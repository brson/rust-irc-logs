[00:00:38] *** Quits: Azdle (Azdle@moz-B334B496.hfc.comcastbusiness.net) (Ping timeout)
[00:00:41] <erickt> graydon: that's easy enough to add
[00:00:44] <strcat> uh, maybe we just don't translate tuples for FFI
[00:00:55] <sully> this pattern matching bug keeps being trickier than I though
[00:00:59] <sully> I was about to say "sigh"
[00:01:08] *** Quits: tchoma (tchoma@moz-BE33DA21.fw1.sfo1.mozilla.net) (Ping timeout)
[00:01:13] <sully> but I actually really like hacking on the pattern matching code.
[00:01:25] <tjc> sully: which pattern matching bug are you working on?
[00:01:32] <tjc> just curious if it's one of the ones I abandoned in despair :-)
[00:02:06] <strcat> rusti: use std::libc::c_int; struct Pair { x: c_int, y: c_int } extern { fn div(n: c_int, d: c_int) -> Pair; } unsafe { div(10, 2) }
[00:02:07] -rusti- {x: 5, y: 0}
[00:02:13] <erickt> graydon: what do you think about CString's optional pointer ownership? Is that something worth keeping?
[00:02:18] <sully> tjc: https://github.com/mozilla/rust/issues/6909
[00:02:25] <strcat> rusti: use std::libc::c_int; extern { fn div(n: c_int, d: c_int) -> (c_int, c_int); } unsafe { div(10, 2) }
[00:02:26] -rusti- (5, 0)
[00:02:28] <sully> tjc: are there more known match codegen bugs?
[00:02:31] <sully> tjc: because I'll take them
[00:02:46] <tjc> sully: yes, https://github.com/mozilla/rust/issues/3121 at least
[00:03:15] *** ozten is now known as ozten|afk
[00:03:33] <dbaupp> sully: https://github.com/mozilla/rust/issues/8021 also ;)
[00:03:51] *** Quits: brendan (brendaneic@moz-BBE3ABD.mv.mozilla.com) (Quit: brendan)
[00:04:16] <tikue> toddaaro: https://intranet.mozilla.org/Summer_INT13
[00:05:14] <dbaupp> sully: there's https://github.com/mozilla/rust/pull/8350 too, btw.
[00:05:29] <erickt> graydon: also, regarding using a small-local temporary array, how can I do that without using a closure?
[00:05:49] <graydon> erickt: it'd be with a closure
[00:06:16] <graydon> erickt: just .. the current idiom in that PR contains a lot of foo.as_c_str().with_ref |bufptr| ...
[00:06:30] <graydon> and I think that's possibly a little chatty / hits malloc, might be nice to avoid both
[00:08:32] <erickt> graydon: I get you now. Yeah, I think it wouldn't be too hard to add `.with_c_str_ref |bufptr| ...` that optionally stack allocates the string
[00:09:21] <sully> tjc: do you have your old partial fix branch anywhere?
[00:09:32] <tjc> sully: Yeah, give me a second
[00:09:33] <graydon> erickt: like, just for the "I need to pass a 10-character filename to fopen()" case, y'know? :)
[00:11:02] <tjc> sully: https://github.com/catamorphism/rust/tree/issue-3121-maturity-5 -- it's not rebased or anything useful like that
[00:11:14] <erickt> graydon: I switched to using malloc to help me track down all the cases where we were accidentally returning an interior pointer with the old `"foo".to_slice().as_c_str(|buf| buf)`. Now that I've fixed all those cases we could go back to using the temporary stack string
[00:12:08] <graydon> erickt: sure. makes sense. *sniff* I miss not being able to write that statically :(
[00:12:14] <strcat> graydon: I think most of the uses are actually incorrect already
[00:12:27] <strcat> because it's using str for paths and env vars, neither of which are necessarily utf-8
[00:13:03] <strcat> and we also incorrectly use str for os::args
[00:13:12] <graydon> there was a PR on that recently
[00:13:16] <strcat> hm
[00:13:18] <graydon> anyway I concur it has to be done better
[00:13:34] <erickt> strcat: I wonder if some day we'll need to adapt CString to work for things like paths and env vars
[00:13:48] <graydon> but it'd be _nice_ if we could offer access to C APIs without having to malloc a lot
[00:13:50] <tikue> hey guys, can someone explain to me what happens to a ChanOne after it's used? if it's a field of a struct, what happens to the struct?
[00:13:54] <strcat> erickt: well, I think Path could enforce the \0 invariant by using CString
[00:14:01] <strcat> rather than str
[00:14:28] <graydon> I might even suggest that if you're converting from &str _and_ the str ends in \0 _and_ the target locale encoding is utf8, then you can pass it through
[00:14:48] <graydon> (since one can always write "hello\0".as_c_str_ref()
[00:14:49] <graydon> )
[00:14:56] <strcat> graydon: you'd be surprised how often that doesn't work well in python3
[00:15:12] <graydon> what do you mean?
[00:15:14] <strcat> lots of times LANG=C (in build chroots, for example) so python3 bails out when you do any utf-8 output
[00:15:20] <engla> Why not use vec inside CString, just like str does (but in a library type)?
[00:15:21] <strcat> really annoying tbh
[00:15:29] <strcat> even if it's more correct
[00:16:16] <graydon> engla: doesn't wrap strings returned-from-C
[00:16:25] *** Quits: maikklein2 (maik@moz-BFE8F4AD.dip0.t-ipconnect.de) (Ping timeout)
[00:16:28] <dbaupp> tikue: I believe the only way to use ChanOne is via methods that take `self`, i.e. consume the struct
[00:16:33] <engla> ah ok, right, it does both those things
[00:16:39] <graydon> strcat: I set LANG=C lots of places, yes.
[00:16:39] <tikue> dbaupp: ok thank you
[00:17:00] <tikue> just wrap it in an option then, if it's a field of a struct
[00:17:03] <graydon> strcat: one could, if one was being extremely fussy, scan for non-ascii as well before re-encoding
[00:17:08] <engla> graydon: you could represent it as a slice
[00:17:20] <dbaupp> tikue: yeah, and use .take(), or something.
[00:17:24] <tikue> yeah :)
[00:18:02] <graydon> engla: sure. but it's not clear there's much of a win there. a CString and a slice are at practically the same level of abstraction. maybe?
[00:19:23] *** Quits: lmandel (lmandel@moz-76CE9D51.cable.teksavvy.com) (Quit: lmandel)
[00:20:17] *** Joins: lmandel (lmandel@moz-76CE9D51.cable.teksavvy.com)
[00:20:56] <engla> Yes using a slice would be a mess. I'm mostly thinking about avoiding malloc and reusing the few core allocation methods (~T and vec)
[00:21:30] <bblum> brson: fyi, i tried lazily initializing KillHandles in addition to Taskgroups, for unlinked tasks, but it doesn't give any noticeable speedup
[00:21:49] <bblum> (i did confirm that they weren't getting initialized in my benchmark)
[00:22:04] <bblum> it makes the code a lot more hard to follow so obviously i'm not going to commit it :P
[00:22:21] <brson> bblum: ok
[00:22:47] <dbaupp> graydon: did you see https://github.com/mozilla/rust/issues/8261? (just putting it on your radar)
[00:24:05] *** Joins: enix (enix@moz-A50569DD.c3-0.slvr-ubr1.lnh-slvr.md.cable.rcn.com)
[00:24:13] <bblum> brson: as a result all i have for you today are cleanup commits: https://github.com/mozilla/rust/pull/8383
[00:24:30] <graydon> dbaupp: yeah. I'm not sure what to do about it!
[00:25:03] <dbaupp> graydon: I like acrichto's suggestion of providing #[inline(never)] extra::test::black_box<T>(_: T) {}
[00:25:03] *** Joins: jeff (jeff@moz-FC89C5BA.nycmny.east.verizon.net)
[00:25:37] <dbaupp> graydon: and so we'd just call that on some value computed by the benchmark.
[00:25:56] <graydon> sure. it's just not clear to me given strcat's statements that that _works_
[00:26:30] <dbaupp> another option is for bh.iter(&fn() -> T), and it just ignores the return value (assuming iter is inline(never) too)
[00:26:32] *** Joins: tautologico (shung@9F01D096.92EA1F6.C27E1635.IP)
[00:26:41] <strcat> for example
[00:27:13] <strcat> count(0, 2).take_while(|x| *x < 1214214).filter(|x| *x % 5 == 0).fold(0, |a, b| a + b)
[00:27:19] <strcat> LLVM will happily constant fold that
[00:27:20] <tjc> graydon: ping
[00:27:39] <graydon> tjc: pong
[00:27:39] <strcat> you have to actually make inputs opaque occasionally
[00:27:55] <tjc> graydon: I've been struggling with figuring out how to nest a workcache context inside a rustpkg context
[00:28:07] <ecr> brson: I think I'm going to have to change how NativeHandle is used to do homed handles. Otherwise we could move homes if from_native_handle is called wrongly.
[00:28:09] <tjc> given that the context has to be able to be referenced inside a ~ closure
[00:28:34] <ecr> brson: particularly in the context of manipulating watcher data (all the callbacks)
[00:28:57] <graydon> strcat: what if we augment BenchmarkHarness with a few helper functions that make inputs opaque and consume outputs? say bouncing inputs off a couple pointers we arrange to alias in a way LLVM won't see, or something?
[00:29:30] <strcat> graydon: they just need a non-#[inline] cross-crate function atm
[00:29:35] <tjc> graydon: I can't figure out how to explain it further without pasting the code, I'll do that
[00:29:36] <strcat> well
[00:29:40] <strcat> I guess that won't work generically :)
[00:29:48] *** Joins: jgilbert (jgilbert@moz-BBE3ABD.mv.mozilla.com)
[00:29:57] <graydon> tjc: please!
[00:30:45] <graydon> tjc: also note: I gotta head out shortly
[00:30:48] <strcat> graydon: if you use #[inline(never)] + give it a side effect (so it's not inferred readnone/readonly) you can use let x = opaque(5); and it won't know what it is
[00:31:03] <graydon> strcat: that sounds helpful.
[00:31:13] <graydon> strcat: we also need something to consume the result, yes?
[00:31:14] <tjc> graydon: https://gist.github.com/catamorphism/6180331 -- this is my current attempt, which doesn't work because I made the workcache-context field in BuildCtx (which is the rustpkg context) an RWArc, but as I discovered, they can't be nested
[00:31:27] <strcat> graydon: yeah but it could likely be the same `opaque` fn
[00:31:37] <tjc> graydon: if you have to leave just say so, it's ok. anyway, no matter what I do, rustc tells me I can't move `ctx` (and other things) inside the closure
[00:31:44] <strcat> #[inline(never)] fn opaque<T>(x: T) -> T { x }
[00:31:50] <strcat> but it needs a side effect
[00:31:52] <tjc> graydon: that is, the closure being passed to prep.exec()
[00:32:03] <brson> ecr: i don't quite understand that. are you putting the scheduler handles inside the Watcher types?
[00:32:12] <strcat> I've been using printfln, but you probably want something it only *thinks* is a side effect
[00:32:23] <strcat> could just do an unsafe write to a global
[00:32:30] <cmr> graydon: can you take a quick look at https://github.com/mozilla/rust/pull/8363 ? If it gets an r+ I'll fold it into my rollup
[00:32:31] <ecr> brson: that was my plan
[00:32:42] <cmr> strcat: and you https://github.com/mozilla/rust/pull/8364 ?
[00:33:03] <graydon> tjc: yeah, non-nesting rwarcs is likely to be a problem. that might require moving the whole thing to ports-and-channels as I feared
[00:33:07] * graydon grumbles
[00:33:11] *** Joins: robarnold (rob@BD56354E.DB510C09.6E370BFC.IP)
[00:33:39] <strcat> cmr: yes, r+
[00:33:59] <ecr> brson: I guess I could homes a wrapper around Watchers but still below the level of uvio.rs
[00:34:02] <brson> ecr: the Watchers don't currently interact with the scheduler - they are at a lower level of abstraction. I/O interacts with the scheduler in uvio, UvTcpListener etc
[00:34:05] <tjc> graydon: so this is actually hard, then… I thought I was just being ignorant and/or slow :-)
[00:34:06] <strcat> cmr: although I don't really think it needs a comment explaining that Integer implies a step of one can reach all elements
[00:34:53] <ecr> brson: right, but the Watchers are just uv_handles, which only make sense in the context of an event loop, which is equivalent to a scheduler
[00:35:20] <graydon> cmr: I can't think through that one, don't understand and honestly don't care _that_ much, have to head out. see if someone else has a strong opinion?
[00:35:30] <erickt> graydon: what do you think about this idea. Once we grow the ability to put regions on types that don't use them, we could write `struct CStringRef<'self>(*c_char)`. Then we could take a function like `fn getenv(*c_char) -> *c_char` and rewrite it to be `fn getenv<'a>(CStringRef<'a>) -> CStringRef<'static>`?
[00:35:57] *** Quits: boredomist (user@moz-63CF9F31.res-cmts.sesp.ptd.net) (Ping timeout)
[00:35:57] <graydon> tjc: no, rwarcs don't nest. why is rustpkg's context in an rwarc?
[00:36:02] <cmr> graydon: basically it paves the way for removing `priv` altogether: when priv is already the default, it just disallows the keyword
[00:36:09] <cmr> I don't really think it's contentious
[00:36:14] <tjc> graydon: rustpkg's context isn't -- let me paste some more code
[00:36:22] <cmr> pcwalton: why did you want graydon's input for https://github.com/mozilla/rust/pull/8363 ?
[00:36:31] <erickt> graydon: it's starting to touch upon the whole "implying things about pointer that we can't guarantee once it hits C land" though
[00:36:32] <graydon> erickt: seems plausible?
[00:36:52] <graydon> erickt: yeah, at some point we must give up and hope C does something reasonable.
[00:36:59] <graydon> I don't mean to make this too much of a burden
[00:37:03] <tjc> graydon: https://gist.github.com/catamorphism/6180370
[00:37:05] <pcwalton> cmr: I wanted to get everyone's input on language design changes.
[00:37:08] <graydon> I think you're on the right path, it might be ok as-is?
[00:37:32] <graydon> pcwalton: is it actually getting us closer to removing priv? if so, are we sure we want that?
[00:37:45] <tjc> graydon: I made the workcache_cx field inside BuildCtx an RWArc because if it was a & or @, I couldn't refer to the context inside the closure that prep.exec takes (since it's a ~fn)
[00:37:50] <cmr> graydon: there's an issue open about it, sec.
[00:37:52] <ecr> brson: I'll move it up to the uvio level
[00:37:58] <cmr> https://github.com/mozilla/rust/issues/8122
[00:38:14] <cmr> Should probably be discussed in a meeting or on the ML
[00:38:35] <pcwalton> I don't think we should remove priv
[00:38:43] <pcwalton> at least, I have not been convinced that we should yet :)
[00:38:52] <graydon> tjc: what if the wordcache_cx is just a field? not a rwarc, but a directly contained field?
[00:38:58] <pcwalton> this is more like: there's no reason to even parse "priv" before items
[00:39:04] <pcwalton> it's just ignored
[00:39:07] <tjc> graydon: I think I tried that, but let me refresh my memory as to what happens
[00:39:13] <graydon> pcwalton cmr: ok. then r+ I guess.
[00:39:19] <pcwalton> in general I don't see a reason to parse things that have no semantic meaning
[00:39:44] <graydon> yeah, agreed
[00:39:46] <graydon> I wasn't sure
[00:40:06] <graydon> tjc: workcache::Context was meant to be used lightweight and clone()'ed when necessary to make new ones.
[00:40:16] <graydon> tjc: it holes all of _its_ fields in rwarcs
[00:40:17] <tjc> graydon: Oh, hmm
[00:40:19] <graydon> *holds
[00:40:24] <strcat> pcwalton: I like private as a default, even for fields - I find we have an endless number of accidentally public fields
[00:40:38] <tjc> graydon: somehow I was thinking that if I cloned one, then work that got cached wouldn't be visible to holders of other copies of it
[00:40:40] <pcwalton> mmm, I'm worried about Point and such
[00:40:58] <strcat> pcwalton: I think once you make a crate, it's okay for exposing the API to be verbose
[00:40:58] <graydon> tjc: no, not at all
[00:40:59] *** Joins: alisdair (textual@moz-FBF4138A.vc.shawcable.net)
[00:41:02] *** Joins: vk (chatzilla@moz-389FEE13.hsd1.ca.comcast.net)
[00:41:03] <strcat> since it's something you want to think about
[00:41:10] <graydon> tjc: they all refer back to the same database, that's why they have rwarcs in them at all
[00:41:15] <strcat> can see why you'd disagree though
[00:41:21] <strcat> there are many structs used just as blobs of data
[00:41:33] <graydon> tjc: I made it so you could pass 'em around and make lots for recursive use. see the testcase in workcache::test
[00:41:41] <strcat> in libstd, I think there are more where fields should be priv than pub
[00:41:47] <graydon> tjc: it does a recursive call by cloning the context and using the clone inside the sub-call
[00:41:59] <tjc> graydon: Yeah, ok
[00:42:23] <graydon> tjc: does that help?
[00:42:34] <brson> ecr: ok, thanks
[00:42:40] <tjc> graydon: yeah. I think I can make some progress now, thanks
[00:43:58] <graydon> tjc: workcache itself should probably gain helper methods for declaring file inputs cheaply
[00:44:16] <graydon> rather than saying declare_input("file", pth.to_str(), digest_file(&pth))
[00:44:51] <graydon> (also for declaring other sorts of dependency like hostname/os, env var / whatever)
[00:44:54] <tjc> graydon: sure
[00:45:00] *** Quits: eatkinson (eatkinson@moz-BBE3ABD.mv.mozilla.com) (Quit: eatkinson)
[00:45:15] *** Quits: true_droid (true_droid@moz-123FD9B8.beck.volia.net) (Client exited)
[00:45:18] *** Quits: infynyxx (infynyxx@DB780A29.749BA1D.DCC373F0.IP) (Client exited)
[00:45:24] <graydon> heading out now, ttyl.
[00:45:30] *** Quits: graydon (Adium@A5087023.2354C43D.D8E68FF6.IP) (Quit: Leaving.)
[00:45:30] <tjc> 'night!
[00:46:37] <sully> welp, found the bug in my thing
[00:46:43] <erickt> graydon: cool. I'll look into it once my PR lands
[00:46:57] *** Joins: Haxkerl (Mibbit@3A8244D5.93384D21.67D94052.IP)
[00:47:05] <sully> protip: "i <= lo && i >= hi" is never the expression you want to be writing
[00:47:28] <tjc> heh
[00:47:29] <strcat> ugh
[00:47:32] <strcat> this was a silly problem
[00:47:43] <strcat> it's just that rustc is making the intrinsic return the tuple via an out pointer ;\
[00:47:49] <Haxkerl> Can I define non-lambda local functions inside main() ?
[00:47:54] <strcat> yes
[00:48:15] <dbaupp> Haxkerl: anything you can put outside a function, you can put inside one too.
[00:48:16] <Haxkerl> strcat: Show me that
[00:48:19] <cmr> rusti: fn foo() -> uint { 42 } foo()
[00:48:20] -rusti- 42
[00:48:25] <cmr> Haxkerl: that's how that works
[00:48:35] <dbaupp> rusti: fn foo() { fn bar() { println("hi") } bar() } foo()
[00:48:36] -rusti- hi
[00:48:36] -rusti- ()
[00:48:47] <cmr> code given to rusti is run like `let r = { YOUR CODE HERE }; printfln!(r)`
[00:49:19] <Haxkerl> dbaupp: Can I do that in rustc?
[00:49:23] <dbaupp> Haxkerl: yes
[00:49:34] <cmr> Haxkerl: rusti-the-bot just compiles with rustc
[00:49:41] *** Joins: wting (wting@moz-250C027.csres.utexas.edu)
[00:49:41] <cmr> rusti-the-program is a different ball of hair
[00:49:54] <strcat> hm, I thought we weren't *always* using a ret ptr anymore for structs
[00:50:02] <strcat> pcwalton: ^ ?
[00:50:09] *** Quits: vosen (vosen@moz-266BA656.icpnet.pl) (Quit: Leaving)
[00:50:15] <pcwalton> strcat: I'm not sure
[00:50:23] <pcwalton> maybe just newtypes?
[00:50:34] <strcat> looks like it
[00:50:45] <strcat> for some reason I thought we'd started returning small ones by-value
[00:51:17] *** Quits: maxli (maxli@B5559308.9C54E60.2FA4EA88.IP) (Quit: Leaving.)
[00:51:44] *** Quits: Haxkerl (Mibbit@3A8244D5.93384D21.67D94052.IP) (Quit: http://www.mibbit.com ajax IRC Client)
[00:54:16] <kmc> what's the new-iterator equivalent of «for 50.times { ...»
[00:54:24] *** Joins: ChrisMorgan (chris@moz-6AC741CA.static.tpgi.com.au)
[00:54:28] <cmr> kmc: do 50.times { ... }
[00:54:33] <kmc> heh ok
[00:54:50] <strcat> kmc: for _ in range(0, 50) {}
[00:55:17] <kmc> I would use the later if I need 'break' to work?
[00:55:25] <strcat> or return, or moves
[00:55:27] <dbaupp> yes
[00:55:44] <cmr> times is on its way out, new code really shouldn't use it
[00:55:49] <strcat> cmr: maybe not
[00:55:57] <strcat> I have a PR open, it's an RFC
[00:56:35] <kmc> yeah I'm not a fan of times
[00:56:59] *** Quits: dherman (dherman@moz-6CA476B1.hsd1.ca.comcast.net) (Quit: dherman)
[00:57:06] <sully> sigh
[00:57:18] <sully> definitely the hardest part of these match fixes
[00:57:24] <sully> is documenting them
[00:57:26] <sully> I could just like
[00:57:29] <sully> imitate the rest of match
[00:57:33] <sully> and not bother
[00:59:33] <strcat> closures as loop bodies are actually a pretty big perf issue, they were only force-inlined for `for` afaict
[00:59:40] <tjc> sully: please document so that the hard work you've put in understanding the code can be used by as many people as possible :-)
[00:59:52] <strcat> if they're small (loop bodies aren't usually), they get inlined
[00:59:53] <sully> tjc: yeah, I know...
[01:00:09] *** Joins: mschifer (Adium@moz-B96B1AE0.public.wayport.net)
[01:00:17] <sully> figuring out how to document this well is just really slow going
[01:00:33] <tjc> I know
[01:01:11] <tjc> I think it's hard to document changes to that code without documenting the entire module, which obviously isn't your responsibility (though if you wanted to, that would be amazing!)
[01:01:36] <sully> I probably do not have it in me to document the whole module
[01:01:38] <sully> we will see
[01:01:44] <sully> I may need to ragerefactor some of it
[01:01:45] *** Quits: q66 (q66@6EE9DE40.46454B5D.33AABD5F.IP) (Quit: Leaving)
[01:01:47] <tjc> haha
[01:01:51] <sully> I am prone to ragerefactoring.
[01:02:00] <tjc> me too, I will use that word for it from now on
[01:02:11] <sully> I'm quite happy with that word.
[01:02:15] <tjc> it's a good one
[01:04:24] <cmr> The best part about working on rustc again is that I can play games while it's compiling
[01:04:51] <eschweic> According to the docs, it is possible to derive IterBytes. Are there any restrictions on this? It doesn't seem to be working on one of my structs
[01:04:53] *** Quits: ecr (Thunderbir@moz-BBE3ABD.mv.mozilla.com) (Quit: ecr)
[01:05:00] <cmr> eschweic: #[deriving(IterBytes)]
[01:05:14] <cmr> Every type your struct includes also needs to implement IterBytes
[01:05:25] <strcat> pcwalton: meh, I'm so confused - there's an out pointer, but out_arg_pos throws a failure due to the ret type being an immediate
[01:05:26] *** Joins: tcr (tcr@moz-1C4F4144.hsd1.ma.comcast.net)
[01:05:29] <cmr> The warnings should be informative.
[01:05:30] <strcat> maybe a bug
[01:05:40] <eschweic> cmr: Ah, okay, thank you
[01:05:41] <pcwalton> hmm
[01:05:43] <cmr> Or, compile errors
[01:05:50] <tjc> cmr: we should measure rustc speed by how complicated a game it's possible to play during rebuilds
[01:05:59] <tjc> we're at chess, we want to be at tic-tac-toe
[01:05:59] * cmr is playing King Arthur's Gold
[01:06:03] <eschweic> I guess [uint, ..2] doesn't implement it then
[01:06:03] <cmr> tjc: that's a good idea though!
[01:06:16] <cmr> eschweic: no, fixed length vecs are kinda second-class right now
[01:06:26] <eschweic> I see
[01:06:37] <cmr> because you can't implement something for every length N
[01:07:01] <eschweic> makes sense
[01:07:07] *** Quits: tcr (tcr@moz-1C4F4144.hsd1.ma.comcast.net) (Ping timeout)
[01:07:39] *** Quits: bjz (brendanzab@B398BE78.F804C29E.D35A31DF.IP) (Quit: Leaving...)
[01:09:48] <aatch> associated constants!
[01:09:58] *** Joins: dherman (dherman@moz-6CA476B1.hsd1.ca.comcast.net)
[01:09:58] *** ChanServ sets mode: +o dherman
[01:10:55] *** Joins: eatkinson (eatkinson@moz-BBE3ABD.mv.mozilla.com)
[01:11:14] <dbaupp> aatch: or just T: uint parameters :)
[01:11:22] <brson> hm android bot isn't actually building android
[01:13:51] <brson> restarting buildbot
[01:14:12] <strcat> dbaupp: if you can use constant exprs based on other constant exprs for the associated consts, I think it then becomes turing complete :s
[01:14:32] <strcat> since you can loop
[01:15:08] <strcat> hm
[01:15:28] *** Quits: igl (igl@moz-BB252A1B.adsl.alicedsl.de) (Connection reset by peer)
[01:15:34] <tikue> iterators don't have .push_front() yet right?
[01:15:38] *** Quits: lmandel (lmandel@moz-76CE9D51.cable.teksavvy.com) (Ping timeout)
[01:15:45] <strcat> tikue: hm?
[01:15:47] <cmr> or ever?
[01:16:00] <tikue> the thing Eridius|vacation had talked about
[01:16:03] <tikue> in the mailing list or something
[01:16:04] *** Quits: rust-buildbot (rust-build@505BFA3.C3CCCE8C.D25A875A.IP) (Quit: buildmaster reconfigured: bot disconnecting)
[01:16:04] *** Joins: rust-buildbot (rust-build@505BFA3.C3CCCE8C.D25A875A.IP)
[01:16:11] <strcat> they can't have it in general
[01:16:16] <tikue> ah
[01:16:20] *** Joins: Azdle (patrick@moz-8C723B60.hsd1.mn.comcast.net)
[01:16:22] *** Quits: hjr3 (hradtke@1A0AE795.28A5F6C3.A2D40ED2.IP) (Quit: My MacBook has gone to sleep. ZZZzzz…)
[01:16:41] *** Joins: Haxkerl (Mibbit@E92B6CFF.24AE4870.CAD5678C.IP)
[01:18:32] *** Quits: Haxkerl (Mibbit@E92B6CFF.24AE4870.CAD5678C.IP) (Quit: http://www.mibbit.com ajax IRC Client)
[01:18:37] <dbaupp> strcat: how do you loop?
[01:19:06] *** Joins: Yurume_ (yurume@AC58A8CE.8A059B47.E313B915.IP)
[01:19:32] <cmr> tjc: do you really think it can get to tic-tac-toe level?
[01:19:44] <tjc> cmr: depends how long you take to play tic-tac-toe...
[01:19:48] <cmr> heh
[01:19:55] <tjc> my benchmark in my mind is GHC, though
[01:20:02] <strcat> dbaupp: with int type params
[01:20:04] <tjc> which is a lot faster to recompile, with a comparably complicated language
[01:20:43] <strcat> struct Foo<T, N> { x: Option<~Foo<T, N + 1>> }
[01:20:44] <tjc> 'night all!
[01:20:46] *** Quits: tjc (tjc@moz-BBE3ABD.mv.mozilla.com) (Quit: Places to go, people to annoy)
[01:20:46] <strcat> something like that anyway...
[01:21:17] <strcat> if you can't use them in const exprs it doesn't matter
[01:21:21] <kmc> GHC also has 20 years of engineering effort put into it
[01:21:25] <strcat> but associated consts would let you do that
[01:22:20] <kmc> aiui the main purpose ofthe native-code (as opposed to registerized via-C) backend was reducing compile times
[01:22:36] <kmc> LLVM didn't exist yet
[01:23:44] *** Joins: jgilbert_ (jgilbert@moz-7B0110AD.mv.mozilla.com)
[01:24:01] *** Joins: panzi (chatzilla@moz-AFD50936.adsl.highway.telekom.at)
[01:24:03] <cmr> We could have fast compiles if we didn't optimize too
[01:24:04] <dbaupp> strcat: right, well, terminating loops are more interesting, and it's not obvious how to do that.
[01:24:18] <dbaupp> cmr: GHC optimises?
[01:24:20] <cmr> We'd just spend a lot less time doing non-optimization/native codegen things..
[01:24:29] <panzi> I have a struct that owns a vec. how do I return this vec (borrowed) from a method?
[01:24:41] <panzi> simply returning it I get: mismatched types: expected `&'a [uint]` but found `~[uint]` ([] storage differs: expected &'a  but found ~)
[01:24:47] *** Quits: jgilbert (jgilbert@moz-BBE3ABD.mv.mozilla.com) (Ping timeout)
[01:24:56] <dbaupp> panzi: call .as_slice()
[01:25:05] <panzi> thx
[01:28:45] <olsonjeffery> are there tickets around improving debug info?
[01:28:52] <cmr> olsonjeffery: not positive
[01:28:55] <olsonjeffery> guess i should just look, heh
[01:29:04] <cmr> there's a GSoC intern working full-time on it though
[01:29:08] *** Joins: maikklein2 (maik@moz-BFE8F4AD.dip0.t-ipconnect.de)
[01:29:13] <cmr> use -Z extra-debug-info to reap the fruit of that work
[01:34:10] *** Quits: pcwalton (pcwalton@moz-7B0110AD.mv.mozilla.com) (Quit: pcwalton)
[01:40:30] *** Quits: mschifer (Adium@moz-B96B1AE0.public.wayport.net) (Quit: Leaving.)
[01:41:00] <panzi> how do I pass a ~Trait to a method that wants a &Trait?
[01:41:24] <dbaupp> cmr: be careful about putting too much stuff into the roll up
[01:41:28] *** Quits: mihneadb (mihneadb@E48845AB.3A9F9BD4.4C2245EF.IP) (Input/output error)
[01:41:36] <cmr> dbaupp: I'm running all the tests locally
[01:41:42] <dbaupp> cmr: oh, ok
[01:41:46] <cmr> for every merge
[01:41:50] <cmr> well, almost every merge
[01:41:55] <cmr> some of them just get a make tidy :p
[01:42:15] <dbaupp> cmr: (also, it makes the benchmarker less useful :) hard to tell what caused the regression/improvement)
[01:42:37] <cmr> Yeah, but my thought on that is that I can add in the merge commits in the override file
[01:43:56] *** Joins: a (Mibbit@E92B6CFF.24AE4870.CAD5678C.IP)
[01:44:37] <sammykim> cmr: Are you working on changing const to static too ? or Doesn't it matter with that commit? ;-) I am talking about that you closed pr8368 just ago ;-)
[01:44:56] <tikue> panzi: I don't know :O) 
[01:45:04] <cmr> sammykim: It's included in my PR bundle to help keep bors with an emptier queue
[01:45:19] <cmr> sammykim: but it's really no issue in the new rustdoc
[01:45:21] *** Joins: erickt1 (Adium@49C4075F.3AC15C18.2321E71E.IP)
[01:45:21] <cmr> http://seld.be/rustdoc/
[01:45:23] <cmr> As a preview
[01:45:55] <cmr> acrichto: you should update your rustc, you use `foreach` in your fmt PR
[01:46:23] <sammykim> cmr: great working : -) impressive!
[01:46:34] *** Quits: a (Mibbit@E92B6CFF.24AE4870.CAD5678C.IP) (Quit: http://www.mibbit.com ajax IRC Client)
[01:46:38] <cmr> sammykim: Seldaek did all the frontend web stuff, I'm just writing the doc extractor
[01:46:40] <panzi> great. also I implemented Eq for a trait and now I try to use == on two ~Trait fields and I get: binary operation == cannot be applied to type `~Expr:Send`
[01:47:16] <cmr> panzi: what is your code?
[01:47:25] <cmr> And why are you using trait objects instead of generics?
[01:48:19] <dbaupp> http://huonw.github.io/isrustfastyet/pull_requests/ :)
[01:48:44] <cmr> dbaupp: woo is that new?
[01:48:45] <sammykim> cmr: Wonderful. I don't want to mess your PR up. I hope to see your new rustdoc soon !
[01:48:46] <aatch> panzi, traits don't automatically implement themselves, i.e., ~Trait doesn't implement Trait (I think, it doesn't seem to be that case all the time)
[01:48:50] <panzi> cmr: that's my unfinised code: http://pastie.org/8217121
[01:49:17] <cmr> aatch: that'd be ~T not implementing the trait that T does implement
[01:49:22] <cmr> different than trait objects.
[01:49:26] <cmr> ...not really sure though
[01:49:26] <aatch> cmr, that's the one
[01:49:46] <aatch> it's a bit... weird. At the moment.
[01:49:46] <jeaye> rusti: let f = ~"  foo  "; let t = f.trim(); f 
[01:49:50] -rusti- pastebinned 8 lines of output: http://sprunge.us/MaZA
[01:50:00] <dbaupp> cmr: just added it, yeah
[01:50:02] <aatch> Because `Trait` isn't a type and [&@~]Trait is.
[01:50:13] <panzi> and how do I compare two enums. == seems not to work
[01:50:26] <aatch> panzi, #[deriving(Eq)] on the enum def
[01:50:27] <jeaye> rusti: let f = ~"  foo  "; let t = f.trim(); t
[01:50:28] -rusti- pastebinned 16 lines of output: http://sprunge.us/cReE
[01:50:30] <cmr> panzi: Do they implement Eq? #[deriving(Eq)] works for simple enums
[01:50:47] <dbaupp> rusti: let f = " foo "; let t = f.trim(); t
[01:50:49] -rusti- "foo"
[01:51:13] <jeaye> dbaupp: What if I'm trimming a ~""?
[01:51:46] <dbaupp> jeaye: it still works, it's just how rusti works
[01:51:54] <jeaye> ah, ok
[01:52:00] <aatch> cmr, I'm guessing it's the operator enums in that code, which are C-style enums
[01:52:07] <acrichto> cmr: oh good point, thanks for the heads-up!
[01:52:17] *** Joins: jviereck (Adium@moz-D4831F8F.dip0.t-ipconnect.de)
[01:52:31] <dbaupp> jeaye: (the code runs in let r = { code here }; printfln!(r), so the lifetime of the ~"" is only the inner block, i.e. it's not long enough for the print.)
[01:52:37] <aatch> jeaye, dbaupp's version works because t is = &'static str
[01:52:41] <acrichto> cmr: you probably don't want to include that in your rollup
[01:52:41] <cmr> acrichto: it'd be cool if you could rebase that PR yourself; if you do it in the next ~15 minutes I'll include it in my rollup, if not I'm backing it out
[01:52:46] <cmr> yeah
[01:52:56] <aatch> (because f is &'static str too)
[01:53:00] <acrichto> cmr: it's a huge change and it'll probably have test failures
[01:53:04] *** Quits: bct (bct@moz-D3BEA05.ed.shawcable.net) (Ping timeout)
[01:53:09] <panzi> so there is no way to use == on two ~Traits?
[01:53:21] <acrichto> cmr: 8322 is an excellent candidate for a rollup though
[01:53:22] <cmr> panzi: is there an impl of Eq for the ~Trait?
[01:53:23] <dbaupp> panzi: no
[01:53:28] <panzi> I want to put these object into a hash set
[01:56:15] *** Joins: samx (sami@moz-48EC0983.dyn.optonline.net)
[01:56:22] <aatch> can't you do `impl Eq for ~Trait { .. }` ?
[01:56:42] <cmr> I'm p[retty sure you can
[01:57:21] <aatch> Since ~Trait is an actual type, so it's no different to implementing it, say, `int`
[01:57:57] <panzi> yes, but then how do I determine wich struct the ~Trait actually is?
[01:58:09] <cmr> panzi: you can't do that with *any* trait object
[01:58:38] *** Quits: eschweic (Adium@moz-BBE3ABD.mv.mozilla.com) (Quit: Leaving.)
[01:58:53] *** Quits: sammykim (Mibbit@B4104EBB.3CC170B1.1E14B209.IP) (Quit: http://www.mibbit.com ajax IRC Client)
[01:58:58] *** Quits: alisdair (textual@moz-FBF4138A.vc.shawcable.net) (Quit: My MacBook Pro has gone to sleep. ZZZzzz…)
[01:59:15] <panzi> yes, so I can't impl Eq for my ~Trait
[01:59:23] <aatch> panzi, you should be able to do (**self).eq(**other)
[01:59:26] <panzi> I do it differently (with enums)
[01:59:35] <aatch> (*self).eq(*other)
[01:59:36] <cmr> Sure you can, you just need to only use the methods the trait provides
[01:59:39] <aatch> (I think)
[01:59:48] <cmr> aatch: you can't dereference a trait object into its underlying struct
[01:59:51] <cmr> it's of unknown size
[02:00:12] <panzi> aatch: I tried "*(self.left) == *(other.left)": error: binary operation == cannot be applied to type `~Expr:Send`
[02:00:40] <aatch> panzi, what if you try calling eq on them?
[02:01:14] *** Joins: snadon (chatzilla@moz-3BC727E8.mc.videotron.ca)
[02:01:20] <panzi> self.left.eq(other.left) -> error: type `~Expr:Send` does not implement any method in scope named `eq`
[02:01:21] *** Quits: thomaslee (thomaslee@moz-6C3931E3.static.twtelecom.net) (Client exited)
[02:01:50] <aatch> Dammit... That's annoying.
[02:02:17] <panzi> but actually expected, if the type information of the objects is gone
[02:03:03] <aatch> I guess it doesn't work because Eq has the same type both sides.
[02:03:05] *** Quits: dherman (dherman@moz-6CA476B1.hsd1.ca.comcast.net) (Quit: dherman)
[02:03:16] *** Quits: Uther (Instantbir@moz-1B244B05.hfc.dyn.abo.bbox.fr) (Ping timeout)
[02:03:20] <cmr> And also because you can't access the underlying object from a trait object
[02:03:40] *** Quits: samx (sami@moz-48EC0983.dyn.optonline.net) (Quit: This computer has gone to sleep)
[02:04:36] <aatch> cmr, yeah, but in theory calling .eq() should work because it should be in the trait object's vtable.
[02:04:47] <cmr> aatch: only if .eq is part of the trait
[02:04:55] <aatch> cmr, in this case it is.
[02:04:59] <cmr> oh
[02:05:01] <cmr> OH
[02:05:09] <cmr> Trait object inheritance is completely broken at
[02:05:11] <cmr> m
[02:05:12] <panzi> but that does nto solve the problem of the type of other
[02:05:15] <aatch> but trait object inheritance doesn't work well
[02:05:52] *** Joins: fndqrqwr (dasdasd@30F5C436.BA106C08.DB9D6342.IP)
[02:05:54] <fndqrqwr> Do skype,yahoo other chat and social communication prog work 2 spoil muslim's youth and spy 4 isreal&usa???????
[02:05:54] <fndqrqwr> do they record and analyse every word we type????????????
[02:05:54] *** Quits: fndqrqwr (dasdasd@30F5C436.BA106C08.DB9D6342.IP) (User has been banned from Mozilla (no spamming here))
[02:05:56] <panzi> look at equals in Java: you have to cast the other parameter
[02:06:14] <engla> implementing Eq on a trait object seems to be crashy
[02:06:37] <aatch> Yeah, I'm trying to think of a decent way around it.
[02:06:48] <cmr> using enums instead of trait objects is a decent workaround
[02:07:01] <erickt1> dbaupp: ping
[02:07:18] <panzi> cmr: but only works if you have a fixed set of things in your "hierarchy"
[02:07:23] <cmr> panzi: right
[02:07:56] <engla> the expression problem
[02:08:25] <panzi> its the case for me here, so I can make it work. but I wonder how one would implement a component system that loads new implementations of other components in rust
[02:08:47] <cmr> not efficiently, that's for sure
[02:09:03] <aatch> panzi, well it would be limited because of the lack of type safety.
[02:10:17] <aatch> You could implement Eq on ~Trait, but all the relevant information would have to be exposed via methods on the trait.
[02:10:35] <aatch> (assuming no bugs)
[02:11:28] <panzi> yeah, I guess one would write higher level interface objects that get passed around and you do QueryInterface like stuff
[02:12:09] <aatch> Can you borrow a trait object yet?
[02:12:17] <cmr> As in &Trait or &~Trait ?
[02:12:23] <aatch> cmr, &Trait
[02:12:38] <aatch> (from @ or ~)
[02:12:41] <cmr> pretty sure yeah
[02:13:43] <aatch> Cool.
[02:14:04] *** Joins: ZeeK (pow@A962E2BB.8FB2E64A.A203EE08.IP)
[02:14:29] *** Parts: ZeeK (pow@A962E2BB.8FB2E64A.A203EE08.IP) ()
[02:15:04] *** Joins: sammykim (Mibbit@B4104EBB.3CC170B1.1E14B209.IP)
[02:16:13] <cmr> I would like to point out that we take almost as long to conver a float to a string as we do to spawn a new task (under the newrt)
[02:16:14] <aatch> This would probably be a bad idea, but `==` could, for trait objects, check to see if the types are same (I.E., check the vtable pointers), then pass the underlying object down to the `eq` method in the vtable.
[02:16:24] <cmr> and that the strconv code is a travesty against mankind.
[02:16:29] <aatch> cmr, yay allocations!
[02:16:36] <maikklein2> can we already send closures?
[02:16:39] <aatch> though float->str isn't trivial.
[02:16:43] <cmr> yeah, it isn't
[02:16:52] <cmr> but it's not just float->str that is that slow
[02:16:53] <aatch> maikklein2, should be able to
[02:16:58] <cmr> maikklein2: only sendable ones
[02:17:02] <cmr> ~fn:Send
[02:17:12] *** Quits: Jesin (Jessin_@moz-1B1307FF.eecs.lehigh.edu) (Quit: Leaving)
[02:17:24] <aatch> (Which is by default every ~fn)
[02:18:05] <maikklein2> ah thanks!
[02:19:53] *** Quits: bnngg (Mibbit@moz-D1E2A18D.dynamic.tstt.net.tt) (Quit: http://www.mibbit.com ajax IRC Client)
[02:20:10] *** Quits: azakai (alon@moz-BBE3ABD.mv.mozilla.com) (Quit: Ex-Chat)
[02:20:40] *** Quits: eatkinson (eatkinson@moz-BBE3ABD.mv.mozilla.com) (Quit: eatkinson)
[02:20:43] *** Quits: jviereck (Adium@moz-D4831F8F.dip0.t-ipconnect.de) (Quit: Leaving.)
[02:21:06] *** Joins: jviereck (Adium@moz-D4831F8F.dip0.t-ipconnect.de)
[02:21:11] <erickt1> come on buildbot… merge in newrt...
[02:21:18] *** Joins: jorendorff (jorendorff@moz-2F32ACA3.hsd1.tn.comcast.net)
[02:21:36] <brson> I think this is attempt 15
[02:21:41] <erickt1> eek
[02:22:09] <aatch> I really want it land, since I'm planning on dusting off my xcb stuff and making a native version.
[02:22:22] <erickt1> brson: green on all but five now!
[02:22:53] <aatch> And having tight integration with the new runtime is a goal for this.
[02:22:53] <cmr> Hm that is quite strang.e.
[02:23:27] *** Joins: eatkinson (eatkinson@moz-BBE3ABD.mv.mozilla.com)
[02:25:02] <panzi> how do I the equivalent to let xs = ~[0, ..n]; where n isn't a constant?
[02:25:13] <aatch> panzi, vec::from_elem
[02:25:14] <cmr> panzi: you don't, you don't use fixed-length vectors for that
[02:25:20] <cmr> since, ya know, not fixed length
[02:25:39] <aatch> cmr, but ~[0, ..n] produces a ~[int]
[02:25:46] <cmr> aatch: no it doesn't
[02:25:55] <cmr> it produces an ~([int, ..n])
[02:25:57] <panzi> cmr: yes, therefore I said the "equivalent"
[02:26:06] <aatch> cmr, oh, I thought it did...
[02:26:20] <aatch> rusti: ~[0,..2]
[02:26:21] -rusti- ~[0, 0]
[02:26:33] <aatch> That wasn't going to work...
[02:26:42] <aatch> rusti: let a : ~[int] = ~[0,..2];
[02:26:43] -rusti- <anon>:5:13: 5:14 warning: unused variable: `a` [-W unused-variable (default)]
[02:26:43] -rusti- <anon>:5          let a : ~[int] = ~[0,..2];
[02:26:44] -rusti-                       ^
[02:26:44] -rusti- ()
[02:26:51] <cmr> hmmmm
[02:26:52] <aatch> cmr, Hey! ^^
[02:27:02] <aatch> rusti: let a : ~[int] = ~[0,..5]; a
[02:27:03] -rusti- ~[0, 0, 0, 0, 0]
[02:27:07] <cmr> rusti: let a : ~([int, ..2]) = ~[0,..2];
[02:27:07] -rusti- <anon>:5:33: 5:41 error: mismatched types: expected `~[int, .. 2]` but found `~[<VI1>]` (expected ~-ptr but found vector)
[02:27:07] -rusti- <anon>:5          let a : ~([int, ..2]) = ~[0,..2];
[02:27:08] -rusti-                                           ^~~~~~~~
[02:27:08] -rusti- error: aborting due to previous error
[02:27:08] -rusti- application terminated with error code 101
[02:27:09] <aatch> rusti: let a : ~[int] = ~([0,..5]); a
[02:27:09] -rusti- <anon>:5:26: 5:37 error: mismatched types: expected `~[int]` but found `~[<VI1>, .. 5]` (expected vector but found ~-ptr)
[02:27:11] -rusti- <anon>:5          let a : ~[int] = ~([0,..5]); a
[02:27:11] *** concrete.mozilla.org sets mode: +M 
[02:27:13] -rusti-                                    ^~~~~~~~~~~
[02:27:13] <cmr> weird!
[02:27:15] -rusti- error: aborting due to previous error
[02:27:15] <cmr> my bad, then
[02:27:17] -rusti- application terminated with error code 101
[02:27:26] <cmr> I feel like I was just playing with this the other day and it was the other way around..
[02:27:43] <aatch> cmr, I thought it was that way round.
[02:28:38] <aatch> cmr, it's parsed as a regular vector expression, where [1,2] is a "raw vector" I think.
[02:29:00] <aatch> The parser does a lookahead for `[` after the sigil.
[02:30:32] <cmr> Ok, I did something very, very wrong, but I'm not quite sure what it was
[02:30:39] <cmr> https://github.com/cmr/rust/tree/big-rollup
[02:30:58] <cmr> Comparing that to mozilla:master shows me two commits
[02:31:15] <cmr> Which... seems to be accurate
[02:31:26] <cmr> but I definitely merged lots of other peoples' PRs into this branch :\
[02:31:44] <cmr> Ohhh I think I just reset it to the wrong place to rollback the fmt PR
[02:31:52] <cmr> #rust: the best rubber duck
[02:32:08] <cmr> Yeah here we are
[02:32:14] *** concrete.mozilla.org sets mode: -M 
[02:33:02] *** Quits: jviereck (Adium@moz-D4831F8F.dip0.t-ipconnect.de) (Quit: Leaving.)
[02:33:20] *** Joins: jviereck (Adium@moz-D4831F8F.dip0.t-ipconnect.de)
[02:33:46] *** Quits: jviereck (Adium@moz-D4831F8F.dip0.t-ipconnect.de) (Quit: Leaving.)
[02:34:24] <acrichto> cmr: does there have to be all those merge commits?
[02:34:41] <cmr> acrichto: There does if I want to keep the history and all the comments on the original PRs
[02:34:51] <cmr> I mean, I can rebase
[02:34:54] <cmr> (Also, don't r+ yet)
[02:35:20] <acrichto> does history beyond authorship matter that much?
[02:35:24] <strcat> cmr: it won't keep the comments or history anyway
[02:35:30] <cmr> Oh it won't?
[02:35:32] <cmr> That's dumb
[02:35:32] <strcat> history of comments/conversation
[02:35:38] * cmr blows it away
[02:35:39] <strcat> no, because after merging their id is changed
[02:35:54] <cmr> it shouldn't be, besides the merge commit?
[02:35:55] <strcat> and even if the id is the same, github tracks comments per repo
[02:36:02] <cmr> oh
[02:36:07] <cmr> still dumb
[02:36:12] <acrichto> github isn't the best code review tool...
[02:36:28] <cmr> sure is convenient though
[02:36:36] <acrichto> very true
[02:36:43] <erickt1> brson: 4 greens :)
[02:37:31] *** Quits: paulproteus (quassel@rose.makesad.us) (Ping timeout)
[02:37:42] *** Quits: lerc (quassel@B2E8CAD3.A8D14E52.788638A4.IP) (Connection reset by peer)
[02:37:46] <acrichto> cmr: you should pull in 8324 as well
[02:38:04] *** Quits: zz_kimundi (kimundi@moz-4F52263A.dip0.t-ipconnect.de) (Ping timeout)
[02:38:06] <acrichto> also 8322
[02:38:14] <acrichto> also 8332
[02:38:17] <acrichto> :D
[02:38:59] *** Joins: infynyxx (infynyxx@moz-E95B370B.nyc.res.rr.com)
[02:39:11] *** Joins: paulproteus (quassel@moz-E86A3B42.makesad.us)
[02:39:20] <cmr> yup got both of those in this next pass through
[02:39:38] <acrichto> cmr: actually these are all good candidates: 8324, 8322, 8332, 8346, 8352
[02:40:29] <brson> erickt1: :)
[02:40:39] *** Quits: jeff (jeff@moz-FC89C5BA.nycmny.east.verizon.net) (Quit: jeff)
[02:41:39] *** Joins: zz_kimundi (kimundi@moz-A60F0B0C.dip0.t-ipconnect.de)
[02:41:45] * brson dinner
[02:41:56] *** zz_kimundi is now known as kimundi
[02:46:52] <acrichto> cmr: also you should probably put the rollup behind 8296 in the queue, but feel free to put it in front of ifmt
[02:48:09] <cmr> If this rollup bounces on windows, I'mma be mad
[02:48:26] <maikklein2> lets say I have a closures like || { // sth} but I want to cosure to capure outer mutable variables, how do I do that? rusts tells me "error: mutable variables cannot be implicitly captured"
[02:48:36] <maikklein2> closure*
[02:50:21] *** Quits: infynyxx (infynyxx@moz-E95B370B.nyc.res.rr.com) (Client exited)
[02:50:25] <aatch> maikklein2, you should be able to implicitly capture with let foo = foo; inside the closure, but I don't know if it works.
[02:50:29] *** Joins: Kruppe (user@moz-E150F49F.cpe.net.cable.rogers.com)
[02:50:34] <aatch> explicitly*
[02:52:10] <acrichto> cmr: well that certainly put a dent in the queue
[02:52:22] <cmr> hopefully bors will be less choked up
[02:52:25] <cmr> tests are running locally
[02:52:34] <cmr> but, preemptive r? https://github.com/mozilla/rust/pull/8385
[02:52:42] <cmr> fb1575b is the head
[02:53:07] <acrichto> r+
[02:53:25] *** Quits: jgilbert_ (jgilbert@moz-7B0110AD.mv.mozilla.com) (Ping timeout)
[02:53:53] <engla> thanks cmr
[02:54:01] <engla> for grabbing those
[02:54:06] <cmr> np
[02:54:20] <engla> any special reason, bors is too slow?
[02:54:24] <cmr> There were a bunch of other PRs which I thought about but decided against because if this bounces I'm going to be really really sad
[02:54:33] <cmr> engla: bors is slow, the queue was huge
[02:55:36] <strcat> cmr: the ids don't all match up ;p
[02:55:37] *** Quits: eatkinson (eatkinson@moz-BBE3ABD.mv.mozilla.com) (Quit: eatkinson)
[02:55:43] <cmr> ugh
[02:55:57] <engla> did you find the right tip to put the r+ on? I'm just idly wondering
[02:56:03] <cmr> yes
[02:56:09] <aatch> git show
[02:56:14] <engla> since github doesn't care about topological order
[02:56:20] *** Joins: eatkinson (eatkinson@moz-BBE3ABD.mv.mozilla.com)
[02:56:27] <engla> ok
[02:59:25] <panzi> I have a &Struct. how do I get a cloned ~Struct from that?
[02:59:36] <cmr> panzi: implement Clone for Struct
[02:59:41] <cmr> then just do s.clone()
[02:59:45] <cmr> ~s.clone(), rather
[03:00:18] *** Joins: dherman (dherman@moz-6CA476B1.hsd1.ca.comcast.net)
[03:00:18] *** ChanServ sets mode: +o dherman
[03:00:28] *** Quits: brson (brson@moz-BBE3ABD.mv.mozilla.com) (Ping timeout)
[03:00:36] *** Joins: jviereck (Adium@moz-D4831F8F.dip0.t-ipconnect.de)
[03:00:59] <strcat> or just ~*s if it has no destructor/&mut
[03:02:29] <panzi> great, thanks!
[03:05:25] *** Joins: maikklein3 (maik@moz-5AED6CF8.dip0.t-ipconnect.de)
[03:06:05] <cmr> "In particular, if the allocation is being made in response to a system call, the kernel will just cause the system call to fail with an ENOMEM error rather than trying to find a process to kill. That may cause system call failures to happen more often and in different contexts than they used to. But, naturally, that will not be a problem since all user-space code diligently checks the return
[03:06:07] <cmr> status of every system call and responds with well-tested error-handling code when things go wrong. "
[03:06:11] <cmr> (from this week's LWN)
[03:06:33] *** Quits: maikklein2 (maik@moz-BFE8F4AD.dip0.t-ipconnect.de) (Ping timeout)
[03:06:47] <erickt1> cmr: that's awesome
[03:06:56] *** Joins: int3_ (int3_@moz-6F0859B8.dsl.pltn13.sbcglobal.net)
[03:07:05] *** Joins: tcr (tcr@moz-EE576D3C.hsd1.ma.comcast.net)
[03:07:29] *** Quits: jviereck (Adium@moz-D4831F8F.dip0.t-ipconnect.de) (Quit: Leaving.)
[03:07:55] <cmr> OOM has always been nasty, but I'm not sure if this makes it better, overall. Rather than killing a random process, you're crashing a random process :p
[03:08:49] <strcat> "random"
[03:09:34] * strcat finds the full overcommit setting saner because at least you can exclude trusted processes or give them better ratios
[03:09:36] *** Quits: int3_ (int3_@moz-6F0859B8.dsl.pltn13.sbcglobal.net) (Client exited)
[03:10:13] *** Quits: richard_s (mindginati@moz-C1729134.dsl.clear.net.nz) (Quit: zzZZZ)
[03:10:54] *** Quits: SiegeLord (sl@moz-CAF07B4C.hsd1.ma.comcast.net) (Connection reset by peer)
[03:10:59] <panzi> using ~*s did not work (cannot move out of dereference of & pointer) so I used s.clone()
[03:12:49] <engla> cmr: it's a distributed fuzz test
[03:12:56] <maikklein3> "error: mutable variables cannot be implicitly captured" will this stay? 
[03:14:49] <maikklein3> oh nvm it actually makes sense
[03:15:37] <strcat> dbaupp: https://github.com/thestinger/rust/compare/checked sadly, it's broken atm
[03:15:41] <strcat> I think I'm returning wrong
[03:16:22] <cmr> I really like that we run benchmarks now
[03:16:29] <cmr> remind me to give graydon more praise
[03:16:35] *** Joins: mark_edward (quassel@moz-57A72B6E.hsd1.in.comcast.net)
[03:17:28] *** Joins: mark_edward_ (quassel@981AA104.E81F12CD.76F66111.IP)
[03:17:34] <ChrisMorgan> cmr: at what interval?
[03:17:43] <cmr> ChrisMorgan: hm?
[03:17:57] <ChrisMorgan> How often do you wish to be reminded?
[03:17:59] <cmr> Oh
[03:18:02] <cmr> Hmm
[03:18:13] <cmr> I suppose 4 times daily is plenty ;p
[03:18:16] *** Quits: mark_edward (quassel@moz-57A72B6E.hsd1.in.comcast.net) (Ping timeout)
[03:20:36] <cmr> dbaupp: I'll do more work on the bencher tomorrow, hopefully finishing at least the builders to get 8 builds going at once
[03:20:55] <cmr> acrichto: r+ again? https://github.com/mozilla/rust/pull/8385
[03:21:04] <acrichto> cmr: feel free to r=me
[03:21:05] <cmr> acrichto: had to fix some test failures (that you introduced!)
[03:21:07] <cmr> ok
[03:21:09] <acrichto> :(
[03:21:13] *** Quits: dherman (dherman@moz-6CA476B1.hsd1.ca.comcast.net) (Quit: dherman)
[03:21:38] <acrichto> darn priv
[03:21:46] <acrichto> thanks though :)
[03:21:49] <cmr> np
[03:21:58] *** Joins: sntxrr (Mibbit@E92B6CFF.24AE4870.CAD5678C.IP)
[03:22:29] *** Quits: eatkinson (eatkinson@moz-BBE3ABD.mv.mozilla.com) (Quit: eatkinson)
[03:22:42] <sntxrr> What does this mean? "Tree is CLOSED for maintenance"
[03:22:59] <cmr> sntxrr: pull requests aren't being automatically integrated, to help the new runtime land faster.
[03:23:18] <cmr> speaking of, one builder left! \o/
[03:23:43] <sntxrr> cmr: What runtime is it?
[03:26:01] <maikklein3> cmr, btw thanks for mentioning sdl, it was exactly what I was looking for
[03:26:21] <erickt1> ack! found a test error with #8296 when merged with head! can someone do a quick r+ of https://github.com/mozilla/rust/pull/8296?
[03:27:16] <erickt1> strcat / cmr / etc: ^
[03:27:56] <sntxrr> rusti: |x,y,z| x*x+y*y*y+z*z*z*z
[03:27:59] -rusti- pastebinned 11 lines of output: http://sprunge.us/YOQJ
[03:28:04] *** Joins: dherman (dherman@moz-6CA476B1.hsd1.ca.comcast.net)
[03:28:04] *** ChanServ sets mode: +o dherman
[03:28:44] *** Quits: tautologico (shung@9F01D096.92EA1F6.C27E1635.IP) (Quit: tautologico)
[03:28:58] <erickt1> nevermind, reviewed it myself to make sure it gets picked up by bors
[03:28:58] *** Joins: tautologico (shung@9F01D096.92EA1F6.C27E1635.IP)
[03:29:08] <sntxrr> rusti: {}
[03:29:09] -rusti- ()
[03:29:34] <sntxrr> rusti: not ()
[03:29:35] -rusti- <anon>:5:9: 5:12 error: unresolved name `not`.
[03:29:35] -rusti- <anon>:5          not ()
[03:29:35] -rusti-                   ^~~
[03:29:35] -rusti- error: aborting due to previous error
[03:29:35] -rusti- application terminated with error code 101
[03:31:03] <panzi> is there a quick & easy way to make the elements of an &[uint] unique? (create a copy with unique elements)
[03:31:28] <erickt1> panzi: you could throw them in a HashSet
[03:31:48] *** Quits: sntxrr (Mibbit@E92B6CFF.24AE4870.CAD5678C.IP) (Quit: http://www.mibbit.com ajax IRC Client)
[03:31:52] *** Joins: ghrust (ghrust@CFE85B59.6A2AE50.F3114085.IP)
[03:31:52] <ghrust> 01[13rust01] 15bors merged 06auto into 06master: 02http://git.io/DgPwWg
[03:31:52] *** Parts: ghrust (ghrust@CFE85B59.6A2AE50.F3114085.IP) ()
[03:32:14] *** Quits: mcpherrin (mimcpher@moz-21D6B3DE.csclub.uwaterloo.ca) (Quit: leaving)
[03:32:31] *** Joins: mcpherrin (mimcpher@moz-21D6B3DE.csclub.uwaterloo.ca)
[03:32:55] <panzi> erickt1: inserting the elements one by one. do I see it right, that there isn't a method that does that for me?
[03:33:25] *** Quits: dherman (dherman@moz-6CA476B1.hsd1.ca.comcast.net) (Quit: dherman)
[03:34:15] *** Joins: jaen (jaen@moz-E0979827.copit.pl)
[03:34:51] *** Joins: ghrust (ghrust@5FEF1C87.6A2AE50.F3114085.IP)
[03:34:51] <ghrust> 01[13rust01] 15bors pushed 0 new commits to 06auto: 02http://git.io/-_Wh1w
[03:34:51] *** Parts: ghrust (ghrust@5FEF1C87.6A2AE50.F3114085.IP) ()
[03:34:57] *** Joins: ghrust (ghrust@FD7BC443.6A2AE50.F3114085.IP)
[03:34:57] <ghrust> 01[13rust01] 15bors pushed 27 new commits to 06auto: 02http://git.io/IlfvvA
[03:34:57] <ghrust> 13rust/06auto 146011f83 15Erick Tryzelaar: std: minor cleanup
[03:34:57] <ghrust> 13rust/06auto 1408b6cb4 15Erick Tryzelaar: std: add str.to_c_str()
[03:34:57] <ghrust> 13rust/06auto 14fd293df 15Erick Tryzelaar: std: rewrite run::with_{argv,envp,dirp} to copy C strings
[03:34:57] *** Parts: ghrust (ghrust@FD7BC443.6A2AE50.F3114085.IP) ()
[03:36:25] <erickt1> phew, got it in
[03:36:43] *** Quits: diegoyam (quassel@FF9B1514.A4EC3D18.3A1EC144.IP) (Ping timeout)
[03:37:10] <panzi> is there something like pythons enumerate in rust?
[03:37:36] <acrichto> panzi: there's an enumerate method on iterators
[03:37:53] <erickt1> panzi: you may be able to do `FromIterator::from_iterator::<~[int]>(HashSet::from_iterator(myvec.iter()))`
[03:38:46] *** Quits: Nisstyre (wes@moz-FD86289.netflash.net) (Quit: Leaving)
[03:39:18] <erickt1> ack! what the heck happened here? http://buildbot.rust-lang.org/builders/auto-linux-64-x-android/builds/5/steps/compile/logs/stdio
[03:39:20] <acrichto> uh oh, every request is about to bounce
[03:39:54] <panzi> erickt1: unresolved name `HashSet::from_iterator
[03:40:07] <erickt1> panzi: do "use hashmap::HashSet"
[03:40:10] <engla> panzi: .collect() on iterators
[03:40:18] <panzi> erickt1: I did use std::hashmap::HashSet;
[03:40:18] <erickt1> acrichto: are you referring to bors?
[03:40:28] <acrichto> erickt1: yeah, if the arm bot is broken :(
[03:40:51] *** Joins: ghrust (ghrust@614D05BD.6A2AE50.F3114085.IP)
[03:40:51] <ghrust> 01[13rust01] 15bors 04force-pushed 06auto from 14a608de6 to 149db698a: 02http://git.io/N3iJvQ
[03:40:51] *** Parts: ghrust (ghrust@614D05BD.6A2AE50.F3114085.IP) ()
[03:40:53] *** Joins: ghrust (ghrust@E7A4CCE2.6A2AE50.F3114085.IP)
[03:40:53] <ghrust> 01[13rust01] 15bors pushed 28 new commits to 06auto: 02http://git.io/mZIWug
[03:40:53] <ghrust> 13rust/06auto 14026c1ae 15blake2-ppc: extra: Remove all .each methods in smallintmap
[03:40:53] <ghrust> 13rust/06auto 1440bdbf0 15blake2-ppc: std: Fix for-range loops that can use iterators...
[03:40:54] <ghrust> 13rust/06auto 14e7d4a9c 15blake2-ppc: Bugfix .each_edge in middle/graph.rs...
[03:40:56] *** Parts: ghrust (ghrust@E7A4CCE2.6A2AE50.F3114085.IP) ()
[03:41:40] <erickt1> panzi: sorry, I meant `FromIterator::from_iterator::<~[int]>(FromIterator::from_iterator::<HashSet::<int>>(myvec.iter()).iter())`
[03:41:49] <engla> erickt1: what is this? :)
[03:41:52] *** Quits: maikklein3 (maik@moz-5AED6CF8.dip0.t-ipconnect.de) (Ping timeout)
[03:41:59] <erickt1> ugh, I missed my merge window. stupid android
[03:42:58] <erickt1> does anyone remember how to retry a build? `@bors: retry` on a commit?
[03:42:59] <engla> panzi, to make a hashset from an iterator you'd use   myvec.iter().transform(|&x| x).collect::<HashSet<uint>>()
[03:43:23] <engla> erickt1: a reviewer must put in the retry comment
[03:43:36] *** Joins: maikklein3 (maik@moz-5AED6CF8.dip0.t-ipconnect.de)
[03:44:05] <acrichto> erickt1: I don't think it'll work though, the next request is about to bounce and I think it'll continue to do so
[03:44:12] <erickt1> bah
[03:44:37] <strcat> we can disable the android bot
[03:44:42] <strcat> and manually merge when the others pass
[03:45:06] <acrichto> strcat: how so?
[03:45:31] <strcat> there
[03:45:45] <acrichto> ah
[03:46:13] *** Quits: jorendorff (jorendorff@moz-2F32ACA3.hsd1.tn.comcast.net) (Quit: jorendorff)
[03:46:51] *** Joins: ghrust (ghrust@9C8B94D4.6A2AE50.F3114085.IP)
[03:46:51] <ghrust> 01[13rust01] 15bors 04force-pushed 06auto from 14e84dc56 to 149db698a: 02http://git.io/N3iJvQ
[03:46:51] *** Parts: ghrust (ghrust@9C8B94D4.6A2AE50.F3114085.IP) ()
[03:46:51] *** Joins: ghrust (ghrust@DE823A67.6A2AE50.F3114085.IP)
[03:46:51] <ghrust> 01[13rust01] 15bors pushed 27 new commits to 06auto: 02http://git.io/hp5aJw
[03:46:51] <ghrust> 13rust/06auto 146011f83 15Erick Tryzelaar: std: minor cleanup
[03:46:51] <ghrust> 13rust/06auto 1408b6cb4 15Erick Tryzelaar: std: add str.to_c_str()
[03:46:51] <ghrust> 13rust/06auto 14fd293df 15Erick Tryzelaar: std: rewrite run::with_{argv,envp,dirp} to copy C strings
[03:46:52] *** Parts: ghrust (ghrust@DE823A67.6A2AE50.F3114085.IP) ()
[03:46:55] <panzi> .enumerate().map(...) says Enumerator has no map. how do I do the equivalent?
[03:47:11] <strcat> it's temporarily called transform as a workaround
[03:47:26] <strcat> you can see the methods listed in the iterator module
[03:51:24] *** Joins: jorendorff (jorendorff@moz-2F32ACA3.hsd1.tn.comcast.net)
[03:52:02] *** Joins: bct (bct@moz-D3BEA05.ed.shawcable.net)
[03:55:50] *** Joins: ghrust (ghrust@DE823A67.6A2AE50.F3114085.IP)
[03:55:50] <ghrust> 01[13rust01] 15bors 04force-pushed 06auto from 14854824a to 149db698a: 02http://git.io/N3iJvQ
[03:55:50] *** Parts: ghrust (ghrust@DE823A67.6A2AE50.F3114085.IP) ()
[03:55:52] *** Joins: ghrust (ghrust@AD60B2E3.6A2AE50.F3114085.IP)
[03:55:52] <ghrust> 01[13rust01] 15bors pushed 28 new commits to 06auto: 02http://git.io/bble2g
[03:55:52] <ghrust> 13rust/06auto 14026c1ae 15blake2-ppc: extra: Remove all .each methods in smallintmap
[03:55:52] <ghrust> 13rust/06auto 1440bdbf0 15blake2-ppc: std: Fix for-range loops that can use iterators...
[03:55:53] <ghrust> 13rust/06auto 14e7d4a9c 15blake2-ppc: Bugfix .each_edge in middle/graph.rs...
[03:55:55] *** Parts: ghrust (ghrust@AD60B2E3.6A2AE50.F3114085.IP) ()
[03:56:13] *** Quits: jorendorff (jorendorff@moz-2F32ACA3.hsd1.tn.comcast.net) (Quit: jorendorff)
[03:58:10] *** Joins: Jesin (Jessin_@moz-3AD6F09F.res.lehigh.edu)
[03:59:55] *** Quits: jaen (jaen@moz-E0979827.copit.pl) (Ping timeout)
[04:02:34] *** Quits: panzi (chatzilla@moz-AFD50936.adsl.highway.telekom.at) (Quit: ChatZilla 0.9.90.1 [Firefox 22.0/20130624150515])
[04:02:43] *** Joins: brson (brson@moz-BBE3ABD.mv.mozilla.com)
[04:02:43] *** ChanServ sets mode: +o brson
[04:05:04] <brson> android bot is not working
[04:05:20] <acrichto> brson: strcat turned it off
[04:05:29] <acrichto> http://buildbot.rust-lang.org/builders/auto-linux-64-x-android/builds/5
[04:05:33] <strcat> brson: it was broken
[04:05:47] <brson> how did strcat turn it off?
[04:05:57] <strcat> brson: there's a graceful shutdown on the buildbot UI
[04:06:24] <strcat> (just of the buildbot client)
[04:06:40] <brson> how do i turn it back on?
[04:07:16] <strcat> brson: I think you just need to restart the client? something is wrong with the workspace though
[04:10:41] <brson> the script is wrong
[04:16:46] *** Joins: mindginative (mindginati@moz-7AB462BB.dyn.cust.vf.net.nz)
[04:17:50] *** Quits: rust-buildbot (rust-build@505BFA3.C3CCCE8C.D25A875A.IP) (Quit: buildmaster reconfigured: bot disconnecting)
[04:17:50] *** Joins: rust-buildbot (rust-build@505BFA3.C3CCCE8C.D25A875A.IP)
[04:18:15] *** Quits: brson (brson@moz-BBE3ABD.mv.mozilla.com) (Quit: leaving)
[04:18:18] *** Joins: brson (brson@moz-BBE3ABD.mv.mozilla.com)
[04:18:19] *** ChanServ sets mode: +o brson
[04:18:44] <brson> erickt1: sorry i cut in line on bors' queue
[04:19:59] *** Quits: Azdle (patrick@moz-8C723B60.hsd1.mn.comcast.net) (Ping timeout)
[04:20:07] <brson> brendanc: can i bring a build slave back online after it's done a 'graceful shutdown'?
[04:20:28] <brson> w/o restarting the buildmaster
[04:22:18] <strcat> brson: afaik it should just connect if you restart it, at least that's what I think graydon did before
[04:22:37] <enix> So, I have 3 rust AES implementations: an AES-NI implementation that runs at 1.3GB/s; a timing attack vulnerable software one at 120MB/s; and a fixed time software one at a whopping 5MB/s
[04:22:45] <brson> strcat: restart the buildmaster?
[04:22:49] *** Quits: rust-buildbot (rust-build@505BFA3.C3CCCE8C.D25A875A.IP) (Quit: buildmaster reconfigured: bot disconnecting)
[04:22:58] <strcat> brson: the slave
[04:23:09] <enix> i'd like to post this stuff for comments sometime soon, but, 5MB/s is super, duper slow. Would such slow code be mergable? Would it make sense to post for comments before its mergable?
[04:23:15] <brson> ec2 slaves are started by the buildmaster
[04:23:21] <strcat> ah right the ec2 ones
[04:23:58] <strcat> don't know what it's supposed to do there.
[04:23:59] *** Joins: rust-buildbot (rust-build@505BFA3.C3CCCE8C.D25A875A.IP)
[04:24:12] <brson> restarted the buildmaster. it was between builds anyway
[04:24:53] <strcat> cmr: windows failed
[04:27:33] <brson> enix: hand-rolled cyphers are going to get a lot of resistence
[04:27:39] <brson> er, ciphers
[04:28:26] <brson> regardless of the perf
[04:28:32] <brson> sorry to be so blunt
[04:28:48] <brson> I'm not sure if we've seen any pull requests for ciphers
[04:28:52] *** Joins: ghrust (ghrust@614D05BD.6A2AE50.F3114085.IP)
[04:28:52] <ghrust> 01[13rust01] 15bors 04force-pushed 06auto from 144755a50 to 149db698a: 02http://git.io/N3iJvQ
[04:28:52] *** Parts: ghrust (ghrust@614D05BD.6A2AE50.F3114085.IP) ()
[04:29:29] *** Quits: jeaye (Jeaye@moz-FD505E54.hsd1.ca.comcast.net) (Quit: Don't tell them I was here...)
[04:30:23] <enix> i have been warned on that before, so, i know i'm going into difficult territory
[04:31:40] <acrichto> cmr: I forgot to xfail-fast an aux-build test
[04:31:48] <enix> but, rust already has various Digests (some of which I've written) which also have significant security implications
[04:32:24] <enix> the biggest difference between Sha2 and AES doesn't seem to be that either one is more or less significant to security
[04:32:38] <acrichto> brson: it looks like all bots are configuring for arm now
[04:32:42] <acrichto> http://buildbot.rust-lang.org/builders/auto-linux-64-nopt/builds/839/steps/configure/logs/stdio
[04:33:05] <brson> yeah, i broke things even worse
[04:33:06] <brson> sorry
[04:33:17] *** Quits: rusti (rusti@moz-54F7FD49.cpe.net.cable.rogers.com) (Ping timeout)
[04:33:18] <enix> but that AES (and DES), obnoxiously, are difficult to implement without introducing various timing attacks, which is why i've been working on an implementation that is simple to verify that is not timing dependant
[04:33:19] *** Quits: strcat (strcat@moz-54F7FD49.cpe.net.cable.rogers.com) (Ping timeout)
[04:33:24] <acrichto> brson: deleting 6k lines makes up for it :)
[04:33:44] * ChrisMorgan had the joy of implementing DES in Java last semester
[04:34:02] *** Quits: maikklein3 (maik@moz-5AED6CF8.dip0.t-ipconnect.de) (Ping timeout)
[04:34:34] *** Quits: tautologico (shung@9F01D096.92EA1F6.C27E1635.IP) (Quit: tautologico)
[04:34:51] *** Joins: ghrust (ghrust@E7A4CCE2.6A2AE50.F3114085.IP)
[04:34:51] <ghrust> 01[13rust01] 15bors 04force-pushed 06auto from 148796f39 to 149db698a: 02http://git.io/N3iJvQ
[04:34:51] *** Parts: ghrust (ghrust@E7A4CCE2.6A2AE50.F3114085.IP) ()
[04:34:53] *** Joins: ghrust (ghrust@5FEF1C87.6A2AE50.F3114085.IP)
[04:34:53] <ghrust> 01[13rust01] 15bors pushed 28 new commits to 06auto: 02http://git.io/LjwyHQ
[04:34:53] <ghrust> 13rust/06auto 146011f83 15Erick Tryzelaar: std: minor cleanup
[04:34:53] <ghrust> 13rust/06auto 1408b6cb4 15Erick Tryzelaar: std: add str.to_c_str()
[04:34:53] <ghrust> 13rust/06auto 14fd293df 15Erick Tryzelaar: std: rewrite run::with_{argv,envp,dirp} to copy C strings
[04:34:54] *** Parts: ghrust (ghrust@5FEF1C87.6A2AE50.F3114085.IP) ()
[04:37:22] <enix> and if the concern is immunity to timing attacks, neither OpenSSL or NSS really give you that - all they've really done is patched around the last set of timing attacks that were published
[04:37:29] *** Quits: rust-buildbot (rust-build@505BFA3.C3CCCE8C.D25A875A.IP) (Quit: buildmaster reconfigured: bot disconnecting)
[04:37:30] *** Joins: rust-buildbot (rust-build@505BFA3.C3CCCE8C.D25A875A.IP)
[04:37:43] <brson> ok, this time the android build will work
[04:38:09] <brson> i'll lower the priority of my c++ change. it's not that important
[04:39:11] *** Joins: bjz (brendanzab@B398BE78.F804C29E.D35A31DF.IP)
[04:39:11] <enix> anyway, I know I'm trying to make a difficult case
[04:39:32] <brson> enix: it can't hurt to make a pr
[04:40:13] <enix> yeah, I'm not really ready quite yet. prob another week or so (i'm on vacation the next few days and won't have free time for playing with this)
[04:40:50] *** Joins: ghrust (ghrust@AD60B2E3.6A2AE50.F3114085.IP)
[04:40:50] <ghrust> 01[13rust01] 15bors 04force-pushed 06auto from 14bc97f11 to 149db698a: 02http://git.io/N3iJvQ
[04:40:50] *** Parts: ghrust (ghrust@AD60B2E3.6A2AE50.F3114085.IP) ()
[04:40:52] *** Joins: ghrust (ghrust@C8693FCB.6A2AE50.F3114085.IP)
[04:40:52] <ghrust> 01[13rust01] 15bors pushed 2 new commits to 06auto: 02http://git.io/RPN5CQ
[04:40:52] <ghrust> 13rust/06auto 14ffb670f 15Alex Crichton: Add initial support for a new formatting syntax...
[04:40:52] <ghrust> 13rust/06auto 142764d97 15bors: auto merge of #8245 : alexcrichton/rust/fmt2, r=graydon...
[04:40:53] *** Parts: ghrust (ghrust@C8693FCB.6A2AE50.F3114085.IP) ()
[04:40:55] *** Quits: tikue (tkuehn@moz-BBE3ABD.mv.mozilla.com) (Quit: tikue)
[04:41:02] *** Quits: engla (engla@moz-DBD1D96E.cust.bredbandsbolaget.se) (Ping timeout)
[04:41:07] <enix> i was mainly just asking to see if 5MB/s makes my case unwinable before I even get to my other points.
[04:41:30] <bjz> rusti: fn f<T>(g: &fn(int) -> T) -> T { g(1) } fn u() -> int { do f |x| { return 1; } } u()
[04:41:53] *** Joins: mihneadb (mihneadb@E48845AB.3A9F9BD4.4C2245EF.IP)
[04:41:53] *** Joins: hjr3 (hradtke@moz-E87BDF1F.socal.res.rr.com)
[04:42:04] *** Quits: geomyidae (geomyidae@DD6F7E3A.21468E9A.30200F38.IP) (Client exited)
[04:42:24] <brson> enix: how does that compare to C?
[04:43:11] *** Joins: strcat (strcat@moz-54F7FD49.cpe.net.cable.rogers.com)
[04:43:23] *** Joins: tikue (tkuehn@moz-BBE3ABD.mv.mozilla.com)
[04:43:29] *** Joins: rusti (rusti@moz-54F7FD49.cpe.net.cable.rogers.com)
[04:43:33] *** Quits: mihneadb (mihneadb@E48845AB.3A9F9BD4.4C2245EF.IP) (Ping timeout)
[04:43:40] <enix> compared to completely timing attack free versions of AES in C? I haven't yet been able to find one (except a specialized AES-CTR only implementation)
[04:44:06] <enix> but, 5MB/s is about an order of magnitude slower than OpenSSL or NSS's implementations
[04:44:16] *** Joins: geomyidae (geomyidae@DD6F7E3A.21468E9A.30200F38.IP)
[04:44:29] <enix> though, those implementations use lookup tables, so, aren't immune to timing attacks
[04:44:49] <enix> I don't have exact number on there performance, but, i'd guess in the 100MB/s - 250MB/s range
[04:45:20] <enix> my lookup table implementation gets 127MB/s, but is super vulnerable to timing attacks
[04:46:21] <brson> uh oh buildbot still broken
[04:46:27] <brson> maybe i'm too tired to be doing this
[04:46:51] *** Joins: ghrust (ghrust@5FEF1C87.6A2AE50.F3114085.IP)
[04:46:51] <ghrust> 01[13rust01] 15bors 04force-pushed 06auto from 142764d97 to 149db698a: 02http://git.io/N3iJvQ
[04:46:51] *** Parts: ghrust (ghrust@5FEF1C87.6A2AE50.F3114085.IP) ()
[04:46:52] *** Joins: ghrust (ghrust@DE823A67.6A2AE50.F3114085.IP)
[04:46:53] <ghrust> 01[13rust01] 15bors pushed 28 new commits to 06auto: 02http://git.io/SDdMww
[04:46:53] <ghrust> 13rust/06auto 146011f83 15Erick Tryzelaar: std: minor cleanup
[04:46:53] <ghrust> 13rust/06auto 1408b6cb4 15Erick Tryzelaar: std: add str.to_c_str()
[04:46:53] <ghrust> 13rust/06auto 14fd293df 15Erick Tryzelaar: std: rewrite run::with_{argv,envp,dirp} to copy C strings
[04:46:53] *** Parts: ghrust (ghrust@DE823A67.6A2AE50.F3114085.IP) ()
[04:47:07] <brson> this time it'll work
[04:47:11] *** Quits: rust-buildbot (rust-build@505BFA3.C3CCCE8C.D25A875A.IP) (Quit: buildmaster reconfigured: bot disconnecting)
[04:47:11] *** Joins: rust-buildbot (rust-build@505BFA3.C3CCCE8C.D25A875A.IP)
[04:51:05] *** Quits: rust-buildbot (rust-build@505BFA3.C3CCCE8C.D25A875A.IP) (Quit: buildmaster reconfigured: bot disconnecting)
[04:51:05] *** Joins: rust-buildbot (rust-build@505BFA3.C3CCCE8C.D25A875A.IP)
[04:51:50] <brson> sike
[04:51:52] <brson> this time
[04:52:50] *** Joins: ghrust (ghrust@C8693FCB.6A2AE50.F3114085.IP)
[04:52:50] <ghrust> 01[13rust01] 15bors 04force-pushed 06auto from 14f07a1a5 to 149db698a: 02http://git.io/N3iJvQ
[04:52:50] *** Parts: ghrust (ghrust@C8693FCB.6A2AE50.F3114085.IP) ()
[04:52:54] *** Joins: ghrust (ghrust@AD60B2E3.6A2AE50.F3114085.IP)
[04:52:54] <ghrust> 01[13rust01] 15bors pushed 28 new commits to 06auto: 02http://git.io/BBg3mA
[04:52:54] <ghrust> 13rust/06auto 146011f83 15Erick Tryzelaar: std: minor cleanup
[04:52:54] <ghrust> 13rust/06auto 1408b6cb4 15Erick Tryzelaar: std: add str.to_c_str()
[04:52:54] <ghrust> 13rust/06auto 14fd293df 15Erick Tryzelaar: std: rewrite run::with_{argv,envp,dirp} to copy C strings
[04:52:55] *** Parts: ghrust (ghrust@AD60B2E3.6A2AE50.F3114085.IP) ()
[04:53:15] *** Quits: strcat (strcat@moz-54F7FD49.cpe.net.cable.rogers.com) (Quit: sleep)
[04:54:32] *** Joins: maikklein3 (maik@moz-5AED6CF8.dip0.t-ipconnect.de)
[04:56:30] *** Quits: maikklein3 (maik@moz-5AED6CF8.dip0.t-ipconnect.de) (Ping timeout)
[04:59:03] <brson> erickt1: windows build failure http://buildbot.rust-lang.org/builders/auto-win-32-opt/builds/824/steps/compile/logs/stdio
[04:59:28] *** Quits: mitja (mitja@moz-E7EA111C.clients.kiwiirc.com) (Quit: http://www.kiwiirc.com/ - A hand crafted IRC client)
[05:01:43] *** Joins: graydon (graydon@moz-F14EE0DB.cable.teksavvy.com)
[05:01:43] *** ChanServ sets mode: +qo graydon graydon
[05:01:51] *** Joins: ghrust (ghrust@CFE85B59.6A2AE50.F3114085.IP)
[05:01:51] <ghrust> 01[13rust01] 15bors 04force-pushed 06auto from 14096aa02 to 149db698a: 02http://git.io/N3iJvQ
[05:01:51] *** Parts: ghrust (ghrust@CFE85B59.6A2AE50.F3114085.IP) ()
[05:01:52] *** Joins: ghrust (ghrust@1E8607E8.6A2AE50.F3114085.IP)
[05:01:52] <ghrust> 01[13rust01] 15bors pushed 2 new commits to 06auto: 02http://git.io/FOqq7w
[05:01:52] <ghrust> 13rust/06auto 14ffb670f 15Alex Crichton: Add initial support for a new formatting syntax...
[05:01:52] <ghrust> 13rust/06auto 14d07a903 15bors: auto merge of #8245 : alexcrichton/rust/fmt2, r=graydon...
[05:01:52] *** Parts: ghrust (ghrust@1E8607E8.6A2AE50.F3114085.IP) ()
[05:01:54] <graydon> did .. newrt actually land?!
[05:02:07] <graydon> do my eyes deceive me?
[05:02:20] <brson> it happened, yeah
[05:02:28] *** Joins: alisdair (textual@moz-FBF4138A.vc.shawcable.net)
[05:02:45] <graydon> brson: !!!AMAZING!!!
[05:02:54] *** Quits: ChrisMorgan (chris@moz-6AC741CA.static.tpgi.com.au) (Ping timeout)
[05:03:10] * graydon looks around the internet for the "king hacker" crown to pass on to brson
[05:03:10] <brson> :-)
[05:03:30] <brson> i have a -6000 line patch for deleting C++ up next
[05:03:34] <graydon> :))))))))
[05:04:02] <graydon> (surely some of it remains, no? some of the C-macro-using bits, or upcalls?)
[05:04:04] <brson> i never figured out what was wrong with the builds last night though, so rusti may misbehave still
[05:04:07] <graydon> mhm
[05:04:13] <graydon> looks like android is freaking out presently
[05:04:24] <brson> i *think* I've got android fixed
[05:04:30] <brson> master.cfg was *totally* wrong
[05:04:31] <graydon> as-of .. moments ago?
[05:04:33] <brson> yeah
[05:04:34] <graydon> oh dear :(
[05:04:38] <graydon> what was it doing wrong?
[05:04:43] *** Joins: mihneadb (mihneadb@E48845AB.3A9F9BD4.4C2245EF.IP)
[05:05:11] <brson> passing --host-triples=arm-linux-androideabi instead of --target-triples and also classifying all slaves as "android"
[05:05:38] <brson> there are about 3000 lines of C++ left, but they are all small, self-contained things that are pretty easy to translate to rust with enough effort
[05:06:09] <graydon> sure
[05:06:16] <graydon> classifying all slaves as android?!
[05:06:24] <brson> yep. it was pretty bogus
[05:06:47] <aatch> brson, should be able to use asm! to move the valgrind stuff into Rust, though it might be a bit of a maintenence burden...
[05:06:52] <graydon> oh, "props['android'] == True"
[05:06:53] <graydon> hah
[05:07:29] <graydon> aatch: I don't mind keeping little must-be-in-C stubs around for such cases. interfacing with C isn't really so bad. having the whole runtime in C++ was bad :)
[05:07:50] <graydon> if it's just like a one-entry, one-exit function that is otherwise tricky to write in rust...
[05:08:13] <graydon> it's not like we're going to be hoisting LLVM or libc into rust
[05:08:20] <graydon> (well, strcat might rewrite libc)
[05:08:22] *** Quits: erickt1 (Adium@49C4075F.3AC15C18.2321E71E.IP) (Quit: Leaving.)
[05:09:02] <aatch> graydon, from what I can tell it's just no-op sequences that valgrind looks for, meaning asm! would work fine. It's certainly not high-priority though.
[05:09:16] <graydon> yes, they just change with different valgrind releases
[05:09:21] <graydon> ish? I think
[05:09:27] <graydon> anyway they are certainly fussy to get right
[05:09:30] <aatch> graydon, I've no idea.
[05:09:31] <graydon> I wouldn't spend a lot of energy on it
[05:09:51] <aatch> graydon, definately contributor-level work.
[05:09:53] <brson> graydon: can you push rust-buildbot to github?
[05:11:27] *** Joins: faildead (Mibbit@E92B6CFF.24AE4870.CAD5678C.IP)
[05:11:40] <graydon> hm, ok. I think I might not be on master. sec.
[05:11:45] <graydon> yeah this is android-wip
[05:11:50] <graydon> shall I merge it back to master?
[05:12:21] *** Joins: tautologico (shung@9F01D096.92EA1F6.C27E1635.IP)
[05:18:01] *** Quits: faildead (Mibbit@E92B6CFF.24AE4870.CAD5678C.IP) (Quit: http://www.mibbit.com ajax IRC Client)
[05:19:13] <brson> graydon: yes please
[05:23:12] *** Joins: jaen (jaen@moz-19FD027.play-internet.pl)
[05:23:25] *** Quits: cubic (cubic@moz-FE5AD6C7.mc.videotron.ca) (Quit: Leaving)
[05:24:36] <graydon> pushed
[05:24:41] *** Quits: tautologico (shung@9F01D096.92EA1F6.C27E1635.IP) (Quit: tautologico)
[05:24:41] *** Quits: jaen (jaen@moz-19FD027.play-internet.pl) (Quit: WeeChat 0.4.1)
[05:25:04] <bjz> brson: do you think it would be possible to have a recv iterator? for msg in port.recv_iter() { ... }
[05:25:26] *** Quits: Kruppe (user@moz-E150F49F.cpe.net.cable.rogers.com) (Client exited)
[05:25:57] <brson> bjz: yes
[05:26:22] <bjz> brson: would it be useful? or does that sort of go against messaging?
[05:28:09] *** Joins: Uther (Instantbir@moz-1B244B05.hfc.dyn.abo.bbox.fr)
[05:28:11] <brson> it seems like a potentially useful way to express the actor message loop. it's usually something like `loop { match port.recv() { ... Exit => break } }`. the tough question is what it means to stop iteration. usually in my code there is an explicit Exit message and if the Chan closes it's an error
[05:28:22] <brson> but the natural stopping point of a recv iterator is when the Chan closes
[05:28:54] <brson> but that doesn't indicate anything about whether the sender closed successfully or failfully
[05:28:59] <brson> have to put some thought into that
[05:29:07] <bjz> ok
[05:29:12] <bjz> was just an idea
[05:29:28] *** Joins: fabiand (fabiand@moz-B59858CA.adsl.alicedsl.de)
[05:32:30] <vk> It'd be nice to have something about the '.. foo' struct syntax in the tutorial, left me a bit befuddled after noticing it for the first time. Well until I looked it up in the manual anyway.
[05:33:20] *** Joins: Usul (anonymous@moz-AB3CA777.w82-125.abo.wanadoo.fr)
[05:38:01] <brson> toddaaro: is 10x message passing perf compared to oldsched an accurate statement, at least in a vague sense?
[05:42:29] *** Joins: figaro (Mibbit@E92B6CFF.24AE4870.CAD5678C.IP)
[05:42:56] <brson> or am i making that number up ...
[05:45:41] <toddaaro> brson: I should check against old olsched actually
[05:45:53] <toddaaro> brson: the pingpong benchmark saw a 10x speed up against master
[05:45:57] <brson> ah
[05:46:07] <figaro> In JavaScript you can use `function(arguments){body}` to define an anonymous function. What is the equivalent syntax in Rust?
[05:46:31] <toddaaro> benchmarks need some sort of infrastructure I haven't decided on yet, as we want to run against a few different rust versions
[05:47:24] <toddaaro> (if you have any tool suggestions let me know, I'm probably going to spend tomorrow on this)
[05:47:25] <mcpherrin> figaro: http://static.rust-lang.org/doc/tutorial.html#closures
[05:48:39] *** Quits: Diamond (dick@moz-C01E1CD1.ks.ks.cox.net) (Ping timeout)
[05:49:59] *** Quits: tikue (tkuehn@moz-BBE3ABD.mv.mozilla.com) (Quit: tikue)
[05:50:10] <figaro> let square = |x: int| -> uint { (x * x) as uint }; square(5)
[05:50:22] <figaro> rusti: let square = |x: int| -> uint { (x * x) as uint }; square(5)
[05:50:26] -rusti- 25
[05:51:58] <sp3d> huh, why can't rust infer that "as uint"?
[05:52:53] <figaro> rusti: let mult = |x: float, y: float| -> {return x * y as float;}; mult(2,5)
[05:52:55] -rusti- pastebinned 7 lines of output: http://sprunge.us/gGQb
[05:53:01] *** Joins: Diamond (dick@moz-C01E1CD1.ks.ks.cox.net)
[05:53:16] *** Quits: enix (enix@moz-A50569DD.c3-0.slvr-ubr1.lnh-slvr.md.cable.rcn.com) (Quit: Konversation terminated!)
[05:54:11] <sp3d> rusti: fn square(x:int)->uint {x*x}; square(5)
[05:54:12] -rusti- <anon>:5:33: 5:36 error: mismatched types: expected `uint` but found `int` (expected uint but found int)
[05:54:12] -rusti- <anon>:5          fn square(x:int)->uint {x*x}; square(5)
[05:54:12] -rusti-                                           ^~~
[05:54:12] -rusti- error: aborting due to previous error
[05:54:12] -rusti- application terminated with error code 101
[05:54:48] *** Quits: ab (alex@BC9D99CC.37C1012D.FE617B51.IP) (Ping timeout)
[05:55:26] <sp3d> oh, I get it, nvm
[05:56:34] *** Joins: recrack (Mibbit@B4104EBB.3CC170B1.1E14B209.IP)
[05:56:42] <figaro> let mult = |x: float, y: float| -> float {fn core(x, y) {return x*y;}; core(x,y) as float}; mult(2,5)
[05:56:42] *** Joins: ab (alex@BC9D99CC.37C1012D.FE617B51.IP)
[05:58:08] <figaro> rusti: let square = |x: int| -> unit
[05:58:08] -rusti- <anon>:6:4: 6:5 error: unexpected token: `}`
[05:58:08] -rusti- <anon>:6     };
[05:58:08] -rusti-              ^
[05:58:09] -rusti- application terminated with error code 101
[05:58:51] *** Quits: Diamond (dick@moz-C01E1CD1.ks.ks.cox.net) (Ping timeout)
[06:02:23] *** Quits: ab (alex@BC9D99CC.37C1012D.FE617B51.IP) (Ping timeout)
[06:02:39] *** Quits: graydon (graydon@moz-F14EE0DB.cable.teksavvy.com) (Ping timeout)
[06:06:29] *** Joins: Diamond (dick@moz-C01E1CD1.ks.ks.cox.net)
[06:06:59] *** Joins: graydon (graydon@moz-F14EE0DB.cable.teksavvy.com)
[06:06:59] *** ChanServ sets mode: +qo graydon graydon
[06:09:33] *** Quits: figaro (Mibbit@E92B6CFF.24AE4870.CAD5678C.IP) (Quit: http://www.mibbit.com ajax IRC Client)
[06:14:29] *** Joins: rlin-nb (rlin@moz-99690620.hinet-ip.hinet.net)
[06:16:13] *** graydon changes topic to 'New Runtime is landed! http://www.rust-lang.org | logs at https://botbot.me/mozilla/rust/ and http://irclog.gr/#browse/irc.mozilla.org/rust | http://huonw.github.io/isrustfastyet/mem/ | landings http://buildbot.rust-lang.org/bors/bors.html'
[06:17:41] <graydon> headed to bed. night all. a great day for rust!
[06:17:47] *** Quits: graydon (graydon@moz-F14EE0DB.cable.teksavvy.com) (Quit: Leaving.)
[06:18:01] <mihneadb> so.. checking the memory data on the "fastyet" website, haha
[06:18:07] <mihneadb> gg on rt
[06:18:10] *** Quits: mkohler (mkohler@moz-1531EE3.dclient.hispeed.ch) (Quit: mkohler)
[06:18:42] *** Joins: tikue (tkuehn@moz-CF8BEBEF.dia.static.qwest.net)
[06:19:59] <brson> hm
[06:20:24] *** Joins: jaen (jaen@moz-CC026488.neoplus.adsl.tpnet.pl)
[06:20:58] <brson> what do the compile/testsuite numbers represent? they look awful
[06:21:43] *** Quits: jaen (jaen@moz-CC026488.neoplus.adsl.tpnet.pl) (Quit: WeeChat 0.4.1)
[06:21:53] *** Joins: jaen (jaen@moz-CC026488.neoplus.adsl.tpnet.pl)
[06:22:17] <brson> is it total running time?
[06:28:19] <brson> appears so. it seems to have taken a ridiculous amount of time to complete the build with the new runtime
[06:28:28] <brson> maybe swapping?
[06:32:41] *** Quits: jaen (jaen@moz-CC026488.neoplus.adsl.tpnet.pl) (Ping timeout)
[06:33:51] <brson> the crazy-bad build times appears to be an anomalous - the most recent build is much closer to the prior times
[06:34:08] <brson> i wonder what that means
[06:34:28] <brson> mihneadb: what were you seeing in the memory data? i have a hard time interpreting it
[06:34:31] *** Joins: eatkinson (eatkinson@moz-5CF47426.dia.static.qwest.net)
[06:35:30] <mihneadb> brson: I was mostly picking on the fact that the URL is about "speed" and the data is about memory :)
[06:35:58] *** Quits: tikue (tkuehn@moz-CF8BEBEF.dia.static.qwest.net) (Quit: tikue)
[06:36:14] *** Quits: vodik (simon@moz-CBE4BB13.cable.teksavvy.com) (Ping timeout)
[06:36:17] <mihneadb> brson: you mean in the buildbot tab?
[06:36:36] <mihneadb> yes, how long it takes to build / make check
[06:36:58] <mihneadb> or at least that's what I understand from it
[06:37:49] *** Quits: aatch (aatch@moz-B437F499.pocketrent.com) (Client exited)
[06:38:36] *** Joins: sanxiyn (tinuviel@858F408C.B797260D.EF43EC08.IP)
[06:38:53] <sanxiyn> Android buildbot!!!
[06:38:54] <sanxiyn> Thanks!
[06:39:17] *** Joins: dim-an (ermolovd@moz-FE167E47.nationalcablenetworks.ru)
[06:39:22] <brson> sanxiyn: :)
[06:41:49] <brson> dbaupp: what are our prospects for adding the new benchmark data to isrustfastyet?
[06:42:02] *** Joins: jaen (jaen@moz-CC026488.neoplus.adsl.tpnet.pl)
[06:44:59] *** Joins: Cromulent (Cromulent@moz-983B638D.cable.virginmedia.com)
[06:45:18] <brson> would you prefer being addressed as "rusties" or "rusticles"?
[06:47:21] *** Joins: eholk (eholk@5DF4FB08.80A060B2.C0B90B08.IP)
[06:48:16] <sp3d> brson: is "rustlings" an option?
[06:48:21] <sanxiyn> brson: Not too enthusiastic about both
[06:48:29] <brson> sp3d: omg that's so much better
[06:48:38] <sanxiyn> I am still looking for a good demonym
[06:48:42] <brson> although very diminutive
[06:48:53] <sp3d> humility is good :)
[06:49:05] <sanxiyn> Indeed, "Rust" itself is a humble name
[06:49:30] *** Joins: Ms2ger (Ms2ger@35CC4A24.2B12F798.F15B0BB3.IP)
[06:50:03] <sanxiyn> brson: Does the new runtime use atomics heavily?
[06:50:09] <brson> sanxiyn: very
[06:50:27] <sanxiyn> I think Android should build for ARMv7 then
[06:50:39] <sanxiyn> Currently it is building for baseline ARM, on which atomics are very slow
[06:51:07] <sanxiyn> Namely, I want LLVM to be able to use LDREX and STREX
[06:51:27] <brson> sanxiyn: i'd be curious to know how well it behaves on real hardware
[06:51:38] <brson> real arm hardware that is
[06:51:52] <sanxiyn> Yeah, I plan to test that
[06:52:28] <sanxiyn> We've got quad core ARM test board here
[06:52:51] *** Quits: eholk (eholk@5DF4FB08.80A060B2.C0B90B08.IP) (Quit: eholk)
[06:53:45] <bblum> are arm atomics any slower than x86 atomics
[06:53:52] <bblum> normalizing for clock speed?
[06:54:12] <bblum> seems like they should be the same speed, and arm non-atomics would be a lot faster than x86 non-atomics
[06:54:12] <sanxiyn> bblum: As I understand ARM before v6 does not have atomics in hardware at all
[06:54:36] <sanxiyn> (and emulated by taking locks)
[06:54:42] <bblum> o_o
[06:54:49] <bblum> like, it doesn't even have atomic swaps?
[06:56:36] <sanxiyn> As I understand
[06:56:45] <bblum> are the locks done with ll/sc?
[06:56:52] <sanxiyn> Really old ARMs don't have any atomics whatsoever (they also don't have any multi core...)
[06:56:57] <sanxiyn> bblum: In recent ARMs, yes
[06:57:06] <sanxiyn> Old ARMs have *only* atomic swap
[06:57:16] <bblum> oh that's bad
[06:57:21] <bblum> i think you can do swaps using ll/sc
[06:57:21] <sanxiyn> So spinlock is implemented on top of atomic swap, and compare-and-swap and others are implemented on top of that
[06:57:28] <bblum> gross :P
[06:57:33] <sanxiyn> Recent ARMs have ll/sc
[06:57:37] <sanxiyn> Which is decent
[06:57:43] <bblum> ll/sc is fsine
[06:57:44] <sanxiyn> Namely LDREX and STREX
[06:57:45] <bblum> *fine
[06:57:51] <bblum> xchg is not a good building block for the others.
[06:57:59] <sanxiyn> But LLVM can't use LDREX and STREX at the moment, since it is building for "generic" ARM
[06:58:03] <sanxiyn> So I want to change that
[06:59:11] <sanxiyn> bblum: ARMv8 (which is not yet but future) just gave up and implemented xchg
[06:59:22] <sanxiyn> ll/sc may be fine, but apparently programmers find them hard
[06:59:37] <sanxiyn> ARMv8 xchg works exactly like x86 one
[06:59:48] <sanxiyn> So that people can port easily etc
[06:59:49] <bblum> barriers are harder than ll/sc but they made it into C++
[07:01:57] <bblum> well, i guess i have never programmed in direct ll/sc
[07:02:17] *** Quits: alisdair (textual@moz-FBF4138A.vc.shawcable.net) (Quit: My MacBook Pro has gone to sleep. ZZZzzz…)
[07:02:47] *** Quits: tcr (tcr@moz-EE576D3C.hsd1.ma.comcast.net) (Client exited)
[07:03:35] <sanxiyn> bblum: I don't know what to make of the comment, but http://herbsutter.com/welcome-to-the-jungle/ says:
[07:03:47] <sanxiyn> "Hardware that supports weaker memory models than that are permanently disadvantaged and will either become stronger (as ARMv8 is now doing by adding SC acquire/release instructions) or atrophy."
[07:04:06] <sanxiyn> "The two main hardware architectures with what I called "weak" memory models were ARMv7 and POWER. ARMv8 is upgrading to SC acquire/release, as predicted, and it remains to be seen whether POWER will upgrade or atrophy."
[07:04:41] *** Quits: Cromulent (Cromulent@moz-983B638D.cable.virginmedia.com) (Quit: KVIrc 4.2.0 Equilibrium http://www.kvirc.net/)
[07:04:54] <sanxiyn> On the other hand, Linux kernel is still supporting Alpha (which has even weaker memory model than both ARM and POWER), so...
[07:05:03] *** Quits: dim-an (ermolovd@moz-FE167E47.nationalcablenetworks.ru) (Quit: dim-an)
[07:07:31] *** Quits: hjr3 (hradtke@moz-E87BDF1F.socal.res.rr.com) (Quit: My MacBook has gone to sleep. ZZZzzz…)
[07:09:20] <dbaupp> brson: that data is in the hands of cmr; he said he'd be working on it tomorrow, a few hours ago; so maybe tomorrow.
[07:09:38] *** Quits: rlin-nb (rlin@moz-99690620.hinet-ip.hinet.net) (Ping timeout)
[07:11:26] *** Joins: xazax (Mibbit@6655692F.3B222813.3F580572.IP)
[07:11:31] <xazax> hey!
[07:11:35] *** Joins: victorporof (victorporo@B4B1C8EE.73B1E539.9B1E38F4.IP)
[07:11:56] <acrichto> brson: newrt problems? http://buildbot.rust-lang.org/builders/auto-mac-64-opt-vg/builds/819/steps/test/logs/stdio
[07:11:58] <dbaupp> brson: but, yes, the compile/testsuite times are just the times that buildbot reports that stage of the build took; and it's sensitive to noise; e.g. if try is being used, then the builds will be much slower. (and some buildslaves are faster than others.)
[07:12:33] <xazax> I saw newrt has been landed, is there a blogpost or something like that which describes the advantages of newrt? or the only reason was to ditch C++ code?
[07:13:21] <dbaupp> xazax: apparently it's faster (for some things)
[07:13:54] *** Joins: ghrust (ghrust@24260B07.6A2AE50.F3114085.IP)
[07:13:54] <ghrust> 01[13rust01] 15bors 04force-pushed 06auto from 14d07a903 to 149db698a: 02http://git.io/N3iJvQ
[07:13:54] *** Parts: ghrust (ghrust@24260B07.6A2AE50.F3114085.IP) ()
[07:13:54] *** Joins: ghrust (ghrust@FD7BC443.6A2AE50.F3114085.IP)
[07:13:54] <ghrust> 01[13rust01] 15bors pushed 2 new commits to 06auto: 02http://git.io/j06v9g
[07:13:54] <ghrust> 13rust/06auto 148970aad 15Brian Anderson: Remove the C++ runtime. Sayonara
[07:13:54] <ghrust> 13rust/06auto 149b1bcd6 15bors: auto merge of #8387 : brson/rust/nooldrt, r=brson
[07:13:55] *** Parts: ghrust (ghrust@FD7BC443.6A2AE50.F3114085.IP) ()
[07:15:34] <brson> acrichto: not sure what to make of that ...
[07:15:57] *** Joins: BizarreCake (BizarreCak@moz-361FE9B2.dynamic.barak-online.net)
[07:16:11] <brson> probably because we're using shit-tons of stack now, valgrind needs more buffer to record info about it
[07:16:18] <brson> grr
[07:16:20] *** Joins: sebcrozet (sebcrozet@moz-87D51607.w80-13.abo.wanadoo.fr)
[07:16:39] <dbaupp> brson: also, it seems that there were 2 builds of the newrt pr happening at the same time, which might explain the spike (which is the second of those builds)
[07:17:16] <brson> xazax: i'll post a status update to the mailing list tomorrow, but it won't really be an overview of why
[07:17:30] <brson> xazax: the primary reason is to support a redesign of the I/O subsystem
[07:18:13] *** Quits: tiffany (kawaii@moz-EB8B0C08.dhcp.embarqhsd.net) (Ping timeout)
[07:18:14] <brson> we're integrating an I/O event loop into the task scheduler, which will allow for fast, synchronous I/O that doesn't block the thread
[07:18:37] <brson> and a rewrite didn't make sense in c++
[07:18:58] <brson> so we took a bit of a detour to port the entire runtime
[07:18:59] <brson> https://github.com/mozilla/rust/issues/4419
[07:19:22] *** Joins: maikklein3 (maik@moz-5AED6CF8.dip0.t-ipconnect.de)
[07:19:31] <acrichto> brson: I'll just retry for now I guess
[07:20:01] <xazax> brson: thanks :) looking forward for the status update
[07:20:17] <brson> some of the mac bots don't actually have valgrind, so whether the mac valgrind builds actually valgrinds is kind of up to change
[07:20:34] <brson> i can possibly disable valgrind on mac ...
[07:21:51] <bblum> brson: just realized what we can do for the try_block/environment race bug
[07:22:13] <bblum> we can make the other CPU spin on the atomic bool only if the task was killed
[07:22:53] *** Joins: ghrust (ghrust@C621748.6A2AE50.F3114085.IP)
[07:22:53] <ghrust> 01[13rust01] 15bors 04force-pushed 06auto from 149b1bcd6 to 149db698a: 02http://git.io/N3iJvQ
[07:22:53] *** Parts: ghrust (ghrust@C621748.6A2AE50.F3114085.IP) ()
[07:22:53] *** Joins: ghrust (ghrust@C8693FCB.6A2AE50.F3114085.IP)
[07:22:54] <ghrust> 01[13rust01] 15bors pushed 2 new commits to 06auto: 02http://git.io/iR7oEg
[07:22:54] <ghrust> 13rust/06auto 14ffb670f 15Alex Crichton: Add initial support for a new formatting syntax...
[07:22:54] <ghrust> 13rust/06auto 14a0080f4 15bors: auto merge of #8245 : alexcrichton/rust/fmt2, r=graydon...
[07:22:54] *** Parts: ghrust (ghrust@C8693FCB.6A2AE50.F3114085.IP) ()
[07:22:58] <bblum> this keeps the status quo about the race still being possible if the closure itself is not carefully written
[07:23:40] <bblum> but it means no overhead if the task is woken by non-killing means
[07:23:58] <bblum> (well, overhead of one write to an uncontended cacheline)
[07:24:33] *** Quits: rust-buildbot (rust-build@505BFA3.C3CCCE8C.D25A875A.IP) (Quit: buildmaster reconfigured: bot disconnecting)
[07:24:33] *** Joins: rust-buildbot (rust-build@505BFA3.C3CCCE8C.D25A875A.IP)
[07:25:55] <brson> acrichto: turned off the mac valgrind bot
[07:26:21] <acrichto> brson: I like your style :)
[07:27:40] *** Quits: bytbox (s@moz-DC83764A.washdc.fios.verizon.net) (Ping timeout)
[07:29:58] <brson> bblum: probably, but I'd like to come up with a protocol that doesn't involve locking
[07:30:03] <brson> i think it can be done
[07:30:28] <bblum> you mean even in the valgrind-friendly build i presume
[07:30:54] *** Joins: rlin-nb (rlin@moz-99690620.hinet-ip.hinet.net)
[07:31:37] <bblum> i dunno, i think it's ok to penalize the valgrind-friendly build
[07:32:13] <bblum> what i would like is a way that isn't gross, and/or a way that unilaterally solves *all* possible abuses of the interface, neither of which can be said for this latest idea
[07:32:23] <maikklein3> brson, https://github.com/brson/rust-sdl/pull/81
[07:33:13] *** maikklein3 is now known as maikklein
[07:38:19] <brson> bblum: no, i mean in general, counting spinning as locking
[07:39:14] *** Quits: BizarreCake (BizarreCak@moz-361FE9B2.dynamic.barak-online.net) (Connection reset by peer)
[07:41:43] *** Quits: mindginative (mindginati@moz-7AB462BB.dyn.cust.vf.net.nz) (Quit: zzZZZ)
[07:42:28] <brson> i need to go to bed
[07:42:29] *** Quits: brson (brson@moz-BBE3ABD.mv.mozilla.com) (Quit: leaving)
[07:42:34] *** Joins: mindginative (mindginati@moz-7AB462BB.dyn.cust.vf.net.nz)
[07:43:52] *** Quits: eatkinson (eatkinson@moz-5CF47426.dia.static.qwest.net) (Quit: eatkinson)
[07:47:23] *** Quits: Mowah (Mowah@moz-436C35C5.cust.bredbandsbolaget.se) (Ping timeout)
[07:49:49] *** Joins: Blub\w (wry@7E3BB9D.71150E1A.237AE2BA.IP)
[08:00:22] <bjz> cmr: hoy
[08:02:59] *** Joins: tcr (tcr@moz-EE576D3C.hsd1.ma.comcast.net)
[08:04:40] *** Quits: tcr (tcr@moz-EE576D3C.hsd1.ma.comcast.net) (Ping timeout)
[08:06:28] *** Quits: mindginative (mindginati@moz-7AB462BB.dyn.cust.vf.net.nz) (Quit: zzZZZ)
[08:07:03] *** Joins: ab (alex@BC9D99CC.37C1012D.FE617B51.IP)
[08:13:13] <maikklein> hm "error: type `&mut ~[game::Actor]` does not implement any method in scope named `next`"
[08:13:42] *** Quits: Earnestly (earnest@3F74F9E2.8E6FE497.30311652.IP) (Ping timeout)
[08:13:43] <maikklein> any idea why?
[08:13:48] *** Joins: dim-an (ermolovd@moz-74FA7782.yandex.net)
[08:13:51] <heftig> forgot .iter()?
[08:13:59] *** Joins: jensnockert (jensnocker@moz-61E1062F.tbcn.telia.com)
[08:14:10] <maikklein> I thought we don't need .iter() in for in v anymore?
[08:14:20] *** Quits: ab (alex@BC9D99CC.37C1012D.FE617B51.IP) (Client exited)
[08:14:49] <dbaupp> maikklein: no, that's not been implemented yet
[08:14:56] <maikklein> dbaupp, oh ok
[08:16:30] *** Joins: ab (alex@BC9D99CC.37C1012D.FE617B51.IP)
[08:18:06] *** Quits: rlin-nb (rlin@moz-99690620.hinet-ip.hinet.net) (Quit: Leaving.)
[08:20:02] *** Joins: vosen (vosen@moz-266BA656.icpnet.pl)
[08:20:11] *** Joins: donri (dag@moz-9BB61102.tbcn.telia.com)
[08:27:41] <mihneadb> rusti: let x = [1,2,3]; x.append_one(4);
[08:27:41] -rusti- <anon>:5:26: 5:42 error: type `[<VI2>, .. 3]` does not implement any method in scope named `append_one`
[08:27:42] -rusti- <anon>:5          let x = [1,2,3]; x.append_one(4);
[08:27:42] -rusti-                                    ^~~~~~~~~~~~~~~~
[08:27:42] -rusti- error: aborting due to previous error
[08:27:42] -rusti- application terminated with error code 101
[08:27:48] <mihneadb> how do I do this?
[08:28:39] <joelteon> rusti: let x = ~[1,2,3]; x.append_one(4);
[08:28:40] -rusti- <anon>:5:27: 5:43 error: type `~[<VI2>]` does not implement any method in scope named `append_one`
[08:28:40] -rusti- <anon>:5          let x = ~[1,2,3]; x.append_one(4);
[08:28:40] -rusti-                                     ^~~~~~~~~~~~~~~~
[08:28:40] -rusti- error: aborting due to previous error
[08:28:40] -rusti- application terminated with error code 101
[08:28:43] <joelteon> hmm
[08:28:51] <mihneadb> mut?
[08:28:52] <dbaupp> rusti: let mut x = ~[1,2,3]; x.push(4); x
[08:28:53] -rusti- ~[1, 2, 3, 4]
[08:28:57] <mihneadb> rusti: let mut x = [1,2,3]; x.append_one(4);
[08:28:57] -rusti- <anon>:5:30: 5:46 error: type `[<VI2>, .. 3]` does not implement any method in scope named `append_one`
[08:28:58] -rusti- <anon>:5          let mut x = [1,2,3]; x.append_one(4);
[08:28:58] -rusti-                                        ^~~~~~~~~~~~~~~~
[08:28:58] -rusti- error: aborting due to previous error
[08:28:58] -rusti- application terminated with error code 101
[08:28:59] <joelteon> oh no, append_one isn't a method on vec in head
[08:29:08] <mihneadb> dbaupp: what about append_one
[08:29:08] <joelteon> rusti: let mut x = [1,2,3]; append_one(x, 4)
[08:29:09] -rusti- <anon>:5:30: 5:40 error: unresolved name `append_one`.
[08:29:09] -rusti- <anon>:5          let mut x = [1,2,3]; append_one(x, 4)
[08:29:09] -rusti-                                        ^~~~~~~~~~
[08:29:09] -rusti- error: aborting due to previous error
[08:29:09] -rusti- application terminated with error code 101
[08:29:13] <joelteon> god damn it
[08:29:30] <mihneadb> oh
[08:29:33] <dbaupp> mihneadb: I guess I removed it in my vec clean ups
[08:29:34] <mihneadb> it's a function, not a method
[08:29:43] * dbaupp can't remember
[08:29:47] <mihneadb> dbaupp: ah, might be
[08:29:51] <mihneadb> it's in the docs :(
[08:29:56] <dbaupp> oh, wow, it is there.
[08:30:07] <dbaupp> rusti: std::vec::apend_one(~[1,2,3], 4)
[08:30:07] <mihneadb> dbaupp: any plans of list comprehensions & such?
[08:30:08] -rusti- <anon>:5:9: 5:28 error: unresolved name `std::vec::apend_one`.
[08:30:08] -rusti- <anon>:5          std::vec::apend_one(~[1,2,3], 4)
[08:30:08] -rusti-                   ^~~~~~~~~~~~~~~~~~~
[08:30:08] -rusti- error: aborting due to previous error
[08:30:08] -rusti- application terminated with error code 101
[08:30:18] <dbaupp> rusti: std::vec::append_one(~[1,2,3], 4)
[08:30:19] -rusti- ~[1, 2, 3, 4]
[08:30:27] <mihneadb> aha!
[08:30:27] <mihneadb> nice
[08:30:33] <dbaupp> mihneadb: they're possible with macros/syntax extensions
[08:30:38] <mihneadb> ok
[08:30:44] *** Quits: KindOne (KindOne@moz-983E660C.dynamic.ip.windstream.net) (Ping timeout)
[08:30:53] <dbaupp> mihneadb: http://www.reddit.com/r/rust/comments/1gag3t/list_comprehensions_in_rust_iterator/
[08:31:03] <mihneadb> dbaupp: ty
[08:31:13] <mihneadb> sweet
[08:31:23] <dbaupp> (I remember now, append_one is to make functional-style programming more natural.)
[08:31:41] <mihneadb> dbaupp: is there some type that can act both as a Port and as a Chan?
[08:31:58] <dbaupp> mihneadb: extra::something has a DuplexStream iirc
[08:31:58] *** Joins: CarpNet (ac@moz-FD24B77.sohonet.co.uk)
[08:32:00] <mihneadb> other than using stream()
[08:32:08] <mihneadb> ok
[08:32:11] <dbaupp> extra::comm
[08:32:27] <mihneadb> dbaupp: I wanted to do 100 tasks that pass an int one to the next
[08:32:31] <mihneadb> circular buffer-like
[08:32:37] <dbaupp> oh
[08:32:40] <mihneadb> any nicer solution than this duplex stream?
[08:32:48] <dbaupp> no idea
[08:33:04] <dbaupp> I guess not
[08:33:15] <mihneadb> ok :)
[08:33:32] <mihneadb> ty
[08:35:09] <mihneadb> dbaupp: if I want to make a vector of 99 of those, what's the rusty way? start out with an empty mut ~[] ?
[08:35:10] *** Joins: KindOne (KindOne@moz-9626F9F2.dynamic.ip.windstream.net)
[08:35:52] <dbaupp> rusti: vec::from_fn(99, |_| extra::comm::DuplexStream::<int, int>())
[08:35:53] -rusti- pastebinned 11 lines of output: http://sprunge.us/dUaR
[08:36:10] <mihneadb> ah
[08:36:11] <mihneadb> nice
[08:36:11] <dbaupp> rusti: std::vec::from_fn(99, |_| extra::comm::DuplexStream::<int, int>())
[08:36:12] <mihneadb> ty!
[08:36:12] -rusti- line longer than 10000 characters, bailing out
[08:36:26] <dbaupp> rusti: std::vec::from_fn(3, |_| extra::comm::DuplexStream::<int, int>())
[08:36:28] -rusti- line longer than 150 columns, pastebinned 1 lines of output: http://sprunge.us/ZRCU
[08:36:29] <mihneadb> rusti: let v: ~[int] = [];
[08:36:29] -rusti- <anon>:5:25: 5:27 error: mismatched types: expected `~[int]` but found `[<V5>, .. 0]` ([] storage differs: expected ~ but found 0)
[08:36:29] -rusti- <anon>:5          let v: ~[int] = [];
[08:36:30] -rusti-                                   ^~
[08:36:30] -rusti- error: aborting due to previous error
[08:36:30] -rusti- application terminated with error code 101
[08:36:45] <mihneadb> rusti: let v: ~[int] = [];
[08:36:46] -rusti- <anon>:5:25: 5:27 error: mismatched types: expected `~[int]` but found `[<V5>, .. 0]` ([] storage differs: expected ~ but found 0)
[08:36:46] -rusti- <anon>:5          let v: ~[int] = [];
[08:36:46] -rusti-                                   ^~
[08:36:46] -rusti- error: aborting due to previous error
[08:36:46] -rusti- application terminated with error code 101
[08:36:53] <mihneadb> how do you make an empty array?
[08:37:00] <joelteon> ~[]
[08:37:05] <mihneadb> rusti: let v: ~[int] = ~[];
[08:37:06] <dbaupp> rusti: let v: ~[int] = ~[]; // sigils!
[08:37:07] -rusti- <anon>:5:13: 5:14 warning: unused variable: `v` [-W unused-variable (default)]
[08:37:07] -rusti- <anon>:5          let v: ~[int] = ~[];
[08:37:07] -rusti-                       ^
[08:37:07] -rusti- ()
[08:37:07] -rusti- <anon>:5:13: 5:14 warning: unused variable: `v` [-W unused-variable (default)]
[08:37:09] -rusti- <anon>:5          let v: ~[int] = ~[]; // sigils!
[08:37:11] -rusti-                       ^
[08:37:13] -rusti- ()
[08:37:14] <mihneadb> ah lol, duh
[08:37:15] <mihneadb> ty
[08:37:54] *** Joins: true_droid (true_droid@moz-123FD9B8.beck.volia.net)
[08:38:01] *** Joins: doomlord (doomlod@moz-13E69BC8.range86-180.btcentralplus.com)
[08:43:15] *** Joins: RMF (RMF@moz-2758EDDD.dsl.telepac.pt)
[08:45:59] *** Parts: Usul (anonymous@moz-AB3CA777.w82-125.abo.wanadoo.fr) ()
[08:48:58] *** Parts: dim-an (ermolovd@moz-74FA7782.yandex.net) ()
[08:50:41] *** Joins: lerc (quassel@B2E8CAD3.A8D14E52.788638A4.IP)
[08:52:56] *** Joins: lucian (lucian@6B2B4644.4304AE1E.CE5E78F6.IP)
[08:53:12] *** Joins: robertknight (robertknig@moz-54528EE0.wby.mendeley.com)
[08:55:25] <mihneadb> dbaupp: ping
[08:55:26] <mihneadb> http://pastebin.mozilla.org/2807943
[08:55:32] <mihneadb> I get "expected struct, found tuple"
[08:55:34] <mihneadb> what am I missing? :)
[08:55:46] <dbaupp> what line?
[08:55:47] <mihneadb> error: mismatched types: expected `extra::comm::DuplexStream<int,int>` but found `(extra::comm::DuplexStream<int,int>,extra::comm::DuplexStream<int,int>)` (expected struct extra::comm::DuplexStream but found tuple)
[08:55:52] <mihneadb> the adder call
[08:56:01] <mihneadb> both for dummy stream and streams[0]
[08:56:45] <dbaupp> ah, a duplex stream returns an in and an out stream
[08:57:04] <dbaupp> so it's a tuple (DuplexStream, DuplexStream)
[08:57:41] <dbaupp> looking at that code, you probably just want a normal stream(), since the communication is unidirectional?
[08:58:35] <mihneadb> it is
[08:58:50] <mihneadb> but stream gives me two objects
[08:58:54] *** Joins: davbo (dave@moz-3FFA637C.oucs.ox.ac.uk)
[08:59:13] <dbaupp> I guess something like let (ports, chans) = vec::unzip(vec::from_fn(99, |_| stream()));
[08:59:32] <dbaupp> (DuplexStream gives you 2 objects too.)
[08:59:59] <mihneadb> yeah, noticed now that you mentioned
[08:59:59] <mihneadb> was hoping for a one object thing
[09:01:01] <dbaupp> oh, so both endpoints in one object?
[09:01:18] <dbaupp> so `x.send(1); x.recv() == 1`?
[09:01:44] *** Joins: kartruss (Mibbit@45652AC6.93384D21.67D94052.IP)
[09:02:05] <mihneadb> yes, a pipe
[09:03:01] *** Joins: rlin-nb (rlin@moz-8636DBAB.dynamic.hinet.net)
[09:03:26] *** Joins: tcr (tcr@moz-EE576D3C.hsd1.ma.comcast.net)
[09:03:42] <dbaupp> I guess that is non-idiomatic with rust's concurrency model, since things get transferred between tasks, so it'd have to be wrapped in an Arc.
[09:04:10] <mihneadb> right
[09:04:14] <mihneadb> makes sense
[09:05:31] <mihneadb> dbaupp: wait, I m confused now
[09:05:39] <mihneadb> so if I call stream
[09:05:42] <mihneadb> I get a port and a chan
[09:05:58] <mihneadb> if I do chan.send(1)
[09:05:59] <heftig> no, you get two duplexstreams connected to another
[09:06:21] <mihneadb> heftig: right, with duplexstreams
[09:06:27] <mihneadb> I was thinking with the std port & chan
[09:06:31] <mihneadb> how you use them
[09:06:33] <dbaupp> yeah, then port.recv() == 1
[09:07:02] <dbaupp> rusti: let (p,c) = stream(); c.send(1); c.send(2); (p.recv(), p.recv())
[09:07:03] -rusti- (1, 2)
[09:07:10] <mihneadb> ok
[09:07:11] <mihneadb> ty
[09:07:21] <heftig> or, worded better, the two endpoints of the same duplex stream
[09:07:52] <mihneadb> yes
[09:08:26] <heftig> ah, whoops, seems I was wrong
[09:08:38] <heftig> it's just a unidirectional stream
[09:09:35] <dbaupp> stream == std::comm::streamis one directional, extra::comm::DuplexStream is two.
[09:09:41] <heftig> dbaupp: right.
[09:09:45] <heftig> rusti: let (a,b) = extra::comm::DuplexStream::<int, int>(); a.send(1); b.send(2); (a.recv(), b.recv())
[09:09:47] -rusti- (2, 1)
[09:09:58] <heftig> i confused myself
[09:10:07] *** Quits: kartruss (Mibbit@45652AC6.93384D21.67D94052.IP) (Quit: http://www.mibbit.com ajax IRC Client)
[09:10:41] *** Joins: elf (Mibbit@2163A5B6.84FFD171.17406662.IP)
[09:10:48] <mihneadb> dbaupp: so.. does vec unzip give me ~[] ?
[09:10:59] *** Quits: elf (Mibbit@2163A5B6.84FFD171.17406662.IP) (Quit: http://www.mibbit.com ajax IRC Client)
[09:11:03] <mihneadb> docs say yes
[09:11:31] *** Joins: gluwpa (Mibbit@2163A5B6.84FFD171.17406662.IP)
[09:11:40] <mihneadb> hitting http://pastebin.mozilla.org/2808030
[09:12:03] <gluwpa> rusti: 
[09:12:04] -rusti- ()
[09:12:11] *** Quits: james4k (james@moz-E7990244.consolidated.net) (Ping timeout)
[09:12:36] <dbaupp> mihneadb: you'll need to pop them off, because the ownership has to move
[09:13:07] <gluwpa> rusti: let factorial(0)=1; let factorial(n)=n*factorial(n-1); factorial(6)
[09:13:08] -rusti- pastebinned 20 lines of output: http://sprunge.us/IMOL
[09:13:17] <dbaupp> mihneadb: and you'll have to do it outside the spawn closure, so you've got a separate chan/port to move into the closure.
[09:13:29] <mihneadb> dbaupp: how do I do that? I thought that if they are owned they are moved during the call
[09:13:52] <dbaupp> mihneadb: yeah, but moving a single element from a vector moves the whole thing
[09:14:15] <mihneadb> ah..
[09:14:30] <mihneadb> dbaupp: even if the vector contains ~Stuff ?
[09:15:08] <gluwpa> rusti: fn factorial(n: uint) { if n==0 {1} else {n*factorial(n-1)} }; factorial(12)
[09:15:09] -rusti- pastebinned 8 lines of output: http://sprunge.us/KWjP
[09:15:54] <gluwpa> Des Rust support tail-call recursion?
[09:16:19] <dbaupp> rusti: let (ps, cs) = std::vec::unzip(~[stream(), stream()]); let (p, c) = stream(); let cc = cs.unshift(); do spawn { cc.send(p.recv()) } let pp = ps.pop(); do spawn { c.send(pp.recv()) } cs[0].send(1); ps[0].recv()
[09:16:21] -rusti- pastebinned 8 lines of output: http://sprunge.us/IeLa
[09:16:34] <heftig> gluwpa: i don't think that's being optimized yet
[09:16:35] <dbaupp> rusti: let (ps, cs) = std::vec::unzip(~[stream(), stream()]); let (p, c) = stream(); let cc = cs.shift(); do spawn { cc.send(p.recv()) } let pp = ps.pop(); do spawn { c.send(pp.recv()) } cs[0].send(1); ps[0].recv()
[09:16:37] -rusti- pastebinned 8 lines of output: http://sprunge.us/GfIf
[09:16:42] <heftig> gluwpa: also, that function up there isn't tail-call recursive
[09:16:47] <mihneadb> gluwpa: you might have to add -> int (return type)
[09:17:14] <dbaupp> gluwpa: it supports sibling call optimisation, but not full TCO, because that would require a different calling convention, which makes all calls slower.
[09:17:25] <dbaupp> gluwpa: (all the optimisation is done by LLVM, btw.)
[09:17:43] <mihneadb> dbaupp: that "one liner" is hard to follow for me atm
[09:17:44] <dbaupp> rusti: let (ps, cs) = std::vec::unzip(~[stream(), stream()]); let mut ps = ps; let mut cs = cs; let (p, c) = stream(); let cc = cs.shift(); do spawn { cc.send(p.recv()) } let pp = ps.pop(); do spawn { c.send(pp.recv()) } cs[0].send(1); ps[0].recv()
[09:17:46] -rusti- 1
[09:17:53] <dbaupp> \o/
[09:18:01] <heftig> rusti: fn factorial(n: uint, acc: uint) -> uint { if n==0 {acc} else {factorial(n-1,acc*n)} }; factorial(12,1)
[09:18:02] -rusti- 479001600
[09:18:04] <dbaupp> mihneadb: yeah, I'm just trying to get something to work
[09:18:12] <heftig> this would be tail-call recursive
[09:18:25] <mihneadb> heftig: does rust ever infer the return type?
[09:18:34] <heftig> mihneadb: no
[09:18:44] <mihneadb> heftig: ok, good to know
[09:18:56] *** Joins: pnkfelix (pnkfelix@87C1F78E.1DE10CA8.D8E68FF6.IP)
[09:19:08] <mihneadb> dbaupp: so how do I trick it? 
[09:19:13] <mihneadb> maybe call .clone() on stuff?
[09:19:16] *** Quits: tcr (tcr@moz-EE576D3C.hsd1.ma.comcast.net) (Ping timeout)
[09:19:38] <mihneadb> no clone on Port
[09:19:55] <mihneadb> ah
[09:20:00] <mihneadb> my functions could borrow the pointers
[09:21:00] <dbaupp> mihneadb: https://gist.github.com/huonw/d90b9e411ed8060ec905
[09:21:39] <mihneadb> dbaupp: oh so you are popping them out one by one so you don't screw up the vector, basically
[09:21:49] <mihneadb> I mean.. move the vector
[09:22:51] *** Quits: LimeBurst (me@247D1419.D73964AC.27A8748.IP) (Ping timeout)
[09:23:04] *** Quits: gluwpa (Mibbit@2163A5B6.84FFD171.17406662.IP) (Quit: http://www.mibbit.com ajax IRC Client)
[09:24:12] <dbaupp> right
[09:24:43] <dbaupp> because if you move out of one element, then the whole vector is no longer useable (as something might accidentally try to use the moved element.)
[09:25:00] <mihneadb> dbaupp: this makes the implementation more complicated/hard to read
[09:25:07] <mihneadb> I was thinking maybe borrowed pointers
[09:25:37] <mihneadb> but it still does not work
[09:27:14] <dbaupp> yeah, it's tricky
[09:28:43] <mihneadb> better go to sleep, try tomorrow
[09:28:44] <mihneadb> thanks
[09:28:45] <mihneadb> :)
[09:28:46] <mihneadb> night
[09:28:50] *** Quits: mihneadb (mihneadb@E48845AB.3A9F9BD4.4C2245EF.IP) (Input/output error)
[09:32:21] *** Joins: grazkea (Mibbit@2163A5B6.84FFD171.17406662.IP)
[09:32:29] *** Quits: ggherdov_ (uid11402@moz-E77DEB21.irccloud.com) (Ping timeout)
[09:32:38] *** Quits: sawrubh (uid6719@moz-5F4AA75A.irccloud.com) (Ping timeout)
[09:32:47] *** Quits: geomyidae__ (uid214@moz-E77DEB21.irccloud.com) (Ping timeout)
[09:32:50] *** Quits: Aetherspawn_BNC (uid6924@moz-31ABA2C0.irccloud.com) (Ping timeout)
[09:32:55] *** kimundi is now known as zz_kimundi
[09:33:00] *** Quits: gazoombo (uid6629@moz-E77DEB21.irccloud.com) (Ping timeout)
[09:33:00] *** Quits: Axord (xord@moz-1B228827.lsanca.dsl-w.verizon.net) (Ping timeout)
[09:33:02] *** Quits: sankha93 (uid12218@moz-31ABA2C0.irccloud.com) (Ping timeout)
[09:33:04] *** Quits: dbaupp (Thunderbir@moz-712A1135.lns20.syd6.internode.on.net) (Ping timeout)
[09:33:05] *** Quits: Crnobog (uid1041@moz-E77DEB21.irccloud.com) (Ping timeout)
[09:33:07] *** Quits: wilfred (uid159@moz-5F4AA75A.irccloud.com) (Ping timeout)
[09:33:11] *** Quits: jez0990 (quassel@moz-3BA8545E.kimsufi.com) (Ping timeout)
[09:33:24] *** Quits: kaeso (kaeso@moz-F21FF626.unstable.it) (Ping timeout)
[09:33:32] <grazkea> rusti: let x=if () {3} {2}; println(x);
[09:33:32] -rusti- <anon>:5:25: 5:26 error: expected `;` but found `{`
[09:33:32] -rusti- <anon>:5          let x=if () {3} {2}; println(x);
[09:33:33] -rusti-                                   ^
[09:33:33] -rusti- application terminated with error code 101
[09:33:36] *** Quits: Seldaek (seld@E733C546.5464C2F1.F113998C.IP) (Ping timeout)
[09:33:37] *** Quits: glandium (glandium@DEB153B8.D2E4ABCD.A00B1FE4.IP) (Ping timeout)
[09:33:38] *** Joins: geomyidae__ (uid214@moz-E77DEB21.irccloud.com)
[09:33:40] *** Joins: dbaupp (Thunderbir@moz-712A1135.lns20.syd6.internode.on.net)
[09:33:42] *** Quits: bbouvier (bnjbouv@moz-63AFAFBF.gagahome.fr) (Ping timeout)
[09:33:42] *** Joins: Axord (xord@moz-1B228827.lsanca.dsl-w.verizon.net)
[09:33:48] *** Quits: nyx114 (nyx114@337D90A6.170C4318.709ED47B.IP) (Ping timeout)
[09:33:48] *** Joins: BizarreCake (BizarreCak@moz-361FE9B2.dynamic.barak-online.net)
[09:34:05] *** Quits: andor (andor@moz-708868D.neferty.me) (Ping timeout)
[09:34:08] *** Quits: darkf (darkf@moz-F9058B8A.net) (Ping timeout)
[09:34:58] *** Joins: jez0990 (quassel@moz-3BA8545E.kimsufi.com)
[09:35:03] *** Quits: grazkea (Mibbit@2163A5B6.84FFD171.17406662.IP) (Quit: http://www.mibbit.com ajax IRC Client)
[09:35:05] *** Joins: Seldaek (seld@moz-5DEA7688.ch)
[09:35:05] *** Joins: bbouvier (bnjbouv@moz-63AFAFBF.gagahome.fr)
[09:35:14] *** Joins: glandium (glandium@moz-A09032B1.kimsufi.com)
[09:35:47] *** Joins: darkf (darkf@moz-F9058B8A.net)
[09:35:48] *** Joins: andor (andor@moz-708868D.neferty.me)
[09:36:28] *** Quits: vk (chatzilla@moz-389FEE13.hsd1.ca.comcast.net) (Quit: ChatZilla 0.9.90.1 [Firefox 23.0/20130729175331])
[09:36:42] *** Joins: peterdn (chatzilla@moz-97742234.new.ox.ac.uk)
[09:36:50] *** Joins: nyx114 (nyx114@337D90A6.170C4318.709ED47B.IP)
[09:36:50] *** Joins: gazoombo (uid6629@moz-E77DEB21.irccloud.com)
[09:36:51] *** Quits: Excureo (c@moz-EB93D257.static.knwc.wa.charter.com) (Ping timeout)
[09:36:51] *** Joins: Crnobog (uid1041@moz-E77DEB21.irccloud.com)
[09:36:51] *** Joins: wilfred (uid159@moz-5F4AA75A.irccloud.com)
[09:36:57] *** Joins: kaeso (kaeso@moz-F21FF626.unstable.it)
[09:37:08] *** Quits: rlin-nb (rlin@moz-8636DBAB.dynamic.hinet.net) (Ping timeout)
[09:37:11] *** Quits: dforsyth (dforsyth@A677A619.1C765EF.EE6E63A5.IP) (Ping timeout)
[09:37:36] *** Quits: sam113101 (sam113101@moz-83612DFD.us-west-2.compute.amazonaws.com) (Ping timeout)
[09:37:44] *** Joins: sam113101 (sam113101@moz-83612DFD.us-west-2.compute.amazonaws.com)
[09:37:47] *** Quits: joelteon (joel@moz-317E8D0C.io) (Ping timeout)
[09:38:23] *** Joins: vodik (simon@moz-CBE4BB13.cable.teksavvy.com)
[09:39:01] *** Quits: Axord (xord@moz-1B228827.lsanca.dsl-w.verizon.net) (Ping timeout)
[09:40:24] *** Quits: kaeso (kaeso@moz-F21FF626.unstable.it) (Ping timeout)
[09:40:27] *** Quits: darkf (darkf@moz-F9058B8A.net) (Ping timeout)
[09:40:30] *** Quits: nyx114 (nyx114@337D90A6.170C4318.709ED47B.IP) (Ping timeout)
[09:40:30] *** Quits: andor (andor@moz-708868D.neferty.me) (Ping timeout)
[09:40:38] *** Quits: jez0990 (quassel@moz-3BA8545E.kimsufi.com) (Ping timeout)
[09:40:40] *** Joins: joelteon (joel@moz-317E8D0C.io)
[09:41:06] *** Quits: bbouvier (bnjbouv@moz-63AFAFBF.gagahome.fr) (Ping timeout)
[09:41:14] *** Quits: Seldaek (seld@moz-5DEA7688.ch) (Ping timeout)
[09:41:14] *** Joins: dforsyth (dforsyth@A677A619.1C765EF.EE6E63A5.IP)
[09:41:18] *** Quits: glandium (glandium@moz-A09032B1.kimsufi.com) (Ping timeout)
[09:41:37] *** Joins: Excureo (c@moz-EB93D257.static.knwc.wa.charter.com)
[09:41:45] *** Joins: rlin-nb (rlin@moz-8636DBAB.dynamic.hinet.net)
[09:42:00] *** Joins: Axord (xord@moz-1B228827.lsanca.dsl-w.verizon.net)
[09:42:29] *** Joins: vk (chatzilla@moz-389FEE13.hsd1.ca.comcast.net)
[09:42:37] <bjz> cmr: ping
[09:43:02] *** Joins: Altazimuth (Max@moz-24A21B33.zone15.bethere.co.uk)
[09:43:07] *** Quits: Altazimuth (Max@moz-24A21B33.zone15.bethere.co.uk) (Quit: Altazimuth)
[09:44:30] *** Joins: bbouvier (bnjbouv@moz-63AFAFBF.gagahome.fr)
[09:44:38] *** Joins: Seldaek (seld@moz-5DEA7688.ch)
[09:44:47] *** Joins: glandium (glandium@moz-A09032B1.kimsufi.com)
[09:45:30] *** Joins: jez0990 (quassel@moz-3BA8545E.kimsufi.com)
[09:45:30] *** Joins: nyx114 (nyx114@337D90A6.170C4318.709ED47B.IP)
[09:46:01] *** Joins: darkf (darkf@moz-F9058B8A.net)
[09:46:14] *** Joins: andor (andor@moz-708868D.neferty.me)
[09:46:27] *** Joins: kaeso (kaeso@moz-F21FF626.unstable.it)
[09:46:52] *** Quits: snadon (chatzilla@moz-3BC727E8.mc.videotron.ca) (Quit: ChatZilla 0.9.90.1 [Firefox 23.0/20130729175331])
[09:46:56] <vk> What does/could/should adding two vectors mean? The specific case I'm looking at is "@~[T] + ~[*T]" (I think).
[09:47:13] *** Joins: Aetherspawn_BNC (uid6924@moz-31ABA2C0.irccloud.com)
[09:47:24] *** Joins: sankha93 (uid12218@moz-31ABA2C0.irccloud.com)
[09:47:26] *** Joins: Altazimuth (Max@moz-24A21B33.zone15.bethere.co.uk)
[09:47:54] *** Quits: Altazimuth (Max@moz-24A21B33.zone15.bethere.co.uk) (Quit: Leaving)
[09:48:32] <vk> Doh, the tutorial has an obvious answer. 
[09:52:07] *** Joins: ggherdov_ (uid11402@moz-E77DEB21.irccloud.com)
[09:54:10] <bjz> eh, drowning in match blocks
[09:54:22] <bjz> :[
[09:54:38] <bjz> (code is so ugly)
[09:54:48] <bjz> :[[
[09:56:15] *** Quits: vk (chatzilla@moz-389FEE13.hsd1.ca.comcast.net) (Quit: ChatZilla 0.9.90.1 [Firefox 23.0/20130729175331])
[09:56:26] *** Quits: donri (dag@moz-9BB61102.tbcn.telia.com) (Client exited)
[09:57:16] *** Joins: sawrubh (uid6719@moz-5F4AA75A.irccloud.com)
[09:58:24] *** Joins: z0w0 (zack@moz-E12708D5.lns6.woo.bigpond.net.au)
[10:00:30] *** Joins: ChrisMorgan (chris@moz-6AC741CA.static.tpgi.com.au)
[10:03:12] <ChrisMorgan> Yay! New runtime means I can stop needing to remember RUST_NEWRT=1 :-)
[10:03:26] * jensnockert hugs bjz.
[10:03:50] <jensnockert> Urgh, this whole &-for-atomics seems a bit broken?
[10:03:51] *** Joins: donri (dag@moz-9BB61102.tbcn.telia.com)
[10:04:14] <bjz> part of the problem is not being able to short circuit ot of do blocks :(
[10:04:19] <jensnockert> Couldn't any atomics on a borrowed ~ptr be replaced with non-atomics?
[10:04:32] <jensnockert> bjz: Yeah, that's a bit annoying.
[10:04:50] *** Joins: mindginative (mindginati@moz-268511E5.dsl.dyn.ihug.co.nz)
[10:04:54] <bjz> so I hve to do nested matches instead of monadic chaining
[10:05:10] <bjz> :(
[10:05:22] <doomlord> i was just about to ask is there a convinient pattern in rust for that sort of thing ..
[10:05:40] <bjz> trying to think of a better one
[10:05:57] <bjz> I'm considering messaging to another entity
[10:06:25] <bjz> I'm doing parsing with the libxml2 sax parser
[10:06:52] <bjz> the sax callbacks send messages to my datastructure factory
[10:07:32] <bjz> I'm thinking I might need another thingy in the middle to extract the semantic information
[10:07:46] *** Joins: maxli (maxli@B5559308.9C54E60.2FA4EA88.IP)
[10:08:03] <doomlord> fn chain(f1:&fn(a:A)->Option<B>, f2:fn(b:B)->Option<C>... ) .. but you'd need chain1 chain2 chain3 ..
[10:12:13] *** Joins: FrozenCow (FrozenCow@moz-B2DF4929.chello.nl)
[10:12:44] *** mindginative is now known as richard|s
[10:15:10] *** Quits: rlin-nb (rlin@moz-8636DBAB.dynamic.hinet.net) (Ping timeout)
[10:17:14] *** Joins: int3_ (int3_@moz-ABE52D50.hsd1.ca.comcast.net)
[10:18:24] *** Quits: maxli (maxli@B5559308.9C54E60.2FA4EA88.IP) (Quit: Leaving.)
[10:18:29] *** Joins: tcr (tcr@moz-EE576D3C.hsd1.ma.comcast.net)
[10:18:41] *** Quits: sanxiyn (tinuviel@858F408C.B797260D.EF43EC08.IP) (Quit: Leaving)
[10:20:10] *** Quits: tcr (tcr@moz-EE576D3C.hsd1.ma.comcast.net) (Ping timeout)
[10:22:33] *** Quits: vodik (simon@moz-CBE4BB13.cable.teksavvy.com) (Quit: WeeChat 0.4.2-dev)
[10:30:22] *** Joins: q66 (q66@6EE9DE40.46454B5D.33AABD5F.IP)
[10:31:17] *** Quits: maikklein (maik@moz-5AED6CF8.dip0.t-ipconnect.de) (Ping timeout)
[10:31:28] *** Joins: rlin-nb (rlin@moz-99690620.hinet-ip.hinet.net)
[10:35:40] *** Quits: jensnockert (jensnocker@moz-61E1062F.tbcn.telia.com) (Input/output error)
[10:35:52] <doomlord> does the standard lib include a container which is a 1:many item map eg m.insert(1,~"foo"), m.inssert(1,~"bar")  m.find(1) == [~"foo",~"bar"] or some iterator 
[10:37:37] *** Joins: leonvv (leonvv@moz-7D83A5F1.ip.telfort.nl)
[10:39:05] *** Joins: Earnestly (earnest@3F74F9E2.8E6FE497.30311652.IP)
[10:44:02] *** Joins: jensnockert (jensnocker@moz-61E1062F.tbcn.telia.com)
[10:46:23] *** Quits: rlin-nb (rlin@moz-99690620.hinet-ip.hinet.net) (Quit: Leaving.)
[10:50:33] *** Joins: igl (igl@moz-BB252A1B.adsl.alicedsl.de)
[11:00:40] *** Joins: mkohler (mkohler@moz-8FC716BF.static.212-41-220-23.swisscomdata.ch)
[11:01:36] <mkohler> hi guys, I got    let foo = ~["bar","baz"]; .. why is this static?
[11:01:53] *** Quits: ab (alex@BC9D99CC.37C1012D.FE617B51.IP) (Quit: Konversation terminated!)
[11:04:33] *** Joins: engla (engla@moz-DBD1D96E.cust.bredbandsbolaget.se)
[11:06:14] <doomlord> static strings ,without ~"..."
[11:06:16] <doomlord> ?
[11:08:37] *** Joins: SiegeLord (sl@moz-CAF07B4C.hsd1.ma.comcast.net)
[11:10:00] *** Joins: Cromulent (Cromulent@moz-983B638D.cable.virginmedia.com)
[11:10:14] *** Quits: sk (sk@61A494B3.BA40E8A.AAC02D62.IP) (Input/output error)
[11:13:47] <mkohler> thanks
[11:13:53] *** Quits: Cromulent (Cromulent@moz-983B638D.cable.virginmedia.com) (Quit: KVIrc 4.2.0 Equilibrium http://www.kvirc.net/)
[11:14:33] *** Joins: gavinb (gavinb@moz-9EC182F0.lowrp3.vic.optusnet.com.au)
[11:16:54] *** Quits: richard|s (mindginati@moz-268511E5.dsl.dyn.ihug.co.nz) (Quit: zzZZZ)
[11:18:49] *** Joins: tcr (tcr@moz-EE576D3C.hsd1.ma.comcast.net)
[11:20:29] *** Quits: tcr (tcr@moz-EE576D3C.hsd1.ma.comcast.net) (Ping timeout)
[11:21:36] *** Quits: recrack (Mibbit@B4104EBB.3CC170B1.1E14B209.IP) (Quit: http://www.mibbit.com ajax IRC Client)
[11:22:39] *** Quits: q66 (q66@6EE9DE40.46454B5D.33AABD5F.IP) (Client exited)
[11:27:36] *** Joins: q66 (q66@6EE9DE40.46454B5D.33AABD5F.IP)
[11:27:48] *** Quits: leonvv (leonvv@moz-7D83A5F1.ip.telfort.nl) (Client exited)
[11:31:56] *** Quits: SiegeLord (sl@moz-CAF07B4C.hsd1.ma.comcast.net) (Quit: It's a joke, it's all a joke.)
[11:35:09] *** Joins: cubic (cubic@moz-FE5AD6C7.mc.videotron.ca)
[11:44:32] *** Joins: maikklein (maik@moz-5AED6CF8.dip0.t-ipconnect.de)
[11:53:10] *** Quits: z0w0 (zack@moz-E12708D5.lns6.woo.bigpond.net.au) (Client exited)
[11:55:07] *** Joins: Houm (Houm@moz-25669AA8.fbx.proxad.net)
[11:55:25] *** zz_kimundi is now known as kimundi
[11:56:09] *** Joins: Azdle (patrick@moz-8C723B60.hsd1.mn.comcast.net)
[11:56:15] *** Joins: ab (alex@BC9D99CC.37C1012D.FE617B51.IP)
[11:57:51] *** Joins: bjz_ (brendanzab@B398BE78.F804C29E.D35A31DF.IP)
[11:57:54] *** Quits: bjz (brendanzab@B398BE78.F804C29E.D35A31DF.IP) (Connection reset by peer)
[11:59:57] <maikklein> bjz_, ping
[12:00:04] <bjz_> maikklein: yo
[12:00:17] <maikklein> bjz_, do you have some experience with detlatime in 2d?
[12:00:25] <maikklein> deltatime*
[12:00:28] <bjz_> maikklein: no :(
[12:01:37] <maikklein> me neither I was wondering how I can achieve this, because I can only manipulate the pixel position which is an i16 and I can't really multiply this with a delta. So I just made a fixed framerate :(
[12:04:46] <engla> this must be a bug?
[12:04:48] <engla> rusti:  match Some(1) { ref x@Some(*) => 1, None => 0 }
[12:04:49] -rusti- <anon>:5:10: 5:57 error: non-exhaustive patterns
[12:04:49] -rusti- <anon>:5           match Some(1) { ref x@Some(*) => 1, None => 0 }
[12:04:49] -rusti-                    ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
[12:04:49] -rusti- error: aborting due to previous error
[12:04:49] -rusti- application terminated with error code 101
[12:05:08] *** Quits: mkohler (mkohler@moz-8FC716BF.static.212-41-220-23.swisscomdata.ch) (Ping timeout)
[12:05:50] <dbaupp> engla: seems like one
[12:06:23] <dbaupp> rusti: match Some(1) { x@Some(*) => 1, None => 0 }
[12:06:24] -rusti- <anon>:5:25: 5:34 warning: unused variable: `x` [-W unused-variable (default)]
[12:06:24] -rusti- <anon>:5          match Some(1) { x@Some(*) => 1, None => 0 }
[12:06:24] -rusti-                                   ^~~~~~~~~
[12:06:24] -rusti- 1
[12:06:44] <dbaupp> rusti: match Some(1) { (ref x)@Some(*) => 1, None => 0 }
[12:06:44] -rusti- <anon>:5:31: 5:32 error: expected `,` but found `)`
[12:06:44] -rusti- <anon>:5          match Some(1) { (ref x)@Some(*) => 1, None => 0 }
[12:06:44] -rusti-                                         ^
[12:06:45] -rusti- application terminated with error code 101
[12:09:50] <engla> I'll report it
[12:10:35] <maikklein> what does this mean? (ref x)@Some(*)
[12:11:03] <dbaupp> maikklein: nothing, it doesn't parse
[12:11:03] <maikklein> @Some(ref x) would make sense, but this seems a little bit strange
[12:11:09] <maikklein> ah
[12:11:10] *** Joins: maxli (maxli@13F2CEC5.7672369.D8E68FF6.IP)
[12:11:35] <dbaupp> but ident@pattern means match the pattern, but call the whole lot `ident`
[12:11:48] <engla> what is the  @-binding called?
[12:12:37] <dbaupp> engla: haskell calls them as-patterns
[12:13:37] <dbaupp> maikklein: (it lets you e.g. match on lists of length 2, but keep the list structure `match foo { x@[_, _] => ..., ... other matches ... }`)
[12:17:27] <maikklein> hm
[12:17:44] <cmr> bjz_: pong
[12:18:26] <bstrie> dbaupp: I refuse to believe that haskell would come up with any name as straightforward as "as-patterns"
[12:18:37] <maikklein> :D
[12:19:10] *** Joins: tcr (tcr@moz-EE576D3C.hsd1.ma.comcast.net)
[12:19:12] <bjz_> cmr: currently getting a good way through implementing the registry parser in Rust
[12:19:21] <cmr> !
[12:19:21] <bstrie> I propose we refer to our "as-patterns" as "holozygotic monoreferences"
[12:19:30] <bjz_> cmr: using libxml
[12:19:33] <cmr> bstrie: I second that proposal
[12:19:33] <bstrie> just to make the haskell devs jealous of our bigger words
[12:20:03] <bjz_> cmr: would you be able to have a look once I get further along?
[12:20:14] <cmr> bjz_: yeah, definitely
[12:20:31] <bjz_> cmr: would like to have some feedback on how to clean it up :)
[12:20:32] *** Quits: KindOne (KindOne@moz-9626F9F2.dynamic.ip.windstream.net) (Ping timeout)
[12:20:32] <maikklein> what is a registry parster?
[12:20:41] <bjz_> maikklein: for OpenGL
[12:20:44] <cmr> maikklein: the OpenGL XML registry
[12:20:44] <dbaupp> bstrie: well, one of *our* devs has the handle catamorphism; they're already jealous.
[12:20:55] <cmr> http://www.opengl.org/registry/
[12:20:58] <bjz_> maikklein: I'm finally getting around to it
[12:20:58] *** Joins: KindTwo (KindOne@moz-55C59F2E.dynamic.ip.windstream.net)
[12:21:04] <bjz_> :P
[12:21:31] <maikklein> ah cool the xml opengl thingy
[12:21:51] <bjz_> maikklein: the glloadgen fork is too hard to maintain
[12:21:56] <bjz_> maikklein: :(
[12:22:05] <bstrie> dbaupp: though I think he chose that handle back when he was working on the haskell compiler :P
[12:22:11] *** KindTwo is now known as KindOne
[12:23:03] <dbaupp> bstrie: they're even more jealous then! they couldn't hang on to it!
[12:23:33] <maikklein> bjz_, what is the advantage?
[12:23:48] <bjz_> Hashmap<~str, str> -> ~"key0=\"val0\" key1=\"val1\" key2=\"val2\" ..." <- how?
[12:23:53] <bjz_> with iterators?
[12:24:07] <dbaupp> cmr: btw, brson was interested in getting more bench data :)
[12:24:16] <bjz_> I mean Hashmap<~str, ~str>
[12:24:20] <bjz_> maikklein: to what?
[12:24:35] <cmr> bjz_: .iter() on a HashMap returns every key-value pair in turn
[12:24:56] <maikklein> bjz_, the xml api vs sth like glloadgen
[12:25:05] <bjz_> cmr: how do you join the together?
[12:25:05] <dbaupp> bjz_: hashmap.iter().transform(|(k,v)| fmt!("%s=\"%s\"", *k, *v)).to_owned_vec().connect(" ")
[12:25:32] <dbaupp> (there currently isn't a join for iterators... but the vec one is fast... so that's nice :P )
[12:25:34] <bjz_> dbaupp: hah, cheers
[12:25:43] *** Joins: mkohler (mkohler@moz-8FC716BF.static.212-41-220-23.swisscomdata.ch)
[12:25:50] <bjz_> dbaupp: I still don't really get iterators :(
[12:26:00] <engla> bjz_: the fundamentals are easy
[12:26:09] *** Quits: mkohler (mkohler@moz-8FC716BF.static.212-41-220-23.swisscomdata.ch) (Client exited)
[12:27:14] <dbaupp> bjz_: they're essentially just a data structure that you call .next() on to get the next element in whatever sequence it represents
[12:27:28] <dbaupp> bjz_: and all the non-next methods are just wrappers around higher-order functionality
[12:27:36] *** Quits: gavinb (gavinb@moz-9EC182F0.lowrp3.vic.optusnet.com.au) (Quit: gavinb)
[12:27:40] *** Quits: reyre (reyre@moz-9002CDDA.cpe.net.cable.rogers.com) (Client exited)
[12:28:13] <maikklein> hm
[12:29:48] <maikklein> is the difference between map and tranform that transform makes it changes inplace and map creates something new?
[12:29:50] <ChrisMorgan> "The ocean ate the last of the land and poured into the smoking gulf, thereby ..." [eight more lines] "fatal runtime error: thread-local pointer is null. bogus!" Rather a verbose error, donchaknow? (Crash case was multi-threaded I/O, so don't worry, I expected it to crash.)
[12:30:06] <bjz_> dbaupp: is there a way of connecting without the string?
[12:30:23] <cmr> ChrisMorgan: I love the poetry
[12:30:39] <bjz_> ChrisMorgan: I love brson's fatal errors
[12:31:22] <dbaupp> bjz_: I'm not sure I understand that question
[12:31:42] <bjz_> dbaupp: something equivalent to .connect("")
[12:31:54] <dbaupp> bjz_: .concat()
[12:31:55] <maikklein> bjz_, do we still need external function pointer with your registry parster?
[12:32:03] <cmr> maikklein: yes
[12:32:08] <bjz_> maikklein: yes :(
[12:32:11] <maikklein> parser* // what is wrong with me
[12:32:15] * maikklein is sad
[12:32:19] <dbaupp> bjz_: (although, .connect() is actually special cased for .connect("") to call .concat() ;) )
[12:32:28] <maikklein> well at least I can play with sdl
[12:32:29] <bjz_> dbaupp: hawhaw
[12:32:43] <bjz_> maikklein: were you needing me to fix lmath?
[12:32:59] <maikklein> bjz_, I tried it a few days ago and I failed :(
[12:33:03] <dbaupp> maikklein: .transform is defined on iterators, .map is defined on vectors, that's the only difference
[12:33:14] <bjz_> maikklein: sorry, been distracted working on this registry thinga
[12:33:17] <bjz_> maikklein
[12:33:28] <maikklein> bjz_, I fixed all the for loops, but there were weird trait errors that I couldn't figure out
[12:33:28] <bjz_> maikklein: so much to do at once!
[12:33:35] <bjz_> yeah
[12:33:37] <maikklein> bjz_, haha you have too many libs :D
[12:33:54] <bjz_> maikklein: mainly just wrappers
[12:34:02] <SimonSapin> Do generic functions/types work across crates?
[12:34:08] <bjz_> SimonSapin: yarr
[12:34:15] <dbaupp> SimonSapin: in theory, yes, why?
[12:34:28] <SimonSapin> " error: mismatched types: expected `BUG[0]` but found `cssparser::tokenizer::Parser` (expected type parameter but found struct cssparser::tokenizer::Parser)"
[12:34:53] <bjz_> haw
[12:34:58] <bjz_> haw haw haw
[12:35:01] <maikklein> bjz_, I will have a look later today, I hope that I can fix it :)
[12:35:04] <cmr> That's almost as good as [type error]
[12:35:14] <SimonSapin> grep tells me that BUG[0] comes from librustc/util/ppaux.rs, which has a comment "this should not happen"
[12:35:24] <bjz_> haw haw hahwha
[12:35:36] <cmr> (someone broke bjz_!)
[12:35:50] <bjz_> haarrrrghagaSimonSapinhwaa
[12:36:06] <maikklein> I think bjz_ is just a pirate
[12:36:07] <engla> dbaupp: clonable iterators could implement StrVector (for .connect()). clonable so it can be identical to the implementation on &[]
[12:36:07] <bjz_> ha
[12:36:09] * ChrisMorgan observed lots of occurrences of BUG in the debug output when compiling normal stuff, not sure if it indicates a bug or just that things haven't been resolved yet
[12:36:30] *** Joins: msingle (Thunderbir@moz-5B594248.openskytelcom.net)
[12:36:44] <dbaupp> engla: oh, yes!
[12:36:48] <dbaupp> engla: that'd be neat
[12:36:53] *** Joins: jorendorff (jorendorff@moz-2F32ACA3.hsd1.tn.comcast.net)
[12:36:55] <bjz_> maikklein: yarthunkyar, send thee a p-arrr
[12:37:02] <maikklein> dbaupp, so vec.map == vec.iter().transform ?
[12:37:10] <heftig> not quite
[12:37:14] <maikklein> dbaupp, what should I use if I have the choice?
[12:37:29] <dbaupp> maikklein: vec.map == vec.iter90.transform.to_owned_vec()
[12:37:30] <heftig> rusti: let a = @[1u,2u,3u]; a.map(|x| { x + 1 })
[12:37:31] -rusti- ~[2, 3, 4]
[12:37:34] <dbaupp> *()
[12:37:46] <dbaupp> engla: oh, yes!
[12:37:59] <engla> I like your repeated oh, yes
[12:38:00] <heftig> rusti: let a = @[1u,2u,3u]; a.iter().transform(|x| { x + 1 })
[12:38:00] <engla> es
[12:38:00] -rusti- {iter: {ptr: (0x7fbad0200930 as *()), end: (0x7fbad0200948 as *()), lifetime: &1}, f: }
[12:38:01] <maikklein> ah ok
[12:38:12] <dbaupp> engla: it'd be nice if we could implement it for all Iterators, and then Cloneable ones get a specialised version
[12:38:18] <engla> Right
[12:38:33] <engla> but it's not possible right now
[12:38:38] <dbaupp> engla: (oh, oops... I was going to say something, but then I got distracted... and forgot I'd started my reply.)
[12:38:44] <dbaupp> yeah :(
[12:39:10] *** Quits: tcr (tcr@moz-EE576D3C.hsd1.ma.comcast.net) (Ping timeout)
[12:39:53] *** Quits: jorendorff (jorendorff@moz-2F32ACA3.hsd1.tn.comcast.net) (Quit: jorendorff)
[12:39:59] <cmr> rusti: enum Foo { Bar(~str) }; let x = Bar(~"asdf"); match x { Bar(x) { x.replace("a", "b") } } x
[12:40:00] -rusti- <anon>:5:72: 5:73 error: expected `=>` but found `{`
[12:40:00] -rusti- <anon>:5          enum Foo { Bar(~str) }; let x = Bar(~"asdf"); match x { Bar(x) { x.replace("a", "b") } } x
[12:40:00] -rusti-                                                                                  ^
[12:40:00] -rusti- application terminated with error code 101
[12:40:05] <cmr> rusti: enum Foo { Bar(~str) }; let x = Bar(~"asdf"); match x { Bar(x) => { x.replace("a", "b") } } x
[12:40:05] -rusti- <anon>:5:55: 5:100 error: mismatched types: expected `()` but found `~str` (expected () but found ~str)
[12:40:05] -rusti- <anon>:5          enum Foo { Bar(~str) }; let x = Bar(~"asdf"); match x { Bar(x) => { x.replace("a", "b") } } x
[12:40:06] -rusti-                                                                 ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
[12:40:09] -rusti- error: aborting due to previous error
[12:40:11] -rusti- application terminated with error code 101
[12:40:15] <cmr> rusti: enum Foo { Bar(~str) }; let x = Bar(~"asdf"); match x { Bar(x) => { x.replace("a", "b"); } } x
[12:40:16] -rusti- pastebinned 8 lines of output: http://sprunge.us/GZbI
[12:40:44] <cmr> rusti: enum Foo { Bar(~str) }; let x = Bar(~"asdf"); let y = match x { Bar(x) => { x.replace("a", "b"); x } } y
[12:40:44] -rusti- <anon>:5:112: 5:113 error: expected `;` but found `y`
[12:40:44] -rusti- <anon>:5          enum Foo { Bar(~str) }; let x = Bar(~"asdf"); let y = match x { Bar(x) => { x.replace("a", "b"); x } } y
[12:40:44] -rusti-                                                                                                                          ^
[12:40:44] -rusti- application terminated with error code 101
[12:40:47] <cmr> rusti: enum Foo { Bar(~str) }; let x = Bar(~"asdf"); let y = match x { Bar(x) => { x.replace("a", "b"); x } }; y
[12:40:48] -rusti- ~"asdf"
[12:41:05] <cmr> well, that's not what I wanted to demonstrate
[12:41:10] <SimonSapin> bjz_: is it that bad?
[12:41:26] <bjz_> SimonSapin: wu?
[12:41:31] <cmr> rusti: enum Foo { Bar(~str) }; let x = Bar(~"asdf"); let y = match x { Bar(x) => { x.clear(); x } }; y
[12:41:31] -rusti- <anon>:5:85: 5:86 error: cannot borrow immutable local variable as mutable
[12:41:32] -rusti- <anon>:5          enum Foo { Bar(~str) }; let x = Bar(~"asdf"); let y = match x { Bar(x) => { x.clear(); x } }; y
[12:41:32] -rusti-                                                                                               ^
[12:41:32] -rusti- error: aborting due to previous error
[12:41:32] -rusti- application terminated with error code 101
[12:41:36] <cmr> rusti: enum Foo { Bar(~str) }; let x = Bar(~"asdf"); let y = match x { Bar(mut x) => { x.clear(); x } }; y
[12:41:37] -rusti- pastebinned 7 lines of output: http://sprunge.us/bRAN
[12:41:45] <SimonSapin> the error message from earlier
[12:41:48] <cmr> How can I get a mutable thingy out of a match?
[12:41:52] <maikklein> u cannot beat the compiler :D
[12:41:59] <cmr> rusti: enum Foo { Bar(~str) }; let mut x = Bar(~"asdf"); let y = match x { Bar(x) => { x.clear(); x } }; y
[12:41:59] -rusti- <anon>:5:89: 5:90 error: cannot borrow immutable local variable as mutable
[12:41:59] -rusti- <anon>:5          enum Foo { Bar(~str) }; let mut x = Bar(~"asdf"); let y = match x { Bar(x) => { x.clear(); x } }; y
[12:42:00] -rusti-                                                                                                   ^
[12:42:00] -rusti- error: aborting due to previous error
[12:42:00] -rusti- application terminated with error code 101
[12:42:25] <bjz_> SimonSapin: no idea, it was just hilaaaarious
[12:42:31] <bjz_> hawhawe
[12:42:51] * bjz_ laughs at SimonSapin's misfortune
[12:42:54] <dbaupp> bjz_: are you drunk? haha
[12:42:58] <SimonSapin> :(
[12:43:10] *** Quits: msingle (Thunderbir@moz-5B594248.openskytelcom.net) (Ping timeout)
[12:43:11] <bjz_> dbaupp: no, just a pirate
[12:43:15] <Ms2ger> Arr.
[12:43:16] <cmr> so... yes
[12:43:25] <dbaupp> rusti: enum Foo { Bar(~str) }; let mut x = Bar(~"asdf"); let y = match x { Bar(x) => { let mut x = x; x.clear(); x } }; y
[12:43:26] -rusti- <anon>:5:41: 5:42 warning: variable does not need to be mutable [-W unused-mut (default)]
[12:43:26] -rusti- <anon>:5          enum Foo { Bar(~str) }; let mut x = Bar(~"asdf"); let y = match x { Bar(x) => { let mut x = x; x.clear(); x } }; y
[12:43:26] -rusti-                                                   ^
[12:43:26] -rusti- ~""
[12:43:41] <Ms2ger> In that case
[12:43:42] <cmr> dbaupp: that seems odd but I'll take it
[12:43:50] <Ms2ger> Do what you want, 'cause a pirate is free
[12:44:01] <dbaupp> cmr: it should/will be `Bar(mut x)` but that's not implemented yet
[12:44:31] <dbaupp> (this will have the fortunate consequence that `let (mut port, mut chan) = stream();` etc is possible.)
[12:44:51] <cmr> I think we should re-introduce distributed mutable bindins
[12:44:55] <cmr> let mut (....) = ...
[12:45:06] <cmr> it's much more explicitly distributive with the parens I think
[12:45:15] <cmr> but it's not really a big deal
[12:46:48] *** Quits: maikklein (maik@moz-5AED6CF8.dip0.t-ipconnect.de) (Ping timeout)
[12:47:07] *** Joins: msingle (Thunderbir@moz-930E5D97.hr.hr.cox.net)
[12:47:17] <bjz_> cmr: yeah, I think that'd be a good idea
[12:47:31] <bjz_> cmr: the intent is very clear
[12:53:36] *** Parts: ChrisMorgan (chris@moz-6AC741CA.static.tpgi.com.au) ()
[12:53:41] *** Joins: ChrisMorgan (chris@moz-6AC741CA.static.tpgi.com.au)
[12:55:11] *** Quits: Azdle (patrick@moz-8C723B60.hsd1.mn.comcast.net) (Ping timeout)
[12:55:36] *** Joins: LimeBurst (me@247D1419.D73964AC.27A8748.IP)
[12:56:07] <Ms2ger> Is that Rust's Foo* bar, baz?
[12:56:21] <cmr> what?
[12:58:50] <jensnockert> Ms2ger: Yes.
[13:02:15] *** Joins: saneyuki_s (Mibbit@moz-A3FEAA56.ap219.ftth.ucom.ne.jp)
[13:03:14] *** Joins: jdm (jdm@92FB48CA.8B5E9DF.9A8C35B4.IP)
[13:08:55] <ChrisMorgan> Due to illness in our scheduled speaker, we have Nicholas Nethercote (most notably of Firefox's MemShrink project) coming for a seminar tomorrow morning at Uni. Basic research confirms he's at least aware of Rust and Servo (of course!). Anyone got any suggestions of things I should ask him?
[13:09:27] *** Quits: jensnockert (jensnocker@moz-61E1062F.tbcn.telia.com) (Input/output error)
[13:10:14] <bstrie> ChrisMorgan: which uni?
[13:10:18] <ChrisMorgan> Monash.
[13:10:33] <bstrie> gesundheit
[13:11:00] <bstrie> what's the audience?
[13:12:10] <ChrisMorgan> Fourth-year Bachelor of Software Engineering students.
[13:13:18] <ChrisMorgan> I'm unlikely to be the only one that has heard of Rust, but am probably the only one to have actually tried using it.
[13:14:05] <bstrie> well asking about rust specifically might be off-topic :P
[13:14:54] *** Quits: xazax (Mibbit@6655692F.3B222813.3F580572.IP) (Quit: http://www.mibbit.com ajax IRC Client)
[13:15:02] <Ms2ger> What's the talk about?
[13:15:06] <bstrie> also, you think someone else in your class will have heard of rust? that seems optimistic :)
[13:15:14] <dbaupp> (and, if he hasn't tried using it, you may know more than him anyway :P )
[13:15:30] <ChrisMorgan> Nah, that and Servo will be quite appropriate. The talk is largely about managing such projects, and these are a great example of doing so!
[13:15:57] <ChrisMorgan> bstrie: of 22 people in the class, I think a couple will have heard of it.
[13:16:10] <ChrisMorgan> (A couple other than me, that is.)
[13:17:22] <bstrie> I think asking about servo would be more relevant to the topic
[13:17:23] *** Quits: int3_ (int3_@moz-ABE52D50.hsd1.ca.comcast.net) (Client exited)
[13:17:49] *** Joins: devinus (devinus@moz-B4AF84BC.ptr.us.xo.net)
[13:17:53] <bstrie> something like "so you're embarking on what might very well be a multimillion-line codebase one day, how do you even begin to approach a project like that?"
[13:18:44] <Ms2ger> "What the hell *were* you thinking?" :)
[13:19:14] <ChrisMorgan> bstrie: good idea. I've wondered exactly that.
[13:19:34] <bstrie> "how will you ensure that something like the memshrink project won't be necessary for servo one day?"
[13:19:52] <ChrisMorgan> I like it!
[13:20:08] <cmr> more, how *can*
[13:20:12] * ChrisMorgan notes these down in order to not forget them
[13:22:09] <ChrisMorgan> ... or even _should_ you work that way?
[13:22:19] <bstrie> "were gecko's memory problems exacerbated by the design of C++, and are rust's memory primitives expressive enough and performant enough to avoid the same fate? would writing in strict C++11 have had the same effect?"
[13:22:39] <bstrie> s/writing/writing servo
[13:23:16] <Ms2ger> And how about if you wrote it in OCaml?
[13:23:30] <dbaupp> (that sounds like a detailed question that requires reasonably deep knowledge of Rust to answer.)
[13:29:36] *** Quits: StarLight (StarLight@moz-B8E3BA82.dynamic.avangarddsl.ru) (Ping timeout)
[13:29:40] *** Joins: StarLight (StarLight@moz-B8E3BA82.dynamic.avangarddsl.ru)
[13:31:52] *** Joins: erickt1 (Adium@49C4075F.3AC15C18.2321E71E.IP)
[13:32:31] *** Quits: true_droid (true_droid@moz-123FD9B8.beck.volia.net) (Client exited)
[13:33:11] *** Quits: jaen (jaen@moz-CC026488.neoplus.adsl.tpnet.pl) (Ping timeout)
[13:37:52] <bjz_> ChrisMorgan: you'd probably want the perspective of Mozilla devs looking in from outside. what do they think of the project?
[13:38:03] *** Joins: Kruppe (user@moz-E150F49F.cpe.net.cable.rogers.com)
[13:38:23] *** Joins: tcr (tcr@moz-EE576D3C.hsd1.ma.comcast.net)
[13:39:04] *** Joins: reyre (reyre@B2D8AB09.33EE9F8A.1139E686.IP)
[13:40:03] *** Quits: tcr (tcr@moz-EE576D3C.hsd1.ma.comcast.net) (Ping timeout)
[13:40:18] * ChrisMorgan finally added an eensy bit of polish to his HTTP server, putting the Makefile where it should be (/, not /src/, stopping it building into the src directory) and adding a README file
[13:41:56] <dbaupp> ChrisMorgan: you should add the polish of using git. :P
[13:42:11] <bstrie> you can add a little bit of polish by adding support for the "pl" ISO language code
[13:42:19] <cmr> hah!
[13:42:25] <cmr> bstrie: you win a funny point
[13:42:37] <bstrie> throw it on the pile
[13:42:50] <bstrie> the pile where I collect my irc karma
[13:43:13] * dbaupp gives a · to bstrie
[13:43:19] <bstrie> alternatively, click this arrow: ↑
[13:44:23] * Ms2ger clicks ↓
[13:45:05] * bstrie clicks "ban Ms2ger"
[13:45:33] <erickt1> morning all! Anyone know if bors got turned off? I see a bunch of things in the approved queue that didn't get built yet
[13:45:39] <cmr> erickt1: yes
[13:45:42] *** Joins: novabyte (Instantbir@moz-3E0F9699.cable.virginmedia.com)
[13:45:45] <Ms2ger> bstrie, aww, that's not nice :)
[13:45:46] <cmr> tree closed for newrt
[13:45:54] <cmr> just gotta wait for graydon to wake up and flip him back on
[13:46:20] <dbaupp> erickt1: pong
[13:46:52] <erickt1> dbaupp: did I ping you? If so, I completely forgot what for :)
[13:46:58] <engla> so bors has been slacking off again
[13:47:16] <dbaupp> erickt1: yeah, I believe you did :)
[13:47:35] *** Joins: int3_ (int3_@moz-ABE52D50.hsd1.ca.comcast.net)
[13:47:49] <cmr> ##OpenGL modified:   src/llvm (new commits)
[13:47:50] *** Quits: int3_ (int3_@moz-ABE52D50.hsd1.ca.comcast.net) (Connection reset by peer)
[13:47:58] <cmr> ERm, that's a weird tab completion
[13:47:59] <cmr> anyway
[13:48:04] *** Joins: int3_ (int3_@moz-ABE52D50.hsd1.ca.comcast.net)
[13:48:08] <cmr> why does git tell me src/llvm is modified and how can I make it stop
[13:48:12] <cmr> /I/ haven't touched it
[13:48:33] <Ms2ger> Uninstall git? ;)
[13:49:11] <doy> cmr: 'git submodule update', i think
[13:49:27] *** Quits: erickt1 (Adium@49C4075F.3AC15C18.2321E71E.IP) (Quit: Leaving.)
[13:49:37] <cmr> doy: ah yup, thanks!
[13:51:21] <cmr> dbaupp: Alright, onto the bencher!
[13:51:34] <dbaupp> cmr: <3
[13:51:43] <novabyte> I've been reading about Rust's Macro system
[13:51:49] *** Quits: BizarreCake (BizarreCak@moz-361FE9B2.dynamic.barak-online.net) (Connection reset by peer)
[13:51:57] <bstrie> novabyte: the macro system has been reading about you as well
[13:51:59] <novabyte> I want to experiment with building something similar to this:
[13:51:59] <novabyte> https://github.com/PhilippeSigaud/Pegged
[13:52:16] <novabyte> bstrie: Lol, I'm sure it has ;)
[13:52:39] <dbaupp> bstrie: you're infinitely helpful :P
[13:52:39] <novabyte> but I don't know how comparable Rust's metaprogramming features are to D's
[13:52:54] <bstrie> novabyte: nowhere near close to what D can do, by design
[13:53:05] <dbaupp> novabyte: a lot weaker, at the moment
[13:53:06] <pauls> novabyte: as I understand it the main thing that Rust lacks is compile-time-function evaluation.
[13:53:09] <olsonjeffery> cmr: i want to say the configure and make scripts will take care of submodule drift
[13:53:15] <cmr> novabyte: I don't think it'd be possible with a "normal" macro, you'd need a procedural macro (syntax extension)
[13:53:23] <olsonjeffery> if you just re-run them it usually rights itself
[13:53:26] <novabyte> ok, so implementing FSAs via CTFE is a no go...
[13:53:36] <cmr> novabyte: we don't have CTFE yet, is the thing
[13:53:42] <novabyte> ah I see
[13:53:50] <dbaupp> novabyte: at some point in the future, it'll be possibly to write and load external syntax extensions (like fmt!) in Rust; not currently though.
[13:54:00] <novabyte> that would be awesome
[13:54:02] *** Quits: int3_ (int3_@moz-ABE52D50.hsd1.ca.comcast.net) (Ping timeout)
[13:54:04] <bstrie> novabyte: we do have the ability to do arbitrary stuff at compile-time via a mechanism called "syntax extensions", but right now these must be built-in to the compiler
[13:54:11] <pauls> (and we won't have CTFE specifically, we'll have procedural macros... which pretty much encompass it, but I think they work differently)
[13:54:28] <cmr> pauls: pcwalton has been talking about how we could implement CTFE
[13:54:42] <novabyte> ok, thanks all. where can I go to read more about syntax extensions in the compiler?
[13:54:53] * dbaupp had a proof of concept of loading external syntax extensions, but it is impossible to make it proper atm.
[13:55:00] <cmr> novabyte: the source. there isn't any documentation of it
[13:55:16] <dbaupp> novabyte: libsyntax/ext/{base,expand}.rs are the starting points
[13:55:32] <cmr> (the source is commented, though!)
[13:55:46] <dbaupp> (except, some of the comments are outdated.)
[13:55:49] <pauls> novabyte: but they're pretty simple. They're just functions that take an AST and produce and AST...
[13:56:08] <pauls> ...OTOH, some of the tools they use to make the process reasonable are complicated.
[13:56:20] <novabyte> ok, thank you. I'll do some source reading :)
[14:00:37] *** Joins: gits1225 (gits@89918D7.F2C235BD.425A25DC.IP)
[14:00:57] *** Quits: cdidd (cdidd@moz-C2A8EEFB.broadband.corbina.ru) (Input/output error)
[14:02:14] *** Joins: Azdle (Azdle@moz-B334B496.hfc.comcastbusiness.net)
[14:06:09] *** Joins: jedestep (jedestep@34641662.FB4DE631.66C78B76.IP)
[14:08:59] *** Quits: ssalbiz (ssalbiz@moz-21D6B3DE.csclub.uwaterloo.ca) (Client exited)
[14:09:00] *** Quits: mcpherrin (mimcpher@moz-21D6B3DE.csclub.uwaterloo.ca) (Client exited)
[14:10:56] <doomlord_> i thought i understood the module system .. .i always seem to break things when i move things around
[14:12:24] *** Joins: jorendorff (jorendorff@moz-2F32ACA3.hsd1.tn.comcast.net)
[14:12:30] *** Joins: sk (sk@61A494B3.BA40E8A.AAC02D62.IP)
[14:12:31] <doomlord_> "use" is crate relative ? ... if i say "mod x" to bring something into the crate main .rs (whatever i igive to rustc) , other source-files in the crate reference that with "use x::*" ?
[14:12:54] <nmatsakis> pauls: ping
[14:13:03] <pauls> nmatsakis: pong
[14:13:14] <nmatsakis> pauls: so I am trying to add support for attributes to macros...
[14:13:22] <doomlord_> eg main.rs " mod foo; mod bar; ...."       foo.rs:   "use foo::*; ... <symbols of foo now accesible...>"
[14:13:30] <nmatsakis> pauls: I added a tt_outer_attr (#[...]) and tt_inner_attr (#![...]) to the enum,
[14:13:49] <nmatsakis> pauls: and added a bit of code for parsing them,
[14:13:49] *** Quits: jorendorff (jorendorff@moz-2F32ACA3.hsd1.tn.comcast.net) (Quit: jorendorff)
[14:13:53] <dbaupp> doomlord_: yes, it's crate relative.
[14:14:03] <nmatsakis> pauls: things build but when I try to *use* a macro, I get just...nothing
[14:14:07] <nmatsakis> pauls: any tips for debugging macros?
[14:14:30] <doomlord_> whilst i thought i understood it .. if i move something from one place to another i often seem to break it :)
[14:14:35] <pauls> nmatsakis: so `--pretty expanded` shows that the macro expanded into nothing?
[14:15:02] <doomlord_> what does it mean if you write "pub mod foo;"
[14:15:13] <cmr> doomlord_: it means other crates using yours can access the module
[14:15:23] <cmr> doomlord_: and, due to bugs in the implementation, other modules in your own crate
[14:15:29] *** Joins: jorendorff (jorendorff@moz-2F32ACA3.hsd1.tn.comcast.net)
[14:15:51] <cmr> but modules in your own crate should be able to see private items in parent modules, it's just a bug right now
[14:15:56] <nmatsakis> pauls: right. 
[14:16:07] <nmatsakis> pauls: but no errors, and if I add gibborish into th emacro use, I do get parse errors,
[14:16:15] <nmatsakis> pauls: so it is *registering* somehow
[14:16:21] <doomlord_> ok - so if i want a 'main' to bring in many sub-modules that use eachother... i *should* be using pub mod ?
[14:16:31] <nmatsakis> pauls: one thing, I didn't have to add any code to convert a tt_outer_attr etc into tokens,
[14:16:40] <engla> nmatsakis: is it related to the existing bug that macros only expand (silently) to the first item
[14:16:43] <cmr> doomlord_: yes
[14:16:57] <nmatsakis> engla: shouldn't be but maybe? the expansion is => ($a $i)
[14:17:05] <nmatsakis> where $a is an attribute and $i is an item
[14:17:27] <nmatsakis> let me try putting them in a module
[14:17:28] <pauls> nmatsakis: I believe that there's something existing you can use; there should be a tt-comsuming lexer, as opposed to a string-reading one?
[14:18:38] <nmatsakis> pauls: ok? (I don't really know how macros work, in my mind they expand the variables into a token tree, then convert token tree to bytes and parse...?)
[14:19:06] <dbaupp> nmatsakis: parse straight from the token trees, aiui
[14:19:15] <nmatsakis> or that
[14:19:20] <nmatsakis> if I put macro_rules! test ( ($a:outer_attr, $i:item) => (mod foo { $a $i }); )
[14:19:42] <nmatsakis> I get parse errors in the expansion it seems ("expected item but found #[foo]")
[14:19:50] *** Quits: Kruppe (user@moz-E150F49F.cpe.net.cable.rogers.com) (Client exited)
[14:20:08] <pauls> nmatsakis: after `my_expr_macro!(...)` is expanded, it gets interpreted into an expression by streaming the tokens from the tt into the expr parser.
[14:20:26] <cmr> nmatsakis: Ahh attributes aren't part of the ast though, they are a property of the item
[14:20:46] <nmatsakis> cmr: yes, I know, but I'm confused why this should matter. I feel like macro expansion should yield the correct tokens,
[14:20:53] <nmatsakis> cmr: then we should parse this,
[14:20:59] <cmr> nmatsakis: macro expansion yields an AST, not a token tree
[14:21:04] <nmatsakis> cmr: but I guess I'm thinking of things in an overly simplistic way
[14:21:13] <cmr> aiui
[14:21:36] *** Quits: dbaupp (Thunderbir@moz-712A1135.lns20.syd6.internode.on.net) (Ping timeout)
[14:21:50] <pauls> nmatsakis: lemme look at the code for a moment...
[14:21:59] <nmatsakis> pauls: I can send you my diff too, it's quite small atm
[14:22:34] <nmatsakis> pauls: https://gist.github.com/nikomatsakis/6185022
[14:23:12] *** Joins: cdidd (cdidd@moz-CEC12794.broadband.corbina.ru)
[14:23:32] *** Joins: jaen (jaen@moz-53728AC6.play-internet.pl)
[14:25:04] *** Quits: cdidd (cdidd@moz-CEC12794.broadband.corbina.ru) (Ping timeout)
[14:25:06] *** Quits: ozten|afk (ozten@moz-DD3B00B4.hsd1.wa.comcast.net) (Quit: ozten|afk)
[14:28:06] *** Joins: hopplaboppla (Mibbit@moz-963D6814.redpill-linpro.com)
[14:29:03] <hopplaboppla> In the spec it says that main() must not take any arguments but then I found http://static.rust-lang.org/doc/std/files/getopts-rs.html How do i get hold av program arguments?
[14:29:19] <cmr> UGH why are those docs still around
[14:29:23] <bstrie> hopplaboppla: yikes, those docs are ancient
[14:29:30] <hopplaboppla> ahh  :)
[14:29:32] <cmr> hopplaboppla: those docs are over two years old
[14:29:34] <bstrie> hopplaboppla: use std::os::args() to get program arguments
[14:29:51] <hopplaboppla> ah ok thx
[14:29:53] <bstrie> just returns a vector of heap-allocated strings
[14:29:53] <jedestep> whoa
[14:29:55] <cmr> http://static.rust-lang.org/doc/std/index.html
[14:30:01] <jedestep> welcome to javadocs there lol
[14:30:10] <bstrie> why are we still hosting those
[14:30:27] <bstrie> someone hack into the website and erase them
[14:30:37] <cmr> I thought graydon deleted them last week
[14:30:55] <bstrie> looks like he didn't delete them vigorously enough
[14:31:32] <doomlord_> (ok panic over my code compiles again, it appears some symbols were ambiguous due to me using "use blah::*" too much..)
[14:32:05] <bstrie> yeah don't use the asterisk if you can help it :P think of it like SQL
[14:32:12] <pauls> nmatsakis: okay, I gotta take a break, but I think that the problem might be in macro_rules.rs, at the line:
[14:32:14] <bstrie> you never put the asterisk in production
[14:32:23] <pauls>                     return MRAny(|| p.parse_expr(),
[14:32:23] <pauls>                                   || p.parse_item(~[/* no attrs*/]),
[14:32:23] <pauls>                                   || p.parse_stmt(~[/* no attrs*/]));
[14:32:41] <jedestep> pauls: that line is the cause of all the problems in macros afaict
[14:32:42] <cmr> bstrie: but the compiler injects use std::prelude::* !
[14:32:42] <pauls> You may need to do something funky to parse attrs and then an item.
[14:33:05] <jedestep> that is also the root of the only one item bug
[14:33:05] <bstrie> cmr: well then I guess rust isn't ready for production then :)
[14:33:09] <doomlord_> i suppose an alternateive is to do ""use ..=" abreviations
[14:33:30] <cmr> doomlord_: glob imports are fine, they're just not really robustly implemented yet
[14:34:15] *** Joins: cdidd (cdidd@moz-567BBB7.broadband.corbina.ru)
[14:34:26] <jedestep> do glob imports from self still cause ICE?
[14:36:01] *** Quits: gits1225 (gits@89918D7.F2C235BD.425A25DC.IP) (Quit: )
[14:37:03] *** Joins: bytbox (s@moz-DC83764A.washdc.fios.verizon.net)
[14:38:43] *** Joins: tcr (tcr@moz-EE576D3C.hsd1.ma.comcast.net)
[14:41:32] <nmatsakis> pauls: I guess I thought we would substitute the values in the RHS before we parsed
[14:41:59] <darkf> i really hate rustc's test runner :\
[14:42:09] <pauls> nmatsakis: we do... I thought?
[14:42:14] <cmr> darkf: fix it!
[14:42:22] <pauls> Oh, actually maybe not.
[14:42:25] <cmr> TAP would be cool
[14:42:30] <nmatsakis> pauls: then I don't quite get why that line should be a problem. if I understand, that line is parsing the RHS?
[14:42:57] <darkf> cmr: I don't even know what it *does*! I just want to fix Windows issues but I can't even run the tests without it rebuilding stage{0,2} which takes like 30 minutes, and then failing on stuff!
[14:43:00] <pauls> The token tree parser takes a token tree, with `$interpolations`, and a table of what to fill in.
[14:43:03] <darkf> and lord knows I can't read the makefile :D
[14:43:29] <cmr> darkf: you can do make check-stage1-{std,extra,rustc}
[14:43:40] <darkf> hmmm
[14:43:55] *** Quits: tcr (tcr@moz-EE576D3C.hsd1.ma.comcast.net) (Connection reset by peer)
[14:44:09] *** Joins: tcr (tcr@moz-EE576D3C.hsd1.ma.comcast.net)
[14:44:13] <pauls> nmatsakis: that line is producing the parser (hence the lambdas) that will be used on the token tree produced by the macro to, in turn, produce the AST that the macro finally outputs.
[14:44:48] <doomlord_> darkf are you still enjoying rust
[14:44:56] <nmatsakis> pauls: that was sort of what I got out of it
[14:44:58] <darkf> doomlord_: yes I am :)
[14:45:34] <darkf> it's a bit like barbed wire at this point but I enjoy it (I am known to be a masochist)
[14:45:39] <nmatsakis> pauls: you're not a big fan of debug!, are you? :) when I run with RUST_LOG=syntax I see...not much.
[14:45:49] *** Quits: tcr (tcr@moz-EE576D3C.hsd1.ma.comcast.net) (Ping timeout)
[14:45:49] <pauls> nmatsakis: sorry ) :
[14:46:22] <pauls> I never knew what was interesting enough to debug.
[14:46:29] * nmatsakis shrugs
[14:46:31] <nmatsakis> it varies by taste I guess
[14:46:37] <nmatsakis> I just like to have RUST_LOG dump as much data as possible
[14:46:44] <nmatsakis> well, not *quite* :)
[14:46:49] <cmr> I usually only insert debug! into stuff when I need the information at some point
[14:46:49] <mark_edward_> doomlord_: hows progress on your jump to definition work?
[14:46:53] <nmatsakis> but I like to be able to trace a path through the code
[14:46:56] <cmr> and then... I just leave it there, in case it's useful again
[14:46:58] *** Quits: bytbox (s@moz-DC83764A.washdc.fios.verizon.net) (Ping timeout)
[14:47:03] <nmatsakis> yes, more or less what cmr says
[14:47:05] <doomlord_> mark_edward_, i've got a working html view of it
[14:47:21] <doomlord_> rust -> linked html source browser generator
[14:47:23] <mark_edward_> cool! do you have methods working?
[14:47:33] <nmatsakis> pauls: anyway, so, I have this intuition that what's happening is that we parse "mod x { $a $i }" and we treat the `$a` as an item-invocation of a macro or something
[14:47:35] <darkf> cmr: I am doing make check-stage1-std and it's still compile_and_link'ing stage0 stuff o_o
[14:47:42] <nmatsakis> pauls: so then we parse the tokens for $a as an item
[14:47:46] <nmatsakis> pauls: would that make any sense?
[14:47:50] <cmr> darkf: what changes have you made?
[14:47:55] <doomlord_> yes.   some bugs and ommisions though: i dont do anything useful outside the crate yet
[14:48:01] <pauls> nmatsakis: that sounds ... reasonable.
[14:48:06] <nmatsakis> pauls: it's not how macros work in my head but it seems to fit the error mesage I see
[14:48:34] *** Joins: lmandel (lmandel@moz-BECB9379.dsl.bell.ca)
[14:48:40] <pauls> nmatsakis: wait, what's the macro that you're currently testing?
[14:48:51] <mark_edward_> doomlord_: still that's really cool work!
[14:48:55] <cmr> darkf: you can do NO_REBUILD=1 if you just changed the tests, but otherwise yes, it *does* need to rebuild the compiler
[14:49:02] <pauls> If there's a mod wrapper, the code that I pointed out shouldn't be relevant to it at all.
[14:49:18] <cmr> doomlord_: if you figure out how to do useful cross-crate things let me know, I haven't figured out how to do anything useful in rustdoc yet
[14:49:22] <jedestep> nmatsakis: if that's what's happening, I think the issue would be in expand.rs
[14:49:38] <pauls> It should parse the mod as an item, and then kick off the responsibility for all its children to the Rust parser.
[14:49:46] <cmr> doomlord_: the best I can do is resolve the node id to a path, and output the path as a string
[14:49:53] <darkf> cmr: ah. yeah, that might be it. I just want to test the stdlib currently so I should do that :)
[14:49:54] <jedestep> it tries to expand macros in the mod first
[14:49:57] <nmatsakis> pauls: I added the mod wrapper later
[14:50:02] <nmatsakis> pauls: and I agree that th code is not relevant :)
[14:50:08] <jedestep> https://github.com/mozilla/rust/blob/master/src/libsyntax/ext/expand.rs#L269
[14:50:10] <nmatsakis> pauls: that's kind of what I was getting at
[14:50:18] <pauls> The problem is just about getting started, thanks to the weird design decision for `parse_item` to take a parameter.
[14:50:21] <doomlord_> cmr if you have the full path, thats a big help i think?
[14:50:30] <pauls> nmatsakis: okay, sorry I was behind.
[14:50:54] <doomlord_> i suppose i could manually create html for each crate... and find some way of linking via the full paths
[14:50:55] <cmr> doomlord_: I don't know. I guess, but you still need to run a limited form of resolve to figure out how to link to the definition I think? not really sure
[14:51:06] <nmatsakis> pauls: I'd rather not have the mod, though in my actual use case the attributes would be expanded inside of a fn
[14:51:34] <nmatsakis> pauls: in particular I was wondering if I could get a dump of each token that results when the RHS is parsed
[14:51:36] <pauls> nmatsakis: but it's not working, even with the `mod`?
[14:51:50] <nmatsakis> pauls: nope, without the mod I get silently nothing, with the mod I get parse errors
[14:51:50] <doomlord_> i suppose there must be some logical way the nodeId's are brought in... 
[14:52:03] *** Joins: panzi (chatzilla@moz-B475CCDD.adsl.highway.telekom.at)
[14:52:14] <pauls> nmatsakis: What do the parse errors look like?
[14:52:22] <cmr> doomlord_: I think there is a lot of information in the crate metadata but I have no idea how to use it or what is there
[14:52:23] <pauls> (I gotta take another keyboard break)
[14:52:26] <nmatsakis> pauls: "expected item but found #[foo]"
[14:52:36] <doomlord_> actually those 'def_ids { _:cratenum, _:nodeid)' might do it perhpas
[14:52:42] *** Joins: BizarreCake (BizarreCak@moz-361FE9B2.dynamic.barak-online.net)
[14:52:46] <panzi> what does "cannot move out of dereference of & pointer" mean and why do I get it in this tiny function: https://gist.github.com/panzi/6185266 ?
[14:52:56] *** Quits: StarLight (StarLight@moz-B8E3BA82.dynamic.avangarddsl.ru) (Ping timeout)
[14:53:08] <doomlord_> cmr ..what would be the best way to make links to rustdoc output ..
[14:53:27] <cmr> panzi: dereferencing x would transfer ownership
[14:53:32] <doomlord_> in my generated html, i make #line_number anchors ...sourcefile.html#512  ..
[14:53:45] <cmr> panzi: ie, move it into the vector. you can't do that, you don't own `xs`
[14:54:07] <nmatsakis> pauls: maybe I just have to write a syntax ext
[14:54:34] <cmr> doomlord_: https://github.com/cmr/rustdoc_ng/blob/master/clean.rs#L1019 is how I handle external crate references right now
[14:55:07] <cmr> doomlord_: Not really sure, that'd be a question for Seldaek, he's doing the frontend stuff
[14:55:28] <cmr> doomlord_: but poke around http://seld.be/rustdoc/master/std/bool/fn.is_true.html. it seems it's url_prefix/path/path/{item type}.{item name}.html
[14:55:57] <panzi> cmr: but if you write the exact same function using uint instead of T it works. so shouldn't it be possible to write it somehow generic to do the same?
[14:56:09] <jedestep> nmatsakis: I think expand_mod_items in expand.rs tries to treat a mod's contents as items and is causing that error
[14:56:12] *** Joins: tchoma (tchoma@moz-E58E29CC.dsl.static.sonic.net)
[14:56:24] <cmr> panzi: nope. generics aren't implicitly copyable
[14:56:44] <cmr> panzi: (imo nothing should be implicitly copyable)
[14:56:47] <Seldaek> doomlord_: we can put anchors where it makes sense for sure, but not sure where it does yet
[14:56:52] *** Joins: StarLight (StarLight@moz-B8E3BA82.dynamic.avangarddsl.ru)
[14:57:07] <panzi> cmr: can I explicitly make them copyable?
[14:57:10] <cmr> panzi: no
[14:57:14] <cmr> panzi: well, kinda
[14:57:21] <cmr> panzi: T: Clone, then do x.clone() instead of *x
[14:57:34] <panzi> I see
[14:57:36] <nmatsakis> jedestep: that's plausible, but seems weird, because I feel like the values for $a and $i should have been substituted by then
[14:57:54] <nmatsakis> jedestep: though it may be that I am not understanding the flow of how macros work.
[14:58:06] <darkf> oh great the test binaries fail with runtime dll errors ("entry point not found", some iter extension method blah blah) :(
[14:58:20] <cmr> panzi: that's considered poor form, though
[14:58:25] *** Quits: wting (wting@moz-250C027.csres.utexas.edu) (Quit: Lost terminal)
[14:58:26] <jedestep> expand_mod_items is called whenever fold_mod would be called; I don't actually know when that is however
[14:58:41] <pauls> nmatsakis: Aha! I think the problem is that parse.rs needs a `maybe_whole!` case for attributes.
[14:58:50] <cmr> panzi: you should just take xs as ~[T], and move into the hashset
[14:59:16] <nmatsakis> pauls: oh? I didn't quite get what maybe_whole! did
[14:59:24] <cmr> pauls: the caller of functions should always decide whether it needs copies or not. the way it is now would require an extra copy in the case where you don't want to keep the old vector arround
[14:59:27] <pauls> `maybe_whole!` is how the parser deals with tokens containing a whole AST fragment...
[14:59:37] <pauls> cmr: huh?
[14:59:41] <hopplaboppla> How much out on a limb would I be if wrote a real app in rust? Is it expected to change a lot over the coming versions?
[14:59:41] <cmr> erm, @panzi
[14:59:43] <cmr> sorry
[14:59:45] *** Joins: Marc_ (chatzilla@moz-46C6E4A5.ipsat.francetelecom.net)
[14:59:45] *** Joins: wting (wting@moz-250C027.csres.utexas.edu)
[14:59:46] <nmatsakis> pauls: oh, now I ... kind of see
[14:59:59] <nmatsakis> pauls: so basically you get back a "token" that contains the tt_attribute
[15:00:04] <cmr> hopplaboppla: you'll be doing a lot of work writing and binding libraries  :)
[15:00:05] <pauls> ...which are the payload of `$interpolations`.
[15:00:06] <nmatsakis> pauls: and maybe_whole matches that
[15:00:09] <pauls> nmatsakis: yes.
[15:00:15] <nmatsakis> pauls: this makes a lot of sense, also explains the error message,
[15:00:16] <cmr> hopplaboppla: but it's more-or-less stablish, language wise.
[15:00:27] <hopplaboppla> libraries? for like databases and what not?
[15:00:31] <nmatsakis> pauls: I was wondering why the error message cited `#[foo]` and not `#`
[15:00:31] *** Quits: olsonjeffery (pf@moz-9E9CF15C.members.linode.com) (Quit: leaving)
[15:00:31] <cmr> hopplaboppla: yup
[15:00:41] <hopplaboppla> ah ok i see
[15:00:44] <cmr> hopplaboppla: although we have sqlite bindings, and now a mongodb driver
[15:00:45] <nmatsakis> pauls: I guess this is to avoid the need to serialize and re-parse the already parsed things
[15:00:52] *** Quits: Marc_ (chatzilla@moz-46C6E4A5.ipsat.francetelecom.net) (Quit: ChatZilla 0.9.90.1 [Firefox 21.0/20130511120803])
[15:00:53] <jedestep> hopplaboppla: need a database driver?
[15:00:59] <hopplaboppla> i did see the mongodb driver, cool
[15:01:04] <pauls> nmatsakis: there's a general approach, which involves pretty-printing something and then re-parsing it, which we don't do because of *horrible* *performance* *implications*
[15:01:10] <pauls> nmatsakis: exactly
[15:01:14] <jedestep> hopplaboppla: if you have feedback on that please let me know :)
[15:01:44] <hopplaboppla> ill give it a go but I have so much to learn language wise first :)
[15:01:44] <darkf> cmr: any idea why it wouldn't link _ZN4test14__extensions__10meth_288384iter17_a<random string here> into the test binary?
[15:01:45] *** Joins: dherman (dherman@moz-6CA476B1.hsd1.ca.comcast.net)
[15:01:45] *** ChanServ sets mode: +o dherman
[15:02:02] <darkf> (stdtest in this case, it happened before with `json` in i think the extra tests)
[15:02:02] <nmatsakis> pauls: cool thanks, let me try that out
[15:02:06] <cmr> darkf: is there a #[cfg(not(win32))] somewhere?
[15:02:10] <jedestep> hopplaboppla: one thing to note is that the driver is only on 0.7 right now
[15:02:11] <hopplaboppla> I have a Go app that is real and talks to mongodb that is feasible to try to port
[15:02:12] *** Quits: cdidd (cdidd@moz-567BBB7.broadband.corbina.ru) (Ping timeout)
[15:02:12] <cmr> s/win32/windows
[15:02:22] *** Joins: azita (Azita@moz-7E81A256.static.qsc.de)
[15:02:24] <jedestep> oh cool :)
[15:02:25] <darkf> lemme see.
[15:02:37] <nmatsakis> pauls: now if only I can understand how macro visibility works
[15:02:38] <hopplaboppla> thats what I use atm as well is 0.8 ready soon?
[15:02:51] <darkf> cmr: wouldn't the build fail if it didn't have a definition for that and it wasn't extern'd though?
[15:02:56] <jedestep> I think 0.8 still has a little while
[15:03:02] <cmr> darkf: dunno
[15:03:07] <hopplaboppla> ok then :)
[15:03:19] <cmr> hopplaboppla: 0.8 is ~2 months out, but it's more stable than 0.7
[15:03:24] <cmr> (0.8pre that is)
[15:03:33] <cmr> releases are just time-based snapshots
[15:03:50] <hopplaboppla> aha I didnt know that
[15:03:52] <darkf> speaking of releases, how many minor releases are we having until 1.0? "until it's done"?
[15:04:00] <cmr> darkf: yes
[15:04:04] <darkf> great
[15:05:01] *** lmandel is now known as lmandel-pto
[15:05:26] <bstrie> hopplaboppla: be warned, we don't have any commitment to backwards-compatibility. in fact we have a commitment to backwards-incompatibility. we guarantee that your code will break.
[15:05:29] <nmatsakis> pauls: also, horray for non-hygenic, have to get all the imports just so :)
[15:05:31] *** Joins: olsonjeffery (pf@B8927AE1.CFEFA148.239A1A9E.IP)
[15:05:37] * nmatsakis can't wait for that patch to land
[15:05:45] <nmatsakis> pauls: still, if this works, that's pretty nifty
[15:05:59] <nmatsakis> we don't have a way to export macros from a crate yet, do we? that kind of stinks
[15:06:09] <nmatsakis> but I guess I can put it in the magic prologue that gets inserted everywhere
[15:06:51] <hopplaboppla> bstrie: great! Better now than later!
[15:07:22] <cmr> hopplaboppla: I log breaking changes in http://cmr.github.io/blog/categories/this-week-in-rust/, so it's relatively easy to keep up
[15:07:36] <jedestep> what is *preventing* macros from being exported exactly?
[15:07:39] <hopplaboppla> nice
[15:07:41] *** Joins: orshem (orshem@C5E06B1E.A5B6B765.E3D28531.IP)
[15:07:54] <jedestep> this is a feature I have been desperately wanting -_-
[15:09:15] *** Quits: huseby (huseby@moz-4E8C421A.husebyhome.com) (Quit: Leaving)
[15:09:56] *** Joins: tcr (tcr@D26BCFC9.C2203064.EDCE493E.IP)
[15:12:02] <pauls> nmatsakis: I don't remember the state of macro export; you'll have to ask jclements, I suppose.
[15:12:36] *** Joins: cdidd (cdidd@moz-D66E14A.broadband.corbina.ru)
[15:13:03] <pauls> jedestep: it requires writing another resolver (fortunately not as complicated a resolver as the one for values, but still non-trivial)
[15:13:22] <jedestep> hmm
[15:15:52] <nmatsakis> pauls: liberally throwing about #[macro_escape]; seems to have helped
[15:16:03] <pauls> nmatsakis: hooray!
[15:18:49] <hopplaboppla> stuff like string concatenation how is it done idiomatically? are there buffers or just +?
[15:19:00] *** Joins: maikklein (maik@moz-5AED6CF8.dip0.t-ipconnect.de)
[15:19:43] <cmr> hopplaboppla: let s = str::with_capacity(expected_length) and then push_str(), is the best way atm afaik
[15:19:50] <cmr> s.push_str() that is
[15:20:18] <Ms2ger> [...].connect()?
[15:20:22] <hopplaboppla> ah thx
[15:20:40] <hopplaboppla> i have to learn to navigate the docs 
[15:21:05] <cmr> the docs kinda suck a lot
[15:21:22] <cmr> the new rustdoc is almost usable: http://seld.be/rustdoc/master/index.html
[15:21:30] <cmr> all it's missing is implementations right now
[15:22:50] <hopplaboppla> And perhaps a whiespace or two? Allocatesanewstringwiththespecifiedcapacity.Thestringreturnedis theemptystring,buthascapacityformuchmore.
[15:23:00] <cmr> well, that's just bugs :p
[15:23:04] <hopplaboppla> :D
[15:23:26] <jdm> hee hee
[15:23:27] <cmr> fixing that is third on my list of things-to-do today
[15:23:33] <hopplaboppla> looks nice though is it how it will look later? format wise?
[15:23:35] <doomlord_> http://dobkeratops.github.io/rftest/rustfind.html <<< WIP 
[15:23:43] <smvv> cmr: although correctly sorted, it seems a bit weird that extra is listed before std
[15:23:44] <jedestep> cmr: what is causing that whitespace bug
[15:23:47] <cmr> hopplaboppla: yes, this is more-or-less how it will look
[15:23:59] <darkf> the font looks a lot like Impact :p
[15:24:01] *** Joins: ozten (ozten@moz-10AD164.tukw.qwest.net)
[15:24:13] <cmr> jedestep: I don't really know, but it can't be fixed until I get the AST folder working properly
[15:24:20] *** Quits: erickt (etryzelaar@8C9ECD8F.3A598286.F12515B4.IP) (Ping timeout)
[15:24:26] *** Quits: jaen (jaen@moz-53728AC6.play-internet.pl) (Ping timeout)
[15:24:27] *** Quits: olsonjeffery (pf@B8927AE1.CFEFA148.239A1A9E.IP) (Ping timeout)
[15:24:27] <cmr> jedestep: I'm pretty sure it's broken comment stripping
[15:24:33] <jedestep> that's what I was thinking
[15:24:39] *** Joins: olsonjeffery (pf@B8927AE1.CFEFA148.239A1A9E.IP)
[15:24:40] <hopplaboppla> aha so generated from comments?
[15:24:42] <cmr> but that was really ad-hoc, it will be a plugin when reimplemented
[15:24:44] <cmr> hopplaboppla: yup
[15:24:46] *** Quits: ozten (ozten@moz-10AD164.tukw.qwest.net) (Quit: ozten)
[15:24:49] <hopplaboppla> nice
[15:27:19] *** Joins: boredomist (user@moz-63CF9F31.res-cmts.sesp.ptd.net)
[15:29:07] <smvv> doomlord_: i know it is WIP, but is it possible to add "border-bottom: 1px dotted #777;" to a:link {} in the css? currently it is really hard to see what's a link (you have to hover a link to see if it's a link)
[15:29:37] <doomlord_> any suggestions welcome :)
[15:29:38] *** Quits: olsonjeffery (pf@B8927AE1.CFEFA148.239A1A9E.IP) (Ping timeout)
[15:29:41] <cmr> doomlord_: this is really cool
[15:30:00] *** Joins: olsonjeffery (pf@B8927AE1.CFEFA148.239A1A9E.IP)
[15:30:02] <doomlord_> disclaimer, i have minimal experience with html :)
[15:30:38] *** Joins: alisdair (textual@moz-FBF4138A.vc.shawcable.net)
[15:30:58] *** Parts: pauls (pauls@moz-BFEF1F22.ccs.neu.edu) (Ignore me!!)
[15:31:35] <doomlord_> smvv ..  let me think about that - when its working right *most things* should have some sort of click behaviour, i'd like to make it annotate types for subexpressions..
[15:32:10] *** Joins: pauls (pauls@moz-BFEF1F22.ccs.neu.edu)
[15:32:38] <doomlord_> subexpresions / locals... dealing with the issue that type inference leaves one not always knowing the type of something..
[15:33:24] <maikklein> doomlord, pretty cool
[15:33:31] * ChrisMorgan has succumbed to pressure: https://github.com/chris-morgan/rust-http
[15:33:34] <darkf> that would be nice in an editor
[15:34:34] <jdm> woot
[15:35:10] <mark_edward_> super nice. doomlord_  your project is sicknasty! do you thik it'd be possible to have a little thingy with the doc comments appear on hover, farther down the road?
[15:35:17] <darkf> ChrisMorgan: interesting
[15:36:22] <doomlord_> doc comments of symbols  ? ... sure i'd like that, function argument names, types ...
[15:36:52] <cmr> ChrisMorgan: Have you considered moving some stuff into a separate HTTP lib so fastcgi could be supported?
[15:37:01] <panzi> is there a function that counts the occurances of a certain value in an vec?
[15:37:25] <ChrisMorgan> cmr: I have not. Matter of fact, that's not compatible with my intention with it, but I'm open to being reasoned with.
[15:37:33] <cmr> panzi: one just landed the other day! https://github.com/mozilla/rust/pull/8320
[15:38:00] <ChrisMorgan> What benefits would a server get from using FastCGI instead of serving directly, itself?
[15:38:20] <engla> panzi: if it's just one particular value, .count() on an iterator will do it
[15:38:20] <cmr> ChrisMorgan: I was more thinking for frameworks than server
[15:38:25] <cmr> they need to handle headers and stuff too
[15:38:51] *** Joins: jeaye (Jeaye@moz-FD505E54.hsd1.ca.comcast.net)
[15:39:08] <ChrisMorgan> cmr: still: why FastCGI rather than a Rust socket-level server?
[15:39:09] <engla> rusti: range(0,10).count(|x| x % 3 == 0)
[15:39:10] -rusti- 4
[15:39:17] <cmr> ChrisMorgan: so it can be put behind nginx and stuff
[15:39:25] <ChrisMorgan> cmr: reverse proxy.
[15:39:34] <jdm> panzi: you can also use filter and len
[15:39:37] <cmr> ChrisMorgan: why bother when you can use fastcgi?
[15:39:50] <jdm> that gives you an iterator, so it doesn't cause extra memory usage
[15:39:52] <ChrisMorgan> Probably not fast enough. Definitely not simple enough.
[15:40:00] <jdm> er, len probably wouldn't work
[15:40:05] <ChrisMorgan> My goal is to have it that you can deploy *one* thing.
[15:40:05] <cmr> it supports the concept of multiple workers and multiplexing
[15:40:27] <ChrisMorgan> (It'll certainly be quite some time before I would recommend anything but reverse proxying—the server would need to be hardened to outside traffic.)
[15:40:53] <cmr> (yes, I don't really trust your implementation either ;)
[15:41:21] <ChrisMorgan> Take a Python example: let's put in Apache, mod_wsgi and Python. Or nginx, uWSGI and Python. That's (normally) two things we have to install and configure. Why not make it just one?
[15:42:08] <ChrisMorgan> In the long run, I think not being tied to a server like nginx is better, so I'm content to use the likes of nginx as a shield with reverse proxying for the moment.
[15:43:00] <cmr> Dunno, I've always used nginx + fastcgi. Maybe it's unideal
[15:43:02] <ChrisMorgan> My convictions in this are not firm, nor proof against sound argument—but that's my current belief on the matter.
[15:43:13] <cmr> But I don't really see how you can contest that a reusable http library wouldn't be useful :p
[15:43:13] *** Joins: infynyxx (infynyxx@moz-E95B370B.nyc.res.rr.com)
[15:43:14] <ChrisMorgan> You should be able to get better performance without it.
[15:43:39] <ChrisMorgan> cmr: if it slows it down? Makes it less efficient? Code maintenance burden?
[15:43:57] * ChrisMorgan doesn't know what would go into making a FastCGI server, anyway.
[15:44:07] <ChrisMorgan> Meaning I should probably investigate it so as to be informed.
[15:44:12] <ChrisMorgan> s/informed/Informed/
[15:44:25] <engla> cmr: so, some questions of order. lexicographical ordering of sequences, we must be able to use both  .lt and .le when comparing for the .le method?  https://gist.github.com/anonymous/ad73637e20be8976e70a
[15:44:59] <ChrisMorgan> There are various things in HTTP which are probably more generally useful—e.g. there's a lot of shared ground with MIME.
[15:45:43] <ChrisMorgan> Anyway, I should have been in bed well over an hour ago, so I'm heading off to bed now. Appropriate contributions are quite welcome with rust-http should anyone desire so to do.
[15:45:45] <cmr> ChrisMorgan: Well I don't mean for fastcgi specifically, also for *anything* that wants to handle HTTP, be it other servers, or clients, etc.
[15:45:52] <cmr> Also your one thing doesn't do load balancing
[15:46:06] <cmr> engla: sec, eating
[15:46:58] <engla> it's ok
[15:47:15] <ChrisMorgan> cmr: not conveniently, at present, but I am going to be having all the origin server stuff at a second level, which could have siblings for proxying, load balancing, etc. It will be a very general server.
[15:47:22] *** Joins: bytbox (s@moz-DC83764A.washdc.fios.verizon.net)
[15:47:56] <ChrisMorgan> Well, for now, g'night.
[15:54:37] <cmr> engla: https://gist.github.com/anonymous/ad73637e20be8976e70a#file-gistfile1-rs-L10 I'm not sure that's correct
[15:54:50] <cmr> both of those conditions can be false
[15:55:07] *** Quits: alisdair (textual@moz-FBF4138A.vc.shawcable.net) (Quit: My MacBook Pro has gone to sleep. ZZZzzz…)
[15:55:55] *** Quits: ChrisMorgan (chris@moz-6AC741CA.static.tpgi.com.au) (Ping timeout)
[15:55:55] *** Joins: ssalbiz (ssalbiz@moz-21D6B3DE.csclub.uwaterloo.ca)
[15:56:51] <cmr> I think we need a dummy type that implements Ord's worst-case behavior
[15:57:06] <cmr> ie, some thnigs are unordered, some things are ordered in a different way than you'd expect from a total order
[15:57:44] *** Joins: bent (chatzilla@moz-BE33DA21.fw1.sfo1.mozilla.net)
[15:57:56] *** Joins: alisdair (textual@moz-FBF4138A.vc.shawcable.net)
[15:58:14] *** Joins: tiffany (kawaii@moz-EB8B0C08.dhcp.embarqhsd.net)
[16:00:42] *** Quits: FrozenCow (FrozenCow@moz-B2DF4929.chello.nl) (Ping timeout)
[16:00:58] *** Joins: ozten (ozten@19BD73A1.5D8BCA3A.A0C1B52F.IP)
[16:03:00] *** Joins: mihneadb (mihneadb@E48845AB.3A9F9BD4.4C2245EF.IP)
[16:04:09] *** Joins: Sergio965 (sergiobz@moz-8D70E596.wireless.csail.mit.edu)
[16:06:29] <panzi> is there a shorter way to write: let mut i = 0; while i < n { f(i); i+= 1; }       like: for i in 0...n { f(i); }
[16:07:09] <cmr> rusti: range(0, 10).transform(|x| printf!(x));
[16:07:10] -rusti- ()
[16:07:21] <cmr> hm
[16:07:26] <bstrie> panzi: for i in range(0, n) { ... } ?
[16:07:38] <bstrie> panzi: assuming you're on trunk
[16:07:48] <cmr> rusti: range(0, 10).transform(|x| printf!("%d", x));
[16:07:49] <Sergio965> rusti: for i in range(0, 3) { println(i); }
[16:07:50] -rusti- ()
[16:07:50] -rusti- <anon>:5:40: 5:41 error: mismatched types: expected `&str` but found `int` (expected &str but found int)
[16:07:50] -rusti- <anon>:5          for i in range(0, 3) { println(i); }
[16:07:50] -rusti-                                                  ^
[16:07:50] -rusti- error: aborting due to previous error
[16:07:50] -rusti- application terminated with error code 101
[16:08:13] <cmr> rusti: range(0, 10).transform(|x| printfln!("%d", x));
[16:08:14] -rusti- ()
[16:08:14] <Sergio965> rusti: for i in range(0, 3) { println(i.to_str()); }
[16:08:15] -rusti- 0
[16:08:15] -rusti- 1
[16:08:15] -rusti- 2
[16:08:16] -rusti- ()
[16:08:25] <cmr> OH
[16:08:30] <cmr> rusti: range(0, 10).transform(|x| printfln!("%d", x)).collect();
[16:08:32] -rusti- <anon>:5:9: 5:66 error: cannot determine a type for this bounded type parameter: unconstrained type
[16:08:32] -rusti- <anon>:5          range(0, 10).transform(|x| printfln!("%d", x)).collect();
[16:08:32] -rusti-                   ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
[16:08:32] -rusti- application terminated with error code 101
[16:08:48] <bstrie> cmr: what are you trying to do?
[16:08:55] <cmr> bstrie: just exhaust the iterator
[16:09:03] <cmr> ie, run next() until it returns None
[16:09:14] <cmr> to make the transform do its thing
[16:09:38] <bstrie> how terrible :P
[16:09:52] <bstrie> just use a for loop!
[16:09:54] <cmr> says you!
[16:10:09] <cmr> rusti: range(0, 10).advance(|x| printf!("%d ", x))
[16:10:10] -rusti- <anon>:5:34: 5:52 error: mismatched types: expected `bool` but found `()` (expected bool but found ())
[16:10:10] -rusti- <anon>:5          range(0, 10).advance(|x| printf!("%d ", x))
[16:10:10] -rusti-                                            ^~~~~~~~~~~~~~~~~~
[16:10:10] -rusti- error: aborting due to previous error
[16:10:10] -rusti- application terminated with error code 101
[16:10:26] <bstrie> do not rely on advance
[16:10:28] <cmr> ah right internal iterator ptocol
[16:10:30] <cmr> *protocol
[16:10:43] <bstrie> ptocol is what the keyword would be if rust had protocols
[16:10:52] <cmr> ptl more likely
[16:11:50] <Sergio965> Protocols are neat.
[16:12:45] <darkf> ptcl
[16:13:11] <bstrie> how about "ooo"
[16:13:15] <Sergio965> But I think type classes supersede them.
[16:13:20] <bstrie> it's the opposite of taking out all the vowels
[16:13:23] *** Quits: devinus (devinus@moz-B4AF84BC.ptr.us.xo.net) (Quit: Computer has gone to sleep.)
[16:13:41] *** Quits: sigma (sigma@moz-BE11A887.range109-151.btcentralplus.com) (Ping timeout)
[16:13:42] *** Joins: sigma (sigma@moz-5022C87F.range109-151.btcentralplus.com)
[16:14:53] <zxcdw> much easier to say out loud
[16:15:19] <Sergio965> "OOO!"
[16:15:21] <Sergio965> I can confirm.
[16:15:43] *** Joins: graydon (graydon@moz-F14EE0DB.cable.teksavvy.com)
[16:15:43] *** ChanServ sets mode: +qo graydon graydon
[16:16:03] *** Quits: pnkfelix (pnkfelix@87C1F78E.1DE10CA8.D8E68FF6.IP) (Ping timeout)
[16:16:03] <engla> cmr: the goal is just to make 'a' lexical comparison. so far I have only made sure that a single-element sequence compares the same as a single element by itself. only tested floats with nans though
[16:16:33] <engla> cmr: there is no implication of total order, it's just using lt
[16:17:11] <toddaaro> graydon: http://pastebin.mozilla.org/2810181 what do I do about this?
[16:17:44] <cmr> graydon: Can you nuke http://static.rust-lang.org/doc/std/files/getopts-rs.html ?
[16:17:50] <engla> cmr: ok it's probably fine to remove that reverse comparison
[16:17:53] <cmr> All of the docs, not just that one
[16:18:00] <graydon> cmr: why?
[16:18:20] <cmr> graydon: because they're ancient and people come in here trying to use them,
[16:18:23] <engla> cmr: hm sorry, no it isn't
[16:18:25] <Sergio965> So guys, I'm still having trouble accessing macros from a different module in the same crate.
[16:18:27] <cmr> well, all the docs in that folder
[16:18:31] <cmr> not *all* the docs :p
[16:18:33] <Sergio965> I can access the macros from some modules but not all.
[16:18:35] <graydon> toddaaro: paste the full code?
[16:18:39] <graydon> cmr: which folder?
[16:18:45] <cmr> graydon: doc/std/files
[16:18:48] <graydon> ok
[16:19:04] <toddaaro> graydon: http://pastebin.mozilla.org/2810190
[16:20:02] <Sergio965> So I have a macro defined in ::macros, and I'm trying to use it in ::mod1::mod2::mod3. I can use it fine in ::mod1prime, though.
[16:20:33] <graydon> toddaaro: first, rename 'b' so it doesn't collide with the 'b' you're trying to do b.iter on
[16:20:46] <toddaaro> graydon: ? why would I do that
[16:20:52] <Sergio965> Actually, the macro is defined in ::moda::modb, and I can use it in ::modb, and ::.
[16:20:52] <toddaaro> graydon: there is only one b
[16:21:02] <Sergio965> ::moda::modb*
[16:21:07] <graydon> toddaaro: oh. weird. um.
[16:21:08] <toddaaro> graydon: just the standard "shadow with cell" game
[16:21:16] <graydon> I don't understand that game
[16:21:20] *** Quits: jedestep (jedestep@34641662.FB4DE631.66C78B76.IP) (Ping timeout)
[16:21:31] <graydon> I'm pretty sure you can't move the & bench harness into a task though
[16:21:42] <graydon> since the task might outlive the bench harness
[16:21:48] <graydon> and thus point to garbage
[16:21:56] <toddaaro> you need a cell to pass a lot of stuff into closures, so you do let x = Cell::new(x), and inside the closure, let x = x.take();
[16:22:04] *** Quits: tcr (tcr@D26BCFC9.C2203064.EDCE493E.IP) (Client exited)
[16:22:04] <toddaaro> we do it hundreds of times in the runtime
[16:22:23] <toddaaro> the best is the frequent let x = Cell::new(x.take());
[16:22:40] <graydon> toddaaro: presumably owned stuff though, right? not &-ptrs
[16:22:53] <toddaaro> yea, usually not &-ptrs
[16:22:58] *** Quits: tchoma (tchoma@moz-E58E29CC.dsl.static.sonic.net) (Quit: tchoma)
[16:23:17] <toddaaro> what should I do about this then? at the scale #[bench] operates runtime init will dominate all the numbers and they will be meaningless
[16:23:21] *** Joins: jaen (jaen@moz-174CF316.play-internet.pl)
[16:23:26] *** Joins: pnkfelix (pnkfelix@87C1F78E.1DE10CA8.D8E68FF6.IP)
[16:23:34] *** Joins: devinus (devinus@moz-B4AF84BC.ptr.us.xo.net)
[16:23:46] <toddaaro> I guess post oldrt the runtime init will leave all these tests
[16:24:06] <graydon> init?
[16:24:17] <toddaaro> the do run_in_newsched_task stuff
[16:24:26] <graydon> why is it running in a newshced task?
[16:24:29] <graydon> sched
[16:24:33] <graydon> you're just measuring spawn rate
[16:24:33] <toddaaro> that is initializing the new runtime for the first time
[16:24:42] <toddaaro> so spawn is undefined outside that
[16:24:58] <graydon> how is the benchmark running at all?
[16:25:10] <toddaaro> in what sense?
[16:25:11] <graydon> isn't it running in a scheduler?
[16:25:21] <nmatsakis> pauls: so...maybe_whole! seems wrong
[16:25:26] <toddaaro> yes - the one started by run_in_newsched_task
[16:25:31] <nmatsakis> pauls: in particular, it calls "clone()", but doesn't renumber the result,
[16:25:32] <pauls> nmatsakis: how so?
[16:25:39] <nmatsakis> pauls: so if you have the same item twice, you get the same ids
[16:25:39] <graydon> are you telling me I can't call spawn unless I do run_in_newsched_task outside it?
[16:25:53] <toddaaro> the name is kinda bad, it initializes a scheduler and then runs the closure in a new task in that sched
[16:26:02] <nmatsakis> pauls: also, maybe_whole! for an item doesn't work because the attributes are passed in from the outside, so you get the item without the additional attrs
[16:26:17] <toddaaro> for the runtime tests we can't assume the runtime is started by main, so yes, in this phase you can't use spawn unless you start the runtime yourself
[16:26:17] <nmatsakis> pauls: though the latter problem I can fix easily enough I guess
[16:26:26] <engla> cmr: we should use Eq + Ord for lexical ordering
[16:26:32] <toddaaro> in the future I think we get to make that assumption, but not now
[16:26:39] <toddaaro> (that main starts the new runtime)
[16:26:42] *** Quits: sawrubh (uid6719@moz-5F4AA75A.irccloud.com) (Ping timeout)
[16:26:49] *** Joins: vodik (simon@moz-1DDE8FF6.dsl.bell.ca)
[16:26:52] <cmr> engla: not sure, ask a mathematician
[16:26:53] *** Joins: sawrubh (uid6719@moz-5F4AA75A.irccloud.com)
[16:26:54] <cmr> Ms2ger: oi!
[16:27:15] <Ms2ger> cmr, looking for a mathematician?
[16:27:18] <pauls> nmatsakis: I think that `.clone()` was added after my time.
[16:27:24] <Ms2ger> cmr, or did I troll you? :)
[16:27:25] <toddaaro> well, maybe not, the newrt tests aren't compatible with the old rt
[16:27:26] <cmr> Ms2ger: yeah, figure out lexicographic ordering for engla
[16:27:31] <toddaaro> it is kind of a mess
[16:28:08] <toddaaro> what we really need is #[cfg(newrt)] and #[cfg(oldrt)]
[16:28:09] <Ms2ger> engla, what's the question?
[16:28:18] <graydon> toddaaro: ... I am a little boggled by this. #[bench] runs inside task::run_test_console
[16:28:31] <graydon> toddaaro: as far as I know there's very much already a runtime + scheduler running at that point
[16:28:38] <pauls> nmatsakis: We'd need to check the transcriber, to see if it's not already changing ids when it duplicates something?
[16:28:41] <toddaaro> well, an oldrt runtime
[16:28:45] <graydon> toddaaro: there is no oldrt
[16:28:50] <graydon> it was turned off last night
[16:29:17] <toddaaro> I haven't pulled that yet, I didn't see that it had landed
[16:29:20] *** Quits: pnkfelix (pnkfelix@87C1F78E.1DE10CA8.D8E68FF6.IP) (Quit: Leaving.)
[16:29:25] <graydon> it did
[16:29:29] <toddaaro> I should get that
[16:29:44] <cmr> graydon: speaking of can you turn bors back on?
[16:29:49] <toddaaro> so even in that case, the tests are a bit of a mess, as if oldrt mode is on they will crash as they are only defined in newrt context
[16:30:05] <engla> Ms2ger: how to lexically order sequences using Ord
[16:30:11] <toddaaro> I'm not sure what brson did about that, maybe just leave them as is
[16:30:14] <toddaaro> so we nest runtimes
[16:30:21] <toddaaro> guarenteeing we get the right one
[16:30:21] <nmatsakis> pauls: ".clone()" is just the new `copy`
[16:30:31] <toddaaro> that was the original system, run newrt inside oldrt for testing
[16:30:48] *** Quits: azita (Azita@moz-7E81A256.static.qsc.de) (Quit: azita)
[16:31:05] *** Quits: devinus (devinus@moz-B4AF84BC.ptr.us.xo.net) (Quit: Computer has gone to sleep.)
[16:31:07] <engla> Ms2ger: I don't think a mathematician will be happy about comparing NaN though
[16:31:10] *** Joins: pnkfelix (pnkfelix@87C1F78E.1DE10CA8.D8E68FF6.IP)
[16:31:27] <Ms2ger> engla, eww, NaN :)
[16:31:49] <graydon> toddaaro: yeah. I think probably "switching runtimes in the middle of a benchmark run" is .. non-ideal.
[16:32:07] <engla> tuples and &[T] today only implement <  and derive the results for >, >=, <= from that. This makes  a single-element collection compare differently than that element by itself
[16:32:18] <engla> I'm attacking this slowly
[16:32:32] <Ms2ger> engla, so does Ord give you a poset in the mathematical sense?
[16:32:35] <graydon> toddaaro: you could potentially run the task-doing-the-spawning in a secondary task and communicate with it during the benchmark calibration loop by passing a message over a channel
[16:32:54] <graydon> toddaaro: triage time, anyways
[16:33:00] <graydon> #rust-triage for anyone who wants to follow
[16:33:07] <toddaaro> graydon: can I just transmute the pointer? the return of run_in_newsched guarentees that all the tasks are done
[16:33:58] <engla> Ms2ger: Ord doesn't have a value for `unorderable` so every comparison is either true or false
[16:34:06] <graydon> toddaaro: I'd rather you didn't. it might work but it's plainly breaking memory safety to do so.
[16:34:13] <engla> rusti: let nan = 0.0/0.0; (nan <= nan, &[nan] <= &[nan])
[16:34:14] -rusti- (false, true)
[16:34:28] <graydon> toddaaro: update to today's code so it's not an issue perhaps?
[16:34:35] <toddaaro> graydon: ok, I'll see what happens
[16:34:50] <toddaaro> graydon: I need to talk to brson when he gets in about how we want testing in general to work in the newrt world
[16:35:01] <graydon> sure
[16:35:10] *** Joins: tjc (tjc@moz-6EB4E533.dsl.tsoft.com)
[16:35:10] *** ChanServ sets mode: +o tjc
[16:35:24] <Ms2ger> engla, not a poset, then... Which makes a lexicographic order not very well defined :/
[16:35:46] <cmr> engla: Unorderable is all the operations returning false
[16:36:19] <engla> is this defined somewhere?
[16:37:17] <engla> I think we must just apply the normal definition..     [x:xs] < [y:ys] is   if x < y => true; if x == y => xs < ys
[16:37:45] <engla> and then implement it separately for each <, <=, >, >=
[16:38:29] *** Quits: BitPuffin (quassel@moz-8370D1B9.bredband.comhem.se) (Ping timeout)
[16:38:32] *** Quits: jdm (jdm@92FB48CA.8B5E9DF.9A8C35B4.IP) (Quit: Lost terminal)
[16:39:12] <engla> but that's only for < and >
[16:39:31] *** Joins: brson (brson@moz-BBE3ABD.mv.mozilla.com)
[16:39:32] *** ChanServ sets mode: +o brson
[16:39:35] <Sergio965> Raw pointers can't be indexed?
[16:39:53] *** Quits: alisdair (textual@moz-FBF4138A.vc.shawcable.net) (Quit: My MacBook Pro has gone to sleep. ZZZzzz…)
[16:40:00] <cmr> Sergio965: what would that operation mean?
[16:40:02] *** Quits: Blub\w (wry@7E3BB9D.71150E1A.237AE2BA.IP) (Quit: bb2m)
[16:40:08] <Sergio965> cmr: The same thing it does in c.
[16:40:11] <Sergio965> Pointer arithmetic.
[16:40:32] *** Joins: BitPuffin (quassel@moz-8370D1B9.bredband.comhem.se)
[16:41:08] *** Quits: maikklein (maik@moz-5AED6CF8.dip0.t-ipconnect.de) (Ping timeout)
[16:42:12] *** Joins: reyre_ (reyre@86C3727C.33EE9F8A.1139E686.IP)
[16:42:35] <toddaaro> brson: now that newrt is default, what is the plan for the runtime tests?
[16:43:39] <toddaaro> brson: was trying to do #bench for the trivial benches I have, but we can't seem to put the bench pointer inside run_in_newsched_task, so the bench has to wrap scheduler initialization, which on this timescale makes them meaningless
[16:44:45] <toddaaro> brson: so in the newrt-is-default world, what is the model? can I just ditch the run_in_* stuff for the tests?
[16:45:00] <Ms2ger> engla, well, the typical definition starts "Take a poset..."
[16:45:43] <brson> toddaaro: I haven't considered this problem with #[bench]. do you have suggestions
[16:45:58] <brson> toddaaro: those initialization functions need to stay. they are sort of a sandbox around runtime instances
[16:46:03] <engla> 
[16:46:05] <engla> oops
[16:46:12] <brson> creating a new thread with their own local state
[16:46:19] <toddaaro> brson: "not have rt benches" is the only one I can think of, I also just realized that that the test runner parallelizes tests assuming sequential code, destroying rt bench meaning
[16:46:56] <Ms2ger> engla, so I'm not quite sure what properties you'd end up with :)
[16:47:31] *** Joins: brianm (brianm@moz-9B7D279E.dsl.static.sonic.net)
[16:47:34] <toddaaro> brson: so I think the answer is "new abstraction" for doing rt benches, as #[bench] also doesn't scale to the input values that would be ideal
[16:48:18] <engla> well the orderings in Ord are potentially crazy. we just need to map them to sequences in a way that preserves the crazy, without adding crazy things comparing more regular types
[16:48:42] <brson> is bors stuck?
[16:48:45] *** Joins: thomaslee (thomaslee@moz-6C3931E3.static.twtelecom.net)
[16:48:57] <cmr> brson: he's off
[16:49:06] <engla> Ms2ger, cmr, just pasting the code again. https://gist.github.com/anonymous/17b1b418713e676d5cea   This is   [x, ..xs] Rel [y, ..ys] => if x != y { x Rel y } else { xs Rel ys }
[16:49:14] <brson> toddaaro: the test runner doesn't run benchmarks in parallel
[16:49:34] <toddaaro> brson: ah, that is good then
[16:49:49] <toddaaro> the easy fix to just "make it work" is transmute the bench pointer and use it
[16:49:55] <toddaaro> should be safe
[16:49:56] <brson> why is bors off?
[16:49:58] *** Joins: leonvv (leonvv@moz-7D83A5F1.ip.telfort.nl)
[16:50:08] <Ms2ger> brson, newrt landing
[16:51:06] <Ms2ger> (I'd ask bz, but he just left for vacation)
[16:51:10] <brson> toddaaro: benchmarks can be done without creating new runtime instances
[16:51:23] *** Quits: reyre_ (reyre@86C3727C.33EE9F8A.1139E686.IP) (Client exited)
[16:51:53] <toddaaro> brson: is oldrt mode going to vanish? the benchmarks would crash in that mode
[16:52:17] *** Joins: alisdair (textual@moz-FBF4138A.vc.shawcable.net)
[16:52:30] <brson> toddaaro: yes
[16:52:32] *** Quits: fabiand (fabiand@moz-B59858CA.adsl.alicedsl.de) (Ping timeout)
[16:52:37] <toddaaro> brson: ok, I'll see if that works
[16:52:42] <toddaaro> brson: if so, super easy
[16:53:03] *** Quits: jaen (jaen@moz-174CF316.play-internet.pl) (Ping timeout)
[16:53:06] *** Joins: vk (chatzilla@3E9D68F2.B1163E0C.2A6693DD.IP)
[16:53:59] *** Quits: alisdair (textual@moz-FBF4138A.vc.shawcable.net) (Ping timeout)
[16:54:27] *** Joins: alisdair (textual@moz-FBF4138A.vc.shawcable.net)
[16:57:43] <cmr> rusti: std::rand::rng().next()
[16:57:44] -rusti- <anon>:5:9: 6:5 error: type `std::rand::IsaacRng` does not implement any method in scope named `next`
[16:57:44] -rusti- <anon>:5          std::rand::rng().next()
[16:57:44] -rusti- <anon>:6     };
[16:57:44] -rusti- error: aborting due to previous error
[16:57:44] -rusti- application terminated with error code 101
[16:58:10] *** Joins: jedestep (jedestep@34641662.FB4DE631.66C78B76.IP)
[16:59:11] *** Quits: davbo (dave@moz-3FFA637C.oucs.ox.ac.uk) (Client exited)
[16:59:13] *** Joins: mcpherrin (mimcpher@moz-345B5EBA.csclub.uwaterloo.ca)
[16:59:21] *** Joins: true_droid (true_droid@moz-123FD9B8.beck.volia.net)
[17:00:07] *** Joins: spider-mario (spidermari@moz-81131DB6.fbx.proxad.net)
[17:00:16] *** Quits: robertknight (robertknig@moz-54528EE0.wby.mendeley.com) (Client exited)
[17:00:30] *** Joins: robertknight (robertknig@moz-54528EE0.wby.mendeley.com)
[17:00:49] *** Quits: StarLight (StarLight@moz-B8E3BA82.dynamic.avangarddsl.ru) (Ping timeout)
[17:02:29] <engla> cmr: the tuple lexical order uses both   a < b and !(b < a)  which leads to this:
[17:02:42] <engla> rusti: let nan = 0.0/0.0;  (1.0, 2.0) < (nan, 3.0)
[17:02:43] -rusti- true
[17:02:47] <jack> brson: just found this if you're curious about erlang's scheduler: http://www.erlang-factory.com/upload/presentations/708/HitchhikersTouroftheBEAM.pdf
[17:02:51] <jack> maybe too high level to be useful
[17:02:55] *** Parts: saneyuki_s (Mibbit@moz-A3FEAA56.ap219.ftth.ucom.ne.jp) ()
[17:03:34] <engla> cmr: so short-circuiting on != is better at least :)
[17:04:51] <brson> jack: thanks
[17:05:14] *** Joins: StarLight (StarLight@moz-880B9767.pppoe.avangarddsl.ru)
[17:05:14] *** Joins: fabiand (fabiand@moz-B59858CA.adsl.alicedsl.de)
[17:05:17] *** Joins: huseby (huseby@19BD73A1.5D8BCA3A.A0C1B52F.IP)
[17:06:27] <toddaaro> brson graydon : ok, first go it looks like skipping the run_in_newsched_* is a disaster, the bench is being forked off and then the iter returns 0ns, and the test harness hangs at the end of the bench set
[17:06:40] *** Quits: vodik (simon@moz-1DDE8FF6.dsl.bell.ca) (Ping timeout)
[17:06:43] *** Joins: ecr (Thunderbir@moz-BBE3ABD.mv.mozilla.com)
[17:06:46] <toddaaro> brson graydon : I'll try plumbing together some "doneness" logic now and see how that goes
[17:06:48] <mihneadb> hi - why is this not a compile error? http://pastebin.mozilla.org/2810510
[17:06:51] <mihneadb> (-5 as uint)
[17:06:53] *** Quits: huseby (huseby@19BD73A1.5D8BCA3A.A0C1B52F.IP) (Connection reset by peer)
[17:07:37] <mihneadb> rusti: let x: uint = -5; x;
[17:07:37] -rusti- <anon>:5:27: 5:28 warning: path statement with no effect [-W path-statement (default)]
[17:07:37] -rusti- <anon>:5          let x: uint = -5; x;
[17:07:38] -rusti-                                     ^
[17:07:38] -rusti- ()
[17:07:44] <cmr> mihneadb: because the semantics of negative unsigned numbers are well-defined.
[17:07:53] <cmr> mihneadb: they're 2's complement fixnums.
[17:08:31] <cmr> rusti: 257i8
[17:08:31] -rusti- <anon>:5:9: 5:14 error: literal out of range for its type
[17:08:32] -rusti- <anon>:5          257i8
[17:08:32] -rusti-                   ^~~~~
[17:08:32] -rusti- error: aborting due to previous error
[17:08:32] -rusti- application terminated with error code 101
[17:08:36] *** Quits: cdidd (cdidd@moz-D66E14A.broadband.corbina.ru) (Ping timeout)
[17:08:49] <cmr> IMO it should fall under the same category as that error
[17:08:51] <mihneadb> cmr: with rust's safetiness I was actually expecting not having to check for this sort of stuff
[17:08:53] <cmr> (but it should also be a lint)
[17:09:02] <cmr> mihneadb: there's nothing unsafe about overflow
[17:09:11] <cmr> (and underflow)
[17:09:19] <mihneadb> unsafe in terms of null pointers, sure
[17:09:31] <cmr> safety in rust is about memory safety and type safety
[17:09:33] <mihneadb> but in terms of "safe" programming, I'd say there is
[17:09:38] <cmr> I agree with you
[17:09:54] <mihneadb> so.. why don't you think this falls into type safety
[17:10:00] <mihneadb> i.e. passing an int to an uint param
[17:10:17] <kimundi> mihneadbd That.s not whats happening
[17:10:27] <mihneadb> kimundi: what is
[17:10:28] <kimundi> your passing a uint to a uint
[17:10:31] <cmr> rusti: let x = 5u; x.neg()
[17:10:32] -rusti- 18446744073709551611
[17:10:42] <cmr> rusti: let x = 5u; let x = x.neg(); x
[17:10:43] -rusti- 18446744073709551611
[17:10:46] <cmr> that's basically what you're saying
[17:11:02] <Sergio965> I'm getting the following error when writing a macro: "unexpected token: `an interpolated block`". Has anyone seen this before? I'm not entirely sure what it means.
[17:11:13] <mihneadb> ok.. I'm not sure why uint implements neg
[17:11:20] <cmr> mihneadb: it's a well-defined operation
[17:11:30] <bstrie> rusti: -5u
[17:11:31] -rusti- 18446744073709551611
[17:11:40] <cmr> rusti: (-5)u
[17:11:41] -rusti- <anon>:5:13: 5:14 error: expected `;` or `}` after expression but found `u`
[17:11:41] -rusti- <anon>:5          (-5)u
[17:11:41] -rusti-                       ^
[17:11:41] -rusti- application terminated with error code 101
[17:11:43] <bstrie> rusti: 5u * -1u
[17:11:43] -rusti- 18446744073709551611
[17:11:46] <pauls> Sergio965: it means that there's a block (from `$my_block` in a macro) in a place were the parser didn't expect one, in the macro expansion.
[17:11:47] <engla> mihneadb: it implements Sub
[17:12:16] <mihneadb> cmr: engla: ok
[17:12:32] <cmr> mihneadb: really most programs want a bignum, not a uint or u32 or anything else
[17:12:49] <mihneadb> right
[17:12:53] *** Joins: eschweic (Adium@moz-BBE3ABD.mv.mozilla.com)
[17:12:58] *** Joins: hjr3 (hradtke@374E545A.3A8E9B0C.F9D9C60E.IP)
[17:13:59] *** Quits: pnkfelix (pnkfelix@87C1F78E.1DE10CA8.D8E68FF6.IP) (Ping timeout)
[17:14:00] <panzi> there is no way to do somethink like this (the return)?    |x| { if cond(x) { return false; } lots_of_code(x); true }
[17:14:10] <panzi> I have to use if+else?
[17:14:26] <cmr> panzi: correct, no early return from closures
[17:14:32] *** Joins: pnkfelix (pnkfelix@87C1F78E.1DE10CA8.D8E68FF6.IP)
[17:14:49] <Sergio965> pauls: But it's wrong...
[17:15:08] <cmr> mihneadb: https://github.com/mozilla/rust/issues/5477
[17:15:26] <Sergio965> pauls: Is there a grammar somewhere?
[17:15:35] <mihneadb> cmr: nice, thanks
[17:16:20] <pauls> Sergio965: you'll need to show me the actual example before I can evaluate that. But later; I've got to deal with other stuff now.
[17:17:25] *** Joins: azakai (alon@moz-BBE3ABD.mv.mozilla.com)
[17:17:42] *** Joins: int3_ (int3_@moz-ABE52D50.hsd1.ca.comcast.net)
[17:18:18] *** Quits: heftig (heftig@moz-D2368502.dip0.t-ipconnect.de) (NickServ (GHOST command used by heftig_))
[17:18:33] *** Joins: heftig (heftig@moz-D2368502.dip0.t-ipconnect.de)
[17:19:30] *** Quits: int3_ (int3_@moz-ABE52D50.hsd1.ca.comcast.net) (Ping timeout)
[17:20:56] *** Joins: azita (Azita@moz-7E81A256.static.qsc.de)
[17:21:30] *** Joins: devinus (devinus@moz-B4AF84BC.ptr.us.xo.net)
[17:22:56] <graydon> reminder: if you are landing a bug that closes some issue #NNNN, please put "close #NNNN" in the commit comment :)
[17:22:58] <graydon> really helps
[17:24:15] <acrichto> graydon: does the commit vs pull request matter that much?
[17:24:39] <graydon> acrichto: yeah. PRs get closed out randomly, reopened, rolled up, etc.
[17:24:52] <cmr> Also github doesn't actually close the issue when the PR gets merged
[17:24:56] <acrichto> ah, good point. Also do you know the syntax for closing multiple issue at once?
[17:25:02] <acrichto> cmr: it doesn't? I thought it did...
[17:25:04] <panzi> is there a way to get the current time in milliseconds?
[17:25:24] <cmr> acrichto: it usually does, but sometimes it doesn't see the PR as "merged" even when it was, in fact, merged.
[17:25:25] <graydon> acrichto: if you put it in the commit, github will auto-close the bug when it merges into master
[17:25:55] <vk> Should this "do std::uint::iterate(0, len) |i| {" be replaced with a for loop now?
[17:26:04] <cmr> vk: yes!
[17:26:06] <acrichto> graydon: does github also detect "Closes #x and #y" or would that have to be formatted as "Closes #x \n Closes #y"
[17:26:08] <cmr> for i in range(0, len)
[17:26:09] <acrichto> cmr: that's ssad :(
[17:26:15] <vk> cmr: cool, thanks.
[17:27:19] <graydon> acrichto: I normally put it as "close #N close #N close #N"
[17:27:36] <acrichto> graydon: ok cool, I'll do that if I run across it again
[17:27:47] *** Joins: cdidd (cdidd@moz-F31196CF.broadband.corbina.ru)
[17:27:48] *** Quits: dherman (dherman@moz-6CA476B1.hsd1.ca.comcast.net) (Quit: dherman)
[17:28:59] *** Quits: reyre (reyre@B2D8AB09.33EE9F8A.1139E686.IP) (Quit: Konversation terminated!)
[17:29:12] *** Joins: dherman (dherman@moz-6CA476B1.hsd1.ca.comcast.net)
[17:29:12] *** ChanServ sets mode: +o dherman
[17:29:25] *** Joins: reyre (reyre@B2D8AB09.33EE9F8A.1139E686.IP)
[17:30:25] *** Joins: nawfel (Mibbit@A7F05FC8.7BD487F1.DFAB1F33.IP)
[17:30:29] *** Quits: alisdair (textual@moz-FBF4138A.vc.shawcable.net) (Quit: My MacBook Pro has gone to sleep. ZZZzzz…)
[17:30:38] <engla> graydon: is the single-value tuple here to stay?
[17:30:49] <tjc> engla: it's here to say -- needed for macros
[17:30:52] <engla> rusti: (1,) < (2,) 
[17:30:52] -rusti- <anon>:5:9: 5:20 error: binary operation < cannot be applied to type `(<VI0>)`
[17:30:53] -rusti- <anon>:5          (1,) < (2,) 
[17:30:53] <nmatsakis> someone want to r? https://github.com/mozilla/rust/pull/8394 
[17:30:53] -rusti-                   ^~~~~~~~~~~
[17:30:53] -rusti- error: aborting due to previous error
[17:30:53] -rusti- application terminated with error code 101
[17:31:00] <engla> ok. it's missing some traits that others have
[17:31:02] <tjc> engla: that should be fixed, though :-)
[17:31:04] <bstrie> let's not even document single-element tuples
[17:31:11] <engla> right, I'm digging around in tuple.rs now so
[17:31:11] <bstrie> let them be a "hidden feature"
[17:31:13] *** Quits: panzi (chatzilla@moz-B475CCDD.adsl.highway.telekom.at) (Quit: ChatZilla 0.9.90.1 [Firefox 23.0/20130807192336])
[17:31:26] <graydon> engla: yeah, I think so
[17:31:31] <tjc> I'm ok with not doumenting them
[17:31:34] <tjc> they should have the traits, though
[17:31:53] <bstrie> let's obfuscate all the code files that use them
[17:31:54] <brson> graydon: bors seems to be off
[17:31:55] <engla> I'm trying to fix lexical compare for tuples now
[17:31:58] <nmatsakis> an/window list
[17:31:59] <bstrie> nobody can know our secret shame
[17:32:12] <graydon> I don't think we need a huge documentation section about them; they should be documented in the sense that tuples are defined as "1 or more elements" and we write a grammar that obviously produces that!
[17:32:23] <tjc> well, yes, they should be in the grammar
[17:32:28] <bstrie> right, I mean "let
[17:32:36] <graydon> brson: huh. it's "on" but I'll check what's going wrong
[17:32:43] <bstrie> 's not mention them in the way that python not mentions them"
[17:33:03] <bstrie> though in python they actually have to mention it a little bit
[17:33:06] *** Quits: paulproteus (quassel@rose.makesad.us) (Ping timeout)
[17:33:22] <cmr> why the hate for the one-tuple :(
[17:34:12] *** Quits: brson (brson@moz-BBE3ABD.mv.mozilla.com) (Ping timeout)
[17:34:37] <ecr> bblum: are you awake?
[17:34:42] *** Joins: brson (brson@moz-BBE3ABD.mv.mozilla.com)
[17:34:42] *** ChanServ sets mode: +o brson
[17:35:11] *** Joins: paulproteus (quassel@moz-E86A3B42.makesad.us)
[17:35:18] <bstrie> cmr: what is this new tab on irfy
[17:35:50] <brson> graydon: I disabled the mac valgrind builders last night. they have two issues: https://github.com/mozilla/rust/issues/8389 and https://github.com/mozilla/rust/issues/8267
[17:35:59] <cmr> bstrie: ask dbaupp :p. it's pull requests, clearly.
[17:36:19] <bstrie> cmr: but, are they fast yet?
[17:36:21] *** Joins: josh (josh@moz-92F864C8.ds1-by.adsl.cybercity.dk)
[17:36:33] <bstrie> is it just an echo of "git log"
[17:36:50] *** Quits: josh (josh@moz-92F864C8.ds1-by.adsl.cybercity.dk) (Quit: josh)
[17:36:57] <cmr> with links!
[17:36:59] *** Joins: mschifer (Adium@moz-BBE3ABD.mv.mozilla.com)
[17:37:15] *** Joins: tchoma (tchoma@moz-BE33DA21.fw1.sfo1.mozilla.net)
[17:38:06] *** Quits: CarpNet (ac@moz-FD24B77.sohonet.co.uk) (Quit: Leaving)
[17:38:12] *** Quits: cdidd (cdidd@moz-F31196CF.broadband.corbina.ru) (Input/output error)
[17:38:28] *** Joins: huseby (huseby@19BD73A1.5D8BCA3A.A0C1B52F.IP)
[17:39:19] *** Quits: azita (Azita@moz-7E81A256.static.qsc.de) (Quit: azita)
[17:39:26] *** Quits: tjc (tjc@moz-6EB4E533.dsl.tsoft.com) (Quit: Places to go, people to annoy)
[17:40:55] <mihneadb> cmr: how do I use task_rng?
[17:41:03] <mihneadb> task_rng().gen::<int>() from docs doesn't seem to work
[17:41:09] <mihneadb> type `@mut std::rand::IsaacRng` does not implement any method in scope named `gen`
[17:41:15] *** Quits: nawfel (Mibbit@A7F05FC8.7BD487F1.DFAB1F33.IP) (Quit: http://www.mibbit.com ajax IRC Client)
[17:41:19] *** Quits: hjr3 (hradtke@374E545A.3A8E9B0C.F9D9C60E.IP) (Ping timeout)
[17:42:15] <bblum> ecr: yes
[17:42:56] *** Quits: lucian (lucian@6B2B4644.4304AE1E.CE5E78F6.IP) (Ping timeout)
[17:42:58] <ecr> bblum: I need a way to take a BlockedTask and call Task.give_home() on it.
[17:43:15] <mihneadb> cmr: I used random::<int>(), that worked. Would love to be able to use something like gen_int_range, but on the task rng
[17:43:22] <bblum> ecr: blocked_task.wake()
[17:43:27] *** Joins: cdidd (cdidd@moz-6B78B066.broadband.corbina.ru)
[17:43:42] <cmr> mihneadb: I dunno, seems weird. Maybe it just needs an impl of Rng for @mut IsaacRng
[17:43:45] <bblum> ecr: are you not actually scheduling it at that point? or what?
[17:43:56] <cmr> ...I would assume that task_rng is at least used or tested though
[17:44:00] <cmr> so that seems weird
[17:44:24] <toddaaro> bblum: no scheduling, just a mutation of the task struct
[17:44:39] <ecr> bblum: kind of? I'm doing something like deschedule => set home => enqueue task
[17:44:48] *** Joins: hjr3 (hradtke@374E545A.3A8E9B0C.F9D9C60E.IP)
[17:44:59] <bblum> if you are rescheduling it at that point, you can just be like
[17:45:04] *** Joins: Peng (mnordhoff@moz-D5175E95.mattnordhoff.net)
[17:45:20] <bblum> do blocked_task.wake().map_consume |task| { task.set_home(..); sched.enqueue_task(task); }
[17:45:22] <Sergio965> For 0.8, are the way macros are handled being improved? I'm having a lot of trouble getting the scoping right.
[17:45:34] <Sergio965> (#[macro_escape] and such)
[17:45:47] <cmr> Sergio965: I don't think anyone is actively working on it
[17:45:50] <bblum> if you want it to stay blocked, you will have to BlockedTask::try_block it again after
[17:45:51] <graydon> Sergio965: I don't think anyone is working on it, no
[17:45:57] <ecr> bblum: alright, I'll give that a shot. thanks
[17:46:01] <Sergio965> Shouldn't macros just be global?
[17:46:12] <bblum> ecr: (think of it like the maybe monad where failure is the task getting killed)
[17:46:30] <bblum> (asynchronously)
[17:46:48] <graydon> Sergio965: what would you suggest we do when someone collides a macro name?
[17:46:55] <Sergio965> Throw an error.
[17:47:09] <Sergio965> Or perhaps allow a #[macro_override].
[17:47:17] *** Joins: pcwalton (pcwalton@moz-7B0110AD.mv.mozilla.com)
[17:47:17] *** ChanServ sets mode: +o pcwalton
[17:47:19] <Sergio965> (To override built-in macros)
[17:47:27] <ecr> bblum: makes sense
[17:48:34] <pauls> Sergio965: in "proper" macro systems, macros do obey scoping rules.
[17:49:06] <Sergio965> I wouldn't have a problem with either solution.
[17:49:11] <Sergio965> But neither is currently implemented.
[17:49:55] <Sergio965> Module based macro scoping would be nice, actually.
[17:50:04] <Sergio965> Something like: module::my_macro!(bla).
[17:50:26] *** Joins: Kruppe (user@moz-4DDA8AB8.uwaterloo.ca)
[17:51:17] <graydon> brson: bors is stopped because you removed the mac-64-vg builder :)
[17:51:34] <bstrie> the truth comes out
[17:51:36] *** Quits: Kruppe (user@moz-4DDA8AB8.uwaterloo.ca) (Client exited)
[17:51:47] <bstrie> and here we were all blaming graydon
[17:51:54] <graydon> no, you were blaming bors
[17:51:59] <graydon> who gets blamed for everything!
[17:52:06] <cmr> he's a very convenient scapegoat
[17:52:16] <graydon> never talks back, etc.
[17:52:20] <graydon> anyway, let's see about that builder
[17:53:35] <graydon> Sergio965: I'd like some form of qualified-macro support, yes. Or a way to import groups of macros from other modules. It would be fine for me to say use_macro!(some::path, ...)
[17:53:49] <peterdn> hey guys, how would I get a *libc::FILE for stdout?
[17:53:55] <brson> graydon: oh!
[17:53:57] <Sergio965> graydon: Why not just have macros come along with the current use?
[17:54:12] <Sergio965> IE: If I do: use macros::*;, I should be able to do: macros::my_macro!(..);
[17:54:17] <Sergio965> Er.
[17:54:25] <Sergio965> use macros; macros::my_macro!(..);
[17:54:35] <graydon> Sergio965: a bug on this topic would be quite welcome. there are a variety of ways to approach it.
[17:54:41] <graydon> (there may already be one)
[17:55:07] <Sergio965> Additionally, use macros::(macro!, macro2!} should also be supported.
[17:55:13] <Sergio965> I'll look through and open one if I don't find one.
[17:55:25] <cmr> the ! isn't part of the macro name
[17:55:27] <bstrie> peterdn: maybe http://static.rust-lang.org/doc/std/io.html can help
[17:55:28] <cmr> just invocation
[17:55:41] <bstrie> peterdn: looks like maybe the std::io::FILERes type is what you want?
[17:55:57] *** Quits: huseby (huseby@19BD73A1.5D8BCA3A.A0C1B52F.IP) (Quit: Leaving)
[17:56:00] <graydon> bors is turned off now, fyi
[17:56:02] <Sergio965> cmr: Interesting. well, it should be. Maybe.
[17:56:09] <cmr> Sergio965: don't think so.
[17:56:15] <cmr> it'd be inconsistent
[17:56:22] <cmr> macro_rules! foo ...
[17:56:25] <Sergio965> With what?
[17:56:30] <cmr> the macro's name is foo
[17:56:31] <cmr> not foo!
[17:56:47] <bstrie> graydon: found another mesozoic-era page for you to delete: http://static.rust-lang.org/doc/std/files/getopts-rs.html
[17:57:06] <cmr> I don't think it needs a custom solution, macros should act just like existing items.
[17:57:08] <graydon> bstrie: you will be happy to know I deleted it already, I think cmr pointed it out?
[17:57:20] <bstrie> ah it was still in cache
[17:57:30] *** Joins: brendan (brendaneic@moz-BBE3ABD.mv.mozilla.com)
[17:57:31] <bstrie> graydon: but that XML error is no more helpful :P
[17:57:47] * kimundi imagines bstrie entering random rust apis in google clicking on everything to make sure all except the current 404s
[17:57:52] <bstrie> though I guess it's at least less unhelpful
[17:58:23] <bstrie> kimundi: I think that once 1.0 comes out we should just switch from rust-lang.org to rustlang.org, just to be safe :)
[17:58:26] <peterdn> bstrie: thanks, I had a look but couldn't see an obvious way to extract it from that. I'll dig around a bit more
[17:58:26] *** Quits: Sergio965 (sergiobz@moz-8D70E596.wireless.csail.mit.edu) (Connection reset by peer)
[17:58:28] <graydon> I will happily add an S3 error page if someone wants to write one
[17:58:53] <sfackler> acrichto: r? https://github.com/mozilla/rust/pull/8362
[17:59:04] <graydon> I have more or less no opinions on what should go on such a page. I hear adorable animals dancing around an animated image of the number 404 is popular?
[17:59:30] <acrichto> sfackler: r+, thanks!
[17:59:33] <bstrie> graydon: not for rust, we're more into the "industrial" aesthetic
[17:59:42] *** Joins: jdm (jdm@19E8F2AF.B919BE8A.47C41102.IP)
[17:59:42] <bstrie> so maybe like adorable robots dancing around
[17:59:55] <toddaaro> how about a rusty spaceship crashing
[17:59:58] <graydon> a bike aesthetic also. maybe someone going for a bike ride.
[18:00:15] <kimundi> How about an omnious spinning bors?
[18:00:20] <bstrie> graydon: create a gif of yourself riding a bike into a hedge outside of the mozilla office
[18:00:26] <kimundi> haha
[18:01:12] <bstrie> then the spinning wheel of the bike turns into a spinning rust logo and the rest of the image fades to white
[18:01:21] <olsonjeffery> so make install is failing for me on the stage1 build of librustc .. known issue?
[18:01:36] <bstrie> olsonjeffery: make install works with stage1?
[18:01:39] *** Joins: azita (Azita@moz-7E81A256.static.qsc.de)
[18:01:47] <cmr> bstrie: it builds everything if they need building
[18:01:54] <olsonjeffery> yeah, that
[18:01:54] <bstrie> ah I see
[18:01:59] <bstrie> I thought you were modifying the makefule
[18:02:00] <graydon> bstrie: I approve of this message
[18:02:10] <olsonjeffery> anyways.. looks like check-stage1-std works.. so ill just make due
[18:02:12] <olsonjeffery> at least i can run tests
[18:02:28] <cmr> olsonjeffery: try just running make again
[18:02:32] <cmr> sometimes it gets weird
[18:02:40] <brson> olsonjeffery: do you have a backtrace?
[18:02:50] *** Quits: leonvv (leonvv@moz-7D83A5F1.ip.telfort.nl) (Client exited)
[18:03:53] <bblum> brson: i have another idea for the env race bug, which involves a xchg on the cleanup job and a cmpxchg on the other CPU
[18:04:08] *** Joins: huseby (huseby@19BD73A1.5D8BCA3A.A0C1B52F.IP)
[18:04:09] *** Joins: nano (nano@moz-74CAD1CA.superkabel.de)
[18:04:57] <bblum> basically analogous to the state flag in a pipe, using reference counting of the 'active endpoints' to decide which endpoint is the one that gets to schedule the task
[18:05:55] <bblum> it has the (what might be a) disadvantage of making the task possibly bounce back to the cpu running the cleanup job
[18:06:06] <graydon> brson: any idea why we are creating so many segments?
[18:06:12] <graydon> brson: (re: valgrind)
[18:07:10] *** Quits: robertknight (robertknig@moz-54528EE0.wby.mendeley.com) (Ping timeout)
[18:08:52] <graydon> brson: obviously one solution would be to recompile valgrind with a larger number on all those bots. but that's a little alarming-sounding to me.
[18:09:01] <graydon> (also curious why it doesn't happen on linux-vg)
[18:09:51] *** Quits: brendan (brendaneic@moz-BBE3ABD.mv.mozilla.com) (Quit: brendan)
[18:10:22] *** Quits: devinus (devinus@moz-B4AF84BC.ptr.us.xo.net) (Quit: Computer has gone to sleep.)
[18:10:44] *** Quits: echristo (echristo@60A74940.D6CCE4AE.77834EAA.IP) (Quit: echristo)
[18:12:16] * olsonjeffery whistles and twiddles thumbs while rustc chugs along in gdb
[18:12:21] *** Quits: rust-buildbot (rust-build@505BFA3.C3CCCE8C.D25A875A.IP) (Quit: buildmaster reconfigured: bot disconnecting)
[18:12:21] *** Joins: rust-buildbot (rust-build@505BFA3.C3CCCE8C.D25A875A.IP)
[18:12:49] <brson> graydon: it's a little surprising to me. on 64-bit mac we should actually be requesting *less* stack than we were previously, since the new tasks use a fixed 2MB whereas the old tasks used an initial 4MB segment. One possibility: on mac every libuv loop has a companion worker thread, so in stdtest where we are creating lots of threads and lots of event loops perhaps the switch to the new runtime pushed our allocation even higher
[18:13:25] <brson> any suggestions about how to investigate this?
[18:13:55] <graydon> brson: I'll try to take a look. you have your hands full with other stuff..
[18:14:02] <brson> ok :(
[18:14:48] *** Joins: mwcampbell (matt@moz-52DF570B.ks.ks.cox.net)
[18:15:08] <mwcampbell> Did the Rust team ever decide whether to remove garbage collection from the language as pcwalton suggested?
[18:15:22] <pcwalton> yes
[18:15:30] *** Ms2ger is now known as Ms2gerbot
[18:15:51] <graydon> mwcampbell: we decided to continue gradually shifting responsibility for it to libraries
[18:15:53] <olsonjeffery> umm, so.. is there ever a reason for rustc to be over 200 stack frames deep in the backtrace?
[18:16:05] <olsonjeffery> that's how far i am in gdb w/ bt, thus far..
[18:16:08] <graydon> brson: meanwhile shall I just tell bors not to look for that builder and keep it disabled?
[18:16:09] <brson> bblum: that sounds promising. what is the impact on the normal path?
[18:16:09] <olsonjeffery> maybe infinite loop?
[18:16:14] <brson> graydon: yes please
[18:16:19] <pcwalton> it's more or less a syntactic change, the details need to be ironed out a bit (specifically the pointer trait or deref trait...pointer trait probably)
[18:16:26] <cmr> olsonjeffery: 200 doesn't sound that deep, there are some really deep data structures
[18:16:37] *** Joins: brendan (brendaneic@moz-BBE3ABD.mv.mozilla.com)
[18:16:39] <bstrie> graydon: for your perusal: http://seleniac.org/404/
[18:16:48] <graydon> brson: ok. the builder's on, it'll just be red until I get it fixed up.
[18:17:27] <olsonjeffery> 1428 frames deep, total
[18:17:36] <brson> olsonjeffery: it could be overflowing the stack. if so valgrind will detect that. you might also want to try bumping the constant in librustc/rustc.rs that sets rustc's stack size
[18:17:37] <cmr> that sounds quite deep
[18:17:44] *** Joins: diegoyam (quassel@FF9B1514.A4EC3D18.3A1EC144.IP)
[18:17:57] <brson> right now rustc requests 4MB of stack
[18:18:06] <graydon> bstrie: hm, needs more marqee
[18:18:17] *** Joins: tcr (tcr@D26BCFC9.C2203064.EDCE493E.IP)
[18:18:24] <bstrie> graydon: it blinks as well, but I'm using aurora so I can't see it :(
[18:18:28] <graydon> pcwalton: we were planning to keep '@' right?
[18:18:37] <graydon> bstrie: ah, I'm on nightly, similar.
[18:18:40] <pcwalton> I thought we were going to Gc<>
[18:18:46] *** Joins: eatkinson (eatkinson@moz-BBE3ABD.mv.mozilla.com)
[18:19:21] <graydon> I thought the community response was a solid preference for @. huh.
[18:19:32] <olsonjeffery> brson: https://gist.github.com/olsonjeffery/6187220
[18:19:34] <heftig> I'd prefer for it to go
[18:19:37] <bstrie> I'm indifferent
[18:19:40] <cmr> I thought we were keeping @
[18:19:44] <pcwalton> I was operating under the assumption that @ was going away
[18:19:49] <cmr> I liked kimundi's proposal
[18:19:53] <pcwalton> hence the discussion about repurposing @
[18:20:01] <graydon> (which discussion?)
[18:20:07] <bstrie> weren't we going to do something like `foo in Gc` instead?
[18:20:10] <pcwalton> some random ones on reddit
[18:20:20] <cmr> Seems nobody knows what is going on
[18:20:21] <pcwalton> I don't think we'll actually do it
[18:21:06] <graydon> I am kinda a reddit-boycotter in general, don't use it
[18:21:14] <graydon> (fwiw, also HN)
[18:21:15] <bstrie> well are we moving gc into a library? if so, then there's going to be an underlying Gc type regardless, so the question of whether to add @ back as sugar is backwards-compatible as long as we don't use the character for anything else
[18:21:19] *** Joins: mark_edward (quassel@moz-57A72B6E.hsd1.in.comcast.net)
[18:21:21] *** Quits: novabyte (Instantbir@moz-3E0F9699.cable.virginmedia.com) (Quit: bye bye)
[18:21:44] <kimundi> bstrie: that's what I'm thinking right now too
[18:22:08] <brson> olsonjeffery: do you still have the debugger running?
[18:22:09] <graydon> bstrie: as much as possible, I believe so. I mean, "move into a library" where the compiler knows about lang items and methods it has to call here and there ... is not hugely different from what we have today.
[18:22:11] <pcwalton> I'm not really fond of the @ character but I could be convinced otherwise
[18:22:17] <olsonjeffery> brson: yes
[18:22:35] <graydon> it's moving a small amount of code form the codegen to library code. the gc itself -- allocation, scanning, collection -- is always "library code" in any event
[18:22:39] <toddaaro> graydon: what is the "max" length for a #[bench] iteration to be reasonable?
[18:22:42] <pcwalton> yeah
[18:22:47] <toddaaro> graydon: I assume 100 us is ok?
[18:22:55] <pcwalton> we should make it a lang item so we can do stack maps in the future too
[18:22:58] <graydon> toddaaro: a few ms. I think it aims for ... (lemme check)
[18:22:58] *** Joins: ghrust (ghrust@FD7BC443.6A2AE50.F3114085.IP)
[18:22:59] <ghrust> 01[13rust01] 15bors merged 06auto into 06master: 02http://git.io/iR7oEg
[18:22:59] *** Parts: ghrust (ghrust@FD7BC443.6A2AE50.F3114085.IP) ()
[18:23:17] <bstrie> I've come to agree with pcwalton that having super-short syntax for @ encourages people to use it, and I've also come to agree that people are using it too much
[18:23:26] *** Joins: erickt (etryzelaar@8C9ECD8F.3A598286.F12515B4.IP)
[18:23:35] <pcwalton> I mean, honestly the discussion about "removing GC" really boils down to the same sort of difference between Haskell's "Bool" enum or a builtin bool type
[18:23:46] <pcwalton> more or less totally uninteresting from a theoretical POV, it's mostly syntactic
[18:23:54] <toddaaro> graydon: I'm getting non-deterministic 0ns output, I think it is other problems and not #bench, but I want to confirm I'm not horribly misusing it
[18:23:57] <pcwalton> it's clear that @ has to be sorta-magic because of stack maps
[18:23:58] <brson> olsonjeffery: can you do something like `frame 0; print $esp; frame 1427; print $esp;` to get the stack pointers at the top and bottom of the stack and gist them?
[18:24:08] *** Joins: tjc (tjc@moz-BBE3ABD.mv.mozilla.com)
[18:24:08] *** ChanServ sets mode: +o tjc
[18:24:09] <pcwalton> and borrowing
[18:24:24] <graydon> toddaaro: 100us is fine. it does a calibration loop to try to figure out how many iterations to run your benchmark for in order to get a 1ms sample, then samples 50 times.
[18:24:36] <brson> olsonjeffery: if the difference is in the vicinity of 4MB then that's bad
[18:24:38] <graydon> toddaaro: then keeps doing that until the 50 samples have a reasonably tight statistical distribution
[18:24:39] <bstrie> graydon: you're not missing anything by not reading reddit, I tell people to take any serious discussions to the mailing list if they actually want them considered
[18:25:44] <mark_edward> did you read that thing about the BitC devs?
[18:25:53] <toddaaro> graydon: ok, so I just need to be under 1ms to keep it happy?
[18:25:54] <bstrie> think of the discussions on reddit like the bikeshedding section on the wiki
[18:25:56] *** Joins: ghrust (ghrust@9C8B94D4.6A2AE50.F3114085.IP)
[18:25:56] <ghrust> 01[13rust01] 15bors pushed 0 new commits to 06auto: 02http://git.io/_TGhxw
[18:25:56] *** Parts: ghrust (ghrust@9C8B94D4.6A2AE50.F3114085.IP) ()
[18:25:59] *** Joins: ghrust (ghrust@F6EE6DE3.6A2AE50.F3114085.IP)
[18:25:59] <ghrust> 01[13rust01] 15bors pushed 29 new commits to 06auto: 02http://git.io/iv-hEg
[18:25:59] <ghrust> 13rust/06auto 14026c1ae 15blake2-ppc: extra: Remove all .each methods in smallintmap
[18:25:59] <ghrust> 13rust/06auto 1440bdbf0 15blake2-ppc: std: Fix for-range loops that can use iterators...
[18:25:59] <ghrust> 13rust/06auto 14e7d4a9c 15blake2-ppc: Bugfix .each_edge in middle/graph.rs...
[18:26:01] *** Parts: ghrust (ghrust@F6EE6DE3.6A2AE50.F3114085.IP) ()
[18:26:06] <toddaaro> though, this is interesting, two segfaults in a row on seemingly ok code
[18:26:17] * graydon notices another screed from Johnathan Shapiro on reddit. dang. he is really not into us.
[18:26:24] *** Joins: strcat (strcat@moz-54F7FD49.cpe.net.cable.rogers.com)
[18:26:42] <graydon> toddaaro: if you run longer than 1ms it just sets the iteration count to 1, which is non-ideal, yeah.
[18:26:57] <olsonjeffery> brson: $esp is the same for both frames..
[18:27:00] <graydon> toddaaro: (and then does 50 samples of 1-iteration, and keeps doing that until it has a statistically-nice set of 50 samples, etc.)
[18:27:09] *** Quits: brianm (brianm@moz-9B7D279E.dsl.static.sonic.net) (Quit: Leaving...)
[18:27:17] <olsonjeffery> brson: i probably need to break and keep the process from running, huh...
[18:27:20] <bstrie> graydon: I think he's just quite misinformed, which to be fair is our fault for having old/missing documentation
[18:27:22] <olsonjeffery> s/running/exiting/
[18:27:50] *** Joins: brianm (brianm@moz-9B7D279E.dsl.static.sonic.net)
[18:27:52] <olsonjeffery> doesn't look like there's anywhere for me to break...
[18:27:52] <brson> olsonjeffery: oh maybe i don't know how to use gdb. very likely
[18:28:26] <strcat> no one *really* knows how to use gdb, we all just stumble through the 6000 commands
[18:28:39] <cmr> I use, like, 4
[18:28:48] *** Quits: erickt (etryzelaar@8C9ECD8F.3A598286.F12515B4.IP) (Quit: leaving)
[18:28:48] <cmr> break, continue, run, print :p
[18:29:00] <mihneadb> - is the best gdb command
[18:29:03] <cmr> oh, step and next
[18:29:07] <mihneadb> but I think it only works with C
[18:29:25] <mihneadb> (shows you the source code while you step through it)
[18:29:31] <toddaaro> graydon: oh, is 0ns the "ran out of time" output?
[18:29:32] <cmr> it works elsewhere
[18:29:37] <cmr> I just use cgdb
[18:29:43] <cmr> or split view with just gdb
[18:29:48] <mihneadb> ah yes cgdb does that by def
[18:29:52] <cmr> but cgdb is better
[18:30:11] <graydon> toddaaro: I don't know
[18:30:22] <graydon> toddaaro: I haven't seen it do that before
[18:30:41] <graydon> bstrie: he seems terribly interested in writing up broad-reaching critiques of our work. bummer.
[18:30:46] <strcat> cmr: yeah and displaying variables is too painful so I just use 'bt full' ;p
[18:30:59] <toddaaro> hm, looks like it is, if you run for >3s it returns summ5 which is zero if you haven't finished an iteration
[18:31:03] <strcat> there's a gvim plugin to do breakpoints for you
[18:31:07] <strcat> soooooooo much simpler
[18:31:13] <toddaaro> I may have to hack these constants a bit so I can run inside gdb
[18:31:21] *** Joins: kermi (Mibbit@moz-D3D15A0C.vie.surfer.at)
[18:31:41] <SimonSapin> Is this a good candidate for std::iterator? https://gist.github.com/SimonSapin/6187341
[18:32:23] *** Joins: erickt (etryzelaar@8C9ECD8F.3A598286.F12515B4.IP)
[18:32:29] <graydon> toddaaro: why would you not finish an iteration? it runs until your iteration completes.
[18:33:46] <toddaaro> graydon: true, I guess you finish an iteration, and then it does total_run += loop_run; if total_run > 3_000_000_000 { return summ5; }
[18:33:58] *** Joins: ikona (ikona@moz-380B1CA5.adsl.alicedsl.de)
[18:34:17] <graydon> wow this is _bizarre_, they've had like 2 weeks of criticizing-rust threads on bitc list. what gives?
[18:34:34] *** Quits: pnkfelix (pnkfelix@87C1F78E.1DE10CA8.D8E68FF6.IP) (Quit: Leaving.)
[18:34:49] <graydon> toddaaro: yeah
[18:34:56] *** Joins: ghrust (ghrust@F6EE6DE3.6A2AE50.F3114085.IP)
[18:34:56] <ghrust> 01[13rust01] 15bors 04force-pushed 06auto from 14aa88c34 to 14a0080f4: 02http://git.io/N3iJvQ
[18:34:56] *** Parts: ghrust (ghrust@F6EE6DE3.6A2AE50.F3114085.IP) ()
[18:34:57] *** Joins: ghrust (ghrust@F6EE6DE3.6A2AE50.F3114085.IP)
[18:34:57] <ghrust> 01[13rust01] 15bors pushed 2 new commits to 06auto: 02http://git.io/U8pxIg
[18:34:57] <ghrust> 13rust/06auto 149df25eb 15Brian Anderson: Remove the C++ runtime. Sayonara
[18:34:57] <ghrust> 13rust/06auto 142cc5c87 15bors: auto merge of #8387 : brson/rust/nooldrt, r=brson
[18:34:58] *** Parts: ghrust (ghrust@F6EE6DE3.6A2AE50.F3114085.IP) ()
[18:35:00] <Ms2gerbot> graydon, people with nothing better to do? :)
[18:35:10] <kermi> I think I remember the old Emacs-mode unindenting "}" automatically (like cc-mode). The new mode doesn't do that anymore, right? Do you guys just hit TAB for that?
[18:35:14] <toddaaro> graydon: but now that I look it looks like summ5 is set before this check, so it shouldn't be returning zero
[18:35:23] <graydon> toddaaro: so you should have 50 samples, winsorized by 5%
[18:35:27] <bblum> brson: by normal do you mean the case where the task isn't rescheduled on a different cpu, or the case where it is but isn't failing (i.e., might race in select() or whatever, but not in switch_running_tasks_and_then)?
[18:35:48] <graydon> toddaaro: if they're zero, something else is going wrong
[18:35:57] <toddaaro> graydon: bleh, I have to get to the bottom of this
[18:36:14] <toddaaro> graydon: nondeterministic segfaults in safe code + many 0ns returns
[18:36:15] <graydon> Ms2gerbot: i guess *shrug*
[18:36:37] <graydon> toddaaro: the benchmarker has a very small brain, it cannot do magic
[18:37:02] *** Quits: erickt (etryzelaar@8C9ECD8F.3A598286.F12515B4.IP) (Ping timeout)
[18:37:03] *** Quits: ozten (ozten@19BD73A1.5D8BCA3A.A0C1B52F.IP) (Quit: ozten)
[18:37:08] <cmr> Does it start doing magic before or after it gains sentience/
[18:37:09] <toddaaro> I'll try to minimize it out of this segfault
[18:37:14] *** Quits: mwcampbell (matt@moz-52DF570B.ks.ks.cox.net) (Quit: ircII EPIC5-1.1.2 -- Are we there yet?)
[18:37:58] *** Joins: ghrust (ghrust@DE823A67.6A2AE50.F3114085.IP)
[18:37:58] <ghrust> 01[13rust01] 15bors 04force-pushed 06auto from 142cc5c87 to 14a0080f4: 02http://git.io/N3iJvQ
[18:37:58] *** Parts: ghrust (ghrust@DE823A67.6A2AE50.F3114085.IP) ()
[18:37:58] *** Joins: ghrust (ghrust@C621748.6A2AE50.F3114085.IP)
[18:37:58] <ghrust> 01[13rust01] 15bors pushed 2 new commits to 06auto: 02http://git.io/mXulrQ
[18:37:58] <ghrust> 13rust/06auto 149df25eb 15Brian Anderson: Remove the C++ runtime. Sayonara
[18:37:58] <ghrust> 13rust/06auto 14cd70c0d 15bors: auto merge of #8387 : brson/rust/nooldrt, r=brson
[18:37:59] *** Parts: ghrust (ghrust@C621748.6A2AE50.F3114085.IP) ()
[18:38:19] *** Ms2gerbot is now known as Ms2ger
[18:39:12] <cmr> brson: did you interrupt my rollup?
[18:39:17] <brson> cmr: no
[18:39:23] <cmr> that's weird
[18:39:31] <cmr> bors is just listing all the builds as "exception"
[18:39:36] <cmr> https://github.com/mozilla/rust/pull/8385
[18:39:44] <bblum> you're just an exceptional guy, cmr
[18:39:51] <cmr> "no point in continuing"
[18:39:55] <cmr> Great, now bors has existential doubt
[18:40:06] <brson> cmr: buildbot shows a failure: http://buildbot.rust-lang.org/builders
[18:40:25] <brson> oh but that's the bot bors is supposed to be ignoring
[18:40:26] <graydon> brson: it seems there's a ~15-20% perf regression switching to newrt, in straight-line work. shall I dig in?
[18:40:39] <graydon> oh. it's not. hm. yeah. 
[18:40:44] <graydon> bors is ignoring it, buildbot's not.
[18:40:45] <graydon> ok
[18:40:47] <cmr> brson: it's also not listed in bors' "what failed" log
[18:40:49] <engla> SimonSapin: looks kind of useful, I added something similar for treemap (not merged yet)   https://github.com/mozilla/rust/pull/8354/files#L0R563
[18:40:49] <graydon> I'll pull it again, sorry.
[18:40:50] <cmr> ok
[18:40:54] <cmr> makes sense
[18:40:55] <brson> graydon: is there a test case you're looking at? that doesn't make a lot of sense
[18:41:05] *** Quits: huseby (huseby@19BD73A1.5D8BCA3A.A0C1B52F.IP) (Quit: Leaving)
[18:41:17] <graydon> brson: perf stat on rustc building libstd with/without RUST_OLDRT=1
[18:41:34] <engla> SimonSapin: by kind of useful, I mean that it's a better model than the one in my change
[18:41:37] <brson> ok. i'll look at it
[18:41:55] *** Quits: rust-buildbot (rust-build@505BFA3.C3CCCE8C.D25A875A.IP) (Quit: buildmaster reconfigured: bot disconnecting)
[18:41:55] *** Joins: rust-buildbot (rust-build@505BFA3.C3CCCE8C.D25A875A.IP)
[18:41:57] *** Quits: azita (Azita@moz-7E81A256.static.qsc.de) (Quit: azita)
[18:42:02] *** Quits: Yurume_ (yurume@AC58A8CE.8A059B47.E313B915.IP) (Ping timeout)
[18:42:18] <bblum> graydon: i noted your twitter discussion of TCO; did i mention that i had a design idea for making it feasible? this was a month or two ago
[18:42:21] <graydon> cmr: reconfigured buildbot; last few builds should be resubmitted :(
[18:42:35] <graydon> bblum: not sure.
[18:43:08] <graydon> bblum: what's the design idea?
[18:43:52] <bblum> graydon: do TCO only with the 'be' keyword, and then any function that uses 'be' will have some sort of attribute that makes sure it's always called with enough argument build area for any other function that it could possibly 'be'
[18:44:28] <bblum> (and of course require no destructors to be in scope)
[18:44:48] <strcat> we do have sibling call optimization already
[18:44:50] <cmr> `be` makes sense as a name there
[18:44:56] <cmr> repurpose the stack frame
[18:45:02] <cmr> make it be another function
[18:45:08] <strcat> afaik if we just allow people to append LLVM passes, they could stick -tailcallopt if they want to pay the price for it
[18:45:22] <graydon> we reserved 'be' for this. I think we should defer revisiting this until post-1.0 at least.
[18:45:25] <strcat> like clang's -mllvm
[18:45:55] <bblum> graydon: yeah, definitely; i just don't think the thousand paper cuts quite kill it yet :P
[18:46:47] *** Joins: jaen (jaen@moz-E0979827.copit.pl)
[18:46:49] <graydon> bblum: I believe the problem stems from that infecting other callees.
[18:46:56] *** Joins: ghrust (ghrust@FD7BC443.6A2AE50.F3114085.IP)
[18:46:57] <ghrust> 01[13rust01] 15bors 04force-pushed 06auto from 14cd70c0d to 14a0080f4: 02http://git.io/N3iJvQ
[18:46:57] *** Parts: ghrust (ghrust@FD7BC443.6A2AE50.F3114085.IP) ()
[18:46:57] *** Joins: ghrust (ghrust@F6EE6DE3.6A2AE50.F3114085.IP)
[18:46:57] <ghrust> 01[13rust01] 15bors pushed 29 new commits to 06auto: 02http://git.io/V-782g
[18:46:57] <ghrust> 13rust/06auto 14026c1ae 15blake2-ppc: extra: Remove all .each methods in smallintmap
[18:46:57] <ghrust> 13rust/06auto 1440bdbf0 15blake2-ppc: std: Fix for-range loops that can use iterators...
[18:46:58] <ghrust> 13rust/06auto 14e7d4a9c 15blake2-ppc: Bugfix .each_edge in middle/graph.rs...
[18:47:00] *** Parts: ghrust (ghrust@F6EE6DE3.6A2AE50.F3114085.IP) ()
[18:47:07] <bblum> graydon: how so?
[18:47:30] <graydon> that is, the calles that it could 'be' wind up having to be compiled with a different ABI, and that penalizes them when called non-be, and so we wind up having to multiply compile them or else make everything use the slower ABI
[18:48:03] <bblum> this would not require using the pascal ABI
[18:48:14] <graydon> why not? who pushes and pops?
[18:48:41] <bblum> caller cleans up argument build area
[18:48:47] <bblum> the caller will just know how much extra padding to add
[18:49:26] *** Quits: jaen (jaen@moz-E0979827.copit.pl) (Ping timeout)
[18:49:51] *** Quits: kermi (Mibbit@moz-D3D15A0C.vie.surfer.at) (Quit: http://www.mibbit.com ajax IRC Client)
[18:49:57] <bblum> e.g., fn main() { foo(5); } fn foo(x:int) -> int { be bar(x, x) } fn bar(x:int, y:int) -> int { x*y }
[18:49:58] <graydon> oh. so be-using-function gets called with, say, 20 extra dummy words worth of args pushed on its stack
[18:50:07] <bblum> right
[18:50:15] <bblum> main calls foo with 2 words of build area
[18:50:23] <cmr> This still needs a separate ABI
[18:50:30] <cmr> How do you have a function pointer to a be-function?
[18:50:51] <bblum> hmm, function pointer, good question
[18:50:52] <graydon> it becomes an attribute glued on to a function type. a modifier.
[18:50:53] *** Joins: echristo (echristo@DCF57675.D6CCE4AE.77834EAA.IP)
[18:51:03] <graydon> which we don't have on types in general, only items.
[18:51:14] <cmr> graydon: So now you need to pass around more than a pointer
[18:51:16] <graydon> this would be ok for items though. and just not exist for first class functions.
[18:51:22] <cmr> Yeah, sure
[18:51:31] <graydon> cmr: not if it's part of the type. but in any case, assume we just don't handle fn ptrs.
[18:51:48] <strcat> LLVM's tailcallopt doesn't seem to work cross-library anyway
[18:51:52] <bblum> forbidding being a function pointer is a decent option
[18:51:59] <strcat> 'On x86-64 when generating GOT/PIC code only module-local calls (visibility = hidden or protected) are supported.'
[18:52:04] <bblum> strcat: what seriously
[18:52:05] <graydon> (if it becomes part of the type it gets uglier but not impossibly so; there are always going to be limits such as, yeah, dynamic libraries)
[18:52:08] <graydon> bblum: yup
[18:52:11] *** Joins: lucian (lucian@moz-22A14C6A.cable.virginmedia.com)
[18:52:13] <bblum> whyyy
[18:52:13] <graydon> welcome to fun times
[18:52:22] <graydon> when I said papercuts, I meant paperuts
[18:52:24] <graydon> cuts
[18:52:30] <brson> bblum: i mean the non-failure message passing case that will be taken on most sends and receives. currently it's two atomics on send and two on recv
[18:52:38] <bblum> graydon: wow, i didn't realize :P
[18:52:40] <strcat> bblum: we could already have `be` for sibling calls - just to enforce that it will be optimized
[18:52:46] <strcat> since we already have that on
[18:52:49] <graydon> pursuing tail calls in this context is really chasing an increasingly marginal feature. that's why we gave up.
[18:52:56] <bblum> i see
[18:53:05] <graydon> it winds up like "one sort of goto-pattern", with a lot of machinery to support it
[18:53:19] <cmr> I don't think it's worth it
[18:53:21] <acrichto> cmr: your rollup changed llvm in https://github.com/cmr/rust/commit/35157669a3b6fb7af918a20a383c14900d2188c8
[18:53:24] <graydon> it also doesn't work on all platforms
[18:53:26] <acrichto> cmr: did you intend that?
[18:53:34] <cmr> acrichto: Yikes! I don't think so
[18:53:41] *** Quits: mschifer (Adium@moz-BBE3ABD.mv.mozilla.com) (Ping timeout)
[18:53:44] <strcat> yeah not on ARM afaict
[18:53:50] *** Quits: Jesin (Jessin_@moz-3AD6F09F.res.lehigh.edu) (Quit: Leaving)
[18:53:51] *** Quits: lucian (lucian@moz-22A14C6A.cable.virginmedia.com) (Ping timeout)
[18:53:55] *** Joins: mschifer (Adium@moz-BBE3ABD.mv.mozilla.com)
[18:53:56] <strcat> just x86/x86_64/PPC
[18:54:12] *** Joins: Sergio965 (sergiobz@moz-8D70E596.wireless.csail.mit.edu)
[18:54:21] <Sergio965> memcmp is provided by LLVM intrinsics, is that correct?
[18:54:25] <strcat> no
[18:54:28] <Sergio965> Boo.
[18:54:36] <strcat> only memcpy/memmove/memset
[18:54:44] <graydon> bblum: you're welcome to append yet more discussion (including all further papercuts noted in this conversation etc.) to issue https://github.com/mozilla/rust/issues/217
[18:54:45] <Sergio965> Ah, memcpy is.
[18:54:52] <strcat> and loop-idiom only knows how to optimize a loop to a) memcpy or b) memset
[18:55:01] <strcat> anything else will just have to rely on vectorizing
[18:55:05] <bblum> graydon: damn, a 3-digit issue number :P
[18:55:14] <graydon> bblum: I implemented tail calls in rustboot!
[18:55:16] <graydon> manually
[18:55:18] <graydon> worked fine, using 'be'
[18:55:23] <graydon> we had to remove them during bootstrapping
[18:55:25] *** Quits: jdm (jdm@19E8F2AF.B919BE8A.47C41102.IP) (Input/output error)
[18:55:41] <bblum> brson: i believe the second CPU need only do a cmpxchg in the case where the task is failing (same as with the spinning), at the price of the interface still being unsafe
[18:55:50] <graydon> (rustboot used very crude calling conventions and manual x86-only codegen)
[18:55:57] *** Joins: ghrust (ghrust@DE823A67.6A2AE50.F3114085.IP)
[18:55:57] <ghrust> 01[13rust01] 15bors 04force-pushed 06auto from 14e24003f to 14a0080f4: 02http://git.io/N3iJvQ
[18:55:57] *** Parts: ghrust (ghrust@DE823A67.6A2AE50.F3114085.IP) ()
[18:55:58] *** Joins: ghrust (ghrust@614D05BD.6A2AE50.F3114085.IP)
[18:55:58] <ghrust> 01[13rust01] 15bors pushed 5 new commits to 06auto: 02http://git.io/0r9ojg
[18:55:58] <ghrust> 13rust/06auto 14bd472d1 15Tim Chevalier: rustpkg: Eliminate a copy
[18:55:58] <ghrust> 13rust/06auto 142455f8e 15Tim Chevalier: Makefiles: make rustpkgtest depend on rustpkg executable
[18:55:58] <ghrust> 13rust/06auto 14c2d7bb5 15Tim Chevalier: std/rustc/rustpkg/syntax: Support the `extern mod = ...` form...
[18:56:00] *** Parts: ghrust (ghrust@614D05BD.6A2AE50.F3114085.IP) ()
[18:56:01] *** Joins: jdm (jdm@19E8F2AF.B919BE8A.47C41102.IP)
[18:56:42] <Sergio965> I've come to the conclusion that the only way to do things "right" in Rust is to use the actor-model.
[18:57:00] <cmr> Sergio965: for concurrency?
[18:57:02] <Sergio965> That way, a bunch of things can have an immutable pointer to an actor that has mutable pointer to its stuff.
[18:57:07] <Sergio965> For stat.
[18:57:10] <Sergio965> For state.*
[18:57:18] <bblum> brson: so the overhead would be an xchg on an uncontended (i think?) cacheline (compare to a boolean store on same)
[18:57:19] <Sergio965> I'm trying to figure out how to model global state in Rust.
[18:57:24] <Sergio965> Correctly.
[18:57:34] <Sergio965> Without resorting to static mut c: T = bla.
[18:57:46] <Sergio965> And then unsafe { c.bla() }.
[18:57:59] <bblum> Sergio965: have you looked at RWArc
[18:58:14] <Sergio965> Yeah, we were talking about it last time.
[18:58:21] <Sergio965> But I'm not sure it's the right solution.
[18:58:35] <Sergio965> It's a solution, and a good one at that, but I'm wondering if using actors is a better one.
[18:58:46] <cmr> Sergio965: do you have an example?
[18:58:51] <Sergio965> Of what?
[18:58:54] <Sergio965> How I'd use actors?
[18:59:09] *** Quits: jdm (jdm@19E8F2AF.B919BE8A.47C41102.IP) (Ping timeout)
[18:59:28] *** Joins: jdm (jdm@CADE9E91.A4FD32B6.47C41102.IP)
[18:59:42] *** Joins: jaen (jaen@moz-E0979827.copit.pl)
[18:59:54] *** Quits: brendan (brendaneic@moz-BBE3ABD.mv.mozilla.com) (Quit: brendan)
[19:00:08] <toddaaro> brson: I'm just not going to do this runtime benches via #[bench], even when I get it to produce a number and not just 0 the variance is through the roof
[19:00:44] <toddaaro> brson: at this timescale the stuff being benchmarked is not the primary source of runtime, need proper benches that run for multiple seconds
[19:00:54] <toddaaro> so I'll leave these in as "tests" not benches
[19:01:04] <Sergio965> So, right now, I have a "Console" struct that implements methods to log stuff. Initially, let c = Console::new() would return a new struct that you could call methods like c.log("bla") and such. But I needed everyone to be able to log to the same Console. So now, I have a: static mut c: Console = Console { } and a macro like cons_do(log, "this") and expends to unsafe { console.log("this") }.
[19:01:42] <bstrie> sounds unsafe :P
[19:02:14] <Sergio965> This is obviously a bad way to do it. It is racy, and using "unsafe" every time I call it really screams "NO!". I was thinking that with tasks, I could have a bunch of immutable references to the same task and then do something like task.log("bla"). The task, internally, would have a mutable reference to one Console which it could then call c.log("") on. I think this is the "right" approach. Thought?
[19:02:15] <toddaaro> brson: (there are also issues where a "spawn bench" wants to spawn as many tasks that do nothing as it can, but to know it is done the tasks have to include sending on a shared chan and the sender needs to receive N times, versus a long test where spawning just dominates the execution time and you rely on the runtime shutdown to know you spawned all the tasks)
[19:02:17] <Sergio965> Thoughts*
[19:03:05] *** Quits: jdm (jdm@CADE9E91.A4FD32B6.47C41102.IP) (Ping timeout)
[19:03:06] <bstrie> Sergio965: I like the idea of using tasks for this, where "log" just sends a message to a task queue
[19:03:07] <Sergio965> Or, you know, one static immutable (and thus, safe) reference to the task.
[19:03:29] <Sergio965> bstrie: Exactly.
[19:03:34] <bblum> you can't have 'references to tasks' in the mutable/immutable sense
[19:03:44] <bblum> you can have a SharedChan to the task
[19:03:59] <Sergio965> bblum: I haven't worked with tasks at all, so I'm not sure, but I read enough to know I can send it messages.
[19:04:04] *** Joins: jdm (jdm@9DACDBF6.FBD0B16C.47C41102.IP)
[19:04:08] <toddaaro> http://pastebin.mozilla.org/2811133
[19:04:21] <Sergio965> bblum: Can I have one global, immutable SharedChan?
[19:04:30] <toddaaro> ^ brson, graydon : the kind of numbers I get out when things are working
[19:04:31] <bblum> you can'th ave a global sharedchan
[19:04:34] <brson> toddaaro: ok. maybe you can put them in test/bench then? benchmarks as normal unit tests don't have much visibility
[19:04:35] <bblum> you have to pass it around and clone it
[19:04:56] <bblum> at which point you may as well have a RWArc handle that you pass around and clone
[19:05:05] <bblum> Sergio965: i thought about doing this with tasks in a general way as a library -- https://github.com/mozilla/rust/issues/3117 -- before i decided it was inferior to RWArc
[19:05:07] <toddaaro> brson: yea, that is my next question, where should I put these things? Certainly important to keep them in master so they don't rot, but they aren't "tests"
[19:05:08] <Sergio965> But cloning it destroys the point.
[19:05:10] <jedestep> sounds like you could use some AbstractLogFactoryBeans
[19:05:17] <bblum> Sergio965: what's the 'point'?
[19:05:26] <Sergio965> To have safe global state.
[19:05:34] <Sergio965> Cloning it creates multiple states.
[19:05:41] <graydon> toddaaro: so .. mostly-noise? :(
[19:05:50] <bstrie> Sergio965: why does it need to be mutable?
[19:05:51] <bblum> Sergio965: no, it creates multiple handles to the same state
[19:06:01] <toddaaro> graydon: yea, I think it is all the kernel scheduling noise
[19:06:05] <graydon> toddaaro: can I see the benchmark code?
[19:06:06] <Sergio965> bstrie: Why does what need to be mutable?
[19:06:13] *** Joins: Marc_ (chatzilla@moz-46C6E4A5.ipsat.francetelecom.net)
[19:06:16] <bstrie> Sergio965: the console
[19:06:17] *** Quits: jdm (jdm@9DACDBF6.FBD0B16C.47C41102.IP) (Ping timeout)
[19:06:17] <olsonjeffery> brson: so, yeah.. i don't know how to confirm the stack overflow thing..
[19:06:23] <Sergio965> bblum: Perhaps I'm misunderstanding. What are we "cloning"?
[19:06:24] <bstrie> Sergio965: it's not unsafe to access static things, just static mut things
[19:06:34] <olsonjeffery> does anyone have any idea about that? trying to see if rustc barfed, in gdb, because of a reversion/stack issue..
[19:06:42] <Sergio965> bstrie: It needs to be mutable because it has a reference to an array of messages (or this is the concept).
[19:06:43] <brson> graydon: ok, i can reproduce the regression. hopefully it's something simple
[19:06:47] <olsonjeffery> but i can't compare the stack points for the first and last frame (they're the same value)
[19:06:54] <olsonjeffery> i assume because the process has segfaulted..
[19:06:59] <olsonjeffery> or maybe im just not using gdb correctly?
[19:07:17] <olsonjeffery> recursion/stack issue, even
[19:07:18] *** Quits: nano (nano@moz-74CAD1CA.superkabel.de) (Connection reset by peer)
[19:07:20] <bblum> Sergio965: http://static.rust-lang.org/doc/extra/arc.html read "Method clone"
[19:07:20] <Sergio965> bstrie: And it keeps internal state, like a count of the number of times stuff has been logged.
[19:07:38] <Sergio965> Is "arc" not "automatic reference counting"?
[19:07:53] <bblum> it is
[19:07:56] <bstrie> Sergio965: no, "atomic"
[19:07:59] <bblum> oh
[19:08:02] <bstrie> it's a bad name
[19:08:03] <bstrie> bad bad
[19:08:06] <bblum> yes, atomic reference counting
[19:08:06] <bstrie> everyone gets it wrong :)
[19:08:09] *** Joins: jdm (jdm@AF7A0A7B.8829A0B.47C41102.IP)
[19:08:10] <Sergio965> Apple uses ARC.
[19:08:12] <Sergio965> :P
[19:08:14] <bstrie> we need to rename it to "AtomicRC"
[19:08:20] <Sergio965> Or just AtomRC.
[19:08:23] <bblum> i disagree
[19:08:26] <bblum> it's a fine name, it's just not an enlightening one
[19:08:27] <bstrie> maybe just "Atom"
[19:08:45] <kmc> an atom is definitely something else
[19:08:46] <Sergio965> But Apple use(s/d) ARC for Objective-C to mean Automatic Reference Counting. 
[19:08:52] <Sergio965> kmc: Haha, true.
[19:08:58] <brson> olsonjeffery: the two ideas i have are 1) valgrind - run with CFG_ENABLE_VALGRIND=1, 2) experimentally increase the constant in librustc/rustc.rs to something very high and see if the sagfault stops
[19:09:00] <kmc> the fact that it uses atomic instructions seems like an impl detail
[19:09:00] <sp3d> do we have non-atomic reference-counting?
[19:09:05] <strcat> sp3d: extra::rc
[19:09:07] <graydon> Rc<>
[19:09:10] <bstrie> bblum: everyone who's ever heard of "ARC" knows that it means "automatic reference counting". the current name is highly misleading. it's a landmine
[19:09:12] <sp3d> isn't that kinda unsafe?
[19:09:13] <toddaaro> graydon: http://pastebin.mozilla.org/2811145 I think this is exactly what it was, I didn't try compiling it though
[19:09:16] <strcat> sp3d: no
[19:09:16] <olsonjeffery> brson: okie dokie
[19:09:16] *** Joins: brendan (brendaneic@moz-BBE3ABD.mv.mozilla.com)
[19:09:18] <strcat> sp3d: it's not sendable
[19:09:18] <kmc> sp3d: they can't be sent between tasks
[19:09:21] <sp3d> oh
[19:09:24] <kmc> neither can @ boxes, which are also refcounted at the moment
[19:09:37] <kmc> rather than saying atomic vs. non-atomic maybe one should focus on the semantic level of shareable vs. per-task
[19:09:38] <graydon> toddaaro: "think"? is that the code you ran?
[19:09:46] <sp3d> maybe ARC could be SendRC, then
[19:09:47] <olsonjeffery> brson: do env vars work w/ gdb?
[19:09:54] <toddaaro> graydon: I've been editing a function, so that version is gone already
[19:10:00] <brson> olsonjeffery: also you can change to the bottom frame in gdb, and type `info frame`. there will be something printed there about `last frame pointer` or something
[19:10:02] <sp3d> explain in terms of features rather than implementation
[19:10:03] <brson> olsonjeffery: yeah, env vars work
[19:10:05] <olsonjeffery> like `CFG_BLAH=1 gdb --args foo`
[19:10:06] <toddaaro> vc doesn't do anything on this scale
[19:10:18] <Sergio965> bblum: Sorry, what am I supposed to glean from this?
[19:10:26] <Sergio965> bblum: The link you gave me.
[19:10:28] <kimundi> Hm... SendRc could work as a name?
[19:10:38] <bblum> Sergio965: the meaning of clone on a (RW)Arc handle
[19:10:43] <brson> olsonjeffery: yes, that should work
[19:10:53] <Sergio965> bblum: But I'd like to do it without using RWArc.
[19:10:53] <bstrie> kimundi: even just "SRC" would be better
[19:10:58] <bblum> Sergio965: why?
[19:11:03] <Sergio965> bblum: The only thing that would need to be atomic would be the message sending.
[19:11:06] <graydon> toddaaro: ok. why 3 times?
[19:11:08] <Sergio965> bblum: Because it's more elegant.
[19:11:12] <olsonjeffery> i guess valgrind needs to be enabled when running make though, heh
[19:11:21] <toddaaro> graydon: experimental, 10 produced 0ns
[19:11:23] *** Quits: tcr (tcr@D26BCFC9.C2203064.EDCE493E.IP) (Client exited)
[19:11:31] <Sergio965> bblum: It needn't even be synchronous.
[19:11:34] <graydon> why n at all?
[19:11:46] <bblum> Sergio965: what do you mean by 'synchronous'?
[19:11:50] <graydon> toddaaro: the b.iter { ... } thing is repeating the loop many times
[19:12:09] <graydon> (or .. potentially many. not if it's taking a really long time)
[19:12:14] <Sergio965> bblum: I mean, it need not be the case that a message sent to an actor gets handled immediately.
[19:12:20] <Sergio965> bblum: It can wait in a queue.
[19:12:27] <toddaaro> I suppose n=1 works, changes the definition of the test to a oneshot which is nice
[19:12:45] <toddaaro> but the test shouldn't be sending on anything, the spawn really really should be ||{}
[19:12:47] <bblum> Sergio965: ah, yes, then the SharedChan with a task approach is more advantageous
[19:13:11] *** Quits: BitPuffin (quassel@moz-8370D1B9.bredband.comhem.se) (Ping timeout)
[19:13:11] <Sergio965> bblum: Can we do this now? Is there something preventing me from doing what I proposed earlier?
[19:13:55] *** Quits: jdm (jdm@AF7A0A7B.8829A0B.47C41102.IP) (Input/output error)
[19:14:09] *** Quits: brendan (brendaneic@moz-BBE3ABD.mv.mozilla.com) (Quit: brendan)
[19:14:10] *** Joins: jdm (jdm@AF7A0A7B.8829A0B.47C41102.IP)
[19:14:24] <strcat> rusti: 2
[19:14:24] <bblum> Sergio965: well, you can't initialize message-passing primitives in global data locations
[19:14:24] -rusti- 2
[19:14:28] *** Joins: brendan (brendaneic@moz-BBE3ABD.mv.mozilla.com)
[19:15:11] <strcat> oh right we can rename Clone/DeepClone to Copy/DeepCopy now
[19:15:14] *** Joins: BitPuffin (quassel@moz-8370D1B9.bredband.comhem.se)
[19:15:17] <strcat> forgot I did a snapshot after that
[19:15:35] <Sergio965> bblum: Is there a reason for that?
[19:15:47] <Sergio965> (Besides being that way now.)
[19:15:58] <bblum> Sergio965: it requires allocation
[19:16:03] <Sergio965> I'm just trying to figure out how to do global state correctly.
[19:16:04] <cmr> Sergio965: they need a constant initializer, which isn't always possible
[19:16:04] *** Joins: tikue (tkuehn@moz-BBE3ABD.mv.mozilla.com)
[19:16:05] <bblum> also we don't have constexpr functions yet
[19:16:14] <cmr> What you can do is static mut foo: Option<YourThing> = None
[19:16:28] <Sergio965> cmr: Indeed. An interesting work around.
[19:16:28] <cmr> and then set it to Some(whatever) at startup
[19:16:37] <strcat> but the Option won't be locked
[19:16:39] *** Quits: jdm (jdm@AF7A0A7B.8829A0B.47C41102.IP) (Ping timeout)
[19:16:44] <Sergio965> What do you mean?
[19:16:45] <cmr> right
[19:16:49] <cmr> it's still just as unsafe
[19:17:01] <Sergio965> Ah, yes.
[19:17:07] <Sergio965> That's not good.
[19:17:11] <bblum> if you do it before you spawn any other tasks you're finen
[19:17:14] <bblum> *fine
[19:17:24] <Sergio965> I want an immutable, global reference (or multiple references to the same thing).
[19:17:26] <brson> graydon: how do i get perf to give me summary info about total runtime?
[19:17:38] <Sergio965> Where is the documentation for sharedChan?
[19:17:43] <graydon> brson: perf stat <command>
[19:18:00] <graydon> brson: if you want "where is it spending time", perf record <command> ; perf report
[19:18:20] <strcat> oh wow perf has cgroup support
[19:18:23] <strcat> never realized
[19:18:27] *** Joins: dim-an (ermolovd@moz-FE167E47.nationalcablenetworks.ru)
[19:18:37] *** Parts: dim-an (ermolovd@moz-FE167E47.nationalcablenetworks.ru) ()
[19:19:00] <bblum> given the name SharedChan i suspect SharedState would be the most appropriate replacement name for Arc
[19:19:12] *** Joins: dim-an (ermolovd@moz-FE167E47.nationalcablenetworks.ru)
[19:19:16] <Sergio965> Can I not do something like: static t: Task = TaskHandle(0)?
[19:19:21] <strcat> bblum: it would be nicer to keep the naming similar to Rc imo
[19:19:35] <Sergio965> (I haven't worked with Tasks.)
[19:19:38] <strcat> bblum: SharedRc, SendRc
[19:19:43] <ecr> There are no handles to tasks
[19:19:47] <Sergio965> I see.
[19:20:21] <Sergio965> I think this is a huge bump in the road for Rust. I don't know how Servo or RustC have dealt with lack of global, mutable state (or something that looks like it, like my proposal).
[19:20:25] *** Quits: jedestep (jedestep@34641662.FB4DE631.66C78B76.IP) (Ping timeout)
[19:20:40] <Sergio965> Have they just used unsafe?
[19:20:44] <cmr> rustc deals with it by passing contexts around.
[19:20:45] <bblum> no, we just don't need it
[19:20:47] <bblum> i suggest you get some experience programming with the task model
[19:20:50] <cmr> there's not really and global mutable state
[19:20:57] <cmr> *any
[19:21:00] <Sergio965> Yeah, I understand I can just pass state around.
[19:21:02] <cmr> I haven't personally needed it at all
[19:21:04] <Sergio965> But that's not fun.
[19:21:23] <tikue> Sergio965: it's a different paradigm than you might be used to, is all
[19:21:28] <Sergio965> tikue: What is?
[19:21:33] <Sergio965> tikue: How do I deal with it, though?
[19:21:57] <tikue> Sergio965: rust is designed to be a safe language, so it purposefully makes doing unsafe things more difficult. it's a design decision
[19:21:58] <toddaaro> what is the preferred way to measure how contended a lock is?
[19:22:13] *** Quits: igl (igl@moz-BB252A1B.adsl.alicedsl.de) (Ping timeout)
[19:22:40] <Sergio965> bblum: I've worked with Go routines extensively in the past. Are tasks not almost identical to Go routines?
[19:22:50] <bblum> tasks are analogous, yes
[19:22:55] <bblum> except go has global mutable state
[19:22:59] <bblum> (which is unsafe!)
[19:23:01] <kimundi> Sergio965: goroutines are unsafe though
[19:23:07] <Sergio965> Yeah, yeah. :P
[19:23:21] <cmr> toddaaro: drd and mutrace is what I've seen used
[19:23:51] *** Joins: igl (igl@moz-EE0266CC.adsl.alicedsl.de)
[19:24:08] *** Quits: Sergio965 (sergiobz@moz-8D70E596.wireless.csail.mit.edu) (Quit: My MacBook Pro has gone to sleep. ZZZzzz…)
[19:24:16] *** Joins: tcr (tcr@D26BCFC9.C2203064.EDCE493E.IP)
[19:25:01] <toddaaro> cmr: cool, I'll look into that, thanks
[19:25:15] <kimundi> would it be safe to put Chans in TLS?
[19:26:09] *** Quits: msingle (Thunderbir@moz-930E5D97.hr.hr.cox.net) (Ping timeout)
[19:26:17] <cmr> acrichto: How do I revert this change to LLVM?
[19:26:40] <toddaaro> cmr: yow, there is a lot of mutex stuff going on, one of these is locked 151306 times, is that sort of thing normal?
[19:26:44] <pcwalton> anyone know offhand how I get the ty::Generics for an impl given its def id?
[19:26:50] <cmr> toddaaro: no idea
[19:27:09] * pcwalton wonders if lookup_item_type works
[19:28:37] *** Joins: jedestep (jedestep@34641662.FB4DE631.66C78B76.IP)
[19:28:41] <toddaaro> cmr: ... does mutrace have a man page?
[19:28:57] <cmr> toddaaro: don't think so
[19:29:06] <cmr> it's an LD_PRELOAD library
[19:30:40] <strcat> lennart's site is always down ;p
[19:31:35] *** Joins: jensnockert (jensnocker@moz-61E1062F.tbcn.telia.com)
[19:32:27] <acrichto> cmr: reset 'HEAD^' and then don't add it back in
[19:33:00] <cmr> acrichto: how do I do that second part? :) I have no idea what I did to get that change in in the first place
[19:33:30] *** Quits: azakai (alon@moz-BBE3ABD.mv.mozilla.com) (Quit: Ex-Chat)
[19:33:37] *** Joins: azakai (alon@moz-BBE3ABD.mv.mozilla.com)
[19:33:57] <strcat> cmr: is it the last commit?
[19:33:58] <acrichto> cmr: if you're on the branch, if you run 'git reset 'HEAD^'' it should take you back one commit, then `git add` the files you want (not src/llvm) and commit
[19:34:47] *** Quits: victorporof (victorporo@B4B1C8EE.73B1E539.9B1E38F4.IP) (Quit: victorporof)
[19:34:59] *** Joins: ghrust (ghrust@CFE85B59.6A2AE50.F3114085.IP)
[19:34:59] <ghrust> 01[13rust01] 15bors 04force-pushed 06auto from 149c49943 to 14a0080f4: 02http://git.io/N3iJvQ
[19:34:59] *** Parts: ghrust (ghrust@CFE85B59.6A2AE50.F3114085.IP) ()
[19:35:01] *** Joins: ghrust (ghrust@AD60B2E3.6A2AE50.F3114085.IP)
[19:35:01] <ghrust> 01[13rust01] 15bors pushed 2 new commits to 06auto: 02http://git.io/aTtjJA
[19:35:01] <ghrust> 13rust/06auto 149df25eb 15Brian Anderson: Remove the C++ runtime. Sayonara
[19:35:01] <ghrust> 13rust/06auto 14e6184f2 15bors: auto merge of #8387 : brson/rust/nooldrt, r=brson
[19:35:01] *** Parts: ghrust (ghrust@AD60B2E3.6A2AE50.F3114085.IP) ()
[19:35:34] <cmr> acrichto: cool, didn't know submodules were updated using git add..
[19:36:02] <strcat> submodules are really a pain
[19:36:07] <brson> going to abort that build until this regression is fixed
[19:36:18] *** Joins: ghrust (ghrust@F6EE6DE3.6A2AE50.F3114085.IP)
[19:36:18] <ghrust> 01[13rust01] 15brson 04force-pushed 06auto from 14e6184f2 to 14a0080f4: 02http://git.io/N3iJvQ
[19:36:18] *** Parts: ghrust (ghrust@F6EE6DE3.6A2AE50.F3114085.IP) ()
[19:36:56] <acrichto> cmr: yeah that caught me more than once, if you run './configure' it should reset the submodule back to what it's expecting
[19:37:42] *** Joins: FrozenCow (FrozenCow@moz-B2DF4929.chello.nl)
[19:37:59] <strcat> acrichto: any luck tracking down the source of that LLVM assert yet?
[19:38:00] *** Joins: ghrust (ghrust@FD7BC443.6A2AE50.F3114085.IP)
[19:38:00] <ghrust> 01[13rust01] 15bors pushed 0 new commits to 06auto: 02http://git.io/_TGhxw
[19:38:00] *** Parts: ghrust (ghrust@FD7BC443.6A2AE50.F3114085.IP) ()
[19:38:00] *** Joins: ghrust (ghrust@79968228.6A2AE50.F3114085.IP)
[19:38:00] <ghrust> 01[13rust01] 15bors pushed 2 new commits to 06auto: 02http://git.io/C4wUmw
[19:38:00] <ghrust> 13rust/06auto 149df25eb 15Brian Anderson: Remove the C++ runtime. Sayonara
[19:38:00] <ghrust> 13rust/06auto 147b0df4e 15bors: auto merge of #8387 : brson/rust/nooldrt, r=brson
[19:38:01] *** Parts: ghrust (ghrust@79968228.6A2AE50.F3114085.IP) ()
[19:38:03] <nmatsakis> graydon: ping
[19:38:08] <graydon> nmatsakis: pong
[19:38:25] <acrichto> strcat: the one I commented out? didn't look much more into it, haven't seen any problems running with it though
[19:38:42] *** Quits: BizarreCake (BizarreCak@moz-361FE9B2.dynamic.barak-online.net) (Ping timeout)
[19:38:46] <strcat> doesn't mean anything though ;p
[19:38:54] <nmatsakis> graydon: do you know the macro code at least vaguely? looking for the right reviewer on https://github.com/mozilla/rust/pull/8394
[19:39:12] <brson> uh, stop it bors
[19:39:23] *** Joins: ghrust (ghrust@DE823A67.6A2AE50.F3114085.IP)
[19:39:23] <ghrust> 01[13rust01] 15brson 04force-pushed 06auto from 147b0df4e to 14a0080f4: 02http://git.io/N3iJvQ
[19:39:23] *** Parts: ghrust (ghrust@DE823A67.6A2AE50.F3114085.IP) ()
[19:39:29] <acrichto> strcat: yeah, I was trying to figure out why rusti tests fail in cross-arch situations but I'm not making much headway in that respect
[19:39:35] <strcat> brson: I think if you delete the r+ he'll just forget about it and move on
[19:39:43] <bblum> suppose I have a type struct Foo { data: T, next: Option<~T> }. Will the drop glue for this type use recursion to traverse the list, and possibly stack overflow if the list is too long?
[19:40:18] <strcat> bblum: yes
[19:40:19] <graydon> brson: bors confused?
[19:40:23] <strcat> bblum: it's an issue in C++ too
[19:40:26] <graydon> nmatsakis: that is closed
[19:40:42] <strcat> but clang outputs good IR for destructors so sibling call optimization would kick in
[19:40:46] <nmatsakis> graydon: uh, oops :)
[19:40:49] <strcat> it shouldn't be too hard to fix rust's
[19:40:51] <nmatsakis> graydon: re-opened now
[19:40:52] <brson> graydon: i was trying to convince him not to build my pull. i think it's straightened out
[19:40:57] *** Joins: ghrust (ghrust@E7A4CCE2.6A2AE50.F3114085.IP)
[19:40:58] <ghrust> 01[13rust01] 15bors pushed 0 new commits to 06auto: 02http://git.io/_TGhxw
[19:40:58] *** Parts: ghrust (ghrust@E7A4CCE2.6A2AE50.F3114085.IP) ()
[19:40:58] *** Joins: ghrust (ghrust@AD60B2E3.6A2AE50.F3114085.IP)
[19:40:59] <ghrust> 01[13rust01] 15bors pushed 2 new commits to 06auto: 02http://git.io/q5OjoQ
[19:40:59] <ghrust> 13rust/06auto 149df25eb 15Brian Anderson: Remove the C++ runtime. Sayonara
[19:40:59] <ghrust> 13rust/06auto 149f11018 15bors: auto merge of #8387 : brson/rust/nooldrt, r=brson
[19:40:59] *** Parts: ghrust (ghrust@AD60B2E3.6A2AE50.F3114085.IP) ()
[19:40:59] <strcat> I think there are a few casts it can't see through
[19:41:02] <brson> erp
[19:41:13] <nmatsakis> graydon: I had arbitrarily put pcwalton but then I remembered that maybe you read through the macro code with pauls at some point
[19:41:21] <graydon> brson: disabled
[19:41:27] <cmr> yours isn't next in the queue, why is bors retrying it?
[19:41:40] <brson> i just need it not to integrate that pr
[19:41:46] *** Quits: tjc (tjc@moz-BBE3ABD.mv.mozilla.com) (Quit: zzzzzzzzzz)
[19:41:48] <brson> i removed the r+s
[19:41:48] <strcat> brson: delete the r+
[19:41:50] <strcat> oh
[19:41:59] <strcat> brson: amend + force push maybe
[19:42:15] <brson> i'll close the pr
[19:42:16] *** Quits: Earnestly (earnest@3F74F9E2.8E6FE497.30311652.IP) (Quit: WeeChat 0.4.2-dev)
[19:42:42] <ecr> brson: I have a prototype HomedUvUdpSocket that can be created (via bind) and destroyed (which homes then closes). Tested and works in the single threaded case (so it's already home). Going to need to write a bunch of manual scheduling to set up the multi threaded case (and actually test homing).
[19:43:25] <engla> bblum: we found such a recursion case for extra::DList. On my machine it overflowed the stack at around 30M elements
[19:43:38] *** Joins: ozten (ozten@19BD73A1.5D8BCA3A.A0C1B52F.IP)
[19:43:57] *** Joins: tjc (tjc@moz-BBE3ABD.mv.mozilla.com)
[19:43:57] *** ChanServ sets mode: +o tjc
[19:44:00] *** Joins: ghrust (ghrust@5FEF1C87.6A2AE50.F3114085.IP)
[19:44:00] <ghrust> 01[13rust01] 15bors 04force-pushed 06auto from 149f11018 to 14a0080f4: 02http://git.io/N3iJvQ
[19:44:00] *** Parts: ghrust (ghrust@5FEF1C87.6A2AE50.F3114085.IP) ()
[19:44:01] <graydon> nmatsakis: this is to allow attributes _as_ arguments, right? do we currently (before this patch) support items-with-attributes-on-them as $item macro arguments?
[19:44:01] *** Joins: ghrust (ghrust@C621748.6A2AE50.F3114085.IP)
[19:44:01] <ghrust> 01[13rust01] 15bors pushed 29 new commits to 06auto: 02http://git.io/MROxaQ
[19:44:01] <ghrust> 13rust/06auto 14026c1ae 15blake2-ppc: extra: Remove all .each methods in smallintmap
[19:44:01] <ghrust> 13rust/06auto 1440bdbf0 15blake2-ppc: std: Fix for-range loops that can use iterators...
[19:44:01] <ghrust> 13rust/06auto 14e7d4a9c 15blake2-ppc: Bugfix .each_edge in middle/graph.rs...
[19:44:03] *** Parts: ghrust (ghrust@C621748.6A2AE50.F3114085.IP) ()
[19:44:23] <graydon> oops. I turned off the wrong crontab entry.
[19:44:25] <graydon> hope that's right!
[19:44:26] <pauls> graydon: we do not support that.
[19:44:31] <cmr> graydon: that PR is fine
[19:44:37] <brson> ecr: the easiest way to test is probably to create two schedulers and know that you are on the non-home is probably to use the TaskFromFriend message to send a task to non-home
[19:44:58] <brson> uh, that english wasn't quite right but all the words were there. maybe it makes sense
[19:44:59] <engla> cmr: hold out
[19:45:08] <cmr> engla: hm?
[19:45:11] <engla> cmr: hopefully it merges finally
[19:45:16] <graydon> pauls: hm. why not?
[19:45:16] <nmatsakis> graydon: pauls: in fact we do not support that, though there is really no good reason for that
[19:45:18] <cmr> what does "hold out" mean?
[19:45:40] <nmatsakis> graydon: pauls: we call parser.parse_item(~[]) where the argument is the list of attrs,
[19:45:50] <engla> cmr: um just some kind of "keep it up, even if the testsuite is against you"
[19:45:54] <toddaaro> brson: how do I compile things in test/bench?
[19:45:56] <nmatsakis> graydon: pauls: we'd just need to create a helper that parses some number of outer attrs and then calls parse_item(), basically
[19:46:04] <brson> toddaaro: make check-stage1-bench TESTNAME=foo
[19:46:07] <nmatsakis> graydon: pauls: iiuc
[19:46:09] <ecr> brson: that's what I was thinking.
[19:46:10] <graydon> mhm.
[19:46:11] <pauls> It's because the parser handles attributes in a funny fashion-- yeah, what nmatsakis said
[19:46:13] <toddaaro> brson: thanks
[19:46:34] <toddaaro> brson: can I put a subdir in test/bench without too much futzing with the makefile?
[19:46:40] <graydon> nmatsakis: that sounds like it'd be nice to support. but anyway it looks like your patch is ok.
[19:46:50] <nmatsakis> graydon: yes, probably worth opening a bug on it
[19:46:50] <graydon> nmatsakis: I'm a little surprised we have to differentiate inner and outer attributes as arguments.
[19:47:02] *** Joins: erickt (etryzelaar@8C9ECD8F.3A598286.F12515B4.IP)
[19:47:08] <nmatsakis> graydon: hmm well --- maybe we don't have to
[19:47:14] <bblum> do we have a standard cons-cell list in libstd?
[19:47:28] <strcat> bblum: no, there's one in libextra
[19:47:36] <bblum> a bad one
[19:47:43] <graydon> nmatsakis: I guess I would have expected $a:attr and writing it as $a; when appearing as an inner-attr
[19:47:43] <nmatsakis> graydon: I thought we did, and it's somewhat convenient to do so, but thinking now I think maybe we could paper over the difference
[19:47:49] *** Joins: huseby (huseby@19BD73A1.5D8BCA3A.A0C1B52F.IP)
[19:48:08] <nmatsakis> graydon: oh, I see, that would be interesting
[19:48:18] <graydon> I imagine it depends on the handling of INTERPOLATED
[19:48:42] *** Quits: orshem (orshem@C5E06B1E.A5B6B765.E3D28531.IP) (Quit: Leaving)
[19:49:03] <nmatsakis> I think this stuff would be somewhat easier if we expanded out INTERPOLATED tokens back into bytes and reparsed
[19:49:08] <nmatsakis> though admittedly less efficient
[19:49:15] <nmatsakis> but I guess I could make that work as you described
[19:49:25] <graydon> well, at least back to token trees
[19:49:31] <nmatsakis> I agree that distinguishing inner/outer is yucky
[19:49:34] <pauls> (in particular, it'd have bad big-O in the case of nested macros)
[19:49:48] <graydon> I believe the whole frontend would work better if the pp was tt-based and we had a function that unparsed ast -> tt
[19:49:55] *** Joins: Earnestly (earnest@3F74F9E2.8E6FE497.30311652.IP)
[19:49:57] <nmatsakis> yes, that makes sense
[19:50:02] <strcat> graydon: so, loop-deletion actually does work now with iterations - that's good
[19:50:09] <cmr> unparsing... that's a new one for me
[19:50:10] <strcat> need to look into vectorizing again
[19:50:11] <SimonSapin> r? https://github.com/mozilla/rust/pull/8396 peekable iterator adaptor
[19:50:18] <graydon> strcat: like a no-op loop gets elided?
[19:50:23] <strcat> graydon: yeah
[19:50:24] <cmr> SimonSapin: we already have one?
[19:50:25] <graydon> nice
[19:50:46] <cmr> SimonSapin: Oh, this is a different meaning of peek than the existing one
[19:50:53] <SimonSapin> yes
[19:50:53] <strcat> graydon: it's one of the loop passes, just trying to get our IR to match what they expect - they are picky
[19:50:54] <graydon> nmatsakis: anyway, r+ on the change as is or with $attr if you can make it work, whatever.
[19:51:34] <cmr> SimonSapin: Does peek returning None imply the iterator is exhausted, or that it can't see into the future anymore?
[19:51:46] <nmatsakis> graydon: ok, let me see if I can remove the distinction, it's yucky
[19:52:00] <graydon> nmatsakis: don't kill yourself over it, but yeah. might be nicer.
[19:52:08] <SimonSapin> cmr: peek() returns None when the underlying iterator is exhausted
[19:52:25] <Ms2ger> graydon, overall, I'd prefer he didn't kill himself over anything in rust :)
[19:52:33] <nmatsakis> graydon: brson: also, shouldn't we make the syntax #![foo] vs #[foo];?
[19:52:39] <cmr> SimonSapin: I don't think that's a good semantic to have.
[19:52:49] <SimonSapin> cmr: what do you mean?
[19:52:50] <nmatsakis> graydon brson: I keep being surprised that it is what it is, given that we have //!
[19:53:04] <cmr> SimonSapin: I would imagine peek() would return None if, for example, it would require reading more into a buffer or something.
[19:53:16] <cmr> But having a PeekableIterator that sometimes fails isn't very useful at all
[19:53:18] <cmr> so nevermind
[19:53:39] <SimonSapin> cmr: well, that entirely depends on the semantics of the underlying iterator
[19:53:39] *** Quits: ecr (Thunderbir@moz-BBE3ABD.mv.mozilla.com) (Ping timeout)
[19:53:51] <kimundi> nmatsakis: It really should get changed
[19:53:54] <cmr> SimonSapin: right
[19:53:56] <SimonSapin> cmr: PeekableIterator "buffers" at most one element itself
[19:54:22] <SimonSapin> cmr: my use case is an iterator of tokens in a parser
[19:54:24] <brson> nmatsakis: yes, I prefer that, or even `# foo` and `#! foo`
[19:54:31] *** Joins: wilmoore (wilmoore@moz-7EE4D9D6.mystrotv.com)
[19:54:43] <brson> nmatsakis: we have to decide how to cope with shebangs though
[19:54:45] <pcwalton> are we discussing attr syntax?
[19:54:51] <brson> yep
[19:54:52] <nmatsakis> brson: woah, #foo
[19:54:56] <pcwalton> I liked the proposal to use @
[19:54:58] <pcwalton> like java, scala
[19:55:00] <pcwalton> once it's free
[19:55:00] * graydon weeps
[19:55:17] <pcwalton> heh
[19:55:19] <pcwalton> so much bikeshedding
[19:55:22] <pcwalton> to be clear I don't care
[19:55:46] <graydon> I know. it's just amazing how many times we go around the topic.
[19:55:47] <graydon> um
[19:56:02] <bblum> strcat: this overflow drop glue thing... is there an issue for it
[19:56:10] * nmatsakis grumbles about how attr_style is a field on Attribute
[19:56:12] <strcat> bblum: don't think so
[19:56:22] <bstrie> pcwalton: I admit, wanting to reuse @ for attributes was one of my reasons for wanting to get rid of it for gc :P
[19:56:24] <strcat> graydon: although as soon as you throw in vectors it falls down ;[
[19:56:27] <strcat> I think from the bitcast
[19:56:31] <strcat> hm
[19:57:55] *** Quits: tjc (tjc@moz-BBE3ABD.mv.mozilla.com) (Quit: Places to go, people to annoy)
[19:58:00] <bstrie> I also love brson's idea of getting rid of the braces
[19:58:13] <bstrie> er, brackets
[19:58:33] <bstrie> though this might mean that we have to restrict the attribute grammar to `foo(bar)` rather than allowing `foo = bar`
[19:58:44] <cmr> why?
[19:58:53] <cmr> Hm, attributes are allowed to span multiple lines
[19:58:58] *** Quits: Uther (Instantbir@moz-1B244B05.hfc.dyn.abo.bbox.fr) (Quit: Instantbird 1.4 -- http://www.instantbird.com)
[19:59:25] <doomlord> # preprocessor, @ pointers ... this makes sense :)
[19:59:29] <bstrie> does `#[foo=bar]` actually set any kind of variable anywhere for use in other attributes?
[19:59:38] <cmr> bstrie: what do you mean?
[19:59:53] <bstrie> cmr: can I do `#[foo=bar]` and then later `#[cfg(foo)]` ?
[20:00:05] *** Quits: BitPuffin (quassel@moz-8370D1B9.bredband.comhem.se) (Ping timeout)
[20:00:17] <cmr> bstrie: no, that's not what cfg *or* foo=bar does
[20:00:39] <bstrie> cmr: what I'm asking is if the = in foo=bar actually has any intuitive significance
[20:00:44] <kimundi> bstrie: as far as I know, that just results in another kind of attribute-AST node
[20:00:56] *** Joins: BitPuffin (quassel@moz-8370D1B9.bredband.comhem.se)
[20:01:05] <kimundi> that is, like all attributes, it doesn'T do anything
[20:01:08] <bstrie> because otherwise I'd argue that the `foo=bar` form is superfluous in favor of `foo(bar)`
[20:01:18] <cmr> It's treated differently for doc
[20:01:21] <cmr> doc="..."
[20:01:23] <cmr> doc(hidden)
[20:01:26] <cmr> but both can be present
[20:01:29] <kimundi> justs sits there, waiting for other to parse it
[20:02:16] <bstrie> what symbols are allowed in attributes right now? can I do `#[foo@bar]` if I write a syntax extension that expects that form?
[20:02:27] <cmr> rusti: #[foo@bar] fn foo() {}
[20:02:27] -rusti- <anon>:5:14: 5:15 error: expected `]` but found `@`
[20:02:28] -rusti- <anon>:5          #[foo@bar] fn foo() {}
[20:02:28] -rusti-                        ^
[20:02:28] -rusti- application terminated with error code 101
[20:02:29] <bstrie> or otherwise use arbitrary symbols
[20:02:33] <pcwalton> no
[20:02:43] <pcwalton> they have to be of the meta_item syntax
[20:02:44] <toddaaro> what would cause something to run "native_flush_tlb_others" a lot?
[20:03:07] <pcwalton> context switches?
[20:03:11] <cmr> toddaaro: do you have something I can run locally?
[20:03:17] <pcwalton> presumably that's in the kernel
[20:03:31] <toddaaro> cmr: not quite yet, I need to clean up where I am and commit soon
[20:03:33] * pcwalton would be scared if rust's scheduler is involved with translation lookaside buffers
[20:03:49] <toddaaro> it is inside the kernel, but it looks like I'm spending a sizable fraction of execution time in there
[20:03:56] <pcwalton> context switches?
[20:04:29] <toddaaro> so that will be called every pthread context swap?
[20:04:50] <tiffany> is it possible to do dlopen/LoadLibrary run-time linking in rust?
[20:04:55] <cmr> tiffany: yes
[20:05:01] <cmr> tiffany: std::unstable::dynamic_lib
[20:05:10] <cmr> tiffany: (plus you can just call the native interfaces directly)
[20:05:23] <toddaaro> brson: the other thing that happens a lot in this "spawn really fast" test is quite a bit of time in pipe_write, do you know what we do that calls pipe_write so much? would that be idle callbacks?
[20:05:38] <cmr> tiffany: be warned that it's an unsafe interface, it doesn't do any typechecking on the symbol you pull out of the dynamic library
[20:05:38] <tiffany> cmr: so I could have a rust application load a rust library and have the runtime still work?
[20:05:47] <cmr> tiffany: that, I don't know
[20:06:01] <tiffany> rust's name manging enforces consistent type signatures though
[20:06:05] <cmr> no it doesn't
[20:06:08] <tiffany> oh?
[20:06:09] <cmr> Well, it does
[20:06:22] <cmr> but embedding a mangled name in your program isn't really feasible
[20:06:31] <cmr> and the mangled name includes an ID that changes over time afaik
[20:06:34] *** Joins: lkuper (lkuper@63686BC7.F689A8C9.EB438161.IP)
[20:06:41] *** Quits: lkuper (lkuper@63686BC7.F689A8C9.EB438161.IP) (Quit: lkuper)
[20:06:54] <tiffany> I'm mostly just wondering how much trouble I'd have with little things if I were to rewrite my game engine ni rust
[20:07:35] <cmr> The language and standard library are constantly moving
[20:08:20] *** Joins: lkuper (lkuper@63686BC7.F689A8C9.EB438161.IP)
[20:08:44] <strcat> iterators aren't going to change much ;p
[20:09:05] <tiffany> are there any plans to actually have a stable version of rust in the future?
[20:09:05] <engla> strcat, cmr I'm going to propose some changes to lexical ordering. Putting generic iterator-based functions in std::iterator::order::{lt,le,gt,ge,equal,cmp} that sequences can use, and using Eq + Ord for lexical order
[20:09:54] <engla> https://github.com/blake2-ppc/rust/compare/seq-ord  fixing ordering for tuples, vec and Option<T> to start with.
[20:09:56] <cmr> toddaaro: if you're spending most of your time in TLB flushes, the only way to fix that is to context switch less.
[20:10:14] *** Quits: jaen (jaen@moz-E0979827.copit.pl) (Ping timeout)
[20:10:45] <bblum> strcat: https://github.com/mozilla/rust/issues/8399
[20:11:00] <toddaaro> cmr: makes sense, this test is a "worst case" test for the scheduler right now so I'm probably just hammering a mutex with 8 threads for almost all the runtime
[20:13:06] <sebcrozet> tiffany: is your current game engine open source?
[20:15:14] <cmr> tiffany: of course
[20:15:18] <cmr> tiffany: it's not a research language
[20:15:19] *** Quits: eschweic (Adium@moz-BBE3ABD.mv.mozilla.com) (Quit: Leaving.)
[20:15:20] <bstrie> the new `for` loop is so pretty
[20:15:23] <cmr> tiffany: it's just early in development
[20:15:44] <bstrie> strcat: do you think `for x in foo.iter()` will get reduced to `for x in foo` by 0.8?
[20:15:47] *** Quits: KindOne (KindOne@moz-55C59F2E.dynamic.ip.windstream.net) (Ping timeout)
[20:16:02] <strcat> no
[20:16:19] <bstrie> are default methods just still unusable?
[20:16:35] <strcat> it can't be implemented in the library afaict
[20:16:44] *** Quits: reyre (reyre@B2D8AB09.33EE9F8A.1139E686.IP) (Quit: Konversation terminated!)
[20:16:49] <strcat> for loops would need to be a compiler feature, not a parser feature
[20:16:54] <strcat> with lang items on Iterator and Iterable
[20:16:57] <bstrie> ah I see
[20:17:19] <strcat> you need to be able to hand a for loop an &mut ref to an iterator and be able to break out and have the state
[20:17:20] *** Joins: jaen (jaen@moz-E0979827.copit.pl)
[20:17:25] <lkuper> brson, ecr, toddaaro, bblum: congrats on the new runtime.  amazing!
[20:17:46] <bstrie> strcat: is there a bug filed on making for loops no longer a parser hack?
[20:17:46] <bblum> lkuper: i accept a small fraction of the congrats :) thanks
[20:18:10] <bstrie> I too accept a small fraction of the congrats, despite the fact that I did nothing to deserve it nor did anyone offer any to me
[20:18:19] <strcat> bstrie: well I don't know if that's desired
[20:19:45] *** Quits: lkuper (lkuper@63686BC7.F689A8C9.EB438161.IP) (Quit: lkuper)
[20:19:46] <bstrie> well I desire `for x in foo`, so if moving them out of the parser is a prerequesite then I support that :)
[20:19:54] *** Joins: KindOne (KindOne@moz-AA7E0BE6.dynamic.ip.windstream.net)
[20:21:20] <cmr> toddaaro: http://blog.tsunanet.net/2010/11/how-long-does-it-take-to-make-context.html
[20:22:23] <bblum> brson: can I add a struct List<T> { Nil, Cons(T, ~List<T>) } stub library to libstd?
[20:22:36] <bblum> brson: cf https://github.com/mozilla/rust/issues/8397
[20:22:50] <bblum> i wish to use it to fix a bug about tombstoning
[20:22:58] <bblum> (so it will immediately have a user)
[20:23:07] *** Joins: adrema (adrema@1453496A.70C7F49.B68672D5.IP)
[20:23:57] <nmatsakis> graydon: so I think I have that `$a;` working, though it occurs to me that if we changed to #![foo], that wouldn't work anymore
[20:24:05] *** Joins: mib_leap (Mibbit@894D2C62.9F275360.C28326FD.IP)
[20:24:22] <nmatsakis> it'd be nice if we could remove the distinction. 
[20:24:53] <nmatsakis> e.g., mod foo #[attr1] { ... } instead of `mod foo { #[attr1]; }`, but I guess that doesn't work when `foo` is declared in `foo.rs`
[20:24:54] <mib_leap> what exactly does the 'ty_bare_fn' represent in the ast?
[20:25:03] <cmr> mib_leap: extern "ABI" fn
[20:25:52] <graydon> nmatsakis: yes. it's all about the "declaring attributes of the current file module" issue
[20:26:23] <bstrie> ty_evec is fixed-length vectors, right?
[20:26:28] *** Quits: olsonjeffery (pf@B8927AE1.CFEFA148.239A1A9E.IP) (Ping timeout)
[20:26:37] <nmatsakis> bstrie: I think it's all vectors, depending on the "vstore"
[20:26:43] *** Joins: eschweic (Adium@moz-BBE3ABD.mv.mozilla.com)
[20:26:43] <bstrie> ok
[20:26:43] <nmatsakis> unless I misremember
[20:26:49] <cmr> rustdoc_ng doesn't see ty_evec anywhere
[20:26:53] *** Quits: jensnockert (jensnocker@moz-61E1062F.tbcn.telia.com) (Input/output error)
[20:26:53] <cmr> so it's clearly unimportant ;p
[20:26:56] *** Joins: alisdair (textual@moz-FBF4138A.vc.shawcable.net)
[20:26:59] <bstrie> I thought maybe ty_dvec was for dynamic vecs, and that the "e" was because it came after "d" :P
[20:27:04] *** Joins: olsonjeffery (pf@B8927AE1.CFEFA148.239A1A9E.IP)
[20:27:07] <acrichto> cmr: I'm just causing you all sorts of problems on the rollup :(
[20:27:14] <mib_leap> cmr: in trans/base.rs, the function trans_external_path seems to have the call convention hardcoded as CCallConv. I'm not sure if it is right...
[20:27:49] <mib_leap> for ty_bare_fn that is
[20:28:15] <nmatsakis> mib_leap: I've got a big PR affecting many aspects of how extern fn calls are handled
[20:28:28] <cmr> acrichto: ugh rustdoc failures
[20:28:36] <nmatsakis> mib_leap: not sure about that particular question tho
[20:28:37] <Jesse> brson: will rust continue to use the C libuv?
[20:28:41] <acrichto> cmr: I think it's just dropping `priv` in a few spots
[20:28:56] *** Quits: maxli (maxli@13F2CEC5.7672369.D8E68FF6.IP) (Quit: Leaving.)
[20:28:58] <mib_leap> nmatsakis: does that mean we can finally use pointers to call into external c functions?
[20:29:00] *** Joins: ghrust (ghrust@DE823A67.6A2AE50.F3114085.IP)
[20:29:01] <ghrust> 01[13rust01] 15bors 04force-pushed 06auto from 149e6e0c4 to 14a0080f4: 02http://git.io/N3iJvQ
[20:29:01] *** Parts: ghrust (ghrust@DE823A67.6A2AE50.F3114085.IP) ()
[20:29:05] *** Joins: ghrust (ghrust@24260B07.6A2AE50.F3114085.IP)
[20:29:05] <ghrust> 01[13rust01] 15bors pushed 29 new commits to 06auto: 02http://git.io/C-AmDA
[20:29:05] <ghrust> 13rust/06auto 146011f83 15Erick Tryzelaar: std: minor cleanup
[20:29:05] <ghrust> 13rust/06auto 1408b6cb4 15Erick Tryzelaar: std: add str.to_c_str()
[20:29:05] <ghrust> 13rust/06auto 14fd293df 15Erick Tryzelaar: std: rewrite run::with_{argv,envp,dirp} to copy C strings
[20:29:05] *** Parts: ghrust (ghrust@24260B07.6A2AE50.F3114085.IP) ()
[20:29:26] <nmatsakis> mib_leap: yes, soon, annoyingly I'm currently somewhat blocked on this limitation of macros :), though I've about fixed that
[20:29:44] <nmatsakis> graydon brson pcwalton : which remind sme, what I've been doing with the extern "C" fn branch is as follows:
[20:29:48] *** Quits: olsonjeffery (pf@B8927AE1.CFEFA148.239A1A9E.IP) (Ping timeout)
[20:29:52] <bstrie> nmatsakis: are you no longer blocked on windows breakage? or was that a different issue
[20:29:56] <nmatsakis> bstrie: I fixed it
[20:29:59] <bstrie> hooray
[20:30:04] *** Quits: jaen (jaen@moz-E0979827.copit.pl) (Ping timeout)
[20:30:13] <nmatsakis> current plan is: when you call an extern "C" fn, nothing special happens in terms of stack switches,
[20:30:30] <nmatsakis> but there is a lint mode that warns you if you call such a fn outside of a fn not tagged as #[fixed_size_stack] or whatever it is called
[20:30:36] <nmatsakis> and I am writing a macro
[20:30:41] <mib_leap> nmatsakis: damn, I thought I had a weekend project...
[20:30:46] <nmatsakis> that you can use to declare an extern fn + rust wrapper
[20:30:54] <nmatsakis> which will have this attribute for you
[20:31:15] <nmatsakis> mib_leap: it seems like a simple problem, but it's not :)
[20:31:25] <nmatsakis> mib_leap: been working on this PR for months -- admittedly in starts and stops
[20:31:35] * nmatsakis sighs
[20:32:03] *** Joins: olsonjeffery (pf@B8927AE1.CFEFA148.239A1A9E.IP)
[20:32:05] <mib_leap> nmatsakis: any issues on windows that you might need help with?
[20:32:26] <cmr> mib_leap: there are a lot of other windows issues!
[20:32:33] *** Quits: erickt (etryzelaar@8C9ECD8F.3A598286.F12515B4.IP) (Ping timeout)
[20:32:48] <nmatsakis> mib_leap: not with that particular patch, at least not that I am aware of...
[20:32:50] <bstrie> bblum: were you one of the members of the rust icfp contest team last year?
[20:32:55] <bblum> bstrie: i was
[20:33:02] <bstrie> bblum: is there a repeat planned?
[20:33:03] <nmatsakis> mib_leap: but yes as cmr said :)
[20:33:08] <bblum> bstrie: ask jack 
[20:33:14] <bblum> bstrie: i am playing on a different team
[20:33:24] <graydon> brson: does RUST_THREADS=N do anything in newrt?
[20:33:29] <bstrie> jack: just curious to know if there's going to be a rust presence at the icfp contest this year
[20:33:42] <graydon> brson: or more concretely: is there anything I can do to make sure there are as few threads as possible running?
[20:33:47] <cmr> bstrie: I'm going to try
[20:34:00] <cmr> bstrie: At least, I entered, we'll see if I can actually complete the task ;P
[20:34:13] <bstrie> maybe bblum can force his team to use rust
[20:34:46] <bblum> bstrie: not likely
[20:35:00] *** Joins: victorporof (victorporo@B4B1C8EE.73B1E539.9B1E38F4.IP)
[20:35:14] <tiffany> [16:13] <sebcrozet> tiffany: is your current game engine open source?
[20:35:15] <tiffany> https://github.com/TheCodeLab/IntenseLogic
[20:35:19] <bstrie> maybe we can discreetly coerce bblum's team to use rust
[20:35:21] <bstrie> and all other teams
[20:35:53] <mib_leap> cmr, nmatsakis: could you suggest something that would take a couple of days to get done?
[20:35:55] <tiffany> cmr: do you think it's possible to ballpark how long it will be until rust is stable?
[20:36:45] <bstrie> tiffany: how stable do you mean?
[20:36:48] *** Quits: victorporof (victorporo@B4B1C8EE.73B1E539.9B1E38F4.IP) (Ping timeout)
[20:36:49] <cmr> mib_leap: run `make check`, fix failures. rinse and repeat
[20:37:02] <cmr> mib_leap: currently the full testsuite is never run on windows. fixing that would be nice.
[20:37:23] <bstrie> it's not that we *couldn't* run the full test suite on windows, it's just too slow to spawn processes
[20:37:25] <tiffany> bstrie: enough that I don't have to go through 20Kloc of code changing something every couple major versions
[20:37:26] <bstrie> so they all rot
[20:37:32] <cmr> bstrie: well we *can't* either
[20:37:37] <cmr> the testsuite is really broken on windows
[20:37:39] <nmatsakis> there are a number of things that don't work on windows
[20:37:40] <cmr> it's bounce immediately
[20:37:43] <nmatsakis> but a lot of them are very hard
[20:37:44] <cmr> task failure doesn't work, etc
[20:37:54] <nmatsakis> in particular handling unrolling
[20:38:01] <bstrie> cmr: right, but fixing up the test suite for windows won't necessarily help, because we still won't be able to run it regularly
[20:38:22] <nmatsakis> mib_leap: if you're looking for a windows specific task, I don't know...
[20:38:38] <cmr> mib_leap: https://github.com/mozilla/rust/issues/2807 is a nice easy one
[20:38:50] *** Joins: ghrust (ghrust@AD60B2E3.6A2AE50.F3114085.IP)
[20:38:50] <ghrust> 01[13rust01] 15bors 04force-pushed 06auto from 14cd56d44 to 14a0080f4: 02http://git.io/N3iJvQ
[20:38:50] *** Parts: ghrust (ghrust@AD60B2E3.6A2AE50.F3114085.IP) ()
[20:38:51] *** Joins: ghrust (ghrust@C621748.6A2AE50.F3114085.IP)
[20:38:51] <ghrust> 01[13rust01] 15bors pushed 4 new commits to 06auto: 02http://git.io/156DCw
[20:38:51] <ghrust> 13rust/06auto 14dda4959 15Michael Woerister: debuginfo: Implemented proper handling of lexical scopes and variable shadowing.
[20:38:51] <ghrust> 13rust/06auto 14db6f31a 15Michael Woerister: debuginfo: Add support for argument shadowing.
[20:38:51] <ghrust> 13rust/06auto 141811a21 15Michael Woerister: debuginfo: Add some tests for visibiliy scopes within closures.
[20:38:53] *** Parts: ghrust (ghrust@C621748.6A2AE50.F3114085.IP) ()
[20:39:03] *** Quits: eschweic (Adium@moz-BBE3ABD.mv.mozilla.com) (Quit: Leaving.)
[20:39:34] <bstrie> tiffany: keep an eye on the "backwards compatible" milestone then https://github.com/mozilla/rust/issues/milestones . as for a ballpark time estimate, I dunno. hopefully less than a year. ideally Q1 2014, maybe, but no commitments :)
[20:40:20] <cmr> bstrie: I seriously doubt that's going to happen, but I'd love to be proven wrong
[20:40:32] <strcat> it's not going to happen for the libraries
[20:40:36] <bstrie> cmr: I doubt that the libraries, yeah
[20:40:38] <mib_leap> cmr: seems interesting...i'll see what i can do... nmatsakis: linux is fine too...
[20:40:40] <strcat> certain libraries, sure
[20:40:42] <bstrie> but the language itself might make it
[20:40:53] <tiffany> I should probably start up some other projects so I can get myself more familiar with rust at least, my only project the past year has been that game engine
[20:41:04] *** Joins: jaen (jaen@moz-E0979827.copit.pl)
[20:41:26] <mib_leap> btw, how do you guys debug rustc?
[20:41:32] <cmr> mib_leap: very painfully
[20:42:00] <mib_leap> cmr: :)
[20:42:02] <cmr> mib_leap: debug logging, basically
[20:42:22] <strcat> depends what you're debugging
[20:43:02] <mib_leap> do i have to recompile all the stages for a online change in rustc?
[20:43:15] <cmr> mib_leap: only if you change codegen
[20:43:25] <bstrie> mib_leap: you can usually ctrl+c after stage0 compiles
[20:43:34] <cmr> otherwise you can run make check-stage1-foo
[20:43:40] <bstrie> or that :P
[20:43:51] <cmr> (with a NO_REBUILD=1 if it's purely a library change, with no compiler implications)
[20:43:57] <mib_leap> -foo?
[20:44:05] <cmr> -std, -extra, -rustc
[20:44:18] <mib_leap> ha, ok thanks everyone
[20:44:40] <pcwalton> https://www.evernote.com/shard/s2/sh/add2ab3a-47e1-48b6-b36b-907644a3029a/3d6a3cbd84548eaf22415f603fa076c1/deep/0/Servo.png so close
[20:44:43] *** Quits: alisdair (textual@moz-FBF4138A.vc.shawcable.net) (Quit: My MacBook Pro has gone to sleep. ZZZzzz…)
[20:44:53] <cmr> pcwalton: nice!
[20:44:58] <pcwalton> (missing: {ib} split between bang/whimper and line-height)
[20:44:59] <cmr> servo seems to be moving quite fast
[20:45:03] <pcwalton> boxes are all in the right place though
[20:45:03] <bstrie> almost to CSS1
[20:45:31] <Ms2ger> Yay, {ib}
[20:45:38] <bstrie> pcwalton: we should have a party when servo surpasses ie6 in standards conformance :)
[20:46:05] <cmr> heh, that'd be pretty cool to track
[20:46:06] <pcwalton> Ms2ger: yeah, we made an invalid frame tree in servo there
[20:46:18] <pcwalton> we should have a verifier that runs in debug mode that catches invalid frame trees
[20:46:19] <cmr> "which historical rendering engines has servo surpassed"
[20:46:21] <bstrie> and then another party once it surpasses firefox 1
[20:46:29] <Ms2ger> One for NN4?
[20:46:29] *** Joins: panzi (chatzilla@moz-B475CCDD.adsl.highway.telekom.at)
[20:46:30] <pcwalton> firefox didn't pass acid2 until, like, 3
[20:46:40] <pcwalton> apparently Gecko took a lot longer to pass acid1
[20:46:50] <pcwalton> but of course we have the benefit of hindsight, we went straight there
[20:46:54] *** Joins: Benvie_ (brandon@5FD20F9A.53D07D95.EFF8B7BF.IP)
[20:47:10] *** Quits: mark_edward_ (quassel@981AA104.E81F12CD.76F66111.IP) (Ping timeout)
[20:47:10] <Ms2ger> ☑ Doesn't support <layer>
[20:47:22] <Ms2ger> At least, I hope we can tick that
[20:47:30] <bstrie> I see that firefox passes acid3 now. did they take out the contentious tests, or did mozilla finally relent and implement them?
[20:47:38] <strcat> bstrie: took them out
[20:47:41] <pcwalton> bstrie: they took out svg fonts a while ago
[20:47:45] <bstrie> ok
[20:47:51] <pcwalton> I've never heard of <layer> so I'm pretty sure we don't implement it :)
[20:47:53] <ozten> I saw "Chris Morgan" mentioned in https://mail.mozilla.org/pipermail/rust-dev/2013-August/005158.html around a web server
[20:47:55] <Ms2ger> Kept enough crappy tests to weep about
[20:48:01] <ozten> github username? I'd like to follow the progress
[20:48:11] <pcwalton> we don't implement tables either, that's probably the first acid2 thing we need
[20:48:16] <pcwalton> since wikipedia uses tables all over the place
[20:48:26] <cmr> ozten: https://github.com/chris-morgan/rust-http
[20:48:27] *** Quits: Ms2ger (Ms2ger@35CC4A24.2B12F798.F15B0BB3.IP) (Quit: nn)
[20:48:47] <ozten> cmr: thanks! are you him?
[20:48:55] <cmr> ozten: no
[20:49:02] <ozten> coolio
[20:49:22] *** Quits: fabiand (fabiand@moz-B59858CA.adsl.alicedsl.de) (Ping timeout)
[20:49:26] <bstrie> I think we'll be able to actually maybe possibly evaluate a timeframe for backwards-compatibility once DST and gc-in-a-library lands
[20:49:38] <panzi> what is the recommended way to profile a rust application? I used perf and my slowest function is "solutions::anon::expr_fn_5890" how do I find out what lambda this is? I guess by converting it to one with a name?
[20:49:38] *** Joins: Sergio965 (sergiobz@moz-8D70E596.wireless.csail.mit.edu)
[20:49:39] <bstrie> assuming that other giant changes surface in the meantime
[20:49:44] <bstrie> *no other
[20:49:57] <panzi> (hope I'm not interrupting anything)
[20:50:04] <cmr> panzi: or use perf -g and compile with rustc -Z debug-info to get a stack trace
[20:50:16] <cmr> panzi: flame graphs (http://dtrace.org/blogs/brendan/2012/03/17/linux-kernel-performance-flame-graphs/) are super useful
[20:50:30] <cmr> sample: http://octayn.net/benches/perf_acpi_pm.svg
[20:50:31] <panzi> cmr: thanks
[20:52:00] *** Quits: Jesse (jruderman@moz-537BCF9.hsd1.ca.comcast.net) (Quit: Jesse)
[20:52:18] *** Joins: ecr (Thunderbir@moz-BBE3ABD.mv.mozilla.com)
[20:53:01] *** Joins: brendan_ (brendaneic@moz-BBE3ABD.mv.mozilla.com)
[20:53:11] *** Quits: brendan (brendaneic@moz-BBE3ABD.mv.mozilla.com) (Connection reset by peer)
[20:53:12] *** brendan_ is now known as brendan
[20:53:54] *** Quits: mib_leap (Mibbit@894D2C62.9F275360.C28326FD.IP) (Quit: http://www.mibbit.com ajax IRC Client)
[20:53:59] *** Quits: eevee (eevee@moz-58058235.evrt.wa.frontiernet.net) (Ping timeout)
[20:54:49] <cmr> bstrie: dunno, there's still a bunch of unresolved resolve and borrowck things I think.
[20:54:54] *** Joins: tjc (tjc@moz-BBE3ABD.mv.mozilla.com)
[20:54:54] *** ChanServ sets mode: +o tjc
[20:55:05] <cmr> bstrie: as in, milestone #1 things
[20:57:50] *** Joins: int3_ (int3_@moz-ABE52D50.hsd1.ca.comcast.net)
[20:58:15] *** Quits: bytbox (s@moz-DC83764A.washdc.fios.verizon.net) (Ping timeout)
[20:58:42] <acrichto> sully: you may be interested in issue 8401 and 8398 if you're dealing with trait-related things
[20:59:34] <sully> 8401, maybe
[20:59:41] <sully> a little afraid of region checking
[21:00:03] <tiffany> how do you convert a string to an int?
[21:00:36] <jedestep> use std::from_str
[21:00:43] <cmr> rusti: std::from_str::FromStr::from_str::<int>("42")
[21:00:44] -rusti- Some(42)
[21:01:19] <cmr> rusti: std::from_str::FromStr::from_str::<int>("4.2")
[21:01:20] <bstrie> rusti: let x: int = FromStr::from_str("42"); x
[21:01:21] -rusti- None
[21:01:21] -rusti- pastebinned 7 lines of output: http://sprunge.us/SbRD
[21:01:57] <bstrie> rusti: let x: int = FromStr::from_str("42").get(); x
[21:01:58] -rusti- pastebinned 7 lines of output: http://sprunge.us/DYDT
[21:02:22] <bstrie> rusti: let x: Option<int> = FromStr::from_str("42"); x
[21:02:22] -rusti- Some(42)
[21:02:35] *** Joins: eschweic (Adium@moz-BBE3ABD.mv.mozilla.com)
[21:02:43] *** Joins: robertknight (robertknig@moz-AB0E96D7.range86-162.btcentralplus.com)
[21:02:51] <bstrie> rusti: Some(42).get()
[21:02:51] -rusti- <anon>:5:9: 6:5 error: type `std::option::Option<<VI0>>` does not implement any method in scope named `get`
[21:02:51] -rusti- <anon>:5          Some(42).get()
[21:02:52] -rusti- <anon>:6     };
[21:02:52] -rusti- error: aborting due to previous error
[21:02:52] -rusti- application terminated with error code 101
[21:02:55] <bstrie> rusti: Some(42).take()
[21:02:56] -rusti- Some(42)
[21:03:04] <bstrie> rusti: Some(42i).get()
[21:03:05] -rusti- <anon>:5:9: 6:5 error: type `std::option::Option<int>` does not implement any method in scope named `get`
[21:03:05] -rusti- <anon>:5          Some(42i).get()
[21:03:05] -rusti- <anon>:6     };
[21:03:05] -rusti- error: aborting due to previous error
[21:03:05] <tiffany> so I had to use FromStr::from_str instead of just from_str
[21:03:05] -rusti- application terminated with error code 101
[21:03:17] <jedestep> rusti: Some(42).unwrap()
[21:03:18] -rusti- 42
[21:03:26] <bstrie> tiffany: yes, from_str is a static method, so you have to qualify it with a trait or type
[21:03:28] *** Joins: bytbox (s@moz-DC83764A.washdc.fios.verizon.net)
[21:03:31] <cmr> tiffany: correct. it's an associated function on a trait, so it needs to be namespaced by the trait.
[21:03:44] <bblum> would anybody complain if i added a struct List<T> { Nil, Cons(T, ~List<T>) } module to libstd?
[21:03:52] <bstrie> I like "unwrap" better than "get". good change
[21:04:00] <cmr> bstrie: .get cloned
[21:04:10] <cmr> unwrap consumes
[21:04:20] *** Joins: eevee (eevee@moz-58058235.evrt.wa.frontiernet.net)
[21:04:21] *** Joins: jgilbert (jgilbert@moz-BBE3ABD.mv.mozilla.com)
[21:04:43] <brson> graydon: RUST_THREADS is supported. RUST_THREADS=1 will mean there is one scheduler thread
[21:04:45] <bstrie> bblum: I dunno, "Cons" feels a little... lispy :)
[21:04:55] <jeaye> rusti: Some(42).get_ref()
[21:04:56] -rusti- pastebinned 15 lines of output: http://sprunge.us/OLiC
[21:04:57] <brson> Jesse: Rust will continue using C libuv
[21:05:04] *** Joins: victorporof (victorporo@B4B1C8EE.73B1E539.9B1E38F4.IP)
[21:05:20] <brson> toddaaro: pipe_write is probably async_cb for scheduler message sends
[21:05:58] <toddaaro> brson: k, so we are going to get a really nice perf improvement from getting rid of the duplicates
[21:06:00] <brson> bblum: put the list type in std::unstable please
[21:06:14] *** Joins: mark_edward_ (quassel@moz-57A72B6E.hsd1.in.comcast.net)
[21:06:16] <bblum> brson: why?
[21:06:31] <bblum> brson: i'm giving it a custom destructor so it doesn't stack overflow when it drops
[21:07:51] <brson> bblum: because I want to punt on whether we should have a list type in std and how it should be designed. Putting something in unstable is easy. Making something a supported interface requires consideration.
[21:08:05] <bblum> brson: alright
[21:09:23] <bblum> should i call it List or ConsList?
[21:09:38] *** Joins: alisdair (textual@moz-FBF4138A.vc.shawcable.net)
[21:10:40] *** Quits: tcr (tcr@D26BCFC9.C2203064.EDCE493E.IP) (Client exited)
[21:11:04] *** Quits: victorporof (victorporo@B4B1C8EE.73B1E539.9B1E38F4.IP) (Ping timeout)
[21:11:07] *** Joins: fabiand (fabiand@moz-B59858CA.adsl.alicedsl.de)
[21:11:23] *** Joins: mindginative (mindginati@moz-268511E5.dsl.dyn.ihug.co.nz)
[21:11:33] *** mindginative is now known as richard|s
[21:11:44] <graydon> brson: when I run the program under gdb and trap it mid-run, there are ... about 200 threads active?
[21:11:48] <graydon> (stdtest)
[21:12:04] <brson> graydon: that sounds plausible. there are a lot of scheduler tests
[21:12:13] <jeaye> hah
[21:12:30] <cmr> brson: are threads never killed / removed from the pool or something?
[21:13:00] <graydon> is there a way to run the test runner to _exclude_ tests with a given pattern?
[21:13:21] <brson> graydon: no
[21:13:25] <graydon> right
[21:13:48] *** Joins: erickt (etryzelaar@8C9ECD8F.3A598286.F12515B4.IP)
[21:14:16] <brson> cmr: threads are killed
[21:14:35] *** Joins: steven_is_false (user@C5B76363.1FF1EBF8.1ECA502.IP)
[21:15:13] <brson> the test runner runs 4 * the number of cores tests. the scheduler tests themselves create ncores * 2 threads per test. on mac every event loop also has a worker thread
[21:15:17] <brson> lots of threads
[21:15:35] <graydon> valgrind gets equally upset if I run it with RUST_THREADS=1 though
[21:15:40] <graydon> so it's not thread segments
[21:15:44] <tiffany> I'm pretty confused by this type error
[21:16:19] <brson> also, the scheduler tests create an extra thread in order to escape the running runtime
[21:16:28] <brson> in order to instantiate a new one
[21:17:04] <tiffany> http://paste.lymiahugs.com/tiffany/a0367b63e054380b63d596554ab3634c516dc762.txt
[21:17:17] <brson> oh, heh and that process actually creates 2 threads
[21:17:29] <brson> i'm thread crazy
[21:17:32] <cmr> tiffany: rust 0.7?
[21:17:34] <tiffany> it prints an error about a borrowed value not living long enough
[21:17:36] <tiffany> and yeah .7
[21:18:16] <cmr> rusti: for arg in os::args().iter() { printfln!(arg) }
[21:18:18] -rusti- pastebinned 11 lines of output: http://sprunge.us/ZARV
[21:18:24] <cmr> rusti: for arg in std::os::args().iter() { printfln!(arg) }
[21:18:25] -rusti- pastebinned 11 lines of output: http://sprunge.us/BDXD
[21:18:39] <cmr> tiffany: it's a bug in rvalue lifetimes
[21:18:43] <cmr> I think
[21:18:48] <cmr> this looks like that bug
[21:18:51] <tiffany> so I should install the git head?
[21:18:53] <strcat> not really a bug
[21:19:08] <strcat> just how it's defined right now
[21:19:10] <cmr> tiffany: anyway just stash the result of os::args() in a variable, should be fine
[21:19:16] <brson> graydon: I have some ideas about where this extra work is. the scheduler is really sloppy. still doing some profiling
[21:19:16] <tiffany> ah
[21:19:32] <cmr> tiffany: yes, you *should* insteall the git head, but not for this reason :p
[21:19:39] *** Joins: aatch (aatch@moz-B437F499.pocketrent.com)
[21:19:39] *** Quits: fabiand (fabiand@moz-B59858CA.adsl.alicedsl.de) (Quit: Verlassend)
[21:19:43] *** Quits: jaen (jaen@moz-E0979827.copit.pl) (Quit: WeeChat 0.4.1)
[21:19:55] <graydon> brson: cool, thanks
[21:20:05] <graydon> brson: I'm still poking at the mac valgrind
[21:20:19] <bblum> oh. a cons list won't help me here.
[21:20:26] <bblum> hmm. crap.
[21:20:45] *** Joins: Jesse (jruderman@moz-BBE3ABD.mv.mozilla.com)
[21:20:51] <strcat> bblum: what do you need?
[21:21:14] <bblum> a list that supports O(1) concatenate two lists together
[21:21:34] <bblum> or well, even an unordered set would be fine
[21:22:00] <toddaaro> can't you just hook two vectors together with a pointer?
[21:22:10] <toddaaro> there was a name for this you mentioned in the past
[21:22:12] <bblum> toddaaro: describe the type of such a structure
[21:22:12] *** Quits: mihneadb (mihneadb@E48845AB.3A9F9BD4.4C2245EF.IP) (Input/output error)
[21:22:21] <bblum> strcat: and also meets the requirement that consuming it or drop-glueing it doesn't stack overflow
[21:22:31] <toddaaro> bblum: just a list impelementation that slab allocates vectors instead of single-item nodes
[21:22:35] *** Joins: vodik (simon@moz-CBE4BB13.cable.teksavvy.com)
[21:22:47] *** Quits: Sergio965 (sergiobz@moz-8D70E596.wireless.csail.mit.edu) (Quit: My MacBook Pro has gone to sleep. ZZZzzz…)
[21:23:00] <bblum> toddaaro: and what happens when you want to concatenate two slabs together
[21:23:15] <graydon> brson: q: when you allocate one of these "4mb stacks" (or whatever) do you just call malloc?
[21:23:19] *** Joins: james4k (james@moz-E7990244.consolidated.net)
[21:23:24] <toddaaro> bblum: just mess with the front+back pointers as necessary, just like a linked listr
[21:23:29] <graydon> brson: and when you're done with it, do you just call free?
[21:23:51] <bblum> toddaaro: so really you're talking about a linked list
[21:24:04] <toddaaro> bblum: yea, but with the elements holding 256 elements or so instead
[21:24:07] <bblum> hmmm, maybe dlist is what i want here
[21:24:14] <bblum> toddaaro: why waste time with the 256 thing
[21:24:15] *** Quits: tjc (tjc@moz-BBE3ABD.mv.mozilla.com) (Quit: zzzzzzzzzz)
[21:24:35] <brson> graydon: they are Rust vectors
[21:24:38] <toddaaro> bblum: ?
[21:25:01] <graydon> brson: oh, where would I find that code?
[21:25:11] <graydon> rt::stack?
[21:25:25] <bblum> toddaaro: why does having vectors improve matters if you already have a solution for containing the vectors?
[21:25:40] <toddaaro> oh, yea it is a linked list of vectors
[21:25:56] <brson> graydon: rt::stack, yeah. 
[21:26:19] <graydon> brson: I see StackPool in there that .. seems to presently just malloc/free them, doesn't pool them, am I reading correctly?
[21:26:20] <brson> graydon: atm they are owned by Task until Task is destroyed
[21:26:25] <brson> that's right
[21:26:27] <graydon> ok
[21:26:34] <graydon> who owns StackPool?
[21:26:41] <brson> Scheduler
[21:26:51] <strcat> graydon: jemalloc caches allocations up to 4MiB in size btw, we probably won't need our own cache
[21:26:52] <brson> rt::sched
[21:26:59] <graydon> how many schedulers do we wind up with?
[21:27:09] <strcat> unless we wanted guard pages, then we'd have to cache ourselves
[21:27:10] <graydon> strcat: the problem here is that we're winding up with a lot of segments mapped
[21:27:22] <graydon> strcat: too many for valgrind's little mind to handle.
[21:27:26] <brson> graydon: under a normal test run we have ncores Schedulers. in stdtest we have very many
[21:27:30] <bblum> strcat: ok, so DList is what I want after all... but it's in extra
[21:27:58] <graydon> strcat: https://gist.github.com/graydon/56bfdd886df0267dad06 for example
[21:28:02] <graydon> (that goes on for several pages)
[21:28:03] *** Quits: alisdair (textual@moz-FBF4138A.vc.shawcable.net) (Quit: My MacBook Pro has gone to sleep. ZZZzzz…)
[21:28:21] <graydon> quite plausibly >2000 segments, which is valgrind's limit
[21:28:34] <graydon> so I think we're probably making a new segment for each new task
[21:28:43] <graydon> and somehow malloc's not recycling them
[21:28:51] <cmr> they're all adjacent
[21:28:54] <graydon> (this is OSX -- are we using jemalloc there?)
[21:28:56] <cmr> why wouldn't they be merged?
[21:28:59] <strcat> graydon: jemalloc is off atm
[21:29:00] <brson> jemalloc is off
[21:29:01] <cmr> oh different permissions
[21:29:08] <brson> i think we should turn it on now
[21:29:15] <brson> 'now' meaning while segmented stacks are off
[21:29:21] <graydon> heh
[21:29:27] <graydon> plausible strategy!
[21:29:40] <brson> this is similar to the problem with stdtest opening too many fds
[21:29:54] <graydon> I expect so
[21:29:59] <graydon> well
[21:30:01] <brson> stdtest is really demanding
[21:30:11] <graydon> no, I expect in this case it's also a matter of us doing something pretty unreasonable
[21:30:19] <graydon> it's not clear to me that those segments are going to be demand paged
[21:30:27] *** Quits: nyx114 (nyx114@337D90A6.170C4318.709ED47B.IP) (Quit: WeeChat 0.4.0)
[21:30:30] <graydon> or lazily committed or whatever
[21:30:44] <brson> i didn't think os x did that at all
[21:31:12] <brson> not that i've actually investigated, just been told
[21:31:26] <toddaaro> brson: so looking at bare-metal performance things are even better than I thought
[21:31:40] <toddaaro> brson: on an i7 930 we can do 32m messages in 23s
[21:32:00] <brson> toddaaro: how does that compare to something else?
[21:32:05] *** Joins: ghrust (ghrust@5FEF1C87.6A2AE50.F3114085.IP)
[21:32:05] <ghrust> 01[13rust01] 15bors pushed 30 new commits to 06auto: 02http://git.io/HhHjfQ
[21:32:05] <ghrust> 13rust/06auto 14026c1ae 15blake2-ppc: extra: Remove all .each methods in smallintmap
[21:32:05] <ghrust> 13rust/06auto 1440bdbf0 15blake2-ppc: std: Fix for-range loops that can use iterators...
[21:32:06] <ghrust> 13rust/06auto 14e7d4a9c 15blake2-ppc: Bugfix .each_edge in middle/graph.rs...
[21:32:08] *** Parts: ghrust (ghrust@5FEF1C87.6A2AE50.F3114085.IP) ()
[21:32:08] <toddaaro> brson: major bottlenecks are malloc/free, and unfortunately, the rtdebug macro
[21:32:19] <brson> toddaaro: malloc free coming from the extra idle callbacks?
[21:32:25] <cmr> (how does it compare to the oldrt?)
[21:32:28] <toddaaro> brson: very possibly
[21:32:35] <toddaaro> cmr: this is something I need to start testing
[21:32:45] <brson> i suspect the idle callbacks are part of this regression in rustc perf too
[21:32:56] <strcat> brson: if we implemented segmented stacks as a minimum 8K size (guard page), C code could grow the stack - as long as it doesn't allocate >4K in one stack frame
[21:33:02] <toddaaro> brson: but also rtdebug, I couldn't get the macro to work doing the let _ stuff, so it currently does the formatting on strings even when disabled
[21:33:13] <strcat> brson: I suspect jemalloc recurses into a recursive data structure
[21:33:14] <brson> toddaaro: ah!
[21:33:15] <toddaaro> brson: so if we stamp that out maybe another 15-20%
[21:33:52] <cmr> toddaaro: brson: 1. what is special about rtdebug! compared to debug!, 2. can it hinge off of #[cfg(debug)] or maybe #[cfg(rtdebug)] like debug! does?
[21:34:45] <strcat> well and that also assumes that a single thread would be tracking all the tasks and I don't think that's true
[21:34:50] <strcat> stupid signals ;p
[21:34:57] <toddaaro> cmr: I'm not actually sure, it might be a holdover from the weird time where we had both runtimes and this one was specialized for newrt. The code is in libstd/macros.rs, it is really simple.
[21:35:00] <brson> cmr: rtdebug! doesn't hit the GC
[21:35:08] <cmr> brson: neither does debug! ?
[21:35:27] <brson> it did last time I used it. maybe it's been fixed
[21:37:10] <Jesse> brson: Marc_ talked at black hat about how C and hardware memory models surprise developers who are writing unsafe code. https://media.blackhat.com/us-13/us-13-Blanchou-Shattering-Illusions-in-Lock-Free-Worlds.pdf
[21:38:33] <toddaaro> brson: so looking up the akka numbers they do 50m/s on 50 cores, so 1m messages per second per core. We do about 180k, but they are also futzing with the throughput so they only reschedule every 5-20 sends, we are likely doing so more often
[21:38:36] <Jesse> brson: i imagine unsafe rust code has similar issues, where things will go slow and/or wrong if the programmer's mental model doesn't match the compiler's memory model.
[21:39:04] <toddaaro> brson: this is ignoring hardware differences, but I think that favors them a bit as I'm using a ~3 year old cpu
[21:39:23] *** Joins: jviereck (Adium@moz-A034D4DA.dclient.hispeed.ch)
[21:39:28] <brson> toddaaro: sounds promising!
[21:39:49] <toddaaro> brson: yea, especially given how wonderfully low-hanging the next three fruits are
[21:40:02] <strcat> Jesse: rust is still a lot more lenient than C when it comes to things like pointers in unsafe code because it does a poor job optimizing
[21:40:17] <graydon> brson: if I simply recycle the stacks inside a StackPool, it should buy us some breathing room; assuming not _every_ stdtest test makes zillions of schedulers, yes?
[21:40:21] <graydon> (which ones do?)
[21:40:25] *** Quits: spider-mario (spidermari@moz-81131DB6.fbx.proxad.net) (Input/output error)
[21:40:39] <strcat> raw pointers act more like plain old addresses than C pointers, but not quite, and I think the difference from C will go away
[21:40:42] <brson> Jesse: yes, Rust does have the same problems. thanks for the slides. I always like reading about these issues
[21:40:43] <Jesse> strcat: meaning it could change to become less lenient at any moment? ;)
[21:40:56] *** Joins: tcr (tcr@D26BCFC9.C2203064.EDCE493E.IP)
[21:40:56] <strcat> Jesse: yes.
[21:41:03] *** Quits: robertknight (robertknig@moz-AB0E96D7.range86-162.btcentralplus.com) (Ping timeout)
[21:41:10] <strcat> solution: write safe code
[21:41:45] <ecr> strcat: +1
[21:41:46] *** Quits: jviereck (Adium@moz-A034D4DA.dclient.hispeed.ch) (Quit: Leaving.)
[21:41:48] <Jesse> does the Rust team get to decide what the memory model is for unsafe, lock-free code? or is it all up to LLVM?
[21:41:57] <brson> Jesse: it's the same as C++
[21:42:03] <brson> C++11
[21:42:17] <brson> but yeah, up to llvm
[21:42:55] <strcat> pointers themselves have a model specific to LLVM - they don't correspond to actual addresses
[21:43:09] <strcat> for example
[21:43:12] <brson> graydon: I'm not sure. Why would holding onto these allocations instead of handing them back to malloc help? malloc is doing something wrong?
[21:43:18] <aatch> Jesse, I like those slides. Though I did actually know most of it.
[21:43:41] <strcat> lets say you have a pointer to some object x
[21:43:48] <strcat> you read the address to a uint, it's 13243214
[21:44:02] <strcat> you offset another pointer to that address and deref it - undefined behaviour
[21:44:40] <strcat> in fact in C, it's undefined behaviour *before* you deref it (not in rust, atm)
[21:44:45] <graydon> brson: my guess is that malloc is not recycling them because they're big and it might be treating big allocations specially. pure speculation.
[21:45:12] <aatch> The gist of lock-free programming seems to be "act as if any data can be modified at any time"
[21:45:22] <strcat> malloc falls through to mmap/munmap for large allocations
[21:45:34] <strcat> but I don't really think that should leak
[21:45:38] <Jesse> strcat: does that mean any use of transmute on things that contain pointers is unsound?
[21:45:45] <toddaaro> brson: updated my PR, should be pretty solid this time
[21:45:48] <strcat> Jesse: don't know what you mean by that
[21:45:54] <strcat> transmute is marked unsafe, and can do many unsound things
[21:46:06] <toddaaro> brson: the main complaint I have is that it should probably have the 3 benchmark programs as a separate commit
[21:46:06] <strcat> you really don't want to use transmute
[21:46:34] *** Quits: tcr (tcr@D26BCFC9.C2203064.EDCE493E.IP) (Connection reset by peer)
[21:46:34] *** Joins: tcr_ (tcr@D26BCFC9.C2203064.EDCE493E.IP)
[21:46:43] <Jesse> strcat: there's some transmute in str and vec. does LLVM consider it undefined behavior just because you've transmuted one pointer into another pointer?
[21:46:52] <strcat> no
[21:47:23] <brson> graydon: i'm not sure how many test cases will be impacted by keeping the segments cached. most tests just created a specific number of tasks for a specific task. the StackPool will only have effect when there are many tasks created that have non-overlapping lifetimes. surely there are some of those, but I don't know how many
[21:47:35] <strcat> llvm has a memory model for pointers based on memory dependencies - it doesn't consider types
[21:47:54] <strcat> clang implements type-based alias analysis on top of LLVM's memory model, implementing restrictions based on types
[21:48:03] <strcat> we should do that too, but we don't for now
[21:48:15] <strcat> (and unlike C, rust can enforce full safety of that model)
[21:48:22] <aatch> We could have awesome alias analysis
[21:48:41] <strcat> LLVM's model is based on pointers being "based" on each other
[21:49:19] <strcat> a null pointer isn't based on anything, so deref of an offset from null is always undef
[21:49:33] *** Joins: gavinb (gavinb@7F15F409.83AB59D0.3BB1CE94.IP)
[21:49:36] <strcat> a pointer to an object is based on it, you can offset/deref anywhere inside that object
[21:49:39] <aatch> I.E, `~` never aliases with anything (as far as LLVM cares, it can alias with &/&mut, but you can't write through it at that point)
[21:49:53] *** Quits: vodik (simon@moz-CBE4BB13.cable.teksavvy.com) (Ping timeout)
[21:50:08] <graydon> brson: I'm thinking the main set of stdtests. like little tests in vec or such. they all become their own tasks.
[21:50:10] *** Joins: dbaupp (Thunderbir@moz-712A1135.lns20.syd6.internode.on.net)
[21:50:18] <graydon> brson: most of them are nothing to do with schedulers.
[21:50:27] <graydon> uint tests, str tests
[21:50:33] <brson> graydon: oh, yeah right, duh. forgot that the new scheduler is actually being used to run all tests now
[21:50:35] <strcat> ptr::offset uses GEP rather than InBoundsGEP so it has fewer restrictions than pointer arithmetic in C
[21:50:43] <strcat> *but* the same restrictions apply to dereferences
[21:50:43] <graydon> brson: :))
[21:51:31] *** Quits: heftig (heftig@moz-D2368502.dip0.t-ipconnect.de) (Ping timeout)
[21:53:55] *** Quits: eatkinson (eatkinson@moz-BBE3ABD.mv.mozilla.com) (Quit: eatkinson)
[21:55:02] *** Joins: reyre (reyre@moz-9002CDDA.cpe.net.cable.rogers.com)
[21:55:27] *** Joins: heftig (heftig@moz-CB9CAA22.dip0.t-ipconnect.de)
[21:55:54] *** Joins: eatkinson (eatkinson@moz-BBE3ABD.mv.mozilla.com)
[21:58:58] *** Quits: jedestep (jedestep@34641662.FB4DE631.66C78B76.IP) (Ping timeout)
[22:00:20] *** Joins: tjc (tjc@moz-BBE3ABD.mv.mozilla.com)
[22:00:20] *** ChanServ sets mode: +o tjc
[22:05:16] *** Quits: bytbox (s@moz-DC83764A.washdc.fios.verizon.net) (Ping timeout)
[22:05:24] <gavinb> Is std::unstable::intrinsics ok to use in an libextra module? I need to do some little/big endian copies into vecs and that sort of thing.
[22:05:35] *** Joins: bytbox (s@moz-DC83764A.washdc.fios.verizon.net)
[22:05:42] <brson> gavinb: yes
[22:05:54] <gavinb> cool, thanks
[22:06:09] <brson> there may be helpers for that kind of thing somewhere, but idk where
[22:06:18] <strcat> they're actually in that intrinsics module
[22:06:39] <strcat> we should probably have endian.rs in libstd instead
[22:06:47] <strcat> with safe wrappers
[22:07:51] <strcat> rusti: let x = true; x + x
[22:07:52] -rusti- <anon>:5:23: 5:28 error: binary operation + cannot be applied to type `bool`
[22:07:52] -rusti- <anon>:5          let x = true; x + x
[22:07:52] -rusti-                                 ^~~~~
[22:07:52] -rusti- error: aborting due to previous error
[22:07:52] -rusti- application terminated with error code 101
[22:09:35] *** Joins: victorporof (victorporo@B4B1C8EE.73B1E539.9B1E38F4.IP)
[22:10:40] *** Joins: rustyPipe (Mibbit@moz-5949C51B.dllstx.fios.verizon.net)
[22:11:32] <tikue> strcat: is iter().filter(pred).next() === iter().find_(pred)
[22:11:36] *** Quits: victorporof (victorporo@B4B1C8EE.73B1E539.9B1E38F4.IP) (Ping timeout)
[22:12:02] <strcat> yes
[22:12:09] <strcat> you could also write it in terms of skip_while 
[22:12:32] <tikue> ok thank you :)
[22:12:54] <rustyPipe> In order to build the latest version of the rust compiler from source, do we have to do anything if there is already a previous install of it?
[22:13:18] <brson> rustyPipe: I'd run `make uninstall` first
[22:13:18] <cmr> rustyPipe: yes
[22:13:31] <rustyPipe> From which path?
[22:13:42] <cmr> same you build from
[22:13:57] <brson> i guess i'm probably not the right one to comment since i don't install
[22:14:10] <brson> maybe 'make uninstall' deletes everything
[22:14:57] <rustyPipe> I'm going to try it right now and see what happens
[22:15:08] <Luqman> i always forget to do that before pulling and then later have to manually remove libs with a changed hash 
[22:15:17] <tiffany> is there any way to put dynamic values into a range, such as a match statement with a pattern for if a number falls within the size of a vector?
[22:15:29] <tiffany> or can you only match constants
[22:15:40] *** Quits: tchoma (tchoma@moz-BE33DA21.fw1.sfo1.mozilla.net) (Quit: tchoma)
[22:15:47] <tjc> tiffany: that sounds like a case in which to use a pattern guard, to me
[22:15:53] <cmr> rusti: let x = 5; match x { y if y < 10 { 42 }, y { y } }
[22:15:53] -rusti- <anon>:5:42: 5:43 error: expected `=>` but found `{`
[22:15:54] -rusti- <anon>:5          let x = 5; match x { y if y < 10 { 42 }, y { y } }
[22:15:54] -rusti-                                                    ^
[22:15:54] -rusti- application terminated with error code 101
[22:16:00] <cmr> rusti: let x = 5; match x { y if y < 10 => { 42 }, y => { y } }
[22:16:02] -rusti- 42
[22:16:14] <tiffany> ah
[22:16:29] <cmr> rusti: let x = 5; let n = 10; match x { y@0..n => { 42 }, y => { y } }
[22:16:30] -rusti- <anon>:5:44: 5:51 error: Non-constant path in constant expr
[22:16:30] -rusti- <anon>:5          let x = 5; let n = 10; match x { y@0..n => { 42 }, y => { y } }
[22:16:31] -rusti-                                                      ^~~~~~~
[22:16:31] -rusti- application terminated with error code 101
[22:16:34] <cmr> aw that's no fun
[22:16:44] *** Joins: maxli (maxli@B5559308.9C54E60.2FA4EA88.IP)
[22:16:45] <cmr> rusti: let x = 5; let n = 10; match x { y@0..10 => { 42 }, y => { y } }
[22:16:47] -rusti- pastebinned 7 lines of output: http://sprunge.us/cUcb
[22:17:54] <rustyPipe> After running make uninstall, can we remove the rust-0.7 file?
[22:19:43] *** Quits: donri (dag@moz-9BB61102.tbcn.telia.com) (Client exited)
[22:20:11] *** Quits: dherman (dherman@moz-6CA476B1.hsd1.ca.comcast.net) (Quit: dherman)
[22:21:18] <sully> just submitted a PR fixing vector pattern matching; can anyone take a look? https://github.com/mozilla/rust/pull/8403
[22:21:35] <rustyPipe> So can we safely delete the file from which we built the compiler from?
[22:21:51] <tjc> sully: Looking at it
[22:21:55] *** Quits: Benvie_ (brandon@5FD20F9A.53D07D95.EFF8B7BF.IP) (Quit: )
[22:22:13] <kimundi> rustyPipe, wich file?
[22:23:03] <rustyPipe> The file that can be extracted from the tarball. It contains the configure script and makefiles needed to install the rust compiler and other tools from source.
[22:23:32] *** Quits: gavinb (gavinb@7F15F409.83AB59D0.3BB1CE94.IP) (Quit: gavinb)
[22:23:42] <brson> it might be tls access that is making newrt slower on straight-line code
[22:23:51] <kimundi> rustyPipe: Once rust is installed you don't need that stuff anymore if you just want to use the installed version
[22:23:58] <cmr> sully: you are a saint for including documentation :)
[22:24:11] <tikue> how do you um
[22:24:14] <sully> cmr: I spent longer on the documentation than I did on the code, I think
[22:24:21] <sully> cmr: and I'm still not convinced it is very good
[22:24:27] <kimundi> (though I would recommend cloning the git head and doing a up to date build)
[22:24:31] <tikue> how do you deconstruct structs within structs
[22:24:39] <kimundi> (and keeping the git repo for updating)
[22:24:41] <rustyPipe> Okay
[22:24:51] <tikue> for Foo { Bar { baz } } in foos { } ?
[22:25:17] <kimundi> tikue: 'destructure', but yes, that should work
[22:25:24] <tikue> kimundi: thank you :)
[22:26:09] <kimundi> rusti: let x = Some(Some(5)); let Some(Some(n)) = x; n
[22:26:10] -rusti- <anon>:5:36: 5:49 error: refutable pattern in local binding
[22:26:10] -rusti- <anon>:5          let x = Some(Some(5)); let Some(Some(n)) = x; n
[22:26:10] -rusti-                                              ^~~~~~~~~~~~~
[22:26:10] -rusti- error: aborting due to previous error
[22:26:10] -rusti- application terminated with error code 101
[22:26:20] <kimundi> aw, enum, right
[22:26:22] *** Quits: sebcrozet (sebcrozet@moz-87D51607.w80-13.abo.wanadoo.fr) (Quit: Gone)
[22:26:48] <brson> pthread_setspecific is 1.43%, pthread_getspecific 0.91%. then there are a number of xxx_local accessors that have high percentages. this stuff was all inline asm in oldsched
[22:27:01] <kimundi> rusti: struct<T> Foo{ data: T}; Foo{data: 5}
[22:27:01] -rusti- <anon>:5:15: 5:16 error: expected ident, found `<`
[22:27:01] -rusti- <anon>:5          struct<T> Foo{ data: T}; Foo{data: 5}
[22:27:01] -rusti-                         ^
[22:27:02] -rusti- application terminated with error code 101
[22:27:12] <kimundi> rusti: struct<T> Foo<T>{ data: T}; Foo{data: 5}
[22:27:12] -rusti- <anon>:5:15: 5:16 error: expected ident, found `<`
[22:27:12] -rusti- <anon>:5          struct<T> Foo<T>{ data: T}; Foo{data: 5}
[22:27:12] -rusti-                         ^
[22:27:12] -rusti- application terminated with error code 101
[22:28:24] <kimundi> rusti: struct Foo<T>{ data: T}; let x = Foo{data: Foo{data: 5}}; let Foo{data: Foo{data: n}} = x; n
[22:28:25] -rusti- 5
[22:30:04] <goffrie_> has really every PR failed to land since 15 hours ago o.o
[22:30:08] *** goffrie_ is now known as goffrie
[22:31:10] *** Quits: dim-an (ermolovd@moz-FE167E47.nationalcablenetworks.ru) (Quit: dim-an)
[22:33:40] <sully> hm
[22:33:43] <sully> why are they failing?
[22:36:02] <brson> this one failed because of a rt problem http://buildbot.rust-lang.org/builders/auto-mac-64-opt/builds/838/steps/test/logs/stdio
[22:36:34] <cmr> my rollup bounced a few times
[22:36:37] <cmr> it should be fine now though
[22:37:01] <sully> tjc: ok, added a hyphen, repushed, and marked r=catamorphism
[22:37:03] <sully> tjc: thanks!
[22:37:20] <brson> bors was off for a long time
[22:37:28] <tjc> sully: thanks!
[22:37:31] <brson> not off, but broken
[22:37:33] <bblum> steven_is_false: ping
[22:37:38] <steven_is_false> bblum: Oh hi.
[22:38:12] <bblum> steven_is_false: let's talk about waitqueue
[22:39:02] <bblum> my view is that it's an internal implementation detail of mutex and friends, and there's not really any reason to split up sync into a subdirectory full of smaller files
[22:39:20] <steven_is_false> bblum: sync.rs is really big, and complicated.
[22:39:50] <steven_is_false> Besides splitting up sync into modules enforces privacy, and prevents classes from mucking with other classes internals.
[22:41:08] <bblum> steven_is_false: Bigness isn't a metric for splitting things up; logical separation is, and there are plenty of files that are bigger -- io.rs, iterator.rs, path.rs, run.rs, str.rs, unicode.rs, vec.rs, bitv.rs, getopts.rs, time.rs, treemap.rs
[22:41:46] <tjc> bblum: I don't know anything about this, but "other files are bigger" is a bad argument for this one being big. We've never systematically refactored the standard libraries; they've grown by accretion.
[22:42:00] <graydon> brson: so um, different angle: are we creating-and-then-killing a lot of threads, say?
[22:42:03] *** Quits: brendan (brendaneic@moz-BBE3ABD.mv.mozilla.com) (Quit: brendan)
[22:42:10] <graydon> brson: like many more than the number of tasks?
[22:42:14] <bblum> tjc: that's a fair point
[22:42:38] <bblum> steven_is_false: i'm also not worried about privacy between waitqueue and the things that use it. there are bigger concerns (unsafety!) about which the different components already have to trust each other to make it work safely
[22:43:12] <steven_is_false> bblum: Yes, the main unsafety issue there is the need for Exclusive.
[22:43:48] <steven_is_false> Splitting every single component up into different Exclusive boxes is probable a bad idea.
[22:43:52] <brson> graydon: stdtest does create a lot of threads. i don't know if it's many more than the number of tasks
[22:45:19] *** Joins: orshem (orshem@C5E06B1E.A5B6B765.E3D28531.IP)
[22:45:41] <steven_is_false> bblum: Although the only concern I have about that is space usage, and not performance (in my way too big pull request I had earlier it was basically as performant.)
[22:46:21] <bblum> steven_is_false: you mean, having several exclusive boxes all sitting next to each other? how did you test this?
[22:47:10] <bblum> steven_is_false: another point is that i view the sync file as a library that provides "multiple utilities all sharing a central theme". i think it's overkill to give directory structure to every single exported type that we want our libraries to have.
[22:47:11] <steven_is_false> bblum: Let me hunt for a link.
[22:47:12] *** Joins: leonvv (leonvv@moz-7D83A5F1.ip.telfort.nl)
[22:47:17] <orshem> hi all. how do i get a backtrace for my program instead of  task <unnamed> failed at .. ?
[22:47:19] <bblum> thanks
[22:47:48] <brson> orshem: use gdb to break on rust_begin_unwind
[22:48:06] <steven_is_false> bblum: I was thinking of splitting it up into wait_queue.rs, semaphore.rs, and locks.rs but that's just a rough sketch.
[22:48:21] <steven_is_false> So not one module for every type.
[22:48:28] <orshem> brson, thanks. do i need to compile it differently as well?
[22:48:53] <cmr> orshem: nope
[22:48:59] <cmr> although -Z debug-info helps a *lot*
[22:49:11] <bblum> steven_is_false: why do you judge mutex and rwlock as similar enough to be in the same file, but not semaphore?
[22:49:24] <orshem> cmr thanks
[22:49:51] <steven_is_false> bblum: Mutex, and RWLock, are two implementations of the same concept.
[22:50:04] <bblum> steven_is_false: So is semaphore.
[22:50:25] <bblum> steven_is_false: They are all variations on the same theme. Mutex is just a special case of semaphore, if anything.
[22:50:38] <steven_is_false> bblum: Yes, a restricted version of Semaphore.
[22:50:58] *** Joins: tchoma (tchoma@moz-E58E29CC.dsl.static.sonic.net)
[22:51:02] <steven_is_false> bblum: Semaphore can model producer, consumer models. Mutex can't.
[22:51:51] <bblum> So, what is the difference between semaphore and the other two that is greater than any possible difference between the two themselves that warrants splitting semaphore out?
[22:51:57] <cmr> Yikes I just filled my disk cache
[22:52:16] <graydon> brson: any idea why 'try' would spawn a new thread?
[22:52:40] <steven_is_false> bblum: Maybe RWLock, and Mutex should be in different files.
[22:53:08] <bblum> steven_is_false: then you've got one file per type, and they may as well all be in the same file
[22:53:34] <steven_is_false> bblum: No, because having them in different files enforces privacy so they can't muck with each others internals.
[22:53:36] <cmr> I don't see why moving things into their own files is contentious
[22:54:05] *** Quits: FrozenCow (FrozenCow@moz-B2DF4929.chello.nl) (Ping timeout)
[22:54:10] <steven_is_false> bblum: Also if we have UnsafeMutex, and Mutex, and UnsafeRWLock, and RWLock we could have the two versions share files.
[22:54:25] <brson> graydon: no. 'try' shouldn't spawn a thread
[22:54:26] <bblum> steven_is_false: They don't muck with each other's internals. There are bigger concerns than privacy, like I said above.
[22:54:37] <brson> graydon: well, 'task::try' at least. maybe there are others
[22:54:41] <bblum> steven_is_false: What about "UnsafeMutex" would be different from Mutex as it presently is?
[22:54:52] <bblum> brson: do scheduler threads get lazily forked?
[22:54:52] <steven_is_false> bblum: Recursion.
[22:54:58] *** Joins: brendan (brendaneic@moz-BBE3ABD.mv.mozilla.com)
[22:55:03] <brson> bblum: no
[22:55:06] <graydon> brson: ok, I may well be misinterpreting. any idea what this is? https://gist.github.com/graydon/673267bdb726f20d0784
[22:55:32] <steven_is_false> bblum: Let me get a link to an issue which explains this.
[22:55:47] <graydon> brson: it looks like every uv loop spawns a thread.
[22:55:54] <bblum> steven_is_false: please do, I am confused
[22:56:46] <brson> graydon: it may be true that every uv loop spawns a thread. i know it's true on mac
[22:56:48] <steven_is_false> bblum: Okay, sorry I was confused for a moment. I meant RWArc, and MutexArc not RWLock, and Mutex. Sorry, that's irrelevant.
[22:56:53] <Seldaek> tjc: regarding composer vs rustpkg, I don't know yet how you handle n>1'th degree dependencies (does it? is it a goal at all?) - but we found that scanning github/git repos was too slow and that caching everything in a centralized repo makes things much easier and faster for users, you can still specify github urls when you need to require a fork or whatever
[22:56:56] <graydon> brson: this is a mac! :)
[22:57:00] <brson> graydon: oh :)
[22:57:14] <brson> so every scheduler is 2 threads
[22:57:16] <toddaaro> brson graydon : wait, why would each loop spawn a thread?
[22:57:16] <tjc> Seldaek: not handled yet. it might be nice to...
[22:57:16] <brson> sadly
[22:57:41] <tjc> Seldaek: caching everything is sorta the plan, though. rustc won't try to do any fetching-from-git, only rustpkg does...
[22:57:43] <brson> toddaaro: i'm not clear on why
[22:57:43] <toddaaro> I'm perplexed, is this a mac-only thing?
[22:58:03] <tjc> so you would run rustpkg to fetch all your external dependencies into the cache, then probably run rustc only for a while, until you wanted to update stuff
[22:58:08] *** Quits: infynyxx (infynyxx@moz-E95B370B.nyc.res.rr.com) (Client exited)
[22:58:22] *** Quits: brendan (brendaneic@moz-BBE3ABD.mv.mozilla.com) (Quit: brendan)
[22:58:35] <brson> graydon: that backtrace you're looking at is for spawning a SingleThreaded task, which has its own scheduler. it's a fairly expensive thing
[22:58:46] <bblum> steven_is_false: oh yeah, that's just a matter of separate impls.
[22:59:12] <Seldaek> tjc: well in my experience there are 3 models.. composer has a fully centralized package repo (though you can have more than one) that caches the metadata, so you can just require a package by name and it's found on packagist.org all is well, no need to know where it's hosted, and you have very little cache space used, then we "flatten" the tree of dependnecies, resolve and install all at once
[22:59:19] <steven_is_false> bblum: Anyways, I admit wait_queue.rs might not be the best place to draw module boundaries. Suppose, I just kept the changes to using a wait_event method for WaitQueue so that it could be split up if WaitQueue ever grew large enough to deserve its own module?
[22:59:32] *** Joins: brendan (brendaneic@moz-BBE3ABD.mv.mozilla.com)
[22:59:38] <orshem> rust mangle names like there's no tomorrow :)
[22:59:46] <tjc> Seldaek: Ah, I see. So far, we don't have an aggregator like that in the picture...
[22:59:49] <tjc> …maybe we will need one
[22:59:51] <Seldaek> tjc: then you have npm in js which is intermediate, it still works with a central repo, but they don't flatten the dependnecies, dependencies are installed recursively for each dependency
[23:00:24] *** Quits: dew (Instantbir@moz-8A63B53.dhcp.stls.mo.charter.com) (Ping timeout)
[23:00:24] <tjc> Seldaek: Right, currently rustpkg does it recursively, but there's no particular requirement to get dependencies that way
[23:00:25] <Seldaek> tjc: that's nice because it makes dependency hell less likely, but it's not feasible in php for example since you can't load twice the same "module" since htey are defined globally (I think this is true in rust too?)
[23:00:44] <bblum> steven_is_false: I don't anticipate WaitQueue will ever grow. It's just a building block; the things that it is built out of will never need any more functionality than it currently provides.
[23:00:54] <brson> i'll ask about the uv working thread in #libuv
[23:00:57] <tjc> Seldaek: hmm, I'm not sure what it would mean to load the same module twice
[23:01:10] <bblum> steven_is_false: If it turns out I am wrong about that, we can add more stuff to WaitQueue when the time comes. But doing it now is premature.
[23:01:23] *** Quits: Marc_ (chatzilla@moz-46C6E4A5.ipsat.francetelecom.net) (Quit: ChatZilla 0.9.90.1 [Firefox 21.0/20130511120803])
[23:01:25] *** Quits: huseby (huseby@19BD73A1.5D8BCA3A.A0C1B52F.IP) (Ping timeout)
[23:01:36] <Seldaek> tjc: then the third model is what you seem to be heading for, which is everything handled locally (no central repo), Bower does that but in very little time it fills your disk with useless cache garbage because it clones tons of repos multiple times it seems. I'm sure it's not the most optimal way but still this model scares me a bit
[23:01:39] <cmr> tjc: I think he means link the same module twice
[23:01:48] <cmr> link, in native parlance, at least
[23:01:54] <steven_is_false> bblum: I don't think it's premature to make the code neater.
[23:02:01] *** Joins: huseby (huseby@19BD73A1.5D8BCA3A.A0C1B52F.IP)
[23:02:10] <tjc> Seldaek: we're not going to make separate copies of repos for each project that depends on them -- they'll be shared
[23:02:10] <brson> it's mac-specific
[23:02:19] <brson> graydon toddaaro: and it's for something tty-related!
[23:02:22] <brson> awesome
[23:02:27] <tjc> Seldaek: as far as linking the same module twice, yeah, I don't think Rust allows that
[23:02:38] <bblum> steven_is_false: Can you explain how adding wait_event makes it neater than it is presently?
[23:02:52] <ecr> can we add a freeze! and thaw! macros to do the 'let (mut) x = x' thing?
[23:02:59] *** Quits: orshem (orshem@C5E06B1E.A5B6B765.E3D28531.IP) (Quit: Leaving)
[23:03:08] <strcat> ecr: I don't think you should need to do that anymore
[23:03:15] <strcat> just leave it as mut
[23:03:23] <strcat> the borrow checker is much less dumb
[23:03:25] <Seldaek> tjc: yeah that's what I mean, if two dependencies have the same dependency in different versions.. if you can link those two separately all is well (like in js because it's just "linking" stuff in local variables). If you can't then you need a proper solver and that's not the most fun thing to write :)
[23:03:47] *** Quits: busylizzy (lisa@85228838.12D0DC84.211374C4.IP) (Ping timeout)
[23:03:51] *** Joins: busylizzy (lisa@85228838.12D0DC84.211374C4.IP)
[23:03:54] <ecr> strcat: I don't want to give up on immutability as default.
[23:04:01] <graydon> Seldaek: we can link 2 different versions of the same-named crate. but let's not get ahead of ourselves.
[23:04:04] <Seldaek> tjc: we ported one from C to php, so we have a pretty complete and powerful model of package resolution.
[23:04:07] <graydon> Seldaek: what are you actually worried about?
[23:04:10] *** Joins: gavinb (gavinb@moz-CA19A0CF.vic.adsl.internode.on.net)
[23:04:15] <strcat> ecr: that won't work with multiple scopes though
[23:04:25] <tjc> Seldaek: Oh, I see -- yes, rustpkg does aim to support different versions of the same package
[23:04:26] <strcat> it won't work as you'd expect
[23:04:39] <tjc> the version is part of the "identity" of the package, so… it's not considered the same
[23:04:39] <ecr> strcat: most of my problems with it come from the lack of once functions
[23:04:47] <steven_is_false> bblum: Sure. The logic for creating a WaitEvent is contained in one wait_event method, as opposed to being duplicated in wait_on, and acquire.
[23:05:21] <strcat> ecr: afaik that restriction is arbitrary - because there are non-Freeze things so it doesn't accomplish anything
[23:05:30] <Seldaek> graydon: just discussing, not worrying :) but the point is just to know if we have to be concerned about ending in dependency hell or not. If multiple dependencies have conflicting dependencies it sucks. If we can work around that by loading things twice in diff versions it does help.
[23:06:12] <tjc> Seldaek: we're allowing multiple versions of a package to be installed at the same time, so I think that prevents the problem with conflicting dependencies, unless I'm failing to appreciate what the problem is
[23:06:13] <graydon> Seldaek: "dependency hell" is imprecise. If you're worried about rust being able to link 2 versions of a library into a program, that's something we designed for.
[23:06:19] <tjc> (which I may be)
[23:06:58] <brson> graydon: opened an issue on that extra thread https://github.com/mozilla/rust/issues/8407
[23:07:14] <graydon> tjc Seldaek: there are 2 possible issues here: "installing 2 libs with same name+hash, different versions" and "linking 2 copies of lib with same name+hash, different version, into same combined application". rust handles both of these.
[23:07:45] <graydon> Seldaek: we version-mangle every symbol and every library filename.
[23:08:08] *** Quits: hjr3 (hradtke@374E545A.3A8E9B0C.F9D9C60E.IP) (Ping timeout)
[23:08:39] <bblum> steven_is_false: do you have a diff for this? i have a hunch about not being able to factor out the common logic without having a race, but i can't remember specifically
[23:08:42] <Seldaek> graydon: sounds like rust allows for the best scenario, but let me give you a concrete example, you build a package requiring the foo package which requires a http package in version 2.* and some other package that requires the http package in version 1.*, this is a conflict if you can't install http 1.* and 2.* at once. Seems you can so we're golden.
[23:08:54] <graydon> yes
[23:09:21] <Seldaek> that's an definite advantage of compiling things ;)
[23:09:26] <steven_is_false> bblum: Aside, from pulling out WaitQueue into it's own file that's all my pull request does.
[23:09:27] <graydon> the only way those wind up conflicting is if there is a semantic requirement in this http library that they can't both be alive at once in a program. for example if they fight over a TCP port or file on disk or whatever.
[23:09:31] <graydon> we can't really prevent that
[23:09:38] <graydon> any more than we can prevent racing on external values or such
[23:09:39] <Seldaek> of course
[23:09:48] <Seldaek> but I'm assuming people are sane 
[23:09:55] <bblum> steven_is_false: alright, one moment, let me look
[23:10:01] <brson> graydon: I think this rustc perf regression is a regression in the cost of local allocations due to TLS differences. Should be able to close that gap pretty easily, but there are some difficulties
[23:10:04] *** Joins: victorporof (victorporo@B4B1C8EE.73B1E539.9B1E38F4.IP)
[23:10:07] <brson> i'll start fixing
[23:10:22] <graydon> brson: ok. not a huge deal, just thought I'd point it out. if there are more pressing things I wouldn't worry.
[23:10:34] <strcat> does someone want to look at a little snippet of LLVM IR for me and tell me if I'm insane or not? ;p
[23:10:41] * strcat can't see the mistake
[23:10:52] <strcat> http://ix.io/797
[23:11:05] <strcat>     pub fn i16_add_with_overflow(x: i16, y: i16) -> (i16, bool);
[23:11:24] <strcat> so... somehow the first part of the result is always 0
[23:11:38] *** Joins: hjr3 (hradtke@374E545A.3A8E9B0C.F9D9C60E.IP)
[23:11:43] <brson> in newrt TLS has ownership semantics, so there's a lot of take/put operations on it, and we're using slow pthread TLS again, so there are some new abstraction penalties here
[23:12:06] *** Quits: victorporof (victorporo@B4B1C8EE.73B1E539.9B1E38F4.IP) (Ping timeout)
[23:12:11] <graydon> right
[23:12:12] *** Joins: dew (Instantbir@moz-8A63B53.dhcp.stls.mo.charter.com)
[23:12:27] <bblum> brson: i am trying to send on a channel from a sched.event_loop.callback, but it appears that i'm in scheduler context when that happens, and an assert trips... i thought it was legal to send from a callback?
[23:12:41] <Seldaek> tjc: anyway, while this kinda clears us from having bad conflicts, there is still a case to be made for having a proper SAT solver with full conflict/replace/provide/require capabilities IMO, and not just a "dumb loop" like most package managers have. It allows for quite complex stuff which is sometimes very handy. 
[23:13:01] <brson> bblum: it could be, but isn't implemented. olsonjeffery was hitting this same thing. send_deferred should work though
[23:13:26] <brson> bblum: other code that wants to change context from a callback in sched context does the switch directly
[23:13:28] <tjc> Seldaek: I'm not sure what the proper-SAT-solver approach buys us, though I know that it's not unimaginable for a package manager to do it. can you sketch out a specific example where it would help?
[23:13:33] <brson> or with tubes
[23:13:53] *** Quits: james4k (james@moz-E7990244.consolidated.net) (Ping timeout)
[23:14:37] <graydon> brson: did you expect a sched to have 1 thread anyways?
[23:14:46] <Seldaek> tjc: I know of two cases we have in composer where people use it mostly: one is replacing sub-packages with an aggregate "monolithic" package, which is probably mostly useful due to historical reasons, I'm not sure. 
[23:14:51] <graydon> brson: you said '2 threads', implying you assumed there'd be one there already?
[23:15:30] <strcat> oh I see the problem
[23:15:32] <strcat> omg
[23:15:38] <Seldaek> tjc: the other is to be able to have virtual packages. So let's say many packages require a "logger" package which doesn't really exist, but is a virtual thing people agree upon, that many different logging libraries can mark as being providers of
[23:15:42] <strcat> something is wrong with whatever generates intrinsics.
[23:15:49] <graydon> Seldaek: I am sure we will, at some point, implement a mechanism for solving mutually-compatible requirements into a single library
[23:15:53] <Seldaek> tjc: so you can pick any of those logging libs and they satisfy the requirement 
[23:15:57] <strcat> it's convinced they always have an immediate return type. and they don't
[23:16:07] <strcat> so it was reading the env ptr parameter as arg 1
[23:16:10] <strcat> and arg1 as arg2
[23:16:12] * strcat sighs
[23:16:21] *** Quits: maxli (maxli@B5559308.9C54E60.2FA4EA88.IP) (Quit: Leaving.)
[23:16:26] <strcat> I'll report this I guess
[23:16:33] <graydon> Seldaek: but it is very important right now to not overload rustpkg's design with scope-creep. a program that we can start using (with some deficiencies) is worth much more than one we're still fiddling with
[23:16:34] <strcat> for now, hardcoded index hacks
[23:16:45] <tjc> Seldaek: Those both seem like reasonable scenarios. Thanks for going into specifics. I think both of those would go on the "future" to-do list for rustpkg
[23:16:56] *** Quits: aatch (aatch@moz-B437F499.pocketrent.com) (Ping timeout)
[23:16:58] <tjc> I don't think anything we're doing now rules out more sophisticated dependency-solving in the future
[23:17:14] <Seldaek> graydon: definitely this isn't necessary for 1.0 feature wise, but it's good to keep in mind to make sure what we do is future proof and enables the introduction of a full blown implementation later on 
[23:17:27] <strcat> if I could count to three, this bug would have been easier to solve
[23:17:29] <tikue> strcat: have you seen "cannot root managed value long enough" related to sending the return value from .iter().find_() to an outer scope?
[23:17:36] <graydon> strcat: story of my life
[23:17:46] <ecr> brson: I told bblum how I got around that scheduler context restriction. hopefully it will be merged when his stuff does.
[23:18:12] <Seldaek> tjc: probably not. If all you do is define requirements I guess it's fine, you just expand on that later
[23:18:13] <strcat> graydon: I looked at this IR 20 times and didn't see the obvious off-by-one ;p
[23:18:22] <ecr> brson: the fix is to only do the rtassert! that we're in the sched context if we're going to do any rescheduling
[23:18:31] *** Joins: jdm (jdm@9FB21CB6.76DE1AD5.AE2B2F80.IP)
[23:18:42] <strcat> well, now LLVM doesn't optimize these intrinsics to no-ops, yay.
[23:19:37] <brson> graydon: yeah, every sched runs on a thread that we create with the Thread type in rt::thread, then uv creates another behind the scenes
[23:19:59] <graydon> brson: but what if I set RUST_THREADS=1 ?
[23:20:48] <brson> graydon: with RUST_THREADS=1 there should be 3 threads on mac: the main thread (that we don't use), the scheduler thread, and the libuv worker thread
[23:20:52] <cmr> Woo rollup is landing
[23:21:38] <graydon> brson: I mean ... when we run with RUST_THREADS=1, how many threads get produced per-new-scheduler?
[23:21:42] <graydon> on a mac
[23:21:45] <Seldaek> cmr: cool, and thanks for r+ing 
[23:21:47] *** Quits: Houm (Houm@moz-25669AA8.fbx.proxad.net) (Ping timeout)
[23:22:12] *** Joins: aatch (aatch@moz-B437F499.pocketrent.com)
[23:22:26] <brson> graydon: the same number RUST_THREADS=1 might as well mean RUST_SCHEDULERS=1. from our perspective there is one thread per scheduler
[23:22:26] <cmr> dbaupp: so I have 8 builds going in parallel right now
[23:22:32] <brson> then libuv does what it does
[23:22:44] <cmr> dbaupp: only problem is, I have all builds using a separate build dir which is rsynced from a single one
[23:22:46] <graydon> brson: a bunch of tests in rt:: produce a lot of schedulers. I believe it's the sudden burst producing new threads due to those that causes valgrind to choke.
[23:22:53] <cmr> (and then checkout the proper revision etc)
[23:22:55] <tikue> nmatsakis: I was pointed in your direction regarding a problem I'm having with a managed value not being rooted long enough
[23:22:58] <cmr> LLVM builds are /killing/ it
[23:23:03] *** Joins: ghrust (ghrust@79968228.6A2AE50.F3114085.IP)
[23:23:03] <ghrust> 01[13rust01] 15bors merged 06auto into 06master: 02http://git.io/HhHjfQ
[23:23:03] *** Parts: ghrust (ghrust@79968228.6A2AE50.F3114085.IP) ()
[23:23:17] <brson> graydon: ok, so those tests are doing their own thing, ignoring RUST_THREADS
[23:23:26] <graydon> brson: if I run with RUST_THREADS=1 I get a ton of new threads being produced.
[23:23:27] <graydon> ok
[23:23:31] <graydon> I did not know they ignore RUST_THREADS
[23:23:34] <graydon> i thought it influenced them
[23:23:43] <cmr> dbaupp: it'd be nice to have a pool of build dirs that are handed out to each new task as it runs, but I don't know enough about celery to make that happen
[23:24:21] <tiffany> what's the best way to make a vector of the form [contents of another vector, some zeros to pad the space, a value]?
[23:24:28] <brson> graydon: there's another var to control those RUST_RT_TEST_THREADS
[23:24:32] <brson> graydon: this is in rt::test
[23:24:47] <brson> that still certainly doesn't controll all the test threads being created
[23:24:49] <brson> but a lot of them
[23:24:51] <strcat> hm
[23:24:58] <strcat> maybe foreign.rs just passes the wrong ty::t
[23:24:58] <brson> by default RUST_RT_TEST_THREADS=ncores*2
[23:26:04] *** Quits: ozten (ozten@19BD73A1.5D8BCA3A.A0C1B52F.IP) (Quit: ozten)
[23:26:15] <brson> graydon: then there are other threads created for other reasons. a lot of the runtime tests use `run_in_bare_thread` to create a clean environment for testing the runtime. this, on mac will end up creating 3 threads
[23:26:31] <ecr> brson: wrote the test with actual homing. passes :D
[23:26:33] <graydon> yeah. can I make those not happen?
[23:26:42] <graydon> ecr: \o/
[23:26:44] <brson> ecr: nice!
[23:26:53] <ecr> now to replicate it across everything
[23:27:28] <brson> ecr: not really, no
[23:27:37] <brson> er, graydon
[23:27:45] <graydon> brson: RUST_THREADS=1 RUST_RT_TEST_THREADS=1 is enough to make valgrind able to run stdtest
[23:27:53] <graydon> though I imagine it's close to its limit anyways
[23:28:02] <graydon> I think we should just turn off those tests when running on v
[23:28:08] <graydon> can we dynamically detect?
[23:28:20] <graydon> (I mean, is there a nice API we left lying around still? or was it removed?)
[23:28:20] <Seldaek> tjc: anyway happy to help with anything if needed.. I can't help so much on rustc so I try to do extraneous things that are still critical to the success of the language (like rustdoc & packaging..)
[23:28:38] *** Quits: jorendorff (jorendorff@moz-2F32ACA3.hsd1.tn.comcast.net) (Quit: jorendorff)
[23:28:58] <brson> graydon: std::run does it, but it's not encapsulated. could probably go in rt::util::on_valgrind()
[23:28:59] <bblum> steven_is_false: ok yeah, i see, wait_event() is good.
[23:29:04] <graydon> Seldaek: I think the most useful thing at this point is to write programs that are "packaged as rustpkg wants them" to find all the usability flaws in the current code
[23:29:05] <tjc> Seldaek: Sure! Trying to use it and filing bugs (esp. about unclear documentation) is one way; the existing bugs are at https://github.com/mozilla/rust/issues?direction=asc&labels=A-pkg&sort=updated&state=open
[23:29:19] <tjc> Seldaek: Also I wrote a separate to-do list at https://github.com/mozilla/rust/wiki/Bikeshed-rustpkg that's cross-referenced with bugs
[23:29:33] <bblum> steven_is_false: i'm not convinced it needs its own struct, and it can just return a non-abstracted PortOne instead, but if you feel strongly about keeping that abstraction, that would be fine too
[23:29:58] <graydon> brson: looks like yes. I will try to adapt those tests to turn themselves off on V
[23:30:13] *** Joins: madalynn (Mibbit@3D9A9111.93384D21.67D94052.IP)
[23:30:40] <steven_is_false> bblum: I'm not sure whether it should return a PortOne, or a WaitEvent.
[23:30:53] <Seldaek> tjc: ok thanks I'll check it. graydon: ack. 
[23:31:11] <bblum> steven_is_false: yeah, my vote would be just return a PortOne, and call recv() on it directly, but it doesn't matter
[23:32:02] *** Quits: leonvv (leonvv@moz-7D83A5F1.ip.telfort.nl) (Client exited)
[23:32:04] *** Quits: madalynn (Mibbit@3D9A9111.93384D21.67D94052.IP) (Quit: http://www.mibbit.com ajax IRC Client)
[23:32:05] *** Joins: ghrust (ghrust@C8693FCB.6A2AE50.F3114085.IP)
[23:32:06] <ghrust> 01[13rust01] 15bors pushed 0 new commits to 06auto: 02http://git.io/oRvP2g
[23:32:06] *** Parts: ghrust (ghrust@C8693FCB.6A2AE50.F3114085.IP) ()
[23:32:31] <steven_is_false> bblum: I'm going to take a break, think about this conversation a bit, adjust the pull request, and than post a summary of some of this conversation to the thread.
[23:32:48] <steven_is_false> bblum: Thanks for discussing the issues with me.
[23:32:55] <bblum> steven_is_false: alright, thanks to you too
[23:32:58] *** Joins: leonvv (leonvv@moz-7D83A5F1.ip.telfort.nl)
[23:33:01] *** Parts: steven_is_false (user@C5B76363.1FF1EBF8.1ECA502.IP) (ERC Version 5.3 (IRC client for Emacs))
[23:33:16] *** Quits: adrema (adrema@1453496A.70C7F49.B68672D5.IP) (Ping timeout)
[23:33:37] <brson> graydon: ok, that does make me a little nervous. i can also investigate other angles to reduce the number of threads being created in parallel here
[23:33:48] *** Quits: leonvv (leonvv@moz-7D83A5F1.ip.telfort.nl) (Client exited)
[23:33:51] *** Quits: erickt (etryzelaar@8C9ECD8F.3A598286.F12515B4.IP) (Ping timeout)
[23:33:56] <cmr> dbaupp: alright seems I accidentally removed ccache usage. Putting that back in makes it 90x better
[23:34:05] * cmr can actually use his computer now
[23:34:07] <graydon> brson: I'm going to try just doing the stress-tests, which seem like the main culprits
[23:35:09] <brson> graydon: ok
[23:35:31] <graydon> or, hm. actually, lemme see about just lowering the env vars internally. I'll futz around some. 
[23:37:31] *** Quits: Azdle (Azdle@moz-B334B496.hfc.comcastbusiness.net) (Ping timeout)
[23:39:31] *** Quits: hjr3 (hradtke@374E545A.3A8E9B0C.F9D9C60E.IP) (Quit: My MacBook has gone to sleep. ZZZzzz…)
[23:39:34] *** Quits: BitPuffin (quassel@moz-8370D1B9.bredband.comhem.se) (Ping timeout)
[23:39:34] *** Joins: SiegeLord (sl@moz-CAF07B4C.hsd1.ma.comcast.net)
[23:39:36] *** Joins: erickt (etryzelaar@8C9ECD8F.3A598286.F12515B4.IP)
[23:40:40] *** Joins: BitPuffin (quassel@moz-8370D1B9.bredband.comhem.se)
[23:41:18] *** Quits: tjc (tjc@moz-BBE3ABD.mv.mozilla.com) (Quit: zzzzzzzzzz)
[23:41:37] <toddaaro> graydon: what stress tests in particular? is the problem "net thread creation" or just active threads at one time?
[23:42:07] <graydon> toddaaro: seems like ... shared_port_stress is one of the worst
[23:42:17] *** Joins: tjc (tjc@moz-BBE3ABD.mv.mozilla.com)
[23:42:17] *** ChanServ sets mode: +o tjc
[23:42:20] <graydon> thread_ring maybe? test_spawn_sched_blocking
[23:42:21] <graydon> there are a few
[23:42:51] <graydon> it seems like ... OSX reaps threads a little lazily and if we make too many at once V gets upset there are too many memory segments for it to track
[23:43:02] <graydon> they do eventually get collected
[23:43:11] <graydon> when I run under a debugger and stop on each pthread_create...
[23:43:15] *** kimundi is now known as zz_kimundi
[23:43:43] <toddaaro> ok, so I know test_stress_schedule_task_states will spawn 240 threads base, as it runs 120 iterations of something that spawns two threads
[23:44:03] <toddaaro> so if reaping is an issue that might be one way to stamp out a couple hundred thread creates
[23:44:31] <strcat> graydon: another bug ;p, our InsertValue in build.rs doesn't return a new ValueRef >.<
[23:44:48] <strcat> oh well
[23:45:00] <graydon> strcat: we're using insertvalue now?
[23:45:05] <graydon> I thought we were avoiding that
[23:45:12] <strcat> graydon: well I used it in an intrinsic I wrote
[23:45:16] <strcat> but it doesn't work as it is
[23:45:16] <graydon> aha
[23:45:20] <graydon> yeah, I think nobody uses it
[23:45:22] <graydon> likely busted
[23:45:24] <brson> the extra thread mac is actually about fsevents
[23:45:26] <strcat> yep!
[23:45:36] <graydon> brson: garg
[23:45:47] <strcat> graydon: from the signature, I assumed it must modify a value - but it can't. it's part of SSA
[23:45:51] <strcat> pub fn InsertValue(cx: @mut Block, AggVal: ValueRef, EltVal: ValueRef, Index: uint) {
[23:45:55] <strcat> should have -> ValueRef
[23:46:06] <brson> i'm sure the libuv guys will be amenable to helping us get rid of it. they're great
[23:46:25] <brson> we probably don't need to access fsevents on every core
[23:48:29] <strcat> graydon: I'm curious why we aren't using insertvalue
[23:48:38] <strcat> do you remember why?
[23:48:54] *** Joins: maxli (maxli@B5559308.9C54E60.2FA4EA88.IP)
[23:49:23] <strcat> I guess we just use GEP
[23:49:24] <graydon> strcat: because you have to orient your entire data model around it if you use it, and you can't GEP to any of the elements
[23:49:32] <graydon> which means no &-of-an-element
[23:49:53] <graydon> SROA apparently (I am told!) magically converts anything it can
[23:49:55] <strcat> ah right because it returns you a new aggregate
[23:49:57] *** Quits: vosen (vosen@moz-266BA656.icpnet.pl) (Quit: Leaving)
[23:50:04] *** Joins: vodik (simon@moz-CBE4BB13.cable.teksavvy.com)
[23:50:40] <graydon> or whatever. I thought we had to use it too and someone long ago informed me that it is not widely used because C semantics let you take addresses inside things so the general translation in things like clang is to not use it.
[23:50:52] <graydon> I have no idea if that is true. I did spend a while using it and then backed out.
[23:51:05] <strcat> graydon: it makes sense why it wouldn't work overall
[23:51:23] <strcat> in this case I just wanted to alloca a struct, set the fields and return it
[23:51:31] <strcat> turns out we still use an out ptr for small structs/tuples though
[23:51:51] <aatch> tjc, btw, don't look too closely at composer. As a PHP dev, Composer is a bane to my existence.
[23:51:53] <strcat> but I was confused by this out_arg_pos function having the reverse assert
[23:52:05] <strcat> -        assert!(self.has_immediate_return_value);
[23:52:07] <strcat> +        assert!(!self.has_immediate_return_value);
[23:52:09] <strcat> fixed now...
[23:52:23] *** Quits: erickt (etryzelaar@8C9ECD8F.3A598286.F12515B4.IP) (Ping timeout)
[23:52:35] <tjc> aatch, I'll take that under advisement :-)
[23:54:08] <aatch> Specifically, composer manages dependencies on a project level, so you end up with ridiculous situations like having PHPUnit installed n+1 times, once for each project that uses it and once from PEAR/PECL
[23:54:17] *** Quits: brendan (brendaneic@moz-BBE3ABD.mv.mozilla.com) (Quit: brendan)
[23:54:36] <tjc> aatch: Yeah, we're not going to be managing dependencies on a project level. That was out of the question from the start
[23:55:04] <graydon> oO?
[23:55:08] <graydon> define "project"
[23:55:18] *** Quits: vodik (simon@moz-CBE4BB13.cable.teksavvy.com) (Quit: WeeChat 0.4.2-dev)
[23:55:22] <aatch> graydon, so "rustc" would be a project.
[23:55:27] <tjc> graydon: I mean, we were never planning on installing a separate copy of a given library for every other package that uses it
[23:55:36] <tjc> I thought that would be the "purely functional" approach, which we decided not to do
[23:55:43] *** Quits: eschweic (Adium@moz-BBE3ABD.mv.mozilla.com) (Quit: Leaving.)
[23:55:45] <tiffany> how do you turn &[] to ~[]?
[23:56:01] <aatch> it plays really, really badly with componentized systems
[23:56:05] <aatch> tiffany, .to_owned()
[23:56:15] *** Joins: vodik (simon@moz-CBE4BB13.cable.teksavvy.com)
[23:56:17] <cmr> tiffany: note that that is a copy
[23:56:39] <tiffany> I have a feeling the code I'm doing does a lot of copies already
[23:56:42] <graydon> tjc: depends what you put in RUST_PATH
[23:56:48] <tiffany> does + on vectors get optimized?
[23:56:55] <tjc> graydon: Sure, but that's up to the user
[23:56:57] <cmr> tiffany: optimized to what?
[23:57:05] <aatch> tiffany, depends on what exactly it does.
[23:57:11] <tiffany> anything less than one allocation per array and one final allocation
[23:57:15] <aatch> how big things are. Stuff like that.
[23:57:17] <graydon> tjc: I thought if you put nothing in it it would put a .rustpkg dir in CWD
[23:57:31] <graydon> (or some such thing, I guess .rust?)
[23:57:36] <tjc> graydon: Right, so if you never put anything in, it should only install things there..
[23:57:44] <cmr> tiffany: It can't do magic. It creates a new vector, and clones every item in both of the original vectors into that new one.
[23:57:48] <aatch> It should, in theory, just be one allocation, plus whatever needs to be there for copying the elements.
[23:57:49] <tjc> that is, if you never put anything in the RUST_PATH, you only get one copy of each package-ID
[23:57:54] <bstrie> so, with the new runtime, is it possible to swap out libuv for other event loops?
[23:57:57] <tiffany> I don't expect it to do magic
[23:58:05] <tjc> oh, in *CWD*
[23:58:06] <tjc> I misread that
[23:58:09] <strcat> tiffany: if you do x + y it's going to do 2 allocations
[23:58:15] <tjc> hmm, I don't really like either putting it in the CWD or in the home directory
[23:58:16] <strcat> x + y + z is 4 allocations
[23:58:18] <tiffany> I have a function which adds <provided array> + <a generated array of zeroes> + <a single-value array of an item>
[23:58:19] *** Joins: hjr3 (hradtke@374E545A.3A8E9B0C.F9D9C60E.IP)
[23:58:24] <tjc> that's an area I was unsure about
[23:58:38] <strcat> tiffany: the Add implementation is currently really bad
[23:58:41] <strcat> it should do 1 allocation
[23:58:44] <cmr> tiffany: don't use +. create a single vector of the correct size and use the various push_foo methods
[23:58:51] <tiffany> in C I could implement it as char *buf = calloc(1, len); memcpy(buf, provided_array, num); buf[len-1] = val;
[23:58:53] <aatch> tiffany, there are append methods for owned vectors
[23:58:54] *** Joins: eschweic (Adium@moz-BBE3ABD.mv.mozilla.com)
[23:58:55] <strcat> x + y + z should be 2 allocs, but it's not and that's still bad
[23:59:03] <strcat> tiffany: it could be implemented as 1 alloc in rust, it's not
[23:59:19] <strcat> it could use with_capacity, but it doesn't
[23:59:27] <graydon> tjc: I thought the point was to default to ./.rust then ../.rust then ../../.rust and so forth
[23:59:29] <graydon> until root
[23:59:39] <strcat> tiffany: do you really need both old vectors afterwards?
[23:59:56] <strcat> if you have two ~[T], you could just append one to the other
[23:59:57] <tjc> graydon: that's what it does now, I'm just not sure if it's the Right Thing
[23:59:59] <graydon> tjc: specifically so that projects would wind up getting separate copies of libs they depend on if the user makes a .rust dir

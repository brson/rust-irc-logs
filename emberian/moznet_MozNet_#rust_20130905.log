[00:00:04] <benh> C++ also has template template parameters :(
[00:00:04] <kmc> can't type it statically, anyway
[00:00:06] *** Quits: jdsanders (Adium@moz-84CB7548.hlrn.qwest.net) (Quit: Leaving.)
[00:00:13] <strcat> dbaupp: you could do that in rust too
[00:00:14] <kmc> benh: why :(?  higher-order polymorphism is great!
[00:00:19] <strcat> foo(2)(3)(4)
[00:00:32] <dbaupp> strcat: righ
[00:00:32] <matt444> that's true, not so useful as a compile time macro
[00:00:38] <Lovot_> Small problem, std::os::path_exists(~"/path/to/file") does not work, error: mismatched types: expected `&std::path::PosixPath` but found `~str` (expected &-ptr but found ~str). How would I convert "/path/to/file" to an acceptable file path?
[00:00:39] <benh> kmc: but it's so complicated!
[00:00:48] <ecr> doesn't have to be a vector literal, that's just the apply! syntax I used. it's just a list of macro args
[00:00:59] <dbaupp> strcat: but it's kinda ridiculously awkward to express :(
[00:00:59] <ecr> could easily be apply!(f, x1, x2, x3, ...)
[00:01:12] <ecr> or even apply!(f(x1, x2, x3))
[00:01:13] <benh> so many orders/kinds/meta-whatsits
[00:01:25] <dbaupp> Lovot_: `path_exists(&Path("/path/to/file"))`
[00:01:43] <benh> (and of course it all works completely differently from language to language, or even from haskell to haskell-set-of-extensions)
[00:01:52] <ecr> the macro just shuffles the inputs around into a function call and lets the typechecker decide if it's valid
[00:02:41] <matt444> where is the documentation on the methods on vector?
[00:03:01] <engla> in std::vec
[00:03:07] <ecr> http://static.rust-lang.org/doc/std/vec.html
[00:03:13] *** Joins: Sorella (queen@9D963F5D.DF5D8AE7.54BCAB54.IP)
[00:03:19] <matt444> k
[00:03:33] <ecr> that's not necessarily complete though. if another module defines a trait and impls the trait for vectors there, then it won't show up in vec.rs
[00:03:47] <ecr> http://static.rust-lang.org/doc/std/to_str.html for example
[00:03:50] <Lovot_> dbaupp: Thanks again.
[00:05:09] *** Quits: ChrisMorgan1 (chris@moz-80C478D2.its.monash.edu.au) (Ping timeout)
[00:05:34] *** Joins: ChrisMorgan (chris@moz-F0B57727.its.monash.edu.au)
[00:05:47] *** Quits: ecr (Thunderbir@moz-BBE3ABD.mv.mozilla.com) (Quit: ecr)
[00:06:06] *** Quits: infynyxx (infynyxx@DB780A29.749BA1D.DCC373F0.IP) (Client exited)
[00:06:08] *** Joins: nsf (nsf@moz-EEF3238A.convex.ru)
[00:06:09] <matt444> I remember Do you use ~ to allocate on the stack?
[00:06:45] *** Joins: infynyxx (infynyxx@DB780A29.749BA1D.DCC373F0.IP)
[00:06:48] *** jorendorff is now known as jorendorff_away
[00:07:30] <dbaupp> matt444: no, ~ is on the heap (but not the task-local heap, that's @). Use no sigil to allocate on the stack.
[00:07:31] <kmc> no
[00:07:41] <kmc> use "let" to allocate on the stack, really
[00:07:46] <kmc> (or function call arguments)
[00:07:57] <benh> or match!
[00:08:01] <kmc> ah, good one!
[00:08:21] <kmc> when you say Â«let x = ~FooÂ» that's stack-allocating a value of type ~Foo, which is a pointer to a box in the exchange heap, holding a value of type Foo
[00:08:22] <benh> & and a literal also kinda allocates on the stack
[00:08:28] *** jorendorff_away is now known as jorendorff
[00:08:37] <matt444> i'd let to write in a functional way, I can always use let and not worry about & @ ~ ?
[00:08:39] *** Quits: echristo (echristo@60A74940.D6CCE4AE.77834EAA.IP) (Ping timeout)
[00:08:53] <kmc> matt444: that depends what you want to do with the values
[00:09:51] <kmc> you can't stack-allocate when the lifetime of your object does not match the lifetime of some stack frame
[00:10:14] <kmc> except that you can return objects by value, and you can move them in arguments
[00:10:39] <kmc> (n.b. by "object" i mean the general GC-terminology meaning of "allocated thing" and nothing special to OOP, methods, etc)
[00:10:43] <matt444> if the object's lifetime is the function then it is the lifetime of a stack frame, right?
[00:10:52] <brson> strcat: I'll start bisecting that valgrind error
[00:11:00] <kmc> matt444: yeah
[00:11:45] <kmc> if you avoid @ and ~ then you will be restricted to things that you can do without 'malloc' in C, or without 'new' in C++
[00:11:49] <kmc> basically?
[00:11:53] <kmc> there are some differences I'm sure.
[00:12:17] <kmc> but anyway, the sigils are there because Rust is a low-level language that gives you exact control over how things are allocated, mostly for performance reasons
[00:12:29] *** Joins: echristo (echristo@60A74940.D6CCE4AE.77834EAA.IP)
[00:12:34] <kmc> this is in conflict with safety, and with supporting functional style
[00:12:44] <kmc> Rust as a research project attempts to push the boundary of that conflict
[00:12:47] <kmc> to have our cake and eat it too
[00:12:59] <miza> cmr: very nice results :D
[00:13:10] *** Quits: Ralith (ralith@A8995AA9.62B6AF6A.922221DB.IP) (Ping timeout)
[00:13:16] <benh> Now I'm gonna think of the borrow checker as a robot that steals our cake if we aren't careful. :(
[00:13:22] *** jorendorff is now known as jorendorff_away
[00:13:24] <kmc> haha
[00:13:24] *** Quits: tjc (tjc@moz-BBE3ABD.mv.mozilla.com) (Quit: zzzzzzzzzz)
[00:13:42] <miza> sieve atkin go implementation 
[00:13:42] <miza> real	0m6.693s
[00:13:43] <miza> user	0m6.596s
[00:13:43] <miza> sys	0m0.088s
[00:13:55] *** Joins: maxli (maxli@moz-6EADA619.cpe.net.cable.rogers.com)
[00:13:55] <miza> rust with rustc -O
[00:14:05] <miza> real	0m2.984s
[00:14:05] *** Quits: maxli (maxli@moz-6EADA619.cpe.net.cable.rogers.com) (Input/output error)
[00:14:05] <miza> user	0m2.880s
[00:14:05] <miza> sys	0m0.100s
[00:14:22] <miza> i compile go with gccgo
[00:14:31] <tikue_> isn't `let mut x = ~1u;` strictly less expressive than `let x = ~mut 1u;` ?
[00:14:53] <kmc> benh: why do you say & allocates on the stack?
[00:14:54] <tikue_> rust can't give mutability guarantees about owned data
[00:15:07] <kimundi> tikue_: sure it can
[00:15:11] <tikue_> kimundi: how?
[00:15:19] <kmc> mutability is determined by the root of the ownership tree
[00:15:23] <tikue_> right
[00:15:26] <kimundi> tikue_: if the owner can mutate it, he can mutate it
[00:15:31] <benh> kmc: I believe if I say &mut [1, 2, 3], I get an array on the stack?
[00:15:32] <tikue_> but you can't for instance
[00:15:50] <tikue_> you can't create immutable data and send it to another task
[00:15:54] <tikue_> and expect it to still be immutable
[00:16:10] <kimundi> you can
[00:16:15] <tikue_> kimundi: how?
[00:16:31] <kmc> benh: oh, well there's some sugar yeah
[00:16:36] <kimundi> just not with a bare ~
[00:16:36] <engla> tikue_: without ~mut T, owned pointers are less special. they work just like normal owned values now
[00:16:41] *** Quits: echristo (echristo@60A74940.D6CCE4AE.77834EAA.IP) (Ping timeout)
[00:16:45] <benh> rusti: let a = &[1i, 2i, 3i]; let b = 42i; (&a[0] as *int, &b as *int)
[00:16:45] -rusti- ((0x7f4dfee170c8 as *()), (0x7f4dfee170c0 as *()))
[00:17:00] <kmc> if you write Â«let x = &3;Â» that's like Â«let _temp = 3; let x = &_temp;Â»
[00:17:04] <kimundi> still, no need to force a ~ to be immutable/mutable
[00:17:08] <matt444> rust takes a while to compile...
[00:17:09] <kimundi> you _own_ it
[00:17:20] <kmc> so yeah
[00:17:23] <kimundi> if you don't want to mutatae it, don't mutate it
[00:17:25] <kmc> in that sense, & can stack allocate
[00:17:41] <kimundi> if you give it away, by eg sending it to an other task, that task owns it
[00:17:59] <kmc> specifically, applying & to an rvalue
[00:18:11] <kimundi> if you truely need something immutable, use a wrapper tyepe that starts it's own ownership tree
[00:18:16] *** Joins: mihneadb_ (mihneadb@moz-BE33DA21.fw1.sfo1.mozilla.net)
[00:18:19] *** Quits: mihneadb (mihneadb@moz-BE33DA21.fw1.sfo1.mozilla.net) (Connection reset by peer)
[00:18:33] *** Quits: azita (Azita@moz-BBE3ABD.mv.mozilla.com) (Quit: azita)
[00:18:34] <tikue_> kimundi: how would you do that?
[00:18:39] <kimundi> but you shouldn't need to have to do that
[00:18:47] <engla> kimundi: or just wrap a struct with private fields and no mutators
[00:19:13] <tikue_> kimundi: why do you say that?
[00:19:16] <kimundi> tikue_: well, exampley right now would be Rc<T> and @T
[00:19:29] <tikue_> kimundi: those can't be shared cross-task no?
[00:19:35] <kimundi> tikue_: Becuase it's not neccessarry.
[00:19:47] *** Joins: dualhbridge (dad@moz-9FEE6D3B.maine.res.rr.com)
[00:19:50] <kimundi> for what do you need immutable data
[00:19:52] <kimundi> ?
[00:19:53] <tikue_> i can't think of an example off hand, but it seems reasonable to want to have mutability guarantees for data sent in between tasks
[00:19:58] *** Joins: DAddYE (DAddYE@moz-98D3933F.hsd1.ca.comcast.net)
[00:19:58] <tikue_> kimundi: nothing, just curious
[00:19:59] <engla> why does it have to be immutable?
[00:20:05] <tikue_> engla: god knows
[00:20:06] <kimundi> er, a always immutable type, that is
[00:20:24] <kimundi> hm?
[00:20:33] <tikue_> i have no use-case in mind, i'm just speculating
[00:20:50] <kimundi> Didn't you start with asking why you can't make a ~ immutable? 
[00:20:52] <tikue_> yes
[00:21:02] <tikue_> but i have no case in mind for which i'd want to do that
[00:21:10] <tikue_> it just seems like something that could be useful at some point
[00:21:14] <kimundi> ah
[00:21:18] <engla> struct Immut<T> { priv value: T }  impl<T> Immut<T> { fn new(x:T) -> Immut<T> { Immut{value: x} }; fn get<'a>(&'a self) -> &'a T { &self.value } }
[00:21:21] <tikue_> i suppose Arcs essentially accomplish the same thing
[00:21:40] <kimundi> well, it has been determined that it's not usefull, and thus been changed to the way it works now :p
[00:21:44] <tikue_> lol
[00:21:56] <tikue_> kimundi: that actually is a very reasonable answer :P
[00:22:02] <engla> wrap in Immut and it's immutable
[00:22:03] <tikue_> experimental evidence has proven me wrong
[00:22:14] <tikue_> engla: or just use an Arc right?
[00:22:25] <matt444> where is rustc after you compile?
[00:22:27] <engla> Arc does a different job
[00:22:33] <tikue_> engla: but it accomplishes this as well
[00:22:48] <tikue_> "here's my data, but i'm watching you to ensure there's no funny business"
[00:23:26] <kimundi> tikue_: The nice thing about it is that now a bare T on the stack and a ~T work essential the same, with the exception that you can move the latter around
[00:23:51] <matt444> i can't find the rust bin/ folder...
[00:23:52] <tikue_> kimundi: well you can move both around
[00:24:07] *** Quits: DAddYE (DAddYE@moz-98D3933F.hsd1.ca.comcast.net) (Ping timeout)
[00:24:15] *** Joins: azita (Azita@moz-BBE3ABD.mv.mozilla.com)
[00:24:43] <kimundi> tikue_: right.... what I meant was..... Ah I'm to tired to remember :P
[00:24:45] <tikue_> kimundi: you can always send a T, it's just that sending a ~T has size guarantees
[00:24:57] <tikue_> unless T isn't sendable
[00:24:58] <tikue_> of course
[00:25:11] <benh> rusti: let u = ~42i; let b: &int = u; let u = u; b
[00:25:16] <SiegeLord> matt444: In the root directory there is a directory that is named after your system's triple
[00:25:21] -rusti- pastebinned 22 lines of output: http://ix.io/7R7
[00:25:32] <SiegeLord> matt444: And in there, look in the directory named stage3
[00:25:58] <kimundi> "a bare T is allocated on the stack, a ~T is a pointer to a T allocated on the heap. Usage of both is identical apart from that."
[00:26:44] <dbaupp> matt444, SiegeLord: (or the stage2 folder)
[00:26:50] *** Quits: SingingBoyo (brandon@4DF3381A.51F4D838.4F048BDC.IP) (Ping timeout)
[00:27:06] <benh> ~T more eagerly coerces into &T ;)
[00:27:32] <SiegeLord> Oh... right, stage3 is empty...
[00:28:58] *** Quits: heftig (heftig@moz-DB953191.dip0.t-ipconnect.de) (Ping timeout)
[00:29:09] *** Quits: kimundi (kimundi@moz-A6FA77E4.dip0.t-ipconnect.de) (Ping timeout)
[00:29:13] *** Quits: ofeldt- (ofeldt@moz-E3B4877F.dip0.t-ipconnect.de) (Ping timeout)
[00:29:25] *** Joins: ofeldt (ofeldt@moz-E3B4877F.dip0.t-ipconnect.de)
[00:29:45] *** Joins: kimundi (kimundi@moz-A6FA77E4.dip0.t-ipconnect.de)
[00:29:48] *** Joins: heftig (heftig@moz-DB953191.dip0.t-ipconnect.de)
[00:32:34] <miza> is there any "next" implementation for "for loop"
[00:33:23] <engla> what do you mean miza?
[00:35:11] *** Quits: pnkfelix (pnkfelix@moz-43495417.fbx.proxad.net) (Quit: Leaving.)
[00:35:12] <miza> for x in range(0, 20) {
[00:35:12] <miza>   if x == 5 { next }
[00:35:12] <miza>   some other stuff
[00:35:12] <miza> }
[00:35:15] <tikue_> miza	there is a trait
[00:35:18] <miza> a dummy examble
[00:35:18] <klutzy> miza: loop;
[00:35:44] <miza> i want to avoid too deep levels of indentation
[00:35:49] *** Joins: ghrust (ghrust@DE823A67.6A2AE50.F3114085.IP)
[00:35:49] <ghrust> 01[13rust01] 15bors merged 06auto into 06master: 02http://git.io/Sp0xVw
[00:35:49] *** Parts: ghrust (ghrust@DE823A67.6A2AE50.F3114085.IP) ()
[00:36:09] <tikue_> rusti: for x in range(0, 20) { if x % 2 == 0 { loop; /* skip evens */ } printfln!(x); }
[00:36:13] -rusti- pastebinned 11 lines of output: http://ix.io/7R8
[00:36:18] <tikue_> ^
[00:36:24] *** Quits: six600110 (six600110@moz-2FA48202.neo.res.rr.com) (Ping timeout)
[00:36:27] <engla> you can also transform the iterator in some cases
[00:36:32] <tikue_> yes, with filter
[00:36:51] <engla> like range(0, 20).filter(|x| *x % 2 != 0)
[00:37:07] *** Joins: bent (chatzilla@moz-932324BF.hsd1.ca.comcast.net)
[00:37:16] <engla> rusti: range(0, 10).filter(|x| *x % 2 != 0).to_owned_vec()
[00:37:17] -rusti- ~[1, 3, 5, 7, 9]
[00:40:45] *** Quits: brendan (brendaneic@F689B55.D90C1611.426D2C95.IP) (Quit: brendan)
[00:40:47] *** Quits: hjr3 (hradtke@1A0AE795.28A5F6C3.A2D40ED2.IP) (Quit: My MacBook has gone to sleep. ZZZzzzâ€¦)
[00:41:04] *** Joins: ghrust (ghrust@1E8607E8.6A2AE50.F3114085.IP)
[00:41:04] <ghrust> 01[13rust01] 15bors pushed 0 new commits to 06auto: 02http://git.io/K2-U6w
[00:41:04] *** Parts: ghrust (ghrust@1E8607E8.6A2AE50.F3114085.IP) ()
[00:41:18] *** Joins: ghrust (ghrust@DE823A67.6A2AE50.F3114085.IP)
[00:41:19] <ghrust> 01[13rust01] 15bors pushed 4 new commits to 06auto: 02http://git.io/O4GCJA
[00:41:19] <ghrust> 13rust/06auto 144600212 15Alex Crichton: Fix inner statics having the same symbol name...
[00:41:19] <ghrust> 13rust/06auto 1436a4af4 15Alex Crichton: Remove __extensions__ in names for a "pretty name"...
[00:41:19] <ghrust> 13rust/06auto 141ac321d 15Alex Crichton: Improve name mangling for gdb...
[00:41:21] *** Parts: ghrust (ghrust@DE823A67.6A2AE50.F3114085.IP) ()
[00:41:37] <miza> engla: i like filter, is more elegant
[00:42:59] <tikue_> same
[00:43:01] *** Joins: samx (sami@moz-D9DA5773.dyn.optonline.net)
[00:43:13] <engla> a stepped loop can be done with counter though
[00:44:18] <tikue_> engla: how so?
[00:44:44] <engla> range_step(lo, hi, step) is approx count(lo, step).take_while(|x| *x < hi)
[00:44:56] <engla> or I guess it's exactly that
[00:45:09] <tikue_> ah good point
[00:45:28] <tikue_> for some reason i was imagining count() didn't return a value but was silly
[00:45:40] *** Joins: Yurume (yurume@AC58A8CE.8A059B47.E313B915.IP)
[00:45:44] <strcat> acrichto: oh nice no more evil unreadable extension method paths
[00:45:49] * strcat hates those
[00:46:02] <benh> hm?
[00:46:09] <benh> nice
[00:46:13] <acrichto> strcat: it works in some cases, not all sadly
[00:46:22] <acrichto> impl @A would still have __extensions__
[00:46:48] <miza> i like that the rust comminity cares about elegant code :)
[00:47:55] *** Quits: steveklabnik (steveklabn@moz-5EF6C37C.socal.res.rr.com) (Quit: bye!)
[00:48:06] *** Quits: pepper_chico (pepper_chi@14AC4DFD.704EE6B0.E4090502.IP) (Quit: My MacBook Pro has gone to sleep. ZZZzzzâ€¦)
[00:49:18] <tikue_> heh
[00:49:29] *** Joins: pepper_chico (pepper_chi@14AC4DFD.704EE6B0.E4090502.IP)
[00:49:48] *** Quits: josh (josh@moz-348C4790.hsd1.mn.comcast.net) (Quit: josh)
[00:50:04] <benh> What's the difference between impl @A { fn f(self... and impl A { fn f(@self...?
[00:50:18] *** Quits: engla (engla@moz-DBD1D96E.cust.bredbandsbolaget.se) (Ping timeout)
[00:50:31] *** Joins: dherman (dherman@moz-6CA476B1.hsd1.ca.comcast.net)
[00:50:31] *** ChanServ sets mode: +ao dherman dherman
[00:50:39] *** Quits: heftig (heftig@moz-DB953191.dip0.t-ipconnect.de) (Ping timeout)
[00:50:40] <kmc> miza: what do you mean by that specifically?
[00:51:03] <tikue_> kmc: i think it was reference to iterator method chaining
[00:51:31] <tikue_> range(0, 20).filter(), count(0, 2).takewhile() etc
[00:51:42] <kimundi> benh: well, for starters the first one can't be currently written ;)
[00:51:49] <benh> oh, good
[00:52:05] <kimundi> because @T is not defined in a library but by the compiler
[00:52:06] *** Joins: six600110 (six600110@moz-2FA48202.neo.res.rr.com)
[00:52:12] *** Quits: mihneadb_ (mihneadb@moz-BE33DA21.fw1.sfo1.mozilla.net) (Connection reset by peer)
[00:52:17] <benh> rusti: struct S; impl @S { fn f(self) {}}
[00:52:20] -rusti- pastebinned 8 lines of output: http://ix.io/7R9
[00:52:23] *** Joins: mihneadb (mihneadb@moz-BE33DA21.fw1.sfo1.mozilla.net)
[00:52:41] <miza> kmc: yes, i mean that tikue_ said
[00:53:29] <tikue_> unfortunately, elegant code is rarely optimal. or maybe i shouldn't say rarely, but frequently not optimal
[00:54:11] <Earnestly> I guess that statement makes Kernighan wrong
[00:54:25] <miza> tikue_ i agree, but you can have some suggar in your code
[00:54:26] <dbaupp> kimundi: impl Foo for @T { .. } does work though
[00:54:29] <dbaupp> benh: ^
[00:54:44] <kmc> I have a kind of negative reaction to the term "elegant code" because I associate it with, like, Ruby libraries that bend over backwards to make the code read kinda like English, but have incoherent semantics as a result
[00:54:45] <ChrisMorgan> r? https://github.com/mozilla/rust/pull/8984 (nice and quick and simple)
[00:54:46] <benh> if Foo is my trait, right?
[00:54:57] <benh> not for someone else's trait Foo and my type T?
[00:54:57] <kmc> iterator method chaining is good, though :)
[00:55:00] <dbaupp> benh: yeah
[00:55:10] <tikue_> kmc: i don't think elegance necessarily has to do with syntax
[00:55:21] <benh> I'm still kinda thinking this iterator method chaining thing should have a proper operator between the methods and not just function calls. Like some Haskell function composition thing.
[00:55:22] <kmc> but I'm glad we're getting rid of Â«do 5.timesÂ» :)
[00:55:26] <dbaupp> benh: well, it can be someone else's trait too.
[00:55:35] <benh> So we'd have first-class iterator pipelines or whatever
[00:55:37] <kimundi> dbaupp: SUre, but that'S nothing special. You can impl any trait for any type (as long as one of them is defined in your crate of course)
[00:55:39] <kmc> tikue_: I agree
[00:56:01] <tikue_> kmc: that's not special syntax though -- or at least, do isn't special to 5.times
[00:56:13] <tikue_> i'll be miserable if/when do spawn { } goes away in favor of spawn! macro
[00:56:22] <kmc> yeah agreed
[00:56:23] <Earnestly> It never has anything to do with syntax or are you refering to code that /looks/ pretty?
[00:56:27] <kimundi> impl Foo for Rc<Option<Either<uint, ~str>>> { ... }.... doesn'T matter :)
[00:56:48] <tikue_> Earnestly: it definitely can be syntax support at times. python is a beautiful language almost solely due to all the (imo) good syntax decisions
[00:57:06] <Earnestly> I disagree, yay.
[00:57:08] <tikue_> e.g. list comprehensions, yield generators
[00:57:39] <strcat> python is full of ugly hacks though
[00:57:46] <strcat> only looks good until you start actually dealing with those
[00:57:46] <miza> one big thing in code is maintaining
[00:57:57] <tikue_> strcat: sure, but it's still very pretty to look at much of the time
[00:58:01] <miza> things like iterators helpings readability
[00:58:12] <strcat> "don't use exceptions for flow control" falls apart when your iteration protocol is exception-based ;p
[00:58:18] <tikue_> haha
[00:58:32] <tikue_> luckily you usually don't have to explicitly implement an iterator object
[00:58:38] * tikue_ harkens back to yield
[00:58:46] * tikue_ really wants yield in rust and is happy it's reserved
[00:59:02] <strcat> python suffers from serious pain due to interfaces just being a convention, they're undocumented
[00:59:05] <Earnestly> tikue_: Elements of Programming Style, Practice of Programming and maybe Beautiful Code could provide a more solid grounding for defining elegance if you're interested.
[00:59:07] <strcat> so they added abstract base classes
[00:59:14] *** Quits: ofeldt (ofeldt@moz-E3B4877F.dip0.t-ipconnect.de) (Ping timeout)
[00:59:16] <strcat> but that's a huge pain and only covers the stdlib
[00:59:18] * strcat shrugs
[00:59:39] *** Quits: kimundi (kimundi@moz-A6FA77E4.dip0.t-ipconnect.de) (Ping timeout)
[00:59:50] <strcat> python is pragmatic with a great library ecosystem, but I wouldn't call it elegant :P
[01:00:01] *** Joins: kimundi (kimundi@moz-A6FA77E4.dip0.t-ipconnect.de)
[01:00:13] <tikue_> hmmâ€¦i don't know if i agree
[01:00:18] <tikue_> or rather
[01:00:28] *** Joins: ofeldt (ofeldt@moz-E3B4877F.dip0.t-ipconnect.de)
[01:00:30] <tikue_> i agree the language *itself* isn't necessarily elegant, but it allows for very elegant code
[01:00:44] <tikue_> perhaps that's a false dichotomy though
[01:00:47] <Earnestly> I think you need to define your terms if you want to discuss this heh
[01:00:58] <eevee> high SNR
[01:01:15] <tikue_> Earnestly: which terms do you take issue with?
[01:01:22] <strcat> tikue_: it's a dynamically typed language with generators, so is ecmascript6
[01:01:34] <strcat> and es6 actually has proper lexical scoping...
[01:02:07] <strcat> and "use strict" at least saves you from undeclared vars
[01:02:09] <tikue_> strcat: does python not have proper lexical scoping in py3k?
[01:02:20] <eevee> python has lexical scope in py2
[01:02:24] <strcat> tikue_: well it doesn't have block scope, and nonlocal/global are a hack
[01:02:27] <strcat> eevee: no, it doesn't
[01:02:31] <strcat> nonlocal == lexical scoping
[01:02:34] <eevee> "lexical" != "block"
[01:02:39] *** Quits: kimundi (kimundi@moz-A6FA77E4.dip0.t-ipconnect.de) (Ping timeout)
[01:02:39] <eevee> er
[01:02:40] <strcat> eevee: it's not lexical scoping in py2
[01:02:54] <strcat> they fixed it
[01:02:59] <strcat> but global/nonlocal keywords are awful
[01:03:05] <eevee> yyyes it is.  it's defined by the syntax, i.e., the lexer
[01:03:33] <strcat> doesn't var hoisting ruin that?
[01:03:45] <strcat> + closures do not work as you would expect
[01:03:46] <eevee> the problem you're referring to is that python declares with assignment
[01:03:55] <strcat> eevee: it doesn't actually
[01:04:00] <strcat> it hoists all declarations to the top of a function
[01:04:04] <tikue_> strcat: how do they not work as you would expect?
[01:04:05] <strcat> like js with 'var'
[01:04:17] <strcat> but js is getting a sane 'let'
[01:04:26] <strcat> alright I will write examples
[01:04:31] <strcat> means more than saying it ;p
[01:04:32] <eevee> javascript actively lies to you since it has explicit declaration
[01:04:56] <jack> i recently sat in on a programming languages class where they implemented python and js scoping rules. neither were straight lexical scoping.
[01:05:19] <eevee> (function() { "use strict"; console.log(a); var a; })()
[01:05:23] <eevee> this is legal javascript
[01:05:27] <eevee> it is not legal python
[01:05:29] *** Quits: miloshadzic (miloshadzi@F8195CC5.425C93D4.449B8A48.IP) (Quit: My MacBook has gone to sleep. ZZZzzzâ€¦)
[01:05:32] <eevee> (modulo syntax)
[01:05:33] <strcat> def foo():
[01:05:34] <strcat>     x
[01:05:38] <strcat> NameError: global name 'x' is not defined
[01:05:43] <strcat> def foo():
[01:05:45] <strcat>     x
[01:05:47] <strcat>     x = 5
[01:05:49] <strcat> UnboundLocalError: local variable 'x' referenced before assignment
[01:05:59] <kmc> we are veering away from being Rust-related here
[01:06:10] *** Parts: thesnowdog (doug@15B51297.CDB23781.6F17036B.IP) (WeeChat 0.4.1)
[01:06:16] <benh> pft, it's comparative programming language studies
[01:06:19] <benh> totally on topic!
[01:06:28] <kmc> I agree to a point; also I did kind of start this convo ;P
[01:06:40] <jack> benh: are we comparing things to rust or not? i missed that part :)
[01:06:47] <mm> I neeeeed rust to emscripten to work one of these days.  Writing JS makes me sad :P
[01:06:52] <strcat> well, I should have declared x as a real global
[01:06:57] <benh> we're trying to clarify terminology :D
[01:07:04] <strcat> then the first example works
[01:07:06] <strcat> but the 2nd example fails
[01:07:13] <kmc> mm: I don't understand using a low-level language with explicit allocation and then compiling it to JS
[01:07:14] <eevee> strcat: the actual reason is about performance and the VM bytecode and blah blah words
[01:07:28] <jack> kmc: TypedArrays for the win.
[01:07:32] <kmc> heh.
[01:07:39] <tikue_> jack: miza asked about rust's syntax for the `continue` idiom, then after he was introduced to iterator method chaining he commented on how rust can be quite elegant, to which kmc wanted to know what he specifically meant, presumably taking issue with the overloadedness of the term `elegant`, and henceforth 
[01:07:41] <strcat> eevee: 60x slower than C and they have worse scoping than C? :p
[01:07:48] * strcat shrugs
[01:07:56] <strcat> js and lua can do it properly
[01:08:00] <strcat> and they're much faster
[01:08:11] <strcat> (js as in mozilla js, not silly es5)
[01:08:16] <mm> kmc: I like strong static guarantees.  I'd take other languages in the browsre too, I just don't like JS.
[01:08:21] <kmc> sure
[01:08:31] <strcat> and 'nonlocal' is the same thing
[01:08:39] <strcat> except nonlocal didn't exist in python2
[01:08:47] <tikue_> still doesn't right?
[01:09:05] <ChrisMorgan> nonlocal is a Python 3 keyword
[01:09:09] <tikue_> right
[01:09:14] <eevee> my kingdom for a __future__
[01:09:17] <strcat> tikue_: well py2 is as dead as windows xp, so I speak about it in the past tense ;p
[01:09:23] <tikue_> strcat: that's simply not true
[01:09:27] <tikue_> strcat: dropbox is still on 2.7
[01:09:32] <kmc> most projects still are
[01:09:33] <strcat> tikue_: lots of people are still on XP
[01:09:36] <eevee> yelp is still on 2.6
[01:09:39] <ChrisMorgan> strcat: very well put
[01:09:42] <tikue_> heh
[01:10:05] <kmc> Django just added support for py3 in the last year, in an experimental capacity
[01:10:12] <tikue_> pypy, etc...
[01:10:16] <tikue_> no one is using py3 yet
[01:10:18] <tikue_> afaik
[01:10:20] <strcat> kmc: sure, and other web frameworks that are sane had it years ago
[01:10:24] <strcat> ;p
[01:10:29] *** Joins: sankha93 (Instantbir@7061CD01.D6BD0D91.22D41759.IP)
[01:10:30] *** Joins: eatkinson (eatkinson@moz-DC7CD72F.airbears2.berkeley.edu)
[01:10:36] <kmc> let's not have an argument about Python web frameworks
[01:10:38] <kmc> in #rust
[01:10:46] *** Joins: ghrust (ghrust@DE823A67.6A2AE50.F3114085.IP)
[01:10:47] <ghrust> 01[13rust01] 15bors 04force-pushed 06auto from 14f5ccc4e to 14b161e09: 02http://git.io/N3iJvQ
[01:10:47] *** Parts: ghrust (ghrust@DE823A67.6A2AE50.F3114085.IP) ()
[01:10:49] *** Joins: ghrust (ghrust@9C8B94D4.6A2AE50.F3114085.IP)
[01:10:49] <ghrust> 01[13rust01] 15bors pushed 3 new commits to 06auto: 02http://git.io/tX5sug
[01:10:49] <ghrust> 13rust/06auto 140f3c87e 15Felix S. Klock II: Revise path.rs API to not allocate ~str so much....
[01:10:49] <ghrust> 13rust/06auto 147f834c5 15Felix S. Klock II: Update clients of path.rs to use new API....
[01:10:50] <ghrust> 13rust/06auto 148827b94 15bors: auto merge of #8978 : pnkfelix/rust/make-path-api-less-allocation-happy, r=huonw...
[01:10:52] *** Parts: ghrust (ghrust@9C8B94D4.6A2AE50.F3114085.IP) ()
[01:10:59] <kmc> sane or not, Django is tremendously popular and should give some indication of whether the Python community at large has embraced python 3 or not
[01:10:59] * ChrisMorgan wishes more things supported Python 3â€”it's a nicer language than Python 2.
[01:11:16] *** Joins: josh (josh@moz-348C4790.hsd1.mn.comcast.net)
[01:11:25] <tikue_> kmc++. anyway, i still think python lends itself to very elegantly written code, insomuch as elegance is terseness and readability
[01:11:25] *** Quits: matt444 (matthew@moz-CFC97445.wi.res.rr.com) (Quit: leaving)
[01:11:30] <tikue_> ChrisMorgan: agreed
[01:11:51] <kmc> but too much focus on terseness and readability produces magic "guess what I mean" libraries
[01:11:56] <kmc> with complicated / incoherent semantics
[01:12:04] <kmc> Python community seems better than some at restraining itself in this way
[01:12:11] <kmc> "explicit is better than implicit" and all that
[01:12:34] <miza> kmc: haha how we go from some elegant stuff to python web framework :p
[01:12:35] <kmc> I guess I would say that "readability" has to include really understanding what each part of what you're reading does, and not just "it looks nice"
[01:12:37] *** Quits: Samulus (sam@moz-212ECDA5.phnx.qwest.net) (Quit: WeeChat 0.4.1)
[01:12:47] <tikue_> kmc: absolutely
[01:12:50] <kmc> but some tend to focus on the latter (Wadler's Law?)
[01:12:53] <tikue_> that's what makes it elegant and not obtuse :P
[01:12:55] <strcat> http://ix.io/7Rb this is all that really comes to my mind when I think about py2
[01:12:58] *** Quits: Sorella (queen@9D963F5D.DF5D8AE7.54BCAB54.IP) (Quit: G'night everynyan~!)
[01:13:09] <tikue_> strcat: ...wow
[01:13:11] <strcat> I don't know why people rag on js so much more
[01:13:17] *** Quits: josh (josh@moz-348C4790.hsd1.mn.comcast.net) (Quit: josh)
[01:13:23] <tikue_> strcat: i'm assuming it's comparing memory?
[01:13:25] <strcat> tikue_: no
[01:13:35] <tikue_> what is it then :|
[01:13:38] <jack> how do I un xfail a test?
[01:13:39] <strcat> I don't remember
[01:13:46] <jack> move it from xfail to run-pass?
[01:13:46] <strcat> something weird about the total ordering over all types
[01:13:47] <Earnestly> tikue_: fwiw, quite a lot of libraries are now using python3, lxml, requests, pygments, flask, gunicorn, sphinx, doc... yeah
[01:13:48] <miza> strcat: i hate that we have stack with this lang in browser
[01:13:52] <kmc> strcat: http://web.archive.org/web/20120103190943/http://web.mit.edu/rwbarton/www/python.html
[01:14:01] <miza> we dont have event the ability to select
[01:14:07] <tikue_> Earnestly:  fair enough. not enough imo :) what's numpy's status on py3?
[01:14:08] <kmc> i *love* #4 here
[01:14:08] <miza> even*
[01:14:29] <Earnestly> tikue_: numpy is on py3
[01:14:32] <dbaupp> tikue_: iirc, both numpy and scipy are ported
[01:14:43] <strcat> python's 'x > y > z' is great though :P
[01:14:46] *** Quits: riley (riley@8BA43816.9AA11D69.65DDFA89.IP) (Client exited)
[01:14:51] <tikue_> oooh, that's excellent! i didn't realize
[01:14:53] <tikue_> strcat: yeah it is
[01:14:54] <benh> haha
[01:15:12] <benh> Does it also have x > y == a > b etc
[01:15:24] <kmc> that's what #4 is about... "word" in [] == False
[01:15:37] <kmc> is neither ("word" in []) == False  nor  "word" in ([] == False)
[01:15:46] <kmc> but rather ("word" in []) and ([] == False)
[01:15:50] <strcat> benh: well, 'a < b < c < d' turns to 'a < b and b < c and c < d'
[01:16:00] <strcat> it's a simple parsing thing
[01:16:07] <strcat> but it lets you write more mathy conditions
[01:16:18] *** Quits: azita (Azita@moz-BBE3ABD.mv.mozilla.com) (Quit: azita)
[01:16:20] <kmc> I'm not a fan of that feature personally
[01:16:21] <dbaupp> and it only evaluates each expression once
[01:16:21] <tikue_> strcat: i think it's id
[01:16:36] <strcat> tikue_: try making them inherit from object like all py3 objects though
[01:16:40] <tikue_> strcat: https://gist.github.com/tikue/9efc99839ef299b608b2
[01:17:26] <tikue_> kmc: but that's not idiomatic anyway
[01:17:30] *** Quits: lerc (quassel@B2E8CAD3.A8D14E52.788638A4.IP) (Ping timeout)
[01:17:44] <strcat> tikue_: but look at 2 < "foo", or something similar
[01:17:49] <tikue_> if you want ("word" in []) == False it's just "word" not in []
[01:18:04] <kmc> sure
[01:18:06] <tikue_> strcat: i think builtins have an ordering hierarchy no?
[01:18:08] <strcat> >>> True + True < "foo"
[01:18:10] *** Quits: MrFahrenheit (RageOfThou@3FEF494C.29C984D5.783DEDCA.IP) (Ping timeout)
[01:18:10] <strcat> True
[01:18:12] <tikue_> kmc: not disagreeing though. it's terrible :P
[01:18:17] <strcat> tikue_: yeah but it's supposed to be pluggable
[01:18:18] <kmc> the point is just that they allow this for any comparison operators, even ones that don't make sense like x < y < z
[01:18:20] <strcat> that's why that weird stuff happens
[01:18:23] <strcat> I just forget how to do it
[01:19:04] <tikue_> kmc: yeah agreed, it shouldn't be all of them. though i guess that's just us humans being arbitrary
[01:19:25] <tikue_> one thing i do like is how python makes everything have a boolean value
[01:19:34] <tikue_> anywayâ€¦what channel is this? 
[01:19:36] *** Joins: lerc (quassel@B2E8CAD3.A8D14E52.788638A4.IP)
[01:19:54] *** Joins: jdsanders (Adium@moz-B46AE510.hfc.comcastbusiness.net)
[01:19:55] *** Parts: jdsanders (Adium@moz-B46AE510.hfc.comcastbusiness.net) ()
[01:20:39] <strcat> it's #stealing-ideas-from-other-languages-and-learning-from-their-mistakes ;p
[01:20:47] <kmc> whose house? rust's house!
[01:20:52] <tikue_> haha
[01:20:57] <benh> strcat: that's in the mission statement, isn't it
[01:21:03] <Earnestly> You mean learning from the past?  We don't do that in the computing industry, what nonsense is this?
[01:21:06] <tikue_> rust-lang is best-lang!
[01:21:34] <eevee> right, so, don't do things that python3 removed  :P
[01:21:37] <benh> yeah well learning from the future only works in python
[01:21:45] <tikue_> lol
[01:21:49] <Earnestly> haha
[01:22:04] <Earnestly> I hope that was a __future__ joke
[01:22:24] <benh> that was the intention :)
[01:22:28] *** Joins: matthew (matthew@moz-CFC97445.wi.res.rr.com)
[01:22:31] *** Quits: miza (miza@moz-4DD51325.home.otenet.gr) (Input/output error)
[01:22:33] *** matthew is now known as matt44
[01:22:42] <matt44> where is the documentation that shows how to import a module?
[01:22:57] <kmc> http://static.rust-lang.org/doc/tutorial.html#crates-and-the-module-system I suppose
[01:23:09] *** Joins: enix (enix@moz-A50569DD.c3-0.slvr-ubr1.lnh-slvr.md.cable.rcn.com)
[01:23:18] *** Joins: DAddYE (DAddYE@moz-98D3933F.hsd1.ca.comcast.net)
[01:23:54] *** Joins: lkuper_ (lkuper@moz-C0CD33ED.hsd1.in.comcast.net)
[01:25:05] *** Joins: dwrensha (chatzilla@moz-AA82FBAF.hsd1.wa.comcast.net)
[01:25:11] <matt44> is there a "typeof" in rust?
[01:25:24] <dbaupp> matt44: not yet
[01:25:31] <kmc> what do you want to do with it?
[01:25:32] <strcat> well what do you mean by typeof?
[01:25:43] <matt44> @kmc find the type of something :)
[01:25:44] <strcat> if you mean like decltype in C++11, then no, but bblum did reserve the keyword
[01:25:48] <kmc> matt44: not an answer ;)
[01:25:49] <strcat> matt44: and do what with it?
[01:25:56] *** Quits: infynyxx (infynyxx@DB780A29.749BA1D.DCC373F0.IP) (Client exited)
[01:25:59] <matt44> let nums = [1, 2, 3];
[01:26:01] <strcat> let x: decltype(some_expr) = foo(); ?
[01:26:04] <matt44> nums == typeof what/
[01:26:05] <matt44> ?
[01:26:20] <strcat> so do you just want to print it for debugging?
[01:26:20] <dbaupp> rusti: let typeof = 1;
[01:26:20] -rusti- <anon>:5:13: 5:19 error: `typeof` is a reserved keyword
[01:26:21] -rusti- <anon>:5          let typeof = 1;
[01:26:21] -rusti-                       ^~~~~~
[01:26:21] -rusti- application terminated with error code 101
[01:26:25] <strcat> you can print it
[01:26:27] <strcat> I added that
[01:26:34] <benh> the type?
[01:26:36] <strcat> yes
[01:26:43] <matt44> strcat: yes
[01:26:49] <strcat> it is in the tydesc, it's a private detail for debugging
[01:26:51] <benh> swell, i thought that was a thing and then couldn't figure out how to do it convinced myself it wasn't actually possible
[01:26:57] <strcat> it's meant to be hard
[01:27:03] <dbaupp> rusti: let nums = [1,2,3]; let () = nums;
[01:27:04] -rusti- <anon>:5:33: 5:35 error: mismatched types: expected `[<VI2>, .. 3]` but found `()` (expected vector but found ())
[01:27:04] -rusti- <anon>:5          let nums = [1,2,3]; let () = nums;
[01:27:04] -rusti-                                           ^~
[01:27:04] -rusti- error: aborting due to previous error
[01:27:04] -rusti- application terminated with error code 101
[01:27:15] <dbaupp> (that error message also works.)
[01:27:28] *** Quits: DAddYE (DAddYE@moz-98D3933F.hsd1.ca.comcast.net) (Ping timeout)
[01:27:45] <strcat> rusti: use std::unstable::intrinsics::get_tydesc; unsafe { get_tydesc::<int>() }
[01:27:46] -rusti- (0x60b020 as *())
[01:27:48] <matt44> dbaupp that doesn't tell me the type...
[01:27:53] <strcat> rusti: use std::unstable::intrinsics::get_tydesc; unsafe { (*get_tydesc::<int>()).name }
[01:27:53] -rusti- "int"
[01:28:15] <strcat> and you could write a function taking a generic value and printing the type
[01:28:16] <dbaupp> matt44: yeah it does: `expected `[<VI2>, .. 3]`` is the type
[01:28:35] <matt44> The type of <VI2> ?
[01:28:43] <strcat> it's not a concrete type yet
[01:28:49] <strcat> integer/float literals are generic
[01:28:52] <matt44> ?
[01:29:00] <strcat> they infer the type based on how they are used
[01:29:06] <strcat> let x = 5; x + 2
[01:29:09] <strcat> x is an int
[01:29:11] <strcat> let x = 5; x + 2u
[01:29:13] <strcat> x is a uint
[01:29:32] <dbaupp> rusti: let nums = [1,2,3]; let () = nums; / * help the inference engine */ 1i + nums[0]
[01:29:32] -rusti- <anon>:5:44: 5:45 error: unexpected token: `/`
[01:29:32] -rusti- <anon>:5          let nums = [1,2,3]; let () = nums; / * help the inference engine */ 1i + nums[0]
[01:29:32] -rusti-                                                      ^
[01:29:32] -rusti- application terminated with error code 101
[01:29:47] <dbaupp> rusti: let nums = [1,2,3]; let () = nums; /* help the inference engine */ 1i + nums[0]
[01:29:47] -rusti- <anon>:5:33: 5:35 error: mismatched types: expected `[<VI2>, .. 3]` but found `()` (expected vector but found ())
[01:29:48] -rusti- <anon>:5          let nums = [1,2,3]; let () = nums; /* help the inference engine */ 1i + nums[0]
[01:29:48] -rusti-                                           ^~
[01:29:48] -rusti- error: aborting due to previous error
[01:29:48] -rusti- application terminated with error code 101
[01:29:53] <strcat> rusti: let mut xs = ~[]; xs.push(5); xs
[01:29:53] -rusti- ~[5]
[01:30:00] <dbaupp> :( it didn't work
[01:30:06] <strcat> rusti: let mut xs = ~[]; xs /* no place to infer the type */
[01:30:09] -rusti- pastebinned 6 lines of output: http://ix.io/7Rd
[01:30:19] <matt44> let nums = [1, 2, 3];
[01:30:21] <matt44> let sum = nums.iter().fold(0, | acc, n | acc + n );
[01:30:34] <matt44> >>> error: mismatched types: expected `<VI3>` but found `&<VI2>` (expected &-ptr but found integral variable)
[01:30:37] <tikue_> kmc: looking at the python quiz. what the HECK is going on in 1a?
[01:30:49] <strcat> matt44: iter() on vectors yields &T
[01:30:53] <strcat> where T is the type in the vector
[01:31:03] <strcat> so it's telling you it expected T but found &T
[01:31:12] <matt44> strcat: Exactly, which is why I want to know the type in the vector :)
[01:31:12] <strcat> it's a generic integer literal, it has no concrete type
[01:31:17] <strcat> matt44: there isn't one yet
[01:31:32] <strcat> <VI#> is the type
[01:31:37] <matt44> so i can't iterate it? that's unfortunate
[01:31:40] <benh> i'd be a fan of having {:?} print the type
[01:31:41] <kmc> tikue_: you're closing over a mutable cell, not a value
[01:31:44] <strcat> matt44: you can iterate it
[01:31:47] <strcat> never said you couldn't
[01:31:56] <strcat> I said iter yields &T, not T
[01:31:56] <matt44> compiler says i can't
[01:31:58] <tikue_> kmc: oh god...
[01:32:03] <strcat> matt44: the compiler says it needs T, not &T
[01:32:04] <kmc> people often use this as an example of Python scope sucking, but really the same thing happens in Scheme if you faithfully translate the for loop
[01:32:15] <strcat> matt44: this is the error you are getting:
[01:32:17] <strcat> rusti: &5 + 2
[01:32:19] -rusti- pastebinned 35 lines of output: http://ix.io/7Re
[01:32:26] <strcat> rusti: 5 + &2
[01:32:26] -rusti- <anon>:5:13: 5:15 error: mismatched types: expected `<VI0>` but found `&<VI1>` (expected integral variable but found &-ptr)
[01:32:27] -rusti- <anon>:5          5 + &2
[01:32:27] -rusti-                       ^~
[01:32:27] -rusti- error: aborting due to previous error
[01:32:27] -rusti- application terminated with error code 101
[01:32:57] <tikue_> kmc: is there not a way to get around that? 
[01:33:09] <strcat> rusti: 5 + *&2
[01:33:09] -rusti- 7
[01:33:17] <benh> what
[01:33:33] <strcat> rusti: 5 + *&*&*&2
[01:33:33] -rusti- 7
[01:33:36] <benh> rusti: &5i + 2i
[01:33:37] -rusti- 7
[01:33:42] <benh> rusti: &5 + 2
[01:33:44] <strcat> it's from auto-deref
[01:33:44] -rusti- pastebinned 35 lines of output: http://ix.io/7Re
[01:33:55] <benh> rusti: *&5 + 2
[01:33:55] -rusti- 7
[01:33:57] <matt44> so how do i fix it?
[01:34:07] <benh> why does it happily pick an integer type if it doesn't have to autoderef?
[01:34:12] <dbaupp> rusti: *&1
[01:34:13] -rusti- 1
[01:34:16] <strcat> matt44: you have 'T + &T', it needs to be the same type on each side
[01:34:20] <strcat> so turn
[01:34:22] <strcat> rusti: 2 + &2
[01:34:22] -rusti- <anon>:5:13: 5:15 error: mismatched types: expected `<VI0>` but found `&<VI1>` (expected integral variable but found &-ptr)
[01:34:22] -rusti- <anon>:5          2 + &2
[01:34:23] -rusti-                       ^~
[01:34:23] -rusti- error: aborting due to previous error
[01:34:23] -rusti- application terminated with error code 101
[01:34:24] <strcat> into
[01:34:26] *** Joins: Ralith (ralith@114DA04D.CD83ED0A.BCDF04A6.IP)
[01:34:26] <strcat> rusti: 2 + *&2
[01:34:27] -rusti- 4
[01:34:59] *** Quits: eatkinson (eatkinson@moz-DC7CD72F.airbears2.berkeley.edu) (Quit: eatkinson)
[01:35:14] <matt44> hanks
[01:35:15] <matt44> thanks
[01:35:48] <strcat> rusti: let xs = [1, 2]; xs.iter().fold(0, |a, &b| a + b)
[01:35:49] -rusti- 3
[01:35:58] <strcat> rusti: range(0, 3).fold(0, |a, b| a + b)
[01:36:00] -rusti- 3
[01:36:20] <strcat> range there is Iterator<int>, the vec iterator is Iterator<&int>
[01:37:18] <kmc> tikue_: define 'good'. usually I would make a function call, creating a new environment frame
[01:37:35] <kmc> it's the same in scheme except that you have 'let' as sugar
[01:37:59] <tikue_> kmc: i didn't say it had to be good haha
[01:38:18] *** Joins: SingingBoyo (brandon@4DF3381A.51F4D838.4F048BDC.IP)
[01:39:35] <kmc> haha okay I just misread
[01:41:07] *** Joins: eatkinson (eatkinson@moz-DC7CD72F.airbears2.berkeley.edu)
[01:41:35] *** Quits: matt44 (matthew@moz-CFC97445.wi.res.rr.com) (Quit: Lost terminal)
[01:41:55] <kmc> in this case adders.append((lambda j: lambda x: x+j)(i))
[01:42:27] <kmc> which is... not beautiful, but it works
[01:46:16] * kmc -> afk
[01:47:28] *** Quits: pepper_chico (pepper_chi@14AC4DFD.704EE6B0.E4090502.IP) (Quit: My MacBook Pro has gone to sleep. ZZZzzzâ€¦)
[01:48:23] *** Quits: carllerche (carllerche@6B070D22.7E6A0813.1428D117.IP) (Quit: carllerche)
[01:49:06] *** Quits: mihneadb (mihneadb@moz-BE33DA21.fw1.sfo1.mozilla.net) (Input/output error)
[01:50:19] <dwrensha> Is it possible to put constraints on the Self parameter of a trait?
[01:50:52] <dwrensha> Here's an example: https://gist.github.com/dwrensha/3b7ee4b33cbc47dd174a
[01:52:39] *** Quits: SingingBoyo (brandon@4DF3381A.51F4D838.4F048BDC.IP) (Ping timeout)
[01:53:02] *** Joins: Sorella (queen@9D963F5D.DF5D8AE7.54BCAB54.IP)
[01:53:49] <dbaupp> dwrensha: trait Foo: std::num::Zero { } 
[01:54:06] <dbaupp> it's called trait inheritance, i.e. anything that implements Foo must also implement Zero.
[01:55:06] *** Joins: SingingBoyo (brandon@4DF3381A.51F4D838.4F048BDC.IP)
[01:55:38] <dwrensha> Ah, that gets me a bit farther...
[01:56:23] *** Joins: matt (Mibbit@moz-3AB1E206.nycmny.fios.verizon.net)
[01:57:18] <dwrensha> But now looks like default methods don't work the way I expect.
[01:57:26] <dwrensha> (The gist has been updated.)
[01:57:33] *** Quits: eatkinson (eatkinson@moz-DC7CD72F.airbears2.berkeley.edu) (Quit: eatkinson)
[01:57:42] *** Quits: azakai_ (alon@moz-BBE3ABD.mv.mozilla.com) (Quit: Ex-Chat)
[01:58:31] <matt> is it true(ie am i reading it right?) that the current std::rt::io::net is backed by libuv? is it preferred to use std:rt:io::net or std::rt::uv directly?
[01:58:36] <a_m0d|home> Is there any up to date information on reading files?
[01:58:43] *** a_m0d|home is now known as a_m0d
[01:58:47] *** Joins: matt444 (matthew@moz-CFC97445.wi.res.rr.com)
[01:58:57] <a_m0d> The stuff on the wiki is quite old (~0.4)
[01:59:01] <matt444> how do i parse a string to a double?
[01:59:10] <a_m0d> I'd prefer some info that doesn't require @
[01:59:35] <lkuper_> dwrensha: you were hoping that the impl of Foo for u16 would automatically imply one for u8?
[01:59:53] <dbaupp> matt: std::rt::io::net is the (eventual) public interface
[02:00:09] <dwrensha> No, I was hoping that since u8 implements Zero, that it would use the default method
[02:00:19] <matt444> dbaupp thanks
[02:01:02] <dbaupp> rusti: let x: float = FromStr::from_str("12.34"); x
[02:01:03] <lkuper_> dwrensha: Oh, I see.
[02:01:06] -rusti- pastebinned 7 lines of output: http://ix.io/7Rg
[02:01:27] <dbaupp> rusti: let x: float = FromStr::from_str("12.34").unwrap(); x
[02:01:28] -rusti- 12.34
[02:01:39] <dbaupp> matt444: ^
[02:01:47] <matt444> what does the unwrap do?
[02:02:42] <dbaupp> extract the Some(x) from an Option; it'll fail if the Option is None.
[02:02:51] <matt444> oh, nice
[02:03:22] *** Joins: ChrisMorgan1 (chris@moz-80C478D2.its.monash.edu.au)
[02:03:36] <dbaupp> you can use .expect("nice error message") too, `match foo { Some(x) => .., None => .. }`, or even methods like map_move and chain.
[02:03:39] <matt444> so you can use match on from_str before to check if Some(x)
[02:03:50] <matt444> yeah
[02:04:06] <matt444> i like it
[02:04:13] <lkuper_> dwrensha: I think you still need an empty `impl Foo for u8 { }` although you don't need any methods in it.
[02:04:25] *** Quits: ChrisMorgan (chris@moz-F0B57727.its.monash.edu.au) (Ping timeout)
[02:04:38] <strcat> remember you can do generic impls
[02:04:43] <strcat> trait Foo: Bar { ... }
[02:04:45] *** Joins: cmr_ (Mibbit@moz-8821CF79.sclab.clarkson.edu)
[02:04:48] <strcat> impl<T: Bar> Foo for T {}
[02:05:15] *** Quits: dbaupp (Thunderbir@moz-EAA09AEF.lns20.syd7.internode.on.net) (Ping timeout)
[02:05:23] <dwrensha> Ah. That helps.
[02:05:42] <lkuper_> Yeah, you can do that.
[02:06:04] <dwrensha> But I can't have overlapping instances, right?
[02:06:10] *** Quits: SingingBoyo (brandon@4DF3381A.51F4D838.4F048BDC.IP) (Ping timeout)
[02:06:23] <strcat> dwrensha: well they can overlap but you can't actually use them for a type where they overlap
[02:06:54] <strcat> like you have have an impl for Bar and also for Baz, but if a type impls both Bar and Baz it will be ambiguous
[02:07:12] *** Joins: SingingBoyo (brandon@4DF3381A.51F4D838.4F048BDC.IP)
[02:07:13] <dwrensha> Right, I was running into that earlier
[02:07:54] <dwrensha> and I was hoping that a default method would save me from writing out a bunch of impls
[02:08:30] <strcat> problem is that it's not implied that a type implements a trait simply because that trait inherits from it
[02:08:53] <strcat> like if you had 'trait Integer: Add + ...', just because a float impls those doesn't mean it's an Integer
[02:09:08] <strcat> there can be guarantees that are semantic, but not expressed as type system requirements
[02:09:54] <lkuper_> yeah, I was just trying to write a version of dwrensha's code that was more concise, and I can't seem to come up with a good way that doesn't end up with conflicting impls, aside from the empty impl for u8.
[02:10:28] *** Quits: matt444 (matthew@moz-CFC97445.wi.res.rr.com) (Quit: leaving)
[02:11:05] *** Quits: cmr_ (Mibbit@moz-8821CF79.sclab.clarkson.edu) (Quit: http://www.mibbit.com ajax IRC Client)
[02:11:06] <strcat> in theory I think something like '#[implicit] trait Foo: Bar { ... }' could exist, but maybe there will end up being a saner way to do it without a hack like that
[02:11:16] * strcat doesn't know a lot about type systems
[02:11:50] <lkuper_> what would #[implicit] mean?
[02:12:03] <strcat> lkuper_: implicitly impl'ed for anything satisfying the inheritance part
[02:12:08] <strcat> (all methods have to be default)
[02:12:45] <strcat> ofc you have to worry about the whole coherence thing :P
[02:12:59] <strcat> but I think you could just inline it into crates as-used
[02:13:08] <strcat> (I guess all generics are done that way...)
[02:13:21] <olsonjeffery> ChrisMorgan1: ping
[02:13:25] *** Joins: alisdair (textual@1697D94C.7742FB18.FBC8476D.IP)
[02:13:26] <ChrisMorgan1> olsonjeffery: pong
[02:13:26] <SingingBoyo> couldn't one do something like impl<T:Add + ...> Integer for T {}?  or is there something I'm missing here?
[02:14:06] *** Quits: austincheney (quassel@8276C73B.985A737F.603BFF2.IP) (Connection reset by peer)
[02:14:10] <strcat> SingingBoyo: yes, you can do generic impls
[02:14:15] *** Joins: austincheney (quassel@8276C73B.985A737F.603BFF2.IP)
[02:14:16] * strcat forgets what the problem actually was
[02:14:17] <olsonjeffery> ChrisMorgan1: howdy.. we were discussing std::rt::io earlier and i was asking for ways to validate the API.. brson mentioned you as someone who's been using it quite a bit in your work and that you had some feedback
[02:14:25] <dwrensha> SingingBoyo: the wrinkle is that I want a special case for one instance of T
[02:14:29] <dwrensha> u16 in my example
[02:14:41] <olsonjeffery> just rt::io in general. we're looking at maybe-kinda-sorta approaching the beggining of considering the eventual removal of std::io
[02:14:48] <olsonjeffery> so im interested in hearing how to tighten up rt::io
[02:15:32] <ChrisMorgan1> olsonjeffery: buffering is, I think, the biggest need. That's in the issues list already; I'm contemplating tackling it (I've already implemented buffering in rust-http) next week.
[02:15:46] *** Joins: ghrust (ghrust@2EE61FCC.6A2AE50.F3114085.IP)
[02:15:46] <ghrust> 01[13rust01] 15bors merged 06auto into 06master: 02http://git.io/tX5sug
[02:15:46] *** Parts: ghrust (ghrust@2EE61FCC.6A2AE50.F3114085.IP) ()
[02:16:18] <olsonjeffery> ChrisMorgan1: just generic in-mem buffering atop any stream? or buffering for a specific instance (like TcpSteam | FileStream) ?
[02:16:29] <ChrisMorgan1> Generic.
[02:16:31] <SingingBoyo> dwrensha: ah okay.  I'd say allowing specialized impls would be better than #[implicit], as interesting as that might be.
[02:16:33] * olsonjeffery nods
[02:16:40] <ChrisMorgan1> c.f. https://github.com/chris-morgan/rust-http/blob/f78236284b73ba5e980962b1ffbd71ea9a03fbbc/src/libhttp/buffer.rs
[02:16:53] <olsonjeffery> yeah.. need buffering for the high-level readline() type stuff
[02:17:03] <SingingBoyo> but yeah I can't think of a way to do that at the moment.
[02:17:45] <ChrisMorgan1> When something like socket.write("\r\n") will send an entire TCP packet with just those two bytes of content, you know you need buffering.
[02:17:56] *** Joins: eatkinson (eatkinson@moz-1047CAB3.airbears2.berkeley.edu)
[02:18:08] *** Quits: q66 (q66@6EE9DE40.46454B5D.33AABD5F.IP) (Quit: Leaving)
[02:18:09] *** Parts: eatkinson (eatkinson@moz-1047CAB3.airbears2.berkeley.edu) ()
[02:18:12] *** Joins: eatkinson (eatkinson@moz-1047CAB3.airbears2.berkeley.edu)
[02:18:41] <ChrisMorgan1> There, finished off my comment for https://github.com/mozilla/rust/issues/8953#issuecomment-23839865 on the topic of buffering.
[02:19:34] <tikue_> what are the 4 kinds? Send, Clone, ...
[02:19:53] <ChrisMorgan1> Freeze, Sized
[02:20:02] <tikue_> what is Sized and Freeze?
[02:20:04] <ChrisMorgan1> Clone ain't a kind.
[02:20:12] <tikue_> really? oh yeah
[02:20:13] <tikue_> duh
[02:20:20] <ChrisMorgan1> Sized: "Types with a constant size known at compile-time."
[02:20:27] <ChrisMorgan1> Freeze: "Types that are either immutable or have inherited mutability."
[02:20:30] *** Joins: carllerche (carllerche@6B070D22.7E6A0813.1428D117.IP)
[02:20:35] <tikue_> ChrisMorgan1: where are you reading that from?
[02:20:37] <ChrisMorgan1> Send: "Types able to be transferred across task boundaries."
[02:20:42] <ChrisMorgan1> tikue_: src/libstd/kinds.rs
[02:20:45] <tikue_> ah cool
[02:20:46] *** Joins: ghrust (ghrust@2EE61FCC.6A2AE50.F3114085.IP)
[02:20:46] <ghrust> 01[13rust01] 15bors pushed 0 new commits to 06auto: 02http://git.io/jEbJiw
[02:20:46] *** Parts: ghrust (ghrust@2EE61FCC.6A2AE50.F3114085.IP) ()
[02:20:50] *** Joins: ghrust (ghrust@79968228.6A2AE50.F3114085.IP)
[02:20:50] <ghrust> 01[13rust01] 15bors pushed 3 new commits to 06auto: 02http://git.io/VruRAg
[02:20:50] <ghrust> 13rust/06auto 14d0a1176 15Daniel Micay: forbid cast as bool...
[02:20:50] <ghrust> 13rust/06auto 14e4a76e6 15blake2-ppc: std::str: Deny surrogates in is_utf8...
[02:20:50] <ghrust> 13rust/06auto 147c7f055 15bors: auto merge of #8980 : thestinger/rust/bool, r=thestinger...
[02:20:51] *** Parts: ghrust (ghrust@79968228.6A2AE50.F3114085.IP) ()
[02:20:54] <ChrisMorgan1> I guess it should be in rust.md also
[02:20:55] *** Quits: dwrensha (chatzilla@moz-AA82FBAF.hsd1.wa.comcast.net) (Quit: ChatZilla 0.9.90.1 [Firefox 23.0.1/20130814063812])
[02:21:03] *** Quits: eatkinson (eatkinson@moz-1047CAB3.airbears2.berkeley.edu) (Quit: eatkinson)
[02:21:28] <ChrisMorgan1> Yep, it is, more or less.
[02:21:28] <strcat> the endless quest for soundness
[02:21:36] <olsonjeffery> ChrisMorgan1: this is wizard (what's in rust-http).
[02:22:20] *** Quits: dherman (dherman@moz-6CA476B1.hsd1.ca.comcast.net) (Quit: dherman)
[02:22:52] <ChrisMorgan1> I've also added the ability to poke a single byte back into my buffer, which is necessary for HTTP headers which can have CR LF 1*(SP|HT) as linear white space, so you can't just stop reading the header at CRLF, you need to read the next byte also.
[02:23:21] <olsonjeffery> totally. that's pretty common for APIs where you have to chomp byte-by-byte
[02:23:24] <olsonjeffery> once you hit the delimiter..
[02:23:36] <ChrisMorgan1> The way I'm doing that isn't sound at present, actually; I need _two_ bytes in one place now. :-(
[02:23:43] *** Quits: austincheney (quassel@8276C73B.985A737F.603BFF2.IP) (Connection reset by peer)
[02:23:45] *** Joins: austincheney (quassel@8276C73B.985A737F.603BFF2.IP)
[02:24:25] <ChrisMorgan1> I had thought I could restructure it to get it down to one again, but the way of doing that would leave a trailing SP in a header value, rather than stripping it.
[02:26:23] *** Joins: DAddYE (DAddYE@moz-98D3933F.hsd1.ca.comcast.net)
[02:27:16] <ChrisMorgan1> Another requirement I'm about to need to tackle is that of applying temporary decoration to a stream, for reading or writing with a Transfer-Encoding (I only need to support chunked, which puts a CRLF, hexadecimal number and CRLF indicating the length of a chunk at the start of each chunk, ending with an size 0 chunk).
[02:28:15] *** Quits: paulproteus (quassel@rose.makesad.us) (Ping timeout)
[02:28:37] *** Joins: paulproteus (quassel@moz-E86A3B42.makesad.us)
[02:28:38] <ChrisMorgan1> The difficulty there is that it needs to apply only to _part_ of a value, i.e. the message body, not the headers. And yet in the case of writing, flushing is distinctly undesirable as it entails writing a packet.
[02:29:02] *** Joins: mihneadb (mihneadb@moz-329F29A3.lightspeed.sntcca.sbcglobal.net)
[02:29:17] <ChrisMorgan1> Then one other thing which I would *really* like, but I'm not sure how it may be conveniently managed, if at all: splitting a TcpStream into a Reader and a Writer.
[02:29:20] <strcat> ChrisMorgan1: well I fixed the kinds.rs docstrings but rust.md is a scary inaccurate mess ;p
[02:29:24] *** Quits: jeaye (Jeaye@moz-FD505E54.hsd1.ca.comcast.net) (Quit: Don't tell them I was here...)
[02:29:28] * strcat prefers modular docs
[02:29:37] <strcat> from a maintaining POV...
[02:29:41] <ChrisMorgan1> strcat: such is life.
[02:29:46] <strcat> as in, cover for loops in the iterator tutorial
[02:29:51] <strcat> and maintain it there
[02:30:03] <strcat> rather than an inaccurate section in 3 places
[02:30:29] *** ChrisMorgan1 is now known as ChrisMorgan
[02:30:33] *** Quits: DAddYE (DAddYE@moz-98D3933F.hsd1.ca.comcast.net) (Ping timeout)
[02:32:32] <tikue_> rust has serialization support yea?
[02:33:03] <ChrisMorgan> Yes, extra::serialization
[02:33:10] <tikue_> ChrisMorgan: you mean so it can't be a reader and writer both?
[02:33:11] <ChrisMorgan> s/serialization/serialize/
[02:33:18] <tikue_> ChrisMorgan: what if you want an echo server
[02:33:42] <tikue_> actually, almost any use would want to both read and write wouldn't it
[02:34:09] <ChrisMorgan> tikue_: more so that I can use reading in one object and writing in another object (both of which require mutable references) simultaneously.
[02:34:45] <tikue_> ChrisMorgan: without using @mut you mean? yeah that would be nice
[02:35:06] <ChrisMorgan> Indeed.
[02:35:50] <ChrisMorgan> I find it amusing to contemplate how much using a language like Rust has adversely affected my judgement on matters of performance; in Python I'll regularly use a slightly inefficient way of doing things if it's more readable, while in Rust I still haven't even worked up the courage to use trait objects instead of generics when it would make code *much* nicer.
[02:36:15] <tikue_> servo uses trait objects relatively liberally
[02:36:16] <tikue_> lol
[02:37:29] <sfackler> vtable lookup isn't all that slow, and if you have a ton of impls of a trait it may end up being faster than templating anyway
[02:37:51] <ChrisMorgan> I can tell, though, that I'm going to need to bite that proverbial bullet to get my TCP interactions working reasonably (and testably).
[02:40:48] <matt> is there a canonical tcp echo server example anywhere using the latest io stuff ?
[02:41:05] *** Joins: jstevans (Instantbir@472AB8DE.1D53A164.B7830B68.IP)
[02:41:14] <tikue_> matt: my friend Shaladdle wrote one the other day
[02:41:24] <tikue_> it's pretty idiomatic imo
[02:41:28] <Shaladdle> with liberal help from tikue 
[02:41:42] <matt> tkx 
[02:41:49] <tikue_> lemme find the github
[02:42:14] <tikue_> matt: https://github.com/shaladdle/learnrust/blob/master/echoserver.rs
[02:42:27] <Shaladdle> beat me to it
[02:44:13] <ChrisMorgan> That's now out of date; TcpListener.listen() is now TcpListener.listen() -> TcpAcceptor, TcpAccepter.accept()
[02:45:07] <tikue_> ChrisMorgan: ah, good to know thank you
[02:45:20] *** Quits: sankha93 (Instantbir@7061CD01.D6BD0D91.22D41759.IP) (Quit: Gone to save the world!)
[02:45:41] <ChrisMorgan> That also means you'll need to import std::rt::io::Acceptor.
[02:46:55] <tikue_> looks like i haven't updated rust in a couple days
[02:47:31] *** Joins: infynyxx (infynyxx@moz-E95B370B.nyc.res.rr.com)
[02:47:37] *** Quits: infynyxx (infynyxx@moz-E95B370B.nyc.res.rr.com) (Client exited)
[02:47:50] <zalzane|alt> so how much support does rust have for debug symbols?
[02:47:51] * ChrisMorgan updates http://stackoverflow.com/questions/17445485/example-tcp-server-written-in-rust/17473420#17473420 in line with this change
[02:48:02] <ChrisMorgan> zalzane|alt: pretty good, actually. Compile with -Z debug-info
[02:48:04] <zalzane|alt> i tried compiling with flag -Z debug-info but gdb doesnt want to see any locals
[02:48:17] * ChrisMorgan doesn't know about locals support
[02:48:18] <etw> I'm trying to write some code to an an item to a linked list, but having some trouble with the memory model, is there a safe way to do this: http://pastebin.com/kREWhkKD ?
[02:48:24] <etw> add an item
[02:48:35] <zalzane|alt> wait does that mean they wrote that entire compiler without debugging?
[02:48:55] <zalzane|alt> well traditional debugging
[02:49:16] *** Joins: heftig (heftig@moz-A8847A1E.dip0.t-ipconnect.de)
[02:49:41] <tikue_> zalzane|alt: the compiler was originally written in c++
[02:49:54] <lkuper_> tikue_: which compiler?
[02:49:58] <tikue_> so presumably the compile flags still existed
[02:50:07] <tikue_> lkuper_: rust's compiler
[02:50:21] <lkuper_> tikue_: the bootstrap compiler was writen in OCaml.
[02:50:24] <tikue_> oh :)
[02:50:25] <tikue_> my bad
[02:50:34] * tikue_ doesn't know where he heard it was c++
[02:50:45] <lkuper_> :)
[02:50:49] <lkuper_> lies, damned lies!
[02:50:54] <Shaladdle> ChrisMorgan, tikue_, matt, just updated the echo server, should be good now
[02:50:57] *** Quits: fyolnish (fyolnish@moz-E730FCE7.uqwimax.jp) (Client exited)
[02:51:15] *** Quits: alisdair (textual@1697D94C.7742FB18.FBC8476D.IP) (Quit: My MacBook Pro has gone to sleep. ZZZzzzâ€¦)
[02:51:21] <tikue_> Shaladdle: forgot you have arch and nice nightly builds -___- takes me forever to update rust lol
[02:51:26] <Shaladdle> muahahahaah
[02:51:39] <Shaladdle> all hail strcat
[02:51:49] <tikue_> there's no nightly build on homebrew is there?
[02:52:38] <lkuper_> zalzane|alt: there's never been great support for debugging symbols; people got pretty good at working around that.
[02:54:02] <ChrisMorgan> etw: recursion is the simplest way that occurs to me
[02:54:10] <zalzane|alt> ive done a bit of opencl in the past and that was pretty much black box kinda stuff
[02:54:22] <zalzane|alt> your code crashes? you gotta restart your machine
[02:54:30] <zalzane|alt> but i cant imagine doing that all the time
[02:54:43] <ChrisMorgan> etw: not sure why you call clone() on the str; you own it already.
[02:54:44] <zalzane|alt> is there a milestone for legit debugging
[02:55:11] <etw> hmm ok
[02:56:11] <sfackler> what's the url for the nightly rust repo for rust?
[02:56:38] <etw> the text.clone() part wasn't the part giving me trouble ;)
[02:56:43] *** Quits: Sorella (queen@9D963F5D.DF5D8AE7.54BCAB54.IP) (Ping timeout)
[02:57:32] <ChrisMorgan> etw: http://pastebin.com/KjPJEeJV
[02:58:05] <tikue_> ChrisMorgan: any idea if that TCO's properly
[02:58:15] <ChrisMorgan> Rust doesn't have TCO.
[02:58:40] <etw> TCO - tail call optimization
[02:58:40] <etw> ?
[02:58:43] <tikue_> ChrisMorgan: but llvm does optimizing
[02:59:06] <ChrisMorgan> I don't know what LLVM will do with it.
[02:59:20] <Shaladdle> sfackler: if you're using arch see here: https://mail.mozilla.org/pipermail/rust-dev/2013-May/004073.html
[02:59:20] <lkuper_> zalzane|alt: I'm not sure.  It's been a rather long saga related to debug info.
[02:59:33] <zalzane|alt> is said saga documented in the mailing list
[02:59:50] <tikue_> ChrisMorgan: it looks like it definitely could. 
[02:59:52] * tikue_ goes to test it
[02:59:57] <etw> I suppose recursion is fine for now, not too concerned with performance
[03:00:12] <tikue_> etw: if llvm optimizes it, the performance would be good
[03:00:25] <etw> tikue_: even better
[03:02:08] <tikue_> annnnndâ€¦it crashed
[03:02:09] <strcat> etw: http://llvm.org/docs/CodeGenerator.html#tail-call-optimization http://llvm.org/docs/CodeGenerator.html#sibling-call-optimization relevant sections
[03:02:11] <tikue_> guess not :(
[03:02:27] <strcat> rust does run the tailcallelim pass, it does *not* pay the cost for tailcallopt though so it only gets sibling call optimization
[03:02:34] <strcat> and it's not an entirely portable optimization
[03:02:43] <strcat> (you can pass tailcallopt yourself, if you want)
[03:03:13] <ChrisMorgan> Um. Given an Option<~x>, how can one get an &mut x out of it?
[03:03:49] <Luqman> ChrisMorgan: get_mut_ref
[03:04:02] <Luqman> er, actually no
[03:04:02] <strcat> rusti: let mut x = Some(~5); match x { Some(ref mut ~x) => *x = 6, None => () }
[03:04:03] -rusti- <anon>:5:50: 5:53 error: expected identifier, found path
[03:04:03] -rusti- <anon>:5          let mut x = Some(~5); match x { Some(ref mut ~x) => *x = 6, None => () }
[03:04:03] -rusti-                                                            ^~~
[03:04:03] -rusti- application terminated with error code 101
[03:04:08] <tikue_> Luqman:  that'd be &mut ~x
[03:04:16] <ChrisMorgan> Indeed.
[03:04:21] <strcat> rusti: let mut x = Some(~5); match x { Some(~ ref mut x) => *x = 6, None => () }
[03:04:22] -rusti- ()
[03:04:24] <strcat> rusti: let mut x = Some(~5); match x { Some(~ ref mut x) => *x = 6, None => () } x
[03:04:25] -rusti- Some(~6)
[03:04:25] <Luqman> tikue_: yea, noticed it at second glance
[03:04:28] <strcat> ChrisMorgan: like that
[03:04:44] <ChrisMorgan> Ah. Thanks!
[03:05:10] <strcat> it didn't used to work when I wrote TreeMap so I had to do ref mut x -> &mut *x a lot
[03:05:12] <strcat> :[
[03:05:15] <strcat> should go back and fix those
[03:05:28] *** Quits: jstevans (Instantbir@472AB8DE.1D53A164.B7830B68.IP) (Ping timeout)
[03:05:45] *** Joins: ghrust (ghrust@C8693FCB.6A2AE50.F3114085.IP)
[03:05:46] <ghrust> 01[13rust01] 15bors 04force-pushed 06auto from 147c7f055 to 148827b94: 02http://git.io/N3iJvQ
[03:05:46] *** Parts: ghrust (ghrust@C8693FCB.6A2AE50.F3114085.IP) ()
[03:05:46] *** Joins: ghrust (ghrust@DE823A67.6A2AE50.F3114085.IP)
[03:05:46] <ghrust> 01[13rust01] 15bors pushed 2 new commits to 06auto: 02http://git.io/IADsfw
[03:05:46] <ghrust> 13rust/06auto 144c37537 15Jack Moffitt: Remove spurious comment in test for #1866....
[03:05:46] <ghrust> 13rust/06auto 14b6d825e 15bors: auto merge of #8986 : metajack/rust/rem-1866-xfail-comment, r=huonw...
[03:05:47] *** Parts: ghrust (ghrust@DE823A67.6A2AE50.F3114085.IP) ()
[03:05:53] <tikue_> strcat: how  do you explicitly pass -tailcallopt to rustc?
[03:05:55] <ChrisMorgan> Looks like a single pass match on writing a non-recursive List.append there doesn't work.
[03:06:03] <strcat> tikue_: --llvm-args
[03:06:13] <tikue_> ChrisMorgan: yeah that's what i'm noticing. wonder why
[03:06:18] <tikue_> strcat: thank you
[03:06:24] <ChrisMorgan> "cannot borrow `*(*list).next#0` as mutable more than once at a time" doesn't seem like a totally correct error.
[03:06:32] <strcat> tikue_: not sure about the exact param you have to pass
[03:06:32] <lkuper_> zalzane|alt: try searching github issues for "debug info" or "debugging symbols" and you'll get a taste of it.  there was also a rust-dev thread about someone working on it as a GSoC 2013 project.
[03:07:19] *** Joins: jstevans (Instantbir@472AB8DE.1D53A164.B7830B68.IP)
[03:07:35] <strcat> acrichto: hm, how do you actually pass something to --llvm-args?
[03:07:40] <tikue_> strcat: would it just be --llvm-args <foo>
[03:07:50] <strcat> rustc tries to parse --llvm-args='-foo' as a -foo switch :s
[03:07:53] <tikue_> ah ok
[03:07:56] <etw> ChrisMorgan: that's another error I kept seeing
[03:09:07] <strcat> maybe it's just not included as a flag you can pass that way
[03:09:10] * strcat isn't sure
[03:09:16] <tikue_> yeah :\
[03:09:38] *** Joins: pepper_chico (pepper_chi@14AC4DFD.704EE6B0.E4090502.IP)
[03:10:04] <ChrisMorgan> etw: looks like at present at least it can't be done in a non-recursive manner; the borrow checker doesn't like it done in a loop.
[03:10:26] <strcat> great, yet another spurious bsd failure
[03:10:28] * strcat sighs
[03:11:02] <etw> ChrisMorgan: is the borrow checker supposed to work that way, or possible bug?
[03:11:12] <ChrisMorgan> I'm still trying to decide that.
[03:11:14] *** Quits: brson (brson@moz-BBE3ABD.mv.mozilla.com) (Ping timeout)
[03:12:07] *** Quits: a_m0d (a_m0d@moz-68E0CFD0.acanac.net) (Quit: Leaving.)
[03:12:09] <ChrisMorgan> *I* know it's valid, and *you* know it's valid, but does *it* know it's valid?
[03:12:23] *** Quits: carllerche (carllerche@6B070D22.7E6A0813.1428D117.IP) (Quit: carllerche)
[03:13:16] <Shaladdle> impl<K, V> KVStore<K, V> for DiskKVStore<K, V> {
[03:13:20] <Shaladdle> ^ Why do we have to have the first <K, V>? Seems redundant?
[03:14:10] <eevee> Shaladdle: consider impl<A, B> Trait<A> for Type<B>
[03:14:18] <cmr> Shaladdle: It's a generic implementation for a trait which takes two type parameters over a type which takes two type parameters.
[03:14:19] <ChrisMorgan> Shaladdle: the first time allows type constraints, too
[03:14:58] <ChrisMorgan> e.g. you might want K to be hashable and V to be able to be converted to a string easily, and go with impl<K: Hash, V: ToStr>
[03:15:40] *** Joins: brson (brson@6A848D32.C1B840DD.76F66111.IP)
[03:15:40] *** ChanServ sets mode: +ao brson brson
[03:15:46] <strcat> it just declares some type parameters with their trait bounds to have in scope
[03:15:46] <Shaladdle> ChrisMorgan, hmm yes but it kind of seems like you could put type constraints in the second two <>'s
[03:15:59] <strcat> Shaladdle: and anywhere you reference them in the impl?
[03:16:02] <Shaladdle> but I guess it' kind of ambiguous where you to put them as in eevee's example
[03:16:08] <ChrisMorgan> Shaladdle: that would rapidly get unworkable in some situations.
[03:16:20] <strcat> Shaladdle: you refer to K/V in the methods themselves too
[03:16:28] *** Joins: fyolnish (fyolnish@moz-BE2BAE5B.miinet.jp)
[03:16:32] <strcat> the impl<> part is just where they're defined as being declared
[03:16:38] <strcat> you don't *have* to use them in the type definition
[03:16:56] <ChrisMorgan> You can have "shadow" generics
[03:16:58] <Shaladdle> not sure what you mean by using them in the type definition..
[03:17:25] <strcat> Shaladdle: impl<type parameters> type_definition for trait_definition {}
[03:17:34] <Shaladdle> oh yeah that's true
[03:17:36] <Shaladdle> right right
[03:17:42] <strcat> er
[03:17:45] <Shaladdle> er
[03:17:46] <strcat> I got type/trait backwards
[03:17:51] <strcat> close enough :D
[03:17:55] *** Joins: infynyxx (infynyxx@moz-E95B370B.nyc.res.rr.com)
[03:18:40] *** Joins: carllerche (carllerche@6B070D22.7E6A0813.1428D117.IP)
[03:18:57] *** Quits: samx (sami@moz-D9DA5773.dyn.optonline.net) (Quit: This computer has gone to sleep)
[03:22:12] *** Quits: infynyxx (infynyxx@moz-E95B370B.nyc.res.rr.com) (Client exited)
[03:22:27] <tikue_> fn foo<B: Bar<Z>, Z: Baz>() { .. } // is this the best way to do this?
[03:23:03] *** Joins: alisdair (textual@1697D94C.7742FB18.FBC8476D.IP)
[03:23:55] *** Joins: jdm (jdm@92FB48CA.8B5E9DF.9A8C35B4.IP)
[03:23:56] *** ChanServ sets mode: +o jdm
[03:24:42] *** Joins: jmgrosen (jmgrosen@moz-848F6087.sb.sd.cox.net)
[03:24:54] <jmgrosen> json parsing is not fun :( https://gist.github.com/jmgrosen/562f1aade8c531cbb7cb
[03:24:59] <jmgrosen> any better ways to do it?
[03:25:23] <tikue_> what is a bounded closure?
[03:27:11] *** Quits: fyolnish (fyolnish@moz-BE2BAE5B.miinet.jp) (Client exited)
[03:27:36] *** Joins: erickt1 (Adium@49C4075F.3AC15C18.2321E71E.IP)
[03:29:07] *** Joins: dherman (dherman@moz-6CA476B1.hsd1.ca.comcast.net)
[03:29:07] *** ChanServ sets mode: +ao dherman dherman
[03:29:19] <Luqman> jmgrosen: i've been playing with something like this https://gist.github.com/luqmana/154868cc6b0a7bcdee5a
[03:29:20] *** Quits: matt (Mibbit@moz-3AB1E206.nycmny.fios.verizon.net) (Quit: http://www.mibbit.com ajax IRC Client)
[03:30:40] *** Joins: zz_kimundi (kimundi@moz-77FD6CAA.dip0.t-ipconnect.de)
[03:31:02] *** zz_kimundi is now known as kimundi
[03:34:32] <ChrisMorgan> jmgrosen: std::rt::io::extensions::ReaderUtil has a read_to_end() method which should do the reading well, I believe.
[03:35:17] <jmgrosen> oh, wow, that's really cool -- I hadn't noticed those things before
[03:35:18] * ChrisMorgan is going to need to be careful with how he handles EOF in requests and responses, as it will eventually need pipelining 
[03:35:32] *** Joins: zeuxcg (zeuxcg@moz-80D1F912.hsd1.ca.comcast.net)
[03:36:20] <jmgrosen> Luqman: do you know if the struct has to have all of the fields that the json has?
[03:36:47] *** Quits: SingingBoyo (brandon@4DF3381A.51F4D838.4F048BDC.IP) (Ping timeout)
[03:38:27] <Luqman> jmgrosen: a brief test says no
[03:38:33] <jmgrosen> great
[03:44:53] <tikue_> it would be nice if there were a way for traits which are just the summation of other traits to be implicitly implemented
[03:45:18] <tikue_> trait Stream: Reader + Writer + Send {} // don't want to have to have the line impl Stream for TcpStream
[03:45:49] <cmr> tikue_: but traits can indicate that an additional invariant is guaranteed, which random things implementing those 3 traits might not guarantee.
[03:45:58] <cmr> (as an example)
[03:45:59] <tikue_> cmr: i know. so perhaps syntax for this
[03:46:12] <cmr> or an attribute
[03:46:12] <tikue_> some way of labeling a trait as "no more" than the simple summation
[03:46:35] <cmr> I gave a Rust presentation tonight, 1.5 hours
[03:46:46] <tikue_> wow, cool! how'd it go?
[03:46:54] <cmr> It went not-so-great
[03:47:13] <tikue_> i'm sorry to hear that -- what were the stumbling points?
[03:47:15] <cmr> It was an introduction to the language driven by the example of a simple text adventure
[03:47:18] <strcat> 1.5 hours? :s
[03:47:23] <cmr> Rust is just so complex
[03:47:47] <cmr> I lost most people around traits
[03:47:53] <tikue_> yeah it isâ€¦i generally feel it hides its complexity well
[03:47:54] <cmr> I'm going to be giving weekly workshops here though
[03:47:56] <erickt1> cmr: traits are tough :(
[03:48:00] <cmr> And I got a lot of great feedback
[03:48:03] *** Joins: Larry (larryfox@moz-343B6F0C.nyc.biz.rr.com)
[03:48:03] <erickt1> cool!
[03:48:16] <cmr> Part of the problem is the diverse background of the audience
[03:48:23] <cmr> (It's at my uni's open source lab)
[03:48:43] <olsonjeffery> cmr: i think im just going to dive into the stdlib for examples
[03:48:55] <olsonjeffery> maybe knock down java/c# strawmen :)
[03:49:04] <tikue_> traits are so similar to interfaces in java, i'm surprised people had trouble grocking their intention
[03:49:27] <cmr> No one in the room knew java
[03:49:27] <tikue_> and interfaces are getting default methods in java 8 so they'll be even more similar heh
[03:49:30] <tikue_> oh
[03:49:36] <cmr> Mostly C++ people
[03:49:38] <jmgrosen> well that would explain it
[03:49:52] <jmgrosen> my friends, most of which know java, can pick up the main ideas fairly quickly
[03:49:53] <tikue_> i don't really know c++ but doesn't it have virtual methods or something
[03:49:56] * strcat doesn't think people who really know C++ should have any problems with concepts in rust
[03:49:58] <cmr> Yes
[03:50:15] <strcat> tikue_: templates have "concepts" too, it's just not enforced at a language level
[03:50:16] <Shaladdle> yeah seems like abstract class/class with pure virtual methods are similar to traits
[03:50:27] <cmr> Shaladdle: trait objects.
[03:50:30] <ChrisMorgan> tikue_: matter of fact, I fixed the why-isn't-Stream-implemented generally (``impl<T: Reader + Writer> Stream for T;``) in a PR just a couple of hours ago
[03:50:32] <olsonjeffery> ^
[03:50:39] <nielsle> When java interfaces get default methods, will they be able to do everything that traits do?
[03:50:40] <tikue_> strcat: you mean <T: Foo + Bar> ? or something else?
[03:50:45] <strcat> C++ concepts == traits
[03:50:47] <cmr> nielsle: no
[03:50:49] <strcat> tikue_: in every way
[03:50:53] <strcat> 1:1 mapping
[03:51:16] <cmr> nielsle: because of trait parameterization and bounds
[03:51:30] <nielsle> OK
[03:51:31] <Shaladdle> cmr, can't you have a pointer to an abstract class? I'm pretty new to rust, so maybe I misunderstand.
[03:51:42] <strcat> rust doesn't have classes or object inheritance
[03:51:48] <tikue_> ChrisMorgan: I'm not sure I follow -- how did you fix it?
[03:51:51] <strcat> or virtual methods
[03:51:57] <cmr> Shaladdle: abstract classes most correspond to trait objects, but they're more than that and different in many ways.
[03:51:58] <Shaladdle> hmm yeah
[03:52:01] <strcat> it has types, and impls
[03:52:16] <ChrisMorgan> tikue_: ``impl<T: Reader + Writer> Stream for T;`` is all there is to it.
[03:52:24] <olsonjeffery> strcat: you can kind of squint your eyes at a default method and consider it vaguely kinda sorta virtual'ish ;)
[03:52:26] <strcat> impls are associated with the type or a trait, and you can use them statically (generic functions, type bounds) or through a boxed trait object
[03:52:40] <strcat> olsonjeffery: well it's either
[03:52:41] <olsonjeffery> can you do super() in overridden default methods?
[03:52:43] <cmr> I wasn't really prepared for the presentation either though, so part of it's probably my fault too.
[03:52:59] <cmr> I got tossed into it a half hour before it started :p
[03:53:00] <strcat> olsonjeffery: you can use methods from the same trait or traits it inherits from, but it's not dynamic dispatch
[03:53:04] <strcat> all methods are static, always
[03:53:12] <erickt1> Function name help request: I'd like to change Option::unwrap_or_default to use the Default trait, but then what should we name the method that allows you to do `None.unwrap_or_default(5)`? What do you all think about naming it `None.unwrap_or(5)` and adding a `None.unwrap_or_with(|| 6)`?
[03:53:13] <strcat> trait objects do the boxing, the methods themselves are always available statically
[03:53:26] <strcat> I think if we have higher-kinded polymorphism that might not be true.
[03:53:34] * strcat isn't sure
[03:53:35] <tikue_> ChrisMorgan: what was it before? 
[03:53:38] <cmr> erickt1: hm, that's tricky.
[03:53:51] <nielsle> Has  it ever been suggested to mark a default methods as on-overridable? (just to curb ravioi code)
[03:53:58] <nielsle> ravioli
[03:54:04] <ChrisMorgan> tikue_: that just wasn't there, so you had to ``impl Stream for MyType;`` each time.
[03:54:17] <olsonjeffery> sealed classes are the devil's creation
[03:54:20] <erickt1> cmr: we need to extend english to add more good words to use
[03:54:32] <strcat> nielsle: yes, there's an open issue
[03:54:40] <tikue_> oh wait, i get it now ! sorry I thought you were using T to represent some concrete struct in a general way
[03:54:44] <cmr> erickt1: I like the look of unwrap_or
[03:54:45] <tikue_> that's awesome :) woo!
[03:54:49] <ChrisMorgan> Now who was it that was saying they'd try using rust-http? Was it you, cmr?
[03:54:59] <cmr> ChrisMorgan: Yup!
[03:55:03] <cmr> ChrisMorgan: it's my weekend project.
[03:55:05] <cmr> (this weekend)
[03:55:09] <Luqman> jmgrosen: did the decoder method work out for you?
[03:55:10] <olsonjeffery> ChrisMorgan: do you think you'll add static file hosting in rust-http, now that file io is in newrt?
[03:55:14] <ChrisMorgan> OK. Looking forward to hearing how it goes.
[03:55:17] <olsonjeffery> or is that the ken of a higher-level framework?
[03:55:23] <ChrisMorgan> olsonjeffery: I should make a demo of that, to be sure.
[03:55:27] <olsonjeffery> cache w/ TLS or somesuch
[03:55:32] <jmgrosen> Luqman: sorry, haven't gotten around to trying it yet -- have to finish up some homework first
[03:55:45] <Luqman> jmgrosen: ah no worries, just curious
[03:55:57] <ChrisMorgan> Before it can do a _good_ job of it, we'll need cache header parsing.
[03:56:31] <olsonjeffery> ChrisMorgan: acrichto has a libuv upgrade PR coming, soon.. i might cajole him into doing a PR for the pipes stuff from 8645 as well and work on that
[03:56:50] <olsonjeffery> i think we could put together a narrow-case demo of transitioning handles to another scheduler
[03:57:06] <olsonjeffery> libuv's "send a handle to another loop" story is handled via IPC over named pipes
[03:57:20] * tikue_ didn't know you could have generic impls
[03:57:25] <strcat> brson: btw any luck finding the cause of that problem?
[03:57:44] <olsonjeffery> wouldn't be equiv. the grand vision of "multithreaded" libuv or even aprop. for general use in the scheduler/io
[03:57:58] <olsonjeffery> but it could be used to explicitly hand a new connection to another task/scheduler
[03:58:09] <olsonjeffery> eg in a task pool
[03:58:45] <tikue_> hmmm
[03:58:51] <tikue_> i'm getting a (to me) strange error
[03:59:04] <tikue_> 35:29: 35:50 error: failed to find an implementation of trait std::rt::io::Reader for ~Stream:Send
[03:59:08] *** Joins: ChrisMorgan1 (chris@moz-F21755A5.its.monash.edu.au)
[03:59:12] <tikue_> however, Stream is simply the trait Reader + Writer + Send
[03:59:17] *** Quits: ChrisMorgan (chris@moz-80C478D2.its.monash.edu.au) (Ping timeout)
[03:59:20] *** Quits: jgilbert (jgilbert@moz-4C088FCE.hsd1.ca.comcast.net) (Ping timeout)
[03:59:22] *** ChrisMorgan1 is now known as ChrisMorgan
[03:59:23] <cmr> https://gist.github.com/cmr/a3526eba1699b3cb1032
[03:59:39] <ChrisMorgan> olsonjeffery: what would the advantages of such an arrangement be?
[03:59:41] <cmr> Does this fail to compile because `foo` is in `super` wrt to main, rather than the current-namespace?
[03:59:42] <brson> strcat: not yet. os x also is failing to valgrind for different reasons though
[03:59:57] <olsonjeffery> ChrisMorgan: what was the last msg of mine you got?
[04:00:17] <ChrisMorgan> "eg in a task pool"
[04:00:23] <ChrisMorgan> One thing I *really* have my heart set on is online upgrades, as in http://www.darkcoding.net/software/online-upgrades-in-go/
[04:00:26] <Luqman> cmr: foo is not pub no?
[04:00:32] <erickt1> tikue_: so streams are sendable now? that's great!
[04:00:48] <cmr> Luqman: ohh that did it.
[04:00:49] <cmr> oops!
[04:00:50] <tikue_> erickt1: no this is just a little project of mine
[04:00:53] <tikue_> sorry :O)
[04:00:57] * erickt1 sobs
[04:01:10] <tikue_> i don't even know what stream is actually
[04:01:32] <tikue_> i just used it to define my trait that sums Reader + Writer + Send
[04:02:07] <ChrisMorgan> tikue_: hang on, is this your own Stream, or std::rt::io::Stream?
[04:02:23] <tikue_> ChrisMorgan: my own stream -- what is std::rt::io::Stream ._.
[04:02:31] <ChrisMorgan> ``pub trait Stream: Reader + Writer { }``
[04:02:56] <tikue_> oh wow
[04:02:59] <tikue_> haha that's exactly the same thing
[04:03:06] <olsonjeffery> ChrisMorgan: that's a common pattern from unicorn, nginx, etc
[04:03:11] <tikue_> except mine had Send too :P
[04:03:20] <olsonjeffery> i think the issue, right now, is that rust can't handle signals.. ?
[04:03:36] <ChrisMorgan> Note that until https://github.com/mozilla/rust/pull/8984 lands nothing actually implements Stream at present.
[04:03:48] <erickt1> ChrisMorgan: did you see that linux 3.9 now has a really easy way to do online upgrades with this SO_REUSEPORT socket option? https://lwn.net/Articles/542629/
[04:03:50] <ChrisMorgan> For that matter, r? https://github.com/mozilla/rust/pull/8984
[04:04:10] <ChrisMorgan> erickt1: I saw that article but haven't read it properly yet.
[04:04:31] <erickt1> ChrisMorgan: it alleviates the need to have to have a master process that's sending around sockets to child processes using unix sockets
[04:04:53] <cmr> olsonjeffery: why not?
[04:04:56] *** Quits: Kruppe (user@moz-E150F49F.cpe.net.cable.rogers.com) (Client exited)
[04:05:26] <olsonjeffery> cmr: not sure.. i recall seeing reading it somewhere..
[04:05:56] <olsonjeffery> brson: is that mistaken? can rust signals from the OS?
[04:06:02] <olsonjeffery> handle signals, even
[04:07:33] <strcat> well it could, but no one has implemented it
[04:07:50] *** Quits: Larry (larryfox@moz-343B6F0C.nyc.biz.rr.com) (Quit: My MacBook Pro has gone to sleep. ZZZzzzâ€¦)
[04:07:56] <strcat> you can sanely handle signals in multithreaded programs on linux with signalfd (with only POSIX, you have to use awful hacks)
[04:08:17] <strcat> libuv has bindings for it, afaik it will use signalfd when it can and fall back to terrible pselect stuff
[04:08:19] <cmr> Does libuv expose it?
[04:08:23] <cmr> Yeah
[04:08:23] <olsonjeffery> cmr: yes
[04:08:31] <olsonjeffery> yeah.. nm.. so its just a matter of mapping it
[04:08:34] * olsonjeffery adds that to the list
[04:09:19] *** Quits: Peng (mnordhoff@moz-D5175E95.mattnordhoff.net) (Ping timeout)
[04:09:25] *** Quits: dave1629 (dave@moz-17578A1A.hsd1.va.comcast.net) (Quit: dave1629)
[04:10:33] <olsonjeffery> good times!
[04:10:44] *** Joins: ghrust (ghrust@F6EE6DE3.6A2AE50.F3114085.IP)
[04:10:44] <ghrust> 01[13rust01] 15bors merged 06auto into 06master: 02http://git.io/IADsfw
[04:10:44] *** Parts: ghrust (ghrust@F6EE6DE3.6A2AE50.F3114085.IP) ()
[04:10:55] <olsonjeffery> it's nice when the only obstacle to a feature is "need to map the libuv bindings"
[04:11:00] <cmr> heh
[04:11:06] <olsonjeffery> (newrt is very nice to work on, id recommend it if you're bored)
[04:11:11] <olsonjeffery> very easy to pick up
[04:11:18] <cmr> What needs doing that's relatively simple?
[04:11:30] <olsonjeffery> well im tackling uv_fs_* now
[04:11:52] <olsonjeffery> acrichto has pipes support as part of 8645.. i hope he'll salvage that soon (because im lazy)
[04:12:01] <olsonjeffery> he said wasn't complete
[04:12:19] <olsonjeffery> the signals stuff would be super useful, i'm sure
[04:12:23] *** Joins: azita (Azita@moz-C1FB2A8.hsd1.ca.comcast.net)
[04:12:33] <cmr> I'll give it a shot.
[04:12:35] <cmr> No promises
[04:12:50] <olsonjeffery> libuv has API for dynamic loading of c libraries
[04:12:55] *** Quits: lmandel (lmandel@moz-76CE9D51.cable.teksavvy.com) (Ping timeout)
[04:12:55] <olsonjeffery> that might be cute
[04:12:58] <cmr> We have an API for that already.
[04:13:10] <cmr> http://seld.be/rustdoc/master/std/unstable/dynamic_lib/index.html
[04:13:25] <strcat> olsonjeffery: well, signals aren't actually very useful ;p, pipes are
[04:13:34] <strcat> signals are fundamentally racy
[04:13:49] <strcat> if something uses signals... it is wrong in edge cases
[04:13:51] <olsonjeffery> strcat: yeah.. just responding to the oooh-shiny'ness of online upgrades
[04:13:57] <strcat> (but sometimes you have to deal with them)
[04:14:24] <olsonjeffery> and agreed. pipes are awesome.
[04:14:34] <strcat> SIGCHLD/SIGHUP are ones you want to deal with ofc
[04:15:00] <strcat> but ones sent from userspace are insane ;p
[04:15:28] <cmr> "To make signals 'play nice' with libuv, the API will deliver signals to all handlers on all running event loops!"
[04:15:31] <cmr> urgh
[04:15:44] *** Joins: ghrust (ghrust@9C8B94D4.6A2AE50.F3114085.IP)
[04:15:44] <ghrust> 01[13rust01] 15bors pushed 0 new commits to 06auto: 02http://git.io/MHKpPQ
[04:15:44] *** Parts: ghrust (ghrust@9C8B94D4.6A2AE50.F3114085.IP) ()
[04:15:45] *** Joins: ghrust (ghrust@DE823A67.6A2AE50.F3114085.IP)
[04:15:45] <ghrust> 01[13rust01] 15bors pushed 3 new commits to 06auto: 02http://git.io/D0PdOA
[04:15:45] <ghrust> 13rust/06auto 14b49e9fa 15Daniel Micay: forbid cast as bool...
[04:15:45] <ghrust> 13rust/06auto 14b153219 15blake2-ppc: std::str: Deny surrogates in is_utf8...
[04:15:45] <ghrust> 13rust/06auto 14d285ea7 15bors: auto merge of #8980 : thestinger/rust/bool, r=thestinger...
[04:15:47] *** Parts: ghrust (ghrust@DE823A67.6A2AE50.F3114085.IP) ()
[04:16:19] <olsonjeffery> cmr: all signal handlers, i think
[04:16:33] <cmr> https://github.com/mozilla/rust/issues/8987
[04:16:36] <strcat> cmr: well the way you do it is that you check if it's the signal you were expecting
[04:16:39] *** Joins: Peng (mnordhoff@moz-D5175E95.mattnordhoff.net)
[04:16:53] <cmr> It seems less janky than that initial sentance suggested to me.
[04:17:00] <cmr> You create a signal handler for a specific signal
[04:17:03] <strcat> like you know the pid of your child, so you look for SIGCHLD and check the pid
[04:17:57] <cmr> Did GSoC end?
[04:18:05] <jdm> cmr: not yet
[04:18:11] <cmr> ah
[04:18:22] <jdm> the soft pencils down date is in two weeks, I believe
[04:18:25] <jdm> firm date is the 23rd
[04:18:31] <cmr> I was going to complement mw for sticking with the debuginfo patches after it ended.
[04:18:35] <jdm> heh
[04:18:36] *** Quits: huhlig-home (huhlig@moz-C8339267.hfc.comcastbusiness.net) (Ping timeout)
[04:18:37] <strcat> cmr: playpen has a little manual epoll loop using signalfd/timerfd ;p
[04:18:38] <cmr> Now he just gets the usual praise :P
[04:18:41] <strcat> that's how it does the timeout
[04:18:44] <strcat> + handles I/O
[04:18:57] <cmr> strcat: roughly the same code that was in the C++ I imagine?
[04:19:01] <cmr> Or have you not ported it to rust yet
[04:19:08] <strcat> cmr: not in rust yet
[04:19:08] <olsonjeffery> strcat: hah, nice
[04:19:11] <cmr> ah, ok
[04:19:14] <cmr> yeah I've seen that code.
[04:19:22] <strcat> https://github.com/thestinger/playpen/blob/master/playpen.c#L442
[04:19:24] <strcat> it has to do a lot ;p
[04:19:36] <strcat> (you have probably seen most of those messages)
[04:19:53] *** Quits: dherman (dherman@moz-6CA476B1.hsd1.ca.comcast.net) (Quit: dherman)
[04:20:35] *** Quits: tikue_ (tkuehn@DAF45FBE.28259105.689607DE.IP) (Quit: tikue_)
[04:20:47] <olsonjeffery> cmr: fwiw, issue #22 was re: signals
[04:20:55] <olsonjeffery> graydon closed it saying "nm, we'll do this in libuv"
[04:20:57] <strcat> anyway it's nice on linux
[04:21:07] <strcat> sockers, queues, timers, signals, events - files!
[04:21:48] <strcat> even things like namespaces are file descriptors.
[04:22:03] *** Joins: dbaupp (Thunderbir@32354265.D5A1DCF.37681C44.IP)
[04:22:47] <olsonjeffery> strcat: dbus
[04:22:59] <olsonjeffery> but you might as well use proper bindings for that, heh
[04:23:01] <cmr> what about it?
[04:23:12] <strcat> olsonjeffery: dbus as a concept isn't bad, just the implementation is really awful
[04:23:17] <olsonjeffery> dbus uses UDP/fd's
[04:23:21] <olsonjeffery> UDS, even
[04:23:22] *** Joins: jaen (jaen@moz-E0979827.copit.pl)
[04:23:30] <cmr> UDS being?
[04:23:30] <strcat> yeah it gives you a fd and you get to hand it to any event loop
[04:23:37] <olsonjeffery> unix domain sockets
[04:23:39] <cmr> oh
[04:23:46] * strcat can't wait for the new dbus
[04:23:53] <cmr> strcat: oh there's actually a new one coming?
[04:23:56] <olsonjeffery> gnome is moving away from dbus
[04:23:58] <strcat> something I can actually use without crying
[04:23:58] <olsonjeffery> i don't know what towards
[04:24:00] <strcat> cmr: yes
[04:24:01] <olsonjeffery> probably something horrible
[04:24:07] *** Parts: Shaladdle (Shaladdle@moz-424BC304.hsd1.pa.comcast.net) (Leaving)
[04:24:09] <olsonjeffery> wheel, reinvent thyself!
[04:24:12] <strcat> olsonjeffery: I don't think it will be horrible
[04:24:13] *** Joins: Shaladdle (Shaladdle@moz-424BC304.hsd1.pa.comcast.net)
[04:24:27] <strcat> greg kh is implemented kdbus, but it's basically unrelated to the current dbus in userspace
[04:24:27] <olsonjeffery> strcat: I Want To Believe
[04:24:27] <cmr> I only looked at the protocol once a year or so ago and decided it wasn't really worth using
[04:24:33] * olsonjeffery is on gnome 3.8
[04:24:53] <strcat> olsonjeffery: http://i3wm.org/docs/userguide.html freedom! ;p
[04:24:55] * strcat runs
[04:25:13] <dbaupp> strcat: I think you typoed xmonad :P
[04:25:15] <cmr> capn proto seems really promising
[04:25:23] <strcat> anyway, they're going to put the implementation of the whole pub/sub dbus thing in the kernel
[04:25:32] * olsonjeffery used to be pretty hardcore into awesome-wm
[04:25:53] * strcat hates awesome/xmonad
[04:25:59] <strcat> silly inflexible layouts
[04:26:01] * cmr just hates awesome
[04:26:04] <strcat> I want my splits/tabs :(
[04:26:10] <strcat> and stacking
[04:26:10] <cmr> My grief about awesome is the awful implementation
[04:26:11] <olsonjeffery> i just want wm chrome to go away
[04:26:24] <olsonjeffery> im in the reclaim-precious-centimeters-of-my-monitor-real-estate camp
[04:28:04] *** Quits: jaen (jaen@moz-E0979827.copit.pl) (Ping timeout)
[04:28:05] <cmr> I'm very rarely in front of my desktop anymore and the only thing feasible on my netbook is a fullscreen terminal ssh'd into a tmux session on my desktop :p
[04:28:08] <olsonjeffery> has anyone thought of xcb bindings?
[04:28:16] <cmr> olsonjeffery: aatch was working on some.
[04:28:17] <olsonjeffery> maybe just go straight to wayland, heh
[04:28:23] <cmr> https://github.com/Aatch/rust-xcb
[04:28:27] <olsonjeffery> rust window manager golf
[04:28:36] <olsonjeffery> ala xmonad
[04:29:02] <cmr> I'm going to be writing a wayland compositor in Rust
[04:29:12] <cmr> ...as well as a lot of other code.
[04:29:44] <dbaupp> cmr: for your OS?
[04:29:48] <cmr> dbaupp: yup!
[04:30:25] <cmr> going to be a while before I get to it
[04:30:27] <dbaupp> ChrisMorgan: https://github.com/chris-morgan/rust-http/pull/7 r? (in a second, I'm just force-pushing an amend, on slow internet)
[04:30:28] <cmr> but that's my plan
[04:30:28] <olsonjeffery> we all have so many ambitions, heh. right now my goals are to: 1) do work code, because yeah. job. 2) rust contribution 3) port some webgl demos ive done and add to my portfolio
[04:30:55] <dbaupp> ChrisMorgan: (ah, there, pushed.)
[04:30:58] <olsonjeffery> and general portfolio/cv maint.
[04:31:20] <dbaupp> olsonjeffery: clearly only 2 and 3 are important. :P
[04:31:44] <olsonjeffery> id skip three if i could
[04:31:49] <dbaupp> ChrisMorgan: wait, it's still broken
[04:32:05] <olsonjeffery> well, i can. but it'll pay dividends down the road, as does rust work.
[04:32:27] <olsonjeffery> a possible #4 is a webrtc project that's been living in the back of my head for a while
[04:32:53] <olsonjeffery> wish webrtc screensharing in chrome would not share all displays ;_;
[04:33:09] <dbaupp> you can webrtc screen share? o_O
[04:33:23] <olsonjeffery> only in chrome
[04:33:27] <cmr> My current priorities are 1. course work, 2. rust, 3. cmoss, with 2 and 3 of roughly equal priority, since they feed into each other.
[04:33:30] <olsonjeffery> you have to set a config flag for it
[04:33:44] <dbaupp> oh
[04:34:01] <olsonjeffery> tl;dr p2p vnc
[04:34:08] <olsonjeffery> the server just does matchmaking
[04:34:10] <cmr> heh
[04:34:10] <dbaupp> cmr: psh, you're just starting uni, right? skip the course work. :P
[04:34:13] <olsonjeffery> and webrtc does all the holepunching
[04:34:22] <cmr> dbaupp: no, I need good grades to get scholarships
[04:34:54] <dbaupp> cmr: meh. get the good grades without doing the work
[04:35:09] * dbaupp has cmr's uni strategy all planned out
[04:35:15] <cmr> apparently :p
[04:35:56] <dbaupp> olsonjeffery: I see, but it's just a chrome extension right now?
[04:36:01] <cmr> tikue: you work on servo yeah?
[04:36:06] <erickt1> cmr: the bad thing about adding a `.unwrap_or(def)` is that it's much shorter to write `.unwrap_or("")` than it is to write `.unwrap_or_default()`
[04:36:17] <cmr> erickt1: why is that bad?
[04:36:22] <cmr> erickt1: oh I see
[04:36:24] <erickt1> well, bad/good :)
[04:36:24] <cmr> well
[04:36:28] <cmr> depends on your type
[04:36:43] <cmr> rusti: from_str::<uint>("42")
[04:36:46] -rusti- <anon>:5:9: 5:25 error: unresolved name `from_str`.
[04:36:46] -rusti- <anon>:5          from_str::<uint>("42")
[04:36:46] -rusti-                   ^~~~~~~~~~~~~~~~
[04:36:47] -rusti- error: aborting due to previous error
[04:36:47] -rusti- application terminated with error code 101
[04:37:00] <erickt1> I like the shorter form, but I feel like we should be good and use the Default implementation when it makes sense
[04:37:04] <cmr> Anyone opposed to a generic from_str function in the prelude that just calls out to FromStr::from_str ?
[04:37:04] <olsonjeffery> dbaupp: no it ships in the default chrome .. there's a demo using it at http://talky.io
[04:37:11] <olsonjeffery> w/ instructions
[04:37:15] <erickt1> cmr: +1
[04:37:36] *** Quits: dbaupp (Thunderbir@32354265.D5A1DCF.37681C44.IP) (Ping timeout)
[04:37:47] <jmgrosen> cmr: also +1
[04:38:24] <erickt1> cmr: are there other trait methods that it'd make sense to export like that?
[04:38:32] <strcat> all of them, that's the problem
[04:38:36] <cmr> yeah :\
[04:38:37] <erickt1> lol
[04:38:38] <strcat> it was better when they leaked out of traits
[04:38:43] <erickt1> it was
[04:38:47] <olsonjeffery> put ALL the functions into the prelude!
[04:39:21] <strcat> maybe one day I'll convince pcwalton to make :: as screwed up as .
[04:39:27] <cmr> heh
[04:39:28] <strcat> so we can say T::from_str ;p
[04:39:30] *** Quits: carllerche (carllerche@6B070D22.7E6A0813.1428D117.IP) (Quit: carllerche)
[04:39:40] <strcat> if the trait is in scope
[04:39:46] * strcat shrugs
[04:40:09] <strcat> seems better than <for T> to me
[04:40:13] <cmr> It makes sense for all of them, but from_str is the most prominent one I think.
[04:40:13] <strcat> + qualifying the trait
[04:40:19] *** Quits: mihneadb (mihneadb@moz-329F29A3.lightspeed.sntcca.sbcglobal.net) (Input/output error)
[04:40:23] <strcat> depends on what you do
[04:40:25] <cmr> Maybe default once it actually gets used.
[04:40:29] <strcat> I use a lot of from_int
[04:40:47] <olsonjeffery> strcat: what about static methods with multiple parameters?
[04:41:04] <strcat> olsonjeffery: the T::foo part is just for the Self param
[04:41:06] <cmr> I think https://github.com/mozilla/rust/issues/7080 is the solution to the from_foo and to_foo craziness
[04:41:10] <strcat> s/is/would be/
[04:41:16] <olsonjeffery> ah, gotcha.
[04:41:21] <strcat> olsonjeffery: you'd say T::foo::<T, U>
[04:41:38] <strcat> instead of FooTrait::<for T>::foo::<T, U>
[04:41:49] <olsonjeffery> yes, i recall the discussion now.
[04:42:10] <erickt1> cmr: next question re default. I'd like to add a DefaultHashMap. Should We have one that uses Default::default, and another, say DefaultValueHashMap that clones some default value that gets passed in? What if we want to call a closure? DefaultClosureHashMap?
[04:42:20] <cmr> One problem with it is that it either needs to return Option, or fail.
[04:42:21] <olsonjeffery> alright im crashing out. night everyone.
[04:42:38] <cmr> And having it return Option can be quite messy IMO
[04:42:52] <erickt1> cmr: was that to me?
[04:42:57] <cmr> erickt1: no
[04:43:04] <cmr> was re-`as` trait
[04:43:15] *** Joins: dbaupp (Thunderbir@32354265.D5A1DCF.37681C44.IP)
[04:43:37] <olsonjeffery> did anyone look at ChrisMorgan's Stream impl for Read+Writer
[04:43:38] <olsonjeffery> it's a one liner
[04:43:43] <olsonjeffery> i don't think i can r+, otherwise i would.
[04:43:56] <olsonjeffery> https://github.com/mozilla/rust/pull/8984
[04:44:04] <cmr> erickt1: I don't really know the answer to that, sorry :(
[04:44:11] <erickt1> cmr:  i too would like to do away with the from/to silliness
[04:44:14] <erickt1> np
[04:44:38] <cmr> It looks a bit like feature creep to have all three, but all three are fairly useful.
[04:44:41] <jmgrosen> Luqman: is there anything I can do about the cruft around `children: [{â€¦}]` with Decoder? http://www.reddit.com/r/rust/.json
[04:44:49] <cmr> If you had to chose one, do the closure one
[04:45:04] <dbaupp> olsonjeffery: done
[04:45:08] <olsonjeffery> ty
[04:45:19] <Luqman> jmgrosen: what do you mean?
[04:45:30] <olsonjeffery> ok bed for real, now
[04:45:47] <erickt1> cmr: probably the best would be Default and Default-With-Closure. 
[04:46:03] *** Joins: skk (androirc@moz-DF027ED1.hsd1.nh.comcast.net)
[04:46:12] <jmgrosen> Luqman: there's the {data: { children: [ and it would be nice to not have to create structs for the things outside the children
[04:46:30] <ChrisMorgan> Quick! More pull requests! The queue is almost empty!
[04:46:32] <erickt1> cmr: It'd sure be nice if we could overload a trait without having to wrap the type though
[04:46:43] <erickt1> ChrisMorgan: Unpossible!
[04:46:46] <Luqman> jmgrosen: ah, i don't think so
[04:46:53] <cmr> erickt1: I think overloads would be a very useful feature.
[04:46:56] <jmgrosen> Luqman: alright
[04:47:05] <cmr> They do bring in their own rats nest of issues though
[04:47:08] *** Joins: carllerche (carllerche@6B070D22.7E6A0813.1428D117.IP)
[04:47:13] <dbaupp> cmr: is https://github.com/mozilla/rust/pull/8540 ready?
[04:47:22] <cmr> dbaupp: I was just checking that now :)
[04:47:38] *** Quits: tiffany (kawaii@moz-EB8B0C08.dhcp.embarqhsd.net) (Input/output error)
[04:48:26] *** Quits: brson (brson@6A848D32.C1B840DD.76F66111.IP) (Quit: leaving)
[04:48:40] <dbaupp> jmgrosen: have you tried just creating structs that mirror the format and use #[deriving(Encodable, Decodable)] with a dummy one for the outside layer that gets "automatically" unwrapped by the parsing function?
[04:48:57] *** Quits: skk (androirc@moz-DF027ED1.hsd1.nh.comcast.net) (Quit: AndroIRC - Android IRC Client ( http://www.androirc.com ))
[04:49:10] <jmgrosen> dbaupp: yeah, that's what I'm going to end up doing, but I was just wondering if there might be a better way
[04:49:23] <cmr> r? https://github.com/mozilla/rust/pull/8988
[04:49:29] <cmr> strcat: shoot that down now if you're opposed
[04:49:37] <cmr> I don't feel too strongly about it
[04:49:38] <dbaupp> jmgrosen: don't think so, unless you unwrap the first layer yourself and parse from there.
[04:49:43] <jmgrosen> yeah
[04:49:56] <strcat> cmr: well, I'm opposed to working around it like this because I think it won't be fixed if we do
[04:50:36] <strcat> working around a language flaw on a case-by-case basis sucks :(
[04:50:42] <cmr> yes, it really does
[04:52:15] * strcat hopes the bool + is_utf8 changes land
[04:52:20] *** Joins: sankha93 (Instantbir@CAF6D3FF.9C875DCD.9105FBCF.IP)
[04:52:29] <cmr> Did someone fix non-canonical bools?
[04:52:37] <strcat> well I forbid casts to them
[04:52:46] <cmr> oh
[04:52:47] <dbaupp> cmr: no, but `as bool` is disappearing
[04:52:51] <strcat> cmr: https://github.com/mozilla/rust/commit/d0a1176
[04:52:51] <cmr> that's one way to do it I guess :P
[04:52:56] <strcat> yeah it's the only way to get one
[04:53:04] <strcat> but ideally they should still be impl'ed as i1
[04:53:06] *** Joins: Uther (Instantbir@moz-1B244B05.hfc.dyn.abo.bbox.fr)
[04:53:09] <strcat> I'll do it eventually if no one else does
[04:53:23] *** Joins: huhlig-home (huhlig@moz-C8339267.hfc.comcastbusiness.net)
[04:53:37] <dbaupp> rusti: unsafe { std::cast::transmute::<u8, bool>(5) }
[04:53:39] -rusti- true
[04:53:44] <ChrisMorgan> Cross-crate macros?
[04:53:46] <strcat> (in safe code ;P)
[04:53:51] <strcat> ChrisMorgan: nope.
[04:53:51] <cmr> ChrisMorgan: what about them?
[04:53:56] <ChrisMorgan> :-(
[04:54:01] <strcat> ChrisMorgan: only leaking macros out of modules
[04:54:04] * dbaupp desperately clings to his weirdo bools
[04:54:06] <strcat> not xcrate
[04:54:15] <dbaupp> ChrisMorgan: just edit them into libsyntax :P
[04:54:23] <strcat> dbaupp: and inhabited uninhabited types?
[04:54:30] * ChrisMorgan wants to replace std::util::unreachable with a macro so that the top of the stack is meaningful
[04:54:36] <cmr> I don't have a project I work on with rust that *doesn't* use a custom-patched rustc
[04:54:42] <dbaupp> strcat: definitely, those are good too
[04:54:59] <Luqman> cmr: obviously need to port back all your changes then
[04:55:00] <dbaupp> cmr: o_O ?
[04:55:09] <cmr> Luqman: they both have/had pull requests
[04:55:14] <cmr> https://github.com/mozilla/rust/pull/8955
[04:55:19] <jmgrosen> Luqman: https://gist.github.com/jmgrosen/912a61753c7544577f19 this works! thanks for your help
[04:55:20] <cmr> https://github.com/mozilla/rust/pull/8437
[04:55:38] <dbaupp> ChrisMorgan: you could have a small macros file that just gets copied and included in the other projects
[04:55:40] <dbaupp> ChrisMorgan: (that's clearly suboptimal though)
[04:56:35] <cmr> we burned through the 8000's fairly slowly it seems
[04:56:40] <cmr> much more slowly than the 7000's
[04:57:06] <dbaupp> cmr: did you ever dig into #8437?
[04:57:10] <Luqman> jmgrosen: sweet, the decoder stuff is indeed much nicer
[04:57:26] <jmgrosen> Luqman: not perfect, but definitely nicer, yes
[04:57:42] <cmr> dbaupp: I spent ~2 hours trying to debug but didn't get anywhere
[04:58:05] <dbaupp> cmr: :( that damn extra::json
[04:59:24] <ChrisMorgan> Actually, there's an alternative to making unreachable a macro, a distinctly desirable alternative: let fail! specify how many levels it should go up the stack before printing the failure position. Thus, things like Option::unwrap could also go one level up.
[04:59:53] <cmr> ChrisMorgan: so unwind up X frames before printing the message and location?
[05:00:09] <ChrisMorgan> Yeah, those is the words I wanted.
[05:00:11] <cmr> Although isn't the location hardcodes into the message? Not sure.
[05:00:43] *** Quits: dbaupp (Thunderbir@32354265.D5A1DCF.37681C44.IP) (Ping timeout)
[05:01:22] <ChrisMorgan> Yeah, it uses file!() and line!(). :-(
[05:02:10] <cmr> "/home/cmr/hacking/rust-benching/src/llvm/tools/clang/utils/TableGen/TableGen.cpp:22:10: fatal error: 'llvm/TableGen/TableGenAction.h' file not found
[05:02:18] <cmr> Need a clean-llvm?
[05:02:50] *** Joins: DAddYE (DAddYE@moz-98D3933F.hsd1.ca.comcast.net)
[05:02:59] *** Quits: boredomist (user@moz-63CF9F31.res-cmts.sesp.ptd.net) (Ping timeout)
[05:03:32] <cmr> ...or maybe just an additional `make`
[05:03:34] <cmr> weird
[05:03:42] *** Quits: erickt1 (Adium@49C4075F.3AC15C18.2321E71E.IP) (Quit: Leaving.)
[05:04:52] <ChrisMorgan> std_macros in src/libsyntax/ext/expand.rs has a big long string literal with Rust code. I think it'd be much nicer as a separate file with include_str!().
[05:05:02] <cmr> ChrisMorgan: go for it
[05:05:13] <ChrisMorgan> I'm putting unreachable in it first.
[05:07:30] <ChrisMorgan> Uh oh... make isn't building libsyntax. How can I force it to do that first?
[05:07:44] *** Quits: carllerche (carllerche@6B070D22.7E6A0813.1428D117.IP) (Connection reset by peer)
[05:08:02] *** Joins: aeqwa (aeqwa@moz-30FF82AD.dsl.tropolys.de)
[05:08:15] <jack> ChrisMorgan: did you have a build going when you edited libsyntax?
[05:08:38] <jack> if so, just touch some file in libsyntax and it should pick up the change.
[05:09:22] *** Joins: lmandel (lmandel@moz-76CE9D51.cable.teksavvy.com)
[05:11:15] *** Quits: aatch (aatch@moz-B437F499.pocketrent.com) (Ping timeout)
[05:11:39] *** Quits: jmgrosen (jmgrosen@moz-848F6087.sb.sd.cox.net) (Quit: jmgrosen)
[05:12:52] <ChrisMorgan> jack: no
[05:13:44] *** Quits: austincheney (quassel@8276C73B.985A737F.603BFF2.IP) (Connection reset by peer)
[05:13:45] <ChrisMorgan> Nor does touching anything in libsyntax seem to trigger anything.
[05:13:47] *** Joins: austincheney (quassel@8276C73B.985A737F.603BFF2.IP)
[05:16:06] *** Quits: bent (chatzilla@moz-932324BF.hsd1.ca.comcast.net) (Quit: ChatZilla 0.9.90.1-rdmsoft [XULRunner 22.0/20130619132145])
[05:16:15] <strcat> bors, hurry up and merge it
[05:16:17] <strcat> :s
[05:16:44] <cmr> Does anyone know if graydon has left the rust project entirely or not?
[05:16:51] *** Joins: aatch (aatch@moz-B437F499.pocketrent.com)
[05:17:58] * ChrisMorgan decided to settle for ``make clean``, seeing as ``make`` wasn't working properly
[05:18:24] <ChrisMorgan> Hang onâ€”it _still_ tries compiling libstd first. What's going on?
[05:18:30] <strcat> cmr: I don't have any more information than you, but I got the impression that he needed a break from it whether or not he'll be back in a non-leadership role
[05:18:43] <cmr> strcat: yeah, that's the gist I got too
[05:18:50] *** Quits: lmandel (lmandel@moz-76CE9D51.cable.teksavvy.com) (Ping timeout)
[05:19:15] <cmr> I hope he's ok, it'd suck to have his own project outgrow his capacity to the point of harmful overextension
[05:19:17] <sfackler> ChrisMorgan: libstd doesn't depend on libsyntax
[05:19:50] <strcat> cmr: well he was spending all his time putting out fires and herding cats, I think he wants to be programming
[05:19:50] <ChrisMorgan> Is this one of the sorts of changes where a new snapshot is needed with the changes in libsyntax before you can make use of the alterations in libstd?
[05:20:03] <sfackler> yep, or toss #[cfg(stage0] everywhere
[05:20:17] <strcat> cmr: but again, I am just speculating :P
[05:20:27] *** Quits: anri (solancile@moz-E49E7C4B.hsd1.wa.comcast.net) (Ping timeout)
[05:20:27] <cmr> ChrisMorgan: if you're just shuffling around the core-macros string to an include_str it shouldn't matter
[05:20:33] <cmr> if you're *adding* a macro, yes.
[05:20:46] *** Joins: ghrust (ghrust@2EE61FCC.6A2AE50.F3114085.IP)
[05:20:46] <ghrust> 01[13rust01] 15bors merged 06auto into 06master: 02http://git.io/D0PdOA
[05:20:46] *** Parts: ghrust (ghrust@2EE61FCC.6A2AE50.F3114085.IP) ()
[05:20:51] <strcat> thanks bors.
[05:21:02] <ChrisMorgan> cmr: this is for changing std::util::unreachable to a macro
[05:21:08] *** Quits: azita (Azita@moz-C1FB2A8.hsd1.ca.comcast.net) (Quit: azita)
[05:21:38] *** Joins: lmandel (lmandel@moz-76CE9D51.cable.teksavvy.com)
[05:22:04] <strcat> rusti:  "0x27 0x0a 0x27"
[05:22:04] -rusti- "0x27 0x0a 0x27"
[05:22:48] <strcat> oh this bug is about source code
[05:22:50] <ChrisMorgan> How should I do it then: duplicate the single-line macro in libstd/macros.rs inside a module there with #[cfg(stage0)], or retain the existing function and don't switch libstd to using the macro yet, or something else?
[05:22:51] <strcat> heh
[05:23:20] <cmr> ChrisMorgan: IMO path of least resistance
[05:23:33] <cmr> retain the function, mark it with a // NOTE:
[05:24:23] <ChrisMorgan> I guess if I went with the first route, then as soon as a new snapshot was made the code would break on account of having a duplicated macro.
[05:24:48] <cmr> rusti: macro_rules! fail() {};
[05:24:48] -rusti- <anon>:1:0: 1:0 error: Unexpected end of macro invocation
[05:24:48] -rusti- <anon>:1 extern mod extra;
[05:24:48] -rusti-          ^
[05:24:49] -rusti- application terminated with error code 101
[05:25:20] <cmr> rusti: macro_rules! fail() { () => () };
[05:25:21] -rusti- <anon>:5:34: 5:36 error: expected one of `; }` but found `=>`
[05:25:21] -rusti- <anon>:5          macro_rules! fail() { () => () };
[05:25:21] -rusti-                                            ^~
[05:25:21] -rusti- application terminated with error code 101
[05:25:25] <ChrisMorgan> rusti: macro_rules! fail(()=>())
[05:25:25] -rusti- ()
[05:25:28] <cmr> ah
[05:25:40] <ChrisMorgan> rusti: macro_rules! stringify(()=>())
[05:25:41] -rusti- ()
[05:25:45] *** Joins: ghrust (ghrust@1E8607E8.6A2AE50.F3114085.IP)
[05:25:45] <ghrust> 01[13rust01] 15bors pushed 0 new commits to 06auto: 02http://git.io/mR-r0g
[05:25:45] *** Parts: ghrust (ghrust@1E8607E8.6A2AE50.F3114085.IP) ()
[05:25:46] *** Joins: ghrust (ghrust@F6EE6DE3.6A2AE50.F3114085.IP)
[05:25:46] <ghrust> 01[13rust01] 15bors pushed 2 new commits to 06auto: 02http://git.io/m7wPTw
[05:25:46] <ghrust> 13rust/06auto 14ba1f663 15Alex Crichton: Raise errors on format strings with unmatched `}`...
[05:25:46] <ghrust> 13rust/06auto 142bd628e 15bors: auto merge of #8944 : alexcrichton/rust/issue-8938, r=huonw...
[05:25:47] *** Parts: ghrust (ghrust@F6EE6DE3.6A2AE50.F3114085.IP) ()
[05:25:53] <ChrisMorgan> rusti: macro_rules! fail(()=>()) fail!()
[05:25:53] -rusti- <anon>:1:0: 1:0 error: unexpected token: `<eof>`
[05:25:53] -rusti- <anon>:1 extern mod extra;
[05:25:54] -rusti-          ^
[05:25:54] -rusti- application terminated with error code 101
[05:26:05] <ChrisMorgan> rusti: macro_rules! fail(()=>()) fail!();
[05:26:05] -rusti- <anon>:1:0: 1:0 error: unexpected token: `<eof>`
[05:26:06] -rusti- <anon>:1 extern mod extra;
[05:26:06] -rusti-          ^
[05:26:06] -rusti- application terminated with error code 101
[05:26:14] <ChrisMorgan> rusti: macro_rules! failz(()=>()) failz!();
[05:26:14] -rusti- <anon>:1:0: 1:0 error: unexpected token: `<eof>`
[05:26:14] -rusti- <anon>:1 extern mod extra;
[05:26:14] -rusti-          ^
[05:26:14] -rusti- application terminated with error code 101
[05:26:55] <sfackler> the nice thing with making #[cfg(stage0)] and #[cfg(not(stage0))] versions of everything is that it forces the right hting to happen at snapshot time
[05:26:59] <ChrisMorgan> That is rather weird.
[05:27:16] <ChrisMorgan> Why is there this unexpected token <eof>?
[05:29:15] <strcat> ChrisMorgan: happens on 0.7 too, thankfully I didn't cause it \o/
[05:29:18] * strcat was worried for a second
[05:29:37] <ChrisMorgan> But what is it that's going wrong?
[05:29:42] <strcat> ChrisMorgan: dunno :(
[05:29:45] <cmr> Guh dammit, just barely missed the bors window.
[05:30:01] <strcat> ChrisMorgan: I'd guess it's looking for some closing delimiter but finds eof...
[05:30:06] <strcat> but I don't see where
[05:30:18] <cmr> https://github.com/mozilla/rust/pull/8540 rustdoc_ng will be in mainline! yay!
[05:30:21] <ChrisMorgan> That's code complete.
[05:30:43] <cmr> now someone write a good template library so we can port the node code over :p
[05:30:44] <ChrisMorgan> Oh, so libextra also gets built in stage 0 :-(
[05:30:45] <klutzy> rusti: macro_rules! failz(()=>()) failz!();26;
[05:30:45] -rusti- <anon>:1:0: 1:0 error: unexpected token: `<eof>`
[05:30:45] -rusti- <anon>:1 extern mod extra;
[05:30:45] -rusti-          ^
[05:30:45] -rusti- application terminated with error code 101
[05:30:54] *** Joins: jviereck (Adium@moz-58A87BA7.dip0.t-ipconnect.de)
[05:31:40] * ChrisMorgan just named a temporary working file "mac.rs"
[05:32:40] *** Quits: cubic (cubic@moz-FE5AD6C7.mc.videotron.ca) (Quit: Leaving)
[05:33:38] <ChrisMorgan> So, macros can be overridden. Not sure if I like that, though it's convenient just now.
[05:37:37] *** Quits: jviereck (Adium@moz-58A87BA7.dip0.t-ipconnect.de) (Quit: Leaving.)
[05:37:38] <zeuxcg> rusti: printfln!("%?", 1)
[05:37:38] -rusti- 1
[05:37:39] -rusti- ()
[05:37:43] <zeuxcg> rusti: println!("%?", 1)
[05:37:43] -rusti- <anon>:5:24: 5:25 error: argument never used
[05:37:49] -rusti- <anon>:5          println!("%?", 1)
[05:37:49] -rusti-                                  ^
[05:37:49] -rusti- error: aborting due to previous error
[05:37:49] -rusti- application terminated with error code 101
[05:37:54] <zeuxcg> rusti: fn foo() {} foo!()
[05:37:55] -rusti- <anon>:5:21: 5:24 error: macro undefined: 'foo'
[05:38:00] -rusti- <anon>:5          fn foo() {} foo!()
[05:38:00] -rusti-                               ^~~
[05:38:00] -rusti- application terminated with error code 101
[05:38:00] <zeuxcg> hm
[05:38:26] <ChrisMorgan> When will (fmt|printf(ln)?)! disappear? When will debug! et al. start using format! instead of fmt!?
[05:38:32] <zeuxcg> rusti: println!("{}", 1)
[05:38:33] -rusti- 1
[05:38:33] -rusti- ()
[05:38:37] <zeuxcg> uh
[05:39:02] <zeuxcg> printfln! uses the old formatting specs, and println! uses the new ones?
[05:39:07] <ChrisMorgan> Yes.
[05:41:16] *** Quits: paulproteus (quassel@rose.makesad.us) (Ping timeout)
[05:41:25] *** Joins: paulproteus (quassel@moz-E86A3B42.makesad.us)
[05:42:34] <ChrisMorgan> How soon is the next snapshot due?
[05:43:03] <strcat> ChrisMorgan: I was going to make one but there's valgrind uncleanness
[05:43:10] <strcat> since we don't run the vg bots anymore, stuff sneaks in
[05:43:31] <strcat> so, not determined - at least 2 bugs to bisect/fix
[05:43:42] *** Joins: jviereck (Adium@moz-58A87BA7.dip0.t-ipconnect.de)
[05:44:09] <Uther> Hi, noob question incoming
[05:44:25] <Uther> I have trouble using ReaderUtil
[05:45:01] <Uther> what wrong with my code : https://gist.github.com/anonymous/bf818648677763f2516a
[05:45:46] <klutzy> Uther: read_line() i think
[05:46:09] <Uther> I'm an idiot
[05:46:30] <Uther> to used to Java convention
[05:48:28] <Uther> It's better anyway. I thought i missed something about how impl was working
[05:49:26] <Uther> thanks
[05:49:55] <bjz> Uther: dw about noob questions!
[05:50:02] <bjz> we are here to serve!
[05:51:12] * strcat will accept tips in the form of ice cream
[05:51:38] *** Joins: fabiand (fabiand@moz-A588C99B.adsl.alicedsl.de)
[05:52:21] <Luqman> strcat: is there a service for this?
[05:52:45] <strcat> petition gittip to add ice cream support
[05:52:47] <strcat> ;p
[05:53:15] <Luqman> perhaps they'll do a special offer in april
[05:53:47] *** Quits: enix (enix@moz-A50569DD.c3-0.slvr-ubr1.lnh-slvr.md.cable.rcn.com) (Quit: Konversation terminated!)
[05:53:47] * bjz prefers a cup of coffee from the fancy espresso bar down the road
[05:55:22] <Luqman> i hear the mozilla toronto office really love their espresso machine
[05:55:31] <acrichto> strcat: --llvm-args is comma-delimited
[05:55:45] *** Quits: bblum (bblum@moz-2B41ACB5.andrew.cmu.edu) (Ping timeout)
[05:55:48] *** Quits: mjrosenb|ARM (mjrosenb@moz-B3592BDA.club.cc.cmu.edu) (Ping timeout)
[05:56:32] *** Joins: bblum (bblum@moz-2B41ACB5.andrew.cmu.edu)
[05:57:25] <strcat> acrichto: yeah figured it out
[05:57:32] <mm> Luqman: I have heard so much about that goddamn espresso machine
[05:57:44] <mm> the mountain view one just wasn't that good :P
[05:57:47] *** Quits: acrichto (acrichto@moz-69F2E428.ugrad.cs.cmu.edu) (Ping timeout)
[05:57:55] *** Quits: rpearl (rpearl@moz-2B41ACB5.andrew.cmu.edu) (Ping timeout)
[05:58:05] <Luqman> mm: haha, well it certainly did look fancy at least
[05:58:11] *** Quits: rntz (rntz@moz-C76A8D96.sp.cs.cmu.edu) (Ping timeout)
[05:58:28] *** Quits: bblum (bblum@moz-2B41ACB5.andrew.cmu.edu) (Ping timeout)
[05:58:32] <mm> maybe they got a new one? didn't look that fancy when I was there :P
[05:58:33] *** Quits: zwol (zack@moz-B5C129C.ece.cmu.edu) (Ping timeout)
[05:58:39] *** Joins: rntz (rntz@moz-C76A8D96.sp.cs.cmu.edu)
[05:58:42] *** Joins: acrichto (acrichto@moz-69F2E428.ugrad.cs.cmu.edu)
[05:58:44] *** Joins: zwol (zack@moz-B5C129C.ece.cmu.edu)
[05:58:47] <Luqman> mm: i mean the toronto one
[05:59:03] <mm> Oh.  Yeah.
[06:01:11] *** Joins: mjrosenb|ARM (mjrosenb@moz-B3592BDA.club.cc.cmu.edu)
[06:01:33] *** Joins: bblum (bblum@moz-2B41ACB5.andrew.cmu.edu)
[06:02:48] <ChrisMorgan> strcat: sorry, but I think international payout support is marginally higher on the importance list than icecream payments.
[06:02:54] *** Joins: james4k (james@moz-E7990244.consolidated.net)
[06:03:10] <strcat> international payout in ice cream
[06:03:17] *** Joins: rpearl (rpearl@moz-2B41ACB5.andrew.cmu.edu)
[06:03:18] <strcat> the universal currency
[06:03:29] <mm> orbital drop shipping
[06:03:44] <mm> somebody go work out the thermodynamics to have it land perfectly frozen
[06:04:47] <Infiltrator> mm: You'd need to heat-shield it.
[06:05:04] *** Quits: jstevans (Instantbir@472AB8DE.1D53A164.B7830B68.IP) (Ping timeout)
[06:05:16] <mm> Well yeah.  I don't want a ball of ice cream just sitting on the sidewalk :P
[06:05:25] <mm> Needs a container!
[06:05:56] <Infiltrator> A disproportionately large container, though.
[06:06:10] <ChrisMorgan> I might not become a millionaire through rust-http. Maybe I might if I sold icecream for bitcoin?
[06:08:32] *** Joins: tgummerer (tgummerer@51D3B54.FEF996EA.EA6FEF3D.IP)
[06:08:46] *** Quits: pepper_chico (pepper_chi@14AC4DFD.704EE6B0.E4090502.IP) (Quit: Textual IRC Client: www.textualapp.com)
[06:10:17] *** Quits: jviereck (Adium@moz-58A87BA7.dip0.t-ipconnect.de) (Quit: Leaving.)
[06:12:54] *** Quits: DAddYE (DAddYE@moz-98D3933F.hsd1.ca.comcast.net) (Ping timeout)
[06:14:07] <sfackler> has anyone run into linker errors like this? undefined reference to `__extensions__::__static_fmtstr::_1cee2de1ca32d67b::_0$x2e1'
[06:14:08] *** Joins: NewGuy (Mibbit@moz-31DAE88F.resnet.usf.edu)
[06:14:14] *** Quits: sankha93 (Instantbir@CAF6D3FF.9C875DCD.9105FBCF.IP) (Quit: Gone to save the world!)
[06:14:39] *** Joins: tjc (tjc@moz-6EB4E533.dsl.tsoft.com)
[06:14:39] *** ChanServ sets mode: +o tjc
[06:15:06] *** Quits: aeqwa (aeqwa@moz-30FF82AD.dsl.tropolys.de) (Quit: Lost terminal)
[06:16:47] *** Quits: tjc (tjc@moz-6EB4E533.dsl.tsoft.com) (Quit: Places to go, people to annoy)
[06:19:56] *** Joins: robertknight_ (robertknig@moz-29DA0AFD.range86-162.btcentralplus.com)
[06:20:41] <acrichto> sfackler: are you compiling a library?
[06:20:51] <acrichto> and is that code perhaps in a type-parameterized function?
[06:20:54] <acrichto> or impl
[06:21:16] <acrichto> I've seen that bug in that situation, and I'm trying to fix the problems but it's slow progress, I need more time to work on rust :(
[06:21:35] <sfackler> it's test code linking against a library with a type parameterized method
[06:21:55] <lkuper_> acrichto: ugh, I messed that merge up, one sec
[06:22:09] <acrichto> sfackler: yeah that sounds about right
[06:22:18] <acrichto> inner statics aren't always working
[06:22:23] <acrichto> their symbols names get conflated
[06:22:27] <lkuper_> hard to say if it compiles since llvm is still rebuilding, but it sure shouldn't
[06:22:31] <sfackler> is there a workaround?
[06:22:37] <acrichto> if you add the symbol name A to llvm twice, it silently renames the second to A1
[06:23:00] <acrichto> sfackler: https://github.com/mozilla/rust/pull/8875 may fix some issues, I don't know of a workaround other than only calling format! once in a function
[06:23:11] <acrichto> lkuper_: no worries
[06:23:16] <acrichto> lkuper_: I recommend ccache
[06:23:23] <acrichto> it has sped up my llvm compilation times massively
[06:23:27] <sfackler> cool, will fmt! or "a" + "b" work too?
[06:23:33] *** Quits: alisdair (textual@1697D94C.7742FB18.FBC8476D.IP) (Quit: My MacBook Pro has gone to sleep. ZZZzzzâ€¦)
[06:23:47] <acrichto> sfackler: yeah fmt! should work
[06:23:51] <ChrisMorgan> I just got a spurious error with make install: "/home/chris/vc/rust/mk/install.mk:136: *** Aborting install because more than one library matching libstd-*.so is present in build tree x86_64-unknown-linux-gnu/stage2/lib: .  Stop." If I run make install again, it works.
[06:23:58] <acrichto> if you have info2! statements you'll also have to remove them
[06:24:17] <acrichto> ChrisMorgan: pnkfelix may know about that
[06:24:25] <sfackler> thanks
[06:25:01] <acrichto> sfackler: that's blocking using format! by default so that should be fixed soon
[06:26:07] <ChrisMorgan> Why is the main task unnamed? Seems to me that "task main failed at x" would be nicer than "task <unnamed> failed at x".
[06:29:48] *** Joins: threecreepio (jdp@moz-71E164C9.cust.bredbandsbolaget.se)
[06:30:24] <acrichto> sfackler: retrying that commit, although I'm not convinced that it fixes the problem. The goal of it was to fix the problem but I still had problems building stage1 libstd which I never tracked down
[06:30:49] *** Joins: ghrust (ghrust@C8693FCB.6A2AE50.F3114085.IP)
[06:30:49] <ghrust> 01[13rust01] 15bors merged 06auto into 06master: 02http://git.io/m7wPTw
[06:30:49] *** Parts: ghrust (ghrust@C8693FCB.6A2AE50.F3114085.IP) ()
[06:35:45] *** Joins: ghrust (ghrust@9C8B94D4.6A2AE50.F3114085.IP)
[06:35:45] <ghrust> 01[13rust01] 15bors pushed 0 new commits to 06auto: 02http://git.io/7JoshA
[06:35:45] *** Parts: ghrust (ghrust@9C8B94D4.6A2AE50.F3114085.IP) ()
[06:35:46] *** Joins: ghrust (ghrust@9C8B94D4.6A2AE50.F3114085.IP)
[06:35:46] <ghrust> 01[13rust01] 15bors pushed 4 new commits to 06auto: 02http://git.io/mgYVOA
[06:35:46] <ghrust> 13rust/06auto 148aa96d0 15Corey Richardson: Add rustdoc_ng
[06:35:46] <ghrust> 13rust/06auto 148c42cbf 15Corey Richardson: Slight restructure of rustdoc_ng
[06:35:46] <ghrust> 13rust/06auto 1458534f6 15Felix S. Klock II: Finish addition of rustdoc_ng to Makefiles.
[06:35:48] *** Parts: ghrust (ghrust@9C8B94D4.6A2AE50.F3114085.IP) ()
[06:37:22] *** Joins: LRN (LRN@moz-50DF30B.nationalcablenetworks.ru)
[06:39:30] *** Joins: DAddYE (DAddYE@moz-98D3933F.hsd1.ca.comcast.net)
[06:39:51] <LRN> Quintessential quick question query: why "extern mod" instead of, say, "import" or "link" (tutorial has to explicitly say that "mod" and "extern mod" are two unrelated things)
[06:41:56] <sfackler> extern mod avoids an extra keyword, but i'm not sure if that's the main reason
[06:42:21] *** Quits: Earnestly (earnest@moz-F387F877.dyn.plus.net) (Ping timeout)
[06:43:33] <ChrisMorgan> r? https://github.com/mozilla/rust/pull/8992 (added unreachable!() macro)
[06:43:37] *** Joins: nkoep (nik@moz-A196DCE9.pool.mediaways.net)
[06:44:09] <strcat> ChrisMorgan: how about marking it #[inline(always)] instead?
[06:44:22] <strcat> that will get inlined at -O0
[06:44:33] <ChrisMorgan> strcat: doesn't help; the file!() and line!() are still those where the code appears
[06:44:47] <strcat> ah right those
[06:51:02] * ChrisMorgan just realised how easy and rusty/rustic (?) it would be to mix client and server code in a Rust web server/client environment using Emscripten for JS translation: use the attributes #[cfg(server)] and #[cfg(client)]
[06:51:17] *** Joins: Ms2ger (Ms2ger@moz-B53902AE.adsl-dyn.isp.belgacom.be)
[06:52:29] *** Quits: threecreepio (jdp@moz-71E164C9.cust.bredbandsbolaget.se) (Quit: threecreepio)
[06:54:45] <NewGuy> I apologize for the ignorance, it's 3 in the morning and I'm attempting to learn me some Rust. Bit stuck on the iterators though (even with the contains & Iterator page)
[06:55:47] *** Joins: ghrust (ghrust@24260B07.6A2AE50.F3114085.IP)
[06:55:47] <ghrust> 01[13rust01] 15bors 04force-pushed 06auto from 14d111834 to 142bd628e: 02http://git.io/N3iJvQ
[06:55:47] *** Parts: ghrust (ghrust@24260B07.6A2AE50.F3114085.IP) ()
[06:55:50] *** Joins: ghrust (ghrust@79968228.6A2AE50.F3114085.IP)
[06:55:50] <ghrust> 01[13rust01] 15bors pushed 4 new commits to 06auto: 02http://git.io/CYXS2w
[06:55:50] <ghrust> 13rust/06auto 144600212 15Alex Crichton: Fix inner statics having the same symbol name...
[06:55:50] <ghrust> 13rust/06auto 1436a4af4 15Alex Crichton: Remove __extensions__ in names for a "pretty name"...
[06:55:51] <ghrust> 13rust/06auto 147baff57 15Alex Crichton: Improve name mangling for gdb...
[06:55:53] *** Parts: ghrust (ghrust@79968228.6A2AE50.F3114085.IP) ()
[06:55:53] <NewGuy> I went to the std::str documentation, looking for how I would go about iterating over the bytes/chars of the string one by one, and I'm a bit... lost.
[06:55:57] *** Joins: dbaupp (Thunderbir@moz-EAA09AEF.lns20.syd7.internode.on.net)
[06:56:44] <strcat> the iter methods
[06:57:02] <sfackler> no problem! str.iter iterates over the characters of a string and byte_iter iterates over the bytes
[06:57:19] <strcat> byte_iter, split_iter, etc.
[06:57:25] <sfackler> rusti: for ch in "hello".iter() { println!("{}", ch); }
[06:57:29] <strcat> there are a bunch
[06:57:30] -rusti- pastebinned 6 lines of output: http://ix.io/7Rm
[06:57:40] <sfackler> and
[06:57:45] <sfackler> rusti: for ch in "hello".bytes_iter() { println!("{}", ch); }
[06:57:47] -rusti- pastebinned 13 lines of output: http://ix.io/7Rn
[06:58:07] <sfackler> rusti: for byte in "hello".byte_iter() { println!("{}", byte); }
[06:58:09] -rusti- pastebinned 6 lines of output: http://ix.io/7Ro
[06:58:43] <NewGuy> Wow, thanks guys.
[06:59:58] *** Quits: rusti (rusti@moz-54F7FD49.cpe.net.cable.rogers.com) (Client exited)
[07:00:10] *** Quits: strcat (strcat@moz-54F7FD49.cpe.net.cable.rogers.com) (Quit: WeeChat 0.4.1)
[07:01:27] *** Joins: strcat (strcat@moz-54F7FD49.cpe.net.cable.rogers.com)
[07:01:30] *** Joins: csherratt (Mibbit@moz-CAF331EA.cable.teksavvy.com)
[07:01:44] *** Joins: rusti (rusti@moz-54F7FD49.cpe.net.cable.rogers.com)
[07:02:14] *** Joins: squiddy (squiddy@moz-F34769CA.adsl.alicedsl.de)
[07:03:54] *** Quits: robertknight_ (robertknig@moz-29DA0AFD.range86-162.btcentralplus.com) (Ping timeout)
[07:05:00] *** Joins: wilkie (wilkie@moz-CEF5E490.pitbpa.fios.verizon.net)
[07:07:56] *** Joins: lenstr (lenstr@AF8EB999.6049B16A.85938D85.IP)
[07:08:03] *** Quits: rusti (rusti@moz-54F7FD49.cpe.net.cable.rogers.com) (Client exited)
[07:08:32] *** Quits: ChrisMorgan (chris@moz-F21755A5.its.monash.edu.au) (Ping timeout)
[07:08:47] *** Joins: strcat1 (strcat@moz-54F7FD49.cpe.net.cable.rogers.com)
[07:09:02] *** Quits: strcat (strcat@moz-54F7FD49.cpe.net.cable.rogers.com) (Connection reset by peer)
[07:11:05] *** Joins: sigma (sigma@51C589B3.EF2694B5.DFAC6AA7.IP)
[07:12:41] *** Joins: rusti (rusti@moz-54F7FD49.cpe.net.cable.rogers.com)
[07:12:51] *** strcat1 is now known as strcat
[07:14:56] *** Quits: Ms2ger (Ms2ger@moz-B53902AE.adsl-dyn.isp.belgacom.be) (Quit: bbl)
[07:15:00] *** Quits: SiegeLord (sl@moz-CAF07B4C.hsd1.ma.comcast.net) (Quit: It's a joke, it's all a joke.)
[07:15:56] *** Joins: threecreepio (jdp@moz-1A9F0A3C.cust.bredband2.com)
[07:17:53] *** Quits: Shaladdle (Shaladdle@moz-424BC304.hsd1.pa.comcast.net) (Quit: Leaving)
[07:17:57] *** Joins: Shaladdle (Shaladdle@moz-424BC304.hsd1.pa.comcast.net)
[07:20:12] *** Quits: james4k (james@moz-E7990244.consolidated.net) (Quit: WeeChat 0.4.1)
[07:21:29] *** flaper87|afk is now known as flaper87
[07:23:54] *** Quits: doomlord (doomlod@moz-13E69BC8.range86-180.btcentralplus.com) (Ping timeout)
[07:29:10] *** Joins: doomlord (doomlod@moz-13E69BC8.range86-180.btcentralplus.com)
[07:32:14] *** Quits: bjz (brendanzab@B398BE78.F804C29E.D35A31DF.IP) (Quit: Leaving...)
[07:44:31] <strcat> rusti: 2
[07:44:34] -rusti- 2
[07:44:37] *** Quits: strcat (strcat@moz-54F7FD49.cpe.net.cable.rogers.com) (Quit: sleep)
[07:44:39] <zeuxcg> rusti: -12.0f32 as u8
[07:44:41] -rusti- 0u8
[07:44:53] <zeuxcg> rusti: 312.0f32 as u8
[07:44:54] -rusti- 255u8
[07:46:17] *** Quits: six600110 (six600110@moz-2FA48202.neo.res.rr.com) (Ping timeout)
[07:47:01] *** Joins: six600110 (six600110@moz-2FA48202.neo.res.rr.com)
[07:47:29] *** Quits: wilkie (wilkie@moz-CEF5E490.pitbpa.fios.verizon.net) (Ping timeout)
[07:50:40] <dbaupp> rusti: 312.0f32 as uint as u8
[07:50:40] -rusti- 56u8
[07:52:32] <acrichto> lkuper_: ping
[07:52:42] <acrichto> lkuper_: wait, unping
[07:53:56] <dbaupp> acrichto: it's permanent, like a tattoo
[07:56:07] <acrichto> :(
[07:56:14] <acrichto> yay name mangling passed
[07:56:29] <acrichto> now I can re-attempt to make progress on format!-ifying
[07:56:45] <dbaupp> awesome :)
[07:56:54] <acrichto> libuv first though
[07:58:19] <dbaupp> do we know the problem with the windows speed regression?
[07:58:32] <dbaupp> (and the segfaults?)
[08:00:51] *** Joins: ghrust (ghrust@F6EE6DE3.6A2AE50.F3114085.IP)
[08:00:51] <ghrust> 01[13rust01] 15bors merged 06auto into 06master: 02http://git.io/CYXS2w
[08:00:51] *** Parts: ghrust (ghrust@F6EE6DE3.6A2AE50.F3114085.IP) ()
[08:01:00] *** Joins: squiddy_ (squiddy@moz-E4F84460.adsl.alicedsl.de)
[08:01:57] *** Quits: squiddy (squiddy@moz-F34769CA.adsl.alicedsl.de) (Ping timeout)
[08:03:09] *** Joins: FrozenCow (FrozenCow@moz-B2DF4929.chello.nl)
[08:03:39] *** Quits: lenstr (lenstr@AF8EB999.6049B16A.85938D85.IP) (Client exited)
[08:03:58] <acrichto> dbaupp: we do know the windows regression
[08:04:03] <acrichto> turned out the tests just rebuilt the compiler
[08:04:10] <acrichto> and I was never smart enough to actually read the logs
[08:04:32] *** Quits: rbancroft (rumble@99CB1D09.5825E03B.F97ED6F2.IP) (Ping timeout)
[08:04:40] <acrichto> the segafaults I hypothesize were in the process bindings code
[08:04:43] <acrichto> (hoping)
[08:05:12] *** Joins: Blub\w (wry@7E3BB9D.71150E1A.237AE2BA.IP)
[08:05:48] *** Joins: ghrust (ghrust@2EE61FCC.6A2AE50.F3114085.IP)
[08:05:48] <ghrust> 01[13rust01] 15bors pushed 0 new commits to 06auto: 02http://git.io/j90cIg
[08:05:48] *** Parts: ghrust (ghrust@2EE61FCC.6A2AE50.F3114085.IP) ()
[08:05:52] *** Joins: ghrust (ghrust@79968228.6A2AE50.F3114085.IP)
[08:05:52] <ghrust> 01[13rust01] 15bors pushed 5 new commits to 06auto: 02http://git.io/ZSXxUQ
[08:05:52] <ghrust> 13rust/06auto 141fbbc71 15Alex Crichton: Move llvm into the artifacts build directory
[08:05:52] <ghrust> 13rust/06auto 1444be4a4 15Alex Crichton: Move the llvm auto-clean stamp into $target/llvm
[08:05:52] <ghrust> 13rust/06auto 146b3c7cb 15Alex Crichton: Build rustllvm into $target/rustllvm
[08:05:54] *** Parts: ghrust (ghrust@79968228.6A2AE50.F3114085.IP) ()
[08:05:54] <acrichto> gmail is flagging rust email as spam :(
[08:06:41] *** Quits: NewGuy (Mibbit@moz-31DAE88F.resnet.usf.edu) (Quit: http://www.mibbit.com ajax IRC Client)
[08:06:50] *** flaper87 is now known as flaper87|afk
[08:07:32] <dbaupp> acrichto: woah, that would make the tests a little slower.
[08:07:37] <acrichto> yeah lol
[08:07:43] <acrichto> http://buildbot.rust-lang.org/builders/auto-win-32-opt/builds/1147/steps/test/logs/stdio
[08:07:46] <acrichto> that's the log for the tests
[08:09:02] <acrichto> I know DaGenix is on irc, what's their handle again?
[08:10:49] *** Joins: rbancroft (rumble@moz-4E8E0D7F.cg.shawcable.net)
[08:11:28] <dbaupp> enix
[08:12:06] <acrichto> aww not here to spread awesomeness
[08:12:37] *** Quits: rbancroft (rumble@moz-4E8E0D7F.cg.shawcable.net) (Ping timeout)
[08:14:05] * dbaupp is apparently in a must-use-moar-iterators mood
[08:15:22] <acrichto> that's b/c iterators are awesome
[08:15:49] *** Joins: rbancroft (rumble@moz-4E8E0D7F.cg.shawcable.net)
[08:16:39] *** Joins: lenstr (lenstr@AF8EB999.6049B16A.85938D85.IP)
[08:16:48] *** Quits: achin (achin@moz-193F7FAD.ri.ri.cox.net) (Ping timeout)
[08:17:13] *** Joins: wilkie (wilkie@moz-CEF5E490.pitbpa.fios.verizon.net)
[08:17:36] *** Quits: rbancroft (rumble@moz-4E8E0D7F.cg.shawcable.net) (Ping timeout)
[08:17:59] *** Joins: achin (achin@moz-193F7FAD.ri.ri.cox.net)
[08:18:24] *** flaper87|afk is now known as flaper87
[08:20:13] <acrichto> olsonjeffery: posted a PR for the new libuv
[08:20:14] *** Quits: austincheney (quassel@8276C73B.985A737F.603BFF2.IP) (Connection reset by peer)
[08:20:15] *** Joins: austincheney (quassel@8276C73B.985A737F.603BFF2.IP)
[08:20:49] *** Joins: rbancroft (rumble@moz-4E8E0D7F.cg.shawcable.net)
[08:21:15] <acrichto> $$$$PYTHONPATH:$$
[08:21:21] <acrichto> I wrote that :(
[08:21:32] <acrichto> unironically as well
[08:22:07] *** Quits: bct (bct@moz-D3BEA05.ed.shawcable.net) (Ping timeout)
[08:22:13] *** Quits: DAddYE (DAddYE@moz-98D3933F.hsd1.ca.comcast.net) (Client exited)
[08:22:42] *** Joins: mib_xyjzys (Mibbit@moz-31DAE88F.resnet.usf.edu)
[08:22:43] *** Joins: DAddYE (DAddYE@moz-98D3933F.hsd1.ca.comcast.net)
[08:22:44] <dbaupp> acrichto: makefiles?
[08:22:51] <acrichto> yeah
[08:23:37] *** Quits: rbancroft (rumble@moz-4E8E0D7F.cg.shawcable.net) (Ping timeout)
[08:23:51] *** Quits: mib_xyjzys (Mibbit@moz-31DAE88F.resnet.usf.edu) (Quit: http://www.mibbit.com ajax IRC Client)
[08:24:23] *** Quits: DAddYE (DAddYE@moz-98D3933F.hsd1.ca.comcast.net) (Ping timeout)
[08:24:35] *** Quits: ivan (ivan@moz-531C3EC9.members.linode.com) (Ping timeout)
[08:24:41] *** Joins: bct (bct@moz-D3BEA05.ed.shawcable.net)
[08:25:39] *** Quits: achin (achin@moz-193F7FAD.ri.ri.cox.net) (Ping timeout)
[08:25:51] *** Joins: CarpNet (ac@moz-FD24B77.sohonet.co.uk)
[08:27:21] *** Quits: bct (bct@moz-D3BEA05.ed.shawcable.net) (Ping timeout)
[08:30:11] *** Joins: ivan (ivan@moz-531C3EC9.members.linode.com)
[08:39:23] <kaeso> acrichto: thanks for pulling in gyp as a submodule
[08:40:03] *** Quits: alex_abreu (alex@moz-7421D6C9.mc.videotron.ca) (Ping timeout)
[08:40:50] *** Joins: achin (achin@moz-193F7FAD.ri.ri.cox.net)
[08:42:47] *** Joins: alex-abreu (alex@moz-7421D6C9.mc.videotron.ca)
[08:44:24] <acrichto> kaeso: np, was certainly a good idea
[08:45:04] <kaeso> acrichto: have you checked if everything is fine in a `make dist`?
[08:45:12] <acrichto> kaeso: oh good idea
[08:45:43] <kaeso> acrichto: I think submodules get bundled automatically, but didn't check the rules
[08:45:44] <acrichto> lol make dist doesn't work on osx
[08:45:54] <acrichto> kaeso: nah looks like I need to specify it
[08:46:12] <acrichto> just updated with it
[08:47:19] *** Quits: jclements (jclements@moz-9C0ABCFC.wireless.calpoly.edu) (Ping timeout)
[08:47:35] *** Joins: ChrisMorgan (chris@moz-6AC741CA.static.tpgi.com.au)
[08:49:12] *** Quits: csherratt (Mibbit@moz-CAF331EA.cable.teksavvy.com) (Quit: http://www.mibbit.com ajax IRC Client)
[08:52:20] <acrichto> this next snapshot is going to be really painful
[08:54:25] <ChrisMorgan> dbaupp: are you done with https://github.com/chris-morgan/rust-http/pull/7?
[08:56:39] *** Quits: telotortium (rmi1@moz-90BFA359.dhcp.mdsn.wi.charter.com) (Ping timeout)
[08:57:54] *** Joins: telotortium (rmi1@moz-90BFA359.dhcp.mdsn.wi.charter.com)
[08:59:35] <dbaupp> ChrisMorgan: yup
[09:03:24] <acrichto> sfackler: if you update to the current master and still get unresolved symbol errors, let me know
[09:03:48] <acrichto> sfackler: I think that #[address_insignificant] can cause serious problems, but I'm not 100% sure
[09:07:19] *** Quits: nkoep (nik@moz-A196DCE9.pool.mediaways.net) (Ping timeout)
[09:08:39] *** Quits: tgummerer (tgummerer@51D3B54.FEF996EA.EA6FEF3D.IP) (Ping timeout)
[09:08:54] *** Joins: davbo (dave@moz-3FFA637C.oucs.ox.ac.uk)
[09:10:48] *** Joins: ghrust (ghrust@DE823A67.6A2AE50.F3114085.IP)
[09:10:48] <ghrust> 01[13rust01] 15bors merged 06auto into 06master: 02http://git.io/ZSXxUQ
[09:10:48] *** Parts: ghrust (ghrust@DE823A67.6A2AE50.F3114085.IP) ()
[09:12:20] *** Joins: donri (dag@moz-9BB61102.tbcn.telia.com)
[09:15:48] *** Joins: ghrust (ghrust@C8693FCB.6A2AE50.F3114085.IP)
[09:15:48] <ghrust> 01[13rust01] 15bors pushed 0 new commits to 06auto: 02http://git.io/H6UZ6g
[09:15:48] *** Parts: ghrust (ghrust@C8693FCB.6A2AE50.F3114085.IP) ()
[09:15:49] *** Joins: ghrust (ghrust@2EE61FCC.6A2AE50.F3114085.IP)
[09:15:50] <ghrust> 01[13rust01] 15bors pushed 2 new commits to 06auto: 02http://git.io/UVNaYA
[09:15:50] <ghrust> 13rust/06auto 14da042ce 15Chris Morgan: Implement Stream automatically for Reader + Writer...
[09:15:50] <ghrust> 13rust/06auto 1413611d0 15bors: auto merge of #8984 : chris-morgan/rust/auto-stream-impl, r=huonw...
[09:15:50] *** Parts: ghrust (ghrust@2EE61FCC.6A2AE50.F3114085.IP) ()
[09:21:53] *** Joins: nkoep (nik@moz-8233EDE9.vpn.rwth-aachen.de)
[09:23:07] *** Joins: DAddYE (DAddYE@moz-98D3933F.hsd1.ca.comcast.net)
[09:26:28] *** Joins: pnkfelix (pnkfelix@87C1F78E.1DE10CA8.D8E68FF6.IP)
[09:27:18] *** Quits: DAddYE (DAddYE@moz-98D3933F.hsd1.ca.comcast.net) (Ping timeout)
[09:28:05] *** Joins: sankha93 (Instantbir@7061CD01.D6BD0D91.22D41759.IP)
[09:31:47] *** jorendorff_away is now known as jorendorff
[09:34:36] *** Quits: Uther (Instantbir@moz-1B244B05.hfc.dyn.abo.bbox.fr) (Ping timeout)
[09:39:12] *** Joins: miloshadzic (miloshadzi@F8195CC5.425C93D4.449B8A48.IP)
[09:40:03] *** Quits: clonejo (clonejo@moz-CC9FD036.de) (Ping timeout)
[09:49:49] *** Joins: clonejo (clonejo@moz-CC9FD036.de)
[09:56:11] *** Joins: q66 (q66@6EE9DE40.46454B5D.33AABD5F.IP)
[09:58:42] *** Joins: z0w0 (zack@moz-74A8B350.lnse4.cha.bigpond.net.au)
[10:00:51] *** Joins: ghrust (ghrust@9C8B94D4.6A2AE50.F3114085.IP)
[10:00:51] <ghrust> 01[13rust01] 15bors 04force-pushed 06auto from 1413611d0 to 14422dcbd: 02http://git.io/N3iJvQ
[10:00:51] *** Parts: ghrust (ghrust@9C8B94D4.6A2AE50.F3114085.IP) ()
[10:00:52] *** Joins: ghrust (ghrust@1E8607E8.6A2AE50.F3114085.IP)
[10:00:52] <ghrust> 01[13rust01] 15bors pushed 2 new commits to 06auto: 02http://git.io/1_Xknw
[10:00:52] <ghrust> 13rust/06auto 14fcc7aff 15Daniel Micay: str: rm `map_chars`, replaced by iterators...
[10:00:52] <ghrust> 13rust/06auto 146f176a1 15bors: auto merge of #8990 : thestinger/rust/str, r=alexcrichton...
[10:00:52] *** Parts: ghrust (ghrust@1E8607E8.6A2AE50.F3114085.IP) ()
[10:06:20] <ChrisMorgan> dbaupp: OK, I'll check it out some time soon (probably not tonight, quite busy)
[10:10:15] *** Quits: sigma (sigma@51C589B3.EF2694B5.DFAC6AA7.IP) (Ping timeout)
[10:13:18] *** Joins: bytewise (bytewise@moz-4A801D04.unitymediagroup.de)
[10:14:37] <dbaupp> ChrisMorgan: doesn't matter, it's unlikely to go stale any time soon
[10:14:52] *** Quits: z0w0 (zack@moz-74A8B350.lnse4.cha.bigpond.net.au) (Quit: z0w0)
[10:14:57] <ChrisMorgan> Indeed. And I won't be doing any work on rust-http myself before dealing with it.
[10:22:03] *** Quits: StarLight (StarLight@moz-69132723.pppoe.avangarddsl.ru) (Ping timeout)
[10:23:51] *** Joins: tgummerer (tgummerer@51D3B54.FEF996EA.EA6FEF3D.IP)
[10:26:29] *** Joins: StarLight (StarLight@moz-BF70B61.pppoe.avangarddsl.ru)
[10:26:30] *** Joins: DAddYE (DAddYE@moz-98D3933F.hsd1.ca.comcast.net)
[10:30:40] *** Quits: DAddYE (DAddYE@moz-98D3933F.hsd1.ca.comcast.net) (Ping timeout)
[10:32:04] *** Joins: jensnockert (jensnocker@moz-8BE55278.customer.t3.se)
[10:42:20] *** Joins: sigma (sigma@51C589B3.EF2694B5.DFAC6AA7.IP)
[10:45:42] *** Joins: dave1629 (dave@moz-17578A1A.hsd1.va.comcast.net)
[10:45:44] *** Joins: miza (miza@moz-BE2AF601.ws.skroutz.gr)
[10:47:09] *** Parts: miza (miza@moz-BE2AF601.ws.skroutz.gr) (PONG :concrete.mozilla.org)
[10:47:30] *** Quits: lenstr (lenstr@AF8EB999.6049B16A.85938D85.IP) (Client exited)
[11:01:35] *** Parts: dualhbridge (dad@moz-9FEE6D3B.maine.res.rr.com) ()
[11:01:41] <pnkfelix> acrichto: ping
[11:05:47] *** Joins: ghrust (ghrust@79968228.6A2AE50.F3114085.IP)
[11:05:47] <ghrust> 01[13rust01] 15bors merged 06auto into 06master: 02http://git.io/1_Xknw
[11:05:47] *** Parts: ghrust (ghrust@79968228.6A2AE50.F3114085.IP) ()
[11:05:50] *** Quits: nrc (nrc@7BE24E90.A5032A01.3CFC199D.IP) (Ping timeout)
[11:10:47] *** Joins: ghrust (ghrust@1E8607E8.6A2AE50.F3114085.IP)
[11:10:47] <ghrust> 01[13rust01] 15bors pushed 0 new commits to 06auto: 02http://git.io/-b7NaQ
[11:10:47] *** Parts: ghrust (ghrust@1E8607E8.6A2AE50.F3114085.IP) ()
[11:10:49] *** Joins: ghrust (ghrust@F6EE6DE3.6A2AE50.F3114085.IP)
[11:10:49] <ghrust> 01[13rust01] 15bors pushed 2 new commits to 06auto: 02http://git.io/EAnEzQ
[11:10:49] <ghrust> 13rust/06auto 14da042ce 15Chris Morgan: Implement Stream automatically for Reader + Writer...
[11:10:49] <ghrust> 13rust/06auto 14301ccee 15bors: auto merge of #8984 : chris-morgan/rust/auto-stream-impl, r=huonw...
[11:10:50] *** Parts: ghrust (ghrust@F6EE6DE3.6A2AE50.F3114085.IP) ()
[11:11:07] *** Joins: a_m0d|home (a_m0d@moz-D474F978.acanac.net)
[11:26:07] *** Joins: lenstr (lenstr@AF8EB999.6049B16A.85938D85.IP)
[11:29:24] *** Joins: DAddYE (DAddYE@moz-98D3933F.hsd1.ca.comcast.net)
[11:29:33] *** Quits: jensnockert (jensnocker@moz-8BE55278.customer.t3.se) (Input/output error)
[11:31:04] *** Quits: DAddYE (DAddYE@moz-98D3933F.hsd1.ca.comcast.net) (Ping timeout)
[11:32:45] *** Joins: Earnestly (earnest@moz-F387F877.dyn.plus.net)
[11:39:08] *** Joins: bjz (brendanzab@B398BE78.F804C29E.D35A31DF.IP)
[11:43:11] *** jorendorff is now known as jorendorff_away
[11:45:17] *** Joins: matt444 (matthew@moz-CFC97445.wi.res.rr.com)
[11:45:38] <matt444> Is it not possible to alias functions in Rust?
[11:45:57] <matt444> let fs = FromStr::from_str;
[11:46:30] <dbaupp> not functions from a trait
[11:46:48] *** Quits: a_m0d|home (a_m0d@moz-D474F978.acanac.net) (Quit: Leaving.)
[11:47:03] <dbaupp> rusti: use other_println = std::io::println; other_println("hi");
[11:47:04] -rusti- hi
[11:47:04] -rusti- ()
[11:48:07] <matt444> These from_str examples are out of date, none work: http://static.rust-lang.org/doc/0.7/std/bool.html
[11:48:15] <matt444> What is the proper way to use it?
[11:48:15] *** Joins: jensnockert (jensnocker@moz-8BE55278.customer.t3.se)
[11:48:37] <klutzy> on 0.7 or on master?
[11:48:58] <matt444> msater
[11:49:15] <dbaupp> matt444: `let foo: bool = FromStr::from_str(string);` /* use foo */`
[11:49:50] <dbaupp> the syntax is going to become somthing like `bool::from_str` or (more likely) `FromStr::<for bool>::from_str(string)`
[11:50:05] <matt444> error: cannot determine a type for this bounded type parameter: unconstrained type
[11:50:06] <dbaupp> (err, wait, that should be `let foo: Option<bool> = ...`
[11:50:08] <dbaupp> )
[11:50:20] *** Joins: msingle (Thunderbir@moz-930E5D97.hr.hr.cox.net)
[11:50:33] <matt444> :)
[11:50:37] <dbaupp> rusti: let foo: Option<bool> = FromStr::from_str("true"); foo
[11:50:37] -rusti- Some(true)
[11:51:18] <matt444> And if str is not a bool then it is None, right?
[11:52:58] <dbaupp> rusti: let foo: Option<bool> = FromStr::from_str("not a bool"); foo
[11:52:59] -rusti- None
[11:53:13] <dbaupp> (yes)
[11:54:24] <matt444> So you can test Some(true) and Some(false)
[11:54:44] <matt444> but how can you test Some(any bool)?
[11:54:59] <dbaupp> .is_some()
[11:55:25] <matt444> so you can't use pattern matching that way
[11:55:30] <dbaupp> but you normally want to `match` or use one of the higher order methods (e.g. .map, .map_move, .chain)
[11:55:46] *** Joins: ghrust (ghrust@24260B07.6A2AE50.F3114085.IP)
[11:55:46] <ghrust> 01[13rust01] 15bors 04force-pushed 06auto from 14301ccee to 146f176a1: 02http://git.io/N3iJvQ
[11:55:46] *** Parts: ghrust (ghrust@24260B07.6A2AE50.F3114085.IP) ()
[11:55:47] *** Joins: ghrust (ghrust@79968228.6A2AE50.F3114085.IP)
[11:55:48] <ghrust> 01[13rust01] 15bors pushed 3 new commits to 06auto: 02http://git.io/O644bw
[11:55:48] <ghrust> 13rust/06auto 1441e7924 15Felix S. Klock II: Fix #7740: gather_loans should not recur into the items of the block....
[11:55:48] <ghrust> 13rust/06auto 14c7352e6 15Felix S. Klock II: regression test for #7740.
[11:55:48] <ghrust> 13rust/06auto 14510c4d8 15bors: auto merge of #8993 : pnkfelix/rust/fsk-fix-7740-dont-recur-on-items-during-gather-loans-of-block, r=nikomatsakis...
[11:55:50] *** Parts: ghrust (ghrust@79968228.6A2AE50.F3114085.IP) ()
[11:56:02] <dbaupp> yeah, you can, `Some(a) => { .. /* a is either true or false */ .. } `
[11:57:40] <matt444> great, got it
[11:59:15] *** Parts: pnkfelix (pnkfelix@87C1F78E.1DE10CA8.D8E68FF6.IP) ()
[11:59:20] *** Joins: pnkfelix (pnkfelix@87C1F78E.1DE10CA8.D8E68FF6.IP)
[12:00:02] *** Joins: bjz_ (brendanzab@B398BE78.F804C29E.D35A31DF.IP)
[12:00:02] *** Quits: bjz (brendanzab@B398BE78.F804C29E.D35A31DF.IP) (Connection reset by peer)
[12:05:54] <matt444> how can I iterate over ~[~str] ?
[12:06:07] <matt444> args.iter().map( | &s | 0.0)
[12:06:16] <matt444> args.iter().map( | ~s | 0.0)
[12:06:23] <matt444> I tried every combo :)
[12:07:12] <bjz_> rusti: for s in [~"hi", ~"ho"].iter() { println(*s) }
[12:07:15] -rusti- pastebinned 11 lines of output: http://ix.io/7RD
[12:07:24] *** Quits: robn (robn@moz-76B0302C.static.internode.on.net) (Quit: Coyote finally caught me)
[12:07:28] *** Joins: robn (robn@moz-76B0302C.static.internode.on.net)
[12:07:41] <bjz_> rusti: let ss = ~[~"hi", ~"ho"]; for s in ss.iter() { println(*s) }
[12:07:42] -rusti- hi
[12:07:43] -rusti- ho
[12:07:43] -rusti- ()
[12:07:46] <dbaupp> [T].iter() gives a &T (so &~str in this instance), so &s is almost correct, except it attempts to transfer ownershipt of the ~str (which is illegal behind a borrowed pointer)
[12:08:30] <dbaupp> just |s| and then *s (which will coerce to &str without moving) were appropriate; or saving it into a local as a slice, with s.as_slice()
[12:08:31] <bjz_> rusti: let ss = ~[~"hi", ~"ho"]; ss.iter().map(|s| s[0]).collect()
[12:08:31] -rusti- <anon>:5:35: 6:5 error: cannot determine a type for this bounded type parameter: unconstrained type
[12:08:32] -rusti- <anon>:5          let ss = ~[~"hi", ~"ho"]; ss.iter().map(|s| s[0]).collect()
[12:08:32] -rusti- <anon>:6     };
[12:08:32] -rusti- application terminated with error code 101
[12:08:57] <dbaupp> rusti: let ss = ~[~"hi", ~"ho"]; ss.iter().map(|s| s.char_at(0)).to_owned_vec()
[12:08:58] <bjz_> dbaupp: ?
[12:08:58] -rusti- ~['h', 'h']
[12:09:17] <bjz_> rusti: let ss = ~[~"hi", ~"ho"]; ss.iter().map(|s| s[0]).to_owned_vec()
[12:09:18] -rusti- ~[104u8, 104u8]
[12:09:22] <bjz_> heh
[12:09:32] <matt444> so what if I want to pass in a named function? what does it's signature need to be?
[12:09:57] <matt444> if s is *s
[12:09:57] <pnkfelix> rusti: let s = ~[~"hi", ~"ho"]; let v : ~[f64] = s.iter().map(|_s| 0.0).collect(); v
[12:09:58] -rusti- ~[0f64, 0f64]
[12:10:36] <matt444> I can't get a function to compile with a string argument unless it is &s
[12:10:56] <bjz_> matt444: function composition is annoying
[12:10:59] <dbaupp> matt444: you want fn foo(s: &str) almost always
[12:11:21] *** Quits: lkuper_ (lkuper@moz-C0CD33ED.hsd1.in.comcast.net) (Ping timeout)
[12:11:23] *** Quits: etw (john@moz-D871A25B.nyc.res.rr.com) (Ping timeout)
[12:11:24] <pnkfelix> rusti: use std::hashmap::HashSet; let s = ~[~"hi", ~"ho"]; let v : HashSet<f64> = s.iter().map(|_s| 0.0).collect(); v.to_str()
[12:11:25] *** Joins: engla (engla@moz-DBD1D96E.cust.bredbandsbolaget.se)
[12:11:25] -rusti- ~"{0}"
[12:11:33] <bjz_> dbaupp: wouldn't it be fn(&~str) ?
[12:11:34] <matt444> ah, it does work :)
[12:11:38] <matt444> yeah! :)
[12:11:58] <dbaupp> bjz_: that's pretty strange; it is annoying to use that function with anything other than the iterators
[12:12:24] <dbaupp> .map(|s| foo(*s)) isn't so bad (imo, at least)
[12:13:14] <bjz_> dbaupp: that's what I mean by composability: .map(foo)
[12:13:17] *** Quits: jensnockert (jensnocker@moz-8BE55278.customer.t3.se) (Input/output error)
[12:13:48] <matt444> I was able to do it
[12:13:49] <bjz_> dbaupp: not sure if that was what matt444 was talking about
[12:13:52] <matt444> with &str
[12:14:18] *** Joins: etw (john@moz-D871A25B.nyc.res.rr.com)
[12:14:26] <bjz_> matt444: ahh yeah, most fns can just use &str as an arg
[12:15:14] <matt444> my hello world for learning a language is to write a program that adds up the arguments
[12:15:38] <bjz_> rusti: fn printer(s: &str) { print(s) } printer("hi"); printer(~"hi"); printer(@"hi");
[12:15:43] -rusti- pastebinned 7 lines of output: http://ix.io/7RF
[12:16:08] <bjz_> matt444: and you see the warning :P
[12:16:10] <matt444> here's where i'm at so far: http://pastebin.com/ZQZ3H0hV
[12:16:28] <bjz_> matt444: if you take a &str you don't need to allocate
[12:17:21] <bjz_> matt444: you could do that nicer monadically
[12:17:38] *** Quits: etw (john@moz-D871A25B.nyc.res.rr.com) (Ping timeout)
[12:17:57] <matt444> it doesn't compile anyways :)
[12:18:11] <dbaupp> rusti: let args = ~["bin-name", "1", "2", "3"]; args.iter().flat_map(|s| FromStr::from_str(*s)).fold(0, |acc, new| acc + new)
[12:18:11] -rusti- <anon>:5:50: 6:5 error: cannot determine a type for this bounded type parameter: unconstrained type
[12:18:11] -rusti- <anon>:5          let args = ~["bin-name", "1", "2", "3"]; args.iter().flat_map(|s| FromStr::from_str(*s)).fold(0, |acc, new| acc + new)
[12:18:12] -rusti- <anon>:6     };
[12:18:12] -rusti- application terminated with error code 101
[12:18:19] <bjz_> matt444: Option has .get_or_default
[12:18:29] <dbaupp> rusti: let args = ~["bin-name", "1", "2", "3"]; args.iter().flat_map(|s| FromStr::from_str(*s)).fold(0.0f, |acc, new| acc + new)
[12:18:30] -rusti- <anon>:5:50: 6:5 error: cannot determine a type for this bounded type parameter: unconstrained type
[12:18:30] -rusti- <anon>:5          let args = ~["bin-name", "1", "2", "3"]; args.iter().flat_map(|s| FromStr::from_str(*s)).fold(0.0f, |acc, new| acc + new)
[12:18:30] -rusti- <anon>:6     };
[12:18:30] -rusti- application terminated with error code 101
[12:18:36] <matt444> bjz_ oh, nice
[12:18:58] <bjz_> dbaupp: that is nice, if it worked :P
[12:18:59] <dbaupp> rusti: let args = ~["bin-name", "1", "2", "3"]; args.iter().flat_map(|s| FromStr::from_str(*s)).fold(0.0f, |acc, new: float| acc + new)
[12:18:59] -rusti- <anon>:5:50: 6:5 error: cannot determine a type for this bounded type parameter: unconstrained type
[12:18:59] -rusti- <anon>:5          let args = ~["bin-name", "1", "2", "3"]; args.iter().flat_map(|s| FromStr::from_str(*s)).fold(0.0f, |acc, new: float| acc + new)
[12:18:59] -rusti- <anon>:6     };
[12:18:59] -rusti- application terminated with error code 101
[12:19:14] * dbaupp scolds rusti for infering so poorly
[12:19:36] <matt444> I want to use a named function though
[12:19:40] <dbaupp> rusti: let args = ~["bin-name", "1", "2", "3"]; args.iter().flat_map(|s| { let gaaah: Option<float> = FromStr::from_str(*s); gaaah }).fold(0.0, |acc, new| acc + new)
[12:19:40] <bjz_> dbaupp: we need float::from_str :(
[12:19:42] -rusti- pastebinned 4 lines of output: http://ix.io/7RH
[12:19:44] <matt444> pretty important to me that a language can do that
[12:19:47] *** Joins: etw (john@moz-D871A25B.nyc.res.rr.com)
[12:20:04] <bjz_> matt444: what do you mean 'named function'?
[12:20:07] <dbaupp> bjz_: err, no; we need traits to work better
[12:20:21] <matt444> bjz_ pass a function as an argument, not an anonymous function
[12:20:25] <dbaupp> rusti: let args = ~["bin-name", "1", "2", "3"]; args.iter().filter_map(|s| { let gaaah: Option<float> = FromStr::from_str(*s); gaaah }).fold(0.0, |acc, new| acc + new)
[12:20:26] -rusti- 6
[12:20:33] <bjz_> matt444: that's what I was saying before
[12:20:36] *** Quits: sankha93 (Instantbir@7061CD01.D6BD0D91.22D41759.IP) (Quit: Gone to save the world!)
[12:20:52] *** Joins: z0w0 (zack@moz-74A8B350.lnse4.cha.bigpond.net.au)
[12:20:58] <bjz_> matt444: composability is hard because the pointer types need to match
[12:21:08] <dbaupp> rusti: let args = ~["bin-name", "1", "2", "3"]; args.iter().filter_map(|s| FromStr::from_str(*s)).fold(0.0, |acc, new: float| acc + new)
[12:21:09] -rusti- 6
[12:21:15] <matt444> bjz_: why can't they match?
[12:21:22] <dbaupp> there we go
[12:21:23] <bjz_> matt444: especially with iterators, since you get doubled up &&
[12:21:44] <bjz_> matt444: well, the way iterators work, they don't match with most functions
[12:22:02] <bjz_> matt444: you need to deref
[12:22:50] <bjz_> dbaupp: I mean: float::from_str <- from_str is an associated function from a trait
[12:23:06] <dbaupp> rusti: fn iter_from_str(s: &~str) -> Option<float> { FromStr::from_str(*s) } fn add<T: Add>(x: T, y: T) -> T { x + y } let args = ~["bin-name", "1", "2", "3.5", "-100"]; args.iter().skip(1).filter_map(iter_from_str).fold(0.0, add)
[12:23:10] -rusti- pastebinned 4 lines of output: http://ix.io/7RI
[12:23:38] <dbaupp> rusti: fn iter_from_str(s: & &str) -> Option<float> { FromStr::from_str(*s) } fn add<T: Add<T, T>>(x: T, y: T) -> T { x + y } let args = ~["bin-name", "1", "2", "3.5", "-100"]; args.iter().skip(1).filter_map(iter_from_str).fold(0.0, add)
[12:23:39] -rusti- -93.5
[12:24:47] <dbaupp> bjz_: right; in that case I kind-of agree (although I don't actually dislike FromStr::from_str that much if we can specify the self type without a temporary)
[12:25:12] <bjz_> dbaupp: what do you mean?
[12:25:23] *** Quits: matt444 (matthew@moz-CFC97445.wi.res.rr.com) (Quit: Lost terminal)
[12:25:29] <bjz_> "if we can specify the self type without a temporary"
[12:25:50] *** Quits: etw (john@moz-D871A25B.nyc.res.rr.com) (Ping timeout)
[12:26:10] *** Joins: jensnockert (jensnocker@moz-8BE55278.customer.t3.se)
[12:26:58] <dbaupp> with the most recent changes the only way to force Self to be a certain type is with the stupid `let tmp: Option<Self> = FromStr::from_str(..)` dance. it'd be nicer to be able to say `FromStr::from_str::<Self>` still (but that sucks for other reasons, that you know), or prefereably somethign like `FromStr::<for Self>::from_str`
[12:27:13] *** Joins: spider-mario (spidermari@moz-2F72F6FF.dsl.quantic-telecom.net)
[12:27:48] <bjz_> dbaupp: why do you prefer <for Self>
[12:28:28] <dbaupp> I prefer it to mixing self with all the other params
[12:29:16] <bjz_> no, not that
[12:29:31] <dbaupp> I don't necessarily think it's the optimal solution; but there's so many different choices here, all with [dis]advantages big and small
[12:29:32] <bjz_> mixing it with the other params is bad
[12:29:39] *** Joins: jfbk (jfbk@moz-EEA9CFB3.nyc.res.rr.com)
[12:29:49] <pnkfelix> dbaupp: would you be happy with use impl FloatFromStr = FromStr for ~Option<float>;  â€¦  ;  FloatFromStr::size_of()
[12:29:57] <pnkfelix> dbaupp: a la https://github.com/mozilla/rust/issues/6894
[12:30:03] *** Joins: DAddYE (DAddYE@moz-98D3933F.hsd1.ca.comcast.net)
[12:31:36] <pnkfelix> dbaupp: Or  do you regard that as too onerous, if the `let tmp: Option<float> = â€¦ ` dance is also too onerous?
[12:32:29] * pnkfelix agrees with bjz_ that mixing with the Self with the other params is bad.
[12:32:56] * dbaupp also agrees with separating Self + trait params from individual method params
[12:32:57] <bjz_> pnkfelix: this is what I'm doing atm: https://github.com/bjz/cgmath-rs/blob/master/src/cgmath/vector.rs#L42
[12:33:10] <LRN> how do i allocate a vector of values of type X and length N, and initialize each element with a particular X value == Y?
[12:33:35] * pnkfelix thought/thinks that even `FromStr::<for Self>` looked too much like mixing Self with the other params, which is why he pushed his view in 6894.  But its not clear if pnkfelix will win this debate.
[12:33:36] <LRN> In Python i can: vec = [Y] * N
[12:34:13] *** Quits: DAddYE (DAddYE@moz-98D3933F.hsd1.ca.comcast.net) (Ping timeout)
[12:34:18] <dbaupp> pnkfelix: I think Trait::<for Self, TraitParam>::method::<MethodParam> isn't too bad, since Self is clearly identified
[12:34:37] <bjz_> pnkfelix: I don't think it's clear either. :( but I know I have a user who hates Mat2::<f32>::ident() already
[12:34:47] <benh> I think use impl blah = FromStr for ~Option<float> is pretty gross :(
[12:34:54] <dbaupp> pnkfelix: I do think that having to explicitly use impls is heavyweight
[12:35:05] <dbaupp> bjz_: is it you?
[12:35:08] <benh> Having to introduce a new name that's almost required to be something useless for a oneshot function call is bad :(
[12:35:18] <bjz_> dbaupp: zeuxcg
[12:35:24] *** Parts: z0w0 (zack@moz-74A8B350.lnse4.cha.bigpond.net.au) ()
[12:35:55] <bjz_> dbaupp: he actually decided to use his own non-generic lib
[12:36:00] <pnkfelix> benh: The original proposal from http://blog.pnkfx.org/blog/2013/04/22/designing-syntax-for-associated-items-in-rust/  tried to make the common case more succinct
[12:36:08] *** Joins: rbancroft (rumble@99CB1D09.5825E03B.F97ED6F2.IP)
[12:36:28] <pnkfelix> benh: Where "common case" means "Type Parameters with Trait Bounds"
[12:36:30] <dbaupp> bjz_: I'm kinda not very sympathetic to that argument... whatever is chosen will have some horrible corners,  and it'll just be something that rust users have to get used to
[12:36:54] <dbaupp> (the argument that some syntax makes a certain use case looks bad)
[12:37:05] <bjz_> dbaupp: it would be nicer when we have type aliases being able to access funs impled directly on Self
[12:37:26] <pnkfelix> benh: i.e. fn foo<F:I=FromStr> { let F = I::from_str("â€¦inputâ€¦"); â€¦ }
[12:37:29] <bjz_> pnkfelix: I would be ok with that you'd have to use type aliases
[12:37:29] <pnkfelix> benh: and then
[12:37:39] <pnkfelix> benh: fn foo<F:FromStr> { let F = F::from_str("â€¦inputâ€¦"); â€¦ }
[12:38:11] <dbaupp> bjz_: And I don't think `Mat2::<f64>::ident()` is that bad (except for all the ::'s); it's clear what it means
[12:38:15] <pnkfelix> benh: (sorry, those should have been `let f = â€¦`, not `let F = â€¦`; the fact the let-bound `F` was in uppercase was a mistake...)
[12:38:32] <bjz_> pnkfelix: so type Vec3f = Vec3<f32>; Vec3f::ident()
[12:39:08] <dbaupp> pnkfelix: how does that syntax work with nongeneric uses of FromStr?
[12:39:36] <pnkfelix> dbaupp: it doesn't.  That's why you still need to put in `use impl foo = Trait for Type` support.
[12:40:19] <dbaupp> pnkfelix: ah. :(
[12:40:24] <pnkfelix> dbaupp: but my thinking had been that you wouldn't need to use it all the time.
[12:40:35] <pnkfelix> dbaupp: but perhaps that's because I tend to write type-parameter heavy code
[12:40:48] <dbaupp> (I do too)
[12:40:54] <bjz_> pnkfelix: yeah, maybe we're weird :(
[12:41:04] *** Joins: bct (bct@moz-D3BEA05.ed.shawcable.net)
[12:41:18] <dbaupp> but the common case of "I want an int from this string" gets very ugly. :(
[12:42:01] <dbaupp> or in bjz's case, I want the 3x3 identity matrix on floats
[12:42:01] <benh> I'm still somewhat partial towards just stuffing all the associated functions into the type :(
[12:42:06] <bjz_> dbaupp: that's why I liked int::from_str
[12:42:14] *** Quits: dave1629 (dave@moz-17578A1A.hsd1.va.comcast.net) (Quit: dave1629)
[12:42:17] <pnkfelix> well, maybe I'll just have to give in and accept FromStr::<for int>::from_str()
[12:42:44] <bjz_> dbaupp: but then you get the issue of how do you do things like ~[int]
[12:43:26] <pnkfelix> but I don't think it scales well, i.e. Trait::<for T>::foo()  gets to look pretty nasty as T gets to be a larger and larger type expression (as I expect will happen, especialy with associated items)
[12:44:08] <bjz_> pnkfelix: my fear is if using associated items is ugly, people won't use them
[12:44:23] <bjz_> pnkfelix: then we will have lost the utility of traits
[12:44:27] <dbaupp> pnkfelix: there's thoughts for `typeof(some expression)` being valid in types, which would make it nicer, if there's some local with the relevant type.
[12:44:29] <pnkfelix> Maybe the right compromise is to put in Trait::<for T>::foo() support alongside my proposed fn bar<T:I=Trait> { â€¦ I::foo() â€¦ } syntax
[12:44:46] <bjz_> pnkfelix: folks will just impl directly on types
[12:45:40] <bjz_> pnkfelix: I might be making a mountain out of a molehill though
[12:45:58] * bjz_ doesn't know anymore ("ugh, bikesheds")
[12:46:19] <dbaupp> pnkfelix: that'd be neat; get the best of both worlds
[12:47:06] <benh> <Ty: I1=Tr1+I2=Tr2> parses kinda weird, is that how it would go?
[12:47:10] <pnkfelix> This may be a bikeshed discussion, but I think this bikeshed is going to be put in a very prominent positiion on the front lawn.
[12:47:47] <bjz_> pnkfelix: does my argumant make any sense?
[12:48:07] <pnkfelix> benh: that's right.
[12:48:14] *** Quits: jfbk (jfbk@moz-EEA9CFB3.nyc.res.rr.com) (Quit: )
[12:48:57] <pnkfelix> benh: (With the ability to leave out the `I=` in the case where there's only one trait bound.  Or something along those lines; we might also allow multiple trait bounds as long as their associated items do not overlap.)
[12:49:30] <pnkfelix> bjz_: Yes I believe I understand your argument, that's why I was saying the color paint for this bikeshed may actually matter.
[12:49:34] <benh> If the latter also works in the general, not-generic case, that'd allow int::from_str(...) again?
[12:50:03] *** Quits: tgummerer (tgummerer@51D3B54.FEF996EA.EA6FEF3D.IP) (Ping timeout)
[12:50:13] <pnkfelix> benh: It doesn't work in the general non-generic case because we don't want to scan all the traits that have been imported into the scope.
[12:50:30] <benh> ah, ok
[12:50:31] <pnkfelix> benh: I think pcwalton has rightly called that "too magical"
[12:50:34] *** Quits: tav (tav@moz-C302A43C.range86-149.btcentralplus.com) (Quit: tav)
[12:50:40] <bytewise> LRN: you can use `let vec = ~[Y, ..N];`
[12:50:48] <benh> double standard! it's okay for methods but not for associated methods!
[12:50:57] <benh> no wonder everybody prefers methods :D
[12:51:10] <benh> ss/methods!/functions!/
[12:51:19] <benh> (s/ss/s/)
[12:51:21] <bjz_> benh: that's where I'm coming from
[12:51:45] <bjz_> benh: the double standard is weird
[12:52:30] *** Quits: jensnockert (jensnocker@moz-8BE55278.customer.t3.se) (Input/output error)
[12:53:36] <bjz_> on a conceptual level, "foo".blah() is str.blah()
[12:55:21] *** Quits: nielsle (nielsle@moz-5CE8ECCD.boa.fiberby.dk) (Ping timeout)
[12:55:30] <bjz_> why do I have to be explicit about which trait it is coming from for associated functions, but not for methods
[12:55:37] <pnkfelix> I've heard this argument before, but I'm still not convinced by it.
[12:55:46] <bjz_> pnkfelix: why not?
[12:55:52] <dbaupp> bjz_: not necessarily; `some_type.some_trait_method()` is "run the some_trait_method behaviour from SomeTrait (oh, btw, the specific type is Type)"
[12:56:16] <dbaupp> (especially in generic code)
[12:56:57] <pnkfelix> I unfortunately have to leave.  If someone comes up with some insight that isn't already in the comments for Issue #6894, please leave a note there.  :)
[12:57:34] <pnkfelix> (sorry if it seems like I'm saying "I don't believe you.  Bye bye!"; I don't mean for it to appear that way.  :(  I just have to go.)
[12:57:38] <bjz_> np
[12:57:47] <benh> :)
[12:57:48] <bjz_> :)
[12:57:48] <benh> bye~
[12:57:52] <bjz_> o/
[12:58:38] <bjz_> dbaupp: could you try to explain that differenly, don't really understant
[12:58:44] *** Joins: nielsle (nielsle@moz-5CE8ECCD.boa.fiberby.dk)
[12:58:44] <bjz_> *understand
[12:59:32] *** Joins: MrFahrenheit (RageOfThou@3FEF494C.29C984D5.783DEDCA.IP)
[13:00:00] <bjz_> dbaupp: is that how the type checker does it?
[13:00:50] *** Joins: ghrust (ghrust@79968228.6A2AE50.F3114085.IP)
[13:00:50] <ghrust> 01[13rust01] 15bors merged 06auto into 06master: 02http://git.io/O644bw
[13:00:50] *** Parts: ghrust (ghrust@79968228.6A2AE50.F3114085.IP) ()
[13:01:09] * bjz_ is feeli
[13:01:15] <bjz_> woops
[13:01:19] <bjz_> :P
[13:01:26] <dbaupp> bjz_: as in, one interpretation of traits is collecting behaviours that are shared (for whatever value of behaviour, e.g. "has a Zero element", "can be added", "is a container that maps keys to values"), and calling methods/static methods is "executing" those behaviours
[13:02:05] <dbaupp> so the important piece of information is the trait & method, and the type is just a detail that controls exactly what flavour of behaviour happens
[13:02:15] <bjz_> mm
[13:02:57] * dbaupp wonders why bjz_ pings mm so much :P
[13:02:58] *** Quits: fabiand (fabiand@moz-A588C99B.adsl.alicedsl.de) (Quit: Verlassend)
[13:03:04] <engla> methods act on values, and you are explicit about which value you act on
[13:03:14] <LRN> Figured it out: let mut V: ~[int] = self::std::vec::build_sized (N, |push| {for i in range (0, N) {push (Y)}});
[13:03:33] *** Quits: hex (kvirc@D70E1914.6461B98.FFDF157.IP) (Connection reset by peer)
[13:03:44] <engla> LRN: that's more complicated than necessary
[13:03:48] * bjz_ forgot again -_- sorry mm
[13:03:51] <dbaupp> LRN: oh, there's probably a nicer way...
[13:03:58] <engla> rusti: range(0, 10).to_owned_vec()
[13:03:59] -rusti- ~[0, 1, 2, 3, 4, 5, 6, 7, 8, 9]
[13:04:13] <LRN> i need V to be initialized with -1s
[13:04:16] *** Joins: fabiand (fabiand@moz-A588C99B.adsl.alicedsl.de)
[13:04:24] <LRN> (well, Y, in general case, but in my case Y==-1)
[13:04:25] <engla> we can fix that
[13:04:32] <dbaupp> rusti: std::vec::from_elem(10, 'a')
[13:04:33] -rusti- ~['a', 'a', 'a', 'a', 'a', 'a', 'a', 'a', 'a', 'a']
[13:04:48] <engla> let mut V = ~[-1];  V.extend(&mut range(0, 10)); V
[13:04:52] <dbaupp> rusti: std::vec::from_elem(10, -1)
[13:04:53] -rusti- ~[-1, -1, -1, -1, -1, -1, -1, -1, -1, -1]
[13:05:02] <LRN> yeah, that one was probably what i was looking for, from_elem
[13:05:14] <engla> oh, I misunderstood completely
[13:05:42] <bjz_> engla: could you elaborate on what you said before?
[13:06:12] <benh> rusti: struct S; trait Tr1 { fn f(&self) {} } trait Tr2 { fn f(&self) {} } impl Tr1 for S {} impl Tr2 for S {} S.f()
[13:06:15] *** Quits: pnkfelix (pnkfelix@87C1F78E.1DE10CA8.D8E68FF6.IP) (Quit: Leaving.)
[13:06:23] -rusti- pastebinned 7 lines of output: http://ix.io/7RL
[13:06:29] <benh> boom :(
[13:07:21] <bjz_> dbaupp: so with a trait Zero, whe you impl you are saying "this type is a member of a set of things that are zeroable"
[13:07:50] <bjz_> dbaupp: or "that have a zero value"
[13:07:53] <engla> bjz_: don't know.  x.method() calls it on the value x explicitly and x has a type.  T::function() would be the corresponding syntax for types, if allowed
[13:08:12] <bjz_> engla: yeah
[13:08:52] *** Quits: fabiand (fabiand@moz-A588C99B.adsl.alicedsl.de) (Quit: Verlassend)
[13:08:52] <engla> so it's that trait function lookup is not implemented on types
[13:08:54] *** Joins: fabiand_ (fabiand@moz-A588C99B.adsl.alicedsl.de)
[13:09:16] <dbaupp> bjz_: basically, yes; looking at it in a more general way, rather than the details of "this type", look at the whole sets, with the specific type an "afterthough" (but not completely an afterthough, obviously)
[13:09:36] <bjz_> engla: but that breaks down in more complex cases, syntactiacally. would make the compiler more complex
[13:09:38] <engla> and why is it not implemented on Types? there seems to be some tradeoffs and I still don't understand
[13:10:05] <dbaupp> bjz_: but, I've got a mathematicians curse: generalise all the things. So I'm presumably unrepresentative of the general person.
[13:10:26] <bjz_> engla: you'd have to have something like (~[Option<int>])::size_of(), witch is tricky
[13:10:44] <benh> I'd like that :(
[13:11:05] <bstrie> dbaupp: no, I'd say that makes you quite comparable to the general person :)
[13:11:07] <dbaupp> benh: btw, https://github.com/mozilla/rust/issues/8808
[13:11:17] <bstrie> now to the specific person, that's a different story...
[13:11:23] <dbaupp> bstrie: :P
[13:11:23] <benh> dbaupp: ah, thanks
[13:11:27] <bjz_> benh: that's what I'm arguing for, but there are valid concerns. Like what dbaupp is raising
[13:12:15] <benh> I don't really follow
[13:12:33] <bjz_> dbaupp: but when I'm writing generic code, I'm working with Ts
[13:12:46] <bjz_> dbaupp: that are bound by constraints
[13:13:42] <bjz_> benh: what don't you follow
[13:13:58] <bjz_> dbaupp: btw, I like the direction you are describing it from
[13:14:03] *** jorendorff_away is now known as jorendorff
[13:14:22] <benh> I'm not sure why it ought to work differently for methods and associated functions
[13:15:21] <bjz_> benh: https://github.com/mozilla/rust/issues/6894
[13:16:52] <bjz_> dbaupp: so are you talking about some situation like: let nothing = _::zero();
[13:17:17] <bjz_> dbaupp: where you want Rust to infer the type?
[13:19:08] <dbaupp> bjz_: kinda, maybe? I'm kinda advocating for status-quo so `Zero::zero()` (inferred) or `Zero::<for T>::zero()` (explicit) would be fine by me
[13:19:22] <bjz_> mm
[13:19:43] <bjz_> do you not find you get lots of type blow-outs?
[13:19:50] * bjz_ does
[13:20:37] <benh> the latter isn't really the status quo, isn't it?
[13:20:53] <benh> is it*
[13:21:29] <bjz_> dbaupp: https://github.com/bjz/cgmath-rs/blob/master/src/cgmath/projection.rs#L156
[13:21:33] <dbaupp> not really; but it's the plan (aiui)
[13:22:07] <bjz_> aiui?
[13:22:18] <bjz_> oh
[13:22:22] <dbaupp> as i understand it
[13:22:36] <bjz_> benh: yes, that is the plan
[13:22:52] <benh> I won't complain too much then!
[13:22:53] <dbaupp> bjz_: I don't see any type blow-outs? (what do you mean by that?)
[13:24:15] <bjz_> dbaupp: note all the one::<S>()s
[13:24:25] *** Joins: sebcrozet (sebcrozet@moz-3CE49532.lrde.epita.fr)
[13:25:24] <bjz_> benh: the plan is for Zero::<for T>::zero()
[13:25:49] <benh> I thought the <for T> bit and especially type parameters on the non-final node of the path was still controversial, but okay :)
[13:26:04] *** Joins: hjr3 (hradtke@moz-E87BDF1F.socal.res.rr.com)
[13:26:23] <dbaupp> benh: it is
[13:26:24] <benh> I think my favorite approach would be to say Type::trait_member in the case where its unambiguous and allow Trait::<for Type>::trait_member as a "fully explicit" form, and then allow use I = Trait for Type; I::trait_member as a shortcut for repeatedly resolving things from the trait. So basically "all of the above" :(
[13:26:25] <bjz_> benh: it's probably me just being noisy. :(
[13:26:45] <dbaupp> benh: (that is my favourite one too, now)
[13:27:09] <dbaupp> bjz_: hm, I don't think it's that bad
[13:27:23] <benh> then we can just generalize x.f() to be the same thing as Tr::f(&x) when it's unambiguous and it's all very neat and consistent, imo :D
[13:27:27] <engla> Zero doesn't have this issue but FromStr has.. the type hint for the latter is just T, but if you use return value, you have to specify Option<T>
[13:27:46] <engla> let x: Option<int> = FromStr::from_str("")
[13:27:51] <dbaupp> benh++
[13:28:30] <bjz_> benh++
[13:28:54] <dbaupp> benh: (that's a plan too, uniform call syntax is the jargon Rust is using I think.)
[13:29:52] <bjz_> benh: a 'have your cake and eat it' approach would be nice
[13:29:56] <ChrisMorgan> Argh, my ``impl<T: Reader + Writer> Stream for T;`` failed spuriously on BSD *again*.
[13:30:09] <dbaupp> ChrisMorgan: ! :(
[13:30:37] <engla> I didn't know that syntax was legal, without {}
[13:31:09] <dbaupp> ChrisMorgan: retry'd 
[13:31:24] <ChrisMorgan> It is for an impl with no methods required. But ``trait X;`` is not valid.
[13:31:30] <ChrisMorgan> Thanks, dbaupp.
[13:31:55] <dbaupp> there's an issue about these inconsistencies somewhere
[13:32:22] <engla> interesting
[13:32:22] <bjz_> benh: but then again, you can't please everyone, and you don't want to. nothing worse than design by comittee that ends up pleasing nobody
[13:32:58] <dbaupp> https://github.com/mozilla/rust/issues/7981
[13:33:14] *** Joins: DAddYE (DAddYE@moz-98D3933F.hsd1.ca.comcast.net)
[13:33:49] <bjz_> dbaupp: hey, that's mine! :P
[13:34:16] <benh> trait Tr { fn foo(); } is different from trait Tr { fn foo() {} } though!
[13:34:27] <engla> SimonSapin: regarding as_imm_buf/as_mut_buf neither needs to be unsafe since they just return raw pointers, nothing more.
[13:34:28] *** Quits: hjr3 (hradtke@moz-E87BDF1F.socal.res.rr.com) (Quit: My MacBook has gone to sleep. ZZZzzzâ€¦)
[13:34:31] <dbaupp> bjz_: you've memorised the issue numbers of the ones you've opened? :P
[13:34:40] <bjz_> dbaupp: I clicked on it
[13:34:54] *** Quits: DAddYE (DAddYE@moz-98D3933F.hsd1.ca.comcast.net) (Ping timeout)
[13:35:03] <bjz_> dbaupp: I'm not that crzy :D
[13:35:25] <benh> bjz_: what do you mean by 'allowed' in the trait B; line?
[13:35:30] * dbaupp ignores bjz_'s lies, and continues living in his fantasy
[13:35:31] <SimonSapin> engla: so, by using raw pointers, they can already only be used in unsafe code?
[13:35:39] <engla> SimonSapin: yes
[13:35:44] <SimonSapin> ok, cool
[13:35:47] *** Joins: ghrust (ghrust@F6EE6DE3.6A2AE50.F3114085.IP)
[13:35:48] <ghrust> 01[13rust01] 15bors pushed 0 new commits to 06auto: 02http://git.io/06vpiA
[13:35:48] *** Parts: ghrust (ghrust@F6EE6DE3.6A2AE50.F3114085.IP) ()
[13:35:49] *** Joins: ghrust (ghrust@24260B07.6A2AE50.F3114085.IP)
[13:35:49] <ghrust> 01[13rust01] 15bors pushed 2 new commits to 06auto: 02http://git.io/dTIt9A
[13:35:49] <ghrust> 13rust/06auto 14da042ce 15Chris Morgan: Implement Stream automatically for Reader + Writer...
[13:35:49] <ghrust> 13rust/06auto 144c62b52 15bors: auto merge of #8984 : chris-morgan/rust/auto-stream-impl, r=huonw...
[13:35:49] *** Parts: ghrust (ghrust@24260B07.6A2AE50.F3114085.IP) ()
[13:36:19] <engla> SimonSapin: also, ffi functions often mutate *T as well as *mut T, it is not consistent. so the two functions are basically equal in capacity
[13:37:20] *** Joins: enix (enix@moz-A50569DD.c3-0.slvr-ubr1.lnh-slvr.md.cable.rcn.com)
[13:37:31] <bjz_> benh: removed it :P
[13:37:45] <SimonSapin> I guess
[13:37:51] <bjz_> benh: must have been the cat banging on the keyboard
[13:38:00] <SimonSapin> I hadnâ€™t paid attention to that fact that it used unsafe pointers
[13:38:43] <bjz_> benh: www.youtube.com/watch?v=J---aiyznGQ
[13:39:09] *** Joins: dew (Instantbir@moz-D2FA52B6.static.stls.mo.charter.com)
[13:39:25] <benh> :D
[13:39:54] *** Quits: dew1 (Instantbir@moz-D2FA52B6.static.stls.mo.charter.com) (Ping timeout)
[13:40:12] *** Quits: enix (enix@moz-A50569DD.c3-0.slvr-ubr1.lnh-slvr.md.cable.rcn.com) (Quit: Konversation terminated!)
[13:41:07] *** Quits: saml (sam@moz-14C16814.cst.lightpath.net) (Client exited)
[13:43:29] *** Joins: sankha93 (Instantbir@7061CD01.D6BD0D91.22D41759.IP)
[13:45:02] *** Joins: saml (sam@moz-14C16814.cst.lightpath.net)
[13:45:04] *** Joins: dave1629 (dave@4F93F0A6.4C91BF6B.DDE5D3F6.IP)
[13:47:18] <dbaupp> benh: btw, https://github.com/mozilla/rust/issues/6894#issuecomment-23868162 (bjz_ quoted you)
[13:47:49] <bjz_> yeah I let him know
[13:47:55] <benh> cheers
[13:48:09] <benh> my bikeshed-to-contributions ratio is getting a bit embarassing so I didn't want to comment on the issue myself :)
[13:48:30] <dbaupp> (ok)
[13:48:32] <bjz_> benh: I am concerned too :D
[13:48:32] *** Joins: natal (Mibbit@moz-3CE49532.lrde.epita.fr)
[13:48:50] <bjz_> benh: about me not you x)
[13:49:09] <dbaupp> benh: buy yourself some bikeshed credits with some amazing bug fixes :P
[13:49:13] <bjz_> hahaha
[13:49:38] <dbaupp> 3 bikeshed comments per commit in master
[13:49:42] <benh> :D
[13:49:45] * bjz_ thinks dbaupp outranks bjz_ in bikeshed credits
[13:49:50] <cmr> Hey, I have a lot to spend then!
[13:50:30] *** Quits: natal (Mibbit@moz-3CE49532.lrde.epita.fr) (Quit: http://www.mibbit.com ajax IRC Client)
[13:50:52] <bjz_> dbaupp: thankfully they chose the right dude to lead rust :P
[13:50:57] *** Quits: huseby (huseby@moz-4E8C421A.husebyhome.com) (Quit: Leaving)
[13:51:08] <dbaupp> bjz_: (who has now left.)
[13:51:26] <dbaupp> cmr: you should splurge: comment on all the bikesheds!
[13:51:30] <bjz_> dbaupp: no, brso - he has the most credits!
[13:51:34] <bjz_> *brson
[13:51:41] <dbaupp> bjz_: oh! I see
[13:52:08] <dbaupp> he's got 13500 comments to make
[13:52:12] <bjz_> hehehe
[13:52:26] <bjz_> no, he's saving them up
[13:52:55] <cmr> Unless it's something affecting ABI or runtime characteristics, I find I don't particularly care or know enough to participate in the language design discussion
[13:52:57] <cmr> s
[13:53:39] <dbaupp> cmr: you're #27 on commits to master, so you certainly know enough :)
[13:53:56] <cmr> Not for language design! I may have opinions, but they're not informed :P
[13:54:39] *** Joins: Larry (larryfox@moz-343B6F0C.nyc.biz.rr.com)
[13:55:03] <bjz_> cmr: I worry my mouth is too large for my informed-ness. need to get back to doing the exercises in "Types and Programming Languages"
[13:55:06] <bjz_> :P
[13:55:30] <benh> But that's the beauty of bikesheds, everybody has a favorite color :)
[13:55:44] <cmr> https://aboutthedata.com/
[13:55:48] <cmr> This is pretty cool and scary.
[13:55:54] <cmr> It thinks I'm married with a child
[13:56:31] <dbaupp> cmr: how's your wife?
[13:56:37] <benh> It thinks I have javascript disabled. :)
[13:56:49] <cmr> dbaupp: I don't know, doesn't give me the data about my inferred spouse :P
[13:57:31] *** Joins: jstevans (Instantbir@63581AE5.D3B9A4F3.DDE5D3F6.IP)
[13:58:10] <bjz_> cmr: do you have to sign up to see?
[13:58:27] <cmr> bjz_: yeah, you have to put in all your information
[13:58:40] <olsonjeffery> acrichto: mucho gracias
[14:00:27] <olsonjeffery> r-r-r-r-reeebbbaaaaaaaase
[14:02:09] *** Quits: ozten (ozten@moz-DD3B00B4.hsd1.wa.comcast.net) (Quit: ozten)
[14:06:11] *** Joins: maxli (maxli@moz-6EADA619.cpe.net.cable.rogers.com)
[14:09:53] *** Joins: nano (nano@moz-74CAD1CA.superkabel.de)
[14:11:10] <cmr> Eugh, was each_path removed?
[14:11:55] <cmr> I actually used that for useful things :(
[14:13:17] <cmr> https://github.com/mozilla/rust/commit/1bbb1e06f114b0a26cd9d9ca35fe1f248c56442a
[14:15:31] <dbaupp> presumably it was replaced with something useful
[14:15:45] <dbaupp> *equally useful
[14:20:55] *** Joins: Palmik (palmik@moz-CC484FDD.tmcz.cz)
[14:22:14] *** Quits: nano (nano@moz-74CAD1CA.superkabel.de) (Connection reset by peer)
[14:24:20] <engla> ChrisMorgan: I'm blake2-ppc who added the writer passthrough comment on github. I'll see if I can produce a proof of concept impl
[14:25:16] <ChrisMorgan> Passthrough may be useful in some cases, but it's won't satisfy those needing buffering of both reading and writing.
[14:25:41] <dbaupp> ChrisMorgan: ReadBuffer<WriteBuffer<W>> with passthrough on each?
[14:26:00] <ChrisMorgan> dbaupp: eww.
[14:26:22] <dbaupp> ChrisMorgan: hidden by a typedef or something
[14:26:48] <engla> exactly like that ChrisMorgan 
[14:26:49] <dbaupp> type StreamBuffer<W> = ReadBuffer<WriterBuffer<W>>;
[14:26:55] <ChrisMorgan> Is that legal?
[14:27:23] <dbaupp> definitely
[14:27:29] <ChrisMorgan> Whether it is or not, you'd get a slight perf loss on that unless the compiler was smart enough.
[14:27:38] <ChrisMorgan> And StreamBuffer::new?
[14:28:13] <dbaupp> ah, no
[14:28:17] <ChrisMorgan> BTW, I don't like (Read|Write|Stream)Buffer as names, though I'll freely admit that Buffered(Reader|Writer|Stream) is a little cumbersome.
[14:28:39] <dbaupp> (inlining + monomorphisation should mean no cost)
[14:28:58] * dbaupp doesn't care about which names are used at all.
[14:28:59] <cmr> I think BufferedFoo is a way better name.
[14:28:59] <engla> ChrisMorgan: the names in my examples are not chosen with care
[14:29:15] <engla> I have no point about naming
[14:29:16] * ChrisMorgan doesn't know how much inlining and such LLVM does
[14:29:37] <cmr> ChrisMorgan: 90% of the time you can expect LLVM to be sufficiently smart
[14:30:21] <ChrisMorgan> I end up not knowing because I'm presuming it also wants to keep the stack (with debug info at least) fairly similar to what's in the code.
[14:30:35] <ChrisMorgan> And I don't have any experience in knowing what compilers do with such things.
[14:31:38] <ChrisMorgan> What would happen to the stack in a case like this if it optimised it?
[14:31:41] <dbaupp> ChrisMorgan: with the passthrough ones, they'd be #[inline]'d to make it inline it very often
[14:31:55] <ChrisMorgan> Oh yeah.
[14:32:07] <ChrisMorgan> How can you check if it is inlining things?
[14:32:12] <cmr> Look at the generated LLVM
[14:32:40] <cmr> ChrisMorgan: once a function is inlined, LLVM will freely optimize it in that specific context.
[14:32:46] <ChrisMorgan> Ah yes, I get it.
[14:32:47] <cmr> The stack might not even be touched
[14:33:51] *** Joins: DAddYE (DAddYE@moz-98D3933F.hsd1.ca.comcast.net)
[14:37:51] *** Quits: jstevans (Instantbir@63581AE5.D3B9A4F3.DDE5D3F6.IP) (Ping timeout)
[14:38:01] *** Quits: DAddYE (DAddYE@moz-98D3933F.hsd1.ca.comcast.net) (Ping timeout)
[14:39:46] *** Quits: dave1629 (dave@4F93F0A6.4C91BF6B.DDE5D3F6.IP) (Quit: dave1629)
[14:39:54] <engla> ChrisMorgan: but in your example the write and read buffer don't interact
[14:40:05] <engla> what does it look like for a R/W file?
[14:41:46] <olsonjeffery> ChrisMorgan: hey i just chimed in on the buffered io ticket
[14:41:50] <olsonjeffery> mostly a tangent
[14:42:51] <ChrisMorgan> Ooh, delightful; attempting to impl Baz given type Baz<T> = Foo<Bar<T>> (all in the same module) makes "error: cannot associate methods with a type outside the crate the type is defined in; define and implement a trait or new type instead"
[14:44:07] * ChrisMorgan doesn't know... /me just likes buffering where it works well
[14:44:15] <olsonjeffery> ChrisMorgan: wrap it like `struct Baz<T>(Foo<Bar<T>>);
[14:44:58] <ChrisMorgan> I know it can't be done that way, it's the incorrectness of the error message ("a type outside the crate") that I'm commenting on.
[14:44:58] <engla> you can't use `type` synonyms with impl, it has to be spelled out
[14:45:03] <engla> oh
[14:45:14] <dbaupp> ChrisMorgan: file it
[14:45:28] <ChrisMorgan> Anyway, I'm off to bed now. Farewell. I'll need to file later.
[14:46:01] <engla> bye
[14:46:28] * ChrisMorgan wonders whether he should stay up and try to snipe #9000
[14:46:30] <ChrisMorgan> Answer: no.
[14:46:52] <engla> it's close
[14:47:01] <ChrisMorgan> Only #8999 to go first.
[14:47:41] <engla> maybe it's better to snipe #9001. Then the number of issues will be over 9000
[14:48:13] *** Joins: anri (solancile@moz-E49E7C4B.hsd1.wa.comcast.net)
[14:48:20] *** Quits: threecreepio (jdp@moz-1A9F0A3C.cust.bredband2.com) (Quit: threecreepio)
[14:48:20] *** Joins: jstevans (Instantbir@moz-9DA403CD.bootp.virginia.edu)
[14:51:11] *** Quits: ChrisMorgan (chris@moz-6AC741CA.static.tpgi.com.au) (Ping timeout)
[14:51:32] *** Joins: cubic (cubic@moz-FE5AD6C7.mc.videotron.ca)
[14:56:49] <jstevans> Can I use a lambda to match part of a string?
[14:57:42] <jstevans> Specifically, could I match ("HTTP GET /" + path) and get path in a single lambda?
[14:59:38] *** Joins: josh (josh@moz-348C4790.hsd1.mn.comcast.net)
[15:01:10] *** Quits: Axord (xord@moz-1B228827.lsanca.dsl-w.verizon.net) (Ping timeout)
[15:01:27] <engla> yes I think so
[15:04:31] *** Joins: jensnockert (jensnocker@moz-8BE55278.customer.t3.se)
[15:04:43] <engla> hm maybe not in a lambda. you want to take a &str and return the matching string slice if any, another &str with the same lifetime
[15:05:06] <engla> but to specify the lifetime parameters you need a function declaration
[15:09:27] *** Quits: Ralith (ralith@114DA04D.CD83ED0A.BCDF04A6.IP) (Ping timeout)
[15:10:03] *** Joins: tiffany (kawaii@moz-EB8B0C08.dhcp.embarqhsd.net)
[15:10:10] *** Quits: sebcrozet (sebcrozet@moz-3CE49532.lrde.epita.fr) (Ping timeout)
[15:11:56] *** Joins: jmgrosen (jmgrosen@moz-848F6087.sb.sd.cox.net)
[15:13:21] <jstevans> Sorry, confused matches with lambdas. Can I do something like let myMatch = match myStr {
[15:13:21] <jstevans> "GET /"+path+" HTTP/1.1"+moreThings => path
[15:13:21] <jstevans> }
[15:13:22] <jstevans> ?
[15:13:55] <jstevans> I've never seen either construction before (match or lambda) so I'm struggling with it a bit
[15:16:18] *** Joins: sebcrozet (sebcrozet@moz-3CE49532.lrde.epita.fr)
[15:17:33] <olsonjeffery> rusti: let s = "foo"; match s { "foo" => true, _ => false }
[15:17:33] -rusti- true
[15:17:44] <olsonjeffery> rusti: let s = "bar"; match s { "foo" => true, _ => false }
[15:17:45] -rusti- false
[15:18:51] <jstevans> rusti: let s = "bar"; match s{ "bar" => "asdf", _ => "dfea"}
[15:18:52] -rusti- "asdf"
[15:18:57] <jstevans> oh, that's so cool.
[15:19:16] <engla> I don't think match can match on substrings
[15:19:36] <engla> it's mostly to match on destructured values, like this
[15:19:57] <jstevans> So I just have to do it the old fashioned way, without any cool Rust-specific constructions?
[15:20:08] <engla> rusti: match Some(27) { Some(x) if x % 3 == 0 => "yes", _ => "no" }
[15:20:09] -rusti- "yes"
[15:22:06] <olsonjeffery> yeah
[15:22:20] *** Joins: threecreepio (jdp@moz-71E164C9.cust.bredbandsbolaget.se)
[15:22:21] <olsonjeffery> also match really shines in cases where you're doing compile time exhaustiveness checking
[15:22:52] <olsonjeffery> you can't do non-trivial string matching w/o basically making it synonymous with what you'd do, with different syntax, in an if/else clause..
[15:22:59] *** Quits: sebcrozet (sebcrozet@moz-3CE49532.lrde.epita.fr) (Ping timeout)
[15:24:04] <engla> there is vector slice matching, but str doesn't have the same conceptual substructure
[15:24:13] <engla> rusti: match "Abc".as_bytes() { [65, .._]  => 1, _ => 0 }
[15:24:13] -rusti- 1
[15:25:25] <jorendorff> bblum: ping me whenever you want to debug that assertion
[15:26:58] <bblum> jorendorff: we can look now
[15:27:44] *** Quits: StarLight (StarLight@moz-BF70B61.pppoe.avangarddsl.ru) (Ping timeout)
[15:28:30] <jorendorff> what's the mozilla live-multiple-people-editing web thingy?
[15:28:39] <bblum> etherpad
[15:28:58] <jorendorff> bblum: https://etherpad.mozilla.org/rust8863
[15:29:21] *** Quits: jmgrosen (jmgrosen@moz-848F6087.sb.sd.cox.net) (Quit: jmgrosen)
[15:29:24] <jorendorff> you can just type in commands to gdb if you like
[15:29:32] *** Quits: sigma (sigma@51C589B3.EF2694B5.DFAC6AA7.IP) (Ping timeout)
[15:30:29] *** Joins: miza (miza@moz-BE2AF601.ws.skroutz.gr)
[15:30:49] *** Joins: StarLight (StarLight@moz-BF70B61.pppoe.avangarddsl.ru)
[15:30:59] <jorendorff> this is rev 6c13b0f4 btw (about 20 hours old)
[15:33:49] <jorendorff> bblum: you'll have to ping me here if i'm unresponsive... i'm doing other stuff too
[15:34:10] *** Quits: maxli (maxli@moz-6EADA619.cpe.net.cable.rogers.com) (Quit: Leaving.)
[15:34:50] *** Joins: riley (riley@8BA43816.9AA11D69.65DDFA89.IP)
[15:34:52] *** Joins: sk (sk@61A494B3.BA40E8A.AAC02D62.IP)
[15:35:54] <bblum> jorendorff: ok, i'm in the tank at the moment
[15:36:10] <jorendorff> tank?
[15:36:13] <bblum> think tank
[15:36:15] <jorendorff> k
[15:36:24] *** Joins: huseby (huseby@19BD73A1.5D8BCA3A.A0C1B52F.IP)
[15:36:31] *** Joins: dherman (dherman@moz-6CA476B1.hsd1.ca.comcast.net)
[15:36:31] *** ChanServ sets mode: +ao dherman dherman
[15:36:47] <bblum> jorendorff: can this ever happen with RUST_THREADS=1 ?
[15:36:56] *** Joins: maxli (maxli@moz-6EADA619.cpe.net.cable.rogers.com)
[15:36:57] *** Joins: DAddYE (DAddYE@moz-98D3933F.hsd1.ca.comcast.net)
[15:37:18] <jorendorff> bblum: empirically, I tried and couldn't get it to happen with =1
[15:37:28] <jorendorff> or even 4
[15:37:33] <jorendorff> happens a lot with 16
[15:37:37] <bblum> good answer :P
[15:38:08] <jorendorff> "good" :(
[15:38:56] *** Quits: abacus (snoonan_mo@moz-F95B9243.hsd1.wa.comcast.net) (Ping timeout)
[15:39:11] *** Joins: abacus (snoonan_mo@moz-F95B9243.hsd1.wa.comcast.net)
[15:39:33] <miza> is there a way to have an TreeMap or HashMap that has boolean values
[15:39:47] *** abacus is now known as [a]bacus
[15:39:50] <miza> and find easy all true values without iterate all the map?
[15:40:41] <jorendorff> bblum: ok, it *can* happen with 4
[15:40:45] <bblum> jorendorff: good
[15:40:49] <jorendorff> just rarer
[15:41:08] *** Quits: DAddYE (DAddYE@moz-98D3933F.hsd1.ca.comcast.net) (Ping timeout)
[15:41:30] <bblum> urgh, how is this possibly platform-specific??
[15:42:20] *** Quits: jensnockert (jensnocker@moz-8BE55278.customer.t3.se) (Input/output error)
[15:43:07] <bblum> jorendorff: ok, well, in the meantime, can you try just commenting out the assertion that's failing; it's in rt/kill.rs
[15:43:18] <bblum> i predict that should have no issues
[15:43:30] <bblum> (it's just a performance assertion)
[15:44:25] *** Quits: zeuxcg (zeuxcg@moz-80D1F912.hsd1.ca.comcast.net) (Ping timeout)
[15:44:39] *** Joins: eholk (eholk@moz-F70D5031.hsd1.in.comcast.net)
[15:45:03] <jorendorff> sure. is there a different make target i should use for this?
[15:46:00] <bblum> nah
[15:46:06] <jorendorff> building
[15:46:30] <bblum> after that i guess i'll have some print statements for you to insert
[15:49:53] <jorendorff> sure, go ahead
[15:50:21] <jorendorff> bblum: can i build with make -j4? does that work? (i don't want to trigger another concurrency problem while debugging this one :)
[15:50:32] *** Quits: huseby (huseby@19BD73A1.5D8BCA3A.A0C1B52F.IP) (Quit: Leaving)
[15:50:34] <bblum> it won't help
[15:50:42] <bblum> except for llvm the rust build is not parallel
[15:51:11] <jorendorff> i thought you were about to say that rustc is cpu-bound and already uses all my cores, and i was about to be duly impressed :)
[15:52:03] <bstrie> jorendorff: if it would make you feel better, we could have rustc spawn busywaiting processes on every available core while the compiler itself builds
[15:55:17] *** Joins: jaen (jaen@moz-E0979827.copit.pl)
[15:55:25] <jorendorff> bstrie: http://quotes.burntelectrons.org/3897
[15:55:52] *** Joins: dwrensha (chatzilla@moz-AA82FBAF.hsd1.wa.comcast.net)
[15:56:47] *** Joins: sinma (sinma@moz-6A11C47C.fbx.proxad.net)
[15:58:24] *** Joins: Axord (xord@moz-1B228827.lsanca.dsl-w.verizon.net)
[15:59:14] *** Quits: FrozenCow (FrozenCow@moz-B2DF4929.chello.nl) (Ping timeout)
[15:59:14] <dwrensha> Could anyone help me with a question about traits?
[15:59:20] <dwrensha> Please take a look here: https://gist.github.com/dwrensha/ef047c76861fd3d1b87f
[16:00:55] <cmr> dwrensha: that's a resolve bug iirc.
[16:01:13] <bblum> unclear to me if that's a bug
[16:01:28] <cmr> well
[16:01:30] <bblum> seems like it is trying to "defend itself" against the possibility that you could add a "impl Bar for u16"
[16:01:36] <cmr> it's intended behavior
[16:01:39] *** Joins: huseby (huseby@19BD73A1.5D8BCA3A.A0C1B52F.IP)
[16:01:44] <cmr> but wanted to be changed by everyone, afaik
[16:03:14] <dwrensha> Well, if that's the intended behavior, I want it to be changed too
[16:03:22] <dwrensha> unless there's a workaround...
[16:03:40] <cmr> the workaround is using a newtype
[16:03:50] <dwrensha> how does that work?
[16:03:52] <cmr> erm, actually, not sure there's a workaround
[16:05:28] *** Joins: infynyxx (infynyxx@moz-E95B370B.nyc.res.rr.com)
[16:05:40] *** Joins: Ms2ger (Ms2ger@moz-B53902AE.adsl-dyn.isp.belgacom.be)
[16:06:59] <sinma> Hi, Iâ€™m want to dev a small game, very simple and I wonder if I can do it with Rust and SFML. Thereâ€™s a binding but I donâ€™t know if itâ€™s based on 0.7 or current, and I donâ€™t know if itâ€™s hard to keep your code up to date to compile with the master branch.
[16:07:16] <olsonjeffery> rusti: trait Foo { fn bar(&self) -> u16; } struct Baz(u16); impl Foo for Baz { fn bar(&self) -> { **self } } let froboz = Baz(42); froboz.bar()
[16:07:19] -rusti- pastebinned 4 lines of output: http://ix.io/7S3
[16:07:20] *** Quits: jstevans (Instantbir@moz-9DA403CD.bootp.virginia.edu) (Connection reset by peer)
[16:07:20] *** Joins: jstevans (Instantbir@moz-9DA403CD.bootp.virginia.edu)
[16:07:23] *** Quits: maxli (maxli@moz-6EADA619.cpe.net.cable.rogers.com) (Quit: Leaving.)
[16:07:38] <olsonjeffery> rusti: trait Foo { fn bar(&self) -> u16; } struct Baz(u16); impl Foo for Baz { fn bar(&self) -> u16 { **self } } let froboz = Baz(42); froboz.bar()
[16:07:39] -rusti- 42u16
[16:07:50] <olsonjeffery> it's always something, innit.
[16:08:29] <sinma> Cause Rust is under heavy developpement, so I donâ€™t know the frequence of _big_ changes.
[16:08:41] *** Joins: echristo (echristo@DCF57675.D6CCE4AE.77834EAA.IP)
[16:08:46] *** Joins: jstevans1 (Instantbir@A58A8051.4F63199.DDE5D3F6.IP)
[16:09:23] <olsonjeffery> sinma: i would say looking at when the bindings repo changed, last.. that would give you a possible indication of what version it's tracking, if its not mentioned explicitly in the docs..
[16:09:24] <cmr> sinma: really big changes are few and far between at this point, the only recent one that comes to mind is iterators.
[16:09:49] <olsonjeffery> cmr: removing generics from static methods broke a lot of stuff
[16:09:51] *** Quits: jstevans (Instantbir@moz-9DA403CD.bootp.virginia.edu) (Ping timeout)
[16:09:52] <olsonjeffery> at least in newrt
[16:09:54] *** Quits: miza (miza@moz-BE2AF601.ws.skroutz.gr) (Quit: Leaving.)
[16:10:21] *** Joins: mib_q5mzy9 (Mibbit@moz-8FDA6122.static.cpe.netcabo.pt)
[16:10:22] <cmr> sinma: I just built it with master
[16:10:40] *** Joins: sebcrozet (sebcrozet@moz-A855F6C0.w82-127.abo.wanadoo.fr)
[16:10:45] <cmr> (rust-sfml)
[16:10:49] <olsonjeffery> nice.
[16:10:52] <sinma> ok
[16:11:08] *** Joins: jclements (jclements@moz-9C0ABCFC.wireless.calpoly.edu)
[16:11:59] *** Joins: sigma (sigma@51C589B3.EF2694B5.DFAC6AA7.IP)
[16:13:49] *** Joins: tav (tav@moz-505FBB11.range86-160.btcentralplus.com)
[16:14:36] <sinma> I think it can be quite nice to have a Qt5 Rust binding, but it seems to be a really big work
[16:15:06] <cmr> It's an open problem whether it's even possible.
[16:15:45] <sinma> Why it canâ€™t be possible?
[16:15:46] <cmr> At least nice non-C-like bindings
[16:15:52] <cmr> sinma: conflicting memory models
[16:16:01] <dwrensha> cmr: what's the best way for me to register a complaint about this kind of thing?
[16:16:15] <sinma> Thereâ€™s Qt4 binding for many different languages
[16:16:19] <cmr> dwrensha: open an issue and make a post to the mailing list.
[16:16:35] *** Quits: davbo (dave@moz-3FFA637C.oucs.ox.ac.uk) (Client exited)
[16:16:36] <sinma> That sounds strange it would not possible with Rust.
[16:17:31] <doomlord> c++ libraries are usually very c++ specific
[16:18:00] <sinma> I see the point.
[16:18:02] *** Joins: bent (chatzilla@moz-BE33DA21.fw1.sfo1.mozilla.net)
[16:18:16] <cmr> sinma: and all of them have a GC'd memory model
[16:18:21] <sinma> The SFML binding use the C SFML binding
[16:18:24] <cmr> (well, besides C++ itself)
[16:18:26] <zol> Cool! SFML bindings for rust. The examples doesn't look like idiomatic rust however..? 
[16:18:36] <doomlord> qt is gc'd ?
[16:18:45] <sinma> no
[16:18:51] <doomlord> i'd have thought it was all c++ RAII
[16:18:57] <cmr> *besides* C++
[16:19:42] <sinma> Ada and Common Lisp are also GCâ€™d?
[16:19:55] <sinma> (I didnâ€™t know much about those languages)
[16:20:12] *** Joins: eatkinson (eatkinson@moz-261EDE03.hsd1.ca.comcast.net)
[16:20:12] <cmr> Hm, I don't know about ada
[16:20:14] <sinma> And Pascal
[16:21:11] *** Quits: jstevans1 (Instantbir@A58A8051.4F63199.DDE5D3F6.IP) (Ping timeout)
[16:21:27] <sinma> And TCL
[16:21:38] <heftig> I hope rust gets GIR bindings
[16:21:43] <sinma> According to Wikipedia, some seems to not have a GC
[16:21:44] *** Quits: eatkinson (eatkinson@moz-261EDE03.hsd1.ca.comcast.net) (Quit: eatkinson)
[16:22:01] *** Joins: jstevans (Instantbir@C6DDFA75.D7E9E509.B7830B68.IP)
[16:22:03] <zol> heftig: GIR?
[16:22:14] <sinma> GIR??
[16:22:17] <cmr> sinma: re: pascal it looks like the interface is very C-like
[16:22:27] <cmr> heftig: https://github.com/mzabaluev/grust
[16:22:54] <sinma> Oh, not Gobject
[16:22:54] <heftig> GObject-Introspection; lets you access GLib, GTK, Webkit, GStreamer, et cetera
[16:22:55] <sinma> xD
[16:23:03] *** Joins: jstevans1 (Instantbir@moz-27868823.bootp.virginia.edu)
[16:23:08] <heftig> cmr: neat, thanks.
[16:23:41] *** Quits: jstevans (Instantbir@C6DDFA75.D7E9E509.B7830B68.IP) (Ping timeout)
[16:23:48] <sinma> Ok, thatâ€™s quite a big bundle of libs you can access that way
[16:24:43] *** Quits: jstevans1 (Instantbir@moz-27868823.bootp.virginia.edu) (Ping timeout)
[16:26:06] <cmr> sinma: so to write Rust bindings you'd need to use http://techbase.kde.org/Development/Languages/Smoke
[16:26:12] *** Joins: carllerche (carllerche@6B070D22.7E6A0813.1428D117.IP)
[16:26:28] *** Joins: maxli (maxli@moz-6EADA619.cpe.net.cable.rogers.com)
[16:26:44] *** Joins: jstevans (Instantbir@moz-B5AD737D.bootp.virginia.edu)
[16:26:45] *** Joins: ozten (ozten@19BD73A1.5D8BCA3A.A0C1B52F.IP)
[16:26:46] *** Quits: threecreepio (jdp@moz-71E164C9.cust.bredbandsbolaget.se) (Quit: threecreepio)
[16:27:05] *** Joins: SiegeLord (sl@moz-CAF07B4C.hsd1.ma.comcast.net)
[16:27:09] <cmr> no one has tried it, so no one knows what the problems would be.
[16:27:17] <heftig> g-i itself comes with bindings to cairo, dbus, fontconfig, freetype, gio, glib, libxml2, xfixes, xft, xlib, xrandr
[16:28:19] *** Joins: jstevans1 (Instantbir@moz-C8D40BF5.bootp.virginia.edu)
[16:28:24] *** Quits: jstevans (Instantbir@moz-B5AD737D.bootp.virginia.edu) (Ping timeout)
[16:28:49] *** Joins: tjc (tjc@moz-6EB4E533.dsl.tsoft.com)
[16:28:49] *** ChanServ sets mode: +o tjc
[16:29:28] *** Joins: jdsanders (Adium@moz-84CB7548.hlrn.qwest.net)
[16:30:02] <doomlord> seems like the major ui libraries are usually very language specific
[16:30:05] *** Joins: azita (Azita@moz-BBE3ABD.mv.mozilla.com)
[16:30:19] <doomlord> objC, C++, java (android ui) 
[16:30:32] <sigma> rust seems like a good candidate for some sort of FRP approach
[16:30:52] <zol> sigma: functional reactive programming? 
[16:30:55] <cmr> sigma: tiffany was playing with it but had too many problems and stopped
[16:31:13] <sigma> zol: yeh
[16:31:21] <tiffany> I didn't really know what I was doing when I tried implementing it though
[16:31:40] <sigma> I havn't looked into it, Rust's feature-set just seems like it might be amenable
[16:31:53] <sinma> cmr: Iâ€™m mostly a newbie into programming
[16:32:05] <sinma> Iâ€™ve never coded something in Qt actually
[16:32:07] <tiffany> I didn't think to use channels while implementing lift2 and I hadn't really gotten the hang of lifetimes
[16:32:30] <jdsanders> what's the best resource for reading about lifetimes?
[16:32:41] <engla> I think closure reform should help eventually. It will be easier to control how closures use the closed-over variables
[16:32:52] <sinma> Just I like what Iâ€™ve heard about it and I want to learn it. QtQtuick is one the killer feature that seems amazing.
[16:32:54] <jdsanders> there's a good section in the borrowed pointer tutorial, but I don't see anything specifically focused on lifetimes
[16:32:56] <tiffany> will you be able to have multiple closures closing over the same values?
[16:33:18] <engla> I think so tiffany but it will have to be by reference
[16:33:22] <sinma> cmr: so Iâ€™ll go play with Rust
[16:33:48] <tiffany> I can't really do a "top down" approach to implementing frp because of nesting generic structures with different type parameters
[16:34:29] <tiffany> so I have to handle lift2 using two closures for each parameter
[16:36:28] <sinma> cmr: thereâ€™s isnâ€™t any UI library available in Rust?
[16:36:31] *** Quits: spider-mario (spidermari@moz-2F72F6FF.dsl.quantic-telecom.net) (Input/output error)
[16:36:34] *** Joins: dave1629 (dave@7FB91DA3.3C990DFD.DDE5D3F6.IP)
[16:36:40] <engla> I've only been playing with expanding unfoldl's parser combinator example; it too has some inconveniences with moving values into closures.
[16:36:44] <cmr> sinma: supposedly gtk works through grust
[16:36:56] <cmr> sinma: anything exposing a C ABI is usable.
[16:37:04] *** Joins: brson (brson@moz-BBE3ABD.mv.mozilla.com)
[16:37:04] *** ChanServ sets mode: +ao brson brson
[16:37:21] *** Quits: dave1629 (dave@7FB91DA3.3C990DFD.DDE5D3F6.IP) (Quit: dave1629)
[16:37:28] <sinma> Is it possible to use C++ with Qt for UI and use Rust + SFML for the other part? Seems pretty complicated.
[16:37:43] <sinma> cmr: ah yes, everything works pretty well when itâ€™s Câ€¦
[16:37:45] <cmr> MaikKlein did that.
[16:37:46] *** Joins: jstevans (Instantbir@C6DDFA75.D7E9E509.B7830B68.IP)
[16:37:48] <tiffany> SFML is C++
[16:37:59] <cmr> Kinda
[16:38:03] <tiffany> you'd have to use something like sdl or glfw instead, or write a C++ binding (or generate one using SWIG)
[16:38:07] <cmr> Wrote the GUI part in C++ and called into Rust
[16:38:19] <cmr> tiffany: there are C bindings and Rust bindings.
[16:38:23] <tiffany> oh?
[16:38:25] <cmr> https://github.com/JeremyLetang/rust-sfml
[16:38:32] <sinma> Thatâ€™s why I asked that
[16:38:40] *** Quits: jstevans1 (Instantbir@moz-C8D40BF5.bootp.virginia.edu) (Ping timeout)
[16:39:21] <sinma> Anyway, Iâ€™m not going to do any UI dev until I have a pretty advanced game.
[16:40:01] *** Quits: jstevans (Instantbir@C6DDFA75.D7E9E509.B7830B68.IP) (Connection reset by peer)
[16:40:18] <tiffany> I don't suppose there's any plans to make rust able to ffi to C++
[16:40:31] <cmr> tiffany: https://github.com/mozilla/rust/issues/5853
[16:41:03] <sinma> Yes I know C++ is a shitty language to deal with outside of the C++ world.
[16:41:20] *** Joins: jstevans (Instantbir@A58A8051.4F63199.DDE5D3F6.IP)
[16:41:56] *** Quits: jclements (jclements@moz-9C0ABCFC.wireless.calpoly.edu) (Quit: jclements)
[16:41:58] *** Joins: jstevans1 (Instantbir@A7D1887E.C325DF16.DDE5D3F6.IP)
[16:43:00] *** Quits: jstevans (Instantbir@A58A8051.4F63199.DDE5D3F6.IP) (Ping timeout)
[16:43:40] <tiffany> hm, sidestepping the problems of templates and multiple inheritance seems like it'd still work for a number of projects
[16:43:43] <sinma> If I use SFML binding, when I make a function call itâ€™s: Rust â†’ CSFML â†’ SFML â†’ CSFML â†’ Rust, isnâ€™t it?
[16:43:54] <tiffany> yeah
[16:44:03] <sinma> May it impact the performances in any way?
[16:44:16] <sinma> Iâ€™m thinking about cast or something
[16:45:09] *** Joins: Ralith (ralith@A8995AA9.62B6AF6A.922221DB.IP)
[16:45:22] *** Quits: nkoep (nik@moz-8233EDE9.vpn.rwth-aachen.de) (Client exited)
[16:46:02] <cmr> Casts have zero performance impact
[16:46:07] <sinma> tiffany: so itâ€™ll be possible to call a C++ function from Rust in not fear future?
[16:46:25] <sinma> cmr: ok thx. But function call?
[16:46:30] <tiffany> I wouldn't hold my breath
[16:46:32] <cmr> dunno about that
[16:48:15] <sinma> I know thatâ€™s pretty silly, giving that most lib do the hard work, and calling function isnâ€™t a big overhead.
[16:48:44] <sinma> But if Iâ€™ll have to call many function, that would be nice to know the perfs implications.
[16:49:55] *** Quits: fabiand_ (fabiand@moz-A588C99B.adsl.alicedsl.de) (Quit: Verlassend)
[16:51:46] <SiegeLord> There's a thread on D forums about supposed ugliness of Rust when it comes to passing around sets of type parameters around... e.g. struct S<A,B,C,D,E,F,G> { a: S2<A,B,C,D,E,F,G>, b: S3<A,B,C,D,E,F,G> }
[16:52:16] <SiegeLord> In D, there's a way to remove the repetition inside there... is there in Rust?
[16:52:20] <SiegeLord> I doubt the macros instantiate there
[16:52:26] <cmr> No
[16:53:51] <SiegeLord> The D way is to essentially create new struct parametrized by the same parameters, and then pass that to S2 and S3
[16:54:07] <SiegeLord> So I think this is essentially asking for associated types
[16:54:08] *** Joins: DAddYE (DAddYE@moz-61EB081B.hfc.comcastbusiness.net)
[16:54:18] <SiegeLord> Which is a planned thing, iirc?
[16:56:08] <cmr> Associated types are planned, yes.
[16:56:27] <SiegeLord> That'd resolve that issue partially... the second component is a type alias
[16:57:06] *** Joins: mihneadb (mihneadb@moz-BE33DA21.fw1.sfo1.mozilla.net)
[16:57:40] <SiegeLord> The definition of S2 would then look like struct S2<T: ParamType> { a: T.A }
[16:57:59] <SiegeLord> Althought I don't think trait bounds can be placed there, so I wonder exactly how associated types are going to work :P
[16:58:12] <SiegeLord> (or a: T::A)
[16:59:07] <jorendorff> bblum: ok, with the assertion commented out, nothing bad happens
[16:59:24] <jorendorff> bblum: ping me if you want some print-statements or whatever
[16:59:27] <bblum> jorendorff: i suspected so
[16:59:34] <bblum> give me a bit, i gotta eat before i can think
[16:59:52] *** Joins: dpc (Mibbit@7FBDDBBD.1B10ED22.D9F38258.IP)
[17:00:01] <dpc> Hi everyone!
[17:00:32] <dpc> I wanted to prettyprint struct using json encoder. Am I doing it right? http://sprunge.us/ZdHS
[17:00:54] <dpc> I mean... it works, but is this the intended way of using it?
[17:01:01] *** Joins: Kruppe (user@moz-4DDA8AB8.uwaterloo.ca)
[17:01:01] <cmr> dpc: generally you don't want to implement Encodable manually.
[17:01:08] <cmr> Use #[deriving(Encodable)]
[17:01:37] <dpc> It did not worked with struct ...
[17:01:49] <dpc> So all of this is unnecessary? :)
[17:02:36] *** Joins: miza (miza@moz-4DD51325.home.otenet.gr)
[17:02:52] <dpc> Well... it works, cmr. Thanks. I'm unsure about this magic #[something] tricks. These are part of the compiler, or coded somewhere?
[17:03:12] <cmr> http://ix.io/7S6
[17:03:15] <cmr> Part of the compiler, yes.
[17:03:27] <dpc> Is there a list of them?
[17:03:43] <cmr> http://static.rust-lang.org/doc/rust.html#attributes has a partial list
[17:04:12] <dpc> And how come compiler has a "macro" that implements something which is in extra... . Is this ... proper? :)
[17:04:52] <nmatsakis> who is the maintainer of deriving these days?
[17:05:24] <cmr> nmatsakis: we assign maintainers to things?
[17:05:35] <engla> dpc: just like the whole #[test] and #[bench]
[17:05:36] <cmr> dbaupp seems to be a likely candidate
[17:06:02] <nmatsakis> cmr: no, I meant de facto :)
[17:06:11] <cmr> probably dbaupp then
[17:06:17] <dpc> One day, I hope to throw C away and write kernels and baremetal software in Rust, so I'm courious about the split line between "this is compiler" and "this is runtime".
[17:06:17] <nmatsakis> browsing the git log it wasn't clear to me who knows it best
[17:06:21] <nmatsakis> dbaupp: ping :)
[17:06:40] <cmr> dpc: https://github.com/cmr/cmoss
[17:06:41] <sinma> dpc: that can be great!
[17:06:50] <cmr> As well as https://github.com/charliesome/rustboot and other projects
[17:06:58] *** Quits: miza (miza@moz-4DD51325.home.otenet.gr) (Input/output error)
[17:07:14] *** Joins: miza (miza@moz-4DD51325.home.otenet.gr)
[17:07:40] <cmr> dpc: deriving just generates code. it will still fail to compile if you don't link to libextra
[17:07:51] <dpc> I work on baremetal software / RTOSes / kernels of any kind professionally, and I'm tired of C, but there's nothing to really replace it.
[17:08:06] <sinma> Not even C--
[17:08:07] <sinma> ?
[17:08:09] <sinma> xD
[17:08:19] <cmr> sinma: C-- is an IR
[17:08:28] <sinma> IR?
[17:08:34] <cmr> intermediate representation
[17:08:40] <cmr> something intended for a compiler to output.
[17:08:42] <dpc> Haven't really tried C--.
[17:08:47] *** Quits: Kruppe (user@moz-4DDA8AB8.uwaterloo.ca) (Client exited)
[17:08:51] <sinma> Oh damn I didnâ€™t know that
[17:08:56] <sinma> Anyway it was just a joke
[17:09:00] <dpc> Yeah, that's what rings my bell. Compiler outputs. :)
[17:09:14] <sinma> I know someone who code Â«objectÂ» in C
[17:09:31] <cmr> it's very common to do that
[17:09:41] <cmr> most good libraries, the linux kernel, etc
[17:09:42] <dpc> "code <<object>>" ?
[17:09:42] <sinma> With some works he can Â«emulateÂ» many object feature
[17:10:05] <sinma> Â« and Â» arenâ€™t << and >>
[17:10:13] <sinma> There are guillemets
[17:10:16] *** Joins: Kruppe (user@moz-4DDA8AB8.uwaterloo.ca)
[17:10:38] <dpc> Yeah, I know. Just don't have a simple way to type them atm. :)
[17:10:57] <SiegeLord> Compose key ftw ;)
[17:10:57] <dpc> We have these in our national typography. :)
[17:11:21] <dpc> What's the state of Rust for Arm, BTW?
[17:11:38] <cmr> dpc: works well.
[17:11:49] <sinma> SiegeLord: but maybe you can type it directly with a good keymap
[17:11:57] <cmr> can't use the standard library yet, but the language works fine
[17:12:08] <cmr> See https://github.com/neykov/armboot
[17:12:19] <SiegeLord> sinma: I never use them outside of showing off... so it's not useful for me to have a permanent key to them :P
[17:12:21] <engla> sinma: you just mean to emulate Â«OO ProgrammingÂ» right?
[17:13:31] <dpc> cmr: I think I've tried to compile it on my Arndale Board and it failed. Is it, I will try again then.
[17:14:06] <dpc> sinma: If that's what you mean then OO-like programming is everywhere.
[17:14:20] <sinma> engla: by emulate, I mean doing the same thing with the C tools
[17:14:24] <cmr> dpc: https://github.com/jensnockert/dueboot is a more up-to-date version
[17:14:37] <dpc> Most of the code I write or work with is based on principles of OO, just without the syntatic sugar for it.
[17:14:47] <sinma> Iâ€™ve see some gobjects example, so I fear to see some of that code
[17:15:09] *** Joins: ecr (Thunderbir@moz-BBE3ABD.mv.mozilla.com)
[17:15:24] *** Joins: hjr3 (hradtke@374E545A.3A8E9B0C.F9D9C60E.IP)
[17:15:51] <sinma> :p
[17:16:09] <dpc> I could write some tiny arm RTOS in Rust ... that would be fun. :D
[17:16:31] *** Joins: valenting (Thunderbir@8758046C.84D5EFD5.FB866788.IP)
[17:17:54] <dpc> Though I fear, my daily work in C could appear miserable because I would have a direct comparison....
[17:18:29] <dpc> How does RustOS sound? :D
[17:18:58] <tjc> sounds like a snack food :-)
[17:19:15] *** Quits: CarpNet (ac@moz-FD24B77.sohonet.co.uk) (Quit: Leaving)
[17:19:21] <bstrie> haha
[17:19:43] <dpc> configure: error: unknown CPU type: armv7l
[17:19:53] <dpc> That's what I'm hitting.
[17:20:10] <bstrie> thus was the downfall of the effort to write an OS in the Dorit programming language
[17:20:14] <dpc> And what's the way to crosscompile?
[17:20:45] <bstrie> dpc: I think there used to be a crosscompiling tutorial... somewhere
[17:21:42] *** Quits: sebcrozet (sebcrozet@moz-A855F6C0.w82-127.abo.wanadoo.fr) (Ping timeout)
[17:21:59] <dpc> Any help with this armv7l error? I'm compiling from sources on Arndale Board with Fedora for ARM installed.
[17:22:06] *** Quits: lenstr (lenstr@AF8EB999.6049B16A.85938D85.IP) (Client exited)
[17:22:17] *** Joins: sebcrozet (sebcrozet@moz-F96421F3.w80-13.abo.wanadoo.fr)
[17:22:22] <bstrie> not sure who here has experience with compiling for arm
[17:22:40] *** Quits: ecr (Thunderbir@moz-BBE3ABD.mv.mozilla.com) (Ping timeout)
[17:23:31] <kimundi> jdsanders: Lifetimes are basically just needed tor borrowed pointers, what else do you want to know? :)
[17:23:47] *** Joins: mihneadb_ (mihneadb@moz-BE33DA21.fw1.sfo1.mozilla.net)
[17:24:07] *** Quits: mihneadb (mihneadb@moz-BE33DA21.fw1.sfo1.mozilla.net) (Connection reset by peer)
[17:24:09] <cmr> dpc: in particular, I don't think rust has ever been built on an arm host.
[17:24:28] *** Joins: ofeldt- (ofeldt@moz-9BFD23F6.dip0.t-ipconnect.de)
[17:24:34] <bstrie> cmr: didn't jensnockert build on arduino?
[17:24:36] * kimundi want so someone to implement that, so that his pi has something to do for a few weeks
[17:24:43] <cmr> bstrie: host, not target.
[17:24:52] <dpc> Hmmm...
[17:25:02] <dpc> I've hacked the configure.sh ...
[17:25:18] *** Quits: ofeldt (ofeldt@moz-E3B4877F.dip0.t-ipconnect.de) (Ping timeout)
[17:25:32] <cmr> dpc: if llvm supports armv71, we should be able to too
[17:25:52] <dpc> That's an L at the end. Probably for low endian.
[17:27:30] <olsonjeffery> dpc: have you seen jensnockert's work w/ getting rust working on embedded systems?
[17:27:37] <olsonjeffery> eg https://github.com/jensnockert/dueboot
[17:27:50] *** Joins: bjz (brendanzab@B398BE78.F804C29E.D35A31DF.IP)
[17:27:57] *** Quits: bjz_ (brendanzab@B398BE78.F804C29E.D35A31DF.IP) (Connection reset by peer)
[17:28:21] <dpc> I'm aware of them, but haven't really get into it yet.
[17:28:40] <jdsanders> kimundi: I guess I was mostly curious about 'static, which I've seen in places - what it means, how "special" it is, whether there are other special 'blah things, etc.
[17:29:47] <olsonjeffery> dpc: jens appears to have a good amount of experience with embedded, is all im saying.. communicating with him is your best bet with getting some kind of "support"
[17:29:58] <cmr> jdsanders: it's the only one semantically special. It means "always alive"
[17:30:07] <cmr> the infinite lifetime, if you will
[17:30:17] *** Quits: Yurume (yurume@AC58A8CE.8A059B47.E313B915.IP) (Ping timeout)
[17:31:05] <bstrie> every time you store something in the 'static lifetime, it is transmitted to the master rust server where it a serialization is etched into a diamond which is then loaded into a rocket and shot into the vastness between galaxies
[17:31:11] <kimundi> right, 'static is the only semantically special
[17:31:17] *** Joins: ecr (Thunderbir@moz-BBE3ABD.mv.mozilla.com)
[17:32:08] <jdsanders> bstrie: lol
[17:32:11] <jdsanders> ok thanks
[17:32:11] <olsonjeffery> the 'static lifetime is guaranteed to be valid until the heat death of the universe or the process ending, whichever comes first
[17:32:23] <bstrie> haha
[17:32:31] <kimundi> 'self is syntactically special for legacy reasons, but works the same as any other lifetime
[17:32:44] <jdsanders> ah, yeah I was gonna ask about that one
[17:33:03] <jdsanders> where does the 'r idiom come from?
[17:33:06] <jdsanders> "Region"?
[17:33:09] <ecr> yep
[17:33:21] <ecr> at least that's what I always thought
[17:33:25] <bstrie> cmr: dammit, I would have proofread that message if I had known you were going to put it on reddit
[17:33:33] <bstrie> also, hi reddit
[17:33:38] <kimundi> 'r // r is a nice letter
[17:33:47] <kimundi> / I like r
[17:34:01] <kimundi> damnit irc
[17:34:06] <cmr> bstrie: :p
[17:34:22] <SiegeLord> I use 'l myself >.>
[17:34:37] * kimundi uses 'a ususally
[17:34:49] <cmr> I also use 'a, 'b
[17:34:53] <cmr> Never had to go past two :p
[17:34:53] <ecr> all uses of 'static have already been etched in the firmament of the heavens. every use is preordained.
[17:34:57] <olsonjeffery> 'r actually stands for "really-rust-doesn't-have-regions-which-is-why-we-call-them-lifetimes-it-confuses-some-academics
[17:35:00] <olsonjeffery> "
[17:35:00] * kimundi feares that'S something we need to add to code conventions too
[17:35:18] <cmr> kimundi: it's entirely invisible to the API though
[17:35:21] <cmr> so it doesn't matter
[17:35:31] <kimundi> cmr: true
[17:36:41] <kimundi> That reminds me. I haven't looked at the new doc tool, but are items transformed in a way that hides such implementation details?
[17:37:32] *** Joins: feduser (feduser@9813480F.BB9BFC11.650F25DA.IP)
[17:38:38] * ecr dies a little inside every time he uses a Cell to circumvent the lack of once fns
[17:38:42] <kimundi> for example, fn foo<KoolType, 'some_lifetime>(mut param: &'some_lifetime KoolType); is the same signature as fn foo<T, 'a>(&'a T); 
[17:38:53] <bstrie> kimundi: have to ask cmr
[17:39:13] *** Quits: azita (Azita@moz-BBE3ABD.mv.mozilla.com) (Quit: azita)
[17:39:35] *** Joins: Sindwiller (quassel@moz-743130B2.dynamic.hispeed.ch)
[17:39:58] *** Joins: jviereck (Adium@moz-72307FBB.customer.m-online.net)
[17:40:08] *** Quits: jviereck (Adium@moz-72307FBB.customer.m-online.net) (Client exited)
[17:40:23] *** Quits: robertknight (robertknig@moz-54528EE0.wby.mendeley.com) (Ping timeout)
[17:40:45] *** Joins: jviereck (Adium@moz-72307FBB.customer.m-online.net)
[17:41:13] *** Quits: six600110 (six600110@moz-2FA48202.neo.res.rr.com) (Quit: Leaving.)
[17:42:17] <ecr> hold on, how could param be mut, but be & instead of &mut?
[17:43:07] *** Quits: dwrensha (chatzilla@moz-AA82FBAF.hsd1.wa.comcast.net) (Ping timeout)
[17:43:40] *** Joins: six600110 (six600110@moz-2FA48202.neo.res.rr.com)
[17:43:53] <kimundi> ecr: that's the confusing thing
[17:43:58] *** Joins: jclements (jclements@moz-9C0ABCFC.wireless.calpoly.edu)
[17:44:02] <kimundi> the mut there has NOTHING to do wit the type signature
[17:44:15] *** Joins: dcoates (dcoates@moz-BE33DA21.fw1.sfo1.mozilla.net)
[17:44:18] <jclements> acrichto: ping
[17:44:32] <acrichto> jclements: pong
[17:44:34] <kimundi> fn foo(mut x) { ... use x } is sugar for fn foo(x) { let mut x = x; ...  use x}
[17:44:50] *** Joins: jstevans (Instantbir@A7D1887E.C325DF16.DDE5D3F6.IP)
[17:44:50] *** Quits: jstevans1 (Instantbir@A7D1887E.C325DF16.DDE5D3F6.IP) (Connection reset by peer)
[17:45:01] <kimundi> that is, only relevant dor the function body
[17:45:03] <ecr> kimundi: ah, right.
[17:45:09] <jclements> acrichto: I see comments from you in expand.rs about how printfln is going away; I'm still back on printf(fmt!(...)), so I thought I'd just ask you: what's current best practice for printf?
[17:45:11] *** Joins: jmgrosen (jmgrosen@moz-A3814C08.sd.sd.cox.net)
[17:45:12] <ecr> I'm not fully awake yet >.<
[17:45:23] <kimundi> so, having it appear in the docs would be confusing
[17:45:28] <ecr> agreed
[17:45:32] <acrichto> jclements: if you can, use print!/println!, they both use the format! syntax
[17:45:38] *** Joins: dave1629 (dave@DFE764FE.2F87036F.DDE5D3F6.IP)
[17:45:43] <kimundi> the problem is... that'S  true for any pattern
[17:45:46] <jclements> achrichto: got it! many thanks.
[17:45:56] <kimundi> fn foo((a, b) : (uint, uint))
[17:46:04] <dpc> I'm making progress. I might be the first person to actually natively use rust on Arm platform, can I? :)
[17:46:05] *** Joins: jstevans1 (Instantbir@F7929542.53D475A2.B7830B68.IP)
[17:46:20] <bstrie> do we not have native rust on android?
[17:46:26] <kimundi> maybe the convention for a doc tool should just be to strip any paramter names and onyl showing the types
[17:46:39] <kimundi> cmr: any comments? ^
[17:47:04] <ecr> kimundi: you're going to lose out on some self-documenting ability there though.
[17:47:06] <dpc> bstrie: Not sure. Wasn't it crosscompilation?
[17:47:20] *** Quits: jstevans (Instantbir@A7D1887E.C325DF16.DDE5D3F6.IP) (Ping timeout)
[17:47:44] <ecr> we could strip the mut out w/o losing information to get rid of that problem
[17:47:45] *** Quits: jstevans1 (Instantbir@F7929542.53D475A2.B7830B68.IP) (Ping timeout)
[17:47:46] *** Joins: jstevans (Instantbir@moz-7D1E410B.bootp.virginia.edu)
[17:48:08] *** Joins: jstevans1 (Instantbir@moz-8B4208F.bootp.virginia.edu)
[17:48:10] <bstrie> dpc: no idea, have to ask sanxiyn
[17:48:15] <ecr> I really don't know what the right answer is on showing pattern deconstruction or not
[17:48:25] <kimundi> ecr: ... The problem is there is no way to see if the naming scheme is intentional self documenting or arbitrary, and is also mixed with syntactic sugar for the function body
[17:49:09] <kimundi> just striping 'mut' alone there would only solve one special case
[17:49:26] *** Quits: jstevans (Instantbir@moz-7D1E410B.bootp.virginia.edu) (Ping timeout)
[17:49:29] *** Quits: carllerche (carllerche@6B070D22.7E6A0813.1428D117.IP) (Quit: carllerche)
[17:49:31] <kimundi> what about the future possible fn foo((mut a, mut b): (uint, uint)) for example?
[17:49:32] *** Joins: jstevans (Instantbir@moz-BAFC6C5.bootp.virginia.edu)
[17:49:36] *** Joins: eevee_ (eevee@moz-2CC451BF.evrt.wa.frontiernet.net)
[17:49:48] *** Quits: jstevans1 (Instantbir@moz-8B4208F.bootp.virginia.edu) (Ping timeout)
[17:50:13] *** Quits: eevee (eevee@moz-9A8E1439.evrt.wa.frontiernet.net) (Ping timeout)
[17:50:21] <ecr> kimundi: well we could just strip out the 'ref's and 'mut's, so that'd just be `fn foo((a, b): (uint, uint))'
[17:50:32] <kimundi> hm, maybe just strip elemnts from the pattern which convey no useful informations
[17:50:37] <kimundi> yeah
[17:51:04] <ecr> AFAIK, ref and mut are the only parts of patterns that aren't derived from types.
[17:51:18] <ecr> so any other pattern info is already visible via the type
[17:51:35] <kimundi> well
[17:51:47] <kimundi> fn foo((_, b) : (uint, uint))
[17:52:08] <ecr> oh right
[17:52:23] <Luqman> dpc: yep, i'm pretty sure anyone who's done anything with rust and arm has crosscompiled
[17:52:41] <kimundi> though I think that falls under "self documenting"
[17:52:55] <ecr> I almost want to say we should generalize that to 'fn foo<A>((_, b) : (A, uint))', but I don't think I'd win that battle
[17:53:23] <kimundi> ecr: well, it'S not allways possible
[17:54:03] <kimundi> if that for example is just some function that works with something like a struct Vector2D(uint, uint) internally or so
[17:54:29] *** Quits: jstevans (Instantbir@moz-BAFC6C5.bootp.virginia.edu) (Connection reset by peer)
[17:54:30] *** Joins: jstevans1 (Instantbir@moz-BAFC6C5.bootp.virginia.edu)
[17:54:42] <ecr> writing the function generically should still work though. the only instantiations will be for (uint, uint)
[17:55:12] <kimundi> well, no
[17:55:35] *** Quits: jmgrosen (jmgrosen@moz-A3814C08.sd.sd.cox.net) (Quit: jmgrosen)
[17:55:42] <kimundi> that function would mean "I can be called with any A type" but it needs to be uint, so it wouldn't work
[17:55:53] <ecr> you can't pass a Vector2D(uint, uint) to a function expecting (uint, uint) anyway.
[17:55:57] *** Quits: infynyxx (infynyxx@moz-E95B370B.nyc.res.rr.com) (Client exited)
[17:56:01] <ecr> so you'd have to extract it into a pair
[17:56:20] <kimundi> I'm imagining some internal function like Vector2D::from_tuple()
[17:56:30] *** Joins: azita (Azita@moz-BBE3ABD.mv.mozilla.com)
[17:56:41] <ecr> but that function CAN be called with any A type. it doesn't depend on the first argument at all
[17:56:56] <ecr> there's no reason why it needs to be restricted to uint
[17:57:08] <kimundi> fn tup_x((x, _) : (uint, uint))  Vector2D::from_tuple((x, 0))
[17:57:12] *** Quits: sinma (sinma@moz-6A11C47C.fbx.proxad.net) (Ping timeout)
[17:57:32] <kimundi> okay, I get what you mean
[17:57:33] *** Quits: victorporof (victorporo@9D964D4D.36D485C.2B3D3D4.IP) (Quit: victorporof)
[17:57:57] *** Joins: sinma (sinma@moz-6A11C47C.fbx.proxad.net)
[17:57:58] <ecr> ah, but that's really fn tup_x<A>((x, _) : (uint, A)) -> Vector2D
[17:58:55] <kimundi> fn tup_x((x, _) : (uint, uint)) { /* some code*/  let v = Vector2D::from_tuple((x, 0)); /* some other code*/  }
[17:59:09] <kimundi> (kinda mangled that one above)
[17:59:33] <kimundi> but yeah, in pronciple it could be gneric then
[17:59:37] <ecr> right
[17:59:47] <ecr> you can always restrict it if you like, but it's never necessary
[18:00:05] *** Quits: josh (josh@moz-348C4790.hsd1.mn.comcast.net) (Quit: josh)
[18:00:08] *** Quits: sinma (sinma@moz-6A11C47C.fbx.proxad.net) (Quit: Konversation terminated!)
[18:00:09] <kimundi> Seems too magical though :P Maybe make it an optional lint
[18:01:03] <ecr> maybe i've spent too much time in haskell land. seems pretty reasonable to me :)
[18:02:30] <ecr> I'm pretty sure an argument that's bound to _ can always be fully generic. It'd be pretty neat to make that syntactic sugar, but I doubt I'd get any support for that
[18:02:55] *** Quits: azita (Azita@moz-BBE3ABD.mv.mozilla.com) (Quit: azita)
[18:03:30] <cmr> kimundi: The `mut` is omitted in the frontend afaik, but parameter names aren't
[18:03:41] *** Quits: Axord (xord@moz-1B228827.lsanca.dsl-w.verizon.net) (Quit: I'm sure it's perfectly safe)
[18:03:46] <cmr> kimundi: it will be especially relevant once/if we have default parameters or the ability to specify parameters by name.
[18:04:21] *** Quits: indirect (indirect_m@moz-22FDA25B.hsd1.ca.comcast.net) (Ping timeout)
[18:05:01] *** Joins: Uther (Instantbir@moz-1B244B05.hfc.dyn.abo.bbox.fr)
[18:05:13] <kimundi> true, in those cases you need to show names
[18:06:12] *** Quits: tjc (tjc@moz-6EB4E533.dsl.tsoft.com) (Quit: Places to go, people to annoy)
[18:06:18] *** Joins: azita (Azita@moz-BBE3ABD.mv.mozilla.com)
[18:07:03] *** Quits: brson (brson@moz-BBE3ABD.mv.mozilla.com) (Ping timeout)
[18:08:02] *** Joins: indirect (indirect_m@moz-22FDA25B.hsd1.ca.comcast.net)
[18:08:30] *** Joins: josh (josh@moz-348C4790.hsd1.mn.comcast.net)
[18:08:38] *** Joins: brson (brson@moz-BBE3ABD.mv.mozilla.com)
[18:08:38] *** ChanServ sets mode: +ao brson brson
[18:09:22] *** Quits: valenting (Thunderbir@8758046C.84D5EFD5.FB866788.IP) (Ping timeout)
[18:11:26] *** Joins: dwrensha (chatzilla@moz-AA82FBAF.hsd1.wa.comcast.net)
[18:12:12] <jdsanders> cmr: is default parameters on the roadmap?
[18:12:37] *** Quits: tav (tav@moz-505FBB11.range86-160.btcentralplus.com) (Connection reset by peer)
[18:12:39] *** Joins: tav (tav@moz-505FBB11.range86-160.btcentralplus.com)
[18:12:47] <doomlord> hehe
[18:13:53] <cmr> jdsanders: it hasn't been rejected and a bunch of people want it
[18:14:12] <cmr> It's been pushed off until probably post-1.0 because it's a backwards compatible change
[18:14:24] <cmr> but doomlord does have a patch that makes them parse
[18:14:31] <jdsanders> neat
[18:14:45] <doomlord> only added to ast, i dont understand the rest enough to implement them
[18:15:02] <doomlord> how they'd interact with typechecking/inference..
[18:15:18] <cmr> yeah
[18:15:33] <cmr> it definitely needs to be pushed off until the constant expression story has been decided.
[18:16:14] <doomlord> i thought it might be possible to do them as some ast manipulation 'hack' but i'm sure that would create unusual bugs
[18:16:31] *** Joins: Axord (xord@moz-1B228827.lsanca.dsl-w.verizon.net)
[18:16:50] *** Quits: squiddy_ (squiddy@moz-E4F84460.adsl.alicedsl.de) (Input/output error)
[18:19:46] *** Quits: josh (josh@moz-348C4790.hsd1.mn.comcast.net) (Quit: josh)
[18:22:21] *** Quits: jstevans1 (Instantbir@moz-BAFC6C5.bootp.virginia.edu) (Ping timeout)
[18:22:36] *** Quits: rusti (rusti@moz-54F7FD49.cpe.net.cable.rogers.com) (Client exited)
[18:23:43] *** Quits: eholk (eholk@moz-F70D5031.hsd1.in.comcast.net) (Quit: eholk)
[18:24:45] *** Joins: josh (josh@moz-348C4790.hsd1.mn.comcast.net)
[18:25:02] *** Quits: jviereck (Adium@moz-72307FBB.customer.m-online.net) (Quit: Leaving.)
[18:27:05] *** Quits: ktos (ktos@moz-D3D6BE18.swidnica.mm.pl) (Ping timeout)
[18:27:44] *** Joins: tjc (tjc@moz-BBE3ABD.mv.mozilla.com)
[18:27:45] *** ChanServ sets mode: +o tjc
[18:29:19] *** Joins: carllerche (carllerche@1E2EB9E3.186539A3.965084DF.IP)
[18:30:52] *** Joins: eatkinson (eatkinson@moz-DC7CD72F.airbears2.berkeley.edu)
[18:31:20] *** Quits: carllerche (carllerche@1E2EB9E3.186539A3.965084DF.IP) (Quit: carllerche)
[18:31:30] *** Joins: carllerche (carllerche@1E2EB9E3.186539A3.965084DF.IP)
[18:31:43] *** Quits: ozten (ozten@19BD73A1.5D8BCA3A.A0C1B52F.IP) (Quit: ozten)
[18:32:05] *** Quits: huseby (huseby@19BD73A1.5D8BCA3A.A0C1B52F.IP) (Quit: Leaving)
[18:33:11] *** Quits: dwrensha (chatzilla@moz-AA82FBAF.hsd1.wa.comcast.net) (Quit: ChatZilla 0.9.90.1 [Firefox 23.0.1/20130814063812])
[18:33:56] *** Quits: sankha93 (Instantbir@7061CD01.D6BD0D91.22D41759.IP) (Ping timeout)
[18:34:52] *** Joins: sankha93 (Instantbir@7061CD01.D6BD0D91.22D41759.IP)
[18:35:14] *** mihneadb_ is now known as mihneadb
[18:35:20] <Palmik> Hi guys. What am I doing wrong here: http://codepad.org/jotvnvwx (I'm getting "error: cannot move out of dereference of & pointer"). Any ideas?
[18:35:21] *** Quits: RMF (RMF@moz-BFEC31A2.dsl.telepac.pt) (Quit: Textual IRC Client: www.textualapp.com)
[18:36:01] *** Quits: bytbox (s@moz-DC83764A.washdc.fios.verizon.net) (Ping timeout)
[18:36:54] *** Joins: fabiand (fabiand@moz-A588C99B.adsl.alicedsl.de)
[18:36:57] *** Joins: bytbox (s@moz-DC83764A.washdc.fios.verizon.net)
[18:37:00] <tjc> Palmik: When you call target.get().into_owned(), the method call (to into_owned) does a thing called "auto-dereferencing"
[18:37:13] <tjc> So, get() gives you a &'x ~strâ€¦ but then, when you call into_owned on it
[18:37:23] <tjc> implicitly, it's the same as calling into_owned on *(target.get())
[18:37:40] <tjc> since Target is non-copyable, when you dereference a pointer to it, you do a more rather than a copy
[18:37:49] <tjc> but, the &'x ~str point is borrowed, so you don't have the right to do that
[18:38:05] <kmc> I think the getter should return &'x str and not &'x ~str
[18:38:05] <tjc> one way to get around it is to write .get().clone().into_owned(); that does introduce an extra copy, but if you're just experimenting, it might not matter
[18:38:11] <tjc> that's another way, yeah
[18:38:17] *** Joins: jstevans (Instantbir@moz-BAFC6C5.bootp.virginia.edu)
[18:39:26] *** Quits: sebcrozet (sebcrozet@moz-F96421F3.w80-13.abo.wanadoo.fr) (Ping timeout)
[18:41:07] <Palmik> kmc: but is not self.un of type &~str?
[18:41:31] *** Quits: tav (tav@moz-505FBB11.range86-160.btcentralplus.com) (Connection reset by peer)
[18:41:33] <kimundi> Palmik: &(self.un) is a &~str
[18:41:36] <tjc> Palmik: &'x ~str is different from &'x str
[18:41:39] <kimundi> self.un is a ~str
[18:41:44] <tjc> Palmik: the first one is a pointer to a string allocated on the exchange heap
[18:41:45] *** Joins: ktos (ktos@moz-D3D6BE18.swidnica.mm.pl)
[18:41:55] <tjc> ths second one is a string, rather than a pointer than a string, that is borrowed and has lifetime 'x
[18:42:00] *** Joins: sebcrozet (sebcrozet@moz-7FB6C00B.w193-252.abo.wanadoo.fr)
[18:42:02] <kimundi> self.un is also borrowable to &str
[18:42:10] <tjc> in C, the first one woudl be **char and the second one would be *char
[18:42:16] <kmc> &~str is a pointer to a pointer to a string, innit?
[18:42:19] <Palmik> kimundi: is not that weird? The geet compiles, so surely it's &~str?
[18:42:40] <kimundi> Palmik: because you added the & in front of self.un
[18:42:48] <kmc> anyway returning &~Foo from an accessor is not idiomatic
[18:42:51] <Palmik> Oh, I totally missed that. :)
[18:43:00] <kmc> you don't need to expose the fact that you own the value
[18:43:11] <kimundi> remove that, and you can return &str
[18:43:12] <kmc> and it's an extra layer of indirection
[18:43:51] *** Quits: MrFahrenheit (RageOfThou@3FEF494C.29C984D5.783DEDCA.IP) (Ping timeout)
[18:44:53] *** Joins: MrFahrenheit (RageOfThou@3FEF494C.29C984D5.783DEDCA.IP)
[18:45:07] *** Quits: Larry (larryfox@moz-343B6F0C.nyc.biz.rr.com) (Quit: My MacBook Pro has gone to sleep. ZZZzzzâ€¦)
[18:45:18] <kimundi> rusti: ("foo".to_owned(), "foo".into_owned())
[18:45:19] <kmc> I'm failing to write the code to actually borrow ~str as &str, though :(
[18:45:38] <cmr> &*foo
[18:45:42] <kimundi> damn, rusti is not here
[18:45:42] <olsonjeffery> rusti: (~"foo").slice()
[18:45:46] <cmr> that too
[18:45:55] <engla> as_slice() is the explicit way kmc 
[18:46:00] <kimundi> self.un.as_slice()
[18:46:02] <kmc> ah yep
[18:46:10] <kmc> is there an implicit way?
[18:46:13] *** Joins: nrc (nrc@7BE24E90.A5032A01.3CFC199D.IP)
[18:46:17] *** Joins: aeqwa (aeqwa@moz-A8FE6EB1.dsl.tropolys.de)
[18:46:31] <kimundi> kmc: in principle, just using a ~str where the type should be &str
[18:46:36] <kimundi> it auto borrows
[18:46:38] <engla> a function call
[18:46:40] <kmc> doesn't work for me
[18:46:49] <olsonjeffery> kimundi: it would borrow to a &str
[18:47:00] <engla> probably only works for function calls
[18:47:03] <olsonjeffery> kimundi: it would borrow to a &~str
[18:47:04] <olsonjeffery> i mean
[18:47:08] <kimundi> yes, that's what kmc meant, no?
[18:47:17] <kimundi> no, hu?
[18:47:28] <kimundi> I'm confused about what we're talkinjg right now :)
[18:47:36] *** Quits: eatkinson (eatkinson@moz-DC7CD72F.airbears2.berkeley.edu) (Quit: eatkinson)
[18:48:07] <kmc> no I was talking about borrowing ~str as &str
[18:48:23] <kmc> because that's what you'd typically want for this kind of data structure accessor, right?
[18:48:36] <kimundi> fn foo(&'a self) -> &'a str { self.un  } // Does that work?
[18:48:47] <kmc> no
[18:48:50] <kimundi> if self.un: ~str
[18:49:01] <kimundi> okay, then you need as_slice()
[18:49:09] <kmc> okay, seems reasonable to me
[18:49:16] <kmc> as I'm not a big fan of implicit conversions anyway
[18:49:24] <Palmik> https://github.com/mozilla/rust/blob/master/src/libstd/str.rs#L1268
[18:49:51] <kimundi> Palmik: yeah, it works in a let
[18:50:04] <Palmik> You have to ask for the explicit lifetime when dereferncing it seems.
[18:50:17] <kimundi> fn foo(&'a self) -> &'a str { let r: &'a str = self.un; r  }
[18:50:31] <kimundi> or even just 
[18:50:34] <kimundi> fn foo(&'a self) -> &'a str { let r: &str = self.un; r  }
[18:51:23] *** Joins: eatkinson (eatkinson@moz-DC7CD72F.airbears2.berkeley.edu)
[18:51:27] *** Joins: tav (tav@moz-505FBB11.range86-160.btcentralplus.com)
[18:52:55] <Palmik> Hmm, now using Map::get is awkward.
[18:53:06] *** Joins: infynyxx (infynyxx@DB780A29.749BA1D.DCC373F0.IP)
[18:53:07] *** Quits: tav (tav@moz-505FBB11.range86-160.btcentralplus.com) (Ping timeout)
[18:53:29] <engla> tjc: I assume you'll revisit this issue at some point, but it has all wrong tags  https://github.com/mozilla/rust/issues/8883  (it's about the design of ToJson and Encodable, not rustc bugs)
[18:54:12] *** Quits: infynyxx (infynyxx@DB780A29.749BA1D.DCC373F0.IP) (Client exited)
[18:54:14] *** Joins: infynyxx (infynyxx@DB780A29.749BA1D.DCC373F0.IP)
[18:54:23] <tjc> engla: okâ€¦ I originally assumed this was an issue the compiler should catch, but I don't understand json/encodable intimately.
[18:55:57] <engla> the original confusion is that ToJson is only implemented for ~str keys in TreeMap, but in this case TreeMap is encoded using Encodable which is implemented for all encodable K,V: TreeMap<K, V>
[18:56:02] <Palmik> So, is there a way to make data.get(&target.get().into_owned()) better? Will into_owned() actually avoid the copy in this case?
[18:56:03] <engla> the result is invalid json (non-string keys)
[18:57:13] <kimundi> Palmik: into_owned() will allways copy because you call it on a &str
[18:57:22] <tjc> Palmik: in general, you can't turn a borrowed pointer into an owned pointer without copying
[18:57:31] *** Joins: FrozenCow (FrozenCow@moz-B2DF4929.chello.nl)
[18:57:33] <kimundi> Palmik: It will only not-copy if you call it on a ~str
[18:57:35] <tjc> and you can't move a value out of a hash map without moving out of the entire hash map
[18:57:37] *** Joins: lenstr (lenstr@AF8EB999.6049B16A.85938D85.IP)
[18:57:42] *** Joins: victorporof (victorporo@9D964D4D.36D485C.2B3D3D4.IP)
[18:58:33] <kimundi> don'T we have a Equiv trait that get's used by hashmap to allow finding something with a &str?
[18:58:51] <kimundi> wouldn'twork for insert though...
[18:59:11] <dpc> Can rust work without any alloc?
[18:59:48] <dpc> I'm looking at zero.rs and malloc/free pair will be a problem...
[19:00:26] <tjc> dpc: the goal is that you shoudl be able to write useful code without heap allocation
[19:00:52] <kimundi> Palmik: okay
[19:01:12] <dpc> tjc: The goal of current Rust language evolution?
[19:01:13] <kimundi> Palmik: Instead of data.get(&target.get().into_owned())
[19:01:17] <tjc> dpc: Yes
[19:01:37] *** Quits: sankha93 (Instantbir@7061CD01.D6BD0D91.22D41759.IP) (Ping timeout)
[19:01:38] <kimundi> Palmik: Use data.find_equiv(target.get()).unwrap()
[19:01:47] <dpc> tjc: How far is Rust from being usable with no malloc/free?
[19:02:01] *** Joins: sankha93 (Instantbir@7061CD01.D6BD0D91.22D41759.IP)
[19:02:07] <tjc> dpc: right now, the main issue that I know of is the standard library
[19:02:09] <kimundi> find works like gte, except gives you an Option value on wether it was found or not
[19:02:16] <tjc> there are still places where you have to allocate in order to use basic library functions
[19:02:25] <tjc> that's something that we're working on
[19:02:36] <dpc> tjc: What about closures and possibly other stuff that might require heap?
[19:02:48] <tjc> dpc: closures don't have to be on the heap; &fn is a stack closure
[19:02:52] <kimundi> find_equiv allows you to use other types for specifying the key, it has been explicitly introduced to allow finding with a &str key in a ~str Map
[19:03:00] *** Quits: fabiand (fabiand@moz-A588C99B.adsl.alicedsl.de) (Quit: Verlassend)
[19:03:08] <kmc> could &fn also be a borrowed ~fn or no?
[19:03:15] <dpc> tjc: So can I not use standard library at all?
[19:03:19] <ecr> kmc: I think so
[19:03:22] <engla> yes kmc 
[19:03:24] <Palmik> kimundi: sorry, I meant data.find(...). Anyway, I can not find find_equiv
[19:03:34] <tjc> dpc: you can use it, but you have to look at the types of functions you're calling and look for things that use ~ and @
[19:03:45] <tjc> dpc: there's also a lint mode you can enable that will make the compiler forbid you from allocating
[19:03:59] <kmc> oh really, that's cool
[19:04:00] *** Quits: victorporof (victorporo@9D964D4D.36D485C.2B3D3D4.IP) (Ping timeout)
[19:04:06] <kimundi> Palmik: https://github.com/mozilla/rust/blob/master/src/libstd/hashmap.rs#L439
[19:04:30] <dpc> tjc: Seems to me that it would be hard to write anything without ~ or @. Can I overcome this by `unsafe`?
[19:04:43] <ecr> kmc: &fn is basically just a function pointer
[19:04:52] *** Joins: azakai (alon@moz-BBE3ABD.mv.mozilla.com)
[19:04:57] <tjc> dpc: It would be hard, yes. Not sure where `unsafe` would help...
[19:05:02] <brson> bors's queue is empty
[19:05:03] <kimundi> ecr: It's function pointer + environment pointer
[19:05:06] <tjc> I guess if you wanted to manage your own memory using code in an `unsafe` block, you could
[19:05:20] *** Quits: infynyxx (infynyxx@DB780A29.749BA1D.DCC373F0.IP) (Client exited)
[19:05:24] *** Joins: infynyxx (infynyxx@DB780A29.749BA1D.DCC373F0.IP)
[19:05:29] <ecr> kimundi: yeah, I was about to elaborate on that. ~fn vs @fn vs &'r fn
[19:05:36] <Palmik> kimundi: now I get "mismatched types: expected `&<V5>` but found `&str`"
[19:05:37] <kmc> it's hard to write anything in C without malloc, too ;)
[19:05:39] <engla> dpc: you can reimplement ~T with malloc/free
[19:05:43] <kmc> (or your own allocator)
[19:05:43] <dpc> tjc: I'm wondering how hard would it be to provide a basic Rust runtime inside of a custom kernel...
[19:05:54] <kmc> but people do it for embedded stuff, and you could do it in Rust too
[19:06:01] <kimundi> Palmik: hm, could you paste you're current code?
[19:06:06] <kmc> dpc: to have ~ you don't really need a full runtime, just any allocator
[19:06:12] <tjc> dpc: AIUI, the hardest thing that has to be in the runtime is the scheduler
[19:06:13] <dpc> kmc: Actually, I produce a lot of code without a single malloc.
[19:06:19] <dpc> (C code)
[19:06:35] *** Joins: Larry (larryfox@moz-343B6F0C.nyc.biz.rr.com)
[19:06:47] <doomlord> embedded?
[19:06:52] <dpc> Yeap.
[19:06:57] <ecr> brson: I'm almost done with the multi-threaded I/O tests. just need to rebase and run tests, so bors should have something to do this afternoon
[19:07:00] <kmc> kernels do lots of heap allocation typically
[19:07:27] <dpc> Big OSes like Linux, yes. Small ones, not so much.
[19:07:32] <kmc> it wouldn't be wrong to expose your kernel's internal allocator for use by Rust's ~ boxes
[19:07:37] <kmc> mm
[19:07:40] <olsonjeffery> ecr: is your PR just additional tests.. or runtime to support mt io?
[19:07:55] <olsonjeffery> runtime work to support, even
[19:08:09] <ecr> olsonjeffery: it's just changing uses of 'run_in_newsched_task' into 'run_in_mt_newsched_task' in rt::io and rt::uv
[19:08:31] <ecr> so we can start get multithreaded coverage in I/O tests
[19:08:37] <kimundi> Palmik: Ah, right, you still need the additional &: data.find_equiv(&target.get()).unwrap()
[19:08:37] <dpc> kmc: Yes. But in areas where I work, if one needs allocation of any kind, it's usually from pools of fixed-size elements etc.
[19:08:39] <olsonjeffery> gotcha.
[19:09:10] <kimundi> Palmik: that will pass a & &str to find_equiv , which should hopefully match the signature finally
[19:09:16] <dpc> Would that work with Rust? I'm pretty sure it will require any-size allocation.
[19:09:28] *** Quits: igl (igl@moz-8851FCBB.adsl.alicedsl.de) (Ping timeout)
[19:09:39] <ecr> olsonjeffery: I had to get that TCP listener/acceptor split first so I could ensure the server was ready before client tasks attempted to connect.
[19:09:58] <ecr> and then I mostly just added oneshot channels in some places
[19:10:24] <Palmik> kimundi: http://codepad.org/pB2vquer HeaderFiledName is just like Target.
[19:10:29] <mm> <@kmc> mm - hello ;)
[19:10:35] <kmc> haha
[19:10:36] <jdsanders> dpc: not sure if this is helpful to you, but in master you don't even need zero.rs - check out https://github.com/mozilla/rust/blob/master/src/test/run-pass/smallest-hello-world.rs
[19:10:49] *** Joins: ghrust (ghrust@C8693FCB.6A2AE50.F3114085.IP)
[19:10:49] <ghrust> 01[13rust01] 15bors 04force-pushed 06auto from 144c62b52 to 14510c4d8: 02http://git.io/N3iJvQ
[19:10:49] *** Parts: ghrust (ghrust@C8693FCB.6A2AE50.F3114085.IP) ()
[19:10:49] *** Joins: ghrust (ghrust@79968228.6A2AE50.F3114085.IP)
[19:10:50] <ghrust> 01[13rust01] 15bors pushed 2 new commits to 06auto: 02http://git.io/puP-Rg
[19:10:50] <ghrust> 13rust/06auto 14da042ce 15Chris Morgan: Implement Stream automatically for Reader + Writer...
[19:10:50] <ghrust> 13rust/06auto 14d84a7b5 15bors: auto merge of #8984 : chris-morgan/rust/auto-stream-impl, r=huonw...
[19:10:50] *** Parts: ghrust (ghrust@79968228.6A2AE50.F3114085.IP) ()
[19:10:53] *** Joins: igl (igl@moz-79D9853B.adsl.alicedsl.de)
[19:11:03] <kmc> dpc: I suppose you would make your own smart pointer type which is like ~ but for these memory pools
[19:11:07] *** Quits: jstevans (Instantbir@moz-BAFC6C5.bootp.virginia.edu) (Ping timeout)
[19:11:16] <kmc> and probably a trait so that you can wire up MyPtr<T> to a pool specifically for T
[19:11:26] <kimundi> Palmik: Try self.data.find_equiv(name.get()); :)
[19:11:30] <kimundi> err
[19:11:34] <kimundi> Palmik: Try self.data.find_equiv(&name.get()); :)
[19:11:38] <Palmik> Yes, it works with the additionqal &
[19:11:44] <kimundi> good
[19:11:56] <Palmik> Why is not find designed in the same way?
[19:12:31] <Palmik> BTW, so far most of my problems I run into seem to be caused by the disconnect in how Rust handles str and all other types.
[19:13:02] <Palmik> The Map trait is a good example. You all said that &~str is an antipattern, but that is exactly what find on Map<~str, ~str> expects.
[19:13:05] <kimundi> Palmik: find looks for keys of the exact type, find_equiv looks for keys that implement Equiv
[19:13:25] *** Joins: infynyxx_ (infynyxx@DB780A29.749BA1D.DCC373F0.IP)
[19:13:35] <kimundi> Palmik: The problem is that we currently are not able to have a bare 'str' type
[19:13:44] *** Quits: infynyxx (infynyxx@DB780A29.749BA1D.DCC373F0.IP) (Ping timeout)
[19:14:09] <kimundi> Palmik: If we could, many of those problems would cease to exist
[19:14:28] <kimundi> Palmik: But not all, du to the reson why we don'T have a 'str' type right now :)
[19:14:45] <Palmik> Another problem (it seems to me) is with 'newtype' wrappers of str... is makes sennse that they wrap ~str, the problem is when you want to return such a wrapper without copying... you are probably forced to return &Wrapper
[19:15:05] <kimundi> right, same kind of problem
[19:15:08] <olsonjeffery> huh. second time my system has hung during an llvm rebuild.
[19:15:19] <kimundi> you can't define a newtype for str, onyl for ~str or &str etc
[19:15:33] <Palmik> kimundi: is there an issua about this where I could learn more about why bare 'str' is not possible?
[19:15:36] <kimundi> so, you basically need to have duplicate wrappers for both
[19:15:39] <ecr> newtype wrappers don't have runtime overhead (or at least they shouldn't). it's just for type system purposes
[19:15:53] <kimundi> Palmik: Yes, but I can also just explain in short :)
[19:16:02] <Palmik> ecr: even if I return &Wrapper?
[19:16:13] <Palmik> kimundi: I would be interested in both. :)
[19:16:34] <ecr> just to be clear, by newtype I mean "struct NewType(OldType)"
[19:16:56] <kimundi> Palmik: The reason thagt we don't have s'str' is the same why we don't have '[T]' - both types do not have a compile time defined size
[19:17:01] <ecr> NewType will all disappear at runtime
[19:17:19] <ecr> so &NewType would just be an &OldType at runtime
[19:17:39] <Palmik> ecr: so if it wraps ~str, it would be &~str, yes?
[19:18:14] <Palmik> kimundi: yes, sure... other languages solve this by having a dedicated type for dynamic arrays.
[19:18:16] <ecr> I'm not sure. It may get collapsed to &str
[19:18:24] <Palmik> ecr: OK, thanks. :)
[19:18:58] <kimundi> Palmik: A str would be a '[u8]', so I'm gonna keep talking about [T] now: You don't know the size of a [T] at compile time. You can solve that by introducing a level of indirection: make, eg a DynArray type that stores a len field and a pointer to the data
[19:19:44] <ecr> while we can completely eliminate newtypes at runtime, I'm not sure if we actually do at the moment. Haskell's optimized it away most of the time for ages, and they just recently figured out how to do it all the time, but our type system isn't as sophisticated as theirs
[19:20:24] <kimundi> Palmik: In rust, we basically pushed that out to the pointer types: a ~[T] is a pointer to some point in memory where the size N is stored, directly followed by the N elemnts of it
[19:21:00] *** Parts: azita (Azita@moz-BBE3ABD.mv.mozilla.com) ()
[19:21:11] <kimundi> Palmik: A &[T] stores it directly in the pointer type itself: A &[T] is a tuple of (pointer to N T's, size N)
[19:22:10] <kimundi> Palmik: The problem with a unsized type like [T] or str is that you can't store it anywhere: the compiler wouldn't knwo how many bytes tor eserve for it
[19:22:24] <kimundi> you couldn't have a function foo(t: str)
[19:22:43] <kimundi> or a struct Bar { data: str }
[19:22:56] <Palmik> Yes, I understand that. But as it is right now I would probably rather have dyn_str, which would avoid these issues (since it would be always on the heap).
[19:23:11] <kimundi> Palmik: but that IS ~str :)
[19:23:53] *** Joins: azita (Azita@moz-BBE3ABD.mv.mozilla.com)
[19:24:23] <Palmik> Hmm, yes. Now that I think about it &~str is no worse than std::string&.
[19:24:31] <kimundi> right
[19:25:11] <kimundi> It's only confusing, because a ~str and &str is not a ~T or &T with T == str, but specific types
[19:25:37] <Palmik> Yep.
[19:26:16] <Palmik> I guess the compiler could, in many cases if not all, treat &~str like ~str, avoiding the one level of indirection.
[19:26:18] <engla> In reality &str is awesome because it's a copyless view into a string (even if the string is mutable)
[19:26:36] <kimundi> Palmik: not really
[19:27:08] *** Joins: mindcat (root@4D722E6D.DC005319.857BDFA9.IP)
[19:27:24] <kimundi> Palmik: a &~str is like any &T: You have read-only access to the type, here ~str. 
[19:27:48] <Palmik> Yes, so?
[19:27:50] <kimundi> Palmik: And you can't move ~str out of the & reference like any other type with a destructor
[19:28:04] *** Quits: eatkinson (eatkinson@moz-DC7CD72F.airbears2.berkeley.edu) (Ping timeout)
[19:28:04] <ecr> kimundi: I think Palmik just meant optimizing away the extra indirection in codegen.
[19:28:11] <kimundi> So a &~str is not the same as a ~str
[19:28:25] <Palmik> Yes, I did not mean direct replacement.
[19:28:27] <kimundi> Well, that is llvm optimsation magic that happens anyway :)
[19:28:35] <kimundi> Okay, sorry :)
[19:29:07] <Palmik> No problem. Thanks a lot for your time.
[19:29:15] *** Joins: eatkinson (eatkinson@moz-DC7CD72F.airbears2.berkeley.edu)
[19:31:19] *** Joins: ozten (ozten@19BD73A1.5D8BCA3A.A0C1B52F.IP)
[19:32:17] <mindcat> rusti: "I am come back! with my phone!".as_slice().slice_from(23)
[19:33:01] <kimundi> rusti: "Say nothing if you're not in this channel!"
[19:33:36] <mindcat> oh no!
[19:33:56] <kimundi> mindcat: Anything you want to ask while rusti's not here? :)
[19:34:00] *** Quits: aeqwa (aeqwa@moz-A8FE6EB1.dsl.tropolys.de) (Quit: Lost terminal)
[19:34:30] <mindcat> KindOne: No. :(
[19:35:18] <kimundi> 'kay :)
[19:35:49] * ecr had to rebuild LLVM in both 'make' and 'make check'
[19:35:52] * ecr cries
[19:36:14] <kimundi> :(
[19:36:28] *** Quits: six600110 (six600110@moz-2FA48202.neo.res.rr.com) (Ping timeout)
[19:37:29] *** Quits: azita (Azita@moz-BBE3ABD.mv.mozilla.com) (Quit: azita)
[19:37:54] <mindcat> how count a string char?
[19:38:30] <engla> the number of chars in a string? .char_len()
[19:38:39] *** Joins: huseby (huseby@19BD73A1.5D8BCA3A.A0C1B52F.IP)
[19:38:58] <engla> but it's not necessarily useful
[19:39:30] *** Quits: huseby (huseby@19BD73A1.5D8BCA3A.A0C1B52F.IP) (Max SendQ exceeded)
[19:39:31] *** Quits: eatkinson (eatkinson@moz-DC7CD72F.airbears2.berkeley.edu) (Quit: eatkinson)
[19:39:56] *** Joins: huseby (huseby@19BD73A1.5D8BCA3A.A0C1B52F.IP)
[19:40:22] <kimundi> or "string".iter().count() or so
[19:40:24] <mindcat> engla: well, rusti is not here :(
[19:41:09] <engla> ah, the number of 'a' in a string is   "stringaaa".iter().count(|c| c == 'a')
[19:41:13] *** Joins: jmgrosen (jmgrosen@moz-A3814C08.sd.sd.cox.net)
[19:41:46] *** Joins: rusti (rusti@moz-61B073BC.cpe.net.cable.rogers.com)
[19:42:45] <dpc> rusti: "stringaaa".iter().count(|c| c == 'a')
[19:42:49] -rusti- 3u
[19:43:08] <mindcat> ...What?
[19:43:22] <jdm> error: failed to find an implementation of trait std::cmp::Eq for extern "C" unsafe fn(*std::libc::types::common::c95::c_void, js::jsapi::JSHandleObject, js::jsapi::JSHandleId, i32, js::jsapi::JSMutableHandleValue) -> i32
[19:43:26] <jdm> :(
[19:43:41] <mindcat> rusti: "I am come back! with my phone!".as_slice().slice_from(23)
[19:43:46] -rusti- pastebinned 15 lines of output: http://ix.io/7Sf
[19:44:38] *** Quits: maxli (maxli@moz-6EADA619.cpe.net.cable.rogers.com) (Quit: Leaving.)
[19:44:51] <kimundi> rusti: "foooooooooooo".slice_to(4)
[19:44:52] -rusti- "fooo"
[19:44:55] *** Joins: maxli (maxli@moz-6EADA619.cpe.net.cable.rogers.com)
[19:44:58] <kimundi> rusti: "foooooooooooo".slice_to(4).as_slice()
[19:45:01] -rusti- pastebinned 15 lines of output: http://ix.io/7Sg
[19:45:09] <mindcat> rusti: "I am come back! with my phone!".slice_from(23)
[19:45:10] -rusti- " phone!"
[19:45:17] <kimundi> mindcat: It's a temporary lifetym problem
[19:45:19] *** Quits: maxli (maxli@moz-6EADA619.cpe.net.cable.rogers.com) (Max SendQ exceeded)
[19:45:34] <kimundi> rusti: let s = "foooooooooooo".slice_to(4); s.as_slice()
[19:45:37] *** Joins: azita (Azita@moz-BBE3ABD.mv.mozilla.com)
[19:45:39] -rusti- pastebinned 16 lines of output: http://ix.io/7Sh
[19:46:04] <kimundi> rusti: let s: &'static str = "foooooooooooo".slice_to(4); s.as_slice()
[19:46:06] -rusti- pastebinned 16 lines of output: http://ix.io/7Si
[19:46:32] <mindcat> rusti: let s = "fgjj".as_slice();s
[19:46:35] -rusti- pastebinned 15 lines of output: http://ix.io/7Sj
[19:47:59] <jdm> I miss having a simple symbol name to break on for task failure in gdb
[19:48:08] <jdm> I always have to bust out nm and grep
[19:48:18] <Luqman> jdm: does rust_begin_unwind not work?
[19:48:25] <kimundi> jdm: there still is, it just got an differnt name afaik
[19:48:25] <jdm> that sounds promising
[19:48:44] <jdm> and it is
[19:48:45] <jdm> thanks
[19:49:21] *** Joins: jgilbert (jgilbert@moz-7B0110AD.mv.mozilla.com)
[19:50:01] <mindcat> rusti: let s = "I am come back! with my phone!";s.slice_from(s.char_len() - 6 as uint)
[19:50:01] -rusti- "phone!"
[19:50:34] <mindcat> yea, that is I want.
[19:50:52] <nmatsakis> anybody besides dbaupp know much about deriving -- I'm having the problem that it is sharing AST trees (should be a tree, not a DAG...) and I'm trying to figure out the easiest way to fix it
[19:50:57] *** Quits: jgilbert (jgilbert@moz-7B0110AD.mv.mozilla.com) (Max SendQ exceeded)
[19:51:07] <nmatsakis> I'm wondering if it would make sense to just fold the AST after expansion and renumber everything
[19:51:13] <kimundi> mindcat: that's wrong
[19:51:22] *** Joins: aeqwa (aeqwa@moz-A8FE6EB1.dsl.tropolys.de)
[19:51:27] <nmatsakis> maybe I can just *try* it, it would eliminate a swatch of problems in both the macro expander and deriving, and give us continuous numbers...
[19:51:45] <mindcat> kimundi: then tell me right way
[19:51:58] *** Joins: jgilbert (jgilbert@moz-7B0110AD.mv.mozilla.com)
[19:52:21] <kimundi> mindcat: char_len() counts the number of unicode code points, most functions on strings that use indices use byte indices though
[19:52:33] <kimundi> rusti: let s = "I am come back! with my phone!";s.slice_from(s.len() - 6 as uint)
[19:52:34] -rusti- "phone!"
[19:52:46] *** Joins: six600110 (six600110@moz-2FA48202.neo.res.rr.com)
[19:53:12] <kimundi> rusti: let s = "I am come back! with my sÃ¼per phone!";s.slice_from(s.len() - 6 as uint)
[19:53:12] -rusti- "phone!"
[19:53:19] <kimundi> rusti: let s = "I am come back! with my sÃ¼per phone!";s.slice_from(s.char_len() - 6 as uint)
[19:53:20] -rusti- " phone!"
[19:53:22] <engla> all string methods use byte indices except a single one that uses codepoint "indices" --   "".slice_chars(begin, end)
[19:53:29] <mindcat> rusti: let s = "é¾™ï¼Œä½ å¥½å—";s.slice_from(s.char_len() - 6 as uint)
[19:53:29] -rusti- task <unnamed> failed at 'index out of bounds: the len is 15 but the index is -1', <anon>:1
[19:53:30] -rusti- application terminated with error code 101
[19:53:31] <kimundi> beside, you want
[19:54:01] <kimundi> no, forget the last one
[19:54:25] *** Quits: Kruppe (user@moz-4DDA8AB8.uwaterloo.ca) (Ping timeout)
[19:54:25] <engla> rusti: "é¾™ï¼Œä½ å¥½å—".slice_chars(1, 4)
[19:54:26] -rusti- "\uff0c\u4f60\u597d"
[19:54:54] <kimundi> rusti: println("é¾™ï¼Œä½ å¥½å—".slice_chars(1, 4));
[19:54:55] -rusti- ï¼Œä½ å¥½
[19:54:55] -rusti- ()
[19:55:05] *** Joins: RMF (RMF@moz-BFEC31A2.dsl.telepac.pt)
[19:55:20] <kimundi> rusti: println("é¾™, ä½ å¥½å—".slice_chars(1, 4));
[19:55:20] -rusti- , ä½ 
[19:55:20] -rusti- ()
[19:55:33] <kimundi> different ',' , interesting...
[19:55:56] <engla> fullwidth
[19:56:11] <mindcat> but how can I get last chars?
[19:56:38] <engla> mindcat: use .slice_chars  with char_len() as last argument?
[19:56:47] <kimundi> rusti: println("é¾™, ä½ å¥½å—".iter().invert().nth(0));
[19:56:48] -rusti- <anon>:5:17: 5:45 error: mismatched types: expected `&str` but found `std::option::Option<char>` (expected &str but found enum std::option::Option)
[19:56:48] -rusti- <anon>:5          println("é¾™, ä½ å¥½å—".iter().invert().nth(0));
[19:56:48] -rusti-                           ^~~~~~~~~~~~~~~~~~~~~~~~~~~~
[19:56:48] -rusti- error: aborting due to previous error
[19:56:48] -rusti- application terminated with error code 101
[19:56:54] <kimundi> rusti: println("é¾™, ä½ å¥½å—".iter().invert().nth(0).unwrap());
[19:56:55] -rusti- <anon>:5:17: 5:54 error: mismatched types: expected `&str` but found `char` (expected &str but found char)
[19:56:55] -rusti- <anon>:5          println("é¾™, ä½ å¥½å—".iter().invert().nth(0).unwrap());
[19:56:55] -rusti-                           ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
[19:56:56] -rusti- error: aborting due to previous error
[19:56:58] -rusti- application terminated with error code 101
[19:57:14] *** Quits: lenstr (lenstr@AF8EB999.6049B16A.85938D85.IP) (Client exited)
[19:57:20] *** Quits: dave1629 (dave@DFE764FE.2F87036F.DDE5D3F6.IP) (Quit: dave1629)
[19:57:26] <kimundi> rusti: println("é¾™, ä½ å¥½å—".iter().last().unwrap());
[19:57:27] -rusti- <anon>:5:17: 5:45 error: mismatched types: expected `&str` but found `char` (expected &str but found char)
[19:57:27] -rusti- <anon>:5          println("é¾™, ä½ å¥½å—".iter().last().unwrap());
[19:57:27] -rusti-                           ^~~~~~~~~~~~~~~~~~~~~~~~~~~~
[19:57:27] -rusti- error: aborting due to previous error
[19:57:27] -rusti- application terminated with error code 101
[19:57:35] *** Joins: jviereck (Adium@moz-58A87BA7.dip0.t-ipconnect.de)
[19:57:39] <kimundi> doh
[19:57:44] <kimundi> rusti: println("é¾™, ä½ å¥½å—".iter().last().unwrap().to_str());
[19:57:45] -rusti- å—
[19:57:45] -rusti- ()
[19:57:59] <kimundi> rusti: "é¾™, ä½ å¥½å—".iter().last().unwrap()
[19:58:00] -rusti- '\u5417'
[19:58:09] *** Quits: jgilbert (jgilbert@moz-7B0110AD.mv.mozilla.com) (Ping timeout)
[19:58:56] <engla> what does the text mean?
[19:59:07] <kimundi> which one?
[19:59:12] <engla> the chinese text
[19:59:17] *** Joins: jgilbert (jgilbert@moz-7B0110AD.mv.mozilla.com)
[19:59:19] <kimundi> ah.
[19:59:20] <dpc> é¾™, ä½ å¥½å—
[19:59:34] * kimundi has no idea
[19:59:43] <engla> I think I know this one  å¥½  woman and child = happiness or something
[19:59:59] *** Quits: miloshadzic (miloshadzi@F8195CC5.425C93D4.449B8A48.IP) (Quit: My MacBook has gone to sleep. ZZZzzzâ€¦)
[20:00:48] *** Quits: jgilbert (jgilbert@moz-7B0110AD.mv.mozilla.com) (Max SendQ exceeded)
[20:00:49] <mindcat> "dragon, are you fine?" I think it is
[20:01:25] <engla> ok. is dragon a person name?
[20:01:30] *** Joins: jgilbert (jgilbert@moz-7B0110AD.mv.mozilla.com)
[20:02:29] *** Joins: victorporof (victorporo@9D964D4D.36D485C.2B3D3D4.IP)
[20:02:38] <kimundi> mindcat: Anyway, I'm currently not entirely sure how to slice a number of code points from the back. I'm looking right now if there are some convenience functions for that...#
[20:03:14] <engla> there aren't
[20:03:52] <mindcat> engla: no, I just randomly type somethings
[20:04:25] <engla> mindcat: if you want 6 chars from the back you do   let clen = s.char_len(); s.slice_char(clen - 6, clen);  we should add convenience functions for this
[20:04:34] *** Quits: jmgrosen (jmgrosen@moz-A3814C08.sd.sd.cox.net) (Quit: jmgrosen)
[20:04:35] <kimundi> rusti: "é¾™, ä½ å¥½å—".offset_char_iter().invert().take(2).to_owned_vec()
[20:04:35] -rusti- <anon>:5:9: 5:33 error: type `&'static str` does not implement any method in scope named `offset_char_iter`
[20:04:36] -rusti- <anon>:5          "é¾™, ä½ å¥½å—".offset_char_iter().invert().take(2).to_owned_vec()
[20:04:36] -rusti-                   ^~~~~~~~~~~~~~~~~~~~~~~~
[20:04:36] -rusti- error: aborting due to previous error
[20:04:36] -rusti- application terminated with error code 101
[20:04:48] <kimundi> rusti: "é¾™, ä½ å¥½å—".char_offset_iter().invert().take(2).to_owned_vec()
[20:04:49] -rusti- ~[(11u, '\u5417'), (8u, '\u597d')]
[20:04:51] <engla> the issue is that we don't want users to confuse which methods use byte indices and which use char indices
[20:05:13] <SimonSapin> was it discussed to used negative indices to mean "from the end"?
[20:05:13] <kmc> why do any of them use byte indices :(
[20:05:15] <kimundi> rusti: "é¾™, ä½ å¥½å—".char_offset_iter().invert().take(2).last().nth(0)
[20:05:15] -rusti- <anon>:5:9: 6:5 error: type `std::option::Option<(uint,char)>` does not implement any method in scope named `nth`
[20:05:15] -rusti- <anon>:5          "é¾™, ä½ å¥½å—".char_offset_iter().invert().take(2).last().nth(0)
[20:05:16] -rusti- <anon>:6     };
[20:05:16] -rusti- error: aborting due to previous error
[20:05:16] -rusti- application terminated with error code 101
[20:05:24] <kimundi> rusti: "é¾™, ä½ å¥½å—".char_offset_iter().invert().take(2).last().unwrap().nth(0)
[20:05:26] -rusti- <anon>:5:9: 6:5 error: type `(uint,char)` does not implement any method in scope named `nth`
[20:05:26] -rusti- <anon>:5          "é¾™, ä½ å¥½å—".char_offset_iter().invert().take(2).last().unwrap().nth(0)
[20:05:26] -rusti- <anon>:6     };
[20:05:26] -rusti- error: aborting due to previous error
[20:05:27] -rusti- application terminated with error code 101
[20:05:34] <engla> kmc: because char index lookup is O(Index)
[20:06:01] <SiegeLord> Are tuples also guaranteed to be aligned the same way as a C struct?
[20:06:03] <bjz> SimonSapin: that causes overhead
[20:06:11] <kimundi> rusti: "é¾™, ä½ å¥½å—".char_offset_iter().invert().take(2).last().unwrap().n0()
[20:06:12] -rusti- 8u
[20:06:27] <SiegeLord> aligned/layed out
[20:06:34] <kmc> engla: that depends on the string data structure, but for a bare UTF-8 buffer, yes
[20:06:43] <bjz> SimonSapin: ie. a check to see if it's negative
[20:06:45] <engla> kmc: so for ~str, yes
[20:07:05] <kmc> but how is byte indexing on UTF-8 useful at all? what's the point of providing a faster operation if it makes no sense
[20:07:20] <engla> slicing is fast
[20:07:43] <kimundi> rusti: fn slice_chars_back(s: &'a str, n: uint) -> &'a str {let index = s.char_offset_iter().invert().take(n).last().unwrap().n0(); s.slice_from(index)} ; slice_chars_back("é¾™, ä½ å¥½å—", 3)
[20:07:46] *** Quits: marc (marc@E31B39DA.F9D61A8.416A0103.IP) (Quit: leaving)
[20:07:46] -rusti- pastebinned 8 lines of output: http://ix.io/7Sk
[20:07:56] <kmc> I don't care how fast it is if it's useless and nonsensical :)
[20:08:04] <Blub\w> good point
[20:08:11] <kimundi> rusti: fn slice_chars_back<'a>(s: &'a str, n: uint) -> &'a str {let index = s.char_offset_iter().invert().take(n).last().unwrap().n0(); s.slice_from(index)} ; slice_chars_back("é¾™, ä½ å¥½å—", 3)
[20:08:12] -rusti- "\u4f60\u597d\u5417"
[20:08:15] *** Joins: jmgrosen (jmgrosen@moz-A3814C08.sd.sd.cox.net)
[20:08:15] <Blub\w> isn't there some .as_bytes() anyway?
[20:08:18] <engla> it's not useless
[20:08:19] <kmc> if people want ASCII character indexing they can use the 'ascii' module and at least own up to the fact that they're making software that most of the world can't use
[20:08:22] <kimundi> rusti: fn slice_chars_back<'a>(s: &'a str, n: uint) -> &'a str {let index = s.char_offset_iter().invert().take(n).last().unwrap().n0(); s.slice_from(index)} ; println(slice_chars_back("é¾™, ä½ å¥½å—", 3));
[20:08:23] -rusti- ä½ å¥½å—
[20:08:23] -rusti- ()
[20:08:34] <kimundi> mindcat: SUCCESS! :) ^
[20:08:41] *** Joins: robertknight (robertknig@moz-29DA0AFD.range86-162.btcentralplus.com)
[20:08:41] <kimundi> rusti: fn slice_chars_back<'a>(s: &'a str, n: uint) -> &'a str {let index = s.char_offset_iter().invert().take(n).last().unwrap().n0(); s.slice_from(index)} ; println(slice_chars_back("é¾™, ä½ å¥½å—", 1));
[20:08:42] -rusti- å—
[20:08:42] -rusti- ()
[20:08:49] <SimonSapin> kmc: you can think of indices as opaque numbers you get from other methods
[20:08:52] <engla> kmc: just because you use .slice() doesn't mean you disregard unicode. You just have to be careful to find the right indices
[20:08:52] <mindcat> kimundi: :D
[20:09:14] <engla> kmc: for example through  char_offset_iter
[20:09:14] <Blub\w> it's not useless, but its use is limited to software you make only for yourself :P
[20:09:29] <Blub\w> ie which doesn't need to deal with other languages at all
[20:09:38] <Blub\w> but then why not use a byte array :|
[20:09:40] <engla> Blub\w: this is again not true
[20:11:05] *** Joins: lenstr (lenstr@AF8EB999.6049B16A.85938D85.IP)
[20:11:25] *** Quits: victorporof (victorporo@9D964D4D.36D485C.2B3D3D4.IP) (Ping timeout)
[20:11:41] <kmc> some kind of opaque pointer into a string would be a lot better than a raw index, I would think
[20:11:45] <kmc> I don't have a detailed proposal, though
[20:11:46] <engla> codepoint indexing is not a magic bullet. Now you risk splitting combining chars from their base character
[20:11:59] <kimundi> kmc: that's a &str, no?
[20:12:12] <doy> yeah, glyph indexing is really what you want
[20:12:18] <kmc> but anyway, I'm sick of programming languages providing APIs that seem designed to result in Unicode-clueless programmers producing software that only works for Americans
[20:12:18] <Blub\w> I find it makes string implementations behave oddly though - indexing should work by codepoint, and to extract bytes I'd expect a method to provide the utf8 implementation - which doesn't mean that utf8 even has to be used internally; what I mean is: the methods and the ways you provide to index the various types of entities in such a string should be independent from the internal representation
[20:12:27] <kmc> even when in principle there is a safe way to use the API
[20:12:31] <Blub\w> and of course also work by visible glyph
[20:12:31] <kmc> there's a safe way to use malloc/free too
[20:12:41] <Blub\w> but you do need both: codepoint and glyph - in order to be able to combine glyphs
[20:13:20] *** Quits: lenstr (lenstr@AF8EB999.6049B16A.85938D85.IP) (Client exited)
[20:13:47] *** Quits: tjc (tjc@moz-BBE3ABD.mv.mozilla.com) (Quit: zzzzzzzzzz)
[20:13:57] <Blub\w> I always thought 'str' should be highlevel, and arrays for lower level functionality
[20:13:58] <kmc> Blub\w: I agree with most of that
[20:14:08] <kmc> I think understanding glyphs might be too complicated for the basic builtin str type
[20:14:10] <kimundi> kmc: I agree in principle. If we could rewrite the string functions to not use byte indices in a way that does not cause significant more overhead, that would be good. Also, making sure that neither of {byte, codepoint, glyph} is being made the default way to handle elements of a string
[20:14:14] <kmc> better provided by a library like ICU or something
[20:14:36] <Blub\w> sure that makes sense too
[20:14:41] <engla> str does provide a too simple impl of .word_iter() today for example
[20:14:47] *** Joins: maxli (maxli@moz-6EADA619.cpe.net.cable.rogers.com)
[20:14:52] <engla> it's really split_on_whitespace_iter()
[20:15:06] <kmc> kimundi: well at least, we could wrap the indices in an abstract type
[20:15:40] <kimundi> kmc: Are glyphs that complicated? Don't we basicaslly just need a lookup table and a nice iterator over them like for char? I know that there are some localized differences, but unicode also provedes a 'generally right' set of rules for that, no?
[20:15:48] <kmc> I don't know all the details
[20:15:48] <kimundi> kmc: right
[20:15:51] *** Joins: ghrust (ghrust@2EE61FCC.6A2AE50.F3114085.IP)
[20:15:51] <ghrust> 01[13rust01] 15bors merged 06auto into 06master: 02http://git.io/puP-Rg
[20:15:51] *** Parts: ghrust (ghrust@2EE61FCC.6A2AE50.F3114085.IP) ()
[20:17:07] <engla> we've only just sorted out the basic wrongness of the utf-8 used in str. I guess it really is time to move to the next level.. understanding unicode
[20:17:09] <kmc> anyway I'm not sure that iterating over glyphs is that useful, either
[20:17:09] <Blub\w> the string/glyph discussion's never over is it :D
[20:17:29] <kmc> if you are outputting text to some device then you usually need to do more than just process each glyph in order
[20:17:38] *** Quits: jviereck (Adium@moz-58A87BA7.dip0.t-ipconnect.de) (Quit: Leaving.)
[20:17:40] *** Joins: themgt (themgt@moz-DEEE1644.baf.movistar.cl)
[20:17:40] *** Quits: themgt (themgt@moz-DEEE1644.baf.movistar.cl) (Client exited)
[20:17:46] <kmc> even fixed width terminals have double-width characters, and proportional text shaping is extremely complicated
[20:18:02] <Blub\w> useful or not - it does make sense though
[20:18:09] <Ms2ger> Strings are hard
[20:18:10] <kmc> I think iterating over codepoints makes sense as the operation which gives you directly what a UTF-8 string "really represents", while preventing you from breaking the invariants of that datastructure
[20:18:12] <Ms2ger> Let's go shopping
[20:18:24] <Blub\w> after all, _displaying_ the text isn't the job of the str type
[20:19:28] <engla> most of all str is UTF-8 packed in an interface to keep it valid UTF-8
[20:19:30] <kimundi> It's all stepping stones
[20:19:32] <Blub\w> and if you eg. implement text rendering manually you do want to be able to get individual codepoints and handle combiners yourself :)
[20:19:59] <kmc> itym Strings are hard Ã¢â‚¬â€ letÃ¢â‚¬â„¢s go shopping
[20:20:25] <Ms2ger> kmc++
[20:20:40] *** Quits: maxli (maxli@moz-6EADA619.cpe.net.cable.rogers.com) (Ping timeout)
[20:20:50] *** Joins: ghrust (ghrust@F6EE6DE3.6A2AE50.F3114085.IP)
[20:20:51] <ghrust> 01[13rust01] 15bors pushed 0 new commits to 06auto: 02http://git.io/XZalyA
[20:20:51] *** Parts: ghrust (ghrust@F6EE6DE3.6A2AE50.F3114085.IP) ()
[20:20:51] *** Joins: ghrust (ghrust@F6EE6DE3.6A2AE50.F3114085.IP)
[20:20:51] <ghrust> 01[13rust01] 15bors pushed 3 new commits to 06auto: 02http://git.io/HPm_TQ
[20:20:51] <ghrust> 13rust/06auto 14be43625 15Corey Richardson: Add a from_str function that calls out to the associated method on the trait
[20:20:51] <ghrust> 13rust/06auto 14c1c5c8b 15Corey Richardson: Add from_str docs
[20:20:51] <ghrust> 13rust/06auto 147b91964 15bors: auto merge of #8988 : cmr/rust/fromstr_fn, r=brson...
[20:20:52] *** Parts: ghrust (ghrust@F6EE6DE3.6A2AE50.F3114085.IP) ()
[20:21:04] <mindcat> å­—ç¬¦ä¸²å¤ªéš¾ï¼Œè®©æˆ‘ä»¬åŽ»è´­ç‰©ã€‚
[20:21:30] <mindcat> chinese version :D
[20:21:31] <kmc> I would just be wary of implementing some abstract Unicode committee notion of "glyph" if there are no plausible API consumers that care about it
[20:21:44] <kimundi> bytes allow for utf8 allow for chars allow for glyphs allow for ...
[20:22:05] <kmc> mindcat: :)
[20:22:07] <doy> kmc: table formatting and word wrapping are impossible without a notion of "glyph"
[20:22:11] <engla> which ultimately allows for rendering internet arguments about encodings
[20:22:26] <kimundi> kmc: If anything, people using glyph for naive text algnment is less wrong than using chars
[20:22:31] <doy> for fixed-width, anyway
[20:22:42] <engla> hehe so it's a pyramid of being less wrong
[20:22:48] <kmc> right, but you have to deal with double width characters still
[20:23:03] <kimundi> If we can't bring them to do something perfectly right away, we can at least keep pushing them in the right direction
[20:23:06] <kmc> but yeah it might be an acceptable less wrong solution
[20:23:24] <kmc> but that has to balance against the complexity of making this part of the core str type
[20:23:29] <Blub\w> even so, I don't think taht's str's job; displaying text and editing text are 2 different problems
[20:23:32] *** Joins: dave1629 (dave@DFE764FE.2F87036F.DDE5D3F6.IP)
[20:23:33] <kmc> rather than delegating it to a terminal output or text shaping library
[20:23:53] <engla> mindcat: your feedback is valuable. feel free to report issues if it's too hard to use ~str or Rust in general with Rust.. or if there are bugs
[20:23:54] <Blub\w> and when you try to align text without knowing what's displaying the text you have a 3rd problem anyway :P
[20:24:14] <engla> mindcat: with regards to chinese
[20:24:17] *** Joins: Kruppe (user@moz-E150F49F.cpe.net.cable.rogers.com)
[20:24:18] <mindcat> engla: :D
[20:24:20] <Blub\w> then again, I don't have problems with double-width chars in my terminal, vim, weechat etc so...
[20:24:33] <Blub\w> solutions must exist already :P
[20:24:37] <kimundi> I mean, for double/fixed with you can have a .is_double_width() on glyph, and an abstraction layer that iterates over glyphes in a way that results in a fixed gwidth grid
[20:24:51] *** Quits: jdsanders (Adium@moz-84CB7548.hlrn.qwest.net) (Quit: Leaving.)
[20:25:55] <Blub\w> ï¼¤ï¼¯ï¼µï¼¢ï¼¬ï¼¥ã€€width
[20:26:42] <kimundi> rusti: "å­—ç¬¦ä¸²å¤ªéš¾ï¼Œè®©æˆ‘ä»¬åŽ»è´­ç‰©ã€‚".bogus()
[20:26:43] -rusti- <anon>:5:9: 6:5 error: type `&'static str` does not implement any method in scope named `bogus`
[20:26:43] -rusti- <anon>:5          "å­—ç¬¦ä¸²å¤ªéš¾ï¼Œè®©æˆ‘ä»¬åŽ»è´­ç‰©ã€‚".bogus()
[20:26:43] -rusti- <anon>:6     };
[20:26:43] -rusti- error: aborting due to previous error
[20:26:43] -rusti- application terminated with error code 101
[20:26:56] <kimundi> rusti: "å­—ç¬¦ä¸²å¤ªéš¾ï¼Œè®©æˆ‘ä»¬åŽ»è´­ç‰©ã€‚".as_slice().as_slice()
[20:27:01] -rusti- pastebinned 28 lines of output: http://ix.io/7Sl
[20:27:18] <Blub\w> haha, next job is to teach rustc to print the ^~~~ lines properly when double-width strings are involved in the source :P
[20:27:35] <kimundi> ^ That error message shows what happens if you don't even care about ccodepoints yet :P
[20:28:28] <engla> kimundi: no. there are 13 ~ and the string is 13 .char_len()
[20:28:56] <kimundi> oh.
[20:28:57] <kimundi> right
[20:29:02] <kmc> Blub\w: haha
[20:29:09] <Blub\w> the codepoint count is right, the codepoint-width is not :P
[20:29:28] <Blub\w> someone needs to make it use ~ and ã€œ accordingly :P
[20:29:38] *** Joins: james4k (james@moz-E7990244.consolidated.net)
[20:29:45] <kimundi> new plan: teach me how to setup my fonts in a way that chromium shows those glyphs as the same size :P
[20:30:02] <Blub\w> kimundi: you mean narrow it?
[20:30:10] <Blub\w> I doubt any such font exists :D
[20:30:11] *** Joins: lenstr (lenstr@AF8EB999.6049B16A.85938D85.IP)
[20:31:16] <kimundi> hm, my terminally makes them double width... with the result that the span is exactly half as long :P
[20:31:47] *** Quits: lenstr (lenstr@AF8EB999.6049B16A.85938D85.IP) (Client exited)
[20:32:21] <engla> talking about language bugs, firefox sorts the font 'monospace' first because it is lower case..
[20:33:31] <kimundi> do codepoints also have the concept of being "double width" ?
[20:33:42] *** Quits: six600110 (six600110@moz-2FA48202.neo.res.rr.com) (Ping timeout)
[20:33:46] <kimundi> if yes, that's what spans need :P
[20:33:51] *** Joins: lenstr (lenstr@AF8EB999.6049B16A.85938D85.IP)
[20:34:21] *** Quits: dave1629 (dave@DFE764FE.2F87036F.DDE5D3F6.IP) (Quit: dave1629)
[20:34:39] <engla> codepoints might stack all into one glyph
[20:34:47] <engla> say the two codepoint version of Ã¡
[20:35:30] <kimundi> true
[20:35:38] *** Joins: dave1629 (dave@DFE764FE.2F87036F.DDE5D3F6.IP)
[20:35:39] <kimundi> so we need glyphs for that
[20:35:50] <kimundi> hey, here we have a reson to add them!
[20:35:54] <engla> https://github.com/mozilla/rust/issues/7043
[20:36:34] <engla> issue "Unicode grapheme support"
[20:36:46] <kimundi> Should I add a comment for that?
[20:36:57] <kmc> kimundi: yeah they do have that concept http://www.unicode.org/reports/tr11/
[20:37:03] <kmc> of course It's Complicated
[20:37:37] <Blub\w> ah right, there ARE narrow chars
[20:37:46] *** Quits: dave1629 (dave@DFE764FE.2F87036F.DDE5D3F6.IP) (Quit: dave1629)
[20:38:09] <kmc> Unicode has a lot of complexity from the need to be round trip compatible with legacy encodings
[20:38:12] <kmc> which is unfortunate
[20:38:24] <kmc> but also kind of necessary if you want things like a single 'str' type for your language
[20:38:48] <kmc> lets you deal with encodings only on input/output
[20:39:22] <kmc> compare with Ruby, where strings are byte strings with some metadata saying what encoding they use
[20:39:29] <kmc> pretty nasty I hear, although I haven't used it much
[20:39:48] *** Quits: mihneadb (mihneadb@moz-BE33DA21.fw1.sfo1.mozilla.net) (Input/output error)
[20:40:09] <mm> rendering language makes me sad :(
[20:40:15] <engla> or C where the wchar is all up to the locale and OS
[20:40:18] * mm goes back to working on non-localized products, yay
[20:40:18] <engla> hence unusable
[20:40:35] <kmc> yeah wchar is really the worst
[20:40:49] <kmc> at least there is a CPP macro to check whether it covers all of ISO 10646, iirc
[20:41:06] <engla> right, but that's only going to be defined for linux-like systems
[20:41:17] <kmc> Android wchar_t was one byte, for a while :3
[20:43:38] *** Joins: jviereck (Adium@moz-58A87BA7.dip0.t-ipconnect.de)
[20:43:42] *** Quits: jviereck (Adium@moz-58A87BA7.dip0.t-ipconnect.de) (Client exited)
[20:43:55] *** Joins: jviereck (Adium@moz-58A87BA7.dip0.t-ipconnect.de)
[20:44:46] *** Joins: jstevans (Instantbir@moz-6B9EAE76.bootp.virginia.edu)
[20:45:44] *** Quits: lenstr (lenstr@AF8EB999.6049B16A.85938D85.IP) (Client exited)
[20:46:13] *** Quits: sankha93 (Instantbir@7061CD01.D6BD0D91.22D41759.IP) (Quit: Gone to save the world!)
[20:48:03] *** Joins: Liothen (liothen@moz-80EF0CD7.spkn.qwest.net)
[20:48:39] *** Quits: dherman (dherman@moz-6CA476B1.hsd1.ca.comcast.net) (Quit: dherman)
[20:48:48] *** Quits: jmgrosen (jmgrosen@moz-A3814C08.sd.sd.cox.net) (Quit: jmgrosen)
[20:48:57] *** Joins: six600110 (six600110@moz-2FA48202.neo.res.rr.com)
[20:49:27] *** Joins: dherman (dherman@moz-6CA476B1.hsd1.ca.comcast.net)
[20:49:27] *** ChanServ sets mode: +ao dherman dherman
[20:50:12] *** Joins: maxli (maxli@moz-6EADA619.cpe.net.cable.rogers.com)
[20:50:46] *** Quits: hjr3 (hradtke@374E545A.3A8E9B0C.F9D9C60E.IP) (Quit: My MacBook has gone to sleep. ZZZzzzâ€¦)
[20:50:49] *** Joins: ghrust (ghrust@DE823A67.6A2AE50.F3114085.IP)
[20:50:49] <ghrust> 01[13rust01] 15bors 04force-pushed 06auto from 147b91964 to 14d84a7b5: 02http://git.io/N3iJvQ
[20:50:49] *** Parts: ghrust (ghrust@DE823A67.6A2AE50.F3114085.IP) ()
[20:50:51] *** Joins: ghrust (ghrust@9C8B94D4.6A2AE50.F3114085.IP)
[20:50:51] <ghrust> 01[13rust01] 15bors pushed 2 new commits to 06auto: 02http://git.io/PtFgkQ
[20:50:51] <ghrust> 13rust/06auto 146b7b8f2 15Chris Morgan: Add an ``unreachable!()`` macro....
[20:50:51] <ghrust> 13rust/06auto 14d1dde99 15bors: auto merge of #8992 : chris-morgan/rust/unreachable-macro, r=brson...
[20:50:52] *** Parts: ghrust (ghrust@9C8B94D4.6A2AE50.F3114085.IP) ()
[20:52:13] <SiegeLord> Damn... keep hitting circular import errors...
[20:52:25] <SiegeLord> Is there a story yet for handling them?
[20:52:36] <kimundi> SiegeLord: Could you give me an example?
[20:53:08] <kimundi> SiegeLord: I recently tried to find out what causes an circular import error, and failed. As in, I knew they exist, but not how to caus ethem
[20:53:23] <doomlord> is that circular glob use
[20:53:49] *** Quits: jviereck (Adium@moz-58A87BA7.dip0.t-ipconnect.de) (Quit: Leaving.)
[20:54:17] *** Joins: jmgrosen (jmgrosen@moz-A3814C08.sd.sd.cox.net)
[20:54:26] *** Quits: jmgrosen (jmgrosen@moz-A3814C08.sd.sd.cox.net) (Quit: jmgrosen)
[20:57:44] *** Joins: jmgrosen (jmgrosen@moz-A3814C08.sd.sd.cox.net)
[20:58:04] *** Quits: josh (josh@moz-348C4790.hsd1.mn.comcast.net) (Quit: josh)
[20:58:19] <SiegeLord> Hmm, I guess I could try to reduce it...
[20:58:21] *** Quits: robertknight (robertknig@moz-29DA0AFD.range86-162.btcentralplus.com) (Ping timeout)
[20:59:25] *** Quits: jmgrosen (jmgrosen@moz-A3814C08.sd.sd.cox.net) (Ping timeout)
[21:00:45] *** Joins: dave1629 (dave@DFE764FE.2F87036F.DDE5D3F6.IP)
[21:00:51] *** Joins: josh (josh@moz-348C4790.hsd1.mn.comcast.net)
[21:01:35] <doomlord> i made the mistake of settig up a project with everything in the root module, it washell to untangle
[21:03:01] *** Joins: valenting (Thunderbir@8758046C.84D5EFD5.FB866788.IP)
[21:04:02] *** Quits: jdm (jdm@92FB48CA.8B5E9DF.9A8C35B4.IP) (Quit: Lost terminal)
[21:08:00] *** Joins: hjr3 (hradtke@374E545A.3A8E9B0C.F9D9C60E.IP)
[21:08:02] *** Joins: nkoep (nik@moz-A196DCE9.pool.mediaways.net)
[21:08:02] *** Joins: robertknight (robertknig@moz-29DA0AFD.range86-162.btcentralplus.com)
[21:08:02] <miza> i have a struct that assigned as mutable
[21:08:39] <miza> bet when i try to chang a struct variable in method that have implement
[21:08:43] <miza> get error
[21:08:49] <miza> cannot assign to immutable field
[21:09:04] <miza> as i read struct inherits mutability
[21:09:07] <kimundi> miza: does the struct use &self ?
[21:09:11] <kimundi> er, the method?
[21:09:11] <miza> y
[21:09:17] *** Quits: dave1629 (dave@DFE764FE.2F87036F.DDE5D3F6.IP) (Quit: dave1629)
[21:09:18] <kimundi> well, that'S the reason :)
[21:09:22] <miza>   pub fn emulate_cycle(&self) {
[21:09:22] <miza>     self.fetch_opcode();
[21:09:22] <miza>   }
[21:09:22] <miza>   fn fetch_opcode(&self) {
[21:09:23] <miza>     self.opcode = (self.memory[self.pc_reg] << 8 | self.memory[self.pc_reg + 1]) as u16;
[21:09:23] <miza>   }
[21:09:27] <kimundi> implement the method with &mut self
[21:09:37] *** Quits: msingle (Thunderbir@moz-930E5D97.hr.hr.cox.net) (Ping timeout)
[21:09:43] *** Quits: robertknight (robertknig@moz-29DA0AFD.range86-162.btcentralplus.com) (Ping timeout)
[21:09:57] *** Joins: victorporof (victorporo@9D964D4D.36D485C.2B3D3D4.IP)
[21:10:28] <miza> kimundi thanks for the fast answer
[21:12:34] *** Joins: strcat (strcat@moz-61B073BC.cpe.net.cable.rogers.com)
[21:14:24] *** Joins: mihneadb (mihneadb@moz-BE33DA21.fw1.sfo1.mozilla.net)
[21:15:58] *** Quits: jstevans (Instantbir@moz-6B9EAE76.bootp.virginia.edu) (Ping timeout)
[21:18:32] <dpc> Is there anyone who groks rust building scripts?
[21:18:41] <dpc> Here, now, I mean.
[21:19:29] *** Joins: robertknight (robertknig@moz-29DA0AFD.range86-162.btcentralplus.com)
[21:20:04] *** Joins: eatkinson (eatkinson@moz-DA40A624.airbears2.berkeley.edu)
[21:20:08] <brson> if you mean the makefiles, then i do
[21:20:49] <dpc> I'm compiling rust on arm machine.
[21:20:54] <dpc> natively, to generate native code
[21:21:09] *** Quits: robertknight (robertknig@moz-29DA0AFD.range86-162.btcentralplus.com) (Ping timeout)
[21:21:23] <dpc> I got couple of fixes/hacks that I needed for this to work. At least to progress...
[21:21:32] <brson> r? https://github.com/mozilla/rust/pull/9000
[21:21:37] <mm> dpc: what hardware are you using?
[21:21:41] <mm> Out of curiosity.
[21:21:54] <dpc> The building scripts add '-m32' which fails here.
[21:22:00] <dpc> Arndale Board.
[21:22:13] <Luqman> dpc: that's going to be complicated a bit by the fact we don't have any arm stage0 snapshots currently
[21:22:29] <dpc> So it's not going to work? :(
[21:22:36] <cmr> You just need to make a snapshot yourself.
[21:22:49] <dpc> How do I do this?
[21:22:53] <Luqman> brson: can't apply cleanly
[21:22:56] <cmr> Make a cross compiler, then cross-build a native compiler using that snapshot commit.
[21:23:01] <brson> Luqman: i just rebased
[21:23:03] <cmr> Look in src/snapshots.txt for the most recent snapshot commit
[21:23:25] <dpc> So I need to build a crosscompiler on my x64 desktop?
[21:23:49] <dpc> No, I need to build native compiler on my x64, only for arm... :D
[21:24:05] <Luqman> dpc: yes, so step one is building a cross compiler
[21:24:20] <Luqman> then you use it to compile the compiler itself for arm
[21:25:18] <dpc> Right.
[21:26:00] <dpc> What is this src/snapshots file?
[21:26:00] *** Joins: robertknight (robertknig@moz-54528EE0.wby.mendeley.com)
[21:26:14] <dpc> sha256 of some files ...
[21:26:51] <dpc> I have no idea about all this compiling llvm evil sourcery, not to mention cross-compiling it. :D
[21:27:13] *** Quits: KindOne (KindOne@moz-A03C5F46.dynamic.ip.windstream.net) (Ping timeout)
[21:27:35] <doomlord> you're into rust on arm ? .. any interest in iOS
[21:27:41] *** Quits: robertknight (robertknig@moz-54528EE0.wby.mendeley.com) (Ping timeout)
[21:27:41] *** Joins: jmgrosen (jmgrosen@moz-848F6087.sb.sd.cox.net)
[21:27:52] <cmr> dpc: it's the git commits.
[21:28:28] *** Joins: robertknight (robertknig@moz-29DA0AFD.range86-162.btcentralplus.com)
[21:28:58] <doomlord> way too late for sony,but i wonder what rust would have been liked on the CELL...
[21:30:08] *** Quits: robertknight (robertknig@moz-29DA0AFD.range86-162.btcentralplus.com) (Ping timeout)
[21:30:15] <cmr> Was cell their own architecture or did they just license/use it?
[21:30:28] <dpc> I've got couple of dev boards for Cortex-a8, a9, a15 and wonted to play with Rust apps on it.
[21:30:33] <TD-Linux> CELL is IBM's architecture
[21:30:35] <doomlord> it was custom designed for the ps3 and intended for video aswell, but i dont think it ever happened
[21:30:46] <TD-Linux> I think a TV or two had it
[21:30:50] <doomlord> sony-toshiba-ibm ... ibm was going to do blade workstations
[21:31:04] <doomlord> blade servers sorry
[21:31:06] *** Joins: jstevans (Instantbir@moz-6B9EAE76.bootp.virginia.edu)
[21:31:30] <TD-Linux> it's basically the same idea as GPU compute
[21:31:44] *** Joins: KindOne (KindOne@41432DDC.B3929A3A.34F73994.IP)
[21:31:49] <doomlord> GPU compute is more shared memory
[21:31:54] <Luqman> dpc: any specific reason you want to run rustc on arm rather than just cross compile?
[21:32:01] <doomlord> cell was NUMA
[21:32:25] <Ms2ger> ... numa eh?
[21:32:27] <dpc> Luqman: No, I guess. I was just curious. 
[21:32:28] <doomlord> DMA between local stores, more like DSP programming
[21:32:45] <doomlord> rust's idea of tasks having local heaps... :)
[21:33:11] <TD-Linux> yeah I was about to mention that, each cell unit had its own bit of SRAM
[21:33:23] *** Quits: infynyxx_ (infynyxx@DB780A29.749BA1D.DCC373F0.IP) (Client exited)
[21:33:25] <doomlord> and it could only work in that. evertthing else was DMA
[21:33:41] <dpc> cmr: I don't think I'll be able and have time to do the full native compilation etc. Just wanted to let you know that I had to add these hacks: http://sprunge.us/dHdN
[21:34:05] <cmr> dpc: why does -m32 not work exactly?\
[21:34:12] <dpc> just to progress a bit with compilation; The -m32 is obviuosly wrong because it should be conditional, I guess.
[21:34:24] <dpc> cmr: It's not recognized argument.
[21:34:45] <dpc> [arndale:src/rust] (master)% gcc -m32 x.c  gcc: error: unrecognized command line option â€˜-m32â€™
[21:35:35] *** Quits: Ms2ger (Ms2ger@moz-B53902AE.adsl-dyn.isp.belgacom.be) (Quit: nn)
[21:35:38] <dpc> I mean, my hack is wrong. :)
[21:35:46] <cmr> What version of gcc is that that doesn't recognize -m32?
[21:36:00] *** Quits: Palmik (palmik@moz-CC484FDD.tmcz.cz) (Quit: Lost terminal)
[21:36:02] <dpc> gcc (GCC) 4.7.2 20121109 (Red Hat 4.7.2-8)
[21:36:39] <cmr> Hm
[21:36:40] <dpc> -m32 is i386/x86_64 option
[21:36:43] <cmr> Perhaps it's an architecture specific thing
[21:36:50] <cmr> It's more than the x86 family
[21:36:53] <cmr> but apparently not arm
[21:36:53] <dpc> Yeap. `man gcc` confirms it.
[21:37:24] <dpc> However as AARCH64 for ARM is on the way, I guess it might be introduced to arm soon, as well.
[21:37:36] *** Quits: Blub\w (wry@7E3BB9D.71150E1A.237AE2BA.IP) (Quit: zZzZ early tonight)
[21:37:48] <dbaupp> nmatsakis: pong
[21:38:05] <dbaupp> nmatsakis: (very briefly)
[21:38:17] <doomlord> might be able to get at a ps4  toolchain soon, i'd love  to know if rust could work there..
[21:38:22] *** Joins: infynyxx (infynyxx@DB780A29.749BA1D.DCC373F0.IP)
[21:38:32] <TD-Linux> that's just x64
[21:38:55] <TD-Linux> is sony rolling their own kernel?
[21:39:06] <doomlord> there's details.. libuv r.e. ios
[21:39:09] <dbaupp> nmatsakis: deriving is definitely wrong wrt NodeIds; I didn't really have a deep understanding of the ast when I wrote it
[21:39:18] <doomlord> ^^^lubuv r.e. whatever OS they have
[21:39:29] <TD-Linux> aah FreeBSD
[21:39:56] <doomlord> i dont currently know what the PS4 'kernel'looks like.
[21:39:59] <TD-Linux> libuv isn't essential to rust right now
[21:40:20] <doomlord> i recall libuv being where i stalled on iOS hence my typo above
[21:40:35] <cmr> TD-Linux: it's certainly essential to libstd though!
[21:40:37] <doomlord> "details" r.e. the whole target-tripple...
[21:40:49] *** Quits: eatkinson (eatkinson@moz-DA40A624.airbears2.berkeley.edu) (Quit: eatkinson)
[21:40:59] <cmr> doomlord: I don't know anything about iOS, but would an iOS-specific profile be useful? (re: runtime profiles, different configurations of the standard library)
[21:40:59] <doomlord> rust for gamedev... to really register it wants to be on consoles
[21:41:04] <TD-Linux> cmr, indeed. I get to either port it or make it an optional part of libstd soon
[21:41:06] <dbaupp> nmatsakis: there's Duplicate in syntax::ext::build which is designed to help with this
[21:41:12] <kmc> they really missed a golden opportunity to name the 64-bit ARM architecture "Leg"
[21:41:23] <cmr> TD-Linux: Ohh, do go on? This is relevant to my interests.
[21:41:37] <doomlord> perhaps it would, i haven't looked at it recently... at the minute i dont have  a working mac
[21:41:42] <TD-Linux> cmr, well I want to port libstd to bare metal
[21:41:55] <TD-Linux> my two targets right now are stm32f4 and the nintendo ds
[21:42:00] <SiegeLord> rusti: let a: *int = ptr::null(); a as u64
[21:42:07] -rusti- pastebinned 11 lines of output: http://ix.io/7So
[21:42:11] <doomlord> rust on nintendo DS?
[21:42:19] <TD-Linux> nintendo ds actually has a filesystem and sockets, so I could port libuv there
[21:42:24] <dpc> kmc: Hahaha. :D
[21:42:26] *** Quits: mihneadb (mihneadb@moz-BE33DA21.fw1.sfo1.mozilla.net) (Input/output error)
[21:42:32] <TD-Linux> but for stm32 the idea will be just to be able to make libstd without files or sockets
[21:42:34] <cmr> Oh, ok.
[21:42:47] <SiegeLord> rusti: let a: *int = std::ptr::null(); a as u64
[21:42:47] -rusti- 0u64
[21:42:49] <cmr> TD-Linux: So there's a fair bit of discussion about this subject.
[21:42:50] <doomlord> i thought libuv was associated with the task/scheduler runtime, its more?
[21:42:53] <dbaupp> nmatsakis: anyway, got to dash. (acrichto has some familiarity with the deriving code too.)
[21:42:59] <TD-Linux> the DS is an easier target because it has boatloads of RAM (4MB)
[21:43:00] <cmr> doomlord: it's what we use for io
[21:43:12] <doomlord> ahhhh.
[21:43:40] <TD-Linux> but the STM32 isn't bad either (1MB of ROM / 192KB RAM), and I expect that rust would run in far more constrained environments
[21:43:44] <cmr> TD-Linux: There's a nice post by brson on the mailing list from the past month or so about having "runtime profiles", where you provide a specific configuration for a platform, with its own libstd etc.
[21:43:45] *** Joins: lenstr (lenstr@AF8EB999.6049B16A.85938D85.IP)
[21:43:59] <TD-Linux> cmr, yup I saw that post
[21:44:05] <cmr> TD-Linux: so, let me know how it goes and what would be necessary for a profile to include to be useful for you
[21:44:21] <TD-Linux> I was considering 3 separate "switches" so far
[21:44:25] *** Joins: dave1629 (dave@DFE764FE.2F87036F.DDE5D3F6.IP)
[21:44:39] <TD-Linux> sockets, filesystem, threading
[21:45:05] *** Joins: mihneadb (Mihnea@moz-BE33DA21.fw1.sfo1.mozilla.net)
[21:45:37] <ecr> brson: could you look at https://github.com/mozilla/rust/pull/8999 ?
[21:46:37] <lkuper> r? anyone: https://github.com/mozilla/rust/pull/8909 (discussion on that page re: allocation etc. should be resolved now)
[21:48:20] <doomlord> one thing is, i know sony had their own compiler for vita.. i dont know if they just use gcc/llvm for ps4,or if they use their own
[21:48:29] *** Quits: dpc (Mibbit@7FBDDBBD.1B10ED22.D9F38258.IP) (Quit: http://www.mibbit.com ajax IRC Client)
[21:48:40] <doomlord> i'd hope you can use gcc/llvm..
[21:50:43] *** Quits: dave1629 (dave@DFE764FE.2F87036F.DDE5D3F6.IP) (Quit: dave1629)
[21:50:48] <Luqman> doomlord: i know llvm has a bit of psp support
[21:51:04] <doomlord> crazy r-series stuff there
[21:51:15] *** Quits: aeqwa (aeqwa@moz-A8FE6EB1.dsl.tropolys.de) (Quit: Lost terminal)
[21:51:21] <doomlord> hehe china keeping MIPS architecture going
[21:55:50] *** Joins: ghrust (ghrust@79968228.6A2AE50.F3114085.IP)
[21:55:50] <ghrust> 01[13rust01] 15bors merged 06auto into 06master: 02http://git.io/PtFgkQ
[21:55:50] *** Parts: ghrust (ghrust@79968228.6A2AE50.F3114085.IP) ()
[21:55:51] *** Joins: ww (Mibbit@moz-7385AD13.dia.static.qwest.net)
[21:56:38] <ww> quick question.  is there a way to exit in the middle of a rust program without using the fail! macro?
[21:57:26] *** Quits: Sindwiller (quassel@moz-743130B2.dynamic.hispeed.ch) (Client exited)
[21:58:07] <kimundi> ww: nope
[21:58:09] *** Quits: Axord (xord@moz-1B228827.lsanca.dsl-w.verizon.net) (Connection reset by peer)
[21:58:27] <bjz> ww: I think that stuff is in std::os?
[21:58:32] <kimundi> unless you call libc::exit, but that is ... unrecommended
[21:58:58] <SiegeLord> Is there a way to uniformly initialize a fixed size array?
[21:59:17] <bjz> ww: no I don't think so
[21:59:20] <kimundi> SiegeLord: Could you elaborate?
[21:59:23] <SiegeLord> Without repeating the size, if possible...
[21:59:26] <ww> ok, thanks
[21:59:29] <bjz> ww: only setting exit codes
[21:59:32] <kmc> . o O (  asm!("mov $60, %rax; syscall")  )
[21:59:42] <kimundi> rusti: let v: [uint, ..12] = [23, ..12];
[21:59:42] -rusti- <anon>:5:13: 5:14 warning: unused variable: `v` [-W unused-variable (default)]
[21:59:42] -rusti- <anon>:5          let v: [uint, ..12] = [23, ..12];
[21:59:42] -rusti-                       ^
[21:59:42] -rusti- ()
[21:59:46] <kimundi> rusti: let v: [uint, ..12] = [23, ..12]; v
[21:59:47] -rusti- [23u, 23u, 23u, 23u, 23u, 23u, 23u, 23u, 23u, 23u, 23u, 23u]
[22:00:01] <SiegeLord> Can you do it without repeating the ..12?
[22:00:10] <kimundi> nope
[22:00:21] <SiegeLord> That's a shame... oh well
[22:00:24] <bjz> ww: I'm guessing attempting to exit when in another task would be... weird...
[22:00:42] <kimundi> alos, only works with implicitly copyable types
[22:00:46] <kimundi> also*
[22:00:52] *** Joins: ghrust (ghrust@9C8B94D4.6A2AE50.F3114085.IP)
[22:00:52] <ghrust> 01[13rust01] 15bors pushed 0 new commits to 06auto: 02http://git.io/zMziFQ
[22:00:52] *** Parts: ghrust (ghrust@9C8B94D4.6A2AE50.F3114085.IP) ()
[22:00:52] <bjz> rusti: let v = [23u, ..12]; v
[22:00:53] -rusti- [23u, 23u, 23u, 23u, 23u, 23u, 23u, 23u, 23u, 23u, 23u, 23u]
[22:00:53] *** Joins: ghrust (ghrust@DE823A67.6A2AE50.F3114085.IP)
[22:00:53] <ghrust> 01[13rust01] 15bors pushed 2 new commits to 06auto: 02http://git.io/6sQPjA
[22:00:53] <ghrust> 13rust/06auto 14de39874 15Florian Hahn: Rename str::from_bytes to str::from_utf8, closes #8985
[22:00:53] <ghrust> 13rust/06auto 146f9ce09 15bors: auto merge of #8997 : fhahn/rust/issue_8985, r=catamorphism,brson...
[22:00:54] *** Parts: ghrust (ghrust@DE823A67.6A2AE50.F3114085.IP) ()
[22:01:41] <myname> can't you just do something like 23u.repeat(12).to_vec()?
[22:01:58] <kimundi> myname: that creates an owned vector
[22:02:01] <ww> well, the use case is just a simple exit in the print_usage().  someone runs a_rust_prog --help.  it's simple to print usage and exit.
[22:02:03] <kimundi> a ~[T]
[22:02:05] <myname> oh
[22:02:23] <jclements> kimundi: AAHHH... you renamed ident->Ident. I mean... thanks, definitely the right thing to do... (back to rebase purgatory... :)  )
[22:02:23] <SiegeLord> bjz: In my case I already wrote down the lhs type, as it's actually in a vector
[22:02:34] <SiegeLord> bjz: So I want to infer the rhs, not the lhs
[22:02:45] <kimundi> generally, we can't have any method that returns/uses a [T, ..N], because we can't express the N as a type paramter yet
[22:02:47] <SiegeLord> *already in a struct
[22:03:07] <SiegeLord> I think that's what I want, yes...
[22:03:08] <kimundi> jclements: Hm? Yeah I did rename a few things :)
[22:03:19] <jclements> kimundi: sigh....
[22:03:26] <bjz> myname: [T, ..N] cannot be expressed generically in the type system (yet?)
[22:03:46] <kimundi> More to come! ;) (but propably not the next month)
[22:04:33] <kimundi> jclements: To be honest I was waiting for the "AAARG, my precious half complete patch!" comments to come in :)
[22:04:56] <jclements> kimundi: does that mean I'm the first? I'm so lucky....
[22:05:23] <kimundi> the first to complain in IRC while I'm reading it at least :)
[22:08:43] <SiegeLord> Hmm... is there no autoderef for raw pointers?
[22:09:25] <kimundi> Btw, fun fact: A stage0 that doesn't error for unused variables caused a few renamings I missed to slip through. "@s as @ToStr: Can only dereference unsafe pointers in an unsafe block" was a very scary way to tell me I missed something :D
[22:09:46] <kimundi> SiegeLord: Nope, as that's an unsafe operation
[22:10:23] <SiegeLord> kimundi: No more unsafe than just derefing it though, no?
[22:12:14] <kimundi> SiegeLord: dereferncing it is an unsafe operation. Having that happen automatically on a method call would mean all method calls would need to be unsafe
[22:13:14] <SiegeLord> I'd kind of expect that to be the case when you're calling methods on a raw pointer...
[22:13:38] <SiegeLord> Or rather, it wouldn't be a source of surprise for me
[22:14:12] <SiegeLord> To be perfectly clear, I am doing this within the unsafe block
[22:16:33] <cmr> ww: return from main?
[22:16:43] *** Joins: tjc (tjc@moz-BBE3ABD.mv.mozilla.com)
[22:16:43] *** ChanServ sets mode: +o tjc
[22:17:12] <cmr> kimundi: I was grumpy when I had to rebase rustdoc_ng but not very much.
[22:17:15] *** Quits: azita (Azita@moz-BBE3ABD.mv.mozilla.com) (Quit: azita)
[22:18:02] *** Quits: sebcrozet (sebcrozet@moz-7FB6C00B.w193-252.abo.wanadoo.fr) (Quit: Gone)
[22:20:59] *** Quits: infynyxx (infynyxx@DB780A29.749BA1D.DCC373F0.IP) (Client exited)
[22:21:17] <tjc> brson: do you know how conditions interact with tasks?
[22:21:19] <tjc> (or anybody else)
[22:21:48] <kimundi> cmr: :)
[22:25:42] <cmr> tjc: they call fail! and use TLS to store the condition stack
[22:25:48] <ecr> tjc: it's all task local. if it causes the task to fail then the failure is propagated. 
[22:25:49] <cmr> Does that answer your question?
[22:26:05] <ecr> tjc: and there's also this exit code propagation thing in rt::kill.rs that bblum wrote
[22:28:17] <tjc> cmr, ecr: thanks
[22:28:24] <tjc> Yes, it answers my question. I'd pretty much guessed, but wanted to be sure
[22:29:08] <doomlord> would it be possible to do something like foo/mod.rs for things at the crate root level to enable a rust sourcetree to always mimick directory structure (next time i set something up i'll know to use subdirs & mod.rs.. just wondering..)
[22:29:38] <doomlord> ^to enable a rust module heirachy to always mimick the directory structure^
[22:30:00] <cmr> doomlord: I don't see why not?
[22:30:14] <cmr> Python does the same thing with __init__.py
[22:30:44] *** Quits: ww (Mibbit@moz-7385AD13.dia.static.qwest.net) (Quit: http://www.mibbit.com ajax IRC Client)
[22:31:15] <bjz> tjc: hoy
[22:31:22] <tjc> bjz: Hey
[22:31:39] <bjz> tjc: how does test.rs work?
[22:31:50] <SiegeLord> rusti: enum A { Test{a: int} } let a = Test{a: 1} match a { Test{a : a} => () }
[22:31:50] -rusti- <anon>:5:52: 5:57 error: expected `;` but found `match`
[22:31:50] -rusti- <anon>:5          enum A { Test{a: int} } let a = Test{a: 1} match a { Test{a : a} => () }
[22:31:51] -rusti-                                                              ^~~~~
[22:31:51] -rusti- application terminated with error code 101
[22:31:56] <bjz> can't see any examples in the testsuite
[22:31:58] <SiegeLord> rusti: enum A { Test{a: int} } let a = Test{a: 1}; match a { Test{a : a} => () }
[22:31:59] -rusti- <anon>:5:72: 5:73 warning: unused variable: `a` [-W unused-variable (default)]
[22:31:59] -rusti- <anon>:5          enum A { Test{a: int} } let a = Test{a: 1}; match a { Test{a : a} => () }
[22:31:59] -rusti-                                                                                  ^
[22:31:59] -rusti- ()
[22:31:59] <tjc> bjz: good point
[22:32:04] <SiegeLord> Hmm
[22:32:09] <SiegeLord> Why doesn't that work for me...
[22:32:13] <tjc> bjz: src/librustpkg/tests.rs has some examples but none that really exercise that feature
[22:32:21] <tjc> they do build an executable from tests.rs, but they don't run the tests
[22:32:27] <jclements> when make succeeds and sudo make install starts compilation all over again... seriously considering hurting myself.
[22:32:35] <bjz> tjc: I want to do tests for cgmath
[22:32:36] <tjc> the idea is that test.rs will be the crate module that you use to build your test executable
[22:32:37] <doomlord> (perhaps for consistency it could just be 'mod.rs' in the 'crate root'..)
[22:32:54] <tjc> right now, you can write a test.rs, build it with rustpkg, and then run the executable manually
[22:33:02] <bjz> tjc: ok
[22:33:03] <tjc> in the future, you will be able to say "rustpkg test" and have it build and run the tests in one go
[22:33:11] <bjz> tjc: https://github.com/bjz/cgmath-rs
[22:33:40] <bjz> tjc: so is there a way of doing something like rustpkg build --test cgmath
[22:33:45] <bjz> or something?
[22:33:49] <bjz> for now?
[22:34:09] <cmr> bjz: I'd be interested in various comparisons between a completed cgmath and nphysics/whatever, both in code size, speed, and memory usage.
[22:34:34] <tjc> bjz: right now, if cgmath has a test.rs file somewhere in it, and you rustpkg build cgmath...
[22:34:44] <tjc> it will create a build/cgmath/cgmathtest executable
[22:34:49] <tjc> then you can just run build/cgmath/cgmathtest --test
[22:34:51] <bjz> cmr: it will never have physics
[22:35:15] *** Joins: infynyxx (infynyxx@DB780A29.749BA1D.DCC373F0.IP)
[22:35:16] <bjz> cmr: and probably won't be as technical as nalgebra
[22:35:32] <bjz> tjc: cool
[22:35:35] <flaper87> tjc: uuu, nice. Gotta read more about rustpkg
[22:35:42] <bjz> tjc: what does --test do?
[22:35:45] <flaper87> I ended up writing my own Makefile for that
[22:35:58] *** Joins: Axord (xord@moz-1B228827.lsanca.dsl-w.verizon.net)
[22:36:15] <bjz> tjc: and how do I include stuff from cgmath?
[22:36:36] <cmr> flaper87: there's not really much to read :)
[22:36:40] <tjc> bjz: --test just says "run things that were marked with #[test]"
[22:36:47] <bjz> tjc: if I have unit tests in the cgmath modules, do they get run when I execute the tests?
[22:37:00] <tjc> bjz: if you do mod foo; inside the test.rs file, then any #[test] things in foo will run when you run the test executable
[22:37:02] <flaper87> cmr: hahah, by read I meant, reading errors after several tests
[22:37:04] <flaper87> :P
[22:37:06] <tjc> cmr: there's the source code :-)
[22:37:09] <flaper87> and the source
[22:37:14] <flaper87> tjc: beat me
[22:37:15] <bjz> tjc: or do I need separate files linked to the test.rs
[22:37:16] <flaper87> :D
[22:37:39] *** Quits: Axord (xord@moz-1B228827.lsanca.dsl-w.verizon.net) (Ping timeout)
[22:37:54] <flaper87> tjc: this is my current structure. http://pastebin.mozilla.org/2979525
[22:38:06] <flaper87> erm, my project's structure
[22:38:08] <flaper87> :D
[22:38:10] <bjz> tjc: would I copy these imports into test.rs? https://github.com/bjz/cgmath-rs/blob/master/src/cgmath/lib.rs#L25
[22:38:16] <tjc> bjz: you can have separate files if you want, but anything with a #[test] in a module that the test.rs imports should be pulled in
[22:38:42] <bjz> tjc: or do you do something like, extern mod cgmath
[22:39:02] *** Joins: eholk (eholk@moz-F70D5031.hsd1.in.comcast.net)
[22:39:22] <SiegeLord> What am I doing wrong here: https://gist.github.com/SiegeLord/6457211
[22:39:26] <tjc> bjz: No, you would just be importing the same files in a different root crate
[22:39:45] <tjc> so yeah, if you copy-and-paste lines 25-42 in your test.rs, that should do it
[22:40:13] <bjz> tjc: also, if I have a subdir 'test', with a file 'test.rs', would 'rustpkg build cgmath' look in the tests dir for the tests.rs file?
[22:40:38] <bjz> tjc: oh ok - but I'd have to copy the util mod code too right?
[22:41:02] *** Quits: eholk (eholk@moz-F70D5031.hsd1.in.comcast.net) (Quit: eholk)
[22:41:04] <tjc> bjz: yes, it will look in the subdir
[22:41:13] <bjz> tjc: seems a tad repetitive - and you have to keep them up to date
[22:41:18] <SiegeLord> Actually, no... nevermind that for now... let me fix it to be the way it is actually in my code...
[22:41:24] <tjc> bjz: if you need the util code for the tests to work, you would have to copy that
[22:41:30] <bjz> tjc: like, if your mods have inter-deps
[22:41:30] <tjc> or you could factor out the util code into another module
[22:41:46] <tjc> bjz: I suppose it would also work if you factored out all the `pub mod`s too...
[22:42:02] <tjc> I'm not sure we have a good pattern for this yet -- try it and see what works, then report back if you think something needs improvement :-)
[22:42:21] <bjz> tjc: would it be better just to have a separate workspace, 'tests'?
[22:42:35] <bjz> tjc: then I would be able to extern mod cgmath
[22:42:42] <bjz> without the hairiness
[22:42:56] <tjc> bjz: I don't think it will run tests defined in other crates; but if you want to put all the tests in a separate crate, that's fine too
[22:43:02] <flaper87> tjc: what sturcture does rustpkg expect ? 
[22:43:07] <bjz> I know that's not what you intended
[22:43:09] <brson> strcat: i couldn't reproduce the linux valgrind problem locally. still trying to find a commit on the bot where it didn't have that problem
[22:43:14] <flaper87> tjc: like src/mymod/lib.rs ?
[22:43:26] <tjc> flaper87: https://github.com/mozilla/rust/blob/master/doc/rustpkg.md isn't that fleshed-out yet, but ti does explain the expected structure
[22:43:31] <tjc> if anything there isn't clear, please yell :-)
[22:43:35] <bjz> tjc: yeah, that's what I mean, make my tets in a separate workspace, not in the source files
[22:43:38] <flaper87> tjc: awesome, thanks
[22:43:52] <tjc> bjz: Yeah, that would make some sense. For rustpkg itself I ended up putting all the tests in one file, which could be a separate crate, so...
[22:43:56] <tjc> I'm not opposed to that design
[22:44:20] <bjz> tjc: do you see what I mean about the inter-deps though?
[22:44:37] <tjc> bjz: Not quite...
[22:44:43] <flaper87> +1 for tests in a separate workspace
[22:45:04] *** Quits: lenstr (lenstr@AF8EB999.6049B16A.85938D85.IP) (Client exited)
[22:45:21] <bjz> tjc: well, you need to duplicate all the mod definitions - if you don't your build would blow up
[22:45:34] <bjz> tjc: not like just using 'use'
[22:46:08] <kimundi> bjz, tjc: How about this: if no test.rs file exists, it uses the regular crate file for unit tests
[22:46:14] <cmr> So, I'm working on 3358
[22:46:22] <bjz> tjc: but yeah, at any rate, doing mine in a seperate workspace might be better
[22:46:22] <cmr> Is there any way to do a span_lint at https://github.com/cmr/rust/blob/415c15cb097de64e35e8b94a73c908f595fc6620/src/librustc/middle/lint.rs#L645 ?
[22:46:30] <cmr> It's the wrong session, and I don't see any way to get the context?
[22:46:30] *** Quits: miza (miza@moz-4DD51325.home.otenet.gr) (Input/output error)
[22:46:41] <cmr> Should I put it somewhere else, or add in the Context as a parameter?
[22:46:50] <tjc> kimundi: Or, i guess, we could just drop the test.rs file altogether
[22:46:50] <bjz> kimundi: that's a nice idea
[22:47:15] <bjz> tjc: yeah, another possibility
[22:47:35] <kimundi> I guess ideally you want to support both in-crate tests and out-of-crate tests
[22:47:42] <bjz> tjc: what does it do if it sees both a main.rs and a lib.rs?
[22:47:45] <bjz> kimundi++
[22:48:02] <kimundi> no test.rs: in-crate tests. test.rs: out-of-crate tests
[22:48:02] <tjc> bjz: It builds two different crates, one executable and one library
[22:48:05] <brson> we had another test suite regression that lost all the gains we made by optimizing resolve
[22:48:23] <cmr> brson: what sort of regression?
[22:48:31] <kimundi> the question is wether the test.rs should contain the modules of the crate, or wether it should extern mod; it
[22:48:39] <bjz> tjc: anyway, I will do a separate workspace for now
[22:48:47] <brson> cmr: oh, i read the chart wrong - the regression was just adding back the benchmarks
[22:49:05] *** Quits: infynyxx (infynyxx@DB780A29.749BA1D.DCC373F0.IP) (Client exited)
[22:49:08] <bjz> tjc: that has its own benefits too
[22:49:11] <brson> i htink
[22:49:56] *** Quits: ab (alex@BC9D99CC.37C1012D.FE617B51.IP) (Ping timeout)
[22:50:05] <cmr> brson: it actually wasn't just the benchmarks
[22:50:10] <cmr> brson: it was all the non-unit-test tests
[22:50:12] <cmr> ie, all rpass
[22:50:13] *** Joins: ab (alex@BC9D99CC.37C1012D.FE617B51.IP)
[22:50:30] *** Joins: infynyxx (infynyxx@DB780A29.749BA1D.DCC373F0.IP)
[22:50:33] <bjz> tjc: still, <3 rustpkg ^^
[22:50:51] *** Quits: infynyxx (infynyxx@DB780A29.749BA1D.DCC373F0.IP) (Connection reset by peer)
[22:51:02] *** Joins: infynyxx (infynyxx@DB780A29.749BA1D.DCC373F0.IP)
[22:51:03] <brson> cmr: ah, that's not great
[22:51:14] <bjz> room for improvement, but you've relly done a great job so far
[22:51:19] <tjc> bjz: thanks!
[22:51:22] <brson> though i'm surprised that all the tests only accounted for that much time
[22:51:38] <brson> which tests *are* taking all that time
[22:51:41] <brson> -?
[22:52:17] <strcat> I think we should aggregate the run-pass tests into bundles of them
[22:52:25] <cmr> Good question
[22:52:28] <strcat> like all the vector ones in one test harness
[22:52:36] <cmr> I've never actually taken a time profile of the tests.
[22:52:45] <doomlord> are gui bindings a low priority...  (web + CLI + 3d engines in opengl is enough :) )
[22:53:01] <SiegeLord> Ok, here it its again: https://gist.github.com/SiegeLord/6457211
[22:53:06] <strcat> and run-fail
[22:53:07] <kimundi> tjc: I have an idea re: rustpkg tests
[22:53:13] <tjc> kimundi: Sure!
[22:53:15] <strcat> just can't do compile-fail that way, but it never hits trans
[22:53:18] <SiegeLord> Having issues with cross crate struct enums
[22:53:37] *** Joins: Axord (xord@moz-1B228827.lsanca.dsl-w.verizon.net)
[22:54:08] <SiegeLord> And it's an already submitted bug... woohoo
[22:55:15] *** Joins: SingingBoyo (brandon@moz-452E2E6F.ubcsecure.wireless.ubc.ca)
[22:56:06] <kimundi> tjc: I think there are 3 ways to have the test suite of a rustpkg package work: in-crate by compiling the crate with rustc --test, out-of-crate by having a test.rs file that 'extern mod's the crate, and hybrid where you have a test.rs file that contains all modules of your crate with 'mod ...;' statements, effectively providing an alternate test crate-root.
[22:57:58] <tjc> kimundi: Yes
[22:58:10] <tjc> that's right
[22:58:26] <kimundi> tjc: And I think you can implement the latter two by having rustpkg look for that 'extern mod' - If test.rs contains it, rustpkg first compiles the crate normaly, and then links the test executable to it. If test.rs doesn't contain the 'extern mod', it just compiles the test crate directly
[22:59:01] <tjc> kimundi: hmm
[22:59:01] *** Quits: SingingBoyo (brandon@moz-452E2E6F.ubcsecure.wireless.ubc.ca) (Ping timeout)
[22:59:09] <tjc> seems reasonable; I just want the story to be as clear as possible
[22:59:20] <tjc> what are the reasons why somebody might want to implement the test suite in each of the 3 ways?
[22:59:26] <tjc> If 1 way is clearly better, maybe we should "bless" it
[22:59:27] *** Joins: SingingBoyo (brandon@moz-452E2E6F.ubcsecure.wireless.ubc.ca)
[22:59:32] *** Quits: huseby (huseby@19BD73A1.5D8BCA3A.A0C1B52F.IP) (Quit: Leaving)
[22:59:54] *** Joins: lenstr (lenstr@AF8EB999.6049B16A.85938D85.IP)
[22:59:59] *** Quits: lenstr (lenstr@AF8EB999.6049B16A.85938D85.IP) (Client exited)
[23:00:00] <flaper87> tjc: kimundi I'd start supporting in-crate tests and using rustc --test
[23:00:11] <kimundi> in-crate: pro: quick and easy, can test private things. cons: clutters the code, change to tests mean recompile the library itself
[23:00:25] <flaper87> https://github.com/FlaPer87/rust-actors/blob/master/Makefile#L31
[23:00:29] <flaper87> for example ^
[23:00:31] <tjc> yeah, the "changes to tests means recompiling the library" is a huge bummer for me when modifying libstd tests
[23:01:07] <flaper87> that's what I did and I don't need to recompile the library
[23:01:17] <flaper87> actually, that'd be kinda out-of-crate
[23:01:37] <kimundi> out-of-crate: pro: can test the public api extensivly, no cluttering the crate code itself, changes to testsuite do not cause the  crate to need recompiling. cons: can't test private items, need to do more work to test the public api
[23:02:16] *** Quits: hjr3 (hradtke@374E545A.3A8E9B0C.F9D9C60E.IP) (Quit: My MacBook has gone to sleep. ZZZzzzâ€¦)
[23:04:00] <mindcat> how can I cross compile rustc to arm platfrom?
[23:04:04] <kimundi> hybrid: pro: can test private api, separate test crate from regular crate, can test public api separately without needing to recompile crate. cons: needs to compile the same amount of code as the crate, needs to duplicate crate root.
[23:04:57] <mindcat> I want rustc running in Raspberry Pi
[23:05:02] <tjc> kimundi: Great summary -- I'll open an issue for this
[23:05:12] <doomlord> hehe compile times might be trying...
[23:05:27] <flaper87> kimundi: +1 
[23:05:51] *** Joins: ghrust (ghrust@24260B07.6A2AE50.F3114085.IP)
[23:05:51] <ghrust> 01[13rust01] 15bors merged 06auto into 06master: 02http://git.io/6sQPjA
[23:05:51] *** Parts: ghrust (ghrust@24260B07.6A2AE50.F3114085.IP) ()
[23:06:04] *** Joins: eatkinson (eatkinson@moz-DA40A624.airbears2.berkeley.edu)
[23:06:23] <kimundi> meta: pro: supporting all 3 means people are less likely to bitch about rusts test suite mechanisms being useless. cons: 3 ways to do something are 2 more than absolutely necessary ;)
[23:06:36] <tjc> I would rather have one way to do it if possible :-)
[23:06:41] <tjc> am willing to deal with the complaints
[23:06:49] <tjc> then there's less to document, test, and maintain
[23:07:15] <flaper87> tjc: +1 About one way to do it
[23:07:41] <kimundi> If it needs to be one, then the current test.rs test-crate seems to be the closest. but still, falling back to using the actual crate as test source seems easy enough to support
[23:08:45] <kimundi> It would also be backwards compatible: can still add the 'extern mod' way afterwards
[23:09:19] <bjz> doomlord: seems to be low priority, but help is always appreaciated
[23:09:38] <bjz> doomlord:sort of needs a champion to forge a way ;)
[23:09:53] <doomlord> i'm not volunteering on that front :) just notice a lot of people asking about qt bindings
[23:10:00] <tjc> kimundi: Actually, I think it already does what you suggested for free --- I mean, having rustpkg look for the `extern mod`
[23:10:14] <tjc> as in, if rustpkg decides that test.rs depends on lib.rs, it will compile lib.rs first
[23:10:22] <kimundi> But anyway, don't listen to closely... Those are just the first things that came to mind for me. :)
[23:10:23] <tjc> I don't have a regression test for that, though, and should
[23:10:33] <tjc> kimundi: don't undersell yourself, these are good ideas :-)
[23:10:36] <bjz> doomlord: I don't think servo is focusing on chrome at any rate - its mandate is for an engine, not a full browser
[23:10:47] *** Joins: ghrust (ghrust@24260B07.6A2AE50.F3114085.IP)
[23:10:47] <ghrust> 01[13rust01] 15bors pushed 0 new commits to 06auto: 02http://git.io/4_SAqQ
[23:10:47] *** Parts: ghrust (ghrust@24260B07.6A2AE50.F3114085.IP) ()
[23:10:50] <kimundi> he, if it already works, all the better xD
[23:10:51] *** Joins: ghrust (ghrust@79968228.6A2AE50.F3114085.IP)
[23:10:51] <ghrust> 01[13rust01] 15bors pushed 2 new commits to 06auto: 02http://git.io/8zOlgQ
[23:10:51] <ghrust> 13rust/06auto 145092ccd 15Eric Reed: Make I/O tests use run_in_mt_newsched_task to get more multi-threaded test coverage
[23:10:51] <ghrust> 13rust/06auto 1435fa9ee 15bors: auto merge of #8999 : anasazi/rust/multi-threaded-io-tests, r=brson...
[23:10:51] *** Parts: ghrust (ghrust@79968228.6A2AE50.F3114085.IP) ()
[23:11:04] <tjc> kimundi bjz: https://github.com/mozilla/rust/issues/9003 if you want to comment
[23:11:15] <tjc> wow, I didn't realize we'd passed 9000 issues
[23:11:25] * kimundi casually notices we're already over 9000
[23:11:32] <bjz> tjc: any luck on that glfw examples thing?
[23:11:43] <tjc> bjz: Sorry, haven't gotten to that yet -- my queue overfloweth
[23:11:48] <bjz> np
[23:11:56] <tjc> bjz: I think I made an issue for it, though, let me check
[23:11:58] <bjz> does it always  ;)
[23:12:02] <bjz> yeah, you did
[23:12:10] <bjz> I'm following it anyway :)
[23:12:35] <tjc> bjz: https://github.com/mozilla/rust/issues/8892 -- you probably know that, though :-)
[23:12:42] * ecr shatters his glasses at kimundi's observation
[23:12:45] * flaper87 definitely watching issue 9003
[23:13:37] <engla> The number of issues is over 9000!! :-)
[23:14:23] *** Joins: eskatrem (user@moz-50DD1DF1.dyn.user.ono.com)
[23:14:37] <bjz> super ideas kimundi!
[23:14:46] <kimundi> thanks :)
[23:14:47] <bjz> well, observations
[23:15:02] *** Quits: jstevans (Instantbir@moz-6B9EAE76.bootp.virginia.edu) (Ping timeout)
[23:15:03] *** Quits: donri (dag@moz-9BB61102.tbcn.telia.com) (Client exited)
[23:15:17] <jack> brson had issue #9000. i noticed that earlier :)
[23:15:17] <bjz> don't underestimate the value of well explained observations
[23:15:25] <kimundi> indeed
[23:15:26] <eskatrem> hey, another elementary question: how do I calculate the modulo for integers? something like (10).mod_floor(3)?
[23:15:37] <doomlord> someone introduced me to google 'protocol buffers' which look like an interesting way of doing cross language data
[23:15:39] <bjz> cmr: that's a milestone you need to inclue in TWiR :)
[23:15:42] <kimundi> rusti: 45u8 & 20
[23:15:43] -rusti- 4u8
[23:15:45] <ecr> rusti: 10 % 3
[23:15:46] -rusti- 1
[23:15:47] <kimundi> rusti: 45u8 % 20
[23:15:47] -rusti- 5u8
[23:16:09] <engla> rusti: -3 % 10
[23:16:10] -rusti- -3
[23:16:21] <zxcdw> rusti: shutup
[23:16:22] -rusti- <anon>:5:9: 5:15 error: unresolved name `shutup`.
[23:16:22] -rusti- <anon>:5          shutup
[23:16:22] -rusti-                   ^~~~~~
[23:16:22] -rusti- error: aborting due to previous error
[23:16:22] -rusti- application terminated with error code 101
[23:16:24] <kimundi> out module is remainder by the way
[23:16:24] <bjz> eskatrem: % does trunc division which is faster
[23:16:29] <zxcdw> oh the irony :D
[23:16:31] <eskatrem> rusti:println(fmt!("%d", 10%3))
[23:16:31] <zxcdw> D_
[23:16:31] -rusti- 1
[23:16:31] -rusti- ()
[23:16:34] <zxcdw> D:*
[23:16:50] <bjz> eskatrem: but mod_floor satisfies the mathematical definition
[23:16:59] <eskatrem> rusti: println(fmt!("%d", 10%3))
[23:16:59] -rusti- 1
[23:17:00] -rusti- ()
[23:17:09] <kimundi> zxcdw: It should be called remainder officially in the docs, actually
[23:17:25] <kimundi> AT least, I opened an issue about that ages ago
[23:17:30] <bjz> kimundi: % is rem
[23:17:32] <eskatrem> I couldn't find it in the doc, so I grepped "modulo" in the source code
[23:17:40] <kimundi> bjz: good
[23:17:54] <bjz> eskatrem: they have doc-strings on them
[23:18:17] <bjz> eskatrem: that provide a more in depth explanation
[23:18:38] <bjz> eskatrem: the difficulty is that bloody C muddied the waters
[23:19:41] <eskatrem> bjz: what's exactly doc-strings? comments? I got my mod_floor from reading the unit tests in the file in_macros.rs
[23:19:47] <kimundi> modulus() and remainder() are well defined, C just decided to call one by the others name :P
[23:19:49] <bjz> eskatrem: really it would might be better if there was a // (quot) operator, but I'm not about to push that
[23:19:59] *** Parts: fzzy (jahman@moz-D9D36111.cs.helsinki.fi) ()
[23:20:11] <SiegeLord> rusti: 1//2
[23:20:11] <eskatrem> at least NOW I CAN DO FIZZBUZZ IN RUST!!!1!!
[23:20:11] -rusti- 1
[23:20:30] <kimundi> rusti: 10 // 2
[23:20:31] -rusti- 10
[23:20:34] <bjz> SiegeLord: oh yeah, downside being that's for comments
[23:20:34] <kimundi> ...
[23:20:36] <bjz> x)
[23:20:36] <kimundi> do'h
[23:21:05] <eskatrem> 1//2 is a very strange notation
[23:21:06] <bjz> eskatrem: the challenge was that the 'div' operator needed a name that works for both floats *and* ints
[23:21:15] <kimundi> 10 `quot` 2 // !!!
[23:21:36] <bjz> eskatrem: isn't the maths notation x | y?
[23:21:40] <eskatrem> bjz: now I am lost
[23:21:44] <bjz> but of course that's taken :P
[23:21:54] <kimundi> eskatrem: AT what point? :P
[23:22:01] <eskatrem> in math it's x = y [z]  or x = y mod z
[23:22:03] <kimundi> did you get lost?
[23:22:26] <kimundi> eskatrem: bjz meant 'quot'
[23:22:32] <eskatrem> with the 'div' operator that needs a name for both floats and ints
[23:22:33] <engla> rt::backtrace is dead?
[23:22:40] <bjz> eskatrem: in haskell the C definitions for ints are quot/rem, then they also have div/mod
[23:22:51] <kimundi> eskatrem: one does div, the other does quot, both use the same symbol
[23:23:17] <kimundi> rusti: 1 / 2
[23:23:17] -rusti- 0
[23:23:20] <brson> ok i finally found a commit that valgrinds from early august
[23:23:22] <kimundi> rusti: 1.0 / 2.0
[23:23:23] -rusti- 0.5
[23:23:23] <eskatrem> kimundi: you mean '/', like in 4/10, right? 
[23:23:53] <bjz> eskatrem: basically we picked the 'best worst' name
[23:24:10] <eskatrem> I mean, other languages have different behaviour for the same operators according to types, so what's the problem?
[23:24:22] <bjz> eskatrem: it was a fiasco of bikeshedding and reversions to say the least
[23:24:40] <eskatrem> what was a fiasco?
[23:24:42] <kimundi> eskatrem: quot == integer division, defined on both natural numbers and reals. Div == actual division, defined on reals
[23:24:45] <bjz> eskatrem: look to the ISWIM languages
[23:25:15] <kimundi> eskatrem: the problem was how to call the method name that corresponds to the operator
[23:25:31] <bjz> and the trait
[23:25:37] <kimundi> to implement / in rust,m you impl trait Div
[23:25:47] <eskatrem> I still don't get it, rust can't overload functions?
[23:26:13] <bjz> eskatrem: but they're impled for the same type
[23:26:15] <engla> eskatrem: that's correct. You have generics via traits
[23:26:19] <doomlord> need to use traits, to overload multiple parameters it seems you can do something like "double-dispatch" with multiple traits
[23:26:47] <eskatrem> in what file of rust is the division implemented? I might as well have a look
[23:26:50] <kimundi> eskatrem: Both uint and float currently implement 'Div', but for uints the actual operation perfomed is 'quot', while for floats the actual operation performed is 'div'
[23:27:02] <bjz> eskatrem: libstd/num/intmacros
[23:27:18] *** Joins: a_m0d|home (a_m0d@moz-205FE182.acanac.net)
[23:27:26] <eskatrem> so in rust you can't overload function "normally" like, say, java or C++ ?
[23:27:33] <bjz> eskatrem: http://research.microsoft.com/pubs/151917/divmodnote-letter.pdf
[23:27:36] <bjz> eskatrem: no
[23:27:43] <kimundi> no overloads, no
[23:28:08] <bjz> eskatrem: we do overloading like in haskell, in a controlled way using typeclasses/traits
[23:28:08] <kimundi> (well, there are default methods that could count as limited overloading if you look at them right)
[23:28:33] <kimundi> (no wait, that's overwriting?)
[23:28:40] <SiegeLord> overriding
[23:28:58] <kimundi> ah, okay
[23:29:07] <bjz> eskatrem: the difficulty comes when trying to impl generic operators multiple times, like with matrix operations
[23:29:11] <eskatrem> I am not an expert in language design (or even in programming), so my opinion must not be the smartest one, but what's the downside of allowing overloading? is it for performance issue or quality of code?
[23:29:12] <doomlord> coming from C++, seems like - downside, less immiediate than overloading, plus side... closer relationship between runtime and compile-time polymorphism with generics & trait objects
[23:29:36] <bjz> eskatrem: there is also the issue of interop with other languages
[23:29:54] <bjz> eskatrem: C++ has painted itself into a corner in that respect
[23:29:55] <doomlord> i gather the real motivation is making compile errors more manageable (like C++ concepts proposal)
[23:30:04] *** Quits: SingingBoyo (brandon@moz-452E2E6F.ubcsecure.wireless.ubc.ca) (Ping timeout)
[23:30:09] <bjz> eskatrem: that's why C is still the linguafranca
[23:30:31] <eskatrem> compile errors manageable is making sens to me...
[23:30:49] <bjz> eskatrem: not sure how high that issue is though (language interop)
[23:30:57] <eskatrem> even though I find rustc cryptic at time (but it's probably because I am not used to it)
[23:31:08] <doomlord> coming from C++ rust is not cryptic
[23:31:09] <bjz> eskatrem: it gets easier
[23:31:46] <bjz> I get this though: https://mail.mozilla.org/pipermail/rust-dev/2013-September/005457.html
[23:32:06] <bjz> (that post was greeted with tumbleweed though)
[23:32:29] <eskatrem> my job is statistician, and my stack is more sql, R, python, than lower level languages, so it's probably me 
[23:32:36] <jmgrosen> one thing I think rust really needs is an official style guide
[23:32:47] <ecr> bjz: that formatting makes me want to vomit
[23:33:00] <bjz> (bar a post on the D forum http://forum.dlang.org/thread/ejfgnyfeddlbvqjmhiuc@forum.dlang.org#post-xjlgbkcbgdpoasslcssl:40forum.dlang.org)
[23:33:10] <bjz> ecr: well, how would you do it
[23:33:22] <bjz> ecr: that was the point of the message
[23:33:24] <jmgrosen> the styling preferably built into the tools (like `go fmt`) unlike PEP8
[23:33:37] <bjz> jmgrosen: https://github.com/mozilla/rust/wiki/Note-style-guide
[23:34:24] <jmgrosen> bjz: yeah, but it's not comprehensive, and not enough people pay attention to it
[23:34:25] <bjz> ecr: the point I was trying to make is that it is hard to lay out complex generics with the syntax as it stands, but maybe there are better ways
[23:34:36] <bjz> jmgrosen: well, it needs love
[23:34:55] <bjz> jmgrosen: it might be good to intergrate it with the current docs
[23:35:07] <jmgrosen> can libsyntax emit code or only parse it?
[23:35:37] <doomlord> there is prettypinting code somewhere i think, rust bindgen uses that
[23:35:49] <doomlord> i think ?
[23:36:03] *** Quits: Luqman (laden@moz-DCEF6040.csclub.uwaterloo.ca) (Ping timeout)
[23:36:12] <bjz> jmgrosen: macros use it when you do log_syntax! or whatever it is
[23:36:22] <eskatrem> anyway, I am trying to do the crypto challenge from matasano in rust, that's why I needed the modulo
[23:36:29] *** Quits: Larry (larryfox@moz-343B6F0C.nyc.biz.rr.com) (Quit: My MacBook Pro has gone to sleep. ZZZzzzâ€¦)
[23:36:35] <bjz> eskatrem: did you see the paper?
[23:36:36] *** Quits: alex-abreu (alex@moz-7421D6C9.mc.videotron.ca) (Ping timeout)
[23:36:50] <eskatrem> bjz: hmm I just had a really quick look
[23:37:03] <bjz> eskatrem: that's basically the goto thing if you want to know the quirks of the different mods
[23:37:17] <eskatrem> ok, I am reading it now
[23:37:24] * bjz heads out for a coffee
[23:37:29] <bjz> o/
[23:37:49] *** flaper87 is now known as flaper87|afk
[23:37:53] *** Quits: infynyxx (infynyxx@DB780A29.749BA1D.DCC373F0.IP) (Client exited)
[23:37:59] <jmgrosen> cya
[23:38:05] *** Joins: ChrisMorgan (chris@moz-80C478D2.its.monash.edu.au)
[23:38:48] *** Joins: alex-abreu (alex@moz-7421D6C9.mc.videotron.ca)
[23:39:31] *** Joins: Luqman (laden@moz-DCEF6040.csclub.uwaterloo.ca)
[23:40:14] <SiegeLord> Hmm... rustc code is somewhat hard to read... I wonder if it's worth it to learn it so I can have a try at fixing some of the bugs that vex me...
[23:40:45] <doomlord> i think its just 'big complex software is hard to read'...
[23:40:50] *** Joins: ghrust (ghrust@9C8B94D4.6A2AE50.F3114085.IP)
[23:40:50] <ghrust> 01[13rust01] 15bors 04force-pushed 06auto from 1435fa9ee to 146f9ce09: 02http://git.io/N3iJvQ
[23:40:50] *** Parts: ghrust (ghrust@9C8B94D4.6A2AE50.F3114085.IP) ()
[23:40:54] *** Joins: ghrust (ghrust@1E8607E8.6A2AE50.F3114085.IP)
[23:40:54] <ghrust> 01[13rust01] 15bors pushed 2 new commits to 06auto: 02http://git.io/IrmDMQ
[23:40:54] <ghrust> 13rust/06auto 14738ec51 15Brian Anderson: extra: Don't overcommit test tasks. Closes #8660...
[23:40:54] <ghrust> 13rust/06auto 14992b558 15bors: auto merge of #9004 : brson/rust/issue-8660, r=thestinger...
[23:40:55] *** Parts: ghrust (ghrust@1E8607E8.6A2AE50.F3114085.IP) ()
[23:41:15] <doomlord> although 2 letter type names dont help :)
[23:41:17] <tjc> doomlord: part of it is that some of rustc was written before we had some of the more modern features that make code easier to read
[23:41:22] <tjc> it's the age-old self-hosting compiler problem :-)
[23:41:28] <kimundi> SiegeLord: I'm thinking the same. I tried to read resolve.rs last week, ended with writing an ruby adhoc refactoring tool for updating rustc type naming conventions :P
[23:41:43] <tjc> patches that refactor code to make it easier to understand are *very* welcome
[23:41:51] <ecr> is there a reason we forbid trait bounds in structure definitions?
[23:41:54] <tjc> as are commits consisting of comments documenting existing code that lacks them
[23:41:59] <tjc> people who contribute those things are saints!
[23:42:09] <tjc> ecr: They were forbidden because they were never actually checked
[23:42:12] <SiegeLord> Once you understand the code, there's no more motivation to do the extra work to document it...
[23:42:23] <tjc> ecr: the idea is that you can always just write the bounds on the functions that take the structs instead
[23:42:32] <tjc> SiegeLord: Except for having a good and charitable soul
[23:42:40] <tjc> and not wanting to have to do all the same work in 3 months after you forget it :-)
[23:43:14] <kimundi> tjc: I know the code is ancient, this is not supposed to be critique - but having an identifier 'foo' defined as static, type, function AND variable in the same module is horrible D:
[23:43:27] <tjc> kimundi: Heh
[23:43:30] <tjc> what module is that?
[23:43:51] <benh> maybe it's a test for separate namespaces <:D
[23:43:54] *** Joins: dave1629 (dave@moz-17578A1A.hsd1.va.comcast.net)
[23:43:54] <kimundi> dunno, but while renaming it had a case similar to that in syntax/ast.rs
[23:44:14] * kimundi looks up the module
[23:45:05] *** Quits: ozten (ozten@19BD73A1.5D8BCA3A.A0C1B52F.IP) (Quit: ozten)
[23:45:36] <doomlord> i think i remember a few cases where more unique naming might have helped eg multiple uses of 'ctxt' in different modules (can defeat grep)
[23:46:01] <kimundi> tjc, It was: type syntax_context = uint; static empty_ctxt: uint = 0; enum syntax_context_{ empty_ctxt, ... } and of course a lot of local variables
[23:46:18] <kimundi> And similar situations
[23:46:32] <doomlord> i like short local variable names but not short  type names :)
[23:47:28] *** Quits: dcoates (dcoates@moz-BE33DA21.fw1.sfo1.mozilla.net) (Input/output error)
[23:47:31] <kimundi> Or things like 'struct Foo;' and 'fn Foo(...) -> Foo' - having an 'use ...::Foo' that actually imports two different items at once is confusing
[23:47:55] *** Joins: enix (enix@moz-A50569DD.c3-0.slvr-ubr1.lnh-slvr.md.cable.rcn.com)
[23:48:11] <tjc> yeah
[23:48:56] <kimundi> In fact, i'd like to propose, once it's feasible, that two items in the same declaration block may not share the same name
[23:49:22] <kimundi> At least for types and functions
[23:49:56] <kimundi> rusti: struct Foo(uint, uint); Foo
[23:49:57] -rusti- fn(uint, uint) -> main::Foo
[23:50:06] <kimundi> Also, that ^
[23:50:24] <kimundi> I know it's implemented as a function call, but it shouldn't appear as one in the tyope system
[23:50:35] *** Joins: infynyxx (infynyxx@DB780A29.749BA1D.DCC373F0.IP)
[23:52:22] *** Quits: eatkinson (eatkinson@moz-DA40A624.airbears2.berkeley.edu) (Quit: eatkinson)
[23:52:52] <benh> rusti: struct Foo(int); fn Foo(i: int) -> Foo { fail!("welp") }; Foo(42)
[23:52:57] -rusti- pastebinned 8 lines of output: http://ix.io/7Su
[23:53:21] <jmgrosen> is there a ",".join(gen) like function in rust?
[23:53:35] <ecr> brson: uh oh, the multithreaded tests failed on bors
[23:53:53] <kimundi> Sorry, gonna stop complaining now - I just find it a bit worrying/confusing
[23:55:51] <benh> rusti: let v = &["foo", "bar", "baz"]; v.connect(", ")
[23:55:52] -rusti- ~"foo, bar, baz"
[23:56:15] <dcrewi> so can anyone think of any way to write a test for my generate-a-random-bigint code?
[23:56:42] <kimundi> rusti: let v = &[".", ".", "."]; v.connect(" the dots! ")
[23:56:43] -rusti- ~". the dots! . the dots! ."
[23:57:03] <kimundi> why doesn't it work? /trollface
[23:57:58] <ecr> dscrewi: try to generate some common distributions and make sure the expected values and variances work out?
[23:59:59] <dcrewi> rand.rs doesn't do that

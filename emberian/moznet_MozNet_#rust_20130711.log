[00:00:41] *** Joins: ghrust (ghrust@79968228.6A2AE50.F3114085.IP)
[00:00:43] <pcwalton> keep in mind concurrent global GC is not 5x slower than C
[00:00:45] <sully> I mean, if "no function calls" is one of the things you need to do to write performant rust code, that's a pretty big disaster
[00:00:45] *** Parts: ghrust (ghrust@79968228.6A2AE50.F3114085.IP) ()
[00:01:01] *** Joins: dbaupp (Thunderbir@moz-712A1135.lns20.syd6.internode.on.net)
[00:01:06] <pcwalton> and we moved mountains to not have concurrent global GC
[00:01:10] <pcwalton> (although it also prevents data races)
[00:01:21] <strcat> we're slower than java in code with allocations because of how slow FFI is
[00:01:36] <strcat> java can do 2x slower than C++ 90% of the time
[00:01:53] <strcat> rust hits a nice 5-15% overhead for loops/numerics, it really falls apart when you do anything else
[00:01:54] *** Parts: mrbill (Mibbit@moz-91B5094F.hsd1.wa.comcast.net) ()
[00:01:59] *** Joins: mrbill (Mibbit@moz-91B5094F.hsd1.wa.comcast.net)
[00:02:32] <pcwalton> we shouldn't be 5-15% overhead for that
[00:02:38] <strcat> pcwalton: well, bounds checks
[00:02:39] *** concrete.mozilla.org sets mode: -M 
[00:02:42] <strcat> if you use unsafe it's the same
[00:02:52] <mrbill> what was the +M all about
[00:02:58] <xenocons> mrbill: bot spam
[00:03:03] <mrbill> ok
[00:03:04] <pcwalton> strcat: sure
[00:03:07] <strcat> overly sensitive rate limiting
[00:03:23] <strcat> whatever 'f [5c#C5,7j#R5,3k#K5,10m#M5,5n#N5]:10' in the mode means
[00:03:29] <mrbill> Anyway, let's say you have a network server that can handle ~100,000 concurrent connections
[00:03:32] <xenocons> getting 'capture of moved value' error hm
[00:03:41] *** Joins: int3_ (int3_@moz-ABE52D50.hsd1.ca.comcast.net)
[00:03:42] <mrbill> Let's say you want to have a task per connection
[00:03:46] <strcat> mrbill: figure out the upper bound per connection, allocate the memory needed to handle them all up front
[00:03:49] <xenocons> something has changed between 0.6 and 0.7 that i havent had to play with yet
[00:03:54] <strcat> mrbill: limit each connection to that bound
[00:04:05] <mrbill> Let's say each task has a 64k stack, which is reasonable
[00:04:08] <strcat> if it goes over, make the allocation fail
[00:04:18] <pcwalton> we need to fix the FFI, if only I didn't had a million language changes :)
[00:04:29] <mrbill> With memory overcommit turned off, this will consume ~6GiB of memory
[00:04:32] * jensnockert hugs pcwalton.
[00:04:49] *** Quits: true_droid (Adium@moz-123FD9B8.beck.volia.net) (Quit: Leaving.)
[00:04:54] <strcat> mrbill: if you can't allocate it up-front you can't assure it won't suddenly start dropping connections
[00:05:06] <strcat> you either have reliability (no dynamic allocations except within bounds) or you don't
[00:05:10] <jensnockert> (Without additional processes)
[00:05:18] <dbaupp> xenocons: is it this https://github.com/mozilla/rust/wiki/Doc-under-construction-FAQ#noncopyable-stack-closures ?
[00:05:22] <sigma> This is by far the most interesting irc room I've been in in ages. Despite 90% being way over my head.
[00:05:25] <xenocons> fn g(x:&~[u8]); fn main(){let x = ~[1u8]; let p = ~[1,2,3]; p.iter().advance |pp| { f(&x); }
[00:05:37] *** Quits: int3_ (int3_@moz-ABE52D50.hsd1.ca.comcast.net) (Ping timeout)
[00:05:39] <bjz_> pcwalton: h3r3tic is wondering if it will ever happen x)
[00:05:49] * jensnockert hugs bjz_
[00:05:50] <xenocons> dbaupp: nope it is only used once
[00:05:57] <strcat> mrbill: if each connection is given 16K of resources and you cap it at that (which rust can do), you can calculate the max # you can allow
[00:06:09] <strcat> and allocate all the resources you need for that # up-front
[00:06:33] <strcat> if you don't care about reliability it doesn't matter if there's overcommit or not
[00:07:00] <strcat> you can #[deny(heap_memory)] and use a custom allocator with rlimits
[00:07:08] <strcat> task-local rlimit
[00:07:50] <aatch> There's always going to be a point at which you hit resource limits. In the real world, that's where you spin up another server.
[00:08:52] <mrbill> The point of having memory overcommit turned off is that the process that exceeds its rlimit is the one that can potentially fail
[00:09:12] <dbaupp> xenocons: being used in a loop is being used more than once
[00:09:15] <mrbill> Instead of it causing some other process to die on a page fault
[00:09:30] <strcat> mrbill: rlimits are unrelated to overcommit
[00:09:43] <xenocons> dbaupp: ah...
[00:09:48] <strcat> "another process" dying is what happens *without* overcommit
[00:10:03] <strcat> the responsible process isn't killed, arbitrary processes have to deal with OOM
[00:10:13] <strcat> and the one causing it can keep consuming more
[00:10:41] <strcat> you can block or you can unwind/flush and exit
[00:10:44] <mrbill> With overcommit turned on, a process can die when it touches a page that does not have physical memory committed to it
[00:11:07] <strcat> mrbill: only if the process has the highest 'mem_usage * score_ratio'
[00:11:26] <strcat> it doesn't kill an arbitrary process or the first process to hit a page fault
[00:11:43] <aatch> can't you exclude applications from the OOM killer?
[00:11:43] <xenocons> hm
[00:11:47] <strcat> aatch: yes
[00:11:53] <strcat> aatch: you can set the ratio their memory is multiplied by
[00:12:05] <strcat> aatch: you can make them viewed as using 0% of the system memory, they'll be killed last
[00:12:09] <strcat> but by doing that you trust them
[00:12:14] <heftig> are we talking about linux? does that even support really turning overcommit off?
[00:12:19] <aatch> heftig, yes
[00:12:24] <mrbill> Yes, it does
[00:12:42] <aatch> there's just a file.
[00:12:45] <xenocons> x.iter().advance |p| { ... f(p) } right?
[00:13:52] <mrbill> Even if the process picked by the OOM killer heuristic is not "arbitrary", you might still end up with the "wrong" process getting tapped
[00:13:52] *** Joins: ghrust (ghrust@AD60B2E3.6A2AE50.F3114085.IP)
[00:13:52] <ghrust> 01[13rust01] 15bors 04force-pushed 06auto from 1448d8bf3 to 14e7040e8: 02http://git.io/N3iJvQ
[00:13:52] *** Parts: ghrust (ghrust@AD60B2E3.6A2AE50.F3114085.IP) ()
[00:13:54] *** Joins: ghrust (ghrust@5FEF1C87.6A2AE50.F3114085.IP)
[00:13:54] <ghrust> 01[13rust01] 15bors pushed 2 new commits to 06auto: 02http://git.io/24pjhg
[00:13:54] <ghrust> 13rust/06auto 146d4d2c9 15Alex Crichton: Don't loop infinitely on 0-size structs in repr...
[00:13:54] <ghrust> 13rust/06auto 149b5d523 15bors: auto merge of #7683 : alexcrichton/rust/issue-7625, r=thestinger...
[00:13:55] *** Parts: ghrust (ghrust@5FEF1C87.6A2AE50.F3114085.IP) ()
[00:14:45] <XgF> strcat: two comments: 1. as a libc author, in C, if (f|vf|s|sn|vs|vsn)printf() *ever* allocates it is a horrible quality implementation and the author should be impaled with a large stake (I stare intently at newlib here...)
[00:14:48] <strcat> heftig: you can partition memory with memory cgroups and enable/disable the oom killer per cgroup too
[00:15:02] *** kimundi is now known as zz_kimundi
[00:15:20] *** Joins: dherman (dherman@moz-BBE3ABD.mv.mozilla.com)
[00:15:20] *** ChanServ sets mode: +o dherman
[00:15:25] <xenocons> rusti: fn f(x:&~[u8], u:int){print(fmt!("[%d]%? ",u,x))}; let x = ~[1u8]; (~[1,2,3]).iter().advance|pp|{f(&x,pp);}
[00:15:26] -rusti- more than 5 lines of output, pastebinned: http://sprunge.us/cDdM
[00:15:35] <mrbill> The idea is that if you turn off overcommit and limit a process to a certain vmem size with rlimit, when that process allocate vmem it is also guaranteed that physical memory is available to back it
[00:15:41] <XgF> 2. Commiting, say, 16kB of RAM as an emergency unwind stack which threads take in turn is not unreasonable
[00:15:57] <mrbill> And when it later touches the pages, it won't cause some potentially unrelated process (or itself) to die
[00:16:10] *** Joins: dew (Instantbir@moz-66796D51.dhcp.stls.mo.charter.com)
[00:16:10] *** Joins: ChrisMorgan (chris@moz-6AC741CA.static.tpgi.com.au)
[00:16:14] <XgF> Note that the C++ unwinder runtime takes exactly the later design decision to handle bad_alloc
[00:16:25] <ChrisMorgan> libstd doesn't compile with rustc -Z debug-info :-(
[00:16:41] <mrbill> With memory overcommit turned on, pre-allocating memory to ensure you won't fail is meaningless, because you might fail when you first touch the page
[00:17:01] <mrbill> Or some other process will get the axe instead.
[00:17:04] <strcat> mrbill: that's not how OOM works
[00:17:08] <strcat> you can partition memory per-cgroup
[00:17:12] <strcat> it's not a global resource
[00:17:13] <heftig> how does windows handle paging? i think it always maps the entire ram to disk, with the pagefile for anonymous memory?
[00:17:25] <XgF> Windows does not overcommit
[00:17:29] <XgF> Windows has it easy, no fork
[00:17:34] <strcat> memory.oom_control
[00:17:36] <strcat> oom_kill_disable 0
[00:17:38] <strcat> under_oom 0
[00:17:40] <strcat> per cgroup
[00:17:42] <strcat> and you can set limits
[00:17:55] <jensnockert> heftig: Yeah, it never overcommits, but doesn't run without swap either.
[00:17:56] <pcwalton> yay, rust without the Copy bound is bootstrapping
[00:18:06] <ChrisMorgan> And someone's already reported that, https://github.com/mozilla/rust/issues/7603
[00:18:13] <strcat> so you can partition 200MiB to a service and turn off the oom killer for it
[00:18:19] <strcat> malloc() will fail after it hits that limit
[00:18:42] <jensnockert> heftig: When it does an anon mmap, it creates a file for it.
[00:18:59] <strcat> rusti (the channel bot) is in a cgroup with an 128MiB limit, with OOM killing on
[00:19:04] <strcat> but it has a timeout so I could turn it off...
[00:19:11] <heftig> jensnockert: it doesn't use the pagefile for that?
[00:19:21] <mrbill> And if it touches a page and the kernel can't service it because it's out of physical memory, what happens?
[00:19:34] <strcat> mrbill: you can partition memory per *cgroup*
[00:19:37] <heftig> strcat: oh, also looks like the kernel will get a completely new cgroup interface named "sane behavior"
[00:19:40] <jensnockert> heftig: Essentially.
[00:19:52] <mrbill> So what happens?
[00:19:57] <xenocons> im not sure i understand the capture syntax... baz(13, |x| callback(x))
[00:20:07] <strcat> mrbill: it won't happen
[00:20:08] <aatch> xenocons, there is no capture syntax
[00:20:15] <jensnockert> heftig: That's how it appears on disk, but I think it does something more fancy in kernel-space.
[00:20:18] <strcat> mrbill: you don't partition out more memory than you have
[00:20:18] <xenocons> hmm
[00:20:23] <aatch> (not anymore either, but I don't think there was in 0.6 either)
[00:20:29] <mrbill> So the kernel will ensure that physical memory exists to back all virtual allocations
[00:20:38] <jensnockert> heftig: I never understood the object manager or what it is called.
[00:20:40] *** Quits: tikue (tkuehn@moz-BBE3ABD.mv.mozilla.com) (Quit: tikue)
[00:20:41] <mrbill> How is that not equivalent to turning off overcommit?
[00:20:44] <strcat> mrbill: yes, if you partition it by cgroup
[00:20:49] <heftig> VmallocTotal:   34359738367 kB
[00:20:58] <strcat> mrbill: because it's per group, it's reliable/contained
[00:21:05] <heftig> I have way more vm than physical memory
[00:21:12] <aatch> Guys, I don't think this is getting us anywhere.
[00:21:18] <jensnockert> ^
[00:21:58] <strcat> you can say sshd gets 30MiB and everything else is capped at 2970MiB (if you have 3000MiB) and sshd will have that all to itself, always
[00:22:05] <mrbill> At any rate, if you ensure that you have physical memory to back virtual allocations, regardless of whether it is per-cgroup or not, you can not longer be extravagant with virtual address space
[00:22:14] <mrbill> Which means you need segmented thread stacks to be able to use tasks scalably
[00:22:25] <strcat> mrbill: how are you going to handle OOM with segmented stacks?
[00:22:28] <XgF> mrbill: Not necessarily segmented. Just Windows style __chkstack
[00:22:35] <XgF> And, indeed, Windows handles this
[00:22:43] *** Quits: graydon (Adium@A5087023.2354C43D.D8E68FF6.IP) (Quit: Leaving.)
[00:22:48] <xenocons> aatch: im struggling to work out this http://codepad.org/SI2RqUdA
[00:22:56] *** Joins: erickt1 (Adium@49C4075F.3AC15C18.2321E71E.IP)
[00:23:14] <aatch> You're arguing about the suitability of an *unfinished* language for military-grade applications. Rust will eventually have a way to handle all of this. But in the mean time, *nothing* is particularly good at handling OOM.
[00:23:14] <xenocons> (it isnt moved right? unless its the pointer thats moved?)
[00:23:16] <XgF> Windows throws an exception when any *further* expansion of your stack would blow you up. 
[00:23:54] <mrbill> I know the language is unfinished.  The reason I brought this up is as a use case data point for discussion of how to handle stack allocation in the future.
[00:24:00] *** Joins: jdm (jdm@moz-B566DF75.dsl.teksavvy.com)
[00:24:03] <aatch> xenocons, what's the signature of firstByteIndexOf
[00:24:04] <aatch> ?
[00:24:10] <strcat> mrbill: what's the plan for handling OOM in segmented stacks?
[00:24:16] <strcat> any call can really use stack
[00:24:24] <xenocons> aatch: sorry, fn firstByteIndexOf (haystack: &~[u8], pattern: ~[u8]) -> uint {
[00:24:27] <strcat> unwinding does function calls
[00:24:32] <strcat> do you reserve it?
[00:24:46] <strcat> 64K per task to probably be able to unwind, but maybe not?
[00:24:55] <aatch> xenocons, any reason why it can't take two &[u8]'s?
[00:25:04] <XgF> strcat: Tell developers "Your destructor must use no more than 3kB of RAM. If it can manage that, it is safe"
[00:25:29] <xenocons> aatch: mostly that the libc stuff returns ~[u8]
[00:25:37] <strcat> XgF: you can't provide that guarantee for a graph/tree
[00:25:42] <mrbill> Maybe you can't and the process dies.  Maybe recovery is not possible in practice.  The point is allow using lots of tasks without consuming excess vmem.
[00:25:44] <xenocons> (or did in 0.6)
[00:25:50] <aatch> xenocons, ~[u8] will coerce to &[u8]
[00:25:56] <xenocons> hm
[00:26:05] <mrbill> Because the process is vmem limited.
[00:26:06] <XgF> strcat: In finite address space you can only have finite depth
[00:26:19] <strcat> XgF: sure, so you can't guarantee unwinding will succeed
[00:26:33] <strcat> so how is this different than overcommit again?
[00:26:42] <xenocons> aatch: heh, this gets me past this error
[00:26:48] <XgF> strcat: The *app developer* can engineer their application to guarantee unwinding will succeed
[00:27:01] <jensnockert> I could see this being an issue in an embedded system, but why not just have multiple processes and let some of them die on OOM on *nix?
[00:27:03] <strcat> XgF: they can engineer it to always succeed by allocating all the resources up from
[00:27:07] <xenocons> (or... i think it does)
[00:27:18] <strcat> get memory from mmap, memset it
[00:27:36] <strcat> up front*
[00:27:45] <xenocons> aatch: is it auto coerced or do i need to do something
[00:27:54] <xenocons> fn firstByteIndexOf (haystack: &[u8], pattern: &[u8]) -> uint 
[00:27:55] <strcat> if there's no upper bound on memory usage there's no guarantees about reliability
[00:28:02] <aatch> (There is very, very little reason to take a &~[u8], the only case I can think of is wanting to know the capacity, but that is literally it. you can't move out of the & and you can't modify the array)
[00:28:02] <strcat> you have to care a lot about memory fragmentation
[00:28:08] <aatch> xenocons, that will work fine
[00:28:30] <xenocons> aatch: i still get the capture of moved variables issue
[00:28:35] <xenocons> should i be passing it in as & still?
[00:28:35] <XgF> strcat: Or you can engineer it to never just keel over and die
[00:28:53] <strcat> XgF: so how do you plan on bounding memory fragmentation?
[00:28:56] <xenocons> (i may need to change my file read function signature now)
[00:29:13] <aatch> rusti: fn foo(a: &[int]) -> uint { a.len() } let b = ~[1,2,3]; foo(b)
[00:29:14] -rusti- 3
[00:29:15] <mrbill> Anyway, thanks for hearing me out.  I just wanted to point out that in some applications you have to treat vmem as a limited resource, and this could influence that ability to use tasks idiomatically in those applications
[00:29:25] <xenocons> hm
[00:29:48] <xenocons> that...
[00:29:50] <XgF> strcat: Some servers, for example, cannot operate in finite, developer determined resource counts, but they can be engineered so that, in the case of OOM, they unwind and fail *that request* gracefully
[00:29:55] <mrbill> Being able to write in a synchronous style but have everything scheduled efficiently in userspace by the scheduler is really nice.
[00:30:01] <jensnockert> mrbill: If you are seriously concerned, you should take it on the mailing list. Anything official happens there or on Github.
[00:30:17] <aatch> mrbill, but there will always be cases where you can't have idiomatic usage.
[00:30:18] <mrbill> OK
[00:30:22] *** Quits: hjr3 (hradtke@1A0AE795.28A5F6C3.A2D40ED2.IP) (Quit: My MacBook has gone to sleep. ZZZzzzâ€¦)
[00:30:33] <strcat> XgF: sure, and whether or not the system does overcommit you can place an upper bound on the memory they can use
[00:30:42] <mrbill> Maybe.  It depends on what tasks are intended for.
[00:30:52] <strcat> and you can guarantee they will have that memory, or not
[00:31:15] <mrbill> If it includes writing scalable network servers in a direct, synchronous style where the event handling is abstracted away, then it's something to keep in mind.
[00:31:17] *** Joins: mschifer (Adium@moz-E8984E2A.public.wayport.net)
[00:31:23] <pcwalton> make tidy caught my rename of "Copyright" to "Cloneright"
[00:31:29] <pcwalton> regexes gone awry :(
[00:31:33] <huseby> has there been any work on porting the rust compiler to openbsd?
[00:31:42] <strcat> servo doesn't need lightweight tasks, neither does a game
[00:31:50] <strcat> and that's all I've seen people writing in rust
[00:31:56] <XgF> Segmented vs linear commit on demand is a distraction: out-of-stack should be a case which can be handled
[00:31:59] <aatch> huseby, no. How much work would it need?
[00:31:59] <strcat> is there even an http server lib that works right now?
[00:32:02] <xenocons> aatch: ok now im using two &[u8]and passing in bytes as is, i get capture of moved value `bytes` still
[00:32:08] <huseby> I forked the repo a few days ago and made a few changes to get the ./configure step to complete properly
[00:32:22] <strcat> XgF: well we don't currently try to handle it in any way
[00:32:28] * jensnockert hugs pcwalton: I know how that feels.
[00:32:29] *** Quits: jdm (jdm@moz-B566DF75.dsl.teksavvy.com) (Ping timeout)
[00:32:30] <huseby> but when I run gmake it fails almost immediately
[00:32:32] <aatch> xenocons, I'm not sure then without taking a proper look at your code and I don't have time to right now sorry
[00:32:34] <strcat> XgF: we don't even handle failures inside destructors
[00:32:35] <pcwalton> heh
[00:32:38] <pcwalton> it's just amusing
[00:32:38] <xenocons> aatch: np
[00:32:42] <mrbill> I thought Rust was intended to be a general purpose systems language and not just for writing web browsers and NES emulators
[00:32:43] <pcwalton> "floatersection" was better though
[00:32:53] <pcwalton> when I renamed int -> float
[00:32:57] <dbaupp> pcwalton: pi was called "somethingsomething staticant" for a few months after the const -> static change
[00:33:03] <pcwalton> oh yeah, I remember that
[00:33:06] <pcwalton> Archimedes' staticant
[00:33:07] *** Joins: ross (ross@moz-8A84103E.br.br.cox.net)
[00:33:10] <strcat> mrbill: it's not what people are using it for though, from what I've seen
[00:33:12] <mrbill> I agree that you don't need tons of tasks for an HTML layout engine or a game
[00:33:16] <aatch> dbaupp, I think there are still a few staticants lying around
[00:33:21] <xenocons> btw, if you specify the return type of a function as -> &[u8] if the function normally returns ~[u8] will this coerce?
[00:33:26] <dbaupp> aatch: awesome
[00:33:32] <mrbill> Tasks are a really nice abstraction, and it would be a shame to restrict their use cases.
[00:33:34] * dbaupp doesn't want anyone to change them
[00:33:50] <mrbill> Anyway, have a nice day everyone.
[00:33:55] <mrbill> bye
[00:33:56] <strcat> mrbill: they're already no good for parallelism ;p
[00:33:58] <strcat> \o
[00:34:06] *** Parts: mrbill (Mibbit@moz-91B5094F.hsd1.wa.comcast.net) ()
[00:34:07] <huseby> I was hoping that somebody else had tried to compile on openbsd recently
[00:34:28] <sully> ugh, I hate when I need to modify type_uses
[00:34:30] <sigma> I was planning on writing a jabber server as a learning project... when I eventually get around to it
[00:34:36] <huseby> so I could have a partner in crime to help work out the wrinkles
[00:34:42] <XgF> strcat: Failures inside destructors are an... interesting case. Especially OOM
[00:34:42] <sully> because I am just so unconvinced that type_uses is right at all
[00:34:48] <huseby> I'm new to the rust build setup
[00:35:03] <engla> xenocons: no, you can't borrow out of a ~[] that goes out of scope
[00:35:18] <xenocons> ok
[00:35:43] <strcat> sully: afaict it thinks destructors aren't generic
[00:35:48] <mark_edward> strcat: do you want to get rid of Rust's lightweight tasks?
[00:35:56] <strcat> mark_edward: by default, yes
[00:36:17] <pcwalton> well wait, lightweight means different things
[00:36:21] <pcwalton> lightweight isn't just about stack size
[00:36:25] <engla> xenocons: whenever you return a & it needs a lifetime
[00:36:27] <mark_edward> i think it's a really nice abstraction though... it's the only thing i like about go, and it makes concurrency pretty easy.
[00:36:27] <strcat> well 'lightweight' to me means stack size
[00:36:38] <pcwalton> it's also for work stealing
[00:36:43] <pcwalton> lightweight tasks are stealable
[00:37:19] <strcat> pcwalton: well if tasks represent work
[00:37:22] <mark_edward> i like being able to do this sort of stuff: https://github.com/MarkJr94/rusty_feds/blob/master/main.rs#L163-L174
[00:37:46] <mark_edward> i wouldn't try and spawn 20 tasks if i thought they represented full threads...
[00:37:47] <pcwalton> for example, and this is the use case I really care about, if you have a task blocked on a port you can immediately switch to that task without a round trip through the scheduler when sending
[00:37:50] <aatch> huseby, well it works on freebsd, whether that means it should work on openbsd... I don't know.
[00:38:15] <huseby> aatch: who would be the person(s) to ping when I run into issues...
[00:38:17] *** Joins: tikue (tkuehn@moz-BBE3ABD.mv.mozilla.com)
[00:38:20] <huseby> ?
[00:38:23] *** Joins: Yurume (yurume@AC58A8CE.8A059B47.E313B915.IP)
[00:38:24] <aatch> huseby, no idea.
[00:38:32] <aatch> What issues do you get right now?
[00:38:32] <huseby> right now I'm trying to figure out why the make step is failing
[00:38:33] <strcat> pcwalton: that's just userland vs OS threads though, is it really where 'lightweight' is used?
[00:38:37] <aatch> (I'
[00:38:44] <huseby> it's not easy to get it to show what commands are being run and which command failed
[00:38:52] <strcat> "lightweight thread" seems like a very overloaded term
[00:39:00] <XgF> My general opinion is destructors should be strictly "exception free" and if a hypothetical "_checkstack" function determines stack exhaustion inside a destructor, the signalling is delayed until the destructor returns
[00:39:01] <aatch> huseby, `gmake VERBOSE=1`
[00:39:11] *** Quits: enix (enix@moz-A50569DD.c3-0.slvr-ubr1.lnh-slvr.md.cable.rcn.com) (Quit: Konversation terminated!)
[00:39:18] *** Joins: enix (enix@moz-A50569DD.c3-0.slvr-ubr1.lnh-slvr.md.cable.rcn.com)
[00:39:24] <strcat> I've always interpreted it as meaning small stacks like Go and "stackless" python
[00:39:42] <pcwalton> strcat: that's what I think of as lightweight
[00:39:44] <aatch> I'm assuming gmake works the same as regular make on Linux
[00:39:56] <mark_edward> strcat: also the implication of the "lightweight threads" being multiplexed onto hardware threads
[00:39:59] <pcwalton> but yeah, the definitions are fuzzy
[00:40:02] <huseby> aatch: let me see if that gives me useful info
[00:40:03] <pcwalton> mark_edward: that will not change
[00:40:11] <xenocons> hrm
[00:40:21] <xenocons> LLVM ERROR: Incompatible object format!
[00:40:38] <xenocons> rusti: fn foo(a: &[int]) { print(fmt!("%? ", a.len())); } let b = ~[1,2,3]; let q = ~[1,2]; for q.iter().advance|x|{foo(b)}
[00:40:39] -rusti- <anon>:7:115: 7:116 warning: unused variable: `x` [-W unused-variable (default)]
[00:40:39] -rusti- <anon>:7          fn foo(a: &[int]) { print(fmt!("%? ", a.len())); } let b = ~[1,2,3]; let q = ~[1,2]; for q.iter().advance|x|{foo(b)}
[00:40:39] -rusti-                                                                                                                             ^
[00:40:39] -rusti- 3 3 ()
[00:40:45] <xenocons> strange, works here
[00:40:46] <mark_edward> but if you make the default stack size big, then could i freely spawn 20, or hundreds of them?
[00:41:01] <Luqman> xenocons: windows?
[00:41:04] <xenocons> Luqman: yeh
[00:41:05] <jensnockert> mark_edward: Yeah, at least on 64-bit systems.
[00:41:27] <jensnockert> mark_edward: The OS doesn't actually commit memory to them until you use it.
[00:41:28] <Luqman> xenocons: yea, rusti on windows is broken. Also the rusti bot in this channel is not actually the same rusti
[00:41:37] <strcat> jensnockert: windows does
[00:41:41] <mark_edward> what about things like having a server spawn a task for every connection?
[00:41:42] <sigma> the ability to spawn tasklets with reckless abandon was the feature that keeps me going back to stackless python. It's a _very_ convenient feature
[00:41:49] <xenocons> Luqman: right yeah
[00:41:58] <jensnockert> strcat: It commits disk space.
[00:42:05] <strcat> jensnockert: ah
[00:42:33] <xenocons> strangely the code compiles for this small example
[00:42:35] <aatch> sigma, the current plan is to default to large initial stacks.
[00:42:42] <xenocons> doesnt seem to for my actual code though
[00:42:51] <strcat> jensnockert: that seems like a pretty theoretical distinction from overcommit
[00:42:56] <strcat> you can't recover from that much swapping
[00:43:02] <strcat> if it actually has to do it
[00:43:05] <mark_edward> strcat: but then you couldn't spawn tasks for say every connection on an IRC server
[00:43:16] <jensnockert> strcat: Yes.
[00:43:24] <aatch> With an option of spawning with small tasks
[00:43:33] <jensnockert> mark_edward: Sure you could, the stack size wouldn't make any difference.
[00:43:45] <xenocons> oh interesting...
[00:43:50] <xenocons> it compiles when i remove the do spawn { }
[00:44:00] <dbaupp> mark_edward: for the -Z debug-info failure, does it require the method call?
[00:44:13] <strcat> anyway I only want it to use large stacks by default... because servers aren't the general case
[00:44:14] <dbaupp> ChrisMorgan* ^ 
[00:44:19] <mark_edward> dbaupp: i think you're asking the wrong person
[00:44:21] <dbaupp> mark_edward: (sorry, wrong person.)
[00:44:21] <strcat> the fact that no one has written an http server in rust proves that
[00:44:29] <ChrisMorgan> dbaupp: yes, it does.
[00:44:41] <xenocons> for some reason do spawn { } does some extra closure funk?
[00:44:48] <strcat> you'd still be able to ask for a small stack
[00:44:52] <mark_edward> strcat: so maybe a do spawn_thread {} and a do spawn_task {}? (names non-final)
[00:44:52] <aatch> so task::spawn { ... } <- large stack. task::spawn_size(2048) { ... } <- 2KiB initial stack
[00:44:54] <ChrisMorgan> (I presume you're commenting on my minimal test case for https://github.com/mozilla/rust/issues/7603.)
[00:45:05] <aatch> mark_edward, still both tasks
[00:45:05] <dbaupp> ChrisMorgan: yep
[00:45:09] <strcat> like what aatch said
[00:45:18] *** Quits: mschifer (Adium@moz-E8984E2A.public.wayport.net) (Quit: Leaving.)
[00:45:24] <strcat> if you want what we have now, pass 0
[00:45:32] <mark_edward> strcat: but i don't know how much memory a certain function needs...
[00:45:44] <strcat> mark_edward: so pass 0 if you plan on using it to handle I/O
[00:45:47] <ChrisMorgan> dbaupp: I believe that to be a minimal test case. (Not to say that there won't be other more minimal test cases, but that one won't be reduced any further.)
[00:45:51] <mark_edward> will the small stacks still be segmented?
[00:45:57] <strcat> otherwise if you don't want it 5x slower than C, don't pass a size
[00:46:00] <aatch> since the pain comes from allocating the new stack
[00:46:00] <strcat> mark_edward: yes
[00:46:10] <dbaupp> ChrisMorgan: yeah, looks like it. I was just double checking. :)
[00:46:11] <aatch> mark_edward, they all will be.
[00:46:18] <aatch> (well mostly)
[00:46:19] <strcat> aatch: allocating/deallocating and also the loss of data locality from splits
[00:46:25] *** Quits: jorendorff (jorendorff@moz-30F4FB9E.hfc.comcastbusiness.net) (Quit: jorendorff)
[00:46:30] <strcat> and the checks are pretty expensive but I'm not bringing that up atm.
[00:46:40] <aatch> strcat, oh yeah, I always forget about the cache 
[00:46:43] <jensnockert> mark_edward: If you don't know/care, just allocate a large stack, the OS still provides memory in 4kB chunks to you as you use it (on x86-*nix)
[00:46:44] <strcat> if all you want is safety you can make some guard pages and only add checks for allocations larger than the guard size, afaik
[00:46:59] <strcat> afaik that's what stack smashing protection does
[00:47:06] <strcat> with -fstack-protector-all
[00:47:10] <jensnockert> mark_edward: And you don't take the penalty from segmented stacks.
[00:47:12] <ChrisMorgan> dbaupp: my first attempted reduction made the trait default method empty, but it doesn't fail thenâ€”requires a statement of some form, hence the `()`
[00:47:25] <dbaupp> ChrisMorgan: (I just refer it two people who know what they're talking/coding about wrt default methods and debug info)
[00:47:48] <ChrisMorgan> Oh, good. I was just taking a look at the relevant code and deciding that I probably can't fix it myself.
[00:47:52] <dbaupp> ChrisMorgan: you could possibly add that to the bug, because it seems like a non-trivial condition.
[00:47:53] <strcat> jensnockert: windows apparently has a 512 limit by default on open files anyway
[00:48:11] <jensnockert> strcat: It is really small on XP at least, but don't know how it is now.
[00:48:57] <mark_edward> jensnockert: but we can't ignore wiwndows
[00:48:57] <strcat> jensnockert: http://msdn.microsoft.com/en-us/library/kdfaxaay(v=vs.120).aspx
[00:49:02] <strcat> The C run-time libraries have a 512 limit for the number of files that can be open at any one time. Attempting to open more than the maximum number of file descriptors or file streams causes program failure. Use _setmaxstdio to change this number.
[00:49:08] <strcat> mark_edward: windows already can't scale by default
[00:49:10] <mark_edward> more people could end up using rust on windows than on linux
[00:49:11] <strcat> 512 connections
[00:49:22] <XgF> strcat: _C run-time libraries_
[00:49:26] <strcat> XgF: rust uses those
[00:49:28] <XgF> msvcrt != windows!
[00:49:39] <mark_edward> strcat: what do you mean it can't scale? there are lots of windows servers and stuff
[00:49:47] <jensnockert> mark_edward: No, but Windows does the same thing but in 64kB chunks.
[00:49:49] <strcat> XgF: the kernel API isn't documented, the windows runtime == windows as far as rust is concerned
[00:49:54] *** Joins: jorendorff (jorendorff@moz-30F4FB9E.hfc.comcastbusiness.net)
[00:49:57] <sigma> Hmm, I suppose the "many concurrent connections" use case should probably be implemented somwhat like I'd implement it in erlang, ie I should expect and recover from failure, so it wouldn't actually matter if the tasks were killed by oom.
[00:49:58] <strcat> XgF: it won't ever do syscalls directly there
[00:50:01] <XgF> strcat: msvcrt != kernel32.dll!
[00:50:10] <bjz_> mark_edward: indeed, game devs *need* Windows support, unfortunately
[00:50:12] <strcat> XgF: we're not using kernel32.dll... we're using libc
[00:50:13] <XgF> msvcrt is limited. kernel32 is not. kernel32 *IS* the Win32 API
[00:50:25] <sigma> Is there any plan or thoughts around making oom only kill the task rather than the whole process? or is the overhead too large?
[00:50:42] <XgF> Anyway 512 actual files open at once is rarely a problem...
[00:50:52] <jensnockert> sigma: The OOM is a OS facility, it doesn't know anything about Rust.
[00:50:55] <XgF> Sockets are a different matter (and on Windows msvcrt won't evn touch them)
[00:51:32] <XgF> (without shennanegins involving _open_osfhandle)
[00:51:35] <ecr> sigma: you should ask bblum. he's working on the task killing system.
[00:51:42] <strcat> I'm fine with rust using segmented stacks when overcommit isn't around. I don't really care
[00:52:06] <XgF> No need for segmented. Just "manual commit"
[00:52:10] <XgF> Windows and Linux both offer that
[00:52:19] <strcat> "manual commit"?
[00:52:46] <XgF> strcat: prod the stack you're about to expand into and trap the failure
[00:53:11] <strcat> XgF: so lazy allocation + handling the faults?
[00:53:24] <XgF> strcat: Yeah
[00:53:29] *** Quits: erickt (erickt@8C9ECD8F.3A598286.F12515B4.IP) (Quit: Leaving.)
[00:53:33] <strcat> didn't know you could do that, that seems ideal
[00:53:41] <mark_edward> brson: ping
[00:53:49] <jensnockert> Sounds like a race-condition waiting to happen :S
[00:53:54] <XgF> As said, if you do it 4kB ahead you can handle it if you can fit your destructors+unwinder in <4kB
[00:53:57] *** Quits: pnathan1 (Adium@B9840254.2CD8A5F8.477B877D.IP) (Quit: Leaving.)
[00:54:01] *** Quits: bjz_ (brendanzab@B398BE78.F804C29E.D35A31DF.IP) (Ping timeout)
[00:54:05] <strcat> how much overhead does that have?
[00:54:13] <XgF> Windows already mandates it
[00:54:15] *** Joins: SiegeLord (sl@moz-CAF07B4C.hsd1.ma.comcast.net)
[00:54:28] *** Joins: bjz (brendanzab@B398BE78.F804C29E.D35A31DF.IP)
[00:54:43] <XgF> Your access will fault with an out of stack exception and then give you your last 4kB
[00:55:01] <XgF> On Linux... requires some trickery and sigaltstack I expect
[00:55:45] <strcat> XgF: what if you overshoot the last few pages?
[00:55:50] <strcat> as in a big uninit array
[00:56:14] <XgF> strcat: Windows will invalid access fault you. You *must* call __chkstack if you're allocating >=4kB
[00:56:29] <strcat> ok so the same as ssp in linux
[00:56:52] <XgF> For POSIX: take the SEGV on the altstack, run the unwinder there
[00:56:53] *** Quits: parcha (quassel@moz-A9A9F340.hsd1.ma.comcast.net) (Ping timeout)
[00:57:20] <strcat> XgF: but that's if you overshoot the process one
[00:57:22] <strcat> what about a thread?
[00:57:35] * aatch has been reading too much assembly, read `call __chkstack` as a call instruction
[00:57:39] <XgF> strcat: All thread stacks must be allocated like that
[00:57:53] <strcat> how does it know the thread overshot the end of the stack?
[00:58:07] *** Quits: azita (Azita@moz-BBE3ABD.mv.mozilla.com) (Quit: azita)
[00:58:11] <strcat> oh because you have those checks
[00:58:12] <strcat> nvm
[00:58:33] <strcat> anyway that'd be much saner than what we have atm
[00:58:46] <strcat> guard pages at the end, checks on allocations larger than the guard pages
[00:59:21] <strcat> you can ask pthread for guard pages so I guess that's the same idea
[00:59:36] <mark_edward> is there any way to do signals with Rust?
[00:59:39] <XgF> strcat: Remember, Windows will just kill you if you fiddle with ESP/RSP behind its back
[00:59:56] <XgF> I'm not sure if a userspace scheduler which doesn't crash is possible without fibres =/
[01:00:06] *** Joins: parcha (quassel@moz-A9A9F340.hsd1.ma.comcast.net)
[01:00:09] <strcat> XgF: well afaik that's what rust is doing on windows atm
[01:00:10] <XgF> Or Vista's "Usermode Scheduling" thingy
[01:00:25] <XgF> strcat: Fibres or fiddling?
[01:00:34] <aatch> mark_edward, not really atm.
[01:00:40] <strcat> XgF: implementing it itself
[01:00:49] <mark_edward> aatch: okey dokey
[01:00:54] <XgF> Then it will break as soon as people start using the actual Win32 API
[01:01:00] <strcat> XgF: don't think it can use something else, the scheduler and I/O handling is all libuv
[01:01:26] <XgF> Win32 fibers are just cooperative thread switching. no scheduler
[01:01:57] <strcat> XgF: we're not using fibers though
[01:01:59] <aatch> XgF, same as the Rust scheduler.
[01:01:59] <XgF> But if you just swap out RSP, the exception handling system will get awfully confused when it needs to take an exception in user space and then you die
[01:02:30] <strcat> XgF: we can't handle foreign exception ABIs anyway
[01:02:43] <strcat> if you can C++ and it throws you're screwed (on any platform)
[01:03:02] <huseby> aatch: so the trick on openbsd is teaching the configure and makefiles to use gmake, gsed, egcc, and eg++
[01:03:04] <XgF> strcat: Windows takes and traps its' own exceptions internally inside several Win32 API functions
[01:03:18] <aatch> huseby, ok, doesn't seem too bad then.
[01:03:19] <huseby> since openbsd has their own, non-gnu version of make and sed that don't work
[01:03:22] <XgF> Anyway, SEH/VEH are really more "Better signals" for these purposes
[01:03:35] <huseby> and gcc-4.7 and g++-4.7 are called egcc and eg++ respectively
[01:03:47] <huseby> to separate them from the gcc-4.2 and g++-4.2 default toolchain
[01:03:56] <strcat> XgF: well I really don't think it can ever use their fibers
[01:03:58] *** Quits: carllerche (carllerche@moz-BF6CB667.hsd1.ca.comcast.net) (Quit: carllerche)
[01:04:01] <huseby> aatch: it's just a matter of working through the issues as they come up
[01:04:27] <huseby> I've got the configure script properly probing, detecting openbsd, and setting up config options properly
[01:04:47] <huseby> my current issue is platform.mk:132: *** please try on a system with gcc or clang.
[01:05:00] <aatch> huseby, cool. If you can get it working, then feel free to open a PR for it. OpenBSD still won't be a tier 1 platform, but we have a FreeBSD testing platform.
[01:05:03] <huseby> it's because the CFG_C_COMPILER is set to egcc not gcc
[01:05:29] <strcat> XgF: by definition rust tasks are mixed 1:1 and N:M threading
[01:05:32] <huseby> I run openbsd on lots of little machines (router, etc) and would like to play around with rust on those
[01:05:34] <XgF> strcat: You don't really havea  choice (Unless theres some Rtl*** API I've forgotten). Your other option is randomly blowing up
[01:05:39] <huseby> aatch: thanks for the encouragement
[01:05:48] <huseby> I'll report back when I have something interesting
[01:06:51] <aatch> huseby, yeah, if you could make it just detect that 'gcc' or 'g++' is in the string for those cases, it would probably be more flexible.
[01:06:53] <strcat> XgF: afaik we're just doing what Go is on windows
[01:06:58] *** Quits: brson (brson@moz-BBE3ABD.mv.mozilla.com) (Ping timeout)
[01:06:59] *** Joins: LimeBurst (me@247D1419.D73964AC.27A8748.IP)
[01:07:29] <mark_edward> is any aware of the performance implications of using many port/chan pairs vs using a sharedchan and a single port?
[01:07:33] <jensnockert> strcat: I think that is randomly blowing up.
[01:08:06] *** Quits: dherman (dherman@moz-BBE3ABD.mv.mozilla.com) (Quit: dherman)
[01:09:02] *** Quits: sigma (sigma@51C589B3.EF2694B5.DFAC6AA7.IP) (Client exited)
[01:09:09] <strcat> jensnockert: well someone should probably report that... because people are busy working on new scheduling and I/O stuff with the assumption it will work
[01:09:14] *** Quits: q66 (q66@6EE9DE40.46454B5D.33AABD5F.IP) (Quit: Leaving)
[01:09:21] <strcat> I don't know anything about windows
[01:10:36] <jensnockert> strcat: I think the issue is LLVM.
[01:11:16] <jensnockert> strcat: I am not saying that it couldn't work, but I doubt you could write ye olde standard windows program and expect it to work.
[01:11:32] <jensnockert> strcat: LLVM doesn't support SEH or VEH iirc.
[01:11:45] <strcat> or apparently unwinding at all
[01:11:55] <mark_edward> why do all of these iterator methods have underscores in their names?
[01:12:06] <strcat> mark_edward: because method resolve doesn't work and it's a workaround
[01:12:17] <mark_edward> i see
[01:12:30] <strcat> it thinks generic impls conflict with everything
[01:12:34] <strcat> regardless of type bounds
[01:13:02] <XgF> You don't really need to support MS' unwinding (it would be nice, but not fatal); just respect it
[01:13:21] *** Quits: roo (jesse@moz-D32719F.dynamic.ip.windstream.net) (Ping timeout)
[01:13:40] <XgF> The FIber*** APIs are reasonably nice and work... just they kind of assume only one person will ever fiberize a thread. Probably reasonable for Rust
[01:13:59] <strcat> XgF: rust tasks aren't all cooperative scheduled
[01:14:25] *** Joins: roo (jesse@moz-D32719F.dynamic.ip.windstream.net)
[01:14:27] <strcat> and libuv doesn't use fibers
[01:14:30] <XgF> strcat: You cooperatively schedule fibers inside however many threads you want
[01:15:02] <XgF> libuv is just an event loop. irrelevant
[01:15:08] *** Quits: ecr (Thunderbir@moz-BBE3ABD.mv.mozilla.com) (Quit: ecr)
[01:15:59] <strcat> well if it's being done wrong someone should be reporting issues
[01:16:01] <strcat> there aren't any
[01:16:17] <strcat> and brson is writing a new scheduler, I haven't seen input about this
[01:16:25] <strcat> so I don't think it's being considered
[01:16:36] <XgF> Theres also the User Mode Scheduling stuff added with Vista (IIRC), which looks interesting... but I'm not sure on if it was a Vista addition and MSDN seems to claim the contradictory "Windows 7 64-bit and above [Windows Store Apps Only
[01:16:49] *** Quits: eschweic (Adium@moz-BBE3ABD.mv.mozilla.com) (Quit: Leaving.)
[01:17:17] <XgF> strcat: Anyhow, need to head to bed. Will file bug report tomorrow
[01:19:03] *** Quits: strcat (strcat@moz-54F7FD49.cpe.net.cable.rogers.com) (Quit: WeeChat 0.4.1)
[01:19:15] <mark_edward> rusti: fn id<T: Copy>(x: T) -> T { x} id((1,2,3,~4))
[01:19:15] -rusti- (1, 2, 3, ~4)
[01:19:29] <mark_edward> rusti: fn id<T: Copy>(x: T) -> T { x} id((1,2,3,~4,@5))
[01:19:30] -rusti- (1, 2, 3, ~4, @5)
[01:19:38] <mark_edward> rusti: fn id<T: Copy>(x: T) -> T { x} id((1,2,3,~4,@5,&6))
[01:19:39] -rusti- more than 5 lines of output, pastebinned: http://sprunge.us/RdjI
[01:20:44] <mark_edward> rusti: fn id<T: Copy>(x: T) -> T { x} println(fmt!("%?",id((1,2,3,~4,@5,&6)) ));
[01:20:45] -rusti- more than 5 lines of output, pastebinned: http://sprunge.us/JNER
[01:21:10] <mark_edward> should a tuple containing ~T implement Copy?
[01:21:21] <aatch> basically mark_edward no
[01:21:34] <aatch> (ignore the first word)
[01:21:39] <mark_edward> it seems to
[01:22:12] *** Quits: Jesse (jruderman@moz-BBE3ABD.mv.mozilla.com) (Ping timeout)
[01:22:53] *** Quits: roo (jesse@moz-D32719F.dynamic.ip.windstream.net) (Ping timeout)
[01:23:01] <aatch> mark_edward, hmm, maybe I'm wrong...
[01:23:09] *** Joins: roo (jesse@moz-D32719F.dynamic.ip.windstream.net)
[01:23:25] <aatch> Oh, right. No, the `Copy` bound is whether you can do `copy` on it.
[01:23:35] *** Quits: erickt1 (Adium@49C4075F.3AC15C18.2321E71E.IP) (Quit: Leaving.)
[01:23:38] *** Joins: erickt (erickt@8C9ECD8F.3A598286.F12515B4.IP)
[01:23:43] <mark_edward> rusti: let x = ~5; let y = copy x; y
[01:23:44] -rusti- ~5
[01:24:09] <aatch> You can have non-copyable types.
[01:24:11] <mark_edward> what's the difference between copy and clone?
[01:24:15] <aatch> Anything with a destructor
[01:24:23] <aatch> mark_edward, not much, which is why Copy is being removed
[01:24:43] <mark_edward> cool
[01:26:22] *** Quits: jorendorff (jorendorff@moz-30F4FB9E.hfc.comcastbusiness.net) (Quit: jorendorff)
[01:26:28] *** Quits: erickt (erickt@8C9ECD8F.3A598286.F12515B4.IP) (Ping timeout)
[01:27:08] * jensnockert hugs XgF.
[01:30:19] *** Quits: roo (jesse@moz-D32719F.dynamic.ip.windstream.net) (Ping timeout)
[01:30:49] *** Joins: carllerche (carllerche@6B070D22.7E6A0813.1428D117.IP)
[01:35:42] <mark_edward> "'as I understand it, a Rust library contains the AST for each generic function it exposes, so compiling a new variant is quick and easy."
[01:35:46] <mark_edward> found here: http://me.veekun.com/blog/2012/11/17/a-little-bit-rusty/
[01:35:48] <mark_edward> is this true?
[01:36:44] <jensnockert> mark_edward: Also anything marked inline.
[01:37:10] <mark_edward> does that affect binary sizes much?
[01:37:12] *** Joins: sankha93 (Instantbir@CC8CDEEF.199B3CEE.EFB84E89.IP)
[01:37:21] <mark_edward> (the generics)
[01:38:23] <jensnockert> mark_edward: Yes, but it shouldn't be worse than a 'real' function.
[01:38:37] <jensnockert> (At least not when it is finished)
[01:39:30] <mark_edward> cool!
[01:40:33] <mark_edward> if you spawn a task in a function, does the task continue running after the function returns? (say it's waiting on some sort of I/O
[01:40:41] <Eridius> haha this is kind of ironic: https://gist.github.com/kballard/427bf902db49f3042187
[01:41:39] *** Joins: roo (jesse@moz-D32719F.dynamic.ip.windstream.net)
[01:42:42] *** Joins: lmandel (lmandel@moz-76CE9D51.cable.teksavvy.com)
[01:43:59] *** Quits: cubic (cubic@moz-FE5AD6C7.mc.videotron.ca) (Quit: Leaving)
[01:44:15] <jensnockert> Eridius: It is, yes.
[01:44:30] *** Quits: echristo (echristo@moz-1892C634.hsd1.ca.comcast.net) (Quit: echristo)
[01:46:41] <mark_edward> jensnockert: do you know the answer?
[01:47:00] <mark_edward> also how do you take a closure that satifies `Send`
[01:47:07] <jensnockert> mark_edward: I don't think so.
[01:47:21] <jensnockert> mark_edward: Never thought of it.
[01:47:31] *** Quits: roo (jesse@moz-D32719F.dynamic.ip.windstream.net) (Ping timeout)
[01:47:44] <jensnockert> mark_edward: I have only used tasks together with GCD, not standard Rust I/O.
[01:48:28] <mark_edward> okay
[01:48:35] *** Joins: strcat (strcat@moz-54F7FD49.cpe.net.cable.rogers.com)
[01:48:59] <kmc> i'm pretty sure it does keep running but i'm a noob
[01:51:33] *** Quits: vk (vk@F92596F.2DEF7520.EF7679FA.IP) (Quit: vk)
[01:52:58] *** Joins: vk (vk@F92596F.2DEF7520.EF7679FA.IP)
[01:53:43] *** Quits: azakai (alon@moz-BBE3ABD.mv.mozilla.com) (Ping timeout)
[01:55:31] *** Joins: scanlonman (scanlonman@moz-169BC238.hsd1.wa.comcast.net)
[02:00:28] <aatch> if you spawn a task, then that task will keep running until it ends for whatever reason.
[02:00:43] *** Joins: pnathan1 (Adium@B9840254.2CD8A5F8.477B877D.IP)
[02:00:53] <aatch> However, running tasks will block the end of the _program_
[02:02:05] <aatch> (I.E. you can't use tasks to daemonize a process)
[02:03:59] *** Quits: engla (engla@moz-DBD1D96E.cust.bredbandsbolaget.se) (Ping timeout)
[02:04:26] *** Quits: posco (oscarboyki@636AC086.5999CED5.71743E61.IP) (Quit: posco)
[02:06:51] *** Quits: pnathan1 (Adium@B9840254.2CD8A5F8.477B877D.IP) (Ping timeout)
[02:07:20] *** Quits: zz_kimundi (kimundi@moz-90EBCCBC.dip0.t-ipconnect.de) (Ping timeout)
[02:07:20] *** Quits: sp3d (a@moz-49806493.dhcp.stls.mo.charter.com) (Ping timeout)
[02:07:52] *** Joins: ghrust (ghrust@5FEF1C87.6A2AE50.F3114085.IP)
[02:07:52] <ghrust> 01[13rust01] 15bors merged 06auto into 06master: 02http://git.io/24pjhg
[02:07:52] *** Parts: ghrust (ghrust@5FEF1C87.6A2AE50.F3114085.IP) ()
[02:08:56] *** Joins: pnathan1 (Adium@moz-BDC3EE62.tukw.qwest.net)
[02:10:08] *** Quits: james4k (james@moz-E7990244.consolidated.net) (Ping timeout)
[02:10:34] *** Joins: zz_kimundi (kimundi@moz-E923C71.dip0.t-ipconnect.de)
[02:10:42] *** Joins: ghrust (ghrust@FD7BC443.6A2AE50.F3114085.IP)
[02:10:42] <ghrust> 01[13rust01] 15bors pushed 0 new commits to 06auto: 02http://git.io/X8cisw
[02:10:42] *** Parts: ghrust (ghrust@FD7BC443.6A2AE50.F3114085.IP) ()
[02:10:44] *** Joins: ghrust (ghrust@DE823A67.6A2AE50.F3114085.IP)
[02:10:44] <ghrust> 01[13rust01] 15bors pushed 2 new commits to 06auto: 02http://git.io/1eC81g
[02:10:44] <ghrust> 13rust/06auto 143ea3a56 15Tim Chevalier: rustpkg: Handle local git repositories...
[02:10:44] <ghrust> 13rust/06auto 14dc9477d 15bors: auto merge of #7681 : catamorphism/rust/rustpkg-local-repos, r=graydon...
[02:10:44] *** Parts: ghrust (ghrust@DE823A67.6A2AE50.F3114085.IP) ()
[02:10:59] *** zz_kimundi is now known as kimundi
[02:12:18] *** Joins: Jesse (jruderman@moz-BBE3ABD.mv.mozilla.com)
[02:12:22] <bblum> Jesse: https://news.ycombinator.com/item?id=5759607
[02:13:42] *** Joins: james4k (james@moz-E7990244.consolidated.net)
[02:14:18] *** Joins: engla (engla@moz-DBD1D96E.cust.bredbandsbolaget.se)
[02:14:18] *** Joins: brendan (brendaneic@9EFD4BF3.615B56E6.43362C16.IP)
[02:16:51] *** Quits: glinscott (garylinsco@789A6618.53EB7C1.FFFE3AA.IP) (Quit: glinscott)
[02:17:03] *** Joins: glinscott (garylinsco@789A6618.53EB7C1.FFFE3AA.IP)
[02:17:46] *** Quits: doomlord_ (servitor@moz-13E69BC8.range86-180.btcentralplus.com) (Client exited)
[02:17:46] *** Quits: n00b6502 (kwr5y54@moz-13E69BC8.range86-180.btcentralplus.com) (Quit: Lost terminal)
[02:18:44] *** Joins: glinscott_ (garylinsco@789A6618.53EB7C1.FFFE3AA.IP)
[02:18:51] *** Quits: glinscott (garylinsco@789A6618.53EB7C1.FFFE3AA.IP) (Ping timeout)
[02:18:51] *** glinscott_ is now known as glinscott
[02:19:30] *** Quits: james4k (james@moz-E7990244.consolidated.net) (Ping timeout)
[02:20:25] <mark_edward> aatch: what do you mean by that last statement?
[02:20:48] <Luqman> i've been doing too much Rust lately, leaving off semi colons everywhere :P
[02:21:39] *** Joins: james4k (james@moz-E7990244.consolidated.net)
[02:23:14] <pcwalton> Luqman: what Rust plays havoc with for me is my ability to write "if (x)" in C
[02:23:26] <aatch> pcwalton, same.
[02:23:38] <aatch> I keep going if expr { ... }
[02:23:43] <aatch> and getting syntax errors
[02:24:01] <jensnockert> bblum: Seems like they want Rust to some degree.
[02:24:12] *** Joins: erickt (erickt@8C9ECD8F.3A598286.F12515B4.IP)
[02:24:20] <jensnockert> bblum: Oh, wait, it is pcwalton, no surprise then.
[02:24:30] *** Joins: km (quassel@FDBAF0A0.DBF71E41.29C67456.IP)
[02:24:30] <bblum> yeah patrick is arguing against this one guy
[02:25:04] <Luqman> pcwalton: yep, catch myself doing that a lot. but those i notice almost immediately. it's adding the semi colon to srtuct definitions that i keep missing :P
[02:25:40] * jensnockert hugs pcwalton.
[02:26:55] *** Quits: erickt (erickt@8C9ECD8F.3A598286.F12515B4.IP) (Ping timeout)
[02:28:18] *** Quits: seth (seth@moz-AEED5C00.hsd1.co.comcast.net) (Input/output error)
[02:28:53] <aatch> mark_edward, daemonizing a process is when you start a process, and then that process "ends" and control returns back to the original environment, but is still executing code. On linux this is normally done by forking, then detaching the child process, but you can do the same with threads.
[02:29:32] <mark_edward> so why cant spawn do that?
[02:29:45] <strcat> aatch: that's the old way of doing things though
[02:29:53] <aatch> strcat, what's the new way?
[02:29:59] <strcat> they don't fork
[02:30:00] * aatch doesn't write server code
[02:30:14] <aatch> strcat, you can just detach directly?
[02:30:26] <strcat> aatch: upstart/systemd don't need them to fork
[02:30:31] <strcat> and they set up their sockets for them
[02:30:39] <strcat> so lets say B and C depend on A through a socket or two
[02:30:45] <strcat> they set up the sockets for it, and start B and C
[02:30:49] <strcat> A doesn't need to be running yet
[02:30:55] <strcat> it all starts in parallel
[02:31:00] <strcat> launchd on OS X is similar
[02:31:24] <strcat> and systemd tracks by cgroup so pid files, etc. aren't useful
[02:31:35] <strcat> it's better if it doesn't fork because then you know the first process to send SIGTERM to
[02:31:39] <strcat> without a pid file
[02:32:13] <aatch> strcat, cool. At any rate, my point is that you can't use tasks to daemonize a process in Rust.
[02:32:19] <strcat> ah
[02:33:01] <aatch> mark_edward, there isn't really a technical reason, other than complicating the scheduler API, since we have 1 scheduler per thread
[02:33:39] <aatch> but it's a bit of an edge case that as strcat demonstrated isn't really that useful in modern applications.
[02:33:45] <mark_edward> i see
[02:33:52] <strcat> well, depends on init :)
[02:34:07] <strcat> lots of systems don't have a modern init
[02:34:19] <strcat> but OS X, ubuntu, arch, opensuse, fedora, etc. do
[02:34:22] <aatch> (I assume that on Windows you'd use the service host system or something)
[02:34:51] *** Quits: pnathan1 (Adium@moz-BDC3EE62.tukw.qwest.net) (Quit: Leaving.)
[02:35:12] *** Joins: roo (jesse@moz-D32719F.dynamic.ip.windstream.net)
[02:36:11] <jensnockert> aatch: Yeah, you cannot fork on Windows.
[02:37:06] <jensnockert> But now I need to go to bed, and figure out how to store stuff into an lvalue that isn't in memoryâ€¦
[02:37:10] *** Joins: snadon (chatzilla@moz-3BC727E8.mc.videotron.ca)
[02:38:29] <strcat> jensnockert: magic?
[02:39:00] <jensnockert> strcat: Mostly that.
[02:39:15] <jensnockert> strcat: And liberal applications of LLVM faerie dust, probably.
[02:39:52] *** Quits: brendan (brendaneic@9EFD4BF3.615B56E6.43362C16.IP) (Quit: brendan)
[02:40:23] <jensnockert> But more seriously, I'll probably have to add some variant of DatumBlock that supports taking a vector + index as the destination
[02:40:47] <strcat> maybe I'll just call RandomAccessRange/BidirectionalRange something more iterator-like
[02:40:51] <strcat> DoubleEndedRange?
[02:40:54] <strcat> seems clearer anyway
[02:41:03] <strcat> DoubleEndedIterator
[02:41:07] <strcat> something like that ;p
[02:41:56] <jensnockert> DoubleEdgedRange!
[02:42:13] * strcat will stick with DoubleEndedIterator for the moment
[02:42:18] <roo> sounds dangerous, but useful :P
[02:42:39] <acrichto> aatch: just curious, but is there anything blocking the next snapshot?
[02:42:43] <strcat> next should probably be pop, since it will clearly make the range 1 smaller
[02:43:02] <strcat> it's less like a cursor if you can access the thing with indices
[02:43:36] <aatch> acrichto, technically, no. But I don't really want to snapshot that 300MB memory regression
[02:43:44] *** Quits: bjz (brendanzab@B398BE78.F804C29E.D35A31DF.IP) (Ping timeout)
[02:44:50] <strcat> // A range iterator able to yield elements from both ends
[02:44:51] <aatch> and the snapshot that (finally) was done seems to be too old to allow me to easily get the codebase to compile with it at stage0 (I don't know why, it's a lang call problem)
[02:44:51] <strcat> pub trait DoubleEndedRange<A>: Iterator<A> {
[02:44:53] <strcat>     /// Yield an element from the end of the range, returning `None` if the range is empty.
[02:44:55] <strcat>     fn pop_back(&mut self) -> Option<A>;
[02:44:57] <strcat> }
[02:44:59] <strcat> something like that anyway
[02:49:35] *** Quits: scanlonman (scanlonman@moz-169BC238.hsd1.wa.comcast.net) (Quit: My MacBook has gone to sleep. ZZZzzzâ€¦)
[02:49:38] *** Joins: ghrust (ghrust@FD7BC443.6A2AE50.F3114085.IP)
[02:49:39] <ghrust> 01[13rust01] 15bors 04force-pushed 06auto from 14dc9477d to 149b5d523: 02http://git.io/N3iJvQ
[02:49:39] *** Parts: ghrust (ghrust@FD7BC443.6A2AE50.F3114085.IP) ()
[02:49:40] *** Joins: ghrust (ghrust@E7A4CCE2.6A2AE50.F3114085.IP)
[02:49:40] <ghrust> 01[13rust01] 15bors pushed 3 new commits to 06auto: 02http://git.io/sXIymw
[02:49:40] <ghrust> 13rust/06auto 143c19f1b 15Felix S. Klock II: Refactored int/uint range code in preparation for change to range_rev semantics....
[02:49:40] <ghrust> 13rust/06auto 14db0a13b 15Felix S. Klock II: Switch over to new range_rev semantics; fix #5270.
[02:49:41] <strcat> need a name for flipping a range
[02:49:41] <ghrust> 13rust/06auto 14483d241 15bors: auto merge of #7684 : pnkfelix/rust/fsk-invert-range-rev-halfclosedness-issue5270-2ndpr, r=cmr...
[02:49:43] *** Parts: ghrust (ghrust@E7A4CCE2.6A2AE50.F3114085.IP) ()
[02:49:44] <strcat> D uses 'retro' ;p
[02:49:49] * strcat likes 'flip'
[02:50:16] <strcat> [1, 2, 3, 4] -> flip -> [4, 3, 2, 1] (lazily)
[02:50:24] *** Joins: bjz (brendanzab@B398BE78.F804C29E.D35A31DF.IP)
[02:51:48] *** Joins: scanlonman (scanlonman@moz-169BC238.hsd1.wa.comcast.net)
[02:53:40] <SiegeLord> 'reverse'?
[02:54:27] <Eridius> invert
[02:55:20] *** Quits: carllerche (carllerche@6B070D22.7E6A0813.1428D117.IP) (Quit: carllerche)
[02:55:37] <strcat> I'll also need names for the mutating algorithms so... not really sure
[02:55:58] <ChrisMorgan> What do "__morestack()" lines in a backtrace mean?
[02:56:03] <strcat> [1, 2, 3, 4].iter().reverse()
[02:56:11] <strcat> can either flip the range or reverse the array in-place
[02:56:28] *** Joins: carllerche (carllerche@6B070D22.7E6A0813.1428D117.IP)
[02:56:40] <Eridius> ChrisMorgan: that grows the segmented stack
[02:56:49] *** Quits: jgilbert (jgilbert@moz-BBE3ABD.mv.mozilla.com) (Ping timeout)
[02:56:56] <strcat> rusti: let mut xs = [1, 2, 3, 4]; let ys: &const [int] = xs; ys[0]
[02:56:57] -rusti- <anon>:7:17: 7:19 warning: variable does not need to be mutable [-W unused-mut (default)]
[02:56:58] -rusti- <anon>:7          let mut xs = [1, 2, 3, 4]; let ys: &const [int] = xs; ys[0]
[02:56:58] -rusti-                           ^~
[02:56:58] -rusti- 1
[02:57:01] <Eridius> strcat: what does `let i = [1,2,3,4].iter(); i.next(); i.reverse()` do?
[02:57:05] <ChrisMorgan> Eridius: so when trying to track down a SIGABRT I can ignore them?
[02:57:13] <strcat> Eridius: [1, 4, 3, 2]
[02:57:16] <Eridius> ChrisMorgan: I would assume so
[02:57:30] <strcat> or, yields 4 3 2 if it's the non-mutating one
[02:57:45] <strcat> maybe I could use a convention like "i" prefixes for in-place, I don't know
[02:58:19] <strcat> python would use 'reversed' vs 'reverse' but that means renaming all of the existing ones and that's bleh
[02:58:29] <strcat> there aren't as many useful in-place ones
[02:58:41] <SiegeLord> How do you do a lazy mutating reverse?
[02:58:49] <strcat> SiegeLord: not lazy
[02:58:56] <strcat> the one yielding in reverse is lazy
[02:59:36] <strcat> it flips pop and pop_back (or whatever they're called)
[02:59:42] <SiegeLord> For the non mutating kind, you need to force conversion to some storage, like an array
[02:59:47] <SiegeLord> What happens for a mutating one?
[02:59:53] <strcat> you don't have to force conversion
[03:00:00] <SiegeLord> Well, if you want it done
[03:00:08] <strcat> you just make the next pop_back do pop, and pop do pop_back
[03:00:22] <strcat> SiegeLord: yeah but it's lazy, so you'll probably just consume it in a loop
[03:00:26] <strcat> or as much as you need
[03:01:01] <strcat> the mutating one would just use a mutable double ended iterator and swap the values behind the pop/pop_back refs
[03:01:12] <strcat> it will work in vectors, deques, ropes, etc.
[03:01:34] *** Joins: jdm (jdm@moz-B566DF75.dsl.teksavvy.com)
[03:01:44] <strcat> it could work on a tree if you made a special iterator...
[03:02:18] <SiegeLord> So what would [1, 2].mut_iter().reverse() do?
[03:02:31] <strcat> I haven't decided on naming
[03:02:32] <SiegeLord> (if you iterate on that and mutate as you go along)
[03:02:55] <strcat> one will eagerly reverse it in-place
[03:02:59] <strcat> the other will yield them in reverse
[03:04:12] <SiegeLord> Is it impossible to have a 'make_it_so()' function that converts the latter into the former?
[03:04:29] *** Quits: vk (vk@F92596F.2DEF7520.EF7679FA.IP) (Quit: vk)
[03:04:32] <strcat> they aren't really the same algorithm
[03:04:38] <strcat> one is just calling pop_back
[03:04:43] <ChrisMorgan> src/libstd/rt/local.rs: "// XXX: This formulation won't work once ~IoFactoryObject is a real trait pointer".  And tcp::TcpListener::bind is indeed crashing inside the Local::unsafe_borrow::<IoFactoryObject>() line.
[03:04:51] <strcat> the other is calling pop + pop_back in pairs, and swapping
[03:04:56] <strcat> well
[03:05:17] <strcat> it's not actually calling pop_back, it's just returning an iterator where pop is pop_back ;p
[03:05:57] *** Joins: sp3d (a@moz-49806493.dhcp.stls.mo.charter.com)
[03:06:12] <ChrisMorgan> But `pub type IoFactoryObject = UvIoFactory`, and `pub struct UvIoFactory(Loop)`, so I guess ~IoFactoryObject is not "a real trait pointer"?
[03:07:06] <strcat> SiegeLord: I'm not going to bother starting on the mutation-based algorithms yet anyway
[03:07:12] * strcat doesn't feel like finding new borrowck bugs atm
[03:07:52] <pcwalton> I haven't actually seen a borrow check *bug* in a while
[03:08:23] <strcat> pcwalton: 'self is fragile :)
[03:08:30] <strcat> and I have a lot of inner pointers in these
[03:08:34] <strcat> &fn
[03:08:34] *** Quits: carllerche (carllerche@6B070D22.7E6A0813.1428D117.IP) (Quit: carllerche)
[03:09:23] <pcwalton> fragile in a buggy way?
[03:09:34] <strcat> pcwalton: yeah there are various (maybe the same) bugs with 'self
[03:09:41] <pcwalton> bleh
[03:10:04] <strcat> pcwalton: you get weird problems like it not knowing where 'self came from, when it's in some object you're using
[03:10:20] * strcat shrugs
[03:10:37] <strcat> and I don't know what to put as the region parameter in a function
[03:10:49] <strcat> let x: T<region> = foo();
[03:10:57] <strcat> it only allows 'self but you can't use 'self without making an impl :)
[03:11:15] <strcat> making everything a static method for no reason seems to work...
[03:11:16] <Eridius> still want to be able to have arbitrary lifetimes in traits
[03:11:42] *** Quits: btipling (btipling@moz-D51E0AEB.xen.prgmr.com) (Ping timeout)
[03:16:03] * strcat wonders if trait inheritance works at all
[03:17:03] <strcat> nope! :)
[03:17:10] <pcwalton> it does work
[03:17:12] <pcwalton> in many cases
[03:17:48] <strcat> well, maybe not with generics
[03:17:50] <strcat> I have
[03:17:51] <strcat> pub trait DoubleEndedIterator<A>: Iterator<A> {
[03:17:54] <strcat> and
[03:17:55] <strcat> impl<A, T: DoubleEndedIterator<A>> Iterator<A> for InvertIterator<A, T> {
[03:18:07] <strcat> and it doesn't find 'next' for T
[03:18:09] <strcat> hrm
[03:18:52] <strcat> ah nvm it seems happy now, I was missing a dummy parameter
[03:20:36] *** Quits: flowsnake (flowsnake@moz-1918C33E.aztw.cable.virginmedia.com) (Ping timeout)
[03:22:40] *** Joins: ghrust (ghrust@C621748.6A2AE50.F3114085.IP)
[03:22:40] <ghrust> 01[13rust01] 15bors 04force-pushed 06auto from 14483d241 to 149b5d523: 02http://git.io/N3iJvQ
[03:22:40] *** Parts: ghrust (ghrust@C621748.6A2AE50.F3114085.IP) ()
[03:22:42] *** Joins: ghrust (ghrust@2EE61FCC.6A2AE50.F3114085.IP)
[03:22:42] <ghrust> 01[13rust01] 15bors pushed 2 new commits to 06auto: 02http://git.io/soVl5Q
[03:22:42] <ghrust> 13rust/06auto 143d3d82a 15Corey Richardson: Restructure benchmarks
[03:22:42] <ghrust> 13rust/06auto 14716d356 15bors: auto merge of #7687 : cmr/rust/benchmarks, r=huonw
[03:22:42] *** Parts: ghrust (ghrust@2EE61FCC.6A2AE50.F3114085.IP) ()
[03:24:12] *** Joins: flowsnake (flowsnake@moz-1918C33E.aztw.cable.virginmedia.com)
[03:24:25] *** Quits: bytbox (s@moz-DC83764A.washdc.fios.verizon.net) (Ping timeout)
[03:24:41] *** Joins: jorendorff (jorendorff@moz-2F32ACA3.hsd1.tn.comcast.net)
[03:24:45] *** Joins: erickt (erickt@8C9ECD8F.3A598286.F12515B4.IP)
[03:27:01] *** Quits: Sorella (queen@78575561.924F2739.95C8B7C6.IP) (Quit: (quit))
[03:27:19] *** Quits: SiegeLord (sl@moz-CAF07B4C.hsd1.ma.comcast.net) (Quit: It's a joke, it's all a joke.)
[03:27:34] *** Quits: erickt (erickt@8C9ECD8F.3A598286.F12515B4.IP) (Ping timeout)
[03:29:06] *** Quits: ysuzuki (ysuzuki@moz-36FBA934.net124047241.t-com.ne.jp) (Quit: Tiarra 0.1+svn-39209: SIGINT received; exit)
[03:29:32] *** Quits: bjz (brendanzab@B398BE78.F804C29E.D35A31DF.IP) (Ping timeout)
[03:29:32] *** Joins: alisdair (textual@moz-EBE9F394.bchsia.telus.net)
[03:29:49] *** Joins: ysuzuki (ysuzuki@moz-36FBA934.net124047241.t-com.ne.jp)
[03:32:14] *** Quits: Earnestly (earnest@2AB30F53.FB5005.2BCC804A.IP) (Ping timeout)
[03:33:41] *** Quits: tikue (tkuehn@moz-BBE3ABD.mv.mozilla.com) (Quit: tikue)
[03:33:44] *** Quits: eatkinson (eatkinson@moz-BBE3ABD.mv.mozilla.com) (Quit: eatkinson)
[03:34:19] *** Joins: eatkinson (eatkinson@moz-BBE3ABD.mv.mozilla.com)
[03:34:45] *** Quits: eatkinson (eatkinson@moz-BBE3ABD.mv.mozilla.com) (Quit: eatkinson)
[03:35:02] *** Quits: Jesse (jruderman@moz-BBE3ABD.mv.mozilla.com) (Quit: Jesse)
[03:38:58] *** Joins: seth (seth@moz-2C443A35.hsd1.co.comcast.net)
[03:41:20] *** Quits: engla (engla@moz-DBD1D96E.cust.bredbandsbolaget.se) (Ping timeout)
[03:41:26] *** Joins: wilsonk-laptop (kvirc@moz-8E86F35A.cg.shawcable.net)
[03:41:35] *** Quits: seth (seth@moz-2C443A35.hsd1.co.comcast.net) (Ping timeout)
[03:43:56] *** Quits: Kruppe (user@moz-E150F49F.cpe.net.cable.rogers.com) (Client exited)
[03:44:45] *** Quits: reyre (reyre@moz-9002CDDA.cpe.net.cable.rogers.com) (Client exited)
[03:45:32] <sully> static default methods: working
[03:46:53] <aatch> sully, schweet!
[03:50:37] *** Joins: arnold (arnold@moz-72830A1C.nyc.res.rr.com)
[03:52:51] *** Quits: jaen (jaen@moz-E0979827.copit.pl) (Ping timeout)
[03:53:25] <jensnockert> \o/
[03:53:34] <jensnockert> Btw. Wasn't I going to bed?
[03:58:47] *** Joins: sanxiyn (tinuviel@858F408C.B797260D.EF43EC08.IP)
[03:58:49] *** Joins: reyre (reyre@moz-9002CDDA.cpe.net.cable.rogers.com)
[03:59:29] * sanxiyn likes mut_split
[04:00:00] <sully> oh, looks like something funny is still going on
[04:00:16] <sanxiyn> r? https://github.com/mozilla/rust/pull/7705
[04:00:23] <sanxiyn> r? https://github.com/mozilla/rust/pull/7706
[04:02:00] <sanxiyn> Also, is someone interested in cleaning up all overqualifications in Rust codebase so that we can turn the lint on? (see #7706)
[04:02:12] <sanxiyn> Like, use cast::transmute; cast::transmute(...)
[04:02:25] <sanxiyn> (Either just use cast;, or call as transmute(...))
[04:03:58] <strcat> can get rid of the reverse vec iterators now I guess
[04:04:09] * strcat thinks this is right...
[04:05:37] *** Joins: pnathan1 (Adium@B9840254.2CD8A5F8.477B877D.IP)
[04:08:01] *** Quits: tiffany (kawaii@moz-1E0FE6E8.dhcp.embarqhsd.net) (Ping timeout)
[04:11:21] *** Quits: lmandel (lmandel@moz-76CE9D51.cable.teksavvy.com) (Quit: lmandel)
[04:11:36] *** Quits: pnathan1 (Adium@B9840254.2CD8A5F8.477B877D.IP) (Ping timeout)
[04:17:55] *** Quits: arnold (arnold@moz-72830A1C.nyc.res.rr.com) (Quit: WeeChat 0.4.1)
[04:18:57] *** Quits: reyre (reyre@moz-9002CDDA.cpe.net.cable.rogers.com) (Client exited)
[04:20:21] *** Quits: bytewise (bytewise@moz-649C630D.unitymediagroup.de) (Quit: Leaving)
[04:23:45] *** Joins: azita (Azita@moz-C1FB2A8.hsd1.ca.comcast.net)
[04:25:20] *** Joins: erickt (erickt@8C9ECD8F.3A598286.F12515B4.IP)
[04:26:46] <ChrisMorgan> rusti: let a = 2u8; fmt!("%u", a)
[04:26:47] -rusti- more than 5 lines of output, pastebinned: http://sprunge.us/DeJI
[04:27:11] <ChrisMorgan> "mismatched types: expected `uint` but found `u8` (expected uint but found u8)", is there a type for u8?
[04:27:42] <ChrisMorgan> (I can do "as uint", but it seems like it shouldn't be necessary.)
[04:28:12] *** Quits: erickt (erickt@8C9ECD8F.3A598286.F12515B4.IP) (Ping timeout)
[04:29:03] <strcat> heh it worked while I was gone
[04:29:14] <strcat> almost ;[
[04:31:39] *** Joins: bjz (brendanzab@B398BE78.F804C29E.D35A31DF.IP)
[04:31:41] *** Joins: ghrust (ghrust@AC22872E.6A2AE50.F3114085.IP)
[04:31:41] <ghrust> 01[13rust01] 15bors 04force-pushed 06auto from 14716d356 to 149b5d523: 02http://git.io/N3iJvQ
[04:31:41] *** Parts: ghrust (ghrust@AC22872E.6A2AE50.F3114085.IP) ()
[04:31:43] *** Joins: ghrust (ghrust@CFE85B59.6A2AE50.F3114085.IP)
[04:31:43] <ghrust> 01[13rust01] 15bors pushed 6 new commits to 06auto: 02http://git.io/ZxivbQ
[04:31:43] <ghrust> 13rust/06auto 14b8d9f1c 15Niko Matsakis: rustc: Add new graph library, based on code from region_infernece
[04:31:43] <ghrust> 13rust/06auto 148ce8894 15Niko Matsakis: Port region inference code to use new graph
[04:31:44] <ghrust> 13rust/06auto 14a1a697d 15Niko Matsakis: Construct the graph only when it is needed to report errors.
[04:31:46] *** Parts: ghrust (ghrust@CFE85B59.6A2AE50.F3114085.IP) ()
[04:37:25] <strcat> sully: you found the fix for that bug right?
[04:37:29] <strcat> I think I hit it again ;p
[04:37:43] <strcat> a different way
[04:37:48] <strcat> probably the same one...
[04:38:04] * strcat will just make a Util trait for the moment
[04:38:25] *** Joins: nano (nano@moz-972880B.superkabel.de)
[04:40:41] *** Joins: ghrust (ghrust@DE823A67.6A2AE50.F3114085.IP)
[04:40:41] <ghrust> 01[13rust01] 15bors 04force-pushed 06auto from 143ab1307 to 149b5d523: 02http://git.io/N3iJvQ
[04:40:41] *** Parts: ghrust (ghrust@DE823A67.6A2AE50.F3114085.IP) ()
[04:40:43] *** Joins: ghrust (ghrust@614D05BD.6A2AE50.F3114085.IP)
[04:40:43] <ghrust> 01[13rust01] 15bors pushed 2 new commits to 06auto: 02http://git.io/6FKf9A
[04:40:43] <ghrust> 13rust/06auto 14663a959 15Kevin Mehall: Document std::libc::c_void.
[04:40:43] <ghrust> 13rust/06auto 144957414 15bors: auto merge of #7690 : kevinmehall/rust/document-c_void, r=huonw...
[04:40:43] *** Parts: ghrust (ghrust@614D05BD.6A2AE50.F3114085.IP) ()
[04:42:21] * ChrisMorgan just got his first HTTP response through. Sure, the server never read the request, and sure, the server then promptly crashed, but the response got through
[04:43:43] <ChrisMorgan> Technique: adapter (incomplete) to mould extra::net::tcp (which works) into the interface of std::rt::io::net::tcp (which my server is using primarily, but which doesn't work at present)
[04:46:28] <strcat> rusti: type foo = std::hashmap::HashMap<int, K>;
[04:46:29] -rusti- <anon>:7:47: 7:48 error: use of undeclared type name `K`
[04:46:29] -rusti- <anon>:7          type foo = std::hashmap::HashMap<int, K>;
[04:46:29] -rusti-                                                         ^
[04:46:29] -rusti- error: aborting due to previous error
[04:46:29] -rusti- application terminated with error code 101
[04:46:35] <strcat> rusti: type foo<K> = std::hashmap::HashMap<int, K>;
[04:46:36] -rusti- ()
[04:46:51] *** Quits: nano (nano@moz-972880B.superkabel.de) (Connection reset by peer)
[04:46:59] <strcat> rusti: type foo<'self, T> = std::vec::VecIterator<'self, T>;
[04:47:00] -rusti- ()
[04:47:48] *** Joins: bjz_ (brendanzab@B398BE78.F804C29E.D35A31DF.IP)
[04:47:48] *** Quits: bjz (brendanzab@B398BE78.F804C29E.D35A31DF.IP) (Connection reset by peer)
[04:49:52] *** Quits: sanxiyn (tinuviel@858F408C.B797260D.EF43EC08.IP) (Ping timeout)
[04:50:01] *** Quits: roo (jesse@moz-D32719F.dynamic.ip.windstream.net) (Ping timeout)
[04:51:00] *** Joins: roo (jesse@moz-D32719F.dynamic.ip.windstream.net)
[04:54:10] *** Quits: pcwalton (pcwalton@moz-BBE3ABD.mv.mozilla.com) (Quit: pcwalton)
[04:55:52] <strcat> dbaupp: around? :)
[04:56:06] *** Joins: bytbox (s@moz-DC83764A.washdc.fios.verizon.net)
[04:58:40] *** Joins: sanxiyn (tinuviel@858F408C.B797260D.EF43EC08.IP)
[04:58:53] *** Quits: sanxiyn (tinuviel@858F408C.B797260D.EF43EC08.IP) (Quit: Leaving)
[05:07:45] *** Joins: pyrac (pyrac@moz-8862B13A.w92-162.abo.wanadoo.fr)
[05:07:53] *** Quits: Jesin (Jessin_@moz-1B1307FF.eecs.lehigh.edu) (Ping timeout)
[05:12:40] *** Joins: Jesin (Jessin_@moz-1B1307FF.eecs.lehigh.edu)
[05:13:46] *** Quits: jensnockert (jensnocker@moz-8BE55278.customer.t3.se) (Input/output error)
[05:18:17] *** Joins: Jesse (jruderman@moz-537BCF9.hsd1.ca.comcast.net)
[05:19:20] *** Quits: bytbox (s@moz-DC83764A.washdc.fios.verizon.net) (Ping timeout)
[05:20:01] *** Quits: enix (enix@moz-A50569DD.c3-0.slvr-ubr1.lnh-slvr.md.cable.rcn.com) (Quit: Konversation terminated!)
[05:20:50] *** Joins: jensnockert (jensnocker@moz-C5F27039.cust.bredband2.com)
[05:23:51] *** Quits: jorendorff (jorendorff@moz-2F32ACA3.hsd1.tn.comcast.net) (Quit: jorendorff)
[05:25:54] *** Joins: erickt (erickt@8C9ECD8F.3A598286.F12515B4.IP)
[05:27:55] *** Quits: nielsle (nielsle@moz-5CE8ECCD.boa.fiberby.dk) (Ping timeout)
[05:28:37] *** Quits: erickt (erickt@8C9ECD8F.3A598286.F12515B4.IP) (Ping timeout)
[05:29:18] <bblum> toddaaro: it seems like the latest and greatest on brson's io branch isn't green on its own tests
[05:29:21] <bblum> what's the deal with that
[05:30:44] *** Joins: rajul (quassel@F90C88F7.3471B448.25B273F5.IP)
[05:33:04] * strcat wants random access iterators now
[05:37:34] <bjz_> bblum: doesn't brson stick to tdd?
[05:38:04] <bblum> i should hope so
[05:38:09] <bblum> but it appears to be nongreen
[05:38:20] <bblum> rt::io::net::udp tests fail
[05:38:22] <bjz_> bblum: i'm guessing he wrote the tests before, then is working on making them green
[05:38:32] <bblum> i verified with a fresh repository checkout
[05:38:54] * bjz_ can't read minds though
[05:39:27] * bjz_ is pretty lax when it comes to TDD
[05:39:33] <strcat> bblum: well that's how life is :), if we weren't running them we've likely broken them 10x over
[05:39:59] <strcat> bjz_: ranges! ;p
[05:40:19] <strcat> just missing random access now and lots of adaptors
[05:40:23] *** Joins: nielsle (nielsle@moz-5CE8ECCD.boa.fiberby.dk)
[05:45:40] *** Quits: azita (Azita@moz-C1FB2A8.hsd1.ca.comcast.net) (Quit: azita)
[05:46:11] <Eridius> hrm, I just realized that rustc re-parses the terminfo for every single diagnostic message. Actually, twice now since the "white errors" change
[05:46:22] <strcat> heh
[05:53:09] <ChrisMorgan> Sounds like good scope for a perf win.
[05:53:43] <strcat> a minor one, it's not like warnings are that common ;p
[05:54:08] *** Quits: dwhyte (dwhyte@ED9190FB.B72E355F.7BF4A4B0.IP) (Quit: Leaving.)
[05:56:10] *** Joins: jaen (jaen@moz-C9423CB8.neoplus.adsl.tpnet.pl)
[06:00:04] *** Quits: jaen (jaen@moz-C9423CB8.neoplus.adsl.tpnet.pl) (Ping timeout)
[06:00:31] *** Joins: jaen (jaen@moz-C9423CB8.neoplus.adsl.tpnet.pl)
[06:02:11] <sfackler> speaking of broken tests, I just hit this running make check on osx: http://pastebin.com/zw2QzPxN
[06:02:40] <sfackler> i have a few changes, but nothing in the rt package
[06:02:48] <sfackler> or anything that should cause this
[06:04:09] <sfackler> running it a few times, it seems to consistently fail in the middle of rt::comm tests
[06:10:33] *** Joins: pnathan1 (Adium@B9840254.2CD8A5F8.477B877D.IP)
[06:11:42] *** Quits: arete (arete@moz-CE1DC602.xen.prgmr.com) (Ping timeout)
[06:11:44] *** Joins: arete (arete@moz-CE1DC602.xen.prgmr.com)
[06:16:27] *** Quits: pnathan1 (Adium@B9840254.2CD8A5F8.477B877D.IP) (Ping timeout)
[06:19:27] *** Quits: bjz_ (brendanzab@B398BE78.F804C29E.D35A31DF.IP) (Quit: Leaving...)
[06:19:40] *** Quits: sankha93 (Instantbir@CC8CDEEF.199B3CEE.EFB84E89.IP) (Ping timeout)
[06:19:41] *** Joins: relistan (relistan@moz-2DE8112B.cable.virginmedia.com)
[06:21:07] *** Quits: snadon (chatzilla@moz-3BC727E8.mc.videotron.ca) (Client exited)
[06:22:16] *** Quits: jensnockert (jensnocker@moz-C5F27039.cust.bredband2.com) (Connection reset by peer)
[06:23:31] *** Quits: jaen (jaen@moz-C9423CB8.neoplus.adsl.tpnet.pl) (Ping timeout)
[06:24:13] *** Joins: jaen (jaen@moz-C9423CB8.neoplus.adsl.tpnet.pl)
[06:24:50] *** Joins: jensnockert (jensnocker@moz-C5F27039.cust.bredband2.com)
[06:26:11] *** Quits: jensnockert (jensnocker@moz-C5F27039.cust.bredband2.com) (Input/output error)
[06:26:28] *** Joins: erickt (erickt@8C9ECD8F.3A598286.F12515B4.IP)
[06:27:29] <Eridius> rusti match 3 { 0,1 => 0, 3 => 1, _ => 2 }
[06:27:32] <Eridius> rusti: match 3 { 0,1 => 0, 3 => 1, _ => 2 }
[06:27:34] -rusti- <anon>:7:20: 7:21 error: expected `=>` but found `,`
[06:27:34] -rusti- <anon>:7          match 3 { 0,1 => 0, 3 => 1, _ => 2 }
[06:27:35] -rusti-                              ^
[06:27:35] -rusti- application terminated with error code 101
[06:27:41] <Eridius> rusti: match 3 { (0,1) => 0, 3 => 1, _ => 2 }
[06:27:42] -rusti- <anon>:7:19: 7:24 error: mismatched types: expected `<VI0>` but found tuple (types differ)
[06:27:42] -rusti- <anon>:7          match 3 { (0,1) => 0, 3 => 1, _ => 2 }
[06:27:42] -rusti-                             ^~~~~
[06:27:42] -rusti- error: aborting due to previous error
[06:27:42] -rusti- application terminated with error code 101
[06:27:51] <Eridius> rusti: match 3 { 0|1 => 0, 3 => 1, _ => 2 }
[06:27:53] -rusti- 1
[06:28:08] *** Joins: Axord (xord@moz-C3CCF156.lsanca.dsl-w.verizon.net)
[06:29:12] *** Quits: erickt (erickt@8C9ECD8F.3A598286.F12515B4.IP) (Ping timeout)
[06:29:47] <brendanc> Eridius: btw https://github.com/graydon/rust/commit/69272e313cd4ffdbf8843dd8072feb0c49282610 looks like the fix for the terminfo reparsing
[06:30:30] <Eridius> brendanc: well that fixes the test runner
[06:30:32] <Eridius> it doesn't fix rustc
[06:30:42] <brendanc> ah true
[06:30:50] <Eridius> the problem I'm looking at is in libsyntax/diagnostic
[06:31:01] <Eridius> which doesn't have any state object to hang the terminal off of
[06:31:06] <Eridius> maybe worth stuffing it into task-local storage?
[06:31:51] *** Joins: snadon (chatzilla@moz-3BC727E8.mc.videotron.ca)
[06:34:35] *** Quits: alisdair (textual@moz-EBE9F394.bchsia.telus.net) (Quit: My MacBook Pro has gone to sleep. ZZZzzzâ€¦)
[06:34:46] *** Joins: ghrust (ghrust@9C8B94D4.6A2AE50.F3114085.IP)
[06:34:47] <ghrust> 01[13rust01] 15bors merged 06auto into 06master: 02http://git.io/6FKf9A
[06:34:47] *** Parts: ghrust (ghrust@9C8B94D4.6A2AE50.F3114085.IP) ()
[06:36:43] *** Joins: alisdair (textual@moz-EBE9F394.bchsia.telus.net)
[06:37:42] *** Joins: ghrust (ghrust@9C8B94D4.6A2AE50.F3114085.IP)
[06:37:43] <ghrust> 01[13rust01] 15bors pushed 0 new commits to 06auto: 02http://git.io/TzpbNQ
[06:37:43] *** Parts: ghrust (ghrust@9C8B94D4.6A2AE50.F3114085.IP) ()
[06:37:44] *** Joins: ghrust (ghrust@CFE85B59.6A2AE50.F3114085.IP)
[06:37:44] <ghrust> 01[13rust01] 15bors pushed 2 new commits to 06auto: 02http://git.io/Fqt63g
[06:37:44] <ghrust> 13rust/06auto 149ee5ce2 15Niko Matsakis: Add a `mut_split()` method for dividing one `&mut [T]` into two
[06:37:44] <ghrust> 13rust/06auto 149239d69 15bors: auto merge of #7691 : nikomatsakis/rust/vec-split-method, r=thestinger...
[06:37:44] *** Parts: ghrust (ghrust@CFE85B59.6A2AE50.F3114085.IP) ()
[06:40:38] *** Joins: bjz (brendanzab@B398BE78.F804C29E.D35A31DF.IP)
[06:41:08] *** Joins: lucian (lucian@6B2B4644.4304AE1E.CE5E78F6.IP)
[06:41:40] *** Quits: strcat (strcat@moz-54F7FD49.cpe.net.cable.rogers.com) (Quit: sleep)
[06:45:49] *** Quits: relistan (relistan@moz-2DE8112B.cable.virginmedia.com) (Quit: relistan)
[06:47:58] *** Quits: Jeaye (Jeaye@moz-FD505E54.hsd1.ca.comcast.net) (Quit: zzz)
[06:49:08] *** Joins: sankha93 (Instantbir@412D51FB.785FD1AF.EFB84E89.IP)
[06:49:41] *** Joins: engla (engla@moz-DBD1D96E.cust.bredbandsbolaget.se)
[06:53:43] *** Joins: fabiand (fabiand@moz-AFE1459A.adsl.alicedsl.de)
[06:54:36] *** Quits: engla (engla@moz-DBD1D96E.cust.bredbandsbolaget.se) (Ping timeout)
[06:56:53] *** Quits: sankha93 (Instantbir@412D51FB.785FD1AF.EFB84E89.IP) (Ping timeout)
[06:57:12] *** Joins: engla (engla@moz-DBD1D96E.cust.bredbandsbolaget.se)
[07:00:45] *** Joins: sankha93 (Instantbir@412D51FB.785FD1AF.EFB84E89.IP)
[07:05:58] *** Quits: sankha93 (Instantbir@412D51FB.785FD1AF.EFB84E89.IP) (Ping timeout)
[07:06:08] *** Quits: engla (engla@moz-DBD1D96E.cust.bredbandsbolaget.se) (Ping timeout)
[07:06:38] *** Quits: alisdair (textual@moz-EBE9F394.bchsia.telus.net) (Quit: My MacBook Pro has gone to sleep. ZZZzzzâ€¦)
[07:07:23] <ChrisMorgan> Why would extra::time have `pub fn strptime(s: &str, format: &str) -> Result<Tm, ~str>` being exactly a wrapper to the priv fn do_strptime of the same signature?
[07:09:35] *** Joins: sankha93 (Instantbir@109D15AF.3AAA1E63.EFB84E89.IP)
[07:11:45] *** Quits: sankha93 (Instantbir@109D15AF.3AAA1E63.EFB84E89.IP) (Ping timeout)
[07:11:57] <Yurumechan> is there any technical reason for not having `pub use std::{int,uint};` reimports etc. in std::prelude?
[07:12:30] <aatch> Yurumechan, because people were getting confused that when they tried to do use int::foo
[07:12:35] <vilonis> what is the best way to take a &str and copy/clone it to get a ~str?
[07:12:41] <aatch> `use int::foo`
[07:12:46] <aatch> vilonis, .to_owned()
[07:13:05] *** Quits: tedh (tedh@moz-F0B37C08.hsd1.il.comcast.net) (Client exited)
[07:13:09] <aatch> rusti: fn foo(s: &str) -> ~str { s.to_owned() } foo("123456")
[07:13:10] -rusti- ~"123456"
[07:13:43] <Yurumechan> aatch: yeah, I know, is it (user modules can always import them) the only reason?
[07:13:55] <vilonis> aatch, well I guess that makes a lot of sense, thanks
[07:14:00] *** Joins: Cromulent (Cromulent@moz-983B638D.cable.virginmedia.com)
[07:14:04] <aatch> Yurumechan, as far as I am aware.
[07:14:11] <aatch> There certainly isn't a technical reason
[07:14:58] <Yurumechan> I found it quite strange that `int` and `float` etc. are built-in but corresponding `std::int` and `std::float` modules are not
[07:15:27] <Yurumechan> especially since they have same names as corresponding type names
[07:16:57] <vilonis> aatch, well I guess that makes a lot of sense, thanks
[07:17:06] <vilonis> curses
[07:20:13] *** Joins: sankha93 (Instantbir@3CE7EBFC.8ACFB64A.EFB84E89.IP)
[07:22:05] <Yurumechan> nowadays modules for corresponding type names (std::int, std::float, std::str etc, std::vec is not a type name but similar) only provide functions for creating corresponding types
[07:22:47] <Yurumechan> but they are still common enough that I find `use std::...` is a bit tedious
[07:23:00] <vilonis> is it possible to have module level static/constant strings? I am getting "constant contains unimplemented expression type" on `static root: ~str = ~"path";
[07:23:17] <Yurumechan> vilonis: `static root: &'static str = "path";`
[07:23:19] <aatch> vilonis, yes.
[07:23:30] <aatch> vilonis, `~` and `@` allocate
[07:23:38] <aatch> so by definition are not static
[07:24:13] *** Quits: scanlonman (scanlonman@moz-169BC238.hsd1.wa.comcast.net) (Quit: My MacBook has gone to sleep. ZZZzzzâ€¦)
[07:24:53] <Yurumechan> if you really want to export a fresh allocated string, exported functions are more adequate for that
[07:25:36] <aatch> Or, leave it at that and let your users call to_owned() if they actually want a copy.
[07:25:42] <aatch> (or .to_managed())
[07:26:04] <Yurumechan> (or if that is used for comparison, .equiv())
[07:26:58] <vilonis> okay, these different pointers require a whole new way of thinking. what is ' (single quote) by the way? I see it around the code base a lot but don't really understand its usage
[07:27:01] *** Joins: erickt (erickt@8C9ECD8F.3A598286.F12515B4.IP)
[07:27:23] <Yurumechan> it denotes a lifetime of that reference
[07:27:25] <aatch> vilonis, is marks a lifetime
[07:27:27] <aatch> it*
[07:28:13] *** Quits: sankha93 (Instantbir@3CE7EBFC.8ACFB64A.EFB84E89.IP) (Ping timeout)
[07:28:20] <Eridius> is local_data unsafe purely because it uses so much unsafe code internally and the authors haven't proved safety of the API, or is there some inherent unsafety here?
[07:28:31] <vilonis> okay, so 'static is more or less the whole program
[07:28:39] <aatch> vilonis, this should help: https://gist.github.com/Aatch/5734372
[07:28:47] <aatch> vilonis, and 'static _is_ the whole program
[07:28:57] <aatch> Eridius, it is an unsafe API at the moment
[07:29:35] *** Joins: scanlonman (scanlonman@moz-169BC238.hsd1.wa.comcast.net)
[07:29:43] *** Quits: erickt (erickt@8C9ECD8F.3A598286.F12515B4.IP) (Ping timeout)
[07:29:56] *** Joins: Blub\w (wry@7E3BB9D.71150E1A.237AE2BA.IP)
[07:30:19] *** Joins: roo_ (jesse@moz-E84FC9C7.dynamic.ip.windstream.net)
[07:31:30] *** Quits: roo (jesse@moz-D32719F.dynamic.ip.windstream.net) (Ping timeout)
[07:35:33] *** Quits: Jesin (Jessin_@moz-1B1307FF.eecs.lehigh.edu) (Quit: Leaving)
[07:36:52] <Eridius> aatch: I'm wondering about this because I think I want to stuff a term::Terminal in local data in libsyntax/diagnostic.rs so we stop re-parsing the terminfo for every single message
[07:36:58] <Eridius> (actually twice per message now)
[07:37:08] <aatch> Eridius, that's fine.
[07:37:53] <aatch> We already use a few instances of task-local data in the compiler
[07:39:25] *** Joins: relistan (relistan@moz-2DE8112B.cable.virginmedia.com)
[07:40:39] *** Joins: vk (vk@moz-389FEE13.hsd1.ca.comcast.net)
[07:40:50] *** Joins: doener (bs@moz-AA189A5A.unitymedia.biz)
[07:51:41] *** Quits: pnathan (vlion@moz-BDC3EE62.tukw.qwest.net) (Ping timeout)
[07:55:39] *** Quits: jdm (jdm@moz-B566DF75.dsl.teksavvy.com) (Ping timeout)
[07:58:37] *** Quits: ross (ross@moz-8A84103E.br.br.cox.net) (Quit: )
[07:59:08] *** Quits: vilonis (jared@moz-EE5D17ED.ph.ph.cox.net) (Quit: WeeChat 0.3.8)
[07:59:56] *** Joins: rooo (jesse@moz-AEE3E1BF.dynamic.ip.windstream.net)
[08:01:01] *** Quits: roo_ (jesse@moz-E84FC9C7.dynamic.ip.windstream.net) (Ping timeout)
[08:07:01] *** Quits: Cromulent (Cromulent@moz-983B638D.cable.virginmedia.com) (Quit: KVIrc 4.2.0 Equilibrium http://www.kvirc.net/)
[08:12:46] *** Joins: engla (engla@moz-9B69FE7C.selucle.dyn.perspektivbredband.net)
[08:13:37] *** Quits: txdv (quassel@966F3542.3BA477DA.14C26596.IP) (Ping timeout)
[08:15:25] *** Joins: pnathan (Adium@B9840254.2CD8A5F8.477B877D.IP)
[08:16:07] *** Joins: txdv (quassel@966F3542.3BA477DA.14C26596.IP)
[08:17:03] *** Joins: azita (Azita@moz-C1FB2A8.hsd1.ca.comcast.net)
[08:17:09] *** Quits: pnathan (Adium@B9840254.2CD8A5F8.477B877D.IP) (Ping timeout)
[08:21:58] *** Quits: aatch (aatch@moz-B437F499.pocketrent.com) (Quit: Leaving)
[08:25:57] *** Joins: victorporof (victorporo@74A9C5E8.1745F5FA.9B1E38F4.IP)
[08:26:01] *** Joins: CarpNet (ac@moz-FD24B77.sohonet.co.uk)
[08:27:38] *** Joins: erickt (erickt@8C9ECD8F.3A598286.F12515B4.IP)
[08:28:02] *** Quits: azita (Azita@moz-C1FB2A8.hsd1.ca.comcast.net) (Quit: azita)
[08:30:26] *** Quits: erickt (erickt@8C9ECD8F.3A598286.F12515B4.IP) (Ping timeout)
[08:32:50] *** Joins: Blei (philipp@moz-D2DE1BF1.ethz.ch)
[08:34:42] *** Joins: ghrust (ghrust@614D05BD.6A2AE50.F3114085.IP)
[08:34:42] <ghrust> 01[13rust01] 15bors merged 06auto into 06master: 02http://git.io/Fqt63g
[08:34:42] *** Parts: ghrust (ghrust@614D05BD.6A2AE50.F3114085.IP) ()
[08:37:41] *** Joins: ghrust (ghrust@24260B07.6A2AE50.F3114085.IP)
[08:37:41] <ghrust> 01[13rust01] 15bors pushed 0 new commits to 06auto: 02http://git.io/yfal3A
[08:37:41] *** Parts: ghrust (ghrust@24260B07.6A2AE50.F3114085.IP) ()
[08:37:43] *** Joins: ghrust (ghrust@FD7BC443.6A2AE50.F3114085.IP)
[08:37:43] <ghrust> 01[13rust01] 15bors pushed 2 new commits to 06auto: 02http://git.io/gXRaZg
[08:37:43] <ghrust> 13rust/06auto 143cb3d75 15korenchkin: Fixed examples...
[08:37:43] <ghrust> 13rust/06auto 146ea0c77 15bors: auto merge of #7693 : korenchkin/rust/fixdoc_rand, r=cmr...
[08:37:43] *** Parts: ghrust (ghrust@FD7BC443.6A2AE50.F3114085.IP) ()
[08:40:35] *** Quits: Diamond (dick@moz-C01E1CD1.ks.ks.cox.net) (Client exited)
[08:42:56] *** Joins: roo_ (jesse@moz-ABAFAB41.dynamic.ip.windstream.net)
[08:43:56] *** Quits: rooo (jesse@moz-AEE3E1BF.dynamic.ip.windstream.net) (Ping timeout)
[08:45:40] *** Joins: pnathan (Adium@B9840254.2CD8A5F8.477B877D.IP)
[08:48:51] *** Joins: doomlord (doomlod@moz-13E69BC8.range86-180.btcentralplus.com)
[08:50:52] *** Quits: pnathan (Adium@B9840254.2CD8A5F8.477B877D.IP) (Ping timeout)
[08:51:45] *** Joins: BizarreCake (BizarreCak@moz-361FE9B2.dynamic.barak-online.net)
[08:56:50] *** Quits: vk (vk@moz-389FEE13.hsd1.ca.comcast.net) (Quit: vk)
[09:00:14] *** Joins: true_droid (Adium@moz-123FD9B8.beck.volia.net)
[09:12:32] *** Joins: z0w0 (zack@moz-37A98529.lnse2.woo.bigpond.net.au)
[09:14:55] *** Joins: SimonSapin (simon@88F51059.F3BBB17D.144F44FA.IP)
[09:15:46] *** Quits: mitsuhiko (mitsuhiko-@moz-BC29B73E.srv.pocoo.org) (Ping timeout)
[09:17:11] *** Joins: mitsuhiko (mitsuhiko-@moz-BC29B73E.srv.pocoo.org)
[09:28:09] *** Joins: erickt (erickt@8C9ECD8F.3A598286.F12515B4.IP)
[09:30:54] *** Quits: erickt (erickt@8C9ECD8F.3A598286.F12515B4.IP) (Ping timeout)
[09:42:11] *** Joins: FrozenCow (FrozenCow@moz-B2DF4929.chello.nl)
[09:44:04] *** Joins: rooo (jesse@moz-71DC5D53.dynamic.ip.windstream.net)
[09:45:02] *** Quits: roo_ (jesse@moz-ABAFAB41.dynamic.ip.windstream.net) (Ping timeout)
[09:52:59] *** Joins: pnkfelix (pnkfelix@87C1F78E.1DE10CA8.D8E68FF6.IP)
[09:54:21] *** Quits: snadon (chatzilla@moz-3BC727E8.mc.videotron.ca) (Ping timeout)
[09:55:53] *** Joins: dwhyte (dwhyte@ED9190FB.B72E355F.7BF4A4B0.IP)
[09:56:46] *** Joins: olleharstedt (Thunderbir@moz-80D8890F.ias.bredband.telia.com)
[10:02:24] *** Quits: pyrac (pyrac@moz-8862B13A.w92-162.abo.wanadoo.fr) (Quit: pyrac)
[10:04:01] <mitsuhiko> is the current bindgen against master?
[10:04:38] *** Quits: km (quassel@FDBAF0A0.DBF71E41.29C67456.IP) (Ping timeout)
[10:04:55] *** Quits: relistan (relistan@moz-2DE8112B.cable.virginmedia.com) (Ping timeout)
[10:05:10] <Blei> yes
[10:06:43] *** Joins: pczarn (Mibbit@moz-69A55FA.izacom.pl)
[10:10:20] <mitsuhiko> ta :)
[10:14:31] *** Quits: scanlonman (scanlonman@moz-169BC238.hsd1.wa.comcast.net) (Quit: My MacBook has gone to sleep. ZZZzzzâ€¦)
[10:15:16] *** Joins: sigma (sigma@51C589B3.EF2694B5.DFAC6AA7.IP)
[10:20:51] *** Joins: vk (vk@moz-389FEE13.hsd1.ca.comcast.net)
[10:21:54] *** Joins: pyrac (pyrac@moz-8862B13A.w92-162.abo.wanadoo.fr)
[10:22:37] *** Quits: vk (vk@moz-389FEE13.hsd1.ca.comcast.net) (Quit: vk)
[10:23:12] *** Joins: q66 (q66@6EE9DE40.46454B5D.33AABD5F.IP)
[10:24:29] *** Joins: Earnestly (earnest@2AB30F53.FB5005.2BCC804A.IP)
[10:28:32] *** Quits: Blei (philipp@moz-D2DE1BF1.ethz.ch) (Quit: WeeChat 0.4.1)
[10:28:43] *** Joins: erickt (erickt@8C9ECD8F.3A598286.F12515B4.IP)
[10:29:03] <cmr> Eridius: (there's an issue open about that btw, https://github.com/mozilla/rust/issues/6827)
[10:29:36] *** Joins: km (quassel@FDBAF0A0.DBF71E41.29C67456.IP)
[10:31:27] *** Quits: erickt (erickt@8C9ECD8F.3A598286.F12515B4.IP) (Ping timeout)
[10:31:40] *** Joins: ghrust (ghrust@5FEF1C87.6A2AE50.F3114085.IP)
[10:31:40] <ghrust> 01[13rust01] 15bors merged 06auto into 06master: 02http://git.io/gXRaZg
[10:31:40] *** Parts: ghrust (ghrust@5FEF1C87.6A2AE50.F3114085.IP) ()
[10:33:22] <cmr> Feh, gnu make's wildcards are primitive
[10:33:32] <cmr> No ** ;\
[10:34:17] <cmr> dbaupp: weather disturbances (read: flooding) have taken the bench server down
[10:34:29] <dbaupp> cmr: oh, nice
[10:34:37] *** Joins: ghrust (ghrust@9C8B94D4.6A2AE50.F3114085.IP)
[10:34:37] <ghrust> 01[13rust01] 15bors pushed 0 new commits to 06auto: 02http://git.io/-lXpeA
[10:34:37] *** Parts: ghrust (ghrust@9C8B94D4.6A2AE50.F3114085.IP) ()
[10:34:38] *** Joins: ghrust (ghrust@C8693FCB.6A2AE50.F3114085.IP)
[10:34:38] <ghrust> 01[13rust01] 15bors pushed 6 new commits to 06auto: 02http://git.io/p0aNLw
[10:34:38] <ghrust> 13rust/06auto 14b8d9f1c 15Niko Matsakis: rustc: Add new graph library, based on code from region_infernece
[10:34:38] <ghrust> 13rust/06auto 148ce8894 15Niko Matsakis: Port region inference code to use new graph
[10:34:39] <ghrust> 13rust/06auto 14a1a697d 15Niko Matsakis: Construct the graph only when it is needed to report errors.
[10:34:41] <dbaupp> cmr: near you?
[10:34:41] *** Parts: ghrust (ghrust@C8693FCB.6A2AE50.F3114085.IP) ()
[10:34:44] <cmr> yeah
[10:34:47] <cmr> next town over
[10:34:51] <cmr> just internet outage
[10:43:38] *** Joins: ghrust (ghrust@C621748.6A2AE50.F3114085.IP)
[10:43:39] <ghrust> 01[13rust01] 15bors 04force-pushed 06auto from 146744261 to 146ea0c77: 02http://git.io/N3iJvQ
[10:43:39] *** Parts: ghrust (ghrust@C621748.6A2AE50.F3114085.IP) ()
[10:43:40] *** Joins: ghrust (ghrust@FD7BC443.6A2AE50.F3114085.IP)
[10:43:40] <ghrust> 01[13rust01] 15bors pushed 2 new commits to 06auto: 02http://git.io/bG0Fqw
[10:43:40] <ghrust> 13rust/06auto 14f091a1e 15Gary Linscott: Convert json Reader to iterators...
[10:43:40] <ghrust> 13rust/06auto 1406accaf 15bors: auto merge of #7704 : glinscott/rust/json_iter, r=erickt...
[10:43:40] *** Parts: ghrust (ghrust@FD7BC443.6A2AE50.F3114085.IP) ()
[10:43:50] *** Joins: SiegeLord (sl@moz-CAF07B4C.hsd1.ma.comcast.net)
[10:44:08] *** Joins: novabyte (Instantbir@moz-3E0F9699.cable.virginmedia.com)
[10:50:06] *** Joins: pnathan (Adium@B9840254.2CD8A5F8.477B877D.IP)
[10:55:20] *** Quits: pyrac (pyrac@moz-8862B13A.w92-162.abo.wanadoo.fr) (Quit: pyrac)
[10:56:19] *** Quits: pnathan (Adium@B9840254.2CD8A5F8.477B877D.IP) (Ping timeout)
[11:01:53] *** Quits: james4k (james@moz-E7990244.consolidated.net) (Ping timeout)
[11:02:07] *** Joins: TD-Linux (TD-Linux@E338EB99.2B4F0AE0.A0A36CCE.IP)
[11:02:24] <cmr> Can someone give me a hand with the makefiles? https://github.com/mozilla/rust/pull/7687, I get `make: *** No rule to make target `/home/cmr/hacking/rust/src/test/bench/std/std.rs)', needed by `tmp/check-stage1-T-x86_64-unknown-linux-gnu-H-x86_64-unknown-linux-gnu-bench.ok'.  Stop.
[11:03:11] *** Joins: Blei (philipp@moz-1D7F398F.ethz.ch)
[11:03:49] *** Joins: Sorella (queen@78575561.924F2739.95C8B7C6.IP)
[11:04:29] *** Quits: victorporof (victorporo@74A9C5E8.1745F5FA.9B1E38F4.IP) (Quit: victorporof)
[11:05:49] <dbaupp> cmr: I don't know how to solve that, but bench/*/*.rs probably works (rather than listing all the folders.)
[11:06:55] <cmr> Is it smart enough to not include the files in that glob?
[11:07:06] <cmr> **/*.rs would be ideal :p
[11:07:55] <dbaupp> well, I'd assume if it does include the files, it expands to `foo.rs/*` and nothing matches that, so they don't appear.
[11:08:25] <dbaupp> (but I'd guess it uses the / as an indicator that it looks at folder names only.)
[11:13:42] <cmr> dbaupp:  */*.rs doesn't work, it doesn't pick up the files at all
[11:16:11] <dbaupp> STDLIB_INPUTS := $(wildcard $(addprefix $(S)src/libstd/,        \
[11:16:11] <dbaupp>                                            *.rs */*.rs */*/*rs */*/*/*rs))
[11:16:18] <dbaupp> cmr: ^ (in Makefile.in)
[11:17:09] <cmr> make makes orphans cry ;(
[11:17:58] <doomlord> hard to decipher but they're very versatile
[11:18:13] <doomlord> write-only perhaps :)
[11:19:09] <doomlord> i felt fairly defeated trying to work with the rust makefiles when i had the iOS attempt :)
[11:19:22] *** Joins: pyrac (pyrac@moz-8862B13A.w92-162.abo.wanadoo.fr)
[11:19:31] <cmr> I can imagine
[11:20:26] <doomlord> i should try again with rust zero..
[11:21:28] <cmr> that'd probably be better, at least for proof of concept, than porting the entire rt in one go
[11:25:09] <cmr> dbaupp: it seems *that* doesn't work correctly either
[11:25:24] <cmr> (for BENCH_RS := $(wildcard $(addprefix $(S)src/test/bench/, *.rs */*.rs)) )
[11:25:35] <dbaupp> cmr: not picking up the files still?
[11:25:39] <cmr> yeah
[11:25:45] <dbaupp> how strange
[11:25:54] <dbaupp> (I can't really help much more.)
[11:26:20] * cmr can't wait for rustpkg to save the day
[11:27:39] <mark_edward> how do you make a function work with Rust's for loop protocol?
[11:29:05] <dbaupp> mark_edward: currently, fn (..., &fn(some, arguments) -> bool) -> bool
[11:29:18] *** Joins: erickt (erickt@8C9ECD8F.3A598286.F12515B4.IP)
[11:29:19] <mark_edward> dbaupp: thanks.
[11:29:39] <dbaupp> mark_edward: in the future, by defining an external iterator object
[11:30:13] <cmr> You should be defining an external iterator *now* and just use .advance (it comes free)
[11:30:59] <mark_edward> cmr: i'm trying to deal with my whole compression streaming thing. i think it can be done safely with internal iterators...
[11:31:16] <doomlord> ididn't know $(addprefix..), i was using $(patsubst  %,..%.., ...src ) in conjunction with $(wildcard ) to do similar things
[11:31:52] <dbaupp> mark_edward: the problem isn't safety, it's efficiency & composability
[11:32:01] *** Quits: erickt (erickt@8C9ECD8F.3A598286.F12515B4.IP) (Ping timeout)
[11:32:32] <cmr> mark_edward: use `do` rather than `for` if at all possible
[11:33:21] <mark_edward> cmr: what do you mean exactly?
[11:33:53] <cmr> do compressor.stream(input) |block| { ... }
[11:33:56] <cmr> or somesuch
[11:36:35] <pnkfelix> cmr: do you still need help with make ?
[11:36:44] <cmr> pnkfelix: yup
[11:36:48] <mark_edward> cmr: thanks' that seems good
[11:36:55] *** Quits: engla (engla@moz-9B69FE7C.selucle.dyn.perspektivbredband.net) (Ping timeout)
[11:37:07] <pnkfelix> cmr: The first step I'd recommend, if you haven't already done so, is to build and install the GNU make debugger, aka "remake"
[11:37:19] <pnkfelix> cmr: http://bashdb.sourceforge.net/remake/
[11:37:29] <cmr> I didn't even know that existed
[11:37:30] <pnkfelix> cmr: I've found it invaluable in tracking down issues
[11:37:41] * cmr avoids gmake as much as possible
[11:38:49] *** Joins: lmandel (lmandel@moz-76CE9D51.cable.teksavvy.com)
[11:38:54] <pnkfelix> cmr: it is a fork of GNU make, so it plugs in as a replacement for make.  But it has 1.) much better error messages IMO, and 2.) A "â€”trace" option that spits out much better information explaining the reasoning process that make is using
[11:39:33] <cmr> pnkfelix: would symlinking `make` to it somewhere high in my PATH be unadvisable?
[11:40:03] <pnkfelix> cmr: â€¦ I think that would work, but I haven't done it myself
[11:40:29] *** Joins: etw (john@moz-B2936CAB.nyc.res.rr.com)
[11:40:40] <pnkfelix> cmr: (I just invoke "remake" directly; it seems like it is smart enough to then reuse remake on recursive make invocation, e.g. when building LLVM inside the rust build tree.  Not quite sure how its doing that.)
[11:40:54] <pczarn> cmr: perhaps you nest it wrong: $(addprefix $(S)src/test/bench/, $(wildcard *.rs wildcard */*.rs))
[11:41:11] <pnkfelix> cmr: But I do think the symlink you describe would work, in particular since I think one of remake's configure options is to actually name its output binary "make" instead of "remake"
[11:41:31] <dbaupp> pczarn: fwiw, the other nesting is used in other make files, and works there.
[11:42:27] *** Quits: z0w0 (zack@moz-37A98529.lnse2.woo.bigpond.net.au) (Client exited)
[11:43:44] *** Quits: lmandel (lmandel@moz-76CE9D51.cable.teksavvy.com) (Quit: lmandel)
[11:44:21] <pnkfelix> cmr: beyond that, I made some heavy use of $(info â€¦) when I was debugging my changes for #3225
[11:44:34] *** Quits: doomlord (doomlod@moz-13E69BC8.range86-180.btcentralplus.com) (Ping timeout)
[11:44:34] <pnkfelix> (good ol' printf-debugging...)
[11:48:07] *** Joins: Ms2ger (Ms2ger@moz-E9883900.access.telenet.be)
[11:49:10] <Seldaek> cmr: is it ok if I work in a rustdoc_frontend repo or would you rather keep the html stuff together with rustdoc_ng?
[11:49:19] <cmr> Seldaek: yeah go ahead
[11:49:25] <cmr> better to keep it separate imo
[11:49:35] <cmr> avoid the temptation of coupling
[11:49:45] <Seldaek> cmr: I tried to explain the whole doc structure to my girlfriend yesterday, forced me to think about it in depth :p
[11:49:56] <cmr> heh
[11:50:52] *** Joins: tiffany (kawaii@moz-1E0FE6E8.dhcp.embarqhsd.net)
[11:51:04] <Seldaek> I have some ideas that might freak people out I'm not sure.. we'll see
[11:51:18] <dbaupp> Seldaek: will it be awesome?
[11:51:26] <dbaupp> (if so, doesn't matter ;P )
[11:51:45] <Seldaek> it is in my head, but that unfortunately is not very deterministic
[11:53:55] <Seldaek> I tried to enroll the gf on the project too, might help with the design because while I know css well I'm not such a designer type
[11:54:47] <dbaupp> and she is?
[11:55:13] <Seldaek> definitely more than I am, studying interaction design
[11:55:54] <cmr> I'm a design nerd but I'm alergic to the box model
[11:56:41] <Seldaek> it does have its moments of pain and anger ;)
[11:56:55] <cmr> (all of them!)
[11:57:23] <cmr> This Week in Rust is listed in LWN now.
[11:57:32] <cmr> Under development newsletters
[11:57:33] <dbaupp> cmr: you're famous!
[11:57:43] <cmr> dbaupp: well I emailed it to them :p
[11:57:57] <dbaupp> cmr: that's no fun :P
[11:59:14] <Seldaek> and internet famous only gets you so far :p
[12:01:53] *** Quits: rooo (jesse@moz-71DC5D53.dynamic.ip.windstream.net) (Ping timeout)
[12:06:51] <Seldaek> cmr: I guess a crate can contain functions/structs/traits as well and not just modules on the top level right? I assume that's just a libstd/libextra convention to keep things tidy?
[12:07:05] <cmr> Seldaek: yep
[12:07:47] <cmr> example: a libpng binding wouldn't have anything not at the top level, probably
[12:08:05] <pnkfelix> nmatsakis: ping
[12:08:21] *** Joins: ab (alex@BC9D99CC.37C1012D.FE617B51.IP)
[12:08:44] <Seldaek> alright
[12:09:50] *** Joins: roo (jesse@moz-71DC5D53.dynamic.ip.windstream.net)
[12:11:42] *** Quits: roo (jesse@moz-71DC5D53.dynamic.ip.windstream.net) (Ping timeout)
[12:12:44] *** Joins: roo (jesse@moz-71DC5D53.dynamic.ip.windstream.net)
[12:14:48] *** Quits: roo (jesse@moz-71DC5D53.dynamic.ip.windstream.net) (Ping timeout)
[12:16:31] *** Joins: fylux (Mibbit@moz-AC51E628.red-83-37-43.dynamicip.rima-tde.net)
[12:17:41] *** Joins: roo (jesse@moz-71DC5D53.dynamic.ip.windstream.net)
[12:18:26] *** Quits: robertknight (robertknig@moz-54528EE0.wby.mendeley.com) (Quit: Computer has gone to sleep.)
[12:18:52] <fylux> Hi, I have just done the article of Rust in Spanish Wikipedia
[12:18:57] <fylux> http://es.wikipedia.org/wiki/Rust_%28lenguaje_de_programaci%C3%B3n%29
[12:19:50] *** Quits: roo (jesse@moz-71DC5D53.dynamic.ip.windstream.net) (Ping timeout)
[12:20:36] <dbaupp> fylux: nice work!
[12:21:21] <cmr> fylux: A stable version is no longer planned by the end of the year.
[12:21:52] * cmr looks on the english wikipedia to see how out of date it is
[12:22:40] <fylux> I traduces the english article
[12:22:50] <fylux> traduced*
[12:23:14] <dbaupp> fylux: ("translated" :) )
[12:24:08] <fylux> Sorry. So shall I change this?
[12:26:15] <dbaupp> cmr: is there actually a solid reference for the stable version date? (it's northern-hemisphere spring next year, right?)
[12:26:34] <cmr> dbaupp: "when it's done"
[12:26:45] <cmr> is the current feeling, aiui
[12:26:45] <dbaupp> cmr: thanks -_-
[12:27:18] <fylux> ok, then I take it off.
[12:28:10] <dbaupp> fylux: yeah, probably best for now
[12:28:40] <dbaupp> fylux: you could also remove it from the english page too (if cmr hasn't done it already)
[12:28:46] *** Joins: victorporof (victorporo@58682299.183F338A.6A4F8DA2.IP)
[12:28:49] <cmr> I am doing it now
[12:29:06] <fylux> Right, It's done in the spanish page. As you can see the article isn't finished but I'll finish it between today and tomorrow.
[12:29:51] *** Joins: erickt (erickt@8C9ECD8F.3A598286.F12515B4.IP)
[12:29:56] <fylux> since I'm changing the article in French
[12:30:41] <cmr> http://en.wikipedia.org/w/index.php?title=Rust_%28programming_language%29&diff=563806468&oldid=563545822
[12:30:43] *** Joins: maxli (maxli@F2D29657.F60B0462.67AC9B1.IP)
[12:31:01] *** Quits: maxli (maxli@F2D29657.F60B0462.67AC9B1.IP) (Connection reset by peer)
[12:31:29] <dbaupp> cmr: nice little addition :)
[12:31:40] <fylux> Ok, I'll add it in spanish.
[12:32:10] *** Joins: bytbox (s@moz-DC83764A.washdc.fios.verizon.net)
[12:32:29] *** Quits: erickt (erickt@8C9ECD8F.3A598286.F12515B4.IP) (Ping timeout)
[12:32:33] *** Joins: maxli (maxli@F2D29657.F60B0462.67AC9B1.IP)
[12:33:02] <cmr> dbaupp: it was brought up in a servo meeting (two weeks ago I think) that the stigma that rust is a mozilla project (ie, "Mozilla Rust") is incorrect and needs to be fixed
[12:33:19] <dbaupp> Mozilla is a stigma?
[12:34:30] <cmr> maybe that is the wrong word
[12:34:41] <dbaupp> cmr: looks like you're gonna have a huge debug-info improvement to trumpet twir https://github.com/mozilla/rust/pull/7710
[12:34:54] *** Joins: roo (jesse@moz-71DC5D53.dynamic.ip.windstream.net)
[12:34:57] <Seldaek> dbaupp: I think it's always best to detach it from the org behind it when possible, because there are always the haters
[12:35:00] <cmr> <3 mw
[12:35:17] <dbaupp> Seldaek: yeah, that was just my biases showing :P
[12:35:27] <fylux> Ok, it's changed in spanish too.
[12:35:28] <Seldaek> and for those that actually think it's a good thing, you can always tell them mozilla is backing it
[12:35:35] * dbaupp loves Rust's community
[12:35:44] <cmr> fylux: thank you!
[12:36:21] <Seldaek> like go now says nothing of being a google thing anymore AFAIK
[12:36:32] <sigma> I think most people appreciate Mozilla, at least in technical circles, they don't have the "spying on you" stigma google has
[12:36:37] <cmr> Seldaek: Go isn't a google project either
[12:36:53] <Seldaek> cmr: it's still considered as such by a ton of people :)
[12:36:55] <cmr> it was a 20% project at first and I think only a few of the core devs are google employees
[12:36:58] <cmr> And it's wrong!
[12:37:09] <cmr> That's why the "Mozilla Rust" thing needs to be squelched
[12:37:42] *** Joins: ghrust (ghrust@AD60B2E3.6A2AE50.F3114085.IP)
[12:37:42] <ghrust> 01[13rust01] 15bors merged 06auto into 06master: 02http://git.io/bG0Fqw
[12:37:42] *** Parts: ghrust (ghrust@AD60B2E3.6A2AE50.F3114085.IP) ()
[12:37:49] <Seldaek> yeah although I consider one of the main appeals of learning rust to be that it's a door opener to work at mozilla :)
[12:38:05] <fylux> That's true cmr, but this project es "famous" just because is hyped by Mozilla.
[12:38:28] <fylux> is*
[12:38:38] *** Quits: roo (jesse@moz-71DC5D53.dynamic.ip.windstream.net) (Ping timeout)
[12:38:40] <Seldaek> that's probably correct, perhaps still is, but at some point you gotta let your baby fly away and live a life of its own 
[12:38:41] *** Quits: maxli (maxli@F2D29657.F60B0462.67AC9B1.IP) (Quit: Leaving.)
[12:39:20] <sigma> yeh, Rust has definitely benefited from the association with a big sponsor, as go or say, Java did.
[12:39:26] <cmr> "Implement SIMD arithmetics"
[12:39:32] <cmr> yay
[12:39:51] <Seldaek> sigma: see how it turned out for java though :)
[12:39:59] * dbaupp has been waiting for SIMD for ages
[12:40:04] <SiegeLord> Where is the term "Mozilla Rust" used?
[12:40:07] <dbaupp> <3 sanxiyn
[12:40:17] <fylux> Rust is definitely more famous than Go.
[12:40:27] <dbaupp> fylux: that's not been my experience
[12:40:31] <sigma> SiegeLord: on reddit and various other social media places, ie in common use among non-enthusiasts
[12:40:34] <cmr> SiegeLord: it isn't, anymore, not in any project documentation. maybe in other media
[12:40:37] *** Joins: ghrust (ghrust@9C8B94D4.6A2AE50.F3114085.IP)
[12:40:37] <ghrust> 01[13rust01] 15bors pushed 0 new commits to 06auto: 02http://git.io/1-4xJQ
[12:40:37] *** Parts: ghrust (ghrust@9C8B94D4.6A2AE50.F3114085.IP) ()
[12:40:39] *** Joins: ghrust (ghrust@79968228.6A2AE50.F3114085.IP)
[12:40:39] <ghrust> 01[13rust01] 15bors pushed 4 new commits to 06auto: 02http://git.io/KVBK7w
[12:40:39] <ghrust> 13rust/06auto 14e6e4f52 15Brendan Cully: remove unused imports
[12:40:39] <ghrust> 13rust/06auto 14202fcb2 15Brendan Cully: unnecessarily mutable variables
[12:40:39] <ghrust> 13rust/06auto 14990dc43 15Brendan Cully: unused variable
[12:40:39] *** Parts: ghrust (ghrust@79968228.6A2AE50.F3114085.IP) ()
[12:40:58] <Seldaek> the homepage's only mention of mozilla is in github.com/mozilla/rust
[12:41:18] <fylux> Actually, google is doing nothing with Go, while Mozilla is developing the core of its engine with Rust.
[12:41:22] <Seldaek> might be worth moving that out of the mozilla org now that github supports redirects for renamed repos
[12:41:42] <SiegeLord> I don't think it's wrong to mention the primary sponsor... it would seem inappropriate to leave them off...
[12:42:00] <sigma> I don't know if the strong Mozilla connection is harmful while the language is still nascent
[12:42:00] <Seldaek> fylux: the core of an experimental thing, and google does use go on a few things last time I heard
[12:42:13] *** Joins: roo (jesse@moz-71DC5D53.dynamic.ip.windstream.net)
[12:42:15] <cmr> Go is widely used internally at google
[12:42:25] <fylux> The thing is as experimental as the language.
[12:42:49] <cmr> fylux: more so; the language uses well-known proved-working concepts. Servo? not as much
[12:42:55] <fylux> I don't think so cmr, can anybody show a project made with Go?
[12:43:05] *** Joins: jorendorff (jorendorff@moz-2F32ACA3.hsd1.tn.comcast.net)
[12:43:15] <cmr> fylux: I use a json pretty printer written in go every day
[12:43:33] <sigma> Google have stated that a lot of their infrastructure projects use Go
[12:43:49] <sigma> the static linking et al suits their systems well
[12:44:09] <fylux> I think that Google still uses C++ because is more efficient than the current release of Go.
[12:44:30] <cmr> http://www.quora.com/Go-programming-language/What-systems-in-production-are-written-in-Go-if-any
[12:44:52] <cmr> and that's 2 years old now
[12:44:55] <Seldaek> fylux: http://golang.org/doc/faq#Is_Google_using_go_internally
[12:45:00] <sigma> Oh, I've no doubt they use it for things that need it, but they also use python and Java extensively, so Go is starting to make progress in those areas
[12:45:43] <cmr> https://groups.google.com/forum/#!topic/golang-nuts/hC0aJ8IASi4
[12:46:11] <dbaupp> fylux: I think they use C++ where they need absolute performance, but other safer/easier-to-write languages where they can
[12:46:28] *** Quits: Blei (philipp@moz-1D7F398F.ethz.ch) (Quit: WeeChat 0.4.1)
[12:46:44] *** Quits: novabyte (Instantbir@moz-3E0F9699.cable.virginmedia.com) (Quit: bye bye)
[12:46:45] <AutomatedTester> cmr: Docker.io is written in go
[12:46:46] <fylux> Yes, that right dbaupp. But cmr, the google groups post looks too much nice.
[12:46:54] <fylux> Too much...
[12:46:59] <AutomatedTester> its a new linux container system
[12:47:48] <cmr> fylux: servo and rustc are the only projects using rust at the moment, afaik
[12:47:57] <cmr> besides people tinkering around
[12:48:25] <fylux> I know, but at least they are important projects.
[12:48:51] <fylux> And if there aren't more projects is because it isn't stable yet.
[12:48:55] <sigma> I'd call google's download servers pretty important projects for go :)
[12:49:07] <cmr> yes, likely true
[12:49:11] <cmr> unstable and incomplete
[12:49:32] <dbaupp> AutomatedTester: (not that it matters) but isn't it just a wrapper for the kernel's lxc's and/or cgroups?
[12:49:50] <AutomatedTester> dbaupp: um good question, I actually havent looked
[12:49:56] <AutomatedTester> you have piqued my interest :)
[12:50:01] <cmr> it is, yes.
[12:50:11] <fylux> Sorry, I have to go, I'm gonna have lunch. Bye.
[12:50:19] <Yoric> dbaupp: AutomatedTester: I have seen a partial reimplementation of Docker (DockerLight?) in bash.
[12:50:27] <dbaupp> cmr: I guess, q3 is possibly beyond the tinkering around stage, but I don't know
[12:50:30] *** Quits: fylux (Mibbit@moz-AC51E628.red-83-37-43.dynamicip.rima-tde.net) (Quit: http://www.mibbit.com ajax IRC Client)
[12:50:36] <dbaupp> fylux: thanks for the spanish wiki page!
[12:50:43] <dbaupp> oh, they're gone.
[12:50:55] <sigma> Yeh, implementing even a toy project in rust at the minute is a big exercise in yak shaving... "Hmm, I'll write a jabber server, ok I need to go write bindings for an xml parser..." etc. It's a great learning experience
[12:51:10] <dbaupp> Yoric: ah, so it's mainly an organisation tool?
[12:51:28] <AutomatedTester> Mozilla has written Heka in Go
[12:51:31] <Yoric> Don't ask me for more details.
[12:51:34] <AutomatedTester> https://github.com/mozilla-services/heka
[12:51:42] <ChrisMorgan> cmr: r? https://github.com/mozilla/rust/pull/7676
[12:51:44] <dbaupp> Yoric: could I have more details? :P
[12:51:51] <Yoric> :)
[12:51:57] <cmr> ChrisMorgan: already in my review queue :)
[12:52:02] <ChrisMorgan> Good :-)
[12:53:44] *** Joins: maxli (maxli@F2D29657.F60B0462.67AC9B1.IP)
[12:54:14] <fabiand> sigma, I found grust - which iiuic helps you to use any gobject introspectable library .. and that's awesome - because it gives you access to the glib and gio universe :)
[12:54:41] <Seldaek> AutomatedTester: did you try Heka? I'm really curious about it because I'd rather avoid having to host more ruby (logstash) than I have to
[12:54:59] *** Joins: pnathan (Adium@B9840254.2CD8A5F8.477B877D.IP)
[12:55:21] <AutomatedTester> Seldaek: no sorry, I just have an interest in projects that dont use the normal python approach Mozilla normally uses
[12:55:37] <AutomatedTester> Seldaek: but as far as I know its in production for Firefox Sync
[12:56:27] *** Joins: MaikKlein (maik@moz-7BAD3439.dip0.t-ipconnect.de)
[12:56:49] *** Joins: roo_ (jesse@moz-A2C4A740.dynamic.ip.windstream.net)
[12:57:15] <Seldaek> AutomatedTester: that's nice, but production-ready for the author doesn't mean it's ready for general consumption :)
[12:57:15] <sigma> fabiand: that seems really useful, this is the first time I've ever written bindings for anything non-trivial so I'm enjoying it, but that'll be really useful with I want to "get things done" (tm)
[12:57:27] <AutomatedTester> Seldaek: to true
[12:57:29] <Seldaek> AutomatedTester: anyway I'll give it a shot when I have more free time (yay.)
[12:57:30] <cmr> sigma: which xml parser are you binding? libxml2?
[12:57:53] *** Quits: roo (jesse@moz-71DC5D53.dynamic.ip.windstream.net) (Ping timeout)
[12:58:30] <sigma> aye, well some of it
[12:58:35] <dbaupp> sigma: have you seen rust-bindgen?
[12:58:51] *** Quits: roo_ (jesse@moz-A2C4A740.dynamic.ip.windstream.net) (Ping timeout)
[12:58:56] <dbaupp> sigma: https://github.com/crabtw/rust-bindgen
[12:58:56] <sigma> nope! that sounds like somthing I should be using
[12:59:01] *** Joins: infynyxx (infynyxx@moz-E95B370B.nyc.res.rr.com)
[12:59:46] * ChrisMorgan loves being able to use Â§ in spec-referencing comments without needing a `# coding: utf-8` at the top of the file
[12:59:52] *** Joins: engla (engla@moz-DBD1D96E.cust.bredbandsbolaget.se)
[13:00:07] *** Joins: roo_ (jesse@moz-777BBF87.dynamic.ip.windstream.net)
[13:00:24] <sigma> dbaupp: that's absurdly useful, I probably should have googled around a bit more before just diving in straight from the manual
[13:00:25] <dbaupp> sigma: (I believe it's kept fairly closely up to date against master, but I'm not sure.)
[13:00:33] <dbaupp> heh :)
[13:00:33] *** Joins: jez0990 (quassel@moz-3BA8545E.kimsufi.com)
[13:01:08] *** Quits: Jesse (jruderman@moz-537BCF9.hsd1.ca.comcast.net) (Connection reset by peer)
[13:01:10] *** Quits: pnathan (Adium@B9840254.2CD8A5F8.477B877D.IP) (Ping timeout)
[13:01:51] *** Quits: roo_ (jesse@moz-777BBF87.dynamic.ip.windstream.net) (Ping timeout)
[13:01:53] <dbaupp> sigma: at least you know rust's ffi back-to-front now :P
[13:01:59] *** Joins: roo_ (jesse@moz-D313C4F5.dynamic.ip.windstream.net)
[13:02:29] *** Quits: dsirenko (mitra@8E712A0.54C21BA0.9F317420.IP) (Ping timeout)
[13:02:38] *** Joins: adu (ajr@moz-68CC2A5E.washdc.fios.verizon.net)
[13:02:57] *** Joins: robertknight (robertknig@moz-54528EE0.wby.mendeley.com)
[13:04:10] <cmr> So I'm looking at https://github.com/sfackler/rust/blob/0b63419e3a693920139b0627f450a759bd3aa38a/src/libextra/bitv.rs#L491
[13:04:17] <cmr> And thinking that that should be a &[bool]
[13:05:10] *** Quits: MaikKlein (maik@moz-7BAD3439.dip0.t-ipconnect.de) (Ping timeout)
[13:05:20] <cmr> at the very least &[u8]
[13:05:53] <dbaupp> cmr: yeah, &[bool], or just removed.
[13:07:15] <SimonSapin> how big is Rustâ€™s bool?
[13:07:23] *** Quits: roo_ (jesse@moz-D313C4F5.dynamic.ip.windstream.net) (Ping timeout)
[13:07:32] <cmr> rusti: std::sys::size_of<bool>()
[13:07:33] -rusti- <anon>:7:27: 7:31 error: unresolved name `bool`.
[13:07:33] -rusti- <anon>:7          std::sys::size_of<bool>()
[13:07:33] -rusti-                                     ^~~~
[13:07:33] -rusti- error: aborting due to previous error
[13:07:33] -rusti- application terminated with error code 101
[13:07:35] *** Joins: roo_ (jesse@moz-D313C4F5.dynamic.ip.windstream.net)
[13:07:37] <cmr> rusti: std::sys::size_of::<bool>()
[13:07:38] -rusti- 1
[13:07:47] <SimonSapin> bytes, I suppose
[13:08:04] <engla> yes it has the same representation as u8
[13:08:24] <dbaupp> *exactly* the same representation at the moment
[13:08:40] <engla> rusti: let x = 257 as bool; x as uint
[13:08:41] -rusti- 1
[13:08:49] <dbaupp> rusti: let x = 10u8 as bool; (x, x == true, x ^ true)
[13:08:50] -rusti- (true, false, true)
[13:08:56] <engla> see, it forgot about the bits outside u8
[13:09:25] <engla> SimonSapin: bool is weirder than it should be, just fyi
[13:09:33] <SimonSapin> how so?
[13:09:49] <engla> look closely at that dbaupp did. x is true but not == true?
[13:09:51] <cmr> "non-canonical bools"
[13:10:02] <engla> sleeper cell bools
[13:10:09] <dbaupp> also `"true" xor true == true`?
[13:10:11] <bstrie> don't case anything to bool
[13:10:19] <bstrie> why is that even supported
[13:10:28] <bstrie> kill it with fire
[13:10:37] <dbaupp> bstrie: because you can hide extra info in them
[13:10:57] <dbaupp> bstrie: also, people who write `if foo() == true {}` get tripped up
[13:10:58] <bstrie> dbaupp: that doesn't sound like a good idea
[13:11:00] <ChrisMorgan> rusti: std::sys::size_of::<[bool, ..8]>()
[13:11:01] -rusti- 8
[13:11:01] <engla> we'll cash in on security consulting in the future
[13:11:03] <ChrisMorgan> :-(
[13:11:20] <dbaupp> bstrie: and that's clearly worthy of punishment
[13:11:20] <bstrie> dbaupp: if foo() doesn't return a bool, then there's a good reason that they're getting tripped up
[13:11:31] *** Quits: roo_ (jesse@moz-D313C4F5.dynamic.ip.windstream.net) (Ping timeout)
[13:11:47] <dbaupp> bstrie: well, yeah, but the type system stops the comparison if it's not a bool.
[13:11:50] * dbaupp was joking
[13:11:54] <cmr> ChrisMorgan: I was thinking about optimizations like that too, but I don't think it's a good idea
[13:12:02] <ChrisMorgan> cmr: why not?
[13:12:04] <bstrie> dbaupp: it's too early in the morning for jokes
[13:12:09] *** Quits: StarLight (StarLight@moz-B9BF4242.dynamic.avangarddsl.ru) (Ping timeout)
[13:12:18] <dbaupp> bstrie: it's the perfect time at night for me :P
[13:12:20] <bstrie> my work computer crashed last night and I'm too pissed off for your frivolity :P
[13:12:29] <dbaupp> :( lose much?
[13:12:31] <bstrie> dammit windows mount the damn network drive!!
[13:12:36] <engla> there's a type for bit vectors in extra
[13:12:39] * bstrie rages
[13:13:19] <ChrisMorgan> Ah, we had to implement DES in Java last semester... the lack of unsigned types made using a 64-bit long for the 64-bit key a little difficult, but it worked. Some apparently used boolean[] for it.
[13:13:25] <bstrie> on the plus side I have an excuse for chatting on irc during work, which is that our code repositories are inaccessible to me
[13:14:05] <dbaupp> ChrisMorgan: and you?
[13:14:50] <ChrisMorgan> long. The only way to get decent performance. Mine ended up the fastest I saw in our quarter of the class.
[13:15:07] <ChrisMorgan> Made it a bit difficult when one of the later assignments was perf optimisation :D
[13:15:15] <cmr> ChrisMorgan: Just a feeling I have about it... it'd make debuginfo tricky, FFI tricky, reasoning about type size difficult..
[13:15:35] <dbaupp> ChrisMorgan: nice
[13:15:37] <ChrisMorgan> Yes, my implementation of DES in Java ended up only about 12 times as slow as the one in javax.crypto.
[13:15:51] <ChrisMorgan> (Which is naturally not written in Java.)
[13:15:54] *** Joins: roo (jesse@moz-D313C4F5.dynamic.ip.windstream.net)
[13:15:58] *** Joins: MaikKlein (maik@moz-7BAD3439.dip0.t-ipconnect.de)
[13:16:10] *** Joins: StarLight (StarLight@moz-D9755DF.dynamic.avangarddsl.ru)
[13:16:17] <engla> ok question about traits in libextra.. if there is a new trait Deque, users now have to "use" both the trait and the concrete type for it to be useful. That's both confusing and annoying. In libstd it's solved by importing traits in Prelude? What about trait Deque in libextra
[13:16:24] <engla> should it go the same way, into libstd?
[13:16:57] <ChrisMorgan> cmr: who wants to reason about type size? Efficiency, man, efficiency! But then again, I don't know how much you'd get people using bool vectors, and bool is the only sub-byte datatype (right?)
[13:17:11] *** Quits: Earnestly (earnest@2AB30F53.FB5005.2BCC804A.IP) (Ping timeout)
[13:17:21] <cmr> ChrisMorgan: currently yes
[13:17:29] <dbaupp> engla: I think suffer the pain for the moment, and see how things play out
[13:17:37] <dbaupp> ChrisMorgan: `Ascii` s 7 bits
[13:17:38] <cmr> ChrisMorgan: we do already have bitv for it
[13:17:39] <dbaupp> *is
[13:18:10] <dbaupp> ChrisMorgan: it'd make a whole pile of vec code special cased and complicated, I guess
[13:18:13] *** Joins: sankha93 (Instantbir@BDB5E925.8ACFB64A.EFB84E89.IP)
[13:18:15] *** Quits: roo (jesse@moz-D313C4F5.dynamic.ip.windstream.net) (Ping timeout)
[13:18:51] <engla> dbaupp: I guess it's a good idea to just try and see.. I'm trying to plan too much ahead.
[13:19:14] <dbaupp> engla: yeah, I get that too :)
[13:19:19] *** Quits: adu (ajr@moz-68CC2A5E.washdc.fios.verizon.net) (Quit: adu)
[13:19:41] <ChrisMorgan> engla: let the library specify traits that should be imported when the type is imported. That'd fix it in various other places too, though default method implementations will sort out most of them in my caseâ€”when they work with trait/kind requirements like `Send`.
[13:20:10] <dbaupp> ChrisMorgan: (as an example, what would .slice(start, end) do for &[bool])
[13:20:24] <ChrisMorgan> dbaupp: I guess Ascii could be 7-bit... unless you wanted it to be true to the original and write a parity bit
[13:20:24] <dbaupp> (you could have a slice starting/ending inside a byte.)
[13:20:30] <engla> ok ChrisMorgan, in this case I think default methods don't apply
[13:20:47] <dbaupp> ChrisMorgan: I guess so.
[13:21:05] <dbaupp> ChrisMorgan: I don't think the current implementation does anything fancy like that though.
[13:21:17] <ChrisMorgan> It'd be rather a waste, really.
[13:21:18] <cmr> Packed 7-bit data would be horrible :\
[13:21:33] <cmr> To actually use, that is.
[13:22:48] *** Joins: msingle (Thunderbir@moz-930E5D97.hr.hr.cox.net)
[13:22:54] <ChrisMorgan> Unlikely to yield a net perf win.
[13:23:14] <Ms2ger> Sounds more like a perf loss
[13:23:20] <engla> the lz4 compression algo is very fast because it is byte oriented
[13:23:35] <engla> splitting bits is a lot of work
[13:23:38] *** Quits: maxli (maxli@F2D29657.F60B0462.67AC9B1.IP) (Quit: Leaving.)
[13:23:48] *** Joins: maxli (maxli@F2D29657.F60B0462.67AC9B1.IP)
[13:27:21] *** Joins: hjr3 (hradtke@moz-E87BDF1F.socal.res.rr.com)
[13:27:25] *** Joins: Earnestly (earnest@2AB30F53.FB5005.2BCC804A.IP)
[13:27:37] *** Joins: bytewise (bytewise@moz-649C630D.unitymediagroup.de)
[13:27:52] *** Joins: dsirenko (mitra@8E712A0.54C21BA0.9F317420.IP)
[13:28:11] *** Quits: pyrac (pyrac@moz-8862B13A.w92-162.abo.wanadoo.fr) (Quit: pyrac)
[13:29:08] <dbaupp> cmr: with https://github.com/mozilla/rust/pull/7695
[13:29:10] *** Joins: pyrac (pyrac@moz-8862B13A.w92-162.abo.wanadoo.fr)
[13:29:26] <dbaupp> cmr: that doesn't look "prettier" to me
[13:29:50] <cmr> dbaupp: subjective
[13:29:58] <dbaupp> cmr: correct :)
[13:30:13] <engla> it's already confusing with left and right
[13:30:20] <cmr> at the very least it's more informative, plus it shows that equality is tested in both directions
[13:30:24] *** Joins: erickt (erickt@8C9ECD8F.3A598286.F12515B4.IP)
[13:30:28] <engla> usually you call them first and second argument
[13:30:54] *** Quits: Houm (Houm@moz-25669AA8.fbx.proxad.net) (Ping timeout)
[13:30:57] *** Quits: jorendorff (jorendorff@moz-2F32ACA3.hsd1.tn.comcast.net) (Quit: jorendorff)
[13:30:58] <dbaupp> cmr: it just seems like repeating the condition is less useful than just saying assert_eq failed, although showing both directions is neat, i guess
[13:31:13] <dbaupp> cmr: (less useful in the sense that it is a lot of extra noise)
[13:31:26] <cmr> dbaupp: you shouldn't have to look in the source to see that equality is tested in both directions
[13:31:32] <cmr> which could be the source of bugs I think?
[13:31:36] <cmr> a.eq(b) vs b.eq(a)
[13:32:00] <dbaupp> what do other libraries/languages do on their equivalent of assert_eq?
[13:32:02] *** Joins: Houm (Houm@moz-25669AA8.fbx.proxad.net)
[13:32:53] <nmatsakis> pnkfelix: pong
[13:33:04] *** Quits: erickt (erickt@8C9ECD8F.3A598286.F12515B4.IP) (Ping timeout)
[13:33:45] *** Joins: roo (jesse@moz-9A53149A.ip.windstream.net)
[13:34:21] *** Joins: bent (chatzilla@F2D29657.F60B0462.67AC9B1.IP)
[13:34:23] <pnkfelix> nmatsakis: in the GC discussion, I, like Graydon (i think), had assumed that we would "simply" attach a write-barrier to every write into a Cell, regardless of whether it is @Cell or &Cell, etc
[13:34:57] <pnkfelix> nmatsakis: the main reason for this: pcwalton noted that for GenGC, you want to get the generation number for both the referrer and the referent
[13:35:38] <pnkfelix> nmatsakis: this is so you can filter aggressively, to avoid the remembered set blowing up (because a large remset is costly at the very least in the time spent scanning it)
[13:35:41] <dbaupp> cmr: e.g. HUnit says: "expected: 1\n but got: 2"
[13:35:48] <nmatsakis> pnkfelix: well, the story is a bit trickier,
[13:35:51] <cmr> dbaupp: which one is the expected?
[13:35:56] <cmr> dbaupp: left, or right?
[13:36:05] <nmatsakis> pnkfelix: but that shouldn't be a problem,
[13:36:07] <cmr> that's the reason we have left/right now, "expected" and "actual" are confusing
[13:36:27] <pnkfelix> nmatsakis: in some of the options you laid out, the write-barrier is done solely at the time of the borrow
[13:36:28] <nmatsakis> pnkfelix: main thing is this: when the value is borrowed as mutable, you give away a pointer and we can't trap the writes to that ptr,
[13:36:30] <dbaupp> cmr: `1 ~=? 2`, `?` indicates the one being tested, so the situation is different there
[13:36:35] <nmatsakis> pnkfelix: but when the pointer is returned, we can scan
[13:36:54] <nmatsakis> pnkfelix: so I imagine that we would add to a temporary "borrowed set" and then, at the end, remove from that set but possibly add to the remembered set
[13:36:56] *** Quits: hjr3 (hradtke@moz-E87BDF1F.socal.res.rr.com) (Quit: My MacBook has gone to sleep. ZZZzzzâ€¦)
[13:37:00] <pnkfelix> nmatsakis: Are we handing the borrowed pointer off to native code?
[13:37:05] <nmatsakis> pnkfelix: yeah I oversimplified,
[13:37:08] <nmatsakis> pnkfelix: that's the full story
[13:37:10] <pnkfelix> nmatsakis: Ah
[13:37:15] <nmatsakis> just didn't want to go into it
[13:37:25] <pnkfelix> nmatsakis: Okay, that's the situation where I had imagined we would *pin* the object
[13:37:33] <nmatsakis> pnkfelix: well, it will also be pinned,
[13:37:48] <pnkfelix> nmatsakis: (and I guess add it to a list of roots that need to be scanned at GC time)
[13:37:52] <nmatsakis> pnkfelix: at least it would be in a mostly copying scheme
[13:37:55] *** Joins: AndroUser (androirc@moz-BE11A887.range109-151.btcentralplus.com)
[13:38:00] <engla> cmr: I'd prefer not introducing variables like 'left' and 'right' since it's not related to the left and right side of the == sign
[13:38:05] *** Joins: saml (sam@moz-14C16814.cst.lightpath.net)
[13:38:07] <Seldaek> rusti: [1, 2, 3].max()
[13:38:08] -rusti- <anon>:7:9: 8:5 error: failed to find an implementation of trait std::iterator::Iterator<<V5>> for [int, .. 3]
[13:38:08] -rusti- <anon>:7          [1, 2, 3].max()
[13:38:08] -rusti- <anon>:8     };
[13:38:08] -rusti- application terminated with error code 101
[13:38:12] <Seldaek> why's that?
[13:38:14] <cmr> engla: I'd be fine with first/second
[13:38:15] <dbaupp> engla: it's related to `assert_eq!(left, right)`
[13:38:30] <nmatsakis> a/b!! a/b!!
[13:38:32] <dbaupp> Seldaek: fixed length vectors suck.
[13:38:37] <engla> dbaupp: I understand, but you usually don't call function-ish arguments left and right
[13:38:40] <pnkfelix> nmatsakis: In my mind these two cases are quite different, I think that's why I've been having a lot of trouble following the conversation
[13:38:50] <dbaupp> engla: yeah, right.
[13:38:57] <nmatsakis> pnkfelix: which two cases? it's also possible I'm conflating things
[13:39:05] <engla> first and second are better
[13:39:07] <nmatsakis> pnkfelix: I just sat down and read the mostly copying thesis, or most of it,
[13:39:11] <Seldaek> dbaupp: not sure I get why/what you mean
[13:39:17] <dbaupp> Seldaek: actually, I'm wrong
[13:39:17] <nmatsakis> pnkfelix: on the train this morning. so I at least have a good handle on what that scheme does I guess
[13:39:24] <dbaupp> rusti: [1, 2, 3].iter().max()
[13:39:26] -rusti- more than 5 lines of output, pastebinned: http://sprunge.us/cMaD
[13:39:40] <pnkfelix> nmatsakis: (i.e., one case being "its all Rust code, with a function that receives an &Cell, but no unsafe blocks within it")
[13:39:44] <dbaupp> rusti: let v =[1, 2, 3]; v.iter().max()
[13:39:46] -rusti- more than 5 lines of output, pastebinned: http://sprunge.us/Leej
[13:40:01] <dbaupp> rusti: let v =[1, 2, 3]; *v.iter().max()
[13:40:02] -rusti- <anon>:7:27: 8:5 error: can only dereference enums with a single variant which has a single argument
[13:40:02] -rusti- <anon>:7          let v =[1, 2, 3]; *v.iter().max()
[13:40:02] -rusti- <anon>:8     };
[13:40:02] -rusti- error: aborting due to previous error
[13:40:02] -rusti- application terminated with error code 101
[13:40:09] * dbaupp sighs
[13:40:12] <nmatsakis> :)
[13:40:29] <Seldaek> dbaupp: I'm glad I'm not the only one that's utterly confused :p
[13:40:30] <pnkfelix> nmatsakis: and another case, perhaps with important subcases, being "Rust code that receives a &Cell and transfers it across the FFI", and perhaps also "Rust code that receives an &Cell and references it within unsafe blocks"
[13:40:36] <nmatsakis> rusti: let v = [1, 2, 3]; v.iter().max().get()
[13:40:36] <dbaupp> Seldaek: .max() is now implemented on Iterators
[13:40:37] -rusti- more than 5 lines of output, pastebinned: http://sprunge.us/ThAC
[13:40:48] <dbaupp> rusti: let v = [1, 2, 3]; *v.iter().max().get()
[13:40:48] <Seldaek> dbaupp: but yeah I get your point
[13:40:49] -rusti- 3
[13:40:59] <dbaupp> Seldaek: not confused, just kept making mistakes
[13:41:00] <pnkfelix> nmatsakis: I am trying to understand if people are combining these two cases into one just to handle the most general scenario
[13:41:00] <nmatsakis> there we go!
[13:41:01] *** Joins: AndroUser2 (androirc@moz-CC757AD0.dab.02.net)
[13:41:22] <pnkfelix> nmatsakis: (or perhaps because they do not see value in treating the first case in a special manner)
[13:41:35] <nmatsakis> pnkfelix: sorry, what is case 1 and what is case 2?
[13:41:43] <Seldaek> dbaupp: yeah I mean this isn't straightforward enough if knowledgeable people keep doing mistakes, but I guess it's due to the rate of change as well
[13:42:05] *** Joins: reyre (reyre@86C3727C.33EE9F8A.1139E686.IP)
[13:42:12] <dbaupp> Seldaek: yeah
[13:42:28] *** Quits: AndroUser (androirc@moz-BE11A887.range109-151.btcentralplus.com) (Ping timeout)
[13:42:32] <nmatsakis> pnkfelix: write barrier vs pinning?
[13:42:33] <pnkfelix> nmatsakis: Case 1 is something like your example from the email: "fn modify(x: &Cell<@T>, y: @T) { *x.as_mut() = y; }"
[13:42:48] <pnkfelix> nmatsakis: This is Rust code with no unsafe blocks, and no transfers across the FFI
[13:42:59] <dbaupp> Seldaek: (although 1 mistake is a bug, another was due to how IRC-rusti works, so they don't really count :P )
[13:43:17] <cmr> engla: dbaupp: so r+ or do you want me to change the message after some further bikeshedding?
[13:43:22] <nmatsakis> Seldaek: you shouldn't need the temporary, that's a bug...though a tricky one
[13:44:04] <pnkfelix> nmatsakis: case 2 is where the fn passes `x` and/or `y` across the FFI, or into an `unsafe` block (which is probably most easily modelled as another kind of transfer across the FFI, in terms of saying "must be handled in most conservative manner)
[13:44:18] <dbaupp> cmr: don't know, I'm happy enough with the current one, so I'll leave it to someone else to r+ it (I won't argue against changing it though)
[13:44:21] <Seldaek> dbaupp: hehe, anyway do I understand right that the .get() is only in case the vec would be empty because there's no null in rust?
[13:44:44] <Seldaek> dbaupp: and the .iter I was missing is to first grab an interator, which I think there should be shortcuts for, but that's maybe just me
[13:44:51] <pnkfelix> nmatsakis: Now that I write this down, I'm realizing that actually distinguishing the two cases would require us to attach meta-data to the fn's in question, i.e. an effect system I guess
[13:44:51] <dbaupp> Seldaek: yeah, Iterator<A>.max() -> Option<A> in case the iterator is empty
[13:45:03] <dbaupp> Seldaek: "shortcuts"?
[13:45:20] <nmatsakis> pnkfelix: so, iiuc, you are implying that in case 1, it'd be plausible not to pin?
[13:45:28] <Seldaek> dbaupp: it feels like every second thing you want to do with a vec these days requires a .iter() first, why not vec.max() and that would do an iter().max() internally?
[13:45:35] <pnkfelix> nmatsakis: yes, I think it is plausible to not pin in case 1
[13:45:46] <cmr> Seldaek: because that'd require lots of useless boilerplate.
[13:45:47] <dbaupp> Seldaek: maybe that can be added later
[13:45:53] <nmatsakis> pnkfelix: one stumbling block is that it is difficult to impossible to get precise stack information out of LLVM
[13:45:57] <cmr> Seldaek: it's coming, be patient (it's planned as Iterable)
[13:46:13] <nmatsakis> pnkfelix: and even if we could, it inhibits some optimizations (though probably not a lot)
[13:46:16] <pnkfelix> nmatsakis: well, okay.  That's where the mostly-copying stuff comes in
[13:46:21] <dbaupp> Seldaek: but, until a month ago, the vec api was *huge* with a lot of pointless/redundant methods/functions
[13:46:22] <nmatsakis> pnkfelix: yes, precisely
[13:46:29] <Seldaek> cmr: true that, but it's a bit of a pain for discoverability right now, I was trying to implement max on Ord myself because I didn't find it
[13:46:29] <pnkfelix> nmatsakis: in terms of pinning conservatively the things reachable from the stack
[13:46:30] <nmatsakis> pnkfelix: but it's the mostly copying scheme that causes scenario 1 to pin
[13:46:48] <dbaupp> Seldaek: so strcat and I removed almost everything that could be written another way
[13:46:54] <pnkfelix> nmatsakis: â€¦ okay wait, let me see here
[13:47:03] <pnkfelix> nmatsakis: maybe that was not the point I was attempting to make.
[13:47:11] <dbaupp> Seldaek: (assuming that other way wasn't too ridiculous)
[13:47:41] <pnkfelix> nmatsakis: let me revisit something you said above
[13:47:45] <cmr> Seldaek: that's a documentation problem for the most part
[13:47:51] <mark_edward> i have a while loop that's behaving weirdly. it won't quit, even though, using print statements i know the condition is being met... 
[13:47:59] *** Quits: roo (jesse@moz-9A53149A.ip.windstream.net) (Ping timeout)
[13:48:02] <cmr> also I think there's a max in std::cmp
[13:48:03] <dbaupp> mark_edward: code?
[13:48:11] <nmatsakis> anybody havea any idea what's going on here? https://github.com/mozilla/rust/pull/7688
[13:48:16] <Seldaek> dbaupp: fair enough, still would be nice if this was possible implicitly somehow, because the compiler tells you "yo there's no iterator implemented for [int, ..]" and that's weird when it means that I forgot to turn the vec into an iterator
[13:48:20] <mark_edward> dbaupp: it's a lot, i'll push on GH and link the relevant lines
[13:48:22] <nmatsakis> as far as I can tell, all the tests were interrupted,
[13:48:25] <nmatsakis> but it happened twice in a row,
[13:48:26] <nmatsakis> so I'm confused.
[13:48:28] <dbaupp> cmr, Seldaek: and one in std::num::Orderable
[13:48:47] <Seldaek> cmr: yup but that only works on max(a, b), not on a vec
[13:48:57] <pnkfelix> nmatsakis: let me try again.
[13:49:25] <mark_edward> dbaupp: https://github.com/MarkJr94/bzip2rs/blob/master/bzip2.rs#L181-L202
[13:49:36] <pnkfelix> nmatsakis: people are talking about trying to only put the write-barrier code at the boundary where borrowing occurs, *not* at the point where the write itself occurs, right?  This is how I interpret your statement "but when the pointer is returned, we can scan"
[13:49:42] *** Joins: roo (jesse@moz-9A53149A.ip.windstream.net)
[13:49:58] *** Joins: Azdle (Azdle@moz-B334B496.hfc.comcastbusiness.net)
[13:50:03] <Seldaek> dbaupp: I'm just thinking it would be better if vecs were iterator themselves instead of having an iter() function, but maybe that's a PITA to do 
[13:50:09] <mark_edward> dbaupp: an sample output https://gist.github.com/MarkJr94/5975600
[13:50:23] <bstrie> Seldaek: iirc that's the eventual idea
[13:50:23] <dbaupp> Seldaek: be patient! Changes are planned! :P
[13:50:28] <mark_edward> it seems to be somehow skipping the first print statement and the loop test, i dont know how!
[13:51:03] <dbaupp> Seldaek: one change would be converting slices to be (start pointer, end pointer) (I have a feeling this isn't likely)
[13:51:14] <Seldaek> dbaupp: well I am not saying it has to be like that now, I'm just asking the questions because I don't know the plans and think it'd be sad if it ends up painful to use
[13:51:28] <dbaupp> Seldaek: the other (which is very likely) is a trait with default methods for all the Iterator functions
[13:51:32] <nmatsakis> pnkfelix: that's right
[13:52:00] *** Quits: rajul (quassel@F90C88F7.3471B448.25B273F5.IP) (Client exited)
[13:52:10] <pnkfelix> nmatsakis: I do not see how to do that while also filtering out the writes of the form A -> B where A and B are both tenured.
[13:52:18] <bstrie> Seldaek: strcat intends the iter() to be unnecessary eventually
[13:52:26] <Seldaek> ok that'd be great
[13:52:38] <nmatsakis> pnkfelix: I imagine this. You have the tenured set, the borrowed set, and the remembered set.
[13:52:40] <Seldaek> if one could do rev_iter() when that's needed, but no iter() when you don't care
[13:52:40] <pnkfelix> nmatsakis: because if you do not observe the writes when they occur
[13:52:48] <nmatsakis> pnkfelix: when you borrow a tenured item, you put the item into the borrowed set.
[13:53:04] <nmatsakis> pnkfelix: when the borrow ends, you scan the contents; if it now contains anything non-tentured, it goes into the remembered set.
[13:53:07] <mark_edward> dbaupp: any ideas?
[13:53:08] <dbaupp> Seldaek: in any case, calling .iter() isn't that painful (if/when the rvalue lifetime bug gets resolved), and the discoverability problems can be overcome by better docs/tutorials.
[13:53:13] <dbaupp> mark_edward: nope :(
[13:53:15] <nmatsakis> pnkfelix: when a collection occurs, you always scan the borrowed set + remembered set
[13:53:20] <dbaupp> mark_edward: looks fine to me
[13:53:26] <cmr> nmatsakis: failure on https://github.com/mozilla/rust/pull/7688 is weird... *all* of the builds are being interrupted
[13:53:30] <nmatsakis> pnkfelix: essentially you're just eagerly scanning
[13:53:34] <nmatsakis> cmr: yes, twice in a row, I am confused.
[13:53:35] <pnkfelix> nmatsakis: â€¦ (I was about to say "how will you know if a A -> C reference was introduced and then overwritten by a A -> B reference", where C is in the nursery and B is tenured)
[13:53:40] <mark_edward> dbaupp: it's so weird! you see how the first print statement is getting skipped?
[13:53:50] <pnkfelix> nmatsakis: (but I'm now thinking that it would be okay to overlook those cases)
[13:53:56] <nmatsakis> pnkfelix: you don't know, but you dont' care
[13:54:06] <dbaupp> mark_edward: (I'm not running the code, btw.)
[13:54:19] <mark_edward> dbaupp: i linked sample output in agist
[13:54:31] <nmatsakis> pnkfelix: in fact, this is arguably a strength of the approach, it could have a smaller remembered set? but I think that's pretty marginal, and it's counterbalanced by the fact that you must scan the borrowed set in full
[13:54:42] <dbaupp> mark_edward: gah, sorry, too many concurrent conversations :)
[13:54:47] <pnkfelix> nmatsakis: some kinds of incremental collectors might care about catching those intermediate writes.  But a snapshot-at-the-beginning wouldn't (I'm not 100% clear why pcwalton ruled that out at the outset)
[13:54:48] <nmatsakis> pnkfelix: (unless I'm wrong and you do care, but I don't see why you should; there was a ref, but there's not now)
[13:54:49] <mark_edward> no prob
[13:55:04] <Seldaek> dbaupp: it's not so painful when you know it I suppose :)
[13:55:14] <nmatsakis> pnkfelix: that's possible; I've been thinking solely about generational,
[13:55:36] <dbaupp> Seldaek: yeah, and I guess (if it doesn't get removed) it'll be one of the first things to be mentioned in tutorials
[13:55:39] <nmatsakis> pnkfelix: however, I think we'll just have to design incremental with this constraint in mind,
[13:55:39] <Seldaek> dbaupp: and certainly it isn't .IteratorIteratorAbstractFactory() so who am I to complain :)
[13:55:49] <nmatsakis> pnkfelix: it's not plausible to intercept *every* &mut T write, I don't think.
[13:55:50] <dbaupp> Seldaek: since iterating over things is fairly common
[13:55:56] <pnkfelix> nmatsakis: scanning the entire object on return may be painful.   Though I guess the scanning could perhaps be specialized to inspect solely the fields that point to mutable+managed things.  Or something.
[13:56:06] <engla> cmr: I'm not a reviewer, but I stand by my opinion on left and right as confusing
[13:56:09] <nmatsakis> pnkfelix: it violates the "pay as you go" principle, GC hurts everything even if unused
[13:56:16] <cmr> engla: what would you replace it with?
[13:56:24] <dbaupp> mark_edward: that looks extremely strange :(
[13:56:27] <nmatsakis> pnkfelix: yes, I presume we'll have a custom visitor,
[13:56:39] <mark_edward> dbaupp: yeah, i don't get it...
[13:56:40] <Seldaek> dbaupp: yeah, and despite my ranty mood I have to say the new iter stuff looks great 
[13:56:43] <nmatsakis> pnkfelix: it may be painful, I don't know, but it is what it is. What choice is there? 
[13:56:51] <pnkfelix> nmatsakis: I agree we cannot intercept the ones that go across the FFI boundary.  I've been trying to determine if there's value in handling the other cases.
[13:56:59] <dbaupp> mark_edward: can you reduce the scope of the unsafe block?
[13:57:09] <pnkfelix> nmatsakis: s/other cases/other case/
[13:57:11] <mark_edward> dbaupp: sure
[13:57:41] <nmatsakis> pnkfelix: from my point of view, it's not even an option. As I said, it violates what I regard as a core tenet of Rust, that basic C-like code compiles down just as it would in C.
[13:57:41] <pnkfelix> nmatsakis: but like I said above, I guess that would require an effect system to reap the benefit.  And it wouldn't have to be in 1.0
[13:57:42] <dbaupp> mark_edward: (it's generally a good practice to make them as small as is reasonable, since unsafe is unsafe :P )
[13:58:13] <dbaupp> Seldaek: yeah, I'm enjoying using it too; you've got strcat to thank for it :)
[13:58:16] *** Quits: MaikKlein (maik@moz-7BAD3439.dip0.t-ipconnect.de) (Ping timeout)
[13:58:16] <nmatsakis> pnkfelix: I mean if every bit of code like `*t += 1` has to check in with the GC... ick.
[13:58:39] <cmr> Very much ick; would make Rust untenable for me
[13:58:45] <pnkfelix> nmatsakis: I dunno, from my POV, it would not be unreasonable to say that when Cell is in the type, like &Cell, you can get write-barrier overheads.
[13:58:55] <nmatsakis> pnkfelix: Cell<T> is a different story. I'm fine with that.
[13:58:58] <engla> cmr: first argument `true` does not equal second argument `false`. I'd have another message show up if the symmetric property is invalid
[13:59:04] <nmatsakis> pnkfelix: I'm just not ok with intercepting every `&mut T` for any T
[13:59:14] <nmatsakis> pnkfelix: the thing is, if you have a Cell<T>, you can extract an &mut T
[13:59:27] <nmatsakis> pnkfelix: so if you want to intercept at the point of write, you have to intercept *every &mut T*
[13:59:29] <ChrisMorgan> rusti: let text = ~"foo bar"; let words = text.word_iter().collect(); words
[13:59:30] -rusti- <anon>:7:44: 7:71 error: cannot determine a type for this bounded type parameter: unconstrained type
[13:59:30] -rusti- <anon>:7          let text = ~"foo bar"; let words = text.word_iter().collect(); words
[13:59:30] -rusti-                                                      ^~~~~~~~~~~~~~~~~~~~~~~~~~~
[13:59:30] -rusti- application terminated with error code 101
[13:59:42] <pnkfelix> nmatsakis: okay, that's part of the problem, I've been misunderstanding the API
[13:59:44] <nmatsakis> pnkfelix: that's kind of the point of Cell<T>... it's something you can use to get an &T or an &mut T
[13:59:56] <dbaupp> rusti: let text = ~"foo bar"; let words = text.word_iter().collect::<~[&str]>(); words
[13:59:57] -rusti- ~["\x00oo", "bar"]
[14:00:00] <nmatsakis> pnkfelix: yeah I just realized that this was probably part of the confusion
[14:00:05] <nmatsakis> pnkfelix: I don't think we spelled out the API anywhere
[14:00:15] * dbaupp wonders how that got through borrowck
[14:00:15] <pnkfelix> nmatsakis: well, I should have figured it out from your example
[14:00:17] *** Joins: jedestep (jedestep@34641662.FB4DE631.66C78B76.IP)
[14:00:24] <ChrisMorgan> Can anyone tell my why that's failing to compile?
[14:00:26] *** Quits: jedestep (jedestep@34641662.FB4DE631.66C78B76.IP) (Quit: leaving)
[14:00:30] *** Joins: jedestep (jedestep@34641662.FB4DE631.66C78B76.IP)
[14:00:34] <Seldaek> dbaupp: \x00oo?
[14:00:37] <dbaupp> nmatsakis: is that rusti output a known bug? ^
[14:00:54] <pnkfelix> nmatsakis: since it could have been written with `fn modify` broken up into two functions; that would have made it explicit
[14:00:56] <ChrisMorgan> Sorry, missed your line somehow, dbaupp
[14:00:57] <cmr> ChrisMorgan: .collect() can return any collection, you need to tell it which one you want via type hint
[14:00:58] <dbaupp> Seldaek: a bug, shouldn't be able to return a slice to a ~str from inside a block
[14:00:58] <nmatsakis> dbaupp: hmm I didn't know about that bug!
[14:01:14] <nmatsakis> dbaupp: though there are some known bugs where simple examples get through the region checker which shouldn't, I've been wanting to look into those,
[14:01:14] <mark_edward> dbaupp: new code https://github.com/MarkJr94/bzip2rs/blob/master/bzip2.rs#L180-L203
[14:01:17] <dbaupp> Seldaek: (inside the block where the ~str is allocated.)
[14:01:20] <nmatsakis> dbaupp: but that example surprises me a bit
[14:01:34] <ChrisMorgan> What else could such a line output?
[14:01:43] <pnkfelix> nmatsakis: this "borrowed set" idea
[14:01:57] <Seldaek> dbaupp: is that like a memory corruption of some sort where the first byte was nulled?
[14:02:01] <dbaupp> nmatsakis: for reference, rusti is running `let v = { input }; print(v);` or something
[14:02:02] <cmr> ChrisMorgan: hashset, linked list, any container
[14:02:10] <nmatsakis> dbaupp: yeah let's try and make a standalone test,
[14:02:18] <nmatsakis> dbaupp: huh.
[14:02:37] <dbaupp> Seldaek: yeah, more use-after-free
[14:02:40] <pnkfelix> nmatsakis: Am I right we could refine it to track the individual fields being borrowed by Cell at the `as_mut()` invocation?
[14:03:09] <pnkfelix> nmatsakis: (I'm trying to see if there's some way to avoid scanning the whole object.)
[14:03:11] <Seldaek> dbaupp: yeah ok, I lack the proper terminology to even express questions in a sensible way it seems :)
[14:03:21] <ChrisMorgan> cmr: ah, I get it
[14:03:30] *** Joins: doomlord (doomlod@moz-13E69BC8.range86-180.btcentralplus.com)
[14:03:31] <nmatsakis> pnkfelix: I don't know how? the API I envision for Cell is that it yields &mut T where T is the type of the content in the cell,
[14:03:36] <ChrisMorgan> But that \x00oo isn't exactly encouraging...
[14:03:53] <dbaupp> ChrisMorgan: yeah, that code should've been disallowed
[14:03:56] <nmatsakis> pnkfelix: maybe it could be done by integrating into the compiler in some cases
[14:04:13] <dbaupp> ChrisMorgan: the bug is in the borrow/region/lifetime checker
[14:04:29] *** Quits: AndroUser2 (androirc@moz-CC757AD0.dab.02.net) (Ping timeout)
[14:04:50] <ChrisMorgan> dbaupp: why disallowed? Where exactly are those strings borrowed from?
[14:05:12] <cmr> ChrisMorgan: it's letting references to an allocation in that scope leak from the scope
[14:05:13] <pnkfelix> nmatsakis: okay.  I'll try keep myself abreast of reality.
[14:05:23] <cmr> ie, dangling pointer
[14:05:26] <dbaupp> ChrisMorgan: the local ~str 'text', which gets freed as soon as the block exits
[14:06:08] <ChrisMorgan> Oh yeah, I see; that's how it fits in with your statement of rusti's `let v = { input }; print(v);` and why it doesn't fail thus in real life code
[14:07:07] <nmatsakis> dbaupp: investigating a bit now. curious.
[14:07:30] <nmatsakis> pnkfelix: to me this feels like a very distant concern;
[14:08:08] <nmatsakis> pnkfelix: like we're talking about a small percentage improvement on the perf of the GC
[14:08:14] <pnkfelix> nmatsakis: I don't think its small
[14:08:27] <pnkfelix> nmatsakis: but I might have the wrong mental model
[14:08:46] <mark_edward> dbaupp: check this out! https://github.com/MarkJr94/bzip2rs/blob/master/bzip2.rs#L207-L210
[14:08:54] * ChrisMorgan is actually rather enjoying getting into the nitty-gritty of how HTTP works internally
[14:09:01] <mark_edward> dbaupp: that print statement executes, an it still does on the the next statement!!!!
[14:09:12] <dbaupp> mark_edward: what. :/
[14:09:29] <mark_edward> dbaupp: the while loop executes again!
[14:09:40] <pnkfelix> nmatsakis: and it might be that there could be ways to program around the problems I'm envisaging
[14:09:44] <dbaupp> mark_edward: yeah, that is... strange
[14:09:55] <cmr> mark_edward: sounds like invalid codegen
[14:09:55] <dbaupp> mark_edward: can you step it in gdb or something?
[14:10:12] <cmr> stepping in gdb still doesn't work quite yet
[14:10:16] <dbaupp> mark_edward: (possibly removing the print, since that'll generate a lot of useless stuff)
[14:10:24] <mark_edward> dbaupp: sure, what should i look for?
[14:10:26] <dbaupp> cmr: per instruction stepping does
[14:10:33] <dbaupp> mark_edward: hm, don't know.
[14:10:41] <pnkfelix> nmatsakis: (e.g. I'm worried about scanning large objects if the borrowed-set is just tracking a set of objects, rather than fields or pages within objects.  But if that problem arises, the developer *might* be able to refactor their code to avoid making large objects.)
[14:10:49] <cmr> dbaupp: yeah but that's using a nuclear missle as a fly swatter
[14:10:57] <dbaupp> mark_edward: possibly easier to file a bug and get someone who's got some experience with trans/codegen to debug it :)
[14:11:07] <pnkfelix> nmatsakis: (its not really something I want to promote, but I'll acknowledge that it exists as a work-around for these hypothetical issues.)
[14:11:12] <dbaupp> cmr: but we don't have a fly swatter yet :(
[14:11:33] <mark_edward> okay, i'll try. i should open an issue on mozilla/rust, right?
[14:11:35] <cmr> Inspecting the IR would be the best bet I'd think
[14:12:06] *** Quits: jaen (jaen@moz-C9423CB8.neoplus.adsl.tpnet.pl) (Ping timeout)
[14:12:25] *** Joins: lmandel (lmandel@F2D29657.F60B0462.67AC9B1.IP)
[14:13:03] *** Joins: jdm (jdm@F2D29657.F60B0462.67AC9B1.IP)
[14:13:53] <nmatsakis> pnkfelix: yes I was going to say, developer may be able to refine the size of the Cell
[14:14:57] <dbaupp> nmatsakis: I have a feeling it requires multiple levels of traits and so on, and the 'self region gets lost in there somewhere (I can only reproduce it with the code above methods)
[14:14:59] <mark_edward> cmr: I have the IR... and i've found the method, but i'm nto sure what i'm looking for...
[14:15:05] <dbaupp> s/ methods//
[14:15:24] <dbaupp> mark_edward: making a smallish testcase would be a start
[14:15:37] <mark_edward> okay
[14:15:56] <dbaupp> mark_edward: (i.e. delete things until the loop starts breaking properly)
[14:18:57] <pnkfelix> nmatsakis: Right.  And I need to remember that we're "only" scanning the Cell, not the block of memory that the Cell is allocated within, right?
[14:20:30] <mark_edward> dbaupp: found it. commenting out this https://github.com/MarkJr94/bzip2rs/blob/master/bzip2.rs#L191-L194 makes it run correctly
[14:20:35] <pnkfelix> nmatsakis: (those quotes around "only" are not meant as sarcasmâ€¦ rather to acknowledge that while Cells could hypothetically be large, maybe in the common case they won't be.  Which is maybe the point you've been making.)
[14:21:21] <nmatsakis> pnkfelix: yes, only scanning the cell, though I don't know whether that will commonly be the entire obj or not
[14:21:21] <dbaupp> mark_edward: what happens if you write `fail!(..)` instead of `return fail!(..)`?
[14:21:26] <nmatsakis> pnkfelix: but it need not be
[14:21:43] <mark_edward> dbaupp: it works
[14:21:59] *** Quits: roo (jesse@moz-9A53149A.ip.windstream.net) (Ping timeout)
[14:22:00] <nmatsakis> pnkfelix: certainly today we only have "Cells" at the level of the entire block (@mut)
[14:22:15] <dbaupp> rusti: let mut i = 0; while i < 3 { if i == 6 { return fail!(); } println(i.to_str()); i += 1; break }
[14:22:17] -rusti- more than 5 lines of output, pastebinned: http://sprunge.us/GXEB
[14:22:18] <nmatsakis> pnkfelix: but I think one of the problems with this system is that it is often coarser than you might like
[14:22:27] <dbaupp> rusti: let mut i = 0u; while i < 3 { if i == 6 { return fail!(); } println(i.to_str()); i += 1; break }
[14:22:28] -rusti- <anon>:7:90: 7:91 warning: value assigned to `i` is never read [-W dead-assignment (default)]
[14:22:29] -rusti- <anon>:7          let mut i = 0u; while i < 3 { if i == 6 { return fail!(); } println(i.to_str()); i += 1; break }
[14:22:29] -rusti-                                                                                                    ^
[14:22:29] -rusti- 0
[14:22:30] -rusti- ()
[14:23:34] <dbaupp> mark_edward: oh, `return x` where `x` isn't a "normal" expression seems to be unreliable
[14:24:05] <dbaupp> mark_edward: e.g. https://github.com/mozilla/rust/issues/6675
[14:24:08] <mark_edward> dbaupp: that's good to know! I can't thank you and cmr enough for the help in finding this problem!
[14:24:25] <dbaupp> mark_edward: but your's is probably different, so file a bug! :)
[14:24:40] <pnkfelix> nmatsakis: I don't know if the plan is for Cell to only expose mutation by offering as_mut()
[14:24:53] <mark_edward> dbaupp: i'm not sure how to reproduce it without all of my code...
[14:24:55] <pnkfelix> nmatsakis: but if it did have an alternative method for mutation, that operated without borrowing
[14:25:13] <dbaupp> mark_edward: well, try deleting all the bzip calls
[14:25:50] <pnkfelix> nmatsakis: that could be a place to put a more precise write barrier, to avoid the scan associated with as_mut().   Not sure if that's silly or not.
[14:26:25] <pnkfelix> nmatsakis: (maybe this sort of flexibility is an argument for moving from @mut to Cell.  Not sure.)
[14:26:26] <dbaupp> mark_edward: (filing it is better than not, even if you have to just put all your code into the bug...)
[14:26:27] <nmatsakis> pnkfelix: I could at least imagine a set() method
[14:26:31] * ChrisMorgan loves being able to just call `stream()` without needing to state the type, on account of later stuffing it into a suitable struct which determines what it must be
[14:26:44] <pnkfelix> nmatsakis: yeah, a `set(T)` method is basically what I was thinking.
[14:26:49] <mark_edward> dbaupp: okay, if i can't isolate, i'll do that
[14:26:55] <doomlord> when passing immutable struct values , could/does rust optimize that as passing references .. 
[14:27:49] <pnkfelix> nmatsakis: obviously using a `set()` method would have the drawback that one's imperative code would no longer be generic to any &T.  But this strikes me as a reasonable tradeoff that one would evaluate.
[14:27:52] <dbaupp> doomlord: if it is pass by value, then it can't
[14:27:54] <cmr> doomlord: there's no such thing as immutable when passing by value
[14:28:06] <pnkfelix> nmatsakis: and the choice would then be in the hands of the end-user.
[14:28:13] <dbaupp> doomlord: since it can be moved into a mutable variable (as the new function is the new owner)
[14:28:30] <ChrisMorgan> Is there any fmt! % value for types like u8? (%? works, but doesn't feel right, and `x as uint` and use `%u` doesn't either.)
[14:28:37] <pnkfelix> nmatsakis: where end-user == application developer.  (or at least the end libary developer, if not the application developer)
[14:28:45] <pnkfelix> nmatsakis: s/libary/library/
[14:28:50] <dbaupp> ChrisMorgan: not yet
[14:29:00] <toddaaro> bblum: I'm not sure what is up with the tests then, ask ecr about network ones I suppose
[14:29:12] *** Quits: Earnestly (earnest@2AB30F53.FB5005.2BCC804A.IP) (Ping timeout)
[14:29:18] <toddaaro> bblum: they might not be green because ecr is writing the udp interface, so previously they would have been "lol no udp impl"
[14:30:43] <nmatsakis> pnkfelix: you mean if you wrote the code to take a Cell<T> and invoked `set`?
[14:30:47] <dbaupp> mark_edward: at the very least, I'm sure only the compress method is relevant, and it's highly possible that the calls to BZ2_* aren't necessary to reproduce
[14:30:52] <pnkfelix> nmatsakis: exactly
[14:31:01] *** Joins: erickt (erickt@8C9ECD8F.3A598286.F12515B4.IP)
[14:31:20] <mark_edward> dbaupp: okay, thanks
[14:32:55] *** Quits: erickt (erickt@8C9ECD8F.3A598286.F12515B4.IP) (Ping timeout)
[14:33:32] <cmr> whoaaa
[14:33:32] <doomlord> passing explicit adresses "&whatever" much more often compared to  C++  references feels very different.. not saying its a bad thing though. i have nostalgia for C
[14:33:34] <cmr> http://static.rust-lang.org/doc/std/os.html#freeze-tmpbuf_sz
[14:33:36] <cmr> what the heck is that
[14:33:37] <jdm> what sort of facilities do we have for creating a vector with an initial number of identical elements?
[14:33:42] <jdm> ie. N empty strings
[14:33:52] <cmr> jdm: vec::from_elem
[14:34:08] <cmr> jdm: or vec::from_fn
[14:34:31] <cmr> Did statics used to be called freezes?
[14:34:35] <jdm> thanks
[14:34:37] *** Joins: ghrust (ghrust@F6EE6DE3.6A2AE50.F3114085.IP)
[14:34:37] <ghrust> 01[13rust01] 15bors merged 06auto into 06master: 02http://git.io/KVBK7w
[14:34:37] *** Parts: ghrust (ghrust@F6EE6DE3.6A2AE50.F3114085.IP) ()
[14:35:10] <SiegeLord> Rust used to have awesome names for everything
[14:35:39] <dbaupp> nmatsakis: https://github.com/mozilla/rust/issues/7713
[14:35:45] <cmr> SiegeLord: weird, you mean :p
[14:35:46] <pnkfelix> nmatsakis: I guess the hypothetical nightmare scenario is libraries that feel like they must be provide both `fn foo(&mut T)` and `fooViaSet(&Cell<T>)`, which might smell like code duplication.
[14:36:03] <dbaupp> ChrisMorgan: ^ that issue
[14:36:13] <dbaupp> ChrisMorgan: (I just filed it.)
[14:36:19] <nmatsakis> dbaupp: ok, I am still investigating
[14:36:41] <ChrisMorgan> dbaupp: well done :-)
[14:36:41] <pnkfelix> nmatsakis: but I'm personally okay with this, as long as most libraries decide to start with `fn foo(&mut T)` and not worry about the other option until it proves necessary.
[14:36:51] <dbaupp> nmatsakis: sure, I'm going to bed now and didn't want it to be forgotten :)
[14:37:08] <doomlord> enum/match is so elegant
[14:37:37] *** Joins: ghrust (ghrust@C8693FCB.6A2AE50.F3114085.IP)
[14:37:37] <ghrust> 01[13rust01] 15bors pushed 0 new commits to 06auto: 02http://git.io/Tg9Z0A
[14:37:37] *** Parts: ghrust (ghrust@C8693FCB.6A2AE50.F3114085.IP) ()
[14:37:40] *** Joins: ghrust (ghrust@24260B07.6A2AE50.F3114085.IP)
[14:37:40] <ghrust> 01[13rust01] 15bors pushed 4 new commits to 06auto: 02http://git.io/5wLKXQ
[14:37:40] <ghrust> 13rust/06auto 144f2ee0e 15Gavin Baker: Create man pages for rust tools
[14:37:40] <ghrust> 13rust/06auto 146143419 15Gavin Baker: Add new manpages to install script
[14:37:40] <ghrust> 13rust/06auto 1450600c3 15Gavin Baker: Updated rustpkg man page to match 0.7
[14:37:42] *** Parts: ghrust (ghrust@24260B07.6A2AE50.F3114085.IP) ()
[14:38:20] *** Joins: jorendorff (jorendorff@moz-1747FB68.hsd1.tn.comcast.net)
[14:38:21] *** Quits: infynyxx (infynyxx@moz-E95B370B.nyc.res.rr.com) (Client exited)
[14:38:30] <dbaupp> engla: I like the name RingBuf :)
[14:38:50] <engla> strcat said  "RingBuf" and "/me shrugs"
[14:38:53] <engla> but I like it too
[14:39:04] <engla> (I mean, strcat named it)
[14:39:13] <dbaupp> (strcat shrugs a lot :P )
[14:39:24] <nmatsakis> pnkfelix: yes. I suspect it will still be a perf footnote, but I guess it remains to be seen.
[14:39:35] <nmatsakis> pnkfelix: this depends a lot on how much we are able to push the use of ~ in place of @ etc
[14:39:52] <pnkfelix> nmatsakis: yes of course.  If you get rid of @ then a lot of this goes away
[14:40:06] <nmatsakis> pnkfelix: well not *get rid of*, but minimize use...
[14:40:10] <SiegeLord> The book about Rust: "Strcat Shrugged"
[14:40:12] <pnkfelix> nmatsakis: Right
[14:41:29] <dbaupp> SiegeLord: sequel "Imagine Never Hearing The Phrase 'Strcat Shrugged' Again"
[14:41:45] <dbaupp> with apologies to nmatsakis.
[14:42:32] <dbaupp> haha, https://news.ycombinator.com/item?id=6025700
[14:45:03] *** Joins: josh (josh@moz-348C4790.hsd1.mn.comcast.net)
[14:45:41] <doomlord> #[(forbid_non_camel_case_types)] ... enforcement of naming convention?
[14:45:49] <engla> yes
[14:46:04] <doomlord> nazi compiler .. :)
[14:46:07] <cmr> not as important now that non-camel-cased-types are handled correctly
[14:46:08] <engla> also ALLCAPS statics.. -.-
[14:46:33] <doomlord> is nice for code to be consistent i guess.
[14:46:53] <doomlord> i would hope that context-free gramar could allow text editors to chroma-code types
[14:46:54] *** Quits: Raynes (macro@moz-E5F01CE6.members.linode.com) (Ping timeout)
[14:47:24] <Ms2ger> It's better than having to write a separate tool to enforce naming conventions
[14:47:29] *** Quits: Eridius (kevin@moz-533B0DB4.us) (Ping timeout)
[14:47:32] * Ms2ger goes back to reviewing one of those for C++
[14:47:37] <ChrisMorgan> Etiquette in taking an E-easy issueâ€”to get started onâ€”would be to add a comment before fixing it and making a PR, I presume?
[14:47:45] *** Quits: olsonjeffery (pf@moz-9E9CF15C.members.linode.com) (Ping timeout)
[14:47:46] <cmr> ChrisMorgan: yes
[14:47:53] *** Quits: cantsin (cantsin@moz-F99612CC.members.linode.com) (Ping timeout)
[14:48:00] *** Joins: Raynes (macro@moz-E5F01CE6.members.linode.com)
[14:48:04] *** Quits: BigEndian (hurp@moz-1B6DD81E.members.linode.com) (Ping timeout)
[14:48:05] <dbaupp> engla: that is mostly on warn by default because it itercts badly with pattern matches
[14:48:07] *** Quits: balpert (balpert@moz-7E5ED302.members.linode.com) (Ping timeout)
[14:48:09] <dbaupp> *interacts
[14:48:36] *** Quits: shachaf (shachaf@moz-F37E0395.members.linode.com) (Ping timeout)
[14:48:40] <dbaupp> rusti: static a: uint = 1; /* hundreds of lines of code */ match (1,2) { (a,b) => a + b }
[14:48:41] -rusti- <anon>:7:61: 7:91 error: non-exhaustive patterns
[14:48:41] -rusti- <anon>:7          static a: uint = 1; /* hundreds of lines of code */ match (1,2) { (a,b) => a + b }
[14:48:41] -rusti-                                                                       ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
[14:48:41] -rusti- error: aborting due to previous error
[14:48:42] *** Joins: BigEndian (hurp@moz-1B6DD81E.members.linode.com)
[14:48:42] -rusti- application terminated with error code 101
[14:49:07] *** Joins: cantsin (cantsin@moz-F99612CC.members.linode.com)
[14:49:09] *** Quits: ziad (ziad@moz-5003F925.members.linode.com) (Ping timeout)
[14:49:38] <engla> dbaupp: aha ok. yeah that's an issue
[14:49:52] <dbaupp> engla: ^ (you could imagine it would be even worse with e.g. match (1,2) { (1, a) => ..., (a,b) => .. } and being very confused why the first case didn't execute, or worse, not noticing.)
[14:49:53] *** Quits: jld (jld@moz-B94C75AD.xlerb.net) (Ping timeout)
[14:49:53] *** Joins: hjr3 (hradtke@1A0AE795.28A5F6C3.A2D40ED2.IP)
[14:50:04] <engla> I've seen it tons of times, too lazy to name my statics properly when experimenting
[14:50:13] <engla> static x  etc 
[14:50:21] <dbaupp> rusti: static a: uint = 1; let a = 1; // this is fun
[14:50:21] -rusti- <anon>:7:33: 7:34 error: only refutable patterns allowed here
[14:50:22] -rusti- <anon>:7          static a: uint = 1; let a = 1; // this is fun
[14:50:22] -rusti-                                           ^
[14:50:22] -rusti- error: aborting due to previous error
[14:50:22] -rusti- application terminated with error code 101
[14:50:22] * engla is not very clever
[14:51:01] <cmr> ChrisMorgan: be careful to step around https://github.com/mozilla/rust/pull/7703
[14:51:01] *** Joins: Eridius (kevin@moz-533B0DB4.us)
[14:51:08] <cmr> sfackler: ^
[14:51:17] <doomlord> do rusters mind functionNames() as opposed to function_names()
[14:51:27] *** Joins: olsonjeffery (pf@moz-9E9CF15C.members.linode.com)
[14:51:28] *** Joins: balpert (balpert@moz-7E5ED302.members.linode.com)
[14:51:35] <doomlord> TypeNames   functionNames
[14:51:44] <engla> it's lowercase function names everywhere
[14:51:46] <cmr> doomlord: I don't personally care, but it's against the dominant style
[14:51:59] *** Joins: shachaf (shachaf@moz-F37E0395.members.linode.com)
[14:52:03] <dbaupp> doomlord: it's unconventional, but no-one will hunt you down. (I think. :P )
[14:52:07] <engla> .reserve_at_least()
[14:52:14] <SiegeLord> Never liked the camel style for anything... it looks assymetrical
[14:52:36] <engla> is there a better style for types?
[14:52:44] <bstrie> doomlord: I do mind! burn it with fire
[14:52:47] <ChrisMorgan> cmr: looks like it might be easiest to wait for it, or alternatively work on top of it
[14:52:57] <cmr> ChrisMorgan: working on top of it might be best
[14:53:05] <bstrie> doomlord: disregard dbaupp, I will hunt you down
[14:53:06] <doomlord> i'm in 2 minds about it.. it does look  odd adding emphasis to secondary parts of a name - but the flipside is, i find the underscores can be less instantly readable as 'parts of the same thing'
[14:53:09] <doomlord> lol
[14:53:34] * dbaupp should've know that bstrie would have opinions
[14:53:34] *** Joins: jld (jld@moz-B94C75AD.xlerb.net)
[14:53:39] <SiegeLord> It also puzzles me that Rust calls this CamelCase... I always considered this to be camelCase...
[14:53:40] <cmr> ChrisMorgan: or just slip it in before that gets tests/r+'d, and a. hope it doesn't conflict, b. ensure it conflicts and snicker at sfackler's plight
[14:53:44] <bstrie> dbaupp: that was your first mistake
[14:53:53] *** Quits: shachaf (shachaf@moz-F37E0395.members.linode.com) (Ping timeout)
[14:53:54] <doomlord> SiegeLord,  +1
[14:53:56] <ChrisMorgan> cmr: =-O
[14:54:02] <dbaupp> bstrie: surely my first mistake was #[bstrie]? :P
[14:54:05] <doomlord> PascalCase or something?
[14:54:37] <bstrie> SiegeLord: it's BactrianCamelCase vs dromedaryCamelCase
[14:54:39] <cmr> I thought it was StudlyCaps...
[14:54:43] <SiegeLord> XD
[14:54:46] <ChrisMorgan> cmr: I guess I should have tests for the benefit of #7311, using different values of "true". Lots of fun :D
[14:54:49] <bstrie> zoologists will understand the reference
[14:55:09] * dbaupp gets it
[14:55:13] <cmr> ChrisMorgan: please don't, that'd be awful
[14:55:31] <engla> I think CamelCase and dromedaryCase renders it well
[14:55:32] <ChrisMorgan> Awww... but how else will we know that it works?
[14:56:06] <cmr> 7311 should be ignored, it's a codegen bug
[14:56:33] <mark_edward> dbaupp: i filed the issue, but i don't know how useful it is https://github.com/mozilla/rust/issues/7714
[14:57:16] *** Joins: shachaf (shachaf@moz-F37E0395.members.linode.com)
[14:57:24] <dbaupp> mark_edward: more useful than it not being field.
[14:57:27] <dbaupp> *filed
[14:58:04] <dbaupp> engla: your dlist pr is very nice :)
[14:58:10] <engla> oh thanks
[14:58:28] <dbaupp> (r+ btw)
[14:58:54] *** Joins: cubic (cubic@moz-FE5AD6C7.mc.videotron.ca)
[14:59:24] <engla> great if this goes in
[14:59:42] <cmr> rusti: let x = std::os::args(); let y = x[0]; os::args()
[14:59:44] -rusti- more than 5 lines of output, pastebinned: http://sprunge.us/FJQa
[14:59:50] <cmr> rusti: let x = std::os::args(); let y = x[0]; std::os::args()
[14:59:52] -rusti- <anon>:7:38: 7:39 warning: unused variable: `y` [-W unused-variable (default)]
[14:59:52] -rusti- <anon>:7          let x = std::os::args(); let y = x[0]; std::os::args()
[14:59:52] -rusti-                                                ^
[14:59:52] -rusti- ~[~"./out"]
[14:59:59] *** Joins: pnathan (Adium@B9840254.2CD8A5F8.477B877D.IP)
[15:00:10] <cmr> rusti: let x = std::os::args(); let _ = x[0]; std::os::args()
[15:00:10] -rusti- ~[~"./out"]
[15:00:14] <engla> I'm one of those with light terminal background and I don't like the new warning/error colors.
[15:01:07] *** Joins: erickt (erickt@8C9ECD8F.3A598286.F12515B4.IP)
[15:01:45] <cmr> engla: Eridius is fixing it
[15:01:45] *** Joins: mr_pants (Mibbit@BBE7C46A.B4F11D08.8612FA94.IP)
[15:02:35] <engla> good
[15:03:40] *** Joins: pnathan1 (vlion@moz-BDC3EE62.tukw.qwest.net)
[15:03:47] <ChrisMorgan> cmr: so you reckon I should ignore #7311 and go for the banal `w0 == w1` instead of the ever-so-much-more-exciting `!w0 && w1 || w0 && !w1`?
[15:03:54] *** Quits: erickt (erickt@8C9ECD8F.3A598286.F12515B4.IP) (Ping timeout)
[15:03:56] <dbaupp> ChrisMorgan: yes
[15:04:02] <StarLight> i remember someone saying that go isn't used in google's project today. https://groups.google.com/forum/?fromgroups=#!topic/golang-nuts/BNUNbKSypE0
[15:04:10] *** Quits: olleharstedt (Thunderbir@moz-80D8890F.ias.bredband.telia.com) (Ping timeout)
[15:04:38] <ChrisMorgan> (Well, I meant w0 != w1, actually.)
[15:05:08] <dbaupp> ChrisMorgan: I don't think there's any part of the standard libraries that makes bad booleans
[15:05:12] <dbaupp> (well, I hope not)
[15:05:25] * ChrisMorgan is a pessimist there
[15:05:48] <cmr> terminfo might
[15:05:52] <cmr> I don't recall
[15:05:53] *** Quits: pnathan (Adium@B9840254.2CD8A5F8.477B877D.IP) (Ping timeout)
[15:06:32] <cmr> no, terminfo doesn't make bools, that'd be silly
[15:06:37] <cmr> it *accepts* bad bools
[15:07:04] <dbaupp> ChrisMorgan: in any case, your test case shouldn't be creating bools with `as`, and so you should be just testing the relevant feature.
[15:07:27] <ChrisMorgan> Very well, captain :-)
[15:09:23] <ChrisMorgan> cmr: looks like those Bitv clone/iter changes don't affect eq_vec
[15:09:36] <cmr> ChrisMorgan: they don't
[15:10:10] <nmatsakis> dbaupp: well, good news is that I think I found the bug, it's https://github.com/mozilla/rust/issues/5781
[15:10:24] <ChrisMorgan> So unless I was writing a bad patch which made more changes than it should, it should merge automatically.
[15:10:52] <dbaupp> nmatsakis: aha
[15:10:54] <nmatsakis> dbaupp: bad news is that fixing it the easy way causes a bit of pain, some extra lifetime annotations that shouldn't really be necessary, still figuring out precisely how much pain this is :)
[15:11:27] <dbaupp> heh, I see.
[15:11:27] <nmatsakis> the harder and proper way would be to fix https://github.com/mozilla/rust/issues/3598
[15:12:22] *** Quits: tiffany (kawaii@moz-1E0FE6E8.dhcp.embarqhsd.net) (No route to host)
[15:12:42] *** Joins: tiffany (kawaii@moz-1E0FE6E8.dhcp.embarqhsd.net)
[15:14:25] *** Joins: MaikKlein (maik@moz-7BAD3439.dip0.t-ipconnect.de)
[15:15:46] *** Quits: tiffany (kawaii@moz-1E0FE6E8.dhcp.embarqhsd.net) (Input/output error)
[15:15:52] *** Joins: tiffany (kawaii@moz-1E0FE6E8.dhcp.embarqhsd.net)
[15:16:55] <bjz> doomlord: https://github.com/mozilla/rust/wiki/Note-style-guide
[15:17:17] <bjz> doomlord: they are subject to change though
[15:17:54] <bjz> doomlord: for example, I do like `from_something` as a constructor syntax
[15:17:58] *** Joins: jensnockert (jensnocker@moz-C5F27039.cust.bredband2.com)
[15:19:48] <jdm> why does ast::Path contain a vector of types?
[15:20:04] <cmr> jdm: type parameterization
[15:20:10] <cmr> foo:bar::<a, b>()
[15:20:11] <jdm> oh, right
[15:20:20] <cmr> I puzzled over that myself
[15:20:29] <cmr> probably needs a comment..
[15:20:30] * jdm ponders the best way to determine if a Path corresponds to an enum variant
[15:21:05] *** Joins: roo (jesse@moz-9A53149A.ip.windstream.net)
[15:21:22] <Luqman> cmr: a lot of fields in syntax::ast could really use some sort of documentation :(
[15:21:46] <cmr> jdm: after resolve and/or typeck, it should be in the def_map
[15:21:57] <cmr> aiui...
[15:22:41] <jdm> ok, thanks
[15:23:44] <nmatsakis> jdm: def_map
[15:23:49] <nmatsakis> oh, cmr answered.
[15:24:36] <jdm> gah, def_map probably won't be populated yet :(
[15:24:51] <jdm> back to the typechecking/constant-resolution intertwining problem
[15:25:02] <jdm> s/resolution/evaluation/
[15:25:16] <nmatsakis> jdm: when are you executing?
[15:25:20] <nmatsakis> jdm: def_map is populated by resolve
[15:25:26] <jdm> nmatsakis: during typechecking
[15:25:29] <jdm> which comes first?
[15:25:32] <cmr> resolve
[15:25:32] <nmatsakis> jdm: resolve, you are fine.
[15:25:37] <jdm> woot
[15:26:40] <MaikKlein> rusti: let a = 5; do spawn { a;}
[15:26:41] -rusti- <anon>:7:31: 7:32 warning: path statement with no effect [-W path-statement (default)]
[15:26:41] -rusti- <anon>:7          let a = 5; do spawn { a;}
[15:26:42] -rusti-                                         ^
[15:26:42] -rusti- ()
[15:26:55] *** Quits: jensnockert (jensnocker@moz-C5F27039.cust.bredband2.com) (Input/output error)
[15:26:58] <SiegeLord> Oh wow... just upgraded rust and indeed the errors are hard to read...
[15:26:59] *** Joins: Jeaye (Jeaye@moz-FD505E54.hsd1.ca.comcast.net)
[15:27:10] <MaikKlein> is a now captured?
[15:27:22] <cmr> rusti: let a = 5; do spawn { a;} a
[15:27:23] -rusti- <anon>:7:31: 7:32 warning: path statement with no effect [-W path-statement (default)]
[15:27:23] -rusti- <anon>:7          let a = 5; do spawn { a;} a
[15:27:23] -rusti-                                         ^
[15:27:23] -rusti- 5
[15:27:24] <SiegeLord> And I get this: error: internal compiler error: couldn't enable multi-threaded LLVM XD
[15:27:35] <cmr> MaikKlein: implicitly copied perhaps?
[15:27:41] <cmr> rusti: let a = ~5; do spawn { a;} a
[15:27:42] -rusti- more than 5 lines of output, pastebinned: http://sprunge.us/ZjFE
[15:27:46] <MaikKlein> cmr, ah because its an int
[15:28:37] *** Joins: devinus (devinus@moz-B4AF84BC.ptr.us.xo.net)
[15:30:19] <jdm> what's the proper way to look up a def_id?
[15:31:32] <cmr> jdm: https://github.com/cmr/rustdoc_ng/blob/wip/clean.rs#L203 is what I do in rustdoc_ng... you just want dm.find(&id) I think
[15:31:51] <jdm> cmr: will that work for cross-crate?
[15:32:34] <cmr> jdm: it should? not sure
[15:33:38] <MaikKlein> rusti: struct Foo; let f = Foo; do spawn { f;}
[15:33:39] -rusti- <anon>:7:45: 7:46 warning: path statement with no effect [-W path-statement (default)]
[15:33:39] -rusti- <anon>:7          struct Foo; let f = Foo; do spawn { f;}
[15:33:39] -rusti-                                                       ^
[15:33:39] -rusti- ()
[15:33:43] <MaikKlein> rusti: struct Foo; let f = Foo; do spawn { f;} f
[15:33:44] -rusti- <anon>:7:45: 7:46 warning: path statement with no effect [-W path-statement (default)]
[15:33:44] -rusti- <anon>:7          struct Foo; let f = Foo; do spawn { f;} f
[15:33:44] -rusti-                                                       ^
[15:33:44] -rusti- {}
[15:34:11] <MaikKlein> can I move stack variables in a new task?
[15:34:17] <MaikKlein> or do they always have to be ~
[15:34:21] <MaikKlein> ?
[15:34:31] <jdm> cmr: hmm, I'm having trouble figuring out how to go from a def_id to an ast::item
[15:34:47] <cmr> jdm: ah, there's a different one for that I think
[15:34:53] <cmr> let me look
[15:35:01] <cmr> jdm: what are you working on btw?
[15:35:07] <bstrie> rusti: let a = 5; do spawn { error!(a); }
[15:35:09] -rusti- ()
[15:35:09] -rusti- rust: ~"5"
[15:35:19] <bstrie> MaikKlein: looks like you can
[15:35:23] <jdm> cmr: I'm trying to allow things like [0, .. C_ENUM_VARIANT as uint]
[15:35:33] <jdm> there are layers of problems I'm fixing :)
[15:35:36] <cmr> ah
[15:35:40] <Luqman> jdm: see lookup_const in middle::const_eval
[15:35:58] <jdm> Luqman: heh, I skipped over that because it didn't look useful from the name :)
[15:36:10] <jdm> I'm just adding code to the None branch in the caller
[15:36:53] <MaikKlein> rusti: struct Foo; let f = Foo; do spawn { let a = f;} f
[15:36:54] -rusti- <anon>:7:49: 7:50 warning: unused variable: `a` [-W unused-variable (default)]
[15:36:54] -rusti- <anon>:7          struct Foo; let f = Foo; do spawn { let a = f;} f
[15:36:54] -rusti-                                                           ^
[15:36:54] -rusti- {}
[15:37:18] <bjz> jdm: bleh C Enums :(
[15:37:36] <MaikKlein> does anyone know what this is trying to tell me ? "error: cannot move out of captured outer variable in a heap closure"
[15:38:11] <cmr> MaikKlein: you can't move into closures, because the closure can be called multiple times. there's 'once fn' for that... bblum would know more
[15:38:20] <MaikKlein> code looks like let b = BaseActor {...}; do spawn { b;}
[15:38:33] <bjz> cmr: has that been implemented yet?
[15:38:38] <cmr> bjz: yes
[15:38:42] <bjz> :O
[15:38:44] <cmr> -Z once-fns
[15:38:50] <engla> the alternative to once closures is a trait object, called by a method
[15:38:53] <bjz> oh ok
[15:39:03] <bjz> will wait for that then
[15:39:10] <bjz> but super coolios
[15:39:12] <dbaupp> cmr: to be specific, you can't move values moved into a closure, out of it
[15:40:09] <jdm> I wonder if enum variatns are item_ty
[15:42:02] <Luqman> jdm: wouldn't they be some variant in item_enum?
[15:42:23] *** Joins: posco (oscarboyki@636AC086.5999CED5.71743E61.IP)
[15:42:23] <MaikKlein> cmr, hm is there sth like do once spawn{}?
[15:42:30] <jdm> Luqman: so def_variant has a def_id for the enum and a def_id for the variant
[15:42:40] *** Quits: dbaupp (Thunderbir@moz-712A1135.lns20.syd6.internode.on.net) (Ping timeout)
[15:42:49] <cmr> MaikKlein: no idea
[15:42:49] <jdm> oh, maybe you're right
[15:42:57] *** Joins: infynyxx (infynyxx@DB780A29.749BA1D.DCC373F0.IP)
[15:43:42] <Luqman> jdm: ty::enum_variants will give you the variants for a given enum def_id
[15:43:50] <jdm> oho, thanks
[15:43:53] <MaikKlein> totally strange because I can't do let b = BaseActor {...}; do spawn { b;} but I can do let b = BaseActor {...}; do spawn { b.start();}
[15:44:23] *** Quits: pnathan1 (vlion@moz-BDC3EE62.tukw.qwest.net) (Ping timeout)
[15:44:28] *** Quits: pyrac (pyrac@moz-8862B13A.w92-162.abo.wanadoo.fr) (Quit: pyrac)
[15:45:02] <doomlord> (bjz, yeah i got into the habit of from_something already, in the absence of C++ constructors..)
[15:45:22] <doomlord> (except i tended to write fromSomething :) )
[15:47:46] <engla> MaikKlein: it's basically a known limitation, and it will possibly be resolved with closure changes
[15:48:24] <bstrie> doomlord: I thought C++ encouraged from_something
[15:48:30] <bstrie> fromSomething looks more like java
[15:49:01] <MaikKlein> engla, okay 
[15:49:10] *** Quits: doener (bs@moz-AA189A5A.unitymedia.biz) (Quit: leaving)
[15:49:17] <bjz> doomlord: you really should just let go and use underscores :P
[15:49:23] <doomlord> (what i mean is i found myself having to come up with a consistent name for constructors )
[15:51:04] <engla> do you need ::from_something? Maybe  Actor::from<T: ActorInit>(x: T) or ::new_from(x: T)  is a better pattern
[15:51:30] <engla> as in, us a trait to overload the conversion function
[15:52:21] <SiegeLord> Kind of awkward for multiple arguments
[15:52:22] <Eridius> cmr: ah, good to know. I have a TLS cache for the Terminal locally, just testing now
[15:52:30] <engla> yes
[15:52:37] <kimundi> RFC: All constructors must be three-glyph-lowwalikes of 'new()': T::new(), T::n3w(), T::Î¼ÎµÏ‰(), T::â„•âˆƒÎ¨()
[15:52:45] <bjz> x)
[15:53:15] <SiegeLord> Âµ is not a look-alike for n :P
[15:53:22] <mark_edward> kimundi: i approve of this RFC
[15:53:27] <SiegeLord> It's... upside down
[15:53:38] <engla> Âµ is m
[15:53:47] <mark_edward> i have the greek layout setup on my keyboard, and i need a reason to use it.
[15:53:58] <ChrisMorgan> RFC: all constructors must use Î½ rather than new
[15:54:04] <engla> better
[15:54:12] <bjz> kimundi: personally favour T::uÇÊ()
[15:54:19] <kimundi> xD
[15:54:40] *** Joins: eholk (eholk@moz-ACB08D8D.uconnect.utah.edu)
[15:54:40] <ChrisMorgan> (In case you didn't notice, mine is U+03BD GREEK SMALL LETTER NU.)
[15:54:55] <bjz> kimundi: or T::ÊÇu()?
[15:54:59] <Eridius> (â•¯Â°â–¡Â°ï¼‰â•¯ï¸µ ÊÇu::âŠ¥
[15:55:22] <doomlord> ouch :)  i did try using emacs pretty-mode to display greek characters for maths code.. but the source was written out as alpha theta etc.
[15:55:24] *** Quits: PeterSP (peter@moz-4DAF5777.bstnma.fios.verizon.net) (Ping timeout)
[15:55:25] <SiegeLord> Hah, so T::new is an upside-down cat?
[15:55:51] <jdm> ChrisMorgan: :D
[15:55:57] *** Quits: tiffany (kawaii@moz-1E0FE6E8.dhcp.embarqhsd.net) (Ping timeout)
[15:55:58] <ChrisMorgan> Or you could go for one like ð›Ž U+1D6CE MATHEMATICAL BOLD SMALL NU, probably more distinctive, though probably with worse support
[15:55:58] <doomlord> having lots more single letter variables :) (with some conventional meaning) was nice
[15:56:09] *** Joins: tiffany (kawaii@moz-1E0FE6E8.dhcp.embarqhsd.net)
[15:56:15] <doomlord> would fn as lambda make sense...
[15:56:46] <SiegeLord> That's like reverse trigraphs!
[15:56:55] <kimundi> let x = Î» x y. x + y
[15:57:01] <cmr> Except worse, because nobody can type them
[15:57:24] *** Quits: MaikKlein (maik@moz-7BAD3439.dip0.t-ipconnect.de) (Ping timeout)
[15:57:36] <ChrisMorgan> Alas, U+1D6CE will waste space too, being four bytes in UTF-8 rather than "new"'s three bytes. Maybe we'd better stick with the two byte U+03BD.
[15:58:23] <Ms2ger> kimundi, ugh, should be Î»x. Î»y. x + y
[15:58:23] <SiegeLord> Æ’ take(a : â„¤) â†’ â„¤
[15:58:44] <doomlord> : as that backwards e ?
[15:58:46] <SiegeLord> Actually, can that already be done?
[15:58:51] <SiegeLord> rusti: type â„¤ = int;
[15:58:52] -rusti- ()
[15:58:56] <SiegeLord> Teehee
[15:58:58] <doomlord> not backwards e sorry 
[15:59:11] <sp3d> time to evangelize to agda programmers :D
[15:59:15] *** Quits: tiffany (kawaii@moz-1E0FE6E8.dhcp.embarqhsd.net) (Connection reset by peer)
[15:59:22] *** Joins: tiffany (kawaii@moz-1E0FE6E8.dhcp.embarqhsd.net)
[16:00:15] <ChrisMorgan> Just figured out the ideal character, though I fear support is lacking: ðŸ‘· U+1F477 CONSTRUCTION WORKER
[16:00:31] <SiegeLord> rusti: let â‘ =1; â‘ 
[16:00:32] -rusti- <anon>:7:13: 7:13 error: unknown start of token: 9312
[16:00:32] -rusti- <anon>:7          let â‘ =1; â‘ 
[16:00:32] -rusti-                       ^
[16:00:32] -rusti- application terminated with error code 101
[16:00:37] <SiegeLord> Damn
[16:00:48] *** Joins: PeterSP (peter@moz-4DAF5777.bstnma.fios.verizon.net)
[16:01:22] <ChrisMorgan> Or ðŸš§ U+1F6A7 CONSTRUCTION SIGN
[16:01:44] <Ms2ger> That would be perfect for my geocities site
[16:02:05] <ChrisMorgan> ... of course, I couldn't recommend the first result in https://duckduckgo.com/?q=site%3Afileformat.info%2Finfo%2Funicode+new :-/
[16:02:31] *** Joins: erickt (erickt@8C9ECD8F.3A598286.F12515B4.IP)
[16:03:05] *** Joins: jclements (jclements@moz-BBE3ABD.mv.mozilla.com)
[16:03:21] *** Quits: tiffany (kawaii@moz-1E0FE6E8.dhcp.embarqhsd.net) (Ping timeout)
[16:03:23] *** Joins: tiffany (kawaii@moz-1E0FE6E8.dhcp.embarqhsd.net)
[16:04:30] *** Joins: jensnockert (jensnocker@moz-C5F27039.cust.bredband2.com)
[16:05:13] *** Quits: erickt (erickt@8C9ECD8F.3A598286.F12515B4.IP) (Ping timeout)
[16:05:16] <pnkfelix> nmatsakis: ping
[16:05:22] <kimundi> Hey, U+1F4A9 is the perfect symbol for annotating crappy apis
[16:06:25] <Eridius> ah the good old pile of poo
[16:06:27] *** Quits: tiffany (kawaii@moz-1E0FE6E8.dhcp.embarqhsd.net) (Connection reset by peer)
[16:06:34] *** Joins: tiffany (kawaii@moz-1E0FE6E8.dhcp.embarqhsd.net)
[16:06:34] <Eridius> ðŸ’©
[16:06:47] <Eridius> (which, sadly, doesn't render for me, I think mosh doesn't know about it)
[16:06:58] *** Joins: mib_vp1jhc (Mibbit@moz-7D83A5F1.ip.telfort.nl)
[16:07:10] <kimundi> That reminds me, do we have #[wip] yet? :P
[16:07:14] *** Quits: mib_vp1jhc (Mibbit@moz-7D83A5F1.ip.telfort.nl) (Quit: http://www.mibbit.com ajax IRC Client)
[16:07:45] *** Quits: rocode (rocode@moz-64C1010D.rocode.net) (Quit: Disconnected)
[16:07:53] <Eridius> #[cfg(never)]? Assuming you can add arbitrary config strings (can you?)
[16:08:02] <Eridius> or, heck, #[cfg(wip)]
[16:08:06] <bstrie> kimundi: right now #[wip] is applied to all rust code by default
[16:08:15] <Eridius> bstrie++
[16:08:17] <nmatsakis> pnkfelix: pong
[16:08:34] <cmr> Eridius: https://github.com/mozilla/rust/issues/723
[16:08:35] <pnkfelix> nmatsakis: PR review ettiquette
[16:08:38] <pnkfelix> nmatsakis: question
[16:08:48] <cmr> `
[16:08:50] <cmr> Per #6875 I want support for at least #[deprecated], #[experimental], #[unstable], #[stable], and maybe eventually #[frozen] and #[locked].
[16:09:08] *** Quits: maxli (maxli@F2D29657.F60B0462.67AC9B1.IP) (Quit: Leaving.)
[16:09:13] <pnkfelix> nmatsakis: I finished the review, and just had small suggestions that you can take or leave; they are not prerequisites for landing
[16:09:15] *** Joins: graydon (Adium@A5087023.2354C43D.D8E68FF6.IP)
[16:09:15] *** ChanServ sets mode: +qo graydon graydon
[16:09:19] <jdm> arrrgh
[16:09:25] <pnkfelix> nmatsakis: so, should I just r+  and let bors take the patch as is
[16:09:28] <nmatsakis> pnkfelix: ok in that case I tend to just write a comment on the PR to that effect,
[16:09:30] <jdm> I was an ast::variant_ now
[16:09:35] <Eridius> cmr: nice. though what would #[stable] be? Isn't stable the default state?
[16:09:38] <nmatsakis> pnkfelix: in which case I can add "r=pnkfelix"
[16:09:45] <cmr> Eridius: No, there is no default state.
[16:09:47] *** Joins: Earnestly (earnest@2AB30F53.FB5005.2BCC804A.IP)
[16:09:48] <kimundi> Was thinking more about "don't emitt warnings for this function", "replace some classes of compile errors with running code that calls fail!() instead", etc
[16:09:48] <pnkfelix> nmatsakis: under the assumption that if you feel like incorporating the suggestions, you will do so in a follow-up commit and add an addition r yourself?
[16:09:53] <cmr> Eridius: it's for annotating APIs
[16:10:00] <nmatsakis> pnkfelix: though if the author of the PR doesn't have commit rights, I would possibly mark r+ and ask for a followup
[16:10:04] <cmr> a la http://nodejs.org/api/documentation.html#documentation_stability_index
[16:10:08] <Eridius> cmr: so #[stable] is a stronger guarantee "this is unlikely to change anytime ever"?
[16:10:28] <nmatsakis> pnkfelix: I don't know that we have a firm policy, but that's what I do
[16:10:28] <Eridius> ah I see frozen and locked is part of this too. I didn't know what those were
[16:10:41] <pnkfelix> nmatsakis: Hmm.  I hadn't incorporated thinking about the previleges of the author
[16:10:45] *** Joins: pnathan (Adium@B9840254.2CD8A5F8.477B877D.IP)
[16:10:52] <pnkfelix> nmatsakis: I was more thinking that if the changes really could be applied after the fact
[16:11:00] <pnkfelix> nmatsakis:  then it is better to get the fix in sooner via bors
[16:11:27] *** Quits: jedestep (jedestep@34641662.FB4DE631.66C78B76.IP) (Ping timeout)
[16:11:27] <pnkfelix> nmatsakis: the main drawback is that maybe the changeset history is cleaner if I leave the push to you, or more generally, the PR author ?
[16:11:35] *** Joins: pyrac (pyrac@moz-8862B13A.w92-162.abo.wanadoo.fr)
[16:12:29] <nmatsakis> pnkfelix: yes, that's the main drawback, not very big. I guess it depends on the magnitude of the suggestions.
[16:13:51] <pnkfelix> nmatsakis: okay, I'll play it by ear in general.  (You can see yourself what I did in this case.)  I guess if you feel like racing bors that option is also open to you.
[16:13:58] *** Quits: mr_pants (Mibbit@BBE7C46A.B4F11D08.8612FA94.IP) (Quit: http://www.mibbit.com ajax IRC Client)
[16:14:12] *** Joins: MaikKlein (maik@moz-7BAD3439.dip0.t-ipconnect.de)
[16:14:12] <ChrisMorgan> "You've met with a terrible fate, haven't you?
[16:14:12] <ChrisMorgan> fatal runtime error: runtime tls key not initialized" :D
[16:14:23] <MaikKlein> how do I use once fn? fn once foo? or once fn foo?
[16:15:16] <Eridius> ChrisMorgan: hah. how'd that happen? Polymorphic function used as a key, or somesuch?
[16:15:25] *** Quits: posco (oscarboyki@636AC086.5999CED5.71743E61.IP) (Ping timeout)
[16:15:36] <ChrisMorgan> Eridius: std::rt::io::net::tcp, so I don't get any warranty whatsoever
[16:15:42] *** Joins: posco (oscarboyki@636AC086.5999CED5.71743E61.IP)
[16:16:09] <nmatsakis> pnkfelix: k
[16:16:12] *** Joins: brendan (brendaneic@moz-BBE3ABD.mv.mozilla.com)
[16:16:24] *** Quits: infynyxx (infynyxx@DB780A29.749BA1D.DCC373F0.IP) (Client exited)
[16:16:36] <Eridius> ChrisMorgan: oh dear me. Try triggering it again
[16:16:53] <ChrisMorgan> Sure. It's consistent.
[16:16:56] <Eridius> actually no that'll give the same message
[16:16:59] <roo> MaikKlein, i am pretty sure it is once fn, but I don't think it parses without a sigil. So ~once fn (my parser code is somewhere else, so this is a guess)
[16:17:09] <Eridius> std::rt::util::abort() hashes the message, and prints one of 6 different results
[16:17:22] <Eridius> with the "terrible fate" being the result for anything that hashes other than 0-5
[16:17:26] <Eridius> err 0-4
[16:17:49] <Eridius> sorry, hash is modded by 10. so half the time you get terrible fate, half the time you get another longer message, depending on what was trying to be used to abort
[16:18:04] *** Joins: carllerche (carllerche@6B070D22.7E6A0813.1428D117.IP)
[16:18:19] <ChrisMorgan> It happens inside rt::io::net::tcp::TcpListener::bind, in rt::local_ptr::unsafe_borrow_30966::_cde5b3ea7e291ef::_0$x2e8$x2dpre
[16:18:56] <ChrisMorgan> The build I had from a day ago didn't put out any error message, just abortedâ€”the build just now is much better behaved, sounding like it comes from an old text adventure.
[16:19:10] <roo> MaikKlein, and you also need to use the -Z once-fns debugging flag
[16:19:49] <cmr>  For getopts::groups, what should the hint be?
[16:19:56] <cmr> what is it even used for? :\
[16:23:03] *** Quits: noam (noam@F6B530A7.720527A7.416762B.IP) (Ping timeout)
[16:23:13] <MaikKlein> roo, thanks
[16:23:30] <MaikKlein> can I also do #[allow(once-fns)] or sth?
[16:23:47] *** Quits: devinus (devinus@moz-B4AF84BC.ptr.us.xo.net) (Quit: Computer has gone to sleep.)
[16:23:59] *** Quits: wilsonk-laptop (kvirc@moz-8E86F35A.cg.shawcable.net) (Quit: KVIrc 4.0.4 Insomnia http://www.kvirc.net/)
[16:24:11] *** Joins: noam (noam@F6B530A7.720527A7.416762B.IP)
[16:25:04] <olsonjeffery> i heard offhand mention that once fn's probably wouldn't come out from behind -Z in time for 1.0 .. may i inquire why? they seem really useful and there seemed to be concensus on their utility?
[16:25:10] <olsonjeffery> rough around the edgeness?
[16:25:22] <cmr> olsonjeffery: unimportant
[16:25:25] <cmr> backwards compatible
[16:25:35] <Eridius> what's -Z?
[16:25:44] <cmr> Eridius: "debug options"
[16:25:47] <cmr> rustc -Z help
[16:25:58] <Eridius> also, I want once fns now :/
[16:26:00] <sully> well, I think a bunch of people don't want them in the language
[16:26:05] <sully> which is why they are behind -Z
[16:26:06] <cmr> sully: who?
[16:26:22] <MaikKlein> hm
[16:26:24] <olsonjeffery> the influential Twice Fn Lobby
[16:26:28] <Eridius> methods like hashmap::mangle are unnecessarily awkward because of the lack of once fns
[16:26:31] <roo> XD
[16:26:35] <MaikKlein> I can't do once fn foo(){} :(
[16:26:49] <olsonjeffery> MaikKlein: it's for closures..
[16:27:27] <bjz> once fns would be great
[16:27:37] <MaikKlein> olsonjeffery, so? like do once spawn{} ?
[16:27:47] *** Joins: devinus (devinus@moz-B4AF84BC.ptr.us.xo.net)
[16:27:52] <roo> so like let x : ~once fn () = || { foo };
[16:27:58] <kmc> so 'once' is becoming a keyword?
[16:28:07] <cmr> kmc: already is and has been
[16:28:10] <kmc> oh
[16:28:33] *** Quits: robertknight (robertknig@moz-54528EE0.wby.mendeley.com) (Quit: Computer has gone to sleep.)
[16:29:05] *** Joins: azita (Azita@moz-BBE3ABD.mv.mozilla.com)
[16:29:17] <bstrie> is there a way to, er, sort an iterator?
[16:29:21] *** Joins: infynyxx (infynyxx@DB780A29.749BA1D.DCC373F0.IP)
[16:29:33] <bstrie> or a hashmap
[16:29:41] *** Quits: paulproteus (quassel@rose.makesad.us) (Ping timeout)
[16:29:54] *** Joins: paulproteus (quassel@moz-E86A3B42.makesad.us)
[16:30:09] <bstrie> via providing a custom fn
[16:30:26] <cmr> hashmaps don't have order :\
[16:30:38] <cmr> iterators don't really make sense to sort either
[16:30:38] *** Quits: donri (dag@moz-9BB61102.tbcn.telia.com) (Client exited)
[16:30:50] *** Quits: pnkfelix (pnkfelix@87C1F78E.1DE10CA8.D8E68FF6.IP) (Quit: Leaving.)
[16:30:57] <Eridius> how can I quickly check if my code will pass documentation-based lints?
[16:30:59] <bstrie> cmr: right, I want to pull a list out of it
[16:31:05] <MaikKlein> i am too retarded to use closures :(. Is it currently possible to do sth like this? Task1 sends "object1" to Task2. Task2 adds "object1" to a vector.
[16:31:13] <bstrie> cmr: basically I want a list of keys in the hashmap ordered by their values
[16:31:38] *** Joins: ghrust (ghrust@C621748.6A2AE50.F3114085.IP)
[16:31:38] <ghrust> 01[13rust01] 15bors merged 06auto into 06master: 02http://git.io/5wLKXQ
[16:31:38] *** Parts: ghrust (ghrust@C621748.6A2AE50.F3114085.IP) ()
[16:32:06] *** Joins: vk (chatzilla@3E9D68F2.B1163E0C.2A6693DD.IP)
[16:32:34] *** Joins: wilsonk-laptop (kvirc@moz-8E86F35A.cg.shawcable.net)
[16:32:36] *** Quits: victorporof (victorporo@58682299.183F338A.6A4F8DA2.IP) (Quit: victorporof)
[16:34:11] *** Joins: pnkfelix (pnkfelix@87C1F78E.1DE10CA8.D8E68FF6.IP)
[16:34:13] <bstrie> rusti: [1,2,3].sort()
[16:34:13] -rusti- <anon>:7:9: 8:5 error: type `[<VI2>, .. 3]` does not implement any method in scope named `sort`
[16:34:14] -rusti- <anon>:7          [1,2,3].sort()
[16:34:14] -rusti- <anon>:8     };
[16:34:14] -rusti- error: aborting due to previous error
[16:34:14] -rusti- application terminated with error code 101
[16:34:23] <bstrie> cmr: ok, how do I sort even a vector?
[16:34:35] <bstrie> rusti: [1,2,3].qsort()
[16:34:35] -rusti- <anon>:7:9: 8:5 error: type `[<VI2>, .. 3]` does not implement any method in scope named `qsort`
[16:34:36] -rusti- <anon>:7          [1,2,3].qsort()
[16:34:36] -rusti- <anon>:8     };
[16:34:36] -rusti- error: aborting due to previous error
[16:34:36] -rusti- application terminated with error code 101
[16:34:39] <cmr>  uhttp://static.rust-lang.org/doc/extra/sort.html aiui
[16:34:41] <graydon> #rust-triage if anyone wants to follow along
[16:34:42] *** Joins: ghrust (ghrust@DE823A67.6A2AE50.F3114085.IP)
[16:34:42] <ghrust> 01[13rust01] 15bors pushed 0 new commits to 06auto: 02http://git.io/rd6j9w
[16:34:42] *** Parts: ghrust (ghrust@DE823A67.6A2AE50.F3114085.IP) ()
[16:34:43] *** Joins: ghrust (ghrust@C621748.6A2AE50.F3114085.IP)
[16:34:44] <ghrust> 01[13rust01] 15bors pushed 2 new commits to 06auto: 02http://git.io/COLgkQ
[16:34:44] <ghrust> 13rust/06auto 143b8c5a1 15Niko Matsakis: Constrain maximum lifetime of stack closures that capture variables to...
[16:34:44] <ghrust> 13rust/06auto 14278ed50 15bors: auto merge of #7455 : nikomatsakis/rust/issue-7336-constrain-closure-lifetimes, r=pnkfelix...
[16:34:44] *** Parts: ghrust (ghrust@C621748.6A2AE50.F3114085.IP) ()
[16:34:52] <pnkfelix> triage mtg: #rust-triage
[16:35:23] *** Joins: tjc (tjc@moz-BBE3ABD.mv.mozilla.com)
[16:35:23] *** ChanServ sets mode: +o tjc
[16:35:23] <roo> rusti: std::cmp::sort([1,2,3,4])
[16:35:24] -rusti- <anon>:7:9: 7:23 error: unresolved name `std::cmp::sort`.
[16:35:24] -rusti- <anon>:7          std::cmp::sort([1,2,3,4])
[16:35:24] -rusti-                   ^~~~~~~~~~~~~~
[16:35:24] -rusti- error: aborting due to previous error
[16:35:24] -rusti- application terminated with error code 101
[16:35:27] <roo> :(
[16:35:31] <bstrie> rusti: use extra::sort::*; [1,2,3].qsort()
[16:35:32] -rusti- ()
[16:35:39] <roo> ah
[16:35:45] <bstrie> rusti: use extra::sort::*; let k = [3,2,1].qsort(); k
[16:35:46] -rusti- ()
[16:35:50] <bstrie> hmmm
[16:35:53] <cmr> ...lol
[16:36:07] <cmr> libextra, tempting us with its hidden brokenness!
[16:36:09] <jdm> fixing rustc bugs is so satisfying
[16:36:13] <bstrie> rusti: use extra::sort::*; let mut k = [3,2,1].qsort(); k
[16:36:14] -rusti- <anon>:7:37: 7:38 warning: variable does not need to be mutable [-W unused-mut (default)]
[16:36:14] -rusti- <anon>:7          use extra::sort::*; let mut k = [3,2,1].qsort(); k
[16:36:14] -rusti-                                               ^
[16:36:14] -rusti- ()
[16:36:15] <cmr> is it in-place?
[16:36:24] <StarLight> rusti: use extra::sort::*; let k = [3, 2, 1]; qsort(k); k
[16:36:25] -rusti- <anon>:7:48: 7:57 error: this function takes 4 parameters but 1 parameter was supplied
[16:36:25] -rusti- <anon>:7          use extra::sort::*; let k = [3, 2, 1]; qsort(k); k
[16:36:25] -rusti-                                                          ^~~~~~~~~
[16:36:25] -rusti- error: aborting due to previous error
[16:36:25] -rusti- application terminated with error code 101
[16:36:37] <Eridius> rusti: use extra::sort::*; let mut k = [3, 2, 1]; k.qsort(); k
[16:36:38] -rusti- [1, 2, 3]
[16:36:41] <cmr> rusti: use extra::sort::*; let k = [1, 3, 2]; k.qsort(); k
[16:36:42] -rusti- <anon>:7:48: 7:49 error: cannot borrow immutable vec content as mutable
[16:36:43] -rusti- <anon>:7          use extra::sort::*; let k = [1, 3, 2]; k.qsort(); k
[16:36:43] -rusti-                                                          ^
[16:36:43] -rusti- error: aborting due to previous error
[16:36:43] -rusti- application terminated with error code 101
[16:36:44] <Eridius> yes, qsort is an in-place sort
[16:36:56] *** Quits: devinus (devinus@moz-B4AF84BC.ptr.us.xo.net) (Quit: Computer has gone to sleep.)
[16:37:02] <bstrie> Eridius: ah, I'm so dumb
[16:37:04] *** Joins: maxli (maxli@F2D29657.F60B0462.67AC9B1.IP)
[16:37:10] <bstrie> sorting the rvalue in-place...
[16:37:23] <Eridius> quick_sort, quick_sort3, and tim_sort (all functions instead of methods) are also in-place. only merge_sort isn't
[16:37:24] <SiegeLord> You can do some kinds of sorting with iterators, I think
[16:37:33] *** Joins: Lilly (PinkLace@moz-145A6857.bredband.comhem.se)
[16:37:36] *** Joins: doener (doener@moz-121949B3.unitymediagroup.de)
[16:37:52] <cmr> SiegeLord: not the standard forward iterator?
[16:37:57] <cmr> at least not usefull
[16:38:00] <cmr> *usefully
[16:38:11] <Lilly> Hello!
[16:38:22] <cmr> hello Lilly
[16:38:27] <Lilly> I thought about something, and I figured I'd ask about it
[16:38:37] <Lilly> WHy can't you implement multiple traits in the same impl block?
[16:39:09] <Lilly> Like: impl Bar, Baz for Foo { ...
[16:39:12] <bstrie> Lilly: I think it's just to keep things organized
[16:39:19] <Lilly> I see
[16:39:38] <Lilly> Because I think it gets kinda messy when you have 30 impl blocks stacked on top of each other
[16:39:53] <Lilly> Also quite repetitive
[16:39:55] <bstrie> Lilly: you can use trait inheritance then! I think
[16:40:17] <Eridius> cmr: https://github.com/mozilla/rust/pull/7716
[16:40:30] <Lilly> Funny you say that, because I asked about that just last week :P
[16:40:32] <bstrie> trait Qux : Bar, Baz { } impl Qux for Foo { }
[16:40:32] *** Joins: jaen (jaen@moz-E0979827.copit.pl)
[16:40:41] <bstrie> Lilly: ^ that *might* work, I have no idea
[16:40:46] <Lilly> bstrie: I doesn't :/
[16:40:50] <bstrie> ah well
[16:41:07] <Lilly> You have to implement Bar and Baz separately, and then implement Qux
[16:41:27] <Lilly> Well if it did work, that would probably be a better solution than my idea
[16:42:03] <Lilly> I don't know if we ever got to know if it was a planned feature that wasn't implemented yet, or if that is the way it's supposed to be
[16:42:19] <bstrie> Lilly: trait inheritance is definitely a planned feature, but I'm not certain of the specifics
[16:42:37] <cmr> Lilly: I don't see anything that would *preclude* this feature, so
[16:42:44] <Lilly> cmr: cool :)
[16:43:15] <friggle> graydon: did you mean to mark https://github.com/mozilla/rust/issues/5853#issuecomment-20569280 as "just a bug"?
[16:44:11] <cmr> friggle: 
[16:44:13] <cmr> 12:41:12 graydon | cmr: "just a bug" is a command in my workspace that clears the I-nominated tag
[16:44:15] <cmr> 12:41:35 graydon | cmr: sorry, I know it's a feature, there, it just .. appends that text along the way to note that it was declined for milestone
[16:44:22] *** Quits: Blub\w (wry@7E3BB9D.71150E1A.237AE2BA.IP) (Quit: bbl)
[16:44:53] <friggle> cmr: how perfectly nonsensical, thanks :)
[16:45:01] <cmr> yup!
[16:45:05] *** Quits: pyrac (pyrac@moz-8862B13A.w92-162.abo.wanadoo.fr) (Quit: pyrac)
[16:46:01] *** Joins: MrFahrenheit (RageOfThou@3FEF494C.29C984D5.783DEDCA.IP)
[16:47:45] *** Joins: eschweic (Adium@moz-BBE3ABD.mv.mozilla.com)
[16:47:57] *** Quits: yong (chatzilla@74DA0C97.4E87ADC2.263D9828.IP) (Client exited)
[16:48:24] *** Joins: pcwalton (pcwalton@moz-BBE3ABD.mv.mozilla.com)
[16:48:24] *** ChanServ sets mode: +o pcwalton
[16:49:32] *** Joins: ziad (ziad@moz-5003F925.members.linode.com)
[16:49:36] <jdm> riddle me this
[16:49:53] <jdm> I have a trait method and I want to return a reference to another trait
[16:49:57] <jdm>     fn expr_ty_provider(&self) -> &ExprTyProvider;
[16:50:13] <Eridius> you want to return a borrowed pointer without giving it a lifetime?
[16:50:20] *** Quits: jaen (jaen@moz-E0979827.copit.pl) (Ping timeout)
[16:50:22] <jdm> probably not, I guess
[16:50:23] <Eridius> also, you want to return a trait object?
[16:50:27] <Eridius> you probably don't want that either
[16:50:35] <jdm> really?
[16:50:39] <Eridius> you probably want something like fn expr_ty_provider<T: ExprTyProvider>(&self) -> T
[16:50:49] <jdm> hmm
[16:50:51] *** Joins: nano (nano@moz-972880B.superkabel.de)
[16:50:59] <jdm> I do want a reference, not a bare type I think
[16:51:01] <Eridius> I mean I could be wrong, maybe you really do want a trait object
[16:51:22] <jdm> no, I believe you're correct now that I think about it
[16:51:38] <cmr> well you can still do that and return a &T
[16:52:01] <Eridius> if you're returning a field of self, it could be something like `fn expr_ty_provider<'a, T: ExprTyProvider>(&'a self,) -> &'a T
[16:52:06] <Eridius> but without the stray comma
[16:52:21] <jdm> aha, thanks
[16:52:26] <Eridius> or you could return T and let the implementation do the pointer and lifetime
[16:52:36] <jdm> ooh, I like the sound of that
[16:53:05] <Eridius> my rule of thumb is if you think you want to return a trait object, you probably don't want to return a trait object ;)
[16:53:06] *** Joins: pwalton (pcwalton@moz-7B0110AD.mv.mozilla.com)
[16:53:13] *** Joins: victorporof (victorporo@74A9C5E8.1745F5FA.9B1E38F4.IP)
[16:53:13] *** Joins: mschifer (Adium@moz-BBE3ABD.mv.mozilla.com)
[16:53:40] <jdm> ok, so I'm having trouble with the implementation that tries to return itself
[16:53:42] *** Joins: olleharstedt (Thunderbir@moz-80D8890F.ias.bredband.telia.com)
[16:53:52] <jdm> since it's implemented on a type that alspo implements ExprTyProvider
[16:53:57] *** Quits: pcwalton (pcwalton@moz-BBE3ABD.mv.mozilla.com) (Ping timeout)
[16:53:58] *** pwalton is now known as pcwalton
[16:54:29] <Eridius> jdm: if Self implements ExprTyProvider, but you return &Self, that's probably wrong
[16:54:31] *** Joins: dherman (dherman@moz-6CA476B1.hsd1.ca.comcast.net)
[16:54:31] *** ChanServ sets mode: +o dherman
[16:54:45] <Eridius> e.g. fn expr_ty_provider(&self) -> ExprTyProvider { self } // this is going to return &Self
[16:55:05] <jdm> right
[16:55:20] <jdm> right
[16:55:48] <jdm> sigh error: mismatched types: expected `T` but found `&middle::typeck::check::FnCtxt` (expected type parameter but found &-ptr)
[16:56:58] <jdm> perhaps I'm going about this the wrong way, and I just need more constraints elsewhere
[16:58:02] <cmr> Eridius: r-, see comments for fixes
[16:58:05] *** Quits: azita (Azita@moz-BBE3ABD.mv.mozilla.com) (Quit: azita)
[16:58:35] *** Joins: echristo (echristo@EECA91.D6CCE4AE.77834EAA.IP)
[16:59:01] *** Joins: jedestep (jedestep@34641662.FB4DE631.66C78B76.IP)
[17:00:45] *** Joins: azita (Azita@moz-BBE3ABD.mv.mozilla.com)
[17:01:22] *** Quits: bnicholson (bnicholson@moz-E98974C1.hsd1.ca.comcast.net) (Ping timeout)
[17:01:34] *** Joins: pnkfelix1 (pnkfelix@87C1F78E.1DE10CA8.D8E68FF6.IP)
[17:01:34] *** Quits: pnkfelix (pnkfelix@87C1F78E.1DE10CA8.D8E68FF6.IP) (Connection reset by peer)
[17:01:48] *** Quits: true_droid (Adium@moz-123FD9B8.beck.volia.net) (Quit: Leaving.)
[17:04:00] *** Joins: erickt (erickt@8C9ECD8F.3A598286.F12515B4.IP)
[17:04:06] *** Joins: pnkfelix (pnkfelix@87C1F78E.1DE10CA8.D8E68FF6.IP)
[17:04:10] *** Quits: pnkfelix1 (pnkfelix@87C1F78E.1DE10CA8.D8E68FF6.IP) (Connection reset by peer)
[17:05:11] *** Quits: lucian (lucian@6B2B4644.4304AE1E.CE5E78F6.IP) (Ping timeout)
[17:06:28] *** Joins: lucian (lucian@6B2B4644.4304AE1E.CE5E78F6.IP)
[17:06:32] *** Quits: SimonSapin (simon@88F51059.F3BBB17D.144F44FA.IP) (Quit: Leaving.)
[17:06:38] *** Quits: erickt (erickt@8C9ECD8F.3A598286.F12515B4.IP) (Ping timeout)
[17:06:51] *** Quits: huseby (huseby@moz-4E8C421A.husebyhome.com) (Quit: Leaving)
[17:06:59] *** Joins: huseby (huseby@moz-4E8C421A.husebyhome.com)
[17:08:05] *** Quits: pnkfelix (pnkfelix@87C1F78E.1DE10CA8.D8E68FF6.IP) (Quit: Leaving.)
[17:08:26] *** Quits: brendanc (brendan@moz-CA4BEC19.cs.ubc.ca) (Input/output error)
[17:10:13] *** Quits: brendan (brendaneic@moz-BBE3ABD.mv.mozilla.com) (Quit: brendan)
[17:11:52] *** Quits: jensnockert (jensnocker@moz-C5F27039.cust.bredband2.com) (Input/output error)
[17:13:55] *** Joins: brendan (brendaneic@moz-BBE3ABD.mv.mozilla.com)
[17:15:06] *** Joins: strcat (strcat@moz-54F7FD49.cpe.net.cable.rogers.com)
[17:15:13] *** Quits: lucian (lucian@6B2B4644.4304AE1E.CE5E78F6.IP) (Ping timeout)
[17:16:16] *** Quits: strcat (strcat@moz-54F7FD49.cpe.net.cable.rogers.com) (Quit: WeeChat 0.4.1)
[17:16:23] *** Quits: echristo (echristo@EECA91.D6CCE4AE.77834EAA.IP) (Quit: echristo)
[17:16:24] *** Quits: rusti (rusti@moz-54F7FD49.cpe.net.cable.rogers.com) (Client exited)
[17:16:33] *** Quits: bytbox (s@moz-DC83764A.washdc.fios.verizon.net) (Ping timeout)
[17:16:55] *** Joins: bnicholson (bnicholson@moz-BBE3ABD.mv.mozilla.com)
[17:17:29] *** Joins: strcat (strcat@moz-54F7FD49.cpe.net.cable.rogers.com)
[17:17:39] *** Joins: rusti (rusti@moz-54F7FD49.cpe.net.cable.rogers.com)
[17:18:20] *** Joins: echristo (echristo@EECA91.D6CCE4AE.77834EAA.IP)
[17:18:57] *** Joins: bnicholson_ (bnicholson@moz-BBE3ABD.mv.mozilla.com)
[17:18:59] *** Quits: bnicholson (bnicholson@moz-BBE3ABD.mv.mozilla.com) (Input/output error)
[17:18:59] *** Quits: bnicholson_ (bnicholson@moz-BBE3ABD.mv.mozilla.com) (Input/output error)
[17:19:08] *** Joins: bnicholson (bnicholson@moz-BBE3ABD.mv.mozilla.com)
[17:20:57] *** Joins: Sergio965 (sergiobz@moz-BB21156B.dynamic.csail.mit.edu)
[17:23:11] *** Quits: jedestep (jedestep@34641662.FB4DE631.66C78B76.IP) (Ping timeout)
[17:23:44] <MaikKlein> http://www.reddit.com/r/rust/comments/1i3c15/experimental_actor_library_in_rust/
[17:24:38] *** Joins: brendanc (brendan@moz-CA4BEC19.cs.ubc.ca)
[17:24:45] *** Joins: devinus (devinus@moz-B4AF84BC.ptr.us.xo.net)
[17:25:55] *** Quits: pcwalton (pcwalton@moz-7B0110AD.mv.mozilla.com) (Quit: pcwalton)
[17:28:26] <MaikKlein> is this proper english ? Criticism Is Welcomed?
[17:28:50] <jdm> yes, it is
[17:28:55] <jdm> or just welcome
[17:29:12] <MaikKlein> ok thanks
[17:29:38] <bblum> welcomed describes an action that is done to criticism
[17:29:57] <bblum> welcome describes the state of all criticism, whether it occurs or not
[17:30:08] <bstrie> eh, people are good at fuzzy logic, they'll understand :P
[17:30:21] *** Quits: CarpNet (ac@moz-FD24B77.sohonet.co.uk) (Quit: Leaving)
[17:30:25] <bblum> fuzzy logic is a thing that humans are pretty strong at.
[17:31:05] <bstrie> MaikKlein: I enjoyed your example
[17:31:39] *** Quits: pczarn (Mibbit@moz-69A55FA.izacom.pl) (Quit: http://www.mibbit.com ajax IRC Client)
[17:31:48] *** Joins: pnkfelix (pnkfelix@87C1F78E.1DE10CA8.D8E68FF6.IP)
[17:31:57] <MaikKlein> bstrie, you mean the monster example :D?
[17:32:08] <bstrie> MaikKlein: now you have to actually make a game where monsters are searching for flowers
[17:32:21] <MaikKlein> bstrie, ofc :D
[17:32:21] <cmr> Well, I think I've managed to get jellybean on my original motorolla droid, so I should be able to play with android now...
[17:32:26] *** Joins: pcwalton (pcwalton@moz-BBE3ABD.mv.mozilla.com)
[17:32:26] *** ChanServ sets mode: +o pcwalton
[17:33:31] <bblum> toddaaro: if ecr is there, can you relay this message to him
[17:33:37] *** Joins: azakai (alon@moz-BBE3ABD.mv.mozilla.com)
[17:33:45] *** Quits: azita (Azita@moz-BBE3ABD.mv.mozilla.com) (Quit: azita)
[17:33:49] <toddaaro> bblum: he is not yet, I'll ask him about this when he appears
[17:33:52] <bblum> toddaaro: ecr: the latest on brson/io appears to fail net::udp tests; are you aware of this?
[17:34:06] <bblum> oh, well, i am headed in presently
[17:34:10] <toddaaro> ah
[17:34:14] <bblum> could you confirm this too?
[17:34:16] <toddaaro> did you get my response in the backtrace?
[17:34:26] <bblum> oh, i didn't 
[17:34:27] <bblum> let me see
[17:34:40] <toddaaro> the tldr is that pre-ecr pull request there was no udp library
[17:34:46] <toddaaro> so I am not sure how udp tests would pass
[17:34:51] <toddaaro> but I'm not sure what the current state is
[17:35:01] <bblum> i see ok
[17:35:03] <toddaaro> the tldr is we should ask ecr
[17:35:08] <bblum> yes
[17:35:20] <bblum> well, i will be content with my local #[ignore] solution in the meantime
[17:35:25] *** Joins: SimonSapin (simon@88F51059.F3BBB17D.144F44FA.IP)
[17:36:32] *** Joins: cp (cp@moz-993078EE.plus.com)
[17:39:04] *** Quits: pnathan (Adium@B9840254.2CD8A5F8.477B877D.IP) (Quit: Leaving.)
[17:40:44] *** Joins: azita (Azita@moz-BBE3ABD.mv.mozilla.com)
[17:42:27] *** Quits: cp (cp@moz-993078EE.plus.com) (Quit: Lost terminal)
[17:42:53] <friggle> interesting comment on stack switching http://www.reddit.com/r/rust/comments/1hy6l9/meetingweekly20130709_split_stacks_ffi/cb0j7m5
[17:43:45] *** Joins: scanlonman (scanlonman@moz-169BC238.hsd1.wa.comcast.net)
[17:45:10] *** Quits: cr (anonymous@moz-76DBFB4D.dip0.t-ipconnect.de) (Ping timeout)
[17:46:06] *** dherman is now known as dherman-brb
[17:46:16] *** Joins: spider-mario (spidermari@4C9DC03E.363ACB84.F049C0AD.IP)
[17:49:56] *** Quits: MaikKlein (maik@moz-7BAD3439.dip0.t-ipconnect.de) (Ping timeout)
[17:49:59] *** Quits: brendan (brendaneic@moz-BBE3ABD.mv.mozilla.com) (Quit: brendan)
[17:52:47] *** Quits: scanlonman (scanlonman@moz-169BC238.hsd1.wa.comcast.net) (Quit: My MacBook has gone to sleep. ZZZzzzâ€¦)
[17:55:25] *** Joins: bytbox (s@moz-DC83764A.washdc.fios.verizon.net)
[17:56:51] *** Joins: brendan (brendaneic@moz-BBE3ABD.mv.mozilla.com)
[17:57:07] *** dherman-brb is now known as dherman
[17:58:46] *** Joins: jedestep (jedestep@34641662.FB4DE631.66C78B76.IP)
[18:00:29] *** Joins: vilonis (jared@moz-EE5D17ED.ph.ph.cox.net)
[18:00:41] *** Quits: jclements (jclements@moz-BBE3ABD.mv.mozilla.com) (Quit: jclements)
[18:01:10] *** Joins: eatkinson (eatkinson@moz-BBE3ABD.mv.mozilla.com)
[18:03:11] *** Joins: pnkfelix1 (pnkfelix@87C1F78E.1DE10CA8.D8E68FF6.IP)
[18:03:34] *** Quits: pnkfelix (pnkfelix@87C1F78E.1DE10CA8.D8E68FF6.IP) (Ping timeout)
[18:03:41] *** pnkfelix1 is now known as pnkfelix
[18:04:47] *** Joins: jgilbert (jgilbert@moz-7B0110AD.mv.mozilla.com)
[18:05:22] *** Joins: erickt (erickt@8C9ECD8F.3A598286.F12515B4.IP)
[18:05:32] *** Quits: vk (chatzilla@3E9D68F2.B1163E0C.2A6693DD.IP) (Ping timeout)
[18:06:00] <cmr> Hm, that's probably a bug
[18:06:35] <cmr> When doing like -L . -L ., it reports multiple matching crates, even though they're the exact same crate
[18:07:45] <graydon> friggle: we already do that
[18:07:49] <graydon> it's just the crossing time
[18:08:07] *** Quits: erickt (erickt@8C9ECD8F.3A598286.F12515B4.IP) (Ping timeout)
[18:08:08] *** Quits: noam (noam@F6B530A7.720527A7.416762B.IP) (Connection reset by peer)
[18:08:40] *** Quits: Yurume (yurume@AC58A8CE.8A059B47.E313B915.IP) (Ping timeout)
[18:08:46] *** Joins: jclements (jclements@moz-BBE3ABD.mv.mozilla.com)
[18:08:51] *** Joins: noam (noam@F6B530A7.720527A7.416762B.IP)
[18:09:05] *** Joins: ski (md9slj@moz-3A3D085A.studat.chalmers.se)
[18:09:29] *** Quits: SimonSapin (simon@88F51059.F3BBB17D.144F44FA.IP) (Ping timeout)
[18:09:59] *** Quits: posco (oscarboyki@636AC086.5999CED5.71743E61.IP) (Quit: posco)
[18:11:18] *** Quits: yichoi (yichoi@5AB4884B.FCC4549.14D5B978.IP) (Ping timeout)
[18:11:40] <cmr> This is so weird :\ https://gist.github.com/cmr/e396e61f936dd36dd5ba
[18:11:56] <cmr> it's there, it's just... weird
[18:13:28] *** Quits: pcwalton (pcwalton@moz-BBE3ABD.mv.mozilla.com) (Quit: pcwalton)
[18:14:13] *** Joins: pcwalton (pcwalton@moz-BBE3ABD.mv.mozilla.com)
[18:14:13] *** ChanServ sets mode: +o pcwalton
[18:14:13] <cmr> the weirdest part is that it *will* resolve std::prelude in the current crate, but not external ones
[18:14:14] *** Joins: Blub\w (wry@7E3BB9D.71150E1A.237AE2BA.IP)
[18:16:03] *** Joins: yichoi (yichoi@5AB4884B.FCC4549.14D5B978.IP)
[18:16:04] *** Quits: pnkfelix (pnkfelix@87C1F78E.1DE10CA8.D8E68FF6.IP) (Quit: Leaving.)
[18:16:24] <cmr> pcwalton: do I have to do something special to get proper resolution for external crates (from metadata::creader::read_crates I guess)? rustdoc_ng is failing to resolve all exports in external crates.
[18:16:32] *** Quits: sankha93 (Instantbir@BDB5E925.8ACFB64A.EFB84E89.IP) (Ping timeout)
[18:17:17] <pcwalton> hmm, I'm not sure off the top of my head.
[18:18:14] <cmr> I've been trying to pick apart what I do different than rustc, but I don't see any obvious differences besides me using a mostly-unchanged session::options (defaults from basic_options())
[18:18:34] <doener> cmr: maybe a recursive use foo::* somewhere? IIRC that can cause such failures
[18:18:56] <cmr> doener: it's failing to resolve std::prelude::*
[18:19:25] *** Joins: posco (oscarboyki@636AC086.5999CED5.71743E61.IP)
[18:19:46] <doener> cmr: it failed to resolve "random" stuff when I had such a recursion
[18:20:21] *** Joins: pczarn (bzlandfill@moz-69A55FA.izacom.pl)
[18:20:42] *** Joins: scanlonman (scanlonman@moz-169BC238.hsd1.wa.comcast.net)
[18:20:56] <cmr> doener: https://gist.github.com/cmr/e396e61f936dd36dd5ba is my stripped-down testcase
[18:21:37] *** Joins: ecr (Thunderbir@moz-BBE3ABD.mv.mozilla.com)
[18:21:39] <doener> ok
[18:24:07] *** Quits: infynyxx (infynyxx@DB780A29.749BA1D.DCC373F0.IP) (Client exited)
[18:24:41] *** Joins: infynyxx (infynyxx@DB780A29.749BA1D.DCC373F0.IP)
[18:25:41] <tjc> graydon: ping
[18:25:46] <graydon> tjc: pong
[18:25:59] <tjc> graydon: bors seems to get interrupted when running tests for https://github.com/mozilla/rust/pull/7681
[18:26:19] <cmr> similarly for one of niko's prs
[18:26:30] <pcwalton> nmatsakis: graydon: sent a GC proposal to the mailing list
[18:26:37] <pcwalton> I'm pretty happy with it assuming it works :)
[18:26:42] <cmr> https://github.com/mozilla/rust/pull/7688
[18:26:50] <tjc> (brb)
[18:27:21] <graydon> tjc: checking
[18:28:27] *** Quits: pczarn (bzlandfill@moz-69A55FA.izacom.pl) (Quit: CGI:IRC (EOF))
[18:28:38] *** Joins: ghrust (ghrust@614D05BD.6A2AE50.F3114085.IP)
[18:28:39] <ghrust> 01[13rust01] 15bors merged 06auto into 06master: 02http://git.io/COLgkQ
[18:28:39] *** Parts: ghrust (ghrust@614D05BD.6A2AE50.F3114085.IP) ()
[18:28:43] <jdm> there are so many edge cases when dealing with constants and enums and array lengths :(
[18:29:05] <graydon> tjc: there was actually a failure there, http://buildbot.rust-lang.org/builders/auto-linux-32-opt/builds/368
[18:29:13] <graydon> for some reason bors didn't post it. lemme check the logic on that.
[18:29:25] <graydon> jdm: I know, it's kinda amazing :((
[18:29:34] <cmr> there was no failure that I could see on https://github.com/mozilla/rust/pull/7688
[18:29:45] <cmr> unless bors isn't reporting all the builds
[18:30:17] *** Quits: noam (noam@F6B530A7.720527A7.416762B.IP) (Ping timeout)
[18:30:36] *** Joins: noam (noam@F6B530A7.720527A7.416762B.IP)
[18:30:43] <graydon> cmr: yeah, it seems like it's not :(
[18:30:48] <graydon> logic error, again. my problem.
[18:30:57] <brendanc> cmr: that one failed with http://buildbot.rust-lang.org/builders/auto-linux-64-nopt/builds/374
[18:31:10] <cmr> nmatsakis: http://buildbot.rust-lang.org/builders/auto-linux-64-nopt/builds/374/steps/compile/logs/stdio
[18:31:12] <graydon> found it
[18:31:14] <graydon> sorry
[18:31:19] <graydon> another bloody typo
[18:31:21] <graydon> THANK YOU PYTHON
[18:31:28] <cmr> rewrite him in rust!
[18:31:39] <graydon> maybe dynamic languages are super cool for people who never fat-finger the keyboard or something?
[18:31:42] *** Joins: ghrust (ghrust@E7A4CCE2.6A2AE50.F3114085.IP)
[18:31:42] <ghrust> 01[13rust01] 15bors pushed 0 new commits to 06auto: 02http://git.io/Wokpmw
[18:31:42] *** Parts: ghrust (ghrust@E7A4CCE2.6A2AE50.F3114085.IP) ()
[18:31:43] *** Joins: ghrust (ghrust@5FEF1C87.6A2AE50.F3114085.IP)
[18:31:44] <ghrust> 01[13rust01] 15bors pushed 13 new commits to 06auto: 02http://git.io/cEzsIg
[18:31:44] <ghrust> 13rust/06auto 14824bb44 15blake2-ppc: dlist: A new implementation of an owned doubly-linked list...
[18:31:44] <ghrust> 13rust/06auto 14f97e640 15blake2-ppc: dlist: Implement size_hint properly for all iterators
[18:31:44] <ghrust> 13rust/06auto 147b1c577 15blake2-ppc: dlist: Introduce a struct Rawlink mimicing Option<T> for a raw pointer...
[18:31:46] *** Parts: ghrust (ghrust@5FEF1C87.6A2AE50.F3114085.IP) ()
[18:31:47] <graydon> this stuff .. feedback time is hours-to-days!
[18:31:49] <brendanc> pylint + flymake is a big help
[18:32:21] <graydon> well, hm, in this case I think only a very fancy warning would have helped
[18:32:25] <graydon> rustc would have caught it
[18:32:33] <graydon> "mutable variable doesn't need to be declared mutable"
[18:32:42] <graydon> (this has saved me several times already)
[18:32:51] <graydon> because if you declared it mut, you probably meant to mutate it, right?
[18:32:56] <graydon> not assign to that _other_ variable :)
[18:33:09] <brendanc> not sure what the error is, but maybe that's when pylint tells you you haven't used a variable you've set?
[18:33:14] <bstrie> I'm very happy with all of rust's lint warnings
[18:33:28] <graydon> this one got used, just never mutated after its initializer
[18:33:39] <graydon> there was a loop that was supposed to populate it
[18:33:45] <graydon> loop populated a different variable
[18:33:56] <graydon> (not technically a typo, but a copy-paste error)
[18:34:00] <brendanc> ah
[18:34:27] <brendanc> pylint + flymake is still very helpful :)
[18:34:28] <graydon> I'm hard on python, it's not fair
[18:34:35] <graydon> I should turn that on
[18:34:37] <pcwalton> graydon: I thought you were a lisper :)
[18:34:45] <graydon> long long ago
[18:35:23] <graydon> went to ML for the algebraic datatypes, stayed for the ... algebraic datatypes
[18:35:27] *** Joins: Vert (quassel@8A83479C.391ACC8C.CAF63861.IP)
[18:35:47] <brendanc> this also makes me laugh: http://www.mypy-lang.org/
[18:35:51] <nmatsakis> cmr: how did you ... find it? oh, it was a bors bug?
[18:35:54] <brendanc> can't decide whether or not it's a troll
[18:36:08] <graydon> nmatsakis: it was a bors bug. just fixed.
[18:36:15] <nmatsakis> graydon: is there a way to get bors to not list the canceled runs?
[18:36:20] <graydon> sure
[18:36:28] <graydon> I figured you might want them in case someone hit the STOP button
[18:36:36] <graydon> so I classified them and listed the classification
[18:36:39] <graydon> rather than omitting any
[18:36:46] <graydon> (except those omitted by accident due to this bug)
[18:36:53] <nmatsakis> graydon: that's even better
[18:37:47] <graydon> I should always watch bors carefully any time I make an enhancement someone asks for :
[18:37:49] <graydon> :)
[18:37:58] <graydon> seems like there's always 2-3 days of fallout
[18:39:07] <cmr> and please never touch bors on a friday :p
[18:39:14] <bstrie> every time someone asks graydon to enhance bors, he gets so stressed that he just plays apocalyptic sandbox games for three days
[18:39:20] *** Quits: carllerche (carllerche@6B070D22.7E6A0813.1428D117.IP) (Quit: carllerche)
[18:39:24] *** Joins: carllerche (carllerche@6B070D22.7E6A0813.1428D117.IP)
[18:41:01] *** Quits: yichoi (yichoi@5AB4884B.FCC4549.14D5B978.IP) (Ping timeout)
[18:41:16] <Vert> So if I want to get involved should I just read the wiki, pick an `E-easy` tagged bug and fix it?
[18:41:33] *** Joins: yichoi (yichoi@5AB4884B.FCC4549.14D5B978.IP)
[18:41:36] <cmr> Vert: there's https://github.com/mozilla/rust/wiki/Note-guide-for-new-contributors too, which is basically a summary of that
[18:41:46] <graydon> Vert: a pretty good start, yeah. though "easy" is .. pretty subjective
[18:41:51] <graydon> find something you _like_, best of all
[18:41:52] <bstrie> Vert: first you should climb the nearest mountain and sit at its peak for three days and nights and reflect on the nature of life and the universe.
[18:42:17] <Lilly> best advice I've heard in a long time :D
[18:42:30] <Vert> I wonder if I can get that google now thing to tell me the nearest mountain... :p
[18:42:46] <bstrie> Vert: if it's smart enough for that, maybe it's also smart enough to file patches
[18:42:53] <bstrie> has anyone... tried?
[18:43:15] <cmr> bstrie: writing the patch is the hard part!
[18:43:40] <bstrie> cmr: I disagree, I think climbing the mountain and surviving without food and water for three days would be harder
[18:43:49] <bstrie> but then again, I've seen some of these bugs. maybe I'd take the mountain
[18:43:51] *** Joins: Voomer (Voomer@moz-E97E8EB7.br.br.cox.net)
[18:44:06] <cmr> (I mean writing the patch is the hard part of filing a patch)
[18:44:16] <tjc> The book _Getting What You Came For_, about applying to grad school, talks about how all you learn from climbing a mountain is how to climb a mountain
[18:44:29] <tjc> saying, basically, that the way to think of a research topic is to do research, not to go to the top of a mountain and meditate ;-)
[18:45:43] *** Joins: tedh (tedh@moz-F0B37C08.hsd1.il.comcast.net)
[18:46:54] <Vert> Well, anyone got any suggestions for good bugs to begin with?
[18:47:11] <cmr> Vert: https://github.com/mozilla/rust/issues/7718 hot off the press
[18:47:26] * strcat could file another 10 about things needing iterators ;p
[18:47:48] <strcat> and some forward+reverse iterators can be replaced by a single double-ended one soon
[18:47:56] <tjc> Vert: one thing that's not too hard is finding test cases that have been marked "expected to fail" and seeing if they work now
[18:48:08] <tjc> Vert: https://github.com/mozilla/rust/issues/3965 explains that a little more
[18:48:13] <cmr> (incredibly boring though)
[18:48:17] <cmr> (*cough*)
[18:48:57] <strcat> extra::stats can probably be ported to iterators too
[18:49:19] <cmr> graydon: I added an E-needstest label for bugs that need test cases; should this perhaps be B-reproduce?
[18:50:08] *** Joins: tikue (tkuehn@moz-BBE3ABD.mv.mozilla.com)
[18:51:29] *** Quits: victorporof (victorporo@74A9C5E8.1745F5FA.9B1E38F4.IP) (Quit: victorporof)
[18:51:32] *** Joins: pnathan (Adium@B9840254.2CD8A5F8.477B877D.IP)
[18:51:40] <tjc> cmr: I'd call that B-reproduce, yeah
[18:52:06] *** Quits: mschifer (Adium@moz-BBE3ABD.mv.mozilla.com) (Ping timeout)
[18:52:36] <cmr> The reason I thought it wouldn't be is that it's more for issues that need something in the test suite rather than just a way to reproduce them (sometimes that already exists)
[18:52:51] *** Joins: slaren (x@moz-5047427A.red-95-120-32.dynamicip.rima-tde.net)
[18:52:58] *** Joins: mschifer (Adium@moz-BBE3ABD.mv.mozilla.com)
[18:53:26] <cmr> hm that could be A-testsuite I suppose
[18:53:44] <tjc> cmr: so you're thinking of more likeâ€¦ someone submitted 1000 lines of code that shows the bug and it would be good to minimize it?
[18:54:10] * strcat is somewhat confused about how the current deque iterator can possibly compile
[18:54:19] <strcat> the mutable one
[18:54:22] <cmr> tjc: I made it for things like https://github.com/mozilla/rust/issues/5926. It was once wrong, it now works, but it should have a testcase to prevent regressions
[18:54:39] <cmr> but that's a good usecase too
[18:54:43] <strcat> nmatsakis: ping
[18:55:02] <tjc> cmr: ah, yeah. that seems reasoanble
[18:55:34] <pcwalton> what is the noncopyable attribute now?
[18:55:39] * pcwalton is updating the docs
[18:55:42] <strcat> pcwalton: it's a struct in util
[18:55:48] <strcat> unit struct
[18:55:51] <bblum> util::NonCopyable
[18:55:55] <bblum> we should have #[no_copy] though
[18:55:58] <strcat> but unit struct constructors don't resolve so you can't use it outside of libstd
[18:56:00] <strcat> :[
[18:56:05] <bblum> strcat: what argh :P
[18:56:07] <pcwalton> oh right, dtor
[18:56:21] *** Quits: infynyxx (infynyxx@DB780A29.749BA1D.DCC373F0.IP) (Client exited)
[18:56:30] <strcat> they're never public, although the type itself is
[18:56:37] <strcat> maybe an easy to fix bug
[18:57:42] *** Quits: pnathan (Adium@B9840254.2CD8A5F8.477B877D.IP) (Ping timeout)
[18:57:44] <strcat> afaict the deque iterator has an internal &'self mut [T] and is returning &'self mut T
[18:57:54] <strcat> so it's safe but.... I can't see how the compiler could know that
[18:57:54] *** Joins: jgilbert_ (jgilbert@moz-7B0110AD.mv.mozilla.com)
[18:58:02] *** Quits: jgilbert (jgilbert@moz-7B0110AD.mv.mozilla.com) (Ping timeout)
[18:58:03] <strcat> so I think it's allowing overlapping &mut borrows
[18:58:08] * strcat will investigate that soon
[18:58:09] *** Joins: pnathan (Adium@B9840254.2CD8A5F8.477B877D.IP)
[18:58:24] <pcwalton> yikes, unary move is still in the docs
[18:58:26] * pcwalton removes
[18:58:53] *** Joins: btipling (btipling@moz-D51E0AEB.xen.prgmr.com)
[18:59:33] <engla> strcat: be prepared to find it under extra::ringbuf
[18:59:45] *** Quits: jgilbert_ (jgilbert@moz-7B0110AD.mv.mozilla.com) (Max SendQ exceeded)
[18:59:46] <engla> no iterators have changed though
[19:00:37] *** Quits: Sorella (queen@78575561.924F2739.95C8B7C6.IP) (Ping timeout)
[19:01:05] *** Quits: btipling (btipling@moz-D51E0AEB.xen.prgmr.com) (Quit: ZNC - http://znc.sourceforge.net)
[19:01:58] *** Joins: btipling (btipling@moz-D51E0AEB.xen.prgmr.com)
[19:02:41] *** Joins: MaikKlein (maik@moz-7BAD3439.dip0.t-ipconnect.de)
[19:02:42] *** Joins: yong (chatzilla@74DA0C97.4E87ADC2.263D9828.IP)
[19:03:34] <bblum> wow, vim scrolling with the scroll wheel is atrociously slow with a vsplit open
[19:03:44] <engla> strcat: maybe deque could use the new split_mut method for slices. all it needs to do is to iterate two slices after all
[19:03:49] *** Joins: Sorella (queen@78575561.924F2739.95C8B7C6.IP)
[19:04:16] <strcat> bblum: use gvim, it's much faster ;p
[19:04:21] <graydon> cmr or someone: r? https://github.com/mozilla/rust/pull/7623
[19:04:24] <graydon> (updated)
[19:04:27] *** Quits: echristo (echristo@EECA91.D6CCE4AE.77834EAA.IP) (Quit: echristo)
[19:04:45] *** Quits: BizarreCake (BizarreCak@moz-361FE9B2.dynamic.barak-online.net) (Ping timeout)
[19:05:01] *** Joins: infynyxx (infynyxx@DB780A29.749BA1D.DCC373F0.IP)
[19:05:06] <sully> ok, I think static default methods working.
[19:05:12] <bstrie> bblum: using vim with a mouse??
[19:05:13] <sully> crosscrate, generic, crosscrate+generic.
[19:05:17] <pcwalton> just as I get all the tests working for de-copy
[19:05:18] <pcwalton> and de-Copy
[19:05:22] <pcwalton> now to rebase
[19:05:29] <strcat> sully: you fixed that other AST map issue too, right? I think that's all we need to use them all over
[19:05:34] <strcat> hopefully.
[19:05:44] * strcat thinks the lint flag should be removed
[19:06:14] <kimundi> Hm, would it be possible with Bidirectional Iterators to support a generic vector-like patter matching syntax?
[19:06:16] <Jeaye> sully: That's awesome. :)
[19:06:27] <strcat> kimundi: maybe
[19:06:38] * strcat shrugs
[19:06:40] <strcat> it'd be weird though
[19:06:41] *** Quits: MaikKlein (maik@moz-7BAD3439.dip0.t-ipconnect.de) (Ping timeout)
[19:06:48] *** Joins: erickt (erickt@8C9ECD8F.3A598286.F12515B4.IP)
[19:06:48] <strcat> because the "rest" would be another iterator
[19:07:04] <kimundi> Weirede than the current rest being a &[]?
[19:07:14] <strcat> I don't think it's integrated into the language enough to have pattern matching syntax
[19:07:22] <strcat> kimundi: weirder, yeah, because it means the pattern iterated it
[19:07:43] <strcat> and that could essentially do anything
[19:07:49] <strcat> patterns with side effects just seems odd
[19:08:00] <kimundi> hm, true... Unless theb pattern just creates the iterator as a temporary, working on an Iterable
[19:08:20] <strcat> kimundi: iterators can have side effects
[19:08:25] <strcat> they're fn calls
[19:08:34] <pcwalton>  359 files changed, 3650 insertions(+), 3369 deletions(-)
[19:08:43] <kimundi> Well, should they have sideffects?
[19:08:49] <strcat> kimundi: sure
[19:08:59] <strcat> if you want
[19:09:01] <pcwalton> passed the 7,000 line mark :)
[19:09:20] <strcat> you can iterate over input from a socket, etc.
[19:09:27] *** Quits: erickt (erickt@8C9ECD8F.3A598286.F12515B4.IP) (Ping timeout)
[19:10:46] <strcat> kimundi: part of my evil plan to convert pretty much every vec method to default methods on the iterable types
[19:11:06] <kimundi> Still, I think it could be usefull... I mean why harcode a special syntax for one kind of container if it is possible to support any container?
[19:11:34] <strcat> because it's not possible to support any container without saying patterns can have side effects
[19:11:42] <strcat> if we're okay with saying that...
[19:11:47] <strcat> still need a syntax for it
[19:12:06] <strcat> also we're missing gc'ed slices
[19:12:15] <strcat> for @[]
[19:12:48] *** Quits: hjr3 (hradtke@1A0AE795.28A5F6C3.A2D40ED2.IP) (Ping timeout)
[19:12:49] * strcat wonders if it'd be safe
[19:13:13] <kimundi> match "bluh bluh bluh etc etc etc".word_iter() { [[first, second, middle_range.., last]] => { ... }      }
[19:13:26] <strcat> I guess you'd just have to make sure the freezing was dealt with across all of them for @mut
[19:13:29] *** Quits: pnathan (Adium@B9840254.2CD8A5F8.477B877D.IP) (Quit: Leaving.)
[19:14:09] <strcat> kimundi: how can it know to match that pattern though?
[19:14:13] <engla> kimundi: what happens if you pick off different numbers of elements in each branch? you can't put those elements back into the `last` iterator
[19:14:20] <strcat> an iterator doesn't know how long it is
[19:14:41] <strcat> some do, but it's not exposed beyond size_hint
[19:14:45] *** Joins: true_droid (Adium@moz-123FD9B8.beck.volia.net)
[19:16:42] <cmr> graydon: no test for the metrics/ratchet?
[19:16:43] *** Joins: hjr3 (hradtke@1A0AE795.28A5F6C3.A2D40ED2.IP)
[19:16:50] <glinscott> json parsing of example.json string 100 times from 25.5s originally, down to 0.45s now after a few perf patches :)
[19:17:06] *** Quits: acrichto (acrichto@moz-B63D64BD.res.cmu.edu) (Connection reset by peer)
[19:17:11] <bstrie> glinscott: great scott
[19:17:16] <bstrie> that's quite a speedup
[19:17:33] *** Quits: bblum (bblum@moz-2B41ACB5.andrew.cmu.edu) (Ping timeout)
[19:17:51] *** Quits: rpearl (rpearl@moz-2B41ACB5.andrew.cmu.edu) (Ping timeout)
[19:17:51] *** Quits: mjrosenb (mjrosenb@moz-B3592BDA.club.cc.cmu.edu) (Ping timeout)
[19:17:51] *** Quits: rntz (rntz@moz-C76A8D96.sp.cs.cmu.edu) (Ping timeout)
[19:17:56] <kimundi> Okay, I kinda overlooked that that patter needs to be refutable. :P But if it's just an irrefutable one that only binds variables: Start with a BidirectionalIterator, pop the necessarry number of elements from front/back, reuse the remaining range.
[19:18:06] *** Joins: robertknight (robertknig@moz-54528EE0.wby.mendeley.com)
[19:18:29] <glinscott> bstrie: yes, most of the easy wins have been had i think.  push_char is slow now, but speeding it up is tricky while strs are still null terminated
[19:18:30] <strcat> kimundi: you don't know how many there are though
[19:18:32] <strcat> it's not irrefutable
[19:18:37] <strcat> [a, ..rest]
[19:18:43] <strcat> you can't know an iterator has 1 element to yield
[19:18:47] <strcat> statically
[19:19:04] <strcat> and you can only find out it has one element to yield by iterating it, and then it's gone
[19:19:20] <cmr> glinscott: wasn't it like ~1.2s this morning?
[19:19:23] *** Joins: victorporof (victorporo@74A9C5E8.1745F5FA.9B1E38F4.IP)
[19:19:26] <kimundi> WEll yeah, it either works or fails, but it can't guarantee success nor refute it beforehand.... So yeah, crappy idea from my side :P
[19:19:51] *** Joins: MaikKlein (maik@moz-7BAD3439.dip0.t-ipconnect.de)
[19:20:03] <kimundi> Could it work with a RandomAccessIterator?
[19:20:28] <bstrie> glinscott: you could add a datapoint to https://github.com/mozilla/rust/issues/7235
[19:20:46] <glinscott> cmr: yes - the 25.5s was from before the initial json perf patch.  the combination of 7696 and 7704 gets it from 1.2s down to 0.45s
[19:20:54] <cmr> awesome :)
[19:22:06] <pcwalton> I do think that buffering should not be in the json library and should be in io
[19:22:09] <strcat> kimundi: don't know
[19:22:14] <pcwalton> rt/io really
[19:22:34] <pcwalton> also tglek was claiming that the json perf was a regression after the first patch
[19:22:39] <cmr> graydon: oh, could also lend a hand with https://github.com/mozilla/rust/pull/7687 ? It spits out `make: *** No rule to make target `/home/cmr/hacking/rust/src/test/bench/std/std.rs)', needed by `tmp/check-stage1-T-x86_64-unknown-linux-gnu-H-x86_64-unknown-linux-gnu-bench.ok'.  Stop`. I tried navigating the makefile but couldn't really decipher it
[19:22:40] <pcwalton> but he may have been using the wrong version of rust
[19:23:33] <glinscott> pcwalton: yes, i moved the json parser to use Iterator<char> instead of doing buffering itself.  For now, the @io::Reader version just does read_whole_stream, and passes that into the parse
[19:23:38] <pcwalton> oh, cool
[19:23:51] <glinscott> pcwalton: which first patch btw?
[19:23:56] <pcwalton> the first one that you landed
[19:24:02] <pcwalton> I'm not sure the number off the top of my head
[19:24:06] <strcat> pcwalton: can you rm the r+ here for now https://github.com/mozilla/rust/pull/7679 ? it has a failing test atm
[19:24:12] <pcwalton> I suspect he was using the wrong version
[19:24:13] <pcwalton> of rust
[19:24:13] *** Quits: doener (doener@moz-121949B3.unitymediagroup.de) (Quit: leaving)
[19:24:17] <strcat> I was going to land it with my rollup PR but it failed
[19:24:41] <pcwalton> strcat: done
[19:24:48] <kimundi> rusti: let r = "bluh bluh bluh etc etc etc".word_iter(); match r.collect::<~[&str]>() { [a, b, c, d.., e] => { println(fmt!("%?", (a,b,c,d,e))) } _ => ()     }
[19:24:51] -rusti- line longer than 150 columns, pastebinned: http://sprunge.us/FiCe
[19:24:57] <pcwalton> did rope get deleted?
[19:25:02] <kimundi> rusti: let r = "bluh bluh bluh etc etc etc".word_iter(); match r.collect::<~[&str]>() { [a, b, c, d.. e] => { println(fmt!("%?", (a,b,c,d,e))) } _ => ()     }
[19:25:03] <glinscott> pcwalton: yeah, i can't see how the first one would have been a perf. regression
[19:25:03] <tjc> pcwalton; yes
[19:25:04] -rusti- more than 5 lines of output, pastebinned: http://sprunge.us/fEWM
[19:25:11] *** Quits: infynyxx (infynyxx@DB780A29.749BA1D.DCC373F0.IP) (Client exited)
[19:25:36] <pcwalton> how is it compared to rapidjson?
[19:25:56] * strcat thinks we need a streaming json parser that the high-level ADT one is built on
[19:26:07] <strcat> we don't have a way to deal with massive files
[19:26:32] <strcat> although maybe those are still usually xml :)
[19:26:45] <glinscott> pcwalton: getting closer!  still about 5x slower
[19:26:50] <pcwalton> hmm, 5x :(
[19:26:55] <pcwalton> but maybe that's io being bad
[19:26:58] <strcat> better than 50x
[19:27:01] <strcat> or whatever it was before
[19:27:03] <strcat> ;p
[19:27:09] <pcwalton> implementing newsched uv file i/o should help
[19:27:31] <glinscott> strcat/pcwalton: that is on string parsing, so no i/o issues.  push_char is up there on the profile now
[19:27:32] <strcat> on the positive side we iterate as fast as C++, and the adaptors are all as fast as the boost range ones ;p
[19:27:36] <pcwalton> oh, ok
[19:27:42] <pcwalton> strcat: cool
[19:27:46] <pcwalton> how is treemap?
[19:27:50] <pcwalton> now that ~ headers are gone
[19:27:59] <strcat> pcwalton: it's closer but still slow
[19:27:59] <Jeaye> pcwalton: rapidjson is pretty poorly designed. libjson works pretty well, and would be a good lib to compare againts (though I'm not much of a fan of it either).
[19:28:05] <pcwalton> strcat: why slow?
[19:28:10] <pcwalton> drop flag?
[19:28:11] <strcat> pcwalton: recursion overhead + ffi overhead
[19:28:18] <pcwalton> blah
[19:28:24] * pcwalton wants to land niko's stuff
[19:28:27] <strcat> the move zeroing hurts but it's not the main reason
[19:28:34] <MaikKlein> can rust expand tail recursion?
[19:28:36] <cmr> strcat: it was 250x before :p
[19:28:37] <Jeaye> libjson dropped 10s from our load times due to its lazy parsing.
[19:29:12] * strcat likes http://zserge.bitbucket.org/jsmn.html ;p
[19:29:31] * Jeaye shoudl really work on https://github.com/Jeaye/JeayeSON
[19:29:39] <strcat> it just gives you pointers to the start/end of things and you do what you want with them
[19:30:06] <glinscott> strcat: a streaming json parser is definitely interesting, seems like a less common use case though
[19:30:15] *** Quits: Sorella (queen@78575561.924F2739.95C8B7C6.IP) (Ping timeout)
[19:30:22] <strcat> glinscott: yeah, less common
[19:30:33] <strcat> but people do need streaming xml parsers all the time, and I expect there *are* big json files
[19:30:42] <strcat> wikipedia could start dumping json instead of xml :)
[19:31:07] <Lilly> one thing I was thinking about
[19:31:17] <Lilly> How heavily does std and extra use @?
[19:31:26] <cmr> Lilly: not much
[19:31:34] <Lilly> because that's one complaint I hear about D all the time
[19:31:50] <strcat> Lilly: iterators/slices/containers don't
[19:32:20] <doomlord> d: you can't opt out of gc so easily? can it still opt out?
[19:32:29] <strcat> Hash{Map,Set}, Tree{Map,Set}, Trie{Map,Set}, Deque, PriorityQueue are all owned
[19:32:39] <pcwalton> TLS and IO are the main offenders
[19:32:44] <pcwalton> there is a patch for getting rid of the TLS one
[19:32:48] <pcwalton> and IO has rt/io
[19:32:49] <Lilly> I guess those are most important ones, strcat
[19:32:49] <cmr> Lilly: in std, almost not at all outside of io (which is old, crappy code) and TLS (which requires @), and various impls for @T
[19:32:51] <pcwalton> but it has no disk io yet :(
[19:33:09] <Lilly> Sorry, but what's TLS?
[19:33:13] <cmr> task local storage
[19:33:14] <Lilly> (i'm a newbie=
[19:33:16] <pcwalton> no disk io is the biggest problem with newsched IMHO
[19:33:52] <Jeaye> Getting rid of the TLS one would break so much of my code, I bet. 
[19:33:57] <cmr> Lilly: libextra isn't so bad though
[19:34:21] <pcwalton> in D, is de-GC-ing the standard library also making it unsafe?
[19:34:28] <Lilly> imo, @ should never be used unless necessary
[19:34:28] <cmr> pcwalton: yes
[19:34:39] *** Joins: Sorella (queen@78575561.924F2739.95C8B7C6.IP)
[19:35:01] <doomlord> oh is that the key difference between D and Rust... D can't do safe , non GC code ?
[19:35:11] <doomlord> D just has raw pointers and GC ?
[19:35:37] <bstrie> Lilly: we also hate @
[19:35:40] <bstrie> join us
[19:35:41] <doomlord> D has just *unsafe* raw pointers and GC ?
[19:35:41] <pcwalton> doomlord: yeah
[19:35:47] <Lilly> bstrie: :D
[19:35:54] <pcwalton> I mean you can probably make smart pointers in D too but they won't be safe like Rust's
[19:35:57] *** Quits: hjr3 (hradtke@1A0AE795.28A5F6C3.A2D40ED2.IP) (Ping timeout)
[19:35:58] <pcwalton> because of iterator invalidation and such
[19:36:03] <jdm> Jeaye: that's a great repo name
[19:36:14] <Jeaye> jdm: :D Thanks.
[19:36:19] <Lilly> I need to wrap my head around the different pointers though. I'm a kinda new programmer
[19:36:30] <pcwalton> Lilly: my advice is to ignore @
[19:36:36] <Lilly> Yeah
[19:36:39] <bstrie> pcwalton: I've come around to liking the idea of renaming @T to Gc<T>, the current notation really is too nice for something we don't want people to use by default
[19:36:40] <pcwalton> you won't need it for most programs
[19:36:47] <strcat> doomlord: they can do safe value semantics but not safe reference semantics or slices/iterators without gc
[19:36:48] *** Joins: vk (chatzilla@3E9D68F2.B1163E0C.2A6693DD.IP)
[19:36:49] <cmr> Also ignore ~ except ~str ;)
[19:36:50] <Lilly> I want to do game development in rust, in which case I'd never use @
[19:36:53] *** Quits: devinus (devinus@moz-B4AF84BC.ptr.us.xo.net) (Quit: Computer has gone to sleep.)
[19:36:54] <cmr> (and ~[])
[19:37:04] <Jeaye> Lilly: It's not sooo bad. ;)
[19:37:07] <pcwalton> well yeah, use the stack first, then use ~ as "new" when you want to put something on the heap
[19:37:18] <Lilly> & is the hardest one to understand :c
[19:37:24] <cmr> Lilly: & is the important one!
[19:37:27] <Lilly> The lifetimes thing makes me dizzy x)
[19:37:31] <strcat> ideally you'll rarely use anything but stack allocation and borrowed pointers outside of containers
[19:37:52] <pcwalton> Lilly: you don't need to know lifetimes unless you are (a) returning an & pointer or (b) putting an & pointer in a data structure
[19:37:53] <Lilly> cmr: Yeah, I figured :P
[19:38:04] <pcwalton> for many programs you don't have to do either
[19:38:42] <Lilly> But let's say I'm programming a resource manager, holding a vector of pointers to resources in memory
[19:38:59] <Lilly> what kind of pointers?
[19:39:18] <cmr> Depends... probably storing ~ and handing out &'self
[19:39:25] <pcwalton> Lilly: should the resource manager be freeing the resources?
[19:39:29] <pcwalton> that's the question you want to ask
[19:39:29] <doomlord> sometime you have to turn a problem on its head to get a safe solution
[19:39:30] <Lilly> Yeah
[19:39:33] *** Joins: hjr3 (hradtke@1A0AE795.28A5F6C3.A2D40ED2.IP)
[19:39:37] <pcwalton> if the answer is yes, then use ~
[19:39:39] *** Joins: bblum (bblum@moz-2B41ACB5.andrew.cmu.edu)
[19:40:19] <Lilly> How does one drop something pointed to by a ~ pointer?
[19:40:31] <Lilly> (~ is annoying as hell to do on a Swedish keyboard haha)
[19:40:53] <cmr> Lilly: let _ = foo; (ie, "move it into the void")
[19:41:00] <kimundi> IT drops automatically as soon as the ~ goes out of scope
[19:41:22] *** Joins: int3_ (int3_@moz-ABE52D50.hsd1.ca.comcast.net)
[19:41:37] <Lilly> but when does a resource go out of scope? I have a hard time... grasping that. :P
[19:41:49] *** Joins: echristo (echristo@EECA91.D6CCE4AE.77834EAA.IP)
[19:41:50] <slaren> make tidy fails on my system (windows) on licenseck.py, apparently due to a issue with line endings
[19:41:58] <slaren> in turn this makes make checks fail too
[19:42:05] <strcat> Lilly: when the variable goes out of scope
[19:42:16] <strcat> variables and @ are the top-level owners
[19:42:26] <strcat> when an owner goes out of scope, it calls the destructors on everything it owns
[19:42:28] *** Joins: rntz (rntz@moz-C76A8D96.sp.cs.cmu.edu)
[19:42:41] *** Joins: rpearl (rpearl@moz-2B41ACB5.andrew.cmu.edu)
[19:42:41] <strcat> if you have struct Foo { x: File, y: ~[int] }
[19:42:50] <strcat> and you have a variable holding Foo go out of scope
[19:42:53] <kimundi> let x = ~5; {let y = ~6; /*y goes out of scope here at the end*/} /*x goes out of scope here at the end*/
[19:42:58] <Lilly> So if I emptied the vector, the resources pointed to by the pointers inside it would get cleaned up automatically?
[19:42:58] <strcat> the file is closed and the vector memory freed
[19:43:09] <slaren> should i open an issue about that ?
[19:43:25] <Lilly> it
[19:43:26] *** Joins: mjrosenb (mjrosenb@moz-B3592BDA.club.cc.cmu.edu)
[19:43:27] <mark_edward> is there a non--blocking way to recv from a port?
[19:43:31] <Jeaye> Lilly: Do you have a game idea already?
[19:43:33] <strcat> Lilly: well in that example there aren't resources to free in the vector
[19:43:40] <Jeaye> I get excited when people start making games with Rust.
[19:43:41] *** Joins: pnathan (Adium@B9840254.2CD8A5F8.477B877D.IP)
[19:43:42] <strcat> if you had ~[File] and you cleared it, yes - they get closed immediately
[19:43:48] <Lilly> it's so hard to think about scope when talking about a kinda persistent vector of stuff :P
[19:43:55] <Lilly> Jeaye: not really :P
[19:43:59] <strcat> Lilly: persistent data structures aren't owned
[19:44:02] *** Quits: eschweic (Adium@moz-BBE3ABD.mv.mozilla.com) (Quit: Leaving.)
[19:44:11] <strcat> they'd use @ or Rc
[19:44:14] <Jeaye> Lilly: Well, keep us updated if you start something. :)
[19:44:21] <Lilly> Jeaye: sure will! :)
[19:44:21] <doomlord> Jeaye , i would like to do a retro remake of  thrust, called 'thRust'. or just make "thRust engine" :)
[19:44:37] <doomlord> (please dont take my name :) )
[19:44:46] <strcat> Lilly: with @, the destructors for everything the @-ptr owns are just called when it's gc'ed
[19:44:56] *** Joins: devinus (devinus@moz-B4AF84BC.ptr.us.xo.net)
[19:44:57] <strcat> for Rc, they're called when the *last* Rc for that box goes out of scope
[19:44:59] <Lilly> I don't like GC :P
[19:45:14] <Jeaye> doomlord: Ohh, I haven't seen anyone working on a platformer like that in Rust yet. That'd be neat!
[19:45:21] <olsonjeffery> has anyone done a 3d physics engine in rust, yet?
[19:45:23] <strcat> Rc just has a destructor doing refcount -= 1
[19:45:28] <strcat> and when it's 0, it destroys it
[19:45:28] *** Joins: cr (anonymous@moz-95C31EA7.dip0.t-ipconnect.de)
[19:45:31] <Jeaye> olsonjeffery: Nope.
[19:45:34] <cmr> olsonjeffery: MaikKlein expressed interest in bullet bindings
[19:45:36] <Lilly> I know it's OK for games on desktop, depending on what you are doing
[19:45:38] *** Quits: echristo (echristo@EECA91.D6CCE4AE.77834EAA.IP) (Quit: echristo)
[19:45:57] <doomlord> i was just going to say bullet bindings would be hugely beneficial to the community, but isn't bullet C++?
[19:46:05] <Jeaye> doomlord: Yup
[19:46:08] <Lilly> But I've only heard horror stories about GC on Android
[19:46:20] <doomlord> i haven't worked with bullet so can't comment how hard a C wrapper would be
[19:46:29] <Jeaye> Lilly: Well, Java...
[19:46:33] <cmr> doomlord: it has a C api, though it's not complete afaik
[19:47:09] <strcat> Jeaye: you can't really blame java for that
[19:47:10] <Jeaye> My plan is to just implement my own basic physics system when it comes time.
[19:47:11] <strcat> java has better garbage collectors than rust will ever be able to have
[19:47:31] <Ms2ger> Oh?
[19:47:34] <Lilly> Basically, I like making singleton resource managers, that load and unload resources
[19:47:41] <Jeaye> strcat: I'm not blamaing Java at all. I was getting at the point that Android Gc can't be _that_ bad if it primarily runs Java.
[19:47:49] <strcat> ah
[19:47:56] <strcat> Jeaye: well, a variant of java with their own VM
[19:48:01] <Ms2ger> strcat, would love to hear you expand on that :)
[19:48:11] <strcat> Ms2ger: sure, rust has unmanaged pointers
[19:48:16] *** Joins: infynyxx (infynyxx@DB780A29.749BA1D.DCC373F0.IP)
[19:48:17] <strcat> it can't use a fully moving gc
[19:48:17] <olsonjeffery> yeah. just curious if someone had something faily simple to model 3d spaces in rust
[19:48:19] *** Joins: echristo (echristo@EECA91.D6CCE4AE.77834EAA.IP)
[19:48:25] <olsonjeffery> not really even interested in gravity, per se
[19:48:31] <Lilly> I know singletons are antipatterns in most cases accoring to some people, but I like using it for that
[19:48:33] <olsonjeffery> maybe a spatial hash or 3d rtree
[19:48:38] <strcat> Ms2ger: half of rust's language features are about avoiding gc
[19:48:40] <doomlord> i heard scala/clojure dont perform well on android because the GC doesn't suit those more functional languages (they generate more interim garbage)
[19:48:47] <strcat> you can write large rust programs without any gc at all
[19:49:01] <strcat> it's not meant to be used often
[19:49:05] <Jeaye> olsonjeffery: I haven't seen anything like that come through yet. Just GL, glfw, sdl,e tc bindings.
[19:49:13] *** Quits: Vert (quassel@8A83479C.391ACC8C.CAF63861.IP) (Ping timeout)
[19:49:16] <Ms2ger> strcat, right; but that doesn't necessarily need to affect the abilities of the actual GCd pointers
[19:49:21] <strcat> Ms2ger: it does
[19:49:29] <strcat> you can borrow & and &mut from gc'ed pointers
[19:49:38] <Ms2ger> Yeah
[19:49:46] *** Quits: pnathan (Adium@B9840254.2CD8A5F8.477B877D.IP) (Ping timeout)
[19:49:47] <Jeaye> Lilly: Singletons have a place in the world, just like anything else.
[19:50:07] <strcat> Ms2ger: so you can't do a fully moving gc, since they can have an unmanaged pointer borrowed
[19:50:15] <strcat> it can't compact the entire heap
[19:50:20] <Ms2ger> You could make borrowed pointers pointers to pointers, but that's too much overhead, I guess :)
[19:50:41] <strcat> Ms2ger: it would be unacceptable to add costs to the rest of the language for gc
[19:50:46] <strcat> it's primarily a language without gc
[19:50:51] <Ms2ger> Yeah, that's fair
[19:50:55] <doomlord> if rust has to compromise GC for the sake of efficient non-GC code, that is a good thing.
[19:51:00] *** Quits: hjr3 (hradtke@1A0AE795.28A5F6C3.A2D40ED2.IP) (Quit: My MacBook has gone to sleep. ZZZzzzâ€¦)
[19:51:15] <Ms2ger> Just saying that it's not technically impossible, just realistically
[19:51:16] *** Joins: pnathan (Adium@B9840254.2CD8A5F8.477B877D.IP)
[19:51:17] <doomlord> there's enough GC languages (well, too many..)
[19:51:27] *** Quits: nano (nano@moz-972880B.superkabel.de) (Connection reset by peer)
[19:51:30] <strcat> Ms2ger: well, it's technically impossible without impacting the rest of the language afaik
[19:51:33] <strcat> and that's a requirement
[19:51:41] <Ms2ger> Right
[19:51:45] <cmr> An alternative Rust implementation could do it
[19:51:47] <strcat> you could segregate @/@mut entirely
[19:51:51] <strcat> and say you can't borrow from them
[19:51:57] <strcat> and they could be as fast as java
[19:51:57] <Ms2ger> But that's sucky too
[19:52:01] <strcat> but you'd need a whole stdlib just for them
[19:52:41] *** Quits: eatkinson (eatkinson@moz-BBE3ABD.mv.mozilla.com) (Quit: eatkinson)
[19:52:54] <doomlord> so: the compromise is borrowing means no heap compaction?
[19:53:16] <Lilly> But going back to the resource manager; how would I unload resources? I'm not really sure. :(
[19:53:31] <strcat> doomlord: it means much less heap compaction
[19:53:40] <strcat> and no heap compaction for @ without adding overhead to track borrows
[19:53:45] <cmr> Lilly: move out of the internal container and let it die
[19:53:51] <strcat> @mut already has that overhead for write barriers
[19:53:56] <doomlord> ah there's a question i had. *can you query memory usage*
[19:54:03] *** Quits: posco (oscarboyki@636AC086.5999CED5.71743E61.IP) (Quit: posco)
[19:54:07] <Jeaye> doomlord: Let me know if you start working on thrust.
[19:54:12] <cmr> doomlord: from rust itself? no, not yet and not in a cross platform manner.
[19:54:13] <strcat> doomlord: not without asking the OS
[19:54:16] <strcat> and even that is an estimate
[19:54:38] <cmr> doomlord: I want to add instrumentation for that stuff, using libstatgrab, but there are licensing issues
[19:55:06] <Lilly> Sorry if I'm annoying and stupid, but I don't know all too much about computing theory and stuff
[19:55:07] <strcat> it's all an estimate anyway without using cgroups
[19:55:12] <strcat> for example....
[19:55:16] <strcat> 2 applications use the same shared lib
[19:55:29] <strcat> it's loaded as a MAP_SHARED block for both of them
[19:55:36] <strcat> which application counts as using that memory?
[19:55:43] <Lilly> cmr: ah, so I'd just move them to a disposable variable, and then let that variable go out of scope?
[19:55:48] <cmr> Lilly: yes
[19:55:59] <Lilly> cmr: I think I understand, thanks :)
[19:56:07] <cmr> Lilly: (one way of doing that is  `let _ = ...`)
[19:56:14] <strcat> although with overcommit on 64-bit you could mostly just ignore mmap'ed libraries
[19:56:24] <Lilly> is _ a special case or something?
[19:56:26] <mark_edward> the DuplexStream pair created by extra::comm::DuplexStream() send/recv to/from each other right?
[19:56:51] <cmr> Lilly: the left-hand-side of `=` in a `let` is a pattern, and yes
[19:57:01] <jedestep> Lilly: _ is a throwaway variable
[19:57:14] <jedestep> placeholder essentially
[19:57:44] <Lilly> Feels like a keyword for _ would look better, but that's just my personal opinion... :P
[19:57:46] <cmr> A type of wildcard, is how I think of it (not sure how accurate it is)
[19:57:52] <cmr> Lilly: well it's used elsewhere too
[19:58:01] *** Quits: azita (Azita@moz-BBE3ABD.mv.mozilla.com) (Quit: azita)
[19:58:05] <cmr> match foo { 1 => println("1"), _ =>  fail!("not one") }
[19:58:19] <Lilly> Yeah I know
[19:58:20] <cmr> let (_, y) = get_coord()
[19:58:20] * strcat always forgets to 'git remote prune' and ends up with 10000 remotes
[19:58:21] <cmr> and so forth
[19:58:40] <Lilly> But "let _ = foo;" doesn't really read like "throw away the thing pointed too by foo"
[19:58:51] <cmr> It does once you're used to it
[19:58:53] <cmr> :p
[19:58:57] <Lilly> I guess :P
[19:59:18] <ecr> isn't there a macro that does "let _ = x;" called ignore! or something?
[19:59:27] <Lilly> it's just that I associate "let x = y" with "assign y to x"
[19:59:28] <kimundi> It reads as 'rebind the variable to the throwaway pattern'
[19:59:46] *** Joins: azita (Azita@moz-BBE3ABD.mv.mozilla.com)
[19:59:54] <Lilly> _ is just another variable name to me, coming from C++ :P
[19:59:58] <kimundi> Lilly: That's essentially how it works
[20:00:10] <kimundi> well...
[20:00:16] <Lilly> I guess I should think about it that way kimundi :)
[20:00:16] <jedestep> ecr: I think std::util used to have a function called forget() but it's gone now
[20:00:17] * Ms2ger prefers (Î»_.unit) foo
[20:00:29] <cmr> rusti: fn _() -> {};
[20:00:29] -rusti- <anon>:7:12: 7:13 error: expected ident, found `_`
[20:00:30] -rusti- <anon>:7          fn _() -> {};
[20:00:30] -rusti-                      ^
[20:00:30] -rusti- application terminated with error code 101
[20:00:36] <cmr> rusti: fn _f() -> {};
[20:00:36] -rusti- <anon>:7:21: 7:22 error: unexpected token: `}`
[20:00:36] -rusti- <anon>:7          fn _f() -> {};
[20:00:37] -rusti-                               ^
[20:00:37] -rusti- application terminated with error code 101
[20:00:40] *** Joins: snadon (chatzilla@moz-3BC727E8.mc.videotron.ca)
[20:00:41] <cmr> rusti: fn _f() {};
[20:00:42] -rusti- ()
[20:01:06] <jedestep> Lilly: the _ convention has a precedent in a number of other languages that use it for the same purpose, such as haskell and ocaml
[20:01:25] <Lilly> ok, so _ is a reserved word then
[20:01:32] <Lilly> I see, thanks a lot guys :D
[20:01:32] <ecr> I always read _ as 'black hole'
[20:01:54] <kimundi> rusti: let (_, b, _) = (1, 2, 3); b
[20:01:55] -rusti- 2
[20:01:58] <Lilly> A forget! macro could be good, though.
[20:02:13] <cmr> well forget is something different
[20:02:14] <strcat> you'll be able to call .drop()
[20:02:16] <cmr> *forget
[20:02:27] <strcat> to destroy before the end of a scope
[20:02:33] <strcat> but really it's not a common use case
[20:02:50] <thiez> rusti: let mut x = ~3; x = x; *x
[20:02:51] -rusti- application terminated abnormally with signal 11 (Segmentation fault)
[20:02:52] <Lilly> (I read all macros as if I was shouting their names because of the ! haha)
[20:02:56] <jedestep> macro_rules! ignore { ($x:item) => { let _ = $x; } }
[20:03:05] <strcat> thiez: that's good ;p
[20:03:12] <strcat> rusti: let ref x = 5;
[20:03:12] -rusti- <anon>:7:13: 7:18 warning: unused variable: `x` [-W unused-variable (default)]
[20:03:13] -rusti- <anon>:7          let ref x = 5;
[20:03:13] -rusti-                       ^~~~~
[20:03:13] -rusti- ()
[20:03:13] *** Joins: frogaincia (Mibbit@BBE7C46A.B4F11D08.8612FA94.IP)
[20:03:18] <strcat> at least that works npw
[20:03:20] <strcat> now*
[20:03:22] *** Quits: tjc (tjc@moz-BBE3ABD.mv.mozilla.com) (Quit: zzzzzzzzzz)
[20:03:24] <strcat> rusti: let ref x = 5; *x
[20:03:25] -rusti- 5
[20:03:25] <Lilly> dispose! maybe would be better?
[20:03:28] <jedestep> thiez: i get about the same average level of success out of rusti
[20:03:31] <strcat> Lilly: it doesn't need to be a macro
[20:03:37] <strcat> you'll just x.drop()
[20:03:38] <Lilly> ecr: yeah, "black hole" is probably good
[20:03:46] <kimundi> Lilly: Well, forget means something different in rust :) There is a unsafe utilty function with that name, wich makes the compiler 'forget' about a value, aka not run its destructor etc... Effectivly a way to croeat memory leaks if used on its own
[20:03:46] <thiez> jedestep: I was just checking a (known) bug ;)
[20:04:07] <strcat> Lilly: things are already destroyed as soon as they go out of scope
[20:04:12] <Lilly> ah, ok strcat
[20:04:14] <strcat> there aren't many use cases for calling it early
[20:04:15] <ecr> Lilly: it's not really a reserved word, but a variable prefixed by _ is understood by the compiler as a variable that can be ignored. If you have the unused variable lint mode active, then a variable prefixed by _ (e.g. _buf) won't raise warnings. Usually you just use _ if you want to ignore something, but sometimes it's useful to name them if you have multiple things you're ignoring as a form of documentation.
[20:04:25] <Lilly> That's great!
[20:04:36] <kimundi> rusti: let x, _y;
[20:04:37] -rusti- more than 5 lines of output, pastebinned: http://sprunge.us/YXjX
[20:04:49] <kimundi> rusti: let x:int; let _y:int;
[20:04:50] -rusti- <anon>:7:13: 7:14 warning: unused variable: `x` [-W unused-variable (default)]
[20:04:50] -rusti- <anon>:7          let x:int; let _y:int;
[20:04:50] -rusti-                       ^
[20:04:50] -rusti- ()
[20:05:11] *** Quits: huseby (huseby@moz-4E8C421A.husebyhome.com) (Quit: Leaving)
[20:05:36] <Lilly> strcat: my question was about a vector of resources; basically a huge list of pointers to resources
[20:05:49] <Lilly> If I wanted to unload those resources manually
[20:05:50] <strcat> Lilly: when something is removed from the vector, it's destroyed
[20:05:55] <kmc> pcwalton, bstrie: would that come with a trait providing deref sugar?
[20:06:05] <strcat> Lilly: or you could swap them out of the vector
[20:06:05] <kmc> er wow I was scrolled up, I meant re @T -> Gc<T>
[20:06:13] <doomlord> filter the resource vector in a cleanup point in your update?
[20:06:15] <strcat> swap them to the end and pop()
[20:06:30] <Lilly> hm yeah
[20:06:37] <cmr> which is probably the only sane thing to do with a vector
[20:06:42] <cmr> removing from the middle is expensive
[20:06:42] *** Quits: infynyxx (infynyxx@DB780A29.749BA1D.DCC373F0.IP) (Client exited)
[20:06:55] <strcat> cmr: unless you don't care about order
[20:07:09] <kimundi> rusti: let mut res = ~[~"foo", ~"foo", ~"foo", ~"foo"]; res.pop(); /* one ~"foo" destroyed here */ ; res
[20:07:10] -rusti- ~[~"foo", ~"foo", ~"foo"]
[20:07:15] <Lilly> I'm not very good with optimizations on containers :/
[20:07:32] <engla> vec already implements swap_remove
[20:07:49] <Lilly> I know what big O notation means, and how to calculate it
[20:08:02] <Lilly> but I don't know the specifics of all the containers
[20:08:11] <kimundi> rusti: let mut res = ~[~"foo", ~"blu", ~"bar", ~"baz"]; res.swap_remove(2); /* ~"bar" destroyed here */ ; res
[20:08:12] -rusti- ~[~"foo", ~"blu", ~"baz"]
[20:08:13] *** Joins: erickt (erickt@8C9ECD8F.3A598286.F12515B4.IP)
[20:08:37] <Lilly> Why isn't remove == swap_remove?
[20:08:41] <Lilly> if I  may ask
[20:08:50] <engla> it doesn't preserve order
[20:08:54] <kimundi> rusti: let mut res = ~[~"foo", ~"blu", ~"bar", ~"baz"]; res.swap_remove(0); res
[20:08:55] -rusti- ~[~"baz", ~"blu", ~"bar"]
[20:08:58] <kimundi> rusti: let mut res = ~[~"foo", ~"blu", ~"bar", ~"baz"]; res.remove(0); res
[20:08:59] -rusti- ~[~"blu", ~"bar", ~"baz"]
[20:09:13] <Lilly> ah ok
[20:09:18] <kimundi> swap_remove = O(1)
[20:09:19] <Lilly> thanks ^^
[20:09:21] <kimundi> remove = O(n)
[20:09:31] <Lilly> dang that's fast
[20:09:54] <cmr> an O(1) can be 30 minutes, Lilly
[20:10:02] <cmr> algorithmic complexity is only tenously related to runtime
[20:10:06] <Lilly> It's relatively fast
[20:10:08] <Lilly> :P
[20:10:10] <kimundi> basically just two pointer copies and a dercement
[20:10:56] *** Quits: erickt (erickt@8C9ECD8F.3A598286.F12515B4.IP) (Ping timeout)
[20:10:58] <Lilly> and you guys type fast by the way haha
[20:11:32] <Lilly> Thanks a bunch for all the help
[20:11:42] <Lilly> Sorry if I'm a little slow, I'm still learning!
[20:11:48] <cmr> don't worry about it :)
[20:11:51] <jedestep> rust is hard
[20:11:58] <jedestep> at least for me 
[20:12:14] <Lilly> There are some new concepts that are hard to understand for me
[20:12:26] <Lilly> I thought pointers were hard when I started C++
[20:12:36] <kimundi> Lilly: Don't be afraid to ask, it's no secret that this channel is the only comprehensive documentation of rust at the moment ;)
[20:12:37] <Lilly> And now I have 3 to learn haha
[20:12:55] <Lilly> kimundi: haha yeah :P
[20:12:57] <cmr> Lilly: (4, actually, we have the raw pointer too, *T)
[20:13:04] <Lilly> Oh yeah, that's true cmr
[20:13:15] <cmr> & is fairly easy I think: it's a pointer that you don't free
[20:13:29] <Lilly> I just feel a little... awkward around all these professionals
[20:13:35] <cmr> The lifetimes it just to figure out that it doesn't get freed while it's still in use
[20:13:36] <kmc> Lilly: have you used smart pointers in C++? there are some that act sort of like ~T
[20:13:40] <jedestep> cmr: & becomes fairly intimidating when you have to introduce lifetime variables
[20:13:47] <Lilly> I'm just a 19 year old that happens to be interested in programming
[20:13:58] <cmr> jedestep: I think it's mostly a problem of compiler bugs in that regard though ;(
[20:14:12] *** Joins: eschweic (Adium@moz-BBE3ABD.mv.mozilla.com)
[20:14:13] <cmr> poor error messages, ICEs, non-obvious arbitrary restrictions
[20:14:24] <Lilly> kmc: not in practice, but I've tried them out and read about them
[20:14:30] *** Joins: huseby (huseby@moz-4E8C421A.husebyhome.com)
[20:14:37] <jedestep> cmr: poor error messages definitely plays into it. at the time I was learning lifetime vars, they were also fully absent from the tutorial
[20:14:47] <kmc> ouch
[20:15:00] <jedestep> and were largely undocumented in even the reference manual, with only 1 or 2 sentences
[20:15:10] <cmr> isn't that still the case now?
[20:15:13] <sigma> lilly: you're in the same boat as some other in this channel (including me) watching the process of a language/runtime coming together is fascinating
[20:15:13] *** Joins: hjr3 (hradtke@1A0AE795.28A5F6C3.A2D40ED2.IP)
[20:15:15] <Ms2ger> Is that the 'foo stuff?
[20:15:20] <jedestep> is it? i haven't checked
[20:15:21] <cmr> (except the section in the borrowed ptr tutorial)
[20:15:23] <cmr> Ms2ger: yes
[20:15:25] <jedestep> Ms2ger: yeah, &'foo
[20:15:26] <Ms2ger> That still isn't in the tutorial
[20:15:33] <cmr> It's in http://static.rust-lang.org/doc/tutorial-borrowed-ptr.html#named-lifetimes
[20:15:38] <engla> it has its own tutorial
[20:15:39] <Ms2ger> Also impossible to search for
[20:15:49] <Lilly> Who is responsible for cleaning up after something pointed to by an & pointer?
[20:15:50] <kimundi> Lilly: The trick is that all these pointers also exist in languagas with just 1. The difference is just that those language don't seperate the different semantics, while rust explicitly does.
[20:15:57] <cmr> Lilly: The owner
[20:16:05] <Lilly> sigma: yeah, that's basically why I'm here haha :D
[20:16:09] <cmr> Lilly: whoever owns the ~ it was borrowed from
[20:16:13] <cmr> Or, the GC, in the case of @
[20:16:19] <jedestep> best documentation i've found for &'a is http://smallcultfollowing.com/babysteps/blog/2012/07/17/borrowed-pointer-tutorial/
[20:16:23] <kimundi> Lilly: No one, a & has no saying on when the memory it points at gets cleaned up
[20:16:30] <Lilly> ok so an & pointer always needs to point to something owned by someone else?
[20:16:31] <cmr> jedestep: yeah, http://static.rust-lang.org/doc/tutorial-borrowed-ptr.html#named-lifetimes is that but updated
[20:16:38] <engla> or the scope, if it was borrowed from a stack variable
[20:16:39] <kimundi> Yes
[20:16:46] <cmr> Lilly: yup, that is why it is called "borrowed"
[20:17:04] <Lilly> I read about that, but then I read code like "let a = &1;"
[20:17:15] <Lilly> but that is illegal?
[20:17:20] <cmr> rusti: let a = &1; fmt!("%?", a)
[20:17:21] -rusti- ~"&1"
[20:17:34] <nmatsakis> Lilly: that's effectively shorthand for "let tmp = 1; let a = &tmp;"
[20:17:34] <kimundi> thats just suger for "let x = 1; let a = &x"
[20:17:44] *** Joins: posco (oscarboyki@636AC086.5999CED5.71743E61.IP)
[20:17:46] <ecr> ^ what they said
[20:18:01] <cmr> rusti: let a = &1; a
[20:18:02] -rusti- more than 5 lines of output, pastebinned: http://sprunge.us/Cbcj
[20:18:03] <Lilly> ok, so it drops when "tmp" goes out of scope
[20:18:12] <cmr> Lilly: notice how it won't let it escape the scope though
[20:18:20] <sigma> this is definitely in contention with #haskell for worlds most helpful IRC channel.
[20:18:33] <jdm> who knows when the collect phase runs? before typechecking? after?
[20:18:41] <cmr> jdm: language item collection?
[20:18:56] <jdm> cmr: I guess so. it seems to control the astconv stuff.
[20:18:58] <Lilly> aah cmr
[20:19:11] <cmr> jdm: it runs before resolve, iirc
[20:19:16] <jdm> hrm hrm
[20:19:23] <Lilly> sigma: this channel definitely is helpful :D
[20:19:38] <cmr> https://github.com/mozilla/rust/blob/master/src/librustc/driver/driver.rs#L230
[20:19:40] <cmr> yup
[20:19:59] *** Quits: eschweic (Adium@moz-BBE3ABD.mv.mozilla.com) (Ping timeout)
[20:20:25] <kimundi> Can't conquer the world with unfriendlyness, I say ;)
[20:20:59] <ecr> Burying the world in hugs on the other hand...
[20:21:16] <glinscott> hm.  any idea why can't I use type T on this expand call?  https://github.com/glinscott/rust/compare/vec_reserve#L0R1168
[20:21:20] <Lilly> kimundi: true enough :D
[20:21:58] <sigma> Plus, it feels pretty good when you realise you actually understand something, I've had more *lightbulb* moments in the last week than in the last couple of months...
[20:22:12] <Ms2ger> \o/
[20:22:23] <cmr> glinscott: should be expand::<T>(ptr, n) perhaps?
[20:22:24] <Lilly> sigma: agreed!
[20:22:25] <bstrie> sigma Lilly: we just insist that all unfriendly people use the #rust_for_assholes channel
[20:22:29] <mark_edward> cmr: how would you cleany exit a task yo've spawned that sits in a loop waiting for things to work on
[20:22:32] <Lilly> bstrie: hahaha!
[20:22:33] *** Joins: askalski (akuda@2BA4E5A7.CC7751E8.6712E96B.IP)
[20:22:44] <jdm> erf
[20:22:46] <mark_edward> srsly everyone one this channel is super ncie
[20:22:55] <cmr> mark_edward: send it a message telling it to die
[20:23:13] <bstrie> that's not super nice :(
[20:23:31] <jdm> bstrie: send it a message asking it nicely to die?
[20:23:47] <bstrie> cmr: you should listen to jdm
[20:23:54] <cmr> it's certainly nicer than just descheduling it and deallocating its memory
[20:24:03] <cmr> poor task, never saw it coming
[20:24:13] <Ms2ger> bstrie, #rusty_assholes?
[20:24:13] <bstrie> foo.die(); //please
[20:24:15] <glinscott> cmr: indeed, that was the magic!  so "::<T>" is the reference to the impl type?
[20:24:29] <bstrie> fun fact, for a brief time the fail!() was called die!()
[20:24:45] <bstrie> Ms2ger: no, that's a different channel...
[20:24:53] <jedestep> that's so aggressive sounding
[20:24:57] <vilonis>  /join #rust_for_assholes
[20:25:11] <Lilly> I read "die!" in a happy tone... :D
[20:25:13] <vilonis> aw
[20:25:18] <Ms2ger> /join #rust_syntax_bikeshed
[20:25:26] <Lilly> You should have called it die_please!()
[20:25:33] <kimundi> (Someone totally needs to write a "rust for assholes" book in the style of this: http://www.mspaintadventures.com/?s=6&p=002016)
[20:25:52] *** Joins: ghrust (ghrust@C8693FCB.6A2AE50.F3114085.IP)
[20:25:52] <ghrust> 01[13rust01] 15bors merged 06auto into 06master: 02http://git.io/cEzsIg
[20:25:52] *** Parts: ghrust (ghrust@C8693FCB.6A2AE50.F3114085.IP) ()
[20:25:59] <cmr> glinscott: It's how you add optional type hints when inference fails
[20:26:00] <bstrie> kimundi: hahaha, I wonder if I was channeling that subconsciously
[20:26:16] <jedestep> learn you a rust for great good
[20:26:28] <bstrie> I think we might get sued
[20:26:32] *** Ms2ger is now known as sicking`
[20:26:35] <bstrie> if we make a book entitled that
[20:26:40] *** sicking` is now known as Ms2ger
[20:26:52] <ecr> well, the LYAH guy was fine with learn you some erlang for great good
[20:27:05] <ecr> we'd probably be fine as long as we asked first
[20:27:16] <bstrie> Learn You A Wee Bit Of Rust For Personal Reasons
[20:27:24] <ecr> personally, i'd like to try writing a tutorial in that style once we reach 1.0
[20:27:33] <jedestep> lyawborfpr
[20:27:35] *** Quits: FrozenCow (FrozenCow@moz-B2DF4929.chello.nl) (Quit: Leaving)
[20:27:38] <jedestep> rolls off the tongue
[20:27:42] <ecr> lol
[20:28:12] <jedestep> ecr: i think that style of tutorial would be really nice to have
[20:28:34] <ecr> jedestep: same, it's my favorite haskell tutorial.
[20:28:40] <kimundi> Imagine Never Hearing The Phrase "Learn You A Rust For Great Good" Again
[20:28:40] *** Joins: ghrust (ghrust@5FEF1C87.6A2AE50.F3114085.IP)
[20:28:40] <ghrust> 01[13rust01] 15bors pushed 0 new commits to 06auto: 02http://git.io/O5SJgg
[20:28:40] *** Parts: ghrust (ghrust@5FEF1C87.6A2AE50.F3114085.IP) ()
[20:28:42] *** Joins: ghrust (ghrust@FD7BC443.6A2AE50.F3114085.IP)
[20:28:42] <ghrust> 01[13rust01] 15bors pushed 5 new commits to 06auto: 02http://git.io/LumjZg
[20:28:42] <ghrust> 13rust/06auto 14fd5f8d9 15Daniel Micay: iterator: add DoubleEndedIterator concept...
[20:28:42] <ghrust> 13rust/06auto 1400da76d 15Daniel Micay: vec: rm inline(never) hack...
[20:28:42] <ghrust> 13rust/06auto 141d08ceb 15Chris Morgan: Fix comment indenting properly for Vim files....
[20:28:44] *** Parts: ghrust (ghrust@FD7BC443.6A2AE50.F3114085.IP) ()
[20:28:53] <strcat> pcwalton: it would be interesting to see the performance gain from throwing out segmented stacks completely
[20:29:02] <ecr> strcat: he's at lunch
[20:29:09] <strcat> he'll see it when he gets back ;p
[20:29:21] *** Quits: askalski (akuda@2BA4E5A7.CC7751E8.6712E96B.IP) (Quit: Wychodzi)
[20:29:23] <kimundi> Imagine Never Hearing The Phrase "he's at lunch Again
[20:29:34] <strcat> pcwalton: as in, use guard pages + add checks on allocations larger than the guard pages
[20:29:47] <kimundi> (darn, missing ")
[20:29:48] <glinscott> cmr: ah, ok.  thanks!
[20:29:56] <ecr> Imagine Never Hearing The Phrase "Imagine Never Hearing The Phrase 'Imagine Never....
[20:30:07] <doomlord> ah. i was rambling about "leaf functions", recallingn how on mips , some functions dont touch the stack at all - if they stick to certain registers
[20:30:22] *** Joins: askalski (akuda@2BA4E5A7.CC7751E8.6712E96B.IP)
[20:30:33] <jedestep> s/Imagine Never Hearing The Phrase/Imagine Never Hearing The Phrase '&'/
[20:30:48] <doomlord> (caller saved vs callee saved)... i bet you could do something like that. get the compiler to flag functions that dont need to check for stack growth...
[20:30:49] <bblum> ecr: c.c.c.c
[20:31:00] <strcat> doomlord: or just not have stack growth
[20:31:21] <thiez> no segmented stacks, use my beautiful 64-bit address space
[20:31:34] <thiez> so many numbers I've never used, they must be sad
[20:31:40] <strcat> they don't suddenly not become a 30-500% perf hit on 32-bit
[20:31:46] <strcat> we can't use them there either if they don't radically improve
[20:32:04] <strcat> servo can't be sometimes 50% slower than ffx
[20:32:17] <thiez> small question, why do 'min' and 'max' on f32 take &f32 as argument?
[20:32:24] <strcat> they're generic
[20:32:26] <thiez> since they are copyable and all that
[20:32:30] <thiez> ah, ok
[20:32:41] <thiez> so we rely on LLVM to un-& them?
[20:32:41] <strcat> they're small so it doesn't matter
[20:32:43] <strcat> there's no actual call
[20:32:46] * kimundi imagines the rust cog doing a happy dive into a scrooge mcduck-like pointer bin
[20:32:48] <strcat> thiez: we know LLVM will do that
[20:32:50] <strcat> don't need to hope
[20:32:57] <thiez> I said rely, not hope :p
[20:33:05] <strcat> well rely sounds like it could fail
[20:33:05] <thiez> LLVM is amazing.
[20:33:13] *** Quits: askalski (akuda@2BA4E5A7.CC7751E8.6712E96B.IP) (Quit: Wychodzi)
[20:33:28] <doomlord> so if you have a value in a register, you can say &value, and it will just inline to using that register, i think
[20:33:35] <bjz> olsonjeffery: were you talking about space modelling in rust?
[20:33:38] <thiez> sure.
[20:33:38] <doomlord> just like when optimizing references in C++
[20:33:42] <strcat> if you take the ref as part of the call you're guaranteed that it will be gone as long as LLVM annotates the call with nocapture
[20:33:49] <strcat> and we could do nocapture ourselves in the frontend
[20:34:10] <doomlord> an adress can as easily be a register name for inlined code.
[20:34:12] <strcat> (LLVM is smart enough anyway for probably ever case like that though)
[20:35:11] <thiez> I wonder how much effort it would be to write a script that would, for each XFAIL'd test: un-XFAIL it, test if it still doesn't work, and if it works, create a commit to remove the XFAIL.
[20:35:21] <thiez> only problem would be tests that only fail on certain platforms
[20:35:22] <bblum> ecr: 
[20:35:24] <bblum> à² _à² 
[20:35:29] <cmr> And also tests that are bitrotted
[20:35:40] <cmr> some just need a syntax update
[20:35:44] <cmr> Or a `use` here or there
[20:35:56] <cmr> Also a lot of them need a fixme to un-xfail them
[20:36:03] <ecr> bblum: use that instead of .get()
[20:36:12] <thiez> those tests can just go for all I care, if we really needed them they wouldn't have bitrotted in the first place :p
[20:36:21] <bblum> ecr: Ê˜â€¿Ê˜ï»¿
[20:36:47] <kimundi> let o = Some(42); let n = od.â‡’();
[20:36:51] <jdm> that is an exceedingly creepy emoticon
[20:36:51] * bjz recoils in horror at bblum's emoticon
[20:36:57] <bblum> :3
[20:37:03] <jedestep> :I
[20:37:09] <bjz> :)
[20:37:11] <ecr> >:]
[20:37:21] <kmc> ê™®
[20:37:23] <kimundi> Î¿âˆ€Î¿
[20:37:29] <bblum> :I is not used enough
[20:37:30] <cmr> NO MORE UNICODE
[20:37:32] <cmr> â€œâ€œâ€Ì¿ Ì¿ Ì¿ Ì¿ Ì¿â€™Ì¿â€™ÌµÍ‡Ì¿Ì¿Ð·=(â€¢Ìªâ—)=Îµ/ÌµÍ‡Ì¿Ì¿/Ì¿ Ì¿ Ì¿ Ì¿ Ì¿â€™â€œâ€œ
[20:37:36] <cmr> oh hm my terminal butchered that
[20:37:40] <cmr> â€œâ€œâ€Ì¿ Ì¿ Ì¿ Ì¿ Ì¿â€™Ì¿â€™ÌµÍ‡Ì¿Ì¿Ð·=(â€¢Ìªâ—)=Îµ/ÌµÍ‡Ì¿Ì¿/Ì¿ Ì¿ Ì¿ Ì¿ Ì¿â€™â€œâ€œ
[20:37:43] <cmr> :(
[20:37:50] <cmr> maybe it's weechat
[20:37:52] <tikue> cmr: looks fine to me
[20:37:53] <ecr> looks good to me
[20:37:59] <bjz> looks good
[20:38:04] <cmr> guess it's weechat
[20:38:08] <Lilly> my irc client can show about half of those haha
[20:38:16] <jedestep> Ã¥.Ã¥
[20:38:19] <cmr> https://gist.github.com/cmr/3e51428072655bb37376/raw/67b30c0eac7e38a3c6753448bbd47b0545393016/gistfile1.txt
[20:38:25] <Lilly> Ã…Ã„Ã–Ã…Ã–Ã„Ã– ENTER SWEDEN Ã…Ã„Ã–Ã…Ã„Ã–
[20:38:31] <bjz> :o]
[20:38:40] <kimundi> But unicode is the Î± and the Ï‰ !
[20:38:40] <jdm> grumble grumble constant evaluation
[20:38:42] <jdm> riddle me this:
[20:38:47] <ecr> I still argue that we should replace fail!() with the flip table symbol
[20:38:55] <Lilly> hahaha ecr :D
[20:39:23] <jedestep> Ë™âˆ†Ë™
[20:39:27] <Lilly> is identifiers in uft allowed?
[20:39:27] <kimundi> RFC: Replace `loop` with `âˆž`
[20:39:28] <kmc> cmr: it's all unicode -_-
[20:39:32] <Lilly> utf*
[20:39:57] <kimundi> Lilly: Only a certain range. Basicaaly everthing that is classified as a letter in some language
[20:40:03] <jedestep> rusti: let âˆ‘ = 1; âˆ‘
[20:40:04] -rusti- <anon>:7:13: 7:13 error: unknown start of token: 8721
[20:40:04] -rusti- <anon>:7          let âˆ‘ = 1; âˆ‘
[20:40:04] -rusti-                       ^
[20:40:04] -rusti- application terminated with error code 101
[20:40:08] <bblum> Lilly: yes but unfortunately https://github.com/mozilla/rust/issues/7048
[20:40:13] <kimundi> rusti: let Ï€ = 3.14; Ï€
[20:40:14] -rusti- 3.14
[20:40:21] <cmr> Lilly: we follow http://www.unicode.org/reports/tr31/
[20:40:26] <sigma> I aliased an exception to the look of disapproval string at work, that didn't get past code-review
[20:40:32] <jedestep> rusti: let Æ’ = ~"foo";
[20:40:33] -rusti- <anon>:7:13: 7:13 warning: unused variable: `Æ’` [-W unused-variable (default)]
[20:40:33] -rusti- <anon>:7          let Æ’ = ~"foo";
[20:40:33] -rusti-                       ^
[20:40:33] -rusti- ()
[20:40:38] <jedestep> rusti: let Æ’ = ~"foo"; Æ’
[20:40:39] -rusti- ~"foo"
[20:40:56] <jedestep> cool, all my functions shall now be called Æ’
[20:41:04] <kimundi> rusti: let Å¿ = '?'; Å¿
[20:41:05] -rusti- '?'
[20:41:10] <Lilly> aww, why not ALL the tokens? :D
[20:41:41] <Lilly> (emote icon identifiers is vital to my programming)
[20:42:23] <sigma> if (in_some_start_that_should_never_have_been_possible):
[20:42:24] <sigma>     raise à² _à² 
[20:42:31] <sigma> that did not format well
[20:42:31] <kimundi> Would be nice if rustc woult accept all unicode characters as tokens. IT can stdill error on them in regular rust code, but macros could consume them.
[20:42:42] <bblum> rusti: let à² _à²  = (); à² _à² 
[20:42:43] -rusti- ()
[20:42:49] <ecr> BRILLIANT
[20:42:49] <bblum> good.
[20:42:54] <Lilly> Perfect
[20:43:05] <ecr> submit the patch to replace Option.get() !
[20:43:12] <Lilly> if (foo == à² _à² ) fail!("à² _à² ");
[20:43:23] *** Quits: reyre (reyre@86C3727C.33EE9F8A.1139E686.IP) (Client exited)
[20:43:29] <jedestep> oh my god
[20:43:41] <jedestep> this is officially the best language
[20:43:55] <strcat> anyway I think we should have sane contiguous stacks that the CPU cache can actually handle, and that don't wipe out branch prediction
[20:44:08] <cmr> strcat: please yes
[20:44:10] <kimundi> rusti: fn à² _à² () { fail!("à² _à² ") }; à² _à² ()
[20:44:11] -rusti- rust: task failed at 'à² _à² ', <anon>:7
[20:44:11] -rusti- rust: domain main @0x21761b0 root task failed
[20:44:12] -rusti- application terminated with error code 101
[20:44:21] <strcat> really, I don't think it's okay that a call to malloc is 5x slower than C :\
[20:44:40] <strcat> and the code is slower coming back from malloc
[20:44:48] <cmr> I don't really care about the hundred-thousand tasks usecase, especially on 32-bit...
[20:44:50] <strcat> because the CPU just said "hey, a stack!" and then you took it away
[20:45:23] <olsonjeffery> bjz: yeah.. thinking about a simple model for 3d space.. 
[20:45:58] <strcat> and you're referring by-reference to other stack segments when you pass borrowed pointers deeper
[20:46:05] <strcat> and with rust they're in completely different VM locations.
[20:46:12] <strcat> it has no hope of caching
[20:46:23] *** Joins: eatkinson (eatkinson@moz-BBE3ABD.mv.mozilla.com)
[20:46:25] <strcat> I'm convinced that's the reason stuff is so slow
[20:46:27] *** Joins: eschweic (Adium@moz-BBE3ABD.mv.mozilla.com)
[20:46:29] <olsonjeffery> like a 3d rtree or something. don't know if there're 3d spatial hashes (i know chipmunk uses a 2d one)
[20:46:44] *** Joins: tjc (tjc@moz-BBE3ABD.mv.mozilla.com)
[20:46:44] *** ChanServ sets mode: +o tjc
[20:46:44] <Lilly> kimundi: this is definitely a good idea in big codebases
[20:46:46] <sp3d> an octree?
[20:46:56] <kimundi> Lilly: :D
[20:47:02] <Lilly> imagine if someone snuck that into servo
[20:47:03] <olsonjeffery> perhaps.
[20:47:09] <strcat> cmr: well maybe I'll implement it and submit a PR to spur discussion ;p
[20:47:12] <Lilly> and it shipped
[20:47:23] <Lilly> and the end user gets à² _à²  errors
[20:47:43] <strcat> cmr: set a few pages to PROT_NONE at the end, and use LLVM's stack smashing protection for allocations larger than the guards
[20:47:43] <ecr> >.<
[20:47:47] <strcat> don't think it'd be that hard
[20:47:58] <strcat> I think SSP lets you just pick a min size to add checks for
[20:48:14] <cmr> strcat: that's how Blei debugged the stack canary slaughter
[20:48:21] <strcat> cmr: yeah but guard pages alone isn't safe
[20:48:40] <strcat> because you can have a stack allocation larger than the guards
[20:48:43] <cmr> just pointing out that it's easily feasible
[20:48:58] <strcat> right and someone can still implement segmented stacks
[20:49:03] <strcat> but we can abandon this morestack stuff
[20:49:24] <strcat> minimum stack size would be 8K though
[20:49:27] <strcat> so it'd be useless on 64-bit
[20:49:43] <strcat> 1 page stack + 1 guard page
[20:49:57] <strcat> and set it to handle faults on guard pages and grow
[20:50:20] <strcat> whatever the growth strategy is, but it wouldn't be the default to make a small stack
[20:50:24] <kmc> is the language accepted by fmt!() documented anywhere?
[20:50:32] <cmr> kmc: the source
[20:50:34] <strcat> kmc: don't think so
[20:50:41] <strcat> kmc: and fmt! is one of the worst parts of the language ;p
[20:50:45] <strcat> it's going to have to change a lot
[20:50:51] <bblum> strcat: why
[20:50:57] <kalenedrael> I <3 fmt!
[20:50:58] <bjz> olsonjeffery: I'm currently working on a lib for 3d maths
[20:51:15] <strcat> bblum: because it always does allocations, doesn't use traits, and doesn't even implement a real grammar
[20:51:21] <bjz> olsonjeffery: loads to do though
[20:51:23] <strcat> rusti: fmt!("%? %?" 5 5)
[20:51:24] -rusti- ~"5 5"
[20:51:24] <olsonjeffery> bjz: are you the glfw maintainer?
[20:51:35] <strcat> is it supposed to do that? I dunno.
[20:51:37] *** Quits: devinus (devinus@moz-B4AF84BC.ptr.us.xo.net) (Quit: Computer has gone to sleep.)
[20:51:38] <bblum> what you can do it without commas?
[20:51:40] <bblum> o_O
[20:51:41] <bblum> strcat: when should it not allocate?
[20:51:44] <bjz> olsonjeffery: aye
[20:51:48] <bjz> olsonjeffery: https://github.com/bjz/lmath-rs
[20:51:58] <strcat> bblum: the fundamental formatting should use a Writer (a sane version of one ;p)
[20:52:07] <strcat> bblum: formatted I/O shouldn't do any allocation in most cases
[20:52:12] <bblum> hmm
[20:52:17] <strcat> strings would be Writers
[20:52:29] <strcat> I think they are already
[20:52:35] <strcat> but it's not a great interface atm
[20:52:42] *** Joins: jviereck (Adium@moz-A034D4DA.dclient.hispeed.ch)
[20:52:43] <strcat> bblum: so, you'd still have fmt! to make ~""
[20:52:51] *** Quits: MaikKlein (maik@moz-7BAD3439.dip0.t-ipconnect.de) (Ping timeout)
[20:52:57] <strcat> but you could have printf! or printing to any writer without allocs
[20:52:59] <olsonjeffery> bjz: ah. i see you have a placeholder for an octree. well if i end up writing on, i'll where to make my PR :)
[20:53:05] <bblum> sure, ok, i buy that
[20:53:07] <kimundi> Btw, I think I know why fmt!() ignores commas
[20:53:07] *** Joins: jviereck1 (Adium@moz-A034D4DA.dclient.hispeed.ch)
[20:53:08] <bjz> olsonjeffery: ooh!
[20:53:24] <kimundi> rusti: bytes!(12, 35, 96)
[20:53:25] -rusti- &[12, 35, 96]
[20:53:26] <bjz> olsonjeffery: that would be most appreaciated
[20:53:28] <kimundi> rusti: bytes!(12 35 96)
[20:53:29] -rusti- &[12, 35, 96]
[20:53:30] <strcat> bblum: and the actual conversions implemented by types would write out to a writer
[20:53:41] <strcat> you could have them optionally hint in advance the amount they are going to write
[20:53:44] *** Quits: Houm (Houm@moz-25669AA8.fbx.proxad.net) (Ping timeout)
[20:53:49] <Jeaye> bjz: You can add Servo to the glfw-rs README now under "glfw-rs in use" now, right? :)
[20:53:50] <strcat> so a str could reserve the space
[20:54:03] <kmc> Lilly: http://lpaste.net/75725  (took me a sec to find a working mirror of this)
[20:54:07] <strcat> and then you could write types directly to stdout, or a file
[20:54:10] <bjz> Jeaye: haha, I can too
[20:54:30] *** Quits: jviereck (Adium@moz-A034D4DA.dclient.hispeed.ch) (Ping timeout)
[20:54:35] <Lilly> kmc: what am I reading? :P
[20:54:37] *** Joins: Houm (Houm@moz-25669AA8.fbx.proxad.net)
[20:54:40] <kimundi> There is a 'parse_expression_list()' function somewhere in libsyntax thet munches a bunch of tokens. ANd rather than erroring on a missing ',', it just ignores all ','
[20:54:56] <kmc> Haskell code composed mostly of emoticons
[20:55:01] <Lilly> Oh
[20:55:08] <strcat> bblum: C++ has a really awful implementation of this but they have the *spirit* of doing it right ;p
[20:55:09] <Lilly> Dang, I should've learned Haskell
[20:55:19] <tjc> I misread that as "Haskell code composed mostly of emotions"
[20:55:22] <kalenedrael> like everything in C++
[20:55:23] <kmc> you should definitely learn Haskell and Rust and C++
[20:55:27] <strcat> bblum: operator<< is output to a stream, and types implement that, and then strings are streams through the awful stringstream thing
[20:55:30] <Jeaye> kalenedrael: Hey now.
[20:55:33] *** Joins: MaikKlein (maik@moz-7BAD3439.dip0.t-ipconnect.de)
[20:55:34] <kmc> is it expected that turning on RUST_LOG for a whole crate will make things much slower, even when no messages are being printed?
[20:55:40] <Jeaye> C++ holds its own.
[20:55:48] <cmr> tjc: http://esolangs.org/wiki/Cfluviurrh
[20:55:59] <strcat> bblum: it's really bad though. they managed to make stringstreams require an extra allocation to get your string
[20:56:04] <strcat> instead of strings just being a stream.
[20:56:05] *** Quits: vilonis (jared@moz-EE5D17ED.ph.ph.cox.net) (Quit: WeeChat 0.3.8)
[20:56:08] <Lilly> Haskell looks interesting, but I can't see anywhere where I'd use it
[20:56:11] <strcat> or using moves
[20:56:17] <strcat> (although they didn't have moves then)
[20:56:19] <cmr> kmc: it follows a branch and compares strings for every logging statement, so I would imagine so, yes
[20:56:20] <tjc> cmr: heh, I haven't seen that one before
[20:56:20] <kmc> that's ok, it will change the way you think about programming even if you don't use it "for real"
[20:56:23] <kmc> same with C++
[20:56:35] <Lilly> it has some really neat syntax though
[20:56:41] <Lilly> I already "know" C++
[20:56:42] <strcat> anyway something like...
[20:56:43] <kmc> cmr: and if there's no RUST_LOG then those branches just aren't taken?
[20:56:50] <Lilly> "know" because noone knows C++ :P
[20:56:50] <cmr> kmc: afaik, something like that
[20:57:02] <kmc> ok
[20:57:02] <sigma> Haskell's syntax can be a littly impenetrable when you start learning it
[20:57:19] <kmc> I like Haskell syntax, but I agree that it's unfamiliar
[20:57:27] <Lilly> Haskell looks so... elegant in some way
[20:57:29] <kmc> I used to think that layout matters a lot more than it does
[20:57:33] <sigma> theres quite a bit of syntactic sugar that is _really_ usefulm but kind of obscures you understanding how haskell works for the first few days
[20:57:34] <kmc> the layout algorithm is pretty lenient
[20:57:40] <jack> kmc: note that servo uses debug! to add things like drawing frames around objects for debugging. not just for printing. some of those things are expensive.
[20:57:42] <sully> I feel like I would have had a lot of trouble learning haskell if I hadn't learned ML first
[20:57:50] <strcat> trait Writable<S: Stream> { fn write_to(stream: &mut S) { stream.put(byte) } }
[20:57:58] <strcat> trait Writable<S: Stream> { fn write_to(stream: &mut S) { stream.put(self.byte) } }
[20:58:00] <strcat> whatever ;p
[20:58:00] <sully> man, I have gotten so lucky with rebases
[20:58:01] <tjc> sully: I feel like I would have had a lot of trouble learning ML if I hadn't learned Haskell first
[20:58:07] <kmc> jack: ah. side effects of the expression inside debug!()?
[20:58:23] <kmc> sully, tjc: woah dude
[20:58:25] <jack> kmc: yes. there's a bug opened for A Better Way, but that's what's used now.
[20:58:41] <kmc> jack: ok, seems semi-reasonable
[20:58:49] <jack> kmc: as an example, turning debug on for font rendering will outline all the text runs.
[20:59:08] <Lilly> I know neither ML nor Haskell :P
[20:59:11] <cmr> jack: that's not that bad of a solution if you ask me... not as efficient as it could be, but a very easy solution
[20:59:17] <Lilly> I can read Haskell cose and understand most of it
[20:59:18] <Yoric> Lilly: You should :)
[20:59:20] <kmc> ok yes it's much faster with RUST_LOG='gfx::text::glyph=4' rather than RUST_LOG='gfx=4'
[20:59:23] <Lilly> In most cases
[20:59:23] <Ms2ger> Lilly, do you know list, at least? ;)
[20:59:30] <Ms2ger> lisp*
[20:59:30] <Lilly> list?
[20:59:31] <sigma> there's a great stackoverflow post that has a list of steps to follow for learning haskell. though lyahfgg + the typeclassopedia was really the core
[20:59:36] <Lilly> Oh, lisp. No, I don't
[20:59:38] <Lilly> >-<
[20:59:48] <Ms2ger> Me neither
[20:59:52] <tjc> The Evolution of a Haskell Programmer is key: http://www.willamette.edu/~fruehr/haskell/evolution.html
[21:00:04] <ecr> Lilly: I highly recommend reading Learn You A Haskell For Great Good. Not so much because you'll use Haskell everywhere, but because it makes you think a lot and understand things better.
[21:00:06] <Lilly> wait, is Lisp (((((())))))
[21:00:19] <Lilly> ?
[21:00:24] <kmc> it's odd when people learn Haskell because they hear it's "the essence of FP" when to me Haskell is a very unusual FP language with a lot of unusual things
[21:00:25] <Lilly> I should, ecr
[21:00:42] <kmc> it's hard enough learning FP without also learning laziness, static types, type classes, etc. all at once, though these things can help too (esp. static types)
[21:01:03] <jack> cmr: it's not that it's bad, just that it's ugly. there should be some other kind of support in rustc for doing that than piggybacking on side effects of string formatting
[21:01:07] *** Joins: mcguire (Mibbit@moz-68F146AD.dyn.centurytel.net)
[21:01:18] *** Quits: brendan (brendaneic@moz-BBE3ABD.mv.mozilla.com) (Quit: brendan)
[21:01:24] <sigma> kmc: yeh, the value I got out of haskell was really learning the type system and how everything came together
[21:01:25] <tjc> graydon: ping
[21:01:28] <kmc> Lilly: yes Lisp has a lot of parentheses; it's a shame that this is practically all anyone knows about it ;P
[21:01:32] <graydon> tjc: pong
[21:01:35] <kmc> since it's a very interesting language
[21:01:36] <Ms2ger> kmc, the best way to learn FP is Pierce's TaPL, surely :)
[21:01:40] <kmc> haha
[21:01:46] <Lilly> kmc: I know it has a good macro system too!
[21:01:49] <tjc> graydon: how would I go about ssh'ing into the bot to check why http://buildbot.rust-lang.org/builders/auto-linux-32-opt/builds/368 failed?
[21:01:52] <Ms2ger> That actually is how I learned it
[21:01:54] <tjc> I only know how to ssh into linux1
[21:01:58] <tjc> and it doesn't seem to have my key anymore anyway
[21:02:05] *** Quits: SiegeLord (sl@moz-CAF07B4C.hsd1.ma.comcast.net) (Quit: It's a joke, it's all a joke.)
[21:02:06] <sigma> SICP is great for learning lisp
[21:02:08] <sigma> well, scheme
[21:02:11] <cmr> I've been doing SICP
[21:02:16] <cmr> slowly, every night before bed
[21:02:34] <sigma> i got to the point where I was implementing an interpreter then got side tracked...
[21:02:41] <kmc> SICP isn't really about scheme though, it's about some fundamental concepts and uses Scheme as a particularly simple context for discussing them
[21:02:43] <ecr> I hope Rust gets higher-kinded types eventually. I miss functors...
[21:02:44] <sigma> I really should finish that off some day
[21:02:49] <kmc> but yeah it will teach you a decent sized subset of Scheme as well
[21:03:05] <cmr> I've been doing it on paper though..
[21:03:09] <sigma> kmc: Yeh, I've yet to learn lisp macros properly
[21:03:13] <Lilly> We did Ada in high school. I really liked some aspects about it, but I found others really annoying.
[21:03:30] <sigma> Lilly: you went to an unusual high school
[21:03:37] <Lilly> sigma: haha :D
[21:03:39] <Ms2ger> Lilly, heh, in high school I got Pascal and JS
[21:03:52] <cmr> my highschool had a c++ class but I never took it
[21:03:57] <cmr> AP CS did java, eugh
[21:04:00] <Lilly> Well, the course we did was microprocessor programming
[21:04:07] <Lilly> and we had this robot that we programmed in Ada
[21:04:19] <cmr> whole year wasted on sorting and basic oop
[21:04:24] <sigma> I got pascal and VBA :( then the only language taught at uni was Java... I swear I learned more from 3 years of redditing...
[21:04:33] *** Quits: MaikKlein (maik@moz-7BAD3439.dip0.t-ipconnect.de) (Ping timeout)
[21:04:33] <Lilly> In the programming course, we did Visual Basic >_>
[21:04:39] *** Quits: jedestep (jedestep@34641662.FB4DE631.66C78B76.IP) (Ping timeout)
[21:04:51] <Lilly> Imagine "learning" VB when you already know C++
[21:04:51] <ecr> I got RealBasic (VB for Mac) and Java in high school :(
[21:05:09] *** Joins: brendan (brendaneic@moz-BBE3ABD.mv.mozilla.com)
[21:05:15] <Lilly> My teacher was like "yeah you already know this stuff" after 2 lessons. :P
[21:05:44] <Lilly> So I just got to do a final assignment, then I was done!
[21:05:47] <kmc> cmr: CS education is strangely obsessed with sorting; I think sorting is really just an example domain for learning big-O notation and such, and doesn't deserve that much time in its own right
[21:06:07] <Lilly> It sucks that I can't go to college right now :/
[21:06:18] <Lilly> The programming course was really interesting
[21:06:24] <ecr> kmc: I think the prevalence of sorting is that it's the simplest example complicated enough to be interesting
[21:06:28] <Lilly> But all the other stuff burnt me out
[21:06:33] <cmr> Sorting *isn't* interesting though
[21:06:39] <cmr> Probably the least interesting problem ever
[21:06:41] *** Joins: jedestep (jedestep@34641662.FB4DE631.66C78B76.IP)
[21:07:01] <Lilly> I think soring is important to understand, to kinda grasp what big-O is all about
[21:07:01] <ecr> cmr: interesting as in 'has multiple solutions with different tradeoffs'
[21:07:05] <Lilly> but it isn't that interesting
[21:07:21] <ecr> cmr: and mostly just interesting as a teaching tool
[21:07:23] <pcwalton> someone will write Scalaz in Rust someday
[21:07:23] <cmr> ecr: ah
[21:07:28] <pcwalton> I am sure of it :)
[21:07:36] <kmc> it does have tradeoffs! especially if you broaden the scope from just comparison-based in-memory sorts
[21:07:42] <kmc> radix sorts and tape sorts :3
[21:07:47] <sigma> yeh, we spent a tremendouse amount of time on tdd and agile development, using databases and a couple of group projects. 1 module on data structures and algorithms, and absoultely nothing on "how modern computers actually take the stuff you write and run it" 
[21:07:48] <ecr> exactly
[21:07:57] *** Quits: jviereck1 (Adium@moz-A034D4DA.dclient.hispeed.ch) (Quit: Leaving.)
[21:08:06] <cmr> sigma: that's a shame
[21:08:14] <sigma> Pointers were never mentioned
[21:08:16] <sigma> not once.
[21:08:34] <kmc> i dunno, "how computers work" is REALLY complicated, and the whole point of all these abstraction layers is that you shouldn't need to know all that right away to get stuff done
[21:08:38] <Lilly> is there a name for this sorting method? while (!vec.is_sorted()) vec.shuffle(); 
[21:08:43] <cmr> The school I'll be attending has a decent CS curriculum
[21:08:43] <kmc> it's good to learn it eventually, of course
[21:08:45] <cmr> Lilly: bogosort
[21:08:55] <jedestep> cmr: where will you be going?
[21:09:00] <Lilly> cmr: aww I wanted to name it retardsort
[21:09:03] <cmr> jedestep: https://www.clarkson.edu/
[21:09:08] <Lilly> or lucksort
[21:09:14] <pcwalton> error: internal compiler error: couldn't enable multi-threaded LLVM
[21:09:16] <sigma> kmc: yeh, but there is a lot of value in having a _rough_ idea what the code you write will actually do, at least one layer of abstraction down
[21:09:16] <pcwalton> uh-oh
[21:09:24] <cmr> pcwalton: a few others have reported that today
[21:09:25] <kmc> i like Quantum Bogosort
[21:09:32] *** Joins: jviereck (Adium@moz-A034D4DA.dclient.hispeed.ch)
[21:09:36] <cmr> COnsidering we don't always *use* mt llvm, you'd think that wouldn't be fatal
[21:09:38] *** Quits: msingle (Thunderbir@moz-930E5D97.hr.hr.cox.net) (Quit: msingle)
[21:09:39] *** Joins: erickt (erickt@8C9ECD8F.3A598286.F12515B4.IP)
[21:09:40] <kmc> vec.shuffle(); if !vec.is_sorted { destroy_universe() }
[21:09:46] <Lilly> How would you even big-O that sorting method?
[21:09:49] <kmc> er should that be universe.destroy(); ;)
[21:09:56] <tjc> Lilly: watch the language, -- see Conduct under https://github.com/mozilla/rust/wiki/Note-development-policy (re: the r-word)
[21:09:58] <kmc> Lilly: expected running time
[21:09:59] <Lilly> O(rand)?
[21:10:06] <jedestep> cmr: not familiar with it but congrats anyway
[21:10:16] <kmc> worst case is unbounded, expected time is O(2^n) i think
[21:10:17] <cmr> Lilly: worst case is infinity
[21:10:32] <Lilly> tjc: noted :)
[21:10:37] <tjc> thanks
[21:11:06] *** Joins: devinus (devinus@moz-B4AF84BC.ptr.us.xo.net)
[21:11:09] <sigma> What was 4chans integer sort called?
[21:11:19] <tjc> the answer probably isn't safe for this channel :-)
[21:11:21] <sigma> the one that spawned a new thread and slept....
[21:11:31] <sigma> possibly not :)
[21:11:34] <tjc> Oh, sleepsort?
[21:11:37] <Lilly> kmc: oh, why O(2^n)?
[21:11:49] <sigma> that 's probably it
[21:11:56] <Lilly> I'm really interested in this stuff, but I feel like I'm cluttering this channel with nonsense :D
[21:12:02] <tjc> that's cleverer than anything I would expect 4chan to come up with :-)
[21:12:04] <cmr> http://rosettacode.org/wiki/Sorting_algorithms/Sleep_sort
[21:12:31] *** Quits: erickt (erickt@8C9ECD8F.3A598286.F12515B4.IP) (Ping timeout)
[21:12:32] <sigma> they probably stole it ofc, but it's the first place I saw it linked
[21:12:38] <ecr> Everyone knows the best sorting algorithm is Quantum Bogosort /s
[21:12:58] <ecr> Ah, I see kmc already mentioned it
[21:13:03] <ecr> oh well :(
[21:13:15] * tjc once blew people's minds by using quicksort in real life when sorting log sheets as part of volunteering at a radio station
[21:13:17] <cmr> http://rosettacode.org/wiki/Sorting_algorithms/Sleep_sort#Rust
[21:13:18] *** Joins: acrichto (acrichto@moz-B63D64BD.res.cmu.edu)
[21:13:20] <cmr> Oi, look at that!
[21:13:26] <tjc> they were amazed that I could sort a pile of papers in 15 minutes instead of 2 hours
[21:13:30] <ecr> tjc: that's brilliant
[21:13:40] <kmc> most real-world sorting you can do radix sort
[21:13:48] <kmc> make piles based on first digit/letter etc.
[21:13:48] <sigma> libraries use a really efficient sorting system
[21:13:54] <tjc> ecr: the guy who was supervising me called someone else over and saidâ€¦ "He said heâ€¦ used aâ€¦ sorting algorithm"
[21:13:55] <kmc> I'm told this is how elementary school teachers usually sort things
[21:13:57] *** Quits: engla (engla@moz-DBD1D96E.cust.bredbandsbolaget.se) (Ping timeout)
[21:14:03] <kmc> so they know more about sorting algorithms than 50% of college CS grads ;)
[21:14:08] <Lilly> I use binary search (which is like the only search method I know haha) IRL
[21:14:11] <cmr> sigma: there was a fastinating blog post about it
[21:14:17] <cmr> Lilly: sort, not search
[21:14:22] <ecr> hard to beat binary search
[21:14:22] *** Quits: vk (chatzilla@3E9D68F2.B1163E0C.2A6693DD.IP) (Ping timeout)
[21:14:29] *** Joins: pyrac (pyrac@moz-8862B13A.w92-162.abo.wanadoo.fr)
[21:14:32] <Ms2ger> http://jorendorff.github.io/hackday/2012/library/
[21:14:41] <cmr> Yup that's the one
[21:14:45] <Lilly> cmr: I meant search
[21:14:48] <cmr> he's a mozillian iirc
[21:15:00] <Ms2ger> He is
[21:15:08] <ecr> the library sorting system is really similar to database sorting
[21:15:10] <Ms2ger> Works on the JS engine mostly
[21:15:28] *** Joins: jgilbert (jgilbert@moz-BBE3ABD.mv.mozilla.com)
[21:16:07] <Lilly> http://jorendorff.github.io/hackday/2012/library/book-cart.jpg hahahaha
[21:17:40] *** Joins: james4k (james@moz-E7990244.consolidated.net)
[21:17:48] <sigma> cmr: yeh, I was just trying to find that
[21:19:07] *** Quits: Azdle (Azdle@moz-B334B496.hfc.comcastbusiness.net) (Ping timeout)
[21:19:14] <Lilly> I wonder if sleepsort could ever be viable
[21:19:25] <Lilly> or wait, it takes time creating all those threads, right?
[21:19:26] <Ms2ger> For books?
[21:19:27] <kmc> sending this to my friend who is both an amateur programmer and an amateur librarian
[21:19:37] <sigma> I can't think of any situation where it would be more efficient than anything else
[21:20:30] <sigma> and if you made the time resolution small enough on the sleep() call you'd end up with threads being woken up in the wrong order by the OS
[21:20:32] <jorendorff> an excellent algorithm for all kinds of things is to sleep until someone else does it
[21:20:57] <jorendorff> Lilly: it's effectively delegating the sorting to the scheduler, which will probably use a heapsort
[21:20:57] *** Quits: jviereck (Adium@moz-A034D4DA.dclient.hispeed.ch) (Quit: Leaving.)
[21:21:11] <Ms2ger> Oh, here we have jorendorff, have you been here all this time?
[21:21:17] <jorendorff> yup
[21:21:20] <cmr> heh
[21:21:34] <sully> no, sleep sort can't ever be viable
[21:21:45] <sully> all you are doing is badly offloading the work of sorting the elements to the kernel
[21:21:58] <sully> the kernel is still sorting the list
[21:22:14] <ecr> and the total running time is going to be at least as long as the max value in the list
[21:22:22] <sully> yes
[21:22:24] <ecr> so if you have 1 billion in your list
[21:22:24] *** Joins: jaen (jaen@moz-E0979827.copit.pl)
[21:22:29] <ecr> you'll be waiting 1 billion seconds
[21:22:32] <ecr> at least
[21:22:35] <Lilly> someone should write a program using all these stupid quirks and methods
[21:22:36] <jedestep> less than ideal
[21:22:37] <sully> and the kernel is still at least doing an n lg n sort, so even if the elements are small...
[21:22:40] <jorendorff> i wonder if there are physical sorting processes that are like sleep
[21:22:43] <sully> there is also forksort, which is hilarious
[21:22:43] <jorendorff> *like sleepsort
[21:22:50] <sully> it's a unix implementation of quantum bogosort
[21:22:56] <jorendorff> oh nice
[21:23:03] <toddaaro> sully: oh wow, I hadn't thought of that
[21:23:03] <ecr> that's amazing
[21:23:08] <toddaaro> I need to make one for rust
[21:23:18] <toddaaro> as soon as the runtime is in good shape
[21:23:23] <Ms2ger> jorendorff, races?
[21:23:26] <sully> also
[21:23:31] <jorendorff> Ms2ger++
[21:23:35] <sully> does anybody have objections to moving default methods out from behind the flag?
[21:23:37] <sigma> so what? it fork bombs and takes down the OS if it fails?
[21:23:57] <ecr> sigma: i'd guess it just spawns a process for each permutation and kills the process if it's not sorted
[21:23:59] *** Quits: Ralith (ralith@moz-50F3C77.vc.shawcable.net) (Ping timeout)
[21:24:08] <Ms2ger> jorendorff, though I'm not sure if I'd use "sleep" in their face
[21:24:08] <cmr> sully: nope, please go ahead
[21:24:09] <ecr> sigma: so the only remaining process will be the sorted one
[21:24:16] <toddaaro> sully: does it need fork throttling on large input?
[21:24:23] <jorendorff> they might kick sand in your face
[21:24:39] <Lilly> What is forksort?
[21:24:52] <sigma> ecr: I was (half) joking :)
[21:24:52] *** Quits: azakai (alon@moz-BBE3ABD.mv.mozilla.com) (Ping timeout)
[21:25:06] <sully> you "randomly" shuffle the array, using !!fork() to generate "random" bits
[21:25:11] *** Quits: cr (anonymous@moz-95C31EA7.dip0.t-ipconnect.de) (Ping timeout)
[21:25:13] <sully> then you check if the array is sorted and exit if it is not
[21:25:32] <Lilly> Haha!
[21:25:44] <sully> note that while this lets you get away with only O(n) comparisons in the surviving process
[21:25:55] <sully> you still need to generate O(n lg n) bits to shuffle the array
[21:26:02] *** Joins: doomlord_ (servitor@moz-13E69BC8.range86-180.btcentralplus.com)
[21:26:10] *** Joins: Jesse (jruderman@moz-537BCF9.hsd1.ca.comcast.net)
[21:26:20] <sigma> better than a worst case quick sort :)
[21:26:23] *** Joins: rajul (quassel@FBE2EC0F.D441D37D.F44414AF.IP)
[21:26:41] *** Quits: Ms2ger (Ms2ger@moz-E9883900.access.telenet.be) (Quit: nn)
[21:27:05] *** dherman is now known as dherman-spec-spec-spec
[21:27:07] <strcat> sigma: a naive quick sort ;p
[21:27:35] <sigma> yeh, it's really __worst__ case
[21:28:50] *** Quits: tjc (tjc@moz-BBE3ABD.mv.mozilla.com) (Quit: zzzzzzzzzz)
[21:29:06] <strcat> sigma: well I mean you can write one with an O(nlogn) worst-case
[21:29:16] <thiez> that is an excellent sorting algorithm if the many-worlds hypothesis holds true
[21:29:25] *** Joins: acrichto_ (acrichto@moz-B63D64BD.res.cmu.edu)
[21:29:29] *** Quits: Sergio965 (sergiobz@moz-BB21156B.dynamic.csail.mit.edu) (Ping timeout)
[21:29:35] <thiez> using quantum randomness, generate a random permutation of the data
[21:29:48] <thiez> if the result is not sorted, destroy the universe.
[21:29:56] <strcat> but I don't know if you give up the good properties by doing the median-of-medians thing
[21:29:56] *** Parts: acrichto_ (acrichto@moz-B63D64BD.res.cmu.edu) ()
[21:29:59] <Lilly> How quickly would a quantum computer be able to sort an array of random numbers?
[21:30:05] <kimundi> Btw, someone update that sleepsort rust example! Needs more iter() and advance() :P
[21:30:39] *** Joins: themgt (themgt@397245C1.77E1C1C5.28199367.IP)
[21:30:39] *** Quits: themgt (themgt@397245C1.77E1C1C5.28199367.IP) (Client exited)
[21:30:39] *** Quits: pyrac (pyrac@moz-8862B13A.w92-162.abo.wanadoo.fr) (Quit: pyrac)
[21:31:01] *** Joins: somebody (Mibbit@moz-7D83A5F1.ip.telfort.nl)
[21:31:47] <cmr> Lilly: http://arxiv.org/abs/quant-ph/0102078
[21:32:28] <Lilly> I don't know if I'd even understand a fractrion of that, but thanks anyways cmr :D
[21:32:37] <kimundi> Lilly: Arcording to wikipedia, a quantum computer can't sort faster than a classical one
[21:32:47] <kimundi> aka, O(n log n)
[21:33:01] <cmr> spaghetti sort is my favorite
[21:33:04] <Lilly> bu-but quantum-
[21:33:07] <kimundi> http://en.wikipedia.org/wiki/Quantum_sort
[21:33:12] <cmr> Lilly: no silver bullet
[21:33:35] *** Joins: reyre (reyre@moz-AFCC727B.wireless.telus.com)
[21:33:56] <sigma> strcat: yeh, I was thinking of hoare's version, he worked at my uni so we got it fairly well drilled in
[21:34:19] <strcat> heh
[21:35:23] *** Quits: somebody (Mibbit@moz-7D83A5F1.ip.telfort.nl) (Quit: http://www.mibbit.com ajax IRC Client)
[21:36:24] *** Quits: ecr (Thunderbir@moz-BBE3ABD.mv.mozilla.com) (Ping timeout)
[21:36:30] <Lilly> cmr: what does that mean?
[21:36:31] *** Quits: jaen (jaen@moz-E0979827.copit.pl) (Connection reset by peer)
[21:37:21] <doomlord_> I've been able to pass rust functions as callbacks to C, but should i be able to make C call statically linked rust functions - i'm trying "pub extern "C" fn some_rusty_function(...) { ...}" and "extern void some_rusty_function(..)" C side.. but i get a linker error; does it qualify the function somehow.. does it generate a C shim or something
[21:37:22] <sigma> lilly: there's no magic solution
[21:37:54] <cmr> doomlord_: rust has no static linking atm
[21:38:25] <doomlord_> oh ok. i dont need it now i guess. passing callbacks into interfaces is ok
[21:38:56] <doomlord_> this means its always going to be a rust main calling C library code i take it
[21:39:17] <cmr> or dynamic linking
[21:39:26] *** Joins: somebody (Mibbit@moz-7D83A5F1.ip.telfort.nl)
[21:39:26] <thiez> for now. Surely we can get static linking at some point?
[21:40:00] *** Joins: Ralith (ralith@moz-71FF9C0.wireless.sfu.ca)
[21:40:20] <doomlord_> i appreciate not everything will work just yet :) enough works to keep me happy
[21:40:25] <somebody> Can somebody explain me the advantage of closures?
[21:40:34] <thiez> somebody: compared to what?
[21:40:46] <somebody> Compared to just calling your function with a parameter
[21:41:02] <doomlord_> they allow behaviour to be composed easily
[21:41:24] *** Quits: spider-mario (spidermari@4C9DC03E.363ACB84.F049C0AD.IP) (Input/output error)
[21:41:37] <kimundi> somebody: It's basically just sugar
[21:41:42] <thiez> it looks less messy
[21:41:57] <doomlord_> dont need to name as many temporaries
[21:42:10] <somebody> So now there are two ways to pass a parameter to your function?
[21:42:26] *** Joins: jensnockert (jensnocker@moz-C5F27039.cust.bredband2.com)
[21:42:33] <sigma> there are 2 ways to pass values around
[21:42:35] <doomlord_> are you talking about closures compared to passing function pointer arguemnts...
[21:42:41] <cmr> somebody: There's a different between the captured environment and arguments passed, but I suppose
[21:42:41] <doomlord_> ... or just compared to "passing arguemnts"
[21:42:52] <cmr> *a difference
[21:42:55] <doomlord_> closures are used in cases that are more versatile than straightforward arguments
[21:43:06] <kimundi> rusti: let x = 5; let f = || println(x.to_str()); f()
[21:43:07] -rusti- more than 5 lines of output, pastebinned: http://sprunge.us/PNQZ
[21:43:12] <thiez> imagine this, we have method that takes a closure, something along the lines of map<T,U>(fn(U)->T)
[21:43:22] <kimundi> rusti: let x = 5u8; let f = || println(x.to_str()); f()
[21:43:23] -rusti- 5
[21:43:23] -rusti- ()
[21:43:30] <cmr> OH! And they're generic
[21:43:36] <doomlord_> eg sort a collection... sort a collection, but using this function to create the sort-key (saves you manually creating another collection of sort keys)
[21:43:40] <thiez> what if we want to map a function that adds some number to the argument
[21:43:45] *** Quits: reyre (reyre@moz-AFCC727B.wireless.telus.com) (Client exited)
[21:44:12] <doomlord_> high order functions are very elegant ways of re-using and composing code
[21:44:25] <cmr> yeah but even C has HOF
[21:44:28] <doomlord_> and closures (compared to passing function pointers) makes them much more convinient to use
[21:44:51] <doomlord_> ... as you dont need to name temporaries, and you can write the little ad hoc functions to pass "in-place"
[21:45:05] *** Joins: somebody2 (Mibbit@moz-7D83A5F1.ip.telfort.nl)
[21:45:14] <thiez> you know, never mind my explanation, looks like you've got this :p
[21:45:15] *** tikue is now known as lunch
[21:45:22] *** lunch is now known as tikue_lunch
[21:45:46] <thiez> I almost ate tikue.
[21:46:34] *** Joins: infynyxx (infynyxx@DB780A29.749BA1D.DCC373F0.IP)
[21:46:56] <kimundi> rusti: trait Closure { fn run(&self); }  let x = 5u8; struct Env{ x: &u8 } impl Closure for Env { fn run(&self) { println(self.x.to_str()) }  } let f = Env{ x: &x } ; f.run()
[21:46:57] -rusti- more than 5 lines of output, pastebinned: http://sprunge.us/QDQi
[21:46:58] *** Quits: maxli (maxli@F2D29657.F60B0462.67AC9B1.IP) (Quit: Leaving.)
[21:47:22] <kimundi> rusti: trait Closure { fn run(&self); }  let x = 5u8; struct Env<'self>{ x: &'selfu8 } impl Closure for Env { fn run(&self) { println(self.x.to_str()) }  } let f = Env{ x: &x } ; f.run()
[21:47:24] -rusti- line longer than 150 columns, pastebinned: http://sprunge.us/Gifc
[21:47:38] <kimundi> rusti: trait Closure { fn run(&self); }  let x = 5u8; struct Env<'self>{ x: &'self u8 } impl Closure for Env { fn run(&self) { println(self.x.to_str()) }  } let f = Env{ x: &x } ; f.run()
[21:47:39] -rusti- line longer than 150 columns, pastebinned: http://sprunge.us/MgBj
[21:47:52] <kimundi> gnar
[21:48:14] <kimundi> rusti: trait Closure { fn run(&self); }  let x = 5u8; struct Env<'self>{ x: &'self u8 } impl <'self> Closure for Env<'self> { fn run(&self) { println(self.x.to_str()) }  } let f = Env{ x: &x } ; f.run()
[21:48:15] -rusti- 5
[21:48:15] -rusti- ()
[21:48:16] *** Quits: somebody (Mibbit@moz-7D83A5F1.ip.telfort.nl) (Quit: http://www.mibbit.com ajax IRC Client)
[21:48:30] <somebody2> For example, take the first example in the tutorial, I can't see how closures would be better than just passing an argument: http://static.rust-lang.org/doc/0.7/tutorial.html#closures
[21:49:00] *** Quits: heftig (heftig@moz-6010B075.dip0.t-ipconnect.de) (Ping timeout)
[21:49:15] <cmr> somebody2: do you understand what a higher order function is?
[21:49:26] <somebody2> No tbh
[21:49:28] <cmr> somebody2: also, most of the examples in the tutorial are trivial, just for example.
[21:49:29] <doomlord_> somebody2, look at the example with 'map' 
[21:49:41] <cmr> somebody2: ok, so that's the biggest hurdle, closures can come after
[21:49:42] * cmr dinner
[21:50:20] <somebody2> doomlord_: allright
[21:50:36] <doomlord_> high order functions save you having to write loops manually , and save you having to re-write patterns like summing things to an accumulator ("fold"/"reduce")
[21:50:37] *** Joins: mib_jbeinl (Mibbit@DD879280.AE38D055.CE4714E5.IP)
[21:50:47] *** Joins: FrozenCow (FrozenCow@moz-B2DF4929.chello.nl)
[21:51:07] <Lilly> sigma: (delayed) thanks :)
[21:51:13] *** Quits: Jesse (jruderman@moz-537BCF9.hsd1.ca.comcast.net) (Quit: Jesse)
[21:51:28] <Lilly> I guess there is no easy way to explain quantum computing :D
[21:51:30] <doomlord_> the common ones are map (transform a collection using a given function) , filter (select items from a collection given some criterea in a function) and reduce aka "fold" .. accumulate from a collection (eg sum all the squares from an array of numbers..)
[21:52:22] <somebody2> So closures act like little functions, and that's why they are more useful than passing in a function pointer and passing in the said pointer?
[21:52:37] <somebody2> and writing the said function****
[21:52:44] <doomlord_> yes, "little functions", so small you can write them inplace instead of seperately and having to name them
[21:53:03] <doomlord_> sometimes just a few statements
[21:53:20] <Lilly> I like calling them "anonymous functions" because they are kinda like "sloppy" unnamed small functions
[21:53:24] <doomlord_> rust provides the do sugar for making HOF's look like language constructs, which is great
[21:53:39] <somebody2> Ha, but the first example is a bit misleading, as closures are not really a function
[21:54:00] <doomlord_> closure = function plus some data carried into it
[21:54:05] <doomlord_> (i think ?? :) )
[21:54:10] *** Quits: saml (sam@moz-14C16814.cst.lightpath.net) (Quit: Leaving)
[21:54:15] <somebody2> Thanks for your time, it helped :)
[21:54:19] *** Quits: mib_jbeinl (Mibbit@DD879280.AE38D055.CE4714E5.IP) (Quit: http://www.mibbit.com ajax IRC Client)
[21:54:32] <doomlord_> part of the added convinience of closures is that - you can pass data in aswell, eg locals from the surrounding context
[21:54:54] <sigma> the moment I realised functions could be passed around like anything else was the moment Java started feeling really clunky... I remember it distinctly
[21:54:57] <Lilly> are C++ lambda functions closures too?
[21:55:07] <doomlord_> yes
[21:55:25] *** Joins: reyre (reyre@moz-9002CDDA.cpe.net.cable.rogers.com)
[21:55:26] <Lilly> Because C++ lambda functions are "as good as" function pointers, right?
[21:55:55] <strcat> they can be used anywhere you would use a function pointer, but they can capture state
[21:55:56] <doomlord_> better, because they can carry data, they're like what C++ calls functors
[21:56:04] <strcat> but they can't be used *as* function pointers
[21:56:06] <Lilly> oh right
[21:56:11] *** Joins: reyre_ (reyre@moz-9002CDDA.cpe.net.cable.rogers.com)
[21:56:13] <doomlord_> function-objects..
[21:56:28] <Lilly> yeah, they can catch stuff by reference and stuff
[21:56:45] <doomlord_> from my little time in #haskell i have learned to say "what C++ calls functors" instead of "functors"
[21:57:07] <Lilly> My programming vocabulary is 50% "stuff" :P
[21:57:19] <strcat> doomlord_: or just say closure
[21:57:30] <somebody2> Lilly: I agree
[21:57:31] *** Quits: reyre (reyre@moz-9002CDDA.cpe.net.cable.rogers.com) (Ping timeout)
[21:57:31] <kmc> yeah, C++11 lambda expressions can close by value or by reference
[21:57:48] <doomlord_> ok
[21:57:48] <Lilly> Can rust do that, by the way?
[21:58:03] *** Quits: Ralith (ralith@moz-71FF9C0.wireless.sfu.ca) (Ping timeout)
[21:58:18] <kmc> and you can upcast them to std::function<whatever> which lets you pass them to other (even separately compiled) code
[21:58:20] <Lilly> catch by either value or reference, I mean
[21:58:39] *** Joins: Ralith (ralith@moz-71FF9C0.wireless.sfu.ca)
[21:58:41] <kmc> "catch" makes me think of exceptions, "capture" is the usual term for closures
[21:58:47] <strcat> Lilly: rust doesn't have by-reference at all, it deals with references as values
[21:59:00] <Lilly> oh, thanks! :)
[21:59:01] <strcat> and yes, you can capture a borrowed pointer
[21:59:06] <somebody2> Is libuv included in the rust standard library?
[21:59:51] *** Joins: heftig (heftig@moz-3958C10A.dip0.t-ipconnect.de)
[22:00:40] *** reyre_ is now known as reyre
[22:00:43] <pcwalton> somebody2: yes, basically
[22:00:50] <Lilly> I've learned more about programming in general by being here for a few hours, than I've learned overa  few months. thanks everyone so much
[22:01:02] <pcwalton> no problem, glad to hear :)
[22:01:22] <Lilly> You are all my programming idols, haha! x)
[22:02:21] *** Quits: eatkinson (eatkinson@moz-BBE3ABD.mv.mozilla.com) (Quit: eatkinson)
[22:02:41] <somebody2> pcwalton: Cool :)
[22:03:02] <kmc> Lilly: yay
[22:03:11] <kmc> #haskell on FreeNode is also good for that
[22:03:35] <kmc> it's a huge busy channel though, things are a bit less chaotic here :)
[22:03:45] <pcwalton> error: internal compiler error: couldn't enable multi-threaded LLVM
[22:03:46] <pcwalton> still
[22:05:11] <sigma> kmc: the technical discussions on #Haskell are completely impenetrable to me, I understand roughly what's being said in here, even if I still can't contribute much
[22:05:52] <sigma> but it's still hugely interesting when you do suddenly understand something new
[22:06:37] *** Quits: Ralith (ralith@moz-71FF9C0.wireless.sfu.ca) (Ping timeout)
[22:06:54] *** tikue_lunch is now known as tikue_actually_at_lunch
[22:07:49] <somebody2> sigma: that's the reason why I program in the first place, the satisfaction you get when you finally really understand something
[22:08:09] *** Joins: cr (anonymous@moz-57073FC6.dip0.t-ipconnect.de)
[22:08:17] *** Quits: jorendorff (jorendorff@moz-1747FB68.hsd1.tn.comcast.net) (Ping timeout)
[22:09:02] *** Joins: eatkinson (eatkinson@moz-BBE3ABD.mv.mozilla.com)
[22:09:08] <bjz> somebody2: it's addictive
[22:09:31] <somebody2> bjz: exactly
[22:09:51] *** Joins: Ralith (ralith@moz-71FF9C0.wireless.sfu.ca)
[22:11:00] *** Joins: ronny (ronnypfa@moz-E7EE6ABE.uberspace.de)
[22:11:04] <ronny> hi
[22:11:07] *** Joins: erickt (erickt@8C9ECD8F.3A598286.F12515B4.IP)
[22:11:07] *** Joins: MaikKlein (maik@moz-7BAD3439.dip0.t-ipconnect.de)
[22:11:24] <ronny> im updating some old code of mine, and i noticed that use std::json doesnt work anymore
[22:11:33] <pcwalton> ronny: it's extra::json
[22:11:45] *** Quits: Ralith (ralith@moz-71FF9C0.wireless.sfu.ca) (Ping timeout)
[22:12:09] <ronny> thanks
[22:12:43] <ronny> next item is io.println, and undelcared module io evne tho i have use std::io
[22:13:09] <pcwalton> you don't need io::println, it's just println
[22:13:37] <ronny> ok, got that
[22:13:39] <ronny> hmm
[22:13:55] *** Quits: erickt (erickt@8C9ECD8F.3A598286.F12515B4.IP) (Ping timeout)
[22:14:05] <ronny> almost done, now all i got left is a spawn |y copy| {...}
[22:14:26] *** Joins: Ralith (ralith@moz-71FF9C0.wireless.sfu.ca)
[22:15:25] *** Quits: MaikKlein (maik@moz-7BAD3439.dip0.t-ipconnect.de) (Ping timeout)
[22:16:18] *** Quits: rajul (quassel@FBE2EC0F.D441D37D.F44414AF.IP) (Connection reset by peer)
[22:16:59] *** Joins: Guest_ (textual@34641662.FB4DE631.66C78B76.IP)
[22:17:06] <sully> hey, just put up a PR fixing a bunch of default method stuff
[22:17:07] <sully> https://github.com/mozilla/rust/pull/7725
[22:17:12] <sully> and doing a bunch of other cleanup
[22:17:15] <sully> can anyone take a look?
[22:17:25] *** tikue_actually_at_lunch is now known as tikue
[22:18:21] *** Joins: Jesse (jruderman@moz-BBE3ABD.mv.mozilla.com)
[22:18:30] <kimundi> ronny: just reomve the 'copy y': spawn |y copy| {...} -> spawn || {...} -> spawn {...}
[22:18:43] <ronny> kimundi: thx
[22:18:54] <ronny> hmm, oh, the each method for vectors is gone?
[22:19:09] <kimundi> jup, we'r doing external iterators now
[22:19:53] <kimundi> replace .each |...| {...} with .iter().advance |...| {...}
[22:20:32] *** Joins: aatch (aatch@moz-B437F499.pocketrent.com)
[22:20:38] *** Quits: Guest_ (textual@34641662.FB4DE631.66C78B76.IP) (Quit: Textual IRC Client: www.textualapp.com)
[22:21:04] *** Quits: bnicholson (bnicholson@moz-BBE3ABD.mv.mozilla.com) (Quit: Ex-Chat)
[22:21:51] *** Quits: bent (chatzilla@F2D29657.F60B0462.67AC9B1.IP) (Quit: ChatZilla 0.9.90-rdmsoft [XULRunner 18.0.2/20130201065344])
[22:22:25] *** Quits: Ralith (ralith@moz-71FF9C0.wireless.sfu.ca) (Ping timeout)
[22:22:39] <somebody2> Where can I find documentation for say, vectors?
[22:22:39] *** Joins: ghrust (ghrust@79968228.6A2AE50.F3114085.IP)
[22:22:39] <ghrust> 01[13rust01] 15bors merged 06auto into 06master: 02http://git.io/LumjZg
[22:22:39] *** Parts: ghrust (ghrust@79968228.6A2AE50.F3114085.IP) ()
[22:22:48] *** Quits: jedestep (jedestep@34641662.FB4DE631.66C78B76.IP) (Ping timeout)
[22:23:01] <cmr> somebody2: http://static.rust-lang.org/doc/std/index.html is the generated docs, but they're hardly cohesive or complete
[22:23:08] <cmr> best is to ask questions here, tbh
[22:23:42] <ronny> hmm
[22:23:49] *** Joins: _Vi (vi@527C345F.497AA854.B16B3BE6.IP)
[22:24:03] *** Quits: infynyxx (infynyxx@DB780A29.749BA1D.DCC373F0.IP) (Client exited)
[22:24:14] <ronny> ok, i got a [~X] and do a .iter().advance, now i want to spawn something with each value
[22:24:14] <somebody2> So no real reference?
[22:24:22] <ronny> however i cant send or dereference
[22:24:41] <cmr> ronny: clone
[22:24:54] <kimundi> somebody2: Best reference at the moment is opening the github page and reading the code :P
[22:24:55] <aatch> ronny, you can do iter_consume() (I think) to move out of the vector
[22:25:11] <somebody2> kimundi, allright fair enough :)
[22:25:15] <_Vi> Trying to build Rust e95fcfafc7a2349217096bc1ed8b8c273b6a0e2b . Seeing "error: internal compiler error: unexpected failure"...
[22:25:17] <aatch> ronny, that will make the vector unusable after though
[22:25:30] <aatch> ronny, (Might be consume_iter)
[22:25:33] *** Joins: SiegeLord (sl@moz-CAF07B4C.hsd1.ma.comcast.net)
[22:25:33] *** Joins: infynyxx (infynyxx@DB780A29.749BA1D.DCC373F0.IP)
[22:25:37] *** Joins: ghrust (ghrust@9C8B94D4.6A2AE50.F3114085.IP)
[22:25:37] <ghrust> 01[13rust01] 15bors pushed 0 new commits to 06auto: 02http://git.io/HXQSIQ
[22:25:37] *** Parts: ghrust (ghrust@9C8B94D4.6A2AE50.F3114085.IP) ()
[22:25:38] *** Joins: ghrust (ghrust@CFE85B59.6A2AE50.F3114085.IP)
[22:25:38] <ghrust> 01[13rust01] 15bors pushed 9 new commits to 06auto: 02http://git.io/qpEP7A
[22:25:38] <ghrust> 13rust/06auto 14a89af1f 15Alex Crichton: Use purely an owned vector for storing TLS data
[22:25:38] <ghrust> 13rust/06auto 14692a22e 15Alex Crichton: Change the elements in the task-local map to be actual key-value pairs
[22:25:39] <ghrust> 13rust/06auto 145c3a2e7 15Alex Crichton: Change TLS to almost be able to contain owned types
[22:25:41] *** Parts: ghrust (ghrust@CFE85B59.6A2AE50.F3114085.IP) ()
[22:25:52] <cmr> _Vi: I don't see that commit in the tree?
[22:25:53] <_Vi> Is it because of rustc running out of memory?
[22:26:02] <cmr> _Vi: it could be OOM, how much memory do you have?
[22:26:16] <_Vi> e95fcfafc7a2349217096bc1ed8b8c273b6a0e2b auto merge of #7632 : gavinb/rust/7484_manpages, r=cmr
[22:26:18] <cmr> recent master need 1.6GiB
[22:26:28] <cmr> oh fetched from the wrong remote, my bad
[22:26:37] *** Quits: lmandel (lmandel@F2D29657.F60B0462.67AC9B1.IP) (Quit: lmandel)
[22:26:46] <aatch> It's unlikely to be OOM if you're seeing an ICE
[22:26:46] * pcwalton really wants the backout to land of that one mem regression patch
[22:26:47] <kimundi> rusti: let v = ~[~"a", ~"b", ~"c", ~"d"]; for v.iter_consume().advance |val| { println(val); }
[22:26:48] -rusti- <anon>:7:48: 7:65 error: type `~[~str]` does not implement any method in scope named `iter_consume`
[22:26:48] -rusti- <anon>:7          let v = ~[~"a", ~"b", ~"c", ~"d"]; for v.iter_consume().advance |val| { println(val); }
[22:26:48] -rusti-                                                          ^~~~~~~~~~~~~~~~~
[22:26:48] -rusti- error: aborting due to previous error
[22:26:49] -rusti- application terminated with error code 101
[22:26:58] <cmr> aatch: it happens if the linker gets killed
[22:27:04] *** Joins: barosl (barosl@E287D94F.C81E10FB.7544CABF.IP)
[22:27:07] <aatch> cmr, oh, ok
[22:27:22] <_Vi> Is there a hard limit of virtual memory which Rust build shall never exceed?
[22:27:23] <toddaaro> aatch: are you still working on that workstealing dequeue implementation?
[22:27:26] <aatch> pcwalton, if you can figure out what the hell is going on on the windows build.
[22:27:28] <graydon> someone want to re-re-re r+ this? https://github.com/mozilla/rust/pull/7623 it should be ready to land now
[22:27:28] <cmr> _Vi: no
[22:27:43] <aatch> toddaaro, not really, no.
[22:27:56] <cmr> graydon: no tests?
[22:27:59] <pcwalton> graydon: done
[22:28:18] <ronny> oh, println is not atomic?
[22:28:23] <toddaaro> aatch: ok, I guess I'll start working on one this month then
[22:28:33] <toddaaro> aatch: your code is in a gist I've seen before I think?
[22:28:36] <cmr> roo: it... should be, for <pagesize strings?
[22:28:39] <cmr> Erm, @ronny
[22:28:53] <aatch> toddaaro, not sure, I'm pretty sure I have a branch with it in though.
[22:28:53] <kimundi> rusti: let v = ~[~"a", ~"b", ~"c", ~"d"]; for v.consume_iter().advance |val| { print(val); } // <ronny
[22:28:54] -rusti- abcd()
[22:29:00] <sully> pcwalton: ok, so, should I push a change for the comment wording suggestion you had, and then you can r+ again?
[22:29:00] <graydon> cmr: I'm not really sure what tests I'd put in there. um. I guess I can add a few.
[22:29:06] <pcwalton> sully: sure
[22:29:09] <toddaaro> aatch: ok, when I start on it I'll bug you if I can't find it
[22:29:20] <ronny> hmm
[22:29:34] <kimundi> ronny: I think println is implmented as print(msg); print("\n");
[22:29:35] <pcwalton> 50 conflicting files in my rebase :(
[22:29:43] <cmr> Oh yeah, it does print the newline separately
[22:29:46] <cmr> my bad, forgot about that
[22:29:56] <_Vi> cmr, Maybe "not enough memory" should be an explicit error, not "internal error, report a bug"?
[22:30:14] <aatch> _Vi, problem is we don't know that's it's out of memory
[22:30:14] <cmr> _Vi: not really anything we can do, OOM killer does as it pleases.
[22:30:14] <ronny> kimundi: i already finished it with clone, i dont want to consume the data
[22:30:21] <ronny> still thanks
[22:30:23] <ronny> hmm
[22:30:45] <aatch> It's like saying: "Error, computer on fire"
[22:31:13] <sully> pcwalton: ok, updated
[22:31:51] <pcwalton> sully: done
[22:31:57] <sully> awesome, thanks
[22:32:00] <kimundi> Hm, rust needs a HCF intrinsic ;)
[22:32:07] <aatch> HCF?
[22:32:15] <kimundi> http://en.wikipedia.org/wiki/Halt_and_Catch_Fire
[22:32:20] <aatch> heh
[22:32:43] *** Quits: _Vi (vi@527C345F.497AA854.B16B3BE6.IP) (Ping timeout)
[22:32:51] <aatch> 'The expression "catch fire" is intended as a joke; the CPU does not catch fire.' <- no shit
[22:32:54] <kmc>  Linux did have "lp0: printer on fire"
[22:32:55] *** Joins: _Vi (vi@527C345F.497AA854.B16B3BE6.IP)
[22:32:57] <aatch> Bloody wikipedia
[22:33:27] <Lilly> I'm installing the haskell platform, but the installer is stuck on "Target was prepended to PATH"... I wonder what has gone wrong now.
[22:33:29] <strcat> kmc: doesn't it still have that?
[22:34:11] <strcat> kmc: https://github.com/torvalds/linux/blob/v3.9/drivers/char/lp.c#L254
[22:34:18] <sigma> Lilly: time to test out the helpfulness of #haskell vs #rust
[22:34:22] <kmc> nice
[22:34:27] <_Vi> How much of compilation (of Rust) is to be repeated if I interrupt it with Ctrl+C and re-start "make"? I see the same warnings as before Ctrl+C...
[22:34:30] <Lilly> sigma: I guess :P
[22:34:48] <aatch> _Vi, the crate that it was in the middle of compiling.
[22:35:15] *** Quits: scanlonman (scanlonman@moz-169BC238.hsd1.wa.comcast.net) (Quit: My MacBook has gone to sleep. ZZZzzzâ€¦)
[22:35:31] <_Vi> Doesn't it do it like C (generating *.o files, then putting them together)? Or it is configurable?
[22:35:36] *** Joins: engla (engla@moz-DBD1D96E.cust.bredbandsbolaget.se)
[22:35:36] <cmr> _Vi: it does not
[22:35:43] <cmr> _Vi: we have a different compilation model
[22:36:02] <cmr> https://github.com/mozilla/rust/issues/2369
[22:36:29] <_Vi> Is there (or will there be) some special mode for quick compilation at expense of the running speed? Like interpreted mode...
[22:36:29] <aatch> We have "crates" as our unit of compilation (as opposed to object files in C/C++)
[22:36:44] <cmr> _Vi: we have -Z jit
[22:37:52] <sully> oh, argh
[22:38:02] <sully> there is a test screwup in my PR
[22:38:03] <_Vi> Is issues/2369 going to be blocker for Rust v1.0?
[22:38:28] <cmr> Maybe
[22:38:31] <_Vi> (i.e. will it appear in Rust or "someday later"?)
[22:38:43] <aatch> _Vi, unlikely a blocker for 1.0
[22:39:06] <somebody2> When does 1.0 come out?
[22:39:11] <pcwalton> when it's done
[22:39:12] <_Vi> So that tooling/IDEs will be designed around "slow crate compilation" in mind...
[22:39:20] <somebody2> lol
[22:39:56] <aatch> _Vi, the thing is that Rust code can be parsed very, very quickly
[22:40:16] <aatch> due to it's low syntactic complexity
[22:40:30] <_Vi> aatch, Seems like the main slowness is not in parsing the code.
[22:40:34] <cmr> also doing --no-trans is fast too
[22:40:38] <cmr> or whatever it is
[22:40:41] *** Joins: ecr (Thunderbir@moz-BBE3ABD.mv.mozilla.com)
[22:40:47] <aatch> _Vi, it's generating/optimizing the machine code
[22:40:54] <cmr> codegen and optimizatoin is easily 80% of a non-trivial crate's compilation
[22:40:56] <aatch> takes easily 80% of the time.
[22:41:17] *** Joins: dbaupp (Thunderbir@moz-712A1135.lns20.syd6.internode.on.net)
[22:42:35] <pcwalton> I like the new vim highlighting
[22:42:44] <cmr> ChrisMorgan: you have a fan!
[22:43:45] *** Joins: MaikKlein (maik@moz-7BAD3439.dip0.t-ipconnect.de)
[22:44:34] <_Vi> Will a thing like github.com/pcwalton/zero.rs be official?
[22:44:40] <pcwalton> _Vi: I hope so yes
[22:44:51] <pcwalton> we should probably throw that into the main repo.
[22:45:00] <cmr> Also in the test suite
[22:45:05] <pcwalton> yeah
[22:46:12] <sully> ok, argh, how I do I remove the r+ from my PR
[22:46:19] <aatch> sully, you can't.
[22:46:21] <sully> there is a test failure that I think I somehow reintroduced while rebasing
[22:46:26] <aatch> sully, closing it works though
[22:46:28] <strcat> sully: just delete the comment
[22:46:37] <strcat> aatch: you can remove them from your own PR
[22:46:45] <aatch> Oh right, stupid Github
[22:46:56] <sully> I don't seem to able to delete it?
[22:46:57] <strcat> you own the repo your commits are in so you can edit comments or delete them
[22:47:03] *** Joins: krdln (Mibbit@moz-6F8A8560.dynamic.chello.pl)
[22:47:04] <strcat> sully: might have to go to it from a different page
[22:47:09] <strcat> try going to the commit from your repo
[22:47:19] <strcat> and the comment should be there and editable/deletable
[22:47:35] <_Vi> Which parts of the Rust source code can serve as "exemplary, classic, idiomatic Rust code"?
[22:48:14] <sigma> strcat: does that mean someone could edit a comment like "not ready yet" into something that would make bors accept it?
[22:48:23] <sully> yes
[22:48:26] <sully> it is a problem
[22:48:26] <aatch> _Vi, um... probably none of it.
[22:48:26] <strcat> sigma: yes, it does
[22:48:29] <sigma> that seems like a silly thing for github to allow -.-
[22:48:42] <aatch> _Vi, Oh, some of the stuff in libstd is good
[22:48:54] <strcat> sigma: you can edit any bugs, comments, etc. on your repo, it's weird
[22:48:55] <aatch> _Vi (Sorry, confused Rust and rustc)
[22:48:56] *** Quits: jdm (jdm@F2D29657.F60B0462.67AC9B1.IP) (Ping timeout)
[22:48:59] <MaikKlein> do you think it is a good idea to write getters in traits? I did this so that I can implement default methods like" trait Foo{ fn get_int() -> int; fn foo_times(&self)-> int { self.get_int()}}"
[22:49:02] *** Joins: dimension (dimension@moz-4CCD79C5.dsl.dynamic.simnet.is)
[22:49:15] <strcat> but anyway, you can make a commit in someone's name with their email and github will attribute it to them - there's no security anywhere ;p
[22:49:18] <_Vi> aatch, So when Rust policy updated, the code in libstd also get updated, is it?
[22:49:45] <aatch> _Vi, no, it's just that libstd has been getting a lot of love recently
[22:50:05] <xenocons> http://lwn.net/Articles/557073/ if you haveen't already seen
[22:50:11] <strcat> _Vi: the terminfo parser in libextra is an example of recently written, good code
[22:50:28] <strcat> and deriving
[22:50:30] <strcat> std::iterator
[22:50:46] *** Joins: vk (vk@B7B36E66.870F2FA5.2370DFC3.IP)
[22:51:02] <sigma> xenocons: it's been seen, and had clarification posted pretty much everywhere :)
[22:51:05] <_Vi> xenocons, My browser have it already opened (scrolled to about 50%), as well as mail.mozilla.org/pipermail/rust-dev/2013-June/004599.html for accompany.
[22:51:20] <xenocons> let me see
[22:51:22] * roo keeps finding sigils in his haskell code :@
[22:51:30] <xenocons> sigma: i haven't got to the bototm of it yet
[22:51:40] <sully> pcwalton: I just pushed a new update, fixing a bug that I reintroduced while cleaning things up
[22:51:48] <sully> pcwalton: the change is moving argument checking to the bottom of type_use
[22:51:57] <pcwalton> ok
[22:52:00] <strcat> xenocons: yeah, they wrote an article about rust's iteration right before it's going to be replaced :)
[22:52:05] <somebody2> How does vector.iter().advance work? It only works if I call it using a for and a closure
[22:52:15] <pcwalton> it's still basically valid though
[22:52:23] <pcwalton> in that Rust doesn't use C-style for loops like Go does
[22:52:40] <MaikKlein> hm I just realized that I never used ~ or @ before.....
[22:52:45] <sigma> xenocons: http://www.reddit.com/r/rust/comments/1i2y9e/philosophy_and_for_loops_more_from_go_and_rust/ contains some comments clarifying the current state of things
[22:52:49] <_Vi> BTW (not been following Rust for a while) are there already algorithmic (or procedural?) macros for users (not inside compiler) already or not yet?
[22:52:52] <aatch> MaikKlein, good
[22:52:58] <pcwalton> _Vi: not yet
[22:53:10] <_Vi> pcwalton, In v1.0 stably?
[22:53:15] <pcwalton> possibly
[22:53:22] <xenocons> sigma: ty
[22:53:42] <MaikKlein> when do I even use ~ when I always have to option to move memory around?
[22:54:06] <_Vi> pcwalton, Means shall I consider the Rust macros a sure, ultimate way to avoid repeating some code or I'll need to resort to source code generation from time to time?
[22:54:12] <roo> when you have to allocate it somewhere :P
[22:54:18] <pcwalton> we use source code generation in servo
[22:54:26] <pcwalton> not ideal but we only have so much manpower
[22:54:42] <xenocons> not sure i really understand his choices of languages to make examples of though
[22:54:57] <olsonjeffery> that lwn article seems to come from the Dept. Of Missing The Point
[22:55:11] <cmr> olsonjeffery: which point?
[22:55:11] <xenocons> eh
[22:55:25] <xenocons> thats my department, i didn't authorise this
[22:55:38] <cmr> heh
[22:55:45] <MaikKlein> i mean ~ is on the exchange heap, ok. but when do I need to use ~ over a stack variable?
[22:55:48] *** Joins: ghrust (ghrust@DE823A67.6A2AE50.F3114085.IP)
[22:55:48] <ghrust> 01[13rust01] 15bors 04force-pushed 06auto from 149e510dd to 14f92b75a: 02http://git.io/N3iJvQ
[22:55:48] *** Parts: ghrust (ghrust@DE823A67.6A2AE50.F3114085.IP) ()
[22:55:48] <_Vi> If there will be user-accessible procedural macros, will it be always considered a hack or there will be official use cases where it is the best way and users will be expected to really use it (when actually needed)?
[22:55:49] *** Joins: ghrust (ghrust@DE823A67.6A2AE50.F3114085.IP)
[22:55:49] <ghrust> 01[13rust01] 15bors pushed 8 new commits to 06auto: 02http://git.io/-dqZNQ
[22:55:49] <ghrust> 13rust/06auto 14e14cd39 15Graydon Hoare: initial sketch of codegen mode for compiletest; doesn't measure / compare / ratchet the disassembly yet
[22:55:49] <ghrust> 13rust/06auto 14fbc5bb4 15Graydon Hoare: wire up makefile to run codegen tests and add one to start
[22:55:49] <ghrust> 13rust/06auto 149e67bc3 15Graydon Hoare: extra: simplify the bench stat loop, improve stability somewhat (?)
[22:55:51] *** Parts: ghrust (ghrust@DE823A67.6A2AE50.F3114085.IP) ()
[22:56:03] <cmr> _Vi: the second
[22:56:09] *** Joins: Ralith (ralith@moz-50F3C77.vc.shawcable.net)
[22:56:29] <aatch> MaikKlein, large structs that you don't want pass around by value.
[22:56:52] <aatch> (And can't pass around as `&`)
[22:57:12] *** Joins: kyle2000 (kyle2000@6EDB4D7A.341FCD98.3031298E.IP)
[22:57:32] <kyle2000> hey buddies. anyone know how the new io work is going? what's its status?
[22:57:56] <MaikKlein> aatch, hm what would be an example of a large struct that I can't pass around via &?
[22:58:12] <olsonjeffery> cmr: my takeaway from that article was a boiling down of the difference between go and rust's approach to control structures, to a sort of philosophical one-way vs many-ways argument (they obliquely reference python vs perl)
[22:58:26] <cmr> olsonjeffery: rust only has one way though?
[22:58:36] <aatch> MaikKlein, oh, I mean if you need to, say, pass it by value in order to avoid copying.
[22:59:01] <aatch> (Like some sort of destructive conversion)
[22:59:20] <aatch> It's not too common, hence why you've been able to avoid it.
[22:59:30] <olsonjeffery> cmr: well, yeah. that's another issue (that it's outdated)
[22:59:36] <olsonjeffery> look. perl and rust in the same sentence = WRONG
[22:59:55] <kyle2000> perl is a rusty language. it is covered in rust from days gone by.
[22:59:59] <olsonjeffery> Go and Python? Sure, why not.
[23:00:01] <_Vi> How that "procedural macros" officially called? Searching "procedural macros" in Github issues lead to no results.
[23:00:12] <aatch> _Vi, syntax extensions
[23:00:14] <xenocons> i like parrot in perl, i think it had potential
[23:00:23] <xenocons> still think perl is a force to be reckoned with
[23:00:41] <xenocons> (after seeing a talk about quantum computing in perl)
[23:00:44] *** Quits: devinus (devinus@moz-B4AF84BC.ptr.us.xo.net) (Quit: Textual IRC Client: www.textualapp.com)
[23:00:58] <strcat> olsonjeffery: go has 4 ways to loop - infinite loops, loops with a condition, 3 expression for loops, range for loops (for the built-in containers, not extensible)
[23:01:24] <cmr> Oh, I suppose we have infinite loops and iteration, that does make two
[23:01:29] <strcat> rust has infinite loops (loop), loops with a condition (while), and will have external iterators with 'for'
[23:01:31] <bstrie> _Vi: oh good, you made your way to the real channel :)
[23:01:37] <cmr> oh right, while
[23:01:37] <MaikKlein> we also have range for loops
[23:01:42] <engla> xenocons: haha, Perl6 and quantum computing are both uncertain if they will ever be realized
[23:01:49] * xenocons rubs hands at promise of external iterators
[23:01:54] <MaikKlein> I guess
[23:01:54] <strcat> MaikKlein: there will only be external iterators with 'for'
[23:02:02] <xenocons> engla: regardless, talk was really great
[23:02:07] <strcat> xenocons: well they exist, just not supported by 'for' yet
[23:02:12] <xenocons> yeah
[23:02:23] <xenocons> each().advance currently right
[23:02:26] <strcat> DoubleEndedIterator just landed too, we have ranges like D
[23:02:30] <cmr> .iter().advance
[23:02:34] * olsonjeffery decides to just ignore the lwn article and move on.
[23:02:36] <xenocons> ah my bad
[23:02:38] *** Quits: kyle2000 (kyle2000@6EDB4D7A.341FCD98.3031298E.IP) (Quit: Leaving)
[23:02:41] <strcat> no generic random access trait yet though.
[23:02:46] <strcat> that's trickier
[23:02:53] <MaikKlein> isn't this a ranged based forloop for int::range(0,10) ?
[23:03:01] <pcwalton> well, slices cover most of the use case for that in D
[23:03:14] <strcat> MaikKlein: that's the old internal iterator 'for'
[23:03:22] <strcat> range(start, end, step) can be an external iterator
[23:03:22] <MaikKlein> strcat, oh ok
[23:03:59] <xenocons> i havent looked at D, mostly because PLT people i know dislike it, but i hear lots of mention of it around rust dev stuff
[23:04:03] <graydon> Huh. I ... leave way too many things just-sketched-out without actually finishing them, don't I?
[23:04:06] *** Quits: brendan (brendaneic@moz-BBE3ABD.mv.mozilla.com) (Quit: brendan)
[23:04:11] *** Joins: smvv_ (sander@moz-BAEA8EB2.dynamic.upc.nl)
[23:04:22] <graydon> well, best that I figured it out at some point in my adult life
[23:04:32] *** Joins: Vert (quassel@8A83479C.391ACC8C.CAF63861.IP)
[23:05:11] <xenocons> btw i relaly like the external iterator idea 
[23:05:23] <xenocons> it fits a lot better with my expectations of how for should work
[23:05:24] <aatch> xenocons, it's a fine language, just not that interesting overall (Source: former D contributor)
[23:05:33] *** Joins: brendan (brendaneic@moz-BBE3ABD.mv.mozilla.com)
[23:05:44] <xenocons> aatch: ahh, sorta like Go without marketing? heh
[23:05:48] <aatch> xenocons, it meets it's goal of "C++ done right"
[23:05:53] <xenocons> right
[23:06:08] <Vert> In the Rust tutorial section 4.1 makes reference to arms before they are explained in section 4.2. Is that intentional?
[23:06:14] <aatch> xenocons, but we already have C++, so it's kinda boring.
[23:06:15] <strcat> Go isn't far from being D without generics ;p
[23:06:18] <cmr> Vert: unlikely
[23:06:21] <graydon> yeah, I wouldn't denigrate D at all. it's a bunch of randomly adjusted (many tastefully adjusted) changes from C++. not terribly groundbreaking, but some nice stuff.
[23:06:24] <doomlord_> i wonder why it is i never tried D
[23:06:42] <strcat> D without generics, CTFE, etc.
[23:06:50] *** Quits: Blub\w (wry@7E3BB9D.71150E1A.237AE2BA.IP) (Quit: bb2m)
[23:06:54] <xenocons> ill refrain from poking flames at this, i think i inherit some arrogance around PLT due to my fp background :)
[23:07:00] <Vert> cmr: Is it the kind of thing I should file as a bug?
[23:07:11] <xenocons> im very happy that rust is getting F# style for though :):):)
[23:07:25] <graydon> I think it's suffered much more from things like their stdlib split, than from anything inherent in the language. it's still going strong, no?
[23:07:26] <sigma> xenocons: it's a lot older than that :)
[23:07:27] *** Quits: brendan (brendaneic@moz-BBE3ABD.mv.mozilla.com) (Quit: brendan)
[23:07:29] <xenocons> (well C# style, according to reddit, but really its lighter weight)
[23:07:31] <jclements> OT: Turns out there's a 1969 band called Rust--their song "Rust" is â€¦ quite listenable!
[23:07:31] <aatch> I love D's CTFE, there's a lot of cool stuff you can do with it.
[23:07:35] <doomlord_> (C++ head) - i went through a phase of trying different languages. haskell, lisp, clojure, go. Why did I try Rust, and not D. i heard more about Rust fulfulling my wishlist. 
[23:07:42] *** Joins: brendan (brendaneic@moz-BBE3ABD.mv.mozilla.com)
[23:07:45] <xenocons> sigma: yeah fair enough
[23:07:48] <doomlord_> i think i had the impression already that D was more GC based
[23:08:00] <strcat> ctfe, ranges and stuff like static if/assert are really cool
[23:08:12] <cmr> Vert: you could, though it's unlikely to get fixed in a reasonable amount of time unless you send a PR
[23:08:25] <graydon> jclements: url?
[23:08:29] <Vert> PR?
[23:08:32] <aatch> graydon, seems to be going ok.
[23:08:35] <cmr> Vert: pull request
[23:08:35] <Vert> Oh pull request
[23:08:42] <strcat> http://dlang.org/phobos/std_range.html <- long way to go before rust iterators are as nice
[23:08:49] <strcat> they'll get there :)
[23:08:50] <jclements> I'm listening on google play; the first youtube hit is the whole album. Hang on...
[23:09:00] <aatch> graydon, the D1/D2 thing was an issue for a while.
[23:09:11] <aatch> as was the phobos/tango thing
[23:09:26] <graydon> aatch: right, yeah. did that ever get settled? I wasn't clear if d1/d2 was related to phobos/tango
[23:09:31] <graydon> did they sort it out?
[23:09:36] <graydon> (both)
[23:09:37] <xenocons> i will write my own for implementation!! fn for(&fn f:([T]->[T']),xs:[T]) { return map(f,xs) }
[23:09:56] <strcat> aatch: well and they alienate the audience that would like it most by making core features require gc
[23:09:57] <Vert> I'm not sure how you would fix it. I'm not really a technical writer... You could swap sections 4.1 (conditionals) and 4.1 (pattern matching) but that seems weird. Or just move the sentance that mentions them to when arms are introduced in 4.2...
[23:10:01] <jclements> graydon: ah well, whatever: http://www.youtube.com/watch?v=-9eJdyDjuE0
[23:10:07] *** Quits: bytewise (bytewise@moz-649C630D.unitymediagroup.de) (Ping timeout)
[23:10:14] <graydon> strcat: very nice
[23:10:15] *** Quits: FrozenCow (FrozenCow@moz-B2DF4929.chello.nl) (Connection reset by peer)
[23:10:31] *** Joins: FrozenCow (FrozenCow@moz-B2DF4929.chello.nl)
[23:10:51] <jclements> actuallyâ€¦ I'm really enjoying this quite a lot.
[23:10:59] <aatch> graydon, the main issue with Tango was that it relied on a different runtime.
[23:11:03] *** Joins: bjz_ (brendanzab@B398BE78.F804C29E.D35A31DF.IP)
[23:11:11] <aatch> graydon, but phobos "won" in the end.
[23:11:12] <kimundi> somebody2: Still having questions about iter() ?
[23:11:16] *** Quits: bjz (brendanzab@B398BE78.F804C29E.D35A31DF.IP) (Connection reset by peer)
[23:11:57] <MaikKlein> is there a c thread library?
[23:12:07] <Vert> MaikKlein: pthreads?
[23:12:16] <strcat> c11/c++11 have platform independent threads
[23:12:30] *** Joins: erickt (erickt@8C9ECD8F.3A598286.F12515B4.IP)
[23:12:36] <strcat> C++11 threads are pretty nice.
[23:12:42] <cmr> pthreads has cross-platform implementations
[23:12:51] <aatch> strcat, I stopped following D because I got tired of the constant bikeshedding and people getting upset over completely minor things.
[23:12:54] <cmr> There's gnu pth for userspace cooperative multithreading
[23:13:12] <MaikKlein> I might want to build my actor library without rust tasks
[23:13:32] <strcat> MaikKlein: you have to use runtimeless rust if you want to use fork/pthreads
[23:14:00] <sigma> jclements: https://www.youtube.com/watch?feature=player_detailpage&v=-9eJdyDjuE0#t=850s I think that link points to around the start of "rust"
[23:14:19] <MaikKlein> strcat, what is runtimeless rust? is this zero.rs from pcwalton?
[23:14:22] *** Quits: echristo (echristo@EECA91.D6CCE4AE.77834EAA.IP) (Quit: echristo)
[23:14:31] <pcwalton> yes
[23:14:49] *** Quits: krdln (Mibbit@moz-6F8A8560.dynamic.chello.pl) (Quit: http://www.mibbit.com ajax IRC Client)
[23:15:13] *** Quits: erickt (erickt@8C9ECD8F.3A598286.F12515B4.IP) (Ping timeout)
[23:15:16] <strcat> the C++11 stuff is pretty nice though, just lacks data structures
[23:15:28] <_Vi> Which features of Haskell (basic, without "{-# LANGUAGE #-}") Rust will never support?
[23:15:50] <sigma> Tail call optimisation?
[23:16:06] <aatch> _Vi, language-level lazy evaluation.
[23:16:11] <strcat> you can turn on tco with an LLVM flag
[23:16:15] <strcat> as long as we used fastcc
[23:16:19] *** Quits: infynyxx (infynyxx@DB780A29.749BA1D.DCC373F0.IP) (Client exited)
[23:16:39] *** Joins: bytewise (bytewise@moz-649C630D.unitymediagroup.de)
[23:16:46] <kimundi> _Vi: Point free notation :P
[23:16:50] <smvv_> let mut rng = rand::IsaacRng::new_seeded(&[42]); io::println(fmt!("i = %u", rng.next()));  // rustc says that next is not in that scope, but it is in the source and docs: http://static.rust-lang.org/doc/std/rand.html#implementation-of-rng-for-isaacrng
[23:16:56] <MaikKlein> hm what would be preferred c11 threads or pthreads?
[23:17:15] <cmr> pthreads
[23:17:22] <cmr> no c11 threads on windows afaik?
[23:17:40] <strcat> cmr: they are on windows, but atm not as native win32 threads
[23:17:43] <strcat> just with the pthread port
[23:17:50] <cmr> ah
[23:17:56] <strcat> c11 threads vs pthreads is pretty similar
[23:18:09] <strcat> the c11 lib is just cleaner and without as many tunables
[23:18:25] <strcat> c++11 has the nice things like unique locks, futures, async, etc.
[23:19:03] <MaikKlein> well but I can't really use c++11 threads in Rust or can I?
[23:19:23] <MaikKlein> *at the moment*
[23:19:36] <strcat> you can't really use them from rust
[23:19:40] <engla> smvv_: you need to 'use' the Rng trait since the method comes from there
[23:19:45] <strcat> they're all variadic templates
[23:19:57] <strcat> with lots of destructor usage
[23:20:47] <mcguire> Well, argh. Working on converting each_permutation to external iterators. It's pretty trivial, if I allocate and return a new vector for each permutation. 
[23:20:51] <mcguire> https://gist.github.com/tmmcguire/5980163
[23:20:56] <MaikKlein> what does std::tasks use? or are they completely written in rust?
[23:21:49] <mcguire> I would prefer not to do the allocation, but I can't see a way around it.
[23:21:51] * MaikKlein assumes that tasks are built on threads
[23:22:01] <Jeaye> Not necessarily.
[23:22:02] *** Joins: foobario (Mibbit@moz-AE486319.dynamic.hispeed.ch)
[23:22:06] *** Joins: tjc (tjc@moz-2FE771F5.tmodns.net)
[23:22:06] *** ChanServ sets mode: +o tjc
[23:22:08] *** Quits: frogaincia (Mibbit@BBE7C46A.B4F11D08.8612FA94.IP) (Quit: http://www.mibbit.com ajax IRC Client)
[23:22:09] *** Quits: brendan (brendaneic@moz-BBE3ABD.mv.mozilla.com) (Quit: brendan)
[23:22:12] <mcguire> ...unless I mutate the vector being iterated over. Wonder if I can do that....
[23:22:26] <_Vi> Will Rust support hot code replace?
[23:22:37] <cmr> MaikKlein: it uses an M:N task-thread scheduler
[23:22:40] <cmr> _Vi: what is that?
[23:22:41] *** Quits: azita (Azita@moz-BBE3ABD.mv.mozilla.com) (Quit: azita)
[23:22:55] <Jeaye> cmr: Code injection, I'm guessing.
[23:22:58] <_Vi> cmr, Loading newer version of some units into running program.
[23:23:17] <MaikKlein> cmr, so rust probably uses pthreads under the hood?
[23:23:22] <cmr> MaikKlein: no idea
[23:23:31] <bblum> MaikKlein: yes
[23:23:32] <Jeaye> MaikKlein: That'd make sense. :P
[23:23:35] <_Vi> cmr, For example, in Java you can load changed implementation of some method (but not adding/removing methods or changing signature).
[23:23:51] <sully> pcwalton: could you re-r+ my PR?
[23:24:11] <strcat> MaikKlein: well it depends on what you mean
[23:24:16] <SiegeLord> Phobos "won" because Andrei and Walter didn't like Tango, so they wrote a new stdlib from scratch :P
[23:24:23] <foobario> guys, what's the best way to try out Rust without messing your OS? Vagrant?
[23:24:37] <pcwalton> sully: done
[23:24:42] <sully> thanks
[23:24:43] <cmr> foobario: "messing your OS"? just use a local prefix
[23:24:51] <strcat> a package manager works too ;p
[23:25:25] <foobario> oh I see.
[23:25:32] <foobario> brew supports Rust.
[23:25:36] <MaikKlein> strcat, well, I don't know what I mean :). If I am right then there must be some pthread rust bindings in std?
[23:25:44] <ecr> _Vi: there aren't currently any plans for hot swapping code
[23:25:47] <foobario> but still 0.6
[23:26:02] <Jeaye> 0.6 is usable
[23:26:10] <strcat> MaikKlein: it uses pthread atm
[23:26:18] <strcat> it doesn't have to though
[23:26:27] <_Vi> ecr, But is it at least not explicitly rejected idea?
[23:27:17] <ecr> _Vi: it's not something that's been addressed either way to my knowledge.
[23:27:29] <heftig> _Vi: i don't think that's going to happen
[23:27:31] *** Joins: brendan (brendaneic@moz-BBE3ABD.mv.mozilla.com)
[23:27:34] <cmr> _Vi: I don't see why it would need to be a language feature though..
[23:27:39] <heftig> i think inlining makes it too complex to reason about
[23:27:51] <cmr> heftig: it'd work fine for trait objects
[23:27:53] <Jeaye> It was made possible with C++, it can work with Rust. :P
[23:28:03] <cmr> just use a different vtable
[23:28:07] <heftig> cmr: in which case you could use symbol interposition, i guess?
[23:28:10] <strcat> dlopen/dlsym/dlclose?
[23:28:13] <_Vi> Java projects sometimes also take much time to rebuild&redeploy, so "hot code injection" saves time debugging...
[23:28:36] <cmr> _Vi: oh you'd definitely need to recompile
[23:28:36] <Jeaye> strcat: Ideally.
[23:28:40] *** Quits: vk (vk@B7B36E66.870F2FA5.2370DFC3.IP) (Quit: vk)
[23:28:41] <cmr> no way around that, not easily
[23:29:04] <ecr> _Vi: it's possible that rust could build off of hot swapping work for C and C++
[23:29:11] <graydon> jclements: track A6, yeah. not .. bad? not really my cup of tea but a credible theme song, for sure.
[23:29:21] <heftig> java uses a vm, rust does not
[23:29:24] <ecr> _Vi: but it's definitely a research level problem
[23:29:35] <sfackler> you might be able to swap out dynamically linked libraries while a program's running, but that's not really a Rust specific thing
[23:29:36] <_Vi> Imagine something like Lighttable, but for Rust instead of Clojure. (Means you type the code and immediately see the result of test run on it).
[23:30:08] <ecr> _Vi: it's possible Rust could adapt something like http://www.cs.umd.edu/~jfoster/papers/oopsla12.pdf
[23:30:11] <jclements> graydon: lots of good lines: "Rust is everywhere. It takes its share of yesterday. It's here to stay â€¦ for at least another day."
[23:31:05] <sp3d> jclements: haha, I was just thinking those lines sounded nice ;)
[23:31:27] <somebody2> Can you set default values for structs in rust?
[23:31:35] <cmr> somebody2: sorta
[23:31:51] <cmr> somebody2: you can fill in missing fields using `Foo {a: 2, ..default}`
[23:32:03] <cmr> Where default is the struct you want to get the defaults from
[23:32:36] <somebody2> Ha, so you make a default instance and rust automatically copies the members you don't set?
[23:32:36] <cmr> Once we have https://github.com/mozilla/rust/issues/7312 I'd like `Foo {a: 2, ..super}` which would use the Default implementation
[23:32:44] <cmr> somebody2: yes
[23:32:49] <somebody2> That would be really cool
[23:32:50] <somebody2> Thanks
[23:33:14] <smvv_> engla: If I use: let mut rng = rand::IsaacRng::new_seeded([42]); assert!(rng.next() > 0); method `next()' is not found, but rand.rs uses similar code in its tests. I'm not sure what you mean with 'use the Rng trait' because s/IsaacRng/Rng/ does not work either
[23:33:35] *** Quits: foobario (Mibbit@moz-AE486319.dynamic.hispeed.ch) (Quit: http://www.mibbit.com ajax IRC Client)
[23:33:36] * pcwalton is amazed by how many commits that came in the last 2 weeks that added more uses of the "copy" expression
[23:33:42] <engla> smvv_: can you add 'use std::rand::Rng' ?
[23:33:58] <cmr> pcwalton: lots of things don't/didn't have clone... easier to use copy ;)
[23:34:05] <_Vi> ecr, To be good for cozy debugging, there should be a fast way to build those "updates", which is probably a bit related to "incremental compilation" problem...
[23:34:09] <pcwalton> well, you can't anymore!
[23:34:13] <cmr> good!
[23:34:15] <pcwalton> once I rebase
[23:34:43] <engla> smvv_: I know use is an awkward verb for using `use`.
[23:34:46] <smvv_> engla: hmm. I'm still a bit suprised that a use statement fixed it
[23:34:50] <cmr> _Vi: I don't think it's a language problem though... I think it's a library or environment problem.
[23:35:13] <engla> smvv_: you need the trait imported for the trait methods. It's just that lots of traits are use'd by default in std::prelude
[23:35:35] <smvv_> ok i see
[23:36:00] <_Vi> cmr, Can a compiler, for example, don't exit after crate compilation, but be ready to produce slightly different crate with only little changed input (for example only one function changed)?
[23:36:08] <tikue> hey all, I'm trying to understand how to use std::pipes::select2. the example code in the docs says stuff like left((none, b)) \\ endpoint a was closed
[23:36:09] <SiegeLord> Rust does encourage pretty large compillation units relative to other compiled languages
[23:36:22] <tikue> how does it know if the endpoint was closed? or rather, how do I close an endpoint?
[23:36:31] <cmr> _Vi: *a* compiler could, rustc doesn't
[23:36:51] <MaikKlein> is vec::from_fn gone?
[23:36:57] <cmr> MaikKlein: shouldn't be?
[23:37:23] <smvv_> _Vi: gold linker supports incremental linking (i.e. substituting parts of object code if the object code fits). I'm not sure what rust uses
[23:37:26] <_Vi> cmr, Are there any plans for it (or in general modes other than just single one-time crate compilation)?
[23:37:39] <cmr> _Vi: no
[23:37:47] <MaikKlein> cmr, well what would be the replacement?
[23:37:52] <cmr> MaikKlein: no idea
[23:38:30] <MaikKlein> who was working on vec stuff again dbaupp?
[23:38:38] <cmr> and strcat
[23:38:43] <_Vi> Is "rustc" going to be mostly "reference implementation" for others to make optimized versions or more like perl5 (other interpreters unlikely)?
[23:38:47] <strcat> _Vi: incremental recompilation isn't really on the agenda yet, speeding up compilation of anything by 10x is more reachable and more useful
[23:39:34] <_Vi> How big crates should be? Are there any guidelines?
[23:39:44] <cmr> "As big as they need to be, and no bigger"
[23:39:45] <strcat> they're standalone libraries
[23:39:49] <strcat> they become a .so
[23:39:50] <ecr> _Vi: true. For just rapid development and debugging, a REPL is probably going to be the more practical option. Ideally rusti will someday be much more capable, like ghci.
[23:40:09] <aatch> _Vi, you shouldn't have too many issues until you get to massive rustc/libstd sizes
[23:40:18] <_Vi> cmr, Too many crates vs too big crates...
[23:40:42] <cmr> the compiler is very inefficient though, lots of big wins still to be had
[23:40:47] <strcat> _Vi: if you would make it a library in C, you would make a crate in rust
[23:41:13] <strcat> the current state of things isn't how it's going to be forever
[23:41:39] <MaikKlein> rusti: std::vec::from_fn(1000, |x| x};
[23:41:40] -rusti- <anon>:7:38: 7:39 error: incorrect close delimiter: `}`
[23:41:40] -rusti- <anon>:7          std::vec::from_fn(1000, |x| x};
[23:41:40] -rusti-                                                ^
[23:41:41] -rusti- application terminated with error code 101
[23:41:45] <strcat> incremental recompilation can be implemented, it's just far from the most important thing to do considering how difficult it would be
[23:41:56] <strcat> there are a lot of issues needing to fixed first
[23:42:01] <MaikKlein> rusti: std::vec::from_fn(1000, |x| {x}};
[23:42:01] -rusti- <anon>:7:40: 7:41 error: incorrect close delimiter: `}`
[23:42:01] -rusti- <anon>:7          std::vec::from_fn(1000, |x| {x}};
[23:42:01] -rusti-                                                  ^
[23:42:01] -rusti- application terminated with error code 101
[23:42:16] <MaikKlein> rusti: std::vec::from_fn(1000, |x| {x});
[23:42:17] -rusti- ()
[23:42:18] <strcat> for example, exporting generic instantiations from the crate where they're defined
[23:42:21] <MaikKlein> hmmmm
[23:42:31] <aatch> Part of the issue is that many of the optimizations are polynomial time, so a crate twice as big takes 4 times longer to compiler. But it means you can't take librustc time and scale it down linearly.
[23:42:36] <strcat> allowing inlining without preventing a fallback to linking against a symbol
[23:43:10] *** Quits: jgilbert (jgilbert@moz-BBE3ABD.mv.mozilla.com) (Ping timeout)
[23:43:25] <cmr> And alternate compilers, for whatever reason, would be easily feasible once milestone 1 is reached
[23:43:50] <strcat> not really
[23:43:56] <jensnockert> Instead of incremental recompilation, couldn't you just split it into more crates?
[23:43:58] <_Vi> strcat, Maybe there can be some easy way to implement for-debugging incremental compilation? For example, splitting each source file to separate physical crate while still having them behave like one logical crate (access to internals, etc.)...
[23:44:12] *** Joins: jgilbert (jgilbert@moz-7B0110AD.mv.mozilla.com)
[23:44:14] *** Quits: somebody2 (Mibbit@moz-7D83A5F1.ip.telfort.nl) (Quit: http://www.mibbit.com ajax IRC Client)
[23:44:15] <strcat> jensnockert: that will make a full compile take longer, and hurt optimization
[23:44:34] <cmr> strcat: why not?
[23:44:41] <strcat> because you don't want 1000 .so files
[23:44:48] <cmr> I mean re: not really
[23:45:01] <jensnockert> But full compile isn't the 'usual' compilation scenario, at least not for developers.
[23:45:05] <_Vi> strcat, "full compile take longer, and hurt optimization" -> But may be viable for debugging?..
[23:45:23] <_Vi> How easy is currently to split or merge crates?
[23:45:36] <jensnockert> Reasonably simple.
[23:45:36] <strcat> look, we can have incremental recompilation within a crate
[23:45:40] <strcat> with automatic dep resolution
[23:45:56] <strcat> it's just hard to implement and not on the agenda because it'd be a lot of effort when there's lower hanging fruit
[23:46:03] <_Vi> jensnockert, Can it be done mechanically?
[23:46:10] <jensnockert> _Vi: Essentially.
[23:46:26] *** Quits: tjc (tjc@moz-2FE771F5.tmodns.net) (Quit: zzzzzzzzzz)
[23:46:37] * cmr bed
[23:46:43] <strcat> more crates -> more total code
[23:46:45] * jensnockert hugs cmr.
[23:46:47] <strcat> with the way things are
[23:47:16] <strcat> generics and inlinable (whether or not they are inlined) functions are currently duplicated into every crate using them - fix that first, it's not even that hard
[23:47:35] <strcat> and making LLVM passes take 1/10 of the time is totally feasible
[23:47:39] *** Quits: Lilly (PinkLace@moz-145A6857.bredband.comhem.se) (Quit: Byeee~~~~)
[23:47:43] <sully> hm
[23:47:48] <strcat> that's 90% of compilation time gone
[23:47:57] <sully> does our aux testing infrastructure let you have multiple aux crates?
[23:48:15] <_Vi> strcat, So it split a crate into 100 little crates, the overhead can be like 100*C, not like log(100)*C?
[23:48:22] <MaikKlein> atm there is no way to send messages that don't block right?
[23:48:34] <strcat> _Vi: well for example, lets say all 100 use HashMap<int, int>
[23:48:37] <strcat> you now have 100 of them
[23:48:50] <strcat> you have to compile it 100 times
[23:49:19] <ecr> MaikKlein: messages between tasks?
[23:49:59] <tikue> MaikKlein: you can use port.peek() to check if there's a message available without blocking
[23:50:15] <strcat> if we actually exported instantiations, and used linkonce_odr + available_externally -> you could have a single reusable copy of HashMap<int, int> in libstd
[23:50:29] <MaikKlein> ecr, yes
[23:50:56] <MaikKlein> tikue, yeah that's what I am doing atm
[23:51:45] <ecr> MaikKlein: send doesn't block the sender
[23:51:48] <tikue> MaikKlein: I'm not sure I understand your question
[23:51:56] <glinscott> strcat: where is the time going in the llvm passes right now?
[23:52:13] <strcat> glinscott: well we generate 50-100x as much IR as clang for similar code
[23:52:14] <MaikKlein> tikue, yeah I think I am just confused
[23:52:18] *** Quits: snadon (chatzilla@moz-3BC727E8.mc.videotron.ca) (Ping timeout)
[23:52:24] <strcat> glinscott: so it makes all of the initial passes have to cut down a lot more
[23:52:31] <glinscott> strcat: ah :)  yes, that makes sense
[23:52:37] <strcat> our allocas are a huge issue, I dunno why we make so many
[23:52:44] <strcat> clang will output 4-5, and we'll have 60
[23:52:55] <strcat> after optimization we'll have 4-5
[23:53:07] <strcat> it's trivially reducible stuff
[23:53:11] <strcat> just takes a long time.
[23:53:45] <glinscott> and requires good llvm knowledge!
[23:53:47] <strcat> making intrinsics expand in-place instead of making alwaysinline functions would be nice
[23:54:04] *** Quits: sigma (sigma@51C589B3.EF2694B5.DFAC6AA7.IP) (Quit: can't absorb anymore information... sleep time)
[23:54:06] <ecr> MaikKlein: sending over a channel doesn't block the sender because the message can just go wait in the mailbox
[23:54:22] <ecr> MaikKlein: receiving on the port blocks the receiver if there's nothing waiting in the mailbox
[23:54:31] <tikue> ecr: the ship can wait in the port :D
[23:54:38] <ecr> MaikKlein: peeking on a port tells you if there's anything waiting in the mailbox
[23:54:55] <strcat> glinscott: it's not as hard as it seems
[23:55:02] *** Joins: enix (enix@moz-A50569DD.c3-0.slvr-ubr1.lnh-slvr.md.cable.rcn.com)
[23:55:19] <MaikKlein> can a tasks have subtasks? 
[23:55:52] <ecr> MaikKlein: yep. Just do another spawn!()
[23:56:00] <tikue> I can't figure out how to select on multiple ports until they're all closed short of keeping a list of all the ports and marking them off as they're closed
[23:56:02] <ecr> MaikKlein: it's tasks all the way down
[23:56:08] *** Quits: MrFahrenheit (RageOfThou@3FEF494C.29C984D5.783DEDCA.IP) (Ping timeout)
[23:56:17] <glinscott> strcat: i believe you - but as you say, optimizing just takes a lot of time :)
[23:56:20] <tikue> ecr: it's not really a subtask if you spawn() right? 
[23:56:32] <MaikKlein> ecr, but the only way to communicate is again via Chan and Port?
[23:56:39] <jensnockert> I don't think you can link tasks with the new scheduler yet, right?
[23:56:45] <ecr> tikue: well, whatever spawns a supervised task these days
[23:56:52] <ecr> MaikKlein: that's right
[23:56:55] <tikue> ecr: ah right
[23:57:00] <MaikKlein> hm
[23:57:31] <tikue> MaikKlein: what are you trying to do?
[23:57:49] <MaikKlein> tikue, http://www.reddit.com/r/rust/comments/1i3c15/experimental_actor_library_in_rust/ 
[23:57:52] <MaikKlein> tikue, even based actors
[23:58:04] <ecr> MaikKlein: so if a parent wanted a child to go do some work and report the answer, the parent would create a Port/Chan pair, give the Chan to the child, do something else, and eventually receive on the Port and block until the child sends over the Chan.
[23:58:30] *** Quits: SiegeLord (sl@moz-CAF07B4C.hsd1.ma.comcast.net) (Quit: It's a joke, it's all a joke.)

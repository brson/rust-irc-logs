[00:00:46] <strcat> brson: I guess mem usage regressed more :(
[00:00:55] *** Quits: ozten (ozten@19BD73A1.5D8BCA3A.A0C1B52F.IP) (Quit: ozten)
[00:00:57] <Luqman> strcat: i think we really only need the actual entry point (main) which just starts the runtime and calls the program's main
[00:00:57] <strcat> how much memory is available?
[00:01:03] <Luqman> no need for rust_main
[00:01:10] *** Quits: maik (maik@moz-FECBC48.dip0.t-ipconnect.de) (Ping timeout)
[00:01:15] *** Quits: relrod (relrod@moz-AABB5D31.redhat.com) (Ping timeout)
[00:01:22] <brson> strcat: about 4GB
[00:01:25] *** Quits: tjc (tjc@moz-73CBF774.dsl.pltn13.sbcglobal.net) (Quit: zzzzzzzzzz)
[00:01:41] <strcat> brson: yeah that's what I have in my laptop and I hit it with some stuff open and no swap file
[00:01:58] *** Quits: dave1629 (dave@moz-17578A1A.hsd1.va.comcast.net) (Quit: dave1629)
[00:01:59] <brson> that's pretty messed up
[00:02:09] <brson> I'm going to reboot
[00:02:12] <strcat> brson: if we used posix_spawn I don't think it would happen
[00:02:20] *** Quits: brson (brson@moz-BBE3ABD.mv.mozilla.com) (Client exited)
[00:03:13] *** Joins: brson (brson@moz-BBE3ABD.mv.mozilla.com)
[00:03:13] *** ChanServ sets mode: +ao brson brson
[00:03:39] *** Joins: tjc (tjc@moz-73CBF774.dsl.pltn13.sbcglobal.net)
[00:03:39] *** ChanServ sets mode: +o tjc
[00:03:48] *** Quits: wilmoore (wilmoore@moz-7EE4D9D6.mystrotv.com) (Client exited)
[00:04:06] *** Joins: ozten (ozten@19BD73A1.5D8BCA3A.A0C1B52F.IP)
[00:04:09] *** Joins: wilmoore (wilmoore@moz-7EE4D9D6.mystrotv.com)
[00:04:34] <strcat> brson: using posix_spawn instead of fork for our blocking subprocess stuff would be an easy win
[00:04:34] *** Joins: hjr3 (hradtke@374E545A.3A8E9B0C.F9D9C60E.IP)
[00:04:46] <strcat> brson: jemalloc registers stuff to run at atfork since it's fork safe
[00:04:53] *** Joins: lkuper_ (lkuper@BAE96B56.1C5FF2E6.51B6877.IP)
[00:04:58] <strcat> we could probably disable that
[00:05:09] <brson> strcat: why is posix_spawn better?
[00:05:40] *** Joins: relrod (relrod@moz-AABB5D31.redhat.com)
[00:05:41] <strcat> brson: on linux it uses the vfork syscall (when possible)
[00:05:44] *** Joins: ghrust (ghrust@79968228.6A2AE50.F3114085.IP)
[00:05:44] <ghrust> 01[13rust01] 15bors 04force-pushed 06auto from 14c6bd0e3 to 140efc482: 02http://git.io/N3iJvQ
[00:05:44] *** Parts: ghrust (ghrust@79968228.6A2AE50.F3114085.IP) ()
[00:05:46] *** Joins: ghrust (ghrust@9C8B94D4.6A2AE50.F3114085.IP)
[00:05:46] <ghrust> 01[13rust01] 15bors pushed 2 new commits to 06auto: 02http://git.io/ccGVZg
[00:05:46] <ghrust> 13rust/06auto 1431ec7e1 15Alex Crichton: Implement process bindings to libuv...
[00:05:46] <ghrust> 13rust/06auto 14d308359 15bors: auto merge of #9260 : alexcrichton/rust/libuv-processes, r=brson...
[00:05:46] *** Parts: ghrust (ghrust@9C8B94D4.6A2AE50.F3114085.IP) ()
[00:05:49] <strcat> brson: so you don't double the address space
[00:06:02] <strcat> and it won't run pthread_atfork functions (that's implementation defined though)
[00:06:11] *** Quits: wilmoore (wilmoore@moz-7EE4D9D6.mystrotv.com) (Ping timeout)
[00:06:18] <strcat> brson: it's basically just a merged fork+exec
[00:06:34] <strcat> + it includes the ability to close all but certain file descriptors, etc.
[00:06:46] <strcat> so it's harder to get wrong - it'd fix the infinite loop on a failed exec we have now
[00:06:56] <brson> strcat: does libuv have an equivalent?
[00:07:19] <strcat> brson: no, sadly they only use fork internally but it could probably be switched to spawn
[00:07:23] *** Quits: relrod (relrod@moz-AABB5D31.redhat.com) (Ping timeout)
[00:07:24] <strcat> posix_spawn*
[00:07:36] <strcat> I'm not familiar with what their process API needs
[00:07:50] *** Joins: infynyxx (infynyxx@DB780A29.749BA1D.DCC373F0.IP)
[00:08:00] <strcat> if it does something more complex than passing fds, it might actually need fork
[00:08:22] <brson> maybe we can just make rustc itself use vfork as a hack
[00:08:36] <brson> or posix_spawn
[00:08:39] <strcat> brson: well using posix_spawn is better even though it's the same syscall
[00:08:43] <strcat> vfork is technically deprecated
[00:09:29] *** Quits: infynyxx (infynyxx@DB780A29.749BA1D.DCC373F0.IP) (Ping timeout)
[00:09:30] <pcwalton> nmatsakis' node_id change totally broke my fold change :(
[00:09:32] <pcwalton> have to rewrite it
[00:09:48] <pcwalton> nmatsakis: did you ever see error: internal compiler error: node_id -1 resolved first to DefPrimTy(ty_int(ty_i)) and then DefPrimTy(ty_int(ty_i64))
[00:09:51] <pcwalton> during your change?
[00:09:56] <pcwalton> and if so what did you do to fix it
[00:10:12] *** Quits: ozten (ozten@19BD73A1.5D8BCA3A.A0C1B52F.IP) (Quit: ozten)
[00:11:05] *** Joins: jstevans1 (Instantbir@21DD3365.9FF7733C.DDE5D3F6.IP)
[00:11:06] *** Quits: jstevans (Instantbir@21DD3365.9FF7733C.DDE5D3F6.IP) (Connection reset by peer)
[00:12:03] *** Quits: Houm (Houm@moz-25669AA8.fbx.proxad.net) (Ping timeout)
[00:12:24] <acrichto> brson: https://github.com/mozilla/rust/pull/9269/files
[00:14:43] <acrichto> tjc: heads up on 9269 as well
[00:14:46] *** Joins: lex (lex@moz-12347B81.bootp.virginia.edu)
[00:15:28] <tjc> acrichto: ok thanks! my pull request fixing that is already in the queue, so with any luck I'll be able to un-ignore it again immediately :-)
[00:15:38] *** Quits: lkuper_ (lkuper@BAE96B56.1C5FF2E6.51B6877.IP) (Ping timeout)
[00:15:47] *** Joins: ghrust (ghrust@79968228.6A2AE50.F3114085.IP)
[00:15:47] <ghrust> 01[13rust01] 15bors 04force-pushed 06auto from 14d308359 to 140efc482: 02http://git.io/N3iJvQ
[00:15:47] *** Parts: ghrust (ghrust@79968228.6A2AE50.F3114085.IP) ()
[00:15:49] *** Joins: ghrust (ghrust@C8693FCB.6A2AE50.F3114085.IP)
[00:15:49] <ghrust> 01[13rust01] 15bors pushed 2 new commits to 06auto: 02http://git.io/Or8TPA
[00:15:49] <ghrust> 13rust/06auto 143b07f1e 15Alex Crichton: Ignore a test which is blocking a snapshot...
[00:15:49] <ghrust> 13rust/06auto 14460021b 15bors: auto merge of #9269 : alexcrichton/rust/ignore-rustpkg-test, r=brson...
[00:15:49] *** Parts: ghrust (ghrust@C8693FCB.6A2AE50.F3114085.IP) ()
[00:16:26] *** Joins: ghrust (ghrust@2EE61FCC.6A2AE50.F3114085.IP)
[00:16:26] <ghrust> 01[13rust01] 15alexcrichton merged 06auto into 06snap-stage3: 02http://git.io/VEU4PQ
[00:16:26] *** Parts: ghrust (ghrust@2EE61FCC.6A2AE50.F3114085.IP) ()
[00:16:35] <acrichto> tjc: oh whoops
[00:16:42] <acrichto> tjc: I didn't know that that already fixed it
[00:16:55] <tjc> acrichto: no worries, I'm not confident that tests will pass on my PR the first time around anyway!
[00:17:09] <tjc> ignoring it in the meantime is fine
[00:17:16] <acrichto> cool, if you're not around when your stuff lands I'll un-ignore it tonight
[00:17:40] <tjc> great
[00:18:01] <lex> Hi, I'm a student using rust 0.7 for a class. I'm trying to add a character to the end of a string. Since the str manipulation functions don't have a concatenate function for strings, I'm trying to turn the char into a str and then use a StrVector. I'm having trouble initializing the StrVector. I'm using `let processed: str::StrVector = ?` and don't know what to replce the '?' with. Any ideas or thoughts on a better way to do this?
[00:18:55] <tjc> lex: strings are immutable, but you can make a new string with the character added by doing something like: let mut s = "whatever"; s = fmt!("%s%c", c);
[00:18:55] <Eridius> lex: if you have a ~str, you can just call .push_char() on it
[00:18:56] <tjc> if c is a char
[00:19:00] <tjc> or there's that
[00:19:05] <Eridius> rusti: let mut s = ~"test"; s.push_char('!'); s
[00:19:06] -rusti- ~"test!"
[00:19:19] <lex> Eridiu: thanks, i'll try that
[00:19:25] <engla> lex: that doesn't sound right.  let mut s = ~""; s.push_str("xyz"); s.push_char('w')
[00:19:55] <acrichto> lex: also, StrVector is a trait, so you can't directly instantiate it. You can only instantiate it through other types which implement the trait (but that's probably not what you're looking for anyway)
[00:20:20] <jesseray> lex: concerning push_char: http://static.rust-lang.org/doc/0.7/std/str.html#trait-ownedstr
[00:20:24] * pcwalton is tempted to back out any patch that adds an @fn
[00:20:36] <Eridius> pcwalton: dooo iiit
[00:20:42] <lex> engla: thanks, that'll work too. I didn't notice push_str in the documentation
[00:20:52] *** Quits: Ferreus (daniel@moz-7BF03B06.pools.arcor-ip.net) (Quit: WeeChat 0.4.1)
[00:21:35] <engla> lex: notice that ~str is the string type that can grow, you can push to it. &str is a string slice = "a view"
[00:23:26] *** Quits: Ferio (Ferio@moz-E7EA111C.clients.kiwiirc.com) (Quit: http://www.kiwiirc.com/ - A hand crafted IRC client)
[00:23:52] <brson> does anybody know when we push new docs? is it only on manual pushes to the doc branch?
[00:24:24] <kimundi> brson: I thought it was on each master commit
[00:24:33] *** Joins: ww (Mibbit@moz-9D1D3E.public.wayport.net)
[00:24:43] *** Joins: lkuper_ (lkuper@BAE96B56.1C5FF2E6.51B6877.IP)
[00:25:19] *** Joins: brendan (brendaneic@E3D7CBA.E815F8FA.2326E556.IP)
[00:26:26] <ww> how do i do use/import to use the enum member from another module?  i have an enum1 defined in mod1, in mod2 i do use mod1::enum1, but its members are not found.
[00:26:54] <kimundi> ww enum variants need to be imported seperately
[00:27:08] <kimundi> ww: they live right next to the enum type that defines them
[00:27:30] <kimundi> use std::option::{Option, Some, None}; as example
[00:27:42] *** Quits: bjz (brendanzab@B398BE78.F804C29E.D35A31DF.IP) (Quit: Bye!)
[00:27:48] <ww> ok.  i have a long list :)
[00:28:55] *** Joins: dwrensha (chatzilla@moz-DE44EA45.hsd1.pa.comcast.net)
[00:28:57] <ww> actually what is the best practice for putting all the common constants and defines in one place and let all mods use them?   like the header files in c.
[00:29:45] <strcat> ww: you can re-export with 'pub use', if you want
[00:30:04] *** Joins: Yeri (jasonjasmi@41C91A8A.CE609BA5.E39FBF79.IP)
[00:30:12] <ww> pub use every one of the variants?
[00:30:21] <strcat> I'm not sure exactly what you want to do
[00:30:39] <ww> i have some constants defined as enum
[00:30:40] *** Quits: lkuper_ (lkuper@BAE96B56.1C5FF2E6.51B6877.IP) (Ping timeout)
[00:30:47] <strcat> normal way of doing things is just to define a public and mark what you want public as pub
[00:30:50] *** Joins: bjz (brendanzab@B398BE78.F804C29E.D35A31DF.IP)
[00:30:52] <ww> i want to make them available for all mods easily
[00:31:27] <strcat> ww: they are always easily available as mod::Foo, if the enum is public
[00:32:01] <ww> strcat: the members of the pub enum still needed to be imported one by one
[00:32:11] *** Joins: jfbk (jfbk@moz-EEA9CFB3.nyc.res.rr.com)
[00:32:17] <strcat> ww: 'use' is totally optional
[00:32:51] <strcat> they can use foo::*; if they really don't care about name conflicts
[00:33:14] *** Joins: Larry (larryfox@26EE99DC.88C61CC9.ECED8BE3.IP)
[00:33:26] <strcat> rusti: mod foo { pub enum Bar { A, B, C } } foo::A
[00:33:27] -rusti- A
[00:33:37] <strcat> rusti: mod foo { pub enum Bar { A, B, C } } use foo::A; A
[00:33:37] -rusti- <anon>:7:46: 7:57 error: `use` and `extern mod` declarations must precede items
[00:33:37] -rusti- <anon>:7          mod foo { pub enum Bar { A, B, C } } use foo::A; A
[00:33:37] -rusti-                                                        ^~~~~~~~~~~
[00:33:37] -rusti- error: aborting due to previous error
[00:33:37] -rusti- application terminated with error code 101
[00:34:00] *** Joins: lkuper_ (lkuper@BAE96B56.1C5FF2E6.51B6877.IP)
[00:34:41] <strcat> (the bot is not great at these kinds of examples due to being in a block scope inside a function already)
[00:34:44] <ww> ok, let me try those
[00:34:49] *** Joins: samx (sami@moz-D9DA5773.dyn.optonline.net)
[00:35:11] <strcat> ww: but basically, if you have 'mod foo' you can refer to anything public in it with foo::name
[00:35:22] <ww> also i got linking problem when exposing sub-mod function in a library
[00:35:51] <strcat> ww: need 'pub mod' to make a module part of the public API
[00:36:07] <ww> ok
[00:36:16] <ww> let me try
[00:36:17] *** Joins: Ralith (ralith@moz-A7071297.customer.broadstripe.net)
[00:36:18] *** Quits: Larry (larryfox@26EE99DC.88C61CC9.ECED8BE3.IP) (Quit: My MacBook Pro has gone to sleep. ZZZzzzâ€¦)
[00:36:40] <dwrensha> Hey, I think I found a bug in macro expansion...
[00:36:57] <dwrensha> Could someone please take a look at https://gist.github.com/dwrensha/a1b4f6f9ad9e7057628a 
[00:37:10] <strcat> brson: you mean to the site? I think the doc builder runs whenever master moves
[00:37:16] <strcat> brson: it runs some s3 commands
[00:37:43] <sfackler> dwrensha: known issue, macros only expand to the first item in their definition. wrap it in a block and it'll work
[00:37:56] <dwrensha> ah, ok. Thanks.
[00:38:01] <strcat> brson: http://buildbot.rust-lang.org/builders/doc
[00:38:05] *** kimundi is now known as zz_kimundi
[00:38:27] <brson> strcat: oh, i see. yeah doc is tied to master
[00:38:50] <brson> strcat: do you have a link to a stray doc file?
[00:39:06] <acrichto> brson: http://static.rust-lang.org/doc/core/index.html
[00:39:37] *** zz_kimundi is now known as kimundi
[00:39:42] <strcat> brson: http://static.rust-lang.org/doc/std/iterator.html example of one from a module that was moved (it's std::iter now)
[00:39:53] <strcat> brson: it seems to just upload new files + clobber old ones, but never removes
[00:40:09] <brson> ugh, they way the doc directory is laid out makes it impossible to just blow away the entire directory
[00:40:32] <kmc> perhaps git clean would be useful
[00:40:40] *** Quits: lkuper_ (lkuper@BAE96B56.1C5FF2E6.51B6877.IP) (Ping timeout)
[00:41:07] *** Quits: mihneadb_ (mihneadb@41E65AA5.B2E373EA.FCAAE698.IP) (Input/output error)
[00:41:10] <strcat> brson: also some really also ones are still on the 'dl' subdomain
[00:44:47] *** Parts: lex (lex@moz-12347B81.bootp.virginia.edu) ()
[00:45:52] *** Quits: eschweic (Adium@moz-B823728F.syrcny.east.verizon.net) (Quit: Leaving.)
[00:46:08] *** Quits: dandy (Dandy@moz-84CC8377.hsd1.co.comcast.net) (Quit: Leaving)
[00:46:38] *** Joins: lkuper_ (lkuper@BAE96B56.1C5FF2E6.51B6877.IP)
[00:47:14] *** bent is now known as bent|away
[00:47:27] *** Joins: dave1629 (dave@moz-17578A1A.hsd1.va.comcast.net)
[00:49:33] *** Quits: heftig (heftig@moz-61654AE9.dip0.t-ipconnect.de) (Quit: Quitting)
[00:49:57] *** Joins: relrod (relrod@moz-AABB5D31.redhat.com)
[00:51:40] *** Joins: vodik (simon@moz-CBE4BB13.cable.teksavvy.com)
[00:51:56] <nejucomo_> It appears that the ' in this declaration confuses rust-mode.el:     fn empty() -> &'static BitBucket {
[00:52:03] *** nejucomo_ is now known as nejucomo
[00:52:32] * nejucomo glances at rust-mode.el...
[00:53:01] *** Quits: dave1629 (dave@moz-17578A1A.hsd1.va.comcast.net) (Quit: dave1629)
[00:55:32] *** Quits: vodik (simon@moz-CBE4BB13.cable.teksavvy.com) (Ping timeout)
[00:55:42] *** Quits: lkuper_ (lkuper@BAE96B56.1C5FF2E6.51B6877.IP) (Ping timeout)
[00:55:50] *** Joins: vodik (simon@moz-CBE4BB13.cable.teksavvy.com)
[00:59:01] *** Quits: jesseray (Mibbit@moz-EE907FB2.dhcp.insightbb.com) (Quit: http://www.mibbit.com ajax IRC Client)
[00:59:39] *** Joins: lkuper_ (lkuper@BAE96B56.1C5FF2E6.51B6877.IP)
[00:59:44] <nejucomo> Ahaâ€¦  I think I had an ancient rust-mode.elc from v0.4 days...
[01:00:25] *** Quits: josh (josh@moz-348C4790.hsd1.mn.comcast.net) (Quit: josh)
[01:01:41] *** Joins: tautologico (shung@72FFECE3.691D28F8.C27E1635.IP)
[01:01:46] *** Quits: thewonderidiot (mstewart@moz-E41129BA.ipnetworksinc.net) (Quit: Leaving.)
[01:02:50] *** Quits: dwrensha (chatzilla@moz-DE44EA45.hsd1.pa.comcast.net) (Quit: ChatZilla 0.9.90.1 [Firefox 23.0.1/20130814063812])
[01:06:13] *** Quits: lkuper_ (lkuper@BAE96B56.1C5FF2E6.51B6877.IP) (Ping timeout)
[01:06:44] <Luqman> one line fixes are the best. r? https://github.com/mozilla/rust/pull/9272
[01:08:09] *** Joins: infynyxx (infynyxx@DB780A29.749BA1D.DCC373F0.IP)
[01:08:40] <aatch> tjc, bah, beat me to it.
[01:08:45] *** Quits: carllerche (carllerche@moz-BF6CB667.hsd1.ca.comcast.net) (Quit: carllerche)
[01:09:40] <tjc> aatch: I cherish any opportunity to have impact
[01:09:49] *** Quits: infynyxx (infynyxx@DB780A29.749BA1D.DCC373F0.IP) (Ping timeout)
[01:09:56] <Luqman> tjc: thanks!
[01:10:00] <tjc> Luqman: yw!
[01:10:34] <ww> what's the syntax to import public names at the crate root?  i'lve tried use ::* or root::* but no go
[01:10:56] *** Joins: jesseray (Mibbit@moz-EE907FB2.dhcp.insightbb.com)
[01:11:40] *** Joins: lkuper_ (lkuper@BAE96B56.1C5FF2E6.51B6877.IP)
[01:13:10] <brson> I'm going to move the master docs to doc/master
[01:13:29] <brson> so there will be docs at doc/0.8, etc. and doc/master, and nothing at doc/
[01:13:37] <brson> then we can rm master before syncing
[01:13:50] <strcat> brson: sounds perfect to me ;]
[01:13:55] *** Joins: hoverbear (andrew@moz-86FCBF4B.gv.shawcable.net)
[01:16:14] <tautologico> is there a filter for vectors defined somewhere?
[01:16:45] <tjc> tautologico: see the `filter` method in std::iter
[01:16:47] <tjc> you can use it on vecs
[01:16:53] <kmc> you'd filter the iterator and then 'collect' it if you want another owned vector
[01:16:58] <tjc> (there's even a code example in the documentation! yippee!)
[01:17:17] <tautologico> thanks :)
[01:17:18] *** Joins: maik (maik@moz-FECBC48.dip0.t-ipconnect.de)
[01:18:01] <strcat> http://seld.be/rustdoc/master/std/iter/trait.Iterator.html much, much better presented here
[01:18:14] <strcat> that module is pretty hard to navigate with the old rustdoc
[01:18:25] <kmc> rusti: let a = [1,2]; a
[01:18:25] -rusti- [1, 2]
[01:18:41] *** jack|plane is now known as jack
[01:18:43] <kmc> huh what's the type of a then?
[01:18:53] <strcat> [int, ..2]
[01:18:55] <cmr> [int, ..2]
[01:19:07] <strcat> kmc: btw you can get type names at runtime now
[01:19:15] <kmc> ah, ok
[01:19:16] <strcat> although I put it in an awful place
[01:19:33] <Jesse_> is seld.be/rustdoc/ new material or just new presentation?
[01:19:41] <strcat> Jesse_: same material, new presentation
[01:20:01] <kmc> is the ability to call .iter() on fixed length vectors compiler magic? seems like you couldn't write trait impls for every size
[01:20:04] <strcat> we actually do have some good documentation... it just gets presented really badly
[01:20:14] <kmc> (or regular impls for that matter)
[01:20:16] <cmr> kmc: it gets borrowed to a slice.
[01:20:16] <strcat> kmc: they coerce to &[]
[01:20:21] <kmc> ah
[01:20:45] *** Joins: jstevans (Instantbir@CEF2B327.599F34EC.DDE5D3F6.IP)
[01:20:53] <kmc> and this coercion is applied before method lookup? so it's kind of like autoderef or what?
[01:21:08] <strcat> kmc: yeah it's part of auto-ref/auto-deref
[01:21:12] <kmc> cool
[01:21:52] *** Quits: andrew-d_w (andrew-d_w@moz-9A2674DF.dsl.static.sonic.net) (Input/output error)
[01:22:00] *** Quits: jstevans1 (Instantbir@21DD3365.9FF7733C.DDE5D3F6.IP) (Ping timeout)
[01:22:39] *** Quits: vodik (simon@moz-CBE4BB13.cable.teksavvy.com) (Ping timeout)
[01:23:16] <strcat> rusti: use std::unstable::intrinsics::get_tydesc; unsafe { get_tydesc::<int>() }
[01:23:16] -rusti- (0x60b030 as *())
[01:23:35] *** Joins: jstevans1 (Instantbir@21DD3365.9FF7733C.DDE5D3F6.IP)
[01:23:44] <strcat> rusti: use std::unstable::intrinsics::get_tydesc; fn name<T>(x: &T) { unsafe { get_tydesc::<T>() } }
[01:23:44] *** Quits: lkuper_ (lkuper@BAE96B56.1C5FF2E6.51B6877.IP) (Ping timeout)
[01:23:44] -rusti- <anon>:7:72: 7:100 error: mismatched types: expected `()` but found `*std::unstable::intrinsics::TyDesc` (expected () but found *-ptr)
[01:23:45] -rusti- <anon>:7          use std::unstable::intrinsics::get_tydesc; fn name<T>(x: &T) { unsafe { get_tydesc::<T>() } }
[01:23:45] -rusti-                                                                                  ^~~~~~~~~~~~~~~~~~~~~~~~~~~~
[01:23:45] -rusti- error: aborting due to previous error
[01:23:46] -rusti- application terminated with error code 101
[01:23:51] <engla> would clone be more sane as a free function? that's a place where autoderef making it harder to use
[01:23:52] <tautologico> what about sorting a vector?
[01:23:55] *** Quits: robn (robn@moz-76B0302C.static.internode.on.net) (Quit: Coyote finally caught me)
[01:23:59] *** Joins: robn (robn@moz-76B0302C.static.internode.on.net)
[01:24:17] <strcat> rusti: use std::unstable::intrinsics::get_tydesc; fn name<T>(x: &T) -> &'static str { unsafe { (*get_tydesc::<T>()).name } } name(&5)
[01:24:18] -rusti- <anon>:7:63: 7:64 warning: unused variable: `x` [-W unused-variable (default)]
[01:24:18] -rusti- <anon>:7          use std::unstable::intrinsics::get_tydesc; fn name<T>(x: &T) -> &'static str { unsafe { (*get_tydesc::<T>()).name } } name(&5)
[01:24:18] -rusti-                                                                         ^
[01:24:18] -rusti- "int"
[01:24:25] *** Quits: jstevans (Instantbir@CEF2B327.599F34EC.DDE5D3F6.IP) (Ping timeout)
[01:24:27] <strcat> kmc: like that ;p
[01:24:31] <cmr> tautologico: there's some stuff in extra::sort but it's primitivish and slow
[01:24:41] <strcat> rusti: use std::unstable::intrinsics::get_tydesc; fn name<T>(_: &T) -> &'static str { unsafe { (*get_tydesc::<T>()).name } } name(&"foo")
[01:24:42] -rusti- <anon>:7:132: 7:138 error: mismatched types: expected `&<V6>` but found `&str` (expected &-ptr but found &str)
[01:24:42] -rusti- <anon>:7          use std::unstable::intrinsics::get_tydesc; fn name<T>(_: &T) -> &'static str { unsafe { (*get_tydesc::<T>()).name } } name(&"foo")
[01:24:42] -rusti-                                                                                                                                              ^~~~~~
[01:24:42] -rusti- error: aborting due to previous error
[01:24:43] -rusti- application terminated with error code 101
[01:24:46] * strcat sighs
[01:25:03] <engla> there's no API for that in repr?
[01:25:12] <strcat> engla: not yet, at least
[01:25:14] <strcat> rusti: use std::unstable::intrinsics::get_tydesc; fn name<T>(_: &T) -> &'static str { unsafe { (*get_tydesc::<T>()).name } } let a = [1, 2]; name(&a)
[01:25:15] -rusti- "[int, .. 2]"
[01:25:23] *** Joins: josh (josh@moz-348C4790.hsd1.mn.comcast.net)
[01:25:32] <kmc> awesome so we can have :t for rusti with just a little sugar now :)
[01:25:39] *** Joins: erickt (Adium@49C4075F.3AC15C18.2321E71E.IP)
[01:26:16] <strcat> I'm not really sure it belongs in the tydesc but that's where it is for now.
[01:26:47] <strcat> either has to be hardcoded into the visit glue or in the tydesc
[01:26:50] <strcat> atm it's both ;]
[01:26:58] *** Quits: canhtak (jeremy@moz-8CBCE134.wl.t.ulaval.ca) (Quit: canhtak)
[01:27:35] *** Joins: jstevans (Instantbir@277ED946.4F63199.DDE5D3F6.IP)
[01:28:36] *** Joins: tikue_ (tkuehn@B57CA43C.B9B3942C.689607DE.IP)
[01:28:55] *** Quits: jstevans1 (Instantbir@21DD3365.9FF7733C.DDE5D3F6.IP) (Ping timeout)
[01:28:59] *** Quits: voxpopuli (fanservice@moz-FE161659.wv.cc.cmu.edu) (Ping timeout)
[01:29:12] <strcat> I think LLVM fails to eliminate bounds checks because the size being stored in bytes confuses it
[01:29:15] <strcat> ;[
[01:29:15] *** Joins: snadon (chatzilla@moz-3BC727E8.mc.videotron.ca)
[01:30:00] <engla> oh
[01:30:14] <engla> so it does elimitate it for [u8, ..N] arrays?
[01:30:22] <strcat> not afaict
[01:30:24] <engla> elimitate. I'm sorry.
[01:31:16] <strcat> working on a minimal example atm
[01:32:01] *** Joins: lkuper_ (lkuper@BAE96B56.1C5FF2E6.51B6877.IP)
[01:32:33] *** Joins: jstevans1 (Instantbir@54275545.EBD92228.DDE5D3F6.IP)
[01:33:05] *** jack is now known as jack|dinner
[01:33:46] *** Quits: jstevans (Instantbir@277ED946.4F63199.DDE5D3F6.IP) (Ping timeout)
[01:35:12] <strcat> http://ix.io/88q it can't even eliminate those bounds checks or compile it out
[01:35:22] *** Joins: heftig (heftig@moz-61654AE9.dip0.t-ipconnect.de)
[01:35:40] *** Quits: tikue_ (tkuehn@B57CA43C.B9B3942C.689607DE.IP) (Quit: tikue_)
[01:35:47] <strcat> http://ix.io/88r makes this
[01:36:08] <strcat> (same IR with 'for i in range(0, 3)', was just making sure it wasn't that)
[01:36:55] * strcat tries C++
[01:37:20] *** Joins: sankha93 (Instantbir@7061CD01.D6BD0D91.22D41759.IP)
[01:37:33] *** Joins: azita (Azita@moz-C1FB2A8.hsd1.ca.comcast.net)
[01:38:08] *** Quits: maik (maik@moz-FECBC48.dip0.t-ipconnect.de) (Ping timeout)
[01:38:44] <strcat> anyway meh
[01:38:50] <strcat> it just doesn't understand that we compare against bytes
[01:39:01] *** Joins: anshin (anshin@CD85F10D.F21429E2.354459FA.IP)
[01:39:26] * strcat will fix it
[01:39:42] <nmatsakis> pcwalton: I never saw that error, but it sounds like you have an a node-id that was never renumbered
[01:39:54] <nmatsakis> pcwalton: certainly resolve should never see -1 as a node-id anywhere!
[01:39:57] *** Quits: sankha93 (Instantbir@7061CD01.D6BD0D91.22D41759.IP) (Quit: Gone to save the world!)
[01:40:03] <pcwalton> nmatsakis: I think it was "as"
[01:40:06] <pcwalton> RHS of "as"
[01:40:14] <pcwalton> rebuilding now
[01:40:52] <brson> i'm learning a lot about aws and s3
[01:40:54] <pcwalton> yeah, looks like that was it
[01:42:21] *** Quits: maxli (maxli@moz-A607CA26.student.cs.uwaterloo.ca) (Quit: Leaving.)
[01:42:24] *** Joins: maxli (maxli@moz-A607CA26.student.cs.uwaterloo.ca)
[01:43:40] <pcwalton> argh, ICE
[01:44:00] <pcwalton> strcat: we shouldn't compare against bytes
[01:44:02] <pcwalton> I want to change that
[01:44:38] <pcwalton> it was a misguided microoptimization that is catastrophic on ARM due to the lack of an integer DIV instruction
[01:44:42] <strcat> I was trying to figure out where 11 came from
[01:44:45] *** Quits: lkuper_ (lkuper@BAE96B56.1C5FF2E6.51B6877.IP) (Ping timeout)
[01:45:02] <strcat> realized it started from 12
[01:45:17] *** Quits: pcwalton (pcwalton@moz-BBE3ABD.mv.mozilla.com) (Quit: pcwalton)
[01:45:23] <strcat>   %4 = shl i64 %i.06, 2
[01:45:26] <strcat>   %5 = icmp ugt i64 %4, 11
[01:47:51] <engla> so it's calculating   while ! ((i << 2) > 11)  { }  if I read that right
[01:48:23] <strcat> << 2 is to get the size in bytes
[01:48:27] <strcat> since f32 is 4
[01:48:28] *** Joins: canhtak (jeremy@moz-8CBCE134.wl.t.ulaval.ca)
[01:48:34] *** Joins: alisdair (textual@1697D94C.7742FB18.FBC8476D.IP)
[01:48:35] *** Quits: alisdair (textual@1697D94C.7742FB18.FBC8476D.IP) (Client exited)
[01:48:42] <strcat> engla: yeah
[01:48:53] *** Quits: vadimcn (chatzilla@A2267643.76F9E272.DA40C4B3.IP) (Quit: ChatZilla 0.9.90.1 [Firefox 23.0.1/20130814063812])
[01:50:51] *** Joins: ghrust (ghrust@C8693FCB.6A2AE50.F3114085.IP)
[01:50:51] <ghrust> 01[13rust01] 15bors merged 06auto into 06master: 02http://git.io/Or8TPA
[01:50:51] *** Parts: ghrust (ghrust@C8693FCB.6A2AE50.F3114085.IP) ()
[01:51:20] *** Quits: rust-buildbot (rust-build@505BFA3.C3CCCE8C.D25A875A.IP) (Quit: buildmaster reconfigured: bot disconnecting)
[01:51:21] *** Joins: rust-buildbot (rust-build@505BFA3.C3CCCE8C.D25A875A.IP)
[01:52:02] *** Joins: lkuper_ (lkuper@BAE96B56.1C5FF2E6.51B6877.IP)
[01:52:54] *** Joins: ross (ross@moz-5EA04060.br.br.cox.net)
[01:52:57] *** Quits: azita (Azita@moz-C1FB2A8.hsd1.ca.comcast.net) (Quit: azita)
[01:53:06] *** Quits: snadon (chatzilla@moz-3BC727E8.mc.videotron.ca) (Ping timeout)
[01:53:23] <brson> ok, I've moved the docs to the new location, updated the links, and reconfigured buildbot to hopefully do the right thing on the next doc build
[01:53:38] <brson> i'm going to go to dinner and hope nothing blows up before i return
[01:55:18] <strcat> the bounds checks also overflow like this
[01:55:30] <strcat> xs[really_big_number] gets multiplied by the size
[01:55:33] <strcat> and wraps
[01:55:40] *** Quits: DAddYE (DAddYE@moz-61EB081B.hfc.comcastbusiness.net) (Client exited)
[01:55:41] <strcat> that can't be good.
[01:55:50] *** Joins: ghrust (ghrust@C8693FCB.6A2AE50.F3114085.IP)
[01:55:50] <ghrust> 01[13rust01] 15bors pushed 0 new commits to 06auto: 02http://git.io/ZsXWBw
[01:55:50] *** Parts: ghrust (ghrust@C8693FCB.6A2AE50.F3114085.IP) ()
[01:55:51] *** Joins: ghrust (ghrust@1E8607E8.6A2AE50.F3114085.IP)
[01:55:51] <ghrust> 01[13rust01] 15bors pushed 2 new commits to 06auto: 02http://git.io/m_dMYw
[01:55:51] <ghrust> 13rust/06auto 14e12c3bf 15Daniel Micay: document what unsafety means...
[01:55:51] <ghrust> 13rust/06auto 144dc3a97 15bors: auto merge of #9258 : thestinger/rust/doc, r=catamorphism...
[01:55:51] *** Parts: ghrust (ghrust@1E8607E8.6A2AE50.F3114085.IP) ()
[01:56:06] *** Quits: jgilbert (jgilbert@moz-BBE3ABD.mv.mozilla.com) (Ping timeout)
[01:56:08] *** Joins: DAddYE (DAddYE@moz-61EB081B.hfc.comcastbusiness.net)
[01:56:28] *** Quits: q66 (q66@6EE9DE40.46454B5D.33AABD5F.IP) (Quit: Leaving)
[01:57:48] *** Quits: DAddYE (DAddYE@moz-61EB081B.hfc.comcastbusiness.net) (Ping timeout)
[01:57:59] *** Quits: tautologico (shung@72FFECE3.691D28F8.C27E1635.IP) (Quit: tautologico)
[01:58:43] *** Joins: tautologico (shung@72FFECE3.691D28F8.C27E1635.IP)
[01:58:46] <cmr> rusti: let xs = ~[1, 2, 3i]; xs[2305843009213693952]
[01:58:48] -rusti- 1
[01:58:50] <cmr> heh
[01:59:17] <strcat> let xs = ~[1, 2, 3i]; xs[2305843009213693953]
[01:59:19] <engla> that's great
[01:59:25] <strcat> rusti: let xs = ~[1, 2, 3i]; xs[2305843009213693953]
[01:59:26] -rusti- 2
[01:59:28] <strcat> rusti: let xs = ~[1, 2, 3i]; xs[2305843009213693954]
[01:59:28] -rusti- 3
[01:59:30] <strcat> rusti: let xs = ~[1, 2, 3i]; xs[2305843009213693955]
[01:59:30] -rusti- task <unnamed> failed at 'index out of bounds: the len is 3 but the index is 2305843009213693955', <anon>:7
[01:59:31] -rusti- application terminated with error code 101
[01:59:33] <strcat> well
[01:59:37] <strcat> not unsafe at least.
[02:03:17] *** Quits: lkuper_ (lkuper@BAE96B56.1C5FF2E6.51B6877.IP) (Ping timeout)
[02:03:27] <brson> we have a new valgrind error!
[02:03:38] <brson> bbl
[02:04:21] <mcpherrin> strcat: haha, that's a nice bug
[02:04:38] *** Joins: voxpopuli (fanservice@moz-CEF3689A.hsd1.pa.comcast.net)
[02:06:20] <nejucomo> I get an access error when I click the "standard" link under trunk on the front rust-lang.org page.
[02:06:25] <nejucomo> Does anyone else get this?
[02:06:35] <cmr> brson: man, not even 15 minutes later.
[02:06:47] <nejucomo> I'm getting an http 403 forbidden
[02:07:17] <cmr> nejucomo: yes, the docs are currently down, waiting for the docbuilder to build the docs.
[02:07:25] <cmr> In the interim, feel free to use http://seld.be/rustdoc
[02:07:36] <nejucomo> I see.  Is this a standard downtime whenever a new doc build is pushed?
[02:07:43] <cmr> No.
[02:07:56] *** Quits: tjc (tjc@moz-73CBF774.dsl.pltn13.sbcglobal.net) (Ping timeout)
[02:08:04] <nejucomo> Thanks for the alternate link.
[02:08:29] *** Joins: infynyxx (infynyxx@DB780A29.749BA1D.DCC373F0.IP)
[02:08:36] *** Joins: lkuper_ (lkuper@BAE96B56.1C5FF2E6.51B6877.IP)
[02:09:43] <nejucomo> Hm.  Actually I was looking for how to iterate over an integer range, and an old stackoverflow mentioned a range function in uint.  I don't see anything in the seld.be doc page for uint, though.
[02:10:05] <cmr> It's 1. reexported, 2. now gone.
[02:10:09] *** Quits: infynyxx (infynyxx@DB780A29.749BA1D.DCC373F0.IP) (Ping timeout)
[02:10:16] <cmr> rusti: for i in range(0, 10) { print!("{} ", i); }
[02:10:17] -rusti- 0 1 2 3 4 5 6 7 8 9 ()
[02:10:34] <acrichto> brson: nooooooooo :(, it looks like check-stage2-std is broken, but not sure why...
[02:10:35] <nejucomo> Ah, I also see useful bits in std::iter
[02:10:50] <engla> _very_ useful bits
[02:14:23] <nejucomo> So if I have: for i in range(0, 42) { func_which_takes_a_uint(i) }  -does type inference determine I want range<uint> ?
[02:15:28] <aatch> cmr, I assume rustdoc itself is what cleans up the doc-comments?
[02:15:30] <engla> nejucomo: apparently not, you can use  range(0u, 42)
[02:15:54] <cmr> aatch: Context? But yes.
[02:16:33] *** Quits: maxli (maxli@moz-A607CA26.student.cs.uwaterloo.ca) (Quit: Leaving.)
[02:16:47] <aatch> cmr, minor bug, if a block doc-comment is ended on the same line, the ending '*/' is left in. See std::condition
[02:17:00] <cmr> aatch: Yes, on my to-do list
[02:17:13] *** Joins: maxli (maxli@moz-A607CA26.student.cs.uwaterloo.ca)
[02:17:16] <cmr> I currently only consider the start of lines for comment cleaning.
[02:17:32] <aatch> cmr, thought so, there just isn't a bug open for it right now.
[02:17:36] <nejucomo> engla: Ok, thanks.
[02:17:41] *** Quits: maxli (maxli@moz-A607CA26.student.cs.uwaterloo.ca) (Quit: Leaving.)
[02:19:18] *** Quits: lkuper_ (lkuper@BAE96B56.1C5FF2E6.51B6877.IP) (Ping timeout)
[02:20:53] *** Quits: riley (riley@8BA43816.9AA11D69.65DDFA89.IP) (Client exited)
[02:21:00] <luisbg> how do you create a string from an int in Rust?
[02:21:15] <cmr> rusti: let i = 5u; i.to_str()
[02:21:16] -rusti- ~"5"
[02:21:49] <luisbg> http://static.rust-lang.org/doc/core/int.html <-- access denied?
[02:21:50] *** Quits: bjz (brendanzab@B398BE78.F804C29E.D35A31DF.IP) (Connection reset by peer)
[02:22:01] <mcpherrin> luisbg: docs are temporarily offline
[02:22:06] *** Quits: RageOfThou (RageOfThou@3FEF494C.29C984D5.783DEDCA.IP) (Ping timeout)
[02:22:07] <cmr> luisbg: Also, those are ancient docs.
[02:22:11] <strcat> luisbg: it's not called core anymore
[02:22:14] <cmr> core is pre-0.7
[02:22:28] <luisbg> google search :S
[02:22:40] <luisbg> why are they temporarily offline? being updated?
[02:22:43] *** Joins: lkuper_ (lkuper@moz-C0CD33ED.hsd1.in.comcast.net)
[02:22:49] <strcat> they are still there
[02:22:52] <cmr> Removing all the old docs such as those.
[02:23:02] <cmr> Removed, in fact.
[02:23:03] <luisbg> cmr, nice
[02:23:17] <strcat> http://static.rust-lang.org/doc/master/std/index.html
[02:23:22] <cmr> http://static.rust-lang.org/doc/master/std/index.html
[02:23:31] *** Joins: bjz (brendanzab@B398BE78.F804C29E.D35A31DF.IP)
[02:23:39] <cmr> 5 seconds late :(
[02:23:47] *** Joins: lkuper__ (lkuper@BAE96B56.1C5FF2E6.51B6877.IP)
[02:24:33] <luisbg> cmr, hahaha
[02:24:36] <luisbg> no worries
[02:24:40] <luisbg> strcat, thanks! :)
[02:24:42] *** Joins: snadon (chatzilla@moz-3BC727E8.mc.videotron.ca)
[02:26:43] <acrichto> in our markdown, can you add a hyperlink but not have the link be inline with the rest of the text?
[02:27:16] <luisbg> cmr, now instead of doing int::from_string(x) we do str.from_string() ?
[02:27:24] <strcat> acrichto: yes, but where are you doing it?
[02:27:25] <strcat> a tutorial?
[02:27:34] <acrichto> nah doc-blocks
[02:27:58] <acrichto> rusti: from_str::<int>("5")
[02:27:59] -rusti- Some(5)
[02:27:59] <cmr> luisbg: no, we use the from_str free function, or do FromStr::from_str
[02:28:17] <acrichto> rusti: println!("{:?}", from_str::<int>("5"))
[02:28:18] <luisbg> cmr, and a match to destruct the Something or None type options
[02:28:18] -rusti- Some(5)
[02:28:18] -rusti- ()
[02:28:27] <acrichto> oh not 5i
[02:28:28] <luisbg> acrichto, thanks! :)
[02:30:32] *** jack|dinner is now known as jack
[02:30:57] <aatch> rusti: let n : int = from_str("5").unwrap(); n
[02:30:58] -rusti- 5
[02:31:28] <aatch> Just fyi, you don't need the explicit params if rust can infer the type(s) ^^
[02:31:35] <luisbg> aatch, unwrap?
[02:31:41] <luisbg> haven't seen that one before
[02:31:44] <cmr> Option<T> -> T
[02:31:47] <cmr> fails if it's None
[02:31:52] <aatch> luisbg, it's a method on Option, fails if it's None
[02:32:03] <strcat> rusti: let xs = &[1, 2];
[02:32:04] -rusti- <anon>:7:13: 7:15 warning: unused variable: `xs` [-W unused-variable (default)]
[02:32:04] -rusti- <anon>:7          let xs = &[1, 2];
[02:32:04] -rusti-                       ^~
[02:32:04] -rusti- ()
[02:32:24] <strcat> rusti: let xs = &[1, 2]; unsafe { std::cast::transmute<&[int], (uint, uint)>() }
[02:32:24] -rusti- <anon>:7:63: 7:64 error: expected one of `; }` but found `,`
[02:32:25] -rusti- <anon>:7          let xs = &[1, 2]; unsafe { std::cast::transmute<&[int], (uint, uint)>() }
[02:32:25] -rusti-                                                                         ^
[02:32:25] -rusti- application terminated with error code 101
[02:32:32] <luisbg> aatch, nice
[02:32:45] <strcat> rusti: let xs = &[1, 2]; unsafe { std::cast::transmute::<&[int], (uint, uint)>() }
[02:32:45] -rusti- <anon>:7:36: 7:84 error: this function takes 1 parameter but 0 parameters were supplied
[02:32:46] -rusti- <anon>:7          let xs = &[1, 2]; unsafe { std::cast::transmute::<&[int], (uint, uint)>() }
[02:32:46] -rusti-                                              ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
[02:32:46] -rusti- error: aborting due to previous error
[02:32:47] -rusti- application terminated with error code 101
[02:33:07] <aatch> luisbg, you probably want to use something else in real code though.
[02:33:19] *** Quits: MrByte (MrByte@moz-147070D0.chy-wy.client.bresnan.net) (Quit: )
[02:33:50] *** Joins: MrByte (MrByte@moz-147070D0.chy-wy.client.bresnan.net)
[02:34:17] <luisbg> aatch, yes 'match', but for testing quickly while writing it is good
[02:34:31] <cmr> or expect
[02:34:45] <luisbg> whose expecting?
[02:34:50] <luisbg> silly joke
[02:34:52] * luisbg hides
[02:35:03] <cmr> rusti: let x: Option<uint> = None; x.expect("message")
[02:35:04] -rusti- task <unnamed> failed at 'message', /build/rust-git/src/rust/src/libstd/option.rs:351
[02:35:05] -rusti- application terminated with error code 101
[02:35:30] <strcat> anyway going to change slice/vector length to elements...
[02:35:56] <strcat> this will be "fun" :P
[02:36:28] <aatch> luisbg, if you're in a situation where you don't think you shouldn't have None (for whatever reason), use expect.
[02:36:38] <aatch> makes debugging much nicer down the road.
[02:36:48] <aatch> strcat, any reason why?
[02:36:57] <luisbg> aatch, will do, thanks
[02:37:11] <strcat> aatch: bounds checking isn't eliminated on fixed-size vectors, LLVM doesn't understand our idiom
[02:37:17] <strcat> (and elsewhere)
[02:37:19] *** Quits: lkuper__ (lkuper@BAE96B56.1C5FF2E6.51B6877.IP) (Ping timeout)
[02:37:21] <aatch> strcat, hmm, fair enough.
[02:37:37] <strcat> rusti: let xs = ~[1, 2, 3i]; xs[2305843009213693953]
[02:37:38] -rusti- 2
[02:37:47] <strcat> aatch: and that's not great
[02:38:11] <aatch> And I guess you can't get away from length being stored_size/element_size
[02:38:31] *** Joins: jensnockert (jensnocker@moz-3AFB03C7.mobileonline.telia.com)
[02:38:33] <brson> acrichto: are you looking at that valgrind error or shall i?
[02:38:39] <strcat> aatch: yeah, although I could solve this another way
[02:38:41] <strcat> maybe
[02:38:41] *** Quits: jensnockert (jensnocker@moz-3AFB03C7.mobileonline.telia.com) (Connection reset by peer)
[02:38:48] <strcat> could submit a patch to LLVM
[02:39:00] <acrichto> brson: I didn't even see the valgrind error so that probably means you should :)
[02:39:18] <cmr> http://cmr.github.io/blog/2013/06/30/structure-and-organisation-of-rustc/ sufficiently complete for me to check it off my todo list.
[02:39:44] <brson> looks like the new doc upload is working
[02:39:49] *** Quits: Sorella (queen@9D963F5D.DF5D8AE7.54BCAB54.IP) (Quit: G'night everynyan~!)
[02:40:02] <brson> acrichto: ok
[02:40:04] <acrichto> brson: yay!
[02:40:57] <brson> the way docs work now though there will be a brief moment every commit where the docs don't exist ...
[02:41:01] <erickt> sfackler: ping
[02:41:11] <aatch> cmr, I like how translation is pretty much just "here be dragons"
[02:41:35] <cmr> aatch: yeah basically that's how I feel about it :p
[02:41:55] <erickt> and dbaupp: ping
[02:42:15] <luisbg> let n = rand::random::<int>()
[02:42:23] <luisbg> rusti: let n = rand::random::<int>()
[02:42:28] -rusti- <anon>:8:4: 8:5 error: expected `;` but found `}`
[02:42:28] -rusti- <anon>:8     };
[02:42:28] -rusti-              ^
[02:42:28] -rusti- application terminated with error code 101
[02:42:34] <luisbg> rusti: let n = rand::random::<int>();
[02:42:39] -rusti- pastebinned 11 lines of output: http://sprunge.us/iWJA
[02:42:43] <cmr> luisbg: you can query rusti
[02:43:19] <luisbg> cmr, like how?
[02:43:25] <luisbg> ooooh
[02:43:27] <luisbg> you mean in private
[02:43:42] <cmr>  /query rusti
[02:43:42] <engla> and the module is called std::rand
[02:43:44] <luisbg> just wanted to comment how weird the syntax to generate a random integer looks like
[02:43:55] <luisbg> engla, yeah, first time using rusti. missed that
[02:44:15] *** Quits: kimundi (kimundi@moz-19BC658F.dip0.t-ipconnect.de) (Ping timeout)
[02:44:24] <engla> the Rng value has a method called something like gen_int_range()
[02:44:32] <cmr> luisbg: well if the type can be infered you don't need the type hint.
[02:44:35] <luisbg> engla, ooh. let me look
[02:46:03] <engla> if std::rand::random() { }  // is valid and inferred to return bool
[02:46:13] *** Joins: lex (lex@moz-12347B81.bootp.virginia.edu)
[02:47:42] *** Joins: kimundi (kimundi@moz-ED244214.dip0.t-ipconnect.de)
[02:48:40] <mcpherrin> speaking of randoms, is there a reason rust doesn't just read from /dev/urandom?
[02:48:47] <mcpherrin> instead implementing Isaac?
[02:49:01] <cmr> mcpherrin: it's slow
[02:49:18] <engla> each task needs its own Rng too
[02:49:38] <cmr> Although the slowness part was really due to using a CSPRNG when we didn't need one.
[02:50:08] <cmr> Though seeding from urandom was a huge slowdown and a point of heavy contention in the profiles.
[02:50:16] <strcat> cmr: isaac is still a CSPRNG
[02:50:20] *** Quits: samx (sami@moz-D9DA5773.dyn.optonline.net) (Quit: This computer has gone to sleep)
[02:50:28] <cmr> strcat: we were using isaac, seeded from urandom.
[02:50:34] <strcat> what are we using now?
[02:50:39] <cmr> xorshift.
[02:51:02] <strcat> so, hash tables are no longer secure against DoS?
[02:51:03] <acrichto> brson: http://static.rust-lang.org/doc/master/tutorial.html is missing?
[02:51:05] <strcat> when did we change it?
[02:51:13] <engla> no?
[02:51:15] <cmr> wasn't in hash tables, it was in the runtime.
[02:51:16] <engla> pub fn task_rng() -> @mut IsaacRng
[02:51:27] <cmr> I'm not talking about the task rng
[02:51:31] <strcat> oh
[02:52:05] *** kimundi is now known as zz_kimundi
[02:53:06] <aatch> rng returns IsaacRng and weak_rng returns XorShiftRng
[02:53:36] <mcpherrin> We should probably have an os_rng too, using /dev/urandom on *nix systems and whatever the CryptRngThing on windows is
[02:53:43] <cmr> mcpherrin: Why?
[02:54:00] <mcpherrin> cmr: Generating random data securely is hard, and your OS does it right
[02:54:02] <strcat> aatch: yup, it eliminates bounds checks if I do this
[02:54:23] <engla> cmr: so what is using xorshift? The seed for Isaac?
[02:54:30] <strcat> aatch: http://ix.io/88v storing size as bytes
[02:55:02] <cmr> engla: the workstealing rng iirc.
[02:55:06] <strcat> hrm
[02:55:17] <aatch> mcpherrin, then you probably want to read from /dev/random, not /dev/urandom
[02:55:23] <engla> oh ok
[02:55:39] <mcpherrin> aatch: Myths of a time long past.
[02:55:52] *** Joins: lkuper__ (lkuper@BAE96B56.1C5FF2E6.51B6877.IP)
[02:55:54] <cmr> Unless you're on android
[02:56:04] <cmr> Trusting the OS is kinda silly.
[02:56:10] <strcat> mcpherrin: ISAAC is fine
[02:56:19] <strcat> it's not a complex algorithm
[02:56:36] *** Joins: DAddYE (DAddYE@moz-98D3933F.hsd1.ca.comcast.net)
[02:56:44] <strcat> we're seeding it from /dev/urandom
[02:57:34] <brson> acrichto: yes it is
[02:57:41] *** Quits: lkuper__ (lkuper@BAE96B56.1C5FF2E6.51B6877.IP) (Ping timeout)
[02:57:47] <strcat> although it might be a bad idea to use RDRAND
[02:58:15] *** Joins: eatkinson (eatkinson@moz-261EDE03.hsd1.ca.comcast.net)
[02:58:28] *** Parts: eatkinson (eatkinson@moz-261EDE03.hsd1.ca.comcast.net) ()
[02:58:46] <mcpherrin> Using RDRAND directly *may possibly* be insecure, though highly unlikely
[02:59:03] <brson> acrichto: the bot that built those docs doesn't have node installed!
[02:59:04] *** zz_kimundi is now known as kimundi
[02:59:20] <strcat> mcpherrin: no one can audit it, so you can't really say it's unlikely
[02:59:35] <lex> Hi, student with rust 0.7 here again. I'm trying to reassign standard input and standard output. Nothing in the documentation jumped out at me. Ideas?
[02:59:52] <lex> I'd hoped that std::os would have something.
[03:00:16] <strcat> they pass it through AES with a secret key, so for all we know the RNG could just go seed, seed + 1, seed + 2, ...
[03:00:26] <cmr> lex: you'll have to call freopen through libc
[03:00:42] *** Quits: erickt (Adium@49C4075F.3AC15C18.2321E71E.IP) (Quit: Leaving.)
[03:00:47] *** Quits: DAddYE (DAddYE@moz-98D3933F.hsd1.ca.comcast.net) (Ping timeout)
[03:00:48] <lex> cmr: thanks!
[03:01:14] <mcpherrin> strcat: Right, but even if the NSA has that key, you'd have to be using RDRAND directly for it to be a vulnerability
[03:01:46] <mcpherrin> Ideally you'd be using a secure hash on your raw entropy to produce your CSPRNG
[03:01:50] *** Parts: lex (lex@moz-12347B81.bootp.virginia.edu) ()
[03:01:59] <mcpherrin> which, incidentally, is what /dev/random does
[03:02:16] <ww> is it possible to declare a [u8] array on the stack?
[03:02:29] <strcat> ww: yes
[03:02:34] <strcat> but [u8] isn't a type
[03:02:35] <ww> :)
[03:02:43] <ww> yes!  problem.
[03:02:45] <strcat> rusti: let xs = [0u8, 1, 2, 3]; xs
[03:02:46] -rusti- [0u8, 1u8, 2u8, 3u8]
[03:02:53] <strcat> the type is [u8, ..4]
[03:03:09] <strcat> it will coerce to &[u8]
[03:03:12] * mcpherrin still likes the old fixed length vector syntax more
[03:03:29] <ww> that's great!  was trying to avoid excessive heap allocation
[03:04:22] <cmr> rusti: let xs = &[1, 2, 3]; println!("{}", xs);
[03:04:24] -rusti- pastebinned 10 lines of output: http://sprunge.us/YOaf
[03:04:39] <cmr> rusti: let xs = &[1, 2, 3]; println!("{:?}", xs);
[03:04:40] -rusti- &[1, 2, 3]
[03:04:41] -rusti- ()
[03:04:51] <ww> thx
[03:04:58] *** Joins: DAddYE (DAddYE@moz-98D3933F.hsd1.ca.comcast.net)
[03:05:35] <engla> rustc can warn you for each allocation, I think that's pretty interesting.  rustc -W heap-memory
[03:05:53] <strcat> but not ones from libstd
[03:06:01] <ww> ok
[03:06:09] *** Quits: rust-buildbot (rust-build@505BFA3.C3CCCE8C.D25A875A.IP) (Quit: buildmaster reconfigured: bot disconnecting)
[03:06:09] *** Joins: rust-buildbot (rust-build@505BFA3.C3CCCE8C.D25A875A.IP)
[03:06:39] <brson> starting another doc build
[03:08:49] *** Joins: infynyxx (infynyxx@DB780A29.749BA1D.DCC373F0.IP)
[03:10:26] <luisbg> good night everyone :)
[03:10:30] *** Quits: infynyxx (infynyxx@DB780A29.749BA1D.DCC373F0.IP) (Ping timeout)
[03:11:52] *** Quits: DAddYE (DAddYE@moz-98D3933F.hsd1.ca.comcast.net) (Client exited)
[03:12:22] *** Joins: DAddYE (DAddYE@moz-98D3933F.hsd1.ca.comcast.net)
[03:14:02] *** Quits: DAddYE (DAddYE@moz-98D3933F.hsd1.ca.comcast.net) (Ping timeout)
[03:15:11] *** Joins: lkuper__ (lkuper@3144E964.FFCF2A3B.51B6877.IP)
[03:15:12] *** Joins: DAddYE (DAddYE@moz-98D3933F.hsd1.ca.comcast.net)
[03:16:07] <ww> question: i have a mut variable, pass it to an immutable function as a ref.  does the mut variable become immutable after the immu call?
[03:16:40] <ww> because if i pass it to anther mut function, compiler complains
[03:17:12] <strcat> ww: example?
[03:17:31] *** Joins: maxli (maxli@moz-A607CA26.student.cs.uwaterloo.ca)
[03:17:36] <ww> sequence is:  let mut foo;  immu_func1(&foo);  mut_func2(&foo)
[03:17:58] *** Quits: maxli (maxli@moz-A607CA26.student.cs.uwaterloo.ca) (Input/output error)
[03:18:00] <strcat> &foo is an immutable reference
[03:18:07] <strcat> you need &mut to take a mutable reference
[03:18:12] *** Joins: maxli (maxli@moz-A607CA26.student.cs.uwaterloo.ca)
[03:18:37] <ww> mismatched types: expected `&mut rustymem_lib::binary_conn::PacketHeader` but found `rustymem_lib::binary_conn::PacketHeader
[03:19:05] <strcat> what's the signature of the function and what type do you have
[03:19:18] <ww> oh i see.  the first let mut foo doesn't make &foo mutable
[03:19:31] <strcat> yeah, &T is an immutable ref
[03:19:34] *** Quits: anshin (anshin@CD85F10D.F21429E2.354459FA.IP) (Connection reset by peer)
[03:19:34] <strcat> &mut T is a mutable ref
[03:19:35] <ww> fn read_header(&mut self, header: &mut PacketHeader)
[03:19:43] <ww> fn write_header(&mut self, header: &PacketHeader)
[03:19:44] *** Joins: anshin (anshin@CD85F10D.F21429E2.354459FA.IP)
[03:20:18] <ww> let mut header;  read_header(&header);  write_header(&header)
[03:20:24] <mcpherrin> rusti: ~[1,2,3] == ~[1,2,3]
[03:20:25] -rusti- true
[03:20:44] <strcat> ww: you need write_header(&mut header)
[03:20:50] <mcpherrin> ^ is equality on vectors pairwise or identity?
[03:20:50] <ww> sorry, wrong order.  write_header(&header);  read_header(&header)
[03:21:03] <ww> ok, thanks
[03:21:21] <mcpherrin> rusti: let mut x = ~[1,2,9]; x[2]=3; x == ~[1,2,3]
[03:21:22] -rusti- true
[03:21:31] <ww> i made it work by adding the &mut header.  was just wondering why it was needed.
[03:22:02] <strcat> mcpherrin: the only address equality is for raw pointers
[03:22:04] <ww> thanks for the explanation
[03:22:25] *** Quits: maxli (maxli@moz-A607CA26.student.cs.uwaterloo.ca) (Ping timeout)
[03:22:38] <mcpherrin> strcat: okay, cool.  As a C-family programmer, I don't trust the == operator :-P
[03:22:52] *** Joins: vodik (simon@moz-CBE4BB13.cable.teksavvy.com)
[03:25:40] <acrichto> brson: aha that got it, it's back
[03:25:47] <engla> mcpherrin: a type implements the trait Eq to support ==
[03:26:16] <mcpherrin> engla: right, I just didn't know what ~[T] did :P
[03:29:54] *** Joins: erickt (Adium@49C4075F.3AC15C18.2321E71E.IP)
[03:30:56] *** Joins: ghrust (ghrust@24260B07.6A2AE50.F3114085.IP)
[03:30:56] <ghrust> 01[13rust01] 15bors merged 06auto into 06master: 02http://git.io/m_dMYw
[03:30:56] *** Parts: ghrust (ghrust@24260B07.6A2AE50.F3114085.IP) ()
[03:31:18] *** Quits: josh (josh@moz-348C4790.hsd1.mn.comcast.net) (Quit: josh)
[03:34:55] *** Joins: geomyidae (quassel@DD6F7E3A.21468E9A.30200F38.IP)
[03:35:54] *** Quits: lkuper__ (lkuper@3144E964.FFCF2A3B.51B6877.IP) (Ping timeout)
[03:35:56] *** Joins: ghrust (ghrust@F6EE6DE3.6A2AE50.F3114085.IP)
[03:35:56] <ghrust> 01[13rust01] 15bors pushed 0 new commits to 06auto: 02http://git.io/Jyoj6A
[03:35:56] *** Parts: ghrust (ghrust@F6EE6DE3.6A2AE50.F3114085.IP) ()
[03:35:57] *** Joins: ghrust (ghrust@DE823A67.6A2AE50.F3114085.IP)
[03:35:57] <ghrust> 01[13rust01] 15bors pushed 2 new commits to 06auto: 02http://git.io/UcwMvA
[03:35:57] <ghrust> 13rust/06auto 14af72e41 15David Creswick: Generate random big integers within a range...
[03:35:57] <ghrust> 13rust/06auto 144c6bf48 15bors: auto merge of #9133 : dcrewi/rust/bigint-random-range, r=huonw
[03:35:57] *** Parts: ghrust (ghrust@DE823A67.6A2AE50.F3114085.IP) ()
[03:36:16] *** Quits: erickt (Adium@49C4075F.3AC15C18.2321E71E.IP) (Quit: Leaving.)
[03:36:30] *** Quits: hjr3 (hradtke@374E545A.3A8E9B0C.F9D9C60E.IP) (Quit: My MacBook has gone to sleep. ZZZzzzâ€¦)
[03:37:52] *** Quits: Earnestly (earnest@moz-BE290A2B.dyn.plus.net) (Ping timeout)
[03:41:27] <jstevans1> How do I convert from a rust string to a cstring?
[03:41:32] *** Joins: mihneadb (mihneadb@41E65AA5.B2E373EA.FCAAE698.IP)
[03:41:42] <acrichto> rusti: "test".to_c_str()
[03:41:42] -rusti- std::c_str::CString{buf: (0x7fa505c23058 as *()), owns_buffer_: true}
[03:42:01] <jstevans1> Sorry, in 0.7
[03:42:02] <acrichto> jstevans1: to_c_str() will create a CString instance, with_c_str() will give you a buffer
[03:42:09] <acrichto> jstevans1: oh I think it's as_c_str() ?
[03:42:22] <jstevans1> rusti: "test".as_c_str()
[03:42:22] <acrichto> I forget though...
[03:42:23] -rusti- <anon>:7:9: 8:5 error: type `&'static str` does not implement any method in scope named `as_c_str`
[03:42:23] -rusti- <anon>:7          "test".as_c_str()
[03:42:23] -rusti- <anon>:8     };
[03:42:23] -rusti- error: aborting due to previous error
[03:42:23] -rusti- application terminated with error code 101
[03:42:23] <nejucomo> I don't understand under what conditions CopyableVector.into_owned() works...
[03:42:38] <nejucomo> Ohâ€¦  For the ~[T] impl, I suppose?
[03:42:49] <acrichto> nejucomo: how so?
[03:42:52] <nejucomo> (Where T: Clone)
[03:42:59] <acrichto> nejucomo: `self` has type `&'self [T]`
[03:43:03] <mcpherrin> strcat: Would having a rusti-0.7 bot be possible?  Might be useful for the OS-people
[03:43:12] <mcpherrin> Dunno what the maintenance burden is
[03:43:17] *** Quits: mihneadb (mihneadb@41E65AA5.B2E373EA.FCAAE698.IP) (Ping timeout)
[03:43:19] <nejucomo> I mean, the doc string says "not making a copy if possible".
[03:43:32] <jstevans1> Sorry, better phrased: I know the method signature is fn as_c_str<T>(s: &str, f: &fn(*libc::c_char) -> T) -> T, but I don't know what that method signature is saying...
[03:43:33] <cmr> I thought the zapto interface allowed version picking at some point.
[03:43:47] <strcat> it does
[03:43:57] <nejucomo> How can an own pointer be returned without making a copy?
[03:44:08] <cmr> jstevans1: it takes a string and a closure, passes the pointer to the C string to the closure, the closure returns some type, and as_c_str returns what the closure returns.
[03:44:13] <acrichto> jstevans1: ah, you would do something like "do str::as_c_str("my string") |c_buffer| { /* use c_buffer */ }"
[03:44:13] <strcat> nejucomo: return it, it won't make a copy
[03:44:24] <acrichto> jstevans1: the c_buffer variable is a null-terminated string
[03:44:39] <strcat> nejucomo: rust only has shallow copies in the language
[03:44:43] <nejucomo> strcat: do you mean for the impl<T: Clone> ~[T]   ?
[03:44:55] <acrichto> nejucomo: I think that documentation may be lsightly out of date
[03:45:05] <jstevans1> That makes sense. Thanks, cmr and acrichto!
[03:45:07] <strcat> nejucomo: that's a library feature
[03:45:22] <nejucomo> So, for example, for impl<T: Clone> @[T], it's obvious it must make a copy, right?
[03:45:36] <strcat> nejucomo: Clone isn't how the language does by-value pass/return
[03:45:40] <nejucomo> So in what cases does it not make a copy?  Is it only for the impl<T: Clone> ~[T]  ?
[03:46:11] <acrichto> nejucomo: nowadays it always calls .clone()
[03:46:15] <strcat> nejucomo: rust, the language, only does shallow copies - if the type has a destructor, it moves ownership
[03:46:35] <strcat> if you call clone, it will do the minimum possible work to create a new one from a reference - as shallow as possible, and no more
[03:46:46] *** Joins: Larry (larryfox@26EE99DC.88C61CC9.ECED8BE3.IP)
[03:46:50] <strcat> which for ~T, means an allocation
[03:47:31] <strcat> rusti: fn foo(x: ~int) -> ~int { x } /* there are no allocations performed in that function */
[03:47:32] -rusti- ()
[03:47:41] <Eridius> rusti: '\q'
[03:47:42] -rusti- <anon>:6:12: 6:13 error: unknown character escape: 113
[03:47:42] -rusti- <anon>:6     let r = {
[03:47:42] -rusti-                      ^
[03:47:42] -rusti- application terminated with error code 101
[03:47:47] *** Quits: geomyidae (quassel@DD6F7E3A.21468E9A.30200F38.IP) (Client exited)
[03:47:55] <strcat> rusti: fn foo(x: ~int) -> ~int { x } let x = ~5; foo(x)
[03:47:56] -rusti- ~5
[03:48:04] <strcat> the only allocation there is 'let x = ~5'
[03:48:29] <nejucomo> strcat: So it sounds like you are saying that for the ~[T] impl of CopyableVector, there's no need for a copy.
[03:48:54] <strcat> nejucomo: what do you mean the ~[T] impl?
[03:49:20] <nejucomo> I mean specifically this impl: http://static.rust-lang.org/doc/master/std/vec.html#implementation-of-copyablevectort-for-t-where-t-clone
[03:49:44] <strcat> to_owned takes &self
[03:49:50] <strcat> it calls Clone, since it can't move from it
[03:49:56] <strcat> into_owned is a no-op
[03:50:09] <strcat> it takes a pointer and returns a pointer, it doesn't allocate
[03:50:14] <strcat>     #[inline(always)]
[03:50:16] <strcat>     fn into_owned(self) -> ~[T] { self }
[03:50:42] <nejucomo> Ok.  That makes sense.  For all other impls, a copy is made then.
[03:52:52] *** Joins: lkuper__ (lkuper@3144E964.FFCF2A3B.51B6877.IP)
[03:53:16] <Eridius> is it intentional behavior that one can embed a literal newline in a char constant?
[03:53:39] <strcat> Eridius: it's reported
[03:53:44] <Eridius> strcat: is it considered an issue?
[03:53:49] <strcat> don't know
[03:54:10] * Eridius is trying to add support for 'FOUR' constants, as an alternative to fourcc!(), and is tempted to block literal newlines or carriage returns in char constants
[03:54:32] <nejucomo> rusti: { let x = ~[1, 2, 3]; x.slice(0, 1).to_owned() }
[03:54:33] -rusti- ~[1]
[03:54:51] <strcat> that allocates
[03:54:55] *** Quits: lkuper__ (lkuper@3144E964.FFCF2A3B.51B6877.IP) (Ping timeout)
[03:55:16] <nejucomo> strcat: I want to have two owned vectors, one a copy of a subset of the other...
[03:55:34] <strcat> by definition an owned vector owns the contents, so that requires a copy
[03:56:01] <strcat> the return value of x.slice(0, 1) is &[int]
[03:56:09] <strcat> you can use that, if you want a subset of the vector
[03:56:32] <nejucomo> However, I have a borrows lifetime failure for code that looks similar to the rusti expression I just tried.  The culprit line is: f().slice(0, 1).to_owned(), where f is fn() -> ~[T]
[03:56:41] *** Quits: tikue (quassel@moz-FEADCD38.hsd1.pa.comcast.net) (Ping timeout)
[03:57:01] <engla> Eridius: https://github.com/mozilla/rust/issues/7053 here's the issue
[03:57:16] <Eridius> engla: there's also https://github.com/mozilla/rust/issues/7945
[03:57:40] <strcat> nejucomo: you need to store the return value of f() somewhere
[03:57:58] <engla> Eridius: the latter one is interesting, not necessarily invalid
[03:58:03] <engla> rusti: '''
[03:58:04] -rusti- '\''
[03:58:05] <strcat> nejucomo: temporaries currently get destroyed right away
[03:58:05] <Eridius> engla: disallowing literal newlines in strings is different than in character constants
[03:58:08] <strcat> their lifetime isn't extended
[03:58:10] <Eridius> yeah I thought ''' was curious as well
[03:58:34] <Eridius> engla: bstrie said if Java/C disallow certain character literals, being consistent may be a good idea. C disallows ''' (it treats '' as an empty character literal and throws an error)
[03:58:34] <engla> Eridius: oh, right, that's my misunderstanding
[03:58:35] <nejucomo> I see.  So lifetimes are kind of tied to bindings, and don't "live on the return stack"?
[03:59:10] * nejucomo wonders about f(g()) where g returns a borrowed pointer...
[03:59:16] *** Quits: bent|away (chatzilla@moz-932324BF.hsd1.ca.comcast.net) (Quit: ChatZilla 0.9.90.1-rdmsoft [XULRunner 22.0/20130619132145])
[03:59:31] <strcat> nejucomo: the problem is that you're taking a reference to a temporary
[03:59:52] <strcat> moving out of a temporary works
[04:00:40] <strcat> and yes lifetimes are tied to bindings
[04:00:51] <nejucomo> Ok.  That helps simplify my mental model...
[04:01:13] <strcat> .slice() is doing a borrow
[04:01:22] <strcat> of the actual temporary value
[04:01:38] <engla> if you are slicing a ~[T] in this case, you can in fact .truncate(1) instead.
[04:01:43] <strcat> (temporaries may end up defined as having their lifetimes extended, but they aren't yet)
[04:01:47] <nejucomo> strcat: I believe I understand the lifetime issue now.
[04:02:38] <nejucomo> Ok.  It's not clear to me in what ways they could be extended, although f(g()) or g().foo() are easy base cases, I wouldn't be surprised if there are counterintuitive cases that would make things complex or confusing.
[04:02:41] <nejucomo> -or impossible.
[04:03:25] * nejucomo imagines automatic translation of composition: f(g()) always becomes { let x = g(); f(x) }
[04:03:43] <jstevans1> What are valid values for oflag in libc::open as of 0.7?
[04:04:06] <nejucomo> Anyway, I kind of like simplifying restrictions like "borrowing checks are always based on bindings".
[04:04:13] <strcat> jstevans1: it's just a binding to libc, very unlikely you want to use it
[04:05:16] <strcat> nejucomo: what C++ does is extend a temporary's lifetime to the expression it's part of
[04:05:37] <strcat> and *also* extends it as long as there's a const& reference (which is very unintuitive and error-prone)
[04:05:41] *** Joins: robertknight (robertknig@moz-54528EE0.wby.mendeley.com)
[04:06:30] <brson> i sort of forgot i was supposed to be debugging the valgrind problem
[04:06:44] <jstevans1> strcat: what should I use instead? I want to redirect a Process's output to a file
[04:07:21] *** Quits: robertknight (robertknig@moz-54528EE0.wby.mendeley.com) (Ping timeout)
[04:07:22] *** Joins: SingingBoyo (singingboy@DAC9C672.CE76D40F.4F048BDC.IP)
[04:07:34] *** Quits: ww (Mibbit@moz-9D1D3E.public.wayport.net) (Quit: http://www.mibbit.com ajax IRC Client)
[04:07:44] *** Joins: maik (maik@moz-FECBC48.dip0.t-ipconnect.de)
[04:08:08] <strcat> jstevans1: well I guess you're doing to end up using libc then, *shrug*
[04:08:12] <strcat> std::run is very awful
[04:08:26] <jstevans1> Is there a better way to run another program within my program?
[04:08:29] <jstevans1> in 0.7^
[04:08:32] <acrichto> strcat: libuv bindings are about to land :), although they're not exactly usable...
[04:08:49] <acrichto> brson: what was the valgrind failure?
[04:09:08] *** Joins: infynyxx (infynyxx@DB780A29.749BA1D.DCC373F0.IP)
[04:09:10] *** Joins: lex (lex@moz-12347B81.bootp.virginia.edu)
[04:09:24] <acrichto> the linux snapshot looks like it just randomly failed and the mac one looks like it failed two tests
[04:09:42] <nejucomo> Why does the doc generator include text for impls of a trait, instead of just a link to the trait?  The haskell docs are much more concise by just listing the instances...
[04:10:16] <acrichto> nejucomo: the docs are a known pain point, but they'll be getting better soon though!
[04:10:34] *** Quits: Ralith (ralith@moz-A7071297.customer.broadstripe.net) (Ping timeout)
[04:10:44] <brson> acrichto: from_c_str_multistring is reading an uninitialized byte
[04:10:48] *** Quits: infynyxx (infynyxx@DB780A29.749BA1D.DCC373F0.IP) (Ping timeout)
[04:11:07] <olsonjeffery> brson: ack!
[04:11:16] <acrichto> brson: ah you have to search fo the failure...
[04:11:18] <olsonjeffery> is that from my change?
[04:11:26] <olsonjeffery> i added that..
[04:11:42] <strcat> nejucomo: http://seld.be/rustdoc/master/std/index.html
[04:11:48] <brson> olsonjeffery: the uv call to the multistring function is incorrect somehow
[04:12:03] <olsonjeffery> :/
[04:12:25] <olsonjeffery> so this is within get_paths() ?
[04:12:36] <nejucomo> Oohâ€¦  that is nicer.
[04:12:38] <acrichto> olsonjeffery: looks like it reads invalidly if count == 0 ? could that happen?
[04:12:43] <acrichto> olsonjeffery: http://buildbot.rust-lang.org/builders/snap3-linux/builds/524/steps/test/logs/stdio
[04:12:44] <jstevans1> if I use std::libc::funcs::c95::stdio::foreign_mod::fopen, will I actually get a *FILE back, or will it still be a c_int?
[04:12:45] <nejucomo> Thanks strcat!
[04:12:45] <brson> olsonjeffery: yeah, i suspect it's just a matter of changing the order of the loop head condition to avoid a read past the end of the buffer
[04:12:51] * brson trying now
[04:13:18] <nejucomo> Last time I was sniffing around rust, crate had a centralized list of packages.  Is there any such central repository these days?
[04:13:33] <strcat> nejucomo: not atm
[04:13:56] *** Joins: Ralith (ralith@moz-A7071297.customer.broadstripe.net)
[04:14:30] *** Quits: Larry (larryfox@26EE99DC.88C61CC9.ECED8BE3.IP) (Quit: My MacBook Pro has gone to sleep. ZZZzzzâ€¦)
[04:14:32] <strcat> did we ever decide if we were going to remove `float`?
[04:14:35] <olsonjeffery> acrichto: is this within the context of the readdir() test or some new use?
[04:14:52] *** Joins: lkuper__ (lkuper@BAE96B56.1C5FF2E6.51B6877.IP)
[04:14:58] <acrichto> olsonjeffery: async callbacks have bad backtraces :(, it's in fs_readdir though
[04:15:30] <olsonjeffery> i see it
[04:15:38] <olsonjeffery> yeah.. test passes
[04:15:46] <olsonjeffery> but valgrind gets mad
[04:15:47] <nejucomo> I'm writing unittests that have exposed a bug with an assert_eq!â€¦  Is there any way to generate a stack trace?  -or is there a debugger?
[04:15:50] <olsonjeffery> i wonder if its a false positive
[04:15:58] <olsonjeffery> because its a multistring with a double \0 delimiter?
[04:16:20] <olsonjeffery> like "foo\0bar\0baz\0\0"
[04:16:29] <strcat> nejucomo: rust will work with gdb
[04:16:30] <acrichto> olsonjeffery: what if it was "" with limit = 0?
[04:16:37] <strcat> nejucomo: you need -Z debug-info
[04:16:48] <acrichto> nejucomo: if you don't want to recompile, break on rust_begin_unwind
[04:16:52] *** Quits: mark_edward (quassel@moz-97E995A.hsd1.in.comcast.net) (Ping timeout)
[04:17:08] <nejucomo> Ah, interesting.  This SO thread makes it sound like gdb is possible: http://stackoverflow.com/questions/15871885/how-to-debug-rust-programs
[04:17:19] <nejucomo> Oh.  Nice!
[04:17:19] <olsonjeffery> acrichto: i wonder if its the deref in the while check
[04:17:25] <olsonjeffery> like brson said.. switch the order around
[04:17:28] <acrichto> yeah
[04:17:31] <olsonjeffery> because it shouldn't enter the while loop
[04:17:52] <acrichto> nejucomo: -Z debug-info is the best way if it works, but it has a tendency to segfault the compiler...
[04:18:03] <acrichto> and if you're really brave there's -Z extra-debug-info !
[04:18:15] <acrichto> we still have yet to add -Z all-the-debug-info
[04:18:31] *** Quits: rusti (rusti@moz-54F7FD49.cpe.net.cable.rogers.com) (Ping timeout)
[04:18:39] *** Quits: DAddYE (DAddYE@moz-98D3933F.hsd1.ca.comcast.net) (Ping timeout)
[04:18:41] *** Joins: DAddYE (DAddYE@moz-98D3933F.hsd1.ca.comcast.net)
[04:18:42] <engla> olsonjeffery: I don't think you need strlen, you have the length from the ~str you get in the loop. Just to remove the libc call
[04:18:45] <olsonjeffery> -Z LETS-BURN-THIS-MOTHER-DOWN-WOOOOOOOOOOOOOO
[04:19:00] <acrichto> olsonjeffery: all branches have a 0.01% chance of failing
[04:19:09] <acrichto> or rather going the wrong direction
[04:19:10] *** Joins: nsf (nsf@moz-EEF3238A.convex.ru)
[04:19:18] *** Quits: strcat (strcat@moz-54F7FD49.cpe.net.cable.rogers.com) (Ping timeout)
[04:19:23] *** Joins: strcat (strcat@moz-54F7FD49.cpe.net.cable.rogers.com)
[04:19:48] <strcat> my hard drive is failing :(
[04:20:06] <olsonjeffery> strcat: dude. i know that feel bigtime.. just last week, my mbp battery failed
[04:20:11] <olsonjeffery> went in, got it fixed
[04:20:16] <strcat> it gets stuck on reads
[04:20:21] <strcat> then marks the sectors as pending
[04:20:21] <olsonjeffery> then i asked them to reimage snow leopard on my machine
[04:20:25] <strcat> then decides they are okay again
[04:20:26] <olsonjeffery> and they told me the HD had failed too :/
[04:20:30] <acrichto> strcat: have you tried turning it on and off again?
[04:20:37] <olsonjeffery> and sincec id replaced it, they wouldnt touch it (this is the apple store)
[04:20:38] <strcat> acrichto: well that's the only choice when it totally locks
[04:20:40] <strcat> ;p
[04:20:44] <olsonjeffery> altogether a great customer service experience
[04:20:45] *** Quits: DAddYE (DAddYE@moz-98D3933F.hsd1.ca.comcast.net) (Client exited)
[04:20:46] <acrichto> :( sry about that
[04:21:01] <olsonjeffery> but scrambling for a new HD was lame. had to get a 5400 rpm ;_;
[04:21:10] *** Joins: lenstr (lenstr@AF8EB999.6049B16A.85938D85.IP)
[04:21:13] <strcat> it corrupted a 16 byte block of my zsh history
[04:21:15] <strcat> o_O
[04:21:17] <olsonjeffery> ssd on the way, though
[04:21:21] <strcat> changed it to NULs
[04:21:28] *** Quits: lenstr (lenstr@AF8EB999.6049B16A.85938D85.IP) (Client exited)
[04:21:36] <acrichto> that's terrifying
[04:21:46] <acrichto> I dunno, maybe the NSA finally caught on to you
[04:21:49] <jstevans1> rusti: let myFD = myPathStr.as_c_str(|pathCStr| {myModeStr.as_c_str(|modeCStr| { std::libc::funcs::c95::stdio::foreign_mod::fopen(pathCStr,modeCStr) })});
[04:22:23] *** Joins: lenstr (lenstr@AF8EB999.6049B16A.85938D85.IP)
[04:25:09] <brson> olsonjeffery: switching the order of the while loop condition fixes it
[04:25:16] <olsonjeffery> HUZZAH
[04:25:17] <strcat> acrichto: I ran a SMART test and it stalled
[04:25:20] <strcat> :s
[04:25:24] <olsonjeffery> brson: add a test for empty dir check?
[04:25:34] <acrichto> brson: \o/ r=me
[04:26:35] <olsonjeffery> and for the record: i didn't actually write from_c_multistring().. that's the old guts of the win32 string parsing in os::env()
[04:26:42] <olsonjeffery> but it is what it is
[04:26:45] <engla> aha
[04:26:50] <brson> olsonjeffery: you're absolved
[04:27:02] <olsonjeffery> so that's "multistring" parsing logic, as alluded to above
[04:27:08] <brson> olsonjeffery: what do you mean by empty dir check?
[04:27:18] <engla> it shouldn't call libc::strlen
[04:27:23] <olsonjeffery> brson: so in order to repro the situation that acrichto mentions above
[04:27:35] *** Joins: mark_edward (quassel@moz-97E995A.hsd1.in.comcast.net)
[04:27:38] *** Joins: rusti (rusti@moz-54F7FD49.cpe.net.cable.rogers.com)
[04:27:56] <olsonjeffery> you could have a test that is basically: `let p = &Path("./tmp/empty_dir");dir.mkdir();let r = dir.readdir();dir.rmdir();
[04:28:02] <olsonjeffery> the readdir() call should fail w/o your fix
[04:28:08] <olsonjeffery> or it won't fail
[04:28:10] <olsonjeffery> but it's valgrind unclean
[04:28:28] <acrichto> not with the inversion of the checks though, right?
[04:28:32] <olsonjeffery> yes.
[04:28:40] <olsonjeffery> because in that case, it checks that libuv says there're zero entries
[04:28:48] <olsonjeffery> and the && short-circuits before it derefs
[04:29:08] <acrichto> I wonder how bad a language would be if && and || didn't short-circuit...
[04:29:19] * acrichto eyes trans...
[04:29:24] <strcat> mcpherrin: the problem with making a stable branch of rusti is that it's going to become 0.8 anyway
[04:29:32] <hoverbear> Heh. Shoot. I have a C question.
[04:29:42] <sfackler> erict: pong
[04:31:21] <olsonjeffery> excuse me.
[04:31:31] <olsonjeffery> let dir = &Path("./tmp/empty_dir");
[04:31:48] <olsonjeffery> strcat: so how often is the version of master that rusti hits rebuilt?
[04:31:53] <strcat> daily
[04:31:57] * olsonjeffery nods
[04:31:59] *** Quits: lkuper__ (lkuper@BAE96B56.1C5FF2E6.51B6877.IP) (Ping timeout)
[04:31:59] <strcat> rusti: version
[04:32:02] -rusti- "rustc 0.8-pre (0ec4d34 2013-09-16 11:30:42 -0700)"
[04:32:12] <olsonjeffery> do you have anything in place to sandbox-out certain modules?
[04:32:25] <strcat> it runs in a secure application sandbox as a whole
[04:32:27] <olsonjeffery> i guess the chroot jail is something
[04:32:28] <strcat> including the compiler
[04:32:34] <strcat> olsonjeffery: more than a chroot
[04:33:13] <strcat> chroot + namespaces + MS_PRIVATE mounts + read-only fs + whitelist of syscalls/devices + cgroup for reliably killing it and any forked processes and limiting memory
[04:33:13] <Eridius> well damn, I don't think 'FOUR' is actually syntactically compatible with lifetimes
[04:33:33] <olsonjeffery> nice.
[04:33:40] <Eridius> 'foo ' could be a 4-char constant, or it could be the start of `'foo 'bar`, which is two lifetimes in a row (which isn't valid, but w/e)
[04:33:45] <Eridius> I can't lex this
[04:33:47] <strcat> olsonjeffery: https://github.com/thestinger/playpen + https://github.com/thestinger/rust-playpen is everything but the python irc script
[04:34:33] *** Quits: Yeri (jasonjasmi@41C91A8A.CE609BA5.E39FBF79.IP) (Quit: Yeri)
[04:34:59] <strcat> rusti: print(std::str::from_utf8(std::run::process_output("ps", [~"ax"]).output))
[04:35:00] -rusti-   PID TTY      STAT   TIME COMMAND
[04:35:00] -rusti-     1 ?        Ssl    0:00 ./out
[04:35:00] -rusti-    23 ?        R      0:00 ps ax
[04:35:00] -rusti- ()
[04:35:19] <strcat> that's from pid namespacing, for example
[04:35:36] <strcat> in /proc/self/ns the namespaces are listed
[04:35:40] *** Quits: maik (maik@moz-FECBC48.dip0.t-ipconnect.de) (Ping timeout)
[04:35:42] <acrichto> that's slick
[04:36:21] *** Quits: voxpopuli (fanservice@moz-CEF3689A.hsd1.pa.comcast.net) (Ping timeout)
[04:36:46] <olsonjeffery> speaking of sandboxing, there was a post on HN that never made it to the frontpage about a server-appliance OS meant to run in vms called OSv
[04:37:08] <olsonjeffery> this: mailman.cs.huji.ac.il/pipermail/linux-il/2013-September/010649.html
[04:37:32] <olsonjeffery> don't know much at all about it
[04:38:26] <olsonjeffery> but the last time i saw anything like this was Singularity OS
[04:39:07] *** Quits: lenstr (lenstr@AF8EB999.6049B16A.85938D85.IP) (Client exited)
[04:39:24] <olsonjeffery> buried lede: "OSv was developed by Cloudius Systems, a small Israeli startup led by
[04:39:27] <olsonjeffery> Dor Laor and Avi Kivity (of KVM fame)"
[04:39:53] *** Joins: geomyidae (quassel@DD6F7E3A.21468E9A.30200F38.IP)
[04:40:09] *** Joins: lenstr (lenstr@AF8EB999.6049B16A.85938D85.IP)
[04:40:54] <nejucomo> hrmâ€¦ gdb says: Reading symbols from /home/user/sandbox/rust/bitfifo/bitfifo...Dwarf Error: Cannot handle DW_FORM_sec_offset in DWARF reader [in module /home/user/sandbox/rust/bitfifo/bitfifo]
[04:41:00] *** Quits: Ralith (ralith@moz-A7071297.customer.broadstripe.net) (Ping timeout)
[04:41:29] <nejucomo> -that was with: rustc â€”test -Z debug-info bitfifo.rs ; gdb bitfifo
[04:41:43] *** Quits: KindOne (KindOne@moz-313EA646.dynamic.ip.windstream.net) (Ping timeout)
[04:42:10] <strcat> gdb might be too old
[04:42:21] *** Quits: canhtak (jeremy@moz-8CBCE134.wl.t.ulaval.ca) (Quit: canhtak)
[04:42:30] * strcat hasn't had problems with gdb 7.6.1
[04:43:35] <nejucomo> Yeahâ€¦  I'm on an ancient debian 6!
[04:43:37] *** Quits: Kruppe (user@moz-E150F49F.cpe.net.cable.rogers.com) (Client exited)
[04:44:04] <nejucomo> I should really upgrade, but I'm too busy playing with rust.  ;-)
[04:44:32] *** Joins: Ralith (ralith@moz-A7071297.customer.broadstripe.net)
[04:44:39] <nejucomo> rusti: 7u - 10u
[04:44:40] -rusti- 18446744073709551613u
[04:45:26] *** Joins: KindOne (KindOne@moz-2273B680.dynamic.ip.windstream.net)
[04:46:04] *** Joins: ghrust (ghrust@C8693FCB.6A2AE50.F3114085.IP)
[04:46:04] <ghrust> 01[13rust01] 15bors merged 06auto into 06master: 02http://git.io/UcwMvA
[04:46:04] *** Parts: ghrust (ghrust@C8693FCB.6A2AE50.F3114085.IP) ()
[04:47:47] <olsonjeffery> *unsafe code trombone*
[04:48:06] <SingingBoyo> rusti: format!("{}{}", ~"a", ~"b")
[04:48:07] -rusti- ~"ab"
[04:48:21] <strcat> ok I have to admit I don't understand why we have all this entry wrapper funny business
[04:48:31] <strcat> :s
[04:49:08] *** Joins: lkuper__ (lkuper@BAE96B56.1C5FF2E6.51B6877.IP)
[04:49:27] <olsonjeffery> bblum: ping
[04:49:32] <bblum> olsonjeffery: pong
[04:50:07] <heftig> strcat: what was the format of a string? length-uint + data?
[04:50:20] <strcat> heftig: ~str? or &str
[04:50:32] <aatch> strcat, I would very much like to fix that up.
[04:50:32] <heftig> strcat: str
[04:50:42] <strcat> heftig: str alone isn't actually a type
[04:50:43] <olsonjeffery> bblum: you're familiar w/ singularity, right? curious if you'd checked out OSv (that i linked above)
[04:50:52] *** Quits: lkuper__ (lkuper@BAE96B56.1C5FF2E6.51B6877.IP) (Ping timeout)
[04:50:56] <bblum> i know of singularity but i forget what it is
[04:50:58] <strcat> ~str is *{length, capacity, data[]}
[04:50:59] <Luqman> nejucomo: debian 6? and here i am thinking 7 is too old :P
[04:51:03] *** Joins: ghrust (ghrust@79968228.6A2AE50.F3114085.IP)
[04:51:03] <ghrust> 01[13rust01] 15bors pushed 0 new commits to 06auto: 02http://git.io/yevUSA
[04:51:03] *** Parts: ghrust (ghrust@79968228.6A2AE50.F3114085.IP) ()
[04:51:03] *** Joins: ghrust (ghrust@9C8B94D4.6A2AE50.F3114085.IP)
[04:51:03] <ghrust> 01[13rust01] 15bors pushed 2 new commits to 06auto: 02http://git.io/2TD4PA
[04:51:03] <ghrust> 13rust/06auto 14fd0fcba 15Brian Anderson: std: Fix an invalid read in from_c_multistring...
[04:51:03] <ghrust> 13rust/06auto 141eb8e3f 15bors: auto merge of #9281 : brson/rust/multistring, r=alexcrichton...
[04:51:04] *** Parts: ghrust (ghrust@9C8B94D4.6A2AE50.F3114085.IP) ()
[04:51:05] <strcat> where length/capacity are in bytes
[04:51:13] <olsonjeffery> bblum: oh wait, you didn't do proto!, huh...
[04:51:14] *** Quits: Ralith (ralith@moz-A7071297.customer.broadstripe.net) (Ping timeout)
[04:51:15] <olsonjeffery> that was eholk
[04:51:20] <strcat> and &str is {*data,len} iirc
[04:51:24] <bblum> olsonjeffery: yeah i know all about proto though
[04:51:31] <nejucomo> Luqman: The good news is that rust works.  ;-)
[04:51:42] <olsonjeffery> iirc proto was based on a similar, novel system exposed in singularity..
[04:51:55] <strcat> brson: do you remember why we create a main function and then call it from a rust_main function?
[04:52:04] <strcat> and then the real entry calls rust_main
[04:52:07] <strcat> (via the scheduler)
[04:52:10] <olsonjeffery> strcat: runtime boostrapping?
[04:52:18] <strcat> well we have 3 main functions
[04:52:21] <strcat> all 3 external
[04:52:28] <heftig> strcat: hm. so you can't create an array that looks like [{len,data[]},{len,data[]},{len,data[]}], i guess?
[04:52:39] <Luqman> strcat: i was planning on removing at least rust_main
[04:52:50] <heftig> strcat: at least not with the built-in str type
[04:53:00] <strcat> rust_main looks easy to remove
[04:53:03] <strcat> just have to not call this function
[04:53:03] <Luqman> so having the real entry point start up the runtime and pass it the user's main
[04:53:12] <strcat> Luqman: yeah
[04:53:41] <strcat> and making the user's main internal if they don't use #[start]
[04:53:52] <strcat> although it doesn't really matter
[04:54:16] *** Quits: ross (ross@moz-5EA04060.br.br.cox.net) (Quit: )
[04:54:23] <olsonjeffery> sometimes, when i get all nostalgic for C# style DI/IoC, i imagine the runtime would inject an EventLoop into main() or any spawn_sched() closures
[04:54:29] <olsonjeffery> and you'd use that when doing any calls into IO
[04:54:41] <strcat> Luqman: running make check now...
[04:54:45] <olsonjeffery> there was something like that with the global loop in extra::net et al.
[04:54:48] <olsonjeffery> i recall everyone hated it
[04:54:58] *** Joins: Ralith (ralith@moz-A7071297.customer.broadstripe.net)
[04:55:06] <olsonjeffery> so we have Local::borrow, instead.. which bugs me because it's rigid and magical..
[04:55:12] <olsonjeffery> (to get at the IoFactory)
[04:55:18] <brson> strcat: it's a relic from when rust used fastcc. rust_main was cdecl so the C++ runtime could call it
[04:55:28] <strcat> brson: ah!
[04:55:48] *** Joins: jstevans (Instantbir@54275545.EBD92228.DDE5D3F6.IP)
[04:55:49] *** Quits: jstevans1 (Instantbir@54275545.EBD92228.DDE5D3F6.IP) (Connection reset by peer)
[04:55:57] <bblum> olsonjeffery: interesting announcement, thanks for showing me
[04:56:03] *** Joins: alisdair (textual@1697D94C.7742FB18.FBC8476D.IP)
[04:56:16] <olsonjeffery> bblum: im gonna play around with it and see how hard it'd be to get rust code running on it
[04:56:22] <olsonjeffery> says it can run linux shared objects ootb
[04:56:47] <nejucomo> rusti: 0x12345678u >> 64
[04:56:48] -rusti- 140664683683904u
[04:57:12] <olsonjeffery> im curious what "taking it to prod" looks like, though.. the examples in the README are all running atop KVM. ive never dealt with KVM at the hypervisor level, before..
[04:57:14] <Luqman> brson: so what's the consensus now since i think i saw talk of possibly switching back to fastcc?
[04:57:18] <strcat> brson: so I guess if we do switch to fastcc again, we would just need to require a #[start] function be 'extern "C"'
[04:57:20] *** Quits: jxv (jxv@moz-8FB92450.lightspeed.irvnca.sbcglobal.net) (Ping timeout)
[04:57:50] *** Joins: jxv (jxv@moz-8FB92450.lightspeed.irvnca.sbcglobal.net)
[04:58:09] <nejucomo> Is that right shift result expected?  I expected 0u.
[04:58:29] <nejucomo> rusti: 1u >> 1
[04:58:30] -rusti- 0u
[04:58:44] *** Joins: ghrust (ghrust@2EE61FCC.6A2AE50.F3114085.IP)
[04:58:45] <ghrust> 01[13rust01] 15alexcrichton merged 06auto into 06snap-stage3: 02http://git.io/5mGmJA
[04:58:45] *** Parts: ghrust (ghrust@2EE61FCC.6A2AE50.F3114085.IP) ()
[04:59:06] <strcat> nejucomo: it's an unspecified result
[04:59:16] <strcat> possibly unsafe to not check for overwide shifts
[04:59:30] <strcat> I am not sure if LLVM considers it just unspecified or undef
[04:59:40] <strcat> if it does consider it undef we could just add a way to make it not do that
[04:59:40] <brson> strcat: idk, it depends. as long as we're generating main ourselves and calling start from it then we don't need it to be extern "C". If we want trans to not generate main at all then main would have to be extern "C"
[04:59:59] <brson> Luqman: there's no consensus about switching back to fastcc. so far it's just idle talk
[05:00:03] <strcat> brson: well when you use #[start], the user function is the entry point
[05:00:07] <brson> Luqman: strcat I think may be experimenting with it
[05:00:33] <brson> strcat: even with #[start] trans generates a function called 'main' or 'WinMain' to call 'start'
[05:00:40] <nejucomo> strcat: Is this due to the underlying llvm / x86 semantics of right shift?
[05:00:44] <Luqman> yep, to pass it the cratemap
[05:00:50] <strcat> brson: ah
[05:00:57] * nejucomo hunts for references.
[05:01:06] <strcat> nejucomo: LLVM defines it as unspecified for overwide shifts
[05:01:17] <strcat> it may or not be LLVM's 'undef' definition
[05:01:23] <strcat> it would be very bad, if it was
[05:01:32] *** Joins: jstevans1 (Instantbir@6B773BF0.A9DA0237.DDE5D3F6.IP)
[05:01:45] <strcat> undef variables may change arbitrarily between reads
[05:01:54] <strcat> s/variables/LLVM registers/
[05:01:55] *** Joins: tjc (tjc@moz-903DB49B.tmodns.net)
[05:01:55] *** ChanServ sets mode: +o tjc
[05:02:11] <strcat> since LLVM isn't going to give them a real CPU register and spill/restore it
[05:02:30] <strcat> so you get a view of something arbitrary each time you read
[05:02:39] <strcat> anyway, LLVM's language reference doesn't clearly define it
[05:03:03] *** Quits: jstevans (Instantbir@54275545.EBD92228.DDE5D3F6.IP) (Ping timeout)
[05:03:24] *** Joins: tikue (quassel@moz-FEADCD38.hsd1.pa.comcast.net)
[05:04:33] <strcat> brson: it's a total non-issue as long as we tag them internal anyway
[05:04:49] <strcat> I'm just annoyed by seeing rust_main and a mangled name with the same contents (since it inlines one into the other)
[05:05:00] <strcat> er
[05:05:04] <strcat> 'if we tag them internal'*
[05:05:15] <nejucomo> rusti: 0x70123456u >> 63
[05:05:16] -rusti- error: internal compiler error: unexpected failure
[05:05:16] -rusti- note: the compiler hit an unexpected failure path. this is a bug
[05:05:16] -rusti- note: try running with RUST_LOG=rustc=1 to get further details and report the results to github.com/mozilla/rust/issues
[05:05:16] -rusti- 0u
[05:05:25] <strcat> we should only output 1 external symbol for an executable
[05:05:53] <strcat> nejucomo: rustc -v is buggy and I run it every time, if you're curious why that happened ;p
[05:06:05] <strcat> rusti: version
[05:06:05] -rusti- error: internal compiler error: unexpected failure
[05:06:05] -rusti- note: the compiler hit an unexpected failure path. this is a bug
[05:06:05] -rusti- note: try running with RUST_LOG=rustc=1 to get further details and report the results to github.com/mozilla/rust/issues
[05:06:05] -rusti- "rustc 0.8-pre (9e8fb4a 2013-09-17 12:50:46 -0700)"
[05:06:07] <strcat> rusti: version
[05:06:08] -rusti- "rustc 0.8-pre (9e8fb4a 2013-09-17 12:50:46 -0700)"
[05:06:11] * strcat shrugs
[05:06:17] <brson> rustc -v is buggy?
[05:06:21] <nejucomo> rusti: 0x70123456u >> 60
[05:06:22] -rusti- 0u
[05:06:47] <nejucomo> rusti: 0x70123456 >> 32
[05:06:48] -rusti- 0
[05:06:54] <acrichto> brson: it'll trigger a pthreads assertion sometimes
[05:07:08] <brson> why?!
[05:07:11] <nejucomo> Sorry for spamming the channel.  (How can I set up a local rusti?)
[05:07:23] <nejucomo> Is it the same as "rust sketch"?
[05:07:24] <brson> nejucomo: rusti takes private messages i think
[05:07:29] *** Joins: echristo (echristo@moz-1892C634.hsd1.ca.comcast.net)
[05:07:53] <strcat> nejucomo: you can also use http://strcat.zapto.org:8000/
[05:08:03] <olsonjeffery> nejucomo: you can /msg rusti directly
[05:08:06] <tikue> i'm trying to parse what was said about default arguments in the weekly meeting, but i'm confused. what exactly is the bottom line on that?
[05:08:08] <strcat> it's really a rustc wrapper
[05:08:10] <olsonjeffery> probably easier than setting up a local sandbox
[05:08:16] <brson> I can't make rustc -v crash
[05:08:16] <olsonjeffery> there's also a playpen that strcat hosts
[05:08:25] *** Joins: lkuper__ (lkuper@72922F20.FFCF2A3B.51B6877.IP)
[05:08:26] <strcat> brson: might be linux only
[05:08:32] <brson> i'm linux :-(
[05:08:52] <strcat> although, I can't crash it consistently :(
[05:08:58] <strcat> I can run it in a loop 100k times with no crash
[05:09:03] <strcat> but sometimes it will crash twice in a row
[05:09:06] <mcpherrin> strcat: that's why I said 0.7 and not stable
[05:09:14] *** Quits: echristo (echristo@moz-1892C634.hsd1.ca.comcast.net) (Ping timeout)
[05:09:34] *** Joins: infynyxx (infynyxx@DB780A29.749BA1D.DCC373F0.IP)
[05:10:35] <strcat> acrichto: can you replicate the issue yourself?
[05:10:42] <acrichto> strcat: yeah
[05:10:54] <strcat> acrichto: which kernel/glibc version?
[05:11:01] <acrichto> strcat: wait maybe not
[05:11:03] <acrichto> perhaps it was fixed
[05:11:07] <mark_edward> hey, im working on rustfind with doomlord, and i recently updated it to get it compiling against master again.
[05:11:14] *** Quits: infynyxx (infynyxx@DB780A29.749BA1D.DCC373F0.IP) (Ping timeout)
[05:11:19] <strcat> acrichto: the bot is up-to-date-ish though :(
[05:11:19] <mark_edward> but when i run it, i'm getting this error: not allowed to compare these idents: &ast::Ident{name: 273u, ctxt: 0u}, &ast::Ident{name: 274u, ctxt: 103u}. Probably related to issue #6993'
[05:11:26] <acrichto> acrichto: well I'm on osx
[05:11:31] <acrichto> 10.8
[05:11:41] <strcat> ah
[05:11:52] <mark_edward> what could that actually mean? it's caused by the `==` operator on a syntax::ast::Ident
[05:12:05] <acrichto> strcat: just ran "rustc -v" 1k times with no segfaults, so I think I'm good now
[05:12:14] <Luqman> i did get it to assert for me on linux debian 7.1 / 3.2.0-4-amd64
[05:12:17] <strcat> acrichto: well I just did ~30k
[05:12:26] <strcat> but rusti is on this same computer and it segfaults
[05:12:26] <acrichto> hehe
[05:12:28] <strcat> now and then
[05:12:40] <acrichto> it used to segfault a lot more frequently for me
[05:12:41] <SingingBoyo> mark_edward: That seems familiar, IIRC it has something to do with the idents having different ctxts
[05:13:02] <SingingBoyo> mark_edward: but I could be completely wrong, haven't really dealt with it myself.
[05:13:39] <mark_edward> SingingBoyo: ah yes, i just saw it in the source 
[05:13:48] <mark_edward> https://github.com/mozilla/rust/blob/master/src/libsyntax/ast.rs#L39-L57
[05:14:23] <Luqman> hmmm, so `rust --version` gets "Program received signal SIGABRT, Aborted." in gdb for me pretty much everytime i run it :/
[05:14:32] <Luqman> (notice rust not rustc)
[05:14:59] <mark_edward> SingingBoyo: why would idents have different ctxts?
[05:15:00] <tjc> Luqman: `rust` has problems. I don't think that one has been reported in the issue tracker, though
[05:15:04] <mark_edward> and what is a ctxt>
[05:15:06] *** Joins: jaen (jaen@moz-EA5CDBF9.play-internet.pl)
[05:15:17] <strcat> Luqman: yeah that segfaults nearly every time
[05:15:18] *** Quits: jstevans1 (Instantbir@6B773BF0.A9DA0237.DDE5D3F6.IP) (Ping timeout)
[05:15:24] <strcat> but rustc -v does occasionally too
[05:15:57] <strcat> Luqman: https://github.com/thestinger/rust-playpen/blob/master/bin/irc.sh that's what rusti is
[05:16:02] <SingingBoyo> mark_edward: damned if I know, it just stuck in my head for some reason :p  best guess is it's related to what code block it's in (context), but that's just a wild guess
[05:16:42] <mark_edward> thanks
[05:17:04] <mark_edward> strcat: do you know what a ctxt is and why/when two idents would have different ctxts?
[05:17:34] *** Joins: jstevans (Instantbir@DBC8468F.471081A5.DDE5D3F6.IP)
[05:18:33] <acrichto> brson: your pull failed :(
[05:19:04] *** Quits: tautologico (shung@72FFECE3.691D28F8.C27E1635.IP) (Quit: tautologico)
[05:19:13] <strcat> mark_edward: no not really. don't play with libsyntax much
[05:19:14] *** Quits: jstevans (Instantbir@DBC8468F.471081A5.DDE5D3F6.IP) (Ping timeout)
[05:19:33] <mark_edward> strcat: i see. wow looking at the code is helping me understand things!
[05:19:37] *** Joins: jstevans (Instantbir@moz-B627BD6E.hsd1.va.comcast.net)
[05:19:42] <mark_edward> it always was so impenetrable!
[05:19:51] <mark_edward> im glad doomlord let me help with this stuff
[05:20:06] *** Joins: jensnockert (jensnocker@moz-8BE55278.customer.t3.se)
[05:20:25] *** Quits: zeuxcg (zeuxcg@moz-80D1F912.hsd1.ca.comcast.net) (Client exited)
[05:20:32] *** Quits: SingingBoyo (singingboy@DAC9C672.CE76D40F.4F048BDC.IP) (Ping timeout)
[05:20:58] *** Joins: ghrust (ghrust@24260B07.6A2AE50.F3114085.IP)
[05:20:59] <ghrust> 01[13rust01] 15bors 04force-pushed 06auto from 141eb8e3f to 144c6bf48: 02http://git.io/N3iJvQ
[05:20:59] *** Parts: ghrust (ghrust@24260B07.6A2AE50.F3114085.IP) ()
[05:21:01] *** Joins: ghrust (ghrust@DE823A67.6A2AE50.F3114085.IP)
[05:21:01] <ghrust> 01[13rust01] 15bors pushed 1 new commit to 06auto: 02http://git.io/1Tb0cg
[05:21:01] <ghrust> 13rust/06auto 14cbd1eef 15bors: auto merge of #9281 : brson/rust/multistring, r=alexcrichton...
[05:21:01] *** Parts: ghrust (ghrust@DE823A67.6A2AE50.F3114085.IP) ()
[05:21:47] *** Quits: jensnockert (jensnocker@moz-8BE55278.customer.t3.se) (Ping timeout)
[05:22:27] <brson> acrichto: random failure i hope
[05:22:32] <acrichto> yeah...
[05:23:17] *** Quits: jstevans (Instantbir@moz-B627BD6E.hsd1.va.comcast.net) (Ping timeout)
[05:23:57] *** Joins: jensnockert (jensnocker@moz-8BE55278.customer.t3.se)
[05:24:35] *** Joins: tikue_ (tkuehn@moz-FEADCD38.hsd1.pa.comcast.net)
[05:24:37] <strcat> bblum: if we had effects I guess we'd just mark certain functions as potentially leaking and be able to deny/allow it
[05:25:05] *** Quits: SiegeLord (sl@moz-CAF07B4C.hsd1.ma.comcast.net) (Quit: It's a joke, it's all a joke.)
[05:25:18] <Luqman> tjc: hmm so there was the issue of `rust help` crashing on os x but that's since been fixed for a while
[05:26:06] <tjc> Luqman: Yeah, I think this is something different
[05:26:28] <mark_edward> would you reccommend using std::rt::io for file IO now?
[05:26:53] <klutzy> I want a meta-issue tracking random test failures
[05:27:10] <Luqman> possibly the same issue as rustc --verion since it seems that pthread_mutex_lock is failing somewhere
[05:27:25] *** Joins: ghrust (ghrust@2EE61FCC.6A2AE50.F3114085.IP)
[05:27:25] <ghrust> 01[13rust01] 15alexcrichton 04force-pushed 06snap-stage3 from 141eb8e3f to 14cbd1eef: 02http://git.io/f3Qwfg
[05:27:25] *** Parts: ghrust (ghrust@2EE61FCC.6A2AE50.F3114085.IP) ()
[05:27:32] *** Quits: lkuper__ (lkuper@72922F20.FFCF2A3B.51B6877.IP) (Ping timeout)
[05:27:53] *** Quits: snadon (chatzilla@moz-3BC727E8.mc.videotron.ca) (Ping timeout)
[05:29:07] *** Quits: Ralith (ralith@moz-A7071297.customer.broadstripe.net) (Ping timeout)
[05:29:14] <mcpherrin> to_owned looks funny if you stop typing at to_o
[05:29:20] <mcpherrin> snorkel man.  That is all.
[05:29:35] <tjc> heh
[05:29:41] <strcat> rusti: 0_0
[05:29:41] -rusti- 0
[05:29:47] *** Quits: jxv (jxv@moz-8FB92450.lightspeed.irvnca.sbcglobal.net) (Ping timeout)
[05:29:58] <bblum> mcpherrin: haha
[05:30:30] <mark_edward> bblum: would you recommend using std::rt::io for FIle I/O at this time?
[05:30:45] <bblum> mark_edward: ecr or brson is the person to ask; i know not
[05:30:58] <mark_edward> oops sorry :-(
[05:31:03] <mark_edward> brson: ping
[05:31:04] <bblum> np
[05:31:24] <mark_edward> can i just ping mozilla employees like that, i feel kinda rude
[05:31:35] <brson> mark_edward: pong
[05:32:04] <mark_edward> brson: Hi! would you recommned using std::rt::io for File I/O at this point?
[05:32:17] <olsonjeffery> answer hazy; ask again after 0.8
[05:32:40] *** Joins: Ralith (ralith@moz-A7071297.customer.broadstripe.net)
[05:32:53] <tjc> mark_edward: we actually get a bonus based on how many people ping us :-)
[05:32:56] <tjc> Just kidding, but I wish
[05:32:56] <olsonjeffery> mark_edward: rt::io::file is undergoing a lot of change.. well most of the big stuff is done. so, i guess we would all appreciate if you used it and gave us feedback
[05:33:11] <mcpherrin> tjc: I wish :P  (Especially if #interns counted:P)
[05:33:22] *** Quits: strcat (strcat@moz-54F7FD49.cpe.net.cable.rogers.com) (Quit: WeeChat 0.4.1)
[05:33:25] <tjc> mcpherrin: Yes. Such a system could be abused rather easily :-)
[05:33:26] *** Joins: strcat (strcat@moz-54F7FD49.cpe.net.cable.rogers.com)
[05:33:39] <olsonjeffery> mark_edward: but (hopefully!) most of the stuff you'd need is there, in terms of file operations
[05:33:50] <olsonjeffery> if not, let us know what you'd like to see (especially if its in the uv.h, heh)
[05:34:11] <mark_edward> olsonjeffery: ok, thanks! i eagerly await std::io's replacement! i don't have any special uses planned, so everything should be fine
[05:34:17] <strcat> brson: ha, we don't tag functions internal at all... I thought it was just a problem with main
[05:34:23] *** Joins: ww (Mibbit@moz-DFAED48A.lightspeed.sntcca.sbcglobal.net)
[05:34:26] <strcat> just monomorphized ones
[05:34:56] <strcat> should be an easy fix...
[05:35:23] *** Quits: tjc (tjc@moz-903DB49B.tmodns.net) (Quit: zzzzzzzzzz)
[05:36:01] *** Quits: jaen (jaen@moz-EA5CDBF9.play-internet.pl) (Ping timeout)
[05:36:48] *** Quits: cubic (cubic@moz-FE5AD6C7.mc.videotron.ca) (Quit: Leaving)
[05:37:37] <Luqman> strcat: are you doing the remove rust_main thing or should i just do it?
[05:37:43] <strcat> Luqman: I did it already
[05:37:49] <strcat> marking priv functions as internal now
[05:37:54] *** Joins: jaen (jaen@moz-99858536.play-internet.pl)
[05:37:55] <Luqman> cool
[05:38:57] * strcat forgets how to get an ast::visibility thing from an ast::NodeId
[05:39:04] <sfackler> is it better style-wise to use a Cell or a oneshot to move something into a task?
[05:39:23] <olsonjeffery> so what does fastcc get you over whatever is being used, now? (cdecl?)
[05:39:52] <sfackler> ooh, looks like spawn_with is what I want
[05:40:04] *** Quits: jaen (jaen@moz-99858536.play-internet.pl) (Quit: WeeChat 0.4.1)
[05:40:06] *** Quits: strcat (strcat@moz-54F7FD49.cpe.net.cable.rogers.com) (Quit: WeeChat 0.4.1)
[05:40:08] *** Joins: strcat (strcat@moz-54F7FD49.cpe.net.cable.rogers.com)
[05:40:41] <strcat> olsonjeffery: fastcc passes/returns things in the best way the LLVM people figure out
[05:40:51] <strcat> cdecl has to conform to the platform ABI, and C is very lenient
[05:40:57] <strcat> the caller is allowed to pass too many arguments, etc.
[05:41:03] <strcat> and it has varargs, fastcc doesn't
[05:41:15] *** Joins: tautologico (shung@72FFECE3.691D28F8.C27E1635.IP)
[05:41:39] <olsonjeffery> strcat: i couldn't find much about it via google, but one thing i saw was a rundown in the context of nacl
[05:41:45] <strcat> olsonjeffery: well, it's LLVM specific
[05:41:47] <olsonjeffery> and it mentioned that fastcc is ignored on x86_64
[05:41:55] <olsonjeffery> and only slightly modified from cdecl on arm
[05:41:59] <Luqman> strcat: match ccx.tcx.items.find(&id) { Some(item) => item.vis, ... } 
[05:42:07] <strcat> Luqman: thanks! :)
[05:42:13] <olsonjeffery> anyways. im not an expert on any of this, just curious if it makes that much of an impact.
[05:42:27] <olsonjeffery> what does the compiler use now, then?
[05:42:33] <olsonjeffery> extern "C" fn's are cdecl, right?
[05:43:18] <Luqman> strcat: er, there's an extra level before you can do item.vis, since item would be some variant of the item_ enum
[05:43:19] <strcat> olsonjeffery: atm, "Rust" is cdecl and "C" is cdecl
[05:43:30] *** Joins: lkuper__ (lkuper@BAE96B56.1C5FF2E6.51B6877.IP)
[05:43:50] <Luqman> strcat: actually, that should work
[05:44:40] *** Joins: jxv (jxv@moz-8FB92450.lightspeed.irvnca.sbcglobal.net)
[05:45:10] *** Joins: fabiand (fabiand@moz-34EAF1E0.adsl.alicedsl.de)
[05:45:24] <strcat> Luqman: it's mad about it
[05:45:32] <strcat> /home/strcat/projects/rust/src/librustc/middle/trans/base.rs:2339:22: 2339:30 error: attempted access of field `vis` on type `&syntax::ast_map::ast_node`, but no field with that name was found
[05:45:37] <strcat> hm
[05:45:38] <sfackler> does anyone know why Future has an unsafe no-op Drop impl?
[05:45:41] <strcat> I thought there was an easy way to do this
[05:45:50] <strcat> sfackler: to make it non-copyable, I guess
[05:46:08] <Luqman> strcat: oh right, you need to match on for the node_item variant
[05:46:33] *** Quits: jensnockert (jensnocker@moz-8BE55278.customer.t3.se) (Input/output error)
[05:46:52] <Luqman> match ccx.tcx.items.find(&id) { Some(ast_map::node_item(i, _)) => i.vis, ... } 
[05:46:58] <Luqman> strcat: ^ something like that
[05:47:02] <strcat> yeah
[05:47:10] * strcat is ready for a linker error now
[05:47:35] *** Joins: wilmoore (wilmoore@moz-71431C3A.hsd1.co.comcast.net)
[05:50:25] <strcat> hm
[05:50:40] <strcat> not sure if it's supposed to put it in item_symbols if it's private
[05:50:43] <strcat> I assume no...
[05:50:54] <sfackler> what are the rules for implicitly copyable types?
[05:51:18] <strcat> if a type has no contained destructors, &fn or &mut it does not move ownership
[05:53:16] <sfackler> rusti: let f: ~fn() = || {}; let g = f; f()
[05:53:18] -rusti- pastebinned 8 lines of output: http://sprunge.us/Bcbh
[05:53:30] <strcat> that has a destructor
[05:53:32] <strcat> rusti: extra::rc::owned_to_raw
[05:53:32] *** Quits: hoverbear (andrew@moz-86FCBF4B.gv.shawcable.net) (Quit: hoverbear)
[05:53:33] -rusti- pastebinned 10 lines of output: http://sprunge.us/UjEj
[05:53:34] <mark_edward> im getting an access denied error for http://static.rust-lang.org/doc/tutorial.html anyone else?
[05:53:48] <strcat> brson: ^
[05:53:50] <strcat> oh
[05:53:58] <strcat> mark_edward: it's because it's under doc/master/tutorial.html now
[05:54:06] <strcat> is a link broken somewhere?
[05:54:22] <sfackler> cool, looks like I should be able to get rid of Future's destructor then, thanks
[05:54:33] <strcat> sfackler: it's there intentionally afaik
[05:54:40] <strcat> to make it non-copyable/safe
[05:54:53] <strcat> rusti: unsafe { extra::rc::owned_to_raw(~5) }
[05:54:54] -rusti- (0x7fbe6ac23058 as *mut ())
[05:54:56] <strcat> um
[05:54:56] <sfackler> there is a note attached saying that it shouldn't be necessary
[05:55:00] <strcat> that function isn't public
[05:55:02] *** Joins: hoverbear (andrew@moz-86FCBF4B.gv.shawcable.net)
[05:55:08] <strcat> privacy... does not work at all? :|
[05:55:12] *** Quits: enix (enix@moz-A50569DD.c3-0.slvr-ubr1.lnh-slvr.md.cable.rcn.com) (Client exited)
[05:55:25] <sfackler> it works at link time in some cases :D
[05:55:54] <sfackler> am I right in thinking that since Future contains a ~fn, it can't be copied anyways?
[05:56:03] *** Quits: hoverbear (andrew@moz-86FCBF4B.gv.shawcable.net) (Quit: hoverbear)
[05:56:33] <strcat> sfackler: right
[05:56:40] *** Joins: josh (josh@moz-348C4790.hsd1.mn.comcast.net)
[05:56:53] *** Quits: josh (josh@moz-348C4790.hsd1.mn.comcast.net) (Quit: josh)
[05:57:07] * strcat didn't realize privacy didn't work for functions
[05:57:27] <strcat> at least unsafe fns...
[05:58:19] <sfackler> privacy is broken for a lot of stuff
[05:58:58] <engla> and regular functions, it appears
[05:58:58] <sfackler> in certain cases, code using private stuff will compile and then fail to link, and in others it will just work
[05:59:25] <strcat> engla: did you check?
[05:59:35] <engla> I just tested this one
[05:59:37] <strcat> rusti: mod foo { fn bar() {} } foo::bar()
[05:59:38] -rusti- <anon>:7:33: 7:41 error: unresolved name `foo::bar`.
[05:59:38] <engla> rusti: extra::ringbuf::raw_index(0, 2, 1)
[05:59:38] -rusti- <anon>:7          mod foo { fn bar() {} } foo::bar()
[05:59:38] -rusti-                                           ^~~~~~~~
[05:59:38] -rusti- error: aborting due to previous error
[05:59:38] -rusti- application terminated with error code 101
[05:59:39] -rusti- 1u
[05:59:49] <strcat> engla: ah
[06:00:00] <strcat> okay, well I'm about to fix that by causing link errors afaik
[06:00:06] <strcat> "fix"
[06:00:29] <engla> statics behave the same way, they are exposed too
[06:01:14] <engla> rusti: std::hashmap::INITIAL_CAPACITY
[06:01:14] -rusti- 32u
[06:01:53] <engla> and other things
[06:01:54] <engla> rusti: std::hashmap::FoundEntry(1)
[06:01:55] -rusti- FoundEntry(1u)
[06:02:01] <brson> mark_edward: the new link is http://static.rust-lang.org/doc/master/tutorial.html
[06:02:10] <mark_edward> thanks!
[06:02:20] *** Joins: bheylin_ (brianheyli@moz-8255E94E.adsl.online.nl)
[06:02:20] *** Joins: mib_a90qrk (Mibbit@moz-5256162B.hsd1.ca.comcast.net)
[06:02:48] <strcat> Luqman: strange... it's failing to look up the NodeId
[06:03:03] <strcat> is the AST already gone in trans?
[06:03:07] * brson home
[06:03:07] <strcat> well
[06:03:08] *** Quits: brson (brson@moz-BBE3ABD.mv.mozilla.com) (Quit: leaving)
[06:03:13] <strcat> I just need to check if this is private >.<
[06:04:04] <Luqman> is it something in the local crate?
[06:04:09] <strcat> yes
[06:04:24] <sfackler> if i'm already messing around in extra::future, should spawn, from_fn, from_port, etc be changed to methods on Future?
[06:04:47] <strcat> Luqman: my assert happens compiling libstd
[06:04:59] <strcat> so afaik there's no xcrate stuff happening yet
[06:06:11] *** Joins: Shaladdle_ (anonymous@moz-424BC304.hsd1.pa.comcast.net)
[06:06:30] <strcat> Luqman: http://ix.io/88C :s
[06:07:14] *** Quits: jeaye (Jeaye@moz-34FEF2BB.hsd1.ca.comcast.net) (Quit: WeeChat 0.4.1)
[06:08:32] *** Quits: geomyidae (quassel@DD6F7E3A.21468E9A.30200F38.IP) (Client exited)
[06:08:45] *** Quits: tautologico (shung@72FFECE3.691D28F8.C27E1635.IP) (Quit: tautologico)
[06:09:01] <strcat> Luqman: maybe that tcx.items is only for types? no fns
[06:09:54] *** Joins: infynyxx (infynyxx@DB780A29.749BA1D.DCC373F0.IP)
[06:09:57] *** Quits: bheylin_ (brianheyli@moz-8255E94E.adsl.online.nl) (Quit: bheylin_)
[06:10:29] <Luqman> strcat: but functions are items, item_fn
[06:10:38] <strcat> ah but methods aren't!
[06:10:42] *** Quits: Shaladdle (Shaladdle@moz-424BC304.hsd1.pa.comcast.net) (Client exited)
[06:10:42] *** Shaladdle_ is now known as Shaladdle
[06:10:49] <strcat> Luqman: that's it :)
[06:11:34] *** Quits: infynyxx (infynyxx@DB780A29.749BA1D.DCC373F0.IP) (Ping timeout)
[06:11:50] <Luqman> strcat: oh!
[06:12:23] * strcat doesn't know if he has to check for trait fns
[06:12:33] *** Joins: geomyidae (quassel@DD6F7E3A.21468E9A.30200F38.IP)
[06:12:38] <Luqman> so i guess need to check for node_method/node_trait_method as well then?
[06:12:42] <strcat> yeah
[06:12:59] <strcat> for now I will pretend they are always pub
[06:13:03] <strcat> just want to get the basics working
[06:14:25] *** Quits: tiffany (kawaii@moz-EB8B0C08.dhcp.embarqhsd.net) (Input/output error)
[06:14:49] *** Quits: jxv (jxv@moz-8FB92450.lightspeed.irvnca.sbcglobal.net) (Client exited)
[06:18:56] *** Quits: mitsuhiko (mitsuhiko-@moz-BC29B73E.srv.pocoo.org) (Ping timeout)
[06:20:03] *** Joins: mitsuhiko (mitsuhiko-@moz-BC29B73E.srv.pocoo.org)
[06:20:05] *** Quits: lkuper__ (lkuper@BAE96B56.1C5FF2E6.51B6877.IP) (Ping timeout)
[06:20:43] <strcat> Luqman: still hitting it :s
[06:21:12] <Luqman> strcat: what is find returning?
[06:21:22] <strcat> None
[06:21:28] *** Joins: valenting (Thunderbir@F8AEB5FE.ECBF5C84.FB866788.IP)
[06:21:46] <strcat> hm
[06:22:49] <strcat> it seems like there should be a function I could call to check this
[06:23:18] *** Joins: eatkinson (eatkinson@moz-261EDE03.hsd1.ca.comcast.net)
[06:25:07] *** Joins: sk (sk@BC280AA6.273A3D3C.78DD174B.IP)
[06:26:36] <strcat> Luqman: ah, hm
[06:26:47] <strcat> Luqman: I think it's possible it gives the node id of a tuple struct
[06:26:55] *** Quits: engla (engla@moz-DBD1D96E.cust.bredbandsbolaget.se) (Ping timeout)
[06:27:06] <Luqman> ah, right, those are functions of sorts
[06:27:06] <strcat> well meh
[06:27:12] <strcat> that's covered by item :(
[06:28:05] *** Quits: geomyidae (quassel@DD6F7E3A.21468E9A.30200F38.IP) (Client exited)
[06:28:48] *** Joins: ChrisMorgan (chris@moz-6AC741CA.static.tpgi.com.au)
[06:29:07] *** Joins: tautologico (shung@72FFECE3.691D28F8.C27E1635.IP)
[06:29:18] *** Joins: aeqwa (aeqwa@moz-A1C312ED.dsl.tropolys.de)
[06:30:12] *** Joins: mib_ysytxd (Mibbit@1C9A9CA0.9498B80C.68E87D45.IP)
[06:31:21] *** Quits: mib_ysytxd (Mibbit@1C9A9CA0.9498B80C.68E87D45.IP) (Quit: http://www.mibbit.com ajax IRC Client)
[06:31:48] *** Joins: zeuxcg (zeuxcg@moz-80D1F912.hsd1.ca.comcast.net)
[06:32:32] <strcat> Luqman: ok fixed
[06:32:43] <Luqman> \o/
[06:34:36] *** Quits: eatkinson (eatkinson@moz-261EDE03.hsd1.ca.comcast.net) (Quit: eatkinson)
[06:35:43] *** Joins: lkuper__ (lkuper@BAE96B56.1C5FF2E6.51B6877.IP)
[06:36:43] <strcat> Luqman: encode_symbol failing now :(
[06:36:50] <strcat> going to try not changing the metadata part
[06:38:37] *** Quits: lkuper__ (lkuper@BAE96B56.1C5FF2E6.51B6877.IP) (Ping timeout)
[06:41:30] *** Quits: lenstr (lenstr@AF8EB999.6049B16A.85938D85.IP) (Client exited)
[06:43:46] <Luqman> is there no way to reference an existing global?
[06:44:29] *** Quits: vodik (simon@moz-CBE4BB13.cable.teksavvy.com) (Ping timeout)
[06:45:44] <mark_edward> how would i loop from 0 to 255 using a u8? for x in range(0u8, 255) leaves out 255
[06:45:57] *** Joins: ghrust (ghrust@DE823A67.6A2AE50.F3114085.IP)
[06:45:57] <ghrust> 01[13rust01] 15bors merged 06auto into 06master: 02http://git.io/rZVCDg
[06:45:57] *** Parts: ghrust (ghrust@DE823A67.6A2AE50.F3114085.IP) ()
[06:46:05] <strcat> mark_edward: range_inclusive
[06:46:08] <dbaupp> mark_edward: std::iter::range_inclusive
[06:46:12] <mark_edward> thank you!
[06:46:37] <strcat> (there are also range_step, range_step_inclusive and count)
[06:46:49] <mark_edward> does it handle the overflow right?
[06:46:52] <strcat> yes
[06:47:16] <strcat> rusti: use std::iter::range_step; range_step(0u8, 255, 80).to_owned_vec()
[06:47:17] -rusti- ~[0u8, 80u8, 160u8, 240u8]
[06:47:29] <strcat> rusti: use std::iter::range_step; range_step(0i8, 120, 40).to_owned_vec()
[06:47:31] -rusti- ~[0i8, 40i8, 80i8]
[06:47:33] <strcat> rusti: use std::iter::range_step; range_step(0i8, 120, 50).to_owned_vec()
[06:47:34] -rusti- ~[0i8, 50i8, 100i8]
[06:47:36] <strcat> rusti: use std::iter::range_step; range_step(0i8, 120, -50).to_owned_vec()
[06:47:37] -rusti- ~[]
[06:47:42] <strcat> rusti: use std::iter::range_step; range_step(0i8, -120, -50).to_owned_vec()
[06:47:42] -rusti- ~[0i8, -50i8, -100i8]
[06:48:04] <strcat> perfect! ;p
[06:49:28] *** Quits: tautologico (shung@72FFECE3.691D28F8.C27E1635.IP) (Quit: tautologico)
[06:50:54] *** Joins: ghrust (ghrust@1E8607E8.6A2AE50.F3114085.IP)
[06:50:54] <ghrust> 01[13rust01] 15bors pushed 0 new commits to 06auto: 02http://git.io/PgD1rA
[06:50:54] *** Parts: ghrust (ghrust@1E8607E8.6A2AE50.F3114085.IP) ()
[06:50:56] *** Joins: ghrust (ghrust@79968228.6A2AE50.F3114085.IP)
[06:50:56] <ghrust> 01[13rust01] 15bors pushed 2 new commits to 06auto: 02http://git.io/_yZhdQ
[06:50:56] <ghrust> 13rust/06auto 148c23eca 15Tim Chevalier: rustpkg: Make crates, not packages, the unit of rustpkg dependencies...
[06:50:56] <ghrust> 13rust/06auto 1469468f7 15bors: auto merge of #9263 : catamorphism/rust/rustpkg-issue-7879, r=brson...
[06:50:56] *** Parts: ghrust (ghrust@79968228.6A2AE50.F3114085.IP) ()
[06:56:28] *** Joins: lkuper__ (lkuper@72922F20.FFCF2A3B.51B6877.IP)
[06:57:09] <strcat> Luqman: oh boy, lots of link failures
[06:57:26] *** Joins: geomyidae (quassel@DD6F7E3A.21468E9A.30200F38.IP)
[06:57:54] <Luqman> strcat: because of internal linkage?
[06:57:57] <strcat> yep
[06:58:06] <strcat> real failures.
[06:58:57] <strcat> privacy *does not work*
[06:59:01] * strcat sighs
[07:01:25] <Jesse_> did the NSA infiltrate rustc?
[07:02:18] <mcpherrin> woah, I think the rustc spellchecker just gave me a useful hint for the first time ever :P
[07:02:20] <mark_edward> what does rustc need CFG_SPEC env variable for? what should i define it to?
[07:03:21] <sfackler> it's kind of neat to go through old rust code and see all of the weird workarounds it has for issues that don't exist anymore
[07:03:48] <strcat> Luqman: well, here's a problem - what happens if you inline a function with calls to private stuff? :(
[07:03:57] * strcat should just give up
[07:04:09] *** Joins: tgummerer (tgummerer@moz-5DC8FA44.tbcn.telia.com)
[07:04:24] <strcat> there's basically no point of us using libraries at this point...
[07:06:19] <tikue_> is the enum to_int patch expecting an r+ soon ? just curious
[07:06:51] <Luqman> oh great, you can't reference an extern static in a static :(
[07:07:09] <tikue_> strcat: what do you mean no point in using libraries :|
[07:07:09] *** Quits: lkuper__ (lkuper@72922F20.FFCF2A3B.51B6877.IP) (Ping timeout)
[07:07:21] <strcat> rustc doesn't have a sane foundation for modules
[07:07:48] <strcat> everything has to either be duplicated between crates or public
[07:07:54] <strcat> there are no implementation details
[07:08:22] <mark_edward> what does that even mean
[07:08:42] <strcat> rustc can't define an internal/private function
[07:08:57] <strcat> all functions/methods are public
[07:09:01] <tikue_> oh wow
[07:09:04] <tikue_> is this a recent revelation?
[07:09:06] <strcat> no
[07:09:12] <tikue_> er
[07:09:17] <strcat> but I thought it was fixable
[07:09:29] <klutzy> pub does not do anything?
[07:09:43] <strcat> within a crate, it does
[07:10:00] <strcat> well
[07:10:08] <strcat> rust will still make all the symbols public
[07:10:10] <strcat> in an executable
[07:10:13] *** Joins: infynyxx (infynyxx@DB780A29.749BA1D.DCC373F0.IP)
[07:10:30] <klutzy> interesting
[07:10:33] <tikue_> "thought it was fixable" as in it _can't_ be fixed?
[07:10:48] <strcat> it can be fixed by changing the language and module system
[07:11:03] <tikue_> strcat: the syntax or the stuff under the hood?
[07:11:16] <strcat> the semantics of the language and module system
[07:11:32] *** Quits: alisdair (textual@1697D94C.7742FB18.FBC8476D.IP) (Quit: My MacBook Pro has gone to sleep. ZZZzzzâ€¦)
[07:11:36] <tikue_> how would the module system change? 
[07:11:37] *** Quits: tgummerer (tgummerer@moz-5DC8FA44.tbcn.telia.com) (Ping timeout)
[07:11:44] <tikue_> i guess if it's gotta be done it's gotta be done
[07:11:54] *** Quits: infynyxx (infynyxx@DB780A29.749BA1D.DCC373F0.IP) (Ping timeout)
[07:12:49] *** Joins: ceninan (ceninan@moz-6BD43586.a370.priv.bahnhof.se)
[07:12:51] <klutzy> strcat: what about extern fn declarations? they are also exported as public, but I don't know if it should be not public as well
[07:13:04] <klutzy> first example of https://github.com/mozilla/rust/issues/9055
[07:13:11] <strcat> there's no cross-crate privacy at all
[07:13:30] <klutzy> ah I meant if it is fixed properly
[07:14:31] <acrichto> strcat: you ran into problems with internal linkage?
[07:14:37] <strcat> acrichto: can't be done
[07:14:40] <acrichto> how come?
[07:14:43] <strcat> acrichto: consider #[inline]
[07:14:49] *** Jesse_ is now known as Jesse
[07:14:58] <strcat> in C, you put inline functions in headers
[07:15:03] <acrichto> huh, guess so
[07:15:23] <acrichto> I guess I got around that in statics because all of them were inline items
[07:15:28] <acrichto> but that's not true for functions
[07:15:42] <strcat> statics likely aren't all going to be inline
[07:15:56] *** Joins: ghrust (ghrust@C8693FCB.6A2AE50.F3114085.IP)
[07:15:56] <ghrust> 01[13rust01] 15bors 04force-pushed 06auto from 1469468f7 to 14cbd1eef: 02http://git.io/N3iJvQ
[07:15:56] *** Parts: ghrust (ghrust@C8693FCB.6A2AE50.F3114085.IP) ()
[07:15:57] <strcat> need a way to define a constant and not break ABI when you change the definition
[07:15:57] *** Joins: ghrust (ghrust@9C8B94D4.6A2AE50.F3114085.IP)
[07:15:57] <ghrust> 01[13rust01] 15bors pushed 2 new commits to 06auto: 02http://git.io/RW7XOg
[07:15:57] <ghrust> 13rust/06auto 14604667f 15Daniel Rosenwasser: Added support for a `\0` escape sequence....
[07:15:57] <ghrust> 13rust/06auto 147dd9344 15bors: auto merge of #9248 : DanRosenwasser/rust/master, r=alexcrichton...
[07:15:58] *** Parts: ghrust (ghrust@9C8B94D4.6A2AE50.F3114085.IP) ()
[07:16:25] <klutzy> 16:08 < strcat> rustc can't define an internal/private function 16:08 < strcat> all functions/methods are public
[07:16:30] <klutzy> oops sorry
[07:16:32] <strcat> headers are seriously better than what we have atm :(
[07:17:20] <strcat> acrichto: well, at least if there's a single executable we can mark everything that's not main as internal...
[07:17:29] <strcat> libraries are pretty hopeless
[07:17:39] *** Quits: geomyidae (quassel@DD6F7E3A.21468E9A.30200F38.IP) (Client exited)
[07:17:43] *** Quits: zeuxcg (zeuxcg@moz-80D1F912.hsd1.ca.comcast.net) (Ping timeout)
[07:17:53] <acrichto> yeah cross-crate stuff is actually hard
[07:18:50] <mcpherrin> is there something like v.slice(0, foo) -> ~[T]
[07:18:58] <strcat> to_owned
[07:18:58] <mcpherrin> ie, drop the tail of a vector
[07:19:05] <strcat> oh you mean without copying?
[07:19:11] <mcpherrin> yeah, slice without copying
[07:19:12] <strcat> truncate
[07:19:17] <strcat> mcpherrin: it's not a slice, then
[07:19:24] * ChrisMorgan sets out to compile almost *two weeks' worth* of Rust changes
[07:19:25] <mcpherrin> I know
[07:19:34] <mcpherrin> I want truncate, thanks
[07:21:21] <ChrisMorgan> New LLVM build, thus it'll take well over an hour :-(
[07:21:43] <acrichto> sorry :(
[07:21:54] *** Joins: geomyidae (quassel@DD6F7E3A.21468E9A.30200F38.IP)
[07:22:00] *** Joins: jaen (jaen@FB01674D.56B727FE.4B52F012.IP)
[07:22:02] <acrichto> blame strcat for convincing me to upgrade everything instead of just one thing :P
[07:22:14] <strcat> it still cleans it all either way
[07:22:20] *** Quits: lkuper_ (lkuper@moz-C0CD33ED.hsd1.in.comcast.net) (Quit: lkuper_)
[07:22:24] *** Joins: lkuper__ (lkuper@72922F20.FFCF2A3B.51B6877.IP)
[07:22:38] <acrichto> ccache would work better in one case though
[07:22:50] <strcat> acrichto: https://github.com/mozilla/rust/issues/9286 that's what we can do, at least
[07:23:05] <acrichto> haha, not sure if it'd be worth it
[07:23:12] <acrichto> but it's certainly an optimization we can do
[07:23:16] *** Quits: anshin (anshin@CD85F10D.F21429E2.354459FA.IP) (Quit: leaving)
[07:23:19] <strcat> it will be worth it
[07:23:24] * strcat can guarantee it
[07:23:49] <strcat> acrichto: if you have
[07:23:59] <strcat> #[inline] fn foo() {} fn main() { foo() }
[07:24:13] <strcat> it's still going to output a symbol for foo with the compiled body
[07:24:20] <acrichto> good point actually
[07:24:28] <acrichto> it wouldn't help rustc at all
[07:24:29] <Luqman> was there a new snapshot?
[07:24:35] <acrichto> Luqman: hopefully soon!
[07:24:45] *** Quits: KindOne (KindOne@moz-2273B680.dynamic.ip.windstream.net) (Ping timeout)
[07:24:50] <acrichto> http://buildbot.rust-lang.org/grid?branch=snap-stage3&width=10
[07:24:52] <acrichto> 2 more...
[07:25:04] <acrichto> linux should be almost done
[07:25:06] <strcat> acrichto: I only *really* care about whole-program-optimization rust (which doesn't exist yet)
[07:25:06] <acrichto> had to retry mac
[07:25:11] <tikue_> oh god
[07:25:14] <strcat> well 
[07:25:15] <tikue_> no headers for rust please no
[07:25:18] <strcat> #[no_std] -> it does exist
[07:25:34] <strcat> (once you don't have to link to librustrt)
[07:25:54] <acrichto> #[path = "http://github.com/mozilla/rust/src/libstd/std.rs"] mod std
[07:26:21] <acrichto> not linking to libmorestack/librustrt by default as an option would be awesome
[07:26:28] *** Joins: tgummerer (tgummerer@51D3B54.FEF996EA.EA6FEF3D.IP)
[07:26:41] <strcat> libstd uses the runtime a lot
[07:26:46] <strcat> failure, managed pointers, I/O
[07:26:50] *** Joins: anshin (anshin@CD85F10D.F21429E2.354459FA.IP)
[07:27:03] <acrichto> yeah this would imply no libstd definitely
[07:27:12] <strcat> if you write a system library in rust you can't use libstd
[07:27:34] <strcat> although apparently rust doesn't really quality for that use case because you can't only expose certain symbols
[07:27:37] <strcat> :(
[07:27:38] <strcat> qualify*
[07:27:44] <tikue_> wait 
[07:27:45] <tikue_> what
[07:28:04] <tikue_> i hope you're not saying it doesn't qualify as a systems language
[07:28:15] <strcat> the name mangling makes it not quite as a bad but it's a huge code size issue, and you are still polluting the namespace
[07:28:15] <heftig> not for libraries, apparently
[07:28:17] <heftig> for apps, yes
[07:28:19] <strcat> going to make linking very slow
[07:28:31] <strcat> and by linking here I mean loading applications
[07:28:49] <strcat> heftig: it'd be fine in a static lib
[07:28:59] * strcat shrugs
[07:29:37] <strcat> acrichto: so... due to generics/inline I can't see any way to make symbols private
[07:29:48] <strcat> I think this is a big oversight :(
[07:30:22] <acrichto> not entirely
[07:30:38] <strcat> you could mark stuff as used by inline/generic functions
[07:30:43] *** Joins: nkoep (nik@moz-1E78C081.pool.mediaways.net)
[07:30:58] <acrichto> that'd involve dependency trees though
[07:31:01] <acrichto> and it'd keep going for awhile
[07:31:01] <mark_edward> was this not noticed until now?
[07:31:23] <strcat> well *I* just noticed it now
[07:31:52] <strcat> I'm surprised I haven't heard anyone complain that privacy doesn't do anything cross-crate, and that there's no privacy at the shared object level
[07:32:17] <tikue_> maybe it was never tested thoroughly?
[07:32:42] <strcat> doesn't really have to be thorough
[07:32:42] <acrichto> strcat: I have a patch for that
[07:32:49] <acrichto> strcat: but it's not enforced at link-time
[07:33:04] <ChrisMorgan> I don't see why it matters. Will not rustc check in the metadata and thus ensure private things are not accessible?
[07:33:08] <strcat> acrichto: right so a rust library is going to be 3-4x bigger than it should be
[07:33:13] <strcat> ChrisMorgan: size, performance
[07:33:22] <acrichto> I don't think symbols are that large?
[07:33:31] <strcat> acrichto: they duplicate functions
[07:33:42] <acrichto> 3-4x though?
[07:33:52] <strcat> yep, most functions are small or used once
[07:33:55] *** Joins: Houm (Houm@moz-25669AA8.fbx.proxad.net)
[07:34:08] <acrichto> I'd be curious to see the actual size improvements
[07:34:15] <acrichto> I wouldn't expect such a boost
[07:34:16] <tikue_> impacts performance in what way? just load times?
[07:34:27] *** Quits: nejucomo (Adium@moz-434492BB.dsl.static.sonic.net) (Quit: Leaving.)
[07:34:58] <strcat> acrichto: drops 2MiB off libstd
[07:35:05] <strcat> ofc, it doesn't work anymore
[07:35:18] <strcat> since the inline/generic functions can't find what they want
[07:35:49] <strcat> I bet libstd is mostly metadata though :s
[07:36:06] <strcat> maybe that's a silly thought
[07:36:22] <acrichto> 2mb is pretty impressive though
[07:36:25] <strcat> metadata wouldn't be there if you were writing a lib with a C ABI
[07:36:28] <acrichto> it's 5.5mb on osx
[07:36:42] <ChrisMorgan> I presume separating metadata from the library (libxyz.so, libxyz.so.rsmd) has been thought of.
[07:36:57] <strcat> acrichto: it went 6.4 -> 4.4
[07:36:57] <acrichto> there was an issue about the separation somewhere
[07:37:13] <ChrisMorgan> I presume the metadata is only necessary for rustc so it knows what to link?
[07:37:18] <strcat> ChrisMorgan: yes
[07:37:27] <ChrisMorgan> (And to provide appropriate error messages, etc.)
[07:37:39] <mcpherrin> rusti: "\x04\x04".into_bytes()
[07:37:39] -rusti- <anon>:7:9: 8:5 error: type `&'static str` does not implement any method in scope named `into_bytes`
[07:37:40] -rusti- <anon>:7          "\x04\x04".into_bytes()
[07:37:40] -rusti- <anon>:8     };
[07:37:40] -rusti- error: aborting due to previous error
[07:37:40] -rusti- application terminated with error code 101
[07:41:14] <acrichto> ok linux, you've been running for > 2 hours, give me a snapshot
[07:41:48] *** Quits: jaen (jaen@FB01674D.56B727FE.4B52F012.IP) (Ping timeout)
[07:41:56] <strcat> hrm
[07:42:03] <strcat> #[no_std] seems to be broken?
[07:42:16] <acrichto> how so?
[07:42:32] <strcat> I thought it wanted the lang items on demand now
[07:42:42] <acrichto> it does
[07:42:49] <acrichto> I use it all the time
[07:42:52] <strcat> #[no_std]; fn main() {}
[07:42:57] <strcat> should that work?
[07:42:59] <strcat> error: requires `unrecord_borrow` lang_item
[07:43:09] <klutzy> std implements some lang items
[07:43:11] <strcat> supplying an unrecord_borrow impl doesn't fix it
[07:43:17] <strcat> klutzy: I know
[07:43:19] <acrichto> whoa
[07:43:25] <klutzy> uh wait. it requires it?
[07:43:31] <strcat> rust is not being kind to me tonight :(
[07:43:31] <acrichto> you should need #[start], not unrecord_borrow
[07:43:55] <klutzy> yes, it should beep about `start` lang_item
[07:43:58] *** Joins: KindOne (KindOne@moz-8A3F01C3.dynamic.ip.windstream.net)
[07:44:09] <strcat> acrichto: do you get the same error?
[07:44:25] <acrichto> whoa yeah
[07:44:32] *** Joins: jaen (jaen@FB01674D.56B727FE.4B52F012.IP)
[07:44:39] <strcat> anyway just an error message screwup
[07:45:02] <acrichto> if you have #[start] it works
[07:45:06] <strcat> yep
[07:45:31] <strcat> error: allocation of `int` requires `fail_bounds_check` lang_item
[07:45:37] <klutzy> wow
[07:45:40] <strcat> I guess the indexing is off
[07:45:48] <acrichto> hm yeah that may be it
[07:46:30] <acrichto> ah yes
[07:46:32] <acrichto> I think that's my fault
[07:46:44] <acrichto> thinking I could remove one and not update all the other numbers...
[07:47:04] <strcat> acrichto: numbers need to be updated in more than 1 place too ;p
[07:47:33] * ChrisMorgan wonders whether it's worthwhile updating his not-quite-functional augmented-assignment branch
[07:47:54] <Luqman> strcat: yea if you have #[no_std] you need to tell it give your own start
[07:48:21] <strcat> Luqman: yep just found an error msg bug
[07:51:42] *** Quits: lkuper__ (lkuper@72922F20.FFCF2A3B.51B6877.IP) (Ping timeout)
[07:55:21] *** Joins: MrOrdinaire (Mibbit@1A659656.A607747.FD383126.IP)
[07:56:57] <Luqman> is there no way to reference a global within the same crate in rust?
[07:57:42] <ChrisMorgan> "a global"?
[07:57:43] <Luqman> since extern { static _rust_crate_map_toplevel: CrateMap; } actually tries linking against _rust_crate_map_toplevel1 instead
[08:00:00] <acrichto> Luqman: import it via use?
[08:00:57] <MrOrdinaire> hi, could any one tell me how to handle a SIGINT in Rust?
[08:01:17] <Luqman> acrichto: you can't afaik? rustc is the one that creates it while compiling
[08:01:41] <acrichto> MrOrdinaire: hmm, I'm not entirely sure that it's possible right now
[08:01:49] <acrichto> in theory libuv has bindings, we just don't use them yet
[08:02:04] <acrichto> Luqman: as in you're declaring a rust static in one module and you're trying to use it in another?
[08:02:44] <Luqman> acrichto: as in, rustc declares this and i'm trying to access it in libstd
[08:02:44] <MrOrdinaire> acrichto: is there anyone working on that part of libuv-binding?
[08:02:57] *** Joins: sankha93 (Instantbir@7061CD01.D6BD0D91.22D41759.IP)
[08:03:10] <acrichto> MrOrdinaire: not that I know of
[08:03:22] <acrichto> Luqman: I don't think that libstd can depend on librustc?
[08:04:01] <strcat> acrichto: I wonder if anyone has actually started making a new runtimeless stdlib...
[08:04:11] <tikue_> what is the bottom line about these public/private issues? what compromise will likely need to be struck?
[08:04:37] <Luqman> acrichto: no, not librustc.
[08:04:41] <strcat> tikue_: don't know
[08:04:45] <acrichto> strcat: not that I know of, I think it's difficult right now with the __morestack crutch
[08:04:48] <strcat> not interested enough in libraries to care ;p
[08:04:50] <MrOrdinaire> acrichto: I'll need that bit of functionality. Could you point me to some code I can use as example to write such binding?
[08:05:07] <acrichto> MrOrdinaire: src/libstd/rt/uv has all the existing uv bindings
[08:05:12] <tikue_> strcat: not interested in the runtime?
[08:05:20] <acrichto> MrOrdinaire: if you google "uv book" you'll find what libuv has for exposing bindings
[08:05:28] <Luqman> acrichto: when rustc builds foo, it creates a symbol for the cratemap, i just want to access that from rust code
[08:05:30] <acrichto> MrOrdinaire: basically just follow that pattern to add some more bindings
[08:05:41] <acrichto> Luqman: oh the crate map!
[08:06:00] <acrichto> Luqman: hmmm..., extern <insert the right symbol name here> doesn't work?
[08:06:29] <Luqman> acrichto: no because llvm thinks i'm declaring something of the same name and decides to append 1 to it
[08:06:34] <Luqman> resulting in linker errors
[08:06:44] <strcat> tikue_: can do LTO or static linking
[08:06:44] <acrichto> Luqman: oh haha llvm is awesome
[08:06:54] <strcat> dynamic linking is already screwed up
[08:06:56] <MrOrdinaire> acrichto: thanks a bunnch
[08:07:11] <strcat> just need to fix the metadata and I can forget dynamic linking exists
[08:07:25] <strcat> although I ran into ICEs when I tried
[08:07:28] *** Joins: lkuper_ (lkuper@72922F20.FFCF2A3B.51B6877.IP)
[08:07:48] <acrichto> Luqman: not sure if this is possible with existing rust then, this is for removing the crate_map argument from #[start] ?
[08:07:55] <Luqman> acrichto: yep
[08:08:06] <strcat> what is the crate map even for?
[08:08:14] <acrichto> setting up logging
[08:08:25] <Luqman> acrichto: and well i can workaround by adding an attribute but that seems wrong
[08:08:39] <acrichto> Luqman: yeah that shouldn't be necessary...
[08:08:52] *** Quits: anshin (anshin@CD85F10D.F21429E2.354459FA.IP) (Quit: leaving)
[08:10:19] <acrichto> Luqman: brson's idea of an intrinsic is actually pretty good
[08:10:34] *** Joins: infynyxx (infynyxx@DB780A29.749BA1D.DCC373F0.IP)
[08:10:36] <acrichto> although possibly buggy...
[08:10:40] *** Quits: sankha93 (Instantbir@7061CD01.D6BD0D91.22D41759.IP) (Quit: Gone to save the world!)
[08:10:43] <acrichto> in case it's "inlined" in another crate
[08:11:12] <strcat> intrinsics are always inlined
[08:11:21] <strcat> unless you mean wrapping it
[08:11:39] <acrichto> yeah but this is the crate map
[08:11:42] <acrichto> which has one instance per crate
[08:11:52] <acrichto> I think...
[08:12:01] <acrichto> or maybe it's one per executable?
[08:12:14] *** Quits: infynyxx (infynyxx@DB780A29.749BA1D.DCC373F0.IP) (Ping timeout)
[08:12:15] * strcat has no idea
[08:13:00] <acrichto> Luqman: if there's only one crate map per executable, I think an intrinsic can work alright
[08:13:18] <Luqman> there's one _rust_crate_map_toplevel per executable and _rust_crate_map_[name]_[vers]_[hash] for each sub crate
[08:13:46] <acrichto> which does the pointer point to?
[08:14:00] <Luqman> toplevel
[08:14:15] <acrichto> yeah how about an intrinsic
[08:14:26] <acrichto> which is a compile-time error if you're building a library
[08:14:32] <acrichto> and otherwise it gives you the global we'd define otherwise
[08:16:15] <Luqman> acrichto: sweet! the attribute approach works!
[08:16:25] <acrichto> attribute?
[08:17:46] *** Quits: strcat (strcat@moz-54F7FD49.cpe.net.cable.rogers.com) (Quit: sleep)
[08:18:00] *** Joins: bheylin_ (brianheyli@moz-3D24C757.static.chello.nl)
[08:19:11] <acrichto> linux snapshot!
[08:20:18] <Luqman> acrichto: i kinda cheated and made it such that if an extern static was tagged with #[crate_map] it would basically make that the crate_map
[08:20:53] <acrichto> hmm...
[08:21:20] <acrichto> Luqman: interesting, I guess if it works it's not *too* bad
[08:21:27] <acrichto> I don't really have a strong preference either way
[08:27:29] *** Quits: MrOrdinaire (Mibbit@1A659656.A607747.FD383126.IP) (Quit: http://www.mibbit.com ajax IRC Client)
[08:27:52] <Luqman> acrichto: https://gist.github.com/luqmana/c51fc585ca3ebae6acdf
[08:29:18] *** Joins: CarpNet (ac@moz-FD24B77.sohonet.co.uk)
[08:30:51] *** Quits: bheylin_ (brianheyli@moz-3D24C757.static.chello.nl) (Quit: bheylin_)
[08:31:57] <acrichto> Luqman: that seems pretty good, this magical #[crate_map] attribute seems kinda bad though where it can be assigned to literally any global
[08:32:32] <Luqman> well, only extern statics
[08:32:50] <Luqman> but yea, not the best way
[08:33:16] <acrichto> I'd be a little more OK if we at least veirfied the type of the static
[08:33:23] <acrichto> but that'd be more effort than it was worth
[08:33:32] *** Joins: robertknight (robertknig@moz-54528EE0.wby.mendeley.com)
[08:34:50] <acrichto> Luqman: certainly worth a pull requet though
[08:37:03] <Luqman> acrichto: yea, just gotta figure why using my own #[start] seems to be confused about how many arguments there should be
[08:39:19] *** Quits: alex-abreu (alex@moz-7421D6C9.mc.videotron.ca) (Ping timeout)
[08:39:56] <ChrisMorgan> Why would I get "failed to find an implementation of trait std::fmt::Default for std::option::Option<http::headers::host::Host>"? What should I do about it?
[08:40:17] *** Quits: lkuper_ (lkuper@72922F20.FFCF2A3B.51B6877.IP) (Ping timeout)
[08:40:26] <acrichto> ChrisMorgan: fmt::Default isn't defined for Option
[08:40:27] <ChrisMorgan> My recollection of stuff I've overheard is that Default is intended to be replacing ToStr?
[08:40:43] <acrichto> ChrisMorgan: I don't think that's been agreed on yet
[08:41:19] *** Quits: wilmoore (wilmoore@moz-71431C3A.hsd1.co.comcast.net) (Client exited)
[08:41:49] *** Joins: wilmoore (wilmoore@moz-71431C3A.hsd1.co.comcast.net)
[08:42:09] <ChrisMorgan> But as it stands, I'll need to implement std::fmt::Default on my own types?
[08:43:04] * ChrisMorgan wishes Pidgin's smilification were more sensible than to turn the :d in std::fmt::default into a grinning smiley
[08:43:28] *** Joins: alex-abreu (alex@moz-7421D6C9.mc.videotron.ca)
[08:43:29] *** Quits: wilmoore (wilmoore@moz-71431C3A.hsd1.co.comcast.net) (Ping timeout)
[08:43:46] <myname> ChrisMorgan: that's why you neither use multi im clients for irc nor use smilification
[08:45:57] *** Joins: ghrust (ghrust@2EE61FCC.6A2AE50.F3114085.IP)
[08:45:57] <ghrust> 01[13rust01] 15bors merged 06auto into 06master: 02http://git.io/RW7XOg
[08:45:57] *** Parts: ghrust (ghrust@2EE61FCC.6A2AE50.F3114085.IP) ()
[08:46:56] <acrichto> ChrisMorgan: yes (fmt::Default on your own types)
[08:47:12] <acrichto> I'm not totally inclined to have that change much, others may feel differently though
[08:50:57] *** Joins: ghrust (ghrust@79968228.6A2AE50.F3114085.IP)
[08:50:57] <ghrust> 01[13rust01] 15bors pushed 0 new commits to 06auto: 02http://git.io/d9hYXw
[08:50:57] *** Parts: ghrust (ghrust@79968228.6A2AE50.F3114085.IP) ()
[08:50:57] *** Joins: ghrust (ghrust@F6EE6DE3.6A2AE50.F3114085.IP)
[08:50:58] <ghrust> 01[13rust01] 15bors pushed 2 new commits to 06auto: 02http://git.io/EGlE1Q
[08:50:58] <ghrust> 13rust/06auto 1444f602d 15Tim Chevalier: rustpkg: Make crates, not packages, the unit of rustpkg dependencies...
[08:50:58] <ghrust> 13rust/06auto 14153e547 15bors: auto merge of #9263 : catamorphism/rust/rustpkg-issue-7879, r=brson...
[08:50:58] *** Parts: ghrust (ghrust@F6EE6DE3.6A2AE50.F3114085.IP) ()
[08:51:02] *** Joins: Blub\w (wry@7E3BB9D.71150E1A.237AE2BA.IP)
[08:53:53] <mib_a90qrk> Hey folks - what's the difference between a MemReader, BufferedReader, and a BytesReader?
[08:56:07] *** Joins: lkuper_ (lkuper@72922F20.FFCF2A3B.51B6877.IP)
[08:59:51] *** Quits: alex-abreu (alex@moz-7421D6C9.mc.videotron.ca) (Ping timeout)
[09:00:57] *** Joins: nano (nano@moz-74CAD1CA.superkabel.de)
[09:01:19] *** Quits: ww (Mibbit@moz-DFAED48A.lightspeed.sntcca.sbcglobal.net) (Quit: http://www.mibbit.com ajax IRC Client)
[09:01:52] <klutzy> MemReader is for vectors, BufferedReader is for readers
[09:02:10] <klutzy> don't know about BytesReader though
[09:02:42] <mib_a90qrk> thanks klutzy!
[09:03:02] <klutzy> mib_a90qrk: seems like BytesReader is at std::io, other two are at std::rt::io
[09:03:43] <klutzy> std::io::Reader and std::rt::io::Reader don't mix well
[09:04:02] <klutzy> I think std::io will be replaced by std::rt::io
[09:04:20] <mib_a90qrk> oh, gotcha
[09:04:22] *** Joins: donri (donri@moz-9BB61102.tbcn.telia.com)
[09:05:13] *** Quits: Shaladdle (anonymous@moz-424BC304.hsd1.pa.comcast.net) (Quit: Shaladdle)
[09:06:07] <mib_a90qrk> is there an equivalent of select or poll for readers / writers?
[09:07:11] *** Quits: txdv (quassel@966F3542.3BA477DA.14C26596.IP) (Ping timeout)
[09:08:01] *** Joins: alex-abreu (alex@moz-7421D6C9.mc.videotron.ca)
[09:08:10] *** Quits: ceninan (ceninan@moz-6BD43586.a370.priv.bahnhof.se) (Ping timeout)
[09:10:53] *** Joins: infynyxx (infynyxx@DB780A29.749BA1D.DCC373F0.IP)
[09:12:34] *** Quits: infynyxx (infynyxx@DB780A29.749BA1D.DCC373F0.IP) (Ping timeout)
[09:14:42] *** Joins: mihneadb (mihneadb@41E65AA5.B2E373EA.FCAAE698.IP)
[09:16:23] *** Quits: alex-abreu (alex@moz-7421D6C9.mc.videotron.ca) (Ping timeout)
[09:18:29] *** Quits: bjz (brendanzab@B398BE78.F804C29E.D35A31DF.IP) (Quit: Leaving...)
[09:18:45] *** Joins: bjz (brendanzab@B398BE78.F804C29E.D35A31DF.IP)
[09:20:07] *** Joins: alex-abreu (alex@moz-7421D6C9.mc.videotron.ca)
[09:25:51] *** Quits: tikue_ (tkuehn@moz-FEADCD38.hsd1.pa.comcast.net) (Quit: tikue_)
[09:25:58] *** Joins: ghrust (ghrust@DE823A67.6A2AE50.F3114085.IP)
[09:25:58] <ghrust> 01[13rust01] 15bors 04force-pushed 06auto from 14153e547 to 147dd9344: 02http://git.io/N3iJvQ
[09:25:58] *** Parts: ghrust (ghrust@DE823A67.6A2AE50.F3114085.IP) ()
[09:25:58] *** Joins: ghrust (ghrust@1E8607E8.6A2AE50.F3114085.IP)
[09:25:58] <ghrust> 01[13rust01] 15bors pushed 3 new commits to 06auto: 02http://git.io/3CnX1Q
[09:25:58] <ghrust> 13rust/06auto 14c3fd430 15Vadim Chugunov: The purpose of these headers is to fix issues with mingw v4.0, as described in #9246....
[09:25:58] <ghrust> 13rust/06auto 14e6832e6 15Vadim Chugunov: Disabled tests which now fail on Windows+mingw4.0 due to GCC 4.8 ABI change (#9205)....
[09:25:59] <ghrust> 13rust/06auto 14adb638f 15bors: auto merge of #9254 : vadimcn/rust/fix-mingw-v4, r=brson...
[09:26:01] *** Parts: ghrust (ghrust@1E8607E8.6A2AE50.F3114085.IP) ()
[09:30:20] *** Quits: lkuper_ (lkuper@72922F20.FFCF2A3B.51B6877.IP) (Ping timeout)
[09:40:52] *** Quits: bjz (brendanzab@B398BE78.F804C29E.D35A31DF.IP) (Connection reset by peer)
[09:40:54] *** Joins: bjz_ (brendanzab@B398BE78.F804C29E.D35A31DF.IP)
[09:44:41] *** Quits: ldunn (username@moz-94CB0FA.cyberius.net) (Ping timeout)
[09:46:04] *** Joins: lkuper_ (lkuper@72922F20.FFCF2A3B.51B6877.IP)
[09:47:52] *** Quits: lkuper_ (lkuper@72922F20.FFCF2A3B.51B6877.IP) (Ping timeout)
[09:48:29] *** Joins: ldunn (username@moz-94CB0FA.cyberius.net)
[09:51:06] *** Joins: pnkfelix (pnkfelix@87C1F78E.1DE10CA8.D8E68FF6.IP)
[09:54:34] *** Quits: [a]bacus (snoonan_mo@moz-F95B9243.hsd1.wa.comcast.net) (Ping timeout)
[09:55:59] *** Joins: anshin (anshin@CD85F10D.F21429E2.354459FA.IP)
[09:59:02] <jzelinskie> is there a better way to match if all i care about are guards? https://gist.github.com/jzelinskie/69c9462a44e0271a0ddb
[09:59:40] <Jesse> use an if..else if chain instead?
[09:59:57] <jzelinskie> is that more idiomatic?
[10:00:11] <jzelinskie> i feel bad having long else if chains
[10:01:12] *** Quits: anshin (anshin@CD85F10D.F21429E2.354459FA.IP) (Quit: leaving)
[10:02:53] <Jesse> for the middle ones you could use "2..4" and "1" as the patterns
[10:02:56] <Jesse> not sure about the first
[10:02:58] *** Joins: anshin (anshin@CD85F10D.F21429E2.354459FA.IP)
[10:03:24] <Jesse> i tried "5.._" and "5..", neither parsed
[10:04:40] *** Quits: mihneadb (mihneadb@41E65AA5.B2E373EA.FCAAE698.IP) (Input/output error)
[10:05:06] *** Joins: lkuper_ (lkuper@128FCA.1C5FF2E6.51B6877.IP)
[10:05:19] *** Joins: jxv (jxv@moz-8FB92450.lightspeed.irvnca.sbcglobal.net)
[10:07:33] *** Joins: [a]bacus (snoonan_mo@moz-F95B9243.hsd1.wa.comcast.net)
[10:07:47] *** [a]bacus is now known as abacus
[10:10:11] *** pnkfelix is now known as pnkfelix-lunch
[10:10:25] <Jesse> is there syntax for open-ended match ranges?
[10:10:38] <Jesse> or do you have to write like "5..int::max"
[10:11:09] *** Quits: anshin (anshin@CD85F10D.F21429E2.354459FA.IP) (Quit: leaving)
[10:11:14] *** Joins: infynyxx (infynyxx@DB780A29.749BA1D.DCC373F0.IP)
[10:11:31] <jzelinskie> duno, that's a good question
[10:11:38] <kimundi> jzelinskie: There is also a cond!() macro
[10:12:05] <jzelinskie> kimundi: I'm attempting to do this: https://github.com/mozilla/rust/issues/9282
[10:12:10] <kimundi> rusti: cond!( (false) => { "foo" }, (true) => "bar" )
[10:12:10] -rusti- <anon>:7:24: 7:26 error: expected `{` but found `=>`
[10:12:11] -rusti- <anon>:7          cond!( (false) => { "foo" }, (true) => "bar" )
[10:12:11] -rusti-                                  ^~
[10:12:11] -rusti- application terminated with error code 101
[10:12:24] <kimundi> rusti: cond!( (false) { "foo" }, (true) {"bar"} )
[10:12:25] -rusti- <anon>:7:33: 7:34 error: No rules expected the token: ,
[10:12:25] -rusti- <anon>:7          cond!( (false) { "foo" }, (true) {"bar"} )
[10:12:25] -rusti-                                           ^
[10:12:25] -rusti- application terminated with error code 101
[10:12:29] <kimundi> rusti: cond!( (false) { "foo" } (true) {"bar"} )
[10:12:30] -rusti- pastebinned 8 lines of output: http://sprunge.us/aCFQ
[10:12:54] *** Quits: infynyxx (infynyxx@DB780A29.749BA1D.DCC373F0.IP) (Ping timeout)
[10:13:00] <kimundi> ... oh :P
[10:13:01] <jzelinskie> i'm rewriting old cond! usages
[10:13:05] <jzelinskie> yeah
[10:13:40] <kimundi> mult if elseif else or match () { _ => if ... } it is then
[10:14:31] <jzelinskie> i think i'll do the void match
[10:15:53] *** Quits: lkuper_ (lkuper@128FCA.1C5FF2E6.51B6877.IP) (Ping timeout)
[10:18:25] <nmatsakis> jzelinskie: I prefer "match () { () if =>" 
[10:18:25] <Jesse> what is cond! for
[10:18:30] <nmatsakis> oh I see kimundi suggetsed it
[10:18:38] <nmatsakis> but, there is a macro, maybe it's cond!? that bjz_ defined
[10:19:01] <jzelinskie> nmatsakis: that macro is being removed
[10:19:03] <kimundi> nmatsakis: To bad that this is about removing cond! :P
[10:19:09] <nmatsakis> oh
[10:19:10] <jzelinskie> i'm cleaning up
[10:19:13] <nmatsakis> I see
[10:19:16] <nmatsakis> I wasn't really following :)
[10:19:30] <nmatsakis> I find `match () { () if => ` ok...
[10:19:39] <nmatsakis> or `_ if`
[10:19:45] <jzelinskie> Jesse: cond! is basically an idea from lisp
[10:19:54] <bjz_> shame we could never get the cond syntax nicer
[10:19:55] <jzelinskie> lets you list a bunch of cases
[10:20:11] <bjz_> with the limitations of macros :(
[10:20:13] <Jesse> nmatsakis: when do you use "match ()" instead of "if ... else if" ?
[10:20:47] <kimundi> Jesse: Doesn't matter. If one looks better than the other :P
[10:21:07] <nmatsakis> Jesse: I... generally use if/else-if to be honest :)
[10:21:15] * bjz_ wanted cond! { x { ... } y { ... } else { ... } }
[10:21:24] <nmatsakis> Jesse: I pretty much never have such long chains of guards
[10:21:30] <bjz_> jzelinskie: np, remove it
[10:22:06] <jzelinskie> I'm just doing clean up; i never asked for this ;)
[10:22:13] *** Joins: q66 (q66@6EE9DE40.46454B5D.33AABD5F.IP)
[10:22:31] <kimundi> haha
[10:22:58] *** Joins: orshem (orshem@F0A9EA9.588A166C.E3D28531.IP)
[10:23:08] <bjz_> guh, kill my babies why don't you
[10:23:12] <jzelinskie> is it better to do match () { () if ... => ... } or match () { _ if ... => ... }
[10:23:27] <bjz_> ^_^
[10:23:45] <orshem> hello rusties
[10:23:52] <bjz_> orshem: arp
[10:24:06] <bjz_> jzelinskie: just use ifelse
[10:24:35] <kimundi> bjz: but pretty collumn lineup!
[10:24:42] <jzelinskie> pretty much ^
[10:24:46] <bjz_> kimundi: I know :(
[10:24:59] <kimundi> jzelinskie: Just decide aesthetically
[10:25:03] <bjz_> kimundi: that was the impetus behind cond
[10:25:12] <kimundi> Which do you think looks nicer ? :P
[10:25:44] <jzelinskie> blasphemy you were just trying to sneak your lisp into rust
[10:25:51] <kimundi> Actually, I think () looks nice, thinking about it
[10:26:11] <orshem> is range(0u, 1000000u).collect() o(1)? o(n)? 
[10:26:14] <Jesse>  if you want your columns to line up, use a font that condenses "else if" to "ef"
[10:26:17] <bjz_> https://github.com/bjz/cgmath-rs/blob/master/src/cgmath/matrix.rs#L563
[10:26:32] <kimundi> orshem: ... For which of those two operations?
[10:27:03] <bjz_> mega cond
[10:27:12] <jzelinskie> soon to be mega match
[10:27:25] <orshem> kimundi, both. getting a vector such as [1, 2, 3, 4, ...
[10:27:41] <kimundi> orshem: range will yield an option value 1000000 times, collect will allocate an vector once because of sizehint, then push 1000000 time to it
[10:27:46] <bjz_> jzelinskie: yarup
[10:27:58] <kimundi> orshem: But all that will get optimized by llvm
[10:28:35] * bjz_ doesn't need to kill his babies anymore, he gets other people to do it for him
[10:28:41] <kimundi> orshem: For llvm optimisation, ask strcat or look at the assembly :P
[10:29:03] <bjz_> :P
[10:29:03] <Jesse> bjz_: that doesn't work in Crusader Kings :(
[10:29:12] <bjz_> Jesse: ?
[10:29:53] <Jesse> bjz_: you can get others to help you kill most people, but not your own babies
[10:30:08] <bjz_> wahuh?
[10:30:12] <bjz_> o_o
[10:30:17] <orshem> kimundi, thanks. my assembly experience ended with a mips course some time ago...
[10:30:38] <orshem> i guess i will just time different approaches
[10:30:51] <orshem> is there a time function?
[10:31:04] <kimundi> orshem: Make sure you compile optimized
[10:31:15] <orshem> yep. --opt-level 3
[10:31:20] *** Joins: lkuper_ (lkuper@128FCA.1C5FF2E6.51B6877.IP)
[10:31:46] <kimundi> orshem: Best try all existing opt levels, I remember there being weird issues where opt3 was slower than opt2
[10:32:41] <orshem> kimundi, that's good to know. thanks.
[10:33:03] <orshem> is there a a way to time a function inside rust?
[10:33:53] *** Quits: nano (nano@moz-74CAD1CA.superkabel.de) (Connection reset by peer)
[10:34:25] *** Quits: lkuper_ (lkuper@128FCA.1C5FF2E6.51B6877.IP) (Ping timeout)
[10:35:40] <orshem> bjz_, what's arp?
[10:35:54] <orshem> not a native speaker
[10:36:15] <Jesse> i thought i was an IRC native but i don't know what arp means
[10:36:30] <bjz_> orshem: neither do I
[10:36:40] <bjz_> arp
[10:36:42] <bjz_> arup
[10:37:14] <bjz_> x)
[10:37:19] <Jesse> could it be The Answer?
[10:37:23] <Jesse> to The Question?
[10:37:28] <Jesse> "What the Fox Say?"
[10:37:50] <orshem> :)
[10:38:00] * bjz_ is even more confused, and he was the one who started it
[10:38:50] <dbaupp> orshem: it has to be O(n); there's no O(1) way to allocate a vector with different entries
[10:39:00] <Jesse> http://www.youtube.com/watch?v=jofNR_WkoCE
[10:39:13] <jzelinskie> oh god i saw that trending, really dumb video
[10:39:22] <orshem> dbaupp, you're right. i'm dense :)
[10:40:02] <dbaupp> orshem: also #[bench], https://github.com/mozilla/rust/wiki/Doc-unit-testing#benchmarking
[10:41:20] <jzelinskie> umm.. if the cond is commented out, do i fix that?lol
[10:42:45] <dbaupp> jzelinskie: delete it?
[10:46:25] <jzelinskie> well they're notes in libsyntax/ext/expand.rs
[10:46:46] <orshem> dbaupp, that's what i needed
[10:46:51] <orshem> but rust is too good
[10:47:02] <orshem> test bench_from_fn ... bench: 0 ns/iter (+/- 0) test bench_range ... bench: 0 ns/iter (+/- 0)
[10:47:08] <dbaupp> haha
[10:47:10] <orshem> it optimize everything away
[10:47:17] <dbaupp> just use the result somehow
[10:47:27] <orshem> i did in a sum
[10:47:36] *** Joins: Earnestly (earnest@moz-BE290A2B.dyn.plus.net)
[10:47:50] <dbaupp> e.g. if random() == 0u { println!("{:?}", vector) }
[10:48:06] *** Quits: nrc (nrc@7BE24E90.A5032A01.3CFC199D.IP) (Ping timeout)
[10:48:08] <dbaupp> the chance of it being 0 is very small, so it's probably never going to print it
[10:48:16] *** Joins: dave1629 (dave@moz-17578A1A.hsd1.va.comcast.net)
[10:48:54] <dbaupp> jzelinskie: aren't they a comment just before the definition of `cond!`? i.e. they definitely need to go
[10:49:38] <jzelinskie> yeah grep just printed it like that, but now that i look at it, they are not
[10:50:02] <orshem> dbaupp, the vector is too big but i tried printing some elements and it doesn't help... :)
[10:50:42] <dbaupp> orshem: don't print the whole thing always: put it in an if that rarely/never happens
[10:50:58] *** Quits: tgummerer (tgummerer@51D3B54.FEF996EA.EA6FEF3D.IP) (Ping timeout)
[10:51:19] <dbaupp> (but make it so that LLVM can't tell that it never happens, e.g. depending on something at runtime, like random numbers, or length of os::args())
[10:51:32] <jzelinskie> dbaupp: should i be deleting the cond definiton too?
[10:51:37] <jzelinskie> i suppose so
[10:51:58] <dbaupp> that's the point of removing it, yeah? :)
[10:52:09] *** Joins: lkuper_ (lkuper@72922F20.FFCF2A3B.51B6877.IP)
[10:53:00] <jzelinskie> https://github.com/mozilla/rust/blob/master/src/libsyntax/ext/expand.rs#L757
[10:53:09] <jzelinskie> do i delete those as well?
[10:53:22] <dbaupp> assert! ? no
[10:53:31] <jzelinskie> i wasn't sure what those were doing
[10:53:32] <dbaupp> the $cond isn't the same as the cond! macro
[10:53:42] <jzelinskie> yeah i wasn't positive, which is why i asked :)
[10:53:53] <orshem> dbaupp: still doesn't work...
[10:54:11] <dbaupp> orshem: code?
[10:56:02] <orshem> dbaupp: https://gist.github.com/dovreshef/6607535
[10:59:51] <dbaupp> orshem: I don't know, the post-optimisation llvm IR looks like it should be doing proper work, but it's clearly not. :(
[11:00:27] *** pnkfelix-lunch is now known as pnkfelix
[11:00:57] *** Quits: lkuper_ (lkuper@72922F20.FFCF2A3B.51B6877.IP) (Ping timeout)
[11:01:02] *** Joins: ghrust (ghrust@C8693FCB.6A2AE50.F3114085.IP)
[11:01:02] <ghrust> 01[13rust01] 15bors merged 06auto into 06master: 02http://git.io/3CnX1Q
[11:01:02] *** Parts: ghrust (ghrust@C8693FCB.6A2AE50.F3114085.IP) ()
[11:02:06] *** Quits: dew1 (Instantbir@moz-D2FA52B6.static.stls.mo.charter.com) (Ping timeout)
[11:02:14] <jzelinskie> make check is pretty much killing my macbook air ;_;
[11:02:17] *** Joins: ceninan (ceninan@moz-6BD43586.a370.priv.bahnhof.se)
[11:02:49] *** Joins: dew (Instantbir@moz-D2FA52B6.static.stls.mo.charter.com)
[11:03:02] *** Joins: dnn (daniel@44EEC4CB.16D3B2F1.79933D60.IP)
[11:03:40] *** Joins: canhtak (jeremy@moz-8CBCE134.wl.t.ulaval.ca)
[11:05:57] *** Joins: ghrust (ghrust@9C8B94D4.6A2AE50.F3114085.IP)
[11:05:57] <ghrust> 01[13rust01] 15bors pushed 0 new commits to 06auto: 02http://git.io/-cOPvA
[11:05:57] *** Parts: ghrust (ghrust@9C8B94D4.6A2AE50.F3114085.IP) ()
[11:05:59] *** Joins: ghrust (ghrust@24260B07.6A2AE50.F3114085.IP)
[11:05:59] <ghrust> 01[13rust01] 15bors pushed 2 new commits to 06auto: 02http://git.io/zuy_pw
[11:05:59] <ghrust> 13rust/06auto 14ba384ff 15Alex Crichton: Implement process bindings to libuv...
[11:05:59] <ghrust> 13rust/06auto 146bbec92 15bors: auto merge of #9260 : alexcrichton/rust/libuv-processes, r=brson...
[11:05:59] *** Parts: ghrust (ghrust@24260B07.6A2AE50.F3114085.IP) ()
[11:09:16] <kimundi> Need a re-r+: https://github.com/mozilla/rust/pull/9267
[11:11:34] *** Joins: infynyxx (infynyxx@DB780A29.749BA1D.DCC373F0.IP)
[11:12:33] *** Joins: Ferreus (daniel@moz-BC40404.pools.arcor-ip.net)
[11:12:52] *** Quits: pauls (pauls@moz-7140CF01.ccs.neu.edu) (Ping timeout)
[11:13:13] *** Quits: infynyxx (infynyxx@DB780A29.749BA1D.DCC373F0.IP) (Ping timeout)
[11:13:17] <dbaupp> kimundi: what changed?
[11:14:11] <kimundi> dbaupp: rustdoc_ng needed an to be changed to use the new getopts methods too, and one or two doc comments
[11:14:27] <kimundi> I repushed just now, btw
[11:15:58] *** Joins: ghrust (ghrust@79968228.6A2AE50.F3114085.IP)
[11:15:58] <ghrust> 01[13rust01] 15bors 04force-pushed 06auto from 146bbec92 to 14adb638f: 02http://git.io/N3iJvQ
[11:15:58] *** Parts: ghrust (ghrust@79968228.6A2AE50.F3114085.IP) ()
[11:16:00] *** Joins: ghrust (ghrust@2EE61FCC.6A2AE50.F3114085.IP)
[11:16:00] <ghrust> 01[13rust01] 15bors pushed 3 new commits to 06auto: 02http://git.io/j-ypBw
[11:16:00] <ghrust> 13rust/06auto 14aa406c1 15Benjamin Herr: pp: typo in comment
[11:16:00] <ghrust> 13rust/06auto 14823ebb1 15Benjamin Herr: pp: also print bounds in paths with no generic params...
[11:16:00] <ghrust> 13rust/06auto 14b8d3496 15bors: auto merge of #9264 : ben0x539/rust/pp-work, r=alexcrichton...
[11:16:01] *** Parts: ghrust (ghrust@2EE61FCC.6A2AE50.F3114085.IP) ()
[11:16:48] <benh> :3
[11:24:17] *** Quits: orshem (orshem@F0A9EA9.588A166C.E3D28531.IP) (Ping timeout)
[11:24:47] *** Quits: dnn (daniel@44EEC4CB.16D3B2F1.79933D60.IP) (Quit: Ex-Chat)
[11:29:02] *** Joins: pauls (pauls@moz-7140CF01.ccs.neu.edu)
[11:34:56] *** Quits: dave1629 (dave@moz-17578A1A.hsd1.va.comcast.net) (Quit: dave1629)
[11:38:31] <kimundi> dbaupp: hm, apparently automatic extern fn -> &fn coercion breaks down if you give type parameters
[11:38:51] <kimundi> .and_then(from_str) // error: unconstrained type
[11:39:08] <kimundi> .and_then(from_str::<f64>) // error: expected `&fn<no-bounds>(~str) -> std::option::Option<<V731>>` but found `extern "Rust" fn(&str) -> std::option::Option<f64>` (str storage differs: expected ~ but found &)
[11:39:40] <dbaupp> kimundi: ha, wrap it in a closure.
[11:41:02] <kimundi> .and_then(|s| from_str::<f64>(s)).unwrap() vs .map_move(|s| from_str::<f64>(s).unwrap()) 
[11:41:06] <mib_a90qrk> will stdout always be a @?
[11:41:12] <kimundi> mib_a90qrk: no
[11:41:28] <kimundi> dbaupp: which do you prefer? :P
[11:41:34] <dbaupp> kimundi: the unwrap isn't necessary in the first one
[11:41:39] <kimundi> it is
[11:41:42] <dbaupp> (ewll, in fact, it's required to not be there)
[11:41:50] <kimundi> and_then maps option -> option
[11:41:56] <dbaupp> Option<T>.map_move(fn(T) -> U) -> Option<U>
[11:41:57] <dbaupp> yeah
[11:42:06] <mib_a90qrk> kimundi: is it @ out of necessity or convenience?
[11:42:10] <dbaupp> Option<T>.and_then(fn(T) -> Option<U>) -> Option<U>
[11:42:13] <dbaupp> mib_a90qrk: history
[11:42:13] <kimundi> mib_a90qrk: legacy cruft
[11:42:31] <mib_a90qrk> ahh
[11:42:31] <kimundi> dbaupp: wait, I'm confused
[11:42:39] <jzelinskie> ok, so how does one go about making a 'regression test' for my PR, i'm lokoing at a wiki page and still a little confused
[11:42:45] *** Joins: sankha93 (Instantbir@7061CD01.D6BD0D91.22D41759.IP)
[11:42:45] <dbaupp> mib_a90qrk: we're moving to the pure Rust runtime, which has a much nicer io story, so stdio will be converted to that
[11:42:50] * kimundi misunderstood the api
[11:42:53] *** Joins: orshem (orshem@F0A9EA9.588A166C.E3D28531.IP)
[11:43:19] <dbaupp> jzelinskie: if you're just deleting stuff, then the "regression test" is deleting all trace of cond!, include the tests for it; since the compile will fail if anyone writes an occurance of it.
[11:44:33] *** flaper87|afk is now known as flaper87
[11:44:38] <dbaupp> mib_a90qrk: (i actually think stdio is the last to be converted; we've had network io for a while, and file io was a week or two ago, and so stdio is the last major hurdle to have all the -io's in the nice API. :) )
[11:45:15] <mib_a90qrk> :)
[11:45:17] <dbaupp> jzelinskie: *including the tests
[11:45:18] <dbaupp> kimundi: hm, am I correct or did I misunderstand it too?
[11:45:49] <jzelinskie> so i don't have to write anything else if i've already deleted/replaced all occurances of cond! and deleted the tests for it right?
[11:45:57] <kimundi> dbaupp: You'Re correct
[11:46:08] <kimundi> dbaupp: Didn't realize that map_move still returns an Option
[11:46:23] <kimundi> dbaupp: And that the target type was supposed to be an Option<f64>
[11:46:39] <dbaupp> jzelinskie: just a commit message :P
[11:46:47] <kimundi> dbaupp: repushed an and_then(|s| from_str::<f64>(s)) version
[11:46:48] <jzelinskie> ok, cool
[11:47:50] <jzelinskie> thanks
[11:47:57] <dbaupp> kimundi: I've got to dash (well, concentrate on my assignment due tomorrow), and I didn't really review it properly; so I'll have to leave the rest of the review upto someone else (they'll do a better job anyway :P )
[11:48:45] <kimundi> dbaupp: hmkay :P
[11:50:28] <kimundi> rusti: from_str
[11:50:29] -rusti- <anon>:7:9: 7:17 error: cannot determine a type for this bounded type parameter: unconstrained type
[11:50:29] -rusti- <anon>:7          from_str
[11:50:29] -rusti-                   ^~~~~~~~
[11:50:29] -rusti- application terminated with error code 101
[11:50:34] <kimundi> rusti: from_str::<f64>
[11:50:35] -rusti- fn(&str) -> std::option::Option<f64>
[11:50:43] *** Quits: orshem (orshem@F0A9EA9.588A166C.E3D28531.IP) (Quit: Leaving)
[11:55:09] *** Quits: nkoep (nik@moz-1E78C081.pool.mediaways.net) (Ping timeout)
[12:00:47] *** Quits: DasIch (dasich@moz-5EDA591.de) (Ping timeout)
[12:01:12] *** Quits: clonejo (clonejo@moz-CC9FD036.de) (Ping timeout)
[12:01:29] *** Joins: clonejo (clonejo@moz-CC9FD036.de)
[12:02:24] *** Joins: DasIch (dasich@moz-5EDA591.de)
[12:08:24] <SimonSapin> https://github.com/mozilla/rust/wiki/Meeting-weekly-2013-09-17#0-change-in-the-queue seems to be lacking a bit of context. What is it about?
[12:09:10] <benh> There is an issue https://github.com/mozilla/rust/issues/9143 
[12:09:50] <SimonSapin> thanks
[12:09:51] *** Joins: msingle (Thunderbir@moz-930E5D97.hr.hr.cox.net)
[12:11:13] *** Joins: nkoep (nik@moz-C551C6AA.vpn.rwth-aachen.de)
[12:11:52] *** Joins: sebcrozet (sebcrozet@moz-3CE49532.lrde.epita.fr)
[12:11:53] *** Joins: infynyxx (infynyxx@DB780A29.749BA1D.DCC373F0.IP)
[12:12:02] <mib_a90qrk> will Reader / Writer always have @ or will that go away with the new rt as well?
[12:12:34] <dbaupp> mib_a90qrk: yes, that's disappearing: std::rt::io::{Reader,Writer} don't use it at all
[12:13:33] *** Quits: infynyxx (infynyxx@DB780A29.749BA1D.DCC373F0.IP) (Ping timeout)
[12:18:19] <jzelinskie> does anybody with a fast CPU want to 'make check' my branch? https://github.com/jzelinskie/rust/tree/remove-cond
[12:18:58] <jzelinskie> mines been going for far too long as it doesn't run in parallel
[12:21:37] *** Joins: Kruppe (user@moz-E150F49F.cpe.net.cable.rogers.com)
[12:22:16] <kimundi> jzelinskie: eh, rust doesn't run parallel anywhere, so :P
[12:22:35] <jzelinskie> oh, i thought the warnings about pthread implied that it did on linux
[12:22:37] <dbaupp> jzelinskie: probably don't need to: if there is no trace of `cond!` in any source file (including the documentation) then that's good enough for this type of patch.
[12:23:16] <dbaupp> (i.e. no results for `git grep "cond!"` from the top of the repo)
[12:23:40] <kimundi> jzelinskie: If make check-stage1 passes, that's usually good enough. Of course the difference between that and make check isn't that big, it still test the same, just compiles one set of libraries and compiler less
[12:24:54] <kimundi> jzelinskie: The Integration bot will run the full testsuite anyway before merging, so even if something slips, nothing bad will happen except time wasting :P
[12:25:39] <jzelinskie> yep, i just want to open this PR before i go to sleep
[12:25:56] <jzelinskie> so i just did, i'll deal with the ramifications tomorrow
[12:25:56] <jzelinskie> :)
[12:25:58] *** Joins: ghrust (ghrust@24260B07.6A2AE50.F3114085.IP)
[12:25:58] <ghrust> 01[13rust01] 15bors merged 06auto into 06master: 02http://git.io/j-ypBw
[12:25:58] *** Parts: ghrust (ghrust@24260B07.6A2AE50.F3114085.IP) ()
[12:26:50] <jzelinskie> i swear every time i compile or pull or anything with master, it gets touched immediately after
[12:27:06] *** Joins: brianm (brianm@CE36CB47.15418CA7.5114C2BC.IP)
[12:27:18] <kimundi> haha
[12:28:30] <jzelinskie> is there a CLA you have to sign?
[12:29:03] <dbaupp> yes, but it's not urgent for small contributions
[12:29:09] <kimundi> jzelinskie: Well, I'm doing PRs since 6 months, and I didn't sign anything till now :P
[12:29:38] <dbaupp> jzelinskie: https://github.com/mozilla/rust/wiki/Note-development-policy#contributions-and-commit-access
[12:29:55] <dbaupp> "If your contribution is nontrivial, we ask that you file a Mozilla "committer agreement"."
[12:30:18] <dbaupp> kimundi: (you probably should; I'm sure one of the mozillians would be willing to point you in the right direction.)
[12:30:37] <kimundi> dbaupp: Yeah, need to ask that at some point :P
[12:30:42] <jzelinskie> ok cool
[12:30:59] *** Joins: ghrust (ghrust@24260B07.6A2AE50.F3114085.IP)
[12:30:59] <ghrust> 01[13rust01] 15bors pushed 0 new commits to 06auto: 02http://git.io/kwY7uA
[12:30:59] *** Parts: ghrust (ghrust@24260B07.6A2AE50.F3114085.IP) ()
[12:31:01] *** Joins: ghrust (ghrust@2EE61FCC.6A2AE50.F3114085.IP)
[12:31:01] <ghrust> 01[13rust01] 15bors pushed 2 new commits to 06auto: 02http://git.io/nNGACw
[12:31:01] <ghrust> 13rust/06auto 1434ac5b0 15Brian Anderson: Add an extra line before the "Additional Help" in rustc's --help output
[12:31:01] <ghrust> 13rust/06auto 1410d26f8 15bors: auto merge of #9271 : brson/rust/extra-help, r=catamorphism...
[12:31:02] *** Parts: ghrust (ghrust@2EE61FCC.6A2AE50.F3114085.IP) ()
[12:31:13] *** Quits: Ferreus (daniel@moz-BC40404.pools.arcor-ip.net) (Quit: WeeChat 0.4.1)
[12:32:49] <jzelinskie> well I'm off to bed, thanks for the help everyone
[12:33:02] <jzelinskie> hopefully i'll be able to handle some more low hanging fruit in the future
[12:33:34] <bstrie> jzelinskie: good night!
[12:33:42] <dbaupp> jzelinskie: thanks :)
[12:33:54] <dbaupp> <3 more contributors
[12:37:18] <bstrie> dictionary.com word of the day: monad
[12:37:31] <bstrie> "a single unit or entity"
[12:37:43] *** flaper87 is now known as flaper87|afk
[12:38:05] <bstrie> and here I thought it had something to do with tacos and endofunctors
[12:40:15] *** Joins: afrey71 (Mibbit@moz-9D412872.mss.so)
[12:40:44] <dbaupp> spacesuits too
[12:43:35] *** Joins: dave1629 (dave@moz-17578A1A.hsd1.va.comcast.net)
[12:43:39] *** Joins: nano (nano@moz-74CAD1CA.superkabel.de)
[12:43:46] <benh> > Global variables are a code smell. Instead, pass a single mu
[12:43:47] <benh> table hashmap through every function. Name it "monad". Keeps 'em on their toes.
[12:47:22] *** Joins: sw17ch (sw17ch@moz-39D8564F.wndsny.tds.net)
[12:47:53] *** Quits: dave1629 (dave@moz-17578A1A.hsd1.va.comcast.net) (Quit: dave1629)
[12:48:23] *** Joins: Larry (larryfox@moz-343B6F0C.nyc.biz.rr.com)
[12:48:23] *** Quits: sankha93 (Instantbir@7061CD01.D6BD0D91.22D41759.IP) (Quit: Gone to save the world!)
[12:48:27] <afrey71> Can I check an enum against a variant in an 'if', i.e. a shorthand for match e { variant: { do_it(); }, _ => {} }?
[12:48:47] <bstrie> afrey71: nope, gotta match to check a variant
[12:49:00] <afrey71> bstrie: okay, thanks.
[12:49:10] <afrey71> Can I match against nested enums?
[12:49:12] <bstrie> if it's a common thing, you can write a function that does the match
[12:49:23] <bstrie> afrey71: pretty sure you can? never tried
[12:49:39] <bstrie> you mean something like `match foo { Variant1(Variant2(bar)) => ... }` ?
[12:50:00] <afrey71> bstrie: that'd be awesome. I'll try it...
[12:50:07] <bstrie> it's a good question
[12:50:16] <dbaupp> rusti: match Some(Some(Some(1))) => { Some(None) => 0, Some(Some(Some(x) => x, _ => -1 }
[12:50:16] -rusti- <anon>:7:89: 7:90 error: incorrect close delimiter: `}`
[12:50:17] -rusti- <anon>:7          match Some(Some(Some(1))) => { Some(None) => 0, Some(Some(Some(x) => x, _ => -1 }
[12:50:17] -rusti-                                                                                                   ^
[12:50:17] -rusti- application terminated with error code 101
[12:50:23] <dbaupp> rusti: match Some(Some(Some(1))) => { Some(None) => 0, Some(Some(Some(x))) => x, _ => -1 }
[12:50:23] -rusti- <anon>:7:35: 7:37 error: expected `{` but found `=>`
[12:50:23] -rusti- <anon>:7          match Some(Some(Some(1))) => { Some(None) => 0, Some(Some(Some(x))) => x, _ => -1 }
[12:50:24] -rusti-                                             ^~
[12:50:24] -rusti- application terminated with error code 101
[12:50:43] <dbaupp> rusti: match Some(Some(Some(1))) { Some(None) => 0, Some(Some(Some(x))) => x, _ => -1 }
[12:50:44] -rusti- 1
[12:50:55] * dbaupp is rusty at rusti
[12:51:21] <afrey71> Hm.. I have an enum ( struct ( enum, though...
[12:51:26] *** Quits: Larry (larryfox@moz-343B6F0C.nyc.biz.rr.com) (Quit: My MacBook Pro has gone to sleep. ZZZzzzâ€¦)
[12:51:33] <afrey71> dbaupp: thanks for the example.
[12:52:23] <dbaupp> afrey71: still works
[12:53:15] <dbaupp> the definition of a pattern is something like `literal | ident | ident(pattern, pattern, ...) | ident { pattern, pattern, ... }`; i.e. anything that works at the top level of a match statement works nested in another pattern
[12:53:33] <afrey71> I tried something like:   match { VP(ref c) if c.field = Some => ...   but that doesn't work because there's no match operator.
[12:53:36] *** Joins: Larry (larryfox@moz-343B6F0C.nyc.biz.rr.com)
[12:54:47] <dbaupp> Ah, VP(StructName { field: Some(_), _ }) should work for that
[12:55:12] <dbaupp> (possibly VP(ref c @ StructName { ... }) if you want to refer to `c` in the body of the arm)
[12:57:05] <afrey71> dbaupp: Wow, okay, that's plain amazing! Thanks.
[12:58:26] <dbaupp> afrey71: ah, also, for Option, there's the .is_some() method.
[12:58:50] *** Quits: nsf (nsf@moz-EEF3238A.convex.ru) (Quit: WeeChat 0.4.1)
[12:59:05] * dbaupp always forgets the simple solutions
[13:05:04] *** Joins: mihneadb (mihneadb@41E65AA5.B2E373EA.FCAAE698.IP)
[13:05:13] <benh> pattern matching is one of "those functional programming things" that struck me as total magic for the first few languages i saw it in :)
[13:07:00] *** Quits: mihneadb (mihneadb@41E65AA5.B2E373EA.FCAAE698.IP) (Ping timeout)
[13:07:00] <klutzy> I'm trying to create macro which generates both from_str and to_str e.g. some_macro!(A ~ "a", B ~ "b")
[13:07:33] <klutzy> but I don't know what types should be used for A and "b"
[13:08:10] <dbaupp> $A:ident $b:expr
[13:08:12] <dbaupp> ?
[13:08:49] <klutzy> rustc emits: unexpected token: `"b"`
[13:09:01] <klutzy> on from_str
[13:09:07] <dbaupp> code?
[13:10:12] <klutzy> cleaning; wait a minute please :)
[13:10:25] *** Joins: a_m0d (dschoof@moz-670D1285.commercial.cgocable.net)
[13:11:49] <klutzy> dbaupp: http://pastebin.com/fGjPDpqT
[13:12:09] <klutzy> (to_str seems wrong but anyway)
[13:12:13] *** Joins: infynyxx (infynyxx@DB780A29.749BA1D.DCC373F0.IP)
[13:12:35] <dbaupp> klutzy: what happens if you have `$($i:ident ~ $s:expr),+`?
[13:12:43] *** Joins: erickt (Adium@49C4075F.3AC15C18.2321E71E.IP)
[13:12:51] <dbaupp> (i.e. force a seperator between each .. ~ .. pair)
[13:13:53] *** Quits: infynyxx (infynyxx@DB780A29.749BA1D.DCC373F0.IP) (Ping timeout)
[13:13:54] <klutzy> dbaupp: adding +?
[13:13:58] <klutzy> oops
[13:13:59] <klutzy> adding ,?
[13:14:05] *** Joins: dave1629 (dave@moz-17578A1A.hsd1.va.comcast.net)
[13:14:07] <benh> jzelinskie is probably gone now but I finished running make check on that remove-cond branch (after rebuilding llvm and all that because i used a new workdir) and it seems all right :D
[13:15:54] *** Quits: dave1629 (dave@moz-17578A1A.hsd1.va.comcast.net) (Quit: dave1629)
[13:15:54] <dbaupp> klutzy: yeah
[13:16:08] <klutzy> dbaupp: I removed , before + becuase rustc forbids some_macro!(... A ~ "a", B ~ "b",) (comma at last)
[13:17:00] <klutzy> I think having comma is better but removed for now because it doesn't work anyway
[13:18:01] *** Quits: erickt (Adium@49C4075F.3AC15C18.2321E71E.IP) (Quit: Leaving.)
[13:19:06] <dbaupp> rusti: macro_rules! foo ( ($($i:ident ~ $e:expr),*) => { { $(println!("{} {:?}", stringify!($i), $e));* } } ) foo!(a ~ "foo", b ~ "bar")
[13:19:07] -rusti- a "foo"
[13:19:07] -rusti- b "bar"
[13:19:07] -rusti- ()
[13:19:18] <dbaupp> comma seems to work there?
[13:19:33] <klutzy> rusti: macro_rules! foo ( ($($i:ident ~ $e:expr),*) => { { $(println!("{} {:?}", stringify!($i), $e));* } } ) foo!(a ~ "foo", b ~ "bar",)
[13:19:34] -rusti- <anon>:7:137: 7:138 error: Unexpected end of macro invocation
[13:19:34] -rusti- <anon>:7          macro_rules! foo ( ($($i:ident ~ $e:expr),*) => { { $(println!("{} {:?}", stringify!($i), $e));* } } ) foo!(a ~ "foo", b ~ "bar",)
[13:19:34] -rusti-                                                                                                                                                   ^
[13:19:34] -rusti- application terminated with error code 101
[13:19:48] <klutzy> I meant this; it was inconvinent for me :p
[13:20:09] <klutzy> well, I'll add comma after my macro works
[13:20:20] <dbaupp> haha :P
[13:20:54] <dbaupp> (yeah, it's annoying that there isn't a way to allow the trailing comma.)
[13:21:18] *** Quits: brendan (brendaneic@E3D7CBA.E815F8FA.2326E556.IP) (Quit: brendan)
[13:24:30] *** Joins: brendan (brendaneic@E3D7CBA.E815F8FA.2326E556.IP)
[13:27:44] <klutzy> $b:pat does not work with $a => $b, $b:expr does not work with $b => Some($a)
[13:27:52] <klutzy> hmm
[13:29:16] *** Joins: mihneadb (mihneadb@41E65AA5.B2E373EA.FCAAE698.IP)
[13:29:58] <dbaupp> you might have to compile to `$(if $b == s { Some($a) } else)* { None }` and hope LLVM converts it into something fast
[13:30:19] *** Joins: BizarreCake (BizarreCak@moz-361FE9B2.dynamic.barak-online.net)
[13:30:29] *** Joins: maik (maik@moz-FECBC48.dip0.t-ipconnect.de)
[13:31:01] <dbaupp> or `$(if $b == s { Some ($a) })else* else { None }`; don't know which one will work
[13:33:25] *** Quits: jfbk (jfbk@moz-EEA9CFB3.nyc.res.rr.com) (Quit: )
[13:34:22] <klutzy> yes, classical if-else chain seems to work
[13:34:24] <klutzy> thanks! :D
[13:34:55] <klutzy> anyway do you think this is design limitation of macro or bug to be fixed?
[13:35:20] <dbaupp> both
[13:35:51] <dbaupp> it's a limitation of having separate expression and pattern grammars, but I imagine that there would be ways to make it nicer to work with.
[13:36:03] *** Joins: engla (engla@moz-DBD1D96E.cust.bredbandsbolaget.se)
[13:36:03] *** Quits: maik (maik@moz-FECBC48.dip0.t-ipconnect.de) (Ping timeout)
[13:36:28] *** Joins: youknowone (youknowone@A826BD81.8A0DEF81.38747683.IP)
[13:36:28] *** Quits: youknowone (youknowone@A826BD81.8A0DEF81.38747683.IP) (Z:lined (Open Proxy found on your host. Please visit www.blitzed.org/proxy?ip=115.68.131.49 for more information.))
[13:36:31] *** AutomatedTester is now known as AutomatedTester|away
[13:38:54] *** Joins: maik (maik@moz-FECBC48.dip0.t-ipconnect.de)
[13:39:43] <nmatsakis> what is the thing to break on for failures nowadays?
[13:40:39] *** Joins: lmandel (lmandel@13F2CEC5.7672369.D8E68FF6.IP)
[13:40:48] *** Quits: maik (maik@moz-FECBC48.dip0.t-ipconnect.de) (Ping timeout)
[13:40:55] *** Joins: ghrust (ghrust@C8693FCB.6A2AE50.F3114085.IP)
[13:40:55] <ghrust> 01[13rust01] 15bors merged 06auto into 06master: 02http://git.io/nNGACw
[13:40:55] *** Parts: ghrust (ghrust@C8693FCB.6A2AE50.F3114085.IP) ()
[13:41:38] * klutzy is going to open an issue
[13:42:28] <dbaupp> nmatsakis: rust_begin_unwind
[13:43:52] *** Joins: RageOfThou (RageOfThou@3FEF494C.29C984D5.783DEDCA.IP)
[13:44:04] <nmatsakis> dbaupp: thanks
[13:45:20] *** Joins: wakandan (Mibbit@5232D4B6.13322C48.EAD3CEA6.IP)
[13:45:54] *** Joins: ghrust (ghrust@DE823A67.6A2AE50.F3114085.IP)
[13:45:54] <ghrust> 01[13rust01] 15bors pushed 0 new commits to 06auto: 02http://git.io/pTpGcw
[13:45:54] *** Parts: ghrust (ghrust@DE823A67.6A2AE50.F3114085.IP) ()
[13:45:55] *** Joins: ghrust (ghrust@24260B07.6A2AE50.F3114085.IP)
[13:45:55] <ghrust> 01[13rust01] 15bors pushed 2 new commits to 06auto: 02http://git.io/j20ZWA
[13:45:55] <ghrust> 13rust/06auto 141ce657a 15Luqman Aden: librustc: Respect #[link_name] on extern statics. Fixes #9270
[13:45:55] <ghrust> 13rust/06auto 149e636f1 15bors: auto merge of #9272 : luqmana/rust/esln, r=catamorphism...
[13:45:56] *** Parts: ghrust (ghrust@24260B07.6A2AE50.F3114085.IP) ()
[13:46:03] *** Joins: ahal (ahal@FCCEA34F.7672369.D8E68FF6.IP)
[13:46:49] <wakandan> hi 
[13:47:04] <wakandan> I'm looking for the docs for fmt/rt.rs module 
[13:47:21] <wakandan> where can I find it, or can someone share with me what it does?
[13:47:35] <wakandan> I'm trying to remove "either" usage in that module
[13:48:18] <dbaupp> it's the internal implementation of the new formatting macros (e.g. format!, format_args!, error2!)
[13:48:18] *** Quits: RageOfThou (RageOfThou@3FEF494C.29C984D5.783DEDCA.IP) (Connection reset by peer)
[13:48:24] *** Joins: Scriptor (historium@moz-E06F46F0.corp.bitshelter.com)
[13:49:15] <dbaupp> wakandan: the only documentation for it will be the doc comments/normal comments in the file itself
[13:49:30] *** Joins: orshem (orshem@F0A9EA9.588A166C.E3D28531.IP)
[13:50:15] <wakandan> which isn't so much :)
[13:50:32] <wakandan> oh hi dbaupp, we talked yesterday
[13:50:49] <pnkfelix> nmatsakis: also, I think `catch throw` works in GDB
[13:50:59] <wakandan> basically my task is to remove some uses of "either" module in those libraries in libstd
[13:51:02] <nmatsakis> pnkfelix: oh cool
[13:51:10] <pnkfelix> nmatsakis: (as an alternative to breaking on `rust_begin_unwind`
[13:51:32] <wakandan> I need to know what I'm replacing means so that I can give them a good name
[13:51:51] *** Quits: pnkfelix (pnkfelix@87C1F78E.1DE10CA8.D8E68FF6.IP) (Quit: Leaving.)
[13:51:54] <wakandan> I have a struct pub struct PluralArm<'self> {
[13:51:59] <wakandan> does it ring any bell?
[13:52:04] * dbaupp looks
[13:52:41] *** Quits: Thiez (thiez@moz-BF669398.student.utwente.nl) (Ping timeout)
[13:53:29] <dbaupp> That's the `1`, `2`, `many` in `{plural, foo, 1{single}, 2{double}, many{a lot}}`
[13:54:13] <orshem> what does @ sign means inside a match?
[13:54:31] <dbaupp> wakandan: (that syntax is saying "print 'single' if foo is 1, 'double' if 2, 'a lot' if it is a locale-defined many")
[13:54:51] <engla> fyi, for english, the cases are called  `one` and `other`
[13:54:56] *** Quits: brianm (brianm@CE36CB47.15418CA7.5114C2BC.IP) (Quit: Leaving...)
[13:55:06] <engla> I don't know what the remaining cases do by default
[13:55:26] <wakandan> oh !
[13:55:46] <wakandan> I have no clue what it means dbaupp 
[13:56:54] <dbaupp> wakandan: read the internationalization section of the docs in fmt/mod.rs
[13:57:30] <dbaupp> but calling it something like PluralSelector { LiteralNumber(uint), Keyword(PluralKeyword) } is probably fine
[13:58:48] *** Quits: nkoep (nik@moz-C551C6AA.vpn.rwth-aachen.de) (Ping timeout)
[13:59:06] *** Joins: brianm (brianm@CE36CB47.15418CA7.5114C2BC.IP)
[14:00:11] *** AutomatedTester|away is now known as AutomatedTester
[14:00:13] <nmatsakis> orshem: `name @ pat` means "bind name to the thing being matched, and then also match pat against it"
[14:01:31] <wakandan> dbaupp: oh 
[14:01:34] <wakandan> nice 
[14:02:17] *** Joins: dherman (dherman@moz-BDCCF091.hfc.comcastbusiness.net)
[14:02:17] *** ChanServ sets mode: +ao dherman dherman
[14:02:23] <wakandan> dbaupp: and for checking I should run "make check-stage2-std", yes?
[14:02:40] <dbaupp> wakandan: that should work yeah
[14:02:53] <wakandan> cool!
[14:02:54] <dbaupp> you can probably get away with `make check-stage1-std` for now
[14:03:00] <wakandan> this could me my first commit!
[14:03:24] <dbaupp> wakandan: :)
[14:04:20] <wakandan> what's your github dbaupp?
[14:04:44] *** Joins: brianm_ (brianm@CE36CB47.15418CA7.5114C2BC.IP)
[14:04:55] <dbaupp> huonw
[14:05:04] *** Quits: brianm (brianm@CE36CB47.15418CA7.5114C2BC.IP) (Ping timeout)
[14:05:18] *** Joins: Thiez (thiez@moz-BF669398.student.utwente.nl)
[14:05:47] *** Joins: brianm (brianm@CE36CB47.15418CA7.5114C2BC.IP)
[14:05:59] *** Quits: brianm_ (brianm@CE36CB47.15418CA7.5114C2BC.IP) (Connection reset by peer)
[14:06:58] *** Quits: Thiez (thiez@moz-BF669398.student.utwente.nl) (Ping timeout)
[14:07:18] *** Joins: brianm_ (brianm@CE36CB47.15418CA7.5114C2BC.IP)
[14:07:23] *** Quits: brianm (brianm@CE36CB47.15418CA7.5114C2BC.IP) (Connection reset by peer)
[14:07:57] <wakandan> my "make ..." is painfully slow :(
[14:08:39] *** Joins: penguin_dan (dan_johnsi@6902762D.11B071D.FB9A45AF.IP)
[14:08:53] <engla> Yeah rustc isn't as slim (in memory) or as fast as one would like
[14:09:43] *** Quits: penguin_dan (dan_johnsi@6902762D.11B071D.FB9A45AF.IP) (Client exited)
[14:10:37] *** Joins: maik (maik@moz-FECBC48.dip0.t-ipconnect.de)
[14:11:01] *** Joins: MrFahrenheit (RageOfThou@3FEF494C.29C984D5.783DEDCA.IP)
[14:11:24] *** Joins: penguin_dan (dan_johnsi@6902762D.11B071D.FB9A45AF.IP)
[14:12:33] *** Joins: infynyxx (infynyxx@DB780A29.749BA1D.DCC373F0.IP)
[14:12:41] *** Joins: dave1629 (dave@BCF98484.EEDD3B02.DDE5D3F6.IP)
[14:14:05] *** Joins: fyolnish (fyolnish@moz-967716B8.uqwimax.jp)
[14:14:11] *** Joins: RageOfThou (RageOfThou@3FEF494C.29C984D5.783DEDCA.IP)
[14:14:13] *** Quits: infynyxx (infynyxx@DB780A29.749BA1D.DCC373F0.IP) (Ping timeout)
[14:15:24] *** Quits: MrFahrenheit (RageOfThou@3FEF494C.29C984D5.783DEDCA.IP) (Ping timeout)
[14:16:38] *** Joins: Thiez (thiez@moz-BF669398.student.utwente.nl)
[14:17:27] *** Joins: nkoep (nik@moz-1E78C081.pool.mediaways.net)
[14:21:06] <orshem> nmatsakis, i don't understand. how is it different from regular match expressions?
[14:21:47] *** Joins: ksev (DrunkenPan@745B767B.989A61DC.CA5B6332.IP)
[14:22:28] *** Quits: maik (maik@moz-FECBC48.dip0.t-ipconnect.de) (Ping timeout)
[14:23:16] *** flaper87|afk is now known as flaper87
[14:23:44] <dbaupp> rusti: match Some(Some(1)) => { Some(a @ Some(_)) => a, _ => None }
[14:23:44] -rusti- <anon>:7:29: 7:31 error: expected `{` but found `=>`
[14:23:44] -rusti- <anon>:7          match Some(Some(1)) => { Some(a @ Some(_)) => a, _ => None }
[14:23:44] -rusti-                                       ^~
[14:23:44] -rusti- application terminated with error code 101
[14:23:49] <dbaupp> rusti: match Some(Some(1)) { Some(a @ Some(_)) => a, _ => None }
[14:23:50] -rusti- Some(1)
[14:23:57] <dbaupp> rusti: match Some(None) { Some(a @ Some(_)) => a, _ => None }
[14:23:59] -rusti- pastebinned 10 lines of output: http://sprunge.us/ALNe
[14:24:10] <dbaupp> rusti: match Some(None::<int>) { Some(a @ Some(_)) => a, _ => None }
[14:24:11] -rusti- None
[14:25:05] <nmatsakis> orshem: it's not? it's just a kind of pattern
[14:25:57] <nmatsakis> orshem: but it enables things like what dbaupp just demonstrated...
[14:27:32] *** Joins: nsf (nsf@moz-EEF3238A.convex.ru)
[14:29:45] <Amaranth> If I have a function that would normally have a boolean "worked or not" return but i want to make it return a string on error what would be the suggested way to do so?
[14:30:16] <Amaranth> I can't decide if Option with Some/None meaning reversed or Result with a bool in Ok that we don't care about
[14:30:27] <dbaupp> Result<(), ~str> works too
[14:30:43] <Amaranth> Perfect, problem solved then, thanks
[14:30:59] <engla> an Option is ok too. None doesn't have be a failure
[14:31:25] <dbaupp> (if you care about these things, Result<(), ~str> actually gets represented as a single nullable pointer.)
[14:31:45] <orshem> rusti: match Some(None::<int>) { Some(a @ Some(_)) => "None1", _ => "None2" }
[14:31:46] -rusti- <anon>:7:40: 7:51 warning: unused variable: `a` [-W unused-variable (default)]
[14:31:46] -rusti- <anon>:7          match Some(None::<int>) { Some(a @ Some(_)) => "None1", _ => "None2" }
[14:31:46] -rusti-                                                  ^~~~~~~~~~~
[14:31:46] -rusti- "None2"
[14:32:28] <orshem> rusti: match Some(5) { Some(a @ Some(_)) => a, _ => None }
[14:32:30] -rusti- pastebinned 8 lines of output: http://sprunge.us/PNXi
[14:32:37] <Amaranth> Uh oh, I think the rust update I did yesterday broke rust-sdl2
[14:32:40] * Amaranth investigates
[14:37:07] *** Joins: quksw (quksw@moz-AD8A99C0.red.bezeqint.net)
[14:37:16] <quksw> hey ppl
[14:37:22] <benh> hi
[14:37:27] <quksw> wazup?!
[14:37:34] <orshem> nmatsakis, dbaupp: i understand now. thanks!
[14:38:06] *** Joins: cubic (cubic@moz-FE5AD6C7.mc.videotron.ca)
[14:38:23] *** Joins: infynyxx (infynyxx@DB780A29.749BA1D.DCC373F0.IP)
[14:38:25] <quksw> i am trying to understand std::Str... I read http://static.rust-lang.org/doc/0.7/std/str.html and didn't get the idea
[14:39:05] <quksw> i mean -- there are many iterators but so less functions like substr, regex and etc
[14:39:29] *** jorendorff_away is now known as jorendorff
[14:40:15] <engla> there is no regex support, and if there was, it would not be inside std::str
[14:40:31] <benh> use .slice(...) for substrings
[14:40:32] <engla> quksw: .slice() or .slice_chars is the way to create a substring
[14:40:43] <engla> or using .split_iter() or other means
[14:41:04] <quksw> engla: hoooooo splice... okay i will take a look at that
[14:41:49] <engla> quksw: also, are you using Rust 0.7 or the lastest master?
[14:42:06] <quksw> i clone the rustc from github
[14:42:17] <quksw> so i guess is the latests master.
[14:42:37] <engla> ok that sounds like you should use the master docs then, look under Trunk on the left side http://www.rust-lang.org/
[14:42:38] <quksw> does it make any different? (cuz i read the 0.7 manual)
[14:42:45] <quksw> 10x
[14:42:48] <engla> yeah, there are constant changes to Rust
[14:42:58] <quksw> engla: thanks for noticing. :)
[14:43:13] *** Quits: brianm_ (brianm@CE36CB47.15418CA7.5114C2BC.IP) (Quit: Linkinus - http://linkinus.com)
[14:45:07] *** Quits: orshem (orshem@F0A9EA9.588A166C.E3D28531.IP) (Ping timeout)
[14:45:08] <quksw> engla: one more question, is Traits another word to interface?
[14:45:37] <benh> interface isn't a thing in the language, but you can kinda look at it like that
[14:46:26] <benh> All the traits in the str module basically serve to tack methods onto the ~str and &str etc types
[14:46:42] <quksw> benh: i see...
[14:47:11] <quksw> benh: what is the differences between ~str and &str (i am C programmer, knows little about C++)
[14:47:38] <benh> A ~str variable "owns" a string, and if it goes out of scope, it will free() the string contents
[14:47:50] *** Quits: Kruppe (user@moz-E150F49F.cpe.net.cable.rogers.com) (Client exited)
[14:48:03] <benh> a &str is like an interior pointer ino a string, together with a length
[14:48:28] <benh> rust tracks that the &str won't outlive the ~str (or whatever) it points into
[14:48:59] <quksw> benh: complicated but i understand...
[14:49:32] <benh> you can copy &str to have multiple references to or into a single string; if you .clone() a ~str it will copy the contents into a newly allocated bit of memory 
[14:49:33] <quksw> benh: 10x
[14:49:53] <ChrisMorgan> Or &'static str, a &str with the static lifetime: a string literal.
[14:50:18] <quksw> ChrisMorgan: then what is the scope of &str?
[14:50:31] <quksw> I thought it was static
[14:50:53] <ChrisMorgan> For &'static str it is, but for the reference-to-part-of-a-~str that benh is talking about, it's not.
[14:51:11] <ChrisMorgan> There, it would be that of the ~str.
[14:51:17] *** Joins: quksw_ (quksw@moz-AD8A99C0.red.bezeqint.net)
[14:51:42] <kimundi> quksw: One important thing to know is that 'str' is not currently an valid type on its own. In the future it will be an unsized type, but you'll still be only able to refer to it as ~str or &str (ot @str, but that's deprecated)
[14:52:05] <quksw_> uh huh
[14:52:14] *** Quits: quksw (quksw@moz-AD8A99C0.red.bezeqint.net) (Ping timeout)
[14:52:55] *** Quits: dave1629 (dave@BCF98484.EEDD3B02.DDE5D3F6.IP) (Quit: dave1629)
[14:53:08] <kimundi> The reason for that a bare 'str' in in principle an bare '[u8]', which would also be unsized. Unsized because the compiler doesn't know at compile time how many bytes the type is going to need
[14:53:41] *** Joins: hjr3 (hradtke@1A0AE795.28A5F6C3.A2D40ED2.IP)
[14:54:09] <kimundi> A ~[T] and &[T] are special types that consist of a pointer to the data, and an length field
[14:54:13] <quksw_> i thought you implement str as a pointer, then its size is regardless and you allocate memory on the heap in case you want to expand it
[14:54:21] <ChrisMorgan> (str is not *equivalent* to [u8], however; it supports Unicode and is presentlyâ€”not sure whether or not it's *defined* as suchâ€”UTF-8 encoded.)
[14:54:31] <Amaranth> extern mod gl; use gl::types::*; triggers error: unresolved import. maybe a missing `extern mod gl`?
[14:54:38] <Amaranth> I don't even
[14:54:48] <kimundi> quksw_: If we make str use a pointer, then we'd have to eat double indirection in most cases
[14:55:06] <ChrisMorgan> Amaranth: is the `extern mod gl;` in the root file that rustc is compiling?
[14:55:08] <kimundi> Amaranth: In a submodule?
[14:55:11] <quksw_> hmmm i see
[14:55:21] <quksw_> 10x guys
[14:55:23] <kimundi> quksw_: So we instead make the pointer obvious
[14:55:36] <Amaranth> Ah, no, for some reason this has demo.rc pulling in video.rs which is where those are
[14:55:55] *** Joins: Skif (emschwar@moz-CA025D57.ip.mcleodusa.net)
[14:55:57] *** Joins: ghrust (ghrust@9C8B94D4.6A2AE50.F3114085.IP)
[14:55:57] <ghrust> 01[13rust01] 15bors merged 06auto into 06master: 02http://git.io/j20ZWA
[14:55:57] *** Parts: ghrust (ghrust@9C8B94D4.6A2AE50.F3114085.IP) ()
[14:56:08] <kimundi> a &[T] is basically a struct of raw pointer to data and size: { *T, uint }
[14:56:14] *** Joins: brianm (brianm@CE36CB47.15418CA7.5114C2BC.IP)
[14:56:16] <ChrisMorgan> The `extern mod gl;` does need to be in the root module in your case. Any `use` statements are relative to the root module.
[14:57:23] <kimundi> a ~[T] is *{size, capacity, T, T, ...} but that's just an implementation deifference
[14:58:24] <quksw_> ok
[14:58:34] <kimundi> you can always make a &[T] that points into any subset of elements of an ~[T], [T, ..N], @[T] or other &[T]
[14:58:51] <engla> you should regard ~[T] and &[T] as two different types, As if their names were Vector<T> and VecSlice<T>
[14:59:19] <quksw_> alright
[14:59:41] <quksw_> btw - why you use "pub" when declaring/defining a function?
[14:59:59] <engla> pub is for public
[15:00:09] <quksw_> yeah - but it's just a function
[15:00:19] <quksw_> it's not a method of a class
[15:00:38] <engla> in rust fashion the common keywords are short. Well a function can be public as well, if it should visible outside the module
[15:00:50] <quksw_> haaaaaa
[15:01:01] *** Joins: ghrust (ghrust@9C8B94D4.6A2AE50.F3114085.IP)
[15:01:01] <ghrust> 01[13rust01] 15bors pushed 0 new commits to 06auto: 02http://git.io/G2bz6Q
[15:01:01] *** Parts: ghrust (ghrust@9C8B94D4.6A2AE50.F3114085.IP) ()
[15:01:01] <quksw_> got it...
[15:01:03] *** Joins: ghrust (ghrust@24260B07.6A2AE50.F3114085.IP)
[15:01:03] <ghrust> 01[13rust01] 15bors pushed 2 new commits to 06auto: 02http://git.io/aA4dVA
[15:01:03] <ghrust> 13rust/06auto 14b5d560a 15blake2-ppc: std: Remove {float,f64,f32}::from_str in favor of from_str...
[15:01:03] <ghrust> 13rust/06auto 14e02313a 15bors: auto merge of #9275 : blake2-ppc/rust/float-from-str, r=thestinger...
[15:01:03] *** Parts: ghrust (ghrust@24260B07.6A2AE50.F3114085.IP) ()
[15:01:09] <engla> Now the visibility/privacy system isn't free of bugs yet
[15:01:29] <jorendorff> how do you convert a char to a u8?
[15:01:32] <quksw_> you have examples that i can see
[15:01:37] <kimundi> quksw_: Our visibility works per-module not per trait/struct or so
[15:01:39] *** Joins: jeaye (Jeaye@moz-34FEF2BB.hsd1.ca.comcast.net)
[15:01:45] <jorendorff> rusti: 'A' as u8
[15:01:46] -rusti- 65u8
[15:02:00] <benh> rusti: 'ÃŸ' as u8
[15:02:01] <kimundi> jorendorff: Hm, that conversion is not allways possible
[15:02:01] -rusti- 223u8
[15:02:09] <engla> quksw_: did you see this? http://static.rust-lang.org/doc/master/tutorial.html#crates-and-the-module-system
[15:02:18] <benh> rusti: 'â—' as u8
[15:02:19] -rusti- 207u8
[15:02:24] <benh> ymmv
[15:02:29] <jorendorff> rusti: match 65u8 {'A' as u8: 1, _: 0}
[15:02:29] -rusti- <anon>:7:25: 7:27 error: expected `=>` but found `as`
[15:02:29] -rusti- <anon>:7          match 65u8 {'A' as u8: 1, _: 0}
[15:02:29] -rusti-                                   ^~
[15:02:30] -rusti- application terminated with error code 101
[15:02:37] <jorendorff> rusti: match 65u8 {'A' as u8 => 1, _ => 0}
[15:02:37] -rusti- <anon>:7:25: 7:27 error: expected `=>` but found `as`
[15:02:37] -rusti- <anon>:7          match 65u8 {'A' as u8 => 1, _ => 0}
[15:02:38] -rusti-                                   ^~
[15:02:38] -rusti- application terminated with error code 101
[15:02:42] <engla> jorendorff: char represents a unicode codepoint. You can cast to u8, but it will wrap if the value doesn't fit.. just like casting from uint to u8
[15:02:43] <kimundi> jorendorff: If you want to be sure that only the ascii subset that fits into an byte survives the conversion:
[15:02:52] <quksw_> engla: nope... i will start read that. 10x
[15:02:55] <kimundi> rusti: 'a'.to_ascii().to_byte()
[15:02:56] -rusti- 97u8
[15:03:02] <kimundi> rusti: 'Ã¤'.to_ascii().to_byte()
[15:03:03] -rusti- task <unnamed> failed at 'assertion failed: self.is_ascii()', /build/rust-git/src/rust/src/libstd/str/ascii.rs:140
[15:03:04] -rusti- application terminated with error code 101
[15:03:05] <jorendorff> yeah, i can convert the u8 instead
[15:03:47] <quksw_> engla: is there an interpreter to rust?
[15:03:52] *** Joins: zeuxcg (zeuxcg@moz-80D1F912.hsd1.ca.comcast.net)
[15:03:55] <quksw_> engla: like in Python?
[15:04:00] <kimundi> quksw_: you can pm rusti in this channel
[15:04:17] <engla> quksw_: there is an executable called rusti but it doesn't work :(
[15:04:17] <jorendorff> it would be great to have this rusti technology at home
[15:04:24] <quksw_> kimundi: yeah, i noticed but sometimes i won't be online :)
[15:04:26] <kimundi> quksw_: we also have an actualy interpreter called rusti distributed with rust, but that is always broken currently
[15:04:49] <kimundi> quksw_: It'S easier to just make an .rs file and use 'rust run foo.rs' on it
[15:04:50] <quksw_> hmmm...looks like a job for me...
[15:05:02] <quksw_> uh huh
[15:05:07] <quksw_> 10x guys!
[15:05:17] <quksw_> for everything... you are awesome
[15:05:26] <benh> I think someone is working on making rusti not always crash and has posted on the mailing list about it, but I don't know how far they got
[15:05:30] <jorendorff> how do i allocate a big ~[u8] vector?
[15:06:13] <quksw_> benh: interesting where can i find that?
[15:06:31] <jorendorff> rusti: let len = 1024; let v : ~[u8] = ~[0, ..len];
[15:06:31] -rusti- <anon>:7:48: 7:51 error: expected constant integer for repeat count but found variable
[15:06:32] -rusti- <anon>:7          let len = 1024; let v : ~[u8] = ~[0, ..len];
[15:06:32] -rusti-                                                          ^~~
[15:06:32] -rusti- error: aborting due to previous error
[15:06:32] -rusti- application terminated with error code 101
[15:06:52] <benh> https://mail.mozilla.org/listinfo/rust-dev is the list, https://mail.mozilla.org/pipermail/rust-dev/2013-September/005542.html is one of the mails in that thread
[15:07:23] <benh> That's all I know, sorry :)
[15:07:32] * jorendorff sees std::vec::build, but surely there is something less complex
[15:07:40] *** Joins: stomper (Mibbit@moz-3B7CB198.guest.johnshopkins.net)
[15:07:44] *** Joins: maik (maik@moz-FECBC48.dip0.t-ipconnect.de)
[15:08:16] *** Joins: nik_ (nik@moz-E8F81FBC.pool.mediaways.net)
[15:08:17] <jorendorff> maybe i don't need to preallocate
[15:08:17] <jesseray> let v : ~[u8, ..1024];
[15:08:19] <engla> jorendorff: there is std::vec::with_capacity to allocate the vec
[15:08:24] <stomper> is eholk's paper on GPU programming the most recent paper on rust?
[15:08:30] *** Quits: nkoep (nik@moz-1E78C081.pool.mediaways.net) (Ping timeout)
[15:08:31] <jesseray> I think that will work, not sure.
[15:08:56] *** Quits: sebcrozet (sebcrozet@moz-3CE49532.lrde.epita.fr) (Ping timeout)
[15:09:46] <jorendorff> jesseray: it works but i wanted to give that constant number a name, since I also use it elsewhere
[15:09:53] *** Quits: sk (sk@BC280AA6.273A3D3C.78DD174B.IP) (Quit: Leaving)
[15:10:31] *** Joins: sebcrozet (sebcrozet@moz-3CE49532.lrde.epita.fr)
[15:10:46] *** Joins: Jesin (Jessin_@moz-CE9E5E72.cc.lehigh.edu)
[15:11:03] <ChrisMorgan> What seems to me to be the prevailing style for type ascription is *not* to use a space before, e.g. `let v: ~[u8, ..1024];` rather than `let v : ~[u8, ..1024]`.
[15:12:03] *** flaper87 is now known as flaper87|afk
[15:12:12] <jorendorff> engla: I'm using it with stdin().read(vec, len) and I'm getting the assertion that vec is not long enough; that is, capacity isn't enough, I need it actually to be populated with zeros
[15:12:18] <ChrisMorgan> jorendorff: incidentally, your "let v: ~[u8, ..1024] = ~[0, ..1024]" can have the type inferred by writing it "let v = ~[0u8, ..1024]".
[15:12:39] <engla> jorendorff: right
[15:13:18] <engla> there are functions like this
[15:13:23] *** Joins: bheylin_ (brianheyli@C709828D.E7BADBF1.B0C2132F.IP)
[15:13:24] <engla> rusti: std::vec::from_elem(12, 0u8)
[15:13:26] -rusti- ~[0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8]
[15:13:32] * jorendorff sees grow
[15:13:35] <engla> I don't remember which way is the most efficient
[15:13:46] <jorendorff> from_elem, thank you!
[15:14:06] <engla> rusti: std::vec::from_fn(12, |i| i as u8)
[15:14:07] -rusti- ~[0u8, 1u8, 2u8, 3u8, 4u8, 5u8, 6u8, 7u8, 8u8, 9u8, 10u8, 11u8]
[15:14:22] *** Quits: infynyxx (infynyxx@DB780A29.749BA1D.DCC373F0.IP) (Client exited)
[15:14:35] *** Quits: maik (maik@moz-FECBC48.dip0.t-ipconnect.de) (Ping timeout)
[15:14:47] *** Quits: ChrisMorgan (chris@moz-6AC741CA.static.tpgi.com.au) (Ping timeout)
[15:15:14] *** Quits: stomper (Mibbit@moz-3B7CB198.guest.johnshopkins.net) (Quit: http://www.mibbit.com ajax IRC Client)
[15:15:29] <Amaranth> It still feels odd having a vector type that doesn't automatically grow as needed
[15:16:33] *** Joins: infynyxx (infynyxx@DB780A29.749BA1D.DCC373F0.IP)
[15:16:36] <engla> it would grow if you assign to the index one past the end?
[15:16:40] <bstrie> Amaranth: which type is that?
[15:16:55] <bstrie> unique vecs should totally grow with .append() or whatever...
[15:17:12] <bstrie> and fixed-size vecs are... fixed-size
[15:17:13] <Amaranth> Oh, append makes them grow? That makes sense I guess
[15:17:25] <engla> .push() is the method to use
[15:17:35] <engla> rusti: let mut v = ~[1,2,3]; v.push(7); v
[15:17:36] -rusti- ~[1, 2, 3, 7]
[15:17:55] <bstrie> yep
[15:17:58] <engla> rusti: let mut v = ~[1,2,3]; v.extend(&mut range(20,30)); v
[15:17:59] -rusti- ~[1, 2, 3, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29]
[15:18:01] *** Quits: bheylin_ (brianheyli@C709828D.E7BADBF1.B0C2132F.IP) (Ping timeout)
[15:18:07] <bstrie> woah
[15:18:10] <bstrie> extend
[15:18:20] <bstrie> just takes an iterator?
[15:18:26] <engla> it takes a &mut iterator
[15:18:40] <Amaranth> I don't know why vec confuses me so much actually
[15:19:05] <Amaranth> I thought I had my finger on it but no because std::vector and ArrayList work like that too
[15:19:45] <engla> having to handle both &[T] and ~[T] is a bit confusing at first I guess
[15:19:54] *** Quits: aeqwa (aeqwa@moz-A1C312ED.dsl.tropolys.de) (Quit: Lost terminal)
[15:20:20] *** Quits: zeuxcg (zeuxcg@moz-80D1F912.hsd1.ca.comcast.net) (Ping timeout)
[15:20:22] <bstrie> rusti: let mut v = ~[1,2,3]; v.extend(&mut v.iter()); v
[15:20:24] -rusti- pastebinned 14 lines of output: http://sprunge.us/QdXX
[15:20:28] <engla> most methods work on &[T] because any vector can be converted to &[T]  (a read only "view" of a part of a vector)
[15:20:31] <bstrie> engla: can you explain why ^ doesn't work?
[15:21:02] <engla> bstrie: well the v.iter() will "lock" `v` from mutation foremost
[15:21:15] <engla> and then the element type of the iterator for ~[int] is Iterator<&int>
[15:21:16] *** Joins: aeqwa (aeqwa@moz-A1C312ED.dsl.tropolys.de)
[15:21:16] <bstrie> that's what I expected, but the error message doesn't indicate that
[15:21:45] <bstrie> how would I fix that line so that the correct error message appears
[15:21:58] <engla> rusti: let mut v = ~[1,2,3]; v.extend(&mut v.iter().map(|&x| x));   // can't both iterate and mutate at the same time
[15:22:01] -rusti- pastebinned 8 lines of output: http://sprunge.us/ASIX
[15:22:15] <engla> error: cannot borrow `(*v)[]` as immutable because it is also borrowed as mutable
[15:22:24] <engla> if you consider this more correct ^^
[15:23:09] <engla> The vector iterator has elements of type &int for a vector of type ~[int]
[15:23:33] *** Quits: myname (myname@F6BC1CBC.2C5F047.A0197E77.IP) (Ping timeout)
[15:23:47] <jorendorff> is fmt! documented anywhere? is there a way to fmt a u64 that doesn't include the "u64" suffix?
[15:24:04] *** Joins: josh (josh@moz-348C4790.hsd1.mn.comcast.net)
[15:24:34] *** Quits: mihneadb (mihneadb@41E65AA5.B2E373EA.FCAAE698.IP) (Input/output error)
[15:26:53] *** Joins: pnkfelix (pnkfelix@moz-43495417.fbx.proxad.net)
[15:26:53] *** ChanServ sets mode: +o pnkfelix
[15:27:44] *** Quits: nano (nano@moz-74CAD1CA.superkabel.de) (Connection reset by peer)
[15:28:07] <engla> jorendorff: I think it's best to use format!() instead, it is replacing fmt!
[15:28:17] <engla> rusti: format!("{}", 27u64)
[15:28:18] -rusti- ~"27"
[15:28:24] <engla> rusti: println!("{}", 27u64)
[15:28:25] -rusti- 27
[15:28:25] -rusti- ()
[15:28:25] <jorendorff> !
[15:31:11] <engla> fmt! never grew to support formats for u64, so your question is onto something
[15:31:13] <engla> format! does
[15:32:49] *** Joins: myname (myname@F6BC1CBC.2C5F047.A0197E77.IP)
[15:33:56] *** Quits: nik_ (nik@moz-E8F81FBC.pool.mediaways.net) (Ping timeout)
[15:34:38] *** Quits: mib_a90qrk (Mibbit@moz-5256162B.hsd1.ca.comcast.net) (Quit: http://www.mibbit.com ajax IRC Client)
[15:38:26] <sebcrozet> Hi,
[15:38:34] <sebcrozet> what am I doing wrong here:
[15:38:37] <sebcrozet> https://gist.github.com/sebcrozet/6611047 ?
[15:39:25] <bstrie> sebcrozet: I'd guess that it's because that method is taking `self` by-value
[15:40:31] <bstrie> hm, maybe not
[15:40:34] <sebcrozet> bstrie: yes, but I dont understand why I cannot move `self.b` once `self.a` is moved.
[15:41:18] <kimundi> sebcrozet: The first move of an field invalidates the whole struct
[15:41:18] <sebcrozet> bstrie: Once I move `self.b`, I should not be able to use `self` itself, but using `self.a` should be ok.
[15:41:40] <bstrie> kimundi: is there a good reason for that?
[15:41:44] <kimundi> sebcrozet: only way to move out all is to destructure self at once
[15:41:56] <klutzy> (a, b) = (self.a, self.b)?
[15:41:58] <sebcrozet> kimundi: ah, how can I do that?
[15:41:58] <kimundi> bstrie: No one implemented smart partial moves yet?
[15:42:00] <klutzy> (only guess :p)
[15:42:19] <kimundi> klutzy: I think that would still count as two seperate moves :P
[15:42:26] <klutzy> partial move is always source of confusion for me
[15:42:44] <kimundi> In the case of sebcrozet ' gist:
[15:42:50] <klutzy> so I'm also waiting for explanation here :)
[15:42:54] <kimundi> let TupleAsStruct{ a, b } = self;
[15:43:00] <kimundi> or
[15:43:09] <kimundi> let TupleAsStruct{ a: x, b: y } = self; 
[15:43:19] <klutzy> uh.. tuple and struct work differently?
[15:43:24] <klutzy> it seems strange
[15:43:37] <kimundi> first one is a shortform that uses the field names as binding names, the second one lets you pick custom names
[15:43:41] <sebcrozet> kimundi: ah, yes it works.
[15:43:49] <kimundi> klutzy: It works just like tuples
[15:43:50] <bstrie> +1 karma for kimundi
[15:43:56] <kimundi> let (a, b) = self
[15:44:02] <bstrie> I always forget that you can destructure-assign structs like that
[15:44:04] <kimundi> if self is a 2 tuple
[15:44:20] <kimundi> bstrie: Well I never used it myself :P
[15:44:52] <sebcrozet> kimundi: so, this non-smart partial move is really just a limitation of the current compiler?
[15:45:07] <kimundi> sebcrozet: In a way, yeah
[15:45:28] <kimundi> sebcrozet: Probably won't get implemented directly though
[15:45:52] <kimundi> sebcrozet: If I overheard the recent ideas correctly, we're more likely to get an generalized swap operation
[15:46:14] <sebcrozet> kimundi: generalized swap?
[15:46:32] <kimundi> sebcrozet: Where you can temporary move out of multibe thibngs at once and put them back in arbitary combination
[15:46:42] *** Joins: anshin (anshin@CD85F10D.F21429E2.354459FA.IP)
[15:46:44] *** Joins: wilmoore (wilmoore@moz-7EE4D9D6.mystrotv.com)
[15:46:49] <kimundi> things*
[15:47:42] <sebcrozet> kimundi: I see. That would be useful.
[15:48:17] *** Joins: nik_ (nik@moz-CDF71706.vpn.rwth-aachen.de)
[15:48:37] *** Joins: feduser (feduser@534495C6.A5F317B6.799BF54A.IP)
[15:48:52] <sebcrozet> kimundi: I guess your solution is sufficient in my case anyway.
[15:48:54] <sebcrozet> kimundi: thanks
[15:49:03] *** Quits: brendan (brendaneic@E3D7CBA.E815F8FA.2326E556.IP) (Quit: brendan)
[15:51:16] *** Joins: quk_sw_ (quksw@moz-AD8A99C0.red.bezeqint.net)
[15:52:12] *** Quits: quksw_ (quksw@moz-AD8A99C0.red.bezeqint.net) (Ping timeout)
[15:52:33] *** Joins: maik (maik@moz-FECBC48.dip0.t-ipconnect.de)
[15:53:13] *** Quits: brianm (brianm@CE36CB47.15418CA7.5114C2BC.IP) (Quit: Linkinus - http://linkinus.com)
[15:53:18] *** Quits: busylizzy (lisa@85228838.12D0DC84.211374C4.IP) (Ping timeout)
[15:53:30] *** Quits: sebcrozet (sebcrozet@moz-3CE49532.lrde.epita.fr) (Quit: Konversation terminated!)
[15:53:34] *** Joins: busylizzy (lisa@85228838.12D0DC84.211374C4.IP)
[15:54:10] *** Quits: wakandan (Mibbit@5232D4B6.13322C48.EAD3CEA6.IP) (Quit: http://www.mibbit.com ajax IRC Client)
[15:54:37] *** Joins: tiffany (kawaii@moz-EB8B0C08.dhcp.embarqhsd.net)
[15:54:41] *** Joins: quksw_ (quksw@moz-CD41E5C8.red.bezeqint.net)
[15:55:11] *** Quits: quk_sw_ (quksw@moz-AD8A99C0.red.bezeqint.net) (Ping timeout)
[15:56:58] <luisbg> morning :)
[15:57:11] <Yoric> 'evening
[15:57:13] <klutzy> here's am 00:57 :p
[15:57:57] <kimundi> 17::57 here, but my clock shows 19::57 :P
[15:59:44] *** Joins: carllerche (carllerche@6B070D22.7E6A0813.1428D117.IP)
[16:00:10] *** Quits: eagen (eagen@8737942B.7A99C13A.B7961A98.IP) (Ping timeout)
[16:00:48] *** Joins: hoverbear (andrew@moz-87982B6F.wireless.uvic.ca)
[16:00:59] *** Quits: maik (maik@moz-FECBC48.dip0.t-ipconnect.de) (Ping timeout)
[16:01:25] <bstrie> hoverbear: for some reason your username conjures a terrifying mental image
[16:01:53] <hoverbear> bstrie: http://1.bp.blogspot.com/_f98opUNuVXc/Sx4jxHtoZRI/AAAAAAAAL4w/ftp-wDJ7zdc/s400/Hover+bear.jpg
[16:01:57] <hoverbear> =D
[16:04:54] *** Joins: sigma (sigma@moz-F95C5D1F.range31-54.btcentralplus.com)
[16:05:37] *** AutomatedTester is now known as AutomatedTester|away
[16:07:10] *** Joins: dave1629 (dave@733C2E5A.B8CF995A.DDE5D3F6.IP)
[16:07:26] *** Quits: dave1629 (dave@733C2E5A.B8CF995A.DDE5D3F6.IP) (Quit: dave1629)
[16:09:09] *** Joins: jdsanders (Adium@moz-F45527D6.hlrn.qwest.net)
[16:10:16] <jdsanders> I'm not having any luck with the steps in the rustpkg tutorial - when I "rustpkg install github.com/steveklabnik/hello", I get "supplied path for package dir does not exist, and couldn't interpret it as a URL fragment"
[16:10:18] <jdsanders> any thoughts?
[16:10:39] <jdsanders> steveklabnik: ping?
[16:10:45] <cmr> jdsanders: I think that was a bug in rustpkg, how old is your build?
[16:10:57] *** Joins: ghrust (ghrust@C8693FCB.6A2AE50.F3114085.IP)
[16:10:57] <ghrust> 01[13rust01] 15bors merged 06auto into 06master: 02http://git.io/aA4dVA
[16:10:57] *** Parts: ghrust (ghrust@C8693FCB.6A2AE50.F3114085.IP) ()
[16:11:04] <jdsanders> gotcha, about a week, I started rebuilding but thought I'd multi-task
[16:11:08] <jdsanders> I'll just be patient
[16:11:15] <jdsanders> thanks
[16:11:38] *** Joins: ozten (ozten@19BD73A1.5D8BCA3A.A0C1B52F.IP)
[16:12:23] <kimundi> rusti: '\0'
[16:12:23] -rusti- <anon>:6:12: 6:13 error: unknown character escape: 48
[16:12:24] -rusti- <anon>:6     let r = {
[16:12:24] -rusti-                      ^
[16:12:24] -rusti- application terminated with error code 101
[16:14:01] *** Joins: zeuxcg (zeuxcg@moz-77D36DA2.mycingular.net)
[16:15:57] *** Joins: ghrust (ghrust@1E8607E8.6A2AE50.F3114085.IP)
[16:15:57] <ghrust> 01[13rust01] 15bors pushed 0 new commits to 06auto: 02http://git.io/RqfzVw
[16:15:57] *** Parts: ghrust (ghrust@1E8607E8.6A2AE50.F3114085.IP) ()
[16:15:59] *** Joins: ghrust (ghrust@2EE61FCC.6A2AE50.F3114085.IP)
[16:15:59] <ghrust> 01[13rust01] 15bors pushed 2 new commits to 06auto: 02http://git.io/eaPgTQ
[16:15:59] <ghrust> 13rust/06auto 14d11f746 15Jyun-Yan You: fix compilation errors of mips target
[16:15:59] <ghrust> 13rust/06auto 14b43ee6c 15bors: auto merge of #9277 : crabtw/rust/mips, r=brson...
[16:15:59] *** Parts: ghrust (ghrust@2EE61FCC.6A2AE50.F3114085.IP) ()
[16:16:27] *** Joins: maik (maik@moz-53663244.dip0.t-ipconnect.de)
[16:18:04] *** Joins: bent|away (chatzilla@moz-BE33DA21.fw1.sfo1.mozilla.net)
[16:18:13] *** bent|away is now known as bent
[16:19:45] *** Joins: vodik (simon@moz-CBE4BB13.cable.teksavvy.com)
[16:20:32] *** Quits: infynyxx (infynyxx@DB780A29.749BA1D.DCC373F0.IP) (Client exited)
[16:22:07] *** Joins: infynyxx (infynyxx@DB780A29.749BA1D.DCC373F0.IP)
[16:24:55] *** Joins: Kruppe (user@moz-BE643E6F.net.uwaterloo.ca)
[16:25:21] *** Joins: brendan (brendaneic@moz-BDCCF091.hfc.comcastbusiness.net)
[16:25:41] *** Quits: robertknight (robertknig@moz-54528EE0.wby.mendeley.com) (Ping timeout)
[16:28:39] *** Joins: brson (brson@moz-BBE3ABD.mv.mozilla.com)
[16:28:39] *** ChanServ sets mode: +ao brson brson
[16:29:14] *** Quits: zeuxcg (zeuxcg@moz-77D36DA2.mycingular.net) (Ping timeout)
[16:30:18] *** Quits: fabiand (fabiand@moz-34EAF1E0.adsl.alicedsl.de) (Quit: Verlassend)
[16:30:50] *** Joins: zeuxcg (zeuxcg@moz-77D36DA2.mycingular.net)
[16:31:34] *** Quits: Kruppe (user@moz-BE643E6F.net.uwaterloo.ca) (Ping timeout)
[16:32:40] *** Joins: infynyxx_ (infynyxx@DB780A29.749BA1D.DCC373F0.IP)
[16:32:44] *** Quits: zeuxcg (zeuxcg@moz-77D36DA2.mycingular.net) (Ping timeout)
[16:32:56] *** Joins: zeuxcg (zeuxcg@moz-77D36DA2.mycingular.net)
[16:32:58] *** Quits: infynyxx (infynyxx@DB780A29.749BA1D.DCC373F0.IP) (Ping timeout)
[16:33:17] *** Quits: Ralith (ralith@moz-A7071297.customer.broadstripe.net) (Ping timeout)
[16:34:02] *** Quits: hoverbear (andrew@moz-87982B6F.wireless.uvic.ca) (Quit: hoverbear)
[16:34:45] *** Quits: zeuxcg (zeuxcg@moz-77D36DA2.mycingular.net) (Ping timeout)
[16:34:46] *** Joins: hoverbear (andrew@moz-87982B6F.wireless.uvic.ca)
[16:35:11] *** Quits: Larry (larryfox@moz-343B6F0C.nyc.biz.rr.com) (Quit: My MacBook Pro has gone to sleep. ZZZzzzâ€¦)
[16:35:56] *** Quits: hoverbear (andrew@moz-87982B6F.wireless.uvic.ca) (Quit: hoverbear)
[16:36:19] *** Joins: dave1629 (dave@3E11D95A.C422786F.DDE5D3F6.IP)
[16:38:34] <cmr> Who knows about the crate_map?
[16:39:04] <acrichto> I know of it
[16:39:04] *** Joins: FrozenCow (FrozenCow@moz-B2DF4929.chello.nl)
[16:39:17] <cmr> Do you know where the structure of whatever is in it is defined?
[16:39:19] *** Joins: Ferio (Mibbit@moz-23CDE542.fullrate.dk)
[16:39:33] <acrichto> it's generatd by the compiler
[16:39:42] <acrichto> so there's no rust-like construction anywhere
[16:39:55] *** Quits: infynyxx_ (infynyxx@DB780A29.749BA1D.DCC373F0.IP) (Client exited)
[16:40:05] <cmr> Is it *used* by any rust code? iirc it has to do with logging
[16:40:11] <pnkfelix> so I'm skimming the source to std::fmt to try to learn what patterns are useful when implementing one of the fmt traits.  I notice that it uses rt::io, and that the writer attached to the &mut Formatter seems to only take byte[]'s, not strings, so std::fmt calls .as_bytes on strings a ton.  Is this, um, the expected way to use the rt::io library?  Why isn't there a convenient way to write strings?
[16:40:31] <brson> cmr: it's in rt::logging
[16:40:32] <acrichto> cmr: yeah it has all the pointers to the log levels for each module, and logging.rs uses it to crawl and update logging levels
[16:40:34] <brson> probably
[16:40:49] <pnkfelix> (will rt::io get methods for writing strings when it eventually/presumably merges into std::io ?)
[16:41:01] <cmr> pnkfelix: aiui it's blocked on encoding/decoding stuff
[16:41:04] <acrichto> pnkfelix: I believe that the string writing sections of rt::io have yet to come into existence
[16:41:42] <acrichto> brson: the snapshot succeeded, but it's missing libmorestack.a :( :( :(, investigating now
[16:41:47] <pnkfelix> cmr: do you have a relevant issue number handy?
[16:42:03] <cmr> pnkfelix: unfortunately not
[16:43:29] <cmr> acrichto: what about std::rt::crate_map::CrateMap?
[16:43:44] *** Quits: feduser (feduser@534495C6.A5F317B6.799BF54A.IP) (Ping timeout)
[16:43:46] <acrichto> cmr: that's rust's own definition of what the crate map *should* look like
[16:43:52] <acrichto> it used to be in a C++ header
[16:44:04] <cmr> Ok
[16:44:23] <engla> pnkfelix: I guess this issue is central https://github.com/mozilla/rust/issues/6164
[16:45:04] *** Joins: andrew-d_w (andrew-d_w@moz-9A2674DF.dsl.static.sonic.net)
[16:45:21] <engla> pnkfelix: there was a post on the ML about Encoding/Decoding API but almost all of the discussion has been on IRC between olsonjeffery, brson, kimundi, SimonSapin, me, and others(?)
[16:46:15] <cmr> I'm trying to figure out what the crate map is and get rid of it/make it optional/make it less magically necessary
[16:46:37] <cmr> I think the best way to keep it around is give it its own symbol in the object file and use dynamic_lib to read it from itself?
[16:46:41] <engla> pnkfelix: https://mail.mozilla.org/pipermail/rust-dev/2013-September/005503.html "Proposed API for character encodings"
[16:46:42] <SimonSapin> engla: time zones are a pain, moving discussions to the mailing list would be nice :)
[16:46:43] <pnkfelix> engla: thanks.  I had seen some of this material go by, but I hadn't made the connection mentally that it would actually block putting in a way to write &str ...
[16:47:16] <pnkfelix> engla: (i.e. because my understanding is that &str is UTF-8 in Rust, that's the way it is.)
[16:47:48] <SimonSapin> pnkfelix: it depends on whether you just want to write UTF-8, or have full support for arbitrary encodings
[16:47:53] <engla> yes, and conceptually str represents any Unicode string
[16:48:02] <engla> using UTF-8 in the representation
[16:48:29] *** Joins: sankha93 (Instantbir@7061CD01.D6BD0D91.22D41759.IP)
[16:48:34] <pnkfelix> SimonSapin: engla: okay, I get it now, its an issue about how the &str should be transmitted to the receiving Writer
[16:48:42] <SimonSapin> although read is a bit trickier than write: you have to handle cases where a read ends in the middle of a UTF-8 byte sequence
[16:49:43] <engla> pnkfelix: absolutely :-). str is a Unicode string, and the writer wants bytes. So any encoder can bridge that gap
[16:50:00] <pnkfelix> SimonSapin: yes I've had to handle situations like that in a past life.  (Trying to layer a JSON decoder on top of Adobe's IO API's in Flash.  They did not handle the boundary cases well.)
[16:50:31] <SimonSapin> pnkfelix: dealing with that is part of my API proposal on the list
[16:50:51] <pnkfelix> SimonSapin: I'll look over it again, I know that its been a recent topic.
[16:51:05] *** Joins: wilmoore_ (wilmoore@moz-1248C037.mystrotv.com)
[16:51:32] *** Joins: DAddYE (DAddYE@moz-61EB081B.hfc.comcastbusiness.net)
[16:51:58] *** Quits: maik (maik@moz-53663244.dip0.t-ipconnect.de) (Ping timeout)
[16:52:01] *** Quits: wilmoore (wilmoore@moz-7EE4D9D6.mystrotv.com) (Ping timeout)
[16:52:48] *** Joins: zeuxcg (zeuxcg@moz-77D36DA2.mycingular.net)
[16:53:12] <SimonSapin> pnkfelix: also, because some encodings are variable-width you can not ask "read this many bytes worth of str"
[16:53:13] *** Joins: hoverbear (andrew@moz-87982B6F.wireless.uvic.ca)
[16:53:21] *** Joins: lkuper_ (lkuper@moz-C0CD33ED.hsd1.in.comcast.net)
[16:53:35] <SimonSapin> you read some amount of input bytes, and its only after decoding that you know the length of the decoded str
[16:54:28] *** Joins: jclements (jclements@moz-EEA2CC16.lightspeed.stlsmo.sbcglobal.net)
[16:54:51] <SimonSapin> gotta go now, so please send feedback to the mailing list :)
[16:55:00] <acrichto> r? https://github.com/mozilla/rust/pull/9296
[16:55:39] <engla> yay acrichto 
[16:58:11] *** Joins: Cromulent (Cromulent@moz-983B638D.cable.virginmedia.com)
[16:59:23] *** Joins: Shaladdle (Shaladdle@moz-424BC304.hsd1.pa.comcast.net)
[17:00:19] *** Joins: Kruppe (user@moz-A17153FF.net.uwaterloo.ca)
[17:00:31] <luisbg> acrichto, \o/
[17:01:00] <sw17ch> Is there an iterator that supports backtracking?
[17:01:19] <sw17ch> looking at std::iter and nothing pops out
[17:01:30] <engla> well you can .clone() a vec iterator if you want to go back to a previous place
[17:01:33] *** Parts: jdsanders (Adium@moz-F45527D6.hlrn.qwest.net) ()
[17:01:50] <engla> the only adaptor is .peekable() which gives you a one-element .peek()
[17:02:10] *** Quits: Cromulent (Cromulent@moz-983B638D.cable.virginmedia.com) (Quit: KVIrc 4.2.0 Equilibrium http://www.kvirc.net/)
[17:02:15] <sw17ch> Hmm. Okay. Thinking about using iterators to build an infinite lookahead parser.
[17:02:31] <sw17ch> (learning Rust still, sorry if it's a weird question)
[17:02:52] <engla> it sounds like a normal question
[17:03:02] <kimundi> sw17ch: Probably doable, but definitly something where you need to clone an iterator
[17:03:12] *** Joins: Larry (larryfox@moz-343B6F0C.nyc.biz.rr.com)
[17:03:19] <kimundi> to "save a spot"
[17:03:29] *** Quits: zeuxcg (zeuxcg@moz-77D36DA2.mycingular.net) (Ping timeout)
[17:03:42] <engla> sw17ch: the answer is partly that std::iter contains almost exclusively adaptors that are simple and efficient, And infinite lookahead isn't, for the general case
[17:04:23] <sw17ch> kimundi, engla: okay. i think i follow. i think the part that's still a little unclear to me is whether or not that clone is going to clone the underlying iterated stream/object.
[17:04:57] <engla> that depends on what you are cloning. A vec iterator just clones the pointers into the vector
[17:05:03] <engla> so it's cheap
[17:05:04] <kimundi> sw17ch: You clone the iterator itself. It will not change anything around the object you're iterating over
[17:05:10] *** Quits: Yurume (yurume@AC58A8CE.8A059B47.E313B915.IP) (Ping timeout)
[17:05:19] *** Joins: maik (maik@moz-53663244.dip0.t-ipconnect.de)
[17:05:30] <sw17ch> That was my assumption. I don't think cloning the iterator is a particularly painful or expensive operation in my circumstance.
[17:05:48] <sw17ch> And is what I expected.
[17:06:04] <kimundi> That is, iterator's usually don't own the data they are iterating over, unless they are explicitly designed to produce values themself. But those iterators tend to be cheaply copyable anyway
[17:06:14] *** Quits: CarpNet (ac@moz-FD24B77.sohonet.co.uk) (Quit: Leaving)
[17:06:24] <engla> rusti: range(0,10).clone()
[17:06:25] -rusti- std::iter::Range<int>{state: 0, stop: 10, one: 1}
[17:06:45] *** Joins: Yurume (yurume@AC58A8CE.8A059B47.E313B915.IP)
[17:07:06] <engla> rusti: let v = [1,2,3]; println!("{:?}", v.iter().clone())
[17:07:06] -rusti- std::vec::VecIterator<,int>{ptr: (0x7f7c412210e0 as *()), end: (0x7f7c412210f8 as *()), lifetime: &1}
[17:07:06] -rusti- ()
[17:07:16] <kimundi> rusti: let r = range(0, 10); r.next(); let r2 = r.clone(); r.next(); (r.to_owned_str(), r2.to_owned_str())
[17:07:17] <acrichto> brson: http://static.rust-lang.org/doc/master/extra/json.html appears to also be missing
[17:07:18] -rusti- pastebinned 8 lines of output: http://sprunge.us/QWEW
[17:07:48] <kimundi> rusti: let r = range(0u, 10u); r.next(); let r2 = r.clone(); r.next(); (r.to_owned_vec(), r2.to_owned_vec())
[17:07:54] -rusti- pastebinned 14 lines of output: http://sprunge.us/dihJ
[17:07:57] <kimundi> gnar
[17:08:30] <kimundi> rusti: let mut r = range(0u, 10u); r.next(); let mut r2 = r.clone(); r.next(); (r.to_owned_vec(), r2.to_owned_vec())
[17:08:30] -rusti- (~[2u, 3u, 4u, 5u, 6u, 7u, 8u, 9u], ~[1u, 2u, 3u, 4u, 5u, 6u, 7u, 8u, 9u])
[17:08:34] <kimundi> there
[17:08:41] <kimundi> clone range, with saved spot :P
[17:08:58] *** Quits: vodik (simon@moz-CBE4BB13.cable.teksavvy.com) (Ping timeout)
[17:09:00] <kimundi> cloned*
[17:11:34] <engla> I've got a toy parser combinator and it uses a vec iterator for infinite lookahead
[17:11:41] <engla> I'd like to make it more general though
[17:12:28] *** Joins: Ralith (ralith@A8995AA9.62B6AF6A.922221DB.IP)
[17:13:58] *** Quits: Yurume (yurume@AC58A8CE.8A059B47.E313B915.IP) (Ping timeout)
[17:14:00] *** Joins: Yurume (yurume@AC58A8CE.8A059B47.E313B915.IP)
[17:14:40] <quksw_> is there any meaning to the mark-sign in the function names like assert! and fmt!?
[17:14:59] <bstrie> quksw_: it means that there is compile-time code expansion going on
[17:15:02] *** Joins: snadon (chatzilla@B31BB78D.5D9DCD7F.47C41102.IP)
[17:15:34] <bstrie> quksw_: there are ways to invoke the compiler such that it will show you what the code looks like after the expansion phase
[17:15:34] <engla> the exclamation mark is the syntax for a syntax extension, including macros
[17:16:41] *** Joins: azita (Azita@moz-BBE3ABD.mv.mozilla.com)
[17:16:58] <quksw_> engla: hmmm... okay. 10x for the fast respond :)
[17:17:31] <quksw_> bstrie: 10x :)
[17:17:36] <bstrie> so many xs
[17:17:39] <engla> rusti: macro_rules! is_match( ($E:expr, $Pattern:pat) => ( match $E { $Pattern => true, _ => false }) )  is_match!(Some(2), None)
[17:17:40] -rusti- false
[17:17:48] <engla> yeah I'm starting to wonder what the base factor is
[17:17:54] <engla> if it's 0 then I'm going to be sad
[17:18:28] *** Quits: barosl (barosl@3DE683B6.E551553C.7544CABF.IP) (Quit: ëžœë¤ì€ ì‡ í‡´í–ˆìŠµë‹ˆë‹¤.)
[17:18:46] <engla> someone here invented that cool macro above
[17:19:29] <kimundi> engla: Hm... I know that I wanted to have such an macro months ago :P
[17:20:10] <engla> rusti: macro_rules! is_match( ($E:expr, $($Pattern:pat)|+) => ( match $E { $($Pattern)|+ => true, _ => false }) )  is_match!(Some(2), None | Some(2))
[17:20:10] -rusti- true
[17:20:53] *** Quits: hoverbear (andrew@moz-87982B6F.wireless.uvic.ca) (Quit: hoverbear)
[17:20:56] <engla> I found out it's useful when testing things that don't define Eq
[17:21:05] <kimundi> yeah
[17:21:23] <kimundi> (Do a PR! :P)
[17:22:33] <engla> not sure, it smells rather like a macro purge is in the air
[17:22:49] <jclements> engla: hey now... nothing wrong with macros.
[17:22:50] <engla> to remove things that rust doesn't want to support in a stable future
[17:22:55] <kimundi> yeah :|
[17:23:10] <bstrie> no reason to remove macros that are defined by the compiler itself
[17:23:14] <jclements> engla: I don't think anyone is talking about actively removing macros. 
[17:23:16] <engla> lack of namespacing is wrong with macros at the moment
[17:23:41] <engla> jclements: https://github.com/mozilla/rust/issues/9282
[17:23:48] <kimundi> I know that we need to converge to something stable... But I'd be also happy if we'd just keep changing things around till everything is perfect. :P
[17:24:01] <engla> project lead is thinking about such things ^^
[17:24:03] <bstrie> I'm actually find with removing cond!
[17:24:32] <bstrie> it's not super useful in terms of sugar
[17:24:34] <jclements> engla: removing an unused macro seems like an excellent idea to me; this sounds like much-needed cleanup, not a macro pogrom.
[17:25:33] *** Quits: Jesin (Jessin_@moz-CE9E5E72.cc.lehigh.edu) (Ping timeout)
[17:25:35] *** Joins: moot (Mibbit@moz-5256162B.hsd1.ca.comcast.net)
[17:25:49] <engla> let's not put value words into it. some macros are being removed
[17:25:50] *** Joins: ofeldt (ofeldt@moz-32135DD8.dip0.t-ipconnect.de)
[17:25:52] *** Quits: Excureo (c@moz-EB93D257.static.knwc.wa.charter.com) (Ping timeout)
[17:26:05] *** Joins: ghrust (ghrust@24260B07.6A2AE50.F3114085.IP)
[17:26:05] <ghrust> 01[13rust01] 15bors merged 06auto into 06master: 02http://git.io/eaPgTQ
[17:26:05] *** Parts: ghrust (ghrust@24260B07.6A2AE50.F3114085.IP) ()
[17:26:06] <jclements> pauls, dherman: sounds like we need to put together a "macro roadmap" for Rust. make sense to either of you?
[17:26:06] *** Joins: kkris (kkris@moz-CB70009.yourvserver.net)
[17:26:08] *** Joins: spider-mario (spidermari@moz-81131DB6.fbx.proxad.net)
[17:26:21] <bstrie> macros are a big selling point
[17:26:23] <jclements> engla: my apologies.
[17:26:28] <jclements> bstrie: +100
[17:26:30] *** Quits: ofeldt- (ofeldt@moz-39E7AEB3.dip0.t-ipconnect.de) (Ping timeout)
[17:26:35] <bstrie> like, super big
[17:26:54] <dherman> jclements: sure thing, sounds good
[17:26:58] <bstrie> without them we don't have a metaprogramming story, really at all
[17:26:59] <jclements> pauls: it's time to write that paper.
[17:27:06] <bstrie> I mean, I'm fine with them being behind a flag for 1.0
[17:27:11] <bstrie> schedules are important
[17:27:32] <bstrie> but they can't just be left by the wayside for "someday". gotta have a plan
[17:27:34] *** Joins: tjc (tjc@moz-A4171C90.dsl.pltn13.sbcglobal.net)
[17:27:35] *** ChanServ sets mode: +o tjc
[17:27:37] *** Quits: snadon (chatzilla@B31BB78D.5D9DCD7F.47C41102.IP) (Quit: ChatZilla 0.9.90.1 [Firefox 24.0/20130909203154])
[17:28:48] *** Joins: hoverbear (andrew@moz-87982B6F.wireless.uvic.ca)
[17:30:08] *** Joins: pcwalton (pcwalton@moz-BBE3ABD.mv.mozilla.com)
[17:30:08] *** ChanServ sets mode: +ao pcwalton pcwalton
[17:31:00] <engla> jclements: you guys should read the meeting transcript https://github.com/mozilla/rust/wiki/Meeting-weekly-2013-09-17
[17:31:16] *** Joins: ghrust (ghrust@C8693FCB.6A2AE50.F3114085.IP)
[17:31:16] <ghrust> 01[13rust01] 15bors pushed 0 new commits to 06auto: 02http://git.io/Kpbe6w
[17:31:16] *** Parts: ghrust (ghrust@C8693FCB.6A2AE50.F3114085.IP) ()
[17:31:18] *** Joins: ghrust (ghrust@DE823A67.6A2AE50.F3114085.IP)
[17:31:18] <ghrust> 01[13rust01] 15bors pushed 2 new commits to 06auto: 02http://git.io/SnLzEg
[17:31:18] <ghrust> 13rust/06auto 149c4797e 15Alex Crichton: Register new snapshots
[17:31:18] <ghrust> 13rust/06auto 147448a8e 15bors: auto merge of #9296 : alexcrichton/rust/snapshots, r=cmr...
[17:31:18] *** Parts: ghrust (ghrust@DE823A67.6A2AE50.F3114085.IP) ()
[17:31:18] *** Joins: Excureo (c@moz-EB93D257.static.knwc.wa.charter.com)
[17:31:58] <Luqman> brson: r? https://github.com/mozilla/rust/pull/9287
[17:32:14] *** Quits: hjr3 (hradtke@1A0AE795.28A5F6C3.A2D40ED2.IP) (Ping timeout)
[17:32:34] *** Joins: hjr3 (hradtke@1A0AE795.28A5F6C3.A2D40ED2.IP)
[17:32:40] *** Joins: Shaladdle_ (anonymous@80F21B40.28336FB0.689607DE.IP)
[17:34:31] *** Quits: pcwalton (pcwalton@moz-BBE3ABD.mv.mozilla.com) (Quit: pcwalton)
[17:36:13] <cmr> Luqman: hah, you beat me to the crate map stuff :)
[17:37:48] *** Quits: Kruppe (user@moz-A17153FF.net.uwaterloo.ca) (Ping timeout)
[17:37:54] <cmr> Luqman: What is the crate_map attr for, exactly?
[17:38:09] <cmr> Luqman: it checks for that attribute and exports the crate mapwith that symbol?
[17:38:22] *** Quits: Amaranth (travis@moz-F81BB56A.cpe.cableone.net) (Ping timeout)
[17:39:49] <Luqman> cmr: i would've been happy with just doing extern { static _rust_crate_map_toplevel: CrateMap; } but rustc/llvm thinks i'm trying to define a new symbol or something and tacks on a 1 to it resulting in linking errors
[17:40:13] *** Joins: Yurume_ (yurume@AC58A8CE.8A059B47.E313B915.IP)
[17:40:56] *** Joins: pcwalton (pcwalton@moz-7B0110AD.mv.mozilla.com)
[17:40:56] *** ChanServ sets mode: +ao pcwalton pcwalton
[17:41:17] *** Quits: maik (maik@moz-53663244.dip0.t-ipconnect.de) (Ping timeout)
[17:41:41] *** Quits: Yurume (yurume@AC58A8CE.8A059B47.E313B915.IP) (Ping timeout)
[17:42:13] *** Joins: infynyxx (infynyxx@DB780A29.749BA1D.DCC373F0.IP)
[17:42:16] <nmatsakis> jclements: I would like to understand sometihng re: macros -- are there theoretical challenges with supprting macro import/export? or a small matter of effort?
[17:42:53] *** Quits: Shaladdle_ (anonymous@80F21B40.28336FB0.689607DE.IP) (Ping timeout)
[17:43:12] <jclements> nmatsakis: I'm not aware of theoretical challenges.  You can make choices (procedural macros) that significantly complicate things, but I don't think those are currently on the radar.
[17:43:19] <bstrie> from reading the bug I thought that macro imports required dynamic linking, or something?
[17:43:48] <jclements> bstrie: erm... which bug?
[17:43:58] <cmr> bstrie: different issue
[17:44:09] <cmr> that's loading syntax extensinos at compiletime
[17:44:11] <cmr> not macros
[17:44:17] <bstrie> ah ok
[17:44:24] <nmatsakis> well... they are tightly interconnected
[17:44:29] *** Quits: Yurume_ (yurume@AC58A8CE.8A059B47.E313B915.IP) (Quit: Leaving)
[17:44:32] <nmatsakis> another name for "syntax extension" basically is "procedural macro"
[17:44:51] <nmatsakis> or at least they are related
[17:45:13] <jclements> nmatsakis: I'm starting to see that import/export--even just inside crates--is a Highly Desirable feature.  Probably higher-priority than hygiene.
[17:45:37] <cmr> namespacing of macros and importing them from other crates is just including them in the metadata and adding somelogic to resolve, I think
[17:45:39] <nmatsakis> jclements: cross-crate also. certainly it's highly related to the question of what we do with closures
[17:45:52] *** Quits: tjc (tjc@moz-A4171C90.dsl.pltn13.sbcglobal.net) (Quit: zzzzzzzzzz)
[17:45:57] <nmatsakis> since one of the ideas hinged on being able to define macros ...
[17:46:34] <cmr> although I suppose that is trickier than I thought, macros happen way befoer reoslve
[17:47:20] <nmatsakis> it seems tricky :)
[17:47:20] <jclements> cmr: I think laziness handles that, though the plumbing may be ugly.
[17:47:41] *** Joins: Yurume (yurume@AC58A8CE.8A059B47.E313B915.IP)
[17:47:43] * kimundi is in favor of calling them declarative and procedural macros, and reserving the term syntax extension as a general term for both kinds of macros and attributes
[17:48:08] <brson> acrichto: sad news about the snapshot. your missing doc reappeared - maybe you requested it in the middle of a reupload?
[17:48:11] *** sam113101 is now known as sam113101_afk
[17:48:17] <bstrie> how about we call macros "macros" and call syntax extensions "compiler plugins" :P
[17:48:20] <jclements> kimundi: declarative and procedural macros matches (in my mind) standard nomenclature, and I'd be happy to use these terms.
[17:48:26] <brson> acrichto: did you figure out the problem with libmorestack.a?
[17:48:58] <jclements> nmatsakis: what's the issue with macros & closures? Are people thinking they'd like to be able to export macros that capture local bindings? 
[17:49:08] *** Quits: hoverbear (andrew@moz-87982B6F.wireless.uvic.ca) (Quit: hoverbear)
[17:49:15] *** sam113101_afk is now known as sam113101
[17:49:35] <kimundi> jclements: I get annoyed everytime someone say that print! is not an syntax extension but an macro - they both extend the syntax!
[17:49:57] <nmatsakis> jclements: no, I had hoped to replace some uses of closures with macros
[17:50:14] *** Quits: jaen (jaen@FB01674D.56B727FE.4B52F012.IP) (Ping timeout)
[17:50:22] <nmatsakis> jclements: http://smallcultfollowing.com/babysteps/blog/2013/06/03/more-on-fns/
[17:50:23] <kimundi> nmatsakis: Wasn't the idea to introduce an thunk {  } syntax?
[17:50:32] *** Joins: Florob (Florob@moz-39532932.de)
[17:50:32] <nmatsakis> kimundi: my presonal pref is not to do so
[17:50:41] <nmatsakis> in fact, I think i'd be opposed to it
[17:50:46] <nmatsakis> though I did entertain the notion
[17:50:56] <nmatsakis> the reason I think I'd be opposed to it is:
[17:51:08] <cmr> I don't have opinions about what happens around  closures as long as they're easy to use and pretty to look at
[17:51:10] *** Quits: ahal (ahal@FCCEA34F.7672369.D8E68FF6.IP) (Ping timeout)
[17:51:12] * kimundi thinks having to type out all captures will get old fast - Didn't that feature exist with the current closures once and got removed?
[17:51:12] <nmatsakis> I expect that there will be other traits,
[17:51:13] *** Joins: SiegeLord (sl@moz-CAF07B4C.hsd1.ma.comcast.net)
[17:51:15] <cmr> And easy to reason about
[17:51:22] <nmatsakis> and they would want their own macros
[17:52:25] <acrichto> brson: looks like I was hallucinating about libmorestack, we've never had libmorestack.a in a snapshot
[17:52:25] <kimundi> nmatsakis: Okay, versatility I can understand
[17:52:40] <acrichto> brson: the snapshot pull hasn't failed yet, so perhaps it may just work!
[17:53:19] *** Joins: voxpopuli (fanservice@moz-FE161659.wv.cc.cmu.edu)
[17:53:20] *** Joins: jdm (jdm@FCCEA34F.7672369.D8E68FF6.IP)
[17:53:20] *** ChanServ sets mode: +o jdm
[17:53:53] <pauls> kimundi: I agree, the intention of "syntax extension"/"macro" was about user-definedness.
[17:54:26] <pauls> (unfortunately, I've found myself having to say "syntax extension)" and leave out "except for macros", because that's too cumbersome.
[17:54:35] <pauls> Someday, all this will be macros!
[17:55:20] <nmatsakis> kimundi: whether explicitly naming closed over values is tolerable is the key question, I guess.
[17:55:26] <nmatsakis> or one of them anyway
[17:55:33] <cmr> pauls: except attributes? :)
[17:56:13] * kimundi wished he could just - like - take a year of or so to dig into the compiler, and start changing things he has opinions about
[17:56:29] *** Joins: maik (maik@moz-53663244.dip0.t-ipconnect.de)
[17:56:46] <benh> What is a good way to write tests to ensure that the correct spans are indicated in lexer error messages?
[17:57:12] *** Joins: hoverbear (andrew@moz-87982B6F.wireless.uvic.ca)
[17:57:19] <kimundi> nmatsakis: One could envision a scheme where 'thunk {  }' just produces the 'to-be-captured' tokens in a way that custom macros logic can take it from there
[17:57:28] *** Joins: yeri (yeri@moz-C3D3381.mycingular.net)
[17:57:31] *** Joins: tcsc (tcsc@786D23EA.402C399C.EFCBE50E.IP)
[17:57:56] <cmr> benh: I don't think we have anything more fine-grained than lines]
[17:58:19] *** Quits: moot (Mibbit@moz-5256162B.hsd1.ca.comcast.net) (Quit: http://www.mibbit.com ajax IRC Client)
[17:58:22] <benh> well, that'd be good enough if i set it up so the "wrong" span is on a different line ;)
[17:58:57] <cmr> See src/test/compile-fail and the //~ ERROR: foo
[17:59:00] <kimundi> `thunk new_task! { ... capture a ... }` => `new_task!((a) -> { ...  captures a ... })`
[17:59:12] <benh> ok, thanks
[17:59:33] <kimundi> Just define an macro interface for thunk! and let the user decide which one to actually use
[18:00:00] <kimundi> Would also mean automatic capture becomes optional
[18:00:04] <olsonjeffery> nmatsakis: i recall, at one point, the touting of rust's implicit capture vis-a-vis c# and obj-c's explicit schemes
[18:00:28] <olsonjeffery> but maybe this is the logical end-state for all languages that actually give programmers real control and accounting over memory
[18:00:42] <olsonjeffery> s/c#/C++/
[18:00:52] *** Quits: shachaf (shachaf@moz-F37E0395.members.linode.com) (Ping timeout)
[18:00:57] <nmatsakis> olsonjeffery: yes well, perhaps some eating of crow is involved :)
[18:01:01] <nmatsakis> we'll see
[18:01:12] <kimundi> nmatsakis: (what do you think of that idea?)
[18:01:23] <nmatsakis> kimundi: sorry, which idea?
[18:01:32] <kimundi> my last 4 lines
[18:03:42] <nmatsakis> kimundi: I see -- that is actually a pretty interesting idea
[18:04:07] *** Quits: geomyidae (quassel@DD6F7E3A.21468E9A.30200F38.IP) (Connection reset by peer)
[18:04:08] *** Quits: jclements (jclements@moz-EEA2CC16.lightspeed.stlsmo.sbcglobal.net) (Quit: jclements)
[18:04:21] <cmr> I agree that it's interesting, but the |args| -> ret { body } is so pretty and convenient. I'd hate to see it go away.
[18:04:46] <kimundi> cmr: I think that will still stay for stack closures
[18:05:10] <kimundi> cmr: And might even get implemnted to produce extern fn()s if not capture happens
[18:05:58] <engla> I think step zero is to allow the lambda expression to create simple extern "Rust" fn() values, that way you could start building your own closure impls
[18:06:16] *** Joins: ghrust (ghrust@24260B07.6A2AE50.F3114085.IP)
[18:06:16] <ghrust> 01[13rust01] 15bors 04force-pushed 06auto from 147448a8e to 14b43ee6c: 02http://git.io/N3iJvQ
[18:06:16] *** Parts: ghrust (ghrust@24260B07.6A2AE50.F3114085.IP) ()
[18:06:17] *** Joins: ghrust (ghrust@2EE61FCC.6A2AE50.F3114085.IP)
[18:06:17] <ghrust> 01[13rust01] 15bors pushed 2 new commits to 06auto: 02http://git.io/xPePxA
[18:06:17] <ghrust> 13rust/06auto 14c624237 15Alex Crichton: Implement process bindings to libuv...
[18:06:17] <ghrust> 13rust/06auto 14847b0f1 15bors: auto merge of #9260 : alexcrichton/rust/libuv-processes, r=brson...
[18:06:18] *** Parts: ghrust (ghrust@2EE61FCC.6A2AE50.F3114085.IP) ()
[18:07:34] <kimundi> I could imagine to expand the syntax accordingly: `let x = thunk task! |a: uint| { ... }` or so...
[18:08:19] <brson> Luqman: how does your crate map change work?
[18:08:50] *** Joins: fabiand (fabiand@moz-34EAF1E0.adsl.alicedsl.de)
[18:09:38] *** Joins: ahal (ahal@13F2CEC5.7672369.D8E68FF6.IP)
[18:10:23] *** Quits: donri (donri@moz-9BB61102.tbcn.telia.com) (Client exited)
[18:12:10] *** Quits: nik_ (nik@moz-CDF71706.vpn.rwth-aachen.de) (Ping timeout)
[18:12:33] <brson> cmr: do you understand how Luqman's change works?
[18:12:57] *** Joins: riley (riley@8BA43816.9AA11D69.65DDFA89.IP)
[18:13:00] <cmr> brson: aiui it exports the crate map under the symbol given by the crate_map attribute.
[18:14:44] <Luqman> cmr: well it's more like it maps that symbol to _rust_crate_map_toplevel
[18:14:49] <cmr> oh
[18:15:05] <brson> Luqman: the way I read it that will always return the value of libstd's crate map
[18:15:30] *** Joins: jensnockert (jensnocker@moz-8BE55278.customer.t3.se)
[18:17:06] <Luqman> brson: hmm, actually yea :(
[18:17:12] *** Quits: infynyxx (infynyxx@DB780A29.749BA1D.DCC373F0.IP) (Client exited)
[18:18:14] <brson> cmr: can you remove your r+?
[18:18:20] <cmr> ye
[18:18:51] *** Joins: infynyxx (infynyxx@DB780A29.749BA1D.DCC373F0.IP)
[18:19:23] *** Quits: hoverbear (andrew@moz-87982B6F.wireless.uvic.ca) (Quit: hoverbear)
[18:19:40] *** Quits: riley (riley@8BA43816.9AA11D69.65DDFA89.IP) (Client exited)
[18:19:55] <Luqman> i'll close it for now and fix it up later today
[18:23:49] <kimundi> cmr: Is there a reason why rustdoc_ng is not integrated as an library the same way rustc, rsut, rusti, rustdoc etc are?
[18:24:03] <cmr> kimundi: it is
[18:24:15] <cmr> see lib.rs
[18:24:25] <kimundi> cmr: Right, but not in the saem way as the others
[18:24:31] <cmr> rustdoc_ng.rs was  previously mani.rs
[18:24:32] <cmr> *main.rs
[18:24:36] <kimundi> so I was wondering
[18:24:37] <cmr> kimundi: that, I can't answer.
[18:24:50] <kimundi> Hm. okay
[18:25:00] *** Joins: mihneadb (mihneadb@41E65AA5.B2E373EA.FCAAE698.IP)
[18:25:14] <cmr> ask acrichto; he did the majority of the makefile jiggering
[18:25:23] <engla> which lib.rs?
[18:25:35] <acrichto> kimundi: that should be changed now
[18:25:38] <acrichto> on master
[18:25:39] <engla> rustdoc_ng.rs seems to be the main file
[18:25:49] <cmr> Oh, hm
[18:25:54] <cmr> acrichto merged htem
[18:26:07] <acrichto> it only builds as a library now
[18:26:19] <acrichto> and then src/driver/driver.rs links to it and rust it in a separate rustdoc_ng executable
[18:26:32] <olsonjeffery> ios 7 stole my car and then burned my house down
[18:26:39] <olsonjeffery> seriously.
[18:26:40] <cmr> acrichto: is this compatible with rustpkg?
[18:26:45] *** Quits: mihneadb (mihneadb@41E65AA5.B2E373EA.FCAAE698.IP) (Ping timeout)
[18:26:45] <kimundi> olsonjeffery: wut?
[18:27:05] <acrichto> cmr: dunno, but I doubt it
[18:27:28] <cmr> that's unfortunate, I was trying to keep it a proper rustpkg project
[18:27:28] <acrichto> if we reorganize rustpkg to build the rest of the compiler, we can reorganize rustdoc_ng back 
[18:27:31] <cmr> ah well
[18:27:38] <bstrie> olsonjeffery: sorry for your loss, but fortunately you need neither a house nor a car to work on rust *cracks the whip*
[18:27:54] <acrichto> cmr: huh, I didn't even realize that was why it was the way it was, but that makes sense...
[18:29:36] *** jorendorff is now known as jorendorff_away
[18:29:44] * kimundi thinks it somehow... wrong... to have two different crate roots, if one is for the executable and the other for the lib
[18:30:24] *** Quits: maik (maik@moz-53663244.dip0.t-ipconnect.de) (Ping timeout)
[18:30:46] *** Joins: nik_ (nik@moz-6A09505.pool.mediaways.net)
[18:31:57] *** Joins: jclements (jclements@moz-3CA4E1EA.static.stls.mo.charter.com)
[18:32:18] *** Joins: Ferreus (daniel@moz-F33CA692.dyn.telefonica.de)
[18:33:50] *** Joins: shachaf (shachaf@moz-F37E0395.members.linode.com)
[18:36:46] <engla> nmatsakis: the macro part of thunk! is just to support a variable number of captures I guss, the rest you can do with just a function (take a tuple as capture and a lambda)
[18:37:30] <nmatsakis> engla: the macro is just to avoid repeating yourself and writing tedious things
[18:37:34] *** Joins: wilmoore (wilmoore@moz-7EE4D9D6.mystrotv.com)
[18:38:08] *** Quits: wilmoore_ (wilmoore@moz-1248C037.mystrotv.com) (Ping timeout)
[18:38:10] *** Quits: yeri (yeri@moz-C3D3381.mycingular.net) (Quit: Colloquy for iPhone - http://colloquy.mobi)
[18:38:12] *** Joins: nrc (nrc@7BE24E90.A5032A01.3CFC199D.IP)
[18:38:50] *** Joins: gandalf (zbraniecki@moz-BE33DA21.fw1.sfo1.mozilla.net)
[18:39:27] *** Joins: feduser (feduser@2A51D215.D610364D.799BF54A.IP)
[18:40:22] <engla> ok then I don't know what it does, a function can be said to do the same
[18:40:59] *** Joins: yeri (yeri@moz-C3D3381.mycingular.net)
[18:41:12] <engla> let add1 = do capture(1) |upvar, arg| { *upvar + arg };
[18:42:17] *** Quits: tcsc (tcsc@786D23EA.402C399C.EFCBE50E.IP) (Quit: computer sleeping)
[18:43:44] *** Quits: infynyxx (infynyxx@DB780A29.749BA1D.DCC373F0.IP) (Client exited)
[18:43:56] <benh> do we have those alias/as patterns currently?
[18:44:10] *** Joins: riley (riley@8BA43816.9AA11D69.65DDFA89.IP)
[18:44:35] <benh> rusti: match 42 { s@42 => s, _ => 0 }
[18:44:36] -rusti- 42
[18:44:41] <benh> are they stayingg?
[18:44:50] <bstrie> benh: don't think there's any reason to remove them
[18:44:54] *** Joins: infynyxx (infynyxx@DB780A29.749BA1D.DCC373F0.IP)
[18:45:33] *** Quits: fabiand (fabiand@moz-34EAF1E0.adsl.alicedsl.de) (Ping timeout)
[18:45:59] <benh> let pos = match rdr.last_pos { n@BytePos(0) => n, n => n - BytePos(1u) }; <- does this sound reasonably idiomatic?
[18:46:33] *** Quits: infynyxx (infynyxx@DB780A29.749BA1D.DCC373F0.IP) (Client exited)
[18:46:37] *** Joins: ghrust (ghrust@F6EE6DE3.6A2AE50.F3114085.IP)
[18:46:37] <ghrust> 01[13rust01] 15bors 04force-pushed 06auto from 14847b0f1 to 14b43ee6c: 02http://git.io/N3iJvQ
[18:46:37] *** Parts: ghrust (ghrust@F6EE6DE3.6A2AE50.F3114085.IP) ()
[18:46:39] *** Joins: ghrust (ghrust@C8693FCB.6A2AE50.F3114085.IP)
[18:46:39] <ghrust> 01[13rust01] 15bors pushed 2 new commits to 06auto: 02http://git.io/_q-4DQ
[18:46:39] <ghrust> 13rust/06auto 14817576e 15Alex Crichton: Register new snapshots
[18:46:39] <ghrust> 13rust/06auto 14d2b0b11 15bors: auto merge of #9296 : alexcrichton/rust/snapshots, r=cmr...
[18:46:39] *** Parts: ghrust (ghrust@C8693FCB.6A2AE50.F3114085.IP) ()
[18:46:42] *** Quits: dave1629 (dave@3E11D95A.C422786F.DDE5D3F6.IP) (Quit: dave1629)
[18:48:37] <bstrie> benh: seems fine. assuming that BytePos overloads the - operator, of course
[18:52:17] *** Joins: lenstr (lenstr@AF8EB999.6049B16A.85938D85.IP)
[18:53:07] *** jorendorff_away is now known as jorendorff
[18:54:13] *** Joins: dave1629 (dave@3E11D95A.C422786F.DDE5D3F6.IP)
[18:54:22] *** Quits: jxv (jxv@moz-8FB92450.lightspeed.irvnca.sbcglobal.net) (Ping timeout)
[18:56:40] *** Joins: Palmik (palmik@moz-11EA685D.pks.muni.cz)
[18:58:07] *** Joins: infynyxx (infynyxx@DB780A29.749BA1D.DCC373F0.IP)
[18:58:09] *** Quits: riley (riley@8BA43816.9AA11D69.65DDFA89.IP) (Client exited)
[18:59:32] *** Quits: jensnockert (jensnocker@moz-8BE55278.customer.t3.se) (Input/output error)
[18:59:34] *** Joins: Amaranth (travis@moz-F81BB56A.cpe.cableone.net)
[18:59:46] *** Quits: infynyxx (infynyxx@DB780A29.749BA1D.DCC373F0.IP) (Client exited)
[18:59:51] *** Joins: obk (Mibbit@56A7885C.6849BFB2.CB858787.IP)
[19:01:11] <benh> Is there something like the //~ ERROR directive for cfail tests except that they precede the erroneous code?
[19:01:22] <benh> hard to test for unexpected eof!
[19:01:50] *** Quits: FrozenCow (FrozenCow@moz-B2DF4929.chello.nl) (Ping timeout)
[19:02:06] <brson> benh: no. you can use `error-pattern:` though
[19:02:08] <engla> nmatsakis: a fleshed out example, functions can also create trait objects for thunks. https://gist.github.com/anonymous/5ed47e211c6a38da8470
[19:02:22] *** Quits: Amaranth (travis@moz-F81BB56A.cpe.cableone.net) (Ping timeout)
[19:02:39] <benh> I wanted to check for the specific span of the error so I think I'll just skip those tests.
[19:02:47] *** Joins: Amaranth (travis@moz-F81BB56A.cpe.cableone.net)
[19:03:27] <engla> (now in the future, instead of ~fn() that lambda expression should just be an extern fn())
[19:05:45] *** jorendorff is now known as jorendorff_away
[19:06:07] *** Joins: strcat (strcat@moz-54F7FD49.cpe.net.cable.rogers.com)
[19:07:15] *** Quits: andrew-d_w (andrew-d_w@moz-9A2674DF.dsl.static.sonic.net) (Input/output error)
[19:07:19] *** Quits: yeri (yeri@moz-C3D3381.mycingular.net) (Quit: Colloquy for iPhone - http://colloquy.mobi)
[19:07:24] *** Quits: SiegeLord (sl@moz-CAF07B4C.hsd1.ma.comcast.net) (Quit: It's a joke, it's all a joke.)
[19:07:30] *** Joins: vodik (simon@moz-CBE4BB13.cable.teksavvy.com)
[19:07:36] *** Joins: tikue_ (tkuehn@moz-FEADCD38.hsd1.pa.comcast.net)
[19:07:39] <benh> Are all tests supposed to have the copyright header, even embarassingly trivial oneliners?
[19:07:45] *** Quits: santiago (santiago@moz-8ADE82B4.socal.res.rr.com) (Quit: Textual IRC Client: http://www.textualapp.com/)
[19:07:49] *** Joins: fabiand (fabiand@moz-34EAF1E0.adsl.alicedsl.de)
[19:08:02] *** Joins: riley (riley@8BA43816.9AA11D69.65DDFA89.IP)
[19:08:12] <kimundi> benh: Afaik it's not that necessary for test, but add them anyway
[19:08:39] *** Joins: mihneadb (mihneadb@41E65AA5.B2E373EA.FCAAE698.IP)
[19:09:08] <nmatsakis> engla: that is true. goal of macro mostly was to avoid repeating names/values of upvars etc
[19:09:25] *** Quits: BizarreCake (BizarreCak@moz-361FE9B2.dynamic.barak-online.net) (Ping timeout)
[19:09:25] *** Joins: yeri (yeri@moz-C3D3381.mycingular.net)
[19:10:29] *** Joins: pnkfelix1 (pnkfelix@moz-43495417.fbx.proxad.net)
[19:10:30] *** Joins: SiegeLord (sl@moz-CAF07B4C.hsd1.ma.comcast.net)
[19:10:30] *** Joins: Kruppe (user@moz-14BD8BF5.net.uwaterloo.ca)
[19:11:35] *** Quits: pnkfelix (pnkfelix@moz-43495417.fbx.proxad.net) (Ping timeout)
[19:11:42] *** Joins: jxv (jxv@moz-8FB92450.lightspeed.irvnca.sbcglobal.net)
[19:12:40] <obk> I'm missing something pretty basic about traits. What's wrong with http://mibpaste.com/uRLuXC ?
[19:13:42] <pcwalton> obk: you need "foo as ~Bar"
[19:13:47] <pcwalton> for now, I plan to remove that necessity
[19:13:53] * obk smacks head
[19:13:56] <obk> Of course.
[19:14:21] <obk> Thanks
[19:15:10] *** Quits: vodik (simon@moz-CBE4BB13.cable.teksavvy.com) (Ping timeout)
[19:15:22] *** Joins: vodik (simon@moz-CBE4BB13.cable.teksavvy.com)
[19:16:30] <brson> 0.8 is the biggest rust release ever by commits
[19:16:44] <pcwalton> yay!
[19:17:06] <pcwalton> how many?
[19:17:13] <brson> 2100 already
[19:17:15] <pcwalton> nice
[19:18:02] <acrichto> \o/
[19:18:04] <brson> 0.3-0.4 still has slightly more surprisingly, at 2152, but we'll surpass that before 0.8
[19:18:16] <strcat> releases were spread out more, though
[19:18:41] <acrichto> 0.8 has the highest commits/second rate :P
[19:19:07] <kimundi> how high is our cps? :P
[19:19:15] * pcwalton doesn't even remember what 0.3-0.4 lookedl ike
[19:19:17] <sfackler> when's 0.8 releasing?
[19:19:17] <pcwalton> like*
[19:19:20] <brson> somehowe 0.5 only had 907 commits. it must have been over christmas
[19:19:23] *** Joins: santiago (santiago@moz-8ADE82B4.socal.res.rr.com)
[19:19:38] *** Joins: vadimcn (chatzilla@A2267643.76F9E272.DA40C4B3.IP)
[19:19:43] *** Quits: strcat (strcat@moz-54F7FD49.cpe.net.cable.rogers.com) (Quit: WeeChat 0.4.1)
[19:19:55] *** Joins: strcat (strcat@moz-54F7FD49.cpe.net.cable.rogers.com)
[19:23:54] *** Joins: nejucomo_ (Adium@moz-A94CACD5.dsl.pltn13.sbcglobal.net)
[19:24:02] *** Joins: victorporof_ (victorporo@DD69D5EC.67CDC207.79933D60.IP)
[19:24:15] *** Quits: tikue_ (tkuehn@moz-FEADCD38.hsd1.pa.comcast.net) (Quit: tikue_)
[19:24:48] *** Quits: vodik (simon@moz-CBE4BB13.cable.teksavvy.com) (Ping timeout)
[19:25:26] *** Quits: victorporof (victorporo@DD69D5EC.67CDC207.79933D60.IP) (Ping timeout)
[19:25:33] *** Joins: eatkinson (eatkinson@moz-261EDE03.hsd1.ca.comcast.net)
[19:26:56] *** Quits: fhahn (fhahn@moz-7924DB5C.vie.surfer.at) (Ping timeout)
[19:27:20] *** jorendorff_away is now known as jorendorff
[19:28:18] *** Quits: dave1629 (dave@3E11D95A.C422786F.DDE5D3F6.IP) (Quit: dave1629)
[19:29:25] *** Quits: pnkfelix1 (pnkfelix@moz-43495417.fbx.proxad.net) (Quit: Leaving.)
[19:30:26] *** Joins: maxli (maxli@moz-A607CA26.student.cs.uwaterloo.ca)
[19:31:19] *** Quits: anshin (anshin@CD85F10D.F21429E2.354459FA.IP) (Client exited)
[19:31:20] *** Quits: fabiand (fabiand@moz-34EAF1E0.adsl.alicedsl.de) (Quit: Verlassend)
[19:31:26] *** Joins: anshin (anshin@CD85F10D.F21429E2.354459FA.IP)
[19:32:17] *** Joins: hoverbear (andrew@moz-87982B6F.wireless.uvic.ca)
[19:33:43] <kmc> there's no version of Option::get_ref which takes a message like 'expect' does, is there?
[19:33:57] <bblum> expect_ref doesn't exist?
[19:33:59] <bblum> i thought i added it
[19:34:07] <kmc> I don't see it in the master docs
[19:34:14] <kmc> and there's no get_ref_or akin to unwrap_or
[19:34:15] <bblum> well add it
[19:34:23] *** Quits: azita (Azita@moz-BBE3ABD.mv.mozilla.com) (Quit: azita)
[19:34:25] <kmc> maybe I will!
[19:34:58] *** Joins: fhahn (fhahn@moz-7924DB5C.vie.surfer.at)
[19:35:03] <kmc> seems like we need a huge assortment of different Option helpers depending on default vs. fail, message vs none, ref vs. move, mut vs imm, etc
[19:35:06] <benh> maybe we need a meta language for function calls where you just combine tokens like ref, expect, unwrap etc and it synthesizes you just the function you want!
[19:35:40] *** Joins: jaen (jaen@moz-E0979827.copit.pl)
[19:35:42] *** Joins: tikue_ (tkuehn@moz-FEADCD38.hsd1.pa.comcast.net)
[19:35:52] *** Quits: anshin (anshin@CD85F10D.F21429E2.354459FA.IP) (Client exited)
[19:35:58] *** Joins: anshin (anshin@CD85F10D.F21429E2.354459FA.IP)
[19:36:04] <kmc> maybe we need monads, is what.
[19:36:17] <engla> you already can, you choose between  .take().unwrap() and .take_unwrap()
[19:36:47] *** jorendorff is now known as jorendorff_away
[19:37:05] *** Quits: tikue_ (tkuehn@moz-FEADCD38.hsd1.pa.comcast.net) (Quit: tikue_)
[19:37:16] <strcat> what you need to do is split out the conversion to refs from the other methods
[19:37:17] <engla> kmc: monads don't solve the problems of passing by value, by &T or by &mut T, it will be just the same as Option is today
[19:37:18] *** Joins: bellows (Mibbit@moz-98E24999.dyn.plus.net)
[19:37:18] <strcat> and compose them
[19:37:19] *** Quits: hoverbear (andrew@moz-87982B6F.wireless.uvic.ca) (Quit: hoverbear)
[19:37:22] *** Joins: jgilbert (jgilbert@moz-BBE3ABD.mv.mozilla.com)
[19:37:33] <kmc> engla: you're probably right
[19:37:35] <strcat> to_ref for Option<T> -> Option<&T>
[19:37:40] <strcat> and then
[19:37:43] <strcat> to_ref().unwrap()
[19:37:47] <strcat> instead of get()
[19:37:51] <strcat> and just rename unwrap to get()
[19:37:51] *** Quits: fhahn (fhahn@moz-7924DB5C.vie.surfer.at) (Ping timeout)
[19:37:54] <kimundi> kmc: you forgot substitute by value / by function call in that list :P
[19:38:27] *** Joins: fhahn (fhahn@moz-7924DB5C.vie.surfer.at)
[19:38:27] <kimundi> strcat: hmmm! That sounds reasonable...
[19:38:29] <strcat> combinatorial explosions of methods are a good indication you're not using composition right ;p
[19:38:49] <kimundi> Though I pity the on who has to do the unwrap->get rename ...
[19:38:56] <strcat> sounds easy enough
[19:38:58] <kimundi> (expect a 10000 line patch)
[19:39:11] <strcat> more fun than debugging ABI issues
[19:39:38] <engla> I'm used to unwrap, I think that 'get' is a too easy name for something that might fail
[19:39:42] <SiegeLord> unwrap will become get again?
[19:39:58] <strcat> engla: 'get' is what the maps call it
[19:39:59] <sfackler> wasn't unwrap get previously?
[19:40:04] <strcat> and I want to remove it from the maps
[19:40:07] *** Quits: fhahn (fhahn@moz-7924DB5C.vie.surfer.at) (Ping timeout)
[19:40:11] *** Joins: andrew-d_w (andrew-d_w@moz-9A2674DF.dsl.static.sonic.net)
[19:40:13] <strcat> sfackler: don't know but it's terrible right now
[19:40:17] <strcat> too many methods, and they don't compose
[19:40:27] <engla> true
[19:40:28] <sfackler> yeah
[19:40:31] *** Joins: fhahn (fhahn@moz-7924DB5C.vie.surfer.at)
[19:41:06] <kimundi> strcat: don't the maps call that pop?
[19:41:13] <strcat> kimundi: pop returns Option
[19:41:17] <kimundi> ah
[19:41:26] <strcat> and then you can compose that with Option methods
[19:41:30] <engla> pop on an option is .take() or .take_unwrap
[19:41:31] <strcat> as in get_or_default, etc.
[19:41:51] <strcat> I really don't like that we have 'get' on maps as a wrapper around 'find' doing unwrap
[19:42:01] * kimundi is excited
[19:42:19] <strcat> first I have to package two dozen more haskell packages :(
[19:42:24] <kimundi> I never though about just _not_ having _ref and _mut_ref versions of everything :P
[19:42:30] <strcat> pandoc decided to switch json libraries for the nth time
[19:42:32] <engla> A cleanup would be nice, it's just stuck in the comittee
[19:43:34] *** Joins: hoverbear (andrew@moz-87982B6F.wireless.uvic.ca)
[19:44:07] *** Quits: mihneadb (mihneadb@41E65AA5.B2E373EA.FCAAE698.IP) (Input/output error)
[19:44:08] <obk> As long as simplifying APIs to reduce combinatorics - it would be nice is RcMut and RWArc had the same interface. read vs. with_borrow, write vs. with_mut_borrow, etc.
[19:44:18] <kimundi> strcat: In any case, mind writing that down on one of the related issues?
[19:44:27] <obk> Might be a part of the whole Pointer trait addition, when that comes.
[19:44:32] *** Quits: hoverbear (andrew@moz-87982B6F.wireless.uvic.ca) (Quit: hoverbear)
[19:44:37] <strcat> obk: going to kill RcMut, I think
[19:44:54] *** Joins: mihneadb (mihneadb@41E65AA5.B2E373EA.FCAAE698.IP)
[19:44:58] <kimundi> RWArc should get renamed to ArcMut I think
[19:44:59] <strcat> I don't envy whoever is going to replace @/@mut with Gc<T>/Gc<Mut<T>> or whatever happens
[19:45:11] <strcat> kimundi: there are two kinds though
[19:45:18] <strcat> there's RWArc and MutexARC
[19:45:22] <strcat> or whatever they're called
[19:45:25] <kimundi> strcat: One of them mostly unsafe though
[19:45:36] <doomlord__> is that on the cards ? replacing @ with Gc ?
[19:45:49] <kimundi> At least, I had that impression while skimming them
[19:46:02] <kimundi> doomlord__: Not more or less than for the last few months
[19:46:02] *** Joins: GregorR (Gregor@moz-D9651910.so)
[19:46:04] <doomlord__> i would have thought its less pain and reasonable compromise to keep @ as gc and add @Rc
[19:46:12] <strcat> no
[19:46:13] *** Joins: sinma (sinma@moz-6A11C47C.fbx.proxad.net)
[19:46:21] <strcat> features that need the runtime really don't belong in a systems language
[19:46:22] <GregorR> ... first time I join the #rust channel and they're discussing reference counting.
[19:46:24] <GregorR> *kills self*
[19:46:33] <kimundi> doomlord__: I think any development in that direction would start with removing the @ syntax completely
[19:46:36] <obk> @Rc might be called # :-)
[19:46:41] <benh> heh
[19:46:43] <obk> But there are so many kinds...
[19:46:50] <strcat> obk: it's not going to be in the language, guarantee you that
[19:46:53] <kimundi> doomlord__: And then think afterwards about how you'd make that shorter again in a generic fashion
[19:46:54] <strcat> just like hash tables aren't
[19:47:00] <strcat> and arguably vectors shouldn't be - too many kinds
[19:47:10] <sinma> hello! do someone know when the rust creator have began to work on the self-hosted rust compiler?
[19:47:14] <benh> Put everything into the language! I won't rest until I can compile my nethack screenshots as rust programs!
[19:47:27] <obk> Well, if [] was a trait, then hashes, vectors etc. could be just libraries
[19:47:30] <sinma> Iâ€™m writing a news on Rust so I need some history to begin properly :p
[19:47:50] <obk> The tricky part would be the initialization literals
[19:48:01] <sinma> (in french at Linuxfr.org if someoneâ€™s interested)
[19:48:03] <kimundi> GregorR: haha
[19:48:15] <strcat> kimundi: the easy way is just to add an attribute
[19:48:16] <kimundi> GregorR: Anything bad about that? :P
[19:48:20] <engla> obk: the hashmap is completely in libstd. Also index lookup is a trait, and it will be redesigned and remain a trait
[19:48:31] <kimundi> strcat: for what?
[19:48:45] <strcat> #[enable_horrible_deprecated_feature]
[19:48:57] <obk> Right, so the only ways vectors are special is the initializers, I think
[19:49:05] <GregorR> kimundi: Reference counting is like GC, except that it doesn't handle cycles and is slower and for some reason people wrongly think that it's better. And I'm not going to defend that statement because it's a hell of flamewar.
[19:49:20] <strcat> GregorR: it's not slower. they are faster in difference cases
[19:49:29] <obk> GregoR: RC has a big advantage over GC - it works between tasks!
[19:49:29] *** Quits: mihneadb (mihneadb@41E65AA5.B2E373EA.FCAAE698.IP) (Input/output error)
[19:49:34] <obk> (Using ARC)
[19:49:36] <strcat> and our reference counted types don't let you create cycles in the first place
[19:49:41] <kimundi> GregorR: Ah, you're mssing context in that case :P We know about all this (at least the majority here I think)
[19:49:42] <obk> This is really the only reason to use them
[19:49:56] <obk> Otherwise, one might as well use @
[19:49:59] <GregorR> kimundi: It was just a bitter taste for a first line ;)
[19:50:04] <kimundi> GregorR: haha, okay
[19:50:07] <strcat> obk: not the only reason to use them
[19:50:10] <Amaranth> Reference counting has a clear obvious expense
[19:50:15] <doomlord__> i thought rusts current idea of giving convinient syntax for the extremes.. stack,  ~ and @  .. was good
[19:50:51] *** Joins: jensnockert (jensnocker@moz-8BE55278.customer.t3.se)
[19:51:07] <strcat> Gc -> non-deterministic destruction, high overhead in memory (2-3x), collects cycles, high throughput for lots of small objects (when the gc lands)
[19:51:09] <obk> Yes, &, ~ and @ was good. This list just misses # (atomic reference counting, works for sharing data between tasks). &, ~, @ and # seem to cover all the common use cases.
[19:51:12] <Amaranth> doomlord__: But then you have to teach people about Rust's 4 pointers and when/how to use them
[19:51:20] *** Joins: hoverbear (andrew@moz-87982B6F.wireless.uvic.ca)
[19:51:27] <doomlord__> i tend to think peopel complaining abuto taht aren't worth worrying about..
[19:51:33] <obk> But the wind is blowing towards & and ~ and a zillion Foo<T> "smart pointer" types.
[19:51:39] <strcat> Rc -> deterministic destruction, 1-word overhead per allocation, move semantics (great when you have only a few splits in ownership), terrible for lots of small, short-lived objects you copy a lot
[19:51:40] <obk> Not sure I like that, actually.
[19:51:40] <doomlord__> .. there is complexity you can't escape or design around
[19:51:42] <kimundi> GregorR: For what it's worth we try to aim for supporting all flavors of gc and rc equally. And with that I mean, move them to the library
[19:51:44] <strcat> Amaranth: there's nothing to teach
[19:51:55] <strcat> Rc/Gc won't act differently
[19:52:02] <doomlord__> if you dont want different pointer types, you probably want a pure GC language.
[19:52:07] <strcat> Arc will act the same way but will be Send
[19:52:08] *** Quits: jgilbert (jgilbert@moz-BBE3ABD.mv.mozilla.com) (Ping timeout)
[19:52:17] *** Quits: fhahn (fhahn@moz-7924DB5C.vie.surfer.at) (Ping timeout)
[19:52:44] <obk> So there would be Gc, Rc and Arc... at least. And Mut variants of each one. That's 6.
[19:52:50] <strcat> no
[19:52:54] <strcat> no Mut variants
[19:53:00] <kimundi> maybe no mut variants
[19:53:01] <obk> And then there would be the builtin & and ~ and the mut version of each one - that's 4.
[19:53:06] <obk> 10 types altogether. Yey.
[19:53:08] <benh> Why no mut variants?
[19:53:10] <strcat> obk: again, no
[19:53:12] <benh> Cells for everybody?
[19:53:16] <strcat> benh: not Cell
[19:53:21] <strcat> Cell is nullability + interior mutability
[19:53:23] <obk> Well, maybe Rc<Mut<T>> or whatever.
[19:53:30] <strcat> obk: there's no such thing as ~mut
[19:53:32] <obk> But that's still a variant in my book...
[19:53:38] *** Joins: mihneadb (mihneadb@41E65AA5.B2E373EA.FCAAE698.IP)
[19:53:42] *** Quits: eatkinson (eatkinson@moz-261EDE03.hsd1.ca.comcast.net) (Quit: eatkinson)
[19:53:45] <strcat> obk: it's not, Mut will just be a generic dynamic borrowck...
[19:53:48] <obk> Ok, right, no ~mut - only 9 then :-)
[19:53:52] <doomlord__> you're going to have all these variations. its better the compiler knows about them, instead of the programmer having to guess what another programemrs pointers mean in plain C
[19:53:58] *** Joins: fhahn (fhahn@moz-7924DB5C.vie.surfer.at)
[19:53:58] <strcat> obk: and no RcMut, and not GcMut
[19:54:00] <benh> dynamic borrowck is really scary :(
[19:54:12] <doomlord__> and if you beleive GC can do everything , then you dont need rust .. you're not the target audience
[19:54:16] *** Joins: jgilbert (jgilbert@moz-BBE3ABD.mv.mozilla.com)
[19:54:18] <obk> Why no RcMut? No ArcMut either?
[19:54:27] <obk> That's pretty restrictive
[19:54:31] <strcat> no, it's not restrictive
[19:54:36] <strcat> I think you're missing the point
[19:54:38] <doomlord__> i like the fact that @ is a catch all
[19:54:41] <kimundi> obk: People who want to learn the language need to know three things: stack allocation, & and ~, the latter mostly for indirection and vectors/strings
[19:54:43] <nejucomo_> Does dynamic borrow checking enforcement need a mechanism like RC?
[19:54:45] <obk> You mean use Rc<Mut<T>> instead?
[19:54:49] <strcat> composability > hardcoding all the possibilities together
[19:55:00] <kimundi> obk: All other... They can look for and find them in the library if they need them
[19:55:05] <strcat> nejucomo_: rust has static control of mutability, when types are owned
[19:55:18] <sinma> Are there any french who have a good knowledge of Rust?
[19:55:19] <strcat> nejucomo_: if a type has shared ownership and is mutable, you fundamentally need dynamic borrow checking
[19:55:27] <nejucomo_> strcat: I realize this.  I mean &@thing
[19:55:43] <kimundi> nejucomo_: That works other way round
[19:55:50] <obk> strcat: Right!
[19:55:57] <strcat> nejucomo_: shared ownership (Gc, Rc) needs dynamic borrow checking for mutability
[19:55:58] <doomlord__> i suppose for "composability/programability", you'd want a hooks the user can over-ride like operator new:: in c++ and operator overloading for writing smart poitners.. but what about borrow checking / freezing semantics
[19:55:59] <strcat> not the other way
[19:55:59] <obk> But that doesn't mean it isn't useful...
[19:56:06] <nejucomo_> My question was about the implementation of borrow checking for shared pointers.
[19:56:08] <kimundi> nejucomo_: Those cases are statically borrow checked by rooting the value so that it can never cease to exist while the borrow lasts
[19:56:35] <strcat> kimundi: that's actually just a gc implementation detail, though
[19:56:43] <strcat> it's not necessary for Rc
[19:56:53] <strcat> not user-visible anyway
[19:56:55] <nejucomo_> strcat: Everything you've said I am already familiar with.  My question is still unaddressed: Does the implementation of dynamic borrow checking look similar to an RC mechanism?
[19:57:02] <strcat> nejucomo_: no
[19:57:03] <doomlord__> it seemed to me the rust design builds on the experience of other languages and gives convinient syntax for them
[19:57:12] <nejucomo_> Ok.  Thanks.
[19:57:13] <strcat> nejucomo_: it is an enum with 3 states (none, borrow, mut_borrow)
[19:57:18] <strcat> nejucomo_: it's stored in the box next to the count
[19:57:22] <strcat> it could be factored out into Mut
[19:57:25] <kimundi> strcat: Hm, might be. I'm not sure at this point if rroting is something that only makes sense for specific types like gc
[19:57:29] *** nejucomo_ is now known as nejucomo
[19:57:38] <strcat> kimundi: rooting is a gc thing
[19:57:43] <strcat> it's not a language semantics thing
[19:57:48] <doomlord__> ^builds onthe experience of pattern s proven in other languages ... ~ from c++ unique ownership and @ from all the lagnauges that have peopel convinced GC is ok
[19:58:02] <obk> IMO the library approach is a bit too mechanism-driven. If you think about Owned vs. Shared, Specific-to-task vs. Shared-between-tasks, and Mutable vs. Immutable, that's an "intentional" categorization, disregarding the mechanism.
[19:58:30] <obk> & ~ @ # with "mut" cover this gamut pretty nicely
[19:58:42] <strcat> obk: they don't cover it well
[19:58:47] <kimundi> doomlord__: In recent time, the 'convenient' syntax is disappearing in a few places in order to converge to a small stable language
[19:58:50] <obk> Really?
[19:58:54] <strcat> obk: there are many ways to implement inner mutability
[19:59:00] <strcat> Mut is one way to do it, and has proven quite error prone
[19:59:01] <obk> Right!
[19:59:05] <obk> To _implement_!
[19:59:08] <strcat> obk: no
[19:59:12] <strcat> error prone to use
[19:59:20] <kimundi> doomlord__: Less special compiler magic and all that...
[19:59:21] <obk> Ah, you are talking about mutability
[19:59:22] <doomlord__> i hope a decent default emerges for unlabeled '...
[19:59:43] <obk> Well, you want only one task/place in the code to have a mutable access to any piece of memory at any given time
[19:59:55] <obk> How you do that... yes, it requires a design choice
[20:00:03] *** Joins: infynyxx (infynyxx@DB780A29.749BA1D.DCC373F0.IP)
[20:00:08] <obk> But assuming that, you are covered.
[20:00:13] <kimundi> doomlord__: Sorry to disappoint, but that already did exist, and has been decided against
[20:00:34] <strcat> obk: Mut<T> on the entire box contents means there is essentially 1 coarse borrow lock
[20:00:36] <obk> My point is that the library approach takes this intentional-based combinations and then multiply it with "different implementations"
[20:00:41] <strcat> obk: it's not flexible enough
[20:00:52] *** AutomatedTester|away is now known as AutomatedTester
[20:00:53] <doomlord__> that is dissapointing :( i'd hope you could keep the default out and then measure waht the best deafult is from all the 1.0 sourcecode
[20:00:55] <strcat> and Mut<T> isn't always how you want to do it
[20:01:10] <obk> Agreed, but I am worried about stuff like Rc vs. Gc vs. Whatever which are basically "different ways to implement the same thing"
[20:01:19] <strcat> obk: different semantics
[20:01:24] *** Joins: ghrust (ghrust@9C8B94D4.6A2AE50.F3114085.IP)
[20:01:24] <ghrust> 01[13rust01] 15bors merged 06auto into 06master: 02http://git.io/_q-4DQ
[20:01:24] *** Parts: ghrust (ghrust@9C8B94D4.6A2AE50.F3114085.IP) ()
[20:01:25] <strcat> Rc has deterministic destruction and move semantics
[20:01:28] *** Quits: Scriptor (historium@moz-E06F46F0.corp.bitshelter.com) (Quit: Scriptor)
[20:01:29] <kimundi> doomlord__: The rules for lifetimes are the same as for any 'normal' type paramter now: if you use them, you have to declare them on the type. The only exception is if you only accept temporary lifetimes in a funtion, there you can leave it of for convenience:  fn foo(x: &uint)
[20:01:31] <engla> strcat: your Mut<T> idea, is that essentially just like RcMut without the count, or something with more compiler support?
[20:01:32] <strcat> Gc doesn't, but allows cycles
[20:01:43] *** Quits: infynyxx (infynyxx@DB780A29.749BA1D.DCC373F0.IP) (Ping timeout)
[20:01:52] <strcat> engla: Mut<T> would just be { borrow_state, object }
[20:01:55] <strcat> and do what RcMut/@mut do
[20:01:59] <obk> That seems like implementation limitations rather than inherent
[20:02:02] <obk> IMO
[20:02:11] <strcat> engla: so you could have inner mutability on a field, or on a whole object
[20:02:24] <strcat> obk: they are the semantics - deterministic destruction is important
[20:02:25] <obk> Both Gc and Rc are "automatic management of memory for you"
[20:02:25] <engla> strcat: ok got it. So the flexibility comes from being able to use it per field instead
[20:02:30] <strcat> obk: nope
[20:02:33] <strcat> Rc has stack discipline
[20:02:36] <strcat> it's entirely transparent
[20:02:41] <engla> strcat: (not from smarter borrow checking of it)
[20:02:50] <strcat> you are fully in control of Rc
[20:03:00] <strcat> .clone() is a refcount (with a refcount-- at the end of the scope)
[20:03:09] <strcat> by-value is just a move
[20:03:13] <obk> strcat: Yes, but you can do that between tasks as well - that's #
[20:03:27] <kimundi> That would be Arc then
[20:03:28] <obk> Not sure that task-local Rc is worth it.
[20:03:28] *** Quits: jxv (jxv@moz-8FB92450.lightspeed.irvnca.sbcglobal.net) (Ping timeout)
[20:03:28] *** Joins: dave1629 (dave@3E11D95A.C422786F.DDE5D3F6.IP)
[20:03:31] <strcat> don't know what you mean by 'that's #'
[20:03:40] <strcat> obk: atomic refcounting is very slow
[20:03:40] <doomlord__> could cycles be detected at compile time
[20:03:40] <obk> basically Arc
[20:03:47] <strcat> doomlord__: they are
[20:03:50] *** Quits: Kruppe (user@moz-14BD8BF5.net.uwaterloo.ca) (Ping timeout)
[20:04:07] *** Joins: maik (maik@moz-53663244.dip0.t-ipconnect.de)
[20:04:08] <strcat> obk: will it allow weak pointers?
[20:04:09] <obk> But anyway this is academic. Rust seems to be going in the direction of library-provided smart pointers
[20:04:11] <kimundi> strcat: ... by greatly reducing the set of possible types you can put in a rc you mean ;)
[20:04:11] *** Quits: nejucomo (Adium@moz-A94CACD5.dsl.pltn13.sbcglobal.net) (Quit: Leaving.)
[20:04:18] <obk> And then we'll see what works and what people use in practice
[20:04:20] <strcat> obk: allowing weak pointers adds overhead, but is useful
[20:04:26] <strcat> kimundi: sure
[20:04:36] <obk> Yes, weak pointers are another example
[20:04:45] <strcat> kimundi: Freeze isn't a big restriction
[20:04:49] *** Quits: lenstr (lenstr@AF8EB999.6049B16A.85938D85.IP) (Client exited)
[20:04:55] <strcat> 99% of types are Freeze, and it's not very sane when a type isn't
[20:04:56] <kimundi> I wonder if it would be worth to have a seperate StrongRc/WeakRc pair
[20:05:29] <strcat> obk: in practice, atomic refcounting makes them far too slow
[20:05:32] <obk> strcat: How would the library smart pointers manage the fine-grained inner-mut semantics?
[20:05:39] <strcat> obk: they wouldn't need to
[20:05:42] <obk> Seems like quite the challange
[20:05:49] <obk> So how would mutation work?
[20:06:00] <strcat> you use Mut<T> on a field or the whole type
[20:06:11] *** Joins: ghrust (ghrust@F6EE6DE3.6A2AE50.F3114085.IP)
[20:06:11] <ghrust> 01[13rust01] 15bors pushed 0 new commits to 06auto: 02http://git.io/GIHhcw
[20:06:11] *** Parts: ghrust (ghrust@F6EE6DE3.6A2AE50.F3114085.IP) ()
[20:06:20] <benh> ... wasn't internal mutability on a per-field basis a thing that everybody was glad to get rid of?
[20:06:25] <strcat> implemented the same way as extra::rc::RcMut does it, possibly with RAII instead of closures
[20:06:28] <obk> I guess I don;t know exactly what you mean by Mut<T> then...
[20:06:31] <kimundi> struct S { a: Mut<uint>, b: Mut<uint> }  Rc<S> // strcat: like this?
[20:06:42] <strcat> benh: internal mutability still exists, it's called @mut
[20:06:45] <strcat> or RcMut
[20:06:52] <strcat> benh: *statically checked* internal mutability is gone
[20:06:58] <kimundi> strcat: benh means mutable fields
[20:07:06] *** Quits: mihneadb (mihneadb@41E65AA5.B2E373EA.FCAAE698.IP) (Ping timeout)
[20:07:08] <strcat> struct { x: @mut int } is a mutable field
[20:07:16] <kimundi> yeah
[20:07:21] <kimundi> well
[20:07:23] <benh> It's kinda gross imo
[20:07:33] <strcat> now the question is... why are we tying dynamic mutability to boxes?
[20:07:36] <benh> I guess I don't get it
[20:07:37] *** Joins: mihneadb (mihneadb@41E65AA5.B2E373EA.FCAAE698.IP)
[20:07:51] <benh> because (@-)boxes start a new ownership tree or something like that?
[20:08:01] <strcat> benh: yes
[20:08:02] <obk> I guess that it is saying "you are paying the GC overhead, adding the ownership costs on that is easy"
[20:08:03] <strcat> benh: the fact is that people need mutability + shared ownership
[20:08:12] * obk nods
[20:08:17] <strcat> so you need to support it
[20:08:32] *** Quits: jaen (jaen@moz-E0979827.copit.pl) (Quit: WeeChat 0.4.1)
[20:08:33] <strcat> but @mut is not a great way of supporting it, because it's inflexible and too easily error prone
[20:08:41] <strcat> it's not clear that you're going to get dynamic failures
[20:08:58] <strcat> and now you've added the need to support unwinding + tasks to the baseline language too
[20:09:00] <obk> strcat: Isn't that inherent in any shared-and-mutable approach?
[20:09:04] <obk> The dynamic errors?
[20:09:19] <strcat> obk: there are other ways to do it, we used to use purity
[20:09:33] <obk> That throws mutation out the window...
[20:09:40] <strcat> it doesn't
[20:09:46] <obk> purity?
[20:09:48] <obk> How so?
[20:09:55] <strcat> purity doesn't mean "pure like haskell", here
[20:10:02] <obk> Ah, sorry, I assumed.
[20:10:09] <obk> So what does it mean?
[20:10:20] <strcat> a 'pure' annotation on functions could allow you to mutate through &mut/@mut parameters
[20:10:37] <obk> Isn't this what we have today, then?
[20:10:38] <strcat> you would be forbidden from using task-local storage and I/O
[20:10:43] <strcat> obk: nope
[20:11:00] <strcat> anyway the TLS part is probably the important one
[20:11:17] * strcat shrugs
[20:11:24] <strcat> Cell is a different way of doing it than @mut
[20:11:25] <strcat> for one example
[20:11:27] <obk> So, sort of referential transparency?
[20:11:27] *** Joins: ghrust (ghrust@F6EE6DE3.6A2AE50.F3114085.IP)
[20:11:27] <ghrust> 01[13rust01] 15bors pushed 0 new commits to 06auto: 02http://git.io/GIHhcw
[20:11:27] *** Parts: ghrust (ghrust@F6EE6DE3.6A2AE50.F3114085.IP) ()
[20:11:28] *** Joins: ghrust (ghrust@C8693FCB.6A2AE50.F3114085.IP)
[20:11:28] <ghrust> 01[13rust01] 15bors pushed 3 new commits to 06auto: 02http://git.io/cY4F_Q
[20:11:28] <ghrust> 13rust/06auto 145ab843f 15Erick Tryzelaar: std: Remove Option.or_{default,zero}...
[20:11:28] <ghrust> 13rust/06auto 141a90f24 15Erick Tryzelaar: extra: minor cleanup of Zero and Default syntax extension
[20:11:28] <ghrust> 13rust/06auto 147b7186c 15bors: auto merge of #9279 : erickt/rust/master, r=alexcrichton...
[20:11:30] *** Parts: ghrust (ghrust@C8693FCB.6A2AE50.F3114085.IP) ()
[20:11:40] <strcat> obk: yeah, except a very weak form of it
[20:11:57] <strcat> as in if it takes a closure parameter, you could pass a non-pure closure (the type system will know about it - so it's fine)
[20:11:59] <obk> Righ, because you are mutating, so you can really only call it once.
[20:12:36] <strcat> an &mut parameter can be viewed as 1) an input and 2) an output
[20:12:42] <strcat> it's not necessarily impure
[20:12:46] <obk> Right
[20:13:21] <obk> But of course if @ is demoted, this becomes a question - how do library smart pointers participate in this party?
[20:13:26] <benh> I guess what's mostly confusing to me is that immutability isn't transitive so I can mutate a thing inside @mut inside a non-mut thing :(
[20:13:33] <obk> So I guess "purity" isn't the way things will be done?
[20:13:42] <strcat> obk: well in the future, it could be
[20:13:48] <strcat> one way
[20:13:51] <strcat> we may one day have effects
[20:13:57] *** Quits: yeri (yeri@moz-C3D3381.mycingular.net) (Quit: Colloquy for iPhone - http://colloquy.mobi)
[20:14:11] <strcat> and may be able to allow borrows from shared, mutable types in some cases without dynamic checks
[20:14:12] <kimundi> obk: custom smartpointer could register themself to the compiler with special attributes
[20:14:14] * obk isn't clear how a MySmartPointer<T> can interact with a purity system
[20:14:18] *** Joins: nejucomo_ (Adium@moz-434492BB.dsl.static.sonic.net)
[20:14:34] *** Quits: jclements (jclements@moz-3CA4E1EA.static.stls.mo.charter.com) (Quit: jclements)
[20:14:34] <doomlord__> i guess programmable pointers would get interesting with HKT
[20:14:39] <obk> I guess if you give enough "meat" to the Pointer trait....
[20:14:41] <strcat> obk: rust has attributes, you can invent fairly arbitrary language features for libraries
[20:15:03] <obk> Right - it would be non-trivial definition work though
[20:15:04] <strcat> for example, there's #[no_freeze] to make RcMut and Cell memory-safe
[20:15:35] *** Parts: nejucomo_ (Adium@moz-434492BB.dsl.static.sonic.net) ()
[20:15:54] <doomlord__> could you just make @ an overloadable operator
[20:16:06] <strcat> doomlord__: doesn't make sense
[20:16:15] <obk> I guess the choice is between "here are a few built-in pointer types covering >80% of the cases" and "let's define a system allowing you to define any conceivable pointer type to cover 100% of the cases"
[20:16:26] <strcat> doomlord__: @Rc is more painful to type than Rc.... and @ doesn't mean anything useful
[20:16:38] <strcat> obk: the system already exists
[20:16:40] <obk> I'm a bit scared about Rust going in the 2nd direction. Being "opinionated" isn't necessarily bad.
[20:16:46] <doomlord__> there is a nesting thing with typing
[20:16:48] <strcat> you can already define any of these pointers in the stdlib
[20:16:58] <obk> I know. I'm still scared :-)
[20:17:03] <doomlord__> Rc<T<X>>   vs @Rc  T<X>
[20:17:24] <strcat> obk: why would containers belong in the stdlib but not odd variants of shared allocation?
[20:17:28] <obk> C++ started with the ideal that "any built-in could have also be implemented as a library"
[20:17:34] <strcat> the only idiomatic type of ownership is linear
[20:17:35] <obk> It didn't end too well...
[20:17:42] <strcat> obk: that's not true
[20:17:52] <doomlord__> well whatever C++ did at the time there was nothing better
[20:18:01] <doomlord__> C++ is unique in its abilities
[20:18:02] <obk> It certainly drove a lot of C++ design choices
[20:18:18] <strcat> obk: it came later
[20:18:30] <obk> Oh, sure, not in the 1st day
[20:18:31] <strcat> it is easier to standardize a library than a language feature, and it won't break backwards compatibility
[20:18:51] <strcat> and it allows people to use an alternate implementation, if you get it wrong
[20:18:54] <obk> It came in the days people started pouring features into it that, well, ... were "way too much"
[20:19:24] <strcat> features depending on the runtime or a specific type of concurrency are way too much
[20:19:27] <doomlord__> so you want to be able to have programmable smart pointers anyway ? (eg implement handles..)
[20:19:28] *** Joins: jxv (jxv@moz-8FB92450.lightspeed.irvnca.sbcglobal.net)
[20:19:30] <strcat> they can't be supported in every place rust needs to run
[20:19:37] <doomlord__> so you figure @ might aswell be redundant ?
[20:19:42] <obk> There's something to be said for picking a few primitives and squeezing all the value out of them, instead of providing "all" promitives and dying from language feature combinatorics
[20:19:45] <strcat> concurrency is entirely in the libraries.... as are most containers
[20:19:57] <doomlord__> but rust's generic system .. can that currently implement smartpointers
[20:20:09] *** Quits: hoverbear (andrew@moz-87982B6F.wireless.uvic.ca) (Quit: hoverbear)
[20:20:33] <strcat> obk: if someone writes a binding for gtk, they will write a glib smart pointer type
[20:20:33] <obk> Actually I'd argue that's not quite ture.
[20:20:37] <strcat> for their refcounting scheme
[20:20:49] <strcat> there are endless smart pointers that can/will be written
[20:20:58] <obk> You can implement smart pointers if you use unsafe code, which is cheating (going outside the system)
[20:21:07] <strcat> unsafe code is part of rust
[20:21:23] <strcat> you need unsafe code to use a foreign library...
[20:21:33] <Amaranth> It isn't possible to use OpenGL without unsafe code
[20:21:37] <strcat> so it's not cheating to define a smart pointer to encapsulate that foreign library's memory management system
[20:21:40] <cmr> You need unsafe code to do tons of useful things.
[20:21:50] <obk> Well, yes, but any use of unsafe code defeats the core goals of the language... and using it widely (for a commonly used smart pointer type) sounds like a big deal to me
[20:21:54] *** Quits: hjr3 (hradtke@1A0AE795.28A5F6C3.A2D40ED2.IP) (Ping timeout)
[20:21:55] <cmr> You just need to be careful that you obey the invariants.
[20:22:03] <doomlord__> it seems ok to wrap and isolate unsafe code
[20:22:03] <strcat> obk: doesn't make sense as an argument
[20:22:05] <Amaranth> I mean you'd have to wrap OpenGL in something with a different API design to avoid having to have unsafe code in your application that uses GL
[20:22:10] <strcat> obk: code generation is one giant trusted unsafe {} block
[20:22:14] <doomlord__> its like haskell and purity...
[20:22:17] <cmr> obk: I disagree with that.
[20:22:18] <obk> I'm not claiming we need to eliminate unsafe code!
[20:22:31] <strcat> obk: code generation is less safe than 'unsafe {}' code in a library
[20:22:47] <strcat> a small subset of unsafe rust is easier to validate than LLVM IR building
[20:22:56] <obk> Well, that depends on how complex is the language you generate code for
[20:23:11] <strcat> unsafe rust is strictly safer than LLVM IR
[20:23:18] <obk> That's why Haskell has the "core" language and the full language that compiles into it.
[20:23:19] <strcat> even with all the intrinsics
[20:23:26] *** Joins: robertknight (robertknig@moz-54528EE0.wby.mendeley.com)
[20:23:51] *** Joins: dnn (daniel@7F1F8351.F7F04062.79933D60.IP)
[20:23:59] <pcwalton> if we had a typed assembly language then maybe
[20:24:05] <obk> Yes, exactly
[20:24:07] <pcwalton> I think that would require a massive redesign of the language
[20:24:10] <pcwalton> if it's even possible
[20:24:16] <zxcdw> Do it!
[20:24:19] <pcwalton> most typed assembly languages rely on garbage collectors
[20:24:21] <kimundi> He, suddenly a core developer appears :P
[20:24:30] <pcwalton> as far as I know
[20:24:36] <pcwalton> which means that the memory management *still* wouldn't be verified
[20:25:03] <obk> Sure - Haskell (for example) also assumes the GC is "correct"
[20:25:24] *** Joins: hjr3 (hradtke@1A0AE795.28A5F6C3.A2D40ED2.IP)
[20:25:30] <obk> But Rust is doing better by allowing more explicit control, and you can run without GC altogether
[20:25:30] <strcat> haskell implements even more in libraries than we'd ever dream of
[20:25:40] <pcwalton> most of the unsafe code in the libraries is for memory management
[20:25:45] <pcwalton> and for scheduling
[20:25:48] <pcwalton> or FFI
[20:25:54] <pcwalton> as far as I'm aware anyway
[20:26:06] <pcwalton> typed assembly languages usually don't handle those 3 things
[20:26:08] <obk> Yes, I could mention Haskell beside C++ as being scary...
[20:26:10] *** Joins: lenstr (lenstr@AF8EB999.6049B16A.85938D85.IP)
[20:26:11] *** Joins: eagen (eagen@8737942B.7A99C13A.B7961A98.IP)
[20:26:14] <pcwalton> GHC's certainly doesn't...
[20:26:17] <kimundi> And a few cases of transmuting to hide invariants behind types :)
[20:26:23] <pcwalton> those are scarier
[20:26:25] <pcwalton> examples?
[20:26:27] <strcat> kimundi: usually wrong
[20:26:34] <strcat> I'm going to start a purge of most transmutes
[20:26:38] <pcwalton> +1
[20:26:42] <kimundi> strcat: Wrong in what sense?
[20:26:50] *** Joins: hoverbear (andrew@moz-87982B6F.wireless.uvic.ca)
[20:26:51] <strcat> mutating through & or @
[20:26:55] <pcwalton> so if the argument is that we should avoid unsafe code outside of memory management + scheduling + FFI I'm totally in favor
[20:27:00] *** Quits: jxv (jxv@moz-8FB92450.lightspeed.irvnca.sbcglobal.net) (Ping timeout)
[20:27:01] <obk> Well, I have been trying to write some non-linear (or semi-linear) containers, and I found myself having to resort to using "unsafe" stuff
[20:27:05] *** Quits: hoverbear (andrew@moz-87982B6F.wireless.uvic.ca) (Quit: hoverbear)
[20:27:17] <strcat> pcwalton: I temporarily switched Drop to &mut self as a stopgap to kill some already...
[20:27:25] <obk> I did manage to bury most of it under some semi-safe APIs (e.g., the stealing-holes code)
[20:27:28] <kimundi> I'm talking about, eg, Ascii here: transmuting between 'u8' and 'Ascii{ priv data: u8}'
[20:27:38] <strcat> we apparently don't type-check lang items :(
[20:27:46] <cmr> We don't? Yikes!
[20:27:52] <strcat> I guess that'll be fixed as more people use runtimeless rust
[20:27:53] *** Joins: hoverbear (andrew@moz-87982B6F.wireless.uvic.ca)
[20:28:10] <strcat> yeah I was able to change Drop to &mut self with a giant sed across the libraries
[20:28:14] <strcat> no compiler change
[20:28:19] <obk> But at some points, for example, I just gave up and resorted to using @ even though in principle I know it "should" be possible to use just ~ and & - it is just convincing the type system of that is nearly impossible
[20:28:29] <kimundi> strcat: (just for the record, I never meant using transmute to mutate through @ or &)
[20:28:32] <pcwalton> obk: yeah, that's unfortunate. I think that in most cases we should try to either (a) expand linearity to make it easier and (b) make it easier to use automatic memory management
[20:28:36] <pcwalton> i.e. @, or RC
[20:28:42] <pcwalton> yes, that's fine, @ is not evil! :)
[20:28:43] <strcat> kimundi: I think transmute is usually going to be wrong though
[20:28:49] <strcat> you can cast between raw pointer types without it
[20:29:06] <obk> Well, I don't fancy the day I'll need to change all the @s to Gc<T> :-)
[20:29:10] <pcwalton> jonathan shapiro is absolutely right that to get safety sometimes automated memory management is the right choice
[20:29:17] *** Quits: robertknight (robertknig@moz-54528EE0.wby.mendeley.com) (Ping timeout)
[20:29:25] <pcwalton> and it should be supported in an easy to use way
[20:29:28] <kimundi> strcat: How would you cast between Ascii and u8? Between ~[u8] and ~str?
[20:30:07] <strcat> doing either would be viewed as incorrect in C's type system
[20:30:11] <sfackler> strcat: the plan is to eventually have Drop take self by value, right?
[20:30:15] <strcat> sfackler: yes
[20:30:19] *** Quits: Ferio (Mibbit@moz-23CDE542.fullrate.dk) (Quit: http://www.mibbit.com ajax IRC Client)
[20:30:34] <strcat> &mut self is just less bad than &self ;p
[20:30:47] <kimundi> strcat: They are identical in memory, and only are different types to encapsulate invariants about their content. I though this is a good idiom?
[20:30:59] <strcat> kimundi: C forbids that because it has type-based alias analysis
[20:31:02] <sfackler> yep :)
[20:31:17] <strcat> ofc a ~ parameter is already noalias
[20:31:24] *** Joins: donri (donri@moz-9BB61102.tbcn.telia.com)
[20:31:27] <kimundi> strcat: Hm, I don't follow... What's the problem here?
[20:31:31] <strcat> so you aren't breaking the rules by doing it from ~str -> ~[u8] or ~[u8] -> ~str
[20:31:38] <strcat> kimundi: &int can't alias &f64, in C
[20:31:42] <obk> Maybe what is needed is more power in the lifetime mechanism. For example, being able to say 'a < 'b, allowing using something other than 'self in type declarations... that would have probably eliminated most of the problems I saw in my code
[20:31:42] <strcat> if you use transmutes, it can
[20:32:08] <kimundi> strcat: Interesting! Why can't it alias?
[20:32:13] <strcat> kimundi: C forbids it
[20:32:20] <strcat> undefined behaviour to cast between stuff like that
[20:32:29] <kimundi> why?
[20:32:33] <strcat> arbitrarily
[20:32:53] <strcat> that's what type-based alias analysis is, arbitrary rules enforced (or in C's case, not enforced) by the type system
[20:32:54] <kimundi> so, no safety reason to forbid it in rust?
[20:33:06] <strcat> there is a performance reason to forbid it
[20:33:08] <obk> E.g., I found it next to impossible to define a container which owns some objects, and allows them to hold & references to each other. All the objects have the lifetime of the container, so this is actually safe, but trying to convince the compiler... shudder.
[20:33:12] *** Quits: jgilbert (jgilbert@moz-BBE3ABD.mv.mozilla.com) (Connection reset by peer)
[20:33:22] <kimundi> strcat: performance? how?
[20:33:38] <strcat> kimundi: type-based alias analysis is when you tell the compiler about the type system's aliasing guarantees
[20:33:41] *** Joins: jgilbert (jgilbert@moz-BBE3ABD.mv.mozilla.com)
[20:33:46] <strcat> rust has *enforced* aliasing and strong type safety guarantees
[20:34:04] <strcat> if you choose not to tell the type system about it to allow certain unsafe hacks, the whole language pays for it in speed
[20:34:10] <kimundi> strcat: You mean that you can early out disjunct types if you analyse aliasing?
[20:34:27] <obk> In a completely unrelated node - is there anywhere I can find a description on how to generate HTML from the newly merged rustdoc_ng? Running it with --help wasn't very helpful...
[20:34:41] <strcat> obk: it can't, it's a separate program that does it
[20:34:47] <kimundi> strcat: I'm not talking about 'unsafe hacks' in the rust 'unsafe' sense
[20:35:06] <obk> strcat: Ok, how can I find the description on that program then? :-)
[20:35:14] <cmr> obk: rustdoc_ng doesn't generate html
[20:35:19] <cmr> objrustdoc_ng generates json
[20:35:22] <obk> I know, it emits JSON
[20:35:23] *** Joins: azita (Azita@moz-BBE3ABD.mv.mozilla.com)
[20:35:23] *** Quits: maik (maik@moz-53663244.dip0.t-ipconnect.de) (Ping timeout)
[20:35:25] <cmr> Right
[20:35:34] <obk> So what's the program that converts JSON to HTML?
[20:35:35] <cmr> github.com/Seldaek/rustdoc_web
[20:35:45] <strcat> kimundi: all I'm saying is that our type system has enforced guarantees
[20:35:55] <strcat> communicating more guarantees to LLVM -> better performance
[20:35:59] <obk> cmr: Thanks
[20:36:02] <strcat> so breaking the guarantees with unsafe code is not something to take lightly
[20:36:11] <doomlord__> this boils down to "rust not needing __restrict" right ?
[20:36:14] *** Joins: pnkfelix (pnkfelix@moz-43495417.fbx.proxad.net)
[20:36:14] *** ChanServ sets mode: +o pnkfelix
[20:36:19] <kimundi> strcat: Right, And all I'm trying to find out is if this one little specific use case is actually unsafe or not
[20:36:38] <strcat> kimundi: you can assume any transmute may become unsafe in the future
[20:36:55] <cmr> obk: I think it's currently in a state of broken.
[20:36:56] <strcat> every use case of them should be documented somewhere
[20:37:05] *** Quits: jgilbert (jgilbert@moz-BBE3ABD.mv.mozilla.com) (Ping timeout)
[20:37:05] <cmr> obk: something about broken dependencies
[20:37:20] <cmr> obk: all the rustdoc people hang out in #rustdog-wg if you have questions
[20:37:22] <kimundi> strcat: I'd also be fine if it get's replaced with something that is not transmute, but causes the same effect in this case
[20:37:41] *** Joins: jgilbert (jgilbert@moz-BBE3ABD.mv.mozilla.com)
[20:37:49] <strcat> kimundi: all I'm saying is that transmutes are not forwards compatible
[20:37:55] <strcat> transmute == breaking the type system rules
[20:38:00] <obk> rustdoG-wg or rustdoC-wg? Or rustdoC-Ng ?
[20:38:04] <strcat> no guarantee a specific transmute will remain valid in the future
[20:38:05] *** Quits: feduser (feduser@2A51D215.D610364D.799BF54A.IP) (Ping timeout)
[20:38:10] <cmr> Heh
[20:38:13] <kimundi> struct NotU8 { prib data: u8 }; let x: NotU8 = transmute(45u8);
[20:38:14] <cmr> #rustdoc-wg
[20:38:16] <cmr> Sorry :(
[20:38:21] <obk> np, thanks
[20:38:25] <strcat> kimundi: may or may not remain valid in the future
[20:38:36] *** Quits: dnn (daniel@7F1F8351.F7F04062.79933D60.IP) (Quit: Ex-Chat)
[20:38:47] <kimundi> strcat: hm. I see lost oportunites if it becomes impossible
[20:39:01] <strcat> kimundi: well, in that case it's actually by-value
[20:39:04] <strcat> so it's always going to be fine...
[20:39:05] <kimundi> strcat: starting with the fact that ~str no longer becomes safe :P
[20:39:22] <strcat> it's not safe anyway
[20:39:44] <kimundi> "~str is no longer able to become safe"
[20:40:03] <strcat> rusti: let mut xs = ~"foo'; xs[0] = 245; xs
[20:40:04] -rusti- <anon>:9:16: 9:17 error: unknown start of token: ?
[20:40:04] -rusti- <anon>:9     println!("{:?}", r)
[20:40:04] -rusti-                          ^
[20:40:04] -rusti- application terminated with error code 101
[20:40:08] <strcat> kimundi: don't worry about that...
[20:40:18] <kimundi> strcat: I know that there still holes in it, not my point
[20:40:35] <strcat> alright so I don't understand why you are worried
[20:40:44] <strcat> ~str is defined in the rust codebase
[20:40:53] <strcat> backwards compatibility isn't relevant to it
[20:41:01] <strcat> when the languages changes, it changes
[20:41:01] <kimundi> strcat: But I worry about that! Because you basically said "It might be impossible to do that in the future" :P
[20:41:22] <strcat> yes, so if it becomes impossible to do something the rust codebase does, it will be updated to not do it
[20:41:25] <strcat> it's a non-issue
[20:41:35] <kimundi> Just trying to follow the logic here...
[20:41:38] *** Quits: Palmik (palmik@moz-11EA685D.pks.muni.cz) (Quit: Lost terminal)
[20:41:42] *** Quits: robarnold (rob@moz-59F6B5.hfc.comcastbusiness.net) (Ping timeout)
[20:41:44] <strcat> backwards compatibility is a concern for users of rust
[20:41:53] <strcat> not the rust implementation itself
[20:42:24] <kimundi> strcat: ... I'm not sure if I agree there
[20:42:45] *** Quits: valenting (Thunderbir@F8AEB5FE.ECBF5C84.FB866788.IP) (Quit: valenting)
[20:43:03] <strcat> why would the *current* implementation of ~str block changes to the language?
[20:43:12] <kimundi> strcat: Removing useful features because the current implementation does them poorly/unsafely seems backwards to me. Rather fix the implementation, you know?
[20:43:17] *** Joins: tjc (tjc@moz-EC0CD9B.hsd1.ca.comcast.net)
[20:43:17] *** ChanServ sets mode: +o tjc
[20:43:41] <strcat> kimundi: transmute == doing something poorly/unsafely
[20:43:45] <strcat> :s
[20:43:57] <strcat> ~str should be a struct wrapper around ~[u8]
[20:44:42] <strcat> the implementation flaws of the stdlib (not having types defined in libstd) is fixable
[20:44:43] *** Joins: robarnold (rob@moz-59F6B5.hfc.comcastbusiness.net)
[20:44:57] <jdm> transmute is just misunderstood
[20:45:00] *** Quits: tjc (tjc@moz-EC0CD9B.hsd1.ca.comcast.net) (Ping timeout)
[20:45:20] <strcat> we shouldn't have those 200 traits in libstd + the prelude, just to define non-generic methods
[20:45:43] <kimundi> strcat: I'm talking about the general use case of switching the type of an value to another memory compatible type. This doesn't strike me as inherently unsafe, but rather as something that the compiler can be though to do correctly
[20:46:07] <strcat> you're not allowed to do it in C - what does memory compatible mean?
[20:46:23] <benh> if you subscribe to C aliasing rules, the only memory compatible types are signed/unsigned pairs and, like, chars
[20:46:51] <kimundi> strcat: Well that all the issues you talk about do not apply. same size, smae aliasing, mutability behavior etc. just a different nominal type
[20:47:07] <strcat> not the same aliasing
[20:47:32] <benh> same padding?
[20:47:34] <kimundi> wrapping everything into struct field seems uneccessary unreadable if the compiler output ends up the same as making them seperate types
[20:47:37] <benh> /alignment?
[20:47:48] <strcat> kimundi: it won't end up the same
[20:48:14] <strcat> there are already LLVM pointer aliasing rules, btw
[20:48:19] <strcat> many existing transmutes may be invalid
[20:48:20] <kimundi> benh: those too
[20:48:35] <strcat> our closure implementation isn't valid
[20:48:42] <kimundi> strcat: why not? 
[20:48:54] <strcat> because it indexes past the end of an aggregate to memory it knows is there
[20:48:59] <strcat> but the type of the pointer says it isn't
[20:49:03] <strcat> so it's undefined behaviour
[20:49:10] <strcat> (indexes *and* reads - double bad)
[20:49:26] <kimundi> I mean why won't it be the same. Why can't it be taught to be the same?
[20:49:45] <strcat> because turning off LLVM's aliasing rules will make rust much slower
[20:49:55] <strcat> if that's what you're saying...
[20:49:56] <kimundi> I'm not talking about turning them off
[20:50:09] *** Joins: tjc (tjc@moz-7CD7E5B1.tmodns.net)
[20:50:09] *** ChanServ sets mode: +o tjc
[20:50:21] <kimundi> I'm talking about augmenting them such that those cases are still detected
[20:50:30] <strcat> it wouldn't be augmenting them
[20:50:36] *** Quits: Larry (larryfox@moz-343B6F0C.nyc.biz.rr.com) (Quit: My MacBook Pro has gone to sleep. ZZZzzzâ€¦)
[20:50:45] <strcat> I don't think you're understanding why the rules are there, and why they are as strict as they are
[20:50:56] <cmr> kimundi: Are you talking about free conversion between structurally identical types?
[20:50:59] <kimundi> Apparently not, or I wouldn't argue with you :P
[20:51:03] <strcat> they exist so LLVM's optimization passes have something to work from...
[20:51:06] <kimundi> cmr: yes
[20:51:15] <strcat> from a hardware point of view, they are *arbitrary* rules
[20:51:19] <strcat> but they exist for a very good reason
[20:51:28] <strcat> the LLVM devs didn't add all these undefined behaviour rules for fun
[20:51:32] <sinma> Iâ€™ve a question, can a Rust program segfault without using unsafe code?
[20:51:32] <cmr> So struct Foo { a: uint } <-> struct Bar { b: uint } ?
[20:51:38] <strcat> sinma: no
[20:51:44] <cmr> sinma: no, barring compiler bugs
[20:51:50] *** Quits: tjc (tjc@moz-7CD7E5B1.tmodns.net) (Ping timeout)
[20:51:51] <kimundi> sinma: Currently, yes. In the longterm, no
[20:51:53] <strcat> sinma: I added a section about unsafety to the language manual, lemme grab a link
[20:52:04] <strcat> kimundi: currently no, if you ignore compiler bugs
[20:52:06] <kimundi> sinma: Of course, if you hardware/os is fault, all bets are off :P
[20:52:09] <cmr> rusti: let mut x = ~5; x = x; x
[20:52:10] -rusti- application terminated abnormally with signal 11 (Segmentation fault)
[20:52:11] <strcat> in the long term yes, there will always be compiler bugs
[20:52:13] <strcat> :s
[20:52:18] <Eridius> rusti: let x: Option<u8> = from_str_radix("23", 16)
[20:52:18] -rusti- <anon>:8:4: 8:5 error: expected `;` but found `}`
[20:52:18] -rusti- <anon>:8     };
[20:52:18] -rusti-              ^
[20:52:19] -rusti- application terminated with error code 101
[20:52:21] <Eridius> rusti: let x: Option<u8> = from_str_radix("23", 16); x
[20:52:22] -rusti- <anon>:7:29: 7:43 error: unresolved name `from_str_radix`.
[20:52:22] -rusti- <anon>:7          let x: Option<u8> = from_str_radix("23", 16); x
[20:52:22] -rusti-                                       ^~~~~~~~~~~~~~
[20:52:22] -rusti- error: aborting due to previous error
[20:52:24] -rusti- application terminated with error code 101
[20:52:29] <Eridius> rusti: use std::num::FromStrRadix; let x: Option<u8> = from_str_radix("23", 16); x
[20:52:29] -rusti- <anon>:7:57: 7:71 error: unresolved name `from_str_radix`.
[20:52:29] -rusti- <anon>:7          use std::num::FromStrRadix; let x: Option<u8> = from_str_radix("23", 16); x
[20:52:29] <pnkfelix> strcat: (and the current possibility of stack overflow, right?)
[20:52:30] -rusti-                                                                   ^~~~~~~~~~~~~~
[20:52:30] <kimundi> strcat: I'm not ignoring the bugs :P
[20:52:33] -rusti- error: aborting due to previous error
[20:52:35] -rusti- application terminated with error code 101
[20:52:37] <cmr> Eridius: you can query rusti you know :|
[20:52:40] <Eridius> rusti: let x: Option<u8> = std::num::FromSTrRadix::from_str_radix("23", 16); x
[20:52:42] -rusti- pastebinned 11 lines of output: http://sprunge.us/PZOB
[20:52:49] <strcat> pnkfelix: well, that's an implementation flaw - semantically, we have stack safety
[20:52:55] <strcat> (it was implemented before)
[20:53:06] <pnkfelix> strcat: right, I'm well aware
[20:53:22] <pnkfelix> strcat: (I meant to stress "current")
[20:53:22] <strcat> and in theory, LLVM has a 'halting' attribute and doesn't optimize out infinite loops
[20:53:30] <strcat> but... it doesn't yet, and it does optimize out infinite loops
[20:53:33] <strcat> and all the other LLVM bugs
[20:53:57] * strcat shrugs
[20:54:04] <strcat> neither LLVM or rustc will ever be perfect
[20:54:08] *** Joins: valenting (Thunderbir@F8AEB5FE.ECBF5C84.FB866788.IP)
[20:54:15] <benh> mm
[20:54:17] *** Quits: dave1629 (dave@3E11D95A.C422786F.DDE5D3F6.IP) (Quit: dave1629)
[20:54:20] <strcat> so if you want to say compiler bug == non-safe language, rust won't ever be a safe language
[20:55:01] <sinma> haha, first time I saw a segfault on a rust program
[20:55:07] <strcat> sinma: http://static.rust-lang.org/doc/master/rust.html#unsafety
[20:55:31] <benh> if i just pulled from the repository after the new snapshots landed and i can't run the snapshot rustc for lack of libtinfo.so.5, is that a bug or is my setup wrong? :)
[20:55:34] <engla> rusti: std::num::from_str_radix::<int>("fe", 16)
[20:55:35] -rusti- Some(254)
[20:55:41] <sinma> strcat: thx for the link!
[20:56:05] * strcat wrote it yesterday so it still has a new car smell
[20:56:23] *** Quits: jensnockert (jensnocker@moz-8BE55278.customer.t3.se) (Input/output error)
[20:57:16] *** Joins: tikue_ (tkuehn@8FAD7F41.28259105.689607DE.IP)
[20:57:29] *** Joins: Larry (larryfox@moz-343B6F0C.nyc.biz.rr.com)
[20:57:31] *** Joins: Shaladdle_ (anonymous@1C2FA4C8.3B4A6B80.689607DE.IP)
[20:57:35] <engla> I approve of that documentation
[20:58:01] <kimundi> strcat: If you're saying that switching the type of an value during its lifetime is 100% completely unchangeable undefined behavior according to llvm, and changing that would invalidate countless optimization assumptions llvm works with, then so be it.  I just wasn't aware of that.  But please allow me to whine about making newtypes with private content easier to defined :P
[20:58:01] *** Joins: jensnockert (jensnocker@moz-8BE55278.customer.t3.se)
[20:58:13] *** Joins: infynyxx (infynyxx@DB780A29.749BA1D.DCC373F0.IP)
[20:58:27] <strcat> kimundi: it's not undefined behaviour according to the baseline LLVM semantics
[20:58:31] <benh> googling suggests that's a ncurses --with-termlib file, is that a rust dependency now or am i messing up?
[20:58:38] <strcat> but there are very good reasons for making it undefined behaviour via type-based alias analysis
[20:58:54] <strcat> kimundi: http://llvm.org/docs/LangRef.html#pointer-aliasing-rules here are the baseline rules
[20:59:10] <strcat> when you use raw pointers, transmutes, etc. you do have to respect those rules
[20:59:41] *** Joins: Bewilderforce (Bewilderfo@442904D0.6D160A56.18DC1FC6.IP)
[20:59:48] <strcat> and ~ is marked noalias in parameters and return values, so in unsafe code you have to follow the rules that implies (it would be pretty hard not to though)
[21:00:12] <strcat> you could try really hard and make several copies of an ~, pass them to a function but call cast::forget before you got double-frees
[21:00:16] <strcat> and you'd be breaking the aliasing rule
[21:00:34] <strcat> well
[21:00:38] <strcat> you'd also have to mutate it
[21:00:44] *** Quits: sankha93 (Instantbir@7061CD01.D6BD0D91.22D41759.IP) (Quit: Gone to save the world!)
[21:01:16] <strcat> let x = ~5; let y = unsafe_copy_of(x); foo(x, y); fn foo(x: ~int, y: ~int) { *x = 5; forget(y) }
[21:01:28] <strcat> would be legal without noalias annotations
[21:01:34] <strcat> but is now undefined behaviour
[21:03:43] <benh> Sorry to harp on about this but is everybody else compiling master as of the last commit just fine?
[21:03:54] *** Quits: hoverbear (andrew@moz-87982B6F.wireless.uvic.ca) (Quit: hoverbear)
[21:04:11] *** Quits: ksev (DrunkenPan@745B767B.989A61DC.CA5B6332.IP) (Ping timeout)
[21:05:48] <Eridius> benh: yes I just compiled latest master a few minutes ago
[21:06:07] *** Joins: ghrust (ghrust@2EE61FCC.6A2AE50.F3114085.IP)
[21:06:07] <ghrust> 01[13rust01] 15bors 04force-pushed 06auto from 147b7186c to 14d2b0b11: 02http://git.io/N3iJvQ
[21:06:07] *** Parts: ghrust (ghrust@2EE61FCC.6A2AE50.F3114085.IP) ()
[21:06:09] *** Joins: ghrust (ghrust@1E8607E8.6A2AE50.F3114085.IP)
[21:06:09] <ghrust> 01[13rust01] 15bors pushed 2 new commits to 06auto: 02http://git.io/ABC7oA
[21:06:09] <ghrust> 13rust/06auto 14cb7756a 15Alex Crichton: Implement process bindings to libuv...
[21:06:09] <ghrust> 13rust/06auto 147ca38b3 15bors: auto merge of #9260 : alexcrichton/rust/libuv-processes, r=brson...
[21:06:09] *** Parts: ghrust (ghrust@1E8607E8.6A2AE50.F3114085.IP) ()
[21:07:02] <benh> boo, I guess I'm recompiling ncurses then
[21:07:42] *** Quits: obk (Mibbit@56A7885C.6849BFB2.CB858787.IP) (Quit: http://www.mibbit.com ajax IRC Client)
[21:07:52] <sfackler> gst
[21:07:55] <sfackler> oops
[21:08:27] *** Quits: pcwalton (pcwalton@moz-7B0110AD.mv.mozilla.com) (Ping timeout)
[21:09:04] *** Quits: jdm (jdm@FCCEA34F.7672369.D8E68FF6.IP) (Quit: Lost terminal)
[21:10:45] <pnkfelix> nmatsakis: ping
[21:10:51] <strcat> rusti: use std::cast::transmute; unsafe { let x = ~5; let y: *int = transmute(x); let x = transmute(y); y }
[21:10:51] -rusti- <anon>:7:88: 7:104 error: cannot determine a type for this local variable: unconstrained type
[21:10:52] -rusti- <anon>:7          use std::cast::transmute; unsafe { let x = ~5; let y: *int = transmute(x); let x = transmute(y); y }
[21:10:52] -rusti-                                                                                                  ^~~~~~~~~~~~~~~~
[21:10:52] -rusti- error: aborting due to previous error
[21:10:53] -rusti- application terminated with error code 101
[21:11:41] *** Joins: hoverbear (andrew@moz-87982B6F.wireless.uvic.ca)
[21:11:53] *** Quits: Amaranth (travis@moz-F81BB56A.cpe.cableone.net) (Connection reset by peer)
[21:12:09] <kimundi> strcat: Hm, now that I think about it. Is an unsized type like [T] even possible to do safely?
[21:12:27] <strcat> yes
[21:12:44] <strcat> { length, capacity, data[] }*
[21:12:55] <strcat> indexing into data directly is undefined behaviour, afaik
[21:13:00] <strcat> you have to cast it first
[21:13:17] *** Quits: spider-mario (spidermari@moz-81131DB6.fbx.proxad.net) (Input/output error)
[21:13:25] <strcat> because data is zero-length
[21:13:26] <kimundi> strcat: So casting is possible?
[21:13:42] <strcat> casting is possible within the rules defined by the language's type-based alias analysis metadata
[21:13:46] *** Joins: Amaranth (travis@moz-F81BB56A.cpe.cableone.net)
[21:14:19] <kimundi> so, if we say *T may allways alias, we'd be good?
[21:14:28] <strcat> no
[21:14:36] <kimundi> though so :p
[21:14:42] <strcat> *T may not always alias, anyway
[21:14:48] <strcat> there are still the basic alias analysis rules
[21:15:18] <kimundi> (I'm assuming *T == *mut T here)
[21:16:58] <strcat> kimundi: the cast itself is always fine... but it doesn't mean you can then treat it as if it was a different object
[21:17:24] <strcat> if you read http://llvm.org/docs/LangRef.html#pointer-aliasing-rules you'll see why
[21:17:29] *** Quits: azita (Azita@moz-BBE3ABD.mv.mozilla.com) (Quit: azita)
[21:17:38] <kimundi> strcat: Could you explain to me which ruling/abstraction would make 'allocate a few bytes of memory' -> 'use them for a fresh ~[u8]' -> 'slice an &[u8] from that' safe? 
[21:17:42] <Eridius> I'm poking around the lexer right now, and in scan_number() it calls `nextch(rdr);` and throws away the return value. But unless I'm missing something obvious, nextch() doesn't actually mutate anything, right? It seems like that call is completely pointless
[21:17:44] *** Quits: lmandel (lmandel@13F2CEC5.7672369.D8E68FF6.IP) (Quit: lmandel)
[21:17:46] * kimundi reads
[21:17:57] *** Quits: Larry (larryfox@moz-343B6F0C.nyc.biz.rr.com) (Quit: My MacBook Pro has gone to sleep. ZZZzzzâ€¦)
[21:18:01] <strcat> kimundi: slicing is done with getelementptr
[21:18:04] <strcat> A pointer value formed from a getelementptr operation is based on the first operand of the getelementptr.
[21:18:09] <strcat> based on == allowed to alias
[21:18:10] *** Joins: eatkinson (eatkinson@moz-261EDE03.hsd1.ca.comcast.net)
[21:19:03] *** Joins: azita (Azita@moz-BBE3ABD.mv.mozilla.com)
[21:19:19] *** Quits: hjr3 (hradtke@1A0AE795.28A5F6C3.A2D40ED2.IP) (Quit: My MacBook has gone to sleep. ZZZzzzâ€¦)
[21:20:16] *** Quits: hoverbear (andrew@moz-87982B6F.wireless.uvic.ca) (Quit: hoverbear)
[21:20:25] *** Quits: aeqwa (aeqwa@moz-A1C312ED.dsl.tropolys.de) (Quit: Lost terminal)
[21:20:47] <strcat> kimundi: but the language can define type-based rules on top of these
[21:21:04] <strcat> these rules only exist to allow optimizations, there is no other reason
[21:21:11] *** Joins: hjr3 (hradtke@1A0AE795.28A5F6C3.A2D40ED2.IP)
[21:21:37] <strcat> without the rules, LLVM couldn't do very many optimizations
[21:21:44] <strcat> no loop vectorization, that's for sure
[21:22:00] <kimundi> strcat: like allowing you to early out different ~ allocations, or different types based on the assumption that once created, you can never change the type of an value, right?
[21:22:19] *** Quits: bellows (Mibbit@moz-98E24999.dyn.plus.net) (Quit: http://www.mibbit.com ajax IRC Client)
[21:22:53] <strcat> by telling LLVM ~ parameters are noalias, it knows a store to other parameters does not alter them and a store to them does not alter other parameters
[21:23:18] <strcat> and that's a lot of the information it needs to do most of the optimization passes
[21:23:35] <kimundi> right
[21:23:57] <brson> Eridius: it looks pointless to me
[21:24:11] *** Joins: Larry (larryfox@moz-343B6F0C.nyc.biz.rr.com)
[21:24:15] *** Joins: pcwalton (pcwalton@moz-7B0110AD.mv.mozilla.com)
[21:24:15] *** ChanServ sets mode: +ao pcwalton pcwalton
[21:24:23] *** Quits: msingle (Thunderbir@moz-930E5D97.hr.hr.cox.net) (Quit: msingle)
[21:24:30] <Eridius> brson: thanks for verifying that I'm not insane
[21:24:47] * Eridius is adding integral suffixes to char literals, so you can say 'a'u8
[21:24:55] <strcat> kimundi: if it has *a, *b and *c and you store 5 to *b, it has to assume *a and *c have changed
[21:25:12] <pnkfelix> brson: Eridius: I would have guessed its moving the cursor forward, over a character it had just peeked?  Is this not correct?
[21:25:19] <Eridius> pnkfelix: that's what bump() does
[21:25:21] <strcat> if your type-based alias analysis says *a is int, *b is char and *c is f64 and none may alias - then it knows that store could not alter the others
[21:25:32] <Eridius> pnkfelix: nextch() is apparently an explicit peek at the next character after rdr.curr
[21:25:33] <pnkfelix> Eridius: ah good point
[21:25:39] <strcat> it's pretty much the single biggest thing a frontend can communicate
[21:25:48] <Eridius> it's given a @mut StringReader instead of a &StringReader for no good reason though
[21:26:05] <benh> I assume the no good reason is that it predates &StringReaders
[21:26:09] <Eridius> ah
[21:26:13] <benh> (just a guess)
[21:26:53] *** Quits: Shaladdle_ (anonymous@1C2FA4C8.3B4A6B80.689607DE.IP) (Ping timeout)
[21:26:59] <benh> Speaking of the lexer, anyone want to review https://github.com/mozilla/rust/pull/9298 ? ;)
[21:27:10] <kimundi> strcat: Okay, so disallowing type casts allows you to assume that pointers to different types can never alias, and such allows a lot of optimization you couldn't get otherwise.
[21:27:19] *** Joins: Shaladdle_ (anonymous@1C2FA4C8.3B4A6B80.689607DE.IP)
[21:27:28] <strcat> kimundi: yes
[21:27:28] <Eridius> benh: I was just considering how to do exactly that yesterday ;)
[21:27:34] <strcat> kimundi: pointer casts though
[21:27:39] <strcat> type casts are under different rules
[21:28:11] <Eridius> benh: rdr.last_pos is the position of rdr.curr, right?
[21:28:12] <strcat> if by 'cast' you mean transmuting value types, that's usually always fine
[21:28:14] <kimundi> strcat: But they would result in the same inability to say *char never alieases *u32, right?
[21:28:21] <benh> Eridius: yeah, at least so says the comment over it
[21:28:33] *** Quits: pcwalton (pcwalton@moz-7B0110AD.mv.mozilla.com) (Ping timeout)
[21:28:33] <Eridius> benh: does the 'hi' value of a Span point to the last char of the span, or last+1 as normal slices do?
[21:28:57] <kmc> hm if i do  s.map_default(~"", |x| x.clone())  that will heap-allocate an empty string on every call, right?
[21:29:00] <kmc> so I should pattern-match instead?
[21:29:13] <kimundi> strcat: Ah, wait I get what you're saying. You can only end up with aliasing pointers to different types if they start of as the same pointer to the same type
[21:29:34] <strcat> kimundi: yeah, value casts alone can't cause a problem
[21:29:46] <strcat> because they make new value
[21:29:49] <strcat> s
[21:29:56] <benh> Eridius: tbh I just fiddled with plus/minus 1 until I got the right values ;)
[21:30:10] <kimundi> If I transmute char to u32, I can't do that in place, so any pointer at the original location would still have the type of the original location
[21:30:16] <benh> The one bit of code that got the spans right is... hang on
[21:30:44] <Eridius> benh: I see the span created at the end of next_token_inner goes from rdr.last_pos to rdr.pos, but that is supposed to point to the unrecognized char, which is rdr.curr, so I'm not sure that span is even correct :/
[21:30:45] <benh> https://github.com/mozilla/rust/blob/master/src/libsyntax/parse/lexer.rs#L789
[21:30:51] * kmc mumbles something about laziness providing more composable APIs
[21:30:57] <Eridius> yeah that's the span I'm talking about
[21:31:15] <benh> the bit in next_token_inner is only good for the error messages that the parser (not the lexer) wants to spit out about the last token
[21:31:31] <benh> it's no good for errors in the lexer because it's only setting the span after all the lexing for that token is done
[21:31:36] <Eridius> rusti: â€“
[21:31:36] -rusti- <anon>:7:9: 7:9 error: unknown start of token: \u2013
[21:31:37] -rusti- <anon>:7          â€“
[21:31:37] -rusti-                   ^
[21:31:37] -rusti- application terminated with error code 101
[21:31:56] <strcat> kmc: we can provide more composable APIs without laziness or monads
[21:32:00] <strcat> see std::iter
[21:32:10] <kimundi> strcat: So, purely hypothetical, would an 'transmute_value' that bails out if it detects any pointer indirection in the type be able to be declared safe? Wouldn't that useful of course.
[21:32:24] <benh> Since the block I linked uses rdr.pos, which is the pos of the next char to be read, I assume it's an exclusive range
[21:32:35] *** Quits: Blub\w (wry@7E3BB9D.71150E1A.237AE2BA.IP) (Quit: night)
[21:32:37] <Eridius> benh: anyway, that peek_span you pointed to goes from last_pos to pos. That suggests that it's a [lo,hi) range
[21:32:40] <strcat> kmc: we just don't do it and seem to prefer making a new method as a new use case appears ;p
[21:32:47] <benh> though I think zero-sized ranges work fine there anyway
[21:32:47] <Eridius> benh: but your fatal_curr does mk_sp(rdr.last_pos, rdr.last_pos)
[21:32:49] <engla> kmc: there is  None.or_else(|| Some(~"")).map( ...  if you'd hate to use match :-)
[21:32:51] <benh> yeah...
[21:32:57] <Eridius> benh: which suggests you should use mk_sp(rdr.last_pos, rdr.pos), no?
[21:32:59] <strcat> kimundi: well it wouldn't be *saf*
[21:33:02] <strcat> safe
[21:33:05] <jeaye> strcat: Everything alright with your nightly build server for Arch?
[21:33:12] <jeaye> I'm getting < 10KB/s
[21:33:13] *** Quits: Bewilderforce (Bewilderfo@442904D0.6D160A56.18DC1FC6.IP) (Client exited)
[21:33:21] <strcat> jeaye: well, it's the arch build server
[21:33:32] <strcat> so someone is probably uploading a new kde or something...
[21:33:37] <kimundi> strcat: Okay, why not? You said by value casts would be fine. What am I missing this time ;)
[21:33:42] <jeaye> heh
[21:33:44] <Eridius> benh: I'm also suspicious of your other uses of .last_pos assuming it really is [lo,hi). By that interpretation, fatal_from() isn't going to include rdr.curr in the span
[21:34:02] <strcat> jeaye: turn on UseDelta in pacman.conf ;p
[21:34:09] <strcat> makes it about 50% smaller
[21:34:14] <jeaye> Ohh
[21:34:28] <strcat> it takes a while to generate the pkg from the delta, ofc
[21:34:32] <kimundi> strcat: I thought the rust package doesn't delta good?
[21:34:42] <strcat> kimundi: it doesn't, but it's still 10MiB vs 20MiB
[21:34:49] <kimundi> hm, true
[21:34:54] <kimundi> rusti: '\0'
[21:34:55] -rusti- <anon>:6:12: 6:13 error: unknown character escape: 48
[21:34:55] -rusti- <anon>:6     let r = {
[21:34:55] -rusti-                      ^
[21:34:55] -rusti- application terminated with error code 101
[21:35:04] <kimundi> rusti: "\0"
[21:35:05] -rusti- <anon>:6:12: 6:13 error: unknown string escape: 48
[21:35:05] -rusti- <anon>:6     let r = {
[21:35:05] -rusti-                      ^
[21:35:05] -rusti- application terminated with error code 101
[21:35:21] <kimundi> hm, still no new build
[21:35:59] <kimundi> Ah right, r? anyone? https://github.com/mozilla/rust/pull/9267
[21:36:14] <Eridius> kimundi: "methodyfied"
[21:36:29] <strcat> kimundi: it's building LLVM for x86_64 atm
[21:36:37] <Eridius> kimundi: surely you could use the simpler "methodify", which has the benefit of being in the present tense :P
[21:36:52] <strcat> it has to build LLVM every day unless I made a separate rust-llvm pkg
[21:37:27] <strcat> (and that'd be weird)
[21:37:39] <kimundi> Eridius: :P 
[21:37:54] *** Quits: Shaladdle_ (anonymous@1C2FA4C8.3B4A6B80.689607DE.IP) (Quit: Shaladdle_)
[21:38:18] *** Joins: pcwalton (pcwalton@moz-7B0110AD.mv.mozilla.com)
[21:38:18] *** ChanServ sets mode: +ao pcwalton pcwalton
[21:38:31] *** Quits: heftig (heftig@moz-61654AE9.dip0.t-ipconnect.de) (Ping timeout)
[21:38:37] <Eridius> kimundi: is <fail_str> some sort of standard docstring syntax I haven't seen before?
[21:39:12] <benh> Eridius: Yeah, I think I kind of worked backwards in that I inserted the calls to my functions and then adjusted the indexes until they marked the right thing. But I suppose that only works because all the callers already bump() before error checking.
[21:39:27] <kimundi> Eridius: It's what was there before. I didn't really have time to update the content of the docs...
[21:39:38] <kimundi> Just modernized them to use ///
[21:39:44] <Eridius> benh: yeah, trying to handle callers that bump() and callers that don't seems like a potential problematic issue. May need separate fatals for each
[21:40:09] <benh> In a few cases I looked at moving the bumps further down, but that was usually tricky because more characters got consumed inbetween :(
[21:40:50] <kimundi> Okay, any other major grammar failures in anything I touched there?
[21:41:21] * kimundi is fully aware and embarrassed about his current state of affairs in that regard
[21:41:31] <luisbg> wow! it is hard to find a bug marked as "easy" in github that isn't already taken care of
[21:41:40] <luisbg> and by hard, I mean, I haven't found any in 30 minutes :P
[21:41:51] <luisbg> the community is too active hahaha
[21:41:59] <Eridius> kimundi: you're slightly inconsistent with using periods on the end of the first line of a docstring, but I'm not really sure which is more common in the codebase at this point anyway
[21:42:06] <luisbg> (in Rust's github I mean: https://github.com/mozilla/rust/issues?direction=desc&labels=E-easy&page=1&sort=created&state=open )
[21:42:38] <benh> Eridius: Do you feel like the function names are misleading as I have them?
[21:42:41] *** Joins: heftig (heftig@moz-5D7BB4C1.dip0.t-ipconnect.de)
[21:42:49] <benh> maybe it's better to make every caller pass an explicit span
[21:42:56] <benh> instead of looking at the rdr state
[21:42:58] <kimundi> Eridius: Yeah, that's one of the things I noticed myself and thought "why bother fixing here if it's inconsistent everywhere"
[21:43:06] <Eridius> benh: my inclination is to say that unless the function specifies otherwise, rdr.curr should be part of the span
[21:43:07] <kimundi> Eridius: But while I'm add it...
[21:43:38] <Eridius> benh: so you should have a fatal_from_to() that lets the caller specify an explicit end, in case they want to record the pos before bumping
[21:43:56] <Eridius> benh: I'm also a bit concerned about fatal_last(). Subtracting 1 from the BytePos may point to the middle of a multi-byte char
[21:44:02] *** Quits: tikue_ (tkuehn@8FAD7F41.28259105.689607DE.IP) (Quit: tikue_)
[21:44:19] *** Joins: amatus (amatus@moz-12C8D317.g-cipher.net)
[21:44:29] <Eridius> kimundi: I find "opt_maybe_str" to be amusing, as opt is sometimes used as a suffix to indicate an Option ;)
[21:44:32] <Eridius> opt_str_opt!
[21:44:37] <Eridius> (don't do that)
[21:45:10] <amatus> how much work would it be to get rust code running on a raspberry pi?
[21:45:50] <Eridius> kimundi: is there any benefit to keeping around the failing methods, e.g. opt_str and opts_str, instead of just always returning an Option?
[21:45:59] <Eridius> fail!() is a pretty ugly failure for user input
[21:46:24] * Eridius would rather see callers say .opt_str("opt").expect("expected option --opt")
[21:46:33] <kimundi> Eridius: Yeah, I didn't bother reviewing the names either, mainly because that would mean actually understanding what they all do. xD Not very self documenting. I really only turned functions to methods an /** */ to /// here
[21:46:46] <Luqman> brson: r? https://github.com/mozilla/rust/pull/9301
[21:46:51] <benh> Eridius: ahh, that's true. I was under the impression that bump() was operating in terms of bytes because the language syntax is all ascii, but at least in character literals that's just wrong
[21:47:08] <Eridius> benh: language syntax isn't necessarily ascii
[21:47:15] <Eridius> rusti: let fÃ¶Ã¶ = 3; fÃ¶Ã¶
[21:47:16] -rusti- 3
[21:47:35] <kimundi> rusti: let ÃŸ = 34; ?
[21:47:35] -rusti- <anon>:7:20: 7:21 error: unknown start of token: ?
[21:47:35] -rusti- <anon>:7          let ÃŸ = 34; ?
[21:47:35] -rusti-                              ^
[21:47:35] -rusti- application terminated with error code 101
[21:47:36] <Eridius> I mean, operators and such are, but identifiers (and string values, and char literals, etc) may be non-ascii
[21:47:38] <kimundi> rusti: let ÃŸ = 34; ÃŸ
[21:47:39] -rusti- 34
[21:47:41] *** Quits: dherman (dherman@moz-BDCCF091.hfc.comcastbusiness.net) (Quit: dherman)
[21:48:06] <benh> Yeah, I mean I don't think any fatal errors happen right after an identifier so I assumed I was okay there
[21:48:09] <Eridius> "Create an option that is optional and takes an optional argument"
[21:48:35] <kimundi> Eridius: :?
[21:48:51] <Eridius> benh: char literal. 'Ã¶ without a terminating '. the fatal there happens when it says rdr.curr is not '\''
[21:49:02] <benh> yep
[21:49:41] *** Quits: hjr3 (hradtke@1A0AE795.28A5F6C3.A2D40ED2.IP) (Quit: My MacBook has gone to sleep. ZZZzzzâ€¦)
[21:49:52] <Eridius> kimundi: line 338. docstring says `fail_` enum but it's called `Fail_`
[21:50:30] <kimundi> Eridius: Already corrected that just now ;)
[21:50:46] <Eridius> kimundi: docstring at 362 is capitalized wrong as well for Ok/Err
[21:51:19] *** Joins: gareth0 (gareth0@7C428FA9.3FD5F917.1A294DCF.IP)
[21:51:25] *** Quits: azita (Azita@moz-BBE3ABD.mv.mozilla.com) (Quit: azita)
[21:51:45] *** Quits: brendan (brendaneic@moz-BDCCF091.hfc.comcastbusiness.net) (Quit: brendan)
[21:53:00] *** Joins: gavinb (gavinb@3FB76255.8E933811.3DEFE92B.IP)
[21:53:01] *** Joins: azita (Azita@moz-BBE3ABD.mv.mozilla.com)
[21:53:09] <Eridius> kimundi: ok, besides what I've already mentioned, I don't see anything else obviously wrong, though I didn't do an exhaustive read
[21:53:21] <Eridius> at least, within getopts.rs. I didn't bother looking anywhere else
[21:53:40] *** Quits: sinma (sinma@moz-6A11C47C.fbx.proxad.net) (Quit: Konversation terminated!)
[21:53:53] <kimundi> The remaining diff is just mechanical function -> method changes anyway
[21:54:16] <kimundi> Eridius: Hm, the module docs are wrong nwo of course...
[21:54:27] <kimundi> We really need a way to test those
[21:54:49] *** Quits: nsf (nsf@moz-EEF3238A.convex.ru) (Quit: WeeChat 0.4.1)
[21:54:59] <gavinb> Anyone here looking after the web server? I just did a Google search for some Rust info, got doc.rust-lang.org/doc/tutorial.htmlâ€Ž as the first hit. That redirected to http://static.rust-lang.org/doc/tutorial.html which gives an "access denied" error (in XML!).
[21:55:09] <Eridius> kimundi: is allow(missing_doc) still necessary, or did you not add docstrings to everything?
[21:55:21] <strcat> gavinb: the url is http://static.rust-lang.org/doc/master/tutorial.html
[21:55:42] <Eridius> whomever controls the webserver should probably put a redirect in for things like that
[21:55:57] *** Joins: ghrust (ghrust@9C8B94D4.6A2AE50.F3114085.IP)
[21:55:57] <ghrust> 01[13rust01] 15bors 04force-pushed 06auto from 147ca38b3 to 14d2b0b11: 02http://git.io/N3iJvQ
[21:55:57] *** Parts: ghrust (ghrust@9C8B94D4.6A2AE50.F3114085.IP) ()
[21:55:58] *** Joins: ghrust (ghrust@F6EE6DE3.6A2AE50.F3114085.IP)
[21:55:58] <ghrust> 01[13rust01] 15bors pushed 2 new commits to 06auto: 02http://git.io/D2YmqA
[21:55:58] <ghrust> 13rust/06auto 14f30a6fb 15Alex Crichton: Remove rust_run_program.cpp...
[21:55:58] <ghrust> 13rust/06auto 14ffd9c20 15bors: auto merge of #9280 : alexcrichton/rust/less-c++, r=brson...
[21:55:58] *** Parts: ghrust (ghrust@F6EE6DE3.6A2AE50.F3114085.IP) ()
[21:56:10] <gavinb> strcat: yup, but Google's index isn't pointing there. :/ And I just tried http://www.rust-lang.org/doc/tutorial.html which gives a Varnish 503 error.
[21:56:33] <strcat> all I can tell you is that the old stray documentation was removed
[21:56:40] <strcat> intentionally
[21:56:58] <kimundi> Eridius: Still docstrings missing, and I didn't want to document every field of a module that needs some more rewrites anyway... But I'm already way to deep in this, might as well go the whole way now.
[21:57:16] <strcat> when std::iterator was renamed to std::iter, it left behind an iterator.html page
[21:57:16] <Eridius> ok
[21:57:27] <strcat> now the pages are removed
[21:57:34] <gavinb> cool, just thought I'd let someone know. Maybe the Google webmaster tools could help here, with a sitemap etc
[21:58:10] <strcat> redirecting would mean someone manually tracking module renames + adding/removing redirects, so it's just all going to be automatic from now on
[21:58:31] <strcat> (there's not really a way to know if there was a rename or a new file introduced)
[21:58:39] <Eridius> strcat: at least redirecting for intentional structural changes, like doc/tutorial.html -> doc/master/tutorial.html, would be sensible
[21:58:44] <Eridius> module renames are less important
[21:59:00] <jeaye> A new ICE ticket I created still hasn't even been labeled. Anyone willing to take a look? https://github.com/mozilla/rust/issues/9189
[21:59:28] <Eridius> jeaye: and you're certain you recompiled everything?
[21:59:33] <jeaye> Yes.
[21:59:43] <Eridius> because, as you already referenced, that error has been seen before when linking a library compiled with a different rustc
[21:59:45] <jeaye> Reconfigured and rebuilt.
[22:00:16] <gavinb> So you can't destructure into a mutable let? eg. let mut (x, y, theta) = pose.clone(); fails to compile.
[22:00:21] <jeaye> I can try it on a clean clone.
[22:00:26] <cmr> jeaye: no, don't worry.
[22:00:31] <strcat> gavinb: there are no mutable lets
[22:00:34] <cmr> That's a legitimate bug.
[22:00:42] <jeaye> cmr: What causes it?
[22:00:47] <cmr> Caused by nmatsakis' AST renaming, afaik.
[22:00:53] <Luqman> cmr: i updated the crate_map pull
[22:00:56] <cmr> I got it with rustdoc_ng too
[22:00:57] <strcat> gavinb: the 'mut' in 'let mut a = 5' is for 'a', basically
[22:01:04] <cmr> Fixing it involved removing a macro invocation
[22:01:14] <strcat> gavinb: and it's not yet implemented inside patterns
[22:01:16] <strcat> like
[22:01:19] <strcat> let (mut a, b) = (1, 2)
[22:01:22] <jeaye> cmr: Which macro?
[22:01:22] <Eridius> gavinb: eventually you'll be able to say `let (mut x, mut y, theta) = pose.clone()
[22:01:50] <cmr> jeaye: debug!, but I don't think the specifics really mattered.
[22:01:53] *** Joins: tjc (tjc@8E4CD96C.1698A9A3.42E94045.IP)
[22:01:53] *** ChanServ sets mode: +o tjc
[22:02:18] *** Quits: a__ (a__@moz-25043B93.nycmny.fios.verizon.net) (Ping timeout)
[22:02:28] <gavinb> strcat, Eridius: ah, yes, that's exactly what I was trying to doâ€¦ when the above didn't work, I tried a few variations and that was first!
[22:03:09] <gavinb> Ok, well good to know it's going to be supported.
[22:03:42] *** Joins: Shaladdle_ (anonymous@1C2FA4C8.3B4A6B80.689607DE.IP)
[22:03:51] <kimundi> rusti: println!("foo")
[22:03:52] -rusti- foo
[22:03:53] -rusti- ()
[22:04:15] <cmr> dbaupp: heh, multibuilder exploded
[22:04:18] <kimundi> ... ah not yet in snapshot
[22:04:19] <cmr> ran out of disk space :P
[22:04:25] *** Quits: azita (Azita@moz-BBE3ABD.mv.mozilla.com) (Quit: azita)
[22:05:10] <kimundi> Eridius: Which methods did you say would be better to not fail?
[22:05:14] *** Quits: ahal (ahal@13F2CEC5.7672369.D8E68FF6.IP) (Input/output error)
[22:05:29] *** Joins: azita (Azita@moz-BBE3ABD.mv.mozilla.com)
[22:05:47] <Eridius> kimundi: opt_str or opts_str
[22:05:58] *** Joins: ghrust (ghrust@1E8607E8.6A2AE50.F3114085.IP)
[22:05:58] <ghrust> 01[13rust01] 15bors 04force-pushed 06auto from 14ffd9c20 to 14d2b0b11: 02http://git.io/N3iJvQ
[22:05:58] *** Parts: ghrust (ghrust@1E8607E8.6A2AE50.F3114085.IP) ()
[22:05:58] *** Joins: ghrust (ghrust@DE823A67.6A2AE50.F3114085.IP)
[22:05:58] <ghrust> 01[13rust01] 15bors pushed 2 new commits to 06auto: 02http://git.io/ca7Q7w
[22:05:58] <ghrust> 13rust/06auto 14c0cc37b 15Daniel Micay: remove useless `rust_main` wrapper...
[22:05:58] <ghrust> 13rust/06auto 148f65529 15bors: auto merge of #9284 : thestinger/rust/main, r=luqmana...
[22:05:59] *** Parts: ghrust (ghrust@DE823A67.6A2AE50.F3114085.IP) ()
[22:06:15] <Eridius> kimundi: I just don't see the point in providing failing variants. Kill opt_str and rename opt_maybe_str to opt_str, and tweak opts_str to return Option
[22:06:20] *** Quits: lenstr (lenstr@AF8EB999.6049B16A.85938D85.IP) (Client exited)
[22:06:49] <kimundi> Eridius: Okay
[22:07:15] <Eridius> anyone who really doesn't want error handling can slap an .expect() at the end of the method call and get at least a better error message
[22:10:06] *** Quits: Zor (zor@moz-180BED6.rfw.name) (Ping timeout)
[22:10:50] *** Joins: Zor (zor@moz-180BED6.rfw.name)
[22:10:58] *** Joins: a__ (a__@moz-25043B93.nycmny.fios.verizon.net)
[22:11:29] *** Joins: lenstr (lenstr@AF8EB999.6049B16A.85938D85.IP)
[22:12:24] *** Quits: infynyxx (infynyxx@DB780A29.749BA1D.DCC373F0.IP) (Client exited)
[22:12:42] *** Joins: ksev (DrunkenPan@745B767B.989A61DC.CA5B6332.IP)
[22:13:23] *** Quits: anshin (anshin@CD85F10D.F21429E2.354459FA.IP) (Connection reset by peer)
[22:13:37] *** Joins: Azdle (patrick@moz-8C723B60.hsd1.mn.comcast.net)
[22:13:41] *** Quits: lenstr (lenstr@AF8EB999.6049B16A.85938D85.IP) (Client exited)
[22:14:30] *** Quits: ksev (DrunkenPan@745B767B.989A61DC.CA5B6332.IP) (Ping timeout)
[22:17:00] *** Joins: lenstr (lenstr@AF8EB999.6049B16A.85938D85.IP)
[22:17:07] <benh> Eridius: thanks for the review, by the way!
[22:17:29] <Eridius> benh: thanks for taking the time to fix this. I thought last night that someone needed to do it, and now I don't have to think about it anymore ;)
[22:18:15] <sfackler> speaking of reviews, r anyone? https://github.com/mozilla/rust/pull/9285
[22:18:28] *** Quits: gavinb (gavinb@3FB76255.8E933811.3DEFE92B.IP) (Ping timeout)
[22:18:55] <benh> Eridius: I think I'm going to have a single fatal_span(rdr, from, upto, msg) function instead of the prematurely convenient set of functions I had before
[22:19:14] *** Quits: lenstr (lenstr@AF8EB999.6049B16A.85938D85.IP) (Client exited)
[22:19:15] <Eridius> benh: maybe fatal_from_to()?
[22:19:32] <Eridius> benh: having a fatal_from() convenience method seems handy though, because I imagine a lot of errors would just use rdr.pos as the end point
[22:20:48] <kimundi> Hm, What is convention? Struct{ data: value } or Struct { data: value } ?
[22:21:14] <cmr> kimundi: the second
[22:21:30] <Eridius> bah. I like Struct{ data: value } to make it more obvious it's a constructor, but w/e
[22:21:43] *** Joins: quk_sw_ (quksw@moz-CD41E5C8.red.bezeqint.net)
[22:21:51] <benh> I want to say it's mostly rdr.last_pos right now, I'm not sure whether I should try moving all the bumps
[22:22:25] <Eridius> benh: hmm
[22:22:39] *** Quits: quksw_ (quksw@moz-CD41E5C8.red.bezeqint.net) (Ping timeout)
[22:22:45] *** Joins: lenstr (lenstr@AF8EB999.6049B16A.85938D85.IP)
[22:24:11] *** Quits: lenstr (lenstr@AF8EB999.6049B16A.85938D85.IP) (Client exited)
[22:24:33] <Eridius> rusti: 97u as char
[22:24:34] -rusti- <anon>:7:9: 7:20 error: only `u8` can be cast as `char`, not `uint`
[22:24:35] -rusti- <anon>:7          97u as char
[22:24:35] -rusti-                   ^~~~~~~~~~~
[22:24:35] -rusti- error: aborting due to previous error
[22:24:35] -rusti- application terminated with error code 101
[22:24:37] *** Quits: Shaladdle_ (anonymous@1C2FA4C8.3B4A6B80.689607DE.IP) (Ping timeout)
[22:24:37] <Eridius> huh
[22:24:42] <benh> Also bumping the reader past eof is kind of weird
[22:25:25] <Eridius> benh: yeah, although it doesn't actually do anything in that case
[22:25:39] <acrichto> olsonjeffery: file::mkdir raises on the directory already existing?
[22:25:53] *** Joins: Shaladdle_ (anonymous@1C2FA4C8.3B4A6B80.689607DE.IP)
[22:26:12] <benh> Eridius: It's annoying in the "unexpected eof" cases because then rdr.last_pos already points past the end
[22:27:16] *** Quits: Shaladdle_ (anonymous@1C2FA4C8.3B4A6B80.689607DE.IP) (Quit: Shaladdle_)
[22:27:49] *** Joins: anshin (anshin@CD85F10D.F21429E2.354459FA.IP)
[22:33:16] *** Joins: Yeri (jasonjasmi@41C91A8A.CE609BA5.E39FBF79.IP)
[22:33:38] *** Quits: anshin (anshin@CD85F10D.F21429E2.354459FA.IP) (Client exited)
[22:35:49] <olsonjeffery> acrichto: yes... is that an issue?
[22:36:09] <olsonjeffery> we're raising conditions anywhere that uv returns an error
[22:36:18] <acrichto> olsonjeffery: nah, I thought about it and i just need to write better code :P
[22:36:38] <olsonjeffery> acrichto: yeah.. im not jazzed about it (conditions are yucky and clog up the code)
[22:36:57] <kimundi> Eridius: Gwraaa, I knew it! Rewriting the getopts functions to be more sensible turns out to be super annoying
[22:37:11] <olsonjeffery> but its either that or Result<T, U> *everywhere*
[22:37:11] <Eridius> kimundi: :/
[22:37:12] <acrichto> olsonjeffery: I think I'd be more OK with it if the error was more helpful when there wasn't a handler installed
[22:37:19] <acrichto> olsonjeffery: right now it's gdb + backtrace to figure that out
[22:37:27] <Eridius> kimundi: you could just stick with methodification for the moment, and open an issue to actually clean up the API
[22:37:50] <olsonjeffery> acrichto: it should print the contents of the IoError when spews though, right?
[22:37:54] <olsonjeffery> and i think libuv catches/reports that
[22:38:10] <olsonjeffery> if not.. then it's a matter of handling/mapping at the uv->io level..
[22:38:12] *** Quits: jensnockert (jensnocker@moz-8BE55278.customer.t3.se) (Input/output error)
[22:38:20] <kimundi> Eridius: Gonmna do that for the names anyway, but I need to finsh what I started till now :P
[22:38:24] <acrichto> olsonjeffery: yeah and that's really descriptive, but I wasn't sure which of my mkdir calls was causing it, nor which path was at fault
[22:38:35] <acrichto> olsonjeffery: it was also an OtherIoError, but the desc was plenty descriptive
[22:38:42] <acrichto> olsonjeffery: it's mostly just that I need better code :(
[22:39:12] <olsonjeffery> yeah.. my one lament is how spoiled i am, in other languages, with reliable line-number info for failures..
[22:39:30] *** Joins: infynyxx (infynyxx@DB780A29.749BA1D.DCC373F0.IP)
[22:39:33] <olsonjeffery> because gdb is often not-at-all helpful
[22:39:43] <olsonjeffery> although maybe the additional DWARF info will help?
[22:39:44] <acrichto> it's nice to not have to deal with results everywhere, but it's also easy to forget to handle a condition...
[22:39:50] <olsonjeffery> i have yet to reap the benefits..
[22:39:52] <acrichto> symbols are a lot nicer nowadays
[22:40:04] <acrichto> so backtraces are mildly useful
[22:40:59] <olsonjeffery> in conclusion: error handling is a land of contrasts
[22:41:36] <acrichto> yeah :(
[22:42:59] <brson> acrichto: how's the snapshot?
[22:43:05] <brson> acrichto: how's the rustdoc?
[22:43:16] <acrichto> brson: snapshot landed
[22:43:20] <brson> sweet
[22:43:24] *** Quits: azita (Azita@moz-BBE3ABD.mv.mozilla.com) (Quit: azita)
[22:43:25] <acrichto> rustdoc_web being rewritten in rust as we speak
[22:43:29] <brson> we're totally going to get this release out on time
[22:43:38] <acrichto> what's the actual date?
[22:43:42] <brson> *shrug*
[22:43:47] <acrichto> lol
[22:43:53] <acrichto> like this friday?
[22:43:54] <tjc> it's like Muni
[22:43:55] <acrichto> or next week?
[22:43:59] <tjc> if we don't have a schedule, we can never be behind schedule
[22:44:17] *** Joins: Kruppe (user@moz-E150F49F.cpe.net.cable.rogers.com)
[22:44:23] <brson> I think I'm shooting for next thursday. If we don't get it out next week it'll have to wait until after the summit
[22:44:29] <acrichto> oh cool
[22:44:33] <acrichto> ok I have a week to work on rustdoc
[22:44:36] <acrichto> this is going to take awhile
[22:44:37] <benh> acrichto: Is it just me or does the new snapshot's librustllvm.so link against ncurses' libtinfo.so.5, whereas the old one didn't? Is that intended?
[22:44:52] <acrichto> benh: um....
[22:45:05] <acrichto> benh: the snapshot builders ran 'make snap-stage3'
[22:45:08] * acrichto runs away
[22:45:22] <acrichto> are you getting linker errors?
[22:45:27] <benh> I had to recompile my ncurses with --with-tinfo to get the snapshot rustc to run
[22:45:31] *** Joins: dave1629 (dave@moz-17578A1A.hsd1.va.comcast.net)
[22:45:46] <benh> I'm not sure if I was supposed to have it set up like that already
[22:45:48] <acrichto> weird
[22:45:55] *** Quits: Skif (emschwar@moz-CA025D57.ip.mcleodusa.net) (Client exited)
[22:45:55] <acrichto> I don't think the bots changed between this and the last snapshot
[22:46:18] <acrichto> brson: what do you think about changing the syntax of debug! for 0.8
[22:46:29] <acrichto> that'll take a lot of work (and possibly a tree closing) to land most likely
[22:46:35] <acrichto> but rustdoc is likely more compelling
[22:46:41] *** Quits: ceninan (ceninan@moz-6BD43586.a370.priv.bahnhof.se) (Ping timeout)
[22:46:48] <Luqman> brson: i switched the crate map thing to use a weak symbol in libstd
[22:47:14] <acrichto> Luqman: I thought that was pretty slick by the way, nice job :)
[22:47:15] <dbaupp> cmr: well! not much I can do about that
[22:47:24] <acrichto> Luqman: we just define globals in way too many locations :(
[22:47:42] <Luqman> acrichto: haha, well brson has actually previously mentioned the weak symbol thing
[22:47:46] <cmr> dbaupp: yup, just that it was amusing :)
[22:48:07] <dbaupp> cmr: but it worked other than that?
[22:48:13] <cmr> dbaupp: yup!
[22:48:22] <dbaupp> cmr: awesome! (how many builds do you have?)
[22:48:41] <Luqman> acrichto: also, conveniently my earlier link_name pull had landed just in time :P
[22:48:51] <cmr> dbaupp: almost 400
[22:49:02] <cmr> 382
[22:49:03] <dbaupp> cmr: now just need to bench 'em
[22:49:16] <dbaupp> cmr: so I should work on getting rust-grease to work in a nice way?
[22:49:22] <dbaupp> *grease-bench
[22:49:28] <cmr> I think it's not hardlinking properly.
[22:49:39] <dbaupp> "it"?
[22:49:50] <Eridius> r? https://github.com/mozilla/rust/pull/9302
[22:50:16] <brson> Luqman: I saw. thanks
[22:51:02] <brson> acrichto: I don't think we should try to get the fmt! conversion done for 0.8. It's big and might have unexpected fallout
[22:51:04] <dbaupp> cmr: oh, git isn't sharing enough between repos?
[22:51:14] <acrichto> brson: k
[22:51:58] <brson> acrichto: it would be good to give the community time to use format! for a while before including it in a release
[22:52:16] *** Joins: maik (maik@moz-53663244.dip0.t-ipconnect.de)
[22:52:31] <cmr> dbaupp: Dunno, my disk is currently expunging.
[22:52:38] <brson> this tinfo thing in the snaps is worrying. i hope a lot of people don't hit it
[22:52:38] *** Joins: binroot (Mibbit@C065C603.1A99F5FD.DDE5D3F6.IP)
[22:53:01] <binroot> How can I read key input such as arrow keys or Ctrl-C signal?
[22:53:03] <acrichto> brson: cool, we do have debug2! and friends now, along with format_args! so everything should be prepped and ready to go
[22:53:12] <cmr> binroot: we currently don't expose it.
[22:53:17] <cmr> binroot: you need some ioctls.
[22:53:29] <cmr> set the terminal to raw mode
[22:53:50] <binroot> any rust clib to support ioctls?
[22:53:51] <cmr> binroot: So, in short, "the same way you do it in C"
[22:55:02] *** Quits: maik (maik@moz-53663244.dip0.t-ipconnect.de) (Ping timeout)
[22:55:37] <dbaupp> cmr: right
[22:55:41] *** Joins: ghrust (ghrust@9C8B94D4.6A2AE50.F3114085.IP)
[22:55:41] <ghrust> 01[13rust01] 15brson merged 06master into 06dist-snap: 02http://git.io/7InE9A
[22:55:41] *** Parts: ghrust (ghrust@9C8B94D4.6A2AE50.F3114085.IP) ()
[22:56:24] *** Joins: nejucomo (Adium@moz-AC868E2D.hfc.comcastbusiness.net)
[22:56:35] *** Quits: Larry (larryfox@moz-343B6F0C.nyc.biz.rr.com) (Quit: My MacBook Pro has gone to sleep. ZZZzzzâ€¦)
[22:57:03] <brson> anybody want to make sure the man pages are in sync with the current command line options?
[22:57:26] *** Joins: Larry (larryfox@moz-343B6F0C.nyc.biz.rr.com)
[22:57:43] <cmr> brson: I can go through it tonight if noone else volunteers
[22:58:08] <nejucomo> I just glanced at the tutorial, hoping to figure out how to have a "static trait method" which returns an instance of the type parameter.  I tried this: trait T { fn do_stuff(src: K) -> T; â€¦ }
[22:58:10] <nejucomo> Is this possible?
[22:58:19] *** Quits: sw17ch (sw17ch@moz-39D8564F.wndsny.tds.net) (Quit: sw17ch)
[22:58:30] <nejucomo> Oh sorry, the second T was "self" with no sigils.
[22:59:25] <brson> cmr: thanks!
[22:59:33] <nejucomo> Ohâ€¦  I seem to recall I may want "Self" not "self".
[22:59:40] <tjc> nejucomo: yes, it's Self
[22:59:42] <tjc> and then it should work
[22:59:52] <tjc> for example, see std::ptr::RawPtr
[23:00:06] <nejucomo> Nice.  How about this, though:  trait T { fn capacity() -> uint }
[23:00:17] <binroot> How can I include use C's signal.h in rust to capture Ctrl-C?
[23:00:21] <nejucomo> There's no Self anywhere.  Is that possible?
[23:00:26] <tjc> nejucomo: sure
[23:00:36] <tjc> in that case you'd just be using a trait as if it's a module
[23:00:48] <tjc> equivalently in that case, you could write mod T { fn capacity() -> uint }
[23:00:50] <tjc> well
[23:00:57] *** Quits: eatkinson (eatkinson@moz-261EDE03.hsd1.ca.comcast.net) (Quit: eatkinson)
[23:00:57] <tjc> you'd have to define the function, too, in the latter case :-)
[23:00:59] *** Quits: lkuper_ (lkuper@moz-C0CD33ED.hsd1.in.comcast.net) (Quit: lkuper_)
[23:01:01] <tjc> so it's a little different
[23:01:04] <tjc> it's more like a module signature
[23:01:05] <tjc> anyway
[23:01:29] <nejucomo> So then I can have: fn f<S: T>(x: S) -> uint { S::capacity() }  -or what?
[23:01:50] *** Joins: Shaladdle_ (anonymous@1C2FA4C8.3B4A6B80.689607DE.IP)
[23:01:53] <nejucomo> But the capacity is different for different impls, so I don't see how a module could work.
[23:02:09] <engla> nejucomo: that, in particular, is not well supported at the moment (waiting on new syntax)
[23:02:15] <nejucomo> Imagine writing a trait for the ::bits of uint::bits...
[23:02:34] *** Joins: Sorella (queen@9D963F5D.DF5D8AE7.54BCAB54.IP)
[23:02:37] <nejucomo> Hmâ€¦  Is there a standard work-around?
[23:02:38] <engla> nejucomo: there is a trait for that in std::num, it uses a workaround (go and look if you are interested)
[23:02:44] <nejucomo> Thanks.
[23:02:47] <engla> nejucomo: a trait for uint::bits
[23:03:02] <engla> but it's not pretty
[23:03:30] *** Quits: Shaladdle_ (anonymous@1C2FA4C8.3B4A6B80.689607DE.IP) (Ping timeout)
[23:05:02] <nejucomo> Okâ€¦  I see the Primitive definition, now trying to guess the call site syntaxâ€¦  Does this work: { let x: Option<uint> = None ; x.bits() }   ?
[23:05:49] <nejucomo> Are there "inline type annotations" in expressions?  Something like:   (foo()  :  T) ?
[23:06:14] <benh> Is it a known deficiency that spans in errors don't work right with multi-byte characters?
[23:06:18] <nejucomo> In which case the call site might be something like: (None : Option<uint>).bits()
[23:06:38] <cmr> benh: eek, I thought those issues had been fixed.
[23:06:38] * nejucomo experiments...
[23:06:46] <benh> rusti: Ã¤Ã¤Ã¤Ã¤
[23:06:48] -rusti- pastebinned 8 lines of output: http://sprunge.us/eXRH
[23:07:10] *** Quits: q66 (q66@6EE9DE40.46454B5D.33AABD5F.IP) (Quit: Leaving)
[23:07:13] <benh> it only points at the first Ã¤, it doesn't underline the whole identifier like it would with an ascii identifier
[23:07:29] <cmr> Heh, so it's not that the span is being printed wrong, it's that the span isn't created correctly.
[23:07:43] <cmr> You'll notice that it's 7:9: 7:9
[23:07:49] <benh> right
[23:07:59] <nejucomo> rusti: { let x: Option<uint> = None; std::num::Primitive::bits(x) }
[23:08:00] -rusti- 64u
[23:08:07] <benh> I'm having some trouble with my lexing changes where unicode symbols are involved, so I'm trying to figure out how much of these are my fault :)
[23:08:11] <Eridius> rusti: let a = "Ã¼Ã¼Ã¼Ã¼"; let b = "\xff";
[23:08:13] -rusti- pastebinned 7 lines of output: http://sprunge.us/SJCM
[23:08:16] <Eridius> the second error points at the wrong spot too
[23:08:20] <Eridius> so yeah, multibyte chars still throw off spans
[23:08:22] <nejucomo> I'll use that pattern, unless there's a more standard one...
[23:08:50] *** Quits: nejucomo (Adium@moz-AC868E2D.hfc.comcastbusiness.net) (Quit: Leaving.)
[23:09:55] *** Joins: azita (Azita@moz-BBE3ABD.mv.mozilla.com)
[23:10:10] <dbaupp> benh: https://github.com/mozilla/rust/issues/8706
[23:10:21] <benh> oh god i see the problem with my lexer spans, I marked my tests with unicode by putting multibyte characters in the filenames, and those are what threw off the spans :D
[23:10:34] <benh> (at least one way)
[23:10:54] <benh> unicode sure is tricky
[23:11:29] <benh> the numbers in the error messages ought to be in characters, not bytes, right?
[23:11:47] *** Quits: mark_edward (quassel@moz-97E995A.hsd1.in.comcast.net) (Client exited)
[23:11:49] <cmr> benh: correct.
[23:12:10] <tjc> unicode: the hardest problem in computer science
[23:12:21] <cmr> tjc: no, just a subset of the problem.
[23:12:28] <cmr> the hardest problem is dealing with humans.
[23:12:30] <dbaupp> benh: they should be in glyphs (i.e. visible characters), but I'm not sure how they should handle doublewidth characters.
[23:12:40] <tjc> cmr: hmm, that pretty much covers it :-)
[23:12:59] * strcat cleaned his hands of the responsibility of maintaining pandoc
[23:13:14] <strcat> it ended up with like 50 deps :s
[23:13:23] <strcat> why does haskell need 4+ json libraries?
[23:13:26] <Florob>  dbaupp, doublewidth, or fullwidth? :P
[23:13:35] <cmr> strcat: did it get passed off to someone else or is it going to whither?
[23:13:53] <strcat> cmr: well I had to drop it from the repos for now, because I can't deal with the 30 things I would have needed to package
[23:13:58] <strcat> I might add it back later with automation
[23:14:03] * strcat shrugs
[23:14:32] <benh> strcat: I'm surprised there isn't, like, <number of parser combinator libaries> * <number of string types> * <number of people in the iteratees mailing list + 2> json libraries
[23:14:34] <kimundi> benh, cmr: In glyphs? Hmmm. My adhoc refactoring ruby script interprets them as bytes. Do you think there would be an usecase for making rustc optionally emitting spanns as byte offsets
[23:14:48] <strcat> benh: well, that's pretty much the problem :D
[23:14:58] <strcat> and there are dozens of string implementations too
[23:15:28] <strcat> benh: http://hackage.haskell.org/package/yaml-0.8.5 for example, pandoc needs this now
[23:15:47] <dbaupp> Florob: I dunno the jargon :P
[23:15:54] *** Joins: ghrust (ghrust@C8693FCB.6A2AE50.F3114085.IP)
[23:15:54] <ghrust> 01[13rust01] 15bors merged 06auto into 06master: 02http://git.io/ca7Q7w
[23:15:54] *** Parts: ghrust (ghrust@C8693FCB.6A2AE50.F3114085.IP) ()
[23:16:09] <strcat> so you get conduits, text, transformers, aeson (json lib), unordered-containers (one set of hash libs)
[23:16:26] <strcat> and then one of pandoc's other deps pulls in haskell-json, + about 4 implementations of regexp
[23:16:34] <benh> :D
[23:16:49] *** Quits: tjc (tjc@8E4CD96C.1698A9A3.42E94045.IP) (Ping timeout)
[23:17:21] *** Joins: tjc (tjc@8E4CD96C.1698A9A3.42E94045.IP)
[23:17:21] *** ChanServ sets mode: +o tjc
[23:17:44] <strcat> benh: http://hackage.haskell.org/package/pandoc can tell how bad it is from there
[23:17:51] <strcat> each dep explodes to 4 more deps :P
[23:17:56] <dbaupp> Could someone fix my mistakes? https://github.com/mozilla/rust/wiki/Doc-detailed-release-notes#cast-naming-conventions :)
[23:17:57] <benh> I can imagine :(
[23:18:19] <strcat> anyway perhaps there is another implementation of markdown we could use but pandoc's variant is really the best :(
[23:18:31] <benh> Ugh, how do I make debug!() output show up again? I thought it was running the final binary with RUST_LOG=<crate where I say debug!()>=1 set? Do I need to change something inbetween?
[23:18:49] <cmr> benh: --cfg debug
[23:18:49] <strcat> we should just invent our own markup standard, the whole could use more fragmentation ;p
[23:18:50] <pcwalton> whoever changed linenoise completions added @fns :(
[23:18:54] <strcat> then world*
[23:19:00] <strcat> urgh, typing
[23:19:03] <cmr> pcwalton: blame dbaupp!
[23:19:04] <dbaupp> benh: compile with --cfg debug and RUST_LOG=foo=4 or RUST_LOG=foo=debug
[23:19:16] <Eridius> hey pcwalton, I implemented the 'a'u8 from 2 days ago. If you like the syntax, you should weigh in on #4334 ;)
[23:19:16] <dbaupp> pcwalton: I thought they were already there? (sorry! :( )
[23:19:21] <pcwalton> they were there
[23:19:23] *** Joins: ofeldt- (ofeldt@moz-ED5D7E12.dip0.t-ipconnect.de)
[23:19:28] <benh> ah... hm
[23:19:30] <pcwalton> it just bitrotted my patches
[23:19:32] <pcwalton> not your fault
[23:20:22] *** Quits: sigma (sigma@moz-F95C5D1F.range31-54.btcentralplus.com) (Ping timeout)
[23:20:32] *** Quits: joshua_ (joshua@moz-45967CBE.emarhavil.com) (Ping timeout)
[23:20:41] <benh> strcat: I like haskell but I really feel like depending on anything haskell in a project that's not deeply embedded in the haskell ecosystem already is just asking for frustration :(
[23:20:46] *** Quits: ofeldt (ofeldt@moz-32135DD8.dip0.t-ipconnect.de) (Ping timeout)
[23:20:53] *** Joins: ghrust (ghrust@C8693FCB.6A2AE50.F3114085.IP)
[23:20:54] <ghrust> 01[13rust01] 15bors pushed 0 new commits to 06auto: 02http://git.io/DaU_Dw
[23:20:54] *** Parts: ghrust (ghrust@C8693FCB.6A2AE50.F3114085.IP) ()
[23:21:16] <strcat> haskell is a good place to look for how not to create a library ecosystem ;p
[23:21:29] <strcat> so many nice libraries, all duplicating each other with no standard way of doing things...
[23:21:54] <strcat> (I think it's a good argument for putting more in the official stdlib, rather than keeping it lean)
[23:22:37] <doomlord__> can a layering approach (like libstd, libextra) get the best of both 
[23:23:17] <cmr> Well, libextra is part of the official stdlib aiui
[23:23:28] <cmr> including the future extra conglomerate
[23:23:31] <strcat> I think libextra is a temporary thing
[23:23:39] <cmr> but that's secondhand knowledge, ask brson
[23:23:44] <strcat> we're going to either stabilize stuff from it, or kick them out of the rust repo
[23:24:09] <strcat> it definitely makes sense for stuff to *start* as an external library until it matures
[23:24:33] <strcat> (there's no way we can commit to so many APIs)
[23:24:58] <doomlord__> i suppose in C++ land.. its boost that fills that niche
[23:25:40] <strcat> boost doesn't have http, crypto, xml, json, yaml
[23:25:43] <Earnestly> strcat: Which language sports a good example of a library ecosystem?
[23:26:00] <doomlord__> is this just an inherent problem with the universe :)
[23:26:01] <Earnestly> (Even if itâ€™s a combination)
[23:26:35] <doomlord__> can you have cutting edge development *and* standardization..
[23:27:23] *** Joins: anshin (anshin@CD85F10D.F21429E2.354459FA.IP)
[23:27:30] <tjc> doomlord__: well, you can probably have them sequentially :-) concurrently, I don't know about
[23:27:31] *** Quits: donri (donri@moz-9BB61102.tbcn.telia.com) (Client exited)
[23:28:19] *** Quits: Ferreus (daniel@moz-F33CA692.dyn.telefonica.de) (Quit: WeeChat 0.4.1)
[23:28:51] <Luqman> brson: oops, forgot to update some tests, mind r+ again?
[23:30:23] <cmr> I think nodejs has a fairly good library ecosystem.
[23:31:09] <mcpherrin> cmr: npm is pretty good, unfortunately the barrier to entry is too low IMHO -- there's a lot of crap in there
[23:31:16] <mcpherrin> I think CPAN is maybe better
[23:31:20] *** Quits: anshin (anshin@CD85F10D.F21429E2.354459FA.IP) (Quit: leaving)
[23:31:23] *** Quits: Excureo (c@moz-EB93D257.static.knwc.wa.charter.com) (Input/output error)
[23:31:24] *** Joins: nejucomo (Adium@moz-434492BB.dsl.static.sonic.net)
[23:31:27] <doomlord__> i saw someone suggest "a good package manager reduces the need for standard libraries.."
[23:31:42] *** Quits: infynyxx (infynyxx@DB780A29.749BA1D.DCC373F0.IP) (Client exited)
[23:31:55] *** Quits: Florob (Florob@moz-39532932.de) (Client exited)
[23:32:05] <doomlord__> just let them replace eachother organically as better substitutes emerge
[23:32:06] <nejucomo> doomlord__: I would concur.
[23:32:17] <tjc> doomlord__: I don't see how it does. Fewer standards means more decisions, and decisions are tiring
[23:32:33] <doomlord__> standardizing means waiting for someone else to decide :)
[23:32:57] <tjc> well, it means a few people do a lot of work deciding so that everybody else doesn't have to do that work :-)
[23:33:13] <doomlord__> like there's common things in C++11 which you'd have been using for years before.. it seems like the time taken to standardize every detail is  *insane*
[23:33:29] <doomlord__> "forward_list"... "std::array<T,N>"
[23:33:56] <tjc> unfortunately I don't see a workaround for people taking a long time to come to agreement about things they care about :-)
[23:34:01] <doomlord__> the issue is the delay - sometimes duplcate work is necasery to get a result earlier
[23:34:55] <doomlord__> having a duplicate code detector to retroactively standardize might be nice :)
[23:35:15] <doomlord__> write what you need, then replace it with the standard version if a standard version emerges..
[23:35:38] <doomlord__> ( i realize a duplicate code detector might not work 100%)
[23:35:46] <tjc> or at least a warning, like, "Hey, it looks like you're trying to call a standard library function..."
[23:35:53] *** Quits: binroot (Mibbit@C065C603.1A99F5FD.DDE5D3F6.IP) (Quit: http://www.mibbit.com ajax IRC Client)
[23:36:21] <doomlord__> i think a duplicate code-detector would actually make a nice search tool :)
[23:36:40] *** Joins: infynyxx (infynyxx@DB780A29.749BA1D.DCC373F0.IP)
[23:36:49] <tjc> for sure! interesting project. could also be the basis for a plagiarism detector once rust is adopted more widely in education ;-)
[23:37:00] *** Joins: youknowone (youknowone@A826BD81.8A0DEF81.38747683.IP)
[23:37:00] *** Quits: youknowone (youknowone@A826BD81.8A0DEF81.38747683.IP) (Z:lined (Open Proxy found on your host. Please visit www.blitzed.org/proxy?ip=115.68.131.49 for more information.))
[23:38:44] *** Quits: Larry (larryfox@moz-343B6F0C.nyc.biz.rr.com) (Quit: My MacBook Pro has gone to sleep. ZZZzzzâ€¦)
[23:39:14] <doomlord__> does rusts' cleaner syntax make such a thing more possibel than in C++, its one of those things i've heard of in other languages IDE's
[23:39:36] <doomlord__> (am i imagining that, where have i heard of it..)
[23:40:35] *** Joins: sigma (sigma@51C589B3.EF2694B5.DFAC6AA7.IP)
[23:40:53] *** Quits: sigma (sigma@51C589B3.EF2694B5.DFAC6AA7.IP) (Quit: Leaving.)
[23:41:16] <tjc> well, there is a plagiarism detector -- so, basically detecting duplicate code with an extra bag of tricks -- for C/C++
[23:41:24] *** Quits: gareth0 (gareth0@7C428FA9.3FD5F917.1A294DCF.IP) (Input/output error)
[23:41:26] <tjc> so I wouldn't say more *possible*, but possibly less time-consuming
[23:41:37] <strcat> libclang is great for building tooling like that
[23:41:38] <pcwalton> ok, done rebasing
[23:41:41] <pcwalton> took 2 days
[23:41:44] <pcwalton> let's try next one
[23:41:54] *** Quits: maxli (maxli@moz-A607CA26.student.cs.uwaterloo.ca) (Quit: Leaving.)
[23:41:56] <strcat> librustc would need some major restructuring to come close ;P
[23:42:02] *** Joins: maxli (maxli@moz-A607CA26.student.cs.uwaterloo.ca)
[23:42:03] *** Quits: mihneadb (mihneadb@41E65AA5.B2E373EA.FCAAE698.IP) (Input/output error)
[23:42:30] <doomlord__> does this exist: a cloud based tool with a repository of functions, you submit a functino, plus what you'd call it, and it tells you what the hive consensus name for that function is :)
[23:42:42] <nejucomo> I'm using the pattern taken from std::num mentioned earlier to approximate per-type static methods.  I thought I could simplify the call-site API with a generic function, but this doesn't work.  If anyone's curious and could explain why, I'd appreciate that: https://github.com/nejucomo/rust-bitfifo/blob/master/bitfifo.rs#L39
[23:42:51] <nejucomo> (If ppl are busy, I totally understand.)
[23:43:23] *** Joins: joshua_ (joshua@moz-45967CBE.emarhavil.com)
[23:43:54] <Eridius> nejucomo: the call syntax for a generic function is bit_capacity::<T>
[23:44:04] <noct> can rust be built on clang?
[23:44:05] <doomlord__> do you think rust would benefit from another abstraction over the AST, like clang has the stable and internal versions
[23:44:11] <nejucomo> Eridius: Thanks!
[23:44:14] <doomlord__> ^^^ for toolinhg
[23:44:42] <nejucomo> Eridius: It now compiles!  (No unittests for it yet...)
[23:44:50] <Eridius> \o/
[23:44:58] *** Quits: wilmoore (wilmoore@moz-7EE4D9D6.mystrotv.com) (Client exited)
[23:45:08] <cmr> nejucomo: https://github.com/mozilla/rust/blob/master/src/libstd/from_str.rs#L24 as an example of this exact pattern
[23:45:21] <tjc> doomlord__: I think the sentiment on the core team is against adding more intermediate languages to rustc. Having no IL between Rust and LLVM makes error reporting and debugging and such somewhat easier.
[23:46:13] *** Joins: Excureo (c@moz-EB93D257.static.knwc.wa.charter.com)
[23:46:21] *** Quits: ozten (ozten@19BD73A1.5D8BCA3A.A0C1B52F.IP) (Quit: ozten)
[23:46:21] *** jld|tent is now known as jld
[23:46:22] <cmr> nejucomo: although it uses type inference, so nevermind, sorry
[23:46:29] <kimundi> Having an resolved,typchecked graph object that represent an crate would be amazing.
[23:46:39] <nejucomo> cmr: Thanks.  I think that pattern is different, however, because the Self represent a "real" value which can be used by the caller, whereas in this case, there is a dummy value who only exists for its type information.
[23:46:47] <nejucomo> Oh, yeah, you just said that.
[23:47:10] *** jorendorff_away is now known as jorendorff
[23:47:28] * nejucomo ponders a general macro-based codification of this kind of "dummy parameter" pattern...
[23:47:47] <doomlord__> tjc, that was more about somethign between the compiler and external tool rather than a suggestion to change the way the compiler works internally -
[23:48:17] <tjc> doomlord__: Oh, I see what you mean; I was thinking that the compiler would translate source to stable-version to internal-version to target
[23:48:22] <doomlord__> - eg are 'a good AST for external tools' and 'a good AST for the compiler internals' possibly seperate goals
[23:48:32] <cmr> rustdoc_ng suffers through this; almost all of it is taking the AST and exposing a useful structure.
[23:48:40] <tjc> but yeah, I guess it's possible, but I'm not sure we're at the point of wanting to do it; the surface language has to be stable first
[23:48:44] <cmr> (though it's only for items, not exprs)
[23:48:59] <tjc> I have a lot of experience with that sort of thing because I maintained GHC External Core for a while
[23:49:06] <tjc> if we ever do this, it'll be really really important to have regression tests for it
[23:49:08] <tjc> really important
[23:49:58] <pcwalton> I would also like to make sure that compiler performance does not regress
[23:50:05] <pcwalton> we already have problems with compiler performance
[23:50:29] *** Joins: snadon (chatzilla@5C4F0E42.98A48E9F.47C41102.IP)
[23:50:45] <doomlord__> well thats the thing , who knows how much you have to change the AST in the name of compiler performance
[23:51:00] <tjc> well, hopefully not at all
[23:51:11] <tjc> the point of having the external representation is that you have a separate pass that translates internal -> stable
[23:51:28] <tjc> that pass, of course, can get bitrotted easily, hence  the need for regression tests
[23:51:42] <pnkfelix> Question: Is functional struct update (FSU) always supposed to *move* its base?  E.g. does { x: a, ..s } always represent a move of s?  Or is it supposed to sometimes move and sometimes copy, based on "a policy" ?
[23:51:42] *** Joins: quksw_ (quksw@moz-CD41E5C8.red.bezeqint.net)
[23:52:04] <cmr> pnkfelix: there were soundness holes with not moving.
[23:52:05] <dbaupp> pnkfelix: I think it follows the normal implicit copy vs move rules?
[23:52:15] <cmr> it previously *only* copied
[23:52:22] <kimundi> pnkfelix: I'd assume it either implicit copies or moves, depending on type
[23:52:36] *** Quits: Kruppe (user@moz-E150F49F.cpe.net.cable.rogers.com) (Ping timeout)
[23:52:44] *** Quits: quk_sw_ (quksw@moz-CD41E5C8.red.bezeqint.net) (Ping timeout)
[23:52:56] <dbaupp> rusti: struct Foo { x: ~int, y: ~int } let a = Foo { x: ~1, y: ~2 }; let b = Foo { x: ~3, .. a }; b
[23:52:57] -rusti- main::Foo{x: ~3, y: ~2}
[23:53:03] <dbaupp> rusti: struct Foo { x: ~int, y: ~int } let a = Foo { x: ~1, y: ~2 }; let b = Foo { x: ~3, .. a }; a
[23:53:03] *** Quits: nejucomo (Adium@moz-434492BB.dsl.static.sonic.net) (Quit: Leaving.)
[23:53:05] -rusti- pastebinned 8 lines of output: http://sprunge.us/TJSb
[23:53:23] <dbaupp> rusti: struct Foo { x: int, y: int } let a = Foo { x: 1, y: 2 }; let b = Foo { x: 3, .. a }; a
[23:53:23] -rusti- <anon>:7:71: 7:72 warning: unused variable: `b` [-W unused-variable (default)]
[23:53:24] -rusti- <anon>:7          struct Foo { x: int, y: int } let a = Foo { x: 1, y: 2 }; let b = Foo { x: 3, .. a }; a
[23:53:24] -rusti-                                                                                 ^
[23:53:24] -rusti- main::Foo{x: 1, y: 2}
[23:53:48] <acrichto> struct Markdown(...) impl fmt::Default for Markdown { ... } format!("{}", Markdown(s)) -- I feel so clever lol
[23:54:05] * dbaupp hugs acrichto
[23:54:34] *** Joins: Kruppe (user@moz-E150F49F.cpe.net.cable.rogers.com)
[23:55:09] <acrichto> if only I could stream the output of pandoc into the fmt::Formatter buf
[23:55:21] <acrichto> too clever by 1/2 at that point...
[23:57:35] <Earnestly> Donâ€™t be too clever, youâ€™re going to have to be twice as clever to debug it :P
[23:57:42] <engla> why? it's supposed to be able to pipe this together, if the Markdown thing can output to a Writer
[23:57:45] <cmr> that's the fun!
[23:57:45] * pnkfelix is trying to fix something in borrowck but doesn't want to inject too much restruction
[23:57:51] <mcpherrin> is there a [u8] -> str that gobbles non-unicode characters (eg, replacement character)
[23:57:57] <engla> mcpherrin: not yet
[23:58:10] *** Quits: andrew-d_w (andrew-d_w@moz-9A2674DF.dsl.static.sonic.net) (Input/output error)
[23:58:29] <acrichto> engla: it's using std::run right now which is a bit of a hamstring
[23:58:38] <acrichto> in theory it's possible, but not really worth it right now
[23:58:43] <engla> oh yeah
[23:58:44] <acrichto> I should make these docs build in parallel though
[23:58:51] <acrichto> that would *actually* be helpful
[23:58:56] <acrichto> b/c we're running child processes
[23:59:16] <benh> hm, if you have an unterminated string with a newline before the end of file, the newline gets counted towards the columns in the last line...
[23:59:50] *** Quits: infynyxx (infynyxx@DB780A29.749BA1D.DCC373F0.IP) (Client exited)
[23:59:55] <engla> strcat: what do you think about writing Mut<T> to both allow access through closures like RcMut, but also with detached wrapped borrowed pointers for either reading or writing? It seems to work well in a test

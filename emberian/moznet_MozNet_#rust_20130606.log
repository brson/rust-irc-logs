[00:00:14] <Jesse> Eridius: is there a company-provided bus that can take you to MV?
[00:00:17] <Jesse> (and then caltrain home)
[00:00:27] *** Joins: vcl (chatzilla@741D4FEA.76F9E272.DA40C4B3.IP)
[00:00:59] <Eridius> Jesse: I suppose there is a shuttle that goes directly to caltrain but I don't know its schedule. Kind of moot anyway if this is happening next week though, because WWDC takes precedence
[00:01:40] <Jesse> the week after next is PLDI
[00:01:43] *** Quits: azita (Azita@2557E599.66715431.D25A875A.IP) (Quit: azita)
[00:01:48] <Eridius> what's PLDI?
[00:02:07] <Jesse> ACM SIGPLAN conference on Programming Language Design and Implementation
[00:02:47] <Eridius> ah
[00:02:54] *** Parts: steven_is_false (user@moz-144077DE.bchsia.telus.net) (ERC Version 5.3 (IRC client for Emacs))
[00:02:57] <erickt> Well lets do this drinkup next week, and make it a regular thing :)
[00:03:19] <Jesse> we could alternate MV and SF
[00:03:21] *** Quits: thou (thou@moz-1C1CA9F7.fasttrackcomm.net) (Ping timeout)
[00:03:57] <erickt> sounds good to me
[00:04:07] <Jesse> i wonder who's going to PLDI
[00:04:14] *** Quits: MaikKlein (maik@moz-72D6CA68.dip0.t-ipconnect.de) (Ping timeout)
[00:04:31] *** Joins: thou (thou@moz-1C1CA9F7.fasttrackcomm.net)
[00:06:10] <cmr> bblum: effects would be very nice to have, I like the propsal. Not too enthused about an "effect" keyword though.
[00:06:34] *** Joins: azita (Azita@2557E599.66715431.D25A875A.IP)
[00:06:44] <bblum> cmr: suggestions welcome
[00:07:05] <cmr> bblum: I can't think of anything better, unfortunately :)
[00:07:06] <bblum> i briefly considered using attributes to declare new effects as well, but i wasn't sure if that was even possible, and it looked uglier anyway
[00:07:33] <bblum> btw, if you have motivating examples for why you want effects, do share them :O
[00:09:07] <cmr> Preventing GC is really great.
[00:09:13] <brson> cmr: I pushed a jemalloc fix to my jemalloc branch for you to cherry-pick
[00:09:28] *** Quits: dylukes (dylukes@moz-E4DF3FED.pitbpa.fios.verizon.net) (Quit: ["Textual IRC Client: www.textualapp.com"])
[00:09:28] <cmr> brson: cool, thanks
[00:10:07] <aatch> Wow, adt puts out some wierd IR...
[00:10:28] *** Joins: ghrust (ghrust@moz-4EF5B6E5.rs.github.com)
[00:10:29] <ghrust> 01[13rust01] 15brson created 06jemalloc (+4 new commits): 02http://git.io/ntM_2Q
[00:10:29] <ghrust> 13rust/06jemalloc 14cff203e 15Daniel Micay: add jemalloc to the runtime
[00:10:29] <ghrust> 13rust/06jemalloc 14933897c 15Daniel Micay: integrate jemalloc into the build
[00:10:29] <ghrust> 13rust/06jemalloc 142d63517 15Corey Richardson: Windows fixes
[00:10:30] *** Parts: ghrust (ghrust@moz-4EF5B6E5.rs.github.com) ()
[00:10:46] <aatch> Woops
[00:11:04] *** Quits: vcl (chatzilla@741D4FEA.76F9E272.DA40C4B3.IP) (Ping timeout)
[00:11:40] <cmr> brson: pushed
[00:13:09] *** Joins: SimonSapin (simon@5924A8D9.7F79A810.4065847B.IP)
[00:14:38] <erickt> brson / pcwalton / Jesse / interns: Does a Wednesday meetup at Tied work for you?
[00:14:48] *** Quits: jgilbert (jgilbert@43CB6079.66715431.D25A875A.IP) (Ping timeout)
[00:15:24] <Jesse> yes
[00:15:37] <Jesse> (btw wed is june 12 is Loving Day)
[00:16:35] <mark_edward> My Favorite!
[00:16:59] *** Quits: Sorella (queen@B12A78F5.BA14766C.95C8B7C6.IP) (Ping timeout)
[00:17:33] <erickt> how appropriate. everyone should love rust
[00:17:39] *** Joins: wilsonk|2 (kvirc@moz-39EFBFC2.cg.shawcable.net)
[00:17:58] *** Joins: \n (NDesaulnie@moz-BE33DA21.fw1.sfo1.mozilla.net)
[00:18:00] <mark_edward> that's not really what it's about...
[00:18:04] <mark_edward> it's about this! https://en.wikipedia.org/wiki/Loving_vs._Virginia
[00:18:11] *** Quits: wilsonk-laptop (kvirc@moz-39EFBFC2.cg.shawcable.net) (Ping timeout)
[00:18:11] <erickt> oooh that loving!
[00:18:23] <erickt> that also should be celebrated
[00:18:28] <mark_edward> significant for me and my fiancee, so we really like that day
[00:18:52] <mark_edward> but i will also celebrate my love of Rust :P
[00:19:11] <erickt> :)
[00:20:09] <moonchrome> bjz, so I've read the associated items thing, it would essentially let you write a generic T/N vector implementation like you can do in D with int template parameter, I don't think it makes sense to try to do anything fancy before that lands 
[00:20:34] <bjz> moonchrome: aye
[00:20:51] <bjz> moonchrome: that's what I was hoping with doing what you suggested
[00:20:51] *** Joins: jyeo (user@moz-FEFE526F.cpe.net.cable.rogers.com)
[00:21:11] <bjz> moonchrome: at least we could get something working in the interim
[00:21:23] <moonchrome> bjz, but any reason to store members as x,y vs [T, .. 2] ?
[00:21:31] *** Joins: true_droid (Adium@moz-123FD9B8.beck.volia.net)
[00:21:38] <moonchrome> wouldn't the latter make it easier to implement index operator on vec
[00:21:52] <bjz> moonchrome: so you can access the feilds via .x
[00:21:57] <bjz> etc
[00:22:09] <true_droid> hi, can one match against the value of an existing variable in "match"?
[00:22:10] <moonchrome> bjz, oh right, no properties 
[00:22:15] <bjz> moonchrome: aye
[00:22:47] <bjz> moonchrome: I plan to merge lmath with cgmath in the future
[00:22:49] <moonchrome> bjz, still do you have to do a switch for index operator or can you just cast self to ptr and offset the index ?
[00:23:17] <bjz> moonchrome: I used to use the index operator, but it copies :(
[00:23:20] *** Joins: dylukes (dylukes@moz-E4DF3FED.pitbpa.fios.verizon.net)
[00:23:28] <bjz> moonchrome: we could reinstate it though
[00:23:37] *** Quits: brendan (brendaneic@8DFE0F5E.F1D38B1F.1D6E592A.IP) (Quit: brendan)
[00:23:37] <bjz> moonchrome: and just state that it copies
[00:23:57] <moonchrome> bjz, but if you can't use the index operator then you can't define generic N dimensional operations
[00:24:01] <bjz> moonchrome: nmatsakis was talking about redoing the Index trait in the future
[00:24:04] *** Joins: eschweic (Adium@moz-BE33DA21.fw1.sfo1.mozilla.net)
[00:24:25] <bstrie> true_droid: you mean something like `let x = 1; match foo { bar if x == 1 ...` ?
[00:24:42] *** Joins: emartin (emartin@moz-C3D4EEBF.caltech.edu)
[00:24:45] <bjz> moonchrome: we have index<'a>(&'a self, i: uint) -> &'a T
[00:24:54] <bjz> moonchrome: that doesn't copy
[00:25:01] <emartin> is there any way I can get a backtrace on a crash (task failure)?
[00:25:22] <cmr> emartin: RUST_LOG=::rt::backtrace
[00:25:33] <cmr> It's not all too useful though, gdb usually gives better backtraces.
[00:25:39] <cmr> It only works on linux afaik
[00:25:41] <true_droid> bstrie: yes, but more like match { #x => â€¦ } where # stands for the actual syntax used for this. Is there one?
[00:25:54] <bjz> moonchrome: btw, I'm wholly open to being convinced :)
[00:26:13] <bjz> moonchrome: I like changing my mind if a good case is presented :)
[00:26:58] *** Quits: bent (chatzilla@moz-BE33DA21.fw1.sfo1.mozilla.net) (Quit: ChatZilla 0.9.90-rdmsoft [XULRunner 18.0.2/20130201065344])
[00:27:03] <moonchrome> bjz, no it's perfectly fine to use index, that's what I meant anyway
[00:27:20] <emartin> i'm running gdb 7.4, after the assertion failure there are messages about threads exiting, and then 'bt' gives message 'no stack'
[00:27:49] <moonchrome> I was just curios if you casted pointer + offset instead of doing switch(index) {case 0: x ... thing, i see in implementation that it's casting a pointer so it's cool
[00:27:54] <bjz> moonchrome: there will also be index assignment overloads in the future
[00:28:32] <moonchrome> bjz, for internal operation implementation shugar isn't really important IMO
[00:28:35] <bjz> moonchrome: I want to take advantage of rust's inherent vector implementation
[00:29:08] *** Joins: eatkinson (eatkinson@moz-BE33DA21.fw1.sfo1.mozilla.net)
[00:29:12] <bjz> moonchrome: if that makes sense
[00:29:28] *** Quits: snadon (chatzilla@moz-3BC727E8.mc.videotron.ca) (Ping timeout)
[00:29:28] <moonchrome> bjz, what advantage is that :P
[00:29:42] *** Joins: jgilbert (jgilbert@2557E599.66715431.D25A875A.IP)
[00:29:49] <nmatsakis> bjz: yeah, I DO want to redo the index trait, kind of fell off my radar though, I should revisit my examples and try to write up my thoughts about it.
[00:29:57] <bjz> moonchrome: I assume it's better optimised than a mtch
[00:30:02] <bjz> *match
[00:30:14] *** Joins: dimension (dimension@moz-4CCD79C5.dsl.dynamic.simnet.is)
[00:30:26] <bjz> moonchrome: plus the user could possibly choose if they want bounds checking
[00:30:29] <moonchrome> bjz, but you're using unsafe { &'a transmute::<&'a Vec2<T>, &'a [T,..2]>(self)[i] } inside your index anyway - that's equivalent to index
[00:30:37] <bjz> nmatsakis: no worries
[00:30:55] <bstrie> true_droid: is https://gist.github.com/bstrie/5718429 enough for your purposes?
[00:31:51] <moonchrome> bjz, so you're already doing the optimal thing if I'm reading it correctly
[00:32:03] <bjz> moonchrome: that's what I thought :)
[00:32:18] <bjz> moonchrome: are you saying I should change?
[00:32:34] <bjz> moonchrome: or are you saying I'm ok?
[00:32:37] *** Quits: ssbr (ssbr@moz-A48A4550.s-ip.magma.ca) (Ping timeout)
[00:32:38] <moonchrome> bjz, no I'm saying I was afraid you didn't do it before I saw the code 
[00:32:44] <bjz> ahh
[00:32:45] <bjz> haha
[00:32:47] <bjz> :)
[00:33:07] <true_droid> bstrie: this looks good, thanks
[00:33:31] <bjz> moonchrome: btw, if you see me doing any stupid things let me know
[00:33:43] *** Quits: \n (NDesaulnie@moz-BE33DA21.fw1.sfo1.mozilla.net) (Quit: \n)
[00:33:50] <bjz> moonchrome: or things that could be optimised
[00:33:55] <bstrie> true_droid: you can also use if statements :)
[00:37:08] *** Quits: royw (royw@moz-E9B4079C.hsd1.ca.comcast.net) (Quit: royw)
[00:37:18] *** Joins: dherman (dherman@moz-BF6CB667.hsd1.ca.comcast.net)
[00:37:18] *** ChanServ sets mode: +o dherman
[00:38:49] <bjz> moonchrome: I'm going to remove those macros from lmath
[00:38:49] <bjz> moonchrome: ie. the mod generating ones
[00:38:55] <bjz> moonchrome: or are you doing it already?
[00:39:06] *** Quits: rfw (rfw@moz-C65A114.rfw.name) (Ping timeout)
[00:39:10] *** Joins: rfw (rfw@moz-C65A114.rfw.name)
[00:39:21] <bjz> moonchrome: did you manage to look at getting rid of the Base* traits?
[00:39:36] <bjz> moonchrome: or shall I?
[00:39:42] <erickt> all: made the meetup reservation at Tied for Wednesday, June 12th, at 7pm
[00:40:06] <erickt> Please reply to my mail to rust-dev if you can/cannot go
[00:40:12] *** Quits: tikue (tkuehn@moz-BE33DA21.fw1.sfo1.mozilla.net) (Quit: tikue)
[00:40:13] <moonchrome> bjz, I'm actually looking at those traits right now
[00:40:32] <bjz> moonchrome: ok, neat
[00:40:46] <bjz> moonchrome: I won't touch it then
[00:41:09] <moonchrome> bjz, do you want to follow glsl syntax ?
[00:41:37] <bjz> moonchrome: what syntax do you mean in particular?
[00:41:40] <moonchrome> ie cos(v1, v2) vs v1.cos(v2)
[00:42:03] <bjz> moonchrome: in the future I want those to be associated functions
[00:42:11] <moonchrome> bjz, exactly
[00:42:44] <bjz> but we have to wait for the new path thingy first for them to be useful
[00:43:10] <bjz> so until then it's probably better to leave them as methods
[00:43:12] *** Quits: eatkinson (eatkinson@moz-BE33DA21.fw1.sfo1.mozilla.net) (Quit: eatkinson)
[00:43:48] <bjz> hopfully in the future we'll be able to do: use Vec3f::{sin, cos, tan};
[00:43:48] <Thiez> brson: it appears to work, I'll be adding some more comments and probably a small explanation of the algorithm. Anything else I should add/remove? https://github.com/Thiez/rust/blob/ll-message-queue/src/libstd/rt/message_queue.rs
[00:43:51] <moonchrome> bjz, would using function inside vector trait to get dimensions work ?
[00:44:38] *** Quits: dherman (dherman@moz-BF6CB667.hsd1.ca.comcast.net) (Quit: dherman)
[00:44:43] <bjz> moonchrome: the reason I didn't have it at first was due to the issue with generic paths
[00:44:43] *** Quits: eschweic (Adium@moz-BE33DA21.fw1.sfo1.mozilla.net) (Quit: Leaving.)
[00:44:55] <moonchrome> ie. trait BaseVec<T> { fn len() -> uint; }
[00:45:04] <bjz> moonchrome: it would have been an associated function on BaseVec
[00:45:19] <bjz> but rust can't infer which vec you mean
[00:45:43] *** Quits: SiegeLord (siege@moz-CAF07B4C.hsd1.ma.comcast.net) (Connection reset by peer)
[00:45:47] <bjz> because it's not present in the BaseVec::len()
[00:46:28] <bjz> hence why (Vec3<T>)::len(), or at least Vec3f::len() would be useful
[00:46:33] <moonchrome> so you can't use something like fn add<T, V :BaseVec<T>>(...) { for t.len() ... } ?
[00:46:52] <bjz> no
[00:47:06] <bjz> :(
[00:47:38] <bjz> that's one of the key limitations in the current way of accessing associated functions
[00:47:54] *** Joins: jorendorff (jorendorff@moz-2F32ACA3.hsd1.tn.comcast.net)
[00:48:06] <bjz> that's why I had those modes generated by macros
[00:48:37] *** Joins: ssbr (ssbr@moz-F4C1E66D.dsl.bell.ca)
[00:48:43] <bjz> the other issue is that it makes it hard to get even those associated functions that get constants
[00:49:18] <bjz> like, you have to do: let id: Vec3<float> = NumericVec::identity();
[00:49:32] <bjz> which smells very java-y
[00:50:34] *** Quits: erickt (erickt@8C9ECD8F.3A598286.F12515B4.IP) (Quit: Leaving.)
[00:50:42] <bjz> so yeah, we are bound by current limitations, but they should be fixed in the future
[00:50:52] *** Quits: true_droid (Adium@moz-123FD9B8.beck.volia.net) (Quit: Leaving.)
[00:51:21] <bjz> I would love to assist, but the hard-core compiler work is beyond my current skills :(
[00:51:27] <bjz> dunno if you could?
[00:51:29] <bjz> :P
[00:52:29] *** Joins: wuwei`lab (wuwei@1A513F49.818D7924.FAA9ED67.IP)
[00:53:07] <aatch> bjz, unfortunately we are also limited by lack of a decision on the syntax.
[00:53:19] <pcwalton> we had a decision on the syntax I think
[00:53:27] <aatch> pcwalton, we did?
[00:53:36] *** Quits: Jesse (jruderman@2557E599.66715431.D25A875A.IP) (Quit: Jesse)
[00:53:39] <bjz> aatch: yeah, for typedefs
[00:53:44] <bjz> *typ aliases
[00:53:49] <bjz> *type aliases
[00:54:09] <aatch> Ok, was that recent? (like less than a day or two?)
[00:54:39] <pcwalton> impl Vec3f = NumericVec for Vec<float>; Vec3f::identity()
[00:55:37] *** Joins: royw (royw@moz-E9B4079C.hsd1.ca.comcast.net)
[00:56:00] *** Joins: Jesin (Jessin_@moz-3AD6F09F.res.lehigh.edu)
[00:56:02] <bjz> pcwalton: could you comment on this? https://github.com/mozilla/rust/issues/6894#issuecomment-18944443
[00:56:10] <pcwalton> it was in Vancouver
[00:57:22] <pcwalton> bjz: replied
[00:57:28] <pcwalton> niko's blog post describes it better
[00:57:46] *** Quits: tgt (tgt@moz-D59EE478.aztw.cable.virginmedia.com) (Quit: Textual IRC Client: www.textualapp.com)
[00:58:12] <bjz> pcwalton: ie. if we were going to do that rework of generic paths, why would we need the `use impl` thing?
[00:58:33] <sully> ugh, we have *so* *much* code in unsafe
[00:58:34] <sully> in rustc
[00:58:37] <pcwalton> you need it because OwnedOptFloat::size_of() won't work
[00:58:43] <pcwalton> sully: we need to make the LLVM interface safe
[00:58:47] <pcwalton> bjz: because that's OO notation
[00:58:49] <sully> most of trans_crate is unsafe
[00:58:49] *** Joins: tgt (tgt@moz-D59EE478.aztw.cable.virginmedia.com)
[00:58:53] <sully> :(
[00:58:58] <pcwalton> and we weren't doing that because of the possibility of name collisions
[00:59:10] <bjz> pcwalton: isn't that what this was about? https://mail.mozilla.org/pipermail/rust-dev/2013-April/003866.html
[00:59:21] <pcwalton> bjz: no, that's not about trait methods
[00:59:29] <pcwalton> that's about methods on impl Foo { ... }
[00:59:31] <pcwalton> not impl SizeOf for Foo { ... }
[00:59:38] <bjz> oh :(
[00:59:41] *** Quits: azita (Azita@2557E599.66715431.D25A875A.IP) (Quit: azita)
[00:59:50] <pcwalton> bjz: the problem is that Self::(Add<Rhs>::Sum) looks terrible
[00:59:55] <pcwalton> and that's what OO notation leads you to
[01:00:14] <pcwalton> it handles simple cases well but doesn't scale to more complex cases
[01:00:21] <bjz> but why do you need to specify the specific trait, when it infers it for methods?
[01:00:23] <aatch> sully, most of that is because of the llvm bindings.
[01:00:39] <bjz> isn't that an assymetry?
[01:00:47] <pcwalton> "." has always been weird
[01:00:58] <pcwalton> we've never had "::" do anything other than look through module paths
[01:01:30] <bjz> it just seems weird to infer for methods and not for associated items
[01:01:32] <Eridius> ack, the unused-mut warning checker is broken
[01:01:33] <pcwalton> if :: looked through all traits in scope, then we'd have method lookup in :: as well as .
[01:01:49] <Eridius> it warns about a mut parameter to my function, but it's wrong
[01:01:49] <pcwalton> it doesn't to me, I mean . is a different operator from ::
[01:01:59] <strcat> Eridius: example?
[01:01:59] *** Joins: dbaupp (Thunderbir@moz-C6B1454A.lns20.syd7.internode.on.net)
[01:02:18] <Eridius> strcat: oh wait, false alarm
[01:02:28] <Eridius> I just misread which function it was complaining about
[01:02:39] <bjz> pcwalton: how so?
[01:02:58] <pcwalton> so '.' looks through traits in scope but '::' doesn't
[01:03:05] <pcwalton> '::' is just a module lookup operator in Rust
[01:03:07] <Eridius> more accurately, I refactored a function into two separate pieces, and only one needed it mut, but when I read the warning about the other function, which carries the name the original had, I was confused
[01:04:12] *** Quits: brson (brson@2557E599.66715431.D25A875A.IP) (Ping timeout)
[01:04:31] <bjz> pcwalton: just out of curiosity, why don't we do the '.' operator for associated items/functions like in Java/C++?
[01:04:46] <pcwalton> I worry that people would be very confused if you had to import something to make '::' work
[01:05:08] *** Joins: SiegeLord (sl@moz-CAF07B4C.hsd1.ma.comcast.net)
[01:05:32] <strcat> bjz: associated functions?
[01:05:38] <strcat> as in... methods? ;p
[01:05:45] <pcwalton> well, C++ uses ::
[01:05:58] <strcat> C++ uses :: for static variables/methods
[01:06:04] <pcwalton> what's on the LHS of '.' is always a value
[01:06:12] <pcwalton> there are two namespaces in Rust, type namespace and value namespace
[01:06:18] <pcwalton> resolve has to know which one to look in
[01:06:33] <pcwalton> for '::' the LHS is in the type namespace (including modules), for '.' the LHS is in the value namespace
[01:06:41] *** Joins: azita (Azita@2557E599.66715431.D25A875A.IP)
[01:07:23] *** Quits: mschifer2 (Adium@2557E599.66715431.D25A875A.IP) (Quit: Leaving.)
[01:07:47] *** Quits: jack (jack@8ABE2BFB.9F8380A1.A535BD55.IP) (Quit: Leaving.)
[01:07:55] *** Quits: bytbox (s@moz-D83E9B31.wireless.umd.edu) (Ping timeout)
[01:08:00] *** Joins: jack (jack@8ABE2BFB.9F8380A1.A535BD55.IP)
[01:08:55] *** Quits: jorendorff (jorendorff@moz-2F32ACA3.hsd1.tn.comcast.net) (Quit: jorendorff)
[01:09:19] <bjz> pcwalton: doesn't Rust have monomorphisation? like shouldn't ~Option<float> generate an associated module with the traits in scope?
[01:09:35] <pcwalton> monomorphization is just something that codegen does
[01:11:32] <jld> sully: Is it still the case that most of the rustc unsafe blocks should be wrappers in the `llvm` module?
[01:11:47] <sully> yeah, probably
[01:11:55] <jld> i.e., are places that predate extern being unsafe and people were lazy and went around the wrappers
[01:12:00] *** Quits: pragmatic (pragmatic@43CB6079.66715431.D25A875A.IP) (Ping timeout)
[01:12:32] *** Quits: jack (jack@8ABE2BFB.9F8380A1.A535BD55.IP) (Ping timeout)
[01:12:44] *** Quits: tgt (tgt@moz-D59EE478.aztw.cable.virginmedia.com) (Quit: Computer has gone to sleep.)
[01:12:52] <bjz> pcwalton: mmk. but yeah, what do you mean by "I worry that people would be very confused if you had to import something to make '::' work" don't we already do that with methods
[01:13:03] <pcwalton> we do, but '.' is different from '::'
[01:13:28] <bjz> why? from an implementation sense, or from a user perspective?
[01:13:36] <pcwalton> well, both really
[01:14:01] <pcwalton> I guess maybe we could do it
[01:14:04] *** Quits: caitp (caitp@moz-9FE842F.cpe.net.cable.rogers.com) (Quit: caitp)
[01:14:56] <bjz> pcwalton: sorry for going so strong about it. I wish we'd get more people's thoughts. I might be alone on this one.
[01:15:06] <pcwalton> well, I do see the use case here
[01:15:32] <pcwalton> if you have a ton of traits Foo Bar Baz and you want to reexport impls for Vec3f or whatever having to write Vec3fFoo:: Vec3fBar:: Vec3fBaz:: may be annoying.
[01:15:35] *** Joins: Amanieu (amanieu@moz-D5D10CA8.halls.manchester.ac.uk)
[01:15:40] *** Joins: caitp (caitp@moz-9FE842F.cpe.net.cable.rogers.com)
[01:16:09] <bjz> pcwalton: I might be completely insane. Which is a very real possibility :). and of course, what makes 'sense' to one person is subjective
[01:16:18] <pcwalton> well, no, we did debate this a lot
[01:16:21] <bjz> aatch: thoughts?
[01:17:00] <pcwalton> it's possible it won't work out. anyway, I think (a) we need this "use impl" thing anyway; (b) we can add the ::-looks-through-everything-in-scope behavior later backwards compatibly if we need to...
[01:17:20] *** Joins: brson (brson@2557E599.66715431.D25A875A.IP)
[01:17:20] *** ChanServ sets mode: +o brson
[01:17:29] *** Joins: Sorella (queen@B12A78F5.BA14766C.95C8B7C6.IP)
[01:17:52] <strcat> pcwalton: not necessarily backwards compatible due to conflicts that might not otherwise exist
[01:18:12] <pcwalton> we'd just resolve them in favor of the inherent methods.
[01:18:25] <bjz> strcat: am I completely insane?
[01:18:30] <strcat> bjz: no
[01:18:34] * bjz want's to know
[01:18:37] <pcwalton> you are not completely insane :)
[01:18:43] <strcat> just a bit
[01:18:43] <bjz> :P
[01:18:47] <bjz> hehe
[01:18:57] <pcwalton> we're just nervous about giving '::' more magic
[01:19:02] <pcwalton> it's entirely possible we will have to add it later
[01:19:49] <bjz> I just see Jeayne soing some similar workarounds to get that functionality and worry other folks will do it too in the future
[01:20:01] *** Joins: jorendorff (jorendorff@moz-2F32ACA3.hsd1.tn.comcast.net)
[01:20:15] <bjz> He has to give up the benefits of traits to do so
[01:20:40] <nmatsakis> brson: btw, I realized I forgot that I still hadn't r+'d your PR
[01:20:56] <bjz> I also see the num modules and see that you're basically doing that already
[01:21:02] <bjz> like uint::range
[01:21:02] <pcwalton> the worst thing that will happen here is that you have to make multiple "use impl"s
[01:21:06] <pcwalton> I want to get rid of those
[01:21:12] <strcat> bjz: that should be a method, imo
[01:21:16] <strcat> 5u.to(&100)
[01:21:20] <pcwalton> or just range(0, 100)
[01:21:37] <bjz> strcat: I've already got a commit locally for that
[01:21:37] <strcat> needs a trait to be generic though
[01:21:44] <bjz> strcat: Enum
[01:21:58] <bjz> strcat: like in haskell
[01:22:19] <mleise> looks like iota() finally made it in :)
[01:22:25] <bjz> strcat: which could mean uint::range would work, if the above would work
[01:23:02] <dbaupp> mleise: ?
[01:23:09] <strcat> mleise: it's not an object though
[01:23:16] <strcat> it's the silly internal iterator stuff that I don't like
[01:23:19] <mleise> dbaupp: it is from C
[01:23:27] <pcwalton> use impl UintRange = Range for uint; UintRange::range()
[01:23:27] <mleise> C++ boost and I was missing it from D
[01:23:28] <pcwalton> you need an extra name.
[01:23:53] <dbaupp> mleise: http://en.cppreference.com/w/cpp/algorithm/iota ?
[01:24:13] <strcat> pcwalton: if our for loop was like python's...
[01:24:20] <strcat> for range(0, 10, 2) |x| { }
[01:24:32] <mleise> dbaupp: yeah, a pretty simple thing actually
[01:24:33] <strcat> range(0, 10, 2).zip(xs)
[01:25:27] <strcat> people won't like internal iterators when they're generic instead of hardcoded algorithms on every container ;\
[01:25:31] <pcwalton> I mean, yes, this basically comes down to whether we're willing to let :: simultaneously mean "look through the given module" and "look through all traits in scope"
[01:25:33] <mleise> compilers can actually turn iota into a for loop
[01:26:00] *** Quits: SimonSapin (simon@5924A8D9.7F79A810.4065847B.IP) (Ping timeout)
[01:26:22] <aatch> Having worked with optimizations, the compiler can do some crazy things
[01:26:38] <bjz> pcwalton: what are the key downsides to "look through all traits in scope"?
[01:26:41] <pcwalton> it is conceivable that we could do both: introduce the "use impl ..." syntax and have :: do the looking through
[01:26:52] <strcat> filter<T>(pred: &fn(&T) -> bool, input: &fn(&fn(T) -> bool) -> bool, output: &fn(T) -> bool) -> bool {}
[01:26:54] <strcat> that's really awful
[01:26:58] <mleise> aatch: I once saw GCC use SSE instructions on some math I was doing on a struct of 4 bytes
[01:26:59] *** Joins: SimonSapin (simon@5924A8D9.7F79A810.4065847B.IP)
[01:27:13] <pcwalton> it's complicated to implement in resolve and I think a lot of people want :: to be simple
[01:27:19] <aatch> mleise, rustc should do that at opt-level=3
[01:27:47] <aatch> not sure about what passes do which vectorizations though.
[01:27:59] *** Quits: a__ (a__@moz-250D9B4.nycmny.fios.verizon.net) (Client exited)
[01:28:04] <strcat> aatch: there's a loop vectorization pass, that's the only one clang has enabled by default
[01:28:08] <pcwalton> I feel like explaining ":: has this behavior whereby it looks through all traits in scope and picks the one with a method with that name" is a wtfrust.com moment
[01:28:14] *** Joins: a__ (a__@moz-250D9B4.nycmny.fios.verizon.net)
[01:28:18] <strcat> vectorizing non-loops isn't ready yet
[01:28:39] <aatch> Well then, it should do the same thing in rust.
[01:28:54] <mleise> pcwalton: and I've seen quite a few wtfdlang.org moments :D dont mess up your language
[01:29:21] <pcwalton> there are also other options that seem less magical
[01:29:29] <pcwalton> (Range for uint)::range() for example
[01:29:32] * strcat thinks it's too late to make 'for' loops sane anyway
[01:29:38] <pcwalton> range::<for uint>()
[01:29:39] <pcwalton> or something like that
[01:29:39] <pcwalton> again this is niko's blog post
[01:29:54] <pcwalton> for loops aren't sane? :)
[01:29:59] <aatch> I don't mind range::<for int>()
[01:30:04] <mleise> not pythonic enough?
[01:30:06] <strcat> pcwalton: they really aren't, internal iterators don't compose in rust
[01:30:11] *** Quits: SimonSapin (simon@5924A8D9.7F79A810.4065847B.IP) (Connection reset by peer)
[01:30:15] <strcat> pcwalton: did you see the filter signature above?
[01:30:20] <strcat> filter<T>(pred: &fn(&T) -> bool, input: &fn(&fn(T) -> bool) -> bool, output: &fn(T) -> bool) -> bool {}
[01:30:24] <strcat> *no one* will know how to use it
[01:30:33] <pcwalton> you need external iterators for that
[01:30:35] <strcat> and it's a pain because you have to wrap the input you pass to it
[01:30:39] <strcat> pcwalton: we have them and they work well ;p
[01:30:40] *** Joins: SimonSapin (simon@5924A8D9.7F79A810.4065847B.IP)
[01:30:46] <pcwalton> you'd rather have them built into the language?
[01:30:49] <pcwalton> I mean, we can change it
[01:30:57] <pcwalton> graydon argued very strongly in favor of internal iterators
[01:31:00] *** Quits: royw (royw@moz-E9B4079C.hsd1.ca.comcast.net) (Quit: royw)
[01:31:06] <strcat> pcwalton: yeah, imo we're doing the wrong thing because they really don't compose well
[01:31:08] <pcwalton> but I never was totally convinced
[01:31:09] <strcat> like
[01:31:18] <aatch> language-level external iterators!
[01:31:31] <pcwalton> it's easy, if you can make it a trait we can just make it a lang item
[01:31:37] <strcat> for filter(predicate, |f| uint::range(0, 10, f)) |x| {}
[01:31:38] <aatch> I mean, from a top-level POV it should look the same, right?
[01:31:39] <strcat> vs
[01:31:52] <strcat> for range(0, 10).filter(predicate) |x| {}
[01:32:05] <strcat> and they can have zip, union, etc.
[01:32:19] <strcat> atm they have .advance tacked on the end
[01:32:43] <strcat> range(0, 10).advance encourages you to use/make internal iterators
[01:33:00] <pcwalton> so the argument in favor of internal is that they're easier to write
[01:33:04] <bjz> pcwalton: maybe we could use the -> operator! *kids*
[01:33:06] <strcat> pcwalton: sometimes
[01:33:07] <pcwalton> for example, iter_boxes_for_range
[01:33:11] <strcat> pcwalton: they're easier to write when you need recursion
[01:33:12] <pcwalton> and traverse_preorder
[01:33:15] <pcwalton> yes
[01:33:18] <pcwalton> which is most of the time in servo
[01:33:20] <strcat> pcwalton: we could have 'yield' though
[01:33:27] <strcat> C# does
[01:33:30] <pcwalton> and transform it into a state machine like C#?
[01:33:33] <strcat> pcwalton: yeah
[01:33:36] <pcwalton> that's out of scope for rust 1.0
[01:33:41] <pcwalton> that'd delay the language for a year
[01:33:56] <strcat> pcwalton: yeah, but 2 years from now or whatever, we'll have it and regret 'for' forever
[01:34:04] <strcat> imo at least
[01:34:10] <pcwalton> "for" is not that bad
[01:34:29] <strcat> pcwalton: for itself is fine to use but internal iterators by themselves are awful to use in rust
[01:34:29] <pcwalton> you can transform an external iterator into an internal one
[01:34:33] <strcat> pcwalton: yeah
[01:34:46] <bjz> strcat: 'iter' ?
[01:34:53] <strcat> pcwalton: but it's much more verbose than languages that use external ones
[01:35:03] <strcat> python's for loop knows about both iterables and iterators
[01:35:08] <pcwalton> if we needed we could overload for
[01:35:11] <pcwalton> and have a lang item
[01:35:12] <pcwalton> or something like that
[01:35:27] <strcat> for container.iter().advance |x| {} is just 'for container |x| {}'
[01:36:03] <strcat> for xs.reversed().zip(ys) |(x, y)| {}
[01:36:07] <bjz> what about having an iter keyword for internal iterators?
[01:36:30] *** Joins: Jesse (jruderman@2557E599.66715431.D25A875A.IP)
[01:36:39] <strcat> pcwalton: recursive ones are really a pain right now, I definitely agree with that
[01:37:02] <strcat> but for someone *using* either an internal or external one, external is really so much better
[01:37:38] <pcwalton> the nice thing about "for" is that it is very simple
[01:37:48] <strcat> pcwalton: well, an external iter one would be simpler
[01:37:52] <strcat> pcwalton: 'return' would always return
[01:38:14] <pcwalton> what is the signature of the iter trait?
[01:38:27] <strcat> pcwalton: fn next(&mut self) -> Option<T>
[01:38:39] <strcat> the for loop would just call next until None
[01:38:45] <pcwalton> can that just be a function?
[01:38:51] <strcat> pcwalton: yeah, it's an advance method
[01:38:55] <pcwalton> I mean
[01:38:58] <pcwalton> don't use a trait
[01:39:12] <strcat> pcwalton: it would be I guess, but you rarely call next yourself
[01:39:58] *** Quits: seth (seth@moz-BE33DA21.fw1.sfo1.mozilla.net) (Input/output error)
[01:40:10] <strcat> rusti: use std::iterator::*; let xs = [1, 2, 3, 4, 5]; xs.iter().transform(|&x| x * 2).take_while(|&x| x < 6).fold(0, |a, b| a + b)
[01:40:11] -rusti- 6
[01:41:00] *** Joins: alisdair (textual@moz-EA60A466.dedicated.allstream.net)
[01:41:28] <pcwalton> well, I think we aren't realistically going to rip out iterators at this point and some of the traversals in Servo are complicated enough that I wouldn't want to write them in an external style, but
[01:41:41] <pcwalton> I think you have a strong argument that "for" should support external iterators in a first class way
[01:41:44] <pcwalton> I think we could overload
[01:41:54] <bjz> pcwalton: https://mail.mozilla.org/pipermail/rust-dev/2013-April/003731.html https://github.com/Jeaye/q3/blob/master/src/math/vec3.rs
[01:42:04] <strcat> pcwalton: a lang item for Iterator? and eventually Iterable, ideally
[01:42:12] <pcwalton> yeah, something like that
[01:42:43] <pcwalton> bjz: we all know what the need is.
[01:42:43] *** Joins: annodomini (lambda@moz-9AC5B452.hsd1.ma.comcast.net)
[01:43:23] <heftig> strcat: hm, why fn transform instead of fn map?
[01:43:31] *** Quits: dylukes (dylukes@moz-E4DF3FED.pitbpa.fios.verizon.net) (Quit: ["Textual IRC Client: www.textualapp.com"])
[01:43:32] <strcat> heftig: method resolve conflicts
[01:43:44] <heftig> what's map?
[01:43:52] <strcat> heftig: it's a bug
[01:43:59] <strcat> it thinks impl<T: Iterator> IteratorUtil for T {} conflicts with *all* T
[01:44:00] <pcwalton> bjz: last I talked to him the problem was that trait inheritance was busted
[01:44:08] <pcwalton> so you had to say Add<>+Sub<>+Mul<> etc
[01:44:10] <strcat> even things that aren't iterators
[01:44:14] <pcwalton> having :: wouldn't help there
[01:44:35] <strcat> heftig: so if IteratorUtil is in scope, you can't have any methods named take, filter, fold, etc. on anything
[01:44:44] <strcat> silly bug
[01:45:49] <strcat> pcwalton: I would be perfectly happy if 'for' worked on both, but I'm not sure how you'd deal with ambiguity though
[01:46:26] <strcat> hmm
[01:46:32] <strcat> I guess a user can't implement Iterator on 'fn'
[01:46:36] <strcat> so maybe that's not an issue
[01:46:47] <pcwalton> also the call will have one fewer argument
[01:47:02] *** Quits: Amanieu (amanieu@moz-D5D10CA8.halls.manchester.ac.uk) (Connection reset by peer)
[01:47:02] <strcat> function -> internal iterator, not a function -> look for Iterator, not an Iterator -> look for Iterable
[01:47:15] <pcwalton> this sounds like Rust 2.0 though
[01:47:20] <pcwalton> I'm worried about the complexity budget here
[01:47:42] <strcat> pcwalton: I don't think it's that complicated since python's takes 2 kinds of things and no one gets confused
[01:47:47] *** Joins: Amanieu (amanieu@moz-D5D10CA8.halls.manchester.ac.uk)
[01:47:53] <pcwalton> python also doesn't have regions
[01:48:07] <pcwalton> or algebraic data types, or inherited mutability, or 3 kinds of pointers
[01:48:18] <strcat> pcwalton: well external iterators handle lifetimes better ;p
[01:48:30] <strcat> internal ones need multiple variants for each algorithm like 'fold'
[01:48:38] <strcat> I talked to niko about it for a while
[01:48:40] <strcat> doesn't seem avoidable
[01:48:57] <strcat> fn(&T) is a function expecting &T in *any* region
[01:49:26] <strcat> so internal iterator adaptors either have to work for anything, except borrowed pointers or borrowed pointers
[01:49:51] <strcat> the errors are pretty confusing from that
[01:50:26] <strcat> pcwalton: I need to add min_ref, max_ref, any_ref, all_ref, etc. to iter
[01:50:37] <strcat> the external ones work fine without it
[01:50:42] <strcat> since there aren't closures
[01:52:35] <pcwalton> can we prototype this with a syntax extension first
[01:53:27] <dbaupp> pcwalton: I don't think a syntax extension can do the fn/Iterator/Iterable fallback correctly (assuming that's what you're talking about)
[01:53:37] <pcwalton> well, it can if you specify which one you want
[01:53:54] <dbaupp> yeah, that'd work
[01:54:08] <pcwalton> it could just desugar to advance()
[01:54:21] <pcwalton> foreach!()
[01:55:44] <dbaupp> `macro_rules! foreach( (fn: $f:expr) => ( $f ); (Iterator: $it:expr) => ( ($it).advance ); (Iterable: $it:expr) => ( ($it).iter().advance ) )`, maybe
[01:55:46] <pcwalton> strcat: is the reason you can't call advance() each() because of the method name conflict bug?
[01:55:53] <strcat> pcwalton: yes
[01:55:57] <brson> bisect fingers "Omit unused implicit argument if return type is immediate." as the culprit of the incoming bustage. this is a bootstrapping + cross-compile problem that I think I can figure out how to work around
[01:55:58] <pcwalton> ok, let's fix that bug
[01:56:03] <strcat> pcwalton: also why IteratorUtil isn't in prelude
[01:57:37] <pcwalton> can we make it "for [ 1, 2, 3 ].each { ... }" and implement Iterator methods on Iterables?
[01:57:40] *** Quits: carllerche (carllerche@6B070D22.7E6A0813.1428D117.IP) (Quit: carllerche)
[01:57:45] <pcwalton> assuming all method bugs are fixed
[01:58:02] <strcat> pcwalton: well we don't actually have Iterable yet
[01:58:13] <strcat> and I think we'd want default methods first
[01:58:15] <pcwalton> I mean, to me that seems like the best of all worlds
[01:58:38] <strcat> pcwalton: problem is that iterators provide things like 'find' that you don't want on a map
[01:58:46] <strcat> they could just be free functions...
[01:58:51] <strcat> methods chain well
[01:58:57] <pcwalton> you can make internal or external iterators if you want with about equal difficulty, and the syntax is equally usable
[01:59:06] <brson> in gdb, how do I run a program repeatedly until it crashes?
[01:59:07] <pcwalton> and "for" stays relatively simple
[01:59:37] <strcat> brson: more than what 'run' does?
[02:00:17] <strcat> pcwalton: you still need .reversed().each though
[02:00:37] <pcwalton> that seems OK to me
[02:00:45] <bjz> strcat: are you ok with this? https://gist.github.com/bjz/e8a0895152e62ed478b4
[02:01:01] <cmr> brson: hit enter a bunch of times
[02:01:15] <cmr> no better way afaik, though you might be able to script it with python
[02:01:22] <strcat> pcwalton: I don't really think we can impl Iterator for Iterable though because of all the methods it would bring along
[02:01:30] <strcat> find, contains, max, min, etc.
[02:01:46] <strcat> max/min should be O(1) or O(logn) on some containers
[02:02:04] <bjz> strcat: I'm not sure if that fits with the things you guys are talking about. I had it committed on my local repo, but I'm thinking maybe I should revert
[02:02:17] <pcwalton> isn't the only one you really need each() though?
[02:02:31] <pcwalton> for easy use in "for"
[02:02:43] <dbaupp> bjz: I'm guessing that he'd prefer external iterators for the range* fns
[02:02:57] <bjz> dbaupp: ok
[02:03:12] <bjz> dbaupp: so range would be removed?
[02:03:15] <strcat> dbaupp: don't really need those, they can just be in iterator.rs
[02:03:22] <bjz> dbaupp: or altered?
[02:03:25] <strcat> like Counter
[02:03:34] <dbaupp> strcat: doesn't it get fiddly with unsigned numbers and wrap around?
[02:03:38] *** Quits: azita (Azita@2557E599.66715431.D25A875A.IP) (Quit: azita)
[02:03:54] <dbaupp> strcat: or have we resolved that?/does this resovle that?
[02:04:01] <strcat> pcwalton: well ideally they all be easy to use, it's common to zip/map/filter
[02:04:14] <pcwalton> so is "yield" even possible to do in a language with regions?
[02:04:16] <pcwalton> has anyone done it?
[02:04:29] <pcwalton> jld points out that this may be research
[02:04:51] <pcwalton> which is fine, but not for 1.0 at this point :)
[02:05:06] <cmr> yield as in generators/coroutines?
[02:05:09] <pcwalton> yes
[02:05:21] <strcat> cmr: yield as in state machines :P
[02:05:22] *** Quits: reyre_ (reyre@moz-9002CDDA.cpe.net.cable.rogers.com) (Client exited)
[02:05:37] <cmr> Easy to emulate with tasks
[02:05:50] <strcat> cmr: but really slow.
[02:05:52] <pcwalton> sure, but we're talking about regions
[02:05:57] *** Joins: rustyFriend (Mibbit@moz-9FB1258A.c3-0.43d-ubr2.qens-43d.ny.cable.rcn.com)
[02:06:07] <strcat> pcwalton: yeah, but I don't really think it would be very special in that regard
[02:06:23] <strcat> pcwalton: it's just sugar for something we can already do
[02:06:50] *** Quits: hjr3 (hradtke@1A0AE795.28A5F6C3.A2D40ED2.IP) (Quit: My MacBook has gone to sleep. ZZZzzzâ€¦)
[02:07:29] *** Quits: jyeo (user@moz-FEFE526F.cpe.net.cable.rogers.com) (Ping timeout)
[02:08:32] <strcat> pcwalton: local variables are struct fields, 'yield' is return, recursion pushes a copy of the struct into a vector
[02:08:51] *** Quits: jorendorff (jorendorff@moz-2F32ACA3.hsd1.tn.comcast.net) (Quit: jorendorff)
[02:09:00] <pcwalton> I think that may interact weirdly with the borrow check and such
[02:09:14] <pcwalton> I haven't really thought about it but this is definitely research
[02:09:46] <pcwalton> for example, copying all locals definitely has move implications
[02:10:17] *** Quits: pcwalton (pcwalton@moz-BE33DA21.fw1.sfo1.mozilla.net) (Quit: pcwalton)
[02:10:33] *** Quits: MrFahrenheit (RageOfThou@3FEF494C.29C984D5.783DEDCA.IP) (Ping timeout)
[02:11:00] *** Joins: a_m0d (a_m0d@moz-9F925EFA.hm.shawcable.net)
[02:12:32] *** Joins: bytbox (s@moz-D83E9B31.wireless.umd.edu)
[02:14:27] *** Quits: bytbox (s@moz-D83E9B31.wireless.umd.edu) (Ping timeout)
[02:15:25] *** Joins: bytbox (s@moz-D83E9B31.wireless.umd.edu)
[02:17:46] *** Joins: ysuzuki (ysuzuki@moz-A563888C.ics.keio.ac.jp)
[02:18:18] *** Quits: bytbox (s@moz-D83E9B31.wireless.umd.edu) (Ping timeout)
[02:19:57] *** Joins: bytbox (s@moz-D83E9B31.wireless.umd.edu)
[02:20:03] *** Quits: Earnestly (earnest@6A917A59.5E1FD793.39C00A7A.IP) (Ping timeout)
[02:25:51] *** Joins: devbug_ (quassel@moz-E1DE087C.bchsia.telus.net)
[02:29:48] *** Quits: emartin (emartin@moz-C3D4EEBF.caltech.edu) (Quit: leaving)
[02:29:58] *** Joins: infynyxx (infynyxx@moz-E95B370B.nyc.res.rr.com)
[02:30:00] *** Quits: Jesse (jruderman@2557E599.66715431.D25A875A.IP) (Quit: Jesse)
[02:30:05] *** Joins: kimundi_ (kimundi@moz-28AE5A0F.dip0.t-ipconnect.de)
[02:30:28] *** Joins: Jesse (jruderman@2557E599.66715431.D25A875A.IP)
[02:31:12] *** Quits: kimundi (kimundi@moz-E1F5D4A6.dip0.t-ipconnect.de) (Ping timeout)
[02:31:12] *** kimundi_ is now known as kimundi
[02:36:37] *** Joins: mattin (user@9E32F7E8.DC7A989C.7F8AB798.IP)
[02:39:15] *** Joins: eatkinson (eatkinson@moz-5CF47426.dia.static.qwest.net)
[02:40:37] *** Joins: hjr3 (hradtke@moz-E87BDF1F.socal.res.rr.com)
[02:43:32] <cmr> Whoa
[02:43:37] <cmr> LZ4 cuts the test suite time in half
[02:43:39] *** Quits: jrfeenst (jrfeenst@moz-F912484F.cpe.norwoodlight.com) (Quit: jrfeenst)
[02:43:43] <cmr> brson: Maybe it *is* worth it
[02:43:52] <cmr> Although I've been looking at different algorithms
[02:44:00] <cmr> Snappy/Yappy or Dozob look promising
[02:44:14] <engla> what does lz4 do for the testsuite?
[02:44:30] <cmr> engla: decompressing metadata is way faster with LZ4
[02:44:32] <aatch> Hah! those sound like Warner Bros. characters
[02:44:40] <cmr> every time you compile, you decompress the metadata of at least std
[02:44:44] <engla> hm ok. yeah lz4 is very fast
[02:45:04] *** Joins: sk (sk@61A494B3.BA40E8A.AAC02D62.IP)
[02:45:17] <cmr> It doesn't compress as well, though, which isn't great.
[02:45:37] <engla> I know. lz4 is byte-oriented
[02:45:50] <brson> cmr: that sounds pretty awesome. can you get numbers for the full 'make check' before and after?
[02:46:11] <cmr> brson: It was 7:something with, 14:20 without
[02:46:32] <cmr> That doesn't sound right though
[02:46:40] <cmr> Let me try with again
[02:46:41] <brson> cmr: does that include building rustc or just running the tests?
[02:46:48] <cmr> brson: just tests
[02:46:54] <dbaupp> cmr: how does it cut it in half?? isn't the theoretical maximum (with an empty file) a gain of ~20%?
[02:46:55] <jclements> that seemsâ€¦ implausible?
[02:47:00] <dbaupp> cmr: awesome, nonetheless
[02:47:10] <cmr> dbaupp: yeah, it doesn't seem right to me.
[02:47:44] <dbaupp> aatch: have you solved that LLVM segfault?
[02:48:27] <aatch> dbaupp, no, it's some wierd thing related to use-after-free but I have no idea where.
[02:48:45] <aatch> The API was pretty unusable though in a real situation, so I'm re-writing it.
[02:49:32] <aatch> Gonna have to lose most of the type-safety stuff.
[02:49:40] <dbaupp> I see. it'll be nice the second time around :)
[02:49:56] <dbaupp> oh, it's too large a burden?
[02:50:09] <aatch> Pretty much. Especially with trait objects being so buggy
[02:53:21] *** Quits: EXetoC (ex@moz-C741B177.customer.t3.se) (Quit: WeeChat 0.4.1)
[02:54:50] *** Joins: sanxiyn (tinuviel@858F408C.B797260D.EF43EC08.IP)
[02:55:43] <sanxiyn> I noticed that http://static.rust-lang.org/doc/std/index.html now points to what was previously core
[02:55:53] <aatch> Cool
[02:56:11] <sanxiyn> I think front page link needs update?
[02:56:16] *** Quits: Sodel_the_V (user@moz-853663E1.va.shawcable.net) (Input/output error)
[02:56:39] *** Quits: ysuzuki (ysuzuki@moz-A563888C.ics.keio.ac.jp) (Client exited)
[02:56:41] <dbaupp> and the introduction to core/std needs an update...
[02:56:44] <sanxiyn> At http://www.rust-lang.org/ Trunk/Standard link to /std/, which is probably not you want
[02:57:06] <sanxiyn> dbaupp: Ah yes front page sample also needs update I guess
[02:57:18] <sanxiyn> Or is that to be done after 0.7 is released?
[02:57:24] <sanxiyn> But trunk doc link needs update now
[02:57:26] <dbaupp> sanxiyn: you were working on SIMD, right? Has there been any progress on doing operations with them?
[02:57:37] <sanxiyn> dbaupp: Sorry, no
[02:57:37] *** Joins: ghrust (ghrust@AD60B2E3.6A2AE50.F3114085.IP)
[02:57:37] <ghrust> 01[13rust01] 15bors 04force-pushed 06auto from 1477a2a43 to 14f5ef076: 02http://git.io/N3iJvQ
[02:57:37] *** Parts: ghrust (ghrust@AD60B2E3.6A2AE50.F3114085.IP) ()
[02:57:39] *** Joins: ghrust (ghrust@C8693FCB.6A2AE50.F3114085.IP)
[02:57:39] <ghrust> 01[13rust01] 15bors pushed 2 new commits to 06auto: 02http://git.io/d_9Y9g
[02:57:39] <ghrust> 13rust/06auto 141ebb62f 15Michael Sullivan: Fix stat.rs to not pollute the build directory. Closes #6959.
[02:57:39] <ghrust> 13rust/06auto 144a19af1 15bors: auto merge of #6960 : msullivan/rust/fix-pollution, r=brson
[02:57:39] *** Parts: ghrust (ghrust@C8693FCB.6A2AE50.F3114085.IP) ()
[02:57:48] <dbaupp> sanxiyn: there's is the 0.6 docs http://static.rust-lang.org/doc/0.6/core/index.html
[02:58:02] <sanxiyn> dbaupp: Yes I know
[02:58:04] <dbaupp> so the trunk doc update could be done now
[02:58:08] <sanxiyn> yes
[02:58:11] <dbaupp> sanxiyn: oh, I see, thanks :)
[02:58:15] <dbaupp> (re SIMD)
[02:58:24] <sanxiyn> Re: SIMD, current status is
[02:58:26] <cmr> Why is it called trunk? What does trunk even mean?
[02:58:47] <sanxiyn> cmr: I guess it means "main branch", as in tree
[02:58:56] <dbaupp> it's the pointy end of an elephant? like the pointy end of the code?
[02:58:59] * dbaupp is guessing
[02:59:05] <sanxiyn> dbaupp: I don't think so
[02:59:05] *** Quits: alisdair (textual@moz-EA60A466.dedicated.allstream.net) (Quit: My MacBook Pro has gone to sleep. ZZZzzzâ€¦)
[02:59:08] <dbaupp> hehe
[02:59:16] <aatch> it's the "trunk" of the tree
[02:59:22] <aatch> of which you branch
[02:59:25] <aatch> off*
[02:59:39] <aatch> it's a little archaic in a DVCS world
[02:59:55] <sanxiyn> dbaupp: This comment
[02:59:56] <sanxiyn> https://github.com/mozilla/rust/pull/6214#issuecomment-17381713
[03:00:02] <sanxiyn> is still not resolved
[03:00:11] <sanxiyn> On the other hand, https://github.com/mozilla/rust/pull/6725 needs exactly same thing
[03:00:19] <sanxiyn> (Passing type context to type_is_immediate)
[03:00:22] * strcat is writing a long email about iterators to the mailing list ;p
[03:00:33] <sanxiyn> So I tried to rebase #6725 myself and run test, but it results in LLVM crash :(
[03:00:36] <sanxiyn> So that is the current status
[03:00:37] <strcat> cmr: snappy is terrible on non-x86
[03:00:44] <strcat> cmr: it relies on unaligned memory access to be fast
[03:00:52] <dbaupp> sanxiyn: I see. so it's not trivial :(
[03:00:54] *** Quits: brson (brson@2557E599.66715431.D25A875A.IP) (Ping timeout)
[03:00:55] <strcat> google wrote it for google's use cases on x86_64 servers
[03:01:17] <bjz> why do I get these errors? https://gist.github.com/bjz/7ccf949e65e361863cd2
[03:01:24] <sanxiyn> dbaupp: Eh... once that is done, it is matter of forward porting old SIMD patches here
[03:01:25] <sanxiyn> https://github.com/mozilla/rust/pull/5841
[03:01:25] <strcat> ofc there's no reason we have to use the same compression algorithm everywhere.
[03:01:31] *** Joins: royw (royw@moz-E9B4079C.hsd1.ca.comcast.net)
[03:01:31] <sanxiyn> (Last 3 patches)
[03:01:33] <strcat> just want to point out that snappy is awful on ARM, etc. ;p
[03:01:37] <bjz> I thought you could do multiple impls with different bounds?
[03:01:50] <bjz> ie. libstd/option.rs
[03:01:51] <dbaupp> bjz: I think you can, but possibly not with static functions
[03:01:53] <sanxiyn> dbaupp: That is, I know which parts I need to change to get operations on SIMD working
[03:01:56] <strcat> bjz: yes but not static method, if that's what you're doing
[03:01:59] * bjz cries
[03:01:59] <strcat> methods*
[03:02:02] <strcat> bjz: I reported it
[03:02:04] <bjz> whyyyy
[03:02:08] <aatch> bjz, I know, I know.
[03:02:14] <strcat> bjz: it seems like it might be problematic :(
[03:02:22] <strcat> as in hard to fix
[03:02:25] <strcat> from what niko said
[03:02:27] <bjz> *face desk facedesk*
[03:02:34] *** Joins: jorendorff (jorendorff@moz-2F32ACA3.hsd1.tn.comcast.net)
[03:02:34] <sanxiyn> By the way, has anyone encountered this? (Is there an issue?)
[03:02:39] <dbaupp> bjz: I've continually tried to update extra::complex to close some feature-bugs, but I keep hitting this :/
[03:02:43] <sanxiyn> pub struct S { ... }
[03:02:48] <sanxiyn> pub type X = S;
[03:02:48] <strcat> bjz: anyway first things first, a long email on why internal iterators suck in rust
[03:02:50] <strcat> bjz: ;p
[03:03:04] <dbaupp> sanxiyn: ok, cool! looking forward to SIMD when it does land :)
[03:03:08] <sanxiyn> And in different crate, you can do S { ... } but not X { ... }
[03:03:19] <bjz> nmatsakis: :( https://gist.github.com/bjz/7ccf949e65e361863cd2
[03:03:22] <sanxiyn> (Is that even supposed to work...?)
[03:03:31] <bjz> nmatsakis: apparently it'll be hard to fix?
[03:03:53] <bjz> strcat: is there an issue?
[03:03:56] <sanxiyn> That is, if you typedef, type can be used in different crate, but value (type constructor?) can't
[03:04:07] <strcat> bjz: yes
[03:04:07] <bjz> because dbaupp and I can pile on
[03:04:08] <bjz> :)
[03:04:24] *** Quits: bytbox (s@moz-D83E9B31.wireless.umd.edu) (Ping timeout)
[03:04:31] <dbaupp> bjz: http://static.rust-lang.org/doc/0.6/core/index.html
[03:04:35] *** Quits: tedh (tedh@moz-F0B37C08.hsd1.il.comcast.net) (Connection reset by peer)
[03:04:38] <dbaupp> bjz: https://github.com/mozilla/rust/issues/4228
[03:04:41] <dbaupp> oops, wrong clipboard
[03:05:05] <bjz> heh
[03:05:41] <strcat> ah yeah that's it
[03:05:53] <strcat> anyway I have to finish this email :)
[03:06:48] *** Joins: tedh (tedh@moz-F0B37C08.hsd1.il.comcast.net)
[03:09:38] *** Quits: Sorella (queen@B12A78F5.BA14766C.95C8B7C6.IP) (Quit: (quit))
[03:09:46] *** Quits: a_m0d (a_m0d@moz-9F925EFA.hm.shawcable.net) (Quit: Leaving.)
[03:10:02] <bjz> dbaupp: cheers
[03:10:14] <bjz> votes to the cause!
[03:10:28] <bjz> moonchrome: https://github.com/mozilla/rust/issues/4228
[03:10:57] <bjz> might be a while before we can fix things then, even if we decide to ditch typeclasses
[03:11:34] *** Quits: annodomini (lambda@moz-9AC5B452.hsd1.ma.comcast.net) (Quit: annodomini)
[03:11:38] <dbaupp> ditch typeclasses??
[03:12:52] *** Quits: nooy (user@moz-2458675D.a146.priv.bahnhof.se) (Client exited)
[03:13:48] <bjz> dbaupp: yeah, we're going to be impling directly onto the Vecs
[03:13:57] <bjz> dbaupp: OO style
[03:14:15] <bjz> dbaupp: oh, as in for lmath
[03:14:18] *** Joins: annodomini (lambda@moz-9AC5B452.hsd1.ma.comcast.net)
[03:14:19] <bjz> not for Rust
[03:14:40] <dbaupp> bjz: oh, right... I was concerned for a second
[03:14:44] <bjz> heh
[03:14:47] <bjz> dw
[03:15:07] <bjz> dbaupp: me and moonchrome think it will probably be easier
[03:15:14] <dbaupp> that'll make the code repeat a lot? or will the magic happen via macros?
[03:15:21] <bjz> dbaupp: yeah
[03:16:24] <bjz> but I think with the direction traits are heading it'll be easier to do it that way
[03:17:12] <moonchrome> bjz I'm beginning to see why he used macros
[03:17:17] <bjz> yeah
[03:18:24] <moonchrome> bjz, thing about macros is you can use them to generate modules and then you don't have the problem of overloading
[03:18:37] <bjz> yep
[03:18:43] <moonchrome> bjz, so vec3f::dot(v1, v2)
[03:18:54] <moonchrome> where vec3f is a module
[03:19:02] <bjz> but the language should support that
[03:19:07] <moonchrome> and vec3f::Vec3f is the type
[03:19:17] <bjz> we shouldn't have to do macro hacks
[03:20:23] <bjz> dot should be an associated function
[03:20:48] <bjz> It would be amazing to do things like: T::size_of(), etc.
[03:21:01] <bjz> or float::pi()
[03:22:09] <bjz> but the issue is whether that's wtf or not
[03:22:14] <bstrie> erick: ping
[03:22:22] * bstrie hopes erick == erickt
[03:22:35] <moonchrome> bjz, well it's on a to-do right ?
[03:22:56] <bjz> moonchrome: if you were reading along the lengthy discussion, that's not planned
[03:23:34] <moonchrome> bjz, from what I've understood they just chose a different syntax ?
[03:24:05] <moonchrome> bjz, or are associated items completely scrapped
[03:24:13] *** Quits: RMF (RMF@68B6AD91.A3D80C3C.8D19547B.IP) (Ping timeout)
[03:24:22] <bjz> moonchrome: associated items will come
[03:25:01] <bjz> moonchrome: but it will be more difficult to use them if they are defined in traits
[03:25:11] <bjz> moonchrome: as opposed to directly on types
[03:26:57] *** Quits: bjz (brendanzab@B398BE78.F804C29E.D35A31DF.IP) (Ping timeout)
[03:27:17] *** Joins: bjz (brendanzab@B398BE78.F804C29E.D35A31DF.IP)
[03:27:26] *** Quits: rustyFriend (Mibbit@moz-9FB1258A.c3-0.43d-ubr2.qens-43d.ny.cable.rcn.com) (Quit: http://www.mibbit.com ajax IRC Client)
[03:28:07] *** Quits: sanxiyn (tinuviel@858F408C.B797260D.EF43EC08.IP) (Quit: Leaving)
[03:31:08] *** Joins: bjz_ (brendanzab@B398BE78.F804C29E.D35A31DF.IP)
[03:31:09] *** Quits: bjz (brendanzab@B398BE78.F804C29E.D35A31DF.IP) (Connection reset by peer)
[03:32:33] *** Quits: jclements (jclements@moz-20AD2EFB.dsl.static.sonic.net) (Quit: jclements)
[03:33:15] *** Joins: nooy (user@moz-2458675D.a146.priv.bahnhof.se)
[03:34:04] <dbaupp> bjz_: Haskell's equivalent of associated items are all defined on type classes, and their APIs aren't particularly bad, I don't think
[03:34:11] <bblum> wow, i am surprised and pleased that this works
[03:34:12] <bblum> https://gist.github.com/bblum/5719126
[03:34:27] <bblum> istr trying this before and it probably crashed the compiler or something
[03:34:28] *** Joins: bytbox (s@moz-D83E9B31.wireless.umd.edu)
[03:35:36] *** Joins: jack (jack@8ABE2BFB.9F8380A1.A535BD55.IP)
[03:35:55] <cmr> you're allowed to do that?
[03:36:15] <cmr> I thought named lifetimes needed to be explicit
[03:36:19] <cmr> ie, fn foo<'a>
[03:36:37] *** Joins: Yurume (yurume@AC58A8CE.8A059B47.E313B915.IP)
[03:36:38] <bblum> iono, works either way
[03:36:45] <bblum> maybe my way is deprecated
[03:36:51] <heftig> IIRC it is
[03:37:04] <heftig> that's going away. you need to specify the lifetime parameter explicitly
[03:37:37] *** Quits: jgilbert (jgilbert@2557E599.66715431.D25A875A.IP) (Ping timeout)
[03:37:38] <dbaupp> rusti: fn foo(a: &'a uint) {}
[03:37:39] -rusti- <anon>:10:23: 10:27 error: Illegal lifetime 'a: this lifetime must be declared
[03:37:39] -rusti- <anon>:10          fn foo(a: &'a uint) {}
[03:37:39] -rusti-                                  ^~~~
[03:37:39] -rusti- error: aborting due to previous error
[03:37:39] -rusti- application terminated with error code 101
[03:37:49] <xenocons> hmm
[03:37:54] <dbaupp> rusti: fn foo(a: &fn(&'a uint)) {}
[03:37:55] -rusti- <anon>:10:27: 10:31 error: Illegal lifetime 'a: this lifetime must be declared
[03:37:55] -rusti- <anon>:10          fn foo(a: &fn(&'a uint)) {}
[03:37:55] -rusti-                                      ^~~~
[03:37:55] -rusti- error: aborting due to previous error
[03:37:55] -rusti- application terminated with error code 101
[03:38:09] <dbaupp> rusti: fn foo(a: &'a fn(&uint)) {}
[03:38:09] -rusti- <anon>:10:23: 10:25 error: Illegal lifetime 'a: this lifetime must be declared
[03:38:09] -rusti- <anon>:10          fn foo(a: &'a fn(&uint)) {}
[03:38:10] -rusti-                                  ^~
[03:38:10] -rusti- error: aborting due to previous error
[03:38:10] -rusti- application terminated with error code 101
[03:38:21] <heftig> rusti: fn foo(a: &fn<'a>(&'a uint)) {}
[03:38:22] -rusti- ()
[03:38:30] <bblum> oh, guess i'm on an old version
[03:38:35] *** Quits: jld (jld@moz-B94C75AD.xlerb.net) (Input/output error)
[03:38:39] <dbaupp> rusti: fn foo(a: fn(&'a fn())) {}
[03:38:42] -rusti- more than 5 lines of output, pastebinned: http://sprunge.us/MBOF
[03:38:54] <dbaupp> rusti: fn foo(a: &fn(&'a fn())) {}
[03:38:55] -rusti- <anon>:10:27: 10:29 error: Illegal lifetime 'a: this lifetime must be declared
[03:38:55] -rusti- <anon>:10          fn foo(a: &fn(&'a fn())) {}
[03:38:55] -rusti-                                      ^~
[03:38:55] -rusti- error: aborting due to previous error
[03:38:55] -rusti- application terminated with error code 101
[03:39:24] <bblum> rusti: fn foo<'a>(blk: &fn(blk2: &'a fn() -> &'a fn())) { let bar: &fn() = || {}; do blk || { bar } }
[03:39:25] -rusti- ()
[03:39:29] <bblum> nice.
[03:39:59] *** Quits: SiegeLord (sl@moz-CAF07B4C.hsd1.ma.comcast.net) (Quit: It's a joke. It's all a joke.)
[03:41:08] *** Quits: jack (jack@8ABE2BFB.9F8380A1.A535BD55.IP) (Quit: Leaving.)
[03:42:15] *** Quits: mattin (user@9E32F7E8.DC7A989C.7F8AB798.IP) (Quit: Leaving)
[03:42:21] *** Quits: lmandel (lmandel@FE1F74.86ED00A7.971E19F6.IP) (Quit: lmandel)
[03:43:50] <royw> is unsafe::reinterpret_cast the best workaround for https://github.com/mozilla/rust/issues/3868?
[03:44:48] <strcat> royw: no, that's not safe
[03:44:48] *** Joins: ysuzuki (ysuzuki@moz-A563888C.ics.keio.ac.jp)
[03:44:55] <strcat> if you have
[03:44:59] <strcat> enum Foo { A = 1, B = 2 }
[03:45:06] <strcat> storing 3 in it would be very undefined
[03:45:10] <dbaupp> royw: cast::transmute is probably better, but it breaks things
[03:45:20] <strcat> royw: you could use a match expression
[03:45:38] <dbaupp> rusti: enum Foo { A = 1, B = 2 } match cast::transmute(3) { A => "a", B => "b" }
[03:45:40] -rusti- more than 5 lines of output, pastebinned: http://sprunge.us/IdOW
[03:45:50] <dbaupp> rusti: enum Foo { A = 1, B = 2 } match unsafe { cast::transmute(3) } { A => "a", B => "b" }
[03:45:51] -rusti- more than 5 lines of output, pastebinned: http://sprunge.us/YLFd
[03:45:59] <dbaupp> rusti: enum Foo { A = 1, B = 2 } match unsafe { std::cast::transmute(3) } { A => "a", B => "b" }
[03:46:01] -rusti- more than 5 lines of output, pastebinned: http://sprunge.us/NfcO
[03:46:02] <royw> strcat:  OK, so I need to hand roll a conversion function
[03:46:08] <strcat> royw: yeah, you can use 'match'
[03:46:17] *** Quits: orshem (orshem@19491716.F0FDCE77.E3D28531.IP) (Quit: WeeChat 0.4.0)
[03:46:23] <dbaupp> rusti: enum Foo { A = 1, B = 2 } match unsafe { std::cast::transmute::<uint, A>(3) } { A => "a", B => "b" }
[03:46:24] -rusti- more than 5 lines of output, pastebinned: http://sprunge.us/MOOe
[03:46:25] *** Quits: devbug_ (quassel@moz-E1DE087C.bchsia.telus.net) (Client exited)
[03:46:40] <dbaupp> rusti: enum Foo { A = 1, B = 2 } match unsafe { std::cast::transmute::<uint, Foo>(3) } { A => "a", B => "b" }
[03:46:41] -rusti- "b"
[03:46:58] <strcat> royw: from_int(x: int) -> Option<YourEnum> { match x { 1 => Some(A), 2 => Some(B), _ => None } }
[03:47:01] <strcat> royw: something like that
[03:47:12] <cmr> that doesn't make sense
[03:47:25] <royw> strcat: thanks
[03:47:30] <strcat> cmr: it does, it's undef behaviour
[03:47:43] <strcat> cmr: LLVM optimizes the last case to the default branch
[03:47:48] <cmr> dbaupp: yeah the testsuite actually takes *longer* to run with LZ4, not sure what happened that I got 7 minutes before...
[03:47:50] <strcat> if it falls off the end, it goes to the last case
[03:47:52] <strcat> it can reorder them
[03:48:00] <dbaupp> cmr: oh :(
[03:48:02] <strcat> cmr: oh, something else doesn't make sense? :p
[03:48:04] *** Quits: hjr3 (hradtke@moz-E87BDF1F.socal.res.rr.com) (Quit: Textual IRC Client: www.textualapp.com)
[03:48:06] <dbaupp> cmr: that's a bit strange?
[03:48:16] <cmr> dbaupp: not really. compression is slower.
[03:48:37] <strcat> cmr: it's compiled with optimizations, right?
[03:48:40] <cmr> because I use the HC mode to avoid bloat
[03:48:47] <cmr> strcat: what is, LZ4? yes
[03:48:47] <strcat> oh
[03:48:49] <cmr> -O3
[03:48:50] <dbaupp> cmr: executables write metadata, right?
[03:49:03] <cmr> dbaupp: no idea. I wouldn't think so...
[03:49:04] <dbaupp> is this necessary?
[03:49:05] <strcat> cmr: well I think with high compression it's slower than modern zlib at compressing, at least
[03:49:11] <cmr> strcat: it is, by half
[03:49:15] *** Joins: hjr3 (hradtke@moz-E87BDF1F.socal.res.rr.com)
[03:49:27] * strcat wrote a long iterator email
[03:49:31] <dbaupp> cmr: well, that's the only reason compressing would make the testsuite slower, isn't it
[03:49:36] <dbaupp> strcat: we don't use zlib
[03:49:41] <strcat> dbaupp: I know
[03:49:48] <strcat> but zlib is a good baseline comparison
[03:49:58] <strcat> and we *could* use zlib, it has a permissive license
[03:50:00] <dbaupp> cmr: (that is, writing metadata to an executable)
[03:50:14] <cmr> I'm ok with slow compression as long as compression ratio is reasonable, but it;s not, for LZ4
[03:50:35] *** Joins: adu (ajr@moz-96FE9B84.washdc.fios.verizon.net)
[03:50:58] <strcat> cmr: I'm curious what lzma2 (xz) at the lowest compression ratio is like
[03:51:23] <strcat> as in -1, whatever that translates to in the library
[03:52:26] <cmr> strcat: is there an lzma2 library?
[03:52:36] *** Quits: eatkinson (eatkinson@moz-5CF47426.dia.static.qwest.net) (Quit: eatkinson)
[03:52:50] <cmr> ah, http://tukaani.org/xz/
[03:53:31] <strcat> cmr: it has very slow compression and reasonable decompression speeds, but that's at -6
[03:53:35] <strcat> so I wonder what -1 is like
[03:53:57] <strcat> it's faster than bzip, for sure
[03:54:15] <dbaupp> cmr: it does appear that metadata is written to executables
[03:54:35] *** Joins: ghrust (ghrust@1E8607E8.6A2AE50.F3114085.IP)
[03:54:35] <ghrust> 01[13rust01] 15bors merged 06auto into 06incoming: 02http://git.io/d_9Y9g
[03:54:35] *** Parts: ghrust (ghrust@1E8607E8.6A2AE50.F3114085.IP) ()
[03:54:37] <dbaupp> cmr: middle/trans/base.rs:3159 if you're interested
[03:55:03] <cmr> dbaupp: one thing I noticed too is that the whole crate is compiled with --test, not just the tests. which makes sense, I guess, it if can't assume it has already been compiled as a library
[03:55:16] *** Quits: Jesse (jruderman@2557E599.66715431.D25A875A.IP) (Quit: Jesse)
[03:56:21] *** Quits: ysuzuki (ysuzuki@moz-A563888C.ics.keio.ac.jp) (Client exited)
[03:56:22] <cmr> but that's not the case for the rust build
[03:57:21] <strcat> dbaupp: http://ix.io/60D heh ;p, more like a blog post than a mailing list post but whatever :)
[03:58:05] <royw> strcat:  Bummer, I can't match against converting the enum
[03:58:22] <strcat> royw: hm?
[03:58:23] <royw> from_int(x: int) -> Option<YourEnum> { match x { (A as int) => Some(A), (B as int) => Some(B), _ => None } }
[03:58:32] <royw> srrcat isn't valid
[03:58:45] <strcat> royw: can't use 'as' in matches, sadly
[03:58:46] <royw> strcat^^
[03:59:02] *** Quits: wuwei`lab (wuwei@1A513F49.818D7924.FAA9ED67.IP) (Ping timeout)
[03:59:03] <strcat> have to hardcode the numbers again
[03:59:08] <royw> got it
[03:59:30] <strcat> royw: well, maybe you can use 'static a: int = A as int' and then match on 'a'
[03:59:35] <cmr> could you do "x as YourEnum" at all?
[03:59:37] <strcat> if you want to avoid repeating the values
[03:59:43] <strcat> cmr: nope
[03:59:48] <cmr> or some unsafe equivalent
[03:59:50] <cmr> shame
[04:00:09] <strcat> cmr: transmuting safely would be hard
[04:00:14] <strcat> and we don't have any stable enum ABI
[04:00:31] <strcat> you'd have to check that the integer was equal to a possible variant and then carefully transmute
[04:00:46] <adu> transmutation?!? sounds like magick
[04:00:59] <strcat> adu: it is, and alchemy is unsafe :)
[04:01:18] <adu> I have a name issue
[04:01:22] <cmr> and unsound
[04:01:30] <xenocons> working on my project in rust, excited :)
[04:01:45] <strcat> unsafe { let x: &int = std::cast::transmute(0); x }
[04:01:52] <strcat> rusti: unsafe { let x: &int = std::cast::transmute(0); x }
[04:01:54] -rusti- application terminated abnormally with signal 11 (Segmentation fault)
[04:02:01] <dbaupp> strcat: looks good!
[04:02:04] <adu> I'm trying to write my own getopts mod, and it turns out I need nullable pointers, or Option<T>, and it sounds too much like Opt that I'm using for the option descriptors
[04:02:09] <dbaupp> strcat: (the email)
[04:03:19] <strcat> adu: well, call those switches ;p
[04:03:36] <strcat> switches/arguments
[04:03:42] <strcat> or just parameters
[04:04:25] <adu> strcat: that would violate the principle of least surprise
[04:04:38] <strcat> adu: why?
[04:04:57] <cmr> adu: I don't think so. getopt is the only thing that calls them options, everything "modern" calls them arguments or parameters
[04:05:00] <strcat> Option is a rust idiom, it's even in prelude
[04:05:03] <adu> because there are dozens of getopts packages for other languages, and they all use "opt"
[04:05:26] <adu> I suppose I could stick with Option and Opt
[04:05:40] <adu> it just sounds odd
[04:06:17] <adu> I could do OptDesc, then provide functions like std::getopts does
[04:06:32] <bjz_> adu: Option comes from ML
[04:06:45] <strcat> dbaupp: now the hard part, the subject :)
[04:06:58] <adu> bjz_: I've never used ML, I come from a Haskell background (which uses Maybe)
[04:07:09] <bjz_> adu: In haskell it's called Maybe, but ML came first
[04:07:10] <bjz_> :)
[04:07:10] <strcat> bjz_: well also 'option type' in type theory
[04:07:17] <adu> bjz_: understood
[04:07:36] <bjz_> adu: but at the end of the day, it's just a name :)
[04:07:36] <adu> right, lots of other things, like C++ boost calls it option too i think
[04:07:40] <strcat> ocaml, scala and boost call them options :)
[04:07:42] <strcat> adu: yeah
[04:07:58] <adu> anyways, maybe I shouldn't complain
[04:08:29] *** Joins: z0w0 (zack@moz-991DC1C4.lnse1.cha.bigpond.net.au)
[04:08:34] <bjz_> adu: I think it's one of those things you get used to
[04:08:52] <bjz_> z0w0: hoya
[04:09:14] <adu> well, wanna see what I have so far?
[04:09:21] <adu> https://gist.github.com/andydude/ec0911fb0298ac0eb8f1
[04:09:32] *** Joins: pcwalton (pcwalton@moz-481A040C.hsd1.ca.comcast.net)
[04:09:32] *** ChanServ sets mode: +o pcwalton
[04:09:53] <adu> the idea is to be closer to glib's GOption library
[04:10:04] <adu> which also handles usage() for you
[04:10:49] <strcat> pcwalton: sending off an email about the iterator thing to the mailing list btw
[04:10:56] <pcwalton> strcat: ok
[04:11:04] <pcwalton> I'm circulating something around the core team
[04:11:14] <pcwalton> to be honest this is very late but I find your arguments persuasive
[04:11:41] <bjz_> adu: have you seen docopt?
[04:11:59] <dbaupp> strcat: there's nothing stopping a MutVecIterator that iterates over each element as &mut T, right?
[04:12:01] <adu> bjz_: nope
[04:12:09] <bjz_> http://docopt.org/
[04:12:24] *** Quits: caitp (caitp@moz-9FE842F.cpe.net.cable.rogers.com) (Quit: caitp)
[04:12:40] <dbaupp> strcat: (or mut-iterating over the values of other datastructure, other than sets, I guess)
[04:12:43] <strcat> dbaupp: it likely has to be implemented as unsafe code
[04:12:58] <dbaupp> strcat: an Iterator<&mut T> ?
[04:13:00] <strcat> but nothing makes it inherently unsafe to use, with proper lifetime annotations, afaik
[04:13:17] <adu> bjz_: fascinating
[04:13:20] <strcat> dbaupp: yes
[04:13:28] <bjz_> adu: http://www.youtube.com/watch?v=pXhcPJK5cMc
[04:13:31] <strcat> dbaupp: because the &mut will point to different objects
[04:13:36] <strcat> so it's safe to use
[04:13:39] <dbaupp> strcat: yeah
[04:14:05] <bjz_> adu: I thought that looked cool, but I'm not that great at wring parsers :)
[04:14:12] *** Joins: carllerche (carllerche@6B070D22.7E6A0813.1428D117.IP)
[04:14:13] <pcwalton> interesting
[04:14:13] <strcat> dbaupp: I'm 90% sure it'd have to use *mut internally
[04:14:14] <bjz_> adu: not like aatch here :)
[04:14:20] <adu> bjz_: I've written quite a few :)
[04:14:24] <pcwalton> the mutability issue seems to me to argue in favor of having both in the language
[04:14:30] <aatch> :D
[04:14:40] <pcwalton> which is something appealing to me since it's backwards compatible
[04:14:46] <pcwalton> also
[04:14:52] <pcwalton> there is compilation speed to consider
[04:14:55] <dbaupp> strcat: presumably it could store &mut [T] and index: uint and that'd work?
[04:15:08] <strcat> pcwalton: well, I'm not sure which is slower - traits (external) vs closures (internal)
[04:15:09] <pcwalton> I would not be surprised if external iterators are way faster to compile than internal ones.
[04:15:21] <pcwalton> closures have a lot of overhead
[04:16:58] <dbaupp> rusti: struct A<'self, T> { v: &'self mut [T] } impl<'self, T> A<'self, T> { fn next(&mut self) -> Option<&'self mut T> { Some(&mut self.v[0]) } }
[04:16:59] -rusti- ()
[04:17:03] *** Joins: alisdair (textual@moz-EBE9F394.bchsia.telus.net)
[04:17:03] *** Quits: alisdair (textual@moz-EBE9F394.bchsia.telus.net) (Client exited)
[04:17:13] <adu> bjz_: actually, that syntax is very similar to Perl6 regexes
[04:17:17] <dbaupp> strcat: unless I've written that incorrectly, it seems to work ok?
[04:17:54] <bjz_> adu: we really need some kind of grammar lib or something
[04:18:00] <strcat> dbaupp: it needs to advance the iterator though
[04:18:09] <strcat> dbaupp: it's not going to let you return &mut and also advance it afaik
[04:18:10] <adu> bjz_: :D :D :D
[04:18:15] <bjz_> adu: a syntax extension would be amazing
[04:18:38] <adu> bjz_: how would that work?
[04:18:38] <bjz_> adu: that would make this kind of thing much simpler
[04:18:41] <dbaupp> rusti: struct A<'self, T> { v: &'self mut [T], i: uint } impl<'self, T> A<'self, T> { fn next(&mut self) -> Option<&'self mut T> { self.i += 1; Some(&mut self.v[self.i - 1]) } }
[04:18:42] -rusti- ()
[04:18:54] <dbaupp> strcat: ^ ?
[04:19:13] <bjz_> adu: no idea :)
[04:19:14] <strcat> dbaupp: that looks fine
[04:19:41] <adu> bjz_: it would probably be along the lines of f(str)
[04:19:44] <bjz_> adu: you could do some kind of PEG parser thing with operator overloads
[04:20:02] <bjz_> adu: like pythons's parsely
[04:20:05] <dbaupp> strcat: cool, I guess storing the &mut self.v[..], mutating self.i, and then returning the element reference would break it
[04:20:05] <cmr> aatch: did you ever figure out why SROA was broken?
[04:20:06] <strcat> dbaupp: although it gets harder for trees
[04:20:13] <strcat> dbaupp: because you need a stack of &mut
[04:20:27] <aatch> cmr, it wasn't sroa in the end, or at least not by itself.
[04:20:27] <bjz_> adu: or maybe some kind of macro thing
[04:20:32] <strcat> vectors likely want an unsafe impl for both immutable/mutable ones for speed
[04:20:33] <cmr> ah
[04:20:36] <aatch> the mergefunc pass did most of the damage
[04:20:46] <strcat> but other data structures can get by with safe ones, for immutable at least
[04:20:50] <dbaupp> rusti: struct A<'self, T> { v: &'self mut [T], i: uint } impl<'self, T> A<'self, T> { fn next(&mut self) -> Option<&'self mut T> { let ret = Some(&mut self.v[self.i]) ; self.i += 1; ret } }
[04:20:50] <aatch> also, there are 3 different scalar replacement passes.
[04:20:51] -rusti- ()
[04:20:56] <bjz_> adu: but the syntax would have to get through rust's parser
[04:21:00] <dbaupp> hm, that also seemed to work
[04:21:08] <aatch> we are using a different one.
[04:21:15] <bjz_> adu: if it was going to be some kind of macro
[04:21:28] *** Joins: mflamer (Mibbit@moz-C6ED16AA.hsd1.ca.comcast.net)
[04:21:30] <adu> bjz_: there are 2 fundamental kinds of "OR": PEG and LL/LR
[04:21:47] <bjz_> adu: indeed
[04:21:50] <dbaupp> strcat: yeah, I was going to implement a mut vector iterator, because I wanted an each2_mut, but adding more functions is stupid. as we've discussed already ;)
[04:22:06] <adu> are there 2 vertical-ish operators?
[04:22:16] <dbaupp> adu: || and | are different
[04:22:16] <bjz_> adu: apparently Perl6 does some amazing work in that direction
[04:22:26] <bjz_> adu: we only have |
[04:22:30] <dbaupp> (is that what you're looking for?)
[04:22:38] <dbaupp> rusti: stringify!( | || )
[04:22:40] -rusti- "| ||"
[04:22:42] <adu> bjz_: in Perl6, | and || are both PEG/ordered choice
[04:22:46] <dbaupp> bjz_: they're not
[04:22:59] <dbaupp> bjz_: I mean, we also have ||
[04:23:01] <adu> bjz_: in Perl6, LL/LR longest-match choice is implemented with polymorphism
[04:23:18] <bjz_> dbaupp: we can't overload || though
[04:23:25] <dbaupp> bjz_: oh, right
[04:23:25] *** Quits: pcwalton (pcwalton@moz-481A040C.hsd1.ca.comcast.net) (Quit: .)
[04:23:32] *** Joins: brson (brson@72B1AFF8.AD1E507F.3688B332.IP)
[04:23:32] <dbaupp> bjz_: but if it's a syntax extension you can
[04:23:32] *** ChanServ sets mode: +o brson
[04:23:38] <bjz_> dbaupp: yeah
[04:23:39] <adu> I didn't know rust had operator overloading
[04:23:40] *** Quits: annodomini (lambda@moz-9AC5B452.hsd1.ma.comcast.net) (Quit: annodomini)
[04:23:44] <bjz_> was about to say that
[04:23:52] <dbaupp> adu: https://github.com/mozilla/rust/wiki/Note-operator-overloading
[04:24:17] <bjz_> adu: but yeah aatch: is doing some work on JIT with rusp
[04:24:21] <adu> oh, cool
[04:24:33] <bjz_> adu: I was thinking JIT might be good for grammars
[04:24:41] <adu> bjz_: how so?
[04:24:46] <bjz_> seeing as rust has limited CTE
[04:24:53] *** Joins: carter (carter@moz-12C317EF.nyc.res.rr.com)
[04:24:54] <adu> you mean making grammars run fast?
[04:24:58] <bjz_> aye
[04:25:12] <aatch> Well right now I'm re-writing the LLVM wrappers I did, because it turned out they sucked.
[04:25:32] <adu> yeah, I wrote a C11 parser in Perl6, and it takes about 30 seconds to parse "int main() { printf("hello world\n"); return 0; }"
[04:25:45] <dbaupp> bjz_: CTE?
[04:25:55] <aatch> compile-time evaluation
[04:26:03] <dbaupp> oh, right
[04:26:07] <bjz_> so, you could write JSON, XML, regex and and email parsers with this thing
[04:26:14] <adu> bjz_: yes
[04:26:15] <dbaupp> syntax-extension all the things!
[04:26:16] <bjz_> or docopt
[04:26:20] <bjz_> or rusp
[04:26:20] <strcat> dbaupp: so yeah, there are simple cases you can write with safe code but...
[04:26:30] <dbaupp> strcat: yeah, I take your point
[04:26:32] <strcat> dbaupp: it really doesn't work if you have to use &mut as the index into the container
[04:26:43] <adu> bjz_: but the really really amazing thing about Perl6 is that regexes are functions
[04:26:46] <strcat> at least right now it doesn't
[04:27:02] <bjz_> adu: ahh, nice
[04:27:17] <dbaupp> strcat: I imagine the vector one would be the most common one though, but as you said... writing it for speed requires *mut
[04:27:30] <adu> is there any way to make a syntax extension that is like regex! f { x } instead of fn f() { x }?
[04:27:39] <dbaupp> adu: yeah
[04:27:47] <adu> dbaupp: :D :D :D
[04:27:59] <bjz_> there has been interest in a regex syntax extension
[04:27:59] <dbaupp> adu: macro_rules! is like that, and isn't (entirely) special cased
[04:28:08] <bjz_> dunno how far it got
[04:28:19] <adu> I'm on it
[04:28:20] <dbaupp> ssbr is/was writing it, I think
[04:28:28] <adu> so how does one write a syntax extension?
[04:28:40] <aatch> adu, look in libsyntax
[04:28:40] <cmr> adu: you hardcode it into libsyntax
[04:28:44] <dbaupp> adu: libsyntax/ext
[04:29:02] <bjz_> adu: hopefully that will be more pluggable in the future
[04:29:08] <dbaupp> adu: bytes.rs is probably a simple-ish one, if you want to have a quick look
[04:29:41] <dbaupp> adu: also, https://github.com/mozilla/rust/wiki/Lib-re
[04:29:48] <bjz_> adu: there are also abunch of simple macros in ext/expand
[04:30:30] <dbaupp> bjz_: they're just plain old macro_rules! ones, right?
[04:30:38] <bjz_> indeed
[04:30:44] <bjz_> not syntax exts
[04:31:08] <adu> hmm
[04:31:43] <bjz_> adu: but yeah, having some linguistic abstraction capability would be incredible
[04:31:54] <bjz_> even if I don't fully understand it yet
[04:31:56] <bjz_> :)
[04:32:08] <adu> bjz_: it's pretty easy to understand
[04:32:16] *** Quits: wizeman_ (quassel@moz-9C343656.dyn.user.ono.com) (Connection reset by peer)
[04:32:16] *** Joins: pyrac (pyrac@moz-96C2FD1F.w109-214.abo.wanadoo.fr)
[04:32:23] <adu> bjz_: just play around with perl6 a bit
[04:32:29] <bjz_> :)
[04:32:41] <bjz_> everyone hates on perl6 :(
[04:32:58] <adu> I don't see why, unless they're speed Nazis
[04:33:01] *** Joins: wizeman (quassel@moz-9C343656.dyn.user.ono.com)
[04:33:03] <bjz_> yeah
[04:33:26] <bjz_> in the run time sense, and the releas time sense :D
[04:33:43] <adu> bjz_: did I ever show you my C11 parser?
[04:33:48] <bjz_> nope
[04:33:50] <adu> https://github.com/andydude/c2drox/blob/master/lib/C/StdC11Parser.pm6
[04:33:57] <cmr> Is there anything in the CrateContext that indicates if a crate is destinted to be a library or executable?
[04:34:42] *** Quits: z0w0 (zack@moz-991DC1C4.lnse1.cha.bigpond.net.au) (Ping timeout)
[04:34:43] <bjz_> adu: we could re-write the rust parser in the grammar! extension!
[04:34:51] <aatch> cmr, which crate context?
[04:34:51] <bjz_> adu: :P
[04:34:54] <aatch> in trans?
[04:34:56] <cmr> aatch: yes
[04:35:02] <adu> bjz_: I have to implement it first
[04:35:07] <bjz_> adu: hehe
[04:35:23] <cmr> An item that is guaranteed to exist in ast::crate would be fine too
[04:35:26] <adu> so you just have to implement a expand_syntax_ext function?
[04:35:32] <bjz_> adu: let me know if you need assistance, it's something I'm very interested in
[04:35:35] <aatch> cmr, ccx.sess.building_library
[04:35:44] <cmr> aatch: nice, thanks!
[04:35:51] <adu> bjz_: I could use a simple example, how about swap!(x, y)
[04:36:03] <adu> let's write the swap! syntax extension
[04:36:04] <dbaupp> wow, CrateContext uses a lot of @mut
[04:36:10] * aatch is scarily familiar with the contents of trans
[04:36:14] <dbaupp> @mut bool ??
[04:36:28] <cmr> dbaupp: I questioned that too but didn't want to take any responsibility for any changes ;)
[04:36:30] <bjz_> adu: as dbaupp said, bytes is relatively simple
[04:36:31] <aatch> dbaupp, just in case...
[04:36:41] <adu> I'm looking at bytes.rs right now
[04:36:45] <dbaupp> aatch: in case?
[04:36:56] <aatch> I dunno, gremlins?
[04:36:57] <bjz_> adu: I haven't really delved deeply into them yet though
[04:37:03] <dbaupp> adu: I'm very familiar with most of the contents of ext
[04:37:10] <dbaupp> adu: if you need help with that part of it :)
[04:37:19] *** Quits: mflamer (Mibbit@moz-C6ED16AA.hsd1.ca.comcast.net) (Quit: http://www.mibbit.com ajax IRC Client)
[04:37:25] *** Quits: jorendorff (jorendorff@moz-2F32ACA3.hsd1.tn.comcast.net) (Quit: jorendorff)
[04:37:26] <bjz_> dbaupp: would you be interested in helping with a grammar! ext?
[04:37:33] *** Joins: pragmatic (pragmatic@moz-1A421840.hsd1.ca.comcast.net)
[04:37:35] <cmr> dbaupp: actually it looks like metadata isn't written for executables
[04:37:46] <bjz_> dbaupp: we could write rusp in it :P
[04:37:49] <adu> dbaupp: I'd like to write swap!(x, y), which should be equivalent to { let t; t = x; x = y; y = t; }
[04:37:50] <cmr> dbaupp: line 2985 of trans/base.rs, if !*cx.sess.building_library { return; }
[04:37:52] <dbaupp> aatch: haha, it seems like changing it to be @mut CrateContext and inlining things would be possible
[04:38:00] <Jeaye_> incoming busted on Linux?
[04:38:01] <Jeaye_> No rule to make target `x86_64-unknown-linux-gnu/stage0/lib/libcore.so'
[04:38:08] <dbaupp> cmr: oh right
[04:38:11] <aatch> Jeaye_, ???
[04:38:17] <dbaupp> cmr: I really should've noticed that
[04:38:21] <dbaupp> Jeaye_: run it agian
[04:38:27] *** Joins: mflamer (Mibbit@moz-C6ED16AA.hsd1.ca.comcast.net)
[04:38:32] <bjz_> adu: we already have util::swap
[04:38:41] <Jeaye_> dbaupp: heh, odd
[04:38:48] <dbaupp> Jeaye_: it's because the ./configure / make thing doesn't work on the first build after the std/core rename
[04:38:51] *** Joins: z0w0 (zack@moz-1EDE5BC0.lnse1.woo.bigpond.net.au)
[04:38:56] <Jeaye_> ahh
[04:39:04] <dbaupp> (i.e. make runs configure, but then uses the old rules, or something)
[04:39:05] <bjz_> dbaupp: do syntax exts need macro_rules?
[04:39:11] <dbaupp> bjz_: nope
[04:39:18] <dbaupp> bjz_: (i'm not really sure what you mean)
[04:39:21] *** Quits: z0w0 (zack@moz-1EDE5BC0.lnse1.woo.bigpond.net.au) (Client exited)
[04:39:23] <bjz_> dbaupp: didn't think so
[04:39:39] <bjz_> dbaupp: I mean, they aren't impled using macro rules
[04:39:39] <adu> bjz_: I found "Use core::util::{swap, replace} instead"
[04:39:58] <dbaupp> bjz_: yeah
[04:39:59] *** Joins: z0w0 (zack@moz-1EDE5BC0.lnse1.woo.bigpond.net.au)
[04:40:44] <dbaupp> bjz_: the syntax extensions are directly inserted into the "expanders" table, while macro_rules! ones get added progressively
[04:40:50] <adu> dbaupp: are you talking about swap<T>(x: &mut T, y: &mut T)?
[04:41:15] <dbaupp> adu: that's what bjz is talking about, yeah
[04:41:22] <bjz_> rusti: use std::util::swap; let mut (x, y) = (1, 2); swap(&mut x, &mut y); (x, y)
[04:41:23] -rusti- (2, 1)
[04:41:29] <adu> er bjz_
[04:41:53] <bjz_> yep?
[04:42:22] <adu> ok, so you don't need a syntax extension for swap
[04:42:37] <bjz_> sorry :(
[04:42:51] <adu> what about ++
[04:42:59] <cmr> ++ doesn't exist
[04:43:17] <adu> can I write a syntax extension called plusplus!(x)
[04:43:39] <dbaupp> adu:  that would expand to `x += 1` ?
[04:43:46] <aatch> adu, in theory, yes. But it would not be useful.
[04:43:46] <adu> sure
[04:43:52] <aatch> and can be done with macros
[04:43:54] <bjz_> adu: are you talking just for practice?
[04:44:02] <adu> I understand, I just want to understand the process of writing a syntax extension
[04:44:12] <adu> currently I don't
[04:44:18] <adu> and I want to understand
[04:44:30] <dbaupp> adu: well, you'd want to gets the tts token tree, and check that it contained a single expression
[04:44:40] <adu> why is it called tts?
[04:44:44] <adu> why not ast?
[04:44:49] <dbaupp> adu: same name as the one in bytes.rs
[04:44:57] <cmr> it's not an ast yet
[04:45:03] <dbaupp> adu: it's actually just been tokenised, not parsed into an ast
[04:45:17] <adu> cmr: oh, so it's toks
[04:45:34] *** Joins: ghrust (ghrust@1E8607E8.6A2AE50.F3114085.IP)
[04:45:34] <ghrust> 01[13rust01] 15bors pushed 0 new commits to 06auto: 02http://git.io/E5IV6Q
[04:45:34] *** Parts: ghrust (ghrust@1E8607E8.6A2AE50.F3114085.IP) ()
[04:45:39] <aatch> rusti: macro_rules! plusplus (($e:expr) => ( {let tmp = $e; $e += 1; tmp} ) let mut a = 1; let b = plusplus!(a); (a, b)
[04:45:40] -rusti- <anon>:11:4: 11:5 error: incorrect close delimiter: `}`
[04:45:40] -rusti- <anon>:11     }));
[04:45:40] -rusti-               ^
[04:45:40] -rusti- application terminated with error code 101
[04:45:54] <aatch> rusti: macro_rules! plusplus (($e:expr) => ( {let tmp = $e; $e += 1; tmp} )) let mut a = 1; let b = plusplus!(a); (a, b)
[04:45:55] -rusti- (2, 1)
[04:45:57] <bjz_> adu: also bear in mind that macros/syntax exts don't have access to types
[04:45:58] <dbaupp> adu: and then you'd write a thing that created a literal 1, and then combine the expression and the literal with a +=  expression
[04:46:23] <aatch> rusti: macro_rules! plusplus (($e:expr) => ( {let tmp = $e; $e += 1; tmp} )) let mut a = 1; let b = plusplus!(1); (a, b)
[04:46:23] <adu> bjz_: I wouldn't expect them to, no macro system I've ever used has types
[04:46:24] -rusti- more than 5 lines of output, pastebinned: http://sprunge.us/ICMK
[04:46:38] <bjz_> adu: yup, just checking :)
[04:47:11] *** Joins: Cromulent (Cromulent@moz-983B638D.cable.virginmedia.com)
[04:47:14] <bjz_> adu: your C11 grammer looks quite cool too :)
[04:47:20] <adu> bjz_:  thanks :)
[04:47:41] <adu> bjz_: do you see what I mean about polymorphism == longest-match choice?
[04:47:52] <dbaupp> cx.lit_uint(1) for the former, and something like cx.expr(ast::expr_assign_op(cx.next_id(), ast::add, ... ))
[04:48:04] <dbaupp> for the latter
[04:48:47] <Eridius> rusti: fn foo() { fn bar() { println("bar") } bar() } foo()
[04:48:48] -rusti- bar
[04:48:48] -rusti- ()
[04:49:44] <strcat> rusti: fn f() { f() } f()
[04:49:45] -rusti- application terminated abnormally with signal 9 (Killed)
[04:50:24] <strcat> rusti: fn f() { f() } f()
[04:50:26] -rusti- ()
[04:50:39] <strcat> rusti: fn f() { f() } f()
[04:50:40] -rusti- ()
[04:50:44] <strcat> heh
[04:50:45] *** Joins: ysuzuki (ysuzuki@moz-A563888C.ics.keio.ac.jp)
[04:50:58] <strcat> LLVM optimizes out that infinite loop
[04:51:07] <strcat> is it... allowed to do that?
[04:51:58] <z0w0> maybe because the loop does nothing? although it sounds like it shouldn't..
[04:52:00] <aatch> strcat, I think it actually optimizes the body down to just "store undef"
[04:52:07] <aatch> or something like that.
[04:52:20] <strcat> C++11 explicitly allows optimizing out infinite loops but I didn't think clang/gcc actually did it ;\
[04:52:30] <strcat> (no-op infinite loops)
[04:52:32] *** Quits: ysuzuki (ysuzuki@moz-A563888C.ics.keio.ac.jp) (Client exited)
[04:52:39] *** Quits: royw (royw@moz-E9B4079C.hsd1.ca.comcast.net) (Quit: royw)
[04:52:44] <strcat> oh well
[04:52:47] <strcat> just kind of weird
[04:53:06] * strcat expected it to do sibling call opt and just run forever...
[04:53:15] <aatch> rusti: fn f(a:int) { f(a) } f(1)
[04:53:17] -rusti- application terminated abnormally with signal 9 (Killed)
[04:53:22] <strcat> optimization is off again
[04:53:26] <strcat> here, on
[04:53:29] <aatch> rusti: fn f(a:int) { f(a) } f(1)
[04:53:31] -rusti- ()
[04:53:34] <aatch> hm
[04:53:56] <aatch> thats constant propagation at work.
[04:54:00] <rntz> ... wait, llvm optimizes out infinite loops? that's bull-shit.
[04:54:02] *** Joins: ysuzuki (ysuzuki@moz-A563888C.ics.keio.ac.jp)
[04:54:08] <aatch> rntz, only no-op ones.
[04:54:10] <z0w0> no-ops
[04:54:16] <rntz> there is no such thing as a no-op infinite loop
[04:54:25] <aatch> infinite loops that do nothing. inside the loop
[04:54:38] <rntz> an infinite loop *is* an operation. an operation that never completes.
[04:55:14] <z0w0> arguing semantics
[04:55:23] <strcat> rntz: well according to C++11 they can be optimized out
[04:55:28] <strcat> apparently LLVM agrees ;p
[04:55:29] <aatch> rntz, not according to llvm.
[04:55:36] <rntz> aatch: well llvm is wrong and bad :P
[04:55:59] <strcat> rntz: it's because it can prove many loops are no-ops but not whether they terminate
[04:56:02] <rntz> strcat: sure, but llvm isn't C++11. at the very least they could allow you to turn off that pass.
[04:56:10] <strcat> rntz: we probably don't want to
[04:56:21] <aatch> it's not an explicit pass
[04:56:29] <aatch> it'll be a combination of passes
[04:56:32] <rntz> strcat: if you allow llvm to do that optimization you break safety
[04:56:38] *** Quits: infynyxx (infynyxx@moz-E95B370B.nyc.res.rr.com) (Connection reset by peer)
[04:56:40] <strcat> rntz: how does that break safety?
[04:56:42] <aatch> rntz, how?
[04:56:48] <rntz> it means that a function declared noreturn can return
[04:56:53] <rntz> fn f() -> ! { f() }, for example
[04:56:54] <rntz> or better yet
[04:56:59] <rntz> fn f() -> int { f() }
[04:57:00] <rntz> let x = f();
[04:57:01] *** Joins: steven_is_false (user@moz-144077DE.bchsia.telus.net)
[04:57:03] *** Joins: infynyxx (infynyxx@moz-E95B370B.nyc.res.rr.com)
[04:57:06] <rntz> // hrm, what is x?
[04:57:19] <strcat> rntz: if we compiled it correctly, I don't think it would optimize out
[04:57:33] <strcat> need unreachable markers
[04:57:45] <strcat> rusti: fn f() -> ! { f() } f()
[04:57:47] -rusti- more than 5 lines of output, pastebinned: http://sprunge.us/hZQI
[04:58:00] <strcat> rusti: fn foo() { fn f() -> ! { f() } f() } foo()
[04:58:02] -rusti- application terminated abnormally with signal 9 (Killed)
[04:58:02] <rntz> oh great, an ICE
[04:58:12] <strcat> rntz: it doesn't optimize out with -> !
[04:58:15] <bblum> that's not what an ice looks like
[04:58:16] <strcat> how? I don't know
[04:58:18] <strcat> ;p
[04:58:18] <z0w0> i disagree, i think if a loop is no-op then the return value should definitely be marked as nil..
[04:58:23] <bblum> an ice looks like this
[04:58:26] <bblum> rusti: None
[04:58:26] -rusti- error: internal compiler error: unexpected failure
[04:58:27] -rusti- note: the compiler hit an unexpected failure path. this is a bug
[04:58:27] -rusti- note: try running with RUST_LOG=rustc=1,::rt::backtrace to get further details and report the results to github.com/mozilla/rust/issues
[04:58:27] -rusti- application terminated with error code 101
[04:58:33] <rntz> bblum: "error: internal compiler error: unexpected failure"
[04:58:40] <strcat> it did ICE after it printed the error
[04:58:45] <bblum> oh i see
[04:58:47] <bblum> in the pastebin
[04:58:48] <strcat> some silly mistake in error printing I guess
[04:59:03] <rntz> how the hell does "None" ICE it?
[04:59:11] <rntz> this is basic stuff :(
[04:59:17] <strcat> rntz: because it's in fmt!("%?", { /* code */ })
[04:59:32] <bblum> rusti: None::<()>
[04:59:32] <rntz> that makes it more understandable, but hardly more excusable
[04:59:33] -rusti- None
[04:59:43] <rntz> arglblargle.
[04:59:52] <rntz> I'm going to repeat "more understandable, but not more excusable"
[04:59:58] <bblum> well, there's a bug open
[05:00:01] <rntz> yeah
[05:00:02] <rntz> anyway.
[05:00:18] <strcat> rusti: fn foo() { fn f() { f() } f() } foo()
[05:00:18] <rntz> how *does* it avoid optimizing fn f() -> ! { f() }?
[05:00:19] -rusti- ()
[05:00:20] <strcat> rusti: fn foo() { fn f() { f() } f() } foo()
[05:00:21] -rusti- ()
[05:00:26] <strcat> rusti: fn foo() { fn f() -> ! { f() } f() } foo()
[05:00:28] -rusti- application terminated abnormally with signal 9 (Killed)
[05:00:28] <rntz> rusti: fn f() -> int { f() } f()
[05:00:29] -rusti- 0
[05:00:30] <strcat> rusti: fn foo() { fn f() -> ! { f() } f() } foo()
[05:00:31] -rusti- application terminated abnormally with signal 9 (Killed)
[05:00:32] <rntz> ha!
[05:00:34] <rntz> it generated an int!
[05:00:36] <aatch> hey, rntz before you start running your mouth this is what the no-return produces (cleaned up): https://gist.github.com/Aatch/5719405
[05:00:42] <bblum> rntz: oh dear.
[05:00:47] <bblum> hmmm
[05:00:59] <rntz> aatch: see above. this is worse than noreturn.
[05:01:15] <rntz> fn f() -> ~int { f() } f()
[05:01:18] <rntz> er
[05:01:19] <rntz> rusti: fn f() -> ~int { f() } f()
[05:01:22] -rusti- application terminated abnormally with signal 11 (Segmentation fault)
[05:01:24] <rntz> boom.
[05:01:28] <bblum> rusti: fn f() -> std::util::Void { f() } f()
[05:01:30] -rusti- rust: task failed at 'enum value matched no variant', /build/rust-incoming-git/src/rust/src/libstd/repr.rs:541
[05:01:30] -rusti- rust: domain main @0xd841b0 root task failed
[05:01:30] -rusti- application terminated with error code 101
[05:01:34] <bblum> :3
[05:01:42] <strcat> well that's a fun bug
[05:01:51] <rntz> there you go, it breaks safety
[05:02:01] <engla> nice work
[05:02:04] <strcat> rntz: not LLVM's optimization, we're likely doing something wrong
[05:02:15] <aatch> rntz, please remember that Rust is an alpha language
[05:02:26] <rntz> aatch: I'm not bitching about rust here :P
[05:02:28] <rntz> I'm bitching about llvm
[05:02:33] <dbaupp> rusti: fn f() -> ~[int] { f() } f()
[05:02:34] -rusti- application terminated abnormally with signal 11 (Segmentation fault)
[05:02:39] <Eridius> rusti: let mut v = ~[]; for u8::range_rev(3,0) |i| { v.push(i); } v
[05:02:40] -rusti- more than 5 lines of output, pastebinned: http://sprunge.us/ADZc
[05:02:40] <rntz> strcat: so, look, there's probably some way you can avoid LLVM optimizing these cases
[05:02:48] <rntz> but the fact is, an infinite loop is not equivalent to a terminating program
[05:02:49] <Eridius> rusti: let mut v = ~[]; for std::u8::range_rev(3,0) |i| { v.push(i); } v
[05:02:51] -rusti- ~[3, 2, 1]
[05:02:53] *** Quits: infynyxx (infynyxx@moz-E95B370B.nyc.res.rr.com) (Client exited)
[05:03:05] <rntz> and the fact that LLVM does this optimization is bullshit on LLVM's part. it's not a legitimate optimization by any reasonable measure of program semantics.
[05:03:09] <bblum> hmmm
[05:03:19] <rntz> you're working around a problem in LLVM if you try to accomodate it, IMO
[05:03:44] <strcat> rntz: http://blog.regehr.org/archives/140
[05:04:14] <strcat> I wonder if it's our fault or LLVM's though
[05:04:30] <bblum> rusti: #[inline(always)] fn f() -> ! { f() } fn coerce<A,B>(x: A) -> B { let _x = std::util::id(x); f() } coerce::<~str,~[u8]>(~"hello world!")
[05:04:32] -rusti- application terminated abnormally with signal 9 (Killed)
[05:04:40] <bblum> hmmm
[05:04:40] <Eridius> for some reason I find myself very commonly wanting to iterate over the range (hi..lo], or possibly [hi..lo], instead of [hi..lo). Kind of annoyed there's no easy way to do that when lo is 0 and it's an unsigned datatype
[05:04:52] *** Joins: Jesse (jruderman@moz-537BCF9.hsd1.ca.comcast.net)
[05:05:00] <dbaupp> Eridius: external iterators!
[05:05:05] <Eridius> for uint::range(lo, hi) |i| { let i = hi-1-i; } is annoying
[05:05:18] <dbaupp> Eridius: the counter in std::iterator possibly helps
[05:05:44] <dbaupp> Eridius: you could do for uint::range(hi, lo) |i| { let i = i - 1;  ... }
[05:05:47] <strcat> rusti: use std::iterator::*; Counter::new(10, -1).take_while(|&x| x != 0).to_vec()
[05:05:48] <Eridius> dbaupp: not quite sure how external iterators work, because docs kinda suck
[05:05:48] <dbaupp> (still annoying)
[05:05:49] -rusti- ~[10, 9, 8, 7, 6, 5, 4, 3, 2, 1]
[05:05:56] <strcat> hrm.
[05:06:11] <strcat> rusti: use std::iterator::*; Counter::new(10u, -1).take_while(|&x| x != -1u).to_vec()
[05:06:13] -rusti- ~[10, 9, 8, 7, 6, 5, 4, 3, 2, 1, 0]
[05:06:14] <strcat> ;p
[05:06:18] <dbaupp> rusti: use std::iterator::*; Counter::new(9, -1).take(10).to_vec()
[05:06:19] * strcat runs
[05:06:19] -rusti- more than 5 lines of output, pastebinned: http://sprunge.us/BCEf
[05:06:33] <dbaupp> rusti: use std::iterator::*; Counter::new(9u, -1).take(10).to_vec()
[05:06:35] -rusti- more than 5 lines of output, pastebinned: http://sprunge.us/CQdF
[05:06:43] <Eridius> strcat: ack, relying on underflow behavior makes me nervous
[05:06:45] <strcat> dbaupp: take hits the type inference bug
[05:06:48] <strcat> Eridius: why?
[05:06:51] <Eridius> (even though, even in C, unsigned underflow is well-defined)
[05:06:56] <Eridius> strcat: it just feels ugly
[05:06:58] <dbaupp> rusti: use std::iterator::*; Counter::new(9u, -1).take(10u).to_vec()
[05:06:58] <strcat> Eridius: it's clearly defined that way in rust for both signed/unsigned
[05:06:59] -rusti- more than 5 lines of output, pastebinned: http://sprunge.us/aADi
[05:07:04] <strcat> Eridius: unsigned integers are math modulo N
[05:07:07] <bblum> i can't get coerce to work
[05:07:10] <dbaupp> strcat: ok, yep
[05:07:15] <bblum> the return value always comes back as 0 :(
[05:07:16] <Eridius> strcat: overflow/underflow is defined for signed as well in rust? huh
[05:07:17] <strcat> modular arithmetic is used in pure math too.
[05:07:18] <Eridius> certainly not in C
[05:07:24] <strcat> Eridius: not in standard C
[05:07:27] <strcat> Eridius: with -fwrapv, yes
[05:07:45] <strcat> the hardware usually makes it possible to implemented as 'defined'
[05:08:02] <strcat> but the C standard says it's undefined mostly so compilers can assume loops with signed counters terminate
[05:08:10] <aatch> Hah! it's not LLVM's fault. not exactly anyway. that loop is undefined behaviour
[05:08:30] <aatch> it optimizes f() down to ret i64 undef
[05:08:45] <Eridius> strcat: because it's undefined a loop that relies on overflow/underflow can actually be treated as infinite by the compiler if it wants to
[05:08:49] <Eridius> which lets it delete any code after the loop as unreachable
[05:08:53] <Eridius> yay optimizations!~
[05:08:56] <bblum> aatch: oh, which always has the value 0, huh?
[05:09:08] <bblum> so my attacks on the register allocator can't work? :(
[05:09:13] <strcat> Eridius: yep, that's how C manages to be fast ;p
[05:09:42] <strcat> leave pretty much everything undefined so the implementation can be simple
[05:09:55] <aatch> Well kinda. it tells llvm that the results don't matter and allows it to optimize accordingly.
[05:09:58] <strcat> make up for the lack of high-level knowledge by making things that seem like they should be well-defined undef
[05:10:35] <bblum> fn f() -> std::util::Void { f() } match f() {}
[05:10:38] <bblum> rusti: fn f() -> std::util::Void { f() } match f() {}
[05:10:40] -rusti- more than 5 lines of output, pastebinned: http://sprunge.us/FEjQ
[05:10:57] <bblum> oops
[05:11:01] <strcat> yay, Send!
[05:11:06] <Eridius> I'm tempted to add a [num]::range_from_to(start, stop, step) which does [start..stop]
[05:11:15] <bblum> rusti: fn f() -> std::util::Void { f() } (match f() {}) as uint
[05:11:16] -rusti- more than 5 lines of output, pastebinned: http://sprunge.us/FKce
[05:11:23] <Eridius> although there's the potential for confusion between that and range_step
[05:11:24] <dbaupp> Eridius: we don't need more functions
[05:11:31] <strcat> we need 1 function
[05:11:35] <bblum> rusti: fn f() -> std::util::Void { f() } let _: uint = match f() {};
[05:11:37] -rusti- more than 5 lines of output, pastebinned: http://sprunge.us/KdhS
[05:11:42] <dbaupp> Eridius: we need a way to group that function with the other range ones
[05:11:44] <strcat> a way to stop an iterator *after* it gets to a certain value
[05:11:48] <Eridius> dbaupp: it turns out that iterating from (hi..0) in an unsigned fashion is surprisingly common in the code I'm writing :/
[05:11:55] <Eridius> strcat: yeah that would be helpful
[05:11:55] *** Quits: carllerche (carllerche@6B070D22.7E6A0813.1428D117.IP) (Quit: carllerche)
[05:11:56] <strcat> as in a variant of take_while
[05:11:58] <strcat> take_until
[05:12:02] <strcat> hrm
[05:12:30] <dbaupp> Eridius: yeah, but if you're thinking of trying to get it into std... please don't. strcat will be extremely upset.
[05:12:32] <strcat> take_upto? ;p
[05:12:56] <dbaupp> take_upto_and_including?
[05:13:18] <strcat> well I'll just make Range
[05:13:20] <strcat> and make it handle that case
[05:13:40] <strcat> doesn't seem too hard....
[05:13:44] <strcat> does range_step_rev handle it?
[05:13:46] <Eridius> Counter::new(hi, -1).take_while(|x| x != 0).chain(Counter::new(0, 1).take(0))
[05:13:57] <dbaupp> strcat: there's isn't a range_step_rev, fortunately
[05:13:58] <Eridius> strcat: what's range_step_rev?
[05:14:10] <dbaupp> strcat: it takes a signed number as the step
[05:14:13] <strcat> a non-existent fn
[05:14:42] *** Quits: mflamer (Mibbit@moz-C6ED16AA.hsd1.ca.comcast.net) (Quit: http://www.mibbit.com ajax IRC Client)
[05:14:48] <strcat> rusti: use std::iterator::*; Counter::new(5, -1).take_while(|x| x != 0).chain(Counter::new(0, 1).take(0))
[05:14:49] -rusti- more than 5 lines of output, pastebinned: http://sprunge.us/IKOV
[05:15:16] <Eridius> rusti: use std::iterator::*; Counter::new(5, -1).take_while(|&x| x != 0).chain(Counter::new(0, 1).take(1))
[05:15:17] -rusti- {a: {iter: {state: 5, step: -1}, flag: false, predicate: }, b: {iter: {state: 0, step: 1}, n: 1}, flag: false}
[05:15:21] <Eridius> rusti: use std::iterator::*; Counter::new(5, -1).take_while(|&x| x != 0).chain(Counter::new(0, 1).take(1)).to_vec()
[05:15:23] -rusti- more than 5 lines of output, pastebinned: http://sprunge.us/jGMU
[05:15:31] <strcat> yay type inference bug
[05:15:33] <strcat> it hates take/drop so much
[05:16:28] <strcat> rusti: use std::iterator::*; let xs: ~[uint] = Counter::new(5u, -1).take_while(|&x| x != 0).chain(Counter::new(0, 1).take(1)).to_vec(); xs
[05:16:30] -rusti- more than 5 lines of output, pastebinned: http://sprunge.us/ZUVW
[05:16:45] <strcat> rusti: use std::iterator::*; let xs: ~[uint] = Counter::new(5u, -1).take_while(|&x| x != 0u).chain(Counter::new(0u, 1).take(1)).to_vec(); xs
[05:16:47] -rusti- ~[5, 4, 3, 2, 1, 0]
[05:16:53] <strcat> anyway
[05:16:54] *** Quits: pragmatic (pragmatic@moz-1A421840.hsd1.ca.comcast.net) (Ping timeout)
[05:16:56] <strcat> need Range
[05:16:59] <Eridius> yes
[05:17:30] <dbaupp> strcat: what's the problem with take/drop, it's no essentially no different to {drop,take}_while is it?
[05:17:38] <strcat> Eridius: it's relying on overflow anyway
[05:17:49] <strcat> because it takes start: A, step: A
[05:17:52] <strcat> ;p
[05:17:52] *** Joins: eatkinson (eatkinson@moz-5CF47426.dia.static.qwest.net)
[05:17:58] <strcat> it should take start: A, step: B
[05:18:09] <Eridius> strcat: range_step takes start: T, stop: T, step: T_SIGNED
[05:18:29] *** Joins: carllerche (carllerche@6B070D22.7E6A0813.1428D117.IP)
[05:18:30] <strcat> dbaupp: essentially. but I did implement them separately to avoid closures
[05:18:37] *** Quits: carllerche (carllerche@6B070D22.7E6A0813.1428D117.IP) (Quit: carllerche)
[05:19:04] <strcat> because closures == non-copyable
[05:19:15] <strcat> well
[05:19:18] <strcat> actually they are copyable
[05:19:23] <strcat> but I think they won't be? ;p
[05:19:29] <strcat> they definitely aren't Clone'able.
[05:19:45] <dbaupp> strcat: https://github.com/mozilla/rust/pull/6964
[05:19:52] <dbaupp> r?
[05:20:20] *** Joins: jld (jld@moz-B94C75AD.xlerb.net)
[05:20:22] <dbaupp> strcat: oh, I see... so I guess they don't mention `T` enough for rustc to work out what's going on?
[05:20:30] <strcat> dbaupp: not sure.
[05:21:07] <strcat> dbaupp: skip_while and take_while use A (the element type) in the struct
[05:21:10] <strcat> take only uses T
[05:21:25] <dbaupp> yeah, I meant `A`
[05:21:59] <strcat> anyway it's a bug ;p
[05:22:34] <dbaupp> strcat: you could parameterise TakeIterator with a dummy A type
[05:22:43] <dbaupp> just temporarily so that it actually works
[05:23:04] <strcat> hm wait
[05:23:29] <strcat> oh nvm
[05:23:45] *** Joins: q66 (q66@6EE9DE40.46454B5D.33AABD5F.IP)
[05:23:49] *** Joins: royw (royw@moz-E9B4079C.hsd1.ca.comcast.net)
[05:24:54] <dbaupp> (sorry for the force push overwriting your first r+ btw :( )
[05:26:52] <bblum> hey, if we add once functions, then rwarc.write_downgrade can be rewritten to have the type...
[05:27:33] *** Quits: adu (ajr@moz-96FE9B84.washdc.fios.verizon.net) (Quit: adu)
[05:27:36] <bblum> fn(once fn(once fn(once fn()) -> once fn(once fn())) -> U) -> U
[05:27:40] *** Joins: ghrust (ghrust@9C8B94D4.6A2AE50.F3114085.IP)
[05:27:40] <ghrust> 01[13rust01] 15bors pushed 0 new commits to 06auto: 02http://git.io/E5IV6Q
[05:27:40] *** Parts: ghrust (ghrust@9C8B94D4.6A2AE50.F3114085.IP) ()
[05:27:43] *** Joins: ghrust (ghrust@614D05BD.6A2AE50.F3114085.IP)
[05:27:43] <ghrust> 01[13rust01] 15bors pushed 2 new commits to 06auto: 02http://git.io/TU4Sfg
[05:27:43] <ghrust> 13rust/06auto 14848dbc9 15Huon Wilson: std: add an external iterator for mutating vec elements
[05:27:43] <ghrust> 13rust/06auto 147e62ad6 15bors: auto merge of #6964 : huonw/rust/vec-mut-iter, r=thestinger
[05:27:43] *** Parts: ghrust (ghrust@614D05BD.6A2AE50.F3114085.IP) ()
[05:28:03] <dbaupp> bblum: that looks... fun :D
[05:29:08] *** Quits: JesseH (JesseH@moz-2E766C3E.mc.at.cox.net) (Quit: github.com/jessehorne)
[05:29:31] <bblum> in haskell syntax it's even less readable
[05:29:31] <bblum> ((((() -> ()) -> ()) -> ((() -> ()) -> ())) -> a) -> a
[05:29:48] <dbaupp> heh, presumably with IO's and stuff
[05:29:52] *** Quits: Nisstyre (wes@moz-FD86289.netflash.net) (Quit: Leaving)
[05:29:55] <bblum> well, ignoring that
[05:30:03] <dbaupp> since () -> () has one (two?) inhabitants
[05:31:20] <aatch> bblum, so it's a function that takes a function that takes a function that takes a function that returns nil that returns a function that takes a function that returns nil that returns U that returns U?
[05:31:49] <bblum> i guess
[05:31:58] <aatch> Why would you need that!
[05:32:19] <bblum> http://dl.acm.org/citation.cfm?id=969615
[05:33:04] <rntz> dbaupp: by a usual account (() -> ()) has two inhabitants, the function that returns and the function that doesn't.
[05:33:25] <dbaupp> rntz: yeah, that's what I was assuming
[05:33:58] <bblum> rntz: doesn't that interpretation consider the bottom type to be inhabitable?
[05:34:07] <rntz> bblum: huh?
[05:34:35] <bblum> the function that doesn't return is () -> !, which is a subtype of () -> ()
[05:34:35] <rntz> bblum: oh, depends on what you mean by inhabitant, and whether your language is CBV or CBN.
[05:34:50] <rntz> that's one way of looking at it
[05:35:08] <rntz> usually you just say that a nonterminating expression can have any type
[05:35:27] <bblum> sure, if your type logic has bottom in it
[05:35:32] <bblum> also i think i've heard functions called exponentials, in the algebraic interpretation
[05:35:38] <rntz> functions are exponentials
[05:35:44] <rntz> x^y = y -> x.
[05:35:56] <bblum> so a () -> () should have 1^1 = 1 inhabitants
[05:36:05] <rntz> ahhh
[05:36:06] <bjz_> bblum: is fn foo() {} a () -> ! or () -> () ?
[05:36:11] <rntz> bblum: but that's only the case for total functions
[05:36:23] <rntz> bjz_: () -> ()
[05:36:24] <bjz_> bblum: I thought it was an () -> ()
[05:36:26] <bblum> bjz_: that's shorthand for fn foo() -> () { return () }
[05:36:31] <bjz_> yeah
[05:36:35] <bjz_> thought so
[05:36:58] <rntz> bblum: that is, figuring out number of inhabitans via exponentials only works for total functions
[05:37:08] <rntz> so, in a CBV turing-complete language where "inhabitants" are "values of that type"
[05:37:08] <bblum> right
[05:37:13] <rntz> () -> () has 2 inhabitants.
[05:37:24] <bblum> sure
[05:37:26] <rntz> er, "inhabitants of that type up to observational equivalence", rather
[05:37:31] <rntz> s/inhabitants/values/
[05:37:48] <bblum> in a CBN language, option<T> has T+3 inhabitants
[05:37:54] <rntz> in a CBV turing-complete language where "inhabitants" are "expressions of that type" it has 3 inhabitants.
[05:38:22] <rntz> namely, infinite loop, \() -> infinite loop, and \() -> ()
[05:38:25] <bblum> ah, yes
[05:38:33] <rntz> so basically it all comes down to edge-cases :P
[05:38:37] <bblum> same as the option observation
[05:38:50] <bblum> and this is why null pointers are bad, kids.
[05:39:04] <bblum> (in a very roundabout way)
[05:39:21] <rntz> hrm, option<T> has _|_, None, Some(T). so T + 2, I think?
[05:39:34] <rntz> Some(_|_), of course, but _|_ is included in T
[05:39:48] <bblum> oh, i was thinking (T+1)+2
[05:40:17] <bblum> option<bool> has 5 is what i meant.
[05:40:19] <steven_is_false> bblum: That's only in a language like Haskell
[05:40:29] <bblum> yes
[05:40:38] <rntz> steven_is_false: yeah, that's what was meant by CBN
[05:40:45] <rntz> (Call By Name)
[05:41:12] <rntz> or just "lazy"
[05:41:13] <steven_is_false> rntz: Right, I got a little confused. That'll teach me to butt into conversations.
[05:41:19] <rntz> steven_is_false: s'okay :)
[05:41:23] <bblum> no prob
[05:42:09] <rntz> bblum: clearly we should all just use agda so our pretty math works out and x->y really does have y^x inhabitants :P
[05:42:25] <bblum> clearly
[05:42:54] <bblum> agda doesn't have recursive types either, does it? it mustn't...
[05:43:02] <steven_is_false> But the Calculus of Constructions just feels so much more elegant to me!
[05:43:04] <rntz> agda has inductive types, which are a subset of recursive types
[05:43:13] <rntz> (and coinductive? I'm not fully sure)
[05:43:16] <Eridius> rusti: u8::range(0, 1, |_| true)
[05:43:20] -rusti- more than 5 lines of output, pastebinned: http://sprunge.us/DhCQ
[05:43:23] <Eridius> rusti: std::u8::range(0, 1, |_| true)
[05:43:24] -rusti- true
[05:43:27] <Eridius> rusti: std::u8::range(0, 1, |_| false)
[05:43:28] -rusti- false
[05:43:30] <bblum> i thought coinductive types let you build infinite streams
[05:43:38] <rntz> yeah, but agda has codata iirc
[05:43:42] <rntz> they might have changed that
[05:43:43] <steven_is_false> Can't coinductive types be done with existential quantification?
[05:43:52] *** Quits: pyrac (pyrac@moz-96C2FD1F.w109-214.abo.wanadoo.fr) (Ping timeout)
[05:44:13] <steven_is_false> So while they might not have the prettiest sugar for it, they probable have something equivalent in power.
[05:44:24] <rntz> I'm not sure existentials suffice?
[05:44:53] <rntz> maybe my terminology is confused, though.
[05:44:58] <Eridius> can I not use `return` in a lambda?
[05:45:02] *** Joins: pyrac (pyrac@moz-96C2FD1F.w109-214.abo.wanadoo.fr)
[05:45:07] <rntz> Eridius: you should be able to.
[05:45:09] <steven_is_false> rntz: âˆƒx, x ^ (x -> f x)
[05:45:10] <Eridius> rusti: std::u8::range(0, 1, |x| return true; )
[05:45:11] -rusti- <anon>:10:45: 10:46 error: expected `,` but found `;`
[05:45:11] -rusti- <anon>:10          std::u8::range(0, 1, |x| return true; )
[05:45:11] -rusti-                                                        ^
[05:45:11] -rusti- application terminated with error code 101
[05:45:20] <Eridius> rusti: std::u8::range(0, 1, |x| { return true; } )
[05:45:21] -rusti- more than 5 lines of output, pastebinned: http://sprunge.us/MbSG
[05:45:27] <Eridius> error: `return` in block function
[05:45:28] <Eridius> wtf
[05:45:30] <steven_is_false> One encodes a stream as a seed, and a generator
[05:45:48] <rntz> steven_is_false: oh, I mean, you can explicitly encode coinductive types using functions in an eager language, sure
[05:45:52] <Eridius> rusti: std::u8::range(0, 1, |x| return true )
[05:45:56] <rntz> existentials aren't even necessary
[05:45:58] -rusti- more than 5 lines of output, pastebinned: http://sprunge.us/WDVe
[05:46:25] <rntz> but agda, at least when I used it, just straight up *has* coinductive types like infinite streams, without needing to explicitly introduce laziness through functions
[05:46:26] <bjz_> rusti: for std::u8::range(0, 1) |x| { return true; }
[05:46:28] -rusti- more than 5 lines of output, pastebinned: http://sprunge.us/PGgZ
[05:46:38] <steven_is_false> rntz: Right but we were talking about Agda, not ML. So () -> x to make a thunk doesn't work.
[05:46:39] <Eridius> bjz_: well return means something different in a for block
[05:47:11] <rntz> Eridius: I guess you can't use return in || { ... } functions, then.
[05:47:30] <rntz> rusti: fn(x) { x }
[05:47:32] -rusti- more than 5 lines of output, pastebinned: http://sprunge.us/VVVB
[05:47:36] <strcat> Eridius: it means something really shady in a for loop ;p
[05:47:47] <rntz> rusti: fn(x:int) { x }
[05:47:48] -rusti- more than 5 lines of output, pastebinned: http://sprunge.us/CjUH
[05:47:57] <bblum> rntz: fn closure literals don't exist anymore
[05:48:00] <rntz> ...
[05:48:09] <rntz> okay, so I either declare a fn or I use || { ... } ?
[05:48:10] <rntz> blech.
[05:48:19] <bblum> || is lambda, not fn
[05:48:25] <bjz_> rusti: |x:int| { x }
[05:48:32] <rntz> bblum: ... what?
[05:48:32] *** Quits: carter (carter@moz-12C317EF.nyc.res.rr.com) (Ping timeout)
[05:48:43] <strcat> rntz: plain fn doesn't need an environment
[05:49:07] <strcat> although I guess the inliner mostly takes care of that anyway...
[05:49:25] <Eridius> filed #6965 about the return issue
[05:49:28] <bblum> rntz: || in rust is fn => in sml
[05:49:31] <bjz_> rusti: let x = 1; let f = || { x }; f()
[05:49:32] -rusti- 1
[05:49:32] <bblum> fn in rust is fun in sml
[05:49:32] <rntz> strcat: you mean, "fn f(x: int) { fn b(y: int) -> int { x + y } }" doesn't work?
[05:49:46] <strcat> rntz: that won't work
[05:49:48] <rntz> bblum: yeah yeah, sure. but what if I want a function literal in which I can invoke "return"?
[05:49:58] <rntz> strcat: well that... sucks
[05:50:01] *** Quits: ysuzuki (ysuzuki@moz-A563888C.ics.keio.ac.jp) (Client exited)
[05:50:07] <rntz> I can't name my functions and also capture environment?
[05:50:10] <rntz> are you *sure*?
[05:50:15] <strcat> Eridius: https://mail.mozilla.org/pipermail/rust-dev/2013-June/004364.html related to 'for'
[05:50:15] <bblum> let x = || ...
[05:50:19] <bblum> to name your function :P
[05:50:27] <steven_is_false> rntz: Use trampolines, and continuation passing style?
[05:50:36] <rntz> bblum: okay, and what if I want to use "return" in my function?
[05:50:38] *** Joins: ysuzuki (ysuzuki@moz-A563888C.ics.keio.ac.jp)
[05:50:39] <rntz> also, is "let" recursive by default?
[05:50:44] <bjz_> rusti: let mut x = 1; let f = || { x }; println(f().to_str()); x +=1; f()
[05:50:45] <strcat> steven_is_false: trampolines are a no-no with a language like C/Rust afaik
[05:50:46] -rusti- more than 5 lines of output, pastebinned: http://sprunge.us/GLjg
[05:50:52] <strcat> steven_is_false: they mean executable stack/heap afaik
[05:51:13] <bjz_> rusti: let mut x = 1; let f = || { x }; println(fmt!("%?", f())); x +=1; f()
[05:51:13] *** Quits: jaen (jaen@moz-E0979827.copit.pl) (Ping timeout)
[05:51:14] -rusti- 1
[05:51:14] -rusti- 2
[05:51:16] <rntz> i,i let mut rec ... and ... 
[05:51:29] <dbaupp> strcat: is there an issue for the .take/.skip inference bug?
[05:51:34] <rntz> bblum: wait, are fn decls seriously not closure anymore?
[05:51:42] <strcat> dbaupp: uh, sort of - I filed a bug before I knew what was going on
[05:51:46] <bblum> fn decls have never been closures
[05:51:46] <rntz> who the hell decided that? that's awful
[05:51:52] <rntz> ... :( :( :(
[05:51:52] <strcat> dbaupp: I think another should be filed, let me find it
[05:52:00] <bblum> rntz: the reason you can't recurse with closures is because it's unsound
[05:52:05] <rntz> bblum: what
[05:52:23] <steven_is_false> strcat: Isn't just returning a function to be executed trampolining?
[05:52:24] <rntz> that's just not true. SML does this fine :P
[05:52:27] <dbaupp> strcat: well, adding a dummy type param works, I'll PR it in a sec but I want to annotate it with an issue
[05:52:33] *** Quits: Cromulent (Cromulent@moz-983B638D.cable.virginmedia.com) (Quit: KVIrc 4.2.0 Equilibrium http://www.kvirc.net/)
[05:52:35] <rntz> I think what you mean is "your region system is broken and you haven't fixed it", maybe 
[05:52:44] <strcat> steven_is_false: all code has to be read-only and known at compile-time though
[05:52:44] <rntz> but seriously, not being able to recurse from a closure?
[05:52:52] <strcat> steven_is_false: if you don't want  an executable stack/heap
[05:52:58] <dbaupp> bblum: you can recurse with closures safely, if you don't mutate anything in the environment
[05:53:03] <bblum> dbaupp: correct
[05:53:13] <bblum> but that means a subset of closures can recurse, not all of them
[05:53:17] <dbaupp> yeah
[05:53:18] <Eridius> recursing in closures interacts with mutating owned pointers badly
[05:53:19] *** Quits: eatkinson (eatkinson@moz-5CF47426.dia.static.qwest.net) (Quit: eatkinson)
[05:53:21] <aatch> rntz, dial it down a bit, would ya
[05:53:24] <rntz> besides, I can just Y-combinator myself into recursing with a closure
[05:53:34] <strcat> steven_is_false: rust is memory safe outside of "unsafe" but it would still be throwing away that layer of protection
[05:53:34] <bblum> rntz: read this post
[05:53:34] <bblum> http://smallcultfollowing.com/babysteps/blog/2013/04/30/the-case-of-the-recurring-closure/
[05:53:37] <rntz> so not letting me refer to myself directly doesn't save you
[05:53:46] <strcat> steven_is_false: unless there's some other way to implement them that I'm not thinking of.
[05:54:09] <strcat> but I think LLVM's trampolines make the stack executable, they're used for gcc's nested fn extension
[05:54:10] <steven_is_false> strcat: I meant the high level meaning of trampoline https://en.wikipedia.org/wiki/Trampoline_(computers)#High_level_programming not the low level.
[05:54:19] <rntz> bblum: okay, sure, but if fn decls have never been closures this is not an explanation of why fn-decls aren't closures now
[05:54:25] <rntz> since this was presumably realized rather later
[05:54:32] <bblum> rntz: the gist of that post is: you can only Y combinator a closure if the closure is copyable
[05:54:40] <strcat> steven_is_false: ah
[05:54:42] <bblum> the way to fix the soundness bug is to restrict copyability
[05:54:46] <rntz> -._
[05:54:54] <rntz> _-_
[05:54:55] <strcat> steven_is_false: why must terms be so overloaded :(
[05:55:08] <dbaupp> strcat: https://github.com/mozilla/rust/issues/5801 right?
[05:55:18] <strcat> dbaupp: yeah, that
[05:55:22] <strcat> it might not even be the same bug
[05:55:32] <strcat> yeah that was a different one iirc
[05:55:34] <rntz> bblum: well, not being able to recurse with closures makes me very sad :(
[05:55:43] <strcat> dbaupp: I reported another with closures and std::iter, a different one
[05:55:58] <bblum> rntz: such is the price of a language both systems and functional
[05:56:03] <strcat> dbaupp: anyway I think the take/drop thing deserves an issue by itself because it's a much clearer bug
[05:56:20] <rntz> bblum: eh, I don't buy it. it's the price of rust's particular set of design choices.
[05:56:22] <strcat> could be related, or the same thing - but it's definitely easier to understand
[05:56:31] <bblum> this is true
[05:56:33] <rntz> not some general thing you can't get away with if you want to be both functional and systemsy
[05:57:28] <rntz> okay, I should read this at some point
[05:57:35] *** Quits: sp3d (a@moz-49806493.dhcp.stls.mo.charter.com) (Client exited)
[05:57:46] <bblum> and then you should read my proposal for closure reform ;)
[05:58:02] <dbaupp> strcat: could you open it? (I'm not quite sure I understand the bug...)
[05:58:02] <rntz> my completely uninformed intuition is that rust's regions, aliasing, and closure rules are getting too complicated for its own good, but that's a completely uninformed bullshit opinion from someone who just wants to have recursive closures, dammit
[05:58:07] <rntz> and I really need to sleep now :P
[05:58:09] <strcat> dbaupp: yeah I will
[05:58:11] *** Quits: royw (royw@moz-E9B4079C.hsd1.ca.comcast.net) (Quit: royw)
[05:58:13] <bblum> rntz: consider also
[05:58:21] <bblum> what if you want a closure to capture a noncopyable type?
[05:58:33] <bblum> affine closures can't recurse either.
[05:58:34] <strcat> dbaupp: I ended up with a good understanding of the limitations of regions and type inference from dealing with this stuff ;p
[05:58:38] * rntz -> sleep
[05:59:23] <bblum> and that's not just a limitation of particular systemsy features
[06:00:18] *** Joins: sp3d (a@moz-49806493.dhcp.stls.mo.charter.com)
[06:00:20] <strcat> bblum: C++ closures actually leave out capture by-move because it's too hard to get right even if you don't care much about safety ;p
[06:00:29] <strcat> maybe they'll add that for C++14 though.
[06:00:42] <bblum> "hard to get right if you don't care about safety"
[06:00:48] <bblum> how could it be hard; then any answer would be right :P
[06:00:55] <strcat> bblum: even if*
[06:01:05] <strcat> and the other key word is "much" :)
[06:01:20] <strcat> they care about safety, but only in the sense that they don't want to make it absolutely impossible to reason about
[06:01:28] <strcat> really hard to reason about? sure :)
[06:01:33] <bblum> c.c
[06:03:11] <strcat> bblum: constexpr is their back door way of slowly adding safety >:)
[06:03:40] *** Quits: pyrac (pyrac@moz-96C2FD1F.w109-214.abo.wanadoo.fr) (Quit: pyrac)
[06:03:41] <strcat> constexpr == referential transparency, it was just disguised as compile-time function evaluation ;p
[06:03:47] *** Joins: carter (carter@moz-12C317EF.nyc.res.rr.com)
[06:03:59] *** Quits: carter (carter@moz-12C317EF.nyc.res.rr.com) (Quit: Textual IRC Client: www.textualapp.com)
[06:04:07] *** Quits: steven_is_false (user@moz-144077DE.bchsia.telus.net) (Client exited)
[06:04:23] <bblum> o_O
[06:04:31] *** Joins: pyrac (pyrac@moz-96C2FD1F.w109-214.abo.wanadoo.fr)
[06:04:51] <strcat> bblum: atm they have to consist of a single statement (return statement) but... http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2013/n3652.html
[06:05:28] <strcat> anyway other languages have bigger problems than we do ;p
[06:05:40] *** Joins: true_droid (Adium@moz-123FD9B8.beck.volia.net)
[06:05:54] <bblum> they're so bad
[06:06:09] <mark_edward> hey, how would you name constructor type function
[06:06:18] <mark_edward> like i have a noarg ::new
[06:06:26] <strcat> that's the convention
[06:06:31] <Jeaye_> 1080 errors. Not bad.
[06:06:33] <mark_edward> but like, how do you name the others
[06:06:53] <aatch> mark_edward, depends on what they do.
[06:06:55] <strcat> new(), new_reserve(mem_to_reserve), from_some_type(bar)
[06:07:07] <aatch> I have in one type, new, new_opaque and new_anonymous
[06:07:14] <mark_edward> what does that do?
[06:07:42] <aatch> what do you mean?
[06:08:01] <strcat> bblum: by 2030, C++ will have borrowck in constexpr. just watch ;p
[06:08:07] <Eridius> ack, I just discovered another range issue. u8::range(0, 255) |x| ... doesn't quiiiiite do what I want
[06:08:36] <engla> right Eridius it's been discussed before
[06:09:06] <strcat> Eridius: what does it do? infinite loop?
[06:09:12] <Eridius> strcat: it goes from 0 to 254
[06:09:18] <strcat> oh
[06:09:28] <dbaupp> strcat: that .take issue? ;P
[06:09:51] <strcat> dbaupp: oh right.
[06:10:41] <strcat> rusti: use std::iterator::*; Counter::new(0, 10).take_while(|&x| x < 4).to_vec()
[06:10:42] -rusti- ~[0]
[06:10:47] <strcat> heh
[06:10:57] <strcat> rusti: use std::iterator::*; Counter::new(0, 2).take_while(|&x| x < 4).to_vec()
[06:10:58] -rusti- ~[0, 2]
[06:11:06] <strcat> rusti: use std::iterator::*; Counter::new(0, 2).take(2).to_vec()
[06:11:07] -rusti- more than 5 lines of output, pastebinned: http://sprunge.us/DCCU
[06:11:15] <strcat> oh well that's a perfect example
[06:11:15] <bblum> strcat: with aliasing pointers? no way
[06:11:27] <strcat> bblum: they have different rules in 'constexpr' though
[06:11:36] <strcat> bblum: 'Allow mutation of objects whose lifetime began within the constant expression evaluation.'
[06:11:48] <bblum> yeah
[06:12:01] <strcat> bblum: I'm not sure if constexpr really allows much with pointers
[06:12:02] <bblum> sounds an awful lot like the 'pure' of olde
[06:12:14] <strcat> definition can't mutate through parameters
[06:12:19] <strcat> definitely*
[06:12:29] <bblum> what if you tried constexpr(*(void *)0)
[06:13:05] <strcat> bblum: it seems like constexpr has no undef behaviour
[06:13:26] <strcat> I don't really understand
[06:13:47] <bblum> i mean will it refuse to compile that
[06:13:52] <bblum> or will it try to compile that and crash
[06:14:32] <strcat> bblum: it won't compile that alone
[06:14:35] <strcat>  an operation that would have undefined behavior [ Note: including, for example, signed integer overflow (Clause 5), certain pointer arithmetic (5.7), division by zero (5.6), or certain shift operations (5.8) ]; 
[06:14:43] <strcat> (things that won't compile)
[06:15:04] <strcat> but I'm not sure if you can cause those things to happen... it seems like division by zero is trivial to cause ;\
[06:15:07] * strcat tries
[06:17:25] <strcat> bblum: it just refuses to compile with division by zero I guess.
[06:17:49] <strcat> gcc 4.7 seems broken
[06:17:54] *** Quits: Voomer (Voomer@moz-E97E8EB7.br.br.cox.net) (Connection reset by peer)
[06:17:56] *** Joins: Voomer (Voomer@moz-E97E8EB7.br.br.cox.net)
[06:18:36] *** Joins: ghrust (ghrust@24260B07.6A2AE50.F3114085.IP)
[06:18:37] <ghrust> 01[13rust01] 15bors merged 06auto into 06incoming: 02http://git.io/TU4Sfg
[06:18:37] *** Parts: ghrust (ghrust@24260B07.6A2AE50.F3114085.IP) ()
[06:18:47] <mark_edward> can you leave out members in the record syntax?
[06:18:54] <strcat> bblum: so undef behaviour can't happen at *compile-time* but it can still happen at runtime afaict.
[06:19:03] <strcat> depends on when you evaluate the fn
[06:19:05] <strcat> weird stuff
[06:19:15] <strcat> foo.cc:4:1: error: non-constant condition for static assertion
[06:19:18] <strcat> div by zero is non-constant
[06:19:19] <engla> mark_edward: you can have a struct with no members
[06:19:28] <strcat> div by two is constant
[06:19:58] <mark_edward> engla: no i mean struct Point {x: int, y:int} let p = Point {};
[06:20:02] <mark_edward> is that valid?
[06:20:09] <dbaupp> mark_edward: no
[06:20:16] <mark_edward> ok
[06:20:44] <engla> mark_edward: you could implement Zero for point and do let p = zero::<Point>();
[06:21:04] <engla> or let p: Point = zero(); etc.
[06:22:25] *** Quits: pyrac (pyrac@moz-96C2FD1F.w109-214.abo.wanadoo.fr) (Quit: pyrac)
[06:22:41] <bblum> strcat: that's about the best you could hope for
[06:23:33] <strcat> bblum: it is definitely weird. they can dereference a null/dangling reference passed at runtime, but a constexpr function can't *create* a null or dangling reference
[06:24:26] <strcat> and same with division by 0
[06:24:47] <strcat> so basically.... C++ can be safe if you don't run anything after the compile
[06:24:49] <strcat> :D
[06:26:58] *** Quits: strcat (strcat@moz-54F7FD49.cpe.net.cable.rogers.com) (Quit: sleep)
[06:26:59] <bjz_> engla: you can't access the zero function as standalone now, it has to be via Zero::zero
[06:29:12] <engla> oh. I was used to importing it
[06:29:35] <bjz_> engla: yeah, that was forbidden
[06:29:57] <engla> that's inconvenient
[06:30:17] <engla> but I think it will be fixed in due time
[06:30:20] <bjz_> it might be reinstated though
[06:30:26] <bjz_> yeah
[06:30:31] <engla> let p = Point::zero; 
[06:30:47] <engla> for example it could be like that
[06:31:07] *** Joins: fabiand (fabiand@5B9ECCE8.5E545589.16E13E53.IP)
[06:31:18] <bjz_> engla: https://github.com/mozilla/rust/pull/6462
[06:31:48] <true_droid> is it deliberate that variables after let are highlighted in the tutorial?
[06:31:59] <true_droid> this makes it difficult to read "let mut owned = ~20;"
[06:32:16] <true_droid> where both mut and owned are the same color
[06:32:30] <engla> thanks for the link bjz_ 
[06:32:33] <bjz_> engla: zero would have to be an associated function on Point if you wanted that way of accessing zero
[06:32:39] *** Joins: Blei (philipp@moz-96D25F7A.cust.bluewin.ch)
[06:33:03] <bjz_> engla: you would only be able to access zero via the Zero trait
[06:33:08] <engla> bjz_: it could be like in https://github.com/mozilla/rust/issues/6894  I thought
[06:33:10] <bjz_> ie. Zero::zero
[06:33:20] <bjz_> read the thread
[06:33:41] <bjz_> that's what I expected, but it seems not to be
[06:34:23] <engla> ok
[06:35:09] <bjz_> :(
[06:35:36] <bjz_> The question is whether using :: in that way would confuse people
[06:36:26] *** Joins: mzabaluev (mzabaluev@moz-91FFD755.dhcp.inet.fi)
[06:39:13] *** Quits: mzabaluev (mzabaluev@moz-91FFD755.dhcp.inet.fi) (Ping timeout)
[06:39:46] *** Quits: blitter (blitter@moz-BA14D5CF.dyn.centurytel.net) (Ping timeout)
[06:45:26] *** Quits: moonchrome (moonchrome@4C0859E0.C952C54B.76F1346C.IP) (Quit: Leaving)
[06:45:54] <true_droid> are clojures really only limited to a single expression?
[06:46:13] <engla> no
[06:48:51] <engla> rusti: ~[1,2].all(|&x| { println(fmt!("Checking %d", x)); x > 0 })
[06:48:52] -rusti- Checking 1
[06:48:52] -rusti- Checking 2
[06:48:52] -rusti- ~true
[06:49:11] <dbaupp> rusti: (|| { let mut x = 1; x += 1; x })()
[06:49:12] -rusti- 2
[06:49:17] <true_droid> engla: so it's only the tutorial then, thanks
[06:49:23] <true_droid> or does Rust call {} an exression
[06:49:24] <true_droid> ?
[06:49:31] <dbaupp> true_droid: the latter
[06:49:41] <dbaupp> rusti: (|| let mut x = 1; x += 1; x)()
[06:49:42] -rusti- more than 5 lines of output, pastebinned: http://sprunge.us/EfHG
[06:49:59] <dbaupp> rusti: (|| 1 + 2; 3)()
[06:50:00] -rusti- <anon>:10:18: 10:19 error: expected `)` but found `;`
[06:50:00] -rusti- <anon>:10          (|| 1 + 2; 3)()
[06:50:00] -rusti-                             ^
[06:50:00] -rusti- application terminated with error code 101
[06:50:06] <true_droid> the tutrial says "Closures begin with the argument list between vertical bars and are followed by a single expression." so that was confusing
[06:50:07] *** Quits: SimonSapin (simon@5924A8D9.7F79A810.4065847B.IP) (Ping timeout)
[06:50:09] <true_droid> thinks for clearing it up
[06:50:48] <true_droid> and all the examples of closures have only one expression in them, with or without {}
[06:50:49] <Eridius> rusti: 1 + { 2; 3 }
[06:50:50] -rusti- 4
[06:50:55] <Eridius> {} is definitely an expression
[06:51:32] <true_droid> it's never mentioned in the tutorial
[06:51:33] *** Joins: SimonSapin (simon@5924A8D9.7F79A810.4065847B.IP)
[06:51:40] <Eridius> true_droid: the docs need some love
[06:52:09] <xenocons> rusti: struct t { x: int }; let p = t { x: 1};
[06:52:10] -rusti- ()
[06:53:12] <xenocons> so that should work..
[06:53:16] *** Joins: victorporof (victorporo@60FA9E67.483E5FE1.9B1E38F4.IP)
[06:55:38] <Eridius> xenocons: it did work
[06:55:46] <Eridius> rusti: struct t { x: int }; let p = t { x: 1}; p
[06:55:48] -rusti- {x: 1}
[06:58:32] <xenocons> Eridius: yeah not in rustc for some reason
[06:58:52] <xenocons> error: expected item but found `let`
[06:58:55] *** Quits: fabiand (fabiand@5B9ECCE8.5E545589.16E13E53.IP) (Quit: Verlassend)
[06:59:52] <true_droid> where could I propose a change in the tutorial? mailing list?
[07:02:00] <Eridius> true_droid: you could submit a pull request
[07:02:16] <Eridius> xenocons: are you putting `let` at the top level in your .rs?
[07:02:29] <xenocons> Eridius: yeah, does it have to be contained within a function?
[07:02:37] <Eridius> xenocons: yeah
[07:02:58] <xenocons> whats the best way to do a huge number of static structs that are post populated
[07:03:02] <xenocons> er
[07:03:06] <xenocons> pre-populated
[07:03:24] <xenocons> i.e. i dont want to have to bind them within functions
[07:03:32] <Eridius> you could try `static p : t = t { x: 1};` but I'm not sure if structs can be statics
[07:03:37] *** Joins: pyrac (pyrac@29E99D66.73C89388.AD05C589.IP)
[07:03:51] <Blei> yes, that should work
[07:03:52] <xenocons> ah, not semantic static i guess, just that i wont be changing them after creation
[07:03:58] <xenocons> let me try
[07:04:18] <Blei> xenocons: `static` is the way to declare global constant data in rust
[07:04:32] <xenocons> ah right
[07:04:44] <xenocons> is the : t required? 
[07:04:49] <Blei> what do you mean by "sematic static"?
[07:05:19] <engla> xenocons: yes the type is required
[07:06:50] <true_droid> I've also found a bunch of places with duplicate words in the comments, in multiple files
[07:07:08] <true_droid> is it OK to send a PR with fixes in many different files' comments?
[07:07:13] <dbaupp> true_droid: yeah
[07:07:15] <xenocons> ok good that at least got over it the first time!
[07:07:15] <xenocons> ty
[07:07:24] <xenocons> ill just tweak the struct field types i think
[07:07:40] <dbaupp> true_droid: lumping it as one commit is fine too
[07:07:54] <true_droid> dbaupp: thanks, I'll do it
[07:08:17] <dbaupp> true_droid: (probably broken into separate commits for each crate (libstd libextra ...) though)
[07:09:53] <xenocons> alright more errors, but i think i know about this one
[07:10:29] *** Joins: koomi (koomi@moz-CBF7646B.pools.arcor-ip.net)
[07:12:55] <Jeaye_> Is anyone pushing for attributes on macros?
[07:13:58] <true_droid> can you decipher this?
[07:14:00] <true_droid> 	// The size of the stack arguments to copy to the new stack,
[07:14:00] <true_droid> 	// ane of the the arguments to __morestack
[07:15:15] <xenocons> rusti: struct s { x: str }; static p : s = s{x:&"p"};
[07:15:17] -rusti- more than 5 lines of output, pastebinned: http://sprunge.us/aUDh
[07:16:21] <dbaupp> rusti: struct s<'self> { x: &'self str }; static p : s<'static> = s{x:&"p"};
[07:16:24] -rusti- ()
[07:16:32] <dbaupp> xenocons: ^
[07:16:40] <geomyidae__> why does that notify everyone?
[07:16:45] <xenocons> dbaupp: i dont understand the use of 'self
[07:16:46] <geomyidae__> or is that irccloud's fault?
[07:16:56] <dbaupp> geomyidae__: it's apparently the fault of the irc client
[07:17:20] <dbaupp> (it's in the spec that notify is what bots should use, or something)
[07:17:24] <xenocons> dbaupp: is it an ownership thing?
[07:18:27] <dbaupp> xenocons: yeah
[07:18:27] <xenocons> hrm
[07:18:27] <dbaupp> xenocons: it's saying that the borrowed pointer needs to live at least as long as `s`
[07:18:27] *** Joins: MaikKlein (maik@moz-72D6CA68.dip0.t-ipconnect.de)
[07:18:27] <engla> xenocons: str is not a type by itself. either &str or ~str is
[07:18:27] <dbaupp> the other possibility there is &'static str, which says that the borrowed pointer is a pointer to static data
[07:18:27] <MaikKlein> this has also been renamed? "cast::transmute"
[07:18:33] *** Joins: cmr (moznet@F468AD76.B3752F1D.93D630DC.IP)
[07:18:36] *** Quits: an0nymous (an0nymous@moz-A6B0CE4.tx.res.rr.com) (Ping timeout)
[07:18:41] <dbaupp> MaikKlein: std::cast::transmute, maybe?
[07:18:45] <xenocons> right, ok
[07:18:58] <xenocons> so it compiles now with an empty fn main() {}
[07:19:01] *** Joins: an0nymous (an0nymous@moz-A6B0CE4.tx.res.rr.com)
[07:19:03] <xenocons> but now it looks really noisy :(
[07:19:23] <dbaupp> it's the price you pay for safety/performance
[07:19:30] <xenocons> yeah fair enough
[07:19:46] <xenocons> i can deal with that, it isnt stuff that will change anyway
[07:19:47] <MaikKlein> dbaupp, right thanks
[07:20:37] <MaikKlein> and what is with sys::size_of::?
[07:21:16] *** Quits: Yurume (yurume@AC58A8CE.8A059B47.E313B915.IP) (Ping timeout)
[07:21:21] <dbaupp> MaikKlein: i.e. sys::size_of::<int>() ?
[07:21:45] <MaikKlein> http://static.rust-lang.org/doc/core/sys.html#function-size_of
[07:21:46] <MaikKlein> hm
[07:21:59] <dbaupp> what do you mean?
[07:22:43] <Blei> it's probably std::sys::size_of now
[07:22:58] <MaikKlein> yes I am trying to port some code "sys::size_of::<GLfloat>()) as GLsizeiptr"
[07:23:15] <MaikKlein> right Beli
[07:23:20] <MaikKlein> it is std::sys now
[07:23:22] <engla> MaikKlein: prelude changed
[07:23:33] <dbaupp> MaikKlein: yeah, core got renamed to std, and the prelude no longer re-exports modules
[07:23:42] <MaikKlein> ok
[07:24:04] <dbaupp> you can fix the latter by just putting `use std::*;` at the top of each file
[07:24:41] <engla> it's much tidier to have all the std:: things under the same prefix
[07:25:47] <dbaupp> Blei: does your export all fix mean that main has to be public?
[07:26:37] <Blei> dbaupp: no it's an issue with an optimization of tests. see etc/combine-tests.py
[07:26:49] *** Quits: Jesin (Jessin_@moz-3AD6F09F.res.lehigh.edu) (Quit: Leaving)
[07:26:53] <Blei> it combines all tests into one huge crate and calls the main function of each test
[07:26:56] <dbaupp> oh, right it's the windows test runne
[07:27:03] <dbaupp> Blei: yeah
[07:27:20] *** Quits: Jeaye_ (Jeaye@moz-FD505E54.hsd1.ca.comcast.net) (Quit: Don't tell them I was here...)
[07:27:34] <Blei> previously, the tests that didn't export anything at all still got their main fn exported as the old export list rule was still followed
[07:27:53] <Blei> (i.e. export everything if a mod doesn't export anything)
[07:29:35] <xenocons> dbaupp: how do you write the type signature for an array of static structs? tried static parray : [s<'static>] = [...]
[07:29:51] <dbaupp> xenocons: &'static [s<'static>] = ...
[07:29:57] <xenocons> ah blast
[07:29:59] <Blei> hmm, is there a way in git to set a local branch to a different revision without checking out that branch?
[07:30:04] <xenocons> this is going to be tricky to remember heh
[07:30:08] <dbaupp> xenocons: (also, the rust convention is for uppercase struct/enum names)
[07:30:20] <xenocons> right, got it
[07:30:22] <dbaupp> xenocons: it's just a &[] vector, which is 'static
[07:30:56] *** Joins: robertknight (robertknig@moz-54528EE0.wby.mendeley.com)
[07:31:24] <xenocons> hmm
[07:31:35] <dbaupp> Blei: do you happen to want to fastforward incoming to upstream/incoming to rebase?
[07:32:22] <xenocons> dbaupp: ok got it working
[07:32:42] <Blei> dbaupp: yes to the first part, but i know that you can rebase on remote branches
[07:32:52] <xenocons> this is my first non tutorial program, seems that this should work well
[07:32:55] <dbaupp> Blei: oh
[07:33:00] <dbaupp> Blei: that was going to be my suggestion
[07:33:03] <xenocons> now, onto translating boyer moore C to rust heh
[07:33:26] <Eridius> true_droid: since you got no answer to your question, I suspect "ane" should be "and"
[07:33:31] <Blei> dbaupp: i'm always one step ahead of you, mr. bond
[07:34:12] <Eridius> Blei: `git push . commit:branch` is my favorite
[07:34:26] <Eridius> Blei: you may have to force it (with -f or +commit:branch) if it's not a fast-forward
[07:34:47] <Eridius> rebasing always requires checking it out because rebase needs a working copy
[07:35:01] <Eridius> to explain, . as a repo means "the current repo"
[07:35:10] *** Quits: MaikKlein (maik@moz-72D6CA68.dip0.t-ipconnect.de) (Ping timeout)
[07:35:12] <dbaupp> Blei: http://stackoverflow.com/questions/1591107/git-reset-other-branch-to-current-without-a-checkout
[07:35:13] <Blei> ah, cool
[07:35:15] <Eridius> and a nicety here is that, because it uses git-push, it will yell at you if you try to use this on the checked-out branch
[07:35:29] <dbaupp> Blei: `git update-ref refs/heads/OtherBranch refs/heads/CurrentBranch`
[07:35:30] <true_droid> Eridius: thanks
[07:35:43] <Eridius> dbaupp: that's a plumbing version
[07:35:43] <Blei> Eridius, dbaupp: thanks!
[07:35:47] <Eridius> `git push . foo` is nicer
[07:36:02] <dbaupp> Eridius: ok
[07:36:09] <dbaupp> Eridius: it does look nicer
[07:36:38] <Eridius> it also doesn't silently do the wrong thing if you forget refs/heads (which update-ref does)
[07:37:04] <xenocons> wait, before i do something silly, is there some built in function to do boyer moore heh
[07:37:41] <Eridius> ?
[07:39:21] <dbaupp> xenocons: no
[07:39:24] *** Quits: brson (brson@72B1AFF8.AD1E507F.3688B332.IP) (Ping timeout)
[07:39:32] <dbaupp> xenocons: the current str::find is a naive search
[07:39:41] <dbaupp> err, str::contains
[07:40:01] *** Quits: pyrac (pyrac@29E99D66.73C89388.AD05C589.IP) (Quit: pyrac)
[07:40:51] <xenocons> dbaupp: right
[07:40:59] <xenocons> probably wont work too well for large byte arrays then ;)
[07:41:13] <xenocons> (yeah i know it sounds crazy but boyer moore over byte arrays is the fastest way ive found so far)
[07:41:30] <xenocons> i should try it first though
[07:41:39] <xenocons> but if it stops at \0 itl be problematic
[07:42:11] <dbaupp> rusti: str::contains(str::repeat("abc", 100000), "abcabcabc1")
[07:42:12] -rusti- more than 5 lines of output, pastebinned: http://sprunge.us/NIPL
[07:42:16] <xenocons> brb usergroup meetup
[07:42:31] <dbaupp> rusti: use std::str; str::contains(str::repeat("abc", 100000), "abcabcabc1")
[07:42:33] -rusti- false
[07:42:43] <Eridius> oh is boyer moore the grep algo?
[07:42:48] <dbaupp> rusti: use std::str; str::contains(str::repeat("abc", 1000000), "abcabcabcabc1")
[07:42:49] -rusti- false
[07:43:22] *** Quits: engla (engla@moz-DBD1D96E.cust.bredbandsbolaget.se) (Ping timeout)
[07:43:53] <dbaupp> rusti: use std::str; str::contains(str::repeat("a", 1000000), fmt!("%s1", str::repeat("a", 10000)))
[07:44:00] -rusti- timeout triggered!
[07:45:50] <dbaupp> (whereas Python answers ('a'*10000 + '1') in ('a'*1000000) instantly)
[07:46:02] <mark_edward> rust needs Monads
[07:46:12] <mark_edward> i'm having to write so many matches and stuff
[07:46:25] <dbaupp> mark_edward: you can use .chain and .map
[07:46:46] <mark_edward> which types have those?
[07:46:48] <mark_edward> Result?
[07:46:54] <dbaupp> Option and Result
[07:47:18] <mark_edward> cool
[07:48:05] <dbaupp> true_droid: with that typo pull request
[07:48:11] *** Quits: jmsaunde (jmsaunde@moz-6FB6A254.cmclub.uwaterloo.ca) (Quit: leaving)
[07:48:12] <dbaupp> true_droid: core got renamed to std
[07:48:36] <dbaupp> true_droid: so I think you need to update the version of the incoming branch you have
[07:48:47] <true_droid> dbaupp: you are fast, I've just pulled from incoming and now fixing conflicts
[07:48:53] <dbaupp> (since it appears that libcore still exists in your branch)
[07:48:57] <dbaupp> oh, right, cool :)
[07:49:55] *** Joins: engla (engla@moz-DBD1D96E.cust.bredbandsbolaget.se)
[07:54:14] <mark_edward> chain doesn't seem 
[07:54:14] <mark_edward> work too well, since  every result has a different error type..
[07:55:02] <mark_edward> maybe map
[07:56:00] *** Quits: devbug (quassel@moz-E1DE087C.bchsia.telus.net) (Connection reset by peer)
[07:56:40] <dbaupp> oh, yeah, you can't change the error type with either map or chain
[07:56:42] <mark_edward> but TCP sockets aren't copyable
[07:56:47] <mark_edward> ARG!
[07:56:59] <dbaupp> (which is the same with Haskell's monads)
[07:57:29] <mark_edward> why do we use so many error types though. chain adn map would be more useful
[07:57:42] <mark_edward> with a unified error type
[07:57:51] <mark_edward> or an Error trait that things could be cast to maybe?
[07:58:27] <dbaupp> what do you mean by having so many error types?
[07:59:04] <dbaupp> Most things just return Err(~str), don't they?
[07:59:10] <mark_edward> nope
[07:59:15] <mark_edward> not in the net::* stuff
[07:59:50] <mark_edward> TcpConnectErrData , IpGetAddrError, and TcpErrData
[07:59:52] *** Joins: snadon (chatzilla@moz-3BC727E8.mc.videotron.ca)
[07:59:56] <dbaupp> oh
[08:00:00] <dbaupp> :(
[08:00:11] <dbaupp> well, you can turn them into strings
[08:00:18] <dbaupp> or just ()
[08:00:26] <mark_edward> yeah, it's either that or back to giant match trees
[08:00:37] *** Joins: ghrust (ghrust@AC22872E.6A2AE50.F3114085.IP)
[08:00:37] <ghrust> 01[13rust01] 15bors pushed 0 new commits to 06auto: 02http://git.io/5hZT8A
[08:00:37] *** Parts: ghrust (ghrust@AC22872E.6A2AE50.F3114085.IP) ()
[08:00:39] *** Joins: ghrust (ghrust@AD60B2E3.6A2AE50.F3114085.IP)
[08:00:39] <ghrust> 01[13rust01] 15bors pushed 3 new commits to 06auto: 02http://git.io/VkMMcw
[08:00:39] <ghrust> 13rust/06auto 14c7b19b0 15Alexei Sholik: Fix duplicate words in the docs
[08:00:39] <ghrust> 13rust/06auto 14e75572c 15Alexei Sholik: Deduplicate words in code comments
[08:00:39] <ghrust> 13rust/06auto 147ce700a 15bors: auto merge of #6966 : alco/rust/fix-typo, r=sanxiyn
[08:00:41] *** Parts: ghrust (ghrust@AD60B2E3.6A2AE50.F3114085.IP) ()
[08:01:57] *** Joins: novabyte (Instantbir@moz-A7154E60.mullvad.net)
[08:03:48] <Eridius> rusti: str::from_bytes([0])
[08:03:52] -rusti- more than 5 lines of output, pastebinned: http://sprunge.us/WRiS
[08:04:00] <Eridius> rusti: std::str::from_bytes([0])
[08:04:02] -rusti- ~"\x00"
[08:04:30] <Eridius> hmm, is 0 actually considered valid UTF-8?
[08:04:40] <Eridius> I guess so
[08:04:49] <dbaupp> Eridius: not sure, but rust's UTF-8 is wrong
[08:04:57] <dbaupp> rusti: (-1u) as char
[08:04:59] -rusti- rust: task failed at 'assertion failed: s.len() <= pad', /build/rust-incoming-git/src/rust/src/libstd/char.rs:211
[08:04:59] -rusti- rust: domain main @0xb891b0 root task failed
[08:04:59] -rusti- application terminated with error code 101
[08:05:44] <dbaupp> rusti: std::str::from_bytes([0xff,0xff,0xff,0xff,0xff,0xff,1])
[08:05:46] -rusti- rust: task failed at 'assertion failed: is_utf8(vv)', /build/rust-incoming-git/src/rust/src/libstd/str.rs:54
[08:05:46] -rusti- rust: domain main @0x1fb51b0 root task failed
[08:05:46] -rusti- application terminated with error code 101
[08:07:20] <aatch> dbaupp, bjz_, re-writing llvm bindings!
[08:07:21] <aatch> https://github.com/Aatch/llvm-rs/tree/rewrite
[08:10:06] <Eridius> dbaupp: it's wrong? I'm surprised that there are limits on what you can put into char, but I don't think a sequence of FF's is valid
[08:10:29] <dbaupp> Eridius: yeah, that was just me seeing how wrong it was
[08:10:37] <dbaupp> Eridius: and clearly it's not entirely broken
[08:10:42] <Eridius> oh that's not a limit on char, that's a limit on turning char into a printable string
[08:10:48] *** Joins: fabiand (fabiand@52C677F.66531EF5.16E13E53.IP)
[08:10:54] <Eridius> and to be fair, -1u isn't a valid codepoint
[08:10:58] <dbaupp> Eridius: but 2^64-1 is definitely not a valid unicode char
[08:11:13] <dbaupp> and so `as char` shouldn't be allowed to construct such a char
[08:11:40] <dbaupp> aatch: well, it's shorter, so far
[08:11:42] <Eridius> dbaupp: what is the definition of `char`? Anything that's a valid unicode codepoint, or just any integer that fits in a set number of bits?
[08:12:15] <dbaupp> Eridius: pretty sure it should be the former, since there's uint/u8/... for the latter
[08:12:31] <dbaupp> (I don't actually know what it is in rust terms though)
[08:12:49] <Eridius> yeah but adding runtime validation code every time you create a new value of a given datatype is kinda bad
[08:13:05] <dbaupp> well, safety
[08:13:06] <Eridius> given *primative datatype
[08:13:30] <dbaupp> if you need absolute performance, you should be manipulating &[u8]'s directly, I guess
[08:13:45] <dbaupp> (and how often does one cast an int to a char anyway?)
[08:15:11] <Eridius> it would have to be on all expressions that return a char, not just casts
[08:15:22] <dbaupp> basically, having a separate unicode char data-type is a silly abstraction if it is allowed to contain non-unicode data without unsafe code (since other code relies on it being valid)
[08:15:29] <Eridius> adding hidden fail!'s is nasty too
[08:15:44] <Eridius> let c = someChar + 1; // needs hidden validation code that could fail!
[08:15:55] <dbaupp> Eridius: strcat was advocating removing the ability to cast to a char
[08:16:01] <dbaupp> is that even valid?
[08:16:10] <Eridius> well I guess maybe it could mod
[08:16:11] <dbaupp> rusti: let c = 'a'; c + 1
[08:16:12] -rusti- more than 5 lines of output, pastebinned: http://sprunge.us/jZCB
[08:16:25] <dbaupp> rusti: let c = 'a'; c + 'a'
[08:16:26] -rusti- '\xc2'
[08:19:32] <Eridius> I still find it odd that a built-in datatype (e.g. str) has runtime validation to make sure it's utf-8
[08:19:36] <Eridius> never seen another language do that
[08:19:54] <Eridius> honestly, I think Go's solution, where anything that interprets a string as a sequence of runes gets the replacement rune on invalid sequences, is pretty elegant
[08:20:54] *** Quits: sk (sk@61A494B3.BA40E8A.AAC02D62.IP) (Quit: Leaving)
[08:20:55] *** Joins: Palmik (palmik@moz-5CA3F354.pks.muni.cz)
[08:21:11] <dbaupp> I guess Rust is more explicit about errors in general
[08:28:21] <true_droid> I didn't think anything was more explicit about errors than Go
[08:29:58] *** Quits: robertknight (robertknig@moz-54528EE0.wby.mendeley.com) (Quit: ["Textual IRC Client: www.textualapp.com"])
[08:30:17] <Eridius> dbaupp: one clear benefit of Go's approach is it can still process string data that is mostly valid but only slightly corrupted
[08:30:21] <Eridius> whereas rust will throw out the entire string
[08:30:39] <Eridius> maybe str::from_bytes should translate invalid sequences into the replacement char instead of failing
[08:30:50] <Ralith> of your data isn't utf8-encoded, don't decode it as utf8
[08:30:52] <Ralith> if*
[08:30:59] <Eridius> Ralith: you may not know if it's utf-8
[08:31:04] <dbaupp> Eridius: I believe the plan was to use 'conditions' there
[08:31:04] <Eridius> maybe it's supposed to be, but it's user input
[08:31:10] <Eridius> dbaupp: 'conditions'?
[08:31:15] <Ralith> you need to validate your input.
[08:31:21] <dbaupp> I don't really understand them
[08:31:39] <dbaupp> but basically the caller can substitute a function that the callee uses to "recover" from errors
[08:31:41] *** Joins: CarpNet (ac@moz-FD24B77.sohonet.co.uk)
[08:31:42] <Ralith> dbaupp: they're like exceptions, except you can resume from where they're raised
[08:32:12] <dbaupp> (by default, an unhandled condition is a failure, but one could use a condition that just drops the incorrect bytes, or replaces them with the correct thing)
[08:32:47] <dbaupp> true_droid: Go isn't about trying to encode error/no-error states into types as much as Rust (from what I've seen of Go)
[08:32:49] <Ralith> if they're anything like CL conditions, the raising code provides zero or more options to resume, one of which might in this case be 'replace with sentinel'
[08:35:06] <Eridius> rusti: str::from_bytes([0xEF, 0xBF, 0xBD])
[08:35:07] -rusti- more than 5 lines of output, pastebinned: http://sprunge.us/hdMD
[08:35:15] <Eridius> rusti: std::str::from_bytes([0xEF, 0xBF, 0xBD])
[08:35:16] -rusti- ~"\ufffd"
[08:35:19] <Eridius> hah
[08:35:31] <Eridius> silly me, that's the replacement char
[08:41:03] *** Joins: jensnockert (jensnocker@moz-8BE55278.customer.t3.se)
[08:43:26] *** Joins: dbaumgarten (quassel@moz-34D91103.dip0.t-ipconnect.de)
[08:51:36] *** Joins: ghrust (ghrust@2EE61FCC.6A2AE50.F3114085.IP)
[08:51:36] <ghrust> 01[13rust01] 15bors merged 06auto into 06incoming: 02http://git.io/VkMMcw
[08:51:36] *** Parts: ghrust (ghrust@2EE61FCC.6A2AE50.F3114085.IP) ()
[08:54:03] *** Joins: lucian (lucian@6B2B4644.4304AE1E.CE5E78F6.IP)
[08:54:55] <true_droid> I've just read about Monomorphization in the tutorial and I wonder: is Rust compiler capable of inlining something like do vector.each([1,2,3]) |&m| { â€¦ } to not use pointer indirection in the final generated code?
[08:57:10] <mleise> true_droid: maybe you better ask the LLVM developers ;)
[08:58:22] <dbaupp> true_droid: you can look at the generated asm with rustc -S, if you feel like it
[08:58:35] <mleise> by the way what indirection do you want to remove?
[08:59:02] <dbaupp> mleise: .each passes pointers to the elements of the vector, not the elements themselves
[08:59:03] <mleise> if m is a reference into the array that you want to update, it has to stay
[08:59:50] <true_droid> mleise: here's each implementation from the tutorial https://gist.github.com/alco/5720245
[09:00:07] <true_droid> it explains that a pointer is passed to op() to avoid copying of large types
[09:00:15] <mleise> sure, but my point is you need to look the items up from the array one way or another by use of a pointer into the array :p
[09:00:24] <true_droid> it's only int in this case but assume it's T
[09:00:39] *** Joins: snearch (snearch@moz-5F685442.pool.mediaways.net)
[09:00:41] <nmatsakis> bjz_: yeah, I think the problem there is that resolve needs to be refactored somewhat to incorporate impls in a deeper way
[09:00:48] <true_droid> yes, I was asking about the case where op is inlined and the compiler knows it doesn't need to take &v[n] anymore
[09:01:10] <mleise> v[n] would be far worse than &v[n]
[09:01:33] <mleise> the difference between picking something up or merely pointing at it
[09:01:53] <mleise> and *maybe* pick it up
[09:01:59] <Blei> nmatsakis: in librustc/middle/typeck/infer/mod.rs:613 is there a reason that this is self.try(f) instead of f() ?
[09:02:06] <true_droid> mleise: monomorphization should generate a specialized function for [int], should it not?
[09:02:13] <true_droid> that it's not necessary to use the pointer any more
[09:03:13] <dbaupp> true_droid: for vec::each there will always be a pointer look up
[09:03:24] <mleise> true_droid: I know near to nothing about Rust. Just saying that whatever the implementation is you are going to dereference the array elements on the CPU
[09:03:43] <dbaupp> true_droid: but it does get optimised to 4 instructions
[09:04:05] <dbaupp> (where it = `for v.each |i| { sum += *i; }`)
[09:04:08] *** Joins: davbo (dave@moz-3FFA637C.oucs.ox.ac.uk)
[09:04:31] <mleise> v[n] would just make it eager, whereas with &v[n] you can still skip the array access for some n if you like.
[09:04:45] <mleise> if n is available in the loop, that is
[09:06:31] <nmatsakis> Blei: yes, because we want to unroll any bindings it creates (as the comment says :)
[09:06:57] <nmatsakis> Blei: oh, I see, there is a start/rollback snapshot around it...
[09:07:01] <nmatsakis> Blei: um, let me check, maybe not.
[09:07:10] <Blei> yeah
[09:07:13] <Blei> that's what i meant
[09:07:33] <nmatsakis> Blei: no, I don't think there's a good reason.
[09:07:38] <nmatsakis> Blei: though it's harmless 
[09:08:11] <Blei> speeding up the compiler is always fun ;)
[09:09:44] <nmatsakis> Blei: I...doubt that will speed up the compiler by any measureable amount
[09:09:55] <nmatsakis> Blei: does it? :)
[09:10:20] <Blei> i doubt it
[09:15:23] <nmatsakis> Blei: ok. :) Not that I object, just that if you were going to tell me you saw a speedup, I'd want to investigate further!
[09:15:49] *** Joins: berak (chatzilla@4E443AD5.4742BCFA.1A5CC7E5.IP)
[09:16:23] *** Quits: SimonSapin (simon@5924A8D9.7F79A810.4065847B.IP) (Quit: Leaving.)
[09:21:56] *** Quits: fabiand (fabiand@52C677F.66531EF5.16E13E53.IP) (Ping timeout)
[09:22:05] *** Joins: doener (bs@moz-AA189A5A.unitymedia.biz)
[09:22:34] *** Joins: fabiand (fabiand@52C677F.66531EF5.16E13E53.IP)
[09:29:17] *** Joins: EXetoC (ex@moz-C741B177.customer.t3.se)
[09:33:54] *** Quits: berak (chatzilla@4E443AD5.4742BCFA.1A5CC7E5.IP) (Quit: .. too much fighting on the dancefloor ..)
[09:34:24] *** Joins: sk (sk@EA324BFE.54A580E3.78DD174B.IP)
[09:35:24] *** Joins: shachaf (shachaf@moz-F37E0395.members.linode.com)
[09:37:18] *** Quits: PeterSP (peter@moz-4DAF5777.bstnma.fios.verizon.net) (Ping timeout)
[09:40:47] *** Quits: hjr3 (hradtke@moz-E87BDF1F.socal.res.rr.com) (Quit: My MacBook has gone to sleep. ZZZzzzâ€¦)
[09:41:30] *** Joins: PeterSP (peter@moz-4DAF5777.bstnma.fios.verizon.net)
[09:42:15] *** Joins: pnkfelix (pnkfelix@moz-801E009D.vlan502.asr1.cdg2.gblx.net)
[09:42:30] *** Joins: pnkfelix|rcirc (pnkfelix@moz-801E009D.vlan502.asr1.cdg2.gblx.net)
[09:49:32] *** Quits: Blub\w (wry@moz-F4722437.wireless.dyn.drei.com) (Quit: WeeChat 0.4.0)
[09:56:07] *** Quits: victorporof (victorporo@60FA9E67.483E5FE1.9B1E38F4.IP) (Quit: victorporof)
[09:56:35] *** Quits: fabiand (fabiand@52C677F.66531EF5.16E13E53.IP) (Quit: Verlassend)
[09:59:04] *** Joins: victorporof (victorporo@60FA9E67.483E5FE1.9B1E38F4.IP)
[09:59:31] *** Quits: snadon (chatzilla@moz-3BC727E8.mc.videotron.ca) (Ping timeout)
[10:06:20] *** Quits: heftig (heftig@moz-C11B5B9D.dip0.t-ipconnect.de) (Ping timeout)
[10:08:08] *** Joins: heftig (heftig@moz-B1A193BC.dip0.t-ipconnect.de)
[10:08:45] *** Joins: FrozenCow (FrozenCow@moz-B2DF4929.chello.nl)
[10:10:41] *** Joins: donri (dag@moz-9BB61102.tbcn.telia.com)
[10:18:39] *** kimundi is now known as zz_kimundi
[10:19:12] *** Joins: sankha93 (Instantbir@3A62547A.1F4087EF.8B6C1D65.IP)
[10:22:32] *** Joins: berak (chatzilla@226CD9DB.BCE163C1.1A5CC7E5.IP)
[10:23:08] *** Parts: berak (chatzilla@226CD9DB.BCE163C1.1A5CC7E5.IP) ()
[10:24:45] *** Quits: thou (thou@moz-1C1CA9F7.fasttrackcomm.net) (Ping timeout)
[10:25:26] *** Joins: thou (thou@moz-1C1CA9F7.fasttrackcomm.net)
[10:26:27] *** Quits: snearch (snearch@moz-5F685442.pool.mediaways.net) (Quit: Verlassend)
[10:29:14] *** Joins: rookii (rookii@moz-336D4A3F.rdl801.qld.optusnet.com.au)
[10:30:58] *** Joins: Earnestly (earnest@6A917A59.5E1FD793.39C00A7A.IP)
[10:32:47] *** Quits: rookii (rookii@moz-336D4A3F.rdl801.qld.optusnet.com.au) (Client exited)
[10:33:28] *** Joins: rookii (rookii@moz-336D4A3F.rdl801.qld.optusnet.com.au)
[10:34:55] *** Quits: eternaleye (eternaleye@moz-76321711.hsd1.wa.comcast.net) (Ping timeout)
[10:37:56] *** Joins: eternaleye (eternaleye@moz-76321711.hsd1.wa.comcast.net)
[10:43:22] *** Quits: doomlord (doomlod@moz-3CF8202D.range81-159.btcentralplus.com) (Ping timeout)
[10:48:14] *** Quits: dbaumgarten (quassel@moz-34D91103.dip0.t-ipconnect.de) (Ping timeout)
[10:50:34] *** Joins: dbaumgarten (quassel@moz-35EC706A.dip0.t-ipconnect.de)
[10:51:49] *** Quits: dimension (dimension@moz-4CCD79C5.dsl.dynamic.simnet.is) (Quit: Leaving)
[10:53:44] <xenocons> hmm
[10:59:47] *** Joins: bsj (Mibbit@moz-98849A0B.ip46.fastwebnet.it)
[11:01:24] *** Quits: bsj (Mibbit@moz-98849A0B.ip46.fastwebnet.it) (Quit: http://www.mibbit.com ajax IRC Client)
[11:04:24] *** Quits: jensnockert (jensnocker@moz-8BE55278.customer.t3.se) (Input/output error)
[11:04:26] *** Joins: robertknight (robertknig@moz-54528EE0.wby.mendeley.com)
[11:05:26] *** Joins: fabiand (fabiand@moz-CFCB6878.adsl.alicedsl.de)
[11:10:02] *** Joins: Sorella (queen@B12A78F5.BA14766C.95C8B7C6.IP)
[11:11:17] *** Quits: donri (dag@moz-9BB61102.tbcn.telia.com) (Client exited)
[11:23:43] *** Joins: BizarreCake (BizarreCak@32C9829A.151E84E7.561471F8.IP)
[11:24:40] *** Joins: donri (dag@moz-9BB61102.tbcn.telia.com)
[11:35:56] *** Quits: fabiand (fabiand@moz-CFCB6878.adsl.alicedsl.de) (Quit: Verlassend)
[11:36:19] *** Quits: victorporof (victorporo@60FA9E67.483E5FE1.9B1E38F4.IP) (Quit: victorporof)
[11:36:44] *** Joins: judder (maradukewa@77329696.665C6EE0.950D3BB5.IP)
[11:37:19] *** Joins: fabiand (fabiand@moz-CFCB6878.adsl.alicedsl.de)
[11:39:17] *** Joins: jensnockert (jensnocker@moz-8BE55278.customer.t3.se)
[11:40:05] *** Joins: victorporof (victorporo@60FA9E67.483E5FE1.9B1E38F4.IP)
[11:43:16] *** Quits: solancile (solancile@moz-A1CFFAE5.hsd1.wa.comcast.net) (Ping timeout)
[11:52:21] <cmr> http://blog.golang.org/a-conversation-with-the-go-team
[11:56:52] <doener> cmr: too bad that the lz4 stuff didn't work out :-/
[11:57:18] <cmr> doener: yeah. data is always good to have, though
[12:00:00] *** Quits: int3_ (int3_@moz-ABE52D50.hsd1.ca.comcast.net) (Client exited)
[12:00:02] *** Quits: Blei (philipp@moz-96D25F7A.cust.bluewin.ch) (Quit: WeeChat 0.4.1)
[12:03:37] <heftig> cmr: lz4 was used to compress all the rust sections in the elfs?
[12:03:49] <cmr> heftig: just .notes.rustc, ie, the metadata.
[12:04:07] <cmr> err, .note.rustc, sorry
[12:04:13] <heftig> yet it increased filesize?
[12:04:32] <cmr> yes, lz4 is known to have worse compression ratio than zlib
[12:04:50] <heftig> oh, i thought it was uncompressed
[12:04:53] <cmr> keep in mind that metadata is like 2MB of libstd
[12:05:32] *** Joins: pyrac (pyrac@29E99D66.73C89388.AD05C589.IP)
[12:05:56] <cmr> right now it uses miniz
[12:11:46] *** Quits: ysuzuki (ysuzuki@moz-A563888C.ics.keio.ac.jp) (Client exited)
[12:13:21] <doener> btw, since you mentioned transitioning away from ebml, I wonder how complicated it would be to avoid reading the same ebml data over and over again. I once added a hacky cache somewhere in the type checking code, which made that pass about 25% faster IIRC. Never got around to check for a cleaner approach than what I had, though
[12:19:14] <cmr> I know almost nothing about how metadata works, I just look at profile traces :)
[12:19:23] <friggle> http://smallcultfollowing.com/babysteps/blog/2013/06/06/reducing-dst-annotation/
[12:19:54] *** Joins: maxli (maxli@F2D29657.F60B0462.67AC9B1.IP)
[12:22:27] <dbaupp> doener: do we reparse metadata repeatedly??
[12:26:01] <benh> rusti: struct S<T> { field: T } #[unsafe_destructor] impl<T: std::to_str::ToStr> Drop for S<T> { fn finalize(&self) { println(self.field.to_str()); } } fn main() { let s1 = S { field: 42 }; let s2 = S { field: main }; }
[12:26:02] -rusti- error: internal compiler error: unexpected failure
[12:26:02] -rusti- note: the compiler hit an unexpected failure path. this is a bug
[12:26:02] -rusti- note: try running with RUST_LOG=rustc=1,::rt::backtrace to get further details and report the results to github.com/mozilla/rust/issues
[12:26:02] -rusti- application terminated with error code 101
[12:26:18] <benh> heh
[12:26:23] <benh> RUST_LOG=rustc=1,::rt::backtrace rusti: ...
[12:27:10] <doener> dbaupp: maybe "reparse" isn't the right term. But the slow vuint_at is called repeatedly for the same "sections"(? -- I'm clueless about the terminology here)
[12:27:55] <doener> dbaupp: IIRC I added the cache hack somewhere in impl_trait_ref
[12:28:23] <doener> dbaupp: the else-branch there ends up reading the same metadata over and over again
[12:28:46] *** Joins: annodomini (lambda@moz-9AC5B452.hsd1.ma.comcast.net)
[12:29:37] <friggle> why was EBML chosen?
[12:30:10] <xenocons> Eridius: yeh
[12:30:26] *** Joins: int3_ (int3_@moz-ABE52D50.hsd1.ca.comcast.net)
[12:30:35] <xenocons> Eridius: i stole some generic implementation (C) but found it is incredibly fast for searching reasonably big byte arrays too
[12:31:21] <friggle> ebml being big-endian seems far from ideal
[12:32:26] <cmr> doener: I don't think that is right.
[12:32:42] <cmr> doener: csearch uses crate data from the cstore, which seems to be all cached
[12:33:32] *** Joins: jyeo (user@F2D29657.F60B0462.67AC9B1.IP)
[12:35:06] <doener> cmr: hm? The result of get_impl_trait isn't cached AFAICT
[12:35:27] <bstrie> is there a way to dispatch a method based on a type annotation? something like `"foo".bar::<bool>()` ?
[12:35:29] <doener> cmr: so it will run through reader::tagged_docs again, which is where vuint_at is called
[12:36:03] <dbaupp> doener: oh, I see
[12:36:04] <doener> cmr: I don't mean that the compressed metadata is read again and again, but it's decoded more than once
[12:36:23] <dbaupp> bstrie: if bar has a type parameter, then that should work
[12:36:35] <cmr> oh, yeah, look at that
[12:36:38] <cmr> doener: my bad
[12:36:39] *** Quits: int3_ (int3_@moz-ABE52D50.hsd1.ca.comcast.net) (Ping timeout)
[12:36:44] <dbaupp> rusti: std::rand::rng().gen::<float>()
[12:36:46] -rusti- more than 5 lines of output, pastebinned: http://sprunge.us/FPdX
[12:37:13] <dbaupp> rusti: use std::rand::*; rng().gen::<float>()
[12:37:14] -rusti- 0.25588051
[12:37:23] <dbaupp> rusti: use std::rand::*; rng().gen::<int>()
[12:37:24] -rusti- -450042796059087268
[12:37:44] <dbaupp> doener: oh, I see, can you re-add a cache there?
[12:38:11] <bstrie> dbaupp: then I'm not sure what the proper approach is: https://gist.github.com/bstrie/5721170
[12:38:38] <dbaupp> bstrie: you've got one too many <T>'s
[12:38:45] <bstrie> where at?
[12:38:59] <dbaupp> bstrie: you shouldn't need one on the fn from_str<T> in the trait
[12:39:07] <dbaupp> (or the corresponding <bool> in the impl)
[12:39:45] <bstrie> dbaupp: this is what I had before, and it gives me "error: this method does not take type parameters"
[12:39:49] <bstrie> bug?
[12:39:54] <dbaupp> oh
[12:39:55] <benh> rusti: struct S<T>(T); trait Tr {} impl Tr for &'static str {} #[unsafe_destructor] impl<T: Tr> Drop for S<T> { fn finalize(&self) { println(fmt!("drop %?", self)); } } { let s1 = S("foo"); let s2 = S(&[98u8, 97, 114, 0]); }
[12:39:56] <dbaupp> hm
[12:40:02] <benh> unsafe destructors are unsafe!
[12:40:02] <doener> dbaupp: Maybe. The one I had was just for testing, in a hot path, to see if there was any effect. Not quite what I'd submit as a PR. Would have to dig in deeper to find out where to actually put the cache.
[12:40:13] -rusti- drop &{__field__: "bar"}
[12:40:13] -rusti- drop &{__field__: "foo"}
[12:40:14] -rusti- ()
[12:40:40] *** Quits: LimeBurst (me@247D1419.D73964AC.27A8748.IP) (Ping timeout)
[12:40:50] <dbaupp> bstrie: then my example doesn't apply, because .gen() is parameterised, not the trait
[12:41:11] <dbaupp> bstrie: type inference should work
[12:42:13] <dbaupp> otherwise I think this falls under the (syntax) changes associated (heh) with the associated proposals
[12:43:11] <bstrie> hm, ok, thanks
[12:48:54] <bstrie> dbaupp: would you expect something like //gist.github.com/5721232 to work eventually?
[12:48:56] *** Joins: RMF (RMF@68B6AD91.A3D80C3C.8D19547B.IP)
[12:50:08] *** Quits: RMF (RMF@68B6AD91.A3D80C3C.8D19547B.IP) (Quit: Textual IRC Client: www.textualapp.com)
[12:50:45] *** Joins: RMF (RMF@68B6AD91.A3D80C3C.8D19547B.IP)
[12:51:09] <dbaupp> bstrie: if the method wasn't parameterised, yes... maybe (but I don't really know the details of the assoc. items stuff.)
[12:58:33] *** Joins: artagnon (uid7560@moz-A588D045.irccloud.com)
[12:59:20] *** Joins: brendan (brendaneic@moz-8D2B6369.sub-70-192-133.myvzw.com)
[12:59:55] *** Quits: koomi (koomi@moz-CBF7646B.pools.arcor-ip.net) (Ping timeout)
[13:01:57] *** Joins: mhi (mhi@moz-4814EA55.sanctioned.net)
[13:03:15] <benh> To what extent is #[unsafe_destructor] supposed to be unsafe, if used to enable destructors on types with parameters?
[13:08:44] *** Quits: brendan (brendaneic@moz-8D2B6369.sub-70-192-133.myvzw.com) (Ping timeout)
[13:10:19] *** zz_kimundi is now known as kimundi
[13:11:19] *** Joins: alexrp (zor@moz-180BED6.rfw.name)
[13:12:33] <kimundi> benh: The unsafeness exist if a type could contain borrowd pointers, either directly or indirectly due to type parameters that could instanciate to one with them.
[13:12:51] *** Joins: MrFahrenheit (RageOfThou@3FEF494C.29C984D5.783DEDCA.IP)
[13:13:21] <kimundi> benh: Because then during unwinding it could happen that your type holds a borrowd reference to a type that has been destroyed already
[13:14:01] *** Parts: jyeo (user@F2D29657.F60B0462.67AC9B1.IP) (ERC Version 5.3 (IRC client for Emacs))
[13:16:02] <benh> kimundi: Oh, so it's basically that the compiler can't ensure that the type implementing Drop is Owned, because it depends on type parameters?
[13:16:38] <kimundi> I think yes
[13:18:20] <bjz_> aatch: noice noice
[13:18:21] <benh> I filed https://github.com/mozilla/rust/issues/6971 because it seemed not entirely related to that sort of thing but I'm not sure if I'm just voiding the warranty myself here :)
[13:18:40] <bjz_> aatch: sorry, was out at the local FP group
[13:22:55] *** Joins: SimonSapin (simon@A5049320.3E93794D.61EA6C28.IP)
[13:24:34] *** Parts: judder (maradukewa@77329696.665C6EE0.950D3BB5.IP) ()
[13:26:26] *** Joins: samebchase (samuel@moz-7519FE69.net)
[13:26:55] *** Quits: hansjorg (hansjorg@moz-EECB5F79.static.cust.telenor.com) (Connection reset by peer)
[13:27:42] *** Joins: SiegeLord (sl@moz-CAF07B4C.hsd1.ma.comcast.net)
[13:27:42] *** Joins: scriptdevil (scriptdevi@moz-9E850855.xen.prgmr.com)
[13:28:38] *** Joins: igl (igl@moz-D41AA89.adsl.alicedsl.de)
[13:29:17] *** Quits: igl1 (igl@moz-8782C0CF.adsl.alicedsl.de) (Ping timeout)
[13:32:41] *** Quits: scriptdevil (scriptdevi@moz-9E850855.xen.prgmr.com) (Quit: leaving)
[13:33:59] *** Joins: caitp (caitp@moz-2E2F18CB.senecacollege.ca)
[13:34:02] *** Joins: hansjorg (hansjorg@moz-EECB5F79.static.cust.telenor.com)
[13:35:43] *** Joins: Yurume (yurume@AC58A8CE.8A059B47.E313B915.IP)
[13:37:15] *** Quits: annodomini (lambda@moz-9AC5B452.hsd1.ma.comcast.net) (Quit: annodomini)
[13:38:28] *** Joins: adu (ajr@moz-96FE9B84.washdc.fios.verizon.net)
[13:40:31] *** Parts: mhi (mhi@moz-4814EA55.sanctioned.net) ()
[13:43:28] *** Quits: z0w0 (zack@moz-1EDE5BC0.lnse1.woo.bigpond.net.au) (Client exited)
[13:43:41] *** Joins: z0w0 (zack@moz-1EDE5BC0.lnse1.woo.bigpond.net.au)
[13:44:38] *** Joins: lmandel (lmandel@F2D29657.F60B0462.67AC9B1.IP)
[13:46:37] *** Joins: cowboyd (cowboyd@1D8844A7.1B729417.CEE440B6.IP)
[13:47:33] <Thiez> the unsafe destructor bug is pretty funny.
[13:47:40] <Thiez> does fmt! think it's a &str? :)
[13:48:17] *** Joins: MaikKlein (maik@moz-72D6CA68.dip0.t-ipconnect.de)
[13:49:19] *** Joins: Blei (philipp@moz-96D25F7A.cust.bluewin.ch)
[13:50:31] *** Quits: SimonSapin (simon@A5049320.3E93794D.61EA6C28.IP) (Ping timeout)
[13:52:14] *** Quits: hansjorg (hansjorg@moz-EECB5F79.static.cust.telenor.com) (Quit: Leaving.)
[13:52:19] *** Joins: hansjorg (hansjorg@moz-EECB5F79.static.cust.telenor.com)
[13:53:20] *** Joins: moonchrome (moonchrome@moz-77761FFA.dsl.iskon.hr)
[13:54:44] *** Joins: ghrust (ghrust@1E8607E8.6A2AE50.F3114085.IP)
[13:54:44] <ghrust> 01[13rust01] 15bors pushed 0 new commits to 06auto: 02http://git.io/SO45Ig
[13:54:44] *** Parts: ghrust (ghrust@1E8607E8.6A2AE50.F3114085.IP) ()
[13:54:46] *** Joins: ghrust (ghrust@C621748.6A2AE50.F3114085.IP)
[13:54:46] <ghrust> 01[13rust01] 15bors pushed 2 new commits to 06auto: 02http://git.io/GgA5Ag
[13:54:46] <ghrust> 13rust/06auto 1413df119 15Philipp BrÃ¼schweiler: infer: remove superfluous call to try()
[13:54:46] <ghrust> 13rust/06auto 148f18ea8 15bors: auto merge of #6969 : Blei/rust/no-try, r=bstrie
[13:54:46] *** Parts: ghrust (ghrust@C621748.6A2AE50.F3114085.IP) ()
[13:55:57] <bstrie> artagnon: I see your "echo" pull request, are you working on any more little cleanups like that? every PR we merge requires a full cycle on the test bots, so it's better to batch tiny changes like those together
[13:56:37] <artagnon> No, not really.  I just send in stuff as soon as I notice.
[13:56:57] <artagnon> I don't really have a plan of any sort.
[13:57:05] <artagnon> Sorry about the triviality of the patch.
[13:57:27] <bstrie> artagnon: no problem, it's always good to have more eyes on the code :)
[13:59:09] <bstrie> it seems like just a style issue, so I'll hold off on approving it for now
[14:02:13] *** Quits: pyrac (pyrac@29E99D66.73C89388.AD05C589.IP) (Quit: pyrac)
[14:03:08] *** Joins: reyre_ (reyre@moz-9002CDDA.cpe.net.cable.rogers.com)
[14:04:02] *** Quits: engla (engla@moz-DBD1D96E.cust.bredbandsbolaget.se) (Ping timeout)
[14:05:10] <artagnon> Can you verify that I haven't misunderstood something in my latest pull request?
[14:05:55] <artagnon> Mistakes in the tutorial are quite worrying.
[14:07:44] <bstrie> artagnon: ah yes, that's a recent change
[14:07:47] <bstrie> good catch
[14:08:00] <artagnon> Oh, good.  Thanks.
[14:09:02] <Blei> isn't it supposed to be the other way around? i.e. return false when breaking?
[14:09:17] <artagnon> I explained that in the commit message.
[14:09:34] *** kimundi is now known as zz_kimundi
[14:09:44] <artagnon> (I thought true made sense)
[14:10:55] *** Quits: bytbox (s@moz-D83E9B31.wireless.umd.edu) (Ping timeout)
[14:11:04] <artagnon> true => successfully found an odd number (or whatever else), which is why we wrote the function in the first place.
[14:12:11] <artagnon> std::vec::each returns !broke.
[14:12:20] <dbaupp> artagnon: the rest of the Rust code does false = break, true = not break (for both the iterating functions, like `op`, and for the iterators themselves like `each`)
[14:12:45] <bstrie> artagnon: I believe Blei is correct, it should return false in the break case. it's not a test, it's just a part of the `for` protocol
[14:12:49] <artagnon> Okay, I'll change it then.
[14:13:09] *** Joins: pyrac (pyrac@29E99D66.73C89388.AD05C589.IP)
[14:13:37] <artagnon> Done.
[14:13:40] <Blei> apparently this as well is nowwhere documented...
[14:13:50] <Blei> (the newer version of the for protocol)
[14:15:04] *** Quits: Amanieu (amanieu@moz-D5D10CA8.halls.manchester.ac.uk) (Connection reset by peer)
[14:15:45] *** Joins: Amanieu (amanieu@moz-D5D10CA8.halls.manchester.ac.uk)
[14:16:05] *** Joins: saml (sam@moz-14C16814.cst.lightpath.net)
[14:20:08] *** Quits: lahwran (lahwran@lahwran.net) (Ping timeout)
[14:20:29] *** Quits: true_droid (Adium@moz-123FD9B8.beck.volia.net) (Quit: Leaving.)
[14:20:42] *** Joins: lahwran (lahwran@lahwran.net)
[14:21:44] <bstrie> artagnon: approved, thanks!
[14:22:06] *** Quits: dbaupp (Thunderbir@moz-C6B1454A.lns20.syd7.internode.on.net) (Ping timeout)
[14:22:34] <bstrie> haha, I see that tj holowaychuk has found rust
[14:24:34] *** Joins: bytbox (s@moz-D83E9B31.wireless.umd.edu)
[14:26:11] <bstrie> I know we've had discussions on uniform function call syntax in the past, but does anyone remember *where*?
[14:28:48] *** Joins: jagaj (Mibbit@moz-917EA306.tampfl.fios.verizon.net)
[14:29:01] *** Joins: ksev (DrunkenPan@745B767B.989A61DC.CA5B6332.IP)
[14:30:52] <jagaj> hello, I'm looking into rust, but I develop xplat gui based   applications
[14:31:06] <jagaj> are there reasonably decent bindings for a ui toolkit for rust currently?
[14:32:01] <bstrie> jagaj: not yet, that I know of
[14:32:15] <bstrie> well, I think there might be bindings for cocoa?
[14:32:28] <bstrie> surely servo's drawing its UI somehow
[14:32:29] *** Joins: unbracketed (textual@moz-7F0EE151.lsanca.fios.verizon.net)
[14:33:24] <jagaj> it seems like it wouldn't be an issue to just use gtk/wx/qt directly
[14:33:36] <jagaj> but I'm about 10 minutes into looking at the language so I don't know :)
[14:33:48] *** Quits: KindOne (KindOne@moz-74BCFC6C.dynamic.ip.windstream.net) (Ping timeout)
[14:37:52] *** Parts: caitp (caitp@moz-2E2F18CB.senecacollege.ca) ()
[14:38:03] *** Joins: alisdair (textual@E1CEBB1A.D061F0C9.AA6AEE7B.IP)
[14:38:04] *** Quits: alisdair (textual@E1CEBB1A.D061F0C9.AA6AEE7B.IP) (Client exited)
[14:38:44] *** Joins: Scriptor (historium@moz-E06F46F0.corp.bitshelter.com)
[14:39:10] *** Joins: alisdair (textual@E1CEBB1A.D061F0C9.AA6AEE7B.IP)
[14:39:33] <bstrie> jagaj: there exists a tool for generating rust bindings from C header files: https://github.com/crabtw/rust-bindgen
[14:39:53] <bstrie> but I'm not sure how much manual tweaking it would require afterward
[14:40:03] <bstrie> for example, it doesn't pick up any functions that are defined as macros
[14:40:10] *** Joins: wilsonk-laptop (kvirc@moz-39EFBFC2.cg.shawcable.net)
[14:40:43] *** Quits: wilsonk|2 (kvirc@moz-39EFBFC2.cg.shawcable.net) (Ping timeout)
[14:43:05] *** Quits: ksev (DrunkenPan@745B767B.989A61DC.CA5B6332.IP) (Ping timeout)
[14:44:17] <jagaj> ok bstrie, thanks. I'll look into it
[14:44:35] <bstrie> jagaj: you might also want to ask again later, when more people might be on
[14:44:38] *** Quits: alisdair (textual@E1CEBB1A.D061F0C9.AA6AEE7B.IP) (Quit: My MacBook Pro has gone to sleep. ZZZzzzâ€¦)
[14:45:19] *** Quits: MaikKlein (maik@moz-72D6CA68.dip0.t-ipconnect.de) (Ping timeout)
[14:45:50] *** Joins: ghrust (ghrust@9C8B94D4.6A2AE50.F3114085.IP)
[14:45:50] <ghrust> 01[13rust01] 15bors merged 06auto into 06incoming: 02http://git.io/GgA5Ag
[14:45:50] *** Parts: ghrust (ghrust@9C8B94D4.6A2AE50.F3114085.IP) ()
[14:48:49] *** Joins: ghrust (ghrust@24260B07.6A2AE50.F3114085.IP)
[14:48:49] <ghrust> 01[13rust01] 15bors pushed 0 new commits to 06auto: 02http://git.io/jFSBJA
[14:48:49] *** Parts: ghrust (ghrust@24260B07.6A2AE50.F3114085.IP) ()
[14:48:53] *** Joins: ghrust (ghrust@E7A4CCE2.6A2AE50.F3114085.IP)
[14:48:53] <ghrust> 01[13rust01] 15bors pushed 3 new commits to 06auto: 02http://git.io/0Xx3CQ
[14:48:53] <ghrust> 13rust/06auto 14c2cb238 15Ramkumar Ramachandra: test/compile-fail: clarify bad-for-loop...
[14:48:53] <ghrust> 13rust/06auto 14dd923e3 15Ramkumar Ramachandra: tutorial: fix for-loop example...
[14:48:53] <ghrust> 13rust/06auto 148450dc8 15bors: auto merge of #6972 : artagnon/rust/bad-for-loop, r=bstrie...
[14:48:56] *** Parts: ghrust (ghrust@E7A4CCE2.6A2AE50.F3114085.IP) ()
[14:50:55] *** Quits: bytbox (s@moz-D83E9B31.wireless.umd.edu) (Ping timeout)
[14:51:44] *** Joins: bytbox (s@moz-D83E9B31.wireless.umd.edu)
[14:54:38] <Thiez> I don't think we can properly avoid the ABA-problem with our current set of Atomics :(
[14:54:38] *** Quits: pascal (pascal@moz-3A678551.pascalj.de) (Client exited)
[14:54:49] *** Joins: KindOne (KindOne@90FB4CF8.8E36DE4.EC6A1518.IP)
[14:56:57] *** Joins: spider-mario (spidermari@moz-2F72F6FF.dsl.quantic-telecom.net)
[15:03:59] *** Quits: unbracketed (textual@moz-7F0EE151.lsanca.fios.verizon.net) (Quit: Computer has gone to sleep.)
[15:05:10] <Thiez> never mind that, we can, it'll just be ugly :D
[15:07:42] *** Quits: doomlord_ (walter@moz-3CF8202D.range81-159.btcentralplus.com) (Ping timeout)
[15:07:57] <mleise> lol why is everyone suddenly into atomic operations
[15:08:35] *** Joins: doomlord_ (walter@moz-8F385DB0.range109-153.btcentralplus.com)
[15:08:58] <Thiez> I was always into atomic ops :)
[15:09:08] <Thiez> and because they are rather important in a few specific cases
[15:09:11] *** Joins: Blub\w (wry@7E3BB9D.71150E1A.237AE2BA.IP)
[15:09:50] *** Joins: LimeBurst (me@247D1419.D73964AC.27A8748.IP)
[15:10:44] <Thiez> more specifically, we want some lockless datastructures for the new scheduler to be nice and fast
[15:11:35] <cmr> Don't atomic ops just push the locking down a layer, eg to cache coherency?
[15:12:42] *** Joins: doomlord (doomlod@moz-8F385DB0.range109-153.btcentralplus.com)
[15:12:53] <Thiez> yes/no/sortof :p
[15:13:30] <Thiez> you have to perform atomic ops to lock, so you're using them regardless
[15:13:37] <cmr> mmm
[15:13:38] <Thiez> with or without locks
[15:14:20] <Thiez> but locks have several rather nasty disadvantages
[15:14:57] <Thiez> for example, if a task is unscheduled while holding a lock
[15:16:30] <Thiez> true lock-free algorithms can survive any task being unscheduled indefinitely at any time :)
[15:18:29] <Thiez> too bad they're usually a bitch to implement [correctly] :D
[15:19:15] *** Quits: cowboyd (cowboyd@1D8844A7.1B729417.CEE440B6.IP) (Client exited)
[15:19:47] <cmr> The difference between lock and lock-free, generically, is that lock-free has guarantees about global progress and lack of deadlock, right? Or is that wait-free.
[15:19:58] <Amanieu> correct
[15:20:21] <Amanieu> the difference between wait-free and lock free is that wait-free guarantees all threads make progress at any time
[15:20:28] <cmr> ah
[15:20:31] <Amanieu> but lock-free only guarantees at least one thread makes progress
[15:20:50] <Thiez> Amanieu: but that also applies to locks :)
[15:20:53] <Amanieu> no
[15:21:03] <Thiez> well, locks don't even guarantee that at least one thread makes progress :D
[15:21:09] *** Quits: rookii (rookii@moz-336D4A3F.rdl801.qld.optusnet.com.au) (Client exited)
[15:21:10] <Amanieu> with locks, if the thread holding a lock is suspended then no threads make progress
[15:21:57] *** Joins: cowboyd (cowboyd@1D8844A7.1B729417.CEE440B6.IP)
[15:22:25] <Amanieu> in practice nobody uses wait-free algorithms because they tend to be a lot slower
[15:22:45] <Amanieu> but lock-free algorithms are about the same speed as using locks
[15:22:57] <cmr> that's what I found when I was doing some light research on queues
[15:25:49] *** Quits: jagaj (Mibbit@moz-917EA306.tampfl.fios.verizon.net) (Quit: http://www.mibbit.com ajax IRC Client)
[15:26:44] <toddaaro> Thiez: ouch, ABA is a pain, what particular case are you talking about?
[15:28:06] <Thiez> toddaaro: I'm working on a lock-free queue for the new scheduler
[15:28:30] <toddaaro> fun, doing a chase lev?
[15:28:42] <toddaaro> <- just started working on the new scheduler as an intern
[15:29:01] *** Joins: lkuper (lkuper@moz-C0CD33ED.hsd1.in.comcast.net)
[15:29:12] <Thiez> I think aatch was working on the chase-lev work-stealing algorithm
[15:29:20] <Thiez> I was looking at the MessageQueue
[15:29:25] <toddaaro> ah ok, I think I looked at that code yesterday
[15:29:44] <toddaaro> so yours is single reader on one end, multiple writers on the other?
[15:29:48] <Thiez> it's improved slightly since yesterday, mostly comments : https://github.com/Thiez/rust/blob/ll-message-queue/src/libstd/rt/message_queue.rs
[15:30:01] <Thiez> actually I grabbed a multiple reader / multiple writer implementation
[15:30:02] *** Quits: jensnockert (jensnocker@moz-8BE55278.customer.t3.se) (Ping timeout)
[15:30:11] *** Joins: jdm (jdm@DB05BBF2.BB1F48F2.971E19F6.IP)
[15:30:13] <Thiez> so I can probably simplify the 'pop' operation a lot :p
[15:31:02] <cmr> from what I found Michael/Scott queues are the best algorithm, but I didn't look very far
[15:31:06] <cmr> http://www.cs.rochester.edu/u/scott/papers/1996_PODC_queues.pdf
[15:31:21] <toddaaro> Michael/Scott is what I'm familiar with for more general use
[15:31:24] <toddaaro> what did you pick?
[15:31:53] * cmr has no formal education and can't critically analze algorithms yet
[15:32:30] <Thiez> I grabbed it from 'The Art of Multiprocessor Programming', I think it's the same algorithm
[15:33:39] <toddaaro> ok, that will be a super useful data structure to have lying around
[15:33:43] <toddaaro> I wish you luck!
[15:33:52] *** Quits: sankha93 (Instantbir@3A62547A.1F4087EF.8B6C1D65.IP) (Ping timeout)
[15:34:11] <Amanieu> I wrote a work stealing queue a while ago
[15:34:16] <artagnon> What are these #[...] annotations called, and which part of the code should I be reading to learn more about them?
[15:34:18] <Amanieu> https://github.com/Amanieu/asyncplusplus/blob/master/src/work_steal_queue.h
[15:34:27] <cmr> artagnon: Attributes, and nowhere in specific.
[15:34:27] <Amanieu> If it helps :)
[15:34:37] *** Joins: sankha93 (Instantbir@3A62547A.1F4087EF.8B6C1D65.IP)
[15:34:42] <cmr> artagnon: Attributes are metadata associated with items, and the code handling them is very ad-hoc by nature.
[15:34:50] <artagnon> Where are they implemented though?
[15:34:56] <artagnon> In libsyntax?
[15:35:01] <cmr> They are parsed in libsyntax, yes.
[15:35:14] <cmr> See the meta_item struct
[15:35:19] <cmr> enum, actually
[15:35:21] <cmr> ast::meta_item
[15:36:14] <artagnon> Got it, thanks.
[15:38:29] *** Joins: eholk (eholk@moz-F8E3901F.uconnect.utah.edu)
[15:38:58] *** Joins: jensnockert (jensnocker@moz-8BE55278.customer.t3.se)
[15:39:04] <moonchrome> why don't integer literals get auto casted to floats, eg.
[15:39:14] <moonchrome> rusti, let x : float = 0
[15:39:29] <cmr> moonchrome: really annoying. I think there's an issue for it, just hasn't been done yet.
[15:39:46] *** Joins: ghrust (ghrust@F6EE6DE3.6A2AE50.F3114085.IP)
[15:39:46] <ghrust> 01[13rust01] 15bors merged 06auto into 06incoming: 02http://git.io/0Xx3CQ
[15:39:46] *** Parts: ghrust (ghrust@F6EE6DE3.6A2AE50.F3114085.IP) ()
[15:39:58] <moonchrome> cmr, oh I thought it was by design, phew 
[15:41:54] <bstrie> cmr moonchrome: no, this is intential. float inference only works on forms like `let x = 0.0;`
[15:42:28] *** Quits: DasIch (dasich@moz-756B08B1.clients.your-server.de) (Connection reset by peer)
[15:43:35] *** Joins: jorendorff (jorendorff@moz-FAB36621.hsd1.tn.comcast.net)
[15:43:38] *** Joins: DasIch (dasich@moz-5EDA591.de)
[15:45:06] <cmr> rusti: let x: float = 0; x
[15:45:08] -rusti- more than 5 lines of output, pastebinned: http://sprunge.us/dFWI
[15:45:10] <cmr> rusti: 5
[15:45:11] -rusti- 5
[15:45:42] *** Joins: eatkinson (eatkinson@moz-5CF47426.dia.static.qwest.net)
[15:45:55] *** Quits: eatkinson (eatkinson@moz-5CF47426.dia.static.qwest.net) (Quit: eatkinson)
[15:46:08] *** Quits: jorendorff (jorendorff@moz-FAB36621.hsd1.tn.comcast.net) (Quit: jorendorff)
[15:46:19] <moonchrome> bstrie, why ?
[15:46:26] *** Joins: jorendorff (jorendorff@moz-FAB36621.hsd1.tn.comcast.net)
[15:46:39] <bstrie> moonchrome: because it's important to draw a distinction between integers and floats
[15:47:01] <bstrie> we used to not have float inference at all, and you had to write `1.0f32` everywhere
[15:47:08] <moonchrome> bstrie, struct Point {x: float, y: float}; Point{x: 0, y: 0}
[15:47:20] <bstrie> Point{x: 0.0, y: 0.0}
[15:47:35] <moonchrome> bstrie, :|
[15:47:38] <cmr> I can see why when there's no type annotation... but when you do, I don't see why 0 shouldn't *always* by that type's 0
[15:47:51] <moonchrome> exactly
[15:48:04] <bstrie> there's no built-in concept of zero
[15:48:18] <moonchrome> bstrie, or any other int literal 
[15:48:35] <cmr> Yes there is? std::num::Zero
[15:48:44] <bstrie> you have to invoke a function if you want "zero": int::zero() or however it looks
[15:48:48] *** Joins: bent (chatzilla@moz-BE33DA21.fw1.sfo1.mozilla.net)
[15:48:55] <cmr> Anyway it'd only be for floats. It's a cosmetic thing.
[15:48:57] <bstrie> but it's not "built-in" in the sense that there's special syntax for it
[15:49:17] <cmr> rusti: let x: float = 0f
[15:49:18] -rusti- <anon>:11:4: 11:5 error: expected `;` but found `}`
[15:49:18] -rusti- <anon>:11     }));
[15:49:18] -rusti-               ^
[15:49:18] -rusti- application terminated with error code 101
[15:49:22] <cmr> rusti: let x: float = 0f; x
[15:49:24] -rusti- 0
[15:50:43] <Thiez> is this a bug: https://github.com/mozilla/rust/blob/incoming/src/libstd/ptr.rs#L178 ? The documentation says it copies 'count' elements (not bytes), but it doesn't calculate any elements
[15:51:31] <cmr> It also says "may overlap" and "does not overlap"
[15:52:20] *** Quits: jorendorff (jorendorff@moz-FAB36621.hsd1.tn.comcast.net) (Quit: jorendorff)
[15:52:36] *** Quits: pyrac (pyrac@29E99D66.73C89388.AD05C589.IP) (Ping timeout)
[15:52:37] <Thiez> I guess I'll fix it
[15:52:39] <cmr> Thiez: Looks like a bug to me.
[15:53:03] <Blei> Thiez: no, it uses the memcpy from the intrinsics module, which computes the counts
[15:53:11] <Blei> at least according to the documentation there
[15:53:20] <Thiez> oh, nice
[15:53:24] *** Quits: doener (bs@moz-AA189A5A.unitymedia.biz) (Quit: leaving)
[15:53:26] <cmr> Blei: It can't, though, since the pointers are casted to *mut u8 and *u8
[15:53:27] <Thiez> I was just checking that :p
[15:53:40] <cmr> Oh wait I'm looking at the wrong one
[15:54:16] <Thiez> these intrinsics are rather ugly ^^
[15:54:17] *** zz_kimundi is now known as kimundi
[15:55:09] *** Joins: MaikKlein (maik@moz-72D6CA68.dip0.t-ipconnect.de)
[15:56:12] <Thiez> working with unsafe code is more challenging in Rust that in C
[15:57:58] *** Quits: lmandel (lmandel@F2D29657.F60B0462.67AC9B1.IP) (Quit: lmandel)
[15:58:27] *** Quits: dbaumgarten (quassel@moz-35EC706A.dip0.t-ipconnect.de) (Client exited)
[15:58:36] *** Joins: igl1 (igl@moz-1D0B7E2E.adsl.alicedsl.de)
[15:58:39] *** Joins: Jesin (Jessin_@moz-3AD6F09F.res.lehigh.edu)
[15:58:55] *** Quits: igl (igl@moz-D41AA89.adsl.alicedsl.de) (Ping timeout)
[15:59:21] *** Joins: \n (NDesaulnie@2557E599.66715431.D25A875A.IP)
[15:59:53] <Thiez> than*
[16:00:31] *** Joins: int3_ (int3_@moz-ABE52D50.hsd1.ca.comcast.net)
[16:00:35] <Thiez> auto-deref on unsafe pointers would be nice in unsafe{} blocks when accessing elements
[16:02:19] *** Quits: int3_ (int3_@moz-ABE52D50.hsd1.ca.comcast.net) (Ping timeout)
[16:03:30] *** Joins: pnkfelix1 (pnkfelix@moz-801E009D.vlan502.asr1.cdg2.gblx.net)
[16:03:40] *** Quits: pnkfelix (pnkfelix@moz-801E009D.vlan502.asr1.cdg2.gblx.net) (Ping timeout)
[16:03:41] *** Joins: igl (igl@moz-B7343949.adsl.alicedsl.de)
[16:03:53] *** Quits: FrozenCow (FrozenCow@moz-B2DF4929.chello.nl) (Ping timeout)
[16:03:53] *** Quits: igl1 (igl@moz-1D0B7E2E.adsl.alicedsl.de) (Ping timeout)
[16:03:54] *** Joins: azita (Azita@2557E599.66715431.D25A875A.IP)
[16:04:19] *** Quits: pnkfelix|rcirc (pnkfelix@moz-801E009D.vlan502.asr1.cdg2.gblx.net) (Ping timeout)
[16:06:12] *** Joins: lmandel (lmandel@F2D29657.F60B0462.67AC9B1.IP)
[16:06:54] *** Joins: ksev (DrunkenPan@745B767B.989A61DC.CA5B6332.IP)
[16:06:58] <Thiez> what surprises me is that we have memmove32 and memmove64 exposed, wouldn't it make sense to only expose 'memmove' and let the compiler pick one?
[16:07:04] *** cscottnet_away is now known as cscottnet
[16:08:00] <cmr> llvm doesn't do that unfortunately.
[16:08:26] <cmr> "This is an overloaded intrinsic. You can use llvm.memmove on any integer bit width and for different address space. Not all targets support all bit widths however."
[16:08:44] <cmr> http://llvm.org/docs/LangRef.html#llvm-memmove-intrinsic
[16:09:38] <Thiez> fair enough, but Rustc knows for which target it is compiling, does it not?
[16:09:43] *** Quits: \n (NDesaulnie@2557E599.66715431.D25A875A.IP) (Ping timeout)
[16:09:46] *** Joins: \n (NDesaulnie@43CB6079.66715431.D25A875A.IP)
[16:09:48] <cmr> it does, that's what copy_nonoverlapping_memory is for.
[16:10:05] <Thiez> I find that hack rather disgusting :p
[16:10:14] <Thiez> would be prettier to do it inside the intrinsic
[16:11:07] *** pnkfelix1 is now known as pnkfelix
[16:11:08] *** Joins: eschweic (Adium@2557E599.66715431.D25A875A.IP)
[16:12:11] *** Joins: int3_ (int3_@moz-ABE52D50.hsd1.ca.comcast.net)
[16:12:48] *** cscottnet is now known as cscott
[16:12:57] *** Joins: true_droid (Adium@moz-123FD9B8.beck.volia.net)
[16:13:24] *** Quits: \n (NDesaulnie@43CB6079.66715431.D25A875A.IP) (Ping timeout)
[16:14:43] *** Joins: \n (NDesaulnie@2557E599.66715431.D25A875A.IP)
[16:15:45] *** Joins: ghrust (ghrust@AD60B2E3.6A2AE50.F3114085.IP)
[16:15:45] <ghrust> 01[13rust01] 15bors pushed 0 new commits to 06auto: 02http://git.io/Y3vo-Q
[16:15:45] *** Parts: ghrust (ghrust@AD60B2E3.6A2AE50.F3114085.IP) ()
[16:15:47] *** Joins: ghrust (ghrust@DE823A67.6A2AE50.F3114085.IP)
[16:15:47] <ghrust> 01[13rust01] 15bors pushed 3 new commits to 06auto: 02http://git.io/hqX6sg
[16:15:47] <ghrust> 13rust/06auto 14ab10b1e 15Ramkumar Ramachandra: libstd: fix comment in to_str impl of tuple...
[16:15:47] <ghrust> 13rust/06auto 1401c4f11 15Ramkumar Ramachandra: libstd: use fmt! in to_str impl for (one|two)-tuple...
[16:15:48] <ghrust> 13rust/06auto 14021e6d3 15bors: auto merge of #6975 : artagnon/rust/tuple-tostr, r=bstrie...
[16:15:50] *** Parts: ghrust (ghrust@DE823A67.6A2AE50.F3114085.IP) ()
[16:16:00] <cmr> *shrug* ask strcat why he did that when he gets on
[16:16:37] *** Joins: strcat (strcat@moz-54F7FD49.cpe.net.cable.rogers.com)
[16:18:54] *** Quits: cowboyd (cowboyd@1D8844A7.1B729417.CEE440B6.IP) (Client exited)
[16:20:24] <MaikKlein> speaking from the devil
[16:20:54] *** Quits: ksev (DrunkenPan@745B767B.989A61DC.CA5B6332.IP) (Ping timeout)
[16:21:14] *** Joins: cowboyd (cowboyd@1D8844A7.1B729417.CEE440B6.IP)
[16:22:28] *** Joins: jclements (jclements@moz-20AD2EFB.dsl.static.sonic.net)
[16:23:32] *** Joins: infynyxx (infynyxx@DB780A29.749BA1D.DCC373F0.IP)
[16:23:53] *** Joins: graydon (graydon@3853DDD.39EEDBB3.D758B1AA.IP)
[16:23:53] *** ChanServ sets mode: +qo graydon graydon
[16:24:53] *** Quits: cowboyd (cowboyd@1D8844A7.1B729417.CEE440B6.IP) (Client exited)
[16:26:54] <Thiez> ok, let's get this over with
[16:27:07] *** Joins: erickt (erickt@8C9ECD8F.3A598286.F12515B4.IP)
[16:27:36] <Thiez> strcat: any particular reason we have memmove64 and memmove32 intrinsics rather than a memmove intrinsic that chooses one of those during compilation based on the target architecture?
[16:27:44] *** Quits: erickt (erickt@8C9ECD8F.3A598286.F12515B4.IP) (Quit: Leaving.)
[16:28:03] <Thiez> (yes, I know we have copy_nonoverlapping_memory in ptr) :)
[16:28:07] <strcat> Thiez: nope, afaict. it was just that way before so I left it that way
[16:28:28] <strcat> I don't mind, no one else should be using that directly
[16:28:35] *** Quits: tiffany (kawaii@moz-1E0FE6E8.dhcp.embarqhsd.net) (Ping timeout)
[16:28:36] <strcat> just copy_memory and copy_nonoverlapping_memory
[16:28:47] <Thiez> fair enough
[16:28:55] <Thiez> my curiousity is properly satisfied :D
[16:30:52] *** Joins: erickt (erickt@8C9ECD8F.3A598286.F12515B4.IP)
[16:32:12] *** Joins: jorendorff (jorendorff@moz-B860E258.hsd1.tn.comcast.net)
[16:32:46] *** Quits: donri (dag@moz-9BB61102.tbcn.telia.com) (Client exited)
[16:32:57] *** Joins: donri (dag@moz-9BB61102.tbcn.telia.com)
[16:34:05] *** Joins: tjc (tjc@moz-B867959A.redactedconsulting.com)
[16:34:05] *** ChanServ sets mode: +o tjc
[16:34:24] *** Joins: pragmatic (pragmatic@moz-1A421840.hsd1.ca.comcast.net)
[16:34:44] *** Joins: judder (maradukewa@77329696.665C6EE0.950D3BB5.IP)
[16:35:25] *** Quits: jclements (jclements@moz-20AD2EFB.dsl.static.sonic.net) (Quit: jclements)
[16:35:25] *** Quits: Amanieu (amanieu@moz-D5D10CA8.halls.manchester.ac.uk) (Connection reset by peer)
[16:35:55] <cmr> strcat: the xz api is nice, and the documentation is very thorough, but it's scattered throughout all the header files.
[16:36:06] <strcat> heh
[16:36:44] *** Joins: Amanieu (amanieu@moz-D5D10CA8.halls.manchester.ac.uk)
[16:37:43] *** Quits: MaikKlein (maik@moz-72D6CA68.dip0.t-ipconnect.de) (Ping timeout)
[16:40:49] *** Joins: doener (doener@moz-121949B3.unitymediagroup.de)
[16:43:42] <moonchrome> am I only limited to one extern macro call inside a macro body ?
[16:44:15] <moonchrome> ie. https://gist.github.com/moonchrome/5722958 - only the first impl_vec_op call inside impl_vec_ops gets called
[16:44:52] <tjc> moonchrome: sounds like a compiler bug to me
[16:44:56] <pauls> moonchrome: The problem has to do with parsing.
[16:45:21] <pauls> moonchrome: a macro can only expand to a single item.
[16:45:45] <pauls> It's been an issue for a while.
[16:45:48] <cmr> pauls: Is that a design decision, or something that will hopefully be fixed later?
[16:45:55] <moonchrome> pauls, even with different arguments ?
[16:46:00] <pauls> cmr: the latter.
[16:46:27] <pauls> moonchrome: yes; it's just a matter of having trouble putting two items in the place occupied by a single item.
[16:47:02] <moonchrome> pauls, so if I put it inside a repeat block it still won't work ?
[16:47:30] <moonchrome> ie. $( impl_vec_op($op...) )+
[16:47:38] <pauls> moonchrome: what's 'it'? Currently the only workaround is to expand to a module and then import the things from the module.
[16:48:01] <pauls> It's not a semantic issue at all; it's all about the way the AST is structured.
[16:48:25] <moonchrome> nvm I get it
[16:50:23] *** Quits: fabiand (fabiand@moz-CFCB6878.adsl.alicedsl.de) (Ping timeout)
[16:52:53] *** Quits: lmandel (lmandel@F2D29657.F60B0462.67AC9B1.IP) (Quit: lmandel)
[16:53:04] *** Joins: fabiand (fabiand@moz-CFCB6878.adsl.alicedsl.de)
[16:53:24] *** Joins: MaikKlein (maik@moz-72D6CA68.dip0.t-ipconnect.de)
[16:54:27] *** Joins: lmandel (lmandel@F2D29657.F60B0462.67AC9B1.IP)
[16:54:31] *** Joins: cowboyd (cowboyd@1D8844A7.1B729417.CEE440B6.IP)
[16:55:32] *** Quits: sawrubh (uid6719@moz-D8B63698.irccloud.com) (Ping timeout)
[16:55:32] *** Quits: gmcabrita (uid4474@moz-D8B63698.irccloud.com) (Ping timeout)
[16:55:32] *** Quits: geomyidae__ (uid214@moz-C944F5EC.irccloud.com) (Ping timeout)
[16:55:32] *** Quits: SeanTAllen_ (uid4855@moz-D8B63698.irccloud.com) (Ping timeout)
[16:55:32] *** Quits: artagnon (uid7560@moz-A588D045.irccloud.com) (Ping timeout)
[16:55:40] *** Quits: DasIch (dasich@moz-5EDA591.de) (Ping timeout)
[16:56:13] *** Quits: stowellde (uid6365@moz-D8B63698.irccloud.com) (Ping timeout)
[16:56:13] *** Quits: molnarg (darkelf@moz-A80E711.clients.your-server.de) (Ping timeout)
[16:56:32] *** Quits: wycats_ (uid79@moz-C944F5EC.irccloud.com) (Ping timeout)
[16:56:32] *** Quits: jihyun (uid7128@moz-D8B63698.irccloud.com) (Ping timeout)
[16:56:50] *** Quits: decoder (quassel@moz-D7023D7D.own-hero.net) (Ping timeout)
[16:56:50] *** Quits: ruediger (quassel@moz-C9B8D8D0.org) (Ping timeout)
[16:57:02] *** Quits: mixi (mixi@moz-DBD8904A.org) (Ping timeout)
[16:57:06] *** Joins: jihyun (uid7128@moz-D8B63698.irccloud.com)
[16:57:14] *** Joins: decoder (quassel@moz-D7023D7D.own-hero.net)
[16:57:17] *** Joins: ruediger (quassel@moz-C9B8D8D0.org)
[16:57:38] *** Joins: annodomini (lambda@moz-6424FBF8.hfc.comcastbusiness.net)
[16:59:01] *** Joins: DasIch (dasich@moz-5EDA591.de)
[16:59:26] *** Joins: molnarg (darkelf@moz-A80E711.clients.your-server.de)
[17:00:55] *** Joins: jclements (jclements@2557E599.66715431.D25A875A.IP)
[17:01:13] <strcat> aatch: http://lists.cs.uiuc.edu/pipermail/llvmdev/2013-June/062707.html
[17:01:14] *** Quits: Amanieu (amanieu@moz-D5D10CA8.halls.manchester.ac.uk) (Ping timeout)
[17:01:33] *** Quits: jclements (jclements@2557E599.66715431.D25A875A.IP) (Quit: jclements)
[17:01:33] *** Quits: erickt (erickt@8C9ECD8F.3A598286.F12515B4.IP) (Quit: Leaving.)
[17:01:41] *** Quits: decoder (quassel@moz-D7023D7D.own-hero.net) (Quit: No Ping reply in 180 seconds.)
[17:01:56] *** Joins: decoder (quassel@moz-D7023D7D.own-hero.net)
[17:02:05] *** Joins: Amanieu (amanieu@moz-D5D10CA8.halls.manchester.ac.uk)
[17:03:32] *** Joins: jclements (jclements@2557E599.66715431.D25A875A.IP)
[17:03:38] <pnkfelix> nmatsakis: there's another mtg soon for us, right?
[17:04:07] <nmatsakis> pnkfelix: right.
[17:06:21] *** Joins: dherman (dherman@2557E599.66715431.D25A875A.IP)
[17:06:21] *** ChanServ sets mode: +o dherman
[17:06:36] *** Joins: brson (brson@2557E599.66715431.D25A875A.IP)
[17:06:36] *** ChanServ sets mode: +o brson
[17:06:53] *** Joins: ghrust (ghrust@9C8B94D4.6A2AE50.F3114085.IP)
[17:06:53] <ghrust> 01[13rust01] 15bors merged 06auto into 06incoming: 02http://git.io/hqX6sg
[17:06:53] *** Parts: ghrust (ghrust@9C8B94D4.6A2AE50.F3114085.IP) ()
[17:06:55] <pnkfelix> #rust-triage
[17:06:58] <cmr> brson: how goes the jemalloc mac testing?
[17:07:15] *** Joins: pcwalton (pcwalton@2557E599.66715431.D25A875A.IP)
[17:07:15] *** ChanServ sets mode: +o pcwalton
[17:07:57] *** Quits: bytbox (s@moz-D83E9B31.wireless.umd.edu) (Ping timeout)
[17:09:32] *** Joins: flu (flu@1B44C715.B5AB1363.2E11A1C0.IP)
[17:09:39] *** flu is now known as flu_
[17:09:43] *** Joins: ghrust (ghrust@2EE61FCC.6A2AE50.F3114085.IP)
[17:09:43] <ghrust> 01[13rust01] 15bors pushed 0 new commits to 06auto: 02http://git.io/75TVdg
[17:09:43] *** Parts: ghrust (ghrust@2EE61FCC.6A2AE50.F3114085.IP) ()
[17:09:44] *** Joins: ghrust (ghrust@AD60B2E3.6A2AE50.F3114085.IP)
[17:09:44] <ghrust> 01[13rust01] 15bors pushed 2 new commits to 06auto: 02http://git.io/W03MFA
[17:09:44] <ghrust> 13rust/06auto 1432228f3 15Huon Wilson: std: work-around for take/skip type inference (#6967)
[17:09:44] <ghrust> 13rust/06auto 140e96369 15bors: auto merge of #6968 : huonw/rust/takeskip-iter, r=thestinger...
[17:09:44] *** Parts: ghrust (ghrust@AD60B2E3.6A2AE50.F3114085.IP) ()
[17:10:01] *** Joins: hjr3 (hradtke@374E545A.3A8E9B0C.F9D9C60E.IP)
[17:10:07] *** Joins: mschifer (Adium@2557E599.66715431.D25A875A.IP)
[17:10:11] *** Quits: novabyte (Instantbir@moz-A7154E60.mullvad.net) (Quit: bye bye)
[17:11:29] *** Joins: blitter (blitter@moz-BA14D5CF.dyn.centurytel.net)
[17:11:37] <Amanieu> about the closure reform, has anyone considered treating closures as normal objects which implement a Callable interface?
[17:11:49] <Amanieu> here's a rough idea of what it would look like: http://pastebin.com/MkXH9HQB
[17:12:09] *** Joins: bytbox (s@moz-2E27684C.student.umd.edu)
[17:12:25] <cmr> Amanieu: that would preclude a non-insignificant amount of optimizations, wouldn't it?
[17:13:09] <Amanieu> not really
[17:13:11] <cmr> Also wouldn't handle environment capturing.
[17:13:27] <Amanieu> well the environment would be the object itself
[17:13:56] <strcat> Amanieu: but then each closure is a unique type
[17:14:04] <strcat> you still need a common way to pass them around
[17:14:18] <Amanieu> you can pass them as trait objects
[17:15:05] <Amanieu> this is pretty much identical to how they are represented now
[17:15:06] <brson> cmr: haven't started yet. today
[17:15:20] <Amanieu> old: {func, env} new: {vtable, env}
[17:15:20] <cmr> brson: ok
[17:15:53] <Amanieu> having a vtable is pretty much requires in order to have fn types with bounds
[17:15:57] <Amanieu> *required
[17:16:12] <Amanieu> since you need to store a pointer to the destructor somewhere
[17:16:24] <Amanieu> for fn:Owned()
[17:17:09] <moonchrome> is there a way to create a new identifier inside a macro from existing identifier (ie. prepend "v_" to $myidentifier) ?
[17:17:48] <pauls> moonchrome: today is the day where you hit all the longstanding macro issues ) :
[17:17:57] <jclements> moonchrome: I believe this is currently not workingâ€¦ but I think that hygiene will probably cause problems for you anyway. What's the use case here?
[17:18:32] <pauls> jclements: The equivalent thing in Scheme is fine, isn't it?
[17:18:53] <jclements> you can do it with syntax-case, but not with syntax-rules. 
[17:18:59] <pauls> You just have to be explicit about where you get the marks from.
[17:20:13] <moonchrome> turns out I don't need it anyway so I'm fine on this one :)
[17:20:30] <jclements> moonchrome: *that's* the response I was looking for :).
[17:20:32] *** Quits: bnicholson (bnicholson@moz-E98974C1.hsd1.ca.comcast.net) (Ping timeout)
[17:21:11] <Amanieu> Anyways, I'm just leaving this as food for though since I think it neatly solves all the issues listed in the closure reform page
[17:21:22] <pauls> jclements: ...but I see no reason it couldn't be built into syntax-rules.
[17:21:49] <jclements> it wouldn't be useful without capturing, and (afaik) syntax-rules can't create capturing macros.
[17:22:01] <jclements> am  I wrong?
[17:22:06] <pauls> https://mail.mozilla.org/pipermail/rust-dev/2013-February/003170.html
[17:22:52] <pauls> jclements: (that's not relevant to your question, though)
[17:23:12] <pauls> jclements: If you just steal the marks off of an identifier you did get, you should be good to go.
[17:23:55] <jclements> pauls: I agree that one could implement that, yes. urrg, trying to be in two places at once.
[17:24:12] <bstrie> Amanieu: if you have a suggestion, please either make a signed comment on the wiki page or just bring it up to nmatsakis right here
[17:25:10] <cmr> Amanieu: It certainly seems like a *very elegant* solution.
[17:25:58] *** Joins: erickt (erickt@8C9ECD8F.3A598286.F12515B4.IP)
[17:26:02] *** Quits: MaikKlein (maik@moz-72D6CA68.dip0.t-ipconnect.de) (Ping timeout)
[17:26:55] *** Joins: eatkinson (eatkinson@2557E599.66715431.D25A875A.IP)
[17:27:32] <sully> so, we don't use the interner anymore?
[17:27:33] <bstrie> graydon: re: the master/incoming split, it's been suggested that the large majority of issues people are facing right now could be solved by simply changing the default branch to "incoming" on github. this wasn't done in the past because incoming used to be broken three times a day, but today it seems worth it to avoid repeating "target your PRs to incoming" and "you need switch to incoming and recompile" over and over again
[17:27:39] <sully> but it still gets passed around?
[17:27:44] <sully> should it get ripped out?
[17:28:21] <cmr> sully: syntax::util::interner? I hope it gets used, it's in the top 5 of a trace of compilation of an empty file
[17:28:52] *** Quits: nielsle (nielsle@moz-5CE8ECCD.boa.fiberby.dk) (Ping timeout)
[17:29:30] <doener> cmr: IIRC only StrInterner is used
[17:29:39] <cmr> there was a PR just the other day for interning keywords
[17:29:46] <doener> cmr: the generic Interner has no users left
[17:29:54] <cmr> doener: ah
[17:30:21] <doener> couldn't decide whether to remove it when I added the StrInterner
[17:30:26] <doener> so I just left it there
[17:30:35] <moonchrome> this is a compiler bug right : https://gist.github.com/moonchrome/5723283
[17:30:44] <moonchrome> ?
[17:31:56] *** Quits: pragmatic (pragmatic@moz-1A421840.hsd1.ca.comcast.net) (Ping timeout)
[17:33:25] *** Joins: bnicholson (bnicholson@2557E599.66715431.D25A875A.IP)
[17:33:54] <bstrie> moonchrome: not sure why it's generating that impl twice
[17:34:37] <moonchrome> bstrie, it's not my code then right ?
[17:34:41] *** Quits: azita (Azita@2557E599.66715431.D25A875A.IP) (Quit: azita)
[17:35:06] <moonchrome> I'll just implement ToStr manually 
[17:35:08] <bstrie> moonchrome: you can look at the macro-expanded code with "rustc --pretty expanded"
[17:35:27] <bstrie> it looks like deriving is getting generated twice for some reason
[17:35:34] <moonchrome> bstrie, oh that's usefull
[17:37:43] *** Joins: ksev (DrunkenPan@745B767B.989A61DC.CA5B6332.IP)
[17:40:34] *** Joins: seth (seth@moz-D840E602.dsl.static.sonic.net)
[17:43:31] *** Joins: nielsle (nielsle@moz-5CE8ECCD.boa.fiberby.dk)
[17:45:19] *** Quits: CarpNet (ac@moz-FD24B77.sohonet.co.uk) (Quit: Leaving)
[17:45:22] <bstrie> moonchrome: https://github.com/mozilla/rust/issues/6976
[17:46:24] <bstrie> getting close to 7000 issues
[17:46:58] *** Quits: tjc (tjc@moz-B867959A.redactedconsulting.com) (Quit: zzzzzzzzzz)
[17:48:02] *** Quits: int3_ (int3_@moz-ABE52D50.hsd1.ca.comcast.net) (Client exited)
[17:48:52] <bblum> at first i was shocked at our issue count but then i realized it's probably half because of pull requests by now
[17:49:06] <moonchrome> bstrie, I have a feeling tho that it could already be known problem because the code I'm working off also doesn't use [deriving(ToStr)] where it should
[17:49:27] <bstrie> moonchrome: keep in mind that deriving in general is relatively new, it might simply be a legacy thing
[17:49:47] *** Quits: erickt (erickt@8C9ECD8F.3A598286.F12515B4.IP) (Quit: Leaving.)
[17:50:20] *** Quits: lucian (lucian@6B2B4644.4304AE1E.CE5E78F6.IP) (Ping timeout)
[17:50:20] <bstrie> bblum: true, there's ~2300 closed pull requests
[17:50:33] *** Joins: mixi (mixi@moz-DBD8904A.org)
[17:51:25] *** Quits: victorporof (victorporo@60FA9E67.483E5FE1.9B1E38F4.IP) (Quit: victorporof)
[17:51:46] <cmr> Are new structs guaranteed to be zeroed?
[17:52:01] <cmr> wait that doesn't make sense, they need to be explicitly initialized
[17:52:13] <pcwalton> there's no such concept of a "zero value" in Rust
[17:52:27] <cmr> New question: can I make a new, empty struct?
[17:52:40] <SiegeLord> Does the mutable external iterator issues mentioned on the ML refer to the iterator invalidation problem?
[17:52:41] <cmr> pcwalton: by zeroed I mean calloc/memset(foo, 0, sizeof(foo))
[17:52:46] <pcwalton> what do you mean by an empty struct?
[17:52:59] <strcat> cmr: by manually zeroing the fields
[17:52:59] <pcwalton> cmr: that wouldn't be type safe, it could give you null pointers among other bad things
[17:53:07] <cmr> "struct bar foo;" in C
[17:53:16] <cmr> pcwalton: That's exactly what I want. huge struct with C ffi
[17:53:20] <strcat> cmr: that doesn't zero in C
[17:53:21] <pcwalton> everything has be initialized
[17:53:21] <kimundi> cmr: Only by explicitly initialising it with 'zero' values, either directly, with a constructor, or by for example implementing Zero for it and using that
[17:53:31] <cmr> strcat: I know, but it's a new, "empty" struct.
[17:53:32] <pcwalton> it would be nice to have #[deriving(Zero)]
[17:53:39] <bstrie> true
[17:53:44] <strcat> cmr: for unsafe code, uninit or init
[17:53:55] <strcat> I use uninit to work with gmp output parameters
[17:54:05] <strcat> since it always inits them
[17:54:18] <cmr> strcat: Where do I find these?
[17:54:29] <strcat> cmr: core::unstable::intrinsics::{init, uninit}
[17:54:35] <cmr> strcat: thanks
[17:54:39] <strcat> uninit leaves it undef, init zeroes
[17:54:48] <strcat> perhaps we should remove init and just use explicit memset calls
[17:55:10] <cmr> eh, init is handy shorthand
[17:55:25] <strcat> shorthand for something you rarely want, though
[17:55:38] <strcat> uninit for output parameters, init for.... a few POSIX things
[17:55:39] <cmr> yeah, there is that :p
[17:55:52] *** Quits: eholk (eholk@moz-F8E3901F.uconnect.utah.edu) (Quit: eholk)
[17:56:03] *** Quits: bjz_ (brendanzab@B398BE78.F804C29E.D35A31DF.IP) (Quit: Leaving...)
[17:56:26] *** Quits: cowboyd (cowboyd@1D8844A7.1B729417.CEE440B6.IP) (Client exited)
[17:56:28] <strcat> cmr: there's ptr::set_memory
[17:56:37] <strcat> it even does aligned initialization :)
[17:56:39] <flu_> Aside from the rust-lang.org tutorial and language reference, are there any 'rust for the rest of us' resources out there? the name is unfortunately rather google proof
[17:56:45] *** Joins: sawrubh (uid6719@moz-D8B63698.irccloud.com)
[17:56:52] <cmr> flu_: Rust for Rubyists is pretty good.
[17:56:53] <bstrie> flu_: try "rust for rubyists"
[17:56:56] <flu_> rgr
[17:57:01] <cmr> flu_: fairly ruby agnostic :)
[17:57:15] * flu_ is a partial rubyist anyway
[17:57:38] *** Parts: judder (maradukewa@77329696.665C6EE0.950D3BB5.IP) ()
[17:57:54] <cmr> flu_: you can give any suggestions to me (I have commit access to it)
[17:58:02] <flu_> noted
[17:58:16] <cmr> flu_: it should be mostly up-to-date for 0.6, though I haven't gotten to the last chapter or two yet.
[17:59:31] *** Joins: vosen (vosen@moz-266BA656.icpnet.pl)
[17:59:58] <flu_> having first class algebraic data types (pattern matching! yes!) is what keeps me coming back to checking it out
[17:59:59] <bstrie> rusti: [0, ..1]
[18:00:00] -rusti- [0]
[18:00:06] <bstrie> rusti: [0, ..0]
[18:00:07] -rusti- []
[18:00:11] <bstrie> rusti: [0, ..-1]
[18:00:13] -rusti- application terminated abnormally with signal 11 (Segmentation fault)
[18:00:18] <cmr> heh
[18:00:43] *** Joins: ghrust (ghrust@1E8607E8.6A2AE50.F3114085.IP)
[18:00:43] <ghrust> 01[13rust01] 15bors merged 06auto into 06incoming: 02http://git.io/W03MFA
[18:00:43] *** Parts: ghrust (ghrust@1E8607E8.6A2AE50.F3114085.IP) ()
[18:00:47] <strcat> bstrie: a new bug! :)
[18:01:12] <bstrie> sigh, I'll file it :)
[18:01:32] *** Quits: BizarreCake (BizarreCak@32C9829A.151E84E7.561471F8.IP) (Client exited)
[18:02:23] *** Quits: \n (NDesaulnie@2557E599.66715431.D25A875A.IP) (Ping timeout)
[18:02:29] *** Parts: z0w0 (zack@moz-1EDE5BC0.lnse1.woo.bigpond.net.au) ()
[18:04:19] *** Joins: \n (NDesaulnie@43CB6079.66715431.D25A875A.IP)
[18:04:25] <nmatsakis> brson: ping
[18:04:33] <cmr> graydon: do the mac/win/linux buildbots run more-or-less the same hardware?
[18:05:04] *** Quits: davbo (dave@moz-3FFA637C.oucs.ox.ac.uk) (Client exited)
[18:05:12] *** Joins: azita (Azita@2557E599.66715431.D25A875A.IP)
[18:05:17] <graydon> cmr: no
[18:05:25] <graydon> I mean, maybe broadly similar?
[18:05:38] <graydon> i7-ish machines for the mac and linux bots. windows are VMs I have no idea about.
[18:05:47] *** Joins: pnkfelix1 (pnkfelix@moz-801E009D.vlan502.asr1.cdg2.gblx.net)
[18:05:58] *** Quits: pnkfelix1 (pnkfelix@moz-801E009D.vlan502.asr1.cdg2.gblx.net) (Input/output error)
[18:06:03] *** Quits: ksev (DrunkenPan@745B767B.989A61DC.CA5B6332.IP) (Ping timeout)
[18:06:09] *** Quits: pnkfelix (pnkfelix@moz-801E009D.vlan502.asr1.cdg2.gblx.net) (Ping timeout)
[18:06:30] <cmr> ok, thanks
[18:07:21] *** Joins: cowboyd (cowboyd@moz-1BD02A1E.sw.biz.rr.com)
[18:08:11] *** Joins: eholk (eholk@moz-F8E3901F.uconnect.utah.edu)
[18:09:09] *** Joins: ksev (DrunkenPan@745B767B.989A61DC.CA5B6332.IP)
[18:09:18] *** Joins: stowellde (uid6365@moz-D8B63698.irccloud.com)
[18:09:30] *** Joins: erickt (erickt@8C9ECD8F.3A598286.F12515B4.IP)
[18:10:08] *** Quits: pcwalton (pcwalton@2557E599.66715431.D25A875A.IP) (Quit: pcwalton)
[18:10:21] *** Joins: mattin (user@F4FAB1DA.DC7A989C.7F8AB798.IP)
[18:12:57] *** Joins: FrozenCow (FrozenCow@moz-B2DF4929.chello.nl)
[18:13:19] <mattin> in this method signature for read_line, what does self refer to?
[18:13:22] <mattin> fn read_line(&self) -> ~str
[18:13:39] <cmr> mattin: the self object, the struct you call the method on.
[18:13:40] <mattin> link: http://static.rust-lang.org/doc/0.6/core/io.html#struct-bytesreader
[18:13:52] <mattin> oh
[18:14:38] <mattin> what if im trying to read from stdin, does that mean i pass in a file handler that represents stdin?
[18:14:50] *** Quits: thou (thou@moz-1C1CA9F7.fasttrackcomm.net) (Ping timeout)
[18:15:43] <cmr> io::stdin() returns a @Reader, so you can do "let stdin = io::stdin(); stdin.read_line()"
[18:15:59] *** Quits: bytbox (s@moz-2E27684C.student.umd.edu) (Ping timeout)
[18:16:56] <mattin> ah that's interesting.  how come you didn't pass in any arguments to read_line?
[18:17:07] *** Joins: pcwalton (pcwalton@2557E599.66715431.D25A875A.IP)
[18:17:07] *** ChanServ sets mode: +o pcwalton
[18:17:20] <cmr> It doesn't need any. self is passed implicitly, because it's a method call.
[18:17:48] *** Joins: thou (thou@144F3092.A9FAD7B8.947355CE.IP)
[18:18:13] <mattin> ah i see, didn't know that.  
[18:18:18] *** Joins: int3_ (int3_@moz-ABE52D50.hsd1.ca.comcast.net)
[18:18:19] <mattin> thanks
[18:18:26] <strcat> graydon: when nominating for a milestone, I should just add the milestone + post a comment, right?
[18:18:46] <graydon> yeah
[18:20:24] *** Joins: bytbox (s@moz-D83E9B31.wireless.umd.edu)
[18:21:35] *** Joins: pragmatic (pragmatic@moz-1A421840.hsd1.ca.comcast.net)
[18:23:14] *** Quits: Axord (xord@moz-C3CCF156.lsanca.dsl-w.verizon.net) (Ping timeout)
[18:23:39] *** Quits: Yurume (yurume@AC58A8CE.8A059B47.E313B915.IP) (Ping timeout)
[18:23:54] *** Quits: brson (brson@2557E599.66715431.D25A875A.IP) (Ping timeout)
[18:24:29] *** Quits: int3_ (int3_@moz-ABE52D50.hsd1.ca.comcast.net) (Ping timeout)
[18:24:44] *** Quits: \n (NDesaulnie@43CB6079.66715431.D25A875A.IP) (Ping timeout)
[18:24:45] *** Joins: \n (NDesaulnie@2557E599.66715431.D25A875A.IP)
[18:25:16] *** Joins: karol (Mibbit@moz-AF222724.orange.sk)
[18:25:55] *** Joins: brson (brson@2557E599.66715431.D25A875A.IP)
[18:25:55] *** ChanServ sets mode: +o brson
[18:26:24] *** Quits: FrozenCow (FrozenCow@moz-B2DF4929.chello.nl) (Connection reset by peer)
[18:26:53] <moonchrome> can I get a identifier name inside a static string in macro, eg. macro_rules! foo ((id: ident) => fmt!("bla" + stringify!(id) + "%?", id))
[18:27:20] <moonchrome> *id = $id
[18:27:36] <jclements> moonchrome: that *kind* of thing *should* work, yes. Does it not?
[18:28:01] <moonchrome> says fmt! expects const string 
[18:28:03] *** Quits: erickt (erickt@8C9ECD8F.3A598286.F12515B4.IP) (Quit: Leaving.)
[18:28:05] <jclements> moonchrome: wait!
[18:28:06] <karol> Hi guys, just started playing with Rust... rust-opengles built a libopengles-94839cbfe144198-0.1.so, and I wanted to use that crate in different module, trying: extern mod gl2 (path = "./", name = "libopengles-94839cbfe144198-0.1.so");  
[18:28:25] <jclements> moonchrome: I belive that the code I'm working on right now will fix this. I'm expecting to make a pull request sometime today. 
[18:28:33] <karol> i get back ex.rs:2:0: 2:74 error: can't find crate for `gl2`   ex.rs is in the same directory. any ideas?
[18:28:37] <jclements> This is bug # â€¦ uhâ€¦ hold on.
[18:28:52] <doener> karol: I think that should be just name="opengles"
[18:29:16] <jclements> moonchrome: #2888
[18:30:01] <karol> doener: hmm, the same error. the whole file looks like this: extern mod gl2 (name = "opengles"); fn main() { println("asdf"); }
[18:30:08] *** Quits: sk (sk@EA324BFE.54A580E3.78DD174B.IP) (Quit: Leaving)
[18:30:29] <doener> karol: sorry, keep the path attribute
[18:31:27] <moonchrome> jclements, yeah that looks like it will solve it
[18:31:44] <jclements> moonchrome: ohâ€¦ hang onâ€¦ there's another problem you're going to run into, here; in order for fmt! to be happy, the string has to be fully constructed at compile time.
[18:32:05] <karol> the same error: with extern mod gl2 (path = "/home/x/Tools/rust-libs/rust-opengles/", name = "opengles");   did try also with relative path = "./"
[18:32:06] <jclements> moonchrome: I don't see an easy fix there; I'm afraid you've left syntax-rules, there.
[18:32:39] <jclements> moonchrome: unless you make a syntax extension.  Actually, a static string-gluing syntax extension could be very useful.
[18:33:22] <doener> karol: no clue then :-/
[18:33:37] <karol> thanks for help anyway :) going to google furiously
[18:34:17] <moonchrome> jclements, well since fmt! seems the only sane way to format strings I'd say it be very useful :)
[18:35:05] <jclements> pcwalton: brson: nmatsakis: graybon: tjc: everyoneelse: shouldn't it be possible to shovel all constant expression evaluation into syntax extensions? wouldn't this be a nice way of resolving the expressiveness-of-constant-expressions problem?
[18:35:53] <pcwalton> constant expression evaluation needs some smarts, like resolving other constants
[18:35:56] <pcwalton> which requires running resolve
[18:36:58] <jclements> pcwalton: hmmâ€¦ that makes sense. moonchrome was just trying to put together a macro which constructs a string to use as the first argument to fmt!, and it looks like you'd need a syntax extension to glue together strings at expansion time.
[18:37:42] *** Parts: jclements (jclements@2557E599.66715431.D25A875A.IP) ()
[18:37:55] *** Joins: jclements (jclements@2557E599.66715431.D25A875A.IP)
[18:45:27] *** Quits: Jesse (jruderman@moz-537BCF9.hsd1.ca.comcast.net) (Quit: Jesse)
[18:48:46] <strcat> pcwalton: well it needs to be able to resolve constants, but stuff like + could be in an eval! ext
[18:49:05] <strcat> or no? because they'd need to again resolve other constants :(
[18:49:06] * strcat sighs
[18:49:19] <pcwalton> yeah, I think it has to be done post-resolve + typeck
[18:49:55] <jclements> pcwalton: well, this is just pie-in-the-sky, now, butâ€¦ why do you need constants at all? Just make them macrosâ€¦.
[18:50:24] <pcwalton> I've thought about this before but I worry about the consequences of doing constant eval before typeck.
[18:50:36] <jclements> pcwalton: in some sense, we've just observed the problem with macro import/export--how's it going to work before resolve?
[18:51:11] <jclements> pcwalton: I agree that you'd have to settle on an evaluation strategy that was independent of types.
[18:51:39] *** Quits: fabiand (fabiand@moz-CFCB6878.adsl.alicedsl.de) (Quit: Verlassend)
[18:51:51] *** Joins: MaikKlein (maik@moz-F9B59FC9.dip0.t-ipconnect.de)
[18:54:41] *** Joins: SeanTAllen_ (uid4855@moz-D8B63698.irccloud.com)
[18:54:44] *** Quits: eholk (eholk@moz-F8E3901F.uconnect.utah.edu) (Quit: eholk)
[18:55:01] *** Joins: geomyidae__ (uid214@moz-C944F5EC.irccloud.com)
[18:55:51] *** Joins: gmcabrita (uid4474@moz-D8B63698.irccloud.com)
[18:58:08] *** Quits: mleise (marco@moz-3468AB5B.pools.arcor-ip.net) (Quit: Leaving.)
[18:58:11] *** Joins: erickt (erickt@8C9ECD8F.3A598286.F12515B4.IP)
[18:58:25] <jclements> anyone have a current incoming build to run a small test (https://gist.github.com/jbclements/5723959) ? 
[18:58:38] <jclements> I hope it fails, BTW.
[18:58:56] <jclements> hmmâ€¦ does rusti take multi-line input?
[18:59:09] <strcat> jclements: no, but maybe it'd work on a single line
[18:59:13] <strcat> jclements: it compiles though.
[18:59:16] *** Joins: carter (carter@moz-BDFE46F6.nyc.biz.rr.com)
[18:59:24] <jclements> strcat: what happens when you run it?
[18:59:28] <strcat> doesn't fail
[18:59:31] <doener> jclements: works
[18:59:33] <jclements> grr, thanks.
[18:59:48] <MaikKlein> y works
[18:59:48] <doener> why did you expect it to fail?
[18:59:55] *** Quits: erickt (erickt@8C9ECD8F.3A598286.F12515B4.IP) (Ping timeout)
[19:00:01] <jclements> because it requires a substitution inside of another macro invocation.
[19:00:07] <nmatsakis> pcwalton: jclements: I...think you'll want it to be integrated with the main "type collection" phase. We'll probably eventually need to accommodate constants like sizeof(Foo)
[19:00:28] <nmatsakis> pcwalton: jclements: certainly that comes up in C++ code rather frequently.
[19:00:48] <strcat> nmatsakis: C++ is weird though, because you have a turing complete language at compile-time aware of types
[19:00:48] *** Joins: pyrac (pyrac@moz-96C2FD1F.w109-214.abo.wanadoo.fr)
[19:00:52] <strcat> constexpr and templates
[19:01:14] <doener> jclements: moonchrome had a problem earlier in which it worked for one inner expansion, just not for two
[19:01:15] <nmatsakis> strcat: yes, and I don't especially want to go there, but we can stop short and still provide things like sizeof.
[19:01:24] <strcat> nmatsakis: http://ix.io/612 ;p
[19:01:56] <bstrie> jclements: doener is referring to https://github.com/mozilla/rust/issues/6976
[19:02:06] <bstrie> I think
[19:02:19] <strcat> in some ways templates are a nicer language than C++ itself - pattern matching!
[19:02:20] <bstrie> maybe moonchrome just has every macro problem ever
[19:02:24] <doener> https://gist.github.com/moonchrome/5722958
[19:03:13] <doener> hm, ($x:expr) => (fmt!($x,1) + fmt!("3")) also works, though
[19:03:17] *** cscott is now known as cscottnet_away
[19:03:36] <Blei> karol: you have to use `rustc -L .`
[19:04:11] <strcat> rusti: println("I need a web frontend ;p")
[19:04:12] -rusti- I need a web frontend ;p
[19:04:12] -rusti- ()
[19:04:19] <bstrie> strcat: perhaps https://github.com/mozilla/rust/wiki/Rust-for-CXX-programmers could use a mention of iterators? :)
[19:04:37] <strcat> bstrie: iterators, containers, etc. - yeah.
[19:04:49] *** Quits: nielsle (nielsle@moz-5CE8ECCD.boa.fiberby.dk) (Ping timeout)
[19:05:29] *** cscottnet_away is now known as cscottnet
[19:06:15] *** cscottnet is now known as cscott
[19:07:24] *** Quits: \n (NDesaulnie@2557E599.66715431.D25A875A.IP) (Ping timeout)
[19:07:41] *** Joins: victorporof (victorporo@60FA9E67.483E5FE1.9B1E38F4.IP)
[19:08:10] *** Joins: \n (NDesaulnie@43CB6079.66715431.D25A875A.IP)
[19:08:52] *** Joins: nielsle (nielsle@moz-5CE8ECCD.boa.fiberby.dk)
[19:10:53] *** Joins: Jesse (jruderman@2557E599.66715431.D25A875A.IP)
[19:12:30] *** Quits: dherman (dherman@2557E599.66715431.D25A875A.IP) (Quit: dherman)
[19:13:56] <mattin> rusti: int::from_str(~"17");
[19:13:57] -rusti- more than 5 lines of output, pastebinned: http://sprunge.us/FCiQ
[19:14:04] *** Quits: eatkinson (eatkinson@2557E599.66715431.D25A875A.IP) (Quit: eatkinson)
[19:14:20] <kimundi> rusti: stdint::from_str(~"17")
[19:14:21] -rusti- more than 5 lines of output, pastebinned: http://sprunge.us/PeLV
[19:14:24] <kimundi> rusti: std::int::from_str(~"17")
[19:14:25] -rusti- more than 5 lines of output, pastebinned: http://sprunge.us/MdVK
[19:15:04] <kimundi> rusti: std::int::from_str("17")
[19:15:05] -rusti- Some(17)
[19:15:38] <doener> rusti: std::from_str::FromStr::from_str::<int>("18")
[19:15:39] <mattin> thanks kimundi :)
[19:15:40] -rusti- Some(18)
[19:16:11] <strcat> graydon: would it make sense to omit useless things from std::libc? for example memset/memmove/memcpy should only be used via the LLVM intrinsics
[19:16:23] <MaikKlein> rusti: std::int::from_str("17a")
[19:16:24] -rusti- None
[19:16:27] <strcat> I see 'gets' is already omitted :)
[19:16:32] <doener> rusti: FromStr::from_str::<int>("164")
[19:16:34] -rusti- Some(164)
[19:17:15] <MaikKlein> why are there two from_str functions?
[19:17:23] <strcat> cruft
[19:18:51] <bstrie> haha, I keep reading the tag "A-macos" as "A-macros"...
[19:18:54] *** Joins: Axord (xord@moz-C3CCF156.lsanca.dsl-w.verizon.net)
[19:19:01] <bstrie> maybe I should just change it to "A-mac"
[19:19:19] <kimundi> MaikKlein: They end up in the same function, though
[19:21:16] *** Quits: eschweic (Adium@2557E599.66715431.D25A875A.IP) (Quit: Leaving.)
[19:21:53] *** Quits: robertknight (robertknig@moz-54528EE0.wby.mendeley.com) (Quit: Computer has gone to sleep.)
[19:22:11] *** Joins: mzabaluev (mzabaluev@moz-91FFD755.dhcp.inet.fi)
[19:27:09] *** Joins: artagnon (uid7560@moz-A588D045.irccloud.com)
[19:27:11] *** Joins: thomaslee (thomaslee@moz-6C3931E3.static.twtelecom.net)
[19:28:51] *** Joins: erickt (erickt@8C9ECD8F.3A598286.F12515B4.IP)
[19:28:54] *** Joins: Jeaye (Jeaye@moz-FD505E54.hsd1.ca.comcast.net)
[19:30:20] <moonchrome> I'm using macros to work around missing associated items, copy-pasting to work around macros not expanding multiple times in another macro, implementing ToStr manually because #[deriving(ToStr)] doesn't work in macro, converting values to [] and using .to_str on it because fmt! can't use a macro constructed string 
[19:30:43] <moonchrome> the workarounds have workarounds xD
[19:31:30] *** Quits: erickt (erickt@8C9ECD8F.3A598286.F12515B4.IP) (Ping timeout)
[19:31:33] <kimundi> In other words, business as usual in rust land. :D
[19:32:34] <bstrie> moonchrome: I'm not sure whether to laugh or cry
[19:32:44] <thomaslee> Hey folks -- Tim C's talking Rust in Portland later this month if anybody wants to come along: http://calagator.org/events/1250464376
[19:33:12] <MaikKlein> can I add a compiler flag in rustc like -lGL?
[19:33:23] <moonchrome> bstrie, meh it's alpha - I expect it, but it's funny when I take a step back and look at it
[19:34:34] <strcat> MaikKlein: #[link_flags = "-lfoo"] on the extern block used to write the defs for the lib
[19:34:45] <kimundi> MaikKlein: You can add cfgs (rustc --cfg Foo), its effect is on items with attributes of the form #[cfg(Foo)]
[19:35:19] <Blei> MaikKlein: another option: --link-args -lGl   (untested)
[19:35:49] *** Quits: \n (NDesaulnie@43CB6079.66715431.D25A875A.IP) (Quit: \n)
[19:36:22] *** Quits: infynyxx (infynyxx@DB780A29.749BA1D.DCC373F0.IP) (Client exited)
[19:36:28] <MaikKlein> thanks @ all
[19:36:29] *** Quits: bytbox (s@moz-D83E9B31.wireless.umd.edu) (Ping timeout)
[19:37:04] <bstrie> thomaslee: have you mentioned that on the mailing list?
[19:37:26] <thomaslee> bstrie: nope, but will later this evening.
[19:40:57] <moonchrome> so I can't use + as separator token right ? 
[19:41:15] <moonchrome> in macro repeat
[19:41:58] <moonchrome> ah well I'll just add a zero after the list so the last "+" gets zero
[19:43:41] <Thiez> I wish x86/x64 had load-linked and store-conditional, would make life much easier :)
[19:43:54] *** Quits: MaikKlein (maik@moz-F9B59FC9.dip0.t-ipconnect.de) (Ping timeout)
[19:44:05] *** Joins: eatkinson (eatkinson@2557E599.66715431.D25A875A.IP)
[19:45:46] <strcat> Thiez: you wish x86 had even more opcodes? ;p
[19:46:28] *** Joins: eholk (eholk@moz-F8E3901F.uconnect.utah.edu)
[19:48:06] *** Quits: Blei (philipp@moz-96D25F7A.cust.bluewin.ch) (Quit: WeeChat 0.4.1)
[19:48:31] <Thiez> strcat: I'm willing to sacrifice AAA,AAD,AAM,AAS, and XLAT... ;)
[19:49:01] <doomlord> load-linked = ?
[19:49:05] <Thiez> basically everything to do with BCD can die for all I care :p
[19:49:58] <Thiez> doomlord: when you load-link a variable, you can perform a store-conditional on the same memory location and it will succeed if no other writes to that location have been performed
[19:50:35] <Thiez> those two instructions can implement every other atomic instruction afaik
[19:50:45] <doomlord> oh nice
[19:51:53] <doomlord> lwarx etc ok
[19:52:13] <Thiez> yes, and x86 doesn't have it, even though Alpha, PowerPC, MIPS and ARM do :p
[19:52:29] <karol> rust program having only "use int;" failing with "error: unresolved import (maybe you meant `in::*`?)" probably means broken installation right? 
[19:52:42] <Thiez> as strcat suggests, I never imagined wishing more opcodes on x86
[19:52:46] *** Joins: bytbox (s@moz-D83E9B31.wireless.umd.edu)
[19:52:59] <Thiez> karol: try 'use std::int;'
[19:53:07] <mcpherrin> You can always wish for more :-)
[19:53:12] <Thiez> or are you using 0.6?
[19:53:21] <Thiez> 0.6 still has core, right?
[19:53:30] <EXetoC> ya
[19:53:30] <mcpherrin> right now I'm in another discussion wishing x86 had the crazy MMU extensions the Azul dudes invented
[19:53:33] <Thiez> mcpherrin: sometimes less is more
[19:53:33] *** Joins: devinus (devinus@moz-B4AF84BC.ptr.us.xo.net)
[19:53:43] <jld> cmpxchg is close enough to stwcx. for most purposes, IMO.
[19:53:52] <doomlord> grew up on 68k, and enjoyed coding on risc games consoles
[19:54:07] <karol> hmm, [x@xmd rustex]$ cat main.rs use std::int; [x@xmd rustex]$ rust run main.rs main.rs:1:4: 1:7 error: unresolved import. maybe a missing `extern mod std`? main.rs:1 use std::int;               ^~~ main.rs:1:4: 1:12 error: failed to resolve import `std::int` main.rs:1 use std::int;               ^~~~~~~~ error: aborting due to 2 previous errors
[19:54:16] <karol> sorry, botched
[19:54:34] <Thiez> karol: try with 'use core::int' then
[19:54:36] <Thiez> if you're on 0.6
[19:54:41] *** Quits: bytbox (s@moz-D83E9B31.wireless.umd.edu) (Ping timeout)
[19:55:15] <jdm> graydon: mmm, you're doing sr&ed as well?
[19:55:17] <Thiez> jld: x86 has 2CAS for adjecent memory locations so it's okay
[19:55:17] <bstrie> sully: is all the interner-related stuff in https://github.com/mozilla/rust/pull/6937/ intentional?
[19:55:24] <jdm> I got introduced to the process recently
[19:55:26] <karol> yes, 0.6. core::int works, thanks
[19:55:29] <jdm> sooooo much fnu
[19:55:36] <mcpherrin> Thiez: Oh, don't get me wrong, RISC instruction sets are sweet, but that's not what x86 is
[19:56:02] <Thiez> mcpherrin: I know what x86 is, I've enjoyed assembly programming x86 for a while
[19:56:15] *** Quits: ksev (DrunkenPan@745B767B.989A61DC.CA5B6332.IP) (Ping timeout)
[19:56:25] <EXetoC> karol: keep in mind that a lot has changed since 0.6
[19:56:26] <mcpherrin> But we don't have perfect CPUs instruction sets yet, so of course we'll still want changes
[19:56:29] <bstrie> sully: oh wait, I suppose that has to do with silencing unused variable warnings
[19:56:45] <mcpherrin> And taking stuff out of x86 is never gonna happen :p
[19:56:57] <Thiez> one of the new processors has a RNG instruction, that's amazing :)
[19:57:10] <jld> I seem to recall reading that 68k had CAS2 that could operate atomically on two unrelated addresses.
[19:57:20] *** Joins: bytbox (s@moz-D83E9B31.wireless.umd.edu)
[19:57:25] <mcpherrin> Well, nobody makes x86 cpus anymore.  More like x86 VMs running on some proprietary risc architecture that only lives in the CPU :)
[19:57:28] <Thiez> jld: yup, but it was slow so nobody used it :(
[19:57:50] <strcat> mcpherrin: risc-ish ;p
[19:58:06] <strcat> mcpherrin: they have tons of die space to dedicate to specialized hardware for the gpu, encryption, etc.
[19:58:29] <Thiez> I quite like ARM at the moment, I think I'll try to get some ARM assembly programming experience once ARMv7 comes out
[19:58:32] <strcat> afaik they have whole sections for emulating old things, it's just that the die is so huge now (in transistor size) that it's insignificant
[19:58:48] <strcat> they could put a whole pentium2 on there and it wouldn't matter
[19:58:54] <mcpherrin> strcat: it's ALL emulated, though
[19:59:01] <mcpherrin> strcat: The cpu doesn't run x86 instructions :)
[19:59:05] <mcpherrin> It emulates them
[19:59:07] <strcat> mcpherrin: I know that. but it still isn't RISC
[19:59:09] <Thiez> yay micro-ops
[19:59:10] <jld> Modern ARM has at times made me long for the simplicity of x86.
[19:59:20] <Thiez> jld: it's that bad?
[19:59:43] <jld> With Thumb2 things get a little complicated.
[20:00:02] <bstrie> can anyone explain why this one-line comment change (!!!) has been sitting in the pull request queue for a month? https://github.com/mozilla/rust/pull/6053/
[20:00:02] <mcpherrin> I wrote an OS in arm.  I pretended Thumb didn't exist :P
[20:00:06] <jld> And weirdly non-orthogonal in terms of what can be encoded how, or even at all.
[20:00:42] *** Joins: solancile (solancile@moz-A1CFFAE5.hsd1.wa.comcast.net)
[20:00:43] *** Joins: ghrust (ghrust@AC22872E.6A2AE50.F3114085.IP)
[20:00:43] <ghrust> 01[13rust01] 15bors pushed 0 new commits to 06auto: 02http://git.io/igiaKQ
[20:00:43] *** Parts: ghrust (ghrust@AC22872E.6A2AE50.F3114085.IP) ()
[20:00:44] *** Joins: ghrust (ghrust@614D05BD.6A2AE50.F3114085.IP)
[20:00:44] <ghrust> 01[13rust01] 15bors pushed 2 new commits to 06auto: 02http://git.io/2eb3Hg
[20:00:44] <ghrust> 13rust/06auto 148bbf83b 15Michael Sullivan: Clean up a handful of build warnings.
[20:00:44] <ghrust> 13rust/06auto 14a51fae0 15bors: auto merge of #6937 : msullivan/rust/no-warnings, r=bstrie
[20:00:44] *** Parts: ghrust (ghrust@614D05BD.6A2AE50.F3114085.IP) ()
[20:00:51] <Thiez> mcpherrin: that's awesome
[20:00:54] <strcat> rusti: [1, ..10000000]
[20:00:58] -rusti- application terminated abnormally with signal 11 (Segmentation fault)
[20:01:04] <strcat> ha
[20:01:05] <strcat> rusti: [1, ..1000000000]
[20:01:06] -rusti- application terminated abnormally with signal 11 (Segmentation fault)
[20:01:09] <strcat> rusti: [1, ..1000000]
[20:01:11] -rusti- line longer than 150 columns, pastebinned: http://sprunge.us/XahD
[20:01:16] <bstrie> haha
[20:01:25] <strcat> rusti: ~[1, ..1000000]
[20:01:26] <Thiez> I did an x86 bootloader for a floppy back in the days, and a little preliminary work on what was supposed to be my own OS
[20:01:31] -rusti- line longer than 10000 characters, bailing out
[20:01:36] <strcat> rusti: ~[1, ..100000000]
[20:01:37] -rusti- application terminated abnormally with signal 9 (Killed)
[20:01:38] <Thiez> never did finish that.
[20:01:40] <mcpherrin> rusti: [0, 10000000]
[20:01:41] <strcat> rusti: ~[1, ..100000000000]
[20:01:42] -rusti- [0, 10000000]
[20:01:42] -rusti- rust: task failed at 'assertion failed: p.is_not_null()', /build/rust-incoming-git/src/rust/src/libstd/rt/global_heap.rs:26
[20:01:42] -rusti- rust: domain main @0x6711b0 root task failed
[20:01:42] -rusti- application terminated with error code 101
[20:01:46] *** Joins: \n (NDesaulnie@2557E599.66715431.D25A875A.IP)
[20:01:50] <bstrie> what a strange menagerie of errors
[20:02:03] <strcat> bstrie: well I have overcommit at 2.
[20:02:12] <jld> Also if there's mixed ARM and Thumb2.  And you're using a GDB that is, apparently, too old to recognize x/wi and x/hi to override the current instruction set for disassembly.
[20:02:16] <strcat> bstrie: err, not 2
[20:02:23] <strcat> bstrie: I mean the default ;p
[20:02:24] <Thiez> rusti: std::unstable::intrinsics::size_of::<uint>()
[20:02:26] -rusti- more than 5 lines of output, pastebinned: http://sprunge.us/JRDC
[20:02:36] <Thiez> rusti: unsafe {std::unstable::intrinsics::size_of::<uint>()}
[20:02:38] -rusti- 8
[20:02:44] <Thiez> nice, 64bits rusti :D
[20:02:51] <mcpherrin> Thiez: getting an ARM os booting is much nicer than x86 though
[20:03:05] <Thiez> mcpherrin: I can't imagine it being worse
[20:03:23] <Thiez> the legacy cruft is amazing
[20:03:38] <mcpherrin> I haven't had the courage to write a bootloader for x86 yet
[20:04:09] <Thiez> I think you have to enable the magic a20 gate if you want more than 1mb of memory
[20:04:13] <Thiez> at some point.
[20:04:16] <mcpherrin> Gotta haul my copy of the intel blue books out of storage
[20:04:18] <bstrie> strcat: btw I'm bothered by the silliness of https://github.com/mozilla/rust/pull/6053, can you either approve it or close it?
[20:08:26] *** Joins: ksev (DrunkenPan@745B767B.989A61DC.CA5B6332.IP)
[20:12:12] *** Quits: pragmatic (pragmatic@moz-1A421840.hsd1.ca.comcast.net) (Ping timeout)
[20:12:13] *** Joins: tikue (tkuehn@2557E599.66715431.D25A875A.IP)
[20:13:10] *** Quits: lmandel (lmandel@F2D29657.F60B0462.67AC9B1.IP) (Quit: lmandel)
[20:16:19] *** Joins: steven_is_false (user@moz-144077DE.bchsia.telus.net)
[20:17:59] *** Joins: robertknight (robertknig@moz-54528EE0.wby.mendeley.com)
[20:19:16] *** Quits: carter (carter@moz-BDFE46F6.nyc.biz.rr.com) (Quit: Textual IRC Client: www.textualapp.com)
[20:19:16] <steven_is_false> Hi. I have a good question for the people at #rust. What are some other interesting Mozilla projects I should check out?
[20:19:27] <Thiez> steven_is_false: I would recommend rust.
[20:19:36] <bstrie> steven_is_false: yes rust is a good one
[20:19:46] <Thiez> or perhaps servo :p
[20:19:50] <kimundi> strcat: So, seeing how I can't workaround the Iterator-in-prelude issue without otherwise uneccessary renamings, should I just make a PR with this: https://github.com/Kimundi/rust/compare/mozilla:incoming...iterator-collect ?
[20:20:06] <bstrie> steven_is_false: there's http://whatcanidoformozilla.org/
[20:20:13] *** Joins: wycats_ (uid79@moz-C944F5EC.irccloud.com)
[20:20:29] <steven_is_false> I'm actually finding it difficult to get started with servo. Is there some kind of getting started guide?
[20:20:29] <bstrie> steven_is_false: anything with firefox os is awesome. persona is cool too
[20:22:48] <tikue> steven_is_false: unfortunately not really. I believe there is a powerpoint floating around somewhere that gives a very high-level overview, but I don't think it'd be helpful for actually digging into the code
[20:23:19] *** Joins: erickt (erickt@8C9ECD8F.3A598286.F12515B4.IP)
[20:23:38] <steven_is_false> tikue: Shame, I guess I can look at some of the easier fixes. At the very least I could probable remove redundant imports from the sources.
[20:24:15] <sp3d> steven_is_false I may be hopelessly off-base w/ the suggestion if you know gecko guts well, but perhaps the one page that compares how gecko and webkit are structured from a high level would be informative?
[20:24:43] <sp3d> http://www.html5rocks.com/en/tutorials/internals/howbrowserswork/
[20:24:54] <steven_is_false> sp3d: That sounds interesting on it's own. I'll look at it.
[20:25:47] *** Joins: sk (sk@61A494B3.BA40E8A.AAC02D62.IP)
[20:25:52] *** Joins: snearch (snearch@moz-5F685442.pool.mediaways.net)
[20:28:14] <tikue> steven_is_false: for me, starting at src/components/main/engine.rs was helpful, because that's where the render, layout, and script tasks are initialized, so you can kind of start to see a skeleton of it
[20:28:37] <steven_is_false> tikue: Awesome.
[20:28:54] *** Joins: FrozenCow (FrozenCow@moz-B2DF4929.chello.nl)
[20:30:20] <tikue> steven_is_false: also, #servo is a good channel to join
[20:30:37] <steven_is_false> tikue: Okay.
[20:31:03] *** Joins: carllerche (carllerche@moz-BF6CB667.hsd1.ca.comcast.net)
[20:31:05] *** Quits: Jesin (Jessin_@moz-3AD6F09F.res.lehigh.edu) (Ping timeout)
[20:31:57] <strcat> kimundi: looks good, but can't the FromIter impl be in vec.rs?
[20:32:06] <strcat> kimundi: it's the crate that matters, and they're all in one crate
[20:32:29] *** Quits: eholk (eholk@moz-F8E3901F.uconnect.utah.edu) (Quit: eholk)
[20:32:53] *** Quits: Palmik (palmik@moz-5CA3F354.pks.muni.cz) (Quit: Lost terminal)
[20:33:01] <kimundi> oh, last I knew that didn't work. Let me check again...
[20:33:27] <strcat> rusti: ~[1, ..100000000]
[20:33:28] -rusti- application terminated abnormally with signal 9 (Killed)
[20:34:50] <kimundi> strcat: Also, I'm currently removing the Cell renamings again because the reason for them was to workaround the Iterator prelude issue
[20:35:06] <strcat> kimundi: sounds good, I don't really care about Cell either way ;p
[20:35:37] *** Joins: eschweic (Adium@2557E599.66715431.D25A875A.IP)
[20:37:31] <bblum> ok libextra 776 sized errors
[20:37:50] *** Quits: ksev (DrunkenPan@745B767B.989A61DC.CA5B6332.IP) (Ping timeout)
[20:40:32] *** Quits: erickt (erickt@8C9ECD8F.3A598286.F12515B4.IP) (Quit: Leaving.)
[20:41:51] *** Quits: graydon (graydon@3853DDD.39EEDBB3.D758B1AA.IP) (Quit: Leaving.)
[20:42:29] <sully> bstrie: yeah, I intended to remove it
[20:42:34] <sully> bstrie: to get rid of unused variable warnings
[20:42:42] <sully> bstrie: there is probably more that can be ripped out too
[20:42:45] *** Quits: snearch (snearch@moz-5F685442.pool.mediaways.net) (Quit: Verlassend)
[20:43:34] *** Quits: pyrac (pyrac@moz-96C2FD1F.w109-214.abo.wanadoo.fr) (Quit: pyrac)
[20:43:37] *** Joins: IdolfHatler (idolf@moz-4103EACC.pwnies.dk)
[20:43:39] *** Quits: sk (sk@61A494B3.BA40E8A.AAC02D62.IP) (Quit: Leaving)
[20:44:40] *** Quits: maxli (maxli@F2D29657.F60B0462.67AC9B1.IP) (Quit: Leaving.)
[20:44:44] *** Joins: jviereck (Adium@moz-DF42D705.dip0.t-ipconnect.de)
[20:44:49] *** Quits: \n (NDesaulnie@2557E599.66715431.D25A875A.IP) (Quit: \n)
[20:45:25] *** Joins: eholk (eholk@moz-F8E3901F.uconnect.utah.edu)
[20:45:46] *** Joins: erickt (erickt@8C9ECD8F.3A598286.F12515B4.IP)
[20:46:07] *** Joins: maxli (maxli@F2D29657.F60B0462.67AC9B1.IP)
[20:46:37] *** Quits: maxli (maxli@F2D29657.F60B0462.67AC9B1.IP) (Quit: Leaving.)
[20:47:02] *** Joins: bjz (brendanzab@B398BE78.F804C29E.D35A31DF.IP)
[20:47:02] <kimundi> strcat: r? https://github.com/mozilla/rust/pull/6980
[20:48:44] *** Joins: ksev (DrunkenPan@745B767B.989A61DC.CA5B6332.IP)
[20:50:34] *** Quits: jviereck (Adium@moz-DF42D705.dip0.t-ipconnect.de) (Quit: Leaving.)
[20:51:02] *** Joins: AndroUser (androirc@moz-AD3275AF.tmodns.net)
[20:51:23] *** Quits: AndroUser (androirc@moz-AD3275AF.tmodns.net) (Quit: AndroIRC - Android IRC Client ( http://www.androirc.com ))
[20:51:43] *** Joins: ghrust (ghrust@1E8607E8.6A2AE50.F3114085.IP)
[20:51:43] <ghrust> 01[13rust01] 15bors merged 06auto into 06incoming: 02http://git.io/2eb3Hg
[20:51:43] *** Parts: ghrust (ghrust@1E8607E8.6A2AE50.F3114085.IP) ()
[20:52:07] *** Quits: jclements (jclements@2557E599.66715431.D25A875A.IP) (Quit: jclements)
[20:52:29] <steven_is_false> A noncopyable type could be hacked in with struct Noncopyable (&'static ()); right?
[20:53:08] *** Quits: eatkinson (eatkinson@2557E599.66715431.D25A875A.IP) (Quit: eatkinson)
[20:53:30] *** Joins: jgilbert (jgilbert@2557E599.66715431.D25A875A.IP)
[20:53:38] <steven_is_false> * A nonmoveable type sorry
[20:54:43] *** Joins: ghrust (ghrust@1E8607E8.6A2AE50.F3114085.IP)
[20:54:43] <ghrust> 01[13rust01] 15bors pushed 0 new commits to 06auto: 02http://git.io/i1NRVQ
[20:54:43] *** Parts: ghrust (ghrust@1E8607E8.6A2AE50.F3114085.IP) ()
[20:54:44] *** Joins: ghrust (ghrust@9C8B94D4.6A2AE50.F3114085.IP)
[20:54:44] <ghrust> 01[13rust01] 15bors pushed 2 new commits to 06auto: 02http://git.io/oYD9rw
[20:54:44] <ghrust> 13rust/06auto 14c20c685 15Niko Matsakis: Remove FIXME #2699---I believe the calculation is correct. Fixes #2699.
[20:54:44] <ghrust> 13rust/06auto 14533425e 15bors: auto merge of #6053 : nikomatsakis/rust/fixme-2699, r=thestinger...
[20:54:44] *** Parts: ghrust (ghrust@9C8B94D4.6A2AE50.F3114085.IP) ()
[20:56:20] *** Quits: dcoates (dcoates@moz-BE33DA21.fw1.sfo1.mozilla.net) (Input/output error)
[20:59:37] *** Quits: brson (brson@2557E599.66715431.D25A875A.IP) (Client exited)
[20:59:39] *** Parts: steven_is_false (user@moz-144077DE.bchsia.telus.net) (ERC Version 5.3 (IRC client for Emacs))
[20:59:48] *** Joins: jmgrosen (john@moz-848F6087.sb.sd.cox.net)
[21:00:11] *** Joins: dcoates (dcoates@moz-BE33DA21.fw1.sfo1.mozilla.net)
[21:00:11] *** Quits: jmgrosen (john@moz-848F6087.sb.sd.cox.net) (Connection reset by peer)
[21:00:41] *** Joins: tgt (tgt@moz-D59EE478.aztw.cable.virginmedia.com)
[21:00:57] *** Joins: infynyxx (infynyxx@DB780A29.749BA1D.DCC373F0.IP)
[21:01:32] <bstrie> erickt: would you like me to advertise the SF rust meetup on reddit, or are you trying to keep it low-key?
[21:02:02] *** Joins: jmgrosen (john@moz-848F6087.sb.sd.cox.net)
[21:02:16] *** Joins: eatkinson (eatkinson@2557E599.66715431.D25A875A.IP)
[21:02:16] *** Quits: jmgrosen (john@moz-848F6087.sb.sd.cox.net) (Connection reset by peer)
[21:04:43] *** Joins: dherman (dherman@2557E599.66715431.D25A875A.IP)
[21:04:43] *** ChanServ sets mode: +o dherman
[21:05:06] *** Joins: jmgrosen (john@moz-848F6087.sb.sd.cox.net)
[21:05:57] *** Quits: erickt (erickt@8C9ECD8F.3A598286.F12515B4.IP) (Quit: Leaving.)
[21:05:57] *** Quits: jmgrosen (john@moz-848F6087.sb.sd.cox.net) (Connection reset by peer)
[21:08:06] *** Joins: jmgrosen (john@moz-848F6087.sb.sd.cox.net)
[21:08:08] *** Quits: karol (Mibbit@moz-AF222724.orange.sk) (Quit: http://www.mibbit.com ajax IRC Client)
[21:09:00] *** Quits: jmgrosen (john@moz-848F6087.sb.sd.cox.net) (Connection reset by peer)
[21:11:00] *** Joins: jmgrosen (john@moz-848F6087.sb.sd.cox.net)
[21:11:59] *** Quits: jmgrosen (john@moz-848F6087.sb.sd.cox.net) (Connection reset by peer)
[21:12:35] *** Joins: snadon (chatzilla@moz-3BC727E8.mc.videotron.ca)
[21:15:16] *** Joins: jmgrosen (john@moz-848F6087.sb.sd.cox.net)
[21:15:36] *** Joins: brson (brson@2557E599.66715431.D25A875A.IP)
[21:15:36] *** ChanServ sets mode: +o brson
[21:15:36] *** Quits: jmgrosen (john@moz-848F6087.sb.sd.cox.net) (Connection reset by peer)
[21:17:10] *** Joins: dylukes (dylukes@moz-E4DF3FED.pitbpa.fios.verizon.net)
[21:18:08] *** Joins: jmgrosen (john@moz-848F6087.sb.sd.cox.net)
[21:18:59] *** Quits: jmgrosen (john@moz-848F6087.sb.sd.cox.net) (Connection reset by peer)
[21:21:17] *** Joins: jmgrosen (john@moz-848F6087.sb.sd.cox.net)
[21:22:08] *** Quits: jmgrosen (john@moz-848F6087.sb.sd.cox.net) (Connection reset by peer)
[21:23:15] *** Quits: adu (ajr@moz-96FE9B84.washdc.fios.verizon.net) (Quit: adu)
[21:24:25] *** Joins: jmgrosen (john@moz-848F6087.sb.sd.cox.net)
[21:25:09] *** Quits: dherman (dherman@2557E599.66715431.D25A875A.IP) (Quit: dherman)
[21:25:09] *** Quits: jmgrosen (john@moz-848F6087.sb.sd.cox.net) (Connection reset by peer)
[21:25:39] *** Quits: brson (brson@2557E599.66715431.D25A875A.IP) (Ping timeout)
[21:25:39] *** Quits: Ralith (ralith@moz-50F3C77.vc.shawcable.net) (Ping timeout)
[21:26:05] <bblum> oh i just realized why redirecting "rustc .... 2>output.txt" with commands copy-pasted from "make VERBOSE=1" fails to redirect output
[21:26:06] *** Joins: brson (brson@2557E599.66715431.D25A875A.IP)
[21:26:06] *** ChanServ sets mode: +o brson
[21:26:24] <bblum> because it's actually "rustc ... && touch ... 2>output.txt"
[21:26:30] <bblum> woops.
[21:27:07] *** Joins: MaikKlein (maik@moz-F9B59FC9.dip0.t-ipconnect.de)
[21:27:17] *** Joins: jmgrosen (john@moz-848F6087.sb.sd.cox.net)
[21:27:29] <MaikKlein> what is ICE? Compiler error?
[21:27:29] *** Quits: jmgrosen (john@moz-848F6087.sb.sd.cox.net) (Connection reset by peer)
[21:27:37] <cmr> Internal Compiler Error, yes.
[21:27:45] *** Quits: bytbox (s@moz-D83E9B31.wireless.umd.edu) (Ping timeout)
[21:29:55] *** Joins: engla (engla@moz-DBD1D96E.cust.bredbandsbolaget.se)
[21:29:55] *** Quits: spider-mario (spidermari@moz-2F72F6FF.dsl.quantic-telecom.net) (Connection reset by peer)
[21:30:19] *** Quits: jgilbert (jgilbert@2557E599.66715431.D25A875A.IP) (Quit: Leaving)
[21:30:29] *** Joins: jmgrosen (john@moz-848F6087.sb.sd.cox.net)
[21:31:25] *** Quits: jmgrosen (john@moz-848F6087.sb.sd.cox.net) (Connection reset by peer)
[21:31:32] <SiegeLord> rusti: trait Axes {} let axes : ~[~Axes] = ~[];
[21:31:34] -rusti- line longer than 150 columns, pastebinned: http://sprunge.us/OOHI
[21:31:48] <SiegeLord> Any clue what I'm doing wrong?
[21:32:00] *** Joins: bytbox (s@moz-D83E9B31.wireless.umd.edu)
[21:32:01] <cmr> rusti: trait Axes {} let axes : ~[@Axes] = ~[];
[21:32:03] -rusti- ()
[21:32:14] <cmr> SiegeLord: bug with ~Trait, maybe? Is ~Trait even a thing?
[21:32:16] *** Quits: ksev (DrunkenPan@745B767B.989A61DC.CA5B6332.IP) (Ping timeout)
[21:32:20] *** Joins: mindginative (mindginati@moz-9C555AF3.spmconsultants.co.nz)
[21:32:22] *** Quits: mindginative (mindginati@moz-9C555AF3.spmconsultants.co.nz) (Quit: mindginative)
[21:32:32] <engla> it should be
[21:32:35] <SiegeLord> Don't see why it wouldn't be
[21:32:51] <bblum> stats for Sized errors on libextra: 776 total errors; function return types and instantiating sized-bounded typarams with unsized types each are 30% of that
[21:33:10] <bblum> a further 20% are arguments passed to functions
[21:33:37] *** Joins: jmgrosen (john@moz-848F6087.sb.sd.cox.net)
[21:33:42] <pcwalton> there are bugs with ~Trait
[21:34:29] *** Quits: devinus (devinus@moz-B4AF84BC.ptr.us.xo.net) (Quit: Computer has gone to sleep.)
[21:34:29] *** Quits: jmgrosen (john@moz-848F6087.sb.sd.cox.net) (Connection reset by peer)
[21:34:42] *** Joins: dherman (dherman@2557E599.66715431.D25A875A.IP)
[21:34:43] *** ChanServ sets mode: +o dherman
[21:35:18] <bblum> how do I make rustc start outputting in colour again?
[21:35:32] <strcat> bblum: which terminal do you use?
[21:35:38] <bblum> xfce4-terminal
[21:35:41] <bblum> i have TERM=xterm set
[21:35:53] <strcat> bblum: go into the xfce terminal settings and make it use xterm-256color
[21:35:57] *** Quits: mattin (user@F4FAB1DA.DC7A989C.7F8AB798.IP) (Ping timeout)
[21:35:58] <cmr> bblum: xterm isn't ANSI compliant. use xterm-256color
[21:36:06] *** Joins: erickt (erickt@8C9ECD8F.3A598286.F12515B4.IP)
[21:36:13] <strcat> bblum: it's a bad default by libvte
[21:36:37] *** Joins: jmgrosen (john@moz-848F6087.sb.sd.cox.net)
[21:36:41] <strcat> it should really define xterm-vte or similar and set the stuff properly
[21:37:03] <bblum> o_O xterm-256color made it unusable
[21:37:04] *** Quits: jmgrosen (john@moz-848F6087.sb.sd.cox.net) (Connection reset by peer)
[21:37:18] <strcat> bblum: unusable?
[21:37:31] <bblum> made my terminals unusable
[21:37:36] <doener> bblum: which distro?
[21:37:41] <bblum> doener: gentoo
[21:37:51] <bblum> i couldn't... press enter, backspace rendered weird unicode characters instead of backspacing, etc
[21:37:58] <strcat> bblum: there should be an ncurses terminfo database including xterm-256color, among others
[21:38:15] <strcat> in /usr/share/terminfo/
[21:38:46] <doener> bblum: hm, don't know about gentoo, but at least Debian has some terminfo stuff in /lib/terminfo (everything that's in ncurses-base, which includes xterm-256color), and the new terminfo stuff in rust doesn't look there by default
[21:38:48] <bblum> that directory contains a bunch of directories with one-character names
[21:38:49] *** Quits: erickt (erickt@8C9ECD8F.3A598286.F12515B4.IP) (Ping timeout)
[21:39:03] *** Joins: lmandel (lmandel@FE1F74.86ED00A7.971E19F6.IP)
[21:39:09] <strcat> bblum: yeah, the 'x' dir should have xterm-256color
[21:39:10] <bblum> ok, i have /usr/share/terminfo/x/xterm-256color
[21:39:33] <strcat> bblum: does 'TERM=xterm-256color tput colors' output 256?
[21:39:50] <bblum> yep
[21:39:54] <bblum> and without, it says 8
[21:40:05] *** Joins: jmgrosen (john@moz-848F6087.sb.sd.cox.net)
[21:40:07] <bblum> but TERM=xterm-256color rustc ... doesn't help
[21:40:49] <doener> bblum: do you have TERMINFO or TERMINFO_DIRS set in your environment?
[21:40:49] *** Quits: jmgrosen (john@moz-848F6087.sb.sd.cox.net) (Connection reset by peer)
[21:41:01] <bblum> neitehr
[21:41:13] <doener> ok, I give up then
[21:41:31] <bblum> rustc should really output colour for 8 colour terminals
[21:41:48] <strcat> xfce terminal has 256 colors though... :(
[21:41:56] <strcat> there aren't any 8 colour terminals anymore
[21:41:59] <strcat> linux console is 24
[21:42:44] *** Quits: eholk (eholk@moz-F8E3901F.uconnect.utah.edu) (Quit: eholk)
[21:42:49] *** Joins: pragmatic (pragmatic@moz-1A421840.hsd1.ca.comcast.net)
[21:42:59] *** Joins: jmgrosen (john@moz-848F6087.sb.sd.cox.net)
[21:43:00] <bblum> can i just hack rustc to output colur
[21:43:01] <bblum> colour
[21:43:11] <kimundi> What would speak against 8 colors, though?
[21:43:11] *** Quits: jmgrosen (john@moz-848F6087.sb.sd.cox.net) (Connection reset by peer)
[21:43:18] *** Quits: paulproteus (quassel@rose.makesad.us) (Ping timeout)
[21:43:20] <strcat> bblum: well afaik it should work with TERM=xterm-256color so I don't really understand
[21:43:28] <kimundi> I mean, runtc needs, like, 3...
[21:44:16] *** Joins: paulproteus (quassel@moz-E86A3B42.makesad.us)
[21:44:22] <lkuper> aw, runtc.  rustc's baby sibling.
[21:44:43] * lkuper scruffles it.
[21:44:59] <bblum> c.c
[21:45:06] <bblum> i want my colours back :(
[21:45:12] <kimundi> me too :(
[21:45:46] *** Joins: ghrust (ghrust@FD7BC443.6A2AE50.F3114085.IP)
[21:45:46] <ghrust> 01[13rust01] 15bors merged 06auto into 06incoming: 02http://git.io/oYD9rw
[21:45:46] *** Parts: ghrust (ghrust@FD7BC443.6A2AE50.F3114085.IP) ()
[21:45:57] <strcat> bblum: meh it seems like it's just broken for some reason
[21:45:58] *** Joins: jmgrosen (john@moz-848F6087.sb.sd.cox.net)
[21:45:58] <lkuper> bblum: your terminal's mad at your for your use of non-US spelling.  "your in america."
[21:46:08] <strcat> let me try to figure out what it's doing
[21:46:08] *** Quits: jmgrosen (john@moz-848F6087.sb.sd.cox.net) (Connection reset by peer)
[21:47:07] *** Joins: Jesin (Jessin_@moz-48B48C95.eecs.lehigh.edu)
[21:47:53] *** Joins: eholk (eholk@moz-F8E3901F.uconnect.utah.edu)
[21:48:11] <strcat> cmr: it doesn't seem to be reading terminfo at all
[21:48:26] *** Joins: int3_ (int3_@moz-ABE52D50.hsd1.ca.comcast.net)
[21:48:43] *** Joins: ghrust (ghrust@1E8607E8.6A2AE50.F3114085.IP)
[21:48:44] <ghrust> 01[13rust01] 15bors pushed 0 new commits to 06auto: 02http://git.io/0MF7XQ
[21:48:44] *** Parts: ghrust (ghrust@1E8607E8.6A2AE50.F3114085.IP) ()
[21:48:44] *** Joins: ghrust (ghrust@DE823A67.6A2AE50.F3114085.IP)
[21:48:44] <ghrust> 01[13rust01] 15bors pushed 5 new commits to 06auto: 02http://git.io/gfYQ-Q
[21:48:44] <ghrust> 13rust/06auto 14af2086a 15Marvin LÃ¶bel: Added iter::FromIter
[21:48:44] <ghrust> 13rust/06auto 14857d433 15Marvin LÃ¶bel: Added IteratorUtil::collect
[21:48:44] <ghrust> 13rust/06auto 140700154 15Marvin LÃ¶bel: Removed IteratorUtil::to_vec and iter::to_vec
[21:48:45] *** Parts: ghrust (ghrust@DE823A67.6A2AE50.F3114085.IP) ()
[21:48:51] *** Joins: jgilbert (jgilbert@2557E599.66715431.D25A875A.IP)
[21:49:10] <strcat> oh nvm it is
[21:49:12] *** Joins: jmgrosen (john@moz-848F6087.sb.sd.cox.net)
[21:49:15] <strcat> [pid 29296] stat("/usr/share/terminfo", {st_mode=S_IFDIR|0755, st_size=4096, ...}) = 0
[21:49:17] <strcat> [pid 29296] stat("/usr/share/terminfo/x/xterm-termite", {st_mode=S_IFREG|0644, st_size=2433, ...}) = 0
[21:49:19] <strcat> [pid 29296] open("/usr/share/terminfo/x/xterm-termite", O_RDONLY) = 3
[21:49:21] <strcat> but it's not detecting color
[21:49:23] <strcat> perhaps a parsing bug?
[21:49:23] *** Quits: jmgrosen (john@moz-848F6087.sb.sd.cox.net) (Connection reset by peer)
[21:49:48] *** Quits: Axord (xord@moz-C3CCF156.lsanca.dsl-w.verizon.net) (Quit: I'm sure it's perfectly safe)
[21:50:11] *** Joins: devinus (devinus@moz-B4AF84BC.ptr.us.xo.net)
[21:50:13] *** Quits: int3_ (int3_@moz-ABE52D50.hsd1.ca.comcast.net) (Ping timeout)
[21:51:28] *** Joins: \n (NDesaulnie@2557E599.66715431.D25A875A.IP)
[21:52:07] *** Quits: tgt (tgt@moz-D59EE478.aztw.cable.virginmedia.com) (Quit: Computer has gone to sleep.)
[21:52:19] *** Joins: jmgrosen (john@moz-848F6087.sb.sd.cox.net)
[21:53:09] *** Quits: jmgrosen (john@moz-848F6087.sb.sd.cox.net) (Connection reset by peer)
[21:53:10] *** Joins: tjc (tjc@36B3FF50.4D3A0C06.43B20542.IP)
[21:53:10] *** ChanServ sets mode: +o tjc
[21:53:23] <bjz> jensnockert: ping
[21:53:26] *** Quits: \n (NDesaulnie@2557E599.66715431.D25A875A.IP) (Ping timeout)
[21:53:48] <strcat> tjc: btw that chdir race you ran into a while ago is at least fixable on POSIX - not sure about windows
[21:54:12] <tjc> strcat: fixable without the current kludgy solution (locks), you mean?
[21:54:14] <strcat> tjc: there's the openat family of functions for opening files relative to a directory descriptor
[21:54:20] <strcat> so we could have a task-local CWD
[21:54:41] <strcat> but again, I don't know about windows at all
[21:54:45] <tjc> strcat: Ah ok. I have no time to look into it right now (working on my talk), but improving that situation is welcome! (either by doing it or filing a bug)
[21:54:48] <tjc> I don't know about Windows either
[21:55:16] *** Joins: jmgrosen (john@moz-848F6087.sb.sd.cox.net)
[21:55:32] *** Joins: \n (NDesaulnie@43CB6079.66715431.D25A875A.IP)
[21:56:08] *** Quits: jmgrosen (john@moz-848F6087.sb.sd.cox.net) (Connection reset by peer)
[21:56:53] *** Quits: infynyxx (infynyxx@DB780A29.749BA1D.DCC373F0.IP) (Client exited)
[21:57:25] *** Quits: tjc (tjc@36B3FF50.4D3A0C06.43B20542.IP) (Quit: Places to go, people to annoy)
[21:57:54] *** Quits: cowboyd (cowboyd@moz-1BD02A1E.sw.biz.rr.com) (Client exited)
[21:58:48] *** Quits: donri (dag@moz-9BB61102.tbcn.telia.com) (Client exited)
[21:59:09] *** Joins: jmgrosen (john@moz-848F6087.sb.sd.cox.net)
[21:59:37] <MaikKlein> bjz, are there some requirements for glcore?
[21:59:38] *** Quits: jmgrosen (john@moz-848F6087.sb.sd.cox.net) (Connection reset by peer)
[21:59:55] <bjz> glewinfo?
[22:00:06] <MaikKlein> I mean like if I have to have 4.3
[22:00:07] <MaikKlein> or sth
[22:01:38] <kimundi> afaik no
[22:01:50] <MaikKlein> ah I probably found the problem
[22:02:04] *** Quits: saml (sam@moz-14C16814.cst.lightpath.net) (Quit: Leaving)
[22:02:15] *** Joins: jmgrosen (john@moz-848F6087.sb.sd.cox.net)
[22:02:34] <MaikKlein> I think I have to activate my gpu before I run glewinfo
[22:02:35] *** Quits: jmgrosen (john@moz-848F6087.sb.sd.cox.net) (Connection reset by peer)
[22:04:01] <cmr> strcat: kimundi: bblum: the terminfo search uses the TERMINFO_DIRS and TERMINFO environment variables to do searching, as any other ncurses application would
[22:04:01] <MaikKlein> hm not really :/
[22:04:14] <moonchrome> MaikKlein, GL core is 3.1 I think
[22:04:16] <moonchrome> or 3.2
[22:04:20] <strcat> cmr: ncurses only uses those to override the default though
[22:04:25] <strcat> it should work without them
[22:04:26] <cmr> Right
[22:04:33] <MaikKlein> moonchrome, I currently have 4.0
[22:04:40] <moonchrome> MaikKlein, you're fine then
[22:04:41] <strcat> cmr: anyway it successfully finds the file for me
[22:04:46] <strcat> cmr: but doesn't use colours
[22:04:49] <cmr> bblum: mind getting an strace rustc ... | grep xterm?
[22:04:52] <strcat> strace -f
[22:04:54] <cmr> Wait, did someone break it?
[22:05:09] <strcat> cmr: don't know, but it doesn't work ;p
[22:05:14] *** Joins: jmgrosen (john@moz-848F6087.sb.sd.cox.net)
[22:05:16] <cmr> *grumble*
[22:05:16] *** Quits: jmgrosen (john@moz-848F6087.sb.sd.cox.net) (Connection reset by peer)
[22:05:27] <MaikKlein> moonchrome, I get those errors if I use glcore http://pastebin.com/8y5ajVyU
[22:05:29] <moonchrome> MaikKlein, just don't request a higher context version than your drivers support and you're fine, but you need to have 3.2 to use GL core context
[22:05:38] <strcat> cmr: http://ix.io/61h definitely finds it
[22:05:53] <cmr> RUST_LOG=extra::terminfo=4 ?
[22:06:18] <strcat> rust: ~"colors#256"
[22:06:20] <strcat> rust: ~"pairs#32767"
[22:06:25] <strcat> still not using colours
[22:06:26] <cmr> setab and setaf?
[22:06:27] <strcat> ;p
[22:06:36] <bblum> cmr: 3 lines:
[22:06:36] <bblum> [pid 24719] stat("/usr/share/terminfo/x/xterm-256color", {st_mode=S_IFREG|0644, st_size=3336, ...}) = 0
[22:06:40] <bblum> [pid 24719] open("/usr/share/terminfo/x/xterm-256color", O_RDONLY) = 3
[22:06:42] <bblum> [pid 24719] read(3, "\32\1%\0&\0\17\0\235\1\251\5xterm-256color|xterm"..., 4096) = 3336
[22:06:44] <MaikKlein> I probably have messed sth up
[22:06:54] <strcat> cmr: no
[22:07:03] <strcat> cmr: they're in 'infocmp' but it doesn't find them
[22:07:24] <cmr> strcat: what are they?
[22:07:34] <strcat>  setab=\E[%?%p1%{8}%<%t4%p1%d%e%p1%{16}%<%t10%p1%{8}%-%d%e48;5;%p1%d%;m,
[22:07:36] <strcat>  setaf=\E[%?%p1%{8}%<%t3%p1%d%e%p1%{16}%<%t9%p1%{8}%-%d%e38;5;%p1%d%;m,
[22:07:45] <cmr> Yeah I didn't implement conditional expressions yet.
[22:08:00] <strcat> well those are the xterm-256color ones
[22:08:02] <cmr> There should have been a debug message about them being unimplemented...
[22:08:07] *** Joins: jmgrosen (john@moz-848F6087.sb.sd.cox.net)
[22:08:17] <strcat> cmr: nope
[22:08:35] <strcat> cmr: http://ix.io/61i
[22:08:35] *** Quits: jmgrosen (john@moz-848F6087.sb.sd.cox.net) (Connection reset by peer)
[22:09:26] <moonchrome> MaikKlein, those look like 4.1+ functions
[22:09:27] <cmr> strcat: oh, RUST_LOG=extra::term=2
[22:09:46] <strcat> foo.rs:1:10: 1:11 rust: ~"~\"if expressions unimplemented (&[27, 91, 37, 63, 37, 112, 49, 37, 123, 56, 125, 37, 60, 37, 116, 51, 37, 112, 49, 37, 100, 37, 101, 37, 112, 49, 37, 123, 49, 54, 125, 37, 60, 37, 116, 57, 37, 112, 49, 37, 123, 56, 125, 37, 45, 37, 100, 37, 101, 51, 56, 59, 53, 59, 37, 112, 49, 37, 100, 37, 59, 109])\""
[22:09:52] <cmr> yup
[22:10:03] <cmr> I can't fix it right now but I will be able to in ~3 hours
[22:10:08] <strcat> sounds good :)
[22:10:43] *** Quits: Jesin (Jessin_@moz-48B48C95.eecs.lehigh.edu) (Quit: Leaving)
[22:11:07] *** Joins: infynyxx (infynyxx@DB780A29.749BA1D.DCC373F0.IP)
[22:11:07] <MaikKlein> moonchrome, yeah I checked again and I currently have opengl 4.2, I try to find the latest driver for 4.3 now
[22:11:11] *** Joins: jmgrosen (john@moz-848F6087.sb.sd.cox.net)
[22:12:04] *** Quits: jmgrosen (john@moz-848F6087.sb.sd.cox.net) (Connection reset by peer)
[22:12:14] <MaikKlein> i think glewinfo is messed up with bumblebee 
[22:12:55] <bjz> MaikKlein: there have been issue for other people on linux :(
[22:13:21] <bjz> I really don't know how to fix it, because I can't reproduce the problem locally
[22:14:44] <bjz> But with gl-rs coming soon, I'm hesitant to put a great deal of time into the problem. That said, if you can locate the problem, I'm very open to fixing it.
[22:14:49] *** Joins: jmgrosen (john@moz-848F6087.sb.sd.cox.net)
[22:14:52] <MaikKlein> yeah not that bad, I just have to wait for your gl-rs
[22:14:52] *** Quits: jmgrosen (john@moz-848F6087.sb.sd.cox.net) (Connection reset by peer)
[22:15:02] <bjz> The other option is to use opengl-es
[22:15:11] <MaikKlein> but this only works with 0.6 right?
[22:15:12] <bjz> sorry :(
[22:15:23] <bjz> no, opengl-es is up to date
[22:15:27] <MaikKlein> oO
[22:15:38] <bjz> it works with servo, so they keep it up to date
[22:15:53] <bjz> glcore is also up to date with incoming
[22:16:17] *** Joins: \n_ (NDesaulnie@2557E599.66715431.D25A875A.IP)
[22:16:58] *** Quits: \n (NDesaulnie@43CB6079.66715431.D25A875A.IP) (Ping timeout)
[22:16:58] *** \n_ is now known as \n
[22:17:30] <MaikKlein> okay mabye I just have the wrong repo
[22:17:37] <MaikKlein> https://github.com/mozilla-servo/rust-opengles this is the wrong one right?
[22:18:03] <SiegeLord> What does this mean? "error: internal compiler error: Cannot relate bound region as subregion: br_self"
[22:18:03] *** Joins: jmgrosen (john@moz-848F6087.sb.sd.cox.net)
[22:18:14] <strcat> SiegeLord: a compiler bug
[22:18:14] *** Quits: jmgrosen (john@moz-848F6087.sb.sd.cox.net) (Connection reset by peer)
[22:18:48] *** Quits: \n (NDesaulnie@2557E599.66715431.D25A875A.IP) (Ping timeout)
[22:19:11] <MaikKlein> because https://github.com/mozilla-servo/rust-opengles definitely has not the core extra name change yet, maybe I can update it
[22:19:54] <SiegeLord> https://gist.github.com/SiegeLord/5725452 line 20 is causing it
[22:20:08] <strcat> SiegeLord: should report it
[22:20:30] <bjz> pcwalton: is opengl-es meant to be up to date with incoming or master?
[22:20:39] <pcwalton> it's up to date with servo
[22:20:43] <pcwalton> which is at master or so
[22:20:46] *** Joins: \n (NDesaulnie@43CB6079.66715431.D25A875A.IP)
[22:20:56] *** Joins: jmgrosen (john@moz-848F6087.sb.sd.cox.net)
[22:21:18] <MaikKlein> okay I probably shouldn't update it for incoming then
[22:21:18] *** Quits: jmgrosen (john@moz-848F6087.sb.sd.cox.net) (Connection reset by peer)
[22:21:22] <SiegeLord> I don't even know if I'm doing it right...
[22:21:44] <SiegeLord> I want the parent to be able to refer to multiple children via a trait object
[22:21:49] <MaikKlein> hm well I can still fork it
[22:21:54] <strcat> SiegeLord: whether the code is right or not, it shouldn't hit an ICE
[22:22:06] <SiegeLord> Sure I hit the ICE, but I bet it's a legit error that's just unhandled
[22:22:29] <SiegeLord> Let me report it anyway... but am I even on the right track with that code?
[22:22:49] <SiegeLord> That's what I would do in C++, for example...
[22:23:24] <strcat> SiegeLord: it doesn't really make sense to me what you want to do
[22:23:52] *** Quits: infynyxx (infynyxx@DB780A29.749BA1D.DCC373F0.IP) (Client exited)
[22:23:54] <strcat> you definitely can't store borrow pointers to something you then return by-value
[22:23:58] <strcat> borrowed*
[22:24:02] <strcat> in C++ either
[22:24:19] <SiegeLord> Well, in C++ I'd store a pointer
[22:24:55] <SiegeLord> And if not return it as ~... what else would I return it as?
[22:25:09] <SiegeLord> Parent shouldn't care about the type, is just needs the interface
[22:25:22] <SiegeLord> So I can't imagine it owning the children
[22:25:41] *** Joins: erickt (erickt@8C9ECD8F.3A598286.F12515B4.IP)
[22:26:13] *** cscott is now known as cscottnet_away
[22:27:04] *** Joins: jmgrosen (john@moz-848F6087.sb.sd.cox.net)
[22:27:14] *** Joins: tiffany (kawaii@moz-1E0FE6E8.dhcp.embarqhsd.net)
[22:27:14] *** Quits: jmgrosen (john@moz-848F6087.sb.sd.cox.net) (Connection reset by peer)
[22:27:15] *** Quits: dcoates (dcoates@moz-BE33DA21.fw1.sfo1.mozilla.net) (Input/output error)
[22:27:18] <strcat> SiegeLord: you can only store borrowed pointers in the struct if the object they point out outlives them
[22:27:25] <strcat> point at*
[22:27:33] <MaikKlein> btw
[22:27:51] <strcat> so you definitely can't allocate an object, store a borrowed pointer to it and return it without any restrictions
[22:27:55] *** Joins: SingingBoyo (brandon@moz-94AE1D3A.bchsia.telus.net)
[22:28:13] <MaikKlein> if you do let ret = ~Child;
[22:28:13] <MaikKlein> p.a = Some(ret as &'l Trait); hasn't ret already moved to p.a?
[22:28:59] *** Quits: tiffany (kawaii@moz-1E0FE6E8.dhcp.embarqhsd.net) (Ping timeout)
[22:29:02] <Jeaye> Is there a way to implement a singleton pattern in Rust so far? 
[22:29:30] <kimundi> Jeaye: Task Local Storage
[22:29:30] <strcat> 'singleton pattern' as in unique global variable? ;p
[22:29:57] *** Joins: jmgrosen (john@moz-848F6087.sb.sd.cox.net)
[22:30:16] <Jeaye> kimundi: Are there docs on this? 
[22:30:16] *** Quits: jmgrosen (john@moz-848F6087.sb.sd.cox.net) (Connection reset by peer)
[22:30:35] <MaikKlein> Jeaye, he means that memory isn't shared between tasks
[22:30:44] <Jeaye> strcat: Preferably a struct with static methods and members.
[22:31:07] <MaikKlein> Jeaye, so it's probably not possible to have some global
[22:31:08] <strcat> Jeaye: well you can have a global variable that's task-local (like thread-local storage in C++)
[22:31:09] <Jeaye> I'm not looking to share between tasks, just between modules without passing around a managed or unique box.
[22:31:15] <kimundi> Jeaye: If it's just a constant, so problem
[22:31:21] <Jeaye> Not cosntant
[22:31:25] <Jeaye> constant
[22:31:30] *** Quits: devinus (devinus@moz-B4AF84BC.ptr.us.xo.net) (Quit: Textual IRC Client: www.textualapp.com)
[22:32:15] <Jeaye> It's a dispatcher of sorts that I'd like a number of structs to subscribe to, but I only ever want one of them and would like to avoid passing it around everywhere.
[22:32:30] *** Quits: \n (NDesaulnie@43CB6079.66715431.D25A875A.IP) (Ping timeout)
[22:33:19] <xenocons> rusti: [5,...15]
[22:33:19] -rusti- <anon>:10:12: 10:13 error: unexpected token: `.`
[22:33:19] -rusti- <anon>:10          [5,...15]
[22:33:19] -rusti-                       ^
[22:33:19] -rusti- application terminated with error code 101
[22:33:32] <Jeaye> ruediger: [5,..15]
[22:33:33] <moonchrome> bjz, what do you think about this approach - https://gist.github.com/moonchrome/5725536
[22:33:40] <Jeaye> rusti: [5,..15]
[22:33:41] <moonchrome> bjz, it's ugly but it seems to work
[22:33:41] -rusti- [5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5]
[22:33:46] <Jeaye> xenocons: ^
[22:33:54] <xenocons> ahh
[22:33:54] *** Joins: \n (NDesaulnie@2557E599.66715431.D25A875A.IP)
[22:33:56] <xenocons> duhh
[22:33:58] <xenocons> Jeaye: ty
[22:34:00] <Jeaye> Cheers.
[22:34:04] *** Quits: carllerche (carllerche@moz-BF6CB667.hsd1.ca.comcast.net) (Ping timeout)
[22:34:08] <xenocons> i may need coffee :)
[22:34:12] <Jeaye> heh
[22:34:17] <xenocons> that works the same as in all languages ive used :\ heh
[22:34:58] *** Joins: carllerche (carllerche@moz-BF6CB667.hsd1.ca.comcast.net)
[22:35:31] <bjz> moonchrome: yeah, it's a shame, unfortunately that would limit use to having Real vectors
[22:35:53] <SiegeLord> strcat, This is what I want http://pastebin.ca/2391701 Can that be expressed in Rust, or should I rethink my design?
[22:36:15] <moonchrome> bjz,  Real ?
[22:36:22] <bjz> moonchrome: ie. floats
[22:36:36] <moonchrome> bjz, no it's also parametrized
[22:36:38] <\n> SiegeLord: there's supertraits
[22:36:41] <moonchrome> bjz, by macro
[22:36:49] <strcat> SiegeLord: you aren't expressing ownership anywhere
[22:37:01] <moonchrome> so you can generate one instance for float one for f32, etc.
[22:37:20] <strcat> SiegeLord: you can use extra::rc or managed boxes if you don't want to use a design with ownership
[22:37:33] <bjz> moonchrome: ohh, I think I see
[22:37:41] <SiegeLord> strcat, well, the parent can own a child... but I want it to own it through a trait object
[22:37:55] <strcat> SiegeLord: so use ~Trait
[22:38:03] <SiegeLord> \n, What the heck is that :D?
[22:38:05] *** Quits: Blub\w (wry@7E3BB9D.71150E1A.237AE2BA.IP) (Quit: night)
[22:38:10] <strcat> or don't use trait objects
[22:38:25] <moonchrome> bjz, "define_vec!(Vec3, vec3, f32, x, y, z)" f32 is used in this case
[22:38:33] <bjz> moonchrome: maybe we could also have documentation on how users can create their own macrofied definitions, in place of generics
[22:38:40] <\n> Siegelord: look in the tutorial, I'm super busy right nowâ€¦sorry!
[22:38:57] <bjz> moonchrome: just as an appendix
[22:39:09] <xenocons> parameters in functions can be `mut' right
[22:39:14] <SiegeLord> Oh, that's not as exciting as I thought...
[22:39:25] <xenocons> fn(x: mut int)  { ... }
[22:39:33] <xenocons> fn f(x: mut int)  { ... }
[22:39:40] <moonchrome> bjz, hopefully it's just a placeholder and when they implement associated items you can just swap the macro implementations with aliases to generic types
[22:39:44] <MaikKlein> does someone already work on an functional opengl abstraction layer?
[22:40:01] <bjz> moonchrome: yeah
[22:40:07] <strcat> SiegeLord: for the parent to own the child, the child has to be inside the parent
[22:40:27] <strcat> you can have borrowed pointers to the child externally
[22:40:33] <brson> cmr: working on jemalloc now. it's passed all the bots but win. doing some multithreading tests
[22:40:48] <moonchrome> bjz, but implementing a matrix this way *barf*
[22:40:50] <bjz> moonchrome: and fix the bug where you can't have static methods in multiple impls on the same type :(
[22:41:02] <bjz> moonchrome: believe me, I agree
[22:41:11] <SiegeLord> Oh, that's not as exciting as I thought...
[22:41:14] <SiegeLord> Whoops
[22:41:14] *** Quits: doener (doener@moz-121949B3.unitymediagroup.de) (Quit: leaving)
[22:42:01] <bjz> moonchrome: ahh dang, so you can't use deriving inside macros?
[22:42:09] *** cscottnet_away is now known as cscottnet
[22:42:29] <moonchrome> bjz, yea someone reported it as bug
[22:42:39] *** Joins: ghrust (ghrust@CFE85B59.6A2AE50.F3114085.IP)
[22:42:39] <ghrust> 01[13rust01] 15bors merged 06auto into 06incoming: 02http://git.io/gfYQ-Q
[22:42:39] *** Parts: ghrust (ghrust@CFE85B59.6A2AE50.F3114085.IP) ()
[22:42:48] <bjz> moonchrome: I like the Vec3::normalize(&a)
[22:42:53] <moonchrome> bjz, also you can't have multiple instances of a same macro inside a macro
[22:42:57] <SiegeLord> strcat, But how do I do it in practice? https://gist.github.com/SiegeLord/5725452/81289fd83d426bddc0b9c6877071c743753e8975
[22:43:19] <pauls> moonchrome: what do you mean?
[22:43:20] <SiegeLord> As soon as I convert ~Child to ~Trait, I lose the ability to get a &Child out of it
[22:43:25] <strcat> SiegeLord: I don't know what you actually what to do
[22:43:29] <strcat> why do you need trait objects?
[22:43:35] <pauls> You can invoke as many macros as you want on the RHS of a macro.
[22:43:48] <erickt> Hey there #rust, anyone else coming to the Wednesday bay area meetup that hasn't replied to my email to the mailing list?
[22:43:49] <moonchrome> pauls, but inside another macro
[22:43:50] *** Quits: dylukes (dylukes@moz-E4DF3FED.pitbpa.fios.verizon.net) (Quit: ["Textual IRC Client: www.textualapp.com"])
[22:43:53] <SiegeLord> strcat, Well, there may be ChildType1, ChildType2 etc
[22:43:56] <SiegeLord> But only one Trait
[22:44:04] <strcat> SiegeLord: are all the types known in advance?
[22:44:13] <SiegeLord> Sure
[22:44:18] <strcat> so you don't need trait objects
[22:44:28] <strcat> you need an enum
[22:44:34] <moonchrome> pauls, eg. this https://gist.github.com/moonchrome/5722958
[22:45:03] <strcat> enum Child { T1(Type1), T2(Type2), ... }
[22:45:18] <strcat> and Nothing, if you want it to be nullable (which you need, if it's recursive)
[22:45:27] <pauls> moonchrome: that doesn't work because impl_vec_op! expands to an item, so impl_vec_ops expands to two items.
[22:45:37] *** Joins: ghrust (ghrust@5FEF1C87.6A2AE50.F3114085.IP)
[22:45:37] <ghrust> 01[13rust01] 15bors pushed 0 new commits to 06auto: 02http://git.io/rd16KA
[22:45:37] *** Parts: ghrust (ghrust@5FEF1C87.6A2AE50.F3114085.IP) ()
[22:45:37] *** Joins: ghrust (ghrust@1E8607E8.6A2AE50.F3114085.IP)
[22:45:38] <ghrust> 01[13rust01] 15bors pushed 3 new commits to 06auto: 02http://git.io/OMk6VQ
[22:45:38] <ghrust> 13rust/06auto 142d59eba 15John Clements: add test cases for fold traversing macros
[22:45:38] <ghrust> 13rust/06auto 14eff49fc 15John Clements: implement fold traversing macros
[22:45:38] <ghrust> 13rust/06auto 146a09b6f 15bors: auto merge of #6981 : jbclements/rust/fold-traverses-macros, r=catamorphism...
[22:45:38] <moonchrome> pauls, actually yeah I just figured that out xD
[22:45:40] *** Parts: ghrust (ghrust@1E8607E8.6A2AE50.F3114085.IP) ()
[22:45:43] <pauls> moonchrome: https://github.com/mozilla/rust/issues/4375
[22:45:48] <SiegeLord> I guess that works, although I'll end up needing to pattern match to get at their common interface
[22:45:55] <moonchrome> pauls, yea I ran in to that bug also
[22:46:12] <moonchrome> pauls, that's why I wrap all elements i generate in my current vector macro inside a mod
[22:46:13] *** kimundi is now known as zz_kimundi
[22:46:19] <moonchrome> pauls, so it generates only 1 item
[22:46:25] <bjz> moonchrome: we could have: define_vec!(vec3 { x, y, z}: Vec3f<float>, Vec3f32<f32>, Vec3f64<f64>, ... )
[22:46:53] <SingingBoyo> SiegeLord:  I think you can write impls for enums, so you can keep the pattern matching for the common interface in an impl at least
[22:46:57] <moonchrome> bjz, macros can only generate one item
[22:47:02] <bjz> moonchrome: then it would generate multiple types within the vec mod
[22:47:15] <bjz> moonchrome: no, as in within the vec mod
[22:47:15] *** Quits: wilsonk-laptop (kvirc@moz-39EFBFC2.cg.shawcable.net) (Ping timeout)
[22:47:16] *** Quits: MaikKlein (maik@moz-F9B59FC9.dip0.t-ipconnect.de) (Ping timeout)
[22:47:37] <moonchrome> oh you mean wrapped all in a same submodule
[22:47:37] <bjz> moonchrome: as long as you have a containing mod, it works ok
[22:47:42] <bjz> aye
[22:47:46] <moonchrome> ok
[22:48:04] <moonchrome> and I can do the macro for generating vectovec operators now
[22:48:15] <bjz> moonchrome: indeed
[22:48:29] <bblum> vectovec
[22:48:38] <bjz> we'll have to forgo bool/int vecs though
[22:49:01] *** Joins: Ralith (ralith@moz-50F3C77.vc.shawcable.net)
[22:49:15] <bjz> and we'll have to macrofy everything, like Planes Rays etc.
[22:49:30] <bblum> umm..... are we allowed to have kind bounds on impl Drops?
[22:49:33] <moonchrome> bjz, I don't know if that's worth it
[22:49:37] *** Joins: infynyxx (infynyxx@DB780A29.749BA1D.DCC373F0.IP)
[22:49:43] <bjz> moonchrome: neither
[22:49:43] <bblum> or only if #[unsafe_destructor] is used?
[22:49:54] <moonchrome> bjz, I think I can pull of ints in same vec macro
[22:49:55] <SiegeLord> Hmm, I suppose if I structure my child types the same I can destructure them?
[22:50:00] <bjz> moonchrome: better to have something working *today*
[22:50:06] <SiegeLord> I wonder if that's as efficient as a vtable
[22:50:15] <bjz> moonchrome: spent too long waiting :)
[22:50:29] <bjz> moonchrome: ok, it's a deal!
[22:51:03] <bjz> moonchrome: we can always refactor later
[22:51:16] <SiegeLord> Or nvm... I guess that doesn't work
[22:52:32] *** Quits: SiegeLord (sl@moz-CAF07B4C.hsd1.ma.comcast.net) (Quit: It's a joke. It's all a joke.)
[22:53:16] <xenocons> is there shorthand for post increment (a++) a mutable integer
[22:53:27] <EXetoC> no
[22:53:29] <strcat> nothing beyond += 1
[22:54:03] <xenocons> how would you usually rewrite this in rust: do { s[*search++]=i;} while(i--);
[22:54:54] <xenocons> (translating some C to rust)
[22:55:52] <moonchrome> bjz, well you can't really do anything without basic vector/matrix types
[22:56:05] <moonchrome> bjz, everything else is optional niceties
[22:56:06] <bjz> moonchrome: exactly
[22:56:10] *** Joins: SiegeLord (siege@moz-CAF07B4C.hsd1.ma.comcast.net)
[22:56:13] <xenocons> i guess let idx = search+search, search = idx, s[idx]=i,i=-i
[22:56:17] <strcat> xenocons: a for loop decrementing a range
[22:56:19] <Jeaye> I'd like to do something like this in Rust: http://ideone.com/wYjG6S
[22:56:41] <Jeaye> How can I?
[22:56:46] <bjz> moonchrome: this has been my holdup
[22:56:47] <bblum> vast majority of libsyntax errors (204/284) are function arguments
[22:57:15] <strcat> Jeaye: you can't
[22:57:21] <strcat> Jeaye: 'static' locals are unsafe mutable global variables
[22:57:27] <xenocons> rusti: [5,..-5]
[22:57:28] -rusti- application terminated abnormally with signal 11 (Segmentation fault)
[22:57:35] <xenocons> damnit
[22:57:45] *** Quits: Scriptor (historium@moz-E06F46F0.corp.bitshelter.com) (Quit: Scriptor)
[22:57:48] <Jeaye> strcat: Can I get anything like it?
[22:57:52] <SingingBoyo> rusti: int::range_rev(5, 0)
[22:57:55] -rusti- more than 5 lines of output, pastebinned: http://sprunge.us/WDNf
[22:57:58] <strcat> Jeaye: task-local storage will let you do it with a global that's local to the task
[22:58:08] <SingingBoyo> rusti: std::int::range_rev(5, 0)
[22:58:09] -rusti- more than 5 lines of output, pastebinned: http://sprunge.us/QGgO
[22:58:17] <strcat> Jeaye: if you don't mind paying a little cost for essentially indexing an array to access it
[22:58:28] <Jeaye> strcat: Mind sharing what that'd look like?
[22:58:41] <Jeaye> It sounds like a reasonable bet for me.
[22:58:43] <strcat> Jeaye: I don't really know what TLS is like in rust atm, I do now it's not what it should be
[22:58:50] <strcat> Jeaye: atm TLS uses @, and it shouldn't ;[
[22:59:19] <bblum> i'm not particularly proud of using @ in tls
[22:59:29] <strcat> Jeaye: it should be like pthread_{set,get}specific, essentially
[22:59:32] <SingingBoyo> rusti: let mut arr:~[int] = ~[]; std::int::range_rev(5, 0) |x| {arr.push(x)}; arr
[22:59:34] -rusti- more than 5 lines of output, pastebinned: http://sprunge.us/XgWS
[22:59:44] <EXetoC> xenocons: do uint::range_step(start, end, -1) |i| {...}?
[22:59:49] *** Joins: tgt (tgt@moz-D59EE478.aztw.cable.virginmedia.com)
[22:59:53] <Jeaye> strcat: Know of the best place to look for docs/examples of it?
[23:00:02] <SingingBoyo> rusti: let mut arr:~[int] = ~[]; do std::int::range_rev(5, 0) |x| {arr.push(x)}; arr
[23:00:03] *** Joins: SimonSapin (simon@A5049320.3E93794D.61EA6C28.IP)
[23:00:03] -rusti- more than 5 lines of output, pastebinned: http://sprunge.us/ALOX
[23:00:07] <xenocons> EXetoC: hmm, ill try this
[23:00:08] <bjz> bblum: is that your fault!
[23:00:09] <Jeaye> If it's going to be a bitch, I'll just redesign. :(
[23:00:16] <bjz> bblum: :D
[23:00:28] <strcat> Jeaye: nope, I really haven't used it or looked into using it yet - I don't think it will be a pain though
[23:00:32] <SingingBoyo> rusti: let mut arr:~[int] = ~[]; for std::int::range_rev(5, 0) |x| {arr.push(x)}; arr
[23:00:33] -rusti- ~[5, 4, 3, 2, 1]
[23:00:34] <EXetoC> xenocons: or maybe that ^
[23:00:40] <SingingBoyo> that took way too much effort
[23:00:41] <xenocons> neat
[23:00:41] <SingingBoyo> but
[23:00:44] <xenocons> ahha
[23:00:44] <SingingBoyo> there you have it
[23:00:46] <xenocons> ty
[23:00:51] <Jeaye> strcat: Ok, I'll look around more. Thanks. :)
[23:02:37] <bblum> bjz: sure is
[23:02:46] *** Quits: doomlord (doomlod@moz-8F385DB0.range109-153.btcentralplus.com) (Ping timeout)
[23:02:54] <bjz> bblum: hehe, just joking :)
[23:03:09] <xenocons> for array access, you need to use push? or can you simply, let arr:~[int] = ~[0,..15]; arr[4] = 2;
[23:03:24] <bjz> bblum: at l;east we have TLS :)
[23:03:25] <xenocons> let mut arr maybe
[23:03:32] <bjz> bblum: (I use it) :)
[23:03:39] <bblum> TLS is pretty great
[23:03:48] <xenocons> TLS the protocol suite ?
[23:03:53] <Jeaye> bblum: Do you've an example of it?
[23:04:05] <bjz> xenocons: task-local storage
[23:04:09] <xenocons> oh
[23:04:11] <brson> jemalloc gives a dramatic speedup to msgsend-pipes on linux
[23:04:13] <xenocons> i got excited
[23:04:19] <bjz> hehe
[23:04:26] <xenocons> but task local storage is also cool
[23:04:28] <brson> 13.1s -> 7.7s
[23:04:37] <pcwalton> wow
[23:04:38] <bjz> brson: yay!
[23:04:44] <pcwalton> is that oldsched or newsched?
[23:04:54] <bjz> brson: what is it?
[23:05:05] <brson> pcwalton: old
[23:05:14] <strcat> bjz: jemalloc is an alternate malloc implementation
[23:05:45] <bjz> strcat: ooh
[23:05:56] <bjz> strcat: what does that mean for us?
[23:05:58] <strcat> compared to glibc it suffers less from fragmentation... not really a huge improvement - on windows and OS X it could be a huge win
[23:06:01] <xenocons> bloody hell why does this C need to be so 'smart'
[23:06:03] *** Joins: deepdog (deepdog@moz-490E834C.client.mchsi.com)
[23:06:07] <SingingBoyo> xenocons:  I was just building up an array there where the indexes wouldn't exist before I put something in them.  afaik, you can use arr[4] = 2
[23:06:20] <xenocons> right, thats good
[23:06:33] <SingingBoyo> assuming of course the vector is large enough to have that index
[23:06:38] <xenocons> heh yeh
[23:06:45] * brson testing jemalloc on mac
[23:08:56] <strcat> bjz: glibc already uses thread-local arenas but I don't know if windows is that clever ;p, that's the big win of newer glibc and jemalloc/tcmalloc over bad allocators
[23:09:18] <strcat> allocating is essentially free of locks and atomics
[23:09:22] <strcat> for small objects
[23:10:56] <strcat> anyway going to attempt to get seccomp working in rust
[23:11:02] *** Quits: carllerche (carllerche@moz-BF6CB667.hsd1.ca.comcast.net) (Ping timeout)
[23:11:17] *** Quits: jdm (jdm@DB05BBF2.BB1F48F2.971E19F6.IP) (Quit: Lost terminal)
[23:11:44] <xenocons> well lookie here, https://github.com/killerswan/boyer-moore-search/blob/master/search.rs
[23:11:51] *** Quits: infynyxx (infynyxx@DB780A29.749BA1D.DCC373F0.IP) (Client exited)
[23:11:58] *** Joins: carllerche (carllerche@moz-BF6CB667.hsd1.ca.comcast.net)
[23:12:01] <xenocons> someones code i can plunder!
[23:12:26] *** Joins: brendan (brendaneic@E9758364.9EC0A5AF.CFE928A7.IP)
[23:12:49] <strcat> that way you can blame someone else for any bugs ;)
[23:13:09] <SingingBoyo> xenocons: just be warned, syntax changes are gonna force a lot of editing there.  that's a year old
[23:13:49] <xenocons> well, i figure ive got better chance of getting that to work than translating all these crazy while loops from the C version?
[23:14:13] <xenocons> (or maybe not?)
[23:15:19] <SingingBoyo> maybe, maybe not.  depends if the compiler errors are helpful :P
[23:15:53] <xenocons> ohwell, im learning bits i guess, thats what is most important
[23:15:58] *** Quits: dherman (dherman@2557E599.66715431.D25A875A.IP) (Quit: dherman)
[23:16:38] <strcat> bjz: http://www.canonware.com/download/jemalloc/jemalloc-latest/doc/jemalloc.html it has great docs, if you're interested - the Implementation notes section
[23:16:45] <strcat> table with the allocation sizes it rounds to, etc.
[23:17:58] <strcat> lock-free until your alloc size is over 4k
[23:20:11] *** Quits: EXetoC (ex@moz-C741B177.customer.t3.se) (Quit: WeeChat 0.4.1)
[23:21:00] *** Joins: a_m0d (a_m0d@moz-9036E0FE.home.cgocable.net)
[23:21:53] <xenocons> could i get an example of BytesReader again
[23:22:13] *** Joins: jrfeenst (jrfeenst@moz-F912484F.cpe.norwoodlight.com)
[23:22:22] <xenocons> i wont say the github about reading files is broken, im just getting errors
[23:22:39] <xenocons> (its probably outdated since last release)
[23:23:54] <xenocons> (https://github.com/mozilla/rust/wiki/Doc-reading-and-writing-files)
[23:24:42] *** Quits: SimonSapin (simon@A5049320.3E93794D.61EA6C28.IP) (Quit: Leaving.)
[23:26:00] *** Quits: \n (NDesaulnie@2557E599.66715431.D25A875A.IP) (Quit: \n)
[23:26:25] *** Joins: \n (NDesaulnie@2557E599.66715431.D25A875A.IP)
[23:26:51] *** Quits: deepdog (deepdog@moz-490E834C.client.mchsi.com) (Ping timeout)
[23:28:11] *** Joins: koomi (koomi@moz-CBF7646B.pools.arcor-ip.net)
[23:28:12] *** cscottnet is now known as cscottnet_away
[23:28:21] *** Joins: wilsonk-laptop (kvirc@moz-39EFBFC2.cg.shawcable.net)
[23:28:35] *** Joins: infynyxx (infynyxx@DB780A29.749BA1D.DCC373F0.IP)
[23:29:10] *** Quits: diegoyam (quassel@FF9B1514.A4EC3D18.3A1EC144.IP) (Ping timeout)
[23:30:17] <flu_> Is there syntax for defining (or synthesizing) properties in a trait spec?
[23:30:18] *** Quits: mzabaluev (mzabaluev@moz-91FFD755.dhcp.inet.fi) (Ping timeout)
[23:30:37] <aatch> flu_, nope
[23:30:38] <flu_> or am I stuck with getter / setters for the moment?
[23:30:51] <aatch> there won't be properties for traits
[23:31:36] <flu_> aatch: womp womp. without a good way of supporting properties, my magical crystal ball predicts getters and setters litering the Rust landscape in the future
[23:32:09] <aatch> flu_, not necessarily.
[23:32:39] *** Quits: q66 (q66@6EE9DE40.46454B5D.33AABD5F.IP) (Client exited)
[23:32:46] <flu_> aatch: could be my OO brain blinding me - how so?
[23:32:51] <xenocons> btw what is '-path' again different from 'path'?
[23:32:57] *** Joins: diegoyam (quassel@FF9B1514.A4EC3D18.3A1EC144.IP)
[23:33:01] <aatch> xenocons, old syntax
[23:33:04] <aatch> ignore it
[23:33:10] <xenocons> k
[23:33:15] <aatch> (assuming that it's a function arg)
[23:33:30] <xenocons> yeh
[23:33:48] <aatch> flu_, well getters and setters are often anti-patterns in most languages
[23:34:06] *** Quits: mschifer (Adium@2557E599.66715431.D25A875A.IP) (Quit: Leaving.)
[23:34:09] <strcat> brson: heh, I've got seccomp working from rust but it's a bit strange since I'm initializing the ruleset in something that's not the main thread
[23:34:19] <flu_> aatch: I agree, but if the syntax isn't transparent between member access and method invocation, they are bound to leak in
[23:34:21] *** Joins: jmgrosen (john@moz-848F6087.sb.sd.cox.net)
[23:34:30] <strcat> brson: so it kills the thread on a violation and the scheduler deadlocks :)
[23:34:30] *** Quits: jmgrosen (john@moz-848F6087.sb.sd.cox.net) (Connection reset by peer)
[23:34:34] *** Quits: bjz (brendanzab@B398BE78.F804C29E.D35A31DF.IP) (Quit: Leaving...)
[23:34:35] <aatch> and traits are more like interfaces than objects.
[23:35:26] <flu_> aatch: for instance, Ruby and Scala properties. The client code is simply 'fooinstance.thing', and 'thing' may or may not be a method invocation
[23:35:40] *** Joins: jmgrosen (jmgrosen@moz-848F6087.sb.sd.cox.net)
[23:35:49] <aatch> also, Rust goes more for explictness, field access is several orders of magnitute faster than a function call.
[23:35:49] *** Quits: jmgrosen (jmgrosen@moz-848F6087.sb.sd.cox.net) (Connection reset by peer)
[23:35:51] *** Joins: devbug (quassel@moz-E1DE087C.bchsia.telus.net)
[23:35:58] <flu_> makes sense
[23:36:23] <strcat> brson: ah ACT_TRAP works much better. sends SIGSYS
[23:36:33] <strcat> and rust could probably recover if it wanted
[23:36:47] <strcat> strcat@thinktank i ~/projects/rust-seccomp master % ./seccomp
[23:36:49] <strcat> zsh: invalid system call  ./seccomp
[23:36:51] <strcat> ;]
[23:36:54] <aatch> but more often than not, you'll have a concrete object that you can do field access on.
[23:37:21] *** Joins: Jesin (Jessin_@moz-48B48C95.eecs.lehigh.edu)
[23:37:56] *** Quits: true_droid (Adium@moz-123FD9B8.beck.volia.net) (Quit: Leaving.)
[23:38:31] *** Joins: jmgrosen (jmgrosen@moz-848F6087.sb.sd.cox.net)
[23:39:00] <aatch> A good example I had recently was that I had a very generic pattern where I was wrapping a C pointer and needed to be able to get the C pointer in and out of the wrapping struct. so I have a Wrapper<T> trait that has a to_ref(&self) method, and a from_ref(T) method.
[23:39:00] *** Quits: jmgrosen (jmgrosen@moz-848F6087.sb.sd.cox.net) (Connection reset by peer)
[23:39:01] *** Joins: bjz (brendanzab@B398BE78.F804C29E.D35A31DF.IP)
[23:39:35] *** Joins: ghrust (ghrust@79968228.6A2AE50.F3114085.IP)
[23:39:35] <ghrust> 01[13rust01] 15bors merged 06auto into 06incoming: 02http://git.io/OMk6VQ
[23:39:35] *** Parts: ghrust (ghrust@79968228.6A2AE50.F3114085.IP) ()
[23:40:06] <flu_> yeah
[23:40:10] <aatch> In terms of understanding, it's much easier. I can use trait bounds to say "anything that implements this trait" and call those methods, even the static ones and know I'll get what I want
[23:40:29] <strcat> ugh I guess I have to write some of this in C :(
[23:40:32] <strcat> stupid varargs
[23:41:01] <xenocons> va args :')
[23:41:22] <xenocons> evail
[23:41:25] <xenocons> evil*
[23:41:28] <flu_> this question came up as I was trying to make a generic function constrained to a trait that did some stuff, and I was thinking it would be nice to specify that implementors of a trait have property x, y, and z
[23:41:49] <flu_> super new to the language, and just working through examples btw
[23:42:01] <aatch> flu_, but the question is why? Would that function not be better as member of the trait?
[23:42:08] <aatch> Or possibly a new trait entirely?
[23:42:12] <strcat> or I could just hardcode the linux calling convention in asm
[23:42:16] <strcat> that sounds more fun!
[23:42:34] <aatch> strcat, does asm! work now?
[23:42:43] <strcat> afaik it works fine
[23:42:47] <strcat> I haven't tried it
[23:43:01] <xenocons> i noticed io.rs:241 uses \n as the end of line char, shouldnt this be taken from the environment?
[23:43:08] <strcat> then again I don't really want to deal with other archs
[23:43:29] <flu_> aatch: I was thinking that actually. Since I'm wanting to do a 'print stats' thing for my fancy monsters, I could just have the Monster trait specify a 'fn stats_str(&self) -> str' method
[23:43:38] *** Quits: tgt (tgt@moz-D59EE478.aztw.cable.virginmedia.com) (Quit: Computer has gone to sleep.)
[23:43:41] <strcat> xenocons: no
[23:43:53] <flu_> rather than trying to dig out shared properties and compose it in the generic function
[23:44:08] <aatch> flu_, why not a "Stats" trait?
[23:44:12] <strcat> \n is the end-of-line character, and if you open files in binary mode with stdio it writes \n
[23:44:16] <aatch> that you implement on everything that has stats?
[23:44:28] <strcat> if you use text mode it translates to a stupid platform specific default
[23:44:34] <xenocons> strcat: ah right
[23:44:55] <xenocons> great i need to do reporting, why wont people just let me rust
[23:45:06] <strcat> text mode is really annoying though because you often really want \n ;p
[23:45:10] <flu_> yeah, why not :-)
[23:46:04] <\n> gah I keep getting pinged for mention
[23:46:18] <xenocons> heh
[23:46:38] <aatch> \n, tis your own fault
[23:46:41] <strcat> \n: and weechat is highlighting every \n I type in your nick colour :)
[23:46:45] <xenocons> so it looks like io::read_whole_stream produces a desirable result
[23:46:48] *** Quits: snadon (chatzilla@moz-3BC727E8.mc.videotron.ca) (Ping timeout)
[23:47:13] <xenocons> am i correct in thinking that if i provide that function with a filestream (or the equivilant) it will return the entire filestream
[23:47:20] <xenocons> (as ~[u8]
[23:47:21] <xenocons> )
[23:47:24] *** Joins: dherman (dherman@2557E599.66715431.D25A875A.IP)
[23:47:24] *** ChanServ sets mode: +o dherman
[23:47:38] <xenocons> effectively reading all byte sin the file
[23:48:50] *** Quits: FrozenCow (FrozenCow@moz-B2DF4929.chello.nl) (Ping timeout)
[23:49:01] <strcat> pcwalton: what's the attribute to override a symbol name?
[23:49:08] <xenocons> very glad people are under taking io rewrite
[23:49:15] *** Quits: SingingBoyo (brandon@moz-94AE1D3A.bchsia.telus.net) (Ping timeout)
[23:49:18] <pcwalton> strcat: #[no_mangle] and name the function with the name you want
[23:49:27] <strcat> pcwalton: I mean for extern
[23:49:33] <pcwalton> strcat: #[link_name]
[23:49:33] <strcat> is there a way to give it a separate link name?
[23:50:01] <aatch> https://github.com/mozilla/rust/pull/6982 r?
[23:50:06] <strcat> pcwalton: perfect, thanks
[23:50:09] *** Quits: annodomini (lambda@moz-6424FBF8.hfc.comcastbusiness.net) (Quit: annodomini)
[23:50:30] <pcwalton> aatch: r+
[23:50:34] <aatch> ty
[23:50:37] <strcat> it doesn't seem to care that it's not getting an argument count pushed to a register like C so... hardcoding vararg calls it is ;p
[23:50:45] <strcat> since it only has to run on linux anyway...
[23:51:18] * strcat really wishes they had versions of the API without that...
[23:51:33] <Jeaye> How can I go from @mut T to @T?
[23:51:40] <pcwalton> Jeaye: you can't yet
[23:51:47] <pcwalton> transmute ;)
[23:52:20] <Jeaye> heh
[23:52:26] *** Quits: \n (NDesaulnie@2557E599.66715431.D25A875A.IP) (Ping timeout)
[23:52:41] <strcat> ugh these apis are such a pain
[23:53:00] *** Joins: graydon (graydon@moz-8B524EBD.cable.teksavvy.com)
[23:53:00] *** ChanServ sets mode: +qo graydon graydon
[23:53:27] *** Joins: \n (NDesaulnie@43CB6079.66715431.D25A875A.IP)
[23:53:28] <strcat> they take (context, action, syscall, argument_count, ...arguments)
[23:53:30] * strcat sighs ;p
[23:54:26] *** Joins: doomlord (doomlod@moz-8F385DB0.range109-153.btcentralplus.com)
[23:54:34] <Jeaye> That did the trick. Thanks, pc.
[23:54:38] *** Joins: ghrust (ghrust@FD7BC443.6A2AE50.F3114085.IP)
[23:54:38] <ghrust> 01[13rust01] 15bors pushed 0 new commits to 06auto: 02http://git.io/G6sAHw
[23:54:39] *** Parts: ghrust (ghrust@FD7BC443.6A2AE50.F3114085.IP) ()
[23:54:40] *** Joins: ghrust (ghrust@2EE61FCC.6A2AE50.F3114085.IP)
[23:54:40] <ghrust> 01[13rust01] 15bors pushed 2 new commits to 06auto: 02http://git.io/3eIVwg
[23:54:40] <ghrust> 13rust/06auto 149c8d0e3 15James Miller: Provide an actual error when expanding macros to foreign items
[23:54:40] <ghrust> 13rust/06auto 14d6b4fde 15bors: auto merge of #6982 : Aatch/rust/better-foreign-error, r=pcwalton...
[23:54:40] *** Parts: ghrust (ghrust@2EE61FCC.6A2AE50.F3114085.IP) ()
[23:54:46] <pcwalton> no problem
[23:55:18] <aatch> heh: %_x = alloca [4294967295 x i64]
[23:55:36] <strcat> ugh that's going to be a huge pain
[23:55:40] <strcat> they have no va_list version
[23:55:48] *** Quits: yardena (yardena@moz-A95F12B1.members.linode.com) (Quit: yardena)
[23:55:48] <strcat> I guess I should just hardcode up to like 20 parameters...
[23:56:03] <strcat> thanks for nothing seccomp ;p
[23:56:53] <aatch> sure, stack-allocate 32GB
[23:59:34] *** Quits: jorendorff (jorendorff@moz-B860E258.hsd1.tn.comcast.net) (Quit: jorendorff)
[23:59:38] *** Joins: dylukes (dylukes@moz-E4DF3FED.pitbpa.fios.verizon.net)
[23:59:56] <Jeaye> pcwalton: Is it UB to go from @T to @mut T if it was originally a @mut T that was transmuted in the first place?

[00:00:18] <eternaleye> And considering the way the number of entries scaled from AES to SHA-3, it'll probably have some good diversity in the ciphers proposed
[00:01:08] <eternaleye> Heck, look at the number of entries to CAESAR, and that doesn't even have a big org like NIST pushing it.
[00:25:22] *** Joins: brson (brson@moz-k2tblc.tmodns.net)
[00:35:05] <kmc> NIST may have lost some credibility in recent times ;)
[00:35:37] <eternaleye> True enough, but there's really not much else out there
[00:35:58] <eternaleye> And while it may have lost some credibility, it does still write standards that influence a lot of other things
[00:36:18] <eternaleye> Simply because losing credibility means nothing to the government procurement process, and that carries money.
[00:38:06] <eternaleye> What I _do_ think is likely (and unfortunate) is that entrants to future competitions will note the historic bias in favor of hardware-friendly designs over software-friendly ones, and the _entrants_ will be biased in that direction.
[00:39:24] <eternaleye> AES with its S-boxes, Keccak being notably slower in SW than it needed to be (giving hardware a significant advantage, which is part of why it was "no-way no-how" as a primitive for PHC entrants),  etc
[00:45:33] *** Quits: brson (brson@moz-k2tblc.tmodns.net) (Quit: leaving)
[01:13:47] <kmc> interesting
[01:13:52] <kmc> i did not know about that drawback of keccak
[01:26:31] <eternaleye> kmc: Compare it to Skein (which is incredibly efficient on Intel), or Blake2b (which is just plain a speed demon), and it's pretty evident that it hurts in software.
[01:26:47] <eternaleye> kmc: But it's quite well-suited to hardware implementation
[01:26:50] *** Joins: enix (enix@moz-0mgr2v.fios.verizon.net)
[01:27:05] <eternaleye> kmc: NIST historically is biased towards stuff amenable to hardware
[01:27:25] <eternaleye> kmc: I mean, they even claimed AES was good because "S-boxes are trivial to do in constant time"
[01:27:36] <eternaleye> kmc: ...and in hardware, that might even be true
[01:28:14] *** Quits: Tobba (Tobba@moz-o13d22.bredband.telia.com) (Ping timeout: 121 seconds)
[01:38:36] *** Joins: Tobba (Tobba@moz-o13d22.bredband.telia.com)
[02:11:36] <kmc> lol
[02:31:25] *** Joins: brson (brson@moz-k2tblc.tmodns.net)
[02:31:43] <bascule> yeah, anyone concerned with a hash function being a bottleneck in software is probably using Blake2(b)
[02:32:17] *** Joins: c74d (c74d3a4ebb6@moz-bpqgf0.mggc.hibn.4404.2002.IP)
[02:32:32] *** Quits: c74d3 (c74d3a4ebb6@moz-0ersgu.oc.cox.net) (Ping timeout: 121 seconds)
[02:33:00] <bascule> funny thing about SHA-3 is although the competition wrapped up a lifetime ago NIST is still yet to specify it o_O
[02:33:08] <bascule> and yet people are already penciling it into TLS
[02:34:06] <bascule> I guess it will be standardized eventually?
[02:42:15] <Ilari> In fact, SHA3-224 (which is the fastest of SHA-3 functions) is slower than SHA2-512 on modern CPUs.
[02:42:50] <Ilari> And SHA3-512 is pretty hilariously slow.
[02:43:59] *** Quits: brson (brson@moz-k2tblc.tmodns.net) (Quit: leaving)
[02:44:14] <eternaleye> Ilari: Isn't SHA-512 faster than SHA-256 on 64-bit?
[02:44:20] <Ilari> Yeah.
[02:51:16] <Ilari> If one is dealing with some_broken_cipher in GCM mode, would knowing the nonces fully (which lets one construct full inputs to the cipher) be helpful in breaking it?
[02:57:42] *** Quits: Tobba (Tobba@moz-o13d22.bredband.telia.com) (Ping timeout: 121 seconds)
[02:59:29] <eternaleye> Aren't nonces generally considered public anyway?
[02:59:50] <eternaleye> Ilari: Really, the problematic piece is "dealing with some_broken_cipher in GCM mode"
[02:59:57] <eternaleye> Ilari: For which the answer is "Don't."
[03:00:34] <eternaleye> Ilari: It's a classic "Doctor, it hurts when I X" situation
[03:02:14] <bascule> https://lists.w3.org/Archives/Public/public-privacy/2014OctDec/0058.html
[03:03:47] <Ilari> Well, don't use GCM. Got it. And are you assuming you know the cipher is broken?
[03:05:42] <Ilari> And as RC4 has shown, people will run plenty of broken ciphers.
[03:05:53] <eternaleye> Ilari: What I'm saying is that you've got your parameters a bit reversed in the question.
[03:06:46] <eternaleye> Ilari: The standard definition of nonces is that they are public; the question reverses that, which obscures the core a bit
[03:07:07] <eternaleye> Ilari: In addition, presuming it's broken is also a bit backwards
[03:07:58] <eternaleye> Ilari: I'd have phrased it that given a block cipher operating in GCM mode, how much does hiding the nonces raise the lower bound to break the block cipher?
[03:08:09] <eternaleye> Ilari: Er, break the construction.
[03:08:49] <eternaleye> Ilari: It's clearly giving the attacker less power than CCA2, but by how much?
[03:12:12] <Ilari> Actually, probably depends on the way the cipher is weak. If it is some differential attack, probably isn't going to do anything. If it is some linearization-type attack, very useful for breaking.
[03:27:41] *** Joins: brson (brson@moz-sn7.c9m.56.172.IP)
[03:30:21] *** Joins: gsingh93 (gulshan@moz-3fu4am.mi.comcast.net)
[03:49:39] <eternaleye> bascule: That guy keeps getting less sensible with each post...
[03:49:49] <eternaleye> >> Giving the gewgaws, like ad services, a better/cheaper way of doing things, would reduce the invalid-cert popup issue -- the Doom of the Web. (Film at 11.)
[03:50:12] <eternaleye> bascule: (him arguing why http is better _because_ it can be mitm'ed)
[03:50:21] <eternaleye> bascule: W. T. F'ing. F.
[03:51:01] *** Quits: c74d (c74d3a4ebb6@moz-bpqgf0.mggc.hibn.4404.2002.IP) (Ping timeout: 121 seconds)
[03:51:02] <eternaleye> >> The thing about HTTP Digest, is the user-agent _can_ authenticate the server if the login is via TLS; subsequent communications can then use HTTP and caching -- even for authenticated users, even with content personalization
[03:51:09] *** Joins: c74d3 (c74d3a4ebb6@moz-0ersgu.oc.cox.net)
[03:51:30] <eternaleye> And he seems to think that authenticating the server on one connection means that connecting unencrypted guarantees the same server MAGICALLY somehow
[03:52:20] <eternaleye> And he argued that it's "trivial" to "just not show a login box" if the page content has been changed
[03:52:26] <eternaleye> This guy's a fucking idiot.
[03:52:55] <eternaleye> I swear he doesn't even comprehend that HTTP is a _stateless goddamn protocol_
[03:52:58] <Ilari> To get _any_ additional guarantees from digest (besides recovering password being a dictionary attack, instead of straight out reading the password), you would need to use auth-int. Which pretty much nothing supports.
[03:55:58] <Ilari> If one has HTTPS, at least one can use channel bindings (which AFAIK digest does not support).
[03:57:57] *** Joins: Tobba (Tobba@moz-o13d22.bredband.telia.com)
[05:46:15] *** Quits: BigE (BigE@moz-4gk6rj.torservers.net) (Connection closed)
[06:22:50] *** Quits: enix (enix@moz-0mgr2v.fios.verizon.net) (Ping timeout: 121 seconds)
[06:44:37] <eternaleye> Oh this is seriously cool: http://csg.csail.mit.edu/pubs/memos/Memo-513/memo513.pdf
[06:45:06] <eternaleye> I love it when high-theory crypto and deep-knowledge system design have cool hybridizations
[06:45:25] <eternaleye> (An efficient, scalable-to-large-sizes ORAM controller on chip_
[06:46:04] <eternaleye> (By leveraging techniques that seem to be ORAM equivalents of the traditional page-table/TLB system)
[06:47:19] <eternaleye> ..._and_ it's open source. http://kwonalbert.github.io/oram
[07:18:35] *** Quits: brson (brson@moz-sn7.c9m.56.172.IP) (Quit: leaving)
[07:45:37] *** Quits: gsingh93 (gulshan@moz-3fu4am.mi.comcast.net) (Ping timeout: 121 seconds)
[07:54:34] *** Joins: BigE (BigE@moz-1jo0ne.badexample.net)
[08:15:51] *** Joins: enix (enix@moz-0mgr2v.fios.verizon.net)
[11:58:14] *** Joins: gleb (gleb@moz-3u1drv.rusanovka-net.kiev.ua)
[13:08:44] *** Quits: tiffany (lymia@moz-6q5ofr.lyrical.lymia.moe) (Quit: ZNC - http://znc.in)
[13:09:33] *** Joins: tiffany (lymia@moz-6q5ofr.lyrical.lymia.moe)
[14:43:48] <kmc> wtf is an ORAM
[14:43:54] <kmc> i like how they completely avoid defining this term
[14:45:13] <kmc> ah, the memo defines it
[15:04:56] <Ilari> Lol... "Cloud".
[15:17:01] *** Quits: enix (enix@moz-0mgr2v.fios.verizon.net) (Ping timeout: 121 seconds)
[16:01:01] *** Joins: pitdicker (pitdicker@moz-328u1s.adsl.online.nl)
[16:05:01] *** Quits: pitdicker (pitdicker@moz-328u1s.adsl.online.nl) (Quit: Ik ga weg)
[17:05:09] *** Joins: brson (brson@moz-8u1.c9m.56.172.IP)
[17:16:12] <eternaleye> Ilari: I do think that "Cloud" is an overused and misused term in ORAM papers
[17:16:41] <eternaleye> Ilari: It's not actually useful for "cloud" as people think of it (OpenStack-type stuff), because in virtualization they could instrument inside the processor anyway
[17:16:49] <eternaleye> Ilari: It may, however, be very useful for colo
[17:17:44] <eternaleye> kmc: Well, ORAM (oblivious RAM) is an entire area of research, so it does kind of tend to be assumed that people reading an ORAM paper know the vague generalities
[17:17:55] <eternaleye> kmc: Which is annoying but understandable
[17:24:14] <Ilari> Well, in general "Cloud" is an overused and misued term. :->
[17:25:23] <eternaleye> I'm not going to disagree
[17:25:48] <tiffany> does cloud even mean anything at all anymore
[17:26:00] <eternaleye> I mean, the whole term derives from the practice of using a cloud to denote "We don't know what this is, but it does things" in network diagrams
[17:26:16] <tiffany> wow
[17:26:20] <tiffany> I never made that connection
[17:26:35] <eternaleye> Yuuuup
[17:26:44] <cmr> I like the definition in http://www.eecs.berkeley.edu/Pubs/TechRpts/2009/EECS-2009-28.pdf
[17:26:45] <tiffany> that makes it so much worse
[17:27:40] <eternaleye> cmr: Yeah, that is a much more useful definition
[17:27:56] <eternaleye> cmr: Sadly, people don't use the word in a way consistent with that definition
[17:28:09] <cmr> yeah
[17:28:14] *** Quits: tiffany (lymia@moz-6q5ofr.lyrical.lymia.moe) (Quit: ZNC - http://znc.in)
[17:28:32] <eternaleye> cmr: For instance, the ORAM papers that say it's useful for "cloud computing" presume the additional constraint that the provider can't instrument the operation of things within the SoC
[17:29:02] <eternaleye> cmr: But since it abstracts over resources, any of those systems MIGHT be a VM, and thus that can't be guaranteed.
[17:29:28] <eternaleye> cmr: Though for colocation (where you provide the machine, but can't enforce physical access security) the point stands.
[17:29:55] <eternaleye> cmr: The Google Fiber colocation stuff is a good example of where that'd be very relevant
[17:30:29] *** Joins: tiffany (lymia@moz-6q5ofr.lyrical.lymia.moe)
[17:31:22] <eternaleye> cmr: Another good example: stuff like SGX
[17:32:03] <eternaleye> cmr: If a "secure environment" within a computer, like SGX or TrustZone, uses ORAM, then that could provide some very real benefits
[17:32:33] *** Quits: tiffany (lymia@moz-6q5ofr.lyrical.lymia.moe) (Quit: ZNC - http://znc.in)
[17:33:54] *** Joins: tiffany (lymia@moz-6q5ofr.lyrical.lymia.moe)
[17:45:15] <Ilari> "The number of infected hosts out there is just astounding. [...]" "Dont' worry, it will calm down as the InternetOfThings takes off... :-S". :->
[17:47:21] <Tobba> if it wasn't for that IoT devices are so diverse I'd expect another blaster to happen due to how exploitable they are
[17:48:02] <Tobba> then again any IoT device that runs Linux will magically stop responding after you plug ';reboot into every available field
[17:50:55] <Tobba> if that doesn't work try, ../../../../../../etc/shadow, a few minutes of hashcat and SSH (that happened)
[17:53:49] <eternaleye> Tobba: That's actually one of the reasons that in the FS protocol I'm working on for my cap-OS, there is no ..
[17:54:12] <eternaleye> Tobba: You can only traverse downwards, much like Rust's iterator - if you want to rewind, clone before you start
[17:54:21] <Tobba> heh, my FS interface is the same
[17:54:27] <Tobba> but mostly for isolation for reasons
[17:54:33] <eternaleye> Yup
[17:54:37] <Tobba> for isolation reasons*
[17:55:16] <eternaleye> The more I work on this stuff, the more I realize that POSIX is almost aggressively anti-containment
[17:55:33] <Tobba> thats one of the reasons I really don't like POSIX
[17:56:29] <Tobba> everything is too global, nothing is contained and everything is coupled too tightly
[17:56:34] <eternaleye> Another thing I'm doing is leaving out . entirely, because a componentwise capability API has no need for it
[17:57:04] <Tobba> I really don't know why that was a thing in the first place
[17:57:26] <Tobba> both . and .. are incredibly redundant and cause lots of problems - especially if they exist on disk (just, why)
[17:57:45] <eternaleye> Tobba: /foo/bar may be a dir or a file, /foo/bar/ is a dir but has some odd semantics in various cases, /foo/bar/. is a dir, and behaves like /foo/bar
[17:58:20] <eternaleye> Tobba: Though I agree that them existing on disk is silly even so
[17:58:31] <eternaleye> Tobba: But for an example where it matters, see rsync
[17:58:40] <Tobba> seems like a bit of a hack, but even then, they shouldn't actually be on the dislk
[17:58:41] <Tobba> disk*
[17:58:44] <eternaleye> Tobba: Another use case is grabbing a whole dir, but eliding the dir name
[17:59:01] <eternaleye> Tobba: Which is unsafe with globs, because of ..
[17:59:15] <eternaleye> Tobba: So in a sense, .. requires .
[17:59:48] <Tobba> fun
[17:59:49] <eternaleye> Tobba: If you have neither, then globs are safe for that use case
[18:00:21] <Tobba> oh and the way POSIX handles expanding *
[18:00:34] <eternaleye> Dotfiles in general.
[18:01:11] <eternaleye> I mean, they're pretty much the prototypical example of "A bug people relied on and thus became ABI"
[18:01:40] *** Quits: brson (brson@moz-8u1.c9m.56.172.IP) (Quit: leaving)
[18:02:55] <eternaleye> https://plus.google.com/u/0/+RobPikeTheHuman/posts/R58WgWwN9jp
[18:03:33] *** Joins: geofft (geofft@moz-vfphq1.mit.edu)
[18:04:36] <cmr> I also consider separation of dirs and files an annoyance. My FS only has "entity" and it can have byte contents and children.
[18:05:29] <eternaleye> cmr: Sounds like hierarchical resource forks :P
[18:05:36] <eternaleye> cmr: But yeah, I agree.
[18:06:03] <Tobba> I haven't thought about that
[18:06:14] <Tobba> but it makes a lot of sense
[18:06:18] <cmr> it's *really nice* for config and packing executables with resources.
[18:06:23] <eternaleye> Tobba: It's quite useful for layered translation filesystems too
[18:06:37] <eternaleye> Like, mounting a zip-translator on top of a native FS
[18:06:42] <cmr> I understand OS X does something similar with it's .app? And I know NTFS has that capability.
[18:06:51] <eternaleye> cmr: .app is just a directory
[18:07:05] <Tobba> eternaleye: hm, my capability-based design can't support that fully :(
[18:07:07] <eternaleye> cmr: It just gets treated specially by the OS X gui libs and tools
[18:07:10] <cmr> ah
[18:07:10] <Tobba> but you could "mount" zip file
[18:07:21] <eternaleye> Tobba: It should be able to...
[18:07:40] <eternaleye> Tobba: It just interposes capabilities, and if the underlying data is a zip, provide a dir-like API...
[18:08:00] <eternaleye> Tobba: I'll note that my VFS has no "mount"
[18:08:17] <Tobba> eternaleye: yeah I can create a directory object which has the contents of the zip file, but I can't really trick other things into that the file contains that
[18:08:20] <cmr> I had to give up on that FS because I'm not actually writing a FS and FUSE can't do it (neither can the linux vfs, due to stat etc)
[18:08:21] <eternaleye> Tobba: It has constructors for filesystems, some of which take a blockdev, some of which take another FS, whatever.
[18:08:24] <Tobba> it's just a separate directory on a different "filesystem"
[18:08:49] <eternaleye> Tobba: So the zip translator is instantiated with the lower FS as the parameter, and then proxies or rewrites calls.
[18:09:12] <eternaleye> Tobba: So you don't mount a zip translator over a file
[18:09:39] <eternaleye> Tobba: You create a zip translator over a tree, and when you encounter a zip it acts as though it had children corresponding to the contents
[18:09:54] <Tobba> I guess I could do that
[18:09:59] <eternaleye> Tobba: Think of it more like iterator map, than anything else
[18:10:28] <Tobba> but for most cases I can actually just have the zip translator host a directory
[18:10:37] <Tobba> and pass that directory around like any other directory
[18:10:41] <eternaleye> cmr: I'm not sure that's true (the the VFS can't do it)
[18:10:58] <eternaleye> cmr: For example, Ceph allows 'cat' on directories (which returns a page of stats)
[18:11:04] <eternaleye> *that the
[18:11:45] <Tobba> so copying the files out of a zip could be done by doing "cp `zipfs foo.zip` ."
[18:12:10] <eternaleye> Tobba: That's basically what I meant
[18:12:23] <Tobba> I assumed so
[18:12:28] <eternaleye> Tobba: Since with a componentwise traversal API, any subelement of the FS offers the same API as the FS
[18:12:46] <eternaleye> Tobba: And an FS constructor returns a "root directory" rather than mutating its arguments
[18:13:54] <eternaleye> Tobba: So your example is like option.iter().map(), since in that case the 'zip' is a single item
[18:14:19] <Tobba> well, you talked about sitting ontop of the FS and turning zip files into directories, this is just a File -> Directory transform
[18:14:20] <Tobba> yeah
[18:14:25] <eternaleye> Tobba: (and if it's not a zip, then zipfs will no-op)
[18:14:36] <eternaleye> Tobba: It's a special case of what I meant, and doesn't actually simplify much
[18:15:15] <Tobba> I don't like having to sit inbetween interfaces, it'll just cause me a lot of problems
[18:15:37] <eternaleye> Tobba: Basically, with what I meant, you have zipfs(dirtree) -> dirtree. On access to something that doesn't have zip magic, it passes access through (with a zipfs interposer); if it does, it provides a directory interface to the zip
[18:15:45] <eternaleye> Tobba: That's a core technique for capabilities.
[18:15:55] <eternaleye> Tobba: It's the only way to implement revocation, for example.
[18:16:07] <eternaleye> Tobba: Interposition is _fundamental_ for capability designs.
[18:16:23] <Tobba> yeah I do use interposition, but not like that
[18:16:39] <Tobba> it has the potential to cause problems with extension interfaces
[18:16:48] <eternaleye> Tobba: So does a mount-like API
[18:17:00] <eternaleye> Tobba: That's just interposition inside the interface, rather than on top of it
[18:17:06] <eternaleye> Tobba: See union file systems
[18:17:22] <eternaleye> Tobba: The solution is namespacing, really
[18:18:17] <eternaleye> Tobba: And if a file can be both a file and a directory (has both contents and children), then your proposed system is exactly equivalent to what I suggest anyway
[18:18:30] <eternaleye> Tobba: As an example, tar archives ignore trailing garbage
[18:18:41] <eternaleye> Tobba: And there are other formats that ignore _leading_ garbage
[18:18:54] <eternaleye> Tobba: What happens if you apply one translator and the other?
[18:19:07] <eternaleye> Tobba: The children collide, despite not doing a "full" translation interposer
[18:20:04] <Tobba> uh, they shouldn't be equivalent
[18:20:42] <eternaleye> Tobba: If something can have contents and children, then using the contents to populate children will shadow potentially preexisting children.
[18:21:10] <eternaleye> Tobba: Which is the same issue as you object to in my more "full" interposition
[18:21:49] <Tobba> in my case all it does is interpret the zipped data as a completely separate directory, ignoring all children
[18:22:04] <eternaleye> Tobba: yes, and that's problematic in similar ways.
[18:22:15] <eternaleye> Tobba: Namespacing (of the children) solves that.
[18:22:29] <eternaleye> Tobba: $fsname/...children...
[18:22:39] <eternaleye> Tobba: So zipfs has a diirectory in the direct children, etc.
[18:23:47] <Tobba> my approach is pretty much that
[18:24:11] <eternaleye> Tobba: Um, no?
[18:24:31] <eternaleye> Tobba: Because unless it passes through preexisting children, other things break
[18:24:52] <eternaleye> Tobba: And if it does, then it's indistinguishable from tree-based, rather than file-based, translation
[18:27:43] <Tobba> I don't see what you're on about, you're looking at the contents of a zip data stream inside of some file, you don't care about the children that file has
[18:29:58] <mcpherrin> .6
[18:31:58] <eternaleye> Tobba: For zip? Perhaps. But there are other cases, such as executables - where it may have a translator exposing its internal resources, and you want to check the owning UID (presuming the underlying FS has such a thing, or it may be a user-set child for the security arch they layered on top, etc)
[18:34:48] <Tobba> check the UID on the underlying file then? my design doesn't try to create a version of the FS that looks slightly different
[18:44:05] <bascule> sodiumoxide doesn't compile on the latest beta :(
[18:45:07] <bascule> eternaleye: re: ORAM and modified CPUs, PrivateCore's argument is modifying a modern Intel CPU is hard ;)
[18:45:28] <bascule> not a perfect argument, but their goal was to reduce the "trusted surface" of a system down to the CPU and chipset
[18:48:21] <eternaleye> bascule: Well, there's a reason Phantom was built using RISC-V, not Intel...
[18:49:22] *** c74d3 is now known as c74d
[18:49:28] <eternaleye> bascule: This kind of stuff is exactly what RISC-V, as an open ISA with multiple open implementations, is intended to make feasible
[18:51:20] *** Joins: gsingh93 (gulshan@moz-3fu4am.mi.comcast.net)
[18:55:55] <bascule> http://ipfs.io/
[18:55:56] <bascule> heh
[18:56:05] <bascule> that's... kind of like what I want to do with the Cryptosphere
[18:56:06] <bascule> but
[18:56:11] <bascule> it looks a lot more like Bittorrent Maelstrom
[19:00:23] *** Quits: gleb (gleb@moz-3u1drv.rusanovka-net.kiev.ua) (Ping timeout: 121 seconds)
[19:05:09] <Ilari> Also, modern CPUs have enormous amount of crap that causes security issues.
[19:07:25] <bascule> heh
[19:11:03] *** Joins: gleb (gleb@moz-3u1drv.rusanovka-net.kiev.ua)
[19:12:00] <Ilari> Trusted CPU, RAM, BIOS and OS? Not enough.
[19:12:59] <bascule> PrivateCore doesn't require you trust the RAM
[19:14:03] <bascule> It does require you trust the CPU
[19:14:08] <bascule> and the chipset
[19:14:10] <bascule> not the BIOS
[19:14:33] <bascule> the VMs boot encrypted and have an attestation protocol to detect tampering
[19:14:48] <bascule> but someone inside your CPU could still see what's going on
[19:14:50] <bascule> c'est la vie
[19:17:54] *** Quits: gleb (gleb@moz-3u1drv.rusanovka-net.kiev.ua) (A TLS packet with unexpected length was received.)
[19:20:36] *** Joins: gleb (gleb@moz-3u1drv.rusanovka-net.kiev.ua)
[19:23:28] <Ilari> bascule: Well, crypto code not compiling on beta isn't surprising.
[19:25:08] <bascule> hahaha
[19:25:15] <bascule> yeah, volatile_set_memory is one of the problems
[19:25:17] <bascule> except
[19:25:24] <bascule> libsodium has a C function that does the exact same thing
[19:25:25] <bascule> soooo
[19:25:46] <Ilari> (I hope that C function actually works).
[19:27:01] <bascule> https://github.com/jedisct1/libsodium/blob/master/src/libsodium/sodium/utils.c#L58
[19:37:42] <bascule> oh hey dnaq responded
[19:37:45] <bascule> I think he's going to fix it
[19:39:04] <Ilari> memset_s can fail?
[19:40:25] <bascule> haha, apparently!
[19:40:59] <bascule> oh, argument errors
[19:45:53] <Ilari> Some crazy MS function just copied?
[19:47:46] <bascule> ?
[19:47:51] <bascule> SecureZeroMemory?
[19:50:52] <Ilari> I really wonder why memset_s has two length parameters?
[19:52:54] <bascule> hahaha
[19:53:04] <bascule> because that's the Zen of C?
[19:53:35] <bascule> we need more length parameters everywhere, any one of which you miscalculate and your computer explodes
[19:55:51] *** Joins: brson (brson@moz-ppb.c9m.56.172.IP)
[20:18:23] <Dcoder> SecureZeroMemory is essentially the #else block wrapped in a macro
[20:20:19] <bascule> woohoo, one 1.0-beta incompatibility fixed in libsodium
[20:20:40] <bascule> oh ho
[20:20:42] <bascule> it compiles
[20:20:46] <bascule> now it's my code that's broken, lol
[21:51:20] *** Quits: gsingh93 (gulshan@moz-3fu4am.mi.comcast.net) (Ping timeout: 121 seconds)
[22:35:54] *** Quits: gleb (gleb@moz-3u1drv.rusanovka-net.kiev.ua) (Ping timeout: 121 seconds)
[22:47:22] *** Joins: gsingh93 (gulshan@moz-3fu4am.mi.comcast.net)
[23:08:37] *** Quits: BigE (BigE@moz-1jo0ne.badexample.net) (Quit: Leaving)
[23:18:11] *** Joins: BigE (BigE@moz-4lmh4m.privacyfoundation.ch)

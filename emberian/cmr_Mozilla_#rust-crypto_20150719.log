[00:27:09] *** Joins: dpc (dpc@moz-t6gr4b.ca.comcast.net)
[00:43:37] <frewsxcv> https://github.com/alex/rust-asn1
[00:46:55] <Tiffany> oh nice
[00:47:57] <Tiffany> only supports writing at the moment though?
[00:59:23] *** Quits: mcpherrin (mcpherrin@moz-clk6gh.ca.comcast.net) (Quit: Changing server)
[00:59:24] *** Joins: mcpherrin (mcpherrin@moz-bhcp6n.8mb6.t84e.0645.2601.IP)
[01:00:06] *** Quits: mcpherrin (mcpherrin@moz-bhcp6n.8mb6.t84e.0645.2601.IP) (Quit: Changing server)
[01:05:29] *** Joins: mcpherrin (mcpherrin@moz-clk6gh.ca.comcast.net)
[01:06:56] *** Quits: mcpherrin (mcpherrin@moz-clk6gh.ca.comcast.net) (Quit: leaving)
[01:07:15] <Ilari> ASN.1 gets more fun if one is to support things like application or context-sensitive tags.
[01:07:19] *** Joins: mcpherrin (mcpherrin@moz-bhcp6n.8mb6.t84e.0645.2601.IP)
[01:10:35] <Ilari> IIRC, there are ways to create ASN.1 that has to have scheme known to even parse the types correctly.
[01:20:11] *** Quits: brson (brson@moz-f0v.335.39.84.IP) (Ping timeout: 121 seconds)
[01:22:20] *** Joins: brson (brson@moz-cfhap5.mtv2.mozilla.com)
[01:47:46] <Ilari> Heh, "Additionally, if you ever need a security fix extension (:vomit:), [...]"
[01:53:14] *** Quits: dcb (textual@moz-v6l3du.ca.comcast.net) (Quit: My Mac has gone to sleep. ZZZzzz…)
[02:26:10] *** Quits: brson (brson@moz-cfhap5.mtv2.mozilla.com) (Quit: leaving)
[02:27:02] *** Joins: _neal_ (neal@moz-of66u9.ca.comcast.net)
[02:28:20] *** Joins: dcb (textual@moz-v6l3du.ca.comcast.net)
[02:36:14] <Ilari> Also, allegedly the worst ASN.1 in the whole world: Goverment smartcard interoperability spec. Peter rates it even worse than his designed to be pathological ASN.1 for april fools joke.
[02:36:25] <Elaine> lol
[02:36:30] *** Quits: _neal_ (neal@moz-of66u9.ca.comcast.net) (Quit: My Mac has gone to sleep. ZZZzzz…)
[02:40:35] <Ilari> Probably good ways to make some really bad ASN.1: Gratulous tagging combined with contex-specific types.
[03:06:04] *** Quits: dcb (textual@moz-v6l3du.ca.comcast.net) (Quit: My Mac has gone to sleep. ZZZzzz…)
[03:06:27] *** Joins: dcb (textual@moz-v6l3du.ca.comcast.net)
[03:27:59] *** Joins: atomic (atomic@moz-388gu4.ip-37-187-129.eu)
[04:15:52] *** Quits: dcb (textual@moz-v6l3du.ca.comcast.net) (Quit: My Mac has gone to sleep. ZZZzzz…)
[04:20:23] *** Joins: dcb (textual@moz-v6l3du.ca.comcast.net)
[04:22:09] *** Joins: _neal_ (neal@moz-of66u9.ca.comcast.net)
[04:25:07] *** Quits: _neal_ (neal@moz-of66u9.ca.comcast.net) (Quit: My Mac has gone to sleep. ZZZzzz…)
[06:13:33] *** Quits: dpc (dpc@moz-t6gr4b.ca.comcast.net) (Ping timeout: 121 seconds)
[06:22:03] *** Joins: tomlikestorock (tomlikestor@moz-i312q9.ca.comcast.net)
[07:44:45] *** Quits: dcb (textual@moz-v6l3du.ca.comcast.net) (Quit: My Mac has gone to sleep. ZZZzzz…)
[07:51:33] *** Joins: dcb (textual@moz-v6l3du.ca.comcast.net)
[08:11:14] *** Quits: dcb (textual@moz-v6l3du.ca.comcast.net) (Quit: My Mac has gone to sleep. ZZZzzz…)
[09:35:25] *** Joins: gleb (gleb@moz-3u1drv.rusanovka-net.kiev.ua)
[09:56:42] *** Quits: tomlikestorock (tomlikestor@moz-i312q9.ca.comcast.net) (Client exited)
[10:52:23] <kmc> haha, I finally understand why there's a relative dearth of information about how to design block ciphers
[10:52:29] <kmc> hint: it's not ULTRA MILITARY SECRETS
[11:08:22] <eternaleye> kmc: Isn't it basically "Avoid the known attacks" ?
[11:08:34] <eternaleye> kmc: Like, don't be linear, etc?
[11:10:02] <kmc> hmm
[11:10:04] <kmc> tell me more
[11:10:37] <kmc> 13 Ways You Could Have Invented Differential Cryptanalysis (Including Five the NSA doesn't WANT you to know!)
[11:10:52] <kmc> I know the secret of the thermionic valve, but I'm not telling.
[11:10:56] <eternaleye> kmc: No, not what I mean
[11:11:39] <eternaleye> kmc: I mean choosing your building blocks so as to dodge the bullets _everyone_ will fire at $your_knew_cipher
[11:12:56] <eternaleye> kmc: So for instance, AES uses S-boxes because they're not linear. Salsa/ChaCha, while not a block cipher, uses addition for similar reasons.
[11:15:58] <eternaleye> kmc: That's in order to counter https://en.wikipedia.org/wiki/Linear_cryptanalysis
[11:16:25] <eternaleye> kmc: Building a cipher, from that point of view, looks like an exercise in constraint-fitting
[11:17:25] <eternaleye> kmc: There are constraints you may not know, whether because they're undiscovered or because they're secret, but there's not much to do about that
[11:19:49] <eternaleye> kmc: Thus, the main constraint on someone being able to implement a block cipher is their understanding of the different attacks that can be brought to bear
[11:21:30] <eternaleye> kmc: And those are pretty well documented - https://www.schneier.com/paper-self-study.pdf and https://class.coursera.org/crypto-preview/lecture for example
[11:23:11] <eternaleye> kmc: The first one is a bit old, but very solid indeed
[11:32:09] <kmc> oh, I know how to dodge bullets
[11:32:12] <kmc> that's really easy now
[11:32:14] <kmc> thanks
[11:35:06] <kmc> I mean it's harder depending on what kind of turf you're on
[11:35:11] <kmc> but it's really not that hard
[11:35:31] <kmc> to protect a small number of humans from a large amount of heavy artillery and anti-personnel fire
[11:35:36] <kmc> in a mobile capacity
[11:35:42] <kmc> I think I could do this with about 4 pick-up trucks
[11:43:35] <eternaleye> Anyway, the tl;dr is that in my opinion, the lack of "how to design a block cipher" info is because "how to design a block cipher" is "1.) Learn what makes block ciphers vulnerable to known cryptanalysis techniques 2.) Don't do that."
[11:45:11] <eternaleye> And if you want a simpler starting point, you use something like a Feistel network, which has well-understood properties
[11:52:07] <eternaleye> Another option is to take the Even-Mansour cipher and try to develop a pseudorandom permutation for the middle
[12:41:59] <Ilari> Wasn't there discovery that differential probabilities of ARX ciphers were not what those were thought to be (turned out to be lower) and that how the building blocks are wired has large effect on differential probabilties?
[12:52:22] *** Quits: gleb (gleb@moz-3u1drv.rusanovka-net.kiev.ua) (Ping timeout: 121 seconds)
[13:12:32] <Tiffany> wtf
[13:12:39] <Tiffany> the tracfone website has https, but it redirects to http
[14:43:40] *** Joins: _neal_ (neal@moz-of66u9.ca.comcast.net)
[14:51:22] *** Quits: _neal_ (neal@moz-of66u9.ca.comcast.net) (Quit: My Mac has gone to sleep. ZZZzzz…)
[15:06:13] *** Joins: _neal_ (neal@moz-of66u9.ca.comcast.net)
[16:01:51] *** Joins: gleb (gleb@moz-3u1drv.rusanovka-net.kiev.ua)
[16:29:54] *** Quits: _neal_ (neal@moz-of66u9.ca.comcast.net) (Quit: My Mac has gone to sleep. ZZZzzz…)
[16:55:57] <Ilari> Tiffany: Similar things have been seen before. Including version that redirects to HTTP after logging in (which is insecure, as demonstrated in no uncertain terms by Firesheep).
[17:05:07] *** Joins: dcb (textual@moz-v6l3du.ca.comcast.net)
[17:12:49] <Ilari> Wonder how many websites would be broken (of course, those are insecure already) if every cookie set on https:// had secure attribute forced on.
[17:26:30] <Ilari> Or if cookies for http and https were fully decoupled (HTTP can't set cookies for HTTPS, HTTPS can't set cookies for HTTP).
[17:28:26] <Ilari> Probably annoying for services: Restriction to first-party cookies only for HTTP.
[17:37:06] <mcpherrin> Ilari: You could try an https-everywhere style addon to force secure attribute
[17:38:13] <Ilari> mcpherrin: Well, this is more in general, not just for some advanced users.
[17:41:42] <mcpherrin> Ilari: Well, you'd want to gather data and find how many places break
[17:41:50] <mcpherrin> it's an interesting idea
[17:46:44] <Ilari> mcpherrin: Well, I can't collect that data myself (due to heavily skewed settings and usage patterns).
[17:48:57] <Ilari> Then there are environments where HTTPS is virtually impossible to use. But these shouldn't have third-party resources at all (or if there are, those could likely be over HTTPS).
[17:53:51] <Ilari> Additionally, one stumbling block for sites to migrate to HTTPS has been quoted to be ads. Disabling TPC would push those provoders to migrate to HTTPS.
[17:53:57] <bascule> Ilari: I wish cookies followed the same origin policy :(
[17:54:37] <Ilari> Yeah. That would be helpful.
[17:55:30] <Tiffany> restricting to first-party cookies breaks both tracking like google analytics and single-sign on
[17:55:34] <Tiffany> at least, I think it breaks SSO
[17:56:11] <Elaine> I don't think it breaks SSO?
[17:56:22] <Elaine> breaking analytics though, what a shame... :P
[17:56:37] <Ilari> I read "analytics" as "spying". :->
[18:00:56] <Tiffany> how does SSO work elaine?
[18:01:04] <Tiffany> I thought it used a third party cookie to store a session token
[18:01:51] <Elaine> maybe some do, but you should be able to do oauth without that.
[18:02:38] <Elaine> (lol oauth though)
[18:03:13] <Tiffany> what's wrong with oauth?
[18:03:46] <Elaine> it's incredibly overcomplicated and challenging to implement correctly (if it's even possible anymore)
[18:03:50] <Elaine> some configurations are not secure.
[18:04:05] <Elaine> it's not interoperable
[18:04:06] <Tiffany> is it possible to compare oauth to kerberos?
[18:04:26] <Tiffany> honestly my only experience with oauth is writing a twitter client
[18:04:37] <Tiffany> and I used an existing library for that
[18:04:54] <Elaine> I think you can actually implement oauth over kerberos.
[18:05:16] <Tiffany> also, is there anything on the web for which some configurations are not secure?
[18:05:22] <Tiffany> er
[18:05:28] <Tiffany> I got that inverted
[18:05:53] <Tiffany> is there anything on the web which has no insecure configurations?
[18:06:05] <Elaine> not to my knowledge :P
[18:06:13] <bascule> PHC announcement tomorrow
[18:06:19] <bascule> I will now accept your guesses
[18:06:22] <bascule> and offer no reaction
[18:06:23] <bascule> lol
[18:06:41] <Elaine> bascule: I think makwa is super interesting.
[18:06:53] <Elaine> yescrypt seems like a reasonable choice, but holy shit grab-bag of features
[18:08:25] <Elaine> all the stuff not by Steve Thomas is pretty strong.
[18:12:41] <Tiffany> password hashing competition?
[18:13:00] <Elaine> yeah, https://password-hashing.net/
[18:15:35] <Ilari> Elaine: OAuth1 is interoperable between two correct implementations (but many implementations are wrong). OAuth2 just isn't interoperable.
[18:15:47] <Tiffany> I figured it was like that
[18:15:53] <bascule> OAuth :(
[18:16:16] <Tiffany> I used OAuth1 when I wrote my twitter app, and that library I used worked with multiple services, but had some service-specific hacks for a couple broken implementations
[18:16:28] <Tiffany> and then OAuth2 is just ditching any wire semantics? or what
[18:16:41] <Tiffany> er, on-wire representation
[18:16:45] <Ilari> Basically there are many different variants of OAuth2, and those variants are not interoperable.
[18:16:48] <Elaine> Ilari: what services haven't migrated to oauth1 yet, though?
[18:17:00] <bascule> yeah, OAuth2 bearer tokens are opaque
[18:17:18] <Elaine> public internet services, I mean, not private stuff.
[18:17:46] * bascule wants OAuth to DIAF
[18:17:49] * Elaine too
[18:18:03] <Tiffany> what should it be replaced with? kerberos?
[18:18:29] <bascule> Macaroons! :o
[18:19:08] <bascule> unfortunately the critical pieces for using Macaroons in federated contexts aren't really in place yet :(
[18:19:47] <Elaine> Tiffany: Kerberos requires a trusted central server.
[18:20:01] <Tiffany> doesn't OAuth too?
[18:20:03] <Elaine> no
[18:20:17] <bascule>  Kerberos is based on symmetric key cryptography
[18:20:37] <bascule> and so, presently, are Macaroons, although the original designers wanted to support public key for federation
[18:20:38] <Tiffany> yeah, I know the Kerberos server has to hold all the keys
[18:20:59] <bascule> it'd be super easy to add from a purely technical point of view
[18:21:21] <bascule> it's more just getting everyone to agree on the wire format and how keys are authenticated
[18:22:51] <bascule> https://air.mozilla.org/macaroons-cookies-with-contextual-caveats-for-decentralized-authorization-in-the-cloud/
[18:23:11] <Tiffany> I've been reading the readme from https://github.com/rescrv/libmacaroons
[18:24:33] <Tiffany> they sound nice
[18:24:38] <Tiffany> although the comparisons to cookies are confusing
[18:24:48] <bascule> they're cookies with layers! :D
[18:25:07] <Tiffany> well, it's confusing since it seems to attribute security attributes to cookies that I'm not familiar with
[18:25:11] <bascule> both the original paper and ^^^ video discuss using public key cryptography for federated authz
[18:25:18] <Tiffany> my understanding of cookies is strings you can set on the client
[18:26:14] <bascule> yes, strings that are typically bearer tokens authenticated using cryptography in some way
[18:26:39] <bascule> when they say "cookie" they mostly mean "bearer token"
[18:26:48] <Tiffany> a bearer token is a sort of encrypted+MACed value authorizing a client, right?
[18:26:55] <bascule> like, you can do delegation with cookies by giving someone a copy of your cookie
[18:27:07] <bascule> but that's usually a bad idea based on how cookies typically work, heh
[18:27:11] <bascule> and yeah
[18:27:33] <bascule> entitles bearer to authority encoded in/on the token
[18:27:49] <bascule> like a train ticket
[18:32:41] <Tiffany> I like macaroons already
[18:33:23] <bascule> the whole chained HMAC thing is pretty mindblowing, heh
[18:33:29] <Tiffany> they make me want to build a distributed capability system
[18:33:36] <bascule> yep
[18:34:17] <bascule> you can get a lot of the stuff CapTP tried to do with sturdy refs and live refs and so forth a lot more simply, and you don't need proxies for handling revocation
[18:34:43] <bascule> instead you can handle revocation with short-lived discharges
[18:35:02] <Tiffany> short-lived discharges?
[18:35:13] <bascule> did you get to third party caveats yet?
[18:35:27] <Tiffany> I'm currently at the cookies with integrity slide
[18:35:37] <bascule> you can have a client check back with a session/authentication server periodically
[18:37:16] <Tiffany> yeah, it seems like you can encode arbitrary caveats as long as they're implementable
[18:37:38] <Tiffany> if you have some sort of synchronization mechanism, you could just hand out maracoons with the caveat of 'revokable' and have a revokation database or something
[18:39:30] <bascule> yeah, that's the sort of thing third party caveats let you do (as a first-class feature)
[18:39:54] <bascule> if a macaroon contains a third party caveat, you have to obtain a second macaroon called a discharge macaroon
[18:40:29] <Tiffany> ooh, I like the chaining mechanism for caveats
[18:40:31] <Tiffany> it's better than I thought
[18:40:48] *** Quits: dcb (textual@moz-v6l3du.ca.comcast.net) (Quit: My Mac has gone to sleep. ZZZzzz…)
[18:40:49] <bascule> yeah it's basically a length extension attack on a cookie ;)
[18:40:55] <Tiffany> heh
[18:45:30] <Tiffany> now for the section on third party caveats
[18:49:34] <bascule> are you watching the video or still just reading the README?
[18:49:38] <Tiffany> the video
[18:49:40] <bascule> aah
[18:50:42] <Tiffany> I like macaroons, but they seem kind of complicated
[18:51:44] <bascule> heh, well, you have to fairly compare them to the alternatives
[18:52:26] <bascule> here's the use case I'm interested in:
[18:52:27] <bascule> https://jasig.github.io/cas/development/images/cas_proxy_flow_diagram.jpg
[18:52:53] <Tiffany> CAS?
[18:54:29] <Tiffany> this is a lot of steps'
[18:54:44] <bascule> haha yeah
[19:03:01] <Ilari> "In general, an old version of Firefox Portable seems a must-have item in the admin toolchest right now - there's just too much stuff still out there that can't be accessed with either current Firefox or IE anymore."
[19:04:44] <Tiffany> gross
[19:04:56] <bascule> o_O
[19:05:00] <Ilari> (And I suppose Chrome too).
[19:05:06] <bascule> just admin shit using an old web browser
[19:05:08] <bascule> what could go wrong
[19:05:37] <bascule> sounds like Microsoft Server 2003 lol
[19:10:10] <Ilari> Hah, checked recent worst on SSL labs and found server with 4 "grade set to F" issues.
[19:11:06] <Ilari> SSLv2, FREAK, POODLE TLS and Renego bug.
[19:11:10] <Tiffany> I wonder how safe siphash is
[19:11:23] <Tiffany> it's very enticingly fast (only 140 cycles for short messages)
[19:11:40] <Tiffany> is there much risk in only having 64-bit MACs?
[19:11:43] <Tiffany> the keys are still 128-bit
[19:13:33] <Ilari> Depends on the MAC. E.g. Truncating the MAC from GCM to 64 bits is a bad idea.
[19:13:51] <bascule> Tiffany: there's the birthday bound on the number of messages you can authenticate before you have to rekey
[19:13:52] <Tiffany> well, SipHash's output is 64 bits
[19:14:04] <Tiffany> hm okay
[19:14:19] <bascule> a (sort of similar) attack worked against WEP
[19:14:25] <Tiffany> I'm mainly thinking about how this video is talking about how quickly you can make macaroons
[19:14:29] <Tiffany> using HMAC
[19:14:38] <Tiffany> when SipHash is so much faster than HMAC
[19:14:39] <bascule> yeah, you could use Blake2b instead of HMAC
[19:14:45] <Tiffany> oh yeah
[19:21:28] <Tiffany> is there a macaroon library in rust?
[19:21:37] <bascule> I started working on one
[19:21:42] <bascule> and kind of never finished it, heh
[19:21:43] <Elaine> https://github.com/cryptosphere/rust-macaroons/ is the only so far I think
[19:21:52] <bascule> yeah, that
[19:22:11] <bascule> I should try to work on that today or something
[20:07:00] <bascule> woop
[20:07:05] <bascule> actually working on rust-macaroons again heh
[20:07:17] <bascule> trying to write a verifier
[20:08:14] <Tiffany> is there a wire format for macaroons specified?
[20:08:33] <bascule> haha, depends how what you mean by "specified"
[20:08:42] <bascule> there is a common wire format used by all the implementations
[20:08:48] <bascule> it's not exactly well-documented, heh
[20:09:01] <bascule> this is why I wanted to try to do a Macaroons BoF
[20:09:02] <Tiffany> how many implementations?
[20:09:12] <bascule> http://macaroons.io/
[20:09:27] <bascule> 9 listed there
[20:10:10] <bascule> it's based on git pkt-lines
[20:10:24] <Tiffany> and they all use that same format?
[20:11:52] <bascule> yep
[20:12:05] <bascule> in theory anyway, heh
[20:16:00] *** Joins: eddyb_ (eddyb@moz-iut.q07.26.188.IP)
[20:17:31] *** Quits: eddyb (eddyb@moz-042.8f9.121.86.IP) (Ping timeout: 121 seconds)
[20:18:31] *** Joins: tomlikestorock (tomlikestor@moz-i312q9.ca.comcast.net)
[20:33:24] *** Quits: tomlikestorock (tomlikestor@moz-i312q9.ca.comcast.net) (Client exited)
[20:50:54] <Tiffany> https://www.ssllabs.com/ssltest/analyze.html?d=cas-auth.rpi.edu
[20:51:08] <Tiffany> look at those preferred ciphers
[20:52:40] *** Joins: dcb (textual@moz-v6l3du.ca.comcast.net)
[20:54:03] <Ilari> What, 1DES is WEAK and not INSECURE? Or am I looking at it wrong?
[20:54:29] <Tiffany> it's not just 1DES
[20:54:32] <Tiffany> it's 1DES clamped to 40 bits
[20:59:54] <Tiffany> also, it is marked INSECURE, not WEAK
[20:59:58] <Tiffany> oh
[21:00:01] <Tiffany> I misunderstood
[21:00:05] <Tiffany> TLS_RSA_WITH_DES_CBC_SHA (0x9)   WEAK
[21:00:06] <Tiffany> yeah what
[21:04:23] *** Quits: dcb (textual@moz-v6l3du.ca.comcast.net) (Ping timeout: 121 seconds)
[21:07:15] <Tiffany> the bad ciphers aren't even why browsers refuse to connect to it though
[21:07:15] <Tiffany> it's because it uses a 768-bit DH prime
[21:07:38] <Tiffany> the only "safe" cipher suite appears to be RSA_WITH_AES_128_CBC_SHA
[21:07:44] <Tiffany> and that doesn't have FS
[21:07:52] <Tiffany> firefox prefers DHE over RSA no matter what it looks like
[21:07:57] <Tiffany> and then it bails upon seeing the 768-bit prime
[21:12:10] *** Quits: atomic (atomic@moz-388gu4.ip-37-187-129.eu) (Ping timeout: 121 seconds)
[21:19:18] <Ilari> Tiffany: Actually, it is server which picks the ciphersuite.
[21:19:39] <Tiffany> oh
[21:38:33] *** Joins: dcb (textual@moz-v6l3du.ca.comcast.net)
[21:40:30] *** Quits: dcb (textual@moz-v6l3du.ca.comcast.net) (Connection closed)
[21:40:43] *** Joins: dcb (textual@moz-v6l3du.ca.comcast.net)
[21:47:27] *** Joins: dcb_ (textual@moz-v6l3du.ca.comcast.net)
[21:49:30] *** Quits: dcb (textual@moz-v6l3du.ca.comcast.net) (Ping timeout: 121 seconds)
[22:10:37] <eternaleye> Ilari: Would another option re: signature seed be HKDF? Extract with the message, then independent expansions using context values?
[22:11:05] <eternaleye> Ilari: It's honestly pretty much the exact intended use case of HKDF...
[22:11:21] <eternaleye> Ilari: Overhead should be near-nil too
[22:45:20] <Ilari> eternaleye: Seed is independent of message?
[23:00:20] <Ilari> Tiffany: The server may or may not take into account the order client puts the ciphersuites in.
[23:01:15] *** Quits: dcb_ (textual@moz-v6l3du.ca.comcast.net) (Ping timeout: 121 seconds)
[23:04:16] *** Joins: tomlikestorock (tomlikestor@moz-i312q9.ca.comcast.net)
[23:04:43] *** Quits: gleb (gleb@moz-3u1drv.rusanovka-net.kiev.ua) (Ping timeout: 121 seconds)
[23:33:27] *** Joins: dpc (dpc@moz-t6gr4b.ca.comcast.net)
[23:37:44] <eternaleye> Ilari: Your slides use "m" to denote _something_!
[23:38:26] <Ilari> Oh, that.
[23:39:28] <Ilari> No damn idea if thing like that can even be made to work. And if one used HKDF, it wouldn't AFAIK have normal hash prefix.
[23:40:09] <eternaleye> Ilari: Well, my point is that slide 7 talks about "some sort of labeled PRF"
[23:40:21] <eternaleye> Ilari: Which is... pretty much exactly the goal of HKDF
[23:40:29] <bascule> impl<F> Verifier<F> where F: Fn(Predicate) { pub fn new(matcher: F) -> Verifier<F> { ... } }
[23:40:35] <bascule> is that a good interface or not, I can't tell
[23:41:03] <eternaleye> bascule: For what, cert chain verification?
[23:41:12] <bascule> Macaroon predicate verification
[23:41:15] <eternaleye> Mm
[23:41:18] <bascule> i.e. checking caveats
[23:42:21] <eternaleye> And how would one use a Verifier?
[23:42:47] <Ilari> eternaleye: The code I have seemingly dumps 0x00 or 0x01, clog2l and the raw key into hash.
[23:42:51] <bascule> give it a key, a macaroon Token, and potentially one or more discharge macaroons (which I haven't implemented yet)
[23:42:58] <eternaleye> Hm
[23:43:12] <bascule> and it will tell you if the HMAC verifies and all of the predicates are recognized and verified
[23:43:32] <bascule> but I leave the "recognized" part up to that Fn
[23:44:09] <bascule> |_predicate| { true } <-- it's legit!
[23:44:10] <eternaleye> I think I'd go for a more builder-ish API
[23:44:29] <bascule> it's hard to do without getting too opinionated about the format
[23:44:35] <eternaleye> First, I'm presuming that "split on first whitespace" is followed
[23:44:39] <eternaleye> But no other assumptions
[23:44:41] <bascule> ^^^
[23:44:46] <bascule> heh
[23:44:51] <eternaleye> bascule: How better to enforce it? :P
[23:45:15] <bascule> just using the magical lambda that knows all at least lets you do single-pass predicate checking
[23:45:27] <bascule> then you can have a higher level library that's more opinionated
[23:45:36] <eternaleye> But what I mean is that the matcher and the verifier can have better types
[23:45:52] <bascule> sure, in a higher level library
[23:45:53] <eternaleye> "do I support this predicate" should be -> Option<Validator>
[23:46:06] <bascule> I don't want to do it that way
[23:46:14] <bascule> that's no longer single-pass
[23:46:41] <eternaleye> bascule: It is if you pre-split :P
[23:46:58] <eternaleye> bascule: Split on whitespace, first goes into support, second goes into valid
[23:46:58] <bascule> if you can be opinionated about "split at space" you can just register an id
[23:47:02] <eternaleye> Sure
[23:47:18] <eternaleye> I think that's fundamentally a better API
[23:47:35] <bascule> then you can use a compile time phf lol
[23:50:24] <Ilari> "In addition to reducing combinatorial nonsense with the suites,"
[23:51:26] <eternaleye> bascule: Even better!
[23:51:46] <eternaleye> bascule: Conveniently, there's even rust-phf to help! :P
[23:53:12] <bascule> yep
[23:53:23] <bascule> Ilari: hate the combinatorial nonsense!

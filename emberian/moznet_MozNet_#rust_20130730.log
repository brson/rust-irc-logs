[00:00:19] <bblum> non-growable just like you if you don't drink your milk
[00:01:09] *** Joins: mhordecki (mhordecki@moz-BE33DA21.fw1.sfo1.mozilla.net)
[00:02:06] *** Joins: yichoi (yichoi@5AB4884B.FCC4549.14D5B978.IP)
[00:02:17] <sam113101> can someone explain to me boxes and pointers?
[00:03:04] <bblum> brson: figured it out
[00:03:06] *** Quits: eatkinson (eatkinson@moz-BBE3ABD.mv.mozilla.com) (Quit: eatkinson)
[00:03:09] <brson> bblum: what was it?
[00:03:35] *** Quits: paupau (textual@FFAF02D4.F5573215.F20F0C5A.IP) (Ping timeout)
[00:03:59] *** Quits: yichoi (yichoi@5AB4884B.FCC4549.14D5B978.IP) (Quit: yichoi)
[00:04:00] <bblum> brson: the "task" is racing with itself, in the sense that the ...and_then() cleanup job is not really the task, so when it re-enqueues the blocked task, the blocked task can reenter its own cleanup job
[00:04:11] *** Joins: yichoi (yichoi@5AB4884B.FCC4549.14D5B978.IP)
[00:04:24] <bblum> and then of course since it owns the packet that its cleanup job is mutating, it has every right to free the packet
[00:04:52] <brson> bblum: yeah that's a tricky and probably undocumented invariant. once the cleanup job gives away the task you can't touch the environment
[00:05:10] <brson> would be nice to find a way to encode that in the type system
[00:05:44] <bblum> seems very difficult
[00:06:00] <bblum> a naive way would be to require that the cleanup job return an Option<BlockedTask>, which is Some if it wants to get rescheduled
[00:06:11] <bblum> but that is probably totally incompatible with IO
[00:06:34] *** Quits: dew (Instantbir@moz-8A63B53.dhcp.stls.mo.charter.com) (Ping timeout)
[00:07:01] <cmr> sam113101: ignore pointers, rust doesn't "really" have them, except raw pointers
[00:07:17] *** Joins: dbp (user@moz-72A193C2.ri.ri.cox.net)
[00:07:34] <cmr> sam113101: the boxes (owned and managed) form the two types of ownership you could want in a program:
[00:07:53] <cmr> either you own it, and nobody can share it with you, or "nobody" owns it (the GC owns it), but you can share it with everyone
[00:08:00] <aatch> Or, the one you want and the one you can't work around
[00:08:02] <strcat> ~T has the same ownership properties as T though
[00:08:05] *** Quits: km (quassel@FDBAF0A0.DBF71E41.29C67456.IP) (Ping timeout)
[00:08:09] <cmr> heheh
[00:08:12] <graydon> huh
[00:08:15] <brson> even though I like the term box and reference, I'm pretty skeptical of this notion that we should be teaching people that rust doesn't have pointers
[00:08:27] <graydon> strcat: you'll be happy to know that I just got my first for .. in { ... } compiling
[00:08:33] <bblum> graydon: woo!
[00:08:34] <graydon> seems to work
[00:08:35] <strcat> graydon: ;)
[00:08:59] <cmr> brson: thus the quotes
[00:09:06] <kmc> brson: why in particular? I can think of a few reasons
[00:09:09] <graydon> well ... _sorta_
[00:09:19] <strcat> bblum: @T is no more or less a pointer than ~[T] though
[00:09:22] <strcat> er
[00:09:24] <strcat> brson: *
[00:09:26] <graydon> please stop saying "rust doesn't have pointers", it's not a reasonable stance
[00:09:36] <graydon> any more than when parasail says it
[00:09:56] <strcat> it has types implemented with pointers, like almost any language
[00:09:59] <graydon> it's not true. we clearly do. a pointer is a thing that is an address and refers to something at that address.
[00:10:05] <aatch> We have pointers because we have types that are pointer-sized that point to data.
[00:10:09] <graydon> yeah
[00:10:12] <cmr> I don't know what parasail is, but I think ignoring pointers while explaining boxes/references to a newbie is reasonable.
[00:10:23] <graydon> it's just .. random obscurantism to say @ or ~ "aren't pointers"
[00:10:31] <strcat> graydon: ~T doesn't have to be a pointer though, any object no bigger than a pointer can be stored inline without an allocation
[00:10:37] <aatch> cmr, ignoring pointers != saying they don't exist
[00:10:38] <strcat> we don't, but there's no reason we couldn't
[00:10:43] <strcat> implementation detail
[00:11:02] <bblum> brson: I think you could encode it in a *very* clunky way, by requiring an environmentless closure (extern fn?), and thread the environment through, and have the closure receive in addition to the task (a) the environment inside a noncopyable, and (b) a fn which it can call to receive the environment 'token' back again and reschedule the task
[00:11:03] <graydon> strcat: it's one that's extremely visible and imo -should- be visible, not an implementation detail
[00:11:16] <Seldaek> graydon: they aren't pointers in the "traditional" C sense of it, at least according to my crappy understanding of both C and rust
[00:11:35] <cmr> Indirection does not a pointer make, IMO
[00:11:40] <strcat> graydon: but there's not actually a way know if ~T is a pointer without transmute
[00:11:50] <aatch> cmr, but that's what a pointer is.
[00:11:56] <bblum> brson: fn deschedule_and_then<E>(env: E, blk: fn(&mut Scheduler, BlockedTask, NoncopyableEnv<E>, wake_task: fn(NoncopyableEnv<E>, BlockedTask)))
[00:11:57] <kmc> I think Rust's positioning as a low-level systems language means we should embrace this particular implementation detail
[00:11:58] <cmr> aatch: a pointer is one method of indirection
[00:12:01] <graydon> C was not the first language with pointers nor will it be the last. a pointer is an address.
[00:12:03] <graydon> http://en.wikipedia.org/wiki/Pointer_%28computer_programming%29
[00:12:03] <kmc> I'm not sure of that, but it's my gut feeling
[00:12:07] <graydon> let's bring the wikipedia, eh?
[00:12:10] <bblum> brson: s/blk: fn/blk: extern fn/
[00:12:33] <bblum> where NonCopyableEnv is just a struct<E> { env: E } with a noop Drop
[00:12:36] <cmr> graydon: the first few sentences aren't even correct, taking virtual memory into account!
[00:12:47] *** Quits: sebcrozet (sebcrozet@moz-C27D92D8.w193-252.abo.wanadoo.fr) (Ping timeout)
[00:12:48] *** Joins: dew (Instantbir@moz-8A63B53.dhcp.stls.mo.charter.com)
[00:12:56] <strcat> graydon: yeah, they can be implemented as an address
[00:13:07] <strcat> ~[] is a pointer to a block of memory, as is @T
[00:13:20] <strcat> and extern fn
[00:13:24] <brson> bblum: yeah :-/, that's a tough price to pay for the type safety, but this bug does come up pretty often when working with the scheduler. maybe we'll have to do something like that eventually
[00:13:27] <sam113101> well, I'm just as comfused if not more
[00:13:42] *** Quits: SiegeLord (sl@moz-CAF07B4C.hsd1.ma.comcast.net) (Ping timeout)
[00:13:44] *** Quits: hjr3 (hradtke@1A0AE795.28A5F6C3.A2D40ED2.IP) (Quit: My MacBook has gone to sleep. ZZZzzzâ€¦)
[00:13:48] <strcat> graydon: & and &mut are defined as pointers
[00:13:49] <cmr> sam113101: I was trying to explain the ownership semantics of boxes and references but I got derailed, sorry :(
[00:13:54] <strcat> since you can coerce them to */*mut
[00:14:00] <strcat> ~T isn't though
[00:14:10] *** Joins: tautologico (lymph@9F01D096.92EA1F6.C27E1635.IP)
[00:14:15] <bjz> Is florob from github here?
[00:14:20] <graydon> I .. don't know why you keep saying this
[00:14:27] <cmr> bjz: he was earlier
[00:14:31] <bjz> maker of RustyXML?
[00:14:32] <cmr> same nick (Florob)
[00:14:34] <cmr> yes
[00:14:35] <bjz> cmr: cool
[00:14:40] <graydon> ~T can be transmuted into *T. you went to some effort to ensure this.
[00:14:45] <graydon> it's a pointer
[00:15:07] <strcat> graydon: if we supported MSVC++ you couldn't count on that though
[00:15:10] <bjz> graydon: pointer to a place on the heap?
[00:15:17] <bblum> brson: hmm... might even have to give a &NoncopyableEnv<E>, with E:Freeze, so you can't just put a &mut environment inside a Cell, take it out, and then pass the token away and continue using part of the env
[00:15:20] <strcat> because we want to use jemalloc
[00:15:22] <strcat> well
[00:15:38] <strcat> it's guaranteed to be a pointer, but not to something you can necessarily make any assumptions about
[00:15:50] *** Joins: stepancheg (Mibbit@A92127F4.E98F9600.51A714DB.IP)
[00:16:01] <aatch> (It should also be noted that pointers are in some cases a concept understood by the *processor*)
[00:16:38] <bblum> brson: that would "work" in the case of comm::try_recv, but it wouldn't give much of a guarantee because self.packet() returns a *mut anyway
[00:16:39] <toddaaro> sully: I got an error "error: first-class methods are not supported" when trying to pass a method of (~self, foo: T) to something expecting a closure
[00:16:44] <toddaaro> sully: what is up with that?
[00:16:55] <graydon> I don't see this as productive. it's like people arguing that you can make C programs run in interpreters. sometimes you can. but you're not going to get platform-specific assumptions about the nature of pointers out of a system that plainly implements references-as-pointers in 99.999% of cases including the production compiler and offers you the opportunity to cast to and from them unsafely.
[00:17:03] *** Joins: Yurume (yurume@AC58A8CE.8A059B47.E313B915.IP)
[00:17:06] <bblum> well, if you &Env, then the noncopy wouldn't help you
[00:17:09] <bblum> argh :P
[00:17:11] <graydon> (certainly not just by insisting that "hey we didn't specify it was going to be an address")
[00:17:14] <sully> toddaaro: you are allowed to use methods in a first class way
[00:17:21] <strcat> graydon: there are actually optimizations possible for ~T that make it not clearly a pointer though
[00:17:22] <sully> toddaaro: like, you can't pass foo.bar as a function, or something
[00:17:28] <graydon> strcat: such as?
[00:17:28] <toddaaro> sully: I did Foo::method
[00:17:29] <sully> toddaaro: you've got to eta expand
[00:17:37] <toddaaro> sully: why?
[00:17:43] *** Quits: yonran (yonran@moz-962F33EB.acuitus.com) (Ping timeout)
[00:17:51] <bblum> brson: anyway, i'll have a ready-to-go select PR shortly
[00:17:51] <cmr> graydon: I don't claim rust doesn't have pointers, I was just going to try to explain the ownership semantics that motivate the different boxes and references :\
[00:17:57] <graydon> strcat: I mean, are these things we do today? because it is presently a pointer.
[00:18:05] <strcat> graydon: it's presently a pointer, yeah
[00:18:08] *** Quits: tchoma (tchoma@moz-BBE3ABD.mv.mozilla.com) (Ping timeout)
[00:18:45] <sully> toddaaro: there might be some good reason involving how self params are dealt with
[00:18:52] <sully> toddaaro: or it might just be silly implementation reasons
[00:19:03] <strcat> graydon: ~int can be represented without a pointer, with the same semantics
[00:19:17] <strcat> or ~bool
[00:19:19] <sully> toddaaro: wait, though, you were trying to use Foo::method as a function that takes the self param as the first argument?
[00:19:27] <cmr> would need to fake the dereference operator
[00:19:28] <strcat> graydon: it would always be *pointer-size*
[00:19:31] <graydon> can be, but it's not clear it's much of a win. doesn't happen often, requires a bunch of special case stuff.
[00:19:39] <strcat> graydon: it'd happen often with ~Trait
[00:19:59] <toddaaro> sully: I need a function taking (T1, T2), so I passed in a method by doing T1::method
[00:20:02] <strcat> graydon: and I don't think it really needs any more special-casing than I did for managed-unique vs unique
[00:20:05] <graydon> sorry for getting snitty on this. we spent a huge amount of time renaming concepts specifically to make pointer-ness clear, to relate & ~ and @ by name, and it feels gratuitous to me to do it again in the opposite direction.
[00:20:14] <sully> toddaaro: yeah, you can't do that
[00:20:19] <stepancheg> Hi all. May I ask a little help? My program fails to compile, and I have no idea what's wrong https://gist.github.com/stepancheg/6109046 It looks like casting to &Bar kills foo variable.
[00:20:20] <toddaaro> sully: that is unfortunate
[00:20:30] <sully> toddaaro: methods aren't actually just functions
[00:20:37] <sully> toddaaro: there are some proposals to fix this
[00:20:41] <toddaaro> bleh
[00:20:46] <mark_edward> hwo would i go from a vector of bytes to a hex string?
[00:21:06] <strcat> graydon: I just find that we're explaining it wrong, and catering to C++ programmers who will already feel at home
[00:21:09] <strcat> it's subjective ofc
[00:21:28] <graydon> yeah, I'm sorry. I'm just in a foul mood because I spent the morning trying to debug memory errors on windows.
[00:21:31] <graydon> not your fault.
[00:22:14] <sully> does valgrind work on windows?
[00:22:18] <graydon> I don't know what to do about for .. in; I implemented it via pure desugaring in the parser which means it absolutely doesn't come close to pretty printing. I guess I can push it through the rest of the compiler but it'll make it 10x as much work.
[00:22:22] <graydon> no
[00:22:35] <brson> nothing works on windows!
[00:22:55] <graydon> valgrind's official position is that they will never work on windows, which I think is quite reasonable given the scope of the problem
[00:23:05] <sully> oh god, I remember debugging a windows only crash when I was a JS intern
[00:23:07] <mark_edward> strcat: do you know how to go from a vector of [u8] to a hex string?
[00:23:07] <graydon> you can run a win32 program under wine under valgrind
[00:23:11] <sully> in the JIT I was writing
[00:23:19] *** Quits: echristo (echristo@DCF57675.D6CCE4AE.77834EAA.IP) (Quit: echristo)
[00:23:22] <brson> stepancheg: i'll give it a try here
[00:23:23] <tikue> when getting a dynamic borrow check failure, is there a way to see where the first borrow occurs?
[00:23:25] <sully> turns out the problem wasn't related to windows, except that different memory layout and behavior happened to expose it
[00:23:31] <strcat> mark_edward: not really, I guess we might have that somewhere in libextra
[00:23:33] <strcat> we have base64
[00:23:47] *** Quits: mschifer (Adium@moz-BBE3ABD.mv.mozilla.com) (Quit: Leaving.)
[00:23:50] <mark_edward> strcat: i see
[00:24:01] <graydon> sully: I'm sure this case is similar
[00:24:08] <sully> turns out the bug was that nanojit would cast one of its classes to a particular subclass and read fields from it
[00:24:10] <graydon> but I haven't the patience to debug it today.
[00:24:25] <sully> assuming that it was a tracemonkey jit context
[00:24:43] <sully> but since I was making another jit, mine *wasn't* that particular subclass
[00:25:11] *** Joins: km (quassel@FDBAF0A0.DBF71E41.29C67456.IP)
[00:25:21] *** Quits: tjc (tjc@moz-BBE3ABD.mv.mozilla.com) (Quit: Places to go, people to annoy)
[00:25:26] *** Joins: tjc (tjc@moz-BBE3ABD.mv.mozilla.com)
[00:25:26] *** ChanServ sets mode: +o tjc
[00:26:53] *** Quits: pnkfelix (pnkfelix@moz-43495417.fbx.proxad.net) (Quit: Leaving.)
[00:26:54] *** Quits: jclements (jclements@moz-7782C71D.ngn.east.myfairpoint.net) (Ping timeout)
[00:27:26] <brson> tikue: I think there's a way to track it with the right compiler flags
[00:27:35] *** Joins: jclements (jclements@moz-4188B56F.port.east.myfairpoint.net)
[00:27:37] <brson> tikue: maybe --cfg debug, maybe ask nmatsakis
[00:27:41] *** Quits: snadon (chatzilla@moz-3BC727E8.mc.videotron.ca) (Ping timeout)
[00:27:54] <tikue> ok thx brson I'll try that
[00:27:57] <kmc> sully, graydon: wonder what sort of heap layout fuzzing would be needed to reproduce those kinds of issues on another OS
[00:28:28] *** Joins: jfbk (textual@moz-EEA9CFB3.nyc.res.rr.com)
[00:29:46] <strcat> graydon: so your implementation of for ... in is side-by-side with the old for?
[00:30:04] <graydon> strcat: yeah. I used 'foreach .. in .. { ... }' for transitional syntax
[00:30:34] <bjz> dbaupp: https://github.com/mozilla/rust/pull/8115
[00:30:41] <tikue> I'm assuming it requires in <..>.iter() still?
[00:30:52] <tikue> just no longer .advance?
[00:31:14] <strcat> it will require iter() to get an iterator from a container
[00:31:27] <graydon> strcat: it seems like it generates quite a bit of code in any case.
[00:31:47] <graydon> though somewhat less
[00:32:17] <strcat> graydon: it just becomes something like 'let mut x = it; loop { match it { Some(pattern) => body, None => break } }' right?
[00:32:24] <graydon> yes
[00:32:32] <graydon> match it.next()
[00:32:39] <strcat> yeah
[00:33:21] <graydon> https://github.com/graydon/rust/tree/foreach-in-sketch if you're curious
[00:33:36] <graydon> I guess I should do the full translation. but it's a bit heart breaking.
[00:33:54] <strcat> full translation as in not just desugaring?
[00:33:57] <graydon> yeah
[00:34:02] * graydon shrugs. pretty printing.
[00:34:28] <strcat> ah since it just writes out the AST
[00:34:32] *** Joins: ghrust (ghrust@2EE61FCC.6A2AE50.F3114085.IP)
[00:34:32] <ghrust> 01[13rust01] 15bors merged 06auto into 06master: 02http://git.io/JtqMBw
[00:34:32] *** Parts: ghrust (ghrust@2EE61FCC.6A2AE50.F3114085.IP) ()
[00:34:33] <strcat> are error messages still sane at least?
[00:34:39] <bblum> i find that the "run this expensive assertion if cfg(test)" pattern is becoming common enough for me that i want to avoid writing separate functions each time i do it
[00:34:53] <graydon> ish
[00:34:54] <bblum> would there be an easy way to be able to #[cfg(test)] blocks of code instead of entire items?
[00:35:17] <cmr> bblum: didn't debug_assert!() land today or recently?
[00:35:30] <graydon> he wants test
[00:35:43] <bblum> if test implies debug, that would also be fine :P
[00:36:06] <bblum> also i see no debug_assert/dbg_assert in my tree
[00:36:19] <cmr> https://github.com/mozilla/rust/pull/7869
[00:37:08] <strcat> bblum: maybe we could just define a 'static test: bool' somewhere
[00:37:11] *** Quits: seth (seth@moz-BE33DA21.fw1.sfo1.mozilla.net) (Input/output error)
[00:37:22] *** Joins: ghrust (ghrust@2EE61FCC.6A2AE50.F3114085.IP)
[00:37:22] <ghrust> 01[13rust01] 15bors pushed 0 new commits to 06auto: 02http://git.io/D4Qf2Q
[00:37:22] *** Parts: ghrust (ghrust@2EE61FCC.6A2AE50.F3114085.IP) ()
[00:37:23] *** Joins: ghrust (ghrust@C8693FCB.6A2AE50.F3114085.IP)
[00:37:23] <ghrust> 01[13rust01] 15bors pushed 6 new commits to 06auto: 02http://git.io/q0VphQ
[00:37:23] <ghrust> 13rust/06auto 140bd293a 15toddaaro: A major refactoring that changes the way the runtime uses TLS. In the...
[00:37:23] <ghrust> 13rust/06auto 14215cfc0 15Ben Blum: Have linked failure tests run on the new scheduler instead of requiring RUST_NEWRT to test.
[00:37:23] <ghrust> 13rust/06auto 142f5e19e 15toddaaro: Fixed a race where a scheduler configured to only run tasks pinned to it would "bounch" a regular task in and out of the work queue without allowing a different scheduler to run it.
[00:37:26] *** Parts: ghrust (ghrust@C8693FCB.6A2AE50.F3114085.IP) ()
[00:37:29] <strcat> bblum: and #[cfg] it
[00:37:56] <lkuper> I'm afraid this conversation on the mailing list about `->` and `:` is going to unleash a monster
[00:38:04] <strcat> #[cfg(test)] static test: bool = true; #[cfg(not(test))] static test: bool = false; and just 'if something::test { }'
[00:38:07] <cmr> it is a good question though
[00:38:13] <bblum> strcat: would result in something surprising if it's cross-crate
[00:38:26] <cmr> bblum: pfah, insert it into the prelude
[00:38:29] <strcat> bblum: true
[00:38:32] *** Quits: vosen (vosen@moz-266BA656.icpnet.pl) (Quit: Leaving)
[00:38:47] <bblum> extra bonus potential for surprise in stdtest
[00:38:48] *** Quits: infynyxx (infynyxx@DB780A29.749BA1D.DCC373F0.IP) (Client exited)
[00:38:52] <bblum> cmr: stdtest doesn't get prelude
[00:39:08] <bblum> basically i just want a counterpart to that debug_assert thing
[00:39:31] <strcat> bblum: is_test!() ;p
[00:39:40] * strcat shrugs
[00:39:46] *** Quits: etw (john@5ADED2BB.8145FF59.D8D886B.IP) (Ping timeout)
[00:39:58] <strcat> those macros are injected at the top of every file
[00:40:08] <strcat> every crate*
[00:40:21] <brson> stepancheg: I can't find a workaround. I'm guessing it's just because &Trait is still half-baked
[00:40:23] *** Joins: ghrust (ghrust@9C8B94D4.6A2AE50.F3114085.IP)
[00:40:23] <ghrust> 01[13rust01] 15bors 04force-pushed 06auto from 14d0b8699 to 14bb996bf: 02http://git.io/N3iJvQ
[00:40:23] *** Parts: ghrust (ghrust@9C8B94D4.6A2AE50.F3114085.IP) ()
[00:40:23] *** Joins: ghrust (ghrust@614D05BD.6A2AE50.F3114085.IP)
[00:40:23] <ghrust> 01[13rust01] 15bors pushed 2 new commits to 06auto: 02http://git.io/3N5fWA
[00:40:23] <ghrust> 13rust/06auto 148ae900f 15Brian Anderson: mk: Fix NO_REBUILD so stdtest can be tested without re-bootstrapping. Closes #8101
[00:40:23] <ghrust> 13rust/06auto 14b9d8971 15bors: auto merge of #8110 : brson/rust/no-rebuild, r=bblum...
[00:40:24] *** Parts: ghrust (ghrust@614D05BD.6A2AE50.F3114085.IP) ()
[00:40:45] <kmc> lkuper: likewise
[00:41:27] <kmc> I wonder if mentioning that C++11 also adopted f(args) -> ret syntax would make that more or less likely
[00:42:00] *** Joins: etw (john@moz-D871A25B.nyc.res.rr.com)
[00:42:11] *** Joins: Jesin (Jessin_@moz-1B1307FF.eecs.lehigh.edu)
[00:42:11] <bblum> that's the only place we have -> in the grammar, isn't it?
[00:42:23] <shachaf> GHC used to support e.g. f (x :: Int) (y :: Char) :: Bool = ...
[00:42:30] <cmr> also closures, but yes
[00:42:38] <shachaf> They took that out at one point. I wonder whether there was a reason.
[00:42:44] <strcat> python3 has this:
[00:42:54] <strcat> def foo(x: foo, y: bar) -> baz:
[00:42:57] <strcat> it's meaningless though
[00:43:23] <strcat> and ofc C++11 has it in both global functions and lambdas as kmc mentioned
[00:43:35] <bjz> shachaf: it probably makes more sense in haskell seeing as its curried
[00:43:35] <stepancheg> brson: half-baked means &Trait not yet fully implemented in compiler, and snippet reveals a bug?
[00:43:53] <shachaf> fn foo(x: fn(int): char) is kind of strange syntax.
[00:44:03] <bjz> shachaf: it also follows the mathematical notation: `f: X -> Y`
[00:44:18] <kmc> strcat: yeah it's meaningless by itself, libraries can introspect on it though
[00:44:35] <bjz> `f: X -> Y -> Z` just makes sense if you look at it from that point of view
[00:44:39] <strcat> kmc: same as python's "..." ;p
[00:44:40] *** Quits: jroll (jroll@moz-5989BB9E.members.linode.com) (Quit: brb!)
[00:44:44] *** Quits: ozten (ozten@moz-DD3B00B4.hsd1.wa.comcast.net) (Quit: ozten)
[00:44:47] <kmc> true
[00:44:52] <bjz> but Rust doesn't really go from that point of view
[00:44:56] <brson> stepancheg: yes
[00:45:06] <shachaf> f(x): B isn't the syntax being suggested, though.
[00:45:13] <cmr> shachaf: yes it is?
[00:45:26] <bjz> yes it is?
[00:45:26] <cmr> fn f(x): B
[00:45:31] <cmr> unless I seriously misread
[00:45:36] <bjz> yeah, that's what I mean
[00:45:39] <strcat> the function syntax isn't going to change at this point, simple answer ;p
[00:45:43] <stepancheg> brson: thank you, waiting for the fix then.
[00:46:08] <shachaf> Hmm, maybe it makes more sense when the function is named...
[00:46:38] *** Quits: Jesse (jruderman@moz-BBE3ABD.mv.mozilla.com) (Quit: Jesse)
[00:48:05] <strcat> engla: could you remove the random_access_iterator! macro in vec.rs? since it just has 1 user now
[00:48:22] <strcat> other than that, r+
[00:48:29] <engla> strcat: ok I will
[00:48:31] *** Quits: lkuper (lkuper@3AE931C6.A402E718.C082B7DC.IP) (Quit: lkuper)
[00:49:13] *** Joins: Nefzaoui (chatzilla@6C9D287B.CFD048A4.80E43DAF.IP)
[00:49:17] *** Quits: jclements (jclements@moz-4188B56F.port.east.myfairpoint.net) (Ping timeout)
[00:49:26] *** Quits: mhordecki (mhordecki@moz-BE33DA21.fw1.sfo1.mozilla.net) (Quit: mhordecki)
[00:49:28] <strcat> so I guess MutRandomAccessIterator needs idx(&'self mut self, ...) and swap(uint, uint)
[00:49:40] <strcat> will take unsafe code to implement for almost anything though
[00:49:51] *** Quits: mihneadb (mihneadb@moz-BE33DA21.fw1.sfo1.mozilla.net) (Connection reset by peer)
[00:49:57] <strcat> need to make sure that's enough to write a sort
[00:50:04] *** Joins: mihneadb (mihneadb@moz-BE33DA21.fw1.sfo1.mozilla.net)
[00:50:13] *** Joins: jclements (jclements@moz-41F46F5E.ptldme.east.myfairpoint.net)
[00:50:16] <strcat> well, it won't be
[00:51:28] <engla> strcat: I guess you read dbaupp's thoughs about random-accessing over Map https://github.com/mozilla/rust/issues/8108 ?
[00:51:42] <olsonjeffery> brson: are you enforcing a really firm boundary between std::rt and the rest of std:: .. curious how much i should pull into std::future, or if i should add traits/impl in rtio and uvio ..
[00:51:46] <strcat> engla: I think it's fine
[00:51:57] <strcat> I actually read that already :)
[00:52:18] <olsonjeffery> i guess more about where to encapsulate interacting with the scheduler..
[00:52:43] <strcat> I don't think the map iterator has to make any guarantees itself
[00:52:44] *** Joins: mhordecki (mhordecki@moz-BE33DA21.fw1.sfo1.mozilla.net)
[00:52:49] <strcat> the order is determined by how you use it
[00:53:16] <engla> peek is the same
[00:53:18] <engla> of course
[00:53:32] *** Quits: maxli (maxli@B5559308.9C54E60.2FA4EA88.IP) (Quit: Leaving.)
[00:53:55] <strcat> could have a parallel map iterator by using closure bounds in the future but it still won't actually be required to be pure
[00:54:05] *** Quits: alisdair (textual@moz-EA60A466.dedicated.allstream.net) (Quit: My MacBook Pro has gone to sleep. ZZZzzzâ€¦)
[00:54:41] <brson> olsonjeffery: any part of std may interact with the scheduler. besides rt::io, no part of of std::rt is supposed to be a public api
[00:54:42] *** Joins: SiegeLord (sl@moz-CAF07B4C.hsd1.ma.comcast.net)
[00:55:08] <brson> well, rt::comm will probably also replace std::comm too
[00:55:55] <brson> olsonjeffery: probably the async io code should have an abstraction layer like rtio/uvio
[00:56:18] <brson> olsonjeffery: I don't know what the requirements are here, but if there's going to a big impact to the rtio interface then it should probably go in rtaio/uvaio
[00:57:08] *** Joins: infynyxx (infynyxx@DB780A29.749BA1D.DCC373F0.IP)
[00:57:21] *** Quits: eschweic1 (Adium@moz-BBE3ABD.mv.mozilla.com) (Quit: Leaving.)
[00:57:41] *** Quits: Nefzaoui (chatzilla@6C9D287B.CFD048A4.80E43DAF.IP) (Quit: ChatZilla 0.9.90.1 [Firefox 22.0/20130618035212])
[00:57:57] <graydon> strcat: you're doing the inttoptr / GEP change to *T?
[00:58:10] <olsonjeffery> brson: i would end up just add structs in there
[00:58:14] <olsonjeffery> +ing
[00:58:21] <strcat> graydon: I probably will, but I thought about it more and 'inbounds' is a bad idea
[00:58:24] <strcat> that can be separate
[00:58:34] <graydon> ok
[00:58:39] *** Quits: mhordecki (mhordecki@moz-BE33DA21.fw1.sfo1.mozilla.net) (Ping timeout)
[00:58:43] <graydon> I'm still not certain why inbounds is bad, but I'll take your word for it
[00:59:10] <strcat> graydon: it's just because it makes a calculation past the end (or before the start) undefined, rather than only a deref
[00:59:40] <shachaf> What's with https://github.com/mozilla/rust/blob/master/src/libextra/unicode.rs#L183 ? Shouldn't that say XID_CONTINUE?
[00:59:52] <graydon> yes
[00:59:54] <strcat> C++ has a guarantee that indexing one past the end of an array is defined, and elsewhere it can use inbounds
[01:00:06] <graydon> shachaf: nobody uses extra::unicode at the moment, as far as I know
[01:00:19] <shachaf> Oh.
[01:00:25] *** Joins: jroll (jroll@moz-5989BB9E.members.linode.com)
[01:00:28] *** Joins: mhordecki (mhordecki@moz-BE33DA21.fw1.sfo1.mozilla.net)
[01:00:35] <shachaf> I was trying to figure out what the actual rules for an identifier are.
[01:00:36] <graydon> shachaf: we use std::unicode
[01:00:49] <graydon> extra::unicode was an abandoned attempt to bind to libICU
[01:01:04] <graydon> we might bind to it again sometime, but for the time being we're using self-generated data tables
[01:01:08] <shachaf> Oh, I see. OK.
[01:01:21] <shachaf> That's what I get for relying on grep, I suppose.
[01:01:25] <graydon> sorry :(
[01:01:31] <graydon> we should remove extra::unicode
[01:01:35] * strcat thought about experimenting with libclang to do C AST -> Rust AST
[01:01:54] <aatch> strcat, doomlord was doing something like that I think.
[01:02:04] <kmc> C++ guarantees that constructing a pointer to the element after tha last element is OK, but not that dereferencing that pointer is allowed, correct?
[01:02:11] <strcat> kmc: right
[01:02:16] <strcat> kmc: and 2 past the end is undef :)
[01:02:50] <strcat> also I don't think C makes that one-past-the-end guarantee
[01:02:51] <strcat> only C++
[01:02:52] <engla> strcat: it's updated
[01:02:58] <engla> strcat: C does
[01:03:23] <strcat> hm
[01:04:17] <strcat> pdfs are really annoying
[01:05:22] <kmc> C99 also has the very obscure int x[static 5] syntax, which is a promise to the compiler that all 5 elements of x can be dereferenced
[01:05:45] <kmc> normally you are allowed to pass an int[2] as an int[5], as long as the code which receives it will only use the first 2 elements
[01:05:59] <kmc> I don't think I've ever seen this feature used in the wild...
[01:06:15] <engla> I don't think gcc implements any use of it either
[01:06:27] <cmr> I think clang does
[01:06:32] *** Quits: stepancheg (Mibbit@A92127F4.E98F9600.51A714DB.IP) (Quit: http://www.mibbit.com ajax IRC Client)
[01:06:37] <cmr> it at least has a warning if you pass wrongly-sized arrays
[01:06:37] <kmc> it is probably the most obscure C feature that I know about :)
[01:06:43] <engla> it does allow you to annotate that a pointer should not be null
[01:06:45] <kmc> (anyone have a better one?)
[01:07:09] *** Quits: brson (brson@moz-BBE3ABD.mv.mozilla.com) (Ping timeout)
[01:07:13] *** Quits: mhordecki (mhordecki@moz-BE33DA21.fw1.sfo1.mozilla.net) (Ping timeout)
[01:07:36] *** Quits: Uther (Instantbir@moz-1B244B05.hfc.dyn.abo.bbox.fr) (Ping timeout)
[01:08:43] *** Joins: mhordecki (mhordecki@moz-BE33DA21.fw1.sfo1.mozilla.net)
[01:09:07] <engla> kmc: I hope to find a use for named function parameters in C :)  https://gist.github.com/anonymous/bcc22417f3aee038e8c2
[01:09:27] <strcat> kmc: well C++ has an endless list of those :), C not so much
[01:09:31] <strcat> templated bitfields!
[01:09:56] <strcat> although there are plenty of weird things like * being a no-op on a function name in C
[01:10:15] <kmc> engla: haha, awesome
[01:10:25] <kmc> Boost has a whole terrifying library for named function args (and also named template args)
[01:10:28] <kmc> in C++ of course
[01:10:36] <cmr> I've looked at some of the boost code
[01:10:38] <cmr> it melted my brain
[01:10:40] *** Joins: jmgrosen (jmgrosen@moz-848F6087.sb.sd.cox.net)
[01:10:42] <cmr> I'm still in recovery :(
[01:10:51] *** Joins: FrozenCow (FrozenCow@moz-B2DF4929.chello.nl)
[01:11:00] <engla> you try to read it and understand it.. but it's boost all the way down
[01:11:07] <kmc> strcat: what do you mean by templated bitfields
[01:11:16] *** Quits: FrozenCow (FrozenCow@moz-B2DF4929.chello.nl) (Quit: Leaving)
[01:11:54] *** Quits: thomaslee (thomaslee@moz-6C3931E3.static.twtelecom.net) (Client exited)
[01:12:51] <strcat> template<size_t A, size_t B, size_t C> struct foo { uint8_t bar: A; uint8_t baz: B; uint8_t foobar: C; };
[01:14:28] <strcat> kmc: ^
[01:14:40] <kmc> wow
[01:15:15] <strcat> I don't really know *why*
[01:15:28] <shachaf> "why not" seems like a reasonable reason.
[01:19:16] <tikue> what can go in a RWARC?
[01:19:56] *** Quits: infynyxx (infynyxx@DB780A29.749BA1D.DCC373F0.IP) (Client exited)
[01:20:00] *** Joins: sankha93 (Instantbir@7061CD01.D6BD0D91.22D41759.IP)
[01:20:41] *** Quits: jmgrosen (jmgrosen@moz-848F6087.sb.sd.cox.net) (Quit: jmgrosen)
[01:21:54] *** Joins: henrikhodne (henrikhodn@moz-F3A92B1C.hsd1.ca.comcast.net)
[01:23:05] *** Quits: jdm (jdm@92FB48CA.8B5E9DF.9A8C35B4.IP) (Quit: Lost terminal)
[01:24:08] *** Quits: azakai (alon@moz-BBE3ABD.mv.mozilla.com) (Ping timeout)
[01:27:11] *** Quits: q66 (q66@6EE9DE40.46454B5D.33AABD5F.IP) (Quit: Leaving)
[01:27:12] <enix> If I rebase a pull request, what does that do to comments that people have already left on changes in that pull request?
[01:27:21] <cmr> enix: removes them
[01:27:27] <cmr> as the old commit is no longer part of the PR
[01:27:29] <cmr> They're still there
[01:27:31] <cmr> you just can't see them
[01:27:35] <strcat> line comments are still attached to the PR
[01:27:37] <cmr> I think github marks it as a discussion on an outdated diff
[01:27:50] <strcat> commit comments are no longer kept attached
[01:28:31] *** Quits: mhordecki (mhordecki@moz-BE33DA21.fw1.sfo1.mozilla.net) (Quit: mhordecki)
[01:29:43] <enix> ok, brson commened on my pull request to update the Sha2 code that there are two competing Md5 implementation now. I figured that the easiest thing to do is to rebase out my Md5 implementation and let that discussion take a different path
[01:30:05] <enix> since, I think the rest of the changes have value and stand on their own. however, it looks like i'll remove the existing comments
[01:30:24] <enix> whats the best thing to do here? rebase stuff out and then post a new comment of my own with summaries of the comments that got knocked out?
[01:33:41] *** Quits: sankha93 (Instantbir@7061CD01.D6BD0D91.22D41759.IP) (Quit: Gone to save the world!)
[01:33:58] <strcat> enix: that sounds fine
[01:34:09] <strcat> github should really keep non-line comments too
[01:34:25] *** Joins: ghrust (ghrust@614D05BD.6A2AE50.F3114085.IP)
[01:34:25] <ghrust> 01[13rust01] 15bors 04force-pushed 06auto from 14b9d8971 to 14bb996bf: 02http://git.io/N3iJvQ
[01:34:25] *** Parts: ghrust (ghrust@614D05BD.6A2AE50.F3114085.IP) ()
[01:34:27] *** Joins: ghrust (ghrust@614D05BD.6A2AE50.F3114085.IP)
[01:34:28] <ghrust> 01[13rust01] 15bors pushed 7 new commits to 06auto: 02http://git.io/ggpg8w
[01:34:28] <ghrust> 13rust/06auto 140bd293a 15toddaaro: A major refactoring that changes the way the runtime uses TLS. In the...
[01:34:28] <ghrust> 13rust/06auto 14215cfc0 15Ben Blum: Have linked failure tests run on the new scheduler instead of requiring RUST_NEWRT to test.
[01:34:28] <ghrust> 13rust/06auto 142f5e19e 15toddaaro: Fixed a race where a scheduler configured to only run tasks pinned to it would "bounch" a regular task in and out of the work queue without allowing a different scheduler to run it.
[01:34:31] *** Parts: ghrust (ghrust@614D05BD.6A2AE50.F3114085.IP) ()
[01:36:36] *** Quits: jclements (jclements@moz-41F46F5E.ptldme.east.myfairpoint.net) (Quit: jclements)
[01:38:05] *** Joins: ChrisMorgan (chris@moz-6AC741CA.static.tpgi.com.au)
[01:40:35] *** Quits: bent (chatzilla@moz-BE33DA21.fw1.sfo1.mozilla.net) (Quit: ChatZilla 0.9.90.1-rdmsoft [XULRunner 22.0/20130619132145])
[01:41:52] *** Quits: Axord (xord@moz-C3CCF156.lsanca.dsl-w.verizon.net) (Quit: I'm sure it's perfectly safe)
[01:43:57] <tikue> was RWArc added recently?
[01:44:43] <strcat> it was just recently renamed from all-caps
[01:45:10] *** Quits: carllerche (carllerche@moz-BF6CB667.hsd1.ca.comcast.net) (Quit: carllerche)
[01:45:50] <engla> now with 40% less caps
[01:46:12] <graydon> I found that renaming a little weird
[01:46:25] <graydon> Read Write Atomically Reference Counted
[01:46:33] <graydon> it's a full acronym
[01:46:39] <graydon> shouldn't it be Rwarc?
[01:47:16] <graydon> (or *cough* a name that can be pronounced?)
[01:47:26] *** Joins: bjz_ (brendanzab@B398BE78.F804C29E.D35A31DF.IP)
[01:47:27] *** Quits: bjz (brendanzab@B398BE78.F804C29E.D35A31DF.IP) (Connection reset by peer)
[01:48:01] <cmr> Rwarc is easy to pronounce!
[01:48:07] <cmr> Are you not a pterodactyl?
[01:48:27] <strcat> we have Rc/RcMut
[01:48:33] <strcat> maybe SendRc or something similar
[01:49:55] <graydon> SCRAWWK!
[01:49:59] *** Quits: SiegeLord (sl@moz-CAF07B4C.hsd1.ma.comcast.net) (Connection reset by peer)
[01:50:10] <graydon> of course I'm a pterodactyl
[01:50:13] <graydon> gosh
[01:50:13] *** Joins: doomrobo (doomrobo@EC9C662A.161AAEB2.58B1C2DD.IP)
[01:50:35] <graydon> in canada they won't let you near a computer if you're not
[01:50:44] <tikue> @mut stuff can't go in RWArc right?
[01:50:54] *** Quits: jgilbert (jgilbert@moz-7B0110AD.mv.mozilla.com) (Ping timeout)
[01:51:47] *** Quits: mihneadb (mihneadb@moz-BE33DA21.fw1.sfo1.mozilla.net) (Ping timeout)
[01:51:52] <bjz_> Jeaye slaren: noise lib! https://github.com/bjz/noise-rs
[01:52:01] <Jeaye> GAH, the noise!
[01:52:04] *** Joins: mihneadb (mihneadb@moz-BE33DA21.fw1.sfo1.mozilla.net)
[01:52:04] <doomrobo> what is the type of, say, fn x() -> int  if I wanted to pass x as an argument to another function? The compiler is complaining that it's some "extern Rust" function
[01:52:09] <bjz_> ahhhhhgr noise
[01:52:25] <bjz_> Jeaye: still more to implement
[01:52:35] <bjz_> Jeaye: help is welcome
[01:52:43] *** Quits: doomrobo (doomrobo@EC9C662A.161AAEB2.58B1C2DD.IP) (Quit: Leaving)
[01:52:49] <Jeaye> I'll take a look when I get home. :D
[01:52:54] <cmr> doomlord: extern "Rust" fn() -> int
[01:53:00] <cmr> Oh doomrobo left
[01:53:04] *** Joins: doomrobo (doomrobo@EC9C662A.161AAEB2.58B1C2DD.IP)
[01:53:06] <doomrobo> whoops
[01:53:10] <cmr> doomrobo: extern "Rust" fn() -> int
[01:53:10] <bjz_> Jeaye: you can do [x, y, z].perlin(ctx)
[01:53:23] <engla> doomrobo: it's just named extern, it's a normal function
[01:54:07] <doomrobo> Is there any way I can make a function accept any type of function that matches the type signature fn () -> int regardless of whether it's static, a closure, extern, etc.?
[01:54:08] <bjz_> Jeaye: or (x, y, z).perlin(ctx)
[01:54:25] *** Joins: alisdair (textual@1697D94C.7742FB18.FBC8476D.IP)
[01:54:27] <strcat> doomrobo: you can borrow any of them as &fn
[01:54:33] <cmr> doomrobo: &fn
[01:54:57] <Jeaye> bjz_: Great work so far, mate. :)
[01:54:57] <cmr> Specifically &'static fn, but that's unimportant
[01:55:03] <doomrobo> that just gives me &extern "Rust" fn...
[01:55:22] <engla> doomrobo: take a parameter of type &fn() -> int
[01:56:11] <doomrobo> ok
[01:56:17] <bjz_> Jeaye: that way you can either implement Perlin for you own types, or it'd work with an .as_fixed or .as_tuple method in a maths lib, if you want things more modular
[01:57:07] <doomrobo> engla it's giving me "illegal anonymous lifetime"
[01:57:09] *** Joins: test57842 (Mibbit@moz-F0840C28.dynamic.jazztel.es)
[01:57:12] *** Joins: SiegeLord (sl@moz-CAF07B4C.hsd1.ma.comcast.net)
[01:57:24] <bjz_> Jeaye: ofc you can also do: PerlinContext.gen2(x, y)
[01:57:39] *** Quits: tjc (tjc@moz-BBE3ABD.mv.mozilla.com) (Quit: Places to go, people to annoy)
[01:57:56] <Jeaye> bjz_: Yeah, definitely.
[01:58:12] *** Quits: test57842 (Mibbit@moz-F0840C28.dynamic.jazztel.es) (Quit: http://www.mibbit.com ajax IRC Client)
[01:58:44] <engla> doomrobo: if you are storing or returning a &fn it needs a lifetime parameter
[01:59:19] *** Quits: goffrie (goffrie@moz-1A2DE2C4.dsl.ncf.ca) (Ping timeout)
[02:00:47] <doomrobo> engla I'm truly lost. It's in a type definition, not a function. And I'm getting the error everywhere now. I'll post the code
[02:02:12] <engla> ok, I heard you wanted to pass it as a function argument. then &fn()->int is sufficient
[02:03:06] <cmr> rusti: fn foo(f: &fn() -> int) -> int { f() }; foo(|| 5)
[02:03:07] -rusti- 5
[02:03:15] <doomrobo> here it is, I'm sure I'm making a very simple mistake: https://gist.github.com/doomrobo/41f95da6ea376cdd1cd0
[02:03:22] <cmr> rusti: fn foo(f: &fn() -> int) -> int { f() }; fn bar() -> int { 42 } foo(bar)
[02:03:22] -rusti- 42
[02:03:54] <engla> doomrobo: in types you need a lifetime. in SpecialFunction and in enum Lisptype, you must have lifetimes on &fn
[02:04:24] *** Joins: ghrust (ghrust@5FEF1C87.6A2AE50.F3114085.IP)
[02:04:24] <ghrust> 01[13rust01] 15bors 04force-pushed 06auto from 14750acc0 to 14bb996bf: 02http://git.io/N3iJvQ
[02:04:24] *** Parts: ghrust (ghrust@5FEF1C87.6A2AE50.F3114085.IP) ()
[02:04:24] *** Joins: ghrust (ghrust@2EE61FCC.6A2AE50.F3114085.IP)
[02:04:24] <ghrust> 01[13rust01] 15bors pushed 12 new commits to 06auto: 02http://git.io/anO-JQ
[02:04:24] <ghrust> 13rust/06auto 144b2931c 15blake2-ppc: iterator: implement DoubleEndedIterator for FlatMap
[02:04:24] <ghrust> 13rust/06auto 145d4af58 15blake2-ppc: iterator: implement size_hint() for FlatMap
[02:04:25] <ghrust> 13rust/06auto 14630627c 15blake2-ppc: std: Implement RandomAccessIterator for iterator adaptors...
[02:04:27] *** Parts: ghrust (ghrust@2EE61FCC.6A2AE50.F3114085.IP) ()
[02:04:43] *** Joins: bytbox (s@moz-DC83764A.washdc.fios.verizon.net)
[02:04:59] <engla> all builds are failing except my PRs? ehxcellent, plan is coming together
[02:05:26] <cmr> heh
[02:05:57] <doomrobo> engla so do I make it <'self>?
[02:06:11] <engla> yes, 'self is the liftime parameter for types
[02:06:15] *** Quits: geomyidae (cole@DD6F7E3A.21468E9A.30200F38.IP) (Client exited)
[02:06:26] <cmr> Typedefs can't contain parameterization though
[02:06:27] <engla> type SpecialFunction<'self> = &'self fn( ... ) ...
[02:06:29] <cmr> I think it needs to be 'static
[02:06:34] <cmr> engla: they can?
[02:06:36] <engla> yes
[02:06:43] <cmr> rusti: type Foo<'self> = &'self fn();
[02:06:45] -rusti- ()
[02:06:48] <cmr> !
[02:07:15] <engla> it's useful
[02:07:31] <engla> pub type RevIterator<'self, T> = Invert<VecIterator<'self, T>>;
[02:07:54] *** Quits: dbp (user@moz-72A193C2.ri.ri.cox.net) (Ping timeout)
[02:07:54] *** Joins: geomyidae (cole@DD6F7E3A.21468E9A.30200F38.IP)
[02:08:00] * strcat did that out of laziness
[02:08:14] <engla> no it's good. the vec iterators are going to be reused
[02:08:24] <doomrobo> engla why am I getting that error on line 30, though?
[02:08:26] *** Quits: heftig (heftig@8D5076D2.6FC4DE2F.FEC4A986.IP) (Quit: Quitting)
[02:08:46] <strcat> engla: yeah I didn't feel like updating the users :)
[02:08:52] <strcat> with something uglier
[02:09:24] <engla> it's good to have a nice implementation like that for vec. it's reused in hashmap and probably will be in user libraries
[02:09:27] <engla> user code
[02:09:28] <engla> so
[02:09:49] <engla> doomrobo: I think it's all the same issue with missing lifetime parameters
[02:10:26] <doomrobo> engla it's not a reference, I'm doing Either<~LispType, @LispType>, there is no anonymous lifetime there
[02:10:59] <engla> but the type itself contains a reference, a &'self fn
[02:11:16] *** Joins: eatkinson (eatkinson@moz-BBE3ABD.mv.mozilla.com)
[02:11:33] <engla> maybe you should prototype this with &'static fn
[02:11:46] <engla> to get rid of the lifetime parameters, because you hardcode it to 'static
[02:11:49] <doomrobo> tried it. It's not static, it's extern "Rust"
[02:12:05] <engla> what's "it"?
[02:12:20] <doomrobo> the functions that I pass
[02:12:38] <doomrobo> they're defined globally, they're extern "Rust" and &'static doesn't work
[02:12:43] <engla> ok you can use extern "Rust" fn() if you want.
[02:12:57] <engla> it can also be converted to &'static fn() if you wnat
[02:13:04] <doomrobo> how?
[02:13:38] *** Joins: carllerche (carllerche@6B070D22.7E6A0813.1428D117.IP)
[02:14:04] <engla> rusti:  fn  takes_function(f: &'static fn()) { f() }   fn sayhi() { println("hi"); }   takes_function(sayhi)
[02:14:04] -rusti- hi
[02:14:04] -rusti- ()
[02:14:13] <engla> you just pass the function (sayhi)
[02:14:19] <engla> to a function that takes &'static fn()
[02:14:36] <ChrisMorgan> There, I got a bit more benchmark comparison with my HTTP server: http://hg.chrismorgan.info/rusthttpserver/file/8d9dc6b21568/comparisons/README.txt
[02:14:45] <doomrobo> hm
[02:14:51] <doomrobo> didn't work for me but I'll try again
[02:15:00] <engla> doomrobo: anyway, &fn is the wrong thing to write in your type
[02:15:01] <ChrisMorgan> And implementing HTTP connection keep-alive was pleasantly easy.
[02:15:05] <engla> it's not allowed
[02:16:40] *** Joins: bnicholson (bnicholson@moz-835D504A.rcmdva.fios.verizon.net)
[02:16:43] <cmr> "4GB ("plenty") of RAM "
[02:16:46] <cmr> ChrisMorgan: nice touch :p
[02:16:54] <doomrobo> ok, I gotta go. Thanks engla
[02:16:57] *** Quits: doomrobo (doomrobo@EC9C662A.161AAEB2.58B1C2DD.IP) (Quit: c ya)
[02:17:21] <engla> you are welcome
[02:18:02] *** Joins: snadon (chatzilla@moz-3BC727E8.mc.videotron.ca)
[02:19:52] <ChrisMorgan> cmr: well, 4GB is plenty for running normal things, even an HTTP server which uses 5MB of RAM. Compiling Rust while having Firefox open with a large session and a few other things also doesn't go quite so well.
[02:21:01] *** Joins: jclements (jclements@moz-30E31CA7.port.east.myfairpoint.net)
[02:22:26] *** Quits: eatkinson (eatkinson@moz-BBE3ABD.mv.mozilla.com) (Quit: eatkinson)
[02:27:37] *** Quits: alisdair (textual@1697D94C.7742FB18.FBC8476D.IP) (Quit: My MacBook Pro has gone to sleep. ZZZzzzâ€¦)
[02:29:10] <strcat> strange
[02:29:20] <strcat> afaik the take glue for fixed-size vectors issue was fixed
[02:29:23] <strcat> afaict*
[02:37:39] *** Quits: graydon (graydon@moz-F14EE0DB.cable.teksavvy.com) (Quit: Leaving.)
[02:37:44] *** Joins: eatkinson (eatkinson@moz-BBE3ABD.mv.mozilla.com)
[02:42:37] *** Joins: Jesse (jruderman@moz-537BCF9.hsd1.ca.comcast.net)
[02:43:07] *** Joins: granowski (granowski@moz-EF356C3A.dhcp.stcd.mn.charter.com)
[02:44:19] *** Quits: jclements (jclements@moz-30E31CA7.port.east.myfairpoint.net) (Ping timeout)
[02:44:22] *** Joins: goffrie (goffrie@moz-1A2DE2C4.dsl.ncf.ca)
[02:44:39] <granowski> ls
[02:44:46] <granowski> ha ha... wrong window...
[02:45:16] <klutzy> Permission denied
[02:45:20] <granowski> Hello rust channel.
[02:45:48] *** Joins: jclements (jclements@EA0A4ADC.CC740DDB.4B322BB7.IP)
[02:49:07] *** Quits: zz_kimundi (kimundi@moz-99C29C81.dip0.t-ipconnect.de) (Ping timeout)
[02:51:00] *** Quits: RMF (RMF@moz-6AD5ED61.dsl.telepac.pt) (Ping timeout)
[02:51:17] <granowski> Is there anyone that may have compiled the rust compiler to run on a mips host?
[02:52:25] *** Joins: zz_kimundi (kimundi@moz-78A866D7.dip0.t-ipconnect.de)
[02:52:46] *** zz_kimundi is now known as kimundi
[02:53:02] *** Quits: SiegeLord (sl@moz-CAF07B4C.hsd1.ma.comcast.net) (Quit: It's a joke, it's all a joke.)
[02:53:03] *** Quits: eatkinson (eatkinson@moz-BBE3ABD.mv.mozilla.com) (Quit: eatkinson)
[02:54:26] *** Joins: RMF (RMF@76B3729C.4FA74685.8D19547B.IP)
[02:54:40] *** Joins: ross (ross@moz-8A84103E.br.br.cox.net)
[02:58:52] <tikue> rusti: let mut a = 1; let mut foo = Some(a); let b = foo.get_ref(); foo = Some(2); b
[02:58:53] -rusti- more than 5 lines of output, pastebinned: http://sprunge.us/YMOO
[02:59:17] <tikue> rusti: let mut a = 1; let mut foo = Some(a); let b = foo.get(); foo = Some(2); b
[02:59:18] -rusti- more than 5 lines of output, pastebinned: http://sprunge.us/jAdh
[03:00:34] *** Joins: eatkinson (eatkinson@moz-BBE3ABD.mv.mozilla.com)
[03:01:24] *** Quits: eholk (eholk@moz-94A2F911.uconnect.utah.edu) (Quit: eholk)
[03:01:50] <tikue> rusti: let mut a = 1; let mut foo = Some(a); let b = &foo.get(); (b, foo)
[03:01:51] -rusti- more than 5 lines of output, pastebinned: http://sprunge.us/beej
[03:05:47] <ChrisMorgan> tikue: get_ref is right, just due to the way rusti works it won't work, as `a` passes out of scope. To demonstrate that yes, it does actually work, turn it straight into a string:
[03:05:47] <ChrisMorgan> rusti: let a = 1; let foo = Some(a); let b = foo.get_ref(); fmt!("%?", (b, foo))
[03:05:48] -rusti- ~"(&1, Some(1))"
[03:06:54] <tikue> ChrisMorgan: thanks -- I was actually also wondering if foo.get_ref() always referred to the thing inside the option, or if it always referred to the pointer to the thing in the option at the time it's called. so if you get_ref(), then change Foo, will what happens
[03:07:28] <Eridius> tikue: you can't change foo while you have the ref from get_ref
[03:07:30] <Eridius> since it's been borrowed
[03:07:39] <tikue> Eridius: ah that makes sense. Thank you!
[03:07:46] <ChrisMorgan> tikue: &x is a reference but not a mutable reference. To modify it thus it'd need to be &mut x
[03:08:32] <tikue> ChrisMorgan: I didn't want to modify the variable to &x -- I wanted to modify x while someone had a pointer to the inside. which obviously wouldn't compile :P
[03:08:44] <ChrisMorgan> (Thus, you can't change what's inside foo from b, nor, as Eridius points out, can you modify foo while b is borrowed as an immutable pointer.)
[03:08:49] <ChrisMorgan> s/pointer/reference/
[03:13:37] *** Quits: enix (enix@moz-A50569DD.c3-0.slvr-ubr1.lnh-slvr.md.cable.rcn.com) (Quit: Konversation terminated!)
[03:13:44] *** Joins: enix (enix@moz-A50569DD.c3-0.slvr-ubr1.lnh-slvr.md.cable.rcn.com)
[03:23:47] <ChrisMorgan> ~o cannot modify o while there exists an &o, and &o and &mut o may not co-exist for the same reason.
[03:29:39] *** Joins: hjr3 (hradtke@moz-E87BDF1F.socal.res.rr.com)
[03:30:30] *** Quits: eatkinson (eatkinson@moz-BBE3ABD.mv.mozilla.com) (Connection reset by peer)
[03:30:34] *** Joins: eatkinson (eatkinson@moz-BBE3ABD.mv.mozilla.com)
[03:34:32] <strcat> rusti: @5
[03:34:32] -rusti- @5
[03:34:34] <strcat> rusti: @mut 5
[03:34:35] -rusti- @5
[03:34:41] <strcat> rusti: (@mut 5,)
[03:34:41] -rusti- (@mut 5,)
[03:34:54] <sam113101> rusti: nigga
[03:34:54] -rusti- <anon>:5:9: 5:14 error: unresolved name `nigga`.
[03:34:54] -rusti- <anon>:5          nigga
[03:34:54] -rusti-                   ^~~~~
[03:34:54] -rusti- error: aborting due to previous error
[03:34:55] -rusti- application terminated with error code 101
[03:35:31] <sam113101> rusti: let nigga = (); nigga
[03:35:31] -rusti- ()
[03:43:21] *** Joins: jmgrosen (jmgrosen@moz-848F6087.sb.sd.cox.net)
[03:43:36] *** Quits: Kruppe (user@moz-E150F49F.cpe.net.cable.rogers.com) (Client exited)
[03:43:47] *** Quits: carllerche (carllerche@6B070D22.7E6A0813.1428D117.IP) (Quit: carllerche)
[03:43:57] *** Quits: IRCMonkey42159 (simon@moz-CBE4BB13.cable.teksavvy.com) (Quit: WeeChat 0.4.2-dev)
[03:46:22] *** Joins: ghrust (ghrust@2EE61FCC.6A2AE50.F3114085.IP)
[03:46:22] <ghrust> 01[13rust01] 15bors merged 06auto into 06master: 02http://git.io/anO-JQ
[03:46:22] *** Parts: ghrust (ghrust@2EE61FCC.6A2AE50.F3114085.IP) ()
[03:46:44] <ChrisMorgan> I'm wanting to alter my header reader to use an iterator, but I need to be able to access the error at the end (could be EOF -> abort request, end of headers -> good, malformed header -> 400 Bad Request). What should I do?
[03:46:48] *** Quits: Jesin (Jessin_@moz-1B1307FF.eecs.lehigh.edu) (Ping timeout)
[03:50:42] *** Joins: infynyxx (infynyxx@DB780A29.749BA1D.DCC373F0.IP)
[03:51:38] <ChrisMorgan> The three main options I see are (a) conditions, and (b) setting something like request.header_failure as Option<HeaderLineErr> which would then be set by the iterator at the end, and (c) not using an iterator after all (it's internal code, anyway, so implementing Iterator doesn't really add anything)
[04:00:14] *** Joins: jensnockert (jensnocker@moz-C5F27039.cust.bredband2.com)
[04:01:30] *** Quits: joshua_ (joshua@moz-45967CBE.emarhavil.com) (Ping timeout)
[04:02:20] *** Quits: engla (engla@moz-DBD1D96E.cust.bredbandsbolaget.se) (Connection reset by peer)
[04:02:52] <jensnockert> Is there any way to get the buildbots to build something, without having to make a PR?
[04:02:59] *** Joins: engla (engla@moz-DBD1D96E.cust.bredbandsbolaget.se)
[04:03:25] <bjz_> jensnockert: https://github.com/mozilla/rust/pull/8115 ?
[04:03:48] <bjz_> jensnockert: and no idea
[04:04:42] <jensnockert> bjz_: I didn't add them because I didn't want to pollute the namespace too much in the beginning, but adding them makes sense.
[04:04:56] <ChrisMorgan> Rust convention: MD5 or Md5?
[04:05:21] *** Joins: joshua_ (joshua@moz-45967CBE.emarhavil.com)
[04:05:57] <jensnockert> ChrisMorgan: It's Json in libextra I think.
[04:06:39] <ChrisMorgan> Yes, and Md5 is what I believe to be consistent with the convention.
[04:06:54] <ChrisMorgan> Then, another one: the HTTP header ETag: ETag or Etag?
[04:07:43] <strcat> jensnockert: what do you want to build?
[04:08:01] *** Quits: km (quassel@FDBAF0A0.DBF71E41.29C67456.IP) (Ping timeout)
[04:08:01] <strcat> it can build branches from the repo
[04:08:11] <strcat> manually
[04:08:45] <jensnockert> strcat: I want to test some libc fixes soon, and I don't have a Linux / Windows system around right now.
[04:09:56] *** Joins: km (quassel@FDBAF0A0.DBF71E41.29C67456.IP)
[04:11:52] *** Quits: james4k (james@moz-E7990244.consolidated.net) (Ping timeout)
[04:12:09] <strcat> hm
[04:12:22] *** Joins: james4k (james@moz-E7990244.consolidated.net)
[04:20:37] *** Joins: recrack (Mibbit@B4104EBB.3CC170B1.1E14B209.IP)
[04:21:40] *** Quits: mihneadb (mihneadb@moz-BE33DA21.fw1.sfo1.mozilla.net) (Input/output error)
[04:22:14] *** Joins: mib_yh3o0u (Mibbit@365CCC0.FBED534.2D4378B7.IP)
[04:22:24] *** Joins: int3_ (int3_@moz-ABE52D50.hsd1.ca.comcast.net)
[04:22:34] *** tikue is now known as tikue_dinner
[04:26:35] <bjz_> strcat: hum
[04:26:41] *** Quits: infynyxx (infynyxx@DB780A29.749BA1D.DCC373F0.IP) (Client exited)
[04:27:45] <strcat> rusti: let x: *int = &5; let y: *const int = x; y
[04:27:46] -rusti- 139720286013336
[04:27:50] *** Quits: km (quassel@FDBAF0A0.DBF71E41.29C67456.IP) (Ping timeout)
[04:28:15] *** Joins: km (quassel@FDBAF0A0.DBF71E41.29C67456.IP)
[04:28:16] *** Quits: jclements (jclements@EA0A4ADC.CC740DDB.4B322BB7.IP) (Ping timeout)
[04:28:24] *** Quits: tikue_dinner (tkuehn@moz-BBE3ABD.mv.mozilla.com) (Quit: tikue_dinner)
[04:28:42] *** Joins: Uther (Instantbir@moz-1B244B05.hfc.dyn.abo.bbox.fr)
[04:29:48] *** Joins: jclements (jclements@moz-E302280F.ngn.east.myfairpoint.net)
[04:31:42] <jensnockert> strcat: Do you know how I would trigger a build for https://github.com/jensnockert/rust/tree/fix-fd-seek ?
[04:31:49] *** Quits: Jeaye (Jeaye@moz-FD505E54.hsd1.ca.comcast.net) (Quit: zzz)
[04:31:52] <jensnockert> And/or could you do it?
[04:32:24] *** Joins: tikue (tkuehn@moz-BBE3ABD.mv.mozilla.com)
[04:34:38] *** Quits: henrikhodne (henrikhodn@moz-F3A92B1C.hsd1.ca.comcast.net) (Ping timeout)
[04:35:23] <aatch> jensnockert, do you have commit access to mozilla/rust?
[04:35:31] <jensnockert> aatch: No.
[04:35:41] *** Quits: jclements (jclements@moz-E302280F.ngn.east.myfairpoint.net) (Ping timeout)
[04:35:41] *** Quits: tikue (tkuehn@moz-BBE3ABD.mv.mozilla.com) (Quit: tikue)
[04:35:46] *** Joins: ghrust (ghrust@F6EE6DE3.6A2AE50.F3114085.IP)
[04:35:46] <ghrust> 01[13rust01] 15thestinger 04force-pushed 06try from 144d6ee64 to 142830d7d: 02http://git.io/k471pw
[04:35:46] *** Parts: ghrust (ghrust@F6EE6DE3.6A2AE50.F3114085.IP) ()
[04:36:00] <strcat> huh
[04:36:40] *** Joins: ghrust (ghrust@614D05BD.6A2AE50.F3114085.IP)
[04:36:41] <ghrust> 01[13rust01] 15thestinger 04force-pushed 06try from 142830d7d to 14ad7a189: 02http://git.io/k471pw
[04:36:41] <ghrust> 13rust/06try 14ad7a189 15Jens Nockert: Fix lseek, off_t...
[04:36:41] *** Parts: ghrust (ghrust@614D05BD.6A2AE50.F3114085.IP) ()
[04:37:02] *** Quits: james4k (james@moz-E7990244.consolidated.net) (Ping timeout)
[04:37:02] * jensnockert hugs aatch.
[04:37:04] <strcat> jensnockert: not sure if the try bots still work
[04:37:06] <strcat> we'll see
[04:37:06] *** Joins: jclements (jclements@moz-E8FE2BCB.burl.east.myfairpoint.net)
[04:37:12] * jensnockert hugs strcat.
[04:37:25] *** Joins: jdm (jdm@92FB48CA.8B5E9DF.9A8C35B4.IP)
[04:37:41] <strcat> uh
[04:37:42] <strcat> the UI changed
[04:37:44] <strcat> wat
[04:37:58] <aatch> strcat, updated version of buildbot
[04:38:15] <strcat> can we still force builds?
[04:38:21] <strcat> try doesn't automatically build anymore
[04:39:34] <aatch> strcat, give it a minute
[04:39:41] <strcat> I know it doesn't ;p
[04:39:53] <ChrisMorgan> I'm dealing with byte representations of characters (i.e. type == u8). Is there any way I can use sane things in my code, e.g. 'G' rather than 71, yet have no runtime inefficiency?
[04:40:11] <sp3d> rusti: 'G' as u8
[04:40:12] -rusti- 71
[04:40:21] <aatch> ChrisMorgan, x as u8, if x is a constant, it does the cast at compile time
[04:40:29] <ChrisMorgan> That's what I was about to askâ€”that would be resolved at compile time, good.
[04:40:54] <strcat> aatch: zero-size types are weird as hell :[
[04:40:55] <aatch> ChrisMorgan, if you can put it in a static declaration, it's done at compile time.
[04:41:02] <aatch> strcat, yes, yes they are.
[04:41:14] <strcat> need to do something about how vectors handle zero-size types before pointer arithmetic can be fast
[04:41:24] <ChrisMorgan> Yeah, there's that option, too. But having a whole lot of static declarations like that doesn't exactly seem friendly.
[04:41:32] <strcat> also need to remove the Add/Sub impls for raw pointers, it can't work
[04:41:40] <strcat> because offsets need to be unsafe
[04:41:44] <strcat> for inbounds gep
[04:41:44] <jensnockert> strcat: We have zero-size types?
[04:41:47] <strcat> jensnockert: yep
[04:41:55] <strcat> rusti: std::sys::size_of::<()>()
[04:41:57] -rusti- 0
[04:42:03] <jensnockert> (), [u8, ..0] ?
[04:42:04] <strcat> rusti: struct Foo; std::sys::size_of::<Foo>()
[04:42:04] -rusti- 0
[04:42:17] <strcat> rusti: struct Foo; std::sys::size_of::<[u8, ..0]>()
[04:42:18] -rusti- 0
[04:42:34] <strcat> rusti: struct Foo; std::sys::size_of::<(((),),)>()
[04:42:35] -rusti- 0
[04:42:38] <jensnockert> I can see why [u8, ..0] is useful, but the others?
[04:42:50] <strcat> jensnockert: well () being zero-size means sets can be implemented as maps
[04:43:05] <strcat> and you can use unit structs as tags
[04:43:20] <aatch> ChrisMorgan, what I mean is that if an expression is valid in a static decl, then it will be evaluated at compile time, irrespective of whether it's in a static decl.
[04:43:32] <strcat> jensnockert: it's just weird because some things use non-zero size_of
[04:43:35] <aatch> since the constant evaluator just goes through all the expressions.
[04:43:39] <ChrisMorgan> Ah. That's what I expected, thanks.
[04:43:40] <jensnockert> strcat: I still don't understand why you would want to index into them :S
[04:43:43] <strcat> jensnockert: like, they clamp the minimum to 1
[04:43:53] <strcat> jensnockert: because vector iterators are a pair of pointers.
[04:43:54] <bjz_> what is the difference between saying "a set is closed _under_ a certain collection of operations" vs "a set is closed _over_ a certain collection of operations"
[04:43:56] <engla> strcat: most things shouldn't need to use nonzero size_of
[04:44:09] <strcat> ok so
[04:44:13] <strcat> if we had real pointer arithmetic
[04:44:18] <bjz_> jensnockert: ^?
[04:44:21] <strcat> let ptr: *T = &a;
[04:44:25] <strcat> ptr.offset(5)
[04:44:36] <jensnockert> bjz_: The same thing iirc.
[04:44:38] <strcat> if you passed an offset that went out-of-bounds of the object 'a'
[04:44:42] <strcat> it'd be a poison value
[04:44:48] <strcat> as in, anything reading it is undefined
[04:44:58] <strcat> you're allowed to go *one byte* past the end
[04:45:04] <jensnockert> bjz_: Closed under is what I believe is the normal terminology.
[04:45:13] <strcat> If the inbounds keyword is present, the result value of the getelementptr is a poison value if the base pointer is not an in bounds address of an allocated object, or if any of the addresses that would be formed by successive addition of the offsets implied by the indices to the base address with infinitely precise signed arithmetic are not an in bounds address of that allocated object. The in
[04:45:15] <strcat> bounds addresses for an allocated object are all the addresses that point into the object, plus the address one byte past the end. In cases where the base is a vector of pointers the inbounds keyword applies to each of the computations element-wise.
[04:45:23] <strcat> for now I'm not using inbounds.
[04:45:31] <strcat> but it will still be better than ptrtoint/inttoptr
[04:45:44] <strcat> because it doesn't throw away aliasing rules
[04:45:48] <bjz_> jensnockert: so I would say: "A vector space is a set that is closed over the vector addition and scalar multiplication"
[04:45:51] <engla> strcat: how does that handle pointers into structs?
[04:46:13] <jensnockert> bjz_: Err, waitâ€¦
[04:46:21] <bjz_> jensnockert: woops: "A vector space is a set that is closed under the operations of vector addition and scalar multiplication"
[04:46:22] <jensnockert> bjz_: I thought you reversed set / operations in those.
[04:46:29] <strcat> engla: well this is just pointer arith
[04:46:39] <strcat> it takes *T and increments by the size of T
[04:46:39] <bjz_> jensnockert: hum
[04:46:44] <strcat> well
[04:46:46] <bjz_> jensnockert: what should I say
[04:46:46] <strcat> T * count
[04:46:58] <engla> strcat: let's say  struct Foo { a: int, b: int }   let x = &f.a;  legal to increment it and dereference it to get b?
[04:47:03] <jensnockert> bjz_: A set is closed under a set of operations, A set of operations is closed over a set.
[04:47:15] <strcat> engla: no
[04:47:17] <engla> strcat: as a *int, of course.
[04:47:21] <strcat> engla: undefined behaviour
[04:47:26] <bjz_> jensnockert: is a vector space the collection of operations?
[04:47:49] <engla> strcat: well your text just says in bounds of _an_ allocated object. not the same
[04:47:54] <strcat> engla: &f.a is a ptr to an int, so it can *index* one byte past the end (it can point to b) but deref is always undef
[04:48:23] <strcat> engla: well... deref has different rules
[04:48:28] <strcat> that's just the rule for the address computation
[04:48:37] <strcat> the address computation has to point inside something valid
[04:48:40] <jensnockert> bjz_: A vector space is closed under vector addition and scalar multiplication.
[04:48:45] <strcat> or one byte past the end of something valid
[04:48:58] <engla> it sounds like the same as in the C std then strcat, but I didn't see that from the text
[04:49:01] <strcat> but a deref can only be done while it points inside the object it based *based* on
[04:49:14] <strcat> engla: that's the text for getelementptr, it does pointer arithmetic
[04:49:17] <strcat> engla: it doesn't deref
[04:49:21] <jensnockert> bjz_: Or more formally, a vector space V is a set that is closed under finite vector addition and scalar multiplication.
[04:49:22] <strcat> deref has much stricter rules
[04:49:34] <strcat> engla: http://llvm.org/docs/LangRef.html#pointer-aliasing-rules
[04:49:39] <bjz_> jensnockert: I have a book that says: "Vectors form a vector space; points form an affine space. Vectors are closed under linear combinations, points are closed under affine combinations"
[04:50:17] *** Quits: kini (kini@moz-92AA953A.members.linode.com) (Ping timeout)
[04:50:32] <jensnockert> bjz_: That is also true.
[04:50:33] <bjz_> jensnockert: just trying to get my doc comments correct
[04:50:37] <bjz_> :P
[04:50:54] *** Joins: kini (kini@moz-92AA953A.members.linode.com)
[04:50:58] <jensnockert> bjz_: But I find vector addition / scalar multiplication more intuitive.
[04:51:04] <bjz_> yup
[04:51:19] <jensnockert> bjz_: But linear combination is the same thing.
[04:54:28] *** Joins: pnathan (Adium@moz-BDC3EE62.tukw.qwest.net)
[05:00:47] <strcat> way too much code uses ptr::offset ;\
[05:01:26] <strcat> solution is probably to remove most of this crap
[05:02:00] * strcat hopes this compiles successfully and speeds up vec::from_elem by 5x
[05:02:01] *** Quits: mib_yh3o0u (Mibbit@365CCC0.FBED534.2D4378B7.IP) (Quit: http://www.mibbit.com ajax IRC Client)
[05:03:28] <strcat> jensnockert: well I can't figure out how to force builds with the new UI ;
[05:03:30] <strcat> ;\
[05:03:35] * jensnockert hugs.
[05:03:37] <strcat> oh wait
[05:03:39] <strcat> they started
[05:03:41] <strcat> magic!
[05:04:04] *** Quits: lmandel (lmandel@2B5B5FD9.7ECD71DF.ADB88A9.IP) (Ping timeout)
[05:04:43] <jensnockert> strcat: Link for the logs?
[05:04:48] <strcat> jensnockert: http://buildbot.rust-lang.org/builders/try-bsd/builds/418 http://buildbot.rust-lang.org/builders/try-linux/builds/529 http://buildbot.rust-lang.org/builders/try-win/builds/553
[05:04:52] <strcat> http://buildbot.rust-lang.org/builders/try-mac/builds/570
[05:05:23] <strcat> /home/strcat/projects/rust/src/librustc/metadata/loader.rs:218:48: 218:52 error: mismatched types: expected `int` but found `uint` (expected int but found uint)
[05:05:25] <strcat> :|
[05:05:26] *** Joins: tikue (tkuehn@moz-A7CDB794.dia.static.qwest.net)
[05:06:07] <jensnockert> ?
[05:07:30] <strcat> jensnockert: my problem, not yours :)
[05:07:59] <jensnockert> Oh, good.
[05:08:29] <jensnockert> I seriously hoped that people were not randomly using lseek in random parts of the compiler.
[05:09:28] <ChrisMorgan> rusti: match 71u8 { 'G' as u8 => true, _ => false }
[05:09:29] -rusti- <anon>:5:26: 5:28 error: expected `=>` but found `as`
[05:09:29] -rusti- <anon>:5          match 71u8 { 'G' as u8 => true, _ => false }
[05:09:29] -rusti-                                    ^~
[05:09:29] -rusti- application terminated with error code 101
[05:09:33] <ChrisMorgan> :-(
[05:09:44] *** Quits: granowski (granowski@moz-EF356C3A.dhcp.stcd.mn.charter.com) (Quit: Leaving)
[05:09:55] <ChrisMorgan> So I can't use `'G' as u8` as a match pattern :-(
[05:10:08] *** Quits: xenocons (otk@moz-C675529E.members.linode.com) (Ping timeout)
[05:10:56] <jensnockert> ChrisMorgan: Nope, and it sucks :(
[05:11:05] <bstrie> rusti: match 71u8 { ('G' as u8) => true, _ => false }
[05:11:06] -rusti- <anon>:5:27: 5:29 error: expected `,` but found `as`
[05:11:06] * jensnockert cannot match against FourCCs. :(
[05:11:06] -rusti- <anon>:5          match 71u8 { ('G' as u8) => true, _ => false }
[05:11:06] -rusti-                                     ^~
[05:11:06] -rusti- application terminated with error code 101
[05:11:14] <bstrie> rusti: match 71u8 { {'G' as u8} => true, _ => false }
[05:11:14] -rusti- <anon>:5:23: 5:26 error: expected ident, found `'G'`
[05:11:14] -rusti- <anon>:5          match 71u8 { {'G' as u8} => true, _ => false }
[05:11:14] -rusti-                                 ^~~
[05:11:14] -rusti- application terminated with error code 101
[05:11:26] <jensnockert> bstrie: We need constexprs :(
[05:11:40] <bstrie> rusti: match 71u8 as char { 'G' => true, _ => false }
[05:11:40] -rusti- true
[05:11:45] <bstrie> ChrisMorgan: ^ :P
[05:11:59] * ChrisMorgan will not deign to comment
[05:12:04] *** Joins: lmandel (lmandel@moz-AEAD2F61.dsl.bell.ca)
[05:12:34] <ChrisMorgan> rusti: static G: u8 = 'G' as u8; match 71u8 { G => true, _ => false }
[05:12:35] -rusti- true
[05:12:47] <strcat> ChrisMorgan: we essentially just need byte literals
[05:12:49] <strcat> for that to work
[05:12:54] <strcat> b'G'
[05:13:02] <strcat> or b!('G')
[05:13:03] <ChrisMorgan> Indeed. That's just what I was about to propose.
[05:13:19] <strcat> rusti: bytes!("foo")
[05:13:20] -rusti- &[102, 111, 111]
[05:13:23] <strcat> rusti: bytes!('c')
[05:13:23] -rusti- &[99]
[05:13:25] <engla> b!('G') is not allowed in match
[05:13:32] *** Joins: xenocons (otk@moz-C675529E.members.linode.com)
[05:13:40] <ChrisMorgan> Python uses '' or "" for unicode strings and b'' or b"" for byte strings.
[05:13:44] <jensnockert> strcat: Or constexprs!
[05:13:52] <strcat> ChrisMorgan: yep I know
[05:13:57] * jensnockert is trying to sell in constexprs.
[05:14:09] * jensnockert is promoting them as the solution to all evil.
[05:14:30] <strcat> jensnockert: first I want pointer arithmetic that's not slow >:)
[05:14:30] <ChrisMorgan> It'd be nice for Rust to have `b'x'` as equivalent to `'x' as u8` and `b"x"` as equivalent to `bytes!("x")`
[05:14:47] <dherman> jensnockert: pcwalton has been working on a solution to constexprs that sounds promising
[05:14:49] <jensnockert> strcat: Well, that's nice too.
[05:15:01] <jensnockert> dherman: He has!? He's amazing \o/
[05:15:08] * jensnockert hugs pcwalton even though he is not here.
[05:15:16] *** Joins: infynyxx (infynyxx@moz-E95B370B.nyc.res.rr.com)
[05:15:19] <dherman> languages have a bad habit of throwing them in in an ad hoc way, we want to do them in at least a quasi-principled way
[05:15:27] <strcat> https://paste.xinu.at/c1BC7/ my current attempt ;p
[05:15:32] <strcat> ideally it would use inbounds GEP
[05:15:41] <strcat> but... there are things I need to fix + offset would need to be unsafe
[05:16:08] * strcat hopes it can also close https://github.com/mozilla/rust/issues/7136
[05:16:13] <strcat> we'll see ;p
[05:16:16] *** Quits: jclements (jclements@moz-E8FE2BCB.burl.east.myfairpoint.net) (Ping timeout)
[05:16:32] <jensnockert> dherman: Sounds amazing.
[05:18:02] *** Joins: jaen (jaen@moz-9EAEEFB6.play-internet.pl)
[05:22:13] <strcat> 00715   // Disable loop idiom recognition if the function's name is a common idiom.
[05:22:18] <strcat> haha, loop-idiom is such a hack
[05:22:43] <strcat> obvious that it has to do that, but funny
[05:23:00] <strcat> it has to detect if it's optimizing memset to avoid outputting memset there ;]
[05:23:24] <jensnockert> Oh dearâ€¦
[05:24:20] <strcat> http://llvm.org/docs/doxygen/html/LoopIdiomRecognize_8cpp_source.html
[05:24:47] <strcat> processLoopMemSet is the relevant thing
[05:25:02] <strcat> just need to keep banging on vec::from_elem until it gets detected as such ;p
[05:25:23] *** Joins: cde (cde@moz-593D124F.rev.dedibox.fr)
[05:25:27] <cde> hi
[05:25:57] <cde> is there a project to port the rust compiler backend from llvm to a backend written in rust?
[05:26:14] <jensnockert> cde: Not that I know of.
[05:26:27] <strcat> it's not realistic to reimplement a high quality optimizing compiler
[05:26:30] <Eridius> why do that, when llvm is so damn useful?
[05:26:44] <jensnockert> Eridius: Because you can?
[05:27:01] <strcat> jensnockert: well, unlikely that you can ;]
[05:27:03] <cde> but so to compile a rust program I would need to compile llvm and for that a c++ front-end as well, like clang or gcc, which could introduce bugs in the backend
[05:27:17] <jensnockert> strcat: Writing a backend isn't hard, writing one as good as LLVM is.
[05:27:41] <sam113101> is rust for rubyists any good?
[05:27:48] <strcat> jensnockert: I don't really think it's easy to write a backend for a dozen architectures
[05:27:56] <cde> jensnockert: couldn't one port the llvm code to rust? the core algorithms must be a handful
[05:27:59] <Eridius> sam113101: I've heard people say good things about it, although I've never looked at it
[05:28:09] <jensnockert> cde: It's gazillions of lines though.
[05:28:13] <strcat> jensnockert: for an arch you know well and have access to, sure ;p
[05:28:15] <jensnockert> strcat: Just output C?
[05:28:29] <cde> jensnockert: if I can figure out which parts are really important, then maybe it would be doable
[05:28:30] <strcat> jensnockert: I guess ;)
[05:28:53] <strcat> cde: LLVM is a very big project
[05:29:06] <jensnockert> cde: Some chinese guys apparently rewrote parts of it in Java, so it is obviously doable. Just a _lot_ of work.
[05:29:26] <cde> yes. I understand it's probably unrealistic
[05:29:27] * jensnockert comments on that from the "rewrite ffmpeg in JS"-perspective.
[05:29:44] <cde> why would you rewrite ffmeg in js?
[05:29:57] <strcat> if you omit most of the passes, you could do it
[05:30:07] <jensnockert> cde: Because you cannot decode compressed audio in JS.
[05:30:15] <jensnockert> cde: (In a browser)
[05:30:21] <jensnockert> So I had to implement it.
[05:30:53] <cde> for the lulz! ;)
[05:30:54] <strcat> could just compile ffmpeg to js now ;]
[05:30:58] <kemurphy> anyone know why collect_record_or_struct_fields claims not to collect fields from struct-like enum variants? (in trans/_match.rs)
[05:30:59] <strcat> or asm.js
[05:31:13] * ChrisMorgan just wrote a work of art: http://sprunge.us/jSbg
[05:31:16] <jensnockert> strcat: When I did it, we didn't have asm.js, or emscripten.
[05:31:28] <jensnockert> We barely had typed arrays!
[05:31:29] <strcat> jensnockert: yeah, I guessed (thus "now" ;p)
[05:31:49] <strcat> ChrisMorgan: looks like ascii art
[05:32:01] <jensnockert> Firefox 4 was just released!
[05:32:04] <jensnockert> The good old days.
[05:32:06] <strcat> compile_and_link: x86_64-unknown-linux-gnu/stage1/lib/rustc/x86_64-unknown-linux-gnu/lib/libstd.so
[05:32:08] <strcat> /home/strcat/projects/rust/src/libstd/ptr.rs:16:4: 16:7 error: unused import [-D unused-imports (default)]
[05:32:10] <strcat> /home/strcat/projects/rust/src/libstd/ptr.rs:16 use sys;
[05:32:12] * strcat sighs
[05:32:16] <jensnockert> Also, asm.js is kind of horrible.
[05:32:33] <strcat> jensnockert: well it's a compiler target ;p
[05:32:44] * ChrisMorgan wonders whether Rust's macros are powerful enough to produce his artwork from very little code
[05:32:53] <strcat> jensnockert: you're not supposed to write it by hand :)
[05:33:07] <jensnockert> strcat: That's just FUD, real men write asm by hand.
[05:33:17] <strcat> I've written LLVM IR by hand
[05:33:19] <strcat> easier than fixing trans
[05:33:39] <strcat> write correct IR by hand -> figure out how the hell to get rustc to make it
[05:33:50] <jensnockert> That's what I usually do as well.
[05:33:52] <strcat> that's what's going on right now too
[05:34:09] <strcat> rustc doesn't feel like cooperating today
[05:34:21] *** Joins: ghrust (ghrust@614D05BD.6A2AE50.F3114085.IP)
[05:34:21] <ghrust> 01[13rust01] 15bors pushed 0 new commits to 06auto: 02http://git.io/vQiuRw
[05:34:21] *** Parts: ghrust (ghrust@614D05BD.6A2AE50.F3114085.IP) ()
[05:34:22] <strcat> my attempt at fixing fixed-size vector glue didn't work out well ;p
[05:34:23] *** Joins: ghrust (ghrust@1E8607E8.6A2AE50.F3114085.IP)
[05:34:23] <ghrust> 01[13rust01] 15bors pushed 2 new commits to 06auto: 02http://git.io/OTXdCg
[05:34:23] <ghrust> 13rust/06auto 14538fbc3 15Steve Klabnik: Adding an initial description to vec.rs....
[05:34:24] <ghrust> 13rust/06auto 1495b6aa4 15bors: auto merge of #7223 : steveklabnik/rust/vec_initial_docs, r=pcwalton...
[05:34:24] *** Parts: ghrust (ghrust@1E8607E8.6A2AE50.F3114085.IP) ()
[05:34:24] <jensnockert> But asm.js really needs typed arrays.
[05:34:28] <cde> will firefox os be written in Rust?
[05:34:40] *** Joins: josh (josh@moz-EC7A63FD.meeting.ietf.org)
[05:34:57] <strcat> cde: well it's just the android kernel and firefox, so the vast majority won't be (at least initially)
[05:35:08] <cde> thanks
[05:35:33] <ChrisMorgan> But if Gecko were to be supplanted by Servo, then yes, a considerable base of Rust code would be in Firefox OS.
[05:35:56] *** Joins: Axord (xord@moz-C3CCF156.lsanca.dsl-w.verizon.net)
[05:37:10] <strcat> jensnockert: you'd hate me for what I'm doing right now
[05:37:14] <strcat> jensnockert: I'm *eating* hugs.
[05:37:18] <jensnockert> :(
[05:37:22] * jensnockert hugs strcat.
[05:37:30] <strcat> (someone gave me a bag of http://www.hersheys.com/kisses/products/hugs-chocolate.aspx )
[05:37:36] <strcat> they are not very tasty.
[05:37:54] * strcat doesn't like chocolate this sweet
[05:38:42] <strcat> jensnockert: anyway I tried to fix fixed-size vec glue by using a loop, so instead of 1000 instructions it output 1000 loops
[05:38:50] <strcat> not as planned :)
[05:38:58] <strcat> iter_structural_ty is a bit weird
[05:39:06] <strcat> rustc: /home/strcat/projects/rust/src/llvm/include/llvm/IR/Instructions.h:704: llvm::Type* llvm::checkGEPType(llvm::Type*): Assertion `Ty && "Invalid GetElementPtrInst indices for type!"' failed.
[05:39:22] <strcat> yay
[05:39:26] <ChrisMorgan> strcat: the question is whether that "ASCII art" will perform well... an alternative would be having static strings "GET", "OPTIONS", etc. and indexing arrays with a simple loop. But hopefully this form of the code would perform better than the put-it-all-in-a-string-and-then-match-it-afterwards. Benchmark time!
[05:39:45] <jensnockert> strcat: American Chocolateâ€¦
[05:39:48] *** Quits: lmandel (lmandel@moz-AEAD2F61.dsl.bell.ca) (Quit: lmandel)
[05:39:58] <jensnockert> Almost everything is too sweet in the US.
[05:40:05] <ChrisMorgan> Actually, I *really* need a more general solution to it, because I need this sort of thing in a few places (e.g. header names and valuesâ€”this one is just the method name!)
[05:40:14] <jensnockert> May only be my dull Swedish taste-buds that think that though.
[05:40:44] *** Quits: enix (enix@moz-A50569DD.c3-0.slvr-ubr1.lnh-slvr.md.cable.rcn.com) (Quit: Konversation terminated!)
[05:40:48] <strcat> jensnockert: you're not wrong, everything has corn syrup in it
[05:41:14] <ChrisMorgan> Ah, corn syrup, corn syrup. Entirely unknown in Australia.
[05:41:36] <strcat> I'd like to say the same about canada but I can't ;p
[05:41:59] <strcat> at least we don't put corn syrup on our waffles
[05:42:18] <jensnockert> Yeah, we don't have corn syrup either, probably because our sugar is a lot cheaper, and our corn is a lot more expensive.
[05:42:36] <ChrisMorgan> My brother reports that in America it's a selling point that something is made with REAL SUGAR! while in Australia that's the norm and *not* using sugar is sometimes a selling point.
[05:43:06] <Eridius> the US subsidized corn pretty heavily, which made corn syrup the go-to sweetener in American food (because it was so cheap)
[05:43:23] <Eridius> which is why soda made with real sugar is a selling point, as that's unusual
[05:43:36] <Eridius> e.g. here in SF, Mexican Coke is a big thing, which people get because it's made with cane sugar
[05:44:18] *** Joins: tchoma (tchoma@moz-E58E29CC.dsl.static.sonic.net)
[05:44:34] <jensnockert> Interesting, considering that Coke in Europe uses 'real' sugar.
[05:44:55] *** Joins: james4k (james@moz-E7990244.consolidated.net)
[05:44:58] <Eridius> jensnockert: coke is actually a bit different in a bunch of different places around the globe
[05:45:16] <strcat> and they have a dozen unlisted ingredients because they're trade secrets ;p
[05:45:16] <jensnockert> Eridius: Yeah, but you would think the US version would be the canonical one.
[05:45:20] <Eridius> jensnockert: if you go to the Epcott Center at Disney World, there's actually a Coke Pavillion which lets you try out all the different variants
[05:45:45] <Eridius> or at least there was 13 years ago. I haven't checked since then
[05:45:52] <strcat> wow it's compiling stage1
[05:46:00] <strcat> that means I likely screwed up, but not completely
[05:46:09] <jensnockert> Eridius: Actually been there, but cannot remember a Coke pavillion, might just have been me not being interested.
[05:46:12] * strcat waits for the stage1 compiler to blow up
[05:46:26] <jensnockert> I'm not serious enough about my Coke.
[05:46:40] * strcat has never liked coke
[05:46:44] <kemurphy> hm, unifying pat_enum and pat_struct seems to be a more pervasive change than i thought
[05:46:47] * jensnockert usually mixes with Schweppes coke if I have to.
[05:47:46] *** Quits: jmgrosen (jmgrosen@moz-848F6087.sb.sd.cox.net) (Ping timeout)
[05:48:21] <strcat> ha, failed again
[05:48:34] *** Joins: jmgrosen (jmgrosen@moz-848F6087.sb.sd.cox.net)
[05:49:43] *** Joins: bheylin (brianheyli@moz-8255E94E.adsl.online.nl)
[05:50:19] <nmatsakis> cmr: pong
[05:51:17] <strcat> YES
[05:51:19] <strcat> I fixed it.
[05:51:23] <strcat> test bench_from_elem ... bench: 445 ns/iter (+/- 23)
[05:51:25] <strcat> test bench_set_memory ... bench: 92 ns/iter (+/- 2)
[05:51:27] <strcat> test bench_vec_repeat ... bench: 90 ns/iter (+/- 5)
[05:51:29] <strcat> before
[05:51:31] <strcat> test bench_from_elem ... bench: 90 ns/iter (+/- 4)
[05:51:33] <shachaf> Is http://static.rust-lang.org/doc/rust.html#number-literals missing a ? at the end of float_suffix_ty?
[05:51:33] <strcat> test bench_set_memory ... bench: 90 ns/iter (+/- 4)
[05:51:35] <strcat> test bench_vec_repeat ... bench: 88 ns/iter (+/- 4)
[05:51:37] <strcat> now
[05:51:39] <strcat> :)
[05:51:49] <strcat> should speed up vec iterators too.
[05:52:00] <Eridius> strcat: yay. what did you do?
[05:52:17] <Eridius> shachaf: I see one
[05:52:21] <strcat> Eridius: made an intrinsic for pointer offsets using GEP, and made std::ptr use it instead of int conversions
[05:52:30] <Eridius> strcat: sweet. what's GEP?
[05:52:32] <strcat> so LLVM's basic aliasing rules now apply
[05:52:38] <strcat> Eridius: LLVM's pointer arithmetic function
[05:52:40] <strcat> er
[05:52:41] <Eridius> ah
[05:52:42] <strcat> intrinsic*
[05:52:47] <shachaf> Eridius: What do you mean?
[05:52:51] <Eridius> shachaf: float_suffix : [ exponent | '.' dec_lit exponent ? ] ? float_suffix_ty ? ;
[05:52:55] <shachaf> Eridius: I mean float_suffix_ty's definition, not use.
[05:52:56] <strcat> Eridius: before we used inttoptr/ptrtoint so it discarded all aliasing info
[05:53:04] <shachaf> Since 1f is a valid float literal (right?).
[05:53:18] <shachaf> I.e. float_suffix_ty : 'f' [ '3' '2' | '6' '4' ] ? ;
[05:53:23] <Eridius> rusti: 1f
[05:53:24] -rusti- 1
[05:53:28] <strcat> Eridius: ideally we'd tell it the computed address is inbounds too, with inbounds GEP, but that would make those ptr functions unsafe + there is currently incorrect code
[05:53:31] <strcat> will deal with that later.
[05:54:01] <Eridius> shachaf: I think you're right
[05:57:00] <strcat> ahhh conflicts already :[
[05:57:53] <strcat> aatch: around?
[05:58:02] <shachaf> I guess I could submit a patch.
[05:58:17] <shachaf> Or a bug report? Whatever the standard thing is.
[05:59:37] *** Quits: bheylin (brianheyli@moz-8255E94E.adsl.online.nl) (Quit: bheylin)
[06:01:34] <Eridius> shachaf: fix it and submit a pull request
[06:02:53] <shachaf> Is there a way of doing it that doesn't involve adding something to my list of GitHub repositories? :-(
[06:02:59] * shachaf tries to avoid that for some reason.
[06:03:12] <strcat> Eridius: https://github.com/mozilla/rust/pull/8121/files#L5R887 pretty simple ;p
[06:03:24] *** Quits: jaen (jaen@moz-9EAEEFB6.play-internet.pl) (Quit: WeeChat 0.4.1)
[06:03:30] *** Quits: josh (josh@moz-EC7A63FD.meeting.ietf.org) (Quit: josh)
[06:03:31] *** Joins: jaen (jaen@moz-9EAEEFB6.play-internet.pl)
[06:03:58] <shachaf> Also in that section: Should Â«| '0' [       [ dec_digit | '_' ] + num_suffix ?Â» be Â«| '0' [       [ dec_digit | '_' ] * num_suffix ?Â»
[06:04:07] *** Joins: pyrac (pyrac@BCED3BF2.5754EDD3.1B3E68DA.IP)
[06:04:11] <shachaf> It doesn't look like it handles just plain 0 currently.
[06:05:01] <acrichto> strcat: nice! could you put a comment explaining why ptr::offset uses intrinsics instead of normal math?
[06:05:01] *** Joins: robertknight (robertknig@moz-AB0E96D7.range86-162.btcentralplus.com)
[06:05:16] <strcat> acrichto: yeah
[06:05:39] <strcat> acrichto: and if I do make it use inbounds GEP, it'll need an explanation of why it's unsafe ;p
[06:05:39] *** Quits: robertknight (robertknig@moz-AB0E96D7.range86-162.btcentralplus.com) (Connection reset by peer)
[06:05:43] <strcat> but that's a separate task
[06:06:00] <acrichto> I like the idea of having that as an intrinsic
[06:06:51] <strcat> sadly won't work for vec iterators the way they are atm
[06:06:57] <strcat> need to do something about zero-size types
[06:07:10] *** Quits: dherman (dherman@moz-6CA476B1.hsd1.ca.comcast.net) (Quit: dherman)
[06:07:27] <acrichto> that's annoying :(
[06:09:01] <strcat> acrichto: there, added a comment to the intrinsic
[06:09:08] *** Joins: true_droid (Adium@moz-123FD9B8.beck.volia.net)
[06:09:09] <strcat> in intrinsics.rs
[06:09:27] <strcat> err
[06:09:29] <strcat> needs to be reworded a bit
[06:09:35] *** Quits: ross (ross@moz-8A84103E.br.br.cox.net) (Quit: )
[06:09:49] <acrichto> is there a reason that you changed uint -> int?
[06:09:55] <acrichto> or is that just what llvm expects
[06:10:00] <strcat> because you can use negative offsets, and LLVM treats them as signed
[06:10:05] <acrichto> cool
[06:10:12] *** Quits: Diamond (dick@moz-C01E1CD1.ks.ks.cox.net) (Ping timeout)
[06:10:13] <strcat> we were just having -5 wrap to uint::max_value - 5 before
[06:10:18] <strcat> and then wrapping around the pointer
[06:10:25] <strcat> undef behaviour if it was inbounds GEP, but atm it's not.
[06:10:37] <strcat> just more correct
[06:10:43] <strcat> semantically :)
[06:10:45] <acrichto> oh ok, r=me when reworded
[06:11:38] <strcat> acrichto: ok, should be good now
[06:12:46] *** Joins: Diamond (dick@moz-C01E1CD1.ks.ks.cox.net)
[06:12:57] <ChrisMorgan> "only refutable patterns allowed here"?
[06:13:16] * strcat is glad to have finally fixed that
[06:13:27] <strcat> I already did 3 other related PRs ;p
[06:14:44] <ChrisMorgan> OK... after a use x::* including a static named `s`, a local ~str may not be called `s`.
[06:14:51] <ChrisMorgan> rusti: static s: u8 = 's' as u8; let s = ~"s";
[06:14:52] -rusti- <anon>:5:39: 5:40 error: only refutable patterns allowed here
[06:14:52] -rusti- <anon>:5          static s: u8 = 's' as u8; let s = ~"s";
[06:14:52] -rusti-                                                 ^
[06:14:52] -rusti- error: aborting due to previous error
[06:14:52] -rusti- application terminated with error code 101
[06:15:22] *** Quits: jaen (jaen@moz-9EAEEFB6.play-internet.pl) (Ping timeout)
[06:16:00] <ChrisMorgan> rusti: static s: u8 = 's' as u8; let s = 's';
[06:16:00] -rusti- <anon>:5:39: 5:40 error: only refutable patterns allowed here
[06:16:00] -rusti- <anon>:5          static s: u8 = 's' as u8; let s = 's';
[06:16:00] -rusti-                                                 ^
[06:16:00] -rusti- error: aborting due to previous error
[06:16:00] -rusti- application terminated with error code 101
[06:17:59] *** Joins: xazax (Mibbit@6655692F.3B222813.3F580572.IP)
[06:18:28] *** Quits: eatkinson (eatkinson@moz-BBE3ABD.mv.mozilla.com) (Quit: eatkinson)
[06:18:33] *** Joins: robertknight (robertknig@moz-AB0E96D7.range86-162.btcentralplus.com)
[06:19:21] <strcat> acrichto: really not sure what the solution is for zero-size things in general :(
[06:19:21] *** Quits: robertknight (robertknig@moz-AB0E96D7.range86-162.btcentralplus.com) (Connection reset by peer)
[06:19:27] *** Joins: ghrust (ghrust@AD60B2E3.6A2AE50.F3114085.IP)
[06:19:27] <ghrust> 01[13rust01] 15bors 04force-pushed 06auto from 1495b6aa4 to 14e94e4d5: 02http://git.io/N3iJvQ
[06:19:27] *** Parts: ghrust (ghrust@AD60B2E3.6A2AE50.F3114085.IP) ()
[06:19:51] <strcat> rusti: struct Foo; std::sys::size_of::<[Foo, ..5]>()
[06:19:51] -rusti- 0
[06:19:54] <strcat> that is not good.
[06:20:02] <strcat> rusti: struct Foo; std::sys::size_of::<[Foo, ..1000]>()
[06:20:03] -rusti- 0
[06:20:10] <strcat> rusti: struct Foo; std::sys::size_of::<[Foo, ..10000000]>()
[06:20:11] -rusti- 0
[06:20:12] <acrichto> strcat: what if there were two iterators
[06:20:22] <acrichto> one for zero-size and one for nonzero-size
[06:20:38] <strcat> acrichto: that would possibly work
[06:20:46] <strcat> acrichto: but rust is bad at that sort of metaprogramming
[06:21:01] <strcat> they'll have to be the same type of iterator
[06:21:04] <acrichto> the return type of the iter() function would be interesting...
[06:21:05] <acrichto> yeah
[06:21:08] <strcat> next() could have a different body
[06:21:14] <acrichto> true
[06:21:19] <acrichto> that would work better
[06:21:46] <strcat> it would be okay to use the 2 pointers as integers, as long as we just used conversions to/from integers
[06:21:50] <strcat> and not offset
[06:22:11] <strcat> or just use 1 of them as a counter
[06:22:41] <acrichto> that might actually work well
[06:22:47] <strcat> it'd impact non-optimized code by adding an extra branch to every iteration though
[06:22:52] <acrichto> what would the perf imrprovement be from though?
[06:23:18] <strcat> acrichto: well there would be a perf improvement from being able to use ptr::offset
[06:23:23] <strcat> for non-zero-size
[06:23:45] <acrichto> oh yeah b/c then it'd use gep
[06:23:45] <strcat> LLVM isn't smart enough to get back the information you lose from converting pointers to/from integers
[06:24:13] <acrichto> I'd be curious of the wins that we'd get percentage wise from compiling rustc
[06:24:23] <strcat> acrichto: it's also somewhat weird for zero-size types atm
[06:24:56] *** Joins: eholk (eholk@moz-9AB4D52F.hsd1.ut.comcast.net)
[06:25:16] <strcat> since it already depends on the pointers being arbitrary integers
[06:25:21] <strcat> which is okay, just weird
[06:25:47] <strcat> acrichto: I think the vec::from_elem improvement might help rustc
[06:26:03] <acrichto> I'll be watching isrustfastyet
[06:26:28] <strcat> 5x faster from a little change like that is pretty good :)
[06:26:37] *** Quits: eholk (eholk@moz-9AB4D52F.hsd1.ut.comcast.net) (Quit: eholk)
[06:26:38] <acrichto> yeah you're not kidding lol
[06:27:08] <strcat> all it takes is one hot vec::from_elem for that to matter, dunno if there is one
[06:27:13] *** Quits: tchoma (tchoma@moz-E58E29CC.dsl.static.sonic.net) (Ping timeout)
[06:27:57] <acrichto> strcat: from_fn :( https://github.com/mozilla/rust/blob/master/src/libstd/hashmap.rs#L83
[06:28:04] <acrichto> that's the hottest one that I would think of
[06:28:09] <strcat> acrichto: it will speed that up too
[06:28:13] <strcat> in all likelihood
[06:28:20] <acrichto> oh yay!
[06:28:25] <strcat> it should become a memset now
[06:29:05] <acrichto> llvm is smart enough to do that?
[06:29:13] <strcat> yup
[06:29:30] <acrichto> oh I can see how that'd work kinda
[06:29:37] <strcat> acrichto: it has a loop-idiom pass
[06:29:39] <acrichto> with gep instead of integer arithmetic
[06:29:42] <strcat> acrichto: http://llvm.org/docs/doxygen/html/LoopIdiomRecognize_8cpp_source.html
[06:29:46] *** Quits: pyrac (pyrac@BCED3BF2.5754EDD3.1B3E68DA.IP) (Quit: pyrac)
[06:29:57] <strcat> acrichto: it's also clever enough to vectorize the loop with the loop-vectorize pass if you turn off loop-idiom
[06:30:02] <strcat> but atm that's only at --opt-level=3
[06:30:18] <acrichto> I wonder if opt-level=3 would gain us much
[06:30:20] <strcat> when we have LLVM 3.4 (from svn, or stable) it will be at --opt-level=2 too
[06:30:23] <acrichto> or slow us down with optimizations
[06:30:33] <strcat> acrichto: they enabled loop-vectorize at -O2 
[06:30:46] <strcat> it got better since the LLVM we have (and they had to talk about it)
[06:31:11] <strcat> + they're going to enable SLP vectorization (scalar operations in a row, rather than just loops) at -O3 and maybe even -O2/-O1
[06:31:20] <strcat> so there are big perf improvements upcoming.
[06:31:43] *** Quits: recrack (Mibbit@B4104EBB.3CC170B1.1E14B209.IP) (Quit: http://www.mibbit.com ajax IRC Client)
[06:31:56] <acrichto> maybe I'll try pulling that into my llvm-upgrades branch soon
[06:32:04] *** Joins: bheylin (brianheyli@C709828D.E7BADBF1.B0C2132F.IP)
[06:32:21] *** Quits: geomyidae (cole@DD6F7E3A.21468E9A.30200F38.IP) (Client exited)
[06:33:06] <strcat> acrichto: loop-idiom actually only does memset/memcpy atm, but they want to improve it ;p
[06:33:13] <strcat> it's just that loop-vectorize mostly removes the need....
[06:33:19] *** Quits: tiffany (kawaii@moz-EB8B0C08.dhcp.embarqhsd.net) (Ping timeout)
[06:33:32] <strcat> it will generate code as fast or nearly as fast as a memset anyway
[06:33:53] *** Joins: geomyidae (cole@DD6F7E3A.21468E9A.30200F38.IP)
[06:34:14] <strcat> but loop-idiom is very reliable/fast
[06:34:32] *** Joins: thomaslee (thomaslee@moz-306D3DF4.hsd1.or.comcast.net)
[06:34:43] *** Joins: robertknight (robertknig@moz-AB0E96D7.range86-162.btcentralplus.com)
[06:35:01] <strcat> this really shows how much opt matters ;p
[06:35:10] <strcat> test bench_from_elem ... bench: 10520 ns/iter (+/- 233)
[06:35:10] *** Quits: robertknight (robertknig@moz-AB0E96D7.range86-162.btcentralplus.com) (Connection reset by peer)
[06:35:13] <strcat> 0
[06:35:16] <strcat> test bench_from_elem ... bench: 5098 ns/iter (+/- 103)
[06:35:19] <strcat> 1
[06:35:23] <strcat> test bench_from_elem ... bench: 83 ns/iter (+/- 0)
[06:35:25] <strcat> 2
[06:35:27] <acrichto> wow
[06:35:35] <acrichto> that's pretty insane
[06:36:16] *** Joins: pyrac (pyrac@moz-F28B7CAD.w90-55.abo.wanadoo.fr)
[06:36:18] <strcat> acrichto: one of the things -O3 would do that's useful to us is argpromotion
[06:36:39] <strcat> it goes and promotes all &T args to T for small types, when it can show all callers pass a pointer
[06:36:41] <strcat> so it has to be internal
[06:36:45] <strcat> but we have a lot of those
[06:36:52] <strcat> most are probably inlined so it wouldn't matter...
[06:37:12] <strcat> (that's why it's at -O3 only, because inlining makes it mostly pointless ;p)
[06:37:55] *** Quits: tikue (tkuehn@moz-A7CDB794.dia.static.qwest.net) (Ping timeout)
[06:39:02] *** Joins: tikue (tkuehn@moz-A7CDB794.dia.static.qwest.net)
[06:39:35] *** Quits: jj2baile (jon@moz-DCEF6040.csclub.uwaterloo.ca) (Ping timeout)
[06:39:36] *** Quits: ssalbiz (ssalbiz@moz-DCEF6040.csclub.uwaterloo.ca) (Ping timeout)
[06:39:37] *** Quits: Luqman (laden@moz-DCEF6040.csclub.uwaterloo.ca) (Ping timeout)
[06:41:04] *** Joins: robertknight (robertknig@moz-AB0E96D7.range86-162.btcentralplus.com)
[06:41:56] *** Quits: robertknight (robertknig@moz-AB0E96D7.range86-162.btcentralplus.com) (Connection reset by peer)
[06:44:10] <Diamond> Is there any planned (as in, in the works) solution for alignment?
[06:44:29] *** Quits: tikue (tkuehn@moz-A7CDB794.dia.static.qwest.net) (Quit: tikue)
[06:45:19] *** Joins: robertknight (robertknig@moz-AB0E96D7.range86-162.btcentralplus.com)
[06:45:34] *** Joins: doener (doener@moz-121949B3.unitymediagroup.de)
[06:45:40] <strcat> Diamond: what precisely about alignment?
[06:45:41] *** Quits: robertknight (robertknig@moz-AB0E96D7.range86-162.btcentralplus.com) (Connection reset by peer)
[06:45:51] <strcat> there's #[packed], align_of, etc.
[06:46:17] <Diamond> for simd types.
[06:46:40] <Diamond> hm is there any documentation?
[06:46:49] <strcat> ah, jensnockert was working on supporting SIMD types
[06:47:00] <strcat> Diamond: not for #[packed]
[06:47:19] *** Quits: yong (chatzilla@89F941DF.4E87ADC2.263D9828.IP) (Ping timeout)
[06:47:19] *** Quits: bheylin (brianheyli@C709828D.E7BADBF1.B0C2132F.IP) (Quit: bheylin)
[06:47:20] <Diamond> I remember reading about his work somewhere.
[06:47:42] <strcat> http://static.rust-lang.org/doc/std/sys.html ways of checking alignment in there
[06:47:45] <strcat> not incredibly useful
[06:47:54] *** Joins: yong (chatzilla@89F941DF.4E87ADC2.263D9828.IP)
[06:48:08] <Diamond> strcat: hm. Well I feel packed is self-explanatory.
[06:48:11] <strcat> acrichto: ha, I forgot to update tests to cast to int
[06:48:27] *** Quits: thesnowdog (doug@32E338DF.CDB23781.6F17036B.IP) (Connection reset by peer)
[06:48:45] <strcat> the sad part is that they used constant offsets
[06:48:52] <strcat> but used an explicit 'u' suffix
[06:49:25] *** Joins: ghrust (ghrust@CFE85B59.6A2AE50.F3114085.IP)
[06:49:25] <ghrust> 01[13rust01] 15bors 04force-pushed 06auto from 1492bcd2b to 14e94e4d5: 02http://git.io/N3iJvQ
[06:49:25] *** Parts: ghrust (ghrust@CFE85B59.6A2AE50.F3114085.IP) ()
[06:49:26] *** Joins: ghrust (ghrust@AC22872E.6A2AE50.F3114085.IP)
[06:49:26] <ghrust> 01[13rust01] 15bors pushed 2 new commits to 06auto: 02http://git.io/2ObUUQ
[06:49:26] <ghrust> 13rust/06auto 14538fbc3 15Steve Klabnik: Adding an initial description to vec.rs....
[06:49:26] <ghrust> 13rust/06auto 148695bc7 15bors: auto merge of #7223 : steveklabnik/rust/vec_initial_docs, r=pcwalton...
[06:49:26] *** Parts: ghrust (ghrust@AC22872E.6A2AE50.F3114085.IP) ()
[06:49:42] *** Quits: yong (chatzilla@89F941DF.4E87ADC2.263D9828.IP) (Ping timeout)
[06:49:56] *** Joins: jviereck (Adium@moz-C97F1B76.ethz.ch)
[06:50:12] *** Joins: jaen (jaen@moz-2FADB812.neoplus.adsl.tpnet.pl)
[06:50:25] <jensnockert> SIMD?
[06:50:25] *** Quits: jviereck (Adium@moz-C97F1B76.ethz.ch) (Quit: Leaving.)
[06:50:32] *** Joins: yong (chatzilla@89F941DF.4E87ADC2.263D9828.IP)
[06:50:34] <strcat> vector types
[06:50:36] <strcat> wasn't that you? ;p
[06:50:38] <jensnockert> Yes
[06:50:51] * jensnockert just wanted to show some interest.
[06:51:00] *** Quits: hjr3 (hradtke@moz-E87BDF1F.socal.res.rr.com) (Quit: My MacBook has gone to sleep. ZZZzzzâ€¦)
[06:51:11] <strcat> instead you sent me into a state of confusion
[06:51:13] <strcat> :)
[06:51:16] * jensnockert hugs strcat.
[06:51:30] * strcat ate too many hugs
[06:51:51] * jensnockert is having too many pen issues.
[06:51:53] *** Joins: robertknight (robertknig@moz-AB0E96D7.range86-162.btcentralplus.com)
[06:52:45] *** Quits: robertknight (robertknig@moz-AB0E96D7.range86-162.btcentralplus.com) (Connection reset by peer)
[06:53:02] *** Joins: xraycat (Adium@moz-104CF07C.pool.mediaways.net)
[06:53:35] *** Joins: jj2baile (jon@moz-DCEF6040.csclub.uwaterloo.ca)
[06:53:35] *** Joins: ssalbiz (ssalbiz@moz-DCEF6040.csclub.uwaterloo.ca)
[06:53:40] *** Joins: Luqman (laden@moz-DCEF6040.csclub.uwaterloo.ca)
[06:57:36] *** Quits: jmgrosen (jmgrosen@moz-848F6087.sb.sd.cox.net) (Quit: jmgrosen)
[06:58:19] <acrichto> is there a reason for priv to still be a keyword if struct fields were private by default?
[06:58:27] <strcat> nope
[06:58:34] *** Joins: gazoombo (uid6629@moz-E77DEB21.irccloud.com)
[06:58:41] <acrichto> I'd be in favor of that...
[06:58:42] <strcat> although maybe priv will end up used elsewhere
[06:58:55] <strcat> you could have private enum variants and private fields in tuple structs
[06:59:10] *** Joins: robertknight (robertknig@moz-AB0E96D7.range86-162.btcentralplus.com)
[06:59:12] <acrichto> I didn't know about the tuple structs
[06:59:21] <acrichto> rusti: struct A(int, priv float);
[06:59:21] *** Quits: robertknight (robertknig@moz-AB0E96D7.range86-162.btcentralplus.com) (Connection reset by peer)
[06:59:22] -rusti- more than 5 lines of output, pastebinned: http://sprunge.us/KIQK
[06:59:36] *** Quits: james4k (james@moz-E7990244.consolidated.net) (Ping timeout)
[06:59:46] <acrichto> rusti enum A { priv A1, A2 }
[06:59:50] <acrichto> rusti: enum A { priv A1, A2 }
[06:59:51] -rusti- ()
[06:59:58] <acrichto> I wonder how often that's used
[07:00:18] <acrichto> I guess that's a pretty legit use case though
[07:00:28] <acrichto> I wouldn't want to have to write pub on each enum variant
[07:00:40] *** Quits: xazax (Mibbit@6655692F.3B222813.3F580572.IP) (Quit: http://www.mibbit.com ajax IRC Client)
[07:03:15] *** Joins: robertknight (robertknig@moz-AB0E96D7.range86-162.btcentralplus.com)
[07:04:11] *** Parts: rsaarelm (rsaarelm@moz-D1CB7158.dhcp.inet.fi) ()
[07:04:14] *** Joins: sebcrozet (sebcrozet@moz-C27D92D8.w193-252.abo.wanadoo.fr)
[07:05:04] *** Quits: robertknight (robertknig@moz-AB0E96D7.range86-162.btcentralplus.com) (Connection reset by peer)
[07:07:17] *** Joins: robertknight (robertknig@moz-AB0E96D7.range86-162.btcentralplus.com)
[07:08:08] *** Quits: robertknight (robertknig@moz-AB0E96D7.range86-162.btcentralplus.com) (Connection reset by peer)
[07:13:11] *** Joins: thesnowdog (doug@A7398D08.8E46834.6F17036B.IP)
[07:18:07] *** Joins: jmgrosen (jmgrosen@moz-848F6087.sb.sd.cox.net)
[07:19:00] *** Joins: heftig (heftig@8DB4145A.5C7D981D.FEC4A986.IP)
[07:19:23] *** Quits: thesnowdog (doug@A7398D08.8E46834.6F17036B.IP) (Connection reset by peer)
[07:19:47] *** Quits: jmgrosen (jmgrosen@moz-848F6087.sb.sd.cox.net) (Ping timeout)
[07:21:42] *** Joins: pnkfelix (pnkfelix@87C1F78E.1DE10CA8.D8E68FF6.IP)
[07:23:58] *** Quits: pnathan (Adium@moz-BDC3EE62.tukw.qwest.net) (Quit: Leaving.)
[07:25:43] *** Joins: thesnowdog (doug@74CCD7E7.CDB23781.6F17036B.IP)
[07:32:39] <bjz_> acrichto: tuple structs are inherently positional. I don't know how well that plays with priv elements
[07:33:07] <bjz_> oh, it was strcat who suggested that
[07:33:23] <strcat> bjz_: we could allow indexing with const exprs
[07:33:29] <strcat> rather than just pattern matching
[07:33:41] <bjz_> would be nice
[07:34:41] <acrichto> how do tuple structs use priv?
[07:35:28] <bjz_> they don't atm
[07:35:38] <bjz_> (I don't think so)
[07:36:24] <acrichto> yeah I dunno if we'd actually want to remove priv, I mainly don't want it as a visibility qualifier because it barely does anything any more on functions/traits/extern/whatnot
[07:36:35] <acrichto> resolve is already confusing enough :(
[07:36:49] <bjz_> acrichto: yeah
[07:37:31] <bjz_> acrichto: I know it'd verbosify stuff, but I priv seems kinda wishy washy
[07:37:39] <bjz_> *but priv
[07:37:50] <acrichto> it's only verbosify structs
[07:37:58] <bjz_> and enums
[07:38:00] <acrichto> and then eliminate some enum behavior
[07:38:05] *** Quits: thesnowdog (doug@74CCD7E7.CDB23781.6F17036B.IP) (Connection reset by peer)
[07:38:09] <bjz_> oh ok
[07:38:10] <acrichto> if we removed priv there just wouldn't be an equivalent which is sad
[07:38:40] <acrichto> arguably though it should verbosify structs
[07:38:46] <bjz_> rusti: enum A { pub A1 }
[07:38:47] -rusti- ()
[07:38:47] <acrichto> depending on your point of view
[07:38:50] <acrichto> whoa
[07:39:00] <bjz_> rusti: struct A { pub a }
[07:39:00] -rusti- <anon>:5:26: 5:27 error: expected `:` but found `}`
[07:39:01] -rusti- <anon>:5          struct A { pub a }
[07:39:01] -rusti-                                    ^
[07:39:01] -rusti- application terminated with error code 101
[07:39:06] <bjz_> rusti: struct A { pub a: float }
[07:39:07] -rusti- ()
[07:39:11] <bjz_> haha
[07:39:17] <bjz_> pub is already there
[07:39:17] <acrichto> that should be disallowed :(
[07:39:32] <acrichto> pub in a priv struct doesn't really make a whole lot of sense
[07:39:34] *** Quits: tautologico (lymph@9F01D096.92EA1F6.C27E1635.IP) (Quit: tautologico)
[07:39:37] <bjz_> disallowed -> forbidden?
[07:39:43] <bjz_> :)
[07:39:50] <acrichto> oh, yes
[07:40:02] <bjz_> (pcwalton used disallowed all the time, haha)
[07:40:10] <bjz_> *uses
[07:40:22] <acrichto> I also like fewer keywords though :)
[07:41:23] <bjz_> it's confusing to have to think about whether to use priv or not
[07:42:02] <bjz_> that's what I've found
[07:42:36] <acrichto> I also want to be able to write down resolve rules
[07:42:50] <acrichto> mainly about accessing priv variants of sibiling/parent/child modules
[07:43:07] <acrichto> or whether you can reach through a priv module to get a pub variant
[07:43:08] <bjz_> would be good to formalize things
[07:43:46] *** Quits: jdm (jdm@92FB48CA.8B5E9DF.9A8C35B4.IP) (Quit: Lost terminal)
[07:51:52] *** Quits: strcat (strcat@moz-54F7FD49.cpe.net.cable.rogers.com) (Quit: WeeChat 0.4.1)
[07:52:51] *** Quits: lerc (quassel@moz-598ED764.telstraclear.net) (Ping timeout)
[07:53:45] *** Joins: lerc (quassel@moz-598ED764.telstraclear.net)
[07:57:20] <ChrisMorgan> Does #[inline] work across crates?
[07:58:15] <bjz_> ChrisMorgan: I believe so
[08:00:07] *** Joins: Cromulent (Cromulent@moz-983B638D.cable.virginmedia.com)
[08:01:39] *** Joins: thesnowdog (doug@629A8C2F.CDB23781.6F17036B.IP)
[08:01:52] <acrichto> ChrisMorgan: it's the only way it does work across crates
[08:04:06] <kemurphy> woo, librustc is compiling with the great enum overhaul
[08:04:10] <kemurphy> now let's see what i broke >.>
[08:04:43] <bjz_> ?
[08:05:00] <bjz_> kemurphy: "great enum overhaul"?
[08:05:43] <kemurphy> bjz_: massive patch in the works to clean up enum and struct stuff behind the scenes
[08:05:56] *** Quits: sebcrozet (sebcrozet@moz-C27D92D8.w193-252.abo.wanadoo.fr) (Ping timeout)
[08:05:56] <kemurphy> bjz_: end result is a fix for https://github.com/mozilla/rust/issues/7435 
[08:05:59] <bjz_> nice :)
[08:06:17] <bjz_> cleaner = less bugs
[08:06:32] <bjz_> usually
[08:06:39] *** Joins: sebcrozet (sebcrozet@moz-7FB6C00B.w193-252.abo.wanadoo.fr)
[08:07:04] <kemurphy> bjz_: my goal is to unify the representation of structs and enum variants behind the scenes
[08:07:26] <kemurphy> bjz_: since an enum variant is just a struct (with a discriminant tacked on front, in the non-univariant case)
[08:07:37] <kemurphy> bjz_: and a struct is essentially a univariant enum
[08:08:14] <kemurphy> bjz_: they eventually converge in trans/adt.rs, so why not converge them earlier
[08:08:29] <bjz_> now, if they only had the same keyword...
[08:08:46] <bjz_> :)
[08:09:05] <kemurphy> but who wants to write enum Foo { Foo { field: uint } } over struct Foo { field: uint }? :P
[08:09:47] <kemurphy> aw, crap
[08:09:49] <kemurphy> /home/kemurphy/rust/src/libstd/vec.rs:169:4: 169:5 error: expected item but found `<`
[08:09:51] <kemurphy> /home/kemurphy/rust/src/libstd/vec.rs:169 impl<'self, T> Iterator<&'self [T]> for VecSplitIterator<'self, T> {
[08:10:11] <kemurphy> not an error i was expecting to see :(
[08:10:20] * kemurphy must have borked the parser somewhere
[08:10:51] *** Joins: Ms2ger (Ms2ger@moz-BA3429A8.adsl-dyn.isp.belgacom.be)
[08:11:22] <jensnockert> I wonder what the reaction of the average muggle would be when trying to read the above conversation? (Also, is muggle a generally accepted term for non-programmer?)
[08:11:25] *** Quits: StarLight (StarLight@moz-A04C614E.dynamic.avangarddsl.ru) (Ping timeout)
[08:12:02] <Ralith> jensnockert: 'layman'.
[08:12:05] *** Quits: Uther (Instantbir@moz-1B244B05.hfc.dyn.abo.bbox.fr) (Ping timeout)
[08:12:47] *** Quits: sebcrozet (sebcrozet@moz-7FB6C00B.w193-252.abo.wanadoo.fr) (Ping timeout)
[08:12:48] <jensnockert> Layman has religious implications for me though.
[08:13:13] *** Joins: sebcrozet (sebcrozet@moz-D8879CC3.w80-13.abo.wanadoo.fr)
[08:13:16] *** Quits: flowsnake (flowsnake@moz-1918C33E.aztw.cable.virginmedia.com) (Connection reset by peer)
[08:13:29] <Ralith> that's unfortunate
[08:14:31] <jensnockert> Considering it is the opposite of clergy.
[08:14:36] <shachaf> kemurphy: It seems like struct serves a dual purpose, though -- guarantee of C ABI memory layout and a shorthand syntax for a one-variant sum type.
[08:15:05] <shachaf> It seems like the former could be an annotation or something, because almost all uses of struct that I see don't care about that guarantee.
[08:15:29] *** Joins: StarLight (StarLight@moz-3423D1FD.dynamic.avangarddsl.ru)
[08:15:56] <kemurphy> shachaf: there's a bug filed somewhere about missing binary compatibility with C unions -- another goal of this patch is to make that much easier via enums
[08:15:59] <shachaf> For that matter, does the syntax for struct and enum ever overlap? E.g. is something like "enum Foo { x: int }" or "enum Foo(int, char);" ever valid? That could be one way to merge them, if kind of hacky.
[08:16:01] <bblum> shachaf: it wouldn't save much, and people would be in for a surprise when they forget to do it
[08:16:08] <bblum> when they forget to annotate i mean
[08:16:21] <bblum> it's not like you are gonna save the struct keyword; that has to stay
[08:16:30] <shachaf> It seems like an FFI concern really oughtn't be mixed with a basic ADT thing.
[08:16:46] *** Quits: ChrisMorgan (chris@moz-6AC741CA.static.tpgi.com.au) (Ping timeout)
[08:17:06] <jensnockert> shachaf: extern "C" struct {} could cover most of the FFI concern, I think?
[08:17:25] <kemurphy> yeah, no reason that couldn't still happen after this
[08:17:26] <shachaf> I don't want to *write* enum Foo { Foo { field: uint } }, but I do want it to be that conceptually.
[08:17:28] <bblum> jensnockert: I know of 1 other person who would use the term muggle in that manner
[08:17:34] <bblum> anybody else would say layman
[08:17:51] <kemurphy> bblum: tt? :P
[08:17:53] *** Joins: flowsnake (flowsnake@moz-1918C33E.aztw.cable.virginmedia.com)
[08:17:58] <bblum> kemurphy: no, de0u
[08:17:59] <jensnockert> bblum: I'm not alone \o/
[08:18:13] <kemurphy> bblum: ah, yeah i could see that too
[08:18:36] <shachaf> jensnockert: Oh, maybe that would work too.
[08:18:58] <kemurphy> shachaf: i'm still leaving layout undefinded, as it currently is
[08:19:11] <kemurphy> shachaf: it just so happens that behind the scenes, enum variants and structs look the same anyway
[08:19:14] <kemurphy> (modulo discriminant)
[08:19:16] *** Joins: CarpNet (ac@moz-FD24B77.sohonet.co.uk)
[08:19:17] <bblum> kemurphy: i think he has even done it, but i am not sure
[08:19:19] <jensnockert> shachaf: Not sure what the advantage would be, but if there was one, separating them like that would be simple.
[08:19:20] * bblum -> sleep
[08:19:28] * jensnockert hugs bblum good night.
[08:19:44] <shachaf> G'nibblum.
[08:21:12] <shachaf> kemurphy: Sure. I just don't like how a 1-variant ADT is treated so completely differently from one with 0 or 2+.
[08:23:49] <kemurphy> shachaf: i'm not sure i follow? they all get treated the same by the end of trans
[08:23:50] *** Quits: jj2baile (jon@moz-DCEF6040.csclub.uwaterloo.ca) (Ping timeout)
[08:23:50] *** Quits: ssalbiz (ssalbiz@moz-DCEF6040.csclub.uwaterloo.ca) (Ping timeout)
[08:23:57] *** Quits: Luqman (laden@moz-DCEF6040.csclub.uwaterloo.ca) (Ping timeout)
[08:24:57] <shachaf> I mean from the perspective of the language. :-)
[08:25:03] <bjz_> jensnockert: muggle is a delightful way of describing non-programmers :)
[08:25:13] <shachaf> Last time I looked at the compiler code they were also treated pretty differently internally, but I guess that's what you're working on.
[08:25:13] <kemurphy> shachaf: oh gotcha, sure
[08:25:37] <kemurphy> yeah, the goal is to make them look the same under the hood after coming out of the ast
[08:25:40] <jensnockert> bjz_: We should revive `Wizard' as the opposite.
[08:25:43] <bjz_> jensnockert: seeing as programming sometimes seems like magic if you don't understand the incantations
[08:25:51] <kemurphy> the real pain is tuple structs and tuple variants, because they look like calls
[08:25:53] <shachaf> So I'm glad all the duplicated code is being eliminated, at least!
[08:25:59] <bjz_> jensnockert: see SICP
[08:26:07] * kemurphy had to write a fold pass to find the offending calls and translate them to expr_struct
[08:26:35] <jensnockert> bjz_: Yes, but that was written when wizard was still a term people actually used.
[08:27:00] <kemurphy> ugh, backtrace o'clock
[08:27:18] <bjz_> jensnockert: http://catb.org/jargon/html/W/wizard.html
[08:27:21] <bjz_> :)
[08:27:37] <shachaf> kemurphy: #haskell does not feel sympathy at your complaints about having backtraces.
[08:27:52] <shachaf> bjz_: Everything seems like magic if you dno't understand the incantations. That's what magic is!
[08:27:54] <bjz_> jensnockert: I bloody love the term 'heavy wizardry'
[08:28:03] <bjz_> shachaf: indeed
[08:28:15] <bjz_> shachaf: any sufficiently advanced...
[08:28:22] <kemurphy> dammit, failed at Option.get()
[08:28:47] <bjz_> shachaf: ...technology seems like magic - A. C. Clarke
[08:28:59] *** Quits: sebcrozet (sebcrozet@moz-D8879CC3.w80-13.abo.wanadoo.fr) (Connection reset by peer)
[08:29:07] *** Joins: sebcrozet (sebcrozet@moz-A855F6C0.w82-127.abo.wanadoo.fr)
[08:29:13] <bjz_> jensnockert: so yes, muggle is the correct technical term
[08:29:37] <shachaf> Well, .get() is evil.
[08:29:54] <shachaf> bjz_: My working definition of "magic" is "primitive".
[08:32:29] *** Joins: robertknight (robertknig@moz-54528EE0.wby.mendeley.com)
[08:34:22] *** Joins: ghrust (ghrust@E7A4CCE2.6A2AE50.F3114085.IP)
[08:34:22] <ghrust> 01[13rust01] 15bors merged 06auto into 06master: 02http://git.io/2ObUUQ
[08:34:22] *** Parts: ghrust (ghrust@E7A4CCE2.6A2AE50.F3114085.IP) ()
[08:35:29] <bjz_> shachaf: magic = { "That which we do not understand (yet)", "A facade or interface that obscures the understanding of the inner workings of a system (may lead to superstion)", "The bottom turtle", ... }
[08:35:48] <bjz_> (possibly)
[08:37:19] *** Joins: ghrust (ghrust@C621748.6A2AE50.F3114085.IP)
[08:37:20] <ghrust> 01[13rust01] 15bors pushed 0 new commits to 06auto: 02http://git.io/KxsFfA
[08:37:20] *** Parts: ghrust (ghrust@C621748.6A2AE50.F3114085.IP) ()
[08:38:04] *** Quits: thomaslee (thomaslee@moz-306D3DF4.hsd1.or.comcast.net) (Client exited)
[08:42:26] *** Quits: snadon (chatzilla@moz-3BC727E8.mc.videotron.ca) (Ping timeout)
[08:47:50] *** Joins: davbo (dave@moz-3FFA637C.oucs.ox.ac.uk)
[08:48:04] *** Joins: BizarreCake (BizarreCak@moz-361FE9B2.dynamic.barak-online.net)
[08:51:12] *** Joins: ssalbiz (ssalbiz@moz-DCEF6040.csclub.uwaterloo.ca)
[08:51:12] *** Joins: jj2baile (jon@moz-DCEF6040.csclub.uwaterloo.ca)
[08:51:17] *** Joins: Luqman (laden@moz-DCEF6040.csclub.uwaterloo.ca)
[08:51:52] <kemurphy> rusti: struct Foo { field: uint }; fn Foo(field: uint) -> Foo { Foo { field: field } }; Foo(42)
[08:51:52] -rusti- {field: 42}
[08:52:08] <kemurphy> rusti: enum Foo { Foo { field: uint } }; fn Foo(field: uint) -> Foo { Foo { field: field } }; Foo(42)
[08:52:09] -rusti- more than 5 lines of output, pastebinned: http://sprunge.us/EHeR
[08:52:11] <kemurphy> hah
[08:53:03] <kemurphy> rusti: enum Foo { Foo(uint) }; fn Foo(field: uint) -> Foo { Foo (field) }; Foo(42)
[08:53:04] -rusti- more than 5 lines of output, pastebinned: http://sprunge.us/PXQF
[08:53:14] <kemurphy> rusti: struct Foo(uint); fn Foo(field: uint) -> Foo { Foo (field) }; Foo(42)
[08:53:14] -rusti- more than 5 lines of output, pastebinned: http://sprunge.us/EVbF
[08:54:35] <kemurphy> okay so a side effect of making tuple structs and record structs share code is now record structs go in the value namespace
[08:54:47] <kemurphy> so the first one of those would be invalid
[08:56:15] <shachaf> kemurphy: Is there any hope of making .x accessor syntax work for 1-ary enums?
[08:56:25] <kemurphy> there's a lot of fns that share a name with a record struct and now they all collide; what's the right thing to do?
[08:56:53] <kemurphy> shachaf: 1-ary as in univariant, or 1-ary as in Foo(field)
[08:57:02] <shachaf> As in one variant.
[08:58:18] <kemurphy> i still don't follow
[08:58:37] <true_droid> I wonder if make always does a full rebuild of Rust. is there an option for incremental builds?
[08:58:40] <kemurphy> apparently you can't even currently define univariant enums, so *shrug*
[08:59:17] <shachaf> You can't?
[08:59:29] <shachaf> I had an issue when using the same name for the constructor as the type.
[08:59:44] <kemurphy> oh, you can, they can't share a name though
[08:59:46] <kemurphy> derp
[09:00:00] <kemurphy> so what's an example of what doesn't work that you want to see work?
[09:00:22] <kemurphy> rusti: enum Foo { Bar(uint) }; Bar(42)
[09:00:23] -rusti- Bar(42)
[09:00:25] <shachaf> enum Foo { Bar { x: int } } ; let blah = Bar { x: 5 }; blah.x
[09:00:38] <kemurphy> rusti: enum Foo { Bar { x: int } } ; let blah = Bar { x: 5 }; blah.x
[09:00:39] -rusti- <anon>:5:64: 5:70 error: attempted access of field `x` on type `main::Foo`, but no field with that name was found
[09:00:39] -rusti- <anon>:5          enum Foo { Bar { x: int } } ; let blah = Bar { x: 5 }; blah.x
[09:00:39] -rusti-                                                                          ^~~~~~
[09:00:39] -rusti- error: aborting due to previous error
[09:00:40] -rusti- application terminated with error code 101
[09:00:55] <kemurphy> aha
[09:01:02] <kemurphy> yeah, that's doable i think
[09:01:13] <shachaf> There's a question of what to do when you have more than one variant.
[09:01:43] <kemurphy> presumably allow it if the same field name exists across all variants, or bark "not a common field name for enum"
[09:01:44] <shachaf> You could do it Haskell-style, as in enum Foo { A { x: int, y: char }, B { x: int, z: bool } } would allow .x but not .y or .z. But maybe that's not so great for Rust.
[09:01:56] <mark_edward> shachaf: that sounds cool
[09:02:13] * kemurphy likes the haskell approach
[09:02:23] *** Joins: yong_ (chatzilla@89F941DF.4E87ADC2.263D9828.IP)
[09:02:27] <kemurphy> shachaf: how does haskell behave if x has two different types though?
[09:02:29] *** Quits: yong (chatzilla@89F941DF.4E87ADC2.263D9828.IP) (Ping timeout)
[09:02:37] *** yong_ is now known as yong
[09:02:42] <shachaf> kemurphy: It's an error because accessors are functions.
[09:02:54] <shachaf> So it would have to define two different 'x's.
[09:03:05] <kemurphy> ah i see
[09:03:30] <shachaf> .x looks a lot more like an accessor than a function call -- it doesn't feel like it would be a branch just to access a field.
[09:04:50] <shachaf> Hmm, I suppose you could arrange to have all the common elements at the beginning of the enum variants with the same memory layout or something...
[09:05:17] <shachaf> But it generally seems a bit fishy. I don't know.
[09:05:35] <kemurphy> shachaf: i mean, that would be reasonable since we leave the in-memory layout undefined
[09:06:59] <shachaf> Right.
[09:07:26] <shachaf> But you might have other constraints you couldn't satisfy, like reÃ¶rdering elements to use the least memory. :-)
[09:10:04] <shachaf> Anyway, allowing the syntax on 1-ary sums seems like a pretty straightforward thing to me.
[09:12:59] <shachaf> http://static.rust-lang.org/doc/rust.html#number-literals as currently written doesn't allow the literal 0, right?
[09:13:58] <dbaupp> shachaf: looks like it
[09:14:38] <shachaf> And also doesn't allow 1f.
[09:16:04] <dbaupp> the manual is incorrect almost everywhere (admittedly with varying degrees of incorrectness)
[09:16:40] <shachaf> That's sad. :-(
[09:16:53] <doener> r? https://github.com/mozilla/rust/pull/8123
[09:17:08] <shachaf> What would it take to have it be correct and kept up-to-date?
[09:18:41] *** Joins: Egbert9e9 (Egbert9e9@moz-366B5D68.inter.net.il)
[09:18:42] <dbaupp> a lot of effort to get it correct, less to keep it up-to-date
[09:18:57] * dbaupp tries to ask for documentation updates when he reviews PRs
[09:18:57] <shachaf> hi Egbert9e9
[09:19:03] <Egbert9e9> hi shachaf :)
[09:19:18] <Egbert9e9> shachaf: is rust your new haskell? :p
[09:19:39] *** Joins: orshem (orshem@C5E06B1E.A5B6B765.E3D28531.IP)
[09:19:51] <dbaupp> doener: could you give an example of what the PR fixes?
[09:20:05] * dbaupp is slow tonight
[09:20:26] <doener> dbaupp: { let mut x = @5; x = @5; x = @5; x = @5 }
[09:20:42] <Egbert9e9> compiling rust is way over my tiny machine's memory. it swaps. I'm looking for a binary installation.
[09:20:43] <doener> dbaupp: all four values currently get freed at the end of the scope
[09:21:04] <doener> dbaupp: with the change, the previous one gets freed when the next one is assigned
[09:21:10] <dbaupp> doener: oh
[09:21:29] <dbaupp> doener: so that "becomes" something like `let mut x; { x = @5 } ...`?
[09:21:36] <doener> dbaupp: right
[09:21:49] <Egbert9e9> a .deb file would be awesome and even moreso an ubuntu PPA.
[09:22:01] <doener> dbaupp: initial peak in phase 2 goes from 1.3GB to 900MB
[09:22:04] <shachaf> Egbert9e9: rust is my new rust hth
[09:22:29] *** Quits: busylizzy (lisa@85228838.12D0DC84.211374C4.IP) (Ping timeout)
[09:22:29] <dbaupp> Egbert9e9: there is one
[09:22:30] <shachaf> Egbert9e9: There was just a post the other day about Ubuntu PPA.
[09:22:30] <Egbert9e9> shachaf: hope this helps? (did a "dict hth")
[09:22:37] <shachaf> https://launchpad.net/~hansjorg/+archive/rust
[09:22:45] <Egbert9e9> zomg! thanks you!
[09:22:49] *** Joins: busylizzy (lisa@85228838.12D0DC84.211374C4.IP)
[09:22:49] <dbaupp> also, https://launchpad.net/~kevincantu/+archive/rust
[09:23:07] <Egbert9e9> which one should I choose?
[09:23:30] <dbaupp> looks like only hansjorg is up-to-date
[09:23:38] <Egbert9e9> awesome. thanks!
[09:24:30] <Egbert9e9> shachaf: a post on which blog?
[09:25:03] <shachaf> Maybe on the mailing list.
[09:25:09] <Egbert9e9> ah, okay
[09:26:18] <dbaupp> Egbert9e9: https://mail.mozilla.org/pipermail/rust-dev/2013-July/004900.html
[09:29:28] *** Joins: vodik (simon@moz-CBE4BB13.cable.teksavvy.com)
[09:30:45] <Egbert9e9> this is great! I hope he won't get bored of this as quickly as I would have.
[09:38:07] <doener> dbaupp: https://gist.github.com/dotdash/c8a311185ab10601fa3b -- before and after massif "graph" for "rustc --no-trans librustc.rs"
[09:38:26] <dbaupp> doener: much nicer!
[09:38:37] <dbaupp> doener: is that spike macro expansion?
[09:39:11] * dbaupp wishes we could go `@isrustfastyet?` on pull requests to get an automatic bench/memory plot.
[09:40:12] <Ms2ger> dbaupp, implement it! ;)
[09:40:48] <doener> phase 2 in general. Macro expansion is part of that, but the @Crate gets reassigned a few more times there, and previously we kept all instances for the whole function, now we have only 2 at any time (plus the original one that is kept alive outside the function)
[09:40:50] <dbaupp> Ms2ger: you should bully cmr about it too :P
[09:41:09] <dbaupp> doener: aha, I understand.
[09:41:17] <Ms2ger> cmr! How are you!
[09:41:20] * dbaupp wishes we had a consuming syntax::fold
[09:41:31] <doener> dbaupp++
[09:42:37] *** Joins: sankha93 (Instantbir@7061CD01.D6BD0D91.22D41759.IP)
[09:46:20] *** Joins: azita (Azita@87C1F78E.1DE10CA8.D8E68FF6.IP)
[09:48:26] *** Joins: q66 (q66@6EE9DE40.46454B5D.33AABD5F.IP)
[09:51:37] *** Joins: rookii (rookii@moz-B4770674.rdl801.qld.optusnet.com.au)
[09:55:32] *** Joins: mrordinaire (Mibbit@8487BAED.E79832F4.8BC4C3B1.IP)
[09:55:50] *** Quits: rookii (rookii@moz-B4770674.rdl801.qld.optusnet.com.au) (Client exited)
[10:01:13] *** Quits: infynyxx (infynyxx@moz-E95B370B.nyc.res.rr.com) (Client exited)
[10:02:33] <kemurphy> namespaces make me sad :(
[10:03:11] * kemurphy wishes the parser could tell when an ident was a struct or enum variant before resolve happens
[10:05:58] *** Joins: lucian (lucian@6B2B4644.4304AE1E.CE5E78F6.IP)
[10:14:59] *** Quits: km (quassel@FDBAF0A0.DBF71E41.29C67456.IP) (Ping timeout)
[10:16:32] *** Joins: Blub\w (wry@moz-81ABD137.dip0.t-ipconnect.de)
[10:21:36] *** Joins: km (quassel@FDBAF0A0.DBF71E41.29C67456.IP)
[10:22:20] *** Joins: ghrust (ghrust@CFE85B59.6A2AE50.F3114085.IP)
[10:22:21] <ghrust> 01[13rust01] 15bors merged 06auto into 06master: 02http://git.io/fHB53A
[10:22:21] *** Parts: ghrust (ghrust@CFE85B59.6A2AE50.F3114085.IP) ()
[10:25:12] *** Quits: Cromulent (Cromulent@moz-983B638D.cable.virginmedia.com) (Quit: KVIrc 4.2.0 Equilibrium http://www.kvirc.net/)
[10:25:20] *** Joins: ghrust (ghrust@C621748.6A2AE50.F3114085.IP)
[10:25:20] <ghrust> 01[13rust01] 15bors pushed 0 new commits to 06auto: 02http://git.io/Gt3znQ
[10:25:20] *** Parts: ghrust (ghrust@C621748.6A2AE50.F3114085.IP) ()
[10:25:22] *** Joins: ghrust (ghrust@C621748.6A2AE50.F3114085.IP)
[10:25:22] <ghrust> 01[13rust01] 15bors pushed 2 new commits to 06auto: 02http://git.io/E9wlzA
[10:25:22] <ghrust> 13rust/06auto 148ae900f 15Brian Anderson: mk: Fix NO_REBUILD so stdtest can be tested without re-bootstrapping. Closes #8101
[10:25:22] <ghrust> 13rust/06auto 14c124f21 15bors: auto merge of #8110 : brson/rust/no-rebuild, r=bblum...
[10:25:23] *** Parts: ghrust (ghrust@C621748.6A2AE50.F3114085.IP) ()
[10:30:19] *** Quits: vodik (simon@moz-CBE4BB13.cable.teksavvy.com) (Quit: dies of dysentery)
[10:32:45] <dbaupp> cmr: http://octayn.net/benches/4c4cf003ea32d7617602fdbd1b2ebc8099633f06/ is broken (it's listed twice in history.txt and time.txt is empty)
[10:34:51] <doener> dbaupp: is that why IRSY isn't updating?
[10:35:16] <dbaupp> doener: partly
[10:35:43] <dbaupp> doener: although, it would be the only update to happen.
[10:36:07] <dbaupp> afaict, nothing else has been benched for a while
[10:36:25] <dbaupp> (well, there are a pile that have an empty/invalid mem.json. :( )
[10:37:40] <Thiez> pub mod m { struct S{ x: int, y: int } } let s = m::S{x:5,y:3}; s
[10:37:43] <Thiez> oh, sorry
[10:37:47] <Thiez> wrong window
[10:39:16] <orshem> mods default to private? 
[10:39:53] *** Quits: StarLight (StarLight@moz-3423D1FD.dynamic.avangarddsl.ru) (Ping timeout)
[10:41:03] <Thiez> do mods work in rusti?
[10:41:45] *** Quits: sankha93 (Instantbir@7061CD01.D6BD0D91.22D41759.IP) (Ping timeout)
[10:41:50] <dbaupp> rusti: pub mod m { struct S{ x: int, y: int } } let s = m::S{x:5,y:3}; s
[10:41:50] -rusti- <anon>:5:58: 5:62 error: `m::S` does not name a structure
[10:41:51] -rusti- <anon>:5          pub mod m { struct S{ x: int, y: int } } let s = m::S{x:5,y:3}; s
[10:41:51] -rusti-                                                                    ^~~~
[10:41:51] -rusti- error: aborting due to previous error
[10:41:51] -rusti- application terminated with error code 101
[10:42:02] <dbaupp> rusti: mod m { pub struct S{ x: int, y: int } } let s = m::S{x:5,y:3}; s
[10:42:03] -rusti- {x: 5, y: 3}
[10:42:09] *** Joins: sankha93 (Instantbir@7061CD01.D6BD0D91.22D41759.IP)
[10:42:26] <dbaupp> Thiez: you need the struct to be pub for it to be useable outside of m
[10:42:38] <Egbert9e9> how do I initialize arrays?
[10:42:49] <kimundi> Thiez: rusti rust code is inserted into a function body, you can have items in a function, but I think importing/exporting them doesn't work (how would you write the path afetr all)
[10:43:13] <kimundi> Egbert9e9: All arrays you creata in rust are already initialized
[10:43:16] <dbaupp> Egbert9e9: more details?
[10:43:28] <dbaupp> rusti: std::vec::from_elem(10, 3)
[10:43:29] -rusti- ~[3, 3, 3, 3, 3, 3, 3, 3, 3, 3]
[10:43:39] <dbaupp> rusti: [3, .. 10]
[10:43:40] -rusti- [3, 3, 3, 3, 3, 3, 3, 3, 3, 3]
[10:43:49] <Egbert9e9> oh wow. thanks!
[10:43:51] <kimundi> rusti: [42u, .. 5]
[10:43:52] -rusti- [42, 42, 42, 42, 42]
[10:43:53] <dbaupp> rusti: std::vec::from_fn(10, |i| i + 1)
[10:43:54] -rusti- ~[1, 2, 3, 4, 5, 6, 7, 8, 9, 10]
[10:44:18] *** Joins: StarLight (StarLight@moz-3C7847AE.dynamic.avangarddsl.ru)
[10:44:44] <kimundi> rusti: Counter::new().take_(15).to_owned_vec()
[10:44:45] -rusti- more than 5 lines of output, pastebinned: http://sprunge.us/RSVc
[10:45:44] <dbaupp> rusti: Counter::new(0, 1).take_(15).to_owned_vec()
[10:45:45] -rusti- more than 5 lines of output, pastebinned: http://sprunge.us/MbRa
[10:46:00] <dbaupp> rusti: std::iterator::Counter::new(0, 1).take_(15).to_owned_vec()
[10:46:01] -rusti- ~[0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14]
[10:46:25] *** Quits: yong (chatzilla@89F941DF.4E87ADC2.263D9828.IP) (Ping timeout)
[10:47:04] <orshem> i think we need crate local visibility (at least i need :)), or let inner mods access their ancestor's privates
[10:47:30] <kimundi> yeah, one of both really needs to be possible
[10:48:08] *** Joins: yong (chatzilla@89F941DF.4E87ADC2.263D9828.IP)
[10:48:44] <Thiez> dbaupp, kimundi: thanks :)
[10:48:58] <dbaupp> orshem++
[10:50:07] <kemurphy> rusti: let id = syntax::parse::token::special_idents::unnamed_field; id
[10:50:08] -rusti- more than 5 lines of output, pastebinned: http://sprunge.us/eYfj
[10:50:32] *** Quits: Blub\w (wry@moz-81ABD137.dip0.t-ipconnect.de) (Quit: bbl)
[10:50:34] <kemurphy> rusti: use syntax::parse::token::special_idents::unnamed_field; let id = unnamed_field; id
[10:50:35] -rusti- more than 5 lines of output, pastebinned: http://sprunge.us/UCgZ
[10:50:54] <kemurphy> rusti: extern mod syntax; use syntax::parse::token::special_idents::unnamed_field; let id = unnamed_field; id
[10:50:54] -rusti- <anon>:5:9: 5:27 error: "extern mod" declarations are not allowed here
[10:50:54] -rusti- <anon>:5          extern mod syntax; use syntax::parse::token::special_idents::unnamed_field; let id = unnamed_field; id
[10:50:54] -rusti-                   ^~~~~~~~~~~~~~~~~~
[10:50:54] -rusti- error: aborting due to previous error
[10:50:54] -rusti- application terminated with error code 101
[10:51:04] <kemurphy> *shrug*
[10:51:47] <kemurphy> i wonder if there's a bug filed for this already, but basically i couldn't use the long version as an immediate value, but could use unnamed_field on its own after inserting the long use statement
[10:52:03] * kemurphy wondering if it has something to do with inner modules
[10:52:33] <dbaupp> kemurphy: I'm guess it was because `syntax` wasn't in scope
[10:52:37] <kimundi> kemurphy: different path syntax betkeen expressions and use
[10:52:50] <dbaupp> kemurphy: if you had `use syntax;` or `::syntax::...` it probably works
[10:53:03] <kimundi> let x = ::syntax::parse::token::special_idents::unnamed_field
[10:53:44] <kemurphy> ah, is that what the leading :: is for then
[10:54:01] <kimundi> paths in expressions are allways relative to what you put in scope with the use imports. To instead use a global path in an expression, prefix it with ::
[10:54:20] <kemurphy> gotcha, thanks!
[10:54:41] <kemurphy> (also yes, "use syntax;" was absent)
[10:55:18] *** Joins: BitPuffin (quassel@moz-49828767.cust.tele2.se)
[10:57:13] <kimundi> dbaupp: r? https://github.com/mozilla/rust/pull/8082
[10:57:26] <kimundi> (Hopefully it actually lands today :D)
[10:57:41] <dbaupp> kimundi: the only change is a rebase?
[10:57:47] <kimundi> yeah
[10:58:00] <kimundi> had to remove -Iterator suffixes
[10:58:06] <kimundi> from types
[10:58:22] <orshem> dbaupp, kimundi: how do i get developers' feedback on this?
[10:58:26] <orshem> also can't implement this myself, i have no knowledge of compilers
[10:58:43] <kimundi> orshem: On what?
[10:58:45] <dbaupp> orshem: of the crate-local public?
[10:59:25] <orshem> dbaupp: yes
[10:59:34] <orshem> kimundi: crate local visibility
[10:59:57] <orshem> or inner modules access to ancestor's private
[11:00:58] <dbaupp> I believe it's been suggested before, but there doesn't a (open or closed) bug about it
[11:01:09] <dbaupp> so the first step would be opening one
[11:01:20] <dbaupp> (and/or sending a email to the mailing list)
[11:01:23] <dbaupp> *an
[11:01:33] <orshem> dbaupp: the first step would be creating a github account :)
[11:01:38] <dbaupp> orshem: heh :)
[11:02:03] <dbaupp> if you're on the mailing list already, that's probably a perfect spot too.
[11:04:27] *** Quits: dwhyte1 (dwhyte@1922756A.EDC594B0.7BF4A4B0.IP) (Quit: Leaving.)
[11:04:37] *** Quits: yuriks (yuriks@9C2CE887.E53EB8F9.8DE25902.IP) (Ping timeout)
[11:07:11] *** Quits: sankha93 (Instantbir@7061CD01.D6BD0D91.22D41759.IP) (Ping timeout)
[11:07:52] *** Joins: sankha93 (Instantbir@7061CD01.D6BD0D91.22D41759.IP)
[11:09:47] *** Quits: pnkfelix (pnkfelix@87C1F78E.1DE10CA8.D8E68FF6.IP) (Quit: Leaving.)
[11:10:37] <cde> how can one contribute to the Rust project?
[11:11:14] <kimundi> cde: Fix a issue, submit pull request :p
[11:11:46] <cde> thx bro
[11:12:29] <kimundi> Also: providing feedback. Using the language and talk about problems etc
[11:13:47] <Ms2ger> kimundi, I'd do that, but I start a syntax bikeshed every time :)
[11:14:07] <kimundi> Ms2ger: That's not a problem :D
[11:14:29] <kimundi> We still haven't reached the bikeshed about wich bikeshed to discus yet
[11:14:30] <jensnockert> Bikeshed all the things \o/
[11:14:31] *** Quits: sankha93 (Instantbir@7061CD01.D6BD0D91.22D41759.IP) (Ping timeout)
[11:14:42] <jensnockert> kimundi: Want me to create it on the wiki?
[11:14:51] <cmr> heh
[11:14:55] *** Joins: sankha93 (Instantbir@7061CD01.D6BD0D91.22D41759.IP)
[11:14:56] * jensnockert hugs cmr.
[11:14:56] <cmr> Bikeshed-bikeshed
[11:15:06] <Ms2ger> For example, I use rust and think "Hmm, I'd like a nice foreach loop"
[11:16:12] *** Joins: Earnestly (earnest@CAE8D902.48DC5685.39C00A7A.IP)
[11:16:24] <dbaupp> Ms2ger: like the new forloop we're getting?
[11:16:51] <Ms2ger> Are we?
[11:16:58] <cmr> yup
[11:17:04] <cmr> graydon was working on it yesterday
[11:17:13] <dbaupp> yup, using the external iterators entirely
[11:17:38] <dbaupp> `for x in v.iter() { .. }`
[11:17:48] <doomlord_> its implemented as a sugar for while  with iter.next() or something ?
[11:17:52] <dbaupp> (possibly without the .iter(), at somepoint in the future.)
[11:18:05] <cmr> doomlord_: yup
[11:18:07] <Ms2ger> \o/
[11:18:33] <Ms2ger> I'll have to find another example bikeshed, then :)
[11:18:58] <dbaupp> doomlord_: yeah, `for <pattern> in <thing> { <body> }` => `for let mut it = <thing>; loop { match it.next() { Some(<pattern>) => { <body> } None => { break } }`
[11:20:11] <dbaupp> cmr: did you see that http://octayn.net/benches/4c4cf003ea32d7617602fdbd1b2ebc8099633f06/ has an empty time.txt?
[11:20:35] <cmr> dbaupp: yeah
[11:20:52] <cmr> I probably interupted the benchmark while it was running
[11:21:52] <dbaupp> (there's a pile with an empty mem.json too, btw.)
[11:22:07] <cmr> how big of a pile :(
[11:22:12] *** Joins: FrozenCow (FrozenCow@moz-B2DF4929.chello.nl)
[11:22:43] <cmr> 11
[11:22:52] <cmr> Why does that happen
[11:25:52] *** Quits: Earnestly (earnest@CAE8D902.48DC5685.39C00A7A.IP) (Ping timeout)
[11:26:19] <cmr> hm, seems there's a problem with running cached builds
[11:26:55] <cmr> dbaupp: does having empty ones affect your end negatively? I'm just going to leave it, I planned on tossing out the whole stack and rewriting it today
[11:27:08] <dbaupp> cmr: no, but having that 4c4c one does
[11:27:15] <cmr> already removed it
[11:28:07] *** Joins: Cromulent (Cromulent@moz-983B638D.cable.virginmedia.com)
[11:28:48] <dbaupp> ok, seems to work now
[11:29:00] <dbaupp> (well, there hasn't been any updates, but it runs to completion.)
[11:29:47] *** Quits: ssbr (ssbr@moz-141F89C6.block0.gvtc.com) (Ping timeout)
[11:30:38] *** Joins: ssbr (ssbr@moz-141F89C6.block0.gvtc.com)
[11:30:50] <orshem> dbaupp: i think the iter() should be kept because sometimes you'll want mut_iter or rev_iter... 
[11:30:53] *** Quits: tedh (tedh@moz-F0B37C08.hsd1.il.comcast.net) (Ping timeout)
[11:31:18] <orshem> it's more explicit this way
[11:32:12] <dbaupp> orshem: but most often you'll just want the plain iterator: you can always call v.mut_iter(), etc.
[11:32:17] <cmr> I disagree
[11:33:14] <dbaupp> orshem: (just btw, I have a feeling that this is a pointless/counterproductive bikeshed until (a) we have the new for-loop and (b) we have the possibility of dropping the .iter().)
[11:35:50] <orshem> dbaupp: it's bikesheding no doubt :) I'll drop it. 
[11:36:19] <dbaupp> orshem: at least for now, feel free to bring it up later :)
[11:38:32] *** Quits: int3_ (int3_@moz-ABE52D50.hsd1.ca.comcast.net) (Client exited)
[11:38:57] *** Joins: int3_ (int3_@moz-ABE52D50.hsd1.ca.comcast.net)
[11:40:39] *** Quits: int3_ (int3_@moz-ABE52D50.hsd1.ca.comcast.net) (Ping timeout)
[11:44:32] *** Quits: azita (Azita@87C1F78E.1DE10CA8.D8E68FF6.IP) (Quit: azita)
[11:45:19] *** Joins: msingle (Thunderbir@moz-930E5D97.hr.hr.cox.net)
[11:56:26] *** Joins: maxli (maxli@F2D29657.F60B0462.67AC9B1.IP)
[11:56:36] <Thiez> so I was looking at the 'dereference operator' mail on the mailinglist and I'm not sure it goes far enough
[11:56:55] <cmr> I'm kind of frightened by it
[11:57:00] <Thiez> yes, that too :p
[11:57:18] <cmr> I don't want to dereference something and have an expensive method call
[11:57:26] <cmr> But usually you'd know exactly when you'd be doing that
[11:57:32] <cmr> since you'd have an Rc<T> or whatever
[11:58:20] <Thiez> it could be #[inline(always)]
[11:58:29] <Thiez> I imagine in most cases that would be fine
[11:58:42] <cmr> I'm worried about the body of the method, not the call itself :p
[11:58:44] <doomlord_> got a peice of sample code csearch::maybe_get_item_ast(
[11:58:44] <doomlord_> 			ccx.tcx, def_id,
[11:58:44] <doomlord_> 			|a, b, c, d| astencode::decode_inlined_item(a, b, ccx.maps(), c.clone(), d)); .... but trying to compile it says no method in scope, and i can't grep a fn\s*maps either.. can anyone confirm if thats a recent addition before i update/recompile rustc ...
[11:58:45] *** Joins: FrozenCow_ (FrozenCow@moz-B2DF4929.chello.nl)
[11:58:47] *** Quits: FrozenCow_ (FrozenCow@moz-B2DF4929.chello.nl) (Quit: FrozenCow_)
[11:59:05] <doomlord_> ^ method .maps()
[11:59:06] <Thiez> cmr: but in the proposal it does not allow dereferencing something as mutable
[11:59:24] <Thiez> rusti: struct S{x: int} let mut x = S{x:5}; let y = &mut x; (*y).x = 3; x // So I don't think you could do something like this.
[11:59:25] -rusti- {x: 3}
[12:00:07] <kimundi> I don't like using dereferencing for anything other than dereferencing... The current behavior with newtype like strutcs already seems strange
[12:00:13] *** Quits: xraycat (Adium@moz-104CF07C.pool.mediaways.net) (Quit: Leaving.)
[12:00:20] *** Joins: donri (dag@moz-9BB61102.tbcn.telia.com)
[12:00:32] <Thiez> would be nice if we could define methods that inherit mutability of an argument in their return value
[12:01:28] *** Quits: Cromulent (Cromulent@moz-983B638D.cable.virginmedia.com) (Quit: KVIrc 4.2.0 Equilibrium http://www.kvirc.net/)
[12:01:35] <kimundi> However: We could just rename 'dereferencing' to 'annonymous one element accessor'
[12:02:35] <Ms2ger> To what? :)
[12:02:57] <kimundi> So, instead of diverging the semantic from the definition, just adjust the definiton to match the semantic.
[12:05:55] <kimundi> Basically, '*foo' shouldn't be read as "derefernce the pointer foo to get what it points at", but instead as "return a type wrapped by foo"
[12:06:14] <kimundi> In the case of &T, ~T etc that woult just be T
[12:08:02] *** Joins: xraycat (Adium@moz-104CF07C.pool.mediaways.net)
[12:09:01] <Thiez> well, not always
[12:09:11] *** Joins: int3_ (int3_@moz-ABE52D50.hsd1.ca.comcast.net)
[12:09:20] <Thiez> rusti: let x = ~"deref me"; *x
[12:09:21] -rusti- <anon>:5:30: 5:32 error: type ~str cannot be dereferenced
[12:09:21] -rusti- <anon>:5          let x = ~"deref me"; *x
[12:09:21] -rusti-                                        ^~
[12:09:22] -rusti- error: aborting due to previous error
[12:09:24] -rusti- application terminated with error code 101
[12:09:36] *** Quits: km (quassel@FDBAF0A0.DBF71E41.29C67456.IP) (Ping timeout)
[12:09:39] <cmr> but ~str isn't a ~T
[12:09:41] <Ms2ger> How about &&T?
[12:09:50] <kimundi> I guess to make it consistent there would be three kinds of fields a struct can have: named fields (regular structs), annonymous ordered fields (tuple structs) and singular annonymous field (one element tuple)
[12:09:51] <Thiez> Ms2ger: what about it?
[12:10:05] <Thiez> rusti: **&&5
[12:10:05] -rusti- <anon>:5:11: 5:13 error: unexpected token: `&&`
[12:10:05] -rusti- <anon>:5          **&&5
[12:10:05] -rusti-                     ^~
[12:10:05] -rusti- application terminated with error code 101
[12:10:12] <Thiez> rusti: * * & &5
[12:10:12] -rusti- 5
[12:10:20] *** Joins: ghrust (ghrust@9C8B94D4.6A2AE50.F3114085.IP)
[12:10:20] <ghrust> 01[13rust01] 15bors merged 06auto into 06master: 02http://git.io/E9wlzA
[12:10:20] *** Parts: ghrust (ghrust@9C8B94D4.6A2AE50.F3114085.IP) ()
[12:10:33] <Thiez> works just fine, as long as rustc doesn't confuse && with logical and
[12:10:37] <kimundi> wich would then make a overloadable deref() fn strange as we don't have overloadable getter/setter for the other two kinds
[12:11:16] <Thiez> hmmn, we can't deref single element tuples?
[12:11:32] <Thiez> *(5,)
[12:11:36] <Thiez> how disappointing
[12:11:43] <dbaupp> rusti: *(5,)
[12:11:44] -rusti- <anon>:5:9: 5:14 error: type (<VI0>) cannot be dereferenced
[12:11:44] -rusti- <anon>:5          *(5,)
[12:11:44] -rusti-                   ^~~~~
[12:11:44] -rusti- error: aborting due to previous error
[12:11:44] -rusti- application terminated with error code 101
[12:11:57] *** Joins: z0w0 (zack@moz-E12708D5.lns6.woo.bigpond.net.au)
[12:12:04] *** Joins: km (quassel@FDBAF0A0.DBF71E41.29C67456.IP)
[12:13:19] *** Joins: ghrust (ghrust@2EE61FCC.6A2AE50.F3114085.IP)
[12:13:19] <ghrust> 01[13rust01] 15bors pushed 2 new commits to 06auto: 02http://git.io/dhonng
[12:13:19] <ghrust> 13rust/06auto 14e33fca9 15Marvin LÃ¶bel: Added str::char_offset_iter() and str::rev_char_offset_iter()...
[12:13:19] <ghrust> 13rust/06auto 147fc8c14 15bors: auto merge of #8082 : Kimundi/rust/master, r=huonw...
[12:13:19] *** Parts: ghrust (ghrust@2EE61FCC.6A2AE50.F3114085.IP) ()
[12:13:44] *** Quits: km (quassel@FDBAF0A0.DBF71E41.29C67456.IP) (Ping timeout)
[12:13:45] <orshem> how would the deref operator work with the auto deref? would we get an invisible method call
[12:14:00] <kimundi> orshem: Apparently yes
[12:14:25] <cmr> I'm not opposed to that really 
[12:14:31] <cmr> As long as you know what you're buying into
[12:14:38] <cmr> And you know what you're buying into when you use a smart pointer.
[12:15:09] *** Quits: int3_ (int3_@moz-ABE52D50.hsd1.ca.comcast.net) (Ping timeout)
[12:15:15] <kimundi> cmr: One of the examples was to use it for arbitrary strutcs to simulate struct inheritance though
[12:15:41] *** Quits: igl (igl@moz-1438006E.adsl.alicedsl.de) (Ping timeout)
[12:15:55] *** Joins: The_third_man (ripault@moz-3CE49532.lrde.epita.fr)
[12:16:20] <The_third_man> hi, do you know if there is way to do a list::find on a mutable list ?
[12:16:27] *** Joins: km (quassel@FDBAF0A0.DBF71E41.29C67456.IP)
[12:16:30] *** Joins: Tatsuya (Mibbit@4CF559D4.5FB881A2.50CFA630.IP)
[12:17:07] <Thiez> kimundi: in those cases if the method call is inlined properly LLVM can probably optimize it away to ordinary member field access
[12:17:11] <kimundi> struct Base {foo }; struct Bar {base: Base, bar}; Bar::new().bar // accesses Bar.bar ; Bar::new().foo // could desugar to Bar::new().deref().foo
[12:17:15] *** Joins: igl (igl@moz-66ACF6D6.adsl.alicedsl.de)
[12:17:49] <kimundi> Thiez: The problem is not if it can be optimized, it's that it can run arbitrary code without you noticing it from the code
[12:18:06] <Ms2ger> EIBTI?
[12:18:07] *** Quits: km (quassel@FDBAF0A0.DBF71E41.29C67456.IP) (Ping timeout)
[12:18:27] *** Quits: Tatsuya (Mibbit@4CF559D4.5FB881A2.50CFA630.IP) (Quit: http://www.mibbit.com ajax IRC Client)
[12:18:46] <Thiez> I'm not really sure why that would desugar to Bar::new().deref() anyway, does struct access imply a deref?
[12:19:16] <kimundi> Thiez: field access can do an autoderef
[12:19:30] *** Joins: SiegeLord (sl@moz-CAF07B4C.hsd1.ma.comcast.net)
[12:19:32] <Thiez> yes, when the struct is in a pointer, correct?
[12:19:40] <Thiez> but not when it's on the stack, I would imagine
[12:19:54] <kimundi> rusti: struct Foo{ bar: uint}; (&Foo{bar: 23}).bar
[12:19:55] -rusti- 23
[12:19:58] <Thiez> S.x = no deref, (&S).x = autoderef?
[12:20:26] <Thiez> so for the deref() struct inheritence magic to work, we would have to always deref on field access
[12:20:55] <kimundi> Thiez: Did you read the mailing list post?(
[12:21:10] <Thiez> I did but I didn't find it very enlightening :p
[12:21:53] <Thiez> also it wasn't clear to me why deref can't return &mut instead of &
[12:22:16] <kimundi> What the compiler does in the case of foo.bar is 1. look if the type of foo has a field bar, if yes use that. 2.else deref foo and look if the type you get with that has a field bar
[12:22:34] <Thiez> ah, that makes sense
[12:23:08] <kimundi> same thing as method resolution really
[12:23:38] *** Joins: km (quassel@FDBAF0A0.DBF71E41.29C67456.IP)
[12:24:23] <doomlord_> heh. watching the conversation i learned you can extract the value from a 'newtype struct' with *, thanks :)
[12:24:27] <cmr> It makes me uncomfortable but I'm not convinced it's a bad idea
[12:24:32] <doomlord_> i was doing messy pattern match before
[12:26:06] <Thiez> cmr: it may be worth investigating what traits we would need to model all the current pointer behaviour
[12:27:06] *** Joins: Florob (Florob@moz-39532932.de)
[12:28:38] *** Quits: pyrac (pyrac@moz-F28B7CAD.w90-55.abo.wanadoo.fr) (Quit: pyrac)
[12:28:47] <Thiez> if rust is going to do the 'structs can behave like pointers'-thing I imagine it's best to go all the way
[12:30:03] <cmr> I fear that this will become very complex
[12:30:05] <doomlord_> it wasn't discoverable, but hearing it , its not completely illogical. "here's something that refers to something else. * extracts the thing it refers to .."
[12:30:32] <cmr> doomlord_: yea, I agree
[12:30:34] <doomlord_> i can forgive a hardcoded special case, i dont think they need to have full overload of * to justify that use of the operator
[12:30:37] <cmr> the first time I saw it I was very confused
[12:30:50] <cmr> match ***self
[12:31:56] <doomlord_> i wondered if you could just make tuples array indexable. some_newtype[0] /* get the first and only value*/ ..   some_tuple[0], some_tuple[1] /* == c++ first, .second */
[12:32:30] *** kimundi is now known as zz_kimundi
[12:32:33] <cmr> doomlord_: it's a bit weird, though, because it's not a simple offset operation
[12:32:40] <doomlord_> this would allow symetry in sourcecode when moving from (T,T,T) to [T,..3]
[12:32:41] <cmr> you need to add sizeof(T1) + sizeof(T2)
[12:32:43] <cmr> to get at item 3
[12:33:03] <doomlord_> true but you could consider it as a hard-coded overload of array indexing
[12:33:05] <cmr> and that means you can't have some_tuple[non_constant_i] without runtime machinery
[12:33:07] <cmr> yeah
[12:33:25] <cmr> I think it's a good idea, that's just a consideration that needs to be made
[12:33:50] <doomlord_> sure my suprious suggestion has not been rigourously tested to see all the implications :)
[12:33:55] *** Joins: yuriks (yuriks@9C2CE887.E53EB8F9.8DE25902.IP)
[12:33:57] <Thiez> cmr: it wouldn't be that much runtime overhead, would it?
[12:34:39] <dbaupp> doomlord_: `impl Index<??> for (A,B,C) { fn index(&self, uint) -> ?? }` ?
[12:34:41] <engla> you can't index tuples at runtime, you have to know the type
[12:34:42] <cmr> Thiez: it's more than pointer+i*size
[12:34:50] <Thiez> just having an array somewhere that maps the indices to the offsets would fix it
[12:34:56] <engla> it's not an array :)
[12:35:12] <doomlord_> hmm, maybe it would only work for (A,A,A) ?
[12:35:16] <engla> right
[12:35:20] <cmr> It could work for (A, B, C)
[12:35:22] <dbaupp> doomlord_: I'm pretty sure we need dependent types to fill in the second ?? ... and I'm not sure it'd work for the first ??
[12:35:32] <doomlord_> could compile time [0],[1],[2] be a special case resolving (a,b,c) ..
[12:35:51] <dbaupp> we already have .n0() .n1()
[12:35:56] <engla> the point is, tuples are very unlike arrays
[12:36:07] <doomlord_> oh ok n0 , great
[12:36:18] <dbaupp> rusti: let t = (1i,3f, "foo"); (t.n2(), t.n1(), t.n0())
[12:36:19] -rusti- ("foo", 3, 1)
[12:36:24] *** Joins: pyrac (pyrac@moz-F28B7CAD.w90-55.abo.wanadoo.fr)
[12:36:43] <dbaupp> (they go all the way up to 12-tuples.)
[12:36:52] <doomlord_> ^ tuples are very unlike arrays, but they have been chosen for SIMD vectors which are a bit like fixed-size arrays
[12:37:52] <doomlord_> was it just me , in haskell i couldn't define those n0 n1 .. style accessors for any tuple size... maybe i just didn't know my way around their typeclasses
[12:39:02] *** Quits: z0w0 (zack@moz-E12708D5.lns6.woo.bigpond.net.au) (Client exited)
[12:39:19] <dbaupp> I'm guess it's just you :P (because Rust's type system is almost a strict subset of Haskell's one.)
[12:39:40] <dbaupp> (i think it might be actually a strict subset, but I don't know for sure.)
[12:39:50] <doomlord_> does haskell actually have those?
[12:39:57] <doomlord_> in its stdlibs
[12:40:00] <dbaupp> "those" == ?
[12:40:01] *** Joins: pyrac_ (pyrac@moz-F28B7CAD.w90-55.abo.wanadoo.fr)
[12:40:12] <dbaupp> oh, tuple accessors?
[12:40:15] <doomlord_> n0 n1 n2 equivalent, overloaded for (a) (a,a) ...
[12:40:16] *** Quits: pyrac (pyrac@moz-F28B7CAD.w90-55.abo.wanadoo.fr) (Connection reset by peer)
[12:40:16] *** pyrac_ is now known as pyrac
[12:40:40] <doomlord_> <<< must not distract himself again, stick with rust :)
[12:40:57] <dbaupp> our overloading is just by defining twelve traits that each have n0, 11 of which also include n1, 10 of which include n2, ...
[12:41:11] <dbaupp> i.e. they're actually entirely different methods, just with the same name. (I think.)
[12:41:44] <dbaupp> yup, seems they are.
[12:42:36] <dbaupp> doomlord_: http://stackoverflow.com/questions/15356953/why-are-there-no-general-accessor-functions-for-tuples-in-haskell btw
[12:43:09] <dbaupp> they require functional dependencies between the type parameters (to get true overloading, not like Rust's one)
[12:43:24] <dbaupp> http://hackage.haskell.org/packages/archive/tuple/0.2.0.1/doc/html/Data-Tuple-Select.html
[12:49:21] *** Joins: pnkfelix (pnkfelix@87C1F78E.1DE10CA8.D8E68FF6.IP)
[12:50:55] *** Quits: FrozenCow (FrozenCow@moz-B2DF4929.chello.nl) (Ping timeout)
[13:01:49] <mrordinaire> hi, how can I link Rust with a C function returning a C string?
[13:03:38] <doomlord_> brute force is to create rust_str's from the unsafe *u8 you get from c, but can the c string be 'viewed' as a slice or something?
[13:04:06] <mrordinaire> doomlord: it's a static string
[13:04:21] <mrordinaire> doomlord_: it's a static string
[13:04:26] <mrordinaire> doomlord: sorry, wrong guy
[13:05:01] <dbaupp> mrordinaire: `extern { fn the_function() -> *c_char }` ?
[13:05:47] <dbaupp> (possibly with `#[linkname="name_of_library"] extern ...`, to specify what you're linking against.)
[13:06:17] <mrordinaire> dbaupp: I tried `use std::libc::c_char` and then that but it says `c_char` is undeclared
[13:06:36] <mrordinaire> dbaupp: I thought it was #[link_args = "-lcurl"]
[13:06:51] <dbaupp> mrordinaire: did you have the `use` at the top of the file and the extern in a submodule?
[13:07:00] <mrordinaire> ooooh
[13:07:05] <mrordinaire> dbaupp: so that's the problem
[13:07:09] <mrordinaire> dbaupp: I see
[13:07:21] <dbaupp> and yep, that works, but #[linkname="curl"] should be fine also
[13:07:42] <mrordinaire> dbaupp: cool
[13:07:48] <dbaupp> mrordinaire: yeah, imports are only in-scope for the current mod, and are not in scope for submodules.
[13:07:58] <mrordinaire> dbaupp: thanks
[13:08:22] <dbaupp> (it might be #[link_name] btw; I can't remember.)
[13:08:36] * dbaupp checks
[13:08:53] <mrordinaire> dbaupp: how can I print the string returned?
[13:09:38] <dbaupp> converting it to a Rust ~str would work: std::str::raw::from_c_str
[13:09:52] <dbaupp> (also, yeah, it's #[link_name="name"])
[13:12:42] *** Joins: bheylin (brianheyli@moz-3D24C757.static.chello.nl)
[13:13:11] *** Quits: bheylin (brianheyli@moz-3D24C757.static.chello.nl) (Quit: bheylin)
[13:14:49] *** Quits: SiegeLord (sl@moz-CAF07B4C.hsd1.ma.comcast.net) (Quit: It's a joke, it's all a joke.)
[13:20:40] *** Quits: sankha93 (Instantbir@7061CD01.D6BD0D91.22D41759.IP) (Ping timeout)
[13:21:06] <mrordinaire> dbaupp: thanks
[13:21:34] *** Joins: sankha93 (Instantbir@7061CD01.D6BD0D91.22D41759.IP)
[13:21:49] *** Joins: dherman (dherman@moz-6CA476B1.hsd1.ca.comcast.net)
[13:21:49] *** ChanServ sets mode: +o dherman
[13:22:22] <mrordinaire> dbaupp: i'm trying to link with curl_version (the simplest function) but when I do `rustc curl.rs`, it says curl_version is an undefined reference
[13:22:47] *** Joins: Earnestly (earnest@CAE8D902.48DC5685.39C00A7A.IP)
[13:23:44] <dbaupp> mrordinaire: can you gist the code/error message?
[13:24:04] *** zz_kimundi is now known as kimundi
[13:24:32] <bstrie> mrordinaire: is the C file containing curl_version in the current directory?
[13:25:16] <bstrie> er, the shared lib
[13:25:23] <bstrie> something something systems programming
[13:25:40] <bstrie> er, the static lib
[13:25:43] <bstrie> I'm so bad at this!
[13:25:46] *** Joins: jdm (jdm@92FB48CA.8B5E9DF.9A8C35B4.IP)
[13:26:04] <bstrie> anyway, rust doesn't automatically look in the pwd for linking, you'd have to pass `-L .`
[13:27:45] <mrordinaire> bstrie: no, it's in /usr/lib
[13:27:49] <mrordinaire> dbaupp: https://gist.github.com/mrordinaire/6112880
[13:29:41] <bstrie> hell, I'm not even sure we look in /usr/lib :P
[13:30:04] *** Quits: jfbk (textual@moz-EEA9CFB3.nyc.res.rr.com) (Quit: My MacBook has gone to sleep. ZZZzzzâ€¦)
[13:30:19] <dbaupp> mrordinaire: I believe the #[link_*] need to go on the extern block itself
[13:30:27] <bstrie> I've embedded lua in rust and I've got shell files full of all sorts of possibly-unnecessary cargo cult linking cruft
[13:30:28] <dbaupp> but I can't get that to work either.
[13:31:05] <hoelzro> bstrie: nice.
[13:32:04] <mrordinaire> bstrie: so I should explicitly link to it using `-L <path>`?
[13:32:12] <bstrie> couldn't hurt
[13:32:30] <bstrie> it just adds another directory to the search path
[13:32:53] <bstrie> afaik
[13:33:03] <bstrie> (which isn't very far)
[13:33:24] <dbaupp> you can get rustc to print what it's passing to the linker with -Z print-link-args btw.
[13:35:54] *** Quits: dbaupp (Thunderbir@moz-712A1135.lns20.syd6.internode.on.net) (Ping timeout)
[13:38:20] *** Quits: dherman (dherman@moz-6CA476B1.hsd1.ca.comcast.net) (Quit: dherman)
[13:38:30] <mrordinaire> bstrie: is it #[link_args = "-L /usr/lib64/ -lcurl"] ?
[13:40:23] *** Joins: bheylin (brianheyli@moz-3D24C757.static.chello.nl)
[13:40:26] <mrordinaire> bstrie: okay, I finally got it to work
[13:40:49] *** Joins: miloshadzic (miloshadzi@5E9C7FE4.FA4D0618.449B8A48.IP)
[13:40:51] <bstrie> mrordinaire: I sure hope that didn't work, I was talking about passing that parameter to rustc :P
[13:41:01] <bstrie> but... I guess that might make sense
[13:41:06] <bstrie> it's just passing a string to the linker
[13:41:07] *** Joins: dherman (dherman@moz-6CA476B1.hsd1.ca.comcast.net)
[13:41:07] *** ChanServ sets mode: +o dherman
[13:41:20] <mrordinaire> bstrie: #[link_*] should go right before to the extern block
[13:41:42] <mrordinaire> bstrie: and it's #[link_args = "-lcurl"]
[13:41:56] <bstrie> ok
[13:42:04] *** Quits: q66 (q66@6EE9DE40.46454B5D.33AABD5F.IP) (Ping timeout)
[13:42:21] <mrordinaire> bstrie: thanks a bunch :D
[13:42:31] <bstrie> I should have suggested that myself, I always have to add #[link_args="-llua"] after regenerating my lua bindings
[13:42:31] *** Quits: heftig (heftig@8DB4145A.5C7D981D.FEC4A986.IP) (Quit: Quitting)
[13:42:48] <mrordinaire> bstrie: cool
[13:43:17] <Seldaek> can someone try and explain what that means? error: mismatched types: expected `&str` but found `&~str` (expected &str but found &-ptr) - I fixed it with a clone() but I don't quite get why I have to do that
[13:43:25] *** Joins: q66 (q66@6EE9DE40.46454B5D.33AABD5F.IP)
[13:43:36] <Seldaek> I will also gladly accept links to RTFM :)
[13:43:50] <bstrie> Seldaek: are you aware of how &str is different from other &types right now?
[13:44:00] <Seldaek> I guess not
[13:44:29] <bstrie> well I'm not about to explain it, I don't even fully understand it and it's a distinction that's hopefully going away :)
[13:44:54] <bstrie> basically &str and &[T] are "special" compared to every other &T type
[13:45:05] <bstrie> they're slices rather than just pointers
[13:45:10] <Seldaek> ok so use the clone() hammer and wait until someone smarter fixes it :p
[13:45:13] <bstrie> so they behave slightly differently
[13:45:31] <doener> Seldaek: just * on the value should work
[13:45:33] <bstrie> yeah, .clone() will just copy the string into the unique heap and hand you back a ~str
[13:45:40] <doener> Seldaek: then auto-borrowing should kick in
[13:45:50] <bstrie> Seldaek: .to_str() would probably do the same thing as .clone() in this case
[13:45:51] *** Quits: bheylin (brianheyli@moz-3D24C757.static.chello.nl) (Quit: bheylin)
[13:46:03] <bstrie> though "foo".to_str() is a bit of a wtf :P
[13:46:17] <bstrie> actually there might be a .to_owned() method
[13:46:17] <Seldaek> well in this case it's a str var from os::args() 
[13:46:34] <doener> Seldaek: simplified, you're basically giving it a pointer pointer where it expects a pointer
[13:46:39] <Seldaek> so it doesn't look too weird, but I'd just like to know what I'm doing
[13:47:33] <Seldaek> ok so those 3 variants work: os::getenv(*env_var) os::getenv(env_var.to_owned()) and os::getenv(env_var.clone())
[13:47:47] <Seldaek> so I'd say doener's * wins for brevity
[13:47:50] <doener> use the first one, that doesn't copy
[13:47:53] *** Joins: lmandel (lmandel@moz-AEAD2F61.dsl.bell.ca)
[13:48:14] <Seldaek> doener: so * accesses the value of the pointer's pointer, which is the inner pointer,
[13:48:14] <doener> Seldaek: the method calls do the deref + a method call that copies
[13:48:45] <Seldaek> doener: s/,/?/ :)
[13:48:58] <doener> Seldaek: right. *env_var is of type ~str, and a process called auto-borrowing / auto-slicing turns that into the required &str
[13:49:14] <Seldaek> ok I see, sort of
[13:49:19] <Seldaek> thanks
[13:51:19] <doener> Seldaek: with the method call, the compiler sees that you're trying to call a method of &str on a &~str. Because method calls also auto-deref, the compiler first does the * thing internally.
[13:51:39] *** Joins: ChrisMorgan (chris@moz-6AC741CA.static.tpgi.com.au)
[13:51:46] <doener> Seldaek: so now it has a ~str. Then, it does the auto-slicing to get a &str. With that it does the method call.
[13:52:10] <doener> Seldaek: The method returns a new ~str (copy of the original string), which is then auto-sliced _again_
[13:52:45] <doener> Seldaek: so the plain deref version using * is a lot more efficient
[13:54:24] <doener> put differently, if there was no auto-deref support, you would have to write: (*env_var).to_owned()
[13:57:26] *** Joins: jedestep (jedestep@34641662.FB4DE631.66C78B76.IP)
[13:58:19] *** Joins: ghrust (ghrust@AD60B2E3.6A2AE50.F3114085.IP)
[13:58:19] <ghrust> 01[13rust01] 15bors merged 06auto into 06master: 02http://git.io/dhonng
[13:58:19] *** Parts: ghrust (ghrust@AD60B2E3.6A2AE50.F3114085.IP) ()
[13:59:12] <Seldaek> doener: ok, thanks for the lenghtier version :)
[14:00:00] <smvv> what is catamorphism's irc name?
[14:00:04] <cmr> tjc
[14:01:17] <smvv> and when is he normally around? i've a patch that fixes the `rustdoc hangs when pandoc is not found' and `linker phase hangs when cc is not found on Mac'
[14:01:20] *** Joins: ghrust (ghrust@C621748.6A2AE50.F3114085.IP)
[14:01:20] <ghrust> 01[13rust01] 15bors pushed 0 new commits to 06auto: 02http://git.io/4E1fMw
[14:01:20] *** Parts: ghrust (ghrust@C621748.6A2AE50.F3114085.IP) ()
[14:01:21] *** Joins: ghrust (ghrust@C8693FCB.6A2AE50.F3114085.IP)
[14:01:21] <ghrust> 01[13rust01] 15bors pushed 2 new commits to 06auto: 02http://git.io/Ps82rg
[14:01:21] <ghrust> 13rust/06auto 14ef870d3 15Daniel Micay: implement pointer arithmetic with GEP...
[14:01:21] <ghrust> 13rust/06auto 14576f395 15bors: auto merge of #8121 : thestinger/rust/offset, r=alexcrichton...
[14:01:22] *** Parts: ghrust (ghrust@C8693FCB.6A2AE50.F3114085.IP) ()
[14:01:48] <bstrie> smvv: usually around 9:00am california time
[14:02:00] <smvv> ok thanks
[14:02:08] <cmr> smvv: don't put too much work into keeping rustdoc alive, it's being replaced
[14:02:40] <smvv> cmr: it has nothing to do with rustdoc. it's about std::run, which is used in rustdoc to invoke pandoc
[14:03:56] <Seldaek> doener: related question, expected `&~str` but found `&'static str` - what's the best way to fix it? &~"foo" works but it feels weird
[14:04:04] *** Joins: Kruppe (user@moz-E150F49F.cpe.net.cable.rogers.com)
[14:04:12] *** Quits: ChrisMorgan (chris@moz-6AC741CA.static.tpgi.com.au) (Ping timeout)
[14:04:29] *** xraycat is now known as lhatsk
[14:05:11] <cmr> smvv: oh, good!
[14:05:18] <smvv> cmr: but thanks for letting me know :-)
[14:06:11] <kimundi> Seldaek: If it wants a &~str, then &~"foo" is the only way :P
[14:06:51] <kimundi> only solution is to not use something that wants a &~str :P
[14:07:27] <Seldaek> hah
[14:08:18] *** Quits: km (quassel@FDBAF0A0.DBF71E41.29C67456.IP) (Ping timeout)
[14:08:34] <Ms2ger> Right; why would anyone want a &~str?
[14:08:36] <kimundi> but seriosly, a &~str doesn't make much sense... You can't mutate it, so it might just as well be a &str
[14:08:47] <Seldaek> is there a way to match (this or that) { Some(whichever matched) => .. } ?
[14:08:47] *** Joins: km (quassel@FDBAF0A0.DBF71E41.29C67456.IP)
[14:08:49] <kimundi> a &mut ~str has usecases, but this...
[14:08:52] *** Quits: lhatsk (Adium@moz-104CF07C.pool.mediaways.net) (Quit: Leaving.)
[14:09:05] <engla> only place it will appear is in traits impl on ~str
[14:09:19] <kimundi> Seldaek: Nope, but you could create a enum for this or that
[14:09:24] <Seldaek> Ms2ger, kimundi: vec::position_elem wants one
[14:09:42] *** Joins: FrozenCow (FrozenCow@moz-B2DF4929.chello.nl)
[14:09:52] *** Joins: lhatsk (Adium@moz-104CF07C.pool.mediaways.net)
[14:10:02] <Seldaek> kimundi: don't think an enum is possible to match on two .position_elem() calls though?
[14:10:52] <Seldaek> basically I want to do match args.position_elem(&~"--version") {}  and the same with -v 
[14:10:57] <kimundi> wait, are this on thgat differen types or just different values?
[14:11:08] <Seldaek> but without duplicating the match body
[14:11:17] *** Quits: naq (naq@D5C2D2DF.E4265FCD.E481B5B.IP) (Connection reset by peer)
[14:11:25] <kimundi> because different values totally works, that's one of the purposes of match
[14:11:27] *** Joins: fzzzy (fzzzy@A5CBE5CF.A81CC6E.44FA8ED.IP)
[14:11:58] <Seldaek> let me show you some code it'll be easier
[14:12:38] *** Quits: jaen (jaen@moz-2FADB812.neoplus.adsl.tpnet.pl) (Ping timeout)
[14:13:23] <kimundi> Seldaek: rather than calling poition_elemn twice, I'd just iterate over all elements and match on them
[14:13:31] *** Joins: jorendorff (jorendorff@moz-2F32ACA3.hsd1.tn.comcast.net)
[14:13:33] <Seldaek> https://gist.github.com/Seldaek/9cf7aced7c7841891e63
[14:13:40] <Seldaek> yes iterating is another way of course
[14:13:51] <Seldaek> there are many ways I can solve it but I was curious if something like that would be possible
[14:14:10] *** Quits: Florob (Florob@moz-39532932.de) (Client exited)
[14:14:18] <Seldaek> but I guess it'd be hard to make sense of it :)
[14:14:49] <kimundi> it is only possible by calling the function twice, somehow collecting both results into one strutcute, and then decide on the results
[14:15:13] <Seldaek> indeed
[14:16:10] <kimundi> Seldaek: One way to use on match block: https://gist.github.com/Kimundi/65f1e0fcdfbc655824fb
[14:18:39] <kimundi> Seldaek: Or, alternativly, look into wich methods there are on Option
[14:18:44] *** Joins: Scriptor (historium@moz-E06F46F0.corp.bitshelter.com)
[14:19:29] <Seldaek> kimundi: nice one, but that doesn't really help with duplication though
[14:19:48] <kimundi> Seldaek: There might be a method on option for chainig both calls.
[14:20:13] <kimundi> so, if either of them is Some you get a Some , else an None
[14:20:25] <Seldaek> hm yeah maybe with .add()
[14:20:27] <Seldaek> let's try this
[14:21:09] <kimundi> I think
[14:21:34] <kimundi> match args.position_elem(&~"--version").or(args.position_elem(&~"-v")) { Some(_) => ... } will work
[14:22:07] <Seldaek> kimundi: this one works https://gist.github.com/Seldaek/9cf7aced7c7841891e63
[14:22:30] <kimundi> da hell does add do xD
[14:22:37] <Seldaek> yours works too though
[14:22:42] <Seldaek> sounds better
[14:22:58] <Ms2ger> if args.position_elem(&~"--version").or(args.position_elem(&~"-v")).is_some()?
[14:23:28] <kimundi> urk, it's that strange add implemnetation ahgain...
[14:23:42] <Seldaek> Ms2ger: ah yes, that'd save some match boilerplate
[14:24:08] <kimundi> Seldaek: You don't want add, that kill break if both -v and --version are given... than it will add both return values
[14:24:29] <Seldaek> ok yeah that'd be weird
[14:25:07] <Seldaek> this works just fine https://gist.github.com/Seldaek/9cf7aced7c7841891e63 - thanks both
[14:25:25] *** Quits: pnkfelix (pnkfelix@87C1F78E.1DE10CA8.D8E68FF6.IP) (Connection reset by peer)
[14:25:32] *** Joins: pnkfelix (pnkfelix@A34AB32F.6B30872B.A515248C.IP)
[14:26:07] *** Quits: mrordinaire (Mibbit@8487BAED.E79832F4.8BC4C3B1.IP) (Quit: http://www.mibbit.com ajax IRC Client)
[14:31:10] <kimundi> It even reads fine :D
[14:32:16] *** Quits: pnkfelix (pnkfelix@A34AB32F.6B30872B.A515248C.IP) (Ping timeout)
[14:32:22] *** Joins: pnkfelix (pnkfelix@A34AB32F.6B30872B.A515248C.IP)
[14:32:52] *** Joins: jaen (jaen@moz-3BFC8C1F.play-internet.pl)
[14:32:54] <Seldaek> eh well, looks like I could use std::getops too :p
[14:34:57] *** Quits: BitPuffin (quassel@moz-49828767.cust.tele2.se) (Ping timeout)
[14:35:02] *** Joins: erickt (Adium@49C4075F.3AC15C18.2321E71E.IP)
[14:35:15] *** Quits: erickt (Adium@49C4075F.3AC15C18.2321E71E.IP) (Quit: Leaving.)
[14:36:24] *** Joins: pnathan (Adium@moz-BDC3EE62.tukw.qwest.net)
[14:41:21] *** Quits: sankha93 (Instantbir@7061CD01.D6BD0D91.22D41759.IP) (Ping timeout)
[14:50:55] <bstrie> cmr: so pub and priv denote module-level privacy rather than crate-level privacy?
[14:51:01] * bstrie reading the ML
[14:51:18] <cmr> bstrie: both
[14:51:23] <cmr> afaict
[14:51:42] <cmr> I had to make my "private" modules in rustdoc_ng `pub` so that the other modules could use the types they define
[14:52:11] <bstrie> what if everything was public within a module, and privacy only applied when you crossed the crate boundary?
[14:52:23] <cmr> I'd be perfectly OK with that
[14:52:28] <bstrie> is that sound though?
[14:52:31] <cmr> Dunno
[14:52:38] <cmr> There's probably other considerations I'm not considering either
[14:52:43] <jedestep> one thing that always bothered me is that only public functions are available to submodules
[14:52:55] <jedestep> I feel like default modifier functions should be available to submodules as well
[14:53:00] <bstrie> *what if everything was public within a _crate_, and privacy only applied when you crossed the crate boundary
[14:53:26] <jedestep> that seems like it would make sense
[14:53:46] <engla> bstrie: it would make it easier to tangle modules up with each other, of course
[14:54:09] <bstrie> engla: true, but does it make sense to split out modules into their own crates if you're worried about tangling?
[14:54:16] <cmr> bstrie: I don't think it does
[14:54:18] <SimonSapin> rusti: "a\x00b".as_bytes()
[14:54:19] -rusti- &[97, 0, 98]
[14:54:29] <SimonSapin> rusti: "a\x00b".as_bytes_with_null()
[14:54:30] -rusti- <anon>:5:9: 6:5 error: type `&'static str` does not implement any method in scope named `as_bytes_with_null`
[14:54:30] -rusti- <anon>:5          "a\x00b".as_bytes_with_null()
[14:54:30] -rusti- <anon>:6     };
[14:54:30] -rusti- error: aborting due to previous error
[14:54:30] -rusti- application terminated with error code 101
[14:54:53] <cmr> Maybe if we had static linking, but it'd still feel hackish
[14:55:36] <SimonSapin> rusti: use std::str::NullTerminatedStr; "a\x00b".as_bytes_with_null()
[14:55:37] -rusti- <anon>:5:42: 6:5 error: type `&'static str` does not implement any method in scope named `as_bytes_with_null`
[14:55:37] -rusti- <anon>:5          use std::str::NullTerminatedStr; "a\x00b".as_bytes_with_null()
[14:55:37] -rusti- <anon>:6     };
[14:55:37] -rusti- error: aborting due to previous error
[14:55:38] -rusti- application terminated with error code 101
[14:55:59] <SimonSapin> rusti: ~"a\x00b".as_bytes_with_null()
[14:56:00] -rusti- <anon>:5:10: 6:5 error: type `&'static str` does not implement any method in scope named `as_bytes_with_null`
[14:56:00] -rusti- <anon>:5          ~"a\x00b".as_bytes_with_null()
[14:56:00] -rusti- <anon>:6     };
[14:56:00] -rusti- error: aborting due to previous error
[14:56:00] -rusti- application terminated with error code 101
[14:56:03] <engla> bstrie: not sure, crates can be pretty big
[14:56:13] <SimonSapin> rusti: (~"a\x00b").as_bytes_with_null()
[14:56:14] -rusti- more than 5 lines of output, pastebinned: http://sprunge.us/fMCi
[14:56:41] *** Quits: pnkfelix (pnkfelix@A34AB32F.6B30872B.A515248C.IP) (Quit: Leaving.)
[14:58:35] *** Joins: nano (nano@moz-972880B.superkabel.de)
[14:59:44] *** Joins: pnkfelix (pnkfelix@87C1F78E.1DE10CA8.D8E68FF6.IP)
[15:03:09] *** Quits: dherman (dherman@moz-6CA476B1.hsd1.ca.comcast.net) (Quit: dherman)
[15:08:13] <jedestep> is extra::json benchmarked anywhere?
[15:08:20] *** Joins: tchoma (tchoma@moz-E58E29CC.dsl.static.sonic.net)
[15:08:54] *** Quits: tupshin (quassel@moz-E7B03838.c3-0.nyr-ubr1.nyr.ny.cable.rcn.com) (Ping timeout)
[15:09:40] <cmr> jedestep: the person who did the recent perf improvements had a benchmark
[15:09:56] *** Quits: tchoma (tchoma@moz-E58E29CC.dsl.static.sonic.net) (Quit: tchoma)
[15:10:35] <cmr> glinscott
[15:10:50] <cmr> "Reading example.json 100 times before was around 1.18s." (https://github.com/mozilla/rust/pull/7704)
[15:10:56] *** Joins: tupshin (quassel@moz-E7B03838.c3-0.nyr-ubr1.nyr.ny.cable.rcn.com)
[15:10:56] *** Joins: strcat (strcat@moz-54F7FD49.cpe.net.cable.rogers.com)
[15:11:04] <jedestep> hmm
[15:11:11] <jedestep> I'm interested to see what the benchmarks were
[15:11:29] <jedestep> because I could use some benchmarks for my own json parser :x
[15:11:36] <jdm> pauls: ping
[15:14:41] <Seldaek> is there a way to get the crate name/version as defined in #[link()] ?
[15:15:08] *** Joins: infynyxx (infynyxx@moz-E95B370B.nyc.res.rr.com)
[15:15:10] <cmr> Seldaek: see how rustdoc_ng does it
[15:15:23] <Seldaek> I mean in the crate itself
[15:15:27] <cmr> oh
[15:15:31] <cmr> no I don't think so
[15:15:40] <Seldaek> just want to avoid repeating the version and name everywhere
[15:15:47] <Seldaek> it'd be good to have a way to reuse those
[15:15:53] <cmr> yeah
[15:18:31] *** Quits: pnathan (Adium@moz-BDC3EE62.tukw.qwest.net) (Quit: Leaving.)
[15:20:26] *** Joins: azita (Azita@87C1F78E.1DE10CA8.D8E68FF6.IP)
[15:21:41] *** Joins: graydon (graydon@moz-F14EE0DB.cable.teksavvy.com)
[15:21:42] *** ChanServ sets mode: +qo graydon graydon
[15:22:40] *** Quits: paulproteus (quassel@rose.makesad.us) (Ping timeout)
[15:23:32] *** Joins: paulproteus (quassel@moz-E86A3B42.makesad.us)
[15:24:37] *** Joins: pnathan (Adium@moz-BDC3EE62.tukw.qwest.net)
[15:24:52] *** Quits: jaen (jaen@moz-3BFC8C1F.play-internet.pl) (Ping timeout)
[15:24:58] *** Joins: yonran (yonran@moz-962F33EB.acuitus.com)
[15:25:03] *** Joins: bent (chatzilla@moz-BE33DA21.fw1.sfo1.mozilla.net)
[15:25:46] *** Joins: devinus (devinus@moz-B4AF84BC.ptr.us.xo.net)
[15:29:00] *** Joins: cubic (cubic@moz-FE5AD6C7.mc.videotron.ca)
[15:32:46] *** Quits: Kruppe (user@moz-E150F49F.cpe.net.cable.rogers.com) (Client exited)
[15:34:54] *** Quits: jedestep (jedestep@34641662.FB4DE631.66C78B76.IP) (Ping timeout)
[15:36:59] <cmr> My shirt just came
[15:37:01] <cmr> It is quite awesome
[15:38:06] <olsonjeffery> cmr: yeah, they're nice
[15:38:53] *** Joins: int3_ (int3_@moz-ABE52D50.hsd1.ca.comcast.net)
[15:39:15] *** Joins: henrikhodne (henrikhodn@moz-F3A92B1C.hsd1.ca.comcast.net)
[15:40:41] *** Quits: int3_ (int3_@moz-ABE52D50.hsd1.ca.comcast.net) (Ping timeout)
[15:41:03] <strcat> graydon: that GEP thing sped up vec::from_elem by 5x :)
[15:41:10] <Seldaek> cmr: rust shirts?
[15:41:11] <graydon> I noticed!
[15:41:35] *** Quits: pnathan (Adium@moz-BDC3EE62.tukw.qwest.net) (Quit: Leaving.)
[15:42:07] * doener is jealous
[15:42:33] <cmr> Seldaek: yes
[15:42:45] <Seldaek> doener: indeed! :)
[15:43:01] <strcat> graydon: I think it's possible we're doing something really awful with @ resulting in code bloat ;S
[15:43:08] <strcat> they seem to be treated as opaque_box
[15:43:13] <strcat> until they're nested in something
[15:43:23] *** Joins: ghrust (ghrust@FD7BC443.6A2AE50.F3114085.IP)
[15:43:23] <ghrust> 01[13rust01] 15bors merged 06auto into 06master: 02http://git.io/Ps82rg
[15:43:23] *** Parts: ghrust (ghrust@FD7BC443.6A2AE50.F3114085.IP) ()
[15:43:23] <strcat> so it actually deals with them by dynamically reading the tydesc
[15:43:32] <strcat> it's why...
[15:43:35] <strcat> rusti: @5
[15:43:38] -rusti- @5
[15:43:39] <strcat> rusti: @mut 5
[15:43:40] -rusti- @5
[15:43:43] <strcat> rusti: (@mut 5,)
[15:43:44] -rusti- (@mut 5,)
[15:43:45] <strcat> that happens.
[15:43:47] <Seldaek> doener: a quick search turns up dubious results, but if you want one too.. http://www.zazzle.com/in_rust_we_trust_t_shirt-235508634520122670 http://www.zazzle.com/blue_iron_texture_wall_t_shirts-235225785298284794
[15:44:07] <cmr> nooo silly
[15:44:16] <strcat> I don't really understand why opaque_box exists at all
[15:44:30] <doener> strcat: @Trait?
[15:44:31] *** Quits: BizarreCake (BizarreCak@moz-361FE9B2.dynamic.barak-online.net) (Client exited)
[15:44:57] *** Joins: dherman (dherman@moz-6CA476B1.hsd1.ca.comcast.net)
[15:44:57] *** ChanServ sets mode: +o dherman
[15:44:58] <strcat> doener: maybe
[15:46:22] <doener> Seldaek: http://www.flickr.com/photos/lindseykuper/9183991477/
[15:46:22] *** Joins: ghrust (ghrust@9C8B94D4.6A2AE50.F3114085.IP)
[15:46:22] <ghrust> 01[13rust01] 15bors pushed 0 new commits to 06auto: 02http://git.io/zhcHYw
[15:46:22] *** Parts: ghrust (ghrust@9C8B94D4.6A2AE50.F3114085.IP) ()
[15:46:23] *** Joins: ghrust (ghrust@2EE61FCC.6A2AE50.F3114085.IP)
[15:46:23] <ghrust> 01[13rust01] 15bors pushed 2 new commits to 06auto: 02http://git.io/yDmh5g
[15:46:23] <ghrust> 13rust/06auto 1407dd622 15BjÃ¶rn Steinbrink: Allow early release of rvalues in assignments...
[15:46:23] <ghrust> 13rust/06auto 140bedd7a 15bors: auto merge of #8123 : dotdash/rust/temporaries, r=huonw...
[15:46:24] *** Parts: ghrust (ghrust@2EE61FCC.6A2AE50.F3114085.IP) ()
[15:46:27] <strcat> I don't see why top-level @ are turned into them though
[15:46:48] <graydon> strcat: opaque box is there to help with monomorphization. or it was, long ago. I'm not sure what its current function is. I suspect you should ask pcwalton when he's in.
[15:47:30] <doener> strcat: is it the general code, or is it the reflection code used for the string output?
[15:47:30] <Seldaek> doener: darn that does look better
[15:48:00] <strcat> doener: general code afaict
[15:48:12] <strcat> doener: it's an opaque box when it enters the glue code
[15:48:25] <strcat> but if it's contained in something else, it's not
[15:48:30] <doener> hu? I'm pretty sure it wasn't yesterday
[15:48:46] *** Quits: dherman (dherman@moz-6CA476B1.hsd1.ca.comcast.net) (Quit: dherman)
[15:49:00] <strcat> doener: it might be something specific to the way visit glue is called, but I don't see where that would happen
[15:49:51] *** Joins: Florob (Florob@moz-39532932.de)
[15:50:16] <doener> strcat: definitely not an opaque box when with a simple "fn main() { let x = @5 }"
[15:50:36] *** Joins: Jeaye (Jeaye@moz-FD505E54.hsd1.ca.comcast.net)
[15:50:38] <doener> neither for @Foo { x: @5 }
[15:50:49] <cmr> rusti: let x = @5; fmt!("%?", x)
[15:50:50] -rusti- ~"@5"
[15:50:55] <cmr> rusti: let x = @5; fmt!("%?", @5)
[15:50:56] -rusti- <anon>:5:13: 5:14 warning: unused variable: `x` [-W unused-variable (default)]
[15:50:56] -rusti- <anon>:5          let x = @5; fmt!("%?", @5)
[15:50:57] -rusti-                       ^
[15:50:57] -rusti- ~"@5"
[15:51:13] <strcat> doener: maybe has to do with generic fns
[15:51:30] <strcat> pub fn write_repr<T>(writer: @Writer, object: &T) {
[15:52:24] <doener> strcat: yeah, monomorphization turns all boxes into opaque ones
[15:52:38] *** Joins: tiffany (kawaii@moz-EB8B0C08.dhcp.embarqhsd.net)
[15:53:50] <strcat> I wonder if that means write barriers for @mut are handled wrong
[15:54:15] *** Joins: tedh (tedh@moz-F0B37C08.hsd1.il.comcast.net)
[15:54:15] *** Quits: henrikhodne (henrikhodn@moz-F3A92B1C.hsd1.ca.comcast.net) (Ping timeout)
[15:54:19] *** Joins: henrikhodne (henrikhodn@moz-F3A92B1C.hsd1.ca.comcast.net)
[15:55:28] *** Quits: busylizzy (lisa@85228838.12D0DC84.211374C4.IP) (Ping timeout)
[15:55:29] *** cade is now known as cade_away
[15:55:33] *** Joins: busylizzy (lisa@85228838.12D0DC84.211374C4.IP)
[15:55:58] <strcat> heh
[15:56:07] *** Quits: henrikhodne (henrikhodn@moz-F3A92B1C.hsd1.ca.comcast.net) (Ping timeout)
[15:56:14] <strcat> git treated the #[bench] in my commit msg as comments
[15:56:19] <strcat> should have realized it would do that
[15:57:33] <graydon> doener: apologies, I just stopped your build
[15:57:59] *** Joins: ecr (Thunderbir@moz-F724119C.uoregon.edu)
[15:58:03] <graydon> doener: the rvalue lifetime thing is an open bug, and I think the PR you submitted changes them in an opposite-to-intended direction
[15:58:17] <graydon> nmatsakis: can you take a look at https://github.com/mozilla/rust/pull/8123 ?
[15:58:27] <graydon> nmatsakis: I stopped it because it needs more-careful review
[15:58:44] *** Joins: heftig (heftig@6835D69C.6FC4DE2F.FEC4A986.IP)
[15:58:58] <nmatsakis> graydon: ok. meeting now?
[15:59:03] <graydon> yes
[15:59:49] *** Joins: erickt (erickt@8C9ECD8F.3A598286.F12515B4.IP)
[16:01:29] *** Quits: erickt (erickt@8C9ECD8F.3A598286.F12515B4.IP) (Ping timeout)
[16:01:29] *** Joins: vodik (simon@moz-CBE4BB13.cable.teksavvy.com)
[16:03:24] *** Joins: erickt (erickt@8C9ECD8F.3A598286.F12515B4.IP)
[16:04:37] *** Joins: barosl (barosl@E287D94F.C81E10FB.7544CABF.IP)
[16:05:12] <graydon> https://etherpad.mozilla.org/Meeting-weekly-2013-07-30
[16:05:33] <doener> graydon: no problem, good thing you catched that early on
[16:05:34] *** Quits: robertknight (robertknig@moz-54528EE0.wby.mendeley.com) (Quit: Computer has gone to sleep.)
[16:06:26] *** Joins: vosen (vosen@moz-266BA656.icpnet.pl)
[16:07:16] <erickt> graydon: in addition to lifetimes on unsafe ptrs, please also consider bstrie's idea about implementing unsafe ptrs in a library
[16:09:17] *** Joins: brson (brson@moz-BBE3ABD.mv.mozilla.com)
[16:09:17] *** ChanServ sets mode: +o brson
[16:10:53] <graydon> erickt: I'm not sure I feel qualified to speak on that
[16:11:14] *** Joins: pcwalton (pcwalton@moz-7B0110AD.mv.mozilla.com)
[16:11:14] *** ChanServ sets mode: +o pcwalton
[16:11:24] *** Joins: jaen (jaen@moz-E0979827.copit.pl)
[16:11:32] *** Quits: lhatsk (Adium@moz-104CF07C.pool.mediaways.net) (Quit: Leaving.)
[16:11:37] <erickt> graydon: no problem, I haven't fully thought it through yet either :)
[16:12:32] <cmr> erickt: how would that be possible?
[16:12:49] <strcat> intrinsics
[16:12:53] <cmr> ah
[16:13:22] <strcat> erickt: finally fixed your vec::from_elem issue \o/
[16:13:23] <erickt> cmr: and that &T pointers are system pointers
[16:13:26] <erickt> !!
[16:13:29] <strcat> took several PRs ;p
[16:13:29] <erickt> yay!
[16:14:15] <erickt> cmr: I go into more detail on https://github.com/mozilla/rust/pull/7967
[16:14:18] <strcat> 700ns -> 84ns overall
[16:14:29] <erickt> strcat: that's awesome
[16:14:31] <bstrie> I like how people keep calling this my idea, when all I did was mention it once via the precedent of @T -> Gc<T> :P
[16:14:32] <pcwalton> wonder if that might improve compile speed
[16:14:47] <strcat> pcwalton: it might, it means hash tables are initialized 5x faster
[16:14:54] <strcat> well and grown, I guess
[16:15:07] <toddaaro> brson: where is the rt-start-main-thread test case?
[16:15:19] <erickt> bstrie: well someone did say "what about bstrie's Unsafe<T> type?" and it got me thinking :)
[16:16:04] <bstrie> I should give it a catchier name. it doesn't hold a candle to IHTAMAWAM
[16:16:07] <erickt> strcat: well done :)
[16:17:21] <cmr> strcat: that's seriously pretty awesome
[16:17:28] <bblum> argh, there is just no sensible way to structure this code
[16:17:33] <bblum> anything i do will be ugly
[16:17:34] <erickt> strcat: I think it was my first micro benchmark that was actually relevant
[16:17:51] <cmr> erickt: did you add it to the test suite?
[16:18:14] <strcat> erickt: the fixes should help elsewhere too
[16:18:14] <erickt> cmr: I think someone else did, let me confirm
[16:18:32] <strcat> the first big issue was with_capacity doing 2 allocations, and the 2nd was pointer arithmetic essentially being slow (by throwing out aliasing info)
[16:19:18] * strcat wonders what other easy to fix perf bugs we have
[16:19:26] <bstrie> strcat: really awesome. has that already landed?
[16:19:29] <strcat> bstrie: yes
[16:19:36] * bstrie recompiles
[16:19:38] <strcat> the with_capacity fix was a while ago
[16:19:53] <strcat> but the recent one was a 5x improvement, it landed a few minutes ago ;p
[16:20:30] <strcat> bstrie: f74250e3a970f81388a73aeb8f3d53304d77c34b was the other, pre-header removal too
[16:20:41] <strcat> anyway vectors are reasonably fast these days
[16:20:47] <strcat> only remaining issue seems to be FFI overhead
[16:20:58] <bstrie> are we still a version behind on llvm?
[16:21:06] <strcat> bstrie: I think we're at 3.3
[16:21:33] <bstrie> mmm, new snapshot
[16:21:34] <strcat> but there are big changes in svn already (since 3.4 was branched before they released 3.3)
[16:21:56] *** Joins: eschweic (Adium@moz-BBE3ABD.mv.mozilla.com)
[16:22:02] *** Joins: eatkinson (eatkinson@moz-BBE3ABD.mv.mozilla.com)
[16:22:10] <bstrie> one of these days maybe we'll upgrade before an official llvm release so that we can get mentioned in their release notes :)
[16:22:14] <cmr> erickt: are you watching the meeting?
[16:22:30] <toddaaro> brson: grepping around for that string finds nothing, not sure where I should be looking, are the make check testnames created out of something?
[16:22:48] *** Quits: huseby (huseby@moz-4E8C421A.husebyhome.com) (Quit: Leaving)
[16:23:40] <Luqman> toddaaro: do you mean src/test/run-pass/rt-start-main-thread.rs ?
[16:24:27] *** Joins: ozten (ozten@moz-DD3B00B4.hsd1.wa.comcast.net)
[16:24:46] *** Joins: mihneadb (mihneadb@moz-BE33DA21.fw1.sfo1.mozilla.net)
[16:25:06] <strcat> erickt: btw I like the idea of just using &T more
[16:25:19] <strcat> if a C function takes a pointer parameter and it has to be valid, it could use &T
[16:25:29] <strcat> if it can be nullable, it could use Option<&T>
[16:25:38] <erickt> I agree. &T would be fine, but the automatic cast to *T has caused problems
[16:25:46] <cmr> A bit weird to be using Option in an FFI IMO
[16:25:56] <strcat> cmr: well atm it's likely broken
[16:25:58] <toddaaro> Luqman: ah, thanks, I have no idea why grep can't find that
[16:25:59] <strcat> but we could make it work
[16:26:06] <toddaaro> I guess it isn't searching filenames like I thought it was
[16:26:22] <strcat> I don't think it's strange to list a set of guarantees about our memory layout
[16:26:29] <strcat> and then start relying on those guarantees
[16:27:33] *** Quits: devinus (devinus@moz-B4AF84BC.ptr.us.xo.net) (Quit: Computer has gone to sleep.)
[16:28:19] <erickt> strcat: but we said in the past we don't guarantee the memory layout of enums so we can optimize Option<&T>. But then if we start using Option<&T> in FFIs, we're relying on it
[16:28:38] <strcat> erickt: we could provide guarantees about some enums though
[16:28:41] <strcat> just not enums overall
[16:29:12] <strcat> I don't think we'll ever have a reason to represent 'enum Foo<T> { Bar, Baz(&T) }' as anything but a nullable ptr
[16:29:38] *** Quits: Egbert9e9 (Egbert9e9@moz-366B5D68.inter.net.il) (Quit: Egbert9e9)
[16:29:49] <strcat> there are things we wouldn't want to provide a guarantee about, like slices/vectors/strings
[16:29:58] <strcat> because there are many ways of skinning that cat
[16:30:11] <strcat> or enums in general
[16:30:14] <bstrie> would we need a lang item for Option, then?
[16:30:20] <strcat> no
[16:30:37] <cmr> it's a structural optimization, not a nominal one
[16:30:53] *** Quits: erickt (erickt@8C9ECD8F.3A598286.F12515B4.IP) (Quit: Leaving.)
[16:30:55] <bstrie> ok
[16:30:59] <strcat> the guarantee could be for an enum with a null variant + non-nullable pointer type in general, since that's what the optimization works on
[16:31:26] *** Joins: erickt (erickt@8C9ECD8F.3A598286.F12515B4.IP)
[16:31:37] <strcat> well, non-nullable borrowed pointer.
[16:31:44] *** Joins: webber46 (webber46@moz-98D2F3C5.cust.bredband2.com)
[16:32:55] *** Quits: jensnockert (jensnocker@moz-C5F27039.cust.bredband2.com) (Connection reset by peer)
[16:33:31] *** Joins: jensnockert (jensnocker@moz-C5F27039.cust.bredband2.com)
[16:34:19] *** Joins: ghrust (ghrust@DE823A67.6A2AE50.F3114085.IP)
[16:34:19] <ghrust> 01[13rust01] 15bors 04force-pushed 06auto from 140bedd7a to 14576f395: 02http://git.io/N3iJvQ
[16:34:19] *** Parts: ghrust (ghrust@DE823A67.6A2AE50.F3114085.IP) ()
[16:34:22] *** Joins: ghrust (ghrust@1E8607E8.6A2AE50.F3114085.IP)
[16:34:22] <ghrust> 01[13rust01] 15bors pushed 3 new commits to 06auto: 02http://git.io/o8K_7g
[16:34:22] <ghrust> 13rust/06auto 14b6ea053 15Brendan Zabarauskas: Add some missing method wrappers to std::num
[16:34:22] <ghrust> 13rust/06auto 144f65fc7 15Brendan Zabarauskas: Improve std::num module description, and fix some formatting
[16:34:22] <ghrust> 13rust/06auto 149aee8e4 15bors: auto merge of #8115 : bjz/rust/num-traits, r=brson...
[16:34:24] *** Parts: ghrust (ghrust@1E8607E8.6A2AE50.F3114085.IP) ()
[16:35:10] <strcat> erickt: ones like vec::raw::to_ptr could just use & too
[16:35:13] <strcat> & coerces to *
[16:35:20] <strcat> so you lose nothing by using a lifetime on &
[16:36:05] *** Quits: erickt (erickt@8C9ECD8F.3A598286.F12515B4.IP) (Quit: Leaving.)
[16:36:37] *** Joins: erickt (erickt@8C9ECD8F.3A598286.F12515B4.IP)
[16:38:02] *** Quits: Jesse (jruderman@moz-537BCF9.hsd1.ca.comcast.net) (Quit: Jesse)
[16:38:40] <bjz_> Florob: hoy
[16:38:49] <Florob> bjz_, hi
[16:43:06] *** Joins: Sergio965 (sergiobz@moz-92077B8C.dyn.mit.edu)
[16:47:05] *** Joins: sankha93 (Instantbir@7061CD01.D6BD0D91.22D41759.IP)
[16:47:17] *** Joins: mhordecki (mhordecki@moz-BE33DA21.fw1.sfo1.mozilla.net)
[16:48:12] *** Joins: jedestep (jedestep@34641662.FB4DE631.66C78B76.IP)
[16:48:45] *** Quits: erickt (erickt@8C9ECD8F.3A598286.F12515B4.IP) (Quit: Leaving.)
[16:48:46] *** Joins: Kruppe (user@moz-4DDA8AB8.uwaterloo.ca)
[16:50:21] *** cade_away is now known as cade
[16:50:47] *** Joins: therantingnorwegian (Mibbit@moz-D5513CBA.static.snlo.ca.charter.com)
[16:51:53] *** Quits: bent (chatzilla@moz-BE33DA21.fw1.sfo1.mozilla.net) (Quit: ChatZilla 0.9.90.1-rdmsoft [XULRunner 22.0/20130619132145])
[16:52:18] *** Joins: mschifer (Adium@moz-42254FB1.hfc.comcastbusiness.net)
[16:53:44] <kimundi> Hm, there could be a `fn to_raw_ptr(&self) -> *T` implemented on `Option<&T>`
[16:54:02] *** Joins: hjr3 (hradtke@374E545A.3A8E9B0C.F9D9C60E.IP)
[16:54:43] *** Quits: azita (Azita@87C1F78E.1DE10CA8.D8E68FF6.IP) (Quit: azita)
[16:55:02] *** Joins: eholk (eholk@moz-A00ECF4B.uconnect.utah.edu)
[16:55:25] *** Quits: therantingnorwegian (Mibbit@moz-D5513CBA.static.snlo.ca.charter.com) (Ping timeout)
[16:56:42] *** Joins: tjc (tjc@moz-BBE3ABD.mv.mozilla.com)
[16:56:42] *** ChanServ sets mode: +o tjc
[16:56:47] *** Quits: eatkinson (eatkinson@moz-BBE3ABD.mv.mozilla.com) (Quit: eatkinson)
[16:56:53] <strcat> nmatsakis: pcwalton: https://github.com/mozilla/rust/issues/6515 here's that index issue btw
[16:57:18] <strcat> C++ is really weird when it comes to this since map[5] will insert 5 as a key with a default-initialized value ;p
[16:58:19] *** Joins: vk (chatzilla@3E9D68F2.B1163E0C.2A6693DD.IP)
[16:58:36] *** Quits: eschweic (Adium@moz-BBE3ABD.mv.mozilla.com) (Ping timeout)
[16:59:45] *** Quits: mhordecki (mhordecki@moz-BE33DA21.fw1.sfo1.mozilla.net) (Ping timeout)
[16:59:53] *** Quits: infynyxx (infynyxx@moz-E95B370B.nyc.res.rr.com) (Client exited)
[17:00:30] *** Quits: mihneadb (mihneadb@moz-BE33DA21.fw1.sfo1.mozilla.net) (Ping timeout)
[17:01:14] *** Joins: erickt (erickt@8C9ECD8F.3A598286.F12515B4.IP)
[17:01:38] *** Quits: Sergio965 (sergiobz@moz-92077B8C.dyn.mit.edu) (Quit: My MacBook Pro has gone to sleep. ZZZzzzâ€¦)
[17:01:47] *** Joins: huseby (huseby@moz-4E8C421A.husebyhome.com)
[17:02:01] *** Joins: eschweic (Adium@moz-BBE3ABD.mv.mozilla.com)
[17:02:31] *** Joins: spider-mario (spidermari@moz-81131DB6.fbx.proxad.net)
[17:02:46] *** Quits: pnkfelix (pnkfelix@87C1F78E.1DE10CA8.D8E68FF6.IP) (Quit: Leaving.)
[17:03:06] *** Joins: eatkinson (eatkinson@moz-BBE3ABD.mv.mozilla.com)
[17:04:11] *** Quits: spider-mario (spidermari@moz-81131DB6.fbx.proxad.net) (Ping timeout)
[17:04:35] *** Joins: spider-mario (spidermari@moz-81131DB6.fbx.proxad.net)
[17:07:19] *** Joins: pnkfelix (pnkfelix@87C1F78E.1DE10CA8.D8E68FF6.IP)
[17:07:23] *** Quits: pnkfelix (pnkfelix@87C1F78E.1DE10CA8.D8E68FF6.IP) (Input/output error)
[17:08:04] *** Joins: eschweic1 (Adium@moz-BBE3ABD.mv.mozilla.com)
[17:08:26] *** Quits: eschweic (Adium@moz-BBE3ABD.mv.mozilla.com) (Connection reset by peer)
[17:08:37] *** Joins: sk (sk@61A494B3.BA40E8A.AAC02D62.IP)
[17:08:40] *** Joins: Sergio965 (sergiobz@moz-92077B8C.dyn.mit.edu)
[17:08:57] *** Joins: henrikhodne (henrikhodn@moz-87E975F1.dsl.static.sonic.net)
[17:10:06] *** Joins: Vert (quassel@8A83479C.391ACC8C.CAF63861.IP)
[17:10:16] *** Joins: azakai (alon@moz-BBE3ABD.mv.mozilla.com)
[17:11:24] *** Quits: erickt (erickt@8C9ECD8F.3A598286.F12515B4.IP) (Quit: Leaving.)
[17:11:49] *** Quits: jaen (jaen@moz-E0979827.copit.pl) (Quit: WeeChat 0.4.1)
[17:12:43] *** Joins: echristo (echristo@DCF57675.D6CCE4AE.77834EAA.IP)
[17:16:19] *** Joins: brianm (brianm@D2D642B9.79695EE7.489C5759.IP)
[17:19:51] *** Joins: thomaslee (thomaslee@moz-6C3931E3.static.twtelecom.net)
[17:20:41] *** Joins: devinus (devinus@moz-B4AF84BC.ptr.us.xo.net)
[17:21:57] *** Joins: int3_ (int3_@moz-ABE52D50.hsd1.ca.comcast.net)
[17:22:54] <sully> ugh, failing to get on wireless in the SF office, tethering from my phone
[17:23:22] *** Joins: lkuper (lkuper@5188CCE.A402E718.C082B7DC.IP)
[17:24:09] *** Joins: jaen (jaen@moz-E0979827.copit.pl)
[17:25:09] <toddaaro> anyone know how to import spawn?
[17:25:18] <toddaaro> I've been trying to figure it out for 20 minutes and can't
[17:25:22] <jedestep> use std::task::spawn ?
[17:25:23] *** Quits: jj2baile (jon@moz-DCEF6040.csclub.uwaterloo.ca) (Ping timeout)
[17:25:25] *** Quits: ssalbiz (ssalbiz@moz-DCEF6040.csclub.uwaterloo.ca) (Ping timeout)
[17:25:27] <toddaaro> jedestep: fails
[17:25:31] *** Quits: Luqman (laden@moz-DCEF6040.csclub.uwaterloo.ca) (Ping timeout)
[17:25:37] <toddaaro> I'm inside the libstd/rt/ directory
[17:25:47] <jedestep> oooh
[17:25:50] <toddaaro> the run-pass testcase doesn't actually import anything, it just does do spawn
[17:25:52] <toddaaro> but that also fails
[17:25:58] <jedestep> super::task::spawn?
[17:26:15] <strcat> spawn is in prelude
[17:26:21] <toddaaro> how do I import the prelude
[17:26:24] <toddaaro> it isn't in the runtime
[17:26:30] <Florob> Are there any docs on debugging rustc errors, and/or writing useful bug reports about them?
[17:26:56] *** Joins: Luqman (laden@moz-DCEF6040.csclub.uwaterloo.ca)
[17:27:02] <toddaaro> I hadn't thought of super, I'll try that now
[17:27:20] <toddaaro> it is ~3-5m per attempt which is stunningly miserable
[17:27:21] <cmr> Florob: basically run with `RUST_LOG=::rt::backtrace,rustc=4` in your environment and include that log
[17:27:53] <brson> toddaaro: if you rebase onto master then you can use NO_REBUILD=1 to avoid rebootstrapping the compiler
[17:28:15] <toddaaro> brson: I'm already doing that, it still takes forever
[17:28:17] <brson> toddaaro: there are name resolution problems around * that can cause resolution to lose its mind. maybe see if there are any *'s laying around
[17:28:17] <toddaaro> I have no clue why
[17:28:20] *** Joins: ghrust (ghrust@C8693FCB.6A2AE50.F3114085.IP)
[17:28:20] <ghrust> 01[13rust01] 15bors 04force-pushed 06auto from 149aee8e4 to 14576f395: 02http://git.io/N3iJvQ
[17:28:20] *** Parts: ghrust (ghrust@C8693FCB.6A2AE50.F3114085.IP) ()
[17:28:21] *** Joins: ghrust (ghrust@5FEF1C87.6A2AE50.F3114085.IP)
[17:28:21] <ghrust> 01[13rust01] 15bors pushed 2 new commits to 06auto: 02http://git.io/IEeKsQ
[17:28:22] <ghrust> 13rust/06auto 14f7ebab4 15Jordi Boggiano: Do not enforce two newlines after the options
[17:28:22] <ghrust> 13rust/06auto 140068bd7 15bors: auto merge of #8131 : Seldaek/rust/getopt_usage_newline, r=brson...
[17:28:22] *** Parts: ghrust (ghrust@5FEF1C87.6A2AE50.F3114085.IP) ()
[17:28:29] <toddaaro> ok, super::task::spawn did the trick
[17:28:35] <jedestep> :D
[17:28:41] <brson> toddaaro: CFG_DISABLE_OPTIMIZE=1 will help too
[17:28:46] <toddaaro> jedestep: thanks
[17:28:51] *** Joins: Uther (Instantbir@moz-1B244B05.hfc.dyn.abo.bbox.fr)
[17:28:58] <jedestep> toddaaro: np
[17:29:21] *** Houm_ is now known as Houm
[17:30:01] *** Joins: james4k (james@moz-E7990244.consolidated.net)
[17:31:50] *** Quits: CarpNet (ac@moz-FD24B77.sohonet.co.uk) (Quit: Leaving)
[17:32:41] *** Joins: ssalbiz (ssalbiz@moz-DCEF6040.csclub.uwaterloo.ca)
[17:34:48] *** Joins: tchoma (tchoma@moz-CAF7E439.mycingular.net)
[17:34:58] *** Joins: chii (Mibbit@BBE7C46A.B4F11D08.8612FA94.IP)
[17:35:10] <Florob> cmr, preferably along with the source code I presume?
[17:35:23] <cmr> Florob: ah, yes, of course.
[17:35:35] *** Quits: huseby (huseby@moz-4E8C421A.husebyhome.com) (Quit: Leaving)
[17:35:59] <graydon> toddaaro: when you're in a tight fixit-loop it is usually more practical to run once with VERBOSE=1 make and then copy/paste the _last_ command in the sequence
[17:36:02] <graydon> and just reissue that one
[17:36:08] *** Joins: mihneadb (mihneadb@moz-4700570F.tmodns.net)
[17:36:19] <graydon> due to bootstrapping sequence we do not always get minimal dependencies worked out
[17:36:26] <cmr> I am not crazy! Mecha-Graydon does it too!
[17:36:58] <engla> rusti: std::str::TAG_CONT_U8
[17:36:59] -rusti- 128
[17:37:12] <engla> ^ libstd has lots of unintentionally public static variables :)
[17:37:53] *** Quits: jaen (jaen@moz-E0979827.copit.pl) (Quit: WeeChat 0.4.1)
[17:38:19] *** Joins: alisdair (textual@1697D94C.7742FB18.FBC8476D.IP)
[17:38:46] <toddaaro> graydon: really? ok, so that chops out all the early make steps?
[17:39:16] *** Parts: ssalbiz (ssalbiz@moz-DCEF6040.csclub.uwaterloo.ca) ()
[17:40:40] <graydon> toddaaro: well, suppose you're trying to see if minor changes to something in libstd build and work. it's _possible_ those would influence libextra and rustc, and rustc would build different code, and so strictly speaking the dependency edge needs to be there
[17:40:54] <graydon> toddaaro: but if you just want to know "the thing that stopped compilation last time -- did I fix it?"
[17:41:02] <graydon> toddaaro: then you can just reissue that last command
[17:41:11] <toddaaro> graydon: ok, I'll keep that in mind, thanks
[17:41:44] <graydon> toddaaro: you're not claiming the dependencies-of-your-work are properly satisfied. you're just running a shell command that happens to be able to help you debug your code faster than the most-correct fashion.
[17:41:54] <toddaaro> graydon: makes sense
[17:41:59] <strcat> I think the inttoptr thing could be why it can't constant-fold operations on vectors
[17:42:01] <graydon> toddaaro: picture it like running a 3rd party linter or requesting clairvoyance
[17:42:06] <strcat> silly zero-size types though >.<
[17:45:12] <toddaaro> brson: what exactly is the goal with run_in_main_thread? to bypass all the old runtime code? there was a dependency on running inside a bare_thread due to the setup performed by task::spawn_sched(task::SingleThreaded), so I guess I'm working on debugging what exactly that is now
[17:45:38] *** Quits: davbo (dave@moz-3FFA637C.oucs.ox.ac.uk) (Client exited)
[17:45:41] *** Joins: mhordecki (mhordecki@moz-902F0004.tmodns.net)
[17:45:53] *** Joins: erickt (erickt@8C9ECD8F.3A598286.F12515B4.IP)
[17:45:58] *** Quits: lucian (lucian@6B2B4644.4304AE1E.CE5E78F6.IP) (Ping timeout)
[17:46:21] *** Joins: dwhyte (dwhyte@1922756A.EDC594B0.7BF4A4B0.IP)
[17:48:32] <strcat> graydon: if I build stage3, I should be able to symlink the compiler libraries to the matching target ones, right?
[17:49:20] <brson> toddaaro: run_on_main_thread puts a scheduler on the OS's main thread (normally we don't do anything on the main thread) and pins the main taks to it. This is for things like gui's that need to run code specifically on the main thread
[17:49:28] <olsonjeffery> brson: so i ended up creating rtaio.rs, uvaio.rs, etc .. im probably going to draw the line, in the duplication, at IoFactory.. and the TcpWatcher can be reused in aio
[17:49:41] <toddaaro> brson: so we should skip run_in_bare_thread in here?
[17:49:49] <brson> toddaaro: yes
[17:49:56] <graydon> strcat: not sure what you're asking, but "probably"? :)
[17:49:59] <olsonjeffery> ill add tcp_connect_async, etc methods on IoFactory... and from there on it's all in uvaio, rtaio, etc
[17:50:06] <brson> toddaaro: we should not be using run_in_bare_thread at all in `run`
[17:50:16] <brson> toddaaro: run_in_bare_thread has to be called from within a task
[17:50:24] <brson> toddaaro: it should be using the Thread type directly
[17:50:40] <brson> olsonjeffery: that sounds reasonable
[17:51:17] <toddaaro> brson: ok, sounds good. One of the threads in my version of run_in_main_thread is failing in "call_on_rust_stack" in the start wrapper, does this sound familiar?
[17:51:19] <bblum> brson: https://github.com/mozilla/rust/issues/8132 by the way, i wrote this up
[17:52:07] <toddaaro> brson: I'm concerned that this might be caused by the scheduler running in a task that isn't using a rust stack
[17:52:56] <strcat> graydon: what's the actual target for building stage3? :s
[17:53:00] *** Quits: RMF (RMF@76B3729C.4FA74685.8D19547B.IP) (Quit: Textual IRC Client: www.textualapp.com)
[17:53:07] * strcat can never figure this out
[17:53:30] <strcat> you know what I don't need to do that
[17:53:37] <strcat> it works fine with stage1/stage2
[17:54:13] <cde> toddaaro: can't we have a process with only rust stacks?
[17:54:24] *** Joins: brendan (brendaneic@moz-BBE3ABD.mv.mozilla.com)
[17:54:59] <toddaaro> cde: the goal is actually to not use the rust stacks in these tasks
[17:55:42] *** Parts: jc-denton (nils@moz-C5E8B5EA.ethz.ch) ()
[17:55:43] *** Joins: jaen (jaen@moz-C284B1D3.neoplus.adsl.tpnet.pl)
[17:55:46] *** Quits: jaen (jaen@moz-C284B1D3.neoplus.adsl.tpnet.pl) (Quit: jaen)
[17:56:08] <cde> oh
[17:56:59] *** Joins: infynyxx (infynyxx@DB780A29.749BA1D.DCC373F0.IP)
[17:58:34] <brson> toddaaro: call_on_rust_stack usually only fails if it thinks it's running in an oldsched task but is not
[17:58:45] *** Quits: Houm (Houm@moz-25669AA8.fbx.proxad.net) (Input/output error)
[17:59:54] <brson> toddaaro: it could be possible that the code for retrieving the task pointer is seeing junk in the segment register, but i *think* it should always be initialized to 0 by the os
[18:00:19] *** Quits: brendan (brendaneic@moz-BBE3ABD.mv.mozilla.com) (Quit: brendan)
[18:00:26] *** Joins: Houm (Houm@moz-25669AA8.fbx.proxad.net)
[18:00:50] <brson> sorry, junk in the TCB where our stack pointer lives
[18:02:19] <strcat> graydon: anyone using my nightly build gets to be a guinea pig ;p, https://github.com/thestinger/packages/commit/11a02dec35699970f23ce80d9c4a6085d0b08dda
[18:02:28] <strcat> I'd be happy if they were nearly 1/2 the size...
[18:02:39] <strcat> although xz probably removes a lot of the duplication
[18:03:40] *** Quits: james4k (james@moz-E7990244.consolidated.net) (Ping timeout)
[18:05:16] <strcat> now that I have over 3 months of them, and they're each ~26MiB...
[18:06:15] <bblum> brson: do you know why the test suite run under valgrind has a zillion 'conditional jump or move depends on uninitialized values'?
[18:06:51] <strcat> bblum: all rust code does, it's because valgrind warnings are imprecise
[18:07:02] <strcat> LLVM is intentionally generating undef reads
[18:07:06] <bblum> strcat: uh... ???
[18:07:26] <strcat> bblum: we have a suppression file for lots of them
[18:07:27] *** Joins: james4k (james@moz-E7990244.consolidated.net)
[18:07:32] <toddaaro> brson: how would I check that? seems pretty clear that the assert failure is the one in rust_task::cal_on_rust_stack when the first context swap occurs in the main thread
[18:07:38] <strcat> that's why you don't see them with VALGRIND_COMPILE
[18:07:39] <bblum> strcat: oh, llvm is generating it when it knows it will be 0?
[18:07:52] <sully> hm, I think that the STAGE$(1)_T_$(2)_H_$(3) variable in the makefiels should be named RUSTC_STAGE... or something
[18:08:05] <strcat> bblum: no, because it knows *if* it is uninitialized, there's something else that will always be 0 or 1 or some other value
[18:08:08] <strcat> bblum: basically it sees
[18:08:10] <strcat> a && b
[18:08:11] *** Quits: km (quassel@FDBAF0A0.DBF71E41.29C67456.IP) (Ping timeout)
[18:08:37] <strcat> and it thinks, "hey, `a` is always 0 if `b` is uninitialized"
[18:08:42] <strcat> and decides to do it as b && a
[18:08:46] *** Quits: erickt (erickt@8C9ECD8F.3A598286.F12515B4.IP) (Quit: Leaving.)
[18:08:48] <strcat> even though the 'b' part can be undef
[18:08:59] *** Quits: mhordecki (mhordecki@moz-902F0004.tmodns.net) (Quit: mhordecki)
[18:09:05] <bblum> oh, i see, hm
[18:09:18] <bblum> and that is faster in some cases but not all?
[18:09:37] <strcat> bblum: well it's the instruction reordering stuff, so it's doing it based on modelling of a CPU's branch prediction, etc.
[18:09:44] <bblum> i see, ok
[18:09:52] *** Joins: brendan (brendaneic@moz-BBE3ABD.mv.mozilla.com)
[18:09:58] <strcat> like there might be another read of b before that, so it knows b will be in a register
[18:10:22] *** Joins: km (quassel@FDBAF0A0.DBF71E41.29C67456.IP)
[18:10:24] *** Joins: jj2baile (jon@moz-DCEF6040.csclub.uwaterloo.ca)
[18:10:39] <strcat> or maybe it knows b is zero more often than a
[18:10:57] <bblum> nod
[18:11:11] <brson> https://github.com/mozilla/rust/wiki/Meeting-weekly-2013-07-30
[18:11:17] <strcat> brson: loop-vectorize will do similar stuff ;]
[18:11:21] <strcat> err, bblum *
[18:11:36] *** Joins: erickt (erickt@8C9ECD8F.3A598286.F12515B4.IP)
[18:11:37] <strcat> valgrind replaces functions like memcmp/memcpy
[18:11:54] *** Quits: james4k (james@moz-E7990244.consolidated.net) (Quit: WeeChat 0.4.1)
[18:12:01] <strcat> LLVM will happily go into the undef part of an array while vectorizing
[18:12:12] <strcat> especially with reads, it just has to know *something* is there
[18:12:45] <sully> the makefiles are so unreadable
[18:12:47] <sully> it is super impressive
[18:13:03] *** Quits: Scriptor (historium@moz-E06F46F0.corp.bitshelter.com) (Quit: Scriptor)
[18:13:15] <brson> toddaaro: put a breakpoint in upcall_call_shim_on_rust_stack and see what branch it takes
[18:13:30] <brson> rust_try_get_current_task should return null if you're using the new runtime
[18:14:12] <cmr> sully: pnkfelix's work on them is particularly impressive
[18:14:27] <toddaaro> looking at code it looks like the function call not happening in the main_thread path is "record_sp_limit(0)"
[18:14:34] *** Quits: km (quassel@FDBAF0A0.DBF71E41.29C67456.IP) (Ping timeout)
[18:14:36] <toddaaro> brson: ^, do you know what that is for?
[18:15:03] *** Joins: maikklein (maik@moz-2FE64448.dip0.t-ipconnect.de)
[18:15:26] *** Joins: km (quassel@FDBAF0A0.DBF71E41.29C67456.IP)
[18:16:05] <maikklein> can I compile Rust for ARM on my current machine?
[18:16:21] <maikklein> because I really don't want to compile it on my pi :x
[18:16:28] <cmr> maikklein: yes
[18:16:52] <cmr>  ../configure --target-triples=arm-linux-androideabi,x86_64-unknown-linux-gnu --android-cross-path=/opt/ndk_standalone
[18:17:10] *** Quits: chii (Mibbit@BBE7C46A.B4F11D08.8612FA94.IP) (Ping timeout)
[18:17:34] <cmr> Then you can do rustc --target=arm-linux-androideabi --android-cross-path=/opt/ndk_standalone
[18:17:36] <strcat> I really despise fcron
[18:17:41] <cmr> except not the android stuff
[18:17:42] <brson> toddaaro: it writes null into the TCB slot that holds the pointer to the end of the stack. that is the value that i believe should be 0 by default but may not be. if it is not then we have additional problems
[18:17:51] <cde> maikklein: you might need additional flags to target armv6 arch
[18:17:54] * cmr copies that out of his shell history
[18:18:05] <cde> alternatively, the beaglebone black is armv8 (with vfpv3)
[18:18:12] <cde> *armv7 sorry
[18:18:15] *** Joins: dherman (dherman@moz-7B0110AD.mv.mozilla.com)
[18:18:15] *** ChanServ sets mode: +o dherman
[18:18:21] <maikklein> cde, yeah I have armv6
[18:18:28] <brson> toddaaro: all functiosn check that pointer in their prologue to know whether to attempt to grow the stack, so if it is garbage on entry to main, then bad things may happen
[18:19:05] <maikklein> I don't suppose there is an up to date repo for ARM on debian?
[18:19:38] <toddaaro> brson: ah, there is logic that sets it to 0 on all the runtime start code except the main_thread path that doesn't work
[18:19:42] <maikklein> okay maybe I do this later that day
[18:19:58] <cde> debian does not (and likely will not) support armv6 with floating point. you need the unofficial wheezy armv6 port
[18:20:07] <toddaaro> brson: so maybe that is the issue, works everywhere else because it is set to 0 explicitly
[18:20:42] <Sergio965> Why isn't the 'self lifetime implied for structs?
[18:20:49] <cde> maikklein: alternatively use the armv5 port (called armel). this will work
[18:20:51] <Sergio965> Isn't that a safe assumption for the compiler to make?
[18:21:23] <cmr> Sergio965: no, because 1. there will be multiple lifetimes allowed, 2. the requirement that th elifetime name is 'self is a bug
[18:21:39] *** Quits: erickt (erickt@8C9ECD8F.3A598286.F12515B4.IP) (Quit: Leaving.)
[18:21:49] <strcat> Sergio965: it used to, but it's in transition to not being crippled ;p
[18:22:08] <maikklein> cde, okay thanks
[18:22:09] <brson> toddaaro: maybe. but if it is not zero at the point that the runtime begins execution then it is probably only working at all by luck, since there's a chance that the very first function we call could decide to try to grow the stack erroneously
[18:22:23] <Luqman> maikklein: the non-android arm linux target is arm-unknown-linux-gnueabihf
[18:22:37] <brson> maybe something about the initial stack layout guarantees it to not grow the stack, but still spooky
[18:22:39] <Sergio965> cmr: On 1, it could simply be that pointers without an explicit lifetime are 'self and those with an explicit lifetime are that lifetime, and on 2, right, I understand this, just using it since it's the case now.
[18:22:46] <Sergio965> strcat: Ah, I see.
[18:22:47] <cde> maikklein: np bro
[18:23:03] <Sergio965> strcat: Is it planned to return?
[18:23:11] <strcat> Sergio965: don't think so
[18:23:30] <strcat> but you will be able to name it whatever
[18:23:46] <strcat> struct Foo<'a, 'b> { x: &'a int, y: &b int
[18:23:48] <brson> toddaaro: anyway, if you want to create a binding to set_sp_limit, put it in rust_builtin.cpp, export it in rustrt.def.in, call it rust_set_sp_limit, bind it to rust with #[rust_stack]
[18:23:50] <strcat> struct Foo<'a, 'b> { x: &'a int, y: &'b int }
[18:23:51] *** Joins: erickt (erickt@8C9ECD8F.3A598286.F12515B4.IP)
[18:23:56] <brson> maybe that will work around the problem
[18:23:58] <strcat> something like that anyway
[18:24:30] <Sergio965> strcat: Is there a reason why it won't return?
[18:25:23] <Sergio965> IE, instead of doing: struct Foo<'self, 'b> { x: &'self int, y: &'b int }, why not have the following be equivalent: struct Foo<'b> { x: &int, y: &'b int }?
[18:25:44] <cmr> Sergio965: why should structs be a special case of lifetime inference?
[18:25:49] *** Joins: xemical (xnxx@moz-5400206B.range109-150.btcentralplus.com)
[18:25:59] *** Parts: xemical (xnxx@moz-5400206B.range109-150.btcentralplus.com) ()
[18:26:20] <strcat> Sergio965: 'self would be entirely an arbitrary name there
[18:26:28] <Sergio965> strcat: Right, just an example.
[18:26:41] <Sergio965> It's not really a special case, is it? The compiler assigned unique lifetimes to all variables; why not assigned a unique name to the struct as a whole?
[18:26:47] <Sergio965> assignes*
[18:26:55] <kimundi> Sergio965: It is a deliberate decision to allways annotate lifetimes in types just like you have to annotatae type parameters
[18:26:56] <Sergio965> assigns*
[18:26:57] <Sergio965> Bah.
[18:27:26] *** Quits: graydon (graydon@moz-F14EE0DB.cable.teksavvy.com) (Ping timeout)
[18:27:49] <Sergio965> assign*
[18:27:53] <Sergio965> Wow, my words are off.
[18:28:14] <kimundi> It's there to make it more obvios how the system works, and have less surprises for the programmer
[18:28:49] <Sergio965> Under the same logic, the compiler would never assign lifetimes to anything, but it does. This seems like an extension of that idea.
[18:29:01] <cmr> It doesn't assign, it infers
[18:29:06] *** Joins: jmgrosen (jmgrosen@moz-848F6087.sb.sd.cox.net)
[18:29:15] *** Joins: chii (Mibbit@BBE7C46A.B4F11D08.8612FA94.IP)
[18:29:21] <Sergio965> It infers uniqueness, and by inferring, inadvertently assigns.
[18:29:42] <Sergio965> I could just as simple annotate every one of my borrowed pointers with a different lifetime.
[18:29:58] <kimundi> For example struct Foo(&A, &B) could either mean struct Foo<'a>(&'a A, &' a B) or struct Foo<'a, 'b>(&'a A, &' b B), by requiring to write it out thet confusion never happens
[18:30:51] <Sergio965> kimundi: I don't believe it's all all confusing to say, "By default, all borrowed pointers in a struct are assigned the same lifetime."
[18:30:57] <Sergio965> It's one sentence of explanation.
[18:31:05] <Sergio965> And it makes writing simple structures simple.
[18:31:07] *** Joins: RMF (RMF@76B3729C.4FA74685.8D19547B.IP)
[18:31:51] <Sergio965> it's at all*
[18:33:18] <kimundi> Sergio965: I think the thinking is simpy "lifetimes are a new concept for most new runt programmers, let's make it more obvios how they work for now"
[18:33:27] <strcat> runt ;p
[18:33:47] <kimundi> :D
[18:33:47] <cde> I like that name better. let's change everything
[18:33:50] <Sergio965> Being forced into a new topic isn't the way to go, in my opinion.
[18:34:23] <Sergio965> In order to write any structure with a borrowed pointer, the programmer has to learn everything about lifetimes even though they're doing the simple, common case.
[18:34:27] <cmr> Sergio965: I find your argument compelling
[18:34:50] <kimundi> Sergio965: You're not forced in the topic, if you're embedding references into a struct you're already using lifetimes
[18:34:53] *** Quits: chii (Mibbit@BBE7C46A.B4F11D08.8612FA94.IP) (Ping timeout)
[18:35:21] <kimundi> All automatic inference does is hiding thet fact behind your back with magic
[18:35:45] <Sergio965> kimundi: If you're using ANY borrowed pointer, you're using lifetimes. That doesn't mean the compiler can't help you out (which it already does) and do what you almost certainly want it to do. It's not all automatic reference. If you want to do something complicated, learn how to use lifetimes. If you want to do something simple, you can let the compiler help you out.
[18:35:58] <Sergio965> inference*
[18:37:11] <Sergio965> If the goal is to get more people to use Rust, I strongly believe being able to write something like: struct Axis { origin: &Point, max: int } is needed.
[18:37:34] <cde> sometimes, the majority is wrong
[18:37:45] <Sergio965> By introducing lifetimes, you not only introduce new syntax 'r, but a new concept.
[18:37:53] *** Quits: maikklein (maik@moz-2FE64448.dip0.t-ipconnect.de) (Ping timeout)
[18:38:05] <Sergio965> cde: But this doesn't appeal to the majority. This appeals to the common case. This appeals to efficiency.
[18:38:32] *** Quits: sankha93 (Instantbir@7061CD01.D6BD0D91.22D41759.IP) (Quit: Gone to save the world!)
[18:39:03] *** Quits: RMF (RMF@76B3729C.4FA74685.8D19547B.IP) (Quit: Textual IRC Client: www.textualapp.com)
[18:39:26] <strcat> so you have 'struct Foo { a: Bar, b: Baz }' and it contains a borrowed ptr somewhere
[18:39:33] <strcat> you get a lifetime error
[18:39:39] <kimundi> Anyway, it used to work the way Sergio965 is proposing, and it has been deliberatly changed to the explicit way it is now after quite a lot of discussin on the devs side
[18:39:50] <strcat> now you have the fun of manually tracing through type definitions since lifetimes aren't explicit parameters
[18:40:01] <strcat> atm lifetimes are always explicit in type definitions
[18:40:11] <Sergio965> strcat: What do you mean, a borrowed pointer somewhere?
[18:40:17] <Sergio965> kimundi: I'd love to read the discussion about this.
[18:40:18] <strcat> something in Bar or Baz
[18:40:20] <kimundi> There exists meeting notes thet explain the thought process behind it 
[18:40:36] <kimundi> Dunno when those where, though
[18:40:53] <strcat> you do need explicit lifetime parameters
[18:41:10] <strcat> since there needs to be something for the impl to associate them with
[18:41:25] <strcat> impl<'a, 'b> for &'a Foo<'b> { }
[18:41:55] <Sergio965> strcat: Yeah, but that's not the case I'm talking about
[18:42:03] <Sergio965> Now you have two different lifetimes.
[18:42:33] *** Joins: jbaldwin (Mibbit@EF784383.FC9BECD6.A8DE49A2.IP)
[18:42:58] <strcat> impl<'a> Foo<'a> { } still needs an explicit parameter
[18:43:00] *** Joins: RMF (RMF@76B3729C.4FA74685.8D19547B.IP)
[18:43:01] <strcat> for 1 lifetime
[18:43:03] <cmr> The point he's making is about parameterization
[18:43:11] <cmr> struct Foo { f: &int }
[18:43:17] <cmr> impl Foo { ... }
[18:43:19] <cmr> isn't allowed
[18:43:29] <cmr> you can't have anonymous lifetimes there
[18:43:35] <strcat> and you wouldn't have a way to refer to it
[18:43:36] <strcat> you need that
[18:44:29] <Sergio965> Why not? Once the compiler has identified Foo as have an ifferred lifetime for its borrowed pointers, why can't it also infer the parameterization of impl <'a> Foo<'a> ?
[18:44:39] <strcat> what do you mean infer it?
[18:44:41] <Sergio965> an inferred*
[18:44:51] <strcat> how are you going to refer to 'a?
[18:45:05] <strcat> fn foo(&self) -> &'a T
[18:45:09] <strcat> as a method in that impl
[18:45:20] <Sergio965> 'self, if need be.
[18:45:29] <strcat> that's a bug
[18:45:36] <Sergio965> But I'm thinking of a case where you don't need to refer to it.
[18:45:49] <Sergio965> If you're turning a borrowed pointer, you should learn how to use lifetimes.
[18:45:52] <Sergio965> returning*
[18:46:03] *** Quits: eatkinson (eatkinson@moz-BBE3ABD.mv.mozilla.com) (Quit: eatkinson)
[18:46:07] <strcat> if you're using structs with borrowed pointers in them, they act *very* differently than those without
[18:46:09] <Sergio965> If you're just using them in your implementation, you'll be fine.
[18:46:18] <strcat> the explicit parameters are a priceless way of making it much more clear
[18:46:24] <strcat> Sergio965: you won't
[18:46:31] <Sergio965> Why?
[18:46:31] <strcat> they act very differently than a struct without a lifetime param
[18:46:50] <strcat> their lifetime is tied to some external source
[18:46:59] <cmr> (they also aren't Send)
[18:47:04] <strcat> and it's not going to be clear where that source is
[18:47:14] <strcat> structs will likely be able to have lifetimes without borrowed pointers too
[18:47:17] <Sergio965> struct Foo { a: &int }; impl Foo { fn new() -> Foo { Foo { a: &3 } }.
[18:47:30] <strcat> you can't do that
[18:47:34] <Sergio965> Why not?
[18:47:49] <cmr> 3 doesn't live long enough
[18:47:54] <Sergio965> Right.
[18:47:59] <Sergio965> Well, bad example. :P
[18:48:07] <cmr> I'm unconvinced there's a good example!
[18:48:20] *** Joins: eatkinson (eatkinson@moz-BBE3ABD.mv.mozilla.com)
[18:48:21] <Sergio965> struct Foo { a: &int }; impl Foo { fn new(a: &int) -> Foo { Foo { a: a } }.
[18:48:44] *** Joins: huseby (huseby@moz-4E8C421A.husebyhome.com)
[18:48:52] <strcat> that won't work either
[18:48:56] <strcat> &int is ephemeral
[18:49:08] <strcat> you can't keep it beyond the call
[18:49:13] <toddaaro> how do you set a gdb breakpoint for a rust function?
[18:49:21] *** Quits: tchoma (tchoma@moz-CAF7E439.mycingular.net) (Connection reset by peer)
[18:49:27] <cmr> toddaaro: should be able to `break rust_function_name`
[18:49:35] <Sergio965> toddaaro: Compile with -Z debug-info.
[18:49:38] <toddaaro> cmr: doesn't seem to work
[18:49:47] <toddaaro> Sergio965: ah, I'll try that, thanks
[18:50:12] <toddaaro> what is the way to pass that into make?
[18:50:15] <Sergio965> strcat: How would use a lifetime fix that?
[18:50:28] <Sergio965> using*
[18:50:30] <Sergio965> Geez.
[18:50:34] <cmr> toddaaro: --enable-debug to configure
[18:50:42] <strcat> fn new<'r>(a: &'r int) -> Foo<'r>
[18:50:44] <cmr> erm, actually, that might just be --cfg debug
[18:50:47] <cmr> I don't remember
[18:50:59] <strcat> Sergio965: borrow checking inference is *only* local
[18:51:10] <strcat> it cannot infer globally, it wouldn't work cross-crate and would be impossible to understand or reason about
[18:51:13] <strcat> especially the errors
[18:51:15] *** Quits: Florob (Florob@moz-39532932.de) (Client exited)
[18:51:17] *** Joins: Florob (Florob@moz-39532932.de)
[18:51:25] <bstrie> uh oh, bors is running low on food
[18:51:36] <jbaldwin> hello, if I have say struct Grid; and then trait Printable; and I use impl Printable for Grid { fn print(); } why can't I use grid.print()? it has to be printable.print()?
[18:51:40] <bstrie> without prs to eat, he will die
[18:52:10] <cmr> jbaldwin: if it's a static method, it needs to be Printable::print(), yes
[18:52:10] <bstrie> jbaldwin: it has to be `fn print(self)` to make it a method
[18:52:16] <strcat> people have enough problems understanding the local rules
[18:52:18] <bstrie> otherwise it is a static method
[18:52:22] <cmr> (Or &self or &mut self or ~self or @self)
[18:52:30] <cmr> (is *self allowed?)
[18:52:33] <jedestep> (&self is generally the go-to)
[18:52:38] <Sergio965> How about ~mut self?
[18:52:40] <cmr> rusti: trait Foo { fn foo(*self); }
[18:52:41] <Sergio965> Is that a thing?
[18:52:42] -rusti- <anon>:5:28: 5:29 error: found `self` in ident position
[18:52:42] -rusti- <anon>:5          trait Foo { fn foo(*self); }
[18:52:42] -rusti-                                      ^
[18:52:42] -rusti- error: aborting due to previous error
[18:52:43] -rusti- application terminated with error code 101
[18:52:43] <bstrie> there's no ~mut
[18:52:45] <jbaldwin> yes it is print(&self) sorry, but I have a Grid object and the compiler tells me it can't find print
[18:52:48] <jedestep> ~mut is long gone
[18:52:56] <cmr> Sergio965: no, ~ has inherited immutability by container
[18:53:00] <Sergio965> Why's that? Inhereted?
[18:53:01] <Sergio965> Indeed.
[18:53:03] <cmr> jbaldwin: The trait needs to be in scope
[18:53:12] <Sergio965> @mut
[18:53:15] <Sergio965> Is that a thing?
[18:53:17] <cmr> yes
[18:53:29] <Sergio965> Does it freeze?
[18:53:35] <bstrie> Sergio965: no, don't listen to cmr, @mut is not a thing and anyone who tells you otherwise wishes you harm
[18:53:38] <cmr> Dynamically yes
[18:53:54] <Sergio965> strcat: Yeah, those are interesting arguments. I still think something can be done to ease working with simple structures.
[18:54:00] <cmr> You should almost never use @mut
[18:54:07] *** Quits: dherman (dherman@moz-7B0110AD.mv.mozilla.com) (Ping timeout)
[18:54:08] *** Joins: joebobjoe (joebobjoe@55F2E07A.7F841963.2213276E.IP)
[18:54:12] <strcat> Sergio965: imo it will just make it harder for people to understand
[18:54:18] <jbaldwin> I'm linking it from another mod / file, I would assume you mean something like -> use grid::Printable;
[18:54:18] <cmr> Less often than the almost never using @ :p
[18:54:20] <strcat> more inference, more implicit assumptions -> more opaque
[18:54:23] <cmr> jbaldwin: yup
[18:54:27] <strcat> you do have to learn it to use rust
[18:54:35] <jbaldwin> k let me try thanks
[18:54:45] <strcat> you can't actually get very far without understanding it
[18:54:58] <jedestep> there are times when @ is appropriate, but I really have not been in a situation where @mut was appropriate and I couldn't just use Cell instead
[18:54:58] *** Quits: noj (jon@moz-D51AE9DE.swym.se) (Quit: WeeChat 0.4.1)
[18:55:01] *** Joins: lucian (lucian@moz-22A14C6A.cable.virginmedia.com)
[18:55:11] *** Joins: dherman (dherman@moz-BBE3ABD.mv.mozilla.com)
[18:55:11] *** ChanServ sets mode: +o dherman
[18:55:22] <toddaaro> ok, CFG_ENABLE_DEBUG=1 didn't trigger a recompile of anything, so that means I have the flags?
[18:55:29] <toddaaro> but I can't figure out how to break on any rust functions still
[18:56:25] <jbaldwin> heh that did it, cool, I thought "mod grid;" was enough
[18:56:42] *** Quits: lucian (lucian@moz-22A14C6A.cable.virginmedia.com) (Ping timeout)
[18:57:08] *** Quits: int3_ (int3_@moz-ABE52D50.hsd1.ca.comcast.net) (Client exited)
[18:57:20] *** Quits: vosen (vosen@moz-266BA656.icpnet.pl) (Quit: Leaving)
[18:58:26] *** Joins: xazax (xazax@moz-D7592A2A.csoma.elte.hu)
[18:58:29] *** Quits: msingle (Thunderbir@moz-930E5D97.hr.hr.cox.net) (Ping timeout)
[18:58:53] <xazax> hi
[18:59:17] <xazax> it is not possible in the current master to declare multiple variables in a single let
[18:59:20] <xazax> ?
[18:59:33] *** Joins: msingle (Thunderbir@moz-930E5D97.hr.hr.cox.net)
[18:59:42] <bstrie> xazax: not via the old syntax
[18:59:54] <xazax> what is the new syntax?
[19:00:03] <bstrie> xazax: nowadays you can either just use multiple lets, or use tuples like `let (x, y, z) = (1,2,3);`
[19:00:04] <kimundi> xazax: The new unified way will be to just use a tuple pattern
[19:00:06] <cmr> let (a, b, c) = (1, 2.0, true);
[19:00:25] *** Quits: acrichto (acrichto@moz-B63D64BD.res.cmu.edu) (Ping timeout)
[19:00:30] *** Quits: webber46 (webber46@moz-98D2F3C5.cust.bredband2.com) (Quit: webber46)
[19:00:36] <brson> toddaaro: adding CFG_ENABLE_DEBUG won't on it's own trigger a recompile
[19:00:40] <xazax> tuples did not work for me either, was it because I wanted to use it for mutable variables?
[19:00:46] <cmr> xazax: yeah
[19:00:46] <brson> toddaaro: breaking on rust functions requires finding the mangled name
[19:00:59] <cmr> xazax: in-between the old syntax and the new for that, where we have *no* syntax for it
[19:01:13] *** Joins: acrichto (acrichto@moz-B63D64BD.res.cmu.edu)
[19:01:18] *** Joins: chii (Mibbit@BBE7C46A.B4F11D08.8612FA94.IP)
[19:01:25] <cmr> xazax: you have to do let (a, ...) = ...; let mut a = a;
[19:01:29] <kimundi> xazax: In the future 'let (a, mut b, c) = (1, 2, 3)' will work, but not yet
[19:01:45] <xazax> oh, I see
[19:01:48] <xazax> it makes sense
[19:01:53] <kimundi> (Will also work in, eg match, then )
[19:02:00] <engla> that's great
[19:03:54] *** Quits: brendan (brendaneic@moz-BBE3ABD.mv.mozilla.com) (Quit: brendan)
[19:04:02] <toddaaro> brson: ah, I'm just going to add that function call to record_sp_limit, seems much faster than gdb
[19:04:48] <engla> bstrie: feel free to feed bors this https://github.com/mozilla/rust/pull/8133 :)
[19:04:57] <toddaaro> brson: the c function wants a void pointer, how do I pass that in rust? c_void? with the type uint = c_void?
[19:05:04] *** Quits: mihneadb (mihneadb@moz-4700570F.tmodns.net) (Input/output error)
[19:05:22] <strcat> toddaaro: *c_void
[19:05:31] <strcat> you mean how do you cast something to that?
[19:05:40] <toddaaro> well, how do I interact with it at all
[19:05:53] <strcat> rusti: let x: *int = &5; let y = x as *c_void; y
[19:05:54] -rusti- <anon>:5:41: 5:47 error: use of undeclared type name `c_void`
[19:05:54] -rusti- <anon>:5          let x: *int = &5; let y = x as *c_void; y
[19:05:54] -rusti-                                                   ^~~~~~
[19:05:54] -rusti- error: aborting due to previous error
[19:05:54] -rusti- application terminated with error code 101
[19:06:01] <strcat> rusti: use std::libc::c_void; let x: *int = &5; let y = x as *c_void; y
[19:06:02] -rusti- 140720256718744
[19:06:03] *** Joins: mhordecki (mhordecki@moz-902F0004.tmodns.net)
[19:06:34] *** Joins: brendan (brendaneic@moz-BBE3ABD.mv.mozilla.com)
[19:06:39] <toddaaro> strcat: I think that does the trick, thanks
[19:06:44] * brson lunch
[19:07:26] *** Joins: int3_ (int3_@moz-ABE52D50.hsd1.ca.comcast.net)
[19:09:08] *** Quits: int3_ (int3_@moz-ABE52D50.hsd1.ca.comcast.net) (Ping timeout)
[19:09:17] <engla> cmr: thanks
[19:09:18] *** Quits: Yurume (yurume@AC58A8CE.8A059B47.E313B915.IP) (Ping timeout)
[19:09:27] *** Joins: int3_ (int3_@moz-ABE52D50.hsd1.ca.comcast.net)
[19:10:34] *** Quits: infynyxx (infynyxx@DB780A29.749BA1D.DCC373F0.IP) (Client exited)
[19:11:03] *** Quits: int3_ (int3_@moz-ABE52D50.hsd1.ca.comcast.net) (Client exited)
[19:11:46] *** Quits: ecr (Thunderbir@moz-F724119C.uoregon.edu) (Quit: ecr)
[19:12:35] *** Quits: FrozenCow (FrozenCow@moz-B2DF4929.chello.nl) (Quit: Leaving)
[19:13:06] *** Quits: lkuper (lkuper@5188CCE.A402E718.C082B7DC.IP) (Quit: lkuper)
[19:13:24] *** Joins: ghrust (ghrust@C8693FCB.6A2AE50.F3114085.IP)
[19:13:24] <ghrust> 01[13rust01] 15bors merged 06auto into 06master: 02http://git.io/IEeKsQ
[19:13:24] *** Parts: ghrust (ghrust@C8693FCB.6A2AE50.F3114085.IP) ()
[19:13:32] *** Quits: pyrac (pyrac@moz-F28B7CAD.w90-55.abo.wanadoo.fr) (Ping timeout)
[19:13:42] *** Quits: alisdair (textual@1697D94C.7742FB18.FBC8476D.IP) (Quit: My MacBook Pro has gone to sleep. ZZZzzzâ€¦)
[19:13:46] <engla> whew, that was close
[19:14:16] *** Joins: Egbert9e9 (Egbert9e9@moz-366B5D68.inter.net.il)
[19:15:13] *** Quits: erickt (erickt@8C9ECD8F.3A598286.F12515B4.IP) (Quit: Leaving.)
[19:16:23] *** Joins: ghrust (ghrust@F6EE6DE3.6A2AE50.F3114085.IP)
[19:16:23] <ghrust> 01[13rust01] 15bors pushed 0 new commits to 06auto: 02http://git.io/fVVUAg
[19:16:23] *** Parts: ghrust (ghrust@F6EE6DE3.6A2AE50.F3114085.IP) ()
[19:16:24] *** Joins: ghrust (ghrust@CFE85B59.6A2AE50.F3114085.IP)
[19:16:24] <ghrust> 01[13rust01] 15bors pushed 5 new commits to 06auto: 02http://git.io/KnDU7w
[19:16:24] <ghrust> 13rust/06auto 146dd1859 15blake2-ppc: std: Disallow bytes 0xC0, 0xC1 (192, 193) in utf-8...
[19:16:24] <ghrust> 13rust/06auto 14b4ff955 15blake2-ppc: std: Deny overlong encodings in UTF-8...
[19:16:25] <ghrust> 13rust/06auto 14aa89325 15blake2-ppc: std: Add from_bytes test for utf-8 using codepoints above 0xffff
[19:16:27] *** Parts: ghrust (ghrust@CFE85B59.6A2AE50.F3114085.IP) ()
[19:20:07] *** Joins: judder (maradukewa@3226AE5F.7C541960.78E362FE.IP)
[19:20:52] *** Quits: vk (chatzilla@3E9D68F2.B1163E0C.2A6693DD.IP) (Ping timeout)
[19:21:35] *** Joins: pyrac (pyrac@moz-F28B7CAD.w90-55.abo.wanadoo.fr)
[19:21:49] *** Quits: sebcrozet (sebcrozet@moz-A855F6C0.w82-127.abo.wanadoo.fr) (Ping timeout)
[19:22:37] *** Quits: xazax (xazax@moz-D7592A2A.csoma.elte.hu) (Quit: Leaving)
[19:23:08] *** Joins: tikue (tkuehn@moz-BBE3ABD.mv.mozilla.com)
[19:24:35] *** Joins: james4k (james@moz-E7990244.consolidated.net)
[19:24:49] *** Quits: tjc (tjc@moz-BBE3ABD.mv.mozilla.com) (Quit: zzzzzzzzzz)
[19:24:51] <toddaaro> brson: I'm pretty sure I know what the problem is in detail now, when you get back from lunch we can discuss options
[19:26:20] <toddaaro> brson: it appears that rust_try_get_current_task is seeing that the sp_limit starts at 0, and then due to FIXME #1226 it checks to see if there is a current task by checkint TLS with try_get_task_tls. This then sees that, yes, tls has been initialized and returns a task, because the scheduler task may be using the c stack but it is using TLS as a normal task.
[19:26:43] <toddaaro> brson: bblum suggested fiddling with some low order bits on the tls pointer as a more robust check, but you probably have thoughts on this
[19:26:49] *** Joins: vk (chatzilla@3E9D68F2.B1163E0C.2A6693DD.IP)
[19:28:24] *** Quits: acrichto (acrichto@moz-B63D64BD.res.cmu.edu) (Ping timeout)
[19:28:46] <bblum> just one low order bit is needed :P
[19:28:55] <bblum> until we get 3 or 4 different types of tasks in TLS
[19:29:06] *** Quits: nano (nano@moz-972880B.superkabel.de) (Connection reset by peer)
[19:29:07] <bblum> when we get 17 different types of tasks in TLS, then my plan will not work anymore
[19:29:30] *** Quits: Egbert9e9 (Egbert9e9@moz-366B5D68.inter.net.il) (Quit: Egbert9e9)
[19:29:32] *** Quits: busylizzy (lisa@85228838.12D0DC84.211374C4.IP) (Quit: No Ping reply in 180 seconds.)
[19:29:33] *** Quits: eatkinson (eatkinson@moz-BBE3ABD.mv.mozilla.com) (Quit: eatkinson)
[19:29:38] *** Joins: infynyxx (infynyxx@DB780A29.749BA1D.DCC373F0.IP)
[19:29:47] *** Joins: busylizzy (lisa@85228838.12D0DC84.211374C4.IP)
[19:30:01] *** Joins: snadon (chatzilla@moz-3BC727E8.mc.videotron.ca)
[19:30:21] <toddaaro> I think we already have 3-4
[19:30:30] *** Joins: BitPuffin (quassel@moz-49828767.cust.tele2.se)
[19:30:51] *** Joins: bheylin (brianheyli@moz-8255E94E.adsl.online.nl)
[19:33:36] *** Quits: eschweic1 (Adium@moz-BBE3ABD.mv.mozilla.com) (Quit: Leaving.)
[19:34:21] *** Joins: acrichto (acrichto@moz-B63D64BD.res.cmu.edu)
[19:39:05] *** Quits: james4k (james@moz-E7990244.consolidated.net) (Ping timeout)
[19:40:42] *** Quits: pyrac (pyrac@moz-F28B7CAD.w90-55.abo.wanadoo.fr) (Quit: pyrac)
[19:41:00] *** Joins: james4k (james@moz-E7990244.consolidated.net)
[19:41:21] *** Joins: int3_ (int3_@moz-ABE52D50.hsd1.ca.comcast.net)
[19:42:17] <sam113101> rusti: for [1,2,3].each |&num| { println(num.to_str()) }
[19:42:18] -rusti- more than 5 lines of output, pastebinned: http://sprunge.us/INIR
[19:42:37] *** Joins: tchoma (tchoma@moz-CAF7E439.mycingular.net)
[19:42:45] <sam113101> what's the new way of doing this?
[19:42:51] *** Quits: infynyxx (infynyxx@DB780A29.749BA1D.DCC373F0.IP) (Client exited)
[19:43:02] <Sergio965> .iter().advance
[19:43:27] <Sergio965> for [1,2,3].advance |&num| { }
[19:43:44] <Sergio965> rusti: for [1,2,3].advance |&num| { *num }
[19:43:45] -rusti- <anon>:5:9: 5:44 error: failed to find an implementation of trait std::iterator::Iterator<<V5>> for [int, .. 3]
[19:43:45] -rusti- <anon>:5          for [1,2,3].advance |&num| { *num }
[19:43:45] -rusti-                   ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
[19:43:45] -rusti- application terminated with error code 101
[19:43:50] <Sergio965> Ah.
[19:43:54] <Sergio965> Whatever.
[19:44:05] <Sergio965> rusti: for [1,2,3].iter().advance |&num| { *num }
[19:44:06] -rusti- more than 5 lines of output, pastebinned: http://sprunge.us/dVQT
[19:44:06] <tikue> rusti: for [1, 2, 3].iter().advance |&num| { printfln!("%d", num); }
[19:44:07] -rusti- more than 5 lines of output, pastebinned: http://sprunge.us/ETVL
[19:44:32] <tikue> rusti: let v = [1, 2, 3]; for v.iter().advance |&num| { printfln!("%d", num); }
[19:44:33] -rusti- 1
[19:44:33] -rusti- 2
[19:44:33] -rusti- 3
[19:44:33] -rusti- ()
[19:44:43] <Sergio965> There you go. :P
[19:44:54] <Sergio965> Anyways, .iter().advance.
[19:45:21] *** Joins: erickt (erickt@8C9ECD8F.3A598286.F12515B4.IP)
[19:45:37] <sam113101> why do you need to assign the vector to a variable first?
[19:45:54] *** Joins: infynyxx (infynyxx@DB780A29.749BA1D.DCC373F0.IP)
[19:46:28] *** Quits: Sergio965 (sergiobz@moz-92077B8C.dyn.mit.edu) (Quit: My MacBook Pro has gone to sleep. ZZZzzzâ€¦)
[19:46:34] *** Parts: judder (maradukewa@3226AE5F.7C541960.78E362FE.IP) ()
[19:46:38] <sfackler> it's an issue with rvalue lifetimes
[19:47:01] <sfackler> https://github.com/mozilla/rust/issues/3511
[19:47:19] *** Quits: int3_ (int3_@moz-ABE52D50.hsd1.ca.comcast.net) (Ping timeout)
[19:49:19] *** Quits: acrichto (acrichto@moz-B63D64BD.res.cmu.edu) (Ping timeout)
[19:49:32] *** Joins: eschweic (Adium@moz-BBE3ABD.mv.mozilla.com)
[19:49:48] *** Joins: acrichto (acrichto@moz-B63D64BD.res.cmu.edu)
[19:50:30] *** Joins: jaen (jaen@moz-C284B1D3.neoplus.adsl.tpnet.pl)
[19:51:00] *** Quits: eschweic (Adium@moz-BBE3ABD.mv.mozilla.com) (Connection reset by peer)
[19:51:11] *** Quits: erickt (erickt@8C9ECD8F.3A598286.F12515B4.IP) (Ping timeout)
[19:51:29] *** Quits: james4k (james@moz-E7990244.consolidated.net) (Ping timeout)
[19:53:07] *** Quits: jedestep (jedestep@34641662.FB4DE631.66C78B76.IP) (Ping timeout)
[19:53:11] *** Joins: eatkinson (eatkinson@moz-BBE3ABD.mv.mozilla.com)
[19:53:22] *** Joins: eschweic (Adium@moz-BBE3ABD.mv.mozilla.com)
[19:53:42] <pauls> jdm: pong
[19:53:55] <jdm> pauls: I think the crisis has passed
[19:54:07] <pauls> jdm: awww ) :
[19:54:14] <strcat> poor crisis, we hardly even knew him
[19:54:17] <jdm> I was looking for input about lexical scoping in macros, but I think mw has a strategy around our problem
[19:54:17] *** Quits: jaen (jaen@moz-C284B1D3.neoplus.adsl.tpnet.pl) (Quit: WeeChat 0.4.1)
[19:54:43] <jdm> macros broke the invariants we thought we could use
[19:55:03] *** Joins: jaen (jaen@moz-C284B1D3.neoplus.adsl.tpnet.pl)
[19:55:22] <pauls> jdm: what invariants?
[19:55:47] *** Joins: robertknight (robertknig@moz-AB0E96D7.range86-162.btcentralplus.com)
[19:56:18] <jdm> pauls: see discussion at https://github.com/michaelwoerister/rust/commit/7c5ecdc985443869582cfb5d2a12c92f844c375a#commitcomment-3744853
[19:56:23] <pauls> Macros should generally only do reasonable things with lexical scope. However, you often can't tell what those reasonable things are going to be without expanding the macros.
[19:57:45] *** Joins: erickt (erickt@8C9ECD8F.3A598286.F12515B4.IP)
[19:59:41] *** Joins: Sergio965 (sergiobz@moz-BB21156B.dynamic.csail.mit.edu)
[19:59:55] <pauls> Ooh, I see.
[20:00:19] <pauls> I'd say that this is a case of macros messing up span information. They totally can do that.
[20:00:40] <pauls> The solution seems reasonable, as far as I understand the issue at hand, which is not very.
[20:01:07] *** Joins: kuuranne (kuuranne@moz-C4357EA7.kapsi.fi)
[20:01:07] <pauls> I think I got that email, but I've got, like, three days of back email to go through still
[20:01:24] <erickt> strcat: ping
[20:02:34] *** Quits: dherman (dherman@moz-BBE3ABD.mv.mozilla.com) (Quit: dherman)
[20:03:11] *** Quits: brendan (brendaneic@moz-BBE3ABD.mv.mozilla.com) (Quit: brendan)
[20:04:19] *** Joins: jedestep (jedestep@34641662.FB4DE631.66C78B76.IP)
[20:06:59] *** Joins: zippity (Mibbit@moz-D869EF22.a2.protectedgroup.com)
[20:07:06] *** Quits: zippity (Mibbit@moz-D869EF22.a2.protectedgroup.com) (User has been banned from Mozilla (no spamming here))
[20:07:32] *** Quits: mhordecki (mhordecki@moz-902F0004.tmodns.net) (Ping timeout)
[20:08:33] *** Joins: lkuper (lkuper@5188CCE.A402E718.C082B7DC.IP)
[20:09:14] *** Joins: maikklein (maik@moz-B067DA96.dip0.t-ipconnect.de)
[20:09:42] <nmatsakis> pauls: ping
[20:09:54] <pauls> nmatsakis: pong
[20:10:11] <nmatsakis> pauls: are there examples of item-generating macros around? is it documentd in the tutorial?
[20:11:30] <pauls> nmatsakis: looks like it's not documented in the tutorial. There's not much to say, though, except that multi-item-generating macros still don't work.
[20:13:02] <nmatsakis> pauls: are there any special conditions? I remember hearing something about doing fmt!{} instead of fmt!()?
[20:13:24] <jensnockert> Top 3 semi-useless error messages: "error: incorrect close delimiter: `}`"
[20:14:37] <strcat> jensnockert: pft
[20:14:43] * jensnockert hugs strcat.
[20:14:51] *** cade is now known as cadeee
[20:15:12] <jensnockert> On the other hand, Javascript engines take top-1 with "Oh, I'll just not execute it"
[20:15:19] <strcat> error: method `next_back` has an incompatible type: expected type parameter but found type parameter
[20:15:36] <strcat> oh, lifetimes
[20:15:53] <jensnockert> I see what you did there.
[20:16:02] <strcat> that's a real error ;p
[20:16:43] <strcat> error: mismatched types: expected `[type error]`, found tuple
[20:17:42] <pauls> nmatsakis: nope; that was considered but rejected
[20:17:44] <kimundi> let x: [type error] = pumpkin;
[20:18:16] <nmatsakis> pauls: ok, so I just define a macro as normal?
[20:18:22] <pauls> nmatsakis: yes
[20:18:30] <nmatsakis> pauls: can I use the macro within a fn body?
[20:18:34] <strcat> rusti: let x: [type error] = 5;
[20:18:35] -rusti- more than 5 lines of output, pastebinned: http://sprunge.us/KLUd
[20:18:50] <pauls> Macros decide what kind of macro they are at use site, not definition site.
[20:19:02] <pauls> This is so that X-macros will work.
[20:19:24] <jmgrosen> anyone working on file IO under the new runtime?
[20:19:28] <pauls> nmatsakis: come to think of it, this should be explicitly mentioned in the tutorial.
[20:19:51] *** Joins: alisdair (textual@1697D94C.7742FB18.FBC8476D.IP)
[20:19:56] *** Quits: pcwalton (pcwalton@moz-7B0110AD.mv.mozilla.com) (Quit: pcwalton)
[20:20:01] *** Joins: mihneadb (mihneadb@moz-4700570F.tmodns.net)
[20:20:03] *** cadeee is now known as cade
[20:20:40] *** Joins: simon (simon@moz-CBE4BB13.cable.teksavvy.com)
[20:20:51] *** Joins: mhordecki (mhordecki@moz-902F0004.tmodns.net)
[20:21:01] <pauls> nmatsakis: oh, actually it is; under "invocation location"
[20:21:32] *** Quits: alisdair (textual@1697D94C.7742FB18.FBC8476D.IP) (Ping timeout)
[20:21:53] *** Quits: maikklein (maik@moz-B067DA96.dip0.t-ipconnect.de) (Ping timeout)
[20:22:57] <brson> toddaaro: oldsched and newsched use two different TLS slots. In your test case I would expect the tls_initialized variable to be false, since the old runtime initialization code is never run
[20:23:55] <doener> hm, is it expected that a rustc build with --enable-debug generates different code than one built without?
[20:24:46] *** Joins: tjc (tjc@moz-BBE3ABD.mv.mozilla.com)
[20:24:46] *** ChanServ sets mode: +o tjc
[20:25:01] *** Quits: eschweic (Adium@moz-BBE3ABD.mv.mozilla.com) (Quit: Leaving.)
[20:25:18] <toddaaro> brson: ah, I'll have to push further then
[20:25:23] *** Quits: msingle (Thunderbir@moz-930E5D97.hr.hr.cox.net) (Ping timeout)
[20:25:30] *** Quits: rusti (rusti@moz-54F7FD49.cpe.net.cable.rogers.com) (Ping timeout)
[20:25:42] <toddaaro> brson: what is the best way to add print statements to the C code?
[20:25:48] *** Quits: strcat (strcat@moz-54F7FD49.cpe.net.cable.rogers.com) (Ping timeout)
[20:29:00] <brson> toddaaro: printf is probably the easiest. some code have access to the DLOG or KLOG macros that can be turned on with e.g. RUST_LOG=::rt::task
[20:29:31] <brson> toddaaro: the C code can also be stepped through in a debugger, which is pretty novel compared to rust
[20:29:39] *** Quits: BitPuffin (quassel@moz-49828767.cust.tele2.se) (Ping timeout)
[20:30:02] *** Joins: BitPuffin (quassel@moz-49828767.cust.tele2.se)
[20:30:17] <bblum> ok, it takes stage2 rustc 4.5 seconds to compile a 28-line source file
[20:30:20] *** Joins: strcat (strcat@moz-54F7FD49.cpe.net.cable.rogers.com)
[20:30:30] <strcat> doener: you can get different code from just compiling again ;p
[20:30:36] <kimundi> rusti: bytes!("ayÌƒe")
[20:30:39] <strcat> hash table seeds
[20:30:41] <bblum> that's with optimization off; with it on, it takes 14 seconds
[20:30:47] <doener> strcat: I mean more that just names :-p
[20:30:48] <bblum> what is going on??
[20:30:59] <strcat> bblum: hm?
[20:31:00] *** Quits: tchoma (tchoma@moz-CAF7E439.mycingular.net) (Connection reset by peer)
[20:31:20] <bblum> strcat: how can it be this slow?
[20:31:27] <strcat> bblum: we generate terrible IR
[20:31:40] <bblum> it definitely used to take half a second to compile a tiny file
[20:31:42] <doener> strcat: librustc.ll built with the debug version had like 100k more lines
[20:31:42] <strcat> in some cases it's okay now
[20:32:11] <strcat> bblum: what's the file though?
[20:32:13] *** Quits: mihneadb (mihneadb@moz-4700570F.tmodns.net) (Ping timeout)
[20:32:16] *** Joins: eschweic (Adium@moz-BBE3ABD.mv.mozilla.com)
[20:32:19] <bblum> strcat: task-perf-spawnalot.rs
[20:32:50] *** Joins: mihneadb (mihneadb@moz-4700570F.tmodns.net)
[20:32:56] <strcat> % time rustc task-perf-spawnalot.rs   
[20:32:58] <strcat> rustc task-perf-spawnalot.rs  1.13s user 0.07s system 99% cpu 1.198 total
[20:33:01] <strcat> % time rustc task-perf-spawnalot.rs -O
[20:33:03] <strcat> rustc task-perf-spawnalot.rs -O  3.19s user 0.06s system 100% cpu 3.247 total
[20:33:26] <bblum> ...
[20:33:49] <bblum> ./x86_64-unknown-linux-gnu/stage2/bin/rustc ?
[20:33:52] *** Quits: maxli (maxli@F2D29657.F60B0462.67AC9B1.IP) (Quit: Leaving.)
[20:34:07] <strcat> it's 0.7.1020.g576f395-1
[20:34:23] *** Joins: josh (josh@moz-EC7A63FD.meeting.ietf.org)
[20:34:26] <bblum> that doesn't help me
[20:34:50] <brson> doener: debug turns on the debug! macro, which generates more code
[20:35:15] <doener> brson: I'm not building the librustc.ll with --cfg debug though
[20:35:22] <bblum> strcat: oh, my mistake, my CPUs are at 800 MHz again.
[20:35:24] <doener> brson: only the compiler was built with it
[20:35:25] <bblum> >_<;;;
[20:36:25] <brson> doener: maybe some inlined functions from std contain debug!? idk
[20:36:32] <doener> brson: ah, the library crate will have the debug stuff though, and that probab.. yeah, that
[20:37:06] <miloshadzic> are rust strings "byte strings"?
[20:37:18] <bstrie> miloshadzic: they are utf-8
[20:39:01] *** Joins: james4k (james@moz-E7990244.consolidated.net)
[20:40:29] <orshem> can anybody tell me what am i doing wrong? https://gist.github.com/DovReshef/6116690
[20:40:29] <miloshadzic> bstrie: is there a package that I can use for unencoded bytestrings?
[20:41:10] <strcat> miloshadzic: ~[u8]
[20:41:11] <kimundi> miloshadzic: "unencoded" and "string" kinda contrtict each other xD
[20:41:16] <strcat> well [u8] in general
[20:41:17] *** Quits: joebobjoe (joebobjoe@55F2E07A.7F841963.2213276E.IP) (Quit: Textual IRC Client: www.textualapp.com)
[20:41:29] <kimundi> if you just wan a vector of bytes: ~[u8]
[20:41:42] <strcat> str only exists to enforce the valid UTF-8 guarantee
[20:42:04] <miloshadzic> kimundi :)
[20:42:26] <miloshadzic> i just need a string of bytes that I can also get a ascii string representation of
[20:42:52] <miloshadzic> sorry vector of bytes
[20:43:03] <miloshadzic> i guess it's [u8]
[20:43:25] <kimundi> well, if your after ascii, there is std::ascii
[20:43:27] <strcat> plenty of [u8] vectors aren't ascii though
[20:43:38] <kimundi> rusti: "hello".to_ascii()
[20:44:16] <brson> orshem: capitalize the declaration of struct Outer
[20:44:25] *** Joins: ecr (Thunderbir@moz-F724119C.uoregon.edu)
[20:45:14] <toddaaro> brson: I confirmed it with more gdb, tls_initialized is true in the bootstrap path
[20:45:16] <brson> orshem: then, in `test`, add `use inner::run_from_outside`. or maybe call inner::run_from_outside
[20:46:01] *** Quits: josh (josh@moz-EC7A63FD.meeting.ietf.org) (Quit: josh)
[20:46:12] <brson> toddaaro: when running the rt-start-main-thread test case?
[20:46:15] <toddaaro> brson: yes
[20:46:25] <orshem> brson: right, sorry, stupid mistake.
[20:46:26] *** Quits: bheylin (brianheyli@moz-8255E94E.adsl.online.nl) (Quit: bheylin)
[20:46:36] *** Quits: mhordecki (mhordecki@moz-902F0004.tmodns.net) (Quit: mhordecki)
[20:46:45] <orshem> brson: still doesn't work
[20:46:48] <orshem> though
[20:46:55] <toddaaro> brson: right before the assert it shows tls_initialized == true, which is what pushes it into the wrong path
[20:47:26] <brson> toddaaro: is this on the same branch that is on that pull request?
[20:47:51] <toddaaro> brson: yes
[20:48:06] <brson> ok, i'll give it a build
[20:48:10] <toddaaro> brson: it looks like local_ptr::init_tls_key() is the old runtime tls 
[20:48:44] <orshem> brson: 'use inner::run_from_outside' doesn't work either. also if i understood you on the ml a parent should have access to its children privates and vice versa
[20:49:12] <orshem> ?
[20:49:45] <brson> toddaaro: i don't see that
[20:50:01] *** Quits: lkuper (lkuper@5188CCE.A402E718.C082B7DC.IP) (Quit: lkuper)
[20:50:11] <bblum> can you be like, trait Foo: Bar<Self> { .. } ?
[20:50:15] *** Joins: pcwalton (pcwalton@moz-481A040C.hsd1.ca.comcast.net)
[20:50:15] *** ChanServ sets mode: +o pcwalton
[20:50:20] <toddaaro> brson: what exactly don't you see?
[20:50:22] *** Quits: jaen (jaen@moz-C284B1D3.neoplus.adsl.tpnet.pl) (Ping timeout)
[20:51:29] <brson> local_ptr::init_tls_key calls rust_initialize_tls_key, which is defined in rust_builtin.cpp which initializes a key called rt_key. this is the newsched tls key. the oldsched tls key is in rust_sched_loop.cpp and is called task_key
[20:51:44] *** Joins: tchoma (tchoma@moz-E58E29CC.dsl.static.sonic.net)
[20:52:46] <bblum> brson: we don't have stack canaries yet, do we?
[20:53:45] <brson> bblum: no, the new scheduler does not use segmented stacks at all. if code runs off the end of the stack it will fail in mysterious ways
[20:53:48] <miloshadzic> the u8 module doesn't really have any docs http://static.rust-lang.org/doc/std/u8.html
[20:53:50] <toddaaro> brson: ok, do you know what else might set the old sched tls key? also, where is the value of task_key defined? rt_key is defined as -1 but I'm not seeing a definition for task_key
[20:54:06] <bblum> brson: just confirming my suspicions from when i discovered this -- https://github.com/mozilla/rust/issues/8136
[20:54:18] *** Joins: mhordecki (mhordecki@moz-6F601BE7.lightspeed.sntcca.sbcglobal.net)
[20:54:19] <kimundi> miloshadzic: A u8 is just a 8 but unsigned integer
[20:54:21] <cmr> miloshadzic: I introduce you to: rustdoc_ng! http://seld.be/rustdoc/std/u8/generated/index.html
[20:54:28] <kimundi> bit*
[20:54:31] <cmr> (incomplete...)
[20:54:40] <kimundi> There isn't really much to it
[20:54:45] <cmr> miloshadzic: the old rustdoc can't document u8 etc because they are generated by macros
[20:54:48] *** Joins: bytewise (bytewise@moz-649C630D.unitymediagroup.de)
[20:54:59] <cmr> kimundi: there are functions that operate on it and traits it implements you know :p
[20:55:10] <brson> toddaaro: it looks like task_key is not initialized until rust_sched_loop::init_tls is called
[20:55:15] <miloshadzic> cmr, oh cool, thanks
[20:55:50] <toddaaro> brson: ok, and from there is uses the phtread query to get a "good" key
[20:56:18] <kimundi> cmr: Well, it seems like miloshadzic is expecting something special about them... Might be my misunderstantding :)
[20:56:31] <brson> toddaaro: pthread_create writes a unique key value into task_key
[20:56:43] <Florob> Note to self: Do not create circular dependencies in crates
[20:56:55] <brson> toddaaro: i can't imagine why tls_initialized would be true in this test case. i'm building now
[20:57:25] *** Quits: pcwalton (pcwalton@moz-481A040C.hsd1.ca.comcast.net) (Quit: pcwalton)
[20:57:43] *** Joins: lkuper (lkuper@A386B130.A402E718.C082B7DC.IP)
[20:58:02] <miloshadzic> kimundi, not really it's just that I'm a bit out of my depth as I've not done anything low level for years. But for example it seems that there's a function that creates a [u8] and takes a string and a radix as a parameter (std::u8::from_str_radix)
[20:58:22] <miloshadzic> that's useful :)
[20:58:27] <Sergio965> Why does fmt! require so much runtime support? :(
[20:58:33] <toddaaro> brson: oh, there is actually another patch you need before this will work
[20:58:54] <toddaaro> brson: in the initialization for run_ the main_sched uses scheds[0] for the sched task, that needs to be main_sched
[20:59:00] <sully> hey, does anybody have any tests that break ~Objects
[20:59:06] <sully> because I've been told they are broken, but
[20:59:13] <bblum> sully: i have one that *doesn't*...
[20:59:15] <strcat> sully: I don't think they're that broken
[20:59:21] <sully> bblum: that's not useful :P
[20:59:26] <bblum> yeah i know >_>
[20:59:28] <strcat> I tested that they still worked after header removal from unique ptrs
[20:59:31] <kimundi> miloshadzic: Yeah, I guess what I've should've said is that all uint, u8, u16, u32 and u64 share more or less the same functions, so each on their own isn't that special... though there are some extre ones for u8 and uint I think
[20:59:50] <bblum> sully: i do mean one that uses dynamic dispatch on ~Objects
[20:59:55] <bblum> and seems to work
[21:00:01] <bblum> it's run-pass/trait-bounds-in-arc.rs
[21:00:07] *** Joins: bent (chatzilla@moz-932324BF.hsd1.ca.comcast.net)
[21:00:56] <toddaaro> brson: oh, maybe this actually matters a lot
[21:01:09] <toddaaro> brson: I ported the test case into mod.rs under #[test]
[21:01:14] <toddaaro> brson: is that what is breaking it
[21:01:24] *** Joins: ghrust (ghrust@614D05BD.6A2AE50.F3114085.IP)
[21:01:24] <ghrust> 01[13rust01] 15bors merged 06auto into 06master: 02http://git.io/KnDU7w
[21:01:24] *** Parts: ghrust (ghrust@614D05BD.6A2AE50.F3114085.IP) ()
[21:01:26] *** Quits: hjr3 (hradtke@374E545A.3A8E9B0C.F9D9C60E.IP) (Quit: My MacBook has gone to sleep. ZZZzzzâ€¦)
[21:01:46] *** Joins: hjr3 (hradtke@374E545A.3A8E9B0C.F9D9C60E.IP)
[21:01:55] <toddaaro> brson: originally I never ran your test because I didn't realize it was there, so I figured syncing it with the rest of the runtime tests would make sense
[21:02:05] *** Quits: lkuper (lkuper@A386B130.A402E718.C082B7DC.IP) (Quit: lkuper)
[21:02:13] <acrichto> sully: https://github.com/mozilla/rust/issues/7673
[21:02:29] <brson> toddaaro: ok, that would explain why the old runtime is initialized at least
[21:02:30] <miloshadzic> kimundi, cool. Thanks
[21:02:33] *** Joins: jaen (jaen@moz-E0979827.copit.pl)
[21:02:54] <brson> toddaaro: calling rt::start from within a test case is not right since start has both global init and cleanup code
[21:02:58] <brson> that should only be called once
[21:03:26] <toddaaro> brson: so is there any way to test the start out of stage2?
[21:04:39] <brson> toddaaro: i'm not sure i understand the question, but make check-stage1-rpass TESTNAME=rt-start-on-main will run the test case in stage 1
[21:04:47] <toddaaro> really?
[21:05:04] <toddaaro> I was running make check-stage1-std yesterday and never ran your test
[21:05:11] <toddaaro> otherwise I wouldn't have noticed it was horribly broken
[21:05:15] <toddaaro> *would have
[21:05:46] <brson> toddaaro: check-stage1-rpass, not check-stage1-std
[21:05:59] <toddaaro> ah, I have no clue how the test folder works
[21:06:01] <toddaaro> I should learn this
[21:06:28] *** Joins: brendan (brendaneic@moz-BBE3ABD.mv.mozilla.com)
[21:06:41] *** sam113101 is now known as sam113101_afk
[21:06:54] <brson> the wiki has some info about the test suite: https://github.com/mozilla/rust/wiki/Note-testsuite
[21:10:04] <bblum> hmm. spawn-linked-unwatched appears to be 1/40th slower than spawn-linked-watched
[21:10:12] <bblum> i definitely expected that to be the other way around
[21:10:18] *** Quits: tchoma (tchoma@moz-E58E29CC.dsl.static.sonic.net) (Ping timeout)
[21:11:20] <bblum> i am pretty sure why unlinked is slower than linked though
[21:11:47] <bblum> this will be hard to get really informative numbers for until the post-oldrt-deletion optimizations can be applied..
[21:12:00] *** Quits: jorendorff (jorendorff@moz-2F32ACA3.hsd1.tn.comcast.net) (Quit: jorendorff)
[21:12:48] *** Quits: brendan (brendaneic@moz-BBE3ABD.mv.mozilla.com) (Quit: brendan)
[21:15:24] *** Joins: tchoma (tchoma@moz-E58E29CC.dsl.static.sonic.net)
[21:15:25] *** Quits: robertknight (robertknig@moz-AB0E96D7.range86-162.btcentralplus.com) (Ping timeout)
[21:15:36] *** Quits: vk (chatzilla@3E9D68F2.B1163E0C.2A6693DD.IP) (Ping timeout)
[21:16:26] *** Joins: graydon (Adium@A5087023.2354C43D.D8E68FF6.IP)
[21:16:26] *** ChanServ sets mode: +qo graydon graydon
[21:16:45] *** Joins: brendan (brendaneic@moz-BBE3ABD.mv.mozilla.com)
[21:17:00] *** Joins: dherman (dherman@moz-7B0110AD.mv.mozilla.com)
[21:17:01] *** ChanServ sets mode: +o dherman
[21:17:34] *** Quits: mihneadb (mihneadb@moz-4700570F.tmodns.net) (Input/output error)
[21:17:36] *** Quits: huseby (huseby@moz-4E8C421A.husebyhome.com) (Ping timeout)
[21:18:24] *** Joins: jgilbert (jgilbert@moz-BBE3ABD.mv.mozilla.com)
[21:20:29] <bblum> brson: by the way, i'm getting 200 ns for the optimistic-fastpath of message sending (just one task to itself)
[21:21:20] <bblum> (that's with oneshot; with stream it apears to be 300 ns)
[21:21:48] *** Joins: mihneadb (mihneadb@moz-BE33DA21.fw1.sfo1.mozilla.net)
[21:23:22] <brson> bblum: how does that compare to oldsched?
[21:24:49] <bblum> it appears to be 1.5x faster than oldsched pipes
[21:24:57] <bblum> note that the scheduler is not actually involved in any of this
[21:25:08] *** Quits: erickt (erickt@8C9ECD8F.3A598286.F12515B4.IP) (Quit: Leaving.)
[21:26:07] <bblum> there's not really any good reason for the optimistic fastpath to be faster in either one, maybe there are extra allocations 
[21:27:20] <bjz_> what was my error here? http://buildbot.rust-lang.org/builders/auto-mac-64-opt-vg/builds/632
[21:27:47] <tjc> bjz_: rustpkg tests -- I'm about to fix it
[21:27:56] <bjz_> ah
[21:28:14] <bjz_> tjc: so not my mistake?
[21:28:18] <tjc> bjz_: nope
[21:28:28] <bjz_> cool, just checking
[21:28:33] <bjz_> good luck!
[21:28:35] <bjz_> :D
[21:28:40] *** Joins: bheylin (brianheyli@moz-8255E94E.adsl.online.nl)
[21:28:45] *** Quits: Kruppe (user@moz-4DDA8AB8.uwaterloo.ca) (Ping timeout)
[21:28:49] <bjz_> bheylin: hurro!
[21:28:57] *** Quits: brendan (brendaneic@moz-BBE3ABD.mv.mozilla.com) (Quit: brendan)
[21:29:20] *** Quits: infynyxx (infynyxx@DB780A29.749BA1D.DCC373F0.IP) (Client exited)
[21:29:31] <bblum> haha, the old runtime has vastly unpredictable spawn performance because the tasks can get randomly put on the same scheduler
[21:29:40] <bheylin> bjz_: harro
[21:30:23] *** Quits: jensnockert (jensnocker@moz-C5F27039.cust.bredband2.com) (Input/output error)
[21:31:31] <bblum> 256k spawns on oldsched can take anywhere from 3 to 5 seconds
[21:32:45] <bjz_> bheylin: long time no speak!
[21:33:00] <bjz_> bheylin: still rusting?
[21:34:31] *** Joins: huseby (huseby@moz-4E8C421A.husebyhome.com)
[21:34:37] *** Joins: maxli (maxli@B5559308.9C54E60.2FA4EA88.IP)
[21:35:38] *** Joins: jensnockert (jensnocker@moz-C5F27039.cust.bredband2.com)
[21:36:41] <bblum> brson: http://pastebin.mozilla.org/2746883 unlinked is slower than linked A. T. M. because we're not yet lazily initializing leaf taskgroups
[21:37:06] *** Quits: jensnockert (jensnocker@moz-C5F27039.cust.bredband2.com) (Input/output error)
[21:37:06] <bblum> and a new taskgroup create is presumably more expensive than enlisting in an existing one
[21:37:21] <bblum> i'm looking into how hard it is to lazily initialize while all the oldrt stuff is still around
[21:38:36] <bblum> either way we're hovering around 15 us per spawn no matter the mode
[21:38:51] *** Quits: Ms2ger (Ms2ger@moz-BA3429A8.adsl-dyn.isp.belgacom.be) (Quit: nn)
[21:39:06] <brson> bblum: thanks for measuring
[21:39:21] <bblum> (i mean, not either way; with more lazily initializing stuff, it will get faster)
[21:41:57] <bblum> (2.5 GHz processor, i suppose that's relevant when quoting absolute numbers :P)
[21:43:30] *** Joins: sebcrozet (sebcrozet@moz-C27D92D8.w193-252.abo.wanadoo.fr)
[21:45:57] *** Quits: Sergio965 (sergiobz@moz-BB21156B.dynamic.csail.mit.edu) (Ping timeout)
[21:46:33] *** Quits: spider-mario (spidermari@moz-81131DB6.fbx.proxad.net) (Input/output error)
[21:47:26] <bblum> also, wow, it gets like 20% slower when i have a compile running in the background, even though i have 8 cores and my program is not 8-way parallel
[21:48:54] <engla> whew, that was close
[21:48:59] <engla> oops
[21:51:36] <bblum> ok, spawn_indestructible() adds basically nothing to the spawn/exit path
[21:51:45] <bblum> 4.02 seconds vs 3.99 seconds for 256k spawns
[21:51:51] *** Joins: vk (chatzilla@3E9D68F2.B1163E0C.2A6693DD.IP)
[21:52:04] <bblum> (~1% slowdown)
[21:52:22] <Ralith> is that statistically significant?
[21:52:38] <bblum> yes, the variance is much lower than the difference
[21:52:47] *** Quits: mhordecki (mhordecki@moz-6F601BE7.lightspeed.sntcca.sbcglobal.net) (Quit: mhordecki)
[21:52:55] <bblum> 4.029 4.023 4.042
[21:53:01] <bblum> 3.925 3.998 3.859
[21:53:26] <bblum> i bet half that time is spent setting the 'indestructible' option and the other half is spent making the task indestructible :P
[21:53:54] <jmgrosen> is there such thing as &'static fn?
[21:54:06] <bblum> jmgrosen: yeah, you can promote an extern fn to it
[21:54:23] <Ralith> bblum: n=3?
[21:54:29] <jmgrosen> bblum: can you pass in a closure that doesn't close on any variables?
[21:54:33] <bblum> Ralith: yeah, you want i should run it some more?
[21:54:43] <jmgrosen> and what's the difference between extern "Rust" fn and &'static fn?
[21:54:47] <Ralith> bblum: I don't actually know anything about what you're benchmarking, I just like to nitpick statistics >_>
[21:54:55] *** Quits: mihneadb (mihneadb@moz-BE33DA21.fw1.sfo1.mozilla.net) (Ping timeout)
[21:55:09] *** Joins: mihneadb (mihneadb@moz-BE33DA21.fw1.sfo1.mozilla.net)
[21:55:10] <bblum> Ralith: yeah i'm not gonna publish these figures in a journal any time soon
[21:55:15] <Ralith> 'kay
[21:55:34] <bblum> jmgrosen: hmm, not sure if that will work, probably not
[21:55:49] <bblum> jmgrosen: extern "Rust" fn is 1 word. &'static fn is 2 words, includes a 'dummy' environment pointer.
[21:56:00] *** Joins: mhordecki (mhordecki@moz-6F601BE7.lightspeed.sntcca.sbcglobal.net)
[21:56:08] <kimundi> jmgrosen: a &fn is a closure, wich basically is a raw extern "Rust" fn and a struct
[21:56:34] <kimundi> or, rather a sturct of two pointers to those things
[21:56:39] <jmgrosen> bblum, kimundi, is there any advantage to using &'static fn over extern "Rust" fn?
[21:57:01] <bblum> jmgrosen: it'd be compatible with places that expect stack closures
[21:57:10] <bblum> but i guess you can promote at any point
[21:57:11] <bblum> so...
[21:57:16] <jmgrosen> bblum: oh, interesting
[21:57:18] <kimundi> jmgrosen: In general &fn is more versatile, and what bblum said
[21:57:42] <kimundi> but yeah, effectivly there is no difference between the two
[21:57:44] <bblum> kimundi: well, extern "Rust" fn has some versatility that &fn doesn't, such as FFI compatibility
[21:57:44] *** Quits: mihneadb (mihneadb@moz-BE33DA21.fw1.sfo1.mozilla.net) (Ping timeout)
[21:59:05] *** Joins: mihneadb (mihneadb@moz-6F601BE7.lightspeed.sntcca.sbcglobal.net)
[21:59:33] *** Quits: Amanieu (amanieu@CB5576F2.F4BF8C9A.9510F13D.IP) (Quit: leaving)
[21:59:38] *** Joins: infynyxx (infynyxx@DB780A29.749BA1D.DCC373F0.IP)
[22:00:16] <bblum> brson: ~12 us per spawn with taskgroup code disabled entirely; ~12.7 us with same but spawn_watched()
[22:00:25] <bblum> i bet i can get spawn_unlinked down to that fast
[22:02:02] *** Joins: dbaupp (Thunderbir@moz-712A1135.lns20.syd6.internode.on.net)
[22:05:22] *** Joins: Amanieu (amanieu@CB5576F2.F4BF8C9A.9510F13D.IP)
[22:05:26] *** Quits: bheylin (brianheyli@moz-8255E94E.adsl.online.nl) (Quit: bheylin)
[22:05:31] *** Quits: infynyxx (infynyxx@DB780A29.749BA1D.DCC373F0.IP) (Client exited)
[22:05:51] *** Joins: infynyxx (infynyxx@DB780A29.749BA1D.DCC373F0.IP)
[22:06:17] *** Joins: erickt (erickt@8C9ECD8F.3A598286.F12515B4.IP)
[22:08:47] *** Quits: erickt (erickt@8C9ECD8F.3A598286.F12515B4.IP) (Ping timeout)
[22:09:47] *** Joins: Nisstyre (wes@moz-FD86289.netflash.net)
[22:11:13] *** Joins: brendan (brendaneic@moz-BBE3ABD.mv.mozilla.com)
[22:13:09] *** Joins: mihneadb_ (mihneadb@moz-BE33DA21.fw1.sfo1.mozilla.net)
[22:13:56] *** sam113101_afk is now known as sam113101
[22:14:10] *** Quits: mihneadb (mihneadb@moz-6F601BE7.lightspeed.sntcca.sbcglobal.net) (Ping timeout)
[22:14:23] *** Joins: mihneadb (mihneadb@moz-BE33DA21.fw1.sfo1.mozilla.net)
[22:14:57] *** Quits: mihneadb_ (mihneadb@moz-BE33DA21.fw1.sfo1.mozilla.net) (Ping timeout)
[22:15:16] *** Joins: int3_ (int3_@moz-ABE52D50.hsd1.ca.comcast.net)
[22:16:29] *** Quits: Amanieu (amanieu@CB5576F2.F4BF8C9A.9510F13D.IP) (Quit: leaving)
[22:16:35] *** Quits: vk (chatzilla@3E9D68F2.B1163E0C.2A6693DD.IP) (Ping timeout)
[22:16:49] *** Joins: Amanieu (amanieu@10FEE2FD.ECEF57A4.2CFD4520.IP)
[22:17:22] *** Quits: tchoma (tchoma@moz-E58E29CC.dsl.static.sonic.net) (Ping timeout)
[22:20:26] <tikue> hey guys, how do I do something like: struct Foo(uint); let mut my_foo = Foo(0); my_foo += 1;
[22:20:42] *** Joins: azita (Azita@C1C006D3.FDA6D3F2.FAF22AF7.IP)
[22:21:20] <olsonjeffery> brson: ping
[22:21:49] <tikue> is the best way just: `my_foo = Foo(*my_foo + 1);`
[22:22:23] *** Joins: ghrust (ghrust@614D05BD.6A2AE50.F3114085.IP)
[22:22:23] <ghrust> 01[13rust01] 15bors pushed 0 new commits to 06auto: 02http://git.io/X3I4JA
[22:22:23] *** Parts: ghrust (ghrust@614D05BD.6A2AE50.F3114085.IP) ()
[22:22:23] *** Joins: ghrust (ghrust@C621748.6A2AE50.F3114085.IP)
[22:22:23] <ghrust> 01[13rust01] 15bors pushed 2 new commits to 06auto: 02http://git.io/D1n4YA
[22:22:23] <ghrust> 13rust/06auto 145ec1d5b 15OGINO Masanori: FALSE is not 1u8 but 0u8, of cource....
[22:22:23] <ghrust> 13rust/06auto 14912d806 15bors: auto merge of #8137 : omasanori/rust/ubool-false, r=bblum...
[22:22:24] *** Parts: ghrust (ghrust@C621748.6A2AE50.F3114085.IP) ()
[22:23:02] *** Quits: infynyxx (infynyxx@DB780A29.749BA1D.DCC373F0.IP) (Client exited)
[22:23:04] <engla> tikue: *my_foo += 1
[22:23:09] <tikue> engla: thank you!!
[22:23:29] *** Quits: jedestep (jedestep@34641662.FB4DE631.66C78B76.IP) (Ping timeout)
[22:23:34] <bjz_> tikue: you will be able to overload the assignment operators in the future
[22:23:43] <tikue> bjz_: ! 
[22:23:45] <tikue> awesome
[22:23:59] <bblum> engla: does that really work? not my_foo = Foo(*my_foo + 1) ?
[22:24:05] <engla> it works
[22:24:12] <bblum> well then
[22:24:17] <jmgrosen> what's the best way of getting from a ~str to a &'self str?
[22:24:19] <tikue> bblum: that one definitely works  too
[22:24:30] <bblum> jmgrosen: as_slice or something along those lines
[22:24:48] <engla> it should coerce to that
[22:24:53] <bblum> jmgrosen: er, wait, you should be able to, yeah
[22:24:54] <engla> but otherwise as_slice yeah
[22:24:56] <bblum> auto promote
[22:25:07] <jmgrosen> the compiler is complaining
[22:25:19] <olsonjeffery> well, can anybody help me troubleshoot this: https://gist.github.com/olsonjeffery/6117567
[22:25:21] <jmgrosen> and i don't want it as a slice
[22:25:30] <jmgrosen> (that is, i don't want to copy it)
[22:25:35] <olsonjeffery> im not using/declaring the cleanup_cb correctly, it seems
[22:25:42] <engla> jmgrosen: a slice is a view, not a copy
[22:25:59] <engla> jmgrosen: slice is just the name of  &'self str  basically
[22:26:06] *** Quits: brendan (brendaneic@moz-BBE3ABD.mv.mozilla.com) (Quit: brendan)
[22:26:09] <jmgrosen> engla: ok, then that should work, thanks
[22:27:26] <brson> olsonjeffery: pong
[22:28:14] <olsonjeffery> brson: see gist above
[22:29:06] <olsonjeffery> generalizing the tcp_connect stuff between the sync and async versions.. just factored the scheduling stuff out, since an async version will return a future instead
[22:29:39] *** Joins: brendan (brendaneic@moz-BBE3ABD.mv.mozilla.com)
[22:29:39] *** Quits: eatkinson (eatkinson@moz-BBE3ABD.mv.mozilla.com) (Quit: eatkinson)
[22:29:56] *** Joins: mcclurmc (mcclurmc@moz-8D61EFD1.cable.virginmedia.com)
[22:30:10] <olsonjeffery> i guess the main issue is that the second use (passing the Err res to cleanup_cb) is doubly nested
[22:30:34] *** Joins: eatkinson (eatkinson@moz-BBE3ABD.mv.mozilla.com)
[22:30:59] *** Quits: mhordecki (mhordecki@moz-6F601BE7.lightspeed.sntcca.sbcglobal.net) (Ping timeout)
[22:31:05] *** Quits: parcha (quassel@moz-A9A9F340.hsd1.ma.comcast.net) (Ping timeout)
[22:31:20] *** Quits: chii (Mibbit@BBE7C46A.B4F11D08.8612FA94.IP) (Quit: http://www.mibbit.com ajax IRC Client)
[22:31:25] *** Quits: doener (doener@moz-121949B3.unitymediagroup.de) (Quit: leaving)
[22:31:31] <brson> olsonjeffery: the error message is confusing, but you definitely need to put the cleanup_cb into a Cell before capturing it in the first closure if you are going to then capture it in the second - once the cb is captured once it can't be moved again into the second. So let cleanup_cb_cell = Cell::new(cleanup_cb); capture; let cleanup_cb = cleanup_cb_cell.take();
[22:31:37] <brson> olsonjeffery: then you should be able to recapture it
[22:31:45] <brson> there may be other errors there but that's the first thing to do
[22:32:04] <olsonjeffery> ok, thanks.
[22:32:57] *** Quits: orshem (orshem@C5E06B1E.A5B6B765.E3D28531.IP) (Quit: Leaving)
[22:33:02] *** Joins: erickt (erickt@8C9ECD8F.3A598286.F12515B4.IP)
[22:33:03] <brson> toddaaro: what is your game plan right now?
[22:33:12] *** Quits: BitPuffin (quassel@moz-49828767.cust.tele2.se) (Ping timeout)
[22:34:08] <smvv> what's the purpose of Cell? "a mutable, nullable memory location" is somewhat vague
[22:34:31] <bblum> smvv: for solving this problem, mostly -- https://github.com/mozilla/rust/wiki/Doc-under-construction-FAQ#Once_functions
[22:35:03] <engla> well, it is mutable even if it has methods taking &self
[22:35:07] <bblum> it has other purposes such as that
[22:35:07] <bblum> yes
[22:35:10] <toddaaro> brson: I finally got the code compiling, that error is gone, but a new one related to task destruction popped up
[22:35:25] <toddaaro> brson: 'make check' started recompiling llvm before I could stop it, no clue why
[22:35:45] <toddaaro> so that was an hour or so
[22:35:57] *** Quits: ecr (Thunderbir@moz-F724119C.uoregon.edu) (Quit: ecr)
[22:36:07] *** Quits: Florob (Florob@moz-39532932.de) (Client exited)
[22:36:19] *** Quits: km (quassel@FDBAF0A0.DBF71E41.29C67456.IP) (Ping timeout)
[22:36:57] *** Quits: ozten (ozten@moz-DD3B00B4.hsd1.wa.comcast.net) (Ping timeout)
[22:37:38] *** Quits: jdm (jdm@92FB48CA.8B5E9DF.9A8C35B4.IP) (Quit: Lost terminal)
[22:38:20] <jmgrosen> rusti: let a = ~[1, 2, 3, 4]; let iter = a.iter(); (iter.next(), iter.collect())
[22:38:52] *** Joins: ozten (ozten@moz-DD3B00B4.hsd1.wa.comcast.net)
[22:38:53] <jmgrosen> where's rust?
[22:38:55] <jmgrosen> *rusti
[22:39:02] *** Joins: rusti (rusti@moz-54F7FD49.cpe.net.cable.rogers.com)
[22:39:10] <bblum> rusti: botsnack
[22:39:11] -rusti- <anon>:5:9: 5:17 error: unresolved name `botsnack`.
[22:39:12] -rusti- <anon>:5          botsnack
[22:39:12] -rusti-                   ^~~~~~~~
[22:39:12] -rusti- error: aborting due to previous error
[22:39:12] -rusti- application terminated with error code 101
[22:39:13] <smvv> bblum: in the wiki it says: "let message_cell == Cell::new(message);". i assume that's a typo? if yes, I'll change it to assignment
[22:39:31] <bblum> smvv: oh, yes, good catch
[22:40:02] <jmgrosen> rusti: let a = ~[1, 2, 3, 4]; let iter = a.iter(); (iter.next(), iter.collect())
[22:40:02] -rusti- <anon>:5:67: 5:82 error: cannot determine a type for this bounded type parameter: unconstrained type
[22:40:03] -rusti- <anon>:5          let a = ~[1, 2, 3, 4]; let iter = a.iter(); (iter.next(), iter.collect())
[22:40:03] -rusti-                                                                             ^~~~~~~~~~~~~~~
[22:40:03] -rusti- application terminated with error code 101
[22:40:22] *** Quits: maxli (maxli@B5559308.9C54E60.2FA4EA88.IP) (Quit: Leaving.)
[22:40:28] <jmgrosen> rusti: let a: ~[int] = ~[1, 2, 3, 4]; let iter = a.iter(); (iter.next(), iter.collect())
[22:40:31] -rusti- <anon>:5:75: 5:90 error: cannot determine a type for this bounded type parameter: unconstrained type
[22:40:31] *** simon is now known as IRCMonkey16438
[22:40:31] -rusti- <anon>:5          let a: ~[int] = ~[1, 2, 3, 4]; let iter = a.iter(); (iter.next(), iter.collect())
[22:40:31] -rusti-                                                                                     ^~~~~~~~~~~~~~~
[22:40:32] -rusti- application terminated with error code 101
[22:40:59] <jmgrosen> rusti: let a: ~[int] = ~[1, 2, 3, 4]; let iter = a.iter(); let foo = iter.next(); let collected = iter.collect(); (foo, collected)
[22:41:00] -rusti- <anon>:5:100: 5:115 error: cannot determine a type for this bounded type parameter: unconstrained type
[22:41:00] -rusti- <anon>:5          let a: ~[int] = ~[1, 2, 3, 4]; let iter = a.iter(); let foo = iter.next(); let collected = iter.collect(); (foo, collected)
[22:41:00] -rusti-                                                                                                              ^~~~~~~~~~~~~~~
[22:41:00] -rusti- application terminated with error code 101
[22:41:17] <strcat> collect() returns a generic container type
[22:41:17] *** Joins: dbp (user@moz-72A193C2.ri.ri.cox.net)
[22:41:23] <strcat> you're not providing any way it can infer the type
[22:41:25] <jmgrosen> right
[22:41:34] <jmgrosen> rusti: let a: ~[int] = ~[1, 2, 3, 4]; let iter = a.iter(); let foo = iter.next(); let collected: ~[int] = iter.collect(); (foo, collected)
[22:41:36] -rusti- more than 5 lines of output, pastebinned: http://sprunge.us/FGDX
[22:41:59] <jmgrosen> ?
[22:42:29] *** Joins: mhordecki (mhordecki@moz-BE33DA21.fw1.sfo1.mozilla.net)
[22:42:51] <bblum> brson: hmm, should task names be a Option<~str>, or a Option<&'static str>, or a Option<Either<~str, &'static str>> ?
[22:43:11] <toddaaro> brson: do you know how to make your test print? it uses the info! macro which I have no seen before. The code is clearly running based on my other debug, but none of hte output is from the test.
[22:43:24] <bblum> the former lets people fmt! their task names; the second lets people save on allocations; the third gives the best of both worlds but is clunky
[22:43:54] <engla> a place for StringRef
[22:44:01] <engla> or whatever the trait for sendable traits was
[22:44:06] <engla> sendable strings
[22:44:08] <bblum> engla: tell me more
[22:44:09] *** Quits: true_droid (Adium@moz-123FD9B8.beck.volia.net) (Quit: Leaving.)
[22:44:24] <engla> it lives in the issue tracker I think
[22:44:34] <bblum> that is not a good place for it to live :P :P
[22:44:42] <engla> https://github.com/mozilla/rust/pull/7599
[22:44:57] <engla> Adds types for representing either a static string/vector or an owned string/vector.
[22:45:05] <engla> it's the thing
[22:45:23] <bblum> great, thanks
[22:45:37] *** Joins: Jesin (Jessin_@moz-1B1307FF.eecs.lehigh.edu)
[22:47:18] *** sam113101 is now known as sam113101_afk
[22:48:32] <brson> bblum: yeah, I think there are a few runtime strings that want to be either. I'm not entirely happy with that pr though.
[22:49:02] *** Quits: jbaldwin (Mibbit@EF784383.FC9BECD6.A8DE49A2.IP) (Quit: http://www.mibbit.com ajax IRC Client)
[22:49:10] <brson> toddaaro: RUST_LOG=rt-start-on-main I think
[22:49:20] <jmgrosen> rusti: let foo = ~[1, 2, 3, 4]; foo.slice_from(1)
[22:49:22] -rusti- more than 5 lines of output, pastebinned: http://sprunge.us/eWhB
[22:50:40] <bblum> hmm i am torn whether to make 'fn name' be the setter or the getter, and what to call the other
[22:50:56] *** sam113101_afk is now known as sam113101
[22:51:10] *** Quits: brianm (brianm@D2D642B9.79695EE7.489C5759.IP) (Connection reset by peer)
[22:51:10] *** Joins: brianm (brianm@D2D642B9.79695EE7.489C5759.IP)
[22:51:14] <jmgrosen> oh THAT'S why it's not working
[22:51:21] <jmgrosen> my version of rust doesn't have slice_from >.<
[22:51:32] <bblum> actually the getter makes little sense, hm
[22:52:08] <jmgrosen> does vec.slice(a, b) return [a, b] or [a, b) ?
[22:52:25] <bblum> [a,b)
[22:52:30] <jmgrosen> ok, great
[22:54:27] <sully> oh, hm, did somebody else land a "type renaming" patch?
[22:54:46] *** Quits: azita (Azita@C1C006D3.FDA6D3F2.FAF22AF7.IP) (Quit: azita)
[22:55:27] <sully> node_id renamed, at least
[22:58:12] *** Quits: int3_ (int3_@moz-ABE52D50.hsd1.ca.comcast.net) (Client exited)
[22:58:15] *** Joins: parcha (quassel@moz-A9A9F340.hsd1.ma.comcast.net)
[22:58:31] *** Quits: dherman (dherman@moz-7B0110AD.mv.mozilla.com) (Quit: dherman)
[22:58:40] *** Joins: int3_ (int3_@moz-ABE52D50.hsd1.ca.comcast.net)
[22:59:20] *** Quits: int3_ (int3_@moz-ABE52D50.hsd1.ca.comcast.net) (Client exited)
[23:01:10] <cmr> mw did yes
[23:02:16] *** Quits: Jesin (Jessin_@moz-1B1307FF.eecs.lehigh.edu) (Quit: Leaving)
[23:02:57] *** sam113101 is now known as sam113101_afk
[23:03:23] *** Joins: maxli (maxli@B5559308.9C54E60.2FA4EA88.IP)
[23:03:23] *** sam113101_afk is now known as sam113101
[23:03:30] *** Quits: devinus (devinus@moz-B4AF84BC.ptr.us.xo.net) (Quit: Textual IRC Client: www.textualapp.com)
[23:06:27] *** Joins: carllerche (carllerche@A01051A9.6F669779.3D1CA460.IP)
[23:07:25] *** Quits: parcha (quassel@moz-A9A9F340.hsd1.ma.comcast.net) (Ping timeout)
[23:07:59] <mihneadb> hey. I want to give a short brownbag-style talk to my team on a work week on rust, and I m looking for a good demo theme
[23:08:14] <mihneadb> I was thinking to get some erlang-style (tons of tasks) demo and do it in rust
[23:08:18] <mihneadb> do you guys have a better suggestion?
[23:08:29] *** kimundi is now known as zz_kimundi
[23:09:21] <tjc> mihneadb: sounds like a good idea. The Rust talks so far that I know of haven't focused on concurrency
[23:09:26] <cmr> mihneadb: the task model is only a library. show the cool zero-overhead memory safety and pattern matching.
[23:09:28] <tjc> so (if you plan to put your slides online) it would be a good addition
[23:10:07] <cmr> I mean tasks are cool, but lots of things can do tasks. THey just can't do them as well as rust can :)
[23:10:14] <bblum> brson: what's a good default name for unnamed tasks? currently i have '<anon>'
[23:10:24] <bblum> or anybody really
[23:10:28] <bblum> open to suggestions
[23:10:30] <bblum> babynames.com
[23:10:34] <mihneadb> tjc: thanks
[23:10:45] <tjc> well, "Satin" is the name of the day
[23:10:47] <tjc> seems legit
[23:10:49] <brson> mihneadb: a scalable task demo in rust is probably prone to backfire. our tasks are bloated and our scheduling sucks
[23:10:51] *** Quits: brendan (brendaneic@moz-BBE3ABD.mv.mozilla.com) (Quit: brendan)
[23:10:59] <mihneadb> cmr: I thought that  maybe talking about the memory model in detail would be too "deep" for the purposes
[23:11:13] <cmr> bblum: if there's no possibility that the <anon> could be confused with the filename, sounds good to me
[23:11:23] <brson> bblum: <anon> is fine
[23:11:24] *** Quits: huseby (huseby@moz-4E8C421A.husebyhome.com) (Quit: Leaving)
[23:11:34] <mihneadb> brson: so what would you do? :)
[23:11:39] <jmgrosen> it would be really nice if there were a .map or .transform directly on vectors
[23:11:51] <bblum> cmr: it prints separately from the filename
[23:11:58] <cmr> jmgrosen: why would that be better than having it on iterators?
[23:12:13] <jmgrosen> cmr: i think both would be best
[23:12:15] <cmr> (Vectors will eventually be iterables, there are just too many compiler bugs atm)
[23:12:31] <mihneadb> btw
[23:12:38] <mihneadb> did you guys consider having something similar to what clojure has
[23:12:47] <mihneadb> i.e. the default seq trait
[23:12:51] <jmgrosen> cmr, it's annoying to have to do vec.iter().transform(f).collect() instead of just vec.transform(f)
[23:12:56] <mihneadb> which supports map and the classics
[23:13:03] <strcat> jmgrosen: you would still have to do .collect
[23:13:22] <cmr> mihneadb: we have Iterator<T> for that
[23:13:23] <strcat> jmgrosen: if vectors have a map/transform method on them, it's not going to copy the entire vector by default
[23:13:35] <doomlord> i've been convinced the convinient names want to pair  up with 'collect', so they can be composed
[23:13:39] <mihneadb> cmr: so then vec.iter().map
[23:13:40] <mihneadb> ?
[23:13:50] <jmgrosen> strcat, why not? it seems like a very common use case
[23:13:53] <doomlord> they've done that right
[23:13:58] *** Joins: brendan (brendaneic@moz-BBE3ABD.mv.mozilla.com)
[23:14:15] <doomlord> but the shortcut to avoid iter() would be nice..
[23:14:20] <cmr> mihneadb: well it's named transform instead of map because of a compiler bug, and it will eventually just be vec.map, but yes.
[23:14:25] <strcat> jmgrosen: it's not the use case that should be common
[23:14:31] <mihneadb> doomlord: I guess that's necessary for type reasons?
[23:14:39] <jmgrosen> strcat, hm
[23:14:40] <cmr> mihneadb: bugs, not reasons :p
[23:14:45] <strcat> 90% of the uses of the methods like that in the compiler are incorrect
[23:14:45] <mihneadb> oh
[23:14:50] <strcat> they're creating a new vector when they don't need to
[23:14:54] <mihneadb> cmr: so you will take out the .iter() layer eventually?
[23:14:55] <doomlord> vec.map().collect()      vec.map().filter().collect()  ... vec.filter().fold().collect() etc
[23:14:59] <cmr> jmgrosen: it's the least possibly efficient way to do that
[23:15:14] <cmr> mihneadb: For some data structures (like vectors), yes
[23:15:33] <strcat> efficient code will look better than inefficiently copying with each composed method
[23:15:42] <jmgrosen> car, yeah, i guess -- i suppose i'm being a little hypocritical since i always recommend generator expressions over list comprehensions in python
[23:15:46] <jmgrosen> *cmr
[23:15:47] <strcat> you can still copy the vector, but it will be explicit
[23:15:55] <jmgrosen> and it's even more important in a systems language
[23:16:05] <mihneadb> cade: will that be macro magic? Or will it just be via the Iterable trait? (I'm thinking about how rustc will know about the type)
[23:16:09] <mihneadb> cmr: ^sorry
[23:16:12] <bblum> hmm, i think i like <unnamed> better
[23:16:16] <bblum> it hints "hey, you can name it!"
[23:16:18] <cmr> mihneadb: Iterable trait
[23:16:21] <mihneadb> cmr: ok
[23:16:35] <mihneadb> btw - is there any place in the SF office where I can find a rust sticker? :D
[23:17:06] <jmgrosen> cmr, will it just automagically implement all iterator methods on iterables, or what?
[23:17:20] <strcat> jmgrosen: doesn't require magic
[23:17:28] <strcat> rust supports extending types with methods on implementations
[23:17:37] <jmgrosen> strcat: ah, right
[23:17:37] <strcat> and there are lang items
[23:17:46] <strcat> to implement `for`
[23:18:26] <jmgrosen> so will `for` loop on both iterators and iterables? or will iterators just be iterables that return itself?
[23:18:40] *** Joins: Jesin (Jessin_@moz-1B1307FF.eecs.lehigh.edu)
[23:22:19] <strcat> they can't be iterables
[23:22:26] *** Quits: yonran (yonran@moz-962F33EB.acuitus.com) (Ping timeout)
[23:23:18] *** Joins: infynyxx (infynyxx@DB780A29.749BA1D.DCC373F0.IP)
[23:23:40] *** Quits: brendan (brendaneic@moz-BBE3ABD.mv.mozilla.com) (Quit: brendan)
[23:23:48] <jmgrosen> is there any way to make a static hashmap? (i.e. one made at compile time)
[23:24:09] <strcat> no
[23:24:12] <jmgrosen> ok
[23:24:59] *** Quits: infynyxx (infynyxx@DB780A29.749BA1D.DCC373F0.IP) (Ping timeout)
[23:29:03] <jmgrosen> is there anywhere i can stash a global hash map?
[23:29:47] *** Quits: carllerche (carllerche@A01051A9.6F669779.3D1CA460.IP) (Ping timeout)
[23:29:55] <strcat> there's not a way you can have a global hash map without unsafe code
[23:30:19] <strcat> not entirely sure if it will let you use one in a static mut anyway
[23:30:29] <jmgrosen> hm
[23:30:36] *** Joins: carllerche (carllerche@A01051A9.6F669779.3D1CA460.IP)
[23:30:38] <erickt> graydon / nmatsakis / brson: hey there! I finally have a free moment if any of you want to talk unsafe pointers
[23:31:21] <graydon> hi
[23:31:27] <graydon> I guess?
[23:31:37] <graydon> an email might also work well, but we can try here
[23:32:08] *** Joins: parcha (quassel@moz-A9A9F340.hsd1.ma.comcast.net)
[23:32:22] <erickt> ok :) so I'm not quite sure where the meeting ended, I got pulled into a meeting right after I posted my comment
[23:33:33] *** Joins: Kruppe (user@moz-E150F49F.cpe.net.cable.rogers.com)
[23:35:12] <erickt> graydon: I spelled out the basis of my argument in https://github.com/mozilla/rust/issues/7694
[23:35:33] *** sam113101 is now known as sam113101_afk
[23:36:18] <erickt> graydon: the problem is that it's really easy to write code that allows an unsafe pointer to live past the structure it's pointing to. Here's an example: https://gist.github.com/erickt/5967320
[23:36:34] *** Quits: snadon (chatzilla@moz-3BC727E8.mc.videotron.ca) (Ping timeout)
[23:36:46] <cmr> erickt: the biggest question afaict is "Why can't you use a borrowed pointer there?"
[23:37:54] <erickt> cmr: sure you can do that, and that would avoid this particular problem. I however am more concerned about the general case
[23:38:34] <erickt> cmr: I expect that people writing C bindings will reach for unsafe pointers more often than not when writing their FFI functions
[23:38:54] <acrichto> erickt: how much of a problem do you think it would be if there were no implicit casting of '&' to '*' ?
[23:39:14] <acrichto> in that example the implicit cast seems the most egregious to me
[23:40:52] <graydon> erickt: what's wrong with that example?
[23:41:15] *** Quits: donri (dag@moz-9BB61102.tbcn.telia.com) (Client exited)
[23:41:21] <graydon> erickt: does the Cstr drop itself before the *-using call returns?
[23:41:26] <erickt> acrichto: it would certainly make the user be more explicit. It'll help that the compiler will force the user do do something. However, I still expect folks would write `baz(CStr2::new(2).as_ref() as *u8)` which still triggers the bug
[23:41:31] <erickt> graydon: yeah
[23:41:45] <graydon> erickt: that sounds like a lifetimes-of-temporaries problem then
[23:42:22] <sully> ok, so, what is the proper use of "NOTE" in comments
[23:42:35] <graydon> (which I will note we had a patch on today -- doener made it -- and I stopped it because I think this is just ill defined in general: https://github.com/mozilla/rust/issues/3511 is the general bug)
[23:43:08] *** Joins: pcwalton (pcwalton@moz-481A040C.hsd1.ca.comcast.net)
[23:43:08] *** ChanServ sets mode: +o pcwalton
[23:43:12] <graydon> sully: not sure. nmatsakis added it as a mechanism to get warned about something you meant to do before committing, I think? IOW I think you're not supposed to leave them in long term.
[23:43:14] <erickt> graydon: now another fix for this particular example would be to make sure a temporary lives as long as the expression it's in. But then you still can do `let x: *u8 = CStr2::new(2).as_ref(); baz(x)`. I'm using the explicit cast here because I'm not sure if the type inferrer will infer x to be &u8 or *u8
[23:43:50] <tjc> sully: they're to remind you to fix something before you check it in
[23:43:59] <tjc> ideally you wouldn't check in code with NOTEs, unless it's to do with snapshots
[23:44:15] <cmr> I think the same few NOTEs have been kicking around since I first started contributing
[23:44:32] *** Quits: ozten (ozten@moz-DD3B00B4.hsd1.wa.comcast.net) (Quit: ozten)
[23:44:32] <strcat> cmr: I added and removed 2 ;p
[23:45:24] <sully> ok, I am going to purge all of the current notes, I think?
[23:45:36] <erickt> graydon: that would help once it gets into a landable state
[23:45:38] <sully> because one of them is a "remove after snapshot" and the reset seem like they shouldn't be NOTE
[23:46:14] *** Quits: henrikhodne (henrikhodn@moz-87E975F1.dsl.static.sonic.net) (Ping timeout)
[23:46:18] <graydon> erickt: I guess I'm just wondering what *-with-a-lifetime means beyond &
[23:46:26] <tjc> sully: don't bother removing the rustpkg-related ones, I'm removing them in my next pull request
[23:46:46] <sully> ok
[23:48:12] <erickt> graydon: My patch made the different between * and & to be just whether or not it's safe to dereference them
[23:48:54] *** Joins: enix (enix@moz-A50569DD.c3-0.slvr-ubr1.lnh-slvr.md.cable.rcn.com)
[23:49:20] *** Quits: tikue (tkuehn@moz-BBE3ABD.mv.mozilla.com) (Quit: tikue)
[23:49:46] <graydon> erick: but that's really the point, isn't it? that it's unsafe _because_ we can't relate its lifetime to its referent.
[23:50:14] <erickt> graydon: there are also secondary effects like you probably want to have the ptr.offset method only work for * ptrs as it'd be strange to have it on & ptrs
[23:50:27] <graydon> ok. arithmetic. anything else?
[23:50:33] <engla> so really the vec iterators should really use &'a T  with pointer arithmetic? instead of *T?
[23:51:07] <strcat> vec iterators can't use &T unless we change the meaning of &
[23:51:07] <graydon> no, pointer arithmetic on &T isn't legit because we don't know there's another T after the one being pointed to
[23:51:08] <erickt> graydon: nullability?
[23:51:29] <strcat> the vector iterators rely on LLVM's definition of an address one byte past the end of an object being valid
[23:51:36] *** Quits: jaen (jaen@moz-E0979827.copit.pl) (Ping timeout)
[23:51:42] <strcat> erickt: Option<&T> is 1-word
[23:51:49] <engla> why doesn't that apply to &T? strcat
[23:52:01] <graydon> nullability can be done with option<&T> though, yes? and I mean .. what's the lifetime of null referent?
[23:52:10] <strcat> &T is supposed to point at a valid object
[23:52:18] <strcat> the compiler could optimize with that assumption
[23:52:24] <engla> ok
[23:52:30] *** Joins: Egbert9e9 (Egbert9e9@moz-366B5D68.inter.net.il)
[23:52:53] <erickt> strcat: I was just about to say that. We need to make a call if we are going to define Option<&T> being 1-word be part of our ABI  
[23:53:43] <strcat> if you had & pointers to invalid objects, it would break once we have llvm.invariant intrinsics
[23:53:44] *** Joins: ChrisMorgan (chris@moz-6AC741CA.static.tpgi.com.au)
[23:54:07] <strcat> since for T: Freeze, the compiler can tell LLVM that memory is immutable
[23:54:14] <erickt> graydon: This was my ptr::null impl: `ptr::null<'a>() -> *'a T { cast::transmute(0) }` 
[23:54:37] *** Joins: tchoma (tchoma@moz-E58E29CC.dsl.static.sonic.net)
[23:55:02] *** Joins: tikue (tkuehn@moz-BBE3ABD.mv.mozilla.com)
[23:55:21] <graydon> erick: that seems really weird to me. the pointer points to 'a T-or-null-or-any-value-offset-by-pointer-arithmetic-from-a-live-T?
[23:55:22] <erickt> graydon: but to recover the old behavior where we ignore the lifetime of the pointer, we can just use `*'static T`
[23:55:50] <strcat> have to be careful about pointer arithmetic
[23:55:57] <strcat> can quickly break the aliasing rules
[23:56:01] <graydon> yes, exactly
[23:56:19] *** Quits: Egbert9e9 (Egbert9e9@moz-366B5D68.inter.net.il) (Quit: Egbert9e9)
[23:56:25] <graydon> I would generally think the way to approach this is not to enrich * but to change APIs to confine it to smaller and smaller cases
[23:56:41] <strcat> LLVm has a lot of rules we don't really tell people about in the * APIs
[23:56:54] <strcat> like, you're not allowing to make a null pointer and offset it to a real object
[23:57:02] <strcat> or take a pointer to an object and use it to index outside the object
[23:57:41] <erickt> graydon: well the other angle is that I think we could remove unsafe pointers altogether and replace them with a library
[23:57:50] <graydon> ok...
[23:58:04] * strcat is worried about zero-size types ;p
[23:58:25] <strcat> hard to reason about whether lots of code is correct in the presence of them
[23:59:00] *** sam113101_afk is now known as sam113101
[23:59:13] *** Quits: sk (sk@61A494B3.BA40E8A.AAC02D62.IP) (Ping timeout)

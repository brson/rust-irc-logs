[00:00:02] <strcat> impl<'self, A, T: Iterator<A> + DoubleEndedIterator<A>> DoubleEndedIterator<A> for FilterIterator<'self, A, T> {
[00:00:04] <strcat> heh
[00:00:24] <strcat> oh wait trait inheritance should cover that
[00:00:26] *** Quits: dherman (dherman@moz-6CA476B1.hsd1.ca.comcast.net) (Ping timeout)
[00:00:52] *** Joins: dherman (dherman@moz-6CA476B1.hsd1.ca.comcast.net)
[00:00:52] *** ChanServ sets mode: +o dherman
[00:02:00] *** tikue is now known as tikue_errand
[00:02:16] <jdm> graydon: what I'm really wondering about is whether a @S allocation is comparable performance-wise to S, and if I hurt myself by passing around a S where I used to pass @S
[00:02:39] <cmr> jdm: you should probably be using & ?
[00:03:25] <graydon> yeah, & is your friend for such things
[00:03:26] <jdm> cmr: I suppose I might be able to call move_val_init(..., *s) if I take an &S
[00:03:29] <strcat> jdm: how big is it?
[00:03:34] <graydon> try to avoid using @
[00:03:56] <jdm> strcat: anywhere from a 1-15 words
[00:06:34] *** Joins: Jesin (Jessin_@moz-1B1307FF.eecs.lehigh.edu)
[00:08:30] *** Joins: brendan (brendaneic@10487EE8.58B1B661.22B0E380.IP)
[00:08:56] *** Quits: brendan (brendaneic@10487EE8.58B1B661.22B0E380.IP) (Quit: brendan)
[00:09:01] <dherman> I haz a rust!
[00:09:03] <dherman> phew
[00:09:08] *** Joins: enix (enix@moz-A50569DD.c3-0.slvr-ubr1.lnh-slvr.md.cable.rcn.com)
[00:10:08] <jdm> soon rust shall haz you
[00:10:37] <jdm> when we unleash the power of this fully-armed and operational programming language
[00:10:37] <dherman> ~dave
[00:10:54] <dherman> THAT'S NO COMPILER
[00:11:33] *** Joins: tcr (tcr@D26BCFC9.C2203064.EDCE493E.IP)
[00:11:34] <strcat> jdm: just convince graydon to make bors handle commits to bors
[00:12:35] <dherman> augh
[00:13:04] <dherman> apparently my old versions of rust kept around crates somewhere?
[00:13:14] <dherman> rbtree.rs:1:0: 1:0 error: multiple matching crates for `std`
[00:13:14] *** Quits: tikue_errand (tkuehn@moz-BBE3ABD.mv.mozilla.com) (Quit: tikue_errand)
[00:13:18] *** Quits: tcr (tcr@D26BCFC9.C2203064.EDCE493E.IP) (Ping timeout)
[00:13:20] <jdm> yep
[00:13:24] <dherman> halp
[00:13:25] <cmr> a make uninstall should do it
[00:13:31] <cmr> and then another make install
[00:13:35] <dherman> ok
[00:13:51] <dherman> phew
[00:13:53] <dherman> cmr++
[00:13:53] <ChrisMorgan> I had this code, which compiled on a build from several days ago: `let mut buf = vec::from_elem(len, 0); let size = sockbuf.read(buf, len);` where sockbuf.read wants a &mut [u8]. On a fresh build, it's now complaining that it got a ~[int]. Changing the 0 to 0u8 works fine. Is it deliberate that 0 is now 0i rather than an as-yet-undetermined integer type?
[00:14:25] <cmr> ChrisMorgan: Hm, that seems like a bug
[00:14:30] <aatch> ChrisMorgan, the inference for integers is a little wonky
[00:14:30] <cmr> ChrisMorgan: it should properly infer the type
[00:14:36] <cmr> it only uses int when it can't find anything else
[00:14:36] <dherman> Re: trait bounds are not allowed in enumeration definitions -- is the workaround a one-element struct?
[00:14:42] <aatch> and falls back to `int`
[00:14:51] <strcat> dherman: priv field + constructor with bounds
[00:14:58] <strcat> dherman: and yeah, it has to be a struct
[00:15:09] <ChrisMorgan> I'm glad to see that certain cases which were causing arbitrary failures with closure capture are now failing to compile instead.
[00:15:13] <dherman> kk
[00:15:19] <strcat> since we don't have priv tuple constructors or even priv tuple struct fields
[00:15:25] *** Joins: brendan (brendaneic@10487EE8.58B1B661.22B0E380.IP)
[00:15:34] <dherman> strcat: you can't just put the bounds on the struct def'n itself?
[00:15:42] <strcat> dherman: nope, you can't
[00:15:45] <cmr> dherman: http://www.haskell.org/haskellwiki/Data_declaration_with_constraint
[00:15:46] <dherman> ok
[00:15:49] *** Quits: azita (Azita@moz-BBE3ABD.mv.mozilla.com) (Quit: azita)
[00:16:07] <strcat> dherman: it's actually more flexible to have them on the impl, since you can have multiple impls with different bounds
[00:16:18] <dherman> sure
[00:16:21] <strcat> just means you need a silly ::new() function
[00:16:29] <pcwalton> brson: r? https://github.com/mozilla/rust/pull/7894
[00:16:36] <dbaupp> strcat: fwiw, there are a pile of #[deriving] tests in src/test/*/deriving-*.rs
[00:16:37] <strcat> I think you used to be able to put the bounds on the struct, I forget why exactly it was removed
[00:16:39] *** Quits: pnathan (Adium@moz-BDC3EE62.tukw.qwest.net) (Quit: Leaving.)
[00:16:42] *** Joins: ghrust (ghrust@AC22872E.6A2AE50.F3114085.IP)
[00:16:42] <ghrust> 01[13rust01] 15bors merged 06auto into 06master: 02http://git.io/OzP0SA
[00:16:43] *** Parts: ghrust (ghrust@AC22872E.6A2AE50.F3114085.IP) ()
[00:16:44] *** Quits: brendan (brendaneic@10487EE8.58B1B661.22B0E380.IP) (Quit: brendan)
[00:19:45] *** Joins: ghrust (ghrust@5FEF1C87.6A2AE50.F3114085.IP)
[00:19:45] <ghrust> 01[13rust01] 15bors pushed 0 new commits to 06auto: 02http://git.io/jZ5e1Q
[00:19:45] *** Parts: ghrust (ghrust@5FEF1C87.6A2AE50.F3114085.IP) ()
[00:23:32] <dherman> zomg this is fun
[00:25:20] *** Quits: donri (dag@moz-9BB61102.tbcn.telia.com) (Client exited)
[00:25:48] *** Quits: dwhyte (dwhyte@ED9190FB.B72E355F.7BF4A4B0.IP) (Quit: Leaving.)
[00:25:50] <strcat> /home/strcat/projects/rust/src/libstd/iterator.rs:915:4: 928:5 error: method `next_back` has an incompatible type: expected type parameter but found type parameter
[00:25:54] <strcat> I hate these
[00:26:03] <cmr> Hah, I haven't seen that one before.
[00:26:05] <strcat> that has to be rustc's worst error
[00:26:17] <strcat> it happens when lifetimes mismatch but it's so hard to figure out why
[00:26:19] <cmr> I like the "[type error]" ones
[00:27:39] * dbaupp prefers the 'Internal Compiler Error' ones
[00:27:57] <brendanc> heh, I used to get an almost identical error from ocaml
[00:28:07] *** Joins: dwhyte (dwhyte@ED9190FB.B72E355F.7BF4A4B0.IP)
[00:28:11] <aatch> I wonder if rustc will every get something as bad as this PHP error:
[00:28:31] <brendanc> ocaml produces most of my favourite terrible error messages
[00:28:31] <aatch> "Unknown Error on line 0 in "
[00:28:47] <cmr> aatch: nah, we can't have spans on an ICE
[00:28:49] <cmr> :D
[00:29:12] <brendanc> the ocaml version is: This expression has type int but is here used with type int
[00:29:14] <aatch> I've actually gotten that, it's what happens when your error handler has an error.
[00:29:26] <aatch> (I guess it's better than an infinite loop)
[00:29:46] *** Quits: bnicholson (bnicholson@moz-BBE3ABD.mv.mozilla.com) (Ping timeout)
[00:30:23] <aatch> strcat, that should be able to be improved now that type params keep what they were named as (I think)
[00:30:39] <aatch> so after that ^ you get (expected 'T' found 'U')
[00:31:18] *** Joins: Thad (chatzilla@moz-C35F90AE.tx.res.rr.com)
[00:31:34] * strcat doesn't understand why it happens in this case
[00:32:39] <cmr> http://rustlog.octayn.net/post/55824853529/status-update, 'night all
[00:32:56] <cmr> I'll be gone for the weekend, no internet connection, but I'll still be chuggin' away on rustdoc
[00:35:09] <ChrisMorgan> cmr: it'd be good if the "mandating" were clarified; I have not at any point sought a monopoly for Sphinx, merely the possibility of a recommendation of that style
[00:35:13] *** Quits: rusti (rusti@moz-54F7FD49.cpe.net.cable.rogers.com) (Ping timeout)
[00:35:30] *** Quits: strcat (strcat@moz-54F7FD49.cpe.net.cable.rogers.com) (Ping timeout)
[00:35:52] *** Joins: strcat (strcat@moz-54F7FD49.cpe.net.cable.rogers.com)
[00:37:11] <strcat> aatch: oh I had the method signature wrong
[00:37:14] * strcat sighs
[00:37:18] <strcat>     fn next_back(&mut self) -> Option<A> {
[00:37:20] <strcat> instead of
[00:37:24] <strcat>     fn next_back(&mut self) -> Option<B> {
[00:37:31] <strcat> thanks for being so helpful rustc ;p
[00:37:55] <strcat> it'd be nice if it put a span on both locations
[00:38:03] *** Quits: graydon (Adium@A5087023.2354C43D.D8E68FF6.IP) (Quit: Leaving.)
[00:39:19] <pcwalton> anyone else think we should disallow "unsafe" on extern fns as redundant?
[00:39:56] <ChrisMorgan> `impl<'self, T> X for &'self T { fn x(self) {} }`: am I right that that's equivalent to `impl<T> X for T { fn x(&self) {} }`?
[00:40:18] <strcat> pcwalton: yes
[00:40:33] <pcwalton> ok, I'll make a note of it to bring up
[00:40:37] <strcat> pcwalton: and add #[safe] to explicitly mark them as safe if they don't need a wrapper
[00:40:46] <strcat> I forget if I reported that
[00:42:21] <pcwalton> did we have consensus to get rid of *mut?
[00:42:44] <ChrisMorgan> Bah, generic kind constraints are now not working for impl blocks. Well, they may not have worked properly before, but it'd compile and run fine. Now it refuses to compile, which stops my code from working altogether.
[00:43:18] <dbaupp> ChrisMorgan: code?
[00:43:22] <jensnockert> pcwalton: Yes.
[00:43:30] <pcwalton> ok, I'll add that to the list
[00:43:38] <jensnockert> pcwalton: As in, I think we should disallow unsafe on extern fns.
[00:43:44] <pcwalton> oh
[00:44:02] <dbaupp> ChrisMorgan: oh, the code above?
[00:44:12] <jensnockert> pcwalton: Would *T replace *mut T?
[00:44:19] <pcwalton> yerah
[00:44:19] <pcwalton> yeah
[00:44:29] <ChrisMorgan> dbaupp: the likes of this: `pub trait Server { pub fn handle_request(&self); } pub trait ServerUtil { pub fn serve_forever(self); } impl<'self, T: Send + Server> ServerUtil for &'self T { pub fn serve_forever(self) { do spawn { self.handle_request(); } } } fn main(){}`
[00:44:31] <dbaupp> ChrisMorgan: they're not equivalent, the first only works on (&T).foo(), the second on T.foo()
[00:44:44] <ChrisMorgan> Compile error: "cannot capture variable of type `&'self T`, which does not fulfill `Send`, in a bounded closure"
[00:44:45] <dbaupp> ChrisMorgan: default methods!
[00:44:53] <SiegeLord> What's the issue with *mut?
[00:45:05] <dbaupp> ChrisMorgan: and yeah, &'self T isn't send
[00:45:34] <dbaupp> Can only send &'static across tasks, as the owning task (for non-'static) could die at any moment
[00:45:36] <ChrisMorgan> True enough, I suppose. I had it as not a pointer before, that was failing too; let me go back to that...
[00:46:14] <ChrisMorgan> dbaupp: by default methods, you mean `pub trait Server: Send { ...; pub fn serve_forever(self) { do spawn { self.handle_request(); } } }`?
[00:46:14] <dbaupp> pcwalton: wouldn't merging *mut u8 & *u8 restrict how much aliasing info we can give to LLVM?
[00:46:21] <dbaupp> ChrisMorgan: yep
[00:46:23] <ChrisMorgan> dbaupp: https://github.com/mozilla/rust/issues/7661
[00:46:24] *** Quits: maxli (maxli@B5559308.9C54E60.2FA4EA88.IP) (Quit: Leaving.)
[00:46:25] *** Quits: MaikKlein (maik@moz-4CFF4604.dip0.t-ipconnect.de) (Ping timeout)
[00:46:25] <pcwalton> I don't think so, because *mut is aliasable
[00:46:44] <dbaupp> I mean *u8 is "unaliasable"
[00:46:56] <pcwalton> unaliasable?
[00:46:59] <ChrisMorgan> That's why I went to the *Util pattern, because it didn't work.
[00:47:01] <dbaupp> but thinking about it, it's not, because `as` safely const_casts
[00:47:15] <pcwalton> *u8 means "const *uint8_t"
[00:47:22] <pcwalton> not "restrict *uint8_t"
[00:47:26] <dbaupp> pcwalton: in LLVM's terminology readonly things don't alias even if they point to the same thing.
[00:47:41] <dbaupp> (iirc, from what strcat has said.)
[00:48:10] <dbaupp> ChrisMorgan: oh :(
[00:48:30] *** Joins: Yurume_ (yurume@AC58A8CE.8A059B47.E313B915.IP)
[00:48:35] *** Joins: bnicholson (bnicholson@moz-E98974C1.hsd1.ca.comcast.net)
[00:49:59] <ChrisMorgan> An example much closer to what I'm doing is: `pub trait Server { pub fn handle_request(&self); } pub trait ServerUtil { pub fn serve_forever(self); } impl<T: Send + Server> ServerUtil for T { pub fn serve_forever(self) { loop { self.handle_request(); do spawn { self.handle_request(); } } } }`
[00:50:00] <strcat> pcwalton: LLVM's aliasing info is based on memory dependencies though, not pointer equality
[00:50:23] <strcat> if a and b point to memory and neither of them can ever modify it in a way the other can observe, they're NoAlias
[00:50:29] <ChrisMorgan> This fails to compile, complaining of "use of moved value: `self`".
[00:50:51] <ChrisMorgan> That I understand. All I'm now pondering is: how can I work around it?
[00:50:55] <dbaupp> ChrisMorgan: yeah, self gets moved into the loop
[00:51:04] <dbaupp> *the spawn
[00:51:07] <strcat> pcwalton: but we have 2000 cases of mutating through &T or *T where T is Freeze using unsafe code :(
[00:51:18] *** Joins: tikue (tkuehn@moz-BBE3ABD.mv.mozilla.com)
[00:51:21] <dbaupp> ChrisMorgan: do spawn { loop { handle_request } }?
[00:51:22] <strcat> most of the libc function defs are wrong
[00:51:22] <pcwalton> that's a good argument for getting rid of *T IMO
[00:51:29] <pcwalton> just make *T always mutable
[00:51:45] <ChrisMorgan> dbaupp: no good, need to spawn a new task for each request so that they don't block one another.
[00:51:49] <pcwalton> nobody gets it right, people think of *T as "always mutable" anyway
[00:51:52] <dbaupp> ChrisMorgan: oh!
[00:52:00] <dbaupp> ChrisMorgan: you'll need to clone it into the task then
[00:52:08] <strcat> pcwalton: they'll get it wrong higher up though
[00:52:15] <strcat> pcwalton: because & coerces to *, &mut coerces to *mut
[00:52:15] *** Joins: rusti (rusti@moz-54F7FD49.cpe.net.cable.rogers.com)
[00:53:12] *** Quits: eatkinson (eatkinson@moz-BBE3ABD.mv.mozilla.com) (Quit: eatkinson)
[00:53:22] <strcat> pcwalton: ideally I think rustc would use libclang to read headers itself
[00:53:28] *** Joins: eatkinson (eatkinson@moz-BBE3ABD.mv.mozilla.com)
[00:53:30] *** Quits: eatkinson (eatkinson@moz-BBE3ABD.mv.mozilla.com) (Quit: eatkinson)
[00:53:31] <strcat> you wouldn't have to make extern sections at all yourself
[00:53:59] *** Quits: tcsc (tcsc@moz-ADC0ED45.hsd1.ct.comcast.net) (Quit: computer sleeping)
[00:54:09] <strcat> and it would turn int * to *mut int
[00:54:23] <ChrisMorgan> dbaupp: that'd mean adding the kind constraint Clone to the impl block and having something like `let self_clone = self.clone()` before the `spawn` and using `self_clone` instead of `self` inside the `spawn`, right?
[00:54:42] <dherman> has anyone noticed how great rust is?
[00:54:56] *** Quits: jdm (jdm@92FB48CA.8B5E9DF.9A8C35B4.IP) (Quit: Lost terminal)
[00:55:25] * ChrisMorgan has
[00:56:03] <jensnockert> rusti: struct Vec2(f32, f32);
[00:56:04] -rusti- ()
[00:57:52] <ChrisMorgan> Then at present I would need #[deriving(Clone)] on my structs that will be implementing Server, right?
[00:58:20] <dbaupp> dherman: that's already been decided! https://github.com/mozilla/rust/wiki/Meeting-weekly-2013-05-21#let-it-be-known-rust-is-super-great :P
[00:58:38] *** Joins: bjz (brendanzab@B398BE78.F804C29E.D35A31DF.IP)
[00:58:46] <dbaupp> ChrisMorgan: yeah, essentially (although you might need custom Clone logic.)
[00:59:01] <ChrisMorgan> server.rs:155:11: 155:16 error: mismatched types: expected `server::Config` but found `&server::Config` (expected struct server::Config but found &-ptr)
[00:59:01] <ChrisMorgan> server.rs:155 #[deriving(Clone)]                           ("Clone" is indicated with the ^~~~~")
[00:59:23] <ChrisMorgan> That, for `#[deriving(Clone)] pub struct SimpleServer { config: Config, handler: ~fn(&Request, &mut ResponseWriter), }`
[00:59:56] <dbaupp> Config doesn't have a Clone impl
[00:59:58] *** Joins: z0w0 (zack@A76ECE44.E8D776F0.D76C0449.IP)
[01:00:11] <dbaupp> (I guess ~fn won't have one either... :S )
[01:00:19] *** Quits: ecr1 (Thunderbir@moz-BBE3ABD.mv.mozilla.com) (Quit: ecr1)
[01:00:28] <dherman> dbaupp: :)
[01:00:45] *** Quits: eschweic1 (Adium@moz-BBE3ABD.mv.mozilla.com) (Quit: Leaving.)
[01:00:52] <dherman> dbaupp: mea culpa, failed to adequately cite prior art
[01:00:57] <ChrisMorgan> Why such a poor error message? Why not "can't derive Clone, server::Config does not satisfy Clone"?
[01:01:16] <dbaupp> dherman: don't worry, it is an acceptable mistake :)
[01:01:31] <dbaupp> ChrisMorgan: because syntax extensions don't have access to type information
[01:02:09] <ChrisMorgan> Bah... Config contains IpAddr, which doesn't derive Clone... *sigh*
[01:02:13] <dbaupp> ChrisMorgan: I've considered adding a mechanism for specifying custom error messages, but I've never even got around to experimenting.
[01:02:29] <dbaupp> ChrisMorgan: you could just throw it in an ARC for now
[01:03:10] <ChrisMorgan> I should let this automatically-derive-clone-unless-otherwise-specified business be sorted out.
[01:03:30] <ChrisMorgan> Should ~fn satisfy Clone?
[01:05:39] <ChrisMorgan> (I know it doesn't at present, but hopefully it should?)
[01:05:44] <dbaupp> You might need ~fn:Clone
[01:06:01] <dbaupp> which says that the environment is Clone... I've got no idea if it works.
[01:06:28] <ChrisMorgan> "only the builtin traits can be used as closure or object bounds"
[01:06:32] <dbaupp> :(
[01:06:50] <dbaupp> yup.. it looks like ARC is your only choice.
[01:07:10] <dbaupp> (extra::arc, btw.)
[01:08:26] *** Quits: erickt (erickt@8C9ECD8F.3A598286.F12515B4.IP) (Quit: Leaving.)
[01:13:28] *** Quits: BitPuffin (quassel@moz-7C12CE89.cust.tele2.se) (Ping timeout)
[01:16:19] *** Joins: int3_ (int3_@moz-ABE52D50.hsd1.ca.comcast.net)
[01:18:46] *** Joins: samx (sami@moz-48EC0983.dyn.optonline.net)
[01:22:53] *** Quits: SiegeLord (sl@moz-CAF07B4C.hsd1.ma.comcast.net) (Quit: It's a joke, it's all a joke.)
[01:22:55] <jensnockert> Is there any plans on normalizing the indent in librustc at some point? Should I use 2 or 4?
[01:23:10] <pcwalton> use 4
[01:23:28] <pcwalton> I slowly try to update but probably a giant refactoring will have to wait on a rewrite of rustfmt
[01:23:45] *** Joins: MaikKlein (maik@moz-4CFF4604.dip0.t-ipconnect.de)
[01:23:48] <jensnockert> <3
[01:24:07] <ChrisMorgan> dbaupp: how precisely do I use it? extra::arc::ARC requires Freeze, which ~fn doesn't seem to satisfy...
[01:24:13] *** Quits: Jesin (Jessin_@moz-1B1307FF.eecs.lehigh.edu) (Ping timeout)
[01:24:21] <pcwalton> ChrisMorgan: you can always use a factory function
[01:24:25] <pcwalton> a function that returns new ~fns
[01:24:29] <dbaupp> Yeah, the pretty printer seems to be waaaay too happy to indent... libstd builds up >500 spaces at the start.
[01:24:36] <dbaupp> (of each line)
[01:24:46] <ChrisMorgan> pcwalton: ?
[01:25:02] <dbaupp> ChrisMorgan: ~fn() -> ~fn(...)
[01:25:14] <pcwalton> really the way I would like to fix it
[01:25:15] <jensnockert> dbaupp: Isn't that just indent blocks not being closed though?
[01:25:26] <dbaupp> jensnockert: no idea
[01:25:26] <pcwalton> is to replace ~fn with a Thunk trait and a ClonableThunk trait
[01:25:31] <engla> dbaupp: some things like empty impl blocks are buggy
[01:25:32] *** Quits: mschifer (Adium@moz-BE33DA21.fw1.sfo1.mozilla.net) (Quit: Leaving.)
[01:25:32] <pcwalton> and have macros to autogenerate them
[01:25:38] <ChrisMorgan> I don't see how that pattern would be applicable.
[01:25:41] <dbaupp> engla: haha
[01:25:51] <dbaupp> ChrisMorgan: do you need it to be a closure?
[01:25:56] *** Quits: samx (sami@moz-48EC0983.dyn.optonline.net) (Quit: This computer has gone to sleep)
[01:26:01] <dbaupp> engla: "some things"
[01:26:05] <dbaupp> :P
[01:26:08] <ChrisMorgan> This SimpleServer is really just a convenience; it doesn't actually need to exist.
[01:26:19] <engla> dbaupp: impl X for T {};   transformed to  impl X for T; without dedent
[01:26:24] <pcwalton> ~Thunk and ~ClonableThunk will make this way easier
[01:26:30] <pcwalton> I hope to get to them soon
[01:26:50] <engla> some things? ah you mean lots of things
[01:26:50] <dbaupp> engla: yeah, and `& & foo` becomes `&&foo`, which doesn't even parse
[01:27:20] <pcwalton> dbaupp: feel free to file a bug on that, we have pretty printer tests for things like that
[01:27:27] <dbaupp> ChrisMorgan: (Maybe remove SimpleServer until things get more reasonable.)
[01:27:36] <pcwalton> but honestly I think rustfmt needs a rewrite to be modernized and handle macros right
[01:27:59] <ChrisMorgan> It lets you do `do serve_forever(Ipv4(0, 0, 0, 0, 80)) |r, w| { ... }` instead of `struct MyServer; impl Server for MyServer { fn get_config(&self) -> Config { Config { bind_address: Ipv4(0, 0, 0, 0, 80) } } fn handle_request(&self, r: &Request, w: &mut ResponseWriter) { ... } }`.
[01:28:01] <dbaupp> pcwalton: oh pprinter bugs are relevant? (I hadn't bothered filing it because I assumed it would have to have huge changes.)
[01:28:12] <pcwalton> dbaupp: might as well have them on file
[01:28:19] <dbaupp> ChrisMorgan: yeah, that is nicer
[01:28:47] <ChrisMorgan> Whoops, the latter would then require `MyServer.serve_forever()` too.
[01:29:22] <pcwalton> struct ClonableThunk<Args,Return> { fn run(a: Args) -> Return; fn clone_thunk(&self) -> ~ClonableThunk<Args,Return>; }
[01:29:26] <pcwalton> err, sorry
[01:29:30] <pcwalton> trait ClonableThunk<Args,Return> { fn run(a: Args) -> Return; fn clone_thunk(&self) -> ~ClonableThunk<Args,Return>; }
[01:29:52] *** Joins: vk (chatzilla@66D44E2E.B568D26C.93B001FA.IP)
[01:30:03] *** Quits: int3_ (int3_@moz-ABE52D50.hsd1.ca.comcast.net) (Client exited)
[01:30:03] <ChrisMorgan> OK, I'm going to remove SimpleServer altogether for the moment.
[01:30:17] <pcwalton> this lets you override clone_thunk() if you want special behavior which is overall nicer IMHO
[01:30:25] <pcwalton> or just use the macro to autogenerate it
[01:31:27] <dbaupp> (filed! https://github.com/mozilla/rust/issues/7895, I assume the pretty tag is for the pretty printer?)
[01:31:53] <dherman> I never get to actually write rust code. this is so freaking much fun
[01:32:06] * dherman snorts like a pig in slop
[01:32:25] *** Quits: tav (tav@moz-5ED3AF3C.range86-152.btcentralplus.com) (Ping timeout)
[01:32:30] *** Joins: int3_ (int3_@moz-ABE52D50.hsd1.ca.comcast.net)
[01:33:29] *** Joins: SiegeLord (sl@moz-CAF07B4C.hsd1.ma.comcast.net)
[01:34:18] *** Joins: samx (sami@moz-48EC0983.dyn.optonline.net)
[01:34:36] *** Quits: strcat (strcat@moz-54F7FD49.cpe.net.cable.rogers.com) (Ping timeout)
[01:34:47] *** Quits: rusti (rusti@moz-54F7FD49.cpe.net.cable.rogers.com) (Ping timeout)
[01:34:55] *** Joins: tav (tav@moz-8C73145.range86-166.btcentralplus.com)
[01:35:21] *** Joins: gavinb (gavinb@moz-CA19A0CF.vic.adsl.internode.on.net)
[01:35:40] *** Quits: zslayton (Mibbit@moz-14AA87A9.nyc.res.rr.com) (Quit: http://www.mibbit.com ajax IRC Client)
[01:36:14] <Thad> OMG, this thing is actually compiling on Windows now ?  Did someone fix it ?  aatch ?
[01:36:16] * ChrisMorgan decides to remove his oldrt adapter as too great a maintenance burden
[01:36:32] *** Joins: pnathan (Adium@B9840254.2CD8A5F8.477B877D.IP)
[01:36:43] <dbaupp> ChrisMorgan: where you using extra::net?
[01:36:52] <dbaupp> *were
[01:37:11] *** Joins: strcat (strcat@moz-54F7FD49.cpe.net.cable.rogers.com)
[01:37:13] *** Quits: hjr3 (hradtke@374E545A.3A8E9B0C.F9D9C60E.IP) (Quit: My MacBook has gone to sleep. ZZZzzzâ€¦)
[01:37:28] <ChrisMorgan> I had code in to use it through this adapter, but I had stopped using it. Now it won't build, so it's easier to just throw it away and go with std::rt::io::net altogether.
[01:37:42] *** Quits: carllerche (carllerche@6B070D22.7E6A0813.1428D117.IP) (Quit: carllerche)
[01:37:47] <dbaupp> yeah, good timing https://github.com/mozilla/rust/pull/7883
[01:38:30] *** Quits: themgt (themgt@moz-7834B2B9.cm.vtr.net) (Ping timeout)
[01:38:34] *** Joins: erickt (erickt@8C9ECD8F.3A598286.F12515B4.IP)
[01:38:40] *** Quits: int3_ (int3_@moz-ABE52D50.hsd1.ca.comcast.net) (Client exited)
[01:38:51] <ChrisMorgan> Oh, good.
[01:38:57] <ChrisMorgan> Justifies my throwing it away :-)
[01:39:54] *** Joins: azita (Azita@moz-BBE3ABD.mv.mozilla.com)
[01:40:21] *** Quits: erickt (erickt@8C9ECD8F.3A598286.F12515B4.IP) (Ping timeout)
[01:40:36] *** Joins: themgt (themgt@moz-7834B2B9.cm.vtr.net)
[01:42:37] *** Quits: pnathan (Adium@B9840254.2CD8A5F8.477B877D.IP) (Ping timeout)
[01:42:48] <ChrisMorgan> Is ~fn() expected to satisfy Clone in the future?
[01:43:11] <MaikKlein> haha i see rust took some inspiration from ruby :) ?
[01:43:33] <dbaupp> ChrisMorgan: not by default, I assume
[01:43:58] <dbaupp> ChrisMorgan: but hopefully the ~fn:Clone thing will work
[01:44:16] <strcat> Clone would need to be a lang item
[01:44:26] *** Joins: cowboyd (cowboyd@moz-DD0FF83.lightspeed.austtx.sbcglobal.net)
[01:45:00] <dbaupp> strcat: why?
[01:45:07] <strcat> so ~fn could call it?
[01:45:13] <strcat> you can't write an impl on ~fn
[01:45:19] <strcat> we don't have variadic generics
[01:45:21] <dbaupp> oh, right, yes.
[01:45:35] <pcwalton> dbaupp: ChrisMorgan: ~fn is slated to be removed
[01:45:38] <pcwalton> in favor of thunks
[01:45:50] <strcat> dbaupp: http://ix.io/6Jq :)
[01:45:53] <dbaupp> and those will work with traits?
[01:46:02] <pcwalton> thunks will be traits and will have clonable versions
[01:46:04] <dbaupp> strcat: that's pretty cool!
[01:46:06] <pcwalton> so you can clone them all you want
[01:46:11] <pcwalton> and even write custom clone implementations
[01:46:25] <dbaupp> awesome!
[01:46:27] <pcwalton> and they'll have macros so they're nearly as convenient today
[01:46:29] <pcwalton> as today
[01:46:33] <pcwalton> you'll have to name your captures
[01:46:41] <dbaupp> strcat: filter/map, too?
[01:46:48] <pcwalton> but I personally like that better anyway since I find implicit moves into closures confusing
[01:47:00] <strcat> dbaupp: filter/map/filter_map/chain
[01:47:05] <strcat> work for double-ended now
[01:47:17] <strcat> like, if the iterator passed in is double-ended, they are too
[01:47:51] <strcat> just need to write tests for the others
[01:47:53] <dbaupp> pcwalton: yeah, that sounds good!
[01:48:02] <dbaupp> strcat: awesome!
[01:48:17] <dbaupp> strcat: the next will be RandomAccessIterator?
[01:48:22] <strcat> dbaupp: dunno
[01:48:28] <dbaupp> haha
[01:48:41] <strcat> only vec/deque can implement it
[01:48:47] <pcwalton> we don't have quite as much need for them as D because we already have slices
[01:48:50] <pcwalton> non-generic, but still.
[01:49:08] <pcwalton> our slices are already non-generic random access ranges
[01:49:13] *** Joins: zippity (Mibbit@moz-3269D7E9.hsd1.il.comcast.net)
[01:49:15] <dbaupp> strcat: what about vec-rope, or something?
[01:49:18] <strcat> true
[01:49:22] <strcat> rope-based vectors
[01:49:27] <strcat> or persistent vectors
[01:49:31] <aatch> That, what was the problem before
[01:49:32] <aatch> ?
[01:49:32] <strcat> since I think those aren't contiguous
[01:49:38] <dbaupp> pcwalton: right, although they only work for contiguous memory
[01:50:19] <ChrisMorgan> dbaupp: OK, you have pleaded enough. My code is currently at http://hg.chrismorgan.info/rusthttpserver (it probably won't remain there, but that'll do for now)
[01:50:20] *** Quits: mib_roswqx (Mibbit@84E199D6.DCDBCF8E.83D0DF30.IP) (Quit: http://www.mibbit.com ajax IRC Client)
[01:50:44] <SiegeLord> What's different between D's slices and Rust's slices that makes the latter so much more powerful?
[01:50:59] <strcat> dbaupp: oh and peek
[01:51:09] *** Joins: rusti (rusti@moz-54F7FD49.cpe.net.cable.rogers.com)
[01:51:18] <ChrisMorgan> dbaupp: http://hg.chrismorgan.info/rusthttpserver/file/474afbdcca61/src/ws3.rs is the example code. (ws2.rs is out of date, won't run.)
[01:51:22] <dbaupp> SiegeLord: contiguous memory vs not, I guess.
[01:51:38] <strcat> SiegeLord: D's slices are gc'ed
[01:51:46] <gavinb> I've start to implement a repeat() iterator. The idea is just to return the original iterator's values forever, looping around when it reaches the end. It copies the original iterator to capture its state and when it reaches the end of the iterator, re-copies the original one and starts again. I could do with some help on getting it finished thoughâ€¦ 
[01:51:47] <strcat> ranges are separate
[01:51:50] * dbaupp thinks ChrisMorgan should use github to get the syntax highlighting ;P
[01:51:53] <SiegeLord> I thought rust's slices are &[]
[01:52:05] <strcat> yes, rust doesn't have what D's slices are
[01:52:31] <SiegeLord> Ok, but &[] is exactly a D's slice
[01:52:35] <strcat> it's not
[01:52:43] <strcat> it's exactly like a D RandomAccessRange
[01:52:48] *** Joins: carter (carter@moz-12C317EF.nyc.res.rr.com)
[01:52:48] <dbaupp> ChrisMorgan: "X-Pad": "Avoid browser bug"?
[01:53:08] <ChrisMorgan> dbaupp: just a copy of the default response a blank Apache instance will give.
[01:53:12] <SiegeLord> So &[] can have non-contiguous memory? I thought it was a pointer + length
[01:53:19] <ChrisMorgan> Yeah, it really has that header.
[01:53:20] <dbaupp> strcat, SiegeLord: (except Rust's are restricted to contiguous memory)
[01:53:26] <strcat> SiegeLord: it's an *implementation* of RandomAccessRange
[01:53:29] <dbaupp> SiegeLord: right
[01:53:36] <dbaupp> ChrisMorgan: how peculiar!
[01:53:38] <SiegeLord> So what's the difference then?
[01:53:41] <strcat> it is the same as the array implementation of RandomAccessRange in D
[01:53:43] <ChrisMorgan> See http://stackoverflow.com/questions/8711584/x-pad-avoid-browser-bug-header-added-by-apache#8711640
[01:53:51] <strcat> SiegeLord: RandomAccessRange is a generic concept
[01:53:57] <strcat> rust's slices don't implement a trait
[01:54:08] *** Quits: vk (chatzilla@66D44E2E.B568D26C.93B001FA.IP) (Quit: ChatZilla 0.9.90.1 [Firefox 23.0/20130715155216])
[01:54:09] <SiegeLord> I am talking about Rust's slices and D's slices
[01:54:13] <SiegeLord> Both are pointer + length
[01:54:13] <strcat> different
[01:54:18] <strcat> D's slices are gc'ed
[01:54:26] <SiegeLord> Not always
[01:54:30] <dbaupp> ChrisMorgan: it looks nice!
[01:54:44] <dbaupp> (that example at least :) )
[01:54:44] <strcat> SiegeLord: afaik they always are
[01:54:48] <SiegeLord> stack_, Nope
[01:54:56] <SiegeLord> Whoops, sorry stack_
[01:55:06] <SiegeLord> You can do malloc(100)[0..100]
[01:55:09] <SiegeLord> That won't be GC'd
[01:55:39] <ChrisMorgan> dbaupp: as you can see, it's not intelligent yet; it doesn't support keep-alive, nor transfer codings (essential to keep-alive: you need to specify either a Content-Length or use the chunked coding, so that it knows when you get to the end of the file), nor does it provide things for handling caches or cookies well.
[01:55:41] <dbaupp> ChrisMorgan: that is a very strange workaround, haaha
[01:55:51] *** Quits: tjc (tjc@moz-15A42B79.lightspeed.sntcca.sbcglobal.net) (Quit: zzzzzzzzzz)
[01:55:54] <ChrisMorgan> But the foundation is there and it's sound.
[01:56:04] <dbaupp> yeah, well you've only been working on it for a week or so
[01:56:06] <ChrisMorgan> dbaupp: which one?
[01:56:12] <dbaupp> ChrisMorgan: X-Pad
[01:56:24] <ChrisMorgan> ... and learning Rust along the way.
[01:56:31] <SiegeLord> Anyway, it's a strange statement to me that Rust's slices avoid the need for a RandomAccessRange... D had slices for years before Andrei showed up, and he still added it :P
[01:56:36] <dbaupp> ChrisMorgan: yeah, exactly
[01:56:57] <ChrisMorgan> And figuring out certain details of how HTTP/1.1 works that I didn't know before. :-)
[01:56:57] <dbaupp> ChrisMorgan: and fighting bugs
[01:57:04] <strcat> SiegeLord: they don't avoid the need for it
[01:57:05] <ChrisMorgan> And reporting them!
[01:57:10] <ChrisMorgan> All fun :-)
[01:57:10] <strcat> SiegeLord: we didn't say they did
[01:57:11] <dbaupp> ChrisMorgan: and fighting libraries!
[01:57:29] <SiegeLord> strcat, <pcwalton> we don't have quite as much need for them as D because we already have slices
[01:57:29] <strcat> SiegeLord: rust's slices are equivalent to D's vector *implementation* of RandomAccessRange
[01:57:39] <dherman> pcwalton: what is the name you like to use for "anonymous trait impls" again?
[01:57:40] <strcat> SiegeLord: they are an implementation of RandomAccessRange
[01:57:43] <strcat> the only thing missing is the trait
[01:58:05] <strcat> we could get rid of VecIterator and use slices instead
[01:58:05] <SiegeLord> So's D's slices
[01:58:11] <SiegeLord> Back in D1
[01:58:13] <ChrisMorgan> There are also a few slabs of stuff from Go's net/http or RFC 2616 which need to be removed.
[01:58:15] <bjz> dherman: Type impls, I think?
[01:58:17] <SiegeLord> Where there was no RandomAccessRange
[01:58:23] <dherman> ah ok
[01:58:26] <dherman> bjz: thx
[01:58:34] <bjz> dherman: coulf be wrong though
[01:58:37] <bjz> *could
[01:58:40] <ChrisMorgan> dbaupp: what do you think of the technique used in librusthttpserver/status.rs?
[01:58:43] <bjz> but that makes sense
[01:58:47] <dherman> can type impls have module-private methods?
[01:58:55] <bjz> yup
[01:58:57] <strcat> SiegeLord: RandomAccessRange wouldn't be a *type*
[01:58:59] <strcat> it would be a trait
[01:59:05] <dherman> omit pub, or priv?
[01:59:09] <strcat> the *implementation* of that trait can be the existing slices
[01:59:15] <strcat> adding the trait wouldn't do anything for vectors
[01:59:19] <SiegeLord> strcat, It's not a type in D either
[01:59:22] <strcat> and we don't have many other random access containers
[01:59:29] <dbaupp> ChrisMorgan: which particular technique?
[01:59:52] <dbaupp> ChrisMorgan: the bit where you use a u8 for something that could be larger than 256? :P
[02:00:01] <dherman> bjz: oh nvm I cant use that here anyway
[02:00:05] <bjz> rusti: struct Foo; impl Foo { fn a() {} pub fn b() priv fn c() {} }
[02:00:05] -rusti- <anon>:7:53: 7:57 error: expected `{` but found `priv`
[02:00:06] -rusti- <anon>:7          struct Foo; impl Foo { fn a() {} pub fn b() priv fn c() {} }
[02:00:06] -rusti-                                                               ^~~~
[02:00:06] -rusti- application terminated with error code 101
[02:00:13] <dbaupp> bjz: priv by default
[02:00:15] <bjz> rusti: struct Foo; impl Foo { fn a() {} pub fn b() {} priv fn c() {} }
[02:00:17] -rusti- ()
[02:00:17] <strcat> SiegeLord: I'm just saying it wouldn't add anything useful for vectors that we don't already have
[02:00:30] <gavinb> Can I get some feedback on this attempt at a repeat() iterator? https://gist.github.com/gavinb/6034521
[02:00:35] <strcat> it would allow you to write generic functions working on either a vector or extra::deque, that's all
[02:00:55] <dbaupp> (and other types too!)
[02:00:57] <bjz> dherman: as dbaupp says, priv by default
[02:01:05] <dherman> bjz: got it thx
[02:01:05] <ChrisMorgan> dbaupp: hmm... not that bit :-/
[02:01:15] <dbaupp> ChrisMorgan: haha :P
[02:01:23] <SiegeLord> I don't disagree with that... I'm saying that Rust's slices are not the reason why it doesn't need RandomAccessRange
[02:01:36] <bjz> dherman: preparing for the presentation?
[02:01:42] *** Joins: tcr (tcr@D26BCFC9.C2203064.EDCE493E.IP)
[02:01:44] <ChrisMorgan> That way of having an enum. The alternative is having a two-element struct with statics defined.
[02:01:45] *** Joins: ghrust (ghrust@FD7BC443.6A2AE50.F3114085.IP)
[02:01:45] <ghrust> 01[13rust01] 15bors merged 06auto into 06master: 02http://git.io/kYOe4Q
[02:01:45] *** Parts: ghrust (ghrust@FD7BC443.6A2AE50.F3114085.IP) ()
[02:01:56] <SiegeLord> Because D had slices for years and it still eventually got RandomAccessRange
[02:02:06] <strcat> SiegeLord: no one is saying it doesn't need RandomAccessRange though
[02:02:09] <engla> gavinb: I've submitted a very similar one today (but using Clone). The implementation looks just the same
[02:02:14] <strcat> just that it wouldn't really be useful right now
[02:02:37] <SiegeLord> strcat, Which has nothing to do with slices, but because you have no other random access containers
[02:02:39] <dbaupp> ChrisMorgan: I think the enum is better
[02:03:30] <gavinb> engla: oh cool, ok! I look forward to using it then. I was trying to port some code from Haskell and thought it would be useful.
[02:03:35] <dbaupp> ChrisMorgan: although, `enum DefinedStatus { .. } enum Status { Defined(DefinedStatus), Unrecognised(u16, ~str) }` might be useful (very) occasionally
[02:03:37] <strcat> slices could be the Iterator/DoubleEndedIterator/RandomAccessIterator implementation
[02:03:40] <engla> gavinb: https://github.com/mozilla/rust/pull/7882  first commit
[02:03:42] <dherman> bjz: yup
[02:03:42] <strcat> we could abandon VecIterator
[02:03:52] <gavinb> engla: I am having issues with copy, didn't know about Clone.
[02:03:56] <strcat> it would just mean switching the slice representation a bit
[02:04:00] <dherman> bjz: programming slowly w/ one hand, entertaining infant w/ other
[02:04:06] <strcat> gavinb: copy/Copy was removed
[02:04:06] <dbaupp> ChrisMorgan: on balance I'd go with what you have now until you need that alternative one
[02:04:14] <bjz> dbaupp: :)
[02:04:21] <dbaupp> ChrisMorgan: (if you need it)
[02:04:24] <dbaupp> bjz: ?
[02:04:31] <bjz> dbaupp: ?
[02:04:36] <bjz> oh
[02:04:37] <engla> gavinb: Clone is going to replace copy for all use cases, but it's complicated until all needed impls of Clone are sorted out
[02:04:44] *** Joins: ghrust (ghrust@CFE85B59.6A2AE50.F3114085.IP)
[02:04:44] <ghrust> 01[13rust01] 15bors pushed 0 new commits to 06auto: 02http://git.io/zVQEjw
[02:04:44] *** Parts: ghrust (ghrust@CFE85B59.6A2AE50.F3114085.IP) ()
[02:04:45] <dbaupp> bjz: haha
[02:04:45] <strcat> although I don't know if we need an output 'iterator'
[02:04:46] *** Joins: ghrust (ghrust@24260B07.6A2AE50.F3114085.IP)
[02:04:46] <ghrust> 01[13rust01] 15bors pushed 2 new commits to 06auto: 02http://git.io/PZZrzQ
[02:04:46] <ghrust> 13rust/06auto 14ffaafb2 15Brian Anderson: std::rt: Use a constant 4 threads for multithreaded sched tests. #7772...
[02:04:46] <ghrust> 13rust/06auto 146534f23 15bors: auto merge of #7855 : brson/rust/rt-overcommit, r=pcwalton...
[02:04:46] *** Parts: ghrust (ghrust@24260B07.6A2AE50.F3114085.IP) ()
[02:04:49] *** Joins: moslemmas (moslemmasr@20F2B8C5.7093D426.563BE9DB.IP)
[02:04:50] <strcat> it wouldn't really make sense
[02:04:53] *** Quits: moslemmas (moslemmasr@20F2B8C5.7093D426.563BE9DB.IP) (User has been banned from Mozilla (abuse))
[02:04:57] *** Quits: alex-abreu (alex@moz-7421D6C9.mc.videotron.ca) (Ping timeout)
[02:04:58] <bjz> dbaupp: smiley aimed at dherman and infant
[02:05:03] <pcwalton> engla: gavinb: that's already happened in master
[02:05:05] <pcwalton> Copy is gone
[02:05:14] <engla> yep
[02:05:21] <gavinb> Wow, master moves fast! :)
[02:05:39] <gavinb> Off I go to fetch again!
[02:05:45] <ChrisMorgan> dbaupp: there, using u16 rather than u8 now.
[02:05:46] <engla> Clone is still a WIP. things have to settle now that Copy is gone
[02:06:05] <ChrisMorgan> I use much the same enum technique in method.rs.
[02:06:23] <ChrisMorgan> s/method/methods/
[02:06:26] *** Quits: azita (Azita@moz-BBE3ABD.mv.mozilla.com) (Quit: azita)
[02:06:26] <strcat> hm
[02:06:34] <ChrisMorgan> Actually, what should my plurality be with all of these module names?
[02:06:49] <strcat> pcwalton: another thing RandomAccessIterator would allow is chaining several random access things and then indexing as a single block
[02:07:34] <dbaupp> ChrisMorgan: whatever you want!
[02:07:37] <strcat> let mut it = xs.iter().chain(ys.iter()); it.sort();
[02:07:40] <strcat> well, mut_iter()
[02:07:58] <strcat> and a reverse sort would just use mut_rev_iter()
[02:07:59] *** Quits: brson (brson@moz-BBE3ABD.mv.mozilla.com) (Ping timeout)
[02:08:01] <dbaupp> ChrisMorgan: they'll get used like `method(s)::Get`, and I guess `method::Get` looks nicer?
[02:08:19] <pcwalton> strcat: ah, yeah
[02:08:21] <Eridius> rusti: let a = [1,2,3,4,5]; for a.chunk_iter(2).advance |x| { println(fmt!("%?", x)) }
[02:08:23] -rusti- &[1, 2]
[02:08:23] -rusti- &[3, 4]
[02:08:23] -rusti- &[5]
[02:08:24] -rusti- ()
[02:08:26] <dbaupp> strcat: that would be amazing!
[02:08:40] * dbaupp wants magical cross-slice sorting
[02:08:51] * ChrisMorgan already prefers the feel of his HTTP server to Go's, which uses things like int for status code, sorting out the "reason" internally from that
[02:09:14] <dbaupp> ChrisMorgan: yuck! does Go not have enums like Rust?
[02:09:27] <strcat> dbaupp: no they don't have sum types
[02:09:36] <pcwalton> it doesn't, it has ints and an iota shorthand in consts
[02:09:39] <strcat> they just use dynamic typing with interface{}
[02:09:43] <strcat> for something like that
[02:09:47] <strcat> and reflection to get the type back out
[02:09:51] <ChrisMorgan> Yeah, it's often nasty.
[02:09:53] <strcat> type assertions
[02:09:56] <dbaupp> ah, I guess they have to work with what they're given, so they don't have much choice about using int.
[02:10:00] <ChrisMorgan> Go's design encourages using built-in types very strongly. Hence map[string][]string for headers.
[02:10:00] *** Quits: eholk (eholk@moz-466C519D.uconnect.utah.edu) (Quit: eholk)
[02:10:35] <ChrisMorgan> They support multiple return values and unpacking similar to in Rust, but not as tuple types generally.
[02:10:42] <strcat> the two type-safe generic containers are arrays/slices and maps
[02:10:43] *** Joins: ghrust (ghrust@CFE85B59.6A2AE50.F3114085.IP)
[02:10:44] <ghrust> 01[13rust01] 15bors 04force-pushed 06auto from 146534f23 to 14f28e581: 02http://git.io/N3iJvQ
[02:10:44] *** Parts: ghrust (ghrust@CFE85B59.6A2AE50.F3114085.IP) ()
[02:10:45] *** Joins: ghrust (ghrust@2EE61FCC.6A2AE50.F3114085.IP)
[02:10:45] <ghrust> 01[13rust01] 15bors pushed 2 new commits to 06auto: 02http://git.io/lkXZqQ
[02:10:45] <ghrust> 13rust/06auto 141dbcc8b 15Brian Anderson: std: Remove ThreadPerCore spawn mode. Unused
[02:10:45] <ghrust> 13rust/06auto 14b70c045 15bors: auto merge of #7856 : brson/rust/no-thread-per-core, r=pcwalton...
[02:10:45] *** Parts: ghrust (ghrust@2EE61FCC.6A2AE50.F3114085.IP) ()
[02:10:53] <strcat> you can write generic code with dynamic typing basically ;p
[02:10:55] <ChrisMorgan> I tried Go for a while but did end up just deciding that its type system was too restrictive.
[02:10:58] <dbaupp> ChrisMorgan: I've always thought that was strange
[02:11:18] <dbaupp> ChrisMorgan: (at least I did once pcwalton explained it too me on HN... coincidences!)
[02:11:22] <strcat> dbaupp: they are about simplicity of the language spec and implementation
[02:11:28] <dbaupp> strcat: yeah, I know.
[02:11:30] *** Joins: pnathan (Adium@moz-BDC3EE62.tukw.qwest.net)
[02:11:33] <strcat> care* about
[02:11:41] <engla> at least it compiles fast
[02:11:45] <engla> ;-)
[02:11:55] <strcat> because the compilers don't optimize
[02:12:04] <strcat> gccgo is usually slower than gcc ;p
[02:12:08] <ChrisMorgan> Its header thing handles , splitting itself, as in "Accept: text/html,application/xhtml+xml;q=0.8", hence the []string value type. Weird, as comma is not *necessarily* a separator.
[02:12:14] <pcwalton> well, also because their typechecking is easier
[02:12:31] <strcat> pcwalton: compared to C++/Rust, yeah
[02:12:31] <pcwalton> and our compiler is much less mature
[02:12:31] <dbaupp> Is go LL(1)?
[02:12:44] <strcat> dbaupp: no
[02:12:53] <strcat> LL(2) or LL(3) maybe
[02:13:03] <strcat> it definitely needs a few tokens of lookahead in some places like their for loop
[02:13:04] <dbaupp> aha, better than C++ ;)
[02:13:11] <pcwalton> strcat: you sure? most LL(k)s can be reduced to LL(1) with left factoring
[02:13:12] <pcwalton> like rust
[02:13:24] <strcat> pcwalton: well... I'm thinking about their for loop
[02:13:26] *** Quits: q66 (q66@6EE9DE40.46454B5D.33AABD5F.IP) (Quit: Leaving)
[02:13:34] <pcwalton> 'for' AFTER-FOR
[02:13:41] <strcat> they have
[02:13:44] <strcat> for {}
[02:13:45] *** Quits: qmx (qmx@moz-D6C3C2E6.qmx.me) (Ping timeout)
[02:13:45] <strcat> for cond {}
[02:13:49] <strcat> for a; b; c {}
[02:13:54] <strcat> and for x = range iirc
[02:14:16] <pcwalton> I suspect that's left factorable with enough of a hatchet job applied to the grammar
[02:14:17] <pcwalton> maybe not
[02:14:53] <ChrisMorgan> Go's iteration support, or lack of it, also drives you to use the built-in types that support it. With Rust, as with Python, I get freedom to make useful iterators.
[02:15:30] <Luqman> strcat: \o/ sully's pull in the queue lets me get through building the rest of the stages
[02:15:51] <strcat> pcwalton: http://golang.org/doc/effective_go.html#for lot of special cases ;p
[02:16:43] <strcat> 3 forms + ones with := range
[02:16:46] <strcat> so really 4
[02:17:05] <strcat> ChrisMorgan: I guess they could make range interface-based though
[02:17:07] <strcat> maybe
[02:17:19] <ChrisMorgan> strcat: they've explicitly shunned that path.
[02:17:26] *** Joins: qmx (qmx@moz-D6C3C2E6.qmx.me)
[02:17:35] <ChrisMorgan> Many people ask. They always say "no".
[02:18:07] *** Quits: pcwalton (pcwalton@moz-7B0110AD.mv.mozilla.com) (Quit: pcwalton)
[02:18:55] <tikue> hey strcat, do you have a moment? I'm trying to implement a mutable iterator for a tree structure and running into problems
[02:19:53] <strcat> tikue: sure
[02:20:01] <tikue> strcat: thanks, here's the code I'm working with https://gist.github.com/tkuehn/16a60885979f2e6299c3
[02:20:13] <tikue> strcat: and the associated compile error
[02:20:27] <tikue> basically I think the issue is I push references to a node's children to the iter stack
[02:20:40] <Eridius> hrm, there appears to be no .consume_first/.consume_second on tuples. That seems a shame
[02:20:47] <tikue> but then that borrows node.inner so I can't return the node
[02:20:51] <strcat> tikue: well you can't yield nodes then
[02:20:54] <strcat> you could yield pages
[02:20:58] <dbaupp> Eridius: there is .n0 and .n0_ref
[02:21:01] *** Quits: azakai_ (alon@moz-BBE3ABD.mv.mozilla.com) (Ping timeout)
[02:21:05] <dbaupp> (all the way up to n12)
[02:21:06] <strcat> n0 clones.
[02:21:10] <dbaupp> strcat: oh
[02:21:12] <strcat> it should move
[02:21:16] <tikue> strcat: why would yielding a page work if yielding nodes doesn't?
[02:21:20] <dbaupp> well, that should be changed, yeah
[02:21:28] *** Joins: steven_is_false (user@moz-144077DE.bchsia.telus.net)
[02:21:30] <strcat> tikue: nodes hold children
[02:21:33] <strcat> so you're making aliases
[02:21:33] <Eridius> .n0 and .n1 are identical to .first and .second, no?
[02:21:38] <dbaupp> Eridius: yup
[02:21:42] <tikue> strcat: haha, of course :P ok, thank you that's what I'll do
[02:21:58] <Eridius> the .n*, .first, and .second methods should probably move
[02:22:04] <strcat> tikue: you have to split them into parts though, in a let statement
[02:22:06] <strcat> tikue: like...
[02:23:01] <strcat> rusti: struct Foo { x: int, y: int } let mut a = Foo { x: 5, y: 6 }; let Foo { x: ref mut x, y: ref mut y } = a; (*x, *y)
[02:23:02] -rusti- (5, 6)
[02:23:15] <dbaupp> Eridius: the .first and .second methods could probably move themselves into /dev/null ;P
[02:23:27] <strcat> tikue: so you could grab a mut ref to the stored page + another to the array of children
[02:23:32] <Eridius> hrm, can't bind by-move in a pattern guard, even if no subsequent patterns use that value. That's a shame
[02:23:38] <dbaupp> Eridius: (replaced by .n*.)
[02:23:41] <benh> ooh, struct destructurig with mutable reference binds?
[02:23:53] <dbaupp> Eridius: file a bug! :)
[02:23:57] *** Quits: samx (sami@moz-48EC0983.dyn.optonline.net) (Quit: This computer has gone to sleep)
[02:24:01] <tikue> strcat: I don't think I'm following -- what makes that necessary?
[02:24:21] <strcat> tikue: I don't think it will let you do &mut a.x and then &mut a.y
[02:24:26] <strcat> you have to take them at the same time
[02:24:30] <tikue> strcat: ahh ok. thanks
[02:24:36] <Eridius> oh come on. I can't bind by-move and by-ref in the same pattern? Grr
[02:24:56] <strcat> Eridius: a move destroys the type
[02:24:57] *** Quits: jaen (jaen@moz-36261275.internetdsl.tpnet.pl) (Ping timeout)
[02:25:05] <strcat> s/destroys/consumes/
[02:25:11] <strcat> so you can't have a ref left into it
[02:25:12] *** Quits: steven_is_false (user@moz-144077DE.bchsia.telus.net) (Ping timeout)
[02:25:12] <Eridius> strcat: yeah but I'm binding one component by-move and another component by-ref. I don't need the original location of the by-moved component to still live
[02:25:21] <Eridius> e.g. (a, b) I bind a by-ref and b by-move
[02:25:22] <strcat> Eridius: so why not take both by-move?
[02:25:38] <Eridius> strcat: actually, that's a good point. I can do that
[02:25:44] * Eridius is updating older code to compile under current rustc
[02:25:47] <strcat> Eridius: it considers a move the end of the whole object
[02:25:49] <Eridius> I think I used to get a bunch of implicit copies in this code
[02:25:51] <strcat> even if it's a partial move
[02:26:35] * strcat thinks there's probably a hole even with the way it's currently done
[02:26:39] <strcat> will look into it in a bit
[02:26:46] <Eridius> huzzah, code compiles
[02:29:33] <jensnockert> I like the type error `mismatched types: expected `BUG[0]` but found `f32` (expected type parameter but found f32)`
[02:30:45] *** Quits: dherman (dherman@moz-6CA476B1.hsd1.ca.comcast.net) (Quit: dherman)
[02:33:32] *** Joins: alisdair (textual@moz-EBE9F394.bchsia.telus.net)
[02:33:59] <Eridius> hrm... error: mismatched types: expected `~[u8]` but found `~[int]` (expected u8 but found )
[02:34:05] <Eridius> that error seems to be missing something
[02:34:25] *** Quits: paulproteus (quassel@rose.makesad.us) (Ping timeout)
[02:34:31] *** Joins: paulproteus (quassel@moz-E86A3B42.makesad.us)
[02:34:41] <Eridius> also, apparently vec::from_elem(16, 0) used to be able to generate a ~[u8] if required, but now it always generates ~[int].
[02:34:52] *** Joins: strcat1 (strcat@moz-54F7FD49.cpe.net.cable.rogers.com)
[02:34:59] *** Quits: rusti (rusti@moz-54F7FD49.cpe.net.cable.rogers.com) (Ping timeout)
[02:34:59] *** Quits: strcat (strcat@moz-54F7FD49.cpe.net.cable.rogers.com) (Ping timeout)
[02:36:11] *** Joins: sankha93 (Instantbir@FF736F2B.ACA8140B.27560D6E.IP)
[02:37:26] <jensnockert> Can someone point at what I am doing wrong? https://gist.github.com/jensnockert/24c6b9b17bdb9847b697
[02:37:31] <jensnockert> It cannot find f32x4
[02:37:49] *** Joins: jdm (jdm@92FB48CA.8B5E9DF.9A8C35B4.IP)
[02:39:26] *** Joins: erickt (erickt@8C9ECD8F.3A598286.F12515B4.IP)
[02:40:21] *** Joins: dherman (dherman@moz-6CA476B1.hsd1.ca.comcast.net)
[02:40:21] *** ChanServ sets mode: +o dherman
[02:41:08] <engla> type aliases are not supported that way
[02:41:08] *** Quits: pnathan (Adium@moz-BDC3EE62.tukw.qwest.net) (Quit: Leaving.)
[02:41:21] *** Quits: erickt (erickt@8C9ECD8F.3A598286.F12515B4.IP) (Ping timeout)
[02:41:26] <jensnockert> They are not?
[02:41:34] <jensnockert> How am I supposed to use them?
[02:42:10] <dbaupp> jensnockert: they're essentially just for making type signatures shorter
[02:42:12] <engla> worse, it seems they are not even planned to be used that way https://github.com/mozilla/rust/issues/4508#issuecomment-21155705
[02:42:27] <jensnockert> dbaupp: Which is exactly what I want to do /o\
[02:42:31] <dbaupp> Eridius: vec::from_elem(16, 0u8)
[02:42:49] <Eridius> dbaupp: yes, that's what I modified it to, I'm just surprised that a) it worked before, and b) it stopped working
[02:42:53] <Eridius> (where "it" is vec::from_elem(16, 0)
[02:42:54] <Eridius> )
[02:43:03] <dbaupp> Eridius: did any of the other code around it change?
[02:43:07] <dbaupp> Eridius: e.g. an iterator?
[02:43:08] <Eridius> dbaupp: no
[02:43:20] <dbaupp> o
[02:43:22] <dbaupp> h
[02:43:25] <Eridius> it's passed to code that expects a ~[u8]
[02:43:35] <Eridius> rather, it's passed to a function that declares its argument as ~[u8]
[02:43:36] <dbaupp> ah, strange!
[02:43:47] <Eridius> cbc_decrypt(key, vec::from_elem(16, 0), input)
[02:43:49] <dbaupp> strcat1: rusti's gone!
[02:44:01] *** Joins: rusti (rusti@moz-54F7FD49.cpe.net.cable.rogers.com)
[02:44:13] <strcat1> dbaupp: because my router actually rips down the connections for some reason
[02:44:18] <strcat1> instead of them dropping...
[02:44:20] *** strcat1 is now known as strcat
[02:44:35] <dbaupp> rusti: fn foo(x: ~[u8]) {} let x = vec::from_elem(16, 0); foo(x)
[02:44:37] -rusti- more than 5 lines of output, pastebinned: http://sprunge.us/cjEV
[02:44:46] <dbaupp> rusti: fn foo(x: ~[u8]) {} let x = std::vec::from_elem(16, 0); foo(x)
[02:44:48] -rusti- <anon>:7:16: 7:17 warning: unused variable: `x` [-W unused-variable (default)]
[02:44:48] -rusti- <anon>:7          fn foo(x: ~[u8]) {} let x = std::vec::from_elem(16, 0); foo(x)
[02:44:48] -rusti-                          ^
[02:44:48] -rusti- ()
[02:44:51] <strcat> so rusti exits cleanly thinking the other end tore down the connection
[02:44:52] <strcat> ;\
[02:44:57] <dbaupp> strcat: :(
[02:45:00] <Eridius> hrm, did structs used to get an implicit Copy (but not an implicit Clone)? I have a vec::from_elem(len, MyStruct(0, false)) that used to work and now complains that MyStruct doesn't conform to Clone
[02:45:02] <strcat> even though on a dropped connection it will keep retrying
[02:45:13] <dbaupp> Eridius: #[deriving(Clone)]
[02:45:30] <dbaupp> i.e. #[deriving(Clone)] struct Foo { ... }
[02:46:00] <engla> Eridius: yes, it used to be that way
[02:46:08] <dbaupp> Eridius: but yes, an aggregate type that included implicitly Copiable types and didn't have a dtor was also implicitly copiable
[02:46:15] <Eridius> dbaupp: sorry if I'm unclear, I'm not looking for solutions to fix my code, I know it already. I'm just trying to understand what happened
[02:46:22] <dbaupp> aha! :)
[02:46:29] <Eridius> dbaupp: so why the decision to not be implicitly clonable?
[02:46:47] <dbaupp> Eridius: https://mail.mozilla.org/pipermail/rust-dev/2013-July/004877.html
[02:46:54] *** Quits: kimundi (kimundi@moz-16A93411.dip0.t-ipconnect.de) (Ping timeout)
[02:47:35] <dbaupp> Eridius: (it would have to be manually overridable/disableable to be any different to Copy.)
[02:47:39] <Eridius> dbaupp: my, what a nicely-timed conversation. I really should pay more attention to rust-dev
[02:47:45] <dbaupp> haha :)
[02:47:55] <dbaupp> well, the remove-Copy change only landed yesterday
[02:48:05] <Eridius> I use gmail for most mailing lists and I kinda hate gmail, which is why I only check rust-dev every few days
[02:48:17] <dherman> do we have as-patterns or something like that? e.g. match <expr> { Ctor(_, _, _) as x => { ... } }
[02:48:19] <bstrie> my new mission is to fit the code for an irc bot into rusti's length restriction and have it come on this channel and quine itself to rusti infinitely
[02:48:27] <Eridius> dherman: I believe it's x@tor(_, _, _)
[02:48:30] <dbaupp> dherman: `x @ Cond(*)`
[02:48:31] <dherman> thx
[02:48:34] <Eridius> same as Haskell
[02:48:50] <dbaupp> bstrie: rusti doesn't respond to itself
[02:48:50] <Eridius> bstrie: step 1) get an IRC library into libstd
[02:49:01] <bstrie> that would be the easiest, yes
[02:49:09] *** Joins: ross (ross@moz-8A84103E.br.br.cox.net)
[02:49:11] <Eridius> also, rusti has a timeout, so your bot would be killed before it even finished the connection
[02:49:16] <dbaupp> bstrie: oh! I see, tricky.
[02:49:30] <dbaupp> bstrie: I guess rusti can't access the internet directly too.
[02:49:32] *** Joins: pnathan (Adium@moz-BDC3EE62.tukw.qwest.net)
[02:49:38] <bstrie> dbaupp: hm, good point
[02:49:39] <Eridius> oh that's probably true
[02:49:54] <bstrie> not that rust itself is really very good at accessing the internet
[02:50:07] <dbaupp> ChrisMorgan has a whole webserver!
[02:50:14] *** Joins: kimundi (kimundi@moz-5EF14CAB.dip0.t-ipconnect.de)
[02:51:35] *** kimundi is now known as zz_kimundi
[02:52:34] *** Quits: alisdair (textual@moz-EBE9F394.bchsia.telus.net) (Quit: My MacBook Pro has gone to sleep. ZZZzzzâ€¦)
[02:52:56] <dbaupp> rusti: enum Foo {} fn f(x: Foo) { match x {} }
[02:52:58] -rusti- ()
[02:53:03] <dbaupp> heh, cool
[02:54:09] <Eridius> What's the point of an empty enum? The only thing you could pass to it is bottom
[02:54:18] <strcat> Eridius: opaque types
[02:54:25] <strcat> for FFI
[02:54:39] <Eridius> strcat: ah, so a pointer to one
[02:54:47] *** Quits: tikue (tkuehn@moz-BBE3ABD.mv.mozilla.com) (Quit: tikue)
[02:55:05] *** Joins: tikue (tkuehn@moz-BBE3ABD.mv.mozilla.com)
[02:55:16] <strcat> Eridius: yep :)
[02:55:24] <strcat> Eridius: you know you can never actually get one so it's perfect
[02:55:29] <dbaupp> rusti: enum Foo {} fn f(x: Foo) { match x {} } f(unsafe {std::unstable::intrinsics::init()})
[02:55:31] -rusti- rust: task failed at 'scrutinizing value that can't exist', <anon>:7
[02:55:31] -rusti- rust: domain main @0x18831b0 root task failed
[02:55:31] -rusti- application terminated with error code 101
[02:55:32] <strcat> Eridius: also... I thought it'd be neat to replace -> ! with one
[02:55:35] <strcat> instead of a special case
[02:55:44] <dbaupp> strcat: does it work with control flow?
[02:55:49] <strcat> dbaupp: not yet but it should
[02:56:24] <Eridius> strcat: I would consider -> ! to have a different semantic meaning than -> EmptyEnum
[02:56:32] <Eridius> (where -> ! is a lot closer to the desired meaning)
[02:56:39] *** Quits: lmandel (lmandel@8B192B20.1F93A08E.ADB88A9.IP) (Quit: lmandel)
[02:56:41] <strcat> -> Bottom
[02:56:44] <strcat> -> Void
[02:56:50] <strcat> there would be a specific type to do it
[02:56:56] <Eridius> oh I see, have one specific enum that's a stand-in for bottom
[02:57:16] *** Quits: LU324 (stuff@moz-A17E9A7B.dyn.embarqhsd.net) (Ping timeout)
[02:57:28] <Eridius> although then you'd be special-casing empty enum return types as unreachable, which feels to me to be more of a special-case than special-casing syntax to mean bottom
[02:57:44] <Eridius> unless you wanted to have like #[lang_item="bottom"]enum Bottom{}, which is just silly
[02:57:51] <dbaupp> Eridius: it'd just be Bottom, via a lang item, yeah
[02:57:54] *** Quits: pnathan (Adium@moz-BDC3EE62.tukw.qwest.net) (Quit: Leaving.)
[02:58:11] <dbaupp> (or it could actually do a is_constructable check.)
[02:58:16] <strcat> Eridius: it wouldn't be a special case
[02:58:35] <strcat> it wouldn't care about them being a return type specifically
[02:58:46] <strcat> ok for example
[02:59:01] *** Quits: Kruppe (user@moz-E150F49F.cpe.net.cable.rogers.com) (Quit: rcirc on GNU Emacs 24.3.1)
[02:59:16] <strcat> rusti: enum Foo {} let x: Option<Foo> = None; match x { None => () }
[02:59:16] <bstrie> dbaupp: are you aware that isrustfastyet hasn't collected memory data recently?
[02:59:17] -rusti- <anon>:7:48: 7:70 error: non-exhaustive patterns: Some not covered
[02:59:17] -rusti- <anon>:7          enum Foo {} let x: Option<Foo> = None; match x { None => () }
[02:59:17] -rusti-                                                          ^~~~~~~~~~~~~~~~~~~~~~
[02:59:17] -rusti- error: aborting due to previous error
[02:59:18] -rusti- application terminated with error code 101
[02:59:20] <strcat> that should work
[02:59:27] <strcat> if rust handled them properly
[02:59:28] <dbaupp> bstrie: I am
[02:59:44] <dbaupp> bstrie: cmr's bencher is off
[03:00:02] <dbaupp> bstrie: had to be de-racked or something-or-other... out of my control :(
[03:00:09] <dbaupp> (but thanks for the heads-up :) )
[03:00:28] <strcat> Eridius: if they are fixed to actually work like proper uninhabited types, -> Void will Just Work
[03:00:33] <strcat> no special case required
[03:00:36] <dbaupp> apparently it was going to be up today... but it doesn't seem to be.
[03:01:42] <bstrie> I'd be happy to offer my server as a memory benchmarker, but it doesn't actually have enough memory to compile rust :\
[03:01:48] *** Quits: MaikKlein (maik@moz-4CFF4604.dip0.t-ipconnect.de) (Ping timeout)
[03:02:10] *** Joins: alisdair (textual@moz-EBE9F394.bchsia.telus.net)
[03:02:15] <engla> that's a benchmark too
[03:02:24] <bstrie> engla: rather uninteresting though
[03:02:27] <strcat> dbaupp: he said it'd be back soon
[03:02:30] <engla> yeah
[03:02:41] <bstrie> as far as graphs go
[03:03:21] *** Joins: MaikKlein (maik@moz-4CFF4604.dip0.t-ipconnect.de)
[03:03:47] <dbaupp> bstrie: as we get more benchmarks it'd get more interesting :)
[03:04:04] *** Quits: zippity (Mibbit@moz-3269D7E9.hsd1.il.comcast.net) (Quit: http://www.mibbit.com ajax IRC Client)
[03:04:22] *** Quits: jensnockert (jensnocker@moz-C5F27039.cust.bredband2.com) (Ping timeout)
[03:04:50] *** dherman is now known as dherman-acting-like-a-grownup
[03:05:13] *** Quits: qmx (qmx@moz-D6C3C2E6.qmx.me) (Ping timeout)
[03:05:15] <aatch> dherman-acting-like-a-grownup, good luck, I tried that once.
[03:05:25] *** Quits: MaikKlein (maik@moz-4CFF4604.dip0.t-ipconnect.de) (Ping timeout)
[03:05:50] *** Joins: qmx (qmx@moz-D6C3C2E6.qmx.me)
[03:06:18] <dherman-acting-like-a-grownup> only acting
[03:07:53] <SiegeLord> Darn, there should be limits on nick lengths :P
[03:08:06] *** Joins: jensnockert (jensnocker@moz-C5F27039.cust.bredband2.com)
[03:08:48] <strcat> SiegeLord: technically the limit is 9
[03:08:50] <strcat> per the RFC
[03:08:58] <strcat> but ofc nothing follows the RFC as an absolute
[03:08:59] <strcat> ;p
[03:09:12] *** Quits: Thad (chatzilla@moz-C35F90AE.tx.res.rr.com) (Client exited)
[03:09:28] *** Joins: jaen (jaen@moz-36261275.internetdsl.tpnet.pl)
[03:11:20] <SiegeLord> Going to have to find a plugin/setting for weechat to work-around it somehow... as soon as someone speaks with a long name, it basically cuts the useful window size in half for me :P
[03:12:32] <Eridius> hrm, why would my debug!() lines not work?
[03:12:44] <acrichto_> Eridius: compile with "--cfg debug"
[03:13:04] <Eridius> acrichto_: ugh, that's necessary now?
[03:13:21] <acrichto_> yeah it was done as an optimization for compiling rustc (there's lots of debug! in there)
[03:13:36] <Eridius> RUST_LOG=::help shows 4 crates from extra. Is extra being compiled with debug or what?
[03:13:38] <acrichto_> although off-by-default may not be the best option
[03:14:43] <dbaupp> (if anyone wants to change it, it's in the `std_macros()` function in syntax/ext/expand.rs)
[03:17:03] <acrichto_> dbaupp: how about --cfg ndebug, like C?
[03:17:03] *** Joins: erickt (Adium@49C4075F.3AC15C18.2321E71E.IP)
[03:17:15] * dbaupp doesn't have any opinion
[03:17:22] <jensnockert> And since I already get awesome help, what does `error: mismatched types: expected `BUG[0]` but found `f32` (expected type parameter but found f32)' mean?
[03:17:39] <Eridius> grr, I can't find any reason for this code to have changed behavior, but it doesn't work anymore
[03:17:49] <dbaupp> acrichto_: (I'm just a code monkey! that was pcwalton's feature request.)
[03:18:07] <jensnockert> The code triggering it is `let f = simd::Vec4(1.0f32, 2.0f32, 3.0f32, 4.0f32);'
[03:18:11] <dbaupp> jensnockert: is BUG something you typed?
[03:18:22] <jensnockert> dbaupp: No, it is from the compiler.
[03:18:45] <dbaupp> jensnockert: from rustc/util/ppaux.rs it seems
[03:18:49] * dbaupp investigates
[03:19:15] <jensnockert> Waitâ€¦ it could be that I don't resolve the type somehow.
[03:19:26] <dbaupp> with `// This should not happen...` above it
[03:19:37] *** Joins: infynyxx (infynyxx@moz-E95B370B.nyc.res.rr.com)
[03:19:48] <aatch> dbaupp, lemme guess, it's after trying to get the identifier?
[03:19:48] <Eridius> ok yeah this is potentially a real issue. What could have caused my code to behave differently under current rustc, but still compile without changes?
[03:20:01] <dbaupp> ty_param(param_ty {idx: id, def_id: did}) => { let param_def = cx.ty_param_defs.find(&did.node); let ident = match param_def { ...; None => fmt!("BUG[%?]", id) } } }
[03:20:12] <dbaupp> aatch: a type parameter ident, yes.
[03:20:19] <aatch> dbaupp, thought so.
[03:20:42] <aatch> niko added that to make error messages nicer.
[03:22:05] <aatch> jensnockert, you are correct that it probably isn't resolving the type there.
[03:22:15] <strcat> dbaupp: https://github.com/mozilla/rust/pull/7897 r? although maybe I'll think of something vaguely related to tack on ;p
[03:22:18] *** Joins: azita (Azita@moz-C1FB2A8.hsd1.ca.comcast.net)
[03:22:46] * dbaupp loves Rust's indentation pyramids
[03:23:54] <jensnockert> aatch: No idea why though :(
[03:24:15] <sully> hm, I am trying out a change to the vtable resolution code
[03:24:32] <sully> and I have this uncanny feeling that I tried this last summer and it didn't work...
[03:24:48] *** Joins: steven_is_false (user@moz-144077DE.bchsia.telus.net)
[03:25:13] *** Quits: Earnestly (earnest@2AB30F53.FB5005.2BCC804A.IP) (Ping timeout)
[03:25:20] *** Quits: azita (Azita@moz-C1FB2A8.hsd1.ca.comcast.net) (Quit: azita)
[03:25:28] <sully> (in particular, I am changing it so that it still does the normal impl search for type parameters if the param doesn't already have a bound on it)
[03:25:36] <sully> I'm not sure if there is a bug open for this
[03:25:43] <sully> if there is I bet that strcat opened it
[03:33:00] *** Joins: tav_ (tav@moz-E0A503B0.range109-156.btcentralplus.com)
[03:33:30] *** Quits: tav (tav@moz-8C73145.range86-166.btcentralplus.com) (Ping timeout)
[03:33:31] *** tav_ is now known as tav
[03:34:07] *** Joins: strcat1 (strcat@moz-54F7FD49.cpe.net.cable.rogers.com)
[03:34:12] <strcat1> sully: I'm a bug magnet ;p
[03:34:35] <strcat1> github doesn't make it easy to see how many I've opened, sadly
[03:34:39] <strcat1> since PRs count as issues
[03:34:40] <sully> well, you also write traits that are "for A"
[03:34:48] <strcat1> ;)
[03:34:51] <sully> which is what my change affects
[03:35:10] <strcat1> sully: well I was also the first person to try writing stuff like an owned tree without copies
[03:35:20] <strcat1> so I got to find dozens of lifetime bugs
[03:35:24] *** Quits: strcat (strcat@moz-54F7FD49.cpe.net.cable.rogers.com) (Ping timeout)
[03:35:24] *** Quits: rusti (rusti@moz-54F7FD49.cpe.net.cable.rogers.com) (Ping timeout)
[03:35:24] <acrichto_> sully: are you talking about https://github.com/mozilla/rust/issues/5898 ?
[03:35:40] * strcat1 is used to being the feature lab rat
[03:35:43] *** strcat1 is now known as strcat
[03:36:17] <strcat> the bugs in 'match' were fun
[03:36:27] <strcat> back when we had 'move' as a keyword
[03:36:35] <strcat> but moves-based-on-types had landed
[03:36:48] <strcat> no end of pain from those.
[03:38:49] <sully> oh, sigh
[03:39:06] <sully> my fix fixed my problem on my reduced test case
[03:39:15] <sully> but not in the standard library
[03:39:21] *** Quits: bytbox (s@moz-DC83764A.washdc.fios.verizon.net) (Quit: Lost terminal)
[03:39:54] <strcat> heh
[03:39:54] *** Joins: erickt1 (erickt@8C9ECD8F.3A598286.F12515B4.IP)
[03:40:11] <strcat> sully: maybe you fixed a different bug ;)
[03:40:50] *** Quits: sankha93 (Instantbir@FF736F2B.ACA8140B.27560D6E.IP) (Ping timeout)
[03:40:53] <sully> oh, no, I fixed the bug, but there is another
[03:41:30] *** Joins: pnathan (Adium@B9840254.2CD8A5F8.477B877D.IP)
[03:41:41] *** Quits: erickt1 (erickt@8C9ECD8F.3A598286.F12515B4.IP) (Ping timeout)
[03:43:17] *** Quits: tikue (tkuehn@moz-BBE3ABD.mv.mozilla.com) (Quit: tikue)
[03:44:39] *** Quits: Axord (xord@moz-C3CCF156.lsanca.dsl-w.verizon.net) (Quit: I'm sure it's perfectly safe)
[03:46:14] <strcat> dbaupp: I should start figuring out random-access ones ;p
[03:46:26] * strcat really wants chain + RandomAccessIterator
[03:46:29] <goffrie> wonder if anyone here would be interested in http://userscripts.org/scripts/show/173659 :P since I keep hearing about this
[03:47:05] <goffrie> looks a little silly in places but should be useful
[03:47:33] *** Quits: pnathan (Adium@B9840254.2CD8A5F8.477B877D.IP) (Ping timeout)
[03:48:31] <eevee> https://gist.github.com/eevee/6034960  i am a bit stuck here
[03:48:53] <eevee> hoping for a solution that doesn't involve plastering @ on basically everything
[03:49:06] *** Quits: SiegeLord (sl@moz-CAF07B4C.hsd1.ma.comcast.net) (Client exited)
[03:49:43] <steven_is_false> eevee: It looks like you just want to make AppState take Terminal by value.
[03:50:14] <steven_is_false> So struct AppState<'self> { term: Terminal, canvas: Canvas<'self>,
[03:50:14] <steven_is_false> }
[03:50:38] *** Joins: rusti (rusti@moz-54F7FD49.cpe.net.cable.rogers.com)
[03:50:52] <eevee> that cuts it down to just the first borrow error  :)  rust is not convinced that term will stick around as long as the canvas
[03:51:43] <steven_is_false> Why do you need two handles to the terminal (one in Canvas, and one in Terminal?)
[03:52:13] <eevee> the canvas needs to be able to write to the terminal, ask it about termcaps, etc
[03:52:35] <eevee> i don't actually need the terminal in AppState but istm it'll be deallocated at the end of the function if i don't keep it around
[03:52:42] *** Joins: ghrust (ghrust@FD7BC443.6A2AE50.F3114085.IP)
[03:52:42] <ghrust> 01[13rust01] 15bors merged 06auto into 06master: 02http://git.io/lkXZqQ
[03:52:42] *** Parts: ghrust (ghrust@FD7BC443.6A2AE50.F3114085.IP) ()
[03:52:47] *** Joins: azita (Azita@moz-C1FB2A8.hsd1.ca.comcast.net)
[03:53:02] <steven_is_false> eevee: Not if you have Canvas take Terminal by value instead of a reference.
[03:54:14] <eevee> Terminal has a destructor for undoing termios changes  :(
[03:54:26] <eevee> maybe this doesn't make sense unless Canvas holds a @Terminal
[03:54:29] <steven_is_false> eevee: You misunderstand move semantics.
[03:55:05] <cmr> eevee: Did you find extra::terminfo to be helpful?
[03:55:07] <steven_is_false> If a Terminal is never cloned there'll only ever be one destruction.
[03:55:10] *** Quits: azita (Azita@moz-C1FB2A8.hsd1.ca.comcast.net) (Quit: azita)
[03:55:13] <cmr> dbaupp: yeah, that didn't materialize unfortunately :(
[03:55:20] <eevee> oh i thought you meant to copy Terminal into Canvas
[03:55:25] <steven_is_false> And, you can handle the case of cloning explicitly.
[03:55:28] <cmr> ChrisMorgan: sure thing
[03:55:29] <eevee> there can be multiple canvases and other callers might want to keep using the terminal directly
[03:55:40] *** Joins: ghrust (ghrust@2EE61FCC.6A2AE50.F3114085.IP)
[03:55:40] <ghrust> 01[13rust01] 15bors pushed 0 new commits to 06auto: 02http://git.io/GvvJMQ
[03:55:40] *** Parts: ghrust (ghrust@2EE61FCC.6A2AE50.F3114085.IP) ()
[03:55:41] *** Joins: ghrust (ghrust@614D05BD.6A2AE50.F3114085.IP)
[03:55:41] <ghrust> 01[13rust01] 15bors pushed 3 new commits to 06auto: 02http://git.io/4hjK4Q
[03:55:41] <ghrust> 13rust/06auto 14e93dd34 15blake2-ppc: Fix warnings in libextra tests...
[03:55:41] <ghrust> 13rust/06auto 14ff9b75f 15blake2-ppc: Fix warnings in libstd and librusti tests
[03:55:42] <ghrust> 13rust/06auto 143514a5a 15bors: auto merge of #7857 : blake2-ppc/rust/fix-test-warnings, r=alexcrichton...
[03:55:44] *** Parts: ghrust (ghrust@614D05BD.6A2AE50.F3114085.IP) ()
[03:55:52] <eevee> cmr: it looks super helpful but i've been trying to get my actual app compiling before switching over  :)
[03:56:01] <cmr> eevee: hehe :p
[03:56:19] <cmr> Amulent is very relevant to my interests, best of luck!
[03:56:20] <steven_is_false> Okay. I'm not sure that get_app_state is what you want then.
[03:56:41] <dbaupp> eevee: a object isn't allowed to depend on its position, so you can have references into itself
[03:56:45] <dbaupp> *can't
[03:57:23] <dbaupp> you could probably hack a relative-pointer type for internal pointers into a datastructure
[03:57:37] <cmr> eevee: One thing you could do is stuff the terminal in TLS, although that gets quite hairy if you want a dynamic amount of them..
[03:58:09] <eevee> haha gross.
[03:58:18] <cmr> eevee: I think @ is the right solution here, but it shouldn't be that pervasive of a change? I'dimagine most uses would use a &
[03:58:27] <goffrie> hmm, does anyone happen to know a PR where github showed the commits in the wrong order?
[03:58:41] <eevee> yeah i think i can maybe fix this with a single @
[03:58:46] <cmr> goffrie: you want a specific example or areyou asking if it happens?
[03:58:53] <goffrie> specific example, to test out my script
[03:59:57] <Eridius> hrm, VecIterator and friends don't implement Clone. That's a shame
[04:00:10] <strcat> Eridius: they will, engla made a PR
[04:00:16] <strcat> it's approved
[04:00:49] <cmr> goffrie: here's one: https://github.com/mozilla/rust/pull/7725
[04:01:01] <goffrie> aha, cool
[04:01:13] <eevee> pointers are hard
[04:01:18] <goffrie> that's really weird behaviour but script works as intended
[04:01:34] <steven_is_false> strcat: engla That's nice. I need clone on vec iterators to make some of the iteration use iterators.
[04:01:46] <steven_is_false> *In HashMap
[04:02:14] <Eridius> what's engla's GH name? I'm having trouble finding the PR
[04:02:24] <engla> I'll find it
[04:02:25] <Eridius> oh there it is
[04:02:27] <Eridius> blake2-ppc?
[04:02:30] <engla> yes
[04:02:36] <strcat> Eridius: http://buildbot.rust-lang.org/bors/bors.html ;p
[04:02:40] <strcat> screw github's UI
[04:02:53] <Eridius> I looked there first
[04:03:14] *** Quits: tiffany (kawaii@moz-EB8B0C08.dhcp.embarqhsd.net) (Ping timeout)
[04:03:17] <Eridius> engla: your PR doesn't seem to add Clone to VecChunkIter :(
[04:04:09] <engla> ok, it can be added later
[04:04:27] <engla> I didn't realize that iterator existed tbh
[04:04:35] <Eridius> heh
[04:06:01] * dbaupp hopes that VecChunkIter will make Rust good at basic map-reduce type algorithms
[04:06:27] <cmr> What is that? iterator over a slice?
[04:06:39] <Eridius> wtf? `let blobit = blob.chunk_iter(16)` cannot ifner an appropriate lifetime
[04:06:59] <Eridius> (blob is a &[u8])
[04:07:12] <steven_is_false> do myvec.iter().transform(|x| x + 1).reduce etc.. ?
[04:07:18] <cmr> dbaupp: I'm considering using a dedicated box to replace the bench box, rather than piggybacking on a server I theoretically shouldn't have access to
[04:07:20] <Eridius> rusti: let blob = bytes!("test"); let blobit = blob.chunk_iter(16); fmt!("%?", blobit)
[04:07:22] -rusti- ~"{v: &[116, 101, 115, 116], size: 16}"
[04:07:25] <Eridius> huh, that worked
[04:07:34] <cmr> dbaupp: I think my old laptop will be... sufficient. It has enough memory, but it's sloowww
[04:07:35] *** Joins: eholk (eholk@moz-9AB4D52F.hsd1.ut.comcast.net)
[04:07:53] <steven_is_false> Actually, serious question. How can the helper method transform (which is just map) be generalized to the full power of applicative functors?
[04:07:54] <cmr> but I ran gentoo on it as my only box, for almost a year, so it's not /too/ unbearably awful
[04:08:32] *** Quits: MrFahrenheit (RageOfThou@3FEF494C.29C984D5.783DEDCA.IP) (Ping timeout)
[04:08:40] <steven_is_false> Applicative functors let one do lift2 (+) x y (and more) as opposed to only map (+1) x
[04:08:51] <dbaupp> cmr: yeah, several people have said that they have spare cycles, so wrapping up the bencher scripts into a one shot git-clone-and-run type thing would be neat too
[04:09:02] <cmr> dbaupp: mmm
[04:09:08] <aatch> I have a spare box now
[04:09:15] <cmr> aatch: hero!
[04:09:22] <cmr> dbaupp: actually it's pretty damn close to that now
[04:09:23] <aatch> it's probably more powerful than a lot of the spares people have.
[04:09:26] <cmr> just needs the cgroup setups
[04:09:31] <cmr> *cgroups setup
[04:09:37] <dbaupp> cmr: (I'd be happy with whatever, although it'd be nice to at least let the current one fill in the recent gap & have an overlap with whatever new computers we add.)
[04:09:37] <steven_is_false> I guess a zip helper would work.
[04:09:56] <cmr> yeah, all of my spares are complete crap.
[04:09:58] <aatch> simply by virtue of it only being made "spare" very recently
[04:10:09] <dbaupp> steven_is_false: I think we just need higher kinded types, and then it should all "just work"
[04:10:13] * strcat anxiously awaits cgroups being redone
[04:10:19] <steven_is_false> And there is a zip method nvm.
[04:10:21] <dbaupp> steven_is_false: (possibly with a liberal application of @. :( )
[04:10:26] <strcat> rusti: you'll be put down and replaced by playpen v2
[04:10:26] -rusti- <anon>:7:12: 7:15 error: expected `;` or `}` after expression but found `'ll`
[04:10:26] -rusti- <anon>:7          you'll be put down and replaced by playpen v2
[04:10:26] -rusti-                      ^~~
[04:10:26] -rusti- application terminated with error code 101
[04:10:30] <aatch> cmr, it's my old desktop, good enough to develop on (just)
[04:10:39] <steven_is_false> Thinks get a lot more complicated when linear types are involved
[04:11:48] <cmr> aatch: would you mind? I can walk you through the setup
[04:12:03] <dbaupp> steven_is_false: yeah
[04:12:46] <aatch> cmr, I wouldn't mind. It's rust-bench on github right?
[04:13:28] <cmr> aatch: yes, but it seems I've misplaced the script dbaupp wrote :\
[04:13:45] * dbaupp will have to work out the best way to display all this daya
[04:13:51] <aatch> cmr, heh. Well I managed to get some of rust-bench working a while back.
[04:13:54] <dbaupp> https://gist.github.com/huonw/5940437
[04:14:03] <cmr> there sheis
[04:14:17] <cmr> it's probably on my desktop somewhere; netbook only atm
[04:14:39] *** Quits: gavinb (gavinb@moz-CA19A0CF.vic.adsl.internode.on.net) (Ping timeout)
[04:14:40] <dbaupp> (it needs to be modified so that git pull failing falls back to doing historical commits, rather than crashing the whole thing.)
[04:14:43] *** Joins: sankha93 (Instantbir@6B0F5A3.D0B6154C.F44414AF.IP)
[04:14:43] <aatch> anyway, my old comp is an old Phenom QuadCore with 4GB of memory, I'll strip everything out too.
[04:14:53] <Eridius> well now I know why my code isn't working! range_rev changed semantics
[04:15:43] *** Joins: gavinb (gavinb@moz-CA19A0CF.vic.adsl.internode.on.net)
[04:17:50] *** Quits: dherman-acting-like-a-grownup (dherman@moz-6CA476B1.hsd1.ca.comcast.net) (Quit: dherman-acting-like-a-grownup)
[04:19:03] <cmr> aatch: down and dirty is: it's a mix of python2 and python3 unfortunately (python3 has clock_gettime support, python2 doesn't). you need plumbum and the libcg tools
[04:19:31] <dbaupp> aatch: (you'll need to put them somewhere on the internet... it's quite a lot of data too.)
[04:19:37] <aatch> cmr, I noticed. plumbumb was probably the hardest part.
[04:19:55] <dbaupp> cmr: you could probably gzip the output files to save a few MB per test.
[04:20:05] <dbaupp> (well, mainly the json)
[04:20:29] <aatch> I think I have a amazon AWS account lying around, I could probably upload to an S3 bucket.
[04:20:48] <cmr> also needs a `cgcreate -a $USER -t $USER -g memory,cpuacct:rustbench`
[04:21:02] <cmr> I can provide hosting if needed
[04:21:35] <dbaupp> The directory with the data in it is 640 MB at my end, at the moment.
[04:21:40] <cmr> but yeah compression would be very good
[04:22:06] * dbaupp will then read the file by shelling out to zcat
[04:22:15] * dbaupp wishes Rust had better library support sometimes
[04:22:26] *** Quits: jfbk (textual@moz-EEA9CFB3.nyc.res.rr.com) (Quit: My MacBook has gone to sleep. ZZZzzzâ€¦)
[04:22:38] <cmr> dbaupp: extra::flate? ;p
[04:22:49] <dbaupp> doesn't handle the headers, I don't think?
[04:22:53] <cmr> ah
[04:23:21] *** Joins: dherman (dherman@moz-6CA476B1.hsd1.ca.comcast.net)
[04:23:21] *** ChanServ sets mode: +o dherman
[04:23:43] <gavinb> To distribute a Rust app, can you just copy the runtimes (std, extra, morestack, rustrt) and the installed contents of the rustpkg? (Assuming the target is a similar platform; eg. the same release of Ubuntu) ?
[04:23:54] *** Joins: vodik_ (simon@moz-CBE4BB13.cable.teksavvy.com)
[04:23:56] <jensnockert> And I have no idea why it doesn't resolve the SIMD types *cries*
[04:24:01] *** Quits: vodik (simon@moz-CBE4BB13.cable.teksavvy.com) (Quit: WeeChat 0.4.2-dev)
[04:24:06] *** vodik_ is now known as vodik
[04:24:08] <cmr> gavinb: that should do it yep
[04:24:13] * jensnockert snuggles a pillow, hoping it will magically fix typecheck.
[04:24:31] <Jeaye> dherman: Damnit. Shifted my whole nick buffer over so far with that nick. :P
[04:24:38] <cmr> yeah me too
[04:25:01] * dbaupp hugs jensnockert
[04:25:15] <Jeaye> Anyone have a good example of file reading? I'm looking to port some std::ifstream code.
[04:25:25] <jensnockert> I do _exactly_ the same thing as is done for structs.
[04:26:34] <dbaupp> Jeaye: beyond `let file = stdio::file_reader(x).expect("couldn't open file");`, `for file.each_line |x| { .. }`?
[04:27:04] <dbaupp> jensnockert: maybe they have to be registered somewhere else?
[04:27:21] <jensnockert> dbaupp: No, I literally use exactly the same codepath.
[04:27:23] <Jeaye> dbaupp: Is there any functionality like. file >> var; instead of parsing entire lines?
[04:27:23] <joelteon> does expect() do what I think it does?
[04:27:29] <Jeaye> joelteon: Yes
[04:27:35] <joelteon> that's a weirdly named method
[04:27:37] <dbaupp> joelteon: what to you expect it to do?
[04:27:39] <dbaupp> *do
[04:27:50] <dbaupp> Jeaye: yeah, sort of... a little bit.
[04:27:58] <cmr> it fails with that error message if it's None, else unwraps the Some
[04:28:02] <joelteon> it fails with that message if it's Nnoe?
[04:28:04] <joelteon> *None
[04:28:06] *** Quits: steven_is_false (user@moz-144077DE.bchsia.telus.net) (Ping timeout)
[04:28:16] <joelteon> that's the opposite of what I'd expect, though
[04:28:22] <Luqman> 23
[04:28:30] <dbaupp> Jeaye: you can use extra::json/extra::ebml to serialise data types to/from bytes/byte streams
[04:28:43] <Jeaye> hm
[04:28:45] <dbaupp> Jeaye: but it's not really been fleshed out very well
[04:28:56] <cmr> please don't use ebml, it needs to die in a fire :(
[04:28:59] <dbaupp> Jeaye: (there are a whole pile of methods on ReaderUtil)
[04:29:25] <dbaupp> http://static.rust-lang.org/doc/std/io.html#trait-readerutil
[04:30:04] <dbaupp> essentially just for reading binary int/uint/floats though.
[04:30:53] <cmr> aatch: https://gist.github.com/cmr/6035363
[04:31:09] <cmr> aatch: on the bench server i just run `while true; do auto-bench.py; done` in tmux...
[04:32:17] <gavinb> cmr: cool, thanks - will give it a try.
[04:32:20] <dbaupp> jensnockert: same codepath for the whole lifetime of the simd type in rustc?
[04:32:26] <cmr> gist updated
[04:32:41] * cmr goes back to bed
[04:32:46] <jensnockert> dbaupp: Yes, or at least until trans.
[04:32:54] <jensnockert> And it crashes in typecheck.
[04:32:59] <dbaupp> jensnockert: how peculiar!
[04:33:34] <Jeaye> dbaupp: Looks like I can emulate file >> var with read_until. Thanks. :)
[04:33:43] <dbaupp> :)
[04:33:56] *** Joins: nano (nano@moz-972880B.superkabel.de)
[04:34:24] <dbaupp> Hopefully we'll eventually get magical type-inferred stream reading of some sort
[04:34:33] <Jeaye> That'll be badass.
[04:34:48] *** Quits: strcat (strcat@moz-54F7FD49.cpe.net.cable.rogers.com) (Ping timeout)
[04:34:56] <dbaupp> let SpaceSepString(s) = stream.read(); let WholeLine(s) = stream.read(); etc
[04:35:00] <jensnockert> dbaupp: Yeah, enough to make a grown man feel :(
[04:35:05] <engla> hopefully it won't involve bit shift operators
[04:35:07] * dbaupp hugs jensnockert
[04:35:14] *** Quits: rusti (rusti@moz-54F7FD49.cpe.net.cable.rogers.com) (Ping timeout)
[04:35:49] <Jeaye> insertion operator!
[04:36:16] <Jeaye> and extraction too. Don't hate :(
[04:36:44] <dbaupp> jensnockert: printf debugging!
[04:36:52] <jensnockert> dbaupp: Yeah, but where?
[04:37:16] <dbaupp> I don't know...
[04:37:30] <dbaupp> just keep working backwards until structs and simds are the same
[04:37:40] <dbaupp> binary search, even!
[04:37:44] * dbaupp loves binary search
[04:38:38] <Jeaye> When I get this working, q3 will have skeletal animations... finally.
[04:40:24] *** Joins: erickt1 (erickt@8C9ECD8F.3A598286.F12515B4.IP)
[04:40:31] <Luqman> 23
[04:41:10] <Jeaye> 42
[04:42:06] *** Quits: erickt1 (erickt@8C9ECD8F.3A598286.F12515B4.IP) (Ping timeout)
[04:43:58] *** Joins: Jesin (Jessin_@moz-3AD6F09F.res.lehigh.edu)
[04:44:33] <Luqman> haha, i'm just trying to switch to window 23 :P
[04:47:43] *** Quits: nano (nano@moz-972880B.superkabel.de) (Ping timeout)
[04:50:22] *** Joins: brendan (brendaneic@A1F79A00.58B1B661.22B0E380.IP)
[04:51:15] *** Joins: strcat (strcat@moz-54F7FD49.cpe.net.cable.rogers.com)
[04:51:18] *** Joins: rusti (rusti@moz-54F7FD49.cpe.net.cable.rogers.com)
[04:55:37] *** Quits: enix (enix@moz-A50569DD.c3-0.slvr-ubr1.lnh-slvr.md.cable.rcn.com) (Quit: Konversation terminated!)
[04:59:05] *** Quits: sankha93 (Instantbir@6B0F5A3.D0B6154C.F44414AF.IP) (Ping timeout)
[05:00:43] <jensnockert> Wtf, it doesn't even work with regular structsâ€¦
[05:01:05] *** Joins: Uther (Instantbir@moz-1B244B05.hfc.dyn.abo.bbox.fr)
[05:01:12] <jensnockert> Something is seriously b0rkenâ€¦
[05:02:18] *** Quits: engla (engla@moz-DBD1D96E.cust.bredbandsbolaget.se) (Ping timeout)
[05:04:01] <jensnockert> It doesn't work cross-crate I think.
[05:04:07] *** Joins: azita (Azita@moz-C1FB2A8.hsd1.ca.comcast.net)
[05:07:55] <jensnockert> No, cross-crate tuple-like structs are brokenâ€¦
[05:08:05] <jensnockert> Good that I spent those two hours debuggingâ€¦
[05:08:16] *** Quits: alisdair (textual@moz-EBE9F394.bchsia.telus.net) (Quit: My MacBook Pro has gone to sleep. ZZZzzzâ€¦)
[05:08:38] <dbaupp> :(
[05:08:58] <dbaupp> I thought only unit structs were broken?
[05:09:21] *** Quits: qmx (qmx@moz-D6C3C2E6.qmx.me) (Ping timeout)
[05:10:07] *** Quits: erickt (Adium@49C4075F.3AC15C18.2321E71E.IP) (Quit: Leaving.)
[05:10:13] *** Joins: qmx (qmx@moz-D6C3C2E6.qmx.me)
[05:10:23] <jensnockert> dbaupp: This fails, https://gist.github.com/jensnockert/6036272
[05:10:38] <dbaupp> :(
[05:11:30] *** Joins: BizarreCake (BizarreCak@moz-361FE9B2.dynamic.barak-online.net)
[05:12:17] <Jeaye> dbaupp: Do things like each_char start from the current seek position, or the beginning?
[05:12:30] <dbaupp> Jeaye: current seek, I think
[05:12:48] <Jeaye> Docs don't say, but I agree that's what makes sense.
[05:13:13] <dbaupp> jensnockert: it looks like it's the generics
[05:13:22] <jensnockert> dbaupp: Yeah.
[05:13:23] <Jeaye> I see now that emulating operator >> for C++ fstreams is not an easy thing to do with so many types. >.<
[05:13:31] <dherman> hm, are the rules for Clone currently screwy?
[05:13:33] <jensnockert> dbaupp: But it should work.
[05:13:39] <dbaupp> jensnockert: yes
[05:13:48] <dbaupp> dherman: in what way?
[05:14:21] <dherman> dbaupp: it seems to be disallowing me to pass an argument of a parametric type in some contexts without making it Clone and calling .clone(), and in other contexts allowing it just fine
[05:14:32] <dherman> I can't figure out what the difference is
[05:14:38] <dbaupp> code?
[05:15:37] <dherman> impl<K: Eq + Ord + Clone, V> Node<K,V> {
[05:15:44] <dherman>     ... pub fn get(~self, k : K) { ... b.get(k) ... }  // works just fine
[05:16:00] <dherman>     ... pub fn has(~self, k : K) { ... b.has(k) ... } // error -- forces me to call .clone()
[05:16:14] <dherman> I forgot the return type annotations there
[05:16:16] <dherman> but that's the rough idea
[05:16:17] <dbaupp> jensnockert: https://github.com/mozilla/rust/issues/7804, https://github.com/mozilla/rust/issues/4545, https://github.com/mozilla/rust/issues/6899 :P
[05:16:22] *** Joins: snadon (chatzilla@moz-3BC727E8.mc.videotron.ca)
[05:16:33] *** Quits: snadon (chatzilla@moz-3BC727E8.mc.videotron.ca) (Quit: ChatZilla 0.9.90.1 [Firefox 23.0/20130715155216])
[05:16:49] *** Joins: alisdair (textual@moz-EBE9F394.bchsia.telus.net)
[05:16:59] <dbaupp> dherman: I guess, in get you only use `k` once, and in has, it can get used multiple times?
[05:17:13] <dbaupp> dherman: (does it complain about 'use of moved value'?)
[05:17:28] <jensnockert> dbaupp: Feels a bit silly that graydon told me this would work /o\
[05:17:29] <dherman> ohhhhh
[05:17:30] <dherman> yes
[05:17:39] <dherman> dbaupp: yep, that's the difference
[05:17:58] <dbaupp> jensnockert: I'll close those others in favour of yours, because it's neater.
[05:18:04] <dherman> so implicit moves is probably not at all what I want here, is it...
[05:18:09] <Luqman> dherman: also, ~self isn't as battle tested as say &self so you might run into issues there
[05:18:11] <jensnockert> dbaupp: They are different errors though.
[05:18:24] <dherman> Luqman: sadface
[05:18:29] <jensnockert> Could be that the error reporting changed though.
[05:18:32] <dbaupp> jensnockert: I'm fairly sure that's just because the error messages have changed
[05:18:43] <dbaupp> jensnockert: the BUG thing is pretty new
[05:18:53] <dherman> have we come to a resolution on the fate of implicit moves?
[05:19:07] <dherman> implicit moves in parametric code seems pretty hazardous to me
[05:19:10] <dherman> just based on this experience at least
[05:19:17] *** Quits: azita (Azita@moz-C1FB2A8.hsd1.ca.comcast.net) (Quit: azita)
[05:19:18] <aatch> ~self is pretty ok, it's unlikely you'll hit any errors related specifically to that.
[05:19:19] <dbaupp> dherman: you probably want &self though, otherwise Node will get consumed anytime you call .get or .has
[05:19:55] <dherman> oh right
[05:20:00] <strcat> dherman: rust doesn't allow use-after-move though
[05:20:16] <dherman> strcat: right but if you only happen to use it once, you won't get yelled at
[05:20:26] <dbaupp> and that's fine, right?
[05:20:27] <dherman> you moved it and maybe didn't mean to at all
[05:20:54] <strcat> dherman: there aren't really any consequences to moving it though
[05:21:04] <dherman> hm
[05:21:07] <strcat> since it's always a memcpy and all types are movable
[05:21:13] <dbaupp> strcat: except for a (possibyl large) memcpy
[05:21:18] <dbaupp> *possibly
[05:21:44] <Jeaye> There's no str::clear?
[05:21:53] <Jeaye> I don't see anything in lieu of it.
[05:22:03] <strcat> Jeaye: there's a clear method
[05:22:09] <strcat> it comes from Container, and afaik strings implement it
[05:22:17] <Jeaye> hmmm
[05:22:33] <Jeaye> rusti: let mut s = ~"foo"; s.clear(); s
[05:22:34] -rusti- <anon>:7:29: 7:39 error: type `~str` does not implement any method in scope named `clear`
[05:22:35] <dherman> strcat: so if I have a parameterized key type K
[05:22:35] -rusti- <anon>:7          let mut s = ~"foo"; s.clear(); s
[05:22:35] -rusti-                                       ^~~~~~~~~~
[05:22:35] -rusti- error: aborting due to previous error
[05:22:35] -rusti- application terminated with error code 101
[05:22:40] *** Quits: cubic_ (cubic@moz-FE5AD6C7.mc.videotron.ca) (Connection reset by peer)
[05:22:46] <dherman> strcat: and I forget to declare it as Clone
[05:22:53] <dherman> strcat: and the code I write just happens to move it
[05:23:07] <Jeaye> strcat: That's what I'm getting.
[05:23:34] <dherman> strcat: then I guess where this would come up is if someone's using a ~ type as the key type. but you probably wouldn't do that
[05:24:07] <dherman> strcat: so you can "move" things like a struct type, and that just basically copies with no other consequences?
[05:24:23] <dherman> i.e., move only really subtracts a resource with ~ ?
[05:24:58] <strcat> dherman: well a move of a ~ just does a shallow copy of the ptr
[05:25:10] <strcat> and prevents the source's destructor from running
[05:25:32] <dherman> hm
[05:25:38] <strcat> dherman: the only consequence is that after a move, you're prevented from still using it
[05:25:46] <dherman> that's a big consequence!
[05:25:49] <dherman> that's the whole point of move
[05:25:57] <strcat> dherman: yeah but you have to have ownership to move it
[05:26:03] <dherman> of course
[05:26:05] <strcat> so there's no externally visible consequence
[05:26:06] <Jeaye> strcat: So should this be an issue?
[05:26:16] <strcat> Jeaye: yes
[05:26:26] <Jeaye> Alright, I'll make it.
[05:26:27] <strcat> ~str should implement Container + Mutable
[05:27:13] <dherman> strcat: I don't buy what you're saying for things like parametric code, where it has external consequences for whoever *instantiates* the parametric type
[05:27:15] <dherman> but it's late
[05:27:18] <dherman> perhaps best to table this
[05:27:21] *** Quits: eholk (eholk@moz-9AB4D52F.hsd1.ut.comcast.net) (Quit: eholk)
[05:29:18] <dherman> actually I'm still confused about Clone
[05:29:29] <dherman> there are other places where I'm reusing a K multiple times
[05:29:31] <dherman> and it's not complaining
[05:29:40] <dherman> oh duh
[05:29:43] <dherman> I bet they're &
[05:31:01] <strcat> dherman: well the general guideline for generics is to take it by & if you don't need ownership
[05:31:03] <dbaupp> dherman: it doesn't have subtle external consequences, since it's all in the types. (The only time it gets strange is for implicitly copyable types.)
[05:31:15] <strcat> since some types are non-copyable, and for some copies are expensive (allocations)
[05:31:31] <strcat> if you need ownership (inserting into a map, needing to move from it) you just take it by-value
[05:31:50] <strcat> by handing you ownership, they know you're going to destroy it at some point or hand it back to them
[05:32:01] <dherman> sure sure
[05:32:26] <dherman> what I mean is, if I write a parametric abstraction
[05:32:35] <dherman> and it takes an argument of parametric type K
[05:32:37] <dherman> and it moves it
[05:32:43] <dherman> then someone who uses my abstraction
[05:32:50] <dherman> might have something that they didn't want moved
[05:32:53] <strcat> dherman: if it takes K they have to move into your function to call it though
[05:33:01] <strcat> they can't see whether you move it
[05:33:03] <dherman> not if instead I did a clone
[05:33:10] <dherman> oh
[05:33:15] <dherman> you're saying *they* have to do the clone or the move
[05:33:18] *** Quits: qmx (qmx@moz-D6C3C2E6.qmx.me) (Ping timeout)
[05:33:23] <strcat> dherman: well technically by-value is always a move (except for implicitly copyable things)
[05:33:28] <dherman> and then I can do whatever I want
[05:33:32] <strcat> if you do a clone, you're just making a value you can move
[05:33:36] <strcat> so by taking it by-value you can choose
[05:33:45] *** Joins: qmx (qmx@moz-D6C3C2E6.qmx.me)
[05:33:50] <dherman> gtg
[05:33:53] <dherman> baby crying
[05:33:56] *** Quits: dherman (dherman@moz-6CA476B1.hsd1.ca.comcast.net) (Quit: dherman)
[05:35:05] *** Quits: rusti (rusti@moz-54F7FD49.cpe.net.cable.rogers.com) (Ping timeout)
[05:35:27] *** Quits: strcat (strcat@moz-54F7FD49.cpe.net.cable.rogers.com) (Ping timeout)
[05:37:29] *** Quits: cowboyd (cowboyd@moz-DD0FF83.lightspeed.austtx.sbcglobal.net) (Client exited)
[05:37:40] *** Joins: ghrust (ghrust@79968228.6A2AE50.F3114085.IP)
[05:37:40] <ghrust> 01[13rust01] 15bors merged 06auto into 06master: 02http://git.io/4hjK4Q
[05:37:40] *** Parts: ghrust (ghrust@79968228.6A2AE50.F3114085.IP) ()
[05:38:14] *** Joins: cowboyd (cowboyd@moz-DD0FF83.lightspeed.austtx.sbcglobal.net)
[05:38:59] *** Joins: int3_ (int3_@moz-ABE52D50.hsd1.ca.comcast.net)
[05:40:01] *** Joins: ozten (ozten@moz-DD3B00B4.hsd1.wa.comcast.net)
[05:40:39] *** Joins: vk (chatzilla@moz-389FEE13.hsd1.ca.comcast.net)
[05:40:40] *** Joins: ghrust (ghrust@79968228.6A2AE50.F3114085.IP)
[05:40:40] <ghrust> 01[13rust01] 15bors pushed 0 new commits to 06auto: 02http://git.io/3aKQ6Q
[05:40:40] *** Parts: ghrust (ghrust@79968228.6A2AE50.F3114085.IP) ()
[05:40:42] *** Joins: ghrust (ghrust@9C8B94D4.6A2AE50.F3114085.IP)
[05:40:42] <ghrust> 01[13rust01] 15bors pushed 3 new commits to 06auto: 02http://git.io/AMzo-g
[05:40:42] <ghrust> 13rust/06auto 14dfa5595 15Keegan McAllister: rt: Diagnose bad alloc index in release_alloc with RUSTRT_TRACK_ALLOCATIONS
[05:40:42] <ghrust> 13rust/06auto 142d82d93 15Keegan McAllister: rt: Print alloc backtraces for bad release_alloc with RUSTRT_TRACK_ALLOCATIONS...
[05:40:42] <ghrust> 13rust/06auto 1491ebfbb 15bors: auto merge of #7859 : kmcallister/rust/rt-diag-messages, r=pcwalton...
[05:40:44] *** Parts: ghrust (ghrust@9C8B94D4.6A2AE50.F3114085.IP) ()
[05:40:48] *** Quits: int3_ (int3_@moz-ABE52D50.hsd1.ca.comcast.net) (Ping timeout)
[05:40:52] *** Joins: erickt (erickt@8C9ECD8F.3A598286.F12515B4.IP)
[05:41:58] *** Quits: carter (carter@moz-12C317EF.nyc.res.rr.com) (Quit: Textual IRC Client: www.textualapp.com)
[05:42:40] *** Quits: erickt (erickt@8C9ECD8F.3A598286.F12515B4.IP) (Ping timeout)
[05:43:21] *** Joins: quacker (Mibbit@moz-E5058588.austin.res.rr.com)
[05:45:36] *** Joins: strcat (strcat@moz-54F7FD49.cpe.net.cable.rogers.com)
[05:46:25] *** Joins: pnathan (Adium@B9840254.2CD8A5F8.477B877D.IP)
[05:46:51] *** Joins: robertknight (robertknig@moz-54528EE0.wby.mendeley.com)
[05:47:54] *** Joins: sankha93 (Instantbir@A8AB2822.465E20BB.27560D6E.IP)
[05:48:20] *** Quits: cowboyd (cowboyd@moz-DD0FF83.lightspeed.austtx.sbcglobal.net) (Client exited)
[05:52:03] *** Joins: rusti (rusti@moz-54F7FD49.cpe.net.cable.rogers.com)
[05:52:14] *** Joins: geomyidae (cole@DD6F7E3A.21468E9A.30200F38.IP)
[05:52:25] *** Quits: pnathan (Adium@B9840254.2CD8A5F8.477B877D.IP) (Ping timeout)
[05:52:33] *** Joins: dherman (dherman@moz-6CA476B1.hsd1.ca.comcast.net)
[05:52:34] *** ChanServ sets mode: +o dherman
[05:53:35] *** Quits: gavinb (gavinb@moz-CA19A0CF.vic.adsl.internode.on.net) (Quit: gavinb)
[05:54:55] *** Joins: robertknight_ (robertknig@moz-B6DD6E0B.range86-166.btcentralplus.com)
[05:56:37] <dherman> strcat: ok so that all makes sense. but here's my remaining question
[05:56:55] <dherman> if I have something that only wants temporary access to an argument of parametric type
[05:57:08] <dherman> then it seems I'm forced to use & and take a pointer indirection
[05:57:23] <dherman> even though the type might be instantiated at a base type like int, where the pointer indirection is a waste
[05:57:28] <dherman> is there no getting around that?
[05:57:33] <dherman> e.g., my has() method
[05:57:40] <dherman> only needs temporary access to the key
[05:57:58] <dherman> but if the key turns out to be int, it's a shame to have to take it by pointer
[05:58:21] <strcat> dherman: there isn't really a way around it, but as long as it gets inlined it will be optimized out
[05:58:28] <dherman> ah
[05:58:29] <dherman> ok
[05:58:32] <strcat> and I think if it's long enough to not be inlined it won't end up mattering
[05:58:46] <dherman> well in this case it's recursive
[05:58:50] <dherman> so it can't be fully inlined
[05:58:54] <strcat> dherman: ah
[05:59:10] <strcat> dherman: well, as long as it's an internal function it *could* still be optimized out (don't know if LLVM will)
[05:59:50] * strcat shrugs
[05:59:59] <strcat> there used to be those horrible mode things ;p
[06:00:07] <dherman> heh
[06:00:18] * dherman is not looking back
[06:01:24] *** Quits: ozten (ozten@moz-DD3B00B4.hsd1.wa.comcast.net) (Quit: ozten)
[06:03:16] *** Quits: aatch (aatch@moz-B437F499.pocketrent.com) (Quit: Leaving)
[06:03:38] <dherman> ha. I just realized my whole data structure makes no sense
[06:03:40] <dherman> sigh
[06:03:48] <dherman> this is a good exercise for me
[06:04:16] <dherman> I've spent so long at the 50k foot view, I can't actually *write* Rust
[06:04:27] *** Quits: zz_kimundi (kimundi@moz-5EF14CAB.dip0.t-ipconnect.de) (Ping timeout)
[06:05:10] <dherman> functional update doesn't work the same as it does in FP languages if you're using ~
[06:05:40] <dherman> actually it probably still makes sense
[06:05:50] <dherman> but it's not a general-purpose functional update
[06:05:52] *** Joins: mye (mye@moz-2FADFF39.dip0.t-ipconnect.de)
[06:06:50] <dherman> I should probably just make this mutable though
[06:08:07] <dherman> ok bed. I'll pick some more people's brains tomorrow
[06:08:09] *** Quits: dherman (dherman@moz-6CA476B1.hsd1.ca.comcast.net) (Quit: dherman)
[06:09:08] <Jeaye> rusti: let n = i32::from_str("42"); n
[06:09:10] -rusti- more than 5 lines of output, pastebinned: http://sprunge.us/fgbE
[06:10:48] <dbaupp> rusti: let n: i32 = FromStr::from_str("42"); n
[06:10:50] -rusti- more than 5 lines of output, pastebinned: http://sprunge.us/NaMi
[06:11:01] *** Quits: jaen (jaen@moz-36261275.internetdsl.tpnet.pl) (Ping timeout)
[06:11:03] <dbaupp> rusti: let n: i32 = FromStr::from_str("42").expect("invalid integer"); n
[06:11:06] -rusti- 42
[06:11:28] <dbaupp> rusti: let n = FromStr::from_str("42").expect("invalid integer"); 1i32 + n // type inference
[06:11:30] -rusti- 43
[06:11:40] <Jeaye> hmm
[06:11:52] <Jeaye> FromStr::from_str just feels so redundant.
[06:11:55] <dbaupp> yeah
[06:12:16] <Jeaye> Anyway, thanks. :)
[06:12:22] <dbaupp> this syntax is slowly (very slowly!) changing
[06:12:43] *** Quits: robertknight_ (robertknig@moz-B6DD6E0B.range86-166.btcentralplus.com) (Ping timeout)
[06:12:51] <dbaupp> (if/when "associated items" come)
[06:13:06] *** Joins: darkf (darkf@moz-F9058B8A.net)
[06:13:22] <Jeaye> expect() will fail!()?
[06:13:25] <darkf> how do I copy the contents of a &-ptr into a @-ptr?
[06:13:34] <Jeaye> darkf: .to_managed
[06:13:42] <darkf> Jeaye: :D
[06:13:57] <dbaupp> darkf: is it a &str or &[]?
[06:14:01] <dbaupp> or just a &T?
[06:14:05] <darkf> dbaupp: &[] from slice()
[06:14:15] <dbaupp> so you want a @[]?
[06:14:18] <darkf> right
[06:15:03] *** Joins: doener_ (doener@moz-121949B3.unitymediagroup.de)
[06:15:06] <Jeaye> rusti: let v = &[1, 2]; v.to_managed()
[06:15:07] -rusti- <anon>:7:26: 8:5 error: type `&[<VI1>]` does not implement any method in scope named `to_managed`
[06:15:07] -rusti- <anon>:7          let v = &[1, 2]; v.to_managed()
[06:15:07] -rusti- <anon>:8     };
[06:15:07] -rusti- error: aborting due to previous error
[06:15:07] -rusti- application terminated with error code 101
[06:15:12] <Jeaye> Oh dear.
[06:15:43] <dbaupp> well, standard disclaimer about avoiding @ (and doubly so for @[], it doesn't have much library support.)
[06:15:50] <dbaupp> but:
[06:16:16] <dbaupp> rusti: let v = &[1, 2]; std::at_vec::to_managed(v)
[06:16:17] -rusti- @[1, 2]
[06:16:22] <darkf> indeed, I would love to not use @, but I need multiple pointers to this and I believe they may have varying lifetimes
[06:16:39] <darkf> ah that will work :)
[06:16:51] *** Quits: alisdair (textual@moz-EBE9F394.bchsia.telus.net) (Quit: My MacBook Pro has gone to sleep. ZZZzzzâ€¦)
[06:17:13] <Jeaye> Should be a method. >.<
[06:17:17] *** Joins: int3_ (int3_@moz-ABE52D50.hsd1.ca.comcast.net)
[06:17:17] <dbaupp> yup
[06:17:21] <Jeaye> method all the things!
[06:17:23] <Jeaye> :)
[06:17:25] <dbaupp> at_vec and vec should be merged
[06:17:32] <darkf> yep!
[06:17:33] * dbaupp is tired of methodising things
[06:17:40] * dbaupp nominates Jeaye
[06:17:42] * darkf personally writes functions instead of methods because he is lazy
[06:17:42] <dbaupp> ;P
[06:17:45] * Jeaye pats dbaupp on the back.
[06:17:49] <Jeaye> You're doing a fine job. ;)
[06:18:05] *** Quits: quacker (Mibbit@moz-E5058588.austin.res.rr.com) (Quit: http://www.mibbit.com ajax IRC Client)
[06:18:26] * Jeaye uses @mut everywhere because he's lazy. Beat that.
[06:18:27] <darkf> although I do hate this extra::sort business.
[06:18:40] <Jeaye> In in-place quicksort works well for me.
[06:19:03] <Jeaye> Well, worked. I don't think I'm using it anymore.
[06:19:16] <darkf> well, I would like some methods to return a copy of the list, instead of mutating in-place.
[06:19:18] <dbaupp> darkf: yeah, there's two problems with that... the code sort-of sucks, and the whole awkward interface sucks 
[06:19:30] <darkf> :-\
[06:19:32] <dbaupp> darkf: x.clone().sort() (or whatever)
[06:20:13] <dbaupp> darkf: hopefully strcat will develop some genius RandomAccessIterators and this problem will be a thing of the past :)
[06:20:25] <darkf> sounds nice!
[06:20:36] * dbaupp is really looking forwart to writing v.mut_iter().chain(w.mut_iter()).sort()
[06:20:39] <darkf> how does `copy` differ from `clone()`, by the way?
[06:20:49] *** Joins: doomlord (doomlod@42802052.53E08B38.C3DDD137.IP)
[06:20:58] *** Quits: qmx (qmx@moz-D6C3C2E6.qmx.me) (Ping timeout)
[06:21:28] <strcat> darkf: copy/Copy was removed recently
[06:21:35] <strcat> so, Clone/clone is the only way ;p
[06:22:07] <darkf> oh, dear, that is nice then! I shall move replace my lazy usage of `copy`!
[06:22:12] <strcat> Clone is a copy that's as shallow as possible (copies everything the type owns directly) and DeepClone traverses through shared data (@, Rc)
[06:23:42] <doomlord> is there a wiki/bikeshed on the idea of removing '@'
[06:24:22] *** Joins: qmx (qmx@moz-D6C3C2E6.qmx.me)
[06:25:09] <doomlord> where is it appropriate to register an opinion on the issue
[06:25:19] <ChrisMorgan> What was the actual difference between Copy/copy x and Clone/x.clone()?
[06:25:28] *** Joins: Deewiant (deewiant@moz-C015B7F8.iki.fi)
[06:27:07] <strcat> Copy only worked for built-in types
[06:27:18] <strcat> as in... you couldn't write a custom Copy impl
[06:27:27] <strcat> and types with destructors aren't implicitly copyable
[06:28:17] <strcat> anyway it removes the concept of explicit copies from the compiler
[06:31:31] *** Joins: zz_kimundi (kimundi@moz-251E23B5.dip0.t-ipconnect.de)
[06:31:53] *** zz_kimundi is now known as kimundi
[06:33:12] <dbaupp> doomlord: mailing list
[06:34:54] *** Joins: strcat1 (strcat@moz-54F7FD49.cpe.net.cable.rogers.com)
[06:35:19] *** Quits: strcat (strcat@moz-54F7FD49.cpe.net.cable.rogers.com) (Ping timeout)
[06:35:28] *** Quits: rusti (rusti@moz-54F7FD49.cpe.net.cable.rogers.com) (Ping timeout)
[06:35:50] *** Joins: thpickert (thpickert@moz-24816453.tng.de)
[06:36:25] *** Joins: rusti (rusti@moz-54F7FD49.cpe.net.cable.rogers.com)
[06:36:57] *** Joins: eatkinson (eatkinson@moz-AD233F1B.dia.static.qwest.net)
[06:39:59] *** Joins: Ms2ger (Ms2ger@moz-12781595.adsl-dyn.isp.belgacom.be)
[06:41:09] *** Joins: jaen (jaen@moz-36261275.internetdsl.tpnet.pl)
[06:41:19] *** Joins: erickt (erickt@8C9ECD8F.3A598286.F12515B4.IP)
[06:43:18] *** Quits: erickt (erickt@8C9ECD8F.3A598286.F12515B4.IP) (Ping timeout)
[06:45:45] *** Quits: jensnockert (jensnocker@moz-C5F27039.cust.bredband2.com) (Input/output error)
[06:46:09] *** Joins: gavinb (gavinb@moz-CA19A0CF.vic.adsl.internode.on.net)
[06:46:48] *** Quits: gavinb (gavinb@moz-CA19A0CF.vic.adsl.internode.on.net) (Quit: gavinb)
[06:47:20] *** Joins: jensnockert (jensnocker@moz-C5F27039.cust.bredband2.com)
[06:52:09] <doomlord> whatever issues there may be now it seems ~/@ mean you have convinient syntax for all extremes of efficiency/convinience, that should be kept IMO
[06:52:44] *** Joins: jviereck (Adium@moz-A034D4DA.dclient.hispeed.ch)
[06:53:29] <Jeaye> rusti: let to_int = |x, s| { x = FromStr::from_str(s); }; let mut x: i32 = 0; let s = ~"42"; to_int(x, s); x
[06:53:31] -rusti- more than 5 lines of output, pastebinned: http://sprunge.us/NKWO
[06:53:44] <doomlord> i'm thinking of mixed lanugae projects. people use c++/python or c++/c#  in conjunction. perhaps rust can avoid that need. you simply have layers that stick to one style or the other.
[06:53:54] <Jeaye> rusti: let to_int = |x, s| { x = FromStr::from_str(s).get(); }; let mut x: i32 = 0; let s = ~"42"; to_int(x, s); x
[06:53:56] -rusti- <anon>:7:111: 7:112 error: mismatched types: expected `&str` but found `~str` (str storage differs: expected & but found ~)
[06:53:56] -rusti- <anon>:7          let to_int = |x, s| { x = FromStr::from_str(s).get(); }; let mut x: i32 = 0; let s = ~"42"; to_int(x, s); x
[06:53:56] -rusti-                                                                                                                         ^
[06:53:56] -rusti- error: aborting due to previous error
[06:53:57] -rusti- application terminated with error code 101
[06:53:58] *** Quits: jaen (jaen@moz-36261275.internetdsl.tpnet.pl) (Ping timeout)
[06:54:43] <Jeaye> How can I get s into there as a &str and x into there as a &mut i32?
[06:55:15] <dbaupp> rusti: let to_int = |x, s| { *x = FromStr::from_str(s).get(); }; let mut x: i32 = 0; let s = ~"42"; to_int(&mut x, s); x
[06:55:17] -rusti- more than 5 lines of output, pastebinned: http://sprunge.us/HcWM
[06:55:26] <Jeaye> Ahh
[06:55:35] <dbaupp> rusti: let to_int = |x: &mut i32, s: &str| { *x = FromStr::from_str(s).get(); }; let mut x: i32 = 0; let s = ~"42"; to_int(&mut x, s); x
[06:55:37] -rusti- 42
[06:55:59] <Jeaye> Oh, I didn't realize they could be specified in the ||
[06:56:01] <Jeaye> Sexy.
[06:56:27] <Jeaye> Have to dereference it, ah. Thanks, dbaupp :)
[06:56:48] <Jeaye> This'll clean up my parsing quite a bit.
[06:58:03] <dbaupp> np :)
[06:58:54] <Luqman> sadly seems like it'll take a while for bors to go through the long queue
[07:00:37] <dbaupp> always!
[07:00:48] <dbaupp> wow, it's really long again
[07:00:59] *** Quits: sankha93 (Instantbir@A8AB2822.465E20BB.27560D6E.IP) (Quit: He will be back!)
[07:03:19] <Luqman> yep
[07:05:02] <ChrisMorgan> It's the end of the week.
[07:13:11] <ChrisMorgan> dbaupp: hang on, why has request reading gone back up from 12% to 64% and request rate dropped to 900 requests per second? Ah! I had removed -O. There, back to over 2250. Clearly -O does good work in my request reading!
[07:13:44] <dbaupp> happy to help ;P
[07:14:26] <ChrisMorgan> Compile time is increased by a few times, but what is that?
[07:14:54] <Jeaye> -O gives my voxelization algorithm a 10x speed increase.
[07:15:09] <Jeaye> When I first used it, I thought I enabled -magic
[07:15:48] <dbaupp> haha
[07:15:57] <ChrisMorgan> Jeaye: that'd be --magic. Or maybe ++magic
[07:16:08] <Jeaye> :)
[07:16:19] <dbaupp> (these huge increases are mainly because Rust's unoptimised IR is ridiculous, so it's not exactly a good thing :( )
[07:16:34] <strcat1> -O will always be huge for rust (and for C++) though
[07:16:41] *** strcat1 is now known as strcat
[07:16:57] <strcat> lots of abstraction/wrappers that are cost-free *when optimized*
[07:17:11] <dbaupp> true
[07:20:03] *** Quits: rbancroft (rumble@moz-4E8E0D7F.cg.shawcable.net) (Ping timeout)
[07:20:06] *** Joins: rbancroft (rumble@moz-4E8E0D7F.cg.shawcable.net)
[07:22:39] *** Joins: ghrust (ghrust@CFE85B59.6A2AE50.F3114085.IP)
[07:22:39] <ghrust> 01[13rust01] 15bors merged 06auto into 06master: 02http://git.io/AMzo-g
[07:22:39] *** Parts: ghrust (ghrust@CFE85B59.6A2AE50.F3114085.IP) ()
[07:23:24] <dbaupp> ChrisMorgan: you can go ~str -> ~[u8] without any allocations, btw.
[07:24:19] <dbaupp> rusti: let mut b = s.as_bytes_consume_with_null(); (b.pop(), b)
[07:24:20] -rusti- <anon>:7:21: 7:22 error: unresolved name `s`.
[07:24:20] -rusti- <anon>:7          let mut b = s.as_bytes_consume_with_null(); (b.pop(), b)
[07:24:20] -rusti-                               ^
[07:24:20] -rusti- error: aborting due to previous error
[07:24:20] -rusti- application terminated with error code 101
[07:24:32] <dbaupp> rusti: let s = ~"foo"; let mut b = s.as_bytes_consume_with_null(); (b.pop(), b)
[07:24:33] -rusti- <anon>:7:37: 7:68 error: type `~str` does not implement any method in scope named `as_bytes_consume_with_null`
[07:24:33] -rusti- <anon>:7          let s = ~"foo"; let mut b = s.as_bytes_consume_with_null(); (b.pop(), b)
[07:24:33] -rusti-                                               ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
[07:24:34] -rusti- error: aborting due to previous error
[07:24:35] -rusti- application terminated with error code 101
[07:24:48] <dbaupp> rusti: let s = ~"foo"; let mut b = s.as_bytes_with_null_consume(); (b.pop(), b)
[07:24:50] -rusti- (0, ~[102, 111, 111])
[07:25:38] *** Joins: ghrust (ghrust@C621748.6A2AE50.F3114085.IP)
[07:25:38] <ghrust> 01[13rust01] 15bors pushed 0 new commits to 06auto: 02http://git.io/z9R-rA
[07:25:38] *** Parts: ghrust (ghrust@C621748.6A2AE50.F3114085.IP) ()
[07:25:39] <dbaupp> ChrisMorgan: (this is talking about your to_owned_bytes function: it could/should take &str as it is currently written.)
[07:25:39] *** Joins: ghrust (ghrust@5FEF1C87.6A2AE50.F3114085.IP)
[07:25:39] <ghrust> 01[13rust01] 15bors pushed 3 new commits to 06auto: 02http://git.io/QhvHDw
[07:25:39] <ghrust> 13rust/06auto 142fbd9f0 15Tim Chevalier: testsuite: Add compile-fail test for #5883
[07:25:39] <ghrust> 13rust/06auto 140ce9135 15Tim Chevalier: testsuite: Test for #6153, closes #6153
[07:25:39] <ghrust> 13rust/06auto 1406fec52 15bors: auto merge of #7863 : catamorphism/rust/issue-5883, r=catamorphism
[07:25:41] *** Parts: ghrust (ghrust@5FEF1C87.6A2AE50.F3114085.IP) ()
[07:26:52] <dbaupp> ChrisMorgan: in fact looking at it... doesn't `socket.write(bytes!("\r\n"))` & `socket.write(self.content.as_bytes())` (etc) work?
[07:29:16] *** Quits: z0w0 (zack@A76ECE44.E8D776F0.D76C0449.IP) (Client exited)
[07:29:30] *** Joins: azita (Azita@moz-C1FB2A8.hsd1.ca.comcast.net)
[07:29:34] *** Joins: lpapp (lpapp@759BF865.314C6558.9EF092A5.IP)
[07:31:48] *** Quits: doener (bs@moz-AA189A5A.unitymedia.biz) (Quit: leaving)
[07:33:09] <dbaupp> ChrisMorgan: if you use fn comma_join<S: Str>(s: &[S]) -> ~str, then you don't have to convert &[~str] to ~[&str] to call it. (it should Just Work.)
[07:35:05] *** Quits: rusti (rusti@moz-54F7FD49.cpe.net.cable.rogers.com) (Ping timeout)
[07:35:05] <dbaupp> ChrisMorgan: (I'm sitting down and reading the rusthttpserver code, if you didn't notice ;P ... looks pretty good.)
[07:35:31] *** Quits: strcat (strcat@moz-54F7FD49.cpe.net.cable.rogers.com) (Ping timeout)
[07:36:06] <dbaupp> ChrisMorgan: oh, another one: `comma_split<'a>(value: &'a str) -> ~[&'a str]`, and skip the .to_owned() call.
[07:36:11] *** Quits: eatkinson (eatkinson@moz-AD233F1B.dia.static.qwest.net) (Quit: eatkinson)
[07:37:00] *** Parts: lpapp (lpapp@759BF865.314C6558.9EF092A5.IP) ()
[07:38:08] <ChrisMorgan> dbaupp: socket buf in old rt took ~[u8], new one takes &[u8], hence to_owned_bytes.
[07:38:19] <dbaupp> ChrisMorgan: aha
[07:39:07] <ChrisMorgan> Anyway, I'm heading off for the weekend in about 50 minutes, still got to do almost all my packing and eat tea first.
[07:39:15] *** Quits: Jeaye (Jeaye@moz-FD505E54.hsd1.ca.comcast.net) (Quit: zzz)
[07:41:05] *** Joins: eatkinson (eatkinson@moz-AD233F1B.dia.static.qwest.net)
[07:41:48] *** Joins: erickt (erickt@8C9ECD8F.3A598286.F12515B4.IP)
[07:43:39] *** Quits: azita (Azita@moz-C1FB2A8.hsd1.ca.comcast.net) (Quit: azita)
[07:43:39] *** Quits: erickt (erickt@8C9ECD8F.3A598286.F12515B4.IP) (Ping timeout)
[07:44:40] *** Quits: james4k (james@moz-E7990244.consolidated.net) (Ping timeout)
[07:45:06] *** Joins: strcat (strcat@moz-54F7FD49.cpe.net.cable.rogers.com)
[07:47:32] <dbaupp> strcat: am I correct in this comment https://github.com/mozilla/rust/issues/4991#issuecomment-21233128 ?
[07:47:54] <dbaupp> strcat: (don't want to be sending someone up a garden path.)
[07:47:56] <strcat> dbaupp: well you can use a bit of the ptr
[07:48:01] <strcat> but it depends on the arch
[07:48:09] <strcat> little vs big endian
[07:48:32] <strcat> libc++'s implementation of std::string uses a small string
[07:48:38] <strcat> it uses a bit of the ptr
[07:48:50] <dbaupp> are the fields in that order?
[07:49:06] <strcat> does really matter as long as the ptr is first or last
[07:49:14] <strcat> hm
[07:49:46] <strcat> anyway libc++ is a good place to look
[07:49:48] <dbaupp> no, I was just wondering?
[07:49:50] <strcat> because that's how we would do it
[07:49:56] <dbaupp> that's clang's one, right?
[07:50:08] <strcat> well, libc++ is part of the LLVM project - so kind of
[07:50:15] <dbaupp> right, whatever ;P
[07:50:36] <strcat> dbaupp: http://ix.io/6JB string header from libc++ 3.3
[07:50:39] *** Quits: Jesin (Jessin_@moz-3AD6F09F.res.lehigh.edu) (Quit: Leaving)
[07:51:02] *** Joins: rusti (rusti@moz-54F7FD49.cpe.net.cable.rogers.com)
[07:51:20] *** Joins: pnathan (Adium@B9840254.2CD8A5F8.477B877D.IP)
[07:51:59] *** Quits: brendan (brendaneic@A1F79A00.58B1B661.22B0E380.IP) (Ping timeout)
[07:52:40] *** Joins: victorporof (victorporo@39C73ED0.834833CE.4A6B528C.IP)
[07:53:02] *** Quits: pnathan (Adium@B9840254.2CD8A5F8.477B877D.IP) (Ping timeout)
[07:53:08] <strcat> dbaupp: they just have endian-specific masks afaict
[07:53:51] *** Quits: strcat (strcat@moz-54F7FD49.cpe.net.cable.rogers.com) (Quit: sleep)
[07:56:48] <doener_> https://gist.github.com/dotdash/3d9ab98ac7b44b63c663 -- almost there. Got rid of the extra block for allocas, now there's only the always-used alloca for immediate return values left to be made optional in regular functions and I will be happy with the code for that function
[07:58:17] *** Quits: BizarreCake (BizarreCak@moz-361FE9B2.dynamic.barak-online.net) (Connection reset by peer)
[07:58:24] <doener_> well, except for the fact I trigger that @ptr memleak again... 
[07:58:59] *** Quits: eatkinson (eatkinson@moz-AD233F1B.dia.static.qwest.net) (Quit: eatkinson)
[08:05:53] *** Joins: dwhyte1 (dwhyte@ED9190FB.B72E355F.7BF4A4B0.IP)
[08:06:02] *** Quits: dwhyte (dwhyte@ED9190FB.B72E355F.7BF4A4B0.IP) (Ping timeout)
[08:08:22] *** Joins: nwf (nwf@moz-E26BF8D7.rr.ietfng.org)
[08:08:54] *** Quits: qmx (qmx@moz-D6C3C2E6.qmx.me) (Ping timeout)
[08:13:02] *** Joins: qmx (qmx@moz-D6C3C2E6.qmx.me)
[08:21:31] *** Joins: pnathan (Adium@B9840254.2CD8A5F8.477B877D.IP)
[08:22:16] *** Joins: sigma (sigma@51C589B3.EF2694B5.DFAC6AA7.IP)
[08:26:46] *** Quits: pnathan (Adium@B9840254.2CD8A5F8.477B877D.IP) (Ping timeout)
[08:29:40] *** Joins: CarpNet (ac@moz-FD24B77.sohonet.co.uk)
[08:30:11] *** Quits: ChrisMorgan (chris@moz-6AC741CA.static.tpgi.com.au) (Ping timeout)
[08:30:32] *** Joins: sk (sk@61A494B3.BA40E8A.AAC02D62.IP)
[08:34:44] *** Quits: rusti (rusti@moz-54F7FD49.cpe.net.cable.rogers.com) (Ping timeout)
[08:35:28] *** Joins: SimonSapin (simon@88F51059.F3BBB17D.144F44FA.IP)
[08:38:24] *** Quits: pnkfelix|rcirc (pnkfelix@moz-43495417.fbx.proxad.net) (Input/output error)
[08:39:56] *** Joins: BizarreCake (BizarreCak@moz-361FE9B2.dynamic.barak-online.net)
[08:40:41] *** Joins: fabiand (fabiand@moz-F2EF568F.adsl.alicedsl.de)
[08:42:16] *** Joins: erickt (erickt@8C9ECD8F.3A598286.F12515B4.IP)
[08:43:40] *** Joins: lucian (lucian@6B2B4644.4304AE1E.CE5E78F6.IP)
[08:44:09] *** Quits: jensnockert (jensnocker@moz-C5F27039.cust.bredband2.com) (Ping timeout)
[08:44:09] *** Quits: erickt (erickt@8C9ECD8F.3A598286.F12515B4.IP) (Ping timeout)
[08:45:28] *** Quits: lucian (lucian@6B2B4644.4304AE1E.CE5E78F6.IP) (Ping timeout)
[08:46:06] *** Quits: ross (ross@moz-8A84103E.br.br.cox.net) (Quit: )
[08:48:11] *** Joins: lucian (lucian@6B2B4644.4304AE1E.CE5E78F6.IP)
[08:48:35] *** Joins: jensnockert (jensnocker@moz-C5F27039.cust.bredband2.com)
[08:51:38] *** Joins: rusti (rusti@moz-54F7FD49.cpe.net.cable.rogers.com)
[08:53:18] *** Joins: mindginative (mindginati@moz-BF128182.dyn.cust.vf.net.nz)
[08:53:50] *** Joins: aatch (aatch@moz-2BB0AC01.cable.telstraclear.net)
[08:54:00] *** Quits: vk (chatzilla@moz-389FEE13.hsd1.ca.comcast.net) (Quit: ChatZilla 0.9.90.1 [Firefox 23.0/20130715155216])
[08:54:29] *** Quits: sk (sk@61A494B3.BA40E8A.AAC02D62.IP) (Broken pipe)
[08:55:05] *** Joins: Jesin (Jessin_@moz-3AD6F09F.res.lehigh.edu)
[09:00:20] *** Quits: aatch (aatch@moz-2BB0AC01.cable.telstraclear.net) (Client exited)
[09:01:05] *** Joins: true_droid (Adium@moz-123FD9B8.beck.volia.net)
[09:05:07] *** Joins: q66 (q66@6EE9DE40.46454B5D.33AABD5F.IP)
[09:07:37] *** Joins: ghrust (ghrust@DE823A67.6A2AE50.F3114085.IP)
[09:07:37] <ghrust> 01[13rust01] 15bors merged 06auto into 06master: 02http://git.io/QhvHDw
[09:07:37] *** Parts: ghrust (ghrust@DE823A67.6A2AE50.F3114085.IP) ()
[09:10:38] *** Joins: ghrust (ghrust@C8693FCB.6A2AE50.F3114085.IP)
[09:10:38] <ghrust> 01[13rust01] 15bors pushed 0 new commits to 06auto: 02http://git.io/9-GWWA
[09:10:38] *** Parts: ghrust (ghrust@C8693FCB.6A2AE50.F3114085.IP) ()
[09:10:39] *** Joins: ghrust (ghrust@C8693FCB.6A2AE50.F3114085.IP)
[09:10:39] <ghrust> 01[13rust01] 15bors pushed 26 new commits to 06auto: 02http://git.io/C0B5-g
[09:10:39] <ghrust> 13rust/06auto 14976d7a5 15Michael Woerister: debuginfo: Began refactoring of composite type handling.
[09:10:39] <ghrust> 13rust/06auto 141b20831 15Michael Woerister: debuginfo: Renamed *reference-to-* test cases to *borrowed-*
[09:10:39] <ghrust> 13rust/06auto 147a31a3e 15Michael Woerister: debuginfo: Removed some misleading comments from test cases.
[09:10:41] *** Parts: ghrust (ghrust@C8693FCB.6A2AE50.F3114085.IP) ()
[09:11:35] *** Joins: aatch (aatch@moz-2BB0AC01.cable.telstraclear.net)
[09:15:06] *** Quits: jviereck (Adium@moz-A034D4DA.dclient.hispeed.ch) (Quit: Leaving.)
[09:15:13] *** Quits: victorporof (victorporo@39C73ED0.834833CE.4A6B528C.IP) (Quit: victorporof)
[09:15:24] *** Quits: dwhyte1 (dwhyte@ED9190FB.B72E355F.7BF4A4B0.IP) (Quit: Leaving.)
[09:15:28] *** Quits: jensnockert (jensnocker@moz-C5F27039.cust.bredband2.com) (Input/output error)
[09:17:38] *** Quits: noam (noam@F6B530A7.720527A7.416762B.IP) (Ping timeout)
[09:18:15] *** Joins: davbo (dave@moz-3FFA637C.oucs.ox.ac.uk)
[09:18:59] *** Joins: noam (noam@F6B530A7.720527A7.416762B.IP)
[09:21:29] *** Joins: pnkfelix (pnkfelix@87C1F78E.1DE10CA8.D8E68FF6.IP)
[09:25:36] *** Joins: ghrust (ghrust@AD60B2E3.6A2AE50.F3114085.IP)
[09:25:36] <ghrust> 01[13rust01] 15bors 04force-pushed 06auto from 14d5a4181 to 1406fec52: 02http://git.io/N3iJvQ
[09:25:36] *** Parts: ghrust (ghrust@AD60B2E3.6A2AE50.F3114085.IP) ()
[09:25:38] *** Joins: ghrust (ghrust@F6EE6DE3.6A2AE50.F3114085.IP)
[09:25:38] <ghrust> 01[13rust01] 15bors pushed 2 new commits to 06auto: 02http://git.io/5nHCPA
[09:25:38] <ghrust> 13rust/06auto 14a1cd142 15Felix S. Klock II: remove non-portable sed invocation as brson says we no longer have clang in tree.
[09:25:38] <ghrust> 13rust/06auto 1432586fa 15bors: auto merge of #7868 : pnkfelix/rust/issue6929-remove-bogus-sed-invoke-from-configure, r=brson...
[09:25:38] *** Parts: ghrust (ghrust@F6EE6DE3.6A2AE50.F3114085.IP) ()
[09:31:22] *** Quits: tcr (tcr@D26BCFC9.C2203064.EDCE493E.IP) (Client exited)
[09:35:22] *** Quits: rusti (rusti@moz-54F7FD49.cpe.net.cable.rogers.com) (Ping timeout)
[09:36:33] <dbaupp> nmatsakis: nice slides :)
[09:39:10] *** Quits: jdm (jdm@92FB48CA.8B5E9DF.9A8C35B4.IP) (Quit: Lost terminal)
[09:41:08] *** Joins: Caspy7_away (chatzilla@A077DB81.8D4B4332.33F321FD.IP)
[09:41:15] <Caspy7_away> anybody around?
[09:41:37] <Caspy7_away> I have what is probably a silly question.
[09:41:55] <aatch> Caspy7_away, our specialty, shoot
[09:42:04] *** Caspy7_away is now known as Caspy7
[09:42:44] *** Joins: erickt (erickt@8C9ECD8F.3A598286.F12515B4.IP)
[09:42:47] <Caspy7> would it be possible to use something like our current JS engines with Servo?
[09:43:10] <dbaupp> I think that's literally what's happening now
[09:43:13] *** Quits: Uther (Instantbir@moz-1B244B05.hfc.dyn.abo.bbox.fr) (Ping timeout)
[09:43:28] <dbaupp> (#servo would be more appropriate, btw :) )
[09:43:43] <dbaupp> although, I'm not actually sure they're running JS yet.
[09:44:10] <Caspy7> dbaupp: ah, didn't know the channel existed
[09:44:21] <dbaupp> (more appropriate in the sense more people will know what they're talking about.)
[09:44:23] * dbaupp doesn't
[09:44:34] *** Quits: erickt (erickt@8C9ECD8F.3A598286.F12515B4.IP) (Ping timeout)
[09:45:34] *** Quits: km (quassel@FDBAF0A0.DBF71E41.29C67456.IP) (Ping timeout)
[09:45:45] <Caspy7> I guess what I'm unclear on is how Servo may fit in with Mozilla/Firefox's future
[09:45:59] <aatch> Caspy7, right now, servo is a research project.
[09:46:31] <aatch> there is, at this time, no specific goal of replacing Gecko
[09:46:44] * Caspy7 *nods*
[09:47:29] *** Joins: km (quassel@FDBAF0A0.DBF71E41.29C67456.IP)
[09:48:04] <aatch> Caspy7, I'm not involved with servo, I just hear things because I hang out here.
[09:48:14] *** Quits: Jesin (Jessin_@moz-3AD6F09F.res.lehigh.edu) (Quit: Leaving)
[09:48:31] * dbaupp is the same
[09:48:32] <Caspy7> ok
[09:48:57] *** Joins: sk (sk@A298A44C.54A580E3.78DD174B.IP)
[09:49:07] <aatch> Caspy7, but my understanding is that it is as much seeing what a project like servo needs from a language as much as it is a serious attempt at a new rendering engine
[09:49:12] <Caspy7> you see what I mean though?  Some writers say that it's the upcoming replacement.  But if it's not, then what will be its fruits?
[09:49:35] <aatch> Caspy7, well servo itself has helped drive a lot of the design of rust
[09:50:16] <Caspy7> aatch: right...but then what shall we do with Rust?  Write parts of Firefox in it?
[09:50:44] <aatch> Caspy7, all sorts of stuff. There are *kernel* projects written in Rust.
[09:50:52] <dbaupp> Caspy7: I believe Servo is exploring the design/problem space of next-gen highly concurrent browsers
[09:51:04] <dbaupp> (i.e. that's what the research goal is.)
[09:51:18] <aatch> toys right now, to be sure, but that's like asking what we should do with C++
[09:51:29] <aatch> "Whatever the hell you want"
[09:51:32] <Caspy7> Exploration as the goal...very Star Trek
[09:52:01] <aatch> Caspy7, it's what Mozilla Research is there for
[09:52:20] *** Joins: rusti (rusti@moz-54F7FD49.cpe.net.cable.rogers.com)
[09:53:37] <Caspy7> I'll assume it's a *continuing* mission rather than a 5 year mission
[09:55:53] <Caspy7> thanks for your thoughts
[09:56:57] <aatch> Caspy7, no problem.
[09:57:13] <aatch> if you manage to catch one of the core devs, many of them work on servo too.
[09:57:22] <aatch> pcwalton and brson especially.
[09:57:55] <Caspy7> ok, cool, thanks
[09:59:24] *** Quits: doomlord (doomlod@42802052.53E08B38.C3DDD137.IP) (Ping timeout)
[10:01:11] *** Joins: doomlord (doomlod@42802052.53E08B38.C3DDD137.IP)
[10:01:38] <dbaupp> heh apparently `(function(i) i+1)` works in firefox's js (but not chromium)
[10:01:50] * dbaupp has been writing too much Rust
[10:01:57] *** Joins: pnkfelix|rcirc (pnkfelix@87C1F78E.1DE10CA8.D8E68FF6.IP)
[10:02:26] *** Joins: jviereck (Adium@moz-A034D4DA.dclient.hispeed.ch)
[10:02:45] <aatch> Yay, new desktop all set up properly now!
[10:02:53] *** Quits: jviereck (Adium@moz-A034D4DA.dclient.hispeed.ch) (Quit: Leaving.)
[10:03:20] <dbaupp> aatch: \o/
[10:03:36] <dbaupp> how long does it take to do a bootstrap?
[10:03:53] <aatch> dbaupp, not sure, I was doing other things while it was bootstrapping.
[10:03:56] <aatch> not long though.
[10:04:03] <dbaupp> haha, awesome
[10:04:27] * dbaupp is expecting to see regular huge patches from aatch
[10:04:31] <dbaupp> ;P
[10:05:48] * aatch is doing a full build under `time`
[10:05:54] <aatch> (not llvm)
[10:06:49] * dbaupp has his shell prompt set to show him the time taken for the last command
[10:07:04] <aatch> dbaupp, that's pretty cool.
[10:07:21] <dbaupp> aatch: it's a huge hack :S
[10:07:24] * dbaupp is good at hacks
[10:07:34] * dbaupp is bad at anything other than hacks
[10:07:49] <aatch> dbaupp, so that's why you do so much Rust!
[10:07:54] <dbaupp> heh :D
[10:08:00] <dbaupp> of course!
[10:09:54] *** Quits: BizarreCake (BizarreCak@moz-361FE9B2.dynamic.barak-online.net) (Connection reset by peer)
[10:11:00] *** Joins: Earnestly (earnest@2AB30F53.FB5005.2BCC804A.IP)
[10:12:24] <nmatsakis> dbaupp: thanks
[10:12:38] * aatch is going to play dwarf fortress to give his comp a workout.
[10:13:08] *** Quits: Caspy7 (chatzilla@A077DB81.8D4B4332.33F321FD.IP) (Client exited)
[10:18:18] <aatch> dbaupp, 12mins from stage0-3
[10:19:14] <true_droid> hi guys, does Rust always copy the return value here or is it usually optimized away (elided)? https://gist.github.com/alco/6038161#file-monster-rs-L21
[10:20:27] <aatch> true_droid, in that specific case, it might do any number of things because the struct is so small
[10:21:28] *** Quits: mindginative (mindginati@moz-BF128182.dyn.cust.vf.net.nz) (Quit: brb)
[10:21:31] <aatch> Also, you can do ~Monster::new() to get an owned-pointer to a monster
[10:21:35] <doomlord> giving in to NIH and familiarity i've started to try and make my own C++ subset clang based bindings generator https://github.com/dobkeratops/cpp2rust 
[10:22:24] <aatch> no need to have a separate one especially for owned.
[10:22:38] *** Joins: novabyte (Instantbir@moz-3E0F9699.cable.virginmedia.com)
[10:22:48] <true_droid> aatch: ok, I have two follow-up questions: 1) what if the struct were large? 2) does ~Monster::new() still copy the same way Monster::new() does?
[10:22:50] <doomlord> ( i was trying to hack bindgen to do this but finding it hard to go through the ast api, and comprehend their rust wrapper for clang.. here i'm pretty much just pretty printing the clang C++ ast in rust syntax myself)
[10:23:33] <doomlord> (same idea, i intend to spit out C++ -> C wrappers, and rust side, impl's for methods that call the C wrappers..)
[10:24:10] <aatch> true_droid, well if it's large, a pointer is passed to the function for it to place the return value into.
[10:24:54] <aatch> though the optimization doesn't work in all cases, it definately does in the case you showed.
[10:25:03] <true_droid> aatch: hm, that's interesting
[10:25:23] <aatch> (as in sometimes it copies into the space after construction, but it's a tricky case to handle)
[10:25:59] <aatch> true_droid, this means that if you call it like ~Monster::new(), then `new` would be passed a pointer to heap-allocated memory
[10:25:59] *** Joins: pnathan (Adium@B9840254.2CD8A5F8.477B877D.IP)
[10:29:26] <true_droid> aatch: thanks, that's delicious food for thought
[10:30:37] *** Joins: Axord (xord@moz-C3CCF156.lsanca.dsl-w.verizon.net)
[10:31:59] *** Quits: pnathan (Adium@B9840254.2CD8A5F8.477B877D.IP) (Ping timeout)
[10:32:07] <doener_> aatch: when does it do that?
[10:32:20] <aatch> doener_, does what?
[10:32:22] *** Joins: MEC (dsqldsld@73870F26.CC75AD1F.96B18764.IP)
[10:32:33] <doener_> aatch: copying to the return pointer after construction
[10:33:01] <aatch> doener_, if the value is constructed, then returned, rather than it being the same expression.
[10:33:17] <aatch> so `{ let a = Foo { ... }; a }`
[10:33:38] <aatch> won't construct `Foo` into the return pointer.
[10:34:00] <aatch> instead the `a` causes a copy into return pointer.
[10:35:03] *** Quits: rusti (rusti@moz-54F7FD49.cpe.net.cable.rogers.com) (Ping timeout)
[10:35:32] <SimonSapin> aatch: could rustc or llvm optimize this away?
[10:35:51] <aatch> SimonSapin, sometimes, but not often. 
[10:35:57] <doener_> aatch: hm, maybe that should trigger a move?
[10:36:11] *** Parts: MEC (dsqldsld@73870F26.CC75AD1F.96B18764.IP) ()
[10:36:24] <aatch> doener_, it does move, but a move still copies some data.
[10:36:46] <aatch> a move is basically a shallow copy.
[10:37:11] <doener_> ah, true, what was I thinking... Move just cancels the cleanup in addition
[10:38:20] <aatch> I'm pretty sure the code for returning in the non-immediate case uses datum's ByMove or whatever.
[10:39:07] <true_droid> is it possible to print the type of an expression?
[10:39:51] <aatch> true_droid, not really, there might be some limited way in the reflection code.
[10:40:17] <doener_> we'd need to be able to revoke cleanups without zeroing to solve that I guess
[10:40:19] <aatch> but much of the useful information (for a human) is lost by the time it's compiled
[10:41:05] <aatch> doener_, yeah, it's a nice optimization, but a bit of an edge case and not a huge hit most of the time.
[10:41:12] <doener_> hm, no, still not good enough, the memory would be in the wrong stack frame
[10:41:42] *** Joins: tcr (tcr@moz-EE576D3C.hsd1.ma.comcast.net)
[10:43:10] <aatch> doener_, basically it needs to track backwards from the return expression to construct into the return pointer.
[10:43:13] *** Joins: erickt (erickt@8C9ECD8F.3A598286.F12515B4.IP)
[10:43:20] <doener_> aatch: yeah
[10:43:23] <aatch> I'm not exactly sure what that would entail though.
[10:43:33] <aatch> There is, at least, an API in LLVM to help with this.
[10:43:34] *** Quits: tcr (tcr@moz-EE576D3C.hsd1.ma.comcast.net) (Ping timeout)
[10:45:03] *** Quits: erickt (erickt@8C9ECD8F.3A598286.F12515B4.IP) (Ping timeout)
[10:49:20] *** Joins: sankha93 (Instantbir@CA5CC0A8.23B0F5E5.F44414AF.IP)
[10:50:09] <true_droid> this surprised me https://gist.github.com/alco/6038293#file-print_vec-rs-L11
[10:50:28] <true_droid> does Rust automatically take an address of vec? or is it implicit conversion of [int, ..3] to &[int]?
[10:50:58] *** Joins: rusti (rusti@moz-54F7FD49.cpe.net.cable.rogers.com)
[10:51:00] <aatch> true_droid, so &[T] is a slice
[10:51:01] *** Quits: _Vi (vi@527C345F.497AA854.B16B3BE6.IP) (Ping timeout)
[10:51:13] <SimonSapin> true_droid: yes, various vector types can be implicitly coerced to a &[T] slice
[10:51:26] <true_droid> ah, ok, makes sense
[10:51:29] <aatch> and a [int,..3] can be coerced to a slice.
[10:51:39] <SimonSapin> similarly for ~T and @T to &T
[10:51:51] <aatch> (a slice is just a pointer and a length, btw)
[10:52:17] <aatch> And ~str and @str to &str
[10:52:40] <aatch> (vectors and strings are different to other types, because they have some special considerations)
[10:52:52] *** Joins: naq (naq@D5C2D2DF.E4265FCD.E481B5B.IP)
[10:54:47] *** Quits: bnicholson (bnicholson@moz-E98974C1.hsd1.ca.comcast.net) (Ping timeout)
[10:59:36] <true_droid> if copy v; simply creates a new slice pointing to the same vector v, how can I create a brand new copy of v's contents?
[10:59:48] <true_droid> sorry, v is a slice: &[int]
[10:59:51] <aatch> true_droid, there is no `copy v` any more.
[10:59:53] <true_droid> pointing to some vector
[11:00:07] <true_droid> I'm using rust 0.6 because 0.7 errors out on my machine
[11:00:26] <aatch> true_droid, uh, that's really not recommended. What's the error?
[11:00:42] <true_droid> https://gist.github.com/alco/6031502
[11:01:11] <aatch> true_droid, ok, what about just using rustc directly?
[11:01:33] *** Joins: BitPuffin (quassel@moz-23AC5B71.bredband.tre.se)
[11:02:14] <true_droid> aatch: seems to work
[11:02:17] *** Joins: MaikKlein (maik@moz-4CFF4604.dip0.t-ipconnect.de)
[11:02:23] <true_droid> but it doesn't complain about copy
[11:02:44] <aatch> true_droid, have you/can you build from source?
[11:02:52] *** Joins: BizarreCake (BizarreCak@moz-361FE9B2.dynamic.barak-online.net)
[11:03:22] *** Joins: donri (dag@moz-9BB61102.tbcn.telia.com)
[11:04:18] <true_droid> aatch: I have both versions installed view Homebrew, which means they've been built from source
[11:04:21] <true_droid> https://gist.github.com/alco/6038368
[11:06:08] <aatch> true_droid, hmm, well `copy` was recently removed from the language.
[11:06:14] <aatch> so you may want to update.
[11:06:21] *** Quits: StarLight (StarLight@moz-534A0739.pppoe.avangarddsl.ru) (Ping timeout)
[11:07:25] <true_droid> aatch: I don't want the bleeding edge, I just want to figure out how deep copying works in Rust. Adjusting to the new syntax/functions will be easier from there.
[11:07:35] *** Joins: ghrust (ghrust@1E8607E8.6A2AE50.F3114085.IP)
[11:07:35] <ghrust> 01[13rust01] 15bors merged 06auto into 06master: 02http://git.io/5nHCPA
[11:07:35] *** Parts: ghrust (ghrust@1E8607E8.6A2AE50.F3114085.IP) ()
[11:08:27] <aatch> true_droid, use .clone() for a "shallow" clone (stops at `@`) and .deep_clone() for a deep clone.
[11:08:58] <aatch> otherwise, PODs are implicitly copyable, everything is moved.
[11:09:51] *** Joins: StarLight (StarLight@moz-C9F68A8D.dynamic.avangarddsl.ru)
[11:10:34] *** Joins: ghrust (ghrust@AD60B2E3.6A2AE50.F3114085.IP)
[11:10:34] <ghrust> 01[13rust01] 15bors pushed 0 new commits to 06auto: 02http://git.io/zqBw7Q
[11:10:34] *** Parts: ghrust (ghrust@AD60B2E3.6A2AE50.F3114085.IP) ()
[11:11:03] <true_droid> aatch: thanks
[11:11:54] *** Quits: infynyxx (infynyxx@moz-E95B370B.nyc.res.rr.com) (Client exited)
[11:12:15] *** Quits: MaikKlein (maik@moz-4CFF4604.dip0.t-ipconnect.de) (Ping timeout)
[11:14:19] *** Quits: KindOne (KindOne@moz-854E31FC.dynamic.ip.windstream.net) (Ping timeout)
[11:20:17] *** kimundi is now known as zz_kimundi
[11:23:18] <dbaupp> aatch: nice... way faster than me
[11:23:23] * dbaupp is jealous
[11:24:25] <dbaupp> doener_: https://github.com/mozilla/rust/issues/7298 (but it doesn't contain any more info than what aatch just told you.)
[11:30:38] *** Joins: Samanthaa (Guest@D07E3CF2.3DB2E23F.6D8B4AB5.IP)
[11:32:29] *** Quits: Samanthaa (Guest@D07E3CF2.3DB2E23F.6D8B4AB5.IP) (Quit: )
[11:33:02] *** Joins: z0w0 (zack@A76ECE44.E8D776F0.D76C0449.IP)
[11:34:43] *** Quits: rusti (rusti@moz-54F7FD49.cpe.net.cable.rogers.com) (Ping timeout)
[11:34:59] <aatch> dbaupp, heh, amazingly, my new-fmt branch had no git conflicts (other than some from the .rc -> .rs change)
[11:35:22] <dbaupp> well... it just created new files, right?
[11:35:30] *** zz_kimundi is now known as kimundi
[11:35:32] <aatch> dbaupp, true.
[11:35:45] <aatch> I'll be surprised if it still compiles tbh
[11:36:03] <dbaupp> but, yay for resurrecting the dead
[11:36:12] * dbaupp is happy to help
[11:38:24] <dbaupp> aatch: do you happen to have an example to hand of code that relies on sharing per https://github.com/mozilla/rust/pull/7644#issuecomment-21244760 ?
[11:38:39] <aatch> dbaupp, the ast map
[11:38:42] <dbaupp> ah
[11:38:48] * dbaupp glares at the ast map
[11:39:03] <aatch> theres a few other places, but that's the biggest offender
[11:39:16] <dbaupp> does it squirrel away references, or something?
[11:39:39] <aatch> dbaupp, yep. it's a map from node-ids to ast nodes.
[11:40:05] <aatch> it's possible to convert it to borrowed pointers with lifetimes, with a little help from `unsafe`
[11:40:09] <dbaupp> yuck :'(
[11:40:36] *** Quits: doomlord (doomlod@42802052.53E08B38.C3DDD137.IP) (Ping timeout)
[11:40:50] <dbaupp> presumably the HashMap can't be behind @mut with borrowed pointers?
[11:41:13] <aatch> dbaupp, you still have a bounded lifetime.
[11:41:29] <dbaupp> hm?
[11:42:14] <aatch> dbaupp, well you can have it behind a @mut, but you still have a lifetime parameter on the hashmap's value type.
[11:42:23] *** Parts: yichoi (yichoi@5AB4884B.FCC4549.14D5B978.IP) ()
[11:42:25] <aatch> since it'd be a borrowed pointer with a 'self
[11:42:35] <dbaupp> https://github.com/mozilla/rust/pull/7894
[11:42:49] <dbaupp> (I'd thought that had landed.)
[11:42:58] <aatch> dbaupp, ah, I missed that.
[11:43:23] <dbaupp> yeah... so it looks like de-@-ing will be a herculean task
[11:43:34] <dbaupp> (even more so than it was originally.)
[11:43:43] *** Joins: erickt (erickt@8C9ECD8F.3A598286.F12515B4.IP)
[11:44:03] <aatch> dbaupp, what's the motivation for that?
[11:44:12] <dbaupp> the pull request?
[11:44:16] <aatch> yeah
[11:44:26] <dbaupp> I'd guess because it's unsound
[11:44:59] *** Joins: _Vi (vi@527C345F.497AA854.B16B3BE6.IP)
[11:45:17] <dbaupp> let z; { let x = 1; let y = &x; let z = @y; } println(fmt!("%?", z));
[11:45:27] <dbaupp> rusti: let z; { let x = 1; let y = &x; let z = @y; } println(fmt!("%?", z));
[11:45:38] *** Quits: erickt (erickt@8C9ECD8F.3A598286.F12515B4.IP) (Ping timeout)
[11:47:10] *** Quits: BizarreCake (BizarreCak@moz-361FE9B2.dynamic.barak-online.net) (Ping timeout)
[11:47:22] *** Quits: Jesse (jruderman@moz-537BCF9.hsd1.ca.comcast.net) (Connection reset by peer)
[11:47:27] <dbaupp> (fwiw, that code gives `borrowed value does not live long enough`, so it's not entirely unsound...)
[11:48:23] *** Joins: engla (engla@moz-DBD1D96E.cust.bredbandsbolaget.se)
[11:48:49] <dbaupp> aatch: I don't know the nitty-gritty of it
[11:51:34] *** Joins: rusti (rusti@moz-54F7FD49.cpe.net.cable.rogers.com)
[11:52:01] *** Joins: tiffany (kawaii@moz-EB8B0C08.dhcp.embarqhsd.net)
[11:57:57] *** Quits: tiffany (kawaii@moz-EB8B0C08.dhcp.embarqhsd.net) (No route to host)
[11:58:13] *** Joins: tiffany (kawaii@moz-EB8B0C08.dhcp.embarqhsd.net)
[11:59:23] *** Quits: sigma (sigma@51C589B3.EF2694B5.DFAC6AA7.IP) (Quit: Leaving.)
[11:59:30] *** Joins: LU324 (stuff@moz-A17E9A7B.dyn.embarqhsd.net)
[12:00:26] <aatch> stupid clock skew
[12:00:37] <aatch> Oh well, time to sleep now.
[12:00:41] *** Quits: aatch (aatch@moz-2BB0AC01.cable.telstraclear.net) (Quit: Leaving)
[12:07:41] *** Joins: msingle (Thunderbir@moz-930E5D97.hr.hr.cox.net)
[12:07:59] *** Quits: themgt (themgt@moz-7834B2B9.cm.vtr.net) (Ping timeout)
[12:08:45] *** Quits: thpickert (thpickert@moz-24816453.tng.de) (Quit: thpickert)
[12:09:33] *** Joins: noam_ (noam@F6B530A7.720527A7.416762B.IP)
[12:10:21] *** Quits: noam (noam@F6B530A7.720527A7.416762B.IP) (Ping timeout)
[12:11:30] *** Joins: themgt (themgt@moz-7834B2B9.cm.vtr.net)
[12:14:06] *** Quits: noam_ (noam@F6B530A7.720527A7.416762B.IP) (Connection reset by peer)
[12:21:50] <bstrie> so I have a c++ question in the context of rust
[12:22:27] <bstrie> so rust lets you store borrowed pointers in data structures
[12:22:36] *** Joins: infynyxx (infynyxx@moz-E95B370B.nyc.res.rr.com)
[12:22:37] <bstrie> and this is something you can't safely do in C++, yeah?
[12:24:22] *** Quits: infynyxx (infynyxx@moz-E95B370B.nyc.res.rr.com) (Ping timeout)
[12:25:09] *** Joins: maxli (maxli@F2D29657.F60B0462.67AC9B1.IP)
[12:26:29] *** Joins: cubic (cubic@moz-FE5AD6C7.mc.videotron.ca)
[12:30:47] <dbaupp> bstrie: you can't do anything safely with "borrowed" pointers in C++, right?
[12:30:56] *** Joins: pnathan (Adium@B9840254.2CD8A5F8.477B877D.IP)
[12:31:04] <dbaupp> (but yeah, I guess storing them is what makes them dangerous.)
[12:31:53] <bstrie> dbaupp: well my real question is whether this means that you can get away with relatively more stack allocations in rust, as opposed to heap allocations in c++, as a way of keeping things alive
[12:32:18] <bstrie> and whether this means that rust is slightly less prone to memory fragementation
[12:32:41] <dbaupp> hahaha, answering that reddit question?
[12:32:47] <bstrie> yep :P
[12:32:49] <bstrie> or trying to
[12:32:53] <bstrie> not a C++ programmer!
[12:33:14] <dbaupp> I think the segmented stacks have more effect on that, i.e. you can put whatever you want on the stack and you don't have to worry about overflows
[12:33:18] * dbaupp isn't one eitehr
[12:33:26] * dbaupp isn't a typist too
[12:33:29] <doener_> great, enabling detailed memleak tracking turns my memleak into a double free o.O
[12:34:17] <dbaupp> bstrie: because, in theory, things on the stack can't "go up a stack frame" while there are still borrowed pointers
[12:34:30] *** Joins: alex-abreu (alex@moz-7421D6C9.mc.videotron.ca)
[12:34:40] <dbaupp> (not sure that means anything in the context of this questions though, heh.)
[12:35:15] *** Quits: rusti (rusti@moz-54F7FD49.cpe.net.cable.rogers.com) (Ping timeout)
[12:35:41] <bstrie> doener_: try using the new gc :P
[12:35:47] <bstrie> not sure if it actually bootstraps yet...
[12:36:28] *** Joins: bytbox (s@moz-DC83764A.washdc.fios.verizon.net)
[12:37:01] *** Quits: pnathan (Adium@B9840254.2CD8A5F8.477B877D.IP) (Ping timeout)
[12:38:11] *** Quits: int3_ (int3_@moz-ABE52D50.hsd1.ca.comcast.net) (Client exited)
[12:38:32] *** Joins: int3_ (int3_@moz-ABE52D50.hsd1.ca.comcast.net)
[12:40:19] *** Quits: int3_ (int3_@moz-ABE52D50.hsd1.ca.comcast.net) (Ping timeout)
[12:43:56] <engla> acrichto_: I didn't answer your comment about warnings in tests. I don't think it's important to deny warnings personally
[12:44:03] *** Joins: int3_ (int3_@moz-ABE52D50.hsd1.ca.comcast.net)
[12:44:11] *** Joins: erickt (erickt@8C9ECD8F.3A598286.F12515B4.IP)
[12:44:33] *** Quits: z0w0 (zack@A76ECE44.E8D776F0.D76C0449.IP) (Client exited)
[12:44:58] *** Quits: sankha93 (Instantbir@CA5CC0A8.23B0F5E5.F44414AF.IP) (Ping timeout)
[12:46:07] *** Quits: erickt (erickt@8C9ECD8F.3A598286.F12515B4.IP) (Ping timeout)
[12:52:11] *** Joins: rusti (rusti@moz-54F7FD49.cpe.net.cable.rogers.com)
[12:52:34] *** Joins: ghrust (ghrust@AC22872E.6A2AE50.F3114085.IP)
[12:52:34] <ghrust> 01[13rust01] 15bors merged 06auto into 06master: 02http://git.io/pQ6XZw
[12:52:34] *** Parts: ghrust (ghrust@AC22872E.6A2AE50.F3114085.IP) ()
[12:55:33] *** Joins: ghrust (ghrust@2EE61FCC.6A2AE50.F3114085.IP)
[12:55:33] <ghrust> 01[13rust01] 15bors pushed 0 new commits to 06auto: 02http://git.io/ie2oRg
[12:55:33] *** Parts: ghrust (ghrust@2EE61FCC.6A2AE50.F3114085.IP) ()
[12:55:34] *** Joins: ghrust (ghrust@AC22872E.6A2AE50.F3114085.IP)
[12:55:34] <ghrust> 01[13rust01] 15bors pushed 2 new commits to 06auto: 02http://git.io/d8K_AQ
[12:55:34] <ghrust> 13rust/06auto 1460bd7ac 15Alex Crichton: Allow linking against crates with #[no_std]...
[12:55:34] <ghrust> 13rust/06auto 143b74b0a 15bors: auto merge of #7874 : alexcrichton/rust/opt-lang-xcrate, r=thestinger...
[12:55:35] *** Parts: ghrust (ghrust@AC22872E.6A2AE50.F3114085.IP) ()
[12:57:12] *** Joins: Kruppe (user@moz-4DDA8AB8.uwaterloo.ca)
[12:58:48] *** Quits: CarpNet (ac@moz-FD24B77.sohonet.co.uk) (Quit: Leaving)
[13:01:05] *** Joins: goffrie_ (goffrie@moz-8764A29A.dsl.ncf.ca)
[13:01:49] *** Quits: goffrie (goffrie@moz-A3ADCE7B.dsl.ncf.ca) (Ping timeout)
[13:03:02] *** Quits: pnkfelix|rcirc (pnkfelix@87C1F78E.1DE10CA8.D8E68FF6.IP) (Quit: rcirc on GNU Emacs 24.2.1)
[13:08:03] *** Quits: novabyte (Instantbir@moz-3E0F9699.cable.virginmedia.com) (Quit: bye bye)
[13:09:52] *** Joins: saml (sam@moz-14C16814.cst.lightpath.net)
[13:10:11] *** Quits: yong (chatzilla@89F941DF.4E87ADC2.263D9828.IP) (Ping timeout)
[13:10:19] *** Quits: Kruppe (user@moz-4DDA8AB8.uwaterloo.ca) (Ping timeout)
[13:10:36] *** Joins: CarpNet (ac@moz-FD24B77.sohonet.co.uk)
[13:12:28] *** Joins: yong (chatzilla@89F941DF.4E87ADC2.263D9828.IP)
[13:12:43] *** Joins: jfbk (textual@moz-EEA9CFB3.nyc.res.rr.com)
[13:15:34] *** kimundi is now known as zz_kimundi
[13:29:44] *** Joins: cowboyd (cowboyd@moz-B819AF27.sw.biz.rr.com)
[13:29:49] *** Quits: Liothen (liothen@moz-32BDFBCC.spkn.qwest.net) (Quit: Textual IRC Client: www.textualapp.com)
[13:32:07] *** Joins: Azdle (Azdle@moz-B334B496.hfc.comcastbusiness.net)
[13:34:50] *** Quits: rusti (rusti@moz-54F7FD49.cpe.net.cable.rogers.com) (Ping timeout)
[13:36:00] <dbaupp> oooh, auto running benchmarks
[13:36:14] <dbaupp> (and saving them too!)
[13:38:18] <cmr> nmatsakis: nice talk
[13:38:23] <nmatsakis> cmr: thanks.
[13:39:38] *** Quits: vodik (simon@moz-CBE4BB13.cable.teksavvy.com) (Ping timeout)
[13:39:46] *** Joins: saati (bjb@moz-11469F61.harmless.hu)
[13:40:14] <saati> hello, is it expected for 'make check' to end with "fatal runtime error: no scheduler"
[13:40:32] *** Joins: vodik (simon@moz-CBE4BB13.cable.teksavvy.com)
[13:42:28] <saati> this is the whole thing http://paste.roguecoders.com/p/6dc27a9da93e206cea6d115a57b8c2fb.txt
[13:42:28] <doener_> urgh, looks like drop() for CrateContext mallocs when it's called from the annihilator
[13:42:52] <doener_> saati: no IPv6 support?
[13:43:09] <saati> oh ok
[13:43:14] <doener_> Unhandled condition: io_error: {kind: OtherIoError, desc: "address not available", detail: None}'
[13:43:27] <doener_> that's probably from a test that uses IPv6
[13:43:36] <saati> and it's the last test?
[13:43:51] <saati> or why does the whole thing die with it?
[13:43:51] *** Quits: jfbk (textual@moz-EEA9CFB3.nyc.res.rr.com) (Quit: My MacBook has gone to sleep. ZZZzzzâ€¦)
[13:44:05] <doener_> the test rig doesn't handle that failure gracefully
[13:44:06] <dbaupp> doener_: in the compiler itself?
[13:44:14] <dbaupp> (the drop)
[13:44:40] *** Joins: erickt (erickt@8C9ECD8F.3A598286.F12515B4.IP)
[13:45:03] <doener_> dbaupp: yeah, happens with the stage1 compiler I get with my changes in. AFAICT, stage1 means that the error already exists, I'm just triggering it, right?
[13:45:07] *** Joins: bytewise (bytewise@moz-649C630D.unitymediagroup.de)
[13:45:29] *** Quits: cowboyd (cowboyd@moz-B819AF27.sw.biz.rr.com) (Client exited)
[13:45:49] <dbaupp> doener_: probably... because it's a problem with the code the stage0 compiler is creating, right?
[13:45:56] <doener_> yeah
[13:46:32] *** Joins: dherman (dherman@moz-6CA476B1.hsd1.ca.comcast.net)
[13:46:32] *** ChanServ sets mode: +o dherman
[13:46:37] *** Quits: erickt (erickt@8C9ECD8F.3A598286.F12515B4.IP) (Ping timeout)
[13:50:57] *** Joins: rusti (rusti@moz-54F7FD49.cpe.net.cable.rogers.com)
[13:51:29] *** Joins: cowboyd (cowboyd@moz-B819AF27.sw.biz.rr.com)
[13:52:09] <bstrie> rusti: 1 && 2
[13:52:10] -rusti- <anon>:7:9: 7:15 error: binary operation && cannot be applied to type `<VI0>`
[13:52:11] -rusti- <anon>:7          1 && 2
[13:52:11] -rusti-                   ^~~~~~
[13:52:11] -rusti- error: aborting due to previous error
[13:52:11] -rusti- application terminated with error code 101
[13:54:40] <true_droid> can a slice to vector point to a subrange of the whole vector?
[13:56:35] <dbaupp> true_droid: yes, that's essentially what they are designed for
[13:56:59] <dbaupp> rusti: let v = ~[1,2,3,4]; let w = v.slice(1,3); println(fmt!("%? %?", v, w));
[13:57:00] -rusti- ~[1, 2, 3, 4] &[2, 3]
[13:57:01] -rusti- ()
[13:57:42] *** Joins: mark_edward (quassel@moz-4A9A2F15.dynamic.utc.edu)
[13:57:54] *** Quits: mark_edward (quassel@moz-4A9A2F15.dynamic.utc.edu) (Quit: http://quassel-irc.org - Chat comfortably. Anywhere.)
[13:58:03] *** Joins: mark_edward (quassel@moz-4A9A2F15.dynamic.utc.edu)
[13:58:26] <true_droid> dbaupp: hm, I'm looking at the read() function of Reader, its signature is fn read(&self, bytes: &mut [u8], len: uint) -> uint. So I'm wondering why the 3rd argument is needed. It's just an extra check that needs to be performed by programmer: make sure len is <= bytes.len(). Why not use bytes' len()?
[13:58:35] <true_droid> http://static.rust-lang.org/doc/std/io.html#trait-reader
[13:59:22] <dbaupp> oh, no idea... that would be more reasonable. I guess it's just a legacy of how it once was
[13:59:22] *** Joins: jedestep (jedestep@34641662.FB4DE631.66C78B76.IP)
[14:00:04] <true_droid> another confusing thing is io::stdin().read_line(). The doc says stdin() returns a Reader, but read_line() is part of ReaderUtil
[14:00:30] <dbaupp> right, ReaderUtil is implemented for all Readers
[14:02:00] <true_droid> dbaupp: kind of like trait Reader { ReaderUtil; <other methodsâ€¦> } ?
[14:02:05] <doener_> hm, yeah, drop() accesses TLS data, which is already gone at that point, so it is recreated which allocates @ in the stage0 version and that bails
[14:02:30] <true_droid> it'd be great to have links straight into the source from the doc site
[14:02:40] <dbaupp> true_droid: well, no `trait<R: Reader> ReaderUtil for R { methods... }`
[14:02:57] <doener_> or rather, the new allocation isn't in the kill list, so it remains as a live allocation even after the annihilator is done
[14:02:59] <dbaupp> gah, sorry, `impl<...`
[14:03:06] <dbaupp> not `trait`
[14:03:28] <dbaupp> true_droid: yes, there's a new rustdoc being written that will hopefully have that
[14:03:41] <dbaupp> true_droid: although you can get by with grep pretty well
[14:03:44] <doener_> shouldn't happen with the new TLS code anymore AFAICT (because it doesn't use @)
[14:03:44] <true_droid> dbaupp: oh I see, the impl thing makes sense, thanks
[14:03:49] <dbaupp> (assuming you have a local copy of the source)
[14:04:02] *** zz_kimundi is now known as kimundi
[14:04:23] <true_droid> dbaupp: yes, I thought it'd be handy to have :)
[14:04:31] <dbaupp> yup :)
[14:05:06] <dbaupp> going in to the top level directory and running `git grep 'fn function_name'` or `git grep 'trait Foo'` will take you straight to the relevant spot
[14:05:17] <dbaupp> (or at least, give you a short list of possible places.)
[14:05:38] <true_droid> dbaupp: thanks
[14:05:38] <dbaupp> doener_: that's annoying. why's it getting removed from TLS?
[14:06:05] <dbaupp> doener_: oh, the task is being destroyed, so TLS goes first?
[14:06:17] <doener_> yeah, TLS goes first, then the annihilator runs
[14:06:39] <dbaupp> that seems backwards, I guess
[14:06:42] <doener_> wouldn't be any better the other way around.
[14:07:01] <doener_> then the annihilator would kill stuff that's still in the TLS map
[14:07:09] <dbaupp> ah, and that'd be incorrect
[14:09:10] <saati> what's the rationale behind if predicates taking only bools and ! doing binary negation too? !some_int oslt can be very comfortable in c
[14:09:16] <bstrie> I wonder if llvm is smart enough to turn `0 * foo` into `0` at compile time
[14:09:44] *** Quits: cowboyd (cowboyd@moz-B819AF27.sw.biz.rr.com) (Client exited)
[14:10:09] <dbaupp> bstrie: almost certainly
[14:10:17] <bstrie> saati: our religion shuns implicit coercions
[14:10:28] <dbaupp> (except for floats, because 0 * inf = NaN)
[14:10:33] *** Joins: jaen (jaen@moz-36261275.internetdsl.tpnet.pl)
[14:10:45] <saati> bstrie: i see
[14:11:12] <bstrie> saati: take it up with graydon, he is adamant on the topic
[14:11:49] <bstrie> perhaps not implicit coercions in *all* cases, but definitely wrt bools and ints
[14:12:50] <bstrie> e.g. I hear that the plan is to be able to write just `~Foo` instead of `~Foo as ~SomeTrait`, to make trait objects more usable
[14:13:20] <dbaupp> and ~T/@T -> &T
[14:13:37] <dbaupp> (is a "legal" implicit coercion)
[14:13:56] <bstrie> is that actually a coercion?
[14:13:59] *** Quits: sk (sk@A298A44C.54A580E3.78DD174B.IP) (Quit: Leaving)
[14:14:07] <bstrie> I figured it was actually making a new pointer, or something
[14:15:12] <bstrie> sort of like how ~[T] -> &[T] creates a slice
[14:15:17] <dbaupp> I guess it depends what you mean by coercion?
[14:15:32] <bstrie> yeah, I guess it does :P
[14:15:33] <dbaupp> but ~T -> &T is now a noop (now that headers are gone)
[14:16:11] <dbaupp> @T -> &T does tricky things with indicating a borrow and adding 4*size_of(size_t) to the pointer etc.
[14:16:16] * dbaupp isn't sure of the details
[14:16:51] <saati> why is it adding 4*size_of(size_t) ?
[14:17:00] <dbaupp> to skip the box header
[14:17:35] <saati> it's size is dependent on the contained type?
[14:17:44] <dbaupp> @T = pointer to struct { type description, ref count, next, prev, T }
[14:17:52] <saati> oh, no, now i get it, ok
[14:18:31] <dbaupp> (the tydesc and next/prev are for getting destructors to work properly.)
[14:19:42] *** Joins: infynyxx (infynyxx@moz-E95B370B.nyc.res.rr.com)
[14:19:45] <saati> what is size_t exactly?
[14:20:06] <bstrie> rusti: size_of(size_t)
[14:20:08] -rusti- more than 5 lines of output, pastebinned: http://sprunge.us/TKKM
[14:20:15] *** Quits: jaen (jaen@moz-36261275.internetdsl.tpnet.pl) (Ping timeout)
[14:20:17] <bstrie> I think it's the size of the pointer on the platform?
[14:20:21] <Ms2ger> Yeah
[14:20:27] <bstrie> must be a C-ism
[14:20:29] <dbaupp> saati: (it's a C type)
[14:20:50] <dbaupp> rusti: std::sys::size_of::<std::libc::size_t>()
[14:20:51] <Ms2ger> (Not sure if C actually guarantees the size)
[14:20:51] -rusti- 8
[14:21:33] <dbaupp> (I guess I really should've said size_of(header)
[14:21:34] <dbaupp> )
[14:22:17] *** Joins: erickt (Adium@49C4075F.3AC15C18.2321E71E.IP)
[14:26:49] *** Quits: Earnestly (earnest@2AB30F53.FB5005.2BCC804A.IP) (Quit: WeeChat 0.4.2-dev)
[14:26:50] *** Joins: Earnestly (earnest@2AB30F53.FB5005.2BCC804A.IP)
[14:26:57] *** Joins: hjr3 (hradtke@1A0AE795.28A5F6C3.A2D40ED2.IP)
[14:31:16] *** Joins: pnathan (Adium@moz-BDC3EE62.tukw.qwest.net)
[14:34:41] *** Quits: rusti (rusti@moz-54F7FD49.cpe.net.cable.rogers.com) (Ping timeout)
[14:35:51] *** Joins: pnathan1 (Adium@B9840254.2CD8A5F8.477B877D.IP)
[14:36:12] *** Quits: pnathan (Adium@moz-BDC3EE62.tukw.qwest.net) (Quit: Leaving.)
[14:36:25] *** Quits: dbaupp (Thunderbir@moz-712A1135.lns20.syd6.internode.on.net) (Ping timeout)
[14:37:28] *** Joins: cornelius (Mibbit@BBE7C46A.B4F11D08.8612FA94.IP)
[14:39:08] *** Joins: dbaupp (Thunderbir@moz-712A1135.lns20.syd6.internode.on.net)
[14:42:01] *** Quits: pnathan1 (Adium@B9840254.2CD8A5F8.477B877D.IP) (Ping timeout)
[14:45:10] *** Joins: erickt1 (erickt@8C9ECD8F.3A598286.F12515B4.IP)
[14:46:37] *** Joins: ozten (ozten@moz-DD3B00B4.hsd1.wa.comcast.net)
[14:46:50] *** Quits: erickt1 (erickt@8C9ECD8F.3A598286.F12515B4.IP) (Ping timeout)
[14:49:54] *** Joins: BizarreCake (BizarreCak@moz-361FE9B2.dynamic.barak-online.net)
[14:51:34] *** Joins: rusti (rusti@moz-54F7FD49.cpe.net.cable.rogers.com)
[14:51:40] *** Parts: bytewise (bytewise@moz-649C630D.unitymediagroup.de) (Leaving)
[14:51:48] *** Joins: bytewise (bytewise@moz-649C630D.unitymediagroup.de)
[14:54:07] *** Joins: tcsc (tcsc@moz-ADC0ED45.hsd1.ct.comcast.net)
[14:54:53] <bjz> rusti: let x; if true { x = 1 } else { x = 2 } x
[14:54:55] -rusti- 1
[14:55:02] <bjz> rusti: let x; if true { x = 1 } x
[14:55:03] -rusti- <anon>:7:34: 7:35 error: use of possibly uninitialized variable: `x`
[14:55:03] -rusti- <anon>:7          let x; if true { x = 1 } x
[14:55:03] -rusti-                                            ^
[14:55:03] -rusti- error: aborting due to previous error
[14:55:03] -rusti- application terminated with error code 101
[14:57:42] <bstrie> I'm fascinated by the first-name frequencies in authors.txt
[14:57:59] <bstrie> how the hell are there so many bens
[14:58:08] <bstrie> I didn't know a single other ben while growing up
[14:59:07] <bstrie> I think we're tied for most frequent with the dans
[14:59:46] <engla> what's the minimum allocation for a ~[]?
[15:00:07] <doener_> 4 elements
[15:00:12] <engla> just in the context of https://github.com/mozilla/rust/issues/7900  implementing ~str::clear() should be very simple
[15:00:37] <engla> just set_len()  to 0. Only thing is it must have at least vec capacity of 1 for the nul byte
[15:00:57] <bstrie> rusti: std::sys::size_of::<~[u8]>()
[15:00:59] -rusti- 8
[15:01:21] <bstrie> rusti: std::sys::size_of::<@[u8]>()
[15:01:22] -rusti- 8
[15:01:28] <bstrie> oh right
[15:01:30] <bstrie> it's a pointer
[15:01:31] <kimundi> I find it somewhat unclear what clear should do there
[15:01:42] * dbaupp thinks he will be unique in authors.txt
[15:02:09] <dbaupp> yup, I'm speshul ;D
[15:02:10] <kimundi> reset it to a state like fresh created, or just remove all elements, keeping the big allocation?
[15:02:20] <bstrie> dbaupp: you're right, I don't see a single other person whose first name is "Db" :P
[15:02:39] <dbaupp> I don't see anyone with bs
[15:02:43] <dbaupp> ;P
[15:02:53] <bstrie> I've got plenty of bs to share
[15:03:02] <bstrie> it's something of a speciality
[15:03:05] <dbaupp> I've noticed :P
[15:03:07] <Ms2ger> How about Mikes?
[15:03:23] <bstrie> no mikes, 4 michaels
[15:03:27] <bstrie> and one mikko
[15:03:47] <bstrie> half as many mikes as bens
[15:03:51] *** Quits: erickt (Adium@49C4075F.3AC15C18.2321E71E.IP) (Quit: Leaving.)
[15:04:27] <engla> kimundi: I think it should keep the allocation
[15:04:50] <doy> three jesses
[15:05:51] *** kimundi is now known as zz_kimundi
[15:06:13] <bstrie> we should do a study where we compare the frequencies of names of programmers to those in the general population
[15:06:26] <engla> kini: a fresh allocation is simple for the user to do in other ways
[15:06:38] <engla> that was for kimundi
[15:08:33] *** Joins: sankha93 (Instantbir@CEB821D0.4F548E43.F44414AF.IP)
[15:09:17] <dbaupp> Does anyone know if there is an issue for `--cfg 'foo(bar)'` not working properly?
[15:10:43] *** Quits: _Vi (vi@527C345F.497AA854.B16B3BE6.IP) (Ping timeout)
[15:12:30] <dbaupp> r? https://github.com/mozilla/rust/pull/7902
[15:14:05] <cmr> &@ast::MetaItem
[15:14:07] <cmr> ugh, why
[15:14:29] <dbaupp> where?
[15:14:38] <cmr> https://github.com/huonw/rust/commit/cc760a647ac0094814f592d08813ebae0b3bec47#L0R545
[15:14:59] <dbaupp> oh, ew
[15:15:17] *** Joins: erickt (erickt@8C9ECD8F.3A598286.F12515B4.IP)
[15:17:07] *** Quits: erickt (erickt@8C9ECD8F.3A598286.F12515B4.IP) (Ping timeout)
[15:18:11] <bjz> why is immutability the default?
[15:18:25] <bjz> (somebody else is asking)
[15:18:51] <cmr> I prefer immutabibility by default for a variety of reasons but you'd probably have to ask dherman or graydon or another of the ancients.
[15:19:00] <dbaupp> because otherwise you get C++'s const correctness problem? (maybe?)
[15:19:19] *** Joins: eholk (eholk@moz-9AB4D52F.hsd1.ut.comcast.net)
[15:19:31] *** Joins: pnathan (Adium@B9840254.2CD8A5F8.477B877D.IP)
[15:19:32] <dbaupp> (i.e. not enough things are marked immutable when they really should be.)
[15:19:39] <bjz> http://www.reddit.com/r/programming/comments/1imf4i/guaranteeing_memory_safety_in_rust_pdf_slides/cb5ysc4
[15:22:22] <nmatsakis> bjz: many reasons... (a) you want it more often, (b) it's the safer of the two, (c) labeling mut variables combined with a lint for unnecessary mut labels actually catches bugs in practice, similar to unused variables,
[15:22:34] *** Quits: mark_edward (quassel@moz-4A9A2F15.dynamic.utc.edu) (Client exited)
[15:22:55] <bjz> nmatsakis: awesome
[15:23:07] <bjz> nmatsakis: would you be able to reply to that fellow?
[15:23:18] <nmatsakis> it's less imp't today in the inhreited mutability world... I've even thought about lobbying to make all locals mut, but graydon came back with (c) which I found persuasive :)
[15:23:37] *** Quits: eholk (eholk@moz-9AB4D52F.hsd1.ut.comcast.net) (Quit: eholk)
[15:23:39] <bjz> I love it
[15:23:41] <nmatsakis> sure, why not. I tend to avoid reddit/hackernews on principle (comment on my blog if you want to comment), but i'll make an excepiton ":)
[15:24:00] <cmr> I find rust's subreddit quite pleasant
[15:24:08] <jack> "and no one saw niko again for days"
[15:24:11] <cmr> it's the only one I frequent, though..
[15:24:24] <bjz> I don't find /r/programming too bad
[15:24:42] <nmatsakis> cmr: I don't mind reddit overall, I just ... feel like blog posts that have comments enabled seems like the place to have the conversation,
[15:24:50] <nmatsakis> cmr: so that if others come later, it's archived on the post itself
[15:24:53] <bjz> nmatsakis: yep
[15:25:22] <bjz> nmatsakis: the comment diffusion is a problem
[15:26:59] <bstrie> nmatsakis: these slides are really great
[15:27:16] <nmatsakis> bstrie: glad you like 'em
[15:27:22] <nmatsakis> bjz: responded.
[15:28:01] *** Joins: mark_edward (quassel@moz-4A9A2F15.dynamic.utc.edu)
[15:28:20] <bjz> nmatsakis: excellent answer!
[15:28:22] <bstrie> bjz: I need some way to automatically find out when rust posts leak into r/programming
[15:28:53] <dbaupp> bstrie: http://www.reddit.com/r/rust/duplicates/1imeac/guaranteeing_memory_safety_in_rust_niko_matsakis/
[15:29:17] <bstrie> dbaupp: right, but I *always* overlook the "other dicussions" tab :P
[15:29:23] <bstrie> also it requires me to keep checking it
[15:29:30] <bjz> nmatsakis: I do agree it makes intent much easier to understand
[15:29:30] <bstrie> in case it gets submitted like an hour after I see it on r/rust
[15:30:02] <dherman> nmatsakis: but isn't there a (d)?
[15:30:11] <bjz> nmatsakis: it helps with self-documentation
[15:30:22] <dherman> which is that inherited mutability gives you the ability to write abstractions that can be either mutable or immutable
[15:30:32] <dherman> or could you have inherited mutability that defaults to mutable?
[15:30:34] <dbaupp> bstrie: true
[15:30:41] <nmatsakis> dherman: no, you're correct when it comes to struct fields,
[15:30:49] <nmatsakis> dherman: but then we don't even *allow* struct fields to be decalred mutable anymore :)
[15:30:56] <nmatsakis> dherman: so I was referring just to local variables
[15:31:01] <dherman> ah I see
[15:31:11] <nmatsakis> I 
[15:31:14] <nmatsakis> (oops)
[15:31:29] <dherman> I guess what I'm saying is that struct fields aren't immutable, they're just mutability-parametric
[15:31:52] <nmatsakis> yes
[15:31:53] <nmatsakis> you are correct
[15:32:03] <dherman> btw I've always meant to mention, there's an esoteric PL research idea called "environmental acquisition" (misleading name, nothing to do with lexical environments) that's related to inherited mutability
[15:32:10] <nmatsakis> oh really?
[15:32:11] <dherman> in one sense anyway
[15:32:18] <nmatsakis> never heard that term before
[15:32:19] <dherman> the idea was basically inheriting attributes from your container
[15:32:24] <dherman> it's just a handful of papers
[15:32:26] <dherman> it's not a big field
[15:32:29] <pnkfelix> nmatsakis: it was not big
[15:32:31] <bstrie> what sort of attributes?
[15:32:56] <dherman> http://www.ccs.neu.edu/home/cobbe/publications/popl-05-slides.pdf
[15:33:02] <dherman> bstrie: fields
[15:33:15] <dherman> think of it like OO but inheriting from the data structure that contains you
[15:33:21] <dherman> instead of from a typical inheritance mechanism
[15:33:34] <nmatsakis> interesting
[15:33:37] <pnkfelix> bstrie: e.g. "A door on a red car is also red."
[15:33:41] <dherman> carDoor.color == "blue" // because car.color == "blue"
[15:33:42] <dherman> haha
[15:33:44] <dherman> yeah
[15:33:44] <dherman> that
[15:33:57] <pnkfelix> bstrie: until you paint it yellow
[15:34:17] *** Quits: rusti (rusti@moz-54F7FD49.cpe.net.cable.rogers.com) (Ping timeout)
[15:34:33] <nmatsakis> seems related to JS prototypes :)
[15:34:38] <pnkfelix> dherman: is there possibly some connection with prototype based property lookup as well?  Though I don't know if prototypes are typically mutable
[15:34:38] <cmr> yeah I was just going to say
[15:34:47] <cmr> these seems identical to prototypes/metatables
[15:34:48] <pnkfelix> wow I'm really just showing confluence all over the place
[15:35:34] *** Quits: BizarreCake (BizarreCak@moz-361FE9B2.dynamic.barak-online.net) (Quit: Leaving)
[15:36:02] *** Joins: cowboyd (cowboyd@moz-A4161B97.dsl.austtx.swbell.net)
[15:37:12] <dherman> hm, I didn't think so
[15:37:17] <nmatsakis> identical is a bit strong, but it's certainly related.
[15:37:24] <dherman> prototypes are just a dynamic way to implement type-based inheritance
[15:37:40] <dherman> env acq is pretty sensitive to ownership issues
[15:37:41] <nmatsakis> I'm trying to remember, in self did you have just one prototype?
[15:37:46] <dherman> JS has no way to control ownership, pure GC
[15:37:49] <dherman> self has multiple prototypes
[15:38:02] <dherman> not sure how much you mutate them
[15:38:20] <dherman> the idea is that if you extract the door from this car and put it in another car it should inherit that other car's color
[15:38:44] <nmatsakis> right, so if you had multiple prototypes, you could say that the car's owner is "self.car == self.prototypes[1]' or someting
[15:38:57] <nmatsakis> and then you inherit the car's attributes,
[15:39:02] <nmatsakis> but you probably inherit more attributes than you'd want
[15:39:04] <dherman> unclear
[15:39:11] <nmatsakis> anyway
[15:40:16] <smvv> i'm not sure but is it true that lifetimes span an entire code block (code enclosed with "{ ... }"), or is it also possible to let lifetimes span from the declaration till the last use of the reference. 
[15:40:35] <nmatsakis> smvv: they span the entire code block right now
[15:40:55] *** Joins: tcr (tcr@moz-EE576D3C.hsd1.ma.comcast.net)
[15:41:02] <smvv> are there plans to change this in the near future? or is this >1.0?
[15:43:17] *** Quits: pnathan (Adium@B9840254.2CD8A5F8.477B877D.IP) (Quit: Leaving.)
[15:47:02] *** Joins: josh (josh@moz-348C4790.hsd1.mn.comcast.net)
[15:48:45] *** Quits: BitPuffin (quassel@moz-23AC5B71.bredband.tre.se) (Ping timeout)
[15:49:16] *** Joins: pnathan (Adium@B9840254.2CD8A5F8.477B877D.IP)
[15:49:35] *** Quits: infynyxx (infynyxx@moz-E95B370B.nyc.res.rr.com) (Client exited)
[15:50:12] *** Joins: rusti (rusti@moz-54F7FD49.cpe.net.cable.rogers.com)
[15:50:17] *** Joins: Jeaye (Jeaye@moz-FD505E54.hsd1.ca.comcast.net)
[15:50:57] *** Joins: eholk (eholk@moz-CB0ECD0F.uconnect.utah.edu)
[15:51:29] <engla> does it come up often?
[15:51:55] <engla> smvv: is it purely convenience (to avoid extra blocks), or would it enable something more? I'm just curious
[16:00:17] *** Quits: pnathan (Adium@B9840254.2CD8A5F8.477B877D.IP) (Quit: Leaving.)
[16:02:22] *** Joins: MaikKlein (maik@moz-4CFF4604.dip0.t-ipconnect.de)
[16:03:13] <smvv> engla: see this slide: http://smallcultfollowing.com/babysteps/pubs/2013.07.17-NEU.pdf#54 if the lifetime is not spanned for the entire block, it is possible to use the second `insert(&mut table, ...);' without the curly braces around the "let value = ... ; match value ..." block. Right?
[16:03:17] *** Quits: maxli (maxli@F2D29657.F60B0462.67AC9B1.IP) (Quit: Leaving.)
[16:04:00] <engla> sure
[16:04:23] <cmr> no, it wouldn't be
[16:04:31] <cmr> you'd have to move the use of value before the insert
[16:04:59] <cmr> I feel like requiring explicit scoping is good, you can't introduce bugs by reordering code without crossing a scope boundary.
[16:04:59] *** Quits: davbo (dave@moz-3FFA637C.oucs.ox.ac.uk) (Broken pipe)
[16:05:04] <cmr> or, not bugs, but compile errors
[16:05:17] *** Joins: _Vi (vi@527C345F.497AA854.B16B3BE6.IP)
[16:06:11] <engla> exactly. as long as you can still express what you want, it's nice to have the explicit scopes too
[16:06:27] <engla> it's the feature perspective
[16:07:06] *** Joins: maxli (maxli@F2D29657.F60B0462.67AC9B1.IP)
[16:08:24] *** Quits: cornelius (Mibbit@BBE7C46A.B4F11D08.8612FA94.IP) (Quit: http://www.mibbit.com ajax IRC Client)
[16:09:01] *** Joins: brendan (brendaneic@10487EE8.58B1B661.22B0E380.IP)
[16:10:41] *** Joins: Uther (Instantbir@moz-1B244B05.hfc.dyn.abo.bbox.fr)
[16:11:37] <smvv> having the ability to explicit scope a block of code is good. On the other hand, if you reduce the lifetime to the last use of a reference, you can free the memory directly after the last use. If you spend a lot of time in a function body, it is useful to free the memory of data that cannot be used anymore
[16:12:33] <bstrie> smvv: alternatively, it might be more efficient to free all the locals in a function at once, rather than freeing single locals many times
[16:12:44] <cmr> especially if you're actually doing region allocation
[16:13:18] <bstrie> so it's a typical time/memory tradeoff
[16:13:42] <cmr> which you can control using scopes
[16:14:03] <smvv> indeed. The argument for merging free operations of small allocations makes sense
[16:14:04] *** Joins: SiegeLord (sl@moz-56D7E78.bstnma.fios.verizon.net)
[16:14:05] <engla> the compiler should be free to put the deallocs where it wants if there are no destructors
[16:14:20] <bstrie> nmatsakis: so back when you first wanted to add regions to rust everyone was talking about how we'd have to simplify them to make them easier to use. how do rust's regions differ from the more advanced systems you were presumably referencing?
[16:14:22] *** Quits: josh (josh@moz-348C4790.hsd1.mn.comcast.net) (Quit: josh)
[16:14:27] *** Quits: jedestep (jedestep@34641662.FB4DE631.66C78B76.IP) (Ping timeout)
[16:14:28] *** Joins: victorporof (victorporo@9D267AB6.30DB0DDD.9B1E38F4.IP)
[16:14:32] <dbaupp> engla: (all the deallocs happen via dtors)
[16:15:45] *** Joins: erickt (erickt@8C9ECD8F.3A598286.F12515B4.IP)
[16:16:24] * engla stalls this trivial patch on not being able to write a nice one-line doc for it
[16:17:04] *** Quits: dbaupp (Thunderbir@moz-712A1135.lns20.syd6.internode.on.net) (Ping timeout)
[16:17:31] <bblum> golfing documentation, truly the developer's bane
[16:17:34] *** Quits: erickt (erickt@8C9ECD8F.3A598286.F12515B4.IP) (Ping timeout)
[16:17:48] *** Joins: vk (chatzilla@3E9D68F2.B1163E0C.2A6693DD.IP)
[16:17:59] <MaikKlein> is anyone here a web developer?
[16:18:54] <cmr> I'm a recovering web dev
[16:19:56] <MaikKlein> cmr, m2 I am currently researching some webframeworks
[16:20:22] <MaikKlein> there are just too many :/
[16:20:33] <cmr> just pick one
[16:20:44] <cmr> they're all different in mostly unimportant ways
[16:21:57] <MaikKlein> I already have experience with django, play2, lift , web2py... but I probably go with rails, then I have an excuse to learn ruby
[16:22:07] *** Joins: BizarreCake (BizarreCak@moz-361FE9B2.dynamic.barak-online.net)
[16:22:37] <bstrie> MaikKlein: as a web developer, I really, really, really, really, really, really, really hate the word "framework"
[16:22:47] <nmatsakis> bstrie: good question---they don't differ as much as I hoped they would,
[16:23:07] <bstrie> MaikKlein: so what are you *really* looking for? :)
[16:23:25] <bstrie> nmatsakis: did it gradually become more like the research, given that lifetime names are more explicit now?
[16:23:26] *** Joins: pnathan (Adium@B9840254.2CD8A5F8.477B877D.IP)
[16:23:34] <nmatsakis> bstrie: two things come to mind. first, some region systems offer the ability to say "fn<'a, 'b>(...) where 'a <= 'b" and other such constriants, 
[16:23:49] <nmatsakis> bstrie: second, the most advanced region systems do not use regions that correspond to lexical scopes,
[16:24:01] <nmatsakis> bstrie: but rather are kind of like ~ pointers, they are "moved arond" and "consumed"
[16:24:06] *** Quits: bjz (brendanzab@B398BE78.F804C29E.D35A31DF.IP) (Quit: Leaving...)
[16:24:11] <bstrie> aha
[16:24:15] *** Quits: paulproteus (quassel@rose.makesad.us) (Ping timeout)
[16:24:19] *** Joins: paulproteus (quassel@moz-E86A3B42.makesad.us)
[16:24:32] <smvv> MaikKlein: i think it is more useful to have set of good libraries (e.g. Go's gorilla libs; http://gorillatoolkit.org) than a full-featured framework
[16:24:52] <MaikKlein> bstrie, well I started low level web development with python. but it was really really cumbersome to write everything by myself
[16:25:02] <bstrie> MaikKlein: what are you trying to write?
[16:25:13] <nmatsakis> bstrie: so we have managed to simplify *somewhat*, though it's partly a matter of perspective. In Cyclone, for example, unique pointers were a special reigon: you can view this as unifying, but since they behave so differently I don't think it really simplifies? hard to say.
[16:25:40] <nmatsakis> kind of forget the details of how they made that work, or maybe I'm misremembering a bit
[16:26:08] <MaikKlein> bstrie, hm, I thought I  play around with some video streaming, just for fun. it's more a hobby I guess
[16:26:12] <bstrie> nmatsakis: ok, thanks
[16:26:22] <MaikKlein> smvv, I actually also wanted to learn go :)
[16:26:54] *** Joins: eschweic (Adium@moz-BBE3ABD.mv.mozilla.com)
[16:27:05] *** Quits: BizarreCake (BizarreCak@moz-361FE9B2.dynamic.barak-online.net) (Connection reset by peer)
[16:27:12] *** Quits: brendan (brendaneic@10487EE8.58B1B661.22B0E380.IP) (Quit: brendan)
[16:27:30] <MaikKlein> bstrie, so you also say I should look more into toolkits like gorillatoolkit?
[16:27:52] <nmatsakis> bstrie: (in answer to your question, yes, when we decided to move to the lifetime syntax and make things more explicit, I think we took a step closer to the research. before that we were hoping we could get away with less flexibility and more defaults...)
[16:28:07] <nmatsakis> ...as you no doubt recall
[16:28:09] <bstrie> MaikKlein: in general I do agree with smvv, a full "web framework" is almost always overkill unless you're trying to turn this into a team project. good libs are what you want
[16:28:11] <MaikKlein> smvv, haha best quote ever " "I wish Gorilla was written in Haskell." -- Rasmus Jørgensen, Haskell developer "
[16:28:41] <toddaaro> bblum: you around?
[16:28:48] <bblum> toddaaro: yeah
[16:28:56] <MaikKlein> bstrie, what lang/toolkit are you using the most?
[16:29:16] <bstrie> nmatsakis: so do you think we're at a good place now wrt flexibility vs defaults? or do you foresee rust having the 'a <= 'b or other notions in the future?
[16:29:24] <toddaaro> bblum: do you understand the "old" join_latch destructor code? I'm getting an "assertion failed: self.closed" when I try to destruct the scheduler task
[16:29:43] <nmatsakis> bstrie: I think we're in a pretty good place. We actually do have a kind of sneaky backdoor version of 'a <= 'b... but you never need to say it explicitly
[16:29:58] <bblum> toddaaro: yeah, like Task, JoinLatch needs to be manually destructed
[16:30:03] <bstrie> MaikKlein: okay well understand that in a professional capacity I use PHP, and I was so disgusted with all php frameworks that I just made something myself :P
[16:30:08] <bblum> toddaaro: as happens in Task::destroy
[16:30:25] <nmatsakis> bstrie: in particular, if you have a fn with a parameter of type &'a Foo<'b>, we assume 'a <= 'b, because otherwise it'd be illegal to create that borrowed pointer (the pointer can't outlive what it points at, in other words)
[16:30:27] <bstrie> MaikKlein: but both python and go sound like good options
[16:30:41] <nmatsakis> bstrie: that's needed to make some code work with explicit self
[16:30:50] <bstrie> MaikKlein: I've also heard lots of good things about flask, which is a python pseudo-framework
[16:30:56] <bstrie> (god do I hate that word)
[16:31:01] <toddaaro> bblum: ah, is that "cleanup::annihilate()"?
[16:31:03] <cmr> It's a perfectly suitable word.
[16:31:07] <MaikKlein> bstrie, I was using flask in the past as my main "framework"
[16:31:09] <bstrie> it's meaningless!
[16:31:13] <cmr> It's a library that calls into your code, rather than the other way around
[16:31:20] <bstrie> "frameworks" do everything under the sun nowadays
[16:31:22] <cmr> Primarily interacted with via callbacks
[16:31:32] <MaikKlein> bstrie, ok thanks I probably look into go :p 
[16:31:44] <bblum> toddaaro: no, sorry, jl actually destroyed in Task::run *after* destroy()
[16:31:48] *** Joins: josh (josh@moz-348C4790.hsd1.mn.comcast.net)
[16:32:03] <bblum> just a few lines above
[16:32:07] <toddaaro> bblum: ahh ok, thans
[16:32:09] <toddaaro> *thanks
[16:32:51] <bstrie> nmatsakis: thanks again
[16:32:54] <bblum> toddaaro: you should use the quickest gross hack to fix it as possible since my stuff has r+ already
[16:33:05] <toddaaro> bblum: k, I figured as much
[16:33:26] <bblum> though i still have to hash some things out with brian
[16:33:35] *** Quits: cdidd (cdidd@moz-1F4FBDB7.broadband.corbina.ru) (Input/output error)
[16:33:36] <bblum> (also it has bitrotted, great)
[16:33:37] <toddaaro> bblum: I'm pretty sure this is the final issue, then I re-enable the remaining tests and cleanup code
[16:33:43] *** Quits: rusti (rusti@moz-54F7FD49.cpe.net.cable.rogers.com) (Ping timeout)
[16:33:44] <toddaaro> bblum: so we should be set for misery time this afternoon
[16:33:51] <bblum> misery time?
[16:33:57] <toddaaro> merging!
[16:34:16] <toddaaro> like how every question you asked me was answered with "uh, well I'm changing that right now but..."
[16:34:29] <bblum> oh yes
[16:34:40] <bblum> i mean, pending bors
[16:34:50] <bblum> maybe i'll bump it's p-value
[16:34:59] <toddaaro> that would be good
[16:35:03] <bblum> (make like a bad statistics researcher and fudge the p-values)
[16:35:08] <toddaaro> if you can make bors do it before lunch that would be *awesome*
[16:35:22] <bblum> uh. we'll see about that.
[16:35:48] *** Joins: cdidd (cdidd@moz-846CF04C.broadband.corbina.ru)
[16:36:01] *** Quits: pnathan (Adium@B9840254.2CD8A5F8.477B877D.IP) (Quit: Leaving.)
[16:36:06] <MaikKlein> bstrie, how much work do you think would it be to roll something in Rust?
[16:36:15] <cmr> MaikKlein: a lot
[16:36:17] <bstrie> MaikKlein: would be painful :)
[16:36:22] <cmr> MaikKlein: you'll be doing everything from scratch
[16:36:26] <bstrie> remember when I said that you need good libs?
[16:36:33] <MaikKlein> :(
[16:36:37] <bstrie> that's code for "don't use rust here" :P
[16:36:48] <bstrie> MaikKlein: no, don't be sad!
[16:36:56] <bstrie> MaikKlein: you need to get more experience with other language's libs
[16:36:59] <bstrie> and then you can write them for rust!
[16:37:04] <MaikKlein> !
[16:37:07] <bstrie> you are making us better by broadening your horizons
[16:37:13] <cmr> see: wsgi and others
[16:38:38] <cmr> node has a bunch of good stuff to draw from too
[16:38:48] *** Joins: pnathan (Adium@B9840254.2CD8A5F8.477B877D.IP)
[16:39:36] *** Parts: pnathan (Adium@B9840254.2CD8A5F8.477B877D.IP) ()
[16:42:17] <eevee> be there a rust ubuntu ppa anywhere that's actually kept up to date
[16:42:23] <cmr> yes
[16:42:28] <cmr> someone posted one to the ML yesterday
[16:42:31] <cmr> nightly builds
[16:42:39] <eevee> wow that's extremely up to date
[16:42:47] <eevee> maybe i should start working against nightlies anyway
[16:42:54] <bstrie> eevee: what problems are you having updating your roguelike?
[16:43:29] <eevee> bstrie: apparently my amulet design is crap  https://gist.github.com/eevee/6034960
[16:43:35] *** Quits: int3_ (int3_@moz-ABE52D50.hsd1.ca.comcast.net) (Client exited)
[16:43:51] <eevee> bstrie: the only solution seems to be to force @ on Terminal which kinda sucks
[16:43:56] *** Joins: int3_ (int3_@moz-ABE52D50.hsd1.ca.comcast.net)
[16:44:57] <bstrie> gisting the vim conceal characters to obfuscate your code... clever move
[16:45:13] *** Joins: ecr (Thunderbir@moz-BBE3ABD.mv.mozilla.com)
[16:45:37] <MaikKlein> eevee, shouldn't it be AppState<'self> ?
[16:45:43] *** Quits: int3_ (int3_@moz-ABE52D50.hsd1.ca.comcast.net) (Ping timeout)
[16:45:52] <MaikKlein> could be confused though
[16:46:06] <eevee> bstrie: hahaha, sorry, was sshing and had to copy from the terminal window
[16:46:13] <cmr> eevee: something has to own the Terminal somewhere
[16:46:24] <cmr> eevee: as it stands, the scope owns the terminal, in get_app_state
[16:46:30] <cmr> whichg means you cannot return a reference to it
[16:46:48] <doy> you probably just want to have the AppState own the terminal
[16:46:52] <cmr> either the AppState has to own the terminal, or it needs to be owned by the GC
[16:46:58] <doy> so you should use ~ instead of &
[16:47:01] <doy> or something along those lines
[16:47:01] <eevee> alas, returning it in any other way means i can't tell rust that it has the same lifetime as the canvases
[16:47:39] <bstrie> uh oh, #crawl-offtopic is overtaking #rust
[16:47:45] <doy> haha
[16:47:58] *** bstrie is now known as Wensley
[16:48:06] <doy> oh hi
[16:48:06] <Wensley> when in neo-rome
[16:48:07] <doy> (:
[16:48:36] * cmr is confused
[16:48:57] *** Joins: rusti (rusti@moz-54F7FD49.cpe.net.cable.rogers.com)
[16:49:43] *** Joins: C_D (Search@FE07FAB0.2D232D0D.F5B38AFB.IP)
[16:50:12] <Wensley> eevee: surely this didn't work in old versions of rust?
[16:50:29] <Wensley> or are you just trying to wean it off of @s now
[16:51:12] <eevee> it didn't; i've been weaning amulet off @ (without considering clio enough, apparently) and older rust had some kind of borrow bug that let me get away with something else iirc
[16:51:24] <cmr> yeah
[16:51:30] *** Joins: infynyxx (infynyxx@DB780A29.749BA1D.DCC373F0.IP)
[16:51:35] <cmr> the borrow checker had arbitrary restrictions and soundness bugs
[16:51:41] <MaikKlein> eevee, you could wrap it in a new struct "struct MyApp { state: AppState: term: Terminal}...
[16:51:57] <Wensley> yeah, new rust is more correct but also more lenient in some cases
[16:52:19] <doy> eevee: really, the way that canvas and term are related is really confusing
[16:52:25] <doy> and i think that's where most of the problems are
[16:52:32] <doy> Terminal creates a Canvas instance
[16:52:40] <doy> but the Canvas instance contains the Terminal
[16:52:49] <MaikKlein> hm
[16:52:54] <doy> and so getting ownership correct with that situation is really confusing
[16:53:10] <MaikKlein> why don't you move the Terminal into the AppState?
[16:53:41] <eevee> spawning a child which remembers its parent can't be that uncommon surely
[16:54:04] <eevee> MaikKlein: doesn't help; there's nothing linking the Terminal to the Canvases
[16:54:15] <eevee> well, it cuts me down to one borrow error rather than two
[16:54:45] *** zz_kimundi is now known as kimundi
[16:54:56] *** Joins: int3_ (int3_@moz-ABE52D50.hsd1.ca.comcast.net)
[16:55:44] <MaikKlein> eevee, because what you are trying to write makes no sense to me, you are doing "let term = Terminal::new();" but then you create an AppState with a reference to term. but after the function call term is out of scope
[16:55:50] <MaikKlein> so it can't work
[16:56:17] <eevee> yeah, fair.  borrowing term was my hamfisted attempt to get the lifetime name onto term somehow  :)
[16:56:21] *** Quits: SimonSapin (simon@88F51059.F3BBB17D.144F44FA.IP) (Quit: Leaving.)
[16:57:28] *** Joins: SimonSapin (simon@88F51059.F3BBB17D.144F44FA.IP)
[16:57:43] <MaikKlein> eevee, you could do
[16:58:02] <MaikKlein> get_app_state<'r>(term: Terminal)
[16:58:19] <Wensley> eevee: you also don't need to name the lifetime "self" anymore, afaik
[16:58:27] <MaikKlein> Wensley, really?
[16:58:27] <Wensley> in fact I sort of thought that was illegal
[16:58:32] *** Joins: graydon (Adium@A5087023.2354C43D.D8E68FF6.IP)
[16:58:33] *** ChanServ sets mode: +qo graydon graydon
[16:58:39] <MaikKlein> Wensley, what do we use now?
[16:58:43] <cmr> there are some weird rules about lifetime names
[16:58:48] <Wensley> MaikKlein: can't you just use any old name that you want?
[16:58:51] *** Joins: spider-mario (spidermari@moz-81131DB6.fbx.proxad.net)
[16:58:56] <cmr> it's fine in some contexts but not in all
[16:59:00] <eevee> it seems to be illegal sometimes and required other times -- i think it's required when defining the structure (or on an impl) and forbidden on individual fns
[16:59:01] <Wensley> cmr: sadness
[16:59:13] <Wensley> hm, ok
[16:59:22] <Wensley> that seems a little bit sane, at least
[16:59:23] <MaikKlein> I think we need a TWIR for this :p
[16:59:29] *** Joins: Blub\w (wry@B283ED27.BB479103.9F19D8E2.IP)
[16:59:35] *** Quits: tcr (tcr@moz-EE576D3C.hsd1.ma.comcast.net) (Client exited)
[16:59:51] * MaikKlein eating...
[16:59:57] *** Joins: tcr (tcr@moz-EE576D3C.hsd1.ma.comcast.net)
[16:59:58] <cmr> TWiR is a news summary.
[17:00:14] <Wensley> cmr: no, it's a complete news network! you have to think big!
[17:00:31] <MaikKlein> :D
[17:00:40] *** Joins: infynyxx_ (infynyxx@moz-E95B370B.nyc.res.rr.com)
[17:01:02] <toddaaro> rust build infrastructure question: is there a way to track various code statistics through the commit history?
[17:01:15] <cmr> toddaaro: not really no
[17:01:24] <toddaaro> an example would be "lines of unsafe code", so if you have a commit with lots of new unsafe code it shows up somehow
[17:01:25] <cmr> besides ohloh I guess?
[17:01:36] <cmr> nope nothing like that
[17:01:42] <toddaaro> it seems really hard, as it requires parsing the language
[17:01:45] <toddaaro> ok, that is what I expected
[17:01:55] <cmr> it's not that hard if you use libsyntax
[17:02:02] <toddaaro> hm
[17:02:18] <Wensley> that would be interesting
[17:02:20] *** Quits: infynyxx_ (infynyxx@moz-E95B370B.nyc.res.rr.com) (Ping timeout)
[17:02:21] <toddaaro> what kind of effort would enabling this be then?
[17:02:27] <cmr> probably not a ton
[17:02:33] *** Quits: tcr (tcr@moz-EE576D3C.hsd1.ma.comcast.net) (Ping timeout)
[17:02:50] <Wensley> I don't know how well libsyntax can track "lines" though
[17:02:54] <toddaaro> if a week of casual effort would let us track all kinds of cool stuff it should be "on the list" of things we suggest to possible contributors
[17:02:55] <eevee> number of uses of deprecated features, number of warnings, number of types/functions...
[17:02:56] <cmr> I'd imagine it'd be a separate tool, use the AST visitor and check the things it wants.
[17:02:57] <Wensley> after lexing it's just tokens
[17:02:59] <eevee> think of all the graphs!
[17:03:09] <cmr> Wensley: Every AST item has an associated span
[17:03:10] <toddaaro> Wensley: well, "lines" is sort of meh, statements is probably more appropriate
[17:03:16] <cmr> You can get the source from that span and count the newlines.
[17:03:26] <Wensley> ah ok
[17:03:34] *** Joins: azakai_ (alon@moz-BBE3ABD.mv.mozilla.com)
[17:03:45] *** Joins: dwhyte (dwhyte@ED9190FB.B72E355F.7BF4A4B0.IP)
[17:04:02] *** Joins: brendan (brendaneic@10487EE8.58B1B661.22B0E380.IP)
[17:07:54] *** Joins: pcwalton (pcwalton@moz-7B0110AD.mv.mozilla.com)
[17:07:54] *** ChanServ sets mode: +o pcwalton
[17:08:04] *** Joins: jdm (jdm@F2D29657.F60B0462.67AC9B1.IP)
[17:08:55] *** Quits: pnkfelix (pnkfelix@87C1F78E.1DE10CA8.D8E68FF6.IP) (Quit: Leaving.)
[17:08:56] <smvv> why does rustc 0.8-pre complain here about a lacking implementation of Clone for the enum Error? https://gist.github.com/smvv/6040719 is a numerical enum not an immutable immediate value and therefore not copyable by default? i do not see a reason why it would be necessary to copy/clone the value of the enum here
[17:09:10] *** Joins: brson (brson@E9CDE21E.991753BB.CA4D1600.IP)
[17:09:10] *** ChanServ sets mode: +o brson
[17:09:22] *** Joins: jedestep (jedestep@34641662.FB4DE631.66C78B76.IP)
[17:10:03] <engla> not right now no smvv 
[17:10:17] <cmr> smvv: not, nothing is implicitly clonable
[17:10:22] <engla> Copy has just been removed in favor of Clone so such things will be sorted out
[17:10:27] *** Quits: brendan (brendaneic@10487EE8.58B1B661.22B0E380.IP) (Quit: brendan)
[17:12:50] *** Joins: seth (seth@moz-BE33DA21.fw1.sfo1.mozilla.net)
[17:13:50] <smvv> ok. #[deriving(Clone)] fixes it
[17:13:50] *** Joins: jensnockert (jensnocker@moz-C5F27039.cust.bredband2.com)
[17:14:01] *** Joins: mschifer (Adium@moz-BBE3ABD.mv.mozilla.com)
[17:16:14] *** Joins: erickt (erickt@8C9ECD8F.3A598286.F12515B4.IP)
[17:17:46] *** Joins: sigma (sigma@CB3F6051.C886FCFF.DF0EE696.IP)
[17:18:17] <toddaaro> anyone know how to find out if a macro is throwing an error because of input passed to it?
[17:18:19] *** Quits: erickt (erickt@8C9ECD8F.3A598286.F12515B4.IP) (Ping timeout)
[17:18:39] <toddaaro> swapping out rtdebug for the non-printing version gives an error that only mentions the macro, but the version I have is the same as master
[17:18:54] <toddaaro> so it must be a callsite problem, but I can't figure out how to tell what one it is
[17:19:19] *** Quits: true_droid (Adium@moz-123FD9B8.beck.volia.net) (Quit: Leaving.)
[17:20:58] <doy> this does seem like something that should be possible (eevee's question, that is)
[17:21:20] *** Joins: erickt (erickt@8C9ECD8F.3A598286.F12515B4.IP)
[17:21:23] <doy> having a struct that holds two other structs, one of which has a borrowed pointer to the other
[17:22:12] <eevee> ok i'm not totally crazy at least
[17:22:17] <doy> i just can't figure out how to actually construct it
[17:22:20] <Wensley> doy: only nmatsakis can say if that's actually possible
[17:22:26] <eevee> the obvious thing was ~'self Terminal but that obviously doesn't work
[17:22:29] <doy> yeah, that was my next thought
[17:22:30] <doy> (:
[17:22:41] *** Joins: jaen (jaen@moz-36261275.internetdsl.tpnet.pl)
[17:22:57] <cmr> eevee: owned boxes can't have lifetimes
[17:23:04] <cmr> they're always alive, doesn't make sense :p
[17:23:08] <doy> eevee: the right change in terms of ownership is that the terminal member in appstate shouldn't be a borrowed pointer
[17:23:11] *** Joins: tcr (tcr@moz-EE576D3C.hsd1.ma.comcast.net)
[17:23:23] <doy> both the terminal and the canvas should be owned by the appstate
[17:23:26] <engla> doy: think of lifetimes as being tied to scopes, not values
[17:23:54] <doy> engla: sure
[17:24:00] <doy> but that doesn't quite help
[17:24:44] <MaikKlein> anyone here was working on a tcp server right?
[17:24:54] <eevee> https://gist.github.com/eevee/6034960  ok ok it's owned now
[17:24:54] <engla> doy: it sounds like it should be possible
[17:24:55] <toddaaro> easier question for the macrologists: what exactly does ( $(let _ = $arg)*; ) mean as a RHS
[17:25:10] <toddaaro> I assume this is taking each of the many input args and turning them into let bindings with 
[17:25:16] <jensnockert> graydon: I tried doing #[lang] for SIMD, and I think it could work out reasonably, except for a set of bugs that are in the compiler right now.
[17:25:17] <toddaaro> "who cares" as the identifier name
[17:25:31] <cmr> pauls: ^
[17:25:43] <graydon> jensnockert: excellent!
[17:25:52] <kimundi> toddaaro: Yes, but I think as written it expands to an syntax error
[17:26:08] <toddaaro> kimundi: somehow this code is in master and works, so I'm not sure what is going on
[17:26:14] <kimundi> hmm
[17:26:20] <toddaaro> but for me yes, syntax error
[17:26:30] <jensnockert> graydon: Wellâ€¦ the mountain is that cross-crate generics using tuple-like structs simply doesn't work.
[17:26:30] <cmr> eevee: hmmm I think this might be a bug?
[17:26:41] <kimundi> Imo it should be ( $(let _ = $arg);* )
[17:26:53] <kimundi> or Imo it should be ( $(let _ = $arg;)* )
[17:26:54] <cmr> eevee: I think it should detect the term is moved into something with a longer lifetime and that the canvas will live long enough
[17:27:02] <cmr> nmatsakis: ^
[17:27:10] <eevee> oh really
[17:27:28] <doy> that is kind of my thought too
[17:27:48] <eevee> i am great at running into bugs
[17:27:56] <cmr> it's hard not to :p
[17:28:13] <kimundi> Would be horrible if everyone evades all the bugs
[17:28:21] <MaikKlein> if I do struct Foo { bar: Bar}; let a = ~Foo; is Foo.bar on the stack or on the heap?
[17:28:49] <kimundi> MaikKlein: heap
[17:29:00] <toddaaro> kimundi: no luck on any, the exact error I get in each case is "found `let` in ident position"
[17:29:11] <kimundi> bar is a part of Foo, wich you put on the heap
[17:29:33] <MaikKlein> kimundi, ok thanks
[17:29:58] <kimundi> toddaaro: Hm...
[17:30:21] <kimundi> try ( {$(let _ = $arg;)*} )
[17:31:05] *** Joins: vosen (vosen@moz-266BA656.icpnet.pl)
[17:32:01] *** Joins: sanxiyn (tinuviel@858F408C.B797260D.EF43EC08.IP)
[17:32:22] <sanxiyn> Tried writing some SIMD example codes
[17:32:22] <sanxiyn> https://gist.github.com/sanxiyn/6040905
[17:32:28] <MaikKlein> kimundi, and if it would be Foo { bar: ~Bar}; let a = ~Foo; then the pointer to bar would be on the heap right? so we can have pointers on the heap?
[17:32:29] *** Quits: infynyxx (infynyxx@DB780A29.749BA1D.DCC373F0.IP) (Client exited)
[17:32:45] *** Quits: CarpNet (ac@moz-FD24B77.sohonet.co.uk) (Quit: Leaving)
[17:32:50] <jensnockert> sanxiyn: Hello sanxiyn.
[17:32:54] <sanxiyn> jensnockert: Hi
[17:33:08] <nmatsakis> doy: http://www.pastebin.mozilla.org/2655999 ?
[17:33:12] <jensnockert> I tried making Vectors generic, but it just doesn't work in the compilers right now :(
[17:33:13] <kimundi> MaikKlein: yep
[17:33:34] *** Quits: rusti (rusti@moz-54F7FD49.cpe.net.cable.rogers.com) (Ping timeout)
[17:33:55] <toddaaro> kimundi: that failed with a slightly different error, moving the 'try' inside the first paren made it "go" though, just spit out ~90 errors on try being OOS
[17:34:04] <nmatsakis> cmr: eevee: what do you think is a bug?
[17:34:05] <sanxiyn> jensnockert: Yes, that's why there is "SIMD vectors cannot be generic" message in typeck...
[17:34:13] <nmatsakis> cmr: eevee: are you saying that this should type check: http://www.pastebin.mozilla.org/2655999
[17:34:15] <toddaaro> kimundi: but I wouldn't be surprised if post-fixing those the original is still there
[17:34:26] <pauls> toddaaro: I believe your analysis is correct.
[17:34:32] <toddaaro> kimundi: this code as present in master works for other people, so I'm puzzled by what is going on
[17:34:32] <jensnockert> sanxiyn: Yeah, but it doesn't work for regular structs either.
[17:34:35] <kimundi> toddaaro:, err 'try' ? That was not supossed to be part of code xD
[17:34:42] <jensnockert> sanxiyn: Which is the main problem
[17:34:44] <nmatsakis> cmr: eevee: (because it shouldn't :)
[17:34:55] <jensnockert> *regular tuple-like structs.
[17:34:55] <pauls> toddaaro: although I'm not sure if `let`s can be non-semicolon-separated.
[17:34:57] <toddaaro> kimundi: that is what I figured, but it didn't work out
[17:35:04] <sanxiyn> jensnockert: What is the main problem?
[17:35:05] <cmr> nmatsakis: seems like it should to me :\
[17:35:23] <nmatsakis> cmr: well, in an ideal world perhaps, but the current Rust type system can't express that, at least not in that way,
[17:35:37] <toddaaro> the exact line copy-pasted from master is: "($( $arg:expr),+) => ( $(let _ = $arg)*; )"
[17:35:39] <pauls> kimundi: oh, you said that. Sorry I didn't notice.
[17:35:52] <nmatsakis> cmr: eevee: a lifetime is always tied to some concrete expression, in this case, the body of get_app_state()
[17:36:03] <jensnockert> sanxiyn: No idea, something is just broken in the compiler, https://github.com/mozilla/rust/issues/7899
[17:36:05] <pauls> What is the context? It doesn't look all that useful.
[17:36:07] <nmatsakis> cmr: eevee: what cmr was suggested was rather a lifetime tied to the *value*
[17:36:10] <sully> indutny: ping
[17:36:29] <nmatsakis> cmr: eevee: unfortunately, we can't do that right now.
[17:36:37] <toddaaro> pauls: we have a file src/libstd/macros.rs that has a pair of "rtdebug" macros, one prints the other just letbinds, and we toggle them by moving an _ between the names
[17:36:58] <toddaaro> pauls: the "non printing let binding" version is great as it means we don't get lint errors from unused variables when it is "off"
[17:37:08] <sanxiyn> jensnockert: Ah ok
[17:37:22] <pauls> toddaaro: ahh, macros and warning messages, those old enemies.
[17:37:54] <doy> nmatsakis: it doesn't necessarily have to be tied to the value, it could be done with an explicit lifetime annotation there too (would that make sense?)
[17:38:07] <doy> get_app_state has an explicit lifetime variable attached
[17:38:15] <pauls> Warning messages are always fussing, and macros are like "Waaaarnings, you just don't understand!"
[17:38:20] <kimundi> MaikKlein: Rusts memory layout rules are pretty straight forward. Struct fields are just sitting right next to each other in memory. Wich means there is only indirection if you include it explicitly with pointers.
[17:38:27] <nmatsakis> doy: point is, you allocated terminal on the stack and borrowed it there,
[17:38:31] <doy> so being able to say "create something with this other lifetime that's already declared" seems like it'd also solve the issue
[17:38:34] <doy> nmatsakis: yeah, i know
[17:38:36] <nmatsakis> doy: (or rather eevee did),
[17:38:41] <nmatsakis> doy: and it can't move while borrowed right now.
[17:38:46] <nmatsakis> doy: well, you *can* do that with an arena
[17:38:52] <nmatsakis> in principle anyhow
[17:39:08] <nmatsakis> that is, get_app_state could take in an arena as argument with that lifetime and allocate term there
[17:39:15] <nmatsakis> but that's not a well-trodden path right now
[17:39:17] *** Joins: eatkinson (eatkinson@moz-BBE3ABD.mv.mozilla.com)
[17:39:19] <nmatsakis> the other option of course is @
[17:39:26] <nmatsakis> this being kind of what @ exists for
[17:39:38] <nmatsakis> the case where lifetimes of objects are dependent on one another
[17:39:43] <nmatsakis> or, alternatively,
[17:39:53] <nmatsakis> don't create the terminal and canvas together in one function :)
[17:40:05] <nmatsakis> but rather create the terminal where you need it, and create the canvas when you need it
[17:40:12] <toddaaro> pauls kimundi : are there any known issues where a callsite error wouldn't be propogated?
[17:40:17] <nmatsakis> the latter is prob what'd I do
[17:40:20] <doy> yeah, that's probably the best solution, actually
[17:40:32] <toddaaro> pauls kimundi : it seems like there is an invalid use of the macro somewhere that isn't being printed
[17:40:39] <sanxiyn> jensnockert: What do you mean here re: #[lang=...]? https://github.com/mozilla/rust/issues/7899#issuecomment-21232199
[17:40:47] <nmatsakis> eevee: see above... :)
[17:40:50] <toddaaro> pauls kimundi : manually inspecting my ~180 uses is out of the question though
[17:40:51] <eevee> the canvas carries buckets of state and is needed basically indefinitely; it's like a curses window
[17:40:53] <pauls> toddaaro: not that I know of, but that doesn't mean much.
[17:41:12] <nmatsakis> eevee: well, if you can't contain its lifetime with some stack frame,
[17:41:14] <nmatsakis> eevee: then you want @
[17:41:27] <doy> eevee: the canvas contains state that's dependent on the terminal itself?
[17:41:28] <nmatsakis> eevee: well, or ~ I guess, you can move it from place to place.
[17:41:37] <nmatsakis> depends.
[17:41:40] <pauls> You could try using debug macros to print `line!()` and `file!()` each time you expand.
[17:41:44] <jensnockert> sanxiyn: Graydon wanted to change SIMD vectors to #[lang="vec4"] Vec4<T> and so on.
[17:41:54] <toddaaro> brson: do you have any clue what might be going on? I'm super blocked on the rtdebug macro that doesn't print not working despite using a version that is exactly what master has
[17:41:59] <sanxiyn> jensnockert: Hm.
[17:42:06] <jensnockert> sanxiyn: And I promised to try.
[17:42:17] <doy> eevee: if the canvas contains state that's dependent on the actual terminal, it seems like the canvas should own the terminal
[17:42:22] <eevee> doy: no, but it can't actually do any IO without the terminal.  i *could* require passing the terminal in i suppose, producing the somewhat cumbersome `canvas.repaint(term)` and `canvas.read_key(term)` etc
[17:42:34] <doy> if it doesn't, you could just pass the terminal into each canvas method
[17:42:34] <graydon> sanxiyn: the only reason was to make the types uniquely-named, so that there'd be _one_ implementation of vec4, not multiple independently-declared ones.
[17:42:40] <doy> yeah
[17:42:46] <graydon> essentially fighting the fact that they're nominal types
[17:43:01] <eevee> doy: you can have more than one canvas alas
[17:43:03] <eevee> wait hm
[17:43:19] <eevee> maybe i want a third thing that can only exist once, owns the terminal, and is @ within canvases
[17:43:43] <doy> how would that help?
[17:43:50] <sanxiyn> graydon: ok, I got that
[17:43:54] <brson> toddaaro: is it only a syntax error for a specific invocation?
[17:43:56] <eevee> it would let me not enforce that all terminals are @
[17:44:10] <sanxiyn> Not sure why should one fight, though
[17:44:22] <doy> well, you already did that by having Terminal::new return a Terminal (rather than a @Terminal)
[17:44:38] <MaikKlein> Wensley, btw can you explain why it is bad to use "frameworks" like Ruby on Rails? You said it is too much, but isn't this a good thing? I heard Rails is very flexible.... dunno if this is correct
[17:44:54] <doy> the canvas could just hold a @Terminal, and that wouldn't mean that all Terminals would have to be @
[17:44:58] <graydon> sanxiyn: to avoid two libraries being developed with different #[simd] vec4<T>(T,T,T,T); definitions being unable to interoperate
[17:45:04] <doy> but i still don't think this should require @
[17:45:14] <eevee> yeah but if canvas needs to have a @Terminal then half of a terminal's methods sort of vanish when it's not @
[17:45:19] <doy> MaikKlein: depends on what you're trying to do
[17:45:20] <sanxiyn> graydon: No, I understand that part
[17:45:21] <graydon> sanxiyn: the risk with nominal types is always 2 people defining "the same" type (effectively-the-same) with different names, so they can't interoperate
[17:45:23] <graydon> ok
[17:45:32] <sanxiyn> graydon: The question is why SIMD types are nominal types at all
[17:45:39] <sanxiyn> (since they naturally aren't)
[17:46:14] <doy> eevee: i still think just passing in the terminal as a method parameter is a better idea
[17:46:28] <cmr> eevee: I don't, nasty API ;(
[17:46:31] <doy> you could then wrap them both in a third thing that forwards methods to the canvas object, passing along the terminal pointer
[17:46:39] <graydon> sanxiyn: so there's something to attach the #[simd] to.
[17:46:50] <doy> if you thought the api was too ugly otherwise
[17:46:58] <MaikKlein> doy, hm when wouldn't I want to use something like rails?
[17:47:02] <toddaaro> brson: there is no invocation information in the error message, it only points to the macro definition
[17:47:07] <graydon> sanxiyn: we can't denote #[simd](T,T,T,T) as a type term
[17:47:29] <doy> MaikKlein: frameworks like rails are useful if you're writing an application that is very much like the kind of application that rails expects
[17:47:36] <toddaaro> brson: it seems like there is an error in the expanded code from an invocation and a bug in the error handling is preventing it from propogating
[17:47:48] <doy> MaikKlein: which is a common pattern, but not universal by any means
[17:47:48] <sanxiyn> graydon: Indeed, since attributes are attached to definition site
[17:47:58] <toddaaro> brson: but there are ~180 invocations so...
[17:48:01] <eevee> rails prides itself on being opinionated, but there are far less opinionated frameworks
[17:48:15] <pauls> toddaaro: and there's only one span it gives? Errors deep in macro calls should give a stack of locations.
[17:48:17] <doy> if you want to do something different, it's easier to start from smaller building blocks and work up than to try to reconfigure something like rails to do what you actually want
[17:48:19] *** Joins: FrozenCow (FrozenCow@moz-B2DF4929.chello.nl)
[17:49:37] *** Joins: rusti (rusti@moz-54F7FD49.cpe.net.cable.rogers.com)
[17:49:44] *** Joins: BizarreCake (BizarreCak@moz-361FE9B2.dynamic.barak-online.net)
[17:50:01] *** Joins: infynyxx (infynyxx@DB780A29.749BA1D.DCC373F0.IP)
[17:50:05] *** Joins: FrozenCow_ (FrozenCow@moz-B2DF4929.chello.nl)
[17:50:06] <MaikKlein> doy, hm okay thanks
[17:50:25] *** Quits: FrozenCow (FrozenCow@moz-B2DF4929.chello.nl) (No route to host)
[17:50:29] <sanxiyn> graydon: We could also introduce a new kind of type instead of using attributes
[17:50:32] <bblum> brson: let's talk about failure at some point today
[17:50:39] <bblum> in person preferably
[17:51:07] *** Quits: josh (josh@moz-348C4790.hsd1.mn.comcast.net) (Quit: josh)
[17:51:24] <graydon> sanxiyn: yes. that's what I'm trying to avoid.
[17:51:26] <brson> bblum: I've scheduled a meeting for tuesday. does that work?
[17:51:39] <bblum> um, tuesday is fine
[17:51:39] <toddaaro> pauls: yea, just a single error message pointing at the macro definition
[17:51:43] <graydon> sanxiyn: I know <T,T,T,T> works. it just touches a lot more places in the language.
[17:51:58] *** Quits: lucian (lucian@6B2B4644.4304AE1E.CE5E78F6.IP) (Ping timeout)
[17:52:04] <cmr> graydon: sanxiyn: I feel like SIMD shouldn't be this invasive?
[17:52:09] <graydon> sanxiyn: trying to avoid a major change like that this late in the game.
[17:52:26] <bblum> oh, i see there is a tuesday in my email
[17:52:27] <sanxiyn> ok
[17:52:27] <toddaaro> brson: ok, I made a modified rtdebug macro that let-binds a formated string and that works
[17:52:41] <brson> toddaaro: ok, good
[17:52:55] <cmr> graydon: Can you elaborate on having multiple #[simd] vec4's not interoperating?
[17:53:48] <graydon> cmr: if module a and module b both define struct Foo, even if they give equivalent definitions
[17:53:58] <graydon> cmr: you cannot use a::Foo where b::Foo is expected and vice versa
[17:54:05] <graydon> that's nominal types
[17:54:13] <cmr> graydon: Right, which only makes sense.
[17:54:16] *** Quits: vk (chatzilla@3E9D68F2.B1163E0C.2A6693DD.IP) (Ping timeout)
[17:54:17] <graydon> (we resisted nominal types for a long time because of this)
[17:54:27] <cmr> I'd expect a std::simd for most uses.
[17:54:37] <graydon> so if two people defined #[simd]struct Vec4<T> and used _their_ Vec4
[17:54:43] <graydon> those two people's libraries would not interoperate
[17:55:03] <graydon> you couldn't take foo::Vec4<int> and use it as an arg for a function taking bar::Vec4<int>
[17:55:05] <cmr> Why should you expect to be able to pass a Vec4 from two different libraries between each other?
[17:55:13] *** Joins: vk (chatzilla@3E9D68F2.B1163E0C.2A6693DD.IP)
[17:55:23] <jensnockert> cmr: Because they are not structs.
[17:55:25] <graydon> because it's a native machine type! :)
[17:55:26] *** Quits: Blub\w (wry@B283ED27.BB479103.9F19D8E2.IP) (Quit: gtg)
[17:55:41] <cmr> Then #[simd] doesn't make sense
[17:55:50] <sanxiyn> cmr: #[lang] approach is basically making std::simd the canonical type
[17:55:54] <graydon> yes
[17:55:55] <jensnockert> Also, things like a == b, should produce a bool-vector, which nominal type should you pick up?
[17:56:14] <sanxiyn> cmr: That is necessary, since compiler needs to be able to construct SIMD types which was not given
[17:56:27] <sanxiyn> e.g. vector comparison of float4 should result in bool4
[17:56:38] <sanxiyn> Ah late
[17:58:07] <jensnockert> #[lang="vec4"] and so on is just a syntax work-around imho.
[17:58:29] <cmr> It feels to me like simd types should be a first-class construct with explicit compiler support
[17:58:36] <jensnockert> Vec4<T> is just new syntax for a vector, it is magical in every sense of the word.
[17:59:15] *** Quits: fabiand (fabiand@moz-F2EF568F.adsl.alicedsl.de) (Quit: Verlassend)
[17:59:27] <jensnockert> cmr: The question is essentially, Vec4<T> (or similar struct-like) or some other syntax for it.
[18:00:12] *** Joins: bjz (brendanzab@B398BE78.F804C29E.D35A31DF.IP)
[18:00:24] <jensnockert> (And to some extent, how they should be implemented in the compiler)
[18:00:41] <cmr> Tuples seem like a perfect match. You can't access their members except by destructuring, which seems to be quite similar to SIMD semantics, at least on x86?
[18:00:41] *** Joins: brson_ (brson@moz-BBE3ABD.mv.mozilla.com)
[18:00:55] <bblum> brson: btw, spending today and yesterday implementing select(); i expect to have that mostly-done and working today
[18:00:55] *** Quits: brson (brson@E9CDE21E.991753BB.CA4D1600.IP) (Ping timeout)
[18:01:33] <jensnockert> cmr: Not really, SSE has quite complex shuffle units.
[18:01:50] *** Joins: noam (noam@F6B530A7.720527A7.416762B.IP)
[18:02:36] <sanxiyn> cmr: Well, it may be like tuple, but it is something different
[18:02:49] <sanxiyn> For example, tuple can be arbitrarily large, SIMD types should fit in a register
[18:03:21] <cmr> right
[18:03:22] <jensnockert> The type closest to a SIMD type in Rust is [T, ..n].
[18:03:42] *** Quits: pcwalton (pcwalton@moz-7B0110AD.mv.mozilla.com) (Quit: pcwalton)
[18:04:01] *** Joins: tikue (tkuehn@moz-BBE3ABD.mv.mozilla.com)
[18:04:10] <sanxiyn> Well, whatever syntax, you want to check SIMD element type is reasonably machine type
[18:04:35] <cmr> Also what should the compiler do when a given SIMD type or operation isn't supported on the target architecture/
[18:04:44] <jensnockert> (That is bool, in, un, fn or *T)
[18:04:50] <tikue> hey guys, this is probably a really silly idea -- but wouldn't it be cool if there were a way to annotate a method to say "you only need to freeze these specific fields"
[18:04:51] <sanxiyn> cmr: That's easy, because LLVM takes care of it
[18:04:56] <cmr> Oh, ok
[18:05:16] *** Quits: eschweic (Adium@moz-BBE3ABD.mv.mozilla.com) (Quit: Leaving.)
[18:05:17] <sanxiyn> cmr: LLVM "legalizes" all vector types to scalar if vector types are not supported
[18:05:20] <tikue> like, still have it take &mut self, but some kind of annotation so that not all of self freezes
[18:05:25] <cmr> Ok, that's good and what I'd expect.
[18:05:52] <sanxiyn> cmr: That's actually quite involved and annoying piece of code, but not my code :)
[18:05:59] <brson_> bblum: can you fix the merge conflicts on https://github.com/mozilla/rust/pull/7858?
[18:06:05] <bblum> brson_: working on it as we speak
[18:06:13] <brson_> thanks
[18:06:15] *** Joins: MrFahrenheit (RageOfThou@3FEF494C.29C984D5.783DEDCA.IP)
[18:06:22] *** Joins: eschweic (Adium@moz-BBE3ABD.mv.mozilla.com)
[18:07:03] *** Quits: seth (seth@moz-BE33DA21.fw1.sfo1.mozilla.net) (Input/output error)
[18:07:38] <bblum> piggybacking unrelated wide-spanning cleanup commits on big PRs is not entirely without downsides
[18:08:10] <cmr> ...does it have upsides?
[18:08:22] <bblum> don't have to run the test suite for cleanup commits alone
[18:08:48] <bblum> argh strcat :P
[18:08:51] <bblum> your iterators bit me again
[18:08:55] *** Quits: robertknight (robertknig@moz-54528EE0.wby.mendeley.com) (Quit: Computer has gone to sleep.)
[18:09:04] <tikue> bblum: what does that mean
[18:09:10] <bblum> tikue: CHOMP CHOMP
[18:09:16] <tikue> -___-
[18:10:14] * sanxiyn points out "piggybacking" is basically manual implementation of Zuul-like speculative execution
[18:10:16] <sanxiyn> http://ci.openstack.org/zuul/gating.html
[18:10:48] *** Joins: james4k (james@moz-E7990244.consolidated.net)
[18:10:50] <cmr> Ohhh there's an existing system that does it for us!
[18:10:55] <cmr> Now we don't have to write something
[18:11:35] <sanxiyn> cmr: Well we want something that works with GitHub, so it's not perfect fit
[18:11:53] <cmr> sanxiyn: yeah but that's not the hard part
[18:12:03] <cmr> the hard part is figuring out which to test and how to handle failure and such
[18:12:13] <cmr> brendanc: ^
[18:12:34] *** Joins: lkuper (lkuper@moz-6A082AC7.ptld.qwest.net)
[18:12:48] <sanxiyn> cmr: Yes, experience is valuable, on the other hand I don't think actual code is much use
[18:12:57] <sanxiyn> So we'd have to write something anyway
[18:13:04] *** Joins: josh (josh@moz-348C4790.hsd1.mn.comcast.net)
[18:13:06] *** Quits: josh (josh@moz-348C4790.hsd1.mn.comcast.net) (Quit: josh)
[18:13:19] *** Joins: josh (josh@moz-348C4790.hsd1.mn.comcast.net)
[18:13:45] *** sankha93 is now known as optimizer1
[18:13:52] *** optimizer1 is now known as sankha93
[18:14:48] *** Quits: brson_ (brson@moz-BBE3ABD.mv.mozilla.com) (Ping timeout)
[18:15:32] *** Quits: jaen (jaen@moz-36261275.internetdsl.tpnet.pl) (Ping timeout)
[18:15:42] *** Joins: echristo (echristo@DCF57675.D6CCE4AE.77834EAA.IP)
[18:16:05] <acrichto_> I think bors is stuck...
[18:16:12] <acrichto_> or is bors turned off?
[18:16:51] <sully> oh, ha!
[18:16:57] <sanxiyn> #[bench] tells me bench_sum is 43 ns/iter and bench_simd_sum is 10 ns/iter
[18:17:06] <sanxiyn> (Summing 64 single precison floats)
[18:17:07] <sully> I had implemented a new check, and it came across a bug trying to check the iterator impls
[18:17:20] <sully> and so I fixed it, and ran again, and it errored on a new iterator impl thing
[18:17:23] <sanxiyn> First time I've seen it is not a slowdown :)
[18:17:25] <sully> but it was a bug in the iterator this time!
[18:17:45] <sanxiyn> sully: !
[18:18:14] *** Joins: azita (Azita@moz-C1FB2A8.hsd1.ca.comcast.net)
[18:18:45] <sanxiyn> I have a question
[18:19:04] *** Joins: brson (brson@moz-BBE3ABD.mv.mozilla.com)
[18:19:04] *** ChanServ sets mode: +o brson
[18:19:16] *** Joins: MaikKlein1 (maik@moz-236DC30E.dip0.t-ipconnect.de)
[18:19:18] <sanxiyn> Let's say, a, b, c are vectors of equal length
[18:20:00] <sanxiyn> I want to do something like: for (int i = 0; i < n; i++) a[i] += b[i] * c[i]; // written in C
[18:20:26] *** Quits: MaikKlein (maik@moz-4CFF4604.dip0.t-ipconnect.de) (Ping timeout)
[18:20:45] <sanxiyn> Can be written trivially with while, but X[Y] all results in bound checks
[18:20:52] <sanxiyn> (and LLVM can't remove them :( yet)
[18:21:04] <sanxiyn> Idea?
[18:21:25] <cmr> there's stuff in vec::raw for bounds-check-free access
[18:21:36] <olsonjeffery> brson: ping
[18:21:45] <bblum> does anybody have anything big in the bors queue that is likely to bitrot if i have my big PR cut in line?
[18:21:49] <bblum> graydon?
[18:22:00] <graydon> not me
[18:22:05] *** Joins: Jesse (jruderman@moz-537BCF9.hsd1.ca.comcast.net)
[18:22:18] <brson> olsonjeffery: pong
[18:22:25] <cmr> bblum: doesn't look like it
[18:22:39] <olsonjeffery> brson: so i have a rt::io::Timer (at least according to my simple smoke tests!)
[18:22:40] *** Quits: lkuper (lkuper@moz-6A082AC7.ptld.qwest.net) (Quit: lkuper)
[18:22:54] <olsonjeffery> i want to write some user code that uses it, just to make sure, before i do a PR to brson/io
[18:23:05] <olsonjeffery> how do i write newsched code as a application?
[18:23:12] <olsonjeffery> compiler flag?
[18:23:20] <bblum> olsonjeffery: RUST_NEWRT=1 ./executable
[18:23:34] <olsonjeffery> ok, at that point main() is within a newsched task?
[18:23:35] *** Quits: int3_ (int3_@moz-ABE52D50.hsd1.ca.comcast.net) (Client exited)
[18:23:43] <brson> olsonjeffery: can you rebase it off of master? I think we can leave brson/io behind now
[18:23:53] <olsonjeffery> sure.
[18:23:56] *** Joins: int3_ (int3_@moz-ABE52D50.hsd1.ca.comcast.net)
[18:24:16] <brson> olsonjeffery: yeah RUST_NEWRT will run everything under the new runtime
[18:24:24] <olsonjeffery> alright, thanks.
[18:24:32] <olsonjeffery> brson: i might take a whack at async tcp, next
[18:25:01] <bblum> alright, i've been really annoyed for a while now that make check-stage0-std doesn't work at all
[18:25:04] <bblum> is this a known bug?
[18:25:08] <bblum> is there an issue for it?
[18:25:13] <bblum> ("can't find crate for extra")
[18:25:36] <cmr> there's no way for that to be possible.
[18:25:40] <cmr> running tests requires extra::test
[18:25:46] *** Quits: int3_ (int3_@moz-ABE52D50.hsd1.ca.comcast.net) (Ping timeout)
[18:25:50] <olsonjeffery> brson: is there any emerging concensus about what the async api will look like?
[18:25:54] <sanxiyn> GCC does value range analysis, but LLVM (in mainline) doesn't yet :(
[18:25:59] *** Joins: pcwalton (pcwalton@moz-7B0110AD.mv.mozilla.com)
[18:25:59] *** ChanServ sets mode: +o pcwalton
[18:26:00] <bblum> cmr: but i have a stage0 extra in the snapshot presumably
[18:26:04] <bblum> it was possible last summer.
[18:26:07] <olsonjeffery> futures vs callbacks, etc..
[18:26:38] <sully> hm
[18:26:46] <sully> I may be about to dive into my first great yakshave of the summer.
[18:26:55] *** Quits: MaikKlein1 (maik@moz-236DC30E.dip0.t-ipconnect.de) (Ping timeout)
[18:27:20] <olsonjeffery> and i take it that the async impl in uvio will use the same underlying libuv bindings, just it won't do the same scheduler-based deschedule/resume magic that the synchronous versions use.. ?
[18:27:38] <sanxiyn> sully: The first? It has been summer for some time... :)
[18:27:38] <cmr> bblum: does using the test runner from the snapshot make sense to test code compiled with the snapshot? I'm not sure.
[18:28:06] <bblum> i think it does
[18:28:35] <sully> yeah, I mean, my previous rust internships have been like
[18:28:39] <sully> 60% yakshave
[18:28:49] <sully> but this summer has been 20% yakshave, tops
[18:28:55] *** Joins: carllerche (carllerche@6B070D22.7E6A0813.1428D117.IP)
[18:29:12] <bblum> brson: so the core of select() will be two traits and two functions which don't rely on comm internals; do you think it should be in its own file and have comm.rs import the two traits? or should it stay in comm.rs?
[18:29:27] <bblum> sully: what are you gonna do
[18:29:35] <jensnockert> Anyone have any tips on something fun to eat?
[18:29:53] <sanxiyn> jensnockert: Icecream?
[18:30:04] <olsonjeffery> jensnockert: some arbitrary combination of carbs, fat and protein?
[18:30:07] <jensnockert> More like dinner, lessâ€¦ dessert.
[18:31:16] *** Joins: Voomer_ (Voomer@moz-B00025E4.dyn.centurytel.net)
[18:31:32] <sully> well, I think the problem I am currently running into is related to https://github.com/mozilla/rust/issues/6967
[18:31:35] <Wensley> jensnockert: how about some mai-fun for dinner and Fun Dip for dessert
[18:31:47] <brson> olsonjeffery: no, there isn't. the current discussion is https://github.com/mozilla/rust/issues/6842. various people have suggested something futures-based, like .NET async i/o
[18:31:54] *** Quits: Voomer (Voomer@moz-9E18DF24.dyn.centurytel.net) (Ping timeout)
[18:32:02] <brson> bblum: it's own file
[18:32:03] <jensnockert> Well, it does have fun in the name.
[18:32:11] <jensnockert> Wensley: So I guess that passes that test.
[18:32:18] *** Wensley is now known as bstrie
[18:33:21] *** Quits: rusti (rusti@moz-54F7FD49.cpe.net.cable.rogers.com) (Ping timeout)
[18:35:44] <brson> I need to put together some kind of handout for OSCON quickly. the 'rust for cxx programmers' is already fairly complete, so I'm thinking of using that
[18:36:31] <toddaaro> brson: when are you leaving for OSCON?
[18:36:48] *** Joins: Voomer__ (Voomer@moz-EBE42B52.dyn.centurytel.net)
[18:36:49] <brson> toddaaro: tuesday afternoon
[18:37:20] <olsonjeffery> brson: when will you be in portland?
[18:37:25] <toddaaro> brson: exciting
[18:37:27] <olsonjeffery> heh
[18:37:28] <olsonjeffery> nm
[18:37:31] <olsonjeffery> im in portland on monday :/
[18:37:32] <indutny> sully: pong?
[18:37:32] *** Quits: Voomer_ (Voomer@moz-B00025E4.dyn.centurytel.net) (Ping timeout)
[18:37:50] *** Quits: jedestep (jedestep@34641662.FB4DE631.66C78B76.IP) (Ping timeout)
[18:38:01] <sully> hm, I was going to ask you about a bug that you had said you were working on
[18:38:04] <sully> but I seem to have lost it
[18:38:07] <brson> olsonjeffery: tuesday through saturday
[18:38:15] <brson> oh, ha
[18:38:51] *** Quits: erickt (erickt@8C9ECD8F.3A598286.F12515B4.IP) (Quit: Leaving.)
[18:39:03] <sanxiyn> Will arrive at Portland on Sunday 6pm
[18:39:51] <olsonjeffery> big spenders, over here. i looked at the cost of OSCON tickets last year (i think i just wanted to do the emerging langs conference)
[18:40:03] <olsonjeffery> took the wind out of my sails.
[18:40:09] *** Joins: jedestep (jedestep@34641662.FB4DE631.66C78B76.IP)
[18:40:24] <olsonjeffery> maybe next year, heh.
[18:40:24] *** Quits: Voomer__ (Voomer@moz-EBE42B52.dyn.centurytel.net) (Ping timeout)
[18:40:39] *** Quits: ssbr (ssbr@moz-141F89C6.block0.gvtc.com) (Ping timeout)
[18:40:45] <cmr> brson: what is the purpose of the handout?
[18:41:13] <brson> cmr: i don't know :-/
[18:41:28] <brson> cmr: to have things to give people
[18:41:29] <cmr> brson: well how are you supposed to put together coherent communication without a purpose!?
[18:41:52] <cmr> then I'd use the bullet points of the problems rust entirely eliminates (niko's recent slides are good), as well as the the nice features like ADT and pattern matching and deriving and macros
[18:42:09] *** Joins: Voomer (Voomer@moz-172FB24B.dyn.centurytel.net)
[18:42:11] *** Quits: sanxiyn (tinuviel@858F408C.B797260D.EF43EC08.IP) (Quit: Leaving)
[18:43:03] <brson> cmr: ok, thanks. i'll use niko's slides
[18:43:40] *** Joins: Voomer_ (Voomer@moz-E83B9700.dyn.centurytel.net)
[18:43:58] *** Quits: Voomer (Voomer@moz-172FB24B.dyn.centurytel.net) (Ping timeout)
[18:44:07] <bstrie> brson: the slides are really excellent, though that's quite a few pages
[18:44:22] <bblum> hmm for a handout sort of format i would also have some sort of cheat-sheet of features
[18:44:33] *** Quits: infynyxx (infynyxx@DB780A29.749BA1D.DCC373F0.IP) (Client exited)
[18:44:35] <bblum> like a short snippet of code for a bunch of different cool things we can do
[18:44:48] <bblum> pattern matching, tasks and channels, traits-as-typeclasses, etc
[18:44:49] *** Quits: FrozenCow_ (FrozenCow@moz-B2DF4929.chello.nl) (Ping timeout)
[18:45:25] <bblum> with slides, you shouldn't put any text that the reader's eyes will just glaze over; with a handout, it's more fine to do that
[18:45:35] *** Quits: Voomer_ (Voomer@moz-E83B9700.dyn.centurytel.net) (Ping timeout)
[18:45:40] *** Joins: Voomer (Voomer@moz-ACE08848.dyn.centurytel.net)
[18:46:04] <pcwalton> do extern "Rust" fns work?
[18:46:49] *** Joins: Voomer_ (Voomer@moz-E8F9104F.dyn.centurytel.net)
[18:47:14] <bblum> pauls: ping
[18:47:23] <pauls> bblum: pong
[18:47:31] *** Quits: Voomer (Voomer@moz-ACE08848.dyn.centurytel.net) (Ping timeout)
[18:48:04] <bblum> pauls: http://pastebin.mozilla.org/2656324 if i wanted to also have select3, select4, etc, how could i write a macro to autogenerate these functions?
[18:49:26] <toddaaro> pauls: silly question: are you the same pauls that made wilbowma have weird names in #soic for awhile?
[18:49:28] <brson> ok, so I'll show ADT's, pattern matching and let patterns, various pointer things, maybe macros, deriving. anything else important, tricky or unique to rust?
[18:49:35] <pauls> toddaaro: yep
[18:49:46] *** Joins: vladimir-lu (vladimir-l@moz-428433D9.cable.virginmedia.com)
[18:49:50] <toddaaro> pauls: ha ok
[18:49:59] *** Quits: Voomer_ (Voomer@moz-E8F9104F.dyn.centurytel.net) (Ping timeout)
[18:50:01] *** Joins: Voomer (Voomer@moz-9C71DD43.dyn.centurytel.net)
[18:50:15] *** Joins: rusti (rusti@moz-54F7FD49.cpe.net.cable.rogers.com)
[18:50:26] <pauls> toddaaro: Are you IU-affiliated? I'm from NEU.
[18:50:52] <toddaaro> pauls: yea, IU PL phd student
[18:50:56] <bblum> brson: you didn't say tasks in that list
[18:51:09] *** Joins: Voomer_ (Voomer@moz-D395F993.dyn.centurytel.net)
[18:51:43] <pauls> bblum: it should probably take a sequence of names and types as arguments...
[18:51:49] *** Quits: Voomer (Voomer@moz-9C71DD43.dyn.centurytel.net) (Ping timeout)
[18:52:10] <bblum> brson: if you want to scare some people and impress other people, showing named lifetimes with option::get_ref would be a good way to do that
[18:52:34] <pauls> ...(once hygiene exists, you'd be able to leave the variable names off in theory, since they don't matter, but actually implementing the macro that way would be tricky)
[18:53:18] <brson> tasks, yes for sure
[18:53:22] <pauls> You'd want to generate the outside of the function (the arguments and the `let mut ports=...`) in a single outer macro...
[18:53:41] <pauls> ...and the match cases in a nested fashion with a recursive macro.
[18:53:53] <pauls> I'll be back in a few minutes.
[18:56:25] *** Joins: Voomer (Voomer@moz-3EFE110F.dyn.centurytel.net)
[18:56:57] *** Quits: Voomer_ (Voomer@moz-D395F993.dyn.centurytel.net) (Ping timeout)
[18:57:02] <vladimir-lu> i contend there's nothing magical about get_ref() - if you already know about functional programming and lifetimes :P
[18:57:16] <bblum> vladimir-lu: like 0.001% of people know about lifetimes
[18:57:45] *** Joins: Voomer_ (Voomer@moz-6DDD4BCA.dyn.centurytel.net)
[18:58:18] <vladimir-lu> bblum: yeah, that's because they're too cool for most people ;)
[18:58:28] *** Quits: Voomer (Voomer@moz-3EFE110F.dyn.centurytel.net) (Ping timeout)
[18:58:32] *** Joins: erickt (erickt@8C9ECD8F.3A598286.F12515B4.IP)
[18:58:36] *** Joins: ssbr (ssbr@moz-141F89C6.block0.gvtc.com)
[18:58:37] *** Joins: infynyxx (infynyxx@DB780A29.749BA1D.DCC373F0.IP)
[19:00:47] *** Joins: lucian (lucian@moz-22A14C6A.cable.virginmedia.com)
[19:01:04] *** Quits: cowboyd (cowboyd@moz-A4161B97.dsl.austtx.swbell.net) (Client exited)
[19:02:32] *** Quits: lucian (lucian@moz-22A14C6A.cable.virginmedia.com) (Ping timeout)
[19:02:52] *** Joins: cowboyd (cowboyd@moz-A4161B97.dsl.austtx.swbell.net)
[19:04:10] *** Joins: tjc (tjc@moz-BBE3ABD.mv.mozilla.com)
[19:04:11] *** ChanServ sets mode: +o tjc
[19:04:48] <jdm> when I have a train with a method where I want to return a managed pointer, where do I declare the 'self lifetime?
[19:04:51] <jdm>     pub fn base_node(&self) -> &'self Node<ScriptView>;
[19:04:55] <jdm> this tells me 'self isn't declared
[19:08:24] <saati> what does "ref" in "Some(ref x)" mean?
[19:08:38] *** Quits: BizarreCake (BizarreCak@moz-361FE9B2.dynamic.barak-online.net) (Ping timeout)
[19:08:48] <tjc> saati: it makes x a pointer to the value inside the Option
[19:08:53] <saati> apart from that options get_ref doesn't seem scary, but i might be missing something
[19:08:57] <tjc> without the ref, it would just copy the contents of the Option into x
[19:09:42] *** ozten is now known as ozten|kale
[19:10:00] <Luqman> jdm: trait Foo<'self> { fn base_node(&'self self) -> &'self Node<ScriptView>; }
[19:10:28] *** Joins: jaen (jaen@moz-36261275.internetdsl.tpnet.pl)
[19:11:25] <saati> tjc: so it's a modifier on the pattern match?
[19:12:20] <tjc> saati: Sort of -- it's a modifier on a binder
[19:12:29] <tjc> that is, a name that you're binding -- in a pattern in this case
[19:12:37] <tjc> well, I guess it can only appear in a pattern
[19:12:42] <tjc> so yes, what you said, more or less :-)
[19:12:46] <jdm> Luqman: ok, so the impl is giving me trouble too
[19:12:51] <jdm> /home/jdm/sdb/servo/src/components/script/dom/bindings/element.rs:293:28: 293:32 error: Illegal lifetime 'self: the `self` lifetime must be declared
[19:12:54] <jdm> /home/jdm/sdb/servo/src/components/script/dom/bindings/element.rs:293         fn base_node(&'self self) -> &'self Node<ScriptView> {
[19:14:50] <Luqman> jdm: you'd have to do impl<'self> FooTrait<'self> for Bar { ... }
[19:14:59] <jdm> oho, I was missing a <'self>
[19:15:00] <jdm> thanks
[19:15:19] <tjc>  graydon: r? https://github.com/mozilla/rust/pull/7419 when you get a chance
[19:15:42] *** Quits: tikue (tkuehn@moz-BBE3ABD.mv.mozilla.com) (Quit: tikue)
[19:16:00] *** Quits: eschweic (Adium@moz-BBE3ABD.mv.mozilla.com) (Quit: Leaving.)
[19:17:22] *** Quits: eatkinson (eatkinson@moz-BBE3ABD.mv.mozilla.com) (Quit: eatkinson)
[19:19:35] *** Quits: jdm (jdm@F2D29657.F60B0462.67AC9B1.IP) (Ping timeout)
[19:22:28] *** Joins: strcat (strcat@moz-54F7FD49.cpe.net.cable.rogers.com)
[19:24:06] *** Quits: dan_johnsin (dan_johnsi@6902762D.11B071D.FB9A45AF.IP) (Connection reset by peer)
[19:25:37] <brson> what did the printfln macro end up being called?
[19:25:59] *** Joins: FrozenCow (FrozenCow@moz-B2DF4929.chello.nl)
[19:26:12] *** Joins: jdm (jdm@F2D29657.F60B0462.67AC9B1.IP)
[19:26:19] *** Joins: tikue (tkuehn@moz-BBE3ABD.mv.mozilla.com)
[19:27:03] *** Joins: pnathan_ (pnathan@moz-6DE9281A.pools.spcsdns.net)
[19:27:09] *** Quits: mark_edward (quassel@moz-4A9A2F15.dynamic.utc.edu) (Ping timeout)
[19:27:40] *** Quits: FrozenCow (FrozenCow@moz-B2DF4929.chello.nl) (Ping timeout)
[19:27:40] *** Joins: fabiand (fabiand@moz-F2EF568F.adsl.alicedsl.de)
[19:28:35] *** Quits: C_D (Search@FE07FAB0.2D232D0D.F5B38AFB.IP) (Quit: )
[19:28:49] *** Quits: fabiand (fabiand@moz-F2EF568F.adsl.alicedsl.de) (Quit: Verlassend)
[19:29:18] <vladimir-lu> if i want the equivalent of thread-local-storage in a task, i just create a new struct in the beginning of the task and store things there?
[19:29:34] *** Joins: brendan (brendaneic@10487EE8.58B1B661.22B0E380.IP)
[19:30:23] *** Joins: mark_edward (quassel@moz-4A9A2F15.dynamic.utc.edu)
[19:30:26] <strcat> vladimir-lu: there's support for TLS
[19:30:40] <strcat> but you are better off not using actual TLS if you can structure it in a way where you can avoid it
[19:31:29] <vladimir-lu> well, i want to bind to a c library and it only guarantees thread-safety when you use a different context for each thread
[19:31:45] <jdm> pub fn create<'self, T: NodeBase<'self>>(cx: *JSContext, node: &'self mut T) -> jsobj {
[19:31:48] <jdm> anything look wrong here?
[19:31:50] <jdm> I'm getting an ICE
[19:31:53] <vladimir-lu> so i probably should use real TLS, I think
[19:32:35] *** Joins: strcat1 (strcat@moz-54F7FD49.cpe.net.cable.rogers.com)
[19:32:51] *** Quits: rusti (rusti@moz-54F7FD49.cpe.net.cable.rogers.com) (Ping timeout)
[19:32:56] <strcat1> vladimir-lu: rust doesn't have data races
[19:33:08] <strcat1> you don't have to do anything special to prevent multiple threads using an object at the same time
[19:33:08] *** Quits: strcat (strcat@moz-54F7FD49.cpe.net.cable.rogers.com) (Ping timeout)
[19:33:10] *** strcat1 is now known as strcat
[19:33:24] <strcat> you have to go out of your way to make that not true
[19:34:09] *** Quits: cubic (cubic@moz-FE5AD6C7.mc.videotron.ca) (Ping timeout)
[19:34:14] <vladimir-lu> strcat: right, but if i wanted to use C object (pass it to C functions) and have one per thread
[19:34:20] *** Quits: sankha93 (Instantbir@CEB821D0.4F548E43.F44414AF.IP) (Ping timeout)
[19:34:21] *** Joins: int3_ (int3_@moz-ABE52D50.hsd1.ca.comcast.net)
[19:34:54] <strcat> vladimir-lu: make it non-copyable
[19:35:04] <strcat> only one task can be referring to it at a time
[19:35:10] <strcat> you don't have to do anything special
[19:35:15] <dherman> got me some more n00b questions...
[19:35:17] <vladimir-lu> strcat: hmnn ok i guess i could do that
[19:35:27] * dherman is biting the bullet and publicly embarrassing himself
[19:35:38] <vladimir-lu> strcat: as it's the first time i'm trying to use a c lib from rust
[19:35:40] <bblum> bite that bullet dherman 
[19:35:43] <strcat> the only way to have tasks actually share data is to make shared data types that are Send, like ARC
[19:35:43] <jdm> dherman: that's the spirit
[19:35:44] <bblum> i believe in you
[19:35:56] <kimundi> dherman: shoot
[19:35:56] *** Joins: bjz_ (brendanzab@B398BE78.F804C29E.D35A31DF.IP)
[19:36:01] *** Quits: bjz (brendanzab@B398BE78.F804C29E.D35A31DF.IP) (Connection reset by peer)
[19:36:11] <kimundi> (but spit out the bullet first)
[19:36:13] <vladimir-lu> strcat: there's no way to have them implicitly share data without sending it? i.e. what you get with TLS in java, say?
[19:36:15] <dherman> if I have an &mut that has a ~ field, how can I mutate that field? I can't even move the field out
[19:36:15] *** Quits: int3_ (int3_@moz-ABE52D50.hsd1.ca.comcast.net) (Ping timeout)
[19:36:41] <bblum> dherman: you should be able to mutate it just fine; mutating does not leave a hole where it once was, whereas moving out does
[19:36:54] <bblum> *ptr = ~new_value
[19:37:03] <strcat> vladimir-lu: there's no way to make them share data without it having exclusive locks
[19:37:05] <doy> if you need to move it out, you can swap it with something
[19:37:07] <strcat> you *do not* need to worry about data races
[19:37:12] <tjc> or even **ptr = new_value
[19:37:16] <strcat> just don't create a type that's sendable + not owned by a single owner
[19:37:16] <tjc> unless I'm deeply confused
[19:37:18] <dherman> well the issue is that I want to compute the new_value by calling a method on the field
[19:37:38] <strcat> dherman: an &mut self method will work
[19:37:38] <bblum> the method needs by value self huh
[19:38:00] <dherman> strcat: I *think* I want ~self here
[19:38:03] <dherman> but I keep thinking that
[19:38:05] <vladimir-lu> strcat: so it's not really TLS then? no pthread_key_create functionality?
[19:38:13] <dherman> and last night someone was telling me that's rare
[19:38:29] <strcat> vladimir-lu: there is TLS, but it's in no way necessary to prevent data races
[19:38:30] <dherman> the method wants to replace itself
[19:38:45] <dherman> possibly with a newly allocated ~thing, possibly with itself
[19:38:53] <bblum> dherman: assuming you do need ~self, this is sort of a limitation we have; the best you can do is make it a &mut Option<~thing> and swap in None temporarily
[19:38:54] <strcat> vladimir-lu: tasks already don't share data, you can only send data
[19:39:05] <strcat> there are shared data types like @, @mut, Rc, RcMut - they are non-sendable
[19:39:13] <strcat> ARC/RWARC are sendable + shared but use exclusive locking
[19:39:20] *** ozten|kale is now known as ozten
[19:39:21] *** Quits: brendan (brendaneic@10487EE8.58B1B661.22B0E380.IP) (Quit: brendan)
[19:39:33] <bblum> i love how ubiquitously-mentioned RWARC has become
[19:39:36] <strcat> you would really have to go out of your way by using unsafe code to implement shared, mutable data that's Send to enable data races
[19:39:50] <bstrie> bblum: we all still hate the name :P
[19:39:52] <vladimir-lu> right, but the data race is not mine
[19:39:57] <vladimir-lu> it's in the C library
[19:40:02] <bblum> bstrie: all but one
[19:40:04] <strcat> vladimir-lu: it doesn't matter
[19:40:08] <vladimir-lu> i get what you're saying
[19:40:32] <vladimir-lu> but maybe i'm not asking a precise enough question
[19:40:32] <strcat> if the object is a) owned or b) non-sendable, there are never thread-safety concerns
[19:40:39] <vladimir-lu> right
[19:40:47] <strcat> the *only* time you could possibly have a data race is if you create one that has multiple owners + is sendable
[19:40:54] <strcat> or make a static mut
[19:40:54] <dherman> bblum: assuming I go with the Option solution, how do I do a swap? (move current value to a local, replace it with None)
[19:41:07] <doy> dherman: std::util::swap
[19:41:18] <dherman> ah
[19:41:18] <kimundi> vladimir-lu: Got a link to the C lib in question?
[19:41:21] <bblum> dherman: util::swap is the innermost function for doing that, but option has a bunch of convenience wrappers
[19:41:28] <vladimir-lu> kimundi: libcurl
[19:41:28] <strcat> if a C library hands you a context and says only one thread must access it at a time, the only thing you have to do to make it safe is make sure it's not shared + sendable
[19:41:36] <vladimir-lu> yes
[19:41:39] *** Joins: lkuper (lkuper@moz-548A28E6.ptld.qwest.net)
[19:41:41] <bblum> dherman: you probably want option::take_unwrap() (which fails if the option is already none)
[19:41:42] *** Quits: lkuper (lkuper@moz-548A28E6.ptld.qwest.net) (Quit: lkuper)
[19:41:53] <strcat> so if it *is* copyable and still refers to the same context after a copy, add #[no_send]
[19:41:59] <strcat> if it has a destructor, it's already non-copyable
[19:42:18] <strcat> and if it's a resource (it likely is), it should have one
[19:42:43] <vladimir-lu> ok, so say you have 5 tasks that all want to use this library, and 2 of them end up being on separate threads. they're all trying to make calls to it at the same time. and you want to create no more contexts (c library terminology) than there are physical threads
[19:42:56] <kimundi> bblum, dherman: Couldn't something like 'data.field = foo(data.field)' work?
[19:43:07] <vladimir-lu> i could create a context per task and be done with it (and that's probably a better option because it's simpler and doesn't optimise prematurely)
[19:43:16] <bblum> kimundi: we're not leet enough for that
[19:43:19] <vladimir-lu> i'm just curious how easy the above is to do in rust
[19:43:44] <bblum> dherman: option::take_unwrap(opt) == util::replace(opt, None).unwrap()
[19:44:16] <strcat> vladimir-lu: afaik what libcurl bindings should be doing in rust is handing fds to libuv
[19:44:28] *** Joins: dan_johnsin (dan_johnsi@6902762D.11B071D.FB9A45AF.IP)
[19:44:29] <strcat> curl multi supports using libev/libevent/libuv
[19:44:34] <dherman> kimundi: I'm not allowed to pass data.field by move when data is a & pointer
[19:45:08] <strcat> dherman: are you sure you need it by-value?
[19:45:19] * jdm is 100% done with lifetime ICEs
[19:45:29] <vladimir-lu> strcat: hmnn i'll have to take a look at libuv
[19:45:31] <dherman> strcat: need what?
[19:45:33] <jdm> by which I mean I have made no progress, not that I've solved my problems :)
[19:45:34] <strcat> in 95% of cases you want &mut self instead of foo(T) -> T
[19:45:40] <strcat> dherman: the field by-value
[19:45:40] <dherman> oh
[19:45:59] <vladimir-lu> strcat: but my question still stands (for any library really)
[19:46:00] <dherman> strcat: lemme rethink again...
[19:46:01] <strcat> &mut T is a lighter requirement than T
[19:46:03] *** Joins: eschweic (Adium@moz-BBE3ABD.mv.mozilla.com)
[19:46:10] <vladimir-lu> another example i can think of is connection pooling
[19:46:17] <bblum> brson: BTW, the problem with the yield() test cases is that, since yield() always immediately resumes the task that was yielding, the test case will hang if the tasks are scheduled on the same scheduler (which confused me until i realized it was determinstic if you set RUST_THREADS=1)
[19:46:18] <vladimir-lu> although i guess you can do it with locking
[19:46:28] <strcat> because if the caller has a T by-value, they can always have &mut T
[19:46:35] <dherman> strcat: I started out that way but somehow convinced myself that doesn't work. trying again...
[19:46:42] <strcat> you'd only need it by-value if you wanted to move out of it
[19:46:54] <bblum> brson: I tried to think of a way to keep a yield-loop in the test case, but i think it is impossible to do correctly until yield() works the way toddaaro was talking about at the meeting a few weeks ago (push to back of RQ)
[19:47:08] <brson> bblum: i see. ok
[19:47:21] <dherman> oh I remember the problem I ran into
[19:47:23] <strcat> pcwalton: https://github.com/mozilla/rust/pull/7906 r?
[19:47:59] <vladimir-lu> anyway i'll see how i get on and if anyone's interested in looking at the rust code will post a link here
[19:47:59] <dherman> strcat: the method is returning a ~Node for the caller to use to do the update. but sometimes it wants to just return self unchanged
[19:48:08] <dherman> strcat: but &mut self is incompatible with ~Node
[19:48:13] <toddaaro> brson bblum : I have been thinking about alternatives, one thing we could try, which is terrible, is just "doing some random stuff and nonsense and such" at yield calls, like dequeueing a bunch of tasks and requeuing them in a different order
[19:48:36] <toddaaro> brson bblum : this is genuienly terrible and we shouldn't rely on this, it just makes 1 thread act like more threads
[19:48:39] <dherman> strcat: some branches allocate a new ~Node, others just mutate self and want to return self
[19:48:54] <dherman> strcat: I guess I could just return Option and have the caller do nothing when it gets None
[19:48:57] *** Joins: rusti (rusti@moz-54F7FD49.cpe.net.cable.rogers.com)
[19:48:58] <bblum> brson: although, i could write a test which would test yield() only when the tasks are scheduled on different cores, but would still do a correct thing if they are on the same core
[19:49:01] *** Joins: eschweic1 (Adium@moz-BBE3ABD.mv.mozilla.com)
[19:49:17] <bblum> in fact, i will do that for sure
[19:49:19] *** Joins: enix (enix@moz-A50569DD.c3-0.slvr-ubr1.lnh-slvr.md.cable.rcn.com)
[19:49:19] <brendanc> cmr: that zuul algorithm seems good. I'd considered something like that too, but the scheme I came up with is a bit more conservative (expects more failures)
[19:49:33] *** Quits: erickt (erickt@8C9ECD8F.3A598286.F12515B4.IP) (Quit: Leaving.)
[19:49:39] <dherman> strcat: maybe that's best, since mutating the container's field to its existing value is pointless anyway
[19:49:41] *** Quits: eschweic (Adium@moz-BBE3ABD.mv.mozilla.com) (Ping timeout)
[19:49:42] *** Quits: maxli (maxli@F2D29657.F60B0462.67AC9B1.IP) (Quit: Leaving.)
[19:49:46] *** Quits: jensnockert (jensnocker@moz-C5F27039.cust.bredband2.com) (Ping timeout)
[19:50:10] <bblum> oh wait, toddaaro reminds me that can only work with per-cpu workqueus >_<
[19:50:49] <bblum> won't work after all
[19:50:58] *** Quits: pnathan_ (pnathan@moz-6DE9281A.pools.spcsdns.net) (Quit: Colloquy for iPhone - http://colloquy.mobi)
[19:51:31] * jdm resorts to cast::transmute to avoid lifetime errors
[19:51:36] <brendanc> cmr: since it has appeared to me that a fairly high percentage of prs get bounced
[19:51:41] *** Quits: eschweic1 (Adium@moz-BBE3ABD.mv.mozilla.com) (Ping timeout)
[19:51:44] <strcat> dherman: you could use &mut self on an impl for ~Node
[19:51:44] <bblum> jdm: no no :( at the very least use transmute_region
[19:51:44] *** Joins: eatkinson (eatkinson@moz-BBE3ABD.mv.mozilla.com)
[19:51:50] <strcat> dherman: and it'd have &mut ~Node
[19:51:52] <jdm> yeah, that's the one I meant
[19:51:58] *** Joins: eschweic (Adium@moz-BBE3ABD.mv.mozilla.com)
[19:53:02] <jdm> huh, even transmute_region fails o.o
[19:53:07] <jdm> huh, even transmute_region fails o.o
[19:53:56] <dherman> strcat: oh, so impl for ~Node instead of Node
[19:54:22] <dherman> strcat: that sounds promising!
[19:54:31] * dherman is having so much fun
[19:54:56] <bstrie> dherman: having fun doing what?
[19:55:04] <dherman> writing teh codez
[19:55:07] <bstrie> in rust?!?
[19:55:09] <dherman> ja
[19:55:11] <bstrie> who could have fun doing that
[19:55:14] <bstrie> you must be a madman
[19:55:18] <dherman> better than writing emails!
[19:55:23] <dherman> which is usually what they pay me for
[19:55:29] <bstrie> try writing emails in rust
[19:55:50] *** Quits: SiegeLord (sl@moz-56D7E78.bstnma.fios.verizon.net) (Ping timeout)
[19:55:52] <bstrie> you'll need to write all the necessary libs yourself, of course
[19:56:14] <dherman> haha
[19:56:40] <bstrie> dherman: are you stealing any content from nmatsakis' presentation for your oscon talk?
[19:56:43] <vladimir-lu> i wouldn't mind an email library for rust (in fact, that's why i'm using libcurl)
[19:56:52] <dherman> bstrie: possibly some examples
[19:57:02] <dherman> bstrie: it was an academic talk, though, mostly not directly applicable for OSCON
[19:57:12] <dherman> I won't be deep-diving into semantics / type system issues
[19:57:21] <bstrie> ok. I'm not sure what the audience at oscon is supposed to be
[19:57:28] <dherman> I think mostly hackers
[19:57:36] <ronny> hmm
[19:57:41] <bstrie> presumably they are people who really enjoy woodcuts of animals and are confused by all this programming nonsense
[19:57:53] * ronny could use a mime parser and a imap parser right now
[19:57:57] <dherman> I don't know oscon, but I feel like it's a bit of an old school open source crowd
[19:58:42] <dherman> strcat: I have new compiler errors and they are scary and I feel cold and alone
[19:58:42] *** Quits: cowboyd (cowboyd@moz-A4161B97.dsl.austtx.swbell.net) (Client exited)
[19:58:47] <strcat> heh
[19:58:50] <dherman> error: no base type found for inherent implementation; implement a trait or new type instead
[19:58:56] <ronny> whats the current way to open processes in rust?
[19:59:22] <strcat> ronny: as in fork(), or spawning a specific binary as a subprocess?
[19:59:29] <bstrie> dherman: do you know about coherence?
[19:59:46] * bstrie presumes that error is related to coherence
[19:59:54] *** Quits: brson (brson@moz-BBE3ABD.mv.mozilla.com) (Ping timeout)
[19:59:57] <dherman> yeah but I don't understand why it's applying here
[20:00:08] <dherman> impl<K: Eq + Ord, V> ~Node<K,V> {
[20:00:08] *** Joins: brendan (brendaneic@10487EE8.58B1B661.22B0E380.IP)
[20:00:18] <dherman> per strcat's suggestion
[20:00:23] <bstrie> is Node a typedef or is it actually a new type?
[20:00:29] <dherman> new type
[20:00:32] <strcat> rusti: print(std::str::from_bytes(std::run::process_output("uname", [~"-a"]).output))
[20:00:33] -rusti- Linux playpen 3.10.1-1-ARCH #1 SMP PREEMPT Sun Jul 14 11:00:04 CEST 2013 x86_64 GNU/Linux
[20:00:35] -rusti- ()
[20:00:35] <bstrie> ok then I don't know :P
[20:01:35] <kmc> is anyone working on Rust - Haskell integration? a lot of Haskell projects have some C component and it would be cool to write that in Rust instead
[20:02:21] <tjc> dherman: I think you have to implement it on Node<K, V> and use ~self
[20:02:25] <tjc> or &self
[20:02:42] <dherman> tjc: IOW strcat's suggestion is a no-go?
[20:03:03] <strcat> I guess that doesn't work anymore
[20:03:17] <dherman> I'll go back to trying the option approach
[20:03:19] <toddaaro> kmc: I don't think anyone is working on it, but that would certainly be cool
[20:03:21] <kmc> projects would include a) teaching Cabal how to compile and link Rust as it does for C, b) tools to help marshal algebraic data types between the languages
[20:03:37] <tjc> dherman: hmm, strcat's suggestion is lost on the backscroll, but yeah, I think that changed fairly recently
[20:03:44] *** Joins: pnathan_ (pnathan@moz-6DE9281A.pools.spcsdns.net)
[20:03:45] <toddaaro> kmc: you considering this as a possible project for yourself?
[20:03:52] <ronny> strcat: spawning a specific binary
[20:03:53] <kmc> maybe
[20:03:55] <dherman> tjc: gotcha, thx
[20:03:56] <bstrie> kmc: well if haskell has a c interface I'd think you could do the same thing that brson did where he called rust from ruby
[20:04:01] <strcat> ronny: ah so then just this:
[20:04:05] <strcat> rusti: print(std::str::from_bytes(std::run::process_output("uname", [~"-a"]).output))
[20:04:06] -rusti- Linux playpen 3.10.1-1-ARCH #1 SMP PREEMPT Sun Jul 14 11:00:04 CEST 2013 x86_64 GNU/Linux
[20:04:06] -rusti- ()
[20:04:10] <dherman> anyway, this is such a great learning experience
[20:04:11] <strcat> depends on what you specifically want to do though
[20:04:16] <strcat> std::run is still a bit crufty
[20:04:21] <kmc> yeah exporting a Rust function with the C ABI and then calling it from Haskell should be easy
[20:04:28] <kmc> both languages have reasonable C FFIs
[20:04:38] <kmc> but tighter integration would be cool
[20:04:38] <ronny> strcat: i need its io streams, and sent/receive data
[20:04:45] <bstrie> kmc: making sure you've read http://brson.github.io/2013/03/10/embedding-rust-in-ruby/
[20:04:47] <kmc> since they both have richer-than-C type systems and build systems
[20:04:47] <toddaaro> kmc: I think it would be super awesome, if there was zero-overhead interaction you could make rust the standard for writing "low-level" code for haskell, instead of using raw # primatives and such implementing data structures
[20:04:47] <kmc> cool
[20:04:48] <ronny> strcat: (im opening an imap connection over ssh)
[20:04:54] <kmc> toddaaro: yeah
[20:04:58] <pcwalton> what did option.iter() become?
[20:05:13] <enix> Are assert!s removed when optimization is turned on?
[20:05:17] <vladimir-lu> ronny: what lib are you using?
[20:05:32] <ronny> vladimir-lu: you mean for imap?
[20:05:39] <vladimir-lu> ronny: yah
[20:05:44] <pcwalton> enix: no
[20:05:44] <pcwalton> 	
[20:05:51] <bstrie> enix: I don't think so, but debug!() gets removed with a compiler flag, so conceivably you could do your asserts in those :P
[20:05:51] <strcat> pcwalton: hm, doesn't that still exist?
[20:05:52] <vladimir-lu> pcwalton: is there an equivalent for flat_map on option?
[20:05:54] <ronny> vladimir-lu: planning to write one (at least fit for doing uid search and uid move)
[20:05:58] <pcwalton> oh, it does?
[20:05:59] <pcwalton> ok
[20:06:08] <strcat> pcwalton: it returns an external iterator though
[20:06:08] <vladimir-lu> ronny: ok, planning to use libcurl
[20:06:19] <pcwalton> oh, well, I can't use it anyway due to the lack of once fn
[20:06:39] <enix> ok, cool. I'm writing some unsafe code and I want to make sure that my assert!s won't go away since they check that the unsafe code won't mess stuff up
[20:07:12] <kmc> I think there's potential for integrating the memory management as well... for example it should be possible to allocate owned boxes in Rust and then move them to Haskell code (as ForeignPtrs)
[20:07:40] <toddaaro> kmc: based on my minimal understanding of haskell's FFI I think that would work nicely
[20:07:48] <kmc> you would just need a ForeignPtr finalizer that calls back into the Rust dtor / free code
[20:07:51] *** Quits: qmx (qmx@moz-D6C3C2E6.qmx.me) (Ping timeout)
[20:07:52] <toddaaro> yea
[20:08:19] <ronny> strcat: so does rust have anything like subprocess.Popen in python?
[20:08:32] <strcat> ronny: I assume there's something for that in std::run
[20:09:00] <ronny> hmm, where are the docs for that
[20:09:13] <strcat> in the libstd documentation
[20:09:25] <bstrie> ronny: http://static.rust-lang.org/doc/std/run.html
[20:09:35] <kmc> but I'm currently trying to track down a segfault caused by the SpiderMonkey GC calling back into the Rust dtor/free code, so maybe I should fix that before I proclaim it a viable strategy :)
[20:09:36] <ronny> thx
[20:11:18] *** Joins: qmx (qmx@moz-D6C3C2E6.qmx.me)
[20:11:47] <ronny> hmm, ok, i created the repo
[20:14:25] <ronny> hmm, anyone aware of a io class that takes one instream, one out stream and turns them into a iostream?
[20:15:13] <olsonjeffery> are nmatsakis's slides on the web, anywhere?
[20:16:38] *** Joins: Lilly (PinkLace@moz-145A6857.bredband.comhem.se)
[20:16:43] <vladimir-lu> olsonjeffery: you mean these? http://smallcultfollowing.com/babysteps/pubs/2013.07.17-NEU.pdf
[20:17:40] *** Quits: qmx (qmx@moz-D6C3C2E6.qmx.me) (Ping timeout)
[20:17:49] *** Quits: jaen (jaen@moz-36261275.internetdsl.tpnet.pl) (Ping timeout)
[20:18:46] <jdm> /home/jdm/sdb/servo/src/components/script/dom/blob.rs:23:8: 23:30 error: not enough type parameters provided for this item
[20:18:49] <jdm> /home/jdm/sdb/servo/src/components/script/dom/blob.rs:23         JSManaged::new::<Blob>(&blob)
[20:18:52] <jdm> impl<T> JSManaged<T> { fn new<T: CacheableWrapper>(wrapped: &mut T) -> JSManaged<T> {
[20:18:59] <jdm> riddle me this!
[20:19:03] <nmatsakis> jdm: static methods are weird.
[20:19:04] <jdm> how can I be missing a type parameter?
[20:19:08] <engla> jdm: you have two type parameters
[20:19:21] <jdm> I do?
[20:19:22] <nmatsakis> jdm: you shouldn't supply their type parameters explicitly, or at least if oyu do so it won't be backwards compat for ever
[20:19:23] <pcwalton> urgh, we need to fix that
[20:19:25] <engla> jdm: you must lose the <T> on the new method, or on the impl
[20:19:31] * pcwalton needs to put that on his board
[20:19:36] <nmatsakis> jdm: what you ought to do is to write: "let x: JSManaged<T> = JSManaged::new(&blob)
[20:19:39] <nmatsakis> er,
[20:19:50] <nmatsakis> actually you shouldn't need any hints
[20:19:54] <jdm> nmatsakis: I agree :)
[20:20:05] <jdm> I threw some in because it said it was unconstrained
[20:20:08] *** Quits: metasyntax (tvenable@moz-63D9B3D.med-web.com) (Quit: Leaving)
[20:20:10] <engla> there is one type param for the impl, and one for ::new
[20:20:10] <jdm> unlike every other single call to it
[20:20:19] <nmatsakis> jdm: oh, that' sbecuase you declared T twice
[20:20:47] <jdm> nmatsakis: so I can't have constrains for impls, right?
[20:20:50] *** Quits: Uther (Instantbir@moz-1B244B05.hfc.dyn.abo.bbox.fr) (Ping timeout)
[20:20:52] <nmatsakis> jdm: yes, you can
[20:20:54] <jdm> oh
[20:21:00] <bblum> eholk: i wanted to let you know i miss figuring out how to design around possible races in the pipes implementation; here i am doing it all on my own
[20:21:07] <engla> you can have multiple impl blocks with different constraints jdm
[20:21:11] <engla> even that
[20:21:26] <jdm> woo, that didn't error this time
[20:21:26] <jdm> thanks
[20:21:49] *** Joins: qmx (qmx@moz-D6C3C2E6.qmx.me)
[20:23:02] *** Quits: brendan (brendaneic@10487EE8.58B1B661.22B0E380.IP) (Quit: brendan)
[20:23:14] *** Joins: jaen (jaen@moz-36261275.internetdsl.tpnet.pl)
[20:23:24] *** Quits: tiffany (kawaii@moz-EB8B0C08.dhcp.embarqhsd.net) (Ping timeout)
[20:23:39] *** Joins: erickt (erickt@8C9ECD8F.3A598286.F12515B4.IP)
[20:23:52] *** Joins: tiffany (kawaii@moz-EB8B0C08.dhcp.embarqhsd.net)
[20:25:28] *** Quits: erickt (erickt@8C9ECD8F.3A598286.F12515B4.IP) (Ping timeout)
[20:25:32] <ronny> again: is there a way to combine a reader and a writer to a ReadWrite?
[20:27:34] *** Joins: brendan (brendaneic@10487EE8.58B1B661.22B0E380.IP)
[20:30:02] <engla> I don't think that is implemented ronny but it should be simple
[20:31:14] *** Quits: tikue (tkuehn@moz-BBE3ABD.mv.mozilla.com) (Quit: tikue)
[20:32:07] *** Joins: true_droid (Adium@moz-123FD9B8.beck.volia.net)
[20:32:25] <ronny> hmk
[20:32:46] *** Quits: rusti (rusti@moz-54F7FD49.cpe.net.cable.rogers.com) (Ping timeout)
[20:33:09] *** Quits: brendan (brendaneic@10487EE8.58B1B661.22B0E380.IP) (Ping timeout)
[20:33:15] *** Quits: strcat (strcat@moz-54F7FD49.cpe.net.cable.rogers.com) (Ping timeout)
[20:33:33] *** Joins: tikue (tkuehn@moz-BBE3ABD.mv.mozilla.com)
[20:34:03] *** Quits: tcr (tcr@moz-EE576D3C.hsd1.ma.comcast.net) (Client exited)
[20:35:03] *** Quits: qmx (qmx@moz-D6C3C2E6.qmx.me) (Ping timeout)
[20:36:12] *** Quits: hjr3 (hradtke@1A0AE795.28A5F6C3.A2D40ED2.IP) (Quit: My MacBook has gone to sleep. ZZZzzzâ€¦)
[20:36:31] *** Joins: MaikKlein1 (maik@moz-236DC30E.dip0.t-ipconnect.de)
[20:37:01] *** Quits: jedestep (jedestep@34641662.FB4DE631.66C78B76.IP) (Ping timeout)
[20:37:11] *** Joins: jedestep (jedestep@34641662.FB4DE631.66C78B76.IP)
[20:39:08] <sully> strmpnk: what is the right way to iterate backwards over a vector?
[20:39:09] <sully> er
[20:39:13] <sully> strcat is gone.
[20:39:17] *** Quits: SimonSapin (simon@88F51059.F3BBB17D.144F44FA.IP) (Ping timeout)
[20:39:20] *** Joins: strcat (strcat@moz-54F7FD49.cpe.net.cable.rogers.com)
[20:39:22] *** Joins: qmx (qmx@moz-D6C3C2E6.qmx.me)
[20:39:27] <sully> there he is.
[20:39:31] <sully> strcat: what is the right way to iterate backwards over a vector?
[20:39:39] <strcat> .rev_iter()
[20:39:43] <strcat> or
[20:39:51] <strcat> .iter().invert() (rev_iter just does that for you)
[20:40:26] <sully> for Reasons I am making vtable resolution resolve parameters /backwards/
[20:41:09] <sully> I /think/ that this will fix a problem and I also have some reason to thing this might be a principled thing to do
[20:41:44] *** Joins: rusti (rusti@moz-54F7FD49.cpe.net.cable.rogers.com)
[20:42:11] <engla> strcat: ok the Mutable for ~str, you think it's better to not have the len() check?
[20:42:13] <sully> I *think* that I might be able to fix the bug that requires dummy type params
[20:42:16] <sully> in the iter stuff
[20:42:28] <strcat> engla: well I don't really understand why it would need it
[20:42:52] <strcat> sully: ;)
[20:42:55] *** Quits: pnathan_ (pnathan@moz-6DE9281A.pools.spcsdns.net) (Quit: Colloquy for iPhone - http://colloquy.mobi)
[20:43:03] <engla> it was just to show that .clear() makes the assumption that there is a nonzero allocation for the str
[20:43:04] <sully> strangely enough, this is a yak shave in order to fix some cross create default/inherited method bugs
[20:43:22] <sully> oh, not just cross crate
[20:43:27] <strcat> engla: but it always sets the len to 0
[20:43:46] <engla> len 0 still requires a base allocation of 1 for the null byte
[20:44:06] <engla> and I wanted to be safe, other uses of set_len call reserve to enlarge the vec so those are safe
[20:44:20] *** Joins: jgilbert (jgilbert@moz-BBE3ABD.mv.mozilla.com)
[20:44:42] <engla> I could remove the len() check but it would have an unstated assumption in the code that there is always a nonzero allocation
[20:44:42] <strcat> I don't really see why it wouldn't be safe to set it to 0 when it's already 0
[20:45:00] <engla> well, set_len is an unsafe fn so
[20:45:25] <engla> I'm sure you can reason about the internal representation of str and say it's safe
[20:45:39] <strcat> you're reading the length
[20:45:45] <strcat> and then setting the length based on that
[20:45:57] <strcat> if reading the length was safe, setting the length isn't going to write to uninit memory
[20:46:09] <strcat> if the length is already 0, setting it to 0 is a no-op
[20:46:26] <engla> it will still write the null terminator
[20:46:35] <engla> I guess it's already in place
[20:47:13] <strcat> afaik we are removing \0 from them anyway
[20:47:22] *** Quits: alex-abreu (alex@moz-7421D6C9.mc.videotron.ca) (Ping timeout)
[20:47:57] *** Quits: jgilbert (jgilbert@moz-BBE3ABD.mv.mozilla.com) (Quit: Leaving)
[20:48:04] <engla> fn capacity has the assertion I wanted
[20:48:07] <engla> I could just copy that
[20:49:05] <jdm> /home/jdm/sdb/servo/src/components/script/dom/bindings/element.rs:390:20: 390:27 error: Unexpected end of macro invocation
[20:49:08] <jdm> /home/jdm/sdb/servo/src/components/script/dom/bindings/element.rs:390 generate_node_base!(Comment)
[20:49:11] <jdm> huh?
[20:49:14] <jdm> macro_rules! generate_cacheable_wrapper(($type_:path) => (
[20:49:27] <sully> oh, good, I changed a type error into an ICE
[20:49:32] <strcat> rusti: let x = ~""; x.capacity()
[20:49:34] -rusti- 0
[20:49:41] <strcat> rusti: let x = ~""; x.len()
[20:49:43] -rusti- 0
[20:50:03] <strcat> engla: I just don't understand why it needs a check at all
[20:50:45] <engla> all other uses of set_len are guarded by either calls to .reserve or assertions
[20:50:49] <sully> a... trans ICE
[20:50:54] <pauls> jdm: is `Comment` the actual, exact, argument to the macro?
[20:50:54] <sully> now that is intriguing.
[20:51:00] <jdm> pauls: yes
[20:51:15] <sully> that is... bizarre
[20:51:16] *** Joins: erickt (erickt@8C9ECD8F.3A598286.F12515B4.IP)
[20:51:36] *** Joins: askalski (akuda@moz-9E90956C.neoplus.adsl.tpnet.pl)
[20:51:38] <pauls> jdm: how odd. I'd think that was a parse error...
[20:51:56] <strcat> erickt: you were working on removing \0 from strings, right?
[20:52:02] <pauls> ...oh, but it might be an error according to the macro parser; does it accept a single identifier as an argument?
[20:52:40] <pauls> `generate_node_base!` might be expecting more after it parsed `Comment`.
[20:54:40] *** Quits: Axord (xord@moz-C3CCF156.lsanca.dsl-w.verizon.net) (Quit: I'm sure it's perfectly safe)
[20:54:54] *** Joins: pnathan_ (pnathan@moz-6DE9281A.pools.spcsdns.net)
[20:55:10] *** Joins: fabiand (fabiand@moz-F2EF568F.adsl.alicedsl.de)
[20:55:56] *** Joins: tcr (tcr@moz-DA668CE2.public.wayport.net)
[20:57:41] *** Joins: brson (brson@8ECA0B87.AD77F8DE.D1E74241.IP)
[20:57:42] *** ChanServ sets mode: +o brson
[20:58:01] *** Quits: msingle (Thunderbir@moz-930E5D97.hr.hr.cox.net) (Ping timeout)
[20:58:47] *** Joins: doomlord (doomlod@moz-13E69BC8.range86-180.btcentralplus.com)
[21:00:33] <jdm> pauls: how come?
[21:00:53] <jdm> pauls: I pasted the definition up above
[21:04:16] *** Quits: askalski (akuda@moz-9E90956C.neoplus.adsl.tpnet.pl) (Quit: Wychodzi)
[21:04:25] *** Joins: askalski (akuda@moz-9E90956C.neoplus.adsl.tpnet.pl)
[21:04:51] *** Quits: Azdle (Azdle@moz-B334B496.hfc.comcastbusiness.net) (Quit: Leaving)
[21:06:12] <bblum> strcat: ok, where did vec::map_consume go?
[21:06:40] * strcat didn't know that existed
[21:06:55] *** Joins: hjr3 (hradtke@1A0AE795.28A5F6C3.A2D40ED2.IP)
[21:07:14] <bblum> ????
[21:07:18] <bblum> where is it o_o
[21:08:42] <engla> gone
[21:08:48] <engla> iterators can do it
[21:08:52] <jedestep> bblum: consume_iter
[21:08:57] <strcat> map_consume actually existed on vec?
[21:09:02] <bblum> there needs to be a convenience function for this
[21:09:16] <engla> eee677564216a64f48ebaffa860e4062f2b2d264  
[21:09:20] <engla> removed it
[21:09:33] *** Quits: askalski (akuda@moz-9E90956C.neoplus.adsl.tpnet.pl) (Quit: Wychodzi)
[21:09:34] *** Joins: maxli (maxli@B5559308.9C54E60.2FA4EA88.IP)
[21:09:49] <strcat> uh
[21:09:53] <strcat> it allocated a new array?
[21:09:59] <strcat> I guess it has to
[21:10:09] <bblum> yeah, it has to allocate
[21:10:14] <bblum> if you were really clever you could use realloc()
[21:10:25] <bblum> but that seems like a big special case
[21:10:37] <engla> you could do it if the types had the same size
[21:10:56] <engla> hm it sounds terrible
[21:11:20] *** Quits: pnathan_ (pnathan@moz-6DE9281A.pools.spcsdns.net) (Quit: Colloquy for iPhone - http://colloquy.mobi)
[21:11:39] <pcwalton> hmm, we allow generic FFI functions
[21:11:42] <pcwalton> I vote to remove this
[21:11:51] <pcwalton> I think they're a relic of the time we didn't monomorphize
[21:11:54] <strcat> pcwalton: need it for intrinsics though
[21:11:58] <pcwalton> oh right
[21:12:05] <pcwalton> ok, for non-intrinsics then
[21:12:09] <strcat> yeah I agree
[21:12:23] <homa_rano> what's the 0.7 way of collecting an iterator into a vector?
[21:12:34] <jedestep> homa_rano: foo.iter().collect()
[21:12:35] <strcat> pcwalton: https://github.com/mozilla/rust/pull/7906 r?
[21:13:13] <sully> fun fact: if you build up the list in reverse, you need to reverse it when you are done.
[21:13:43] <bblum> sully: that seems urelated to the factorial function
[21:13:44] <pcwalton> strcat: r+
[21:13:47] *** Joins: jgilbert (jgilbert@moz-7B0110AD.mv.mozilla.com)
[21:13:51] <homa_rano> jedestep: aha, thanks
[21:13:52] <pcwalton> I wonder if that helps compile perf
[21:14:01] *** Quits: josh (josh@moz-348C4790.hsd1.mn.comcast.net) (Quit: josh)
[21:15:31] <jdm> pcwalton: erk, I was calling the wrong macro :<
[21:15:58] <sully> oof
[21:16:07] <sully> that is a C++ quality error message right there
[21:16:19] <sully> one of the downsides of the cool new iterator stuff
[21:16:24] *** Quits: saml (sam@moz-14C16814.cst.lightpath.net) (Quit: Leaving)
[21:16:28] <sully> is that if you are using a lot of iterators, and you do something wrong
[21:16:29] *** Quits: fabiand (fabiand@moz-F2EF568F.adsl.alicedsl.de) (Quit: Verlassend)
[21:16:34] <sully> you get a hell of a an error message
[21:16:44] <strcat> sully: the dummy type parameters make it a bit more insane than it should be too
[21:16:54] <sully> well, I /might/ maybe be fixing that
[21:17:06] <strcat> since it has <A, B, T, U> for some instead of <T, U> and so on
[21:17:18] <sully> but I am feeling kind of out of it today, so I'm not actually smart enough to properly analyze whether this will fix it
[21:17:27] <sully> but I believe it is related, and it is fixing something related
[21:17:29] <sully> so it might.
[21:17:44] <sully> oh, right, I can't invert a map iterator.
[21:17:46] <sully> hm.
[21:18:05] <sully> I guess I need to collect this into a list and then reverse it again
[21:18:07] <strcat> sully: treemap/smallintmap have reverse iterators though, or at least they should
[21:18:27] <strcat> sully: oh you mean map as in transform?
[21:18:32] <sully> yeah, MapIterator
[21:18:39] <strcat> sully: https://github.com/mozilla/rust/pull/7897 I have impls of those
[21:19:08] <strcat> only works if the iterator inside them is double-ended though
[21:20:12] <strcat> iterator.rs is a nice set of unit tests for traits ;p
[21:20:17] <eholk> bblum: yeah, that was a lot of fun last summer!
[21:20:33] *** Quits: vk (chatzilla@3E9D68F2.B1163E0C.2A6693DD.IP) (Ping timeout)
[21:20:44] *** Quits: Ms2ger (Ms2ger@moz-12781595.adsl-dyn.isp.belgacom.be) (Quit: nn)
[21:20:54] <bblum> eholk: check out how pretty this is though: http://pastebin.mozilla.org/2656922
[21:21:53] <eholk> bblum: nice!
[21:22:55] <sully> no DoubleEnded for zip iterator?
[21:23:26] <strcat> sully: I don't really think it would work
[21:23:31] <strcat> it would need to know they are the same length
[21:23:35] <sully> hm, well, if the sequences are different lengths
[21:23:43] *** Joins: Nisstyre (wes@moz-FD86289.netflash.net)
[21:23:49] <strcat> I could add Container impls for iterators with exact lengths
[21:23:53] <strcat> hrm
[21:23:56] <sully> I think I have expressed my objection to ZipIterator's treatment of sequences with different lengths
[21:24:07] <strcat> sully: well we can have zip_longest
[21:24:10] <sully> well, at least, I feel like having both beahviors is useful
[21:24:14] *** Quits: vodik (simon@moz-CBE4BB13.cable.teksavvy.com) (Ping timeout)
[21:24:21] <strcat> I think either one can't be DoubleEnded though
[21:24:44] <strcat> well, they could be, but the semantics would be a bit strange
[21:25:18] <sully> the semantics would be "if you get a reversed iterator for this, and they are different lengths, the first N results will be silly and then you will fail"
[21:26:02] <sully> oh, heh
[21:26:02] <strcat> just thinking about what zip would do on double-ended
[21:26:05] <strcat> like
[21:26:14] <strcat> zip([1, 2], [1, 2, 3, 4])
[21:26:16] <sully> so, the thing about a double ended MapIterator here
[21:26:28] <sully> is that it would not do what I want
[21:26:42] <strcat> next() -> (1, 1), next() -> (2, 2), done
[21:26:45] <strcat> but if you did...
[21:26:46] <sully> because the reason I reversed the input is so that when I map over it, the side effects happen in reverse order
[21:26:54] <strcat> sully: ah
[21:27:12] *** Joins: msingle (Thunderbir@moz-20675462.nrflva.fios.verizon.net)
[21:27:15] <sully> so I think I do just need to spit it out to a vector and reverse it
[21:27:15] *** Quits: msingle (Thunderbir@moz-20675462.nrflva.fios.verizon.net) (Quit: msingle)
[21:27:22] <sully> is there a .collect() that is specialized for ~[]?
[21:27:33] <strcat> sully: nope just .collect::<~[T]>()
[21:27:45] <sully> grum
[21:28:03] <sully> I think we should have one, since I think that collecting to ~[]s is a super common case
[21:28:06] <strcat> I'd like it if it let you write ::<~[_]>
[21:28:08] <strcat> and inferred
[21:28:11] <sully> right
[21:28:14] <sully> but we don't, so...
[21:28:27] *** Quits: azita (Azita@moz-C1FB2A8.hsd1.ca.comcast.net) (Quit: azita)
[21:28:32] <sully> it probably wouldn't be that hard to add, but I don't know if we want to
[21:28:36] <strcat> sully: but aggravating everyone is the quickest way to get someone to implement it :)
[21:28:37] <pcwalton> a type ascription operator would probably work, no?
[21:28:41] *** Quits: erickt (erickt@8C9ECD8F.3A598286.F12515B4.IP) (Quit: Leaving.)
[21:28:59] <sully> well, the thing is, I don't want to have to give a full annotation
[21:28:59] <engla> sully: it's super easy, you just add a function that calls collect, and uses ~[T] in the return type
[21:29:15] <sully> yeah, I know that writing to_vec is easy
[21:29:33] <sully> and I think it should be in iterator.rs, but iterator.rs is strcat's baby, so I'm running it by him
[21:29:37] <strcat> it's to_uniq_vec, though
[21:29:45] <sully> sure, to_uniq_vec()
[21:29:53] <engla> why not to_vec
[21:30:25] *** Joins: strcat1 (strcat@moz-54F7FD49.cpe.net.cable.rogers.com)
[21:30:43] <strcat1> engla: because 'vec' is a bit ambiguous
[21:30:55] <engla> well
[21:31:02] <engla> I'd use to_vec
[21:31:07] <strcat1> although I would really prefer not having a special case and just making partial type hints possible
[21:31:11] *** Quits: rusti (rusti@moz-54F7FD49.cpe.net.cable.rogers.com) (Ping timeout)
[21:31:14] *** Joins: vk (chatzilla@3E9D68F2.B1163E0C.2A6693DD.IP)
[21:31:19] *** Quits: strcat (strcat@moz-54F7FD49.cpe.net.cable.rogers.com) (NickServ (GHOST command used by strcat1))
[21:31:22] *** strcat1 is now known as strcat
[21:31:27] <sully> eh, I think code using the special case would look nicer
[21:31:31] <engla> even with partial hints, it's cumbersome to write .collect::<~[]>()
[21:31:34] <sully> ::<~[_]> is super super ugly
[21:31:38] <engla> look at all that puncuation
[21:31:44] <sully> I mean, I understand that it is more principled and elegant
[21:31:49] <sully> I'm a PL theorist
[21:31:50] <sully> but...
[21:31:59] <engla> strcat: just sync up with .to_owned() I think owned is the better terminology
[21:32:11] <strcat> but that doesn't make sense on Iterator
[21:32:16] <sully> to_owned_vec()?
[21:32:19] <engla> right
[21:32:32] <engla> just saying you can't have uniq in one place and owned in the other
[21:32:51] <strcat> sully: so, basically I really want to add other types of vectors - ropes and small vectors
[21:32:58] <strcat> and I really don't want ~[] to be the "first-class" one
[21:33:04] <strcat> it will discourage using the right tool for the job
[21:33:59] *** Joins: Uther (Instantbir@moz-1B244B05.hfc.dyn.abo.bbox.fr)
[21:34:33] <pcwalton> in haskell you'd just use type ascription, right?
[21:34:39] <pcwalton> I mean, maybe that's the best thing
[21:35:26] <sully> I'm not actually really sure
[21:35:37] <sully> I feel like the iterator stuff doesn't really directly map into haskell
[21:35:41] <pcwalton> I mean, haskell's type inference is better than ours so I guess you don't have to write it as often
[21:35:48] <pcwalton> it's a general problem with overloading in the return type
[21:36:08] <sully> so, where it comes up it seems
[21:36:09] <pcwalton> I'm pretty sure there are some cases in which haskell's type inference breaks down at least in the presence of GHC extensions though
[21:36:16] <sully> yeah
[21:36:33] <sully> so, the problem having to type annotate it here, is that in rust, you need to write out a full annotation
[21:36:49] <strcat> sully: well it kind of maps to haskell, you could consider [a] to be their iterator
[21:36:54] <kimundi> let v: ~[_] = iter.collect()
[21:36:58] <sully> when all you really /need/ to tell the inferencer is that it is an array
[21:36:59] <strcat> so their FromIterator is just conversion from a list
[21:37:07] <sully> but I still think that is kind of ugly?
[21:37:16] <strcat> one issue we have is that static methods from generic traits are painful to use
[21:37:19] <strcat> instead of....
[21:37:23] <strcat> T::method(x)
[21:37:25] <strcat> you do
[21:37:30] <strcat> MethodTrait::method::<T>(x)
[21:37:40] <pcwalton> we can't do T::method(x)
[21:37:50] <pcwalton> or rather, we don't want to :)
[21:38:02] <engla> aw
[21:38:07] <sully> I mean, you usually shouldn't have to write the T
[21:38:10] <sully> although I'm not sure how often you do
[21:38:18] <pcwalton> it makes '::' too magical -- looking through all traits in scope
[21:38:31] <sully> when I first implemented static methods, I dumped all of the static methods into the enclosing namespace
[21:38:38] <sully> but it looks like that got changed
[21:38:41] <pcwalton> it did
[21:38:56] <sully> is it possible to import them into another namespace?
[21:38:59] <strcat> pcwalton: I find FromIterator::from_iterator::<T>(x) too painful to actually use though
[21:39:02] <sully> I feel like I tried to do this and got an error
[21:39:03] <pcwalton> not at the moment
[21:39:05] <strcat> that's why collect exists ;p
[21:39:24] <strcat> especially since you can't import from a trait namespace
[21:39:31] *** Joins: jvtdlc (chatzilla@7C2DFC51.3EFEC9D9.209B798A.IP)
[21:39:34] <sully> yeah, that is a huge problem, I think
[21:39:34] *** Quits: true_droid (Adium@moz-123FD9B8.beck.volia.net) (Quit: Leaving.)
[21:39:36] <pcwalton> strcat: I know people keep asking for it, but I'm still very nervous about making '::' magic
[21:39:44] <sully> well, I mean, it makes static methods basically too painful to use
[21:39:51] <strcat> generic ones
[21:39:51] <pcwalton> you can write a wrapper function
[21:40:05] <sully> I don't want to make :: magic, I just want you to be able to import static methods into other namespaces
[21:40:08] <pcwalton> so the reason why I removed importing from a trait namespace has to do with typedefs
[21:40:12] <sully> like you can do with every other named thing in the language
[21:40:41] <pcwalton> people *also* want to be able to write "type Foo = Bar;" and be able to call Bar's static methods (e.g. new) with Foo::new()
[21:40:45] <Thiez> why does Result<T,U>.get()->T require T to be clone? oO
[21:40:55] <pcwalton> Thiez: because it hasn't been renamed to unwrap() yet. I want to.
[21:40:57] <pcwalton> err
[21:41:03] <pcwalton> because unwrap() hasn't been renamed to get() yet
[21:41:07] <Thiez> oh, it copies
[21:41:10] *** Quits: jedestep (jedestep@34641662.FB4DE631.66C78B76.IP) (Ping timeout)
[21:41:15] <Thiez> how silly :)
[21:41:32] <kimundi> pcwalton: There was a bit of discussin recently about those names
[21:42:21] <pcwalton> maybe the answer is that you can only import from trait namespaces but not from impl-for-type namespaces
[21:43:12] <kimundi> pcwalton: https://github.com/mozilla/rust/issues/7887
[21:44:27] <kimundi> The shortes convenient names seem to be get() for a &T, unwrap() for moving out, take() for replacing with None.
[21:44:41] <jdm> /home/jdm/sdb/servo/src/components/script/dom/bindings/element.rs:306:29: 306:34 error: internal compiler error: No type for local variable 49656
[21:44:44] <jdm> arghbarghle
[21:45:00] *** Parts: jvtdlc (chatzilla@7C2DFC51.3EFEC9D9.209B798A.IP) ()
[21:45:15] <kimundi> jdm: At least it tells you the exact number ;)
[21:45:18] <strcat> s/take/swindle/ ;p
[21:45:46] *** Quits: donri (dag@moz-9BB61102.tbcn.telia.com) (Client exited)
[21:45:49] <bblum> pcwalton: https://github.com/mozilla/rust/issues/7909 o_O at this
[21:46:00] <bblum> (nothing important)
[21:46:05] <strcat> bors seems to be stuck
[21:46:08] <pcwalton> so here are two proposals.
[21:46:19] *** Joins: rusti (rusti@moz-54F7FD49.cpe.net.cable.rogers.com)
[21:46:20] <Thiez> pcwalton: when you're fixing Result, could you have a look at Future too?
[21:46:20] <pcwalton> (1) allow trait static methods to be imported (but NOT through typedefs of that trait)
[21:46:27] <pcwalton> Thiez: I won't be in the foreseeable future.
[21:46:28] <Thiez> right now it also always copies
[21:46:30] <kimundi> .houdini()
[21:46:36] <pcwalton> I have no time, swamped with backwards incompatible language changes
[21:46:54] <Thiez> hmmn, perhaps I'll do it then.
[21:47:16] *** Joins: KindOne (KindOne@moz-854E31FC.dynamic.ip.windstream.net)
[21:47:28] *** Joins: erickt (erickt@8C9ECD8F.3A598286.F12515B4.IP)
[21:47:28] *** Joins: ghrust (ghrust@FD7BC443.6A2AE50.F3114085.IP)
[21:47:28] <ghrust> 01[13rust01] 15thestinger 04force-pushed 06auto from 143b74b0a to 140d04aa7: 02http://git.io/N3iJvQ
[21:47:28] *** Parts: ghrust (ghrust@FD7BC443.6A2AE50.F3114085.IP) ()
[21:47:33] <strcat> please bors?
[21:47:34] <pcwalton> (2) allow "?" in type signatures like Java to mean "whatever", allowing ascriptions like foo : ~[?]
[21:47:35] <strcat> ;p
[21:47:46] <pcwalton> that's far less ugly than ::<~[_]>
[21:47:47] <pcwalton> imho
[21:48:10] <strcat> you mean like Scala? 
[21:48:14] <pcwalton> Java has ?
[21:48:16] <strcat> oh
[21:48:18] <pcwalton> look it up :)
[21:48:37] <kimundi> let v: ~[_] = iter.collect(); let v: ~[?] = iter.collect(); 
[21:48:40] <bblum> i kind of prefer ~[_] as it fits more with pattern-matching, but whatever
[21:48:52] *** Quits: carllerche (carllerche@6B070D22.7E6A0813.1428D117.IP) (Quit: carllerche)
[21:48:54] <pcwalton> I don't have strong feelings either way
[21:48:59] <pcwalton> I do feel like type ascription is the best here
[21:49:01] *** Joins: heftig_ (heftig@moz-E82F1C34.dip0.t-ipconnect.de)
[21:49:08] <pcwalton> we want that anyway
[21:49:19] <pcwalton> I also vote not blocking 1.0 on any of this
[21:49:24] <pcwalton> except maybe (1)
[21:49:27] <sp3d> is there a difference between type ascription and type annotation?
[21:49:36] *** Quits: heftig (heftig@moz-B6FEC520.dip0.t-ipconnect.de) (Ping timeout)
[21:49:44] *** Joins: ghrust (ghrust@AC22872E.6A2AE50.F3114085.IP)
[21:49:45] <ghrust> 01[13rust01] 15bors pushed 0 new commits to 06auto: 02http://git.io/ie2oRg
[21:49:45] *** Parts: ghrust (ghrust@AC22872E.6A2AE50.F3114085.IP) ()
[21:49:54] <strcat> there
[21:49:56] <strcat> got it unstuck
[21:49:59] <pcwalton> \o/
[21:50:05] <strcat> had to close the pending PR
[21:50:15] <sully> I think 1 is probably important for 1.0?
[21:50:23] <strcat> need to wait a bit or it goes mad and does 2 at once
[21:50:48] <kimundi> pcwalton: What do you mean with type ascriptons? 'let v : ~[?]  = iter.collect(); ' or 'let v = iter.collect() : ~[?] ; '?
[21:50:58] <bblum> kimundi: the former
[21:51:08] <bblum> the latter is not grammatical
[21:51:23] <sp3d> the latter would be nice so you could have it in expressions
[21:51:23] <pcwalton> no, the latter
[21:51:27] <bblum> oh
[21:51:29] <sp3d> yay
[21:51:29] <sully> I think that 2 is probably not important for 1.0, but if we don't add it, we really ought to add a .to_owned_vec() or some suitable "default" thing for when you are working with iterators and you need to collapse it out into something real
[21:51:31] <pcwalton> we wanted to allow that in general
[21:51:32] <Thiez> does it make sense to put stuff like 'unwrap' and/or 'get' and 'get_ref' into a trait, to make it more obvious that there is a naming convention?
[21:51:33] <sully> for temporary use
[21:51:34] <bblum> my mistake
[21:51:37] <sully> which seems to come up decently often
[21:51:45] <sully> (I have a .to_owned_vec() on my local branch)
[21:51:54] <bblum> Thiez: it does, but there is an open debate about the actual names
[21:52:42] *** Joins: ghrust (ghrust@C621748.6A2AE50.F3114085.IP)
[21:52:42] <ghrust> 01[13rust01] 15bors 04force-pushed 06auto from 141ce2190 to 140d04aa7: 02http://git.io/N3iJvQ
[21:52:42] *** Parts: ghrust (ghrust@C621748.6A2AE50.F3114085.IP) ()
[21:52:44] *** Joins: ghrust (ghrust@614D05BD.6A2AE50.F3114085.IP)
[21:52:44] <ghrust> 01[13rust01] 15bors pushed 30 new commits to 06auto: 02http://git.io/8BhbcQ
[21:52:44] <ghrust> 13rust/06auto 14e9735da 15Ben Blum: Add Either::expect_{left,right}
[21:52:44] <ghrust> 13rust/06auto 147877113 15Ben Blum: Add Option::take_map{,_default}()
[21:52:44] <ghrust> 13rust/06auto 14263584f 15Ben Blum: Remove redundant Atomic{Ui,I}nt types from unstable::sync
[21:52:46] *** Parts: ghrust (ghrust@614D05BD.6A2AE50.F3114085.IP) ()
[21:52:54] <strcat> there :)
[21:53:11] <sully> oh, sigh
[21:53:23] <sully> v.rev_iter().collect() does not actually reverse a vector :P
[21:53:43] *** Quits: bjz_ (brendanzab@B398BE78.F804C29E.D35A31DF.IP) (Connection reset by peer)
[21:53:45] *** Joins: bjz (brendanzab@B398BE78.F804C29E.D35A31DF.IP)
[21:53:47] <strcat> sully: it should
[21:53:57] <sully> it does something very similar to reversing a vector
[21:54:00] <engla> you get reverse &T
[21:54:10] *** Quits: spider-mario (spidermari@moz-81131DB6.fbx.proxad.net) (Input/output error)
[21:54:12] <sully> namely, creating a vector with & pointers to the original one
[21:54:13] <sully> reversed
[21:54:23] <strcat> sully: well, because iter() uses &T
[21:54:29] <sully> yeah
[21:54:34] <strcat> there's .reverse on vecs for just doing it in-place
[21:54:39] <sully> yeah, I just found that
[21:55:04] <strcat> you'd need .map(|x| x.clone()) (or deep_clone) for making a new unrelated one
[21:55:14] <brson> graydon: r? https://github.com/mozilla/rust/pull/7883
[21:55:28] <strcat> alright I think github actually broke on this PR
[21:55:30] <strcat> I can't reopen
[21:55:33] *** Quits: vosen (vosen@moz-266BA656.icpnet.pl) (Quit: Leaving)
[21:55:35] <Thiez> rusti: let v = ~[1,2,3,4]; v.consume_rev_iter().collect::<~[int]>()
[21:55:37] -rusti- ~[4, 3, 2, 1]
[21:55:40] <graydon> brson: r+
[21:55:47] <graydon> brson: and any rebasing of it required, r=me
[21:55:49] <strcat> oh there it goes
[21:55:50] <smvv> I would like to create a ~[u8] type of a ~[~str] type. I tried for example: (~[~"hi", ~"bye"]).connect(" ").as_bytes().to_owned(), but the reference returned by as_bytes() does not life long enough. What should I do? I saw that there is an as_bytes_with_null_consume that does convert ~str to ~[u8], but that does append an extra null byte to the ~[u8]
[21:56:08] <strcat> graydon: btw bors got stuck on https://github.com/mozilla/rust/pull/7874 for some reason, but closing + deleting the r+ + reopening worked
[21:56:11] <sully> oh wow, my PR is still really late in the queue
[21:56:14] <graydon> weird
[21:56:16] <strcat> graydon: after closing it did the strange double-merge
[21:56:20] <graydon> :(
[21:56:29] <strcat> if I'd have reopened quickly it would have gone on one of those clobber rampages
[21:56:36] <strcat> where it has 2 pending ones
[21:56:40] * strcat has seen this bug a few times
[21:56:47] <strcat> it might be github being weird
[21:57:06] <graydon> yeah, >1 pending seems to make it terribly upset
[21:57:33] <jdm> so I've found intrinsics::move_val_init
[21:57:39] <graydon> maybe I should try to establish "max 1 pending" as an invariant in the logic somewhere
[21:57:41] <jdm> unfortunately, it takes a T for the second param, and I have a &mut T
[21:57:51] <olsonjeffery> brson: nice!
[21:57:53] <graydon> II would have thought that was true, but hey, distributed systems
[21:58:04] <Thiez> jdm: what are you trying to do, exactly?
[21:58:08] *** Quits: bjz (brendanzab@B398BE78.F804C29E.D35A31DF.IP) (Ping timeout)
[21:58:10] *** Joins: bjz (brendanzab@B398BE78.F804C29E.D35A31DF.IP)
[21:58:11] <strcat> graydon: I think github is giving you inconsistent information
[21:58:14] <bblum> strcat: error: type `vec::VecConsumeIterator<...>` does not implement any method in scope named `map_` ?
[21:58:14] <olsonjeffery> incidentally.. will hopefully have a newsched timer PR later today
[21:58:24] <bblum> oh transform
[21:58:26] <bblum> never mind me
[21:58:33] <jdm> Thiez: I'm essentially trying to replicate placement new
[21:58:35] <strcat> bblum: well if you use consume you don't need clone
[21:58:40] <strcat> or is this something else? ;p
[21:58:45] *** Quits: Guest (textual@34641662.FB4DE631.66C78B76.IP) (Quit: Textual IRC Client: www.textualapp.com)
[21:58:52] <bblum> strcat: clone isn't involved here
[21:58:54] <strcat> ah
[21:58:58] <jdm> Thiez: I've got a struct S that I create somewhere and pass &S around until I get to the place where I want to stash the value somewhere else
[21:59:00] <bblum> i just forgot the name
[21:59:06] <strcat> bblum: yeah I really want to rename it
[21:59:11] <bblum> i know you do
[21:59:13] <strcat> bblum: Luqman was working on a fix for the relevant bug ;p
[21:59:44] <bblum> ok, this is a problem
[21:59:45] <bblum> error: failed to find an implementation of trait rt::select::Select for &rt::select::Select<no-bounds>
[21:59:52] *** Quits: tcr (tcr@moz-DA668CE2.public.wayport.net) (Ping timeout)
[21:59:57] <bblum> why do packed traits not implement their own triat
[21:59:59] <bblum> *trait
[22:00:07] *** Joins: carllerche (carllerche@moz-CDE5367B.dsl.static.sonic.net)
[22:00:10] <sully> so, when we have an impl
[22:00:19] <sully> we don't actually check that the type also implements any super traits
[22:00:20] <strcat> bblum: I got what you were doing confused with what sully was doing :)
[22:00:36] <sully> and I have fixed that
[22:00:42] <strcat> it's weechat's fault for hashing your nicknames to the same colour
[22:00:52] <sully> as it turns out, we have a bunch of traits for which we do not in fact ever implement the supertraits
[22:01:16] <jdm> supertraits are some of the least tested and implemented parts of the language, it feels
[22:01:17] <strcat> sully: I noticed that before, I may have even filed a bug ;)
[22:01:29] <sully> a bunch of things that implement TotalOrd don't implement TotalEq
[22:01:34] <sully> one of strcat's iterators was messed up
[22:02:03] <sully> I really like the way that I implemented this check, by the way
[22:02:08] <Thiez> jdm: have you considered just swapping it?
[22:02:16] <jdm> Thiez: ooh, no.
[22:02:23] <sully> which is that every time we see an impl of a trait
[22:02:38] <sully> we do a vtable search for that type for the trati
[22:03:02] <strcat> jdm: yeah I basically assumed they didn't work after my prior experience with them
[22:03:13] <strcat> but... I made DoubleEndedIterator inherit from Iterator and it seems to mostly work
[22:03:24] <strcat> I don't remember seeing anyone try to fix them though
[22:03:30] <sully> so, I feel like a lot of supertrait stuff works decently
[22:03:36] <sully> except for supertrait interaction with default methods
[22:03:40] <sully> which is totally and completely wrong
[22:03:57] <sully> except in the most basic monomorphic single crate setting
[22:04:32] <sully> this, in fact, is why I am fixing the supertrait checking bug
[22:04:50] * strcat needs to make RandomAccessIterator >:)
[22:05:43] *** Quits: bjz (brendanzab@B398BE78.F804C29E.D35A31DF.IP) (Ping timeout)
[22:05:46] <sully> strcat, do you have a good small test case for the dummy type param bug?
[22:06:07] *** Joins: bjz (brendanzab@B398BE78.F804C29E.D35A31DF.IP)
[22:06:41] *** Joins: lucian (lucian@moz-22A14C6A.cable.virginmedia.com)
[22:06:58] <strcat> hm
[22:07:40] <sully> because I have a patch that I think might substantially improve impl resolution
[22:07:49] <sully> I needed to do this because as it turns out
[22:08:37] <sully> our impl resolution is sufficently weak that it can not always, given an impl, find that the impl implements the trait at its type params
[22:09:51] <strcat> sully: http://ix.io/6Km
[22:10:01] <strcat> could make it simpler
[22:10:23] <strcat> hrm
[22:10:38] <Thiez> jdm:
[22:10:41] <Thiez> rusti: use std::cast::*; use std::unstable::intrinsics::*; struct S{x:int,y:int}; let s = S{x:4,y:3}; unsafe{ let sp = &s; let mut t = uninit(); move_val_init(&mut t,*transmute_mut(sp)); t }
[22:10:42] -rusti- {x: 4, y: 3}
[22:10:51] <Thiez> it can be done, but it's not very pretty.
[22:11:15] <jdm> Thiez: what's the transmute_mut?
[22:11:22] <Thiez> also unsafe if you have more pointers lying around
[22:11:25] <sully> ok
[22:11:28] <Thiez> it makes &T -> &mut T
[22:11:37] <jdm> Thiez: well, I had a &mut T
[22:11:42] <sully> I will test that out as soon as I finish fixing all of our code
[22:11:44] <Thiez> oh, then it's okay, you don't need that :)
[22:11:49] <sully> to actually have all the supertraits it is supposed to
[22:11:53] <Thiez> you can just * the &mut T
[22:11:59] <jdm> Thiez: I was informed that I couldn't move out of a * dereference, though
[22:12:32] *** Joins: SiegeLord (sl@moz-56D7E78.bstnma.fios.verizon.net)
[22:12:37] <strcat> sully: heh sorry example is a bit broken
[22:12:49] <strcat> hm
[22:13:02] <Thiez> rusti: struct S { x:int } let mut s = S{x:5}; let sp = &mut s; let t = *sp; t
[22:13:03] -rusti- {x: 5}
[22:13:07] <Thiez> appears to work just fine
[22:13:28] *** Quits: huseby (huseby@moz-4E8C421A.husebyhome.com) (Ping timeout)
[22:13:53] <strcat> dummy type param isn't fixing this ;\
[22:13:55] <Thiez> oh, my struct is probably implicitly copyable or something
[22:14:07] <sp3d> hm, rusti (program) doesn't appear to care about nonexisting imports
[22:15:50] <graydon> r? someone https://github.com/mozilla/rust/pull/7912
[22:17:12] <tjc> graydon: r+'ed
[22:17:42] <strcat> graydon: hm bors isn't actually starting buildbot builds
[22:17:48] <strcat> well
[22:17:54] <strcat> I guess that's buildbot's fault entirely.
[22:19:25] *** Quits: lucian (lucian@moz-22A14C6A.cable.virginmedia.com) (Input/output error)
[22:20:19] <strcat> sully: http://ix.io/6Ko here, that shows the type inference failing
[22:20:27] <strcat> but type checking does work if you give a hint
[22:21:05] <sully> ok
[22:21:16] <sully> and this is the same as the dummy param thing, or?
[22:21:33] <strcat> sully: yeah
[22:21:47] <strcat> sully: for some reason it's getting mad about an unconstrained type when I try the dummy type workaround here
[22:22:02] <brendanc> hmm I wonder why buildbot isn't seeing auto
[22:24:20] *** Quits: MaikKlein1 (maik@moz-236DC30E.dip0.t-ipconnect.de) (Ping timeout)
[22:25:54] *** Quits: geomyidae (cole@DD6F7E3A.21468E9A.30200F38.IP) (Client exited)
[22:26:39] <bstrie> what are the cases where lifetimes must be explicitly named on functions? is it just when returning borrowed pointers?
[22:27:38] *** Joins: huseby (huseby@moz-4E8C421A.husebyhome.com)
[22:27:43] *** Quits: pcwalton (pcwalton@moz-7B0110AD.mv.mozilla.com) (Quit: pcwalton)
[22:28:08] <strcat> bstrie: not just when returning them
[22:28:30] <strcat> when passing them to a closure you were passed, etc.
[22:29:11] <strcat> lifetimes are only inferred locally, named lifetimes are required for borrowed pointers escaping from functions
[22:30:11] *** Quits: hjr3 (hradtke@1A0AE795.28A5F6C3.A2D40ED2.IP) (Quit: My MacBook has gone to sleep. ZZZzzzâ€¦)
[22:30:49] *** Quits: Ralith (ralith@moz-50F3C77.vc.shawcable.net) (Ping timeout)
[22:30:53] *** Quits: rusti (rusti@moz-54F7FD49.cpe.net.cable.rogers.com) (Ping timeout)
[22:31:08] *** Quits: strcat (strcat@moz-54F7FD49.cpe.net.cable.rogers.com) (Ping timeout)
[22:32:09] <sp3d> when parsing (looking at this binary-float thing), is it better to parse a little ahead and give a semantic message (e.g. "binary floats are not supported", which is currently done sometimes) or to stop at the first invalid char and say what was expected?
[22:32:13] <sully> hm, ok, so, my patch does not fix it
[22:32:39] <sully> but it also occurs to me that I set things up specifically so that nothing would change in the early resolution case
[22:32:54] <sully> and this would require getting more information during early resolution
[22:34:38] *** Quits: eatkinson (eatkinson@moz-BBE3ABD.mv.mozilla.com) (Quit: eatkinson)
[22:34:39] <graydon> brson: ping
[22:35:04] <brson> graydon: pong
[22:35:30] <graydon> brson: remind me again how we can have test in extra, yet when I build libstd with --test it links in libextra?
[22:35:38] <graydon> doesn't libextra depend on libstd?
[22:35:45] <graydon> (doesn't this make a circular crate dependency?)
[22:36:29] <brson> graydon: stdtest is effectively *not* std
[22:36:50] <brson> graydon: when building with #[cfg(test)] we strategically compile out some things like lang items
[22:37:05] <brson> graydon: so the linkage is stdtest->extra->std
[22:37:28] <graydon> this .. huh, ok
[22:37:41] <graydon> did you still think it would be desirable to move the tests back out of the crates someday?
[22:37:51] *** Quits: tjc (tjc@moz-BBE3ABD.mv.mozilla.com) (Quit: zzzzzzzzzz)
[22:37:56] <graydon> I am trying to figure what to do about leaving #[bench] things in std for now
[22:38:19] <sully> oh no
[22:38:26] <sully> I made some changes to vtable resolution
[22:38:35] <sully> and now, when I try to compile stage2
[22:38:38] <graydon> can test modules within std _see_ extra? like can I put 'extern mod extra' in a mod in std?
[22:38:41] <sully> there is some sort of lifetime error
[22:38:53] *** Quits: themgt (themgt@moz-7834B2B9.cm.vtr.net) (Ping timeout)
[22:38:56] <graydon> sully: *warning warning*
[22:38:57] <brson> graydon: i'm fairly satisfied with the status quo. the stdtest situation is a little ugly but seems to be managable. what's your reservation about having #[bench] tests in std?
[22:39:10] <brson> graydon: yes, theoretically you could call libextra from std tests
[22:39:54] <brson> the main reason i'd want to move tests out of std is for turnaround time
[22:39:58] <graydon> brson: well, two things I guess. 1 is that I didn't know if I _could_ mention extra::test::BenchHarness in a std test. 2 is that it's just .. longer term I thought we might have been thinking about moving them back out of the crates and confining tests to the public interface
[22:40:04] *** Quits: SiegeLord (sl@moz-56D7E78.bstnma.fios.verizon.net) (Quit: Leaving)
[22:40:08] <graydon> (and, yeah, turnaround time improvements, and conforming to rustpkg's assumptions, etc.)
[22:40:18] <brson> what does rustpkg say about tests?
[22:40:28] *** Quits: infynyxx (infynyxx@DB780A29.749BA1D.DCC373F0.IP) (Client exited)
[22:40:37] <graydon> oh, they're in crates rooted in files called test.rs or bench.rs respectively
[22:40:52] <graydon> rustpkg sees 4 filenames: main.rs, lib.rs, test.rs and bench.rs
[22:41:01] <graydon> and acts on those accordingly (automatically)
[22:41:03] *** Joins: pcwalton (pcwalton@moz-7B0110AD.mv.mozilla.com)
[22:41:03] *** ChanServ sets mode: +o pcwalton
[22:41:06] <brson> so will rustpkg not run tests that are in the crate? so you can't test internals?
[22:41:16] *** Joins: themgt (themgt@moz-7834B2B9.cm.vtr.net)
[22:41:21] *** Quits: eholk (eholk@moz-CB0ECD0F.uconnect.utah.edu) (Quit: eholk)
[22:41:52] <brson> maybe with custom rustpkg script?
[22:42:13] <graydon> brson: I guess not, though your test.rs file is just the compilation root; I suppose you could also have test.rs pull in the same files as lib.rs
[22:42:27] <graydon> "plus some other stuff"
[22:42:41] <graydon> it's just a convention. you could multiply compile.
[22:43:08] *** Joins: eatkinson (eatkinson@moz-BBE3ABD.mv.mozilla.com)
[22:43:08] <graydon> I'm a bit torn over whether it's best practice to try to test via public interfaces or private
[22:43:15] <graydon> whitebox vs. blackbox I guess?
[22:43:41] <olsonjeffery> /home/jeff/src/rust/mk/install.mk:136: *** Aborting install because more than one library matching libstd-*.so is present in build tree x86_64-unknown-linux-gnu/stage2/lib: .  Stop.
[22:43:47] <olsonjeffery> anyone see this? doing `make install`
[22:44:01] <vladimir-lu> graydon: this used to be a favourite argument at my old job - would come up consistently year on year
[22:44:12] <Thiez> olsonjeffery: try 'make uninstall' first
[22:44:18] <graydon> vladimir-lu: what was the conclusion, year-on-year? :)
[22:44:18] <Thiez> oh no
[22:44:20] <Thiez> never mind
[22:44:27] <vladimir-lu> graydon: there never was :P
[22:44:32] <olsonjeffery> Thiez: huh that worked
[22:44:38] <Thiez> it did? oO
[22:44:44] <Thiez> oh well
[22:44:53] <brendanc> graydon: btw buildbot doesn't seem to be picking up commits
[22:44:55] <Thiez> I accidentally fixed it I guess.
[22:44:58] <vladimir-lu> graydon: my preference is testing most the public api with the hairy bits of the private impl tested where you knew it was sensitive
[22:45:33] <graydon> brendanc: oh weird
[22:45:59] <olsonjeffery> good times: https://gist.github.com/olsonjeffery/6042901
[22:46:04] <brendanc> (and bors has two prs in 'pending')
[22:46:14] <graydon> crap
[22:46:15] <olsonjeffery> rustc barfing trying to link newsched code... ?
[22:46:34] *** Quits: ozten (ozten@moz-DD3B00B4.hsd1.wa.comcast.net) (Quit: ozten)
[22:46:35] <graydon> bors is turned off
[22:46:39] <graydon> (now)
[22:46:46] <graydon> I wonder what was going on
[22:46:51] <graydon> ssh'ing into the buildmaster
[22:46:57] *** Joins: rusti (rusti@moz-54F7FD49.cpe.net.cable.rogers.com)
[22:47:08] *** Joins: strcat (strcat@moz-54F7FD49.cpe.net.cable.rogers.com)
[22:48:01] <graydon> did it go sideways around 3pm?
[22:48:31] <brendanc> last event on buildbot is 5:49 AM
[22:48:40] <graydon> ?
[22:48:53] <graydon> oh gosh
[22:48:57] <brendanc> bors has pushed since but it hasn't been picked up
[22:49:08] <brson> rusti: (~[1i,2]).unsafe_get(1)
[22:49:09] -rusti- <anon>:7:9: 8:5 error: invocation of unsafe method requires unsafe function or block
[22:49:09] -rusti- <anon>:7          (~[1i,2]).unsafe_get(1)
[22:49:09] -rusti- <anon>:8     };
[22:49:09] -rusti- error: aborting due to previous error
[22:49:09] -rusti- application terminated with error code 101
[22:49:19] <sp3d> hm... is rust *supposed* to support whole-number literals in non-decimal bases with float types? the manual makes it sound like that's the intent
[22:49:23] <graydon> that explains the 40+ entry backlog
[22:49:24] <graydon> um
[22:49:36] <brendanc> buildbot can't reach github perhaps?
[22:49:41] <toddaaro> is the borrow checker different on master than it was two weeks ago?
[22:49:43] <graydon> sorry, was doing benchmarks today; someone yell at me a little earlier when this is happening!
[22:49:44] <olsonjeffery> brson: any ideas on that gist link i pasted above?
[22:49:55] <graydon> SQLAlchemy is losing its marbles in the twistd.log
[22:49:58] <toddaaro> it started complaining about some code that was fine on my ~two week old branch
[22:50:13] <graydon> sqlalchemy.exc.OperationalError: (OperationalError) too many SQL variables u'DELETE FROM scheduler_changes WHERE scheduler_changes.changeid
[22:50:27] *** kimundi is now known as zz_kimundi
[22:50:33] <graydon> looks like I have one of the thresholds set so high that it can't issue the command to prune when it's exceeded
[22:50:34] <graydon> charming
[22:50:34] *** Joins: tcr (tcr@moz-EE576D3C.hsd1.ma.comcast.net)
[22:50:38] <brson> going through the issue tracker there are tons of bugs with @brson mentions ... i wish github would tell me about those specifically instead of flooding my inbox with crap
[22:50:41] *** Quits: vk (chatzilla@3E9D68F2.B1163E0C.2A6693DD.IP) (Ping timeout)
[22:50:46] <brson> sorry everyone i never respond to
[22:50:50] <graydon> no worries
[22:51:01] <graydon> gh notices are unhelpful for most of us (I think?)
[22:51:12] *** Joins: vk (chatzilla@3E9D68F2.B1163E0C.2A6693DD.IP)
[22:51:15] <graydon> hm hm. shall I reset the buildbot database and lower some of the thresholds back down?
[22:51:17] <toddaaro> brson: does it really not notify? I thought it did, that is terrible UI design on their part
[22:51:58] <brson> toddaaro: it notifies about way too much. my inbox is filled with stuff
[22:52:04] <brson> so i don't read any of it
[22:52:28] <toddaaro> brson: yea, but it should be smart about @ mentions so they are easy to "actually" notice. (I also just ignore everything from github about rust)
[22:53:12] <sully> hm, wait, it isn't an error in the stage2 compiler
[22:53:17] <sully> it was an error building... librust
[22:53:43] *** Quits: james4k (james@moz-E7990244.consolidated.net) (Ping timeout)
[22:53:51] <engla> brson: imagine having the gh username mut. it would be so confusing with all the @mut mentions
[22:54:04] <olsonjeffery> hah
[22:54:10] *** Quits: rust-buildbot (rust-build@505BFA3.C3CCCE8C.D25A875A.IP) (Quit: buildmaster reconfigured: bot disconnecting)
[22:54:18] <brson> engla: lol
[22:55:01] *** Quits: carllerche (carllerche@moz-CDE5367B.dsl.static.sonic.net) (Quit: carllerche)
[22:55:41] <brendanc> http://trac.buildbot.net/ticket/2299
[22:56:16] <brendanc> fixed in 0.8.7 :(
[22:56:39] <brendanc> first hunk is fairly short :)
[22:58:39] *** Joins: tjc (tjc@moz-BBE3ABD.mv.mozilla.com)
[22:58:39] *** ChanServ sets mode: +o tjc
[22:58:43] <brendanc> graydon: ^^
[22:59:05] <Thiez> is there a way for a method to take 'mut self'? right now I find myself doing 'fn f(self) { let mut this = self; ... }
[22:59:10] <graydon> brendanc: where's the fix?
[22:59:20] <brson> olsonjeffery: where's your branch?
[22:59:22] <brendanc> https://github.com/buildbot/buildbot/commit/5d61618979fbdfcd3e87c37c246a82d0a111db16
[22:59:42] <brendanc> er https://github.com/buildbot/buildbot/commit/5d61618979fbdfcd3e87c37c246a82d0a111db16.patch
[22:59:53] <brson> olsonjeffery: odd that rustc crashes with RUST_NEWRT :-/ it worked at some point
[22:59:54] <graydon> right
[23:00:06] *** Quits: Nisstyre (wes@moz-FD86289.netflash.net) (Quit: Leaving)
[23:00:21] <graydon> um, now I can't restart it at all, wtf
[23:00:22] <olsonjeffery> brson: it's not public.. i can push it up.. it's just the additions of my timer stuff atop master. ill just do a PR.
[23:00:31] <graydon> I stopped it, moved the db aside
[23:00:37] <graydon> grr my life as a sysadmin
[23:00:45] *** Joins: james4k (james@moz-E7990244.consolidated.net)
[23:02:40] <sully> hey, if I wanted to breakpoint on a diagnostic being emitted
[23:02:45] <sully> is there a decent way to do that?
[23:03:37] *** Joins: rust-buildbot (rust-build@505BFA3.C3CCCE8C.D25A875A.IP)
[23:05:07] *** Quits: rust-buildbot (rust-build@505BFA3.C3CCCE8C.D25A875A.IP) (Quit: buildmaster reconfigured: bot disconnecting)
[23:05:34] <kmc> what would be the preferred way to manually bump the refcount on an @ box, to deal with unsafe shenanigans?  i have something like  let _: *LayoutData = unsafe { transmute(data) }
[23:05:42] <kmc> which seems to work, but I'm not totally sure why
[23:06:04] *** Quits: bjz (brendanzab@B398BE78.F804C29E.D35A31DF.IP) (Quit: Leaving...)
[23:06:20] <ecr> lol
[23:06:28] <ecr> at the @mut joke
[23:06:30] *** Quits: vk (chatzilla@3E9D68F2.B1163E0C.2A6693DD.IP) (Ping timeout)
[23:06:32] <brson> kmc: cast::bump_box_refcount
[23:06:32] *** Quits: erickt (erickt@8C9ECD8F.3A598286.F12515B4.IP) (Quit: Leaving.)
[23:06:38] <ecr> I forgot to scroll down >.<
[23:07:08] <Thiez> kmc: std::cast::bump_box_refcount
[23:07:41] <toddaaro> brson: https://github.com/mozilla/rust/pull/7915 r+?
[23:07:53] <toddaaro> brson: that is the pull request for my stuff, pre-bblum merge
[23:08:04] <kmc> brson, Thiez: thanks
[23:08:08] <Thiez> your thing works because when you pass 'data' to transmute, its refcount is incremented, then it is transmuted to a type that does not have a refcount, so it is never decremented
[23:08:15] <toddaaro> brson: I guess if that is r+'d it'll end up in a "cannot auto merge" pile and I'll manually merge with bblum
[23:08:36] *** Quits: pcwalton (pcwalton@moz-7B0110AD.mv.mozilla.com) (Quit: pcwalton)
[23:08:44] <Thiez> but the dedicated method will be much easier to understand when you read it a month from now :p
[23:08:56] <olsonjeffery> brson: https://github.com/mozilla/rust/pull/7916
[23:09:03] <bblum> bors currently has two pending PRs o_O
[23:09:08] <kmc> makes sense
[23:09:11] <olsonjeffery> curious if maybe its in how i pulled in timer in mod.rs ?
[23:09:34] <olsonjeffery> obviously im still getting caught up with lang/module changes since i last did substantial work, heh.
[23:09:47] <kmc> hm and what if I have an @mut box instead? bump_box_refcount takes only immutable boxes
[23:11:15] *** Quits: tjc (tjc@moz-BBE3ABD.mv.mozilla.com) (Quit: zzzzzzzzzz)
[23:11:15] <kmc> bump_box_refcount just calls forget so I suppose I could use forget directly
[23:11:39] <brson> olsonjeffery: yeah, maybe a resolve bug, since you don't have `pub mod timer`
[23:11:45] *** Joins: rust-buildbot (rust-build@505BFA3.C3CCCE8C.D25A875A.IP)
[23:12:10] <olsonjeffery> brson: ok, will try that
[23:12:29] <sully> hm, the debug pretty printing of region stuff is not great
[23:12:36] <olsonjeffery> brson: it's in there, actually .. mod.rs, line 71
[23:12:38] <sully> it seems to output the empty string for a bunch of regions
[23:13:58] *** Joins: carllerche (carllerche@6B070D22.7E6A0813.1428D117.IP)
[23:15:09] <brson> olsonjeffery: that's not what i see: https://github.com/olsonjeffery/rust/commit/cc29be89a8b96f4c54663a40ae24ab153261092c#L0R301
[23:15:39] <brson> olsonjeffery: aside from the two comments i left, looks great!
[23:16:24] *** Quits: maxli (maxli@B5559308.9C54E60.2FA4EA88.IP) (Quit: Leaving.)
[23:16:42] <olsonjeffery> brson: did you see my earlier query about doing async tcp?
[23:17:07] <olsonjeffery> it looks like id use the same, underlying uv tcp stuff to impl async.. just not the same scheduler deschedule/resume magic?
[23:17:38] <brson> olsonjeffery: i think so, yes
[23:19:15] <brson> toddaaro: this .bootstrap method that requires all schedulers to be initialized with a no-op task is not so great. do you have a plan to remove that requirement?
[23:19:32] <brson> "boostraping a non-primary scheduler" etc
[23:19:37] *** Joins: tjc (tjc@moz-BBE3ABD.mv.mozilla.com)
[23:19:37] *** ChanServ sets mode: +o tjc
[23:20:21] *** Joins: maxli (maxli@B5559308.9C54E60.2FA4EA88.IP)
[23:20:57] <brson> r? https://github.com/mozilla/rust/pull/7864
[23:22:57] <olsonjeffery> heh: /home/jeff/src/rust/src/libstd/rt/io/timer.rs:1: incorrect license
[23:23:05] *** Quits: eschweic (Adium@moz-BBE3ABD.mv.mozilla.com) (Quit: Leaving.)
[23:24:16] <toddaaro> brson: I had the same thought, but decided to go with it for now. We could add a second boostrap method that doesn't take a task and hops directly into the scheduler, which would have a bit of code duplication, but I think it would work.
[23:24:57] <toddaaro> brson: I guess that is something I'm hesitant to polish too much, as the startup design changes a lot next week when I do work queues for each scheduler
[23:25:31] <toddaaro> brson: (mostly the information flow of making sure they all know about each other)
[23:27:08] <brson> toddaaro: ok
[23:27:49] <bblum> i wish you could parameterize traits over self mode
[23:28:03] *** Joins: snadon (chatzilla@moz-3BC727E8.mc.videotron.ca)
[23:28:07] <bblum> so i could be like, impl <T> SelectPort<T, self> for PortOne<T>
[23:28:17] <bblum> impl <T> SelectPort<T, &mut self> for Port<T>
[23:28:36] <bblum> but i also wish you could parameterize trait inheritance over traits
[23:28:50] <bblum> while we're at it, how about parameterizing types over values
[23:28:55] *** Quits: snadon (chatzilla@moz-3BC727E8.mc.videotron.ca) (Client exited)
[23:29:33] *** Joins: snadon (chatzilla@moz-3BC727E8.mc.videotron.ca)
[23:29:47] *** Joins: lucian (lucian@moz-22A14C6A.cable.virginmedia.com)
[23:30:02] *** Quits: MrFahrenheit (RageOfThou@3FEF494C.29C984D5.783DEDCA.IP) (Ping timeout)
[23:30:43] *** Quits: rusti (rusti@moz-54F7FD49.cpe.net.cable.rogers.com) (Ping timeout)
[23:30:55] *** Quits: strcat (strcat@moz-54F7FD49.cpe.net.cable.rogers.com) (Ping timeout)
[23:31:06] *** Quits: mye (mye@moz-2FADFF39.dip0.t-ipconnect.de) (Quit: mye)
[23:31:33] *** Quits: lucian (lucian@moz-22A14C6A.cable.virginmedia.com) (Ping timeout)
[23:32:01] * Thiez parameterizes some parameters over bblum.
[23:32:17] <bblum> talk to me baby
[23:33:06] <Thiez> parameterizing by self mode looks nice
[23:33:13] *** Joins: Ralith (ralith@moz-127CEE5F.wireless.sfu.ca)
[23:34:34] <tikue> lol
[23:35:14] <graydon> brendanc: thanks
[23:35:30] <graydon> brendanc: not sure if it's "fixed" but have applied that patch, reset db, lowered limits
[23:35:33] <graydon> we'll see how it goes
[23:35:57] <brendanc> error rate for buildbot seems a lot better than it used to be :)
[23:36:19] <graydon> yeah
[23:37:41] <graydon> we should really bring it up to 0.8.7
[23:37:47] <graydon> *cough* I should
[23:37:55] <sully> ok, hm, I understand this vtable code less than I thought I did
[23:37:56] <sully> it appears
[23:38:01] <bblum> Thiez: my guess is that parameterizing over self mode is not theoretically difficult but would take a zillion years to refactor code in the compiler for
[23:38:18] <sully> also, I think I am going to fail to get around to my triage bugs this week :(
[23:38:25] <sully> so doubling up next week, I guess
[23:39:19] *** Joins: steven_is_false (user@moz-144077DE.bchsia.telus.net)
[23:40:17] *** Joins: int3_ (int3_@moz-ABE52D50.hsd1.ca.comcast.net)
[23:41:16] <Thiez> bblum: probably likewise for values
[23:41:42] <Thiez> being generic over [T * N] would be nice
[23:42:48] <steven_is_false> Cloning Arc variables is expensive. Would it make sense to have a LocalArcRef value that is less expensive to clone but can't be send across tasks, or would that be too much micromanagement?
[23:43:24] <bblum> Thiez: um, parameterizing types over values is known to be undecidable ;)
[23:43:38] <Thiez> how disappointing.
[23:43:45] <bblum> i know, right
[23:43:55] <bblum> some limited forms are ok
[23:43:56] <Thiez> like, we can't decide just how awesome it would be
[23:44:00] <bblum> wat
[23:44:05] <Thiez> undecidable :p
[23:44:19] <bblum> you have an interesting interpretation of what that word means.
[23:44:31] <graydon> brson: when I put #[cfg(test)] extern mod extra; in std.rs, the resulting testrunner segfaults in iter_crate_map during runtime startup..
[23:44:39] <Thiez> As I recall there is a nice example on the internet where a C++ program parses only when some number is prime.
[23:44:51] <Thiez> I'm thinking we should avoid that situation
[23:44:59] <bblum> steven_is_false: cloning arc handles is supposed to avoid expensive. it is just one atomic xadd.
[23:45:09] *** Quits: tikue (tkuehn@moz-BBE3ABD.mv.mozilla.com) (Quit: tikue)
[23:45:27] <olsonjeffery> brson: so about expanding the Timer api.. i assume something we'd want would be a wait-and-run-callback type thing.. do we want to support that?
[23:45:39] <steven_is_false> bblum: That's what I thought. I was just double checking though.
[23:45:44] <olsonjeffery> i almost feel like, in the Brave New World of newsched.. sleep() is the base primitive..
[23:45:55] <bblum> steven_is_false: you can see the implementation for yourself in unstable/sync.rs
[23:46:06] <olsonjeffery> someone want a setTimeout() type functionality would spawn a new scheduler/thread and do the sleep, there
[23:46:11] <steven_is_false> I should actually get a benchmark, and test out my idea, and be all scientific.
[23:46:16] <eevee> http://stackoverflow.com/a/14589567/17875  said example.  this is hilarious
[23:46:18] <olsonjeffery> someone who wants a setTimeout(), even
[23:47:00] *** Joins: strcat (strcat@moz-54F7FD49.cpe.net.cable.rogers.com)
[23:47:36] *** Joins: rusti (rusti@moz-54F7FD49.cpe.net.cable.rogers.com)
[23:49:17] <brson> graydon: interesting. std.rs will already contain an 'extern mod extra', injected by the rustc test code. maybe that has something to do with it?
[23:49:44] <brson> i think ... it's been a long time since i've looked at that code
[23:50:10] <brson> oh, that's not true ...
[23:50:19] <graydon> brson: hard to say. other crates I build with extern mod extra (redundantly) work
[23:51:43] <brson> graydon: investigating
[23:51:52] <graydon> I'll poke around a few other spots
[23:52:08] <graydon> brson: don't let this distract from you working on newsched stuff, that's more important
[23:52:12] <graydon> was just wondering if it rang any bells
[23:53:02] <acrichto_> graydon: I ran into a similar error recently, and I fixed it with https://github.com/mozilla/rust/pull/7874/files#L2L71
[23:53:06] <brson> olsonjeffery: i'm not sure. that would basically be the same as { timer.sleep(); f() } i think, which seems kind of trivial
[23:53:26] <acrichto_> graydon: not sure if it's the same problem though
[23:53:28] <olsonjeffery> yeah, that's what im saying..
[23:53:49] <graydon> acrichto_: did that land yet?
[23:53:53] <brson> graydon: i can't reproduce your crash
[23:54:03] <acrichto_> graydon: oh checking now it looks like all the tests passed but bors never merged it...
[23:54:05] *** Joins: fread2282 (Mibbit@moz-C66177A6.nat.asu.edu)
[23:54:08] <olsonjeffery> brson: so i got my stuff building, based on the changes i made to the PR.. but rustc still segfaults with RUST_NEWRT=1 .. :/
[23:54:13] <brson> graydon: i.e. i can #[cfg(test) extern mod extra in stdtest
[23:54:13] *** Quits: fread2282 (Mibbit@moz-C66177A6.nat.asu.edu) (Quit: http://www.mibbit.com ajax IRC Client)
[23:54:25] *** Joins: fread2282 (Mibbit@moz-C66177A6.nat.asu.edu)
[23:54:28] <graydon> brson: and it builds through a runnable stdtest?
[23:54:36] <graydon> (runnable)
[23:54:40] <olsonjeffery> and Timer.sleep() works! huzzah.
[23:54:46] <graydon> olsonjeffery: \o/
[23:54:58] <brson> graydon: yes, though i'm building stdtest by hand. maybe there's some other build step that doesn't work? trying
[23:55:21] <graydon> brson: weird. lemme remove the uses of it I put in str.rs and see if those triggered the fault
[23:55:58] <ecr> olsonjeffery! woo!
[23:56:02] *** Joins: pcwalton (pcwalton@moz-BBE3ABD.mv.mozilla.com)
[23:56:02] *** ChanServ sets mode: +o pcwalton
[23:56:52] *** Joins: ross (ross@moz-8A84103E.br.br.cox.net)
[23:56:54] <brson> olsonjeffery: interesting, my rustc works with RUST_NEWRT here :-/ do you have a backtrace?
[23:57:20] *** Quits: sigma (sigma@CB3F6051.C886FCFF.DF0EE696.IP) (Quit: Leaving.)
[23:57:27] <graydon> nope, still crashes
[23:58:04] <brson> graydon: do you have a branch i can try?
[23:58:09] <bblum> strcat: unzip?
[23:58:12] <brson> olsonjeffery: r+ed your timer. thanks
[23:58:37] <bblum> oh it's just a vec function
[23:59:18] <brson> ecr: have you put any thought yet into making I/O threadsafe? as far as I know it doesn't yet guarantee that i/o happens on the correct scheduler
[23:59:26] <mark_edward> strcat: how often is the Rust arch repo updated?

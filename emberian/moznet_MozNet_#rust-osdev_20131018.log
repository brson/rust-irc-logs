[17:04:44] *** Joins: cmr (moznet@moz-EC676DFE.members.linode.com)
[17:04:48] * cmr waves
[17:07:26] <Leo`> hello cmr 
[17:07:48] <cmr> My OS project that I swear I'll get back to eventually: https://github.com/cmr/cmoss
[17:08:27] *** Joins: kido (kido@moz-40572DAF.w92-150.abo.wanadoo.fr)
[17:10:11] <Leo`> \o/ KokaKiwi 
[17:10:14] <Leo`> fu
[17:10:16] <Leo`> \o/ kido 
[17:10:31] <kido> :)
[17:10:35] <Leo`> cmr: looks nice. you can add it to the wiki page
[17:11:23] *** Joins: canhtak (jeremy@moz-44A7DE0.wl.t.ulaval.ca)
[17:11:43] <Leo`> (kido is a very nice person I was doing OS dev with in C :D)
[17:12:44] <kido> not so nice, I often bite, and even worst, I've got no rust skills
[17:13:47] <Leo`> for the moment :)
[17:19:43] <Seldaek> kido: don't worry I know nothing of OS dev and I'm here anyway 
[17:19:51] <kido> :)
[17:23:21] <Leo`> fu
[17:23:24] <Leo`> KokaKiwi: 
[17:23:37] <Leo`> the test compiles and runs just fine on your server xD
[17:24:03] <Leo`> I really don't understand why it didn't work in Bors
[17:24:53] <Leo`> fffff why isn't strcat here ? ._.
[17:26:57] *** Joins: eddyb9 (eddy@3C6E2DBB.FFB4E060.A5830293.IP)
[17:29:54] <eddyb9> dbaupp: from what I've seen, custom linkage should be easy, if not trivial. I have to fiddle with attrs though
[17:33:21] *** Quits: rveach (kvirc@moz-7E54B3A2.hsd1.ca.comcast.net) (Ping timeout)
[17:34:40] <KokaKiwi> Leo`: That's weird yeah x)
[17:35:48] <eddyb9> dbaupp: I think I even have a test for it: same extern fn with code and without code. calling the version without code should cause a call to the version with code
[17:36:15] <eddyb9> dbaupp: so, rust-core has extern malloc/free, I should be able to implement those in Rust
[17:38:20] <eddyb9> I really want to nuke C and asm from rustic ASAP
[17:39:07] <Luqman> eddyb9: i'd imagine there'd be at least some assembly
[17:39:48] <eddyb9> Luqman: inline, for things like loading the GDT, the IDT, and port IO
[17:40:41] <Leo`> for Quasar, i have to keep some assembly for the boot part since i want to be x86_64 only
[17:40:45] <cmr> The reason I have my loader separate from the kernel is that I tried to link it all into one elf binary, and the loader is 16bit
[17:40:57] <cmr> The kernel is amd64 only
[17:41:02] <Leo`> it's booted by Grub 2
[17:41:18] <Leo`> Grub 2 is able to load a ELF64 binary, but not to go to long mode
[17:41:18] <Luqman> Leo`: need to make it EFI bootable :P
[17:41:33] <Leo`> so I have to keep a 32-bit assembly stub that goes to long mod
[17:41:37] <Leo`> btw eddyb9 
[17:41:43] <Leo`> you can't do IDT only in Rust 
[17:41:59] <Leo`> because an IDT handler need to use the iretq instruction to return
[17:42:06] <eddyb9> hmpf
[17:42:08] <Leo`> I don't think you can do that with Rust functions
[17:42:16] <cmr> asm!("iretq") ?
[17:42:19] <eddyb9> can't you inline asm it?
[17:42:31] <eddyb9> Leo`: pcmattman is working on that, though
[17:42:40] <eddyb9> I'm trying to clean after him
[17:42:55] <Leo`> eddyb9: if you inline it, you "bypass" all the return code the compiler generates for you
[17:42:56] <cmr> How are ya'll dealing with the morestack problem?
[17:43:05] <Leo`> like restoring stack pointer, etc.
[17:43:14] <Leo`> it's quite dangerous
[17:43:47] <Leo`> cmr: just a stub in my assembly loader
[17:43:53] <Leo`> __morestack: 
[17:43:55] <Leo`> ret
[17:44:02] <cmr> Leo`: What about the prelude that checks the stack size?
[17:44:04] <Leo`> before I find time to take a detailed look at it
[17:44:11] <eddyb9> cmr: apparently there's an attribute to get rid of the prelude
[17:44:15] <cmr> eddyb9: which?
[17:44:15] <Leo`> and find a cleaner way
[17:44:23] <Leo`> cmr: #[no_stack_split], iirc
[17:44:28] <Leo`> but I don't use it
[17:44:47] <Leo`> for now, my functions must be simple eought so that there are no stack problems
[17:44:54] <Leo`> enough*
[17:44:57] <cmr> no_split_stack
[17:45:03] <Leo`> yeah
[17:45:13] <cmr> Ok, that's nice.
[17:45:41] <Leo`> well
[17:45:44] <cmr> Not really ideal
[17:45:52] <cmr> I still want to make the whole situation better
[17:46:02] <eddyb9> cmr: I think I'll have it for the code path from boot::x86::multiboot::start till GDT is setup and there's a fake TLS
[17:46:48] <eddyb9> cmr: pcmattman suggested providing a function (like a lang item) to get the stack limit
[17:47:22] <Leo`> erfm. I should return to my PR and try to fix the failing test
[17:47:29] <Leo`> but I don't understand at all what's going on
[17:47:34] <eddyb9> in a kernel, you'd make it return the stack limit, instead of putting it in a fake TLS
[17:47:57] <eddyb9> cmr: the problem is that it's entirely a LLVM feature :(
[17:48:04] <cmr> Yeah
[17:48:08] <cmr> I don't think that's a good solution.
[17:48:15] <eddyb9> cmr: why?
[17:48:29] <eddyb9> you get stack checking, but the way you want it
[17:49:13] <cmr> Because you need stack to call the function to check if you have enough stack
[17:49:35] <cmr> Also puts pressure on LLVM to inline things.
[17:49:49] <cmr> Needs to be specific per ABI and platform, which gets messy.
[17:50:13] <eddyb9> pffft
[17:50:56] <eddyb9> I'd like a #[no_stack]
[17:51:13] <eddyb9> so it's forced to registers
[17:51:15] <cmr> Once I have some time, I have a big blog post to write about mixed runtimes and soforth.
[18:09:31] *** Joins: rusti (rusti@moz-54F7FD49.cpe.net.cable.rogers.com)
[18:10:20] *** Joins: strcat (strcat@moz-54F7FD49.cpe.net.cable.rogers.com)
[18:11:01] *** Quits: strcat (strcat@moz-54F7FD49.cpe.net.cable.rogers.com) (Quit: WeeChat 0.4.2)
[18:11:05] *** Joins: strcat (strcat@moz-54F7FD49.cpe.net.cable.rogers.com)
[18:11:32] <eddyb9> sweet :D
[18:12:13] <eddyb9> strcat: did I get to tell you about my compromise: provide a module that only users with macros enabled will load?
[18:12:29] <strcat> rusti: 2
[18:12:29] -rusti- 2
[18:12:37] <strcat> eddyb9: no, you didn't tell me yet
[18:13:03] <Leo`> hey strcat 
[18:14:26] <eddyb9> strcat: if I add a linkage attribute, I'll be able to implement malloc/free/realloc for your "libc" mode, in Rust
[18:14:43] <eddyb9> but I'd rather use a macro to set it up
[18:15:02] *** Joins: acrichto (acrichto@moz-69F2E428.ugrad.cs.cmu.edu)
[18:15:08] <Leo`> hey acrichto 
[18:15:11] <acrichto> hello!
[18:15:19] <Leo`> welcome here o/
[18:16:50] <eddyb9> strcat: and traits to allow allocators to optionally provide special functions, like the jemalloc API
[18:19:41] *** Joins: thewonderidiot (mstewart@moz-E41129BA.ipnetworksinc.net)
[18:24:14] <eddyb9> hmm, is there some kind of linter that would allow me to restrict unsafe code to certain parts of the kernel?
[18:25:03] <cmr> not really
[18:25:04] <acrichto> eddyb9: right now no, but I think there's an issue about that
[18:25:13] <acrichto> #[allow(unsafe)]
[18:25:16] <cmr> The hypothetical post-1.0 effect system woudlallow that
[18:25:23] <acrichto> also it'd be awesome to require libraries with #[deny(unsafe)]
[18:25:51] <eddyb9> arch-specific initialization can use inline asm in unsafe blocks, same for arch-specific asm for IO
[18:26:32] *** Joins: geoffhill (geoffhill@moz-244CF33A.amazon.com)
[18:26:34] <eddyb9> the allocator and memory management (including MMIO regions) can read/write unsafe pointers
[18:26:56] <eddyb9> everything else has to be sparkling clean. not even a damned transmute
[18:27:12] <eddyb9> cmr: effect system?
[18:28:01] <cmr> https://github.com/mozilla/rust/wiki/Proposal-for-effects
[18:28:23] <eddyb9> oh, that reminds me: accessing &'static mut should be unsafe, not taking a reference to a static mut (so the unsafe operation is localized to the read/write operation on a static mut)
[18:30:09] *** Joins: hoelzro (hoelzro@moz-937642A5.ro)
[18:32:12] <Leo`> acrichto: i've got a weird issue with the test case you asked me to add in my PR :( (https://github.com/mozilla/rust/pull/9909)
[18:32:32] <Leo`> it compiles successfully on my OS X, and even on an Arch Linux, but fails with Bors
[18:32:44] <acrichto> Leo`: did you compile it with a 32-bit build?
[18:32:53] <Leo`> no
[18:33:03] <Leo`> I don't have a 32 bit Linux box to test
[18:33:05] <Leo`> :/
[18:33:22] <acrichto> you can use a 64-bit workspace, you just need a cross compiler
[18:33:26] <cmr> Leo`: cross compiling!
[18:33:26] <eddyb9> you can build 32bit on 64bit
[18:33:28] <acrichto> if you can build on 64-bit arch you can bulid 32-bit
[18:33:40] <acrichto> Leo`: look at the configure logs for that build to see the ./configure parameters
[18:33:42] <eddyb9> *without* a crosscompiler
[18:33:59] <Leo`> mh yeah
[18:34:23] <Leo`> the error is quite strange
[18:34:25] <Leo`> it says LLVM ERROR: expected relocatable expression
[18:34:30] <eddyb9> it just needs to know what target it's building for, x86_64 compilers can usually do both
[18:34:44] <eddyb9> Leo`: oh, I might know what that is. more info?
[18:35:33] <Leo`> eddyb9: https://github.com/mozilla/rust/pull/9909/files
[18:35:35] <eddyb9> Leo`: can you try rustc with a 32bit -target argument, on your OSX?
[18:35:36] <Leo`> it's the third file
[18:35:42] <Leo`> yup
[18:35:50] <eddyb9> and it works?
[18:36:03] <Leo`> do I need to builda 32 bit Rustc, or is my 64 bit Rustc fine with the good argument ?
[18:36:04] *** Joins: rveach (kvirc@moz-7E54B3A2.hsd1.ca.comcast.net)
[18:36:19] <eddyb9> Leo`: the latter. that's how we build rustic
[18:36:51] <Leo`> ...
[18:36:57] <Leo`> of course it can't find std
[18:37:25] <Leo`> okay
[18:37:28] <Leo`> it produces the bug
[18:37:36] <eddyb9> :)
[18:37:50] <Leo`> but orks with a u32
[18:37:57] <eddyb9> sorry I did pay attention earlier. what caught my eye is "relocation"
[18:38:28] <Leo`> wtf, doesn't llvm know how to cast a 32-bit ptr to a 64 bit integer... ? u_u
[18:38:34] <Leo`> eddyb9: you mean didn't ?
[18:38:37] <eddyb9> you probably make it place a relocation of a size/shape that doesn't exist for the target
[18:38:44] <Leo`> haaana
[18:38:46] <Leo`> -a
[18:38:52] <Leo`> u64 doesn't exist for 32 bit targets ?...
[18:39:03] <eddyb9> Leo`: yeah, on the phone, I miss letters :P
[18:39:09] <Leo`> np :D
[18:39:14] <eddyb9> the 64 bit relocation doesn't exit
[18:39:19] <eddyb9> *exist
[18:39:21] <Leo`> relocation ?
[18:39:31] <eddyb9> see? that's the big clue
[18:39:58] <eddyb9> is how it stores "I want this symbol's address to be put into this cell when the symbol address is known"
[18:40:05] <eddyb9> you have a 64bit cell
[18:40:11] <Leo`> yeah
[18:40:35] <eddyb9> there's no 64bit allocation in 32 bit elf/mach-o
[18:40:42] <eddyb9> *relocation
[18:41:07] <Leo`> but... using a 64-bit constant, it works ._.
[18:41:17] <Leo`> I mean, like static a:u 64 = 0xAAAAAAAAAAAAAAAA;
[18:41:24] <Leo`> a: u64 *
[18:41:27] <eddyb9> that's not a relocation
[18:41:32] <Leo`> oh
[18:41:34] <Leo`> ok
[18:41:36] <Leo`> I see
[18:41:44] <Leo`> it declares 2 u32
[18:41:48] <Leo`> or something like that
[18:41:56] <eddyb9> LLVM probably needs to use a 32bit relocation and cast to u64
[18:42:04] <Leo`> mhhhh
[18:42:07] <Leo`> okay...
[18:42:15] <eddyb9> but the relocations are the last step, they can happen at runtime for shared libraries
[18:42:21] <Leo`> Rustc should provide a better error message but eh
[18:42:29] <Leo`> yup
[18:42:33] <Leo`> of course
[18:42:45] <Leo`> so... in fact all I need to do is a #[cfg] thing
[18:42:53] <Leo`> that tests the word size...
[18:42:59] <eddyb9> so LLVM can't cast. it could half the u64 zeroed
[18:43:46] <eddyb9> Leo`: try to get ll from the 32bit failing compile with --emit-llvm -S -o fail.ll
[18:45:35] <eddyb9> I'm curious how it defines the static, and who's fault it is
[18:45:57] <eddyb9> this might be a LLVM bug/annoyance
[18:46:29] <Leo`> internal constant i64 ptrtoint (void ({ i32, %tydesc*, i8*, i8*, i8 }*)* @_ZN3foo19hdfe04c475c624d9fad4v0.0E to i64)
[18:46:29] <eddyb9> (I'm curious if it handles the basic addition relocation)
[18:47:57] <eddyb9> hmm
[18:48:10] *** Joins: mib_b7ypjy (Mibbit@829B7B25.32D367C3.64FAF8EC.IP)
[18:48:32] <eddyb9> Leo`: it's an unhandled case in LLVM, it could do better
[18:48:49] *** Quits: mib_b7ypjy (Mibbit@829B7B25.32D367C3.64FAF8EC.IP) (Quit: http://www.mibbit.com ajax IRC Client)
[18:49:01] <eddyb9> (set top half to zero, use relocation for bottom half)
[18:49:32] <Leo`> okay so this is not Rustc's fault ?
[18:49:54] <eddyb9> though i64 is ambiguous, since you can't just set half to 0 for signed upcasing
[18:50:02] <eddyb9> Leo`: nope
[18:50:40] <eddyb9> Leo`: I'd ask a LLVM dev to be sure
[18:51:08] <Leo`> okay
[18:51:26] <Leo`> yeah
[18:52:13] *** Joins: brson (brson@moz-BBE3ABD.mv.mozilla.com)
[18:53:13] <eddyb9> cmr: trustme(wont(Fail)) I feel like it's begging for a joke
[18:53:45] <Leo`> so I'm just going to add a #[cfg] directive and everythign will be ok... ><
[18:54:03] <Leo`> everything*
[18:54:46] <eddyb9> almost everything
[18:54:55] <eddyb9> Leo`: does cast + constant work?
[18:55:09] <eddyb9> (it should. other operations might not)
[18:55:11] <Leo`> eddyb9: ?
[18:55:39] <eddyb9> foo as uint + 10
[18:55:45] <Leo`> mhhhh
[18:55:56] <eddyb9> Leo`: oh, btw, no cfg required, uint is uintptr_t
[18:55:57] <Leo`> with u64 ?
[18:56:18] <Leo`> ok kay
[18:56:20] <Leo`> oh*
[18:56:23] <Leo`> okay*
[18:56:26] <eddyb9> no, with the native pointer size. which is uint :P
[18:56:27] <Leo`> (I mispell every word ><)
[18:56:45] <Leo`> well it works
[18:57:15] <eddyb9> that's pretty cool
[18:57:37] <eddyb9> a constexpr fully evaluated by a dynamic linker
[18:58:07] <Leo`> huh
[18:58:09] <Leo`> wait
[18:58:11] <Leo`> no
[18:58:13] <eddyb9> take that, C++14
[18:58:14] <Leo`> I didn't tried with the add
[18:58:16] <Leo`> wait
[18:58:19] <eddyb9> hehe
[18:58:30] * eddyb9 gets enthusiastic too fast
[18:58:38] <Leo`> well
[18:58:41] <Leo`> It works anyway 
[18:58:44] <eddyb9> :P
[18:58:54] <Leo`> @_ZN1a19h59e85fa3b943ff69ag4v0.0E = internal constant i32 add (i32 ptrtoint (void ({ i32, %tydesc*, i8*, i8*, i8 }*)* @_ZN3foo19hdfe04c475c624d9fad4v0.0E to i32), i32 10)
[18:59:19] <eddyb9> now, something like div, left shift, etc. shouldn't work
[18:59:31] <Leo`> suppose so
[18:59:42] <eddyb9> (don't just emit llvm, compile)
[18:59:43] <Leo`> well
[19:00:05] <Leo`> [1]    27241 segmentation fault  ./x86_64-apple-darwin/stage2/bin/rustc --target i386-apple-darwin test.rs  -c
[19:00:07] <Leo`> mhhhhh
[19:00:20] <Leo`> but add works ><
[19:00:21] <strcat> I guess we can't implement it that way
[19:00:26] <Leo`> (that was a div :D)
[19:00:59] <eddyb9> wait, a div crashes the compiler?
[19:01:21] <eddyb9> Leo`: your PR should work, but you found a compiler bug
[19:01:24] <Leo`> crashes llvm in fact
[19:01:30] <Leo`> emitting llvm works fine
[19:01:37] <Leo`> but assembling fails
[19:01:40] <Leo`> @_ZN1a19h59e85fa3b943ff69ag4v0.0E = internal constant i32 udiv (i32 ptrtoint (void ({ i32, %tydesc*, i8*, i8*, i8 }*)* @_ZN3foo19hdfe04c475c624d9fad4v0.0E to i32), i32 10)
[19:01:49] <eddyb9> well, yeah, LLVM bug
[19:02:01] <eddyb9> Leo`: gj
[19:06:33] *** Quits: canhtak (jeremy@moz-44A7DE0.wl.t.ulaval.ca) (Quit: canhtak)
[19:12:30] <Leo`> eddyb9: what's your Github username ? so I can credit you in my comment under the PR : p
[19:12:33] <Leo`> :p *
[19:12:43] <eddyb9> Leo`: eddyb
[19:13:45] <eddyb9> the 9 is because I'm on my N900
[19:13:49] <Leo`> :)
[19:13:52] <Leo`> ok
[19:34:34] <eddyb9> cmr: ooh, I can use effects to make Rust understand the multi-thread/multi-processor safe design of my allocator
[19:35:47] <eddyb9> cmr: alternatively, writes/reads to a static mut are unsafe, unless atomic (but how do you prove the atomic operations are safe when combined?)
[19:47:35] *** Joins: canhtak (jeremy@moz-44A7DE0.wl.t.ulaval.ca)
[19:51:04] *** Joins: kmc (keegan@moz-2C6EE959.compute-1.amazonaws.com)
[19:53:49] *** Joins: devbug (quassel@2D4E172D.4C8B6099.9B57EA59.IP)
[19:53:56] <devbug> So, this is rather interesting
[19:57:34] <Leo`> :)
[19:57:39] <Leo`> hello devbug 
[19:57:46] <devbug> Leo`: hello
[19:57:59] <devbug> Great minds think alike, it seems... I hope.
[19:58:41] <Leo`> hehe
[19:58:45] <devbug> Has anyone figured out an elegant way to handle multiboot in pure Rust?
[19:58:57] <Leo`> Pure Rust ? mh
[19:59:06] <devbug> I'm currently resorting to a C-shim
[19:59:06] <Leo`> it doesn't seem very hard
[19:59:15] <devbug> Leo`: parsing modules, and such
[19:59:22] <Leo`> in my case it's not possible
[19:59:39] <Leo`> since i'm doing a 64-bit only kernel, and Grub leaves the CPU in 32-bit mode
[19:59:57] <devbug> Leo`: just create a 32-bit elf and "chain load"
[19:59:59] <devbug> https://github.com/mtwilliams/iron/blob/master/include/multiboot.h#L161
[20:00:01] <Leo`> I need an assembly stub that goes to 64 bits etc.
[20:00:04] <devbug> God damn unions, man.
[20:00:13] <Leo`> yeah :(
[20:00:31] <Leo`> currently, I've got everything into a single 64 bits binary
[20:00:33] <Leo`> ELF
[20:00:40] <eddyb9> devbug: rustic will have no C and asm code (which we currently need for bootstraping Rust weirdness)
[20:00:40] <Leo`> but a part of it is in Assembly
[20:00:42] <Leo`> however
[20:00:51] <Leo`> If I manage to do it in Rust-only
[20:00:52] <devbug> eddyb9: :)
[20:00:55] <Leo`> I'll let you know
[20:01:24] <eddyb9> like, the split stacks. we found a little too late about the attribute that does what we wanted
[20:01:25] <devbug> Leo`: great.
[20:01:36] <devbug> eddyb9: about split stacks
[20:01:44] <devbug> Anyone got documentation on __morestack?
[20:01:55] <devbug> I assume LLVM has documeted it somewhere
[20:01:56] <Leo`> hehe
[20:02:07] <eddyb9> devbug: read the implementation in rt
[20:02:09] <Leo`> I think it's the more recurrent topic on this channel today xD
[20:02:21] <devbug> eddyb9: thanks
[20:04:27] <devbug> So, anyone microkerneling?
[20:04:37] <devbug> Even exokerneling?
[20:06:14] <Leo`> devbug: I think i'm going toward microkernel
[20:06:18] <Leo`> but I'm far from it :p
[20:06:36] <devbug> Leo`: heh
[20:06:42] <devbug> I'm working on a microkernel
[20:07:26] <devbug> I might call it a picokernel, because it's really small.  So small infact, that I don't even have a GDT yet
[20:08:02] <devbug> "instead of returning, it then calls into the original function, resuming execution at the instruction following the call to __morestack."
[20:08:30] <devbug> Welp.
[20:10:07] <eddyb9> devbug: it wraps the rest of the function in another stack
[20:10:27] <eddyb9> devbug: you don't actually need it, you can abort when you run out of stack
[20:11:45] <devbug> eddyb9: mhm.  It is a dirty trick, however clever.
[20:38:33] *** Joins: Ke (jkarlson@moz-785A3407.org.aalto.fi)
[20:39:54] *** Joins: c74d (c74d@moz-E2EAC718.oc.oc.cox.net)
[20:40:42] *** Quits: eddyb9 (eddy@3C6E2DBB.FFB4E060.A5830293.IP) (Ping timeout)
[20:41:12] *** Joins: eddyb9 (eddy@3C6E2DBB.FFB4E060.A5830293.IP)
[20:49:51] *** Joins: Earnestly (earnest@moz-BE290A2B.dyn.plus.net)
[21:02:30] *** Quits: brson (brson@moz-BBE3ABD.mv.mozilla.com) (Ping timeout)
[21:05:00] *** Joins: brson (brson@moz-BBE3ABD.mv.mozilla.com)
[22:07:45] *** Quits: devbug (quassel@2D4E172D.4C8B6099.9B57EA59.IP) (Ping timeout)
[22:41:15] *** Quits: kido (kido@moz-40572DAF.w92-150.abo.wanadoo.fr) (Quit: @+)
[23:14:02] *** Quits: thewonderidiot (mstewart@moz-E41129BA.ipnetworksinc.net) (Quit: Leaving.)
[23:15:51] *** Quits: canhtak (jeremy@moz-44A7DE0.wl.t.ulaval.ca) (Quit: canhtak)
[23:43:01] *** Joins: devbug (quassel@23AC5F12.9D950176.3655BBF5.IP)
[23:57:58] <pcmattman> .....
[23:58:11] <pcmattman> wow, llvm is nice
[23:58:40] <pcmattman> it figured out a particular function is only ever called with one constant parameter and so emitted machine code for the function for that constant only

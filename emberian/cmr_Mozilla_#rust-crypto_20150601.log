[00:00:25] <bascule> o11c: yes, that
[00:01:01] <bascule> "Okay, the difference between ECC and RSA is that RSA is so simple that it can be incompetently implemented, and ECC is so complex that it can be incompetently implemented."
[00:32:19] <Tobba> ECC is easy to implement though
[00:32:25] <Tobba> it's hard to make fast but the math is easy
[01:02:46] <Ilari> The "20th century ECC" stuff isn't easy to implement. "21st century ECC" is.
[01:02:51] <eternaleye> bascule: My favorite response to "RSA is teh awsum" folks is "Call me back when you have something that fits inside the minimum MTU ipv4 guarantees."
[01:03:43] <eternaleye> Or even ipv6
[01:04:07] <eternaleye> (576 and 1280, respectively)
[01:04:07] <bascule> hahahaha
[01:04:26] <bascule> I made the argument about DNSSEC amplification attacks
[01:04:31] <eternaleye> Well, ipv4 is absurd, as its minimum _path_ MTU is 68
[01:04:42] <eternaleye> But a host must accept 576-byte messages
[01:04:56] <bascule> but I'm arguing with people who I am guessing don't do massively scalable TLS termination or have to deal with getting DDoSed as part of their day-to-day
[01:07:55] <Ilari> Also, tokbind apparently has plans to put obsolete insecure crap to new standard because of backward compatiblity...
[01:08:21] <bascule> Ilari: o_O
[01:08:22] <bascule> wat?
[01:08:26] <bascule> what obsolete insecure crap?
[01:10:51] <eternaleye> Ilari: Waitwait, lemme guess: PKCS#1v1.5?
[01:10:59] *** Joins: esclear_ (esclear@moz-7hlp7k.dip0.t-ipconnect.de)
[01:11:08] <Ilari> eternaleye: Yeah.
[01:11:08] <eternaleye> Ilari: Because that excuse sounds REALLY FUCKING FAMILIAR from WebCrypto
[01:11:39] <eternaleye> What the hell is with people and their boner for v1.5?
[01:13:30] <Ilari> Something about hardware not supporting PSS or something.
[01:13:31] *** Quits: esclear (esclear@moz-rsqfao.dip0.t-ipconnect.de) (Ping timeout: 121 seconds)
[01:16:28] <eternaleye> ...in *WebCrypto*?
[01:16:43] <Ilari> In Tokbind.
[01:16:52] <eternaleye> Yes, but they used the same excuse
[01:17:03] <eternaleye> of back-compat
[01:17:07] <eternaleye> In a *new thing*
[01:17:12] <bascule> haha oh god...
[01:17:13] * eternaleye stabs
[01:17:22] <Ilari> "this is due to hardware limitations: most (if not all) TPMs only support PKCS. And storing TB keys in a TPM is probably a security win, even if it involves PKCS."
[01:17:24] <bascule> why are they using RSA?!#$# o_O
[01:17:40] <bascule> fuck TPMs
[01:18:35] <Ilari> I think that if you are in position to dump keys from software-only implementation that isn't total garbage, you are very likely in position to do serious damage even if the keys are in "hardware" and unextractable.
[01:18:45] <bascule> yep
[01:19:00] *** Joins: dpc (dpc@moz-t6gr4b.ca.comcast.net)
[01:19:02] <bascule> I'd rather have either 1) Intel SGX or 2) a Yubikey than a TPM
[01:19:18] <Ilari> (Just abuse the hell out of those keys, no need to extract them).
[01:19:36] <eternaleye> bascule: TPM 2.0 is a hell of a lot better, IMO
[01:19:41] <eternaleye> bascule: Still not great, but better
[01:20:02] <bascule> a Yubikey gives you portability of your crypto keys between devices
[01:20:31] <bascule> and implements standards I care about, like U2F
[01:20:34] <eternaleye> bascule: Sure. So does keeping a copy of the original on a disk in a safe, and importing it into the TPM on provision.
[01:20:42] <eternaleye> bascule: http://en.wikipedia.org/wiki/Trusted_Platform_Module#TPM_1.2_vs_TPM_2.0
[01:20:56] <bascule> eternaleye: so with a Yubikey, you take the Yubikey out and put it in another device
[01:21:05] <bascule> with a TPM, you... go to the safe? lol (that's not how I'd do it anyway)
[01:21:12] <bascule> all our systems are set up for credential agility
[01:21:23] <bascule> which was nice during the Yubipocalypse
[01:21:29] <eternaleye> bascule: Hooking your yubikey to an untrusted device is asking for UI spoofing anyway
[01:21:44] <eternaleye> bascule: I mean on device provisioning, under the "I own this device" model
[01:21:45] <bascule> it isn't an untrusted device
[01:21:52] <bascule> it'd be getting a new laptop at work
[01:21:56] <bascule> something I'm planning on doing
[01:22:01] <bascule> it's not even BYOD
[01:22:22] <eternaleye> Sure. Import the key, and when work asks for it back, wipe the key.
[01:22:25] <bascule> we don't do BYOD
[01:22:42] <bascule> I'm... not sure what you're talking about, heh
[01:23:37] <eternaleye> bascule: You can seal keys under the TPM's authority, to load at runtime.
[01:23:54] <eternaleye> bascule: That ties them to the device securely, without requiring you get the disc again.
[01:23:58] <bascule> eternaleye: If I were doing that, I'd probably just deprovision and reprovision all credentials per-person
[01:24:13] <bascule> we use a safe, but it's not something I'd ever want to access to solve the "I lost my laptop" problem
[01:24:37] <bascule> we try to push the management of this stuff onto IT as much as possible
[01:24:49] <eternaleye> Mm
[01:25:50] <bascule> now if only there were a safe way to clone token-to-token
[01:25:57] <bascule> I'd love that
[01:26:19] <bascule> e.g. enter an admin pin into the source token, and put it in a "pairing mode"
[01:26:32] <bascule> tap destination token to source token, they exchange keys
[01:26:46] <bascule> source token dumps all of its keys, encrypted to the destination token
[01:42:17] <Tobba> bascule: I'd rather have anything where my keys aren't in escrow than a TPM
[01:42:52] <Ilari> I disagree that storing TB keys in HW module is a securty win if it involves bad crypto algorithms.
[01:43:14] *** Joins: skeuomorf (skeuomorf@moz-a8h.ni9.32.197.IP)
[01:44:23] <bascule> Ilari: Yuikeys can do, uhh, ECDSA, lol...
[01:46:04] <Tobba> bascule: I tried to find something on intel SGX
[01:46:16] <Tobba> most of it is gibberish
[01:47:26] <bascule> heh yeah :|
[01:47:34] <Tobba> actually, the extension doesn't seem to make sense at all.
[01:47:48] <Tobba> it provides... code execution that's automagically untamperable
[01:47:57] <Tobba> that's both nearly entirely useless and impossible
[01:48:03] <bascule> it isn't "automagically" untamperable
[01:48:11] <bascule> you have to get the CPU's public key
[01:48:26] <bascule> then the CPU will at least attest what code it loaded into an encrypted enclave
[01:48:38] <bascule> and the enclaves are enumerable by the kernel
[01:49:02] <Tobba> most sources I find say the kernel can't tamper with it, which means that the CPU does context switching
[01:49:15] <Tobba> and it somehow enforces memory restrictions on PCI devices
[01:49:47] <Ilari> Well, modern CPUs have IOMMUs, which can enforce memory restrictions on PCI devices.
[01:49:55] *** Quits: mcpherrin (mcpherrin@moz-fl0kt2.ca.comcast.net) (Ping timeout: 121 seconds)
[01:50:26] <bascule> Tobba: the kernel has some powers over it
[01:50:32] <bascule> Tobba: it knows it exists, and it can shut it down
[01:50:45] *** Joins: c74d3 (c74d3a4ebb6@moz-l85t2q.mggc.hibn.4404.2002.IP)
[01:51:10] <bascule> what I haven't seen a clear description of is how SGX enclaves can interact with memory outside the enclave
[01:51:20] <Tobba> well yeah
[01:51:28] <Ilari> And I think kernel can swap those in and out (in encrypted form).
[01:51:32] <bascule> I know it's possible because Microsoft VC3 is clearly doing that
[01:51:45] <Tobba> and it'd have to communicate a lot of state to the chipset to prevent PCI writes
[01:51:48] <Tobba> it seems hilariously unenforcable
[01:51:56] <bascule> Tobba: it's enforced through cryptography?
[01:52:12] <bascule> the memory is encrypted using a hardware key known only to the CPU
[01:52:16] <Tobba> so it authenticates every cache line?
[01:52:17] <Ilari> Tobba: I think SGX has dedicated memory.
[01:52:21] *** Quits: c74d (c74d3a4ebb6@moz-0ersgu.oc.cox.net) (Ping timeout: 121 seconds)
[01:52:29] <Tobba> even more fun
[01:52:31] *** c74d3 is now known as c74d
[01:52:38] <bascule> Tobba: I don't know about ciphertext malleability attacks
[01:52:46] <bascule> the descriptions I've read have been quite handwavy
[01:52:58] <Tobba> yeah I'm not really buying this
[01:52:58] <Ilari> Well, there are authentication tags for the encryption.
[01:53:08] <Tobba> even if it had dedicated memory I can just list endless ways to get past this
[01:53:29] <bascule> Tobba: the memory is dedicated and anything that ever exits or reenters the CPU is ciphertext, and Ilari says it's authenticated, so...
[01:54:09] <bascule> where TrustZone fell down was interactions between the insecure and trusted worlds
[01:54:19] <bascule> TrustZone had to manually lock and unlock memory
[01:54:21] <Tobba> and the giant side-channel of everything goes... somewhere
[01:54:41] <bascule> and while TrustZone only runs one thread, the OS can be running many on the shared memory
[01:54:42] <Tobba> it should be pretty easy to trace execution
[01:54:59] <bascule> Tobba: I am sure there are sidechannels galore in SGX
[01:55:16] <Ilari> Also, even hypervisor can't read the plaintext. It can lock/unlock pages and then swap encrypted data in/out.
[01:55:26] <bascule> yeah
[01:55:28] <Tobba> you can set up the CPU to interrupt on every opcode easily, and there are hundreds/thusands of statistics registers to play with
[01:55:35] <Ilari> Tobba: Performance counters are disabled in SGX mode.
[01:55:43] <bascule> Tobba: SGX strikes me as being something quite similar to PrivateCore vCage, but in hardware...
[01:55:49] <Tobba> Ilari: still
[01:55:57] <Tobba> they can't have thought of everything
[01:56:20] <bascule> where vCage was implemented at the hypervisor level
[01:56:27] <bascule> SGX just moves it into the CPU
[01:56:30] <Tobba> Ilari: other fun ideas: various hooks SMM can use
[01:56:34] *** Quits: c74d (c74d3a4ebb6@moz-l85t2q.mggc.hibn.4404.2002.IP) (Connection closed)
[01:56:51] <Ilari> Tobba: AFAIK, SMM can't do anything with SGX.
[01:56:51] *** Joins: c74d (c74d3a4ebb6@moz-gadv8g.mggc.hibn.4404.2002.IP)
[01:56:56] <bascule> Tobba: I'm sure there will be SGX bugs
[01:56:59] <Tobba> you simply *cant* protect against some things since you actually want things to be fast
[01:57:12] <Tobba> Ilari: not *manipulate* it
[01:57:21] <bascule> Tobba: every system that tries to do anything remotely like this has fallen down
[01:57:26] <bascule> at least once
[01:57:31] <bascule> but then you fix it and move on, heh
[01:57:55] <Tobba> I'd say it's quite possible, but not on x86
[01:57:56] <bascule> this is a fun one: https://www.blackhat.com/docs/us-14/materials/us-14-Rosenberg-Reflections-On-Trusting-TrustZone-WP.pdf
[01:58:06] <bascule> Tobba: ARM isn't much better, lol
[01:58:14] <Tobba> x86 is simply too complicated to do it on
[01:59:18] <bascule> Tobba: I think you're overlooking something huge
[01:59:25] <bascule> which is that even if Intel gets it right
[01:59:25] <Tobba> it's 4AM, of course I am
[01:59:51] <bascule> all it takes is one teensy mistake to get RCE into one of these enclaves
[01:59:52] <bascule> :o
[02:00:01] <Tobba> well yeah
[02:00:10] <bascule> even if the CPU attests it booted clean code, people are going to break in
[02:00:15] <Tobba> Rust!
[02:00:15] <bascule> and you're none the wiser
[02:00:19] <bascule> Rust to the rescue! lol
[02:00:21] <bascule> or something
[02:00:38] <bascule> VC3 uses C++
[02:00:43] <Tobba> I'd like to see it on an architecture where an engineer could actually list all the CPU state
[02:01:15] <Ilari> Yup, even SGX system functions (intended for OS kernels) fault if executed in SMM.
[02:01:19] <Tobba> x86 literally has thousands of registers (mostly MSRs) that can be mutated
[02:04:00] <Tobba> and this is ignoring the fact that apparently intel can't even get a P1 clone right
[02:05:11] <Tobba> P1 die shrink*
[02:06:40] <eternaleye> Tobba: RISC-V to save the world! :P
[02:06:45] <Tobba> Mill!
[02:07:14] <Tobba> (A Mill implementation of this would probably have even more side channels considering all the crazy stuff done in HW)
[02:07:49] <eternaleye> I'm honestly not super-impressed by the Mill, though part of that is probably a reflexive "This looks too different for me to expect good results from current compilers"
[02:08:09] <eternaleye> Although I've seen mails that imply e.g. LLVM really can't handle the Mill model
[02:08:19] <eternaleye> Partially due to non-integer pointers
[02:08:20] <Tobba> I just want to see a VLIW succeed
[02:08:55] <Tobba> they're pretty much superior in every way other that you can't get a compiler to write code worth shit for them
[02:09:12] <eternaleye> Tobba: Sadly, that's kind of a deal-breaker...
[02:09:17] <bascule> lololololololol
[02:09:28] <eternaleye> Tobba: Because the whole point of VLIW is "The compiler can do better than the CPU"
[02:09:57] <Tobba> eternaleye: no shit, other than some other impressive (supposed) feats of the mill is that the compiler doesn't need information it doesn't have to generate the code
[02:10:01] <eternaleye> Tobba: Hell, even GPUs have been ditching VLIW, after using it for *years*
[02:10:07] <Tobba> which was the problem with other VLIW cores
[02:10:19] <eternaleye> See also: AMD's GCN
[02:11:07] <Tobba> so it's more like "The programmer can do it better than the CPU"
[02:12:51] <eternaleye> Tobba: Sure. The thing is, the Mill relies on a Sufficiently Advanced Compiler, and then the LLVM mailing list contains messages from members of the Mill team (and replies) that show that it isn't really a model LLVM can handle well, and they didn't actually look at the compilers much.
[02:13:12] <Tobba> yeeaah
[02:13:28] <Tobba> I'm just hoping they get it right
[02:13:41] <eternaleye> Tobba: Look for the ml thread on non-integer pointers, IIRC
[02:14:12] <eternaleye> Tobba: The Mill team made a bunch of assumptions of "Of course compilers can handle this" and got a bit of a surprise.
[02:14:36] <Tobba> heh
[02:14:49] *** Quits: gsingh93 (gulshan@moz-ln1ktu.st3l.iv8o.0004.2601.IP) (Ping timeout: 121 seconds)
[02:15:08] <eternaleye> RISC-V, on the other hand, already has a working (competitive!) GCC port, LLVM port, and Linux port
[02:15:23] <eternaleye> The last despite the privileged spec being in flux
[02:15:25] *** Quits: dpc (dpc@moz-t6gr4b.ca.comcast.net) (Ping timeout: 121 seconds)
[02:15:52] <eternaleye> Arnd Bergmann even looked over it, and said that once the spec stabilizes, it looks pretty much ready-to-merge
[02:16:11] <Ilari> Apparently SGX enclaves can R/W their host address space (but not X it)?
[02:16:34] <Tobba> Ilari: that's gonna make for so many security holes involving the enclaves trusting the kernel too much
[02:16:38] <Tobba> I don't even think rust can save them here
[02:17:12] <eternaleye> I wonder how that'll handle faulting...
[02:17:24] <Tobba> destroy_universe()
[02:17:27] <eternaleye> That was one of the problems that really bit the original L4's long-ipc in the ass
[02:17:33] <eternaleye> And why modern L4's rip it out
[02:17:56] <Tobba> hm?
[02:18:20] <eternaleye> Tobba: It's in the paper "From L3 to seL4"
[02:18:31] <Ilari> Tobba: Kernel supposedly can't do anything to enclave-internal memory (other than DoS things).
[02:18:36] <eternaleye> Tobba: Which is a retrospective of L4 variants over design choices
[02:19:06] <Tobba> Ilari: well yeah, but at some point someones gonna end up trusting a pointer returned from the kernel
[02:19:08] <Tobba> and then things go bad
[02:19:23] <eternaleye> Tobba: http://flint.cs.yale.edu/cs428/doc/L3toseL4.pdf
[02:19:56] <Tobba> this should be a fun read
[02:20:29] <bascule> this is cool: https://eprint.iacr.org/2009/095.pdf
[02:20:33] <bascule> privacy-preserving attestation
[02:21:06] <Ilari> Tobba: You can't call kernel from SGX. Any instruction that can change privilege level gives #UD.
[02:21:57] <Tobba> Ilari: still gotta get data in somehow
[02:22:39] <Tobba> how do you get entropy in there? I guess rdrand will work
[02:22:40] <Ilari> Tobba: But assuming R/W access to host memory space, on can still screw it up: E.g. run Ed25519 on buffer in host process memory space...
[02:22:58] <Ilari> Tobba: Yeah, RDRAND and RDSEED work.
[02:27:01] <Ilari> (The right way is to copy the buffer into enclave space first and then run Ed25519 on it).
[02:27:32] <Tobba> which will kinda suck for perf
[02:29:04] <eternaleye> Ilari: Er, what about "run some_public_hash on the buffer, with state and output in enclave space, then run ed25519 in enclave space" ?
[02:30:08] <Tobba> eternaleye: what if the buffer changes after the hash is run?
[02:31:41] <eternaleye> Tobba: No, I mean ed25519 on the hash value
[02:31:54] <eternaleye> Tobba: Which is how most real-world message sigs work anyway
[02:32:02] <Ilari> eternaleye: That works (if some_public_hash is CR)
[02:32:16] <eternaleye> Ilari: If it's not, it's not much good...
[02:38:06] <Ilari> And yeah, if enclave gets RCE'd, bad things happen...
[02:50:00] *** Quits: skeuomorf (skeuomorf@moz-a8h.ni9.32.197.IP) (Ping timeout: 121 seconds)
[03:04:45] <bascule> Tobba: TrustZone uses "locking" for that... I haven't seen what SGX does
[03:05:03] <bascule> instead of copying, the trusted part locks the untrusted part, and then that memory becomes invisibile to the untrusted part until unlocked
[03:06:53] *** Joins: skeuomorf (skeuomorf@moz-a8h.ni9.32.197.IP)
[03:08:20] <bascule> Tobba: what I really dislike about TrustZone is it's a ginormous separate kernel
[03:08:29] <bascule> with millions of lines of attack surface
[03:08:38] <bascule> (depending on which implementation you're talking about)
[03:08:42] <bascule> SGX is all userspace code
[03:09:05] <bascule> and guess what, RCE on the TrustZone kernel has happened
[03:13:13] <bascule> so at least with SGX you can theoretically write all of the code in the enclave in something like Rust
[03:13:32] <bascule> and you don't have to worry about getting popped by some bug in some crazy "secure" kernel
[03:17:52] <eternaleye> bascule: So SGX is more like the way a function capability in CHERI works, so to speak?
[03:18:20] <eternaleye> bascule: You have some code that is loaded sealed, and you can call it and get a return value, but you can't really look at it?
[03:18:53] <eternaleye> (Capability Hardware Enhanced RISC Instruction-set, IIRC)
[03:19:22] <eternaleye> Based on MIPS, it's a full hardware-based capability system
[03:19:24] <eternaleye> Pretty shiny
[03:19:38] <eternaleye> One guy from there said they're looking at a RISC-V variant
[04:00:35] *** Joins: dpc (dpc@moz-t6gr4b.ca.comcast.net)
[04:00:48] *** Joins: gsingh93 (gulshan@moz-ln1ktu.st3l.iv8o.0004.2601.IP)
[04:34:49] *** Quits: gsingh93 (gulshan@moz-ln1ktu.st3l.iv8o.0004.2601.IP) (Ping timeout: 121 seconds)
[04:53:06] *** Quits: skeuomorf (skeuomorf@moz-a8h.ni9.32.197.IP) (Ping timeout: 121 seconds)
[04:53:47] *** Joins: irobevjodu (ident@moz-5bq.k90.254.5.IP)
[05:07:02] *** Joins: skeuomorf (skeuomorf@moz-a8h.ni9.32.197.IP)
[05:42:46] *** Quits: Tobba (Tobba@moz-o13d22.bredband.telia.com) (Ping timeout: 121 seconds)
[05:51:00] *** Quits: c74d (c74d3a4ebb6@moz-gadv8g.mggc.hibn.4404.2002.IP) (Connection closed)
[05:51:08] *** Joins: c74d (c74d3a4ebb6@moz-0ersgu.oc.cox.net)
[06:30:34] <Ilari> Lol: "My abstract for SPACE: 'Crypto is a thriving research area, full of excitement, which is exactly what the cryptographic user doesn't want.'" -- DJB
[06:47:38] *** Joins: Tobba (Tobba@moz-6oh.7ki.21.217.IP)
[07:39:49] *** Quits: Tobba (Tobba@moz-6oh.7ki.21.217.IP) (Ping timeout: 121 seconds)
[07:50:08] *** Joins: Tobba (Tobba@moz-6oh.7ki.21.217.IP)
[07:52:56] *** Quits: skeuomorf (skeuomorf@moz-a8h.ni9.32.197.IP) (Ping timeout: 121 seconds)
[07:58:14] *** Quits: dpc (dpc@moz-t6gr4b.ca.comcast.net) (Ping timeout: 121 seconds)
[08:11:28] *** Joins: acharles (acharles@moz-ulbdcn.ca.comcast.net)
[08:34:59] *** Quits: irobevjodu (ident@moz-5bq.k90.254.5.IP) (Ping timeout: 121 seconds)
[09:09:01] *** Joins: eddyb_ (eddyb@moz-9ak.sgj.26.188.IP)
[09:11:48] *** Quits: eddyb (eddyb@moz-ure.pug.25.188.IP) (Ping timeout: 121 seconds)
[09:23:06] *** Joins: gleb (gleb@moz-3u1drv.rusanovka-net.kiev.ua)
[09:40:08] *** Quits: Tobba (Tobba@moz-6oh.7ki.21.217.IP) (Ping timeout: 121 seconds)
[09:53:23] *** Joins: irobevjodu (ident@moz-3vi4l0.static-ro.twistednetworks.net)
[10:20:08] *** Joins: Tobba (Tobba@moz-6oh.7ki.21.217.IP)
[10:42:30] *** Quits: Tobba (Tobba@moz-6oh.7ki.21.217.IP) (Ping timeout: 121 seconds)
[11:18:25] *** Joins: Tobba (Tobba@moz-6oh.7ki.21.217.IP)
[11:19:55] <Ilari> Sheesh... Hit that 32 element array clone limit in quite nasty way. I'm trying to work around lack of dependent associated constants by defining structs Array1<T>, Array2<T>, ..., Except those arrays are supposed to be Copy, and so Clone, but when one gets to Array33<T>, the Clone on arrray is missing, and coherence does not let one implement that.
[12:05:24] *** Quits: Tobba (Tobba@moz-6oh.7ki.21.217.IP) (Ping timeout: 121 seconds)
[12:08:41] *** Joins: Tobba (Tobba@moz-6oh.7ki.21.217.IP)
[12:09:34] *** eddyb_ is now known as eddyb
[12:22:40] *** Quits: Tobba (Tobba@moz-6oh.7ki.21.217.IP) (Ping timeout: 121 seconds)
[12:24:37] *** Joins: Tobba (Tobba@moz-6oh.7ki.21.217.IP)
[12:59:00] *** Quits: Tobba (Tobba@moz-6oh.7ki.21.217.IP) (Ping timeout: 121 seconds)
[13:45:59] <Ilari> bascule: Sigh, doesn't look like one can properly write ECC code in Rust right now...
[14:10:09] *** Joins: Tobba (Tobba@moz-o13d22.bredband.telia.com)
[15:44:10] *** Joins: gsingh93 (gulshan@moz-qnbukr.mi.comcast.net)
[15:52:18] <Tiffany> BLAKE is neat
[15:55:08] <bascule> Ilari: why?
[16:02:28] <Tiffany> oh
[16:02:37] <Ilari> Or maybe there is a way around that Clone problem...
[16:03:05] <Tiffany> reusing nonces with stream ciphers is a lot worse than I thought
[16:03:21] <Tiffany> if you can chosen plaintext a message full of zeros, you can just xor it with any message you like and get the plaintext back...
[16:03:59] <Tiffany> or if you have a known plaintext
[16:08:35] <bascule> Tiffany: yep
[16:09:00] <Tiffany> I wonder how many applications are using stream ciphers with bad nonces
[16:14:24] *** Joins: skeuomorf (skeuomorf@moz-a8h.ni9.32.197.IP)
[16:15:04] <Ilari> Also reminds me of one "homecooked" encryption mode I recently saw...
[16:15:39] <Tobba> Tiffany: also fun things: feeding encrypted data back through the encryptor with the same nonce
[16:15:45] <Ilari> (Surprisingly just slow, maybe broken, but not horribly so).
[16:16:04] <Tiffany> yeah...
[16:16:13] <Tiffany> "double chacha must be twice as secure!"
[16:16:16] *** Quits: gleb (gleb@moz-3u1drv.rusanovka-net.kiev.ua) (Ping timeout: 121 seconds)
[16:18:07] <Ilari> Also, 1024 bit DH (with very probably already-broken-by-NSA group) for speed reasons.
[16:20:17] <Tiffany> how does GCM work?
[16:20:29] <Tiffany> the authentication part, in paritcular
[16:21:38] <Ilari> Tiffany: Map the message (and AD) into polynomial, evaluate it at secret point and add per-message secret. All computed in GF(2^128).
[16:22:24] <Tiffany> it can reject forged messages without having to decrypt them, right?
[16:22:49] <Tiffany> hm
[16:22:54] <Ilari> Tiffany: The per-message secret is obtained by doing E_k(nonce|0), where nonce is 96 bits.
[16:22:59] <Tiffany> isn't that similar to how poly1305 works?
[16:23:41] <Ilari> Tiffany: Yes, it can check without decrypting. And yes, the principle is similar, but the fields used are different (Poly1305 uses GF(2^130-5).
[16:24:05] <Tiffany> ah
[16:24:27] <Ilari> Tiffany: Binary fields GF(2^n) are more efficient in hardware. Prime fields GF(p) are more efficient in software.
[16:27:00] <Ilari> Tiffany: Then there are prime powers GF(p^n), but about nothing uses those for anything.
[16:27:43] *** Quits: skeuomorf (skeuomorf@moz-a8h.ni9.32.197.IP) (Ping timeout: 121 seconds)
[16:30:45] <Ilari> The possible numbers of elements in field: 2, 3, 4, 5, 7, 8, 9, 11, 13, 16, 17, 19, 23, 25, 27, 29, 31, 32, 37, 41, 43, 47, 49, 53, 59, 61, 64, 67, 71, 73, 79, 81, 83, 89, 97, 101, 103, 107, 109, 113, 121, 125, 127, 128, 131, 137, 139, 149, 151, 157, 163, 167, 169, 173, 179, 181, 191, 193, 197, 199, 211, 223, 227, ...
[16:31:50] <Ilari> And for each of these, there is only one field (up to renaming of elements).
[17:04:59] *** Joins: brson (brson@moz-cfhap5.mtv2.mozilla.com)
[17:05:47] *** Joins: dpc (dpc@moz-t6gr4b.ca.comcast.net)
[18:49:05] *** Joins: eddyb_ (eddyb@moz-e8s.ur8.27.188.IP)
[18:49:11] *** Quits: dpc (dpc@moz-t6gr4b.ca.comcast.net) (Ping timeout: 121 seconds)
[18:51:52] *** Quits: eddyb (eddyb@moz-9ak.sgj.26.188.IP) (Ping timeout: 121 seconds)
[18:54:18] *** eddyb_ is now known as eddyb
[19:28:45] *** Joins: skeuomorf (skeuomorf@moz-a8h.ni9.32.197.IP)
[19:43:52] *** Joins: dpc (dpc@moz-t6gr4b.ca.comcast.net)
[19:54:38] *** Quits: taryn (taryn@moz-g8toaq.vmsplic.me) (Ping timeout: 121 seconds)
[19:55:28] *** Joins: taryn (taryn@moz-32j57o.jdpb.6cej.6400.2605.IP)
[19:59:30] *** Quits: taryn (taryn@moz-32j57o.jdpb.6cej.6400.2605.IP) (Ping timeout: 121 seconds)
[20:00:18] *** Joins: taryn (taryn@moz-g8toaq.vmsplic.me)
[20:09:27] *** Quits: dpc (dpc@moz-t6gr4b.ca.comcast.net) (Connection closed)
[20:11:35] *** Joins: dpc (dpc@moz-t6gr4b.ca.comcast.net)
[20:35:41] *** Quits: dpc (dpc@moz-t6gr4b.ca.comcast.net) (Ping timeout: 121 seconds)
[20:56:24] *** Joins: dpc (dpc@moz-t6gr4b.ca.comcast.net)
[21:14:45] *** Quits: irobevjodu (ident@moz-3vi4l0.static-ro.twistednetworks.net) (Connection closed)
[21:51:34] *** Joins: irobevjodu (ident@moz-5bq.k90.254.5.IP)
[22:17:01] <Ilari> And also, u128 type on 64-bit would sure be useful for ECC...
[22:58:24] *** Quits: dpc (dpc@moz-t6gr4b.ca.comcast.net) (Ping timeout: 121 seconds)
[23:58:33] *** Quits: eddyb (eddyb@moz-e8s.ur8.27.188.IP) (Ping timeout: 121 seconds)

[00:00:08] *** Quits: bjz (bjz@B398BE78.F804C29E.D35A31DF.IP) (Quit: ZZZzzz…)
[00:00:08] *** Quits: maxiepoo (Max@moz-6F50ADE.hsd1.il.comcast.net) (Quit: maxiepoo)
[00:00:55] *** Quits: canhtak (canhtak@moz-14E3CE16.wl.t.ulaval.ca) (Ping timeout)
[00:01:45] *** Joins: canhtak (canhtak@moz-14E3CE16.wl.t.ulaval.ca)
[00:01:58] *** Quits: willingc (willingc@moz-B4760708.san.res.rr.com) (Client exited)
[00:02:18] *** Joins: willingc (willingc@moz-B4760708.san.res.rr.com)
[00:02:41] *** Joins: maxiepoo (Max@moz-6F50ADE.hsd1.il.comcast.net)
[00:03:07] *** Quits: nkoep (nik@moz-17B4884B.pool.mediaways.net) (Quit: Leaving)
[00:03:13] *** Quits: ozten (ozten@moz-DD3B00B4.hsd1.wa.comcast.net) (Quit: ozten)
[00:03:18] *** Quits: huseby (huseby@moz-4E8C421A.husebyhome.com) (Quit: Leaving)
[00:03:31] *** Joins: maik (maik@moz-BDF2085A.dip0.t-ipconnect.de)
[00:03:58] *** Quits: willingc (willingc@moz-B4760708.san.res.rr.com) (Ping timeout)
[00:04:35] *** Joins: skeet70 (skeet70@moz-697F48F2.bzm-mt.client.bresnan.net)
[00:04:39] *** Joins: bjz (bjz@B398BE78.F804C29E.D35A31DF.IP)
[00:07:03] *** Parts: thewonderidiot (mstewart@moz-E41129BA.ipnetworksinc.net) ()
[00:10:19] *** Quits: CarpNet (Alasdair@moz-25C796BC.cable.virginm.net) (Connection reset by peer)
[00:11:20] <pcwalton> what's the most elegant way to flatten a list of pairs into two lists?
[00:12:23] *** Joins: Jesin (Jessin_@moz-9BB5F6CF.cc.lehigh.edu)
[00:13:00] <brson> pcwalton: vec::unzip maybe
[00:13:34] *** Joins: huseby (huseby@moz-4E8C421A.husebyhome.com)
[00:13:56] <pcwalton> brson: righto
[00:14:01] <pcwalton> thanks
[00:15:02] *** Quits: Jesin (Jessin_@moz-9BB5F6CF.cc.lehigh.edu) (Ping timeout)
[00:15:02] *** Joins: Jessin (Jessin_@moz-9BB5F6CF.cc.lehigh.edu)
[00:15:09] *** Joins: Pac (textual@moz-7E76649.emobile.ad.jp)
[00:17:49] <mletterle> "In Rust we don't like capital letters."  <-- Brilliant.
[00:18:10] <enix> I'm getting an ICE and I can't find an issue for it. Does anyone know if there is an existing issue: https://gist.github.com/DaGenix/7273937 ?
[00:19:03] *** Quits: jgilbert (jgilbert@moz-BBE3ABD.mv.mozilla.com) (Ping timeout)
[00:21:03] <acrichto> enix: I don't think that there's currently a workaround for that, but I believe that #10153 will fix it
[00:21:11] <acrichto> (not verified, just guessing)
[00:21:28] <enix> ah, cool, thanks
[00:22:57] <sfackler> there is a bug that lifetime annotations require a borrowed pointer
[00:28:57] *** Quits: Pac (textual@moz-7E76649.emobile.ad.jp) (Ping timeout)
[00:29:51] *** Quits: skeet70 (skeet70@moz-697F48F2.bzm-mt.client.bresnan.net) (Quit: My MacBook Pro has gone to sleep. ZZZzzz…)
[00:30:54] *** Quits: mcarberry (mcarberry@moz-BE1C9F3F.lightspeed.frokca.sbcglobal.net) (Ping timeout)
[00:33:12] *** Quits: nejucomo (Adium@moz-A94CACD5.dsl.pltn13.sbcglobal.net) (Quit: Leaving.)
[00:34:14] *** Joins: mcarberry (mcarberry@moz-BE1C9F3F.lightspeed.frokca.sbcglobal.net)
[00:35:47] *** Quits: bjz (bjz@B398BE78.F804C29E.D35A31DF.IP) (Quit: ZZZzzz…)
[00:36:08] *** Quits: avsej (avsej@D9A610B8.4841F515.FB33447D.IP) (Client exited)
[00:37:16] *** Quits: eevee (eevee@moz-7B6C48E3.evrt.wa.frontiernet.net) (Ping timeout)
[00:37:26] *** Quits: maxiepoo (Max@moz-6F50ADE.hsd1.il.comcast.net) (Quit: maxiepoo)
[00:39:31] *** Joins: willingc (willingc@moz-B4760708.san.res.rr.com)
[00:40:31] *** Joins: nejucomo (Adium@moz-434492BB.dsl.static.sonic.net)
[00:40:31] *** Quits: samnardoni (Mibbit@FC9A45BE.3393236F.BFD1ABFD.IP) (Quit: http://www.mibbit.com ajax IRC Client)
[00:41:22] *** Joins: tautologico (lymph@703660AA.CFE755C8.C27E1635.IP)
[00:41:27] *** Joins: freezerburnv (freezerbur@moz-C5EF929C.washdc.fios.verizon.net)
[00:41:37] *** Joins: eevee (eevee@moz-7B6C48E3.evrt.wa.frontiernet.net)
[00:43:01] *** Quits: DAddYE (DAddYE@moz-61EB081B.hfc.comcastbusiness.net) (Client exited)
[00:43:38] *** Quits: eevee (eevee@moz-7B6C48E3.evrt.wa.frontiernet.net) (Ping timeout)
[00:46:17] *** Quits: gandalf (zbraniecki@moz-DFAA4E15.p2p.sfo1.mozilla.com) (Quit: My lid went down)
[00:46:23] *** Joins: kvark (Mibbit@moz-F30E0473.cpe.net.cable.rogers.com)
[00:46:57] <kvark> I've got an strace of my "can't find crate std" error. Please take a look: https://gist.github.com/kvark/7274154
[00:47:19] <kvark> I clearly see that libstd is found and opened, as well as other libs. It fails somewhere long after that.
[00:47:37] *** Joins: ktt3ja (Mibbit@moz-F40FE31.washdc.fios.verizon.net)
[00:47:56] *** Joins: eevee (eevee@moz-7B6C48E3.evrt.wa.frontiernet.net)
[00:47:57] *** Joins: mib_wyolf2 (Mibbit@B4104EBB.3CC170B1.1E14B209.IP)
[00:48:31] <mib_wyolf2> hi
[00:49:05] *** Quits: hjr3 (hradtke@1A0AE795.28A5F6C3.A2D40ED2.IP) (Quit: My MacBook has gone to sleep. ZZZzzz…)
[00:49:45] *** Joins: thewonderidiot (mike@moz-5506A033.hsd1.ca.comcast.net)
[00:49:51] <Luqman> kvark: no, the libstd it finds is the one the rustc itself is linked against
[00:49:55] *** Quits: engla (engla@moz-BFD53D48.selucle.dyn.perspektivbredband.net) (Ping timeout)
[00:50:09] <Luqman> it can't find the one the programs it compiles will link against
[00:50:37] <Luqman> which would be in somewhere like /usr/local/lib/rustc/x86_64-unknown-linux-gnu/lib/libstd-*.so
[00:50:52] <kvark> Luqman: thanks for looking into it! I guess I'll just relink then
[00:50:52] <Luqman> kvark: how did you install it?
[00:51:20] <kvark> I may have built some stuff before installing it
[00:51:31] *** Quits: nejucomo (Adium@moz-434492BB.dsl.static.sonic.net) (Quit: Leaving.)
[00:51:48] <kvark> and then installed by a standard "sudo make install"
[00:51:54] *** Quits: qwertie (Mibbit@moz-C23FC2A2.ptr.terago.net) (Quit: http://www.mibbit.com ajax IRC Client)
[00:51:59] <Luqman> kvark: is there anything in /usr/local/lib/rustc ?
[00:52:24] <kvark> yeah
[00:52:35] <kvark> Luqman: everything works now, thanks!
[00:54:10] *** Quits: gareth0 (gareth0@7B67FAFD.7B34A6AE.2653C6EC.IP) (Input/output error)
[00:55:40] *** Joins: nejucomo (Adium@moz-434492BB.dsl.static.sonic.net)
[00:56:14] *** Quits: dbaupp (Thunderbir@moz-B3C9E9E8.lns20.syd6.internode.on.net) (Ping timeout)
[00:56:31] *** Quits: nejucomo (Adium@moz-434492BB.dsl.static.sonic.net) (Quit: Leaving.)
[00:59:15] *** Joins: dbaupp (Thunderbir@moz-B3C9E9E8.lns20.syd6.internode.on.net)
[01:04:45] *** Quits: canhtak (canhtak@moz-14E3CE16.wl.t.ulaval.ca) (Quit: canhtak)
[01:04:48] *** Joins: mikezaby (mikezaby@moz-B26868E.home.otenet.gr)
[01:04:57] *** Parts: mikezaby (mikezaby@moz-B26868E.home.otenet.gr) ()
[01:06:08] *** Quits: lenstr (lenstr@AF8EB999.6049B16A.85938D85.IP) (Client exited)
[01:06:18] *** Quits: CyBeRKeL (cyber@E6A1FD6F.BE88DC8C.9C1C15C3.IP) (Ping timeout)
[01:06:19] *** sam113101_afk is now known as sam113101
[01:06:29] *** Joins: lenstr (lenstr@AF8EB999.6049B16A.85938D85.IP)
[01:07:30] *** Quits: voxpopuli (fanservice@moz-FE161659.wv.cc.cmu.edu) (Ping timeout)
[01:08:05] *** Joins: glennsl (textual@moz-6822C772.customer.cdi.no)
[01:08:13] *** Quits: lenstr (lenstr@AF8EB999.6049B16A.85938D85.IP) (Ping timeout)
[01:10:33] *** Joins: nomadic (nomadic@moz-E01D5C49.hsd1.ga.comcast.net)
[01:11:22] *** Joins: voxpopuli (fanservice@moz-FE161659.wv.cc.cmu.edu)
[01:11:36] *** Quits: Ralith (ralith@A8995AA9.62B6AF6A.922221DB.IP) (Ping timeout)
[01:15:06] <mletterle> It's Friday night.. time to recompile rust.
[01:15:38] *** Quits: maik (maik@moz-BDF2085A.dip0.t-ipconnect.de) (Ping timeout)
[01:16:00] *** Joins: notmatt (notmatt@moz-9FB2565E.vc.shawcable.net)
[01:17:45] *** Quits: dew (Instantbir@moz-E4452B8F.static.stls.mo.charter.com) (Ping timeout)
[01:17:49] *** Joins: dew (Instantbir@moz-E4452B8F.static.stls.mo.charter.com)
[01:17:50] *** Joins: bjz (bjz@B398BE78.F804C29E.D35A31DF.IP)
[01:18:20] *** Joins: canhtak (canhtak@moz-14E3CE16.wl.t.ulaval.ca)
[01:19:03] *** Quits: tiffany (kawaii@moz-28A8742A.dhcp.embarqhsd.net) (Ping timeout)
[01:23:33] *** Quits: gavinb (gavinb@moz-9EC182F0.lowrp3.vic.optusnet.com.au) (Quit: gavinb)
[01:23:51] *** Quits: james4k (james@moz-E7990244.consolidated.net) (Ping timeout)
[01:25:06] *** Joins: maxiepoo (Max@moz-6F50ADE.hsd1.il.comcast.net)
[01:26:33] *** Quits: maxiepoo (Max@moz-6F50ADE.hsd1.il.comcast.net) (Quit: maxiepoo)
[01:27:09] *** Joins: maxiepoo (Max@moz-6F50ADE.hsd1.il.comcast.net)
[01:28:28] *** Quits: maxiepoo (Max@moz-6F50ADE.hsd1.il.comcast.net) (Quit: maxiepoo)
[01:30:23] <kvark> did anyone use cgmath::rotation::Euler?
[01:30:24] *** Quits: ofeldt (ofeldt@moz-4D678086.dip0.t-ipconnect.de) (Ping timeout)
[01:30:40] <kvark> why did bjz decide to remove it?! X_x
[01:30:43] <bjz> kvark: did you?
[01:30:50] <kvark> you are here!
[01:31:06] <kvark> sure I did
[01:31:06] <bjz> come to rust-gamedev
[01:33:06] *** Quits: Jessin (Jessin_@moz-9BB5F6CF.cc.lehigh.edu) (Ping timeout)
[01:33:59] *** Joins: ofeldt (ofeldt@moz-4D678086.dip0.t-ipconnect.de)
[01:37:52] *** Joins: maxiepoo (Max@moz-6F50ADE.hsd1.il.comcast.net)
[01:40:14] *** Joins: Ralith (ralith@moz-132F2FD4.sea.wa.customer.broadstripe.net)
[01:43:08] *** Quits: donri (donri@moz-9BB61102.tbcn.telia.com) (Client exited)
[01:43:42] *** Joins: z0w0 (zack@moz-238C2341.lnse3.cha.bigpond.net.au)
[01:46:31] *** Quits: dherman (dherman@moz-6CA476B1.hsd1.ca.comcast.net) (Quit: dherman)
[01:47:14] *** Joins: Jesin (Jessin_@moz-9BB5F6CF.cc.lehigh.edu)
[01:48:58] *** Quits: maxiepoo (Max@moz-6F50ADE.hsd1.il.comcast.net) (Quit: maxiepoo)
[01:51:47] *** Joins: sankha93 (Instantbir@7061CD01.D6BD0D91.22D41759.IP)
[01:55:31] *** Quits: willingc (willingc@moz-B4760708.san.res.rr.com) (Client exited)
[01:55:52] *** Joins: willingc (willingc@moz-B4760708.san.res.rr.com)
[01:56:29] *** Quits: thewonderidiot (mike@moz-5506A033.hsd1.ca.comcast.net) (Connection reset by peer)
[01:57:26] *** Quits: cdelo (cdelo@31073680.31C0B4EF.D345515E.IP) (Client exited)
[01:57:33] *** Quits: willingc (willingc@moz-B4760708.san.res.rr.com) (Ping timeout)
[01:58:42] *** Quits: dbaupp (Thunderbir@moz-B3C9E9E8.lns20.syd6.internode.on.net) (Ping timeout)
[02:01:49] *** Joins: vadimcn (chatzilla@FB06B64.76F9E272.DA40C4B3.IP)
[02:01:50] *** Quits: devbug_ (quassel@23AC5F12.9D950176.3655BBF5.IP) (Ping timeout)
[02:02:39] *** Joins: dbaupp (Thunderbir@moz-7FBF750E.lns20.syd6.internode.on.net)
[02:02:57] *** Joins: jxv (jxv@moz-8FB92450.lightspeed.irvnca.sbcglobal.net)
[02:05:24] *** Quits: vadimcn (chatzilla@FB06B64.76F9E272.DA40C4B3.IP) (Quit: ChatZilla 0.9.90.1 [Firefox 24.0/20130910160258])
[02:06:59] *** Joins: lenstr (lenstr@AF8EB999.6049B16A.85938D85.IP)
[02:08:49] *** Quits: lenstr (lenstr@AF8EB999.6049B16A.85938D85.IP) (Ping timeout)
[02:13:04] <mletterle> is -Z trace broken?
[02:13:16] *** Joins: maxiepoo (Max@moz-6F50ADE.hsd1.il.comcast.net)
[02:13:28] *** Quits: btipling (btipling@moz-D51E0AEB.xen.prgmr.com) (Connection reset by peer)
[02:14:31] *** Quits: ofeldt (ofeldt@moz-4D678086.dip0.t-ipconnect.de) (Ping timeout)
[02:14:36] *** Joins: btipling (btipling@moz-D51E0AEB.xen.prgmr.com)
[02:15:34] <cmr> mletterle: it could be. what should it be doing?
[02:15:49] <dbaupp> mletterle: linking errors with "undefined reference to `upcall_trace'" etc?
[02:16:00] *** Joins: alisdair (textual@28441AAB.AC6E1995.F0AE27BD.IP)
[02:16:36] <mletterle> yar
[02:16:42] <mletterle> am I missing a library?
[02:16:51] <brson> i deleted upcall_trace recently
[02:16:53] *** Quits: heftig (heftig@moz-858AE1B9.dip0.t-ipconnect.de) (Ping timeout)
[02:16:55] <brson> i didn't even know what it did
[02:17:02] <mletterle> well there you go :)
[02:17:29] <brson> if it's valuable it should be converted to a lang item
[02:17:47] <dbaupp> what is it supposed to do? ("emit trace logs" isn't very informative.)
[02:17:59] <mletterle> yeah, no idea, was just playing..
[02:18:03] <cmr> heh
[02:18:26] <mletterle> I'm guessing it injects debug printing logs into your application? maybe with what line it's on? Just a wild guess
[02:18:33] *** Joins: ofeldt (ofeldt@moz-4D678086.dip0.t-ipconnect.de)
[02:20:01] <dbaupp> tracing allocations?
[02:20:03] * dbaupp shrugs
[02:20:18] *** Quits: sweet_kid_ (Upasana@93CB8004.98D8CFFD.1228A288.IP) (Quit: Leaving)
[02:20:44] <cmr> mletterle: that doesn't sound unreasonable, looking at it.
[02:20:59] <cmr> fn trans_trace in middle/trans/base.rs
[02:21:13] <mletterle> regardless.. sucks to have a broken option...
[02:21:15] *** Quits: nomadic (nomadic@moz-E01D5C49.hsd1.ga.comcast.net) (Quit: Leaving)
[02:21:21] <cmr> and trace_span!
[02:22:47] *** Joins: willingc (willingc@moz-B4760708.san.res.rr.com)
[02:23:51] *** Quits: ofeldt (ofeldt@moz-4D678086.dip0.t-ipconnect.de) (Ping timeout)
[02:24:00] *** Joins: nomadic (nomadic@moz-E01D5C49.hsd1.ga.comcast.net)
[02:24:03] *** Quits: boredomist (ruqs@8186917.CC8FA3EE.E3401B6E.IP) (Ping timeout)
[02:24:13] <mletterle> as an aside.. that -Z help is formatted weird... the repeated -Z seems.. unnecessary.
[02:25:02] *** Quits: voxpopuli (fanservice@moz-FE161659.wv.cc.cmu.edu) (Ping timeout)
[02:25:02] *** Quits: azakai (alon@moz-BBE3ABD.mv.mozilla.com) (Ping timeout)
[02:26:19] *** Joins: heftig (heftig@moz-74DC22BF.dip0.t-ipconnect.de)
[02:27:04] *** Joins: ofeldt (ofeldt@moz-4D678086.dip0.t-ipconnect.de)
[02:27:15] *** Joins: tautologico_ (shung@703660AA.CFE755C8.C27E1635.IP)
[02:28:28] *** Joins: lmandel (lmandel@moz-76CE9D51.cable.teksavvy.com)
[02:29:15] *** Joins: jmgrosen (jmgrosen@moz-848F6087.sb.sd.cox.net)
[02:29:20] *** Quits: glennsl (textual@moz-6822C772.customer.cdi.no) (Quit: My MacBook Pro has gone to sleep. ZZZzzz…)
[02:29:34] *** Joins: dherman (dherman@moz-6CA476B1.hsd1.ca.comcast.net)
[02:29:34] *** ChanServ sets mode: +ao dherman dherman
[02:30:36] *** Quits: brson (brson@moz-BBE3ABD.mv.mozilla.com) (Ping timeout)
[02:34:24] *** Quits: SiegeLord (sl@moz-CAF07B4C.hsd1.ma.comcast.net) (Quit: It's a joke, it's all a joke.)
[02:35:00] *** Joins: brson (brson@981AA104.E81F12CD.76F66111.IP)
[02:35:00] *** ChanServ sets mode: +ao brson brson
[02:35:46] *** Joins: mindcat (mindcat@905CA2D5.E97F21E0.431667FD.IP)
[02:36:37] *** Joins: SiegeLord (sl@moz-CAF07B4C.hsd1.ma.comcast.net)
[02:36:43] <mindcat> /home/mindcat/mydev/rust/nbt.rs:88:19: 88:25 error: macro undefined: 'format'
[02:36:44] <mindcat> /home/mindcat/mydev/rust/nbt.rs:88             debug!(format!("[NBT] Byte_Array length: {:?}", len));
[02:37:03] <mindcat> I got this problem, any idea?
[02:37:12] <dbaupp> mindcat: old version of rust
[02:37:56] <dbaupp> also, you can write `debug!("[NBT] Byte_Array length: {:?}", len);` directly, don't need the double-layer.
[02:38:40] <mindcat> dbaupp: oh, I didn't know this :)
[02:39:13] <mindcat> dbaupp: my rust is very new
[02:39:24] <cmr> mindcat: rustc --version ?
[02:39:26] <mletterle> if it's not HEAD, it's probably old
[02:39:45] <mindcat> rustc 0.9-pre (d04a58c 2013-10-31 17:51:26 -0700)
[02:39:59] <mletterle> uh.
[02:40:06] <dbaupp> oh, format! should exist...
[02:40:11] <mindcat> when print(format!("[NBT] Byte_Array length: {:?}", len)); is fine
[02:40:13] <cmr> mindcat: are you using no_std?
[02:40:27] <cmr> huh
[02:40:32] <mindcat> cmr: I did not set "#[no_std]
[02:40:36] <mindcat> "
[02:40:45] <cmr> rustic: debug!(format!("{}", 42))
[02:40:49] <cmr> erm... sorry rustic
[02:41:01] <mindcat> rusti: debug!(format!("{}", 42))
[02:41:09] <dbaupp> (you should be using `print!("[NBT] ...", len)` for that one, btw.)
[02:42:03] <dbaupp> the only time you need to be using format! is when you actually need a string. if you're printing then `print!`, `println!`, `debug!`, `info!` etc all take format strings. (even fail! and assert! do.)
[02:42:23] *** Quits: kvark (Mibbit@moz-F30E0473.cpe.net.cable.rogers.com) (Quit: http://www.mibbit.com ajax IRC Client)
[02:42:26] <mindcat> dbaupp: ok..
[02:42:32] <cmr> (they don't allocate)
[02:45:24] <ChrisMorgan> And if you're writing to a Writer, you also don't need to allocate a string for it: there's write!(&mut Writer, format: &str, ...)
[02:45:40] *** Quits: maxiepoo (Max@moz-6F50ADE.hsd1.il.comcast.net) (Quit: maxiepoo)
[02:47:13] <mindcat> ChrisMorgan: https://gist.github.com/mindcat/7274900
[02:47:19] <mindcat> ChrisMorgan: I am writing this
[02:48:10] <ChrisMorgan> mindcat: that should be fail!(...), not fail!(format!(...))
[02:49:17] *** Quits: sk (sk@61A494B3.BA40E8A.AAC02D62.IP) (Input/output error)
[02:49:55] <ChrisMorgan> mindcat: still, I don't see any "macro undefined: 'format'", nor should you. It suggests your Rust installation might be broken.
[02:50:02] <mindcat> so where are they going on? http://paste.ubuntu.com/6344772/
[02:50:26] <ChrisMorgan> They're default methods now. Remove the imports and see what happens.
[02:51:37] <ChrisMorgan> BTW, where you have things like `pub use std::rt::io::{Reader,Writer};`, you shouldn't have `pub` there. That would mean that you could import Reader et al. from this module, which is not, I think, what you intend.
[02:52:47] <mindcat> ChrisMorgan: ok...
[02:53:58] *** Joins: eternaleye (eternaleye@moz-5668AFCB.hsd1.wa.comcast.net)
[02:54:30] *** Quits: dherman (dherman@moz-6CA476B1.hsd1.ca.comcast.net) (Quit: dherman)
[02:55:57] *** jorendorff_away is now known as jorendorff
[02:56:57] <ChrisMorgan> mindcat: the read_*_ and write_*_ methods have had the trailing underscores removed, also
[02:57:13] *** Quits: maxli (maxli@moz-4D28BA20.student.cs.uwaterloo.ca) (Quit: Leaving.)
[02:58:29] *** Quits: tautologico_ (shung@703660AA.CFE755C8.C27E1635.IP) (Quit: tautologico_)
[02:58:50] *** Quits: jmgrosen (jmgrosen@moz-848F6087.sb.sd.cox.net) (Quit: jmgrosen)
[02:59:31] *** Quits: SilverKey (SilverKey@moz-B589DA51.sw.biz.rr.com) (Quit: My MacBook Pro has gone to sleep. ZZZzzz…)
[02:59:44] *** Quits: jxv (jxv@moz-8FB92450.lightspeed.irvnca.sbcglobal.net) (Ping timeout)
[03:01:07] <ChrisMorgan> mindcat: your impl<T> where the T is not used anywhere necessarily prevents the code from being able to be compiled.
[03:01:30] *** Joins: jmgrosen (jmgrosen@moz-848F6087.sb.sd.cox.net)
[03:01:45] *** Quits: jmgrosen (jmgrosen@moz-848F6087.sb.sd.cox.net) (Quit: jmgrosen)
[03:02:43] *** Joins: voxpopuli (fanservice@moz-CEF3689A.hsd1.pa.comcast.net)
[03:03:59] <ChrisMorgan> mindcat: for the `buf.buf` privacy problem (where buf is a MemWriter), import std::rt::io::Decorator and use buf.inner(). You'll also need to rejig it so that you're working with the MemWriter, not a &mut MemWriter, so that it can consume it.
[03:04:31] *** Quits: lmandel (lmandel@moz-76CE9D51.cable.teksavvy.com) (Quit: lmandel)
[03:05:01] <ChrisMorgan> (That is: `let mut buf = MemWriter::new();`, and change `buf_write_string(buf, name.clone());` to `buf_write_string(&mut buf, name.clone());` to compensate.)
[03:05:22] <ChrisMorgan> After those changes (including removing the <T>) it compiles for me.
[03:06:24] *** Quits: Earnestly (earnest@38FE72A5.82423D8F.BFD1ABFD.IP) (Ping timeout)
[03:07:49] *** Joins: lenstr (lenstr@AF8EB999.6049B16A.85938D85.IP)
[03:08:37] *** Quits: z0w0 (zack@moz-238C2341.lnse3.cha.bigpond.net.au) (Quit: z0w0)
[03:09:37] *** Quits: lenstr (lenstr@AF8EB999.6049B16A.85938D85.IP) (Ping timeout)
[03:13:17] *** Joins: jmgrosen (jmgrosen@moz-848F6087.sb.sd.cox.net)
[03:15:33] *** Joins: jxv (jxv@moz-8FB92450.lightspeed.irvnca.sbcglobal.net)
[03:16:54] *** Quits: exobit (foo@moz-90D1B547.nycmny.fios.verizon.net) (Quit: My MacBook Pro has gone to sleep. ZZZzzz…)
[03:17:52] <mletterle> nil == () == unit :/
[03:18:37] <cmr> mletterle: hm?
[03:18:48] <cmr> are you refering to the internal inconsistency in rustc/libsyntax?
[03:18:56] <mletterle> and in docs.
[03:19:24] <mletterle> seems like it would be something you'd want unified.
[03:19:38] *** Quits: mark_edward (quassel@moz-DCB0B750.lightspeed.cicril.sbcglobal.net) (Client exited)
[03:19:49] <cmr> The unit type, written (), has one value, unit, also written ()
[03:19:59] <cmr> nil is no longer used.
[03:20:27] <mletterle> ah, it's still mentioned everywhere.
[03:20:33] <cmr> unfortunate :(
[03:20:38] <mletterle> why not just have unit?
[03:20:44] <cmr> as a keyword/
[03:20:50] <mletterle> also, I assume unit is short for uninitialized? 
[03:20:52] <cmr> no
[03:20:59] <cmr> http://en.wikipedia.org/wiki/Unit_type
[03:21:02] <cmr> It's a 0-tuple
[03:21:09] <mletterle> ah
[03:21:11] <mletterle> *click*
[03:21:22] <cmr> Rust doesn't have uninitialzed values.
[03:21:54] <mletterle> sure, but the nil -> unit seemed like it was an historical thing or something *shrugs* so I shall banish nil from my vocabulary.
[03:22:27] *** Quits: willingc (willingc@moz-B4760708.san.res.rr.com) (Client exited)
[03:22:41] <cmr> yep
[03:22:48] *** Joins: willingc (willingc@moz-B4760708.san.res.rr.com)
[03:24:33] *** Quits: willingc (willingc@moz-B4760708.san.res.rr.com) (Ping timeout)
[03:24:42] *** Quits: brson (brson@981AA104.E81F12CD.76F66111.IP) (Quit: leaving)
[03:24:44] <mindcat> code: https://gist.github.com/mindcat/7274900 error: http://paste.ubuntu.com/6344885/
[03:24:55] <cmr> mindcat: read what ChrisMorgan wrote.
[03:25:19] <mindcat> cmr: reading now
[03:26:08] * ChrisMorgan occasionally tangles typing "unit" and "uint"
[03:26:35] *** Joins: lenstr (lenstr@AF8EB999.6049B16A.85938D85.IP)
[03:26:57] *** Quits: jxv (jxv@moz-8FB92450.lightspeed.irvnca.sbcglobal.net) (Quit: Leaving)
[03:27:11] *** Joins: z0w0 (zack@moz-238C2341.lnse3.cha.bigpond.net.au)
[03:28:01] *** Joins: maxli (maxli@moz-4D28BA20.student.cs.uwaterloo.ca)
[03:28:27] *** Quits: lenstr (lenstr@AF8EB999.6049B16A.85938D85.IP) (Ping timeout)
[03:29:32] *** Joins: mib_3rw2pm (Mibbit@B4104EBB.3CC170B1.1E14B209.IP)
[03:30:13] *** Quits: freezerburnv (freezerbur@moz-C5EF929C.washdc.fios.verizon.net) (Quit: freezerburnv)
[03:31:28] <mletterle> it is uncomfortably close
[03:33:21] *** Quits: maxli (maxli@moz-4D28BA20.student.cs.uwaterloo.ca) (Ping timeout)
[03:33:34] <Sharp> Maybe we should have gone with sint and int instead :)
[03:33:48] * Sharp wonders whether people want uints or ints more often.
[03:34:54] <cmr> Sharp: usually they want neither, and want a fast bigint type.
[03:35:00] <mindcat> ChrisMorgan: thanks! :D
[03:35:03] <Sharp> Heh.
[03:35:06] <pcmattman> cmr +1
[03:35:19] <cmr> the current numeric situation is not very good.
[03:35:27] <Sharp> Isn't uint currently the largest fast type on most people's machines?
[03:35:31] <cmr> No.
[03:35:36] <cmr> It's pointer-sized.
[03:35:37] <ChrisMorgan> Yep, overflow is normally an undesirable thing.
[03:35:39] <cmr> uintptr_t
[03:35:50] <Sharp> Isn't pointer size generally word size?
[03:36:09] <cmr> Sharp: there's been some thought of changing it to something less convenient so people don't use them when they don't really want them.
[03:36:12] <ChrisMorgan> On most architectures, yes.
[03:36:21] <Sharp> I know there are architectures where it's not the case
[03:36:33] <Sharp> I figured we were just ignoring them since I've been told to treat them as the same :)
[03:36:38] <mletterle> Anyway, I was actually looking at this, because I was poking around internals and what not: https://github.com/mozilla/rust/issues/9226 and I'm betting that ty_nil and ty_bot were supposed to be "unit" and not "uint".. :)
[03:37:08] <cmr> mletterle: heh, probably.
[03:37:50] <Sharp> cmr: Change them to what?  Go back to the C variants?
[03:38:01] <cmr> Sharp: uintptr/intptr
[03:38:05] <Sharp> Ah
[03:38:08] <cmr> was the proposal I recall seeing
[03:38:15] * Sharp wouldn't mind that personally.
[03:38:49] <cmr> With ToPrimitive and FromPrimitive, I wouldn't mind having that, and having an Int/Integer type which is a fast bigint.
[03:39:48] <ChrisMorgan> Yep, we need something like Py3k's int type.
[03:39:52] <Sharp> I don't mind fast bigints in principle.  I do mind slow bigints, and bigints that don't look like bigints, which is what I get in a lot of languages.
[03:40:16] <Sharp> (Also: bigints that still overflow, just later, are the worst).
[03:40:22] <cmr> Yeah, I'll strongly resist any change to a slow bigint
[03:40:42] <cmr> Sharp: What do you mean by bigints that don't look like bigints?
[03:40:57] <Sharp> I mean bigints that silently coerce from ints to bigints when they get large enough, regardless of context.
[03:41:03] *** Quits: mib_wyolf2 (Mibbit@B4104EBB.3CC170B1.1E14B209.IP) (Quit: http://www.mibbit.com ajax IRC Client)
[03:41:03] *** Quits: mib_3rw2pm (Mibbit@B4104EBB.3CC170B1.1E14B209.IP) (Quit: http://www.mibbit.com ajax IRC Client)
[03:41:10] <cmr> Ah, yeah, that's not very rustic.
[03:41:26] <Sharp> Nope.  But it's very [insert language here] :P
[03:41:35] <dbaupp> Sharp: how is the silent coercion anything but an implementation detail?
[03:41:44] <ChrisMorgan> It's certainly got to be a discrete type. No coercion like Py2k int/long.
[03:42:09] <Sharp> It is more than an implementation detail when I am trying to do something with the type that relies on it being a particular size.  Or when it does something really dumb like turn it into a double precision and I lose information.
[03:42:36] <strcat> a big integer never loses precision
[03:42:37] <dbaupp> well, yeah, but that's fairly impossible in statically typed language like Rust.
[03:42:37] * ChrisMorgan likes Python's integer handling, but recognises such a model is not appropriate for Rust—but the Py3k int type would be suitable as a new type
[03:42:50] <Sharp> More commonly, I'll be passing it back and forth with another program that expects numbers of a particular size and it will get confused.
[03:42:50] <mletterle> autoint
[03:43:09] <dbaupp> (i.e. the possibility for coercion has to be in the type, so you know when you're using one that can be upgraded.)
[03:43:15] <Sharp> Yeah, exactly
[03:43:20] <strcat> the py3k int would be an enum with i64 and the big integer type
[03:43:23] <Sharp> I'm totally fine with *expected* bigints
[03:43:32] <Sharp> I just don't like silent ninja bigints.
[03:43:48] <ChrisMorgan> Fortunately, we can have things like <T: Integer> :-)
[03:44:38] <Sharp> strcat: I think Ruby's BigInteger class is bounded, actually.  That or BigDecimal.
[03:44:39] *** Joins: rusti (rusti@moz-54F7FD49.cpe.net.cable.rogers.com)
[03:44:42] <Sharp> It's really annoying.
[03:45:06] <strcat> a big integer type with a bound that's not out of memory is broken
[03:45:16] <Sharp> Well, yeah, it's Ruby :P
[03:45:20] <strcat> you'd have to go out of your way to break it ;\
[03:45:34] <ChrisMorgan> strcat: of course, the important thing with the Py3k int is that it's all the one type, unlike Py2k where it's int if small enough and coerced to long if it gets bigger than sys.maxint.
[03:45:49] <strcat> ChrisMorgan: well that should be an internal implementation detail
[03:45:54] <ChrisMorgan> Indeed.
[03:47:38] *** Quits: ofeldt (ofeldt@moz-4D678086.dip0.t-ipconnect.de) (Ping timeout)
[03:47:42] *** Quits: pcwalton (pcwalton@moz-C07D5168.p2p.sfo1.mozilla.com) (Quit: pcwalton)
[03:49:07] <ChrisMorgan> nmatsakis: did you want me to create a PR of my augmented-assignment branch so you can comment on it?
[03:49:23] <cmr> ChrisMorgan: is this generic augmented assignment?
[03:49:32] <ChrisMorgan> cmr: yep
[03:49:35] <cmr> \o/
[03:49:42] <ChrisMorgan> The stuff I did a few months ago but didn't get entirely working.
[03:50:08] <ChrisMorgan> cmr: https://github.com/mozilla/rust/issues/5992#issuecomment-22258296
[03:51:12] *** Joins: ofeldt (ofeldt@moz-4D678086.dip0.t-ipconnect.de)
[03:51:27] <sfackler> Is there any way to get a ~Any from a ~SomeTrait?
[03:52:01] <cmr> sfackler: your_obj as ~Any
[03:52:06] <cmr> Or actually
[03:52:08] <cmr> No
[03:52:11] <cmr> All types implement Any
[03:53:57] *** Joins: kimundi_ (kimundi@moz-CEF9AA1F.dip0.t-ipconnect.de)
[03:55:09] *** Quits: kimundi (kimundi@moz-F8D99315.dip0.t-ipconnect.de) (Ping timeout)
[03:55:09] *** kimundi_ is now known as kimundi
[03:55:30] *** Quits: ofeldt (ofeldt@moz-4D678086.dip0.t-ipconnect.de) (Ping timeout)
[03:56:18] *** Quits: rusti (rusti@moz-54F7FD49.cpe.net.cable.rogers.com) (Client exited)
[03:57:11] <sfackler> right, but I don't want the implementation for the trait object, I want the implementation for the type encapsulated by the trait object
[03:57:45] <cmr> Ahh
[03:57:52] <cmr> kimundi: ^ ?
[03:58:06] *** Quits: TD-Linux (TD-Linux@E338EB99.2B4F0AE0.A0A36CCE.IP) (Ping timeout)
[03:58:11] <cmr> sfackler: I feel like that wouldn't be possible, given the get_tydesc intrinsic.
[03:59:12] *** Joins: ofeldt (ofeldt@moz-4D678086.dip0.t-ipconnect.de)
[03:59:44] <sfackler> I really just want safe downcasting from a ~Trait to the implementation type
[03:59:53] <strcat> sfackler: it's won't be possible
[04:00:31] <ChrisMorgan> sfackler: do you know the type (I mean, is it a finite set of types, known at compile time)?
[04:01:03] <sfackler> yeah
[04:01:15] <strcat> if it's a finite set of types, why a trait object?
[04:01:41] *** Joins: TD-Linux (TD-Linux@E338EB99.2B4F0AE0.A0A36CCE.IP)
[04:01:57] <ChrisMorgan> You've got any.as_ref::<Foo>() -> Option<&Foo>, any.move::<Foo>() -> Option<~Foo>, &c.
[04:02:22] <sfackler> ChrisMorgan: right, but I have a ~SomeTrait, not a ~Any
[04:03:02] <dbaupp> sfackler: if you have control over SomeTrait you can make it inherit from Any.
[04:03:03] <ChrisMorgan> sfackler: if you were feeling particularly crazy you could copy what Any does...
[04:03:10] *** kimundi is now known as zz_kimundi
[04:03:31] * strcat is sad that we've moved towards reflection..
[04:03:33] <ChrisMorgan> Oh yes, I forgot trait inheritance.
[04:03:44] <strcat> why not use an enum here? finite set of types...
[04:03:56] <dbaupp> strcat++
[04:03:57] <sfackler> I should have been more clear. I personally know the type since I'm defining it, but it's not limited in practice
[04:03:58] <ChrisMorgan> strcat: hopefully it won't get as 'orrible as Go's type assertions
[04:04:04] <sfackler> strcat: it's the notice handler callback here: http://docs.octayn.net/rust-postgres/struct.PostgresConnection.html#method.set_notice_handler
[04:04:22] *** Quits: ofeldt (ofeldt@moz-4D678086.dip0.t-ipconnect.de) (Ping timeout)
[04:04:30] <strcat> ChrisMorgan: or it will be removed
[04:04:43] * ChrisMorgan shudders when he sees how a Go function might take a Writer and then sneakily check if it's flushable and flush it if it is
[04:05:11] <Sharp> I kind of feel like that really wants to be a fn argument of some sort, not a trait
[04:05:32] <sfackler> Sharp: ~fns are being removed in favor of ~Traits
[04:05:33] <cmr> Sharp: trait objects can keep their own state.
[04:05:46] <sfackler> and once-fns
[04:05:47] *** Quits: sankha93 (Instantbir@7061CD01.D6BD0D91.22D41759.IP) (Ping timeout)
[04:05:51] <Sharp> Bleh.  Why?
[04:05:54] <dbaupp> 'proc's
[04:06:11] <cmr> Sharp: see all of nmatsakis' blog posts about functions :p
[04:06:12] *** Joins: sankha93 (Instantbir@7061CD01.D6BD0D91.22D41759.IP)
[04:06:34] <Sharp> I know, I know, fns don't play well with no garbage collection
[04:06:34] <dbaupp> Sharp: I believe there is a plan for having sugar that makes (the equivalent of) ~fn/@fn not so bad.
[04:06:44] <strcat> I don't like that we have std::reflect, std::repr, get_tydesc and Any at all - it's not possible to write a library with a well defined ABI
[04:06:57] <sfackler> strcat: Reflection opens up a can of worms, but it's incredibly useful. Some of it can be handled with syntax extensions, but not everything
[04:06:57] <strcat> and it generates so much code bloat
[04:07:16] <dbaupp> strcat: should we at least move reflect and repr to std::unstable?
[04:07:16] <strcat> hiding implementation details is useful too, and we lost it
[04:07:22] * Sharp doesn't think reflection can possibly be useful enough to justify the cost in a language like Rust.
[04:07:28] <strcat> we don't have privacy
[04:07:43] *** Joins: ofeldt (ofeldt@moz-4D678086.dip0.t-ipconnect.de)
[04:08:56] <Sharp> Feature-gate reflection?
[04:09:09] <strcat> yes
[04:09:11] <strcat> please ;
[04:09:13] <strcat> p
[04:09:16] * Sharp likes that.
[04:09:21] <strcat> poor smiley chopped in two
[04:10:06] <strcat> feature gating won't really work for libraries, it'd just be stability attributes
[04:10:18] <Sharp> In all seriousness I don't think reflection is that useful most of the time.  I think it makes writing programs faster at the cost of predictability.
[04:10:27] *** zz_kimundi is now known as kimundi
[04:10:35] *** Quits: nomadic (nomadic@moz-E01D5C49.hsd1.ga.comcast.net) (Quit: Leaving)
[04:10:48] <Sharp> (And it makes the actual program slower, usually).
[04:11:32] *** Quits: dew (Instantbir@moz-E4452B8F.static.stls.mo.charter.com) (Ping timeout)
[04:11:37] *** Joins: dew (Instantbir@moz-E4452B8F.static.stls.mo.charter.com)
[04:11:55] *** Quits: ofeldt (ofeldt@moz-4D678086.dip0.t-ipconnect.de) (Ping timeout)
[04:12:16] <strcat> the stdlib is generally very slow/bloated atm
[04:12:18] *** Quits: Sorella (quildreen@9D963F5D.DF5D8AE7.54BCAB54.IP) (Quit: Ex-Chat)
[04:12:47] *** Quits: jmgrosen (jmgrosen@moz-848F6087.sb.sd.cox.net) (Quit: jmgrosen)
[04:13:34] *** jorendorff is now known as jorendorff_away
[04:14:21] <Sharp> I feel like speed of the stdlib (as long as it's not actually buggy) is something that can be incrementally improved easily after 1.0… bloated not so much.  I thought people were refactoring it all the time though.
[04:14:30] <strcat> it can't be fixed post 1.0
[04:14:38] <strcat> if we stabilize the APIs
[04:14:48] <strcat> acrichto had this example before http://ix.io/8Qw
[04:14:56] <strcat> compile that with rustc -S --emit-llvm -o -
[04:15:04] <Sharp> You're talking about bloatedness, or speed?  I was saying I think speed can often be fixed with a similar API.
[04:15:09] <strcat> it generates 26k lines of LLVM IR
[04:15:18] <strcat> Sharp: they are the same thing in most cases
[04:15:26] <Sharp> 26k lines?  Ew.
[04:15:44] *** Joins: ofeldt (ofeldt@moz-4D678086.dip0.t-ipconnect.de)
[04:16:02] <Sharp> …That?
[04:16:13] <strcat> there are design decisions made in the standard library that make it slow/bloated
[04:16:29] <strcat> we are slower than interpreted languages in debug builds
[04:16:34] <Sharp> Well, then they should be fixed.
[04:16:48] <strcat> I don't think it will be
[04:17:06] <Sharp> Then people just won't use the standard library.
[04:17:20] <strcat> people just won't use rust*
[04:17:26] <Sharp> Also that.
[04:17:53] *** Joins: jmgrosen (jmgrosen@moz-848F6087.sb.sd.cox.net)
[04:18:00] <Sharp> What sorts of design decisions are you referring to?
[04:19:14] * Sharp finds it hard to believe there could be community backlash over making Rust fast :P
[04:20:01] <dbaupp> Sharp: there might be community backlash over breaking the stdlib API yet again
[04:20:04] <strcat> well I feel like there's no interest in it
[04:20:08] *** Quits: ofeldt (ofeldt@moz-4D678086.dip0.t-ipconnect.de) (Ping timeout)
[04:20:11] <ChrisMorgan> Sharp: speed will typically come at a cost in another area, and that's where the backlash will come in.
[04:20:20] <strcat> I think rust-core will end up being a fork of the standard library
[04:20:29] <strcat> when I feel like devoting some time to it
[04:21:02] <Sharp> ChrisMorgan: The C++ STL is pretty fast, no?
[04:21:09] * ChrisMorgan doesn't know
[04:21:13] <SiegeLord> What does code generation quality have to do with the standard library?
[04:21:18] * ChrisMorgan isn't familiar with the C++ STL
[04:21:36] <strcat> SiegeLord: it's not rustc's fault the standard library isn't written to perform well
[04:21:43] <strcat> rustc is no longer really to blame
[04:21:50] <strcat> it generates pretty good code
[04:22:18] <SiegeLord> It seems to compile pretty slowly still...
[04:22:32] <strcat> what are you compiling?
[04:22:32] <Sharp> LLVM optimizes most of our output away
[04:22:47] <strcat> rustc doesn't compile slowly or generate poor code
[04:22:57] *** Joins: mindcat_ (mindcat@9F19EC2E.B1E12A5D.57E3C596.IP)
[04:23:16] <Sharp> My understanding is that with proper use of compile-time generics and clever algorithms we should be able to be very performant, I'm sort of confused about what decisions we could possibly be making to make that not the case
[04:23:28] *** Quits: sankha93 (Instantbir@7061CD01.D6BD0D91.22D41759.IP) (Ping timeout)
[04:23:28] *** Quits: mindcat (mindcat@905CA2D5.E97F21E0.431667FD.IP) (Ping timeout)
[04:23:37] <ChrisMorgan> strcat: one thing I would not like to see happen is have a language where you get multiple incompatible standard libraries in common usage. As an example, when I was looking at D quite some time ago, the situation with Phobos and Tango was leading to considerable confusion.
[04:23:38] <dbaupp> SiegeLord: there's other factors unrelated to codegen that make compilation seem slow (e.g. reading metadata from external crates is the majority of time for small files)
[04:23:43] *** Joins: james4k (james@moz-E7990244.consolidated.net)
[04:23:44] *** Joins: ofeldt (ofeldt@moz-4D678086.dip0.t-ipconnect.de)
[04:23:47] <strcat> ChrisMorgan: well, it's going to happen
[04:23:51] <Sharp> Is speed just not a priority at all in the current implementations?
[04:23:53] *** Joins: sankha93 (Instantbir@7061CD01.D6BD0D91.22D41759.IP)
[04:24:00] <strcat> I love rust, but am no longer very interested in the standard library
[04:24:12] <strcat> there is too much push back now when I try to improve it
[04:24:19] <dbaupp> Sharp: the stdlib itself isn't really a priority for the core-devs atm
[04:24:36] <cmr> I wonder if libstd could be split into libcore (rust-core) and librustrt
[04:24:42] <dbaupp> Sharp: they're all doing more fundamental language work
[04:24:53] <Sharp> Which is good, but the standard library is pretty important
[04:24:55] <strcat> ChrisMorgan: https://github.com/mozilla/rust/issues/8981 that seems like a pretty compelling perf increase to me
[04:25:01] <Sharp> IMO
[04:25:11] <strcat> ChrisMorgan: but it's been 2 months, and it's still just an RFC
[04:25:32] *** Joins: willingc (willingc@moz-B4760708.san.res.rr.com)
[04:25:56] <strcat> what about a faster hashmap? what about faster trees? what about allocators? how about removing the 10 useless layers of abstraction so non-optimized code is 10x faster
[04:25:57] <strcat> *shrug*
[04:26:13] <cmr> strcat++
[04:26:14] <dbaupp> Sharp: yes, but getting the language "finished" is more important in many ways, since the stdlib needs to be written in that language.
[04:26:33] <ChrisMorgan> strcat: my suggestion would be to take your specific suggestion (ideally with an implementation ready) and ask the core developers to approve it and see what happens.
[04:26:36] <Sharp> I agree with the caveat that I think stdlib has to be part of the finished language.
[04:26:49] <Sharp> I don't think you can call Rust 1.0 finished if the stdlib isn't.
[04:26:49] <strcat> ChrisMorgan: I have lots of suggestions though
[04:27:19] *** Joins: lenstr (lenstr@AF8EB999.6049B16A.85938D85.IP)
[04:27:25] <cmr> strcat: add it to https://etherpad.mozilla.org/Rust-meeting-weekly
[04:27:31] <ChrisMorgan> strcat: the mere existence of such a discussion makes it very easy to come to no conclusion; providing something ready to integrate (though unfortunately with the potential to be wasted effort) is much more compelling for coming to strict conclusions.
[04:28:03] *** Quits: ofeldt (ofeldt@moz-4D678086.dip0.t-ipconnect.de) (Ping timeout)
[04:28:07] <strcat> I don't like spending hours on something and having it rejected
[04:28:13] *** Joins: nejucomo (Adium@moz-434492BB.dsl.static.sonic.net)
[04:28:27] *** Quits: nejucomo (Adium@moz-434492BB.dsl.static.sonic.net) (Quit: Leaving.)
[04:28:50] <strcat> anyway, to support allocators it needs to be a Vec type in the library
[04:28:55] *** Quits: alan (alan@moz-F8EE186F.lightspeed.snantx.sbcglobal.net) (Quit: alan)
[04:29:04] *** Quits: lenstr (lenstr@AF8EB999.6049B16A.85938D85.IP) (Ping timeout)
[04:29:35] <strcat> do I want to fight for replacing ~[T] with a library type? not really
[04:30:00] <SiegeLord> So my code compiles slowly because I use std?
[04:30:10] <strcat> SiegeLord: that's likely a big part of it
[04:30:14] * Sharp thought everyone wanted to replace ~[T] with a library type.
[04:30:41] <cmr> Could ~[T] be a lang item?
[04:30:52] <strcat> cmr: wouldn't support allocators
[04:30:57] <cmr> Ah, yeah.
[04:31:14] <cmr> strcat: weren't you against allocator parameterization a few months ago?
[04:31:22] <strcat> I found a sane way to do it
[04:31:32] <cmr> cool
[04:31:45] *** Joins: ofeldt (ofeldt@moz-4D678086.dip0.t-ipconnect.de)
[04:32:56] <dbaupp> strcat: rust-core isn't using an allocator parameter for Vec?
[04:33:03] <strcat> dbaupp: generic dtors don't work
[04:33:15] <dbaupp> strcat: ah :(
[04:33:26] <Sharp> strcat: What's still wrong with them?
[04:33:52] <strcat> the code path generating destructors doesn't handle type bounds
[04:34:00] <Sharp> All the glue_ stuff?
[04:34:06] <strcat> well it's written in base.rs
[04:34:08] <strcat> get_res_dtor
[04:34:11] <Sharp> Ah, okay.
[04:34:25] *** Quits: ofeldt (ofeldt@moz-4D678086.dip0.t-ipconnect.de) (Ping timeout)
[04:34:32] <strcat> it calls monomorphic_fn directly without passing it the type bound info (called vtables, even if it's all statically resolved, for legacy reasons)
[04:34:48] <Sharp> Weird.
[04:35:02] <Sharp> Actually, not that weird, based on some of the stuff I've seen in rustc :P
[04:35:06] <strcat> dbaupp: https://gist.github.com/thestinger/7275558
[04:35:23] <Jesse_> strcat: if your experiments go well, maybe you'll be able to get them into the standard library?
[04:36:17] <strcat> well, Vec<T> is 7x faster at pushing than the standard vector
[04:36:24] <strcat> it doesn't need to allocate space for a zero-size vector
[04:36:28] <strcat> and it handles overflow correctly
[04:36:36] <strcat> also generates much, much smaller code
[04:36:58] <strcat> needing to support managed pointers throws a wrench in this, because the old crappy layout is still needed for that
[04:37:00] <Sharp> Oh yeah, we're still allocating space for those aren't we :(
[04:37:02] <Sharp> Dumbly
[04:37:16] <strcat> well the representation is silly
[04:37:53] <strcat> I doubt there's going to be support for adding a type parameter to every container and removing ~T and ~[T]
[04:38:18] <dbaupp> strcat: just need dtors to be correct and that'll work?
[04:38:22] <Sharp> I thought that was what the devs were discussing
[04:38:23] <strcat> dbaupp: yes
[04:38:27] <Sharp> With allocatorsal
[04:38:29] <strcat> dbaupp: it works if I remove the dtor ;p
[04:38:31] <Sharp> *allocators
[04:38:34] <Sharp> Haha
[04:38:37] <Sharp> "Works"
[04:38:40] <dbaupp> strcat: \o/ leak all the things
[04:38:46] *** Joins: ofeldt (ofeldt@moz-4D678086.dip0.t-ipconnect.de)
[04:38:57] <strcat> dbaupp: or at least, if I remove the allocator call there
[04:39:02] <strcat> so free the elements and leak the vector ;p
[04:39:12] <strcat> it's the call itself that's broken
[04:39:22] <strcat> because it looks up the impl/trait data but it's missing
[04:39:32] <strcat> and ICEs
[04:39:36] <strcat> I couldn't figure out how to fix it :(
[04:39:39] <Sharp> This is for @muts only?
[04:39:45] <strcat> hm?
[04:39:52] <Sharp> The allocator dying
[04:39:54] <strcat> no
[04:39:58] <strcat> generic dtors don't compile
[04:40:02] <Sharp> I assume the allocator doesn't need that information otherwise
[04:40:06] <Sharp> Oh… right.
[04:40:09] <strcat> if they make a call to a method from a trait in a type bound
[04:40:18] <Sharp> Yeah, that's just crappy.
[04:40:20] <dbaupp> strcat: one could imagine ~ and ~[] being sugar for Unique<T, SomeDefaultAllocator> and Vec<T, SomeDefaultAllocator>
[04:40:28] * Sharp has imagined it that way.
[04:40:38] <strcat> dbaupp: but not when they contain managed ptrs
[04:40:53] <Sharp> I don't think people are interested in a concise representation for managed pointers anymore.
[04:41:41] <Sharp> At least, not the core devs.  I heard arguments explicitly against it on the basis that there are too many possible allocation schemes.
[04:41:45] <cmr> I feel like managed pointers haven't really lived up to their original expectation: that people would use them by default, and that they wouldn't impose a perf burden on code not using them.
[04:41:46] <strcat> a unique vector containing a managed ptr needs to have the length inside the allocation
[04:42:08] <strcat> or there's no way for the gc (or the current cycle annihilator) to dynamically free it
[04:42:17] <Sharp> Managed pointers *shouldn't* affect code that's not using them.  There's no reason why they should.
[04:42:22] <strcat> they do
[04:42:34] <strcat> anything that's a generic way to allocate memory will need to use a rooting API
[04:42:46] *** Joins: dherman (dherman@moz-6CA476B1.hsd1.ca.comcast.net)
[04:42:46] *** ChanServ sets mode: +ao dherman dherman
[04:42:49] <strcat> it will need to contain the necessary data to free it *in the allocation itself*
[04:42:55] <strcat> dynamic runtime type information
[04:43:08] * Sharp doesn't see why anything but the GC'd type has to be boxed or have runtime information known
[04:43:18] <strcat> Sharp: because a GC walks from roots
[04:43:31] <strcat> it needs to scan the stack
[04:43:33] <Sharp> You can store the possible roots explicitly
[04:43:38] <Sharp> There are lots of GC schemes
[04:43:40] <strcat> ok
[04:43:48] <strcat> so now, the GC needs to know the type of the thing it's trying to free
[04:43:53] <strcat> or at least, a ptr to the dtor
[04:44:02] <Sharp> Yes, that's not that unusual though
[04:44:14] <strcat> so you need runtime type information in heap allocations
[04:44:17] <strcat> think about Rc<T>
[04:44:24] <strcat> it's shared ownership
[04:44:30] <strcat> it can contain managed ptrs
[04:44:35] <strcat> the GC needs to trace through it
[04:44:42] <strcat> the GC needs to able to free the box dynamically
[04:44:44] <Sharp> As far as I am concerned: if you are using GC, you've agreed to sacrifice some performance.
[04:44:53] <Sharp> Or Rc for that matter.
[04:45:01] <strcat> but if you aren't using GC, you are paying a 7x cost in performance for vectors *right now*
[04:45:10] <strcat> they are represented that way to make GC possible
[04:45:12] <Sharp> Yes, but I'm just saying
[04:45:16] <Sharp> A solution that makes GC slower and not GC faster
[04:45:20] <Sharp> Is a win as far as I'm concerned
[04:45:26] <strcat> well, rust-core won't have GC
[04:45:29] <strcat> so it doesn't need to worry about this
[04:46:11] <strcat> exceptions, reflection and GC are not really pay-for-what-you-use
[04:46:16] <Sharp> If your codei s running alongside code that uses GC, yeah, it's going to be slower.  But as long as I don't *have* to use GC and as long as Rust is smart enough not to enable it if I'm not using it, I don't care how slow it is
[04:46:18] <strcat> you end up paying for them whether or not you use them
[04:46:36] <strcat> Sharp: the stdlib will support managed ptrs though
[04:46:47] <Sharp> I thought we were getting rid of all managed pointers from stdlib.
[04:46:58] <strcat> it still needs to support them
[04:47:05] <Sharp> It should be possible to optimize for one case over the other.
[04:47:18] <strcat> you can't write a generic container that doesn't support managed ptrs
[04:47:19] <Jesse_> strcat: i don't understand this part "a unique vector containing a managed ptr needs to have the length inside the allocation"
[04:47:20] *** Joins: boredomist (ruqs@B16F530C.DC641F2C.BCAEBB33.IP)
[04:47:30] <strcat> Jesse_: the GC needs to be able to free arbitrary objects on the heap
[04:47:43] <Sharp> Except that it doesn't, except under some GC schemes...
[04:47:53] <strcat> ok, but the current concept of a GC needs that
[04:48:08] <strcat> ~T and ~[T] are not represented the same way if they container a managed ptr
[04:48:10] <Jesse_> the GC doesn't need to be able to free arbitrary *bare pointers* on the heap
[04:48:15] <Sharp> I thought everyone hated the current concept of a GC and that's why it was feature gated
[04:48:19] <strcat> I am not talking about bare pointers
[04:48:38] <strcat> Sharp: no, it's feature gated because it's going to move to libstd
[04:48:46] <strcat> with compiler hooks (lang items) to build it
[04:49:09] <Jesse_> if the GC traces something that has a pointer to the ~[T], the length will be alongside the pointer, right?
[04:49:15] * Sharp isn't sure exactly what our current plans for real GC even look like
[04:49:19] <Sharp> Not refcounting that is
[04:49:52] *** Quits: willingc (willingc@moz-B4760708.san.res.rr.com) (Client exited)
[04:50:01] <strcat> Jesse_: it's not going to start out as a precise GC
[04:50:07] <strcat> certainly not precise on the stack
[04:50:16] *** Joins: exobit (foo@moz-90D1B547.nycmny.fios.verizon.net)
[04:50:33] <strcat> it won't know what it's looking at
[04:50:45] <strcat> heap allocations that aren't done through ~T or ~[T] will need to use a rooting API
[04:50:46] <Jesse_> oh, yuck
[04:51:18] <strcat> LLVM doesn't have strong support for precise GC
[04:51:40] <strcat> they are just getting early stack map stuff 
[04:51:44] <strcat> hasn't landed
[04:51:47] <Sharp> Oh, really?
[04:51:49] <Sharp> Blah.
[04:52:00] * Sharp had hoped people wouldn't have to keep reinventing that particular wheel.
[04:53:08] <strcat> I happen to think that rust's vector is a deal breaker
[04:53:20] <strcat> if the vector is that slow, it's not a C++ replacement
[04:53:32] <strcat> but I can't see another way to support @
[04:53:43] <strcat> the length *needs* to be in the allocation for the current view of managed ptrs
[04:54:01] <Jesse_> is conservative scanning the only reason?
[04:54:12] <Sharp> I just don't understand why we have ot lay out our memory like we're expecting @ regardless of whether it's used
[04:54:19] <strcat> atm it uses a cycle collection at the end of the task so it needs a way to dynamically clean up
[04:54:25] <strcat> it uses reflection
[04:54:28] <SiegeLord> Is it not possible to decide what to desugar ~[] to depending on what is put in it?
[04:54:39] <strcat> SiegeLord: it would be very heard
[04:54:41] <strcat> hard*
[04:55:00] <strcat> considering how simple a vector type is to implement in a library
[04:55:00] *** Quits: mindcat_ (mindcat@9F19EC2E.B1E12A5D.57E3C596.IP) (Connection reset by peer)
[04:55:26] <Sharp> It seems to me that the implementation of the vector type and the syntax are orthogonal issues.
[04:55:41] <Sharp> The vector type *should* be implemented in the library and even if it is it would still be equally hard to desugar ~[] in that way.
[04:55:48] *** Joins: mindcat (mindcat@C116C6B9.E97F21E0.431667FD.IP)
[04:55:56] <strcat> a library type can't change the representation depending on managed vs non-managed
[04:56:10] <Sharp> Not by itself, but the implementation could stil llive in a library.
[04:56:16] <strcat> it's not possible to write alternate vectors or smart pointers in the stdlib ecosystem unless you allocate memory with ~ or ~[T]
[04:56:32] <Sharp> And we could choose the "fast" or "slow" implementation based on whether there might be a GC'd pointer.
[04:56:42] <Sharp> I don't think that's unreasonable.  In fact, I think that's exactly what Rust is essentially promising.
[04:56:43] <strcat> Sharp: yeah, look in std::vec
[04:56:48] <strcat> the functions branch on contains_managed
[04:56:57] <strcat> ~[T] is always a ptr though
[04:57:00] <strcat> changing that would be hard
[04:57:04] <Sharp> Yeah, it would be annoying
[04:57:06] <Sharp> But not impossible
[04:57:30] * Sharp finally understands what that contains_managed check is for :)
[04:57:31] <dbaupp> can't we have ~[T: Managed] be ~[] with an extra header on the data? i.e. still (len, cap, *data)?
[04:57:43] <strcat> Sharp: I had to add it when I removed box headers from ~ for non-managed
[04:57:47] <dbaupp> but data == [len, T, T, T, ...]
[04:57:57] <strcat> Sharp: it's a big reason why there is so much code bloat at -O0
[04:58:10] <strcat> not *the biggest* reason, obviously
[04:58:15] *** Quits: KindOne (KindOne@moz-8384E922.dynamic.ip.windstream.net) (Ping timeout)
[04:58:19] <strcat> but it does mean those vector functions are 3-4x as big as they should be
[04:58:22] <Sharp> The branching?
[04:58:24] <Sharp> I mean
[04:58:26] <strcat> Sharp: no
[04:58:31] <Sharp> That doesn't make sense
[04:58:34] <strcat> the fact that there's a fast path that you want, and then a larger slow path
[04:58:37] <Sharp> Oh
[04:58:38] <strcat> and both exist at -O0
[04:58:45] <Sharp> Hah
[04:58:59] <Sharp> Well, we don't really optimize our code generation
[04:59:01] <Sharp> Like at all
[04:59:06] <strcat> we shouldn't
[04:59:10] <Jesse_> can you combine -O0 with something that tells it to at least prune dead paths
[04:59:20] <Sharp> It might be worthwhile just to speed up compilation in some cases
[04:59:22] <dbaupp> then it's not -O0
[04:59:25] *** Joins: maxiepoo (Max@moz-6F50ADE.hsd1.il.comcast.net)
[04:59:31] <strcat> it's not much of a debug build if it's eliminating dead code
[04:59:34] <Sharp> For useless branches
[04:59:39] <Sharp> That aren't in the original code
[04:59:46] <Sharp> Which we routinely add
[05:00:03] <strcat> or I can work on rust-core where there are no managed pointers
[05:00:08] <Sharp> Case in point, adding useless calls to tuple struct constructors
[05:00:32] <Sharp> I understand why you'd rather work in an environment where you don't have to deal with this stuff, I'm just saying it's not completely hopeless :P
[05:00:59] <strcat> some stuff in std::vec is broken if the vector contains a managed ptr like shrink_to_fit
[05:01:04] <strcat> because it's hard to remember to branch
[05:01:45] <Sharp> That just means we aren't maintaining our invariants properly, we should never not know (unless we are doing something stupid like using reflection).
[05:02:01] *** Joins: KindOne (KindOne@FADF8F1E.2171A688.34F73994.IP)
[05:02:08] <cmr> Personally I don't need or care about the GC. Rc and its bretheren fit my non-owned-needs
[05:02:12] <strcat> Sharp: I just mean it's a maintenance burden
[05:02:46] <Sharp> Yes… I think there is probably something automatable hiding in it though
[05:02:54] *** Quits: mindcat (mindcat@C116C6B9.E97F21E0.431667FD.IP) (Connection reset by peer)
[05:02:56] <Sharp> Though maybe that's naive
[05:03:19] *** Joins: mindcat (mindcat@2E9C9F87.68CEB32F.57E3C596.IP)
[05:03:32] <strcat> Sharp: http://ix.io/8Qz an example from earlier
[05:03:44] <strcat> Sharp: http://ix.io/8MY the *optimized* assembly for libstd
[05:03:49] <strcat> Sharp: http://ix.io/8MW here is rust-core
[05:04:04] <strcat> so it's not really surprising that it's 7x faster
[05:04:18] <strcat> in an inner loop where you would be doing more work, the gap would be larger (caches!)
[05:04:38] <Sharp> WTF
[05:04:45] <Sharp> That first output is optimized?
[05:04:47] <strcat> yes
[05:04:58] <strcat> unwinding and reflection and trait objects make a lot of code
[05:05:16] <strcat> but mostly, it's just hard to do all those weird align calculations and so on
[05:05:19] <strcat> to make
[05:05:30] <strcat> |len|cap|data| as one allocation block
[05:05:34] * Sharp sees no trait objects in the code sample
[05:05:35] <strcat> and handle overflow for each step
[05:05:39] <Sharp> Does Vec use them all the time?
[05:05:50] <strcat> Sharp: Vec calls stuff that calls fail!()
[05:06:00] <strcat> failure uses reflection and trait objects
[05:06:03] <Sharp> Oh.  Therefore theoretically uses… yeah
[05:06:08] <Sharp> Mehhh
[05:06:25] <Sharp> If there's one thing we do optimize in the frontend, let it be that
[05:06:35] <Sharp> If you're building -O3 you shouldn't expect the same quality backtrace you get at -O0
[05:06:37] <strcat> indexing the vector in rust-core is faster too, since it stores stuff in element units
[05:06:51] <strcat> converting to a slice doesn't require a division
[05:06:58] <Sharp> Yeah, I thought that was weird
[05:07:01] <Sharp> Like
[05:07:04] *** Quits: dherman (dherman@moz-6CA476B1.hsd1.ca.comcast.net) (Quit: dherman)
[05:07:08] <strcat> and keep in mind, a / x calls fail!() in a branch
[05:07:08] <Sharp> We have the information not to do that
[05:07:10] <Sharp> At compile time
[05:07:36] <Jesse_> because we're dividing by a constant that isn't 0 or -1
[05:07:41] <Sharp> We literally start by knowing the length
[05:07:52] <Sharp> Then we forget
[05:07:55] <Sharp> Then we recalculate it at runtime
[05:07:59] <Sharp> It's baffling
[05:08:10] <Sharp> I had assumed we were doing it because LLVM would optimize it away
[05:08:14] <Sharp> From what you're saying it doesn't though
[05:08:16] <strcat> hm?
[05:08:24] <Sharp> The division to figure out array length
[05:08:34] <strcat> Sharp: ah yes, well
[05:08:39] <strcat> you'll notice I fixed slices
[05:08:42] <strcat> they use element length now
[05:08:46] <Sharp> Good.
[05:09:24] <strcat> they were (ptr, byte_len) and now they're (ptr, element_len)
[05:09:58] <strcat> so length can return the length, not do a division and potentially unwind
[05:10:13] <strcat> (it wouldn't ever *actually* unwind...)
[05:10:16] <strcat> well
[05:10:19] <strcat> that'd be optimized out anyway
[05:10:22] <strcat> but not at -O0
[05:10:33] <dbaupp> strcat: doesn't fail!() do reflection in a function, not directly inline?
[05:10:50] <strcat> dbaupp: well it definitely uses trait objects
[05:11:08] *** Quits: canhtak (canhtak@moz-14E3CE16.wl.t.ulaval.ca) (Quit: canhtak)
[05:11:10] <strcat> all I can say is that there are tydescs everywhere
[05:11:36] <cmr> "All I know is my gut says maybe"
[05:12:03] <strcat> dbaupp: ah I see
[05:12:27] <Sharp> fail!() implicitly has to use reflection to produce a useful stack trace, I just don't get why that's the #1 priority at -O3
[05:12:31] <dbaupp> `echo 'fn main() { fail!("foo") }' | rustc --pretty expanded -` becomes `fn main() { ::std::sys::FailWithCause::fail_with("foo", "<anon>", 1u) }`
[05:12:45] <strcat> dbaupp: I'm talking about the total code though
[05:12:53] <strcat> using LTO
[05:12:57] <dbaupp> strcat: right
[05:13:22] <strcat> it's true that it's just a function call that may unwind
[05:13:25] <strcat> at the call site
[05:13:50] <strcat> so mostly it just causes landing pads to be generated all the way up the stack
[05:14:09] <dbaupp> yeah, yuck :(
[05:15:03] <strcat> it's hard to pin down exactly what makes something like task::try generate >26k lines of IR
[05:15:12] <strcat> many papercuts
[05:15:28] <strcat> I'm convinced rustc is not at fault though
[05:15:30] <strcat> libstd is
[05:15:33] *** Quits: james4k (james@moz-E7990244.consolidated.net) (Ping timeout)
[05:15:42] <strcat> rustc can be made better, sure
[05:16:35] <strcat> dbaupp: we also don't hoist out of generics
[05:16:49] <cmr> What is that?
[05:16:58] <strcat> cmr: so, lets say you are writing a generic function
[05:16:58] <cmr> Oh, remove the code that doesn't use the generic?
[05:17:04] <cmr> remove/separate
[05:17:08] <strcat> cmr: yeah
[05:17:14] <cmr> mmm
[05:17:18] <strcat> 90% of the body is often the same for different types
[05:17:27] <cmr> That'd help overall codesize, but would it help runtime much?
[05:17:34] *** Joins: dherman (dherman@moz-6CA476B1.hsd1.ca.comcast.net)
[05:17:34] *** ChanServ sets mode: +ao dherman dherman
[05:17:39] <Sharp> strcat: That sounds like an optimization, from your perspective we shouldn't do that
[05:17:39] <strcat> cmr: with nopt, yes
[05:17:51] <strcat> Sharp: it's a thing humans need to do
[05:18:37] <strcat> to reduce compile-time and code size with optimizations disabled
[05:18:43] *** Quits: jmgrosen (jmgrosen@moz-848F6087.sb.sd.cox.net) (Quit: jmgrosen)
[05:19:44] <Sharp> So… you don't want to put any optimization (even really basic stuff) in the frontend, but instead you want notoriously error-prone humans to do it?  That doesn't make sense to me.
[05:19:46] *** Quits: maxiepoo (Max@moz-6F50ADE.hsd1.il.comcast.net) (Quit: maxiepoo)
[05:19:56] <Sharp> I agree that it shouldn't be hard in principle to do, I just don't agree with the logic.
[05:19:58] <strcat> code reuse
[05:20:07] <strcat> Sharp: -O0 can't run code transformations
[05:20:12] <strcat> it just can't
[05:20:15] *** Joins: jmgrosen (jmgrosen@moz-848F6087.sb.sd.cox.net)
[05:20:22] <Sharp> Yeah… you're right about -O0
[05:20:37] <strcat> this is only really a problem at -O0
[05:20:45] <Sharp> Fair enough.
[05:20:52] <strcat> well, hoisting out code as a compiler optimization is a research topic and isn't implemented in LLVM
[05:20:58] <strcat> but... it's usually not a huge deal except in compile-time
[05:21:17] <strcat> it's not something the frontend *can* do
[05:21:20] <Sharp> Hoisting has been around for a pretty long time… maybe not specifically with generics I guess
[05:21:20] <strcat> it doesn't know enough
[05:21:20] <SiegeLord> That's... an important consideration give Rust's compilation model :P
[05:21:25] <Sharp> But certainly with loop invariants
[05:21:52] <strcat> Sharp: yes, but LLVM doesn't know how to put code in another function to share code
[05:22:00] <Sharp> Oh.  Wait, really?
[05:22:05] <strcat> it would be enormously expensive to run naive searches for common bits of code to separate
[05:22:10] <strcat> Sharp: really
[05:22:16] <Sharp> Huh.
[05:22:23] <strcat> LLVM doesn't do optimizations that take ages
[05:22:42] <strcat> they have to have a very good impact on performance relative to their running time
[05:22:49] <cmr> -O4 baby
[05:23:01] <Sharp> GCC accepts up to -O9 right?
[05:23:04] <Sharp> Gotta put something there!
[05:23:08] <strcat> Sharp: it accepts, but it only has up to -O3
[05:23:13] <Sharp> Yeah, I know.
[05:23:20] *** Quits: jeffdb (jeff@moz-ED35AD97.hsd1.ca.comcast.net) (Quit: jeffdb)
[05:23:25] <strcat> Sharp: gcc's -O3 is usually slower than -O2
[05:23:25] <Sharp> But it implies that someone at some point thought it might be worth adding another 6 levels :)
[05:23:39] <strcat> clang's -O3 is faster than -O2
[05:23:46] <Sharp> Really?
[05:23:56] <cmr> I can confirm
[05:24:01] <strcat> LLVM doesn't enable optimizations until a speedup can be quantified
[05:24:08] <cmr> (with my experience)
[05:24:14] <strcat> and the potential regressions as viewed as acceptable
[05:24:18] *** Quits: cubic (cubic@moz-80241A3A.mc.videotron.ca) (Connection reset by peer)
[05:24:20] <Sharp> Ah, I see.
[05:24:36] <strcat> gcc has any "cool" optimizations enabled at -O3 whether or not they have good enough cost/heuristic models to be good in most cases
[05:24:36] <Sharp> Oh, you meant the actual program output, not compile time
[05:24:51] <Sharp> -O3 compiling faster was what confused me :)
[05:24:51] <strcat> Sharp: yes
[05:25:05] <Sharp> Yeah, I've noticed that -O2 tends to get me better results with GCC in most cases
[05:25:15] <strcat> for example gcc is still ahead of LLVM in terms of which loops it can vectorize
[05:25:21] <Sharp> Or I just have to fiddle with the optimization flags to ge tthe stuff that's actually useful
[05:25:25] <strcat> but their cost model sucks, and it's buggy
[05:25:28] <strcat> so it's in -O3
[05:25:31] <Sharp> Yeah, it does fancy polymath
[05:25:33] *** Joins: thewonderidiot (mstewart@moz-BE1C9F3F.lightspeed.frokca.sbcglobal.net)
[05:25:37] <Sharp> Of some sort
[05:25:50] <strcat> LLVM has really simple vectorization but it's so solid that it's enabled in -O2 and -Os now
[05:26:02] <strcat> there is polly, working on advanced vectorization
[05:26:03] *** Quits: jmgrosen (jmgrosen@moz-848F6087.sb.sd.cox.net) (Quit: jmgrosen)
[05:26:10] <strcat> http://polly.llvm.org/
[05:27:31] <Sharp> Actually, there are a couple of loop vectorization related optimizations that aren't enabled by default at -O3 IIRC
[05:27:45] <Sharp> But I think that's because they actually tend to change program behavior unacceptably
[05:28:05] *** Joins: lenstr (lenstr@AF8EB999.6049B16A.85938D85.IP)
[05:28:08] *** Quits: dew (Instantbir@moz-E4452B8F.static.stls.mo.charter.com) (Ping timeout)
[05:28:13] *** Quits: matthewbot (user@moz-C6814817.ga.at.cox.net) (Quit: ERC Version 5.3 (IRC client for Emacs))
[05:28:53] <Sharp> Anyway: hoisting out of invariants isn't the same as "randomly searching for code that looks the same," in principle it should be doable at compile time (and maybe you were saying it already is).
[05:28:53] *** Joins: dew (Instantbir@moz-E4452B8F.static.stls.mo.charter.com)
[05:28:59] <Sharp> Er, out of generics.
[05:29:26] <strcat> it's still not an easy optimization to do
[05:29:32] <strcat> you need to carefully measure when it's going to be a good idea
[05:29:38] *** Joins: pcwalton (pcwalton@moz-B51927E9.hsd1.ca.comcast.net)
[05:29:38] *** ChanServ sets mode: +ao pcwalton pcwalton
[05:29:47] *** Quits: lenstr (lenstr@AF8EB999.6049B16A.85938D85.IP) (Ping timeout)
[05:29:50] <Sharp> Yeah, it's easy to lose out when you add function calls.
[05:30:07] <strcat> it needs to be done in LLVM
[05:30:37] <strcat> after stuff like early-cse, and using the same cost information inlining knows about
[05:31:07] <strcat> but if you try to get that upstream I don't think it would fly ;p
[05:31:13] <Sharp> Haha
[05:31:20] <Sharp> Just hoist all common code in generics?  Yeah, I don't think so :P
[05:31:44] <cmr> strcat: does LLVM even have enough information to perform that optimization acceptably?
[05:31:57] <cmr> I feel like it wouldn't know which operations are even possible to be hoisted, not easily.
[05:32:09] <cmr> though I suppose metadata could help it.
[05:32:12] <Sharp> cmr: probably not, I think LLVM would need more metadata
[05:32:14] <Sharp> Yeah
[05:32:23] <strcat> cmr: it's like a more complicated mergefunc that does the opposite of the inline passes
[05:32:35] <strcat> I mean... they are fine with crazy ideas like rerolling loops ;p
[05:32:44] <cmr> heh, that optimization still gets me.
[05:32:50] <Sharp> Haha
[05:32:57] <Sharp> It makes sense though
[05:33:28] <strcat> oh look, I see you unrolled that loop. I'll kindly reroll that for you and do it myself
[05:33:41] <Sharp> Well, you probably didn't do it right :D
[05:34:00] <Sharp> You're a human, you can't compete with a machine.
[05:34:03] <strcat> unrolling is part of vectorizing
[05:34:06] *** Joins: maxiepoo (Max@moz-6F50ADE.hsd1.il.comcast.net)
[05:34:09] <strcat> if it can vectorize
[05:34:26] <cmr> Sharp: implying humans aren't machines!
[05:34:33] <Sharp> We are machines
[05:34:38] <strcat> a human could only compete if they had a time machine
[05:34:38] <Sharp> But we suck at rapid calculation
[05:34:45] <Sharp> Also, most of us aren't up to date on the latest compiler research
[05:34:50] <Sharp> Unlike LLVM
[05:34:58] <strcat> you'd need to go into the future and implement code with SIMD instructions that don't exist yet
[05:35:04] <Sharp> And don't like to do things like solve the k-coloring problem in our spare time
[05:35:07] <strcat> because in 6 months... LLVM will be outputting them for your code
[05:35:22] <strcat> auto-vectorization > manual vectorization in the long-term
[05:35:35] <strcat> the trick is writing the code in a way that auto-vectorization picks up on it ;p
[05:35:44] <Sharp> Auto vectorization will save parallel programming from programmers.
[05:36:09] <strcat> it's a different level of parallel though...
[05:36:11] *** Joins: jeffdb (jeff@moz-ED35AD97.hsd1.ca.comcast.net)
[05:36:12] <Sharp> True
[05:36:18] <Sharp> Autovectorization is a much faster variant :)
[05:36:36] <Sharp> And much more obviously useful, in general.
[05:37:26] <strcat> Sharp: it's different
[05:37:34] <strcat> vectorization means SIMD, in this case at least
[05:37:42] <Sharp> I know
[05:37:42] <strcat> so it only really applied to inner loops
[05:37:46] <Sharp> I'm pretty sure we're talking about the same thing
[05:37:56] *** Quits: dew (Instantbir@moz-E4452B8F.static.stls.mo.charter.com) (Ping timeout)
[05:37:56] <strcat> applies*
[05:37:59] *** Joins: dew (Instantbir@moz-E4452B8F.static.stls.mo.charter.com)
[05:38:06] <cmr> Sharp: I found http://smallcultfollowing.com/babysteps/blog/2013/06/11/data-parallelism-in-rust/ and the things it links to quite enlightening
[05:38:09] <Sharp> I'm just saying… when a compiler applies an autovectorization optimization to my code, I'm rather confident that my code is actually going to be faster
[05:38:25] <Sharp> Not so much with most autothreading implementations.
[05:38:32] <strcat> http://www.yosefk.com/blog/simd-simt-smt-parallelism-in-nvidia-gpus.html
[05:38:35] *** Quits: dbaupp (Thunderbir@moz-7FBF750E.lns20.syd6.internode.on.net) (Ping timeout)
[05:39:15] <strcat> Sharp: you need both though
[05:39:23] *** Quits: enix (enix@moz-A50569DD.c3-0.slvr-ubr1.lnh-slvr.md.cable.rcn.com) (Quit: Konversation terminated!)
[05:39:26] *** Quits: jeaye (Jeaye@moz-34FEF2BB.hsd1.ca.comcast.net) (Quit: zzz)
[05:39:36] <Sharp> Yeah, you can't just ignore threads entirely :P  I'm not trying to equate them, if that's what you're saying.
[05:39:42] <strcat> SIMD can make some inner loop 2x, 4x, 8x, 16x faster
[05:40:00] <strcat> but it's a constant factor speed up
[05:40:15] <strcat> threads scale to hardware with many cores
[05:40:35] <Sharp> Yeah… though in many cases diminishing returns start in short order
[05:40:41] <strcat> (and most code can't be vectorized)
[05:40:51] <Sharp> And the savings get swallowed up by the overhead of communicating over a network if you're using a datacenter
[05:41:08] <Sharp> Not always, but sometimes
[05:41:10] <strcat> vectorizing float calculations usually means getting different results
[05:41:54] <Sharp> Which is relevant for some, but not all, fields.
[05:42:08] <strcat> but it means it won't happen automatically
[05:42:37] *** Joins: dbaupp (Thunderbir@moz-8F906C32.lns20.syd6.internode.on.net)
[05:42:41] <strcat> unless we had attributes mapping to the floating point strictness stuff
[05:42:48] <Sharp> That sounds hard.
[05:43:48] <strcat> like arcp
[05:44:23] <Sharp> ARCP?
[05:44:53] <strcat> replace x / n with x * (1 / n)
[05:45:19] *** Quits: dbaupp (Thunderbir@moz-8F906C32.lns20.syd6.internode.on.net) (Ping timeout)
[05:45:21] <Sharp> Hm
[05:45:21] *** Joins: dbaupp (Thunderbir@moz-89FD7F5F.lns20.syd6.internode.on.net)
[05:45:22] *** Quits: maxiepoo (Max@moz-6F50ADE.hsd1.il.comcast.net) (Quit: maxiepoo)
[05:45:28] <Sharp> Does LLVM do that?
[05:45:46] <strcat> if you tell it it's allowed to break the strict float semantics ;p
[05:45:51] <Sharp> Heh.
[05:45:59] <Sharp> Then it's still not fully automated.
[05:46:00] <strcat> it's a per-operation flag
[05:46:28] <strcat> Sharp: sure, but you could have #[fast_math(reciprocal)] on a function and have rustc output all the instructions as arcp
[05:46:39] * Sharp likes the option to optimize out things like that even though it will technically break semantics
[05:46:51] <Sharp> It's like getting rid of code that might have otherwise raised a division by zero error
[05:46:52] <Sharp> I don't care
[05:47:08] *** Quits: dbaupp (Thunderbir@moz-89FD7F5F.lns20.syd6.internode.on.net) (Ping timeout)
[05:47:10] <strcat> it totally breaks floats to turn them all on ;p
[05:47:17] <strcat> http://llvm.org/docs/LangRef.html#fast-math-flags
[05:47:19] *** Joins: Shaladdle (Shaladdle@moz-424BC304.hsd1.pa.comcast.net)
[05:47:20] <Sharp> No doubt :P
[05:47:33] <strcat> (and some are memory unsafe)
[05:47:45] <Sharp> Haha, what?  Reassociate?
[05:47:50] *** Joins: dbaupp (Thunderbir@moz-96FDCF0F.lns20.syd6.internode.on.net)
[05:48:02] <Sharp> Is that an optimization? :P
[05:48:06] <Sharp> Maybe sometimes I guess
[05:48:09] <strcat> like
[05:48:31] <Sharp> I mean, I can see where it could produce faster code… but if it's wrong it's not actually faster
[05:48:36] <Sharp> You just generated a fast way to calculate something else
[05:48:43] <strcat> ((x * 1.5) * 1.5) * 1.5)
[05:48:46] <strcat> is not the same as
[05:48:51] <strcat> x * (1.5 * 1.5 * 1.5)
[05:48:56] <strcat> because floats are weird
[05:49:01] <benh> wow that 100 pushes libstd vs libcore example is killing me :(
[05:49:31] <strcat> I have a lot of trouble keeping a sane understanding of floats in my head
[05:49:34] <strcat> they are so darn weird
[05:49:39] <Sharp> IIRC strcat hasn't even put in anything very optimized
[05:50:07] <strcat> mathematical laws? ordering rules? pfft. floats are too cool for that
[05:50:11] <Sharp> Floats are confusing and I am happy that I rarely have to think about their memory layout.
[05:50:51] <strcat> the lack of associativity makes it not vectorize accumulators and so on :(
[05:51:14] <strcat> xs.fold(0.0, |a, b| a * b)
[05:51:18] <Sharp> Well, it's a good thing lots of languages use floats by default as their numeric types then
[05:51:18] <strcat> xs.fold(0.0, |a, b| a + b)
[05:52:54] <strcat> benh: https://github.com/thestinger/rust-core/blob/master/core/vec.rs#L55 well, it's simple
[05:53:00] *** Joins: jmgrosen (jmgrosen@moz-848F6087.sb.sd.cox.net)
[05:53:04] <strcat> KISS is the best rule in most cases ;P
[05:53:20] *** Joins: azita (Azita@moz-C1FB2A8.hsd1.ca.comcast.net)
[05:53:46] <Sharp> What?  No it's not.  It's just that it's hard to figure out which of the complex solutions is actually better.
[05:54:54] <benh> if old_size > size { out_of_memory() }, heh
[05:55:00] <strcat> if you have a simple vs. complex solution and the simple one is only slower by a low constant factor... in almost every case the simple one is better
[05:55:28] <strcat> easier to maintain, and easier to apply future *more important* optimizations
[05:55:42] <Sharp> I would still argue that the faster one is better, but I suspect we're just going to disagree on that one :)
[05:56:28] <strcat> I'm pretty sure rust uses byte size in vectors as a failed micro-optimization ;p
[05:56:50] <Sharp> That's not an optimization, that's just forgetting information purposelessly.
[05:56:54] <mcarberry> Having an error when attemping to use std::rt::io::net::addrinfo::get_host_addresses and when I request an irc rotation server like chat.freenode.net it errors
[05:57:07] <benh> It's probably because someone wanted to transmute them weirdly without having to adjust sizes
[05:57:10] <Sharp> Having *less* information is pretty much never a good idea if you are optimizing.
[05:57:20] <strcat> it's the same information
[05:57:27] <strcat> in a different format
[05:57:32] <Sharp> It's not, because you have to add a division and it's not available at all for zero size types.
[05:57:34] <strcat> if you want to allocate memory, you want bytes
[05:57:39] <mcarberry> "failed in non-task context at 'called Option::unwrap()' on a 'None' value
[05:57:41] <strcat> for almost everything else you want length
[05:57:52] <mcarberry> this function call is the only thing in my application
[05:57:56] <Sharp> Which results in us (awkwardly) allocating memory for zero size vectors
[05:58:05] <Sharp> Or pretending we are
[05:58:06] <strcat> Sharp: that's not why it does that
[05:58:16] <benh> strcat: It's not obvious to me what makes libstd's push worse... is it just that it has more indirection and potentially unwinds?
[05:58:27] <strcat> benh: layout of the vector
[05:58:32] <Sharp> strcat: I know why it allocates memory in general
[05:58:45] <Sharp> But that's not why it sends a fill of 50 bytes for a 50 element 0 length vector
[05:58:47] <strcat> Sharp: I mean the non-zero size thing
[05:59:10] <Sharp> It's to get around GEP, but really we shouldn't even be calling GEP in that situation
[05:59:31] <strcat> benh: *{ len, cap, data[] } vs. { len, cap, *data }
[05:59:38] <strcat> is most of it
[05:59:48] <benh> That accounts for the difference in size of generated code?
[06:00:16] <strcat> well the vector in the stdlib has to calculate the header size, adjust it to alignment, add the real size
[06:00:23] <strcat> and handle overflow over and over
[06:00:36] <strcat> and it uses len in bytes, not elements, so it has divisions/multiplications
[06:00:46] *** Joins: IRCMonkey56529 (nobody@moz-3F544FC1.san.res.rr.com)
[06:00:51] <benh> :(
[06:00:57] <strcat> actually atm it doesn't handle alignment portably, I think
[06:01:02] * strcat isn't sure
[06:01:12] *** Quits: jmgrosen (jmgrosen@moz-848F6087.sb.sd.cox.net) (Quit: jmgrosen)
[06:01:19] *** Quits: IRCMonkey56529 (nobody@moz-3F544FC1.san.res.rr.com) (Client exited)
[06:01:26] <Sharp> I'm pretty sure it doesn't
[06:01:31] <benh> How set are we on having byte counts instead of element counts, is that necessary for the gc case or can we change that?
[06:01:35] <Sharp> IIRC someone was getting a failure compiling on a nonstandard architecture at one of the aligns
[06:01:43] <strcat> benh: can change it, already changed it for slices
[06:01:46] <Sharp> It's not necessary at all.
[06:01:47] <benh> ok
[06:02:01] <benh> Do we still have @[]?
[06:02:04] <Sharp> The GC has to advance by element anyway.
[06:02:07] <strcat> benh: yes
[06:02:23] <strcat> benh: the real pain is that @ inside ~/~[T] makes them the managed-unique layout
[06:02:27] <strcat> ~[@5]
[06:02:29] <strcat> is
[06:02:30] <benh> yeah, i get that
[06:02:48] <benh> I'm trying to figure out how much of a pain it would be to ban @ inside ~[]
[06:02:57] <strcat> *{ { ref_count, *tydesc, *next, *prev }, { len, cap, data[] } }
[06:03:09] <strcat> I should make a README for this stuff (memory layouts and so on)
[06:03:14] <benh> "just use @[] in that case! pft!"
[06:03:20] <benh> generic code :(
[06:03:22] <dbaupp> @[] isn't expandable
[06:03:26] <strcat> @[] is really terrible, yeah
[06:03:38] <strcat> you would be hard-pressed to find a use case for it imo
[06:03:50] <benh> @mut @[] >:[
[06:03:58] <strcat> sharing some big immutable chunk of memory *within a task*
[06:03:59] <cmr> doesn't change @[]
[06:04:06] <strcat> benh: @mut [] can't be resized
[06:04:15] <strcat> think about the layout, ptr to an allocation
[06:04:20] <Sharp> strcat: dynamically compiled jump table? :P
[06:04:21] <strcat> resizing can move the allocation
[06:04:22] <benh> extra @
[06:04:29] <strcat> benh: still can't reallocate ;p
[06:04:52] <strcat> @mut ~[T] is the most lightweight dynamic array in an @mut
[06:05:16] <benh> i'll copy the @[] to a bigger one and store the new one in my @mut!
[06:05:26] <strcat> that works ;p
[06:05:26] <benh> yeah okay. i'll just stay away from the data structures, no worries.
[06:05:28] *** Quits: dew (Instantbir@moz-E4452B8F.static.stls.mo.charter.com) (Ping timeout)
[06:05:30] *** Joins: dew (Instantbir@moz-E4452B8F.static.stls.mo.charter.com)
[06:05:37] <Sharp> I can see people using it who just used @ everywhere because they didn't want to be bothered with lifetime errors
[06:06:08] <benh> I'm really afraid of dynamic borrowing errors :(
[06:06:22] <benh> Just because I don't really seem to have the right intuition for borrowing in the first place
[06:09:28] *** Quits: dew (Instantbir@moz-E4452B8F.static.stls.mo.charter.com) (Ping timeout)
[06:09:31] *** Joins: dew (Instantbir@moz-E4452B8F.static.stls.mo.charter.com)
[06:25:28] *** Parts: pcwalton (pcwalton@moz-B51927E9.hsd1.ca.comcast.net) ()
[06:28:45] *** Joins: lenstr (lenstr@AF8EB999.6049B16A.85938D85.IP)
[06:30:25] *** Quits: lenstr (lenstr@AF8EB999.6049B16A.85938D85.IP) (Ping timeout)
[06:31:37] *** Joins: pepper_chico (pepper_chi@552215C7.BBE04DBB.F546FA5F.IP)
[06:31:52] *** Joins: avsej (avsej@D9A610B8.4841F515.FB33447D.IP)
[06:40:06] *** Quits: azita (Azita@moz-C1FB2A8.hsd1.ca.comcast.net) (Quit: azita)
[06:41:43] *** Joins: Sodel_the_V (user@moz-853663E1.va.shawcable.net)
[06:46:04] *** Quits: alisdair (textual@28441AAB.AC6E1995.F0AE27BD.IP) (Quit: My MacBook Pro has gone to sleep. ZZZzzz…)
[06:49:36] *** Joins: alisdair (textual@28441AAB.AC6E1995.F0AE27BD.IP)
[06:50:20] *** Quits: dew (Instantbir@moz-E4452B8F.static.stls.mo.charter.com) (Ping timeout)
[06:50:21] *** Quits: alisdair (textual@28441AAB.AC6E1995.F0AE27BD.IP) (Quit: My MacBook Pro has gone to sleep. ZZZzzz…)
[06:51:15] *** Quits: sankha93 (Instantbir@7061CD01.D6BD0D91.22D41759.IP) (Quit: Gone to save the world!)
[06:52:31] *** Joins: dew (Instantbir@moz-E4452B8F.static.stls.mo.charter.com)
[07:01:39] *** Quits: pepper_chico (pepper_chi@552215C7.BBE04DBB.F546FA5F.IP) (Quit: Ex-Chat)
[07:08:33] *** Quits: dew (Instantbir@moz-E4452B8F.static.stls.mo.charter.com) (Ping timeout)
[07:08:39] *** Joins: dew (Instantbir@moz-E4452B8F.static.stls.mo.charter.com)
[07:10:07] *** Joins: nsf (nsf@moz-EEF3238A.convex.ru)
[07:10:28] *** Quits: voxpopuli (fanservice@moz-CEF3689A.hsd1.pa.comcast.net) (Ping timeout)
[07:11:09] *** Quits: dbaupp (Thunderbir@moz-96FDCF0F.lns20.syd6.internode.on.net) (Ping timeout)
[07:13:03] *** Quits: mindcat (mindcat@2E9C9F87.68CEB32F.57E3C596.IP) (Quit: Lost terminal)
[07:14:41] *** Joins: dbaupp (Thunderbir@moz-4D38AB0E.lns20.syd6.internode.on.net)
[07:15:11] *** Joins: asm (Mibbit@moz-F07ECE0D.vpn.mgn.ru)
[07:15:22] *** Joins: james4k (james@moz-E7990244.consolidated.net)
[07:15:32] *** Quits: dew (Instantbir@moz-E4452B8F.static.stls.mo.charter.com) (Ping timeout)
[07:15:45] *** Joins: hjr3 (hradtke@moz-E87BDF1F.socal.res.rr.com)
[07:16:11] *** Quits: asm (Mibbit@moz-F07ECE0D.vpn.mgn.ru) (Quit: http://www.mibbit.com ajax IRC Client)
[07:16:22] *** Joins: dew (Instantbir@moz-E4452B8F.static.stls.mo.charter.com)
[07:17:11] *** Quits: james4k (james@moz-E7990244.consolidated.net) (Ping timeout)
[07:17:43] *** Quits: dherman (dherman@moz-6CA476B1.hsd1.ca.comcast.net) (Quit: dherman)
[07:24:31] *** Joins: gavinb (gavinb@moz-9EC182F0.lowrp3.vic.optusnet.com.au)
[07:29:44] *** Joins: lenstr (lenstr@AF8EB999.6049B16A.85938D85.IP)
[07:29:54] *** Quits: Sodel_the_V (user@moz-853663E1.va.shawcable.net) (Quit: Eaten by a grue)
[07:30:31] *** Quits: gavinb (gavinb@moz-9EC182F0.lowrp3.vic.optusnet.com.au) (Quit: gavinb)
[07:30:55] *** Joins: kode-crypt (chatzilla@9BE163B0.70578880.F102451D.IP)
[07:31:33] *** Quits: lenstr (lenstr@AF8EB999.6049B16A.85938D85.IP) (Ping timeout)
[07:32:03] *** Quits: kode-crypt (chatzilla@9BE163B0.70578880.F102451D.IP) (Quit: ChatZilla 0.9.90.1 [Firefox 25.0/20131028113246])
[07:33:24] *** Joins: kode-crypt (chatzilla@F63B62E8.8AE8A320.7C0F3359.IP)
[07:33:28] *** Quits: dbaupp (Thunderbir@moz-4D38AB0E.lns20.syd6.internode.on.net) (Ping timeout)
[07:34:54] <kode-crypt> hi is it rust community ??? 
[07:35:31] <kode-crypt> any one alive here ?? 
[07:36:16] <strcat> yes
[07:36:37] <kode-crypt> hi <strcat>
[07:37:00] <kode-crypt> thnks for making it clear :)
[07:37:23] *** Joins: dbaupp (Thunderbir@moz-EA596755.lns20.syd6.internode.on.net)
[07:37:47] <myname> Oo
[07:38:27] <kode-crypt> any compiler developer here ???
[07:38:50] <kode-crypt> rust compiler developer ?? , i am trying to improve debug symbols in the compiler.
[07:40:37] <eddyb9> ????
[07:41:28] <kode-crypt> i m looking forward to improve debug symbol generation in rust compiler , so that gdb can provide more information.
[07:42:16] <kode-crypt> eddy do u work with compiler ?
[07:42:33] *** Quits: ksf (ksf@moz-EDD270DC.adsl.hansenet.de) (Ping timeout)
[07:42:35] *** Joins: ksf (ksf@moz-913342DB.adsl.hansenet.de)
[07:44:52] *** Joins: jensnockert (jensnocker@moz-5B057FF0.minc.se)
[07:45:20] <strcat> kode-crypt: it's 12:45am in california ;p
[07:49:43] <ChrisMorgan> kode-crypt: have you kept track of Michael Woerister's work in that area?
[07:50:11] <kode-crypt> yeah 
[07:50:49] <kode-crypt> same , i am doing it , and also trying to make contact with MW .
[07:51:13] <ChrisMorgan> The rust-dev mailing list is a good place.
[07:51:15] *** Joins: cdidd (cdidd@moz-DCE39D3C.broadband.corbina.ru)
[07:51:24] <kode-crypt> kk 
[07:52:10] <ChrisMorgan> The room's pretty quiet just at present (late Friday night for most regulars), but do ask any specific questions you may have and you might get an answer.
[07:54:12] <ChrisMorgan> (And here I am at 6:54pm on Saturday...)
[07:54:18] <kode-crypt> k , chris , last i was here, then it was not, so i thought  may be i m wrong room :P. well that's okey. Actually , i need help at initial level.
[07:54:24] <kode-crypt> I am student.
[07:56:03] * ChrisMorgan is also departing in a few minutes
[07:56:53] <ChrisMorgan> kode-crypt: there's also #rust-internals which is dedicated to what its name suggests
[07:58:38] *** Quits: Voomer (Voomer@moz-CC05FF5E.hsd1.wa.comcast.net) (Ping timeout)
[07:59:41] *** Quits: notmatt (notmatt@moz-9FB2565E.vc.shawcable.net) (Client exited)
[08:00:09] <kode-crypt> ok <chris> :)
[08:03:03] <ChrisMorgan> BTW, a general IRC hint: don't ask permission to ask, just ask; if the question is wrong in any way, you'll normally be directed in the right direction.
[08:05:50] <kode-crypt> what is the format of debug symbols ?
[08:07:17] <Sharp> I think DWARF?
[08:07:24] <ChrisMorgan> Something to do with DWARF. Michael's blog has many more details.
[08:07:40] <myname> doooorfs
[08:07:41] * ChrisMorgan is a mere mortal who enjoys being able to use debug symbols when necessary
[08:07:47] <myname> (sorry)
[08:08:31] <kode-crypt> kk
[08:09:58] *** Quits: JamesNZ (james@moz-264643C7.bitstream.orcon.net.nz) (Quit: Busying myself...)
[08:10:46] <kode-crypt> i have saved but can not find the link of his blog , do some1 else have/find ?
[08:11:00] <ChrisMorgan> http://michaelwoerister.github.io/
[08:11:10] * ChrisMorgan is now officially Gone.
[08:12:39] <kode-crypt> i think so . :P :P
[08:12:46] *** Quits: SiegeLord (sl@moz-CAF07B4C.hsd1.ma.comcast.net) (Connection reset by peer)
[08:22:36] *** Quits: ktt3ja (Mibbit@moz-F40FE31.washdc.fios.verizon.net) (Quit: http://www.mibbit.com ajax IRC Client)
[08:25:02] <nielsle> I am looking for a container that allows me to create immutable references to a mutable vector.  It should translate the following c++ code to rust as directly as possiblehttp://pastebin.com/wA8pY9dS 
[08:26:49] *** Quits: strcat (strcat@moz-54F7FD49.cpe.net.cable.rogers.com) (Quit: WeeChat 0.4.2)
[08:27:51] <nielsle> I can use @-pointers, but I have a feeling that they are not neccesary.
[08:30:29] *** Joins: lenstr (lenstr@AF8EB999.6049B16A.85938D85.IP)
[08:31:19] <dbaupp> nielsle it's not directly possible, e.g. references in rust (i.e. & and &mut pointers) are normal values, and so can be stored in mutable/immutable slots freely (i.e. you can change what they point to)
[08:32:02] <dbaupp> also, you're not directly allowed to have 2 mutable references to the same thing, so you can't really have both r1 and r2
[08:32:13] *** Quits: lenstr (lenstr@AF8EB999.6049B16A.85938D85.IP) (Ping timeout)
[08:32:59] *** Quits: eternaleye (eternaleye@moz-5668AFCB.hsd1.wa.comcast.net) (Ping timeout)
[08:34:37] <nielsle> The idea is that r1 and r2 are immutable, but the container  contains unsafe code to make the mutable. So get_mut(r1: Reference) -> &mut int transforms an immutable reference to a mutable pointer.
[08:36:32] *** Joins: squiddy (squiddy@moz-8537813B.adsl.alicedsl.de)
[08:37:27] <nielsle> But thank you for the answer. I will try with @-pointers. 
[08:45:39] *** Quits: exobit (foo@moz-90D1B547.nycmny.fios.verizon.net) (Quit: My MacBook Pro has gone to sleep. ZZZzzz…)
[08:46:19] *** Joins: sebcrozet (sebcrozet@moz-A855F6C0.w82-127.abo.wanadoo.fr)
[08:47:26] *** Quits: hjr3 (hradtke@moz-E87BDF1F.socal.res.rr.com) (Quit: My MacBook has gone to sleep. ZZZzzz…)
[08:49:32] *** Joins: tiffany (kawaii@moz-28A8742A.dhcp.embarqhsd.net)
[08:51:17] *** Joins: mark_edward (quassel@moz-DCB0B750.lightspeed.cicril.sbcglobal.net)
[08:55:45] *** Quits: z0w0 (zack@moz-238C2341.lnse3.cha.bigpond.net.au) (Client exited)
[08:57:37] *** Joins: Jackneill (Jackneill@moz-224A92F.pool.digikabel.hu)
[09:05:23] *** Joins: tiffnya (kawaii@moz-28A8742A.dhcp.embarqhsd.net)
[09:05:31] *** Quits: tiffany (kawaii@moz-28A8742A.dhcp.embarqhsd.net) (Ping timeout)
[09:07:25] *** Quits: mark_edward (quassel@moz-DCB0B750.lightspeed.cicril.sbcglobal.net) (Client exited)
[09:08:42] *** Joins: Blub\w (wry@7E3BB9D.71150E1A.237AE2BA.IP)
[09:09:21] *** Joins: pyrac (pyrac@moz-84C91992.w90-60.abo.wanadoo.fr)
[09:13:13] *** Quits: nrc (nrc@7BE24E90.A5032A01.3CFC199D.IP) (Ping timeout)
[09:14:26] *** Joins: Ms2ger (Ms2ger@moz-6EEC6E4D.adsl-dyn.isp.belgacom.be)
[09:14:27] *** Quits: Jesin (Jessin_@moz-9BB5F6CF.cc.lehigh.edu) (Ping timeout)
[09:21:53] *** Quits: pyrac (pyrac@moz-84C91992.w90-60.abo.wanadoo.fr) (Quit: pyrac)
[09:23:07] *** Joins: pyrac (pyrac@moz-84C91992.w90-60.abo.wanadoo.fr)
[09:27:27] *** Joins: sweet_kid (Upasana@BE3CCB39.46D830F0.1228A288.IP)
[09:30:45] *** Joins: glennsl (textual@moz-6822C772.customer.cdi.no)
[09:30:56] *** Joins: lenstr (lenstr@AF8EB999.6049B16A.85938D85.IP)
[09:31:20] *** Quits: devbug (quassel@23AC5F12.9D950176.3655BBF5.IP) (Connection reset by peer)
[09:32:12] *** Joins: ross (ross@moz-5EA04060.br.br.cox.net)
[09:32:25] *** Joins: Jesin (Jessin_@moz-669C6A2A.cc.lehigh.edu)
[09:32:43] *** Quits: lenstr (lenstr@AF8EB999.6049B16A.85938D85.IP) (Ping timeout)
[09:36:24] *** Quits: sweet_kid (Upasana@BE3CCB39.46D830F0.1228A288.IP) (Quit: Leaving)
[09:38:10] *** Quits: glennsl (textual@moz-6822C772.customer.cdi.no) (Quit: My MacBook Pro has gone to sleep. ZZZzzz…)
[09:39:33] *** Quits: jensnockert (jensnocker@moz-5B057FF0.minc.se) (Input/output error)
[09:39:47] *** Joins: jensnockert (jensnocker@moz-5B057FF0.minc.se)
[09:41:13] *** Quits: boredomist (ruqs@B16F530C.DC641F2C.BCAEBB33.IP) (Ping timeout)
[09:42:24] *** Joins: mikezaby (mikezaby@moz-B26868E.home.otenet.gr)
[09:43:07] *** Quits: Jesin (Jessin_@moz-669C6A2A.cc.lehigh.edu) (Ping timeout)
[09:44:24] *** Quits: avsej (avsej@D9A610B8.4841F515.FB33447D.IP) (Ping timeout)
[09:46:06] *** Joins: bytewise (bytewise@moz-E32D3378.eduroam.rwth-aachen.de)
[09:53:13] *** Quits: ofeldt (ofeldt@moz-4D678086.dip0.t-ipconnect.de) (Ping timeout)
[09:56:42] *** Joins: ofeldt (ofeldt@moz-29DC8EDC.dip0.t-ipconnect.de)
[09:56:55] *** Joins: quasisphere (btw@DC685DC2.94302614.1D0D91FF.IP)
[09:58:48] *** Joins: Jesin (Jessin_@moz-9BB5F6CF.cc.lehigh.edu)
[10:00:32] *** Quits: sebcrozet (sebcrozet@moz-A855F6C0.w82-127.abo.wanadoo.fr) (Ping timeout)
[10:02:44] *** Quits: ofeldt (ofeldt@moz-29DC8EDC.dip0.t-ipconnect.de) (Ping timeout)
[10:03:21] *** Quits: pyrac (pyrac@moz-84C91992.w90-60.abo.wanadoo.fr) (Quit: pyrac)
[10:03:30] *** Joins: spider-mario (spidermari@moz-81131DB6.fbx.proxad.net)
[10:04:32] *** Joins: sebcrozet (sebcrozet@moz-87D51607.w80-13.abo.wanadoo.fr)
[10:06:13] *** Joins: ofeldt (ofeldt@moz-29DC8EDC.dip0.t-ipconnect.de)
[10:07:58] *** Quits: ofeldt (ofeldt@moz-29DC8EDC.dip0.t-ipconnect.de) (Ping timeout)
[10:08:31] *** Quits: mikezaby (mikezaby@moz-B26868E.home.otenet.gr) (Input/output error)
[10:09:59] *** Joins: lenstr (lenstr@AF8EB999.6049B16A.85938D85.IP)
[10:11:13] *** Joins: ofeldt (ofeldt@moz-29DC8EDC.dip0.t-ipconnect.de)
[10:12:53] *** Joins: pyrac (pyrac@moz-84C91992.w90-60.abo.wanadoo.fr)
[10:16:29] *** Joins: moostik (Icedove@moz-A9D666E7.w92-151.abo.wanadoo.fr)
[10:26:06] *** Joins: pheleas_frog (Mibbit@moz-E18DD580.hsd1.fl.comcast.net)
[10:26:48] *** Quits: kode-crypt (chatzilla@F63B62E8.8AE8A320.7C0F3359.IP) (Ping timeout)
[10:27:01] *** Quits: pheleas_frog (Mibbit@moz-E18DD580.hsd1.fl.comcast.net) (Quit: http://www.mibbit.com ajax IRC Client)
[10:27:40] *** Joins: kode-crypt (chatzilla@9BE163B0.70578880.F102451D.IP)
[10:35:26] *** Quits: lenstr (lenstr@AF8EB999.6049B16A.85938D85.IP) (Client exited)
[10:35:49] *** Joins: lenstr (lenstr@AF8EB999.6049B16A.85938D85.IP)
[10:37:41] *** Quits: lenstr (lenstr@AF8EB999.6049B16A.85938D85.IP) (Ping timeout)
[10:42:46] *** Joins: mukilan (quassel@2AF0BA32.5CDB92DC.520CDC98.IP)
[10:42:49] *** mukilan is now known as pseudoku
[10:44:06] <pseudoku> Hi! I'm trying to write a macro rule to map nested lists in a variant type. i'm not sure what the problem is with the macro rule. could someone help please...https://gist.github.com/anonymous/7277650
[10:47:51] <dbaupp> pseudoku: I think the problem is 'list(str)' is a single token (or something like that)
[10:48:03] <dbaupp> if you change rest to be tt (token tree) it might work
[10:48:18] <dbaupp> i.e. (list($rest:tt), $val:expr) => ...
[10:48:59] <pseudoku> dbaupp: i tried that already, but i got the error: no rules expected the token '('
[10:49:30] <pseudoku>  extract!(list(list(str)), *bval);
[10:49:30] <pseudoku>                  \
[10:49:55] <dbaupp> hm
[10:50:11] <dbaupp> list(($rest:tt)) ?
[10:50:16] * dbaupp is just guessing
[10:51:13] <pseudoku> dbaupp: error: No rules expected the token: list
[10:51:24] <dbaupp> weird :(
[10:51:44] *** Quits: pyrac (pyrac@moz-84C91992.w90-60.abo.wanadoo.fr) (Quit: pyrac)
[10:51:46] <dbaupp> ... the matching algorithm could definitely be improved in a few places
[10:52:06] <pseudoku> should i change the order of the invocations clauses?
[10:52:49] <pseudoku> nope, still doesn't work
[10:52:59] <benh> ...There's a bug with "no rules expected the token: <identifier>" when identifier is a local variable in scope at the call site...
[10:53:37] <pseudoku> benh, but the fragment i'm matching has type expr...does it not matter?
[10:54:05] <benh> i dunno
[10:55:05] <dbaupp> oh, yeah, `let` hygiene broke some things
[10:55:15] <dbaupp> pseudoku: do you have a `let list = ...` somewhere?
[10:56:00] <pseudoku> nope :(
[10:58:33] *** Joins: gavinb (gavinb@moz-9EC182F0.lowrp3.vic.optusnet.com.au)
[11:02:24] *** Joins: victorporof (victorporo@733111D7.F5F0D9CD.9B1E38F4.IP)
[11:03:07] *** Joins: donri (donri@moz-9BB61102.tbcn.telia.com)
[11:04:46] *** Joins: exobit (foo@moz-90D1B547.nycmny.fios.verizon.net)
[11:05:00] <dbaupp> pseudoku: does it work if you do something like ($val:expr, list $rest:tt) => ..., and call it like `extract!(foo, list list str)`?
[11:05:33] <pseudoku> dbaupp: i'll try that
[11:06:29] *** Joins: lenstr (lenstr@AF8EB999.6049B16A.85938D85.IP)
[11:06:39] *** Joins: mikezaby (mikezaby@moz-B26868E.home.otenet.gr)
[11:08:23] *** Quits: lenstr (lenstr@AF8EB999.6049B16A.85938D85.IP) (Ping timeout)
[11:08:35] <pseudoku> dbaupp: no, error: No rules expected the token: str . and it not even parse the outer level
[11:09:02] <dbaupp> ah, you probably need $(rest:tt)*
[11:09:11] <dbaupp> I mean, $($rest:tt)*
[11:09:35] <dbaupp> oh, that's probably the problem with the `list(list(str))` version too
[11:10:09] <dbaupp> a tt is something like `list` or `( str )`, so a single $rest:tt will parse just the first one.
[11:10:16] <dbaupp> i.e. list.
[11:10:46] <dbaupp> so I guess `list($($rest:tt)*), $val:expr` should work too.
[11:13:08] *** Quits: jeffdb (jeff@moz-ED35AD97.hsd1.ca.comcast.net) (Quit: jeffdb)
[11:16:04] *** Joins: findow (Mibbit@moz-6C393FDD.rev.numericable.fr)
[11:16:27] *** Quits: findow (Mibbit@moz-6C393FDD.rev.numericable.fr) (Quit: http://www.mibbit.com ajax IRC Client)
[11:16:34] <pseudoku> dbaupp i tried $($rest)+ since i need atleast one token as rest, but still got error: Local ambiguity: multiple parsing options: built-in NTs tt ('rest') or 1 other options.
[11:16:43] *** Joins: james4k (james@moz-E7990244.consolidated.net)
[11:17:01] <pseudoku> i meant $($rest:tt)+
[11:18:37] *** Quits: james4k (james@moz-E7990244.consolidated.net) (Ping timeout)
[11:19:45] <dbaupp> eurgh, yuck. I hate that one
[11:19:49] *** Joins: MrFahrenheit (RageOfThou@3FEF494C.29C984D5.783DEDCA.IP)
[11:20:17] <dbaupp> I think one way to resolve it is to put more brackets/parens around things, but I've never really got to work reliably :(
[11:20:38] *** Quits: parcha (quassel@moz-A9A9F340.hsd1.ma.comcast.net) (Ping timeout)
[11:20:49] *** Joins: parcha (quassel@moz-A9A9F340.hsd1.ma.comcast.net)
[11:22:02] *** Joins: DeTeam (DeTeam@moz-974A5FAE.dyn.broadband.iskratelecom.ru)
[11:22:34] <pseudoku> dbaupp: or i think i could try the list!(list!(str!(val)))... but it looks ugly
[11:24:37] <pseudoku> oh wait it that won't work
[11:25:04] *** Joins: Cromulent (Cromulent@moz-C2470BE2.cable.virginm.net)
[11:25:05] *** Joins: nkoep (nik@moz-17B4884B.pool.mediaways.net)
[11:26:56] *** Joins: Ferreus (ferreus@moz-870D435F.pools.arcor-ip.net)
[11:28:16] *** Joins: maik (maik@moz-BDF2085A.dip0.t-ipconnect.de)
[11:30:36] *** Quits: maik (maik@moz-BDF2085A.dip0.t-ipconnect.de) (Ping timeout)
[11:34:25] *** Joins: Diamond (dick@moz-80556682.ks.ks.cox.net)
[11:34:29] *** Quits: kode-crypt (chatzilla@9BE163B0.70578880.F102451D.IP) (Connection reset by peer)
[11:34:29] <pseudoku> dbaupp: got it to work with (list|$($rest:tt)|+, val) =>
[11:34:53] <pseudoku> although i have to do extract!(list|list|str, val)
[11:35:38] *** Quits: gavinb (gavinb@moz-9EC182F0.lowrp3.vic.optusnet.com.au) (Quit: gavinb)
[11:36:39] *** Joins: askalski (akuda@moz-A2FA9AA0.neoplus.adsl.tpnet.pl)
[11:38:12] <dbaupp> pseudoku: oh, neat
[11:38:42] <dbaupp> that's not so bad (and it has the nice property of working, too, which is always convenient).
[11:39:17] <pseudoku> dbaupp: but i still feel list(list(str)) should be possible... is it a bug or a limitation of the macro system?
[11:42:03] <dbaupp> pseudoku: I'd think it's a bug (but I don't know enough to be sure that it's not a fundamental limitation)
[11:42:19] *** Quits: parcha (quassel@moz-A9A9F340.hsd1.ma.comcast.net) (Ping timeout)
[11:42:55] *** Quits: Excureo (c@moz-EB93D257.static.knwc.wa.charter.com) (Ping timeout)
[11:43:03] <pseudoku> dbaupp: i just tried if i could do something like list|list|~str, but it treats the ~ as a separate token. i too think it is a bug
[11:43:59] *** Joins: parcha (quassel@moz-A9A9F340.hsd1.ma.comcast.net)
[11:44:44] *** Joins: Excureo (c@moz-EB93D257.static.knwc.wa.charter.com)
[11:45:32] <dbaupp> pseudoku: that isn't a bug, ~ is a separate token
[11:46:44] <pseudoku> dbaupp: ha...so is there a fragment type like tt but which says rest of the literal string?
[11:48:58] <dbaupp> pseudoku: you mean something like "foo"?
[11:49:04] *** Quits: tgummerer (tgummerer@moz-582025B2.members.linode.com) (Quit: Coyote finally caught me)
[11:49:13] <dbaupp> that's covered by tt or expr.
[11:51:00] <pseudoku> whats the difference between token trees and expressions?
[11:54:12] <dbaupp> from a macros point of view, token trees are literally just treated as a list of tokens (which means they can only be passed into other macro invocations), while expressions are actually parsed into an Expr variant of the AST, so can only be used in places where the parser would normally expect an expression
[11:54:32] *** Joins: mihneadb (mihneadb@4A8952C.AE58154E.4A6B528C.IP)
[11:54:46] *** Joins: maik (maik@moz-BDF2085A.dip0.t-ipconnect.de)
[11:54:54] <dbaupp> e.g. not a place where it expects raw tokens (like when doing the `list($..)` match as you wrote before)
[11:55:26] *** Quits: mikezaby (mikezaby@moz-B26868E.home.otenet.gr) (Input/output error)
[11:55:30] <pseudoku> dbaupp: got it...thanks
[11:59:34] *** Quits: blank_name (blank_name@FAB53C88.7071B2C8.31EC03F3.IP) (Ping timeout)
[12:00:02] *** Joins: notmatt (notmatt@moz-9FB2565E.vc.shawcable.net)
[12:01:49] *** Quits: notmatt (notmatt@moz-9FB2565E.vc.shawcable.net) (Ping timeout)
[12:11:54] *** Joins: HollyRain (HollyRain@moz-50A83091.dyn.user.ono.com)
[12:12:16] *** Quits: DeTeam (DeTeam@moz-974A5FAE.dyn.broadband.iskratelecom.ru) (Quit: DeTeam)
[12:12:22] <HollyRain> if you do a port (of a program or library) from a language to other one, do you have to use the same license than the original source?
[12:13:28] *** Joins: blank_name (blank_name@FAB53C88.7071B2C8.31EC03F3.IP)
[12:14:40] <tiffnya> it seems as though it's not a well defined case
[12:14:45] *** tiffnya is now known as tiffany
[12:14:51] <tiffany> what license is it under?
[12:15:33] *** Quits: maik (maik@moz-BDF2085A.dip0.t-ipconnect.de) (Ping timeout)
[12:15:51] *** Quits: ross (ross@moz-5EA04060.br.br.cox.net) (Quit: )
[12:16:17] <tiffany> it seems to qualify as a derivative work, and derivative works depend on the license
[12:16:22] <tiffany> in the case of gpl, it would have to remain gpl
[12:16:39] <HollyRain> it makes sense, thanks
[12:17:16] <tiffany> I'm not a lawyer though
[12:17:27] <tiffany> if you're really worried about it, contact the author
[12:17:53] *** Quits: ofeldt (ofeldt@moz-29DC8EDC.dip0.t-ipconnect.de) (Ping timeout)
[12:20:12] *** Quits: HollyRain (HollyRain@moz-50A83091.dyn.user.ono.com) (Quit: bye, bye)
[12:20:46] *** Joins: pnkfelix (pnkfelix@moz-43495417.fbx.proxad.net)
[12:20:46] *** ChanServ sets mode: +o pnkfelix
[12:21:25] *** Joins: ofeldt (ofeldt@moz-29DC8EDC.dip0.t-ipconnect.de)
[12:21:43] *** Joins: gavinb (gavinb@moz-9EC182F0.lowrp3.vic.optusnet.com.au)
[12:25:36] *** Quits: bytewise (bytewise@moz-E32D3378.eduroam.rwth-aachen.de) (Quit: Leaving)
[12:26:05] *** Joins: CyBeRKeL (cyber@E6A1FD6F.BE88DC8C.9C1C15C3.IP)
[12:27:02] *** Joins: alonlevy (alon@moz-B0E66DB7.static.bezeqint.net)
[12:31:27] *** Quits: Ms2ger (Ms2ger@moz-6EEC6E4D.adsl-dyn.isp.belgacom.be) (Quit: bbl)
[12:31:27] *** Joins: Earnestly (earnest@38FE72A5.82423D8F.BFD1ABFD.IP)
[12:34:27] *** Quits: saati (s@moz-11469F61.harmless.hu) (Ping timeout)
[12:38:05] *** Joins: DeTeam (DeTeam@moz-974A5FAE.dyn.broadband.iskratelecom.ru)
[12:38:09] *** Joins: canhtak (canhtak@moz-A161DED8.wl.t.ulaval.ca)
[12:38:53] *** Quits: moostik (Icedove@moz-A9D666E7.w92-151.abo.wanadoo.fr) (Ping timeout)
[12:43:02] *** Joins: saati (s@moz-11469F61.harmless.hu)
[12:44:36] *** Quits: gavinb (gavinb@moz-9EC182F0.lowrp3.vic.optusnet.com.au) (Quit: gavinb)
[12:47:29] *** Quits: jensnockert (jensnocker@moz-5B057FF0.minc.se) (Ping timeout)
[12:48:17] *** Joins: pyrac (pyrac@moz-84C91992.w90-60.abo.wanadoo.fr)
[12:49:17] *** Quits: Sharp (Sharp@moz-7B61DF4.dsl.static.sonic.net) (Quit: Sharp)
[12:52:15] *** Quits: sebcrozet (sebcrozet@moz-87D51607.w80-13.abo.wanadoo.fr) (Quit: Gone)
[12:52:58] *** Quits: exobit (foo@moz-90D1B547.nycmny.fios.verizon.net) (Quit: Textual IRC Client: www.textualapp.com)
[12:54:11] *** Joins: jensnockert (jensnocker@moz-5B057FF0.minc.se)
[12:54:31] *** Joins: moostik (Icedove@moz-A9D666E7.w92-151.abo.wanadoo.fr)
[12:56:47] *** Joins: freezerburnv (freezerbur@moz-C5EF929C.washdc.fios.verizon.net)
[13:00:56] *** Quits: askalski (akuda@moz-A2FA9AA0.neoplus.adsl.tpnet.pl) (Quit: Wychodzi)
[13:03:58] <pseudoku> is there any difference between doing match refToEnumVal { &Variant => ... } vs match *refToEnumVal { Variant => ... } ?
[13:05:16] *** Quits: pyrac (pyrac@moz-84C91992.w90-60.abo.wanadoo.fr) (Quit: pyrac)
[13:05:43] <dbaupp> pseudoku: not particularly, but the match *foo { Variant => ... } one is the convention
[13:06:29] *** Quits: DeTeam (DeTeam@moz-974A5FAE.dyn.broadband.iskratelecom.ru) (Quit: DeTeam)
[13:07:12] <pseudoku> dbaupp: ha...is there a specific reason the other syntax is allowed?...nested references?
[13:07:27] <ChrisMorgan> dbaupp: "not particularly"? My understanding is that they are identical functionally; is that correct or not?
[13:08:46] <dbaupp> ChrisMorgan: semantically they are identical, not sure if they get codegened identically.
[13:09:15] <dbaupp> pseudoku: because `&x` is a valid pattern, no special treatment (so I guess the answer is yes to nested references)
[13:09:45] *** Joins: sweet_kid (Upasana@D1DDC9CD.1F5862DC.388CF16F.IP)
[13:09:52] *** Joins: avsej (avsej@EED21AB8.C2F3859F.8AE46547.IP)
[13:10:52] <pseudoku> dbaupp: "codegened identically"...is there more than one way? 
[13:12:07] *** Quits: freezerburnv (freezerbur@moz-C5EF929C.washdc.fios.verizon.net) (Quit: freezerburnv)
[13:12:08] <ChrisMorgan> pseudoku: sure, there are an infinite number of ways to achieve the same thing.
[13:13:22] <pseudoku> ChrisMorgan: in this particular case however, i may be wrong, there seems to be only one way...fetch the tag by dereferencing the pointer...right?
[13:13:29] *** Joins: freezerburnv (freezerbur@moz-C5EF929C.washdc.fios.verizon.net)
[13:15:49] *** Quits: freezerburnv (freezerbur@moz-C5EF929C.washdc.fios.verizon.net) (Quit: freezerburnv)
[13:15:49] <tiffany> pseudoku: I think that if you're repeating the same pattern multiple times in a match statement (like an &) then you should just put it in the expression to match
[13:16:22] <tiffany> I always dereference pointers before doing a match
[13:17:25] <pseudoku> tiffany: so its just an explicit optimization...kinda like ++i vs i++ ?
[13:17:38] <tiffany> no, it decreases verbosity
[13:18:03] <tiffany> if you match x {&Foo => ..., &Bar => ...} then you're repeating the fact it's a borrowed pointer multiple times
[13:18:12] <tiffany> it's an irrelevant detail
[13:18:58] <pseudoku> tiffany: but still the optimizer can reduce it to a single dereference, can't it?
[13:19:07] *** Joins: freezerburnv (freezerbur@moz-C5EF929C.washdc.fios.verizon.net)
[13:19:28] <tiffany> a more obvious example is if you have a struct {x: int, y: char}, match my_struct {MyStruct {x: _, y: 'a'} => ..., MyStruct {x: _, y: 'b'} => ...}
[13:19:32] <tiffany> you could just match my_struct.y
[13:19:48] <tiffany> it can optimize it sure, that's not what I'm considering
[13:20:10] <dbaupp> ChrisMorgan, pseudoku: fwiw it appears that the codegen for `match *x` and `&x =>` are identical (not that that means much, since that's just an implementation detail)
[13:21:02] <pseudoku> tiffany: got it. thanks
[13:21:36] <pseudoku> dbaupp: thanks.
[13:21:37] <tiffany> I think DRY applies
[13:21:52] *** Quits: heftig (heftig@moz-74DC22BF.dip0.t-ipconnect.de) (Quit: Quitting)
[13:22:29] * dbaupp agrees with tiffany
[13:22:52] <dbaupp> the semantics are the same either way, so might as well reduce the amount of irrelevant repetition.
[13:23:09] *** Joins: steffenomak (steffenoma@moz-FB0A4BEB.student.uu.se)
[13:26:57] *** Joins: dherman (dherman@moz-6CA476B1.hsd1.ca.comcast.net)
[13:26:57] *** ChanServ sets mode: +ao dherman dherman
[13:27:15] *** sam113101 is now known as sam113101_afk
[13:28:31] *** Quits: pnkfelix (pnkfelix@moz-43495417.fbx.proxad.net) (Quit: Leaving.)
[13:29:40] *** Quits: squiddy (squiddy@moz-8537813B.adsl.alicedsl.de) (Ping timeout)
[13:31:54] *** Quits: nielsle (nielsle@moz-C46DA772.boa.fiberby.dk) (Ping timeout)
[13:35:26] *** Quits: jensnockert (jensnocker@moz-5B057FF0.minc.se) (Input/output error)
[13:50:11] <pseudoku> what's the difference between let v = ~[5,6]; v.map() and v.iter().map()
[13:51:44] *** Quits: alonlevy (alon@moz-B0E66DB7.static.bezeqint.net) (Ping timeout)
[13:52:10] <eddyb9> I would think the former is a shorthand for the latter. you can check the docs/code if you want
[13:53:45] *** Joins: redbrain (redbrain@moz-A78C4B0A.vm.bytemark.co.uk)
[13:54:15] <pseudoku> eddyb9: i could not find the doc for the v.map method. however i found that the difference is for v.iter().map() i have to call collect() expicitly to turn it into a vector again
[13:54:59] <eddyb9> ah, so v.map probably does v.iter().map().collect()
[13:55:46] <pseudoku> eddyb9: v.map is in trait ImmutableVector and is deprecated 
[13:56:05] <redbrain> if i have a string i can iterate with mystring [uint]; and it gives me a u8 as the char. i want to do: let mychar = mystr[1]; match mychar { 'x'=>...  => ... } but that doesnt work
[13:57:27] <eddyb9> redbrain: you need .char_at() or something like that, not sure
[13:57:41] <redbrain> eddyb9: ah ok cool thanks
[13:58:35] <eddyb9> but I'm not sure that's going to work
[13:59:03] *** Quits: pcdummy (pcdummy@moz-CF4CA865.page4me.ch) (Ping timeout)
[13:59:10] <eddyb9> redbrain: the best solution here would be to use a char iterator, if that's what you need
[13:59:46] <eddyb9> the methods on str working with chars can be O(N) instead of O(1), because of utf8
[14:00:15] *** Quits: toshok (toshok@moz-43741342.cat) (Ping timeout)
[14:00:46] <eddyb9> you can get rid of the extra cost if you don't need random access
[14:02:20] *** Joins: nielsle (nielsle@moz-C46DA772.boa.fiberby.dk)
[14:03:10] *** Joins: pcdummy (pcdummy@moz-CF4CA865.page4me.ch)
[14:03:16] *** Quits: noam_ (noam@F6B530A7.720527A7.416762B.IP) (Ping timeout)
[14:03:43] *** Quits: dherman (dherman@moz-6CA476B1.hsd1.ca.comcast.net) (Quit: dherman)
[14:04:17] <eddyb9> redbrain: this will work: for mychar in mystr.iter()
[14:04:26] *** Joins: kvark (Mibbit@moz-F30E0473.cpe.net.cable.rogers.com)
[14:05:53] <redbrain> ah ok cool thanks
[14:05:59] <redbrain> yeah i have it working on
[14:06:01] <redbrain> now*
[14:07:17] *** Joins: sankha93 (Instantbir@7061CD01.D6BD0D91.22D41759.IP)
[14:07:28] *** Joins: jensnockert (jensnocker@moz-5B057FF0.minc.se)
[14:08:30] <kvark> I'm trying to use new io::file stuff, the example here "http://static.rust-lang.org/doc/master/std/rt/io/index.html" shows a call to File::new, but I can't find it in the interface
[14:08:36] <kvark> where is File::new?
[14:09:04] *** Quits: canhtak (canhtak@moz-A161DED8.wl.t.ulaval.ca) (Quit: canhtak)
[14:09:27] *** Joins: heftig (heftig@moz-74DC22BF.dip0.t-ipconnect.de)
[14:10:24] <eddyb9> redbrain: oh, I found what I wanted, if you can't use for-in: http://static.rust-lang.org/doc/master/std/str/trait.StrSlice.html#tymethod.char_range_at
[14:10:46] <eddyb9> the example should speak for itself :P
[14:12:19] * dbaupp dislikes that example, since one should use .char_offset_iter() for that
[14:13:25] <eddyb9> dbaupp: you might not always be able to use a for-in loop
[14:13:57] *** Joins: lfox (lfox@moz-1CED9133.nycmny.east.verizon.net)
[14:14:22] <eddyb9> although... you can always pull from an iterator yourself. hmm
[14:16:23] *** Joins: noam (noam@F6B530A7.720527A7.416762B.IP)
[14:17:27] *** Quits: jensnockert (jensnocker@moz-5B057FF0.minc.se) (Input/output error)
[14:17:48] *** Quits: heftig (heftig@moz-74DC22BF.dip0.t-ipconnect.de) (Input/output error)
[14:18:02] *** Joins: heftig (heftig@moz-74DC22BF.dip0.t-ipconnect.de)
[14:19:19] *** Joins: canhtak (canhtak@moz-A161DED8.wl.t.ulaval.ca)
[14:22:56] *** Quits: jeyraof_ (uid6796@moz-31ABA2C0.irccloud.com) (Input/output error)
[14:22:57] *** Quits: Aetherspawn_BNC (uid6924@moz-31ABA2C0.irccloud.com) (Broken pipe)
[14:22:57] *** Quits: dnyy (uid2106@moz-31ABA2C0.irccloud.com) (Broken pipe)
[14:23:11] <dbaupp> eddyb9: yes, it's just normally safer to use the iterators rather than have to manage stepping state correctly
[14:23:20] *** Joins: jensnock_ (jensnocker@moz-5B057FF0.minc.se)
[14:24:12] *** Joins: pnkfelix (pnkfelix@moz-43495417.fbx.proxad.net)
[14:24:12] *** ChanServ sets mode: +o pnkfelix
[14:25:59] *** Quits: pnkfelix (pnkfelix@moz-43495417.fbx.proxad.net) (Ping timeout)
[14:28:04] *** Joins: alonlevy (alon@16E94D1.80C6E391.EFBC6494.IP)
[14:31:29] *** Quits: kvark (Mibbit@moz-F30E0473.cpe.net.cable.rogers.com) (Quit: http://www.mibbit.com ajax IRC Client)
[14:32:27] *** Joins: mib_6ea1qt (Mibbit@873BB8F6.D4BA1E0E.3BD9FE04.IP)
[14:32:34] *** Joins: dherman (dherman@moz-6CA476B1.hsd1.ca.comcast.net)
[14:32:34] *** ChanServ sets mode: +ao dherman dherman
[14:32:42] *** Joins: Sorella (quildreen@9D963F5D.DF5D8AE7.54BCAB54.IP)
[14:34:09] *** Quits: jensnock_ (jensnocker@moz-5B057FF0.minc.se) (Input/output error)
[14:35:56] *** Joins: bytewise (bytewise@moz-E32D3378.eduroam.rwth-aachen.de)
[14:41:00] *** Joins: dnyy (uid2106@moz-31ABA2C0.irccloud.com)
[14:45:01] *** Quits: Jesin (Jessin_@moz-9BB5F6CF.cc.lehigh.edu) (Ping timeout)
[14:45:08] *** Joins: jeyraof_ (uid6796@moz-31ABA2C0.irccloud.com)
[14:45:16] *** Joins: Aetherspawn_BNC (uid6924@moz-31ABA2C0.irccloud.com)
[14:50:01] *** Joins: mib_j9lg7g (Mibbit@moz-2919D62C.dynamic.hinet.net)
[14:50:03] *** Quits: mib_j9lg7g (Mibbit@moz-2919D62C.dynamic.hinet.net) (Quit: mib_j9lg7g)
[14:53:17] *** Quits: LimeBurst (me@247D1419.D73964AC.27A8748.IP) (Quit: leaving)
[14:53:23] *** Joins: LimeBurst (me@247D1419.D73964AC.27A8748.IP)
[14:54:19] *** Joins: pnkfelix (pnkfelix@moz-43495417.fbx.proxad.net)
[14:54:19] *** ChanServ sets mode: +o pnkfelix
[14:55:17] *** Quits: ChrisMorgan (chris@moz-6AC741CA.static.tpgi.com.au) (Ping timeout)
[14:55:28] *** Quits: sweet_kid (Upasana@D1DDC9CD.1F5862DC.388CF16F.IP) (Quit: Leaving)
[14:56:07] *** Quits: pnkfelix (pnkfelix@moz-43495417.fbx.proxad.net) (Ping timeout)
[15:00:49] *** Quits: avsej (avsej@EED21AB8.C2F3859F.8AE46547.IP) (Ping timeout)
[15:02:38] *** Joins: glennsl (textual@moz-6822C772.customer.cdi.no)
[15:02:53] *** Joins: Jesin (Jessin_@moz-669C6A2A.cc.lehigh.edu)
[15:03:45] *** Joins: kvark (Mibbit@moz-F30E0473.cpe.net.cable.rogers.com)
[15:06:36] *** Joins: cubic (cubic@moz-80241A3A.mc.videotron.ca)
[15:07:03] *** Joins: eddyb (eddy@FE23D96E.F33C1089.FB866788.IP)
[15:07:55] *** Joins: maik (maik@moz-BDF2085A.dip0.t-ipconnect.de)
[15:08:15] *** sam113101_afk is now known as sam113101
[15:13:34] *** Joins: samnardoni (samnardoni@FC9A45BE.3393236F.BFD1ABFD.IP)
[15:14:14] *** Quits: eddyb9 (eddy@FE23D96E.F33C1089.FB866788.IP) (Quit: Leaving)
[15:15:12] <samnardoni> What's considered more idiomatic: `use std::task; task::spawn()` or `use std::task::spawn; spawn()`?
[15:15:51] *** Joins: avsej (avsej@681E7E71.CBA75883.E17286EB.IP)
[15:16:03] <kimundi> No idea. I usually do the latter though
[15:16:58] *** Joins: Sharp (Sharp@moz-7B61DF4.dsl.static.sonic.net)
[15:18:28] *** Joins: james4k (james@moz-E7990244.consolidated.net)
[15:19:35] *** Quits: Sharp (Sharp@moz-7B61DF4.dsl.static.sonic.net) (Quit: Sharp)
[15:20:14] *** Quits: james4k (james@moz-E7990244.consolidated.net) (Ping timeout)
[15:22:01] <samnardoni> It'd be nice if there was a consensus on this issue. It helps for naming. e.g. should it be udp::Socket or udp::UdpSocket...
[15:22:31] *** Joins: jeffdb (jeff@moz-ED35AD97.hsd1.ca.comcast.net)
[15:22:49] <kvark> not a question for me, definitely udp::Socket
[15:23:30] *** Quits: steffenomak (steffenoma@moz-FB0A4BEB.student.uu.se) (Ping timeout)
[15:23:54] <Siyo> I don't see why you would want to prefix class names when you have proper namespace support in the language
[15:24:45] *** Joins: voxpopuli (fanservice@moz-CEF3689A.hsd1.pa.comcast.net)
[15:24:45] <samnardoni> kvark, Siyo: for what it's worth, std::rt::io::net::udp::UdpSocket is how it currently is in the std lib
[15:25:12] <kvark> so we've got to votes to change that already then :)
[15:25:16] <kvark> *two
[15:25:31] <samnardoni> make that three
[15:25:43] <Siyo> yeah just my opinion, I don't know what the rust censensus is :)
[15:26:17] *** Joins: tgummerer (tgummerer@moz-582025B2.members.linode.com)
[15:29:00] *** Quits: lfox (lfox@moz-1CED9133.nycmny.east.verizon.net) (Quit: ZZZzzz…)
[15:29:26] *** Quits: mib_6ea1qt (Mibbit@873BB8F6.D4BA1E0E.3BD9FE04.IP) (Quit: http://www.mibbit.com ajax IRC Client)
[15:34:03] *** Joins: Yeri (jasonjasmi@BA0CD88C.B2E00889.31F69D78.IP)
[15:36:28] *** Quits: reyre (reyre@moz-89E9865B.com) (Quit: ZNC - http://znc.in)
[15:37:28] *** Joins: reyre (reyre@moz-89E9865B.com)
[15:37:40] *** Joins: doomlord_ (servitor@moz-4625DF14.range86-184.btcentralplus.com)
[15:37:46] *** Joins: Engineer (engineer@moz-C4BE28E4.c3-0.upd-ubr1.trpr-upd.pa.cable.rcn.com)
[15:38:12] *** Joins: hjr3 (hradtke@moz-E87BDF1F.socal.res.rr.com)
[15:39:17] *** Quits: Kxepal (Miranda@moz-B0668C07.pppoe.mtu-net.ru) (Ping timeout)
[15:41:28] *** Joins: FrozenCow (FrozenCow@moz-B2DF4929.chello.nl)
[15:42:23] *** Joins: Kxepal (Miranda@moz-4C240DE4.pppoe.mtu-net.ru)
[15:44:37] *** Joins: BizarreCake (BizarreCak@moz-361FE9B2.dynamic.barak-online.net)
[15:45:33] *** Quits: moostik (Icedove@moz-A9D666E7.w92-151.abo.wanadoo.fr) (Ping timeout)
[15:46:44] *** Quits: sankha93 (Instantbir@7061CD01.D6BD0D91.22D41759.IP) (Ping timeout)
[15:47:06] *** Quits: mihneadb (mihneadb@4A8952C.AE58154E.4A6B528C.IP) (Quit: Computer gone to sleep - Zzzz...)
[15:48:18] *** Quits: Kxepal (Miranda@moz-4C240DE4.pppoe.mtu-net.ru) (Quit: Kxepal)
[15:48:49] *** Joins: Kxepal (Miranda@moz-4C240DE4.pppoe.mtu-net.ru)
[15:51:12] *** Joins: sankha93 (Instantbir@7061CD01.D6BD0D91.22D41759.IP)
[15:51:23] *** Joins: jmgrosen (jmgrosen@moz-848F6087.sb.sd.cox.net)
[15:54:03] *** Quits: bobthenameless (bobthename@moz-1C30D660.hsd1.wa.comcast.net) (Ping timeout)
[15:54:14] *** Quits: jst (quassel@moz-BBE3ABD.mv.mozilla.com) (Input/output error)
[15:54:33] *** Joins: pnkfelix (pnkfelix@moz-43495417.fbx.proxad.net)
[15:54:33] *** ChanServ sets mode: +o pnkfelix
[15:55:36] *** Quits: samnardoni (samnardoni@FC9A45BE.3393236F.BFD1ABFD.IP) (Client exited)
[15:55:57] *** Joins: samnardoni (samnardoni@FC9A45BE.3393236F.BFD1ABFD.IP)
[15:56:24] *** Quits: pnkfelix (pnkfelix@moz-43495417.fbx.proxad.net) (Ping timeout)
[15:57:39] *** Quits: samnardoni (samnardoni@FC9A45BE.3393236F.BFD1ABFD.IP) (Ping timeout)
[15:59:41] *** Joins: jxs (joaoxsouls@moz-A7EE0DAF.compute-1.amazonaws.com)
[16:00:53] *** Joins: jst (quassel@CB36FB4D.BE63433B.EE6E63A5.IP)
[16:01:01] *** Joins: earlzlap (earlz@moz-9E279EAD.neo.res.rr.com)
[16:02:24] *** Joins: samnardoni (samnardoni@FC9A45BE.3393236F.BFD1ABFD.IP)
[16:05:50] *** Quits: freezerburnv (freezerbur@moz-C5EF929C.washdc.fios.verizon.net) (Quit: freezerburnv)
[16:05:56] *** Quits: jxs (joaoxsouls@moz-A7EE0DAF.compute-1.amazonaws.com) (Quit: bye)
[16:06:19] *** Quits: samnardoni (samnardoni@FC9A45BE.3393236F.BFD1ABFD.IP) (Client exited)
[16:06:40] *** Joins: samnardoni (samnardoni@FC9A45BE.3393236F.BFD1ABFD.IP)
[16:08:03] *** Joins: anshin (anshin@CD85F10D.F21429E2.354459FA.IP)
[16:08:24] *** Quits: samnardoni (samnardoni@FC9A45BE.3393236F.BFD1ABFD.IP) (Ping timeout)
[16:09:05] *** Quits: canhtak (canhtak@moz-A161DED8.wl.t.ulaval.ca) (Quit: canhtak)
[16:09:10] *** Joins: samnardoni (samnardoni@FC9A45BE.3393236F.BFD1ABFD.IP)
[16:10:27] <zokier`> I like using fully qualified names, I guess it's a remnant of my cpp days
[16:10:42] *** Joins: jxs (joaoxsouls@moz-A7EE0DAF.compute-1.amazonaws.com)
[16:12:26] *** Quits: jst (quassel@CB36FB4D.BE63433B.EE6E63A5.IP) (Input/output error)
[16:12:36] *** Joins: jst (quassel@CB36FB4D.BE63433B.EE6E63A5.IP)
[16:12:47] *** Quits: jst (quassel@CB36FB4D.BE63433B.EE6E63A5.IP) (Input/output error)
[16:12:53] *** Joins: jensnockert (jensnocker@moz-5B057FF0.minc.se)
[16:13:37] *** Joins: jst (quassel@CB36FB4D.BE63433B.EE6E63A5.IP)
[16:15:38] *** Quits: jst (quassel@CB36FB4D.BE63433B.EE6E63A5.IP) (Ping timeout)
[16:17:37] *** Joins: reedlepee (Mibbit@9B9315E1.A6025CA.1C37C358.IP)
[16:18:56] *** Joins: jst (quassel@CB36FB4D.BE63433B.EE6E63A5.IP)
[16:19:39] *** Quits: parcha (quassel@moz-A9A9F340.hsd1.ma.comcast.net) (Ping timeout)
[16:20:34] *** Quits: Cromulent (Cromulent@moz-C2470BE2.cable.virginm.net) (Quit: KVIrc 4.2.0 Equilibrium http://www.kvirc.net/)
[16:20:43] *** Quits: jst (quassel@CB36FB4D.BE63433B.EE6E63A5.IP) (Ping timeout)
[16:21:10] *** Joins: moostik (Icedove@47C863C.ED2579B8.BCDF592F.IP)
[16:21:27] *** Joins: parcha (quassel@moz-A9A9F340.hsd1.ma.comcast.net)
[16:21:52] <doomlord_> i see a proposal on reddit for single-inheritance of structs ... is that a popular idea in the team or not
[16:23:33] *** Joins: pyrac (pyrac@moz-84C91992.w90-60.abo.wanadoo.fr)
[16:23:46] *** Joins: jst (quassel@CB36FB4D.BE63433B.EE6E63A5.IP)
[16:25:35] *** Quits: jst (quassel@CB36FB4D.BE63433B.EE6E63A5.IP) (Ping timeout)
[16:27:43] *** Joins: toshok (toshok@moz-43741342.cat)
[16:28:37] *** Joins: jst (quassel@CB36FB4D.BE63433B.EE6E63A5.IP)
[16:30:16] *** Quits: jxs (joaoxsouls@moz-A7EE0DAF.compute-1.amazonaws.com) (Quit: bye)
[16:30:22] *** Quits: jst (quassel@CB36FB4D.BE63433B.EE6E63A5.IP) (Ping timeout)
[16:30:48] *** Joins: jxs (joaoxsouls@moz-A7EE0DAF.compute-1.amazonaws.com)
[16:32:05] *** Joins: eternaleye (eternaleye@moz-5668AFCB.hsd1.wa.comcast.net)
[16:32:07] *** Joins: jst (quassel@moz-BBE3ABD.mv.mozilla.com)
[16:32:21] *** Quits: bjz (bjz@B398BE78.F804C29E.D35A31DF.IP) (Quit: ZZZzzz…)
[16:33:38] <redbrain> can you print enum's?
[16:34:07] <kimundi> SUre, if you use the right function/implement the right traits
[16:34:27] *** Quits: voxpopuli (fanservice@moz-CEF3689A.hsd1.pa.comcast.net) (Ping timeout)
[16:34:43] <kimundi> put a #[deriving(ToStr)] on the enum definition and you can do println(enum_value.to_str())
[16:35:09] <redbrain> ok will give it ago i have enum myenum { bla, foo, foobar }; could i let x:myenum = foobar; println(format!("{}", x))
[16:35:12] <kimundi> Or for quick unsafe debug output: println!("{:?}", enum_value)
[16:35:27] *** Quits: jxs (joaoxsouls@moz-A7EE0DAF.compute-1.amazonaws.com) (Quit: bye)
[16:35:54] <kimundi> For "{}" you need to implement std::fmt::Default for the enum naually, as we don't have a deriving mode for that yet
[16:35:58] *** Joins: jxs (joaoxsouls@moz-A7EE0DAF.compute-1.amazonaws.com)
[16:36:04] <kimundi> manually*
[16:36:06] <redbrain> ahh ok
[16:36:12] <redbrain> thanks loads
[16:37:44] *** Quits: samnardoni (samnardoni@FC9A45BE.3393236F.BFD1ABFD.IP) (Client exited)
[16:37:53] *** Quits: pyrac (pyrac@moz-84C91992.w90-60.abo.wanadoo.fr) (Quit: pyrac)
[16:38:05] *** Joins: samnardoni (samnardoni@FC9A45BE.3393236F.BFD1ABFD.IP)
[16:38:27] *** Quits: eevee (eevee@moz-7B6C48E3.evrt.wa.frontiernet.net) (Ping timeout)
[16:38:51] *** Quits: ksf (ksf@moz-913342DB.adsl.hansenet.de) (Quit: Leaving)
[16:39:21] *** Joins: pyrac (pyrac@moz-84C91992.w90-60.abo.wanadoo.fr)
[16:39:40] *** Quits: maik (maik@moz-BDF2085A.dip0.t-ipconnect.de) (Ping timeout)
[16:39:49] *** Quits: samnardoni (samnardoni@FC9A45BE.3393236F.BFD1ABFD.IP) (Ping timeout)
[16:41:03] *** Quits: sankha93 (Instantbir@7061CD01.D6BD0D91.22D41759.IP) (Ping timeout)
[16:41:53] *** Joins: sankha93 (Instantbir@7061CD01.D6BD0D91.22D41759.IP)
[16:41:56] <redbrain> whoo got my rust written lexer working
[16:42:01] <redbrain> first rust program working
[16:42:02] <redbrain> lol
[16:42:09] *** Joins: james4k (james@moz-E7990244.consolidated.net)
[16:42:17] <redbrain> its sooo nice
[16:44:02] *** Joins: samnardoni (samnardoni@FC9A45BE.3393236F.BFD1ABFD.IP)
[16:44:36] *** Joins: Ms2ger (Ms2ger@moz-6EEC6E4D.adsl-dyn.isp.belgacom.be)
[16:44:53] *** Quits: dherman (dherman@moz-6CA476B1.hsd1.ca.comcast.net) (Quit: dherman)
[16:45:23] *** Quits: jensnockert (jensnocker@moz-5B057FF0.minc.se) (Input/output error)
[16:46:26] *** Quits: reedlepee (Mibbit@9B9315E1.A6025CA.1C37C358.IP) (Quit: http://www.mibbit.com ajax IRC Client)
[16:47:38] *** Quits: JanC (janc@moz-9B741F51.dsl.scarlet.be) (Ping timeout)
[16:48:04] *** Quits: Jesin (Jessin_@moz-669C6A2A.cc.lehigh.edu) (Ping timeout)
[16:50:27] *** Joins: dab_ (Mibbit@C335B9F2.807CFFFA.53E421C3.IP)
[16:51:04] <dab_> Hi guys, I tried to install Rust on windows.. Followed two things.. a) Installed from the installer directly - And all I got was " Windows has stopped working" 
[16:51:20] <Ms2ger> Windows ever worked? ;)
[16:51:30] <dab_> then i took the build path and started building Rust as given here : https://github.com/mozilla/rust/wiki/Note-Building-Rust-Before-0.8-on-Windows-Systems
[16:51:54] <eddyb> dab_: that has "before 0.8" in the title
[16:51:59] <dab_> then finally after 4 hours or so of build, I dont see the bin folder in the new build rust folder.. any questions?
[16:52:08] <dab_> yea, but as 0.8 didn't work, I had to try that
[16:52:18] <dab_> sorry any suggestions*
[16:52:20] *** Joins: canhtak (canhtak@moz-A161DED8.wl.t.ulaval.ca)
[16:52:25] <eddyb> 0.8 is old :)
[16:52:36] <eddyb> isn't there a guide post-0.8?
[16:52:53] *** Quits: james4k (james@moz-E7990244.consolidated.net) (Ping timeout)
[16:52:56] <dab_> All i can see on github is the link to installer.. 
[16:53:01] <eddyb> dab_: after the build itself, there's a folder with a triplet in its name
[16:53:09] <kimundi> You want to go the other direction: use git master. Afaik windows build still involves some trickery, but it seems to work
[16:53:15] <dab_> link : https://github.com/mozilla/rust
[16:53:20] *** Joins: james4k (james@moz-E7990244.consolidated.net)
[16:53:30] <eddyb> dab_: oh, it's in the tutorial: i686-pc-mingw32/stage2/bin
[16:53:42] <eddyb> s/tutorial/the wiki page you linked/
[16:54:27] <dab_> aah okay, one more thing please, Should I do anything else than what is listed here : https://github.com/mozilla/rust (under windows section) for Rust to work?
[16:54:43] <dab_> Thanks guys for your time, I'm totally spent :(
[16:54:47] *** Joins: dherman (dherman@moz-6CA476B1.hsd1.ca.comcast.net)
[16:54:47] *** ChanServ sets mode: +ao dherman dherman
[16:55:04] <eddyb> dab_: "Enjoy!" :P
[16:55:16] *** Joins: pnkfelix (pnkfelix@moz-43495417.fbx.proxad.net)
[16:55:16] *** ChanServ sets mode: +o pnkfelix
[16:55:30] <kimundi> https://github.com/mozilla/rust/wiki/Note-getting-started-developing-Rust#windows
[16:55:41] <eddyb> dammit, I just about to link that
[16:55:47] <kimundi> :P
[16:56:33] <dab_> My GOD, again...
[16:56:44] <dab_> hmm, what's the easiest way?
[16:56:46] <dab_> Linux?
[16:57:00] *** Quits: pnkfelix (pnkfelix@moz-43495417.fbx.proxad.net) (Ping timeout)
[16:57:01] <kimundi> Do what's written there, or use linux :P
[16:57:30] <dab_> kimundi Thanks mate, I think now I should switch over to my linux :|
[16:57:51] <dab_> one last question, What time lines are we looking at when installing on Linux? :P Windows took close to 4.. 
[16:57:55] <kimundi> Doing development in a linux vm is quite manageable, provided you have enough physical memory. As a bonus point, after two months you are fed up enough to just switch to linux directly ;)
[16:58:09] <dab_> LOL
[16:58:21] *** Quits: jst (quassel@moz-BBE3ABD.mv.mozilla.com) (Input/output error)
[16:58:22] <kimundi> (Actually happend to me)
[16:58:25] <myname> who wnts to work with windows anyways?
[16:58:45] <kimundi> Build time depends on your cpu and system
[16:58:51] <dab_> Ah, I see..
[16:58:52] *** Joins: jst (quassel@CB36FB4D.BE63433B.EE6E63A5.IP)
[16:59:08] <kimundi> Also, on first build it has to build llvm too, which I think at least doubles the build time
[16:59:22] <dab_> okay..
[16:59:45] <dab_> Thanks guys.. Have a great day.. Its Diwali here, If you know that festival! Have fun!
[17:00:06] <kimundi> But you won't rebuild llvm that often after that, even if you regulary update and rebuild rust itself
[17:00:29] <kimundi> No idea what that is, but have fun! :)
[17:00:42] <dab_> :)
[17:01:10] <myname> just use a distribution with binary packages
[17:01:16] <kimundi> OH, right!
[17:01:23] *** Quits: jst (quassel@CB36FB4D.BE63433B.EE6E63A5.IP) (Ping timeout)
[17:01:37] <kimundi> If you just install ubuntu or arch, you can just use nightly prebuild packages
[17:01:47] <dab_> link please?
[17:01:51] <dab_> i'm running ubuntu
[17:01:53] <kimundi> Much easier if you don't want to actually work on the langauge itself :)
[17:02:32] *** Joins: JanC (janc@moz-F9B04454.dsl.scarlet.be)
[17:03:04] <kimundi> I think this is the right one: https://launchpad.net/~hansjorg/+archive/rust
[17:03:20] *** Joins: Jesin (Jessin_@moz-9BB5F6CF.cc.lehigh.edu)
[17:03:41] *** Joins: Sharp (Sharp@moz-7B61DF4.dsl.static.sonic.net)
[17:04:21] *** Joins: jst (quassel@CB36FB4D.BE63433B.EE6E63A5.IP)
[17:04:36] *** Joins: bjz (bjz@B398BE78.F804C29E.D35A31DF.IP)
[17:06:09] *** Quits: jst (quassel@CB36FB4D.BE63433B.EE6E63A5.IP) (Ping timeout)
[17:06:51] *** Quits: bjz (bjz@B398BE78.F804C29E.D35A31DF.IP) (Quit: ZZZzzz…)
[17:08:55] *** Joins: jst (quassel@CB36FB4D.BE63433B.EE6E63A5.IP)
[17:10:43] *** Quits: jst (quassel@CB36FB4D.BE63433B.EE6E63A5.IP) (Ping timeout)
[17:11:57] *** Quits: anri (solancile@moz-E49E7C4B.hsd1.wa.comcast.net) (Quit: anri)
[17:12:01] *** Joins: reedlepee (Mibbit@9B9315E1.A6025CA.1C37C358.IP)
[17:12:38] *** Quits: pyrac (pyrac@moz-84C91992.w90-60.abo.wanadoo.fr) (Quit: pyrac)
[17:13:39] *** Joins: jst (quassel@CB36FB4D.BE63433B.EE6E63A5.IP)
[17:15:20] *** Quits: jst (quassel@CB36FB4D.BE63433B.EE6E63A5.IP) (Ping timeout)
[17:17:51] *** Joins: maik (maik@moz-AC35752F.dip0.t-ipconnect.de)
[17:18:30] *** Joins: mib_qsp4dd (Mibbit@moz-32E80DEF.centertel.pl)
[17:18:31] *** Quits: mib_qsp4dd (Mibbit@moz-32E80DEF.centertel.pl) (Quit: mib_qsp4dd)
[17:18:34] *** Joins: jst (quassel@CB36FB4D.BE63433B.EE6E63A5.IP)
[17:20:17] *** Quits: jst (quassel@CB36FB4D.BE63433B.EE6E63A5.IP) (Ping timeout)
[17:20:49] *** Joins: parcha_ (quassel@moz-A9A9F340.hsd1.ma.comcast.net)
[17:21:36] *** Quits: parcha (quassel@moz-A9A9F340.hsd1.ma.comcast.net) (Ping timeout)
[17:23:17] *** Quits: tgummerer (tgummerer@moz-582025B2.members.linode.com) (Quit: Coyote finally caught me)
[17:23:47] *** Joins: jst (quassel@CB36FB4D.BE63433B.EE6E63A5.IP)
[17:24:07] *** Quits: nsf (nsf@moz-EEF3238A.convex.ru) (Quit: WeeChat 0.4.2)
[17:24:12] *** Joins: sweet_kid (Upasana@D1DDC9CD.1F5862DC.388CF16F.IP)
[17:24:21] *** Joins: anri (solancile@moz-E49E7C4B.hsd1.wa.comcast.net)
[17:25:24] *** Joins: nsf (nsf@moz-EEF3238A.convex.ru)
[17:25:32] *** Quits: jst (quassel@CB36FB4D.BE63433B.EE6E63A5.IP) (Ping timeout)
[17:26:35] *** Quits: Jesin (Jessin_@moz-9BB5F6CF.cc.lehigh.edu) (Quit: Leaving)
[17:27:07] *** Joins: jst (quassel@moz-BBE3ABD.mv.mozilla.com)
[17:27:42] *** Quits: dab_ (Mibbit@C335B9F2.807CFFFA.53E421C3.IP) (Quit: http://www.mibbit.com ajax IRC Client)
[17:27:55] *** Quits: maik (maik@moz-AC35752F.dip0.t-ipconnect.de) (Ping timeout)
[17:29:00] *** Joins: voxpopuli (fanservice@moz-FE161659.wv.cc.cmu.edu)
[17:29:07] <mcarberry> Having an error when attemping to use std::rt::io::net::addrinfo::get_host_addresses and when I request an irc rotation server like chat.freenode.net
[17:29:12] <mcarberry> "failed in non-task context at 'called Option::unwrap()' on a 'None' value
[17:29:15] <mcarberry> this function call is the only thing in my application
[17:29:43] <kimundi> Sounds like a bug in get_host_addresses then
[17:31:08] <mcarberry> It does, what would be the best way of tracking it down, is there a way to get a more detailed traceback?
[17:31:20] *** Joins: lenstr (lenstr@AF8EB999.6049B16A.85938D85.IP)
[17:31:22] <kimundi> gdb
[17:32:10] <kimundi> But I'm not sure how to enable the neccessary debug info...
[17:32:25] <cmr> -Z extra-debug-info
[17:32:43] <cmr> RUSTCFLAGS="-Z extra-debug-info" when build rust
[17:33:35] <mcarberry> Awesome, thanks.
[17:33:47] <kimundi> Does anyone know why ToStr is not implemented for &T and &mut T ? (I know that ToStr is deprecated)
[17:34:19] <cmr> kimundi: oversight, probably
[17:36:29] <kvark> ToStr is deprecated? oh, things change so fast these days
[17:37:04] *** Joins: pnkfelix (pnkfelix@moz-43495417.fbx.proxad.net)
[17:37:04] *** ChanServ sets mode: +o pnkfelix
[17:37:38] *** Joins: SiegeLord (sl@moz-CAF07B4C.hsd1.ma.comcast.net)
[17:38:41] *** Joins: eevee (eevee@moz-7B6C48E3.evrt.wa.frontiernet.net)
[17:39:53] *** Quits: hjr3 (hradtke@moz-E87BDF1F.socal.res.rr.com) (Quit: My MacBook has gone to sleep. ZZZzzz…)
[17:40:38] *** Joins: shooteram (shooteram@moz-A860A0B9.fbx.proxad.net)
[17:40:49] *** Joins: brylie (quassel@moz-E27796EB.hsd1.or.comcast.net)
[17:42:41] <jeffdb> what's replacing ToStr?
[17:42:52] *** Quits: Yeri (jasonjasmi@BA0CD88C.B2E00889.31F69D78.IP) (Quit: Yeri)
[17:42:54] <cmr> jeffdb: std::fmt::String
[17:43:20] <cmr> doesn't need to allocate like ToStr does.
[17:43:55] <jeffdb> that makes sense
[17:45:50] *** Quits: CyBeRKeL (cyber@E6A1FD6F.BE88DC8C.9C1C15C3.IP) (Ping timeout)
[17:46:38] *** Joins: CyBeRKeL (cyber@E6A1FD6F.BE88DC8C.9C1C15C3.IP)
[17:46:56] *** Quits: BizarreCake (BizarreCak@moz-361FE9B2.dynamic.barak-online.net) (Ping timeout)
[17:47:15] *** Quits: reedlepee (Mibbit@9B9315E1.A6025CA.1C37C358.IP) (Quit: http://www.mibbit.com ajax IRC Client)
[17:49:50] *** Quits: shooteram (shooteram@moz-A860A0B9.fbx.proxad.net) (Quit: )
[17:54:06] *** Joins: jensnockert (jensnocker@moz-7DC16A5F.afb.bredband2.com)
[17:54:49] *** Joins: mikezaby (mikezaby@moz-B26868E.home.otenet.gr)
[17:54:55] *** Quits: pnkfelix (pnkfelix@moz-43495417.fbx.proxad.net) (Quit: Leaving.)
[17:55:05] *** Joins: engla (engla@moz-BFD53D48.selucle.dyn.perspektivbredband.net)
[17:55:43] *** Joins: SilverKey (SilverKey@moz-B589DA51.sw.biz.rr.com)
[17:59:02] *** Joins: JamesNZ (james@moz-264643C7.bitstream.orcon.net.nz)
[18:00:28] *** Quits: Amaranth (travis@moz-F81BB56A.cpe.cableone.net) (Ping timeout)
[18:00:30] *** Joins: Amaranth (travis@moz-F81BB56A.cpe.cableone.net)
[18:05:57] *** Joins: jeaye (Jeaye@moz-34FEF2BB.hsd1.ca.comcast.net)
[18:07:24] *** Quits: moostik (Icedove@47C863C.ED2579B8.BCDF592F.IP) (Ping timeout)
[18:13:29] *** Quits: FrozenCow (FrozenCow@moz-B2DF4929.chello.nl) (Client exited)
[18:14:04] *** Joins: hjr3 (hradtke@moz-E87BDF1F.socal.res.rr.com)
[18:14:14] *** Joins: infynyxx (infynyxx@moz-E95B370B.nyc.res.rr.com)
[18:14:15] *** Quits: hjr3 (hradtke@moz-E87BDF1F.socal.res.rr.com) (Quit: My MacBook has gone to sleep. ZZZzzz…)
[18:14:43] *** Quits: Leo` (Leo@moz-83832FE2.placeholder.fr) (Quit: WeeChat 0.3.9.2)
[18:16:29] *** Quits: alonlevy (alon@16E94D1.80C6E391.EFBC6494.IP) (Ping timeout)
[18:18:35] *** Joins: RagingDave (RagingDave@moz-A2E7AB78.pools.arcor-ip.net)
[18:19:29] *** Joins: notmatt (notmatt@moz-9FB2565E.vc.shawcable.net)
[18:20:34] *** Quits: RagingDave (RagingDave@moz-A2E7AB78.pools.arcor-ip.net) (Quit: Ex-Chat)
[18:22:56] *** Quits: parcha_ (quassel@moz-A9A9F340.hsd1.ma.comcast.net) (Ping timeout)
[18:23:15] *** Joins: parcha (quassel@moz-A9A9F340.hsd1.ma.comcast.net)
[18:28:33] *** Joins: valenting (Thunderbir@F12D0376.5025026B.FB866788.IP)
[18:29:01] *** Quits: jmgrosen (jmgrosen@moz-848F6087.sb.sd.cox.net) (Quit: jmgrosen)
[18:31:20] *** Joins: freezerburnv (freezerbur@moz-C5EF929C.washdc.fios.verizon.net)
[18:31:26] *** Quits: Blub\w (wry@7E3BB9D.71150E1A.237AE2BA.IP) (Ping timeout)
[18:31:47] *** Joins: Blub\w (wry@7E3BB9D.71150E1A.237AE2BA.IP)
[18:35:31] *** Quits: infynyxx (infynyxx@moz-E95B370B.nyc.res.rr.com) (Client exited)
[18:36:02] *** Joins: infynyxx (infynyxx@moz-E95B370B.nyc.res.rr.com)
[18:37:42] *** Quits: infynyxx (infynyxx@moz-E95B370B.nyc.res.rr.com) (Ping timeout)
[18:38:43] *** Quits: kvark (Mibbit@moz-F30E0473.cpe.net.cable.rogers.com) (Quit: http://www.mibbit.com ajax IRC Client)
[18:41:19] *** Joins: maxiepoo (Max@moz-6F50ADE.hsd1.il.comcast.net)
[18:42:42] *** Joins: bjz (bjz@B398BE78.F804C29E.D35A31DF.IP)
[18:43:12] *** Quits: maxiepoo (Max@moz-6F50ADE.hsd1.il.comcast.net) (Ping timeout)
[18:43:34] *** Quits: StarLight (StarLight@moz-501842FE.dynamic.avangarddsl.ru) (Ping timeout)
[18:45:22] *** Joins: alonlevy (alon@moz-B0E66DB7.static.bezeqint.net)
[18:47:29] *** Joins: StarLight (StarLight@moz-69EDBB3C.dynamic.avangarddsl.ru)
[18:48:50] *** Joins: jmgrosen (jmgrosen@moz-848F6087.sb.sd.cox.net)
[18:49:31] *** Quits: bjz (bjz@B398BE78.F804C29E.D35A31DF.IP) (Quit: ZZZzzz…)
[18:53:53] *** Joins: moostik (Icedove@47C863C.ED2579B8.BCDF592F.IP)
[18:54:33] *** Joins: bjz (bjz@B398BE78.F804C29E.D35A31DF.IP)
[18:58:08] *** Quits: lenstr (lenstr@AF8EB999.6049B16A.85938D85.IP) (Client exited)
[18:58:30] *** Joins: lenstr (lenstr@AF8EB999.6049B16A.85938D85.IP)
[18:58:42] *** Quits: lenstr (lenstr@AF8EB999.6049B16A.85938D85.IP) (Client exited)
[19:00:27] *** Quits: jmgrosen (jmgrosen@moz-848F6087.sb.sd.cox.net) (Quit: jmgrosen)
[19:00:58] *** Quits: freezerburnv (freezerbur@moz-C5EF929C.washdc.fios.verizon.net) (Quit: freezerburnv)
[19:04:25] <jeffdb> say I have a type T that implements the Zero trait, and I want to call zero() on it. How do I do that?
[19:05:49] *** Joins: steven_is_false (user@C5B76363.1FF1EBF8.1ECA502.IP)
[19:06:46] <steven_is_false> Is there any reason in particular that Rust is built with -O (-O is equivalent to -O2 I believe) rather than -O3?
[19:07:04] *** Quits: engla (engla@moz-BFD53D48.selucle.dyn.perspektivbredband.net) (Ping timeout)
[19:07:26] *** Joins: jxv (jxv@moz-8FB92450.lightspeed.irvnca.sbcglobal.net)
[19:09:05] <kimundi> jeffdb: let x: T = Zero::zero();
[19:10:25] <jeffdb> kimundi: Thanks!
[19:11:04] *** Joins: nrc (nrc@7BE24E90.A5032A01.3CFC199D.IP)
[19:17:09] <cmr> steven_is_false: it'd be even slower!
[19:18:26] <steven_is_false> cmr: Oh okay. Has anyone considered using a program like acovea to find the best possible set of optimizations to maximize build time?
[19:19:07] <cmr> steven_is_false: it has come across in conversation, but there are bigger fish still
[19:19:39] <cmr> clang's set of optimizations is highly tuned, I have no reason to doubt it.
[19:19:59] <steven_is_false> Okay.
[19:20:20] <myname> i am more confused about code being horribly slow if not compiled with -O
[19:20:51] <steven_is_false> myname: I believe that's because almost all optimizations are done in LLVM, and not Rust.
[19:21:22] <steven_is_false> Unless that has changed by now.
[19:21:34] <cmr> the frontend only does one optimization, which is removing dead branches for `if true`/`if false`
[19:22:16] <steven_is_false> I thought there were a lot of efforts a while ago to shrink IR bloat so LLVM wouldn't take so long?
[19:25:43] <steven_is_false> What optimizations does clang turn on for no optimizations mode?
[19:26:26] <kimundi> none
[19:26:27] <myname> does gcc make any optimization by default?
[19:26:34] <jeaye> yes
[19:26:38] <myname> oh
[19:26:46] <steven_is_false> kimundi: Are you sure it is absolutely none?
[19:26:56] <myname> can you actually disable that for benchmark reasons?
[19:27:05] <kimundi> afaik yes, but thats just memory, might be wrong about it
[19:30:06] *** Joins: strcat (strcat@moz-54F7FD49.cpe.net.cable.rogers.com)
[19:32:24] *** Joins: ross (ross@moz-5EA04060.br.br.cox.net)
[19:32:43] *** Joins: jmgrosen (jmgrosen@moz-848F6087.sb.sd.cox.net)
[19:33:06] *** Joins: GeorgeH (George@moz-FB5F2302.hsd1.nj.comcast.net)
[19:36:05] <steven_is_false> Has any effort been put in to optimize dynamic relocations for Rust?
[19:36:28] <steven_is_false> I know Rust uses shared libraries by default.
[19:37:05] *** Joins: Florob (Florob@moz-39532932.de)
[19:38:25] <strcat> steven_is_false: what would need to be optimized?
[19:39:13] <steven_is_false> strcat: An easy one linker thingy is that global variables that start out as zero don't need to be wrote done in the library.
[19:39:31] <steven_is_false> But that's just library size.
[19:39:39] <benh> that sounds like such a minor thing compared to actual code bloat
[19:39:40] *** Quits: moostik (Icedove@47C863C.ED2579B8.BCDF592F.IP) (Ping timeout)
[19:39:53] <strcat> afaik LLVM and the linker are fully capable of doing all of that
[19:40:00] <steven_is_false> benh: Yeah. That was only the first thing that came to min.
[19:40:01] *** Joins: ktt3ja (Mibbit@moz-F40FE31.washdc.fios.verizon.net)
[19:40:01] <strcat> run 'size' on a rust binary
[19:40:33] *** Quits: mcarberry (mcarberry@moz-BE1C9F3F.lightspeed.frokca.sbcglobal.net) (Ping timeout)
[19:40:45] <strcat> there's definitely stuff in bss
[19:41:29] *** Joins: aeqwa (aeqwa@moz-FF95955F.dsl.tropolys.de)
[19:42:08] <steven_is_false> Running objdump -D I get <completed.6338>, <dtor_idx.6340>, and <_rust_mod_map> in the .bss section.
[19:42:08] <steven_is_false>  
[19:42:11] *** Quits: jensnockert (jensnocker@moz-7DC16A5F.afb.bredband2.com) (Input/output error)
[19:42:22] *** Quits: jmgrosen (jmgrosen@moz-848F6087.sb.sd.cox.net) (Quit: jmgrosen)
[19:42:29] <steven_is_false> The _rust_mod_map is metadata that should be stripped out right?
[19:43:02] <strcat> no
[19:43:18] <strcat> it wouldn't be there if it could be stripped out, it's one of the prices you pay for using the runtime
[19:43:24] <steven_is_false> Oh, okay then.
[19:45:34] <steven_is_false> Doesn't Rust have really long symbol names? That'd probable be our biggest linker problem I guess.
[19:46:06] <strcat> it has long symbol names and too many external symbols
[19:46:14] <strcat> dynamic linking is fairly pointless for rust imo
[19:46:22] <strcat> you can't expose a stable ABI anyway
[19:46:30] *** Joins: infynyxx (infynyxx@moz-E95B370B.nyc.res.rr.com)
[19:47:48] <steven_is_false> strcat: If only native ABIs were as easy as on JVM, and CLR.
[19:48:17] *** Quits: infynyxx (infynyxx@moz-E95B370B.nyc.res.rr.com) (Ping timeout)
[19:49:17] *** Joins: jmgrosen (jmgrosen@moz-848F6087.sb.sd.cox.net)
[19:50:02] *** Quits: dnyy (uid2106@moz-31ABA2C0.irccloud.com) (Quit: )
[19:50:33] <steven_is_false> How does Rust export to many symbols?
[19:51:52] *** Quits: jmgrosen (jmgrosen@moz-848F6087.sb.sd.cox.net) (Ping timeout)
[19:51:58] *** Quits: valenting (Thunderbir@F12D0376.5025026B.FB866788.IP) (Ping timeout)
[19:52:54] *** Parts: steven_is_false (user@C5B76363.1FF1EBF8.1ECA502.IP) (ERC Version 5.3 (IRC client for Emacs))
[19:53:57] *** Quits: dherman (dherman@moz-6CA476B1.hsd1.ca.comcast.net) (Quit: dherman)
[19:54:29] *** Quits: samnardoni (samnardoni@FC9A45BE.3393236F.BFD1ABFD.IP) (Client exited)
[19:54:50] *** Joins: samnardoni (samnardoni@FC9A45BE.3393236F.BFD1ABFD.IP)
[19:54:54] <kimundi> Hm... Giving Result as_ref and as_mut adapters conflicts with the ToStr bound on the error type in it...
[19:54:56] *** Quits: BigEndian (hurp@moz-1B6DD81E.members.linode.com) (Quit: leaving)
[19:55:16] *** Quits: samnardoni (samnardoni@FC9A45BE.3393236F.BFD1ABFD.IP) (Client exited)
[19:55:17] *** Joins: samnardoni (samnardoni@FC9A45BE.3393236F.BFD1ABFD.IP)
[19:56:35] *** Joins: mcarberry (mcarberry@moz-BE1C9F3F.lightspeed.frokca.sbcglobal.net)
[19:58:41] *** Quits: pseudoku (quassel@2AF0BA32.5CDB92DC.520CDC98.IP) (Client exited)
[20:01:55] *** Quits: Sharp (Sharp@moz-7B61DF4.dsl.static.sonic.net) (Quit: Sharp)
[20:05:20] *** Quits: JamesNZ (james@moz-264643C7.bitstream.orcon.net.nz) (Client exited)
[20:12:02] *** Quits: samnardoni (samnardoni@FC9A45BE.3393236F.BFD1ABFD.IP) (Client exited)
[20:12:23] *** Joins: samnardoni (samnardoni@FC9A45BE.3393236F.BFD1ABFD.IP)
[20:14:10] *** Quits: samnardoni (samnardoni@FC9A45BE.3393236F.BFD1ABFD.IP) (Ping timeout)
[20:14:14] *** Quits: jeffdb (jeff@moz-ED35AD97.hsd1.ca.comcast.net) (Quit: jeffdb)
[20:18:44] *** Joins: enix (enix@moz-A50569DD.c3-0.slvr-ubr1.lnh-slvr.md.cable.rcn.com)
[20:20:34] *** Joins: maxli (maxli@moz-4D28BA20.student.cs.uwaterloo.ca)
[20:22:24] *** Joins: mark_edward (quassel@moz-DCB0B750.lightspeed.cicril.sbcglobal.net)
[20:23:42] *** Joins: reedlepee (Mibbit@9B9315E1.A6025CA.1C37C358.IP)
[20:24:17] *** Quits: Jackneill (Jackneill@moz-224A92F.pool.digikabel.hu) (Input/output error)
[20:29:11] *** Joins: nif (Mibbit@moz-B6DFA19D.wireless.oberlin.edu)
[20:29:21] *** Joins: cubic_ (cubic@moz-80241A3A.mc.videotron.ca)
[20:29:49] *** Quits: cubic (cubic@moz-80241A3A.mc.videotron.ca) (Ping timeout)
[20:34:11] *** Joins: lenstr (lenstr@AF8EB999.6049B16A.85938D85.IP)
[20:36:25] <bstrie> heh, somehow while manually inlining javascript functions I managed to crash firefox
[20:36:34] <bstrie> I feel like I should be able to just show this to somebody I know
[20:37:15] <bstrie> and have it taken care of
[20:37:21] * bstrie too lazy to file bugs
[20:37:32] <eevee> email all@mozilla.org threatening to switch to chrome
[20:37:45] <Ms2ger> File a bug 
[20:37:54] <bstrie> but then I'd have to like
[20:38:04] <bstrie> ugh, minimize this simple 100-line script
[20:38:23] <Ms2ger> Meh
[20:38:25] <Ms2ger> Start with a bug
[20:38:27] <bstrie> it's *saturdaaaay*
[20:38:30] <bstrie> :)
[20:38:35] <bstrie> I will file a bug later
[20:38:41] *** Quits: alonlevy (alon@moz-B0E66DB7.static.bezeqint.net) (Ping timeout)
[20:38:44] <Ms2ger> Orly?
[20:38:57] <bstrie> also I am waiting for aurora 27 to land
[20:39:09] <bstrie> since maybe that will have a bugfix
[20:39:24] <Ms2ger> Could test in Nightly :)
[20:39:39] *** Joins: mib_xtdusp (Mibbit@179AE006.409F80CD.3A7352D6.IP)
[20:40:09] <bstrie> ugh, but *then* I'd have to figure out the nightly ppa, and *then* I'd have to add it to my sources!
[20:40:26] <bstrie> too much work!! it's *saturdaaaaaaay*
[20:40:45] <cmr> bstrie: for a slave driver, you sure do whine a lot about it being the weekend.
[20:40:57] <bstrie> cmr: if I wasn't lazy then why would I need slaves??!
[20:41:11] <Ms2ger> Could download a tar from nightly.mozilla.org :)
[20:41:12] * bstrie cracks the whip, lazily
[20:41:33] * Ms2ger is no fun
[20:42:51] <bstrie> in any case, aurora 27 should be out any second now
[20:43:02] *** Joins: samnardoni (samnardoni@FC9A45BE.3393236F.BFD1ABFD.IP)
[20:43:08] <bstrie> though I have been a little tempted to try out the UX build
[20:43:11] *** Joins: jvshahid (jvshahid@moz-C1BC0CE4.nyc.res.rr.com)
[20:43:23] <bstrie> and see if australis actually does anything on linux
[20:43:42] *** Quits: earlzlap (earlz@moz-9E279EAD.neo.res.rr.com) (Ping timeout)
[20:43:49] *** Joins: jeffdb (jeff@moz-ED35AD97.hsd1.ca.comcast.net)
[20:44:03] *** Quits: jvshahid (jvshahid@moz-C1BC0CE4.nyc.res.rr.com) (Quit: leaving)
[20:44:11] *** Joins: devbug (quassel@23AC5F12.9D950176.3655BBF5.IP)
[20:44:26] <cmr> has the ux build actually been updated? last I looked it was just the new downloader.
[20:44:32] <cmr> (I haven't looked for a while..)
[20:45:43] *** Quits: samnardoni (samnardoni@FC9A45BE.3393236F.BFD1ABFD.IP) (Client exited)
[20:45:54] <bstrie> I haven't looked at UX since like last year
[20:46:04] *** Joins: samnardoni (samnardoni@FC9A45BE.3393236F.BFD1ABFD.IP)
[20:47:34] *** Quits: mib_xtdusp (Mibbit@179AE006.409F80CD.3A7352D6.IP) (Quit: http://www.mibbit.com ajax IRC Client)
[20:47:38] *** Joins: sk (sk@61A494B3.BA40E8A.AAC02D62.IP)
[20:47:55] *** Quits: samnardoni (samnardoni@FC9A45BE.3393236F.BFD1ABFD.IP) (Ping timeout)
[20:48:12] *** Joins: Yeri (jasonjasmi@BA0CD88C.B2E00889.31F69D78.IP)
[20:48:49] *** Quits: victorporof (victorporo@733111D7.F5F0D9CD.9B1E38F4.IP) (Quit: victorporof)
[20:49:38] *** Joins: dherman (dherman@moz-6CA476B1.hsd1.ca.comcast.net)
[20:49:38] *** ChanServ sets mode: +ao dherman dherman
[20:49:39] *** Joins: jvshahid (jvshahid@moz-C1BC0CE4.nyc.res.rr.com)
[20:51:04] *** Quits: jxv (jxv@moz-8FB92450.lightspeed.irvnca.sbcglobal.net) (Quit: Leaving)
[20:51:45] *** Joins: alonlevy (alon@moz-B0E66DB7.static.bezeqint.net)
[20:53:12] <bjz> any idea what's going wrong with rustpkg here? https://travis-ci.org/bjz/glfw-rs/builds/13414479#L472
[20:54:23] <cmr> bjz: looks like it's not setting up the workspace properly?
[20:54:48] <bjz> should I just rm .rust?
[20:54:54] <bjz> for now?
[20:55:18] <bjz> that's what I normally do when running rustpkg atm -_-
[20:55:49] <bjz> `rm -rf .rust; rustpkg build foo` is what I normally run
[20:56:10] <bjz> kmc: were you doing rustpkg stuff?
[20:57:26] *** Joins: adu (ajr@moz-60B25736.washdc.fios.verizon.net)
[20:58:48] *** Joins: Sharp (Sharp@moz-7B61DF4.dsl.static.sonic.net)
[20:59:20] <Sharp> Question: does ordinary Rust code have access to libsyntax?
[20:59:26] *** Quits: huseby (huseby@moz-4E8C421A.husebyhome.com) (Ping timeout)
[20:59:31] <cmr> Sharp: `extern mod syntax`
[20:59:36] <Sharp> Yay!
[21:00:01] <Sharp> That makes my life much easier :)
[21:00:38] <bjz> cmr: eh, still fails with that
[21:00:51] <bjz> rustpkg fml
[21:00:59] <Sharp> Where do I have to put that?  Every file I use it, or just somewhere in the crate?
[21:01:34] <cmr> Sharp: crate root.
[21:01:34] <bjz> Sharp: in a parent module to where you want to use it
[21:01:44] <Sharp> Cool, thanks.
[21:01:53] <bjz> Sharp: usually in the crate root
[21:02:16] * Sharp is writing a thrift implementation for Rust, or at least part of one.
[21:02:23] <bjz> Sharp: but you can do it further down I think for privacy I think
[21:02:28] <cmr> Sharp: cool!
[21:02:38] <Sharp> I'm not sure if our networking code is up to the task yet, but we can certainly do the rest.
[21:02:43] *** Joins: boredomist (ruqs@B16F530C.DC641F2C.BCAEBB33.IP)
[21:02:56] *** Joins: engla (engla@moz-9B69FE7C.selucle.dyn.perspektivbredband.net)
[21:03:05] <Sharp> IMO, it shouldn't even be that hard, since I can just leverage the existing compiler architecture for a lot of it
[21:03:47] <Sharp> It would be even easier if we had a good Yacc equivalent, of course :)
[21:03:53] *** Joins: valenting (Thunderbir@F12D0376.5025026B.FB866788.IP)
[21:04:02] *** Quits: valenting (Thunderbir@F12D0376.5025026B.FB866788.IP) (Input/output error)
[21:04:55] <bjz> Sharp: there was an antlr grammar
[21:05:01] <cmr> Sharp: We have ragel support.
[21:05:06] <Sharp> Do we?
[21:05:10] <cmr> yes
[21:05:13] * Sharp must have missed that.
[21:05:20] <cmr> https://github.com/erickt/ragel
[21:05:23] <bjz> https://github.com/jbclements/rust-antlr/
[21:05:40] <Sharp> I think the Antlr one was rusted
[21:05:42] <Sharp> But maybe not
[21:06:05] <cmr> it is
[21:08:00] <Sharp> Aw man, I was hoping one of the examples in ragel would be a thrift implementation :P
[21:08:02] * Sharp lazy.
[21:08:12] <bjz> Sharp: yeah, 'rusted' x)
[21:08:22] <bjz> takes abit to keep up with the changes
[21:09:05] <Sharp> If we can't use "rusted" instead of "bitrotted" for Rust projects, what's the point?
[21:09:23] <bjz> I love it
[21:09:40] *** Joins: nomadic (nomadic@moz-E01D5C49.hsd1.ga.comcast.net)
[21:09:55] * bjz thinks he should add that to the Rusticon
[21:10:25] <cmr> +1
[21:11:24] <tautologico> I started a lexer generator (with the idea of doing a LALR parser generator as well), but it may take a while to have something usable
[21:11:42] <Sharp> I'd be interested in seeing that
[21:11:45] *** Quits: nomadic (nomadic@moz-E01D5C49.hsd1.ga.comcast.net) (Quit: Leaving)
[21:11:49] *** Joins: nomadic (nomadic@moz-E01D5C49.hsd1.ga.comcast.net)
[21:11:53] <Sharp> I feel like Rust is particularly well-suited to grammars and grammar generators.
[21:12:11] <tautologico> it's a good language for writing compilers and runtimes
[21:12:12] <cmr> Sharp: why?
[21:12:15] <Sharp> Strongly typed + fast + ADTs
[21:12:24] <tautologico> ADTs + pattern matching
[21:12:30] *** Joins: samnardoni (samnardoni@FC9A45BE.3393236F.BFD1ABFD.IP)
[21:12:32] <Sharp> + pattern matching, yeah
[21:12:38] <Sharp> Are there languages with ADTs and not pattern matching?
[21:12:44] <bjz> :)
[21:12:50] <cmr> C++
[21:13:01] <bjz> cmr: no adts?
[21:13:01] <Sharp> Unions are barely ADTs :)
[21:13:06] <bjz> heh
[21:13:07] <cmr> Boost.Variant
[21:13:14] <Sharp> That's not a core language feature.
[21:13:20] <cmr> So?
[21:13:29] <strcat> Sharp: so C++ doesn't have containers or smart pointers either
[21:13:32] <Sharp> Ruby has an RDT library too but that doesn't mean Ruby has ADTs.
[21:13:39] <cmr> The whole point of C++ is they don't need to be core language features.
[21:13:45] <Sharp> Sure
[21:13:56] <Sharp> But it means that "ADTs without pattern matching" isn't something people have usually done
[21:14:14] <Sharp> When it was actually considered an important feature.
[21:14:15] <bjz> cmr: ++, but it also means sometimes you get substandard implementations
[21:14:24] <strcat> you can implement pattern matching
[21:14:28] <strcat> it's just a royal PITA
[21:14:37] <strcat> to implement
[21:14:41] *** Joins: freezerburnv (freezerbur@moz-C5EF929C.washdc.fios.verizon.net)
[21:14:47] <bjz> bjarne has hinted that he wants to add pattern matching and adt things
[21:15:06] <strcat> bjz: they won't add a feature like that to the core language
[21:15:11] <strcat> it's a library feature, in the C++ world
[21:15:11] <tautologico> "ADT" is a wide concept, but ML-style ADTs of course always come with pattern matching, it's part of the package
[21:15:13] <bjz> which is kind of frightening
[21:15:24] *** Joins: pnkfelix (pnkfelix@moz-43495417.fbx.proxad.net)
[21:15:24] *** ChanServ sets mode: +o pnkfelix
[21:15:36] <Sharp> Yeah, pretty much…
[21:15:43] <Sharp> There *are* languages with pattern matching and not ADTs though
[21:16:00] <strcat> maybe it's frightening but C++ is a better language than rust today for containers, smart pointers and allocators
[21:16:10] <bjz> strcat: agreed
[21:16:32] <Sharp> C++ has also had a good 30 years of optimization, of course.
[21:16:36] <bjz> strcat: that's part of why C++ has had such longevity
[21:16:39] <strcat> not talking about optimization
[21:16:40] <reedlepee> https://github.com/mozilla/rust/issues/9543  .. Do i  just need to change extern mod foo (name="bar") to extern mod foo = "bar"; ??
[21:16:46] <strcat> C++ has better language feature than rust for generic programming
[21:17:07] <strcat> it's not a strength that rust needs ~ and ~[T] hardcoded into the compiler
[21:17:17] <bjz> Sharp: it's hard to 'grow' rust, unlike C++
[21:17:24] <strcat> we can say ~[1, 2, 3], great
[21:17:25] <tautologico> C++ also has had such longevity because there is no competitor in the same space
[21:17:29] <Sharp> bjz: I think that is by design.
[21:17:32] <strcat> C++ users can say {1, 2, 3} to init any kind of array
[21:17:33] <strcat> or a set
[21:17:35] *** Joins: Kruppe (user@moz-E150F49F.cpe.net.cable.rogers.com)
[21:17:35] <strcat> or a list
[21:17:46] <strcat> {{1, 2}, {3, 4}} to init an array of tuples, or a map
[21:17:57] *** Quits: pnkfelix (pnkfelix@moz-43495417.fbx.proxad.net) (Quit: Leaving.)
[21:18:07] <Sharp> At least for me personally, one of the reasons I am interested in Rust is because I like to know WTF is going on.
[21:18:11] <strcat> I'm frustrated that rust isn't improving in these areas
[21:18:14] <eevee> otoh when i see ~[1, 2, 3] in rust i know what it does
[21:18:22] <strcat> you know what it does in C++ too
[21:18:23] <bjz> tautologico: that too, but its a combination of factors
[21:18:38] <cmr> reedlepee: yes, and change libsyntax to no longer accept it.
[21:18:44] <eevee> yes it initializes something, probably.
[21:18:49] <Sharp> strcat: Not necessarily.  Sometimes you do, and sometimes not.
[21:18:58] <strcat> you realize rust has crappy generic int/float literals?
[21:18:59] *** Quits: samnardoni (samnardoni@FC9A45BE.3393236F.BFD1ABFD.IP) (Client exited)
[21:19:08] <strcat> Sharp: you know what it does
[21:19:12] <strcat> {1, 2, 3} is an initializer list
[21:19:14] <strcat> it's a type
[21:19:19] *** Joins: samnardoni (samnardoni@FC9A45BE.3393236F.BFD1ABFD.IP)
[21:19:30] <strcat> http://en.cppreference.com/w/cpp/utility/initializer_list
[21:19:47] <Sharp> Okay, but it could be overriden by someone else.
[21:20:01] <bjz> Sharp: that's the whole point
[21:20:03] <strcat> which is exactly what rust intends to do for integer/float literals
[21:20:12] <strcat> and ideally container literals too
[21:20:35] *** Quits: parcha (quassel@moz-A9A9F340.hsd1.ma.comcast.net) (Ping timeout)
[21:20:46] <Sharp> Then I no longer know what is going on when I look at a piece of code, which I do not consider a good thing :)
[21:20:46] <strcat> it's not a strength that you can't write a vector type or a smart pointer type in a library
[21:20:55] <Sharp> No, you should be able to do those things.
[21:21:02] *** Quits: samnardoni (samnardoni@FC9A45BE.3393236F.BFD1ABFD.IP) (Ping timeout)
[21:21:08] <Sharp> I just don't think you need to be able to write them with cute syntax.
[21:21:09] *** Joins: samnardoni (samnardoni@FC9A45BE.3393236F.BFD1ABFD.IP)
[21:21:15] *** Quits: nomadic (nomadic@moz-E01D5C49.hsd1.ga.comcast.net) (Quit: Leaving)
[21:21:18] *** Joins: nomadic (nomadic@moz-E01D5C49.hsd1.ga.comcast.net)
[21:21:18] <strcat> Sharp: why should the built-in types be special?
[21:21:23] <strcat> this isn't Go
[21:21:40] <cmr> Sharp: You know what it's doing, because you know its type.
[21:21:46] *** Quits: nomadic (nomadic@moz-E01D5C49.hsd1.ga.comcast.net) (Quit: Leaving)
[21:21:49] <bjz> that's what causes so much pain with Java
[21:22:41] <Sharp> I'm all for consistency, but I don't think consistency means "making the language so generic that any given piece of code could be doing a huge variety fo things and you'd have no idea."
[21:22:43] <strcat> I don't see why you would want the built-in fixed-size integer/vector/pointer types to be special
[21:22:43] <myname> strcat: go built-ins are special?
[21:22:49] <strcat> myname: ofc they are
[21:22:52] <strcat> Go doesn't have generics
[21:23:00] <strcat> the only generic types you'll ever have are maps and vectors
[21:23:02] <myname> the fuck
[21:23:02] * kimundi now wonders if rusts [] literals could get turned into generic initializer lists
[21:23:03] <strcat> and they have hardcoded syntax
[21:23:13] <Sharp> I'd rather make them not special and just use the full syntax everywhere than let everything override everything.
[21:23:28] <strcat> Sharp: so, no [1, 2, 3] syntax
[21:23:39] <tautologico> I've written a lot of code in OCaml and Haskell in the last 10 years or so and it never bothered me much that built-in types are special in these languages
[21:23:40] <strcat> maybe rust will catch up to C++03 soon ;p
[21:23:51] <strcat> tautologico: uh
[21:23:56] <strcat> haskell has overloaded literals
[21:24:07] <Sharp> I didn't say I wouldn't like to have that.  I said that in your hypothetical world where you can only be at one extreme or the other, I'll take the long and shitty syntax.
[21:24:07] <bjz> strcat: does it?
[21:24:09] <strcat> yes
[21:24:11] <Earnestly> ^ What types are you refering to in Haskell?
[21:24:20] <tautologico> you can't define haskell lists as a library
[21:24:28] *** Joins: tootse (Mibbit@moz-A7027B54.dhcp.nwtn.ct.charter.com)
[21:24:32] <kimundi> strcat: I remember you pushing a lot of things in the last months, but not generic initializer lists :P
[21:24:43] <Sharp> Since I don't think a language has to be *fully* consistent if it intends to be practical, I would rather have a language with syntactic sugar for a couple of useful types and a longer syntax for everything else.
[21:24:45] <tootse> hi
[21:24:47] <tautologico> you can do a lot of stuff with camlp4 in ocaml, but it isn't pretty or straightforward
[21:25:03] <bjz> tootse: o/
[21:25:06] <strcat> tautologico: standard haskell has overloading for integer literals
[21:25:11] <strcat> ghc has overloading for list and string literals
[21:25:22] <eevee> i don't know what we're actually proposing here so it's hard to argue about  :)
[21:25:27] *** Joins: geoffhill (geoffhill@moz-EED745AA.hsd1.wa.comcast.net)
[21:25:36] <bstrie> Ms2ger: never mind, it wasn't a crash, I'm just an idiot! hurray!
[21:25:40] <tootse> food
[21:25:46] <Sharp> strcat is proposing that Rust be more like C++ in terms of overloadable syntax.
[21:25:49] <Sharp> I think.
[21:25:50] <Ms2ger> bstrie, heh
[21:25:54] <SiegeLord> Is this an argument to allow let foo: Foo = [...]; vs let foo = Foo::from([...]) ?
[21:25:58] <eevee> Sharp: yes but that's not very specific.
[21:26:03] <strcat> I'm proposing that rust's built-in types not be special
[21:26:06] <strcat> as in vectors
[21:26:07] <bjz> Sharp: I think that's a misrepresentation
[21:26:14] <kimundi> I confused though. That c++11 doc for initializer lists says taht they are basically slices. SO where is the problem, what of it does rust not support?
[21:26:24] <strcat> kimundi: they are not like slices
[21:26:28] <Sharp> bjz: maybe, I'm not trying to misrepresent anyone's position.  That's the impression I have.
[21:26:28] <strcat> they are a generic literal
[21:26:31] <tootse> times
[21:26:56] <Sharp> For me, I don't see why the implementation has to be special just because the syntax is
[21:27:00] <tautologico> strcat: yes but these are specific extensions (in the case of lists and strings)
[21:27:00] <Sharp> I think they are entirely different things.
[21:27:15] <strcat> tautologico: okay, and how is that any different than what I'm talking about?
[21:27:20] <kimundi> strcat: Are they something like `from_slice(&[T]) -> Container<T>` ?
[21:27:23] <strcat> they let you overload the list, string and integer literal syntax
[21:27:52] * kimundi doesn't know enough C++ to grasp how initializers work right now
[21:28:18] <tautologico> strcat: it's different because you don't have a general language feature that allows overloaded literal, there is an extension, in one specific implementation, just to desugar list literals and only that (another one for strings, but anyway)
[21:28:30] <bjz> kimundi: well it's relatively new - C++11 stuff
[21:28:41] <strcat> tautologico: it has overloading for certain types of literals
[21:28:47] <tootse> tv ones
[21:28:47] <strcat> what do you think I am proposing if not that?
[21:28:49] <tautologico> such an extension could be done easily for rust as well, it's just a syntactical translation
[21:29:04] <kimundi> bjz: It could be from the 80s and I wouldn't know about it ;)
[21:29:09] <strcat> tautologico: it's part of type inference
[21:29:09] <bjz> :P
[21:29:30] <strcat> '1' isn't a literal of a specific type, in either rust or haskell
[21:29:49] *** Quits: geoffhill (geoffhill@moz-EED745AA.hsd1.wa.comcast.net) (Ping timeout)
[21:29:52] <kimundi> strcat: The discussion is a bit convoluted... _what exactly_ is it you're proposing?
[21:29:55] <tootse> were there 
[21:29:57] <tautologico> not needed, you just translate [a] to fromList 1 (a : [])
[21:30:01] * kimundi didn't catch it
[21:30:07] <tautologico> you do type inference after rewriting
[21:30:09] <strcat> tautologico: yeah, a + operator isn't needed either
[21:30:15] <strcat> not what I'm talking about
[21:30:18] <bjz> kimundi: better support for overloading literals
[21:30:19] *** Joins: maik (maik@moz-AC35752F.dip0.t-ipconnect.de)
[21:30:48] <eevee> c++11 custom literals?  :)
[21:31:25] <tautologico> you said built-in types shouldn't be special, I just commented about using languages where built-in types are special and it's not a big deal
[21:31:29] <bjz> strcat: it would be awesome if the operators for numerics would be implemented in the library
[21:31:50] <reedlepee> cmr : What needs to be changed in libsyntax to no longer accept it .. can u elaborate a little ?
[21:32:03] <kimundi> I know what the topic is about, I wonder about specifics :)
[21:32:04] <strcat> anyway I can't seem to figure out a way to fix generic dtors
[21:32:20] <cmr> reedlepee: the parser. I don't know where or how.
[21:32:23] <tautologico> I agree that some sugar is important, for instance for numerics
[21:32:23] <Sharp> strcat: In principle, or just implementation wise?
[21:32:32] <strcat> implementation wise
[21:32:46] <strcat> tautologico: not special casing crappy built-in types is important
[21:32:52] <Sharp> I thought you had some ideas anyway?
[21:32:59] <strcat> Sharp: nothing works
[21:33:00] <tautologico> but to have a language that is capable of defining any built-in type as a library, I don't know if we need to get this far
[21:33:12] *** Quits: samnardoni (samnardoni@FC9A45BE.3393236F.BFD1ABFD.IP) (Client exited)
[21:33:15] <strcat> yeah, you should be able to write a vector as a library type
[21:33:21] <strcat> or the language is a joke - it's not a systems language
[21:33:28] <Sharp> Bleh.  Is it still a vtables issue?
[21:33:32] <strcat> rust isn't a C++ replacement if you can't write a vector or a smart pointer in the library
[21:33:33] *** Joins: samnardoni (samnardoni@FC9A45BE.3393236F.BFD1ABFD.IP)
[21:33:35] <strcat> Sharp: yes
[21:33:39] <SiegeLord> C can't do it... is C not a system language?
[21:33:46] <Sharp> I don't think Rust is a C++ replacement.
[21:33:49] <strcat> SiegeLord: you can't obviously write a vector type in C...
[21:33:57] <strcat> Sharp: well that's what rust is intended to be
[21:34:01] <bjz> Guy Steele's 'Growing a Language' talk is one of my all time favourites: http://www.youtube.com/watch?v=_ahvzDzKdB0
[21:34:16] <Sharp> I've felt like Rust is more trying to be a C than a C++ replacement.
[21:34:27] <cmr> Sharp: no, definitely C++
[21:34:32] <Earnestly> ↑
[21:34:43] <myname> why not C?
[21:34:53] *** Quits: tootse (Mibbit@moz-A7027B54.dhcp.nwtn.ct.charter.com) (Quit: http://www.mibbit.com ajax IRC Client)
[21:34:56] <bjz> unfortunately the Java folks never listened to him
[21:35:02] <tautologico> but there has to be something in the parser, right? how can you define vectors purely as a library, if the library can't affect the parser?
[21:35:15] *** Quits: samnardoni (samnardoni@FC9A45BE.3393236F.BFD1ABFD.IP) (Ping timeout)
[21:35:34] <strcat> myname: C++ is already a valid replacement for C in any situation, rust isn't going to appeal to people who like C and not C++ in the first place
[21:36:20] <myname> sounds legit
[21:36:30] <Sharp> I like C a lot better than C++ and Rust appeals to me.
[21:36:38] <strcat> I can't see why
[21:36:52] <kimundi> strcat: Bear with me please... After looking at the example on that c++11 initializer list page more, it still seems to me that a initializer_list is the same as a temporary slice, with the only difference that in rust code we need to do `let x: CustomType = CustomType::from_slice([a, b, c])` instead of `let x: CustomType = [a, b, c]` today.
[21:37:10] <strcat> rust is C++ without the C legacy, and with a lifetime system to make references safe
[21:37:28] <strcat> the difference between C++11/Rust is not large
[21:37:35] <tautologico> when changing stuff in libsyntax, are there issues with bootstrapping?
[21:37:52] <cmr> tautologico: yes.
[21:37:57] <Sharp> Right now, the difference is pretty significant, because it doesn't allow (for the most part) stupid things that make it hard to tell what's going on.
[21:38:00] <cmr> tautologico: depending on what you change, of course.
[21:38:07] <Sharp> What you are proposing is that we should add that ability.
[21:38:09] <bjz> Sharp: One way to look at it is in terms of lightweight abstractions. C++ has many faults, but it really enables the programmer to write high-ish level code whilst still being able to have confidence that it will compile down efficiently/
[21:38:16] <cmr> tautologico: if you're removing old syntax, and the compiler still uses it, you need to do some jiggering.
[21:38:25] <strcat> Sharp: there are already accepted nominated issues for most of those things
[21:38:28] <Sharp> Yes, I know.  That's an advantage of C++ over C.  But it's not an advantage of C++ over Rust.
[21:38:46] <bjz> Sharp: that is why we have generics and monomorphisation
[21:38:47] <strcat> C++ is a better language for generic programming than Rust
[21:38:49] <tautologico> cmr: so in this "extern mod foo (name = 'bar')" case it could be trouble?
[21:39:00] <Sharp> Generics aren't impossible to follow.  At all.
[21:39:01] <cmr> tautologico: no, since we already have replacement syntax for it that works today.
[21:39:06] <strcat> C++ has better closures than Rust
[21:39:17] <Ms2ger> strcat, wait, better closures?
[21:39:19] <bjz> strcat++
[21:39:21] <strcat> Ms2ger: yup
[21:39:27] <strcat> C++11 lambdas > rust closures, without a doubt
[21:39:30] <Sharp> As of C++11.
[21:39:32] <SiegeLord> That has nothing to do with better generic programming :P
[21:39:35] <tautologico> Sharp: you mean in c++? ever got hundreds of lines for a template error? :)
[21:39:37] <Ms2ger> Oh, C++11
[21:39:42] <Sharp> No, I don't, tautologico.
[21:39:46] <Ms2ger> I was thinking about usable C++ ;)
[21:39:54] <strcat> Ms2ger: how is C++11 not 'usable'?
[21:39:55] <kimundi> But is planned for rust closures to become like c++ closures, it just probably not going to happen before 1.0
[21:40:00] <Sharp> I meant in languages that don't let you do crazy things like C++ templates do.
[21:40:05] *** Joins: geoffhill (geoffhill@514D668A.DB14657A.BCDF04A6.IP)
[21:40:05] <kimundi> it is*
[21:40:09] <strcat> Ms2ger: clang/gcc are both full C++11 implementations...
[21:40:16] <strcat> unlike rustc they are production compilers
[21:40:20] <Ms2ger> How about msvc?
[21:40:23] <cmr> Ms2ger: msvc too.
[21:40:29] <cmr> well
[21:40:32] <strcat> cmr: no it's not a full C++11 implementation
[21:40:36] <cmr> not full, it still has problems
[21:40:37] <strcat> Ms2ger: last time I checked it couldn't compile rust either
[21:40:39] <Amaranth> MSVC isn't full C++11 but most of the really useful bits
[21:40:40] <sam113101> are C++ templates good?
[21:40:44] <strcat> Ms2ger: or C99
[21:40:45] <tautologico> C++11 has a lot of good stuff, but it's very recent too
[21:40:53] <Sharp> If you like undecidable type systems, C++ templates are good.
[21:41:08] <tautologico> even if the compilers are already compliant, most people in the wild are not producing C++11 code right now
[21:41:12] <strcat> rust generics are an undecidable type system, aren't they?
[21:41:16] <strcat> you can recurse forever
[21:41:24] <Earnestly> strcat: To be fair, gcc doesn't even have /full/ C99 support.
[21:41:30] <bjz> strcat: you can?
[21:41:33] <strcat> bjz: yes
[21:41:36] <Sharp> strcat: I don't think you can
[21:41:38] <Sharp> Unless we are extending H-M
[21:41:41] <Amaranth> gcc doesn't do C generics, does it?
[21:41:45] <Sharp> In incompatible ways
[21:41:47] <strcat> Sharp: not talking about type inference
[21:41:55] *** Quits: geoffhill (geoffhill@514D668A.DB14657A.BCDF04A6.IP) (Ping timeout)
[21:41:56] <strcat> Sharp: sure
[21:41:58] <strcat> rust has subtyping
[21:42:01] <strcat> it's not pure H-M
[21:42:06] <Sharp> Oh, right.
[21:42:13] <strcat> lifetimes are subtyping and pcwalton wants to add single inheritance
[21:42:19] <Sharp> Yeah, I know :(
[21:42:24] <kimundi> strcat: Which cases of generic recursion are you talking about?
[21:43:05] * kimundi knows about macro recursion and regular recursion, but isn't aware of any in the regular type system
[21:43:21] *** Quits: adu (ajr@moz-60B25736.washdc.fios.verizon.net) (Quit: adu)
[21:43:28] <strcat> you can define types recursively in terms of themselves
[21:43:56] <Sharp> Not with an occurs check.
[21:44:00] <kimundi> ... Which the compiler will complain about and refuse to compile. I don'T see the issue with that?
[21:44:15] <strcat> kimundi: there are plenty, https://github.com/mozilla/rust/issues/4287
[21:44:26] <strcat> and I doubt you can solve it completely
[21:44:50] *** Quits: Lovot (root@AE31FB56.8153C3BF.F3C9A2D9.IP) (Quit: Lost terminal)
[21:44:50] <strcat> when there are associated types/constants you will be able to have a lot more fun too
[21:45:43] <Sharp> When you say "solve" what do you mean?
[21:46:08] <Sharp> That Cons type won't work in any language.  In the languages where it works, it's just implicitly a pointer.
[21:46:09] *** Quits: alonlevy (alon@moz-B0E66DB7.static.bezeqint.net) (Ping timeout)
[21:46:23] <strcat> Sharp: 'solve' as in 'not recurse infinitely'
[21:46:30] <strcat> as in 'give a type error'
[21:46:40] <Sharp> It *should* be solvable
[21:46:43] <Sharp> I think provably so.
[21:46:43] <strcat> and without hardcoding some arbitrary recursion limit
[21:46:50] <strcat> like C++ compilers do
[21:46:57] <Sharp> Yes, without that...
[21:47:02] <Sharp> C++ compilers have to because templates can do things
[21:47:09] <Sharp> That make it impossible to reliably perform an occurs check.
[21:48:08] <Sharp> But Rust's generics (at least for now) can't, I don't think.  Maybe subtyping and single inheritance change that, I'm not positive.
[21:48:09] *** Quits: mikezaby (mikezaby@moz-B26868E.home.otenet.gr) (Input/output error)
[21:48:33] <Sharp> I don't *think* single inheritance does.
[21:48:39] <strcat> generic impls make life harder too
[21:49:04] <strcat> impl<T: Foo> Baz for T {} impl<T: Bar> Baz for T {}
[21:49:32] <strcat> if they overlap, you have an error when you use a method from them
[21:49:43] <strcat> already seems like a step away from type-checking from a definition
[21:49:56] <Sharp> Yeah, that's what's not so great about them… though I'm not sure in principle that isn't just a type unification issue.
[21:50:35] *** Quits: freezerburnv (freezerbur@moz-C5EF929C.washdc.fios.verizon.net) (Quit: freezerburnv)
[21:51:25] <Sharp> I *think* the issue there is less "it can't be done" and more about whether it can efficiently be done.
[21:51:33] *** Quits: Kruppe (user@moz-E150F49F.cpe.net.cable.rogers.com) (Client exited)
[21:51:55] *** Joins: Kruppe (user@moz-E150F49F.cpe.net.cable.rogers.com)
[21:54:55] <reedlepee> https://github.com/mozilla/rust/issues/1921 What i understood is function get_concurrency is returning how many test can be run at one time.. So in function get_concurrency we should call running_on_valgrind if that returns true we should return 1 from get_concurrency  else return whatever returning previously.
[21:55:03] <reedlepee> right ?
[21:58:15] <SiegeLord> Anyway, I think there are more important issues in Rust than "we can't write Boost in it" :P
[21:58:21] <tautologico> reedlepee: are you going to work on #9543 ?
[21:59:27] <reedlepee> tautologico: I tried looking into it .. but I am not clear how do i change libsyntax
[22:00:06] <strcat> SiegeLord: yeah, misrepresenting what I said somehow makes it not important that C++ does closures/containers and smart pointers better than us
[22:00:15] <strcat> I don't remember saying anything about boost
[22:00:33] <tautologico> I think it's just a matter of changing the parser and ast, I may play around with this if you're not going to work on it
[22:00:42] <SiegeLord> Even that doesn't seem that important...
[22:00:57] <SiegeLord> Rust doesn't have parity with C in some things
[22:01:12] <SiegeLord> Like ability to preserve the ABI
[22:01:22] <strcat> and that's a problem too
[22:01:34] <SiegeLord> That's an actual thing that'll ruin your life... a smart pointer that requires horrible syntax? Not as much
[22:01:34] <strcat> the fact that we are moving more towards reflection is a problem 
[22:01:58] <reedlepee> tautologico: what needs to be changed ?
[22:02:45] <tautologico> reedlepee: look at the parser, it should not allow the outdated construction anymore
[22:02:49] <strcat> SiegeLord: you can't write a vector type or pointer type doing allocation itself in the library at all
[22:02:54] <Sharp> ++strcat re: reflection.
[22:02:57] <strcat> it's not possible
[22:03:24] <strcat> managed pointers prevent that, and currently kinds do as well
[22:03:49] <SiegeLord> What about that custom vector type you made? What's wrong with that?
[22:03:54] <bjz> strcat: I wonder if it's a case for trying to desugar rust into a core kernel language
[22:04:02] <strcat> SiegeLord: doesn't work if there are managed ptrs
[22:04:26] <strcat> rust-core doesn't have reflection or managed ptrs, and won't
[22:04:41] <strcat> so it can work there, but T has to be bounded by Send+Freeze for now, which sucks
[22:04:58] <SiegeLord> So... just need a NonManaged kind or something?
[22:05:13] <bjz> strcat: of course that would be a huge undertaking
[22:05:20] <strcat> well, if everyone is okay with not being able to put managed pointers in containers
[22:05:21] <strcat> sure
[22:05:28] <bjz> strcat: probably too big
[22:05:39] * Sharp is okay with it :P
[22:06:08] <Sharp> Someone can make a ManagedContainer to handle that relatively rare situation.
[22:06:08] <strcat> I have no problem with managed pointers becoming unusable and rust never having a GC, but I am pretty sure others want that
[22:06:13] <SiegeLord> I still don't get why you can't have a ManagedVector and NonManagedVector... can you not write std::iter accepting both?
[22:06:25] <strcat> SiegeLord: because lots of stuff uses ~[T]
[22:06:36] <SiegeLord> Well, that's just a library problem
[22:07:03] <strcat> it's not possible to write a library type that changes representation based on whether T is managed
[22:07:12] <strcat> rust isn't capable of writing that kind of generic code
[22:07:57] <Sharp> In principle, why couldn't Rust be capable of writing that kind of code?  It's something that can be checked at compile time, is it not?
[22:08:02] <SiegeLord> It's not a single type though...
[22:08:27] <strcat> so what are we going to do with all of the code that uses a generic type T and then stores it in ~[T]?
[22:08:48] <strcat> such as extra::ringbuf, extra::priority_queue and plenty of other stuff
[22:09:00] *** Parts: Yeri (jasonjasmi@BA0CD88C.B2E00889.31F69D78.IP) ()
[22:09:06] <Sharp> They should explicitly require T to be nonmanaged.  It's not like we don't already require things like Clone all the time.
[22:09:16] <SiegeLord> That's a library problem that can be fixed, assuming a NonManaged trait exists
[22:09:17] <strcat> the containers don't require Clone
[22:09:24] <SiegeLord> *kind
[22:09:26] <strcat> SiegeLord: so managed ptrs won't work in the containers
[22:09:31] <Sharp> No, but my point is that there is precedent.
[22:09:45] <SiegeLord> You'll specify the type of their internal vector at creation time
[22:09:56] *** Quits: ross (ross@moz-5EA04060.br.br.cox.net) (Quit: )
[22:09:57] <SiegeLord> Is that not possible to do?
[22:10:01] <Sharp> I simply don't think managed types should be used in most situations and I think most people already agree, so anyone using them is doing so because they *have* to
[22:10:09] <Sharp> Or should be
[22:10:21] <Sharp> Making most libraries incompatible with them just helps solidify that in the general case.
[22:10:21] <strcat> you never 'have' to
[22:10:24] *** Quits: dew (Instantbir@moz-E4452B8F.static.stls.mo.charter.com) (Ping timeout)
[22:10:27] <Sharp> No, you can always use unsafe pointers.
[22:10:41] <Sharp> But sometimes you 'have' to in the way that Servo 'has' to use OO
[22:10:44] <SiegeLord> Something like: HashMap::<NonManagedVector, KeyT, ValT>::new()
[22:10:47] <Sharp> Where you can do it otherwise but it's inefficient.
[22:11:10] <Sharp> Or you end up reimplementing GC.
[22:11:14] <strcat> SiegeLord: and you need a way to pass an allocator
[22:11:25] <strcat> but ManagedVector wouldn't allow allocators
[22:11:42] <strcat> also, rust won't let you do that
[22:11:46] <strcat> you need to pass the complete type
[22:11:53] <Sharp> Currently.
[22:11:59] <Sharp> That's something I thought people wanted to change.
[22:12:05] <strcat> I don't think so
[22:12:19] <Sharp> I thought .. in type variable lists was in the works, maybe not.
[22:12:27] <strcat> doubt it
[22:13:27] *** Joins: dew (Instantbir@moz-E4452B8F.static.stls.mo.charter.com)
[22:13:41] * Sharp would think it would be a relatively noncontroversial feature given that it's one of the more boilerplate-y things in Rust at the moment.
[22:13:51] <strcat> you mean where you have to do
[22:13:53] *** Quits: Excureo (c@moz-EB93D257.static.knwc.wa.charter.com) (Ping timeout)
[22:14:52] <strcat> <K: Eq + Hash, V, A: Allocator, V: Vec<(K, V), A>
[22:14:57] <strcat> <K: Eq + Hash, V, A: Allocator, V: Vec<(K, V), A>>
[22:15:00] <cmr> Sharp: it's merely a crackdream in eddyb's head.
[22:15:29] <Sharp> cmr: Heh.  I thought eddyb wanted variable-size tyvar lists, which are different.
[22:15:33] *** Quits: Engineer (engineer@moz-C4BE28E4.c3-0.upd-ubr1.trpr-upd.pa.cable.rcn.com) (Quit: Leaving)
[22:15:43] <Sharp> strcat: Yeah.  As long as it can be inferred it shouldn't be necessary to constantly repeat it.
[22:15:52] <cmr> Sharp: what would .. do, then?
[22:15:55] *** Joins: Excureo (c@moz-EB93D257.static.knwc.wa.charter.com)
[22:16:15] <Sharp> cmr: Where it was unambiguous what the remaining type arguments would be, .. would just let you not include them.  Maybe _ would work there too.
[22:16:23] <strcat> Sharp: inferred vs. not inferred is one of the big differences from haskell/C++ though
[22:16:26] <cmr> Sharp: that'd be ..
[22:16:30] <strcat> it's intended to be an explicit list of all the requirements
[22:16:46] <Sharp> We already infer much more than C++ does, do we not?
[22:17:24] <tautologico> I'm getting errors from xcrun while building rust on OS X, is this something related to Xcode's version?
[22:17:36] <Sharp> I mean, I'm fine with inference where it actually adds meaningful information for the reader.  I just don't see how explicitly listing that third variable is accomplishing that in this case.
[22:17:44] <Sharp> Er, noniference.
[22:17:47] <Sharp> *noninference.
[22:21:07] *** Quits: dew (Instantbir@moz-E4452B8F.static.stls.mo.charter.com) (Ping timeout)
[22:21:09] *** Joins: dew (Instantbir@moz-E4452B8F.static.stls.mo.charter.com)
[22:21:10] *** Quits: strcat (strcat@moz-54F7FD49.cpe.net.cable.rogers.com) (Quit: WeeChat 0.4.2)
[22:22:00] <mark_edward> when will rust get those allocator/pointer types as a library?
[22:22:33] <cmr> mark_edward: Soon (TM)
[22:22:44] <mark_edward> pre-1.0?
[22:22:52] <cmr> yes
[22:23:21] <mark_edward> i'd love to make a custom allocator that simply never deallocates, lets the system cleanup at process death
[22:23:33] <mark_edward> dmd does something like that for speed, since it's shortlived
[22:24:01] *** Quits: dew (Instantbir@moz-E4452B8F.static.stls.mo.charter.com) (Ping timeout)
[22:24:12] <Sharp> mark_edward: Just use malloc? :P
[22:24:15] *** Joins: mib_6ni8m8 (Mibbit@moz-6E579F4B.superkabel.de)
[22:24:22] <mark_edward> basically
[22:24:30] <Sharp> I mean, you can already do that.
[22:24:35] *** Joins: lenstr_ (lenstr@AF8EB999.6049B16A.85938D85.IP)
[22:24:44] *** Quits: lenstr (lenstr@AF8EB999.6049B16A.85938D85.IP) (Ping timeout)
[22:24:51] <Sharp> It's definitionally unsafe so it's not like you will be able to get around unsafe blocks by using this new allocator type.
[22:25:03] *** Joins: dew (Instantbir@moz-E4452B8F.static.stls.mo.charter.com)
[22:25:13] *** Joins: adu (ajr@moz-60B25736.washdc.fios.verizon.net)
[22:25:22] *** Quits: eevee (eevee@moz-7B6C48E3.evrt.wa.frontiernet.net) (Ping timeout)
[22:27:08] <SiegeLord> So what am I missing here: https://gist.github.com/SiegeLord/7284175
[22:27:42] <SiegeLord> I seem to be able to pass a backing vector type to a container without any issue...
[22:32:44] *** Quits: Ms2ger (Ms2ger@moz-6EEC6E4D.adsl-dyn.isp.belgacom.be) (Quit: nn)
[22:33:13] *** Quits: Blub\w (wry@7E3BB9D.71150E1A.237AE2BA.IP) (Quit: night)
[22:34:21] *** Joins: HollyRain (HollyRain@moz-50A83091.dyn.user.ono.com)
[22:34:51] <HollyRain> how to read a file?
[22:35:35] *** Quits: jvshahid (jvshahid@moz-C1BC0CE4.nyc.res.rr.com) (Ping timeout)
[22:35:43] <SiegeLord> Something like this: BufferedReader(Path::new("test.txt").open_reader(Open)).read
[22:35:52] *** Quits: boredomist (ruqs@B16F530C.DC641F2C.BCAEBB33.IP) (Ping timeout)
[22:36:34] <SiegeLord> *BufferedReader::new(
[22:36:43] <HollyRain> SiegeLord, does it allows to read it line by line?
[22:37:10] <SiegeLord> Yes, read_line instead of read
[22:37:19] <HollyRain> perfect, thanks
[22:37:31] <Sharp> SiegeLord: I'm confused, what is that demonstrating?
[22:37:55] <SiegeLord> Sharp: Well, my point was that you could build a container library without assuming ~[] as the backing vector
[22:37:55] *** Quits: jeffdb (jeff@moz-ED35AD97.hsd1.ca.comcast.net) (Quit: jeffdb)
[22:38:04] <SiegeLord> Since ~[] by design has to allow managed pointers
[22:38:07] <Sharp> Yeah, but for & to work like that
[22:38:16] <Sharp> The compiler has to know that it can use @ or ~
[22:38:25] <Sharp> And rewrite code accordingly
[22:38:46] <Sharp> So in general anything that needs to branch on that has to be known ahead of time by the compiler.
[22:38:56] <SiegeLord> "Yeah, but for & to work like that" work like what?
[22:39:03] <SiegeLord> I'm not 100% sure what you men
[22:39:04] <Sharp> To actually work at all :)
[22:39:05] <SiegeLord> *mean
[22:39:17] <Sharp> To allow you to reference pointers of either type.
[22:40:53] <SiegeLord> Ok... so what does that have to do with vectors at all?
[22:41:07] <Sharp> It's not implicitly about vectors, it's about managed pointers.
[22:41:16] <Sharp> And the way GC works right now.
[22:41:47] <Sharp> It's not necessary with a different GC system for vectors not to be allowed to contain managed pointers, but it is with any GC system we're likely to have anytime soon.  At least, that is strcat's contention.
[22:43:02] *** Quits: nsf (nsf@moz-EEF3238A.convex.ru) (Quit: WeeChat 0.4.2)
[22:44:08] *** Joins: samnardoni (samnardoni@FC9A45BE.3393236F.BFD1ABFD.IP)
[22:44:11] *** Quits: dbaupp (Thunderbir@moz-EA596755.lns20.syd6.internode.on.net) (Ping timeout)
[22:45:52] *** Quits: samnardoni (samnardoni@FC9A45BE.3393236F.BFD1ABFD.IP) (Ping timeout)
[22:46:45] <sam113101> who's bors?
[22:46:49] <SiegeLord> I'm still not quite getting it... oh well
[22:47:02] <Sharp> GC needs to be able to go through roots and figure out if they're still being used
[22:47:30] <Sharp> So for a naive GC system that assumes anything on the heap can be a root (more or less) it needs certain information
[22:47:43] <Sharp> Which exists in our current vector implementation but not in the one strcat wrote
[22:47:45] <bjz> cmr: do you know if extern dependencies works with rustpkg yet?
[22:47:50] <kimundi> sam113101: Integrations bot
[22:47:51] <cmr> sam113101: bot, tests PRs and merges them if they pass.
[22:48:11] *** Joins: dbaupp (Thunderbir@moz-EA596755.lns20.syd6.internode.on.net)
[22:48:22] <Sharp> A different GC implementation could keep track of the roots in other ways and would not have this problem.  But apparently LLVM does not have good support for that.
[22:48:28] <Sharp> And won't for a while.
[22:49:22] <cmr> bjz: they do, yes, but there is transient brokenness in actually fetching them.
[22:49:24] *** Quits: rustic (engineer@946A1967.A3B62A92.3ABBA12E.IP) (Quit: Nettalk6 - www.ntalk.de)
[22:49:36] <bjz> cmr: what does that mean?
[22:49:49] <cmr> bjz: the git clone sometimes fails.
[22:50:02] <bjz> cmr: ah
[22:50:22] <bjz> what workflow do you normall use to build gl-rs/src/generator?
[22:50:29] <sam113101> cmr: "test"?
[22:50:38] <cmr> sam113101: make check
[22:50:45] <cmr> bjz: I just used rustc :(
[22:50:46] *** Joins: jvshahid (jvshahid@moz-C1BC0CE4.nyc.res.rr.com)
[22:50:51] <bjz> :[
[22:50:53] *** Quits: reedlepee (Mibbit@9B9315E1.A6025CA.1C37C358.IP) (Quit: http://www.mibbit.com ajax IRC Client)
[22:50:54] <sam113101> ah
[22:51:45] *** Joins: samnardoni (samnardoni@FC9A45BE.3393236F.BFD1ABFD.IP)
[22:53:58] <HollyRain> I just look the documentation (manual, tutorial and modules) and I've to give thanks and kudos to the team. Great work!
[22:54:03] <SiegeLord> Sharp: So is the statement that if you take a borrowed pointer to GC'd memory and store it in an area which the GC has no knowledge of, it'll leak?
[22:54:35] <SiegeLord> Or rather, that reference will become dangling
[22:54:55] <Sharp> More like, when a vector with a borrowed pointer is freed the GC needs to know that that memory is no longer a root, which means it has to have known that the memory was a root in the first place.
[22:55:11] <Sharp> Or, yeah.  That.
[22:55:24] <sam113101> what happened to graydon
[22:55:38] <SiegeLord> That seems surprising to me, does the lifetime analysis not prevent that at all?
[22:55:42] *** Quits: Ferreus (ferreus@moz-870D435F.pools.arcor-ip.net) (Ping timeout)
[22:55:56] <Sharp> Not with @ pointers, @ pointers are handled by GC.
[22:57:31] <SiegeLord> Well, sure... but the function that returns the borrowed pointer will have to have a lifetime... is it not guaranteed that that lifetime will be shorter than the "local" lifetime of the @ you got it from?
[22:57:37] *** Quits: nif (Mibbit@moz-B6DFA19D.wireless.oberlin.edu) (Quit: http://www.mibbit.com ajax IRC Client)
[22:58:25] <Sharp> I mean, yeah, it's definitely the case that its lifetime will be shorter than the @ if things are working correctly
[22:58:30] <Sharp> But the only way to actually make sure that happens
[22:58:42] <Sharp> And still be able to remove the @ at at all
[22:58:46] <Sharp> *@ at
[22:59:10] <Sharp> Is to be able to know when those pointers are alive, which means being able to follow their roots.
[22:59:59] <FreeFull> You also have raw pointers
[23:00:06] <Sharp> Raw pointers are unsafe.
[23:00:12] <FreeFull> That's the point of them
[23:00:15] <Sharp> Yeah.
[23:00:31] <FreeFull> They are probably the closest pointer type to C pointers in Rust
[23:00:39] <cmr> They are C pointers
[23:00:42] <Sharp> They are C pointers
[23:00:43] <Sharp> Beaten.
[23:00:46] *** Quits: jvshahid (jvshahid@moz-C1BC0CE4.nyc.res.rr.com) (Ping timeout)
[23:00:58] <FreeFull> Being something is the closest you can get to it
[23:00:59] <Sharp> A refcounting solution (which we use now) *still* has to be aware of that.  You can try to be smarter about it by branching at compiler time based on whether there are @s in the vector or not, which we sort of do now, but not everywhere and not consistently
[23:01:03] <cmr> Touche
[23:01:05] <Sharp> It's much easier to just ban them
[23:01:16] *** Quits: mib_6ni8m8 (Mibbit@moz-6E579F4B.superkabel.de) (Quit: http://www.mibbit.com ajax IRC Client)
[23:01:47] <FreeFull> Simplistic refcounting doesn't deal with cycles
[23:02:00] <SiegeLord> Still not quite sure why vectors are special, what if you store a reference to @ inside a ~Struct?
[23:02:30] <Sharp> Then the ~ takes care of the problem, not the vector, so it doesn't change the vector's implementation
[23:03:36] <cmr> Interesting
[23:03:36] <Sharp> Or maybe I'm not sure what you mean.  Vectors have additional metadata that can be stored more efficiently with cmr's approach than the approach that works with GC
[23:03:50] <cmr> We have 4-5 new contributors a week for as long as I've been tracking.
[23:04:04] <cmr> Sharp: strcat's, not mine.
[23:04:07] *** Quits: lenstr_ (lenstr@AF8EB999.6049B16A.85938D85.IP) (Quit: Leaving...)
[23:04:09] <Sharp> Er, sorry.  Yes.
[23:04:46] *** Quits: spider-mario (spidermari@moz-81131DB6.fbx.proxad.net) (Input/output error)
[23:04:50] <Sharp> ~ would have a similar problem if there were equivalent issues with ~ (there aren't as far as I'm aware, but it's possible).
[23:05:01] <dbaupp> cmr: i.e. 3 weeks?
[23:05:03] *** Joins: themgt (themgt@moz-83F07CDA.cm.vtr.net)
[23:05:10] <cmr> dbaupp: yeah
[23:05:34] <SiegeLord> It just seems to me that the GC will have to know about every ~ as well
[23:05:41] <SiegeLord> as well as every ~[]
[23:05:47] <cmr> 64 PRs this week! \o/
[23:05:52] <Sharp> Yes, but there's nothing you want to do differently with ~ than we're already doing.
[23:05:59] <Sharp> Whereas ~[] without GC can look quite different.
[23:06:51] <SiegeLord> I find that... strange. Granted, I don't know about GC's, but my experience with D's GC told me that all you have to do is tell the GC about a region of memory it needs to look through
[23:07:56] <Sharp> Like I said, it's not a hard requirement for GCs, it's a GC (and vector) implementation issue.  I don't know anything about D so I can't really say anything more than that.
[23:08:14] *** Quits: blank_name (blank_name@FAB53C88.7071B2C8.31EC03F3.IP) (Ping timeout)
[23:08:49] *** Quits: adu (ajr@moz-60B25736.washdc.fios.verizon.net) (Quit: adu)
[23:09:06] *** Joins: jvshahid (jvshahid@moz-C1BC0CE4.nyc.res.rr.com)
[23:11:17] *** Joins: blank_name (blank_name@FAB53C88.7071B2C8.31EC03F3.IP)
[23:12:09] *** Quits: donri (donri@moz-9BB61102.tbcn.telia.com) (Client exited)
[23:15:07] <SiegeLord> I think D does allocate for 0 size vectors, but it's GC API simply has an addRange(ptr, size) function
[23:15:14] *** Joins: Lovot (root@AE31FB56.8153C3BF.F3C9A2D9.IP)
[23:15:37] <SiegeLord> So you could write a vector based on C's malloc and assuming you routinely tell the GC about it, everything should be ok...
[23:16:10] <Sharp> If D allocates for size 0 vectors, it is just like our allocator, and probably has bad performance like our vectors too.
[23:16:25] <Sharp> Well, maybe not just like.
[23:17:05] <SiegeLord> That very well may be, but the point is that you could write a malloc'd one that wouldn't have to, and would still work with the GC
[23:17:05] *** Joins: aegeaner (Aegeaner@129DA5B7.364C5DC1.A28F48E3.IP)
[23:17:12] *** Joins: lenstr (lenstr@AF8EB999.6049B16A.85938D85.IP)
[23:17:14] *** Quits: aegeaner (Aegeaner@129DA5B7.364C5DC1.A28F48E3.IP) (Quit: Leaving.)
[23:17:17] <Sharp> How do you think you tell the GC about it?
[23:17:18] <SiegeLord> And D uses LLVM in one specific implementation, so it's not like a custom backend thing
[23:17:49] <Sharp> There are a variety of ways but the way we're using (and I assume LLVM supports) is kind of crappy.
[23:17:50] <SiegeLord> You call a function, addRange(ptr, size)
[23:18:02] <Sharp> And where is the range stored?
[23:18:19] <SiegeLord> That's uniportant, the point is you don't need to do it until you have at least one element
[23:18:33] <Sharp> No, it's very important, because the only difference between strcat's and our current vecotr implementation is where it's stored.
[23:18:39] <Sharp> *vector
[23:18:40] <SiegeLord> Obviously once you have an element, the GC needs to store the range somewhere
[23:19:03] <SiegeLord> The pointer to it/size that is
[23:19:16] <Sharp> I think you are missing the point.  The problem isn't that we're unoptimized for zero size vectors.  It's that we're unoptimized for vector access in general.
[23:20:21] *** Quits: canhtak (canhtak@moz-A161DED8.wl.t.ulaval.ca) (Quit: canhtak)
[23:20:25] *** Quits: maik (maik@moz-AC35752F.dip0.t-ipconnect.de) (Connection reset by peer)
[23:20:35] *** Joins: strcat (strcat@moz-54F7FD49.cpe.net.cable.rogers.com)
[23:21:15] <Sharp> Also, correct me if I'm wrong, SiegeLord, but the GC needs to be running the entire time for addRange to work, if it's not known until runtime whether or not it will be called.
[23:21:37] <SiegeLord> Yes, that's correct
[23:21:59] <Sharp> The whole point of Rust is that the GC shouldn't have to run--or affect representations--unless you are actually using GC.
[23:22:05] <SiegeLord> But the point is... in principle you could check if the GC is on
[23:22:07] <Sharp> (Or affect running time :P)
[23:22:12] <SiegeLord> And if it's not, then not call addRange
[23:22:14] *** Quits: notmatt (notmatt@moz-9FB2565E.vc.shawcable.net) (Client exited)
[23:22:27] <Sharp> Yes, you could branch everywhere.  If you do it at runtime GC is affecting you though.
[23:22:44] <Sharp> You can do it at compile time but it becomes very unwieldy and spaghetti code-ish, and you have to do it consistently.
[23:22:57] <SiegeLord> That seems to be a minor check compared to allocating memory period, no?
[23:23:16] <sam113101> when will rust 0.9 be released?
[23:23:16] <Sharp> Not really, because everywhere that tries to access the memory has to know, too
[23:23:38] <strcat> sam113101: the tags are done every 3 months
[23:23:45] <strcat> they are just a time-based tag on master
[23:23:56] <strcat> there are no milestones for them or anything
[23:24:11] <Sharp> strcat: I assume it will go 0.10 rather than 1.0?
[23:24:19] <strcat> likely, it's a semver
[23:24:31] *** Quits: themgt (themgt@moz-83F07CDA.cm.vtr.net) (Ping timeout)
[23:24:59] *** Joins: Ferreus (ferreus@moz-92CD5E84.pools.arcor-ip.net)
[23:25:07] <sam113101> strcat: aaaww shit
[23:25:14] <mletterle> tidy is a cruel mistress
[23:25:52] *** Joins: themgt (themgt@moz-83F07CDA.cm.vtr.net)
[23:27:14] *** Joins: nomadic (nomadic@moz-E01D5C49.hsd1.ga.comcast.net)
[23:27:21] <sam113101> when will rust become "stable", then?
[23:27:30] <strcat> what do you mean 'stable'?
[23:28:02] <strcat> the rate of change to the language has greatly slowed down
[23:28:16] <sam113101> that things aren't going to break all the time, people will be able to start writing books without them getting outdated the next month
[23:28:43] <strcat> don't know
[23:29:09] <sam113101> I thought 1.0 would be the one bringing stability
[23:29:18] <strcat> some extent of stability
[23:29:19] <sam113101> and I thought it would be 1.0 after 0.9
[23:30:00] <strcat> version numbers aren't usually decimals, the point is a separator
[23:30:07] <SiegeLord> The latest ETA for 1.0 is in 8-9 months
[23:30:08] <strcat> major.minor.patch
[23:30:19] <SiegeLord> But 6 months ago, it was this winter... so it could be pushed back again
[23:30:27] <strcat> yeah but what does 1.0 mean? the libraries are mostly not going to be stable
[23:30:36] <strcat> it's not well defined what 1.0 will mean yet
[23:30:41] *** Joins: canhtak (canhtak@moz-A161DED8.wl.t.ulaval.ca)
[23:30:56] <strcat> perhaps it will mean the language that's exposed without #[feature] flags will be backwards compatible
[23:31:29] <strcat> maybe we'll even tag a few things in the stdlib with #[stable]
[23:31:54] <Sharp> strcat: Is there any reason in principle why a 0-size vector couldn't just be an integer rather than a pointer?
[23:32:26] <strcat> if it's a library type the representation has to be same regardless of the type parameters
[23:32:43] <strcat> and if you do that with ~[T], it's going to add an extra branch to every function
[23:32:48] <strcat> for --opt-level=0
[23:33:23] <strcat> seems to me that a vector of zero-size types is a questionable thing to make ;p
[23:33:30] <Sharp> Perhaps so :)
[23:33:39] <Sharp> If you just want a length, you should probably just store a length :P
[23:33:50] <strcat> generic code is nice when it factors out generic patterns
[23:33:56] *** Quits: lenstr (lenstr@AF8EB999.6049B16A.85938D85.IP) (Quit: Leaving...)
[23:33:59] <strcat> but I've yet to find a case where zero-size types are used in such a way
[23:34:14] <Sharp> What are they used for?  I assume mostly ugly hacks.
[23:34:29] <strcat> Sharp: for example, sets are implemented in terms of maps using () as the value type
[23:34:50] <strcat> Sharp: and in rust-core, there will be allocators, which get stored in the container, so it's important for the default one to be zero-size
[23:35:01] <Sharp> Ah, I see.
[23:35:06] <strcat> Sharp: https://gist.github.com/thestinger/7275558 if generic dtors worked, that'd work
[23:35:10] <Sharp> But those aren't 0 size vectors.
[23:35:18] <strcat> right
[23:35:31] <strcat> I've yet to find a good reason you'd want to stick zero-size types in a vector
[23:36:02] <Sharp> You're trying to break rustc? :)
[23:36:02] <strcat> but there are good reasons to have zero-size types, when you're using generic code and don't need state for that type
[23:36:09] <strcat> Sharp: hm?
[23:36:15] <strcat> oh
[23:36:22] <Sharp> (Reasons to put zero-size types in a vector).
[23:36:29] <strcat> hrm
[23:36:29] *** Joins: alex-abreu (alex@moz-7421D6C9.mc.videotron.ca)
[23:36:51] <strcat> it's really hard to think of generic code where you'd be putting values in a vector and the caller would have some reason to want to use that code, but for a stateless type
[23:37:18] *** Joins: earlzlap (earlz@moz-9E279EAD.neo.res.rr.com)
[23:37:34] <Sharp> I can think of generic code where I'd want to pass a vector that was always empty, but that's not really the same thing.
[23:37:43] <Sharp> And it's not a type, I don't think.
[23:39:03] *** Quits: earlzlap (earlz@moz-9E279EAD.neo.res.rr.com) (Ping timeout)
[23:42:02] *** Quits: btipling (btipling@moz-D51E0AEB.xen.prgmr.com) (Quit: ZNC - http://znc.sourceforge.net)
[23:42:30] <dbaupp> strcat: /** retrieve one value from each element of dists. */ sample_many<S: Sample<f64>>(dists: &[S]) -> ~[f64], with a Sample-r that doesn't have any state.
[23:43:09] *** Joins: btipling (btipling@moz-D51E0AEB.xen.prgmr.com)
[23:43:19] * dbaupp is possibly misunderstanding something, of course.
[23:45:18] <strcat> dbaupp: you wouldn't ever want to call that with a zero-size type though, would you?
[23:45:37] <strcat> if there's no state, what is it for? ;p
[23:47:46] <dbaupp> generic code
[23:48:42] <strcat> dbaupp: not talking about it in general
[23:48:44] <Sharp> dbaupp: But if each element of dists is the same why would you use sample_many?
[23:48:45] <strcat> zero-size types are useful
[23:49:08] <dbaupp> Sharp: internally to some other generic function, so it doesn't know that each element is the same.
[23:49:13] <strcat> zero-size types in vectors do not seem useful, so I don't think it's worth special-casing the vector representation for them
[23:49:31] <strcat> dbaupp: but why would you be calling that function with zero-size types?
[23:49:46] <strcat> I haven't seen a use case for it yet, so I don't think it merits an optimization or even considering the optimization
[23:49:46] <Sharp> For you to be doing that, you'd have to call it with a vector
[23:50:01] <Sharp> Which means that whatever that hypothetical wrapper is would have to have some useful reason to be called with a vector of zero size types
[23:50:18] <Sharp> Because there is no reason a generic function would deliberately create a vector of the same element and then pass it to sample_many
[23:51:10] *** Joins: simlay (simlay@moz-7C1CFB5E.dreamhost.com)
[23:51:39] <dbaupp> imagine sample_many ran each sample in parallel
[23:52:38] *** Quits: Earnestly (earnest@38FE72A5.82423D8F.BFD1ABFD.IP) (Ping timeout)
[23:52:44] <HollyRain> why cann't be used? use std::path; let p = &path::Path(filename);  => unresolved name `path::Path`
[23:52:49] *** Quits: tautologico (lymph@703660AA.CFE755C8.C27E1635.IP) (Quit: tautologico)
[23:53:15] <Sharp> If you have to create a vector to do that, aren't you going to lose those savings?
[23:53:26] <Sharp> I mean, maybe not in theory
[23:53:31] <jvshahid> is there a syntax sugar for macros that take a body as their last arg ? something similar to do() {}
[23:53:31] <strcat> HollyRain: there's no Path function in std::path http://static.rust-lang.org/doc/master/std/path/index.html
[23:53:36] <Sharp> I guess I can *theoretically* see a case where it might be desirable
[23:53:38] <dbaupp> Sharp: depends how expensive the sampling operation is
[23:53:48] <dbaupp> jvshahid: no
[23:54:13] *** Quits: samnardoni (samnardoni@FC9A45BE.3393236F.BFD1ABFD.IP) (Client exited)
[23:54:32] <jvshahid> dbaupp: thx
[23:54:34] *** Joins: samnardoni (samnardoni@FC9A45BE.3393236F.BFD1ABFD.IP)
[23:54:52] <Sharp> dbaupp: Seems to me that if you want to explicitly parallelize you should just do that, not rely on it as a side effect from some other function.
[23:55:02] <HollyRain> strcat, there is an example here (http://static.rust-lang.org/doc/master/std/rt/io/file/fn.open.html) using:  use std::path::Path; let p = &Path("/some/file/path.txt");
[23:55:16] <Sharp> Like… I could maybe stretch out this fake analog and convince myself that in a different world there was a usecase
[23:55:33] <strcat> HollyRain: well, the example is invalid
[23:55:36] *** Quits: aeqwa (aeqwa@moz-FF95955F.dsl.tropolys.de) (Quit: WeeChat 0.4.3-dev)
[23:55:43] <Sharp> But for it to be worth it the sample would have to be much more expensive than the overhead of creating a few bytes for the zero size type
[23:56:02] <Sharp> (Zero size type vector rather)
[23:56:14] <Sharp> And the code would be fantastically incorrect from a modeling standpoint.
[23:56:21] *** Quits: samnardoni (samnardoni@FC9A45BE.3393236F.BFD1ABFD.IP) (Ping timeout)
[23:56:50] <Sharp> What you'd really want is a repeatedly_sample<> function explicitly for that purpose
[23:56:55] <Sharp> Or sample_in_parallel<>
[23:57:32] <dbaupp> so you're saying the name "sample_many" was incorrect?
[23:57:46] <Sharp> Well, no, I'm saying that sample_many<> should have the primary purpose of sampling many distributions
[23:57:51] <Sharp> Not sampling one distribution many times
[23:58:03] <dbaupp> that's what the vector code does?
[23:58:07] <Sharp> I suspect there are optimizations you can make for the latter that are more far reaching than for the former...
[23:58:29] <Sharp> Which vector code?
[23:58:40] <dbaupp> oh, I see.
[23:59:26] <dbaupp> I was saying that each instance of a S: Sample<f64> is a different distribution even though they all have the same type (i.e. different parameters), but you're not saying that.
[23:59:56] <strcat> Sharp: fwiw, the library vector implementation just calls malloc(0) which may or may not allocate any memory

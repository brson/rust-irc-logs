[00:03:45] *** Quits: cgaebel (clark@ADA4DDE2.290DF317.EE6E63A5.IP) (Quit: ChatZilla 0.9.90.1 [Firefox 26.0/20131206145143])
[00:04:08] *** Joins: lpy (lpy@B744D17C.B31F127E.E99F7FDB.IP)
[00:06:14] *** Quits: lpy (lpy@B744D17C.B31F127E.E99F7FDB.IP) (Ping timeout)
[00:11:44] *** Quits: jensnockert (jensnocker@moz-7DC16A5F.afb.bredband2.com) (Input/output error)
[00:22:39] *** kimundi is now known as zz_kimundi
[00:29:42] <canhtak> Hi Rust, I have a question.
[00:30:32] <canhtak> Someone now where add the extern mods needed to build the tests for guide-something docs?
[00:36:39] *** Quits: jdm (jdm@A7937365.8212E19F.1D05C454.IP) (Quit: Lost terminal)
[00:40:26] <eddyb> acrichto: woo, it substitutes!
[00:41:03] <eddyb> acrichto: now I need to fix pretty printing to consider the expanded version identical to the original
[00:41:18] <dbaupp> eddyb: does it error?
[00:41:19] <eddyb> though that might be hard
[00:41:28] <eddyb> dbaupp: the bad one?
[00:41:49] <dbaupp> eddyb: <T = Option<U>, U = bool> etc.
[00:42:22] <dbaupp> eddyb: also, could you just record which arguments were defaulted?
[00:42:31] <dbaupp> (in a sidetable or directly in the type)
[00:43:27] <eddyb> maybe, I'd have to check in ty_struct, ty_enum and ty_trait
[00:44:41] <eddyb> struct Foo<T, U = Option<V>, V = bool>; fn main(){let x: Foo<int>;}
[00:44:50] <eddyb> task 'rustc' failed at 'index out of bounds: the len is 1 but the index is 2'
[00:45:07] <dbaupp> whoops :P
[00:45:24] <eddyb> dbaupp: it's what I expected
[00:46:00] <dbaupp> it's still wrong ;P
[00:46:49] <eddyb> oooh, I have a DefId for the type param
[00:47:16] <eddyb> so I can technically improve that ancient error
[00:48:44] *** Joins: TheHydroImpulse (TheHydroIm@moz-A9FB1B83.ed.shawcable.net)
[00:49:17] <eddyb> dbaupp: I wish I had a context in substs
[00:49:26] <dbaupp> can you add one?
[00:51:12] <eddyb> Option<codemap::Span> would do wonders, I guess
[00:52:07] *** Joins: nrc_ (nrc@6D0546D1.9A5DBD9A.84D1E168.IP)
[00:52:26] <acrichto> eddyb: nice!
[00:52:27] *** Quits: brson (brson@moz-BBE3ABD.mv.mozilla.com) (Ping timeout)
[00:52:39] *** Quits: nrc (nrc@7BE24E90.A5032A01.3CFC199D.IP) (Ping timeout)
[00:52:54] *** nrc_ is now known as nrc
[00:57:54] *** Quits: nrc (nrc@6D0546D1.9A5DBD9A.84D1E168.IP) (Ping timeout)
[00:58:27] *** Joins: nrc (nrc@7BE24E90.A5032A01.3CFC199D.IP)
[01:01:30] *** Joins: ghrust (ghrust@24260B07.6A2AE50.F3114085.IP)
[01:01:30] <ghrust> 01[13rust01] 15bors merged 06auto into 06master: 02http://git.io/gL8LLw
[01:01:30] *** Parts: ghrust (ghrust@24260B07.6A2AE50.F3114085.IP) ()
[01:02:50] *** Quits: dherman (dherman@moz-6CA476B1.hsd1.ca.comcast.net) (Quit: dherman)
[01:04:21] <eddyb> dbaupp: now I have to check which bugs I'm fixing :P
[01:04:53] *** Joins: lpy (lpy@B744D17C.B31F127E.E99F7FDB.IP)
[01:06:27] *** Joins: ghrust (ghrust@9C8B94D4.6A2AE50.F3114085.IP)
[01:06:28] <ghrust> 01[13rust01] 15bors pushed 0 new commits to 06auto: 02http://git.io/imvBzA
[01:06:28] *** Parts: ghrust (ghrust@9C8B94D4.6A2AE50.F3114085.IP) ()
[01:07:02] *** Quits: lpy (lpy@B744D17C.B31F127E.E99F7FDB.IP) (Ping timeout)
[01:07:10] *** Joins: cgaebel (clark@ADA4DDE2.290DF317.EE6E63A5.IP)
[01:11:27] *** Joins: ghrust (ghrust@1E8607E8.6A2AE50.F3114085.IP)
[01:11:27] <ghrust> 01[13rust01] 15bors pushed 2 new commits to 06auto: 02http://git.io/Y2QGQA
[01:11:27] <ghrust> 13rust/06auto 144f1564b 15David Manescu: Rename reserve to reserve_exact and reserve_at_least to reserve...
[01:11:27] <ghrust> 13rust/06auto 14c944a09 15bors: auto merge of #11951 : dmanescu/rust/reserve-rename, r=huonw...
[01:11:27] *** Parts: ghrust (ghrust@1E8607E8.6A2AE50.F3114085.IP) ()
[01:12:05] <eddyb> dbaupp: there's still an issue with inference
[01:17:25] <cgaebel> so I've been implementing the ToStr for my hashmap, and it allocates and copies a LOT. I feel like we should have a to_rope function which converts a data structure into a rope, and then to_str by default just does self.to_rope().to_str()
[01:18:16] * eddyb raises hand
[01:18:18] <dbaupp> cgaebel: the new formatting infrastructure in std::fmt is much better
[01:18:25] <eddyb> "new"?
[01:18:29] <dbaupp> cgaebel: ToStr is (mostly) deprecated
[01:18:35] <eddyb> dbaupp: did we change anything in std::fmt?
[01:18:37] <dbaupp> eddyb: much much newer than ToStr
[01:18:41] <cgaebel> dbaupp: what should I be implementing instead
[01:18:46] <eddyb> dbaupp: like, recently?
[01:18:46] <dbaupp> eddyb: it was only added a few months ago
[01:18:51] <eddyb> ohhh
[01:19:01] <dbaupp> like, last year sometime
[01:19:06] <eddyb> dbaupp: won't do much help to cgaebel
[01:19:12] <dbaupp> cgaebel: std::fmt::Default gives you `format!("{}", 1)`
[01:19:16] <dbaupp> eddyb: yeah, it will
[01:19:38] <dbaupp> writing toa MemWriter will mean allocations are amortised to be O(1) (since it's just a vector)
[01:20:03] <eddyb> dbaupp: but I have something better than a rope :P
[01:20:03] <dbaupp> cgaebel: (well, `format!("{}", some_hashmap)`)
[01:20:11] <eddyb> or rather, it's a rope on the stack
[01:20:23] <cgaebel> dbaupp: so I should implement the std::fmt::Default interface?
[01:20:25] <eddyb> can we come up with a witty name for that visual?
[01:20:45] <eddyb> cgaebel: yes, and be prepared for an overhaul in about a week or two
[01:20:53] <cgaebel> fun. alright.
[01:21:33] <eddyb> dbaupp: once I remove rt::Piece I hope I can get LLVM to optimize sooner than two -O3 with --passes inline and a LTO in the middle
[01:21:42] <dbaupp> cgaebel: yeah
[01:21:53] <eddyb> (that's what's been blocking me, mostly)
[01:22:15] <dbaupp> eddyb: will the interface be hard to implement?
[01:22:18] <eddyb> though we should probably also fix the issue where it doesn't finish optimizing after devirtualizing
[01:22:26] <eddyb> dbaupp: depends what you're doing
[01:22:36] *** Quits: gwty (gwtypc@BEB2E7A8.D37BBF03.CF29F6CE.IP) (Ping timeout)
[01:22:45] <eddyb> if you just have a &str, it's hardly much different than today
[01:23:12] <eddyb> dbaupp: you'll be able to defer to an interpolated format, though
[01:24:35] <eddyb> dbaupp: something like match *self { Some(ref x) => format_to!(fmt, then, "Some({})", x), None => fmt.append("None", then) }
[01:24:57] <dbaupp> "yay" manual CPS :/
[01:24:58] <eddyb> dbaupp: it can be derived without losing performance, and feel free to suggest options to neaten it up
[01:26:26] *** Joins: ghrust (ghrust@DE823A67.6A2AE50.F3114085.IP)
[01:26:27] <ghrust> 01[13rust01] 15bors 04force-pushed 06auto from 14c944a09 to 14a72ab2d: 02http://git.io/N3iJvQ
[01:26:27] *** Parts: ghrust (ghrust@DE823A67.6A2AE50.F3114085.IP) ()
[01:26:36] <eddyb> I might add something for iterators so you can easily implement lists and whatnot. but not a complete pretty-printer :/
[01:27:18] <eddyb> dbaupp: wait, maybe I'm dumb
[01:28:25] <eddyb> dbaupp: I might be able to have a FormatterPlusContinuationButWithAShorterName which makes it harder to do the wrong thing, by ensuring you only do one operation
[01:28:38] <eddyb> dbaupp: would work perfectly for a format_to macro
[01:30:10] <eddyb> and a WriterFormatter can probably ditch the continuations altogether
[01:31:19] *** Quits: TheHydroImpulse (TheHydroIm@moz-A9FB1B83.ed.shawcable.net) (Connection reset by peer)
[01:31:58] <eddyb> dbaupp: I wonder if it would blow the stack for very large vectors
[01:32:21] <eddyb> especially if it formats numbers on the stack
[01:32:46] <eddyb> but nobody would do that, right?
[01:33:05] <dbaupp> a new closure for each element of the vector??
[01:33:22] *** Joins: TheHydroImpulse (TheHydroIm@moz-A9FB1B83.ed.shawcable.net)
[01:33:22] <dbaupp> that sounds... like a rather bad idea.
[01:33:33] *** Joins: zimbabao (rajaram@6E0FBB2F.DA20CA3D.D2D1FAF0.IP)
[01:34:10] <cgaebel> what's the difference between &Self and &self?
[01:34:28] <cgaebel> i.e. /home/clark/development/rust/rust/src/libstd/hashmap_ng.rs:582:5: 608:6 error: method `fmt` has a `&self` declaration in the impl, but not in the trait
[01:34:31] <strcat> Self refers to the type the trait is being implemented on in a trait definition
[01:34:36] <eddyb> cgaebel: Self is the type implementing the trait
[01:34:37] <strcat> elsewhere it's no valid
[01:34:40] <strcat> not*
[01:34:57] <eddyb> cgaebel: they're using &Self because of nasty unsafe bare fn transmutes
[01:35:08] <eddyb> I've heard they're changing that, I wonder with what
[01:35:10] <dbaupp> (it's about to change to `&self`
[01:35:11] <dbaupp> )
[01:35:18] <cgaebel> ok
[01:35:22] <eddyb> dbaupp: so what are the functions replaced with?
[01:35:35] <eddyb> dbaupp: or are the transmutes considered safe because of my self removal?
[01:35:38] <eddyb> s/self/env/
[01:35:53] *** Joins: summerlight (summerligh@327FC32B.2C956A45.501EFF44.IP)
[01:36:51] <dbaupp> eddyb: https://github.com/mozilla/rust/pull/11948
[01:36:59] <dbaupp> silly wrapper functions until we get UFCS
[01:37:25] <eddyb> oh, I used structs and traits in my version
[01:37:42] <eddyb> you know, a trait object instead of fn and &'static Void
[01:38:26] <eddyb> (but I hope to rip that all out, and just iterate in the expansion)
[01:41:36] <eddyb> dbaupp: silly thing: substitutions don't happen if the substitution is a noop, even if the type still has type params
[01:42:58] <cgaebel> so now I'm getting these errors http://pastebin.com/ggecV0dT . any ideas?
[01:43:37] <dbaupp> cgaebel: fmt isn't a method
[01:43:51] <cgaebel> dbaupp: oh? what should I be doing instead?
[01:44:08] <dbaupp> write!(fmt.buf, "({}, {})", self.keys[idx], self.vals[idx])
[01:44:19] <eddyb> eww
[01:44:28] <dbaupp> or call Default::fmt(&self.keys[idx], f)
[01:44:37] <eddyb> (but it's probably the simplest way to do it currently)
[01:44:40] <dbaupp> eddyb: and calling continuations will be *so* much nicer /s
[01:44:56] <cgaebel> dbaupp: ok I'll use write. thanks!
[01:45:01] <eddyb> dbaupp: format_to!(fmt, "({}, {})", self.keys[idx], self.vals[idx])
[01:45:16] <eddyb> dbaupp: instead of exposing the inner workings
[01:45:19] <dbaupp> eddyb: that looks pretty similar :P
[01:45:45] <eddyb> dbaupp: what I hate is "write" and ".buf"
[01:46:39] <dbaupp> meh
[01:46:50] * dbaupp thinks they're not so bad
[01:48:53] <cgaebel> dbaupp: ok I'll use write. thanks!
[01:48:57] <cgaebel> oops wrong window
[01:49:04] <cgaebel> (up-enter)
[01:49:22] <dbaupp> cgaebel: np :)
[01:49:24] <dbaupp> cgaebel: np :)
[01:49:40] <cgaebel> where's format_to!?
[01:49:55] <dbaupp> cgaebel: part of eddyb's proposed changes
[01:50:05] <cgaebel> oh.
[01:50:24] <eddyb> when you see me talking, put on your skeptic glasses
[01:50:33] <eddyb> (just so you can be in line with everyone else)
[01:50:35] <cgaebel> eddyb: lol
[01:57:45] <olsonjeffery> hey, im still banging my head against the wall trying to move extra::serialize et al into its own module, here's my current situation: https://gist.github.com/olsonjeffery/8761927
[01:58:24] <olsonjeffery> trying to re-export libserialize stuff to make it through stage0 libsyntax which chokes.. but going down the rabbithole of doing the re-export has me stuck in stage0 libextra
[01:58:47] <dbaupp> olsonjeffery: it would have to be `pub use self::...`
[01:58:50] <olsonjeffery> thinking most of the trouble is related to shadowing issues in resolve because serialize is ambiguous between libserialize or extra::serialize ?
[01:58:56] <dbaupp> or pub use serialize::serialize::{ ... }
[01:59:18] <dbaupp> beacuse extern mod serialize just introduces it in that submodule, and use is from the root of the crate
[01:59:19] <olsonjeffery> where? in libserialize or in libextra?
[01:59:35] <dbaupp> in the stage0 one
[01:59:47] <dbaupp> where you're exporting things to satisfy deriving
[02:00:08] <olsonjeffery> yeah
[02:00:28] <dbaupp> (one which has the self now doesn't actually need it, since serialize is at the root of the crate there.)
[02:01:23] <olsonjeffery> yeah
[02:01:36] <dbaupp> olsonjeffery: (also, it's better to use #[cfg(not(stage0))] rather than the explicit list, so that people can still run `rustc` directly on the file, without having to pass --cfg stage2 or whatever)
[02:01:47] <olsonjeffery> extern mod serialize = "serialize";
[02:01:49] <olsonjeffery> #[cfg(stage0)]
[02:01:51] <olsonjeffery> pub use self::serialize;
[02:01:59] <olsonjeffery> /Users/jeff/src/rust/src/libextra/lib.rs:40:9: 40:24 error: unresolved import
[02:02:01] <olsonjeffery> /Users/jeff/src/rust/src/libextra/lib.rs:40 pub use self::serialize;
[02:02:15] <dbaupp> yeah, I don't think that will work, because they have the same name
[02:02:35] <dbaupp> if you do the pub mod serialize thing you're currently doing
[02:02:56] <cmr> can you just leave in extra::serialize until a snapshot?
[02:03:11] <dbaupp> and just use `pub use self::serialize::{Encoder, ...};` etc. rather than `pub use serialize::{Encoder, ...}` I think it should work
[02:03:52] <dbaupp> you could also do `#[cfg(not(stage0))] extern mod serialize; #[cfg(stage0)] extern mod serialize0 = "serialize"; pub use serialize = serialize0;` I think
[02:04:01] <olsonjeffery> ah. within the extra::serialize stub
[02:04:03] <dbaupp> er, #[cfg(stage0)] on the pub use
[02:04:09] <dbaupp> olsonjeffery: yeah
[02:04:09] <olsonjeffery> cmr: i really don't want to duplicate codebase
[02:05:05] *** Joins: notmatt (notmatt@moz-9FB2565E.vc.shawcable.net)
[02:05:13] <olsonjeffery> dbaupp: i tried a variation on that (serialize0)
[02:05:26] <olsonjeffery> the error was pretty aggrevating
[02:05:39] *** Joins: lpy (lpy@B744D17C.B31F127E.E99F7FDB.IP)
[02:06:04] <dbaupp> haha, ok :)
[02:06:20] * dbaupp has (fortunately) never had to deal with such arcane reexports
[02:06:24] <dbaupp> the joys of bootstraps
[02:07:41] *** Quits: lpy (lpy@B744D17C.B31F127E.E99F7FDB.IP) (Ping timeout)
[02:08:22] <eddyb> dbaupp: do you know any issues about missing type param substitutions?
[02:09:49] <eddyb> if I remember the exact error I'll search on github for it
[02:10:54] *** Quits: TheHydroImpulse (TheHydroIm@moz-A9FB1B83.ed.shawcable.net) (Quit: TheHydroImpulse)
[02:10:59] <dbaupp> eddyb: for default type params?
[02:11:12] <eddyb> dbaupp: no, the age-old ones
[02:11:24] <eddyb> dbaupp: https://github.com/mozilla/rust/search?q=len+is+but+index+is&ref=cmdform&state=open&type=Issues
[02:11:27] <dbaupp> run an example through rusti
[02:12:11] *** Quits: doomlord_ (servitor@moz-841308DB.range86-160.btcentralplus.com) (Ping timeout)
[02:12:33] <eddyb> rusti: struct A<T> {a: T} fn f<T>(v: A<T>) {let ~A{a: ref a} = v;} 5
[02:12:37] -rusti- pastebinned 7 lines of output: http://ix.io/agu
[02:12:48] *** Joins: jensnockert (jensnocker@moz-7DC16A5F.afb.bredband2.com)
[02:13:04] <eddyb> dbaupp: I probably just fixed that :P
[02:13:13] <dbaupp> awesome!
[02:13:28] <eddyb> I output an error and return ty_err()
[02:13:36] <eddyb> I mean, ty::mk_err()
[02:13:44] *** Joins: doomlord_ (servitor@moz-858B6E73.range86-148.btcentralplus.com)
[02:14:44] *** Quits: jensnockert (jensnocker@moz-7DC16A5F.afb.bredband2.com) (Ping timeout)
[02:15:57] <eddyb> dbaupp: there's like 50 closed issues that probably have similar errors
[02:17:05] <dbaupp> eddyb: well they're closed, so either dupes or fixed
[02:17:16] <dbaupp> but yeah, people clearly keep hitting it
[02:17:23] <dbaupp> so fixing it would be very cool
[02:17:27] <olsonjeffery> oh thank you dear lord. it finally built.
[02:18:17] <eddyb> error: missing type param `U` in the substitution of `std::option::Option<U>`
[02:18:27] <eddyb> dbaupp: my previous built errored in trans with this same code
[02:18:38] <eddyb> *build
[02:18:44] <dbaupp> olsonjeffery: \o/
[02:19:11] <eddyb> it looks like a proper error now :)
[02:19:17] <dbaupp> eddyb: cool
[02:19:28] <eddyb> albeit slightly confusing, but I can't do much about it without rewriting parts of resolve
[02:19:50] <dbaupp> :(
[02:20:22] <dbaupp> can you rephrase the error message slightly to make it clearer? (I would offer suggestions, but I've never understood that bug very well.)
[02:20:46] <eddyb> dbaupp: it's confusing because there's not enough information to know the precise source
[02:21:18] <dbaupp> might as well rewrite resolve then :P
[02:22:53] <eddyb> dbaupp: https://github.com/mozilla/rust/issues/8998#issuecomment-33889993
[02:24:48] <olsonjeffery> do you have to re-run configure if you touch crates.mk ?
[02:25:08] <eddyb> possibly
[02:25:20] <eddyb> wait, no, that's if you add a new .mk file
[02:29:14] *** Quits: zimbabao (rajaram@6E0FBB2F.DA20CA3D.D2D1FAF0.IP) (Ping timeout)
[02:32:20] <eddyb> dbaupp: r? https://github.com/mozilla/rust/pull/11982
[02:32:27] <eddyb> I am testing right now
[02:32:58] <dbaupp> eddyb: I can review, but I don't know enough to r+
[02:33:16] <eddyb> who's also around at this time?
[02:33:19] <eddyb> cmr, strcat?
[02:33:22] <cmr> sup
[02:33:33] * cmr looks
[02:33:44] *** Quits: notmatt (notmatt@moz-9FB2565E.vc.shawcable.net) (Client exited)
[02:33:45] <dbaupp> eddyb: why not just add an arg to subst rather than adding a new function?
[02:33:56] <eddyb> dbaupp: because of so many uses
[02:34:03] <dbaupp> ok
[02:34:12] *** Joins: notmatt (notmatt@moz-9FB2565E.vc.shawcable.net)
[02:35:08] * olsonjeffery made it to stage1, throws confetti into the air
[02:35:12] <cmr> eddyb: needs a negative test.
[02:35:22] * cmr gathers all of olsonjeffery's confetti for cataloging
[02:35:33] <cmr> eddyb: ie, a test for the error case.
[02:35:52] <eddyb> cmr: to show that it doesn't ICE?
[02:35:56] <cmr> eddyb: yes.
[02:35:57] *** Quits: notmatt (notmatt@moz-9FB2565E.vc.shawcable.net) (Ping timeout)
[02:36:25] <dbaupp> eddyb: adding new .span_err's means adding test cases that hit those calls
[02:36:58] <eddyb> right. the only controlled cases are default type params right now
[02:40:08] <cmr> it looks fine to me but I don't know the code well enough for an r+
[02:41:31] *** Joins: ghrust (ghrust@9C8B94D4.6A2AE50.F3114085.IP)
[02:41:31] <ghrust> 01[13rust01] 15bors merged 06auto into 06master: 02http://git.io/VwisGg
[02:41:31] *** Parts: ghrust (ghrust@9C8B94D4.6A2AE50.F3114085.IP) ()
[02:41:46] <olsonjeffery> cmr: so has cargo-lite seen much refinement since you announced it? gotten PRs?
[02:41:47] <eddyb> the only test name I can come up with is "generic-type-params-forward-mention"
[02:41:54] <olsonjeffery> or do you think its pretty much good enough, for now?
[02:41:57] <cmr> olsonjeffery: I've continued to work on it, haven't gotten any major PRs
[02:42:15] <cmr> the last thing left, updating + rebuilding, is currently sitting in my working dir
[02:42:20] <cmr> It'll be "finished" tonight.
[02:42:33] <olsonjeffery> are deps w/i a single workspace/repo supported?
[02:42:42] <cmr> example?
[02:42:45] <olsonjeffery> curious if ill need to split up my codebase by crate, or what
[02:42:49] <olsonjeffery> olsonjeffery/p2d
[02:43:00] <olsonjeffery> there're two crates in there, p2d and p2dux.. with the latter depending on the former
[02:43:05] <olsonjeffery> and downstream bins would depend on both
[02:43:13] <cmr> they're in separate dirs so it's fine.
[02:43:30] <cmr> so how it works is that the "deps" are just listed as the command line arguments that'd you give to cargo-lite install...
[02:43:39] * olsonjeffery nods
[02:43:40] <cmr> which works for local paths as well as git + hg remote paths.
[02:45:09] *** Joins: brson (brson@moz-BBE3ABD.mv.mozilla.com)
[02:45:09] *** ChanServ sets mode: +qo brson brson
[02:46:27] *** Joins: ghrust (ghrust@F6EE6DE3.6A2AE50.F3114085.IP)
[02:46:28] <ghrust> 01[13rust01] 15bors pushed 3 new commits to 06auto: 02http://git.io/s6j_Fg
[02:46:28] <ghrust> 13rust/06auto 14003ce50 15Huon Wilson: std: rename fmt::Default to `Show`....
[02:46:28] <ghrust> 13rust/06auto 14104f60e 15Huon Wilson: std::fmt: prepare to convert the formatting traits to methods, and work...
[02:46:29] <ghrust> 13rust/06auto 149723163 15bors: auto merge of #11948 : huonw/rust/show, r=alexcrichton...
[02:46:31] *** Parts: ghrust (ghrust@F6EE6DE3.6A2AE50.F3114085.IP) ()
[02:48:04] <eddyb> cmr: added negative test
[02:50:33] <eddyb> cmr: I hope everything is in order, *please* get me a snapshot and r+ before I wake up. it's 5am. why am I so slow? good night
[02:51:30] *** Joins: ghrust (ghrust@DE823A67.6A2AE50.F3114085.IP)
[02:51:31] <ghrust> 01[13rust01] 15cmr merged 06master into 06snap-stage3: 02http://git.io/qWHiYw
[02:51:31] *** Parts: ghrust (ghrust@DE823A67.6A2AE50.F3114085.IP) ()
[02:51:42] <olsonjeffery> cmr: i only saw examples for git repos are deps
[02:51:47] <cmr> olsonjeffery: --local
[02:51:53] <olsonjeffery> so i guess id want to see the complete, multi-config layout
[02:51:57] <cmr> sure
[02:52:12] <cmr> I can write your cargo-lite.conf for you once I'm done making irsy run again
[02:53:01] <eddyb> cmr: a snapshot *including* the fix :P
[02:53:07] <cmr> eddyb: pft
[02:53:21] <cmr> (I mostly care if  a snapshot is possible at all right now)
[02:53:27] <eddyb> sure :)
[02:53:36] <eddyb> since I'll probably need HashMap<K, V, Hasher = DefaultHash<K>>
[03:03:09] <eddyb> strcat: feel free to comment on https://github.com/mozilla/rust/pull/11982 since neither dbaupp and cmr feel comfortable with giving me a r+
[03:03:34] *** Joins: TheHydroImpulse (TheHydroIm@moz-A9FB1B83.ed.shawcable.net)
[03:03:43] *** Quits: cgaebel (clark@ADA4DDE2.290DF317.EE6E63A5.IP) (Ping timeout)
[03:06:23] *** Joins: lpy (lpy@B744D17C.B31F127E.E99F7FDB.IP)
[03:08:32] *** Quits: lpy (lpy@B744D17C.B31F127E.E99F7FDB.IP) (Ping timeout)
[03:09:45] *** nrc is now known as nrc|afk
[03:16:26] *** Joins: ghrust (ghrust@24260B07.6A2AE50.F3114085.IP)
[03:16:27] <ghrust> 01[13rust01] 15bors 04force-pushed 06auto from 149723163 to 143e39e3e: 02http://git.io/N3iJvQ
[03:16:27] *** Parts: ghrust (ghrust@24260B07.6A2AE50.F3114085.IP) ()
[03:16:27] *** Joins: ghrust (ghrust@9C8B94D4.6A2AE50.F3114085.IP)
[03:16:27] <ghrust> 01[13rust01] 15bors pushed 2 new commits to 06auto: 02http://git.io/4OgEXA
[03:16:27] <ghrust> 13rust/06auto 14e704561 15Jason Fager: un-xfail test for #8498 and replace prints w/ asserts
[03:16:27] <ghrust> 13rust/06auto 1416f1a72 15bors: auto merge of #11975 : jfager/rust/r8498, r=alexcrichton...
[03:16:27] *** Parts: ghrust (ghrust@9C8B94D4.6A2AE50.F3114085.IP) ()
[03:17:15] *** Quits: erickt (Adium@49C4075F.3AC15C18.2321E71E.IP) (Quit: Leaving.)
[03:17:26] *** Quits: robert3005 (robert3005@moz-DA3F8722.skybroadband.com) (Client exited)
[03:17:36] *** Quits: eddyb (eddy@832D2DE5.66315F97.FB866788.IP) (Ping timeout)
[03:17:56] *** Quits: JesseH (Jesse@moz-BD21A528.mc.at.cox.net) (Ping timeout)
[03:18:37] <dbaupp> gaaah, accidentally inserting a space in an error string so it still compiles but fails on one test :'(
[03:18:38] *** Quits: TheHydroImpulse (TheHydroIm@moz-A9FB1B83.ed.shawcable.net) (Connection reset by peer)
[03:20:38] *** Joins: TheHydroImpulse (TheHydroIm@moz-A9FB1B83.ed.shawcable.net)
[03:23:27] *** Quits: TheHydroImpulse (TheHydroIm@moz-A9FB1B83.ed.shawcable.net) (Quit: TheHydroImpulse)
[03:24:48] *** Joins: TheHydroImpulse (TheHydroIm@moz-A9FB1B83.ed.shawcable.net)
[03:25:01] *** Quits: zz_kimundi (kimundi@moz-CC8364D0.dip0.t-ipconnect.de) (Ping timeout)
[03:25:05] *** Joins: zimbabao (rajaram@6E0FBB2F.DA20CA3D.D2D1FAF0.IP)
[03:26:41] *** Quits: new_one (new_one@338D8DF9.4C461BEC.59A381B9.IP) (Ping timeout)
[03:28:54] *** Joins: zz_kimundi (kimundi@moz-19888B08.dip0.t-ipconnect.de)
[03:28:56] *** zz_kimundi is now known as kimundi
[03:30:15] *** Joins: cgaebel (clark@moz-92F543E4.nycmny.east.verizon.net)
[03:30:39] *** Quits: summerlight (summerligh@327FC32B.2C956A45.501EFF44.IP) (Ping timeout)
[03:34:48] *** Quits: ssira (ssira@moz-DC71C200.kanagawa.ocn.ne.jp) (Client exited)
[03:35:09] *** Joins: ssira (ssira@moz-DC71C200.kanagawa.ocn.ne.jp)
[03:36:56] *** Quits: ssira (ssira@moz-DC71C200.kanagawa.ocn.ne.jp) (Ping timeout)
[03:40:29] *** Quits: TheHydroImpulse (TheHydroIm@moz-A9FB1B83.ed.shawcable.net) (Quit: TheHydroImpulse)
[03:47:02] *** Quits: japaric (japaric@BA37D376.D2FA42B.95AFB88D.IP) (Ping timeout)
[03:48:56] *** Joins: TheHydroImpulse (TheHydroIm@moz-A9FB1B83.ed.shawcable.net)
[03:50:39] *** Joins: new_one (new_one@990A9309.E8040809.B3C0173E.IP)
[03:50:45] *** Joins: ssira (ssira@moz-DC71C200.kanagawa.ocn.ne.jp)
[03:53:24] *** Joins: dherman (dherman@moz-6CA476B1.hsd1.ca.comcast.net)
[03:53:25] *** ChanServ sets mode: +ao dherman dherman
[03:57:42] *** Joins: japaric (japaric@56FF3E09.8FD1E798.5C7588CA.IP)
[04:01:51] *** Quits: zimbabao (rajaram@6E0FBB2F.DA20CA3D.D2D1FAF0.IP) (Ping timeout)
[04:03:55] *** Joins: pcwalton (pcwalton@moz-DA87EE4.hsd1.ca.comcast.net)
[04:03:55] *** ChanServ sets mode: +ao pcwalton pcwalton
[04:07:07] *** Quits: new_one (new_one@990A9309.E8040809.B3C0173E.IP) (Client exited)
[04:07:08] *** Joins: lpy (lpy@B744D17C.B31F127E.E99F7FDB.IP)
[04:09:23] *** Quits: lpy (lpy@B744D17C.B31F127E.E99F7FDB.IP) (Ping timeout)
[04:11:02] <brson> i love it when you move something in std and it explodes in resolve errors
[04:11:40] <cmr> brson: yup
[04:13:44] *** Joins: jensnockert (jensnocker@moz-988C9930.e0f8471ae7fa.afb.bredband2.com)
[04:13:56] *** Quits: pcwalton (pcwalton@moz-DA87EE4.hsd1.ca.comcast.net) (Quit: pcwalton)
[04:15:37] *** Quits: jensnockert (jensnocker@moz-988C9930.e0f8471ae7fa.afb.bredband2.com) (Ping timeout)
[04:17:10] *** Joins: zimbabao (rajaram@7C5A6537.A7AC81F6.D2D1FAF0.IP)
[04:20:21] *** Quits: zimbabao (rajaram@7C5A6537.A7AC81F6.D2D1FAF0.IP) (Ping timeout)
[04:27:51] *** Quits: ssira (ssira@moz-DC71C200.kanagawa.ocn.ne.jp) (Client exited)
[04:28:12] *** Joins: ssira (ssira@moz-DC71C200.kanagawa.ocn.ne.jp)
[04:29:58] *** Quits: ssira (ssira@moz-DC71C200.kanagawa.ocn.ne.jp) (Ping timeout)
[04:36:56] *** Joins: lpy (lpy@B744D17C.B31F127E.E99F7FDB.IP)
[04:43:54] <olsonjeffery> r? https://github.com/mozilla/rust/pull/11984
[04:44:50] <dbaupp> olsonjeffery: I guess you could inline extra::serialize into extra/lib.rs, which may make the diff nicer
[04:45:29] <dbaupp> (i.e. `#[cfg(stage0)] pub mod serialize { extern mod serialize; pub use self::serialize::{...}; }`)
[04:46:28] *** Joins: ghrust (ghrust@1E8607E8.6A2AE50.F3114085.IP)
[04:46:28] <ghrust> 01[13rust01] 15bors merged 06auto into 06master: 02http://git.io/4OgEXA
[04:46:28] *** Parts: ghrust (ghrust@1E8607E8.6A2AE50.F3114085.IP) ()
[04:48:12] <olsonjeffery> dbaupp: dont
[04:48:14] <olsonjeffery> done
[04:48:52] <dbaupp> ah, that's much nicer! :)
[04:49:25] <dbaupp> github's considering serialize.rs moved, rather than deleted and re-added now.
[04:49:51] <olsonjeffery> yeah, i saw that
[04:49:54] <olsonjeffery> pretty crafty
[04:50:35] <olsonjeffery> i wonder if we'll get a libcontainer crate, with all of the data structures from std/extra
[04:50:44] <olsonjeffery> although i wonder if there're things in std that depend on hashmap
[04:50:50] <olsonjeffery> i assume that's why it moved, in the first place
[04:51:32] *** Joins: ghrust (ghrust@C8693FCB.6A2AE50.F3114085.IP)
[04:51:33] <ghrust> 01[13rust01] 15bors pushed 3 new commits to 06auto: 02http://git.io/CnX0bg
[04:51:33] <ghrust> 13rust/06auto 14003ce50 15Huon Wilson: std: rename fmt::Default to `Show`....
[04:51:33] <ghrust> 13rust/06auto 14d8b6919 15Huon Wilson: std::fmt: prepare to convert the formatting traits to methods, and work...
[04:51:33] <ghrust> 13rust/06auto 146ad0194 15bors: auto merge of #11948 : huonw/rust/show, r=alexcrichton...
[04:51:35] *** Parts: ghrust (ghrust@C8693FCB.6A2AE50.F3114085.IP) ()
[04:51:37] <olsonjeffery> mostly thinking in the context of this change, because of TreeMap moved out of extra, then json could move to libserialize
[04:51:44] <olsonjeffery> if*
[04:53:10] <dbaupp> yeah, I imagine some sort of change may be good there. Although the change could just be moving TreeMap to std (or, putting a btree in std and removing TreeMap).
[04:54:15] *** Quits: japaric (japaric@56FF3E09.8FD1E798.5C7588CA.IP) (Ping timeout)
[04:55:49] *** Joins: japaric1 (japaric@DDF50A2B.40EC661E.5C7588CA.IP)
[05:00:38] <olsonjeffery> dbaupp: updated
[05:02:04] *** Quits: SiegeLord (sl@moz-CAF07B4C.hsd1.ma.comcast.net) (Quit: It's a joke, it's all a joke.)
[05:07:58] *** Joins: gwty (gwtypc@2D0C08FA.3AF9C23B.45DA6411.IP)
[05:11:54] *** Quits: strcat (strcat@moz-54F7FD49.cpe.net.cable.rogers.com) (Quit: sleep)
[05:21:27] *** Joins: ghrust (ghrust@C8693FCB.6A2AE50.F3114085.IP)
[05:21:27] <ghrust> 01[13rust01] 15bors pushed 2 new commits to 06auto: 02http://git.io/3P6Kng
[05:21:27] <ghrust> 13rust/06auto 146b1c7bd 15Eduard Burtescu: Substitute type params in default type params using them.
[05:21:27] <ghrust> 13rust/06auto 147c009ad 15bors: auto merge of #11982 : eddyb/rust/generic-default-type-params, r=pcwalton...
[05:21:27] *** Parts: ghrust (ghrust@C8693FCB.6A2AE50.F3114085.IP) ()
[05:21:29] *** Joins: ghrust (ghrust@1E8607E8.6A2AE50.F3114085.IP)
[05:21:29] <ghrust> 01[13rust01] 15bors 04force-pushed 06auto from 146ad0194 to 1416f1a72: 02http://git.io/N3iJvQ
[05:21:29] *** Parts: ghrust (ghrust@1E8607E8.6A2AE50.F3114085.IP) ()
[05:29:48] *** Quits: canhtak (canhtak@moz-9E539298.wl.t.ulaval.ca) (Quit: canhtak)
[05:30:07] *** Joins: canhtak (canhtak@moz-9E539298.wl.t.ulaval.ca)
[05:35:10] *** Joins: Jesse (jruderman@moz-9754CB0.hsd1.ca.comcast.net)
[05:51:30] *** Quits: dherman (dherman@moz-6CA476B1.hsd1.ca.comcast.net) (Quit: dherman)
[05:59:23] *** Joins: strcat (strcat@moz-54F7FD49.cpe.net.cable.rogers.com)
[06:00:55] *** Quits: TheHydroImpulse (TheHydroIm@moz-A9FB1B83.ed.shawcable.net) (Connection reset by peer)
[06:02:38] *** Joins: TheHydroImpulse (TheHydroIm@moz-A9FB1B83.ed.shawcable.net)
[06:14:40] *** Joins: jensnockert (jensnocker@moz-7DC16A5F.afb.bredband2.com)
[06:14:58] *** Joins: summerlight (summerligh@327FC32B.2C956A45.501EFF44.IP)
[06:16:35] *** Quits: jensnockert (jensnocker@moz-7DC16A5F.afb.bredband2.com) (Ping timeout)
[06:29:47] *** Joins: erickt (Adium@49C4075F.3AC15C18.2321E71E.IP)
[06:31:26] *** Joins: ghrust (ghrust@79968228.6A2AE50.F3114085.IP)
[06:31:26] <ghrust> 01[13rust01] 15bors 04force-pushed 06auto from 147c009ad to 1416f1a72: 02http://git.io/N3iJvQ
[06:31:26] *** Parts: ghrust (ghrust@79968228.6A2AE50.F3114085.IP) ()
[06:31:26] *** Joins: ghrust (ghrust@79968228.6A2AE50.F3114085.IP)
[06:31:26] <ghrust> 01[13rust01] 15bors pushed 4 new commits to 06auto: 02http://git.io/vZpdOQ
[06:31:26] <ghrust> 13rust/06auto 14003ce50 15Huon Wilson: std: rename fmt::Default to `Show`....
[06:31:26] <ghrust> 13rust/06auto 14d8b6919 15Huon Wilson: std::fmt: prepare to convert the formatting traits to methods, and work...
[06:31:26] <ghrust> 13rust/06auto 14c19a7b6 15Huon Wilson: Remove the SNAP line to work around #11985.
[06:31:28] *** Parts: ghrust (ghrust@79968228.6A2AE50.F3114085.IP) ()
[06:39:04] *** Quits: strcat (strcat@moz-54F7FD49.cpe.net.cable.rogers.com) (Quit: WeeChat 0.4.2)
[06:39:09] *** Quits: gwty (gwtypc@2D0C08FA.3AF9C23B.45DA6411.IP) (Ping timeout)
[06:39:58] *** Quits: summerlight (summerligh@327FC32B.2C956A45.501EFF44.IP) (Ping timeout)
[06:50:54] *** Joins: gwty (gwtypc@FB838CD7.DCF3E831.27560D6E.IP)
[06:52:58] *** Quits: cgaebel (clark@moz-92F543E4.nycmny.east.verizon.net) (Ping timeout)
[06:52:58] *** Quits: gwty (gwtypc@FB838CD7.DCF3E831.27560D6E.IP) (Ping timeout)
[06:54:46] *** Quits: erickt (Adium@49C4075F.3AC15C18.2321E71E.IP) (Quit: Leaving.)
[06:55:39] *** Joins: cgaebel (clark@ADA4DDE2.290DF317.EE6E63A5.IP)
[07:16:06] *** Joins: notmatt (notmatt@moz-9FB2565E.vc.shawcable.net)
[07:25:30] *** Quits: bjz (bjz@B398BE78.F804C29E.D35A31DF.IP) (Ping timeout)
[07:25:34] *** Joins: gwty (gwtypc@2D0C08FA.3AF9C23B.45DA6411.IP)
[07:25:53] *** Joins: bjz (bjz@B398BE78.F804C29E.D35A31DF.IP)
[07:28:06] *** Quits: nate (pinkeh@moz-B8462C56.members.linode.com) (Quit: ...)
[07:28:36] *** Joins: nate (cs61-nherm@moz-A3C418FF.hcs.harvard.edu)
[07:30:09] *** Quits: bjz (bjz@B398BE78.F804C29E.D35A31DF.IP) (Ping timeout)
[07:31:10] *** Quits: nate (cs61-nherm@moz-A3C418FF.hcs.harvard.edu) (Quit: leaving)
[07:31:22] *** Joins: bjz (bjz@B398BE78.F804C29E.D35A31DF.IP)
[07:36:40] *** Joins: nate (pinkeh@moz-A3C418FF.hcs.harvard.edu)
[07:41:34] *** Joins: ghrust (ghrust@9C8B94D4.6A2AE50.F3114085.IP)
[07:41:34] <ghrust> 01[13rust01] 15bors merged 06auto into 06master: 02http://git.io/vZpdOQ
[07:41:34] *** Parts: ghrust (ghrust@9C8B94D4.6A2AE50.F3114085.IP) ()
[07:46:25] *** Joins: ghrust (ghrust@2EE61FCC.6A2AE50.F3114085.IP)
[07:46:25] <ghrust> 01[13rust01] 15bors pushed 0 new commits to 06auto: 02http://git.io/p-UEXA
[07:46:25] *** Parts: ghrust (ghrust@2EE61FCC.6A2AE50.F3114085.IP) ()
[07:49:38] <cmr> I'm going to remove rustpkg
[07:50:27] *** Joins: dbussink (dbussink@moz-E0A5568C.bussink.me)
[07:52:33] <brson> ok
[07:53:32] *** Quits: gwty (gwtypc@2D0C08FA.3AF9C23B.45DA6411.IP) (Ping timeout)
[07:53:36] *** Quits: notmatt (notmatt@moz-9FB2565E.vc.shawcable.net) (Client exited)
[07:54:01] <acrichto> I was so happy that the queue size was going to be near 30 last night
[07:54:02] *** Joins: notmatt (notmatt@moz-9FB2565E.vc.shawcable.net)
[07:54:05] <acrichto> now it's 38 :(
[07:55:44] *** Quits: notmatt (notmatt@moz-9FB2565E.vc.shawcable.net) (Ping timeout)
[07:56:53] *** Joins: ghrust (ghrust@24260B07.6A2AE50.F3114085.IP)
[07:56:53] <ghrust> 01[13rust01] 15alexcrichton 04force-pushed 06try from 145142467 to 14f174586: 02http://git.io/k471pw
[07:56:53] <ghrust> 13rust/06try 147ee5321 15Alex Crichton: Shuffle around ownership in concurrent queues...
[07:56:53] <ghrust> 13rust/06try 14ea521f4 15Alex Crichton: Rewrite channels yet again for upgradeability...
[07:56:53] <ghrust> 13rust/06try 14249bae5 15Alex Crichton: Re-implement select() for channels...
[07:56:54] *** Parts: ghrust (ghrust@24260B07.6A2AE50.F3114085.IP) ()
[07:58:16] <acrichto> cmr: you will unblock the snapshot, turns out my fixes didn't actually fix the snapshot
[07:58:26] <cmr> acrichto: yeah that's why I'm doing it.
[07:58:32] <acrichto> cmr: for bonus points, you could write "Closes #XXXX" for all open rustpkg issues
[07:58:49] <acrichto> not sure if we want to start from a clean state on the issue tracker
[07:58:52] <acrichto> but seems reasonable to me
[08:03:00] <cmr> there are 67 issues and I don't feel like doing that.
[08:03:08] <acrichto> no worries
[08:03:32] <acrichto> what was that about badges recently? "closed 50 issues with one PR"
[08:03:42] <cmr> hm
[08:03:49] <cmr> if I get a badge for it I might..
[08:03:52] <acrichto> :P
[08:04:01] <acrichto> (I don't know what badges are)
[08:04:14] <cmr> brson: badges to promote slavery
[08:04:50] <cmr> not quite the basis of an open future its inventors imagined, I bet.
[08:05:17] <acrichto> its the future bors is working towards though
[08:05:48] <cmr> hah
[08:06:04] <cmr> that'd be amusing
[08:06:12] <cmr> if bors got badges, that is.
[08:06:14] <acrichto> we're just workers feeding bors
[08:06:17] <acrichto> hahaha
[08:06:24] <acrichto> I got the badge "be bors"!
[08:06:27] <cmr> I mean, he *does* close the most PRs...
[08:07:17] <cmr> I just realized that Linus is bors for Linux
[08:07:26] <acrichto> lol
[08:12:17] <cmr> r? https://github.com/mozilla/rust/pull/11987 p=1
[08:12:30] <cmr> Also I'm 100% sure that's the largest deletion:addition
[08:15:36] *** Joins: jensnockert (jensnocker@moz-988C9930.e0f8471ae7fa.afb.bredband2.com)
[08:17:28] *** Quits: jensnockert (jensnocker@moz-988C9930.e0f8471ae7fa.afb.bredband2.com) (Ping timeout)
[08:27:35] *** Quits: rustilite (rustilite@moz-54F7FD49.cpe.net.cable.rogers.com) (Ping timeout)
[08:27:43] *** Quits: rusti (rusti@moz-54F7FD49.cpe.net.cable.rogers.com) (Ping timeout)
[08:28:35] *** Joins: zimbabao (rajaram@BED96B2A.B53AC82C.D2D1FAF0.IP)
[08:29:42] *** Quits: zimbabao (rajaram@BED96B2A.B53AC82C.D2D1FAF0.IP) (Connection reset by peer)
[08:36:26] *** Joins: ghrust (ghrust@24260B07.6A2AE50.F3114085.IP)
[08:36:26] <ghrust> 01[13rust01] 15bors 04force-pushed 06auto from 1493dc99a to 14dce61c9: 02http://git.io/N3iJvQ
[08:36:26] *** Parts: ghrust (ghrust@24260B07.6A2AE50.F3114085.IP) ()
[08:36:29] *** Joins: ghrust (ghrust@2EE61FCC.6A2AE50.F3114085.IP)
[08:36:29] <ghrust> 01[13rust01] 15bors pushed 21 new commits to 06auto: 02http://git.io/7UStCw
[08:36:29] <ghrust> 13rust/06auto 1474b1c6a 15Alex Crichton: std: Remove io::io_error...
[08:36:29] <ghrust> 13rust/06auto 1489bc30c 15Alex Crichton: extra: Remove io_error usage
[08:36:29] <ghrust> 13rust/06auto 14738a2e7 15Alex Crichton: syntax: Remove io_error usage
[08:36:31] *** Parts: ghrust (ghrust@2EE61FCC.6A2AE50.F3114085.IP) ()
[08:38:03] *** Quits: TheHydroImpulse (TheHydroIm@moz-A9FB1B83.ed.shawcable.net) (Connection reset by peer)
[08:39:26] *** Joins: TheHydroImpulse (TheHydroIm@moz-A9FB1B83.ed.shawcable.net)
[08:43:19] *** Joins: rustilite (rustilite@moz-54F7FD49.cpe.net.cable.rogers.com)
[08:43:39] *** Joins: rusti (rusti@moz-54F7FD49.cpe.net.cable.rogers.com)
[08:46:14] *** Joins: zimbabao (rajaram@BED96B2A.B53AC82C.D2D1FAF0.IP)
[08:46:45] *** Quits: Jesse (jruderman@moz-9754CB0.hsd1.ca.comcast.net) (Quit: Jesse)
[08:56:06] *** Joins: jensnockert (jensnocker@moz-988C9930.e0f8471ae7fa.afb.bredband2.com)
[08:56:17] *** Joins: vadimcn_ (chatzilla@FB06B64.76F9E272.DA40C4B3.IP)
[08:56:19] *** Quits: vadimcn (chatzilla@FB06B64.76F9E272.DA40C4B3.IP) (Ping timeout)
[08:56:27] *** vadimcn_ is now known as vadimcn
[08:57:57] *** Quits: jensnockert (jensnocker@moz-988C9930.e0f8471ae7fa.afb.bredband2.com) (Ping timeout)
[09:00:46] *** flaper87|afk is now known as flaper87
[09:00:58] *** Quits: nrc|afk (nrc@7BE24E90.A5032A01.3CFC199D.IP) (Ping timeout)
[09:02:41] *** Joins: mankyKitty (Instantbir@moz-F98AF264.rev.sfr.net)
[09:09:59] *** Quits: brson (brson@moz-BBE3ABD.mv.mozilla.com) (Ping timeout)
[09:11:28] *** Joins: ghrust (ghrust@F6EE6DE3.6A2AE50.F3114085.IP)
[09:11:29] <ghrust> 01[13rust01] 15bors pushed 2 new commits to 06auto: 02http://git.io/WBiK8g
[09:11:29] <ghrust> 13rust/06auto 1425fe2ca 15Corey Richardson: Remove rustpkg....
[09:11:29] <ghrust> 13rust/06auto 148665a51 15bors: auto merge of #11987 : cmr/rust/rm-rustpkg, r=cmr...
[09:11:30] *** Parts: ghrust (ghrust@F6EE6DE3.6A2AE50.F3114085.IP) ()
[09:12:29] <flaper87> cmr: what does rs=blocking-snapshot do?
[09:15:40] <cmr> flaper87: it's an (informal) way of listing the reason for the r+
[09:16:07] <flaper87> cmr: gotcha
[09:22:59] *** Joins: eddyb (eddy@832D2DE5.66315F97.FB866788.IP)
[09:25:35] *** Quits: mankyKitty (Instantbir@moz-F98AF264.rev.sfr.net) (Ping timeout)
[09:25:43] *** Quits: canhtak (canhtak@moz-9E539298.wl.t.ulaval.ca) (Quit: canhtak)
[09:27:02] <eddyb> acrichto: random rustpkg test failure here? https://github.com/mozilla/rust/pull/11982
[09:28:17] <cmr> eddyb: yes.
[09:28:25] <cmr> rustpkg removal currently in testing
[09:28:46] <eddyb> I hope whatever we come up is written in rust and it's better
[09:28:54] <cmr> rustpkg is written in rust
[09:29:31] <eddyb> I know, I just mean I don't want to have a node.js or python-based package manager
[09:29:44] <cmr> ah
[09:29:57] <dbaupp> (I think strcat has a point that we should just use a tool like 0install.)
[09:30:20] <dbaupp> their next rewrite we can convince them to choose Rust instead of OCaml. :P
[09:30:49] <eddyb> that sounds pretty good, actually
[09:31:10] <cmr> they did evaluate it.
[09:31:24] <cmr> I don't remember the reasoning for the final decision, but it was a good one.
[09:32:12] <flaper87> I think it was stability
[09:32:24] <cmr> probabl
[09:32:24] <flaper87> I mean, they didn't pick rust because it didn't have backwards compatibility
[09:32:26] <cmr> y
[09:32:48] <flaper87> well, technically, it still doesn't but we're getting there :P
[09:33:08] <dbaupp> It was ~a year ago, and so Rust was not as nice a language
[09:33:18] <cmr> wasn't it like 8 months ago?
[09:34:49] <dbaupp> 8 is approximately 12
[09:35:41] <flaper87> lol
[09:37:28] *** Joins: gwty (gwtypc@2D0C08FA.3AF9C23B.45DA6411.IP)
[09:40:40] <flaper87> btw, next year we should've a #rustlang devroom at FOSDEM ( https://fosdem.org/2014/ )
[09:40:55] <flaper87> there's a mozilla devroom, but having one just for rust would be cool
[09:55:11] *** Joins: jdm (jdm@moz-DB4A9C19.scl3.mozilla.com)
[10:06:53] *** Joins: rca (rcatolino@D84C5999.F01B4DB2.520D6FA6.IP)
[10:09:52] *** Joins: mankyKitty (Instantbir@moz-F98AF264.rev.sfr.net)
[10:11:05] *** Quits: zimbabao (rajaram@BED96B2A.B53AC82C.D2D1FAF0.IP) (Ping timeout)
[10:18:46] *** Joins: summerlight (summerligh@327FC32B.2C956A45.501EFF44.IP)
[10:23:25] *** Quits: limeburst (me@247D1419.D73964AC.27A8748.IP) (Client exited)
[10:26:20] *** Joins: zimbabao (rajaram@A0834F85.4D5634FA.D2D1FAF0.IP)
[10:30:08] *** Joins: limeburst (me@247D1419.D73964AC.27A8748.IP)
[10:33:07] <cmr> eddyb: sorry I couldn't get you a snapshot :(
[10:33:11] * cmr goes to sleep
[10:33:21] *** Quits: jdm (jdm@moz-DB4A9C19.scl3.mozilla.com) (Quit: Lost terminal)
[10:34:14] *** Quits: rca (rcatolino@D84C5999.F01B4DB2.520D6FA6.IP) (Ping timeout)
[10:35:50] <eddyb> cmr: I might try and kill @Trait as much as possible
[10:36:04] <eddyb> dbaupp: know any attempt at ^^?
[10:43:39] *** Joins: rca (rcatolino@D84C5999.F01B4DB2.520D6FA6.IP)
[10:45:39] <eddyb> woo, struct HashMap<K, V, H = Hash<K>>; won't display H if it's Hash<K>, with K substituted :D
[10:46:19] *** Joins: ghrust (ghrust@24260B07.6A2AE50.F3114085.IP)
[10:46:19] <ghrust> 01[13rust01] 15bors merged 06auto into 06master: 02http://git.io/WBiK8g
[10:46:19] *** Parts: ghrust (ghrust@24260B07.6A2AE50.F3114085.IP) ()
[10:46:35] <eddyb> dbaupp: much better for inferred/generic cases than storing the number of defaults
[10:51:20] *** Joins: ghrust (ghrust@1E8607E8.6A2AE50.F3114085.IP)
[10:51:21] <ghrust> 01[13rust01] 15bors pushed 0 new commits to 06auto: 02http://git.io/clRcVA
[10:51:21] *** Parts: ghrust (ghrust@1E8607E8.6A2AE50.F3114085.IP) ()
[10:56:06] <eddyb> dbaupp: r=pcwalton? only change is some ppaux code to handle printing the tricky defaults like above https://github.com/mozilla/rust/pull/11982
[10:56:21] *** Joins: ghrust (ghrust@C8693FCB.6A2AE50.F3114085.IP)
[10:56:21] <ghrust> 01[13rust01] 15bors pushed 2 new commits to 06auto: 02http://git.io/EA9MQg
[10:56:21] <ghrust> 13rust/06auto 140074ae5 15Byron Williams: Change fmt! to format!
[10:56:21] <ghrust> 13rust/06auto 14fb663c3 15bors: auto merge of #11988 : cmr/rust/11668-squash, r=alexcrichton
[10:56:22] *** Parts: ghrust (ghrust@C8693FCB.6A2AE50.F3114085.IP) ()
[10:56:25] *** Joins: ghrust (ghrust@9C8B94D4.6A2AE50.F3114085.IP)
[10:56:25] <ghrust> 01[13rust01] 15bors pushed 0 new commits to 06auto: 02http://git.io/clRcVA
[10:56:25] *** Parts: ghrust (ghrust@9C8B94D4.6A2AE50.F3114085.IP) ()
[10:57:15] *** Joins: jensnockert (jensnocker@moz-7DC16A5F.afb.bredband2.com)
[10:58:57] *** Quits: jensnockert (jensnocker@moz-7DC16A5F.afb.bredband2.com) (Ping timeout)
[11:01:08] *** Quits: zimbabao (rajaram@A0834F85.4D5634FA.D2D1FAF0.IP) (Ping timeout)
[11:11:27] *** Joins: rca_ (rcatolino@moz-6D1B2709.adsl.proxad.net)
[11:12:07] *** Quits: rca (rcatolino@D84C5999.F01B4DB2.520D6FA6.IP) (Ping timeout)
[11:12:14] <eddyb> I wish I had r+ powers to send that PR to testing
[11:16:39] *** Joins: zimbabao (rajaram@B6E6B273.A14AA29D.D2D1FAF0.IP)
[11:22:31] *** Quits: TheHydroImpulse (TheHydroIm@moz-A9FB1B83.ed.shawcable.net) (Connection reset by peer)
[11:23:36] *** Quits: rca_ (rcatolino@moz-6D1B2709.adsl.proxad.net) (Ping timeout)
[11:24:35] *** Joins: TheHydroImpulse (TheHydroIm@moz-A9FB1B83.ed.shawcable.net)
[11:27:47] *** Quits: mankyKitty (Instantbir@moz-F98AF264.rev.sfr.net) (Quit: mankyKitty)
[11:28:15] *** Joins: rca (rcatolino@moz-997DEF82.adsl.proxad.net)
[11:28:49] *** Joins: jsonnull (Thunderbir@26F61E6.CFD9471D.494A0F8B.IP)
[11:29:16] *** Quits: zimbabao (rajaram@B6E6B273.A14AA29D.D2D1FAF0.IP) (Ping timeout)
[11:31:03] <Luqman> eddyb: which one?
[11:32:00] <eddyb> Luqman: I need r=pcwalton on https://github.com/mozilla/rust/pull/11982
[11:32:18] <eddyb> "only change is some ppaux code to handle printing the tricky defaults like above"
[11:32:52] <eddyb> Luqman: it would've actually merged hours ago (without that ^^ fix) but I hit a rustpkg test it seems
[11:34:58] <Luqman> eddyb: done
[11:35:46] <eddyb> Luqman: thanks :D
[11:37:16] *** Parts: jsonnull (Thunderbir@26F61E6.CFD9471D.494A0F8B.IP) ()
[11:40:08] <dbaupp> eddyb: I imagine the compiler uses @Trait a lot
[11:40:40] <eddyb> dbaupp: the compiler shouldn't use a single trait object IMO
[11:40:46] *** Joins: rca_ (rcatolino@moz-A5AE67A5.adsl.proxad.net)
[11:41:12] <dbaupp> eddyb: maybe it shouldn't but that doesn't change the current state of affairs
[11:41:21] *** Quits: rca_ (rcatolino@moz-A5AE67A5.adsl.proxad.net) (Quit: leaving)
[11:41:22] *** Quits: rca (rcatolino@moz-997DEF82.adsl.proxad.net) (Ping timeout)
[11:44:02] *** Joins: doener (doener@moz-C68F600D.unity-media.net)
[11:44:05] <SimonSapin> I wish I could write struct expressions as Foo { bar } instead of Foo { bar: bar }, where the value of a field is given by a variable of the same name
[11:44:19] <SimonSapin> Has this been discussed before?
[11:45:40] <dbaupp> I think people were idly discussing it on IRC just yesterday
[11:45:53] <dbaupp> I don't think an issue resulted from it though
[11:46:53] <eddyb> SimonSapin: I can implement it, not sure if it would be accepted though
[11:47:20] <eddyb> SimonSapin: it's just parser/pretty-printer work
[11:49:43] <SimonSapin> I think the same already works in patterns
[11:50:02] <eddyb> yupp, so I'd use "consistency" as an argument
[11:50:04] <SimonSapin> creating a variable named like the field
[11:50:16] <SimonSapin> eddyb: awesome :)
[11:50:41] <eddyb> dbaupp: I'll try chmod -w src/llvm
[11:51:33] <dbaupp> eddyb: why?
[11:51:46] <eddyb> hopefully that will leave it untouched when I go from current-branch -> old master, update master to current upstream -> new-branch
[11:51:57] <dbaupp> ah
[11:52:06] <dbaupp> (do you have ccache?)
[11:53:24] <eddyb> not (enabled)
[11:54:22] <dbaupp> it makes LLVM build in a flash :P
[11:55:56] <dbaupp> also, you could just touch src/llvm to be older
[11:56:02] <dbaupp> (possibly recursive)
[11:56:27] <eddyb> dbaupp: wait, can I do that?
[11:56:33] * eddyb feels dumb
[11:57:43] <doener> or maybe git update-index --assume-unchanged src/llvm
[11:58:03] <doener> hm, checkout might mess with that though. Let me try...
[11:58:30] <doener> yeah, doesn't work
[11:59:16] <dbaupp> eddyb: yeah, I do it to stop having to rebuild everything to continue `make check` when just fixing a single test in libstd
[11:59:31] * dbaupp hates how that makes things start from the very beginning
[11:59:34] *** Joins: ssira (ssira@moz-DC71C200.kanagawa.ocn.ne.jp)
[12:03:52] *** Quits: luz (lucy@moz-CD18B14B.customer.cdi.no) (Ping timeout)
[12:05:13] *** Joins: luz (lucy@moz-CD18B14B.customer.cdi.no)
[12:06:26] *** Joins: ghrust (ghrust@2EE61FCC.6A2AE50.F3114085.IP)
[12:06:26] <ghrust> 01[13rust01] 15bors merged 06auto into 06master: 02http://git.io/EA9MQg
[12:06:26] *** Parts: ghrust (ghrust@2EE61FCC.6A2AE50.F3114085.IP) ()
[12:11:08] <eddyb> dbaupp: find src/llvm | xargs touch -t 01010000
[12:11:15] <eddyb> I hope that works, thanks for the clue
[12:11:21] *** Joins: ghrust (ghrust@79968228.6A2AE50.F3114085.IP)
[12:11:21] <ghrust> 01[13rust01] 15bors pushed 0 new commits to 06auto: 02http://git.io/3da6kg
[12:11:21] *** Parts: ghrust (ghrust@79968228.6A2AE50.F3114085.IP) ()
[12:12:03] <dbaupp> eddyb: haha
[12:12:21] * dbaupp touched all of libsyntax back to 1970, and now the make files are complaining that it's too far in the future
[12:12:27] <dbaupp> I guess I should just fix that...
[12:12:40] <eddyb> haha
[12:12:59] <eddyb> you must've went a few hours too far back
[12:13:04] <dbaupp> (well, past... either way, they're not happy.)
[12:13:23] <dbaupp> yay, 1990 is recent enough
[12:13:30] <eddyb> that is, 1969 is probably in the future
[12:14:59] <dbaupp> eddyb: I thought those timestamps where i32/i64?
[12:15:32] <eddyb> -t is MMDDhhmm if that's what you're referring to
[12:15:44] <eddyb> dbaupp: aaah, signed. I don't know about that
[12:16:18] *** Joins: ghrust (ghrust@1E8607E8.6A2AE50.F3114085.IP)
[12:16:19] <ghrust> 01[13rust01] 15bors pushed 0 new commits to 06auto: 02http://git.io/3da6kg
[12:16:19] *** Parts: ghrust (ghrust@1E8607E8.6A2AE50.F3114085.IP) ()
[12:16:20] *** Joins: ghrust (ghrust@C8693FCB.6A2AE50.F3114085.IP)
[12:16:20] <ghrust> 01[13rust01] 15bors pushed 2 new commits to 06auto: 02http://git.io/aHjDEg
[12:16:20] <ghrust> 13rust/06auto 14fdf985c 15Eduard Burtescu: Substitute type params in default type params using them.
[12:16:20] <ghrust> 13rust/06auto 143e0eb3c 15bors: auto merge of #11982 : eddyb/rust/generic-default-type-params, r=pcwalton...
[12:16:20] *** Parts: ghrust (ghrust@C8693FCB.6A2AE50.F3114085.IP) ()
[12:26:57] <eddyb> dbaupp: it's still compiling a bunch of stuff :/
[12:27:33] <eddyb> this doesn't work either find src/llvm | xargs touch -t 199001010000
[12:28:13] <doener> eddyb: does it run configure again? That updates the submodules by default
[12:28:25] <dbaupp> eddyb: :(
[12:28:44] <doener> maybe passing --disable-manage-submodules to configure helps
[12:29:03] <eddyb> doener: I did it after running make and stopping it after a few files
[12:29:18] <eddyb> ls: src/llvm/.git/ nu poate fi accesat: Not a directory
[12:29:23] <eddyb> wtf did touch do?
[12:29:30] <SimonSapin> eddyb: I filed #11990
[12:30:24] <doener> eddyb: that's normal, the gitdir for submodules live within the main project's gitdir
[12:30:34] <eddyb> oh, okay
[12:30:43] <eddyb> I wanted to see what untracked files there were
[12:30:43] <doener> eddyb: the .git file just contains the path to it
[12:30:45] *** Quits: ssira (ssira@moz-DC71C200.kanagawa.ocn.ne.jp) (Client exited)
[12:31:09] *** Joins: ssira (ssira@moz-DC71C200.kanagawa.ocn.ne.jp)
[12:31:52] <eddyb> what's the xargs equivalent that doesn't use spaces for delimiters?
[12:32:38] <eddyb> nvm it's only one file :/
[12:32:46] <SimonSapin> Is [a, b] the only way to create a fixed-size vector value? (In this case I just want to implement .clone())
[12:32:55] *** Quits: ssira (ssira@moz-DC71C200.kanagawa.ocn.ne.jp) (Ping timeout)
[12:33:07] <eddyb> SimonSapin: implement clone for what?
[12:33:37] <dbaupp> eddyb: `find src/llvm -exec touch -t foobarbaz '{}' \+`
[12:33:46] <SimonSapin> for a struct with a fixed-size vector field
[12:34:03] <SimonSapin> #[deriving(Clone)] does not support fixed-size vectors
[12:34:07] <eddyb> SimonSapin: #[deriving(Clone)] doesn't work.... oh
[12:34:30] <eddyb> it could easily output N - no, it couldn't, because it's not that kind of a constant
[12:34:30] <SimonSapin> probably because the implementation can not be made generic over the size
[12:35:26] <eddyb> SimonSapin: you can use uninit and a copy_to_but_ignore_previous_value_in_dest function to implement it with slices
[12:36:14] <SimonSapin> I really just want a memcpy, but preferably safe
[12:36:32] <eddyb> dbaupp: it still wants to build everything
[12:37:03] <eddyb> dbaupp: x*/llvm/Release+Asserts is empty :((
[12:37:10] <eddyb> what silly script does this?
[12:42:19] <eddyb> also, parallelism is brkoen
[12:42:26] <eddyb> /bin/sh: line 0: echo: write error: Resource temporarily unavailable
[12:45:07] <dbaupp> SimonSapin: yeah, [, ..] implements no traits :(
[12:45:31] <dbaupp> SimonSapin: however [T, .. ] is Pod (i.e. implicitly copyable) if T: Pod
[12:46:07] <eddyb> you can always write a macro to implement a trait for [T, ..N], for fixed values of N, like we do for tuples
[12:48:01] <dbaupp> it's a good way to kill compilation time :P
[12:48:15] * dbaupp used a macro to autogenerate impls up to like 512 or something
[12:48:37] <dbaupp> takes a little while, and also kills rustdoc as far as I could tell
[12:51:04] <flaper87> dbaupp: yeah, I did that for rust-proton and I'm hating it right now. they're not 512 impls but it's not so nice
[12:52:47] <dbaupp> flaper87: https://github.com/huonw/boehm-rs/blob/master/src/tracing/boehm_traced_impls.rs#L79-L113
[12:53:03] <dbaupp> (toned down to just 128 there :P )
[12:53:21] <dbaupp> oh
[12:53:24] <dbaupp> actually only 63
[12:53:34] * dbaupp skipped 8
[12:54:39] <flaper87> dbaupp: hehe
[12:55:00] <flaper87> dbaupp: btw, how's that boehm implementation coming along?
[12:55:42] <dbaupp> flaper87: pnkfelix is working on boehm stuff
[12:56:26] <dbaupp> and I've postponed by pure-Rust GC work for now (partly because I have no idea what I'm doing :P and partly because the goals/design are still being hammered out)
[12:56:29] <dbaupp> *my
[12:57:50] *** Joins: jensnockert (jensnocker@moz-7DC16A5F.afb.bredband2.com)
[12:58:09] <flaper87> dbaupp: oh ok! Yeah, I don't know that much about GCs either. Sounds reasonable, though
[12:59:41] *** Quits: jensnockert (jensnocker@moz-7DC16A5F.afb.bredband2.com) (Ping timeout)
[12:59:48] *** Joins: jdm (jdm@moz-DB4A9C19.scl3.mozilla.com)
[13:01:26] <SimonSapin> dbaupp: oh, nice. Pod means I can write 'fn clone(&self) { Struct { field: self.field } }'
[13:01:50] <SimonSapin> dbaupp: Does Pod imply Clone?
[13:02:24] *** Joins: ssira (ssira@moz-DC71C200.kanagawa.ocn.ne.jp)
[13:02:27] <dbaupp> SimonSapin: yeah, pod allows you to write that instance
[13:02:28] <SimonSapin> or can #[deriving(Clone)] recurse with Pod instead of .clone()?
[13:02:36] <dbaupp> but no, Pod doesn't imply Clone
[13:02:52] <dbaupp> Pod is a compiler built-in, while Clone is purely in libraries
[13:03:03] <dbaupp> and no #[deriving] can't be that smart
[13:03:11] <SimonSapin> I see, thanks
[13:03:53] <dbaupp> You could define a wrapper struct that just contains the vectors and give that a Clone impl, which would allow #[deriving(Clone)] to work
[13:06:11] *** Joins: zimbabao (rajaram@B6E6B273.A14AA29D.D2D1FAF0.IP)
[13:08:00] *** Joins: SiegeLord (sl@moz-CAF07B4C.hsd1.ma.comcast.net)
[13:13:04] *** Joins: NiccosSystem (NiccosSyst@AB1AFDE.FC7B0C35.A7597CB6.IP)
[13:23:52] <eddyb> sweet, it passed :D
[13:25:58] *** Quits: ssira (ssira@moz-DC71C200.kanagawa.ocn.ne.jp) (Quit: Leaving...)
[13:26:22] *** Joins: ghrust (ghrust@DE823A67.6A2AE50.F3114085.IP)
[13:26:22] <ghrust> 01[13rust01] 15bors merged 06auto into 06master: 02http://git.io/aHjDEg
[13:26:22] *** Parts: ghrust (ghrust@DE823A67.6A2AE50.F3114085.IP) ()
[13:26:28] *** Joins: ssira (ssira@moz-DC71C200.kanagawa.ocn.ne.jp)
[13:27:19] <eddyb> SimonSapin: https://github.com/mozilla/rust/pull/11994
[13:27:38] <eddyb> what did I think but not say? 5-line change?
[13:27:53] <eddyb> 6 extra lines, actually
[13:27:55] <dbaupp> eddyb: failing tests
[13:28:02] <eddyb> dbaupp: foooor?
[13:28:19] <dbaupp> variable that doesn't exist
[13:28:25] <dbaupp> and field that doesn't exist
[13:28:26] <eddyb> though I tend to miss things, I was hoping this one...
[13:28:40] <eddyb> dbaupp: mkay, as silly as they sound, I'll do those
[13:29:19] <SimonSapin> eddyb: \o/
[13:29:24] <dbaupp> eddyb: yeah, a little silly; but just to be sure, and to keep it bullet-proof as people change things :)
[13:29:57] <dbaupp> eddyb: also, why matching with `match`?
[13:30:04] <dbaupp> why not just a.x and a.y?
[13:30:17] <flaper87> eddyb: that was fast :P
[13:30:24] <eddyb> flaper87: it's a tiny change
[13:30:28] <dbaupp> to keep it focused on the thing at hand
[13:30:34] <flaper87> eddyb: I thought it was going to be bigger, TBH
[13:30:57] <eddyb> dbaupp: because I copied a different test. I like how it outlines that both construction and destructuring supports those shorthands
[13:31:13] <eddyb> but sure, I'll do that
[13:31:23] *** Joins: ghrust (ghrust@9C8B94D4.6A2AE50.F3114085.IP)
[13:31:23] <ghrust> 01[13rust01] 15bors pushed 0 new commits to 06auto: 02http://git.io/fFha2w
[13:31:23] *** Parts: ghrust (ghrust@9C8B94D4.6A2AE50.F3114085.IP) ()
[13:33:07] <doener> hm, I should try to add calls to the llvm lifetime intrinsics once again
[13:37:56] <doener> https://gist.github.com/dotdash/23f242c04554ce5af71d -- manually added lifetimes to the (unoptimized) .ll file from rustc and passed it through opt -O3 / llc
[13:41:29] <dbaupp> doener: that's very cool
[13:44:08] <eddyb> doener: what are you exactly trying to do?
[13:44:51] <dbaupp> eddyb: make things more faster?
[13:45:03] <eddyb> which ones?
[13:45:03] <dbaupp> such speed
[13:45:05] <dbaupp> much optimisation
[13:45:24] <dbaupp> things in general? by giving LLVM more info
[13:45:37] <doener> eddyb: trying to get rustc to emit calls to the llvm lifetime intrinsics, so that e.g. allocas that don't have overlapping lifetimes can share the same stack slots
[13:45:46] <eddyb> doener: okay, that's cool :D
[13:46:36] <eddyb> we emit allocas at the top of the function for some reason, and sometimes LLVM can guess the lifetimes itself. if you can make Datum generate those intrinsic calls automatically, that would be awesome :D
[13:46:51] <eddyb> (well, having less allocas would also be nice)
[13:47:25] <flaper87> doener: awesome! 
[13:49:47] <doener> eddyb: most (all?) calls to the lifetime intrinsics you see in optimized code are put there by the inlining pass, which can guess the lifetimes of the inlined allocas quite easily :-)
[13:50:28] <eddyb> ahh
[13:50:34] <eddyb> so this is purely superior :D
[13:53:11] *** Quits: gwty (gwtypc@2D0C08FA.3AF9C23B.45DA6411.IP) (Ping timeout)
[13:53:26] <flaper87> dbaupp: I remember you openened / commented on a bug related to S3 and the docs not having 404 pages whatsoever. Is that issue related to the docs not loading the `index.html` automagically?
[13:53:30] <flaper87> http://static.rust-lang.org/doc/master/ 
[13:53:34] <flaper87> for example
[13:54:07] *** Joins: new_one (new_one@C6CC5851.CCA5821A.B3C0173E.IP)
[13:54:26] <dbaupp> flaper87: https://github.com/mozilla/rust/issues/11896 and https://github.com/mozilla/rust/issues/11897
[13:54:49] <flaper87> dbaupp: ok, thanks! I didn't want to create a duplicate
[13:55:08] *** Quits: cgaebel (clark@ADA4DDE2.290DF317.EE6E63A5.IP) (Ping timeout)
[14:08:00] *** Quits: TheHydroImpulse (TheHydroIm@moz-A9FB1B83.ed.shawcable.net) (Connection reset by peer)
[14:09:25] <eddyb> bench.rs:37:13: 40:17 error: cannot call a method whose type contains a self-type through an object
[14:09:32] *** Joins: TheHydroImpulse (TheHydroIm@moz-A9FB1B83.ed.shawcable.net)
[14:09:38] <eddyb> how did I break my own code and nothing else? that makes no sense
[14:12:09] *** Quits: jdm (jdm@moz-DB4A9C19.scl3.mozilla.com) (Quit: Lost terminal)
[14:16:14] <flaper87> lol
[14:16:46] *** Quits: TheHydroImpulse (TheHydroIm@moz-A9FB1B83.ed.shawcable.net) (Quit: TheHydroImpulse)
[14:17:57] *** Quits: zimbabao (rajaram@B6E6B273.A14AA29D.D2D1FAF0.IP) (Connection reset by peer)
[14:27:22] *** Quits: bjz (bjz@B398BE78.F804C29E.D35A31DF.IP) (No route to host)
[14:27:37] *** Joins: bjz (bjz@B398BE78.F804C29E.D35A31DF.IP)
[14:30:24] *** Joins: strcat (strcat@moz-54F7FD49.cpe.net.cable.rogers.com)
[14:31:23] *** Quits: NiccosSystem (NiccosSyst@AB1AFDE.FC7B0C35.A7597CB6.IP) (Client exited)
[14:34:07] *** Joins: zimbabao (rajaram@B433CF1A.43C38DAE.D2D1FAF0.IP)
[14:34:24] *** Quits: zimbabao (rajaram@B433CF1A.43C38DAE.D2D1FAF0.IP) (Connection reset by peer)
[14:44:17] *** Joins: dherman (dherman@moz-6CA476B1.hsd1.ca.comcast.net)
[14:44:18] *** ChanServ sets mode: +ao dherman dherman
[14:49:07] <eddyb> dbaupp: okay, so, putting &Argument inside a slice and taking it back out later causes devirtualization to happen without inlining after it
[14:51:04] *** Joins: zimbabao (rajaram@B433CF1A.43C38DAE.D2D1FAF0.IP)
[14:59:06] *** Joins: jensnockert (jensnocker@moz-7DC16A5F.afb.bredband2.com)
[15:00:49] *** Quits: jensnockert (jensnocker@moz-7DC16A5F.afb.bredband2.com) (Ping timeout)
[15:05:53] *** Quits: SiegeLord (sl@moz-CAF07B4C.hsd1.ma.comcast.net) (Quit: It's a joke, it's all a joke.)
[15:06:00] *** Joins: SiegeLord (sl@moz-CAF07B4C.hsd1.ma.comcast.net)
[15:09:34] *** Quits: dherman (dherman@moz-6CA476B1.hsd1.ca.comcast.net) (Quit: dherman)
[15:10:37] *** Quits: new_one (new_one@C6CC5851.CCA5821A.B3C0173E.IP) (Client exited)
[15:12:03] <doener> hm, at least it's compiling now...
[15:12:09] * doener makes too many stupid mistakes today
[15:13:58] <eddyb> doener: you and me both :P
[15:14:13] * eddyb is close to finding a rustc/LLVM optimization pass ordering bug
[15:15:54] <doener> "Cannot take the address of an intrinsic!" -- how did I do _that_?!
[15:26:57] *** Joins: canhtak (canhtak@moz-8A625E1D.wl.t.ulaval.ca)
[15:33:06] *** Joins: dherman (dherman@moz-6CA476B1.hsd1.ca.comcast.net)
[15:33:06] *** ChanServ sets mode: +ao dherman dherman
[15:58:54] *** Joins: aurynj (Eon@583ABBE5.60FA2E28.B9E25744.IP)
[16:05:43] *** Joins: erickt (Adium@49C4075F.3AC15C18.2321E71E.IP)
[16:39:29] *** Quits: ssira (ssira@moz-DC71C200.kanagawa.ocn.ne.jp) (Client exited)
[16:39:50] *** Joins: ssira (ssira@moz-DC71C200.kanagawa.ocn.ne.jp)
[16:41:27] *** Joins: ghrust (ghrust@DE823A67.6A2AE50.F3114085.IP)
[16:41:27] <ghrust> 01[13rust01] 15bors pushed 0 new commits to 06auto: 02http://git.io/fFha2w
[16:41:27] *** Parts: ghrust (ghrust@DE823A67.6A2AE50.F3114085.IP) ()
[16:41:30] *** Joins: ghrust (ghrust@DE823A67.6A2AE50.F3114085.IP)
[16:41:30] <ghrust> 01[13rust01] 15bors pushed 2 new commits to 06auto: 02http://git.io/sU0Sag
[16:41:30] <ghrust> 13rust/06auto 146ad383e 15Marcel Rodrigues: doc: use backticks for code-in-comments.
[16:41:30] <ghrust> 13rust/06auto 142ff16b1 15bors: auto merge of #11996 : lecram/rust/master, r=pcwalton...
[16:41:31] *** Parts: ghrust (ghrust@DE823A67.6A2AE50.F3114085.IP) ()
[16:41:36] *** Quits: ssira (ssira@moz-DC71C200.kanagawa.ocn.ne.jp) (Ping timeout)
[16:45:36] *** Quits: Kxepal (Miranda@moz-447F3688.pppoe.mtu-net.ru) (Ping timeout)
[16:48:42] *** Joins: cgaebel (clark@ADA4DDE2.290DF317.EE6E63A5.IP)
[16:48:54] *** Joins: Kxepal (Miranda@moz-1A176845.pppoe.mtu-net.ru)
[16:49:28] <doener> yay!
[16:51:25] <cgaebel> does rust's type system make it possible to have vec_ng::Vec<()> just be represented by a length and a single "representative" element?
[16:53:09] <eddyb> cgaebel: hmm?
[16:53:19] <eddyb> cgaebel: it would probably be a zero-sized heap allocation
[16:53:26] <eddyb> rusti: Some(~())
[16:53:27] -rusti- None
[16:53:39] <eddyb> strcat: ^^ you said this wasn't happening
[16:54:08] <strcat> hm?
[16:54:10] <strcat> that's bad
[16:54:23] <eddyb> strcat: that is, glibc malloc always returning non-NULL
[16:54:38] <strcat> eddyb: we don't call malloc directly anymore
[16:54:41] <strcat> need a different fix.
[16:54:44] <eddyb> and strangely enough... it's not aborting. I'm pretty sure the result of....
[16:54:47] <eddyb> strcat: wait, what?
[16:54:59] <eddyb> what do we call?
[16:55:04] <strcat> eddyb: malloc(0) may return an allocation or it may return NULL
[16:55:08] <strcat> eddyb: so we have to special case 0
[16:55:10] <eddyb> cgaebel: do you want two Vec<()> to appear different?
[16:55:12] <strcat> it currently returns NULL for 0
[16:55:15] <strcat> I guess that has to be changed
[16:55:19] <strcat> it has to clamp to 1
[16:55:26] <cgaebel> eddyb: Doesn't matter.
[16:55:28] <eddyb> non_zero_size_of?
[16:55:37] <eddyb> cgaebel: then... why not use a number, instead?
[16:55:39] <cgaebel> eddyb: want to implement hashset using hashmap, without wasting space for a set.
[16:55:46] <strcat> eddyb: well, it doesn't use size_of
[16:55:48] <eddyb> cgaebel: aah, I see
[16:55:56] <strcat> cgaebel: it doesn't waste space
[16:56:01] <strcat> cgaebel: () is zero-size
[16:56:25] <cgaebel> strcat: really? so total allocation for a vec_ng::Vec<()> of length 10 is the same as one of length 20?!
[16:56:28] <cgaebel> strcat: cool!
[16:56:44] <eddyb> oh, that question has a simple answer :P
[16:56:51] <strcat> cgaebel: well, atm it is always null
[16:56:53] <strcat> but
[16:56:54] <strcat> this has to change
[16:56:58] <eddyb> I was afraid you wanted more specific craziness
[16:56:58] <strcat> cgaebel: () itself is zero-size
[16:57:08] <strcat> in a hash table, there is Bucket { key, value, hash }
[16:57:10] *** Quits: japaric1 (japaric@DDF50A2B.40EC661E.5C7588CA.IP) (Ping timeout)
[16:57:16] <strcat> so if value is (), it's as if the field wasn't there
[16:57:23] <strcat> so whether Vec<()> uses an allocation isn't relevant
[16:57:32] <cgaebel> I actually have 3 vectors in mine. one of hashes, one of keys, and one of values.
[16:57:32] <cgaebel> because cache.
[16:57:50] <eddyb> cake?
[16:58:01] <cgaebel> cake?
[16:58:09] <eddyb> strcat: I found a subtitle for your blog - "the cache is a lie"
[16:58:25] <eddyb> cgaebel: just me being cheesy
[16:58:27] <strcat> no doubt already used somewhere
[16:58:34] <strcat> yep
[16:58:51] <strcat> http://www.opencaching.com/de/geocache/OX3385Z
[16:59:00] <strcat> different kind of cache ;)
[16:59:25] <cgaebel> did fmt::Default disappear overnight?
[16:59:45] <eddyb> renamed to Show, I think
[16:59:47] *** Joins: jensnockert (jensnocker@moz-7DC16A5F.afb.bredband2.com)
[16:59:53] <cgaebel> eddyb: thanks
[17:00:09] <eddyb> I don't like the name immediately, but I do agree it serves its purpose
[17:00:15] <eddyb> much better than Default, anyways
[17:01:14] <eddyb> strcat: lets see if I can construct my code outside of this context
[17:01:40] *** Quits: jensnockert (jensnocker@moz-7DC16A5F.afb.bredband2.com) (Ping timeout)
[17:02:14] <eddyb> strcat: it's something to do with &[&Trait]
[17:02:17] *** Joins: japaric1 (japaric@290150F2.C68AB816.F29ED47E.IP)
[17:02:35] <strcat> this is a PITA
[17:02:49] <strcat> I'll fix it in rust-core and make a PR for libstd
[17:02:54] <strcat> https://github.com/mozilla/rust/issues/11998
[17:03:07] <strcat> acrichto: around? fun problem ^ :)
[17:03:18] <strcat> curious if someone can think of a better solution
[17:03:44] <strcat> on the positive side, Vec<()> will be null when empty or have a malloc(1) allocation at every other size
[17:04:00] <strcat> so... it's not *that* bad
[17:04:18] <strcat> stupid useless malloc crap
[17:04:26] <strcat> eddyb: I know an alternative
[17:04:34] <strcat> eddyb: allocate a static variable
[17:04:43] <strcat> eddyb: return a pointer to it
[17:04:46] <strcat> :)
[17:04:59] <cgaebel> or just return &0x1
[17:05:06] <cgaebel> (which I've seen in some awful C codebases)
[17:05:13] <strcat> cgaebel: yeah that also works
[17:05:20] <strcat> or just return 1 as *int
[17:05:24] <strcat> it just has to be non-null
[17:05:35] <eddyb> strcat: if you don't care about reference equality, see my comment
[17:05:44] <strcat> we can't care about reference equality
[17:05:47] <strcat> it's a zero-size type
[17:05:51] <strcat> it doesn't reserve space anyway
[17:06:04] <strcat> rusti: let x = (); &x as *int
[17:06:05] -rusti- <anon>:10:21: 10:23 error: mismatched types: expected `*int` but found `&()` (expected int but found ())
[17:06:05] -rusti- <anon>:10         let x = (); &x as *int
[17:06:05] -rusti-                               ^~
[17:06:05] -rusti- error: aborting due to previous error
[17:06:05] -rusti- application terminated with error code 101
[17:06:09] <eddyb> so does ~() have to exist?
[17:06:12] <strcat> rusti: let x = (); &x as *()
[17:06:13] -rusti- (0x7f55c7399dc0 as *())
[17:06:25] <strcat> rusti: let x = (); let y = (); (&x as *(), &y as *())
[17:06:26] -rusti- ((0x7faa3e119db8 as *()), (0x7faa3e119db0 as *()))
[17:06:29] <cgaebel> how often is reference equality actually used?
[17:06:33] <strcat> rusti: let x = (); let y = (); (&x as *(), &y as *(), &x as *())
[17:06:34] -rusti- ((0x7fb069efddb0 as *()), (0x7fb069efdda8 as *()), (0x7fb069efddb0 as *()))
[17:06:37] <eddyb> rusti: let x = (); (&x as *(), &x as *())
[17:06:38] -rusti- ((0x7f1fe89f4db8 as *()), (0x7f1fe89f4db8 as *()))
[17:06:48] <eddyb> rusti: let x = (); (&x as *(), &() as *())
[17:06:49] -rusti- ((0x7f7571913db8 as *()), (0x7f7571913db0 as *()))
[17:06:52] <eddyb> meh
[17:06:54] <strcat> let me enable optimization
[17:06:58] <eddyb> hehe
[17:07:16] <strcat> rusti: let x = (); let y = (); (&x as *(), &y as *())
[17:07:17] -rusti- ((0x7fc8bb6bedc8 as *()), (0x7fc8bb6bedc8 as *()))
[17:07:22] <strcat> see?
[17:07:33] <strcat> it doesn't matter
[17:07:39] <strcat> because 'alias' in LLVM isn't about ptr equality
[17:07:53] <strcat> if you never read/write to them (we don't), then it's irrelevant
[17:08:01] <eddyb> strcat: can we make ~() zero sized? does that make sense? does it break anything?
[17:08:20] <strcat> eddyb: it's okay, the solution is to return '1 as *()'
[17:08:26] <strcat> not '0 as *()'
[17:08:29] <eddyb> hehe
[17:08:43] <eddyb> strcat: we need a typed allocator
[17:09:06] <eddyb> (which can do these kinds of shenanigans)
[17:10:31] <strcat> there are other zero-size types
[17:10:37] <strcat> anyway don't worry
[17:10:38] <strcat> genius plan
[17:10:46] <strcat> preserves the current 'optimization'
[17:11:18] * strcat pats himself on the back
[17:11:42] <strcat> I solved a problem and created a new problem, and now I get to solve it
[17:11:46] <strcat> again!
[17:11:59] <eddyb> strcat: you remind me of someone
[17:12:19] <eddyb> today I fixed (probably) the first bug I introduced
[17:13:58] *** Joins: gwty (gwtypc@6DB449F9.8B64350F.F64220F6.IP)
[17:15:59] <strcat> eddyb: meh actually
[17:16:01] <strcat> that doesn't work
[17:16:04] <strcat> since it's going to call free :(
[17:16:07] <strcat> and we don't give free a size
[17:16:22] <strcat> alright I need to throw it all out
[17:16:30] <eddyb> strcat: you can consider ~ZeroSized to not have free glue
[17:16:41] <strcat> eddyb: it doesn't know the size...
[17:16:43] <strcat> ~Trait
[17:16:50] <strcat> well
[17:16:54] <strcat> I guess it does in advance
[17:16:54] <eddyb> strcat: the drop glue does
[17:16:57] <strcat> this is an enormous pain.
[17:17:13] <eddyb> strcat: the drop glue of the original type actually does the freeing, so it's fine
[17:17:16] <strcat> this is a huge pain
[17:17:17] *** Quits: dherman (dherman@moz-6CA476B1.hsd1.ca.comcast.net) (Quit: dherman)
[17:17:19] <eddyb> just modify free glue
[17:17:38] <eddyb> or what has remained of it
[17:17:57] <strcat> eddyb: I am going to pass a size to free
[17:17:59] <strcat> it is useful anyway
[17:18:16] <eddyb> strcat: what would be useful is a type
[17:18:27] <eddyb> like, make alloc/free generic
[17:18:50] <strcat> are there generic lang items already?
[17:18:53] <strcat> this would be the first
[17:19:34] *** japaric1 is now known as japaric
[17:21:06] *** Quits: zimbabao (rajaram@B433CF1A.43C38DAE.D2D1FAF0.IP) (Ping timeout)
[17:24:36] *** Quits: summerlight (summerligh@327FC32B.2C956A45.501EFF44.IP) (Ping timeout)
[17:29:32] <strcat> eddyb: ugh
[17:29:54] <eddyb> pretty sure the covariant/invariant stuff is generic
[17:29:58] <eddyb> though those are types
[17:30:01] *** Quits: erickt (Adium@49C4075F.3AC15C18.2321E71E.IP) (Quit: Leaving.)
[17:33:27] <strcat> need to update rust-core to use marker types
[17:33:31] <strcat> then I'll deal with allocation
[17:34:03] <olsonjeffery> is there any place in the docs or codebase where i could see marker types in action?
[17:34:25] <olsonjeffery> the PRs/issues referenced didn't have much in the way of commentary, from what i could gather
[17:34:54] <strcat> the PR introduced usage of them and big block comments
[17:36:50] *** Joins: NiccosSystem (NiccosSyst@AB1AFDE.FC7B0C35.A7597CB6.IP)
[17:37:47] *** Joins: dherman (dherman@moz-6CA476B1.hsd1.ca.comcast.net)
[17:37:47] *** ChanServ sets mode: +ao dherman dherman
[17:40:12] <cgaebel> is uninit<T>().drop() safe?
[17:41:09] <eddyb> cgaebel: no
[17:41:20] <strcat> cgaebel: what does drop do?
[17:41:22] <eddyb> well, it would be drop(uninit::<T>()) anyways
[17:41:39] <eddyb> cgaebel: init::<T>() is somewhat closer to sanity
[17:41:44] <strcat> 'somewhat'
[17:41:53] <strcat> zeroed doesn't mean correctly initialized for most types
[17:41:58] <cgaebel> so how do I safely "free" a vector with some elements uninitialized, where I know which ones are and aren't initialized?
[17:42:21] <eddyb> cgaebel: that is, for all types that move, if all bytes are zero, they are considered as being dropped already
[17:42:56] <eddyb> (though only some bytes need to be zero for that to apply. like the drop flag)
[17:43:13] <cgaebel> so it's safe to let a ~[uninit, e1, uninit, v2] vector fall out of scope for all e1: T?
[17:43:22] <cgaebel> err, ~[uninit, e1, uninit, e2]
[17:43:46] <cgaebel> and drop will be called on e1 and e2, and nothing bad will happen with the other elems?
[17:45:39] <eddyb> cgaebel: not uninit
[17:45:48] <eddyb> cgaebel: only init, which is memset 0
[17:46:12] <cgaebel> ok. so if I have a ~[init, e1, init, e2], and it falls out of scope, that'll be safe?
[17:46:29] <eddyb> cgaebel: if your types are Pod, you can let them drop even if they're uninitialized, otherwise, you need at least "init" (and/or memset 0)
[17:46:32] *** Joins: jensnockert (jensnocker@moz-7DC16A5F.afb.bredband2.com)
[17:46:46] <eddyb> cgaebel: what kind of algorithm are you playing with?
[17:46:53] <cgaebel> it's just a hashtable
[17:47:08] <cgaebel> keys + vals are "undefined" if the hash == 0
[17:50:53] <strcat> cgaebel: no, that's not safe
[17:51:10] <cgaebel> is there a safe way of writing this?
[17:51:14] <strcat> eddyb: it only works right now due to an implementation detail that is intended to change
[17:51:22] *** Joins: ghrust (ghrust@DE823A67.6A2AE50.F3114085.IP)
[17:51:22] <ghrust> 01[13rust01] 15bors merged 06auto into 06master: 02http://git.io/sU0Sag
[17:51:22] *** Parts: ghrust (ghrust@DE823A67.6A2AE50.F3114085.IP) ()
[17:51:24] <eddyb> strcat: I know that very well
[17:51:26] <strcat> cgaebel: you can't allow a destructor to be called on an improperly initialized type
[17:51:33] <strcat> init() isn't correctly initialized, just zeroed
[17:51:48] <strcat> cgaebel: in the destructor for your hash table, do something to prevent the dtor from being called on uninit data
[17:52:03] <eddyb> strcat: https://gist.github.com/eddyb/5705c1dd292e58ccd210 the call to Bar::bar isn't inlined after it's devirtualized
[17:52:15] <strcat> cgaebel: https://github.com/thestinger/rust-core/blob/master/core/deque.rs#L154 like this
[17:52:17] <cgaebel> I guess I can set_len after removing all the elements
[17:52:21] <cgaebel> set_len(0)
[17:52:23] <strcat> cgaebel: it uses a vector but doesn't fully initialize it
[17:52:23] <cgaebel> would that work?
[17:52:28] <eddyb> yes, much saner
[17:52:30] <strcat> cgaebel: yes look at that deque dtor
[17:52:36] <strcat> cgaebel: it leaves a portion of the vector uninit
[17:52:43] <eddyb> strcat: I'm not sure I can make my testcase smaller
[17:52:46] <strcat> anyway atm it doesn't reuse the length field
[17:52:51] <strcat> but if it did, it'd need set_len there
[17:53:03] <strcat> (rust-core's asserts are disabled by default)
[17:54:07] <cgaebel> would setting the length to 0 of a vector of uninitialized data before destructing ruin my day still?
[17:54:23] <eddyb> cgaebel: nope
[17:54:33] *** Quits: lpy (lpy@B744D17C.B31F127E.E99F7FDB.IP) (Client exited)
[17:54:40] <cgaebel> eddyb: ok. I'll try that first then. I think it might be easier to work into what I already have.
[17:55:22] <eddyb> strcat: updated with LLVM IR https://gist.github.com/eddyb/5705c1dd292e58ccd210
[17:59:05] *** Joins: nrc|afk (nrc@7BE24E90.A5032A01.3CFC199D.IP)
[18:00:05] <strcat> eddyb: LLVM IR for... ?
[18:00:14] <strcat> oh
[18:00:47] <eddyb> strcat: with a well-placed #[always(inline)] there's no difference between -O1 and -O3
[18:01:36] <strcat> yes the big thing about --opt-level=1 is no cost-based inlining
[18:01:43] <strcat> so you need well placed inline(always) to perform well there
[18:01:52] <strcat> gcc even runs a separate inline(always) pass iirc
[18:01:58] <strcat> llvm doesn't
[18:02:12] <strcat> gcc tries to inline those early, with the assumption that they don't need inner optimizations
[18:02:20] <strcat> for compile-time
[18:02:32] <strcat> well and more time to work on the inline site
[18:02:34] <cgaebel> what does #[inline] do relative to #[always(inline)] is it just which optimization level it's run at?
[18:02:41] <strcat> cgaebel: no
[18:02:56] <strcat> cgaebel: only functions marked inline(never) are not eligible for cost-based inlining
[18:03:18] <strcat> #[inline] adds an inline hint (raises the cost threshold) and allows cross-crate inlining for non-generics
[18:03:27] <strcat> although perhaps in the future, it will be required for generics too
[18:03:29] <strcat> in some cases
[18:03:56] <strcat> cgaebel: at -O0 and -O1, it only inlines inline(always) functions
[18:04:03] <strcat> at -O2 and -O3, it also does cost-based inlining
[18:04:11] <cgaebel> ok
[18:04:25] <eddyb> err
[18:04:26] <strcat> inline hints are generally a bad idea, but in rust you need lots in libraries to make cross-crate inlining possible
[18:04:33] <eddyb> #[inline(always)], my bad
[18:04:42] <eddyb> strcat: okay, so, no closures, just an argument big enough https://gist.github.com/eddyb/5705c1dd292e58ccd210
[18:05:24] <eddyb> strcat: now I need to bisect passes :S
[18:11:41] <eddyb> strcat: even smaller https://gist.github.com/eddyb/5705c1dd292e58ccd210
[18:13:43] <eddyb> strcat: can I get a set of --passes to run with -O0 to mimic -O1 or -O3?
[18:14:06] *** Quits: jensnockert (jensnocker@moz-7DC16A5F.afb.bredband2.com) (Input/output error)
[18:15:32] <strcat> eddyb: you can't mimic it with passes alone, it won't set the inline threshold
[18:15:47] <eddyb> I don't really need that
[18:15:58] <eddyb> notice my abuse of #[inline(always)]
[18:16:06] <strcat> clang foo.c -mllvm -debug-pass=Structure -O2
[18:16:10] <strcat> clang foo.c -mllvm -debug-pass=Arguments -O2
[18:16:11] <strcat> for the simple one
[18:16:14] *** Joins: jensnockert (jensnocker@moz-7DC16A5F.afb.bredband2.com)
[18:16:17] <strcat> eddyb: can't mimic it with passes alone for other reasons
[18:16:24] <strcat> eddyb: there are separate function passes run before the module passes
[18:16:34] <eddyb> bleah
[18:16:39] <strcat> and with LTO, it does function passes -> module pass -> LTO module pass
[18:16:45] <eddyb> is there no simple bisect for this?
[18:17:03] <eddyb> I just want to know what modifies the function to allow inlining but doesn't attempt it
[18:17:16] <strcat> it's not necessarily a bug
[18:17:27] <strcat> LLVM doesn't have all the time in the world to optimize
[18:17:43] <strcat> sometimes you just have to write better code in the first place :P
[18:18:38] <eddyb> strcat: it has something to do with how we pass structures by value (that is, by reference)
[18:18:54] <eddyb> which means it can really hurt (was caused by a closure in my case)
[18:19:41] <strcat> well, investigate fixing *that* in LLVM
[18:19:47] <strcat> lower actual by-value parameters properly
[18:19:51] <strcat> then we can always do by-value when we mean it
[18:20:05] <strcat> there code to do it exists
[18:20:07] <strcat> it may already work
[18:20:18] <strcat> i.e. there is sret/parameter lowering code
[18:20:28] <strcat> just make sure it generates code at least as good as we get now
[18:22:05] <eddyb> strcat: it shouldn't break optimizations, though
[18:22:33] <strcat> eddyb: why not?
[18:22:40] <strcat> eddyb: it can and does break optimizations
[18:22:43] <strcat> it is a lossy way of doing by-value.
[18:22:55] <eddyb> strcat: I'm not even using that argument
[18:22:56] <strcat> that is known, and there is no way to mark the IR to communicate all the information
[18:23:04] <strcat> alright so I don't know what you're saying
[18:23:17] <eddyb> its mere presence breaks a semi-unrelated optimization
[18:23:23] <strcat> the fact is that passing stuff by-pointer loses out on a lot of optimizations
[18:23:30] <strcat> LLVM knows a value is valid
[18:23:40] <strcat> it cannot assume a pointer actually points to an object of the type it says
[18:23:42] <strcat> it could be dangling
[18:23:44] <strcat> it could be null
[18:23:48] <strcat> it could point to something else
[18:24:11] <strcat> LLVM pointers types are *meaningless* except for a GEP/Load
[18:24:21] <strcat> they don't give LLVM information
[18:24:33] <strcat> *i32 vs. *{i32, i32} as a parameter
[18:24:44] <strcat> for an {i32, i32}
[18:24:47] <strcat> LLVM doesn't care
[18:24:49] <eddyb> fn foo(x: &Indirect) {} allows the rest of the code to work properly, while fn foo(x: Indirect) {} doesn't
[18:24:59] <eddyb> the function is optimized to ret void in both cases
[18:25:04] <strcat> doesn't compile to the same thing
[18:25:12] *** Joins: lpy (lpy@B744D17C.B31F127E.E99F7FDB.IP)
[18:25:26] <eddyb> strcat: I want to catch it in the act
[18:26:40] *** Quits: lpy (lpy@B744D17C.B31F127E.E99F7FDB.IP) (Connection reset by peer)
[18:26:57] *** Joins: lpy (lpy@B744D17C.B31F127E.E99F7FDB.IP)
[18:27:37] <eddyb> strcat: from what I know and what you're saying, it may devirtualize before it optimizes out the callee - but I have alwaysinline on all functions, so that doesn't make sense
[18:27:49] <eddyb> okay, let me try something crazy
[18:27:49] <strcat> dunno what you mean
[18:27:55] <strcat> alwaysinline doesn't mean it has to be inlined
[18:28:04] <strcat> it means it will inline during an inline attempt without checking the cost
[18:28:20] <strcat> if it's already below the cost, alwaysinline does *nothing*
[18:28:32] <strcat> there is no separate handling
[18:28:48] *** Quits: lpy (lpy@B744D17C.B31F127E.E99F7FDB.IP) (Ping timeout)
[18:28:56] <eddyb> -O0 does alwaysinline? o_O
[18:28:59] <strcat> eddyb: yes.
[18:29:11] <strcat> that's the point of it
[18:29:23] <eddyb> anyways, the resulting fn test body is tiny
[18:29:25] *** Joins: new_one (new_one@6F9548B7.4BFECEA2.B3C0173E.IP)
[18:29:34] <eddyb> compared to what I was expecting
[18:29:39] <strcat> it inlines if possible regardless of the need to preserve debugging or compile quickly
[18:29:50] <strcat> eddyb: -O0 doesn't insert lifetime markers on inline
[18:29:51] <strcat> -O1 does
[18:30:02] <eddyb> interesting
[18:31:11] <eddyb> strcat: I don't see what could possibly reasonably block optimizations for a reason
[18:31:20] <acrichto> strcat: do you know if that works when you do *(~()) ?
[18:31:39] <doener> eddyb: the unexpected thing there is that Foo::foo::...() is not inlined?
[18:31:46] <strcat> acrichto: we never actually deref zero-size types, that'd be a bug
[18:31:52] <strcat> acrichto: as they point to arbitrary addresses
[18:31:54] <strcat> may not be readable
[18:31:59] <eddyb> doener: yeah
[18:32:00] <acrichto> rusti: *(~())
[18:32:02] -rusti- ()
[18:32:10] <acrichto> strcat: I think you can dereference the box though
[18:32:23] <acrichto> strcat: I'm not sure if the codegen actually emits a load (I don't think it should)
[18:32:26] <strcat> acrichto: I don't think so, it would be a bug
[18:32:31] <acrichto> oh yay!
[18:32:37] <strcat> acrichto: whether or not it can be null, it would be a bug to deref
[18:32:38] <acrichto> I think you just hav to make sure that free(1) works then
[18:32:49] <strcat> acrichto: well I am going to change exchange_free to take a size
[18:32:53] <strcat> acrichto: it is faster anyway with a non-C allocator
[18:32:58] <strcat> as you can skip finding the right pool
[18:33:03] <strcat> well
[18:33:06] <strcat> depends on the allocator.
[18:33:09] <acrichto> oh hm...
[18:33:17] <strcat> acrichto: we always know the size for exchange_free
[18:33:34] <acrichto> sgtm
[18:33:34] <strcat> it could even give the type but I don't really know how much work making a generic lang item would be
[18:34:01] <acrichto> the intrinsics are generic
[18:34:03] <eddyb> wait, that would mean my Slam/Blam doesn't need a cache pointer. but then, that pointer still helps with distinguishing between a freed node and an allocated one
[18:34:05] <acrichto> so I don't think it's too hard
[18:34:16] <eddyb> acrichto: lang items, not intrinsics
[18:34:31] <strcat> acrichto: I'm thinking about what the generic allocator interface will have
[18:34:35] <acrichto> yeah I guess none of those are generic right now
[18:34:36] *** Quits: jensnockert (jensnocker@moz-7DC16A5F.afb.bredband2.com) (Input/output error)
[18:34:37] <strcat> I think free should probably require a size
[18:34:44] <strcat> alloc(size)
[18:34:46] <strcat> zero_alloc(size)
[18:34:54] <strcat> realloc(old_ptr, new_size)
[18:34:58] <strcat> free(ptr, size)
[18:35:34] <strcat> it gives the allocator strictly more information, and I can't think of a time when user code has an allocation but not a size
[18:35:58] <acrichto> when freeing?
[18:36:03] <strcat> a vector will always know the capacity (or the length, if it's fixed capacity)
[18:36:05] <strcat> acrichto: yes
[18:36:23] <acrichto> I know I've run into it on more than one occasion where it's super convenient
[18:36:29] <acrichto> but that's when I'm dealing with malloc/free directly
[18:36:31] <strcat> to not need the length?
[18:36:42] <acrichto> yeha
[18:36:50] <acrichto> but this is in C code, not in rust code I think
[18:36:59] <eddyb> strcat: ~[T] wouldn't know its capacity
[18:37:03] <strcat> eddyb: yes it would.
[18:37:14] <strcat> length == capacity, is it not?
[18:37:27] <strcat> Vec<T> -> ~[T] would shrink_to_fit
[18:37:34] <strcat> anyway
[18:37:38] <eddyb> oh, if you do that... then it's sane
[18:37:42] <strcat> I am still not feeling great about a separate ~[T] type
[18:37:56] <acrichto> neither do I :\
[18:37:59] <eddyb> and requires no oracle when going back to Vec<T>, if required
[18:38:10] <strcat> I don't see why I need to go back and forth between Vec<T> and ~[T]
[18:38:12] <strcat> ;\
[18:38:31] <strcat> Rc<[T]>/Gc<[T]> is undeniably useful
[18:38:32] <eddyb> strcat: I like how nmatsakis calls [T] arrays and Vec<T> vectors...
[18:38:37] <strcat> but all ~[T] provides is one fewer field
[18:38:40] <strcat> well
[18:38:41] <strcat> I'd say
[18:38:47] <eddyb> if we don't need ~[T], we can disable it by default
[18:38:49] <strcat> [T, ..n] is an an array, [T] is a slice
[18:38:58] <eddyb> sure
[18:38:58] <strcat> Go and D have heap-allocated slices
[18:39:23] <strcat> and C++ only calls fixed-size arrays arrays
[18:39:29] <strcat> std::array<T, n> and C arrays
[18:39:58] <strcat> anyway that's what I'm doing.
[18:40:05] * strcat goes to fix free
[18:40:10] <strcat> exchange_free*
[18:40:53] <strcat> If the size of the space requested is 0, the behavior is implementation-defined: the value returned shall be either a null pointer or a unique pointer.
[18:40:55] <strcat> such a pain
[18:41:05] <strcat> acrichto: technically, we could check errno for ENOMEM instead of the null compare
[18:41:13] <strcat> but we *need* to guarantee ~() is not null
[18:41:19] <strcat> so... we need to deal with this crap by branching anyway
[18:41:21] <strcat> :[
[18:41:33] <strcat> optimizes out but it's so much more complex than it should be
[18:41:37] <strcat> if only C was sane
[18:42:02] <acrichto> hmm...
[18:42:03] <eddyb> strcat: you can always just remove the free call completely for ~ZeroSized
[18:42:05] <strcat> if *I* wrote the standard
[18:42:08] <strcat> I would have said...
[18:42:19] <strcat> malloc(0) returns a non-null pointer that can be passed to free
[18:42:23] <strcat> but it might not be unique.
[18:42:38] <strcat> and then you just return the address of a constant for malloc(0) and free checks for that address
[18:42:56] <strcat> I don't see any point in saying it is *either* null or a unique ptr
[18:43:04] <eddyb> and it can be the address of a static in the library so it's inlined to a constant?
[18:43:24] <strcat> talking about C
[18:43:28] <acrichto> woohoo claimed #12000!
[18:43:29] <strcat> rust's statics don't work that way
[18:43:42] <strcat> acrichto: hm?
[18:43:49] <acrichto> https://github.com/mozilla/rust/issues/12000
[18:44:00] <eddyb> strcat: I meant C
[18:49:49] <strcat> acrichto: and realloc would need to take the old size
[18:50:03] <acrichto> makes sense
[18:53:48] <eddyb> strcat: I so wish I could come up with a simpler testcase :(
[18:54:05] <eddyb> there are a few conditions here complicating things
[18:55:06] <eddyb> it has to be a trait object in a vector
[18:55:53] <eddyb> that is, if I put let args: &[&Foo] = [&() as &Foo]; args[0].foo((0, 0)); in one function, it works fine
[18:56:58] <eddyb> a trait object in a vector that is coerced to a slice as an argument to a function calling a method on the trait object with an argument passed by value but indirectly
[18:57:24] <eddyb> strcat: at least I optimized out the punctuation
[18:57:48] *** Quits: canhtak (canhtak@moz-8A625E1D.wl.t.ulaval.ca) (Quit: canhtak)
[18:57:58] *** Joins: canhtak (canhtak@moz-8A625E1D.wl.t.ulaval.ca)
[18:58:40] <eddyb> doener: do you have any experience with tracking down something like this?
[18:58:56] *** Joins: ghrust (ghrust@9C8B94D4.6A2AE50.F3114085.IP)
[18:58:57] <ghrust> 01[13rust01] 15alexcrichton merged 06auto into 06snap-stage3: 02http://git.io/wxryqg
[18:58:57] *** Parts: ghrust (ghrust@9C8B94D4.6A2AE50.F3114085.IP) ()
[18:59:03] *** Joins: erickt (etryzelaar@8C9ECD8F.3A598286.F12515B4.IP)
[19:01:34] *** Joins: ghrust (ghrust@79968228.6A2AE50.F3114085.IP)
[19:01:34] <ghrust> 01[13rust01] 15bors pushed 4 new commits to 06auto: 02http://git.io/hv1YVQ
[19:01:34] <ghrust> 13rust/06auto 14864b434 15Alex Crichton: Move doc/ to src/doc/...
[19:01:34] <ghrust> 13rust/06auto 1491882a4 15Alex Crichton: Remove VPATH usage in Makefiles...
[19:01:35] <ghrust> 13rust/06auto 1422a421f 15Alex Crichton: Rewrite the doc makefile for doc => src/doc...
[19:01:37] *** Parts: ghrust (ghrust@79968228.6A2AE50.F3114085.IP) ()
[19:02:02] <eddyb> acrichto: oh, heh, I've never tested my struct literal field shorthand PR, because I stopped the very slow LLVM rebuild :(
[19:02:06] <doener> eddyb: not much. I tried using the info from -Z print-llvm-passes to reproduct with `opt`, but that doesn't work (i.e. it inlines)
[19:02:22] <acrichto> eddyb: haha, oh well
[19:02:38] <eddyb> but if there's a problem, it's something small
[19:02:39] * acrichto wills something of his to actually merge
[19:02:48] <eddyb> doener: for my testcase?
[19:03:06] <cmr> acrichto: will will not work, only vim
[19:03:11] <doener> eddyb: yeah
[19:03:40] <eddyb> hard to update because my chrome is broken
[19:07:11] <doener> eddyb: opt-3.4 bla.ll -S  -sroa  -instcombine -always-inline
[19:07:29] <doener> eddyb: that seems to be the minimal set of passes required for the call to be removed
[19:07:50] <eddyb> why are you not using the opt built by the rust build system?
[19:09:00] <doener> didn't expect that to make a difference. 
[19:09:03] <doener> and it doesn't AFAICT
[19:10:00] <eddyb> but that's a small set of optimizations
[19:10:10] <eddyb> doener: where does -sroa  -instcombine get you?
[19:10:17] <eddyb> doener: similar state to rustc -O3?
[19:10:34] <doener> instcombine reduces Foo::foo() to "ret void", sroa+instcombine cause the devirtualization, always-inline removes the call
[19:11:00] <eddyb> doener: btw, you can run rustc --save-temps to get the not-optimized-at-all-nada file
[19:12:23] <eddyb> doener: https://gist.github.com/eddyb/5705c1dd292e58ccd210#file-bad-devirtualize-rs rustc --save-temps, take the no-opt .bc file, and run it through opt -O1
[19:12:33] <doener> ah, right, we do some passes even when not using -O
[19:12:53] <eddyb> --opt-level=0 runs alwaysinline, per strcat's comments
[19:13:26] <eddyb> doener: if we do worse than opt, that's probably a bug in the rust pass manager
[19:15:58] *** Quits: kaeso (kaeso@moz-F21FF626.unstable.it) (Ping timeout)
[19:17:56] *** Quits: eddyb (eddy@832D2DE5.66315F97.FB866788.IP) (Ping timeout)
[19:18:15] <cmr> acrichto: something is seriously wrong with snap3-win, http://buildbot.rust-lang.org/builders/snap3-win/builds/645/steps/clean/logs/stdio
[19:18:38] <acrichto> ugh I hate these windows builders
[19:18:51] <cmr> s/builders// ;(
[19:18:59] <acrichto> lol
[19:23:14] *** Joins: eddyb (eddyb@832D2DE5.66315F97.FB866788.IP)
[19:23:22] *** eddyb is now known as eddyb[pc]
[19:23:33] <eddyb[pc]> note to self: opt /dev/zero is a bad, bad idea
[19:23:45] <cmr> heh
[19:27:42] *** Joins: lpy (lpy@B744D17C.B31F127E.E99F7FDB.IP)
[19:29:27] *** Joins: eddyb (eddy@832D2DE5.66315F97.FB866788.IP)
[19:29:39] *** Quits: lpy (lpy@B744D17C.B31F127E.E99F7FDB.IP) (Ping timeout)
[19:32:50] <eddyb> doener: have you managed to get anywhere?
[19:33:50] <doener> almost
[19:36:31] <eddyb> what's the logic for having the LLVM passes in back::link::write?
[19:37:07] <doener> eddyb: -always-inline -sroa -instcombine -always-inline
[19:37:30] <doener> eddyb: that's required for `opt` to remove the call with the .no-opt.bc version
[19:37:48] <eddyb> doener: and what does rustc do for -O0?
[19:38:01] <doener> eddyb: -always-inline
[19:38:32] <doener> that's why I didn't need the first inlining run in my previous experiments
[19:38:40] <eddyb> doener: how about --opt-level=1?
[19:39:02] <doener> eddyb: also just a single inliner run, but we need 2
[19:39:10] <doener> (for whatever reason)
[19:39:26] <doener> without the first run, the sroa+instcombine doesn't manage to drop the memcpy calls
[19:39:50] <eddyb> doener: so an inline *at the start* solves it?
[19:39:51] <doener> and then the later inlining run doesn't inline the function (even though it's marked alwaysinline...)
[19:40:02] <eddyb> weeeeird
[19:40:09] <doener> indeed
[19:40:32] <doener> btw, using opt with -print-after-all was super helpful to figure this out
[19:40:37] <eddyb> echo 'fn main(){}' | ./x*/stage1/bin/rustc -Z print-llvm-passes --opt-level=1 - 2>| less
[19:40:41] <eddyb> there's a lot of stuff going on in there
[19:41:23] <strcat> eddyb: run -Z lto and there's even more
[19:41:29] <eddyb> doener: does opt -O1 optimize it out?
[19:41:51] <doener> eddyb: no
[19:42:09] <doener> eddyb: since we're using the same pass managers as `opt`, results should be identical
[19:42:15] *** nrc|afk is now known as nrc
[19:42:16] <eddyb> doener: -O2/-O3?
[19:42:46] <eddyb> I thought you - oh, nvm, you weren't running on no-opt before
[19:43:15] <doener> yeah, forgot that always-inline always runs
[19:43:31] <eddyb> so if it inlines before it optimizes, it can eliminate the memcpy easier
[19:43:46] <eddyb> but why is it not inlining the devirtualized call?
[19:44:41] <eddyb> doener: does it need both -sroa and -instcombine?
[19:46:31] <doener> eddyb: yeah, without those, the call is still indirect
[19:48:22] <strcat> doener: opt doesn't enable loop-vectorize or slp-vectorize (although that's irrelevant to this)
[19:49:33] <doener> eddyb: ok, the inner call to foo() requires the memcpy(s), so without the first inlining run, those can't be removed
[19:50:06] <eddyb> doener: that's the entire issue?
[19:50:17] <eddyb> well, the root of it
[19:50:40] <eddyb> doener: so what does opt -sroa -instcombine -always-inline result it?
[19:50:42] <eddyb> *in
[19:50:49] <doener> it's part of it. Still doesn't explain why -always-inline doesn't always inline
[19:51:11] <eddyb> doener: so the -always-inline at the end is a noop?
[19:51:42] <doener> eddyb: no, that inlines the call to Foo::foo()
[19:51:54] <doener> eddyb: the first one inlines foo() (the toplevel one)
[19:52:03] *** Quits: cgaebel (clark@ADA4DDE2.290DF317.EE6E63A5.IP) (Ping timeout)
[19:52:48] <eddyb> doener: riight. but I want to know what -O1 or -O3 do that doesn't trigger an inline for Foo::foo() *at some point*
[19:52:51] <doener> eddyb: ah, good thing you asked about leaving out the first inlining again. That actually _doesn't_ de-virt
[19:52:59] <doener> eddyb: and without de-virt, it can't inline
[19:53:04] <eddyb> AHA
[19:53:16] <eddyb> doener: that means it devirtualizes later
[19:53:23] *** Joins: cgaebel (clark@ADA4DDE2.290DF317.EE6E63A5.IP)
[19:53:45] <eddyb> rustc --opt-level=1 actually devirtualizes, just not early enough for an inline. or it fails to trigger an inline
[19:56:48] <acrichto> strcat: what does -fcheck-stack in gcc do? I thought it was a funciton call on functions of stack size > 4K and nothing otherwise?
[19:57:05] <strcat> acrichto: it touches uninitialized pages
[19:57:11] <strcat> if necessary
[19:57:15] <acrichto> strcat: how so?
[19:57:17] <cmr> acrichto: http://gcc.gnu.org/onlinedocs/gccint/Stack-Checking.html
[19:57:17] <strcat> I don't think it needs a function call
[19:57:24] <strcat> acrichto: as in near the end, it injects a write per page
[19:57:30] <strcat> acrichto: if they aren't already written to
[19:57:46] <acrichto> strcat: but this is no extra overhead for small functions?
[19:58:00] <strcat> acrichto: no overhead if they don't have sections of uninit memory larger than a page
[19:58:08] <strcat> well, as large as a page
[19:58:27] <strcat> and you can set 2 guard pages and have it only output checks once every 2 pages
[19:58:28] <acrichto> hm, that's what I'm worried about, I don't think we can do that becauase that'd be a theoretical unwinding at all instructions
[19:58:50] <acrichto> by having all the stack touching at the top of the function we know the exact location it could unwind
[19:59:18] <strcat> acrichto: it won't unwind, it will cause a memory fault
[19:59:30] <acrichto> indeed, but we want it to trigger an unwind
[19:59:38] <strcat> I don't think you can do that
[19:59:40] <acrichto> in the "ideal world" we don't want a fault
[19:59:45] <acrichto> why not?
[19:59:50] <strcat> via a guard page, I don't see how
[19:59:58] <acrichto> you trigger a fault
[20:00:03] <eddyb> acrichto: turns out my blind feature code compiles. let's see if the tests pass
[20:00:05] *** Quits: cgaebel (clark@ADA4DDE2.290DF317.EE6E63A5.IP) (Ping timeout)
[20:00:06] <strcat> acrichto: so the C code triggers a fault
[20:00:06] <acrichto> and from the fault handler you go back to the stack and throw an exception
[20:00:07] <strcat> what do you do?
[20:00:11] <strcat> free can recurse pretty deep
[20:00:15] <strcat> we call free everywhere
[20:00:19] <acrichto> this is tough, but it can be done
[20:00:25] <strcat> acrichto: how do you deal with unwinding in C?
[20:00:32] <acrichto> in the worst-case world we could set a global flag on the FFI boundary
[20:00:35] <strcat> it won't clean up or uphold invariants
[20:00:41] <strcat> acrichto: but there is nothing special about FFI
[20:00:46] <acrichto> we could be more clever though, we'll have to look at dwarf info
[20:00:47] *** Joins: cgaebel (clark@ADA4DDE2.290DF317.EE6E63A5.IP)
[20:00:56] <strcat> acrichto: you are just as likely to hit the end of the stack (if not more likely, because they're leaves) in FFI
[20:01:05] <strcat> the C code won't have landing pads
[20:01:15] <acrichto> yes, and that will always abort
[20:01:17] <strcat> you can't unwind through arbitrary C without leaking resources and breaking invariants
[20:01:20] <strcat> acrichto: so what is the point?
[20:01:34] <acrichto> stack overflow in urst code shouldn't abort
[20:01:42] <strcat> acrichto: rust uses lots of native libs
[20:01:44] <strcat> ~T uses C
[20:01:47] <cmr> What are the use cases for recovering from overflow?
[20:01:49] <strcat> 5.0 % 5.0 uses C
[20:01:53] <acrichto> that doesn't mean we should throw rust undre the bust
[20:01:55] <acrichto> bus*
[20:01:56] <strcat> 1 / 2 uses C on 64-bit
[20:02:03] <strcat> acrichto: rust code compiles to calls to C code
[20:02:10] <acrichto> think of a stack overflow in something like servo
[20:02:11] <strcat> it calls memcpy, memset, fmod
[20:02:14] <acrichto> do you want to abort the whole browser?
[20:02:27] <strcat> acrichto: so, servo approaches the end of the stack
[20:02:30] <strcat> there are 200 bytes left
[20:02:31] <strcat> it calls free
[20:02:33] <strcat> it aborts
[20:02:41] <strcat> whether or not you do something different in rust code, it will still abort
[20:02:53] <acrichto> not if there's rust code at the end of the stack
[20:03:38] <acrichto> basically, the function prologue is highly dependent on whether we want to support unwinding on overflow or not
[20:03:49] <acrichto> right now the general opinion is "yes at some point"
[20:03:54] <strcat> we can't supporting unwinding on overflow
[20:03:59] <strcat> all you're saying is 'sometimes it will unwind'
[20:04:02] <strcat> but sometimes it won't
[20:04:12] <strcat> and rust calls a lot of C, so "won't" will be very common
[20:04:17] <strcat> how will you explain it?
[20:04:26] <strcat> it becomes semantically relevant whether or not code calls into C
[20:04:28] <acrichto> these are problems to hash out and carefully think about, not a decision that can be made in a second saying "oh well C breaks everything"
[20:04:37] <strcat> not just C
[20:04:47] <acrichto> it may very well be true that this isn't that useful, but thi si something to hink about
[20:04:55] <eddyb> acrichto: oops, I forgot to remove the self.expect(&token::COLON); line
[20:05:00] *** Joins: jensnockert (jensnocker@moz-7DC16A5F.afb.bredband2.com)
[20:05:03] <acrichto> eddyb: ah so close :(
[20:05:12] <strcat> acrichto: if all code can unwind, then there's not much you can safely call
[20:05:23] <strcat> let x = malloc(); 5.5 % 5.5
[20:05:23] <strcat> buggy
[20:05:45] <acrichto> strcat: remember, this is something to *think about*, halting all development because of a problem is not very productive
[20:05:56] <strcat> 'not about halting all development'
[20:06:02] <strcat> you're the one saying we can't use -fcheck-stack
[20:06:08] <strcat> that's halting development
[20:06:28] <acrichto> I'm saying we shouldn't blindly go towards it, we need to seriously consider the case on unwinding on overflow
[20:06:39] <acrichto> I'm not saying we shouldn't go to it at all, we need to agree that unwinding isn't the right strategy
[20:06:50] <strcat> we abort today so using a lighter solution that also aborts is an improvement
[20:06:53] <strcat> and doesn't make it harder to unwind
[20:07:01] <acrichto> you're saying there's no argument, you have internally made a decision and are incredulous that there's no official agreement with you
[20:07:07] <strcat> the hardest part about unwinding will be no longer calling any C code
[20:07:37] <cmr> So the way I see it there are three major usecases: 1. full static analysis of stack size, no possible overflow, 2. want to recover from overflow, 3. don't want to handle overflow
[20:07:51] <strcat> static analysis doesn't really work outside of special cases
[20:07:54] <cmr> I know
[20:08:01] <cmr> For #2 your well-trodden-path is growable, segmented stacks.
[20:08:14] <strcat> closures, trait objects, (mutual) recursion, etc.
[20:08:16] <cmr> with stack checking and all the nasty C stack stuff.
[20:08:18] <strcat> cmr: segmented stacks abort on OOM
[20:08:29] <cmr> strcat: OOM can't be handled anyway
[20:08:43] <cmr> overflow != oom though
[20:09:13] <cmr> so Servo could say "give me a 16MiB stack, but when I get to within 16K of the end, kill this task"
[20:09:18] *** Quits: cgaebel (clark@ADA4DDE2.290DF317.EE6E63A5.IP) (Ping timeout)
[20:09:30] <strcat> cmr: not if it calls native libs
[20:09:43] *** Joins: cgaebel (clark@ADA4DDE2.290DF317.EE6E63A5.IP)
[20:09:46] <strcat> free can easily explode that stack
[20:09:54] <strcat> if you allocate a lot of memory in other tasks
[20:10:14] <cmr> sure.
[20:10:28] <strcat> so it still needs a guard page, and it's going to abort when it hits it
[20:10:32] <cmr> so it could say, instead, 512K, or however much proves useful in practice.
[20:10:34] <cmr> Yes, I agree.
[20:10:54] <cmr> But the possibility of graceful recovery is all that's needed for such a "soft-reliable" system.
[20:11:08] <strcat> but it's only a possibility
[20:11:15] <strcat> and there are native calls all over
[20:11:21] <strcat> the native calls are usually leaves
[20:11:27] <strcat> destructor calls are usually native calls
[20:11:43] <strcat> destructors get called at the end of the function, so in many cases they are the deepest point
[20:11:57] <cmr> yes, I don't disagree with that
[20:12:16] <strcat> unless you've got a function that's pure rust and doesn't use any C (no floating point, no 64-bit ints, etc. as these can call into compiler-rt/libc)
[20:12:18] <cmr> but any possibility at all, especially one that can be tuned from tests, is better than none, no?
[20:12:24] <strcat> and doesn't use any big struct copies
[20:12:33] <strcat> cmr: no, I don't think so
[20:13:02] <strcat> is a rare race condition better than a common one?
[20:13:10] <strcat> the common one is far easier to diagnose and fix
[20:13:29] <strcat> hiding issues in many cases is worse than always exposing them, imo
[20:13:39] <cmr> aborts are fer less insidious than race conditions, but I take your point.
[20:13:49] <strcat> you shouldn't have to worry about an ~T going out of scope changing the stack overflow behaviour
[20:13:52] <cmr> I agree, personally I don't think I'd ever want to be using unwind-on-overflow.
[20:14:05] <cmr> especially given the nasty signal handling magic it entails
[20:14:21] <strcat> if you depend on unwind-on-stack-overflow, and programs will depend on it if it's offered as a feature, then you need to audit the code for native calls
[20:14:31] <strcat> and you need to be aware that lots of pure rust exprs can compile to native calls
[20:16:26] <strcat> acrichto: btw we actually need compiler-rt for 64-bit checked multiplication on 32-bit
[20:16:35] <cmr> we also need it for asan
[20:16:38] <strcat> atm you get a missing symbol
[20:16:44] <strcat> cmr: gcc has asan
[20:16:58] <strcat> it's in a separate lib, but the LLVM one will probably be split too
[20:17:46] <acrichto> strcat: yeah we definitely need compiler-rt
[20:18:16] <strcat> compiler-rt is also faster but it's pretty irrelevant to x86_64
[20:18:26] <strcat> as on x86_64 you barely need anything from it
[20:20:16] <doener> eddyb: the -lower-expect pass breaks it
[20:20:29] <eddyb> doener: whaa?
[20:21:02] <eddyb> doener: that's... used in the slice access, for bound checks
[20:23:02] <eddyb> doener: I think its only purpose is to mark the failing case as cold
[20:23:53] <doener> eddyb: ok, looking at -print-after-all, I can see that the inliner _is_ already triggered twice. It "implicitly"(?) runs against after instcombine
[20:24:06] <doener> I guess the expectation overrules alwaysinline
[20:24:09] <doener> let me check the source
[20:24:35] <eddyb> so, what, it doesn't inline because of a cold branch? I guess that's sometimes useful
[20:26:03] *** Quits: cgaebel (clark@ADA4DDE2.290DF317.EE6E63A5.IP) (Ping timeout)
[20:26:30] *** Joins: cgaebel (clark@ADA4DDE2.290DF317.EE6E63A5.IP)
[20:27:16] *** Quits: tupshin_ (quassel@moz-E7B03838.c3-0.nyr-ubr1.nyr.ny.cable.rcn.com) (Client exited)
[20:28:06] <eddyb> acrichto: this is such a hack :( - Parser::looking_at_struct_literal
[20:28:26] *** Joins: lpy (lpy@B744D17C.B31F127E.E99F7FDB.IP)
[20:28:31] <eddyb> not sure if it's even required anymore, since we don't have records
[20:28:43] <acrichto> eddyb: oh yeah Eridius was mucking with that as well to support Foo { .. foo }
[20:30:29] *** Quits: lpy (lpy@B744D17C.B31F127E.E99F7FDB.IP) (Ping timeout)
[20:30:43] <eddyb> acrichto: I don't understand how ident { can mean anything other than a struct literal
[20:31:07] *** Quits: cgaebel (clark@ADA4DDE2.290DF317.EE6E63A5.IP) (Ping timeout)
[20:31:13] <cmr> do foo { ... }
[20:31:30] *** Joins: cgaebel (clark@ADA4DDE2.290DF317.EE6E63A5.IP)
[20:31:30] <acrichto> I'd think you'd be in a do-context at that point though
[20:31:34] <eddyb> do is gone
[20:31:35] <cmr> you would be yes
[20:31:36] <acrichto> oh we also remove do!
[20:31:47] <eddyb> so can I please remove yet another lookahead?
[20:31:51] <acrichto> eddyb: this is in an expression context?
[20:32:05] <eddyb> acrichto: yes. it doesn't eat the { if it doesn't think it's a structure
[20:32:10] <acrichto> eddyb: I would assume that any relevant lookahead cases are all tested, so I'd be fine with removing
[20:32:11] <eddyb> it's probably bad logic
[20:32:11] <cmr> eddyb: current state of the language doesn't explain the state of the parser :P
[20:32:26] <eddyb> cmr: this only makes sense with records
[20:33:01] <acrichto> eddyb: wait hm
[20:33:04] <acrichto> for x in bar { ... }
[20:33:12] <eddyb> pffft
[20:33:15] <acrichto> for x in bar { foo: baz } { ... }
[20:33:22] <eddyb> *sigh*
[20:33:23] <acrichto> that should be valid syntax
[20:33:34] <eddyb> {a, ... is not valid block syntax, right?
[20:33:40] <acrichto> lol
[20:33:45] <acrichto> oh, n
[20:33:46] <acrichto> no*
[20:35:53] <eddyb> acrichto: for x in bar { a } { b }
[20:36:09] <acrichto> that's terrifying
[20:36:16] <eddyb> I am going to require a trailing comma in that case, mkay?
[20:36:24] *** Joins: ghrust (ghrust@1E8607E8.6A2AE50.F3114085.IP)
[20:36:24] <ghrust> 01[13rust01] 15bors merged 06auto into 06master: 02http://git.io/hv1YVQ
[20:36:24] *** Parts: ghrust (ghrust@1E8607E8.6A2AE50.F3114085.IP) ()
[20:36:28] <acrichto> hmm
[20:36:39] <eddyb> (the conservative choice)
[20:36:39] <acrichto> seems a little bad
[20:37:14] <eddyb> acrichto: nobody is going to use the shorthand with one-field structs
[20:37:36] <eddyb> similar situation to (a,)
[20:37:49] <strcat> require CamelCase for types and snake_case for variables and it's solved
[20:37:55] <acrichto> eddyb: usability aside, language grammaer is a pretty serious issue
[20:38:18] <strcat> and as a bonus
[20:38:20] <strcat> Foo(1, 2)
[20:38:22] <doener> eddyb: https://gist.github.com/dotdash/8f6e1d87c912d845901b
[20:38:23] <strcat> no longer has to be a function
[20:38:27] <strcat> like Some(5)
[20:38:30] <strcat> that's really, really weird.
[20:38:41] <strcat> maybe I'm alone in thinking that's a horrific language wart
[20:38:43] <strcat> ;p
[20:39:06] <eddyb> strcat: it is making some things harder to optimize
[20:39:08] <doener> eddyb: without -lower-expect, it runs all passes twice
[20:39:31] <acrichto> eddyb: for x in a { b } <- is 'a' an iterator object or is 'a { b }' the iterator?
[20:39:49] <eddyb> acrichto: a, like today
[20:40:08] <acrichto> that's b/c struct construction requires colons on fields
[20:40:55] <eddyb> doener: how... does that make sense?
[20:41:00] <strcat> 15:38:56       strcat | require CamelCase for types and snake_case for variables and it's solved
[20:41:01] <strcat> ;p
[20:41:12] <doener> eddyb: if I knew...
[20:41:21] *** Joins: ghrust (ghrust@24260B07.6A2AE50.F3114085.IP)
[20:41:21] <ghrust> 01[13rust01] 15bors pushed 19 new commits to 06auto: 02http://git.io/RIDucg
[20:41:21] <ghrust> 13rust/06auto 14754393a 15Alex Crichton: std: Remove io::io_error...
[20:41:21] <ghrust> 13rust/06auto 14864cf5b 15Alex Crichton: extra: Remove io_error usage
[20:41:21] <ghrust> 13rust/06auto 14fdf737a 15Alex Crichton: syntax: Remove io_error usage
[20:41:23] *** Parts: ghrust (ghrust@24260B07.6A2AE50.F3114085.IP) ()
[20:41:29] <strcat> like haskell
[20:41:30] <doener> eddyb: but we're using expect incorrectly AFAICT. Let's see what happens if I fix that
[20:41:45] * strcat will bug pcwalton about it later
[20:42:14] <doener> eddyb: then all is fine
[20:42:19] <strcat> eddyb: it can't be generic
[20:42:22] <strcat> eddyb: free
[20:42:22] <eddyb> doener: hmm?
[20:42:29] <strcat> eddyb: it calls it on things that aren't types
[20:42:49] <eddyb> strcat: wait, what?
[20:42:54] <strcat> eddyb: the proc environment
[20:42:55] * eddyb is confused
[20:42:58] <doener> eddyb: lower expect has strict rules on how it is used. br on icmp-ne using retval of expect. 
[20:43:10] <strcat> eddyb: the proc environment has a known size but it doesn't really have a real type
[20:43:24] <eddyb> strcat: it has an erased tuple type
[20:43:32] <eddyb> strcat: for which the drop glue is generated
[20:43:35] <doener> eddyb: we're doing "br on retval of expect, which is called on the result of icmp"
[20:44:00] <eddyb> strcat: you know about this?
[20:44:11] <eddyb> strcat: the expect nonsense, that is?
[20:44:17] <strcat> it's not nonsense
[20:44:34] <strcat> I added it to bounds checks back when rust wasn't marking fail_bounds_check as noreturn
[20:44:44] <strcat> maybe now it can be removed
[20:44:48] <strcat> but it doesn't really hurt 
[20:44:57] <eddyb> feel free to enlighten me because I'm seeing otherwise-unrelated things fighting in optimizations
[20:45:05] <doener> strcat: it just needs to be fixed :-p
[20:45:09] <strcat> lower-expect is the simplest pass ever
[20:45:11] <eddyb> strcat: how can it halve the optimizations?
[20:45:19] <strcat> what do you mean 'halve' the optimizations
[20:45:22] <eddyb> strcat: like, what is going on here? https://gist.github.com/dotdash/8f6e1d87c912d845901b
[20:45:25] <strcat> the optimization passes are supposed to run once
[20:45:29] <strcat> eddyb: the first case looks like a bug.
[20:45:42] <strcat> eddyb: well
[20:45:44] <strcat> actually no
[20:45:48] <strcat> in one case
[20:45:51] <strcat> you're running function passes
[20:45:58] <strcat> in the 2nd case you're not running function passes
[20:46:04] <strcat> why? because you specified a function pass yourself
[20:46:09] <strcat> this isn't a problem in librustc
[20:46:33] <strcat> use -debug-pass=Structure
[20:46:49] <doener> eddyb, strcat: https://gist.github.com/dotdash/b905ba663af510aa4ee8
[20:46:50] <eddyb> so we still don't know... anything, really *sigh*
[20:47:17] <strcat> doener: dunno what you mean by 'correct'
[20:47:35] <doener> strcat: correct = the way that the lower expect pass wants it
[20:47:39] <strcat> doener: LLVM bug
[20:47:44] <strcat> doener: early-cse will remove that icmp
[20:47:50] <strcat> doener: lower-expect runs after early-cse
[20:47:53] <strcat> so it accomplishes nothing
[20:48:04] <strcat> http://llvm-reviews.chandlerc.com/D2034
[20:48:10] <strcat> feel free to kick someone until they merge this
[20:48:36] <strcat> zDaniel Micay danielmicay@gmail.com
[20:48:37] <strcat>  
[20:48:39] <strcat> Jan 23 (10 days ago)
[20:48:41] <strcat>   
[20:48:43] <strcat> to Nick, reviews+D2034+., Kuba, Chandler, David, llvm-commits
[20:48:45] <strcat> another ping, ready to be merged (I don't have commit access)
[20:48:54] <strcat> I pinged it a dozen times
[20:48:57] <strcat> no one cares.
[20:49:55] <strcat> at this point it should probably just be removed as it's not doing anything, I never expected it to take so long to get an LLVM patch merged ;s
[20:50:11] <cmr> seriously, that's ridiculous
[20:51:09] <strcat> I guess I need to bug a specific person
[20:51:12] <strcat> rather than pinging it
[20:51:13] *** Quits: eddyb (eddy@832D2DE5.66315F97.FB866788.IP) (Ping timeout)
[20:51:22] <strcat> also not all of the discussion is on that bug
[20:51:27] <doener> strcat: sorry, I didn't mean to offend you.
[20:51:31] <strcat> doener: you didn't offend me
[20:51:44] <strcat> I am mad at the LLVM committers, not you :P
[20:52:04] <strcat> doener: don't mean to appear mad at you, just frustrated about this :(
[20:52:18] <strcat> I added that expect and submitted the LLVM thing at the same time
[20:52:29] <strcat> rust thing was r+'ed in maybe 15 mins
[20:52:32] <strcat> then merged in a few hours
[20:52:35] <strcat> LLVM part? *sigh*
[20:53:52] <strcat> I am not really enthusiastic about teaching LLVM about a nonnull attribute or anything else now
[20:54:05] <strcat> even though it's a lot more likely that would be merged quickly
[20:54:08] <strcat> since it helps clang.
[20:58:56] <strcat> ugh.
[21:00:07] <strcat> eddyb[pc]: why the weird suffix? :P
[21:00:48] <acrichto> argh the snap didn't pass
[21:01:03] <acrichto> strcat: do you remember the name of the debuginfo test that failed when you disabled frame pointer elimination?
[21:01:10] <acrichto> or rather you enabled it
[21:01:15] <acrichto> was it function-arg-initialization ?
[21:01:19] <strcat> acrichto: uh the one with no-split-stack
[21:01:37] <acrichto> hm different one then
[21:01:48] <strcat> which is why I special-cased it to not do it when debug info is enabled
[21:01:51] <strcat> which is sad.
[21:02:01] <strcat> it may be an LLVM bug
[21:02:03] <acrichto> http://buildbot.rust-lang.org/builders/snap3-linux/builds/619/steps/test/logs/stdio
[21:02:06] <strcat> I found similar issues for clang
[21:02:33] <strcat> acrichto: maybe gdb is out-of-date
[21:02:54] <strcat> and on the auto bot it's newer
[21:02:55] <strcat> that's my guess
[21:03:06] <acrichto> hm, I don't think I can ssh into linux1b
[21:03:32] <strcat> acrichto: well actually it can't be fpelim
[21:03:36] <strcat> cause it's disabled when debuginfo is on
[21:03:47] * strcat shrugs
[21:04:02] <acrichto> GNU gdb (GDB) Red Hat Enterprise Linux (7.2-50.el6)
[21:04:15] <acrichto> GNU gdb (Ubuntu/Linaro 7.4-2012.04-0ubuntu2) 7.4-2012.04
[21:04:16] <strcat> yikes.
[21:04:25] <strcat> that's also yikes :(
[21:04:27] <acrichto> first is the snap bot (I think)
[21:04:31] <acrichto> second is the linux1 builder
[21:06:35] <acrichto> it looks like the path is wrong I think
[21:06:40] <doener> eddyb[pc]: crap, I messed up when I added the extra icmp... It's "ne true" instead of "ne false", so it always went to the bounds failure and dropped the call only because of that
[21:06:43] <acrichto> oh wait no it's good...
[21:07:57] *** Quits: eddyb[pc] (eddyb@832D2DE5.66315F97.FB866788.IP) (Quit: Konversation terminated!)
[21:08:06] <strcat> doener: oh I thought you found the issue where it doesn't emit the branch metadata node
[21:08:25] <strcat> doener: because atm lower-expect only matches the pattern of expect followed by icmp followed by the branch
[21:08:29] <strcat> because clang only has 32-bit/64-bit expect
[21:08:34] <strcat> so it needs to use icmp as a 'cast'
[21:13:37] *** Quits: new_one (new_one@6F9548B7.4BFECEA2.B3C0173E.IP) (Ping timeout)
[21:13:50] <doener> ok, so if we have a call to expect but we don't run lower-expect, for some reason the "inline sroa instcombine" cycle is run twice.
[21:14:15] <doener> if I add lower-expect _or_ remove the call to expect, that doesn't happen and the call to Foo::foo isn't remove
[21:15:33] *** Quits: Kxepal (Miranda@moz-1A176845.pppoe.mtu-net.ru) (Quit: Kxepal)
[21:15:43] <doener> or put differently, I've spent the better part of a day fooling myself
[21:15:56] *** Joins: Kxepal (Miranda@moz-1A176845.pppoe.mtu-net.ru)
[21:16:13] <strcat> doener: it's run twice because half is from function passes and half is from module passes
[21:16:23] <strcat> doener: look at -debug-pass=Structure
[21:16:46] <strcat> doener: I don't know why it's done that way, but I do know why lower-expect is causing it
[21:16:51] <strcat> and this isn't an issue for librustc
[21:16:56] <doener> strcat: why is it not run twice when I add -lower-expect or remove the call to expect?
[21:16:58] <strcat> it's just opt being opt
[21:17:09] <strcat> doener: because lower-expect is overriding the function passes
[21:17:16] <strcat> opt doesn't do the same thing clang/librustc do
[21:17:17] <strcat> it's weird
[21:17:24] <strcat> I recommend using clang instead of opt
[21:17:41] <strcat> clang can take bytecode as input
[21:17:48] <strcat> and you can -S -emit-llvm
[21:17:59] <strcat> and -mllvm to pass stuff to LLVM like setting inline threshold
[21:18:05] <strcat> but unlike opt it makes sense to me...
[21:20:48] *** Joins: new_one (new_one@6F9548B7.4BFECEA2.B3C0173E.IP)
[21:21:09] *** Joins: yuriks (yuriks@FAC97ED5.A9CCF389.F3163DCD.IP)
[21:21:26] *** Quits: canhtak (canhtak@moz-8A625E1D.wl.t.ulaval.ca) (Quit: canhtak)
[21:21:31] *** Joins: ghrust (ghrust@9C8B94D4.6A2AE50.F3114085.IP)
[21:21:31] <ghrust> 01[13rust01] 15bors 04force-pushed 06auto from 14a325f73 to 148d7bd49: 02http://git.io/N3iJvQ
[21:21:31] *** Parts: ghrust (ghrust@9C8B94D4.6A2AE50.F3114085.IP) ()
[21:21:34] *** Joins: ghrust (ghrust@79968228.6A2AE50.F3114085.IP)
[21:21:34] <ghrust> 01[13rust01] 15bors pushed 5 new commits to 06auto: 02http://git.io/WU4SLg
[21:21:34] <ghrust> 13rust/06auto 145baee9d 15Jeff Olson: pull extra::{serialize, ebml} into a separate libserialize crate...
[21:21:34] <ghrust> 13rust/06auto 1499a617c 15Jeff Olson: extra: inline extra::serialize stub
[21:21:34] <ghrust> 13rust/06auto 1423b58f6 15Jeff Olson: fix stuff clobbered in rebase + don't reexport serialize::serialize
[21:21:37] *** Parts: ghrust (ghrust@79968228.6A2AE50.F3114085.IP) ()
[21:21:50] *** Quits: blank_name (blank_name@75624DB1.E6D3F868.537E532E.IP) (Ping timeout)
[21:29:12] *** Joins: lpy (lpy@B744D17C.B31F127E.E99F7FDB.IP)
[21:30:32] *** Quits: aurynj (Eon@583ABBE5.60FA2E28.B9E25744.IP) (Ping timeout)
[21:31:08] *** Quits: lpy (lpy@B744D17C.B31F127E.E99F7FDB.IP) (Ping timeout)
[21:31:10] *** Joins: lpy_ (lpy@B744D17C.B31F127E.E99F7FDB.IP)
[21:32:51] *** Quits: lpy_ (lpy@B744D17C.B31F127E.E99F7FDB.IP) (Ping timeout)
[21:36:26] *** Joins: ghrust (ghrust@79968228.6A2AE50.F3114085.IP)
[21:36:26] <ghrust> 01[13rust01] 15bors pushed 2 new commits to 06auto: 02http://git.io/_mzN9w
[21:36:26] <ghrust> 13rust/06auto 14abc8372 15Ben Harris: Disable ARM ehabi when building without landing pads
[21:36:26] <ghrust> 13rust/06auto 1487c3ab1 15bors: auto merge of #11992 : bharrisau/rust/arm-no-landing, r=alexcrichton...
[21:36:26] *** Parts: ghrust (ghrust@79968228.6A2AE50.F3114085.IP) ()
[21:36:29] *** Joins: ghrust (ghrust@24260B07.6A2AE50.F3114085.IP)
[21:36:29] <ghrust> 01[13rust01] 15bors 04force-pushed 06auto from 14bbe9b8c to 148d7bd49: 02http://git.io/N3iJvQ
[21:36:29] *** Parts: ghrust (ghrust@24260B07.6A2AE50.F3114085.IP) ()
[21:47:25] *** Joins: blank_name (blank_name@75624DB1.E6D3F868.537E532E.IP)
[21:48:10] *** Quits: erickt (etryzelaar@8C9ECD8F.3A598286.F12515B4.IP) (Ping timeout)
[21:50:30] *** Quits: dbaupp (Thunderbir@moz-68C83524.lns20.syd6.internode.on.net) (Ping timeout)
[21:54:09] *** Quits: strcat (strcat@moz-54F7FD49.cpe.net.cable.rogers.com) (Quit: WeeChat 0.4.2)
[21:59:29] *** Quits: new_one (new_one@6F9548B7.4BFECEA2.B3C0173E.IP) (Ping timeout)
[21:59:45] *** Joins: strcat (strcat@moz-54F7FD49.cpe.net.cable.rogers.com)
[22:01:55] *** Joins: TheHydroImpulse (TheHydroIm@moz-A9FB1B83.ed.shawcable.net)
[22:03:49] *** Joins: new_one (new_one@6F9548B7.4BFECEA2.B3C0173E.IP)
[22:04:42] *** Quits: blank_name (blank_name@75624DB1.E6D3F868.537E532E.IP) (Ping timeout)
[22:08:07] *** Joins: blank_name (blank_name@75624DB1.E6D3F868.537E532E.IP)
[22:10:05] *** Quits: blank_name (blank_name@75624DB1.E6D3F868.537E532E.IP) (Ping timeout)
[22:12:04] *** Quits: strcat (strcat@moz-54F7FD49.cpe.net.cable.rogers.com) (Quit: WeeChat 0.4.2)
[22:20:00] *** Joins: erickt (Adium@49C4075F.3AC15C18.2321E71E.IP)
[22:30:38] <flaper87> after this test, we can consider `extern mod extra;` gone!
[22:30:40] *** Joins: kaeso (kaeso@moz-F21FF626.unstable.it)
[22:30:56] <flaper87> well, at least in my working copy :D
[22:31:54] *** Joins: lpy (lpy@B744D17C.B31F127E.E99F7FDB.IP)
[22:32:00] <flaper87> and AFAIU, it'll be necessary to push a new snapshot of stage0 before we can completely remove all the `extern mod` usage.
[22:32:41] <flaper87> at least `extern crate` works now and I took the chance and refactored that part of the parser.
[22:33:41] *** Quits: lpy (lpy@B744D17C.B31F127E.E99F7FDB.IP) (Ping timeout)
[22:35:44] <flaper87> when is the "an ABI may bot be specified here" error is supposed to be raised?
[22:38:58] *** Quits: TheHydroImpulse (TheHydroIm@moz-A9FB1B83.ed.shawcable.net) (Connection reset by peer)
[22:40:28] *** Joins: TheHydroImpulse (TheHydroIm@moz-A9FB1B83.ed.shawcable.net)
[22:40:55] <flaper87> not*
[22:45:54] *** Joins: blank_name (blank_name@75624DB1.E6D3F868.537E532E.IP)
[22:48:45] *** nrc is now known as nrc|afk
[22:55:39] *** Quits: erickt (Adium@49C4075F.3AC15C18.2321E71E.IP) (Quit: Leaving.)
[22:57:56] *** Quits: TheHydroImpulse (TheHydroIm@moz-A9FB1B83.ed.shawcable.net) (Quit: TheHydroImpulse)
[23:00:22] *** Quits: NiccosSystem (NiccosSyst@AB1AFDE.FC7B0C35.A7597CB6.IP) (Ping timeout)
[23:02:13] *** Joins: erickt (Adium@49C4075F.3AC15C18.2321E71E.IP)
[23:05:49] *** Joins: dbaupp (Thunderbir@2702835C.D5A1DCF.37681C44.IP)
[23:18:05] *** Quits: doener (doener@moz-C68F600D.unity-media.net) (Quit: leaving)
[23:21:24] *** Joins: jdm (jdm@moz-4AA3652E.cable.virginm.net)
[23:21:38] *** Quits: dherman (dherman@moz-6CA476B1.hsd1.ca.comcast.net) (Quit: dherman)
[23:24:53] *** Quits: erickt (Adium@49C4075F.3AC15C18.2321E71E.IP) (Quit: Leaving.)
[23:24:59] *** flaper87 is now known as flaper87|afk
[23:28:06] *** Joins: erickt (Adium@49C4075F.3AC15C18.2321E71E.IP)
[23:28:47] *** Joins: dherman (dherman@moz-6CA476B1.hsd1.ca.comcast.net)
[23:28:47] *** ChanServ sets mode: +ao dherman dherman
[23:30:30] *** Quits: dbaupp (Thunderbir@2702835C.D5A1DCF.37681C44.IP) (Ping timeout)
[23:32:39] *** Joins: lpy (lpy@B744D17C.B31F127E.E99F7FDB.IP)
[23:34:22] *** Quits: lpy (lpy@B744D17C.B31F127E.E99F7FDB.IP) (Ping timeout)
[23:40:51] *** Quits: dherman (dherman@moz-6CA476B1.hsd1.ca.comcast.net) (Quit: dherman)
[23:42:11] *** Quits: erickt (Adium@49C4075F.3AC15C18.2321E71E.IP) (Quit: Leaving.)
[23:44:28] *** Joins: canhtak (canhtak@moz-945C7B49.wl.t.ulaval.ca)
[23:56:29] *** Joins: ghrust (ghrust@2EE61FCC.6A2AE50.F3114085.IP)
[23:56:29] <ghrust> 01[13rust01] 15bors pushed 2 new commits to 06auto: 02http://git.io/7qpPrQ
[23:56:29] <ghrust> 13rust/06auto 1451260f6 15xales: Move term, terminfo out of extra....
[23:56:29] <ghrust> 13rust/06auto 14449a99e 15bors: auto merge of #11945 : xales/rust/libextra, r=huonw...
[23:56:29] *** Parts: ghrust (ghrust@2EE61FCC.6A2AE50.F3114085.IP) ()

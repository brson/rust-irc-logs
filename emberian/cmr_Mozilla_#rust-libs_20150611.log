[00:05:50] *** Quits: aatch (james@moz-is4j4r.cable.telstraclear.net) (Ping timeout: 121 seconds)
[00:46:08] *** Joins: aatch (james@moz-c6etfk.fosn.r6an.e000.2406.IP)
[01:31:13] *** kimundi is now known as zz_kimundi
[01:51:57] *** Quits: bluss (bluss@moz-ec5o68.cust.bredbandsbolaget.se) (Ping timeout: 121 seconds)
[02:20:38] *** Quits: brson (brson@moz-cfhap5.mtv2.mozilla.com) (Quit: leaving)
[02:54:24] *** Quits: zz_kimundi (kimundi@moz-ktmie3.dip0.t-ipconnect.de) (Ping timeout: 121 seconds)
[02:56:42] *** Joins: zz_kimundi (kimundi@moz-o5192b.dip0.t-ipconnect.de)
[02:56:44] *** zz_kimundi is now known as kimundi
[03:15:36] *** Quits: Tobba (Tobba@moz-o13d22.bredband.telia.com) (Ping timeout: 121 seconds)
[03:45:05] <Gankro> acrichto: Is there any problem with having shortread occur only on EOF?
[03:45:18] <Gankro> It seems like it's not lossy in that case
[03:46:01] <Gankro> Like you still lose data if you get another Err
[03:46:05] <Gankro> Maybe that's fine
[03:53:13] <Gankro> eh they really should just use read...
[06:00:15] *** Quits: kimundi (kimundi@moz-o5192b.dip0.t-ipconnect.de) (Ping timeout: 121 seconds)
[06:02:17] *** Joins: zz_kimundi (kimundi@moz-o5192b.dip0.t-ipconnect.de)
[06:02:20] *** zz_kimundi is now known as kimundi
[06:24:02] <acrichto> Gankro: yeah that's the lossy case (losing how much you read on a different Err)
[06:32:22] <Gankro> Anyone have any strong feelings on removing the weak ptr stuff from Rc and Arc? I feel like supporting it is the wrong default.
[06:32:53] <Gankro> Particularly since it's fundamentally racy for Arc and some useful functions
[06:35:06] <sfackler> in what way is it fundamentally racy beyond the current implementations of make_unique &co?
[06:35:39] <Gankro> sfackler: Can make_unique be made non-racy?
[06:36:27] <sfackler> I'm not convinced it can't
[06:37:57] <acrichto> sfackler: currently with two separate counts for strong/weak it's impossible to atomically check to see if a pointer is a unique pointer
[06:38:15] <acrichto> e.g. you can't actually answer the question "am I unique"
[06:38:34] <acrichto> Gankro: there was an idea to combine the two counts into one 64-bit pointer
[06:38:37] <acrichto> e.g. two 32-bit counts
[06:38:41] <acrichto> which... may work out?
[06:38:58] <acrichto> I do think, though, that weak pointers aren't pulling their weight with Arc
[06:39:40] <sfackler> (weak+strong, strong) was another possibility iirc
[06:39:43] <Gankro> Also there's nothing keeping weak variants out of Cargo (modulo alloc being unstable)
[06:40:10] <sfackler> (I also don't use either of the Weak apis so I don't feel too strongly)
[06:40:42] <acrichto> sfackler: hm I think (weak+strong, strong) had a problem
[06:40:48] <acrichto> although now I forget what I convinced myself of
[06:42:06] <sfackler> double wide atomics aren't universally available, right?
[06:42:43] <acrichto> I wouldn't bet on it
[06:42:52] <acrichto> but I also haven't researched much
[06:43:32] <sfackler> if we wanted we could probably also have a fast implementation on platforms with double wide atomic ops and a crappy fallback that spins or whatever for platforms that don't
[06:43:45] <sfackler> depending on what the breakdown of support is
[06:44:46] <Gankro> RFC or PR?
[06:45:24] <sfackler> might want an rfc
[06:45:39] <sfackler> there seems to be a decent set of people who feel strongly about weak support
[06:46:29] <sfackler> naming conventions question:
[06:47:09] *** Quits: aatch (james@moz-c6etfk.fosn.r6an.e000.2406.IP) (Quit: Leaving)
[06:47:28] <sfackler> rust-unix-socket has a UnixStream type that corresponds to a SOCK_STREAM socket, analagous to TcpStream
[06:47:40] <sfackler> I'd also like to support SOCK_DGRAM sockets
[06:47:53] <acrichto> UnixDatagram?
[06:48:28] <sfackler> right now I've added it via a UnixSocket type that looks like UdpSocket
[06:48:48] <sfackler> but yeah, UnixDatagram is a bit more descriptive, but kind of a weird name
[06:48:50] <sfackler> imo
[06:48:54] <acrichto> true
[06:48:56] <acrichto> unixgram
[06:49:02] <acrichto> muy bueno
[06:49:26] <sfackler> UnixStream and UnixSocket do seem too similar to sit in the same module potentially
[06:49:33] <sfackler> name-wise
[06:50:06] <acrichto> UnixSocket is also somewhat ambiguous as they're sometimes colloquially referred to as "unix sockts"
[06:50:09] <acrichto> (the stream ones)
[06:51:17] <sfackler> yeah
[07:26:51] *** Joins: simukis (nagisa@moz-8t068g.static.zebra.lt)
[07:30:34] <eternaleye> There's also SOCK_SEQPACKET
[07:30:52] <eternaleye> Which works on Unix domain sockets, and sometimes maps to SCTP
[07:35:31] <SimonSapin> impl DerefMut for String ? https://github.com/rust-lang/rfcs/issues/1157
[07:46:12] *** Quits: ChrisMorgan (ChrisMorgan@moz-g6osuq.tpgi.com.au) (Ping timeout: 121 seconds)
[08:39:26] *** Joins: bluss (bluss@moz-ec5o68.cust.bredbandsbolaget.se)
[08:44:53] *** Joins: gleb (gleb@moz-3u1drv.rusanovka-net.kiev.ua)
[10:32:15] *** Joins: ChrisMorgan (ChrisMorgan@moz-g6osuq.tpgi.com.au)
[10:42:23] *** Quits: stl (stl@moz-o95.t8r.15.176.IP) (Ping timeout: 121 seconds)
[10:48:21] *** Joins: stl (stl@moz-vot.hbd.15.176.IP)
[10:52:53] *** Quits: stl (stl@moz-vot.hbd.15.176.IP) (Ping timeout: 121 seconds)
[11:31:52] *** Joins: stl (stl@moz-sa1.66b.15.176.IP)
[12:24:27] *** Joins: Tobba (Tobba@moz-o13d22.bredband.telia.com)
[13:21:14] *** Quits: ChrisMorgan (ChrisMorgan@moz-g6osuq.tpgi.com.au) (Ping timeout: 121 seconds)
[13:34:55] *** Joins: ChrisMorgan (ChrisMorgan@moz-g6osuq.tpgi.com.au)
[15:50:20] *** Joins: Rym (uid91135@moz-n2i7qm.charlton.irccloud.com)
[18:14:16] <acrichto> Gankro: ah hm so to be clear, I'll stabilize or_insert/or_insert_with on VecMap's Entry
[18:14:25] <acrichto> Gankro: but the `get` method is still unstable everywhere
[18:14:37] <Gankro> acrichto: wat
[18:14:58] <Gankro> like OccupiedEntry::get?
[18:14:59] <acrichto> or is that supposed to also be stable?
[18:15:03] <acrichto> nah just Entry::get
[18:15:11] <acrichto> the one that returns Result
[18:15:15] <Gankro> Oh I thought we deprecated that
[18:15:23] <acrichto> welp
[18:15:24] <acrichto> I got this
[18:15:25] <acrichto> it's deprecated
[18:15:31] <Gankro> *boom*
[18:15:50] <Gankro> reason: or_insert is strictly better
[18:17:52] <bluss> yes the entry api is nice now
[18:22:57] *** Joins: brson (brson@moz-u3dg2t.sfo1.mozilla.com)
[18:22:58] *** ChanServ sets mode: +qo brson brson
[18:48:04] *** Quits: brson (brson@moz-u3dg2t.sfo1.mozilla.com) (Connection closed)
[20:29:49] *** Joins: brson (brson@moz-u3dg2t.sfo1.mozilla.com)
[20:29:50] *** ChanServ sets mode: +qo brson brson
[21:36:23] *** Quits: simukis (nagisa@moz-8t068g.static.zebra.lt) (Ping timeout: 121 seconds)
[21:56:00] <Gankro> SimonSapin: You're my goto string person, how do you feel about https://github.com/rust-lang/rfcs/pull/1152 ?
[22:12:46] <Gankro> aturon: acrichto: into_string is being proposed on str for symmetry with into_vec on slice. I really need, like, an FAQ for what our conversions roadmap is.
[22:13:14] <aturon> Gankro: OK. will write conventions RFC.
[22:13:17] <sfackler> don't we not want either of those? isn't into() sufficient?
[22:13:24] <aturon> sfackler: definitely no!
[22:13:26] <aturon> not*
[22:13:35] <sfackler> ?
[22:13:46] <aturon> that is, `into` is intended only for generic contexts
[22:13:54] <aturon> it has very poor ergonomics for ad hoc cases
[22:14:19] <aturon> e.g. since every type T: Into<T>,
[22:14:26] <sfackler> ah
[22:14:27] <aturon> you would always have to specify the target type explicitly
[22:14:42] <aturon> to some extent this was already spelled out on the RFC
[22:14:44] <aturon> lemme look it up
[22:14:45] <bluss> aturon: maybe there's a better solution than adding ad hoc methods, nongenerically
[22:14:45] <Gankro> aturon: tldr; into_string = yes?
[22:15:03] <aturon> https://github.com/rust-lang/rfcs/blob/db410afdaeb0a3321c3ee22242bafc78b9861ad1/text/0000-conversion-traits.md#preliminary-conventions
[22:15:04] <bluss> aturon: we already have so many ways to convert between basic types..
[22:15:25] <aturon> Gankro: i'm not opposed to it. but in that particular case there's also to_owned :)
[22:15:40] <Gankro> Yeah
[22:15:41] <aturon> bluss: i'd love to hear it :)
[22:15:51] <Gankro> Honestly *I* prefer String::from("foo")
[22:16:13] <Gankro> .'s on litteralls freak me out
[22:16:18] <aturon> bluss: originally i was hoping the generic traits could kill off all ad hoc cases
[22:16:21] <Gankro> And it can be passed into `map`
[22:16:27] <aturon> but that didn't fly for a variety of reasons spelled out in the RFC
[22:16:54] <Gankro> aturon: It seems `from` solves the write-the-type problem in a non-pokey-way
[22:17:11] <bluss> from is very nice
[22:17:26] <aturon> Gankro: it doesn't chain well, though
[22:17:43] <aturon> and we still want things like .into_iter()
[22:17:55] <Gankro> aturon: Also it seems like to vs into is really all over the place?
[22:18:09] <aturon> Gankro: ?
[22:18:41] <aturon> actually i have to run :-/
[22:18:53] <aturon> but i will try to write out a revised version of the conventions 
[22:19:06] <aturon> (but take a look at the ones from the original RFC, i think they're not far off)
[22:21:54] <Gankro> aturon: into = cheap, to = expensive, right?
[22:23:00] <aturon> No, as is cheap, to is expensive, both of those borrow, into consumes
[22:23:48] <Gankro> aturon: to/into is meaningless for slices...
[22:24:59] <aturon> Yes. I would actually stick to 'to' for them. Not sure why into_vec
[22:25:22] <aturon> For the generic case things play out a bit differently
[22:25:48] <Gankro> Ohhh
[22:25:49] <Gankro> ughhh
[22:25:49] <aturon> Because you generally want the caller to decide
[22:26:01] <Gankro> we have to_vec for &[T] and into_vec for Box<[T]>
[22:26:14] <aturon> That makes more sense
[22:26:29] <aturon> Also don't forget deref
[22:26:55] <aturon> These methods will show up on types that deref to slices
[22:27:07] <Gankro> vec.to_vec ftw
[22:28:16] <aturon> Lol
[22:28:23] <Gankro> And yeah teh RFC is proposing for Box<str>
[22:28:31] * Gankro should read stuff more
[22:29:23] <aturon> Ok I am on board with that
[22:29:31] <Gankro> yeah
[22:39:12] <bluss> Gankro: I'm so silly
[22:39:19] <bluss> Gankro: https://github.com/bluss/bmap/blob/master/src/bmap.rs#L859-L878
[22:39:41] <bluss> Gankro: first I did line 859, yay 2% improvement, then line 878, 1% improvement
[22:39:57] <bluss> then realize algorithm is dumb (line 875) and 30 % improvement..
[22:40:03] <bluss> so much for ricing with unsafe blocks
[22:41:22] <Gankro> ricing?
[22:41:52] <bluss> http://funroll-loops.org/
[22:42:18] <Gankro> wait, why is backwards iteration faster?
[22:42:40] <bluss> because most of the time it's going to skip to the next leaf anyway
[22:42:49] <bluss> just that most of the time, the end of the iteration is not in this node
[22:42:52] <bluss> just that observation
[22:43:20] <sfackler> http://fun.irq.dk/funroll-loops.org/
[22:43:57] <Gankro> bluss: Sorry what is this method?
[22:44:11] <bluss> Gankro: sorry for tossing you in without context. Range iteration for btreemap
[22:44:37] <bluss> it looks at the last key of the current node, if that last key is smaller than then end bound, then we just go on
[22:44:45] <bluss> otherwise we need to find the end inside current node
[22:45:17] <bluss> I'm benching towards libstd BTreeMap and I see.. it looks like one of the latest nightlies has a regression in the libstd side
[22:45:29] <bluss> maybe llvm upgrade changed how it optimizes
[22:45:43] <Gankro> bluss: believable
[22:46:28] <bluss> lucky I have notes, I'll show you the difference
[22:48:24] <bluss> Gankro: https://gist.github.com/anonymous/da3b776fefe5b20a1619
[22:48:55] <bluss> that's a massive degradation in perf but only in BTreeMap, not my code
[22:50:09] *** Quits: gleb (gleb@moz-3u1drv.rusanovka-net.kiev.ua) (Ping timeout: 121 seconds)
[22:50:44] <bluss> but it's only measuring one thing, the iterator
[22:52:07] <Gankro> bluss: holy shit, 10x improvement
[22:53:01] <bluss> but only for small maps
[22:53:16] <bluss> then at 100_000 entries it's only 30% better
[22:53:35] <bluss> well it's a different impl entirely but same fanout
[22:54:04] <Gankro> bluss: Any particular thing giving The Big Win?
[22:54:47] <bluss> probably this https://github.com/bluss/bmap/blob/master/src/bmap.rs#L906-L917
[22:55:04] <bluss> i.e the common case in the iterator is just pick the next elt from the slice iterators
[22:56:45] <bluss> then using position indices and parent pointers in the nodes like we talked about
[22:57:02] <Gankro> What's the wins on non-iter stuff?
[22:57:43] <bluss> lookup has same performance and insertion 30% faster
[22:57:51] <Gankro> Sweet
[22:58:01] <Gankro> Plus nothing allocates except for making nodes now?
[22:58:22] <bluss> yes
[22:58:40] <Gankro> awesome
[22:59:12] <Gankro> Are you doing the sequential insertion optimization?
[22:59:22] <bluss> probably not
[22:59:26] <bluss> what's that?
[22:59:45] <Gankro> So you know that btrees are degenerately bad when you insert an ordered sequence, yeah?
[23:00:06] <bluss> I haven't thought about it :)
[23:00:33] <Gankro> You keep pushing on the end of a node, split it off, and then never touch the RHS again
[23:00:39] <Gankro> Basically makes ever node maximally empty
[23:00:46] <Gankro> err LHS
[23:00:47] <bluss> maybe I suck at that.. I never enabled the seq insert bench!
[23:01:22] <Gankro> Google's btree basically notices if this is happening via some heuristic and does an uneven split
[23:01:49] * bluss enables the bench
[23:03:32] <bluss> hm that makes sense
[23:03:39] <bluss> I'll look at my insertion algo
[23:04:46] <Gankro> bluss: https://code.google.com/p/cpp-btree/source/browse/btree.h#1552
[23:06:01] <bluss> ah I've been there, now I get why they do it
[23:07:46] <Gankro> It'd be interesting to see how much it penalizes the general case
[23:07:55] <Gankro> Probably not a lot since it's an expensive case in general
[23:08:19] <bluss> It will take a while for me to sort this out
[23:08:32] <bluss> This bmap code is mostly ported from a C impl I wrote
[23:08:46] <bluss> using preemptive splits
[23:08:54] <bluss> let's see if google does that
[23:13:22] <bluss> sigh, these benchmarks don't make sense :) need to go over them with black box
[23:13:27] <bluss> the insert seq
[23:13:56] * bluss sees that they do
[23:18:43] <Gankro> bluss: ? is it being no-op'd?
[23:19:01] <Gankro> bench is kinda problematic with insertion
[23:20:34] <bluss> I just misunderstood it
[23:20:42] <bluss> maybe you wrote these btreemap benches
[23:23:20] <bluss> this was a cool thing to play with. It looks like a win for sequences
[23:23:40] <bluss> but my hack is upsetting the balance and tripping minimum order invariant
[23:26:21] <bluss> Gankro: thanks for the tip about this. Pretty cool it's so localized, no global knowledge
[23:43:50] <Gankro> bluss: Yeah I've never been clear how this is compatible with minimum-size...
[23:44:11] <bluss> I've confirmed that the optimization exists
[23:44:17] <bluss> and it breaks all the other functionality
[23:44:30] <Gankro> haha
[23:44:53] <Gankro> gg google
[23:49:22] <Gankro> bluss: What do the wins look like (e.g. is it worth refactoring everything to support it)
[23:51:52] <bluss> 10-20% decrease in runtime for sequential insert bench
[23:52:30] <bluss> I think I read it right that google "split" by moving all elements to one side
[23:54:08] <Gankro> that matches my memory, yes
[23:54:47] <Gankro> I mean, litterally any unbalanced split breaks the B invariant
[23:56:26] <bluss> that's what I finally realized
[23:56:39] <bluss> which is why the remove code broke on any +/- bias
[23:57:44] * Gankro can't remember why the balance really matters
[23:58:07] <Gankro> beyond amortization arguments

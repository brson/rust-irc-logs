[00:00:01] <pcmattman> hm, http://hackage.haskell.org/package/llvm-0.7.0.1/docs/LLVM-FFI-Core.html has nice descriptions about each linkage type
[00:00:05] <devbug> pcmattman: yep
[00:00:14] <devbug> I don't think you can imagine all the use cases.
[00:02:51] <pcmattman> well, you can imagine the base set which would be most likely to be used, and then when somebody needs (and _actually_ needs, not just _thinks_ they need) some crazy low-level LLVM-specific linkage they can ask for it
[00:03:15] <pcmattman> dbaupp: I would be okay with a trial of DST up here, I don't really see what the fuss is - there's still 24 hours in the day?
[00:05:43] <dbaupp> pcmattman: I agree (on both those points)
[00:06:00] <dbaupp> we don't have to support everything if we don't have a usecase for some of them.
[00:06:46] <cmr> DST is obnoxious
[00:06:51] <cmr> Mostly just an inconvenience.
[00:08:14] * dbaupp doesn't understand the hate :'(
[00:09:59] <devbug> dbaupp: screw edision and his light bulbs
[00:19:15] *** kimundi is now known as zz_kimundi
[00:24:30] *** Quits: canhtak (jeremy@moz-44A7DE0.wl.t.ulaval.ca) (Quit: canhtak)
[00:31:53] *** Quits: rveach (kvirc@moz-7E54B3A2.hsd1.ca.comcast.net) (Quit: KVIrc 4.2.0 Equilibrium http://www.kvirc.net/)
[00:38:10] *** Quits: dbaupp (Thunderbir@moz-54ADD9F4.lns20.syd6.internode.on.net) (Quit: dbaupp)
[00:38:12] *** Joins: canhtak (jeremy@moz-44A7DE0.wl.t.ulaval.ca)
[00:49:30] *** Joins: dbaupp (Thunderbir@moz-54ADD9F4.lns20.syd6.internode.on.net)
[00:54:36] <eddyb> good night guys :D
[01:20:44] *** Quits: eddyb (eddy@3C6E2DBB.FFB4E060.A5830293.IP) (Quit: Konversation terminated!)
[01:21:00] *** Joins: eddyb (eddy@3C6E2DBB.FFB4E060.A5830293.IP)
[01:23:10] *** Quits: eddyb (eddy@3C6E2DBB.FFB4E060.A5830293.IP) (Ping timeout)
[01:45:40] <cmr> Does anyone have announcement for This Week in Rust?
[01:46:04] <strcat> rust-core exists? ;p
[01:46:13] * strcat hasn't done much with it yet though
[01:46:47] <strcat> will be more fun when it has hash tables, trees, and so on
[01:46:58] <dbaupp> and iterators
[01:47:28] <cmr> I'm thinking that std needs to be broken out from the runtime if we want a coherent multi-runtime story.
[01:47:39] <cmr> (along the lines of rust-core)
[01:47:49] <cmr> There are a bunch of tensions in that area, it's messy.
[01:48:43] <dbaupp> I have a feeling that the multi-runtime stuff won't be being pushed from the mozilla end very hard because it's not a requirement for servo
[01:48:46] <dbaupp> :(
[01:48:56] <cmr> It is a considerationg.
[01:49:16] <cmr> https://github.com/mozilla/rust/wiki/Meeting-planning-2013-01-08#10
[01:50:01] <dbaupp> cmr: ah! cool
[01:50:05] <dbaupp> (although that is fairly old now...)
[01:50:18] <cmr> Yes
[02:20:12] <devbug> "<dbaupp> and iterators" +1
[02:20:14] *** Quits: brson (brson@981AA104.E81F12CD.76F66111.IP) (Quit: leaving)
[02:21:17] *** Quits: zz_kimundi (kimundi@moz-D33AF750.dip0.t-ipconnect.de) (Ping timeout)
[02:24:48] *** Joins: zz_kimundi (kimundi@moz-F488EB60.dip0.t-ipconnect.de)
[02:24:49] *** zz_kimundi is now known as kimundi
[02:29:53] * strcat will get to that ;p
[02:30:42] <dbaupp> strcat: isn't it mostly just copy-paste? none of the adaptors use ~ or @ do they? (unless you want to change the design of course...)
[02:31:08] <strcat> dbaupp: yeah it's copy-paste + updating all the paths
[02:31:24] <strcat> but I'm doing some things differently
[02:31:26] <dbaupp> oh, paths
[02:32:04] <strcat> iterators don't use failure or allocation so they will be easy
[02:32:28] <strcat> dbaupp: kind of annoying that #[test] won't work ;\
[02:32:44] <dbaupp> strcat: oh
[02:32:54] <dbaupp> even with #[cfg(test)] extern mod extra?
[03:07:04] *** Joins: rhelmer (rhelmer@moz-DB4A9C19.scl3.mozilla.com)
[03:23:57] *** Quits: dbaupp (Thunderbir@moz-54ADD9F4.lns20.syd6.internode.on.net) (Ping timeout)
[03:24:34] *** Joins: dbaupp (Thunderbir@moz-54ADD9F4.lns20.syd6.internode.on.net)
[05:47:18] *** Quits: strcat (strcat@moz-54F7FD49.cpe.net.cable.rogers.com) (Quit: WeeChat 0.4.2)
[06:55:20] *** Joins: eddyb (eddy@3C6E2DBB.FFB4E060.A5830293.IP)
[07:02:52] *** Joins: laci (Mibbit@moz-2643E5B1.pool.digikabel.hu)
[07:26:46] *** Quits: laci (Mibbit@moz-2643E5B1.pool.digikabel.hu) (Quit: http://www.mibbit.com ajax IRC Client)
[07:31:35] <eddyb> pcmattman: good news, rustic compiles with only one #[linkage(external)]. the bad news is that my PR needs more thought :(
[07:32:49] <dbaupp> eddyb: I imagine thought will be "convince acrichto to accept a subset of the linkages" :P
[07:32:57] * dbaupp is hopeful
[07:33:44] <eddyb> dbaupp: you know him better than I do :)
[07:34:32] <dbaupp> yeah, but I don't know enough about the various linkages to say anything useful
[08:09:10] <Leo`> o/
[08:09:48] <eddyb> /o-
[08:39:29] <pcmattman> don't hate me, but I kind of agree with achrichto
[08:39:50] <pcmattman> objectively, not just because of my own PR :)
[08:42:31] <eddyb> pcmattman: sure, but I don't think I can come up with something nicer in a reasonable amount of time
[08:46:43] <pcmattman> well, weak linkage aside, what linkage is available that isn't inferrable from the rust declaration?
[08:48:09] <eddyb> pcmattman: see strcat's comment, external is not really inferrable from extern "C"
[08:48:35] <pcmattman> sure, extern "C" specifies the ABI, pub defines visibility
[08:49:05] <pcmattman> #[linkage(internal)] pub fn helloworld() {}
[08:49:07] <pcmattman> ^ this doesn't make sense
[08:49:54] <eddyb> pub defines module-level visibility
[08:50:15] <eddyb> pcmattman: and that's actually the default
[08:50:25] <dbaupp> what about thinks like #[linkage(dllimport)] and dllexport?
[08:50:53] <pcmattman> dbaupp: do crates built with --lib export all symbols by default?
[08:50:53] <eddyb> (unless you're compiling with --lib)
[08:51:00] <Leo`> eddyb: internal on a function that is pub at the crate level doesn't make much sense
[08:51:24] <Leo`> if the whole mod chain to your function is pub it should be external
[08:51:29] <dbaupp> pcmattman: I think it's guaranteed to export all symbols that have a path where each component is pub
[08:51:38] <Leo`> yep
[08:51:41] <eddyb> Leo`: nope
[08:51:44] <pcmattman> dbaupp: fair enough, I imagine on Windows it'll do that via dllexport
[08:51:45] <dbaupp> (including via `pub use`, although this is buggy)
[08:51:58] <dbaupp> pcmattman: ok 
[08:52:13] <pcmattman> dllimport though, that one is a challenge
[08:52:17] <eddyb> Leo`: pub gives you access to those names from within the crate itself. functions can still be removed if they get inlined
[08:53:16] <Leo`> eddyb: if a function is visible outside the crate according to pub, it should be external
[08:53:33] <Leo`> pub mod foo { pub mod bar { pub fn() { } } } 
[08:53:50] <Leo`> the fn should be external unless a signle component of the hierarchy is not pub
[08:53:55] <Leo`> single*
[08:53:59] <eddyb> Leo`: you might need to make a function visible outside the crate to use it somewhere inside the crate
[08:54:11] <pcmattman> dbaupp: dllimport is a different story, if there's no dllimport attribute it seems that a thunk is emitted
[08:54:31] <Leo`> eddyb: I don't think so
[08:55:12] <dbaupp> Leo`: you may need it to exist as a symbol with a fixed name for asm!() stuff
[08:55:14] <Leo`> or at least this shouldn't be
[08:55:27] <Leo`> yeah
[08:55:34] <Leo`> oh
[08:55:37] <eddyb> Leo`: or if you want to make a function that's in a submodule external, you end up making a lot of functions external
[08:55:38] <Leo`> I see your point
[08:56:24] <pcmattman> pub mod foo { pub mod bar { pub fn visible() { }; fn notvisible() {}; } } ?
[08:56:26] <Leo`> for your first case, I think #[inline(never)] would be sufficient
[08:56:38] <Leo`> pcmattman: this way notvisible is not accessible inside the crate
[08:56:53] <Leo`> pcmattman: and to make it accessible inside the crate you have to make it accessible outside
[08:56:54] <pcmattman> sec
[08:57:02] <eddyb> Leo`: but what if you need notvisible from inside foo?
[08:57:28] <pcmattman> if you need notvisible inside foo you define it as pub notvisible?
[08:57:39] <eddyb> then it ends up being external
[08:57:42] <Leo`> pcmattman: and then it becomes external
[08:57:44] <eddyb> (according to his logic)
[08:57:56] <Leo`> mhh
[08:58:03] <Leo`> I get the point
[08:58:24] <Leo`> that still can be solved by arranging a bit the module hierarchy but I'm not sure if this is the right solution ><
[08:58:26] <pcmattman> pub mod foo { pub mod bar { #[inline(never)] pub "extern "C" fn visible() { }; fn notvisible() {}; } } <-- visible is now present as a usable symbol for things opened with dlopen etc
[08:58:48] <pcmattman> pub mod foo { pub mod bar { #[inline(never)] "extern "C" fn visible() { }; fn notvisible() {}; } } <-- visible now uses the C ABI but is _not_ available as a symbol for things opened with dlopen etc
[08:59:08] <Leo`> pcmattman: the problem is
[08:59:17] <eddyb> pcmattman: now try using visible from inside foo
[08:59:21] <eddyb> same problem
[08:59:29] <Leo`> you can't have BOTH visible to be external and notvisible internal but still accessible from the rest of the crate
[08:59:41] <pcmattman> sure, fair point
[08:59:53] <eddyb> now that we got that out of the way... I'd be fine with restricting linkage to internal, external, weak (external_weak), and the dll_import/dll_export (without the underscore, maybe)
[08:59:56] <pcmattman> is there a case where you don't actually want the symbol to be external?
[09:00:14] <eddyb> pcmattman: yes, gdt::table::load
[09:00:26] <pcmattman> that's... not extern "C"
[09:00:42] <eddyb> hmm, I see your point
[09:00:45] <pcmattman> wait, we're talking about bin crates, right?
[09:01:09] <Leo`> thought we ware talking about libs
[09:01:27] <Leo`> but I shouldn't be very different
[09:01:31] <eddyb> pcmattman: I was assuming a change shouldn't affect general behavior
[09:01:45] <eddyb> Leo`: libs do your everything-pub-is-external deal
[09:01:45] <pcmattman> bin crates do not export anything other than their entry point, this is why my PR fixes linkage for foreign ABI functions
[09:02:11] <pcmattman> (eg, if we're specifying a function pub extern ABI, set is as external linkage unless Rust's visibility rules override that)
[09:04:38] <eddyb> hmm, the function would need to be emitted anyway, if you were passing pointers to it around
[09:08:40] <pcmattman> emitted is not the same as exported
[09:09:27] <pcmattman> now, where a linkage attribute could be really useful is on _data_ :)
[09:10:05] <pcmattman> maybe.
[09:10:15] <eddyb> it's already there for static imports
[09:14:24] <eddyb> (in my PR that is)
[09:15:06] <pcmattman> the use case for that is a bit more difficult to figure out though
[09:17:43] <eddyb> I really don't know what to do :/. I want to work on non-compiler code, dammit :D
[09:23:59] <pcmattman> hmm working on two projects at once makes my system unhappy, too much compiling
[09:47:12] *** Joins: kido (kido@moz-40572DAF.w92-150.abo.wanadoo.fr)
[09:49:29] <Leo`> mhhh
[09:49:38] <Leo`> i'm playing with Rust's hygienic macros
[09:50:06] <Leo`> is there a way to do a macro that takes, say, an integer as parameter, and expands like :
[09:50:24] <Leo`> macro!(123) => something_123();
[09:52:41] <dbaupp> concat_idents!() used to do that, but it's likely broken
[09:52:57] <Leo`> :/
[09:53:02] <dbaupp> oh, and it probably doesn't work with integer arguments
[09:53:07] <dbaupp> fun times :P
[09:53:34] <dbaupp> rusti: fn foo_bar() { println("ok"); } concat_ident!(foo_, bar)()
[09:53:36] -rusti- pastebinned 6 lines of output: http://ix.io/8D0
[09:53:43] <dbaupp> rusti: fn foo_bar() { println("ok"); } concat_idents!(foo_, bar)()
[09:53:45] -rusti- pastebinned 9 lines of output: http://ix.io/8D1
[09:54:02] <dbaupp> rusti: fn foo_bar() { println("ok"); } ((concat_idents!(foo_, bar))())
[09:54:03] -rusti- ok
[09:54:03] -rusti- ()
[09:54:19] <dbaupp> well, it's not entirely broken
[09:54:43] <Leo`> it is for what I wanted to do :p
[09:55:02] <Leo`> I wanted a macro that generates function definitions based on its arguments
[09:55:20] <Leo`> like macro!(123) => fn something_132();
[09:55:36] <Leo`> so I did : fn concat_ident!(foo, $i)();
[09:55:42] <Leo`> where $i is my parameter
[09:56:13] <Leo`> but he don't like the concat_ident! call 
[09:56:20] <Leo`> says he expects an ident
[09:56:34] <dbaupp> and you have $i:expr?
[09:56:35] <dbaupp> yeah
[09:56:52] <Leo`> no $i:ident
[09:56:54] <dbaupp> oh
[09:56:55] <Leo`> no I mean
[09:56:59] <eddyb> Leo`: let me tell you a secret
[09:57:17] <Leo`> fn concat_idents!(foo, $i)();
[09:57:19] <eddyb> Leo`: use [u8, ..N] as a type param, extract N using size_of
[09:57:24] <Leo`>  error: expected `(` but found `!`
[09:57:27] <dbaupp> Leo`: oh! yeah
[09:57:31] <dbaupp> that's annoying
[09:57:39] <dbaupp> eddyb: you're a bad person :P
[09:57:51] <Leo`> eddyb: ... wut ?
[09:57:56] <eddyb> that's how I'm going to specialize some stuff in SlamAllocator
[09:58:15] <eddyb> Leo`: you can pass numbers as generic type params, using fixed length vectors
[09:58:29] <Leo`> eddyb: except the functions I want to declare are external
[09:58:31] <Leo`> :P
[09:58:43] <eddyb> tough luck :(
[09:58:59] <pcmattman> Leo`: you aren't, perchance, doing ISRs or something?
[09:59:15] <Leo`> pcmattman: How did you guessed ? ._____.
[09:59:18] <pcmattman> heh.
[09:59:19] <eddyb> Leo`: you can put pointers to foobar<[u8, ..N]> in an array, if that would work for you
[09:59:33] <eddyb> Leo`: because he wrote similarly messy code
[09:59:34] <dbaupp> Leo`: pcmattman actually lives in your computer
[09:59:35] * pcmattman generates those, quick script and you're all set
[09:59:42] *** Joins: kido` (kido@moz-DCEF136C.w92-150.abo.wanadoo.fr)
[09:59:52] <pcmattman> not a chance I'm typing 256 lines
[09:59:52] <Leo`> I want to access all my ISR functions from my Rust code
[09:59:58] <Leo`> yeah :D
[09:59:59] *** Quits: kido (kido@moz-40572DAF.w92-150.abo.wanadoo.fr) (Ping timeout)
[10:00:05] <Leo`> neither am I
[10:00:15] <pcmattman> oh I also have a disgusting hack for actually getting the ISRs into my rust code
[10:00:24] <pcmattman> that I used in one of my C kernels and liked so much that I brought it across
[10:00:29] <Leo`> oh ?
[10:00:42] <pcmattman> sec, I'll get the code
[10:01:04] <pcmattman> https://github.com/pcmattman/rustic/blob/master/src/cpu/idt.rs
[10:01:26] <pcmattman> where isrs_base is in https://github.com/pcmattman/rustic/blob/master/src/start.S
[10:01:32] <eddyb> https://github.com/pcmattman/rustic/blob/master/src/start.S#L185-L441 this is just nasty
[10:01:49] <pcmattman> it's kind of hard to avoid
[10:02:04] <ldunn> is it necessary to add an entry for every interrupt? .-.
[10:02:19] <Leo`> well this is because you use GAS :D
[10:02:21] <eddyb> pcmattman: you can use a macro here https://github.com/pcmattman/rustic/blob/master/src/cpu/idt.rs#L107-L115
[10:02:24] <dbaupp> ooooh, people using #[packed] <3
[10:02:41] *** Joins: tgummerer_ (tgummerer@51D3B54.FEF996EA.EA6FEF3D.IP)
[10:02:47] <pcmattman> eddyb: a macro?
[10:02:57] <eddyb> pcmattman: to use pointers to specialized generics
[10:03:18] <pcmattman> what's wrong with it now?
[10:03:19] <Leo`> pcmattman: http://paste.placeholder.fr/show/475/ 
[10:03:22] <Leo`> :D
[10:03:56] <pcmattman> Leo`: you'll note your example doesn't push the interrupt number, and therefore makes central interrupt dispatch challenging :)
[10:03:57] <eddyb> pcmattman: it's messy in start.S
[10:04:20] <pcmattman> can't use specialized generics unless you can do naked functions in rust
[10:04:39] <Leo`> pcmattman: it pushes the interrupt number
[10:05:01] <pcmattman> oh so it does, missed that
[10:05:33] <pcmattman> also eww PIC EOI for traps :(
[10:05:57] <Leo`> mh ? :|
[10:05:57] <eddyb> pcmattman: iret should be easy to do with -> !, and you can remove the prelude if you want to
[10:06:18] <eddyb> (the morestack one, at least)
[10:06:31] <eddyb> pcmattman: I'll play with it, I guess, and report back if it works :D
[10:06:32] <pcmattman> alright, what does putting that stuff in Rust give me? the whole thing is going to be inline ASM anyway.
[10:06:56] <pcmattman> it has to be in order to push the registers and state necessary for stack switching before calling into the actual dispatcher
[10:07:13] <pcmattman> Leo`: the outb after calling into rust in that assembly
[10:07:40] <Leo`> pcmattman: yeah, and what ?
[10:08:27] <Leo`>         base += ISR_STUB_LENGTH; well this is ...... :D
[10:08:32] <pcmattman> well, it'll happen on non-IRQ interrupts there
[10:08:33] <eddyb> pcmattman: for one, you can have the segment selectors as constant statics, in cpu::gdt, and use them instead of hardcoding
[10:08:41] <pcmattman> yeah, that's the best part of the hack
[10:08:56] <Leo`> pcmattman: oh
[10:09:03] <Leo`> pcmattman: and it shouldn't ?
[10:09:13] <pcmattman> (it also won't be enough for IRQ8 and above)
[10:09:46] <eddyb> pcmattman: you can pass the interrupt number without pushing it and then retrieving it from the stack
[10:10:30] <pcmattman> eh, I like it how it is now
[10:10:36] <Leo`> pcmattman: I prefer the macro trick, if feasible
[10:10:38] <Leo`> :P
[10:10:47] <Leo`> but that's... interesting :p
[10:10:48] <pcmattman> works, no need to hope the compiler doesn't screw around with preludes and stacks and stuff
[10:12:18] *** Quits: devbug (quassel@23AC5F12.9D950176.3655BBF5.IP) (Connection reset by peer)
[10:28:25] *** Quits: tiffany (kawaii@moz-28A8742A.dhcp.embarqhsd.net) (Ping timeout)
[10:31:08] *** Quits: canhtak (jeremy@moz-44A7DE0.wl.t.ulaval.ca) (Quit: canhtak)
[10:51:16] <KokaKiwi> Hoy
[11:25:51] *** Joins: canhtak (jeremy@moz-A67811CE.wl.t.ulaval.ca)
[11:28:20] *** Quits: dbaupp (Thunderbir@moz-54ADD9F4.lns20.syd6.internode.on.net) (Ping timeout)
[11:40:04] *** Joins: dbaupp (Thunderbir@moz-54ADD9F4.lns20.syd6.internode.on.net)
[12:49:59] *** Quits: kido` (kido@moz-DCEF136C.w92-150.abo.wanadoo.fr) (Client exited)
[13:27:52] *** Quits: dbaupp (Thunderbir@moz-54ADD9F4.lns20.syd6.internode.on.net) (Ping timeout)
[13:34:19] *** Joins: dbaupp (Thunderbir@moz-54ADD9F4.lns20.syd6.internode.on.net)
[15:49:39] *** Joins: b (b@moz-55CA322E.org)
[15:58:52] <eddyb> dbaupp: https://github.com/thestinger/rust-core/pull/4
[15:59:03] <eddyb> look ma', no macros!
[16:00:58] <cmr> Damn that's a lot of atomics.
[16:01:06] <cmr> Are the intrinsics all things that LLVM emits?
[16:03:40] <eddyb> most of them, yeah
[16:03:52] <eddyb> cmr: I just copied all the atomic intrinsics from libstd/unstable/intrinsics.rs
[16:04:32] <cmr> ah
[17:02:12] <eddyb> cmr: GAAAH you cursed me
[17:02:25] <eddyb> I'm pretty sure it's failing to boot because of alignment problems now
[17:02:47] <cmr> Hahah
[17:04:57] <eddyb> let data = &self.data as *N as uint; // this might not work
[17:05:43] <eddyb> I mean, I know I've done something stupid with references before
[17:10:38] *** Quits: canhtak (jeremy@moz-A67811CE.wl.t.ulaval.ca) (Quit: canhtak)
[17:11:22] *** Joins: canhtak (jeremy@moz-A67811CE.wl.t.ulaval.ca)
[17:11:46] *** Quits: canhtak (jeremy@moz-A67811CE.wl.t.ulaval.ca) (Quit: canhtak)
[17:14:43] <cmr> http://dl.acm.org/citation.cfm?id=1806596.1806610&coll=DL&dl=ACM&CFID=372004882&CFTOKEN=31948457
[17:14:48] <eddyb> haha woot? #[fixed_stack_segment] makes a function uncallable
[17:14:57] <eddyb> qemu hangs for a second or two then reboots
[17:17:42] <eddyb> this must be one crazy bug
[17:25:19] <eddyb> cmr: I've added alignment, and positioned the data at the end, hoping it might get put into .bss, but no luck :/
[17:25:55] <cmr> eddyb: as I was beginning work on cmoss I always had the disassembly and IR of my code in a separate pane.
[17:26:17] <cmr> Rust still isn't mature enough for this usecase to be trusted to do the right thing.
[17:26:54] <eddyb> #[fixed_stack_segment] was working fine when the function was calling a C function
[17:27:13] <eddyb> not sure what the deal is there, but I don't need it anymore anyway :D
[17:36:27] <eddyb> wake up, strcat :/
[17:52:29] *** Joins: rveach (kvirc@9B96775A.4E0850CE.9A53B712.IP)
[17:52:55] *** Quits: eddyb9 (eddy@3C6E2DBB.FFB4E060.A5830293.IP) (Ping timeout)
[18:02:15] *** Quits: rusti (rusti@moz-54F7FD49.cpe.net.cable.rogers.com) (Ping timeout)
[18:18:05] *** Joins: rusti (rusti@moz-54F7FD49.cpe.net.cable.rogers.com)
[18:27:03] *** Joins: strcat (strcat@moz-54F7FD49.cpe.net.cable.rogers.com)
[18:29:11] <eddyb> strcat: found a macro-less solution for the heap allocator custom implementation problem: https://github.com/thestinger/rust-core/pull/4
[18:29:59] <eddyb> strcat: and this turns each constant-sized allocation into a single call instruction (to the specialized function, no arguments): https://github.com/eddyb/rustic/blob/slam/src/mem/slam.rs#L202-L226
[18:30:05] *** Joins: rveach|2 (kvirc@moz-7E54B3A2.hsd1.ca.comcast.net)
[18:30:22] *** Quits: rveach (kvirc@9B96775A.4E0850CE.9A53B712.IP) (Ping timeout)
[18:59:51] *** Joins: tiffany (kawaii@moz-28A8742A.dhcp.embarqhsd.net)
[19:01:49] *** Quits: rusti (rusti@moz-54F7FD49.cpe.net.cable.rogers.com) (Ping timeout)
[19:01:54] *** Quits: strcat (strcat@moz-54F7FD49.cpe.net.cable.rogers.com) (Ping timeout)
[19:02:51] *** Joins: devbug (quassel@23AC5F12.9D950176.3655BBF5.IP)
[19:03:10] <eddyb> pcmattman: two step (rs -> bs and then bs -> ELF .o) Rust compilation gets rid of the prelude and allows us to disable PIC. the generated code is sleeker with forced static relocation :D
[19:03:30] <eddyb> one allocation function: http://i.imgur.com/kou661Q.png
[19:03:53] *** Joins: strcat (strcat@moz-54F7FD49.cpe.net.cable.rogers.com)
[19:04:10] <eddyb> strcat: the nop "sled" I mentioned: http://i.imgur.com/kou661Q.png
[19:04:29] <eddyb> bbl
[19:04:55] <strcat> eddyb: it does that to align stuff
[19:18:43] *** Joins: rusti (rusti@moz-54F7FD49.cpe.net.cable.rogers.com)
[19:19:30] <strcat> eddyb: I don't really understand why you're using compare_and_swap there
[19:32:21] <strcat> eddyb: oh just as a spin lock
[19:33:47] *** Quits: tgummerer_ (tgummerer@51D3B54.FEF996EA.EA6FEF3D.IP) (Ping timeout)
[19:52:53] *** Joins: tgummerer_ (tgummerer@moz-5DC8FA44.tbcn.telia.com)
[20:01:23] *** Joins: strcat1 (strcat@moz-54F7FD49.cpe.net.cable.rogers.com)
[20:01:35] *** Quits: strcat (strcat@moz-54F7FD49.cpe.net.cable.rogers.com) (NickServ (GHOST command used by strcat1))
[20:01:38] *** strcat1 is now known as strcat
[20:02:32] *** Quits: rusti (rusti@moz-54F7FD49.cpe.net.cable.rogers.com) (Ping timeout)
[20:05:07] *** Joins: rusti (rusti@moz-54F7FD49.cpe.net.cable.rogers.com)
[20:34:53] *** Quits: tgummerer_ (tgummerer@moz-5DC8FA44.tbcn.telia.com) (Ping timeout)
[20:40:29] <eddyb> back
[20:41:05] <eddyb> strcat: lock-free. I think I could replace the loop with a single atomic add, but I haven't exposed that yet
[20:41:54] <eddyb> SlamAllocator needs loops around CAS because it does operations on lists like head = head->next, and you can't make that entire thing atomic
[20:42:16] <eddyb> strcat: but in normal conditions, the loop should break after the first attempt
[20:42:30] <strcat> right
[20:53:12] <eddyb> strcat: but what do you think of the module structure I used to make this user-configurable?
[20:53:30] <eddyb> pcmattman: you're no longer away, I noticed :P
[20:53:50] *** Joins: tgummerer_ (tgummerer@moz-5DC8FA44.tbcn.telia.com)
[20:56:04] <pcmattman> IRC is open, but I am getting ready for work :)
[20:56:52] <strcat> eddyb: I'm not sure yet, allocators are hard to get right - probably want it configurable per-container, but as part of the type
[20:57:02] <strcat> so you can't accidentally mix it up
[20:57:27] <strcat> but ofc as part of the type, the allocator will be a type and not an instance
[20:57:30] <strcat> so again, hard to get right ;p
[20:57:34] <eddyb> strcat: C++ std does that...
[20:57:54] <strcat> yeah and it doesn't work well
[20:58:11] <eddyb> you would need something that can compose
[20:59:13] <eddyb> maybe a macro that creates a new empty struct implementing Allocator as a proxy to a static Allocator
[20:59:54] <eddyb> then you can use that type, even create instances, and it will use that same "heap" instance
[21:00:18] <eddyb> strcat: it gets messier because there's no default "values" for generics (AFAIK)
[21:00:23] <strcat> if it's not part of the type it won't be safe
[21:00:29] <strcat> and that's a hard requirement
[21:01:31] <eddyb> why so? what's wrong with a global allocator?
[21:01:46] *** Joins: strcat1 (strcat@moz-54F7FD49.cpe.net.cable.rogers.com)
[21:01:46] *** Quits: rusti (rusti@moz-54F7FD49.cpe.net.cable.rogers.com) (Ping timeout)
[21:01:58] *** Joins: rusti (rusti@moz-54F7FD49.cpe.net.cable.rogers.com)
[21:02:09] *** Quits: strcat (strcat@moz-54F7FD49.cpe.net.cable.rogers.com) (Ping timeout)
[21:02:18] *** Quits: rusti (rusti@moz-54F7FD49.cpe.net.cable.rogers.com) (Client exited)
[21:02:19] *** Joins: rusti (rusti@moz-54F7FD49.cpe.net.cable.rogers.com)
[21:09:21] <devbug> eddyb: "Allocate 4GB and I'll kick your teeth in."
[21:09:27] <eddyb> strcat1: hmpf, looking again at http://i.imgur.com/kou661Q.png - it aligns loads from memory.... why? I don't really get it
[21:09:39] <strcat1> eddyb: performance
[21:09:46] <eddyb> devbug: the great James Molloy's words
[21:09:48] <strcat1> eddyb: try using -march=native and see if it does something smarter
[21:09:57] <eddyb> hmm, thanks
[21:10:02] <strcat1> maybe it won't
[21:10:03] <strcat1> dunno
[21:10:07] <devbug> eddyb: reverend saint
[21:10:09] <pcmattman> devbug: until recently that comment was wrong, the check against lg2 actually meant the limit was 16 MB :)
[21:10:28] <eddyb> devbug: I left him in the copyright header, too
[21:10:32] <strcat1> eddyb: it aligns instructions in some cases for performance, I don't know the details
[21:10:54] <devbug> hmm
[21:11:00] <devbug> My google fu fails me
[21:11:11] <devbug> http://www.linuxplumbersconf.org/2010/ocw/proposals/405
[21:11:38] <eddyb> devbug: this explains an improvment I came up with, to his problem and two partial solutions: http://forum.osdev.org/viewtopic.php?f=15&t=20878&p=228353#p228353
[21:11:47] <pcmattman> that's a lot of nops
[21:12:05] <eddyb> (it's not yet implemented anywhere, but the rust version doesn't have the things it doesn't need, like magic)
[21:12:32] <devbug> The good kind, or the dark kind?
[21:12:49] <pcmattman> the magic number to check consistency kind
[21:12:57] <eddyb> the 0xb00b1e55 kind
[21:15:43] <eddyb> with -march=native, it seems to do something crazier (while still forcing alignment) http://i.imgur.com/sO5zvN5.png
[21:16:39] * pcmattman doesn't see that the craziness is
[21:16:41] <pcmattman> what*
[21:16:53] <eddyb> pcmattman: the 2
[21:17:02] <eddyb> err, keypad enter, behave
[21:17:02] <devbug> wtf is with all these nops
[21:17:15] <eddyb> pcmattman: the 13byte o16 nop [cs:eax+eax]
[21:17:28] <pcmattman> sure, align the next instruction to a cache line
[21:17:56] <pcmattman> and do so with something that won't destroy the pipeline
[21:18:10] <eddyb> I'm thinking the fancy nops execute faster and... yeah
[21:20:20] <eddyb> making the linear allocator non-thread-safe (or replacing the CAS loop with a single atomic add) and getting rid of alignment might cut that code in half
[21:22:57] <eddyb> this is fun, removing the alignment actually prevents register spilling
[21:23:21] <pcmattman> why do you want to cut the code in half?
[21:23:51] *** Joins: canhtak (jeremy@moz-12EBB66A.wl.t.ulaval.ca)
[21:23:59] <eddyb> pcmattman: I kinda want to see how small I can make this, while keeping all its functionality
[21:24:13] <pcmattman> :/
[21:24:15] <eddyb> it's already pretty darn small for an allocator, I would say
[21:24:55] <pcmattman> why does it matter, if you're writing it in a high-level language anyway?
[21:25:31] <eddyb> pcmattman: I want to make sure I use the best primitives :P
[21:25:45] <eddyb> and I'm having fun with this because I understood how it works
[21:27:26] <eddyb> but goodnight for now and school tomorrow :(
[21:27:45] <pcmattman> night
[21:28:02] *** Quits: eddyb (eddy@3C6E2DBB.FFB4E060.A5830293.IP) (Quit: Konversation terminated!)
[21:28:12] *** Joins: eddyb (eddy@3C6E2DBB.FFB4E060.A5830293.IP)
[21:29:47] <strcat1> eddyb: yeah if you tag it optsize it will probably not do it
[21:29:51] <strcat1> but otherwise it really likes padding
[21:30:19] *** Quits: eddyb (eddy@3C6E2DBB.FFB4E060.A5830293.IP) (Ping timeout)
[21:33:20] *** Joins: eddyb9 (eddy@3C6E2DBB.FFB4E060.A5830293.IP)
[21:35:43] *** strcat1 is now known as strcat
[21:37:57] *** Quits: tgummerer_ (tgummerer@moz-5DC8FA44.tbcn.telia.com) (Ping timeout)
[21:50:05] *** Joins: brson (brson@moz-BBE3ABD.mv.mozilla.com)
[21:52:25] *** Quits: brson (brson@moz-BBE3ABD.mv.mozilla.com) (Ping timeout)
[21:55:58] *** Joins: brson (brson@981AA104.E81F12CD.76F66111.IP)
[22:01:04] *** Joins: strcat1 (strcat@moz-54F7FD49.cpe.net.cable.rogers.com)
[22:02:02] *** Quits: rusti (rusti@moz-54F7FD49.cpe.net.cable.rogers.com) (Ping timeout)
[22:02:13] *** Joins: rusti (rusti@moz-54F7FD49.cpe.net.cable.rogers.com)
[22:02:21] *** Quits: strcat (strcat@moz-54F7FD49.cpe.net.cable.rogers.com) (Ping timeout)
[22:20:18] *** strcat1 is now known as strcat
[22:35:26] *** Quits: strcat (strcat@moz-54F7FD49.cpe.net.cable.rogers.com) (Quit: WeeChat 0.4.2)
[22:52:58] *** Quits: rveach|2 (kvirc@moz-7E54B3A2.hsd1.ca.comcast.net) (Quit: KVIrc 4.2.0 Equilibrium http://www.kvirc.net/)
[22:53:05] *** Joins: strcat (strcat@moz-54F7FD49.cpe.net.cable.rogers.com)
[22:53:29] <strcat> eddyb9: I guess a macro isn't really going to work ;\
[22:53:43] <strcat> since rust-core will eventually be a crate
[22:54:58] <strcat> pcmattman: does windows have an aligned_alloc symbol?
[22:55:25] <pcmattman> well, I did a quick hunt and came up with http://msdn.microsoft.com/en-us/library/8z34s9c6.aspx
[22:55:42] <strcat> ah that's the same as the C11 function with another name
[22:56:40] <pcmattman> and posix_memalign is POSIX but not stdc, so I don't know if it'll be available on Windows
[23:01:29] *** Joins: strcat1 (strcat@moz-54F7FD49.cpe.net.cable.rogers.com)
[23:01:58] *** Quits: rusti (rusti@moz-54F7FD49.cpe.net.cable.rogers.com) (Ping timeout)
[23:02:06] *** Joins: rusti (rusti@moz-54F7FD49.cpe.net.cable.rogers.com)
[23:02:11] <pcmattman> strcat1: your network seems sad :(
[23:02:25] *** Quits: strcat (strcat@moz-54F7FD49.cpe.net.cable.rogers.com) (Ping timeout)
[23:02:45] <strcat1> pcmattman: I don't really think it's my network, I have plenty of ssh connections open that aren't dying
[23:02:49] * strcat1 shrugs
[23:03:10] <strcat1> I think my ISP sends TCP RSTs on encrypted connections that look like P2P
[23:03:22] <pcmattman> ahh
[23:03:36] * strcat1 shrugs
[23:04:06] *** strcat1 is now known as strcat
[23:09:37] <pcmattman> clearly the solution is to pipe all that encrypted IRC down one of your SSH connections :)
[23:18:26] <strcat> pcmattman: I think if the ssh connections were sending more data, they'd RST them too :(
[23:19:24] *** Joins: geoffhill (geoffhill@moz-2785B672.hsd1.wa.comcast.net)
[23:24:07] *** Parts: olsner (salparot@moz-DB61CF9E.bredband.comhem.se) (Leaving)
[23:25:09] *** Quits: geoffhill (geoffhill@moz-2785B672.hsd1.wa.comcast.net) (Quit: geoffhill)
[23:33:47] <pcmattman> strcat: fair point
[23:34:32] <strcat> pcmattman: but basically, canada sucks in regards to internet service ;p
[23:34:50] <strcat> I think they have load problems and then specifically target P2P - but they *always* have these problems
[23:35:56] <pcmattman> ah
[23:36:00] <pcmattman> well at least git still works :)
[23:40:42] <pcmattman> hm, I should probably do something about making rustic usable/buildable until https://github.com/mozilla/rust/pull/9945 (or #9966) happen
[23:59:22] <strcat> pcmattman: ugh
[23:59:31] <strcat> it looks like windows requires you to use _aligned_free for that

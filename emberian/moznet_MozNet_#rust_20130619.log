[00:00:18] <graydon> oh, I gotta pull out the mac32-nopt build entirely, right?
[00:00:22] <graydon> linker has kittens
[00:00:24] <graydon> k
[00:00:27] *** Joins: KindOne (KindOne@moz-5220B9A5.dynamic.ip.windstream.net)
[00:00:36] *** Joins: dylukes (dylukes@moz-E4DF3FED.pitbpa.fios.verizon.net)
[00:00:45] <aatch> graydon, probably worth turning back on post-snapshot, at least to check
[00:00:47] *** Quits: dylukes (dylukes@moz-E4DF3FED.pitbpa.fios.verizon.net) (Quit: Computer has gone to sleep.)
[00:01:10] <graydon> *shrug* maybe
[00:01:24] <graydon> I think I'm a little more concerned with 64nopt and 32-at-all than that _exact_ combination
[00:01:35] <graydon> (are 32bit mac builds even that relevant in 2013?)
[00:01:50] <graydon> there's "tier 1" and then there's "forgotten variants of tier 1"
[00:01:55] <cmr> are there 32 bit macs?
[00:01:59] <graydon> we're not building on slackware 4 either
[00:02:23] <aatch> graydon, not really. But it could at least be a nice smoketest for code size
[00:02:43] *** Quits: maxli (maxli@C03F2759.C70D537E.2FA4EA88.IP) (Quit: Leaving.)
[00:03:00] <graydon> I guess. it if can't link with >21bit relocs, I think maybe the smoke will be hard to get back into the case.
[00:03:00] *** Quits: eschweic1 (Adium@2557E599.66715431.D25A875A.IP) (Quit: Leaving.)
[00:03:05] *** Joins: devbug (quassel@moz-E1DE087C.bchsia.telus.net)
[00:03:38] <graydon> (that would require, I think, most crates to be <2mb)
[00:03:39] *** Joins: Diamond (dick@moz-625C0DAF.ks.ok.cox.net)
[00:04:03] <graydon> might just be some magic linker option though
[00:04:13] <cmr> it said 24 bits didn't it?
[00:04:19] <graydon> I would be surprised if osx 32bit was fundamentally unable to deal with object files that large
[00:04:22] <graydon> oh, maybe 24
[00:04:40] <cmr> so 16MB :p
[00:04:40] <aatch> Yeah, so it's less than 16MB
[00:04:45] *** Joins: dylukes (dylukes@moz-E4DF3FED.pitbpa.fios.verizon.net)
[00:04:48] <graydon> hm. maybe! 16mb binary as the largest .o file on 32bit OSX? maybe, maybe
[00:05:35] <aatch> Although it might not be feasible... librustllvm.so on my machine comes to 24MB
[00:05:48] <aatch> For a 32-bit build
[00:05:51] *** Joins: int3_ (int3_@43CB6079.66715431.D25A875A.IP)
[00:05:51] <Eridius> 32-bit mac builds aren't very relevant these days
[00:05:59] <Eridius> we haven't sold a 32-bit mac in a while if memory serves
[00:06:36] *** Quits: mschifer (Adium@2557E599.66715431.D25A875A.IP) (Quit: Leaving.)
[00:07:01] <strcat> bblum: when we have working default methods we can have an iterable trait with map
[00:07:10] <strcat> so it will just be 'for xs.map {}' again
[00:07:21] <bblum> strcat: oh nice
[00:07:26] <Eridius> strcat: we can? how will map know how to reconstruct the original iterable container?
[00:07:35] *** Joins: infynyxx (infynyxx@DB780A29.749BA1D.DCC373F0.IP)
[00:07:50] <bblum> strcat: er, wait, well, will the value of that for loop return a mapped object?
[00:07:50] <strcat> Eridius: it won't
[00:07:59] <Eridius> strcat: mapping into a different container type isn't very nice
[00:07:59] <strcat> bblum: err
[00:08:03] *** kimundi is now known as zz_kimundi
[00:08:20] <strcat> bblum: for xs.map(|x| * 2).filter(|x| *x % 3 == 0) { } ;p
[00:08:33] <Eridius> oh map in this case as transform, not as in option.map
[00:08:36] <bblum> strcat: well what if i want to actually get a container back out
[00:08:37] <strcat> atm there's an extra .iter() thrown in because of lacking Iterable and .advance because of 'for' not being aware of it
[00:08:41] <graydon> *cough* http://lists.cs.uiuc.edu/pipermail/lldb-commits/Week-of-Mon-20120326/005361.html
[00:08:55] <strcat> bblum: let container: AnyContainer<T> = iter.collect()
[00:08:58] *** Quits: EXetoC (ex@moz-C741B177.customer.t3.se) (Quit: WeeChat 0.4.1)
[00:08:59] <graydon> osx has something it calls "scattered" relocs, which maybe involve jumping from one to the next, or something?
[00:09:03] <strcat> that exists right now but the inference doesn't work *at all*
[00:09:06] <graydon> they only handle 24bit displacements
[00:09:07] <graydon> weird weird
[00:09:08] <bblum> strcat: ok, .collect, hm
[00:09:10] <strcat> so you always have to put the type ;\
[00:09:22] <strcat> it can't infer from what you do with it yet
[00:09:25] <bblum> in what way doesn't it work?
[00:09:27] <bblum> oh
[00:09:33] <bblum> it can't infer what container type you want?
[00:09:38] <strcat> bblum: foo(iter.collect()) where foo takes ~[T]
[00:09:39] <strcat> won't work
[00:09:44] <strcat> at least last time I checked
[00:09:46] <Eridius> strcat: if we make map a default method of iterables, rather than of iterators, then that kills option.map, which is a useful method
[00:10:04] <cmr> Eridius: why does it need to?
[00:10:06] <strcat> Eridius: can be called something else
[00:10:08] <cmr> oh wow lag
[00:10:14] <cmr> 153 seconds of it...
[00:10:18] *** Quits: tgt (tgt@moz-D59EE478.aztw.cable.virginmedia.com) (Quit: Computer has gone to sleep.)
[00:10:19] <Eridius> that's a lot of lag
[00:10:19] <bblum> strcat: can i do, like, some_vector.map(...).collect::<BinaryTree<T>>() ?
[00:10:20] *** Joins: tgt (tgt@moz-D59EE478.aztw.cable.virginmedia.com)
[00:10:51] <Eridius> strcat: maybe .map_iter() on an Iterable and .map on the Iterator itself?
[00:10:52] <bblum> (with HKT you won't even need to write the <T>!)
[00:11:02] <graydon> http://code.google.com/p/go/issues/detail?id=3253 possibly
[00:11:05] <Eridius> although .map_iter() being just a replication of .iter().map() doesn't strike me as that useful
[00:11:05] <graydon> -fno-common?
[00:12:15] <bblum> ok, whoever named the function "normalize_for_monomorphization" committed an egregious error
[00:12:20] <bblum> it should clearly be "normalize_for_monomorphize"
[00:12:39] <Eridius> normalise_for_monomorphisation
[00:12:49] <bblum> Eridius: that would be cool too
[00:12:56] *** Quits: jorendorff (jorendorff@moz-2F32ACA3.hsd1.tn.comcast.net) (Quit: jorendorff)
[00:12:57] *** Joins: eschweic (Adium@2557E599.66715431.D25A875A.IP)
[00:13:12] <nmatsakis> bblum: I think the visitor_object_ty is a type for the visitor object used in reflection, I'm not sure why it has its own type vs ty_trait
[00:13:15] <bblum> or perhaps monomorphanormalizer
[00:13:20] *** Joins: eschweic1 (Adium@2557E599.66715431.D25A875A.IP)
[00:13:20] *** Quits: eschweic (Adium@2557E599.66715431.D25A875A.IP) (Connection reset by peer)
[00:13:26] <strcat> bblum: yeah you can do that
[00:13:32] <strcat> bblum: it works now, except that you need .iter()
[00:13:36] <bblum> strcat: ok, leet
[00:13:48] <strcat> and method resolve bugs mean it has to be called transform or map_
[00:13:57] <bblum> c.c
[00:15:11] <strcat> rusti: let xs = ["foo", "bar", "baz"]; let ys = [1i, 2, 3]; let zs: ~[(&'static str, int)] = xs.iter().transform(|&x| x).zip(ys.iter()).collect();
[00:15:13] -rusti- more than 5 lines of output, pastebinned: http://sprunge.us/AbRJ
[00:15:26] <strcat> rusti: let xs = ["foo", "bar", "baz"]; let ys = [1i, 2, 3]; let zs: ~[(&'static str, &int)] = xs.iter().transform(|&x| x).zip(ys.iter()).collect();
[00:15:27] -rusti- ()
[00:15:38] <strcat> rusti: let xs = ["foo", "bar", "baz"]; let ys = [1i, 2, 3]; let zs: ~[(&'static str, &int)] = xs.iter().transform(|&x| x).zip(ys.iter()).collect(); fmt!("%?", zs)
[00:15:38] <nicelydone> Is transmute an intrinsic function?
[00:15:39] -rusti- ~"~[(\"foo\", &1), (\"bar\", &2), (\"baz\", &3)]"
[00:16:02] <strcat> bblum: also needs a size hint default method
[00:18:21] <steven_is_false> C style enums are represented as ints right?
[00:19:06] *** Joins: eholk (eholk@moz-4EB1DCC1.hfc.comcastbusiness.net)
[00:19:18] *** Joins: k00mi (koomi@moz-DA4B95B4.pools.arcor-ip.net)
[00:19:30] <bblum> geez, ty::ty_trait is just as far-reaching as ast::ty_path
[00:19:57] *** Quits: koomi (koomi@moz-543186DC.pools.arcor-ip.net) (Ping timeout)
[00:20:28] *** Quits: int3_ (int3_@43CB6079.66715431.D25A875A.IP) (Client exited)
[00:21:11] <dbaupp> cmr: whipped up something quickly http://www.ug.it.usyd.edu.au/~hwil7821/rust-bench/
[00:21:53] <graydon> brson: seeing run failures on master osx and linux still, curiously
[00:22:01] <graydon>     run::tests::test_finish_with_output_once     run::tests::test_finish_with_output_twice     run::tests::test_process_output_output  on linux
[00:22:20] <cmr>  dbaupp I wonder what the universal spike at the end is
[00:22:25] <cmr> and if it's endemic of rust in general
[00:22:33] <graydon> tests::run_all on .. oh wait, that's rusti 32bit, already disabled
[00:23:01] <cmr> there seems to be a consistent spike at the beginning too
[00:23:08] <graydon> cmr: could be the annihilator, at the end
[00:23:13] <brson> graydon: i've seen those failures a few times but haven't looked into them. i686?
[00:24:03] *** Joins: int3_ (int3_@43CB6079.66715431.D25A875A.IP)
[00:24:20] <brson> cmr: these aren't just rustc runs right? those are the actual benchmarks? very curious that the graphs look so similar
[00:24:27] *** Quits: engla (engla@moz-DBD1D96E.cust.bredbandsbolaget.se) (Ping timeout)
[00:24:34] <brson> I'd love to know what the diferent 'phases' are
[00:24:35] <cmr> brson: good question
[00:24:42] <graydon> brson: yeah, run: x86_64-unknown-linux-gnu/stage2/test/stdtest-i686-unknown-linux-gnu
[00:24:42] <cmr> dbaupp: which data did you use? :p
[00:24:46] <cmr> 'program' or 'rustc'?
[00:24:51] <dbaupp> cmr: rustc
[00:24:55] <cmr> that explains it
[00:25:11] <brson> graydon: ok, building
[00:25:17] <cmr> annotating that with the pass timing information would be cool, eventually
[00:25:18] <aatch> data usage of rustc during compile, I'm guessing?
[00:25:22] <cmr> aatch: yeah
[00:25:24] <dbaupp> cmr: working on it ;)
[00:25:33] *** Quits: jensnockert (jensnocker@moz-C5F27039.cust.bredband2.com) (Connection reset by peer)
[00:25:47] <graydon> brson: I think it might be related to the "running under valgrind" thing. note there are 3 or 4 of these intermixed in the test output:
[00:25:47] <cmr> dbaupp: :D
[00:25:51] <graydon> ERROR: ld.so: object '/usr/lib/valgrind/vgpreload_core-x86-linux.so' from LD_PRELOAD cannot be preloaded: ignored. ERROR: ld.so: object '/usr/lib/valgrind/vgpreload_memcheck-x86-linux.so' from LD_PRELOAD cannot be preloaded: ignored.
[00:25:51] <cmr> dbaupp: what tool do you use?
[00:26:06] *** Joins: jensnockert (jensnocker@moz-C5F27039.cust.bredband2.com)
[00:26:10] <dbaupp> cmr: R
[00:26:15] <cmr> ah
[00:26:22] <dbaupp> hah
[00:26:55] *** Joins: jorendorff (jorendorff@moz-2F32ACA3.hsd1.tn.comcast.net)
[00:27:08] <dbaupp> cmr: (if/when they get on isrustfastyet, it'll be in javascript, but I'm faster in R for quick stuff like this)
[00:27:19] <bblum> anybody wanna think of a less silly way to structure this: "match foo { bar(*) => { }, _ if condition() => error(), _ => { } }"
[00:27:45] <bblum> it really wants to be, like, "if foo matches bar(*) && condition() { error() }"
[00:27:58] <aatch> bblum, how common is it?
[00:28:05] <bblum> just writing it once
[00:28:09] * dbaupp would like a `matches` operator occasionally too
[00:28:21] <bblum> aatch: in a "fn check_empty_bounds_unless_trait()" i have written
[00:29:07] <aatch> I wonder if a macro could serve as a match operator.
[00:29:25] <bblum> that would be leet
[00:29:34] <bblum> we still can't export macros cross-file, can we?
[00:29:57] <aatch> match!(foo => pat) // returns true if foo matches pat, false otherwise.
[00:30:12] <Luqman> bblum: something like match foo { bar(*) if condition() => error(), _ => {} } ?
[00:30:23] <bblum> Luqman: that does a different thing
[00:30:28] <dbaupp> bblum: #[macro_escape]; "exports" macros
[00:30:38] <graydon> is this rust-bench thing just polling? I'd be slightly concerned it will miss a memory-peak if one occurs, or not report a reliable "maximum"..
[00:30:43] <bblum> oops, my mistake above, i mean "if !(foo matches bar(*)) && condition()"
[00:31:00] <dbaupp> graydon: it's polling cgroups as fast as it can, i think
[00:31:09] *** Quits: bent (chatzilla@moz-BE33DA21.fw1.sfo1.mozilla.net) (Quit: ChatZilla 0.9.90-rdmsoft [XULRunner 18.0.2/20130201065344])
[00:31:16] <dbaupp> graydon: (the raw json also includes the cgroups max_memory_usage, fwiw)
[00:31:18] <graydon> as fast as it _can_? surely there's a better use of time..
[00:31:19] <graydon> ok
[00:31:31] <dbaupp> cmr: ^ ?
[00:31:36] <graydon> so long as it picks up the max before exiting, that's fine
[00:31:40] <cmr> hi
[00:31:47] <aatch> cgroups keeps track of max memory usage
[00:31:52] <cmr> it does poll, I think the delay is like 1.x ms
[00:31:53] <dbaupp> cmr: how's it getting the memory profile?
[00:32:00] <dbaupp> oh
[00:32:03] <cmr> It does also record maximum usage
[00:32:16] <aatch> so it's really down to how fast the kernel checks
[00:32:18] <cmr> it does do it as fast as it can
[00:32:21] *** Quits: yichoi (yichoi@5AB4884B.FCC4549.14D5B978.IP) (Quit: leaving)
[00:32:32] <cmr> no, the python code is actually quite slow :p
[00:32:36] <graydon> huh. something about busy-waits spooks me out, but ok.
[00:32:55] <steven_is_false> Ugh, in git notation HEAD is the last committed thing. How do I refer to the uncommitted stuff?
[00:33:06] <cmr> steven_is_false: you don't
[00:33:09] <cmr> steven_is_false: what do you want to do with it?
[00:33:17] *** Joins: erickt (Adium@49C4075F.3AC15C18.2321E71E.IP)
[00:33:29] <cmr> and by uncommitted do you mean staged?
[00:33:30] <steven_is_false> cmr: NVM just putting a blank in magit's input gives it.
[00:33:34] <strcat> steven_is_false: there are index commands
[00:33:41] <strcat> git diff-index, etc.
[00:34:10] <strcat> and '$(git hash-object -t tree /dev/null)' is the empty repo commit ;p
[00:34:38] *** Joins: doomlord (doomlod@moz-6651F8D4.range86-145.btcentralplus.com)
[00:35:02] <Eridius> strcat: well that's the empty tree
[00:35:10] <Eridius> `git hash-object -t blob /dev/null` is an empty file
[00:35:14] <Eridius> and there's no such thing as an empty commit
[00:35:51] <strcat> Eridius: well commits are just metadata attached to a tree so... I think of trees that way
[00:36:50] <Eridius> commits are their own legitimate objects, with message, authorname, authoremail, authortime, committername, committeremail, committertime, a tree, and zero or more parents
[00:36:51] *** Quits: jorendorff (jorendorff@moz-2F32ACA3.hsd1.tn.comcast.net) (Quit: jorendorff)
[00:37:21] <strcat> sure, but you can diff against a tree
[00:37:27] *** Quits: devbug (quassel@moz-E1DE087C.bchsia.telus.net) (Ping timeout)
[00:38:13] *** Joins: Benvie_ (brandon@5FD20F9A.53D07D95.EFF8B7BF.IP)
[00:38:16] *** Quits: Benvie_ (brandon@5FD20F9A.53D07D95.EFF8B7BF.IP) (Client exited)
[00:38:20] <Eridius> well yeah. you can diff files too
[00:38:23] <cmr> Actually the delay in the poll is something like 0.003ms iirc, I was thinking of the total overhead of loop (measured by the average of three runs of measuring the time it takes to execute `sleep 1` with the memory measurement loop and subtracting 1 second from that (which still isn't that accurate)
[00:38:35] <Eridius> damn, there's no such thing as a "null" commit, because the author ident cannot be empty
[00:38:40] <brson> servo was using constant evaluation in patterns
[00:39:10] *** Joins: devbug (quassel@moz-E1DE087C.bchsia.telus.net)
[00:39:22] *** Quits: tjc (tjc@moz-24060A8E.firstunitarianportland.org) (Quit: zzzzzzzzzz)
[00:40:00] *** Quits: dylukes (dylukes@moz-E4DF3FED.pitbpa.fios.verizon.net) (Quit: Computer has gone to sleep.)
[00:40:27] <strcat> cmr: any idea of kmem is included in mem?
[00:40:31] <steven_is_false> && is lazy right?
[00:40:32] <strcat> any idea if*
[00:40:45] *** Joins: Jesin (Jessin_@moz-3AD6F09F.res.lehigh.edu)
[00:40:54] <aatch> steven_is_false, if you mean short-circuiting, yes
[00:41:00] <cmr> strcat: I don't think it is.
[00:41:04] <steven_is_false> aatch: Thanks.
[00:41:33] <cmr> strcat: not sure
[00:41:42] <strcat> cmr: and I don't know what happened to CLONE_NEWUSER ;\
[00:41:51] <strcat> doesn't seem to be around anymore
[00:42:10] <Eridius> rusti: false && { println("not lazy"); true }
[00:42:11] -rusti- false
[00:42:14] <Eridius> guess it's lazy
[00:42:34] <aatch> Not lazy, short-circuiting.
[00:42:40] <Eridius> (as it should be, and aatch is right, short-circuiting is the right term)
[00:43:25] <aatch> Sorry, just that lazyness is different. it could be lazy and not be short-circuiting.
[00:43:29] <cmr> rusti: false & { println("nope"); true }
[00:43:30] -rusti- nope
[00:43:30] -rusti- false
[00:43:47] <Eridius> cmr: & can't posssibly be short-circuiting
[00:43:53] <Eridius> although.. why the hell does it work on non-integrals?
[00:43:53] <cmr> Eridius: it isn't
[00:44:04] <cmr> Because it's the non-short-circuit boolean and :)
[00:44:20] <aatch> Eridius, booleans can be though of as 1-bit integrals
[00:44:22] <Eridius> cmr: that's a horrid abuse of C's habit of using integers as booleans
[00:44:32] <strcat> rusti: !false
[00:44:33] -rusti- true
[00:44:34] <strcat> rusti: !5
[00:44:36] -rusti- -6
[00:44:36] <cmr> Eridius: integers aren't booleans
[00:44:37] <Eridius> rusti: false ^ true
[00:44:38] -rusti- true
[00:44:42] <Eridius> cmr: in C they are
[00:44:43] <cmr> rusti: false & 123
[00:44:44] -rusti- <anon>:9:23: 9:26 error: mismatched types: expected `bool` but found `<VI0>` (expected bool but found integral variable)
[00:44:44] -rusti- <anon>:9     let r = {  false & 123
[00:44:44] -rusti-                                 ^~~
[00:44:44] -rusti- error: aborting due to previous error
[00:44:44] -rusti- application terminated with error code 101
[00:44:47] <cmr> Eridius: not in rust
[00:44:52] <Eridius> cmr: yes I know
[00:44:56] <Eridius> rusti: true ^ true
[00:44:57] -rusti- false
[00:45:00] <cmr> Eridius: so... what abuse is it? :\
[00:45:02] <strcat> well they're _Bool in C and it's undef behaviour to store anything but 0 or 1 in them
[00:45:09] <strcat> but C returns int for conditionals ;\
[00:45:13] <aatch> Eridius, C doesn't have booleans. It has values that are considered true or false.
[00:45:17] *** Quits: lmandel (lmandel@556E85CD.E855F8D7.412CF160.IP) (Ping timeout)
[00:45:25] <Eridius> strcat: get your fancy shmancy C99 outta here
[00:45:32] <dbaupp> cmr: update with markers
[00:45:35] <dbaupp> *updated
[00:45:53] *** Quits: nattofriends (tsutsumi@moz-A369A791.warosu.org) (Ping timeout)
[00:45:57] <Eridius> honestly my only real issue with & is the fact that it might hide typos
[00:46:02] <dbaupp> cmr: I have a feeling the passes timing info is slightly skewed
[00:46:07] <strcat> Eridius: well c89 isn't really C anymore because they withdraw the standard when they release an update :)
[00:46:09] *** Joins: Yurume (yurume@AC58A8CE.8A059B47.E313B915.IP)
[00:46:13] *** Quits: nicelydone (Mibbit@moz-BB21156B.dynamic.csail.mit.edu) (Quit: http://www.mibbit.com ajax IRC Client)
[00:46:14] <strcat> C is ISO C11 ;p
[00:46:15] *** Quits: jrfeenst (jrfeenst@moz-F912484F.cpe.norwoodlight.com) (Quit: jrfeenst)
[00:46:24] <Eridius> strcat: hah tell that to Microsot
[00:46:30] <Eridius> *Microsoft. They still don't support C99
[00:46:35] *** Joins: lmandel (lmandel@556E85CD.E855F8D7.412CF160.IP)
[00:46:37] *** Joins: nattofriends (tsutsumi@moz-A369A791.warosu.org)
[00:46:53] <strcat> clang and gcc are both complete C++11 implementations now, MSVC++ is still far away from that
[00:47:15] <strcat> they're consistently bad at that, I bet they have 2 interns working on the compiler in a dark basement
[00:47:26] <strcat> everyone else makes C# slides for conferences
[00:48:03] * aatch pictures frustrated MS kernel devs using clang in secret
[00:48:11] <cmr> they actually have a single STL developer
[00:48:15] <cmr> I don't joke
[00:48:20] <strcat> cmr: they buy their stdlib implementation though
[00:48:37] <cmr> strcat: that doesn't make it work better :p
[00:48:40] <strcat> so he probably doesn't have much to do
[00:49:03] <strcat> cmr: well it's a complete C++11 stdlib implementation but they have to disable lots of it because their compiler sucks :D
[00:49:11] *** Quits: lmandel (lmandel@556E85CD.E855F8D7.412CF160.IP) (Ping timeout)
[00:49:11] <erickt> anyone know if bors is still offline?
[00:49:18] <cmr> erickt: yes
[00:49:24] * erickt pouts
[00:49:28] *** Quits: eholk (eholk@moz-4EB1DCC1.hfc.comcastbusiness.net) (Quit: eholk)
[00:49:34] *** Joins: jrfeenst (jrfeenst@moz-F912484F.cpe.norwoodlight.com)
[00:50:26] <erickt> Given how much money MS has, I wonder why they aren't putting more employees on MSVC. Or are they all working on C#?
[00:50:32] <bblum> hmmm who understands the parser
[00:50:36] <bblum> fn mk_pointer in particular
[00:50:43] <bblum> er, sorry, the astconverter
[00:50:52] <strcat> ahhh conflicts
[00:51:13] <strcat> erickt: well they certainly waste a lot of effort making proprietary extensions to C++
[00:51:20] <erickt> haha
[00:51:21] <strcat> implementing all of actual C++? nope
[00:51:43] <aatch> bblum, what do you want to know?
[00:51:56] <dbaupp> cmr: there we go, "finished" http://www.ug.it.usyd.edu.au/~hwil7821/rust-bench/
[00:51:59] <erickt> bblum: I'm looking too
[00:52:16] <aatch> I don't really know the astconv stuff, but I've been spending a lot of time around there recently
[00:53:06] <bblum> aatch: i added a check to this check_empty_bounds_unless_trait() in two places, (a) in fn mk_pointer() after we match on a ty_path, and (b) in mk_ty() when we match on a ty_path before traversing a pointer (the place where the "bare trait type not supported" error is emitted)
[00:53:19] <bblum> and in one of my test cases i'm getting my error message being emitted twice
[00:53:34] <bblum> this does not seem like it should be the case
[00:54:22] <cmr> dbaupp: rustc is using a different epoch than rust-bench is
[00:54:26] <cmr> which is the skew
[00:54:31] <bblum> and by mk_ty i mean ast_ty_to_ty
[00:54:39] <dbaupp> cmr: oh?
[00:54:52] <brson> graydon: x86_64-unknown-linux-gnu/stage1/test/stdtest-i686-unknown-linux-gnu with opts passed here
[00:55:01] <dbaupp> cmr: so rustc's 0 isn't rust-bench's 0?
[00:55:14] <cmr> dbaupp: as in, the way you do measurements it by subtracting the end from the start... rustc is using a different start, so rust-bench 0 + rustc 0 != 0 :p
[00:55:15] <dbaupp> cmr: would it be possible to get them as close together as possible?
[00:55:48] <cmr> dbaupp: might be able to pass in an argument specifying the origin to use, and use offsets from that instead of absolute duration
[00:55:51] *** Joins: steveklabnik (steveklabn@moz-A4503A72.socal.res.rr.com)
[00:55:53] <brson> oh I'm not valgrinding
[00:55:58] <cmr> would require finagling rustc
[00:56:07] *** Joins: mjrosenb (mjrosenb@moz-B3592BDA.club.cc.cmu.edu)
[00:56:09] <bblum> i also would like some help figuring out what causes "internal error looking up a definition" (lookup_def_tcx())
[00:56:10] <graydon> brson: under valgrind?
[00:56:13] <dbaupp> cmr: could you just "start" rust-bench when rustc starts?
[00:56:17] <graydon> brson: and, er, cross-from-x64?
[00:56:27] <mjrosenb> the llvm3.3 release doesn't mention rust as a compatible project :(
[00:56:29] <dbaupp> cmr: (it might mean you have negatives times, but that's fine.)
[00:56:42] <strcat> mjrosenb: it's not
[00:56:43] <dbaupp> cmr: (fine from my perspective anyway)
[00:56:46] <Ralith> mjrosenb: has rust switched to trunk yet?
[00:57:03] <aatch> mjrosenb, because we aren't
[00:57:22] <aatch> There are a bunch of patches we need to push upstream first.
[00:57:33] <mjrosenb> interesting, in the past, rust always used a version of llvm pulled from trunk
[00:57:35] <graydon> we're _close_ though :)
[00:57:46] <graydon> mjrosenb: no, we've come and gone from trunk
[00:57:48] <mjrosenb> well, I have learned something today!
[00:57:54] <graydon> several times. usually off by a little.
[00:58:14] <cmr> dbaupp: there's no way to know when rustc gets its first timestamp
[00:58:34] <aatch> Right now we can't even land an update to LLVM in rust...
[00:58:44] <dbaupp> cmr: I assume it's basically when it starts
[00:59:22] <cmr> dbaupp: I grab a timestamp right before I execute rustc, there's no way I can get it any closer
[00:59:50] <dbaupp> cmr: oh, right
[01:00:03] <dbaupp> cmr: yeah, that's what I was meaning, and that's as good as we'll get
[01:00:35] <brson> graydon: yeah, it fails under valgrind
[01:01:07] <graydon> brson: something to do with that missing preload?
[01:01:19] <brson> graydon: yes
[01:02:04] *** Parts: ecr (ereed@2557E599.66715431.D25A875A.IP) ()
[01:03:54] <aatch> btw, I committed a fix that ignored LD_PRELOAD in the run::test_inherit_env test. Looks like it was reverted though.
[01:05:57] <cmr> dbaupp: before I go off to bed, is there anything else data-collection-wise that would be good?
[01:08:50] <brson> aatch: what's the commit?
[01:08:50] *** Quits: heftig (heftig@moz-9CF50836.dip0.t-ipconnect.de) (Ping timeout)
[01:08:54] <dbaupp> cmr: not that I can think of (the graph now has labels, btw.)
[01:09:01] <brson> aatch: sorry, what was the hash of your LD_PRELOAD commit?
[01:09:05] <aatch> brson, no idea.
[01:09:22] <aatch> I'll try to dig it up.
[01:10:00] <aatch> It's possible I imagined actually opening a PR for it though.
[01:10:04] *** Joins: pyrac (pyrac@moz-C46184AA.w86-198.abo.wanadoo.fr)
[01:10:22] <aatch> (Though I definitely fixed it)
[01:10:55] <brson> maybe it got lost in the incoming->master switch
[01:11:00] *** Quits: eschweic1 (Adium@2557E599.66715431.D25A875A.IP) (Quit: Leaving.)
[01:11:22] <aatch> brson, nope, some tests broke trying to merge it
[01:11:55] *** Joins: eholk (eholk@moz-9AB4D52F.hsd1.ut.comcast.net)
[01:11:57] *** Quits: pyrac (pyrac@moz-C46184AA.w86-198.abo.wanadoo.fr) (Ping timeout)
[01:12:10] <aatch> so it never got merged. But it's `5ff42ab6c9641437b` on my tree.
[01:12:33] <aatch> Then the PR closed in the switch
[01:12:45] *** Quits: dew (Instantbir@moz-66796D51.dhcp.stls.mo.charter.com) (Ping timeout)
[01:14:52] *** Quits: infynyxx (infynyxx@DB780A29.749BA1D.DCC373F0.IP) (Client exited)
[01:14:57] <bblum> nmatsakis: ping
[01:15:01] *** Joins: jorendorff (jorendorff@moz-2F32ACA3.hsd1.tn.comcast.net)
[01:15:37] <nmatsakis> bblum: pong
[01:15:57] <bblum> can you help me debug "Cannot relate bound region as subregion: br_anon(0)"
[01:16:05] <bblum> trying to compile a simple trait bounds test
[01:16:26] <bblum> backtrace is from check_expr_coercable_to_type and so on
[01:16:29] *** Joins: ysuzuki (ysuzuki@moz-CEDE4EE1.st.itc.keio.ac.jp)
[01:16:48] *** Joins: heftig (heftig@moz-9CF50836.dip0.t-ipconnect.de)
[01:16:55] <nmatsakis> bblum: ok, what is the test?
[01:17:06] <bblum> hang on, let me minimize it, i guess
[01:17:38] <strcat> rusti: let xs = [1, 2, 3, 4, 5]; xs.rposition(|x| *x == 3)
[01:17:41] <bblum> nmatsakis: http://pastebin.mozilla.org/2539903
[01:17:46] -rusti- Some(2)
[01:18:02] *** Joins: dew (Instantbir@moz-66796D51.dhcp.stls.mo.charter.com)
[01:18:07] <strcat> rusti: let xs = [1, 2, 3, 4, 5]; xs.rev_iter().position(|x| *x == 3)
[01:18:07] -rusti- /usr/local/bin/rust.sh: 5: /usr/local/bin/rust.sh: rustc: not found
[01:18:07] -rusti- application terminated with error code 127
[01:18:12] <strcat> huh.
[01:18:17] <strcat> rusti: let xs = [1, 2, 3, 4, 5]; xs.rev_iter().position(|x| *x == 3)
[01:18:18] -rusti- more than 5 lines of output, pastebinned: http://sprunge.us/idQh
[01:18:24] <strcat> rusti: let xs = [1, 2, 3, 4, 5]; xs.rev_iter().position_(|x| *x == 3)
[01:18:25] -rusti- Some(2)
[01:18:51] <bblum> nmatsakis: of course, i'm expecting it to go into some combine code and fail in Sub::bounds
[01:18:55] *** Quits: a__ (a__@moz-250D9B4.nycmny.fios.verizon.net) (Client exited)
[01:19:29] <nmatsakis> bblum: backtrace?
[01:19:31] <bblum> it also dies with the same message with the bounds the other way around, which should pass
[01:19:51] *** Quits: carllerche (carllerche@moz-BF6CB667.hsd1.ca.comcast.net) (Quit: carllerche)
[01:19:56] *** Joins: a__ (a__@moz-250D9B4.nycmny.fios.verizon.net)
[01:20:35] *** Quits: seth (seth@2557E599.66715431.D25A875A.IP) (Input/output error)
[01:20:44] *** Quits: graydon (graydon@3853DDD.39EEDBB3.D758B1AA.IP) (Quit: Leaving.)
[01:21:26] *** Quits: a__ (a__@moz-250D9B4.nycmny.fios.verizon.net) (Client exited)
[01:21:30] <bblum> nmatsakis: http://pastebin.mozilla.org/2539926 anonymous functions trimmed
[01:22:27] *** Joins: a__ (a__@moz-250D9B4.nycmny.fios.verizon.net)
[01:24:02] <erickt> brson: ping
[01:24:03] <nmatsakis> bblum: the problem is that fold_regions_and_ty in middle/ty.rs does not fold the region that appears in a TriaTStore
[01:24:06] <nmatsakis> *TraitStore
[01:24:09] <nmatsakis> bblum: this is a bug
[01:24:26] <nmatsakis> bblum: in particular this line:         ty::mk_trait(cx, def_id, fold_substs(substs, fldr, fldt), st, mutbl)
[01:24:53] <nmatsakis> bblum: the `st` there is passed through unchanged, but if it is `RegionStore(r)` we should be applying `fldr()` to `r`
[01:25:12] <nmatsakis> bblum: because we do not do this, the bound region that appears in the type `&Foo`
[01:25:18] <nmatsakis> bblum: never gets substituted with a free region
[01:25:39] <nmatsakis> bblum: leading to this asserton failure; at that point in the code, any bound reigons should have been replaced with free ones
[01:25:41] *** Joins: dylukes (dylukes@moz-E4DF3FED.pitbpa.fios.verizon.net)
[01:25:44] *** Quits: dylukes (dylukes@moz-E4DF3FED.pitbpa.fios.verizon.net) (Quit: dylukes)
[01:25:45] *** Joins: youknowone (youknowone@A826BD81.8A0DEF81.38747683.IP)
[01:25:45] *** Quits: youknowone (youknowone@A826BD81.8A0DEF81.38747683.IP) (Z:lined (Open Proxy found on your host. Please visit www.blitzed.org/proxy?ip=115.68.131.49 for more information.))
[01:26:15] <brson> erickt: pong
[01:26:53] <erickt> brson: good evening! got a moment to talk about converting from &[u8] to &str?
[01:27:15] <steven_is_false> Where are the comparison operators located? They are not in std::ops.
[01:27:23] <aatch> steven_is_false, std::cmp
[01:27:29] <bblum> nmatsakis: hmm, and i suppose it just never came up because you never had to subtype traits before
[01:27:30] <erickt> brson: kimundi and I have been talking about it off and on, and I was hoping to get a second opinion :)
[01:27:31] <steven_is_false> aatch: Thanks.
[01:27:35] <steveklabnik> is steven_is_false http://static.rust-lang.org/doc/std/cmp.html ?
[01:28:13] <steven_is_false> steveklabnik: Thanks!
[01:28:15] *** Joins: SiegeLord (sl@moz-CAF07B4C.hsd1.ma.comcast.net)
[01:29:25] <bblum> nmatsakis: ok, fixing it in my branch, thank you
[01:29:55] * strcat will just continue on the whole vec cleanup thin
[01:29:57] <strcat> g
[01:30:02] <strcat> going to conflict with *everything* though ;\
[01:30:26] <nmatsakis> bblum: it never came up because &Objects are rather broken and unused.
[01:30:50] <bblum> oh
[01:31:03] <aatch> nmatsakis, it would be nice to have &Objects working, it would make a lot of code in librustc easier to work with.
[01:31:07] <bblum> yeah, i suppose you would have to subtype a &Trait
[01:32:36] *** Quits: nattofriends (tsutsumi@moz-A369A791.warosu.org) (Ping timeout)
[01:32:51] <strcat> hm
[01:35:18] *** Quits: steven_is_false (user@moz-144077DE.bchsia.telus.net) (Ping timeout)
[01:35:54] *** Quits: jensnockert (jensnocker@moz-C5F27039.cust.bredband2.com) (Input/output error)
[01:37:56] *** Joins: nattofriends (tsutsumi@moz-A369A791.warosu.org)
[01:40:12] *** Joins: pyrac (pyrac@moz-C46184AA.w86-198.abo.wanadoo.fr)
[01:41:59] *** Quits: pyrac (pyrac@moz-C46184AA.w86-198.abo.wanadoo.fr) (Ping timeout)
[01:42:00] <bblum> nmatsakis: hmm, i added the fix, and still get the error
[01:42:02] <bblum> ~Traits seem to work fine
[01:42:50] *** Joins: snadon (chatzilla@moz-3BC727E8.mc.videotron.ca)
[01:43:43] <brson> erickt: yes
[01:43:44] <brson> ready
[01:44:15] <nmatsakis> bblum: diff?
[01:45:02] <bblum> nmatsakis: http://pastebin.mozilla.org/2539984
[01:45:16] *** Joins: pcwalton (pcwalton@2557E599.66715431.D25A875A.IP)
[01:45:16] *** ChanServ sets mode: +o pcwalton
[01:45:18] <erickt> brson: :) the crux of the problem is that you can't safely convert from a &[u8] to a &str using str::from_bytes because of str::as_c_str dereferences one byte pass the end of the &str
[01:45:53] <erickt> brson: for real ~strs, this isn't a problem because of the hidden trailing null
[01:46:41] *** Quits: Jesse (jruderman@2557E599.66715431.D25A875A.IP) (Quit: Jesse)
[01:46:52] <erickt> brson: err, it's `str::from_bytes_slice` that's the problem
[01:47:12] <brson> erickt: right
[01:47:21] <nmatsakis> bblum: can you gist output from RUST_LOG=rustc::middle::typeck ?
[01:47:58] <brson> erickt: what is the solution?
[01:48:10] <erickt> brson: I can see two possible apis. First is we change from_bytes to `from_bytes<'a>(&'a [u8], begin: uint, end: uint) -> &'a str`, which checks that the slice of the &[u8] has at least one more byte in it. This is my favorite
[01:48:16] *** cscott is now known as cscottnet_away
[01:48:30] *** Quits: steveklabnik (steveklabn@moz-A4503A72.socal.res.rr.com) (Quit: bye)
[01:49:24] *** Joins: Jesse (jruderman@2557E599.66715431.D25A875A.IP)
[01:49:33] <erickt> brson: two, we provide two apis, one that works for &[u8] that has a trailing null, and one that doesn't, and it's the user's responsibility to use the right function
[01:49:46] * strcat thinks we should should just not null-terminate them
[01:49:50] <strcat> afaik \0 is valid in utf-8
[01:49:56] <strcat> so you can just .push one before calling C
[01:50:03] * strcat shrugs
[01:50:08] *** Joins: MaikKlein (maik@moz-27A63459.dip0.t-ipconnect.de)
[01:50:27] <erickt> strcat: that's a third option :) replace `str::as_c_str` with a fn that copies and get rid of the trailing null
[01:50:31] <strcat> just seems like the wrong case to optimize for (calling legacy C APIs)
[01:51:06] *** Quits: nattofriends (tsutsumi@moz-A369A791.warosu.org) (Ping timeout)
[01:51:09] <strcat> specifically ones using C strings, which means non-binary
[01:52:00] *** Joins: nattofriends (tsutsumi@moz-A369A791.warosu.org)
[01:52:12] <aatch> strcat, there are C apis that are designed to take a string literal.
[01:52:26] <bblum> nmatsakis: http://pastebin.mozilla.org/2539996 there sure is a lot of it
[01:52:36] *** Quits: roo (Mibbit@moz-F3EBFE77.dynamic.ip.windstream.net) (Quit: http://www.mibbit.com ajax IRC Client)
[01:52:38] <brson> my ideal preference is also to not have the invariant that string slices contain an extra character
[01:52:43] <strcat> aatch: yeah, and how many are performance critical/useful?
[01:52:46] <brson> it's just awkward everywhere
[01:53:02] <brson> but, since we do currently have this constraint...
[01:53:05] <erickt> aatch: I think strcat is suggesting replacing `str::as_c_str` with a fn that copies a &str into a temporary *char
[01:53:08] <strcat> compression/hashing/database APIs use ptr + length because they work for binary
[01:53:38] <aatch> Hmm, I guess most of the LLVM functions take a ptr + len
[01:54:06] <strcat> lots of the POSIX functions that matter take ptr + len
[01:54:10] <strcat> they use C strings for filenames
[01:54:29] <strcat> but writes, setting the hostname, etc. are ptr + len
[01:55:10] <erickt> I personally would be also fine getting rid of that trailing null
[01:55:33] *** Quits: Jesse (jruderman@2557E599.66715431.D25A875A.IP) (Quit: Jesse)
[01:55:57] <strcat> aatch: can always explicitly include \0 in a &'static str or .push it to ~str
[01:56:02] <strcat> since it's valid unicode
[01:56:04] <erickt> This would also make calling functions with *char arguments consistently slow
[01:56:16] <strcat> erickt: not necessarily, only if you planned it badly :)
[01:56:21] <erickt> instead of slow in some circumstances
[01:56:25] <erickt> strcat: true :)
[01:56:26] <strcat> you can null terminate them yourself
[01:56:33] <brson> erickt: we could also keep the from_bytes(&[u8]) signature and just say that the resulting string has one less byte than the input?
[01:56:39] *** Joins: Jesse (jruderman@2557E599.66715431.D25A875A.IP)
[01:56:48] *** Joins: nrubin (nathanaelr@moz-CEC5F287.cncdnh.fast07.myfairpoint.net)
[01:56:58] <strcat> heh
[01:57:03] *** Quits: nrubin (nathanaelr@moz-CEC5F287.cncdnh.fast07.myfairpoint.net) (Quit: nrubin)
[01:57:05] <strcat> test_rposition was never updated to use rposition
[01:57:09] <strcat> it tests position
[01:57:11] <strcat> oh well
[01:57:13] <dbaupp> brson: that seems like a huge gotcha
[01:57:27] <aatch> I'd say make &'static str have a trailing null. The only issue is trying to make a nicer API for it.
[01:57:36] *** Quits: jack (jack@moz-F1B36F9F.hsd1.nm.comcast.net) (Quit: Leaving.)
[01:57:48] <strcat> aatch: but you can include it if you need it anyway
[01:58:09] <strcat> rusti: "foo\0"
[01:58:10] -rusti- <anon>:9:12: 9:13 error: unknown string escape: 48
[01:58:11] -rusti- <anon>:9     let r = {  "foo\0"
[01:58:11] -rusti-                      ^
[01:58:11] -rusti- application terminated with error code 101
[01:58:17] <dbaupp> even if literals have a trailing null, not all &'static str do, since they can be .slice'd shorter
[01:58:42] <strcat> yep slices ruin the whole thing, it means you have inconsistent performance
[01:58:45] <strcat> it's a bad thing to rely on
[01:58:53] <strcat> sometimes you copy, sometimes you don't
[01:59:01] *** Quits: Jesse (jruderman@2557E599.66715431.D25A875A.IP) (Quit: Jesse)
[01:59:15] <aatch> I'd rather have inconsistent performance than consistently bad performance.
[01:59:18] <strcat> and all your strings are 1 byte longer, so lots get pushed into the next jemalloc size class (or with SSO, they move off the stack)
[01:59:35] <strcat> aatch: not bad performance
[01:59:44] <strcat> only bad performance if you're determined to use str* APIs
[01:59:55] <dbaupp> aatch: it's not consistently bad: passing a ~str allows the null to be pushed without any more allocations (if it has enough capacity)
[01:59:56] <brson> erickt: your first idea is I guess the best we can do
[02:00:11] <aatch> dbaupp, true, I forgot about that.
[02:00:16] *** Quits: snadon (chatzilla@moz-3BC727E8.mc.videotron.ca) (Ping timeout)
[02:00:38] * dbaupp votes for not having trailing nulls by default
[02:01:01] *** Joins: snadon (chatzilla@moz-3BC727E8.mc.videotron.ca)
[02:01:25] <brson> erickt: maybe we don't need both start and end params though. the only real purpose here is to make the user explicitly ask for 1 less byte than the slice len
[02:01:42] <brson> just a len param that we assert is len -1
[02:01:47] <strcat> erickt: can just .slice().other_api()
[02:01:49] <strcat> brson: *
[02:01:50] <brson> which sounds pretty lame
[02:02:08] <brson> strcat: i don't understand what that was referring to
[02:02:15] <strcat> brson: start/end params
[02:02:18] <strcat> maybe I misinterpreted it
[02:02:42] <strcat> but instead of .foo(start, end, bar) you can do .slice(start, end).foo(bar)
[02:03:06] * strcat hates the _between functions we have atm
[02:03:06] <brson> the other api here is converting from &[u8] to &str and the issue is that doing that with just the slice isn't safe because you don't know if theres an extra byte or not
[02:03:32] <brson> so erickt is proposing to surface that detail in the api itself by requiring the user specify the range of the slice that becomes the string
[02:03:38] *** Quits: MaikKlein (maik@moz-27A63459.dip0.t-ipconnect.de) (Ping timeout)
[02:03:58] *** Quits: KindOne (KindOne@moz-5220B9A5.dynamic.ip.windstream.net) (Ping timeout)
[02:04:19] <nmatsakis> bblum: that output doesn't seem to be complete; it doesn't have anything from the inferencer etc, and I don't see the error? anyway, I gotta go for the night, but I'm happy to look at this tomorrow...
[02:04:37] *** Quits: SiegeLord (sl@moz-CAF07B4C.hsd1.ma.comcast.net) (Quit: WeeChat 0.4.1)
[02:04:40] <bblum> nmatsakis: yeah, i didn't get all of it
[02:04:51] <bblum> this doesn't block me; i can just write my test cases with ~Trait
[02:04:57] <bblum> is there an issue open?
[02:05:07] <nmatsakis> don't know
[02:05:43] <strcat> rusti: let mut s = ~"foo"; s.push(0 as char); s
[02:05:44] -rusti- <anon>:9:35: 9:53 error: type `~str` does not implement any method in scope named `push`
[02:05:44] -rusti- <anon>:9     let r = {  let mut s = ~"foo"; s.push(0 as char); s
[02:05:45] -rusti-                                             ^~~~~~~~~~~~~~~~~~
[02:05:45] -rusti- error: aborting due to previous error
[02:05:45] -rusti- application terminated with error code 101
[02:05:50] <strcat> rusti: let mut s = ~"foo"; s.push_char(0 as char); s
[02:05:52] -rusti- ~"foo\x00"
[02:06:00] <strcat> rusti: let mut s = ~"foo"; s.push_char(0 as char); println(s)
[02:06:01] -rusti- foo0
[02:06:01] -rusti- ()
[02:06:13] <brson> fn from_bytes(buf: &[u8], len: uint) -> &str { assert!(len == buf.len() - 1); ... }
[02:07:13] <brson> this extra bytes is such an ugly detail that every rust programmer is going to have to understand at some point
[02:07:16] <bblum> pcwalton: impl Foo:Owned for Bar
[02:07:32] <strcat> brson: if it means anything, Go doesn't use \0-terminated strings (russ cox hates them ;p)
[02:07:46] <strcat> they don't mix well with slices and \0 is valid anywhere in a string anyway
[02:07:59] *** Quits: zz_kimundi (kimundi@moz-81FBC630.dip0.t-ipconnect.de) (Ping timeout)
[02:08:00] <brson> oh, so maybe null termination *is* the right thing to do
[02:08:03] * brson zing
[02:08:10] *** Joins: KindOne (KindOne@E313C970.A337191.EC6A1518.IP)
[02:08:15] <erickt> haha
[02:08:24] <strcat> their strings are close to ours since they use slicing a lot ;p
[02:08:43] *** Quits: Jesin (Jessin_@moz-3AD6F09F.res.lehigh.edu) (Quit: Leaving)
[02:08:46] <strcat> language's like python don't have string views so including a \0 at the end makes more sense
[02:08:50] <strcat> (but they don't)
[02:09:22] <brson> i think we should drop the nulls too fwiw
[02:09:26] <erickt> anyone have a rough estimate on how many C apis use *char that are performance critical?
[02:10:07] *** Quits: vosen (vosen@moz-266BA656.icpnet.pl) (Connection reset by peer)
[02:10:34] <aatch> if we add the ability to embed a null in a string like "abc\0", then I can't think of any, at least in trans
[02:10:43] <strcat> aatch: we can embed nulls in strings
[02:10:47] <strcat> they are valid utf-8
[02:10:50] *** Joins: SiegeLord (siege@moz-CAF07B4C.hsd1.ma.comcast.net)
[02:10:59] <strcat> it's totally valid to have "foo\0bar\0baz"
[02:11:01] <aatch> strcat, didn't you try it earlier and it not work?
[02:11:13] <strcat> aatch: well the \0 escape doesn't work but there are other ways
[02:11:15] *** Joins: zz_kimundi (kimundi@moz-DD3E166.dip0.t-ipconnect.de)
[02:11:20] <aatch> strcat, that's what I meant.
[02:11:22] <strcat> rusti: "\x00foo\x00bar"
[02:11:23] -rusti- "\x00foo\x00bar"
[02:11:32] <erickt> We'd still have to provide an unsafe as_c_str function for strings that have a null character
[02:11:33] *** zz_kimundi is now known as kimundi
[02:11:46] <erickt> and a safe to_c_str that does a copy
[02:11:53] <strcat> erickt: I don't think we do
[02:11:56] *** Quits: jorendorff (jorendorff@moz-2F32ACA3.hsd1.tn.comcast.net) (Quit: jorendorff)
[02:12:04] <aatch> Simple change to the tokenizer to allow '\0' to be a valid escape.
[02:12:06] *** Quits: k00mi (koomi@moz-DA4B95B4.pools.arcor-ip.net) (Ping timeout)
[02:12:08] <brson> aatch: what branch is your LD_PRELOAD fix on?
[02:12:12] <strcat> can just .push_char(0) when you need it
[02:12:18] <strcat> and if you have to make a copy, it might as well be explicit
[02:12:32] <brson> i guess graydon didn't finish fixing the LD_PRELOAD issue?
[02:12:41] <strcat> let s = x.to_owned(); s.push_char(0);
[02:12:44] <strcat> not painful at all
[02:12:47] <strcat> arguably less painful than a closure
[02:13:11] <strcat> and it should feel bad because it *is* bad ;p
[02:13:24] <aatch> brson, I don't think it is on one anymore.
[02:13:28] *** Joins: infynyxx (infynyxx@moz-E95B370B.nyc.res.rr.com)
[02:13:35] <strcat> anything using \0-termination doesn't support all of utf-8
[02:13:48] <strcat> it's *totally* valid in standard utf-8
[02:13:53] <brson> aatch: oh you gave me the commit id. I'll use that
[02:14:02] <strcat> it's not valid in linux filenames, but I don't think that means much
[02:14:06] <aatch> brson, I was wondering.
[02:14:07] <erickt> strcat: and str::as_c_str stays the same?
[02:14:13] <erickt> where it may or may not do the copy?
[02:14:28] <strcat> erickt: I think we should get rid of it to encourage pushing \0
[02:14:46] <strcat> or encourage using the alternate apis with uint8_t * and size_t
[02:14:48] <brson> me too
[02:14:58] <brson> don't like the unknownable perf of as_c_str
[02:15:41] <erickt> I'll start a branch that tries to get rid of the null
[02:15:58] <brson> erickt: you'll want to talk to graydon about this. he has strong feelings i think
[02:16:10] <brson> aatch: that commit doesn't exist on your remote. do you mind pushing it?
[02:16:23] <aatch> brson, it should be on my remote...
[02:16:36] <strcat> https://www.sqlite.org/c3ref/bind_blob.html example of a *good* C API
[02:16:36] <aatch> https://github.com/Aatch/rust/commit/5ff42ab6c9641437bcbaf7f59cc2f01106721649
[02:16:37] <erickt> brson: I will
[02:16:44] <strcat> If a non-negative fourth parameter is provided to sqlite3_bind_text() or sqlite3_bind_text16() then that parameter must be the byte offset where the NUL terminator would occur assuming the string were NUL terminated. If any NUL characters occur at byte offsets less than the value of the fourth parameter then the resulting string value will contain embedded NULs. The result of expressions involving
[02:16:46] <strcat> strings with embedded NULs is undefined.
[02:16:47] *** Joins: lkuper_ (lkuper@moz-C0CD33ED.hsd1.in.comcast.net)
[02:16:55] <strcat> you can pass strings containing \0 with a given length and they're included as part of the string
[02:17:02] <strcat> only if you pass -1 does it assume it's nul-terminated
[02:17:24] <strcat> but the SQL stuff itself is messed up ;p
[02:17:38] <brson> aatch: it must not be fetching since it's not a head. I don't have it here
[02:17:42] <strcat> sqlite's API is okay... until you venture into SQL expressions >:)
[02:17:55] <strcat> although it lets you plug in your own functions
[02:18:06] <brson> is there any way to fetch a sha1 explicitly?
[02:19:25] <brson> i'll just copy it from github. thanks git
[02:20:00] <bblum> come on librustc
[02:20:06] <bblum> waiting on one more of you so i can go home
[02:21:13] <strcat> if we really wanted we could make CString like haskell
[02:21:40] <strcat> but I don't think it's really as widely used as it seems...
[02:21:40] <erickt> brson: oh, btw, why I wanted to add begin/end to from_bytes_slice is that I'm seeing most of the uses of it do `from_bytes_slice(foo.slice(begin, end))`
[02:21:58] <erickt> strcat: what's special about it? I'm unfamiliar with it
[02:22:26] <strcat> erickt: CString? it's just guaranteed to be \0-terminated
[02:22:35] <strcat> so you have to convert to it
[02:24:40] *** Joins: sankha93 (Instantbir@B9DEEB97.F36055FE.8B6C1D65.IP)
[02:25:41] *** Joins: jack (jack@moz-F1B36F9F.hsd1.nm.comcast.net)
[02:26:07] *** Quits: infynyxx (infynyxx@moz-E95B370B.nyc.res.rr.com) (Client exited)
[02:33:07] <strcat> anyway I think the whole \0 thing is a bad idea ;p
[02:33:29] <strcat> one day someone will have a security whole where half the stack is fully unicode-aware and allows \0, but some function stops at it
[02:33:33] *** Quits: jrfeenst (jrfeenst@moz-F912484F.cpe.norwoodlight.com) (Quit: jrfeenst)
[02:33:38] <strcat> and someone will just make their username admin\0notreally
[02:34:31] <erickt> strcat: speaking of using unicode to hack a systemâ€¦ http://labs.spotify.com/2013/06/18/creative-usernames/
[02:34:44] <Eridius> strcat: reading back up a bit.. I didn't think \0 was valid in utf-8
[02:34:52] <strcat> Eridius: it is! :)
[02:35:03] <strcat> anything that uses it as the end of string marker doesn't support utf-8
[02:35:16] <strcat> https://en.wikipedia.org/wiki/UTF-8#Modified_UTF-8 there are workarounds
[02:35:18] <strcat> but it's not utf-8.
[02:35:41] *** Quits: heftig (heftig@moz-9CF50836.dip0.t-ipconnect.de) (Ping timeout)
[02:36:24] *** Joins: heftig (heftig@moz-9CF50836.dip0.t-ipconnect.de)
[02:36:31] *** Joins: m_kato (m_kato@moz-C286AD9A.bitcat.net)
[02:37:56] <strcat> rusti: let a = "admin"; let b = "admin\0not"; a == b
[02:37:56] -rusti- <anon>:9:38: 9:39 error: unknown string escape: 48
[02:37:57] -rusti- <anon>:9     let r = {  let a = "admin"; let b = "admin\0not"; a == b
[02:37:57] -rusti-                                                ^
[02:37:57] -rusti- application terminated with error code 101
[02:38:01] <strcat> rusti: let a = "admin"; let b = "admin\x00not"; a == b
[02:38:02] -rusti- false
[02:38:20] <dbaupp> rusti: let a = "adminAAAA"; let b = "admin\x00not"; a == b
[02:38:21] -rusti- false
[02:38:27] <dbaupp> strcat: it checks lengths first
[02:38:46] <Eridius> rusti: "admin\x00not".len()
[02:38:47] -rusti- 9
[02:38:49] <strcat> and then uses memcmp or byte-by-byte compares, if it's correct
[02:39:02] <dbaupp> strcat: yup, memcmp
[02:39:27] <strcat> strcmp is only useful for comparing linux filenames ;p
[02:39:27] <dbaupp> strcat: (and the Ord/TotalOrd implementation does similarly)
[02:39:37] *** Joins: mib_cezid7 (Mibbit@64D3DDC4.6B7634FB.8209398B.IP)
[02:39:41] *** Quits: mib_cezid7 (Mibbit@64D3DDC4.6B7634FB.8209398B.IP) (Quit: mib_cezid7)
[02:42:08] *** Joins: pyrac (pyrac@moz-C46184AA.w86-198.abo.wanadoo.fr)
[02:42:15] <strcat> rusti: [1, 2, 3, 4, 5, 6, 7, 8, 9, 10].rposition(|x| *x == 8)
[02:42:17] -rusti- Some(7)
[02:42:25] <strcat> rusti: [1, 2, 3, 4, 5, 6, 7, 8, 9, 10].rev_iter().position_(|x| *x == 8)
[02:42:26] -rusti- more than 5 lines of output, pastebinned: http://sprunge.us/NjbW
[02:42:43] <strcat> rusti: let xs = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]; xs.rev_iter().position_(|x| *x == 8)
[02:42:44] -rusti- Some(2)
[02:43:13] * strcat isn't sure if he should leave rposition around
[02:43:49] *** Quits: pyrac (pyrac@moz-C46184AA.w86-198.abo.wanadoo.fr) (Ping timeout)
[02:44:17] <brson> when in doubt throw it out
[02:44:29] <dbaupp> yeah, I had this problem with str too... I just did it "manually" by subtracting from the length. (on that note, we probably need a (uint, char) CharIndexIterator)
[02:44:49] <strcat> rusti: let xs = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]; xs.rev_iter().position_(|x| *x == 8).unwrap() - xs.len()
[02:44:50] -rusti- 18446744073709551608
[02:44:53] <dbaupp> err, length-1
[02:45:04] <strcat> rusti: let xs = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]; xs.len() - xs.rev_iter().position_(|x| *x == 8).unwrap()
[02:45:05] -rusti- 8
[02:45:10] <strcat> dbaupp: right
[02:45:11] <strcat> hrm
[02:45:21] <dbaupp> (it can be added back in later...)
[02:45:34] <strcat> could be a default method on ReverseIterable
[02:45:47] *** Quits: nattofriends (tsutsumi@moz-A369A791.warosu.org) (Ping timeout)
[02:45:51] <strcat> ReverseIterableContainer, or whatever
[02:47:06] *** Quits: pcwalton (pcwalton@2557E599.66715431.D25A875A.IP) (Quit: pcwalton)
[02:47:07] <dbaupp> yeah
[02:47:33] *** Joins: pnathan (pnathan@moz-F0F9C5F5.pools.spcsdns.net)
[02:47:48] <erickt> strcat: I think I added rposition to find the "." in "foo.bar.txt", as long as .rev_iter().position work, I'm happy
[02:48:29] <strcat> and I want to add .pop_{front,back}{,n} to slices anyway
[02:48:46] <dbaupp> erickt: it doesn't really... since the index it gives is from the back
[02:48:51] <dbaupp> strcat: what do they do?
[02:49:13] <strcat> let xs = [1, 2, 3, 4, 5]; let slice: &[int] = xs; slice.pop_back(3)
[02:49:16] <strcat> would be &[1, 2]
[02:49:27] *** Joins: nattofriends (tsutsumi@moz-A369A791.warosu.org)
[02:49:28] <erickt> dbaupp: well then I don't remember why I added it :)
[02:49:29] <strcat> they're D-isms
[02:49:42] <dbaupp> strcat: oh, right. I put .slice_to and .slice_from on str
[02:50:07] <dbaupp> strcat: "foo".slice_to(1) = "f", "foo".slice_from(1) == "oo"
[02:50:20] <strcat> slices could technically be the vector iterators but they aren't represented in the "perfect" way where it costs only 1 add to increment
[02:50:51] *** Joins: zslayton1 (Mibbit@moz-14AA87A9.nyc.res.rr.com)
[02:50:51] <dbaupp> erickt: I mean, rev_iter().position (indices from the back) isn't a drop-in replacement for .rposition (indices from the front)
[02:50:55] <strcat> (ptr_to_start, ptr_to_end)
[02:50:58] <strcat> or ptr_one_past_end
[02:51:04] <dbaupp> strcat: yeah
[02:51:08] <erickt> dbaupp: ooh
[02:51:27] <erickt> dbaupp: then that's a good reason to keep it around :)
[02:51:55] <erickt> although I guess you could do `foo.len() - foo.rev_iter().position(...)`
[02:52:00] <strcat> -1
[02:52:03] <strcat> ;p
[02:52:08] <strcat> evil off-by-one errors
[02:52:36] <strcat> anyway going to leave it for now
[02:54:29] *** Joins: wilsonk-laptop (kvirc@moz-39EFBFC2.cg.shawcable.net)
[02:54:48] <strcat> erickt: what D does is defining Iterator as "ForwardRange" with pop_front
[02:54:53] *** Quits: wilsonk|2 (kvirc@moz-39EFBFC2.cg.shawcable.net) (Ping timeout)
[02:54:54] <strcat> and then they can also be extended with pop_back
[02:55:09] <strcat> so a vector iterator could really represent a range
[02:55:13] <erickt> that works too
[02:55:33] <strcat> starting to think slices should be represented as 2 pointers ;p
[02:56:08] <strcat> not sure how often the length is taken compared to just bounds checks and reducing the range
[02:56:14] *** Joins: ghrust (ghrust@AC22872E.6A2AE50.F3114085.IP)
[02:56:14] <ghrust> 01[13rust01] 15brson pushed 1 new commit to 06master: 02http://git.io/IgBECw
[02:56:14] <ghrust> 13rust/06master 147f55fc3 15Brian Anderson: std: Work around some failing 'run' tests when valgrinding. #7224...
[02:56:14] *** Parts: ghrust (ghrust@AC22872E.6A2AE50.F3114085.IP) ()
[02:56:18] *** Joins: ghrust (ghrust@614D05BD.6A2AE50.F3114085.IP)
[02:56:18] <ghrust> 01[13rust01] 15brson merged 06master into 06auto: 02http://git.io/5Wlgcg
[02:56:19] *** Parts: ghrust (ghrust@614D05BD.6A2AE50.F3114085.IP) ()
[02:57:10] <erickt> strcat: I think that's what D does. I vaguely remembering that the guy who came up with STL wrote D's range-based iteration api
[02:57:30] <aatch> erickt, not quite
[02:57:33] <strcat> erickt: well, andrei didn't make the STL but he's involved with C++ standardization
[02:57:38] <brson> that may or may not be the last fix to get master green. i'll check up on it later tonight
[02:57:42] *** Quits: brson (brson@2557E599.66715431.D25A875A.IP) (Quit: leaving)
[02:58:13] <aatch> Alex Stepanov (I think) did the STL, Andrei did ranges. He's pretty evangelical about them.
[02:58:23] <aatch> (Source, I used to be in the D community)
[02:58:41] <strcat> we essentially have ranges, just a small subset of them
[02:58:46] *** Joins: dylukes (dylukes@moz-E4DF3FED.pitbpa.fios.verizon.net)
[02:58:52] <strcat> but memory safety means a lot of it isn't possible
[02:59:02] <aatch> I never saw the big deal about them to be honest.
[02:59:10] <strcat> aatch: well, good iterators are a big deal
[02:59:13] <strcat> and that's what ranges are
[02:59:25] <strcat> + they let you do mutation, and bidirectional stuff, and random access stuff
[02:59:25] <aatch> Most of his zeal was focussed on how they are different from C++
[02:59:34] <strcat> so you can implement a sort on any random access container, etc.
[03:00:08] <aatch> but I never saw how that fundamentally made them as awesome as he seemed to think.
[03:00:27] <strcat> they are much nicer than C++ iterators but not really a *huge* leap from external iterators like Boost.Range
[03:00:31] *** Quits: ysuzuki (ysuzuki@moz-CEDE4EE1.st.itc.keio.ac.jp) (Client exited)
[03:00:36] <strcat> (boost range isn't the D-style range, it's just like what rust has now)
[03:02:52] *** Joins: ysuzuki (ysuzuki@moz-3830D141.st.keio.ac.jp)
[03:07:46] *** Joins: roo (Mibbit@moz-F3EBFE77.dynamic.ip.windstream.net)
[03:08:33] *** Quits: ysuzuki (ysuzuki@moz-3830D141.st.keio.ac.jp) (concrete.mozilla.org gravel.mozilla.org)
[03:08:33] *** Quits: dylukes (dylukes@moz-E4DF3FED.pitbpa.fios.verizon.net) (concrete.mozilla.org gravel.mozilla.org)
[03:08:33] *** Quits: zslayton1 (Mibbit@moz-14AA87A9.nyc.res.rr.com) (concrete.mozilla.org gravel.mozilla.org)
[03:08:33] *** Quits: heftig (heftig@moz-9CF50836.dip0.t-ipconnect.de) (concrete.mozilla.org gravel.mozilla.org)
[03:08:33] *** Quits: m_kato (m_kato@moz-C286AD9A.bitcat.net) (concrete.mozilla.org gravel.mozilla.org)
[03:08:33] *** Quits: sankha93 (Instantbir@B9DEEB97.F36055FE.8B6C1D65.IP) (concrete.mozilla.org gravel.mozilla.org)
[03:08:33] *** Quits: kimundi (kimundi@moz-DD3E166.dip0.t-ipconnect.de) (concrete.mozilla.org gravel.mozilla.org)
[03:08:33] *** Quits: Yurume (yurume@AC58A8CE.8A059B47.E313B915.IP) (concrete.mozilla.org gravel.mozilla.org)
[03:08:33] *** Quits: doomlord (doomlod@moz-6651F8D4.range86-145.btcentralplus.com) (concrete.mozilla.org gravel.mozilla.org)
[03:08:33] *** Quits: erickt (Adium@49C4075F.3AC15C18.2321E71E.IP) (concrete.mozilla.org gravel.mozilla.org)
[03:08:33] *** Quits: tgt (tgt@moz-D59EE478.aztw.cable.virginmedia.com) (concrete.mozilla.org gravel.mozilla.org)
[03:08:34] *** Quits: dbaupp (Thunderbir@moz-73E90475.lns20.syd6.internode.on.net) (concrete.mozilla.org gravel.mozilla.org)
[03:08:34] *** Quits: RMF (RMF@7CB4432F.59969257.8D19547B.IP) (concrete.mozilla.org gravel.mozilla.org)
[03:08:34] *** Quits: Earnestly (earnest@6A917A59.5E1FD793.39C00A7A.IP) (concrete.mozilla.org gravel.mozilla.org)
[03:08:34] *** Quits: flowsnake_ (flowsnake@moz-1918C33E.aztw.cable.virginmedia.com) (concrete.mozilla.org gravel.mozilla.org)
[03:08:34] *** Quits: zslayton (Mibbit@BF6B2242.269AFE30.6A3AF4D7.IP) (concrete.mozilla.org gravel.mozilla.org)
[03:08:34] *** Quits: bjz (brendanzab@B398BE78.F804C29E.D35A31DF.IP) (concrete.mozilla.org gravel.mozilla.org)
[03:08:34] *** Quits: Amanieu (amanieu@moz-D5D10CA8.halls.manchester.ac.uk) (concrete.mozilla.org gravel.mozilla.org)
[03:08:34] *** Quits: Jeaye (Jeaye@moz-FD505E54.hsd1.ca.comcast.net) (concrete.mozilla.org gravel.mozilla.org)
[03:08:34] *** Quits: jeltz (andreas@moz-7C6B0B72.tn.glocalnet.net) (concrete.mozilla.org gravel.mozilla.org)
[03:08:34] *** Quits: kini (kini@moz-92AA953A.members.linode.com) (concrete.mozilla.org gravel.mozilla.org)
[03:08:34] *** Quits: robertknight (robertknig@moz-54528EE0.wby.mendeley.com) (concrete.mozilla.org gravel.mozilla.org)
[03:08:34] *** Quits: sk (sk@61A494B3.BA40E8A.AAC02D62.IP) (concrete.mozilla.org gravel.mozilla.org)
[03:08:34] *** Quits: hansjorg (hansjorg@moz-EECB5F79.static.cust.telenor.com) (concrete.mozilla.org gravel.mozilla.org)
[03:08:34] *** Quits: joone (joone@moz-C50DC051.jf.intel.com) (concrete.mozilla.org gravel.mozilla.org)
[03:08:34] *** Quits: barosl (barosl@E287D94F.C81E10FB.7544CABF.IP) (concrete.mozilla.org gravel.mozilla.org)
[03:08:34] *** Quits: cr (anonymous@moz-32D659DA.dip0.t-ipconnect.de) (concrete.mozilla.org gravel.mozilla.org)
[03:08:34] *** Quits: wycats_ (uid79@moz-C944F5EC.irccloud.com) (concrete.mozilla.org gravel.mozilla.org)
[03:08:34] *** Quits: Aetherspawn_BNC (uid6924@moz-A588D045.irccloud.com) (concrete.mozilla.org gravel.mozilla.org)
[03:08:34] *** Quits: geomyidae__ (uid214@moz-C944F5EC.irccloud.com) (concrete.mozilla.org gravel.mozilla.org)
[03:08:34] *** Quits: zootm (calum@moz-DCC1F9C3.sgyl.cable.virginmedia.com) (concrete.mozilla.org gravel.mozilla.org)
[03:08:34] *** Quits: gazoombo (uid6629@moz-C944F5EC.irccloud.com) (concrete.mozilla.org gravel.mozilla.org)
[03:08:34] *** Quits: mixi (mixi@moz-DBD8904A.org) (concrete.mozilla.org gravel.mozilla.org)
[03:08:34] *** Quits: prudhvi (prudhvi@moz-154A460A.supr.io) (concrete.mozilla.org gravel.mozilla.org)
[03:08:34] *** Quits: DasIch (dasich@moz-5EDA591.de) (concrete.mozilla.org gravel.mozilla.org)
[03:08:34] *** Quits: pcdummy (quassel@moz-CF4CA865.page4me.ch) (concrete.mozilla.org gravel.mozilla.org)
[03:08:34] *** Quits: cscottnet_away (cscott@moz-2577C94A.net) (concrete.mozilla.org gravel.mozilla.org)
[03:08:34] *** Quits: Boreeas (Boreeas@moz-F35C832D.boreeas.net) (concrete.mozilla.org gravel.mozilla.org)
[03:08:35] *** Joins: kini (kini@moz-92AA953A.members.linode.com)
[03:08:35] *** Joins: pcdummy (quassel@moz-CF4CA865.page4me.ch)
[03:08:35] *** Joins: prudhvi (prudhvi@moz-154A460A.supr.io)
[03:08:36] *** Joins: DasIch (dasich@moz-5EDA591.de)
[03:08:37] *** Joins: dbaupp (Thunderbir@moz-73E90475.lns20.syd6.internode.on.net)
[03:08:38] *** Joins: flowsnake (flowsnake@moz-1918C33E.aztw.cable.virginmedia.com)
[03:08:39] *** Joins: zz_kimundi (kimundi@moz-DD3E166.dip0.t-ipconnect.de)
[03:08:45] *** Joins: doomlord (doomlod@moz-6651F8D4.range86-145.btcentralplus.com)
[03:08:45] *** Joins: zootm (calum@moz-DCC1F9C3.sgyl.cable.virginmedia.com)
[03:08:46] *** Joins: Yurume (yurume@AC58A8CE.8A059B47.E313B915.IP)
[03:08:47] *** Joins: barosl (barosl@E287D94F.C81E10FB.7544CABF.IP)
[03:08:48] *** Joins: mixi (mixi@moz-DBD8904A.org)
[03:08:48] *** Joins: Earnestly (earnest@6A917A59.5E1FD793.39C00A7A.IP)
[03:08:49] *** Joins: sk (sk@61A494B3.BA40E8A.AAC02D62.IP)
[03:08:49] *** Joins: hansjorg (hansjorg@moz-EECB5F79.static.cust.telenor.com)
[03:08:49] *** concrete.mozilla.org sets mode: +R 
[03:08:50] *** Joins: heftig (heftig@moz-9CF50836.dip0.t-ipconnect.de)
[03:08:56] *** Joins: dylukes (dylukes@moz-E4DF3FED.pitbpa.fios.verizon.net)
[03:08:58] *** Joins: erickt (Adium@49C4075F.3AC15C18.2321E71E.IP)
[03:09:05] *** zz_kimundi is now known as kimundi
[03:09:06] *** Joins: Jeaye (Jeaye@moz-FD505E54.hsd1.ca.comcast.net)
[03:09:16] *** Joins: Amanieu (amanieu@moz-D5D10CA8.halls.manchester.ac.uk)
[03:10:30] <goffrie> rusti: enum E<'self> { Int(int), Ptr(&'self int) }; match Some(1) { Some(x) => Int(x), None => Int(0) }
[03:10:33] -rusti- Int(1)
[03:10:46] <goffrie> hm, didn't work on my machine
[03:10:58] <strcat> rusti is very up-to-date
[03:11:01] <dbaupp> goffrie: what was the complaint?
[03:11:06] <goffrie> error: cannot infer an appropriate lifetime due to conflicting requirements
[03:11:21] <goffrie> my rust is from.. yesterday :)
[03:11:31] <goffrie> but I'm using rusti, not rustc
[03:11:32] <strcat> rusti is from today ;p
[03:11:35] <goffrie> oh okay :p
[03:11:37] <strcat> goffrie: oh
[03:11:40] <strcat> well the bot uses rustc
[03:11:48] <aatch> goffrie, I'm gonna go out on a limb here and say that your code isn't that simple.
[03:13:37] <goffrie> yup, trying to make a good reduced testcase
[03:13:46] *** concrete.mozilla.org sets mode: -R 
[03:13:47] *** Joins: Boreeas (Boreeas@moz-F35C832D.boreeas.net)
[03:14:27] <strcat> 2.17 +R
[03:14:29] <strcat> +R stands for registered nicknames only. As its name implies, only those who are using and have identified to their current nickname (in other words, those who are set to umode +r) are allowed to enter the channel. For informations to umode +r see section section 3.3.
[03:14:31] <strcat> heh
[03:14:33] *** Joins: cowboyd (cowboyd@moz-5476415B.sw.biz.rr.com)
[03:14:34] <strcat> that flood protection is really terrible ;p
[03:14:46] <strcat> net split -> people who aren't identified can't join?
[03:14:53] *** Joins: ksev (DrunkenPan@745B767B.989A61DC.CA5B6332.IP)
[03:15:25] <aatch> strcat, presumably it's so people that try to flood with accounts get stopped.
[03:16:43] <tiffany> this channel has had a few clonebot attacks for whatever reason
[03:16:54] <tiffany> +R is a surefire way to end those
[03:17:17] <strcat> could be less sensitive though
[03:17:30] <strcat> (and the +M one)
[03:17:31] *** Joins: steven_is_false (user@moz-144077DE.bchsia.telus.net)
[03:17:55] <steven_is_false> Hey can anyone figure out why this causes the compiler to crash? http://pastebin.mozilla.org/2540220
[03:18:35] <dbaupp> steven_is_false: what's the error message?
[03:18:58] <dbaupp> steven_is_false: actually... it's probably the `let` pattern matching
[03:19:06] <dbaupp> (is the error an LLVM assertion?)
[03:19:41] <steven_is_false> Top of the backtrace: rust: task failed at 'assertion failed: !bcx.ccx().maps.moves_map.contains(&arg_expr.id)', /home/steven/others/src/rust/src/librustc/middle/trans/callee.rs:811
[03:19:41] <steven_is_false>  
[03:20:15] <dbaupp> oh... nonetheless, does `let lhs = **self; let rhs = **rhs;` in place of the two `let &Matrix ...`'s help?
[03:20:33] <steven_is_false> dbaupp: The recent changes to borrowing prevent that from being allowed
[03:20:46] <dbaupp> 1let lhs = copy **self;`
[03:20:50] <dbaupp> s/1/`/
[03:21:07] <dbaupp> (pattern matching in let's is essentially entirely broken atm.)
[03:21:35] *** Joins: nattoenemies (tsutsumi@moz-4CEEC7AA.warosu.org)
[03:21:37] <dbaupp> at least, for anything beyond `let (a,b,c) = foo`
[03:21:45] <steven_is_false> dbaupp: Even changing it do copies doesn't help
[03:22:06] <dbaupp> as in? it still crashes with the moves_map error?
[03:22:16] *** Quits: nattofriends (tsutsumi@moz-A369A791.warosu.org) (Quit: ã•ã‚ˆãªã‚‰)
[03:22:16] <steven_is_false> dbaupp: yep
[03:22:16] *** nattoenemies is now known as nattofriends
[03:22:40] *** Joins: geomyidae__ (uid214@moz-C944F5EC.irccloud.com)
[03:24:10] <dbaupp> steven_is_false: I don't know... there's half a dozen open issues also featuring that error message... and none have any work-arounds or analysis at all :(
[03:24:52] <steven_is_false> :(
[03:25:20] *** Quits: bytbox (s@moz-D83E9B31.wireless.umd.edu) (Ping timeout)
[03:27:01] *** Quits: heftig (heftig@moz-9CF50836.dip0.t-ipconnect.de) (Ping timeout)
[03:27:42] *** Joins: gazoombo (uid6629@moz-C944F5EC.irccloud.com)
[03:28:28] *** Joins: heftig (heftig@moz-9CF50836.dip0.t-ipconnect.de)
[03:29:24] *** heftig is now known as IRCMonkey3257
[03:31:25] *** Joins: alisdair (textual@moz-EBE9F394.bchsia.telus.net)
[03:31:36] *** Quits: alisdair (textual@moz-EBE9F394.bchsia.telus.net) (Quit: Textual IRC Client: www.textualapp.com)
[03:32:06] *** Joins: bytbox (s@moz-D83E9B31.wireless.umd.edu)
[03:36:17] *** Quits: steven_is_false (user@moz-144077DE.bchsia.telus.net) (Ping timeout)
[03:36:28] *** Joins: steven_is_false (user@moz-144077DE.bchsia.telus.net)
[03:37:55] *** Quits: pnathan (pnathan@moz-F0F9C5F5.pools.spcsdns.net) (Quit: Colloquy for iPhone - http://colloquy.mobi)
[03:43:40] *** Joins: lmandel (lmandel@556E85CD.E855F8D7.412CF160.IP)
[03:44:44] *** Joins: pyrac (pyrac@moz-C46184AA.w86-198.abo.wanadoo.fr)
[03:45:23] *** Quits: lmandel (lmandel@556E85CD.E855F8D7.412CF160.IP) (Ping timeout)
[03:46:31] *** Quits: pyrac (pyrac@moz-C46184AA.w86-198.abo.wanadoo.fr) (Ping timeout)
[03:47:52] *** Joins: alisdair (textual@moz-EBE9F394.bchsia.telus.net)
[03:52:42] *** Quits: dylukes (dylukes@moz-E4DF3FED.pitbpa.fios.verizon.net) (Quit: Computer has gone to sleep.)
[03:53:10] *** Quits: jack (jack@moz-F1B36F9F.hsd1.nm.comcast.net) (Quit: Leaving.)
[03:55:13] *** Joins: jack (jack@moz-F1B36F9F.hsd1.nm.comcast.net)
[03:55:32] *** Joins: dylukes (dylukes@moz-E4DF3FED.pitbpa.fios.verizon.net)
[03:59:44] *** Quits: cowboyd (cowboyd@moz-5476415B.sw.biz.rr.com) (Client exited)
[04:00:30] *** Quits: Earnestly (earnest@6A917A59.5E1FD793.39C00A7A.IP) (Ping timeout)
[04:01:42] *** Joins: bjz (brendanzab@B398BE78.F804C29E.D35A31DF.IP)
[04:02:29] *** Quits: dylukes (dylukes@moz-E4DF3FED.pitbpa.fios.verizon.net) (Quit: Computer has gone to sleep.)
[04:02:29] *** Quits: int3_ (int3_@43CB6079.66715431.D25A875A.IP) (Client exited)
[04:02:34] *** Quits: ksev (DrunkenPan@745B767B.989A61DC.CA5B6332.IP) (Ping timeout)
[04:05:23] *** Quits: SiegeLord (siege@moz-CAF07B4C.hsd1.ma.comcast.net) (Connection reset by peer)
[04:05:31] *** Joins: brson (brson@72B1AFF8.AD1E507F.3688B332.IP)
[04:05:31] *** ChanServ sets mode: +o brson
[04:06:52] *** Joins: dylukes (dylukes@moz-E4DF3FED.pitbpa.fios.verizon.net)
[04:07:27] *** Joins: int3_ (int3_@43CB6079.66715431.D25A875A.IP)
[04:08:12] *** Quits: brson (brson@72B1AFF8.AD1E507F.3688B332.IP) (Ping timeout)
[04:08:39] *** Joins: carllerche (carllerche@6B070D22.7E6A0813.1428D117.IP)
[04:09:22] *** Joins: cowboyd (cowboyd@moz-DD0FF83.lightspeed.austtx.sbcglobal.net)
[04:15:22] *** Joins: brson (brson@5F06B402.AD1E507F.3688B332.IP)
[04:15:22] *** ChanServ sets mode: +o brson
[04:15:57] *** Quits: brson (brson@5F06B402.AD1E507F.3688B332.IP) (Quit: leaving)
[04:16:36] *** Joins: Aetherspawn (Aetherspaw@moz-8811D9F0.static.tpgi.com.au)
[04:16:46] *** Joins: ysuzuki_ (ysuzuki@moz-3830D141.st.keio.ac.jp)
[04:17:18] <Aetherspawn> aw, tree still closed.
[04:17:40] *** Quits: cowboyd (cowboyd@moz-DD0FF83.lightspeed.austtx.sbcglobal.net) (Client exited)
[04:18:28] <steven_is_false> Hoorah for the recent fixes for -Z debug-info!
[04:20:17] *** Joins: brson (brson@5F06B402.AD1E507F.3688B332.IP)
[04:20:17] *** ChanServ sets mode: +o brson
[04:20:54] *** Quits: jack (jack@moz-F1B36F9F.hsd1.nm.comcast.net) (Quit: Leaving.)
[04:22:13] <tikue> rusti: [~"foo", ~"bar"].concat()
[04:22:16] -rusti- ~"foobar"
[04:23:38] <tikue> ^ is there a better way to construct long strings that span multiple lines
[04:24:09] <dbaupp> tikue: string literals can span multiple lines
[04:24:33] <dbaupp> a trailing \ escapes the new line and any indentation
[04:24:42] <tikue> dbaupp: thanks very much :-)
[04:26:55] *** Quits: int3_ (int3_@43CB6079.66715431.D25A875A.IP) (Client exited)
[04:28:23] *** Joins: cowboyd (cowboyd@moz-DD0FF83.lightspeed.austtx.sbcglobal.net)
[04:30:04] *** Joins: jack (jack@moz-F1B36F9F.hsd1.nm.comcast.net)
[04:31:33] *** Quits: cowboyd (cowboyd@moz-DD0FF83.lightspeed.austtx.sbcglobal.net) (Client exited)
[04:34:40] *** Quits: steven_is_false (user@moz-144077DE.bchsia.telus.net) (Client exited)
[04:35:11] *** Joins: steveklabnik (steveklabn@moz-5EF6C37C.socal.res.rr.com)
[04:46:40] *** Quits: erickt (Adium@49C4075F.3AC15C18.2321E71E.IP) (Quit: Leaving.)
[04:47:40] *** Quits: josh (josh@moz-348C4790.hsd1.mn.comcast.net) (Quit: josh)
[04:50:25] *** Quits: dylukes (dylukes@moz-E4DF3FED.pitbpa.fios.verizon.net) (Quit: Computer has gone to sleep.)
[04:56:42] *** Joins: vk (chatzilla@moz-389FEE13.hsd1.ca.comcast.net)
[04:57:42] *** Quits: anri (solancile@moz-A1CFFAE5.hsd1.wa.comcast.net) (Quit: anri)
[04:58:42] *** Quits: hjr3 (hradtke@374E545A.3A8E9B0C.F9D9C60E.IP) (Quit: My MacBook has gone to sleep. ZZZzzzâ€¦)
[05:08:03] <tikue> what would cause rustc to say that not enough type parameters have been provided for an item? I'm trying to call a function parameterized over one type, and I'm providing a type to it
[05:08:45] <aatch> tikue, is it method on a parameterized trait?
[05:08:59] <tikue> aatch: yes it is
[05:09:03] <tikue> how'd you know :P
[05:09:22] <tikue> aatch: I think I see where you're going with this
[05:09:23] <aatch> Then you need to supply the type parameters for that type too.
[05:10:03] <aatch> Or, give rustc enough information to infer.
[05:10:40] <tikue> aatch: that fixed it :D
[05:12:21] *** Joins: int3_ (int3_@43CB6079.66715431.D25A875A.IP)
[05:13:40] *** Joins: Jesin (Jessin_@moz-3AD6F09F.res.lehigh.edu)
[05:14:16] *** Joins: doener (doener@moz-121949B3.unitymediagroup.de)
[05:16:41] *** Quits: roo (Mibbit@moz-F3EBFE77.dynamic.ip.windstream.net) (Quit: http://www.mibbit.com ajax IRC Client)
[05:18:44] *** Quits: ysuzuki_ (ysuzuki@moz-3830D141.st.keio.ac.jp) (Client exited)
[05:19:26] *** Quits: int3_ (int3_@43CB6079.66715431.D25A875A.IP) (Client exited)
[05:19:43] *** Quits: eholk (eholk@moz-9AB4D52F.hsd1.ut.comcast.net) (Quit: eholk)
[05:20:34] *** Joins: ghrust (ghrust@614D05BD.6A2AE50.F3114085.IP)
[05:20:34] <ghrust> 01[13rust01] 15brson pushed 1 new commit to 06master: 02http://git.io/aKvtFw
[05:20:34] <ghrust> 13rust/06master 14fb2765e 15Brian Anderson: rusti: Disable tests on macos harder
[05:20:34] *** Parts: ghrust (ghrust@614D05BD.6A2AE50.F3114085.IP) ()
[05:22:42] <aatch> brson, you show those tests whose boss
[05:22:46] * dbaupp wills master to be green
[05:23:35] <brson> aatch: lol
[05:26:33] *** Joins: tjc (tjc@moz-ACD0E477.hsd1.or.comcast.net)
[05:26:33] *** ChanServ sets mode: +o tjc
[05:26:36] *** Quits: tjc (tjc@moz-ACD0E477.hsd1.or.comcast.net) (Client exited)
[05:27:27] <xenocons> mr anderson
[05:27:35] <xenocons> surprised to see me?
[05:29:28] *** Joins: hjr3 (hradtke@moz-E87BDF1F.socal.res.rr.com)
[05:29:34] *** Joins: azita (Azita@moz-C1FB2A8.hsd1.ca.comcast.net)
[05:33:24] *** Quits: tiffany (kawaii@moz-1E0FE6E8.dhcp.embarqhsd.net) (Ping timeout)
[05:34:07] *** Quits: tikue (tkuehn@2557E599.66715431.D25A875A.IP) (Quit: tikue)
[05:35:51] <brson> xenocons: that's a puzzling question, so I think yes
[05:39:39] <Jeaye> hehe, I like it.
[05:41:18] *** Joins: Cromulent (Cromulent@moz-983B638D.cable.virginmedia.com)
[05:41:31] *** Quits: vk (chatzilla@moz-389FEE13.hsd1.ca.comcast.net) (Quit: ChatZilla 0.9.90 [Firefox 22.0/20130612084701])
[05:43:04] *** Joins: pseudoku (quassel@A565A1F4.C65759D6.274D17D6.IP)
[05:43:39] *** Quits: carllerche (carllerche@6B070D22.7E6A0813.1428D117.IP) (Quit: carllerche)
[05:44:57] *** Quits: azita (Azita@moz-C1FB2A8.hsd1.ca.comcast.net) (Quit: azita)
[05:45:20] *** Quits: pseudoku (quassel@A565A1F4.C65759D6.274D17D6.IP) (Ping timeout)
[05:47:37] *** Joins: pseudoku (quassel@A62A2DDF.CE9E801D.520CDC98.IP)
[05:48:24] *** Joins: orshem (orshem@3545E24A.588A166C.E3D28531.IP)
[05:51:50] *** Quits: pseudoku (quassel@A62A2DDF.CE9E801D.520CDC98.IP) (Ping timeout)
[05:54:19] *** Joins: pseudoku (quassel@BC907535.20B1F350.C28326FD.IP)
[05:56:56] *** Quits: Cromulent (Cromulent@moz-983B638D.cable.virginmedia.com) (Quit: KVIrc 4.2.0 Equilibrium http://www.kvirc.net/)
[05:57:06] *** Quits: pseudoku (quassel@BC907535.20B1F350.C28326FD.IP) (Ping timeout)
[05:57:58] <xenocons> matrix quote :(
[05:58:35] *** Quits: Aetherspawn (Aetherspaw@moz-8811D9F0.static.tpgi.com.au) (Quit: Leaving)
[05:58:38] <aatch> xenocons, only works if you're Hugo Weaving though.
[05:58:48] <xenocons> heh
[05:59:01] *** Joins: pseudoku (quassel@A1BD81E3.AB6E7807.C28326FD.IP)
[06:00:51] *** Quits: pseudoku (quassel@A1BD81E3.AB6E7807.C28326FD.IP) (Ping timeout)
[06:01:00] *** Joins: huddler (Mibbit@moz-486B1BEF.unige.ch)
[06:01:23] *** Quits: huddler (Mibbit@moz-486B1BEF.unige.ch) (Quit: http://www.mibbit.com ajax IRC Client)
[06:02:44] *** Joins: pseudoku (quassel@B06C6AE8.1137763F.C28326FD.IP)
[06:03:57] *** Quits: nattofriends (tsutsumi@moz-4CEEC7AA.warosu.org) (Quit: ã•ã‚ˆãªã‚‰)
[06:04:37] *** Quits: pseudoku (quassel@B06C6AE8.1137763F.C28326FD.IP) (Ping timeout)
[06:05:29] *** Joins: nattofriends (tsutsumi@moz-4CEEC7AA.warosu.org)
[06:06:29] *** Joins: pseudoku (quassel@446D055A.91231D08.520CDC98.IP)
[06:08:11] *** Quits: pseudoku (quassel@446D055A.91231D08.520CDC98.IP) (Ping timeout)
[06:08:48] *** Joins: q66 (q66@6EE9DE40.46454B5D.33AABD5F.IP)
[06:10:08] *** Joins: berak (chatzilla@8FB423B.3A27401E.16E13E53.IP)
[06:10:17] *** Joins: pseudoku (quassel@764ABBB.DACC8C67.520CDC98.IP)
[06:11:17] *** Quits: pseudoku (quassel@764ABBB.DACC8C67.520CDC98.IP) (Connection reset by peer)
[06:11:35] *** Parts: berak (chatzilla@8FB423B.3A27401E.16E13E53.IP) ()
[06:15:44] *** Quits: duckinator (nick@moz-74B346B5.mostlyincorrect.info) (Quit: Nickname collision due to Services enforced nickname change, your nick was overruled)
[06:16:12] <brson> oh my bad
[06:16:18] *** Quits: brson (brson@5F06B402.AD1E507F.3688B332.IP) (Quit: leaving)
[06:17:01] *** Joins: ghrust (ghrust@F6EE6DE3.6A2AE50.F3114085.IP)
[06:17:01] <ghrust> 01[13rust01] 15brson merged 06master into 06auto: 02http://git.io/o-k7aQ
[06:17:01] *** Parts: ghrust (ghrust@F6EE6DE3.6A2AE50.F3114085.IP) ()
[06:17:19] *** Joins: pseudoku (quassel@39F4635A.201D7E23.520CDC98.IP)
[06:17:39] *** Joins: wuwei (wuwei@1A513F49.818D7924.FAA9ED67.IP)
[06:18:34] *** aatch is now known as aatch|gone
[06:18:58] *** Joins: Blei (philipp@moz-96D25F7A.cust.bluewin.ch)
[06:20:04] *** Quits: pseudoku (quassel@39F4635A.201D7E23.520CDC98.IP) (Ping timeout)
[06:22:02] *** Joins: pseudoku (quassel@EA65A522.5FFD4EE0.520CDC98.IP)
[06:22:04] *** Joins: nano (nano@moz-972880B.superkabel.de)
[06:23:51] *** Quits: pseudoku (quassel@EA65A522.5FFD4EE0.520CDC98.IP) (Ping timeout)
[06:28:24] *** Joins: duckinator (nick@moz-74B346B5.mostlyincorrect.info)
[06:28:49] *** Quits: alisdair (textual@moz-EBE9F394.bchsia.telus.net) (Quit: My MacBook Pro has gone to sleep. ZZZzzzâ€¦)
[06:29:34] *** Joins: pseudoku (quassel@63A73D5.CA6AAE21.520CDC98.IP)
[06:29:57] *** Joins: ezkl (ezkl@moz-6733ED12.zoominternet.net)
[06:31:32] *** Quits: pseudoku (quassel@63A73D5.CA6AAE21.520CDC98.IP) (Ping timeout)
[06:34:32] *** Joins: webber46 (webber46@moz-98D2F3C5.cust.bredband2.com)
[06:35:47] *** Joins: Aetherspawn (Aetherspaw@moz-8811D9F0.static.tpgi.com.au)
[06:36:37] *** Quits: lkuper_ (lkuper@moz-C0CD33ED.hsd1.in.comcast.net) (Ping timeout)
[06:37:50] *** Quits: nano (nano@moz-972880B.superkabel.de) (Connection reset by peer)
[06:38:22] *** Joins: SimonSapin (simon@moz-73287A57.zone9.bethere.co.uk)
[06:41:22] *** Joins: int3_ (int3_@43CB6079.66715431.D25A875A.IP)
[06:41:33] *** Quits: steveklabnik (steveklabn@moz-5EF6C37C.socal.res.rr.com) (Quit: Lost terminal)
[06:48:18] *** Joins: ghrust (ghrust@FD7BC443.6A2AE50.F3114085.IP)
[06:48:18] <ghrust> 01[13rust01] 15brson pushed 1 new commit to 06master: 02http://git.io/BJH__Q
[06:48:18] <ghrust> 13rust/06master 141120f8c 15Brian Anderson: std::rt: Work around a dynamic borrowck bug
[06:48:18] *** Parts: ghrust (ghrust@FD7BC443.6A2AE50.F3114085.IP) ()
[06:48:25] *** Joins: ghrust (ghrust@79968228.6A2AE50.F3114085.IP)
[06:48:25] <ghrust> 01[13rust01] 15brson merged 06master into 06auto: 02http://git.io/RxGVMw
[06:48:25] *** Parts: ghrust (ghrust@79968228.6A2AE50.F3114085.IP) ()
[06:53:07] *** Joins: robarnold (rob@BD56354E.DB510C09.6E370BFC.IP)
[06:54:10] *** Joins: roo (Mibbit@moz-75C9FCEA.dynamic.ip.windstream.net)
[06:54:14] *** Joins: sankha93 (Instantbir@BE39845E.105820C5.8B6C1D65.IP)
[06:55:09] *** Joins: tikue (tkuehn@moz-A7CDB794.dia.static.qwest.net)
[06:59:58] *** Quits: hjr3 (hradtke@moz-E87BDF1F.socal.res.rr.com) (Quit: My MacBook has gone to sleep. ZZZzzzâ€¦)
[07:03:05] *** Quits: tikue (tkuehn@moz-A7CDB794.dia.static.qwest.net) (Quit: tikue)
[07:06:22] *** Joins: tikue (tkuehn@moz-A7CDB794.dia.static.qwest.net)
[07:06:29] *** Quits: webber46 (webber46@moz-98D2F3C5.cust.bredband2.com) (Quit: webber46)
[07:11:34] *** Quits: SimonSapin (simon@moz-73287A57.zone9.bethere.co.uk) (Ping timeout)
[07:13:14] *** Joins: webber46 (webber46@moz-98D2F3C5.cust.bredband2.com)
[07:25:40] *** Quits: tikue (tkuehn@moz-A7CDB794.dia.static.qwest.net) (Quit: tikue)
[07:37:56] *** Joins: tikue (tkuehn@moz-A7CDB794.dia.static.qwest.net)
[07:40:04] *** Joins: aatch (aatch@moz-2BB0AC01.cable.telstraclear.net)
[07:47:41] *** Quits: strcat (strcat@moz-54F7FD49.cpe.net.cable.rogers.com) (Quit: WeeChat 0.4.1)
[07:48:49] *** Joins: victorporof (victorporo@70DEDDA.9004F55.9B1E38F4.IP)
[07:49:28] *** Joins: jdm (jdm@moz-801E009D.vlan502.asr1.cdg2.gblx.net)
[07:52:15] *** Quits: orshem (orshem@3545E24A.588A166C.E3D28531.IP) (Quit: Leaving)
[07:56:38] *** Joins: SimonSapin (simon@88F51059.F3BBB17D.144F44FA.IP)
[08:00:17] *** Quits: tikue (tkuehn@moz-A7CDB794.dia.static.qwest.net) (Quit: tikue)
[08:00:41] *** Joins: cr (anonymous@moz-32D659DA.dip0.t-ipconnect.de)
[08:02:18] *** Joins: jorendorff (jorendorff@moz-2F32ACA3.hsd1.tn.comcast.net)
[08:02:39] *** Joins: doener_ (bs@moz-ABF3CB03.fixip.bitel.net)
[08:03:07] *** Quits: jorendorff (jorendorff@moz-2F32ACA3.hsd1.tn.comcast.net) (Quit: jorendorff)
[08:05:49] *** Joins: novabyte (Instantbir@moz-3E0F9699.cable.virginmedia.com)
[08:06:42] *** Quits: doener_ (bs@moz-ABF3CB03.fixip.bitel.net) (Ping timeout)
[08:07:38] *** Joins: doener_ (bs@moz-AA189A5A.unitymedia.biz)
[08:11:19] *** Joins: fabiand (fabiand@moz-AB28A0AF.adsl.alicedsl.de)
[08:11:34] *** Quits: doener_ (bs@moz-AA189A5A.unitymedia.biz) (Quit: leaving)
[08:12:38] *** Joins: nano (nano@moz-972880B.superkabel.de)
[08:12:59] *** Quits: Jeaye (Jeaye@moz-FD505E54.hsd1.ca.comcast.net) (Quit: Don't tell them I was here...)
[08:19:59] *** Quits: Voomer (Voomer@moz-E97E8EB7.br.br.cox.net) (Connection reset by peer)
[08:24:35] *** Joins: berak (chatzilla@B307B3BE.8B38C502.16E13E53.IP)
[08:24:48] *** Joins: dsirenko (mitra@8E712A0.54C21BA0.9F317420.IP)
[08:29:06] *** Parts: berak (chatzilla@B307B3BE.8B38C502.16E13E53.IP) ()
[08:31:19] *** Parts: doomlord (doomlod@moz-6651F8D4.range86-145.btcentralplus.com) (Leaving)
[08:37:00] *** Quits: devbug (quassel@moz-E1DE087C.bchsia.telus.net) (Connection reset by peer)
[08:37:55] *** Joins: CarpNet (ac@moz-FD24B77.sohonet.co.uk)
[08:44:24] *** Joins: jaen (jaen@moz-E0979827.copit.pl)
[08:44:38] *** Joins: doomlord (doomlod@moz-6651F8D4.range86-145.btcentralplus.com)
[08:45:03] <indutny> morning
[08:45:30] <aatch> indutny, evening
[08:45:35] <indutny> heh
[08:46:03] *** Joins: lucian (lucian@6B2B4644.4304AE1E.CE5E78F6.IP)
[08:46:21] *** Quits: doomlord (doomlod@moz-6651F8D4.range86-145.btcentralplus.com) (Quit: Leaving)
[08:46:24] *** Joins: doomlord (doomlod@moz-6651F8D4.range86-145.btcentralplus.com)
[08:47:34] *** Quits: snadon (chatzilla@moz-3BC727E8.mc.videotron.ca) (Ping timeout)
[08:47:49] <indutny> I think I've encountered on interesting bug...
[08:48:00] <indutny> trying to reduce test case for it
[08:48:32] <indutny> yep, gotcha
[08:48:39] <aatch> indutny, ok, what's the bug?
[08:50:19] *** Joins: ysuzuki (ysuzuki@moz-285468F7.net219126120.t-com.ne.jp)
[08:50:37] <indutny> https://gist.github.com/indutny/3b056a4c91ad26680ea8
[08:50:40] <indutny> aatch: try compiling b
[08:50:49] <indutny> oh gosh
[08:50:49] <indutny> sorry
[08:50:50] <indutny> my bad
[08:51:04] <indutny> nvm
[08:51:05] <indutny> hm...
[08:51:08] <indutny> can't figure it out
[08:51:21] <indutny> but I've trait Register in one crate
[08:51:26] <indutny> and struct Register in another
[08:51:33] <indutny> and I'm trying to implement trait for this struct
[08:51:44] <indutny> but rust says that its unknown
[08:51:47] <aatch> indutny, ahhh.. cross-crate is different from, well not cross-crate
[08:51:55] <indutny> well
[08:52:07] <indutny> I'm doing `impl linearscan::Register for Register { â€¦ }`
[08:52:46] <indutny> aaah
[08:52:50] <indutny> use of undeclared module linearscan
[08:52:53] <indutny> that explains
[08:52:55] <aatch> Also, that gist likely has an error, unless you intended to implement a::T when the trait is R
[08:53:10] <indutny> yep
[08:53:17] <indutny> there's another problem here :)
[08:53:23] <indutny> linearscan:: is undefined 
[08:53:28] <indutny> but use linearscan::* works :P
[08:53:47] <dbaupp> indutny: `::linearscan::Register` might work
[08:54:00] <indutny> yes, it does
[08:54:03] <indutny> butâ€¦ why?
[08:54:24] <dbaupp> 'use's are from the global scope always, but local things are, well, locally scoped ;P
[08:54:49] <dbaupp> and so putting `use linearscan;` in the top of that file probably works too
[08:55:02] <dbaupp> (which brings the linearscan from the global scope into the local scope)
[08:55:30] <dbaupp> also, a path with :: is a global path.
[08:56:31] <dbaupp> *a path prefixed with ::
[08:57:18] <indutny> aaah
[08:57:21] <indutny> I see
[08:57:23] <indutny> thank you
[08:57:30] <aatch> which is why if you look at some of the expanded macros, they have stuff like ::std::...
[08:59:32] <dbaupp> (global scope = relative to the crate file, btw, so prefixing a path with :: does nothing in that file)
[08:59:45] <dbaupp> (I think)
[09:05:13] *** Quits: cr (anonymous@moz-32D659DA.dip0.t-ipconnect.de) (Ping timeout)
[09:07:53] *** Joins: davbo (dave@moz-3FFA637C.oucs.ox.ac.uk)
[09:09:06] <indutny> also
[09:09:15] <indutny> what happened to [].each_reverse?
[09:09:31] <aatch> indutny, [].rev_iter()
[09:09:36] <indutny> oh god
[09:09:45] <indutny> ah
[09:09:47] <indutny> and then each()
[09:09:54] <indutny> for [].rev_iter().each() |_| {}
[09:10:00] <indutny> ah no
[09:10:01] <indutny> advance
[09:10:20] *** Joins: cr (anonymous@moz-BD0F2442.dip0.t-ipconnect.de)
[09:10:31] <aatch> rusti: for [1, 2, 3].rev_iter().advance |&a| { println(fmt!("%?", a)); }
[09:10:32] -rusti- more than 5 lines of output, pastebinned: http://sprunge.us/LNBG
[09:10:50] <aatch> bah, stupid rvalues
[09:11:08] <aatch> rusti: let v = [1, 2, 3]; for v.rev_iter().advance |&a| { println(fmt!("%?", a)); }
[09:11:09] -rusti- 3
[09:11:09] -rusti- 2
[09:11:10] -rusti- 1
[09:11:10] -rusti- ()
[09:11:24] <indutny> what about eachi() ?
[09:11:31] <indutny> how can I accomplish the same with iterators?
[09:11:57] <indutny> I'm talking about eachi_reverse
[09:13:01] <aatch> rusti: let v = [1, 2, 3]; for v.rev_iter().enumerate().advance |(i, a)| { println(fmt!("%? %?", i, a)); }
[09:13:03] -rusti- 0 &3
[09:13:03] -rusti- 1 &2
[09:13:03] -rusti- 2 &1
[09:13:03] -rusti- ()
[09:13:28] <indutny> oooh
[09:13:31] <indutny> thank you
[09:14:05] *** Quits: ysuzuki (ysuzuki@moz-285468F7.net219126120.t-com.ne.jp) (Client exited)
[09:14:40] <aatch> rusti: let v = [1, 2, 3, 4, 5, 6]; for v.filter(|&x| x & 1 == 0).rev_iter().enumerate().advance |(i, a)| { println(fmt!("%? %?", i, a)); }
[09:14:42] -rusti- line longer than 150 columns, pastebinned: http://sprunge.us/XiLG
[09:14:56] <indutny> isn't it slower?
[09:15:04] <aatch> indutny, nope
[09:15:09] <indutny> ok, so its lazy
[09:15:21] <aatch> with optimizations it compiles down really well.
[09:16:17] <indutny> ok, so should I use iterators instead of each() ?
[09:16:24] <indutny> its a bit more verbose, you know
[09:16:51] *** Joins: donri (dag@moz-9BB61102.tbcn.telia.com)
[09:17:04] <aatch> rusti: let a = [1, 2, 3, 4]; let b = [1, 2, 3, 4]; for a.iter().chain(b.iter()).advance |x| { println(fmt!("%?", x)); }
[09:17:04] -rusti- <anon>:9:63: 9:88 error: type `std::vec::VecIterator/&<<VI3>>` does not implement any method in scope named `chain`
[09:17:05] -rusti- <anon>:9     let r = {  let a = [1, 2, 3, 4]; let b = [1, 2, 3, 4]; for a.iter().chain(b.iter()).advance |x| { println(fmt!("%?", x)); }
[09:17:05] -rusti-                                                                         ^~~~~~~~~~~~~~~~~~~~~~~~~
[09:17:05] -rusti- error: aborting due to previous error
[09:17:06] -rusti- application terminated with error code 101
[09:17:12] <aatch> rusti: let a = [1, 2, 3, 4]; let b = [1, 2, 3, 4]; for a.iter().chain_(b.iter()).advance |x| { println(fmt!("%?", x)); }
[09:17:14] -rusti- more than 5 lines of output, pastebinned: http://sprunge.us/RHCS
[09:17:30] <aatch> heh.
[09:17:44] <aatch> rusti: let a = [1, 2, 3, 4]; let b = [1, 2, 3, 4]; for a.iter().chain_(b.iter()).advance |x| { print(fmt!("%? ", x)); }
[09:17:46] -rusti- &1 &2 &3 &4 &1 &2 &3 &4 ()
[09:18:11] <aatch> indutny, it is, but the idea is that iterators will get better integrated into the language.
[09:18:30] <indutny> ah
[09:18:32] <indutny> ok
[09:18:40] <aatch> such that advance won't be needed.
[09:18:41] <indutny> I'll probably use each() for now
[09:18:51] <indutny> who knows what you guys will decide next :P
[09:19:08] *** Joins: BizarreCake (BizarreCak@32C9829A.151E84E7.561471F8.IP)
[09:19:12] <aatch> indutny, I think .each may be disappearing...
[09:19:15] <dbaupp> and iterators will likely be faster & safer (to compile and to run) once they're properly integrated
[09:19:36] <dbaupp> indutny: disappearing in the next few days, depending on how fast strcat works
[09:19:59] <indutny> heh
[09:20:00] <indutny> ok
[09:20:00] <aatch> indutny, have a look through std::iterator
[09:20:01] <indutny> thank you
[09:20:04] <indutny> already had
[09:20:21] <indutny> right now it looks like a mess
[09:20:29] <indutny> i.e. advance() is using match...
[09:20:44] <indutny> each() was much leanier to me
[09:21:10] <aatch> indutny, and what is wrong with match?
[09:21:37] <indutny> that's a check, isn't it?
[09:21:39] <dbaupp> it's not that messy... having to define .eachi and .each2 individually is significantly messier.
[09:21:43] <aatch> for an Option, it's no more expensive than an if.
[09:21:48] <aatch> which each did.
[09:21:53] <indutny> ah, ok
[09:22:13] <indutny> well, its the same as while (cur != NULL) cur = cur->next; right?
[09:22:42] <aatch> indutny, only if you're iterating over a linked list.
[09:23:32] <aatch> indutny, here's strcat's post about external iterators.
[09:23:36] <aatch> http://permalink.gmane.org/gmane.comp.lang.rust.devel/4293
[09:25:47] <indutny> thanks
[09:26:00] <aatch> Specifically, this: let mut it = Counter::new(0.0, 1.0)
[09:26:00] <aatch>             .take_while(|x| *x < 10000000.0)
[09:26:00] <aatch>             .transform(|x| x / 2.0)
[09:26:00] <aatch>             .transform(|x| x + 2.0);
[09:26:00] <aatch>         println(it.fold(0.0, |a, b| a + b).to_str())
[09:26:17] <aatch> gets compiled down (after optimization) to this: http://ix.io/5Xl
[09:28:03] <indutny> oh
[09:28:03] <indutny> nice
[09:28:28] <indutny> heh
[09:28:34] <indutny> why are you translating / 2.0 to fmull 0.5?
[09:28:39] <indutny> fmul*
[09:28:45] <indutny> I mean, I know about cost of the operation
[09:28:49] <indutny> but isn't llvm handling it itself?
[09:31:00] <indutny> also, need some help
[09:31:19] *** Quits: aatch (aatch@moz-2BB0AC01.cable.telstraclear.net) (Client exited)
[09:31:24] <indutny> can't figure out why https://github.com/indutny/linearscan.rs/blob/master/src/linearscan/json.rs#L129
[09:31:30] <dbaupp> indutny: that translation is what LLVM is doing
[09:31:40] <indutny> this complains that Value<R> doesn't have to_json() method
[09:31:45] <indutny> why it clearly should have one
[09:32:03] <indutny> ah wait
[09:32:13] <dbaupp> did you impl ToJson?
[09:32:15] <indutny> nvm
[09:32:19] <indutny> I thought it was Value<R>
[09:32:22] <indutny> but it was another struct
[09:32:38] *** Joins: aatch (aatch@moz-2BB0AC01.cable.telstraclear.net)
[09:34:33] <aatch> indutny, sorry, keyboard stopped working...
[09:34:37] <indutny> np
[09:34:50] <aatch> LLVM is the one handling it.
[09:34:52] <indutny> dbaupp: so you what llvm stuff is rust generating?
[09:34:56] <indutny> err
[09:34:57] <indutny> s/you//
[09:35:08] <indutny> ah
[09:35:20] <aatch> That code is LLVM IR post-optimization.
[09:35:21] <indutny> you just posted intermediate representation after opt
[09:35:33] <aatch> Yes, I did say it was after optimization.
[09:35:45] <aatch> <aatch> gets compiled down (after optimization) to this: http://ix.io/5Xl
[09:35:55] <dbaupp> Rust converts the Rust code to -> LLVM IR (essentially without performing any optimisations) and lets LLVM do all the intelligent stuff
[09:36:01] <dbaupp> s/to //
[09:36:05] <indutny> ok
[09:36:10] <indutny> so with phis and everything, right?
[09:36:26] *** Joins: pnkfelix|rcirc (pnkfelix@moz-801E009D.vlan502.asr1.cdg2.gblx.net)
[09:36:27] *** Joins: pnkfelix (pnkfelix@moz-801E009D.vlan502.asr1.cdg2.gblx.net)
[09:37:07] <aatch> unfortunately the IR we put out is just unintelligent, it's downright stupid.
[09:37:43] <dbaupp> (and wrong)
[09:39:32] *** Quits: nonehaxor (nonehaxor@BA9CBAE.4C3B0355.EE6E63A5.IP) (Quit: WeeChat 0.4.0)
[09:40:17] <indutny> em
[09:40:24] <indutny> isn't that sort of problem? :)
[09:40:31] <aatch> indutny, yes.
[09:40:50] *** Joins: nonehaxor (nonehaxor@BA9CBAE.4C3B0355.EE6E63A5.IP)
[09:50:53] *** Joins: Palmik (palmik@moz-5CA3F354.pks.muni.cz)
[09:56:39] *** Joins: k00mi (koomi@moz-DA4B95B4.pools.arcor-ip.net)
[09:58:34] *** Quits: k00mi (koomi@moz-DA4B95B4.pools.arcor-ip.net) (Ping timeout)
[09:59:35] *** Joins: k00mi (koomi@moz-DA4B95B4.pools.arcor-ip.net)
[10:07:09] *** Quits: IRCMonkey3257 (heftig@moz-9CF50836.dip0.t-ipconnect.de) (Ping timeout)
[10:08:58] *** Joins: EXetoC (ex@moz-C741B177.customer.t3.se)
[10:09:32] *** Joins: ysuzuki (ysuzuki@moz-D5A41FD7.bbtec.net)
[10:15:16] *** Quits: sankha93 (Instantbir@BE39845E.105820C5.8B6C1D65.IP) (Ping timeout)
[10:16:13] *** Joins: Earnestly (earnest@6A917A59.5E1FD793.39C00A7A.IP)
[10:19:28] *** Joins: jeltz (andreas@moz-7C6B0B72.tn.glocalnet.net)
[10:19:48] *** Joins: sankha93 (Instantbir@794B2ADF.82126C03.8B6C1D65.IP)
[10:21:01] *** Quits: ssbr (ssbr@moz-2D56B53B.dsl.bell.ca) (Client exited)
[10:21:36] *** Joins: MaikKlein (maik@moz-27A63459.dip0.t-ipconnect.de)
[10:24:56] <aatch> bjz, ping
[10:25:05] *** kimundi is now known as zz_kimundi
[10:26:00] *** Joins: vmx (vmx@moz-68DB8EFC.pools.arcor-ip.net)
[10:27:48] *** Joins: mleise (marco@moz-3468AB5B.pools.arcor-ip.net)
[10:30:44] <indutny> another question
[10:30:50] <indutny> how to use static methods of trait?
[10:31:20] <aatch> indutny, Trait::method()
[10:31:25] <indutny> oh
[10:31:26] <indutny> ok
[10:31:28] <indutny> thanks
[10:32:01] *** Joins: IRCMonkey3257 (heftig@moz-60BEBDB9.dip0.t-ipconnect.de)
[10:34:51] <aatch> msg bjz I made an example, I think it's relevant: https://github.com/bjz/stupid-lang/wiki/Examples
[10:35:02] <aatch> Bah.
[10:41:12] <indutny> gosh
[10:41:29] <indutny> I wonder if it'd be useful for anyone else to wrap code in lets say:
[10:41:37] <indutny> generic <R: Register, G: Group> {
[10:41:39] <indutny> ...
[10:41:39] <indutny> }
[10:41:49] <indutny> and use R and G inside
[10:41:51] <indutny> aatch: what do you think?
[10:42:17] <indutny> that'll remove tons of code from linearscan.rs
[10:42:36] <indutny> and will allow me to add new constraints without modifying every crate
[10:42:43] <aatch> indutny, macros
[10:42:53] <indutny> aatch: you suggest me to wrap all my code in macros? :)
[10:43:12] <aatch> not all of it, just some of it.
[10:43:14] <indutny> its pretty hard to do it using macros
[10:43:27] <indutny> aatch: can't say I wasn't thinking about it
[10:43:42] <indutny> hm...
[10:43:49] <indutny> ok, it might be worth trying
[10:44:07] <indutny> I'm just trying to replace my uint types with enums
[10:44:14] <indutny> user supplied enums
[10:44:21] <indutny> and it requires a lot of generics
[10:45:57] *** Quits: sk (sk@61A494B3.BA40E8A.AAC02D62.IP) (Quit: Leaving)
[10:48:17] <indutny> aatch: but can I share macro between multiple crates?
[10:48:39] <aatch> indutny, not presently.
[10:48:47] <indutny> ok
[10:49:15] <indutny> still I think that `generic <â€¦> { }` is a right tool for this purpose ;)
[10:49:18] <indutny> but I'll try macros
[10:49:34] <indutny> mind if I'll put this on discussion at mailing list?
[10:50:22] <aatch> indutny, go ahead. I doubt it'll get very far though. We are very much trying to lessen the number of features in the code.
[10:50:36] *** Joins: orshem (orshem@3545E24A.588A166C.E3D28531.IP)
[10:53:14] <indutny> aatch: whatever
[10:53:16] <indutny> better ask
[10:55:15] <dbaupp> if/when macros start working properly, something like `generic! { R: Register, G: Group => { fn foo<$R, $G>() { ... } } }` would be possible. (fwiw.)
[10:56:05] <indutny> right now I'm trying to accomplish something like this
[10:56:16] <indutny> but I need a bit complicated thing
[10:56:30] <indutny> probably adding `struct` and `impl` macroses as well
[10:56:38] <indutny> and `trait`
[10:56:46] <indutny> ah meh
[10:56:50] <indutny> only `struct` and `impl`
[10:57:23] <dbaupp> (I don't think bounds on type parameters work for anything other than impl's and fn's)
[10:57:50] <indutny> bounds no
[10:57:54] <indutny> but I need to parametrize structs too
[10:58:05] <indutny> i.e. there could be struct S { k: K }
[10:58:09] <indutny> where K is a parametrized type
[10:58:23] <indutny> and later when I want to add methods for this struct, right now I write
[10:58:32] <indutny> impl<K: Kind> for S<K> { â€¦ }
[10:58:40] <indutny> and that's spread all over my code
[10:58:48] <indutny> because its all parametrized
[10:59:13] <indutny> just for reference, I'm talking about https://github.com/indutny/linearscan.rs/blob/master/src/linearscan/graph.rs
[10:59:50] <indutny> adding new parameter is just too much pain
[10:59:59] <indutny> I either need exportable macros
[11:00:05] <indutny> so I can just replace types
[11:00:10] <indutny> with their definitions
[11:00:29] <indutny> but that'll probably cause a code bloat :(
[11:00:37] *** Quits: novabyte (Instantbir@moz-3E0F9699.cable.virginmedia.com) (Quit: bye bye)
[11:00:51] <indutny> meh, I just need this generics thing
[11:02:07] *** Joins: snearch (snearch@moz-94670B58.pool.mediaways.net)
[11:02:50] <dbaupp> you can group traits via an empty one, e.g. `trait CopyKind : KindHelper + Copy {}` and then you only need to use the one bound
[11:03:23] <dbaupp> (also, Copy is slowly being deprecated, the replacement is Clone.)
[11:04:01] <indutny> hm...
[11:04:03] <indutny> is it working now?
[11:04:09] <indutny> I remember you guys telling me that it wasn't implemented
[11:04:56] <dbaupp> "it"?
[11:05:54] <dbaupp> I think the trait inheritance mostly works, as long as you aren't using trait objects (since e.g. std::num::Num is a trait of this form)
[11:06:03] <indutny> ah ok
[11:06:33] <indutny> well, still it doesn't help that much :)
[11:06:48] <indutny> it solves only half of the problem
[11:07:29] <indutny> I was thinking about creating adapter for this stuff
[11:07:42] <indutny> so instead of rewriting all the lib - I'd just supply user an API
[11:07:51] <indutny> which will convert automatically all enums to uints
[11:07:54] <indutny> and all uints to enums
[11:07:55] <dbaupp> yup, and atm, the solution for the other half is either macros (which can be exported from modules within a crate, but not outside a crate), or just no solution
[11:11:09] *** Quits: ezkl (ezkl@moz-6733ED12.zoominternet.net) (Quit: My MacBook Pro has gone to sleep. ZZZzzzâ€¦)
[11:11:58] *** Joins: ezkl (ezkl@moz-6733ED12.zoominternet.net)
[11:18:51] *** Joins: engla (engla@moz-DBD1D96E.cust.bredbandsbolaget.se)
[11:19:54] *** Joins: jensnockert (jensnocker@moz-C5F27039.cust.bredband2.com)
[11:30:27] *** Quits: BizarreCake (BizarreCak@32C9829A.151E84E7.561471F8.IP) (Quit: Leaving)
[11:30:30] *** Joins: BizarreCake (BizarreCak@32C9829A.151E84E7.561471F8.IP)
[11:30:49] *** Joins: youknowone (youknowone@A826BD81.8A0DEF81.38747683.IP)
[11:30:58] *** Quits: BizarreCake (BizarreCak@32C9829A.151E84E7.561471F8.IP) (Quit: Leaving)
[11:31:14] *** Joins: novabyte (Instantbir@moz-3E0F9699.cable.virginmedia.com)
[11:31:36] <doomlord> theoretically , how much C++ could interface with rust...
[11:31:57] <Amanieu> anything declared as extern "C"
[11:32:12] <doomlord> ... eg could a tool be written to expose a workalike of C++ vtables, or auto-generate C wrappers for overloaded C functions
[11:32:32] <doomlord> vica versa, theoretically could rust 'trait-objects' be exposed in C/C++
[11:32:37] <MaikKlein> bjz, are you fluid in glfw3?
[11:33:21] <doomlord> i know interop with plain C is much easier- and I am happy with personally dropping back to plain C for that purpose 
[11:33:38] <Amanieu> C++ vtables use a different format to rust traits
[11:33:54] <doomlord> i know they're different
[11:34:11] <Amanieu> theoretically you could make a wrapper
[11:34:41] <Amanieu> but it would be quite inconvenient to use, in particular from the rust side with overloaded functions
[11:36:00] <doomlord> i think its possible to translate plain C (minus macros) 1:1 to rust, isn't it?
[11:36:36] <doomlord> (although that means extensive use of unsafe blocks in rust, and the rust code wont be idiomatic)
[11:36:45] <dbaupp> doomlord: goto is slightly annoying to simulate (but not particularly difficult)
[11:37:06] <doomlord> i'd be happy to drop goto
[11:37:51] <doomlord> just considering my options with existing c++ code and how to ensure i can move to rust later..
[11:38:14] <bjz> MaikKlein: yep, decently
[11:42:28] <MaikKlein> bjz, I am trying to port some code from my university from glfw2 to 3 and I have problems with my framebuffer I think. http://pastebin.com/n4bfWu6d . In line 298 I think I can't to sth like this anymore? 
[11:44:23] <MaikKlein> bjz,  I saw that there is "glfwGetFramebufferSize(window, &width, &height);" but the author of that code had 4 different Viewports, I think the line 298 could cause trouble in glfw3?
[11:45:05] <bjz> what makes you think it's an issue with glfw (I'm less experienced with actual opengl)
[11:45:46] *** Joins: sk (sk@1335CD0E.81A8C295.D066974A.IP)
[11:46:46] <bjz> wait
[11:46:48] *** Quits: rusti (rusti@moz-54F7FD49.cpe.net.cable.rogers.com) (Ping timeout)
[11:47:11] <bjz> before you initialise your context, don't you need to set the window hints?
[11:47:19] <MaikKlein> no
[11:47:28] <MaikKlein> I tried to look for fbo window hints
[11:47:31] <MaikKlein> but I could find anyone
[11:47:32] <bjz> ie. the gl version?
[11:48:07] <MaikKlein> do you maybe mean "glfwGetFramebufferSize(window, &width, &height)" ? for glViewport?
[11:49:00] <bjz> there is also #glfw on freenode
[11:49:56] <bjz> as I say, I'm ashamedly inexperienced in actual opengl :P
[11:50:14] <bjz> what does the framebuffer do, and why are you setting it?
[11:51:35] <bjz> (I'm pretty sure I know what it does, I just don't want to embarrass myself :P)
[11:52:19] *** Joins: ramige (ramige@moz-28AD658E.dynamic.ip.windstream.net)
[11:52:33] <bjz> oh I see
[11:52:37] *** Joins: true_droid (Adium@moz-123FD9B8.beck.volia.net)
[11:52:47] <bjz> "Render small views at the top"
[11:52:59] <MaikKlein> I am also learning OpenGL In fact I write my exam computergraphics 2 tomorrow and I just wanted to do defered shading again, I probably just install glfw2 again. The fbo just cotains the information about the image that you want to render.
[11:53:16] *** Quits: orshem (orshem@3545E24A.588A166C.E3D28531.IP) (Ping timeout)
[11:53:20] <MaikKlein> you could save position, normal and color into and FBO 
[11:53:23] <MaikKlein> an*
[11:54:10] <bjz> have you seen the docs? http://www.glfw.org/docs/3.0/
[11:54:11] <MaikKlein> so instead of displaying the image to your monitor you just safe the image in you fbo.
[11:54:14] <MaikKlein> y
[11:54:49] <indutny> hm...
[11:54:57] *** Quits: nano (nano@moz-972880B.superkabel.de) (Connection reset by peer)
[11:55:14] <MaikKlein> so you are actually learning OpenGL as well? :)
[11:55:18] <indutny> src/linearscan/allocator.rs:338:40: 338:78 error: this function takes 1 parameter but 2 parameters were supplied
[11:55:18] <indutny> src/linearscan/allocator.rs:338       if split_pos == max_pos.prev() && self.clobbers(state.group, &max_pos) {
[11:55:18] <indutny>                                                                         ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
[11:55:18] <indutny> src/linearscan/allocator.rs:338:40: 338:78 error: failed to find an implementation of trait linearscan::api::KindHelper<<V486>> for &'r mut linearscan::graph::Graph<'a>
[11:55:18] <indutny> src/linearscan/allocator.rs:338       if split_pos == max_pos.prev() && self.clobbers(state.group, &max_pos) {
[11:55:27] <indutny> any help is welcome
[11:55:27] <indutny> :)
[11:55:33] <indutny> interesting fact
[11:55:37] <indutny> I've two KindHelper traits
[11:55:42] <indutny> in different rs files
[11:55:54] <indutny> and none of them applies to Graph struct
[11:56:12] <dbaupp> do either have a .clobbers method?
[11:56:14] <bjz> MaikKlein: I am, but for my own work. I've done abit, but nothing too advanced. like triangles/cubes/fractal terrain
[11:56:18] <indutny> dbaupp: both
[11:56:22] <dbaupp> https://github.com/mozilla/rust/issues/5898
[11:56:26] <indutny> but before introducing second one - it was working
[11:56:35] <dbaupp> (that issue is *ridiculously* annoying.)
[11:56:38] <dbaupp> oh
[11:56:45] *** Joins: orshem (orshem@3545E24A.588A166C.E3D28531.IP)
[11:56:56] <dbaupp> Um, do you have only one of those traits in scope in your file?
[11:56:59] <bjz> MaikKlein: yeah sorry, I can't really assist. you could try #glfw though
[11:57:03] *** Quits: jdm (jdm@moz-801E009D.vlan502.asr1.cdg2.gblx.net) (Quit: Lost terminal)
[11:57:19] <indutny> dbaupp: yes...
[11:57:24] <indutny> its explicitely imported
[11:57:31] <dbaupp> indutny: yup, that's the problem :(
[11:57:52] <MaikKlein> bjz, no problem really :) What are you trying to create? Or are you just interested in computer graphics?
[11:58:02] <dbaupp> indutny: the solution is to rename the method (there are quite a few in libstd with a trailing underscore for precisely this reason :( ) or not have the traits in cope
[11:58:09] <dbaupp> *scope
[11:58:56] <indutny> oh gosh
[11:59:17] <bjz> MaikKlein: a horribly over-scoped procedural world thingy. I want to be able to generate my art rather than doing it all by hand (which is tedious) http://voyager3.tumblr.com/
[11:59:39] <dbaupp> indutny: yup :( I keep running into it. it is extremely annoying.
[11:59:44] <indutny> hehe
[12:00:40] *** zz_kimundi is now known as kimundi
[12:00:43] <indutny> ok, now it sees both traits
[12:00:47] <indutny> how is that even possible
[12:00:55] <indutny> oh gosh...
[12:01:05] <indutny> looks like its a bad day to implement this stuff :P
[12:02:20] <indutny> I was thinking about starting to implement jit engine itself
[12:02:21] <indutny> but nah
[12:02:32] <indutny> it just stinks right now
[12:03:42] <dbaupp> I guess that the bad days will continue for a few months at least ;P
[12:04:36] *** Joins: ssbr (ssbr@CB3EC984.A5F785DE.396E4C6D.IP)
[12:05:54] <indutny> heh
[12:05:58] <indutny> that's my choice anyway
[12:06:22] <MaikKlein> bjz, it's a nice topic, I am also interested in this but it so complex. Do you want to randomly generate a world and it should look good?
[12:08:47] <MaikKlein> bjz, I think the best thing that I have seen so far was in cryengine, you can generate your terrain with some constraints, you also can generate vegetation. But in the end the artist still has to adjust a lot of things. I also saw a more real procedural world generation in a new space gae, but I can't remeber the name
[12:09:57] <MaikKlein> but it "just" was textured terrain with oceans
[12:10:32] *** Joins: SiegeLord (sl@moz-CAF07B4C.hsd1.ma.comcast.net)
[12:10:35] <aatch> MaikKlein, look at this: http://procworld.blogspot.com.au/
[12:10:43] <aatch> Especially the older stuff.
[12:11:10] <MaikKlein> ah voxelfarm I know
[12:11:26] <dbaupp> aatch: blogspot redirects to .au for NZ?
[12:12:04] <aatch> dbaupp, no, the link I clicked to get to it was a .com.au and it didn't redirect at all.
[12:12:05] *** Joins: MidnightFun (huh@moz-F31B7D19.cpe.net.cable.rogers.com)
[12:12:21] <bjz> aatch: was that mine? :P
[12:12:25] <dbaupp> aatch: oh, how strange
[12:12:33] <aatch> bjz, yes
[12:12:50] *** Quits: MidnightFun (huh@moz-F31B7D19.cpe.net.cable.rogers.com) (User has been banned from Mozilla (no spamming here))
[12:13:38] *** Quits: ezkl (ezkl@moz-6733ED12.zoominternet.net) (Quit: My MacBook Pro has gone to sleep. ZZZzzzâ€¦)
[12:13:57] <bjz> MaikKlein: yes, it is very complex :[
[12:14:10] <bjz> MaikKlein: but that's what makes it fun :)
[12:14:28] <MaikKlein> bjz, are you also interested in city generation?
[12:14:34] <bjz> MaikKlein: also if you give up ultra-realism that helps
[12:14:59] <bjz> MaikKlein: yup
[12:15:12] <bjz> MaikKlein: well more village generation
[12:17:43] <MaikKlein> bjz, it's an really interesting topic. And I would love to see more games with procedural level design.
[12:19:12] *** Quits: aatch (aatch@moz-2BB0AC01.cable.telstraclear.net) (Quit: Leaving)
[12:19:30] *** Joins: msingle (Thunderbir@moz-930E5D97.hr.hr.cox.net)
[12:20:55] <mleise> oh no not again, we had that in the early 90s :p
[12:21:33] <mleise> "Our role playing game world is 129124981294810924 square miles large!" - "Ours is larger!"
[12:22:03] <Yoric> Who cares, mine is toric :)
[12:22:38] * dbaupp wants a game world on a klein bottle
[12:23:13] <bjz> bigger isn't always better
[12:24:32] <bstrie> daggerfall has a game world the size of great britain, but I'll take morrowind any day :P
[12:24:58] <kimundi> dbaupp: Sounds like an interesting idea ;)
[12:25:33] *** Quits: sankha93 (Instantbir@794B2ADF.82126C03.8B6C1D65.IP) (Quit: Instantbird 1.4 -- http://www.instantbird.com)
[12:25:36] <mleise> bstrie: that's what I'm saying
[12:25:55] <bjz> Yoric: asteroids is toroidal isn't it?
[12:26:04] <bjz> *toric
[12:26:06] <dbaupp> bjz: yup
[12:26:20] <dbaupp> (toroidal is correct, isn't it?)
[12:26:27] <Yoric> bjz: I would need to check the formal definition of toroidal, but I think it matches.
[12:26:39] <bstrie> it's toroidal, yeah
[12:26:39] <mleise> well, you get back in on the other side, simply put :p
[12:26:45] <bstrie> gluing top to bottom and left to right does that
[12:26:47] <MaikKlein> when I was 17 or so I created 30 different rooms in blender, and the I randomly put them together in UDK. This was complex enough for me:)
[12:26:52] <dbaupp> projective-plane asteroids would be neat
[12:26:59] *** Joins: judder (maradukewa@D90735BE.FBAA5D2F.78E362FE.IP)
[12:27:05] <dbaupp> (and probably already done, given it's so simple to implement)
[12:27:07] * dbaupp google
[12:27:08] <mleise> MaikKlein: lol, I did that in Half-Life, too
[12:27:14] <dbaupp> *s
[12:27:19] <MaikKlein> mleise, haha
[12:27:23] <mleise> no wait... I just build simple maze parts
[12:27:49] <mleise> probably in a text editor or QuArK
[12:28:28] <mleise> and then assembled them with a Delphi program. best way to get random maps :p
[12:28:30] <bjz> mleise: yeah, see if you limit the size of a procedural world, there is a possibility that that the really rare generation rules may never be invoked for that seed
[12:28:43] <MaikKlein> mleise, I build some sort of an underground station, it was fun but UDK wasn't the best engine for this :( because there is no realtime lighting.
[12:29:00] <bjz> mleise: which is a good thing imo
[12:29:22] <mleise> I always feld closed quarters works well with static radiosity lighting
[12:29:52] *** Quits: snearch (snearch@moz-94670B58.pool.mediaways.net) (Quit: Verlassend)
[12:29:56] <mleise> bjz: I wouldn't want to pay real money for a game based on a procedural world.
[12:30:05] *** Joins: lkuper_ (lkuper@moz-C0CD33ED.hsd1.in.comcast.net)
[12:30:10] <bstrie> mleise: minecraft? :)
[12:30:17] <kimundi> mleise: minecr... damit
[12:30:23] <mleise> Radom item locations and such are great. Yes, including minecraft
[12:30:56] <MaikKlein> because you think it is not polished enough?
[12:31:07] <SiegeLord> What about roguelikes?
[12:31:09] <bstrie> mleise: diablo? nethack?
[12:31:19] <bstrie> actually wait
[12:31:22] <mleise> never played nethack, diablo wasn't random
[12:31:23] <bstrie> nobody has ever paid for nethack :P
[12:31:24] <MaikKlein> diablo is not really random generated at least not diablo3
[12:31:41] <SiegeLord> Diablo 1 and 2 were
[12:32:06] *** Joins: MrFahrenheit (RageOfThou@3FEF494C.29C984D5.783DEDCA.IP)
[12:32:21] <Yoric> Yes, at least Diablo 2 was.
[12:32:28] *** Joins: maxli (maxli@F2D29657.F60B0462.67AC9B1.IP)
[12:32:32] <mleise> MaikKlein: Especially an RPG needs good setups. There is a lot to designing the locations in a way, that it looks natural or awesome or just logical that race X is holding up here
[12:32:33] <bjz> Spelunky?
[12:33:07] <mleise> Diablo 1 wasn't procedurally generated. There was the same butcher in Level 2 over and over again
[12:33:22] *** Joins: BizarreCake (BizarreCak@32C9829A.151E84E7.561471F8.IP)
[12:33:33] <MaikKlein> mleise, I agree but it depends on the game
[12:34:18] <mleise> Looking at Gothic for example. There is no way this could have been generated by some program.
[12:34:51] <SiegeLord> mleise, what... just because one enemy appears on the same level it's not procedurally generated?
[12:35:21] <mleise> SiegeLord: I think the room looked the same as well
[12:35:40] <SiegeLord> And that's the extent of the prefabbed aspect of it
[12:35:51] <SiegeLord> You were not even guaranteed to get a butcher quest every playthrough
[12:38:23] *** Quits: Aetherspawn (Aetherspaw@moz-8811D9F0.static.tpgi.com.au) (Quit: Leaving)
[12:38:44] <mleise> SiegeLord: I only played it twice and nothing appeard random to me back then.
[12:40:34] <engla> diablo 2 at least had random levels but the building blocks might be large, and with some fixed parts
[12:41:27] <mleise> ok, so for this discussion we should have set on a definition of "procedural generation" first :p
[12:41:55] <bstrie> yes, diablo works by gluing together prefabbed rooms in new ways and putting ranom enemies in them
[12:43:29] <mleise> I bet Rust will be used for a whole bunch of new RPGs with rusty two handers, rusty daggers, rusty arrows, rusty chains, ...
[12:43:51] <mleise> I mean which other genre appreciates rust so much?
[12:44:20] <MaikKlein> http://playrust.com/ is also randomly generated afaik
[12:45:01] <mleise> haha great name
[12:45:22] <dbaupp> "-32134 seconds ago"?
[12:45:22] <MaikKlein> :D
[12:45:33] <mleise> it's just not aware of time zones or something
[12:45:49] *** Quits: orshem (orshem@3545E24A.588A166C.E3D28531.IP) (Ping timeout)
[12:46:11] <dbaupp> seems so
[12:46:32] <kimundi> "Rust: Timecorps primary development language since 2354"
[12:50:06] <bjz> dbaupp: haaa, that is very amusing
[12:50:09] <bjz> :)
[13:00:28] *** Quits: BizarreCake (BizarreCak@32C9829A.151E84E7.561471F8.IP) (Quit: Leaving)
[13:00:39] *** Joins: orshem (orshem@3545E24A.588A166C.E3D28531.IP)
[13:09:47] *** Quits: MaikKlein (maik@moz-27A63459.dip0.t-ipconnect.de) (Ping timeout)
[13:14:08] *** Joins: erickt (Adium@49C4075F.3AC15C18.2321E71E.IP)
[13:15:10] *** Joins: sankha93 (Instantbir@B9DEEB97.F36055FE.8B6C1D65.IP)
[13:20:31] *** Joins: saml (sam@moz-14C16814.cst.lightpath.net)
[13:23:16] *** Joins: cowboyd (cowboyd@1D8844A7.1B729417.CEE440B6.IP)
[13:26:26] *** Quits: pnkfelix|rcirc (pnkfelix@moz-801E009D.vlan502.asr1.cdg2.gblx.net) (Input/output error)
[13:28:26] *** Quits: pnkfelix (pnkfelix@moz-801E009D.vlan502.asr1.cdg2.gblx.net) (Quit: Leaving.)
[13:28:27] *** Joins: rubber-duck (rubber-duc@moz-8F879002.dsl.iskon.hr)
[13:30:00] *** Quits: ssbr (ssbr@CB3EC984.A5F785DE.396E4C6D.IP) (Client exited)
[13:32:06] *** Quits: jaen (jaen@moz-E0979827.copit.pl) (Quit: WeeChat 0.4.1)
[13:32:14] *** Joins: jaen (jaen@moz-E0979827.copit.pl)
[13:32:16] <cmr> Was jemalloc indeed the cause of the stack canaries?
[13:33:27] *** Joins: dylukes (dylukes@moz-B5418F79.hsd1.pa.comcast.net)
[13:33:34] <dbaupp> cmr: seems like it
[13:33:38] <dbaupp> (master is almost green!)
[13:33:53] <Blei> cmr: maybe. probably not. according to strcat(?) we are just using our stack incorrectly and jemalloc is much more sensitive to that than glibc malloc
[13:34:09] <Blei> incorrectly, as in, overflowing during failure (somehow)
[13:34:32] <dbaupp> (rustc seems to do a lot of things incorrectly :( )
[13:36:50] *** Quits: a__ (a__@moz-250D9B4.nycmny.fios.verizon.net) (Ping timeout)
[13:39:03] <cmr> Blei: I'd buy that :)
[13:39:54] <cmr> dbaupp: so now that there are a *lot* more configs on auto, which are you pulling data from for isrustfastyet?
[13:39:56] *** Joins: tgt (tgt@moz-D59EE478.aztw.cable.virginmedia.com)
[13:40:03] <dbaupp> cmr: all
[13:40:26] *** Joins: bct (bct@moz-D3BEA05.ed.shawcable.net)
[13:40:36] <dbaupp> cmr: (it only registers anything when all configs pass though, which is why irfy is looking fairly empty atm)
[13:40:49] *** Quits: erickt (Adium@49C4075F.3AC15C18.2321E71E.IP) (Quit: Leaving.)
[13:40:50] <cmr> ah
[13:41:21] <bct> hi. i'm having a lot of fun learning rust but i've run into something that i don't understand
[13:41:25] *** Joins: erickt (Adium@49C4075F.3AC15C18.2321E71E.IP)
[13:41:44] <dbaupp> cmr: (that is to say, I think I'm pulling data from all of them... I haven't been able to test it, because nothing's passed yet.)
[13:41:51] <bct> why does this fail? rusti> let xs = ~[1,2,3]; xs.map(|x| x) 
[13:41:51] <dbaupp> bct: ask away
[13:41:53] *** Joins: vertexclique (vertexcliq@2A4DD1A8.B0B9525A.34FB0D7A.IP)
[13:42:07] <cmr> bct: rusti-the-program is buggy and shouldn't be used
[13:42:10] <bct> fail to compile, i should say.
[13:42:22] *** Joins: jedestep (jedestep@34641662.FB4DE631.66C78B76.IP)
[13:42:25] <dbaupp> what's the complaint?
[13:42:28] <bct> it's not a rusti issue, that was just the easy way to demonstrate it
[13:42:39] <dbaupp> rusti: let xs = ~[1,2,3]; xs.map(|x| x) 
[13:42:55] <dbaupp> hm, rusti's dead
[13:42:58] <cmr> ah borrow error
[13:42:59] *** Joins: infynyxx (infynyxx@moz-E95B370B.nyc.res.rr.com)
[13:43:18] *** Joins: Scriptor (historium@moz-E06F46F0.corp.bitshelter.com)
[13:43:28] <bct> reference is not valid outside of its lifetime [...] only valid for the lifetime & as defined on the block
[13:43:41] <cmr> bct: map gives a borrowed reference to the items you are iterating over. you need to copy if you want to use the item it gives you outside the closure.
[13:44:12] <cmr> so like xs.map(|x| x.clone())
[13:44:37] <bct> and that will just clone the reference, not the whole thing?
[13:44:43] <kimundi> In the case of integers that's as simple as "let xs = ~[1,2,3]; xs.map(|x| *x) " or "let xs = ~[1,2,3]; xs.map(|&x| x) ", but other types need an explicit clone() call
[13:45:47] <cmr> bct: see http://static.rust-lang.org/doc/std/clone.html#trait-clone for details
[13:45:56] <kimundi> bct: Err, not sure what it actually does atm, but the idea behind it is to clone the whole thing
[13:46:03] <cmr> It doesn't clone the reference.
[13:46:08] <cmr> That would be unsafe.
[13:46:16] <cmr> (memory-unsafe that is)
[13:47:25] <kimundi> but you don't necessary _need_ to clone the values, in theory you can just store the reference directly in  the vector, as long as the lifetimes match. But I'm not sure if there are any api hurdles for that atm
[13:48:47] <bct> hrrm. ok, the pointer-logic part of my brain feels broken so i think i'm a bit closer to understanding
[13:48:48] <bct> thanks :)
[13:48:54] *** Joins: Azdle (Azdle@moz-B334B496.hfc.comcastbusiness.net)
[13:49:44] <Blei> arg! how do you do this?
[13:50:03] <Blei> pub type GlueFn<'self> = &'self fn(**i8, *i8); struct Foo<'self> { a: GlueFn }
[13:50:20] <Blei> how do i attach the 'self lifetime to the GlueFn type?
[13:50:42] <Blei> ::<'self> doesn't work
[13:50:48] <Blei> &'self GlueFn doesn't work
[13:51:14] <doener> <'self>
[13:51:22] <doener> a: GlueFn<'self>
[13:51:23] <Blei> doener: it works!
[13:51:27] <Blei> i didn't expect that
[13:51:39] <Blei> why is it <> instead of ::<> here?
[13:51:44] *** Quits: jensnockert (jensnocker@moz-C5F27039.cust.bredband2.com) (Input/output error)
[13:51:47] <kimundi> you only need the :: in an expression I think
[13:52:09] <Blei> hmm, ok
[13:52:11] <kimundi> becuase only in a expression could it be confuased with less and greater
[13:52:21] <Blei> ah, of course
[13:52:38] <kimundi> let x = Foo < Bar > () 
[13:52:44] <Blei> same for all generic types. Option<T> is like this as well
[13:52:50] *** Joins: erickt1 (erickt@49C4075F.3AC15C18.2321E71E.IP)
[13:52:52] <Blei> yeah, i feel slightly stupid now
[13:53:00] *** Quits: erickt1 (erickt@49C4075F.3AC15C18.2321E71E.IP) (Quit: Leaving.)
[13:53:07] *** Quits: erickt (Adium@49C4075F.3AC15C18.2321E71E.IP) (Quit: Leaving.)
[13:53:19] <kimundi> meh, its just a quirky part of rusts grammer, trips everyone up :)
[13:53:41] *** Joins: jensnockert (jensnocker@moz-C5F27039.cust.bredband2.com)
[13:53:42] <doener> won't we get rid of that once we get associated values?
[13:53:51] <doener> s/values/items/
[13:53:58] <kimundi> get rid of what?
[13:54:06] <doener> that notation
[13:54:34] <kimundi> which notation? explicit type params? They will stay
[13:54:49] *** Joins: MaikKlein (maik@moz-27A63459.dip0.t-ipconnect.de)
[13:55:21] <kimundi> what is going to happen is a bit shuffling around of generic params for better structure, but I think the :: are still going to be necessary
[13:55:29] <dbaupp> doener: the notation may change, but there'll always be something like it (and it'll always be designed to be non-ambiguous to parse)
[13:55:51] <kimundi> IF you need them, that is. They are optional (though sometimes necessarry) annotation after all to overwrite inference
[13:56:42] <doener> the <T> syntax outside type declarations, but it's only removed in one of the proposals
[13:57:53] *** Joins: mib_rs3mqy (Mibbit@BBE7C46A.B4F11D08.8612FA94.IP)
[13:59:16] *** Joins: a__ (a__@moz-250D9B4.nycmny.fios.verizon.net)
[14:00:42] *** Quits: webber46 (webber46@moz-98D2F3C5.cust.bredband2.com) (Quit: webber46)
[14:02:02] *** Quits: a__ (a__@moz-250D9B4.nycmny.fios.verizon.net) (Ping timeout)
[14:05:14] *** Quits: roo (Mibbit@moz-75C9FCEA.dynamic.ip.windstream.net) (Quit: http://www.mibbit.com ajax IRC Client)
[14:07:48] *** Parts: wuehlmaus (wuehlmaus@moz-BBCFACA0.de) (Aus, die Maus)
[14:08:24] *** Joins: dan_johnsin (dan_johnsi@6902762D.11B071D.FB9A45AF.IP)
[14:09:01] *** Joins: jdm (jdm@moz-801E009D.vlan502.asr1.cdg2.gblx.net)
[14:16:41] <indutny> hm...
[14:17:03] <indutny> is there any way to make generic type movable?
[14:17:37] <dbaupp> everything is movable... ?
[14:17:56] <dbaupp> a = b; is a move by default
[14:18:04] <indutny> no
[14:18:24] <indutny> impl<K> for S { fn clone_it(k: K) { k } }
[14:18:35] <indutny> what constraints should I put on K in order to make it work?
[14:18:35] *** Quits: donri (dag@moz-9BB61102.tbcn.telia.com) (Client exited)
[14:18:41] <indutny> rusti: 	 impl<K> for S { fn clone_it(k: K) { k } }
[14:18:42] *** Joins: donri (dag@moz-9BB61102.tbcn.telia.com)
[14:19:31] <dbaupp> indutny: rusti's gone
[14:19:37] <indutny> heh
[14:19:37] <indutny> I see
[14:19:56] <dbaupp> indutny: also, that piece of code has at least two things that stop it compiling (the `for` and the incorrect return type on `clone_it`)
[14:20:07] <indutny> yeeah
[14:20:11] <indutny> I see now
[14:20:12] <indutny> whatever
[14:20:12] *** Joins: ksev (DrunkenPan@745B767B.989A61DC.CA5B6332.IP)
[14:20:35] <dbaupp> solved? :)
[14:20:37] <indutny> cannot bind by-move into a pattern guard
[14:20:38] <indutny> no
[14:20:40] <indutny> that's what I get
[14:20:51] <indutny> it was working before when this value's type was RegisterId(uint)
[14:20:56] <Blei> try fn clone_it(k: &self)
[14:20:56] <indutny> right now its generic
[14:21:09] <indutny> wanna see code?
[14:21:21] <cmr> Yes, because the example you gave compiles fine
[14:21:51] <indutny> its pretty big
[14:21:51] <doener> sounds like a match pattern with some "if" guard
[14:21:52] <indutny> as usual
[14:21:52] <indutny> https://github.com/indutny/linearscan.rs
[14:22:21] <indutny> the error happens here https://github.com/indutny/linearscan.rs/blob/master/src/linearscan/allocator.rs#L350
[14:22:34] <indutny> and https://github.com/indutny/linearscan.rs/blob/master/src/linearscan/allocator.rs#L781
[14:22:47] <indutny> in case of 781
[14:22:51] <doener> indutny: Some(ref u) if u.pos == max_pos => ...
[14:22:58] <indutny> r0 and r1 have type R
[14:23:11] <indutny> which has constraints: Clone, Eq, RegisterHelper
[14:23:11] *** Joins: a__ (a__@moz-250D9B4.nycmny.fios.verizon.net)
[14:23:23] <doener> indutny: it would need to move u to execute the if, but it would still need u, if the condition doesn't hold
[14:23:23] <indutny> doener: yes?
[14:23:29] <indutny> well, it was working before generics
[14:23:49] <doener> because uint gets copied, not moved
[14:23:55] <indutny> ok
[14:24:00] <indutny> how can I make my type copyable
[14:24:01] <dbaupp> (copied implicitly)
[14:24:02] <doener> you could also add a Copy bound
[14:24:04] *** Joins: jorendorff (jorendorff@moz-2F32ACA3.hsd1.tn.comcast.net)
[14:24:07] <indutny> great
[14:24:07] <dbaupp> Clone ;)
[14:24:14] <doener> whatever :-)
[14:24:15] <indutny> it has it already
[14:24:16] <indutny> Clone
[14:24:19] <indutny> ah wait
[14:24:22] <indutny> one sec
[14:24:27] <cmr> Clone is not for implicit copyability
[14:24:35] <dbaupp> well, bind by `ref` and call .clone() on that variable
[14:24:38] *** Joins: lmandel (lmandel@556E85CD.E855F8D7.412CF160.IP)
[14:24:38] <dbaupp> cmr: neither is Copy
[14:25:01] <dbaupp> cmr: and Copy is (hopefully/apparently) going to be replaced with Clone
[14:25:23] <doener> indutny: but both errors should be gone if you just use "ref" in the pattern, no need for a copy
[14:25:26] <indutny> heh
[14:25:31] <indutny> there'll be much more errors after it
[14:25:35] <indutny> like 700 :)
[14:25:46] <indutny> because it thinks that this type can't be copied
[14:25:51] <indutny> and it was before
[14:26:02] <indutny> ok, Clone trait doesn't work
[14:26:02] <dbaupp> how recent is your rustc?
[14:26:07] <indutny> dbaupp: latest
[14:26:15] <indutny> 1120f8c
[14:26:37] <indutny> it just can't figure out that UseKind and Register can be copied
[14:26:41] <dbaupp> ok, because `: Copy` used to imply implicit copiability, but now it requires the `copy` keyword definitely
[14:26:52] <indutny> oh no
[14:26:56] <dbaupp> why doesn't Clone work? did you call .clone()?
[14:26:59] <indutny> no
[14:27:08] <indutny> I thought it'll happen implicitely
[14:27:13] <indutny> implicitly*
[14:27:26] <dbaupp> nope... no implicit copying for generics in Rust now
[14:27:34] <indutny> that's what I need :P
[14:27:35] <cmr> indutny: on the plus side, using references instead of copying everywhere should improve performance :)
[14:27:36] <indutny> gosh
[14:27:39] <dbaupp> (for the moment, at least)
[14:28:00] <indutny> cmr: and kill architecture of my code :P
[14:28:09] <indutny> cmr: Register is just an enum
[14:28:18] <indutny> cmr: I don't get why referencing it would work faster
[14:28:21] <indutny> than copying it
[14:28:46] <cmr> copys need to allocate and copy, references are just an address-of... assuming you don't have to clone it explicitly
[14:28:49] *** Quits: jack (jack@moz-F1B36F9F.hsd1.nm.comcast.net) (Quit: Leaving.)
[14:29:01] <indutny> cmr: even for enums?
[14:29:08] <cmr> indutny: for everything
[14:29:12] <indutny> oh god
[14:29:15] <indutny> even implicit?
[14:29:23] <cmr> yes, especially implicit
[14:29:52] <dbaupp> anything that is not a reference has got a chunk of memory allocated just for it (either on the stack or heap)
[14:30:09] <indutny> oh crap
[14:30:53] * dbaupp wishes linux-64-opt-vg would pass
[14:31:39] *** Parts: judder (maradukewa@D90735BE.FBAA5D2F.78E362FE.IP) ()
[14:31:42] *** Quits: doomlord (doomlod@moz-6651F8D4.range86-145.btcentralplus.com) (Quit: Leaving)
[14:32:17] *** Quits: ramige (ramige@moz-28AD658E.dynamic.ip.windstream.net) (Quit: Leaving)
[14:33:49] *** Joins: Aetherspawn_BNC (uid6924@moz-A588D045.irccloud.com)
[14:33:56] <bstrie> would jmalloc be better off as a git submodule?
[14:34:11] <Blei> bstrie: yes, i thought so as well
[14:34:15] <Aetherspawn_BNC> What is jmalloc and why is it such an issue w/ msvc?
[14:34:15] <cmr> bstrie: brson said no because it's small and stable
[14:34:29] <dbaupp> Aetherspawn_BNC: it's a replacement for malloc
[14:34:38] <cmr> Aetherspawn_BNC: jemalloc is a malloc implementation better than the default on every platform except freebsd
[14:34:45] <cmr> (because the default on freebsd is jemalloc)
[14:34:58] <Aetherspawn_BNC> any specifics about why its better
[14:35:05] <dbaupp> Aetherspawn_BNC: much faster
[14:35:11] <dbaupp> less memory fragmentation
[14:35:14] <bstrie> cmr: not necessarily, if it doesn't play nicely with llvm optimizations on windows
[14:35:25] <cmr> less fragmentation, better multi-threaded, faster, less overhead
[14:35:27] *** Joins: erickt (erickt@8C9ECD8F.3A598286.F12515B4.IP)
[14:35:32] <cmr> Aetherspawn_BNC: there's an issue with a bunch of benchmarks, sec..
[14:35:55] <cmr> https://github.com/mozilla/rust/issues/6897
[14:36:24] <cmr> I also benchmarked it on windows and it was 2x faster for the core-map benchmark
[14:36:51] <dbaupp> bstrie: I thought the problem (killing stack-canaries etc) was it interacted poorly with Rust specifically, because rustc does bad/incorrect things
[14:36:56] *** Joins: erickt1 (erickt@8C9ECD8F.3A598286.F12515B4.IP)
[14:36:56] *** Quits: erickt (erickt@8C9ECD8F.3A598286.F12515B4.IP) (Connection reset by peer)
[14:37:48] <cmr> bstrie: it optimizes just like native malloc/free because it uses the same symbol name, afaik there aren't any optimizations that depend on the *exact* platform allocator implementation
[14:39:13] <cmr> Aetherspawn_BNC: jemalloc has msvc support, but it still needs building with autotools
[14:39:18] <cmr> they only have one build system
[14:39:40] <Aetherspawn_BNC> hmm
[14:40:21] <bstrie> cmr: so is strcat mistaken in https://github.com/mozilla/rust/issues/1768#issuecomment-19352238 ?
[14:40:40] <cmr> bstrie: yes
[14:40:49] <bstrie> please leave a comment then :)
[14:40:58] <indutny> another question, if you don't mind :)
[14:41:01] <indutny> what should I use
[14:41:03] <indutny> `copy `
[14:41:04] <cmr> Well, not entirely
[14:41:06] <indutny> or `.clone()`
[14:41:11] <indutny> heh
[14:41:13] <bstrie> indutny: use .clone if it works for you
[14:41:16] <indutny> ok
[14:41:17] <cmr> indutny: .clone() is more forwards-compatible
[14:41:18] <indutny> thank you
[14:41:22] <cmr> `copy` is slated for removal
[14:41:24] <indutny> that's what I thought about it
[14:42:10] <cmr> bstrie: it isn't a drop-in replacement for the *entire* process because it's statically linked into rustrt. If you load a dll that has its own malloc/free (especially if it's not using those symbol names), it won't be using jemalloc.
[14:43:06] <cmr> but strcat noted in irc that different-mallocs was already a problem because of the msvcrt fragmentation on windows
[14:45:32] <doener> hm, not bad, avoiding the alloca/store/load cycle for pass-by-value function arguments reduces compile time for rustc by 7%
[14:45:50] <doener> librustc that is
[14:45:59] <dbaupp> doener: nice!
[14:46:36] <doener> took me quite a while till my brain managed to tell apart the self_mode for the arg, and the self.mode for the arg_datum
[14:47:04] <doener> had all kinds of weird errors and thought I was going crazy
[14:47:46] <dbaupp> heh
[14:48:11] *** Joins: jeff (jeff@moz-F81F6C4E.nyc.biz.rr.com)
[14:48:34] <doener> hm, and it seems I have one left with unreachable code, at least those two tests failed *sigh*
[14:49:02] <doener> fail to compile that is
[14:52:23] *** Joins: jack (jack@moz-F1B36F9F.hsd1.nm.comcast.net)
[14:52:36] *** Quits: davbo (dave@moz-3FFA637C.oucs.ox.ac.uk) (Client exited)
[14:55:21] *** Joins: cscottnet (cscott@moz-2577C94A.net)
[14:55:27] <nmatsakis> aatch|gone: nice work on the trans refactor, I am rebasing over it, I like having the more specific CrateContext types.
[14:55:33] <cmr> dbaupp: http://octayn.net/data-nojemalloc.json.xz
[14:55:41] <cmr> dbaupp: current master, which doesn't use jemalloc
[14:55:45] <cmr> dbaupp: should be nice comparison :)
[14:56:10] <indutny> instantiating a type parameter with an incompatible type `~linearscan::graph::Use<'a,'b>`, which does not fulfill `Copy`
[14:56:13] <indutny> what could this mean?
[14:56:29] <nmatsakis> indutny: most likely it means that the type parameters are not copyable
[14:56:32] <indutny> happens when giving ~[~Use] to filtered
[14:56:38] <indutny> method
[14:56:47] <indutny> ok, how can I fix it? :)
[14:57:05] <nmatsakis> indutny: need a bit more context, what is the fn where this occurs? how is Use defined?
[14:57:15] <indutny> well, Use is a generic struct
[14:57:19] <indutny> struct<G, R> Use { â€¦ }
[14:57:24] <indutny> with derived Clone trait
[14:57:36] *** cscottnet is now known as cscott
[14:57:38] <indutny> I've field : uses: ~[~Use<G,R> ] in another struct
[14:57:42] <indutny> and I'm trying to filter it
[14:57:50] <nmatsakis> indutny: yeah, while copy is slated for removal, it's still used in the std library, unfortuantely,
[14:58:00] <indutny> oh, so it just won't work
[14:58:10] <nmatsakis> indutny: so you will need to declare G:Copy, R:Copy or whatever
[14:58:28] <nmatsakis> indutny: if you want to use filtered.
[14:58:31] <indutny> oh
[14:58:32] <indutny> thanks
[14:58:46] <nmatsakis> indutny: perhaps Copy+Clone if you are using Clone already
[14:58:47] <indutny> yikes
[14:58:47] <indutny> working!
[14:58:47] <indutny> :)
[14:58:49] <indutny> yep
[14:59:16] <indutny> no
[14:59:17] <indutny> it doesn't
[14:59:25] <indutny> should I implement Copy for Use too?
[14:59:39] <nmatsakis> indutny: you can't implement Copy, it's automatic.
[14:59:53] <nmatsakis> indutny: how does it not work? same error as before? can you gist the fn in question?
[15:00:01] <indutny> failed to find an implementation of trait std::kinds::Copy for emulator::Register
[15:00:14] <indutny> and if I add `impl Copy for Register` its the same as above
[15:00:19] *** Quits: infynyxx (infynyxx@moz-E95B370B.nyc.res.rr.com) (Client exited)
[15:00:33] <indutny> nmatsakis: https://github.com/indutny/linearscan.rs/blob/master/src/linearscan/allocator.rs#L745
[15:00:41] <indutny> but all other code has changed
[15:00:46] <indutny> haven't commited it yet
[15:01:09] *** Joins: davbo (dave@moz-3FFA637C.oucs.ox.ac.uk)
[15:02:11] <nmatsakis> indutny: ok, well, probably need to see the rest too
[15:02:42] *** kimundi is now known as zz_kimundi
[15:02:43] <indutny> ok, https://github.com/indutny/linearscan.rs/blob/master/src/linearscan/allocator.rs#L746
[15:02:48] <indutny> nmatsakis: just pushed
[15:03:06] <indutny> use is defined here https://github.com/indutny/linearscan.rs/blob/master/src/linearscan/graph.rs#L94
[15:03:21] *** Joins: infynyxx (infynyxx@moz-E95B370B.nyc.res.rr.com)
[15:03:21] <indutny> reg and group there https://github.com/indutny/linearscan.rs/blob/master/src/linearscan/api.rs#L17
[15:03:44] <indutny> and "failed to find implementation" is happening here https://github.com/indutny/linearscan.rs/blob/master/test/emulator.rs#L95
[15:04:17] <nmatsakis> indutny: what is type of get_interval?
[15:04:25] <orshem> can a function call appear in a match arm?
[15:04:30] <nmatsakis> orshem: yes.
[15:04:30] <indutny> https://github.com/indutny/linearscan.rs/blob/master/test/emulator.rs#L95
[15:04:32] <indutny> oops
[15:04:36] <indutny>   pub fn get_interval<'r>(&'r self, id: &IntervalId) -> &'r ~Interval<G, R> {
[15:04:37] *** Joins: zslayton (Mibbit@BF6B2242.269AFE30.6A3AF4D7.IP)
[15:04:44] <orshem> i get error "error: expected `,` but found `.`" when matching on a tuple
[15:05:17] *** Quits: ysuzuki (ysuzuki@moz-D5A41FD7.bbtec.net) (Client exited)
[15:05:17] <nmatsakis> orshem: please pastebin/gist the code somewhere.
[15:06:52] *** Quits: msingle (Thunderbir@moz-930E5D97.hr.hr.cox.net) (Ping timeout)
[15:07:14] <nmatsakis> indutny: so, where did you add the Copy bounds? I think you would want to add them here https://github.com/indutny/linearscan.rs/blob/master/src/linearscan/allocator.rs#L183
[15:07:29] <dbaupp> cmr: http://www.ug.it.usyd.edu.au/~hwil7821/rust-bench/noje.html
[15:07:30] <indutny> I added them in api.rs
[15:07:36] <indutny> in trait definition
[15:07:36] <indutny> https://github.com/indutny/linearscan.rs/blob/master/src/linearscan/api.rs#L17
[15:07:53] *** Quits: jedestep (jedestep@34641662.FB4DE631.66C78B76.IP) (Quit: jedestep)
[15:08:10] <orshem> nmatsakis: thanks for taking a look: https://gist.github.com/anonymous/5815026
[15:08:13] *** Quits: infynyxx (infynyxx@moz-E95B370B.nyc.res.rr.com) (Client exited)
[15:08:15] <nmatsakis> indutny: oh, I see, yes, so, in principle that should work, but there are bugs.
[15:08:15] <orshem> in the contain fn
[15:08:22] <indutny> aha
[15:08:28] <indutny> ok
[15:08:29] <indutny> thank you
[15:08:36] <indutny> I'll figure out something
[15:08:54] <nmatsakis> indutny: I think you must do G:RegisterHelper+Copy (or whatever)
[15:09:00] <dbaupp> cmr: and with that, I'm off to bed.
[15:09:05] <indutny> nmatsakis: ok
[15:09:06] <nmatsakis> orshem: if you omit `{}` in a match arm, you must have a comma
[15:09:09] <cmr> dbaupp: hm, it seems either memory cgroups don't madvise-free'd pages, or jemalloc is a memory lose!
[15:09:11] <indutny> thank you
[15:09:17] <nmatsakis> orshem: e.g., foo => return 22,
[15:09:24] <nmatsakis> orshem: not `foo => return 22` as you wrote
[15:09:39] <cmr> will ask strcat later.
[15:09:40] <dbaupp> cmr: yeah, looks like it (on linux x64(?) at least)
[15:09:42] <cmr> dbaupp: sleep well :)
[15:09:50] <indutny> nmatsakis: but unfortunately this doesn't work too :(
[15:09:55] <orshem> nmatsakis: thanks. i knew it had to be something stupid like this
[15:10:37] <indutny> nmatsakis: I'll use retain
[15:10:54] *** Quits: MaikKlein (maik@moz-27A63459.dip0.t-ipconnect.de) (Ping timeout)
[15:12:50] *** Joins: Cromulent (Cromulent@moz-983B638D.cable.virginmedia.com)
[15:13:03] *** Quits: mib_rs3mqy (Mibbit@BBE7C46A.B4F11D08.8612FA94.IP) (Quit: http://www.mibbit.com ajax IRC Client)
[15:13:13] *** Joins: hjr3 (hradtke@374E545A.3A8E9B0C.F9D9C60E.IP)
[15:14:14] *** Quits: dbaupp (Thunderbir@moz-73E90475.lns20.syd6.internode.on.net) (Ping timeout)
[15:14:55] *** Quits: ksev (DrunkenPan@745B767B.989A61DC.CA5B6332.IP) (Ping timeout)
[15:16:18] *** Joins: tiffany (kawaii@moz-1E0FE6E8.dhcp.embarqhsd.net)
[15:20:37] <Blei> ugh, tidy error
[15:21:45] *** Quits: jensnockert (jensnocker@moz-C5F27039.cust.bredband2.com) (Input/output error)
[15:21:48] *** Quits: Earnestly (earnest@6A917A59.5E1FD793.39C00A7A.IP) (Ping timeout)
[15:26:59] *** Joins: MaikKlein (maik@moz-4AFFBD8F.dip0.t-ipconnect.de)
[15:29:52] *** Quits: cowboyd (cowboyd@1D8844A7.1B729417.CEE440B6.IP) (Client exited)
[15:33:24] *** Quits: Cromulent (Cromulent@moz-983B638D.cable.virginmedia.com) (Quit: KVIrc 4.2.0 Equilibrium http://www.kvirc.net/)
[15:34:09] *** Joins: pnkfelix (pnkfelix@moz-43495417.fbx.proxad.net)
[15:36:02] <orshem> are there examples of how to work with the new iterators? how to iterate over a tuple getting both the location and the value?
[15:36:37] <cmr> orshem: location being reference?
[15:36:56] *** Quits: hansjorg (hansjorg@moz-EECB5F79.static.cust.telenor.com) (Quit: Leaving.)
[15:37:23] <orshem> cmr: sorry meant position in the tuple?
[15:37:26] <cmr> oh
[15:37:59] <bstrie> orshem: you can't index tuples, you have to match on them to get their contents
[15:38:04] <bstrie> tuple indexing might come in the future
[15:38:22] <Blei> hmm, is there somewhere a table with a mapping from ast::def_id to llvm types?
[15:39:04] <nmatsakis> indutny: huh. well, you need to add a +Copy somewhere :) but I must not be following the types in your code correctly. That said, if you can use retain, that's fine too.
[15:39:11] <orshem> bstrie: there are no iterators that can run over them and yield (pos, value)?
[15:39:22] *** zz_kimundi is now known as kimundi
[15:39:44] *** Joins: Aetherspawn (Aetherspaw@moz-8811D9F0.static.tpgi.com.au)
[15:39:58] <cmr> hey there's a readme in src/librustc
[15:39:58] <jdm> bstrie: I think there's also .first() and .second()
[15:40:01] * cmr reads it
[15:40:18] <bstrie> jdm: good luck returning those methods from an iterator :P
[15:40:26] <jdm> challenge accepted!
[15:40:31] *** Quits: jeff (jeff@moz-F81F6C4E.nyc.biz.rr.com) (Quit: jeff)
[15:40:38] <bstrie> and then jdm implemented UFCS to spite bstrie
[15:41:16] <bstrie> orshem: I'm not sure if iterators are implemented over tuples. I'll try and check
[15:41:22] <indutny> nmatsakis: meh, it didn't work out :)
[15:41:33] <indutny> nmatsakis: I've just replace .filtered calls with .retain
[15:41:40] <indutny> I was cloning source array anyway
[15:41:43] <orshem> bstrie: i look at the code and drowned in a sea of macros
[15:41:52] <orshem> looked
[15:43:57] <nmatsakis> Blei: there are mappings from def_id to rust types, which can be converted to llvm types.
[15:44:00] <bstrie> orshem: it doesn't appear that iterators are implemented on tuples
[15:44:25] *** Quits: MaikKlein (maik@moz-4AFFBD8F.dip0.t-ipconnect.de) (Ping timeout)
[15:45:01] <bstrie> orshem: also, tuples aren't the sort of thing you usually want to iterate over... if you have a collection of elements, use a vector instead
[15:45:25] <bstrie> orshem: unlike python, tuples are very different from vectors in rust
[15:45:37] *** Joins: jensnockert (jensnocker@moz-C5F27039.cust.bredband2.com)
[15:47:49] <orshem> bstrie: how do i iterate over a vector and get both value and position? 
[15:47:58] <orshem> bstrie: thanks for helping
[15:48:00] <orshem> me
[15:48:05] *** Joins: seth (seth@moz-D840E602.dsl.static.sonic.net)
[15:48:06] <bstrie> orshem: I'll write up an example
[15:48:47] <orshem> also does rust supports yield statements/expressions like python?
[15:48:53] *** Joins: Jeaye (Jeaye@moz-FD505E54.hsd1.ca.comcast.net)
[15:49:33] <bstrie> orshem: //gist.github.com/5815365
[15:50:11] <bstrie> orshem: in the future it might be possible to leave off the `advance()` part of that example
[15:50:20] <orshem> bstrie: thanks!
[15:50:28] <Blei> nmatsakis: thanks, i think i found what i need
[15:50:51] <bstrie> orshem: what version are you using? iterators are pretty recent
[15:52:06] <bstrie> orshem: we don't support generators like python does, no
[15:52:33] *** Joins: carllerche (carllerche@6B070D22.7E6A0813.1428D117.IP)
[15:53:15] <cmr> They can be implemented on top of tasks though
[15:54:21] <orshem> bstrie: i compiled rust again a few hours ago. 
[15:54:26] <bstrie> good
[15:54:49] <bstrie> and I don't have to ask if you're on master or incoming any more! I'm on the verge of tears, I am so happy
[15:55:13] <orshem> :)
[15:55:15] <SiegeLord> Hah
[15:56:07] <orshem> bstrie: borrow errors usually have that effect on me (verge on tears) :)
[15:56:24] <bstrie> Rust: We Bring You To Tears (Sometimes In a Good Way)
[15:56:37] *** Joins: Cromulent (Cromulent@moz-983B638D.cable.virginmedia.com)
[15:57:20] <cmr> twir is going to be exciting
[15:58:04] *** Joins: eholk (eholk@BAD3967A.BEBDB225.ABD5273E.IP)
[15:58:29] *** Quits: seth (seth@moz-D840E602.dsl.static.sonic.net) (Ping timeout)
[15:58:41] <cmr> Anyone have any specific complaints about rustdoc? Today that is at the top of my todo list.
[15:58:58] <orshem> rust testing facility is great! 
[15:59:07] <bstrie> cmr: were you the one who updated the css lately?
[15:59:14] <cmr> bstrie: no that was SiegeLord
[15:59:25] <cmr> (at my goading, I don't think he was going to send a PR :p)
[15:59:36] <SiegeLord> And then somebody removed my nice borders :'(
[15:59:36] <bstrie> SiegeLord: the new rustdoc css is 1000x better. still could use some work, but it's not an assault on my eyes now
[15:59:47] *** Quits: eholk (eholk@BAD3967A.BEBDB225.ABD5273E.IP) (Ping timeout)
[15:59:56] <SiegeLord> But there's no objective standard for beauty, so... it's all good
[16:00:21] <cmr> I would like to see the docs centered on the page with a complete ToC on the left
[16:00:25] *** Quits: SimonSapin (simon@88F51059.F3BBB17D.144F44FA.IP) (Quit: Leaving.)
[16:00:49] <cmr> I plan on spewing out either xml or json from rustdoc, and then shoving that into a template to make HTML
[16:01:00] <Blei> hrm, i have a circularity
[16:01:01] <cmr> should also enable inline docs in IDEs
[16:01:23] <SiegeLord> One thing I wanted was little anchor links so you could link to specific headings
[16:01:27] <jdm> omg, the new docs are live on the site
[16:01:33] <jdm> I want to weep with joy
[16:01:36] <Blei> i can't translate the tydesc to an llvm type without having a CrateContext, and for the CrateContext i have to have the llvm type of the tydesc
[16:01:37] <bstrie> cmr: I want it so that I can click a link in the docs and go to the source. I want this to be controlled by an attribute that points to where the source is stored
[16:01:40] <bstrie> cmr: https://github.com/mozilla/rust/issues/2072
[16:01:53] <cmr> bstrie: yep, I want that too.
[16:01:59] <cmr> I'm heavily inspired by the python docs :)
[16:02:16] <cmr> But I'm not sure going to sphinx outright is the right thing for rustdoc
[16:02:37] <cmr> for the rust docs, maybe.
[16:02:38] <jdm> SiegeLord: if the TOC on the left materializes, somebody should make a docs stylesheet that makes them look like http://www.extrachm.com/images/ExtraChmWnd.png
[16:02:41] *** Joins: SimonSapin (simon@88F51059.F3BBB17D.144F44FA.IP)
[16:02:48] <bstrie> cmr: rust should use rustdoc
[16:03:01] <jdm> or maybe even http://i.stack.imgur.com/mVDyx.jpg
[16:03:21] <bstrie> maybe sphinx would work, but I think it's so popular that it just looks generic now :P no brand awareness at all!
[16:03:35] <cmr> bstrie: but... who care about that? :p
[16:04:06] <SiegeLord> jdm: Can't you make chm files from HTML?
[16:04:17] <cmr> SiegeLord: chm is html
[16:04:21] <jdm> presumably
[16:04:29] <jdm> but I just want the nostalgia
[16:04:31] <jdm> not the actual pain
[16:04:38] <SiegeLord> Or do you mean to have it look as if it was chm
[16:04:43] <jdm> zigzactly
[16:04:48] <SiegeLord> Hehe
[16:05:04] *** Joins: infynyxx (infynyxx@DB780A29.749BA1D.DCC373F0.IP)
[16:05:08] <cmr> bstrie: I agree rust should use rustdoc, but I'm saying rustdoc could spit out rst for sphinx
[16:05:19] <bstrie> cmr: a distinctive look is crucial! if people look at our docs and think that they are looking at python docs, we have failed
[16:05:37] <cmr> but look at http://docs.python.org/3.4/library/random.html !
[16:05:39] <cmr> just beautiful
[16:05:50] *** Joins: bent (chatzilla@moz-BE33DA21.fw1.sfo1.mozilla.net)
[16:05:54] *** Joins: msingle (Thunderbir@moz-930E5D97.hr.hr.cox.net)
[16:06:04] *** Joins: ksev (DrunkenPan@745B767B.989A61DC.CA5B6332.IP)
[16:06:40] <cmr> can always theme sphinx anywaty
[16:06:45] <bstrie> cmr: actually I liked the old yellow and blue look better :P
[16:06:59] <cmr> I'm no designer, though.
[16:07:01] <bstrie> the white and grey is very boring
[16:07:02] <SiegeLord> I like pandoc since you can make average looking PDFs out of it, in addition to HTML
[16:07:27] <bstrie> SiegeLord: making pdfs is the reason we went with pandoc in the first place, but I don't think anyone has ever actually cared about having a pdf of rust's docs
[16:08:01] <SiegeLord> It's useful for a printed copy... some people are like that
[16:08:18] <SiegeLord> Well, maybe not quite yet at this stage
[16:08:41] <bstrie> printing the webpage looks just as nice as printing the pdf :)
[16:10:51] <SiegeLord> Hmm... pandoc even gets the links right when making the pdf... that's pretty neat
[16:13:47] *** Quits: vertexclique (vertexcliq@2A4DD1A8.B0B9525A.34FB0D7A.IP) (Client exited)
[16:14:08] *** Joins: vertexclique (vertexcliq@2A4DD1A8.B0B9525A.34FB0D7A.IP)
[16:17:42] *** Quits: vertexclique (vertexcliq@2A4DD1A8.B0B9525A.34FB0D7A.IP) (Ping timeout)
[16:18:14] *** Joins: cowboyd (cowboyd@1D8844A7.1B729417.CEE440B6.IP)
[16:19:45] *** Joins: vk (chatzilla@3E9D68F2.B1163E0C.2A6693DD.IP)
[16:19:53] *** Quits: Cromulent (Cromulent@moz-983B638D.cable.virginmedia.com) (Quit: KVIrc 4.2.0 Equilibrium http://www.kvirc.net/)
[16:20:07] *** Quits: ksev (DrunkenPan@745B767B.989A61DC.CA5B6332.IP) (Ping timeout)
[16:24:41] *** Quits: cowboyd (cowboyd@1D8844A7.1B729417.CEE440B6.IP) (Client exited)
[16:25:59] *** Joins: MaikKlein (maik@moz-4AFFBD8F.dip0.t-ipconnect.de)
[16:26:28] *** Joins: eschweic (Adium@2557E599.66715431.D25A875A.IP)
[16:27:45] *** Joins: azita (Azita@2557E599.66715431.D25A875A.IP)
[16:30:24] *** Joins: eholk (eholk@BAD3967A.BEBDB225.ABD5273E.IP)
[16:30:43] <cmr> bstrie: web docs aren't all on one page though
[16:31:11] *** Quits: jaen (jaen@moz-E0979827.copit.pl) (Quit: WeeChat 0.4.1)
[16:31:46] *** Quits: MaikKlein (maik@moz-4AFFBD8F.dip0.t-ipconnect.de) (Ping timeout)
[16:31:48] *** Joins: RMF (RMF@7CB4432F.59969257.8D19547B.IP)
[16:32:43] *** Joins: cowboyd (cowboyd@1D8844A7.1B729417.CEE440B6.IP)
[16:32:53] *** Joins: graydon (graydon@3853DDD.39EEDBB3.D758B1AA.IP)
[16:32:54] *** ChanServ sets mode: +qo graydon graydon
[16:33:36] *** Joins: Earnestly (earnest@6A917A59.5E1FD793.39C00A7A.IP)
[16:36:01] *** Joins: rajul (quassel@A2DDF553.812B5995.2051BA92.IP)
[16:38:45] *** Quits: Amanieu (amanieu@moz-D5D10CA8.halls.manchester.ac.uk) (Quit: Lost terminal)
[16:38:53] *** Quits: bytbox (s@moz-D83E9B31.wireless.umd.edu) (Ping timeout)
[16:39:06] *** Joins: Amanieu (amanieu@moz-D5D10CA8.halls.manchester.ac.uk)
[16:39:33] *** Quits: jdm (jdm@moz-801E009D.vlan502.asr1.cdg2.gblx.net) (Quit: Lost terminal)
[16:40:19] *** Joins: jedestep (jedestep@34641662.FB4DE631.66C78B76.IP)
[16:40:40] *** Joins: josh (josh@moz-348C4790.hsd1.mn.comcast.net)
[16:41:21] *** Joins: mib_znigap (Mibbit@BBE7C46A.B4F11D08.8612FA94.IP)
[16:45:46] *** Joins: ysuzuki (ysuzuki@moz-285468F7.net219126120.t-com.ne.jp)
[16:47:03] *** Joins: tedh (tedh@moz-CE9B2F5A.cinci.res.rr.com)
[16:48:23] *** Joins: roo (Mibbit@moz-75C9FCEA.dynamic.ip.windstream.net)
[16:50:22] *** Joins: qmx (qmx@B42C1175.A82378F3.A2BF9DEB.IP)
[16:51:08] *** Quits: IRCMonkey3257 (heftig@moz-60BEBDB9.dip0.t-ipconnect.de) (Ping timeout)
[16:51:23] <mib_znigap> I'm having some trouble understanding modules... suppose I have a mod util, and modules foo and bar (in files named accordingly)
[16:51:35] <mib_znigap> foo uses util (with mod util at the top)
[16:51:41] <mib_znigap> and bar uses both foo and util
[16:51:50] *** Joins: Cromulent (Cromulent@moz-983B638D.cable.virginmedia.com)
[16:51:59] *** Quits: Cromulent (Cromulent@moz-983B638D.cable.virginmedia.com) (Quit: KVIrc 4.2.0 Equilibrium http://www.kvirc.net/)
[16:52:08] <mib_znigap> it seems that if bar tries to use something in util, it'll try to pull it out of foo::util
[16:52:27] <mib_znigap> can someone explain why this happens and why we want this to happen?
[16:52:36] <mib_znigap> or if we don't, how to get around it?
[16:52:37] <jack> are setjmp and longjmp safe to use form rust?
[16:52:37] <mib_znigap> thanks
[16:53:13] <jack> (they are apparently needed for libpng)
[16:53:25] <cmr> mib_znigap: can you pastebin your code somewhere?
[16:53:32] <cmr> (preferably on gist, which allows multiple files)
[16:53:42] <mib_znigap> cmr: sure, I'll get on that
[16:54:34] <cmr> jack: they *should* be
[16:56:59] *** Joins: anri (solancile@moz-A1CFFAE5.hsd1.wa.comcast.net)
[16:57:54] *** Quits: pnkfelix (pnkfelix@moz-43495417.fbx.proxad.net) (Quit: Leaving.)
[17:02:07] *** Joins: pnkfelix (pnkfelix@moz-43495417.fbx.proxad.net)
[17:02:19] *** Quits: Earnestly (earnest@6A917A59.5E1FD793.39C00A7A.IP) (Connection reset by peer)
[17:02:39] *** Joins: Earnestly (earnest@6A917A59.5E1FD793.39C00A7A.IP)
[17:04:09] <erickt1> graydon: ping
[17:04:10] <graydon> jack: safe ish
[17:04:12] *** Quits: jensnockert (jensnocker@moz-C5F27039.cust.bredband2.com) (Input/output error)
[17:04:19] <mib_znigap> http://mibpaste.com/kb9Qr2 sorry, gist a little slow for whatever reason
[17:04:25] <graydon> jack: actually um. hm. probably not terribly safe. how are they used?
[17:04:26] <mib_znigap> just pasted them together there cmr
[17:04:33] <graydon> erickt1: what's up?
[17:04:59] *** Quits: qmx (qmx@B42C1175.A82378F3.A2BF9DEB.IP) (Quit: Textual IRC Client: www.textualapp.com)
[17:05:45] <erickt1> graydon: if you got a few minutes, I wanted to talk about some issues converting &[u8] to &str
[17:05:49] *** erickt1 is now known as erickt
[17:05:55] <cmr> mib_znigap: also what version of rust are you using?
[17:06:02] <doy> mib_znigap: this looks like https://github.com/mozilla/rust/issues/5693
[17:06:07] <graydon> mib_znigap: you do not need to (and should not) declare the mods in each sub-file
[17:06:20] <mib_znigap> OH
[17:06:28] <mib_znigap> that's good to know
[17:06:46] <mib_znigap> commit 90b999aea1a4cfdda549c2ba8462d9eac23c681a>
[17:06:49] *** Quits: infynyxx (infynyxx@DB780A29.749BA1D.DCC373F0.IP) (Client exited)
[17:06:51] <mib_znigap> *90b999aea1a4cfdda549c2ba8462d9eac23c681a?
[17:06:59] <graydon> mib_znigap: all modules are mounted into a single hierarchical crate namespace at the point of the 'mod <xxx>;' declaration. the topmost one suffices.
[17:07:07] <graydon> the others make redundant (and conflicting) bindings
[17:07:19] <graydon> by compiling-in the same module contents at different path names in your crate namespace
[17:07:35] <mib_znigap> graydon meaning that if I have all the needed modules in my top crate (all.rc, in this case)
[17:07:41] <graydon> you are seeing a mismatch between uses because you're using one of those multiple copies in one place and another in another place
[17:07:47] <mib_znigap> I shouldn't have "mod [anything]" in any of the .rs's?
[17:07:49] <mib_znigap> just to check
[17:07:59] <erickt> graydon: this conversion is unsafe, because &strs need to have an extra null byte at the end. So if you use str::from_bytes_slice(&[1,2,3]) to get a &str, then use str::from_c_str, you'll dereference invalid memory since from_c_str looks one past the official string bytes to see if it's null terminated or not
[17:08:03] <graydon> mib_znigap: yes. though we'll be removing the .rc file extension soon-ish as the two file types are compiled equivalently.
[17:08:12] <graydon> erickt: yeah, sorry, I am listening... :)
[17:08:20] <cmr> mib_znigap: you shouldn't duplicate them, not that you shouldn't use them at all (some directory structures needs them, libextra is a good example)
[17:08:35] <erickt> graydon: no problem :)
[17:08:35] <mib_znigap> oh hm
[17:09:04] <mib_znigap> what if hypothetically I had circular dependencies?
[17:09:07] <graydon> mib_znigap: you can put the mod statements in any one file in a crate. just make sure there's only one! otherwise you're saying "please compile-in a file called foo.rs and attach it ->here<- in the crate hierarchy" again
[17:09:23] <graydon> mib_znigap: circularity is unrelated. all modules in a crate are compiled at once, can have mutual dependency
[17:09:26] <cmr> mib_znigap: inter-crate circular dependencies aren't a problem
[17:09:45] <mib_znigap> I must not be understanding your explanations, sorry!!
[17:09:47] <cmr> mib_znigap: it's not like C etc where each file is compiled separately
[17:09:51] <graydon> erickt: &str does not need a null byte at the end
[17:09:53] <mib_znigap> I removed the mod statements at the top of foo.rs and bar.rs
[17:10:00] <mib_znigap> but then many more compilation errors appear
[17:10:13] <erickt> graydon: it's really str::as_c_str that needs an extra character
[17:10:15] <mib_znigap> (unresolved name, undeclared type name, etc.)
[17:10:32] <graydon> mib_znigap: ok, when you build a rust source file, it builds a single output from _all_ the modules it can find, transitively, starting from the input.
[17:10:48] *** Quits: eevee (eevee@moz-A643AA65.evrt.wa.frontiernet.net) (Connection reset by peer)
[17:10:55] <mib_znigap> graydon that makes sense so far
[17:11:05] <graydon> mib_znigap: but it does so hierarchically. so if your input is all.rc and you compile in 'mod foo' and 'mod bar' from there, you'll have "::foo" and "::bar" modules
[17:11:15] <mib_znigap> graydon right
[17:11:19] <erickt> graydon: it's the only function in str that does a `if slice[slice.len()] == 0 { â€¦ }`
[17:11:22] *** Joins: eevee (eevee@moz-A643AA65.evrt.wa.frontiernet.net)
[17:11:46] <graydon> erickt: a &str does have to have one-addressable-byte beyond the len()
[17:12:15] <graydon> erickt: that's not the same as saying it has to be null. and, as several people stub their toes on this, we might change it.
[17:12:27] <erickt> graydon: yeah, and that means we can't just take any old &[u8] and convert it into a &str
[17:12:38] <kimundi> erickt: Not trying to nitpick, but your explanitions you've given the last few days each time I read them are kinda-not-quite right :(
[17:12:39] <mib_znigap> http://mibpaste.com/J541eU does that mean I should something like the previous?
[17:12:53] <mib_znigap> *I should do
[17:13:18] <erickt> kimundi: oh? what am I missing?
[17:13:25] <graydon> mib_znigap: yes
[17:13:47] *** Quits: Aetherspawn (Aetherspaw@moz-8811D9F0.static.tpgi.com.au) (Quit: Leaving)
[17:13:53] <graydon> erickt: yeah. it has to be one-byte-longer than the slice you want to form. that is the main failure mode of the current design (aside from constant surprise and footgunning)
[17:13:54] <mib_znigap> but that has all sort of unresolved name, undeclared mod, etc. errors!
[17:13:59] <mib_znigap> :(
[17:14:07] <graydon> mib_znigap: "all sorts" is not a listing. can you paste those errors? :)
[17:14:15] <cmr> mib_znigap: you need to `use foo` and etc I bet
[17:14:28] *** Quits: Earnestly (earnest@6A917A59.5E1FD793.39C00A7A.IP) (Quit: WeeChat 0.4.2-dev)
[17:14:31] *** Joins: Earnestly (earnest@6A917A59.5E1FD793.39C00A7A.IP)
[17:14:41] <graydon> yes, there is also that: you have to 'use' each module you want to bring into scope
[17:14:43] <mib_znigap> http://mibpaste.com/xqDn1z absolutely! graydon
[17:14:43] <erickt> graydon: we do have a couple cases where I think where we are using from_bytes_slice without guaranteeing the &[u8] has one extra byte
[17:14:57] *** Joins: IRCMonkey3257 (heftig@moz-60BEBDB9.dip0.t-ipconnect.de)
[17:15:18] <erickt> graydon: so I wanted to run some options by you
[17:15:57] <mib_znigap> ooh wait I might have gotten it graydon cmr
[17:16:07] <graydon> erickt: unfortunate! I think everyone would at this point be willing to take a patch that makes &str len actually be the length only, and to make the null-terminating helper always make a copy but use (say) a small-string-optimization local buffer.
[17:16:18] <erickt> kimundi: please chime in too, you missed the conversation I had with brson last night about this
[17:16:25] <kimundi> well, as_c_str does NOT read one point past the slice of a &str. The byte it reads is the LAST byte of the slice, that is it is PART of it. A &str with len() N represents a utf8 string of length N but points at a memory range of N+1 bytes. The last byte just isn't part of the utf8 data, but a valid part of the slice.
[17:16:35] <mib_znigap> yep got it, thank you so much car and graydon!!
[17:16:50] <graydon> mib_znigap: np. sorry for the confusion. seems people stub their toes on this one pretty often.
[17:16:53] *** Joins: spider-mario (spidermari@moz-2F72F6FF.dsl.quantic-telecom.net)
[17:17:01] <graydon> we need to clarify this part of the manual and tutorial, clearly :(
[17:17:04] <cmr> graydon: it's probably a failing of the tutorial
[17:17:11] <cmr> I had trouble with it too
[17:17:55] <graydon> kimundi: right, but the point is you can't take a &[u8] that has 100 copies of the byte 'z' and make a 100-character-long &str. like you just can't. it's a memory error.
[17:18:11] *** Quits: IRCMonkey3257 (heftig@moz-60BEBDB9.dip0.t-ipconnect.de) (Quit: Quitting)
[17:18:12] *** Joins: wilsonk|2 (kvirc@moz-39EFBFC2.cg.shawcable.net)
[17:18:21] <mib_znigap> graydon cmr maybe including in the tutorial an example that's a little more substantive would help?
[17:18:22] <kimundi> graydon: correct, but you can make one thet points at 99 'z's
[17:18:28] <graydon> yeah
[17:18:31] <graydon> I know, I designed it!
[17:18:41] <kimundi> graydon: He :)
[17:18:43] *** Quits: wilsonk-laptop (kvirc@moz-39EFBFC2.cg.shawcable.net) (Ping timeout)
[17:18:43] <erickt> graydon: removing the +1 from the &str length is one of the options I wanted to propose :)
[17:18:48] *** Joins: heftig (heftig@moz-60BEBDB9.dip0.t-ipconnect.de)
[17:18:55] <graydon> it's a bit of a gaffe. you have to copy those 100 'z' bytes into a ~[u8] and then slice that.
[17:19:45] *** heftig is now known as IRCMonkey50590
[17:20:46] <kimundi> Anyway, just wanted to make that clear to erickt . In the current scheme nowhere is a (*ptr, len) tuple passed around where you are expected to read one past the last element.
[17:20:48] <graydon> erickt: another option would be to always end ~[anything] with a 0 byte as well
[17:21:10] <graydon> kimundi: it's a matter of perspective whether the trailing byte is "part of" the slice.
[17:21:35] <erickt> graydon: That seems a little odd
[17:21:55] <roo> does this make sense? with core::rand imported: rand::Rng().gen_int_range(0,10)
[17:22:06] <jack> graydon: on http://www.libpng.org/pub/png/libpng-manual.txt search for "When libpng encounters an error"
[17:22:07] <graydon> kimundi: if I take the len-3 substring of "petunia", I get a slice that addresses "petu" but most high-level APIs will only iterate over "pet"
[17:22:17] <jack> graydon: it describes why it uses longjmp there
[17:22:37] <erickt> graydon: I think the least surprising approach may be just to remove the trailing null from ~strs/@strs
[17:22:44] <kimundi> graydon: strcat made me aware of an interesting fact thoug, that is: valid utf8 can contain interion nulls. So we could just say 'If you want to pass that string to C, put an '\0' at the end or copy it whole'
[17:23:04] <erickt> and do what kimundi just suggested
[17:23:30] *** Joins: infynyxx (infynyxx@DB780A29.749BA1D.DCC373F0.IP)
[17:23:30] <graydon> jack: sounds like they want you to setjmp before any call to png, yes?
[17:23:42] <jack> graydon: yes. they have a little macro for that.
[17:24:02] <graydon> jack: that should work, so long as png doesn't call you back and re-enter rust mid-call 
[17:24:12] <jack> setjmp(png_jmpbuf(png_ptr))
[17:24:41] <graydon> erickt: I concur, it has caused unlimited sadness.
[17:24:45] <erickt> graydon: otherwise we could use a naming convention, such as str::from_bytes_slice_plus_one that one uses when the caller knows there's an extra byte past the end of the &[u8]
[17:25:01] <graydon> erickt: some of the APIs already are name-mangled this way to indicate it
[17:25:04] <jack> graydon: isn't hte whole point that it short circuits the error and jumps back?
[17:25:14] *** Quits: infynyxx (infynyxx@DB780A29.749BA1D.DCC373F0.IP) (Ping timeout)
[17:25:24] <erickt> graydon: but we couldn't protect against someone doing something foolish with just a naming convention
[17:25:36] <jack> does this mean i can't call libpng functions from the rust side? do i need create a C shim?
[17:25:39] <graydon> erickt: agreed, it's too systemic a footgun.
[17:25:45] <kimundi> graydon: From all this discussion I'm also of the opinion that the  hidden byte should dissapear, mainly because it seems hard to explain to peaople doing library work. :)
[17:25:57] <graydon> jack: the point is to short circuit the error, yes.
[17:26:37] <erickt> graydon + kimundi: if you are both for removing the hidden byte, I'll start working on a branch to remove it
[17:26:50] <graydon> jack: I'm just saying that if you do rust -> png -> rust -> re-enter-scheduler, switch context to some other mid-callback-from-png-task -> png -> error -> longjmp
[17:26:55] *** Joins: bytbox (s@moz-BA9A08F8.wireless.umd.edu)
[17:27:00] <graydon> jack: then you might wind up switching _tasks_ on png-error
[17:27:11] <graydon> jack: but if png doesn't call rust back there's no risk of that
[17:27:59] <cmr> You need to pass around a png_context type thing when using libpng don't you? Is the jmp_buf stored in there?
[17:28:13] <kimundi> erickt: Related to that, I wanted to work on transforming all the 'raw' calls to transmutes on things like slices etc to explicit central library functions, wich would kind go hand in hand.
[17:28:39] <kimundi> erickt: That is, the places you'd need to clean up would be the same where I'd need to clean up
[17:29:02] *** Quits: nmatsakis (nmatsakis@moz-DB4A9C19.scl3.mozilla.com) (Ping timeout)
[17:29:06] <graydon> erickt kimundi: I believe so, yes. I think brson also feels this way somewhat strongly. you make a good point that trailing-0 is also legal utf8. maybe as_c_str (or as_null_terminated_c_str to be explicit) can check for last-byte-is-null to save itself work in some cases also.
[17:29:09] *** Quits: cowboyd (cowboyd@1D8844A7.1B729417.CEE440B6.IP) (Client exited)
[17:29:23] *** Joins: MaikKlein (maik@moz-4AFFBD8F.dip0.t-ipconnect.de)
[17:29:25] <graydon> that and using a small-vector-optimization (and/or TLS arena) to avoid allocating temp strings too often, ought to be ok
[17:29:36] <graydon> cmr: I imagine so
[17:29:46] <erickt> graydon: sounds good to me
[17:29:55] *** Joins: infynyxx (infynyxx@DB780A29.749BA1D.DCC373F0.IP)
[17:30:01] *** Joins: nmatsakis (nmatsakis@moz-DB4A9C19.scl3.mozilla.com)
[17:30:01] *** ChanServ sets mode: +o nmatsakis
[17:30:05] <erickt> I'll make a bug ticket to track this work
[17:30:10] <cmr> graydon: so wouldn't that avoid libpng calling into a different task? (Since the same context can't be shared across tasks)
[17:30:26] <graydon> erickt: though I don't know whether we'd wind up with null-in-a-&str very often anyways. when would it occur? if you read a file from disk, or a string from a network buffer, it won't have it.
[17:30:53] <graydon> cmr: so long as you re-enter the correct png callback, yeah, I suppose so!
[17:30:56] <graydon> (hope so)
[17:31:34] <erickt> I think some C APIs use it, like windows's getenv api, where each key/value is separated by a null character
[17:32:50] <kimundi> graydon: well a null is valid utf8, so any utf8 encoded file might contain it. as_c_str() would have to check that the last byte is null and that all other bytes are non_null to be what C expects
[17:34:14] <graydon> kimundi: maybe. there's a limit to how clever we need to be. let's just try to make the APIs more-obvious about what they actually do.
[17:34:30] <kimundi> well, I guess it wouldn't have to check _all_ other bytes, but need docs to say that it might have interior nulls, and thus the c side might see a shorter string than you expect
[17:34:31] <erickt> kimundi: I don't think .as_c_str() has to check that all other bytes are non-null. C apis are all over the place on how their strings are formatted
[17:35:01] <bstrie> would that ever be a security vulnerability, to get a *shorter* string than you expect?
[17:35:14] <graydon> yeah. I'd just suggest "ends-with-0" as a consistency check. and/or as I mentioned, renaming the API to as_null_terminated_c_str
[17:35:21] <graydon> then you know what you're asking for
[17:35:29] <cmr> Or just as_null_terminated_str
[17:35:40] *** Quits: dylukes (dylukes@moz-B5418F79.hsd1.pa.comcast.net) (Quit: ["Textual IRC Client: www.textualapp.com"])
[17:35:46] <bstrie> or just .null_terminate() :P
[17:36:25] <cmr> Actually, that's crazy enough that it might just work.
[17:36:58] <erickt> brb
[17:37:00] *** Joins: devinus (devinus@moz-B4AF84BC.ptr.us.xo.net)
[17:37:04] <bblum> anybody know what early_resolve_expr is for...?
[17:37:06] <cmr> Don't do any special handling, just expose a null_terminate method on str that null terminates if necessary
[17:37:21] <kimundi> Also a possible function csuld be one that takes ~str, pushes a NULL, calls out to C, pops the NULL and returns the ~str again
[17:37:38] <doener> hm, you could overallocate the strings to have space to add a null terminator. Then ...
[17:37:43] <doener> what kimundi said
[17:37:54] *** Joins: brendan (brendaneic@moz-BE33DA21.fw1.sfo1.mozilla.net)
[17:38:00] <kimundi> :)
[17:38:16] *** Joins: ksev (DrunkenPan@745B767B.989A61DC.CA5B6332.IP)
[17:38:23] <doener> that could also accept a range and temporarily insert a null byte, and restore the original afterwards
[17:38:37] <bstrie> cmr kimundi https://github.com/mozilla/rust/issues/6869
[17:38:42] <bstrie> leave comments there if you have ideas
[17:40:50] <kimundi> erickt ^
[17:41:38] <MaikKlein> has tjc held his rust talk yet?
[17:41:44] <cmr> nope
[17:42:08] <cmr> oh, actually, maybe
[17:42:36] <bstrie> he gave a practice talk
[17:42:45] *** Quits: lucian (lucian@6B2B4644.4304AE1E.CE5E78F6.IP) (Ping timeout)
[17:43:01] <bstrie> at... newrelic?
[17:43:10] <cmr> http://opensourcebridge.org/sessions/970
[17:43:10] <bstrie> he's at a conference right now, not sure what day his talk is on
[17:43:16] <cmr> I think that happened already then?
[17:43:21] <cmr> bstrie: it's today
[17:43:46] <cmr> is it ongoing?
[17:43:50] * cmr doesn't know timezones well
[17:44:06] <bstrie> hmm
[17:44:16] <MaikKlein> I think it's already done, but I am not completely sure 
[17:44:16] <bstrie> it would have started at... 2:00 my time
[17:44:23] <bstrie> so it starts in a few minutes, then :P
[17:44:26] <MaikKlein> hm
[17:45:07] *** Quits: josh (josh@moz-348C4790.hsd1.mn.comcast.net) (Quit: josh)
[17:46:06] <MaikKlein> there are two portlands :X?
[17:46:09] *** Quits: bjz (brendanzab@B398BE78.F804C29E.D35A31DF.IP) (Quit: Leaving...)
[17:46:14] <bblum> nmatsakis: ping
[17:46:24] <nmatsakis> bblum: pong.
[17:46:47] <bblum> nmatsakis: in ty.rs, why don't we have an impl IterBytes for BuiltinBounds?
[17:46:58] <bblum> i notice the impl IterBytes for ClosureTy doesn't iterbytes the bounds
[17:47:08] *** Joins: bjz (brendanzab@B398BE78.F804C29E.D35A31DF.IP)
[17:47:09] *** Quits: bjz (brendanzab@B398BE78.F804C29E.D35A31DF.IP) (Quit: bjz)
[17:47:24] <nmatsakis> bblum: sounds like a bug. it should be using deriving.
[17:47:41] <MaikKlein> yeah the talk will be finished in 60min
[17:47:49] *** Joins: mschifer (Adium@2557E599.66715431.D25A875A.IP)
[17:48:03] *** Quits: davbo (dave@moz-3FFA637C.oucs.ox.ac.uk) (Client exited)
[17:48:13] *** Joins: cowboyd (cowboyd@moz-1BD02A1E.sw.biz.rr.com)
[17:48:20] <MaikKlein> wow 10 hours time difference to Portland, not bad
[17:48:23] <bblum> ah, it does already derive, we just don't use it
[17:49:18] <bblum> nmatsakis: does it matter what order the components of ClosureTy are itered-bytes in?
[17:49:30] <nmatsakis> bblum: no
[17:50:03] <nmatsakis> bblum: all the manual IterBytes impl should be removed, they're just asking to become inconsistent...
[17:50:12] <bblum> what's it used for?
[17:50:37] <bstrie> oh right, maybe the talk did start at 1:00
[17:50:42] <bstrie> I guess we're all terrible at timezones
[17:50:55] <cmr> :p
[17:51:00] <bstrie> bah, who needs them
[17:51:09] <bstrie> indeed, who even needs a concept of absolute time
[17:51:59] *** Quits: MaikKlein (maik@moz-4AFFBD8F.dip0.t-ipconnect.de) (Ping timeout)
[17:52:44] <nmatsakis> bblum: hashing.
[17:52:52] <nmatsakis> bblum: when interning types.
[17:53:14] *** Joins: pcwalton (pcwalton@43CB6079.66715431.D25A875A.IP)
[17:53:14] *** ChanServ sets mode: +o pcwalton
[17:53:49] <bblum> i don't see where it's called from O_o
[17:54:05] <nmatsakis> bblum: it's a trait, it's called from the hashtables.
[17:54:14] <nmatsakis> bblum: I think it's the default impl of hash
[17:54:18] <nmatsakis> bblum: or something like that
[17:54:19] <bblum> ah, ok
[17:54:44] <nmatsakis> probably ought to be removed in favor of the Encodable trait
[17:54:50] <nmatsakis> but oh well, someday.
[17:55:24] *** Joins: deepdog (deepdog@moz-490E834C.client.mchsi.com)
[17:55:27] <Eridius> yeah Hash is defined for all IterBytes by default
[17:55:37] *** Quits: deepdog (deepdog@moz-490E834C.client.mchsi.com) (Quit: Leaving)
[17:55:53] <bblum> i see
[17:56:04] <graydon> I wonder what these remaining failures are about, hmm
[17:57:12] *** Quits: infynyxx (infynyxx@DB780A29.749BA1D.DCC373F0.IP) (Client exited)
[17:57:33] *** Joins: FrozenCow (FrozenCow@moz-B2DF4929.chello.nl)
[18:00:44] *** Quits: sk (sk@1335CD0E.81A8C295.D066974A.IP) (Quit: Leaving)
[18:01:09] *** Quits: azita (Azita@2557E599.66715431.D25A875A.IP) (Quit: azita)
[18:01:48] *** Quits: Yurume (yurume@AC58A8CE.8A059B47.E313B915.IP) (Ping timeout)
[18:02:19] *** Quits: IRCMonkey50590 (heftig@moz-60BEBDB9.dip0.t-ipconnect.de) (Quit: Quitting)
[18:02:36] <erickt> thanks kimundi, I'll cc that issue in mine
[18:03:26] *** Joins: azita (Azita@2557E599.66715431.D25A875A.IP)
[18:05:00] *** Joins: kerm (Mibbit@9468E38F.68D1775A.A3D1B221.IP)
[18:05:07] *** Quits: kerm (Mibbit@9468E38F.68D1775A.A3D1B221.IP) (Quit: http://www.mibbit.com ajax IRC Client)
[18:05:18] *** Joins: peeves (Mibbit@9468E38F.68D1775A.A3D1B221.IP)
[18:07:02] <roo> http://pastebin.mozilla.org/2542685 having trouble using core::rand
[18:07:34] <cmr> roo: rust 0.6?
[18:07:45] <roo> yes
[18:08:33] <cmr> use core::rand::*, maybe?
[18:08:34] *** Quits: brendan (brendaneic@moz-BE33DA21.fw1.sfo1.mozilla.net) (Quit: brendan)
[18:10:42] *** Quits: zslayton (Mibbit@BF6B2242.269AFE30.6A3AF4D7.IP) (Quit: http://www.mibbit.com ajax IRC Client)
[18:10:54] *** Joins: brendan (brendaneic@moz-BE33DA21.fw1.sfo1.mozilla.net)
[18:11:17] <roo> yeah that worked, but now i have no idea how the scoping of methods works...
[18:11:35] <cmr> You can only call methods when the trait the method is defined in is in scope
[18:11:59] <roo> but it should be in scope... just not imediate local scope
[18:12:18] <roo> idk, thanks though
[18:13:38] <cmr> fwiw the example in rand's docs on master has `use core::rand::RngUtil`
[18:13:44] <cmr> (should be std now...)
[18:14:24] *** Quits: peeves (Mibbit@9468E38F.68D1775A.A3D1B221.IP) (Quit: http://www.mibbit.com ajax IRC Client)
[18:15:19] *** Quits: ysuzuki (ysuzuki@moz-285468F7.net219126120.t-com.ne.jp) (Client exited)
[18:15:58] <Eridius> we really should put RngUtil into prelude
[18:16:05] <pcwalton> +1
[18:16:08] <cmr> yeah
[18:16:16] <Eridius> and probably Rng too, because I know sometimes I want to type .next() instead of relying on type inference of .gen()
[18:16:23] *** Joins: heftig (heftig@moz-E9626940.dip0.t-ipconnect.de)
[18:16:41] <Blei> hmm, can use statements be cfg'd away?
[18:16:47] <cmr> Blei: yup
[18:16:53] <Blei> cmr: great!
[18:16:58] <cmr> Blei: that's how std::libc works
[18:17:00] *** Joins: igl (igl@moz-5AE08D12.adsl.alicedsl.de)
[18:17:26] *** heftig is now known as IRCMonkey56359
[18:17:39] *** Quits: SimonSapin (simon@88F51059.F3BBB17D.144F44FA.IP) (Ping timeout)
[18:18:13] <erickt> graydon / kimundi / cmr / bstrie: here's my bug report about removing the trailing null from strings: https://github.com/mozilla/rust/issues/7235
[18:18:39] <kimundi> erickt: I started writing down the current situationin bstries one
[18:19:07] <erickt> kimundi: awesome
[18:19:51] <roo> i just started messing with rust a couple days ago so I am assuming some things from elsewhere, but to be clear, for any trait's method's to be in scope, the trait has to be reachable unqualified?
[18:19:57] *** Joins: SimonSapin (simon@88F51059.F3BBB17D.144F44FA.IP)
[18:20:13] <erickt> kimundi: nice summary
[18:20:21] <pcwalton> roo: right
[18:20:28] <roo> got it :)
[18:21:20] <Eridius> what's bstrie's one?
[18:21:25] *** Joins: kendle (Mibbit@84CDA2E2.BA2323BF.8D85FBA3.IP)
[18:21:38] <kendle> hiii there
[18:22:01] *** Joins: berak (chatzilla@95564114.5291F4C0.16E13E53.IP)
[18:22:11] <bstrie> Eridius: https://github.com/mozilla/rust/issues/6869
[18:22:17] <bstrie> kendle: helloo
[18:22:46] <kendle> hey there
[18:22:52] <kendle> i am new to this lang
[18:23:09] <kendle> any jumpstart tutorials u suggest?
[18:23:32] <bstrie> kendle: what other languages are you familiar with?
[18:23:40] *** Parts: berak (chatzilla@95564114.5291F4C0.16E13E53.IP) ()
[18:23:42] <kendle> java mostly
[18:23:45] <cmr> kendle: http://static.rust-lang.org/doc/0.6/tutorial.html, http://www.rustforrubyists.com/book/index.html
[18:24:24] <bstrie> kendle: that "rust for rubyists" link is pretty understandable even if you don't know ruby
[18:24:35] <cmr> I don't think it explicitly compares to ruby anywhere
[18:24:48] *** Quits: true_droid (Adium@moz-123FD9B8.beck.volia.net) (Quit: Leaving.)
[18:24:48] <cmr> It's more "rust for highlevel programmers"
[18:25:18] <kendle> might i ask.. 
[18:25:24] *** Joins: brson (brson@2557E599.66715431.D25A875A.IP)
[18:25:24] *** ChanServ sets mode: +o brson
[18:25:26] <bstrie> you may
[18:25:27] <erickt> woah, Rust for Rubyists? that looks awesome. And Steve Klabnik has an awesome personal page: http://www.steveklabnik.com/
[18:25:42] <kendle> i was told rust is a kind of http request 
[18:25:48] <kendle> can any1 elaborate on it
[18:26:02] <cmr> kendle: rust is a programming language. whoever said that was extremely confused.
[18:26:11] <Eridius> maybe they were talking about REST?
[18:26:29] <brson> graydon: have any leads on this new valgrind issue?
[18:26:42] <kendle> maybe he got confused..
[18:26:48] * Yoric assumes Eridius is right.
[18:26:52] <graydon> brson: no
[18:26:58] <Yoric> kendle: Probably "REST", not "Rust".
[18:27:02] <graydon> brson: I'm also confused about the rustpkg failure
[18:27:17] <graydon> brson: and really annoyed that master is still not properly covered by auto! :)
[18:27:29] *** Joins: infynyxx (infynyxx@DB780A29.749BA1D.DCC373F0.IP)
[18:27:48] <kendle> thanks guys anywayz.. have to jump into tutorials now
[18:27:48] *** Quits: infynyxx (infynyxx@DB780A29.749BA1D.DCC373F0.IP) (Connection reset by peer)
[18:28:01] <kendle> :D
[18:28:01] *** Joins: infynyxx (infynyxx@DB780A29.749BA1D.DCC373F0.IP)
[18:28:29] <Eridius> kendle: do you have a project that you're going to use rust with? I find the best way to learn a language is to have a project (after reading through the tutorial of course)
[18:28:32] <EXetoC> graydon: cool, you are an owned box now
[18:28:33] *** Joins: strcat (strcat@moz-54F7FD49.cpe.net.cable.rogers.com)
[18:28:56] <Eridius> kendle: btw, just to head off any confusion, if you read the 0.6 docs you'll see 'core' and 'std'. In current master, 'core' is now called 'std' and 'std' is called 'extra'
[18:29:03] <EXetoC> and the others are managed I guess huehue
[18:29:24] <kendle> @eridius: nothing as of now.. 
[18:29:29] <cmr> kendle: yeah. and if you can, you should build rust yourself (or if you use arch linux, use strcat's packages).
[18:29:42] <Eridius> kendle: I haven't tried it with Rust yet but my go-to project is working through projecteuler.com
[18:29:45] <brson> graydon: oh, I didn't see the rustpkg failure
[18:29:53] <Eridius> make that projecteuler.net
[18:29:55] <graydon> EXetoC: hm?
[18:30:40] <kendle> cmr: how do you propose i should do that?
[18:30:58] <Eridius> kendle: check out github.com/mozilla/rust
[18:31:02] <Eridius> ./configure, make, make install
[18:31:23] <cmr> kendle: https://github.com/mozilla/rust/wiki/Note-getting-started-developing-Rust
[18:31:36] <Eridius> if you build it yourself, you'll want to use Trunk docs instead of 0.6 docs
[18:31:45] <brson> ok, I'm going to look at the valgrind failure in rustctest
[18:32:19] <graydon> brson: ok. I'm trying to figure out rustpkg.
[18:32:21] <Blei> dealing with snapshot compilers is fun /s
[18:32:22] <bstrie> kendle: what platform are you on?
[18:32:27] <Blei> so much recompiling everything
[18:32:31] <kendle> linux mint
[18:32:47] <kendle> mint 12
[18:32:48] <bstrie> ok, I use mint so I know rust works there :)
[18:32:51] *** Quits: FrozenCow (FrozenCow@moz-B2DF4929.chello.nl) (Ping timeout)
[18:33:02] <kendle> :)
[18:33:05] <bstrie> well I think I'm using mint 14, but it will probably still work
[18:33:24] *** Joins: webber46 (webber46@moz-98D2F3C5.cust.bredband2.com)
[18:33:51] <kendle> no issues.. i'll find out.. if i am stuck. i'll ping
[18:34:06] <kendle> mostly it should work..
[18:34:14] *** Quits: infynyxx (infynyxx@DB780A29.749BA1D.DCC373F0.IP) (Ping timeout)
[18:34:25] * graydon points out that if anyone wants to get static linking working (esp. on linux, esp esp. on a non-glibc libc) it would be ... extremely cool.
[18:34:37] <graydon> it has worked before
[18:34:42] <cmr> graydon: ohh, that'll be my next pet project
[18:34:45] <cmr> rust-musl
[18:34:59] <graydon> yes please please
[18:35:09] * cmr has a strong dislike of glibc
[18:35:10] <graydon> sabotage buildroot or something
[18:35:23] <graydon> it makes bootstrap-compiler portability very complicated
[18:35:27] <graydon> since they insist on fighting static linking
[18:35:43] <Eridius> I want to be able to statically link the rust crates, so I can hand a binary to someone running on my same OS (so same libc) that doesn't have rust installed
[18:36:04] <kendle> thanks guys c ya.. :D
[18:36:29] <engla> I see graydon has a new sigil..  But you have the mods in manageble boxes ^^
[18:36:42] <rubber-duck> where can I find info on the current development of GC - AFAIK it's currently a conservative collector and you're developing a precise collector right ?
[18:36:55] *** Quits: kendle (Mibbit@84CDA2E2.BA2323BF.8D85FBA3.IP) (Quit: http://www.mibbit.com ajax IRC Client)
[18:37:15] <graydon> rubber-duck: currently we're on refcounting. I have a wip conservative collector that mostly works but uses too much memory and can't get through stage2 of i386
[18:37:32] <graydon> rubber-duck: we'll then later move to a  stack-conservative, heap-precise variant
[18:37:42] <graydon> then later (hopefully) to a mostly-copying variant of that
[18:37:51] <rubber-duck> graydon, why not have full precise GC ?
[18:37:56] <rubber-duck> what's the blocker ?
[18:37:57] *** Quits: brson (brson@2557E599.66715431.D25A875A.IP) (Ping timeout)
[18:38:02] <graydon> (mostly-copying meaning the conservative pages are pinned, the precise ones are copied and compacted)
[18:38:27] <graydon> rubber-duck: llvm isn't really great about it
[18:38:40] <doener> ah, finally: https://github.com/mozilla/rust/pull/7237
[18:38:41] <graydon> rubber-duck: if you mark something as a GC root, it spills and reloads it on every operation, IIRC
[18:39:06] <doener> that took way longer than I liked...
[18:39:28] <rubber-duck> graydon, I've been reading about that - can't you just force LLVM to push registers on the stack at each GC::alloc call - since you're dealing with single threaded GC you don't have to deal with interupts and read/write barriers
[18:39:31] <graydon> rubber-duck: which completely kills performance. though maybe not as much as we've observed with the conservative stack approach. we'll have to see.
[18:39:57] <rubber-duck> why can't you just block and collect if needed in GC alloc ?
[18:40:04] <graydon> rubber-duck: sure. but "precise" means knowing which of those registers are GC pointers and which are just integers.
[18:40:09] <graydon> rubber-duck: (also all stack slots)
[18:40:24] <rubber-duck> graydon, oh you're saying getting that out of LLVM is hard ?
[18:40:26] <graydon> rubber-duck: if we don't know that, then we are doing stack-conservative
[18:40:47] <graydon> rubber-duck: yeah, apparently (I haven't looked into it, but two different people have bounced off it)
[18:41:03] *** Joins: Jesse (jruderman@moz-537BCF9.hsd1.ca.comcast.net)
[18:41:11] <graydon> (also which are live vs. just happen to be still visible)
[18:41:51] <graydon> I think stack-conservative + heap-precise won't be _that_ bad. it might be. it's hard to tell.
[18:42:00] <graydon> it still has to deal with interior pointers, which kinda sucks.
[18:42:02] <strcat> graydon: can always just not use gc until it's solid
[18:42:03] <rubber-duck> graydon, any links on those bounces, I've found the 2012 one from your intern
[18:42:08] <strcat> graydon: I mean, people can use Rc
[18:42:15] <graydon> strcat: yeah, maybe
[18:42:24] <graydon> rubber-duck: I think pcwalton tried before
[18:42:27] <strcat> don't think it's very important that it be a great gc because there are so many alternatives to it
[18:42:37] <graydon> I tend to agree. but I think it should _work_
[18:42:38] <strcat> unless you actually have possible cycles
[18:42:39] <graydon> :)
[18:42:58] <strcat> it should work, but don't worry so much about it being fast yet ;p
[18:43:00] <graydon> and at the moment rustc leans on it heavily
[18:43:08] <graydon> historical accident, mostly
[18:43:18] <rubber-duck> strcat, I just want to play arround to see if I can get it working - being single threaded should make things a lot simpler than a full blown global memory collector
[18:43:47] <strcat> graydon: yeah but I bet most could be converted to Rc
[18:44:28] <rubber-duck> I think the whole read/write barriers and safe points problem doesn't exist if you're dealing with a task-local GC
[18:45:17] <pcwalton> write barriers are still needed for generational or incremental
[18:45:20] <graydon> conseratively, true. if you want stack-precise a lot of them re-emerge.
[18:45:24] <graydon> and you need write barriers for .. yeah
[18:45:26] <graydon> as pcwalton said
[18:45:48] <rubber-duck> pcwalton, not if you do your collection only inside allocate calls ?
[18:45:53] <graydon> but I think that will be ok. we control mutability pretty well. it's not like "every pointer-write will be a write barrier"
[18:45:55] <pcwalton> no
[18:46:01] <pcwalton> you still need it for generational or incremental
[18:46:07] <pcwalton> for incremental to maintain the tri color invariant
[18:46:24] <pcwalton> for generational to deal from pointers from the tenured generation into the nursery
[18:46:45] *** Quits: azita (Azita@2557E599.66715431.D25A875A.IP) (Quit: azita)
[18:47:20] <rubber-duck> pcwalton, do you need generational GC in rust ? it seems like the very specific use case of rust GC should by default encourage long living objects 
[18:47:28] *** Joins: FrozenCow (FrozenCow@moz-B2DF4929.chello.nl)
[18:47:31] <pcwalton> it's possible that we won't need it, yes
[18:47:39] <rubber-duck> same thing for generational 
[18:47:48] <rubber-duck> *incremental
[18:48:24] <rubber-duck> because GC heap should be limited, and task local the pauses shouldn't be outrageous 
[18:49:43] <bblum> not sure if these two PRs of mine will fail to merge with each other :X
[18:49:47] * graydon heads to lunch, back in a bit
[18:50:19] <rubber-duck> depending on how smart you can get with type info generated you can also skip a lot of memory because GC heap pointers are explicitly marked in type information ?
[18:50:58] *** Joins: tjc (tjc@6902864.17C2F9C.163DC5C6.IP)
[18:50:58] *** ChanServ sets mode: +o tjc
[18:50:59] <rubber-duck> so I'm guessing a simplistic precise collector would do fine in like 90% of the cases - with no hassle with read/write barriers or safe points
[18:52:11] *** Joins: lucian (lucian@moz-22A14C6A.cable.virginmedia.com)
[18:54:00] *** Quits: lucian (lucian@moz-22A14C6A.cable.virginmedia.com) (Ping timeout)
[18:55:01] <jedestep> question about std::ptr::copy_memory, documentation says it copies "elements (not bytes)"; it is not explicitly copying a vector, so what is meant by "elements"?
[18:55:12] *** Quits: Jesin (Jessin_@moz-3AD6F09F.res.lehigh.edu) (Ping timeout)
[18:56:12] <strcat> values
[18:56:44] <strcat> if you give it a count of 5 it will copy 5 objects
[18:57:12] <jedestep> and it decides the size of an object based on the type T it's given
[18:57:20] <strcat> yes
[18:57:22] <jedestep> ok
[18:57:34] <jedestep> i can maybe make that work
[18:57:45] <strcat> nmatsakis: you were talking about vec::consume the other day, right? I can't see that trick being safe because of RWARC
[18:57:51] <strcat> (what it uses)
[18:58:15] <strcat> but... maybe RWARC is what needs to be changed
[18:58:27] <strcat> it makes us have to worry about exception safety
[18:59:08] *** Quits: novabyte (Instantbir@moz-3E0F9699.cable.virginmedia.com) (Quit: bye bye)
[19:02:34] *** Quits: ksev (DrunkenPan@745B767B.989A61DC.CA5B6332.IP) (Ping timeout)
[19:03:00] *** Quits: SimonSapin (simon@88F51059.F3BBB17D.144F44FA.IP) (Ping timeout)
[19:03:41] *** Quits: orshem (orshem@3545E24A.588A166C.E3D28531.IP) (Quit: Leaving)
[19:03:47] *** Joins: orshem (orshem@3545E24A.588A166C.E3D28531.IP)
[19:04:14] *** Joins: cstrahan (cstrahan@moz-4C7E5789.hsd1.dc.comcast.net)
[19:05:34] *** Joins: ksev (DrunkenPan@745B767B.989A61DC.CA5B6332.IP)
[19:05:47] *** Quits: carllerche (carllerche@6B070D22.7E6A0813.1428D117.IP) (Quit: carllerche)
[19:07:54] *** Joins: doomlord (doomlod@moz-6651F8D4.range86-145.btcentralplus.com)
[19:09:51] <bblum> what will happen when we have 32 rustc -Z flags and want to add a 33rd
[19:09:58] *** Quits: orshem (orshem@3545E24A.588A166C.E3D28531.IP) (Ping timeout)
[19:10:38] *** Joins: orshem (orshem@3545E24A.588A166C.E3D28531.IP)
[19:10:46] *** Quits: tjc (tjc@6902864.17C2F9C.163DC5C6.IP) (Quit: zzzzzzzzzz)
[19:11:28] <SiegeLord> They'll have to add a -ZZ
[19:11:38] *** Quits: Jesse (jruderman@moz-537BCF9.hsd1.ca.comcast.net) (Quit: Jesse)
[19:12:00] <benh> shouldn't it roll over to -AA
[19:12:39] *** Quits: jedestep (jedestep@34641662.FB4DE631.66C78B76.IP) (Quit: jedestep)
[19:14:26] *** Quits: tedh (tedh@moz-CE9B2F5A.cinci.res.rr.com) (Client exited)
[19:14:47] *** Quits: rajul (quassel@A2DDF553.812B5995.2051BA92.IP) (Client exited)
[19:15:40] <cmr> bblum: are -Z flags stored in a 5 bit value?
[19:15:56] *** Quits: vk (chatzilla@3E9D68F2.B1163E0C.2A6693DD.IP) (Ping timeout)
[19:15:59] *** Joins: infynyxx (infynyxx@DB780A29.749BA1D.DCC373F0.IP)
[19:16:24] *** Joins: vk (chatzilla@3E9D68F2.B1163E0C.2A6693DD.IP)
[19:16:41] *** Quits: infynyxx (infynyxx@DB780A29.749BA1D.DCC373F0.IP) (Client exited)
[19:17:17] <bblum> cmr: they are bits in a uint that get ored together
[19:17:26] *** Joins: infynyxx (infynyxx@DB780A29.749BA1D.DCC373F0.IP)
[19:17:36] <cmr> ew
[19:18:01] *** Quits: mib_znigap (Mibbit@BBE7C46A.B4F11D08.8612FA94.IP) (Quit: http://www.mibbit.com ajax IRC Client)
[19:18:10] <cmr> it should be a ~[Zflag]
[19:18:16] *** Quits: orshem (orshem@3545E24A.588A166C.E3D28531.IP) (Ping timeout)
[19:18:30] *** Joins: steven_is_false (user@moz-144077DE.bchsia.telus.net)
[19:19:05] <SiegeLord> Is there no flag macro?
[19:19:06] *** Joins: BitPuffin (quassel@moz-26C91AC6.cust.tele2.se)
[19:19:47] <cmr> what would it do?
[19:19:55] *** Joins: orshem (orshem@3545E24A.588A166C.E3D28531.IP)
[19:20:53] <SiegeLord> Hmm... not sure
[19:21:10] *** Joins: jedestep (jedestep@34641662.FB4DE631.66C78B76.IP)
[19:22:19] *** Quits: orshem (orshem@3545E24A.588A166C.E3D28531.IP) (Quit: Leaving)
[19:22:19] <SiegeLord> Some kind of typesafe flag mechanism... not sure how it would work (no idea how you overload operators in Rust)
[19:22:23] <jack> where do i ge a FILE*. there are readers for FILE*, but there seems to be nothing that will return one.
[19:25:29] *** Quits: brendan (brendaneic@moz-BE33DA21.fw1.sfo1.mozilla.net) (Quit: brendan)
[19:26:00] <Blei> hmm, what does the align field in tydescs correspond with, min_align or pref_align?
[19:27:04] *** Joins: brson (brson@2557E599.66715431.D25A875A.IP)
[19:27:04] *** ChanServ sets mode: +o brson
[19:27:51] *** Quits: bytbox (s@moz-BA9A08F8.wireless.umd.edu) (Ping timeout)
[19:28:47] *** Joins: fran (fran@79AF8722.E2041B94.8ACE28DB.IP)
[19:28:57] *** Joins: jviereck (Adium@moz-2E67E93A.ethz.ch)
[19:29:10] <Blei> seems to be min_align
[19:30:25] <bblum> brson: i dunno the specifics of tombstoning, but if you wanted me to add the arc idea to my taskgroup code, i could do it pretty quickly
[19:30:38] *** Joins: frogzilla (Mibbit@BBE7C46A.B4F11D08.8612FA94.IP)
[19:30:51] *** Joins: SimonSapin (simon@moz-73287A57.zone9.bethere.co.uk)
[19:31:29] <bblum> brson: personally i'm anxious at the claim that nobody will need the functionality that my old taskgroup provides, but i guess my track record for language proposals along those lines is pretty bad
[19:32:46] *** Joins: brendan (brendaneic@moz-BE33DA21.fw1.sfo1.mozilla.net)
[19:33:35] *** Quits: cstrahan (cstrahan@moz-4C7E5789.hsd1.dc.comcast.net) (Ping timeout)
[19:36:09] <indutny> is it known that rustc sometimes complains about unused importants
[19:36:25] <bblum> rustc is such a complainer
[19:36:27] <cmr> indutny: during the rust build?
[19:36:28] <indutny> when they're actually used inside generic trait implementation
[19:36:30] <indutny> nope
[19:36:33] <cmr> oh
[19:36:33] <indutny> so like
[19:36:44] *** Quits: erickt (erickt@8C9ECD8F.3A598286.F12515B4.IP) (Quit: Leaving.)
[19:36:45] <cmr> strcat: get rusti back in here!
[19:37:13] *** Joins: rusti (rusti@moz-54F7FD49.cpe.net.cable.rogers.com)
[19:37:18] <Eridius> rusti: botsnack
[19:37:19] -rusti- "nom nom"
[19:37:50] <cmr> rusti: botsnack.slice(0, botsnack.len())
[19:37:52] -rusti- "nom nom"
[19:37:52] <Eridius> rusti: "Om " + botsnack
[19:37:53] -rusti- ~"Om nom nom"
[19:38:28] <steven_is_false> rusti: do 5.times { botsnack }
[19:38:28] -rusti- <anon>:9:26: 9:38 error: mismatched types: expected `bool` but found `&'static str` (expected bool but found &'static str)
[19:38:28] -rusti- <anon>:9     let r = {  do 5.times { botsnack }
[19:38:28] -rusti-                                    ^~~~~~~~~~~~
[19:38:28] -rusti- error: aborting due to previous error
[19:38:29] -rusti- application terminated with error code 101
[19:38:36] <steven_is_false> rusti: do 5.times { println(botsnack) }
[19:38:36] -rusti- <anon>:9:26: 9:47 error: Do-block body must return bool, but returns () here. Perhaps you meant to write a `for`-loop?
[19:38:36] -rusti- <anon>:9     let r = {  do 5.times { println(botsnack) }
[19:38:36] -rusti-                                    ^~~~~~~~~~~~~~~~~~~~~
[19:38:37] -rusti- error: aborting due to previous error
[19:38:37] *** concrete.mozilla.org sets mode: +M 
[19:38:37] -rusti- application terminated with error code 101
[19:38:45] <Eridius> rusti: for 5.times { println(botsnack) }
[19:38:47] -rusti- more than 5 lines of output, pastebinned: http://sprunge.us/NCTg
[19:38:55] <flu_> he's choking on botsnacks!
[19:39:04] <flu_> 5 is too many! haven't you played nethack? :-P
[19:40:17] *** Quits: brendan (brendaneic@moz-BE33DA21.fw1.sfo1.mozilla.net) (Quit: brendan)
[19:40:43] <bstrie> rusti: botsnack.as_bytes()
[19:40:44] -rusti- &[110, 111, 109, 32, 110, 111, 109]
[19:41:09] <bstrie> rusti: let botsnack = 2; botsnack
[19:41:09] -rusti- <anon>:9:19: 9:27 error: only refutable patterns allowed here
[19:41:10] -rusti- <anon>:9     let r = {  let botsnack = 2; botsnack
[19:41:10] -rusti-                             ^~~~~~~~
[19:41:10] -rusti- error: aborting due to previous error
[19:41:10] -rusti- application terminated with error code 101
[19:41:15] *** Quits: devinus (devinus@moz-B4AF84BC.ptr.us.xo.net) (Quit: Textual IRC Client: www.textualapp.com)
[19:41:21] <cmr> whu?
[19:41:32] *** Joins: devinus (devinus@moz-B4AF84BC.ptr.us.xo.net)
[19:41:33] <cmr> whu?
[19:41:37] <bstrie> that's weird
[19:41:45] <bstrie> rusti: let foo = 2; foo
[19:41:46] -rusti- 2
[19:42:06] <bstrie> rusti: let r = 2; r
[19:42:07] -rusti- 2
[19:42:22] <bstrie> maybe it's just doing a textual replace
[19:42:31] <bstrie> rusti: "foobotsnack"
[19:42:32] -rusti- "foobotsnack"
[19:42:37] <bstrie> rusti: "foo botsnack "
[19:42:39] -rusti- "foo botsnack "
[19:43:27] *** Quits: devinus (devinus@moz-B4AF84BC.ptr.us.xo.net) (Quit: Textual IRC Client: www.textualapp.com)
[19:43:36] *** concrete.mozilla.org sets mode: -M 
[19:44:16] <Eridius> if it was a textual replace, how would the error messages be saying botsnack?
[19:44:22] <bstrie> right
[19:44:22] *** Joins: brendan (brendaneic@moz-BE33DA21.fw1.sfo1.mozilla.net)
[19:44:27] <bstrie> that occurred to me after I said it :P
[19:44:31] <Eridius> what does that +M flag actually do?
[19:44:40] <cmr> Eridius: can't talk unless registered and identified
[19:44:50] <Eridius> ah
[19:44:59] <Eridius> good thing I register out of habit then
[19:45:52] *** Joins: carllerche (carllerche@moz-BF6CB667.hsd1.ca.comcast.net)
[19:46:15] <engla> the plebs (like me) are shut out with +M
[19:46:31] <cmr> and presumably the spammers too
[19:47:14] <bblum> is there a way to make test cases compile with certain -Z options
[19:47:16] <bblum> probably not huh
[19:48:32] *** Joins: erickt (erickt@8C9ECD8F.3A598286.F12515B4.IP)
[19:50:18] <bblum> oh nice there is
[19:50:25] *** Joins: MX80 (MX80@moz-32BE33CD.dsl.g3telecom.net)
[19:51:23] *** Joins: rajul (quassel@A2DDF553.812B5995.2051BA92.IP)
[19:53:33] *** Joins: bytbox (s@moz-D83E9B31.wireless.umd.edu)
[19:54:37] *** Joins: Lovot (root@AE31FB56.8153C3BF.F3C9A2D9.IP)
[19:54:40] *** Quits: pcwalton (pcwalton@43CB6079.66715431.D25A875A.IP) (Input/output error)
[19:54:49] *** Joins: reyre_ (reyre@86C3727C.33EE9F8A.1139E686.IP)
[19:56:12] *** Quits: lkuper_ (lkuper@moz-C0CD33ED.hsd1.in.comcast.net) (Ping timeout)
[19:56:29] *** Joins: lkuper_ (lkuper@moz-C0CD33ED.hsd1.in.comcast.net)
[19:58:56] <cmr> Who was working on a dependency graph generator for rust source? Was it aatch?
[19:59:11] *** Joins: ecr (ereed@2557E599.66715431.D25A875A.IP)
[20:00:15] *** Quits: vmx (vmx@moz-68DB8EFC.pools.arcor-ip.net) (Quit: Leaving)
[20:01:08] <cmr> https://github.com/mozilla/rust/wiki/Bikeshed-rustdoc
[20:01:09] *** Quits: lkuper_ (lkuper@moz-C0CD33ED.hsd1.in.comcast.net) (Ping timeout)
[20:01:24] *** Joins: lkuper_ (lkuper@moz-C0CD33ED.hsd1.in.comcast.net)
[20:02:30] *** Joins: true_droid (Adium@moz-123FD9B8.beck.volia.net)
[20:03:18] *** Quits: SimonSapin (simon@moz-73287A57.zone9.bethere.co.uk) (Connection reset by peer)
[20:03:32] *** Joins: SimonSapin (simon@moz-73287A57.zone9.bethere.co.uk)
[20:03:38] *** Quits: lkuper_ (lkuper@moz-C0CD33ED.hsd1.in.comcast.net) (Quit: Leaving)
[20:03:44] *** Joins: lkuper_ (lkuper@moz-C0CD33ED.hsd1.in.comcast.net)
[20:05:44] *** Quits: brendan (brendaneic@moz-BE33DA21.fw1.sfo1.mozilla.net) (Quit: brendan)
[20:07:57] *** Quits: FrozenCow (FrozenCow@moz-B2DF4929.chello.nl) (Ping timeout)
[20:10:22] *** Joins: devinus (devinus@moz-B4AF84BC.ptr.us.xo.net)
[20:12:00] *** Joins: cstrahan (cstrahan@moz-4C7E5789.hsd1.dc.comcast.net)
[20:12:23] <graydon> strcat: ping
[20:12:41] *** Joins: tikue (tkuehn@2557E599.66715431.D25A875A.IP)
[20:12:53] <strcat> graydon: pong
[20:13:16] <graydon> strcat: I'm not clear on what you're arguing in the bug about str/u8, thought I'd ask here :)
[20:13:28] *** Joins: brendan (brendaneic@moz-BE33DA21.fw1.sfo1.mozilla.net)
[20:13:29] <strcat> graydon: well \0 is a valid character in utf-8
[20:13:38] <strcat> so null-terminated string APIs don't support utf-8
[20:13:42] *** Quits: tikue (tkuehn@2557E599.66715431.D25A875A.IP) (Quit: tikue)
[20:13:45] <graydon> it's a valid character in ascii as well
[20:13:50] *** Joins: Jesin (Jessin_@moz-157A63DD.cc.lehigh.edu)
[20:13:51] <Eridius> I have to say, in all my years using utf-8, I've never actually seen a NUL inside a utf-8 string
[20:13:51] *** Quits: eschweic (Adium@2557E599.66715431.D25A875A.IP) (Quit: Leaving.)
[20:14:11] <strcat> I've never seen lots of code points ;p, I don't even have fonts that can display all of them
[20:14:13] <strcat> it's still valid though
[20:14:28] <indutny> hm...
[20:14:32] *** Quits: vk (chatzilla@3E9D68F2.B1163E0C.2A6693DD.IP) (Ping timeout)
[20:14:33] <graydon> what exactly do you think we ought to send to fopen(char* path, char* mode)?
[20:14:34] <indutny> is there any way to have mutable static variables?
[20:14:35] <rubber-duck> is there a reason some structs inside compiler are using different naming convention - eg. "creader_cache_key" vs "Method" - is this legacy or is there a pattern :|
[20:14:50] <strcat> graydon: well we can't use str for that because paths don't have to be unicode
[20:14:58] <Eridius> strcat: they do on OS X ;)
[20:14:58] <strcat> at least on linux, they can have anything but \0 and /
[20:15:07] <strcat> Eridius: on every filesystem OS X can support?
[20:15:08] <graydon> strcat: that's a null terminated string API. if we give it ascii, it might also fail.
[20:15:13] <Eridius> strcat: ehh, good point
[20:15:17] <Eridius> I guess I was thinking of HFS+
[20:15:20] *** Joins: vk (chatzilla@3E9D68F2.B1163E0C.2A6693DD.IP)
[20:15:25] <strcat> graydon: yep, but it should be using &[u8]
[20:15:36] <strcat> &str won't work because then you can't open all files
[20:15:54] <strcat> so whether we put \0 at the end of strings by default doesn't really help (anyway, slices aren't always null-terminated atm)
[20:15:58] *** Joins: tikue (tkuehn@2557E599.66715431.D25A875A.IP)
[20:16:05] <graydon> strcat: ok. so we need an character-encodings module that has some common restrictions like this?
[20:16:17] <strcat> graydon: well we have Path, so it can deal with that
[20:16:27] <Blei> rubber-duck: because the compiler is very old/crufty
[20:16:32] <strcat> but you can only really find out about file name issues at runtime
[20:16:45] <strcat> because you don't know if it's FAT32, ext4, NTFS, zfs, ...
[20:16:49] <graydon> ok. how about puts(char*, FILE*) ?
[20:16:58] <strcat> graydon: well that's not a useful API :)
[20:17:04] <graydon> how about perror(char*) ?
[20:17:13] <graydon> system(char*)?
[20:17:16] <strcat> graydon: the lower level POSIX/win32 functions use bytes
[20:17:18] <graydon> getenv(char*) ?
[20:17:27] <graydon> bytes in what encoding?
[20:17:33] <strcat> graydon: none, files can be binary :)
[20:17:57] <strcat> you can layer str on top of it and enforce that some files aren't binary - but are you going to read to the end of the file when you open it to make sure?
[20:17:57] <graydon> let me ask differently: how long is the parameter to getenv()?
[20:18:16] <graydon> or strcat() for that matter?
[20:18:37] *** Quits: vcl (chatzilla@741D4FEA.76F9E272.DA40C4B3.IP) (Quit: ChatZilla 0.9.90 [Firefox 21.0/20130511120803])
[20:18:38] <strcat> graydon: getenv is one where you actually need \0-termination
[20:18:47] <strcat> but env variables aren't restricted to unicode
[20:18:50] <graydon> maybe I'm asking the wrong question: do we not, to use any such API, need a function that nul-terminates a buffer?
[20:18:52] <strcat> we're incorrectly using str for them right now
[20:18:58] <strcat> graydon: we can have CString like haskell
[20:19:07] <graydon> fair, we might be misusing them
[20:19:10] <strcat> str isn't useful for env variables, file paths, etc. because they aren't restricted to utf-8
[20:19:10] <graydon> what is CString?
[20:19:17] <strcat> graydon: a null-terminated bytestring
[20:19:27] <graydon> does it have any other interesting properties?
[20:19:31] <graydon> "no internal nulls" say?
[20:19:40] <strcat> graydon: yeah, it won't have internal nulls
[20:19:46] <strcat> since the \0 marks the env
[20:19:48] <strcat> end*
[20:20:07] <kimundi> Sounds like we need a new unsized type c_str then :P
[20:20:15] <strcat> newCString :: String -> IO CStringSource
[20:20:17] <strcat> Marshal a Haskell string into a NUL terminated C string.
[20:20:19] <strcat>     the Haskell string may not contain any NUL characters 
[20:20:23] <graydon> ok
[20:20:51] <strcat> graydon: and that covers env variables and files, at least
[20:21:29] <graydon> I would be ok with a CString type of this sort. so long as they can be stack allocated with a small-string-optimization.
[20:21:38] <strcat> open() is a syscall so it doesn't really matter if you copy (it will be small anyway)
[20:21:48] <kimundi> You couldn't slice a c_str, though
[20:21:49] <graydon> (and easily constructed from a str)
[20:21:58] <graydon> yeah, that's ok.
[20:22:05] <steven_is_false> rusti: bytes!("foo")
[20:22:06] -rusti- &[102, 111, 111]
[20:22:07] *** Quits: fabiand (fabiand@moz-AB28A0AF.adsl.alicedsl.de) (Quit: Verlassend)
[20:22:10] <strcat> kimundi: well I plan on making slices generic via a range trait
[20:22:19] <strcat> that's my plan for iterators at least
[20:22:31] <graydon> strcat: this strikes me as closely related to getting a sensible system in place for dealing with charset encoding
[20:22:49] <strcat> Iterator -> ForwardRange, next -> pop_front + add BidirectionalRange with pop_back
[20:22:56] <strcat> and pop_front_n/pop_back_n as default methods
[20:22:59] <steven_is_false> let my_function = my_dynamic_library.symbol(bytes!("my_function")) isn't too bad right?
[20:23:23] <kimundi> steven_is_false: That's what it is for
[20:23:26] <strcat> + RandomAccessRange with random access sub-slicing... harder to figure out that API though ;p
[20:24:03] <strcat> a deque can implement a bidirectional and random access range even though it isn't (always) contiguous
[20:24:09] <steven_is_false> kimundi: I was just unsure of how the wrapper over dynamic library stuff is going to deal with this stuff.
[20:24:37] <strcat> graydon: I realize that there are useful APIs using \0, I just don't think any of them are actually going to be used with &str/~str :)
[20:24:54] <strcat> so whether or not we put \0 at the end we have the same problems
[20:25:05] *** Joins: snadon (chatzilla@moz-3BC727E8.mc.videotron.ca)
[20:25:11] <strcat> slices won't ever have \0 without a copy, and most APIs should be using slices/ranges
[20:25:27] <strcat> at least not *all* slices, *some* &'static str slices have them right now
[20:25:34] <graydon> strcat: slices currently do have \0 without a copy. but if we remove it, what you say is true.
[20:25:39] <strcat> graydon: some do
[20:25:42] <graydon> (slices derived from ~str)
[20:25:45] <graydon> and static
[20:25:48] <graydon> and @str
[20:25:49] <strcat> "foo" will, but not "foo".slice(0, 1)
[20:25:49] <graydon> but anyway
[20:25:53] <strcat> and that's still static
[20:25:53] <graydon> correct
[20:25:55] <kimundi> strcat: Only buggy one don't :P
[20:25:55] <bstrie> I like the idea of having a separate CString type. someone should write this idea somewhere more permanent
[20:26:06] <graydon> I am writing it into the bug in question
[20:26:10] <graydon> I want to link it to encoding
[20:26:30] <graydon> because I don't want to revisit encoding again later. this is a good enough time. the IO library is awaiting a champion to redesign its layers as well.
[20:26:33] <graydon> this fits with that task
[20:27:21] <kimundi> graydon: It would be cool if you could user define unsized types, then we could just grow an string-encoding library that works like our str today
[20:27:30] <strcat> graydon: the Go authors share part of the blame for nul-terminated strings and they left them out completely ;p
[20:27:43] *** Quits: jviereck (Adium@moz-2E67E93A.ethz.ch) (Quit: Leaving.)
[20:27:44] <strcat> kimundi: can already make nice user-defined strings/vectors
[20:27:52] <graydon> they left out "accessing the OS via libc" almost entirely
[20:27:56] <graydon> no?
[20:27:58] <strcat> just can't choose the same perf tradeoff that the built-ins do
[20:28:18] <strcat> graydon: well they implemented that stuff themselves
[20:28:21] <graydon> yeah
[20:28:30] <Eridius> graydon: they did? you can call any C function using cgo
[20:28:30] *** Parts: steven_is_false (user@moz-144077DE.bchsia.telus.net) (ERC Version 5.3 (IRC client for Emacs))
[20:29:04] <strcat> graydon: libc doesn't really have much that's useful for us, imo
[20:29:12] <kimundi> strcat: Sure, but if the building blocks of the build-in ones could be used anywhere, they won't need to be special anymore. :)
[20:29:25] <strcat> well you can use slices on custom types
[20:29:36] <frogzilla> sorry I've not been able to keep up with the avid iterator discussion -- what's the accepted way to iterate across vector elements to operate on them?
[20:29:51] <strcat> frogzilla: for xs.iter().advance |x| { }
[20:29:55] <strcat> frogzilla: or for xs.mut_iter().advance |x| { }
[20:30:02] <frogzilla> excellent, thank you!
[20:30:08] <strcat> .advance will go away when 'for' learns about them
[20:30:20] <frogzilla> oh
[20:30:23] <graydon> strcat: it avoids having to invoke system calls manually. I guess we could do that ourselves, but I think libc is nontrivial.
[20:30:29] <frogzilla> meaning this is not long term?
[20:30:36] <jedestep> sounds like it will at least be a find/replace fix
[20:30:48] <graydon> strcat: and on windows, "invoke system call manually" isn't even defined / documented. you have to reverse engineer it. the official API is kernel32.dll and such
[20:30:50] <frogzilla> hope so :P
[20:31:09] <strcat> graydon: yeah, I think they just go through libc on windows though
[20:31:35] <graydon> I am happy to keep using libc for now. we have larger fish to fry and it's pretty robust code, if occasionally API-crusty
[20:31:49] *** Quits: infynyxx (infynyxx@DB780A29.749BA1D.DCC373F0.IP) (Client exited)
[20:31:51] <graydon> the amount of energy I've put into std::libc is tiny compared to what I'd have to do if we "did it ourselves", and we've limited resources
[20:31:51] <strcat> graydon: there are a lot of problems with it though
[20:31:54] *** Quits: Blei (philipp@moz-96D25F7A.cust.bluewin.ch) (Quit: WeeChat 0.4.1)
[20:31:59] <strcat> graydon: chdir for example, we have races from that
[20:32:04] <strcat> POSIX has openat
[20:32:07] <strcat> dunno what windows has
[20:32:19] <strcat> tasks could have a task-local directory as long as windows has an equivalent
[20:33:17] <strcat> and we should be using O_CLOEXEC for all files, I know node.js does
[20:33:28] <strcat> + doing buffering ourselves is likely better
[20:34:42] <graydon> I agree with some of these points, not others. But we only gained inline asm recently and it'll be spotty / platform-specific if and when we can.
[20:34:47] *** Joins: Blei (philipp@moz-96D25F7A.cust.bluewin.ch)
[20:35:10] <strcat> graydon: well I don't think it's important to worry about yet, but I don't think we want to be using libc in the long run
[20:35:14] <graydon> I don't mind bypassing libc in cases where it's clear we can do better. I'm not in the mood to rip out libc bindings "on principle" when they're still useful for a lot of stuff.
[20:35:23] <graydon> that's possible, sure
[20:35:24] <strcat> using libc also means we can't do real static linking, because glibc is evil
[20:35:32] <Blei> quick question: if i were to add new lang items, can i just follow the existing implementation in middle::lang_items, or are there many hidden gotchas?
[20:35:40] <graydon> we had someone suggesting porting us to the raw xen hypervisor calls at one point too
[20:35:47] *** Joins: pyrac (pyrac@moz-DAB0A516.w109-222.abo.wanadoo.fr)
[20:35:54] <graydon> Blei: should be mostly obvious
[20:35:54] <strcat> graydon: it's a pain to do it properly
[20:36:03] <Blei> graydon: thanks, great to hear :D
[20:36:10] <kimundi> frogzilla: The for loop might get changed to use iterators directly. So 'for xs.iter().advance |b| {  ... }' would degenerate to 'for xs.iter() |b| {  ... }' or even 'for xs |b| {  ... }'
[20:36:39] <strcat> graydon: because glibc doesn't actually make syscalls directly anymore
[20:36:42] <strcat> graydon: https://en.wikipedia.org/wiki/VDSO
[20:37:14] *** Quits: reyre_ (reyre@86C3727C.33EE9F8A.1139E686.IP) (Client exited)
[20:37:17] *** Joins: infynyxx (infynyxx@DB780A29.749BA1D.DCC373F0.IP)
[20:37:49] *** Joins: azita (Azita@2557E599.66715431.D25A875A.IP)
[20:38:42] *** Joins: Nawfel (Mibbit@AA35313D.368280C4.DFAB1F33.IP)
[20:39:11] * strcat gets really annoyed by some of glibc's evil tricks like caching getpid
[20:39:12] *** Joins: devbug (quassel@moz-E1DE087C.bchsia.telus.net)
[20:39:21] <strcat> that's why you aren't allowed to make a pid namespace without a fork :[
[20:39:47] <graydon> strcat: I do not exactly understand how a VDSO works
[20:39:55] *** Quits: Blei (philipp@moz-96D25F7A.cust.bluewin.ch) (Quit: WeeChat 0.4.1)
[20:40:30] <strcat> graydon: it's some magic the dynamic linker does for you afaik, it lets you call kernel code as if it was a shared object
[20:40:44] <frogzilla> kimundi got it, thanks
[20:40:45] <graydon> sure sure
[20:40:55] <strcat> it's required to make fast syscalls and take advantage of stuff like clock_gettime not requiring a context switch
[20:40:59] <graydon> but I mean, doesn't the kernel have to map the data structures used into userspace for that to work also?
[20:41:19] <strcat> graydon: it's probably just some reserved address space
[20:41:23] <graydon> it's not getting the code or permissions right that surprises me; it's the amount of kernel data structures that have to be visible
[20:41:40] <graydon> presumably they only do read-only mappings?
[20:41:44] <strcat> graydon: dunno :)
[20:41:58] <strcat> linux is really weird though ;]
[20:42:08] <jedestep> ^ words of wisdom
[20:42:22] <BitPuffin> Freebsd and Haiku ftw
[20:42:24] <strcat> namespaces for example
[20:42:32] *** Quits: Jesin (Jessin_@moz-157A63DD.cc.lehigh.edu) (Ping timeout)
[20:42:34] <graydon> yeah. so um, I really don't want to be struggling with keeping up with linux kernel APIs if I can avoid it.
[20:42:45] <graydon> I have enough difficulties arguing over the meaning of semicolons and such adventures in language design
[20:42:45] <strcat> graydon: well there's no keeping up, it's a stable ABI
[20:42:48] <strcat> they've never broken it
[20:43:05] <BitPuffin> well they have but then they have suffered the wrath of torvalds
[20:43:44] <graydon> ok. I won't say no (especially if it performs well), I just think we've bigger fish to fry at the moment.
[20:43:54] *** Joins: eschweic (Adium@2557E599.66715431.D25A875A.IP)
[20:44:00] <graydon> but I can't choose what others work on :)
[20:44:04] <strcat> graydon: yeah, I don't think it's an important thing to do ;p
[20:44:12] <strcat> I just think it should *eventually* be done
[20:44:27] <strcat> there aren't many advantages as long as we always link to libc/libstdc++ anyway
[20:45:19] * strcat doesn't mean "weird" in a bad way anyway
[20:45:35] <strcat> things like cgroups and namespaces are awesome, just not at all conventional unix
[20:45:42] *** Joins: dylukes (dylukes@moz-A27EFB78.wireless.pitt.edu)
[20:45:47] *** Joins: Jesin (Jessin_@moz-157A63DD.cc.lehigh.edu)
[20:45:50] <strcat> if only CLONE_NEWUSER worked....
[20:45:56] <Eridius> speaking of libstdc++, I'd love to know how to fix https://github.com/mozilla/rust/issues/6849, wherein my librustllvm actually links to libc++
[20:47:00] <graydon> "conventional unix" is a very random assortment of weird itself.
[20:47:41] <strcat> graydon: it's pretty weird/awesome that each process can have an entirely different mapping of uids/gids, pids, mounts, etc. :)
[20:48:11] *** Quits: Axord (xord@moz-C3CCF156.lsanca.dsl-w.verizon.net) (Quit: I'm sure it's perfectly safe)
[20:48:29] <graydon> 4.4BSD-after-the-lawsuits + random-forgotten-SVID-experiments
[20:48:54] <graydon> unix purists crack me up. whatever. I just want to be able to copy bytes in and out of my program and maybe not race on temporary files.
[20:49:09] <graydon> (>0 atomic filesystem opreations would be cool also)
[20:49:12] *** Quits: eschweic (Adium@2557E599.66715431.D25A875A.IP) (Ping timeout)
[20:49:20] <strcat> graydon: the alternate C libraries are having to add all the linux-y APIs now
[20:49:33] <strcat> so udev still works with them ;p, because they care about doing things *right* now without races
[20:50:00] *** Joins: Jesse (jruderman@moz-537BCF9.hsd1.ca.comcast.net)
[20:50:50] *** Quits: dylukes (dylukes@moz-A27EFB78.wireless.pitt.edu) (Quit: ["Textual IRC Client: www.textualapp.com"])
[20:51:41] <strcat> graydon: at least there are atomic operations on single files now
[20:51:44] *** Quits: tikue (tkuehn@2557E599.66715431.D25A875A.IP) (Quit: tikue)
[20:51:46] <strcat> cp --reflink foo foo.new
[20:51:52] <strcat> modify foo.new, rename it back
[20:52:03] <strcat> it only copies the blocks you modify at least
[20:52:32] <strcat> (on btrfs... and maybe zfs only though)
[20:52:56] *** Joins: sk (sk@61A494B3.BA40E8A.AAC02D62.IP)
[20:53:12] <strcat> I guess snapshots actually give you that for directories...
[20:53:29] <graydon> so long as mkdir, creat, unlink and rename are indivisible, I can get stuff done :)
[20:54:37] *** Quits: devinus (devinus@moz-B4AF84BC.ptr.us.xo.net) (Quit: Computer has gone to sleep.)
[20:55:08] <strcat> sqlite would benefit a lot from reflink
[20:55:12] <strcat> I wonder if it knows how to use it
[20:55:27] <strcat> a transaction copies the entire db to a journal file
[20:55:54] *** Quits: Nawfel (Mibbit@AA35313D.368280C4.DFAB1F33.IP) (Quit: http://www.mibbit.com ajax IRC Client)
[20:58:21] *** Joins: eschweic (Adium@2557E599.66715431.D25A875A.IP)
[20:58:22] *** Joins: tikue (tkuehn@2557E599.66715431.D25A875A.IP)
[20:58:37] *** Joins: snearch (snearch@moz-94670B58.pool.mediaways.net)
[20:59:24] *** Joins: pcwalton (pcwalton@43CB6079.66715431.D25A875A.IP)
[20:59:24] *** ChanServ sets mode: +o pcwalton
[20:59:35] *** Joins: seth (seth@2557E599.66715431.D25A875A.IP)
[20:59:37] *** Quits: pyrac (pyrac@moz-DAB0A516.w109-222.abo.wanadoo.fr) (Quit: pyrac)
[21:00:26] <bstrie> cmr: rewriting rustdoc is something I've been waiting for for a long time, I wish you luck
[21:02:45] *** Joins: infynyxx_ (infynyxx@DB780A29.749BA1D.DCC373F0.IP)
[21:03:05] *** Quits: Palmik (palmik@moz-5CA3F354.pks.muni.cz) (Quit: Lost terminal)
[21:03:06] *** Quits: brendan (brendaneic@moz-BE33DA21.fw1.sfo1.mozilla.net) (Quit: brendan)
[21:03:08] *** Quits: infynyxx (infynyxx@DB780A29.749BA1D.DCC373F0.IP) (Ping timeout)
[21:03:18] *** Joins: devinus (devinus@moz-B4AF84BC.ptr.us.xo.net)
[21:03:21] *** Quits: msingle (Thunderbir@moz-930E5D97.hr.hr.cox.net) (Quit: msingle)
[21:03:29] <strcat> anyway extending iterators to be more like ranges would mean a generic rfind/rposition
[21:03:30] *** Joins: eschweic1 (Adium@2557E599.66715431.D25A875A.IP)
[21:03:43] <SiegeLord> I don't really get the rustdoc proposal... the switching of the meanings of frontend/backend doesn't doesn't make it better
[21:04:34] *** Quits: eschweic (Adium@2557E599.66715431.D25A875A.IP) (Ping timeout)
[21:04:48] *** Quits: maxli (maxli@F2D29657.F60B0462.67AC9B1.IP) (Quit: Leaving.)
[21:04:51] *** Quits: EXetoC (ex@moz-C741B177.customer.t3.se) (Ping timeout)
[21:05:55] *** Parts: Lovot (root@AE31FB56.8153C3BF.F3C9A2D9.IP) (channel rust)
[21:06:13] <sully> hm, arg
[21:06:29] <sully> it looks like there is something that will cause build directory pollution again
[21:06:36] *** Joins: josh (josh@moz-348C4790.hsd1.mn.comcast.net)
[21:06:47] *** Quits: eschweic1 (Adium@2557E599.66715431.D25A875A.IP) (Quit: Leaving.)
[21:07:59] *** Joins: brendan (brendaneic@moz-BE33DA21.fw1.sfo1.mozilla.net)
[21:08:04] * strcat would like to eventually sandbox/isolate the test harness
[21:08:15] <strcat> on linux at least ;p
[21:08:23] *** Joins: pyrac (pyrac@moz-DAB0A516.w109-222.abo.wanadoo.fr)
[21:09:04] <strcat> although it would be nice to just have the test harness hand you a temp dir at least
[21:09:21] <strcat> in TLS? I dunno.
[21:09:32] *** Quits: brendan (brendaneic@moz-BE33DA21.fw1.sfo1.mozilla.net) (Quit: brendan)
[21:12:37] *** Quits: ksev (DrunkenPan@745B767B.989A61DC.CA5B6332.IP) (Ping timeout)
[21:12:58] *** Quits: seth (seth@2557E599.66715431.D25A875A.IP) (Connection reset by peer)
[21:13:14] *** Joins: seth (seth@2557E599.66715431.D25A875A.IP)
[21:13:21] *** Joins: ksev (DrunkenPan@745B767B.989A61DC.CA5B6332.IP)
[21:13:50] *** Joins: brendan (brendaneic@moz-BE33DA21.fw1.sfo1.mozilla.net)
[21:14:55] <strcat> sully: how goes the quest to make default methods work? :)
[21:17:32] *** Quits: tikue (tkuehn@2557E599.66715431.D25A875A.IP) (Quit: tikue)
[21:18:00] *** Quits: pyrac (pyrac@moz-DAB0A516.w109-222.abo.wanadoo.fr) (Quit: pyrac)
[21:18:48] *** Quits: true_droid (Adium@moz-123FD9B8.beck.volia.net) (Quit: Leaving.)
[21:18:58] *** Joins: tikue (tkuehn@2557E599.66715431.D25A875A.IP)
[21:21:22] <strcat> graydon: should POSIX bindings go in libc? or would it make sense to split out a posix.rs module
[21:21:41] <graydon> strcat: libc.rs is mostly posix bindings presently
[21:21:47] *** Quits: webber46 (webber46@moz-98D2F3C5.cust.bredband2.com) (Quit: webber46)
[21:22:10] <graydon> I think given that they show up in libc-the-shared-object, the fact that they are a superset of the C language standard library is not-too-important
[21:22:18] <graydon> at least that was my reasoning at the time
[21:22:22] <strcat> graydon: some do :), some are in rt.so on linux
[21:22:27] <strcat> librt.so*
[21:22:30] <strcat> and others
[21:22:36] <graydon> huh! miracles
[21:22:40] <strcat> and pthread
[21:23:00] <graydon> what's the meaning of the distinction there?
[21:23:13] <strcat> graydon: rt is supposed to be esoteric real-time stuff afaik
[21:23:18] <strcat> but clock_gettime was in it until recently
[21:23:22] <strcat> they moved it back to libc
[21:23:35] <strcat> (breaking a bunch of autoconf scripts checking for librt with clock_gettime)
[21:24:03] <graydon> weird
[21:24:19] <graydon> well, yeah, I mean, I lumped stuff-that-talks-to-kernel32.dll-and-user32.dll into libc.rs as well
[21:24:33] <graydon> "low level C foreign APIs for talking to the operating system"
[21:24:35] <graydon> mumble mumble
[21:24:58] <graydon> my only request if you go changing it is to be careful about the editability and tendency for things to multiply
[21:25:13] *** Quits: seth (seth@2557E599.66715431.D25A875A.IP) (Ping timeout)
[21:25:28] <graydon> the reason why it is the way it is now is to minimize the number of times you have to declare the same signature by platform/arch variants
[21:25:28] *** Quits: ksev (DrunkenPan@745B767B.989A61DC.CA5B6332.IP) (Ping timeout)
[21:25:31] *** Joins: seth (seth@2557E599.66715431.D25A875A.IP)
[21:25:41] <bblum> what will happen if i git push -f to a branch that has an open PR
[21:25:47] <bblum> let's find out i guess
[21:25:52] <strcat> bblum: the pull will just update to the new commits
[21:25:55] <strcat> it only references the branch
[21:25:58] <bblum> good
[21:26:15] <strcat> comments on commits will vanish, comments on line numbers will stay around as "outdated diffs" (why not save both? who knows!)
[21:27:25] *** Joins: eschweic (Adium@2557E599.66715431.D25A875A.IP)
[21:29:06] *** Quits: tikue (tkuehn@2557E599.66715431.D25A875A.IP) (Quit: tikue)
[21:30:26] <sully> strcat: I have a pending pull request that fixes a bunch of things
[21:30:42] <sully> strcat: I just discovered a bunch more problems, and am trying to figure out how to approach them best
[21:32:09] *** Joins: tikue (tkuehn@2557E599.66715431.D25A875A.IP)
[21:33:47] *** Quits: vk (chatzilla@3E9D68F2.B1163E0C.2A6693DD.IP) (Quit: ChatZilla 0.9.90 [Firefox 23.0a2/20130618004018])
[21:34:39] *** Joins: tedh (tedh@moz-CE9B2F5A.cinci.res.rr.com)
[21:38:14] <brson> graydon: got distracted for 3 hours. looking at the valgrind failure now
[21:38:33] <graydon> brson: no worries. I'm doing triage trying to get stuff ready for tomorrow, haven't diagnosed the rustpkg thing either.
[21:38:46] *** Joins: EXetoC (ex@moz-2DBEB1E4.customer.t3.se)
[21:39:26] *** Quits: BitPuffin (quassel@moz-26C91AC6.cust.tele2.se) (Ping timeout)
[21:39:36] *** Joins: orshem (orshem@3545E24A.588A166C.E3D28531.IP)
[21:42:18] *** Joins: BitPuffin (quassel@moz-26C91AC6.cust.tele2.se)
[21:43:14] *** Quits: brendan (brendaneic@moz-BE33DA21.fw1.sfo1.mozilla.net) (Quit: brendan)
[21:43:14] *** Joins: reyre_ (reyre@91189D34.E11ACA58.47C41102.IP)
[21:45:39] *** Joins: krebbit (Mibbit@moz-4E627A8B.range86-149.btcentralplus.com)
[21:46:41] *** Quits: cowboyd (cowboyd@moz-1BD02A1E.sw.biz.rr.com) (Client exited)
[21:46:52] *** Quits: reyre_ (reyre@91189D34.E11ACA58.47C41102.IP) (Client exited)
[21:47:52] *** Quits: spider-mario (spidermari@moz-2F72F6FF.dsl.quantic-telecom.net) (Input/output error)
[21:48:15] *** Quits: victorporof (victorporo@70DEDDA.9004F55.9B1E38F4.IP) (Quit: victorporof)
[21:48:53] *** Quits: SimonSapin (simon@moz-73287A57.zone9.bethere.co.uk) (Ping timeout)
[21:51:57] *** Quits: Azdle (Azdle@moz-B334B496.hfc.comcastbusiness.net) (Ping timeout)
[21:52:22] *** Quits: pnkfelix (pnkfelix@moz-43495417.fbx.proxad.net) (Quit: Leaving.)
[21:53:13] *** Quits: infynyxx_ (infynyxx@DB780A29.749BA1D.DCC373F0.IP) (Client exited)
[21:54:01] * pcwalton wishes http://doc.rust-lang.org/ worked
[21:55:44] <rubber-duck> pcwalton, what branch should I be looking at to see this : https://github.com/mozilla/rust/issues/2361 ?
[21:56:43] <rubber-duck> can't find "noteroots-ir"
[21:56:51] <pcwalton> rubber-duck: https://github.com/pcwalton/llvm/tree/noteroots-ir
[21:56:53] *** Quits: kini (kini@moz-92AA953A.members.linode.com) (Ping timeout)
[21:57:13] *** Joins: sw17ch (sw17ch@moz-39D8564F.wndsny.tds.net)
[21:57:13] <rubber-duck> oh right I was looking at Rust repo
[21:57:14] * graydon glares at tvec
[21:57:35] <graydon> what .. even .. this is amazing. I have no idea whether any of this code is live anymore.
[21:57:37] *** Joins: kini (kini@moz-92AA953A.members.linode.com)
[21:57:44] <graydon> we could really do with a coverage-o-meter
[21:57:47] <strcat> what's tvec?
[21:57:52] *** Joins: brendan (brendaneic@moz-BE33DA21.fw1.sfo1.mozilla.net)
[21:57:56] <pcwalton> translate vec
[21:58:04] <graydon> middle/trans/tvec.rs
[21:58:09] <pcwalton> that would be hilarious if it's unused
[21:58:17] <pcwalton> I thought it was though
[21:58:19] <pcwalton> due to import *
[21:58:37] <graydon> well, like, there's a fixme in here about the code for appending vectors specializing the case of known-type elements
[21:58:43] <graydon> like dating back from when elements could be dynamic-zed
[21:58:44] <graydon> sized
[21:58:46] <pcwalton> heh
[21:58:48] <pcwalton> that code is ancient
[21:58:53] <graydon> yes
[22:01:13] <BitPuffin> rust is a lot of haskell
[22:01:32] <BitPuffin> especially pattern matching
[22:01:47] *** Joins: mschifer1 (Adium@2557E599.66715431.D25A875A.IP)
[22:01:56] *** Quits: mschifer (Adium@2557E599.66715431.D25A875A.IP) (Ping timeout)
[22:02:07] *** Quits: sw17ch (sw17ch@moz-39D8564F.wndsny.tds.net) (Quit: sw17ch)
[22:02:56] *** Joins: infynyxx (infynyxx@DB780A29.749BA1D.DCC373F0.IP)
[22:02:58] *** Joins: pnathan (pnathan@moz-F0F9C5F5.pools.spcsdns.net)
[22:04:53] *** Quits: jedestep (jedestep@34641662.FB4DE631.66C78B76.IP) (Quit: jedestep)
[22:05:09] *** Quits: brendan (brendaneic@moz-BE33DA21.fw1.sfo1.mozilla.net) (Quit: brendan)
[22:07:08] *** Quits: Jesse (jruderman@moz-537BCF9.hsd1.ca.comcast.net) (Quit: Jesse)
[22:09:34] *** Quits: carllerche (carllerche@moz-BF6CB667.hsd1.ca.comcast.net) (Quit: carllerche)
[22:09:49] <cmr> bstrie: you originally inspired me to do it :)
[22:13:34] *** Quits: frogzilla (Mibbit@BBE7C46A.B4F11D08.8612FA94.IP) (Quit: http://www.mibbit.com ajax IRC Client)
[22:14:33] *** Joins: bjz (brendanzab@B398BE78.F804C29E.D35A31DF.IP)
[22:17:10] *** Joins: jensnockert (jensnocker@moz-C5F27039.cust.bredband2.com)
[22:17:23] *** Quits: sankha93 (Instantbir@B9DEEB97.F36055FE.8B6C1D65.IP) (Quit: Instantbird 1.4 -- http://www.instantbird.com)
[22:18:30] <BitPuffin> can rust ever return null or nil?
[22:18:45] <pcwalton> not unless you're calling C libraries in unsafe code that return NULL
[22:18:47] <cmr> rusti: return ()
[22:18:49] -rusti- more than 5 lines of output, pastebinned: http://sprunge.us/OCXR
[22:18:49] <BitPuffin> or does an if also have to have an else
[22:18:51] <pcwalton> the safe Rust language has no null
[22:19:09] <pcwalton> if you don't have an else on your if, the "then" branch has to unify with ()
[22:20:14] <BitPuffin> ()?
[22:20:52] <pcwalton> the unit type
[22:20:59] *** Joins: ghrust (ghrust@AD60B2E3.6A2AE50.F3114085.IP)
[22:21:00] <ghrust> 01[13rust01] 15brson pushed 1 new commit to 06master: 02http://git.io/tYIGKA
[22:21:00] <ghrust> 13rust/06master 14b7a6919 15Brian Anderson: rustc: Dispose of LLVM passes in test cases
[22:21:00] *** Parts: ghrust (ghrust@AD60B2E3.6A2AE50.F3114085.IP) ()
[22:21:22] *** Joins: ghrust (ghrust@C621748.6A2AE50.F3114085.IP)
[22:21:22] <ghrust> 01[13rust01] 15brson merged 06master into 06auto: 02http://git.io/I2s6rg
[22:21:22] *** Parts: ghrust (ghrust@C621748.6A2AE50.F3114085.IP) ()
[22:22:45] <cmr> brson: you opened the issue for rewrite/redesign rustdoc. Did you have any particular ideas, and would you mind looking over https://github.com/mozilla/rust/wiki/Bikeshed-rustdoc ?
[22:25:13] *** Quits: doener (doener@moz-121949B3.unitymediagroup.de) (Ping timeout)
[22:25:38] *** Quits: devinus (devinus@moz-B4AF84BC.ptr.us.xo.net) (Quit: Textual IRC Client: www.textualapp.com)
[22:26:44] *** Quits: donri (dag@moz-9BB61102.tbcn.telia.com) (Client exited)
[22:27:14] *** Joins: MaikKlein (maik@moz-36D8270A.dip0.t-ipconnect.de)
[22:28:17] <brson> cmr: yes, I will give your proposal some attention soon. thank you for taking up this topic
[22:28:41] <cmr> brson: thanks
[22:28:48] *** Quits: pnathan (pnathan@moz-F0F9C5F5.pools.spcsdns.net) (Quit: Colloquy for iPhone - http://colloquy.mobi)
[22:29:01] <engla> BitPuffin: rust has the wonderful feature of being able to do type inference on the return value
[22:29:09] <engla> much demonstrated by std::rand
[22:29:34] <BitPuffin> now that's wonderful
[22:34:39] <Earnestly> engla: How does it guess the type?
[22:35:31] <BitPuffin> Earnestly: magic
[22:36:47] *** Quits: rubber-duck (rubber-duc@moz-8F879002.dsl.iskon.hr) (Quit: Leaving)
[22:37:02] <Earnestly> I thought Rust was statically typed?
[22:37:34] <xenocons> black majik?
[22:37:55] <Eridius> Earnestly: it is
[22:38:16] *** Quits: Amanieu (amanieu@moz-D5D10CA8.halls.manchester.ac.uk) (Connection reset by peer)
[22:38:24] <xenocons> type inference + static typing, i can see how people from non static languages find it similar
[22:38:29] <xenocons> however, it is sound
[22:38:51] *** Joins: Amanieu (amanieu@moz-D5D10CA8.halls.manchester.ac.uk)
[22:39:31] <kimundi> Earnestly: The trick is that it guesses the type at compile time ;)
[22:39:46] <Earnestly> kimundi: Based on the return type declared in the function?
[22:39:54] *** Quits: orshem (orshem@3545E24A.588A166C.E3D28531.IP) (Quit: Leaving)
[22:40:04] <kimundi> For example yeah
[22:40:33] <Earnestly> kimundi: How else can it determine the type?
[22:40:42] <kimundi> But not only the return type, also the argument types, the usage later in your code etc
[22:40:48] *** Joins: jesseray (Mibbit@moz-B0004241.dynamic.ip.windstream.net)
[22:40:59] <strcat> Earnestly: it knows the type from what you do with it
[22:41:24] <Earnestly> strcat: "what you do with it"?
[22:41:27] <strcat> rusti: let mut xs = std::hashmap::HashSet::new(); xs.insert(5); xs.insert(6);
[22:41:28] -rusti- ()
[22:41:35] <strcat> rusti: let mut xs = std::hashmap::HashSet::new(); xs.insert("bar"); xs.insert("foo");
[22:41:37] -rusti- ()
[22:41:39] <strcat> rusti: let mut xs = std::hashmap::HashSet::new(); xs.insert("bar"); xs.insert(5);
[22:41:39] -rusti- <anon>:9:86: 9:87 error: mismatched types: expected `&'static str` but found `<VI0>` (expected &'static str but found integral variable)
[22:41:39] -rusti- <anon>:9     let r = {  let mut xs = std::hashmap::HashSet::new(); xs.insert("bar"); xs.insert(5);
[22:41:39] -rusti-                                                                                                ^
[22:41:39] -rusti- error: aborting due to previous error
[22:41:41] -rusti- application terminated with error code 101
[22:41:41] <Earnestly> strcat: It's surely not doing anything horrible like guessing?
[22:41:45] <strcat> Earnestly: no...
[22:41:50] <Earnestly> Okay, fine :D
[22:42:12] <strcat> it's inferred, not 'guessed'
[22:42:14] <xenocons> but type inference should do default cases i think
[22:42:41] <Eridius> rusti: let x = std::rand::random(); let y = std::rand::random(); println(fmt!("%d %u", x, y))
[22:42:42] -rusti- 6848273936270771821 2381675197114784224
[22:42:42] -rusti- ()
[22:42:42] <xenocons> a + b if no polymorphism should infer int -> int -> int unless annotated
[22:42:48] <Eridius> there, x is int, y is uint
[22:43:42] <Earnestly> strcat: So if you don't tell the function what to return, it inferres it based on the function's argument list?
[22:43:44] <cmr> xenocons: why?
[22:43:57] <strcat> Earnestly: that's not really what happens
[22:44:03] <cmr> xenocons: that's very nonobvious and confusing
[22:44:31] <strcat> Earnestly: if there is some variable 'x', the type can just be determined by it being used *as a specific type*
[22:44:38] <xenocons> cmr: either that or error out saying not enough information, please provide annotation, which would make sense for rust i guess
[22:44:42] <strcat> Earnestly: it won't "guess", if it's not used as a specific type it won't infer
[22:44:54] <Earnestly> Ah
[22:45:03] <strcat> rusti: let mut xs = ~[]; xs.push(5); xs
[22:45:04] -rusti- ~[5]
[22:45:07] <strcat> infers the type
[22:45:09] <strcat> rusti: let mut xs = ~[];
[22:45:10] -rusti- <anon>:9:23: 9:31 error: cannot determine a type for this local variable: unconstrained type
[22:45:10] -rusti- <anon>:9     let r = {  let mut xs = ~[];
[22:45:10] -rusti-                                 ^~~~~~~~
[22:45:10] -rusti- error: aborting due to previous error
[22:45:10] -rusti- application terminated with error code 101
[22:45:12] <strcat> can't infer the type
[22:45:17] <strcat> rusti: let mut xs: ~[int] = ~[];
[22:45:18] -rusti- <anon>:9:23: 9:25 warning: variable does not need to be mutable [-W unused-mut (default)]
[22:45:18] -rusti- <anon>:9     let r = {  let mut xs: ~[int] = ~[];
[22:45:18] -rusti-                                 ^~
[22:45:19] -rusti- ()
[22:45:26] <Earnestly> Yeah, thanks for explaining that. Good news
[22:45:44] <cmr> https://github.com/mozilla/rust/blob/master/src/librustc/middle/typeck/infer/mod.rs#L11
[22:45:50] <cmr> HM is https://en.wikipedia.org/wiki/Hindley%E2%80%93Milner
[22:46:18] <xenocons> pretty big
[22:46:58] *** Joins: carllerche (carllerche@moz-BF6CB667.hsd1.ca.comcast.net)
[22:47:45] <strcat> Earnestly: so anyway most code doesn't explicitly state types of local variables, it just infers them
[22:47:59] <strcat> the only time you really end up needing to explicitly add it is when using a generic conversion function
[22:48:00] <xenocons> cmr: what is the 'known scenario' where subtype heurestic fails?
[22:48:05] <xenocons> how interesting
[22:48:27] <cmr> xenocons: beats me, ask someone who knows about these things, I just know what file it happens in :p
[22:49:49] <xenocons> oh 
[22:50:24] <bblum> delicious soundness holes
[22:51:03] <xenocons> i like the idea of '+' being a function for some reason
[22:51:40] <strcat> Add::add, when method reform is done
[22:52:34] <Earnestly> strcat: How does type coercion work in rust?
[22:53:00] <strcat> conversion functions/methods generally
[22:53:29] <strcat> except for 'as' that's included because conversions need to be possible in constant expressions
[22:54:04] <kimundi> and coercion to borrowed ptrs in function calls
[22:54:20] <strcat> kimundi: all other uses of 'as' could be functions/methods though
[22:54:26] <strcat> it only has to exist in the language for constants
[22:54:38] <strcat> since we don't have constexpr
[22:58:03] *** Quits: MaikKlein (maik@moz-36D8270A.dip0.t-ipconnect.de) (Ping timeout)
[22:59:08] <xenocons> need to try out my darpa inference checking kludge scanner in rust (* inference jokes *)
[23:00:14] *** Quits: Jesin (Jessin_@moz-157A63DD.cc.lehigh.edu) (Ping timeout)
[23:01:57] *** cscott is now known as cscottnet_away
[23:03:33] *** Quits: jensnockert (jensnocker@moz-C5F27039.cust.bredband2.com) (Input/output error)
[23:03:43] * bblum fistpump
[23:03:55] *** Joins: jensnockert (jensnocker@moz-8BE55278.customer.t3.se)
[23:03:55] *** Quits: Amanieu (amanieu@moz-D5D10CA8.halls.manchester.ac.uk) (Connection reset by peer)
[23:03:57] <bblum> got a segfaulting program
[23:04:12] *** Joins: Amanieu (amanieu@moz-D5D10CA8.halls.manchester.ac.uk)
[23:04:54] <xenocons> nice, program that isnt using unsafe {} im guessing?
[23:04:58] <bblum> naturally
[23:05:01] <xenocons> nice work
[23:05:08] <xenocons> theyre the bugs to find!
[23:05:16] <bblum> of course, this is exploiting a bug that i am about to fix anyway
[23:05:29] <xenocons> anything interesting?
[23:05:36] <bblum> but this just lets me file an "A-typesystem I-crash" bug :)
[23:05:50] <xenocons> cool
[23:06:01] <xenocons> subtyping? :P
[23:06:16] <bblum> you can capture borrowed pointers when casting to a @Trait, and forget the lifetime
[23:06:32] *** Quits: krebbit (Mibbit@moz-4E627A8B.range86-149.btcentralplus.com) (Quit: http://www.mibbit.com ajax IRC Client)
[23:06:43] <xenocons> oo ok that is quite interesting
[23:06:56] *** Quits: johns (johns@2557E599.66715431.D25A875A.IP) (Connection reset by peer)
[23:07:04] *** Joins: jensnock_ (jensnocker@moz-C5F27039.cust.bredband2.com)
[23:07:08] <xenocons> does the memory get reused unsafely, causing the segfault?
[23:07:22] *** Joins: johns (johns@2557E599.66715431.D25A875A.IP)
[23:07:23] <bblum> in my particular exploit program, yes
[23:07:34] <bblum> presently trying to escalate it into coerce A -> B
[23:07:52] <xenocons> bblum: blog post blog post blog post
[23:08:20] <bblum> maybe, c.c
[23:08:28] *** Quits: jensnockert (jensnocker@moz-8BE55278.customer.t3.se) (Ping timeout)
[23:08:50] <xenocons> bblum: disperse thy knowledge
[23:09:36] <xenocons> til there is a keyword in C called 'restrict' :|
[23:09:43] *** Joins: sw17ch (sw17ch@moz-675AFBCF.hsd1.mi.comcast.net)
[23:10:25] <xenocons> http://blog.frama-c.com/index.php?post/2012/07/25/On-the-redundancy-of-C99-s-restrict not entirely relevant to rust, but imo the frama-c stuff is a must read for anyone interested in language safety
[23:10:26] <joelteon> today?
[23:10:42] <xenocons> joelteon: yeh, i come from MSVC for my C stuff, not c99
[23:10:52] <joelteon> oh
[23:10:57] <xenocons> saw it in the 'dark corners of C' proggit post
[23:11:42] <strcat> xenocons: that blog post is wrong because that's not what restrict does
[23:11:54] <strcat> it's not about value equality of pointers
[23:12:02] <xenocons> it isnt? hm
[23:12:53] *** Joins: brendan (brendaneic@moz-EBA77DDE.sub-70-197-10.myvzw.com)
[23:13:02] * xenocons washes eyes and waits for strcat's explanation
[23:13:41] <strcat> xenocons: it's 2 whole pages in the C standard
[23:14:05] <xenocons> ah, alright
[23:14:27] <strcat> xenocons: if neither pointer is used to mutate the memory, they are allowed to be 'restrict' and point to the same memory
[23:14:40] <xenocons> it even has a wiki
[23:14:50] *** Quits: brendan (brendaneic@moz-EBA77DDE.sub-70-197-10.myvzw.com) (Quit: brendan)
[23:15:01] <xenocons> strcat: right hm that makes sense
[23:15:21] <strcat> xenocons: http://i.imgur.com/3ESr5yM.png first part
[23:16:05] <strcat> http://i.imgur.com/JQXdEf3.png and more
[23:16:29] <xenocons> strcat: ty, i dont ever imagine ill get to use c99, but still interested 
[23:16:32] <xenocons> will read
[23:16:44] <strcat> xenocons: this is from the c11 standard but it's the same
[23:16:48] *** Quits: Scriptor (historium@moz-E06F46F0.corp.bitshelter.com) (Quit: Scriptor)
[23:16:49] <strcat> and finally, http://i.imgur.com/zZoRknb.png
[23:17:06] <xenocons> ok ill start with1 
[23:17:22] *** Quits: seth (seth@2557E599.66715431.D25A875A.IP) (Ping timeout)
[23:17:57] *** Joins: seth (seth@2557E599.66715431.D25A875A.IP)
[23:20:20] *** Quits: mschifer1 (Adium@2557E599.66715431.D25A875A.IP) (Quit: Leaving.)
[23:20:23] *** Joins: mschifer (Adium@2557E599.66715431.D25A875A.IP)
[23:20:47] *** aatch|gone is now known as aatch
[23:21:08] <strcat> (the noalias attribute in LLVM is defined in a similar way - clang compiles 'restrict' to it)
[23:22:00] <xenocons> strcat: that last page (example 11) is interesting, does the compiler not warn if you use a restricted pointer in a memory-mutable manner (i suppose it can't really know until runtime...)
[23:22:16] <strcat> it can't know if it's correct
[23:22:25] <strcat> it could have heuristics to warn for a limited set of cases
[23:22:29] <strcat> but gcc/clang don't warn
[23:22:31] <cmr> xenocons: that's the programmer's job
[23:22:48] <cmr> as with most everything in C
[23:22:51] <strcat> have to know what you're doing to write C ;p
[23:22:53] <xenocons> this is where i have a seperation of ideaology between C programmers
[23:22:59] <strcat> some pointer casts are illegal
[23:23:03] <strcat> some pointer casts are legal
[23:23:05] <strcat> etc.
[23:23:06] <xenocons> yeah
[23:23:12] *** Quits: johns (johns@2557E599.66715431.D25A875A.IP) (Input/output error)
[23:23:19] *** Quits: snearch (snearch@moz-94670B58.pool.mediaways.net) (Quit: Verlassend)
[23:23:21] *** Joins: johns (johns@2557E599.66715431.D25A875A.IP)
[23:23:35] <xenocons> strcat: i can still bruteforce C solutions with a minimal understanding of memory internals ;)
[23:23:49] <strcat> xenocons: but they likely aren't valid C
[23:23:52] <strcat> they just appear to work
[23:23:53] <cmr> they probably suck (no offense)
[23:24:04] <joelteon> none taken, c sucks
[23:24:23] <xenocons> cmr: none taken, i never use any library functions, as they make me fear my existence
[23:24:23] <strcat> it doesn't actually matter what the hardware does
[23:24:35] <SiegeLord> cmr: About your proposal... it really should say what the current rustdoc does that's different... and also, I think you reversed frontend/backend
[23:24:37] <strcat> pointers are unsigned, but integer overflow for pointers is undef behaviour
[23:24:52] <strcat> and by undef behaviour, that means the compiler can just assume it never happens
[23:24:58] <strcat> so it can remove bounds checks you expect to be there
[23:25:00] <xenocons> strcat: right
[23:25:08] <strcat> if you write
[23:25:11] <joelteon> whenever undefined behavior occurs anywhere, it makes the entire program undefined behavior
[23:25:19] <joelteon> so the compiler is free to no-op
[23:25:19] <cmr> SiegeLord: How have I reversed them? The backend does all the parsing of the rust code, the frontend does the formatting into output format
[23:25:23] <strcat> joelteon: that's not usually how it happens though
[23:25:31] <strcat> joelteon: usually the compiler sees that undef behaviour *could* happen
[23:25:34] <strcat> it might not
[23:25:34] <joelteon> strcat: don't you ever go into ##c?
[23:25:38] <SiegeLord> cmr, I'd say the opposite
[23:25:39] <strcat> it doesn't know what actually happens at runtime
[23:25:40] <xenocons> joelteon: lol
[23:26:02] <strcat> so it optimizes with the assumption that certain cases never happen
[23:26:03] <SiegeLord> Frontend does the parsing, and backend does the outputting
[23:26:13] <xenocons> i still use C as much as i dislike it, nothing comes close to its single loop speed
[23:26:28] <xenocons> all falls to shit when you want to do things in parallel though
[23:26:34] <strcat> xenocons: that's not true
[23:26:38] <strcat> fortran optimizes better than C
[23:26:40] <cmr> SiegeLord: *shrug*, maybe backend/frontend aren't correct terms. I originally used core and formatter
[23:26:45] <strcat> intel's fortran compiler is better than icc/clang/gcc
[23:27:16] <xenocons> strcat: sure, but i wouldnt use fortran to interop with winapi, so while its a super fast language (driven by necessity), it is also a bit inaccessible?
[23:27:33] *** Joins: brendan (brendaneic@moz-EBA77DDE.sub-70-197-10.myvzw.com)
[23:27:36] <xenocons> but if i was writing time critical finance number crunching, fortran would probably be a good choice
[23:27:49] *** Quits: brendan (brendaneic@moz-EBA77DDE.sub-70-197-10.myvzw.com) (Quit: brendan)
[23:28:17] <aatch> Auto is almost green again!
[23:28:37] <xenocons> quickly, make a #rust-offtopic so we can broadly discuss stuff :P
[23:28:55] * xenocons now is curious about c89 vs c99 
[23:29:02] <strcat> lots of people assume 'undef behaviour' is limited to things that are actually invalid in implementation terms
[23:29:07] <strcat> when really a lot of it is arbitrary
[23:29:12] <cmr> aatch: were you the one who wrote the dep graph thingy?
[23:29:23] <strcat> like signed int overflow being undef
[23:29:27] <aatch> cmr, dep graph thingy?
[23:29:31] <bblum> xenocons: https://github.com/mozilla/rust/issues/7247
[23:29:34] <xenocons> strcat: undef = unknown, imo, unknown isnt definetly broken, only potentially 
[23:29:40] <strcat> xenocons: no, that's not what it means
[23:29:44] <cmr> aatch: someone wrote a something that got a dependency graph from a rust crate
[23:29:47] <strcat> xenocons: signed int overflow is undefined
[23:29:59] *** Quits: jesseray (Mibbit@moz-B0004241.dynamic.ip.windstream.net) (Quit: http://www.mibbit.com ajax IRC Client)
[23:30:02] <strcat> xenocons: that doesn't mean if you have a signed int overflow that could happen, that it's just undefined what the result will be
[23:30:07] <bblum> my favourite part of that exploit program is the #[inline(always)]
[23:30:12] <strcat> it means the compiler can assume signed int overflow never, ever happens
[23:30:14] <xenocons> right
[23:30:21] <aatch> cmr, I started on one, didn't get very far though.
[23:30:21] <xenocons> i get that i think
[23:30:24] <xenocons> bblum: looking, 1 tic
[23:30:38] <strcat> xenocons: if it sees
[23:30:57] <strcat> int foo(int x) { INT_MAX + x; return x; }
[23:31:01] <cmr> aatch: what was involved with it and why did you need it? I'm wondering if I can fold it into the new rustdoc https://github.com/mozilla/rust/wiki/Bikeshed-rustdoc
[23:31:02] <strcat> it is allowed to assume x is always 0
[23:31:05] <strcat> *always*
[23:31:11] <strcat> it can just compile that to a function returning 0
[23:31:20] <joelteon> returning INT_MAX, surely
[23:31:23] <joelteon> oh
[23:31:25] <joelteon> nvm
[23:31:28] <xenocons> bblum: heh, thats nice
[23:31:43] <xenocons> how did you find this? fuzzing or accident?
[23:31:49] <bblum> xenocons: purpose
[23:31:52] <xenocons> nice one
[23:31:58] <xenocons> reasonably tricky
[23:32:02] *** Quits: snadon (chatzilla@moz-3BC727E8.mc.videotron.ca) (Ping timeout)
[23:32:06] <bblum> not tricky to get a segfault with the bug
[23:32:11] <bblum> tricky to get coerce with
[23:32:11] <xenocons> heh
[23:32:20] <aatch> cmr, I was investigating what would be needed to allow for re-use of compilation work.
[23:32:20] <bblum> i am working on fixing the bug i refer to in the description
[23:32:25] <bblum> and i was like "hm, what if"
[23:32:30] <xenocons> this pointer coercion will be a big thing to look at
[23:32:36] <aatch> Basically, caching.
[23:32:46] <xenocons> strcat: yeah, so the compiler knows about the overflow right?
[23:32:48] <cmr> aatch: caching of what? ast? partially compiled IR?
[23:32:55] <strcat> xenocons: no
[23:33:06] <strcat> xenocons: well if x is not 0, that would overflow
[23:33:11] <strcat> so the compiler is allowed to assume x is 0
[23:33:46] <aatch> cmr, anything, though my initial aim was to try and cache optimized IR fragments.
[23:33:52] <xenocons> it should be -(2^32-1) though right
[23:33:57] *** Quits: seth (seth@2557E599.66715431.D25A875A.IP) (Ping timeout)
[23:33:58] <aatch> cmr, anyway, I just used the AST visitor in libsyntax.
[23:34:05] <strcat> xenocons: no
[23:34:08] <strcat> xenocons: it's undefined
[23:34:13] <xenocons> hm
[23:34:24] <joelteon> it could return 15
[23:34:28] <joelteon> it could erase your hard drive
[23:34:28] <xenocons> implementation specific 
[23:34:30] *** Joins: steven_is_false (user@moz-144077DE.bchsia.telus.net)
[23:34:31] <strcat> xenocons: the result of signed int overflow is undefined
[23:34:32] <joelteon> it's undefined behavior
[23:34:37] <strcat> xenocons: no, not implementation specific
[23:34:39] <strcat> xenocons: I don't think you get it ;p
[23:34:42] <aatch> Turns out there's actually quite a lot of useful code in libsyntax that can be used without too much work.
[23:34:52] <strcat> bool foo(int x) { (INT_MAX - 5) + x; return x < 6; }
[23:34:58] <strcat> the compiler can compile that to
[23:35:11] <strcat> bool foo(int x) { return true; }
[23:35:21] <strcat> if you do foo(15) it can return true
[23:35:31] <aatch> For one, it's pretty easy to construct a parser, read a file and then get an AST out of it.
[23:35:34] <strcat> why? because 15 would cause signed int overflow
[23:35:34] <xenocons> well, couldn't your int32 represent something different depending on the architecture?
[23:35:54] <strcat> xenocons: that's not relevant
[23:36:00] <strcat> it doesn't matter what the hardware does
[23:36:09] <strcat> it's not undefined because hardware implements it differently
[23:36:10] *** Quits: BitPuffin (quassel@moz-26C91AC6.cust.tele2.se) (Connection reset by peer)
[23:36:17] <strcat> and that's not what undefined behaviour means
[23:36:27] <xenocons> strcat: ahh, hmm
[23:36:33] <strcat> bool foo(int x) { (INT_MAX - 5) + x; return x < 6; }
[23:36:34] <strcat> xenocons: so you see
[23:36:40] <strcat> (INT_MAX - 5) + x
[23:36:44] <xenocons> yes
[23:36:47] <strcat> if x is greater than 5, that overflows
[23:36:51] <strcat> that's undef behaviour
[23:36:57] <strcat> the compiler can now assume x is *never* greater than 5
[23:37:04] <xenocons> #define INT_MAX 1
[23:37:09] <strcat> because undef behaviour doesn't happen in a valid C program, ever
[23:37:26] *** Quits: mschifer (Adium@2557E599.66715431.D25A875A.IP) (Quit: Leaving.)
[23:37:44] <xenocons> right, the problem is invalid C program != non compiling C program :)
[23:37:44] *** Joins: BitPuffin (quassel@moz-5C0452AB.cust.tele2.se)
[23:38:04] *** Quits: doomlord (doomlod@moz-6651F8D4.range86-145.btcentralplus.com) (Ping timeout)
[23:38:12] <strcat> xenocons: and invalid C program != C program that does something invalid in terms of hardware/memory
[23:38:12] <xenocons> would it be wrong to assume the majority of C programs running out there are not valid C programs? 
[23:38:22] <strcat> xenocons: it's reasonable to assume that
[23:38:37] <strcat> bugs are found in pretty much all major software all the time that involve them not being valid C/C++
[23:38:49] <strcat> zlib broke with gcc 4.8
[23:38:55] <xenocons> strcat: one could infer from this (bit rougher) that writing invalid C is still a valid aproach to programming ;)
[23:39:04] <strcat> because gcc 4.8 got smarter, and took advantage of potentially undef behaviour in zlib that *did* actually happen
[23:39:09] <xenocons> ah nice
[23:39:49] <strcat> xenocons: http://blog.regehr.org/archives/918
[23:39:54] <xenocons> strcat: people can use stuff like integer overflows for integer optimizations too i guess
[23:40:01] <strcat> xenocons: no, you can't
[23:40:23] *** Joins: brendan (brendaneic@moz-EBA77DDE.sub-70-197-10.myvzw.com)
[23:40:24] <strcat> xenocons: the important thing to understand is that signed int overflow is totally fine to use outside of C
[23:40:36] <strcat> it might not be portable between platforms, but the only difference will be the result
[23:40:40] <xenocons> what types for integers result in undefined behaviour, is it only int32s or * int types
[23:40:47] <xenocons> right
[23:40:49] <strcat> xenocons: signed ints
[23:40:53] <xenocons> strcat: i think that makes sense
[23:40:59] <strcat> signed char, short, int, long, long long
[23:41:03] <strcat> bool and char can be signed
[23:41:13] <xenocons> as bool is just int anyway
[23:41:19] <strcat> xenocons: no, it's _Bool
[23:41:26] <xenocons> didn't know it cared about signedness though
[23:41:31] <xenocons> _Bool?
[23:41:33] <strcat> yes
[23:41:39] <strcat> storing a value other than 0 or 1 in _Bool is undef behaviour
[23:41:50] <strcat> they just typedef bool to _Bool in stdbool.h
[23:41:54] *** Joins: ssbr (ssbr@868FD9A8.646EADF6.99A1C83D.IP)
[23:41:55] *** Joins: seth (seth@2557E599.66715431.D25A875A.IP)
[23:42:02] <strcat> the stdint.h things are just typedefs to primitive types
[23:42:26] <xenocons> i just #define TRUE 1 #define FALSE 0, is this signed or unsigned 
[23:42:35] <xenocons> (depends on the compiler doesn't it?)
[23:42:39] <strcat> signed, it's an int
[23:42:43] <strcat> xenocons: no
[23:42:45] <strcat> int literal
[23:42:52] *** Quits: erickt (erickt@8C9ECD8F.3A598286.F12515B4.IP) (Quit: Leaving.)
[23:42:53] <strcat> 'c' is an int literal too, not a char literal
[23:42:59] <strcat> in C++ 'c' is a char literal
[23:43:23] <xenocons> right, it makes sense to treat everything as an int in C
[23:43:33] <strcat> it doesn't really
[23:43:34] <xenocons> haven't ever thought about signedness issues though
[23:43:36] *** Joins: erickt (erickt@8C9ECD8F.3A598286.F12515B4.IP)
[23:43:36] *** Quits: erickt (erickt@8C9ECD8F.3A598286.F12515B4.IP) (Quit: erickt)
[23:43:40] <xenocons> why not?
[23:43:41] <strcat> unsigned integer overflow is defined in C as wrapping
[23:43:48] <strcat> and int is only guaranteed to be 16 bits...
[23:43:58] <xenocons> hm
[23:44:29] *** Quits: seth (seth@2557E599.66715431.D25A875A.IP) (Ping timeout)
[23:44:31] <strcat> the new standards add more fun
[23:44:46] <strcat> for (;;) { } int *p = NULL; *p
[23:44:47] <cmr> "Fun"
[23:44:50] <strcat> defined behaviour in C++03
[23:44:53] *** Quits: steven_is_false (user@moz-144077DE.bchsia.telus.net) (Client exited)
[23:44:54] <strcat> undefined behaviour in C++11
[23:44:56] <xenocons> heh yeah was about to quotation mark it also
[23:45:16] <xenocons> strcat: that doesnt dereference a null ptr?
[23:45:16] <strcat> C++11 allows optimizing out infinite loops, C11 might too
[23:45:25] <strcat> xenocons: they allowed optimizing out no-op infinite loops
[23:45:30] <Earnestly> xenocons: signage for char is also implementation specific fwiw
[23:45:46] <strcat> also
[23:45:48] <xenocons> interesting to both
[23:45:57] <xenocons> ive always loathed the for (;;) syntax
[23:46:02] <Earnestly> (C98, C99 and C11)
[23:46:08] <strcat> xenocons: well then
[23:46:25] <xenocons> tbh i also hate while loops
[23:46:35] <strcat> xenocons: any loop they can prove to be a no-op, they can optimize out
[23:46:41] <xenocons> especially while (*p++ = *d++) and co
[23:47:02] <strcat> if the loop writes stuff to an array in an infinite loop (wrapping around) and they determine nothing reads the array, goodbye loop
[23:47:12] <xenocons> strcat: right, i suppose that is good and bad, good because it can optimize stuff, bad because if osmeone tries to compile under c++11 they are going to have a bad day
[23:47:29] <xenocons> someone*
[23:47:41] <strcat> or just if they update their compiler and the undef behaviour they were relying on is implemented differently
[23:48:01] <strcat> as in the compiler learns to see cases that could result in undef behaviour and optimize them out
[23:48:19] <xenocons> or was it while (++p* = *d++) i forget
[23:48:39] <xenocons> all it takes for me is to read the underhanded c competition entries to get really fearful of C again
[23:48:54] <strcat> undef behaviour should make you more scared of C than anything else
[23:48:57] *** Quits: lkuper_ (lkuper@moz-C0CD33ED.hsd1.in.comcast.net) (Ping timeout)
[23:48:57] <xenocons> everytime i write something in C i think 'ok its a broken program, but it works'
[23:49:07] <strcat> the fact that it has no basis in hardware at all
[23:49:16] *** Quits: q66 (q66@6EE9DE40.46454B5D.33AABD5F.IP) (Client exited)
[23:49:19] <strcat> it's an imaginary world and if you break the imaginary C rules, the compiler can do whatever it wnats
[23:49:21] <strcat> wants*
[23:49:27] <xenocons> hah
[23:49:30] <xenocons> yeah i think i see that
[23:49:35] <roo> doesn't seem much like optimization to me
[23:49:43] <strcat> roo: the infinite loop thing?
[23:49:48] <roo> yeah
[23:49:49] <strcat> it's because they can often prove a loop doesn't do anything
[23:49:52] <strcat> post-optimization
[23:49:56] <strcat> but they have trouble proving it halts
[23:50:05] <strcat> so the standard committee made their life easier
[23:50:13] *** Joins: dbaupp (Thunderbir@moz-73E90475.lns20.syd6.internode.on.net)
[23:50:16] <strcat> generally it means
[23:50:22] <strcat> they can remove *any* loop that may or may not terminate
[23:50:28] <strcat> if they can prove it doesn't do anything
[23:50:31] *** Quits: bjz (brendanzab@B398BE78.F804C29E.D35A31DF.IP) (Ping timeout)
[23:50:37] * Amanieu compiles his C code with -Wall -Wextra -pedantic
[23:50:45] <Ralith> Amanieu: what, no -Werror?
[23:50:48] <xenocons> is converstion from signed type to unsigned type undefined too?
[23:50:51] <strcat> Amanieu: that's not actually a lot of warnings, and doesn't catch very much undef behaviour
[23:51:04] <aatch> -Warn-me-harder
[23:51:05] <strcat> most has to be caught at runtime
[23:51:11] <roo> lol
[23:51:21] <Ralith> also, -fsanitize=address
[23:51:23] <strcat> and ofc you can't possibly run all variations of input
[23:51:24] <Amanieu> Ralith: I prefer cleaning up warnings myself. I do get rid of all of them though
[23:51:35] <strcat> Ralith: they have a dozen fsanitize values now ;p
[23:51:37] <strcat> at least
[23:51:38] <xenocons> -fno-mudflaps
[23:51:49] <Ralith> strcat: indeed
[23:51:49] <strcat> -fsanitize=bool, for example
[23:51:57] <aatch> Which I initially read as 'Warn arn-me-harder'
[23:51:58] <strcat> checks that bools are only set to 0 and 1 ;p
[23:52:10] <Ralith> there's a nice one for signed integer overflow too iirc
[23:52:14] <xenocons> oh its -fmudflap
[23:52:18] <strcat> Ralith: -ftrapv
[23:52:22] <strcat> Ralith: it's broken in gcc though
[23:52:33] <xenocons> http://gcc.gnu.org/wiki/Mudflap_Pointer_Debugging i guess gcc is kinda cool hehe
[23:52:34] <Ralith> who cares about gcc anymore anyway
[23:52:35] <strcat> xenocons: mudflap is essentially deprecated though
[23:52:37] <strcat> and doesn't work for C++
[23:52:37] *** Quits: eholk (eholk@BAD3967A.BEBDB225.ABD5273E.IP) (Quit: eholk)
[23:52:49] <strcat> google ported asan/tsan/msan to gcc 4.8
[23:52:54] <xenocons> oh 
[23:52:59] <Earnestly> strcat: What's interesting though is that so far there are no languges being developed which are as flexable and as fast as C and C++. Reckon that's just due to maturity rather than technical basis?
[23:53:06] <Earnestly> s/languages
[23:53:10] <strcat> Earnestly: there are faster languages
[23:53:18] <xenocons> depends how you compare fast
[23:53:29] <Earnestly> strcat: (not including asm, do you have examples?)
[23:53:33] <strcat> C isn't a particularly well designed language for speed, thus all the undef behaviour hacks to let compilers optimize
[23:53:43] *** Joins: seth (seth@2557E599.66715431.D25A875A.IP)
[23:53:47] <xenocons> fast these days seems to be mor eand more so to do with how much parallel operations you can squeeze in
[23:53:49] <Earnestly> That's what I was refering to by maturity
[23:53:50] <strcat> Earnestly: ada, pascal, fortran? there are older languages than C that can optimize better and are higher level
[23:54:09] <xenocons> ocaml is pretty damn fast
[23:54:22] <xenocons> probably not ada speed though
[23:54:24] <Earnestly> strcat: pascal is faster than C? Aside from that, what is being developed now that is?
[23:54:35] <Earnestly> (go doesn't compare and it's math lib is written in asm)
[23:54:37] <strcat> Earnestly: fortran, ada
[23:54:42] <strcat> both are still developed
[23:54:46] <strcat> both are more modern than C
[23:55:00] <strcat> (now)
[23:55:02] <Earnestly> strcat: Modern in what way?
[23:55:04] *** Quits: ssbr (ssbr@868FD9A8.646EADF6.99A1C83D.IP) (Ping timeout)
[23:55:09] <xenocons> constraints
[23:55:13] <xenocons> type systems
[23:55:19] <xenocons> verification that is provable
[23:55:42] <Earnestly> xenocons: C has a simple type system fwiw
[23:55:54] <xenocons> although i hear from a C advocate buddy that JPL C is pretty good
[23:55:55] <aatch> Isn't AST often faster than C
[23:55:59] <jensnock_> Does C even have a type system?
[23:56:07] <Earnestly> :|
[23:56:12] <xenocons> jensnock_: not in the way i think of type systems
[23:56:12] <aatch> Earnestly, that's kind of the problem.
[23:56:21] <aatch> jensnock_, it has types, therefore a type system.
[23:56:37] <xenocons> aatch: ok so we are defining what a type system is now ;p
[23:56:47] <xenocons> ill step out of this one because im biased towards high level langs
[23:56:48] <aatch> Well a type system is a system for types.
[23:56:50] <strcat> Earnestly: intel's fortran compiler is consistently faster than icc/clang/gcc/msvc
[23:57:01] *** Quits: devbug (quassel@moz-E1DE087C.bchsia.telus.net) (Quit: http://quassel-irc.org - Chat comfortably. Anywhere.)
[23:57:04] *** Joins: devbug (quassel@moz-E1DE087C.bchsia.telus.net)
[23:57:09] <strcat> Earnestly: because the language maps to optimization techniques better, thanks to better aliasing guarantees for one thing
[23:57:13] <Earnestly> strcat: I'm not surprised frtran is faster, pascal though? No clue about ada
[23:57:25] <jensnock_> strcat: Where 'faster' means 'faster in code that is essentially linear algebra'
[23:57:25] *** Quits: sw17ch (sw17ch@moz-675AFBCF.hsd1.mi.comcast.net) (Quit: sw17ch)
[23:57:35] <strcat> jensnock_: no, faster in code that does anything with pointers
[23:57:38] <xenocons> strcat: guessing intel fortrans compiler can optimize relaly well for intel stuff
[23:57:45] <strcat> so, all useful code
[23:57:51] <Earnestly> strcat: But, is the trend of safer languages we see today at the cost of speed or is that merely compiler (im)maturity?
[23:57:52] <strcat> xenocons: well icc is intel too
[23:58:00] <strcat> xenocons: not like they wrote another optimization backend for fortran
[23:58:05] <aatch> The complexity of that system has no bearing on whether it's a system.
[23:58:12] <xenocons> strcat: for numerical analysis are people using intel hardware or sparc though?
[23:58:14] <strcat> Earnestly: which language?
[23:58:31] *** Quits: brson (brson@2557E599.66715431.D25A875A.IP) (Ping timeout)
[23:58:31] <Earnestly> strcat: I was thinking of Go, Rust and D primarily
[23:58:31] <aatch> Earnestly, safer languages nowadays are more a result of mature theories and faster computers for static analysis
[23:58:47] <strcat> Earnestly: Go and D aren't really systems languages
[23:58:52] <Earnestly> aatch: Yes, I appricate that
[23:58:52] *** Quits: infynyxx (infynyxx@DB780A29.749BA1D.DCC373F0.IP) (Client exited)
[23:58:54] <strcat> they use global gc
[23:59:29] <strcat> and neither Go or D is memory safe
[23:59:58] <Eridius> strcat: what do you mean by "memory safe"?
[23:59:59] <graydon> hey now, that's not fair
[23:59:59] <strcat> so...

[00:05:42] *** Quits: Rym (y@moz-c2u.sd4.38.217.IP) (Ping timeout: 121 seconds)
[00:19:36] *** Quits: simukis (nagisa@moz-8t068g.static.zebra.lt) (Ping timeout: 121 seconds)
[00:23:16] *** Joins: Rym (y@moz-c2u.sd4.38.217.IP)
[00:44:11] <pnkfelix> my discovery for the evening: `let z = match x { Some(y) => y, None => panic!() };` for a non-copy type does not actually zero (i.e. drop-fill) `x`.  It drop-fills the *y* within it, but the discriminant, if stored outside the content, remains unchanged.
[00:45:10] <aatch> pnkfelix, is that a problem?
[00:46:34] <pnkfelix> aatch: I'm not sure yet. It is a problem for me right now, because I am trying to associate a stack-local drop-flag-like thing with `x`, but there's nowhere in trans today that actually attempts to zero `x`
[00:46:50] <pnkfelix> aatch: and so I need to figure out where in `trans::_match` such a thing should go
[00:47:34] <aatch> pnkfelix, bahaha! Good luck. I've spent ages staring at trans::_match and still don't realy understand whats going on.
[00:48:05] <pnkfelix> aatch: In terms of the language, I do not think it is a problem because there is no way to make a type that lets you move in match-arm *and* implement Drop at the same time.
[00:48:45] <pnkfelix> (i.e. there is no way to attach user-defined drop code to an attempt to drop `x`)
[00:49:31] <pnkfelix> ((at the end of the scope of `x`, that is.  instead we will always attempt to drop it, by inspecting its discriminant and then recursing the contents, at which point we discover that *they* have indeed been dropped...)
[01:42:00] *** Quits: c74d (c74d3a4ebb6@moz-0ersgu.oc.cox.net) (Ping timeout: 121 seconds)
[01:42:27] *** Joins: c74d (c74d3a4ebb6@moz-kfb9ol.mggc.hibn.4404.2002.IP)
[02:30:29] <nrc> I'm getting the following llvm/linking error:
[02:30:31] <nrc> Global is external, but doesn't have external or weak linkage!
[02:31:16] <nrc> What does "Global is external" mean? Is there some concept of external unrelated to linking? Why does llvm think a global is external?
[02:31:23] <nrc> In this case the global is a function, btw
[02:31:45] <nrc> Does llvm know about references TO the global from other modules?
[02:31:52] <nrc> (Not that I think there are any)
[02:32:03] <nrc> aatch, doener ^ please help?
[02:32:57] <aatch> nrc, oh, I've seen that before.
[02:33:20] <aatch> nrc, trying to remember where though.
[02:33:29] <nrc> the error is valid in some sense - the function is declared with internal linkage
[02:33:36] <nrc> but I'm not sure why that is a problem
[02:34:11] <aatch> nrc, is there a static variable or similar that references it?
[02:35:10] <nrc> there's only one other reference, from another function with internal linkage, but it is more complicated than this....
[02:35:24] <nrc> I only have ir from an adjusted version with no error
[02:35:30] <nrc> where it errors out I have no ir
[02:35:59] <nrc> but I see no reason why rustc would generate any reference to the function in another llvm module
[02:36:02] <nrc> EXCEPT
[02:36:20] <nrc> it might make another function with exactly the same name and the linker might try to merge the symbols?
[02:37:11] <aatch> nrc, oh, I remember the case I had before. It was a function that didn't have a body generated.
[02:37:17] <aatch> nrc, and it was actually a closure.
[02:37:31] <nrc> this is a closure too, but it does have a body
[02:37:49] <aatch> nrc, the closure in this case *should* have had a body, but didn't.
[02:39:15] <aatch> nrc, is it something like `|||| x`?
[02:39:29] <nrc> aatch: no
[02:39:30] <nrc> |s| s.len()
[02:39:51] <nrc> not a complex closure :-p
[02:40:50] <aatch> nrc, hmm, interesting.
[02:41:20] <nrc> its another || codegen bug, but different to the old one, I think
[02:41:35] <aatch> nrc, well I bet that if you patch the compiler to make it so closures aren't marked internal, you'll see that it doesn't have a body.
[02:42:11] <nrc> hmm, I'll try that
[02:56:43] *** Quits: zz_kimundi (kimundi@moz-0meql0.dip0.t-ipconnect.de) (Ping timeout: 121 seconds)
[02:58:02] *** Joins: zz_kimundi (kimundi@moz-siarqd.dip0.t-ipconnect.de)
[02:58:03] *** zz_kimundi is now known as kimundi
[03:02:37] <nrc> aatch: you're right! no body. So, theory, rustc thinks its already generated the closure so skips the body, but thanks to || codegen, it's in another module, so it looks like just a decl ... error
[03:04:38] <aatch> nrc, I got as far as "it has no body, that's why LLVM is complaining", couldn't figure out past that.
[03:07:37] <nrc> istm that in the || context we either should not be outputting these decls, or they must have available_externally linkage (or something like that)
[03:10:02] *** Quits: Rym (y@moz-c2u.sd4.38.217.IP) (Ping timeout: 121 seconds)
[03:17:00] <nrc> weird it should only be reusing fns from the local codegen unit, it should never share them
[03:37:13] *** Joins: Rym (y@moz-c2u.sd4.38.217.IP)
[03:41:29] *** Quits: Rym (y@moz-c2u.sd4.38.217.IP) (Ping timeout: 121 seconds)
[04:24:14] *** Joins: Rym (y@moz-c2u.sd4.38.217.IP)
[04:28:32] *** Quits: Rym (y@moz-c2u.sd4.38.217.IP) (Ping timeout: 121 seconds)
[04:57:58] *** Joins: c74d3 (c74d3a4ebb6@moz-0ersgu.oc.cox.net)
[04:59:26] *** Quits: c74d (c74d3a4ebb6@moz-kfb9ol.mggc.hibn.4404.2002.IP) (Ping timeout: 121 seconds)
[04:59:35] *** c74d3 is now known as c74d
[05:02:33] *** Quits: aatch (james@moz-8r6eer.orns.ubhm.e000.2406.IP) (Connection closed)
[05:18:24] *** Joins: Rym (y@moz-c2u.sd4.38.217.IP)
[05:22:40] *** Quits: Rym (y@moz-c2u.sd4.38.217.IP) (Ping timeout: 121 seconds)
[06:10:34] *** Quits: Tobba (Tobba@moz-o13d22.bredband.telia.com) (Ping timeout: 121 seconds)
[06:12:32] *** Joins: Rym (y@moz-c2u.sd4.38.217.IP)
[06:16:50] *** Quits: Rym (y@moz-c2u.sd4.38.217.IP) (Ping timeout: 121 seconds)
[06:30:43] *** Joins: laumann (thomas@moz-n9e72h.0.fullrate.dk)
[07:06:40] *** Joins: Rym (y@moz-c2u.sd4.38.217.IP)
[07:10:58] *** Quits: Rym (y@moz-c2u.sd4.38.217.IP) (Ping timeout: 121 seconds)
[08:00:50] *** Joins: Rym (y@moz-c2u.sd4.38.217.IP)
[08:05:06] *** Quits: Rym (y@moz-c2u.sd4.38.217.IP) (Ping timeout: 121 seconds)
[08:12:49] *** Quits: laumann (thomas@moz-n9e72h.0.fullrate.dk) (Ping timeout: 121 seconds)
[08:20:00] *** Joins: simukis (nagisa@moz-8t068g.static.zebra.lt)
[08:20:30] *** Joins: Tobba (Tobba@moz-6oh.7ki.21.217.IP)
[08:28:11] <doener> eddyb: I've been thinking about the nocapture attribute for function pointers that went missing. Wouldn't we be violating that here, by means of casting a borrowed pointer to a raw pointer and storing that? https://github.com/rust-lang/rust/blob/master/src/libcollections/vec.rs#L782
[08:34:18] <eddyb> nope
[08:34:26] <eddyb> doener: lifetime elision
[08:34:43] <eddyb>     pub fn drain<'a, R>(&'a mut self, range: R) -> Drain<'a, T>
[08:34:48] <doener> oh, right
[08:35:16] <doener> forgot that that applies to lifetimes in type parameters, too
[08:36:08] <doener> eddyb: but in general this would be UB, right?  fn foo(x: &i32) -> *const i32  { x as *const i32 }
[08:36:39] <eddyb> doener: that's the signature of as_ptr
[08:37:51] <doener> eddyb: which one? I could only find ones that only return a pointer that is a field on self
[08:37:58] <eddyb> the slices
[08:39:09] <doener> that takes a pointer to the slice and returns the data pointer, i.e. it returns a different pointer than its argument
[08:39:16] *** Joins: laumann (thomas@moz-vj4.hq0.225.130.IP)
[08:40:20] <eddyb> hmm
[08:40:41] <eddyb> doener: but that's an implementation detail/limitation
[08:40:53] <eddyb> if you could, you would put nocapture on the data pointer itself
[08:41:41] <doener> eddyb: that would definitely be UB then, wouldn't it?
[08:42:13] <eddyb> it would make some code UB, but it's the same rule that you use on references to sized types
[08:42:27] <eddyb> doener: maybe the uses of the parameter should be inspected
[08:46:07] <doener> eddyb: that's why I used a sized type in my example above ;-) Basically I'm wondering if we want to add that attribute back and declare the above to be UB in safe code, or only add it back with constraints like the usage analysis.
[08:46:57] <doener> eddyb: that would have to happen before we emit the metadata then, and we'd have to encode such function argument attributes in the metadata, right?
[08:47:28] <eddyb> riiight
[08:47:43] <eddyb> doener: can't LLVM deduce this information?
[08:47:56] <eddyb> oh
[08:48:04] <eddyb> doener: if LLVM produced `nounwind` after optimizations
[08:48:24] <eddyb> doener: and this is a function that doesn't get inlined. do we lose nounwind when calling from another crate, without LTO?
[08:48:50] <eddyb> maybe we should encode LLVM function attributes produced by optimizations, in metadata
[08:50:27] <doener> eddyb: I think we lose that, yes. Let me check
[08:54:58] *** Joins: Rym (y@moz-c2u.sd4.38.217.IP)
[08:55:20] <doener> eddyb: yes, deduced attributes are lost. I think that's correct at least for dynamic linking though, as implementation details like that might change.
[08:55:55] <doener> eddyb: Though I guess recompiling the lib would force a re-compile of the program that uses it anyway because of the way we generate names?
[08:56:52] <eddyb> yeah, dynamic linking in Rust is for code reuse, not binary patching
[08:57:08] <eddyb> I am happy Rust didn't follow the broken tradition
[08:59:15] *** Quits: Rym (y@moz-c2u.sd4.38.217.IP) (Ping timeout: 121 seconds)
[09:11:57] *** Quits: nrc (nrc@moz-14pjgj.xtra.co.nz) (Ping timeout: 121 seconds)
[09:14:26] <huon> what's broken about binary patching?
[09:23:39] <eddyb> huon: dylib patching only "works" if you have a strictly opaque API with no chance of inlining and no public type definitions
[09:23:47] <eddyb> it's fundamentally incompatible with generics
[09:24:28] <huon> it's a tradeoff
[09:24:48] <huon> sometimes performance/flexibility is extremely important
[09:24:58] <huon> other times being able to upgrade for problems might trump it
[09:25:06] <eddyb> yeah, well, try fixing a security vuln in the STL
[09:25:34] <huon> just because it doesn't apply to every library doesn't mean it is broken
[09:25:39] <eddyb> most distros out there, if not all of them, will fail to do so properly (without rebuilding everything)
[09:26:02] <huon> it's unlikely it'll apply to the rust std lib, but I can certainly imagine people writing libs that are designed for it
[09:26:22] <eddyb> huon: it's universally relied upon, even when it can't work
[09:27:01] <huon> do you really think the distros etc. are blind to this problem? :)
[09:27:52] <eddyb> I doubt that. but that doesn't fix much, does it now?
[09:28:53] <eddyb> only means someone will remember to rebuild all the packages in certain situations
[09:29:18] <eddyb> which is not what most build systems I've seen are designed for
[09:29:29] <eddyb> the throughput is just not there
[09:30:32] <eddyb> I'm not sure how well NixOS handles this, but it can't scale amazingly
[09:32:31] <eddyb> doing taint analysis on the source of values/instructions in LLVM IR could be fun
[09:45:34] *** kimundi is now known as zz_kimundi
[09:49:08] *** Joins: Rym (y@moz-c2u.sd4.38.217.IP)
[09:53:23] *** Quits: Rym (y@moz-c2u.sd4.38.217.IP) (Ping timeout: 121 seconds)
[09:58:10] *** Joins: nrc (nrc@moz-14pjgj.xtra.co.nz)
[09:58:10] *** ChanServ sets mode: +qo nrc nrc
[10:06:21] *** Joins: arielb1 (Mibbit@moz-cmi.jfj.114.192.IP)
[10:43:16] *** Joins: Rym (y@moz-c2u.sd4.38.217.IP)
[10:47:34] *** Quits: Rym (y@moz-c2u.sd4.38.217.IP) (Ping timeout: 121 seconds)
[11:04:20] *** Quits: arielb1 (Mibbit@moz-cmi.jfj.114.192.IP) (Quit: http://www.mibbit.com ajax IRC Client)
[11:09:33] *** Quits: nrc (nrc@moz-14pjgj.xtra.co.nz) (Ping timeout: 121 seconds)
[11:37:27] *** Joins: Rym (y@moz-c2u.sd4.38.217.IP)
[11:41:43] *** Quits: Rym (y@moz-c2u.sd4.38.217.IP) (Ping timeout: 121 seconds)
[11:57:11] *** zz_kimundi is now known as kimundi
[12:01:00] *** Quits: laumann (thomas@moz-vj4.hq0.225.130.IP) (Ping timeout: 121 seconds)
[12:03:03] *** Joins: laumann (thomas@moz-gqpfnm.science.ku.dk)
[12:18:04] *** Quits: Tobba (Tobba@moz-6oh.7ki.21.217.IP) (Ping timeout: 121 seconds)
[12:20:20] *** kimundi is now known as zz_kimundi
[12:31:37] *** Joins: Rym (y@moz-c2u.sd4.38.217.IP)
[12:35:51] *** Quits: Rym (y@moz-c2u.sd4.38.217.IP) (Ping timeout: 121 seconds)
[12:52:53] <eddyb> nmatsakis: are you working on anything related to associated items? I kinda want to replace the name with an ID. it would make implementing ARTs easier
[13:18:44] *** Joins: Rym (y@moz-c2u.sd4.38.217.IP)
[13:23:06] *** Quits: Rym (y@moz-c2u.sd4.38.217.IP) (Connection closed)
[13:23:20] *** Joins: Rym (y@moz-c2u.sd4.38.217.IP)
[13:26:40] *** Joins: Tobba (Tobba@moz-o13d22.bredband.telia.com)
[14:33:19] *** zz_kimundi is now known as kimundi
[14:58:15] *** Quits: simukis (nagisa@moz-8t068g.static.zebra.lt) (Quit: Leaving.)
[14:58:49] *** Joins: simukis (nagisa@moz-8t068g.static.zebra.lt)
[15:25:26] *** Quits: Rym (y@moz-c2u.sd4.38.217.IP) (Ping timeout: 121 seconds)
[15:44:50] *** Joins: Rym (y@moz-c2u.sd4.38.217.IP)
[15:47:09] *** Quits: laumann (thomas@moz-gqpfnm.science.ku.dk) (Ping timeout: 121 seconds)
[15:49:11] *** Joins: laumann (thomas@moz-vj4.hq0.225.130.IP)
[15:50:44] <nmatsakis> eddyb: I don't have any patches in flight atm, I've been writing up a proposed revision to how normalization; replacing name with ID seems like a good thing, rather orthogonal to the stuff I was thinking about
[16:19:05] *** Joins: arielb1 (Ariel@moz-9he9ta.red.bezeqint.net)
[16:23:11] *** Joins: brson (brson@moz-48fqub.res.rr.com)
[16:23:11] *** ChanServ sets mode: +qo brson brson
[16:39:26] <doener> arielb1: the example in gh25826 took me a minute to understand what that was even doing
[16:39:48] <arielb1> doener: this is a bug in const_expr
[16:39:54] <arielb1> I am going to write a fix
[16:40:04] <arielb1> I mean, in check_const
[16:40:09] <doener> arielb1: totally forgot that some is also a function
[16:40:13] <doener> *Some
[16:40:50] <arielb1> doener: fixed
[16:40:53] <doener> nice
[16:40:57] <doener> that was quick :-)
[16:54:30] *** Quits: Rym (y@moz-c2u.sd4.38.217.IP) (Ping timeout: 121 seconds)
[17:28:10] <eddyb> nmatsakis: thanks, I'll see if I can tackle it
[17:29:12] *** Joins: Rym (y@moz-c2u.sd4.38.217.IP)
[17:30:06] *** Quits: laumann (thomas@moz-vj4.hq0.225.130.IP) (Quit: leaving)
[17:30:22] <nmatsakis> eddyb: sorry, what does ART stand for?
[17:30:31] <nmatsakis> meant to ask earlier
[17:31:21] <eddyb> nmatsakis: anonymized return types
[17:32:03] <nmatsakis> I'm not sure what that is :)
[17:32:25] <eddyb> -> impl Trait
[17:49:02] <eddyb> nmatsakis: does this have any chance? https://github.com/rust-lang/rfcs/pull/591#issuecomment-105809406
[17:49:37] <nmatsakis> eddyb: I've been meaning to read that comment and digest it...
[17:49:58] <nmatsakis> ...but I think that using some kind of assicated something or other could be a nice alternative
[17:59:30] *** Quits: brson (brson@moz-48fqub.res.rr.com) (Quit: leaving)
[18:03:55] *** Quits: Rym (y@moz-c2u.sd4.38.217.IP) (Ping timeout: 121 seconds)
[18:53:25] *** Joins: Rym (y@moz-c2u.sd4.38.217.IP)
[18:57:39] *** Quits: Rym (y@moz-c2u.sd4.38.217.IP) (Ping timeout: 121 seconds)
[19:09:37] *** Joins: killercup (killercup@moz-723bo4.dip0.t-ipconnect.de)
[19:12:39] *** ker is now known as oli_obk
[19:20:28] *** Joins: Rym (y@moz-c2u.sd4.38.217.IP)
[19:24:47] *** Quits: Rym (y@moz-c2u.sd4.38.217.IP) (Ping timeout: 121 seconds)
[19:34:35] *** Joins: nrc (nrc@moz-14pjgj.xtra.co.nz)
[19:34:36] *** ChanServ sets mode: +qo nrc nrc
[19:52:33] <nmatsakis> dear me but do we have a lot of global maps
[19:55:31] <eddyb> I was just about to add a new one!
[19:55:43] <eddyb> though I don't have to
[20:14:37] *** Joins: Rym (y@moz-c2u.sd4.38.217.IP)
[20:18:55] *** Quits: Rym (y@moz-c2u.sd4.38.217.IP) (Ping timeout: 121 seconds)
[20:28:23] *** Joins: sigma (sigma@moz-k1ghg8.range109-153.btcentralplus.com)
[20:52:35] *** Quits: sigma (sigma@moz-k1ghg8.range109-153.btcentralplus.com) (Ping timeout: 121 seconds)
[21:02:21] *** Quits: whipsch (whipsch@moz-bl4i0b.from.irc.camp) (Ping timeout: 121 seconds)
[21:08:46] *** Joins: Rym (y@moz-c2u.sd4.38.217.IP)
[21:13:04] *** Quits: Rym (y@moz-c2u.sd4.38.217.IP) (Ping timeout: 121 seconds)
[21:16:02] *** Joins: whipsch (whipsch@moz-bl4i0b.from.irc.camp)
[21:35:07] *** kimundi is now known as zz_kimundi
[21:35:18] *** Parts: simukis (nagisa@moz-8t068g.static.zebra.lt) ()
[21:35:27] *** Joins: simukis (nagisa@moz-8t068g.static.zebra.lt)
[21:36:08] *** zz_kimundi is now known as kimundi
[21:45:16] <nrc> I wish we had somethin like pretty expanded for a post-inlinging/monomorphisation program
[21:45:36] <nrc> hat would be really useful right now
[21:46:13] <eddyb> nrc: you mean, --pretty=typed?
[21:46:41] <eddyb> because that should be possible to combine with monomorphization
[21:49:08] <nrc> typed, identified, all of the above. But having output including all the source that goes in to an LLVM module, whether it comes from the actual source or from metadata from other crates
[21:50:16] <nrc> I think actually inlining and monomorphisation could happen in a phase before trans proper, as an early manipulation of the LIR
[21:51:09] <nrc> related I'm naming my ideal, hypothetical compiler NRustC :-p
[22:16:50] *** Joins: Rym (y@moz-c2u.sd4.38.217.IP)
[22:23:38] *** Quits: simukis (nagisa@moz-8t068g.static.zebra.lt) (Ping timeout: 121 seconds)
[22:27:04] *** Quits: killercup (killercup@moz-723bo4.dip0.t-ipconnect.de) (Quit: Bye)
[22:34:41] <eddyb> nrc: rs0 here
[22:35:07] *** Quits: JustAPerson (JustAPerson@moz-un628q.moe) (Ping timeout: 121 seconds)
[22:35:10] * eddyb should work on that instead of just mentioning rs-3 -> rs-2 -> rs-1 -> rs0 from time to time...
[22:38:35] *** Joins: JustAPerson (JustAPerson@moz-un628q.moe)
[22:46:47] *** Quits: JustAPerson (JustAPerson@moz-un628q.moe) (Ping timeout: 121 seconds)
[22:59:36] <nrc> hoiw does translating a closure lead to a const?
[23:00:54] <pnkfelix> nmatsakis: BTW thanks for the help with _match earlier
[23:01:12] <nmatsakis> pnkfelix: what's status?
[23:01:19] <pnkfelix> nmatsakis: the technique of differentiating aliasing and non-aliasing match pattern bindings worked out well, I think
[23:01:55] <pnkfelix> nmatsakis: I am down to 9 errors during `make check-stage1`. That is a small enough number that I'm taking a shot at bootstrapping `rustc-stage2`
[23:02:11] <pnkfelix> (run-pass errors that is; before I was looking at numbers like 40 -- 70)
[23:03:16] <pnkfelix> nmatsakis: unfortunately I did not include a -Z flag to revert to the previous behavior, so its a little tricky to get apples-to-apples benchmark comparisons out of the gate.
[23:03:48] <pnkfelix> nmatsakis: (I can obviously build a reference compiler; maybe that's a better idea anyway...)
[23:03:50] <nrc> eddyb: do you know about consts - do we we speculatively promote any expression to a const during trans? I'm looking at expr.rs:217
[23:04:07] <arielb1> nrc: we do
[23:04:13] <pnkfelix> nrc: yes const-eval applies to semi-arbitrary expresions
[23:04:24] <eddyb> nrc: any actually-constant rvalue
[23:04:29] <eddyb> did it break closures?
[23:04:36] <nrc> that would include closures, right?
[23:04:51] <eddyb> those with no captures
[23:04:57] <nrc> ah, right
[23:04:59] <nrc> maybe?
[23:05:06] <nrc> still looking
[23:05:33] <nrc> seems that the const globals might be too global - i.e., one per crate rather than one per compilation unit
[23:05:41] <nrc> lots of new code for me to read
[23:06:18] <arielb1> nrc: what are you doing?
[23:06:34] <nrc> trying to fix parallel codegen
[23:07:21] <eddyb> nrc: oh :(
[23:07:35] *** Joins: JustAPerson (JustAPerson@moz-un628q.moe)
[23:07:50] <eddyb> nrc: there's like 3 or 4 maps that need to be per-unit
[23:09:24] <nrc> it looks like most of them are already per-unit - e.g., const_values
[23:10:38] <nrc> I don't see any smoking guns on the shared contexts
[23:16:42] *** kimundi is now known as zz_kimundi

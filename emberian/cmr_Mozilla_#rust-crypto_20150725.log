[00:30:17] *** Quits: erickt (erickt@moz-4hh.6p3.217.74.IP) (Ping timeout: 121 seconds)
[01:23:36] <Ilari> bascule: I think that if one can attack that sort of selfsigned signature key (of course, one has to be careful it indeed is a signature key!), lots of things would be in trouble.
[01:27:31] <eternaleye> So I've finally gotten started on making a HIP implementation (using libpnet, because it's pretty damn nice)
[01:27:40] <eternaleye> I have decided to call it "hipsters" :P
[01:29:21] <Ilari> How strong host identites are in HIP?
[01:31:11] <eternaleye> Ilari: Strongest available host identities are P-384 ECDSA keys, with the HIT being the 96-bit-truncation of its SHA-384 hash.
[01:31:34] <eternaleye> Ilari: Unless you use some absurdly-large RSA key, since those don't have a size cap AFAIK
[01:32:03] <eternaleye> Ilari: RSA HITs are 96-bit truncation of the SHA-256 of the pubkey
[01:40:43] <eternaleye> Ilari: (the ORCHID encoding only has 96 bits of space after the IPv6 prefix)
[01:42:33] <eternaleye> Ilari: I did some extensive math about how hard it'd be to get a usefully colliding HIT on that ticket in the Snow repo: https://github.com/zrm/snow/issues/1#issuecomment-124291092
[01:42:55] <eternaleye> Ilari: My 2^40 legitimate HITs number comes from here: https://github.com/zrm/snow/issues/1#issuecomment-120302715
[01:46:21] <eternaleye> Ilari: But basically, an attacker would have to generate 2^64 HITs to get a 1/2^32 chance of a useful collision
[01:59:36] <eternaleye> Huh, the odds of useful collision actually come out very very close to 2^96/n, where n is how many HITs the attacker generates
[01:59:49] <eternaleye> er, n/2^96
[02:25:41] <bascule> Ilari: haha indeed
[02:25:45] <bascule> Ilari: wtf responses
[02:25:48] <bascule> I'm like
[02:25:56] <bascule> you people are designing security infrastructure? really?
[02:26:03] <bascule> THE VULNS HAVE BEEN FOUND. IT'S GOOD NOW.
[02:26:04] <bascule> WAT
[02:34:38] <eternaleye> bascule: Those responsible for sacking the offenders have been sacked.
[02:36:50] <bascule> https://mailarchive.ietf.org/arch/msg/unbearable/NR2KxRO2lnOk06EyLud6l1uz3BI
[02:37:34] <bascule> I just want macaroons that are contextually confined to a particular TLS channel
[02:40:00] <Ilari> I actually did figure out one usecase for extensions: Anonymous federation (passing the token in extension). Of course, how to implement that in browsers is nastier problem.
[02:41:27] <Ilari> Idea being: IdP does not get to know who RP is, if RP is honest.
[02:59:21] <Ilari> bascule: Also, assuming the signature is actually verified properly (e.g. the verifier actually verifies claimed algorithm), there are no attacks if client is not extremely buggy due to keys acting as globally&securely unique identifiers.
[03:00:59] <Ilari> And example of that "e.g." being broken: The key says it is RSA-PSS key, but verifier verifies the signature as HMAC-SHA256 MAC.
[03:05:58] <bascule> Ilari: https://twitter.com/sleevi_/status/624775701120614400
[03:09:30] <Ilari> Yeah, the hardware token stuff is troublesome for two reasons: 1) Used as justification for bad signature algorithms. 2) Used as justification for wanting "attestation", which is troublesome at best, and web-breaking at worst.
[03:11:44] <Ilari> There are vendors that want to do wanton stuff with their technologies, even after it has been pointed to them that the use is unacceptable and why it is unacceptable.
[03:14:34] <bascule> Ilari: we can totally have good hardware tokens yo
[03:14:41] <bascule> my company already makes them
[03:14:50] <bascule> Yubikeys + U2F seem ok?
[03:15:32] <Ilari> bascule: That is the "troublesome at best" case.
[03:17:00] <Ilari> bascule: And when one does attestatation in way that links keys, it goes to web-breaking.
[03:19:05] <bascule> you don't have to do that
[03:19:13] <bascule> U2F follows the same origin policy
[03:19:19] <bascule> and there are anonymous attestation protocols
[03:20:03] <bascule> the real problem are 1) hardware token vendors who are all super obsessed with IDENTITY AS A BUSINESS and 2) hardware token vendors peddling shitty, obsolete hardware
[03:20:51] <Ilari> bascule: Yes, and when attestation is not anonymous, things get extremely ugly extremely fast.
[03:20:58] <bascule> yeah
[03:21:29] <bascule> it's kind of funny how the protocols that preserve privacy generally also provide the best security
[03:22:30] <Ilari> Also, the stated usecase for attestation is some "high security" (and banks were given as example) sites requiring hardware tokens.
[03:24:13] * bascule wants it for confining bearer tokens to secure channels in an "enterprise" context
[03:26:55] <Ilari> The "anonymous federation" would work as follows: Send a token to browser. Then browser RP JS passes capability for RP key and the token to IdP JS (somehow avoiding passing origin). The token is then added to extensions in referred key, IdP returns its own token, which is then pased to RP.
[03:27:30] <Ilari> The IdP token contains the RP token, the RP key and is signed by IdP.
[03:28:10] <Ilari> The RP can then verify the IdP signature and extract the token, check it is valid.
[03:28:17] <bascule> Ilari: what if the hardware token could generate an origin-specific EC*SA private key, and use that to sign ephemeral keys or do Noise-style triple-DH with static origin-bound DH keys?
[03:29:01] <bascule> the former is what U2F already provides
[03:29:10] <bascule> with ECDSA
[03:29:17] <bascule> not that I'm a fan of Dan Brown but it's ok?
[03:29:18] <Ilari> Unfortunately, due to "speed constraints", there is only one flight for keys.
[03:29:37] <bascule> I think you could work U2F into ClientKeyExchange?
[03:30:46] *** Quits: zeiris (dan@moz-nfg.gu4.131.104.IP) (Quit: segfault)
[03:30:58] *** Joins: zeiris (dan@moz-nfg.gu4.131.104.IP)
[03:31:35] <Ilari> Well, one could diffie-hellman DH key with per-channel secret nonce. Doesn't support extensions through, and would require TLS-Extractor instead of just TLS-Unique.
[03:31:43] <bascule> now I'm asking Brad Hill
[03:31:47] <bascule> can we just throw tokbind out
[03:31:58] <bascule> and use U2F to create origin-bound TLS client certificates?
[03:32:08] <Ilari> (I was playing with TLS-Extractor in Gnutls before TLS-Extractor even was an RFC)
[03:33:34] <Ilari> bascule: Also, the fact that cookies don't follow same-origin tends to create nasty edge cases.
[03:34:04] <Ilari> bascule: So you need a key per scope. And have fun when scope changes.
[03:35:03] <Ilari> bascule: I think the reason why not use TLS client certs got asked many times.
[03:36:41] <bascule> the main problem to me is the UX sucks
[03:37:07] <bascule> but if you have origin-bound certificates which are stored in some sort of secure context, the UX problem melts away
[03:37:19] <bascule> and that also fixes the privacy problems!
[03:38:57] *** Quits: zeiris (dan@moz-nfg.gu4.131.104.IP) (Quit: segfault)
[03:38:59] <Ilari> Reminds me of one protocol I designed that needed to do serious integerity protection (integerity of control) with unencrypted(!) HTTP.
[03:39:04] *** Joins: zeiris (dan@moz-nfg.gu4.131.104.IP)
[03:43:15] <Ilari> I think the only justification the folks there have for having RSA PKCS#1 v1.5 is "hardware tokens".
[03:45:55] <bascule> yes
[03:45:58] <bascule> that's the problem
[03:46:09] <bascule> tokens that do RSA, and they want to reuse them for ECC
[03:46:35] <bascule> as opposed to tokens designed from the ground-up for ECC, or even just ones with reasonably mordern CPUs
[03:48:06] <Ilari> I think software could easily do RSA-PSS for RSA.
[03:54:52] *** Joins: erickt (erickt@moz-njt.vqi.14.76.IP)
[04:02:46] <Ilari> Eeh, using DH keys with time constrints given can't actually work.
[04:04:03] *** Quits: eternaleye (eternaleye@moz-7ps.ehi.245.50.IP) (Ping timeout: 121 seconds)
[04:05:08] *** Joins: eternaleye (eternaleye@moz-7ps.ehi.245.50.IP)
[04:09:21] *** Quits: eternaleye (eternaleye@moz-7ps.ehi.245.50.IP) (Ping timeout: 121 seconds)
[04:09:50] *** Joins: eternaleye (eternaleye@moz-7ps.ehi.245.50.IP)
[04:16:17] *** Joins: dpc (dpc@moz-t6gr4b.ca.comcast.net)
[04:18:06] <bascule> Ilari: what about the Macaroons model?
[04:18:16] <bascule> where the DH keys just define a secure channel (AuthN)
[04:18:29] <bascule> and the bearer credential, which is bound to the channel, defines the time constraints
[04:22:24] <Ilari> I mean that due to tokbind not wanting to add any new flights, one needs signatures.
[04:23:03] *** Quits: dpc (dpc@moz-t6gr4b.ca.comcast.net) (Ping timeout: 121 seconds)
[04:23:30] *** Joins: skeuomor1 (skeuomorf@moz-qe4.ip0.32.197.IP)
[04:24:08] <bascule> Ilari: oh, well tokbind is just generally doing everything wrong in my opinion?
[04:24:31] <bascule> at least I apparently helped convince them they didn't need ALPN maybe?
[04:25:11] *** Quits: skeuomorf (skeuomorf@moz-mrf.u8d.32.197.IP) (Ping timeout: 121 seconds)
[04:26:10] <bascule> I'm just like
[04:26:15] <bascule> Sleevi in March: https://twitter.com/sleevi_/status/580660273024921600
[04:26:23] <bascule> Sleevi today: https://twitter.com/sleevi_/status/624774850247311361
[04:27:04] *** Joins: dpc (dpc@moz-t6gr4b.ca.comcast.net)
[04:27:05] <bascule> I thought of tokbind as being kind of a "Google" thing
[04:27:17] <bascule> and here's one of the main Chrome security people being like NOPE
[04:27:21] <bascule> that's a warning sign
[04:32:12] <Ilari> What all you think is screwed up in tokbind (besides hardware focus, multiple notations for supported signatures and such)?
[04:51:49] <Ilari> Lol: 0.00404 (ARIN inventory counter), 265 /24s remain.
[04:54:44] <Ilari> That's ~9.2% of pool gone in one day.
[05:00:30] <Ilari> Lol, good old <marquee> (hit a website using that).
[05:07:58] *** Joins: neal (neal@moz-of66u9.ca.comcast.net)
[05:11:46] *** Joins: dpc__ (dpc@moz-t6gr4b.ca.comcast.net)
[06:42:39] *** Quits: erickt (erickt@moz-njt.vqi.14.76.IP) (Ping timeout: 121 seconds)
[08:13:41] *** Quits: dpc__ (dpc@moz-t6gr4b.ca.comcast.net) (Ping timeout: 121 seconds)
[08:13:50] *** Quits: dpc (dpc@moz-t6gr4b.ca.comcast.net) (Ping timeout: 121 seconds)
[09:06:56] *** Quits: kmc (keegan@moz-gjgn5n.compute.amazonaws.com) (Quit: leaving)
[10:23:34] *** Joins: gleb (gleb@moz-3u1drv.rusanovka-net.kiev.ua)
[13:07:37] <Tiffany> I am happy firefox no longer supports that tag
[13:07:49] <Tiffany> at least, I think
[13:08:19] <Tiffany> oh god, it's still there
[13:08:24] <Tiffany> maybe it was blink they removed
[13:08:25] <eternaleye> Tiffany: There's also a polyfill!
[13:08:30] <eternaleye> Tiffany: In javascript!
[13:08:38] <Tiffany> yeah, it's <blink> that's gone
[13:08:46] <eternaleye> For both of them :P
[13:08:48] <Tiffany> data:text/html,<blink>test</blink>
[13:08:53] <Tiffany> and yeah
[13:08:56] <Tiffany> you can do it in css/js
[13:09:02] <Tiffany> but please don't
[13:09:17] <Tiffany> marquee and blink were never added to any standard were they?
[13:09:52] <eternaleye> Honestly, I'm in favor of their removal purely from the "content, not presentation" POV
[13:10:18] <eternaleye> I'm utterly indifferent to the _behavior_ itself
[13:10:54] <Tiffany> I dislike the behaviour
[13:11:23] <Tiffany> I think the original reasoning they were never standardized is because they don't map to print media or screen readers
[13:11:45] <Tiffany> and having to wait a couple seconds to read some text so it can scroll by gruelingly slow is pretty painful
[13:12:43] <Tiffany> although, someone might mention TV news, which uses a marquee for stuff they're not discussing live...
[13:13:04] <eternaleye> They both have valid uses.
[13:13:12] <Ilari> Also, IIRC curl uses marquee for long names.
[13:13:18] <Tiffany> yeah, it does
[13:13:36] <Tiffany> it does it in a way that makes it impossible to read the last character of the filename
[13:13:51] <eternaleye> It bounces, doesn't it? Rather than cycling?
[13:13:54] <Tiffany> yeah
[13:14:09] <Tiffany> I want ARIN to run out soon so I can say ARIN has run out
[13:33:19] <Ilari> Well, 265x/24 remaining...
[13:33:52] <Tiffany> yeah
[13:53:34] <Ilari> That's less than 70,000 addresses total.
[13:58:00] <Ilari> Also, looks like MS Edge makes HSTS block all mixed content (and Chrome is planning to follow). Which means that sites that have thrid party mixed content and can't get rid of that (there are such sites) can't use HSTS.
[13:59:59] <Tiffany> mixed content does kind of lie about the site being secure, though
[14:00:45] <Ilari> Well, active mixed content is blocked anyway. And referrers are not sent for passive mixed content. Which limits damage quite a bit.
[14:01:09] <Tiffany> I suppose
[14:01:42] <Tiffany> you can't really tell if something is static site assets or the actual content of the page though
[14:01:53] <Tiffany> like imagine an image hosting site with https but the images are all hosted on a CDN without it
[14:03:03] <Ilari> Well, if one can edit the site code, one could make the site load all the images and then serve those. But that might run into trouble with things like copyright.
[14:04:24] <Ilari> And would likely also be helpful against that darn Chrome attack site detection (include a picture from site it thinks is "attack site" and it complains about _your_ site).
[14:06:22] <Ilari> If one has some medium-sized site (say, ISP user pages site) that accepts user content, it is quite likely that is classed as "attack site".
[14:06:59] <Tiffany> nice
[14:09:28] <Ilari> Really, if image decoder has some vulernability, things are bad anyway. And network attackers can easily attack user on any HTTP site.
[14:10:57] <Tiffany> how common are image decoder vulnerabilities?
[14:11:34] <Ilari> There have been numerious, but those aren't very common.
[14:11:43] <Tiffany> I imagine they're the perfect target for fuzzers
[14:12:25] <Tiffany> PNG is not a complex format to parse (although processing it can get pretty complicated)
[14:12:38] <Ilari> Many image formats have compression, which might have vulernabilites in decoder (there have been a number of those in zlib for instance).
[14:13:08] <Tiffany> oh yeah
[14:13:21] <Tiffany> I imagine jpeg is a pain to parse
[14:13:32] <Ilari> I actually have written PNG file decoder (which punts stream decompression to zlib).
[14:15:54] <Tiffany> I wrote some code to parse PNG headers using lua
[14:19:09] <Ilari> (Well, didn't take long to find an security bug in that decoder, fortunately it can only crash the program).
[14:45:15] <Ilari> That decoder I wrote seems to at least try to deal with interlaced PNGs.
[14:52:29] <Ilari> If one wanted to be an asshole: Find RCE bugs in IE6, IE7 and IE8 (on XP). Now that XP is truly EOL'd, those bugs will remain unpatched, and make it quite dangerous to use old IE.
[14:53:10] <Ilari> *find and publish
[14:54:24] <Ilari> And maybe the same for Android 2.3 browser...
[14:55:51] <Tiffany> I would have thought there'd already be some out in the wild
[14:56:24] <Tiffany> I know there was a nasty one released immediately after the EOL, but it was fixed anyway
[14:56:47] <Tiffany> the reasoning was that it would harm the internet as a whole, because so many people still use XP
[14:56:51] <Ilari> Tiffany: WXP EOL or W2003 EOL?
[14:56:56] <Tiffany> WXP
[14:57:25] <Ilari> Tiffany: Because in effect, WXP did get patches even after it was declared EOL (due to W2003 still being supported).
[14:58:48] <Tiffany> the most recent IE 6 vuln on cvedetails appears to have been fixed as well
[14:58:49] <Tiffany> https://technet.microsoft.com/library/security/ms15-065
[14:59:00] <Tiffany> 3 days ago...
[14:59:55] <Tiffany> W2003 is EOLed as of earlier this month, apparently
[15:00:04] <Tiffany> and that's extended support, not mainstream support
[15:01:07] <Ilari> No mention of XP in that advisory (tho WXP can use W2003 updates).
[15:01:12] <Tiffany> I imagine the main reason IE6 keeps getting patched is because these bugs affect more than just IE6
[15:02:11] <Tiffany> it would be nice if there was a site that showed which vulnerabilities were still unpatched
[15:02:20] <Ilari> That bulletin was published July 14th. Isn't that the final day for W2003?
[15:02:20] <Tiffany> for various softawre
[15:02:24] <Tiffany> kind of like cvedetails
[15:02:51] <Ilari> (The July 22nd is update date).
[15:03:01] <Tiffany> yeah, it is
[15:03:47] <Ilari> So it very well might be that there truly will be no further patches for IE6/IE7/IE8 on WXP/W2003. But there might be further IE7 patches (for Vista).
[15:04:28] <Tiffany> have the two outstanding flash vulnerabilities been fixed yet?
[15:04:30] <Tiffany> it's hard to find out
[15:05:22] <Tiffany> firefox and chrome are no longer treating flash like the plague on my system
[15:05:27] <Tiffany> which is too bad
[15:05:32] <Elaine> yeah it really is
[15:06:11] <Tiffany> I really wish they would just assume there are always going to be vulnerabilities in flash waiting to happen and just leave it permanently on security warning mode
[15:06:42] <Tiffany> adobe clearly has no interest in making this situation any worse
[15:07:00] <Tiffany> I heard a cited number that 90% of flash vulnerabilities are due to malformed inputs, i.e. they don't validate before processing
[15:07:13] <Tiffany> er, any betteR*
[15:22:46] *** Joins: eddyb_ (eddyb@moz-vej.dmj.25.188.IP)
[15:23:43] *** Joins: erickt (erickt@moz-njt.vqi.14.76.IP)
[15:23:45] *** Quits: eddyb (eddyb@moz-j5m.32b.126.86.IP) (Connection closed)
[15:36:55] <Ilari> Other things that are just plain too insecure: Loading Lua bytecode one didn't compile yourself. That is perennial source of code execution bugs, and Lua authors can't seem to fix those.
[15:38:49] *** eddyb_ is now known as eddyb
[15:41:48] <Ilari> It eventually got so bad that Lua 5.2 has an flags on calls that load code if source is allowed and if bytecode is allowed.
[15:41:58] <Tiffany> yeah I know
[15:42:25] <Tiffany> they should probably put more danger flags on it
[15:42:47] <Ilari> One program I wrote sets that flag to source only, and additionally checks for bytecode signature (and refuses to load the code if found).
[15:42:49] <Tiffany> all the validation happens in the language layer
[15:43:38] <Tiffany> there's missing type checks and stuff in the bytecode
[15:49:08] <Ilari> Also, Chrome devs are discussing changing "dubious TLS" indication to be identical to HTTP indication.
[15:49:46] <Ilari> That indication is given on mixed content and some minor TLS errors.
[16:13:22] <Ilari> Well, if one wants to, one can serve 301 redirect in http:// pages, redirecting to https://. The browser does cache redirects like that.
[16:25:20] *** Quits: neal (neal@moz-of66u9.ca.comcast.net) (Quit: My Mac has gone to sleep. ZZZzzz…)
[16:52:16] <bascule> Ilari: wtf
[16:52:18] <bascule> "What we've cannot yet turn off is RC4.  That's still sufficiently
[16:52:18] <bascule> widely used that disabling RC4 would result in excessive cleartext
[16:52:19] <bascule> fallback and even in some cases failure to deliver email."
[16:52:27] <bascule> uhh
[17:05:38] *** Joins: dpc (dpc@moz-t6gr4b.ca.comcast.net)
[17:06:02] *** Joins: dpc__ (dpc@moz-t6gr4b.ca.comcast.net)
[17:19:55] *** Quits: dpc (dpc@moz-t6gr4b.ca.comcast.net) (Ping timeout: 121 seconds)
[17:19:58] *** Quits: dpc__ (dpc@moz-t6gr4b.ca.comcast.net) (Ping timeout: 121 seconds)
[17:36:44] <Ilari> Well, it seems likely that RC4 is no better than snake oil against attackers here.
[17:42:53] <Ilari> bascule: Well, the way tokbind does keys, if you get algorithms on verification wrong, everything breaks.
[17:43:08] <Ilari> bascule: In this won't work at all way.
[17:47:03] <Ilari> bascule: Also, libraries don't support taking a JWK and verifying JWS using it?
[18:23:22] *** Quits: gleb (gleb@moz-3u1drv.rusanovka-net.kiev.ua) (Ping timeout: 121 seconds)
[18:55:25] <Ilari> bascule: Got some list of of things that is wrong with tokbind (at very low resolution if it is fractal)?
[18:56:10] <WindowsBunny> Does anyone know if there is a maximum size on TLS packets?
[18:57:05] <Ilari> WindowsBunny: You mean records?
[18:57:59] <Ilari> WindowsBunny: If so, IIRC 18kB (16kB maximum payload, the 2kB is buffer for expansion).
[18:58:40] <Ilari> WindowsBunny: Handshake messages can be up to 2^24-1 bytes (3-byte length field and can be fragmented).
[18:59:09] <WindowsBunny> I ask because schannel requires that I give it an entire message at a time
[18:59:27] <WindowsBunny> Otherwise it'll give me an error telling me the message was incomplete and ask me to get more before I try again
[19:00:34] <WindowsBunny> I'll probably just use a Vec and resize it as needed
[19:01:24] <Ilari> Yup, 18*1024 bytes, not counting the 5 byte header.
[19:03:09] <Ilari> (The length of payload is in the 5 byte header, and the value of that field can only go up to that amount)
[19:04:04] <Ilari> Probably not a good idea to dynamically allocate it, given that ~16kB records are common, and 18kB is not far above that.
[19:05:47] <WindowsBunny> Ilari: Yeah but handshake messages can be up to 2^24-1 as you said
[19:06:28] <Ilari> WindowsBunny: I don't think it can take handshake messages as input, because one of those is encrypted.
[19:06:57] *** skeuomor1 is now known as skeuomorf
[19:07:12] <WindowsBunny> The schannel API requires doing the handshake manually
[19:07:37] <WindowsBunny> where I have to read from the socket or whatever myself, hand it off to schannel, and schannel gives me the reply that I have to write out
[19:18:50] <Ilari> WindowsBunny: But is it at record level or handshake message level for handshakes and records for everything else?
[19:19:14] <WindowsBunny> Ilari: I... don't know
[19:19:33] <Ilari> WindowsBunny: I would presume record level. Because the latter would be way beyond insane..
[19:20:16] <Ilari> WindowsBunny: You have name of relevant function so I could search the documentation for it?
[19:20:49] <WindowsBunny> Ilari: https://msdn.microsoft.com/en-us/library/windows/desktop/aa375924%28v=vs.85%29.aspx
[19:23:40] <Ilari> WindowsBunny: Windows 8.1 minimum? What the heck is that function? And it doesn't seem to be directly connected with TLS.
[19:24:15] <WindowsBunny> Ilari: Oh, the function is available from windows XP and up
[19:25:17] <WindowsBunny> Ilari: Schannel is the security package that provides TLS and SSL
[19:25:24] <Ilari> WindowsBunny: Well, try passing it records. If it doesn't work, the API is just borked.
[19:30:09] <WindowsBunny> alright, I'll try with a fixed buffer size of 0x5000 for now and see how things work
[19:30:38] <WindowsBunny> the msdn documentation for security stuff is so obscure
[19:32:55] <Ilari> WindowsBunny: Well, if it is not records, you will discover that very quickly (nothing will work if you get it wrong).
[19:33:34] <WindowsBunny> Ilari: I can just have an unreachable! thing if it wants more and the buffer is already maxed
[19:42:53] <Ilari> WindowsBunny: Well, if you read the buffers at record level, just break off the connection and log an error if the length field value is bigger than 18432.
[19:44:08] <Ilari> WindowsBunny: Because either the state is corrupted or the client is extremely buggy.
[19:44:29] <WindowsBunny> Ilari: Well I'm not reading the record headers myself, I just pass the data to schannel, and if it isn't enough it tells me how much more I should read before I try again
[19:45:54] <Ilari> WindowsBunny: Well, at least this can't be subtly buggy. If you get it wrong, things immediately break.
[19:48:46] <WindowsBunny> if I run out of buffer space, then my assumptions about it dealing only with records is wrong
[19:49:18] <Ilari> Well, I would think that if you get it wrong, you get errors even without running out of buffers.
[19:49:22] <WindowsBunny> otherwise, if the other end does something weird and sends invalid sizes for records, schannel should error at me
[19:49:41] <Ilari> Well, SChannel isn't known to be good at sending errors to other end.
[19:52:20] <WindowsBunny> as long as it obeys the SSL/TLS specs, I'll be happy
[19:57:33] <bascule> Ilari: how do you use Tokbind to bind a channel to a hardware token?
[19:59:28] <Ilari> bascule: Ask the token to generate a non-exportable key and then use public half of that as the key in protocol (obviously signing the challenges using the token).
[20:00:14] <bascule> and I mean honestly do you think JWS is the right tool for the job here?
[20:01:10] <Ilari> Well, I think it would get job done. But the present mechanism (once one rounds off some nasty corners) is much simpler than JWS.
[20:02:24] <Ilari> That "rounding off corners" refers to having unified naming scheme for signature algorithms (and not the present "bastardized TLS scheme in one place and custom registry in another").
[20:04:07] <Ilari> And yes, JWS does support RSA-PKCS#1 v1.5 ... Unfortunately.
[20:25:50] *** Joins: gleb (gleb@moz-3u1drv.rusanovka-net.kiev.ua)
[20:33:27] *** Joins: dpc (dpc@moz-t6gr4b.ca.comcast.net)
[20:33:38] *** Joins: dpc__ (dpc@moz-t6gr4b.ca.comcast.net)
[20:34:08] *** Quits: dpc__ (dpc@moz-t6gr4b.ca.comcast.net) (Connection closed)
[20:34:28] *** Joins: dpc__ (dpc@moz-t6gr4b.ca.comcast.net)
[20:39:08] <Ilari> bascule: If using JWS for tokbind, the problem for attackers is that replacing the algorithm in key causes the key to become different key.
[20:39:08] *** Quits: dpc__ (dpc@moz-t6gr4b.ca.comcast.net) (Ping timeout: 121 seconds)
[20:39:17] *** Quits: dpc (dpc@moz-t6gr4b.ca.comcast.net) (Ping timeout: 121 seconds)
[21:05:01] *** Joins: neal (neal@moz-of66u9.ca.comcast.net)
[21:08:05] *** Quits: neal (neal@moz-of66u9.ca.comcast.net) (Quit: My Mac has gone to sleep. ZZZzzz…)
[21:12:01] *** Joins: neal (neal@moz-of66u9.ca.comcast.net)
[21:16:06] *** Quits: neal (neal@moz-of66u9.ca.comcast.net) (Quit: My Mac has gone to sleep. ZZZzzz…)
[21:40:20] *** Joins: dpc__ (dpc@moz-t6gr4b.ca.comcast.net)
[21:40:25] *** Joins: dpc (dpc@moz-t6gr4b.ca.comcast.net)
[21:41:52] *** Quits: erickt (erickt@moz-njt.vqi.14.76.IP) (Ping timeout: 121 seconds)
[22:35:47] *** Quits: dpc__ (dpc@moz-t6gr4b.ca.comcast.net) (Connection closed)
[22:35:54] *** Quits: dpc (dpc@moz-t6gr4b.ca.comcast.net) (Connection closed)
[22:35:58] *** Joins: dpc__ (dpc@moz-t6gr4b.ca.comcast.net)
[22:36:06] *** Joins: dpc (dpc@moz-t6gr4b.ca.comcast.net)
[22:37:23] *** Quits: dpc__ (dpc@moz-t6gr4b.ca.comcast.net) (Connection closed)
[22:37:33] *** Quits: dpc (dpc@moz-t6gr4b.ca.comcast.net) (Connection closed)
[22:37:34] *** Joins: dpc__ (dpc@moz-t6gr4b.ca.comcast.net)
[22:37:44] *** Joins: dpc (dpc@moz-t6gr4b.ca.comcast.net)
[23:04:10] *** Joins: Tobba (Tobba@moz-o13d22.bredband.telia.com)
[23:17:58] <Ilari> "What is it people are doing with PHP that requires so many bad random numbers so quickly?"
[23:19:58] <Tiffany> are there really so many bad random number generators?
[23:20:37] <Ilari> It is very easy to make a bad random number generator.
[23:21:45] <Tiffany> maybe PHP developers feel like there isn't enough excitement in their lives, so they create nondeterministic code and do poorly seeded crypto
[23:24:30] <mcpherrin> I hope nobody is using that rng for crypto
[23:24:47] <mcpherrin> odd number bug or not, mt are not csprngs
[23:25:33] <Tiffany> the built-in one, you mean? or a different one?
[23:29:54] <mcpherrin> mersenne twisters are never crypto safe
[23:30:38] <Tiffany> well, yeah
[23:35:36] *** Joins: neal (neal@moz-of66u9.ca.comcast.net)
[23:41:31] <Ilari> Also, PHP memory management is shit. Try to make a large page (but much less than the amount of memory available) and the thing will just plain OOM.
[23:41:57] <mcpherrin> Ilari: omg, 5 years ago I worked on an embedded device with a php web control page
[23:42:10] <mcpherrin> We restarted apache after every pageload to avoid oom issues :|
[23:42:18] <mcpherrin> it was like running the whole damn webserver as a CGI
[23:42:27] <mcpherrin> dailywtf worthy
[23:43:04] <Ilari> Well, I'm not talking about system OOM, but PHP itself OOMing against the memory limits (thankfully autoresets).
[23:43:36] <Ilari> IIRC, 128MB or so memory limit and few MB page was enough to OOM it.
[23:45:01] <Tiffany> that explains why routers take so long to load admin pages...
[23:46:58] *** Quits: neal (neal@moz-of66u9.ca.comcast.net) (Quit: My Mac has gone to sleep. ZZZzzz…)
[23:53:46] <mcpherrin> Tiffany: This was actually an SS7 gateway!  Telecom hardware is ~the best~
[23:54:07] <mcpherrin> I think most home routers use lighttpd or something with C cgis ;p
[23:54:13] <mcpherrin> (or shell!)
[23:56:08] <Tiffany> mine didn't
[23:56:17] <Ilari> Also, slow scripting languages are probably major reason why most websites are so slow.
[23:56:26] <Tiffany> it used some weird obscure server
[23:56:41] <Tiffany> that and badly written SQL queries
[23:57:06] <Ilari> Yeah, that too.
[23:57:08] <Tiffany> it's kind of amazing how websites which take huge fractions of a second to render a single page can manage to service so many users
[23:57:15] <Elaine> The one router firmware I really poked at used thttpd
[23:57:34] <Elaine> the management interface was just a patch
[23:57:37] <Elaine> slash fork
[23:58:27] <Tiffany> my current router doesn't report the server in the response headers
[23:58:34] <Tiffany> it does send binary: login.cgi, though

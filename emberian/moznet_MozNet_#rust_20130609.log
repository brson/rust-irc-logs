[00:01:45] *** Joins: jensnockert (jensnocker@moz-8BE55278.customer.t3.se)
[00:02:23] <Eridius> cmr: any plans for extra::term to be able to do more than just set colors? For example, let it disable ECHO/ICANON?
[00:02:43] *** zz_kimundi is now known as kimundi
[00:02:53] *** Joins: FreezerburnV (freezerbur@moz-5718C330.bltmmd.fios.verizon.net)
[00:04:41] *** Joins: victorporof (victorporo@FE2F04DC.63E19875.D111398B.IP)
[00:04:53] <steven_is_false> strcat: clang's static analyzer finally finished compiling, and I think I found a few bugs!
[00:07:25] *** Quits: mattin (user@9E32F7E8.DC7A989C.7F8AB798.IP) (Quit: Leaving)
[00:09:57] *** Quits: EXetoC (ex@moz-2DBEB1E4.customer.t3.se) (Quit: WeeChat 0.4.1)
[00:11:23] *** Quits: victorporof (victorporo@FE2F04DC.63E19875.D111398B.IP) (Ping timeout)
[00:11:33] <MaikKlein> how do you read though big projects like rust? I am really struggling to understand how methods functions and types work under the hood. The frontend of rustc was pretty easy to understand.
[00:11:51] *** Joins: bytbox (s@moz-D83E9B31.wireless.umd.edu)
[00:12:19] *** Quits: FrozenCow (FrozenCow@moz-B2DF4929.chello.nl) (Client exited)
[00:13:26] *** Joins: int3_ (int3_@moz-ABE52D50.hsd1.ca.comcast.net)
[00:13:32] <aatch> MaikKlein, a lot of rustc is pretty bad code, in terms of structure.
[00:14:03] <aatch> It's because rust has evolved, but fixing up trans is a ton of work.
[00:14:24] <aatch> since it requires so many interlocking pieces.
[00:14:34] <steven_is_false> Dangit! scan-build only got me one possible bug, a null dereference in the task system. Except that it's probable not a bug.
[00:15:13] <steven_is_false> Also the task system is being rewritten in Rust anyways.
[00:16:11] *** Joins: snearch (snearch@moz-AA459792.pool.mediaways.net)
[00:16:55] <strcat> ssbr: &mut will work as long as they are unique references to the data
[00:17:14] <strcat> ssbr: tuple fields are disjoint data, so as long as you match out multiple references at the same time it will work
[00:17:21] <dbaupp> steven_is_false: so you're saying that Rust is near-perfect and has no bugs? :P
[00:17:21] <MaikKlein> I want to add autocompletion support for rust. I know that rust knows everything about to code so I am looking for a way to extract this information. It's pretty crazy to see files with 8k lines of code and I don't even know where to look. Can I make the compiler verbose? So that I can see how it is supposed to work? 
[00:18:05] <steven_is_false> dbaupp: I know it's such a shame I wish it was buggier than I could get credit for fixing the bugs.
[00:18:52] <aatch> MaikKlein, various parts have debug! statements, so doing a compile with RUST_LOG=rustc will print out stuff
[00:19:28] <steven_is_false> Although there do seem to be bugs in the supporting libraries.
[00:19:48] <aatch> I suggest narrowing the path down though, since some parts spit out a huge amount of lines.
[00:20:39] <MaikKlein> aatch, nice thanks, I noticed that too. Now I can start making some sense
[00:25:00] <MaikKlein> is the lint module broken?
[00:25:19] <aatch> MaikKlein, no.
[00:25:22] <MaikKlein> I get some weird lint logs that don't make any sense
[00:25:30] <aatch> unless it broke like /really/ recently.
[00:25:59] <Eridius> I assume vec::each2 is meant to be replaced with something like v.iter().zip(v2.iter()) ?
[00:26:20] *** Quits: vosen (vosen@moz-266BA656.icpnet.pl) (Quit: Leaving)
[00:26:24] <steven_is_false> brson is the person who worked on the tasking system right?
[00:26:38] <aatch> steven_is_false, he is working on the new one
[00:26:48] <aatch> I don't know who worked on the old one.
[00:26:49] <MaikKlein> the code that I am compiling is just struct Test; and it tells me that it finds mutable variables and unnecessary allocations 
[00:26:54] <steven_is_false> But he didn't work on the C++ one?
[00:26:58] <dbaupp> Eridius: correct
[00:27:22] <dbaupp> well, mostly, `v.iter().zip(v2.iter()).advance`
[00:27:24] <MaikKlein> and it find dead code
[00:27:29] <MaikKlein> finds*
[00:27:47] <aatch> MaikKlein, is it line 1, column 0?
[00:27:53] <aatch> for everything?
[00:28:04] <steven_is_false> There's one possible null reference. Which could be ignored by simply addding to the method assert(stck != NULL).
[00:28:52] <MaikKlein> like this one 
[00:28:53] <MaikKlein> rust: ~"insert fresh (~\"unused_mut\"->{lint: unused_mut, desc: \"detect mut variables which don\\\'t need to be mutable\", default: warn}) at idx 21, hash 7918075210329709556"
[00:29:06] <MaikKlein> wait i make a new file
[00:29:10] <MaikKlein> maybe something is broken 
[00:29:14] <aatch> MaikKlein, oh, so not actually output?
[00:29:39] <aatch> That's it detecting it in pulled in crates, like std
[00:29:41] <dbaupp> Eridius: there is strong plans to make the syntax nicer... all we need is the for protocol to support Iterator's natually, and default methods to work
[00:29:48] <MaikKlein> ahhh
[00:30:00] <MaikKlein> okay that makes sense
[00:30:07] *** Joins: Jesin (Jessin_@moz-3AD6F09F.res.lehigh.edu)
[00:30:30] <dbaupp> MaikKlein, aatch: isn't that it setting up a hashtable with all the lints, for later use?
[00:30:40] <bjz_> jensnockert: ping
[00:30:44] <aatch> dbaupp, that is also possible, I just thought of that too.
[00:30:45] <jensnockert> bjz_: Pong.
[00:30:54] <steven_is_false> TIL that just using assert(stck) would also work.
[00:31:31] <bjz_> jensnockert: test_barycentric seems to be failing for float and f64
[00:31:37] <Eridius> dbaupp: I wish that std::iterator::IteratorUtil was in the prelude.
[00:31:46] <dbaupp> Eridius: same! :(
[00:31:51] <jensnockert> bjz_: Did I fail something in the copying?
[00:31:58] <jensnockert> bjz_: Does it work for f32?
[00:32:06] <bjz_> seems to
[00:32:06] <dbaupp> Eridius: it's really annoying :/
[00:32:11] <bjz_> checking the test
[00:32:32] <aatch> hasn't it just been added?
[00:32:32] <Eridius> dbaupp: I get the rationale for removing all the uses from the prelude, even though I disagree with it, but it seems to me that at least the traits should be use'd
[00:32:44] <MaikKlein> std is default right?
[00:32:48] <MaikKlein> can I disable it?
[00:32:58] <aatch> MaikKlein, yes, #[no_std];
[00:33:02] <bjz_> jensnockert: weird, the impls and tests are the same
[00:33:15] <bjz_> jensnockert: btw, I pubified all the methods
[00:33:20] <dbaupp> Eridius: the problem isn't that
[00:33:29] <bjz_> jensnockert: it's the new style
[00:33:38] <dbaupp> Eridius: the problem is it conflicts with several other methods
[00:34:13] <dbaupp> Eridius: 
[00:34:16] <dbaupp> Eridius: https://github.com/mozilla/rust/issues/5898, sorry
[00:34:51] <bjz_> jensnockert: do `make check-stage1-std NO_REBUILD=1` if you want to check it quicker
[00:35:00] <Eridius> dbaupp: >_<
[00:35:24] <dbaupp> bjz_: there's NO_REBUILD? :O
[00:35:29] <dbaupp> bjz_: you're a hero!
[00:36:02] <bjz_> dbaupp: thank brson for that tidbit :)
[00:36:26] <bjz_> dbaupp: you have to have a recent build installed though
[00:36:39] <dbaupp> bjz_: certainly do
[00:37:02] *** Joins: pongad (Mibbit@moz-483DE200.hfc.comcastbusiness.net)
[00:37:16] <jensnockert> I just dev in a separate file, then copy in.
[00:37:20] <jensnockert> Much simpler.
[00:37:47] <bjz_> jensnockert: heh, that works too
[00:37:58] <pongad> Hello good sirs, I'm completely new with Rust and kind of confused. Wondering if you could help?
[00:38:14] <aatch> pongad, welcome! We are happy to help.
[00:38:20] <bjz_> pongad: you're in the right place!
[00:38:21] <bjz_> :D
[00:38:28] <aatch> Some of us are procrastinating from boring projects.
[00:38:35] <pongad> Thank you!
[00:38:38] <Eridius> wat: error: mismatched types: expected `std::option::Option<[type error]>` but found `std::option::Option<('b,'a)>` (expected type error but found tuple)
[00:38:43] <dbaupp> aatch: llvm-rs?
[00:38:49] <bjz_> hehe wut
[00:38:49] <aatch> dbaupp, yep...
[00:38:52] <pongad> :D
[00:38:55] *** Quits: koomi (koomi@moz-B2B8B6D1.superkabel.de) (Quit: WeeChat 0.4.1)
[00:38:58] *** Quits: doomlord (doomlod@moz-8F385DB0.range109-153.btcentralplus.com) (Ping timeout)
[00:39:02] <bjz_> "expected type error"
[00:39:06] <dbaupp> Eridius: there's probably another error message?
[00:39:08] <pongad> I'm trying to make a string iterator
[00:39:08] <bjz_> 8o
[00:39:13] <Eridius> dbaupp: well it's the third error in the sequence
[00:39:24] <aatch> I'm at the "boring boilerplate" stage of wrapping.
[00:39:29] <pongad> Like, calling next() gives you the next character in a string
[00:39:30] *** Quits: jensnockert (jensnocker@moz-8BE55278.customer.t3.se) (Ping timeout)
[00:39:32] <dbaupp> Eridius: yeah, Rust doesn't avoid flow on errors good enough
[00:39:35] <Eridius> dbaupp: I'm having difficulty translating vec::foldl::<Option<(U,T)>,T>() into the iterator style
[00:39:54] <dbaupp> Eridius: v.iter().fold(initial, func)
[00:40:03] *** Joins: jensnockert (jensnocker@moz-8BE55278.customer.t3.se)
[00:40:05] <bjz_> pongad: strcat is the iterator guru
[00:40:10] <pongad> My idea: make a structure, one ~str and one uint, at each next(), do get_char(i) on the string and i += 1
[00:40:10] <dbaupp> Eridius: that's a drop-in replacement
[00:40:18] <Eridius> dbaupp: I needed to qualify vec::foldl for a reason
[00:40:23] <pongad> Of course, i is immutable, so I'm kind of stuck :D
[00:40:26] <dbaupp> Eridius: 
[00:40:29] <dbaupp> Eridius: oh
[00:40:32] <bjz_> pongad: he pretty much wrote std::iterator
[00:40:42] <Eridius> dbaupp: but using fold::<T,Option<(U,T)>> doesn't work
[00:40:48] <bjz_> pongad: not that experienced with the myself though :(
[00:40:48] <Eridius> apparently it's not enough type parameters
[00:40:53] <Eridius> but IteratorUtil takes one param, and fold takes one param
[00:41:03] <dbaupp> Eridius: can you put the parameters elsewhere?
[00:41:10] <aatch> pongad, you want to use a higher-order function, so you can store your mutable state on the stack
[00:41:10] <Eridius> dbaupp: what do you mean?
[00:41:24] <dbaupp> Eridius: actually, there's the implicit Self parameter on traits
[00:41:29] <pongad> aatch, can you give an example?
[00:41:32] <dbaupp> Eridius: so there should be 3
[00:41:42] <Eridius> dbaupp: ack, I really have to qualify it with the type of the real thing it is?
[00:41:46] <dbaupp> Eridius: um, like either given `func` explicit types
[00:41:48] <aatch> pongad, look in the std::iterator library.
[00:41:50] <Eridius> but that's already known!
[00:42:01] <dbaupp> Eridius: apparently not!
[00:42:01] <pongad> aatch, ok, will do
[00:42:14] <dbaupp> pongad: it works better if you use char_range_at()
[00:42:20] <aatch> pongad, the code is also a pretty good example of decent Rust
[00:42:31] <aatch> being relatively new compared to other code.
[00:42:40] <bjz_> aatch: sans default methods :(
[00:42:46] <dbaupp> pongad: that takes a string and a byte index and extracts the uft8 character at that location
[00:42:54] <strcat> and dozens of dummy parameters to work around type inference bugs :D
[00:42:58] <aatch> bjz_, yeah, but that's not strcat's fault...
[00:43:01] <Eridius> dbaupp: oookay I gave it 3 params and that's still incorrect
[00:43:10] <bjz_> aatch: ofc :)
[00:43:17] <Eridius> dbaupp: ..huh it actually wanted just one
[00:43:18] <pongad> aatch dbaupp: I see, working on it. GitHub is being slow :D
[00:43:21] <Eridius> I thought you had to provide all params?
[00:43:25] <dbaupp> pongad: as well as the byte index of the end of the current character
[00:43:29] <Eridius> so I just needed fold;:<Option(U,T)>
[00:43:32] <Eridius> s/;/:/
[00:43:39] <dbaupp> pongad: (just btw, there is already a string char iterator)
[00:43:50] <dbaupp> Eridius: oh, right
[00:44:01] <dbaupp> Eridius: methods only take there explicit params
[00:44:04] <dbaupp> *their
[00:44:06] <Eridius> dbaupp: sure wish the error message told me what params it was expecting instead of just "incorrect number"
[00:44:10] <pongad> dbaupp: I figured, but rewriting the library is great way to learn a new language :D
[00:44:14] <dbaupp> Eridius: I thought it does :)
[00:44:24] <pongad> dbaupp, well you know what I mean
[00:44:25] <dbaupp> pongad: cool :)
[00:44:39] <bjz_> pongad: the docs are pretty horrid atm, str and vec in particular :(
[00:44:45] <bjz_> Luqman: ping
[00:45:02] <dbaupp> bjz_: it's... improving... I removed 500 lines yesterday :D
[00:45:13] <bjz_> dbaupp: yay!
[00:45:21] <bjz_> dbaupp: from str/vec?
[00:45:29] <dbaupp> pongad: also, mutability: the .next() method takes &mut self, which means that it is actually mutable
[00:45:33] <dbaupp> bjz_: yup
[00:45:49] <dbaupp> bjz_: https://github.com/mozilla/rust/pull/7015
[00:45:52] <MaikKlein> is ref only used in match?
[00:46:05] <bjz_> dbaupp: if you could remove the standalone connect/concats that would be amazing
[00:46:16] <aatch> MaikKlein, technically it can be used in any pattern
[00:46:17] <bjz_> MaikKlein: aye
[00:46:17] <dbaupp> bjz_: well, it
[00:46:28] <dbaupp> 's just some deletions
[00:46:28] <bjz_> MaikKlein: well, and destructuring
[00:46:37] <dbaupp> since they've already been migrated to the traits
[00:46:52] <dbaupp> MaikKlein: in theory it should work in let patterns
[00:47:00] <dbaupp> MaikKlein: it makes LLVM unhappy though
[00:47:02] <bjz_> let Some(ref x) = Some(1); x
[00:47:07] <bjz_> rusti: let Some(ref x) = Some(1); x
[00:47:08] -rusti- more than 5 lines of output, pastebinned: http://sprunge.us/TdIZ
[00:47:15] <dbaupp> aatch: https://github.com/mozilla/rust/pull/7018 is waiting for a re-review
[00:47:20] <bjz_> bugger
[00:47:31] <pongad> dbaupp: Oh, that makes so much sense. I was trying to do    impl mut Type {...} :D
[00:47:34] <bjz_> rusti: let (ref x, _) = (1, 2); x
[00:47:35] <Eridius> dbaupp: hah, replacing vec::foldl() with .iter().fold( results in the same number of chars!
[00:47:36] -rusti- line longer than 150 columns, pastebinned: http://sprunge.us/HUTV
[00:47:41] <MaikKlein> thanks I finally have understood what ref is good for
[00:47:48] <bjz_> haa
[00:47:49] <MaikKlein> and thanks aatach for https://gist.github.com/Aatch/5734372
[00:47:58] <MaikKlein> aatch*
[00:48:11] <dbaupp> Eridius: I noticed that too! it was mildly amusing every time I replaced it
[00:48:29] <strcat> Eridius: ideally we'll eventually have Iterable + default methods so it'll be smaller :)
[00:48:35] <strcat> xs.iter().zip(ys.iter().advance
[00:48:37] <strcat> will become
[00:48:39] <bjz_> rusti: let [ref x, .._] = [1, 2, 3]; *x
[00:48:41] -rusti- more than 5 lines of output, pastebinned: http://sprunge.us/MNZh
[00:48:41] <strcat> xs.zip(ys)
[00:48:44] <Eridius> strcat: ooh
[00:48:54] <pongad> Also, where do I find source for Module Iterator? I can't seem to find it in libstd (Git branch master)
[00:48:55] <bjz_> rusti: let (ref x, _) = (1, 2); *x
[00:48:57] -rusti- line longer than 150 columns, pastebinned: http://sprunge.us/YhhM
[00:49:03] <MaikKlein> :D
[00:49:05] <Eridius> strcat: although tbh v.zip(v2) seems like it would produce a ~[(A,B)] as a return value, instead of an Iterator
[00:49:09] <dbaupp> pongad: it's probably in libcore on that branch
[00:49:19] <dbaupp> pongad: but the most up-to-date branch is incoming
[00:49:21] <Eridius> pongad: use the incoming branch
[00:49:22] <bjz_> rusti: let tup = (1, 2); let (ref x, _) = tup; *x
[00:49:23] -rusti- line longer than 150 columns, pastebinned: http://sprunge.us/WUeW
[00:49:30] <dbaupp> pongad: that's where all the pull-requests get merged to
[00:49:43] <pongad> dbaupp Eridius, that makes sense
[00:49:55] <bjz_> pongad: incoming is stable, and barely ever goes up in flames
[00:50:13] <aatch> bjz_, yeah never more than once a week :P
[00:50:18] <bjz_> pongad: we have bors, the buildbot gatekeeper
[00:50:28] <aatch> (I keeed, I keeed)
[00:50:40] <bjz_> aatch: usually when one of the devs forces a push x)
[00:50:44] <dbaupp> strcat: next task, removing each_split from str
[00:50:50] <aatch> dbaupp, r'd
[00:51:00] <MaikKlein> why does https://gist.github.com/Aatch/5734372 print None with "level". Because it only matches strings right?
[00:51:11] <dbaupp> MaikKlein: correct
[00:51:13] <bjz_> jensnockert: any idea with those tests?
[00:51:14] *** Joins: ghrust (ghrust@AC22872E.6A2AE50.F3114085.IP)
[00:51:14] <ghrust> 01[13rust01] 15bors 04force-pushed 06auto from 14b347ed7 to 14470bf0d: 02http://git.io/N3iJvQ
[00:51:14] *** Parts: ghrust (ghrust@AC22872E.6A2AE50.F3114085.IP) ()
[00:51:14] *** Joins: ghrust (ghrust@AC22872E.6A2AE50.F3114085.IP)
[00:51:15] <ghrust> 01[13rust01] 15bors pushed 3 new commits to 06auto: 02http://git.io/bIlOBA
[00:51:15] <ghrust> 13rust/06auto 1490ec422 15Bill Myers: fix decoding of multiple attributes (fixes #7017)...
[00:51:15] <ghrust> 13rust/06auto 142d92c26 15Bill Myers: add test for RcMut being Const and Owned, tests #7017 being fixed
[00:51:15] <ghrust> 13rust/06auto 14ea59ae8 15bors: auto merge of #7018 : bill-myers/rust/fix_7017, r=Aatch...
[00:51:16] *** Parts: ghrust (ghrust@AC22872E.6A2AE50.F3114085.IP) ()
[00:51:27] <aatch> bjz_, which was especially annoying when pcwalton set it on fire while I was trying to push my regression fix.
[00:51:30] <jensnockert> bjz_: Not really, no, will need to think about it.
[00:51:33] <aatch> MaikKlein, correct
[00:51:48] <bjz_> aatch: hehe :D
[00:51:59] <pongad> Alright, that makes so much sense, thank you everyone!
[00:52:06] <aatch> I think in the end he just pushed it directly.
[00:52:31] <dbaupp> aatch: yeah, he had a few huge patches that just weren't merging
[00:52:38] *** Quits: pongad (Mibbit@moz-483DE200.hfc.comcastbusiness.net) (Quit: http://www.mibbit.com ajax IRC Client)
[00:52:59] <bjz_> poor fellow
[00:53:02] <aatch> dbaupp, yeah, but he also pushed my fix directly since it cut like 30 mins off the time.
[00:53:22] <dbaupp> aatch: oh, right, you were talking about that one.. :)
[00:53:30] <aatch> yes that one...
[00:53:50] *** Quits: snearch (snearch@moz-AA459792.pool.mediaways.net) (Quit: Verlassend)
[00:53:59] <dbaupp> aatch: should we continue to remind you of the time you made rust 3x slower?
[00:54:13] <dbaupp> :P
[00:54:13] <aatch> dbaupp, haha, I'm not bothered.
[00:54:27] <aatch> My conscience is cleared by the fact that I fixed it.
[00:55:00] <aatch> I don't care if I break something, as long I fix it.
[00:55:27] <aatch> I also added several extra features at the same time too, so that's nice.
[00:57:14] <dbaupp> and you made it faster than before
[00:57:23] <aatch> dbaupp, exactly.
[00:57:41] <aatch> a lot faster for some code, like rustray
[00:57:57] *** Quits: SiegeLord (sl@moz-CAF07B4C.hsd1.ma.comcast.net) (Quit: It's a joke. It's all a joke.)
[01:01:14] *** Joins: engla (engla@moz-DBD1D96E.cust.bredbandsbolaget.se)
[01:01:23] *** Quits: FreezerburnV (freezerbur@moz-5718C330.bltmmd.fios.verizon.net) (Quit: FreezerburnV)
[01:02:00] <MaikKlein> haha in rust reddit, &@~11 users
[01:02:08] *** Joins: SiegeLord (siege@moz-CAF07B4C.hsd1.ma.comcast.net)
[01:02:36] <MaikKlein> nice easter egg
[01:03:26] <Eridius> MaikKlein: and the mods are all ~ptrs
[01:05:06] *** Joins: koomi (koomi@moz-E8AECC1E.pools.arcor-ip.net)
[01:07:10] *** Quits: jensnockert (jensnocker@moz-8BE55278.customer.t3.se) (Ping timeout)
[01:07:38] <bjz_> MaikKlein: and illissius is now Gc<illissius>
[01:07:48] <bjz_> :D
[01:08:15] <bjz_> http://www.reddit.com/r/rust/comments/1fkhe6/removing_garbage_collection_from_the_rust_language/cabchxe
[01:08:38] <dbaupp> bjz_: a lot of people upvoted kibwen's reply to that comment ;P
[01:09:39] <bjz_> dbaupp: :P
[01:09:47] *** Joins: victorporof (victorporo@FE2F04DC.63E19875.D111398B.IP)
[01:09:54] <bjz_> dbaupp: <inspect element>
[01:09:58] <bjz_> 12 votes
[01:09:59] <bjz_> :D
[01:10:52] <dbaupp> why do only mods have CSS powers :'( I want 2^64 upvotes!
[01:11:26] <MaikKlein> btw why is it called rust? 
[01:11:53] <MaikKlein> because it's ment to be a system level language?
[01:11:55] *** Quits: victorporof (victorporo@FE2F04DC.63E19875.D111398B.IP) (Ping timeout)
[01:11:58] <MaikKlein> meant*
[01:12:11] <bjz_> MaikKlein: it rhymes with 'lust'
[01:12:19] <bjz_> MaikKlein: according to bstrie
[01:12:36] <MaikKlein> bjz_, haha
[01:13:25] <MaikKlein> or with robust
[01:13:34] <MaikKlein> trust?
[01:13:47] <aatch> I remember somebody saying that graydon named it "Rust" because it was supposed to be a language that experimented with older, abandoned, "rusty" concepts.
[01:13:49] <MaikKlein> disgust
[01:13:50] <MaikKlein> lol
[01:14:35] <dbaupp> bjz_: I can confirm that lust and Rust rhyme, bstrie is 100% correct
[01:14:43] <dbaupp> :P
[01:14:46] <MaikKlein> :d
[01:14:49] <aatch> because Rust actually doesn't push the boundaries of language design and implementation. It just actually bothers to look at more than C++ and go "we can do better!"
[01:15:01] * aatch glares at D
[01:15:03] <dbaupp> yaaay traits!
[01:15:20] <dbaupp> yay borrowed pointers and lifetimes
[01:15:30] <bjz_> dbaupp: traits (haskell, scala)
[01:16:01] <bjz_> dbaupp: lifetimes are a little less tried and true though
[01:16:10] <bjz_> dbaupp: ATS maybe, and cyclone I think
[01:16:11] <aatch> I mean, from what I can tell Rust is the first to use them in an industry-targeted language, instead of a research language.
[01:16:21] <bjz_> aatch: aye
[01:16:24] <dbaupp> but it's clearly a good idea
[01:16:47] <aatch> bjz_, the formalization in Rust isn't common, but region-based analysis is pretty solid.
[01:17:21] <aatch> the concurrency is mostly inspired by Cilk I think.
[01:17:42] <bjz_> aatch: I'm concerned about the fact that the liftimes and type inference aren't mathemtically formalised though (although I might be wrong)
[01:18:01] <dbaupp> bjz_: apparently we use HM
[01:18:07] <dbaupp> bjz_: which is pretty formalised
[01:18:14] <dbaupp> not sure about lifetimes
[01:18:16] <bjz_> dbaupp: oh really
[01:18:34] <dbaupp> bjz_: bstrie was saying this yesterday/the day before
[01:18:37] <bjz_> dbaupp: I think nmatsakis was working on formalising lifetimes
[01:18:45] <aatch> bjz_, region inference is pretty much the same as type inference
[01:18:55] <bjz_> dbaupp: and he actually found some bugs in the initial stages
[01:19:00] <bjz_> aatch: oh cool
[01:19:20] <dbaupp> "This is loosely based on standard HM-type inference, but with an extension to try and accommodate subtyping ..."
[01:19:31] <dbaupp> from middle/typeck/infer/mod.rs
[01:19:54] <bjz_> dbaupp: the 'loose' but is what worries me. but I'm not a type theorist
[01:20:02] <dbaupp> bjz_: oh, really? and fixed them, I hope
[01:20:09] <bjz_> dbaupp: the devs seem to know what they're doing
[01:20:19] <aatch> bjz_, loose is a modifier for "based"
[01:20:20] <MaikKlein> i wonder if you can form a proper a sentence with only words that rhymes with rust.... 
[01:20:27] <MaikKlein> rust must just 
[01:20:40] <dbaupp> lust must rust?
[01:20:42] <bjz_> aatch: ahh if you look at it that way, yes
[01:20:50] <aatch> MaikKlein, must rust just lust?
[01:21:03] <MaikKlein> haha
[01:21:17] <dbaupp> Fussed rust must lust
[01:21:22] <bjz_> must trust rust
[01:21:26] <MaikKlein> !
[01:21:33] <aatch> bjz_, since I think standard HM assumes that you can see the entire program to gather your constraints.
[01:21:36] <MaikKlein> this needs to be a slogan
[01:21:38] <MaikKlein> for rust
[01:21:58] <aatch> dbaupp, nice rhyme
[01:22:03] <dbaupp> MaikKlein: we'll turn into a cult, with a slogan like that!
[01:22:11] <dbaupp> MaikKlein: not that that's a bad thing
[01:22:25] <xenocons> if the worst happens in rust, say a nasty bug that appears at runtime, what safety measures are in place to insure that it isnt devistating? (thinking aslr, dep,nx stack)
[01:22:32] * aatch mutters "must trust rust... must trust rust... must trust rust... must trust rust..."
[01:22:36] <xenocons> does this get provided by llvm
[01:22:47] <MaikKlein> :p
[01:22:49] <dbaupp> xenocons: there is a stack redzone
[01:22:54] <aatch> xenocons, there are stack protectors
[01:22:59] <aatch> dbaupp, redzone is different...
[01:23:03] <xenocons> so canaries?
[01:23:07] <aatch> xenocons, yes
[01:23:07] <dbaupp> aatch: oh, ok
[01:23:07] <strcat> xenocons: not rust's responsibility, those are OS things
[01:23:21] <strcat> xenocons: rust doesn't use an executable stack/heap
[01:23:25] <xenocons> i.e. a cookie placed on the stack, when part is overwritten it will be known
[01:23:27] <xenocons> ok
[01:23:30] <strcat> only read-only data is executable
[01:23:38] <xenocons> cool
[01:23:41] * strcat fixed that ;p
[01:23:47] <strcat> our asm was bad before
[01:23:52] <strcat> made the stack executable
[01:23:57] <xenocons> heh
[01:24:03] <aatch> redzone is a reserved space on the stack. I can't remember exactly what it's purpose is
[01:24:05] <dbaupp> it's annoying that #[deny(missing_doc)] only appears in stage1 :/
[01:24:32] <aatch> dbaupp, get incoming-full green and we can snapshot
[01:24:43] <aatch> we could probably do with one soon anyway.
[01:24:49] <dbaupp> aatch: but red is my favour colour :(
[01:24:52] <strcat> which means fix jemalloc's build
[01:24:52] *** Joins: doomlord (doomlod@moz-8F385DB0.range109-153.btcentralplus.com)
[01:24:55] <dbaupp> *ite
[01:24:56] <strcat> cross-compile
[01:25:04] <strcat> it needs the page size shift hardcoded
[01:25:14] <strcat> it tries to run a test program but it bails out because that doesn't make sense when cross-compiling
[01:25:30] <xenocons> im really confused about the boundary between rustc and llvm , e.g. what does rust do in compilation and what does llvm do
[01:25:42] <strcat> rust outputs LLVM IR
[01:25:43] <strcat> that's all
[01:25:51] <dbaupp> strcat: should I bother with optimising string split for the case when splitting on an ascii character?
[01:25:56] <xenocons> right ok
[01:26:01] <strcat> dbaupp: dunno
[01:26:01] <dbaupp> strcat: is seems like a good idea?
[01:26:10] <dbaupp> since \n and ' ' are ascii
[01:26:22] <strcat> dbaupp: it's unlikely that our string splitting is correct
[01:26:31] <dbaupp> strcat: it seems to be
[01:26:33] <strcat> you can't split a string on an arbitrary byte or code point
[01:26:41] <dbaupp> strcat: i.e. it uses utf8?
[01:26:51] <strcat> glyph combining-char combining-char combining-char glyph
[01:26:59] <strcat> if you split on index 2, you've created 2 invalid strings
[01:27:04] <aatch> xenocons, LLVM is the compiler back-end. it provides an IR, methods to manipulate that IR, optimization facilities and native code generation.
[01:27:05] <strcat> our strings are all wrong
[01:27:27] <dbaupp> strcat: oh, I'm talking about splitting with a character? i.e. "a b" split ' ' => "a" "b"
[01:27:33] <strcat> dbaupp: anyway I wouldn't really worry about that but just keep in mind that the entire string implementation will have to be thrown out ;p
[01:27:36] <aatch> It also has a JIT execution engine, which rusti (the program) uses.
[01:27:44] <dbaupp> strcat: so it's the users fault if they put a combining-char through the splitter
[01:27:55] <strcat> dbaupp: ah
[01:28:01] <strcat> dbaupp: I guess that makes sense, it could eventually assert
[01:28:06] <xenocons> aatch: right, but rust has to be conscious of the llvm ir format, for example some llvm ir will be optimized differently 
[01:28:11] <xenocons> not sure what point im making
[01:28:20] <aatch> xenocons, not really. LLVM handles all of that too.
[01:28:28] <xenocons> ok cool
[01:28:34] <aatch> It provides an IR builder.
[01:28:54] <aatch> I mean, rust has to be aware of the various features, but not the format itself.
[01:29:03] <xenocons> cool ok
[01:29:06] <strcat> the IR is just a human-readable format of the bytecode
[01:29:13] <strcat> rust doesn't actually deal with IR or the bytecode
[01:29:18] <Ralith> bitcode*
[01:29:41] <aatch> which is nice because for the in-memory and bitcode representations they are firmly "this can and will change between versions, possibly dramatically"
[01:29:55] <xenocons> whats libsyntax like, less scarey than librustc/middle?
[01:30:10] <aatch> hell "in memory" is a bit misleading since it's actually all just C++ objects.
[01:30:14] <MaikKlein> rustc middle is totally scary
[01:30:16] <MaikKlein> atleast for me
[01:30:18] <MaikKlein> :D
[01:30:29] <xenocons> MaikKlein: yeh ive been warned away for now
[01:30:30] <aatch> xenocons, a bit less scary
[01:30:34] <xenocons> i know i will pickup bad things from middle
[01:30:46] <dbaupp> xenocons: don't look in syntax/parse
[01:30:52] <xenocons> heh
[01:30:55] <aatch> the libs are a good place to start though.
[01:30:58] <MaikKlein> I saw a function that was using 30 @ 
[01:30:59] <xenocons> but parsing is the most juicy part
[01:31:02] <MaikKlein> or so
[01:31:17] <dbaupp> xenocons: parts of ext are probably the nicest part of syntax
[01:31:23] <aatch> xenocons, the parser is over 4000 lines of hand-written, old-style rust.
[01:31:27] <dbaupp> xenocons: but it's all a bit strange there
[01:31:38] * xenocons froths at the mouth 4k line parser
[01:32:07] <aatch> xenocons, exactly.
[01:32:09] <MaikKlein> will rustc get a complete rewrite some day?
[01:32:19] <aatch> MaikKlein, probably not.
[01:32:23] <MaikKlein> okay nice
[01:32:26] <dbaupp> MaikKlein: progressively, I guess
[01:32:32] <aatch> well, depends on how you think of it.
[01:32:37] <MaikKlein> because I want to add auto completion some day
[01:33:27] <aatch> "I've had the same broom for 12 years" "How'd you manage that" "well it's had 7 new heads and 9 new handles" "..."
[01:33:36] <xenocons> since im on a roll this morning i have a potentially controlversial question\statement... given that i mostly 'brutefoce' ownership and pointers in rustc, would it be insane to introduce a default pointer system that is plain old GC + scope lifetimes for people just getting into the language, so t hat the requirement to learn about ownership is offset?
[01:34:23] <aatch> xenocons, uh, yes.
[01:34:29] <strcat> xenocons: ownership is key to semantics
[01:34:39] <xenocons> yeah
[01:34:41] <strcat> xenocons: if you give up ownership you give up pretty much every advantage of rust...
[01:34:43] <MaikKlein> never heard the word broom before
[01:34:43] <aatch> the concept of ownership is pretty central
[01:34:49] *** Joins: a__ (a__@moz-250D9B4.nycmny.fios.verizon.net)
[01:34:52] <strcat> xenocons: no ownership == no static mutability
[01:35:00] <xenocons> right
[01:35:01] <strcat> iterator invalidation exists with @mut
[01:35:11] *** Quits: MrFahrenheit (RageOfThou@3FEF494C.29C984D5.783DEDCA.IP) (Ping timeout)
[01:35:42] <xenocons> so ive been writing rust for a few days now, and im not getting the concepts of ownership at the intuitive level, i guess my best bet is to just wait f or osmosis to kick in and just keep coding it
[01:36:04] <aatch> xenocons, it'll click eventually
[01:36:13] <MaikKlein> when did you start with programming?
[01:36:15] <xenocons> im kinda like 'oh that didnt work, ill change the pointer and try again' heh
[01:36:29] <xenocons> MaikKlein: i guess 3 years ago>
[01:36:33] <xenocons> ago*
[01:37:00] <xenocons> when was i actually able to write code? (like 3 or 4 years ago i think)
[01:37:18] <xenocons> when did i start looking at rust... about 4 months ago? when did i actually write some working rust... last few days ;p
[01:37:52] <MaikKlein> haha
[01:37:55] <xenocons> fortunately in rust if your pointer is wrong it just doesnt compile, instead of C where you will blow up the universe
[01:38:23] <strcat> xenocons: except if you're using @mut/RcMut, then you get runtime failures ;p
[01:38:34] <xenocons> oh :(
[01:38:46] <xenocons> well, ill try not to use mut as much as possible
[01:38:50] <strcat> xenocons: mut is fine
[01:38:59] <strcat> xenocons: lack of ownership + mutability == runtime failures
[01:39:22] <xenocons> well for me i find i have better ease with non mutable data (i come from mostly immutable default languages)
[01:39:58] <xenocons> nothing gives me more fear than 'a -> unit BUT SOMETHING HAPPENED
[01:40:47] <xenocons> mutability is like hearing something bump in your house at night, needing to get out of bed and turn on the lights and think 'wtf just happened'
[01:40:48] <steven_is_false> Okay now that I stare at it the code in rust_task.cpp is looking kind of mistaken.
[01:41:14] <MaikKlein> I am programming since 2 years now I guess
[01:41:21] <MaikKlein> so pretty inexperienced
[01:41:39] <xenocons> anyway, this leads to another question: does writing purely immutable code cause a runtime cost over mutation
[01:41:48] <xenocons> MaikKlein: cool, a newbie like me
[01:41:50] <steven_is_false> In rust_task::new_big_stack stk->next is used but later on there's a check to see if stck is NULL. I don't get it.
[01:42:11] <dbaupp> xenocons: yes, if it forces you to copy more
[01:42:23] <strcat> or if it forces you to use less efficient algorithms in general
[01:42:26] <dbaupp> xenocons: which it probably does
[01:42:36] <aatch> xenocons, in general, yes.
[01:42:46] <strcat> or if it means you're using @, which is inefficient (in memory and time)
[01:42:47] <xenocons> right, i expect this i guess
[01:43:22] <xenocons> strcat: what about different allocation boundaries for different pointers, e.g. ~ on the heap, does this have a 'block' size of memory at which it allocates or something
[01:43:33] <aatch> rust does work hard to let you have your cake and eat it too, but you have to conceed a few slices here and there.
[01:43:36] <xenocons> allocating lots of small objects on heap is costly etc
[01:43:42] <xenocons> aatch: hah
[01:43:50] <strcat> xenocons: allocating small objects with ~ is cheap
[01:43:52] <strcat> xenocons: http://www.canonware.com/download/jemalloc/jemalloc-latest/doc/jemalloc.html
[01:44:14] <strcat> (the Implementation notes section)
[01:44:20] <strcat> there's a table with the sizes it rounds up to
[01:44:24] <xenocons> ok, so ~ + small = cheap, & + small = ? (is & on the stack?)
[01:44:27] <xenocons> cool
[01:44:35] <xenocons> ill read this
[01:44:36] <strcat> xenocons: & is a pointer to existing memory
[01:44:41] <strcat> xenocons: doesn't matter where
[01:44:45] <xenocons> ah
[01:44:56] <xenocons> if we wanted to keep stuff on the stack, which pointer type is that?
[01:45:02] <aatch> xenocons, btw, if you haven't seen it: https://gist.github.com/Aatch/5734372 (shameless self-plug)
[01:45:09] <strcat> xenocons: no pointer
[01:45:12] <aatch> xenocons, no pointer type, just stack-allocate.
[01:45:15] <strcat> xenocons: by default, you shouldn't use pointers
[01:45:25] <xenocons> aatch: cool, nice, i will read this too
[01:45:27] <aatch> you can take the address with &
[01:45:34] <xenocons> right, like in C
[01:45:36] <strcat> 90% of code should be stack allocation and &
[01:45:45] <strcat> ~ outside of data structure implementations is code smell
[01:46:04] <xenocons> so & in a parameter means you are passing by-value a pointer to some allocated memory
[01:46:12] <strcat> xenocons: yes
[01:46:20] <strcat> xenocons: and ~ by-value is the same
[01:46:27] <strcat> xenocons: it "moves" ownership (as in just copies the ptr)
[01:46:28] <dbaupp> strcat: even for huge types to avoid big memcpy's?
[01:46:43] <strcat> dbaupp: you shouldn't have huge types :)
[01:46:59] <strcat> stack allocated arrays should only be passed deeper into the call stack
[01:47:03] <strcat> usually
[01:47:15] <aatch> at any rate, it's more of a rule-of-thumb
[01:47:24] <strcat> you want the allocations as high in the call stack as possible
[01:47:35] <strcat> APIs should avoid inherent allocation and let the caller decide
[01:47:41] *** Quits: a__ (a__@moz-250D9B4.nycmny.fios.verizon.net) (Ping timeout)
[01:47:41] <xenocons> is there a 'register' pointer in rust ;)
[01:47:47] <aatch> xenocons, no
[01:48:02] <strcat> 'register' in C is a useless obsolete keyword
[01:48:03] <aatch> nobody has used register pointers in years.
[01:48:06] <xenocons> aatch: but aatch, how will we get the women?
[01:48:22] <strcat> all it does in C is prevent taking an address of that variable
[01:48:22] <xenocons> yeah, ive seen it only a few times
[01:48:27] <strcat> it has nothing to do with registers anymore
[01:48:35] <strcat> the compiler doesn't even treat it as a hint
[01:48:38] <strcat> it discards it immediately
[01:48:42] <xenocons> i was team coding with some C guy who uses it
[01:48:53] <aatch> compiler register-allocators are far, far better at doing it than you.
[01:49:02] <strcat> the *only* thing it does is prevent you taking an address (but the compiler knows that 100% of the time)
[01:49:07] <xenocons> he says that certain things will end up in registers anyway, so providing the hint will just help the compiler or something
[01:49:13] <strcat> xenocons: it's not a hint
[01:49:15] <strcat> it's ignored
[01:49:23] <strcat> neither gcc or clang does anything with it
[01:49:26] <xenocons> hmm
[01:49:34] <strcat> they can discard it after type checking
[01:49:37] <aatch> xenocons, there are very few things you should ever need to hint to a modern compiler.
[01:49:45] *** Quits: erickt (Adium@49C4075F.3AC15C18.2321E71E.IP) (Quit: Leaving.)
[01:49:48] <xenocons> aatch: right
[01:49:52] <strcat> aatch: aliasing :), if the language isn't high level
[01:50:08] <aatch> I think "inline" is one, but that actually changes some semantics
[01:50:10] *** Joins: a__ (a__@moz-250D9B4.nycmny.fios.verizon.net)
[01:50:17] <aatch> s/think//
[01:50:19] *** Joins: lmandel (lmandel@FE1F74.86ED00A7.971E19F6.IP)
[01:50:30] <strcat> aatch: 'inline' in C++ essentially only has to exist because it *allows* you to put code in headers so it can be inlined
[01:50:55] <MaikKlein> rusti: let a = 5; fn test(i: &int){}; test(&a)
[01:50:57] <aatch> strcat, exactly. and in Rust it allows for cross-crate inlining.
[01:50:58] -rusti- ()
[01:51:04] <MaikKlein> rusti: let a = 5; fn test(i: &int){}; test(a)
[01:51:06] -rusti- more than 5 lines of output, pastebinned: http://sprunge.us/OOGF
[01:51:27] <MaikKlein> don't you think it would make more sense it i could just write test(a) ?
[01:51:36] <MaikKlein> if*
[01:51:39] <aatch> rusti: fn test(i: &int) -> int { *i } test(&10)
[01:51:40] -rusti- 10
[01:51:51] <dbaupp> MaikKlein: too implicit
[01:51:54] <aatch> MaikKlein, not really.
[01:52:25] <steven_is_false> How does one put small phrases like "stk" in code blocks in GitHub Markdown?
[01:52:34] <dbaupp> MaikKlein: it's not obvious to the programmer what's going to happen by looking at 'test(a)' (i.e. "does it copy?")
[01:52:38] <dbaupp> steven_is_false: `stk`
[01:52:43] <aatch> steven_is_false, `stk`
[01:52:44] <strcat> `stk` is inline
[01:52:44] <MaikKlein> true
[01:52:45] <steven_is_false> dbaupp: Thanks.
[01:52:49] <strcat> if you want a block you can indent it by 4
[01:52:52] <strcat> if you want a code block
[01:52:55] <strcat> ```rust
[01:52:57] <strcat> let a = 5
[01:52:59] <strcat> ```
[01:53:10] <dbaupp> MaikKlein: and I'm sure someone could conjure up an example of traits and implicit addr-of making code ambiguous
[01:53:14] <aatch> I like that GitHub has LLVM highlighting.
[01:53:15] <xenocons> aatch: so map.find_equiv takes a **key ?
[01:53:47] <aatch> xenocons, no, it takes &U, where U:Equiv<U,T>
[01:53:57] <dbaupp> MaikKlein: actually it's easy: trait Foo {} impl Foo for int {} impl Foo for &int {} fn foo<F: Foo>(i: F) {} let a = 1; foo(a)
[01:54:01] <xenocons> hrm
[01:54:13] <dbaupp> MaikKlein: "which instance of Foo does that use?"
[01:54:14] <aatch> so it takes a pointer to a type that is equivalent to the type of the key.
[01:54:29] <MaikKlein> dbaupp, the first one
[01:54:34] <MaikKlein> for int
[01:54:46] <MaikKlein> well
[01:54:46] <MaikKlein> okay
[01:54:47] <xenocons> but isnt fn f(x:&str) { ... &x ...  going to be poi(poi(x))
[01:54:48] <MaikKlein> yeah
[01:54:58] <MaikKlein> it makes more sense
[01:54:58] *** Quits: koomi (koomi@moz-E8AECC1E.pools.arcor-ip.net) (Ping timeout)
[01:55:03] <aatch> xenocons, it is, correct
[01:55:09] <xenocons> ok
[01:55:21] <xenocons> this makes sense then i think
[01:55:25] <strcat> xenocons: the maps don't actually do any internal copies or use @
[01:55:27] <aatch> it's a limitation with unsized types at the moment.
[01:55:36] <strcat> xenocons: everything they need is exposed in the function signatures
[01:55:56] <strcat> if they don't need ownership they take it by reference, if they do, they take it by-value
[01:56:01] <MaikKlein> rusti: Test(Test1); Test1(int); let a = Test(Test1(1)); **a
[01:56:02] -rusti- more than 5 lines of output, pastebinned: http://sprunge.us/RJWX
[01:56:03] <xenocons> good that map (as in the structure) doesnt use @ as you said before its inefficient? hehe
[01:56:35] <strcat> xenocons: it used to use @
[01:56:39] <aatch> since the key is T, and a string is ~str, the signature &T is &~str.
[01:56:50] <strcat> xenocons: replacing the @ made it 35-40% faster.
[01:56:54] <MaikKlein> rusti: Test1(int); Test(Test1);  let a = Test(Test1(1)); **a
[01:56:55] -rusti- more than 5 lines of output, pastebinned: http://sprunge.us/UiSC
[01:57:08] <MaikKlein> oh I am so stupid
[01:57:35] <xenocons> wow nice
[01:57:55] <aatch> there are proposals to make it more unified though. So you would be able to parameterize something over str or [T]
[01:58:13] <dbaupp> aatch: you've got another typo ;P http://www.reddit.com/r/rust/comments/1fx1vl/an_example_of_using_lifetimes_and_regions/caf0hwm
[01:58:15] <strcat> dbaupp: getting rid of vec::len and vec::is_empty
[01:58:38] <strcat> should really clear out all this cruft ;p
[01:58:44] <dbaupp> strcat: the functions rather than the methods?
[01:59:07] <MaikKlein> rusti: struct Test1(int);struct Test(Test1);  let a = Test(Test1(1)); **a
[01:59:08] -rusti- 1
[01:59:14] <strcat> dbaupp: yeah
[01:59:22] <steven_is_false> How can I add a reference to specific lines of code in GitHub? I should really do that instead of including it inline in https://github.com/mozilla/rust/issues/7022
[01:59:49] <dbaupp> steven_is_false: you can put #L<linenumber> at the end of the code url
[01:59:59] <steven_is_false> dbaupp: Thanks!
[02:00:04] <dbaupp> steven_is_false: (clicking on the line number itself actually does this for you)
[02:00:12] <dbaupp> strcat: :)
[02:00:29] <MaikKlein> gn8 all
[02:00:55] <aatch> dbaupp, thanks, fixed it.
[02:01:14] * aatch is more surprised at the _lack_ of mistakes.
[02:02:32] *** Quits: MaikKlein (maik@moz-B464C230.dip0.t-ipconnect.de) (Ping timeout)
[02:03:16] <dbaupp> steven_is_false: you're sstewartgallus on GH right?
[02:05:17] *** Joins: erickt (Adium@49C4075F.3AC15C18.2321E71E.IP)
[02:05:41] <steven_is_false> dbaupp: Yep.
[02:07:28] <xenocons> hmm
[02:07:47] <xenocons> just looking at my_file_read that i wrote, it takes &Path, but it just does path.to_str() anyway
[02:07:58] <aatch> xenocons, autderef
[02:08:01] <xenocons> i guess its more efficient just passing in ~str?
[02:08:06] <aatch> autoderef*
[02:08:10] <strcat> xenocons: &str
[02:08:14] <xenocons> ah
[02:08:34] <strcat> xenocons: you shouldn't take types with destructors by-value unless you need your own copy of them
[02:08:34] <dbaupp> steven_is_false: oh, cool... just wondering, were/are you going to try to merge your dl wrapper back into libstd?
[02:08:43] <dbaupp> steven_is_false: (the one you mention here: https://github.com/mozilla/rust/pull/6735#issuecomment-18457104)
[02:08:44] <strcat> and you should take parameters by-value instead of copying internally
[02:08:54] <xenocons> strcat: right, that does make sense
[02:09:16] <aatch> the idea being "don't hide allocations"
[02:09:40] <xenocons> it compiles!
[02:09:57] <xenocons> now i can do fn readFileBytes (path: &str) -> ~[u8] { return my_file_reader(path).get().read_whole_stream(); }
[02:10:11] <strcat> xenocons: so basically, sometimes you *do* need a copy
[02:10:11] <steven_is_false> dbaupp: I don't understand what you mean really.
[02:10:14] *** Joins: victorporof (victorporo@FE2F04DC.63E19875.D111398B.IP)
[02:10:23] <strcat> by putting it in the signature, if the caller has a copy they don't need to keep around they can move
[02:10:25] <strcat> instead of copying
[02:10:33] <xenocons> ah
[02:10:41] <dbaupp> steven_is_false: i.e. currently there is no way to use dlopen and dlsym in Rust
[02:10:48] <dbaupp> steven_is_false: and you've written a wrapper for it
[02:11:49] <xenocons> so with vector implementation... does the size of the vector get kept in its head in memory or something?
[02:11:56] <steven_is_false> dbaupp: I was hoping that huonw 's work would get merged into std, or extra
[02:12:05] <xenocons> (obviously transparent to the rust coder)
[02:12:05] <dbaupp> steven_is_false: that's me ;)
[02:12:19] *** Quits: victorporof (victorporo@FE2F04DC.63E19875.D111398B.IP) (Ping timeout)
[02:12:20] <strcat> xenocons: yes, it's [len|capacity|data]
[02:12:35] <dbaupp> steven_is_false: but I think yours is better in many ways
[02:12:36] <xenocons> ok cool, so finding .len() of a vec is O(1)
[02:12:45] <aatch> xenocons, yep.
[02:12:47] <strcat> xenocons: yes and appending is O(1) amortized
[02:12:51] <xenocons> sweet
[02:13:10] <strcat> xenocons: popping from the end with a type without a destructor is just len -= 1
[02:13:31] <strcat> std::deque makes it the same but for both ends
[02:13:35] <steven_is_false> dbaupp: One slight problem is that it might be better to have a more platform agnostic version of it.
[02:13:38] <strcat> extra::deque * 
[02:13:39] *** Joins: acrichto (acrichto@moz-B63D64BD.res.cmu.edu)
[02:13:50] <dbaupp> steven_is_false: yours?
[02:13:54] <engla> extra::deque is so simple maybe it can be in std
[02:14:15] <steven_is_false> dbaupp: Okay, what is wanted is DynamicLibrary facilities in general.
[02:14:27] <dbaupp> steven_is_false: you can just crib from my code if you feel like it :) (but I don't actually know if it works on any platform other than windows)
[02:14:28] <xenocons> strcat: nice
[02:14:30] <xenocons> ok brb
[02:14:40] <dbaupp> steven_is_false: yup
[02:14:56] <steven_is_false> dbaupp: Right, I'll probable be able to figure it out from your code.
[02:15:09] <dbaupp> *other than linux, sorry
[02:15:34] <steven_is_false> dbaupp: I guess the facilities should go in libstd
[02:15:43] <dbaupp> I have literally no idea if it works on windows
[02:15:50] <steven_is_false> dbaupp: Oh...
[02:15:53] <dbaupp> steven_is_false: yeah, probably in libstd/unstable for now
[02:16:25] *** Quits: lmandel (lmandel@FE1F74.86ED00A7.971E19F6.IP) (Quit: lmandel)
[02:16:29] <dbaupp> steven_is_false: but in theory it does, 'cause I was copying off some tutorial about dynamic libs in windows
[02:18:15] <steven_is_false> dbaupp: Okay, I'll reexamine your version, and than submit my version of dynamic_lib.rs as a pull request.
[02:18:15] *** Joins: ghrust (ghrust@DE823A67.6A2AE50.F3114085.IP)
[02:18:15] <ghrust> 01[13rust01] 15bors 04force-pushed 06auto from 14ea59ae8 to 14470bf0d: 02http://git.io/N3iJvQ
[02:18:15] *** Parts: ghrust (ghrust@DE823A67.6A2AE50.F3114085.IP) ()
[02:18:17] *** Joins: ghrust (ghrust@AD60B2E3.6A2AE50.F3114085.IP)
[02:18:17] <ghrust> 01[13rust01] 15bors pushed 3 new commits to 06auto: 02http://git.io/auCLgw
[02:18:17] <ghrust> 13rust/06auto 1490ec422 15Bill Myers: fix decoding of multiple attributes (fixes #7017)...
[02:18:17] <ghrust> 13rust/06auto 1454ec7ab 15Bill Myers: add test for RcMut being Const and Owned, tests #7017 being fixed
[02:18:17] <ghrust> 13rust/06auto 141f0c05f 15bors: auto merge of #7018 : bill-myers/rust/fix_7017, r=thestinger...
[02:18:19] *** Parts: ghrust (ghrust@AD60B2E3.6A2AE50.F3114085.IP) ()
[02:18:29] <dbaupp> steven_is_false: looking forward to it! :)
[02:22:10] *** Joins: infynyxx (infynyxx@moz-E95B370B.nyc.res.rr.com)
[02:23:32] <steven_is_false> dbaupp: About the fragile link library name problem. Can't we get a dynamic library object representing the existing state of the binary, and get access to symbols we know are already linked in to test it?
[02:26:51] *** Quits: SiegeLord (siege@moz-CAF07B4C.hsd1.ma.comcast.net) (Connection reset by peer)
[02:26:55] <dbaupp> steven_is_false: not sure
[02:27:06] <steven_is_false> dbaupp: I'll test it out and try it.
[02:27:07] <dbaupp> steven_is_false: (I haven't used dlopen much at all)
[02:27:18] *** Quits: Earnestly (earnest@6A917A59.5E1FD793.39C00A7A.IP) (Ping timeout)
[02:27:51] *** Quits: kimundi (kimundi@moz-DAF39C0A.dip0.t-ipconnect.de) (Ping timeout)
[02:28:08] <steven_is_false> dbaupp: Fair enough.
[02:30:46] *** Joins: kimundi (kimundi@moz-D1D1BED9.dip0.t-ipconnect.de)
[02:30:50] *** Joins: SiegeLord (sl@moz-CAF07B4C.hsd1.ma.comcast.net)
[02:31:27] <steven_is_false> Hi! Do we have a cfg(posix) flag or something in the compiler?
[02:32:10] *** kimundi is now known as zz_kimundi
[02:32:16] <aatch> steven_is_false, maybe not posix, but there is a way for linux and unix
[02:32:21] *** Joins: sankha93 (Instantbir@BFECE1D6.6ABDE3A6.8B6C1D65.IP)
[02:32:59] <steven_is_false> aatch: It's just it's bad practis to special case on #[cg(target_os = ...
[02:33:39] <aatch> I dunno then.
[02:34:01] <steven_is_false> Fair enough.
[02:40:17] *** Joins: mib_3d2d1o (Mibbit@moz-BF63AEBC.dsl.teksavvy.com)
[02:40:36] *** Quits: mib_3d2d1o (Mibbit@moz-BF63AEBC.dsl.teksavvy.com) (Quit: http://www.mibbit.com ajax IRC Client)
[02:44:25] *** zz_kimundi is now known as kimundi
[02:45:03] *** Quits: q66 (q66@6EE9DE40.46454B5D.33AABD5F.IP) (Client exited)
[02:48:44] <strcat> aatch: removing the useless first parameter we put on every single function would be good ;p
[02:49:01] <aatch> strcat, I know.
[02:49:09] * strcat wonders how much that hurts
[02:49:44] <strcat> it definitely becomes part of the ABI
[02:49:58] <aatch> Hmm, probably a fair amount.
[02:50:21] <aatch> since we still have to generate code for the argument, even if LLVM mostly optimizes it out.
[02:50:33] <strcat> aatch: can't optimize it out unless it inlines
[02:50:43] <strcat> or at least unless it's an internal function
[02:50:54] <aatch> I mean it optimizes out the alloca, bitcast, etc.
[02:51:06] <aatch> so the function is just passed an undef
[02:51:20] <strcat> aatch: wastes a register
[02:51:32] <strcat> for calls
[02:51:38] <aatch> true, that probably has an impact
[02:52:10] * strcat has that right up there with the ~ unused headers as potentially the worst perf issue
[02:52:10] <aatch> and it affect the potential optimizations inside the function too.
[02:52:59] <strcat> aatch: I bet we can easily get rid of it at least
[02:53:03] <strcat> doesn't seem to be used at *all*
[02:53:26] <aatch> strcat, it does get used, it's the return parameter.
[02:53:34] <strcat> aatch: urgh
[02:53:43] <aatch> but it's unused if the function has an immediate return type.
[02:54:30] <aatch> it's also used, I think, for closures. To pass the environment.
[02:54:39] <aatch> and methods for the self type.
[02:54:52] <aatch> I'm not sure on the last two though.
[02:54:55] <aatch> I'd have to check.
[02:59:55] *** Joins: thou (thou@moz-1C1CA9F7.fasttrackcomm.net)
[03:01:24] *** Quits: int3_ (int3_@moz-ABE52D50.hsd1.ca.comcast.net) (Client exited)
[03:01:48] *** Joins: alisdair (textual@moz-EBE9F394.bchsia.telus.net)
[03:01:50] *** Quits: alisdair (textual@moz-EBE9F394.bchsia.telus.net) (Client exited)
[03:06:22] <mark_edward> are function pointers to named functions passable to C functions taking callbacks?
[03:06:39] <aatch> mark_edward, I think so.
[03:06:46] <steven_is_false> mark_edward: I think they have to be extern "C" functions
[03:06:59] <mark_edward> does that limit what features they can use?
[03:07:01] *** Joins: int3_ (int3_@moz-ABE52D50.hsd1.ca.comcast.net)
[03:07:14] <steven_is_false> mark_edward: I don't believe so.
[03:07:18] <aatch> mark_edward, they can't be called directly from Rust code.
[03:07:23] <mark_edward> ok cool, thanks guys
[03:07:29] *** Quits: int3_ (int3_@moz-ABE52D50.hsd1.ca.comcast.net) (Client exited)
[03:08:16] *** Joins: int3_ (int3_@moz-ABE52D50.hsd1.ca.comcast.net)
[03:08:40] *** Quits: int3_ (int3_@moz-ABE52D50.hsd1.ca.comcast.net) (Client exited)
[03:09:12] *** Joins: ghrust (ghrust@5FEF1C87.6A2AE50.F3114085.IP)
[03:09:12] <ghrust> 01[13rust01] 15bors merged 06auto into 06incoming: 02http://git.io/auCLgw
[03:09:12] *** Parts: ghrust (ghrust@5FEF1C87.6A2AE50.F3114085.IP) ()
[03:09:35] *** Joins: magg (magg@630352A8.CD20F79C.3D0AE249.IP)
[03:10:46] *** Joins: victorporof (victorporo@FE2F04DC.63E19875.D111398B.IP)
[03:11:35] *** Quits: paulproteus (quassel@rose.makesad.us) (Ping timeout)
[03:11:58] *** Quits: moonchrome (moonchrome@moz-A3A6B427.dsl.iskon.hr) (Input/output error)
[03:11:59] <magg> hello
[03:12:31] <magg> I'm pretty new to rust, how do i declare byte vector?
[03:12:32] <strcat> hi
[03:12:49] <strcat> magg: let xs = [5u8, 2, 3, 4];
[03:12:51] *** Quits: victorporof (victorporo@FE2F04DC.63E19875.D111398B.IP) (Ping timeout)
[03:13:03] <strcat> or let xs = bytes!("foo");
[03:13:08] <engla> magg: u8 is the byte type
[03:13:28] <aatch> rusti: let xs = ~[5u8, 2, 3, 4]; xs
[03:13:33] -rusti- ~[5, 2, 3, 4]
[03:14:01] <aatch> rusti: let xs = [5u8, 2, 3, 4]; sys::size_of_val(xs)
[03:14:03] -rusti- more than 5 lines of output, pastebinned: http://sprunge.us/jhGE
[03:14:09] <aatch> rusti: let xs = [5u8, 2, 3, 4]; std::sys::size_of_val(xs)
[03:14:11] -rusti- more than 5 lines of output, pastebinned: http://sprunge.us/hfcQ
[03:14:14] *** Joins: paulproteus (quassel@moz-E86A3B42.makesad.us)
[03:14:25] <aatch> rusti: let xs = [5u8, 2, 3, 4]; std::sys::size_of_val(&xs)
[03:14:26] -rusti- 4
[03:14:31] <magg> OOh i see, can i initialize it with a fixed number of elements?
[03:14:36] <xenocons> so rust is using jemalloc with thread-specific caching?
[03:14:51] <strcat> xenocons: yes, all allocations under 4k are from thread-local arenas
[03:14:56] <xenocons> cool
[03:15:44] *** Joins: magg_ (magg@44067157.A0880D54.3D0AE249.IP)
[03:16:13] *** Quits: magg (magg@630352A8.CD20F79C.3D0AE249.IP) (Ping timeout)
[03:16:13] *** magg_ is now known as magg
[03:17:40] <engla> magg: if you need a mutable vec,  let mut xs = ~[0u8];  xs.push(1) ...
[03:18:04] <magg> cool, thanks guys
[03:18:49] *** Joins: aruniiird (arun@7ED01CB1.77AE1A6E.B84D4DA2.IP)
[03:20:46] <xenocons> jemalloc nice read
[03:21:13] <xenocons> aatch: i finished urlifetimes git post
[03:21:28] <aatch> xenocons, cool.
[03:21:39] <xenocons> i think i get it
[03:21:49] <xenocons> but ill need to just code stuff to let it sink in
[03:21:58] <xenocons> also, stringify! seems interesting heh
[03:22:13] *** Joins: deepdog (deepdog@moz-490E834C.client.mchsi.com)
[03:22:23] <xenocons> rusti: stringify!("a":"b");
[03:22:25] -rusti- ()
[03:22:27] <aatch> xenocons, yeah, don't expect to get it immediately. It's not the most simple concept to grasp.
[03:22:34] <aatch> rusti: stringify!("a":"b")
[03:22:36] -rusti- "\"a\" : \"b\""
[03:22:40] <xenocons> rusti: fmt!("%s", stringify!("a":"b"));
[03:22:42] -rusti- ()
[03:22:47] <xenocons> rusti: fmt!("%s", stringify!("a":"b"))
[03:22:49] -rusti- ~"\"a\" : \"b\""
[03:22:54] <xenocons> cool
[03:22:57] <xenocons> aatch: yeah i dont heh
[03:23:19] <xenocons> took me a year of coding part time in ML languages to 'get' disjoint unions and pattern matching
[03:23:44] <aatch> the idea was more to help explain what the different things are, and why they are they.
[03:23:51] <xenocons> willing to stick with it, i want a ->machine code language in my toolbelt other than C
[03:24:20] <steven_is_false> Hoorah! It it works!
[03:24:53] <xenocons> aatch: is there anything i can help with on issue 7012?
[03:25:26] <aatch> xenocons, not really.
[03:25:44] *** Quits: Sorella (queen@B12A78F5.BA14766C.95C8B7C6.IP) (Quit: (quit))
[03:25:44] <aatch> I tried to fix it, but I hit the limit of my understanding of compiler internals
[03:26:03] <aatch> I know where the problem is, and roughly how to fix it, but not sure how.
[03:26:16] <xenocons> damn
[03:26:22] <aatch> I mean, I know the high-level fix, not the actual code fix.
[03:26:31] <xenocons> right
[03:26:45] <aatch> in the mean time, if you drop the & off the front of the array in the field, it should work.
[03:27:14] <xenocons> can you declare static u8 vectors inside structs without &?
[03:27:53] <aatch> xenocons, you can. Which is a bug that this causes this to fail.
[03:28:26] <xenocons> hm
[03:28:31] <steven_is_false> I really hate that bug
[03:28:44] <steven_is_false> I have to work around it using a function that returns the value
[03:29:17] <aatch> steven_is_false, you shouldn't need to. you should be able to do struct { field: [1,2,3] }
[03:29:26] <xenocons> let me try
[03:29:30] <aatch> because it auto borrows, despite the fact it shouldn't.
[03:29:35] <xenocons> oh does the struct definition ont need to change?
[03:29:36] <xenocons> not*
[03:30:10] <xenocons> or are you saying that it does
[03:30:23] <xenocons> like struct sig<'self> { pat : 'self [u32] }
[03:30:34] <xenocons> instead of pat : &'self [u32] 
[03:30:59] <aatch> hang on, I'll post the workaround on the issue
[03:31:22] <xenocons> cool, ty
[03:31:32] *** Quits: parcha (quassel@moz-A9A9F340.hsd1.ma.comcast.net) (Client exited)
[03:32:46] *** Joins: parcha (quassel@moz-A9A9F340.hsd1.ma.comcast.net)
[03:33:54] *** Quits: jack (jack@moz-F1B36F9F.hsd1.nm.comcast.net) (Quit: Leaving.)
[03:35:00] *** Quits: aruniiird (arun@7ED01CB1.77AE1A6E.B84D4DA2.IP) (Ping timeout)
[03:35:02] <mark_edward> can you write a long numeric liter for 10,000 as 10_000
[03:35:03] <mark_edward> ?
[03:36:26] <magg> is there something like parseInt in rust? to change a string to int..
[03:36:36] <strcat> magg: from_str
[03:36:50] <strcat> there's one for specific bases too
[03:36:59] <strcat> rusti: 10_000
[03:37:01] -rusti- 10000
[03:37:08] <mark_edward> cool!
[03:37:28] <magg> thanks, strcat
[03:37:35] <strcat> np
[03:37:44] <aatch> https://github.com/mozilla/rust/issues/7012#issuecomment-19160239
[03:38:22] <steven_is_false> What package gives the documentation for standard c functions like dlerror on Debian?
[03:39:15] <xenocons> aatch: ahhh i see
[03:39:16] <xenocons> cool!
[03:39:42] <sp3d> dunno on Debian, it's just "man-pages" on Arch in case that's helpful
[03:40:04] <xenocons> going to try it out
[03:40:58] <xenocons> aatch: works!
[03:42:03] *** Joins: eatkinson (eatkinson@moz-5CF47426.dia.static.qwest.net)
[03:42:09] <engla> steven_is_false: I think you want manpages-posix-dev
[03:43:30] <steven_is_false> engla: Also the funny manpages
[03:43:32] <engla> you actually want manpages-dev. but the former package too
[03:43:38] <engla> just get all of it
[03:43:39] <engla> :-)
[03:43:54] <engla> there are funny man pages?
[03:44:13] <steven_is_false> There are a lot of humorous versions of packages.
[03:44:23] <engla> I'm installing it
[03:45:07] <SiegeLord> Hmm... rust doc output isn't too pretty
[03:45:46] <SiegeLord> Should it list private members of a public struct?
[03:46:22] <xenocons> my first rust program!
[03:46:36] <xenocons> aatch: should i reply saying thanks on that issue? i am not sure the convention
[03:47:31] <aatch> xenocons, nah, don't bother.
[03:49:01] <xenocons> https://gist.github.com/xenocons/6d9886763dea8c9497bd :D
[03:49:28] <magg> is there a way to convert int to u8?
[03:49:56] <aatch> magg, cast.
[03:49:59] <xenocons> magg: convert int to u8 or ~[u8] ? i think you can do x as u8
[03:50:15] <aatch> rusti: 6531i as u8
[03:50:16] -rusti- 131
[03:51:09] <magg> u8
[03:51:23] <magg> ok thx
[03:51:30] *** Joins: hjr3 (hradtke@moz-842BF853.hsd1.ca.comcast.net)
[03:52:30] <SiegeLord> I wonder if macros can generate docstrings...
[03:52:41] *** Quits: eatkinson (eatkinson@moz-5CF47426.dia.static.qwest.net) (Quit: eatkinson)
[03:52:46] <magg> mmm i get: error: non-scalar cast: `core::option::Option<int>` as `u8`
[03:53:01] <steven_is_false> Does Rust configures as win32 work under WINE?
[03:54:51] <SiegeLord> And for some reason my enum isn't getting documented... a known limitation?
[03:55:03] <strcat> SiegeLord: don't think so, what's the code?
[03:55:14] <strcat> SiegeLord: macros can't generate more than one item though
[03:55:17] <strcat> that's a known limitation
[03:55:22] *** Joins: mflamer (Mibbit@moz-C6ED16AA.hsd1.ca.comcast.net)
[03:55:37] <strcat> magg: because it's an Option<int>, not an int - you have to match out the int
[03:55:39] <SiegeLord> strcat, http://pastebin.ca/2393707
[03:55:55] <strcat> SiegeLord: that should work
[03:59:21] *** Joins: eatkinson (eatkinson@moz-5CF47426.dia.static.qwest.net)
[03:59:41] *** Quits: mib_bx3rbd (Mibbit@moz-72830A1C.nyc.res.rr.com) (Quit: http://www.mibbit.com ajax IRC Client)
[04:01:11] <SiegeLord> Hmm... it doesn't
[04:01:43] <mark_edward> what's wrong with this macro invocation?
[04:01:47] <mark_edward> https://gist.github.com/MarkJr94/5737573
[04:01:55] <mark_edward> isn't the "!" required?
[04:02:18] *** Joins: graydon (graydon@3853DDD.39EEDBB3.D758B1AA.IP)
[04:02:18] *** ChanServ sets mode: +qo graydon graydon
[04:02:28] *** Quits: graydon (graydon@3853DDD.39EEDBB3.D758B1AA.IP) (Quit: Leaving.)
[04:02:58] <aatch> mark_edward, you have either omitted or added commas
[04:03:05] <engla> mark_edward: the macro doesn't have commas in the argument string
[04:03:07] <aatch> depending on where you're coming from.
[04:03:11] <mark_edward> oh ok
[04:03:37] <aatch> Oh, actually, you can't expand macros there
[04:03:43] <mark_edward> you can't?
[04:04:07] <mark_edward> how come?
[04:04:07] <aatch> currently macros can only expand to a single item or expression.
[04:04:16] <aatch> because of the way the parser works.
[04:04:37] <mark_edward> :-( ok
[04:04:45] *** Joins: mleise (marco@moz-3468AB5B.pools.arcor-ip.net)
[04:04:51] <aatch> expansion happens /after/ parsing.
[04:05:31] <aatch> and macros aren't recognised in the variant grammar
[04:05:44] <strcat> rusti: time for a makeover
[04:05:45] -rusti- <anon>:10:14: 10:17 error: expected `;` or `}` after expression but found `for`
[04:05:45] -rusti- <anon>:10          time for a makeover
[04:05:45] -rusti-                         ^~~
[04:05:45] -rusti- application terminated with error code 101
[04:05:49] *** Quits: rusti (rusti@moz-54F7FD49.cpe.net.cable.rogers.com) (Client exited)
[04:06:37] <aatch> strcat, are you going to make rusti <camp voice> faaabulous darling?</camp voice>
[04:06:53] <strcat> not really anything user-visible ;p
[04:10:21] <xenocons> how do we g et the error back from libc::fopen ?
[04:10:24] <xenocons> get*
[04:10:40] <xenocons> return value seems to be 0 on failure
[04:10:53] <strcat> because that's how fopen works
[04:10:55] *** Quits: eatkinson (eatkinson@moz-5CF47426.dia.static.qwest.net) (Ping timeout)
[04:10:57] <strcat> returns NULL on error, sets errno
[04:11:03] <xenocons> ahh
[04:11:06] <strcat> do you really want to be using libc fns?
[04:11:10] <xenocons> so we have to get errno somehow
[04:11:16] *** Joins: victorporof (victorporo@FE2F04DC.63E19875.D111398B.IP)
[04:11:16] <xenocons> strcat: not sure how else to do it
[04:11:22] <strcat> what do you want to do?
[04:11:27] <xenocons> read a file
[04:11:33] <strcat> don't need unsafe code for that.
[04:11:39] <xenocons> hmm
[04:11:42] <strcat> there's an io module
[04:11:51] <strcat> you shouldn't need unsafe code for anything
[04:11:53] *** Joins: eatkinson (eatkinson@moz-5CF47426.dia.static.qwest.net)
[04:11:54] <xenocons> yeah, in io.rs 'file_reader' uses unsafe
[04:12:10] <strcat> yes it uses unsafe but it's already made
[04:12:44] <xenocons> yes but its "r" instead of "rb" which is incorrect on windows for binary files iirc
[04:12:52] <xenocons> (i realise its pending rewrite)
[04:12:59] *** Quits: mflamer (Mibbit@moz-C6ED16AA.hsd1.ca.comcast.net) (Quit: http://www.mibbit.com ajax IRC Client)
[04:13:23] *** Quits: victorporof (victorporo@FE2F04DC.63E19875.D111398B.IP) (Ping timeout)
[04:13:33] *** Joins: mflamer (Mibbit@moz-C6ED16AA.hsd1.ca.comcast.net)
[04:13:48] <mflamer> error: illegal borrow unless pure: creating immutable alias to mutable field
[04:14:35] <mflamer> I keep running in to this. What does it mean?
[04:14:46] <aatch> mflamer, example code?
[04:15:16] *** Quits: atticus (Mibbit@moz-C0A7ED45.hsd1.mn.comcast.net) (Quit: http://www.mibbit.com ajax IRC Client)
[04:15:55] <mleise> does Rust use these file mode strings from C, too?
[04:16:27] <aatch> mleise, not at a high level. but you can access the libc functions
[04:16:59] <mflamer> aatch: https://gist.github.com/anonymous/4dc985a3b81a5e39b41a
[04:17:01] <mleise> aatch: thank god. those thinks are a source of trouble
[04:17:10] <strcat> mleise: it should be opening everything in "binary" mode, but there's no difference on *nix
[04:17:57] <aatch> mflamer, where does the error happen?
[04:18:25] <mleise> strcat: I know. I recently came to realize with D, what DOES make a difference when someone reimplemented the process handling module: inheritance of file handles to child-processes
[04:18:59] <mflamer> aatch: ln 204
[04:19:01] *** Joins: int3_ (int3_@moz-ABE52D50.hsd1.ca.comcast.net)
[04:19:04] <mleise> Unix default is to duplicate and keep them open, Windows default is to close them or ask whether handles should be inherited
[04:19:05] <mflamer> in main
[04:19:07] <strcat> well the files should usually be opened CLOEXEC in the first place
[04:19:22] <strcat> mleise: windows doesn't have fork
[04:19:24] <Jesse> mflamer: what version of Rust? i thought "illegal borrow unless pure" went away
[04:19:29] <strcat> mleise: not really a default vs not a default
[04:19:31] <mleise> strcat: exactly, but do that with the C API :-/
[04:19:38] <mflamer> 0.6
[04:19:46] <strcat> mleise: io shouldn't be built on stdio ;p
[04:19:54] <mleise> strcat: :-(
[04:20:05] <aatch> mflamer, ah. It's because you have @muts
[04:20:53] *** Quits: int3_ (int3_@moz-ABE52D50.hsd1.ca.comcast.net) (Ping timeout)
[04:21:10] <mflamer> I try to stay away from them....seems like I need them
[04:21:31] <aatch> It's kinda hard to explain, but it's not always possible to immutably borrow into them.
[04:21:35] <mleise> strcat: well it wasn't about fork() but about execv. So actually spawning a different process. And the Windows functionality for that has the option to keep inheritable handles or close them.
[04:21:47] <aatch> hang on, I need to experiment
[04:21:58] <mflamer> ok, thanks
[04:21:58] * aatch very, very rarely uses @
[04:22:41] <aatch> mflamer, also, what version of rust are you on?
[04:22:51] <mleise> And the use of stdio was probably to bootstrap D back then and attempts to rewrite the basic I/O failed so far :D
[04:23:31] <aatch> does that exact code fail for you? because if so I suggest updating.
[04:23:35] <mflamer> I just don't know any other way to get a mutable cyclic graph 
[04:23:47] <mflamer> aatch: 0.6
[04:23:50] <aatch> because it works for me
[04:23:57] <mflamer> yes
[04:23:57] <magg> so with "let mut xs = ~[0u8];" i can do xs.push, but if i want to push an element to a certain index that won't work  and a definite-sized vector needs a constant. I need to create a vector with a defined number of elements... is there something like malloc?
[04:23:58] <aatch> mflamer, yeah, but when did you build?
[04:24:23] <aatch> magg, you can pre-allocate with vec::with_capacity(len)
[04:24:28] <mflamer> I just download the binary installer, for win
[04:24:40] <aatch> mflamer, ah, well that is very out of date.
[04:24:41] <mflamer> week or 2 ago
[04:24:54] <Jesse> mflamer: rust changed its strategy for making @mut safe from "require purity" to "use dynamic checks". maybe that was after 0.6?
[04:24:57] <xenocons> there is a std::str::append but no prepend?
[04:25:05] <aatch> do you think you could build it from source?
[04:25:10] <strcat> Jesse: it wasn't actually safe before
[04:25:23] <strcat> @mut only became safe recently
[04:25:40] <aatch> rusti: let mut a = ~[1u, 2u]; a.unshift(0); a
[04:25:40] <magg> aatch, thx
[04:25:48] <aatch> dammit.
[04:26:07] <Jesse> hmm, https://github.com/mozilla/rust/wiki/Doc-detailed-release-notes says that change was made between 0.5 and 0.6
[04:26:10] <aatch> well that produces: "~[0, 1, 2]"
[04:26:18] <strcat> Jesse: yep but it wasn't safe in 0.6 :)
[04:26:21] <mflamer> I need Python, msys, ming, bunch of other stuff. I could give it a try
[04:26:34] <Jesse> strcat: what made it unsafe?
[04:26:53] <strcat> Jesse: a dozen memory unsafety holes
[04:26:57] <strcat> you could get multiple &mut
[04:27:01] <strcat> & and &mut at the same time
[04:27:04] <aatch> mutable, alias data.
[04:30:05] <xenocons> rusti: let x = ["C:\\windows\\system32","test.dll"].connect("\\"); x
[04:30:17] <xenocons> oh whoops it isnt here
[04:31:28] *** Joins: SimonSapin (simon@EB52D2D2.2813D576.FA28A497.IP)
[04:33:20] *** Quits: SimonSapin (simon@EB52D2D2.2813D576.FA28A497.IP) (Ping timeout)
[04:34:41] <mflamer> I'm on a little surface pro tablet. I don't really want to clutter my dinky ssd with pearl, python, etc... I guess I'll have to wait to get a newer build
[04:34:50] *** Quits: jrfeenst (jrfeenst@moz-F912484F.cpe.norwoodlight.com) (Quit: jrfeenst)
[04:35:29] <mflamer> I think this Rust is awesome though. 
[04:36:12] <xenocons> yup
[04:36:48] *** Joins: SimonSapin (simon@EB52D2D2.2813D576.FA28A497.IP)
[04:38:18] <xenocons> aatch: is there something you needed to test on incomming windows?
[04:38:43] <mflamer> low level and fast like C++, elegant like Haskell. :-)
[04:39:15] <xenocons> without C++ goop :O
[04:39:23] *** Quits: eatkinson (eatkinson@moz-5CF47426.dia.static.qwest.net) (Ping timeout)
[04:39:27] <mflamer> yes! 
[04:40:47] *** Joins: eatkinson (eatkinson@moz-5CF47426.dia.static.qwest.net)
[04:41:18] *** Quits: SimonSapin (simon@EB52D2D2.2813D576.FA28A497.IP) (Ping timeout)
[04:42:25] *** Joins: rusti (rusti@moz-54F7FD49.cpe.net.cable.rogers.com)
[04:42:28] <strcat> rusti: 1
[04:42:29] -rusti- cat: /dev/stdin: Operation not permitted
[04:42:29] -rusti- application terminated with error code 1
[04:42:31] <strcat> heh
[04:42:42] *** Quits: rusti (rusti@moz-54F7FD49.cpe.net.cable.rogers.com) (Client exited)
[04:42:53] *** Joins: SimonSapin (simon@EB52D2D2.2813D576.FA28A497.IP)
[04:43:08] <mflamer> At some point I would like to start to contribute...maybe add some libs , help test etc.. 
[04:44:16] *** Joins: brson (brson@72B1AFF8.AD1E507F.3688B332.IP)
[04:44:16] *** ChanServ sets mode: +o brson
[04:45:45] <steven_is_false> How can I test the target_os at rustc?
[04:47:21] *** Quits: SimonSapin (simon@EB52D2D2.2813D576.FA28A497.IP) (Ping timeout)
[04:47:26] <steven_is_false> Okay I can set --cfg 'target_os = "win32"' but how do I unset that it is equal to linux?
[04:47:54] <steven_is_false> (So I can test using WINE)
[04:49:22] *** Quits: eatkinson (eatkinson@moz-5CF47426.dia.static.qwest.net) (Quit: eatkinson)
[04:49:40] <SiegeLord> Is there any aspect of rustpkg that works?
[04:50:21] <steven_is_false> SiegeLord: Yes, it just doesn't give friendly error messages
[04:50:35] <SiegeLord> Can you build a package using it?
[04:50:38] <steven_is_false> SiegeLord: It's SO.. close to being actually useful.
[04:51:01] <steven_is_false> SiegeLord: As I recall it can't detect libextra that might have changed recently though.
[04:51:15] <steven_is_false> I can build hello world with it.
[04:51:30] <SiegeLord> How do you invoke it?
[04:52:22] <steven_is_false> SiegeLord: cd rust/src/librustpkg/testsuite; rust build hello-world
[04:55:27] <SiegeLord> That's not rustpkg though...
[04:55:43] <steven_is_false> Oops I meant rust pkg build.
[04:56:18] <strcat> rust build is just rustc
[04:56:27] <strcat> steven_is_false: oh
[04:57:37] <SiegeLord> That doesn't do anything for me...
[04:57:49] <SiegeLord> rust: task failed at 'Package hello-world not found in any of the following workspaces: [.]', /home/siege/src/rust2/src/librustpkg/workspace.rs:24
[04:58:03] <steven_is_false> Sorry testsuite/pass
[04:58:19] <SiegeLord> pwd is /home/siege/src/rust2/src/librustpkg/testsuite/pass/src/hello-world
[04:58:32] <steven_is_false> Right I made that mistake too.
[04:58:53] <steven_is_false> You have do rust pkg build from the directory containing src not src, or hello-world
[04:59:40] *** Quits: erickt (Adium@49C4075F.3AC15C18.2321E71E.IP) (Quit: Leaving.)
[04:59:58] <SiegeLord> So the src directory is mandatory?
[05:00:44] <steven_is_false> SiegeLord: yes.
[05:00:57] <SiegeLord> That seems... bizzare
[05:01:49] *** Joins: aruniiird (arun@D773DE32.D7DC86D4.5296A3D0.IP)
[05:01:51] <aatch> SiegeLord, it might not be.
[05:02:09] <aatch> it just might be the default
[05:02:17] <SiegeLord> Hmm
[05:02:29] <SiegeLord> Well, I guess I'll just wait until it's a bit more fleshed out
[05:02:29] <aatch> I know that you will be able to have build scripts.
[05:02:31] *** Joins: pseudoku (quassel@E11BF0D0.96D08489.C28326FD.IP)
[05:02:50] <SiegeLord> I'd really expect it to look for the pkg.rs or whatnot in the current directory
[05:02:56] <aatch> I think if you have a pkg.rs at the top level is compiles and executes it.
[05:03:16] <steven_is_false> There's a function to disable task switching right something like task::atomically?
[05:03:28] <steven_is_false> Found it.
[05:03:32] <aatch> steven_is_false, that's the exact function, yes
[05:04:17] <strcat> huh, can't figure out why rusti broke
[05:04:25] <pseudoku> brson: is https://github.com/mozilla/rust/issues/6435 still open?
[05:04:55] <strcat> stupid pipe isn't working
[05:08:27] *** Quits: aruniiird (arun@D773DE32.D7DC86D4.5296A3D0.IP) (Ping timeout)
[05:11:31] <brson> pseudoku: yes. we need a new design and implementation. it can be influenced by extra::timer. good project for aspiring library authors
[05:11:41] <magg> I'm using: let mut xs: ~[u8]  = vec::with_capacity(tot); But when i try to access index 1. I get " failed at 'index out of bounds: the len is 0 but the index is 1' "
[05:11:45] *** Joins: victorporof (victorporo@FE2F04DC.63E19875.D111398B.IP)
[05:12:11] <engla> right, the capacity is just a preallocation not the logical size
[05:13:09] <magg> :( so is there a way to set the logical size on runtime?
[05:13:42] <strcat> initialize it to that size
[05:13:45] <engla> you can do vec::from_elem(tot, 0u8)
[05:13:58] *** Quits: victorporof (victorporo@FE2F04DC.63E19875.D111398B.IP) (Ping timeout)
[05:14:31] <pseudoku> brson: could you tell me who the clients of the api would be? since you mentioned extra::timer, i am assuming it should be a channel based api, rather than callback based one, right?
[05:15:06] <engla> magg: you'll need to initialize to some value if you have a vector with logical size > 0
[05:15:14] *** Joins: z0w0 (zack@FDF4EF6A.2CA5CD8.5F93A189.IP)
[05:15:16] <engla> so from_elem works if you want to copy one element
[05:15:25] <engla> from_fn if you want to generate a sequence
[05:16:14] <magg> kk
[05:16:29] <flu_> for https://github.com/mozilla/rust/issues/7022 - I'm thinking adding an additional check before stk is dereferenced is the better choice. Thoughts?
[05:16:40] <mark_edward> how do you guys do that thing where you have a .rs file for a module as well as a folder for it?
[05:16:49] <mark_edward> i see it in libstd with std::num
[05:16:55] <flu_> basically 'big_stack->next = stk ? stk->next : NULL;'
[05:16:59] <mark_edward> but i can't do it ?
[05:19:35] <Jeaye> How can I pass compile-time constants from rustc? I know of --cfg, but that's only for flags, right? I'd like to send the commit hash.
[05:19:51] <strcat> Jeaye: put it in the environment
[05:19:53] <strcat> and use env!
[05:20:16] <Jeaye> println(env!(PATH)); ?
[05:20:40] <Jeaye> ahh, need quotes
[05:20:46] <Jeaye> That's good though. Thanks, strcat. :)
[05:21:08] <steven_is_false> TIL I learn about env!. But that doesn't work for the version number right? In other words one can't do #[lib (vers = env!("VERSION_NUMBER"))]?
[05:21:44] <steven_is_false> rusti: println(env!("PATH"))
[05:21:47] <strcat> Jeaye: git describe is nice btw.
[05:22:01] <strcat> Jeaye: it outputs tag-commits_since_tag-id
[05:22:15] <strcat> last_tag* rather
[05:23:12] <Jeaye> Ahh, I've just been using `git rev-parse HEAD`
[05:23:20] *** Quits: deepdog (deepdog@moz-490E834C.client.mchsi.com) (Quit: Leaving)
[05:23:29] <mark_edward> can anyone help me?
[05:23:50] <aatch> mark_edward, that isn't suggested anymore.
[05:24:41] <aatch> the suggested method is to have a `mod.rs` file in the folder, then put a #[path="path/to/foo/mod.rs"] on the `pub mod foo;` 
[05:24:58] *** Quits: SiegeLord (sl@moz-CAF07B4C.hsd1.ma.comcast.net) (Quit: It's a joke. It's all a joke.)
[05:25:32] *** Joins: rusti (rusti@moz-54F7FD49.cpe.net.cable.rogers.com)
[05:25:34] <mark_edward> oh ok i think
[05:25:35] <brson> pseudoku: I am not entirely sure, and I haven't done any comparisons to other timer libraries. I would expect a sleep function, something that sends pipe messages and eventual compatibility with #6842
[05:25:36] <strcat> rusti: 2
[05:25:37] -rusti- 2
[05:25:59] <strcat> rusti: println("foo")
[05:26:00] -rusti- foo
[05:26:00] -rusti- ()
[05:26:05] <brson> pseudoku: our timer resolution by default is going to be very bad since we don't preempt
[05:26:54] <brson> pseudoku: i think that's not a huge problem since if you need accuracy you can create a new thread
[05:27:38] <mark_edward> aatch: i'm confused. say i want to have mod, mod::submod, and mod::submod2
[05:27:38] *** Quits: rusti (rusti@moz-54F7FD49.cpe.net.cable.rogers.com) (Client exited)
[05:27:40] *** Joins: rusti (rusti@moz-54F7FD49.cpe.net.cable.rogers.com)
[05:27:57] <mark_edward> and i want to define some funcions under `mod`
[05:28:30] <aatch> mark, so for the module foo, you want a folder named foo/ with mod.rs, subfoo.rs and subbar.rs
[05:28:46] <aatch> in mod.rs, you have pub mod subfoo and pub mod subbar
[05:28:58] <strcat> rusti: -
[05:28:59] -rusti- <anon>:11:4: 11:5 error: unexpected token: `}`
[05:28:59] -rusti- <anon>:11     }));
[05:28:59] -rusti-               ^
[05:28:59] -rusti- application terminated with error code 101
[05:29:10] <mark_edward> Ah ok, i've got it. Thanks!
[05:29:28] <aatch> then in the crate file, you have #[path="foo/mod.rs"] pub mod foo;
[05:29:43] <strcat> brson: https://github.com/mozilla/rust/pull/7023 r?
[05:29:58] <mark_edward> cool, i think it makes sense now
[05:35:53] *** Quits: santiago (santiago@moz-8ADE82B4.socal.res.rr.com) (Quit: Computer has gone to sleep.)
[05:36:11] *** Joins: jviereck (Adium@moz-2C3A9E25.dip0.t-ipconnect.de)
[05:36:14] *** Joins: ghrust (ghrust@614D05BD.6A2AE50.F3114085.IP)
[05:36:14] <ghrust> 01[13rust01] 15bors pushed 0 new commits to 06auto: 02http://git.io/lt9CiA
[05:36:14] *** Parts: ghrust (ghrust@614D05BD.6A2AE50.F3114085.IP) ()
[05:36:19] *** Joins: ghrust (ghrust@79968228.6A2AE50.F3114085.IP)
[05:36:19] <ghrust> 01[13rust01] 15bors pushed 2 new commits to 06auto: 02http://git.io/t6RjZw
[05:36:19] <ghrust> 13rust/06auto 14de36715 15Daniel Micay: remove deprecated vec::{is_empty, len} functions
[05:36:19] <ghrust> 13rust/06auto 1488c318d 15bors: auto merge of #7023 : thestinger/rust/vec, r=brson
[05:36:19] *** Parts: ghrust (ghrust@79968228.6A2AE50.F3114085.IP) ()
[05:36:28] <xenocons> rusti: "test.dll".contains(&~"dll");
[05:36:45] <xenocons> hm
[05:36:56] *** Joins: alisdair (textual@moz-EBE9F394.bchsia.telus.net)
[05:40:39] <xenocons> ok my search algorithm is obviously slow
[05:41:19] <steven_is_false> rusti: env!("PATH")
[05:41:20] -rusti- "/usr/local/bin:/usr/bin:/bin"
[05:41:24] <steven_is_false> rusti: env!("")
[05:41:25] -rusti- ""
[05:41:39] <steven_is_false> rusti: env!("_")
[05:41:39] -rusti- ""
[05:41:52] <steven_is_false> rusti: env!("PWD")
[05:41:53] -rusti- "/home/rust"
[05:41:57] <steven_is_false> rusti: env!("PS1")
[05:41:58] -rusti- ""
[05:42:04] <steven_is_false> rusti: env!("PPID")
[05:42:05] -rusti- ""
[05:42:16] * xenocons snickers do spawn { }sped things up
[05:42:22] <magg> so I'm doing this: substr(string, 94, 96); and i get rust: task failed at 'assertion failed: end < l', /private/tmp/rust-DFFU/rust-0.6/src/libcore/str.rs:1752
[05:42:26] <steven_is_false> rusti: env!("LOGNAME")
[05:42:27] -rusti- ""
[05:42:48] <magg> the length of the string is 96
[05:46:41] <magg> :(
[05:46:54] *** Joins: Yurume (yurume@AC58A8CE.8A059B47.E313B915.IP)
[05:47:24] <bstrie> magg: well if the length is 96, then you can't take the index at 96
[05:48:03] <bstrie> though I have no idea if substr is intended to be inclusive or exclusive on its upper bound...
[05:48:06] <bstrie> it might just be a bug
[05:48:50] <bstrie> rusti: "abc".substr(0,1)
[05:48:50] -rusti- "a"
[05:48:58] <bstrie> rusti: "abc".substr(0,3)
[05:49:00] -rusti- "abc"
[05:49:21] <bstrie> magg: what version are you using?
[05:49:56] *** Joins: jack (jack@moz-F1B36F9F.hsd1.nm.comcast.net)
[05:50:12] <magg> bstrie: i'm assuming thats 0.6
[05:50:19] <bstrie> rusti: "123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456".substr(94,96)
[05:50:20] -rusti- rust: task failed at 'assertion failed: end < l', /build/rust-incoming-git/src/rust/src/libstd/str.rs:1970
[05:50:20] -rusti- rust: domain main @0x7f2c1ec1f810 root task failed
[05:50:20] -rusti- application terminated with error code 101
[05:50:25] <bstrie> haha
[05:50:49] <magg> wtf happened
[05:50:52] <magg> is that a bug?
[05:51:09] <bstrie> rusti: "12345678901234567890123456789012345678901234567890123".substr(51,53)
[05:51:10] -rusti- rust: task failed at 'assertion failed: end < l', /build/rust-incoming-git/src/rust/src/libstd/str.rs:1970
[05:51:10] -rusti- rust: domain main @0x7f1b5281f810 root task failed
[05:51:10] -rusti- application terminated with error code 101
[05:51:27] <bstrie> rusti: "123456789012345678901".substr(19,21)
[05:51:28] -rusti- rust: task failed at 'assertion failed: end < l', /build/rust-incoming-git/src/rust/src/libstd/str.rs:1970
[05:51:28] -rusti- rust: domain main @0x7fd0de81f810 root task failed
[05:51:28] -rusti- application terminated with error code 101
[05:51:30] <bstrie> wtf
[05:51:35] <magg> WTF
[05:51:38] <bstrie> rusti: "abcd".substr(0,4)
[05:51:39] *** Quits: jack (jack@moz-F1B36F9F.hsd1.nm.comcast.net) (Ping timeout)
[05:51:39] <xenocons> WTF
[05:51:40] -rusti- "abcd"
[05:51:54] <bstrie> rusti: "1234567890".substr(0,10)
[05:51:55] -rusti- "1234567890"
[05:51:55] <xenocons> last 2 chars? hehe
[05:51:58] <bstrie> rusti: "1234567890".substr(8,10)
[05:51:59] -rusti- rust: task failed at 'assertion failed: end < l', /build/rust-incoming-git/src/rust/src/libstd/str.rs:1970
[05:51:59] -rusti- rust: domain main @0x7f167381f810 root task failed
[05:51:59] -rusti- application terminated with error code 101
[05:52:03] <bstrie> wwwwwwwwwwwwwwwwwttttttttttttttttfffffffffffffff
[05:52:06] <magg> LOL
[05:52:11] <magg> I found a bug!!!
[05:52:12] <aatch> rusti: "abcdefg".substr(2,2)
[05:52:13] -rusti- "cd"
[05:52:16] <xenocons> rusti: "abcdefg".substr(9,10)
[05:52:17] -rusti- rust: task failed at 'index out of bounds: the len is 7 but the index is 9', /build/rust-incoming-git/src/rust/src/libstd/str.rs:1997
[05:52:17] <aatch> or not
[05:52:17] -rusti- rust: domain main @0x7f577b81f810 root task failed
[05:52:17] -rusti- application terminated with error code 101
[05:52:22] <xenocons> oh
[05:52:30] <aatch> did nobody think that it might be (start,length)?
[05:52:33] <bstrie> hahaha
[05:52:33] <xenocons> rusti: "abcdefg".substr(5,7)
[05:52:34] -rusti- rust: task failed at 'assertion failed: end < l', /build/rust-incoming-git/src/rust/src/libstd/str.rs:1970
[05:52:34] -rusti- rust: domain main @0x7ff86281f810 root task failed
[05:52:34] -rusti- application terminated with error code 101
[05:52:44] <bstrie> aatch: that would be too reasonable!
[05:52:47] <aatch> rusti: "abcdefg".substr(3,2)
[05:52:48] -rusti- "de"
[05:52:58] <aatch> -.-
[05:53:05] <bstrie> rusti: "abcdef".slice(4,6)
[05:53:06] -rusti- "ef"
[05:53:30] *** Quits: caitp (caitp@moz-9FE842F.cpe.net.cable.rogers.com) (Quit: caitp)
[05:53:31] <bstrie> magg: ^ use .slice instead of .substr if you want to give indexes in the string
[05:54:56] <xenocons> is int::range the same perf as for(i=0;i<... in C?
[05:55:06] <xenocons> (or similar)
[05:55:10] <bstrie> yeah
[05:55:13] <magg> bstrie:ok thanks
[05:56:24] *** Quits: alisdair (textual@moz-EBE9F394.bchsia.telus.net) (Quit: My MacBook Pro has gone to sleep. ZZZzzz)
[05:56:52] <bstrie> brson: I think you're having a bit too much fun with github emoticons
[05:57:17] <strcat> never enough github emoticons
[05:57:38] <magg> rusti: "abcdefg".substr(5,2)
[05:57:39] -rusti- "fg"
[05:57:41] <strcat> brson will have to design the io module paths to expand to github emotions in the commit messages
[05:57:58] *** Joins: eatkinson (eatkinson@moz-5CF47426.dia.static.qwest.net)
[05:58:17] <magg> rusti: "abcdefg".substr(5,7)
[05:58:18] -rusti- rust: task failed at 'assertion failed: end < l', /build/rust-incoming-git/src/rust/src/libstd/str.rs:1970
[05:58:18] -rusti- rust: domain main @0x7f72b081f810 root task failed
[05:58:18] -rusti- application terminated with error code 101
[05:58:22] <strcat> bstrie: https://github.com/mozilla/rust/commit/eb627817206aa0ca5faf4ffb68f53da0f5ddbde5
[05:58:35] <strcat> :back: and :link: :D
[05:58:40] <bstrie> strcat: yes, I was highly amused at that
[05:58:54] <bstrie> I'm a little baffled that github tries to parse emoticons in commit messages
[05:59:01] <aatch> hurrah!
[05:59:10] <strcat> bstrie: it's github, nothing should surprise you
[05:59:14] <bstrie> haha
[05:59:35] <aatch> I finally tricked rustc into letting me write code I know is correct.
[05:59:35] <strcat> bstrie: the whole "you can edit other people's comments silently" is what gets me
[05:59:50] <aatch> strcat, that scares me to no end
[06:00:34] <bjz_> arrgh, massive commit went out of control
[06:00:36] <bstrie> yes, that's very bad
[06:00:39] <dbaupp> aatch: with 'unsafe'?
[06:00:54] <aatch> dbaupp, no. hence the celebration.
[06:00:59] <bstrie> I mean, I understand and accept why we can edit issue text and issue titles
[06:00:59] <dbaupp> :D
[06:01:01] <aatch> strange borrow checker
[06:01:07] <bstrie> but arbitrary comments, that's just wrong
[06:01:44] *** Joins: true_droid (Adium@moz-123FD9B8.beck.volia.net)
[06:02:01] <aatch> bstrie, especially since it's 'edit', delete makes sense.
[06:02:14] *** Quits: sankha93 (Instantbir@BFECE1D6.6ABDE3A6.8B6C1D65.IP) (Ping timeout)
[06:03:53] <strcat> bstrie: I understand why you can edit comments/issues
[06:03:55] <strcat> but...
[06:03:59] <strcat> it should show a history of edits
[06:04:01] <strcat> and make it obvious
[06:04:13] <strcat> [originally posted by bstrie, edited by ...]
[06:04:35] *** Quits: hjr3 (hradtke@moz-842BF853.hsd1.ca.comcast.net) (Quit: My MacBook has gone to sleep. ZZZzzz)
[06:04:46] <strcat> bstrie: I've seen it used to make people look stupid
[06:04:56] <strcat> as in editing their comments out of spite
[06:05:07] * strcat doesn't like that "feature" at all ;[
[06:05:48] *** Quits: dylukes (dylukes@moz-E4DF3FED.pitbpa.fios.verizon.net) (Quit: ["Textual IRC Client: www.textualapp.com"])
[06:06:45] <flu_> hmm... running 'make check' on incoming failed for me. doing a clean and trying again
[06:06:52] <flu_> anybody ran the tests on incoming recently?
[06:07:10] <strcat> yes
[06:07:11] <strcat> it passed
[06:07:14] <flu_> hrm
[06:07:27] <aatch> flu_, ever PR is tested against incoming.
[06:07:33] <aatch> every*
[06:07:41] <aatch> before being merged.
[06:07:46] *** Quits: rusti (rusti@moz-54F7FD49.cpe.net.cable.rogers.com) (Client exited)
[06:07:46] <flu_> aatch: yeah, testing my commit against it before sending the PR :-)
[06:08:04] <flu_> could be on my end, I was hovering close to 0% free disk space when I ran the tests previously
[06:08:49] *** Joins: rusti (rusti@moz-54F7FD49.cpe.net.cable.rogers.com)
[06:12:16] *** Joins: victorporof (victorporo@FE2F04DC.63E19875.D111398B.IP)
[06:14:20] *** Quits: victorporof (victorporo@FE2F04DC.63E19875.D111398B.IP) (Ping timeout)
[06:18:16] *** Joins: Voomer_ (Voomer@moz-E97E8EB7.br.br.cox.net)
[06:18:16] *** Quits: Voomer__ (Voomer@moz-E97E8EB7.br.br.cox.net) (Connection reset by peer)
[06:19:29] *** Quits: jviereck (Adium@moz-2C3A9E25.dip0.t-ipconnect.de) (Quit: Leaving.)
[06:20:23] *** Joins: jack (jack@moz-F1B36F9F.hsd1.nm.comcast.net)
[06:22:25] *** Joins: SingingBoyo (brandon@moz-94AE1D3A.bchsia.telus.net)
[06:27:13] *** Joins: ghrust (ghrust@CFE85B59.6A2AE50.F3114085.IP)
[06:27:14] <ghrust> 01[13rust01] 15bors merged 06auto into 06incoming: 02http://git.io/t6RjZw
[06:27:14] *** Parts: ghrust (ghrust@CFE85B59.6A2AE50.F3114085.IP) ()
[06:29:23] *** Joins: azita (Azita@moz-C1FB2A8.hsd1.ca.comcast.net)
[06:30:23] *** Quits: jack (jack@moz-F1B36F9F.hsd1.nm.comcast.net) (Ping timeout)
[06:30:45] *** Joins: Cromulent (Cromulent@moz-983B638D.cable.virginmedia.com)
[06:32:02] *** Joins: rajul (quassel@A2DDF553.812B5995.2051BA92.IP)
[06:33:53] *** Joins: dpc (Mibbit@moz-86B6569C.hfc.comcastbusiness.net)
[06:34:25] <dpc> Hi? I can't get "log(error, ...)" to compile. I'm using current incoming. Any help with that?
[06:40:04] *** Quits: wuwei|away (wuwei@1A513F49.818D7924.FAA9ED67.IP) (Quit: Leaving)
[06:41:26] <dbaupp> rusti: error!("my message %?", 1234)
[06:41:27] -rusti- rust: ~"my message 1234"
[06:41:27] -rusti- ()
[06:41:38] <dbaupp> dpc: the syntax changed ^
[06:42:06] *** Quits: steven_is_false (user@moz-144077DE.bchsia.telus.net) (Client exited)
[06:42:11] <dpc> Thank you. I thought so, but could not find out anything about it in "git log"
[06:42:28] *** Quits: mflamer (Mibbit@moz-C6ED16AA.hsd1.ca.comcast.net) (Quit: http://www.mibbit.com ajax IRC Client)
[06:42:43] <mark_edward> http://static.rust-lang.org/doc/std/index.html
[06:42:49] <mark_edward> http://static.rust-lang.org/doc/core/index.html
[06:42:54] <mark_edward> what happend to the docs?
[06:43:13] <dpc> mark_edward: Yes, I've also noticed it.
[06:43:33] <dpc> core was renamed to std; and std to extra, so everything is wrong now. :D
[06:43:43] <mark_edward> maybe extra is up?
[06:43:46] <dpc> You should use 0.6 for time being,  Iguess.
[06:43:58] <mark_edward> it works! http://static.rust-lang.org/doc/extra/index.html
[06:44:29] *** Joins: sankha93 (Instantbir@49B9E539.3248B2C3.8B6C1D65.IP)
[06:44:56] <mark_edward> dpc: i thought the stuff a static.rust-lang.org wouldn't change until they released 0.7 though
[06:44:56] <dpc> Does DNS resolution work in Rust libraries?
[06:46:03] <dpc> mark_edward: I don't know about "static." I use only main one and "trunk" is for trunk.
[06:46:29] <mark_edward> dpc: yes, but it's a bit of a hassle.
[06:46:37] *** Quits: rajul (quassel@A2DDF553.812B5995.2051BA92.IP) (Client exited)
[06:46:41] <mark_edward> look into extra::net::ip
[06:47:32] *** Joins: jviereck (Adium@moz-2C3A9E25.dip0.t-ipconnect.de)
[06:47:38] <dpc> BTW. What is this "log / error!" really doing BTW?
[06:47:43] <dbaupp> mark_edward: you can get the old docs via, http://static.rust-lang.org/doc/0.6/core/index.html
[06:47:47] <dbaupp> dpc: it's a macro
[06:48:04] <dbaupp> dpc: so it expands to something like what the log(...) syntax of old was doing
[06:48:07] <dpc> Yes. I know it's a macro, I wonder about internals.
[06:48:16] <dpc> Is this going to stderr or something?
[06:48:27] <engla> rust-lang.org now links to the docs for both Core and Standard for the trunk
[06:48:30] <mark_edward> you could check the source for great detail
[06:48:34] <dbaupp> dpc: you can look at it's internals via 'rustc --pretty expanded'
[06:48:53] <dbaupp> dpc: on a file like `fn main() { error!("foo") }`
[06:49:39] <dbaupp> it looks like it calls a function/built-in called __log
[06:50:06] <dpc> dbaupp: Handy feature. Thanks. :)
[06:50:11] <dbaupp> which you can in fact call yourself, just like the old `log`
[06:50:19] *** Quits: sankha93 (Instantbir@49B9E539.3248B2C3.8B6C1D65.IP) (Ping timeout)
[06:50:22] <dpc> So what's old "log" doing? :D
[06:50:28] <dbaupp> dpc: no idea ;P
[06:50:50] *** Joins: int3_ (int3_@moz-ABE52D50.hsd1.ca.comcast.net)
[06:50:51] <dbaupp> dpc: it is going to stderr though
[06:52:09] <mark_edward> --pretty expanded is cool
[06:53:40] <dbaupp> yup, it's amazing for debugging macros/syntax extensions
[06:54:09] <dbaupp> the only problem is it can generate code that doesn't compile
[06:54:45] *** Quits: azita (Azita@moz-C1FB2A8.hsd1.ca.comcast.net) (Quit: azita)
[06:55:26] <magg> is there a way to convert a u8 vector to str?
[06:56:45] <dbaupp> magg: str::from_bytes, I think
[06:57:33] <dbaupp> rusti: str::from_bytes(&[65,66,67])
[06:58:02] <dbaupp> rusti: str::from_bytes(&[65,66,67])
[06:58:22] <dbaupp> rusti: hello
[06:58:40] <magg> thanks dbaupp
[06:58:51] <dbaupp> strcat: how come rusti works with a pm but not in the channel?
[06:59:11] <strcat> dbaupp: uh
[06:59:16] <dbaupp> strcat: or is it not printing errors?
[06:59:16] <strcat> rusti: str::from_bytes(&[65,66,67])
[06:59:23] <dbaupp> rusti: std::str::from_bytes(&[65,66,67])
[06:59:24] -rusti- ~"ABC"
[06:59:27] <strcat> rusti: str::from_bytes(&[65,66,67])
[06:59:28] *** Joins: jack (jack@moz-F1B36F9F.hsd1.nm.comcast.net)
[06:59:36] <strcat> dbaupp: it's a bug of some sort
[06:59:38] *** Quits: rusti (rusti@moz-54F7FD49.cpe.net.cable.rogers.com) (Client exited)
[06:59:42] <strcat> I changed stuff
[07:00:04] <dbaupp> strcat: speaking of which, I'm thinking we should convert from_bytes/to_bytes to operate on slices
[07:00:12] <dbaupp> strcat: and let people call .to_owned() if they need to
[07:00:25] <engla> strcat: it's very nice that you keep rusti up to date all the time
[07:00:29] <strcat> dbaupp: sounds inefficient (two passes)
[07:00:38] *** Joins: rusti (rusti@moz-54F7FD49.cpe.net.cable.rogers.com)
[07:00:41] <strcat> rusti: str::from_bytes(&[65,66,67])
[07:00:43] <strcat> ugh
[07:00:49] *** Quits: rusti (rusti@moz-54F7FD49.cpe.net.cable.rogers.com) (Client exited)
[07:00:53] <dbaupp> strcat: oh, so we should keep both -> &[u8] and -> ~[u8] fns?
[07:01:26] <strcat> dbaupp: in some cases we probably should
[07:01:57] <dbaupp> strcat: hmm, what are the two passes?
[07:02:09] <dbaupp> strcat: since the -> &[u8] is just a transmute
[07:02:18] <strcat> dbaupp: oh well nvm for those ones
[07:02:21] <strcat> it depends on the function
[07:02:40] <strcat> most should just use slices (like splitting)
[07:02:57] <dbaupp> our current implementation of from_bytes checks utf8-ness, and then converts to a ~str
[07:03:04] <strcat> ah
[07:03:08] <dbaupp> i.e. it does two passes anyway?
[07:03:26] <dbaupp> and presumably the actual -> ~str step should be a memcpy
[07:04:08] <dbaupp> in any case, I think that the discoverable function should be the non-allocating one
[07:04:17] <strcat> yes
[07:04:55] *** Joins: rusti (rusti@moz-54F7FD49.cpe.net.cable.rogers.com)
[07:05:01] <strcat> rusti: str::from_bytes(&[65,66,67])
[07:05:09] <strcat> rusti: 2
[07:05:13] -rusti- 2
[07:05:14] <strcat> huh
[07:05:21] *** Quits: rusti (rusti@moz-54F7FD49.cpe.net.cable.rogers.com) (Client exited)
[07:05:46] *** Quits: parcha (quassel@moz-A9A9F340.hsd1.ma.comcast.net) (Client exited)
[07:05:53] <dbaupp> strcat: are you not capturing stderr or something?
[07:05:55] *** Joins: rusti (rusti@moz-54F7FD49.cpe.net.cable.rogers.com)
[07:05:59] <strcat> rusti: aa
[07:06:00] -rusti- more than 5 lines of output, pastebinned: http://sprunge.us/XdWG
[07:06:04] <strcat> rusti: str::from_bytes(&[65,66,67])
[07:06:05] -rusti- more than 5 lines of output, pastebinned: http://sprunge.us/COJb
[07:06:17] <dbaupp> yay!
[07:06:20] <dbaupp> rusti: botsnack
[07:06:21] -rusti- "nom nom"
[07:07:39] *** Quits: rusti (rusti@moz-54F7FD49.cpe.net.cable.rogers.com) (Client exited)
[07:07:40] *** Quits: jack (jack@moz-F1B36F9F.hsd1.nm.comcast.net) (Ping timeout)
[07:07:51] *** Joins: rusti (rusti@moz-54F7FD49.cpe.net.cable.rogers.com)
[07:07:55] <strcat> rusti: aa
[07:07:56] -rusti- more than 5 lines of output, pastebinned: http://sprunge.us/QPSL
[07:08:29] <strcat> dbaupp: I had a typo in the pastebin bit
[07:08:42] <strcat> fixed now
[07:08:44] <strcat>             r = requests.post("http://sprunge.us", {"sprunge": b"".join(lines)})
[07:08:52] <strcat>             return "line longer than 150 columns, pastebinned: " + r.content
[07:09:05] <strcat> anyway it was having an encoding error
[07:12:47] *** Joins: victorporof (victorporo@FE2F04DC.63E19875.D111398B.IP)
[07:14:57] *** Quits: victorporof (victorporo@FE2F04DC.63E19875.D111398B.IP) (Ping timeout)
[07:16:03] *** Joins: EXetoC (ex@moz-2DBEB1E4.customer.t3.se)
[07:16:12] *** Joins: sankha93 (Instantbir@4CE513C9.4A7A14DD.8B6C1D65.IP)
[07:17:28] *** Quits: ravi_ (ravi@moz-F439A643.jetstream.xtra.co.nz) (Client exited)
[07:18:04] *** Quits: SingingBoyo (brandon@moz-94AE1D3A.bchsia.telus.net) (Ping timeout)
[07:20:20] *** Joins: wuwei (wuwei@1A513F49.818D7924.FAA9ED67.IP)
[07:20:41] <dbaupp> strcat: \o/ about removing len and is_empty though
[07:21:02] <strcat> so much cruft left ;p
[07:21:47] <dbaupp> working on the str splitters now
[07:23:18] <strcat> heh there's *so* much cruft in that module
[07:23:21] <strcat> like it's ridiculous
[07:23:55] *** Quits: dpc (Mibbit@moz-86B6569C.hfc.comcastbusiness.net) (Quit: http://www.mibbit.com ajax IRC Client)
[07:24:36] <dbaupp> yup
[07:25:06] <dbaupp> it is not match for our delete keys though
[07:25:31] <aatch> dbaupp, %s/.//g
[07:25:51] <dbaupp> that would be effective
[07:25:53] <aatch> much more efficient
[07:26:04] <Luqman> aatch: haha deleting everything is a bit much though :P
[07:26:04] <dbaupp> I have a feeling users would get annoyed at the new str/vec APIs
[07:26:11] <Luqman> or lack thereof
[07:26:21] <pseudoku> why do we have libuv bindings in both extra and rt?
[07:26:40] <dbaupp> aatch: one problem though. that deletes the licence also :(
[07:26:48] <aatch> dbaupp, I thought minimalism was good?
[07:26:49] <dbaupp> it's not as efficient as possible
[07:27:01] <dbaupp> well, make tidy doesn't think so :(
[07:27:12] * strcat just uses 'dap'
[07:27:33] <strcat> deletes the docstring and the function block ;p
[07:27:49] <dbaupp> ew, vim :P
[07:29:48] <dbaupp> strcat: should I not have a split_nonempty_iter() method, and just let users run `.filer(|s| !s.is_empty())` if they need it?
[07:30:27] <strcat> dbaupp: don't know, might as well start simple though
[07:30:29] <dbaupp> strcat: it's only used a few times in std::path, so I'm leading towards yes
[07:30:37] <dbaupp> (i.e. in the whole codebase)
[07:30:59] <dbaupp> ok.. if it gets too annoying someone can add it in later
[07:32:56] <magg> how to print chars? or char vector
[07:33:32] <magg> print doesn't allow chars.
[07:33:39] *** Quits: rntz (rntz@moz-C76A8D96.sp.cs.cmu.edu) (Ping timeout)
[07:33:53] <dbaupp> magg: fmt!("%c", c) for a single char
[07:34:18] <dbaupp> magg: and str::from_chars(char_vec) for a `&[char]` vector
[07:34:32] <magg> thanks man
[07:34:38] <dbaupp> :)
[07:35:59] *** Quits: magg (magg@44067157.A0880D54.3D0AE249.IP) (Quit: magg)
[07:40:11] *** Quits: Cromulent (Cromulent@moz-983B638D.cable.virginmedia.com) (Quit: KVIrc 4.2.0 Equilibrium http://www.kvirc.net/)
[07:42:33] *** Joins: rntz (rntz@moz-C76A8D96.sp.cs.cmu.edu)
[07:44:32] *** Quits: strcat (strcat@moz-54F7FD49.cpe.net.cable.rogers.com) (Quit: WeeChat 0.4.1)
[07:47:08] <doomlord> Did i read correct that traits will eventually support default implementations..
[07:48:43] *** Joins: santiago (santiago@moz-8ADE82B4.socal.res.rr.com)
[07:49:01] *** Joins: youknowone (youknowone@A826BD81.8A0DEF81.38747683.IP)
[07:49:01] *** Quits: youknowone (youknowone@A826BD81.8A0DEF81.38747683.IP) (Z:lined (Open Proxy found on your host. Please visit www.blitzed.org/proxy?ip=115.68.131.49 for more information.))
[07:49:14] <dbaupp> doomlord: yes, as in, you'll be able to supply a default method body
[07:50:12] *** Quits: blitter (blitter@moz-BA14D5CF.dyn.centurytel.net) (Ping timeout)
[07:54:16] *** Joins: quvarxa (chatzilla@moz-60654F71.lns21.adl2.internode.on.net)
[07:56:39] *** Joins: dpc (Mibbit@moz-86B6569C.hfc.comcastbusiness.net)
[07:56:52] <dpc> How do I print on stderr without using error! ?
[07:57:01] <dpc> I don't really want to print errors there ...
[07:57:14] <dpc> Just log some stuff that is not part of stdout.
[07:57:55] <dbaupp> rusti: std::io::stderr().write_line("hello")
[07:57:59] -rusti- hello
[07:57:59] -rusti- ()
[07:58:29] <dbaupp> (if you're using 0.6, then that can just be `io::stderr().write_line("hello")`)
[08:00:30] <dpc> Also, why does error! pretty-print (serializes?) values give to it? Should it be like this?
[08:00:47] <dbaupp> dpc: what do you mean?
[08:00:57] <dbaupp> rusti: error!(1)
[08:00:59] -rusti- rust: ~"1"
[08:00:59] -rusti- ()
[08:01:01] *** Quits: yardena (yardena@moz-A95F12B1.members.linode.com) (Ping timeout)
[08:01:11] <dbaupp> dpc: oh, right, yeah... I guess that's by design
[08:01:58] *** Joins: Blub\w (wry@7E3BB9D.71150E1A.237AE2BA.IP)
[08:01:59] <dbaupp> it just calls fmt!(<args>), except if there is only one, in which case it is fmt!("%?", <arg>)
[08:02:35] <dpc> I see.
[08:04:29] <dbaupp> I'm not sure I agree with the latter case, since it makes a single string look really ugly
[08:11:53] *** kimundi is now known as zz_kimundi
[08:12:31] *** Quits: brson (brson@72B1AFF8.AD1E507F.3688B332.IP) (Quit: leaving)
[08:13:03] <bjz_> rusti: error!("hi")
[08:13:04] -rusti- rust: ~"\"hi\""
[08:13:05] -rusti- ()
[08:13:13] <bjz_> yuck
[08:14:02] *** Joins: mzabaluev (mzabaluev@moz-91FFD755.dhcp.inet.fi)
[08:15:40] <dpc> rust: task failed at 'Unhandled condition: not_utf8: ~"from_bytes: input is not UTF-8; first bad byte is 229"', /home/dawidc/opt/src/rust/src/libstd/condition.rs:44
[08:15:43] <dpc> :(
[08:17:58] *** Quits: eatkinson (eatkinson@moz-5CF47426.dia.static.qwest.net) (Quit: eatkinson)
[08:19:28] *** Joins: yardena (yardena@moz-A95F12B1.members.linode.com)
[08:20:57] *** Joins: Cromulent (Cromulent@moz-983B638D.cable.virginmedia.com)
[08:21:27] <dbaupp> rusti: error!("hi \"quotes\"")
[08:21:28] -rusti- rust: ~"\"hi \\\"quotes\\\"\""
[08:21:29] -rusti- ()
[08:24:47] <dpc> How do I return value from "do / for" clousure?
[08:28:57] <bjz_> dpc: you mean short circuit?
[08:28:57] *** Joins: aruniiird (arun@280AB1CD.70AE5D19.261E7448.IP)
[08:29:22] <bjz_> you can only do a short-circuit from a sugared for closure
[08:29:45] <dbaupp> rusti: fn f() { for 4.times { return 1; } return 2; } f()
[08:29:48] -rusti- more than 5 lines of output, pastebinned: http://sprunge.us/GKVb
[08:30:02] <dbaupp> rusti: fn f() -> uint { for 4.times { return 1; } return 2; } f()
[08:30:03] -rusti- 1
[08:30:09] <bjz_> there
[08:30:44] <bjz_> rusti: fn f() -> uint { do [4, 5, 6].map |_| { return 1; } return 2; } f()
[08:30:45] -rusti- more than 5 lines of output, pastebinned: http://sprunge.us/fVBV
[08:30:53] <bjz_> ^can't do that
[08:31:06] <xenocons> rusti: {4}
[08:31:07] -rusti- 4
[08:31:10] <xenocons> rusti: {4;}
[08:31:11] -rusti- ()
[08:31:47] <bjz_> rusti: fn f() -> uint { do [4, 5, 6].map |_| { return 1; }; return 2; } f()
[08:31:48] -rusti- more than 5 lines of output, pastebinned: http://sprunge.us/XIPQ
[08:34:10] *** Quits: Amanieu (amanieu@moz-D5D10CA8.halls.manchester.ac.uk) (Connection reset by peer)
[08:34:17] <dpc> Is there any labeled goto or other way to break the execution of callee from the block clousure?
[08:34:52] *** Joins: Amanieu (amanieu@moz-D5D10CA8.halls.manchester.ac.uk)
[08:35:09] <dbaupp> dpc: no
[08:35:32] <dbaupp> dpc: (except for return in a `for` closure)
[08:36:11] <bjz_> rusti: 'foo loop { loop { break 'foo; } } 4
[08:36:11] -rusti- <anon>:10:14: 10:18 error: expected `:` but found `loop`
[08:36:12] -rusti- <anon>:10          'foo loop { loop { break 'foo; } } 4
[08:36:12] -rusti-                         ^~~~
[08:36:12] -rusti- application terminated with error code 101
[08:36:24] <bjz_> rusti: 'foo: loop { loop { break 'foo; } } 4
[08:36:24] -rusti- 4
[08:36:31] <bjz_> :P
[08:36:43] *** Quits: wilsonk-laptop (kvirc@moz-39EFBFC2.cg.shawcable.net) (Ping timeout)
[08:36:50] <bjz_> only for `loop` though
[08:37:12] <Luqman> rusti: let x = Some(@21); x.unwrap(); x.unwrap()
[08:37:13] -rusti- @21
[08:37:23] <bjz_> kind of an ideosyncratic feature
[08:37:39] <dbaupp> bjz_: works for while too
[08:37:48] <bjz_> orly?
[08:38:14] <dbaupp> rusti: 'foo: while 1 == 1 { loop { break 'foo } } 7
[08:38:15] -rusti- <anon>:10:15: 10:20 error: expected `loop`, found `while`
[08:38:15] -rusti- <anon>:10          'foo: while 1 == 1 { loop { break 'foo } } 7
[08:38:15] -rusti-                          ^~~~~
[08:38:15] -rusti- application terminated with error code 101
[08:38:21] <dbaupp> ok, maybe not
[08:38:23] <dbaupp> :(
[08:39:15] <bjz_> heh
[08:39:20] <Luqman> I thought unwrap moved things out of the option, why does doing it twice not fail?
[08:39:34] <bjz_> Luqman: dunno
[08:39:49] <bjz_> Luqman: there was talk of getting rid of unwrap
[08:40:00] <bjz_> and making get return a reference
[08:40:01] <dbaupp> Luqman: because @int can be implicitly copied, maybe?
[08:40:15] <dbaupp> rusti: let x = Some(~[1,2,3]); x.unwrap(); x.unwrap()
[08:40:17] -rusti- more than 5 lines of output, pastebinned: http://sprunge.us/dGiO
[08:40:31] <Luqman> dbaupp: ah right
[08:40:34] <bjz_> Luqman: actually, I think get moves atm
[08:40:45] <bjz_> Luqman: I dunno
[08:40:54] <dbaupp> bjz_: get uses `copy` I think?
[08:41:08] <bjz_> dbaupp: oh yeah, I am wrong
[08:41:09] <dbaupp> yup
[08:41:11] <Luqman> get has T: Copy
[08:41:18] <dbaupp> how silly!
[08:41:36] <bjz_> get -> unwrap, unwrap -> *poof*
[08:41:44] <bjz_> is what I reckon
[08:42:20] <bjz_> I attempted to have a go after pcwalton / nmatsakis were talking about it, but it's very pervasive
[08:42:55] <bjz_> also, the freestanding functions in option should be zapped as well
[08:43:10] <dbaupp> bjz_: i assign you
[08:43:13] <bjz_> Luqman: we really need that deprecated attribute
[08:43:38] *** Joins: victorporof (victorporo@FE2F04DC.63E19875.D111398B.IP)
[08:43:57] <dbaupp> bjz_: just remove them? there's no guarantee of stability yet
[08:44:07] <bjz_> Luqman: I want to deprecate all the appropriate free-standing functions in vec/str/option/result
[08:44:20] <Luqman> bjz_: oh right, i had a branch that implemented a bit about it but it's just been collecting dust
[08:44:24] <bjz_> dbaupp: the issue is that there are so many of them in use
[08:44:35] <dbaupp> bjz_: I'm removing a lot of vec, btw
[08:44:41] <bjz_> dbaupp: it's too hard to do it in one go
[08:44:44] <bjz_> ahh, nice
[08:44:44] <dbaupp> bjz_: (well, strcat and I)
[08:45:07] <bjz_> dbaupp: I just removed all of them in the num mods
[08:45:20] <dbaupp> :D
[08:45:26] *** Quits: mzabaluev (mzabaluev@moz-91FFD755.dhcp.inet.fi) (Ping timeout)
[08:45:27] <bjz_> dbaupp: well, except for the str ones
[08:45:42] *** Quits: victorporof (victorporo@FE2F04DC.63E19875.D111398B.IP) (Ping timeout)
[08:45:54] <bjz_> and we don't re-export the delegated intrinsics/cmath functions
[08:46:31] <bjz_> dbaupp: so much to do!
[08:47:20] *** Quits: Cromulent (Cromulent@moz-983B638D.cable.virginmedia.com) (Quit: KVIrc 4.2.0 Equilibrium http://www.kvirc.net/)
[08:48:08] *** Quits: thou (thou@moz-1C1CA9F7.fasttrackcomm.net) (Input/output error)
[08:49:41] *** Quits: dpc (Mibbit@moz-86B6569C.hfc.comcastbusiness.net) (Quit: http://www.mibbit.com ajax IRC Client)
[08:54:50] *** Joins: jensnockert (jensnocker@moz-8BE55278.customer.t3.se)
[09:01:00] *** Quits: sankha93 (Instantbir@4CE513C9.4A7A14DD.8B6C1D65.IP) (Ping timeout)
[09:04:45] *** Joins: sankha93 (Instantbir@F601F159.CB400184.8B6C1D65.IP)
[09:05:49] *** Joins: victorporof (victorporo@FE2F04DC.63E19875.D111398B.IP)
[09:07:08] <bjz_> jensnockert: pushed a big commit removing most of the free-standing functions from the numeric modules and removing the re-exports of the delegated float functions
[09:07:19] <jensnockert> bjz_: Sounds good.
[09:07:34] <jensnockert> To your repo?
[09:07:39] <bjz_> aye
[09:07:44] <bjz_> same branch
[09:08:01] <bjz_> if you can figure out why those tests were failing, it'd be awesome
[09:08:26] <bjz_> then we can get an r+ hopefully!
[09:08:30] <bjz_> :)
[09:11:30] *** Joins: wilsonk-laptop (kvirc@moz-39EFBFC2.cg.shawcable.net)
[09:12:46] *** Joins: Sodel_the_V (user@moz-853663E1.va.shawcable.net)
[09:16:57] *** Joins: Earnestly (earnest@6A917A59.5E1FD793.39C00A7A.IP)
[09:17:36] *** Quits: jviereck (Adium@moz-2C3A9E25.dip0.t-ipconnect.de) (Ping timeout)
[09:18:15] *** Joins: jviereck (Adium@moz-2C3A9E25.dip0.t-ipconnect.de)
[09:18:49] *** Quits: jviereck (Adium@moz-2C3A9E25.dip0.t-ipconnect.de) (Quit: Leaving.)
[09:18:50] *** Joins: jviereck (Adium@moz-2C3A9E25.dip0.t-ipconnect.de)
[09:18:59] *** Quits: jviereck (Adium@moz-2C3A9E25.dip0.t-ipconnect.de) (Client exited)
[09:19:00] *** Joins: jviereck (Adium@moz-25A1D0F6.ethz.ch)
[09:21:03] *** Quits: jviereck (Adium@moz-25A1D0F6.ethz.ch) (Quit: Leaving.)
[09:21:23] *** Quits: Jeaye (Jeaye@moz-FD505E54.hsd1.ca.comcast.net) (Quit: Don't tell them I was here...)
[09:24:03] *** Quits: Earnestly (earnest@6A917A59.5E1FD793.39C00A7A.IP) (Quit: WeeChat 0.4.2-dev)
[09:25:14] *** Joins: koomi (koomi@moz-E8AECC1E.pools.arcor-ip.net)
[09:26:36] <jensnockert> bjz_: I'll take a look at it as soon as I poked my server a bit, it seems to have driver issues with the RAID array which makes me worried :S
[09:26:49] <bjz_> ahh, np
[09:27:15] *** Joins: Earnestly (earnest@6A917A59.5E1FD793.39C00A7A.IP)
[09:27:38] *** Quits: sk (sk@61A494B3.BA40E8A.AAC02D62.IP) (Ping timeout)
[09:28:28] <jensnockert> It is annoying that it fails all over when trying to boot into runlevel 5, but when I boot into runlevel 3 and check _the entire_ RAID array multiple times it shows up nothing
[09:28:55] *** Joins: sk (sk@61A494B3.BA40E8A.AAC02D62.IP)
[09:29:18] *** Quits: sankha93 (Instantbir@F601F159.CB400184.8B6C1D65.IP) (Ping timeout)
[09:29:20] *** Joins: Cromulent (Cromulent@moz-983B638D.cable.virginmedia.com)
[09:29:42] *** Joins: sankha93 (Instantbir@F601F159.CB400184.8B6C1D65.IP)
[09:30:05] *** Quits: sankha93 (Instantbir@F601F159.CB400184.8B6C1D65.IP) (Client exited)
[09:31:53] *** Joins: jviereck (Adium@moz-2C3A9E25.dip0.t-ipconnect.de)
[09:33:15] *** Joins: caitp (caitp@moz-9FE842F.cpe.net.cable.rogers.com)
[09:33:46] <jensnockert> bjz_: Was just copy-paste error.
[09:33:53] <jensnockert> bjz_: I'll push a patch.
[09:34:03] <bjz_> cheers :)
[09:37:38] <jensnockert> bjz_: Fixed!
[09:40:46] *** zz_kimundi is now known as kimundi
[09:41:59] *** Quits: Sodel_the_V (user@moz-853663E1.va.shawcable.net) (Ping timeout)
[09:58:28] *** Quits: Cromulent (Cromulent@moz-983B638D.cable.virginmedia.com) (Quit: KVIrc 4.2.0 Equilibrium http://www.kvirc.net/)
[09:59:22] *** Joins: spider-mario (spidermari@moz-AC2C1EAE.rev.sfr.net)
[10:02:48] *** Joins: kud1ing (Mibbit@moz-9A0388E1.pools.arcor-ip.net)
[10:03:03] <kud1ing> cursor.rs:236:6: 236:13 error: cannot move out of dereference of & pointer
[10:03:04] <kud1ing>  cursor.rs:236       Text(v) => {
[10:03:13] *** Quits: pseudoku (quassel@E11BF0D0.96D08489.C28326FD.IP) (Ping timeout)
[10:03:22] <kud1ing> any idea? i had to remove "copy" for latest incoming
[10:04:28] <doener> kud1ing: Text(ref v) => ... copy *v
[10:05:36] <kud1ing> doener: seems to work, thanks
[10:06:09] *** Joins: heftig_ (heftig@moz-F9D278E1.dip0.t-ipconnect.de)
[10:06:19] *** Quits: heftig (heftig@moz-B5C1FECB.dip0.t-ipconnect.de) (Ping timeout)
[10:08:19] <xenocons> is do spawn { } cheap? can we just throw it around?
[10:08:43] <dbaupp> xenocons: yeah, it's pretty cheap
[10:08:47] <xenocons> cool
[10:09:06] <dbaupp> xenocons: iirc, for 1000000.times {  do spawn {} } took ~1s on my computer
[10:09:10] <caitp> did rust give up on traits or something
[10:09:31] <dbaupp> xenocons: the exact numbers aren't correct there
[10:09:42] <dbaupp> caitp: no, not at all... why do you ask?
[10:09:55] <xenocons> thats fast
[10:10:25] <bjz_> jensnockert: hmm, still fails for me
[10:10:26] <dbaupp> (it's probably more like ten thousand than 1 million though)
[10:10:28] <caitp> because it will say "Expected owned pointer to Foo, but instead found owned pointer of type implementing Foo"
[10:10:50] <caitp> which is fucking stupid obviously
[10:11:16] <dbaupp> caitp: I have no idea what you're talking about? trait objects?
[10:11:33] <caitp> nobody has any idea, don't worry about it
[10:12:08] <dbaupp> what's "it"?
[10:12:09] *** Quits: jviereck (Adium@moz-2C3A9E25.dip0.t-ipconnect.de) (Quit: Leaving.)
[10:12:15] <dbaupp> rustc?
[10:12:23] <kimundi> caitp: you need to cast ~Type to ~Trait
[10:12:37] <bjz_> xenocons: the whole driving factor behind tasks is that they're lightweight
[10:12:48] <dbaupp> caitp: but you probably want `thing as ~Foo` though, as kimundi says
[10:12:49] <kimundi> explicitly with 'as'
[10:12:50] <caitp> yes kimundi, but having to cast is stupid
[10:13:00] <xenocons> bjz_: right, hmm
[10:13:02] <dbaupp> caitp: no it's not, because they have different representations
[10:13:09] <caitp> no, it is stupid, end of story
[10:13:10] <bjz_> xenocons: they're supposed to be inspired by erlangs concurrency model
[10:13:15] <xenocons> i think my program is slow due to the algorithm though
[10:13:17] <dbaupp> caitp: (and anyway, it's probably getting removed)
[10:13:35] <xenocons> i mean, do spawn{} certainly speeds it up, but nothing beats fixing poor algorithm
[10:13:58] <xenocons> i could probably use a few more do spawn{} but the improvement might not be that noticable
[10:14:16] <kimundi> caitp: I wouldn,t say its stupid, but one of the devs has an PR lingering where that coerces automatically 
[10:14:27] <dbaupp> caitp: lastly, coming on #rust and swearing about a feature that is known incomplete/broken is not pleasant at all
[10:14:29] <dbaupp> caitp: https://github.com/mozilla/rust/wiki/Note-development-policy#conduct
[10:14:47] <caitp> pleasant is overrated
[10:15:45] <xenocons> its alpha still :^)
[10:15:58] <xenocons> and it works for me, imo thats pretty cool
[10:16:09] <caitp> if you don't have emotional intensity, you don't have real feedback :^)
[10:16:12] <bjz_> we just use sadfaces :(
[10:16:27] <bjz_> and then try to fix it
[10:16:31] <xenocons> if you find an issue, submit on github for maximum exposure
[10:16:41] <kimundi> caitp: Its just one of the many things that might be relaxed later, but isnt currently worked on because there are more important things on their tables.
[10:16:53] <bjz_> aye
[10:17:00] <caitp> the general pattern has been "if you find an issue, it's not important enough to fix for the next 700 days or so because other things are more important"
[10:17:14] <caitp> "bugs will be closed"
[10:17:19] <dbaupp> that's true for everyone
[10:17:27] <bjz_> hehe, you should see how many they've fixed
[10:17:38] <caitp> right, but it just means that it's more useful to swear about things rather than file bugs or attempt to fix them
[10:17:51] <bjz_> no it doesn't
[10:17:59] <dbaupp> I dunno, fixing things is pretty good
[10:18:00] <EXetoC> bjz_: yeah. too bad there aren't any issue graphs
[10:18:26] <caitp> swearing about badness is always useful
[10:18:35] <bjz_> EXetoC: the issue count is pretty much a treadmill
[10:19:24] <xenocons> btw, are there any profiling tools atm for rust? for example % of time taken on function
[10:19:26] <bjz_> meh, swearing can get folks attention sometimes, but other times it's just annoying
[10:19:39] <bjz_> makes folks less likely to help
[10:19:44] <dbaupp> xenocons: you're on windows, right?
[10:19:48] <kimundi> caitp: Not if the badness is known, the devs are willing do fix it, but just have hifher prioritys atm :P
[10:19:48] <xenocons> bjz_: i find it helps when i stub my toe tho for some reason
[10:19:51] <xenocons> dbaupp: yeh
[10:20:09] <dbaupp> xenocons: oh, then I don't know
[10:20:27] <xenocons> maybe something inside of llvm\clang tools
[10:20:41] <bjz_> xenocons: I just say 'oh golly goshness', and jump up and down abit
[10:21:01] <xenocons> bjz_: i say 'f* mother f, arghhh god damn f' 
[10:21:07] <caitp> explicit language is an important part of communication which intensifies a message and emphasizes it
[10:21:17] <bjz_> xenocons: whatever floats your boat
[10:21:17] <caitp> it's very important for communicating discontent
[10:21:25] <EXetoC> I'm just annoyed by it tbh
[10:21:41] <caitp> it's meaningless without it
[10:21:54] <caitp> how are you going to measure my discontent without a few dozen fucks here and there?
[10:22:00] <bjz_> caitp: swearing is warrented, but LIKE ANY INTENSIFIER IT GETS ANNOYING WHEN USED INAPPROPRATIELY@!!!
[10:22:16] <xenocons> i would rage at rust if a) it was production ready b) devs didnt fix stuff, neither of these 2 conditions are satisfied
[10:22:24] <dbaupp> caitp: the point is not the swearing so much as repeatedly complaining about bugs in an *explicitly* alpha language
[10:22:41] <jaen> it also ups the ante and make people want to (even if only subconsciously) counter-rage you, not really productive
[10:22:42] <caitp> it's not clear that it's a bug at all
[10:23:13] <dbaupp> caitp: and always doing it in a confrontational manner
[10:23:19] * bjz_ exits debate
[10:23:26] <caitp> what it looks like is, "there was a design decision made at some point to behave this way"
[10:23:28] <jaen> if language is alpha everything is potentially a bug, so no reason to get confrontational ; p
[10:23:46] *** Joins: donri (dag@moz-9BB61102.tbcn.telia.com)
[10:24:32] *** Quits: true_droid (Adium@moz-123FD9B8.beck.volia.net) (Quit: Leaving.)
[10:24:34] <dbaupp> caitp: let me refer you back to the conduct page again: "Please keep unstructured critique to a minimum. If you have solid ideas you want to experiment with, make a fork and see how it works."
[10:25:01] <dbaupp> caitp: even substituting "blog post" or "mailing list email" with "fork" would be fine.
[10:25:20] <dbaupp> s/with/for/
[10:25:41] *** Joins: FrozenCow (FrozenCow@moz-B2DF4929.chello.nl)
[10:26:21] <caitp> you don't have to say it like that, you can say "go write a fucking blogpost or something", try it
[10:26:35] *** Quits: wilsonk-laptop (kvirc@moz-39EFBFC2.cg.shawcable.net) (Ping timeout)
[10:26:37] <dbaupp> caitp: go write a fucking blogpost or something
[10:26:41] <caitp> attaboy
[10:27:26] <kimundi> caitp: The stance of the devs with lang features was allways "lets try it this way, and look how the community likes it"
[10:28:57] *** Quits: devbug (quassel@moz-E1DE087C.bchsia.telus.net) (Client exited)
[10:29:13] <caitp> i've been reading the issue tracker and mailing list for nearly a year, the pattern is largely "well this language feature breaks X so we need to remove or contort it in horrible ways that break perfectly good code for the benefit of this particular edge case -- in the name of safety!"
[10:29:41] <xenocons> i for one welcome our new safety overlords
[10:30:00] <xenocons> but i haven't been following rust stuff that long
[10:30:29] *** Quits: jaen (jaen@moz-E0979827.copit.pl) (Ping timeout)
[10:30:38] *** Joins: wilsonk-laptop (kvirc@moz-39EFBFC2.cg.shawcable.net)
[10:31:09] <kimundi> caitp: I'm rot sure what you're talking about...
[10:31:18] <kimundi> not*
[10:31:23] *** Joins: true_droid (Adium@moz-123FD9B8.beck.volia.net)
[10:31:26] <caitp> i have not seen "developer happiness" used as a factor anywhere, really
[10:32:09] <kimundi> because in a alpha lang that's not relevant...
[10:32:29] <caitp> developer happiness is always relevant
[10:33:19] <xenocons> are you unhappy caitp ?
[10:33:35] <Axord> In alpha the happiness of the language devs may be more relevant than that of users
[10:33:55] <caitp> it varies from hour to hour xenocons 8)
[10:34:21] <bjz_> they have a happiness test
[10:34:22] <kimundi> whats relevant is that the language develops to something devs are happy with
[10:34:27] <xenocons> caitp: i think you should document your opinion on this somewhere more permenant than irc
[10:34:59] <caitp> don't worry i'm sure the nsa is marking all this down
[10:35:15] *** Joins: Blei (philipp@moz-96D25F7A.cust.bluewin.ch)
[10:35:23] *** Quits: Blei (philipp@moz-96D25F7A.cust.bluewin.ch) (Quit: Blei)
[10:35:27] *** Joins: Blei (philipp@moz-96D25F7A.cust.bluewin.ch)
[10:35:30] <bjz_> [o__o] is, actually
[10:35:50] <caitp> nothing on the internet is really fleeting
[10:35:54] <bjz_> but nobody ever reads it :)
[10:37:15] <Axord> Can't be a mainstream language without plenty of ranty blog posts
[10:37:44] <caitp> i agree
[10:48:47] <jensnockert> bjz_: Wat?
[10:49:24] <bjz_> jensnockert: posted on the commit
[10:50:17] *** Quits: kud1ing (Mibbit@moz-9A0388E1.pools.arcor-ip.net) (Quit: http://www.mibbit.com ajax IRC Client)
[10:50:29] <jensnockert> Silly.
[10:50:49] <bjz_> dunno why
[10:50:53] <bjz_> maybe its me
[10:51:00] <jensnockert> It is probably off in the last digit.
[10:51:01] <bjz_> :/
[10:51:08] <jensnockert> What OS are you running btw?
[10:51:08] *** Joins: maxli (maxli@C03F2759.C70D537E.2FA4EA88.IP)
[10:51:22] <bjz_> approx_eq?
[10:51:30] <bjz_> assert_approx_eq?
[10:51:33] <bjz_> os x
[10:51:33] <jensnockert> Possibly.
[10:51:39] <jensnockert> Odd, then it's not that.
[10:51:54] *** Joins: MaikKlein (maik@moz-B464C230.dip0.t-ipconnect.de)
[10:52:10] <bjz_> what do you mean?
[10:52:19] <bjz_> it's not that?
[10:52:36] <jensnockert> Since we're both on OS X, then differences in libc is not it.
[10:52:53] <jensnockert> Or I just forgot to run the tests.
[10:53:04] <bjz_> make check-stage1-std NO_REBUILD=1
[10:53:18] <dbaupp> bjz_: I've used that like 10 times already today
[10:53:25] <dbaupp> bjz_: you're a hero
[10:53:29] <bjz_> :D
[10:54:28] <jensnockert> What does NO_REBUILD do? Just build Rust once?
[10:56:27] <dbaupp> jensnockert: basically yes
[10:56:29] *** Quits: maxli (maxli@C03F2759.C70D537E.2FA4EA88.IP) (Ping timeout)
[10:56:44] <dbaupp> jensnockert: all I know is it stops you having to rebuild the whole thing if you change the tests
[11:00:21] *** Quits: caitp (caitp@moz-9FE842F.cpe.net.cable.rogers.com) (Ping timeout)
[11:01:04] <bjz_> dbaupp: http://www.reddit.com/r/rust/comments/1fz5xu/public_service_announcement_make_checkstage1std/
[11:01:06] <bjz_> :)
[11:01:14] <bjz_> thought I'd share
[11:01:40] *** Quits: dew (Instantbir@moz-66796D51.dhcp.stls.mo.charter.com) (Ping timeout)
[11:01:54] *** Joins: dew (Instantbir@moz-66796D51.dhcp.stls.mo.charter.com)
[11:01:56] <dbaupp> bjz_: it works for anything... not just std ;P
[11:02:16] <dbaupp> bjz_: and now you get to be a hero to everyone! :D
[11:07:13] <aatch> looks like I missed quite a kerfuffle.
[11:08:17] <aatch> anyway, there is another NZ dev! Living in the same city as me!
[11:08:39] <aatch> 2 is enough for a user group, right? :P
[11:09:35] <dbaupp> aatch: a user*s* group!
[11:09:50] <aatch> dbaupp, exactly!
[11:12:47] *** Quits: int3_ (int3_@moz-ABE52D50.hsd1.ca.comcast.net) (Client exited)
[11:13:28] <aatch> but seriously, seeing his exact address and realizing I know what bus to get to house is weird.
[11:16:00] <dbaupp> why/how are you stalking him? ;P
[11:19:38] <aatch> dbaupp, no lol. Wellington is pretty compressed, I'd have lived here long enough to know where most things are.
[11:19:38] <MaikKlein> here
[11:19:39] <MaikKlein> http://seleniac.org/map/
[11:19:39] *** Quits: jensnockert (jensnocker@moz-8BE55278.customer.t3.se) (Input/output error)
[11:20:22] <aatch> MaikKlein, hmmm, that seems... inaccurate.
[11:20:36] <MaikKlein> I just never thought that we have so many contributers from atlantis
[11:20:55] *** wuwei is now known as wuwei|offline
[11:21:24] <Luqman> haha, i see it thinks I'm "inhabiting a shack in remote Saskatchewan"
[11:22:18] <aatch> For one, either there are more NZ contributers than I thought, or this map is perpetuating the idea that the only inhabited place in NZ is Auckland.
[11:22:25] <aatch> Which is a giant shithole.
[11:22:51] <dbaupp> aatch: there are places other than Auckland (and Hobbitton) in NZ?
[11:22:53] <dbaupp> :P
[11:24:23] <aatch> dbaupp, eh, AU gets a similar thing with Sydney.
[11:24:43] <dbaupp> aatch: Sydney's the capital, yeah? :P
[11:25:07] <engla> I can't imagine anything in NZ to be a shithole
[11:25:33] <aatch> Australian cities: Sydney, Ayer's Rock, Tazmania and New Zealand.
[11:25:49] <aatch> engla, Auckland is terrible compared to most of the rest of the country
[11:26:20] <MaikKlein> New Zealand is also a city in Australia? oO
[11:26:41] *** Joins: tgt (tgt@moz-D59EE478.aztw.cable.virginmedia.com)
[11:27:28] <aatch> MaikKlein, possibly a state. Based on my brief survey of 14 year-olds in UK.
[11:27:49] <aatch> (Aka, my old high-school classmates)
[11:27:59] <dbaupp> aatch: it *should* be
[11:28:13] <MaikKlein> haha
[11:28:17] <aatch> dbaupp, you shut your mouth.
[11:28:29] <dbaupp> :D
[11:29:02] <Luqman> bjz_: do you know if there was an issue for not being able to have static methods in multiple impls ?
[11:29:12] <MaikKlein> I think its putting all contributers in capital cities 
[11:29:38] <MaikKlein> like in germany nearly every contributer comes from berlin... srsly?
[11:30:11] <Luqman> MaikKlein: well it depends on what people have set as their location on github
[11:30:21] <dbaupp> MaikKlein: there's apparently no-one in Canberra, but there are people from other AU cities
[11:30:30] *** Joins: q66 (q66@6EE9DE40.46454B5D.33AABD5F.IP)
[11:30:42] <dbaupp> (there's also apparently no-one from Sydney... I don't exist :'( )
[11:30:56] <dbaupp> Luqman: yes
[11:31:22] <dbaupp> Luqman: https://github.com/mozilla/rust/issues/4228
[11:31:26] <MaikKlein> oh I thought it traces your ip or sth
[11:31:51] <engla> it's scaled by lines of code contributed
[11:32:49] <Luqman> dbaupp: ah thanks!
[11:33:37] <MaikKlein> out of curiosity do English speaking ppl know how to pronounce my name "Maik"?
[11:33:45] *** Quits: nielsle (nielsle@moz-5CE8ECCD.boa.fiberby.dk) (Ping timeout)
[11:34:10] *** Joins: jack (jack@moz-F1B36F9F.hsd1.nm.comcast.net)
[11:34:26] <Blei> MaikKlein: you speak english, so by definition: yes
[11:34:34] <MaikKlein> haha
[11:34:45] *** Quits: jyyou (jyyou@moz-47B052FA.cs.nctu.edu.tw) (Ping timeout)
[11:35:06] <Blei> guessing: like mike?
[11:35:10] <MaikKlein> yeah
[11:36:08] <Blei> we had a proffessor called Maike, so that makes guessing easier. are you Dutch?
[11:36:18] <MaikKlein> I was just wondering if I have to rename myself to mike if I wanted to move to a english speaking country.
[11:36:25] <MaikKlein> I am from Germany
[11:36:45] *** Quits: true_droid (Adium@moz-123FD9B8.beck.volia.net) (Quit: Leaving.)
[11:36:55] <doener> MaikKlein: at least you have no umlauts in your name ;-)
[11:36:58] <aatch> MaikKlein, depends if you want to tell everybody how to spell your name.
[11:37:20] <Blei> well, then don't take my answer for being representative, i'm not from an english speaking country either
[11:37:40] <aatch> Also, I would pronounce it "Mike"
[11:38:34] <aatch> I am not only from an english speaking country, I grew in /the/ english speaking country.
[11:38:44] <aatch> Singapore!
[11:38:54] <aatch> (No, not really, England)
[11:39:34] <MaikKlein> do you know Fort William?
[11:39:45] <dbaupp> in Scotland?
[11:39:53] <MaikKlein> yeah
[11:41:01] <aatch> I do not, but I grew up as far away from Scotland as you can get without leaving the country.
[11:41:09] *** Joins: jyyou (jyyou@moz-47B052FA.cs.nctu.edu.tw)
[11:41:09] <MaikKlein> :D
[11:41:27] *** Quits: jack (jack@moz-F1B36F9F.hsd1.nm.comcast.net) (Ping timeout)
[11:41:41] <dbaupp> I've been on a bus through Fort William... does that count?
[11:41:49] <aatch> I then moved as far away as it is possible without living in the middle of the ocean
[11:42:11] <MaikKlein> dbaupp, then you were much closer to fort william than me :)
[11:42:16] *** Joins: ryo (Mibbit@moz-C2182715.fibertel.com.ar)
[11:42:41] <MaikKlein> aatch, You are currently living in NZ?
[11:42:58] <aatch> I am, have been for over 7 years
[11:43:01] *** Joins: int3_ (int3_@moz-ABE52D50.hsd1.ca.comcast.net)
[11:43:33] <aatch> I am not, however, a citizen.
[11:43:49] <aatch> that shit's like... effort or something.
[11:44:28] <aatch> However, I am a permanent resident. So I can still vote, get government aid and stuff like that.
[11:44:35] <MaikKlein> haha what? :D
[11:44:46] <aatch> I just can't represent NZ in an international sporting event.
[11:45:05] <MaikKlein> I am kind not sure where I want to go. I definitely want to move to an english speaking country 
[11:45:08] <aatch> and they might think a bit before letting me into the armed forces
[11:45:17] <MaikKlein> but amerika is kinda crazy
[11:45:18] <aatch> MaikKlein, you could do worse than NZ.
[11:45:25] <aatch> Wellington is brilliant
[11:45:33] <MaikKlein> I also thought about canada 
[11:45:37] <dbaupp> MaikKlein: clearly australia
[11:45:37] <dbaupp> :P
[11:45:41] <aatch> and I'm not just saying that because I live here.
[11:46:02] <aatch> dbaupp, you still have filtered internet and banned media?
[11:46:14] <dbaupp> aatch: not that I've noticed
[11:46:53] <MaikKlein> germany has "filtered" internet, at least i can't watch like 40% of all youtube videos.....
[11:47:02] <MaikKlein> only with a VPN
[11:47:05] <MaikKlein> so sad
[11:47:42] <dbaupp> MaikKlein: everywhere that isn't the US gets that
[11:47:43] <MaikKlein> and my IPS just throttled all internet traffic to youtube to like 10kb/s
[11:48:06] <dbaupp> oh, but maybe not that :(
[11:48:07] <aatch> MaikKlein, EU hates Google
[11:48:14] <MaikKlein> haha
[11:48:20] *** Joins: jensnockert (jensnocker@moz-8BE55278.customer.t3.se)
[11:48:23] <dbaupp> Luqman: !
[11:48:33] <Luqman> dbaupp: ?
[11:48:34] <dbaupp> you fixed it!
[11:48:52] <dbaupp> it = 4228
[11:48:53] <doener> what's it?
[11:48:55] <aatch> I think it was germany that wanted Google to pay for the snippets on Google News from german sites
[11:49:04] *** Quits: ryo (Mibbit@moz-C2182715.fibertel.com.ar) (Quit: http://www.mibbit.com ajax IRC Client)
[11:49:07] <dbaupp> doener: https://github.com/mozilla/rust/pull/7029
[11:49:20] *** Quits: int3_ (int3_@moz-ABE52D50.hsd1.ca.comcast.net) (Ping timeout)
[11:49:29] *** Quits: aruniiird (arun@280AB1CD.70AE5D19.261E7448.IP) (Ping timeout)
[11:49:34] <Luqman> dbaupp: yea, bjz_ mentioned it a few days ago and I thought i'd give it a try
[11:49:44] <MaikKlein> aatch, yeah...
[11:50:01] <dbaupp> Luqman: what was the problem?
[11:50:37] <MaikKlein> I have no idea what politicians are so crazy
[11:50:37] *** Joins: nielsle (nielsle@moz-5CE8ECCD.boa.fiberby.dk)
[11:50:40] <MaikKlein> why*
[11:50:49] <MaikKlein> at least sometimes
[11:51:03] <dbaupp> Luqman: (also, if ModuleReducedGraphParent is a newtype struct/enum then you can just do `let parent_mod = *parent;`, I think)
[11:51:44] <Luqman> dbaupp: when you have a static fn in an impl it creates a new module. So with 2 impls it'd be trying to create the same module twice hence the error about previous definitions
[11:52:10] <dbaupp> oh, neat fix! :)
[11:52:43] *** Quits: quvarxa (chatzilla@moz-60654F71.lns21.adl2.internode.on.net) (Quit: ChatZilla 0.9.90 [Firefox 22.0/20130605070403])
[11:54:02] <MaikKlein> do you have winter in new zealand?
[11:54:08] <MaikKlein> like snow?
[11:54:13] *** kimundi is now known as zz_kimundi
[11:55:04] <aatch> MaikKlein, no, at least not in the north island
[11:55:26] <aatch> it did snow, once, in the dead middle of winter a couple years ago.
[11:55:41] <dbaupp> MaikKlein: the south island has (some of) the best skiing in the south hemisphere, so I've been told
[11:56:11] <aatch> dbaupp, so I have been told too. Also, the mountains the middle of the north island are popular too.
[11:56:19] <MaikKlein> yeah I should probably do some research, I have absolutely no information about NZ :D
[11:57:17] *** Quits: bjz_ (brendanzab@B398BE78.F804C29E.D35A31DF.IP) (Connection reset by peer)
[11:57:20] *** Joins: bjz (brendanzab@B398BE78.F804C29E.D35A31DF.IP)
[11:58:25] <aatch> MaikKlein, well, it's not too hard to get in, and if you hang out in Wellington, you'd be fine. Lot's of immigrants round here.
[11:58:43] *** Quits: victorporof (victorporo@FE2F04DC.63E19875.D111398B.IP) (Quit: victorporof)
[12:00:03] <aatch> Also, the IT industry is booming here. Everybody is like "Oh, it so hard to get a job! Woe is me!". I'm like "Two weeks, didn't even finish applying for unemployment benefit"
[12:00:35] <Jesse> fn main() { error!(~"bye") }
[12:00:36] <Jesse> rust: ~"~\"bye\""
[12:00:53] <Jesse> why so much ~ " \
[12:01:16] <MaikKlein> aatch, haha
[12:01:19] <dbaupp> Jesse: error!(foo) just calls fmt!("%?", foo)
[12:01:26] <Luqman> dbaupp: thanks, realized i don't even have to do that since using methods on it autodereferencesq
[12:02:49] <dbaupp> Luqman: even better!
[12:03:49] <Luqman> and with that, time for bed. (it's already 8am)
[12:04:27] <dbaupp> Luqman: you're doing clocks backwards ;P
[12:04:57] <Luqman> dbaupp: standard weekend bedtime :P
[12:05:50] *** Joins: Sorella (queen@B12A78F5.BA14766C.95C8B7C6.IP)
[12:06:30] *** Joins: BitPuffin (quassel@moz-E3EC9C54.cust.tele2.se)
[12:06:30] <MaikKlein> haha google doesn't seem to like germany at all http://i.imgur.com/402IaYF.png 
[12:07:04] <ssbr> Man, this is a little absurd: https://gist.github.com/ssbr/739069ae43b481c80a25
[12:07:13] <MaikKlein> for those who don't know, the German Empire doesn't exist anymore :p
[12:07:19] <ssbr> I get the importance of line 2 and so on, but how do I get rid of line 14?
[12:07:50] <ssbr> I know I can do "let mut ... = ...", but I can't see where to put "mut" in the arm of a match
[12:08:04] <ssbr> and some trivial things show that it should already be mutable anyway...
[12:08:09] <jensnockert> bjz: Yeah, I did some analysis on the issue, it is just an issue of precision.
[12:08:13] <ssbr> rusti: match (1, 2) { (a, b) => { a += 1; a} }
[12:08:13] -rusti- 2
[12:08:16] <ssbr> confusing!
[12:08:29] <dbaupp> ssbr: does BinaryTreeNode(t, mut left, mut right) work?
[12:08:35] *** Quits: BitPuffin (quassel@moz-E3EC9C54.cust.tele2.se) (Ping timeout)
[12:08:41] <aatch> ssbr you can put mut in the match
[12:08:54] <dbaupp> rusti: match (~[1,2], 2) { (a, b) => { a.push(3), a } }
[12:08:55] -rusti- <anon>:10:50: 10:51 error: expected `;` or `}` after expression but found `,`
[12:08:55] -rusti- <anon>:10          match (~[1,2], 2) { (a, b) => { a.push(3), a } }
[12:08:55] -rusti-                                                             ^
[12:08:55] -rusti- application terminated with error code 101
[12:08:58] <jensnockert> bjz: 0.8 * 6.0 isn't exact in IEEE 754 double-precision, it just accidentally is in single-precision.
[12:08:59] <ssbr> dbaupp: error: found `mut` in ident position
[12:09:09] <dbaupp> rusti: match (~[1,2], 2) { (a, b) => { a.push(3); a } }
[12:09:11] -rusti- more than 5 lines of output, pastebinned: http://sprunge.us/hLVU
[12:09:20] <dbaupp> rusti: match (~[1,2], 2) { (mut a, b) => { a.push(3); a } }
[12:09:21] -rusti- more than 5 lines of output, pastebinned: http://sprunge.us/LhCB
[12:09:22] *** Joins: BitPuffin (quassel@moz-E3EC9C54.cust.tele2.se)
[12:09:33] <dbaupp> ssbr: :(
[12:09:39] <ssbr> dbaupp: isn't it just so :( ?
[12:09:58] <ssbr> aatch: it doesn't look as if I can
[12:10:07] <aatch> rusti: let mut a = Some(~1); match a { Some(mut ref z) => println(fmt!(z)), _ => () }
[12:10:08] -rusti- more than 5 lines of output, pastebinned: http://sprunge.us/OPJB
[12:10:20] *** Joins: jack (jack@moz-F1B36F9F.hsd1.nm.comcast.net)
[12:10:40] <ssbr> aatch: I want a mutable variable containing an owned pointer, not an immutable variable containing a mutable borrowed pointer
[12:10:44] <ssbr> if I understand it right
[12:10:56] <ssbr> (it should be ref mut anyway)
[12:12:47] <MaikKlein> bjz, btw are you the author of http://open.gl/ ?
[12:13:06] <ssbr> BTW, if anyone has any other comments on the style of my code, please feel free to give them. I don't know what's idiomatic or not, I just struggled until I found a way to do what I want that didn't fail the borrow checker et al
[12:13:27] <ssbr> (e.g. especially that silly swap, is specifically so that the borrow checker doesn't complain about aliasing)
[12:15:10] <dbaupp> ssbr: does `*self = match *self { .. }` work at all?
[12:15:40] <dbaupp> rusti: let mut v = ~[1,2]; v = match v { _ => ~[] }; v
[12:15:41] -rusti- ~[]
[12:16:07] <dbaupp> rusti: let mut v = ~[1,2]; v = match v { [a,b] => ~[b,a], _ => v }; v
[12:16:08] -rusti- ~[2, 1]
[12:16:27] <ssbr> dbaupp: you know, that was a variant I hadn't tried
[12:16:34] <ssbr> I generally assigned to *self in the body
[12:16:35] <ssbr> give me a moment
[12:16:36] *** Quits: jack (jack@moz-F1B36F9F.hsd1.nm.comcast.net) (Ping timeout)
[12:17:19] <dbaupp> rusti: let mut v = ~[~[1],~[2]]; v = match v { [a,b] => ~[b,a], _ => v }; v
[12:17:20] -rusti- ~[~[2], ~[1]]
[12:17:48] *** Quits: tgt (tgt@moz-D59EE478.aztw.cable.virginmedia.com) (Quit: Computer has gone to sleep.)
[12:18:19] <ssbr> dbaupp: oh, no, because then I'd be moving out of a dereference of a &mut pointer (self)
[12:19:15] <MaikKlein> rusti: let mut v = ~[~[1],~[2]]; v = match v { ~[a,b] => ~[b,a], _ => v }; v
[12:19:16] -rusti- more than 5 lines of output, pastebinned: http://sprunge.us/cXPf
[12:19:31] *** Joins: MrFahrenheit (RageOfThou@3FEF494C.29C984D5.783DEDCA.IP)
[12:19:38] *** Joins: caitp (caitp@moz-9FE842F.cpe.net.cable.rogers.com)
[12:20:25] <MaikKlein> why can I do  match v { [a,b] => ~[b,a]?
[12:20:35] <MaikKlein> shouldn't it be  match v { ~[a,b] => ~[b,a]
[12:21:59] <ssbr> MaikKlein: the pattern for vecs doesn't have the pointer sigils
[12:22:10] <dbaupp> rusti: fn foo(x: &mut (~[int],)) { *x = match *x { ([a,b],) => (~[b,a],), _ => (~[],) } } let mut x = (~[1,2],); foo(&mut x)
[12:22:11] -rusti- ()
[12:22:33] <dbaupp> rusti: fn foo(x: &mut (~[int],)) { *x = match *x { ([a,b],) => (~[b,a],), _ => (~[],) } } let mut x = (~[1,2],); foo(&mut x); x
[12:22:34] -rusti- (~[2, 1],)
[12:23:09] <dbaupp> rusti: fn foo(x: &mut ~[~[int]]) { *x = match *x { [a,b] => ~[b,a], _ => ~[] } } let mut x = ~[~[1],~[2]]; foo(&mut x); x
[12:23:10] -rusti- more than 5 lines of output, pastebinned: http://sprunge.us/gAGJ
[12:23:58] <ssbr> rusti: let mut v = ~[1, 2]; v = match v {[a, b] => ~[b, a]; other => other}; v
[12:23:59] -rusti- <anon>:10:60: 10:61 error: expected `,` but found `;`
[12:23:59] -rusti- <anon>:10          let mut v = ~[1, 2]; v = match v {[a, b] => ~[b, a]; other => other}; v
[12:23:59] -rusti-                                                                       ^
[12:23:59] -rusti- application terminated with error code 101
[12:24:10] <ssbr> rusti: let mut v = ~[1, 2]; v = match v {[a, b] => ~[b, a], other => other}; v
[12:24:11] -rusti- ~[2, 1]
[12:24:24] <MaikKlein> let s = ~"Hello"  let b = match s { str => 1}; b
[12:24:40] <MaikKlein> rusti: let s = ~"Hello"  let b = match s { str => 1, _ => 2}; b
[12:24:41] -rusti- <anon>:10:27: 10:30 error: expected `;` but found `let`
[12:24:41] -rusti- <anon>:10          let s = ~"Hello"  let b = match s { str => 1, _ => 2}; b
[12:24:41] -rusti-                                      ^~~
[12:24:41] -rusti- application terminated with error code 101
[12:24:53] <MaikKlein> rusti: let s = ~"Hello";  let b = match s { str => 1, _ => 2}; b
[12:24:54] -rusti- more than 5 lines of output, pastebinned: http://sprunge.us/iIWg
[12:25:12] <MaikKlein> rusti: let s = ~"Hello";  let b = match s { "Hello" => 1, _ => 2}; b
[12:25:13] -rusti- more than 5 lines of output, pastebinned: http://sprunge.us/UPCh
[12:25:28] <MaikKlein> rusti: let s = ~"Hello";  let b = match s { ~"Hello" => 1, _ => 2}; b
[12:25:29] -rusti- 1
[12:25:32] <MaikKlein> hm
[12:25:43] <MaikKlein> so it's only for vectors that I don't have to add the ~ ?
[12:25:51] <MaikKlein> why is that?
[12:26:19] <aatch> MaikKlein, because it destructures.
[12:27:07] <aatch> rusti: let a = ~[1,2,3]; match a { ~[1, 2, 3] => "Spoon", _ => "Spork" }
[12:27:09] -rusti- more than 5 lines of output, pastebinned: http://sprunge.us/iebY
[12:27:14] <aatch> rusti: let a = ~[1,2,3]; match a { [1, 2, 3] => "Spoon", _ => "Spork" }
[12:27:15] -rusti- "Spoon"
[12:28:05] <MaikKlein> so I can't pattern match if a vector is ~ or @?
[12:28:11] <aatch> MaikKlein, you can.
[12:28:17] <dbaupp> aatch: that doesn't explain why only vecs don't require the sigil
[12:28:18] <ssbr> MaikKlein: there's multiple examples above of exactly that
[12:28:26] <ssbr> dbaupp: don't strings not require sigils either?
[12:28:34] <dbaupp> ssbr: nope
[12:28:43] <ssbr> strings do require sigils? absurd.
[12:28:46] <dbaupp> rusti: match ~"" { ~"" => true, _ => false }
[12:28:48] -rusti- true
[12:28:51] <ssbr> That doesn't make any sense at all.
[12:28:58] <dbaupp> rusti: match ~"" { "" => true, _ => false }
[12:28:59] -rusti- more than 5 lines of output, pastebinned: http://sprunge.us/XeWS
[12:29:12] <ssbr> rusti: stop being inconsistent you jerk
[12:29:13] -rusti- <anon>:10:14: 10:19 error: expected `;` or `}` after expression but found `being`
[12:29:13] -rusti- <anon>:10          stop being inconsistent you jerk
[12:29:13] -rusti-                         ^~~~~
[12:29:13] -rusti- application terminated with error code 101
[12:29:16] <aatch> dbaupp, from the error it looks like it's because ~[a,b,c] is interpreted as ~([a, b, c])
[12:29:42] <aatch> because [a,b,c] is completely different type of pattern to even ~"string"
[12:29:44] <dbaupp> aatch: oh... that's silly
[12:30:09] <aatch> and since ~-vecs are not ~-ptrs, it doesn't like it
[12:30:38] <dbaupp> rusti: let x: [int, .. 3] = [1,2,3]; match x { [a,b,c] => (a,b,c), _ => fail!("useless") }
[12:30:39] -rusti- (1, 2, 3)
[12:30:57] <dbaupp> rusti: let x: ~([int, .. 3]) = ~([1,2,3]); match x { [a,b,c] => (a,b,c), _ => fail!("useless") }
[12:30:58] -rusti- more than 5 lines of output, pastebinned: http://sprunge.us/BKhZ
[12:30:59] <aatch> rusti: let a = ~([1,2,3]); match a { ~[a,b,c] => (c,b,a), _ => fail!() }
[12:31:01] -rusti- (3, 2, 1)
[12:31:12] <MaikKlein> ah ok
[12:31:39] <aatch> MaikKlein, the ongoing dynamically-sized types proposal should help straighten this out.
[12:31:41] <MaikKlein> now i get it
[12:31:54] <ssbr> Is there a way to get around writing the exact same functions twice, once each for &-ptrs and once for &mut-ptrs?
[12:31:57] <ssbr> it's getting annoying
[12:32:36] <aatch> ssbr, you might be able to use &const
[12:32:37] <MaikKlein> I think const is for this problem
[12:32:43] <ssbr> aha!
[12:32:49] <ssbr> that is something I'm not familiar with at all
[12:33:45] <aatch> though I'm not sure how long it will stick around
[12:33:56] <ssbr> I do believe this is an undocumented feature
[12:34:00] <ssbr> can't find it in http://static.rust-lang.org/doc/rust.html
[12:34:13] <ssbr> or in http://static.rust-lang.org/doc/tutorial.html
[12:34:17] <dbaupp> ssbr: undocumented... like half of Rust :P
[12:34:33] <ssbr> dbaupp: all the rust bits I know are documented... ;_;
[12:34:37] <MaikKlein> you just need to stick around in the irc long enough
[12:34:39] <MaikKlein> :D
[12:34:41] <ssbr> OK, maybe not all of them
[12:34:45] <ssbr> but most of them for sure
[12:35:00] *** Joins: jrfeenst (jrfeenst@moz-F912484F.cpe.norwoodlight.com)
[12:35:12] <dbaupp> ssbr: there's all these secret features that you'll never know :P
[12:35:34] <ssbr> Those features don't deserve me!
[12:35:36] * ssbr huffs
[12:35:39] <cmr> It's slated to be cut afaik
[12:35:46] <dbaupp> heh :)
[12:35:49] <aatch> ssbr, we all talk about them when you're not here
[12:35:54] <MaikKlein> const is going away?
[12:35:57] <doener> ssbr: https://gist.github.com/dotdash/76a1eabdd87a38eb5174
[12:36:07] <cmr> &const yeah
[12:36:27] <MaikKlein> what's the replacement then?
[12:36:34] <aatch> MaikKlein, better semantics
[12:37:42] <dbaupp> rusti: match 1 { ref mut x => { *x += 1; *x } }
[12:37:45] -rusti- 2
[12:37:46] *** Joins: Yurume_ (yurume@AC58A8CE.8A059B47.E313B915.IP)
[12:38:27] <doener> ssbr: you can even drop the Copy trait bound on T, that was for some other thing I tried earlier
[12:38:44] *** Quits: Yurume (yurume@AC58A8CE.8A059B47.E313B915.IP) (Ping timeout)
[12:39:17] <ssbr> doener: man, what
[12:39:20] <doener> ssbr: oh wait... the middle one doesn't swap back anymore
[12:39:24] <ssbr> I swear I tried something that simple
[12:39:40] <ssbr> oh right
[12:39:51] <ssbr> yes, that middle one becomes problematic because you're borrowing rather than taking ownership
[12:40:04] <ssbr> but you can't take ownership and also use the owned things in the guard
[12:43:09] <cmr> Eridius: I don't have any plans for that personally. All I planned on doing was getting color working. Feel free to add it though :)
[12:44:31] <cmr> MaikKlein: Hows's the autocomplete coming? :)
[12:45:17] <MaikKlein> cmr, well I know how to use the front end now, and I also found a way to find all types but the /middle thing is completely strange
[12:45:49] <cmr> MaikKlein: Yeah, middle is really hairy :(
[12:45:54] *** Joins: jack (jack@moz-F1B36F9F.hsd1.nm.comcast.net)
[12:46:57] <MaikKlein> cmr, the problem is I don't really know where I have to look. I would need a way to trace the compiler
[12:47:41] <MaikKlein> can't I debug the compiler somehow?
[12:48:53] <MaikKlein> cmr, well I am not much further than this tutorial that I wrote yesterday :( http://maikklein.github.io/2013/06/08/how-to-hack-rustc/
[12:50:39] *** Joins: victorporof (victorporo@FE2F04DC.63E19875.D111398B.IP)
[12:51:19] *** Quits: donri (dag@moz-9BB61102.tbcn.telia.com) (Ping timeout)
[12:52:44] *** Quits: jack (jack@moz-F1B36F9F.hsd1.nm.comcast.net) (Ping timeout)
[12:55:06] *** Joins: sankha93 (Instantbir@915679EA.CB400184.8B6C1D65.IP)
[12:56:55] *** Quits: Blub\w (wry@7E3BB9D.71150E1A.237AE2BA.IP) (Quit: bb2m)
[12:56:56] <MaikKlein> hm can you change your usename in reddit?
[12:57:09] <aatch> MaikKlein, it seems so
[12:58:20] <dbaupp> MaikKlein: http://www.reddit.com/r/help/wiki/faq#wiki_is_it_possible_to_change_my_username.3F
[12:58:57] <MaikKlein> lol
[12:58:59] <MaikKlein> "note that if your account is deleted, nobody can ever use that username again"
[12:59:45] <dbaupp> heh... if reddit is around in 20 years, all the usernames will be 30 characters long, or be full of weird unicode ones
[13:00:50] <MaikKlein> yeah xXXXxXXXXxMaikKlein
[13:01:20] *** Quits: victorporof (victorporo@FE2F04DC.63E19875.D111398B.IP) (Quit: victorporof)
[13:05:15] <dbaupp> bjz, jensnockert: you guys are making Rust into an amazing numerics language!
[13:05:22] * jensnockert hugs dbaupp.
[13:05:25] <jensnockert> You too!
[13:07:17] <MaikKlein> how can I force my github repo to contain the same files as my local repo? 
[13:07:30] <aatch> MaikKlein, push -f
[13:07:34] <MaikKlein> hm
[13:07:36] <MaikKlein> did that 
[13:07:45] <MaikKlein> but it doesn't delete old files for some reason
[13:07:56] <dbaupp> MaikKlein: files or branches?
[13:08:28] <MaikKlein> dbaupp, files I guess, I only have a master branch
[13:11:46] <aatch> MaikKlein, for the deleted files, did you actually do git rm on them?
[13:15:32] <MaikKlein> no I just deleted them and did git add . and git commit
[13:16:03] <MaikKlein> but I remember that this worked in the past, dunno maybe I have to use git rm :/
[13:16:04] <aatch> MaikKlein, yeah, you need to actually tell git you deleted them
[13:16:13] <aatch> or use git commit -a
[13:16:30] <jensnockert> bjz,dbaupp: We should have a module for getting low-level floating-point exceptions
[13:16:50] <dbaupp> jensnockert: the hardware ones?
[13:16:50] *** Quits: wuwei|offline (wuwei@1A513F49.818D7924.FAA9ED67.IP) (Connection reset by peer)
[13:16:54] <jensnockert> dbaupp: Yes.
[13:17:08] <dbaupp> jensnockert: this module could also include setting rounding modes?
[13:17:18] <jensnockert> dbaupp: That would make sense imho.
[13:17:22] *** Joins: wuwei|offline (wuwei@1A513F49.818D7924.FAA9ED67.IP)
[13:18:19] *** Quits: Blei (philipp@moz-96D25F7A.cust.bluewin.ch) (Quit: WeeChat 0.4.1)
[13:20:20] <jensnockert> dbaupp: At least on platforms that have dynamic rounding modes.
[13:20:36] <dbaupp> jensnockert: arm doesn't?
[13:20:36] <jensnockert> dbaupp: (That probably means all non-GPU platforms)
[13:20:43] <dbaupp> oh, GPUs
[13:21:34] *** Joins: jack (jack@moz-F1B36F9F.hsd1.nm.comcast.net)
[13:21:52] <dbaupp> yes, presumably setting rounding modes should be cfg'd out on platforms that don't support it? (or silently ignored?)
[13:30:37] *** Quits: MaikKlein (maik@moz-B464C230.dip0.t-ipconnect.de) (Quit: Leaving)
[13:30:47] *** Joins: MaikKlein (maik@moz-B464C230.dip0.t-ipconnect.de)
[13:31:28] *** Quits: jack (jack@moz-F1B36F9F.hsd1.nm.comcast.net) (Ping timeout)
[13:31:30] *** Joins: victorporof (victorporo@FE2F04DC.63E19875.D111398B.IP)
[13:32:40] *** Joins: Cromulent (Cromulent@moz-983B638D.cable.virginmedia.com)
[13:36:08] <jensnockert> dbaupp: Should throw error / compilation error.
[13:36:23] <MaikKlein> ah okay
[13:36:29] <jensnockert> Urgh btw, fma is broken
[13:36:34] <jensnockert> (At least on OS X)
[13:36:37] <MaikKlein> you don't need to use git rm you can just do a git add -u .
[13:36:48] <jensnockert> Because it is broken in libc on OS X.
[13:37:47] *** Quits: victorporof (victorporo@FE2F04DC.63E19875.D111398B.IP) (Ping timeout)
[13:38:31] <dbaupp> jensnockert: yeah... conditionally compiliting it via cfg would give an error... that's not very user friendly though :(
[13:39:14] <jensnockert> dbaupp: On the other hand, people running such Rust code on such weird systems probably know what they are doing.
[13:40:11] <dbaupp> heh
[13:41:35] <dbaupp> I'd imagine a `#[error(reason="unsupported platform")] fn foo()` attribute would be feasible (which would make the compiler print an appropriate message whenever foo was used)
[13:43:38] *** Quits: Cromulent (Cromulent@moz-983B638D.cable.virginmedia.com) (Quit: KVIrc 4.2.0 Equilibrium http://www.kvirc.net/)
[13:44:49] <jensnockert> Hm uncovering more and more errors in FP in Rust /o\
[13:45:45] <dbaupp> 's/uncovering/fixing/; s@/o\@\o/@' you mean ;P
[13:46:23] *** Joins: donri (dag@moz-9BB61102.tbcn.telia.com)
[13:47:09] <jensnockert> dbaupp: I hope we'll fix them, but just finding them is hard work :S
[13:47:23] <dbaupp> what're the problems?
[13:48:13] <jensnockert> Well, one_plus_eps(one_plus_eps, -one_plus_two_eps) should be zero, but it is not.
[13:48:18] <jensnockert> That is an issue with libc though.
[13:48:33] <jensnockert> But the smallest representable floating-point number prints as zero.
[13:48:42] <jensnockert> Which is more of an issue with Rust.
[13:49:47] <jensnockert> On the other, no one else is going to be using this silly format string :S
[13:51:18] <jensnockert> one_plus_eps.mul_add(one_plus_eps, -one_plus_two_eps)*
[13:54:00] <MaikKlein> rusti: 0.000001
[13:54:01] -rusti- 0.000001
[13:54:49] <MaikKlein> rusti: 0.000001 == 0
[13:54:50] -rusti- more than 5 lines of output, pastebinned: http://sprunge.us/gNHI
[13:55:01] <MaikKlein> rusti: 0.000001 == 0.0
[13:55:01] -rusti- false
[13:55:12] *** Joins: true_droid (Adium@moz-123FD9B8.beck.volia.net)
[13:55:22] <dbaupp> jensnockert: eurgh, floating point semantics are hard
[13:55:52] <MaikKlein> how many digits does a double have again?
[13:55:58] <MaikKlein> behind the .
[13:56:03] <EXetoC> ~17
[13:56:04] <MaikKlein> 12?
[13:56:04] <jensnockert> MaikKlein: 53
[13:56:09] <MaikKlein> what
[13:56:11] <jensnockert> (binary)
[13:56:16] <MaikKlein> well
[13:56:34] <jensnockert> 4.94065645841246544176568792868221372E-324 is the smallest double.
[13:56:44] <aatch> "If you think you understand quantum physics... Good job! Now you can try IEEE floating point numbers"
[13:56:52] <MaikKlein> :D
[13:57:21] *** Quits: aatch (aatch@moz-2BB0AC01.cable.telstraclear.net) (Client exited)
[13:57:57] <MaikKlein> didn't even know that we can go so precise
[13:58:15] <dbaupp> rusti: 4.94065645841246544176568792868221372E-324
[13:58:16] -rusti- 0
[13:58:20] <jesse99> we can't :-)
[13:58:24] <MaikKlein> rusti: 0.00000000000000001
[13:58:24] <dbaupp> rusti: 4.94065645841246544176568792868221372E-324 == 0
[13:58:26] -rusti- 0
[13:58:26] -rusti- more than 5 lines of output, pastebinned: http://sprunge.us/ZUiQ
[13:58:30] <jesse99> or rather we can, but only for small numbers
[13:58:34] <MaikKlein> rusti: 0.0000000000000001
[13:58:35] -rusti- 0
[13:58:35] <jensnockert> Or big ones.
[13:58:38] <MaikKlein> rusti: 0.000000000000001
[13:58:39] -rusti- 0
[13:58:42] <MaikKlein> rusti: 0.000000000001
[13:58:43] -rusti- 0
[13:58:44] <jensnockert> rusti: 179769313486231680088648464220646842686668242844028646442228680066046004606080400844208228060084840044686866242482868202680268820402884062800406622428864666882406066422426822086680426404402040202424880224808280820888844286620802664406086660842040886824002682662666864246642840408646468824200860804260804068888.0
[13:58:45] -rusti- inf
[13:58:47] <MaikKlein> rusti: 0.000000001
[13:58:48] -rusti- 0
[13:58:51] <MaikKlein> rusti: 0.000001
[13:58:51] -rusti- 0.000001
[13:58:52] <dbaupp> rusti: 4.94065645841246544176568792868221372E-324 == 0.0
[13:58:53] -rusti- false
[13:58:55] <EXetoC> 0.0000000000000001f64
[13:58:56] <jensnockert> Err that's another bug
[13:59:00] <MaikKlein> rusti: 0.0000001
[13:59:01] -rusti- 0.0000001
[13:59:04] <EXetoC> rusti 0.0000000000000001f64
[13:59:04] <MaikKlein> rusti: 0.00000001
[13:59:05] -rusti- 0.00000001
[13:59:07] <EXetoC> bah
[13:59:07] <MaikKlein> rusti: 0.000000001
[13:59:08] -rusti- 0
[13:59:09] <EXetoC> rusti: 0.0000000000000001f64
[13:59:10] <jesse99> well you still have lots of digits for large numbers, but the gaps between values get larger and larger
[13:59:10] -rusti- 0
[13:59:10] <MaikKlein> ah
[13:59:24] <MaikKlein> ok
[13:59:27] <MaikKlein> at 9 digits
[13:59:30] <MaikKlein> it is just 0
[13:59:37] <EXetoC> rusti: 0.000000000001f64
[13:59:38] -rusti- 0
[13:59:46] <dbaupp> jensnockert: that huge one should finite?
[13:59:52] <engla> MaikKlein: that's just the printing precision
[13:59:53] <jensnockert> dbaupp: Nope.
[14:00:05] <dbaupp> rusti: 1797693134862316800886484642206468426866682428440286464422286800660460046060804008442082280600848400446868662424828682026802688204028840628004066224288646668824060664224268220866804264044020402024248802248082808208888442866208026644060866608420408868240026826626668642466428404086464688242008608042608040688.0
[14:00:06] -rusti- line longer than 150 columns, pastebinned: http://sprunge.us/HgFi
[14:00:16] <MaikKlein> rusti: 0.000000001 == 0
[14:00:17] -rusti- more than 5 lines of output, pastebinned: http://sprunge.us/VfPi
[14:00:21] <MaikKlein> rusti: 0.000000001 == 0.0
[14:00:23] -rusti- false
[14:00:26] <MaikKlein> oh
[14:00:29] <jensnockert> rusti: 179769313486231680088648464220646842686668242844028646442228680066046004606080400844208228060084840044686866242482868202680268820402884062800406622428864666882406066422426822086680426404402040202424880224808280820888844286620802664406086660842040886824002682662666864246642840408646468824200860804260804068888.0 == std::float::infinity
[14:00:30] -rusti- true
[14:00:35] <MaikKlein> okay didn't know that
[14:00:43] <jensnockert> rusti: 179769313486231680088648464220646842686668242844028646442228680066046004606080400844208228060084840044686866242482868202680268820402884062800406622428864666882406066422426822086680426404402040202424880224808280820888844286620802664406086660842040886824002682662666864246642840408646468824200860804260804068887.0 == std::float::infinity
[14:00:44] -rusti- true
[14:00:48] <ssbr> This fails on line 8: https://gist.github.com/ssbr/d97d9707b19beed4902e
[14:00:53] <jensnockert> rusti: 17976931348623168008864846422064684268666824284402864644222868006604600460608040084420822806008484004468686624248286820268026882040288406280040662242886466688240606642242682208668042640440204020242488022480828082088884428662080266440608666084204088682400268266266686424664284040864646882420086080426080406888.0 == std::float::infinity
[14:00:54] <MaikKlein> rusti: std::float::infinity
[14:00:54] -rusti- false
[14:00:55] -rusti- inf
[14:00:58] <ssbr> that boggles my mind. Can anyone point to anything I'm missing?
[14:01:12] *** Joins: reyre_ (reyre@moz-9002CDDA.cpe.net.cable.rogers.com)
[14:01:13] *** Joins: jack (jack@moz-F1B36F9F.hsd1.nm.comcast.net)
[14:01:31] <ssbr> (FWIW: enum BST { BinaryTreeNode(...), BinaryEmpty })
[14:01:32] <dbaupp> ssbr: the enum only has 2 variants?
[14:01:35] <ssbr> dbaupp: yes
[14:01:54] <dbaupp> ssbr: are there globals statics called 't' or 'left' or 'right'?
[14:01:55] *** Quits: wuwei|offline (wuwei@1A513F49.818D7924.FAA9ED67.IP) (Connection reset by peer)
[14:02:05] <ssbr> oh. ew.
[14:02:08] <jensnockert> ssbr: Isn't it just the comma being in the wrong place?
[14:02:17] <EXetoC> there better not be one called t :>
[14:02:18] <ssbr> yes, there's a local left and right
[14:02:28] *** Joins: wuwei|offline (wuwei@1A513F49.818D7924.FAA9ED67.IP)
[14:02:38] <dbaupp> ssbr: it only matters if they are `static`
[14:02:50] <ssbr> oh. slightly less ew. No, no statics.
[14:03:15] <ssbr> jensnockert: where?
[14:03:16] <dbaupp> ssbr: can you println(fmt!("%?", nonempty))?
[14:03:22] <jensnockert> ssbr: On line 8.
[14:03:31] <EXetoC> MaikKlein: 12? single precision?
[14:03:37] <dbaupp> jensnockert: the trailing comma shouldn't matter
[14:03:56] <jensnockert> dbaupp: And the missing one on the line before?
[14:03:58] <dbaupp> ssbr: I'd guess there's a bug that stops the first pattern from matching, but that's pretty strange
[14:04:05] <MaikKlein> EXetoC, no I meant double, we learned that float has 6 and double 12
[14:04:15] <dbaupp> jensnockert: don't need them for match arms with { }, only for a plain expression
[14:04:18] <MaikKlein> or was it 12 and 24
[14:04:18] <EXetoC> f32: 6-9 decimal digits and f64: 15-17 yeah?
[14:04:20] <MaikKlein> what ever
[14:04:24] <ssbr> dbaupp: ~BinaryEmpty
[14:04:26] <jensnockert> dbaupp: I learn something every day.
[14:04:33] <dbaupp> ssbr: :(
[14:04:37] <ssbr> :(
[14:04:38] <MaikKlein> ahh right
[14:04:39] <dbaupp> jensnockert: as do i :)
[14:04:42] <MaikKlein> i forgot about x64
[14:04:44] <MaikKlein> :x
[14:05:10] <ssbr> I will see if I can reduce this to a smaller test case then
[14:05:11] <dbaupp> ssbr: what about match (*left, *right) { ... }?
[14:05:34] <jensnockert> EXetoC: 24 binary / 53 binary.
[14:05:53] <dbaupp> rusti: enum Foo {A, B} match (~A, ~A) { (~A, ~A) => true, _ => false }
[14:05:55] -rusti- true
[14:06:43] <ssbr> dbaupp: that works
[14:06:49] <EXetoC> right
[14:06:54] <dbaupp> ssbr: :D
[14:06:58] *** Joins: erickt (Adium@49C4075F.3AC15C18.2321E71E.IP)
[14:06:59] <ssbr> dbaupp: how is that :D?
[14:07:05] <ssbr> it means there's another bug in rust! I hate bugs in rust
[14:07:07] <dbaupp> ssbr: well it works
[14:07:34] *** Quits: jack (jack@moz-F1B36F9F.hsd1.nm.comcast.net) (Ping timeout)
[14:08:16] <ssbr> it'd be so much better if one could go, "no, you're wrong, there's a static somewhere" and then I'd ctrl+f for statics again and be like "oh my mistake, of course, rust could never be buggy, it was my own fault"
[14:08:19] *** Joins: wilsonk|2 (kvirc@moz-39EFBFC2.cg.shawcable.net)
[14:08:39] <ssbr> ah well
[14:09:07] *** Quits: wilsonk-laptop (kvirc@moz-39EFBFC2.cg.shawcable.net) (Ping timeout)
[14:09:14] <jensnockert> ssbr: That's the spirit, eradicate them all!
[14:09:22] <dbaupp> ssbr: yeah, I really want rust to be bugless, so we can say "must trust rust" ;D
[14:09:49] *** Quits: tiffany (kawaii@moz-1E0FE6E8.dhcp.embarqhsd.net) (Ping timeout)
[14:10:07] <jensnockert> rusti: let zero:float = 0.0; zero.next_after(1.0)
[14:10:08] -rusti- 0
[14:10:14] <jensnockert> rusti: let zero:float = 0.0; zero.next_after(1.0) == 0.0
[14:10:15] -rusti- false
[14:10:31] <dbaupp> rusti: let zero:float = 0.0; 1.0/zero.next_after(1.0)
[14:10:31] -rusti- inf
[14:10:54] <jensnockert> float::infinity.next_after(1.0)
[14:11:04] <jensnockert> rusti: float::infinity.next_after(1.0)
[14:11:05] -rusti- more than 5 lines of output, pastebinned: http://sprunge.us/jIgg
[14:11:12] <dbaupp> rusti: std::float::infinity.next_after(1.0)
[14:11:14] -rusti- line longer than 150 columns, pastebinned: http://sprunge.us/YJcA
[14:11:23] <ssbr> dbaupp: hahahahaha, yes please!
[14:11:43] <dbaupp> ssbr: you'll have to thanks aatch for that one
[14:11:53] <jensnockert> rusti: 179769313486231680088648464220646842686668242844028646442228680066046004606080400844208228060084840044686866242482868202680268820402884062800406622428864666882406066422426822086680426404402040202424880224808280820888844286620802664406086660842040886824002682662666864246642840408646468824200860804260804068888.0
[14:11:54] -rusti- inf
[14:12:04] <jensnockert> Wtf is this trickery.
[14:12:13] <doener> dbaupp: the download location say dist/rust though
[14:12:31] *** Quits: sankha93 (Instantbir@915679EA.CB400184.8B6C1D65.IP) (Quit: Instantbird 1.4 -- http://www.instantbird.com)
[14:12:39] *** Quits: BitPuffin (quassel@moz-E3EC9C54.cust.tele2.se) (Ping timeout)
[14:13:10] <dbaupp> jensnockert: presumably the float parser doesn't handle it properly
[14:13:26] <jensnockert> dbaupp: Very likely.
[14:14:13] <EXetoC> rusti: 2579592754897652347865347826598236859612346218473648712461794632819764327846238742317462334173498217489247289172891347289-e50 > 9000.0
[14:14:13] -rusti- <anon>:9:23: 9:24 error: int literal is too large
[14:14:14] -rusti- <anon>:9     println(fmt!("%?", {
[14:14:14] -rusti-                                 ^
[14:14:14] -rusti- application terminated with error code 101
[14:14:38] <EXetoC> rusti: 257959275489765234786534782659823685961234621847364871246179463281-e20 > 9000.0
[14:14:38] -rusti- <anon>:9:23: 9:24 error: int literal is too large
[14:14:38] -rusti- <anon>:9     println(fmt!("%?", {
[14:14:39] <dbaupp> rusti: fmt!("%64t", unsafe { cast::transmute::<float, u64>(float::infinity.next_after(1.0)) })
[14:14:39] -rusti-                                 ^
[14:14:39] -rusti- application terminated with error code 101
[14:14:40] -rusti- more than 5 lines of output, pastebinned: http://sprunge.us/aBWK
[14:15:02] <dbaupp> rusti: fmt!("%64t", unsafe { std::cast::transmute::<float, u64>(std::float::infinity.next_after(1.0)) })
[14:15:03] -rusti- more than 5 lines of output, pastebinned: http://sprunge.us/gYQj
[14:15:15] <dbaupp> rusti: fmt!("%64t", unsafe { std::cast::transmute::<float, uint>(std::float::infinity.next_after(1.0)) })
[14:15:16] -rusti- ~" 111111111101111111111111111111111111111111111111111111111111111"
[14:15:34] <EXetoC> we should have a rusti channel
[14:16:43] <jensnockert> Added a bug https://github.com/mozilla/rust/issues/7030
[14:16:56] <jensnockert> EXetoC: True.
[14:18:15] <EXetoC> we're both swedish? dude, that is awesome
[14:19:00] <ssbr> EXetoC: you can just privmsg rusti and it works fine.
[14:19:29] <ssbr> /msg rusti 1
[14:19:31] <ssbr> -rusti- 1
[14:21:06] *** Joins: jack (jack@moz-F1B36F9F.hsd1.nm.comcast.net)
[14:21:16] *** Quits: reyre_ (reyre@moz-9002CDDA.cpe.net.cable.rogers.com) (Client exited)
[14:21:33] <dbaupp> rusti: 179769313486231580788648464220646842686668242844028646442228680066046004606080400844208228060084840044686866242482868202680268820402884062800406622428864666882406066422426822086680426404402040202424880224808280820888844286620802664406086660842040886824002682662666864246642840408646468824200860804260804068887.0 == std::float::infinity.next_after(1.0)
[14:21:34] -rusti- true
[14:21:44] <dbaupp> jensnockert: ^
[14:23:31] *** Quits: spider-mario (spidermari@moz-AC2C1EAE.rev.sfr.net) (Input/output error)
[14:24:15] <jensnockert> dbaupp: What did you do different from me?
[14:24:31] <jensnockert> rusti: std::float::infinity.next_after(1.0)
[14:24:33] -rusti- line longer than 150 columns, pastebinned: http://sprunge.us/TDZj
[14:24:48] *** zz_kimundi is now known as kimundi
[14:24:50] <dbaupp> jensnockert: mine goes ...62315 near the start
[14:24:55] <jensnockert> 179769313486231580788648464220646842686668242844028646442228680066046004606080400844208228060084840044686866242482868202680268820402884062800406622428864666882406066422426822086680426404402040202424880224808280820888844286620802664406086660842040886824002682662666864246642840408646468824200860804260804068887.0 == std::float::infinity.next_after(1.0)
[14:25:14] <dbaupp> jensnockert: sorry, ...62315807, and the 5 and the 7 are different
[14:25:17] <jensnockert> dbaupp: Oh, it might be the output code that is wrong.
[14:25:27] *** Joins: reyre_ (reyre@moz-9002CDDA.cpe.net.cable.rogers.com)
[14:26:27] <dbaupp> rusti: 179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368L
[14:26:27] -rusti- <anon>:9:23: 9:24 error: int literal is too large
[14:26:27] -rusti- <anon>:9     println(fmt!("%?", {
[14:26:27] -rusti-                                 ^
[14:26:27] -rusti- application terminated with error code 101
[14:26:35] <dbaupp> rusti: 179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.0
[14:26:36] -rusti- line longer than 150 columns, pastebinned: http://sprunge.us/LYVT
[14:27:00] <dbaupp> jensnockert: that's what Python/numpy says is inf.nextafter(1.)
[14:27:41] <jensnockert> dbaupp: Yeah, just compared to C, and it diverges pretty early.
[14:31:00] <dbaupp> jensnockert: so it's mostly the printer then?
[14:31:07] <jensnockert> dbaupp: Most likely.
[14:31:37] <jensnockert> dbaupp: Are you huonw btw?
[14:31:47] <dbaupp> yeah, putting the Rust-printed one into python gives inf, but the python one gives the proper thing
[14:31:50] <dbaupp> and yes
[14:32:17] <kimundi> accuratly printing/parsing floating point numbers is hard if you don't want to use bignums, so the current algorithm doesn't try to be accurate :P
[14:32:37] <jensnockert> kimundi: It should try to be accurate ;)
[14:32:50] *** Quits: reyre_ (reyre@moz-9002CDDA.cpe.net.cable.rogers.com) (Client exited)
[14:36:31] *** Quits: wuwei|offline (wuwei@1A513F49.818D7924.FAA9ED67.IP) (Connection reset by peer)
[14:36:33] *** Joins: victorporof (victorporo@FE2F04DC.63E19875.D111398B.IP)
[14:37:02] *** Joins: wuwei|offline (wuwei@1A513F49.818D7924.FAA9ED67.IP)
[14:38:45] *** Quits: victorporof (victorporo@FE2F04DC.63E19875.D111398B.IP) (Ping timeout)
[14:39:29] *** Joins: __matt (bekkah@moz-87C9B5EC.unitymediagroup.de)
[14:43:48] *** Quits: __matt (bekkah@moz-87C9B5EC.unitymediagroup.de) (Ping timeout)
[14:45:24] *** Joins: BitPuffin (quassel@260D9792.B4985FA1.CB45D44D.IP)
[14:46:27] <cmr> MaikKlein: You can set RUST_LOG=rustc=4, but thatwillgiveyouway more information than you want
[14:47:00] <cmr> MaikKlein: I think you want tobe looking at rustc::resolve
[14:47:02] *** Quits: ssbr (ssbr@moz-F4C1E66D.dsl.bell.ca) (Ping timeout)
[14:48:23] <MaikKlein> cmr, thanks I'll try that. I already looked at resolve and though several files like mod.rs, where I found the type system
[14:53:28] <cmr> MaikKlein: For example see resolve_methods
[14:54:07] <cmr> The resolve code is clear as mud :)
[14:54:53] <MaikKlein> ok maybe I didn't see this function, thanks
[14:58:04] *** Quits: wuwei|offline (wuwei@1A513F49.818D7924.FAA9ED67.IP) (Connection reset by peer)
[14:58:30] *** Joins: wuwei|offline (wuwei@1A513F49.818D7924.FAA9ED67.IP)
[14:58:52] *** Joins: Guest (textual@moz-A3295542.nycmny.fios.verizon.net)
[14:59:46] *** Joins: SiegeLord (sl@moz-CAF07B4C.hsd1.ma.comcast.net)
[14:59:47] *** Quits: Guest (textual@moz-A3295542.nycmny.fios.verizon.net) (Quit: My MacBook Pro has gone to sleep. ZZZzzz)
[15:01:49] *** Joins: ssbr (ssbr@moz-C9F16F18.dsl.bell.ca)
[15:04:26] *** Quits: jrfeenst (jrfeenst@moz-F912484F.cpe.norwoodlight.com) (Quit: jrfeenst)
[15:06:18] *** Quits: engla (engla@moz-DBD1D96E.cust.bredbandsbolaget.se) (Ping timeout)
[15:08:04] *** Joins: sebcrozet (Mibbit@moz-2517AE39.w80-13.abo.wanadoo.fr)
[15:09:32] *** Quits: an0nymous (an0nymous@moz-A6B0CE4.tx.res.rr.com) (Quit: Leaving)
[15:12:13] *** Joins: an0nymous (an0nymous@moz-A6B0CE4.tx.res.rr.com)
[15:12:14] *** Joins: jrfeenst (jrfeenst@moz-F912484F.cpe.norwoodlight.com)
[15:13:12] *** Joins: int3_ (int3_@moz-ABE52D50.hsd1.ca.comcast.net)
[15:14:31] <sebcrozet> Hello guys!
[15:14:57] *** Quits: int3_ (int3_@moz-ABE52D50.hsd1.ca.comcast.net) (Ping timeout)
[15:15:32] <sebcrozet> Im working on a physics engine. Got a few questions.
[15:16:24] <kimundi> Hi! Just ask them. :)
[15:16:38] <sebcrozet> ok.
[15:16:52] <sebcrozet> Is there any kind of Downcasting in Rust?
[15:17:47] <kimundi> In what sense? Going from Trait -> Type ?
[15:17:53] <sebcrozet> yep
[15:18:17] <kimundi> Not really, no. :(
[15:18:50] <sebcrozet> I tryed a cast::transmute but it complains about the pointers size.
[15:19:31] <kimundi> sebcrozet: That's because for example a @Trait has not the same memory layout as a @Type
[15:20:20] <kimundi> a @Trait is a tuple of (ptr to data, ptr to vtable), but the @Type is just (ptr to data)
[15:22:06] <sebcrozet> kimundi: Ok.
[15:22:20] <kimundi> It might be posible to add some safe way of downcasting (pattern match on trait object maybe?) But that's not something that's currently being discussed or much demanded
[15:22:45] <kimundi> You could use enums for that thoug
[15:23:09] <sebcrozet> Yep, Ill do that. But enums are closed.
[15:23:58] <sebcrozet> And I have quite a lot of different types implementing the same traits (at least 20)
[15:24:02] <kimundi> And with that I mean: If you want downcasting, that means you already know wich specific types you're going to get. SO instead of trait objects, you might instead just use a enum variant for each possible type
[15:25:02] <sebcrozet> Enums are like ADT right?
[15:26:05] <MaikKlein> will we get default methods in 0.7?
[15:26:28] <dbaupp> MaikKlein: seems unlikely
[15:26:34] <kimundi> Sorry, what do you mean with ADT here? I can never remember wether the A it means Algebraic or Abstract :P
[15:26:37] <dbaupp> MaikKlein: it'd be nice though
[15:26:42] <MaikKlein> the first one
[15:26:47] <sebcrozet> kimundi: Algebraic.
[15:27:09] <MaikKlein> dbaupp, would be really nice indeed
[15:27:13] <EXetoC> remember? well it's both depending on the context
[15:27:35] <ssbr> kimundi: it means both!
[15:27:55] <kimundi> sebcrozet: In this case, yes enums in rust are Algebraic. 
[15:28:16] <EXetoC> FTW YO
[15:28:49] <kimundi> sebcrozet: In fact, all of rusts types are algebraic :P
[15:30:05] *** Joins: jviereck (Adium@moz-2C3A9E25.dip0.t-ipconnect.de)
[15:30:39] <MaikKlein> can someone give me a good example of ADT's and why they are so useful? 
[15:30:47] *** Joins: BizarreCake (BizarreCak@32C9829A.151E84E7.561471F8.IP)
[15:31:08] <MaikKlein> I mean what I see when  look at enums is that they somehow group types together
[15:31:23] <sebcrozet> kimundi: A trait is an algebraic type (Im thinking of ADT as in Haskell)?
[15:32:19] <EXetoC> MaikKlein: http://static.rust-lang.org/doc/core/option.html
[15:32:43] <EXetoC> enum Option<T> { Some(T), None }
[15:33:11] *** Quits: caitp (caitp@moz-9FE842F.cpe.net.cable.rogers.com) (Ping timeout)
[15:33:14] <sebcrozet> MaikKlein: enums and ADT are the same in rust (afaik).
[15:34:54] <ssbr> sebcrozet: traits are like typeclasses...
[15:35:01] <ssbr> they apply to any type, algebraic or not
[15:35:20] *** Joins: thou (thou@moz-1C1CA9F7.fasttrackcomm.net)
[15:35:20] <SiegeLord> Does anybody know if anybody is working on rustdoc?
[15:35:24] <kimundi> sebcrozet: Well I don't actually know what I'm talking about here, but I think a Traitobject can be seen as one in the sense that its a tupel of (data ptr, vtable ptr)
[15:35:25] <ssbr> MaikKlein: the Option type is really quite amazing. :)
[15:36:26] <MaikKlein> so basically ADT's are necessary in languages without inheritance.
[15:37:00] <MaikKlein> so you can describe a relation
[15:37:03] *** Joins: victorporof (victorporo@FE2F04DC.63E19875.D111398B.IP)
[15:37:18] <EXetoC> I don't know about that
[15:39:15] *** Quits: victorporof (victorporo@FE2F04DC.63E19875.D111398B.IP) (Ping timeout)
[15:39:25] <sebcrozet> MaikKlein: In Haskell you can emulate inheritance without ADT.
[15:40:14] <sebcrozet> MaikKlein: Using stuffs like universal quantification (folall) and other compiler extensions.
[15:40:40] <MaikKlein> sebcrozet, dunno I am just used to languages like c++ java etc and I am trying to figure out how to think functional
[15:40:40] <EXetoC> MaikKlein: implementing some trait is basically like inheriting, and it can be polymorphic depending on how you use it
[15:40:54] <kimundi> MaikKlein, a Algebraic typesystem means that every type is explictly build out of a combination of other types with strict rules
[15:42:23] <EXetoC> fn get(&self) -> Option<int> { if (self.has_stuff) { Some(self.val) } else { None } }
[15:42:31] <MaikKlein> would this make some sense? enum Human { Arm, Leg, Head} 
[15:42:55] <koomi> sebcrozet: it's existential quantification actually
[15:43:00] <EXetoC> let human: Human = Leg;
[15:43:00] <kimundi> For example a tuple (T, U) is always the product of type T and type U. Option<T> is always either Some(T) or None. uint is always a integer of machine word size etc
[15:43:03] <EXetoC> :>
[15:43:08] <EXetoC> barely
[15:43:11] *** Joins: reyre_ (reyre@moz-9002CDDA.cpe.net.cable.rogers.com)
[15:43:37] <MaikKlein> ahh okay
[15:43:54] <EXetoC> enum Human { Male, Female } let john: Human = Male;
[15:44:01] <kimundi> In contrast, javas type system is not algebraic, because every type T can be either T or null, without that being part of the type description
[15:45:04] *** Quits: reyre_ (reyre@moz-9002CDDA.cpe.net.cable.rogers.com) (Ping timeout)
[15:45:20] <sebcrozet> MaikKlein: Use a tuple to say that "and": Human = (Arm, Leg, Head) means that the human has those three parts simultaneously.
[15:45:27] <dbaupp> kimundi: doesn't that mean that Haskell's isn't algebraic also?
[15:46:00] <sebcrozet> MaikKlein: An ADT is to say "or": enum Human = { Man, Woman } means that the human is either a man or a woman, but not both.
[15:46:07] <MaikKlein> so it would make sense to write enum drinkable { cola, water}
[15:46:17] <kimundi> Don't know enoug of either haskel nor type systems to answer thet :P
[15:46:32] <kimundi> MaikKlein: Yes
[15:46:51] <sebcrozet> MaikKlein: Yep. But I think "enum Drink = { Cola, Water }" is better (no "able" suffix).
[15:46:55] <koomi> dbaupp: Haskell's datatypes are ADTs
[15:47:26] <MaikKlein> but once I do let a = Cola; a is not a cola it is a Drink
[15:47:49] <MaikKlein> wait I can try this
[15:48:00] <koomi> MaikKlein: yes, Drink is the Type, Cola is the value
[15:48:02] <kimundi> MaikKlein: Right, the type is always 'Drink'
[15:48:22] <MaikKlein> ahh
[15:48:23] <MaikKlein> okay
[15:48:26] <kimundi> The type has the meaning 'either Cola or Water'
[15:48:33] <sebcrozet> MaikKlein: You can think of ADTs as C/C++ nasty "union".
[15:48:50] <MaikKlein> I never learned about unions because the book that I read says that unions are bad
[15:49:03] <MaikKlein> rusti: enum Drink { Cola, Water}; let a = Cola;
[15:49:04] -rusti- ()
[15:49:07] <MaikKlein> rusti: enum Drink { Cola, Water}; let a = Cola; a
[15:49:08] -rusti- Cola
[15:49:12] <MaikKlein> cool
[15:49:13] <MaikKlein> okay
[15:49:14] <kimundi> If you want to have just 'Cola', you need a seperate 'struct Cola;'
[15:49:14] <MaikKlein> got it
[15:49:44] <MaikKlein> rusti: enum Drink { Cola, Water}; let a: Drink = Cola; a
[15:49:45] -rusti- Cola
[15:51:36] <MaikKlein> rusti: enum Drink { Cola, Water}; impl Drink{ fn print(){println("hello"}; } let a = Cola; a.print();
[15:51:36] -rusti- <anon>:10:74: 10:75 error: incorrect close delimiter: `}`
[15:51:37] -rusti- <anon>:10          enum Drink { Cola, Water}; impl Drink{ fn print(){println("hello"}; } let a = Cola; a.print();
[15:51:37] -rusti-                                                                                     ^
[15:51:37] -rusti- application terminated with error code 101
[15:51:45] <MaikKlein> rusti: enum Drink { Cola, Water}; impl Drink{ fn print(){println("hello")}; } let a = Cola; a.print();
[15:51:46] -rusti- <anon>:10:76: 10:77 error: unexpected token: `;`
[15:51:46] -rusti- <anon>:10          enum Drink { Cola, Water}; impl Drink{ fn print(){println("hello")}; } let a = Cola; a.print();
[15:51:46] -rusti-                                                                                       ^
[15:51:46] -rusti- application terminated with error code 101
[15:51:55] <MaikKlein> rusti: enum Drink { Cola, Water}; impl Drink{ fn print(){println("hello")} } let a = Cola; a.print();
[15:51:56] -rusti- more than 5 lines of output, pastebinned: http://sprunge.us/EMIO
[15:52:22] <MaikKlein> rusti: enum Drink { Cola, Water}; impl Drink{ fn print(&self){println("hello")} } let a = Cola; a.print();
[15:52:23] -rusti- hello
[15:52:23] -rusti- ()
[15:52:24] *** Joins: mflamer (Mibbit@moz-C6ED16AA.hsd1.ca.comcast.net)
[15:53:12] <sebcrozet> Is there automatic inlining yet?
[15:53:56] *** Quits: skchrko_ (sk@61A494B3.BA40E8A.AAC02D62.IP) (Connection reset by peer)
[15:53:59] *** Joins: skchrko_ (sk@61A494B3.BA40E8A.AAC02D62.IP)
[15:54:32] *** Joins: victorporof (victorporo@FE2F04DC.63E19875.D111398B.IP)
[15:54:36] <MaikKlein> btw if I would write a hello world program in c++ and rust. And I would both compile them would they look similar in Assembler?
[15:55:22] <MaikKlein> because I saw .cpp files in rust and I was wondering if rust compiles to some c++ under the hood
[15:55:59] <dbaupp> sebcrozet: there's always been automatic inlining
[15:56:09] <jesse99> the cpp files are part of the rust runtime, rust code doesn't compile to c++
[15:56:13] *** Quits: igl (igl@moz-EDD2E3B6.adsl.alicedsl.de) (Ping timeout)
[15:56:15] *** Joins: Blei (philipp@moz-96D25F7A.cust.bluewin.ch)
[15:56:16] *** Joins: caitp (caitp@moz-9FE842F.cpe.net.cable.rogers.com)
[15:56:29] <dbaupp> sebcrozet: (except for cross-crate inlining, which still requires #[inline]/#[inline(always)])
[15:57:01] *** Joins: igl (igl@moz-9E1F1B1.adsl.alicedsl.de)
[15:58:11] <sebcrozet> dbaupp: ok. And the cross-crate inlining will be automated in the future?
[15:58:11] *** Joins: judder (maradukewa@85208D00.97F8E51D.E305BD61.IP)
[15:58:26] <dbaupp> sebcrozet: not sure, seems unlikely
[15:59:08] <dbaupp> sebcrozet: I could imagine it for very small functions maybe, but it all this metadata makes the compiled crates large
[15:59:44] *** Quits: jviereck (Adium@moz-2C3A9E25.dip0.t-ipconnect.de) (Quit: Leaving.)
[16:00:39] <sebcrozet> dbaupp: But for cross-crate trait implementation or generic structure specialization, the compiler already have to keep the source code somewhere right?
[16:01:30] <sebcrozet> dbaupp: So cross-crate inlining could already be possible, at least for generic stuffs
[16:02:26] <dbaupp> probably... I'm not really sure how it works
[16:03:41] <sebcrozet> ok
[16:05:52] <Blei> i'm pretty sure cross-crate inling already works
[16:06:21] <Blei> else all the inline declarations in libstd are quite meaningless
[16:06:46] *** Quits: wuwei|offline (wuwei@1A513F49.818D7924.FAA9ED67.IP) (Connection reset by peer)
[16:07:11] *** Joins: wuwei|offline (wuwei@1A513F49.818D7924.FAA9ED67.IP)
[16:07:19] <Blei> ah, sorry, are you talking about inlining without adding declarations? that probably doesn't work
[16:07:20] <dbaupp> Blei: yeah, that works, this is a slightly different thing
[16:07:27] <dbaupp> yeas
[16:07:35] <dbaupp> s/a//
[16:07:43] <Blei> sorry, i missed the beginning of the conversation
[16:08:05] *** Quits: true_droid (Adium@moz-123FD9B8.beck.volia.net) (Quit: Leaving.)
[16:08:37] <mflamer> does anyone have a more recent windows build of rustc than the installer? I'm not really setup to build from source. 
[16:09:36] <MaikKlein> can't we just screw windows over for https://github.com/mozilla/rust/pull/6661 ?
[16:10:31] <MaikKlein> kinda want EFP now :p
[16:11:51] <dbaupp> mflamer: the build-bots are continually building on windows... I'm not sure if it's at all possible to retrieve the result though
[16:12:05] <dbaupp> mflamer: you'd have to talk to graydon/email the mailing list
[16:12:33] <mflamer> ok, I'll try that
[16:14:26] <sebcrozet> Is there a way to use a pointer (@mut Whatever) as a HashMap key?
[16:15:08] *** cscottnet_away is now known as cscottnet
[16:16:13] <mflamer> I think Eq is implemented for pointers. I did compare == with some @mut recently and it seemed to work
[16:16:43] <sebcrozet> Well, here I need Hash.
[16:17:08] *** Joins: zofrex (Mibbit@moz-CFD5D022.cable.virginmedia.com)
[16:17:41] <sebcrozet> And it complains about IterByte not being implemented.
[16:17:57] <MaikKlein> sebcrozet, so you want to store the pointer address as a key value?
[16:18:08] <dbaupp> sebcrozet: do you want it hashed with respect to the contents of the @mut pointer, or just as the raw address of the pointer?
[16:18:37] <zofrex> What would be good modules to look at / techniques to use to distribute a large number of tasks (1000s) across a small number of threads (10s)?
[16:18:39] <sebcrozet> dbaupp: Just the raw adress.
[16:19:25] <MaikKlein> I think this is only possible in unsafe code
[16:19:28] <dbaupp> rusti: (@mut 1) as *int
[16:19:29] -rusti- more than 5 lines of output, pastebinned: http://sprunge.us/HOai
[16:19:41] <dbaupp> rusti: (@mut 1) as *mut int
[16:19:42] -rusti- more than 5 lines of output, pastebinned: http://sprunge.us/cYNT
[16:19:57] <zofrex> I know my way around chans and sharedchans, and I can easily say spawn a task for every single job to do, but that's rather inefficient in this case
[16:20:01] <MaikKlein> I saw sth called RawPtr
[16:20:02] <dbaupp> I'm inclined to agree with MaikKlein
[16:20:42] <sebcrozet> Maybe we can convert a pointer to an integer, and then use it as a key?
[16:21:05] <MaikKlein> well I don't think that the language will allow that
[16:21:05] <dbaupp> rusti: std::ptr::to_unsafe_ptr(@mut 1) as uint
[16:21:06] -rusti- 139637492351072
[16:21:10] <MaikKlein> y
[16:21:17] <MaikKlein> in u
[16:21:20] <dbaupp> rusti: std::ptr::to_mut_unsafe_ptr(@mut 1) as uint
[16:21:21] -rusti- 140665973440608
[16:21:27] <MaikKlein> makes sense in unsafe code
[16:21:36] <dbaupp> sebcrozet: you probably want the second one
[16:21:40] <MaikKlein> wait
[16:21:44] <MaikKlein> hm
[16:22:02] <dbaupp> sebcrozet: otherwise you could get runtime failures if the @mut is modified... maybe
[16:22:07] <MaikKlein> ok but you can't get the value where the ptr points to right?
[16:22:12] <MaikKlein> at least not in safe code
[16:22:27] <dbaupp> MaikKlein: correct. dereferencing an unsafe pointer is unsafe
[16:22:36] <dbaupp> but acquiring one (normally) isn't
[16:23:12] *** Quits: jrfeenst (jrfeenst@moz-F912484F.cpe.norwoodlight.com) (Quit: jrfeenst)
[16:24:06] *** Quits: KindOne (KindOne@moz-FFCAD1D.dynamic.ip.windstream.net) (Ping timeout)
[16:24:07] <sebcrozet> Ok. Thx. So there is no safe way to do that.
[16:24:35] *** Joins: Cromulent (Cromulent@moz-983B638D.cable.virginmedia.com)
[16:24:45] <dbaupp> sebcrozet: it is safe
[16:25:18] *** Joins: KindOne (KindOne@moz-8D92DF9A.dynamic.ip.windstream.net)
[16:25:21] <dbaupp> (you aren't ever reading from the memory that the unsafe pointer points to)
[16:26:23] <sebcrozet> dbaupp: I have my pointer as a HashMap key. But this pointer is shared with other structures which might want to modify its content.
[16:27:41] <sebcrozet> dbaupp: Ah, ok. You are saying that it is safe as long as I dont read the unsafe pointer itself. Reading the original @mut is still safe.
[16:28:01] <dbaupp> it should be
[16:30:01] <sebcrozet> Ill try that. thx.
[16:30:17] *** Quits: MaikKlein (maik@moz-B464C230.dip0.t-ipconnect.de) (Ping timeout)
[16:32:07] *** Quits: victorporof (victorporo@FE2F04DC.63E19875.D111398B.IP) (Quit: victorporof)
[16:32:47] *** cscottnet is now known as cscottnet_away
[16:32:51] *** cscottnet_away is now known as cscottnet
[16:39:16] *** Quits: sebcrozet (Mibbit@moz-2517AE39.w80-13.abo.wanadoo.fr) (Quit: http://www.mibbit.com ajax IRC Client)
[16:41:00] *** Joins: jrfeenst (jrfeenst@moz-F912484F.cpe.norwoodlight.com)
[16:43:04] *** Quits: z0w0 (zack@FDF4EF6A.2CA5CD8.5F93A189.IP) (Client exited)
[16:44:17] *** Quits: Cromulent (Cromulent@moz-983B638D.cable.virginmedia.com) (Quit: KVIrc 4.2.0 Equilibrium http://www.kvirc.net/)
[16:47:27] *** Joins: miseria (Mibbit@moz-9578F42A.ee.protectedgroup.com)
[16:47:36] *** Quits: miseria (Mibbit@moz-9578F42A.ee.protectedgroup.com) (User has been banned from Mozilla (no spamming here))
[16:50:57] *** Joins: steven_is_false (user@moz-144077DE.bchsia.telus.net)
[16:53:21] *** Joins: deepdog (deepdog@moz-490E834C.client.mchsi.com)
[16:54:28] <steven_is_false> dbaupp: So I made the pull request like you wanted https://github.com/mozilla/rust/pull/7027
[16:58:23] *** Quits: BitPuffin (quassel@260D9792.B4985FA1.CB45D44D.IP) (Client exited)
[17:03:27] *** Quits: Diamond (dick@moz-625C0DAF.ks.ok.cox.net) (Client exited)
[17:03:54] *** Joins: MaikKlein (maik@moz-B464C230.dip0.t-ipconnect.de)
[17:04:04] *** Joins: dylukes (dylukes@moz-E4DF3FED.pitbpa.fios.verizon.net)
[17:04:10] *** Quits: infynyxx (infynyxx@moz-E95B370B.nyc.res.rr.com) (Client exited)
[17:04:27] <dbaupp> steven_is_false: yay! looks good! :)
[17:04:32] *** Quits: BizarreCake (BizarreCak@32C9829A.151E84E7.561471F8.IP) (Connection reset by peer)
[17:04:36] <steven_is_false> dbaupp: cool
[17:04:57] <MaikKlein> what looks good?
[17:05:18] *** Quits: judder (maradukewa@85208D00.97F8E51D.E305BD61.IP) (Ping timeout)
[17:05:33] <steven_is_false> MaikKlein: dbaupp was talking about my pull request https://github.com/mozilla/rust/pull/7027
[17:06:17] <SiegeLord> Is there a way to convert things (integers, floats) to string without allocating memory?
[17:06:50] <kimundi> SiegeLord: Currently no, I have some unfinished code lying around to fix that though
[17:07:57] <kimundi> SiegeLord: Floats withouth memory allocation is going to be hard, though
[17:08:01] *** Joins: pyrac (pyrac@moz-96C2FD1F.w109-214.abo.wanadoo.fr)
[17:08:15] <SiegeLord> kimundi, I'm just looking for a callback version
[17:08:47] <kimundi> SiegeLord: Yeah, that's what it's going to be
[17:08:59] <kimundi> SiegeLord: I'm just stuck at floats atm
[17:10:10] <SiegeLord> Also... I can't seem to find a function that converts a float to the scientific notation
[17:10:37] <kimundi> Yeah, that doesn"t seem to exist
[17:10:42] <dbaupp> SiegeLord: there isn't one
[17:11:16] <steven_is_false> What does everyone think about running the Windows configuration of Rust under WINE so as to test under Valgrind?
[17:11:17] <MaikKlein> what is a RibKind? I mean what does Rib stand for?
[17:11:26] <SiegeLord> Hmm... that's unfortunate
[17:11:35] <kimundi> But generating that string is easy, just normalise your float and tack on the exponent
[17:11:44] *** Joins: mib_nzn7tq (Mibbit@moz-9BBC8BC6.range86-149.btcentralplus.com)
[17:12:06] <Blei> steven_is_false: your indentation is off by one starting line35 until the end of the function
[17:12:06] <MaikKlein> steven_is_false, wine doesn't emulate, it converts the code to linux afaik
[17:12:16] <SiegeLord> kimundi, Like using frexp?
[17:12:29] <steven_is_false> MaikKlein: So?
[17:12:42] <kimundi> SiegeLord: Just use log
[17:12:51] <SiegeLord> rusti: (1.34e-5).frexp()
[17:12:52] -rusti- more than 5 lines of output, pastebinned: http://sprunge.us/UadB
[17:13:01] <kimundi> rusti: 1596.9856_f64.log(10)
[17:13:02] -rusti- more than 5 lines of output, pastebinned: http://sprunge.us/RBPc
[17:13:06] *** Quits: bytbox (s@moz-D83E9B31.wireless.umd.edu) (Ping timeout)
[17:13:08] <SiegeLord> rusti: (1.34e-5_f32).frexp()
[17:13:09] -rusti- (0.87818241, -16)
[17:13:11] <MaikKlein> steven_is_false, so I don't think that you can get a reasonable output with valgrind but I am not an expert
[17:13:34] <kimundi> (1.34e-5_f32).log(10f64)
[17:13:37] <steven_is_false> Blei: Thanks!
[17:13:42] <kimundi> rusti: (1.34e-5_f32).log(10f64)
[17:13:48] -rusti- more than 5 lines of output, pastebinned: http://sprunge.us/HgZd
[17:14:01] <kimundi> rusti: (1.34e-5_f32).log(10f32)
[17:14:03] -rusti- -4.87289524
[17:14:25] <kimundi> rusti: (1.34e-5_f32).log(10f32).floor()
[17:14:26] -rusti- -5
[17:14:28] <steven_is_false> MaikKlein: I looked it up, and it seems like one can (although there have been various bugs.)
[17:15:44] <MaikKlein> steven_is_false, it definitely would make things easier, if it works for you, please let me know :)
[17:16:10] <steven_is_false> Anyways, my distrobutions WINE is currently broken on 64 bit so I was wondering if anyone else could try running the Windows configuration of Rust on Valgrind under WINE?
[17:17:40] <SiegeLord> rusti: let f = 1.34e-5_f32; let e = (f).log(10f32).floor(); let m = f / 10f32.pow(e); (m, e)
[17:17:41] -rusti- (1.34000003, -5)
[17:18:05] *** Joins: parcha (quassel@moz-A9A9F340.hsd1.ma.comcast.net)
[17:18:07] <MaikKlein> does anyone know what Rib stands for? (in rustc)
[17:18:22] <SiegeLord> rusti: let f = 10.34e-5_f32; let e = (f).log(10f32).floor(); let m = f / 10f32.pow(e); (m, e)
[17:18:23] -rusti- (1.03400004, -4)
[17:20:01] <MaikKlein> omg I think I just figured out how to implement autocompletion for rust
[17:20:34] <kimundi> fn sci(v: f64) -> ~str { let e = v.log(10f64).floor(); (v / 10f64.pow(e)).to_str() + "e" + e.to_str() } sci(1.64e-5_f64)
[17:20:46] <kimundi> rusti: fn sci(v: f64) -> ~str { let e = v.log(10f64).floor(); (v / 10f64.pow(e)).to_str() + "e" + e.to_str() } sci(1.64e-5_f64)
[17:20:48] -rusti- ~"1.64e-5"
[17:20:52] <kimundi> SiegeLord: ^
[17:21:11] <kimundi> rusti: fn sci(v: f64) -> ~str { let e = v.log(10f64).floor(); (v / 10f64.pow(e)).to_str() + "e" + e.to_str() } sci(1.64e5_f64)
[17:21:12] -rusti- ~"1.64e5"
[17:21:39] <SiegeLord> I wonder if that's really correct... should the leading digit be 0 or 1?
[17:22:18] <kimundi> rusti: fn sci(v: f64) -> ~str { let e = v.log(10f64).floor()+1.0; (v / 10f64.pow(e)).to_str() + "e" + e.to_str() } sci(1.64e5_f64)
[17:22:20] -rusti- ~"0.164e6"
[17:22:21] <SiegeLord> Well, probably doesn't matter for me... +- one significant digit won't make a difference
[17:23:18] <SiegeLord> fn sci(v: f64) -> ~str { let e = v.log(10f64).floor(); (v / 10f64.pow(e)).to_str() + "e" + e.to_str() } sci(1.6400001e5_f64)
[17:23:24] <SiegeLord> rusti: fn sci(v: f64) -> ~str { let e = v.log(10f64).floor(); (v / 10f64.pow(e)).to_str() + "e" + e.to_str() } sci(1.6400001e5_f64)
[17:23:26] -rusti- ~"1.6400001e5"
[17:23:36] <SiegeLord> Ok, great... thanks kimundi
[17:23:45] <kimundi> rusti: fn sci(v: f64) -> ~str { let e = v.log(10f64).floor()+1.0; f64::to_str(v / 10f64.pow(e)) + "e" + e.to_str() } sci(1.64e5_f64)
[17:23:51] -rusti- more than 5 lines of output, pastebinned: http://sprunge.us/gNNX
[17:23:59] <kimundi> rusti: fn sci(v: f64) -> ~str { let e = v.log(10f64).floor()+1.0; std::f64::to_str(v / 10f64.pow(e)) + "e" + e.to_str() } sci(1.64e5_f64)
[17:24:01] -rusti- ~"0.1640000000000000124344978758017532527446746826171875e6"
[17:24:07] <kimundi> there we go
[17:24:10] <SiegeLord> That's just excessive :P
[17:24:54] <kimundi> SiegeLord: .to_str rounds to 8 (or 6?) digits after the dot, the standalon fn.... keeps going until ther are no mor bits :P
[17:25:12] <kimundi> Of course it's not more accurate
[17:25:57] <kimundi> I've seen the papers that explain how to print/floats most optimal... I was not smart enough for them :P
[17:26:12] <MaikKlein> hmm
[17:26:34] <MaikKlein> core still exists? I am in rustc and just found use core::str::each_split_str;
[17:26:42] <MaikKlein> I thought it is std:: now
[17:27:01] <kimundi> MaikKlein: It seems to still exist in a backwards-compatible kinda way I think?
[17:27:02] <doener> it's aliased, stage0 still needs it
[17:27:12] <dbaupp> MaikKlein: all those libraries have had to alias core = std and std = extra
[17:27:41] <MaikKlein> ah ok
[17:28:03] <doener> src/librustc/rustc.rc:extern mod core(name = "std");
[17:30:25] <MaikKlein> I am so exited now
[17:30:28] <zofrex> I figured out the answer to my own question. If you want to efficiently do 1000s of "jobs" on a small number of tasks, rather than using SharedChan like I was, you should use PortSet - source: https://github.com/mozilla/rust/issues/3928#issuecomment-10114880
[17:30:58] <MaikKlein> excited*
[17:31:34] <doener> why?
[17:32:21] <MaikKlein> I am think I just found a way get all information about rust code, so that someone could implement auto completion fairly easy
[17:33:47] <doener> I guess it's reasonably doable for other crates. But for things in the same crate that you're working on, that will likely by a lot harder.
[17:34:56] *** Joins: brson (brson@2557E599.66715431.D25A875A.IP)
[17:34:56] *** ChanServ sets mode: +o brson
[17:35:03] *** Quits: dylukes (dylukes@moz-E4DF3FED.pitbpa.fios.verizon.net) (Quit: ["Textual IRC Client: www.textualapp.com"])
[17:37:37] *** Quits: jensnockert (jensnocker@moz-8BE55278.customer.t3.se) (Input/output error)
[17:37:42] <MaikKlein> that's the cool thing, if I am write I get information for all crates
[17:37:47] <MaikKlein> right*
[17:37:48] <MaikKlein> :x
[17:38:22] <SiegeLord> rusti: fn sci(v: f64) -> ~str { let e = v.log(10f64).floor(); (v / 10f64.pow(e)).to_str() + "e" + e.to_str() } sci(-1.64e5_f64)
[17:38:24] -rusti- ~"NaNeNaN"
[17:38:31] *** Joins: jensnockert (jensnocker@moz-8BE55278.customer.t3.se)
[17:38:42] <SiegeLord> That reminds me of that "wat" video XD
[17:39:28] <MaikKlein> :D
[17:39:44] *** Quits: erickt (Adium@49C4075F.3AC15C18.2321E71E.IP) (Quit: Leaving.)
[17:39:55] <MaikKlein> if I just could compile rustc faster T_T
[17:42:22] <MaikKlein> someone was working on a jit compiler for rust right?
[17:42:31] <bstrie> dbaupp: ping
[17:42:44] <dbaupp> bstrie: pong
[17:43:00] *** Joins: strcat (strcat@moz-54F7FD49.cpe.net.cable.rogers.com)
[17:43:14] <bstrie> dbaupp: I don't understand why you changed slice to from_chars at https://github.com/mozilla/rust/pull/7032/files#L0L817
[17:43:39] <dbaupp> bstrie: because I removed slice
[17:43:47] <dbaupp> bstrie: so I needed a new example
[17:43:48] <bstrie> dbaupp: right, but you left the method
[17:43:54] <dbaupp> correct
[17:43:59] <bstrie> just making sure
[17:44:03] <dbaupp> strcat: https://github.com/mozilla/rust/pull/7032
[17:44:18] <bstrie> it's still a really ugly example
[17:44:20] <bstrie> :P
[17:44:29] <dbaupp> feel free to suggest a new one :)
[17:46:12] <MaikKlein> is there already a file writer in std or extra?
[17:46:39] <dbaupp> MaikKlein: str::io::file_writer, I think
[17:46:42] <bstrie> is there a way to tell github to show diffs that exclude whitespace changes
[17:47:14] <strcat> bstrie: ?w
[17:47:16] <SiegeLord> bstrie, Add ?w=1 to the url
[17:47:22] <bstrie> nice
[17:47:36] *** Joins: spider-mario (spidermari@moz-2F72F6FF.dsl.quantic-telecom.net)
[17:47:59] <strcat> dbaupp: hmm, what's the count member in the split iterator for?
[17:48:12] <dbaupp> strcat: limited splits
[17:48:17] <strcat> ah
[17:48:25] <strcat> so it's not used unless you pass it
[17:48:30] <dbaupp> strcat: i.e. "a b c".split(1) = "a", "b c"
[17:48:42] <dbaupp> (well, splitn_iter(' ', 1))
[17:49:03] <dbaupp> it's set to a large value by default, and so has no effect, yes
[17:49:05] <MaikKlein> thanks
[17:49:49] <strcat> dbaupp: we might want to specialize it more in the future
[17:49:51] <strcat> it's a very big struct
[17:50:07] <dbaupp> strcat: yes
[17:51:09] <dbaupp> strcat: the main reason for having it all in one was I was trying to avoid an explosion of structs and methods
[17:51:11] *** Joins: alisdair (textual@moz-EBE9F394.bchsia.telus.net)
[17:51:27] *** Joins: ghrust (ghrust@DE823A67.6A2AE50.F3114085.IP)
[17:51:28] <ghrust> 01[13rust01] 15bors pushed 0 new commits to 06auto: 02http://git.io/ouK_oQ
[17:51:28] *** Parts: ghrust (ghrust@DE823A67.6A2AE50.F3114085.IP) ()
[17:52:01] <strcat> brson: https://github.com/mozilla/rust/pull/7028 r?
[17:52:27] <MaikKlein> wait we already have a jit compiler?
[17:52:37] <strcat> LLVM does
[17:52:44] <MaikKlein> https://github.com/mozilla/rust/pull/3292
[17:52:50] <strcat> rustc's support for it doesn't really work well
[17:53:08] *** Joins: tgt (tgt@moz-D59EE478.aztw.cable.virginmedia.com)
[17:53:23] *** Quits: mflamer (Mibbit@moz-C6ED16AA.hsd1.ca.comcast.net) (Quit: http://www.mibbit.com ajax IRC Client)
[17:54:44] *** Quits: dbaupp (Thunderbir@DD5A5B3.5DFF0E76.CCE6F5F4.IP) (Ping timeout)
[17:55:32] *** Quits: tgt (tgt@moz-D59EE478.aztw.cable.virginmedia.com) (Quit: Computer has gone to sleep.)
[17:56:21] *** Joins: magg (magg@B7B2D103.77B59C03.3D0AE249.IP)
[17:56:39] *** Joins: MaikKlein1 (maik@moz-C731CFBB.dip0.t-ipconnect.de)
[17:57:07] *** Quits: deepdog (deepdog@moz-490E834C.client.mchsi.com) (Ping timeout)
[17:57:20] <magg> hello,
[17:57:29] *** Joins: youknowone (youknowone@A826BD81.8A0DEF81.38747683.IP)
[17:57:29] *** Quits: youknowone (youknowone@A826BD81.8A0DEF81.38747683.IP) (Z:lined (Open Proxy found on your host. Please visit www.blitzed.org/proxy?ip=115.68.131.49 for more information.))
[17:57:33] <MaikKlein1> .
[17:57:38] *** Quits: MaikKlein (maik@moz-B464C230.dip0.t-ipconnect.de) (Ping timeout)
[17:57:48] <MaikKlein1> ./reconnect
[17:57:53] *** Quits: MaikKlein1 (maik@moz-C731CFBB.dip0.t-ipconnect.de) (Quit: Leaving)
[17:57:56] <magg> what kind of operations can i do on vectors, besides addition/concat (+) ?
[17:57:57] *** Joins: MaikKlein1 (maik@moz-C731CFBB.dip0.t-ipconnect.de)
[17:59:06] <strcat> magg: all the methods in the vec module
[18:02:34] <magg> strcat: well yeah, i meant something like, can i use bitwise operators &,^, | directly on vectors or need to done between elements of the vectors
[18:02:39] <steven_is_false> magg: Technically, one can only do operations on owned, borrowed, and managed vectors. Vectors with a static size are automatically coerced as needed which is annoying.
[18:02:59] <strcat> magg: the operators they implement are listed in there too
[18:03:05] <strcat> magg: they're implemented via traits
[18:03:11] <magg> strcat: oh
[18:05:54] <MaikKlein1> rusti: struct Test(int); println(fmt!("%?",Test(42));
[18:05:56] -rusti- <anon>:11:4: 11:5 error: incorrect close delimiter: `}`
[18:05:56] -rusti- <anon>:11     }));
[18:05:56] -rusti-               ^
[18:05:56] -rusti- application terminated with error code 101
[18:07:06] <MaikKlein1> rusti: struct Test(int); 
[18:07:08] -rusti- ()
[18:07:21] <MaikKlein1> rusti: struct Test(int); println(fmt!("%?",Test(42)));
[18:07:22] -rusti- {__field__: 42}
[18:07:22] -rusti- ()
[18:07:26] *** Quits: pyrac (pyrac@moz-96C2FD1F.w109-214.abo.wanadoo.fr) (Quit: pyrac)
[18:08:23] *** Joins: pyrac (pyrac@moz-96C2FD1F.w109-214.abo.wanadoo.fr)
[18:08:41] *** Quits: jensnockert (jensnocker@moz-8BE55278.customer.t3.se) (Input/output error)
[18:09:18] *** Joins: devbug (quassel@moz-E1DE087C.bchsia.telus.net)
[18:09:50] *** Joins: erickt (Adium@49C4075F.3AC15C18.2321E71E.IP)
[18:12:04] *** Quits: Yurume_ (yurume@AC58A8CE.8A059B47.E313B915.IP) (Ping timeout)
[18:13:52] *** Joins: int3_ (int3_@moz-ABE52D50.hsd1.ca.comcast.net)
[18:14:32] *** Joins: infynyxx (infynyxx@moz-E95B370B.nyc.res.rr.com)
[18:16:17] *** Quits: infynyxx (infynyxx@moz-E95B370B.nyc.res.rr.com) (Ping timeout)
[18:17:23] <SiegeLord> Hmm... sometimes rust doc doesn't output any file
[18:17:47] <SiegeLord> If I run it a few more times (without changing anything) it eventually outputs something
[18:19:03] <steven_is_false> The heck? I'm profiling the build process using perf on Linux and llvm::ComputeMaskedBits took 1.04% of the cycles!
[18:20:00] *** Joins: jensnockert (jensnocker@moz-8BE55278.customer.t3.se)
[18:22:57] <steven_is_false> Most of the cycles happen in system calls though. 
[18:24:15] *** Parts: steven_is_false (user@moz-144077DE.bchsia.telus.net) (ERC Version 5.3 (IRC client for Emacs))
[18:31:32] *** Joins: Jeaye (Jeaye@moz-FD505E54.hsd1.ca.comcast.net)
[18:35:50] *** Quits: MaikKlein1 (maik@moz-C731CFBB.dip0.t-ipconnect.de) (Ping timeout)
[18:42:23] *** Joins: hjr3 (hradtke@moz-842BF853.hsd1.ca.comcast.net)
[18:44:02] *** Joins: tcsc (tcsc@moz-ADC0ED45.hsd1.ct.comcast.net)
[18:44:42] <doomlord> i was just talking to someone about C vs C++ for dsp code and wondered about rust and intrinsics..
[18:45:45] *** Joins: deepdog (deepdog@moz-490E834C.client.mchsi.com)
[18:46:01] *** Quits: hjr3 (hradtke@moz-842BF853.hsd1.ca.comcast.net) (Quit: My MacBook has gone to sleep. ZZZzzz)
[18:49:35] *** Quits: alisdair (textual@moz-EBE9F394.bchsia.telus.net) (Quit: My MacBook Pro has gone to sleep. ZZZzzz)
[18:51:35] *** Parts: jrfeenst (jrfeenst@moz-F912484F.cpe.norwoodlight.com) ()
[18:51:41] *** Joins: jrfeenst (jrfeenst@moz-F912484F.cpe.norwoodlight.com)
[18:53:27] *** Joins: engla (engla@moz-DBD1D96E.cust.bredbandsbolaget.se)
[18:57:40] <Jeaye> I'm getting a hard crash that looks like it has to do with borrowing and dynamic freezing. Anyone care to take a look? https://gist.github.com/Jeaye/8e12248aefbb65df56d8
[18:58:02] *** Joins: mzabaluev (mzabaluev@moz-91FFD755.dhcp.inet.fi)
[18:58:07] <strcat> Jeaye: yep that's from @mut
[18:58:17] <Jeaye> What can I do?
[18:58:32] <strcat> don't use @mut? ;p
[18:58:37] <magg> rusti: 'a' ^ ' b'
[18:58:39] -rusti- <anon>:10:13: 10:14 error: unterminated character constant
[18:58:39] -rusti- <anon>:10          'a' ^ ' b'
[18:58:39] -rusti-                        ^
[18:58:39] -rusti- application terminated with error code 101
[18:59:28] *** Quits: pyrac (pyrac@moz-96C2FD1F.w109-214.abo.wanadoo.fr) (Quit: pyrac)
[18:59:50] <Jeaye> strcat: I'm not sure what my other options are. I rely on the object being captured in a number of closures, so having it managed made sense.
[19:00:16] *** Joins: moonchrome (moonchrome@moz-C9D218E8.dsl.iskon.hr)
[19:00:21] <magg> rusti: 1 ^ 0;
[19:00:23] -rusti- ()
[19:00:32] <Jeaye> rusti: 1 ^ 0
[19:00:33] -rusti- 1
[19:01:17] <sp3d> rusti: ' a'
[19:01:17] -rusti- <anon>:9:23: 9:24 error: unterminated character constant
[19:01:18] -rusti- <anon>:9     println(fmt!("%?", {
[19:01:18] -rusti-                                 ^
[19:01:18] -rusti- application terminated with error code 101
[19:01:23] <magg> how can xor 2 chars?
[19:02:05] <strcat> it doesn't really make sense to do that
[19:02:17] <strcat> are you sure you should be using chars (unicode code points) and not u8?
[19:02:18] <sp3d> rusti: 'a' ^ 'a'
[19:02:18] -rusti- '\x00'
[19:02:26] <strcat> sp3d: yeah and it shouldn't have that
[19:02:29] <sp3d> ah
[19:02:33] <strcat> *yet another* soundness hole
[19:02:49] <strcat> the code point space is 21-bit
[19:02:58] <moonchrome> bjz, here ?
[19:03:01] <strcat> anything above that is totally invalid and will cause unsafety if you assume they're valid
[19:03:04] <sp3d> ah, so you could xor into an invalid char
[19:03:06] <strcat> and we do assume they're valid
[19:03:10] <strcat> sp3d: yeah :)
[19:03:22] *** Quits: deepdog (deepdog@moz-490E834C.client.mchsi.com) (Ping timeout)
[19:03:35] <magg> oh well, i'll use u8 my mistake
[19:03:54] *** Joins: pyrac (pyrac@moz-96C2FD1F.w109-214.abo.wanadoo.fr)
[19:04:13] *** Joins: deepdog (deepdog@moz-490E834C.client.mchsi.com)
[19:06:59] <SiegeLord> What do you call a method calling style when each method returns a reference to self?
[19:07:10] <sp3d> method chaining?
[19:07:33] <SiegeLord> Ah, yes...
[19:07:37] <strcat> that won't work out well in rust though
[19:08:09] <SiegeLord> It seems to work fine for now?
[19:08:35] <strcat> so you have a whole chain of
[19:08:47] <strcat> foo(&'r self) -> &'r Self
[19:11:22] *** Quits: huhlig-home (huhlig@moz-C8339267.hfc.comcastbusiness.net) (Connection reset by peer)
[19:11:44] <SiegeLord> Oh, I didn't know about Self
[19:11:46] <SiegeLord> But yes
[19:13:06] <SiegeLord> Wait... is Self a thing? Or just an example type here
[19:13:57] <Jeaye> strcat: Is there any way to capture right now when the object is not @?
[19:14:12] <Jeaye> Without moving, I s'pose.
[19:14:25] <strcat> you can use &mut in stack closures
[19:14:57] <Jeaye> strcat: Is @mut being fixed?
[19:15:11] <caitp> apparently you can't use cast expressions in match arm
[19:15:14] <strcat> Jeaye: it is fixed
[19:15:24] <Jeaye> Then why's it hard crashing? :P
[19:15:40] <strcat> Jeaye: because you've opted into dynamic mutability, just like you'd get in python/java
[19:15:45] <strcat> working as intended
[19:15:57] <caitp> src/parser.rs:41:16: 41:18 error: expected `=>` but found `as`
[19:15:58] <caitp> src/parser.rs:41       -1 | '\n' as int => {
[19:15:59] <strcat> @mut -> dynamic failures at runtime, iterator invalidation, etc.
[19:16:13] <strcat> there's more reason to avoid it than how terribly slow it is
[19:16:27] <Jeaye> In C++ terms, you're talking about dynamic_casting?
[19:16:30] <strcat> it throws away the benefits of rust compared to a language like Go/Java
[19:16:30] *** Quits: RMF (RMF@E80DA7BB.A3D80C3C.8D19547B.IP) (Quit: Textual IRC Client: www.textualapp.com)
[19:16:41] <strcat> Jeaye: no about iterator invalidation and reference invalidation
[19:16:49] *** Joins: RMF (RMF@E80DA7BB.A3D80C3C.8D19547B.IP)
[19:16:50] *** Joins: MaikKlein1 (maik@moz-C731CFBB.dip0.t-ipconnect.de)
[19:17:01] <Jeaye> I don't understand how that'd happen if it's managed/shared.
[19:17:07] <strcat> Jeaye: ok so
[19:17:10] <strcat> you have a container
[19:17:12] <strcat> it's owned
[19:17:16] <strcat> you borrow a reference, it's statically frozen
[19:17:22] <strcat> you can't invalidate the reference
[19:17:39] <strcat> in C++, you could, you'd get memory corruption, a segfault, etc.
[19:17:57] <strcat> now in rust you opt-in to dynamic handling of that with @mut - you borrow & to it, it *dynamically* freezes
[19:18:05] <strcat> you try to modify it - it *fails* to prevent a memory safety issue
[19:18:22] <strcat> @mut is safe because it fails on invalid usage
[19:18:29] <MaikKlein1> do you think we could push https://github.com/mozilla/rust/pull/6661 without windows support?
[19:19:05] *** Joins: steven_is_false (user@moz-144077DE.bchsia.telus.net)
[19:19:41] <Jeaye> I'm just confused, I s'pose, since I don't see why the reference would be invalidated; the referenced object is still entirely alive.
[19:20:39] <strcat> Jeaye: it's not still entirely alive
[19:20:47] <strcat> it could point into an enum and you switched the type
[19:20:51] <strcat> it could point into a container you resized
[19:21:25] <strcat> if you want static control over mutability, guaranteed not to fail, you can use stack allocation, ~, &, &mut and @
[19:21:27] *** Joins: ghrust (ghrust@C621748.6A2AE50.F3114085.IP)
[19:21:27] *** Joins: huhlig-home (huhlig@moz-C8339267.hfc.comcastbusiness.net)
[19:21:27] <ghrust> 01[13rust01] 15bors 04force-pushed 06auto from 14fb35603 to 1488c318d: 02http://git.io/N3iJvQ
[19:21:27] *** Parts: ghrust (ghrust@C621748.6A2AE50.F3114085.IP) ()
[19:21:30] *** Joins: ghrust (ghrust@79968228.6A2AE50.F3114085.IP)
[19:21:30] <ghrust> 01[13rust01] 15bors pushed 2 new commits to 06auto: 02http://git.io/59Wc7w
[19:21:30] <ghrust> 13rust/06auto 14fb76ec4 15Daniel Micay: cmp: remove duplicate free functions
[19:21:30] <ghrust> 13rust/06auto 148daae75 15bors: auto merge of #7028 : thestinger/rust/cmp, r=brson
[19:21:30] *** Parts: ghrust (ghrust@79968228.6A2AE50.F3114085.IP) ()
[19:22:45] *** Joins: tjc (tjc@moz-266A5CD0.hsd1.wa.comcast.net)
[19:22:45] *** ChanServ sets mode: +o tjc
[19:22:50] <strcat> @mut doesn't *really* let you opt-out of worrying about it, because if you stop thinking about it you'll be unsure about where dynamic failures could happen (like python or java)
[19:22:59] <strcat> it's the same as this
[19:23:11] <strcat> >>> xs = {1, 2, 3}
[19:23:14] <strcat> >>> for x in xs: xs.add(5)
[19:23:16] <strcat> ... 
[19:23:18] <strcat> Traceback (most recent call last):
[19:23:20] <strcat>   File "<stdin>", line 1, in <module>
[19:23:22] <strcat> RuntimeError: Set changed size during iteration
[19:23:49] <strcat> except python pays performance price across many features to make the errors more fine-grained
[19:23:52] *** Joins: bytbox (s@moz-D83E9B31.wireless.umd.edu)
[19:24:52] <strcat> Jeaye: if you use @mut and  *only* @mut, no borrowed pointers, you'll get the same kind of errors as java/python only
[19:25:06] <strcat> if you borrow & or &mut to it, you're freezing it
[19:25:35] <strcat> & and &mut don't have runtime instrumentation - with owned data that's fine, mutability is all static
[19:26:37] *** Quits: int3_ (int3_@moz-ABE52D50.hsd1.ca.comcast.net) (Client exited)
[19:26:53] *** Quits: bytbox (s@moz-D83E9B31.wireless.umd.edu) (Ping timeout)
[19:27:49] <SiegeLord> Here's some method chaining in action: https://github.com/SiegeLord/RustGnuplot/blob/master/example.rs#L15
[19:27:57] *** Joins: bytbox (s@moz-D83E9B31.wireless.umd.edu)
[19:28:18] <SiegeLord> It seems to work ok, although I had to make some (seemingly) ad-hoc choices on the return type
[19:28:34] <SiegeLord> Sometimes it's &' Type<'l> and sometimes it's &' Type<'self>
[19:28:44] <strcat> SiegeLord: neat
[19:28:47] <SiegeLord> * &' lType<'l> and sometimes it's &'l Type<'self>
[19:29:14] <Jeaye> strcat: I appreciate the explaination. I'm still trying to wrap my head around this in C++ terms, so I'll just go back over what you said.
[19:29:19] <Jeaye> explanation, too
[19:29:36] <flu_> SiegeLord: why not use a builder? It adds a '.build()' at the end of the chain, but all your return types are the same
[19:29:51] <strcat> Jeaye: in C++, let xs = [1, 2, 3]; let y = &xs[0]; xs.clear(); /* y is now a dangling reference */
[19:29:57] <strcat> lots of other ways to do it
[19:30:17] <strcat> rust guarantees that won't happen entirely with static checks for T, ~T, &T, &mut T, @
[19:30:38] <strcat> as soon as you touch @mut, you've opted into the possibility of dynamic failures when you mess up mutability
[19:30:41] <Jeaye> I see that, and completely agree. That's just not what I'm doing here in Rust.
[19:31:02] <strcat> Jeaye: rust is memory safe, it has to uphold that guarantee
[19:31:03] <SiegeLord> flu_, Won't I have to create a builder type?
[19:31:09] <strcat> it can't allow you to get into that situation in the first place
[19:31:11] <flu_> SiegeLord: correct
[19:31:21] <strcat> & and &mut don't have any runtime instrumentation at all. they can't know they are dangling
[19:31:33] <SiegeLord> flu_, I was thinking of adding something like that in the future
[19:31:34] <strcat> @mut is responsible for keeping all &/&mut reference to the contents valid
[19:31:45] <strcat> it does that by freezing itself
[19:31:49] <flu_> SiegeLord: looking at the rest of the example, may not be a great fit anyway. It would let you enforce parameter invariants and make sure the entire Figure's state is sane before construction
[19:31:57] <Jeaye> I'm thinking of @mut T as shared_ptr<T>, where all I'm doing is giving another object a @mut to me and allowing him to change me.
[19:32:01] <strcat> every time you borrow & to @mut, it sets a freeze status - when the & is gone, it restores it
[19:32:11] <strcat> Jeaye: okay but you're mixing it with & and &mut
[19:32:21] <strcat> if you only use @mut, and never borrow to it, it will work like shared_ptr
[19:32:22] <Jeaye> So the problem here is that I've a &mut to @mut?
[19:32:32] <strcat> Jeaye: yes, now the &mut is the unique handle to it
[19:32:37] <flu_> let fg = Figure::builder().foo("x").bar("y").awesome_level(100).build();
[19:33:09] <Jeaye> strcat: I understand more now. The closure is doing this behind the scenes?
[19:33:41] <Jeaye> I'd prefer to just use @mut, and no &mut @mut or anything of the sort.
[19:33:55] <strcat> Jeaye: I see &self there
[19:33:57] <strcat> that's a borrow
[19:34:02] <strcat> you likely have lots of other borrows
[19:34:22] *** Quits: sp3d (a@moz-49806493.dhcp.stls.mo.charter.com) (Quit: sp3d)
[19:34:45] <strcat> rusti: let x = @mut 5; let y = &*x; /* x has to freeze itself dynamically until is gone */
[19:34:46] -rusti- ()
[19:34:59] <Jeaye> Ahh, so since the activator has &mut self, the self.console becomes &mut @mut.
[19:34:59] <strcat> until y is gone*
[19:35:14] <strcat> Jeaye: &mut @mut won't freeze it
[19:35:52] *** Joins: vosen (vosen@moz-266BA656.icpnet.pl)
[19:36:17] <Jeaye> So I have, in essence, a `shared_ptr<T> &`
[19:37:09] *** Joins: sp3d (a@moz-49806493.dhcp.stls.mo.charter.com)
[19:38:45] <Jeaye> Yeah, the &mut self doesn't matter here. In fact, it compiles just fine with self being immutable. Still crashes though.
[19:39:28] <strcat> Jeaye: compile without optimization with a current incoming
[19:39:38] <strcat> it will tell you where the conflicting borrow happened
[19:39:46] <strcat> it's not a "crash" though, it's fail!()
[19:40:34] <Jeaye> Ahh
[19:40:38] <Jeaye> That error is more helpful.
[19:41:30] *** Quits: heftig_ (heftig@moz-F9D278E1.dip0.t-ipconnect.de) (Quit: Quitting)
[19:42:03] *** Joins: heftig (heftig@moz-F9D278E1.dip0.t-ipconnect.de)
[19:42:52] *** Joins: gareth0 (gareth0@moz-59BAD7FE.dynamic.dsl.as9105.com)
[19:43:53] *** Quits: erickt (Adium@49C4075F.3AC15C18.2321E71E.IP) (Quit: Leaving.)
[19:45:17] *** Quits: zofrex (Mibbit@moz-CFD5D022.cable.virginmedia.com) (Quit: http://www.mibbit.com ajax IRC Client)
[19:46:51] *** Joins: \n (NDesaulnie@moz-C2B49FFE.hsd1.ca.comcast.net)
[19:48:17] *** Quits: tcsc (tcsc@moz-ADC0ED45.hsd1.ct.comcast.net) (Quit: computer sleeping)
[19:48:39] *** Quits: gareth0 (gareth0@moz-59BAD7FE.dynamic.dsl.as9105.com) (Client exited)
[19:49:20] *** Quits: steven_is_false (user@moz-144077DE.bchsia.telus.net) (Ping timeout)
[19:50:05] <Jeaye> rusti: let mut i = 0; || { i += 1; }(); println(fmt!("%?", i));
[19:50:07] -rusti- more than 5 lines of output, pastebinned: http://sprunge.us/TGKX
[19:51:54] <Jeaye> rusti: let mut i = 0; (|| { i += 1; })(); println(fmt!("%?", i));
[19:51:55] -rusti- 1
[19:51:56] -rusti- ()
[19:52:12] <Jeaye> rusti: let i = @mut 0; (|| { i += 1; })(); println(fmt!("%?", i));
[19:52:14] -rusti- more than 5 lines of output, pastebinned: http://sprunge.us/fHHb
[19:52:36] *** Joins: steven_is_false (user@moz-144077DE.bchsia.telus.net)
[19:53:08] <flu_> So I really like the way you can declare linker arguments in the source file (with #[link_args = "-lwhatever"]), is there some way I can get this to play nice with pkg_config?
[19:53:37] <flu_> I'm thinking of resorting to some sed voodoo in the Makefile... somebody talk me down! :-P
[19:53:47] <flu_> *pkg-config
[19:54:21] <steven_is_false> flu_: A ffi.rs.in file might be the best way to go. Can't one get environment arguments with env! though?
[19:55:41] <flu_> steven_is_false: What is this *.in you refer to? I'm trying to link against imagemagick's magickwand api, and their docs specify using pkg-config (which returns an include path that is definitely non-standard)
[19:56:01] <flu_> steven_is_false: that's an automake or autoconf thing, right? the .in file
[19:56:17] <steven_is_false> .in is the traditional suffix for files which are preprocessed with config data.
[19:56:23] <flu_> ah, gotcha
[19:56:25] <steven_is_false> Yeah it's an autotools thing.
[19:56:42] * flu_ hits the google
[19:56:54] *** Quits: MaikKlein1 (maik@moz-C731CFBB.dip0.t-ipconnect.de) (Ping timeout)
[19:57:49] <steven_is_false> flu_: Using sed isn't that difficult. In my P( = x) project I have a good way of using it.
[19:57:53] <steven_is_false> I'll find a link in a second.
[19:58:16] <flu_> steven_is_false: I wasn't shying away from sed for it's difficulty, but rather the hacktastic flavor it puts in my mouth
[19:58:29] <steven_is_false> flu_: Fair enough
[19:58:59] <flu_> if autotools is the *right way*, might as well take some time to learn those pieces. I've been spoiled in jvm / ruby land for too long
[19:59:56] <steven_is_false> flu_: autotools is complicated, and annoying, and difficult to integrate with non C languages but it's one of the build systems which just works.
[20:00:51] <strcat> uh
[20:00:54] <strcat> autotools doesn't 'just work'
[20:00:56] <strcat> at all
[20:01:02] <flu_> your warning is noted :-) if my brain starts smoking, I'll just abort and go back to my sed approach
[20:01:06] <strcat> it happens to be why rust's incoming is red right now....
[20:01:13] <flu_> haha
[20:01:16] <strcat> if someone feels like dealing with autoconf, they can fix it
[20:01:41] *** Quits: mib_nzn7tq (Mibbit@moz-9BBC8BC6.range86-149.btcentralplus.com) (Quit: http://www.mibbit.com ajax IRC Client)
[20:02:20] *** Quits: caitp (caitp@moz-9FE842F.cpe.net.cable.rogers.com) (Ping timeout)
[20:02:46] *** Quits: engla (engla@moz-DBD1D96E.cust.bredbandsbolaget.se) (Ping timeout)
[20:04:03] *** Quits: magg (magg@B7B2D103.77B59C03.3D0AE249.IP) (Quit: magg)
[20:05:21] *** Quits: jensnockert (jensnocker@moz-8BE55278.customer.t3.se) (Input/output error)
[20:05:43] <steven_is_false> strcat: One of Rust's dependencies uses autoconf?
[20:05:52] <strcat> steven_is_false: several
[20:06:05] <steven_is_false> strcat: Which one's broken?
[20:06:08] <strcat> the broken one is jemalloc though. because autoconf sucks at cross-compiling
[20:06:24] <strcat> because the whole idea of running tests to get constants, etc. is broken
[20:07:22] *** Joins: SingingBoyo (brandon@moz-EAC7E73D.bchsia.telus.net)
[20:08:06] <steven_is_false> strcat: Ugh, jemalloc's configure.ac is spaghetti
[20:08:50] <strcat> well the problem is that it uses autoconf to get the page size
[20:09:04] *** Joins: infynyxx (infynyxx@moz-E95B370B.nyc.res.rr.com)
[20:09:09] <strcat> and using autoconf is a problem, because your target arch isn't necessarily your host arch
[20:09:11] <steven_is_false> strcat: Right, that's silly.
[20:09:25] *** Quits: deepdog (deepdog@moz-490E834C.client.mchsi.com) (Quit: Leaving)
[20:09:30] <strcat> yes it should just hardcode it for the platforms in the source code
[20:09:54] <strcat> but it doesn't so we have to find a way to deal with it
[20:09:57] <strcat> firefox seems to hardcode it
[20:10:16] <steven_is_false> strcat: There should be a better solution than both of those approaches but I can't think of one at the moment.
[20:10:26] <strcat> there isn't
[20:10:44] <strcat> you don't have a guarantee that you have the target available to run things on when you're compiling
[20:11:02] <strcat> it has to be hardcoded *somewhere*
[20:11:13] <steven_is_false> strcat: Well one could hard code for a few platforms, and if those platforms aren't found throw on error on cross compilation.
[20:11:24] <steven_is_false> Otherwise check for the page size.
[20:11:37] *** Joins: magg (magg@B7B2D103.77B59C03.3D0AE249.IP)
[20:11:52] *** Quits: tjc (tjc@moz-266A5CD0.hsd1.wa.comcast.net) (Quit: Places to go, people to annoy)
[20:12:20] <Earnestly> And end up with the same problem
[20:12:27] <strcat> afaik it's 4k everywhere, and the windows alloc granularity is 64k
[20:12:38] <strcat> firefox hardcodes the page shift size to 12 *everywhere*
[20:13:20] <steven_is_false> How old is jemalloc?
[20:13:48] <steven_is_false> Actually, what do other memory allocators do?
[20:14:02] <strcat> https://hg.mozilla.org/mozilla-central/file/855a29c9dd68/configure.in#l9293
[20:14:19] <strcat> steven_is_false: I imagine they hardcode it to 4k because it's 4k everywhere
[20:14:49] <steven_is_false> strcat: Fair enough
[20:15:24] *** Joins: gareth0 (gareth0@moz-59BAD7FE.dynamic.dsl.as9105.com)
[20:16:54] <steven_is_false> So we want to be able to just pass to jemalloc a constant page size?
[20:17:09] *** Quits: SingingBoyo (brandon@moz-EAC7E73D.bchsia.telus.net) (Ping timeout)
[20:17:15] <steven_is_false> Has anyone filed a bug report to the jemalloc people about that yet?
[20:17:24] <strcat> steven_is_false: no
[20:17:29] *** Quits: mleise (marco@moz-3468AB5B.pools.arcor-ip.net) (Ping timeout)
[20:17:52] <steven_is_false> I don't know enough about the issue to make up a proper bug report.
[20:18:05] *** Quits: moonchrome (moonchrome@moz-C9D218E8.dsl.iskon.hr) (Ping timeout)
[20:18:32] *** Joins: ghrust (ghrust@FD7BC443.6A2AE50.F3114085.IP)
[20:18:32] <ghrust> 01[13rust01] 15bors 04force-pushed 06auto from 148daae75 to 1488c318d: 02http://git.io/N3iJvQ
[20:18:32] *** Parts: ghrust (ghrust@FD7BC443.6A2AE50.F3114085.IP) ()
[20:18:34] *** Joins: ghrust (ghrust@AD60B2E3.6A2AE50.F3114085.IP)
[20:18:34] <ghrust> 01[13rust01] 15bors pushed 4 new commits to 06auto: 02http://git.io/tZZMCA
[20:18:34] <ghrust> 13rust/06auto 14a014088 15Tim Chevalier: std: Fix search-and-replace typos
[20:18:34] <ghrust> 13rust/06auto 1453b8352 15Tim Chevalier: rustpkg: Extract version number from git, as per #5684...
[20:18:35] <ghrust> 13rust/06auto 14d92b435 15Tim Chevalier: rustpkg: Accept package IDs like github.com/foo/bar#0.3...
[20:18:36] *** Parts: ghrust (ghrust@AD60B2E3.6A2AE50.F3114085.IP) ()
[20:19:14] <steven_is_false> Go Tim!
[20:19:21] *** Quits: Amanieu (amanieu@moz-D5D10CA8.halls.manchester.ac.uk) (Connection reset by peer)
[20:20:10] *** Joins: Amanieu (amanieu@moz-D5D10CA8.halls.manchester.ac.uk)
[20:20:16] *** Joins: lmandel (lmandel@FE1F74.86ED00A7.971E19F6.IP)
[20:20:46] <steven_is_false> There doesn't seem to be any sort of public bug report page.
[20:21:25] <kimundi> steven_is_false: What do you mean?
[20:22:08] <steven_is_false> kimundi: I was looking for jemalloc's project page because strcat said that noone had submitted a bug report about jemalloc's manual testing of the page size which breaks cross compilation.
[20:22:24] <kimundi> ah, not rust, okay :)
[20:22:27] <strcat> none of us has
[20:23:02] <Jeaye> strcat: So this is the most distilled version of my problem: https://gist.github.com/Jeaye/856ff687de9f5615f88d
[20:23:45] <Jeaye> And you're saying I just *can't* use @mut here?
[20:23:59] <strcat> the in-place assign ops are weird
[20:24:02] <strcat> what if you do it by hand?
[20:24:18] * Jeaye tries
[20:24:27] <strcat> as in using one of the &mut methods
[20:24:42] <strcat> += is very inefficient anyway
[20:24:48] <Jeaye> Fuck
[20:25:01] <Jeaye> IT works with f.x = f.x + ~"x";
[20:25:37] <strcat> well... the in-place ops are going to be replaced 
[20:25:39] <doomlord> interesting , += in an immutable-by-default language..
[20:25:54] <Jeaye> Testing this with my actual code.
[20:26:07] <strcat> doomlord: why?
[20:26:21] <doomlord> are they in rust?
[20:26:32] <strcat> yes those operators are in rust
[20:26:35] <doomlord> ok
[20:26:44] <Jeaye> muahaha!
[20:26:46] <strcat> they are not implemented well
[20:26:55] <Jeaye> strcat: Removing the += fixed it in my code.
[20:27:14] <doomlord> i suppose functional programming would avoid them
[20:27:23] <Jeaye> Just silly.
[20:27:23] <doomlord> replace their use with folds?
[20:27:41] <doomlord> but i realise rust isn't pure-functional
[20:28:24] *** Quits: pyrac (pyrac@moz-96C2FD1F.w109-214.abo.wanadoo.fr) (Quit: pyrac)
[20:29:40] *** Quits: lmandel (lmandel@FE1F74.86ED00A7.971E19F6.IP) (Quit: lmandel)
[20:31:11] <Jeaye> strcat: Well, that solves everything. Thanks again for the help; sorry for the slow pace. :P
[20:32:30] *** Joins: webber46 (webber46@moz-DC342D45.cust.bredband2.com)
[20:40:31] *** Quits: jack (jack@moz-F1B36F9F.hsd1.nm.comcast.net) (Quit: Leaving.)
[20:40:32] <EXetoC> yeah, I used += in a loop once. it just kept going after 10 minutes
[20:40:40] *** Joins: jack (jack@moz-F1B36F9F.hsd1.nm.comcast.net)
[20:42:06] <strcat> Jeaye: well it's not obvious that += is a problem
[20:42:25] <strcat> it's implemented really poorly right now though. so I imagine it borrows internally and modifies
[20:42:48] <Jeaye> Yeah, no worries.
[20:43:17] <Jeaye> I learned a lot from your explanation of the freezing anyway. :)
[20:44:07] *** Quits: wuwei|offline (wuwei@1A513F49.818D7924.FAA9ED67.IP) (Connection reset by peer)
[20:44:32] *** Joins: wuwei|offline (wuwei@1A513F49.818D7924.FAA9ED67.IP)
[20:46:17] *** Quits: Sorella (queen@B12A78F5.BA14766C.95C8B7C6.IP) (Quit: (quit))
[20:46:55] *** Quits: bytbox (s@moz-D83E9B31.wireless.umd.edu) (Ping timeout)
[20:50:24] *** Joins: bytbox (s@moz-2E27684C.student.umd.edu)
[20:51:34] *** Quits: \n (NDesaulnie@moz-C2B49FFE.hsd1.ca.comcast.net) (Quit: \n)
[20:53:29] *** Joins: true_droid (Adium@moz-123FD9B8.beck.volia.net)
[20:54:51] *** Quits: mzabaluev (mzabaluev@moz-91FFD755.dhcp.inet.fi) (Ping timeout)
[20:58:57] *** Quits: jihyun (uid7128@moz-D8B63698.irccloud.com) (Ping timeout)
[20:58:57] *** Quits: sawrubh (uid6719@moz-D8B63698.irccloud.com) (Ping timeout)
[20:58:57] *** Quits: SeanTAllen_ (uid4855@moz-D8B63698.irccloud.com) (Ping timeout)
[20:58:57] *** Quits: gmcabrita (uid4474@moz-D8B63698.irccloud.com) (Ping timeout)
[20:58:57] *** Quits: stowellde (uid6365@moz-D8B63698.irccloud.com) (Ping timeout)
[20:59:09] <steven_is_false> Huh? I'm getting error: obsolete syntax: visibility-qualified implementation what does that mean?
[20:59:13] *** Joins: jihyun (uid7128@moz-D8B63698.irccloud.com)
[20:59:50] <cmr> steven_is_false: pub/priv impl is deprecated and removed
[21:00:26] <steven_is_false> cmr: So that's what that means! thanks.
[21:00:44] *** Joins: SeanTAllen_ (uid4855@moz-D8B63698.irccloud.com)
[21:01:05] *** Quits: Blei (philipp@moz-96D25F7A.cust.bluewin.ch) (Ping timeout)
[21:01:10] *** Quits: gareth0 (gareth0@moz-59BAD7FE.dynamic.dsl.as9105.com) (Ping timeout)
[21:04:46] *** Quits: jack (jack@moz-F1B36F9F.hsd1.nm.comcast.net) (Quit: Leaving.)
[21:04:57] <bjz> steven_is_false: instead use pub on a per-method basis
[21:05:28] <steven_is_false> bjz: Yep
[21:05:47] <bjz> makes more sense now that trait impls are forbidden as well
[21:05:58] <bjz> *pub trait impls
[21:06:01] <bjz> I mean
[21:06:05] <cmr> I was going to say... wut
[21:09:30] *** Joins: ghrust (ghrust@FD7BC443.6A2AE50.F3114085.IP)
[21:09:30] <ghrust> 01[13rust01] 15bors merged 06auto into 06incoming: 02http://git.io/tZZMCA
[21:09:30] *** Parts: ghrust (ghrust@FD7BC443.6A2AE50.F3114085.IP) ()
[21:11:17] <strcat> bstrie: that was already r+'ed btw ;p
[21:11:19] <strcat> bstrie: r=foo works
[21:12:28] *** Joins: ghrust (ghrust@F6EE6DE3.6A2AE50.F3114085.IP)
[21:12:28] <ghrust> 01[13rust01] 15bors pushed 0 new commits to 06auto: 02http://git.io/p8cM_Q
[21:12:28] *** Parts: ghrust (ghrust@F6EE6DE3.6A2AE50.F3114085.IP) ()
[21:12:30] *** Joins: ghrust (ghrust@24260B07.6A2AE50.F3114085.IP)
[21:12:30] <ghrust> 01[13rust01] 15bors pushed 2 new commits to 06auto: 02http://git.io/TW7MJw
[21:12:30] <ghrust> 13rust/06auto 14fb174b5 15Daniel Micay: cmp: remove duplicate free functions
[21:12:30] <ghrust> 13rust/06auto 14fdcfee5 15bors: auto merge of #7028 : thestinger/rust/cmp, r=bstrie,brson
[21:12:30] *** Parts: ghrust (ghrust@24260B07.6A2AE50.F3114085.IP) ()
[21:12:44] <Luqman> bjz: btw, have a fix for #4228
[21:12:58] <bjz> Luqman: which one was that?
[21:13:07] <bjz> the #[deprecated] one?
[21:13:20] <Luqman> static fns in multiple impls's
[21:15:21] <Luqman> also, while i was updating my old deprecated patch i realized that it would have issues when things are cross-crate since we don't always write the AST
[21:16:55] *** Joins: \n (NDesaulnie@moz-C2B49FFE.hsd1.ca.comcast.net)
[21:17:46] *** Joins: SingingBoyo (brandon@moz-EAC7E73D.bchsia.telus.net)
[21:19:37] *** Joins: jaen (jaen@moz-E0979827.copit.pl)
[21:21:12] *** Joins: Sorella (queen@B12A78F5.BA14766C.95C8B7C6.IP)
[21:23:49] *** Joins: eholk (eholk@moz-9AB4D52F.hsd1.ut.comcast.net)
[21:24:19] *** Joins: GinIris (chatzilla@moz-53E08EF2.libero.it)
[21:26:12] <SiegeLord> Hmm... so I'm essentially implementing something like zipN with N going from 2 to 6. Is there any way of making that look nice? Should I have an adaptor function that's called from each of them with this signature: zip_dyn(&[&fn adaptor() -> Option<T>]) ?
[21:28:25] *** Quits: spider-mario (spidermari@moz-2F72F6FF.dsl.quantic-telecom.net) (Input/output error)
[21:28:26] <strcat> rusti: use std::iterator::*; let xs = [1, 2, 3]; let ys = ["foo", "bar", "baz"]; let zs = [4, 5, 6]; xs.iter().zip(ys.iter()).zip(zs.iter()); /* ;p */
[21:28:31] -rusti- ()
[21:28:57] *** Joins: themgt (themgt@moz-248BBB96.dhcp.gnvl.sc.charter.com)
[21:29:09] <SiegeLord> Now you're thinking with iterators!
[21:29:56] <strcat> rusti: use std::iterator::*; let xs = [1, 2, 3]; let ys = ["foo", "bar", "baz"]; let zs = [4, 5, 6]; for xs.iter().zip(ys.iter()).zip(zs.iter()).advance |((x, y), z)| { println(fmt!("%? %? %?", x, y, z) }
[21:29:58] -rusti- line longer than 150 columns, pastebinned: http://sprunge.us/BdVI
[21:30:09] <strcat> rusti: use std::iterator::*; let xs = [1, 2, 3]; let ys = ["foo", "bar", "baz"]; let zs = [4, 5, 6]; for xs.iter().zip(ys.iter()).zip(zs.iter()).advance |((x, y), z)| { println(fmt!("%? %? %?", x, y, z)) }
[21:30:11] -rusti- &1 &"foo" &4
[21:30:11] -rusti- &2 &"bar" &5
[21:30:12] -rusti- &3 &"baz" &6
[21:30:12] -rusti- ()
[21:31:01] <strcat> it might be more convenient to have zip3, zip4, etc... but I think composing zips is still nicer than making an N one with something weird like vectors
[21:31:40] <strcat> if only we had default methods and a nicer 'for' :)
[21:32:15] *** Quits: rsaarelm (rsaarelm@moz-D1CB7158.dhcp.inet.fi) (Ping timeout)
[21:32:24] <SiegeLord> For 4 it would be (((x, y), z), w) ?
[21:32:42] *** Quits: GinIris (chatzilla@moz-53E08EF2.libero.it) (Quit: ChatZilla 0.9.90 [SeaMonkey 2.17.1/20130410205058])
[21:34:08] <strcat> SiegeLord: yep
[21:35:15] <Ralith> a language-level solution to this problem would me to make ((x, y), x) isomorphic to (x, y, z)
[21:35:19] <Ralith> would be*
[21:35:37] <strcat> they aren't the same structure though.
[21:35:43] <Ralith> indeed not
[21:35:46] *** Quits: doy (doy@moz-5FE28A32.akrasiac.org) (Ping timeout)
[21:36:15] <Eridius> Represented the same in memory though, no?
[21:36:27] *** Joins: rsaarelm (rsaarelm@moz-D1CB7158.dhcp.inet.fi)
[21:36:38] <strcat> rusti: std::sys::size_of::<((bool, int), bool))>
[21:36:39] -rusti- <anon>:10:48: 10:49 error: incorrect close delimiter: `)`
[21:36:39] -rusti- <anon>:10          std::sys::size_of::<((bool, int), bool))>
[21:36:39] -rusti-                                                           ^
[21:36:39] -rusti- application terminated with error code 101
[21:36:48] <strcat> rusti: std::sys::size_of::<((bool, int), bool)>
[21:36:50] <strcat> rusti: std::sys::size_of::<((bool, int), bool)>()
[21:36:51] -rusti- 24
[21:36:57] <Ralith> (x, (y, z)) is the more usual translation, also
[21:36:57] <strcat> rusti: std::sys::size_of::<(bool, int, bool)>()
[21:36:59] -rusti- 24
[21:37:03] <Eridius> rusti: unsafe { std::cast::transmute<(int, int, int)>(((1, 2), 3))
[21:37:04] -rusti- <anon>:11:5: 11:6 error: incorrect close delimiter: `)`
[21:37:04] -rusti- <anon>:11     }));
[21:37:04] -rusti-                ^
[21:37:04] -rusti- application terminated with error code 101
[21:37:10] <Eridius> rusti: unsafe { std::cast::transmute<(int, int, int)>(((1, 2), 3)) }
[21:37:12] -rusti- more than 5 lines of output, pastebinned: http://sprunge.us/GOJj
[21:37:21] <strcat> Eridius: not sure. trying to think of an example that's not
[21:37:47] <SiegeLord> Hah, that works... hopefully it doesn't explode in my face at a later point
[21:37:55] <strcat> rusti: std::sys::size_of::<((bool, bool), int)>()
[21:37:55] <SiegeLord> All I can see from that construction is "template bloat"
[21:37:56] -rusti- 16
[21:37:56] <Eridius> rusti: unsafe { std::cast::transmute::<((int,int),int),(int,int,int)>(((1, 2), 3)) }
[21:37:59] -rusti- (1, 2, 3)
[21:38:04] <strcat> rusti: std::sys::size_of::<(bool, bool, int)>()
[21:38:05] -rusti- 16
[21:38:13] <Ralith> if they're regular unboxed tuples, flattening should never affect memory representation
[21:38:37] <SiegeLord> In my case I don't really need the tuple, I only care about the components
[21:38:45] <Eridius> rusti: unsafe { std::cast::transmute::<((int,bool),int),(int,bool,int)>(((1, true), 3)) }
[21:38:47] -rusti- (1, true, 3)
[21:38:58] *** Joins: doy (doy@moz-5FE28A32.akrasiac.org)
[21:39:17] <Ralith> and having n-tuples be built out of 2-tuples in the semantics is very convenient for writing abstractions over tuples of arbitrary size
[21:41:34] <flu_> If I'm wrapping a C library, and that library exposes an API with several structs declared in it, can I safely translate these directly to Rust structs?
[21:41:47] <flu_> The authors weren't cool enough to have void* types for API in/outs
[21:41:51] <Eridius> flu_: yes
[21:41:58] <Eridius> rust's structs are equivalent to C's in memory layout
[21:42:00] <flu_> Eridius: woot!
[21:42:03] <Eridius> there's even a #[packed] attribute if you need it
[21:42:04] <strcat> flu_: rust structs are laid out the same as C ones, just make sure to use the same field types
[21:42:07] <Eridius> flu_: also see: rust-bindgen
[21:42:13] * flu_ googles
[21:42:15] <Eridius> https://github.com/crabtw/rust-bindgen
[21:42:22] <Eridius> you may have to tweak the output, but it's a nice start
[21:42:56] <SiegeLord> Although, hah... it turns out that the zip variant results in smaller binary size!
[21:43:07] <SiegeLord> Same compillation speed
[21:43:08] <flu_> amen! That could save me a good amount of the boilerplate I see lurking in my future
[21:45:44] *** Joins: moonchrome (moonchrome@moz-99EA89E.dsl.iskon.hr)
[21:45:49] <SiegeLord> Oh wait, no... I was looking at the wrong binary... the code with zip's is a bit bigger
[21:48:29] *** Joins: ghrust (ghrust@C621748.6A2AE50.F3114085.IP)
[21:48:29] <ghrust> 01[13rust01] 15bors 04force-pushed 06auto from 14fdcfee5 to 1494f72dd: 02http://git.io/N3iJvQ
[21:48:29] *** Parts: ghrust (ghrust@C621748.6A2AE50.F3114085.IP) ()
[21:48:33] *** Joins: ghrust (ghrust@24260B07.6A2AE50.F3114085.IP)
[21:48:33] <ghrust> 01[13rust01] 15bors pushed 3 new commits to 06auto: 02http://git.io/ordpAQ
[21:48:33] <ghrust> 13rust/06auto 14618558a 15Luqman Aden: librustc: Allow adding static fn's in multiple impl's.
[21:48:33] <ghrust> 13rust/06auto 140bf6d9e 15Luqman Aden: Add test for #4228.
[21:48:33] <ghrust> 13rust/06auto 149bcf911 15bors: auto merge of #7029 : luqmana/rust/issue-4228, r=catamorphism...
[21:48:35] *** Parts: ghrust (ghrust@24260B07.6A2AE50.F3114085.IP) ()
[21:48:59] <SiegeLord> The compillation speed is unaffected though, and that tends to be the first thing templates hit
[21:49:19] <SiegeLord> This example is probably too small :P
[21:49:49] <flu_> Eridius: GREAT recommendation! thanks
[21:49:50] <SiegeLord> Although I wonder if Rust's generic model is less susseptible to this, as it doesn't need to do a type check when instantiating a template
[21:49:56] <cmr> SiegeLord: generics in rust can be faster because type checking only needs to be done once for any given generic, rather than in C++ where every single instanciation needs separate compilation and checking.
[21:50:03] <cmr> yeah
[21:50:44] *** Quits: infynyxx (infynyxx@moz-E95B370B.nyc.res.rr.com) (Ping timeout)
[21:51:03] *** Joins: infynyxx (infynyxx@moz-E95B370B.nyc.res.rr.com)
[21:51:33] <steven_is_false>  Should rustc act like rustc --link-args '-L /usr/local/lib' by default?
[21:51:53] <SiegeLord> rusti: use std::iterator::*; let xs = [1, 2, 3]; let ys = ["foo", "bar", "baz"]; let zs = [4]; for xs.iter().zip(ys.iter()).zip(zs.iter()).advance |((x, y), z)| { println(fmt!("%? %? %?", x, y, z)) }
[21:51:55] -rusti- &1 &"foo" &4
[21:51:56] -rusti- ()
[21:52:19] <cmr> steven_is_false: no, by default the linker (gcc/clang right now) only check the default dirs specified (on linux) in /etc/ld.so.conf and friends
[21:52:35] *** Quits: bjz (brendanzab@B398BE78.F804C29E.D35A31DF.IP) (Client exited)
[21:53:03] <flu_> just saved me ~6k LoC 
[21:53:20] <Eridius> flu_: cripes
[21:53:28] <steven_is_false> cmr: So then the installing program should search in case the library is installed in /usr/local/lib?
[21:53:34] *** Joins: bjz (brendanzab@B398BE78.F804C29E.D35A31DF.IP)
[21:53:48] <cmr> steven_is_false: what installing program?
[21:54:02] <cmr> (Is there context I'm not seeing?)
[21:54:04] <flu_> Eridius: yeah this API is kind of ridiculous. I'm guessing the authors were only thinking it would be used from C code, so they might as well expose absolutely everything! kitchen sink and all
[21:54:16] <steven_is_false> cmr: To build rust-bindgen I had too do rustc --link-args '-L /usr/local/lib'
[21:54:26] *** Quits: vosen (vosen@moz-266BA656.icpnet.pl) (Quit: Leaving)
[21:54:41] <cmr> steven_is_false: is /usr/local/lib in /etc/ld.so.conf or any of its included dirs?
[21:54:59] <cmr> (or LD_LIBRARY_PATH)
[21:55:18] <steven_is_false> No.
[21:55:39] <steven_is_false> I guess I should set LD_LIBRARY_PATH myself?
[21:55:41] <cmr> steven_is_false: you should add it, then, and run ldconfig, if you want libraries in there to be found by default.
[21:55:56] <cmr> well that only works for dynamic libs, but that works too
[21:56:27] <steven_is_false> Is there a per user ld.so.conf ?
[21:56:33] <strcat> steven_is_false: no
[21:57:03] <steven_is_false> Then if I could get LD_LIBRARY_PATH to work it'd be the best option.
[21:57:07] *** Joins: vosen (vosen@moz-266BA656.icpnet.pl)
[22:01:49] *** Quits: infynyxx (infynyxx@moz-E95B370B.nyc.res.rr.com) (Client exited)
[22:04:04] <bjz> brson: r? http://en.wikipedia.org/wiki/Error_function
[22:04:20] <bjz> oops
[22:04:30] <cmr> heh
[22:04:35] *** Joins: infynyxx (infynyxx@moz-E95B370B.nyc.res.rr.com)
[22:04:37] <bjz> brson: r? https://github.com/mozilla/rust/pull/6986
[22:06:31] *** Joins: deepdog (deepdog@moz-490E834C.client.mchsi.com)
[22:07:39] *** Quits: webber46 (webber46@moz-DC342D45.cust.bredband2.com) (Quit: webber46)
[22:10:21] *** Joins: tgt (tgt@moz-D59EE478.aztw.cable.virginmedia.com)
[22:11:00] <steven_is_false> Uggh, bindgen is giving annoying errors. How can it not find stdarg.h
[22:11:38] <flu_> steven_is_false: it just worked like a champ for me ^_^ how'd you run it?
[22:12:02] <steven_is_false>  bindgen `pkg-config libxml-2.0 --cflags --libs` -match libxml headers.h
[22:12:15] <steven_is_false> headers.h includes all the libxml headers
[22:12:18] <flu_> huh. that's pretty much what I did
[22:12:49] <flu_> I used ./bindgen `pkg-config --cflags --libs MagickWand` -match agic -o magickwand2.rs magickwand.h
[22:13:12] <flu_> maybe your param order with pkg-config?
[22:18:28] <steven_is_false> flu_: I just hacked around the problem with an explicit include of     -I /usr/local/lib/clang/3.4/include \
[22:23:02] *** Quits: doener (doener@moz-121949B3.unitymediagroup.de) (Quit: leaving)
[22:26:25] *** Quits: eholk (eholk@moz-9AB4D52F.hsd1.ut.comcast.net) (Quit: eholk)
[22:27:02] *** Joins: dylukes (dylukes@moz-E4DF3FED.pitbpa.fios.verizon.net)
[22:27:59] *** Joins: maxli (maxli@C03F2759.C70D537E.2FA4EA88.IP)
[22:38:37] *** Quits: maxli (maxli@C03F2759.C70D537E.2FA4EA88.IP) (Quit: Leaving.)
[22:39:28] *** Joins: ghrust (ghrust@AC22872E.6A2AE50.F3114085.IP)
[22:39:28] <ghrust> 01[13rust01] 15bors merged 06auto into 06incoming: 02http://git.io/ordpAQ
[22:39:28] *** Parts: ghrust (ghrust@AC22872E.6A2AE50.F3114085.IP) ()
[22:40:15] <flu_> has anybody 'optparse' or is the current standard to roll your own?
[22:40:32] <flu_> granted I don't need anything complex, just trying to stick with the emerging standards :-)
[22:40:38] <bstrie> flu_: I think there's an optparse lib in the standard library somewher
[22:41:18] <cmr> flu_: std::getopts
[22:41:23] <cmr> or maybe extra
[22:41:37] <cmr> yeah, extra::getopts
[22:41:39] <flu_> I'm building against incoming, it seems like everything is in extra now?
[22:41:43] <cmr> yes
[22:41:49] <flu_> thanks!
[22:42:26] *** Joins: ghrust (ghrust@AD60B2E3.6A2AE50.F3114085.IP)
[22:42:26] <ghrust> 01[13rust01] 15bors pushed 0 new commits to 06auto: 02http://git.io/2PZqkw
[22:42:26] *** Parts: ghrust (ghrust@AD60B2E3.6A2AE50.F3114085.IP) ()
[22:42:27] *** Joins: ghrust (ghrust@FD7BC443.6A2AE50.F3114085.IP)
[22:42:27] <ghrust> 01[13rust01] 15bors pushed 2 new commits to 06auto: 02http://git.io/wgO5hg
[22:42:27] <ghrust> 13rust/06auto 14be06af5 15Daniel Micay: cmp: remove duplicate free functions
[22:42:27] <ghrust> 13rust/06auto 144835d54 15bors: auto merge of #7028 : thestinger/rust/cmp, r=brson
[22:42:27] *** Parts: ghrust (ghrust@FD7BC443.6A2AE50.F3114085.IP) ()
[22:45:18] *** Joins: tiffany (kawaii@moz-1E0FE6E8.dhcp.embarqhsd.net)
[22:46:11] *** Quits: infynyxx (infynyxx@moz-E95B370B.nyc.res.rr.com) (Client exited)
[22:47:07] *** Joins: jensnockert (jensnocker@moz-DC345667.cust.bredband2.com)
[22:47:44] *** Quits: jensnockert (jensnocker@moz-DC345667.cust.bredband2.com) (Input/output error)
[22:50:54] <flu_> easy doc change here if any of you are merge meisters - https://github.com/mozilla/rust/pull/7035
[22:51:06] *** Quits: tgt (tgt@moz-D59EE478.aztw.cable.virginmedia.com) (Quit: Computer has gone to sleep.)
[22:51:16] <bjz> LUQMAN I LOVE YOU!
[22:51:22] <bjz> FFF
[22:51:30] <bjz> https://github.com/mozilla/rust/issues/4228
[22:51:51] *** Quits: FrozenCow (FrozenCow@moz-B2DF4929.chello.nl) (Quit: Leaving)
[22:51:54] * bjz is sad he can't inform dbaupp at this time
[22:52:14] <bjz> moonchrome: loook!!^
[22:52:14] *** Quits: dylukes (dylukes@moz-E4DF3FED.pitbpa.fios.verizon.net) (Quit: ["Textual IRC Client: www.textualapp.com"])
[22:53:32] <bjz> moonchrome: apologisies for being slow on the pull
[22:53:43] <bjz> moonchrome: should I say, the lmath fix
[22:54:06] <bjz> I think I'm gonna go back to square one again though, with the macro thing
[22:54:32] <bjz> since that has now been fixed
[22:54:54] *** Joins: dualhbridge (dad@moz-9FEE6D3B.maine.res.rr.com)
[22:57:15] *** Quits: koomi (koomi@moz-E8AECC1E.pools.arcor-ip.net) (Ping timeout)
[22:57:39] <cmr> steven_is_false: your formatting in #7027 is bad.
[22:57:49] <cmr> steven_is_false: run `make tidy` on that branch
[22:58:08] <cmr> specifically the extern block for libdl
[22:58:25] <cmr> Nice work on that one though
[22:58:35] *** Joins: sawrubh (uid6719@moz-D8B63698.irccloud.com)
[22:59:49] *** Joins: gmcabrita (uid4474@moz-D8B63698.irccloud.com)
[23:01:28] <steven_is_false> cmr: Okay.
[23:02:16] <moonchrome> bjz, this is nice, still macros seem like a good way to go about implementing operators since you don't have associated items yet so it's better than copy-pasting :)
[23:02:35] <steven_is_false> How does make tidy work?
[23:02:42] <moonchrome> bjz, just that now you can have generic Vec<T> trait right 
[23:02:48] <cmr> Just runs lint passes and a python script over the source files
[23:03:46] *** Quits: doomlord (doomlod@moz-8F385DB0.range109-153.btcentralplus.com) (Ping timeout)
[23:06:21] *** Joins: stowellde (uid6365@moz-D8B63698.irccloud.com)
[23:08:07] <flu_> has vec::tail moved someplace, or been removed in preference to destructuring?
[23:08:23] <flu_> (building against incoming)
[23:08:29] <strcat> still seems to exist
[23:08:34] <strcat> it shouldn't
[23:08:36] <cmr> rusti: use std::vec; vec::tail
[23:08:38] -rusti- more than 5 lines of output, pastebinned: http://sprunge.us/TSiZ
[23:08:38] <steven_is_false> cmr: Done.
[23:08:50] <strcat> flu_: use the method
[23:09:58] <flu_> rgr
[23:12:26] *** Joins: ghrust (ghrust@2EE61FCC.6A2AE50.F3114085.IP)
[23:12:26] <ghrust> 01[13rust01] 15bors 04force-pushed 06auto from 144835d54 to 149bcf911: 02http://git.io/N3iJvQ
[23:12:26] *** Parts: ghrust (ghrust@2EE61FCC.6A2AE50.F3114085.IP) ()
[23:13:03] <cmr> steven_is_false: you don't need to use fmt!() in conjunction with fail!() and friends.
[23:13:23] <ssbr> Hm.
[23:13:29] <cmr> rusti: fail!("look, ma, no boilerplate! %? %?", 15, "foo")
[23:13:30] <ssbr> The "core" and "std" pages in the docs are identical.
[23:13:31] -rusti- more than 5 lines of output, pastebinned: http://sprunge.us/iAjM
[23:13:37] <ssbr> Did someone forget to remove "core" and add "extras"?
[23:13:47] <cmr> rusti: fail!("look, ma, no boilerplate! %? %?", 15, "foo");
[23:13:49] -rusti- more than 5 lines of output, pastebinned: http://sprunge.us/hcLi
[23:13:57] <cmr> steven_is_false: well, I'm sure you get the point :p
[23:14:16] <steven_is_false> cmr: That's useful to know.
[23:14:29] <Luqman> bjz: haha thanks and i'm pretty sure dbaupp already knows :P
[23:14:38] <cmr> steven_is_false: additionally, why do you have the extra newlines in "Could not load self as module:\n%s\n" ? You shouldn't use any newlines at all.
[23:14:52] *** Parts: \n (NDesaulnie@moz-C2B49FFE.hsd1.ca.comcast.net) ()
[23:15:43] *** Quits: donri (dag@moz-9BB61102.tbcn.telia.com) (Client exited)
[23:16:14] <steven_is_false> cmr: That's a matter of opinion but I can lose them
[23:17:14] *** Joins: koomi (koomi@moz-E8AECC1E.pools.arcor-ip.net)
[23:17:26] <cmr> steven_is_false: And convention. No code anywhere in the stdlib/compiler does it.
[23:17:39] <steven_is_false> cmr: Fair enough.
[23:18:07] <flu_> So if I added some commits to a branch and reopen a PR that references that branch, it will get the latest commits right? i.e., the PR is for the branch, not a specific commit on the branch, right?
[23:18:30] <cmr> flu_: yup
[23:18:36] <flu_> sweet
[23:18:51] <steven_is_false> cmr: I think the error messages for dl are big but I can't remember.
[23:19:32] <cmr> steven_is_false: then maybe it's best to log them with error/warn/info/debug
[23:19:45] <cmr> probably error
[23:21:34] <steven_is_false> cmr: error!("stuff"); fail!("other stuff") ?
[23:21:44] <cmr> steven_is_false: yeah
[23:22:45] <steven_is_false> cmr: Seems reasonable, but let me double check the error message sizes before I do that.
[23:25:22] <cmr> A final nit, the prevailing style is to not have a space on the left side of a colon, so eg "filename : Option<...>" would be "filename: Option<...>" and so on
[23:25:42] <bjz> moonchrome: yeah ofc
[23:25:43] <cmr> Other than that, looks good to me, and is a nice interface.
[23:25:44] <steven_is_false> cmr: Right, I'll fix that.
[23:25:56] <bjz> moonchrome: again, sorry for being so slow
[23:26:10] <bjz> moonchrome: I got sidetracked with std::num
[23:26:46] <flu_> wrt that style guideline, I'm really happy to see modern languages embracing the "name: Type" standard
[23:26:54] <bjz> would somebody be able to r? this, I'm worried about it rotting: https://github.com/mozilla/rust/pull/6986
[23:26:58] *** Joins: int3_ (int3_@moz-ABE52D50.hsd1.ca.comcast.net)
[23:27:17] <ssbr> Are there any pointer types that let you have multiple mutable references to the same data, other than @mut?
[23:27:18] <steven_is_false> flu_: Why not name  Type ?
[23:27:18] <bjz> flu_: pascal type notation :)
[23:27:35] <cmr> ssbr: *mut
[23:27:41] <ssbr> I can't use @mut in rt-less rust, and moreover it doesn't give me the nice guarantee that the value dies
[23:27:42] <ssbr> cmr: blech
[23:27:45] <flu_> steven_is_false: if my keyboard had an 'is a member of' key, I'd totally be on board for that
[23:28:10] <flu_> maybe in the future programmers can have special badass keyboards and we can all use the type theory symbols 
[23:28:34] <steven_is_false> flu_: Or you can use Emacs.
[23:28:35] <cmr> flu_: http://en.wikipedia.org/wiki/Space-cadet_keyboard
[23:28:41] <flu_> vim or die man
[23:28:43] <SiegeLord> You know what would benefit Rust'd documentation? A whole bunch of <hr />
[23:28:52] <strcat> ssbr: extra::rc::RcMut
[23:28:54] *** Quits: int3_ (int3_@moz-ABE52D50.hsd1.ca.comcast.net) (Ping timeout)
[23:29:36] <bjz> strcat: would you be able to review that pull?
[23:29:44] <flu_> cmr: oooh. that is nice. I bet Linux has some dusty mapping for it hanging around
[23:30:05] <cmr> Lisp machines were really cool
[23:30:07] <ssbr> strcat: that isn't documented in 0.6
[23:30:13] <ssbr> strcat: was it added in incoming?
[23:30:19] <strcat> ssbr: I don't know what's in 0.6
[23:30:26] <ssbr> strcat: well, the docs for extra are not available
[23:30:34] <ssbr> for incoming.
[23:30:35] <bjz> strcat: it has lots of changes to differenet files, I'm worried it will rot. It removes most of the free functions in the numeric modules
[23:30:51] <strcat> ssbr: there are no pre-generated docs for incoming regardless
[23:30:53] <ssbr> blegh, I'll read source code later
[23:30:54] <strcat> bjz: I will, don't worry :)
[23:31:03] <strcat> ssbr: you can generate docs with rustdoc
[23:31:03] <bjz> strcat: cheers :)
[23:31:11] <bjz> strcat: lucky it's a weekend :)
[23:31:13] <ssbr> strcat: whatever the docs are for the thing that isn't 0.6 on the rust homepage
[23:31:23] *** Joins: doomlord (doomlod@moz-8F385DB0.range109-153.btcentralplus.com)
[23:31:23] <ssbr> I am guessing the doc generator is broken
[23:31:23] <cmr> (master)
[23:31:32] <steven_is_false> Can anybody think of a symbol guaranteed not to exist in the current binary?
[23:31:39] <strcat> ssbr: graydon just hasn't gotten around to updating the names
[23:31:42] <strcat> on the site
[23:31:49] <steven_is_false> And a library guaranteed not to exist on the current system?
[23:32:06] <ssbr> strcat: aha! you're right
[23:32:08] <cmr> steven_is_false: asdasdgjklhertuioyhejkln is a pretty good guess :p
[23:32:08] <ssbr> http://static.rust-lang.org/doc/extra/index.html exists
[23:32:14] <strcat> ssbr: yeah just the links aren't updated
[23:32:24] <steven_is_false> cmr: I guess.
[23:32:25] <strcat> and there are lots of obsolete pages to remove
[23:32:27] <ssbr> strcat: mmmmmf
[23:32:36] <ssbr> strcat: but there's no equivalent to &mut without aliasing restrictions, then?
[23:32:46] <strcat> ssbr: no, that wouldn't be safe
[23:32:53] <ssbr> strcat: Oh?
[23:32:55] <strcat> &mut has restrictions to make it memory safe
[23:33:00] <strcat> they aren't just there for fun ;p
[23:33:02] <ssbr> strcat: in what way would it not be safe?
[23:33:11] <ssbr> I'd feel a lot better if I wasn't frustrated by this limitation
[23:33:19] <strcat> data foo = bar | baz;
[23:33:20] <ssbr> (it's bitten me a lot)
[23:33:23] <strcat> x = bar;
[23:33:26] <strcat> let y = &mut x;
[23:33:29] <strcat> x = baz;
[23:33:32] <strcat> y is a dangling ref
[23:33:37] <strcat> plenty of other ways to do it too
[23:34:14] <strcat> containers/enums can have references into them invalidated by changing the size/layout/type
[23:34:16] <ssbr> strcat: I don't understand why y wouldn't point to baz after you do "x = baz"
[23:34:23] <ssbr> strcat: that's how it'd work in C with unions
[23:34:26] <strcat> ssbr: &mut x.foo then
[23:34:43] <ssbr> strcat: can you write an example using raw pointers or C that fails?
[23:34:48] <strcat> ssbr: sure
[23:35:05] <strcat> ssbr: I'll write one with a dangling reference, no guarantee it *does* a specific thing
[23:35:12] <ssbr> strcat: fair enough
[23:35:36] <strcat> rusti: let x = Some(~"foo"); let y = &(x.get()[0]);
[23:35:37] -rusti- ()
[23:36:12] <strcat> rusti: let mut x = Some(~"foobar"); let y: *u8 = &(x.get()[5]); x = None;
[23:36:13] -rusti- ()
[23:36:19] <strcat> rusti: let mut x = Some(~"foobar"); let y: *u8 = &(x.get()[5]); x = None; unsafe { *y }
[23:36:20] -rusti- 114
[23:36:28] <strcat> rusti: let mut x = Some(~"foobar"); let y: *u8 = &(x.get()[5]); x = None; unsafe { *y }
[23:36:29] -rusti- 114
[23:36:42] <strcat> rusti: let mut x = Some(~"foobar adgfdsagdsg"); let y: *u8 = &(x.get()[15]); x = None; unsafe { *y }
[23:36:44] -rusti- 100
[23:36:54] <strcat> anyway that's doing invalid reads
[23:36:56] <ssbr> I see
[23:37:04] *** Quits: doomlord (doomlod@moz-8F385DB0.range109-153.btcentralplus.com) (Ping timeout)
[23:37:07] <strcat> there are lots of ways to do it though
[23:37:28] <ssbr> now I get what you mean by &mut x.foo
[23:37:54] <strcat> rusti: let mut x = ~"foobar"; let y: *u8 = &x[5]; x.clear(); unsafe { *y }
[23:37:55] -rusti- more than 5 lines of output, pastebinned: http://sprunge.us/LjIT
[23:38:01] <ssbr> I will stop being frustrated, then, until I think I can see a way that doesn't involve garbage collection :p
[23:38:14] <strcat> ssbr: reference counting
[23:38:29] <ssbr> strcat: garbage counting or reference counting
[23:38:33] <strcat> anyway you can have multiple &mut references into the same thing
[23:38:36] <strcat> they just can't overlap
[23:38:47] <ssbr> I do like the typed guarantee that the reference dies at the end of the scope, that's basically all I want
[23:38:54] <ssbr> no possibility of accidentally storing it somewhere forever
[23:39:01] <ssbr> maybe that's silly
[23:39:23] <ssbr> I want a reason for the non-@ pointers to exist other than "efficiency" and "concurrency"
[23:39:33] <ssbr> because I don't personally do either of those things :p
[23:39:47] <cmr> ssbr: perhaps... rust isn't the language for you? :P
[23:40:17] <strcat> ssbr: because @mut gives dynamic failures like java/python for using mutability wrong
[23:40:21] <strcat> seems like a good enough reason to me
[23:40:43] <ssbr> cmr: of course it is
[23:40:57] <strcat> T, ~T, &T, &mut T, @T -> no such thing as iterator invalidation or other misuses of references/mutability
[23:41:34] <ssbr> cmr: I was complaining for nearly a year that there was no usable thing that was "ML, plus typeclasses". Rust is essentially what I wanted, except it added pointers too.
[23:41:43] <ssbr> so I need to somehow work in a love for Rust's safe pointers
[23:41:47] <ssbr> so that I will be happy :p
[23:42:06] <cmr> ssbr: well efficiency and concurrency are huge drivers for rust's design
[23:42:08] <strcat> ssbr: I don't know of another language with mutability + the guarantee that you can't invalidate references/iterators
[23:42:13] <strcat> so.. there's that
[23:42:21] <strcat> and deterministic resource management
[23:42:41] <ssbr> cmr: it doesn't have to be designed with me in mind to be good for me. I don't like the reasons for any of the languages I like :P
[23:42:52] <cmr> heh, fair enough
[23:42:56] <strcat> if you stay away from @mut, it's always clear where mutation happens from the signatures
[23:43:10] <flu_> if I'm creating a string in a function, would it be correct to return an ~str? Seems that since the box is created and returned from the function, the owner can safely own it
[23:43:14] <ssbr> strcat: so far I've had a lot of problems with the mutability controls, and not much benefit
[23:43:19] <cmr> flu_: yes
[23:43:22] <ssbr> strcat: could you expand more on invalidation of references/iterators?
[23:43:26] <flu_> rgr
[23:43:47] <flu_> s/owner/caller - but point communicated anyway
[23:43:51] <strcat> ssbr: take a reference/iterator from a container, modify the container in a way that makes it invalid -> dynamic failure in java/python, memory unsafety in C++
[23:44:03] <ssbr> strcat: ahhhh, right
[23:44:11] <ssbr> strcat: that's the thing I just learned about!
[23:44:18] <ssbr> which I need to learn to appreciate.
[23:44:18] <strcat> ssbr: that can't happen in rust without @mut because it statically freezes it
[23:45:33] *** Joins: aatch (aatch@moz-B437F499.pocketrent.com)
[23:45:49] <cmr> Luqman: can you comment a bit on #7029? Does it allow multiple impls when they *only* add static methods, or what?
[23:46:02] *** Quits: koomi (koomi@moz-E8AECC1E.pools.arcor-ip.net) (Ping timeout)
[23:46:35] <cmr> (I can't really tell from the source)
[23:46:40] *** Quits: deepdog (deepdog@moz-490E834C.client.mchsi.com) (Ping timeout)
[23:47:56] <Luqman> cmr: you could already have something like impl Foo { fn one(&self) {} } impl Foo { fn two(&self) {} }
[23:48:28] <Luqman> what you couldn't do before was impl Foo { fn one() {} } impl Foo { fn two() {} }
[23:48:52] <cmr> Seems like a weird asymmetry
[23:49:43] *** Joins: Guest_ (textual@moz-A3295542.nycmny.fios.verizon.net)
[23:50:06] <Luqman> when rustc sees a static method, it creates a new mod. Thus the way you call it `Foo::bar()`
[23:50:33] *** Quits: Guest_ (textual@moz-A3295542.nycmny.fios.verizon.net) (Quit: My MacBook Pro has gone to sleep. ZZZzzz)
[23:50:33] <SiegeLord> Hmm... actually you can get pretty far in making Rust documentation look ok with a better CSS file
[23:50:45] <Luqman> so what was happening was it was trying to create a new mod with the same name for the second impl and thus failing
[23:50:55] <cmr> SiegeLord: *Please* *do* send a PR for that if you come up with anything better
[23:51:17] *** Joins: reyre_ (reyre@moz-9002CDDA.cpe.net.cable.rogers.com)
[23:51:19] <Luqman> so i just changed it to check if a mod with that name (that was made for an impl) already exists
[23:51:23] *** Quits: brson (brson@2557E599.66715431.D25A875A.IP) (Quit: leaving)
[23:51:51] <cmr> Luqman: Cool. Thanks :)
[23:53:35] <flu_> what does the single quote before a type indicate? I've seen this in the library code in a few places, but havent ran across it in the docs
[23:53:56] <steven_is_false> flu_: You mean a lifetime parameter?
[23:53:57] <cmr> flu_: named lifetimes. http://static.rust-lang.org/doc/tutorial-borrowed-ptr.html
[23:54:11] <flu_> something like "pub fn substr<'a>(s: &'a str, begin: uint, n: uint) -> &`a str"
[23:54:35] <flu_> yep, named lifetimes it is!
[23:55:46] <ssbr> Can I perform a match on a vec where I obtain the first element of the vec, and a slice for the rest of the vec? i.e. something equivalent to "x:xs" in Haskell
[23:55:47] *** Joins: dbaupp (Thunderbir@moz-C6B1454A.lns20.syd7.internode.on.net)
[23:56:33] *** Quits: devbug (quassel@moz-E1DE087C.bchsia.telus.net) (Client exited)
[23:57:21] *** Quits: Earnestly (earnest@6A917A59.5E1FD793.39C00A7A.IP) (Quit: WeeChat 0.4.2-dev)
[23:58:00] *** Quits: reyre_ (reyre@moz-9002CDDA.cpe.net.cable.rogers.com) (Client exited)
[23:58:14] <aatch> ssbr, yes
[23:58:25] <aatch> rusti: 5
[23:58:26] -rusti- 5
[23:58:29] <ssbr> Oh no, the mathematician's answer
[23:58:34] <ssbr> aatch: How do I do that?
[23:58:41] <flu_> the match clause is [x, ..xs] right?
[23:58:46] <ssbr> I couldn't find a syntax for it
[23:58:49] <ssbr> flu_: ah, is that it?
[23:58:58] <flu_> think so, rusti is griping at me :-/
[23:58:59] <aatch> rusti: let a = ~[1,2,3,4]; let [a,..as] = a; (a, as)
[23:59:00] -rusti- more than 5 lines of output, pastebinned: http://sprunge.us/LjDD
[23:59:03] <flu_> cant get my box types right
[23:59:04] <heftig> it deconstructs into x as head and xs as tail
[23:59:22] <aatch> rusti: let a = ~[1,2,3,4]; let [a,..ar] = a; (a, as)
[23:59:22] -rusti- <anon>:10:49: 10:50 error: found `as` in ident position
[23:59:22] -rusti- <anon>:10          let a = ~[1,2,3,4]; let [a,..ar] = a; (a, as)
[23:59:22] -rusti-                                                            ^
[23:59:22] -rusti- error: aborting due to previous error
[23:59:23] -rusti- application terminated with error code 101
[23:59:24] <aatch> rusti: let a = ~[1,2,3,4]; let [a,..ar] = a; (a, ar)
[23:59:26] -rusti- more than 5 lines of output, pastebinned: http://sprunge.us/TYZg
[23:59:47] <ssbr> rusti: let a = ~[1,2,3,4]; let [..ar] = a; ar
[23:59:50] -rusti- more than 5 lines of output, pastebinned: http://sprunge.us/JhCa
[23:59:56] *** Quits: jaen (jaen@moz-E0979827.copit.pl) (Ping timeout)

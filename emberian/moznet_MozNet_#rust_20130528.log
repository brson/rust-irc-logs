[00:00:57] <strcat> https://github.com/thestinger/playpen/commit/01a43014bff81ce504f981ce7e7c49e58070785e yay? ;p
[00:01:12] <cmr> playpen is your lxc replacement?
[00:01:16] <strcat> yes
[00:01:25] <cmr> fun name :)
[00:01:26] <strcat> it's broken-ish atm though
[00:01:31] <strcat> the timerfd loop has something wrong
[00:02:54] <strcat> rusti: for 5.times { println("foo") }
[00:02:55] -rusti- foo
[00:02:55] -rusti- foo
[00:02:55] -rusti- foo
[00:02:55] -rusti- foo
[00:02:55] -rusti- foo
[00:02:57] <strcat> hm
[00:03:00] *** Joins: erickt (Adium@49C4075F.3AC15C18.2321E71E.IP)
[00:03:12] *** Quits: dbaupp (Thunderbir@moz-C6B1454A.lns20.syd7.internode.on.net) (Ping timeout)
[00:05:09] <jdm> arrgh
[00:05:12] <jdm> what is the secret
[00:05:17] <jdm> how can I move this value into the closure?
[00:06:20] <jdm> http://pastebin.mozilla.org/2451764
[00:06:23] <jdm> halp D:
[00:06:34] <strcat> jdm: use a Cell
[00:06:38] <jdm> ooh, right
[00:07:34] <strcat> cmr: I thought about making it in rust but I'd have to make so many bindings and deal with varargs ;p
[00:07:51] <strcat> libseccomp uses varargs functions without va_list versions too
[00:07:55] <strcat> so you can't even make wrappers in C
[00:14:53] *** Quits: EXetoC (ex@moz-C741B177.customer.t3.se) (Quit: WeeChat 0.4.1)
[00:15:10] *** Joins: SiegeLord (sl@moz-CAF07B4C.hsd1.ma.comcast.net)
[00:18:28] *** Joins: ghrust (ghrust@moz-4EF5B6E5.rs.github.com)
[00:18:28] <ghrust> 01[13rust01] 15alexcrichton 04force-pushed 06try from 14e6c04de to 141ab23ea: 02http://git.io/k471pw
[00:18:28] <ghrust> 13rust/06try 1474508d6 15Alex Crichton: Define rustc's host triple at compile time...
[00:18:28] <ghrust> 13rust/06try 141ab23ea 15Alex Crichton: Un-ignore rusti/rustpkg tests on i686
[00:18:29] *** Parts: ghrust (ghrust@moz-4EF5B6E5.rs.github.com) ()
[00:20:00] *** Joins: ctult (Mibbit@moz-78482241.bois.qwest.net)
[00:20:21] <halorgium> is there a notion of implemented methods in a Trait
[00:20:28] <ctult> Has anyone tried to embed mruby in Rust?
[00:22:29] <cmr> halorgium: es http://static.rust-lang.org/doc/rust.html#traits
[00:24:49] <halorgium> cmr: i was unsure if these were simply examples of interfaces (re: java) compared to traits as in scala. 
[00:25:31] <halorgium> i would like a trait to carry the implementation so as to get some form of multiple-inheritance
[00:25:41] * halorgium is coming from ruby with module inclusion
[00:26:14] <cmr> i may not have understood the question
[00:26:36] <halorgium> i guess this is it: error: default methods are experimental
[00:27:19] <halorgium> cmr: when you include a module (or trait) in ruby, you end up with the class or module in which the module is being included into receiving new implemented methods
[00:30:53] *** Quits: tiffany (kawaii@moz-1E0FE6E8.dhcp.embarqhsd.net) (No route to host)
[00:31:02] *** Joins: tiffany (kawaii@moz-1E0FE6E8.dhcp.embarqhsd.net)
[00:35:13] *** Quits: ctult (Mibbit@moz-78482241.bois.qwest.net) (Quit: http://www.mibbit.com ajax IRC Client)
[00:35:41] *** Quits: jack (jack@2557E599.66715431.D25A875A.IP) (Quit: Leaving.)
[00:35:56] *** Quits: threecreepio (jdp@moz-DB2D70E9.cust.bredbandsbolaget.se) (Quit: threecreepio)
[00:36:42] <cmr> strcat: cgroups have a really nice api, from what I can see
[00:36:51] <strcat> cmr: they do.
[00:37:00] <strcat> mkdir, rmdir to make/remove
[00:37:21] <strcat> cgroup.procs is a sorted/unique list of pids in the group
[00:38:17] <strcat> and you just echo 0 to tasks to add a pid :)
[00:38:23] <strcat> well, the current pid
[00:38:34] * strcat still hates sending SIGKILL signals...
[00:42:33] <strcat> I guess if I freeze the group I don't have to worry about that
[00:43:00] <strcat> anyway pids don't get reused that fast ;p
[00:43:15] <strcat> needs to wrap around
[00:43:46] <graydon> strcat: I have recently had success with cgroups-to-measure-memory-use
[00:43:46] *** Joins: jack (jack@2557E599.66715431.D25A875A.IP)
[00:43:56] <strcat> graydon: :)
[00:45:37] <graydon> though it requires creating a group, running the command, and deleting the group
[00:45:45] <graydon> otherwise A-ok
[00:47:43] <strcat> graydon: if you're on a system with systemd you can use systemd-cgtop
[00:47:53] <strcat> still have to make the group though.
[00:47:57] <strcat> it's just a nice way to watch it
[00:48:05] <graydon> not watch, measure. unattended.
[00:48:09] <strcat> ah
[00:48:19] <graydon> I've been trying to do that reliably for a long time!
[00:48:27] <graydon> so thanks :)
[00:48:53] *** Joins: maxli (maxli@C03F2759.C70D537E.2FA4EA88.IP)
[00:52:36] *** Joins: erickt1 (erickt@49C4075F.3AC15C18.2321E71E.IP)
[00:53:11] *** Quits: erickt1 (erickt@49C4075F.3AC15C18.2321E71E.IP) (Quit: Leaving.)
[00:54:12] *** Quits: snadon (chatzilla@moz-3BC727E8.mc.videotron.ca) (Ping timeout)
[00:57:04] <cmr> strcat: what are MS_SLAVE and MS_REC in mount?
[00:57:12] <cmr> I don't see them in mount(2)
[00:57:58] *** Joins: ghrust (ghrust@moz-4EF5B6E5.rs.github.com)
[00:57:58] <ghrust> 01[13rust01] 15bors merged 06auto into 06incoming: 02http://git.io/zah5QQ
[00:57:58] *** Parts: ghrust (ghrust@moz-4EF5B6E5.rs.github.com) ()
[00:58:58] *** Quits: eatkinson (eatkinson@2557E599.66715431.D25A875A.IP) (Quit: eatkinson)
[00:59:28] <strcat> cmr: MS_REC is recursive, MS_SLAVE makes it not appear outside the container
[00:59:50] <strcat> so when I mounted proc, tmp, and home/rust, their lifetime is tied to the process and the children
[00:59:58] <strcat> that's why I don't have to umount 
[01:00:11] <cmr> handy
[01:00:34] <strcat> CLONE_NEWNS gives the process a new fs namespace but if it mounts stuff, stuff outside will still see it (and it will stick around)
[01:00:55] *** Joins: ghrust (ghrust@moz-4EF5B6E5.rs.github.com)
[01:00:55] <ghrust> 01[13rust01] 15bors pushed 5 new commits to 06auto: 02http://git.io/nNmYuQ
[01:00:55] <ghrust> 13rust/06auto 146c03fbf 15Tim Chevalier: testsuite: Add passing test for #4735
[01:00:55] <ghrust> 13rust/06auto 1458547d6 15Tim Chevalier: testsuite: Add working test for #5550
[01:00:56] <ghrust> 13rust/06auto 14403aee1 15Tim Chevalier: testsuite: Test cases, one xfailed, one not
[01:00:58] *** Parts: ghrust (ghrust@moz-4EF5B6E5.rs.github.com) ()
[01:01:27] <strcat> cmr: it's mostly documented in the kernel docs
[01:01:30] <strcat> rather than man page :(
[01:01:48] <cmr> Yeah, I had too look at Documentation/ for the cgroup stuff
[01:01:49] <strcat> afaik a lot of this stuff was added recently for systemd
[01:01:54] *** Joins: aruniiird (arun@84E199D6.DCDBCF8E.83D0DF30.IP)
[01:02:08] <strcat> containers and reliable services with real resource limits are both relatively new things
[01:02:09] <Eridius> woo, I now officially have a commit in rust
[01:02:43] <graydon> acrichto: ping
[01:04:07] <strcat> cmr: signalfd is especially amazing. can just epoll signals as fds and get info about them
[01:04:11] <strcat> yay linux specific APIs
[01:04:25] <cmr> strcat: yeah, I'd never seen some of these apis before.
[01:04:29] <strcat> portable signal handling is a hell I've been spared from
[01:04:33] *** Quits: erickt (Adium@49C4075F.3AC15C18.2321E71E.IP) (Quit: Leaving.)
[01:05:36] <strcat> cmr: it's all relatively controversial. everything is moving towards these wonderful APIs, and they don't exist on freebsd, etc.
[01:06:18] <strcat> gnome is essentially linux-only now ;\
[01:06:59] <cmr> The only computer I've owned that succesfully ran freebsd was a laptop from 2006
[01:07:16] <cmr> Everything else has had various hardware driver issues :(
[01:07:37] *** Joins: erickt (Adium@49C4075F.3AC15C18.2321E71E.IP)
[01:09:19] *** Quits: maxli (maxli@C03F2759.C70D537E.2FA4EA88.IP) (Quit: Leaving.)
[01:09:25] *** Joins: eatkinson (eatkinson@2557E599.66715431.D25A875A.IP)
[01:10:46] *** Joins: maxli (maxli@C03F2759.C70D537E.2FA4EA88.IP)
[01:13:52] <strcat> cmr: thanks for the fixes :)
[01:14:03] <cmr> np
[01:16:49] <cmr> strcat: I plan on adding syscall list support. I planned on doing this by having a file of the format "name number\n" per arch to map from name->number, generated from the linux headers. Sane?
[01:17:45] *** Quits: q66 (q66@6EE9DE40.46454B5D.33AABD5F.IP) (Client exited)
[01:18:05] <strcat> cmr: that sounds sane
[01:18:19] <strcat> one of the things I hate about lxc is that it makes you write the whitelist with numbers... ;p
[01:18:26] <cmr> yeah
[01:18:48] <strcat> cmr: could also generate code directly
[01:19:00] <strcat> just some sorted table of names to bsearch on
[01:19:35] *** Quits: maxli (maxli@C03F2759.C70D537E.2FA4EA88.IP) (Quit: Leaving.)
[01:19:45] <cmr> mm, that'd be nice
[01:20:26] <strcat> cmr: vodik has a branch with getopt stuff so that'd probably be useful
[01:20:29] <strcat> dunno if that's done
[01:20:36] *** Quits: eatkinson (eatkinson@2557E599.66715431.D25A875A.IP) (Quit: eatkinson)
[01:20:55] <strcat> he's going to be using it for something unrelated (build server for arch linux AUR packages)
[01:23:59] *** Parts: twm (twm@moz-13417AD3.dsl.static.sonic.net) ()
[01:24:50] *** Quits: tjc (tjc@A5087023.2354C43D.D8E68FF6.IP) (Quit: Places to go, people to annoy)
[01:27:34] <acrichto> graydon: pong
[01:27:51] <graydon> acrichto: hey, I just commented on that space regression
[01:27:58] *** Joins: ghrust (ghrust@moz-4EF5B6E5.rs.github.com)
[01:27:58] <ghrust> 01[13rust01] 15bors 04force-pushed 06auto from 14cda347f to 14e6a838d: 02http://git.io/N3iJvQ
[01:27:58] *** Parts: ghrust (ghrust@moz-4EF5B6E5.rs.github.com) ()
[01:27:59] *** Joins: ghrust (ghrust@moz-4EF5B6E5.rs.github.com)
[01:27:59] <ghrust> 01[13rust01] 15bors pushed 2 new commits to 06auto: 02http://git.io/ltxEaQ
[01:27:59] <ghrust> 13rust/06auto 14cf34f9f 15Patrick Walton: librustc: Allow intra-crate start functions, for runtimeless operation.
[01:27:59] <ghrust> 13rust/06auto 142061ce9 15bors: auto merge of #6741 : pcwalton/rust/intra-crate-start, r=graydon...
[01:27:59] *** Parts: ghrust (ghrust@moz-4EF5B6E5.rs.github.com) ()
[01:28:11] <graydon> was wondering if we could do some investigation, but it's late, don't want to bother you at this hour if you're busy / done for the day
[01:29:21] <acrichto> graydon: sure, I'll definitely take a look into this tonight
[01:29:29] *** Quits: dylukes (dylukes@moz-E4DF3FED.pitbpa.fios.verizon.net) (Quit: ["Textual IRC Client: www.textualapp.com"])
[01:30:53] <acrichto> My best guess as to where the cycle would be is that during the new linting process some cycle is created between a crate and the linting context
[01:31:23] <graydon> mhm
[01:31:36] <graydon> did you add any fields to the AST? I don't .. see any
[01:31:43] <acrichto> https://github.com/mozilla/rust/blob/incoming/src/librustc/middle/lint.rs#L1034
[01:31:56] <acrichto> would something like that cause a cycle?
[01:32:12] <acrichto> the cx has the tcx embedded in it, which I imagine takes up a whole lot of memory
[01:32:26] <graydon> line 1034 is ..
[01:32:52] <graydon> yes, dropping the tcx is part of what we're trying to accomplish. it's where most of the memory lives
[01:32:57] *** Quits: engla (engla@moz-DBD1D96E.cust.bredbandsbolaget.se) (Quit: Lost terminal)
[01:33:04] <graydon> maybe a lint context <-> tcx cycle?
[01:33:25] <graydon> tcx -> session -> lintcx -> tcx, say?
[01:33:26] <acrichto> the tcx won't have any pointers into the lint context
[01:33:34] *** Joins: engla (engla@moz-DBD1D96E.cust.bredbandsbolaget.se)
[01:33:36] <graydon> who owns the lint context?
[01:33:40] <acrichto> how about lintcx -> visitor -> lintcx ?
[01:33:42] <acrichto> is that possible?
[01:33:53] <acrichto> because each visitor created is closed over the lint cx
[01:33:59] <graydon> visitors are usually transient. but if they close over ... 
[01:33:59] <graydon> yeah
[01:34:02] <graydon> might be
[01:34:03] *** Joins: youknowone (youknowone@A826BD81.8A0DEF81.38747683.IP)
[01:34:03] *** Quits: youknowone (youknowone@A826BD81.8A0DEF81.38747683.IP) (Z:lined (Open Proxy found on your host. Please visit www.blitzed.org/proxy?ip=115.68.131.49 for more information.))
[01:34:06] <acrichto> I think that's the problem then
[01:34:15] <acrichto> I'll try to remove that and see if the usage drops
[01:34:19] *** Quits: erickt (Adium@49C4075F.3AC15C18.2321E71E.IP) (Quit: Leaving.)
[01:34:28] <graydon> thanks, if you can figure out an equivalent formulation!
[01:34:58] <acrichto> just curious, but would the new gc free the memory despite the cycle?
[01:35:03] <graydon> yes
[01:35:11] <graydon> this is an artifact of refcounting
[01:35:11] * strcat hopes the swap changes killed off a fair bit of movbs
[01:35:21] <acrichto> ah, that's right
[01:36:20] *** Joins: infynyxx (infynyxx@moz-E95B370B.nyc.res.rr.com)
[01:36:39] <strcat> graydon: is there any reason for keeping everything around while we're calling ld? seems like it could all be dropped by then
[01:36:57] <graydon> you mean the valgrind stuff?
[01:36:58] *** Joins: eatkinson (eatkinson@2557E599.66715431.D25A875A.IP)
[01:36:59] <graydon> er
[01:37:02] <graydon> the llvm stuff?
[01:37:03] <strcat> the ld fork is where I get OOM after I've been letting this silly intel driver leak
[01:37:12] <strcat> graydon: yeah, there's a huge amount of memory around when it calls out to ld
[01:37:14] *** Quits: eatkinson (eatkinson@2557E599.66715431.D25A875A.IP) (Quit: eatkinson)
[01:37:23] <graydon> sadly IIRC we don't know how to ask LLVM to drop its memory
[01:37:31] <graydon> I can check, maybe there's something obvious
[01:38:08] <graydon> oh, yeah, I guess we could dispose of the module?
[01:38:11] *** Quits: snearch (snearch@moz-E718D633.pool.mediaways.net) (Quit: Verlassend)
[01:39:10] <strcat> graydon: that sounds good :)
[01:39:24] <strcat> perhaps everything could also be run in a task beforehand? not sure how invasive that would be.
[01:39:43] *** Quits: infynyxx (infynyxx@moz-E95B370B.nyc.res.rr.com) (Client exited)
[01:39:57] <strcat> I do know I'm used to seeing ICEs from fork() failing now :)
[01:40:09] <strcat> but this weird leak messes with overcommit
[01:40:10] *** Joins: kyle2000 (kyle2000@D3528B97.7E2E8376.3031298E.IP)
[01:40:19] *** Joins: infynyxx (infynyxx@moz-E95B370B.nyc.res.rr.com)
[01:40:21] <strcat> it tries to drop these weird cached pages and gets stuck ;\
[01:40:48] *** Joins: eholk (eholk@moz-9AB4D52F.hsd1.ut.comcast.net)
[01:40:53] <aatch> strcat, it does drop the module before linking
[01:41:15] <strcat> aatch: hrm, strange - there's really a lot of memory left around
[01:41:17] <aatch> it writes everything to a temporary .o file
[01:41:36] <graydon> aatch: doesn't look like we do LLVMDisposeModule
[01:42:01] <aatch> graydon, we do, inside link::run_passes
[01:42:13] <graydon> oic
[01:42:31] <aatch> I would give you a line number, but my ones won't line up...
[01:42:41] <graydon> yeah, I see it now, np
[01:42:58] *** Quits: SiegeLord (sl@moz-CAF07B4C.hsd1.ma.comcast.net) (Quit: It's a joke. It's all a joke.)
[01:43:48] *** Quits: Earnestly (earnest@6A917A59.5E1FD793.39C00A7A.IP) (Ping timeout)
[01:46:48] *** Joins: SiegeLord (siege@moz-CAF07B4C.hsd1.ma.comcast.net)
[01:54:25] *** Joins: benw (Mibbit@moz-57951E38.perm.iinet.net.au)
[01:59:09] *** Quits: MrFahrenheit (RageOfThou@3FEF494C.29C984D5.783DEDCA.IP) (Ping timeout)
[01:59:21] *** Quits: cjh (chellmuth@moz-45C21C42.compute-1.amazonaws.com) (Ping timeout)
[02:00:32] *** Joins: cjh (chellmuth@moz-45C21C42.compute-1.amazonaws.com)
[02:03:00] *** Quits: balpert (alpert@moz-B247840C.hsd1.ca.comcast.net) (Quit: balpert)
[02:03:45] *** Joins: fairfieldt (fairfieldt@moz-D8998E1C.xen.prgmr.com)
[02:04:23] *** Quits: kyle2000 (kyle2000@D3528B97.7E2E8376.3031298E.IP) (Client exited)
[02:04:47] *** Joins: kyle2000 (kyle2000@D3528B97.7E2E8376.3031298E.IP)
[02:05:34] *** Quits: kyle2000 (kyle2000@D3528B97.7E2E8376.3031298E.IP) (Quit: Leaving)
[02:12:11] *** Joins: wilsonk|2 (kvirc@moz-39EFBFC2.cg.shawcable.net)
[02:12:16] *** Quits: aruniiird (arun@84E199D6.DCDBCF8E.83D0DF30.IP) (Ping timeout)
[02:13:04] *** Quits: wilsonk-laptop (kvirc@moz-39EFBFC2.cg.shawcable.net) (Ping timeout)
[02:13:45] *** Quits: Jesse (jruderman@moz-537BCF9.hsd1.ca.comcast.net) (Quit: Jesse)
[02:13:58] *** Joins: Jesse (jruderman@moz-537BCF9.hsd1.ca.comcast.net)
[02:14:18] *** Joins: kyle2000 (kyle2000@D3528B97.7E2E8376.3031298E.IP)
[02:14:51] *** Joins: bytbox (s@moz-D83E9B31.wireless.umd.edu)
[02:15:02] *** Joins: MaikKlein (maik@moz-A3453BF6.dip0.t-ipconnect.de)
[02:15:18] <kyle2000> friends, am i correct in my understanding that rust does not support overloading function names?
[02:15:27] <aatch> kyle2000, yep
[02:17:12] <kyle2000> okay. and there are no default parameter values either? so the recommended rust practice is to use multiple functions with different names, with one calling the other and providing an argument representing the default value?
[02:17:37] <cmr> kyle2000: for now, yes
[02:17:38] <aatch> kyle2000, if that's the way it makes the most sense, then yes
[02:17:40] *** Joins: cowboyd (cowboyd@moz-DD0FF83.lightspeed.austtx.sbcglobal.net)
[02:18:11] *** Joins: balpert (alpert@moz-B247840C.hsd1.ca.comcast.net)
[02:20:28] *** Quits: BitPuffin (quassel@moz-8370D1B9.bredband.comhem.se) (Client exited)
[02:21:50] *** Quits: kyle2000 (kyle2000@D3528B97.7E2E8376.3031298E.IP) (Quit: Leaving)
[02:22:48] *** Quits: benw (Mibbit@moz-57951E38.perm.iinet.net.au) (Quit: http://www.mibbit.com ajax IRC Client)
[02:24:11] *** Quits: catpig (catpig@moz-FE9C02B0.dip0.t-ipconnect.de) (Quit: Verlassend)
[02:24:56] *** Joins: ghrust (ghrust@moz-4EF5B6E5.rs.github.com)
[02:24:56] <ghrust> 01[13rust01] 15bors merged 06auto into 06incoming: 02http://git.io/ltxEaQ
[02:24:56] *** Parts: ghrust (ghrust@moz-4EF5B6E5.rs.github.com) ()
[02:26:27] *** Quits: Jesin (Jessin_@moz-A03A364F.cc.lehigh.edu) (Ping timeout)
[02:27:57] *** Joins: ghrust (ghrust@moz-4EF5B6E5.rs.github.com)
[02:27:57] <ghrust> 01[13rust01] 15bors pushed 0 new commits to 06auto: 02http://git.io/qW_JBQ
[02:27:57] *** Parts: ghrust (ghrust@moz-4EF5B6E5.rs.github.com) ()
[02:28:00] *** Joins: ghrust (ghrust@moz-4EF5B6E5.rs.github.com)
[02:28:00] <ghrust> 01[13rust01] 15bors pushed 3 new commits to 06auto: 02http://git.io/8jYadA
[02:28:00] <ghrust> 13rust/06auto 14e6a5165 15Niko Matsakis: Issue #3678: Remove wrappers and call foreign functions directly
[02:28:00] <ghrust> 13rust/06auto 1453df1c8 15Niko Matsakis: Remove unused function trans_external_path_casted
[02:28:00] <ghrust> 13rust/06auto 14257b2f0 15bors: auto merge of #6661 : nikomatsakis/rust/issue-3678-wrappers-be-gone-2, r=brson...
[02:28:02] *** Parts: ghrust (ghrust@moz-4EF5B6E5.rs.github.com) ()
[02:28:17] *** Joins: sanxiyn (tinuviel@858F408C.B797260D.EF43EC08.IP)
[02:28:50] <sanxiyn> Is r/rust mod around?
[02:29:08] <aatch> graydon, you will be please to know that my changes will expose the LLVM lint pass too
[02:29:19] <graydon> aatch: excellent
[02:29:24] *** Joins: slimer (Mibbit@moz-E308C5A2.hsd1.wa.comcast.net)
[02:29:32] <graydon> == cgroup == max memory used: 2372120576
[02:29:39] <graydon> == cgroup == max memory used: 1904123904
[02:29:43] <graydon> I like that!
[02:29:43] <aatch> Ouch
[02:30:20] <sanxiyn> How does one get "max memory used" output?
[02:30:27] <graydon> 2 line patch, 400mb less memory use
[02:30:50] *** Quits: MaikKlein (maik@moz-A3453BF6.dip0.t-ipconnect.de) (Ping timeout)
[02:30:56] <graydon> sanxiyn: um, using a cgroups hack strcat suggested
[02:31:30] <strcat> sanxiyn: you can mkdir /sys/fs/cgroup/memory/name, echo a pid (0 for current) to the tasks file and then read memory.max_usage_in_bytes for the memory total of that process + anything it spawned
[02:31:31] <sanxiyn> Eh, where can I learn about it?
[02:31:36] <graydon> https://gist.github.com/graydon/0261eb4d954f2ebee838
[02:31:38] <graydon> sorry, was pasting :)
[02:31:54] <sanxiyn> Thanks
[02:31:59] *** Quits: balpert (alpert@moz-B247840C.hsd1.ca.comcast.net) (Quit: balpert)
[02:32:09] <graydon> that script as "measure.sh" means you can run "measure.sh <somecommand>" and get nice cpu-time-and-max-memory numbers
[02:32:13] <strcat> sanxiyn: http://www.mjmwired.net/kernel/Documentation/cgroups/
[02:32:35] <sanxiyn> Can it also limit amount of memory used, besides measuring?
[02:32:38] <graydon> yes
[02:32:43] <strcat> sanxiyn: yes, rusti uses it
[02:32:46] <sanxiyn> Ah
[02:32:53] <strcat> sanxiyn: you can also limit cpu shares, throttle network traffic, etc.
[02:33:07] <strcat> reliably kill a service + all pids it spawned
[02:33:08] <aatch> Oh wow. The LLVM linter is going crazy on our output...
[02:33:13] <graydon> good
[02:33:21] <graydon> we know we do bad idioms. I'd like to see them pointed out.
[02:33:24] <sanxiyn> graydon: re: https://mail.mozilla.org/pipermail/rust-dev/2013-May/004214.html
[02:33:35] <sanxiyn> #6703 was mine, but it did went back to DISCUSSING, IIRC
[02:33:38] <sanxiyn> I think it was timing issue
[02:33:44] <graydon> sanxiyn: oh, ok
[02:33:48] <aatch> tonnes of undefined behaviour
[02:33:54] <strcat> sanxiyn: https://github.com/thestinger/playpen that's what rusti uses, if you're curious
[02:34:21] <graydon> aatch: I love the feeling of turning on a diagnostic tool for the first time (or first time in a while :)
[02:34:24] <sanxiyn> graydon: I suspect Gareth's case was also timing issue
[02:35:14] <sanxiyn> I've seem some maxim from Coverity presentation that you will find all kinds of broken codes as long as it compiles
[02:35:34] <aatch> Well it looks like my changes work anyway. I'll do some more testing, clean up (including adding a flag to turn the linter) and submit a pull-req
[02:35:56] <sanxiyn> By the way, what was this 2 line patch?
[02:36:14] <graydon> aatch: is this the LLVM-optimization-selection hackery?
[02:36:35] <aatch> graydon, yep, though it's not particuluarly hacky.
[02:36:36] <graydon> sanxiyn: involves fixing a table in the tcx to use hashmap rather than smallintmap
[02:36:52] <graydon> aatch: sorry, didn't mean to imply hack-like-bad; just stuff-you-were-working-on
[02:37:02] <aatch> And atm it just replicates the current behaviour
[02:37:20] <aatch> with some minor tweaks
[02:37:25] <graydon> aatch: excellent, I will review with gusto
[02:37:53] *** Quits: jack (jack@2557E599.66715431.D25A875A.IP) (Ping timeout)
[02:38:41] <aatch> like adding the lint pass, always stripping dead prototypes and aggressive now runs the MergeFunctions pass
[02:39:45] *** Joins: snadon (chatzilla@moz-3BC727E8.mc.videotron.ca)
[02:40:30] *** Joins: dbaupp (Thunderbir@55A980D9.D5A1DCF.37681C44.IP)
[02:40:47] *** Quits: kimundi (kimundi@moz-345A3880.dip0.t-ipconnect.de) (Ping timeout)
[02:42:27] <graydon> cool. does mergefunctions help much?
[02:42:36] <aatch> graydon, haven't tested it yet.
[02:42:44] <graydon> k
[02:42:57] <aatch> I'm also unsure of the best place in the pipeline, so it's at the end atm
[02:43:07] <graydon> good as any for a start
[02:43:31] <strcat> our IR is really quite hideous so it's not surprising that the lint is mad
[02:43:41] *** Joins: kimundi (kimundi@moz-77E3ACED.dip0.t-ipconnect.de)
[02:44:10] <graydon> there's a lot of technical debt to pay down there, but I have high hopes
[02:44:10] <sanxiyn> How about getting rid of addrspace at least?
[02:44:22] <graydon> that is a patch in the gc-branch queue
[02:44:28] <sanxiyn> ok
[02:44:50] <sanxiyn> (Today is memorial day, right?0
[02:44:50] <strcat> graydon: it doesn't really seem that hard, it's just a million papercuts
[02:45:00] <graydon> yeah
[02:45:01] <strcat> lots of unnecessary casts and weird labels
[02:45:03] <cmr> sanxiyn: yes
[02:45:07] <graydon> sanxiyn: yes,  but I'm in canada
[02:46:03] *** kimundi is now known as zz_kimundi
[02:47:18] <bjz> rusti: let f = |x: int| x * x; fmt!("%?", f)
[02:47:19] -rusti- ~""
[02:47:29] <bjz> interesting
[02:47:55] <sanxiyn> Huh
[02:48:15] <slimer> quick questions: Does anybody know of any tutorials or sample code using the futures library from libstd? And is there any significant overhead in using futures? 
[02:48:48] *** Quits: jyasskin_w (jyasskin@DAF66858.C60FE7DC.4065847B.IP) (Ping timeout)
[02:49:04] <cmr> slimer: see the tests and the code
[02:49:33] *** Joins: jyasskin_w (jyasskin@DAF66858.C60FE7DC.4065847B.IP)
[02:49:35] <cmr> https://github.com/mozilla/rust/blob/incoming/src/libextra/future.rs
[02:49:56] <bjz> slimer: unfortunately that's as good as you're probably going to get for now :(
[02:50:32] <bjz> slimer: if you work some things out, help with documentation is most appreaciated
[02:50:46] <slimer> Okay, I would love to help
[02:51:16] <bjz> I'm sure the relavant folks are willing to lend their advice
[02:52:35] <slimer> any idea where I can find the tests? The directory structure for the tests is not quite as intuitive as the src
[02:52:44] <cmr> slimer: they're in the source file
[02:52:46] <cmr> scroll down :)
[02:52:54] <cmr> https://github.com/mozilla/rust/blob/incoming/src/libextra/future.rs#L149
[02:52:57] <bjz> slimer: for library stuff it's usually at the bottom
[02:52:59] <slimer> ahh
[02:53:02] <slimer> doh :)
[02:53:12] <bjz> the tests directory is mostly for compiler stuff
[02:53:34] <bjz> but I think there might be some bleed with some of the older tests
[02:53:44] <bjz> which can make it confusing
[02:54:57] *** Joins: ghrust (ghrust@moz-4EF5B6E5.rs.github.com)
[02:54:58] <ghrust> 01[13rust01] 15bors 04force-pushed 06auto from 14257b2f0 to 142061ce9: 02http://git.io/N3iJvQ
[02:54:58] *** Parts: ghrust (ghrust@moz-4EF5B6E5.rs.github.com) ()
[02:55:00] *** Joins: ghrust (ghrust@moz-4EF5B6E5.rs.github.com)
[02:55:01] <ghrust> 01[13rust01] 15bors pushed 2 new commits to 06auto: 02http://git.io/l3LnlA
[02:55:01] <ghrust> 13rust/06auto 14863369e 15Patrick Walton: librustc: Only emit visitor glue if it's necessary....
[02:55:01] <ghrust> 13rust/06auto 14708367c 15bors: auto merge of #6744 : pcwalton/rust/visitor-glue, r=graydon...
[02:55:01] *** Parts: ghrust (ghrust@moz-4EF5B6E5.rs.github.com) ()
[02:55:03] *** Quits: jdm (jdm@DB05BBF2.BB1F48F2.971E19F6.IP) (Quit: Lost terminal)
[02:55:12] <slimer> well the location of the lib tests is certainly good to know. This is my first stab at a managed memory language and I've been banging my head for a while trying to figure some of this out. Sample code is definitely going to help. 
[02:55:28] <aatch> slimer, C/C++ background?
[02:55:36] <bjz> nmatsakis: dang :(
[02:55:39] <cmr> nmatsakis: bounced again :(
[02:56:02] *** Quits: SiegeLord (siege@moz-CAF07B4C.hsd1.ma.comcast.net) (Connection reset by peer)
[02:56:22] <cmr> actually, why did that fail?
[02:56:38] <slimer> No, I don't have any formal CS or engineering background. I'm a BI engineer, and most of my work involves languages that are convenient for analysis: R, Octave, Python, and Clojure
[02:56:50] <sanxiyn> What is BI?
[02:56:57] <slimer> Business Intelligence
[02:57:01] <bjz> slimer: well, I would say 'safe manual memory management', not 'managed memory'
[02:57:21] <bjz> slimer: managed memory is optional
[02:57:42] <slimer> I think the safety is what made me think it was time to try it. I always felt I would shoot myself in the foot with C/C++
[02:58:01] <bjz> slimer: bear in mind the std/extra code can be patchy style-wise
[02:58:25] <bjz> slimer: the language has evolved a bit
[02:58:46] <slimer> Thats okay, I've been expecting that. I think almost everything I've seen so far has been amazing. 
[02:58:59] *** Joins: SiegeLord (sl@moz-CAF07B4C.hsd1.ma.comcast.net)
[02:59:23] <aatch> Hence the clarification. Since rust occupies an odd space between the two extremes of C ("automatic freeing? Oh you mean the stack!") and say Java ("Trust in the garbage collector, ignore those occasional stalls")
[03:00:27] <strcat> it's the same way you manage resources in C++, but without the very likely possibility of getting any of it wrong (especially dangling refs) ;p
[03:00:34] <bjz> aatch: GC is optional
[03:00:45] <slimer> Yeah, I definitely confuse the vocabulary. Its all pretty new to me. 
[03:01:02] <bjz> aatch: I would say the semantics closely resemble C/C++
[03:01:04] <aatch> bjz, I know, I was talking about Java, in which it isn't
[03:01:09] <cmr> slimer: definitely send documentation patches if there's things you find confusing! :)
[03:01:11] <slimer> I didn't even know what a GC was until last month...all the languages I've used seem to hide it from me pretty well
[03:01:26] <bjz> slimer: that's the point of it
[03:01:32] <bjz> slimer: but that
[03:01:36] <aatch> and that, in terms of memory management, Rust is between the two extremes.
[03:01:59] <bjz> slimer: good on you for branching out and trying to learn different languages
[03:02:05] <slimer> Thanks
[03:02:19] *** Quits: dbaupp (Thunderbir@55A980D9.D5A1DCF.37681C44.IP) (Ping timeout)
[03:02:24] <bjz> slimer: it will help you when you go back to GCed languages too
[03:02:44] <a_m0d> Is anyone working on cleaning up the references to core:: / std:: in the tutorials?
[03:02:53] <slimer> I've got another question that I haven't been able to figure out. Section 9.2 of the tutorial
[03:03:34] <aatch> and now I wait for the linter...
[03:03:46] <slimer> I thought I understood the difference between a variable and a box, but then there was this concept of a mutable variable vs a mutable box
[03:03:49] <strcat> a_m0d: it might be done already
[03:03:58] <strcat> docs on the site are from master
[03:04:12] <a_m0d> strcat: ok, didn't realise that.  Thanks.
[03:04:30] <slimer> Are there any other tutorials that can help me understand the difference?
[03:05:04] <cmr> slimer: boxes are just a certain type that variables can have
[03:05:31] <strcat> slimer: managed boxes aren't owned by the variable so the mutability is a property of the type, like in python
[03:05:51] <slimer> Why would I ever need a mutable variable with an immutable box, or vice versa?
[03:05:54] <cmr> slimer: non-boxed variables are values, boxes are references to values, and how you access that value is determined by that box
[03:05:58] <graydon> \o/ gc+heapmap can build libcore, libstd
[03:06:11] <cmr> slimer: mutable variables can be reassigned.
[03:06:26] <cmr> rusti: let a = @mut 10; a = @mut 20; a
[03:06:28] -rusti- more than 5 lines of output, pastebinned: http://sprunge.us/RMDc
[03:06:36] <cmr> rusti: let mut a = @mut 10; a = @mut 20; a
[03:06:37] -rusti- more than 5 lines of output, pastebinned: http://sprunge.us/HdhZ
[03:06:50] <graydon> n_bytes_swept: 16136104 curr, 19480472 total
[03:07:09] <cmr> strcat: can you please turn off most of the warnings on rusti, like unused variable and dead assignment?
[03:07:21] <graydon> (all this effort for a tiny little 16mb reclaimed!)
[03:08:31] <aatch> We really need to clean up the glue_* code in terms of IR output
[03:08:38] <graydon> (it's not that, it's the 30% smaller binary that results)
[03:08:47] <graydon> aatch: yes, known reality :(
[03:08:56] <strcat> cmr: yes, I'll just copy them from the repl
[03:09:08] <slimer> So does a mutable box let it contain different types? or different sizes of collections? 
[03:09:20] <aatch> The lint's errors are like 80% from glue_* code
[03:09:27] <strcat> slimer: just lets you mutate it
[03:09:32] <cmr> slimer: mutable box lets you mutate the boxes contents
[03:09:37] <strcat> slimer: think tuple vs list in python
[03:09:41] <graydon> ah nuts. still peaking over 2.8gb rss with heapmap.
[03:09:51] <aatch> slimer, rust is statically typed, meaning that variable has one type, and one type only, for it's entire lifetime.
[03:09:59] <slimer> okay
[03:10:09] <a_m0d> Is it possible to send an owned vector through a channel?
[03:10:20] <aatch> a_m0d, should be
[03:10:31] <strcat> graydon: you still get to kill the headers, if you can figure out what the hell reads them ;p
[03:10:32] <aatch> as long as the contents are owned
[03:10:48] <graydon> strcat: oh, I know. this is strictly ...
[03:10:54] <a_m0d> aatch: do you know anywhere where that might already be done?
[03:10:56] <strcat> at least the list ptrs?
[03:11:02] <graydon> I'm trying to get the GC memory-use overhead low enough that it'll bootstrap on x86
[03:11:05] <aatch> a_m0d, no sorry
[03:11:08] <a_m0d> I'm having trouble getting the stream() call to pass typechecking :/
[03:11:10] <graydon> x86 has small address space, y'know :)
[03:11:21] <strcat> graydon: yeah, I just think that's the biggest reason we use so much memory
[03:11:33] <cmr> graydon: can it be cross compiled, temporarily?
[03:11:47] <aatch> a_m0d, oh yeah, the type inferrer has some issues there, try stream::<~[MyType]>();
[03:11:50] <graydon> in this case it's gc accounting overhead
[03:12:21] <a_m0d> aatch: actually, I just discovered that I simply had to require the Owned trait on my function to get it to pass
[03:12:21] <graydon> cmr: for a single build, sure. but to what end? it won't be able to build rustc anymore.
[03:12:31] <aatch> a_m0d, or that.
[03:12:39] <a_m0d> now I think I just need to get Cells working somehow
[03:15:59] <graydon> ok, heading home. ttyl.
[03:16:03] *** Quits: graydon (Adium@A5087023.2354C43D.D8E68FF6.IP) (Quit: Leaving.)
[03:16:34] *** Joins: brson (brson@E02A6CDD.75598729.B6A3AE99.IP)
[03:16:34] *** ChanServ sets mode: +o brson
[03:18:24] <strcat> rusti: let x = 5;
[03:18:26] -rusti- foo.rs:8:13: 8:14 warning: unused variable: `x` [-W unused-variable (default)]
[03:18:26] -rusti- foo.rs:8          let x = 5;
[03:18:26] -rusti-                       ^
[03:18:26] -rusti- note: in expansion of fmt!
[03:18:26] -rusti- foo.rs:7:12: 9:7 note: expansion site
[03:18:28] <strcat> hm
[03:18:41] <strcat> rusti: let x = 5;
[03:18:42] -rusti- foo.rs:8:13: 8:14 warning: unused variable: `x` [-W unused-variable (default)]
[03:18:42] -rusti- foo.rs:8          let x = 5;
[03:18:42] -rusti-                       ^
[03:18:42] -rusti- note: in expansion of fmt!
[03:18:42] -rusti- foo.rs:7:12: 9:7 note: expansion site
[03:18:45] <strcat> ;\
[03:19:03] <strcat> rusti: core::run::run_program("cat", [~"foo.rs"]);
[03:19:04] -rusti- more than 5 lines of output, pastebinned: http://sprunge.us/EQcO
[03:19:12] <strcat> rusti: std::run::run_program("cat", [~"foo.rs"]);
[03:19:13] -rusti- more than 5 lines of output, pastebinned: http://sprunge.us/KgMb
[03:19:20] <a_m0d> Is rust smart about how many threads it starts when using std::spawn()
[03:19:30] <a_m0d> or does it just try to run them all at once?
[03:19:50] <cmr> rusti: extra::run::run_program("cat", [~"foo.rs"]);
[03:19:52] -rusti- more than 5 lines of output, pastebinned: http://sprunge.us/bWHb
[03:19:56] <cmr> hm
[03:19:56] <aatch> a_m0d, it's not particularly intelligent
[03:20:02] <cmr> oh whoops
[03:20:04] <strcat> it was renamed
[03:20:13] <a_m0d> Is the re-write going to fix that?
[03:20:20] <aatch> a_m0d, yep.
[03:20:22] <strcat> rusti: let x = 5;
[03:20:28] <a_m0d> Or should I try to be careful with how many times I call spawn()?
[03:20:48] <aatch> a_m0d, is this just the standard task spawner?
[03:20:53] <a_m0d> yes.
[03:21:14] <a_m0d> I've got a sequential and parallel merge-sort implementation written
[03:21:24] *** Quits: Sorella (queen@B12A78F5.BA14766C.95C8B7C6.IP) (Quit: (quit))
[03:21:24] <a_m0d> and the parallel one is definitely slower
[03:21:36] <strcat> a_m0d: use the sched mode mapping to threads
[03:21:59] <strcat> and you'll only want to spawn 2, 4, 8 or some reasonable number
[03:22:03] <a_m0d> This is most likely due to my bad programming skills and very in-efficient implementation, but I was not expecting this level of overhead from using tasks
[03:22:10] <aatch> Ok, well the standard task::spawn just creates a new task and attaches it to the current scheduler.
[03:22:15] <a_m0d> strcat: Ok, I'll try that
[03:22:27] <strcat> a_m0d: CPU-parallel code requires being careful about dividing up work
[03:22:41] <strcat> it's not the same approach as concurrent code where you're doing I/O
[03:22:50] <a_m0d> strcat: sadly :/ I was hoping it was just magic :)
[03:22:54] <aatch> the current scheduler is (I think) still multi-threaded though
[03:23:13] <strcat> well if he's spawning 2 tasks for every recursion it will be a lot slower than just single-threaded
[03:23:21] <aatch> strcat, that too.
[03:23:24] <a_m0d> But I guess these tasks aren't light weight like Go's then
[03:23:29] <strcat> a_m0d: they are
[03:23:34] <a_m0d> strcat: that's pretty much what I'm doing
[03:23:42] <Ralith> a_m0d: lightweight doesn't mean free.
[03:23:42] <strcat> you wouldn't get a speed-up in Go from spawning 2 with every recursion
[03:23:54] <a_m0d> One task for half the vector, and the other half on the main thread
[03:24:14] <a_m0d> Ok, so the problem is just my implementation then
[03:24:25] <a_m0d> That's good to know, and gives me something to play with.
[03:24:35] <a_m0d> Thanks
[03:24:58] *** Joins: ghrust (ghrust@moz-4EF5B6E5.rs.github.com)
[03:24:58] <ghrust> 01[13rust01] 15bors 04force-pushed 06auto from 14708367c to 142061ce9: 02http://git.io/N3iJvQ
[03:24:58] *** Parts: ghrust (ghrust@moz-4EF5B6E5.rs.github.com) ()
[03:24:59] *** Joins: ghrust (ghrust@moz-4EF5B6E5.rs.github.com)
[03:24:59] <ghrust> 01[13rust01] 15bors pushed 2 new commits to 06auto: 02http://git.io/vFP4rA
[03:24:59] <ghrust> 13rust/06auto 14dea6677 15Olivier Saut: Add a short section on ARC
[03:24:59] <ghrust> 13rust/06auto 146d7d759 15bors: auto merge of #6752 : osaut/rust/tutorial-tasks, r=graydon...
[03:24:59] *** Parts: ghrust (ghrust@moz-4EF5B6E5.rs.github.com) ()
[03:25:22] <strcat> a_m0d: goroutines and rust tasks are also only lightweight in the sense that they use very little virtual memory and can yield immediately on I/O
[03:26:03] <strcat> OS threads don't really consume more actual memory, just address space
[03:26:10] <a_m0d> ok
[03:26:36] <strcat> well and they'll yield on I/O too. but they also preempt
[03:26:38] <a_m0d> I've not really done much work with threading, concurrency, or parallelism
[03:26:58] <a_m0d> strcat: no io going on in the work that I'm doing though - just 100% CPU
[03:27:23] *** Joins: echristo (echristo@moz-CE1AD9FD.hsd1.ca.comcast.net)
[03:27:23] <aatch> strcat, you will be pleased to hear that mergefunctions in LLVM does do /something/ though it didn't seem to make a difference to the size of librustc
[03:27:45] <strcat> aatch: something? :)
[03:28:05] <aatch> it does combine identical functions.
[03:28:26] <aatch> it leaves the one behind with a tail call to the other
[03:28:32] <strcat> how long does it take?
[03:28:42] <aatch> strcat, haven't tested it yet.
[03:28:52] *** Quits: sanxiyn (tinuviel@858F408C.B797260D.EF43EC08.IP) (Ping timeout)
[03:29:01] <aatch> I'm figuring out where this leak is coming from first
[03:30:17] *** Quits: cowboyd (cowboyd@moz-DD0FF83.lightspeed.austtx.sbcglobal.net) (Client exited)
[03:30:22] <aatch> They're still reachable, so it might be nothing
[03:31:02] <a_m0d> Is there a way to determine the number of cores available on the system?
[03:32:21] *** Joins: siavashserver (siavash@B86D67DD.AC532F77.82A25C10.IP)
[03:32:35] *** Joins: cowboyd (cowboyd@moz-DD0FF83.lightspeed.austtx.sbcglobal.net)
[03:33:29] <aatch> a_m0d, I think so.
[03:34:57] *** Quits: cjh (chellmuth@moz-45C21C42.compute-1.amazonaws.com) (Ping timeout)
[03:35:03] *** Joins: cjh (chellmuth@moz-45C21C42.compute-1.amazonaws.com)
[03:35:31] *** Quits: cowboyd (cowboyd@moz-DD0FF83.lightspeed.austtx.sbcglobal.net) (Client exited)
[03:35:48] *** Joins: eatkinson (eatkinson@moz-5CF47426.dia.static.qwest.net)
[03:36:05] <a_m0d> aatch: any idea where that would be?
[03:36:13] <a_m0d> I didn't see it in std::task
[03:36:30] <aatch> a_m0d, oh, inside std? No, there isn't.
[03:36:31] *** Quits: infynyxx (infynyxx@moz-E95B370B.nyc.res.rr.com) (Client exited)
[03:36:37] <aatch> I thought you mean in general...
[03:36:45] <a_m0d> oh, no library support yet then
[03:37:19] <a_m0d> oh well, I'll just use another command line parameter then
[03:37:20] <a_m0d> Thanks
[03:37:33] <bjz> ugh, assert_eq! seems to want Copy
[03:38:11] <cmr> bjz: it shouldn't; it does moves?
[03:38:20] *** Joins: langhai (Mibbit@716C3E4.23F85D28.74F0EBEC.IP)
[03:39:02] <bjz> rusp.rs:285:19: 285:55 error: instantiating a type parameter with an incompatible type `Value`, which does not fulfill `Copy`
[03:39:03] <bjz> rusp.rs:285         assert_eq!(Symbol(Ident(~"a")).eval(env).get(), Int(0));
[03:39:03] <bjz>                                ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
[03:39:03] <bjz> <core-macros>:71:4: 82:5 note: in expansion of assert_eq!
[03:39:14] <bjz> I impled Clone on it
[03:39:44] <langhai> I wonder is there anyone translating the docs. I would like to help with that. 
[03:40:20] *** Quits: solancile (solancile@moz-A1CFFAE5.hsd1.wa.comcast.net) (Quit: Leaving)
[03:40:30] <aatch> langhai, there is not anyone (as far as I know). You are welcome to translate them, but they are likely to change quite frequently
[03:41:03] <aatch> Actually, hold off at the moment, we have enough trouble keeping the docs in sync with the code in one language
[03:41:13] <bjz> yeah
[03:41:21] <bjz> I would advise against it
[03:41:51] <cmr> bjz: why does assert_eq want Copy?
[03:42:00] <bjz> cmr: no idea
[03:42:31] <bjz> :)
[03:42:40] <langhai> that's quite interesting. maybe I'll wait until it's stable. Thanks for the tips
[03:43:47] <bjz> langhai: dw, we would love help
[03:44:00] <bjz> langhai: it's just difficult at this time
[03:45:02] *** Quits: eatkinson (eatkinson@moz-5CF47426.dia.static.qwest.net) (Quit: eatkinson)
[03:45:33] <langhai> any idea on when things will get stablised?
[03:45:44] <cmr> langhai: it could be a while
[03:45:59] <aatch> langhai, between now and the heat death of the universe.
[03:46:01] <aatch> Maybe
[03:47:57] <langhai> I'm looking at the english doc. looks like it doesn't even have all the grammars and features included.
[03:49:34] <bjz> langhai: nope :)
[03:50:06] <bjz> langhai: https://github.com/jbclements/rust-antlr
[03:50:25] <bjz> langhai: jbclements was working on a grammar
[03:51:28] <langhai> I meant this doc https://github.com/mozilla/rust.git. 
[03:52:36] *** Quits: a_m0d (a_m0d@moz-9F925EFA.hm.shawcable.net) (Quit: Leaving.)
[04:03:44] <aatch> https://github.com/mozilla/rust/pull/6778 <- Yay being better and stuff
[04:05:50] *** Quits: eholk (eholk@moz-9AB4D52F.hsd1.ut.comcast.net) (Quit: eholk)
[04:06:11] *** Joins: wuwei`lab (wuwei@1A513F49.818D7924.FAA9ED67.IP)
[04:07:06] *** Quits: engla (engla@moz-DBD1D96E.cust.bredbandsbolaget.se) (Ping timeout)
[04:09:01] *** Joins: fread2282 (Mibbit@moz-CB181B42.dia.static.qwest.net)
[04:09:10] <cmr> aatch: so some of the passes seem to be run multiple times in multiple places. is this because some passes enable more optimizations later?
[04:09:18] <fread2282> Would embedding rust in go or go in rust be a sane idea?
[04:09:19] <aatch> cmr, yep
[04:09:28] <strcat> fread2282: why?
[04:10:02] <aatch> some optimizations are cheaper than others. The instruction combiner for example is peep-hole, so pretty cheap
[04:10:15] <fread2282> strcat: embedding a go app in a rust one (or the other way around...but that would be insane for my idea)
[04:11:26] <fread2282> I guess I could do it with IPC or something
[04:12:56] <cmr> aatch: is loop unrolling supposed to be run twice with aggresive?
[04:13:20] *** Quits: stephank (stephank@FE6D378F.A6EC7F74.1E99A072.IP) (Ping timeout)
[04:13:38] <bjz> aatch: with the lisp thing, do you reckon Eval should just return an Expr?
[04:14:06] <bjz> aatch: I mean, Expr::eval
[04:14:22] <bjz> aatch: at the moment I have have it returning a Value
[04:14:24] <aatch> cmr, it's not, no
[04:14:36] <aatch> I put in the wrong pass
[04:14:44] <aatch> it's supposed to be loop vectorize pass
[04:15:03] <cmr> is that the fancy new SLP stuff?
[04:15:20] <aatch> cmr, no, I couldn't get it to link with that.
[04:15:31] <aatch> I'll investigate more later.
[04:15:31] <cmr> shame, ah well
[04:15:35] *** Quits: tiffany (kawaii@moz-1E0FE6E8.dhcp.embarqhsd.net) (Ping timeout)
[04:16:06] <aatch> bjz, eval() should return a Value.
[04:16:18] *** Quits: echristo (echristo@moz-CE1AD9FD.hsd1.ca.comcast.net) (Quit: echristo)
[04:16:32] <aatch> even if that value is a function or something
[04:16:40] <bjz> aatch: what happens if it evaluates to a lambda?
[04:16:43] <aatch> data == code, remember
[04:16:47] <bjz> yeah
[04:16:53] <bjz> that's the funny bit
[04:16:54] <bjz> :)
[04:17:22] <bjz> dbaupp did a parser
[04:17:32] <bjz> it's pretty complex though
[04:17:40] <bjz> (as he admits)
[04:17:50] <aatch> I saw.
[04:17:50] <bjz> dunno if we could improve it
[04:18:16] <aatch> Well given that it doesn't tokenize strings properly, I'm sure there's room for improvement :P
[04:18:23] <cmr> aatch: besides the unrolling, the PR looks good for me
[04:18:26] *** Joins: echristo (echristo@moz-CE1AD9FD.hsd1.ca.comcast.net)
[04:18:32] *** Joins: eatkinson_ (eatkinson@moz-5CF47426.dia.static.qwest.net)
[04:18:48] <bjz> aatch: if you have any time to spare, some assistance would be most welcome :)
[04:19:03] *** Joins: ghrust (ghrust@moz-4EF5B6E5.rs.github.com)
[04:19:03] <ghrust> 01[13rust01] 15bors merged 06auto into 06incoming: 02http://git.io/vFP4rA
[04:19:03] *** Parts: ghrust (ghrust@moz-4EF5B6E5.rs.github.com) ()
[04:19:20] <aatch> bjz, lol. I'll probably look at it tonight or tomorrow.
[04:19:34] <bjz> aatch: I also added a way to add Rust functions. Unfortunately that breaks deriving for Eq and Clone, and hence breaks the unit tests :(
[04:20:02] <bjz> aatch: but that will allow us to have something to stand on
[04:20:14] *** Quits: echristo (echristo@moz-CE1AD9FD.hsd1.ca.comcast.net) (Quit: echristo)
[04:20:17] *** Joins: echristo (echristo@moz-CE1AD9FD.hsd1.ca.comcast.net)
[04:20:53] <bjz> aatch: ie. add, sub, etc
[04:21:18] <bjz> (+, -, /, *, %, etc)
[04:21:25] <aatch> Ah yep.
[04:21:38] <bjz> looking at http://www.ee.ryerson.ca/~elf/pub/misc/micromanualLISP.pdf too
[04:22:03] *** Joins: ghrust (ghrust@moz-4EF5B6E5.rs.github.com)
[04:22:03] <ghrust> 01[13rust01] 15bors pushed 0 new commits to 06auto: 02http://git.io/IrxKDw
[04:22:03] *** Parts: ghrust (ghrust@moz-4EF5B6E5.rs.github.com) ()
[04:22:03] *** Joins: ghrust (ghrust@moz-4EF5B6E5.rs.github.com)
[04:22:03] <ghrust> 01[13rust01] 15bors pushed 2 new commits to 06auto: 02http://git.io/ruIRew
[04:22:03] <ghrust> 13rust/06auto 143c4ce79 15Graydon Hoare: rustc: Switch ty::node_type_table to smallintmap, cut 400mb memory use off a librustc build....
[04:22:03] <ghrust> 13rust/06auto 1426fb16e 15bors: auto merge of #6776 : graydon/rust/node-type-table-hashmap, r=thestinger...
[04:22:03] *** Parts: ghrust (ghrust@moz-4EF5B6E5.rs.github.com) ()
[04:22:13] *** Joins: stephank (stephank@FE6D378F.A6EC7F74.1E99A072.IP)
[04:22:28] <bjz> We might need a List Value varient too. as a stand in for cons/car/cdr
[04:23:22] <bjz> See the thing is, Bool, Int, Float, Str and Symbol are all Atoms
[04:23:30] <Ralith> why would you need a stand in for cons?
[04:23:34] <Ralith> cons is like the simplest data structure
[04:23:54] <Ralith> any simpler and it's not a structure anymore
[04:24:02] <bjz> Well, not really a stand-in
[04:24:18] <bjz> I guess that was a sloppy way of saying it
[04:24:27] <fread2282> can I use dynamic runtime linking (for plugins) in rust?
[04:25:04] <bjz> Ralith: are you familiar with implemnting Lisps?
[04:25:06] <cmr> fread2282: yes
[04:25:39] <fread2282> cmr: where should I read about it?
[04:25:48] <Ralith> bjz: yes.
[04:26:07] <cmr> fread2282: someone got it working recently... you have to use the OS facilities, though. dlopen etc
[04:26:11] *** Joins: dbaupp (Thunderbir@55A980D9.D5A1DCF.37681C44.IP)
[04:26:16] <fread2282> cmr: oh ok
[04:26:19] <bjz> Ralith: would you be able to help give some feedbck on a project I'm working on?
[04:26:42] <Ralith> bjz: if it's not too involved.
[04:26:55] <Ralith> shouldn't spend too much time
[04:27:15] <bjz> Ralith: if you have any time
[04:27:19] <bjz> Ralith: https://github.com/bjz/rusp/blob/master/rusp.rs
[04:27:28] <bjz> Ralith: I'm pretty new to this :)
[04:28:13] <bjz> Ralith: if you have any suggestions for implementations I could look at, that might be useful
[04:28:34] <bjz> Ralith: I'm interested in using it for scripting/data exchange
[04:28:39] <bjz> dbaupp: hoya
[04:28:47] <bjz> dbaupp: I broked deriving
[04:29:59] <Ralith> bjz: at a glance, add Cons(Value, Value) and Nil Values and remove Expr entirely
[04:30:15] <bjz> Ralith: really? neat
[04:30:36] <Ralith> also a Symbol Value I suppose
[04:30:43] <bjz> Ralith: Atom?
[04:30:57] <Ralith> an atom is not a symbol
[04:31:08] <bjz> Ralith: Is Atom like a literal?
[04:31:19] <aatch> an atom is a value that evaluates to itself
[04:31:35] <aatch> I think
[04:31:36] <bjz> Ahh
[04:31:39] <Ralith> an atom is anything that is not a cons
[04:31:44] <bjz> http://www.gnu.org/software/emacs/emacs-lisp-intro/html_node/Lisp-Atoms.html
[04:31:55] <Ralith> please don't use elisp as a reference for anything ever
[04:32:01] <bjz> hehe :D
[04:32:20] <bjz> Ralith: thanks so much for your help
[04:32:40] <bjz> Ralith: yeah I was concerned about having both Expr and Val
[04:33:16] <Ralith> eval should be (Env, Value) -> Value
[04:33:23] <bjz> AHHH
[04:33:26] <bjz> nice!
[04:33:30] <bjz> that's it!
[04:33:33] <bjz> :D
[04:33:39] <bjz> thankyou thankyou
[04:33:59] <bjz> I knew I had something around the wrond way :D
[04:34:01] <Ralith> or, better still, a sum type of Value and an error type
[04:34:08] <bjz> Yeah
[04:34:14] *** Quits: fread2282 (Mibbit@moz-CB181B42.dia.static.qwest.net) (Quit: http://www.mibbit.com ajax IRC Client)
[04:34:14] <bjz> I already return an error
[04:34:37] <Ralith> yes, that looks like the right idea
[04:35:06] <bjz> I'm certainly on the right track I think, just needs lots of rejigerring
[04:35:16] <dbaupp> bjz: hi! what are you doing to deriving?
[04:35:30] <Ralith> I'd also recommend bouncing everything, including primitives, through environment lookup
[04:35:32] <dbaupp> bjz: (I saw you did s/@/~/ :D )
[04:35:41] <Ralith> this will make fexprs or macros easier to implement later
[04:35:43] <bjz> dbaupp: Rust(~fn(params: ~[Ident], env: &Env) -> Value)
[04:35:50] <bjz> Ralith: oh yeah?
[04:36:08] *** Quits: lmandel (lmandel@FE1F74.86ED00A7.971E19F6.IP) (Quit: lmandel)
[04:36:11] <Ralith> and generally simplify adding, removing, and modifying primitives
[04:36:28] *** Joins: pyrac (pyrac@moz-D851FA22.w92-149.abo.wanadoo.fr)
[04:36:47] <Ralith> e.g. implement 'if' as a regular lexical binding to some possibly-special Value
[04:38:00] *** Joins: hjr3 (hradtke@moz-E87BDF1F.socal.res.rr.com)
[04:38:22] <Ralith> then finally implement '(define name value)' as another primitive which will side-effect the current lexical environment
[04:39:35] <dbaupp> Ralith: isn't that the (let name value) that currently exists?
[04:39:56] <Ralith> didn't see that
[04:40:06] <Ralith> looks that way
[04:40:10] <bjz> yeah
[04:40:17] <bjz> I don't like 'Let'
[04:40:19] <Ralith> it should be renamed; in lisp, 'let' conventionally introduces a new lexical environment
[04:40:27] <bjz> yeah
[04:40:29] <bjz> I agree
[04:40:36] <bjz> Def would be better
[04:40:41] <dbaupp> bjz: I see... it's probably not too bad? (I guess there is some argument for implementing Eq for ~/@/&fn just as pointer equality)
[04:41:34] *** Joins: vcl_ (chatzilla@741D4FEA.76F9E272.DA40C4B3.IP)
[04:41:52] *** Quits: vcl (chatzilla@741D4FEA.76F9E272.DA40C4B3.IP) (Ping timeout)
[04:42:00] *** vcl_ is now known as vcl
[04:43:06] <Ralith> bjz: I'd recommend just having a Primitive Value constructor which contains a rust function which implements arbitrary eval behavior
[04:43:33] <bjz> Ralith: I've seen people with an Env primitive
[04:43:39] *** Quits: slimer (Mibbit@moz-E308C5A2.hsd1.wa.comcast.net) (Quit: http://www.mibbit.com ajax IRC Client)
[04:43:48] <Ralith> ?
[04:44:18] <bjz> dw
[04:46:49] *** Joins: vcl_ (chatzilla@741D4FEA.76F9E272.DA40C4B3.IP)
[04:47:41] *** Quits: wuwei`lab (wuwei@1A513F49.818D7924.FAA9ED67.IP) (Ping timeout)
[04:47:47] *** Quits: vcl (chatzilla@741D4FEA.76F9E272.DA40C4B3.IP) (Ping timeout)
[04:48:00] *** vcl_ is now known as vcl
[04:48:03] <aatch> Is anybody else getting a compiler error building the latest incoming?
[04:48:09] <aatch> internal compiler error: unexpected sort of item in get_item_ty(): None
[04:51:00] <Ralith> bjz: ...?
[04:51:32] *** Joins: Cromulent (Cromulent@moz-983B638D.cable.virginmedia.com)
[04:53:34] *** Quits: eatkinson_ (eatkinson@moz-5CF47426.dia.static.qwest.net) (Quit: eatkinson_)
[04:57:00] <bjz> Ralith: ok, well eval is now a method on Env
[04:57:32] <bjz> now to get rid of Expr
[04:57:40] *** Quits: strcat (strcat@moz-54F7FD49.cpe.net.cable.rogers.com) (Quit: WeeChat 0.4.1)
[04:57:45] <bjz> somehow :)
[04:58:06] <Ralith> do you need help doing that?
[04:58:15] *** Joins: vcl_ (chatzilla@741D4FEA.76F9E272.DA40C4B3.IP)
[04:58:32] <bjz> Yeah, might do
[04:58:40] <bjz> just a sec, I'll rename Def
[04:58:50] <bjz> I mean, Let->Def
[04:58:53] *** Quits: vcl (chatzilla@741D4FEA.76F9E272.DA40C4B3.IP) (Ping timeout)
[04:58:56] *** vcl_ is now known as vcl
[04:58:57] *** Quits: hjr3 (hradtke@moz-E87BDF1F.socal.res.rr.com) (Quit: Textual IRC Client: www.textualapp.com)
[04:59:17] *** Quits: nielsle (nielsle@moz-5CE8ECCD.boa.fiberby.dk) (Ping timeout)
[05:00:26] *** Joins: nielsle (nielsle@moz-5CE8ECCD.boa.fiberby.dk)
[05:02:16] <bjz> Ralith: done
[05:03:17] * bjz realised he accidentally pushed some commented out code blocks, heh
[05:03:31] *** Joins: hjr3 (hradtke@moz-E87BDF1F.socal.res.rr.com)
[05:04:30] <bjz> Ralith: bear in mind the tests don't compile :(
[05:05:04] <bjz> might just have to use assert! for now
[05:05:16] <bjz> seeing as assert_eq! doesn't work
[05:06:32] <Ralith> bjz: so, eval is (Env, Value) -> Value
[05:06:38] <Ralith> it matches on its second argument
[05:06:50] <bjz> EvalResult?
[05:06:53] <bjz> yep
[05:06:59] <Ralith> if it is a symbol: look up the symbol in the Env, return the value
[05:08:04] <Ralith> if it is a cons cell: eval the car, ensure that the resulting value is a function, then apply that function to every value in the cdr
[05:09:04] <Ralith> (you should write apply : (Value, Value) -> Value which takes a function and a cons list, and calls the function as above, then just call it from eval)
[05:09:22] <bjz> ah nice
[05:09:25] <Ralith> if it is anything else: return it unmodified
[05:10:10] <Ralith> you'll need to extend the cons case to handle when the car returns a primitive or a macro instead of a function, also
[05:11:39] <bjz> mm
[05:11:48] <bjz> was wondering about macros
[05:12:45] <Ralith> I'd also consider implementing shutt fexprs instead of macros, but get primitives working first
[05:22:09] *** Quits: brson (brson@E02A6CDD.75598729.B6A3AE99.IP) (Quit: leaving)
[05:22:26] *** Joins: fdr (user@B280A391.27376607.189F3E15.IP)
[05:22:58] *** Joins: aruniiird (arun@92D70115.B332A52C.E3D0A897.IP)
[05:23:38] <fdr> hello everyone.  I have been messing around with rust just a tiny bit and want to ask how I can distribute a rust program that links libstd and librustrt
[05:24:21] <fdr> the easy answer is to play games with the linker and package them along, but that kind of sucks, so I was wondering if there was something better.
[05:25:26] *** Joins: doomlord_ (walter@moz-A9E19E41.range86-140.btcentralplus.com)
[05:25:35] *** Joins: doomlord (doomlod@moz-A9E19E41.range86-140.btcentralplus.com)
[05:26:51] <bjz> Ralith: http://en.wikipedia.org/wiki/Cons#Not_technically_fundamental
[05:27:19] <bjz> Ralith: thought that was interesting
[05:28:06] *** Joins: ghrust (ghrust@moz-4EF5B6E5.rs.github.com)
[05:28:06] <ghrust> 01[13rust01] 15bors merged 06auto into 06incoming: 02http://git.io/ruIRew
[05:28:06] *** Parts: ghrust (ghrust@moz-4EF5B6E5.rs.github.com) ()
[05:29:36] <Ralith> bjz: yes, the lambda calculus is full of clever encodings like that
[05:30:37] <bjz> So confusing, because everything is a transformation of something else. And of course it wraps around in a loop (I think)
[05:31:02] *** Joins: ghrust (ghrust@moz-4EF5B6E5.rs.github.com)
[05:31:02] <ghrust> 01[13rust01] 15bors pushed 0 new commits to 06auto: 02http://git.io/bOuUWQ
[05:31:02] *** Parts: ghrust (ghrust@moz-4EF5B6E5.rs.github.com) ()
[05:31:03] *** Joins: ghrust (ghrust@moz-4EF5B6E5.rs.github.com)
[05:31:03] <ghrust> 01[13rust01] 15bors pushed 2 new commits to 06auto: 02http://git.io/TCxT6g
[05:31:03] <ghrust> 13rust/06auto 14ae7df57 15Alex Crichton: Prevent refcount cycles during linting...
[05:31:03] <ghrust> 13rust/06auto 146264df5 15bors: auto merge of #6777 : alexcrichton/rust/less-memory, r=graydon...
[05:31:03] *** Parts: ghrust (ghrust@moz-4EF5B6E5.rs.github.com) ()
[05:31:11] *** Quits: siavashserver (siavash@B86D67DD.AC532F77.82A25C10.IP) (Quit: Konversation terminated!)
[05:32:05] *** Joins: eatkinson_ (eatkinson@moz-5CF47426.dia.static.qwest.net)
[05:32:12] *** Joins: wuwei`lab (wuwei@1A513F49.818D7924.FAA9ED67.IP)
[05:34:28] *** Joins: philix (philix@moz-8FDC6117.user.veloxzone.com.br)
[05:35:20] *** Quits: Axord (xord@moz-C3CCF156.lsanca.dsl-w.verizon.net) (Quit: I'm sure it's perfectly safe)
[05:35:45] *** Joins: jack (jack@2557E599.66715431.D25A875A.IP)
[05:36:59] *** Joins: haard (fredrik@18E6EC45.6A26450D.BE04C429.IP)
[05:37:26] *** zz_kimundi is now known as kimundi
[05:41:45] *** Quits: eatkinson_ (eatkinson@moz-5CF47426.dia.static.qwest.net) (Quit: eatkinson_)
[05:47:20] *** Quits: pyrac (pyrac@moz-D851FA22.w92-149.abo.wanadoo.fr) (Ping timeout)
[05:47:42] *** Joins: pyrac (pyrac@moz-285C535.w92-156.abo.wanadoo.fr)
[05:51:41] *** Quits: Cromulent (Cromulent@moz-983B638D.cable.virginmedia.com) (Ping timeout)
[05:58:33] *** Joins: Cromulent (Cromulent@moz-983B638D.cable.virginmedia.com)
[06:00:28] *** Joins: eatkinson_ (eatkinson@moz-5CF47426.dia.static.qwest.net)
[06:06:03] *** Quits: pyrac (pyrac@moz-285C535.w92-156.abo.wanadoo.fr) (Quit: pyrac)
[06:08:16] *** Quits: Cromulent (Cromulent@moz-983B638D.cable.virginmedia.com) (Quit: KVIrc 4.2.0 Equilibrium http://www.kvirc.net/)
[06:08:47] *** kimundi is now known as zz_kimundi
[06:09:05] *** zz_kimundi is now known as kimundi
[06:15:04] *** kimundi is now known as zz_kimundi
[06:15:13] *** zz_kimundi is now known as kimundi
[06:15:56] *** kimundi is now known as zz_kimundi
[06:19:19] <bjz> dbaupp: not sure how I can get deriving to work for Value :(
[06:19:34] *** Joins: berak (chatzilla@94AA4171.5F42470D.16E13E53.IP)
[06:19:36] *** Quits: katis (katis@40C8AF65.EFDC2270.EE6E63A5.IP) (Quit: WeeChat 0.3.7)
[06:19:42] *** Joins: donri (dag@moz-9BB61102.tbcn.telia.com)
[06:20:02] <bjz> dbaupp: check out ze crazy Eq/clone defs: https://github.com/bjz/rusp/blob/master/rusp.rs#L49
[06:20:06] *** Joins: katis (katis@40C8AF65.EFDC2270.EE6E63A5.IP)
[06:22:33] <dbaupp> bjz: you could break the actual value of the Rust variant into a separate type, implement Eq on that, and then deriving should work on Value
[06:22:56] <dbaupp> bjz: e.g. ... Rust(RustValue), ...; enum RustValue { RustFn(...) }
[06:23:54] *** Quits: katis (katis@40C8AF65.EFDC2270.EE6E63A5.IP) (Quit: WeeChat 0.3.7)
[06:30:01] *** Joins: katis (katis@40C8AF65.EFDC2270.EE6E63A5.IP)
[06:30:03] *** Joins: MrFahrenheit (RageOfThou@3FEF494C.29C984D5.783DEDCA.IP)
[06:37:46] *** Joins: vmx (vmx@moz-6A65996C.pools.arcor-ip.net)
[06:40:51] *** Joins: ghrust (ghrust@moz-4EF5B6E5.rs.github.com)
[06:40:52] <ghrust> 01[13rust01] 15bors merged 06auto into 06incoming: 02http://git.io/TCxT6g
[06:40:52] *** Parts: ghrust (ghrust@moz-4EF5B6E5.rs.github.com) ()
[06:40:57] *** Quits: MrFahrenheit (RageOfThou@3FEF494C.29C984D5.783DEDCA.IP) (Ping timeout)
[06:43:12] *** Joins: ghrust (ghrust@moz-4EF5B6E5.rs.github.com)
[06:43:12] <ghrust> 01[13rust01] 15bors pushed 0 new commits to 06auto: 02http://git.io/eFPqZQ
[06:43:12] *** Parts: ghrust (ghrust@moz-4EF5B6E5.rs.github.com) ()
[06:43:12] *** Joins: ghrust (ghrust@moz-4EF5B6E5.rs.github.com)
[06:43:12] <ghrust> 01[13rust01] 15bors pushed 3 new commits to 06auto: 02http://git.io/6Aekkg
[06:43:12] <ghrust> 13rust/06auto 143794605 15Daniel Farina: Use passing by-value in gmtime, mktime...
[06:43:12] <ghrust> 13rust/06auto 14c6f3577 15Daniel Farina: Increment copyright year of time.rs
[06:43:12] <ghrust> 13rust/06auto 14f7f36a8 15bors: auto merge of #6766 : fdr/rust/time-by-value, r=catamorphism...
[06:43:15] *** Parts: ghrust (ghrust@moz-4EF5B6E5.rs.github.com) ()
[06:48:54] *** Joins: pyrac (pyrac@9F71F32A.73C89388.AD05C589.IP)
[06:51:51] *** Joins: azita (Azita@moz-C1FB2A8.hsd1.ca.comcast.net)
[06:53:05] *** Quits: paulproteus (quassel@rose.makesad.us) (Ping timeout)
[06:53:18] *** Quits: jyasskin_w (jyasskin@DAF66858.C60FE7DC.4065847B.IP) (Ping timeout)
[06:53:18] *** Quits: blitter (blitter@moz-E761A52F.dyn.centurytel.net) (Ping timeout)
[06:53:25] *** Quits: madmoose (Hat@moz-E1973371.nerp.net) (Ping timeout)
[06:53:43] *** Joins: paulproteus (quassel@moz-E86A3B42.makesad.us)
[06:53:46] *** Joins: jyasskin_w (jyasskin@DAF66858.C60FE7DC.4065847B.IP)
[06:53:58] *** Joins: madmoose (Hat@moz-E1973371.nerp.net)
[06:54:21] *** Quits: azita (Azita@moz-C1FB2A8.hsd1.ca.comcast.net) (Quit: azita)
[06:54:44] *** Quits: dbaupp (Thunderbir@55A980D9.D5A1DCF.37681C44.IP) (Ping timeout)
[06:56:12] *** Joins: siavashserver (siavash@7CB05A38.7430D50B.82A25C10.IP)
[06:59:27] *** Quits: langhai (Mibbit@716C3E4.23F85D28.74F0EBEC.IP) (Quit: http://www.mibbit.com ajax IRC Client)
[07:03:12] *** Joins: novabyte (Instantbir@moz-43A3814E.mullvad.net)
[07:06:38] *** Quits: siavashserver (siavash@7CB05A38.7430D50B.82A25C10.IP) (Quit: Konversation terminated!)
[07:15:43] *** Quits: jack (jack@2557E599.66715431.D25A875A.IP) (Quit: Leaving.)
[07:16:58] *** Joins: jensnockert (jensnocker@moz-8BE55278.customer.t3.se)
[07:18:43] *** Quits: jensnockert (jensnocker@moz-8BE55278.customer.t3.se) (Ping timeout)
[07:23:19] *** Joins: victorporof (victorporo@DE2B5DEF.67CDC207.79933D60.IP)
[07:28:58] *** Quits: SiegeLord (sl@moz-CAF07B4C.hsd1.ma.comcast.net) (Quit: It's a joke. It's all a joke.)
[07:30:24] *** Joins: doener (bs@moz-AA189A5A.unitymedia.biz)
[07:36:00] *** Quits: devbug (quassel@moz-E1DE087C.bchsia.telus.net) (Connection reset by peer)
[07:37:41] *** Quits: Jeaye (Jeaye@moz-FD505E54.hsd1.ca.comcast.net) (Quit: Don't tell them I was here...)
[07:41:02] *** Quits: barosl (barosl@1E71221E.C81E10FB.7544CABF.IP) (Ping timeout)
[07:42:20] *** Joins: barosl (barosl@1E71221E.C81E10FB.7544CABF.IP)
[07:42:58] *** Joins: ghrust (ghrust@moz-4EF5B6E5.rs.github.com)
[07:42:59] <ghrust> 01[13rust01] 15bors merged 06auto into 06incoming: 02http://git.io/6Aekkg
[07:42:59] *** Parts: ghrust (ghrust@moz-4EF5B6E5.rs.github.com) ()
[07:45:57] *** Joins: ghrust (ghrust@moz-4EF5B6E5.rs.github.com)
[07:45:57] <ghrust> 01[13rust01] 15bors pushed 0 new commits to 06auto: 02http://git.io/O_ZaTw
[07:45:57] *** Parts: ghrust (ghrust@moz-4EF5B6E5.rs.github.com) ()
[07:45:59] *** Joins: ghrust (ghrust@moz-4EF5B6E5.rs.github.com)
[07:45:59] <ghrust> 01[13rust01] 15bors pushed 2 new commits to 06auto: 02http://git.io/Asdhmw
[07:45:59] <ghrust> 13rust/06auto 1477de84b 15Tim Chevalier: extra: Add reserve and reserve_at_least to extra::deque...
[07:45:59] <ghrust> 13rust/06auto 14fe7f528 15bors: auto merge of #6769 : catamorphism/rust/issue-4994, r=thestinger...
[07:45:59] *** Parts: ghrust (ghrust@moz-4EF5B6E5.rs.github.com) ()
[07:47:01] *** Quits: eatkinson_ (eatkinson@moz-5CF47426.dia.static.qwest.net) (Quit: eatkinson_)
[07:50:45] *** Joins: Blub\w (wry@moz-DF767356.wireless.dyn.drei.com)
[07:55:16] *** Joins: siavashserver (siavash@37E8F5D3.3A2812F8.82A25C10.IP)
[07:56:03] *** Joins: threecreepio (jdp@moz-F2D425CF.business.telia.com)
[07:58:54] *** Joins: thomaslee_ (thomaslee@moz-306D3DF4.hsd1.or.comcast.net)
[08:00:18] *** zz_kimundi is now known as kimundi
[08:06:08] *** Quits: martndemus (martndemus@moz-FAE8D24A.sshunet.nl) (Connection reset by peer)
[08:10:34] *** Joins: fabiand (fabiand@moz-357F09F3.adsl.alicedsl.de)
[08:12:48] *** Joins: tgt (tgt@moz-D59EE478.aztw.cable.virginmedia.com)
[08:15:25] *** Quits: KindOne (KindOne@moz-AAD7235.dynamic.ip.windstream.net) (Ping timeout)
[08:16:06] *** Joins: KindOne (KindOne@moz-AAD7235.dynamic.ip.windstream.net)
[08:17:38] *** Quits: jaen (jaen@moz-BEAD385F.play-internet.pl) (Ping timeout)
[08:18:28] *** Joins: dbaupp (Thunderbir@moz-C6B1454A.lns20.syd7.internode.on.net)
[08:19:59] <bjz> dbaupp: that works!
[08:20:10] <bjz> dbaupp: ze tests pass. muahaha
[08:21:05] *** Joins: jensnockert (jensnocker@moz-8BE55278.customer.t3.se)
[08:21:26] <bjz> rusti: #[deriving(Eq,Clone)] struct Fn(@fn()); ()
[08:21:27] -rusti- playpen: rmdir: Device or resource busy
[08:23:10] *** Quits: thomaslee_ (thomaslee@moz-306D3DF4.hsd1.or.comcast.net) (Ping timeout)
[08:23:35] *** Quits: thomaslee (thomaslee@moz-306D3DF4.hsd1.or.comcast.net) (Ping timeout)
[08:26:22] *** kimundi is now known as zz_kimundi
[08:27:02] *** zz_kimundi is now known as kimundi
[08:27:31] <bjz> rusti: #[deriving(Eq,Clone)] struct Fn(@fn()); ()
[08:27:32] -rusti- playpen: rmdir: Device or resource busy
[08:27:37] <bjz> :P
[08:29:30] *** Joins: snearch (snearch@moz-9D325B5D.pool.mediaways.net)
[08:30:02] *** Quits: hjr3 (hradtke@moz-E87BDF1F.socal.res.rr.com) (Quit: My MacBook has gone to sleep. ZZZzzz)
[08:31:22] *** Joins: CarpNet (ac@moz-FD24B77.sohonet.co.uk)
[08:33:07] *** Joins: thomaslee (thomaslee@moz-306D3DF4.hsd1.or.comcast.net)
[08:36:59] *** Joins: q66 (q66@6EE9DE40.46454B5D.33AABD5F.IP)
[08:38:43] *** Joins: thomaslee_ (thomaslee@moz-306D3DF4.hsd1.or.comcast.net)
[08:40:46] *** Quits: jensnockert (jensnocker@moz-8BE55278.customer.t3.se) (Input/output error)
[08:46:58] *** Quits: dbaupp (Thunderbir@moz-C6B1454A.lns20.syd7.internode.on.net) (Quit: dbaupp)
[08:47:23] *** Joins: lucian (lucian@6B2B4644.4304AE1E.CE5E78F6.IP)
[08:47:47] *** Joins: dbaupp (Thunderbir@moz-C6B1454A.lns20.syd7.internode.on.net)
[08:48:03] <dbaupp> bjz: :D
[08:48:36] *** Quits: snadon (chatzilla@moz-3BC727E8.mc.videotron.ca) (Ping timeout)
[08:48:57] *** Joins: ghrust (ghrust@moz-4EF5B6E5.rs.github.com)
[08:48:57] <ghrust> 01[13rust01] 15bors merged 06auto into 06incoming: 02http://git.io/Asdhmw
[08:48:57] *** Parts: ghrust (ghrust@moz-4EF5B6E5.rs.github.com) ()
[08:51:28] <bjz> rusti: #[deriving(Eq,Clone)] struct Fn(@fn()); ()
[08:51:29] -rusti- playpen: rmdir: Device or resource busy
[08:51:59] *** Joins: ghrust (ghrust@moz-4EF5B6E5.rs.github.com)
[08:51:59] <ghrust> 01[13rust01] 15bors pushed 0 new commits to 06auto: 02http://git.io/MU0p7A
[08:51:59] *** Parts: ghrust (ghrust@moz-4EF5B6E5.rs.github.com) ()
[08:52:00] *** Joins: ghrust (ghrust@moz-4EF5B6E5.rs.github.com)
[08:52:00] <ghrust> 01[13rust01] 15bors pushed 2 new commits to 06auto: 02http://git.io/An6Sbw
[08:52:00] <ghrust> 13rust/06auto 14c9c4d92 15Lindsey Kuper: Add xfail'd test for #6762.
[08:52:00] <ghrust> 13rust/06auto 147ee329e 15bors: auto merge of #6770 : lkuper/rust/6762, r=catamorphism
[08:52:00] *** Parts: ghrust (ghrust@moz-4EF5B6E5.rs.github.com) ()
[08:52:13] <bjz> dbaupp: so yeah got rid of Expr
[08:52:29] *** Joins: jensnockert (jensnocker@moz-8BE55278.customer.t3.se)
[08:53:29] <dbaupp> bjz: Oh, wow, it's all just Value
[08:53:42] <bjz> Aye
[08:53:53] <bjz> source == data
[08:53:58] <bjz> the beauty of lisp
[08:54:05] <siavashserver> This is blasphemy.
[08:54:23] <bjz> dbaupp: but it could be much nicer
[08:54:31] <bjz> dbaupp: and more elegant
[08:54:52] <bjz> dbaupp: as we were talking about before
[08:54:55] <dbaupp> bjz: yeah, merging do, if, def, quote and apply?
[08:55:08] <bjz> dbaupp: indeed
[08:55:31] <bjz> dbaupp: but then, I don't know if that's what we want
[08:56:02] <bjz> dbaupp: because we also have to think about the fact you want it performant
[08:56:10] <dbaupp> bjz: yeah
[08:56:53] <fdr> anyone have any thoughts about iterating on rustc/libcore/libstd?
[08:57:06] <fdr> I'm trying to bisect a regression and it's mind-blowingly slow to do builds
[08:57:08] <dbaupp> bjz: I'd imagine that enum Something { If, Def, Do, Quote, Symbol(~Value) } might work?
[08:57:27] <dbaupp> fdr: how many cores do you have?
[08:57:50] <dbaupp> because you could clone the repo several times and build in each of them
[08:57:51] <fdr> 8, which is 2x4. I use make -sj8 or something.
[08:58:09] <dbaupp> (the actual rust part of the build is single threaded unfortunately)
[08:58:19] <fdr> Yeah, I'm noticing this.
[08:58:26] <dbaupp> also, you can build just the stage 1 compiler, if the regression shows up there
[08:58:35] <dbaupp> `make rustc-stage1`
[08:58:44] <fdr> neat, that may help a lot
[08:58:49] <bjz> dbaupp: an Atom variant might be good for the Numbers and String type
[08:59:03] <fdr> so, uh, would parallel build be a non-insane contribution for whatever is being done to build the compiler?
[08:59:17] <dbaupp> fdr: that would be an amazing contribution
[08:59:40] <fdr> but clearly not very easy, or it might be done.  Any known objections or gnashing of teeth on why it hasn't been completed?
[08:59:57] <dbaupp> unfortunately rustc depends on syntax which depends on extra which depends on std
[09:00:06] <dbaupp> so there's not much parallelism possible there
[09:00:22] <bjz> dbaupp: I don't know why they need set!: http://norvig.com/lispy.html
[09:00:34] <dbaupp> fdr: the biggest gains are probably making rustc itself do work in parallel
[09:00:37] <bjz> dbaupp: it seems to be a Scheme primitive
[09:00:47] <dbaupp> bjz: dunno
[09:01:00] <dbaupp> bjz: Scheme isn't one of the lisps I've used
[09:01:09] *** Quits: haard (fredrik@18E6EC45.6A26450D.BE04C429.IP) (Ping timeout)
[09:01:32] <bjz> dbaupp: oh I don
[09:01:33] <fdr> dbaupp: I agree making the compiler parallel is probably best, because the old fashioned fork-per-file does add some pretty hefty overhead if one wants to compile quite quickly.
[09:01:43] <bjz> 't think set! is used a heap
[09:02:19] <bjz> dbaupp: it's probably used for implementing higher-level things though
[09:02:41] <dbaupp> fdr: yeah... the best way is possibly making the AST sendable, so that it can work that uses that can distributed across multiple threads easily
[09:03:07] <dbaupp> fdr: (that is, convert all the @ to ~)
[09:03:33] <dbaupp> bjz: isn't it just mutating the variable?
[09:03:33] <fdr> I remember seeing a bug while fishing around looking for easy ones that said this would be time consuming but may also make the compiler faster (for unrelated reasons) as a microoptimization.
[09:03:45] *** Quits: wilkie (wilkie@moz-57D49853.pitbpa.fios.verizon.net) (Ping timeout)
[09:04:03] <fdr> actually, I ran into this trying to build zero.rs.  I wanted to have a go at embedding rust in PostgreSQL.
[09:04:43] <fdr> zero.rs slightly modified => palloc (postgres allocator)/ereport (exception handling)/etc may give a pretty nice interface
[09:04:45] <bjz> fdr: nice!
[09:05:11] <fdr> well, it'll be nice if I get around to it. 
[09:05:20] <fdr> but maybe just a bit at a time...
[09:05:39] <fdr> I also would like to run some rust in production, but am having trouble getting past the problem of distributing the binaries
[09:05:44] <bjz> fdr: oh well, that's how you do it
[09:06:03] <bjz> fdr: I wanted to make a lisp in rust for game stuff
[09:06:14] <dbaupp> fdr: I'm not sure "rust" and "in production" go together yet ;P
[09:06:36] <kaeso> is there a yaml parser/generator for rust?
[09:06:39] <bjz> fdr: heh, it might be a little early for that
[09:06:52] <fdr> dbaupp: meh.
[09:06:55] <dbaupp> kaeso: probably not, JSON is as good as you get
[09:07:08] <fdr> whatever I write will be small enough to re-write in emergency.
[09:07:29] <dbaupp> fdr: heh :)
[09:07:31] <bjz> kaeso: S-expressions!
[09:07:38] <bjz> kaeso: :D
[09:07:38] <fdr> I'm mostly curious if I can get a small memory footprint out of rust, which is killing me just a bit in golang
[09:07:53] *** Quits: doomlord_ (walter@moz-A9E19E41.range86-140.btcentralplus.com) (Ping timeout)
[09:07:53] *** Quits: doomlord (doomlod@moz-A9E19E41.range86-140.btcentralplus.com) (Ping timeout)
[09:08:40] <kaeso> dbaupp, bjz: thanks anyway
[09:08:47] <bjz> :P
[09:09:01] <bjz> you'll probably have to write your own, unfortunately
[09:09:09] <bjz> or make bindings
[09:09:19] <bjz> but writing your own is more fun :D
[09:12:57] *** Joins: EXetoC (ex@moz-C741B177.customer.t3.se)
[09:13:55] *** Joins: Earnestly (earnest@6A917A59.5E1FD793.39C00A7A.IP)
[09:14:34] <dbaupp> fdr: what do you mean? Do Go programs use a lot of memory?
[09:15:45] <kaeso> bjz: I'll push another item into my infinite todo list :)
[09:16:11] <fdr> dbaupp: they tend to use a lot of virtual memory, and it's hard to get below the 5MB barrier, say.
[09:16:35] <fdr> the GC is minimally tunable, so it won't necessarily collect until there's some kind of pressure
[09:17:13] <fdr> I'd like to write a class of program that is even smaller than that.
[09:17:14] <bjz> fdr: kick it a few times?
[09:17:20] <bjz> fdr: "GO!"
[09:17:37] <fdr> well, I ended up suiciding the process repeatedly to free the VMA.
[09:17:44] <fdr> that is a kludge that basically works
[09:19:02] <fdr> Go representations are compact enough, though.  Also the build/test cycle is quite speedy...although by contrast even user-mode linux compiles in about a minute and postgres in 45 seconds.
[09:20:36] <fdr> is there a xcscope.el-like thing for Rust?
[09:20:51] <nmatsakis> bjz: looks like I will have to get my windows machine up-and-running after all.
[09:21:04] <nmatsakis> fdr: there is ctags support
[09:21:59] <fdr> nmatsakis: I'll look into that, thanks
[09:22:58] <bjz> nmatsakis: :(
[09:23:10] <dbaupp> bjz: I have a repl! :D
[09:23:20] <nmatsakis> bjz: I can do that today, I think. I was just hoping to avoid it :)
[09:23:33] <bjz> dbaupp: for? :o
[09:23:39] <dbaupp> bjz: rusp!
[09:23:51] <bjz> !!!!
[09:23:54] <bjz> woooow
[09:24:15] <bjz> nmatsakis: no where near done: https://github.com/bjz/rusp
[09:24:27] <bjz> :)
[09:25:46] <bjz> nmatsakis: I'm finding other distractions, hehe
[09:26:27] <bjz> dbaupp: it might be a good idea to have some examples of serialisation
[09:26:59] <nmatsakis> bjz: neat.
[09:28:39] <bjz> dbaupp: tbh, I've never actually done serialisation in my life before, but I know it's something I'll need
[09:28:46] <dbaupp> serialisation?
[09:29:38] *** Quits: siavashserver (siavash@37E8F5D3.3A2812F8.82A25C10.IP) (Quit: Konversation terminated!)
[09:29:48] <bjz> dbaupp: I think that's the right term
[09:30:01] <bjz> dbaupp: like storing data from your program
[09:30:20] <bjz> dbaupp: so that you can load it up at a later date
[09:30:22] <dbaupp> bjz: oh, right, serialising a rusp program itself?
[09:30:28] <dbaupp> (and it's environment)
[09:30:42] <bjz> no, as in, using it as a data format
[09:30:55] <dbaupp> Oh, I see
[09:31:00] <bjz> say if I had a config file
[09:31:12] <bjz> or maybe a high scores list
[09:31:42] <bjz> you'd save a .rsp of the data
[09:32:19] <dbaupp> ah, I see. that's neat!
[09:32:24] <bjz> I'll have to see how they do it with the JSON thing
[09:32:38] <dbaupp> yeah, there's a huge number of methods to implement
[09:32:44] <bjz> maybe we could have a serialise trait or something
[09:32:53] <dbaupp> but once you do it, then it "just works"
[09:32:56] <dbaupp> bjz: there is one :)
[09:33:07] <dbaupp> (except with a z... :'( )
[09:33:29] <dbaupp> bjz: anyway, I've got to go, bbl
[09:33:35] <bjz> bye!
[09:33:43] <bjz> ecited for the repl!
[09:33:46] <bjz> *excited
[09:33:47] <bjz> :D
[09:36:24] <bjz> dbaupp: #[deriving(rusp::Serialize)]
[09:36:25] <bjz> :P
[09:41:45] *** Quits: berak (chatzilla@94AA4171.5F42470D.16E13E53.IP) (Quit: .. too much fighting on the dancefloor ..)
[09:44:01] <bjz> oh wait
[09:44:14] <bjz> extra::serialize is pretty generic
[09:44:16] <bjz> nice
[09:48:43] *** Joins: pnkfelix (pnkfelix@moz-801E009D.vlan502.asr1.cdg2.gblx.net)
[09:54:04] *** Quits: jensnockert (jensnocker@moz-8BE55278.customer.t3.se) (Input/output error)
[09:57:59] *** Joins: ghrust (ghrust@moz-4EF5B6E5.rs.github.com)
[09:57:59] <ghrust> 01[13rust01] 15bors merged 06auto into 06incoming: 02http://git.io/An6Sbw
[09:57:59] *** Parts: ghrust (ghrust@moz-4EF5B6E5.rs.github.com) ()
[10:00:56] *** Joins: ghrust (ghrust@moz-4EF5B6E5.rs.github.com)
[10:00:57] <ghrust> 01[13rust01] 15bors pushed 0 new commits to 06auto: 02http://git.io/03YvqQ
[10:00:57] *** Parts: ghrust (ghrust@moz-4EF5B6E5.rs.github.com) ()
[10:00:57] *** Joins: ghrust (ghrust@moz-4EF5B6E5.rs.github.com)
[10:00:57] <ghrust> 01[13rust01] 15bors pushed 2 new commits to 06auto: 02http://git.io/rBOv-w
[10:00:57] <ghrust> 13rust/06auto 14c302010 15Daniel Micay: mark unique pointer parameters as noalias...
[10:00:57] <ghrust> 13rust/06auto 14b738b57 15bors: auto merge of #6754 : thestinger/rust/noalias, r=nikomatsakis...
[10:00:57] *** Parts: ghrust (ghrust@moz-4EF5B6E5.rs.github.com) ()
[10:12:39] *** Quits: busylizzy (lisa@85228838.12D0DC84.211374C4.IP) (Ping timeout)
[10:13:30] *** Joins: busylizzy (lisa@85228838.12D0DC84.211374C4.IP)
[10:25:43] *** Joins: pnkfelix|rcirc (pnkfelix@moz-801E009D.vlan502.asr1.cdg2.gblx.net)
[10:28:11] *** Quits: rusti (rusti@moz-54F7FD49.cpe.net.cable.rogers.com) (Ping timeout)
[10:28:12] <dbaupp> bjz: I'm back! Should I just push the repl to your repo, or go via a PR?
[10:28:24] <bjz> maybe via a PR
[10:28:30] *** Joins: rusti (rusti@moz-54F7FD49.cpe.net.cable.rogers.com)
[10:28:46] <bjz> dunno if I should be doing that too :)
[10:28:56] <bjz> it's always good to have documentation
[10:29:09] <bjz> and to get reviewed
[10:29:18] <dbaupp> can you submit a PR to yourself?
[10:29:44] <bjz> no idea
[10:29:48] <bjz> probably not :P
[10:29:59] <bjz> oh wait
[10:30:18] <bjz> I have a little PR button
[10:31:31] <bjz> but then I'd have to make a new repo
[10:31:43] <dbaupp> bjz: https://github.com/bjz/rusp/pull/2 r?
[10:31:54] <dbaupp> heh, we need a rusp-bors
[10:32:10] <bjz> hehe
[10:32:20] <bjz> yaya
[10:32:23] <bjz> it's tiny
[10:32:26] <bjz> I likey
[10:32:38] *** Joins: doomlord_ (walter@moz-A9E19E41.range86-140.btcentralplus.com)
[10:33:03] *** Joins: doomlord (doomlod@moz-A9E19E41.range86-140.btcentralplus.com)
[10:34:02] <cmr> bjz: you can make PRs between branches of one repo
[10:34:38] <dbaupp> bjz: (just added another commit, in case you missed it)
[10:34:46] <bjz> got it
[10:34:54] <bjz> any way we can fix: rusp::parse::parse
[10:34:56] <bjz> :P
[10:35:14] <dbaupp> I guess a top level 'parse' in rusp.rs would be reasonable
[10:35:20] <dbaupp> I'll move it?
[10:35:28] <bjz> good idea
[10:35:48] <bjz> I'm also thinking that it would be good to call Env->Rusp
[10:37:56] <dbaupp> That's reasonable, should I move it?
[10:38:05] <bjz> yep
[10:38:28] <bjz> also Rusp::empty() -> new()
[10:38:53] <bjz> because that's what the user will... err... use
[10:39:39] *** Joins: maxli (maxli@C03F2759.C70D537E.2FA4EA88.IP)
[10:40:05] *** Quits: doomlord (doomlod@moz-A9E19E41.range86-140.btcentralplus.com) (Ping timeout)
[10:40:24] <bjz> http://clojure.org/data_structures
[10:40:26] *** Quits: doomlord_ (walter@moz-A9E19E41.range86-140.btcentralplus.com) (Ping timeout)
[10:40:33] <bjz> interesting
[10:41:36] *** Joins: synapsos (Mibbit@640C6C8D.C434660A.DAB1EB3B.IP)
[10:41:44] <dbaupp> It'd be amazing if it supported literals like {} and []
[10:41:57] <dbaupp> and also "native" rust data structures
[10:42:02] <bjz> aye
[10:42:12] <bjz> that's what I'm thinking
[10:42:51] <bjz> I'm worried that what we have is a little inefficient (but being wary of premature optimisation ofc)
[10:43:02] <cmr> then that guy asking how to script rust would have something to use :)
[10:43:24] <bjz> like, in terms of serialisation, you'd need some way of producing records
[10:43:31] <bjz> and lists
[10:43:40] <bjz> cmr: :)
[10:44:42] *** Quits: busylizzy (lisa@85228838.12D0DC84.211374C4.IP) (Ping timeout)
[10:47:27] *** Quits: maxli (maxli@C03F2759.C70D537E.2FA4EA88.IP) (Quit: Leaving.)
[10:47:58] <bjz> (def points (hash-map ("harry" 6) ("alice" 2) ("bob" 5)))
[10:48:32] <dbaupp> bjz: pushed
[10:49:43] <dbaupp> bjz: it's cool because it works already
[10:50:00] <dbaupp> > (def a true)
[10:50:00] <dbaupp> AST: ~Def(~"a", ~Bool(true))
[10:50:00] <dbaupp> Ok(Unit)
[10:50:00] <dbaupp> > (def b (quote (1 2 3)))
[10:50:00] <dbaupp> AST: ~Def(~"b", ~Quote(~Apply(~Int(1), ~[~Int(2), ~Int(3)])))
[10:50:00] <dbaupp> Ok(Unit)
[10:50:06] <dbaupp> > (if a b 1)
[10:50:06] <dbaupp> AST: ~If(~Symbol(~"a"), ~Symbol(~"b"), ~Int(1))
[10:50:06] <dbaupp> Ok(Apply(~Int(1), ~[~Int(2), ~Int(3)]))
[10:50:19] <dbaupp> (excuse the smap :P )
[10:50:24] <dbaupp> *spam
[10:50:26] <cmr> I don't think that first one is correct?
[10:50:50] <dbaupp> cmr: in what sense?
[10:50:53] *** Joins: sk (sk@EA324BFE.54A580E3.78DD174B.IP)
[10:51:20] <bjz> dbaupp: nice!
[10:51:50] <EXetoC> ribbit ribbit
[10:51:55] <cmr> Shouln't quote (1, 2, 3) be a lisy, not an apply?
[10:52:01] <cmr> *list
[10:52:52] <cmr> minus commas 
[10:52:54] <cmr> ;p
[10:53:32] <dbaupp> cmr: well, it is (slightly) different:
[10:53:38] <dbaupp> > (def b (1 2 3))
[10:53:38] <dbaupp> AST: ~Def(~"b", ~Apply(~Int(1), ~[~Int(2), ~Int(3)]))
[10:53:38] <dbaupp> rust: task failed at 'Not yet implemented', rusp.rs:157
[10:54:14] <dbaupp> i.e. the quoting actually does stuff
[10:54:52] *** Joins: siavashserver (siavash@7727B288.90416268.82A25C10.IP)
[10:55:19] <cmr> when you go throug and eval that is 1 actually going to be looked up and called? excuse the ignorance, i only have scant familiarity with lisp
[10:55:19] <dbaupp> bjz: it would be nice for Apply and Unit to merge though, maybe? just List(~[~Value]), and have runtime-y checks, since they have to exist anyway
[10:55:37] <dbaupp> cmr: which one? the quoted or unquoted?
[10:55:56] <cmr> dbaupp: unquoted
[10:55:56] <bjz> dbaupp: I already have List done
[10:56:05] <bjz> dbaupp: Rusp Repl
[10:56:05] <bjz> > (def x "3")
[10:56:05] <bjz> AST: ~Def(~"x", ~Symbol(~"\"3\""))
[10:56:05] <bjz> Err(~"The value of `\"3\"` was not defined in this environment")
[10:56:18] <dbaupp> bjz: heh
[10:56:20] <bjz> :P
[10:56:29] <dbaupp> strings aren't parsed at all
[10:56:35] <bjz> ahhh
[10:56:36] <bjz> ok
[10:57:08] *** Parts: siavashserver (siavash@7727B288.90416268.82A25C10.IP) (Konversation terminated!)
[10:57:11] *** Joins: MaikKlein (maik@moz-F9DF85DA.dip0.t-ipconnect.de)
[10:57:18] <dbaupp> bjz: > (quote ("a b"))
[10:57:19] <dbaupp> AST: ~Quote(~Apply(~Symbol(~"\"a"), ~[~Symbol(~"b\"")]))
[10:57:19] <bjz> Want me to push List?
[10:57:19] <dbaupp> Ok(Apply(~Symbol(~"\"a"), ~[~Symbol(~"b\"")]))
[10:57:27] <dbaupp> sure
[10:57:39] <dbaupp> I'll try something with strings
[10:57:45] <Ralith> bjz: it looks like you haven't killed Expr yet...
[10:57:55] <dbaupp> Ralith: it's all values
[10:58:07] <Ralith> Apply is not a sane value
[10:58:09] <Ralith> neither is Def
[10:58:09] <Ralith> etc
[10:58:11] <dbaupp> (i.e. there's a single data-type for expressions)
[10:58:16] <Earnestly> Are we witnessing greenspuns tenth rule in action?
[10:58:31] <dbaupp> Earnestly: if explicitly implementing a lisp counts, yes
[10:58:35] <Ralith> when I said 'kill expr' I did not mean 'put all of Expr into Value'; that entirely misses the point
[10:58:47] <dbaupp> Ralith: it's being worked on
[10:59:01] <Ralith> it's not clear to me that I was understood
[10:59:06] <dbaupp> Ralith: (and that's a step in the right direction)
[10:59:37] <dbaupp> Ralith: bjz has got a 'List' thing. Not sure how extensively he's using it yet though
[10:59:38] *** Joins: jaen (jaen@B361617C.6A94545C.43DC2829.IP)
[10:59:46] <Ralith> that also misses the point.
[10:59:56] <bjz> :)
[11:00:06] <dbaupp> Are cons cells explicitly necessary?
[11:00:13] <Ralith> if you're trying to implement a lisp, yeah
[11:00:56] *** Joins: ghrust (ghrust@moz-4EF5B6E5.rs.github.com)
[11:00:56] <ghrust> 01[13rust01] 15bors merged 06auto into 06incoming: 02http://git.io/rBOv-w
[11:00:56] *** Parts: ghrust (ghrust@moz-4EF5B6E5.rs.github.com) ()
[11:01:16] <dbaupp> could you explain why the underlying representation can't be a vector?
[11:02:18] <Ralith> the underlying representation can be carrier pigeons if you like, but for it to resemble what most people would recognize as a lisp, the interface should be cons cells
[11:02:39] <Ralith> and I would expect it to be easier to actually *use* cons cells than to fake them
[11:03:22] *** Joins: judder (maradukewa@385DDD8F.206937E4.78E362FE.IP)
[11:03:55] *** Joins: ghrust (ghrust@moz-4EF5B6E5.rs.github.com)
[11:03:55] <ghrust> 01[13rust01] 15bors pushed 0 new commits to 06auto: 02http://git.io/50qrNw
[11:03:55] *** Parts: ghrust (ghrust@moz-4EF5B6E5.rs.github.com) ()
[11:03:56] *** Joins: ghrust (ghrust@moz-4EF5B6E5.rs.github.com)
[11:03:56] <ghrust> 01[13rust01] 15bors pushed 2 new commits to 06auto: 02http://git.io/P71fiA
[11:03:56] <ghrust> 13rust/06auto 140d5fdce 15Daniel Micay: syntax highlight code examples in docstrings
[11:03:56] <ghrust> 13rust/06auto 1424784e8 15bors: auto merge of #6771 : thestinger/rust/highlight, r=luqmana...
[11:03:56] *** Parts: ghrust (ghrust@moz-4EF5B6E5.rs.github.com) ()
[11:05:49] *** Joins: jensnockert (jensnocker@55058FD.75EEE270.CA0B30E6.IP)
[11:06:47] *** Quits: novabyte (Instantbir@moz-43A3814E.mullvad.net) (Quit: bye bye)
[11:06:53] *** Quits: synapsos (Mibbit@640C6C8D.C434660A.DAB1EB3B.IP) (Quit: http://www.mibbit.com ajax IRC Client)
[11:07:46] *** Joins: novabyte (Instantbir@moz-3E0F9699.cable.virginmedia.com)
[11:08:32] *** Quits: MaikKlein (maik@moz-F9DF85DA.dip0.t-ipconnect.de) (Ping timeout)
[11:09:22] <bjz> Ralith: so I currently have a define method on the environment type. So we could remove Def from vals, and just introduce a function 'def' that uses that method?
[11:09:43] <bjz> ie. introduce it at start up
[11:10:19] <Ralith> it would need to be a special form, not a function
[11:10:28] <Ralith> functions evaluate all their arguments
[11:10:51] <Ralith> but that's the basic idea
[11:11:04] <Ralith> (on start up, or in an immutable global root environment)
[11:11:20] <bjz> so how do special forms come into play?
[11:11:32] *** Joins: busylizzy (lisa@85228838.12D0DC84.211374C4.IP)
[11:11:51] <Ralith> they work like functions, except they have arbitrary evaluation semantics
[11:12:24] <bjz> makes sense
[11:13:08] <Ralith> a simple way to handle them in an interpreter context is to just have a 'special form' value which in this case would contain a rust function which eval calls out to with the cdr of the calling form when it's applied
[11:13:53] <bjz> I already have a define method impled on the environment
[11:15:11] <bjz> I'm guessing we could use that?
[11:15:14] *** Quits: SimonSapin (simon@moz-99690620.hinet-ip.hinet.net) (Ping timeout)
[11:16:10] <Ralith> if you modify it to take a cons and return an EvalResult, sure
[11:16:35] *** Quits: jensnockert (jensnocker@55058FD.75EEE270.CA0B30E6.IP) (Ping timeout)
[11:16:49] *** Joins: jensnockert (jensnocker@55058FD.75EEE270.CA0B30E6.IP)
[11:16:50] <Ralith> but first you need conses
[11:17:31] <bjz> Ralith: what do you mean what you say, "take a cons"? (cons 1 (cons 2 (cons 3)))
[11:18:31] <Ralith> a list, I should say
[11:18:34] <Ralith> as in, a cons or a nil
[11:19:23] <Ralith> lisp lists are composed of a chain of conses terminated by a nil
[11:19:26] <bjz> So are you saying something like: enum Value { Cons(~Value) ... } ?
[11:19:32] <bjz> So are you saying something like: enum Value { Cons(~Value), Nil ... } ?
[11:19:50] <Ralith> a cons contains two values, but otherwise, yeah
[11:19:55] <Ralith> (the car and the cdr)
[11:20:05] <bjz> ah, haha
[11:20:11] <bjz> *facepalm*
[11:20:35] <Yurumechan> I have onlymy shallow reading
[11:20:39] <Yurumechan> oh
[11:20:39] <Yurumechan> ...
[11:20:46] <bjz> ?
[11:21:33] <Yurumechan> I only have shallow understanding of rusp code, but how do you represent '(p q) in terms of Value?
[11:22:18] <bjz> hah! I don't know if it's worthy of 'understanding' yet.
[11:22:22] <bjz> :)
[11:22:47] <Yurumechan> consider it to be a skimming :D
[11:24:28] <Yurumechan> so, I thought that it'd have a Value for the evaluated value and a Node for the yet-to-be-evaluated sexpr
[11:24:52] <Yurumechan> but I couldn't find the latter in rusp (yet)
[11:25:20] <Yurumechan> since Quote value contains just another Value
[11:25:35] <Yurumechan> is this a planned feature? :)
[11:25:56] <Ralith> '(p q) => (quote (p q)) => Cons(Symbol("quote"), Cons(Cons(Symbol("p"), Cons(Symbol("q"), Nil)), Nil))
[11:26:11] <Ralith> assuming I counted my parens right
[11:26:18] <Yurumechan> oh, does it have Cons?
[11:26:33] <bjz> Yurumechan: if you're confused, it's because: http://i.imgur.com/xVyoSl.jpg
[11:26:36] *** Quits: jensnockert (jensnocker@55058FD.75EEE270.CA0B30E6.IP) (Ping timeout)
[11:26:44] <Yurumechan> lol
[11:26:50] <bjz> Ralith: nice
[11:27:19] <Ralith> and you can implement quote as a special operator initially, and later as a macro
[11:27:22] <bjz> dbaupp: I think I'm understanding better
[11:27:55] * dbaupp reads
[11:28:33] <Yurumechan> yeah, my reading was not wrong, the current code does not have Node or cons cell yet
[11:28:50] <Ralith> what is Node?
[11:28:51] <bjz> Yurumechan: I'm implementing it right now :D
[11:28:54] <dbaupp> bjz: yes, I don't disagree with anything
[11:29:24] <Yurumechan> Ralith : "unevaluated sexpr"
[11:29:44] <Ralith> Yurumechan: we call that a value.
[11:29:54] <Yurumechan> huh
[11:30:03] <Yurumechan> what a revelation...
[11:30:56] <dbaupp> ffffffffuuuuuuu
[11:31:02] <bjz> dbaupp?
[11:31:06] <dbaupp> macros not expanding to multiple items is the worst
[11:31:12] <bjz> :(
[11:31:18] <bjz> it makes me sadface
[11:31:29] <dbaupp> it silently drops things and stuff doesn't make sense! :(
[11:31:32] <Yurumechan> Ralith: then, does it work by repeatedly evaluate redexes within a Value?
[11:31:42] <Yurumechan> or somehow else?
[11:31:44] <Ralith> Yurumechan: what's a redex?
[11:32:05] <dbaupp> rusti: let mut b = 0; macro_rules! a( () => { print("foo"); b += 1 }); a!()
[11:32:07] -rusti- more than 5 lines of output, pastebinned: http://sprunge.us/gPZe
[11:32:26] <dbaupp> rusti: let mut b = 0; macro_rules! a( () => {{ print("foo"); b += 1 }}); a!()
[11:32:26] -rusti- fooplaypen: rmdir: Device or resource busy
[11:32:39] <Yurumechan> ah sorry for PL jargon, it is a reducible expression
[11:32:45] <Yurumechan> maybe
[11:33:35] <dbaupp> bjz: wahoo, string tokenising works!
[11:33:38] <Ralith> I'm not sure what you mean to ask
[11:33:51] <Ralith> by definition, an interpreter repeatedly reduces reducible expressions.
[11:33:59] <Yurumechan> ...just figuring out how it internally work
[11:34:09] <Yurumechan> don't mind ;)
[11:34:29] <Yurumechan> better reading the code thoroughly when I go back home
[11:36:19] *** Joins: an0nymous (an0nymous@moz-A6B0CE4.tx.res.rr.com)
[11:40:14] *** Quits: thomaslee (thomaslee@moz-306D3DF4.hsd1.or.comcast.net) (Client exited)
[11:43:31] * Ralith sleeps
[11:44:47] <bjz> Ralith: night!
[11:44:48] <bjz> thanks!
[11:44:52] <Ralith> good luck
[11:44:57] <bjz> :)
[11:54:13] *** Joins: berak (chatzilla@B8C4FD6F.5F42470D.16E13E53.IP)
[11:55:52] *** Quits: Blub\w (wry@moz-DF767356.wireless.dyn.drei.com) (Quit: bbl)
[11:56:19] *** Quits: doener (bs@moz-AA189A5A.unitymedia.biz) (Quit: leaving)
[12:01:47] *** Joins: tfk (Mibbit@moz-91F99944.ip47.fastwebnet.it)
[12:03:15] *** Quits: Voomer (Voomer@moz-E97E8EB7.br.br.cox.net) (Connection reset by peer)
[12:03:26] *** Joins: Voomer (Voomer@moz-E97E8EB7.br.br.cox.net)
[12:03:53] *** Quits: james4k (james@moz-726FE3EE.com) (Ping timeout)
[12:04:00] *** Quits: heftig (heftig@moz-2AFE8E9D.dip0.t-ipconnect.de) (Quit: Quitting)
[12:04:02] *** Quits: parcha (quassel@moz-A9A9F340.hsd1.ma.comcast.net) (Ping timeout)
[12:04:03] *** Joins: james4k (james@moz-726FE3EE.com)
[12:04:04] *** Joins: parcha (quassel@moz-A9A9F340.hsd1.ma.comcast.net)
[12:05:16] *** Joins: heftig (heftig@moz-2AFE8E9D.dip0.t-ipconnect.de)
[12:06:13] *** Joins: haard (fredrik@F3248749.C2E49760.92AEF337.IP)
[12:06:51] *** Joins: ghrust (ghrust@moz-4EF5B6E5.rs.github.com)
[12:06:51] <ghrust> 01[13rust01] 15bors merged 06auto into 06incoming: 02http://git.io/P71fiA
[12:06:51] *** Parts: ghrust (ghrust@moz-4EF5B6E5.rs.github.com) ()
[12:09:04] *** Joins: charliesome (charliesom@moz-3097CE0F.cpe.vividwireless.net.au)
[12:09:52] *** Joins: ghrust (ghrust@moz-4EF5B6E5.rs.github.com)
[12:09:52] <ghrust> 01[13rust01] 15bors pushed 0 new commits to 06auto: 02http://git.io/FmdZ8Q
[12:09:52] *** Parts: ghrust (ghrust@moz-4EF5B6E5.rs.github.com) ()
[12:09:52] *** Joins: ghrust (ghrust@moz-4EF5B6E5.rs.github.com)
[12:09:52] <ghrust> 01[13rust01] 15bors pushed 2 new commits to 06auto: 02http://git.io/ykOSMQ
[12:09:52] <ghrust> 13rust/06auto 1432c6199 15Lindsey Kuper: Change `alt` to `match` in filenames.
[12:09:52] <ghrust> 13rust/06auto 14c33258b 15bors: auto merge of #6773 : lkuper/rust/alt-to-match, r=thestinger...
[12:09:52] *** Parts: ghrust (ghrust@moz-4EF5B6E5.rs.github.com) ()
[12:10:38] *** Quits: tfk (Mibbit@moz-91F99944.ip47.fastwebnet.it) (Quit: http://www.mibbit.com ajax IRC Client)
[12:10:48] <charliesome> this is awesome: https://github.com/tsgates/rust.ko
[12:14:53] *** Quits: heftig (heftig@moz-2AFE8E9D.dip0.t-ipconnect.de) (Quit: Quitting)
[12:15:20] *** Quits: KindOne (KindOne@moz-AAD7235.dynamic.ip.windstream.net) (Ping timeout)
[12:18:05] *** Joins: heftig (heftig@moz-2AFE8E9D.dip0.t-ipconnect.de)
[12:19:17] *** Joins: KindOne (KindOne@moz-BD65AC3C.dynamic.ip.windstream.net)
[12:19:47] *** Joins: dylukes (dylukes@moz-B5418F79.hsd1.pa.comcast.net)
[12:21:34] *** Joins: jensnockert (jensnocker@55058FD.75EEE270.CA0B30E6.IP)
[12:24:16] *** Joins: maxli (maxli@F2D29657.F60B0462.67AC9B1.IP)
[12:27:42] *** Joins: siavashserver (siavash@535C3EFE.EE231390.82A25C10.IP)
[12:37:26] *** Quits: siavashserver (siavash@535C3EFE.EE231390.82A25C10.IP) (Quit: Konversation terminated!)
[12:41:13] *** Joins: zerty (Mibbit@A6C59A57.53B65998.1F6B983A.IP)
[12:43:50] *** Parts: zerty (Mibbit@A6C59A57.53B65998.1F6B983A.IP) ()
[12:44:23] *** Joins: Blub\w (wry@moz-577D9ED6.wireless.dyn.drei.com)
[12:45:12] <jaen> Uh, so I stopped lurking and started rusting and I wanted to have a generic is_zero function, but rust complains that it expected a type parameter instead of intergral variable in the first arm of pattern match - http://ix.io/5Po
[12:45:16] <jaen> What am I doing wrong?
[12:45:36] <bstrie> I thought we already had a generic zero thing
[12:45:41] <bstrie> bjz: ping
[12:45:50] <bjz> hoy
[12:46:04] <bstrie> do we have a generic zero thing? you're the one who knows about numbers :)
[12:46:12] <bjz> num::Zero
[12:46:13] <bstrie> fn zero_thing<T>()
[12:46:14] <bjz> :)
[12:46:42] <bstrie> jaen: ^
[12:46:46] <bjz> rusti: 0.0f.is_zero()
[12:46:48] -rusti- more than 5 lines of output, pastebinned: http://sprunge.us/cHXW
[12:46:59] <bjz> oh wait
[12:47:16] <bjz> rusti: Zero::zero::<f32>()
[12:47:18] -rusti- more than 5 lines of output, pastebinned: http://sprunge.us/fWDj
[12:47:25] <bjz> ohh
[12:47:30] <bjz> it's not in prelude
[12:47:41] <bstrie> do you think it should be?
[12:47:46] <bjz> rusti: use num::Zero; 0.0f.is_zero()
[12:47:47] -rusti- more than 5 lines of output, pastebinned: http://sprunge.us/bdNF
[12:47:52] <bjz> rusti: use std::num::Zero; 0.0f.is_zero()
[12:47:53] -rusti- true
[12:47:53] -rusti- playpen: rmdir: Device or resource busy
[12:48:07] <jaen> Hmr
[12:48:20] <bjz> rusti: num::Zero::zero::<f32>()
[12:48:22] -rusti- 0
[12:48:22] -rusti- playpen: rmdir: Device or resource busy
[12:48:23] <jaen> I tried use std::num::Zero; and then Zero::zero() in that arm
[12:48:32] <jaen> But it didn't like it either
[12:49:02] <bjz> it's annoying without pcwalton's patch, and without associated constants
[12:49:29] <bjz> ie. it would be better if we could do: float::ZERO;
[12:49:42] <bstrie> yeah
[12:49:52] <bjz> or at the very least, float::zero()
[12:50:42] <jaen> Hmm, maybe I'm wrong but doesn't Haskell do it like every numeric constant starts out as Num and converts to the proper numeric type? Is there some reason rust doesn't want to do that? (disclaimer: I have only vague Haskell knowledge and may be wrong on that account)
[12:50:42] <bjz> Zero::zero::<float>() - ugh
[12:51:39] <dbaupp> jaen: every numeric constant is implicitly either `fromInteger n` or `fromRational n` (depending on if it's an integer or floating point constant)
[12:51:42] *** Joins: vosen (vosen@moz-266BA656.icpnet.pl)
[12:51:56] <jaen> `Zero::zero::<T>() => { println("zero") }` results in "error: `zero` is not an enum variant, struct or const" here ; /
[12:52:18] <bjz> that's why we need associated consts
[12:52:20] <dbaupp> jaen: Haskell's semantics are higher level though, so they can "afford" to call functions on their constants at runtime
[12:52:34] <bjz> you can only match on constexprs
[12:52:49] <bjz> it's a major pain point
[12:52:51] <jaen> That explains a lot
[12:52:54] <bjz> :(
[12:52:57] <dbaupp> jaen: whereas Rust is trying to map to the hardware closely, so that matches should be quite raw
[12:53:03] <jaen> So I just have to stick with non-generic version for now
[12:53:10] <bjz> yeah, it sucks
[12:53:25] <jaen> dbaupp: I thought Haskell does that conversion compile time, silly me
[12:53:27] <bjz> but there's just so much that the devs need to work on
[12:53:29] <dbaupp> jaen: you can use if foo.is_zero() { .. } else { .. } ?
[12:53:46] <bjz> that's one solution ^
[12:53:52] <bjz> albiet more ugly
[12:54:08] <jaen> dbaupp: yeah, probably, but that's just in case of zero or one, right? I f I wanted, say, five I'm still out of luck, right?
[12:54:16] <dbaupp> jaen: I'm sure it does it for built-in types (because optimisations are good), but it can't do it general
[12:54:24] <dbaupp> jaen: there is the `cond!` macro
[12:54:31] <dbaupp> (wait, are you on 0.6?)
[12:54:48] <bjz> if x == num::cast(5) { } else { }
[12:54:49] <jaen> oh, yeah, the cond!, I like me some cond
[12:54:57] <jaen> dbaupp: on rust as of somewhen yesterday
[12:55:06] <dbaupp> rusti: cond!( (2 == 3) { 0 } (1 == 2) { 1 } (3 == 3) { 2  } )
[12:55:08] -rusti- more than 5 lines of output, pastebinned: http://sprunge.us/RVDb
[12:55:10] <bjz> unfortunately we don't have a from_int atm
[12:55:19] <bjz> still need to rectify that
[12:55:29] <dbaupp> rusti: cond!( (2 == 3) { 0 } (1 == 2) { 1 } (3 == 3) { 2 } _ { 3 } )
[12:55:31] -rusti- 2
[12:55:31] -rusti- playpen: rmdir: Device or resource busy
[12:55:43] <dbaupp> jaen: that should work
[12:55:46] <jaen> rusti, u so funny
[12:55:49] <jaen> lemme see
[12:56:18] <bjz> jaen: and cond looks uglier than it should because of limitations in macros that need to be ironed out
[12:56:48] <bjz> cond! { 2 == 3 { 0 } _ { 3 } } is what we want
[12:56:54] <jaen> oh yeah, I noticed some talk about macros delimiters wrt cond while lurking
[12:57:07] <bjz> yeah, so much to do
[12:57:19] <jaen> I'd help, but I'm still too rust-dumb ; p
[12:57:57] <dbaupp> that's not an obstacle! bors is there to save you from any screw-ups ;)
[12:58:21] <jaen> I'll try to write a game of life on infinite plane
[12:58:25] <jaen> If I can manage to do that
[12:58:32] <jaen> I'll think about contributing ; p
[13:00:00] <bjz> things will improve :)
[13:03:08] *** Quits: jaen (jaen@B361617C.6A94545C.43DC2829.IP) (Ping timeout)
[13:03:19] *** Joins: jaen (jaen@B361617C.6A94545C.43DC2829.IP)
[13:04:28] *** Joins: jaen1 (jaen@moz-C4438BD1.play-internet.pl)
[13:05:10] *** Quits: jaen (jaen@B361617C.6A94545C.43DC2829.IP) (Ping timeout)
[13:05:21] <jaen1> Rust is still pretty damn cool as it is, does most of the things I would have liked my dream language to do, except having less hardcore macros ; p
[13:05:26] *** jaen1 is now known as jaen
[13:06:03] <dbaupp> jaen: Rust has less hardcore macros, or your dream language?
[13:06:23] <jaen> Rust
[13:07:04] <jaen> My dream language would have something like this probably - http://www.umsec.umn.edu/publications/Context-Aware-Scanning-Parsing-Extensible-Language
[13:07:46] <dbaupp> Well, you *can* write macros in Rust
[13:07:58] <dbaupp> and then they can process anything that the tokeniser accepts
[13:08:17] <dbaupp> (i.e. they get their input tokenised, but nothing else)
[13:09:02] *** Quits: dylukes (dylukes@moz-B5418F79.hsd1.pa.comcast.net) (Quit: ["Textual IRC Client: www.textualapp.com"])
[13:09:20] <bjz> jaen: nice!
[13:09:27] *** Joins: jdm (jdm@DB05BBF2.BB1F48F2.971E19F6.IP)
[13:09:36] <jaen> But as far as I gather from docs it's more like scheme pattern matching macros, right?
[13:09:54] <jaen> Or did I get them wrong?
[13:09:57] <bjz> jaen: that is correct
[13:10:08] <bjz> jaen: they are reasonably limated
[13:10:12] <bjz> *limited
[13:10:26] <dbaupp> jaen: only the ones defined with macro_rules!
[13:10:38] <bjz> there is opportunity for improvement
[13:10:43] <jaen> So a macro cannot say, introduce fields to structs and whatnot
[13:10:54] <jaen> dbaupp: are there macro which do not rule?
[13:11:19] <dbaupp> jaen: yeah, the ones like fmt! are written in Rust in libsyntax
[13:11:20] <dbaupp> sec
[13:11:43] <jaen> oh yeah, but they need to come with compiler, right?
[13:11:56] <dbaupp> https://github.com/mozilla/rust/blob/incoming/src/libsyntax/ext/fmt.rs
[13:11:58] <dbaupp> jaen: mostly
[13:12:18] <dbaupp> the plan is for being able to load them into the compiler when compiling
[13:12:27] <dbaupp> and it's semipossible atm
[13:12:44] <dbaupp> https://github.com/mozilla/rust/pull/6735
[13:12:58] <jaen> oh, nice I didn't realise it's a planned feature
[13:13:22] <bjz> jaen: they're pretty open to help
[13:13:36] <bjz> jaen: if this is one of your 'pet things'
[13:13:37] <dbaupp> jaen: there are macros that work as attributes (e.g. #[deriving]), so one could use one of those to add fields to structs
[13:14:00] <jaen> oh wow, that's a macro?
[13:14:05] <dbaupp> (currently only definable via hardcoding in libsyntax/using that dodgy patch of mine)
[13:14:20] <dbaupp> jaen: technically "syntax extension" in Rust parlance
[13:14:32] <dbaupp> but it uses exactly the same underlying code as fmt!
[13:14:55] <bjz> pauls was doing much of the awesomeness, but unfortunately he has been struck down with RSI.
[13:15:51] *** Joins: ghrust (ghrust@moz-4EF5B6E5.rs.github.com)
[13:15:51] <ghrust> 01[13rust01] 15bors merged 06auto into 06incoming: 02http://git.io/ykOSMQ
[13:15:51] *** Parts: ghrust (ghrust@moz-4EF5B6E5.rs.github.com) ()
[13:16:09] <jaen> bjz: it's more of a casual interest, I'd probably get lost in intricacies, if I got aroundto contributing I'd think about a more Java/C#-like reflection library or custom attributes (those are not user definable atm, right?)
[13:16:21] <bjz> oh ok
[13:16:34] <bjz> macros are a pretty tricky bit of the compiler
[13:16:56] <bjz> it's not exactly a 'low hanging fruit' :(
[13:17:02] <jaen> But first I'd need to write something bigger to get a better feel of the language before setting the tree on fire ; p
[13:17:07] *** Quits: charliesome (charliesom@moz-3097CE0F.cpe.vividwireless.net.au) (Quit: Textual IRC Client: www.textualapp.com)
[13:17:13] <bjz> you can't really
[13:17:19] <bjz> set the tree on fire
[13:17:33] <bjz> well, it's very hard to
[13:17:42] <bjz> bors stands sentry
[13:18:04] *** Joins: jorendorff (jorendorff@moz-2F32ACA3.hsd1.tn.comcast.net)
[13:18:12] *** Quits: jorendorff (jorendorff@moz-2F32ACA3.hsd1.tn.comcast.net) (Quit: jorendorff)
[13:18:25] *** Joins: jorendorff (jorendorff@moz-2F32ACA3.hsd1.tn.comcast.net)
[13:18:25] <dbaupp> jaen: what do you mean by "custom attributes"?
[13:18:50] <dbaupp> (the things like #[deriving]?)
[13:19:19] *** Joins: engla (engla@moz-DBD1D96E.cust.bredbandsbolaget.se)
[13:19:21] <jaen> dbaupp: maybe I misread something, but at the moment a user can't define an attribute, right?
[13:19:52] <dbaupp> jaen: not without hacking at the compiler
[13:19:56] <dbaupp> so yes
[13:20:03] <dbaupp> they can't
[13:21:32] <jaen> So that's hypothetically one thing could work on when he starts grokking rust, right?
[13:21:55] *** Joins: ghrust (ghrust@moz-4EF5B6E5.rs.github.com)
[13:21:55] <ghrust> 01[13rust01] 15bors pushed 0 new commits to 06auto: 02http://git.io/9ehvOw
[13:21:55] *** Parts: ghrust (ghrust@moz-4EF5B6E5.rs.github.com) ()
[13:22:01] *** Joins: ghrust (ghrust@moz-4EF5B6E5.rs.github.com)
[13:22:01] <ghrust> 01[13rust01] 15bors pushed 3 new commits to 06auto: 02http://git.io/ba27vQ
[13:22:01] <ghrust> 13rust/06auto 14874ea93 15Alex Crichton: Fix 'make check-stage1-std' by correcting dependencies
[13:22:01] <ghrust> 13rust/06auto 14847dbbe 15Alex Crichton: Silence various warnings throughout test modules
[13:22:01] <ghrust> 13rust/06auto 14c703758 15bors: auto merge of #6774 : alexcrichton/rust/silence-warnings, r=catamorphism...
[13:22:03] *** Parts: ghrust (ghrust@moz-4EF5B6E5.rs.github.com) ()
[13:22:36] <dbaupp> jaen: of course!
[13:22:38] <dbaupp> :)
[13:23:31] <jaen> So I'm back to making me grok then ; )
[13:29:57] <kaeso> I'm not sure if it's the same question, but one can define a custom cfg attributes at command-line with --cfg
[13:31:11] *** Quits: cdidd (cdidd@C9988B9C.8AFAB4CD.62D8163C.IP) (Ping timeout)
[13:32:26] <jaen> I was thinking more about something along the lines #[as_lua_userdata] or something
[13:33:01] *** Joins: SimonSapin (simon@5AAE35B2.5EFFC0B8.24454B25.IP)
[13:41:09] *** Quits: jensnockert (jensnocker@55058FD.75EEE270.CA0B30E6.IP) (Input/output error)
[13:41:52] <bstrie> jaen: oh ho, what are you up to with lua
[13:42:07] <bstrie> I just managed to generate luajit2 bindings last week, still have to wrap them nicely
[13:42:14] <EXetoC> rusti: fn a() -> Result<~int, ~int> { Ok(~1) } a()
[13:42:15] -rusti- Ok(~1)
[13:42:15] -rusti- playpen: rmdir: Device or resource busy
[13:42:39] <EXetoC> rusti: fn a() -> Result<~int, ~int> { Ok(~1) } let i = a().get_ref();
[13:42:41] -rusti- more than 5 lines of output, pastebinned: http://sprunge.us/PTGP
[13:43:40] <jaen> bstrie: right now I'm just more tthinking about things than doing anything practical, but at some point it would be nice to have some sort of reflection/macro powered transparent sharing betwee Rust and lua
[13:43:53] <jaen> But right now I just rust-noob about, nothing more
[13:44:00] *** Joins: cowboyd (cowboyd@1D8844A7.1B729417.CEE440B6.IP)
[13:44:25] <bstrie> jaen: do you have experience with embedding lua in C/C++? because I'm a lua noob and I'd like some test cases for making lua bindings :)
[13:44:41] *** Quits: haard (fredrik@F3248749.C2E49760.92AEF337.IP) (Ping timeout)
[13:45:02] *** Joins: haard (fredrik@F3248749.C2E49760.92AEF337.IP)
[13:45:53] *** Joins: solancile (solancile@moz-A1CFFAE5.hsd1.wa.comcast.net)
[13:46:08] <jaen> bstrie: not really, I work with Ruby on Rails mostly, I just sometimes do weird things on a whim, it would be first time trying to embed lua ; p
[13:46:54] <EXetoC> I'm not sure how to deal with that error
[13:47:25] <jaen> I had some experience with OpenGL but that's about it wrt gamedevy things
[13:49:51] <bstrie> EXetoC: do you need to take a reference to it if it's already a unique pointer?
[13:50:11] <bstrie> oh wait, nm
[13:50:16] <bstrie> was reading this wrong
[13:50:29] <bstrie> thought that last part was inside of a()
[13:52:32] <EXetoC> it works if I create a temporary, but I'm trying to make it more concise
[13:55:04] *** Joins: strcat (strcat@moz-54F7FD49.cpe.net.cable.rogers.com)
[13:55:43] <dbaupp> EXetoC: there's no way around it, with blah().get_ref() the return value of blah goes out of scope as soon as the get_ref call finishes
[14:00:01] <EXetoC> right
[14:00:58] <EXetoC> I guess I could add a flag that determines if functions should fail directly, which would simplify the code
[14:02:03] *** Joins: tiffany (kawaii@moz-1E0FE6E8.dhcp.embarqhsd.net)
[14:05:32] *** Joins: saml (sam@moz-14C16814.cst.lightpath.net)
[14:05:47] <EXetoC> thought i might not actually need to generate results in so many. still, being it'd be nice to be able to avoid the temporary
[14:06:39] <EXetoC> actually, unwrap isn't as bad in this regard. I wonder if the signatures need to differ as much as they do
[14:07:22] *** Joins: jensnockert (jensnocker@moz-8BE55278.customer.t3.se)
[14:11:58] <cmr> bstrie: engla had some stuff with lua
[14:15:52] *** Quits: dan_johnsin (dan_johnsi@6902762D.11B071D.FB9A45AF.IP) (Client exited)
[14:17:07] *** Joins: dan_johnsin (dan_johnsi@6902762D.11B071D.FB9A45AF.IP)
[14:18:07] *** Joins: jviereck (Adium@moz-5116E6BD.ethz.ch)
[14:18:52] *** Joins: ghrust (ghrust@moz-4EF5B6E5.rs.github.com)
[14:18:52] <ghrust> 01[13rust01] 15bors 04force-pushed 06auto from 14c703758 to 14c33258b: 02http://git.io/N3iJvQ
[14:18:52] *** Parts: ghrust (ghrust@moz-4EF5B6E5.rs.github.com) ()
[14:18:55] *** Joins: ghrust (ghrust@moz-4EF5B6E5.rs.github.com)
[14:18:55] <ghrust> 01[13rust01] 15bors pushed 2 new commits to 06auto: 02http://git.io/J_f2ug
[14:18:55] <ghrust> 13rust/06auto 142505416 15Rob Hoelz: Remove colorcolumn setting
[14:18:55] <ghrust> 13rust/06auto 1405735a9 15bors: auto merge of #6783 : hoelzro/rust/master, r=bstrie...
[14:18:55] *** Parts: ghrust (ghrust@moz-4EF5B6E5.rs.github.com) ()
[14:21:46] *** Joins: wizeman (quassel@moz-9C343656.dyn.user.ono.com)
[14:22:03] *** Joins: jeff (jeff@4231C034.745B261B.F12515B4.IP)
[14:22:19] *** Quits: jeff (jeff@4231C034.745B261B.F12515B4.IP) (Quit: jeff)
[14:28:10] *** Joins: Yurume (yurume@AC58A8CE.8A059B47.E313B915.IP)
[14:28:24] *** Quits: SimonSapin (simon@5AAE35B2.5EFFC0B8.24454B25.IP) (Quit: Leaving.)
[14:29:16] *** Quits: threecreepio (jdp@moz-F2D425CF.business.telia.com) (Quit: threecreepio)
[14:35:01] *** Joins: threecreepio (jdp@moz-F2D425CF.business.telia.com)
[14:35:09] *** Quits: yong (chatzilla@74DA0C97.4E87ADC2.263D9828.IP) (Ping timeout)
[14:35:13] *** Quits: snearch (snearch@moz-9D325B5D.pool.mediaways.net) (Quit: Verlassend)
[14:35:14] *** Joins: erickt (erickt@8C9ECD8F.3A598286.F12515B4.IP)
[14:35:28] *** Joins: snearch (snearch@moz-9D325B5D.pool.mediaways.net)
[14:35:39] *** Joins: yong (chatzilla@74DA0C97.4E87ADC2.263D9828.IP)
[14:37:27] *** Joins: doomlord_ (walter@moz-A9E19E41.range86-140.btcentralplus.com)
[14:37:40] *** Joins: doomlord (doomlod@moz-A9E19E41.range86-140.btcentralplus.com)
[14:38:40] <jaen> I've just had this idea that the rust book should be named "Learn You a Rust For The Good of All of Us" with a subtitle of "Except Those Who Are Dead" and have funny Portal pictures ; d
[14:38:51] *** Quits: threecreepio (jdp@moz-F2D425CF.business.telia.com) (Quit: threecreepio)
[14:39:22] <bstrie> jaen: I was thinking of naming it "Rust in Pieces"
[14:39:27] <doomlord> lol
[14:39:36] <jaen> This is pretty not bad too
[14:39:55] <benh> I like that better than pop culture references :)
[14:41:20] *** Joins: Scriptor (historium@moz-E06F46F0.corp.bitshelter.com)
[14:42:11] *** Quits: Scriptor (historium@moz-E06F46F0.corp.bitshelter.com) (Quit: Scriptor)
[14:42:17] *** Joins: Scriptor (historium@moz-E06F46F0.corp.bitshelter.com)
[14:42:17] *** Quits: dbaupp (Thunderbir@moz-C6B1454A.lns20.syd7.internode.on.net) (Ping timeout)
[14:42:39] <jdm> Rust for the Rusty
[14:44:51] <bstrie> every book comes with a can of WD-40
[14:45:42] <jaen> I'd leave that for collector's edition ; p
[14:46:00] <strcat> bstrie: and a free tetanus shot?
[14:46:27] <bstrie> strcat: I'm not sure, how long do those keep on the shelves?
[14:46:44] <bstrie> strcat: btw, rusti is whining about something called playpen
[14:46:47] <bstrie> rusti: 1
[14:46:49] -rusti- 1
[14:46:49] -rusti- playpen: rmdir: Device or resource busy
[14:46:52] <strcat> heh
[14:47:09] <strcat> rusti: 1
[14:47:09] -rusti- 1
[14:47:09] -rusti- playpen: rmdir: Device or resource busy
[14:47:14] <strcat> wat
[14:47:18] <strcat> why won't the cgroup die
[14:47:23] <doomlord> lol. debugger,lint tools - tetanus, or wd40
[14:47:42] <doomlord> tetanus-shot^
[14:47:54] <strcat> bstrie: oh my fault
[14:47:59] <strcat> I was messing around with it last night
[14:48:02] <strcat> rusti: 1
[14:48:02] -rusti- 1
[14:48:04] <strcat> rusti: 1
[14:48:05] -rusti- 1
[14:48:13] <strcat> bstrie: was because I started adding nested ones ;p
[14:48:27] <bstrie> nested interpreters?
[14:48:40] <strcat> bstrie: no, nested cgroups
[14:48:46] <strcat> so it can concurrently eval rust code
[14:48:55] <strcat> bstrie: https://github.com/thestinger/playpen https://github.com/thestinger/playpen/issues/4
[14:49:20] <bstrie> ah I see, so you can have more than one person using it at a time
[14:49:41] <strcat> bstrie: yeah I want to make 1 per channel
[14:49:47] <strcat> and also let it spawn maybe up to 10 for PMs
[14:49:51] <jaen> doomlord: I think that won't fly, while I was lurking I noticed that while it's a witty name rustpkg will not go back to being cargo ; /
[14:50:05] <strcat> bstrie: anyway playpen has a wider usage than rusti ;p
[14:50:34] <strcat> I just finished most of it yesterday so... needs a lot of work
[14:51:38] *** Quits: jviereck (Adium@moz-5116E6BD.ethz.ch) (Quit: Leaving.)
[14:54:53] *** Quits: jaen (jaen@moz-C4438BD1.play-internet.pl) (Ping timeout)
[14:55:56] <strcat> bstrie: https://github.com/thestinger/playpen/blob/master/playpen.cc#L87 that's where it was screwing up ;p
[14:56:07] <strcat> because I made a dir called 0 in the cgroup and forgot about it
[14:56:09] *** Quits: erickt (erickt@8C9ECD8F.3A598286.F12515B4.IP) (Quit: Leaving.)
[14:56:13] <strcat> they're a tree, basically
[14:56:22] <strcat> there's always a top-level one
[14:57:51] <bstrie> ok
[14:59:14] *** Quits: bjz (brendanzab@B398BE78.F804C29E.D35A31DF.IP) (Quit: Leaving...)
[15:01:30] *** Joins: themgt (themgt@moz-248BBB96.dhcp.gnvl.sc.charter.com)
[15:01:31] *** Quits: themgt (themgt@moz-248BBB96.dhcp.gnvl.sc.charter.com) (Quit: themgt)
[15:02:14] *** Joins: BizarreCake (BizarreCak@32C9829A.151E84E7.561471F8.IP)
[15:03:17] *** Quits: haard (fredrik@F3248749.C2E49760.92AEF337.IP) (Ping timeout)
[15:06:01] *** Joins: eholk (eholk@moz-EB4FB3E5.uconnect.utah.edu)
[15:07:59] *** Joins: kesserich (Mibbit@moz-7ABC9BDB.hsd1.pa.comcast.net)
[15:08:17] <nmatsakis> anybody develop in windows? any idea how to get a rust tstack trace?
[15:09:09] <bstrie> we need an emergency windows task team
[15:09:57] <nmatsakis> we need a decent windows port is what we need :)
[15:10:19] <nmatsakis> but seriously, I get a stack trace, but without any functions at all
[15:10:23] <nmatsakis> or any functio names rather
[15:10:56] *** Quits: eholk (eholk@moz-EB4FB3E5.uconnect.utah.edu) (Quit: eholk)
[15:11:45] <kesserich> Howdy. Does anyone have experience using rust to define extern fn's for C callbacks?  I believe I have managed to wire up such a callback but I am encountering a strange runtime everyone if I attempt to use most rust fn's within the callback.  
[15:11:57] *** Joins: erickt (erickt@8C9ECD8F.3A598286.F12515B4.IP)
[15:12:19] <kesserich> Even an io::println will terminate the program with the error like: Assertion failed: (task != NULL && "no current task")
[15:12:29] <nmatsakis> kesserich: how are you calling the C code?
[15:12:41] <nmatsakis> kesserich: it sounds like the Rust thread-local-storage is not set, maybe it's calling you back from another thread?
[15:13:18] <nmatsakis> hmm. "Cannot access memory at address 0x1234567c". Sounds suspicious!
[15:13:57] <kesserich> nmatsakiks: the C library is almost definitely calling me back from another thread.  I'm passing a callback to the Jack audio library which is periodically asking me to provide a buffer of audio data.
[15:14:29] <nmatsakis> kesserich: ah. in that case, you won't be able to do much right now. one option is to create a port pair and use messaging,
[15:14:38] <nmatsakis> kesserich: though even that might not work without the runtime.
[15:14:48] <nmatsakis> kesserich: we are doing some work on refactoring to better support this kind of scenario
[15:14:56] *** Joins: BitPuffin (quassel@moz-8370D1B9.bredband.comhem.se)
[15:15:01] *** Quits: pyrac (pyrac@9F71F32A.73C89388.AD05C589.IP) (Quit: pyrac)
[15:15:53] *** Joins: threecreepio (jdp@moz-DB2D70E9.cust.bredbandsbolaget.se)
[15:16:16] <kesserich> nmatsakis: let me post a gist real quick to make sure i'm not doing anything stupid :P
[15:16:21] *** Joins: ghrust (ghrust@moz-4EF5B6E5.rs.github.com)
[15:16:21] <ghrust> 01[13rust01] 15bors merged 06auto into 06incoming: 02http://git.io/J_f2ug
[15:16:21] *** Parts: ghrust (ghrust@moz-4EF5B6E5.rs.github.com) ()
[15:16:25] <nmatsakis> kesserich: ok. If all you want is debugging printfs, there are sol'ns
[15:16:39] <nmatsakis> kesserich: I can point you at some code that just invokes the raw unix functions, for example, specifically for this reason
[15:16:59] <nmatsakis> kesserich: I imagine in this situation you have the data ready and just need to shovel it in
[15:17:48] <strcat> nmatsakis: in the code that generates glue_drop, does it currently have a way to know if the value was definitely *not* moved from?
[15:18:07] <nmatsakis> strcat: no.
[15:18:34] <kesserich> https://gist.github.com/psantacl/5663510
[15:18:51] <nmatsakis> strcat: I am thinking btw that it's probably not too hard to avoid generating calls to drop for moved locals (and thus avoid zeroing them out); totally removing the "zero out" behavior will be harder (e.g., if you move from a.b, we may still need to zero)
[15:19:14] <strcat> nmatsakis: the zeroing out isn't too bad, C++ does it - as long as we can make it only zero the first ptr or something
[15:19:20] <kesserich> nmatsakis: raw unix functions would be great.  The more functionality I can get away with the better. 
[15:19:46] <strcat> nmatsakis: I think the reason we get much worse code than C++ moves is lack of TBAA
[15:20:30] *** Joins: eholk (eholk@moz-6546E880.uconnect.utah.edu)
[15:21:03] <strcat> nmatsakis: I don't know if you know what C++11 does in regards to this
[15:22:51] <nmatsakis> kesserich: check out the trait DebugPrints in src/libstd/unstable/lang.rs
[15:23:12] <nmatsakis> kesserich: it writes directly to the stdout file descriptor to avoid allocating or relying on standard library, since that code is running as *part* of the allocator
[15:23:23] <nmatsakis> strcat: enlighten me,.
[15:23:30] *** Joins: dherman (dherman@moz-6CA476B1.hsd1.ca.comcast.net)
[15:23:30] *** ChanServ sets mode: +o dherman
[15:23:31] <jensnockert> Am I just amazingly lost in the str documentation, or is there no function to split a string into a ~[~str] or something similar in an easy way?
[15:23:50] <strcat> nmatsakis: http://ix.io/5Ps well, basically that's a C++ object with a move constructor
[15:23:53] <nmatsakis> jensnockert: there is. look in src/libstd/str.rs for functions named `split`
[15:24:01] <strcat> nmatsakis: they usually manually copy field-by-field (worse than what we do) and then zero at least one field
[15:24:03] <nmatsakis> jensnockert: maybe it's not showing up in the docs
[15:24:25] <strcat> so it copies over other.ptr and then sets other.ptr = nullptr - exactly what we do afaict
[15:24:45] <nmatsakis> strcat: I see. We could probably be cute to avoid over-zeroing, but it'd require a bit of caution I think
[15:24:46] <strcat> but clang is outputting much better code pre-optimization
[15:25:06] *** Joins: jaen (jaen@moz-E0979827.copit.pl)
[15:25:15] <strcat> nmatsakis: it would be nice to be able to override the drop flag + drop flag check for some types
[15:25:20] <strcat> like std::rc
[15:25:49] <nmatsakis> strcat: hmm, we could conceivably have an annotation on the drop trait that permits it to run multiple times.
[15:26:04] <strcat> nmatsakis: need a way to zero the ptr during the move though
[15:26:19] <strcat> unless it still does that for you, but it might be more than you need
[15:26:31] <jensnockert> nmatsakis: Nope, only each_split functions there as well.
[15:27:44] *** Quits: dherman (dherman@moz-6CA476B1.hsd1.ca.comcast.net) (Quit: dherman)
[15:27:57] <kesserich> nmatsakis: I found a DebugPrint trait impl in libcore/unstable/lang.rs. Is that the one?
[15:29:23] <kesserich> so i mean basically, i am limited to function calls within the libc module?
[15:29:26] *** Joins: Dimension (Mibbit@moz-4CCD79C5.dsl.dynamic.simnet.is)
[15:30:20] <nmatsakis> jensnockert: oh, combine with iter
[15:30:42] *** Joins: pyrac (pyrac@9F71F32A.73C89388.AD05C589.IP)
[15:31:03] <nmatsakis> kesserich: I don't know, but you can't go too wrong with those :)
[15:31:13] <nmatsakis> strcat: I see, yes, that's true.
[15:31:24] <jensnockert> nmatsakis: I did a https://gist.github.com/JensNockert/f55018440e13dd39f964 combo, is there a shorter way?
[15:31:30] <strcat> nmatsakis: clang also inlines the null check for free
[15:31:43] <strcat> nmatsakis: http://ix.io/5Pt what their destructor looks like
[15:32:06] <nmatsakis> jensnockert: not much, in principle iter::to_vec() might save a few characters, though at the cost of being somewhat more opaque.
[15:32:58] <nmatsakis> strcat: we could certainly inline the null check, with a bit of effort
[15:33:06] *** kimundi is now known as zz_kimundi
[15:33:41] <kesserich> nmatsakis: gotcha.  The gist(https://gist.github.com/psantacl/5663510) looks roughly correct though right?  I'm not doing anything stupid with regards to defining my callback?
[15:33:45] <strcat> nmatsakis: I guess if we were using an embedded jemalloc we could rm the check from the implementation and put it in rust instead
[15:34:00] <strcat> atm LLVM can't remove our glue_drop calls
[15:34:10] *** zz_kimundi is now known as kimundi
[15:34:18] <nmatsakis> kesserich: yes.
[15:34:32] <strcat> they also mark the return value of new and malloc as noalias which is clever
[15:34:35] <nmatsakis> strcat: I'd be inclined to just check both places.
[15:34:44] <kesserich> nmatsakis: thanks :)
[15:34:46] <nmatsakis> strcat: yes that's a standard optimization
[15:36:04] <strcat> nmatsakis: marking ~ parameters as noalias actually ends up helping a lot in places like treemap
[15:36:23] <strcat> I think if we were able to mark the end of lifetimes when we knew for sure stuff wasn't moved from, it would generate code really close to clang
[15:36:55] <strcat> atm it knows the parameter is noalias but we aren't informing it that if you move something into a function, what the function does to it isn't visible externally
[15:37:08] <strcat> dunno if there's some way to do that...
[15:38:07] <bstrie> strcat: all this optimization work is head-explodingly awesome, I'm just worried that without tests that look directly at LLVM output we're eventually going to regress without realizing it
[15:39:37] *** Quits: dan_johnsin (dan_johnsi@6902762D.11B071D.FB9A45AF.IP) (Quit: Leaving)
[15:40:18] *** Joins: dan_johnsin (dan_johnsi@6902762D.11B071D.FB9A45AF.IP)
[15:40:49] <nmatsakis> strcat: yeah, I don't know.
[15:41:16] <strcat> anyway it's just disappointing that LLVM can't remove essentially any glue drops or move zeroes ;p
[15:41:34] <strcat> maybe once the FFI layers are torn down the libcall optimization pass will kick in
[15:41:42] <nmatsakis> strcat: regarding the impl of the drop trait, it seems like that would fit in with pcwalton's ideas to have generic smart pointer traits
[15:42:00] <benh> Smart pointer traits?
[15:42:02] <nmatsakis> strcat: that would allow deeper integration with the borrow checker
[15:42:25] <nmatsakis> benh: we're thinking about moving some of the functionality that is now built-in into generic traits that other "smart pointer" types (like Rc<T>) can implement
[15:42:35] <benh> cool :)
[15:42:41] <nmatsakis> precise details tbd :)
[15:43:10] <benh> would that apply to vectors behind ~/@ as well after the dynamically-sized type magic happens?
[15:43:25] <nmatsakis> vectors behind ~ won't be a concept anymore, really
[15:43:34] <nmatsakis> so I guess the answer is yes
[15:43:39] <nmatsakis> what I mean is, you will still write ~[T]
[15:43:47] <nmatsakis> but from the type system's point of view, that will be ~([T])
[15:43:53] <nmatsakis> whereas now the ~ and [] are inseperable
[15:44:02] <nmatsakis> so yes Rc<[T]> should be ok
[15:44:28] *** Joins: eatkinson (eatkinson@2557E599.66715431.D25A875A.IP)
[15:44:32] <strcat> I don't really understand why clang outputs alignments on functions
[15:44:38] <benh> Looking forward to the details :)
[15:44:40] <strcat> seems to make lots of them align 2
[15:45:15] <strcat> If the unnamed_addr attribute is given, the address is know to not be significant and two identical functions can be merged.
[15:45:19] <strcat> aatch: ^^^
[15:45:22] <benh> (I know I'm not being productive with that at all but I've been hoping that built-in types could hoard less of the magic and share it with user pointer types or container types more ;)
[15:45:26] <strcat> we need to be doing that.
[15:46:08] <strcat> nmatsakis: is the actual address of a function ever significant or used in comparisons? I don't think so
[15:46:10] *** Joins: jack (jack@moz-B9D40F4B.hfc.comcastbusiness.net)
[15:46:23] * strcat is going to try the unnamed_addr thing
[15:46:46] <strcat> if only I knew why it marked them align 2...
[15:46:47] <nmatsakis> strcat: it can be?
[15:46:56] <nmatsakis> strcat: you can compare function pointers
[15:47:02] <strcat> nmatsakis: ah
[15:47:09] <nmatsakis> strcat: however, only fn items
[15:47:12] <nmatsakis> strcat: not closures
[15:47:28] <nmatsakis> strcat: also I don't know if we implement Eq for `extern fn` types, but I think we...might as well?
[15:47:44] <nmatsakis> strcat: so probably the answer is "no" right now, and maybe it will stay no if that makes things run much better
[15:47:45] *** Quits: berak (chatzilla@B8C4FD6F.5F42470D.16E13E53.IP) (Ping timeout)
[15:47:49] <nmatsakis> strcat: though I suspect closures are the imp't case
[15:48:11] <strcat> nmatsakis: graydon found that there were like 300 copies of hashmap in librustc
[15:48:20] <strcat> so we were looking into how to merge them, and there's a pass that can
[15:48:26] <strcat> but it wasn't really working so...
[15:48:27] <strcat> perhaps this is why
[15:48:46] <strcat> (lots were identical)
[15:48:47] *** Joins: berak (chatzilla@B8C4FD6F.5F42470D.16E13E53.IP)
[15:49:12] <strcat> anyway looking at clang's output is enlightening ;p
[15:49:31] <strcat> made our swaps faster that way, just have to copy whatever it does :)
[15:50:05] <strcat> nmatsakis: so I guess it knows certain function ptrs can't be compared in C++ - I haven't really ever thought about it
[15:50:10] <strcat> it marks all constructors/destructors this way
[15:50:23] <nmatsakis> strcat: methods would be another case
[15:50:29] <nmatsakis> strcat: well, at least until we unify methods / fns
[15:50:46] <nmatsakis> strcat: but this is a persuasive reason not to support comparing fn pointers...
[15:51:17] <nmatsakis> strcat: actually, it'd be hard to support it anyhow
[15:51:21] <strcat> nmatsakis: it also applies to addresses of globals
[15:51:34] <nmatsakis> strcat: since we can't implement Eq for all extern fn types in a generic way
[15:51:34] <strcat> if we decided the addresses were unimportant, it could merge them
[15:51:50] <nmatsakis> strcat: though we could handle fns of up to N arguments for some reasonable N, much like tuples.
[15:52:03] <nmatsakis> strcat: ok, well, those are definitely used.
[15:52:19] <nmatsakis> strcat: also, it's not obvious to me why we would ever merge constants? I mean, they're not duplicated willy nilly like generic code is
[15:52:32] <strcat> nmatsakis: well I think array literals count as constants
[15:52:49] <strcat> clang doesn't merge them though, so... it wouldn't be worse than C++
[15:52:58] <nmatsakis> strcat: I doubt it? they can contain arbitrary values.
[15:53:04] <nmatsakis> strcat: maybe in some special cases...
[15:53:17] <nmatsakis> strcat: ...anyhow, we could probably add the flag in some cases, like temporary rvalues in constants or something.
[15:55:25] *** Quits: KindOne (KindOne@moz-BD65AC3C.dynamic.ip.windstream.net) (Ping timeout)
[15:55:50] *** Quits: threecreepio (jdp@moz-DB2D70E9.cust.bredbandsbolaget.se) (Quit: threecreepio)
[15:55:54] *** Joins: dylukes (dylukes@moz-B5418F79.hsd1.pa.comcast.net)
[15:55:54] *** Quits: berak (chatzilla@B8C4FD6F.5F42470D.16E13E53.IP) (Ping timeout)
[15:56:01] *** Quits: dylukes (dylukes@moz-B5418F79.hsd1.pa.comcast.net) (Quit: ["Textual IRC Client: www.textualapp.com"])
[15:56:30] *** Joins: berak (chatzilla@B8C4FD6F.5F42470D.16E13E53.IP)
[15:58:21] *** Joins: graydon (graydon@3853DDD.39EEDBB3.D758B1AA.IP)
[15:58:21] *** ChanServ sets mode: +qo graydon graydon
[15:58:38] *** Joins: devinus (devinus@moz-B4AF84BC.ptr.us.xo.net)
[15:58:50] *** Joins: KindOne (KindOne@moz-3E4620C6.dynamic.ip.windstream.net)
[15:59:00] <strcat> graydon: btw:
[15:59:02] <strcat> 'If the unnamed_addr attribute is given, the address is know to not be significant and two identical functions can be merged.'
[15:59:31] <graydon> the address of the function?
[15:59:34] <strcat> clang puts it on constructors/destructors
[15:59:37] <graydon> aha
[15:59:40] <strcat> graydon: yeah since you can compare addresses of function ptrs
[15:59:44] *** Joins: azita (Azita@2557E599.66715431.D25A875A.IP)
[15:59:45] <graydon> right, sure
[15:59:45] *** Joins: pnkfelix1 (pnkfelix@moz-801E009D.vlan502.asr1.cdg2.gblx.net)
[15:59:49] <graydon> put it on all the glue :)
[15:59:59] <graydon> _lots_ of those are bit-identical
[16:00:09] *** Quits: pnkfelix|rcirc (pnkfelix@moz-801E009D.vlan502.asr1.cdg2.gblx.net) (Ping timeout)
[16:00:11] *** Quits: pnkfelix1 (pnkfelix@moz-801E009D.vlan502.asr1.cdg2.gblx.net) (Max SendQ exceeded)
[16:00:22] *** Quits: pnkfelix (pnkfelix@moz-801E009D.vlan502.asr1.cdg2.gblx.net) (Ping timeout)
[16:00:48] <strcat> graydon: sadly one of the things not in the C ABI so I guess I'll have to make a wrapper first
[16:00:52] <strcat> C API*
[16:01:05] *** Joins: pnkfelix (pnkfelix@moz-801E009D.vlan502.asr1.cdg2.gblx.net)
[16:01:10] *** Joins: Sodel_the_V (user@moz-853663E1.va.shawcable.net)
[16:01:31] <strcat> http://llvm.org/docs/doxygen/html/classllvm_1_1GlobalValue.html#a91ebd7b5d66cc73396c43f4c056050d6 this thing
[16:01:40] <strcat> err, I guess they don't have anchors
[16:01:47] <strcat> void setUnnamedAddr (bool Val)
[16:01:47] <azita> graydon: Vidyo is still having trouble.  Make sure you call CYA
[16:02:06] * strcat will figure it out
[16:02:20] <azita> pnkfelix, nmatsakis ^^
[16:02:50] <graydon> azita: all 3 of us are in CYA
[16:03:42] *** Joins: xazax (xazax@moz-D7592A2A.csoma.elte.hu)
[16:03:45] *** Joins: tjc (tjc@moz-E0677B46.vc.shawcable.net)
[16:03:46] *** Quits: cowboyd (cowboyd@1D8844A7.1B729417.CEE440B6.IP) (Client exited)
[16:03:46] *** ChanServ sets mode: +o tjc
[16:03:55] <strcat> hmm
[16:04:06] <strcat> we don't seem to have *any* of the GlobalValue API available ;\
[16:04:12] *** Quits: TD-Linux (TD-Linux@E338EB99.2B4F0AE0.A0A36CCE.IP) (Ping timeout)
[16:04:29] <graydon> strcat: looks like .. some?
[16:04:54] <azita> wrong info AGAIN guys.. it's 2C CYA
[16:05:06] <azita> we're just getting people out of the room to start the meeting
[16:05:41] <strcat> graydon: ah I guess the C API just isn't as strongly typed
[16:05:48] <strcat> they just use ValueRef
[16:05:56] *** Joins: steven_is_false (user@moz-144077DE.bchsia.telus.net)
[16:06:12] <strcat> makes sense
[16:06:13] <graydon> azita: ok. that's where we were to start. going back there.
[16:06:24] <strcat> just have to figure out how to get a GlobalValue from a ValueRef...
[16:07:16] *** Joins: jclements (jclements@2557E599.66715431.D25A875A.IP)
[16:07:46] *** Quits: berak (chatzilla@B8C4FD6F.5F42470D.16E13E53.IP) (Ping timeout)
[16:08:04] <strcat> graydon: heh they use 'unwrap' as a naming convention too ;p
[16:08:08] <graydon> https://etherpad.mozilla.org/Meeting-weekly-2013-05-28
[16:08:19] *** Joins: TD-Linux (TD-Linux@E338EB99.2B4F0AE0.A0A36CCE.IP)
[16:08:28] *** Joins: berak (chatzilla@B8C4FD6F.5F42470D.16E13E53.IP)
[16:10:02] *** Quits: mulander (uid1766@moz-D8B63698.irccloud.com) (Client exited)
[16:10:02] *** Quits: wycats_ (uid79@moz-D8B63698.irccloud.com) (Client exited)
[16:10:02] *** Quits: chadz (uid979@moz-D8B63698.irccloud.com) (Input/output error)
[16:10:02] *** Quits: jihyun (uid7128@moz-D8B63698.irccloud.com) (Input/output error)
[16:10:02] *** Quits: geomyidae__ (uid214@moz-D8B63698.irccloud.com) (Broken pipe)
[16:10:05] *** Quits: sawrubh (uid6719@moz-C944F5EC.irccloud.com) (Client exited)
[16:10:05] *** Quits: wilfred (uid159@moz-C944F5EC.irccloud.com) (Input/output error)
[16:10:05] *** Quits: gmcabrita (uid4474@moz-C944F5EC.irccloud.com) (Input/output error)
[16:10:22] *** Quits: jack (jack@moz-B9D40F4B.hfc.comcastbusiness.net) (Ping timeout)
[16:10:24] *** Quits: eholk (eholk@moz-6546E880.uconnect.utah.edu) (Quit: eholk)
[16:10:26] *** Joins: jack (jack@moz-9CE00FC0.holiday-inn-express.mozilla.hq)
[16:12:46] *** Joins: igl (igl@moz-469BCB2E.adsl.alicedsl.de)
[16:13:18] *** Quits: igl1 (igl@moz-F0BA6E1F.adsl.alicedsl.de) (Ping timeout)
[16:13:26] <jensnockert> nmatsakis: Managed to write a wrapper around it all in a nice way, thanks <3
[16:13:36] <nmatsakis> jensnockert: np
[16:13:46] *** Quits: berak (chatzilla@B8C4FD6F.5F42470D.16E13E53.IP) (Ping timeout)
[16:14:07] *** Joins: brson (brson@2557E599.66715431.D25A875A.IP)
[16:14:07] *** ChanServ sets mode: +o brson
[16:14:29] *** Joins: berak (chatzilla@B8C4FD6F.5F42470D.16E13E53.IP)
[16:16:40] <strcat> rusti: true as int
[16:16:41] -rusti- 1
[16:16:56] *** Joins: Guest_ (textual@BBE7C46A.B4F11D08.8612FA94.IP)
[16:18:22] *** Joins: steve (steve@moz-5EF6C37C.socal.res.rr.com)
[16:18:26] *** Quits: jack (jack@moz-9CE00FC0.holiday-inn-express.mozilla.hq) (Quit: Leaving.)
[16:18:27] *** steve is now known as steveklabnik
[16:19:34] *** Joins: pcwalton (pcwalton@2557E599.66715431.D25A875A.IP)
[16:19:34] *** ChanServ sets mode: +o pcwalton
[16:19:52] *** Joins: anshin (nbs@CD85F10D.F21429E2.354459FA.IP)
[16:21:55] *** Joins: eholk (eholk@moz-6546E880.uconnect.utah.edu)
[16:23:50] *** Quits: berak (chatzilla@B8C4FD6F.5F42470D.16E13E53.IP) (Ping timeout)
[16:24:29] *** Joins: berak (chatzilla@B8C4FD6F.5F42470D.16E13E53.IP)
[16:25:24] <strcat> nmatsakis: btw's LLVM's understanding of NoAlias (which noalias uses) is 2 pointers that are either non-aliasing or both read-only
[16:26:04] <strcat> so they are actually allowed to alias even if you say "noalias" if neither of them is used for writes or can observe writes through the other
[16:26:29] *** Joins: lmandel (lmandel@FE1F74.86ED00A7.971E19F6.IP)
[16:27:40] *** Joins: wilsonk-laptop (kvirc@moz-39EFBFC2.cg.shawcable.net)
[16:27:52] *** Quits: berak (chatzilla@B8C4FD6F.5F42470D.16E13E53.IP) (Ping timeout)
[16:28:11] *** Quits: wilsonk|2 (kvirc@moz-39EFBFC2.cg.shawcable.net) (Ping timeout)
[16:28:29] *** Joins: berak (chatzilla@B8C4FD6F.5F42470D.16E13E53.IP)
[16:29:01] *** Joins: brendan (brendaneic@2557E599.66715431.D25A875A.IP)
[16:30:25] *** Quits: devinus (devinus@moz-B4AF84BC.ptr.us.xo.net) (Quit: Computer has gone to sleep.)
[16:33:03] *** Joins: michaelgreene (michael@DA820AA2.17CD9887.F12515B4.IP)
[16:33:56] <strcat> rusti: let mut x = 5; let y = &mut x; let z = &const x;
[16:34:29] <strcat> rusti: let mut x = 5; let y = &mut x; let z = &const x; *y = 10; *z
[16:34:30] -rusti- 10
[16:35:47] *** Joins: Palmik (palmik@moz-DADC71F0.pks.muni.cz)
[16:36:31] <strcat> rusti: let x = @mut 5; let y = &mut *x; *y = 10; x
[16:36:32] -rusti- @10
[16:36:42] <strcat> hm
[16:36:43] <nef> so i know that the whole libuv/net stack is very volatile as-is, but is tcp::listen() expected to work on windows?
[16:37:36] <nef> win7 64bit, listen() never returns here, nor is establish_cb ever called
[16:38:07] *** Quits: rust-buildbot (rust-build@505BFA3.C3CCCE8C.D25A875A.IP) (Ping timeout)
[16:38:07] *** Quits: pyrac (pyrac@9F71F32A.73C89388.AD05C589.IP) (Ping timeout)
[16:38:32] <bstrie> nef: brson is the only one likely to know the state of tcp
[16:42:51] <nef> brson: https://gist.github.com/andor44/5664141 listen() here never returns on windows, i'll try it on linux a bit later, can you take a look at it?
[16:43:26] <nmatsakis> strcat: sure, we just have to be sure that &const/@mut and &mut are considered as possibly aliasing
[16:45:12] <nmatsakis> strcat: if you have a fn(noalias a: &,noalias b: &mut,c: &const) , does this imply any aliasing relationship between a/c and b/c?
[16:45:20] *** Joins: Azdle (Azdle@moz-B334B496.hfc.comcastbusiness.net)
[16:45:24] <nmatsakis> strcat: I...sort of presume not.
[16:45:52] <strcat> nmatsakis: I'm pretty sure it's wrong to do it the way we are atm
[16:46:07] <strcat> I think if there are &const or @mut in parameters, it has to not do that
[16:46:11] *** Quits: anshin (nbs@CD85F10D.F21429E2.354459FA.IP) (Quit: leaving)
[16:46:13] *** Joins: wycats_ (uid79@moz-C944F5EC.irccloud.com)
[16:46:49] <nmatsakis> strcat: ok, well, that's the question to figure out. there is also some concern about closure upvars. 
[16:47:05] <nmatsakis> strcat: we may have to only do this for fn items, or perhaps gather some more data about when we can
[16:47:18] <strcat> nmatsakis: the &const has a dependency on the &mut but the &mut doesn't have a dependency on the &const
[16:47:22] <nmatsakis> strcat: (the changes I have in mind for how borrowck handles closures would probably give us the info we need, I think)
[16:47:26] *** Quits: brendan (brendaneic@2557E599.66715431.D25A875A.IP) (Quit: brendan)
[16:47:29] <strcat> but I think that means we have to not use noalias
[16:47:37] <strcat> and anyway there are non-Const objects
[16:47:43] <nmatsakis> strcat: I don't know what it means for a to hvae a dependency on b
[16:47:57] <strcat> nmatsakis: meaning if you change b, a has to refetch
[16:47:59] <Azdle> I'm just starting to learn rust and I'm trying to understand the difference between copy and .clone(). For instance in this code: https://gist.github.com/grahamking/5470333 which method would be better? They both seem to work.
[16:48:32] *** Joins: doener (doener@moz-121949B3.unitymediagroup.de)
[16:48:43] <nmatsakis> strcat: I see. we want &const to depend on &mut then. other way around doesn't matter, because you will never &const content---always the aliases are read-only
[16:49:01] <bstrie> Azdle: it's... sort of up in the air at this point. use copy whereever you want a copy, clone only if you need to for some reason
[16:49:04] <nmatsakis> strcat: same holds for @mut, if an @mut alias exists, you still can't *write* to it
[16:49:08] <strcat> nmatsakis: yeah the 'noalias' parameter tag is just very coarse so we have to check the other params
[16:49:32] <Azdle> bstrie: Mmkay, Thanks
[16:49:42] <strcat> nmatsakis: so what's the concern with closures? that they can capture @mut?
[16:54:09] *** Quits: Guest_ (textual@BBE7C46A.B4F11D08.8612FA94.IP) (Quit: My MacBook Pro has gone to sleep. ZZZzzz)
[16:55:54] *** Joins: jack (jack@2557E599.66715431.D25A875A.IP)
[16:56:25] *** Joins: Jeaye (Jeaye@moz-FD505E54.hsd1.ca.comcast.net)
[16:57:28] *** Joins: wilfred (uid159@moz-C944F5EC.irccloud.com)
[16:57:36] *** Quits: wilsonk-laptop (kvirc@moz-39EFBFC2.cg.shawcable.net) (Quit: KVIrc 4.0.4 Insomnia http://www.kvirc.net/)
[16:58:16] <Luqman> nmatsakis: ping
[17:00:24] *** Joins: geomyidae__ (uid214@moz-C944F5EC.irccloud.com)
[17:01:27] <nmatsakis> graydon: regarding using too much memory, do you have ideas why that is, or is it just general "too much"
[17:01:41] <nmatsakis> graydon: I was wondering if we'd examined the size of our AST nodes etc, I think we have a lot of typed inlined where we might want pointers
[17:02:04] *** Joins: pnkfelix1 (pnkfelix@moz-801E009D.vlan502.asr1.cdg2.gblx.net)
[17:02:08] <graydon> nmatsakis: I have a certain amount of info on the matter..
[17:02:14] <nmatsakis> Luqman: pong
[17:02:21] <graydon> the peak is definitely LLVM-induced, so it's "we're generating too much code / using LLVM inefficiently"
[17:02:37] <nmatsakis> strcat: lemme think, I just have a memory in my head that sometimes reads can occur via closure upvars, but that was an old thought and may not apply, particularly when I fix closures and borrowck
[17:02:43] <graydon> like the LLVM-phase peak is 1.5x - 2x the pre-LLVM phase peak
[17:02:46] <strcat> nmatsakis: I'll just send a pull to revert noalias on &mut for now, and we can approach it again with &const/@mut in mind
[17:02:48] *** Quits: pnkfelix (pnkfelix@moz-801E009D.vlan502.asr1.cdg2.gblx.net) (Ping timeout)
[17:02:59] <nmatsakis> strcat: ok.
[17:03:37] *** pnkfelix1 is now known as pnkfelix
[17:03:52] <graydon> but we still retain a substantial (many hundreds of megs) segment immediately after the first peak, most of which is (I think) un-collected AST
[17:04:01] <graydon> which is weird, now that I say it. I wonder why
[17:05:04] <Luqman> nmatsakis: i'm stumped with how changing passing self to always ByRef is breaking various tests
[17:05:10] <Luqman> am i missing something https://github.com/luqmana/rust/commit/f0f251e9fa901e53aa974d4fa7267f27c4c055fe ?
[17:05:18] *** Quits: tjc (tjc@moz-E0677B46.vc.shawcable.net) (Ping timeout)
[17:06:07] <nmatsakis> Luqman: which tests are failing?
[17:07:38] *** Quits: jensnockert (jensnocker@moz-8BE55278.customer.t3.se) (Input/output error)
[17:08:41] *** Joins: thomaslee (thomaslee@moz-6C3931E3.static.twtelecom.net)
[17:08:57] <strcat> nmatsakis: https://github.com/mozilla/rust/pull/6786 r?
[17:08:59] *** Joins: tjc (tjc@moz-E0677B46.vc.shawcable.net)
[17:08:59] *** ChanServ sets mode: +o tjc
[17:09:04] *** Quits: jack (jack@2557E599.66715431.D25A875A.IP) (Quit: Leaving.)
[17:09:14] *** Quits: sk (sk@EA324BFE.54A580E3.78DD174B.IP) (Quit: Leaving)
[17:09:18] <Luqman> nmatsakis: extra::dlist::test_dlist_each_node is one
[17:10:21] <nmatsakis> strcat: r+, though I'm not sure if the code is wrong
[17:10:31] <strcat> nmatsakis: well, I think it is ;p
[17:10:43] <strcat> better safe than sorry
[17:10:43] <nmatsakis> strcat: ok :) I will read into LLVM's rules more closely
[17:10:46] <nmatsakis> definitely.
[17:11:55] *** Joins: devinus (devinus@moz-B4AF84BC.ptr.us.xo.net)
[17:11:56] *** Quits: judder (maradukewa@385DDD8F.206937E4.78E362FE.IP) (Connection reset by peer)
[17:12:08] *** Joins: bnicholson (bnicholson@2557E599.66715431.D25A875A.IP)
[17:12:16] <strcat> nmatsakis: an actual TBAA pass would be passed 2 ptrs and you'd be able to say NoAlias as long as one wasn't @mut or &const
[17:12:30] <strcat> I think noalias on a parameter means it can't alias any of the other params though
[17:12:31] <nmatsakis> Luqman: guess I have to check out your branch, hard to say
[17:12:54] <strcat> their wording is very lawyer-y ;p
[17:12:59] *** Joins: ghrust (ghrust@moz-4EF5B6E5.rs.github.com)
[17:12:59] <ghrust> 01[13rust01] 15bors pushed 0 new commits to 06auto: 02http://git.io/Jer7vQ
[17:12:59] *** Parts: ghrust (ghrust@moz-4EF5B6E5.rs.github.com) ()
[17:13:24] <nmatsakis> strcat: yeah, I think you are corect.
[17:13:25] <cmr> nmatsakis: still having trouble with windows
[17:13:33] <nmatsakis> strcat: I was re-reading the language and also re-reading how `restrict` is defined in c++
[17:13:37] <nmatsakis> strcat: er, in C
[17:13:41] <Luqman> nmatsakis: sure, i'll investigate some more as well. my branch is 'bare-self'
[17:13:42] <nmatsakis> strcat: probably we want our own pass
[17:13:46] <nmatsakis> cmr: yes
[17:13:53] *** Quits: devinus (devinus@moz-B4AF84BC.ptr.us.xo.net) (Quit: Computer has gone to sleep.)
[17:13:54] <nmatsakis> cmr: any advice?
[17:13:55] <cmr> nmatsakis: have you tried using gdb?
[17:14:20] <nmatsakis> cmr: yes, that's what I'm doing right now, I stll don't get a stack trace, but I was trying to just stepi through the program :)
[17:14:27] <nmatsakis> cmr: hoping the crash occurs...you know, early
[17:14:35] <cmr> ah, darn
[17:14:39] <nmatsakis> cmr: so far it doesn't seem quite early enough
[17:14:49] *** Quits: tjc (tjc@moz-E0677B46.vc.shawcable.net) (Ping timeout)
[17:14:55] <cmr> nmatsakis: I'll take a look at it when I get home
[17:15:17] <cmr> nmatsakis: you don't even get symbol names? weird :\
[17:15:22] *** Quits: doomlord (doomlod@moz-A9E19E41.range86-140.btcentralplus.com) (Connection reset by peer)
[17:15:23] *** Quits: doomlord_ (walter@moz-A9E19E41.range86-140.btcentralplus.com) (Connection reset by peer)
[17:15:34] *** Joins: dherman (dherman@moz-6CA476B1.hsd1.ca.comcast.net)
[17:15:34] *** ChanServ sets mode: +o dherman
[17:15:45] <nmatsakis> cmr: yeah, it's weird, maybe i'm not building with the right settings?
[17:15:51] <nmatsakis> pcwalton: feel up to r? https://github.com/mozilla/rust/pull/6784
[17:15:58] *** Joins: doomlord (doomlod@moz-A9E19E41.range86-140.btcentralplus.com)
[17:16:01] <nmatsakis> pcwalton: it's a step towards better moves, I figured you'd be interested :)
[17:16:53] <strcat> nmatsakis: is &const non-Const?
[17:16:59] <strcat> I assume so
[17:17:04] *** Joins: devinus (devinus@moz-B4AF84BC.ptr.us.xo.net)
[17:17:06] <nmatsakis> strcat: yes.
[17:17:09] <nmatsakis> strcat: ironically :)
[17:18:57] *** Quits: dcamp (dcamp@moz-930D5B64.hsd1.wa.comcast.net) (Quit: Linkinus - http://linkinus.com)
[17:19:19] *** Joins: chadz (uid979@moz-A588D045.irccloud.com)
[17:19:39] <strcat> nmatsakis: anyway I care about the alias analysis stuff so I'll probably figure it out soon ;p
[17:19:49] <strcat> the hard part will be auditing for things that need to be marked non-Const
[17:20:06] <strcat> and then we could start marking some & as NoAlias, since they imply a freeze
[17:20:19] *** Joins: tjc (tjc@moz-E0677B46.vc.shawcable.net)
[17:20:19] *** ChanServ sets mode: +o tjc
[17:20:26] <strcat> anyway I'm sure there's a *lot* of code doing that...
[17:22:02] <strcat> first an attempt at making the glue code merge :)
[17:22:04] *** Joins: pnkfelix|rcirc (pnkfelix@moz-801E009D.vlan502.asr1.cdg2.gblx.net)
[17:22:32] *** Joins: jack (jack@2557E599.66715431.D25A875A.IP)
[17:22:57] *** Joins: brendan (brendaneic@2557E599.66715431.D25A875A.IP)
[17:22:58] <nmatsakis> strcat: I am as usual very busy with 101 things, so I suspect you'll get there first, but please do keep me abreast
[17:23:32] <nmatsakis> strcat: what would be best, I think, is if you can actually write up some docs regarding the LLVM settings we use and their implications, as best you can
[17:24:21] <strcat> nmatsakis: yeah, I think it would be nice to make a stub alias analysis pass just responding MayAlias, and then write a bunch of docs there + start working towards real analysis
[17:24:32] *** Joins: cdidd (cdidd@moz-C14ABA98.broadband.corbina.ru)
[17:24:32] <strcat> we could start with easy things like ~ and @ being NoAlias
[17:24:34] *** Quits: tjc (tjc@moz-E0677B46.vc.shawcable.net) (Quit: Places to go, people to annoy)
[17:24:51] *** Parts: berak (chatzilla@B8C4FD6F.5F42470D.16E13E53.IP) ()
[17:24:53] <strcat> mostly just have to figure out LLVM's API.
[17:24:58] <strcat> I have a feeling the C API is going to be lacking
[17:25:29] *** Joins: MaikKlein (maik@moz-F9DF85DA.dip0.t-ipconnect.de)
[17:25:51] *** Joins: mulander (uid1766@moz-C944F5EC.irccloud.com)
[17:26:11] <nmatsakis> strcat: probably. it's ok to have a C++ module, I imagine.
[17:27:15] <strcat> nmatsakis: I think what you have to do is output metadata for yourself and then respond based on that, so maybe it would be little snippets of C++ anyway
[17:27:42] <strcat> it would just have to output "&mut", "~", "@", etc.
[17:27:58] *** Joins: SiegeLord (sl@moz-CAF07B4C.hsd1.ma.comcast.net)
[17:28:07] <nmatsakis> strcat: right, that makes sense
[17:28:15] <nmatsakis> strcat: we could maybe use the address space stuff on pointers,
[17:28:25] <nmatsakis> strcat: but it might be nicer if we left that alone
[17:29:07] *** Joins: blitter (blitter@moz-E761A52F.dyn.centurytel.net)
[17:29:24] *** Quits: devinus (devinus@moz-B4AF84BC.ptr.us.xo.net) (Quit: Computer has gone to sleep.)
[17:29:28] *** Joins: devinus (devinus@moz-B4AF84BC.ptr.us.xo.net)
[17:29:41] <bstrie> strcat: http://blog.llvm.org/2013/05/llvm-33-vectorization-improvements.html
[17:30:01] <strcat> bstrie: yep we have it already :)
[17:30:12] <bstrie> we're already vectorizing?
[17:30:19] <strcat> bstrie: on x86_64
[17:30:24] <bstrie> super great
[17:30:25] *** Quits: CarpNet (ac@moz-FD24B77.sohonet.co.uk) (Quit: Leaving)
[17:30:35] <strcat> bstrie: it's not very good because we have no AA though.
[17:30:42] <strcat> although C hardly has any either
[17:30:55] <strcat> they just have type punning rules (store of a double can't alias with a float ptr, etc.)
[17:31:28] <strcat> bstrie: you'll notice they use restrict in one of those snippets
[17:31:30] *** Quits: Sodel_the_V (user@moz-853663E1.va.shawcable.net) (Quit: Eaten by a grue)
[17:31:39] <strcat> void foo(int * restrict A, int * restrict B) {
[17:31:58] <strcat> otherwise stores to A can change B and you can't vectorize
[17:32:08] <bstrie> ah yes
[17:32:19] <strcat> so yeah, that's why figuring out noalias on &mut properly will be nice
[17:32:42] *** Joins: pyrac (pyrac@moz-285C535.w92-156.abo.wanadoo.fr)
[17:33:05] <strcat> if b is & and a is &mut, we know stores to a don't touch b
[17:33:18] <strcat> I forgot about &const and @mut before though.
[17:33:18] *** Quits: echristo (echristo@moz-CE1AD9FD.hsd1.ca.comcast.net) (Quit: echristo)
[17:33:19] *** Quits: jaen (jaen@moz-E0979827.copit.pl) (Quit: WeeChat 0.4.1)
[17:33:32] *** Joins: jaen (jaen@moz-1EC8DB57.play-internet.pl)
[17:33:57] <bstrie> isn't &const going away?
[17:34:11] <MaikKlein> do you mean this by vectorizing ? http://en.wikipedia.org/wiki/Vectorization_%28parallel_computing%29
[17:34:14] *** Quits: aruniiird (arun@92D70115.B332A52C.E3D0A897.IP) (Ping timeout)
[17:34:16] <strcat> bstrie: dunno but @mut can do the same thing, I didn't realize before
[17:34:44] <strcat> MaikKlein: yes
[17:34:56] <strcat> converting scalar code to SIMD (SSE, AVX, NEON)
[17:35:09] <bstrie> though I think LLVM only does loop vectorization?
[17:35:21] <strcat> bstrie: it knows how to do vectorization for non-loops now
[17:35:24] <strcat> it's just not enabled by defau;lt
[17:35:26] <strcat> yet
[17:35:32] <strcat> they want to enable it for 3.4 by default
[17:35:34] <bstrie> neat
[17:35:47] *** Joins: hjr3 (hradtke@374E545A.3A8E9B0C.F9D9C60E.IP)
[17:36:08] <bstrie> maybe by 3.4 we'll finally be using the upstream release :)
[17:36:10] *** Joins: Blei (philipp@moz-96D25F7A.cust.bluewin.ch)
[17:36:15] *** Joins: threecreepio (jdp@moz-DB2D70E9.cust.bredbandsbolaget.se)
[17:36:24] *** Quits: dherman (dherman@moz-6CA476B1.hsd1.ca.comcast.net) (Quit: dherman)
[17:37:39] <bstrie> strcat: do you know of any good resources for learning any assembly language, so that I can be less useless?
[17:37:49] *** Joins: dylukes (dylukes@moz-B5418F79.hsd1.pa.comcast.net)
[17:38:12] *** Joins: judder (maradukewa@385DDD8F.206937E4.78E362FE.IP)
[17:38:23] <cmr> bstrie: read disassemblies of simple C programs
[17:38:33] <cmr> And get a good ISA manual :)
[17:38:56] <strcat> bstrie: you really just have to learn what the common instructions do, there are too many x86 instructions to actually understand compiler output without a reference ;p
[17:39:19] <bstrie> that's sort of what I figured
[17:39:58] <cmr> also intel syntax ftw
[17:41:41] <sp3d> ^^^
[17:43:26] *** Joins: carllerche (carllerche@6B070D22.7E6A0813.1428D117.IP)
[17:44:01] *** Quits: bytbox (s@moz-D83E9B31.wireless.umd.edu) (Input/output error)
[17:44:14] <strcat> graydon: well they are successfully marked with unnamed_addr now ;p
[17:44:21] <strcat> I guess we need to be running that merge pass for it to have any effect...
[17:44:48] *** Joins: rust-buildbot (rust-build@505BFA3.C3CCCE8C.D25A875A.IP)
[17:45:02] *** Joins: veddan (viktor@moz-C79BC80B.csbnet.se)
[17:45:25] *** Joins: bytbox (s@moz-D83E9B31.wireless.umd.edu)
[17:45:36] <graydon> aatch: how's that llvm-pass-management bug going?
[17:45:40] *** Parts: steven_is_false (user@moz-144077DE.bchsia.telus.net) (ERC Version 5.3 (IRC client for Emacs))
[17:46:42] *** Quits: Jesse (jruderman@moz-537BCF9.hsd1.ca.comcast.net) (Quit: Jesse)
[17:47:04] *** Joins: gmcabrita (uid4474@moz-D8B63698.irccloud.com)
[17:47:08] <steveklabnik> cmr: i _think_ i've pulled in your 'for rubyists' changes and deployed them
[17:48:02] <steveklabnik> <3 again for that
[17:48:05] <cmr> np
[17:48:08] <cmr> I'm not done yet
[17:48:22] <steveklabnik> yeah, i saw it was 'initial'
[17:48:22] <strcat> graydon: yeah it has basically no effect.
[17:48:25] <cmr> but I sprained my right hand over the weakend :(
[17:48:29] <strcat> alone at least
[17:48:30] <steveklabnik> oh no :(
[17:48:47] <graydon> strcat: even with merging?
[17:48:54] <strcat> graydon: haven't tried yet
[17:49:13] <strcat> just without it has no effect for sure
[17:49:15] *** Quits: MaikKlein (maik@moz-F9DF85DA.dip0.t-ipconnect.de) (Ping timeout)
[17:49:17] *** Quits: robertknight (robertknig@moz-54528EE0.wby.mendeley.com) (Quit: Computer has gone to sleep.)
[17:49:43] <strcat> graydon: first I need some example code where it actually outputs duplicate glues
[17:50:29] <cmr> steveklabnik: I want to add syntax highlighting at least for html, but couldn't figure out how to get dexy to play nice. pygments has rust support.
[17:50:41] <graydon> strcat: any of our libraries have lots of glues that are identical
[17:51:56] <sfackler> i'm taking a look at https://github.com/mozilla/rust/issues/6399 . the way that I'd like to fix it is by returning a borrowed mutable reference to the TaskBuilder with the same lifetime as self. unfortunately, this doesn't seem to work when self is a borrowed reference to a temporary (i.e. the common use case) since the returned pointer's lifetime ends as the function returns. is there a good way of fixing that? here's a minimal-ish ex
[17:52:17] *** Joins: tikue (tkuehn@2557E599.66715431.D25A875A.IP)
[17:52:33] *** Joins: bjz (brendanzab@B398BE78.F804C29E.D35A31DF.IP)
[17:53:03] *** Joins: mschifer (Adium@2557E599.66715431.D25A875A.IP)
[17:53:11] <sfackler> the TaskBuilder code used to be returning a modified copy of self by value, which seems kind of unpleasant
[17:53:29] *** Joins: Guest_ (textual@BBE7C46A.B4F11D08.8612FA94.IP)
[17:54:01] *** Joins: sk (sk@61A494B3.BA40E8A.AAC02D62.IP)
[17:54:10] *** Quits: tikue (tkuehn@2557E599.66715431.D25A875A.IP) (Quit: tikue)
[17:54:12] <nmatsakis> sfackler: there is no good way to fix that right now.
[17:54:25] <nmatsakis> sfackler: this is issue #3511
[17:56:02] <sfackler> thanks
[17:56:37] *** Quits: Yurume (yurume@AC58A8CE.8A059B47.E313B915.IP) (Ping timeout)
[17:57:44] *** Joins: tikue (tkuehn@2557E599.66715431.D25A875A.IP)
[17:58:16] *** Quits: vmx (vmx@moz-6A65996C.pools.arcor-ip.net) (Quit: Leaving)
[17:58:24] <strcat> graydon: I'm not sure how to pass an arbitrary optimization pass to llc :(
[17:58:29] <strcat> clang has -mllvm -foo
[17:58:53] <graydon> aatch: has a patch in the queue that enables this, or the beginnings of it
[17:58:58] *** Quits: yong (chatzilla@74DA0C97.4E87ADC2.263D9828.IP) (Ping timeout)
[17:59:02] *** Joins: ghrust (ghrust@moz-4EF5B6E5.rs.github.com)
[17:59:02] <ghrust> 01[13rust01] 15alexcrichton 04force-pushed 06try from 141ab23ea to 145a8bc6d: 02http://git.io/k471pw
[17:59:03] <ghrust> 13rust/06try 14e6f991e 15Brian Anderson: Try to fix a periodic windows build failure due to broken rwildcard macro
[17:59:03] <ghrust> 13rust/06try 1403990ff 15Alex Crichton: Start building a multithreaded rust
[17:59:03] <ghrust> 13rust/06try 14b9ab41e 15Brian Anderson: Upgrade LLVM
[17:59:04] *** Parts: ghrust (ghrust@moz-4EF5B6E5.rs.github.com) ()
[18:01:20] *** Joins: yong (chatzilla@74DA0C97.4E87ADC2.263D9828.IP)
[18:02:36] <strcat> graydon: okay it works :)
[18:02:42] *** Joins: sawrubh (uid6719@moz-D8B63698.irccloud.com)
[18:02:54] <graydon> strcat: do tell!
[18:02:55] <strcat> graydon: with -mergefunc, it merges them without unnamed_addr but leaves stubs
[18:03:00] <strcat> this just gets rid of the stubs
[18:03:13] <strcat> not that big a deal I guess, but it was easy ;p
[18:03:18] <graydon> how much merging are we talking? glue fns are a substantial amount of code
[18:03:36] <strcat> graydon: seems to catch any *exact* duplicates
[18:03:42] <strcat> if the instructions are exactly the same
[18:04:05] <strcat> if I make a tiny change it doesn't merge so it doesn't appear to be very clever
[18:04:20] <strcat> anyway I'm just compiling the .bc with clang ;p
[18:04:36] *** Joins: jihyun (uid7128@moz-D8B63698.irccloud.com)
[18:04:41] *** Quits: Mowah (Mowah@moz-B9D06A8A.cust.bredbandsbolaget.se) (Ping timeout)
[18:05:29] <strcat> graydon: https://github.com/mozilla/rust/pull/6787 r?
[18:06:36] *** Quits: brendan (brendaneic@2557E599.66715431.D25A875A.IP) (Quit: brendan)
[18:06:55] *** Joins: jensnockert (jensnocker@moz-8BE55278.customer.t3.se)
[18:07:33] <graydon> strcat: sure
[18:07:53] <strcat> anyway sad that it doesn't do anything without that pass
[18:07:59] <graydon> I'm just excited at seeing you and aatch poking at the LLVM optimizers, never mind me :)
[18:09:02] <strcat> graydon: well, I'm going to make another attempt at getting noalias on &mut params too
[18:09:22] *** Quits: kesserich (Mibbit@moz-7ABC9BDB.hsd1.pa.comcast.net) (Quit: http://www.mibbit.com ajax IRC Client)
[18:09:24] <strcat> because it's really awesome to have it vectorize stuff.
[18:09:37] <strcat> and maybe a really basic TBAA pass...
[18:10:39] <cmr> rusti: let x = 4; 1 < x < 6
[18:10:42] -rusti- more than 5 lines of output, pastebinned: http://sprunge.us/BTTf
[18:10:54] <cmr> it'd be neat if that worked :)
[18:11:46] <cmr> (just sugar for 1 < x && x < 6)
[18:11:47] <strcat> it works in python ;p
[18:14:26] *** Quits: jack (jack@2557E599.66715431.D25A875A.IP) (Quit: Leaving.)
[18:14:38] *** Joins: jack (jack@2557E599.66715431.D25A875A.IP)
[18:14:45] *** Quits: BizarreCake (BizarreCak@32C9829A.151E84E7.561471F8.IP) (Ping timeout)
[18:14:57] *** Quits: jack (jack@2557E599.66715431.D25A875A.IP) (Quit: Leaving.)
[18:15:35] *** Quits: tikue (tkuehn@2557E599.66715431.D25A875A.IP) (Quit: tikue)
[18:17:47] *** Quits: brson (brson@2557E599.66715431.D25A875A.IP) (Ping timeout)
[18:17:56] *** Joins: jack (jack@2557E599.66715431.D25A875A.IP)
[18:18:25] <sp3d> "1 < x < 6" < "[1, x, 6].sorted()", imo
[18:18:36] *** Joins: echristo (echristo@D423593A.D6CCE4AE.77834EAA.IP)
[18:19:15] *** Joins: tikue (tkuehn@2557E599.66715431.D25A875A.IP)
[18:19:25] *** Joins: brson (brson@2557E599.66715431.D25A875A.IP)
[18:19:25] *** ChanServ sets mode: +o brson
[18:19:46] <cmr> the second isn't obvious to me
[18:20:19] <cmr> plus more to  type
[18:20:26] *** Quits: tikue (tkuehn@2557E599.66715431.D25A875A.IP) (Quit: tikue)
[18:20:27] <sp3d> the former seems confusing because I start thinking about order of evaluation and return types from the subexpressions
[18:20:52] *** Quits: lucian (lucian@6B2B4644.4304AE1E.CE5E78F6.IP) (Ping timeout)
[18:21:45] <cmr> that's a good point, I didn't think about more complex cases
[18:22:31] <sp3d> "relation!(1 < x < 6)"?
[18:22:35] <strcat> sp3d: well python just does it piece by piece
[18:22:38] *** Quits: erickt (erickt@8C9ECD8F.3A598286.F12515B4.IP) (Quit: Leaving.)
[18:22:39] *** Joins: tikue (tkuehn@2557E599.66715431.D25A875A.IP)
[18:22:39] <strcat> 3 < 4 < 5 < 6 < 7
[18:22:41] <strcat> true
[18:22:48] <strcat> 3 < 4 < 5 < 6 < 7 < 7
[18:22:50] <strcat> false
[18:22:52] <strcat> 3 < 4 < 5 < 6 < 7 <= 7
[18:22:54] <strcat> true
[18:23:12] <strcat> it just breaks 3 < 4 < 5 < 6 into 3 < 4 && 4 < 5 && 5 < 6
[18:23:45] *** Joins: Jesse (jruderman@2557E599.66715431.D25A875A.IP)
[18:23:51] <sp3d> the problem is that in python "(3 < 4) > 2" != "3 < 4 < 2"
[18:23:56] <sp3d> er
[18:24:03] <sp3d> "3 < 4 > 2"
[18:24:20] <rpearl> why is that a problem
[18:24:43] <rpearl> the problem in python is that you can put unreadable binops in there instead
[18:24:51] <rpearl> like 'in'
[18:24:53] <sp3d> it seems confusing that neither possible parenthesization matches the unparenthesized expression
[18:25:20] <rpearl> it doesn't really, though, they are syntactically different and you should read them as such
[18:25:31] *** Joins: infynyxx (infynyxx@moz-E95B370B.nyc.res.rr.com)
[18:25:33] <sp3d> yeah, that just seems really weird coming from a C background
[18:25:52] <sp3d> having it be in a relation! would make it clear that regular evaluation rules do not apply
[18:26:00] <strcat> yeah but... C
[18:26:04] <rpearl> it turns out that having constructs that don't exist in c makes your language not like c.
[18:26:12] <rpearl> i fail to see why this is a problem
[18:26:18] <strcat> 5["foobar"] == 'r'
[18:26:24] *** Quits: dylukes (dylukes@moz-B5418F79.hsd1.pa.comcast.net) (Quit: ["Textual IRC Client: www.textualapp.com"])
[18:26:38] <rpearl> strcat: http://www.endofunctor.org/~rpearl/sizeof.c
[18:26:44] <strcat> (**********************************************puts)("foo") // valid C
[18:26:58] <sp3d> yes, C is a silly language
[18:27:31] <sp3d> my point is more that I don't get how to conceptualize the < operator given that syntax--is it binary or just a token, and if binary, how do you know its return type?
[18:27:40] *** Quits: eholk (eholk@moz-6546E880.uconnect.utah.edu) (Quit: eholk)
[18:28:17] <sp3d> if just a token, that sounds like the prime use case for a macro to me
[18:28:45] *** Quits: Blub\w (wry@moz-577D9ED6.wireless.dyn.drei.com) (Ping timeout)
[18:28:47] <rpearl> i mean, it is adjacent pairs, with && for each pair
[18:29:19] <rpearl> a op1 b op2 c op3 d ... translates to a op1 b && b op2 c && c op3 d && ...
[18:29:42] *** Joins: cowboyd (cowboyd@moz-1BD02A1E.sw.biz.rr.com)
[18:29:42] <rpearl> this is consistent with one such pair, clearly
[18:30:34] <sp3d> so it's a token used as shorthand syntax, not an operator that maps directly to a trait method, no?
[18:33:26] <rpearl> yes, it is shorthand? building shorthand into a language is a reasonable thing to do if it makes things easier to read.
[18:33:28] *** Quits: veddan (viktor@moz-C79BC80B.csbnet.se) (Quit: Konversation terminated!)
[18:34:43] *** Quits: Dimension (Mibbit@moz-4CCD79C5.dsl.dynamic.simnet.is) (Quit: http://www.mibbit.com ajax IRC Client)
[18:35:02] *** Joins: erickt (erickt@8C9ECD8F.3A598286.F12515B4.IP)
[18:36:06] <rpearl> sp3d: i haven't been watching rust recently, but isn't there `do' shorthand, still? and omitting empty argument lists? and `match` on structs re-using the field name?
[18:36:25] <rpearl> all those things are syntactic sugar, eliding unecessary details
[18:36:27] <sp3d> do is a syntax extension like I was proposing
[18:36:48] <sp3d> i.e. an explicit context where tokens are parsed by a function you can look up
[18:38:14] *** Quits: heftig (heftig@moz-2AFE8E9D.dip0.t-ipconnect.de) (No route to host)
[18:38:27] *** Joins: heftig (heftig@moz-2AFE8E9D.dip0.t-ipconnect.de)
[18:38:49] *** Joins: eholk (eholk@moz-6546E880.uconnect.utah.edu)
[18:39:58] *** Joins: ghrust (ghrust@moz-4EF5B6E5.rs.github.com)
[18:39:58] <ghrust> 01[13rust01] 15bors merged 06auto into 06incoming: 02http://git.io/lJSYiQ
[18:39:58] *** Parts: ghrust (ghrust@moz-4EF5B6E5.rs.github.com) ()
[18:40:36] *** Quits: fabiand (fabiand@moz-357F09F3.adsl.alicedsl.de) (Quit: Verlassend)
[18:41:04] <rpearl> the "function" in this case is the language documentation, and the construct is built into the language. `a < b < c` *always* being shorthand for `a < b && b < c` is a perfectly reasonable way of doing things, even if it doesn't match c code.
[18:41:18] *** Quits: vcl (chatzilla@741D4FEA.76F9E272.DA40C4B3.IP) (Quit: ChatZilla 0.9.90 [Firefox 21.0/20130511120803])
[18:41:30] *** Joins: vcl (chatzilla@741D4FEA.76F9E272.DA40C4B3.IP)
[18:41:40] <eevee> seems nice for matching too
[18:42:21] <ion> (a + b == c) == (a + b && b == c)? :-P
[18:42:52] <strcat> C++ lets you do
[18:42:58] <strcat> a > b ? c : d = 10;
[18:42:59] *** Joins: ghrust (ghrust@moz-4EF5B6E5.rs.github.com)
[18:42:59] <ghrust> 01[13rust01] 15bors pushed 6 new commits to 06auto: 02http://git.io/xdVJNA
[18:42:59] <ghrust> 13rust/06auto 1404e8935 15Niko Matsakis: Move checking for moves and initialization of local variables and patterns into...
[18:42:59] <ghrust> 13rust/06auto 141c53190 15Niko Matsakis: Update docs on the formal basis of the borrow checker.
[18:42:59] <ghrust> 13rust/06auto 147dbf1b9 15Niko Matsakis: Reconcile docs and code, adding examples and adding RESTR_CLAIM
[18:42:59] <strcat> ;p
[18:43:01] *** Parts: ghrust (ghrust@moz-4EF5B6E5.rs.github.com) ()
[18:44:32] <jensnockert> I cannot really find any documentation on it, but an unsafe block doesn't introduce a new scope, right?
[18:44:52] <bstrie> I don't think so, you can start unsafe blocks in really wacky places iirc
[18:45:02] <strcat> jensnockert: they're a block
[18:45:13] <strcat> {} is a scope, so unsafe is
[18:45:29] <jensnockert> strcat: But that doesn't make sense with the warnings that I am getting /o\
[18:45:32] <bstrie> rusti: let a = unsafe { 2 }; a
[18:45:33] -rusti- more than 5 lines of output, pastebinned: http://sprunge.us/bGHS
[18:45:57] <bstrie> I guess that's actually just following the usual block rules
[18:45:57] *** Joins: Jesin (Jessin_@moz-48B48C95.eecs.lehigh.edu)
[18:45:58] *** Joins: Blub\w (wry@moz-577D9ED6.wireless.dyn.drei.com)
[18:45:58] *** Quits: pnkfelix|rcirc (pnkfelix@moz-801E009D.vlan502.asr1.cdg2.gblx.net) (Quit: rcirc on GNU Emacs 24.2.1)
[18:46:02] *** Joins: aruniiird (arun@moz-3DB73AA5.azulsystems.com)
[18:46:06] <jensnockert> bstrie: I guess that as well.
[18:46:15] <bstrie> jensnockert: then we both guess it.
[18:46:15] *** Quits: pnkfelix (pnkfelix@moz-801E009D.vlan502.asr1.cdg2.gblx.net) (Quit: Leaving.)
[18:46:33] <jensnockert> bstrie: Now I am just trying to find out what those are :S
[18:46:34] <bstrie> rusti: let a = { 2 }; a
[18:46:35] -rusti- 2
[18:46:47] <bstrie> jensnockert: anywhere where an expression is legal
[18:47:01] <bstrie> rusti: let a = { 2; }; a
[18:47:45] <bstrie> rusti: let a = { 2; }; 1
[18:47:46] -rusti- 1
[18:47:50] <bstrie> rusti: let a = { 2; }; ()
[18:47:54] <bstrie> weird
[18:48:08] <jensnockert> bstrie: I'll send you a gist instead.
[18:48:09] <jensnockert> https://gist.github.com/JensNockert/bc35af2bf3753138c757
[18:48:27] <jensnockert> Gives the warning "cl.rs/cl.rs:20:8: 20:13 warning: value assigned to `error` is never read [-W dead-assignment (default)]"
[18:48:51] *** Quits: Guest_ (textual@BBE7C46A.B4F11D08.8612FA94.IP) (Quit: My MacBook Pro has gone to sleep. ZZZzzz)
[18:49:36] <jensnockert> Also, UNSAFE ALL THE THINGS!!11!!
[18:52:32] <acrichto> brson: ping
[18:54:37] <jensnockert> bstrie: Hm if I do two-step compilation, first expanding the macros, then compiling that code, then it does not emit any warnings.
[18:54:44] <kimundi> bstrie: 'weird' as in 'why doesn't it print the ()'?
[18:54:46] *** Joins: dherman (dherman@moz-6CA476B1.hsd1.ca.comcast.net)
[18:54:46] *** ChanServ sets mode: +o dherman
[18:54:54] <bstrie> kimundi: I figured it out
[18:55:01] *** Joins: tjc (tjc@A5087023.2354C43D.D8E68FF6.IP)
[18:55:01] *** ChanServ sets mode: +o tjc
[18:55:14] <bstrie> jensnockert: that sonds bad
[18:55:28] *** Joins: brendan (brendaneic@2557E599.66715431.D25A875A.IP)
[18:55:37] <jensnockert> bstrie: It sure sounds like a bug imho.
[18:55:44] <nmatsakis> jensnockert: that looks like a bug to me
[18:55:55] *** Quits: erickt (erickt@8C9ECD8F.3A598286.F12515B4.IP) (Quit: Leaving.)
[18:55:59] <nmatsakis> jensnockert: ah, wait,
[18:56:07] <nmatsakis> jensnockert: try renaming error to something else?
[18:56:37] <nmatsakis> jensnockert: shouldn't be, but maybe error is one of the built-in debug level constants?
[18:56:46] <nmatsakis> jensnockert: in which I think it should be giving you a different error, but anyhow.
[18:56:51] <jensnockert> nmatsakis: I'll try.
[18:57:05] <jensnockert> nmatsakis: Nope, err gives the same issue.
[18:57:19] <bstrie> jensnockert: what if you change the unsafe blocks to look like https://gist.github.com/bstrie/ee037de957f3eb47628a
[18:57:46] <bstrie> jensnockert: presuming here that the only unsafe bit is the clGetPlatformIDs call
[18:58:24] <graydon> huh
[18:58:31] <graydon> we should really drop the AST before we run LLVM
[18:58:39] <graydon> so weird. why don't we do that?
[18:58:43] * graydon scratches head
[18:58:57] <nmatsakis> jensnockert: ok, sounds like an error in the liveness checking code. (also, to solve the unsafe business, why not just make one big unsafe block? or declare the whole fn unsafe?)
[18:59:17] <jensnockert> nmatsakis: Because I generate the code with nested macros.
[18:59:19] <nmatsakis> jensnockert: can you try making a smaller, standalone example...
[18:59:29] <nmatsakis> jensnockert: oh, wait, sorry, I didn't read enough backscroll
[18:59:35] <jensnockert> nmatsakis: I'll try to make a minimal piece, without OpenCL.
[18:59:41] <nmatsakis> jensnockert: do the error occurs when you compile the expanded code directly?
[18:59:47] <nmatsakis> jensnockert: or only when the code is generated via macro
[18:59:47] <jensnockert> nmatsakis: Nope.
[18:59:52] <jensnockert> nmatsakis: Only via macro.
[19:00:00] <nmatsakis> jensnockert: aaaaaaah. I see now. OK, so, first, the good news is: not my bug
[19:00:06] <nmatsakis> jensnockert: good news for me anyhow ;)
[19:00:18] <brson> acrichto: pong
[19:00:41] <nmatsakis> jensnockert: but secondly, where is the macro? did you define it with macro!? I'd bet money that it's duplicating the AST somehow or something like that
[19:00:46] <acrichto> brson: have you ever seen a failure like http://buildbot.rust-lang.org/builders/try-win/builds/519/steps/compile/logs/stdio when dealing with llvm before?
[19:00:52] <nmatsakis> jensnockert: that is, that the macro code is doin git, not necessarily your code.
[19:01:08] <acrichto> brson: I figured it'd be a good idea to push the llvm-upgrade branch through try to see what happens
[19:01:10] <jensnockert> nmatsakis: I can send you the entire file! Wait a bit.
[19:01:20] <acrichto> brson: try-linux passed just fine
[19:01:54] <jensnockert> nmatsakis: https://gist.github.com/JensNockert/5665203
[19:02:04] <jensnockert> nmatsakis: But I'll try to make a more minimal example.
[19:02:17] *** Quits: eholk (eholk@moz-6546E880.uconnect.utah.edu) (Quit: eholk)
[19:02:46] *** Quits: xazax (xazax@moz-D7592A2A.csoma.elte.hu) (Quit: Ex-Chat)
[19:03:29] <brson> acrichto: no, I haven't seen that. maybe something broke in the split stack code for windows
[19:03:32] <brson> acrichto: bbl lunch
[19:05:54] *** Quits: infynyxx (infynyxx@moz-E95B370B.nyc.res.rr.com) (Client exited)
[19:06:38] *** Quits: pyrac (pyrac@moz-285C535.w92-156.abo.wanadoo.fr) (Quit: pyrac)
[19:06:42] *** Quits: hjr3 (hradtke@374E545A.3A8E9B0C.F9D9C60E.IP) (Quit: My MacBook has gone to sleep. ZZZzzz)
[19:06:42] *** Quits: brendan (brendaneic@2557E599.66715431.D25A875A.IP) (Quit: brendan)
[19:06:45] <nef> brson: i just tested that listen() code on linux, it does call the establish callback, so something's wrong in the windows build
[19:07:11] <bstrie> what linux distros do the bots use?
[19:07:19] <strcat> ubuntu lts
[19:07:23] <bstrie> has anyone tried compiling on wheezy?
[19:10:30] <nmatsakis> graydon: any tips for getting a backtrace on windows?
[19:12:25] <jld> ...oh wow. Today I learn that Ada makes you opt in to being able to alias aggregates' fields. This may inform my feelings about Rust enums.
[19:13:05] <bstrie> jld: can you elaborate?
[19:13:33] <jld> In C and Rust you can do &foo.bar and get a pointer to a field within a struct.
[19:13:47] *** Parts: evan (evan@moz-F60DCF69.us-west-1.compute.amazonaws.com) ()
[19:13:59] <bstrie> what does that have to do with enums, though?
[19:13:59] <jld> That's something that can be done for any field, so all fields have to be represented the same way as a standalone value of that type.
[19:14:26] *** Quits: jack (jack@2557E599.66715431.D25A875A.IP) (Quit: Leaving.)
[19:14:37] <jld> There are some things that are harder to do with Rust enums, like using tagged pointers, because of that.
[19:15:27] *** Quits: eatkinson (eatkinson@2557E599.66715431.D25A875A.IP) (Quit: eatkinson)
[19:15:46] *** Quits: tikue (tkuehn@2557E599.66715431.D25A875A.IP) (Quit: tikue)
[19:16:18] <bstrie> jld: I was under the impression that the reason for rust's struct layout was specifically for C compatibility, rather than as a result of aliasing rules
[19:17:01] *** Joins: bent (chatzilla@moz-932324BF.hsd1.ca.comcast.net)
[19:19:17] *** Joins: erickt (erickt@8C9ECD8F.3A598286.F12515B4.IP)
[19:20:52] <jensnockert> nmatsakis, bstrie: Didn't manage to make it smaller than https://gist.github.com/JensNockert/ab64d115023bf9d20261
[19:21:07] *** Joins: brendan (brendaneic@2557E599.66715431.D25A875A.IP)
[19:21:50] <nmatsakis> jld: that is interesting. makes sense.
[19:22:20] *** Quits: tjc (tjc@A5087023.2354C43D.D8E68FF6.IP) (Quit: zzzzzzzzzz)
[19:22:46] *** Quits: Blei (philipp@moz-96D25F7A.cust.bluewin.ch) (Quit: WeeChat 0.4.1)
[19:24:05] *** Quits: cjh (chellmuth@moz-45C21C42.compute-1.amazonaws.com) (Ping timeout)
[19:24:19] *** Joins: cjh (chellmuth@moz-45C21C42.compute-1.amazonaws.com)
[19:26:56] *** Joins: tjc (tjc@A5087023.2354C43D.D8E68FF6.IP)
[19:26:56] *** ChanServ sets mode: +o tjc
[19:28:03] *** Joins: pyrac (pyrac@moz-285C535.w92-156.abo.wanadoo.fr)
[19:30:30] <jensnockert> nmatsakis: Made a bug, https://github.com/mozilla/rust/issues/6788
[19:31:21] *** Quits: victorporof (victorporo@DE2B5DEF.67CDC207.79933D60.IP) (Quit: victorporof)
[19:35:19] <Luqman> compiletest/compiletest.rc:1:0: 1:0 error: can't find crate for `core`
[19:35:32] <Luqman> makefiles weren't updated it seems
[19:35:50] <tjc> Luqman: I think I had to add a #[no_core] in compiletest.rc or something like that
[19:35:51] *** Joins: jack (jack@2557E599.66715431.D25A875A.IP)
[19:36:04] <nmatsakis> jensnockert: ok.
[19:37:01] <jensnockert> nmatsakis: Thanks for all the help.
[19:38:25] <jld> nmatsakis: I seem to recall that graydon knows Ada, so I suspect this was thought about at some point.
[19:38:47] <nmatsakis> he's an admirer, to be sure.
[19:40:04] *** Joins: ghrust (ghrust@moz-4EF5B6E5.rs.github.com)
[19:40:04] <ghrust> 01[13rust01] 15bors 04force-pushed 06auto from 1403b2574 to 14833ed21: 02http://git.io/N3iJvQ
[19:40:04] *** Parts: ghrust (ghrust@moz-4EF5B6E5.rs.github.com) ()
[19:40:06] *** Joins: ghrust (ghrust@moz-4EF5B6E5.rs.github.com)
[19:40:06] <ghrust> 01[13rust01] 15bors pushed 3 new commits to 06auto: 02http://git.io/RqdjTQ
[19:40:06] <ghrust> 13rust/06auto 148749cb5 15Alex Crichton: Fix 'make check-stage1-std' by correcting dependencies
[19:40:06] <ghrust> 13rust/06auto 143649c93 15Alex Crichton: Silence various warnings throughout test modules
[19:40:07] <ghrust> 13rust/06auto 142cdfa2e 15bors: auto merge of #6774 : alexcrichton/rust/silence-warnings, r=graydon...
[19:40:09] *** Parts: ghrust (ghrust@moz-4EF5B6E5.rs.github.com) ()
[19:40:36] <bstrie> amused that servo is 57% python and 35% rust
[19:40:40] *** Quits: geomyidae (geomyidae@DD6F7E3A.21468E9A.30200F38.IP) (Ping timeout)
[19:40:48] *** Quits: devinus (devinus@moz-B4AF84BC.ptr.us.xo.net) (Quit: Computer has gone to sleep.)
[19:40:57] <benh> too many servo developers can't do without x < y < z syntax, evidently
[19:41:23] <jaen> 57% is a lot of snake percentage
[19:41:36] <bstrie> benh: they're so desperate that they've actually embedded cpython just so that they can drop into literal python to do their less-than comparisons
[19:41:58] *** Joins: fabiand (fabiand@moz-357F09F3.adsl.alicedsl.de)
[19:42:13] *** Quits: erickt (erickt@8C9ECD8F.3A598286.F12515B4.IP) (Quit: Leaving.)
[19:42:58] <Luqman> tjc: yep, that works
[19:43:18] <tjc> Luqman: cool
[19:43:29] *** Joins: mzabaluev (mzabaluev@moz-91FFD755.dhcp.inet.fi)
[19:44:24] *** Joins: Guest_ (textual@BBE7C46A.B4F11D08.8612FA94.IP)
[19:46:48] *** Joins: erickt (erickt@8C9ECD8F.3A598286.F12515B4.IP)
[19:47:08] *** Quits: Guest_ (textual@BBE7C46A.B4F11D08.8612FA94.IP) (Quit: My MacBook Pro has gone to sleep. ZZZzzz)
[19:49:01] *** Joins: geomyidae (geomyidae@DD6F7E3A.21468E9A.30200F38.IP)
[19:52:37] *** Quits: aruniiird (arun@moz-3DB73AA5.azulsystems.com) (Ping timeout)
[19:52:43] *** Quits: geomyidae (geomyidae@DD6F7E3A.21468E9A.30200F38.IP) (Ping timeout)
[19:52:44] *** Joins: devinus (devinus@moz-B4AF84BC.ptr.us.xo.net)
[19:53:11] *** Quits: rusti (rusti@moz-54F7FD49.cpe.net.cable.rogers.com) (Client exited)
[19:55:14] *** Joins: heftig_ (heftig@moz-D04F4D4A.dip0.t-ipconnect.de)
[19:55:18] *** Quits: heftig (heftig@moz-2AFE8E9D.dip0.t-ipconnect.de) (Ping timeout)
[19:56:11] <strcat> graydon: btw a snapshot would be nice to lower memory usage, among other things
[19:56:27] <strcat> since that's quite a bit fixed now
[19:56:38] *** Quits: brendan (brendaneic@2557E599.66715431.D25A875A.IP) (Quit: brendan)
[19:56:56] <graydon> true. I wanted to run one more experiment in that regard
[19:57:06] <graydon> dropping the crate AST before running LLVM
[19:57:10] <graydon> which we, amazingly, do not do presently
[19:57:35] <cmr> nmatsakis, what branch are you using that you want to debug?
[19:57:37] *** Joins: rusti (rusti@moz-54F7FD49.cpe.net.cable.rogers.com)
[19:57:41] <strcat> rusti: do you work
[19:57:41] -rusti- foo.rs:8:16: 8:20 error: expected `{` but found `work`
[19:57:41] -rusti- foo.rs:8          do you work
[19:57:41] -rusti-                          ^~~~
[19:57:46] <strcat> rusti: 5 + 5
[19:57:47] -rusti- 10
[19:58:07] * strcat remembers what a PITA format strings in C are
[19:58:17] * jensnockert hugs strcat.
[19:58:36] <strcat> http://ix.io/5PF/diff yay. horrors
[19:58:44] <strcat> PATH_MAX is deprecated anyway but I needed an arbitrary buffer size
[19:59:16] <nmatsakis> cmr: in my repo, it's issue-3678-wrappers-be-gone-2
[19:59:20] <cmr> alright
[19:59:24] <nmatsakis> cmr: my github account is nikomatsakis
[19:59:24] <benh> pft, g_strdup_printf
[19:59:38] <strcat> benh: but evil allocations.
[19:59:44] <nmatsakis> cmr: https://github.com/nikomatsakis/rust/tree/issue-3678-wrappers-be-gone-2
[19:59:49] <strcat> ;p
[20:00:00] <strcat> benh: it's linux-only so I could just use asprintf
[20:00:18] <benh> if only there was alloca_printf
[20:01:07] *** Joins: geomyidae (geomyidae@DD6F7E3A.21468E9A.30200F38.IP)
[20:01:10] <strcat> benh: if only C++ stringstreams weren't hell
[20:01:22] <benh> but they're full of evil allocations too!
[20:01:28] <strcat> benh: yes, even more
[20:01:32] <strcat> but they don't have to be...
[20:01:39] * strcat hopes rust gets fmt! to a Writer and that str becomes a writer
[20:01:52] <strcat> you could just reuse a ~str as a buffer, it won't realloc once it gets a nice capacity
[20:02:19] <strcat> stringstreams are awful because the only way to get the string out is a copy 
[20:03:07] *** Joins: eholk (eholk@moz-6546E880.uconnect.utah.edu)
[20:03:12] <heftig_> meh, i dislike the std/extra rename
[20:03:33] <strcat> heftig_: afaik extra will move out to external repos eventually
[20:03:57] <strcat> the parts we don't want to move to the new libstd
[20:03:59] <heftig_> so nothing in the compiler depends on it?
[20:04:21] <strcat> heftig_: it does actually
[20:04:34] <heftig_> but will that dep be broken with the move out?
[20:04:48] <strcat> heftig_: dunno, but we do have deps on stuff in external repos (llvm and libuv)
[20:05:43] *** heftig_ is now known as heftig
[20:05:49] *** Quits: geomyidae (geomyidae@DD6F7E3A.21468E9A.30200F38.IP) (Ping timeout)
[20:06:34] <heftig> i like that utf-8 is the only valid string encoding, though
[20:06:51] <heftig> ruby went the other way when they introduced encodings, and it's hell
[20:07:12] <cmr> yeah, encoding strings is hard
[20:07:28] <cmr> or, rather, string encoding
[20:11:58] *** Joins: aruniiird (arun@84E199D6.DCDBCF8E.83D0DF30.IP)
[20:12:02] <bstrie> rather, human language :)
[20:12:17] <cmr> yeah
[20:12:22] <cmr> we should just get rid of the humans
[20:12:26] <cmr> it'd make programming so much easier
[20:12:33] <kimundi> rusti: "ascii ftw!".to_ascii()
[20:12:34] *** Joins: snadon (chatzilla@moz-3BC727E8.mc.videotron.ca)
[20:12:34] -rusti- &[{chr: 97}, {chr: 115}, {chr: 99}, {chr: 105}, {chr: 105}, {chr: 32}, {chr: 102}, {chr: 116}, {chr: 119}, {chr: 33}]
[20:13:12] <bstrie> why are those structs rather than just ints?
[20:13:33] <bstrie> or u8s, in the case of ascii...
[20:13:34] <kimundi> they are struct { priv chr: u8 }
[20:13:46] <kimundi> struct Ascii { priv chr: u8 }
[20:14:04] *** Joins: geomyidae (geomyidae@DD6F7E3A.21468E9A.30200F38.IP)
[20:14:05] <bstrie> I guess so that you could impl things on the type?
[20:14:19] *** Joins: Dimension (Mibbit@moz-4CCD79C5.dsl.dynamic.simnet.is)
[20:14:21] <kimundi> With the invariant that the top bit is never set.
[20:14:22] <bstrie> still not sure why it isn't just `struct Ascii(u8)`
[20:14:25] <strcat> kimundi: I dunno how we're going to deal with \0 though
[20:14:31] <strcat> with str
[20:14:51] <kimundi> strcat: In what regard?
[20:15:00] <strcat> for conversions to/from
[20:15:04] <strcat> without allocations
[20:15:05] <strcat> oh
[20:15:07] <strcat> I guess you just pop/push
[20:15:11] <strcat> not that bad
[20:15:57] <strcat> meh the whole \0 thing is a mess
[20:16:22] <engla> rusti: "lve".to_ascii()
[20:16:23] -rusti- rust: task failed at 'assertion failed: self.is_ascii()', /build/rust-incoming-git/src/rust/src/libstd/str/ascii.rs:97
[20:16:23] -rusti- rust: domain main @0x169c1b0 root task failed
[20:16:25] <strcat> I'd be happier if we didn't have it... ;p
[20:16:38] <kimundi> well, &str -> &[Ascii] drops the trailing 0 of the &str, and &[Ascii] -> &str requires an additional trailing 0 in the &[Ascii]
[20:17:02] <strcat> kimundi: makes sense
[20:17:11] <strcat> what about ~[Ascii] <-> ~str?
[20:17:36] *** Quits: fabiand (fabiand@moz-357F09F3.adsl.alicedsl.de) (Quit: Verlassend)
[20:17:39] <cmr> I thought &str wasn't nul terminated?
[20:17:48] <cmr> doesn't as_c_str add a nul?
[20:17:49] <kimundi> rusti: ['f'.to_ascii(), 'o'.to_ascii(), 0u8.to_ascii()]
[20:17:50] -rusti- [{chr: 102}, {chr: 111}, {chr: 0}]
[20:17:58] <kimundi> rusti: ['f'.to_ascii(), 'o'.to_ascii(), 0u8.to_ascii()].to_str()
[20:17:59] -rusti- ~"[\'f\', \'o\', \'\x00\']"
[20:18:04] <strcat> cmr: sometimes.
[20:18:06] <strcat> it's a mess.
[20:18:15] <strcat> &'static str is always nul terminated
[20:18:16] <kimundi> rusti: ['f'.to_ascii(), 'o'.to_ascii(), 0u8.to_ascii()].to_str_ascii()
[20:18:17] -rusti- ~"fo\x00"
[20:18:31] <bstrie> strcat: we're already suggesting that all C apis use .as_c_str 
[20:18:38] *** Joins: vcl_ (chatzilla@741D4FEA.76F9E272.DA40C4B3.IP)
[20:18:40] <bstrie> so maybe the trailing null isn't necessary
[20:18:42] *** Joins: Axord (xord@moz-C3CCF156.lsanca.dsl-w.verizon.net)
[20:18:44] *** Joins: tikue (tkuehn@2557E599.66715431.D25A875A.IP)
[20:18:45] *** Quits: geomyidae (geomyidae@DD6F7E3A.21468E9A.30200F38.IP) (Ping timeout)
[20:18:46] *** Joins: eatkinson (eatkinson@2557E599.66715431.D25A875A.IP)
[20:19:05] <kimundi> bstrie: As_c_str uses the trailing null though :)
[20:19:16] <bstrie> right, the point is to guarantee the trailing null
[20:19:23] <bstrie> so why does it always need to be present?
[20:19:24] <strcat> rusti: static foobar: &'static str = "foobar"; unsafe { let (x, y): (*u8, uint) = cast::transmute(foobar); (x, y) }
[20:19:25] -rusti- ((0x40c220 as *()), 7)
[20:19:53] *** Quits: vcl (chatzilla@741D4FEA.76F9E272.DA40C4B3.IP) (Ping timeout)
[20:20:04] *** vcl_ is now known as vcl
[20:21:02] *** Quits: ksev (DrunkenPan@745B767B.989A61DC.CA5B6332.IP) (Ping timeout)
[20:21:44] <kimundi> bstrie: Well the way it is done right now is for speed reasons. you pass a &str to as_c_str, and it checks the hidden trailing byte on wether it needs to allocate a copy or just use it directly.
[20:22:05] *** Joins: ghrust (ghrust@moz-4EF5B6E5.rs.github.com)
[20:22:06] <ghrust> 01[13rust01] 15bors 04force-pushed 06auto from 142cdfa2e to 14833ed21: 02http://git.io/N3iJvQ
[20:22:06] *** Parts: ghrust (ghrust@moz-4EF5B6E5.rs.github.com) ()
[20:22:08] *** Joins: ghrust (ghrust@moz-4EF5B6E5.rs.github.com)
[20:22:08] <ghrust> 01[13rust01] 15bors pushed 3 new commits to 06auto: 02http://git.io/yP8hfw
[20:22:08] <ghrust> 13rust/06auto 14317248f 15Daniel Micay: expose the ability to set unnamed_addr
[20:22:08] <ghrust> 13rust/06auto 147c3c8ae 15Daniel Micay: mark glue functions with unnamed_addr
[20:22:08] <ghrust> 13rust/06auto 149a1b0d1 15bors: auto merge of #6787 : thestinger/rust/unnamed_addr, r=graydon...
[20:22:10] *** Parts: ghrust (ghrust@moz-4EF5B6E5.rs.github.com) ()
[20:22:36] <strcat> kimundi: it's kind of silly though
[20:22:41] <strcat> good C APIs use a buf + len
[20:23:13] <kimundi> strcat: Well this api does too. It's a safety precaution against bad apis :P
[20:23:28] *** Joins: ksev (DrunkenPan@745B767B.989A61DC.CA5B6332.IP)
[20:23:42] <strcat> it's not really a safety precaution at all
[20:24:03] <bstrie> int luaL_loadstring (lua_State *L, const char *s);  <-- bad api?
[20:24:08] <strcat> it's just an optimization for libraries using C strings at the expense of everything else
[20:24:17] <strcat> bstrie: if there isn't an alternative with a buf and len
[20:24:23] <strcat> providing both is fine...
[20:25:12] <bstrie> int lua_load (lua_State *L, lua_Reader reader, void *data, const char *chunkname);  <-- good api?
[20:25:24] *** Quits: Jesin (Jessin_@moz-48B48C95.eecs.lehigh.edu) (Quit: Leaving)
[20:25:24] *** Quits: cowboyd (cowboyd@moz-1BD02A1E.sw.biz.rr.com) (Client exited)
[20:25:29] <kimundi> It could be fixed by having as_c_str take a ~str or maybe &~str. Those would be guaranteed to be null terminated
[20:26:02] <bstrie> loadstring is apparently a special case of load, but I still don't see a length field anywhere
[20:26:38] <kimundi> Problem is the rustic way is to use slices as much as possible, so you might not have access to the ~str at the point of the call even though you might have a &str that spans the whole string
[20:27:03] *** Joins: geomyidae (geomyidae@DD6F7E3A.21468E9A.30200F38.IP)
[20:27:17] <strcat> kimundi: it could be fixed by requiring a copy when you call a C API expecting a nul-terminated buffer
[20:27:21] *** Joins: Mowah (Mowah@moz-B9D06A8A.cust.bredbandsbolaget.se)
[20:27:25] <bstrie> ah I see, lua_reader is typedef const char * (*lua_Reader) (lua_State *L, void *data, size_t *size);
[20:27:53] <kimundi> strcat: But that's kinde performance critical, no?
[20:27:54] <cmr> I feel like an extra byte isn't that much to pay compared to copies
[20:28:11] <strcat> cmr: you don't pay any copies with good libraries offering both
[20:28:40] <strcat> is there a performance critical, useful library that does require them for something other than stuff like filenames?
[20:29:14] <kimundi> I mean having a additional u8 for each ~str doesn't sound too bad, but having to always copy for ffi even though it wouldn't be necessary in theory...
[20:29:36] <strcat> plenty of C APIs have unsigned char *buf, size_t len
[20:30:14] *** Quits: jack (jack@2557E599.66715431.D25A875A.IP) (Quit: Leaving.)
[20:30:26] <strcat> you already have to re-encode to utf-16 for most FFI on windows
[20:30:42] <bstrie> strcat: I have a PR for as_c_str which is blocked on these sorts of API issues, would you like to bring this whole thing up on the mailing list?
[20:30:42] <kimundi> true...
[20:30:46] *** Quits: geomyidae (geomyidae@DD6F7E3A.21468E9A.30200F38.IP) (Ping timeout)
[20:30:48] <engla> another Lua issue is that lua strings are arbitrary byte strings. Any wrapper will need to safely handle that
[20:30:59] *** Joins: jack (jack@2557E599.66715431.D25A875A.IP)
[20:31:13] <benh> unsafely cast your slice to a *mut u8, write a '\0' at the end and restore the original later ;)
[20:31:23] <kimundi> engla: lua strings just need to be handled as [u8] then
[20:31:25] <engla> lua strings can also contain \0
[20:31:36] *** Quits: Palmik (palmik@moz-DADC71F0.pks.muni.cz) (Quit: Lost terminal)
[20:31:39] *** Quits: dherman (dherman@moz-6CA476B1.hsd1.ca.comcast.net) (Quit: dherman)
[20:32:06] <engla> yeah that's the safe way
[20:32:22] <acrichto> graydon: re-r+ https://github.com/mozilla/rust/pull/6774 ? I think there's actually a bug with unused imports which caused me to remove one too many
[20:32:34] *** Quits: mzabaluev (mzabaluev@moz-91FFD755.dhcp.inet.fi) (Quit:    )
[20:33:08] *** Quits: maxli (maxli@F2D29657.F60B0462.67AC9B1.IP) (Quit: Leaving.)
[20:33:22] *** Joins: cscottnet (cscott@moz-2577C94A.net)
[20:33:30] <kimundi> acrichto: afaik that's because some macro expansions expect certain things to be in scope, which the unused import checker doesn't know about.
[20:33:31] <graydon> acrichto: r=me on anything like that that, that's just trivial warning-silencing (w/o major rearrangements)
[20:33:38] *** Quits: azita (Azita@2557E599.66715431.D25A875A.IP) (Quit: azita)
[20:34:00] <brson> acrichto: ok, I'm back. what do we need to do to land llvm?
[20:34:02] <acrichto> graydon: thanks!
[20:34:16] <engla> kimundi: are you working on lua?
[20:34:26] <acrichto> kimundi: macros wreak havoc with linting in general, I haven't look into it much, this was different though sadly :(
[20:34:28] <kimundi> nope
[20:34:34] <bstrie> engla: I am
[20:34:37] *** Quits: jack (jack@2557E599.66715431.D25A875A.IP) (Quit: Leaving.)
[20:34:38] <engla> aha
[20:34:44] <acrichto> brson: I rand the llvm-upgrade branch through try and it passed on linux, but mysteriously failed on windows http://buildbot.rust-lang.org/builders/try-win/builds/519
[20:34:45] <bstrie> engla: I generated bindings to luajit2 last week
[20:35:03] <acrichto> brson: I have no access to any windows build environment, so I'm not sure I'll be able to debug much of it
[20:35:04] *** Joins: vcl_ (chatzilla@741D4FEA.76F9E272.DA40C4B3.IP)
[20:35:12] <engla> I did some experiments with lua yesterday
[20:35:14] <bstrie> engla: but I really want to find some sort of comprehensive C-api test suite that I can port to rust, to ensure things to break after I start making wrappers
[20:35:17] *** Quits: pyrac (pyrac@moz-285C535.w92-156.abo.wanadoo.fr) (Quit: pyrac)
[20:35:27] <bstrie> er, don't break
[20:35:42] <engla> bstrie: I don't know any except the LUA_APICHECK which are assertions in the LUA C code
[20:36:10] *** Quits: vcl (chatzilla@741D4FEA.76F9E272.DA40C4B3.IP) (Ping timeout)
[20:36:15] *** vcl_ is now known as vcl
[20:36:29] <engla> so you might recompile your lua library with those enabled.. I think that's imporant for any app using the C API
[20:36:44] *** Joins: vcl_ (chatzilla@741D4FEA.76F9E272.DA40C4B3.IP)
[20:37:00] *** Joins: ghrust (ghrust@moz-4EF5B6E5.rs.github.com)
[20:37:00] <ghrust> 01[13rust01] 15bors 04force-pushed 06auto from 149a1b0d1 to 14833ed21: 02http://git.io/N3iJvQ
[20:37:00] *** Parts: ghrust (ghrust@moz-4EF5B6E5.rs.github.com) ()
[20:37:03] *** Joins: ghrust (ghrust@moz-4EF5B6E5.rs.github.com)
[20:37:03] <ghrust> 01[13rust01] 15bors pushed 3 new commits to 06auto: 02http://git.io/23m17w
[20:37:03] <ghrust> 13rust/06auto 148749cb5 15Alex Crichton: Fix 'make check-stage1-std' by correcting dependencies
[20:37:03] <ghrust> 13rust/06auto 14b04c40b 15Alex Crichton: Silence various warnings throughout test modules
[20:37:04] <ghrust> 13rust/06auto 14d7e1f08 15bors: auto merge of #6774 : alexcrichton/rust/silence-warnings, r=graydon...
[20:37:05] <bstrie> engla: right now the only flag I'm passing is -fPIC, what would I need to put and where in the makefile. also remember that this is luajit
[20:37:06] *** Parts: ghrust (ghrust@moz-4EF5B6E5.rs.github.com) ()
[20:37:26] <engla> ok. I've never used luajit
[20:37:42] <bstrie> hm, I'll have to read through the makefile when I get home
[20:37:48] <engla> of course, luajit should support the same api as lua5.1 itself
[20:37:55] <engla> and ABI
[20:37:57] *** Quits: vcl (chatzilla@741D4FEA.76F9E272.DA40C4B3.IP) (Ping timeout)
[20:37:57] <bstrie> it does, yeah
[20:38:06] <bstrie> though I hear it has a few extensions?
[20:38:11] *** vcl_ is now known as vcl
[20:38:29] <engla> yeah its own ffi
[20:39:03] *** Joins: geomyidae (geomyidae@DD6F7E3A.21468E9A.30200F38.IP)
[20:39:16] *** Joins: jack (jack@2557E599.66715431.D25A875A.IP)
[20:39:29] <bblum> nmatsakis: ok, in "the case of the recurring closure", i'm confused by bullet #1 ("modify the borrow checker to...") -- is that not something it does already?
[20:39:59] <kimundi> strcat: Related to the &str null byte thing, someone really needs to gitther all the special representations of fat pointers in a module in std::unstable and make sure that all unsafe code uses that
[20:40:03] <nmatsakis> bblum: well, no.
[20:40:16] <nmatsakis> bblum: not correctly, anyhow. when the borrow checker was written,
[20:40:27] <kimundi> I wonder if a lint that warns on transmutes on fat pointer could be implemented
[20:40:29] <nmatsakis> bblum: stack closures could  only be found in argument position,
[20:40:34] <nmatsakis> bblum: and were noncopyable etc,
[20:40:40] <nmatsakis> bblum: so it treated stack closures as being part of the call
[20:40:52] <nmatsakis> bblum: that treatment has continued basically unchanged, although we added lifetimes to closures,
[20:40:54] <nmatsakis> bblum: so they are not much more flexi ble
[20:41:01] *** Joins: hjr3 (hradtke@374E545A.3A8E9B0C.F9D9C60E.IP)
[20:41:31] *** Joins: vcl_ (chatzilla@741D4FEA.76F9E272.DA40C4B3.IP)
[20:41:32] *** Quits: vcl (chatzilla@741D4FEA.76F9E272.DA40C4B3.IP) (Connection reset by peer)
[20:41:33] *** vcl_ is now known as vcl
[20:41:34] <nmatsakis> kimundi: that would be nice
[20:41:36] <bblum> so stack closures were noncopyable, but could be promoted to &fn()s, which are copyable?
[20:42:21] <nmatsakis> bblum: no, at that time, &fn was not copyable.
[20:42:36] <engla> bstrie: look into luaconf.h if it's there
[20:42:39] <nmatsakis> bblum: there were special rules in fact that prevented an instance of that type from being used except in either a call or as an argument to a function
[20:42:44] *** Quits: geomyidae (geomyidae@DD6F7E3A.21468E9A.30200F38.IP) (Ping timeout)
[20:42:45] <nmatsakis> bblum: it all predated regions, really.
[20:42:51] <bblum> huh.
[20:45:03] <bblum> so when/why did they become copyable?
[20:45:48] <bblum> it seems like the fix to the bug is just to undo that change; i'm not sure why having the borrow checker consider captured things as borrowed is relevant
[20:45:53] *** Joins: azita (Azita@2557E599.66715431.D25A875A.IP)
[20:46:09] <nmatsakis> bblum: it's insufficient by itself, you might have two closures that call each other and conflict.
[20:46:13] *** Joins: josh (josh@moz-348C4790.hsd1.mn.comcast.net)
[20:46:20] <bblum> ah.
[20:46:41] <bblum> erm... how can you get them to call each other if they're noncopyable?
[20:46:51] <nmatsakis> "let x = || ...; let y = || x()"
[20:47:00] <bblum> oh, not corecursive
[20:47:09] <nmatsakis> yes, they don't need to co-recurse necessarily.
[20:47:16] <nmatsakis> in fact you don't even *need* two closures, really.
[20:47:37] <nmatsakis> bottom line is that we have to know what the "initial state" is when the closure is called
[20:47:58] <bblum> let x = || vec.push(0); for vec.each |i| { x(); } ?
[20:48:09] <nmatsakis> right something like that. now, I think that this will get an error today,
[20:48:15] <nmatsakis> though i'm not sure.
[20:48:26] <nmatsakis> but even if it does, I think you can concoct examples that wouldn't.
[20:48:32] <cmr> rusti, let mut vec = ~[]; let x = || vec.push(0); for vec.each |i| { x(); }
[20:49:01] <nmatsakis> cmr: does it work with `,`?
[20:49:19] <cmr> oops
[20:49:23] <cmr> rusti: let mut vec = ~[]; let x = || vec.push(0); for vec.each |i| { x(); }
[20:49:27] <nmatsakis> bblum: in any case, the only "obviously sound" thing I can see is what I plan to do, which is have the creation of the closure create the borrows.
[20:49:31] <cmr> client on windows is mostly unconfigured :)
[20:49:32] <strcat> rusti: 2
[20:49:33] -rusti- 2
[20:49:41] <bblum> nmatsakis: huh, it does compile.
[20:49:43] <nmatsakis> bblum: and have the borrows then persist for the lifetime of the closure.
[20:49:59] <nmatsakis> cmr: btw did you ever make any progress on reproducing that windows failure?
[20:50:03] <bblum> it seems like an oversight that it compiles :P
[20:50:11] <cmr> nmatsakis, LLVM is building now
[20:50:32] <bblum> cmr: i think you need let x = || { vec.push(0); };
[20:50:36] *** Joins: Dimension_ (Dimension@moz-4CCD79C5.dsl.dynamic.simnet.is)
[20:50:50] <cmr> rusti: let mut vec = ~[]; let x = || { vec.push(0); }; for vec.each |i| { x(); }
[20:50:53] *** Quits: Dimension (Mibbit@moz-4CCD79C5.dsl.dynamic.simnet.is) (Quit: http://www.mibbit.com ajax IRC Client)
[20:50:58] <cmr> rusti: 5
[20:50:59] -rusti- 5
[20:51:05] <nmatsakis> bblum: well, yes. :) it is not intended that it should compile!
[20:51:05] *** Joins: geomyidae (geomyidae@DD6F7E3A.21468E9A.30200F38.IP)
[20:51:20] *** Quits: snadon (chatzilla@moz-3BC727E8.mc.videotron.ca) (Client exited)
[20:51:25] *** Quits: pcwalton (pcwalton@2557E599.66715431.D25A875A.IP) (Quit: pcwalton)
[20:51:27] <bblum> yeah
[20:51:44] <nmatsakis> bblum: but as I said, closures are not sound right now, that's why I plan to fix it. However, this particular aspect of the problem revelead here is orthogonal to the question of copyability.
[20:51:46] *** Joins: samnardoni (samnardoni@moz-ECB14881.cable.virginmedia.com)
[20:51:47] <bblum> i mean, it seems like a separate problem, more a bug than a hole in the type system
[20:51:52] <bblum> yeah
[20:52:16] *** Joins: steven_is_false (user@moz-144077DE.bchsia.telus.net)
[20:52:19] <nmatsakis> well, all formal variants of the type system have excluded closures,
[20:52:28] <nmatsakis> if you did include them, you'd naturally have to devise rules for them,
[20:52:33] <nmatsakis> if you made rules similar to what borrowck is doing today,
[20:52:35] <nmatsakis> they'd be unsound.
[20:52:39] <strcat> nmatsakis: another thing that would be nice about "overloading" for pointers would be having lint checks for other mutable managed ptr types
[20:52:53] <nmatsakis> strcat: lint checks?
[20:52:59] <strcat> nmatsakis: the freezing ones
[20:53:07] <strcat> maybe that's impossible :)
[20:53:18] <nmatsakis> strcat: oh, you mean like "best effort" static errors?
[20:53:22] <strcat> nmatsakis: yeah
[20:53:26] <nmatsakis> strcat: that should be possible.
[20:54:46] *** Quits: philix (philix@moz-8FDC6117.user.veloxzone.com.br) (Ping timeout)
[20:55:10] <cmr> nmatsakis, where/when does the failure occur? The buildbot log I saw died in stage2 libstd
[20:55:21] *** Joins: pcwalton (pcwalton@2557E599.66715431.D25A875A.IP)
[20:55:21] *** ChanServ sets mode: +o pcwalton
[20:56:33] *** Joins: philix (philix@moz-ACBA4252.user.veloxzone.com.br)
[20:57:04] <bblum> ah, the recurring closure post ends by suggesting the &own pointer idea
[20:57:14] *** Quits: Azdle (Azdle@moz-B334B496.hfc.comcastbusiness.net) (Quit: Leaving)
[20:57:50] *** Joins: brendan (brendaneic@2557E599.66715431.D25A875A.IP)
[20:58:10] *** Joins: MaikKlein (maik@moz-F9DF85DA.dip0.t-ipconnect.de)
[20:58:20] <bblum> nmatsakis: if i remember right, &own (== &noalias) would always imply (i.e., be promotable to) &mut
[20:58:53] <bstrie> strcat engla kimundi: I've sent a message concerning rust strings and null-termination/c interop to the mailing list, if you'd like to weigh in
[20:58:56] *** Quits: Jesse (jruderman@2557E599.66715431.D25A875A.IP) (Quit: Jesse)
[20:58:59] *** Quits: brendan (brendaneic@2557E599.66715431.D25A875A.IP) (Quit: brendan)
[20:59:38] *** Quits: novabyte (Instantbir@moz-3E0F9699.cable.virginmedia.com) (Input/output error)
[20:59:46] *** Quits: azita (Azita@2557E599.66715431.D25A875A.IP) (Quit: azita)
[21:00:25] *** Joins: seth (seth@moz-D840E602.dsl.static.sonic.net)
[21:00:26] <pcwalton> hmm, I think you can call cross crate private extern functions
[21:00:27] <pcwalton> grr
[21:00:36] *** Quits: devinus (devinus@moz-B4AF84BC.ptr.us.xo.net) (Quit: Computer has gone to sleep.)
[21:00:41] *** Joins: devinus (devinus@moz-B4AF84BC.ptr.us.xo.net)
[21:01:00] *** Quits: jack (jack@2557E599.66715431.D25A875A.IP) (Quit: Leaving.)
[21:01:10] <bstrie> pcwalton: "calling cross-crate private static methods" is still uncrossed-out on the deprecated features metabug, is that related?
[21:01:19] <pcwalton> that's fixed
[21:01:22] <pcwalton> I'm pretty sure
[21:01:29] <acrichto> pcwalton: I was just looking at that code I think https://github.com/mozilla/rust/blob/incoming/src/librustc/middle/privacy.rs#L385
[21:01:59] *** Quits: eatkinson (eatkinson@2557E599.66715431.D25A875A.IP) (Quit: eatkinson)
[21:02:06] <bstrie> are mutable fields gonegonegone?
[21:02:10] <pcwalton> yes
[21:02:16] *** Quits: pcwalton (pcwalton@2557E599.66715431.D25A875A.IP) (Quit: pcwalton)
[21:02:17] <bstrie> crossing it off the list
[21:02:25] *** Quits: tikue (tkuehn@2557E599.66715431.D25A875A.IP) (Quit: tikue)
[21:02:39] *** Quits: josh (josh@moz-348C4790.hsd1.mn.comcast.net) (Quit: josh)
[21:02:46] *** Joins: snadon (chatzilla@moz-3BC727E8.mc.videotron.ca)
[21:02:52] *** Joins: SimonSapin (simon@5AAE35B2.5EFFC0B8.24454B25.IP)
[21:03:05] *** Quits: vcl (chatzilla@741D4FEA.76F9E272.DA40C4B3.IP) (Ping timeout)
[21:03:09] <nmatsakis> bblum: that's right, but I don't think we plan to separate uniqueness from mutability.
[21:03:29] *** Joins: maxli (maxli@C03F2759.C70D537E.2FA4EA88.IP)
[21:03:31] *** Joins: dylukes (dylukes@moz-68BEB894.public.wayport.net)
[21:03:33] <nmatsakis> cmr: yes, I see the error there I think
[21:03:56] *** Quits: brson (brson@2557E599.66715431.D25A875A.IP) (Ping timeout)
[21:04:33] *** Joins: jack (jack@2557E599.66715431.D25A875A.IP)
[21:04:36] *** Joins: tikue (tkuehn@2557E599.66715431.D25A875A.IP)
[21:04:38] *** Joins: eatkinson (eatkinson@2557E599.66715431.D25A875A.IP)
[21:04:44] *** Joins: pcwalton (pcwalton@2557E599.66715431.D25A875A.IP)
[21:04:44] *** ChanServ sets mode: +o pcwalton
[21:04:53] *** Joins: brson (brson@2557E599.66715431.D25A875A.IP)
[21:04:53] *** ChanServ sets mode: +o brson
[21:05:01] *** Joins: azita (Azita@2557E599.66715431.D25A875A.IP)
[21:05:04] <graydon> huh
[21:05:11] *** Quits: maxli (maxli@C03F2759.C70D537E.2FA4EA88.IP) (Ping timeout)
[21:05:12] *** Joins: brendan (brendaneic@2557E599.66715431.D25A875A.IP)
[21:05:20] <graydon> dropping the AST before LLVM knocks another 400mb off peak rss
[21:05:38] <strcat> graydon: \o/
[21:05:42] <graydon> IOW it's 1.1gb down from a week ago
[21:05:51] <graydon> if only we could repeat that trick!
[21:05:59] <strcat> graydon: string interner?
[21:06:11] <strcat> is that in the gc branch?
[21:06:13] <graydon> nah, that was a red herring
[21:06:20] <strcat> aw
[21:06:23] <graydon> this is on trunk. I'll open a pull req momentarily.
[21:06:49] *** Joins: fread2282 (Mibbit@moz-CB181B42.dia.static.qwest.net)
[21:07:03] *** Joins: Jesse (jruderman@2557E599.66715431.D25A875A.IP)
[21:07:23] <bstrie> so what's the actual memory peak down to now?
[21:07:39] <kimundi> graydon: So, 32Bit crisis averted?
[21:07:43] <strcat> down from 2500MiB to like 1400MiB I guess
[21:07:53] <bstrie> so then it's just back to normal :P
[21:07:57] <strcat> kimundi: not really, it's still awful
[21:08:04] <graydon> 1331MiB
[21:08:09] <graydon> it's still awful
[21:08:18] *** Quits: Jesse (jruderman@2557E599.66715431.D25A875A.IP) (Quit: Jesse)
[21:08:22] <graydon> but _less_ awful. 32bit crisis still unfortunately present.
[21:08:24] <MaikKlein> can I enable default methods in the compiler? 
[21:08:37] <graydon> I think you need to implement a bunch to make them useful
[21:08:46] *** Quits: dylukes (dylukes@moz-68BEB894.public.wayport.net) (Quit: Computer has gone to sleep.)
[21:08:46] <graydon> but .. please do! I'd love someone to finish them
[21:09:28] <strcat> graydon: there's a horrible workaround at least
[21:09:32] *** Joins: dylukes (dylukes@moz-5EF8B0CF.hfc.comcastbusiness.net)
[21:09:35] <strcat> opt-in default methods with a dummy trait
[21:10:24] <MaikKlein> yeah I know that already, the compiler tells me -D default-methods (default) so I thought maybe I could enable it somehow
[21:10:25] <graydon> how does that work?
[21:10:29] <strcat> trait Dummy {} impl<T: Dummy> SomeTrait for T { ... }
[21:10:31] <strcat> and then
[21:10:31] *** Quits: Diablo-D3 (diablo@moz-6317EE8A.port.east.myfairpoint.net) (Ping timeout)
[21:10:32] <strcat> impl Dummy for int {}
[21:10:41] <strcat> and you get a default impl ;p
[21:10:54] <graydon> strcat: I've been trying to figure out the idiom. suppose each impl wants to override a handful of the default methods
[21:11:25] <strcat> graydon: well I don't really think you could make that hack work for that without splitting up traits
[21:11:30] <strcat> need actual default methods working
[21:11:42] <graydon> yeah
[21:14:14] <engla> strcat: what about  impl SomeTrait for &Dummy  or something like that?
[21:15:02] *** Joins: mark_edward (quassel@moz-6B90E517.rh.uchicago.edu)
[21:16:06] <strcat> engla: dunno, but that's pretty restricted
[21:17:05] <pcwalton> graydon: how low do we need to go in terms of RSS?
[21:17:14] <pcwalton> to make 32 bit work.
[21:17:16] <engla> it is
[21:17:34] <graydon> I don't know. gc branch isn't rebased.
[21:17:44] <graydon> need to merge fixes to trunk, then rebase gc branch
[21:17:48] *** Quits: dylukes (dylukes@moz-5EF8B0CF.hfc.comcastbusiness.net) (Ping timeout)
[21:17:48] <graydon> then muck with pagemap more
[21:17:51] <graydon> I suspect
[21:17:55] <graydon> I am trying, honest
[21:18:09] <pcwalton> I know :) the numbers so far have sounded great
[21:18:18] <pcwalton> 1 GB down, I'll take that
[21:19:39] *** Quits: jensnockert (jensnocker@moz-8BE55278.customer.t3.se) (Input/output error)
[21:20:00] <graydon> grr, rusti calls compile_upto with cu_everything and uses the resulting crate
[21:20:01] <graydon> dammit
[21:21:36] *** Joins: Jesse (jruderman@2557E599.66715431.D25A875A.IP)
[21:23:03] <cmr> (gdb) Cannot access memory at address 0x1234567c
[21:23:13] <cmr> That's a really improbable address
[21:23:20] <bblum> seems legit
[21:24:37] *** Quits: Ralith (ralith@moz-50F3C77.vc.shawcable.net) (Ping timeout)
[21:24:56] <bstrie> cmr: ruined by the last digit
[21:26:04] *** Joins: jensnockert (jensnocker@moz-8BE55278.customer.t3.se)
[21:27:58] *** Joins: jrfeenst (jrfeenst@moz-3265BD65.cpe.norwoodlight.com)
[21:28:17] <nmatsakis> cmr: that's the errorI get too
[21:28:24] <engla> alignment ruins it
[21:29:06] *** Joins: dylukes (dylukes@moz-5EF8B0CF.hfc.comcastbusiness.net)
[21:30:14] <cmr> nmatsakis, it would be really nice if -Z debug-info was working, but it's weird that it's not even resolving the address to a symbol
[21:31:21] <nmatsakis> cmr: I agree. must be jumping somewhere totally wrong I guess.
[21:31:36] *** Quits: samnardoni (samnardoni@moz-ECB14881.cable.virginmedia.com) (Client exited)
[21:32:57] <nmatsakis> cmr: occurs to me I should try check-stage1-rpass
[21:33:15] <nmatsakis> but that doens't seem to work for some odd reason.
[21:33:16] *** Quits: Blub\w (wry@moz-577D9ED6.wireless.dyn.drei.com) (Quit: night)
[21:33:56] *** Joins: ghrust (ghrust@moz-4EF5B6E5.rs.github.com)
[21:33:56] <ghrust> 01[13rust01] 15bors merged 06auto into 06incoming: 02http://git.io/23m17w
[21:33:56] *** Parts: ghrust (ghrust@moz-4EF5B6E5.rs.github.com) ()
[21:34:10] *** Quits: steven_is_false (user@moz-144077DE.bchsia.telus.net) (Ping timeout)
[21:34:11] *** Joins: steven_is_false (user@moz-144077DE.bchsia.telus.net)
[21:34:24] * nmatsakis jealous. can't seem to land anything these days.
[21:34:29] <cmr> heh
[21:36:31] <kimundi> nmatsakis: I made an issue for that transmute-warn-proposal: https://github.com/mozilla/rust/issues/6790
[21:36:54] *** Joins: ghrust (ghrust@moz-4EF5B6E5.rs.github.com)
[21:36:54] <ghrust> 01[13rust01] 15bors pushed 0 new commits to 06auto: 02http://git.io/nz-_7Q
[21:36:54] *** Parts: ghrust (ghrust@moz-4EF5B6E5.rs.github.com) ()
[21:36:58] *** Joins: ghrust (ghrust@moz-4EF5B6E5.rs.github.com)
[21:36:59] <ghrust> 01[13rust01] 15bors pushed 6 new commits to 06auto: 02http://git.io/OfeEKw
[21:36:59] <ghrust> 13rust/06auto 146c03fbf 15Tim Chevalier: testsuite: Add passing test for #4735
[21:36:59] <ghrust> 13rust/06auto 1458547d6 15Tim Chevalier: testsuite: Add working test for #5550
[21:36:59] <ghrust> 13rust/06auto 14403aee1 15Tim Chevalier: testsuite: Test cases, one xfailed, one not
[21:37:01] *** Parts: ghrust (ghrust@moz-4EF5B6E5.rs.github.com) ()
[21:38:26] <nmatsakis> kimundi: cool
[21:38:59] *** Quits: MaikKlein (maik@moz-F9DF85DA.dip0.t-ipconnect.de) (Ping timeout)
[21:39:45] <cmr> nmatsakis, it'd be so much easier if windows was a supported platform for gdb's reverse debugging, or msvc could be used
[21:40:28] <strcat> graydon: heh, you can also freeze a cgroup and dump the state to a file
[21:40:38] <strcat> can then move it to another computer
[21:40:44] <strcat> weird.
[21:41:01] <graydon> "state"?
[21:41:19] <cmr> nmatsakis, ok, debugging with visual studio gives me Unhandled exception at 0x00C93808 in rustc.exe: 0xC0000005: Access violation writing location 0x00000000.
[21:41:29] <strcat> graydon: an image of all the processes basically
[21:41:44] <strcat> graydon: /sys/fs/cgroup/freezer can apparently do an atomic freeze
[21:42:41] <strcat> I thought it would be a good way to do an atomic kill but.... it seems like it can fail
[21:43:09] <nmatsakis> cmr: huh. I can't say that means much to me.
[21:43:21] <kimundi> rusti: let v: *uint = &5; v
[21:43:22] -rusti- 15413000
[21:43:39] <kimundi> rusti: let v: *uint = &5; v += 5; v
[21:43:40] -rusti- more than 5 lines of output, pastebinned: http://sprunge.us/NggJ
[21:44:29] <cmr> nmatsakis, it's trying to do *NULL = foo
[21:45:02] <cmr> it does look like it jumped to some fairly random place
[21:45:02] <nmatsakis> cmr: well, that much I did get :)
[21:45:07] <cmr> so maybe the abi handling is bad?
[21:45:19] <nmatsakis> cmr: presumably! thanks for your help, I have to run anyhow, I'll dig into this more later.
[21:45:19] <cmr> I have a partial stack trace, but it only gives me offsets into the dll
[21:45:31] <nmatsakis> cmr: yeah, I am trying to run stage1 rustc on smaller rust files now
[21:45:43] <nmatsakis> cmr: hoping to find a smaller example that crashes
[21:45:52] <nmatsakis> cmr: where I can just manually read the generated code, probably the problem will be obvious
[21:46:32] <nmatsakis> cmr: but yes I think we're not getting stack traces because the code is just jumping to the wrong place? or overwriting the return address? or doing something totally wrong, anyway.
[21:46:53] <cmr> nmatsakis, https://gist.github.com/anonymous/e50a2983a61f379e61f6 is what I get from MSVC
[21:47:15] <graydon> strcat: huh. how effective is it across, say, kernel versions? I assume you need a pretty close match
[21:47:22] *** Joins: youknowone (youknowone@A826BD81.8A0DEF81.38747683.IP)
[21:47:22] *** Quits: youknowone (youknowone@A826BD81.8A0DEF81.38747683.IP) (Z:lined (Open Proxy found on your host. Please visit www.blitzed.org/proxy?ip=115.68.131.49 for more information.))
[21:47:23] <strcat> graydon: yeah
[21:47:25] <nmatsakis> cmr: :(
[21:47:46] <strcat> graydon: I guess you'd usually just use it to save some state on the same machine
[21:47:51] <graydon> strcat: I mean, taking userspace is one thing, but what does it do for freezing a process' associated kernel resources?
[21:47:55] *** Quits: eholk (eholk@moz-6546E880.uconnect.utah.edu) (Quit: eholk)
[21:47:56] *** Joins: Ralith (ralith@moz-253EB0FD.wireless.sfu.ca)
[21:48:13] <strcat> graydon: well afaik the kernel ABI is forwards compatible
[21:48:55] <strcat> I don't really understand how freezing groups of processes can work in the first place
[21:49:46] <steven_is_false> So why is the function std::cast::forget needed?
[21:50:05] <aatch> steven_is_false, prevents the destructor from runnin
[21:50:06] <graydon> strcat: no, I mean .. when the process freezes, there are kernel-held _data structures_ (pipe buffers, signal state, page table entries, open files, etc.) associated with it. what happens to those?
[21:50:24] <strcat> graydon: dunno, but I guess it'd have to remake them again
[21:50:26] *** Quits: Ralith (ralith@moz-253EB0FD.wireless.sfu.ca) (Ping timeout)
[21:50:31] <graydon> mhm
[21:50:35] <graydon> well, neat
[21:52:07] *** Joins: Ralith (ralith@moz-253EB0FD.wireless.sfu.ca)
[21:54:04] *** Quits: erickt (erickt@8C9ECD8F.3A598286.F12515B4.IP) (Quit: Leaving.)
[21:56:27] <kimundi> Does 'let option: Some(~T) = ... ; option.is_none()' turn into a fast nullpointer check or something more complicated?
[21:56:58] *** Quits: Ralith (ralith@moz-253EB0FD.wireless.sfu.ca) (Ping timeout)
[21:57:33] *** Joins: Ralith (ralith@moz-253EB0FD.wireless.sfu.ca)
[21:57:46] <bblum> kimundi: last i heard jld was working on that
[21:57:58] <kimundi> ah,, okay :)
[21:59:37] *** Quits: Ralith (ralith@moz-253EB0FD.wireless.sfu.ca) (Ping timeout)
[21:59:45] <strcat> kimundi: yes
[22:00:01] <strcat> #[inline(never)]
[22:00:03] <strcat> fn foo<T>(x: Option<&T>) -> bool {
[22:00:05] <strcat>     x.is_none()
[22:00:07] <strcat> }
[22:00:20] <strcat> http://ix.io/5PJ becomes that
[22:00:51] <kimundi> nice! :)
[22:01:43] <Luqman> rusti: (sys::size_of::<Option<int>>(), sys::size_of::<Option<~int>>())
[22:01:44] -rusti- (16, 8)
[22:01:59] <bblum> heh
[22:03:00] <kimundi> rusti: (sys::size_of::<Option<&int>>(), sys::size_of::<Option<int>>(), sys::size_of::<Option<&[int]>>())
[22:03:00] -rusti- error opening /dev/urandom: Operation not permittedBad system call
[22:03:06] * strcat broke something
[22:03:11] <kimundi> wut? xD
[22:03:13] <strcat> rusti: (sys::size_of::<Option<&int>>(), sys::size_of::<Option<int>>(), sys::size_of::<Option<&[int]>>())
[22:03:13] -rusti- (8, 16, 24)
[22:03:42] <Luqman> sys::size_of::<Option<*int>>()
[22:03:43] *** Joins: Ralith (ralith@moz-253EB0FD.wireless.sfu.ca)
[22:03:49] <Luqman> rusti: sys::size_of::<Option<*int>>()
[22:03:50] -rusti- 16
[22:04:11] <strcat> * ptrs can actually be null in valid code
[22:04:28] <Luqman> ah right
[22:04:51] <aatch> In Rust, I tend to just think of *-ptrs as uints with a dereference operator
[22:05:00] <aatch> since semantically, that is what they are.
[22:05:44] <kimundi> well, there is *mut too...
[22:06:35] *** Quits: Ralith (ralith@moz-253EB0FD.wireless.sfu.ca) (Ping timeout)
[22:06:44] <strcat> Option<&[]> could be 2 words
[22:07:28] <kimundi> yeah, the optimisation works for a lot of them.
[22:07:57] <strcat> rusti: sys::size_of::<Option<~[]>>()
[22:07:58] -rusti- foo.rs:8:33: 8:34 error: expected type, found token RBRACKET
[22:07:58] -rusti- foo.rs:8          sys::size_of::<Option<~[]>>()
[22:07:58] -rusti-                                           ^
[22:08:02] <strcat> rusti: sys::size_of::<Option<~[int]>>()
[22:08:03] -rusti- 8
[22:08:09] <strcat> rusti: sys::size_of::<Option<~str>>()
[22:08:09] -rusti- 8
[22:08:12] *** Joins: mschifer1 (Adium@2557E599.66715431.D25A875A.IP)
[22:08:20] <strcat> rusti: sys::size_of::<Option<&str>>()
[22:08:21] -rusti- 24
[22:08:24] <kimundi> Option<char> could be 1 word, Option<bool> could be one byte... (Of course those are more uncommon ;) )
[22:08:30] *** Quits: mschifer (Adium@2557E599.66715431.D25A875A.IP) (Ping timeout)
[22:08:49] <fread2282> rusti: sys:ize_of::<Option<bool>>()
[22:08:50] -rusti- foo.rs:8:12: 8:13 error: expected `;` or `}` after expression but found `:`
[22:08:50] -rusti- foo.rs:8          sys:ize_of::<Option<bool>>()
[22:08:50] -rusti-                      ^
[22:08:55] <fread2282> rusti: sys::size_of::<Option<bool>>()
[22:08:56] -rusti- 16
[22:09:10] <Boreeas> For some reason, I am getting double error messages from the compiler, is that known/fixed already?
[22:09:20] <fread2282> rusti: sys::size_of::<Option<i64>>()
[22:09:21] -rusti- 16
[22:09:29] <fread2282> rusti: sys::size_of::<i64>()
[22:09:31] -rusti- 8
[22:09:31] <kimundi> Boreeas: That tends to happen
[22:09:54] <fread2282> rusti: sys::size_of::<bool>()
[22:09:55] -rusti- 1
[22:10:02] <Luqman> So an enum is generally sizeof largest variant + 8 for tag right?
[22:10:27] <kimundi> Boreeas: The compiler needs to do some preproccessing on it's error output to remove duplicates, merge different messages on the same span etc...
[22:10:33] <strcat> Luqman: yeah, uint tag right now
[22:10:41] <strcat> Luqman: the tag *should* only be as large as needed
[22:11:06] <strcat> Option<bool> should be 2 bytes, Option<()> should be 1 ;p
[22:11:36] <kimundi> strcat: couldn't option<bool> be 1 byte?
[22:11:41] <fread2282> rusti: (sys::size_of::<bool>(), sys::size_of::<Option<bool>>(), sys::size_of::<Option<()>>(), sys::size_of::<i8>())
[22:11:43] -rusti- (1, 16, 8, 1)
[22:12:05] <strcat> kimundi: not really
[22:12:31] <strcat> would probably break a lot of casts
[22:12:45] <kimundi> hmm...
[22:13:59] *** Joins: drak3 (drak3@moz-63A002DC.dip0.t-ipconnect.de)
[22:14:15] <strcat> rusti: std::run::spawn_program("ls", []);
[22:14:17] -rusti- more than 5 lines of output, pastebinned: http://sprunge.us/CKEJ
[22:14:23] <kimundi> Wouldn't unwrapping tha bool simply apply a bitmask to it?
[22:15:02] <strcat> kimundi: I guess
[22:16:00] <strcat> rusti: std::run::process_status("ls", []);
[22:16:01] -rusti- rust: task failed at 'failure in dup2(in_fd, 0): Bad file descriptor', /build/rust-incoming-git/src/rust/src/libstd/run.rs:658
[22:16:01] -rusti- rust: domain main @0x1d671b0 root task failed
[22:16:08] *** Quits: jack (jack@2557E599.66715431.D25A875A.IP) (Quit: Leaving.)
[22:16:13] <strcat> huh.
[22:16:21] *** Quits: azita (Azita@2557E599.66715431.D25A875A.IP) (Quit: azita)
[22:16:24] *** Quits: brendan (brendaneic@2557E599.66715431.D25A875A.IP) (Quit: brendan)
[22:16:29] <strcat> rusti: std::run::process_output("ls", []);
[22:16:36] <strcat> rusti: std::run::process_output("ls", [])
[22:16:38] -rusti- {status: 0, output: ~[102, 111, 111, 10, 102, 111, 111, 46, 114, 115, 10], error: ~[]}
[22:16:45] *** Quits: dju (dju@moz-83BD5EC.dmz.me) (Ping timeout)
[22:16:58] <steven_is_false> rusti: std::run::process_output("ps", [])
[22:16:59] -rusti- line longer than 150 columns, pastebinned: http://sprunge.us/gLIX
[22:17:22] <strcat> rusti: std::run::process_output("ps", []).output.to_str()
[22:17:23] -rusti- ~"[]"
[22:17:40] <strcat> rusti: std::run::process_output("ps", []).error.to_str()
[22:17:42] -rusti- line longer than 150 columns, pastebinned: http://sprunge.us/YHEP
[22:18:04] *** Joins: dju (dju@moz-83BD5EC.dmz.me)
[22:18:15] <strcat> rusti: unsafe { libc::system("ps") }
[22:18:17] -rusti- more than 5 lines of output, pastebinned: http://sprunge.us/BKIS
[22:18:26] * strcat sighs ;p
[22:19:04] <strcat> rusti: str::from_bytes(std::run::process_output("ps", []).error)
[22:19:05] -rusti- line longer than 150 columns, pastebinned: http://sprunge.us/Tihg
[22:19:29] <graydon> pcwalton: ping
[22:20:11] <strcat> oh it doesn't have procps-ng
[22:20:11] <pcwalton> graydon: pong
[22:20:22] <strcat> rusti: str::from_bytes(std::run::process_output("ps", []).error)
[22:20:23] -rusti- ~""
[22:20:34] <strcat> and I'd need to whitelist syscalls ;p
[22:20:50] <graydon> pcwalton: the thing-that-causes-slow-small-compiles, for-each-item or such .. what is it? was there a bug open on it? I'm having trouble digging it up
[22:21:08] <pcwalton> graydon: there are two problems, both stemming from each_path.
[22:21:12] <pcwalton> one is in coherence and the other is in resolve.
[22:21:42] *** Quits: saml (sam@moz-14C16814.cst.lightpath.net) (Quit: Leaving)
[22:22:05] <strcat> rusti: str::from_bytes(std::run::process_output("ps", []).output)
[22:22:06] -rusti- ~"  PID TTY          TIME CMD\n    1 ?        00:00:00 rust.sh\n   12 ?        00:00:00 foo\n   15 ?        00:00:00 ps\n"
[22:22:16] <graydon> do you think they'd be within reach of some of our larger community? it seems like it's one of the larger gates on cycle time
[22:22:37] *** Quits: devinus (devinus@moz-B4AF84BC.ptr.us.xo.net) (Quit: Computer has gone to sleep.)
[22:22:43] <fread2282> rusti: enum Foo{STUFF, OTHER}; sys:ize_of::<Foo>()
[22:22:43] -rusti- foo.rs:8:36: 8:37 error: expected `;` or `}` after expression but found `:`
[22:22:44] -rusti- foo.rs:8          enum Foo{STUFF, OTHER}; sys:ize_of::<Foo>()
[22:22:44] -rusti-                                              ^
[22:23:03] <fread2282> rusti: enum Foo{STUFF, OTHER}; sys::size_of::<Foo>()
[22:23:03] -rusti- 8
[22:23:27] <fread2282> wow that was a bad error message
[22:23:47] <jld> So, there's actually a change I was working on to use smaller ints for discriminants.
[22:24:01] *** Joins: devinus (devinus@moz-B4AF84BC.ptr.us.xo.net)
[22:24:05] <jld> It broke core::pipes and one of the FFI functions in rustllvm.
[22:24:11] *** Joins: erickt (erickt@8C9ECD8F.3A598286.F12515B4.IP)
[22:24:23] *** Joins: azita (Azita@2557E599.66715431.D25A875A.IP)
[22:24:43] *** Quits: dylukes (dylukes@moz-5EF8B0CF.hfc.comcastbusiness.net) (Quit: Computer has gone to sleep.)
[22:26:43] <jld> Thus, the problem of allowing the user to ask for, at the very least, a specific size of discriminant.
[22:27:08] <jld> Which in turn gets us into `attribute` vs. `meta_item`.
[22:27:26] <graydon> pcwalton: aha, https://github.com/mozilla/rust/issues/4572 there it is, and tomlee is already interested
[22:27:35] <jld> Which led to me trying to write an `each`-like function using the new signature for those, which was a type error in stage0.
[22:27:42] <pcwalton> yup
[22:27:47] <jld> And that's why I was trying to build a snapshot on my laptop on an airplane yesterday.
[22:28:43] <tjc> like you do
[22:29:14] <jld> I was left with the distinct impression that snap-stage1 is not what I wanted.
[22:29:27] <tjc> I didn't know you could do snap-stage1
[22:30:12] <jld> You can!  And then you'll get a snapshot rustc that won't load because symbol names changed.
[22:30:15] *** Quits: erickt (erickt@8C9ECD8F.3A598286.F12515B4.IP) (Ping timeout)
[22:30:16] <cmr> heh
[22:30:17] <aatch> bjz, I added some notes to the rusp wiki
[22:31:09] <strcat> aatch: btw we had to back out the noalias on &mut for now
[22:31:18] <aatch> strcat, I saw.
[22:31:20] <strcat> it has to check that none of the params contain &const or @mut and maybe something with closures
[22:33:32] *** Joins: brendan (brendaneic@2557E599.66715431.D25A875A.IP)
[22:33:38] <strcat> pcwalton: does ty::type_is_structural(t) return true for enums?
[22:33:47] <pcwalton> I *think* so
[22:34:06] <bjz> aatch: I'm doing a refactor
[22:34:16] <strcat> pcwalton: ah yeah it does
[22:34:19] <aatch> bjz, of the wiki?
[22:35:07] <bjz> aatch: removing the special forms from the parser doing everything as lists (apart from atoms)
[22:35:12] *** Joins: jack (jack@2557E599.66715431.D25A875A.IP)
[22:35:24] <bjz> aatch: simplifies things greatly
[22:35:27] <aatch> bjz, so the way you're supposed to do it?
[22:35:48] *** Quits: bjz (brendanzab@B398BE78.F804C29E.D35A31DF.IP) (Client exited)
[22:35:52] *** Joins: bjz (brendanzab@B398BE78.F804C29E.D35A31DF.IP)
[22:36:10] <bjz> aatch: yep :)
[22:36:25] <bjz> aatch: it's quite a learning experience
[22:36:28] <bjz> but fun
[22:36:44] <aatch> bjz, cool. I'm generally more interested in the runtime side of it.
[22:36:58] <bjz> yeah, that could do with some work
[22:37:06] <bjz> glad you're interested :)
[22:37:12] <bjz> (I have no idea)
[22:37:25] <bjz> you'll note I changed the description of the repo
[22:37:42] *** Joins: dylukes (dylukes@moz-5EF8B0CF.hfc.comcastbusiness.net)
[22:38:06] <bjz> me and dbaupp are thinking it might be better to steer clear of doing a 'traditional lisp'
[22:38:20] <aatch> bjz, fair enough
[22:38:53] *** Quits: jack (jack@2557E599.66715431.D25A875A.IP) (Quit: Leaving.)
[22:39:02] <bjz> aatch: nice!
[22:39:07] <bjz> I like the additions
[22:39:12] *** Joins: nonehaxor (nonehaxor@BA9CBAE.4C3B0355.EE6E63A5.IP)
[22:39:21] <bjz> :)
[22:39:22] <cscottnet> bjz: you're doing a lisp impl in rust?
[22:39:46] <bjz> cscottnet: "A minimal scripting and data language"
[22:39:50] *** Joins: ghrust (ghrust@moz-4EF5B6E5.rs.github.com)
[22:39:50] <ghrust> 01[13rust01] 15bors merged 06auto into 06incoming: 02http://git.io/OfeEKw
[22:39:50] *** Parts: ghrust (ghrust@moz-4EF5B6E5.rs.github.com) ()
[22:39:55] <bjz> is the revised description
[22:40:08] <aatch> bjz, you might want to update the README too
[22:40:13] <bjz> the implementation is pretty horid at the moment
[22:40:16] <bjz> yeah
[22:40:21] <bjz> I have it staged
[22:40:32] <cscottnet> bjz: i did https://github.com/cscott/rusty-turtle ; i recommend the approach as a way to learn about rust
[22:40:43] <cscottnet> but it's not such a great way to learn about rust's memory model
[22:40:53] *** Joins: jack (jack@2557E599.66715431.D25A875A.IP)
[22:40:55] <bjz> nice
[22:41:00] <bjz> will have a look later
[22:41:12] <aatch> bjz, is this still aimed at environments like game scripting?
[22:41:16] *** Quits: brson (brson@2557E599.66715431.D25A875A.IP) (Ping timeout)
[22:41:20] <bjz> aatch: yep
[22:41:25] <cscottnet> (rusty-turtle is an implementation of https://github.com/cscott/turtlescript, which is a syntactic (but not semantic) subset of javascript)
[22:41:41] *** Quits: jdm (jdm@DB05BBF2.BB1F48F2.971E19F6.IP) (Quit: Lost terminal)
[22:41:57] *** Joins: samnardoni (samnardoni@moz-ECB14881.cable.virginmedia.com)
[22:42:00] <bjz> aatch: and hopefully data serialisation
[22:42:04] <aatch> Cool, that helps to focus what features we want and what should be made easy at the expense of other things.
[22:42:12] <graydon> r? anyone https://github.com/mozilla/rust/pull/6793
[22:42:23] <bjz> aatch: might be good to emphasise that in the wiki
[22:42:46] *** Joins: ghrust (ghrust@moz-4EF5B6E5.rs.github.com)
[22:42:46] <ghrust> 01[13rust01] 15bors pushed 0 new commits to 06auto: 02http://git.io/0d2m7Q
[22:42:46] *** Parts: ghrust (ghrust@moz-4EF5B6E5.rs.github.com) ()
[22:42:48] *** Joins: ghrust (ghrust@moz-4EF5B6E5.rs.github.com)
[22:42:48] <ghrust> 01[13rust01] 15bors pushed 2 new commits to 06auto: 02http://git.io/OdIh0g
[22:42:48] <ghrust> 13rust/06auto 144521c34 15Jihyun Yu: Fix #6696
[22:42:48] <ghrust> 13rust/06auto 145676056 15bors: auto merge of #6775 : yjh0502/rust/issue_6696, r=catamorphism
[22:42:48] *** Parts: ghrust (ghrust@moz-4EF5B6E5.rs.github.com) ()
[22:43:11] *** Joins: brson (brson@2557E599.66715431.D25A875A.IP)
[22:43:11] *** ChanServ sets mode: +o brson
[22:43:32] <bjz> aatch: the reason s-expressions are good is they promote the data as code philosophy
[22:43:46] *** Quits: samnardoni (samnardoni@moz-ECB14881.cable.virginmedia.com) (Ping timeout)
[22:43:54] <bjz> aatch: I think it has great potential for game scripting in that regard
[22:44:18] <aatch> bjz, yep, I know. But from the "I want to do stuff" side, things like making it easy to manipulate objects is important
[22:44:23] <bjz> aatch: the challenge will be to make it performant and best utilise the strngths of rust
[22:44:50] <bjz> aatch: could you elaborate?
[22:45:50] *** Quits: brendan (brendaneic@2557E599.66715431.D25A875A.IP) (Quit: brendan)
[22:46:06] *** Joins: matt (Mibbit@moz-73D874BD.range81-129.btcentralplus.com)
[22:46:42] <aatch> bjz, well the scripting in games is mostly game logic. Stuff that isn't likely to cause a significant performance hit. Hence the usage of Lua et al.
[22:47:04] <aatch> bjz, but games are naturally drawn towards objects for representing bits of the world
[22:47:12] <bjz> yep
[22:47:31] <aatch> so it should be relatively easy to manipulate said objects in rusp
[22:48:06] <aatch> it's probably more a library-ish level feature, but it's also important to keep in mind.
[22:48:25] <bjz> if you have any ideas of traits/interfaces that would make that easier let me know
[22:48:31] <bjz> or post on the wiki
[22:48:57] <bjz> brb
[22:49:03] <brson> acrichto: building your branch on windows
[22:49:45] *** Quits: dylukes (dylukes@moz-5EF8B0CF.hfc.comcastbusiness.net) (Quit: Computer has gone to sleep.)
[22:50:28] <aatch> graydon, so my optimization pass refactor has encountered a strange bug with intrinsic injection.
[22:50:41] *** Joins: Sorella (queen@B12A78F5.BA14766C.95C8B7C6.IP)
[22:50:56] *** Joins: dylukes (dylukes@moz-5EF8B0CF.hfc.comcastbusiness.net)
[22:52:25] <graydon> aatch: oh?
[22:52:46] <graydon> aatch: feel free to remove intrinsic injection. it's redundant cruft from before we had lang items.
[22:53:00] <graydon> you will have to do a bit of a snapshot dance to do so, but it's slated to go anyways
[22:53:55] <aatch> graydon, ok. I'll make a new branch and do that, the refactoring will be blocked on that.
[22:54:30] <aatch> It's really strange though, it fails during either typecheck or resolve, depending on what I build with the stage2 compiler...
[22:54:37] <graydon> what's the failure?
[22:54:59] <graydon> happy to debug it in absence of removing-intrinsic-injection. that's just the brute force workaround :(
[22:55:24] <aatch> "error: internal compiler error: unexpected sort of item in get_item_ty(): None (def_id:{crate: 0, node: 762383})"
[22:55:30] <aatch> trying to build libstd
[22:55:55] <graydon> backtrace?
[22:55:59] <aatch> (I added the bit at the end to try and get a little more help)
[22:57:14] <aatch> graydon, https://gist.github.com/Aatch/4e981c1c0f98ef143923
[22:57:42] <aatch> if I try to compile something else, I get a resolve error for the same item.
[22:57:55] <graydon> which item?
[22:58:09] <aatch> intrinsic::get_tydesc
[22:58:28] <aatch> which is the first one in the module, so it's probably because of that.
[22:58:33] <graydon> huh
[22:58:39] <graydon> ummm
[22:59:04] <graydon> yeah, sounds like intrinsic injection is less the problem, and you are just hitting the "failure on the first item" situation
[22:59:09] *** Joins: erickt (erickt@8C9ECD8F.3A598286.F12515B4.IP)
[22:59:15] <aatch> Oh, by "resolve error" I mean: "task failed at 'lookup_item: id not found: 762951', /home/james/projects/rust/compiler/src/librustc/metadata/decoder.rs:92"
[22:59:20] *** Quits: tikue (tkuehn@2557E599.66715431.D25A875A.IP) (Quit: tikue)
[23:00:05] *** Joins: Jesin (Jessin_@moz-A03A364F.cc.lehigh.edu)
[23:00:11] <aatch> The odd thing is that the numbers are way lower with the stage1 compiler.
[23:00:19] <graydon> which numbers?
[23:00:19] *** Joins: alisdair (textual@moz-EBE9F394.bchsia.telus.net)
[23:00:25] *** Quits: pcwalton (pcwalton@2557E599.66715431.D25A875A.IP) (Quit: pcwalton)
[23:00:29] <aatch> the node ids
[23:00:47] <graydon> that is odd
[23:00:51] *** Quits: erickt (erickt@8C9ECD8F.3A598286.F12515B4.IP) (Ping timeout)
[23:00:57] <graydon> do you have your patch kicking around that I can look at?
[23:01:11] <aatch> There's a pullreq open
[23:01:25] *** Joins: pcwalton (pcwalton@2557E599.66715431.D25A875A.IP)
[23:01:25] *** ChanServ sets mode: +o pcwalton
[23:01:27] *** Quits: bjz (brendanzab@B398BE78.F804C29E.D35A31DF.IP) (Quit: Leaving...)
[23:01:27] <aatch> which I note that I have run into an error.
[23:01:42] <aatch> https://github.com/mozilla/rust/pull/6778
[23:02:59] *** Quits: Jesin (Jessin_@moz-A03A364F.cc.lehigh.edu) (Input/output error)
[23:03:17] *** Joins: tikue (tkuehn@2557E599.66715431.D25A875A.IP)
[23:03:48] *** Joins: mschifer (Adium@2557E599.66715431.D25A875A.IP)
[23:03:54] *** Quits: mschifer1 (Adium@2557E599.66715431.D25A875A.IP) (Connection reset by peer)
[23:04:08] *** Quits: Scriptor (historium@moz-E06F46F0.corp.bitshelter.com) (Quit: Scriptor)
[23:04:19] *** Joins: eholk (eholk@moz-6546E880.uconnect.utah.edu)
[23:05:27] <graydon> aatch: what happens if you turn off some of those optimizations? I wouldn't be surprised if this is just "optimizer uncovered bad code"
[23:05:48] <aatch> graydon, yeah, that was my next move.
[23:06:03] *** Quits: devinus (devinus@moz-B4AF84BC.ptr.us.xo.net) (Quit: Textual IRC Client: www.textualapp.com)
[23:06:05] *** Joins: bjz (brendanzab@B398BE78.F804C29E.D35A31DF.IP)
[23:06:32] *** Quits: donri (dag@moz-9BB61102.tbcn.telia.com) (Client exited)
[23:06:33] <matt> hi guys, i'm struggling to work out how regions work with self, how come this does not work: http://pastebin.com/KKFDZZNP ?
[23:07:41] <graydon> aatch: yeah, nothing stands out at me. looks like a nice patch!
[23:07:59] <cmr> matt: it works on the incoming branch
[23:08:12] <aatch> graydon, yeah, if there was something obvious, I'd probably have found it by now... :(
[23:08:30] *** Parts: mschifer (Adium@2557E599.66715431.D25A875A.IP) ()
[23:08:54] *** Joins: MaikKlein (maik@moz-F9DF85DA.dip0.t-ipconnect.de)
[23:09:09] <graydon> but I'd try turning off TBAA for example. and maybe tail call elim?
[23:09:38] <aatch> The thing is, I just copied the pipeline from PassManagerBuilder
[23:09:55] <steven_is_false> rusti: struct Test { length: Option<int> } impl Test { fn foo<'a>(&'a self) -> &'a Option<int> { &'a self.length } }
[23:10:54] *** Quits: dylukes (dylukes@moz-5EF8B0CF.hfc.comcastbusiness.net) (Quit: Computer has gone to sleep.)
[23:10:56] <cmr> rusti: 2
[23:10:58] -rusti- 2
[23:11:04] <cmr> strcat: what's wrong with rusti? :\
[23:11:33] <bblum> uh, there was just no output for the above input
[23:11:41] <bblum> because it was an impl
[23:11:56] <strcat> rusti: 5
[23:11:57] -rusti- 5
[23:12:00] *** Joins: devbug (quassel@moz-E1DE087C.bchsia.telus.net)
[23:12:06] <strcat> I can make there be something wrong with it :)
[23:12:13] <cmr> heh
[23:12:38] <matt> thing is it doesn't compile for me, i get: error: cannot infer an appropriate lifetime due to conflicting requirements
[23:12:41] <bjz> strcat: would be nice if rusti posted `()` if there was no output
[23:12:56] <strcat> bjz: I actually explicitly got rid of that :)
[23:12:59] <strcat> I could turn that off
[23:13:01] <matt> "the lifetime cannot outlive the lifetime &'self  as defined on the block"
[23:13:06] * strcat didn't really think about it
[23:13:08] <bjz> strcat: would be nice
[23:13:19] <strcat> rusti: 5;
[23:13:24] <strcat> rusti: 5;
[23:13:34] <strcat> rusti: 5;
[23:13:35] <bjz> strcat: it gives the user feedback if something happened
[23:13:36] -rusti- ()
[23:13:39] <bjz> yay
[23:13:53] <bjz> rusti: trait Foo {}
[23:13:54] -rusti- ()
[23:13:57] <bjz> :)
[23:14:01] <bjz> awesome
[23:14:08] <strcat> rusti: 5;
[23:14:09] -rusti- ()
[23:14:26] *** Quits: snadon (chatzilla@moz-3BC727E8.mc.videotron.ca) (Ping timeout)
[23:14:47] <strcat> http://ix.io/5PO just this now ;p
[23:15:22] <strcat> I might not need to pipe stderr anymore
[23:15:47] <bjz> strcat: we should make that the official rusti XD
[23:16:10] * bjz kids
[23:16:27] <acrichto> brson: thanks!
[23:16:50] * graydon cries a little
[23:16:55] <graydon> yesterday, gc bootstraps
[23:17:05] <graydon> today, same code, gc crashes
[23:17:08] *** Quits: doener (doener@moz-121949B3.unitymediagroup.de) (Quit: leaving)
[23:17:08] *** Quits: Flibo (Flibo@moz-40397852.org.aalto.fi) (Ping timeout)
[23:17:14] <graydon> come on now, why you have to be like that?
[23:18:30] <aatch> graydon, it looks like I wasn't paying attention while copying the passes, I'm gonna make sure it /actually/ reflects what we had before and try again..
[23:18:38] <graydon> :)
[23:18:53] <graydon> aatch: best of luck!
[23:18:53] *** Quits: steveklabnik (steve@moz-5EF6C37C.socal.res.rr.com) (Quit: Lost terminal)
[23:19:38] <aatch> Hopefully I can get this into a state where we can copy Haskell and evolve a set of optimizations
[23:19:54] <cscottnet> rusti: fn foo(x:f64)->int { match x { f64::NaN => 1, _ => 0 } } foo(f64::NaN)
[23:19:55] -rusti- 0
[23:20:01] *** Joins: dbaupp (Thunderbir@5398BEFD.D5A1DCF.37681C44.IP)
[23:20:01] <cscottnet> ^^ understandable, but still a bug
[23:20:15] <strcat> cscottnet: is it? ;p
[23:20:46] <aatch> It's not, NaN doesn't compare equal to anything, even itself.
[23:21:08] <aatch> rusti: f64::NaN == f64::NaN
[23:21:10] -rusti- false
[23:21:11] <cscottnet> but match is a structure equivalence, not really an equality test
[23:21:15] <cscottnet> aatch: i'm well aware
[23:21:27] <graydon> what's structure equivalence?
[23:21:38] <cscottnet> the question is, if I structure-match against a structure with NaN in it, do i expect it to always fail?  not very useful, that.
[23:21:40] <graydon> (if not equality?)
[23:21:41] <strcat> I was going to ask 'what does haskell do' but they don't have NaN literals ;\
[23:21:57] <aatch> WWHD
[23:22:00] *** Joins: brendan (brendaneic@2557E599.66715431.D25A875A.IP)
[23:22:02] <cscottnet> graydon: match against a list, tuple, or structure with a NaN in it.
[23:22:34] <graydon> cscottnet: ... what's "match", if not equality?
[23:22:41] <steven_is_false> The thing is NaN is basically like an exception.
[23:22:41] <dbaupp> it seems scala doesn't match on NaN http://stackoverflow.com/questions/6908252/in-scala-why-is-nan-not-being-picked-up-by-pattern-matching
[23:22:44] *** Joins: Flibo (Flibo@moz-40397852.org.aalto.fi)
[23:23:01] *** Quits: matt (Mibbit@moz-73D874BD.range81-129.btcentralplus.com) (Quit: http://www.mibbit.com ajax IRC Client)
[23:23:35] <steven_is_false> In a hypothetical Rust with exceptions would (throw "A") == (throw "B") ? I think the answer is no.
[23:23:56] <graydon> like, seriously, what should we emit there? special case double such that we call IsNaN() rather than equality, as in all other cases?
[23:24:08] <cscottnet> in a hypothetical Rust with exceptions, I would hope that 'catch' is implemented with the same basic mechanism as 'match'
[23:25:18] <aatch> cscottnet, the other thing is that, while you are aware than NaN != NaN, not everybody is.
[23:25:22] <graydon> pattern matching is generally "equality with values, binding with non-values". this would add an "... except NaN, which is special"
[23:25:25] <cscottnet> graydon: yes, i was expecting match to special-case equality for f64.  but you could argue that NaN != NaN is the 'surprising' part here, not match's behavior.
[23:25:46] *** Quits: Excureo (c@moz-DE8C33F1.static.yakm.wa.charter.com) (Ping timeout)
[23:26:09] <aatch> cscottnet, this is why there are pattern guards
[23:26:12] <cscottnet> aatch: which is exactly why I feel like this could be considered a bug.  it's "surprising".  understandable, if you understand IEEE floating-point semantics
[23:26:18] <graydon> we don't do so for equality, so this would be weirder still. we don't induce a total order on doubles either. we expose what the hardware does.
[23:26:18] <cscottnet> aatch: yes, that is what rusty-turtle uses
[23:26:23] <engla> Why does rust have to preserve this NaN != NaN madness
[23:26:26] <graydon> you have to understand ieee 754 to use doubles
[23:26:38] <cscottnet> graydon: does matching against a tuple invoke Eq on tuples?
[23:26:46] *** Joins: mflamer (Mibbit@moz-FE8B7976.dsl.pltn13.sbcglobal.net)
[23:26:49] <graydon> engla: because it's what the hardware does and it's not our place to impose a notion of correctness on it
[23:26:50] <steven_is_false> engla: Because 0/0 does not equals sqrt(-1).
[23:26:50] <cscottnet> i don't believe that match is equality, exactly
[23:27:09] *** Joins: Excureo (c@moz-DE8C33F1.static.yakm.wa.charter.com)
[23:27:12] <graydon> cscottnet: on values, yes. on variables-to-bind, it descends into them and makes bindings.
[23:27:15] <strcat> engla: our floats are ieee754 math, and that's what it's defined to do
[23:27:23] <strcat> engla: you can't really have sane numbers ;p
[23:27:28] <strcat> just different tradeoffs
[23:27:28] <aatch> There are actually like 4 different NaNs or something too
[23:27:38] <strcat> rationals are so very nice but then you have no sin, cos, etc.
[23:27:59] <engla> graydon: that's the point I was missing x
[23:28:02] <strcat> or sqrt
[23:28:14] <cscottnet> graydon: yes.  so my point is just that because NaN != NaN doesn't necessarily mean that match against NaN must always fail.
[23:28:29] <cscottnet> aatch: more than that.  JS implementation use NaN boxing.
[23:28:40] <cscottnet> rationals are very nice but they overflow if you look at them funny.
[23:29:02] <strcat> cscottnet: they don't overflow when they use bigints
[23:29:13] <cscottnet> strcat: unless you have infinite storage, they do
[23:29:13] <graydon> cscottnet: x if x.isNaN() => ... works here
[23:29:20] <cscottnet> your bigints grow *very* quickly.
[23:29:32] <aatch> more than 4 NaNs? Eh, the important thing is that there is more than one, but they are all still NaN
[23:29:36] <cscottnet> graydon: yes.  like i said, that's what rusty-turtle does.
[23:30:17] <cscottnet> i was just bringing up the NaN case to see if anyone else agreed that this could be improved.  apparently, no one else thinks this is a problem.  that's fine.
[23:30:40] <graydon> cscottnet: ok. I .. don't really think this is a bug. it's a place where there's confusion-potential either way and we've picked the most conservative position which is to treat NaN as a value-like-thing and dispatch to equality, since it's syntactically presented as a value in the pattern.
[23:30:56] <graydon> the same could potentially happen with, say, unicode normalization
[23:31:55] <cscottnet> sure, arguably you'd need the same solution there
[23:32:27] <graydon> cscottnet: but I can see how it is a confusable. I wish there was a better solution to confusables of this sort. I don't think switching it to do the opposite of == will make it less confusable.
[23:32:39] *** Quits: SimonSapin (simon@5AAE35B2.5EFFC0B8.24454B25.IP) (Ping timeout)
[23:32:50] <cscottnet> match x { Foo(str) if str::unicode_nfkc_equals(str, "some constant) => ... }
[23:33:57] <graydon> yeah :(
[23:34:04] <graydon> or locale_equiv()
[23:34:07] <graydon> or several other things
[23:34:23] <cscottnet> graydon: generically speaking, you'd want to be able to define "which sort of equality" you wanted to use for the match.  but in a sense you already have that with value binding, so i guess i'll agree that this isn't a bug.  it's just surprising.  but NaN is surprising, as is unicode normalization.
[23:34:39] <graydon> I don't think it's going to make life easier on users if the compiler tries to guess that. it's already spooky to me that == is overridable (in ways that permit you to, say, write non-symmetric ==)
[23:34:49] <cscottnet> it's just particularly weird that a match with a NaN in it will never match anything ever
[23:34:55] <graydon> yeah
[23:35:03] <pcwalton> it seems natural to me
[23:35:12] <pcwalton> I mean, it's what i'd expect
[23:35:22] <graydon> it seems like .. if it were on a test, I'd expect to get the answer wrong 50% of the time
[23:35:35] <pcwalton> although I'm used to NaN being weird from JS so...
[23:35:39] <graydon> no matter what the compiler does :(
[23:35:41] <pcwalton> I mean, I'd expect match to do the same thing == does
[23:35:50] <graydon> very slightly, yes
[23:35:50] <bblum> it is counterintuitive that you could write a match statement and execute it without executing any of its arms
[23:35:55] <cscottnet> i certainly understand NaN semantics, yet this was a bug I found in my own code because I wrote the match against NaN without thinking too hard.
[23:35:58] <graydon> 49% of the time :)
[23:36:08] <cscottnet> bblum: well, the catchall arm still matches
[23:36:15] *** Quits: brendan (brendaneic@2557E599.66715431.D25A875A.IP) (Quit: brendan)
[23:36:28] <graydon> curious aside: what does the exhaustiveness checker do here?
[23:36:45] <bblum> cscottnet: hmmm... i suppose that means it's impossible to write a match on a float without using a catchall, then
[23:36:49] <cscottnet> i would not expect any finite set of cases to be called "exhaustive" for floats.
[23:36:52] <graydon> I assume it treats all double == arms as "maybe"
[23:37:07] <bblum> hey, you could write a multi-gigabyte source file with 4 billion match arms
[23:37:16] <strcat> graydon: at least we don't have an overloadable comma operator ;p
[23:37:17] <cscottnet> even though technically you could write.. yeah, what bblum said.
[23:37:18] *** Joins: Ralith (ralith@moz-50F3C77.vc.shawcable.net)
[23:37:32] <graydon> strcat: I should make a little altar where I place things-to-be-thankful-for like that
[23:37:47] <graydon> and I can remove them one by one as angry feature requests come in :)
[23:38:00] <cscottnet> graydon: speaking of which...
[23:38:13] <graydon> oh? surely not comma..
[23:38:14] <cscottnet> i had some thoughts on exceptions-that-might-not-totally-piss-off-graydon
[23:38:17] <graydon> haha
[23:38:18] <jclements> graydon: no altars: #4 on the list of things I miss about being an atheist.
[23:38:52] <bblum> cscottnet: i think the right thing to do here is add some special-case code to the compiler, but only for the purpose of emitting a warning ("this match clause will never execute")
[23:38:55] *** Quits: Excureo (c@moz-DE8C33F1.static.yakm.wa.charter.com) (Ping timeout)
[23:39:14] *** Joins: Excureo (c@moz-DE8C33F1.static.yakm.wa.charter.com)
[23:39:18] <bblum> ("instead write: _ if isNaN(x) => ...")
[23:39:26] <graydon> cscottnet: can it leave values in an addressable but uninitialized state?
[23:39:51] <graydon> cscottnet: or half-constructed?
[23:39:52] <strcat> bblum: we need that in general (expression always true/false)
[23:40:23] <strcat> rusti: let x = 5u; while x >= 0 { x -= 1 }
[23:40:25] -rusti- more than 5 lines of output, pastebinned: http://sprunge.us/aIeB
[23:40:34] <strcat> rusti: let mut x = 5u; while x >= 0 { x -= 1 }
[23:40:38] <strcat> should warn ;p
[23:40:40] -rusti- more than 5 lines of output, pastebinned: http://sprunge.us/NeTi
[23:40:48] <strcat> oh it does! :)
[23:40:52] <bblum> :3
[23:40:55] <cscottnet> bblum: i like that
[23:41:03] <bblum> strcat: that's probably also special-case code though
[23:41:17] <strcat> bblum: yeah, I know - I just mean it's a good thing to pursue
[23:41:25] <cscottnet> graydon: only if you ask it to. ;)
[23:41:45] <graydon> cscottnet: well, ok, what's the trick?
[23:42:00] <aatch> graydon, btw, I'm pretty sure we could add profiling to rust, there's a transform pass that adds profiling instrumentation
[23:42:02] <graydon> cscottnet: I hate to be a broken record, it just feels like it's intrinsic to the feature, which is why I don't like it..
[23:42:04] <cscottnet> graydon: i hashed it out in interviews with rust/servo folk on friday, but my family just came home, not sure i have time to dig into details atm
[23:42:15] <graydon> aatch: yes, I saw that! very exciting. PGO often helps quite a bit.
[23:42:18] <graydon> kk
[23:42:19] <cscottnet> graydon: but the key is that exceptions do not by default propagate.
[23:42:26] <bblum> rusti: let x = f64:NaN; if x == NaN { io::println("nan"); }
[23:42:27] -rusti- foo.rs:8:20: 8:21 error: expected `;` but found `:`
[23:42:27] -rusti- foo.rs:8          let x = f64:NaN; if x == NaN { io::println("nan"); }
[23:42:27] -rusti-                              ^
[23:42:27] <cmr> aatch: that would be great
[23:42:30] <bblum> oops
[23:42:36] <bblum> rusti: let x = f64::NaN; if x == f64::NaN { io::println("nan"); }
[23:42:37] -rusti- ()
[23:42:44] <bblum> that should warn too
[23:42:44] <graydon> cscottnet: looking forward to reading it. I'll try to read with an open mind.
[23:42:56] <graydon> have a good evening
[23:43:04] <cscottnet> graydon: using # as a bit of strawman syntax, fn# foo declares a function that can throw, but the thrown exception is only propagated if you invoke it with foo#(...)
[23:43:34] * strcat thinks we just need synchronous "tasks" on the same stack
[23:43:47] <cscottnet> it's mostly just a bit of syntactic jujitsu, but it means that any place where strange-exception-type-things can happen gets syntatically marked.
[23:43:48] <bblum> strcat: how are those different from "function calls"
[23:43:54] *** Quits: Excureo (c@moz-DE8C33F1.static.yakm.wa.charter.com) (Ping timeout)
[23:43:55] <strcat> bblum: you can catch failure
[23:43:56] <cscottnet> i think i proposed at the same time that fail!() disappear
[23:44:02] <strcat> bblum: because it stops you from sharing memory
[23:44:05] <graydon> bblum: they're failure-and-heap-boundaries
[23:44:11] <bblum> ah yes
[23:44:13] <cscottnet> i think assert!(false) is still valuable
[23:44:22] <cscottnet> but that it's not implemented with fail!() any more
[23:44:41] <aatch> graydon, and in better news, I removed some of the optimizations and it compiles all the way through.
[23:44:50] <graydon> aatch: \o/
[23:44:51] <cscottnet> assert!(false) would probably do something like "return an arbitrary value consistent with the function signature" if assertion-checking were not enabled
[23:44:56] <bblum> strcat: well, task::try is the same functionality; just less performant
[23:45:04] <aatch> I'm gonna add some back in to see what breaks.
[23:45:04] <graydon> aatch: ship it!
[23:45:16] <strcat> bblum: yeah, and I guess it won't be too bad with the new scheduler
[23:45:21] <strcat> just the overhead of a new stack
[23:45:34] <cscottnet> but that's orthogonal, really.  the point is just that fail!() appears in match statements and other places where the programmer can assert that execution does not reach; you don't want to turn those into exceptions (of the #-marked kind or otherwise)
[23:45:35] *** Joins: Excureo (c@moz-DE8C33F1.static.yakm.wa.charter.com)
[23:45:40] <graydon> aatch: I would very much like to see what happens if you combine that, function merging and strcat's change to mark glue as address-ignorable
[23:45:53] <aatch> graydon, me too
[23:46:04] *** Quits: mflamer (Mibbit@moz-FE8B7976.dsl.pltn13.sbcglobal.net) (Quit: http://www.mibbit.com ajax IRC Client)
[23:46:50] <cscottnet> graydon: anyway, i'll try to find free time to write it up more properly.  there were still a few issues with interaction with the iterator protocol that deserve more than a hand-waving treatment.
[23:47:28] <cscottnet> whoever it was I was talking to on friday (josh, i think?  names melt together) was pointing out that fail!() is currently an exception, and one of the most pernicious kinds.
[23:48:01] <graydon> cscottnet: ok. I'm ... only lukewarm at the summary form, given that it requires marking each call in the unwindable-path with a different call syntax, but ..
[23:48:24] *** Quits: vosen (vosen@moz-266BA656.icpnet.pl) (Quit: Leaving)
[23:48:37] <graydon> yes, it's an exception. but it _destroys the task_, so you can't get into a state with a half-constructed heap. that's the only part of the issue we're struggling with, I think.
[23:48:49] *** Joins: ghrust (ghrust@moz-4EF5B6E5.rs.github.com)
[23:48:49] <ghrust> 01[13rust01] 15bors merged 06auto into 06incoming: 02http://git.io/OdIh0g
[23:48:49] *** Parts: ghrust (ghrust@moz-4EF5B6E5.rs.github.com) ()
[23:49:01] <aatch> I have a feeling that the optimization that broke it was the SROA pass...
[23:49:45] <cscottnet> graydon: destroying the task still requires the compiler to emit lots of unnecessary cleanup code paths, since the task can be destroyed in theory at every function call site.
[23:50:22] <graydon> cscottnet: yes, it's quite a cost center for us, no debate. I don't think we'll be able to get away from that though. there will always be fatal / pervasive errors.
[23:50:31] <cscottnet> and if you're a user writing resource-management code (like opening file handlers), you still have to deal with the fact that the task can be killed without giving you an opportunity to release the resources
[23:50:34] <graydon> divide by zero. control-C. out of memory.
[23:50:41] <graydon> that's why we have destructors
[23:50:47] <graydon> (haven't we been over all this?)
[23:50:50] *** Quits: jorendorff (jorendorff@moz-2F32ACA3.hsd1.tn.comcast.net) (Quit: jorendorff)
[23:51:05] <cscottnet> graydon: wait, destructors can be run after the task is killed?
[23:51:10] <graydon> no
[23:51:14] <graydon> they run while the task is unwinding
[23:51:28] <graydon> fail() is just like C++ throw, except _you cannot catch_
[23:51:46] *** Quits: ksev (DrunkenPan@745B767B.989A61DC.CA5B6332.IP) (Ping timeout)
[23:51:47] *** Joins: ghrust (ghrust@moz-4EF5B6E5.rs.github.com)
[23:51:47] <ghrust> 01[13rust01] 15bors pushed 0 new commits to 06auto: 02http://git.io/9rf0tg
[23:51:47] *** Parts: ghrust (ghrust@moz-4EF5B6E5.rs.github.com) ()
[23:51:47] <graydon> it's not the unwinding that's the problem. it's the idea of stopping part way in a half-constructed heap.
[23:51:48] *** Joins: ghrust (ghrust@moz-4EF5B6E5.rs.github.com)
[23:51:48] <ghrust> 01[13rust01] 15bors pushed 3 new commits to 06auto: 02http://git.io/ZuJJGg
[23:51:48] <ghrust> 13rust/06auto 1474508d6 15Alex Crichton: Define rustc's host triple at compile time...
[23:51:49] <ghrust> 13rust/06auto 141ab23ea 15Alex Crichton: Un-ignore rusti/rustpkg tests on i686
[23:51:49] <ghrust> 13rust/06auto 14dd76da4 15bors: auto merge of #6733 : alexcrichton/rust/issue-2400, r=brson...
[23:51:50] *** Parts: ghrust (ghrust@moz-4EF5B6E5.rs.github.com) ()
[23:52:06] <cscottnet> graydon: but your destructors are running in that half-constructed context.
[23:52:06] <graydon> we partition our heaps at task boundaries. and we unwind _to_ a task boundary when the task fails.
[23:52:18] <graydon> destructors only have access to their own data.
[23:52:36] <graydon> they execute top-down
[23:52:44] <graydon> in that tree of data
[23:52:50] <graydon> that they own
[23:53:10] <cscottnet> ok, i do have to go take a family-related exception right now.
[23:53:24] <graydon> k
[23:53:48] <cscottnet> but i'll try to write something up.  it's an interesting problem, and i agree with you that ensuring good semantics for the unwind is important.
[23:54:09] <aatch> graydon, what AliasAnalysis-related information do we have in the compiler atm?
[23:54:11] * strcat really thinks it would be a non-issue if tasks could be as light as a function call if needed
[23:54:13] *** Quits: jensnockert (jensnocker@moz-8BE55278.customer.t3.se) (Input/output error)
[23:54:22] <cscottnet> strcat would like cilk ;)
[23:54:33] <graydon> aatch: not much? strcat is trying to add some
[23:54:45] <strcat> aatch: there's just noalias on ~ params right now
[23:54:51] <strcat> and no TBAA pass
[23:54:57] <aatch> I meant more, stuff that /could/ be added.
[23:55:08] *** Joins: ksev (DrunkenPan@moz-C6488E57.autodesk.com)
[23:55:17] *** Quits: lerc (quassel@121-74-233-23.telstraclear.net) (Ping timeout)
[23:55:19] <strcat> aatch: well for a TBAA pass where it queries you about 2 pointers
[23:55:20] <aatch> like we have the mutability and the types.
[23:55:25] <strcat> ~ and ~ never alias, ~ and @ never alias
[23:55:29] <strcat> &mut never aliases with anything
[23:55:49] <strcat> & pointers to Const things never alias in LLVM's terms, assuming correct unsafe blocks (not the case)
[23:56:12] <aatch> because it doesn't look like writing a rust-specific TBAA pass would be too hard.
[23:56:23] <strcat> aatch: well it would be awesome to do :)
[23:56:26] <aatch> just need to emit the appropriate metadata
[23:56:32] <aatch> which is the hard part
[23:56:48] <jld> Also, a &[] won't alias with its contents.
[23:56:54] *** Quits: ksev (DrunkenPan@moz-C6488E57.autodesk.com) (Ping timeout)
[23:57:14] <jld> This used to be a problem and still may -- writes to an array made LLVM re-fetch the length field from the &[] and re-assert its length.
[23:57:20] *** Quits: eholk (eholk@moz-6546E880.uconnect.utah.edu) (Quit: eholk)
[23:57:42] <strcat> jld: well most things are Const, so if we actually track down and fix everything using unsafe {} to mutate through & we can pretty much make & respond NoAlias
[23:58:18] <strcat> the rules are the 2 pointers have to be a) pointing at disjoint things or b) both only used to read data
[23:58:26] <strcat> and then you can respond NoAlias
[23:58:59] <Eridius> strcat: are you sure &mut never aliases? I can certainly construct a &mut[u8] and a &const[u8] from the same ~[u8]
[23:59:09] <strcat> Eridius: it aliases with @mut and &const
[23:59:17] <strcat> but &const will go away afaik
[23:59:19] <graydon> &const should go
[23:59:28] <Eridius> strcat: I'm coming into the convo late, I'm just responding to your statement "&mut never aliases with anything"
[23:59:30] <graydon> (I think!)
[23:59:39] <Eridius> if &const goes away, what replaces it?
[23:59:43] *** Joins: erickt (erickt@8C9ECD8F.3A598286.F12515B4.IP)

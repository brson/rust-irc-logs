[00:38:57] *** Joins: SilverKey (SilverKey@moz-liif3j.res.rr.com)
[01:29:56] *** Quits: SilverKey (SilverKey@moz-liif3j.res.rr.com) (Quit: ZZZzzz…)
[03:13:32] *** Joins: SilverKey (SilverKey@moz-liif3j.res.rr.com)
[04:24:15] *** Quits: SilverKey (SilverKey@moz-liif3j.res.rr.com) (Quit: ZZZzzz…)
[07:42:39] *** Joins: Tobba (Tobba@moz-oecqnu.plus.com)
[08:04:44] *** Quits: Tobba (Tobba@moz-oecqnu.plus.com) (A TLS packet with unexpected length was received.)
[13:47:36] *** Joins: Tobba (Tobba@moz-oecqnu.plus.com)
[14:38:16] <nmatsakis> huon: I'm in favor of inclusive ranges! I keep hitting random times that I want them :P
[14:38:27] <nmatsakis> however, I'm confused why you don't implement Iterator...is there a deep reason for that?
[14:38:30] <nmatsakis> also, ...b seems useful
[14:38:39] <nmatsakis> 0... not so much
[14:38:46] <nmatsakis> (nor ...)
[14:39:15] <nmatsakis> however, I would also like to add exclusive patterns (for consistency's sake, if nothing else)
[14:39:26] <nmatsakis> it's worth at least mentioning why you're not talking about adding those in the RFC :)
[14:49:28] *** Joins: SilverKey (SilverKey@moz-liif3j.res.rr.com)
[15:57:16] *** Quits: Tobba (Tobba@moz-oecqnu.plus.com) (Ping timeout: 121 seconds)
[16:41:46] <huon> nmatsakis: an inclusive Iterator basically needs to have an extra bit of state internally to handle the 0...0 case, and we probably don't want to have the desugaring include that field
[16:47:00] <nmatsakis> huon: hmm. I think we should.
[16:47:09] <nmatsakis> I'll comment on the RFC though
[16:47:19] <nmatsakis> like, it'll be annoying that you can't do the same things with `a...b` as with `a..b`
[16:47:25] <nmatsakis> and we hope that things like
[16:47:36] <nmatsakis> `&vec[x...y]` are inlined and optimized anyway
[16:59:05] <huon> nmatsakis: you'll mainly have to convince aturon: he was vehemently against it :)
[16:59:14] <nmatsakis> heh :)
[16:59:15] <nmatsakis> ok
[16:59:20] <nmatsakis> I'm surprised
[17:05:30] *** Joins: Tobba (Tobba@moz-4l45on.skybroadband.com)
[17:12:31] <aturon> nmatsakis: basically i see both .. and ... as sugar for newtyped tuples of various kinds. it feels very weird to me to desugar to a struct with random other fields based on one particular use case of the notation
[17:12:48] <nmatsakis> *the* use case :)
[17:13:02] <nmatsakis> I guess I never saw them as sugar for tuples
[17:13:06] <sfackler> it could implement IntoIterator
[17:13:07] <nmatsakis> we have perfectly good notation for that (a, b)
[17:13:22] <nmatsakis> yeah, but that means if I write `(a..b).map(...)`
[17:13:25] <nmatsakis> and realize I want inclusive range
[17:13:28] <nmatsakis> everything is different now
[17:13:30] <aturon> sfackler: huon's RFC proposes IntoIterator, yes
[17:13:31] <nmatsakis> seems odd to me
[17:13:44] <aturon> nmatsakis: i agree that it's a downside, but iterators are not, in fact, the only use case :)
[17:13:50] <nmatsakis> there is one other one, right?
[17:13:55] <nmatsakis> &vec[1...3]?
[17:13:59] <nmatsakis> what is the other one?
[17:14:11] <aturon> there's also ranges for random number generation,
[17:14:24] <aturon> for operations like drain and other bulk operations on collections
[17:14:27] <nmatsakis> right
[17:14:38] <aturon> and i suspect more to come
[17:15:06] <nmatsakis> I suspect most all of them make transient use of the range and would not be harmed by an extra field
[17:15:40] <nmatsakis> I guess I just wish that a..b was not an iterator
[17:15:43] <nmatsakis> then i'd be happy
[17:15:49] <aturon> sure; i'm not worried about perf, just the strange inconsistency of the desugaring
[17:15:50] <aturon> yeah
[17:15:58] <nmatsakis> I mean you ahve to pick your inconsistency
[17:16:01] <nmatsakis> one of them is visible to users
[17:16:02] <nmatsakis> and one is not :)
[17:16:09] <nmatsakis> but yes
[17:16:11] <aturon> i mean, we could implement the various iterator adapters inherently
[17:16:24] <aturon> depends which "users" you mean
[17:16:32] <nmatsakis> I mean the ones typing a...b
[17:16:36] <nmatsakis> :)
[17:16:54] <nmatsakis> ...if you are on the receiving side, you can always discard the extra field
[17:16:57] <aturon> i guess i consider the semantics of language notation more sacrosanct than std :)
[17:16:58] <nmatsakis> but yes, we could do that I guess
[17:17:13] <aturon> i mean, i'm willing to be argued down here, to be clear
[17:17:21] <nmatsakis> it's a minor point
[17:17:50] <nmatsakis> I guess I'll ponder it -- but it feels like `a..b` and `a...b` look so similar, I think people will find it annoying which can be used in which way
[17:18:08] <nmatsakis> inherent methods might be a reasonable compromise, though of course that will be a "leaky abstraction"
[17:18:53] <aturon> yeah. this could be a case where i'm wrongly prioritizing "purity" of the lang definition over the pragmatics of the user experience
[17:22:23] <sfackler> it seems like in hindsight, the range types should have implemented IntoIterator instead of Iterator, but adding a private state field to RangeInclusive or whatever it's called seems like not the end of the world
[17:47:38] *** Quits: SilverKey (SilverKey@moz-liif3j.res.rr.com) (Quit: ZZZzzz…)
[18:00:44] *** Quits: Tobba (Tobba@moz-4l45on.skybroadband.com) (A TLS packet with unexpected length was received.)
[20:43:44] *** Quits: blank_name (blank_name@moz-onojo8.mi.frontiernet.net) (Ping timeout: 121 seconds)
[20:56:25] *** Joins: SilverKey (SilverKey@moz-liif3j.res.rr.com)
[21:20:55] <huon> nmatsakis: I would especially appreciate your feedback on https://internals.rust-lang.org/t/pre-rfc-simd-groundwork/2343
[21:21:07] <huon> and everyone elses too, of course
[21:29:34] <nmatsakis> huon: oh nice
[21:29:50] <nmatsakis> huon: sigh I'm still digging myself out of PRs and stuff on GH, totally overlooked internals lately :)
[21:31:56] <huon> nmatsakis: I literally just posted it, you haven't missed anything :P
[21:33:12] <huon> nmatsakis: (for context: the longer term plan is to hvae a SIMD.js-esque cross-platform API, and then some way to access the platform-specific "advanced" features)
[21:33:27] <nmatsakis> k
[21:33:30] <nmatsakis> yes I am on board with that plan
[21:33:43] <nmatsakis> and i'm happy to have precedent we can point at :)
[21:39:23] <jroesch> huon: looks good my questions are similar to what Brian and Niko posted 
[21:39:42] <huon> thanks for rading
[21:39:45] <huon> *reading
[21:44:50] <jroesch> huon: so the lack of strict typing is just to be flexible around newtypes?
[21:45:00] <jroesch> just reading a second over a second time to see if I missed anything
[21:45:22] <huon> jroesch: it's to be flexible about how this interacts with external crates
[21:47:55] <huon> basically, I'm not sure how to do it in any other way without lang items
[21:48:40] <huon> and lang items make versioning things trickier (it'd be required to have exactly one version of the simd crate linked into a final artifact, and that seems like an unpleasant restriction)
[21:48:44] <jroesch> so this allows other people to give us their SIMD data without having to plugin to a lang item 
[21:49:26] <huon> I think the "other people" is more likely to be simd 1.0 and simd 2.0 (where `simd` is my/rust-lang's official simd crate)
[21:50:24] <Elaine> huon: do you consider ifunc-like things for platform detection out-of-scope?
[21:50:34] <jroesch> huon: yeah I wasn't expecting the average user to use it
[21:50:48] <jroesch> just you, and or other expert people who want to use the functionality in a custom way
[21:51:38] <huon> Elaine: yes, I'm not sure our current compilation model is good enough for it
[21:52:18] <huon> Elaine: (AIUI, the normal way to do this in C/C++ is to compile separate object files with different target-features, which doesn't work so well for us now)
[21:52:42] <huon> jroesch: *theoretically* expert users will be able to get what they want from `simd`
[21:52:48] <huon> at least, thta's the long term goal
[21:52:52] <jroesch> cool
[21:52:57] <huon> and it'd be great to allow people to experiment
[21:53:12] * huon isn't omniscient
[21:53:13] <jroesch> I know there are some crazy simd people who love to build their own worlds on top 
[21:53:56] <jroesch> Carter in the Haskell community spent months building his own SIMD stuff, not sure whatever came of it but I imagine he would be the kind of person to build his own crate
[21:54:40] <Elaine> He's been around #rust and #rust-internals before too.
[21:56:15] <huon> yeah, we've actually chatted briefly a few times
[21:56:20] <huon> I'll get in touch with him
[21:56:58] <huon> However, I feel this RFC is fairly Rust specific, and isn't so interesting to non-Rusties
[21:57:09] <huon> certainly the higher-level APIs will benefit from broad feedback
[21:57:21] <Elaine> well, he is a rustie, he started porting his haskell stuff to rust a while ago
[21:57:29] <huon> oh, really
[21:57:34] <huon> didn't realise that...
[21:57:59] <Elaine> I think he gave up after a while, due to lacking type system. this was around 0.9 I think
[21:59:07] * huon pinged him
[22:08:40] <Elaine> huon: also, I don't know if you've seen it, but https://software.intel.com/sites/landingpage/IntrinsicsGuide/#!
[22:16:12] <huon> Elaine: that's like my favourite page
[22:16:20] <huon> (srsly, it's so great)
[22:16:27] <huon> thanks anyway :)
[22:18:13] <Elaine> The shuffle interface you expose is really high level.
[22:18:42] <Elaine> To the point where it's rather opaque to me, how it would be lowered.
[22:19:25] <Elaine> eg how would I write a one-vector swizzle?
[22:19:48] <Elaine> (ala vpshufd)
[22:20:28] <huon> Elaine: pass uninit
[22:20:44] <huon> Elaine: users generally won't use this directly
[22:20:46] <Elaine> are the simd intrinsics unsafe?
[22:20:49] <huon> yes
[22:20:50] <Elaine> ok, sure.
[22:21:12] <huon> I should probably mention it
[22:21:17] <huon> but I didn't mention that they were safe :P
[22:21:34] <Elaine> well, sure, but you didn't mention that they were unsafe either :P
[22:23:39] <Elaine> I'm just trying to see how code I've written and seen (which all uses intrinsics or asm directly) would map to this
[22:25:33] <Elaine> huon: masked comparisons?
[22:31:03] <Elaine> Also, for fused arithmetic, is the assumption that the compiler will optimize those?
[22:31:22] <Elaine> (eg a = a*b + c)
[22:31:29] <Elaine> or, b*c + d
[22:31:51] <Elaine> because I'm not sure if llvm will do that
[22:31:53] <huon> Elaine: there are intrinsics for all that
[22:32:04] <huon> if the platform supports masked comparisons there's an intrinsic for it
[22:32:12] <huon> if the platform supports fused arithmetic there's an intrinsic for it
[22:32:15] <Elaine> oh, ok.
[22:32:30] <Elaine> sorry, I guess that's implicit in the "operations" section
[22:32:42] <huon> it'll definitely be awesome if I can work out a nice way to expose this "fancy" stuff
[22:32:54] <Elaine> yes, I see now.
[22:32:56] <Elaine> sorry :)
[22:33:07] <huon> since not all platforms support it automatically it won't be in the basic safe/high-level API
[22:33:11] <huon> np :)
[22:33:19] <Elaine> right.
[22:34:10] <huon> I have a draft of the latter, which allows code like https://gist.github.com/huonw/e29c3f0b80a688444021
[22:34:26] <Elaine> heh, splat = broadcast?
[22:34:34] <Elaine> excellent name
[22:35:18] <huon> nmatsakis: incidetally, I haven't put any effort into comparison operators that return vectors, I'm unsure if I should try to tackle it.
[22:35:27] <huon> Elaine: yeah, it's great. unfortunately I can't take credit :P
[22:35:49] <huon> (e.g. SIMD.js uses splat too)
[22:36:28] <Elaine> What's this ecma crate?
[22:36:35] <huon> the API sketch
[22:36:35] <nmatsakis> huon: I'm personally inclined to use a distinct operator
[22:36:45] <Elaine> k
[22:36:57] <huon> Elaine: ecma == simd_ecmascript => https://github.com/tc39/ecmascript_simd
[22:37:38] <Elaine> aka SIMD.js?
[22:37:43] <huon> yup
[22:37:44] <Elaine> yeah
[22:38:00] <huon> nmatsakis: oh, yeah, I forgot that solution
[22:38:04] <huon> I'll write it down this time...
[22:38:49] <nmatsakis> huon: I've been wanting for a while to write an iterator-like API based on the flattening transform that desugars to SIMD ops (and multicore where appropriate)... see http://www.cs.rit.edu/~mtf/manticore/papers/ppopp13-flat.pdf featuring larsberg for some related work ... anyway, this woudln't be part of your proposal but rather somerthing I'd write on top
[22:47:07] <huon> nmatsakis: interesting
[22:47:25] <nmatsakis> huon: I worked out a lot of this in the context of PJS, but got distracted in the meantime :)
[22:47:32] <nmatsakis> I was originally writing it as JS code that used eval ;)
[22:47:51] <huon> haha
[22:47:57] <huon> JS cheats because it has a JIT/eval :P
[23:10:07] *** Joins: blank_name (blank_name@moz-i7g.dq5.36.50.IP)

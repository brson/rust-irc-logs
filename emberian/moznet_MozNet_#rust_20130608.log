[00:00:01] <pcwalton> I don't think a "custom GC" will really work
[00:00:07] <pcwalton> maybe it will
[00:00:15] <pcwalton> a fully custom GC anyway
[00:00:18] <bblum> strcat: sorry, i... am not paying 100% attention; can you draft a specific chunk of code that should compile but doesn't?
[00:00:25] <strcat> bblum: okay
[00:00:56] *** Quits: EXetoC (ex@moz-2DBEB1E4.customer.t3.se) (Quit: WeeChat 0.4.1)
[00:01:25] <Ralith> bstrie: GCs are pretty hard to make; why do you want a custom one?
[00:02:12] <bstrie> Ralith: just as a thought experiment
[00:02:35] <bstrie> *someone* out there is going to want a custom gc for rust eventually, I'm wondering if the language encourages that
[00:02:55] <Ralith> running multiple GCs in a single thread would require expensive indirection
[00:03:04] <cmr> Task, you mean?
[00:03:12] <Ralith> no, thread
[00:03:22] <bstrie> pcwalton: so then would moving GC into the stdlib mostly just be an exercise in making sure that the language can support custom pointers?
[00:03:30] *** Quits: infynyxx (infynyxx@DB780A29.749BA1D.DCC373F0.IP) (Client exited)
[00:03:50] <cmr> What extra overhead would it impose on threads that it doesn't on tasks?
[00:04:12] <Ralith> tasks execute on threads, so it would certainly impose it on tasks as well
[00:04:37] *** Quits: koomi (koomi@moz-B2B8B6D1.superkabel.de) (Quit: WeeChat 0.4.1)
[00:04:43] *** Quits: graydon (Adium@A5087023.2354C43D.D8E68FF6.IP) (Quit: Leaving.)
[00:05:22] <cmr> Way I see it, GC is already per-task, a different GC per task (even sharing the same thread) wouldn't hurt.
[00:05:27] <bstrie> pcwalton: because looking at these meeting minutes, it would be heartbreaking having to go from `@foo` to `alloc GC foo`
[00:05:33] <cmr> I could easily be wrong though :)
[00:05:45] <pcwalton> heartbreaking?
[00:05:53] <pcwalton> I think it'd be new GC foo anyway
[00:06:13] <Eridius> rusti: use std::to_bytes::ToBytes; 3u64.to_bytes()
[00:06:15] -rusti- more than 5 lines of output, pastebinned: http://sprunge.us/bije
[00:06:24] <Eridius> rusti: use std::to_bytes::ToBytes; 3u64.to_bytes(true)
[00:06:25] -rusti- ~[3, 0, 0, 0, 0, 0, 0, 0]
[00:06:50] *** Joins: dbaupp (Thunderbir@DD5A5B3.5DFF0E76.CCE6F5F4.IP)
[00:06:57] <Ralith> cmr: I was considering the case where you have GCs segregated by function, not by task
[00:07:08] <cmr> Ralith: Oh. Yeah, I can see that.
[00:07:10] <Ralith> in retrospect bstrie was talking about swapping GCs out from under code, not using multiple at once, though
[00:07:11] <bstrie> pcwalton: and the "new" would be for use only with GC?
[00:07:16] <cmr> Right.
[00:07:18] <dbaupp> strcat: thanks for landing that pr :)
[00:07:24] <pcwalton> in my head it's for unique pointers as well
[00:07:28] <pcwalton> but you'd just write new Foo
[00:07:34] <bstrie> instead of ~ ?
[00:07:34] <pcwalton> not new(~) Foo or whatever
[00:07:37] <pcwalton> yes
[00:07:39] <Ralith> if a GC is correct then it should work regardless, though code may make assumptions about performance that get invalidated
[00:07:41] *** Quits: hjr3 (hradtke@374E545A.3A8E9B0C.F9D9C60E.IP) (Quit: My MacBook has gone to sleep. ZZZzzzâ€¦)
[00:07:46] <cmr> pcwalton: That's a lot of syntax :S. I much prefer plain sigils.
[00:07:51] <bstrie> pcwalton: I'm sentimentally attached to ~ and @ :(
[00:08:39] <Eridius> pcwalton: I like ~ and @ :/
[00:08:52] <pcwalton> personally my problem with them is that they scare off newcomers
[00:09:13] <kimundi> no! no keywords :(
[00:09:15] <pcwalton> since the concepts are just foreign
[00:09:23] <pcwalton> if you say "GC" then it's obvious what it means
[00:09:44] <Eridius> pcwalton: ownership is a strange concept. having a sigil (~) to denote it I think helps
[00:09:55] <pcwalton> I'm open to being convinced otherwise
[00:10:03] <cmr> I don't disagree with you.
[00:10:09] <pcwalton> well, I think of ~ like malloc and free
[00:10:11] <cmr> I just don't prefer more verbose syntax for it.
[00:10:20] <pcwalton> anyway, I would be fine with keeping ~
[00:10:25] <strcat> Eridius: ~ doesn't denote ownership though
[00:10:28] *** Joins: infynyxx (infynyxx@DB780A29.749BA1D.DCC373F0.IP)
[00:10:41] <Eridius> strcat: it denotes owned pointers
[00:10:51] <strcat> Eridius: one implementation of them
[00:10:52] <bstrie> pcwalton: I don't have a technical argument, I just feel like ~ and @ are like totems that make the language unique
[00:11:39] <pcwalton> I like having a flavor
[00:11:54] <pcwalton> what I'm concerned about is being known as "that language with three kinds of pointers"
[00:12:08] <Eridius> pcwalton: 4 kinds ;)
[00:12:12] <flu_> ^^
[00:12:14] <pcwalton> right
[00:12:17] <flu_> that scared me off multiple times
[00:12:28] <cmr> rusti: let x = ~~~~~~~~@3;
[00:12:30] -rusti- ()
[00:12:35] <kimundi> pcwalton: I'd really like to keep ~. And I'd like to remind you again of my idea to turn @ into sugar for custom smartpointers :)
[00:12:39] <Eridius> pcwalton: honestly, the idea of having multiple different types of pointers/heaps is one of the things that actually intrigued me about Rust and caused me to look deeper
[00:12:54] <flu_> luckily reading through the rust for rubyists guide in its entirety + some entries on the wiki helped me get over my fear
[00:13:21] <cmr> pcwalton: I think simplyifying and expanding the syntax would be very useful for clarity.
[00:13:27] <cmr> I just don't prefer how it looks :)
[00:13:45] <pcwalton> because Rust isn't more complicated than C++ is, actually it's way simpler
[00:13:59] <strcat> bar.rs:17:24: 17:35 error: cannot borrow `(*xs)[]` as mutable more than once at a time
[00:14:01] <strcat> bar.rs:17             return Some(&mut xs[idx])
[00:14:04] <strcat>                                   ^~~~~~~~~~~
[00:14:05] <strcat> bar.rs:17:24: 17:35 note: second borrow of `(*xs)[]` as mutable occurs here
[00:14:07] <strcat> bar.rs:17             return Some(&mut xs[idx])
[00:14:09] <strcat> bblum: ^
[00:14:11] <strcat> bblum: borrows conflict with themselves on returns
[00:14:16] *** Quits: jensnockert (jensnocker@moz-8BE55278.customer.t3.se) (Input/output error)
[00:14:17] <strcat> they shouldn't, with an external iterator
[00:14:18] <bstrie> pcwalton: the reason I asked the question earlier about custom GCs was because I was curious if @ could ever possibly mean different things in different codebases. if you say that it's unlikely that someone would be able to drop-in replace the GC module in the stdlib, I'd really like it if @ could still be used to create them
[00:14:21] <strcat> the return *always* works
[00:14:22] <flu_> rust-buildbot: let c = @mut &~31.4e-1f32; c
[00:14:33] <flu_> rusti: let c = @mut &~31.4e-1f32; c
[00:14:36] -rusti- more than 5 lines of output, pastebinned: http://sprunge.us/IFYj
[00:15:01] <strcat> bblum: there are more examples but that's one I've run into in various forms many times in things like find_mut on the containers
[00:15:02] <flu_> heh. that worked on the compiler I was using last week
[00:15:29] <kimundi> pcwalton: We just need to present it differently: 1 safe ptr, one buildin smartpointer, n libary smartpointer
[00:15:48] *** Joins: devbug (quassel@moz-E1DE087C.bchsia.telus.net)
[00:16:16] <pcwalton> so in my dreams I'd have & as a "reference", * as ~, and then @ as Gc<> or @'gc or something
[00:16:38] <pcwalton> to me & and * seem way less scary than & and ~
[00:16:49] <pcwalton> since * passes the manager test
[00:16:54] <strcat> pcwalton: well the only thing the *language* calls & is a reference
[00:16:56] <flu_> heh
[00:16:57] <strcat> ref and ref mut ;p
[00:17:01] <bstrie> pcwalton: trying to repurpose * for unique pointers sets off alarm bells in my head.
[00:17:03] *** Joins: tjc (tjc@moz-69395CA0.hsd1.wa.comcast.net)
[00:17:03] *** ChanServ sets mode: +o tjc
[00:17:05] <Eridius> pcwalton: rust's ~ isn't the same as most other languages' *
[00:17:23] <pcwalton> this is all just bikeshedding though, don't take anything I say as "we are going to do this"
[00:17:40] <pcwalton> I mean, I think of ~ as malloc and free
[00:17:52] <kimundi> * is to overloaded imo
[00:18:03] <bstrie> yeah, I still want unsafe pointers to be ^ :)
[00:18:05] <Eridius> pcwalton: I don't. I think of ~ as ownership, and don't worry about [de-]allocation
[00:18:32] <strcat> but there's no reason to use ~ beyond adding indirection
[00:18:34] <bstrie> pcwalton: I've always hated that C used * for both the type of a pointer and as dereferencing a pointer. hated hated hated
[00:18:45] <pcwalton> I would just do unsafe pointers as Ptr<T> if we could ;)
[00:18:57] <cmr> Ugh. I'd hate writing FFIs
[00:19:03] <pcwalton> that's the problem
[00:19:14] <strcat> cmr: you should hate writing FFI
[00:19:19] <strcat> 99% of the FFI code we have is wrong
[00:19:24] <strcat> it uses * for mutable pointers
[00:19:26] <bstrie> yeah, I'm fine with FFI being painful
[00:19:29] <strcat> it looks good, but it's wrong
[00:19:32] <cmr> strcat: not the code I write :)
[00:19:44] <pcwalton> maybe Rust is just plain complex and we can't paper over it with syntax, but anyway
[00:19:57] <cmr> *mut is still better than Ptr<T> imo
[00:20:18] *** Quits: SimonSapin (simon@A5049320.3E93794D.61EA6C28.IP) (Quit: Leaving.)
[00:20:23] <bstrie> pcwalton: fight the good fight. be the language that brings linear types to the fore
[00:20:23] <cmr> pcwalton: exploring the syntax space is important
[00:20:47] <bstrie> don't let the folks who cry "alas, three pointers!" get to you
[00:21:04] <dbaupp> pcwalton: well, borrow checking failures are pretty hard to explain to beginners, as are lifetimes
[00:21:14] <bstrie> if you can come to terms with one pointer, *you are equipped to understand two more*
[00:21:18] <dymk> I'm still getting my head around lifetimes
[00:21:29] <pcwalton> well, look at it this way, the design of the language is as a better C++
[00:21:42] <bstrie> yes, I agree :)
[00:21:43] <pcwalton> it's designed to be used for systems code, like OS kernels
[00:21:43] *** Joins: erickt (erickt@8C9ECD8F.3A598286.F12515B4.IP)
[00:22:09] <pcwalton> if you don't care about managing your memory for performance or flexibility, then use Go instead
[00:22:10] *** Quits: erickt (erickt@8C9ECD8F.3A598286.F12515B4.IP) (Quit: Leaving.)
[00:22:22] <pcwalton> or whatever
[00:22:31] <dymk> I've heard that Rust is moving away from a GC and more towards ref counting for managed pointers; is this true?
[00:22:37] <pcwalton> opposite
[00:22:45] <cmr> dymk: it's refcounting now, to become a GC
[00:22:52] <dymk> Oh, alright
[00:23:10] <cmr> Only for @ though, there are still refcounted types
[00:23:30] <dymk> and then, when that's implemented, are programs which don't use managed pointers just compiled without a GC?
[00:23:37] *** Joins: hjr3 (hradtke@374E545A.3A8E9B0C.F9D9C60E.IP)
[00:23:42] <pcwalton> to be on equal footing with C++ while still staying safe, the language needs to provide the lowest-level primitives that it can for memory management
[00:23:48] <pcwalton> and ~ is about as low level as you can go
[00:24:00] <pcwalton> and remain safe
[00:24:00] <pcwalton> if you had malloc and free then you'd lose exception safety
[00:24:12] <dymk> where ~ is staticaly checked std::uniq_ptr, no?
[00:24:35] <pcwalton> yup
[00:24:38] *** Joins: bytbox (s@moz-D83E9B31.wireless.umd.edu)
[00:24:51] <dymk> hmkay
[00:25:02] <strcat> pcwalton: https://github.com/mozilla/rust/issues/6997#issuecomment-19138751 about for loops
[00:25:07] <dymk> when the GC is implemented, will it be thread local, or "stop the world" for all threads? 
[00:25:12] <pcwalton> thread local
[00:25:12] <strcat> task-local
[00:25:29] <strcat> if you opt-in to using @ at all
[00:25:31] <bblum> bstrie: i always thought about it like this: having extra builtin pointer types is just the type-system being honest about all the semantically different pointer use cases that the programmer should worry about
[00:25:43] <dymk> ah right, rust does its own scheduling
[00:25:59] <bblum> high-level languages hide pointer types because programmers don't need to worry about them
[00:26:12] <bblum> low-level languages lie about the pointer types and then make up for the deficit with clunky libraries
[00:27:24] <pcwalton> well, keep in mind that Go has explicit pointers and is way easier as far as memory management is concerned
[00:27:36] <pcwalton> as evidenced by its uptake
[00:27:42] <bblum> doesn't go not give you control over GC though
[00:27:47] <pcwalton> right, it doesn't
[00:27:52] <strcat> pcwalton: I'd argue that's more about having a standard library which doesn't suck
[00:27:54] <pcwalton> it doesn't give control over stack vs heap allocation
[00:28:02] <pcwalton> no, I think the language is just easier in many ways
[00:28:09] <pcwalton> and I'm OK with that
[00:28:13] *** Joins: MaikKlein (maik@moz-76A64E0E.dip0.t-ipconnect.de)
[00:28:46] <flu_> +1 for pimped out standard libraries
[00:28:53] <pcwalton> Rust should play to its strengths, namely deterministic, low-level control over memory management
[00:28:55] <flu_> see Scala for an example of effing amazing collections
[00:28:57] <pcwalton> and safety
[00:29:23] *** Quits: mschifer (Adium@2557E599.66715431.D25A875A.IP) (Quit: Leaving.)
[00:29:25] <strcat> flu_: I don't really agree, there are libraries with nicer collections
[00:29:39] <bblum> we don't have pimped out libraries :(
[00:29:40] <strcat> D ranges
[00:29:43] <flu_> strcat: best I've had the pleasure of working with :-)
[00:29:46] <cmr> Were any decisions/action items made in this weeks meetings? I didn't really see any, but I wasn't reading the notes too carefully.
[00:30:02] <strcat> Boost.Range is nicer than most languages too. and that's a low-level language
[00:33:42] *** Joins: koomi (koomi@moz-E8AECC1E.pools.arcor-ip.net)
[00:34:09] <cmr> bblum: toddaaro: sully: are you the only interns?
[00:34:31] <bblum> i think we are the only rust interns
[00:34:35] <bblum> there are several servo interns
[00:34:49] *** Quits: jdm (jdm@F2D29657.F60B0462.67AC9B1.IP) (Quit: Lost terminal)
[00:35:04] <cmr> Ehh I don't care about servo yet
[00:35:08] <cmr> Thanks :)
[00:35:32] <strcat> bblum: https://mail.mozilla.org/pipermail/rust-dev/2013-June/004364.html I don't know if you've read this already
[00:35:42] <bblum> i haven't, thanks
[00:36:01] *** Joins: ssbr (ssbr@moz-F4C1E66D.dsl.bell.ca)
[00:36:37] <pcwalton> maybe @ -> ~gc
[00:36:44] *** Quits: azita (Azita@moz-C1FB2A8.hsd1.ca.comcast.net) (Quit: azita)
[00:37:04] <pcwalton> I think one of the issues is that the language isn't opinionated enough about guiding people to use ~
[00:37:14] <pcwalton> we could have & = reference, ~ = smart pointer
[00:37:20] <pcwalton> (and * = dumb pointer)
[00:37:30] <cmr> Rust for Rubyists used @ a lot where it was unnecessary, until I made it not.
[00:37:32] <bblum> ~gc?
[00:37:49] <pcwalton> beginners end up confused a lot about whether to use @ or ~
[00:37:54] <pcwalton> and the answer is almost always !~
[00:37:54] <pcwalton> err
[00:37:55] <pcwalton> ~
[00:37:56] <Eridius> I don't like overloading ~ to mean two things
[00:38:01] <flu_> cmr: is the source for RfR on github or something? Found a few minor typos worth correcting yesterday
[00:38:02] *** Quits: ssbr (ssbr@moz-F4C1E66D.dsl.bell.ca) (Ping timeout)
[00:38:15] <flu_> by source I mean the markdown or whatever generates it
[00:38:19] <cmr> flu_: it's a private repo. send 'em to me in a query, I'll fix it
[00:38:24] <Eridius> incidentally, in my code I have never used @, except once in an attempt to work around a borrowck bug (which subsequently got "fixed" to disallow the @ workaround)
[00:38:24] <flu_> k
[00:38:25] *** Joins: ssbr (ssbr@moz-F4C1E66D.dsl.bell.ca)
[00:38:40] <pcwalton> Eridius: right. that's how most everyone writes modern Rust
[00:38:41] <Eridius> the closest I've come in code that compiles with current rustc that uses @ is in calling std::rand::task_rng
[00:38:50] <tikue> rusti: enum Foo { Bar, Baz }; repr(Bar)
[00:38:52] -rusti- more than 5 lines of output, pastebinned: http://sprunge.us/QHEJ
[00:38:52] <strcat> pcwalton: well it should mostly be stack allocation and borrowed pointers anyway
[00:39:00] <sam1> are there many rubyists here?
[00:39:26] <cmr> sam1: not afaik, but RfR is very ruby-agnostic and an all-around-easy introduction to rust
[00:40:15] <pcwalton> basically one of the big ideas that I was pushing is: beginners are confused by the presence of @ when they should probably avoid it and learn it later only when they learn the limitations of ~
[00:40:23] <pcwalton> you have to learn ~ and & anyway to write rust
[00:40:28] <cmr> Definitely.
[00:40:30] <pcwalton> just using @ isn't an option because of libraries and sharing
[00:40:30] <strcat> pcwalton: I think unique pointers outside of data structure implementations are usually code smell
[00:40:42] <pcwalton> strcat: even better is to not allocate at all, of course :)
[00:40:45] <strcat> pcwalton: and @/@mut are almost always code smell in rust, to me
[00:40:51] <pcwalton> yup
[00:40:54] <strcat> especially @mut since you throw out static mutability checking
[00:41:03] <strcat> iterator invalidation? welcome back.
[00:41:05] <strcat> ;p
[00:41:10] <pcwalton> exactly
[00:41:11] <cmr> pcwalton: Perhaps it shouldn't even be in the tutorial?
[00:41:29] <pcwalton> cmr: that's what jclements suggested a while back and I'm inclined to agree, at least put it at the end
[00:41:29] <strcat> I think it should be but the tutorial should be done differently
[00:41:30] <pcwalton> also
[00:41:40] <pcwalton> a lot of libraries are going to want to use reference counting anyway
[00:42:01] *** Quits: dherman-babyduty (dherman@moz-6CA476B1.hsd1.ca.comcast.net) (Quit: dherman-babyduty)
[00:42:17] <pcwalton> because you're usually a better citizen that way (for example, kernel space or games are both huge strengths of Rust and both use reference counting a lot, and GC is rarely used in either)
[00:42:26] <pcwalton> mobile games on android may use GC, and minecraft
[00:42:31] <pcwalton> but they're the exception
[00:42:38] <strcat> minecraft has very visible gc pauses ;p
[00:42:46] <pcwalton> :)
[00:43:13] <cmr> pcwalton: well bblum wants to introduce controlling where GC can happen with the effect system afaik
[00:43:18] <cmr> which is super useful in games
[00:43:19] *** Joins: thou (thou@moz-1C1CA9F7.fasttrackcomm.net)
[00:43:19] <Eridius> iiiiiiiiiiiiiii
[00:43:20] <strcat> pcwalton: as does all of android :)
[00:43:27] <Eridius> <<<<<<<<<<<<<<<a<<ck<< m<<y< <<c<a<t< <i<s <o<n< <m<<y< <k<e<y<b<o<a<rd<
[00:43:32] <pcwalton> aww
[00:43:39] <strcat> I notice UI pauses on my nexus 10 despite the gpu accel
[00:44:09] * strcat blames dalvik
[00:44:16] <mark_edward> damn Dalvik
[00:44:17] <cmr> (I love how "games" is now equivalent to "soft realtime")
[00:44:24] <bblum> cmr: gc + destructors + effects is a problem for effects other than GC
[00:44:26] <mark_edward> you ever written an android app?
[00:44:27] <pcwalton> in fact I'd say the Big Idea in Rust may well be the fact that unique pointers + references, statically checked, make dynamic memory management unnecessary for 99% of cases, *and* provide the tools for race-free concurrency and mutability
[00:44:28] <moonchrome> pcwalton, task local GC should mean only task local pauses right ? so GC isn't that bad if you can isolate it, in fact it might be preferable to refcounting for performance reasons
[00:44:41] <pcwalton> moonchrome: yes, in many cases
[00:44:48] <bblum> pcwalton: I still worry about circularly-linked data structures
[00:44:51] <bblum> like an LRU
[00:44:58] <moonchrome> pcwalton, I meant for games
[00:45:03] <strcat> moonchrome: it will perform better if you copy the references around a lot
[00:45:06] <mark_edward> strcat: have you ever written an android app?
[00:45:21] <strcat> mark_edward: no, just android-scripting stuff
[00:45:23] <bblum> i was thinking of hacking tgether an Owned LRU using unsafe pointers, and looking at it really hard to make sure the interface was safe
[00:45:26] <pcwalton> moonchrome: maybe. depends on how multithreaded it is of course.
[00:45:36] *** Joins: ghrust (ghrust@24260B07.6A2AE50.F3114085.IP)
[00:45:36] <ghrust> 01[13rust01] 15bors pushed 0 new commits to 06auto: 02http://git.io/371HnA
[00:45:36] *** Parts: ghrust (ghrust@24260B07.6A2AE50.F3114085.IP) ()
[00:45:39] *** Quits: cdidd (cdidd@moz-AFAFD3B0.broadband.corbina.ru) (Input/output error)
[00:45:44] <mark_edward> strcat: when there is an exception, you see that it get's thrown up through like
[00:45:59] <mark_edward> 20 layers of virtual calls and stuff
[00:46:04] <mark_edward> ridiculous
[00:46:41] *** Quits: heftig (heftig@moz-B679706C.dip0.t-ipconnect.de) (Quit: Quitting)
[00:46:55] *** Joins: heftig (heftig@moz-B679706C.dip0.t-ipconnect.de)
[00:47:04] *** Joins: jorendorff (jorendorff@moz-2F32ACA3.hsd1.tn.comcast.net)
[00:47:14] <sam1> ruby is my favorite language, IÂ thought IÂ should also learn a compiled language and was hesitating between C++ and rust
[00:47:35] *** Quits: jorendorff (jorendorff@moz-2F32ACA3.hsd1.tn.comcast.net) (Quit: jorendorff)
[00:47:48] <bstrie> pcwalton: I'm totally fine with having @ as GC (though a new keyword for it would be a little unfortunate), but I'm very attached to ~ for unique pointers. I agree that idiomatic rust should always be using & and ~, and it takes a lot of bite out of the critics if they're reduced to saying "TWO pointer types? preposterous"
[00:48:07] <strcat> we should just start calling & a reference, imo
[00:48:10] <bstrie> I agree
[00:48:17] <dbaupp> strcat: decide for me! rev_iter() -> VecRevIterator or reverse_iter() -> VecRevIterator?
[00:48:18] <bstrie> then we're down to one pointer type in safe code
[00:48:27] *** Quits: Jesin (Jessin_@moz-3AD6F09F.res.lehigh.edu) (Connection reset by peer)
[00:48:41] *** Joins: Jesin (Jessin_@moz-3AD6F09F.res.lehigh.edu)
[00:48:43] <bstrie> "ONE pointer type? ludicrous"
[00:49:18] <bstrie> so we just got a documentation PR from someone involved in Elixir
[00:49:22] <strcat> dbaupp: leaning towards rev_iter
[00:49:23] <bstrie> so that's pretty cool
[00:49:38] <dbaupp> strcat: same, so I'll go with that
[00:49:39] *** Quits: tjc (tjc@moz-69395CA0.hsd1.wa.comcast.net) (Quit: zzzzzzzzzz)
[00:50:17] <dbaupp> strcat: and do we need a VecRevMutIterator?
[00:50:22] <bjz> moonchrome: I've moved the vec module over to macros
[00:50:24] <strcat> dbaupp: yeah
[00:50:36] <strcat> dbaupp: we don't need any more after that though. you can just use slices to iterate over a range
[00:50:45] <bjz> moonchrome: now currently working on the matricies and quaternions
[00:50:50] <dbaupp> strcat: yeah
[00:50:54] <moonchrome> bjz, pushed it ?
[00:51:02] <bjz> moonchrome: not yet
[00:51:08] <bstrie> so if we can get that elixir guy, AND armin ronacher from python, AND steve klabnik from ruby, AND tj holowaychuk from javascript, maybe we can assemble the all-star dynamic language dream team
[00:51:15] <strcat> dbaupp: so we'll have 4 iterators on vec/str and we won't need any of the hardcoded adaptor ones
[00:51:24] <bjz> moonchrome: it'll break matricies, and quats, which is why I haven't
[00:51:31] <dbaupp> strcat: yup, it'll be awesome
[00:51:36] <pcwalton> bstrie: ~ for unique pointers is the one I'm happiest with keeping
[00:51:37] *** kimundi is now known as zz_kimundi
[00:51:43] <pcwalton> because, honestly, ~ is a good primitive, it's even in C++
[00:51:43] <moonchrome> bjz, might as well make a new repo for it :)
[00:51:44] <dbaupp> strcat: wait... we'll probably want SplitIterators for str
[00:51:45] <pcwalton> it's called operator new!
[00:51:48] <strcat> oh good I think my daily build will be done soon
[00:51:52] <moonchrome> bjz, doesn't seem it will be compatible with the current
[00:52:00] <bjz> moonchrome: oh no, it will be compatible
[00:52:01] <strcat> dbaupp: right. and vectors too
[00:52:12] <bjz> moonchrome: pretty much compatible
[00:52:23] <moonchrome> bjz, IIRC you use add_v instead operators in current one right ?
[00:52:33] <moonchrome> bjz, *operator traits
[00:52:44] <bjz> moonchrome: yeah, unfortunately
[00:53:12] <moonchrome> bjz, but with macros you can implement operators easily, I'm not sure if you can overload vec to float
[00:53:21] <moonchrome> bjz, had some issues with that yesterday
[00:53:33] <bjz> moonchrome: indeed, I know how to do it though
[00:53:46] <bjz> moonchrome: I just need to implement it ;)
[00:53:47] <bjz> https://gist.github.com/bjz/bf186d9c61812c8fe01d
[00:54:00] <bjz> moonchrome: I'm going to change that slightly though
[00:54:25] <bjz> moonchrome: also look, this was an example jensnokert was doing: https://gist.github.com/JensNockert/5733166
[00:54:33] <bjz> moonchrome: with macros as well
[00:55:21] <pcwalton> I think I improved trans perf by 7% by making crate ctxt into an unsafe ptr
[00:55:26] <pcwalton> speaking of reference counting
[00:55:37] *** Quits: infynyxx (infynyxx@DB780A29.749BA1D.DCC373F0.IP) (Client exited)
[00:56:43] <bjz> MaikKlein: see above ^
[00:57:06] <bjz> MaikKlein: hopefully we will have it working before the day is out
[00:57:07] <moonchrome> bjz, why not write a generic macro define_vec that takes components as arguments , eg. https://gist.github.com/moonchrome/5725536
[00:57:53] *** Quits: bent (chatzilla@moz-932324BF.hsd1.ca.comcast.net) (Quit: ChatZilla 0.9.90-rdmsoft [XULRunner 18.0.2/20130201065344])
[00:57:56] <bjz> moonchrome: cross?
[00:58:01] <moonchrome> bjz, so you have only one define_vec! - that's what macros are for
[00:58:02] <cmr> pcwalton: damn
[00:58:15] <pcwalton> hmm, GEPi allocates
[00:58:19] <moonchrome> bjz, see how I did dot
[00:58:23] <pcwalton> let's just remove it, the interface can't be fixed to be efficient
[00:58:32] <bjz> moonchrome: perp_dot?
[00:58:43] <bjz> moonchrome: (only implemented for vec2s)
[00:59:08] <moonchrome> bjz, just add a macro impl_cross that returns nothing for any other vector and returns cross fn for the one that has 3 components
[00:59:16] <true_droid> is { â€¦ } called a block in Rust?
[00:59:22] <bblum> yes
[00:59:27] <moonchrome> bjz, and then stick that in the define_vec! body
[00:59:29] <true_droid> ty
[00:59:30] <bjz> moonchrome: you can't have macros inside impls :(
[00:59:38] <bjz> moonchrome: it's a bug
[01:00:02] <moonchrome> bjz, but I did it for the dot function implementation in my code
[01:00:08] *** Quits: hjr3 (hradtke@374E545A.3A8E9B0C.F9D9C60E.IP) (Quit: My MacBook has gone to sleep. ZZZzzzâ€¦)
[01:00:18] <moonchrome> bjz, it returns 3 different versions for 3 different component combinations
[01:00:46] <bjz> moonchrome: not as in, if you want a macro to expand to become a method
[01:00:53] <bjz> not inside the method itself
[01:01:11] <bjz> I'm talking about item macros, not expression macros
[01:01:12] *** Quits: tikue (tkuehn@2557E599.66715431.D25A875A.IP) (Quit: tikue)
[01:01:25] <moonchrome> bjz, that's rather bizarre 
[01:01:34] <bjz> moonchrome: as I say, a bug
[01:01:50] <bjz> moonchrome: same with expanding to multiple items
[01:02:08] <moonchrome> bjz, I mean as a bug, bizarre that it would fail in that specific case - no macros inside impls 
[01:02:11] <bjz> moonchrome: it will be fixed I'm sure, just not the highest priority
[01:02:33] <bjz> moonchrome: it's because of the way impls are, well implemented on the compiler side
[01:02:36] <bjz> I think
[01:03:20] <bjz> moonchrome: adds a bit of complexity apparently
[01:03:26] <moonchrome> bjz, still you can overload the body and just have empty functions for all other vector types - nasty hack but it's just until it gets fixed 
[01:03:45] *** Joins: cdidd (cdidd@moz-3B6805BF.broadband.corbina.ru)
[01:04:05] <bjz> moonchrome: true, we could fail on those cases
[01:04:13] *** Joins: tjc (tjc@moz-44841960.tukw.qwest.net)
[01:04:13] *** ChanServ sets mode: +o tjc
[01:04:26] <bjz> moonchrome: the issue is also when we get to matricies
[01:04:48] <bjz> moonchrome: as some of the methods are also dimension-specific
[01:05:03] <bjz> I would rather just live with the copied code for now
[01:05:30] <moonchrome> bjz, yeah it's a hack around no associated items anyway
[01:05:41] <moonchrome> bjz, doesn't need to be pretty 
[01:05:43] <bjz> moonchrome: but we'll aim to do that in the future aywayn
[01:05:56] <bjz> *anyway
[01:05:57] <moonchrome> bjz, hopefully in the future no macros at all
[01:06:11] <bjz> hopefully
[01:06:20] *** Quits: eatkinson (eatkinson@2557E599.66715431.D25A875A.IP) (Quit: eatkinson)
[01:06:29] *** Quits: dymk (dymk@44EEE21C.A6E21E6E.5E500FC7.IP) (Ping timeout)
[01:06:57] <moonchrome> bjz, btw what was that issue that was blocking dynamic gl loader 
[01:07:15] <moonchrome> bjz, if you have it bookmarked
[01:08:33] *** Joins: SimonSapin (simon@5924A8D9.7F79A810.4065847B.IP)
[01:08:51] <flu_> anybody here know erickt on github? I'd love to take ownership of rust-zmq if he's abandoning it
[01:09:01] <cmr> erick: that's you right?
[01:09:05] <bstrie> flu_: erickt is on here a lot
[01:09:05] *** Quits: SiegeLord (siege@moz-CAF07B4C.hsd1.ma.comcast.net) (Connection reset by peer)
[01:09:06] <bjz> moonchrome: https://github.com/mozilla/rust/pull/6661
[01:09:08] <cmr> too many erics!
[01:09:19] <flu_> haha, gotcha. I'll peep the /names list periodically
[01:09:26] <bjz> flu_: you could always make an issue on his repo too
[01:09:46] <bjz> moonchrome: I believe poor nmatsakis is still having trouble with windows
[01:09:51] <flu_> sent a pull request, but I think an issue of 'GIMME UR REPO' might be a bit much :-P
[01:09:57] *** Quits: snearch (snearch@moz-C8C93E58.pool.mediaways.net) (Quit: Verlassend)
[01:09:57] * bjz shakes fist at windows
[01:10:21] <bjz> flu_: it would be nice if there was a way on github to PM maintainers
[01:10:39] <cmr> Yeah... I don't know why they removed the PM feature.
[01:10:58] <flu_> bjz: cmr: agreed. not like there are a ton of spammers there (thank god) 
[01:11:09] *** Quits: eschweic (Adium@2557E599.66715431.D25A875A.IP) (Quit: Leaving.)
[01:12:34] <MaikKlein> what do you think of http://kentonv.github.io/capnproto/ ?
[01:13:41] <cmr> MaikKlein: looks handy
[01:15:21] <cmr> Looks really handy.
[01:15:24] <cmr> I like it.
[01:16:59] *** Joins: SiegeLord (sl@moz-CAF07B4C.hsd1.ma.comcast.net)
[01:17:40] <MaikKlein> I mean this could be used for task communication right?
[01:18:08] <moonchrome> "Think JSON, except binary." this makes me think of bad things :(
[01:19:51] <MaikKlein> or what do you think are the main use cases?
[01:21:56] <cmr> MaikKlein: Using it for task communication would be pointless.
[01:22:03] <cmr> Just pass structs around directly.
[01:22:15] <cmr> I'd use it for RPC and IPC
[01:23:17] *** Quits: true_droid (Adium@moz-123FD9B8.beck.volia.net) (Quit: Leaving.)
[01:23:24] <moonchrome> cmr, well if you wanted to be able to transparently communicate with tasks the same way you do with processes and remotes it's a good way to define your API
[01:23:38] <xenocons> rusti: (~[1u]).unsafe_ref(0)
[01:23:38] <cmr> moonchrome: sure
[01:23:39] <xenocons> rusti: (~[1u]).unsafe_ref(0);
[01:23:42] -rusti- more than 5 lines of output, pastebinned: http://sprunge.us/UMYd
[01:23:42] -rusti- more than 5 lines of output, pastebinned: http://sprunge.us/JbKa
[01:24:02] <xenocons> rusti: unsafe { (~[1u]).unsafe_ref(0); }
[01:24:03] -rusti- ()
[01:24:11] <bjz> OOH
[01:24:22] <bjz> they fixed the unsafe method thingy!
[01:24:24] <bjz> yay!
[01:24:29] <xenocons> hm
[01:24:44] <xenocons> type `~[u8]` does not implement any method in scope named `unsafe_ref`
[01:24:44] <dbaupp> bjz: but now (some) plain functions are incorrect
[01:25:09] *** Joins: erickt (Adium@49C4075F.3AC15C18.2321E71E.IP)
[01:25:10] <strcat> one step forward, one step back
[01:25:12] <strcat> :D
[01:25:23] <xenocons> is there some special scoping i need to use? (im already using unsafe {})
[01:25:53] *** Joins: infynyxx (infynyxx@DB780A29.749BA1D.DCC373F0.IP)
[01:26:11] <SiegeLord> Is there a trait that allows a type to be converted to a scalar (float in my case)?
[01:26:28] <pcwalton> SiegeLord: NumCast
[01:26:32] <bjz> SiegeLord: what type?
[01:26:32] <cmr> bjz: it's been fixed for a bit
[01:26:34] <cmr> Where do you think all the warnings in stage0 were coming from? :P
[01:26:38] <strcat> NumCat is hardcoded for the built-ins though
[01:26:50] <bjz> SiegeLord: we need to add better num conversions
[01:26:50] <strcat> well, I guess a type could implement them all...
[01:26:53] <dbaupp> SiegeLord: there isn't really a proper generic one
[01:27:14] <dbaupp> rusti: unsafe { (~[1u]).unsafe_ref(0) }
[01:27:14] -rusti- 140649905062032
[01:27:17] <bjz> SiegeLord: I have been attempting to bring it up on the numeric issue
[01:27:23] <SiegeLord> Hmm...
[01:27:23] <dbaupp> xenocons: it seems to work here?
[01:27:31] <SiegeLord> I guess I'll use NumCast for now then
[01:27:32] <bjz> dbaupp: suggestions welcome :)
[01:27:41] <bjz> SiegeLord: it's not ideal, sorry
[01:27:54] <dbaupp> bjz: yeah, I've been involved in the discussion ;)
[01:28:06] <xenocons> dbaupp: could it be that it doesnt work in 0.6 release?
[01:28:10] <dbaupp> I don't really have anything to offer that hasn't been brought up already
[01:28:17] <bjz> SiegeLord: we need a more generic one, maybe on num or fractional
[01:28:17] <dbaupp> xenocons: oh.. yes probably
[01:28:20] <strcat> rusti: use std::iterator::*; let xs: ~[int] = Counter::new(10, 0).take(5).collect(); xs
[01:28:21] -rusti- ~[10, 10, 10, 10, 10]
[01:28:28] <dbaupp> :D
[01:28:32] <xenocons> hmm
[01:28:34] <strcat> rusti: use std::iterator::*; let xs: ~[int] = Counter::new(10, 2).take(5).collect(); xs
[01:28:36] -rusti- ~[10, 12, 14, 16, 18]
[01:28:37] <bjz> dbaupp: from_float on fractional?
[01:28:38] <dbaupp> strcat: is collect generic?
[01:28:40] <xenocons> is there a way in 0.6 to get an unsafe ref?
[01:28:42] <strcat> dbaupp: yes
[01:28:49] <strcat> dbaupp: but it's only implemented for vectors
[01:28:54] <strcat> FromIter
[01:28:56] <strcat> in iter.rs
[01:29:05] <dbaupp> strcat: heh, that's the best sort of generic! ;P
[01:29:11] <dbaupp> bjz: dunno
[01:29:13] <dbaupp> bjz: probably
[01:29:32] <bjz> dbaupp: and where do complex numbers fit in?
[01:29:32] <dbaupp> strcat: each[i]_reverse is dying
[01:29:40] <strcat> rusti: use std::iterator::*; let xs: ~[int] = Counter::new(10, 12).take_while(|x| *x < 100).collect(); xs
[01:29:41] -rusti- ~[10, 22, 34, 46, 58, 70, 82, 94]
[01:29:53] <strcat> rusti: use std::iterator::*; let xs: ~[int] = Counter::new(10, 12).take_while(|x| *x < 100).transform(|x| x * 2).collect(); xs
[01:29:54] -rusti- ~[20, 44, 68, 92, 116, 140, 164, 188]
[01:29:55] <dbaupp> bjz: for from_float: just map x -> x + 0i
[01:30:14] <bjz> strcat: will the iterator proposals reduce that verbosity?
[01:30:25] <strcat> bjz: well we could call it count(10, 12)
[01:30:33] <strcat> the other stuff isn't really verbosity ;p
[01:30:38] <strcat> it's a pointless example though.
[01:30:48] <strcat> bjz: in the future
[01:30:53] <MaikKlein> rusti: use std::iterator::*; let xs: ~[int] = Counter::new(10, 12).take_while(|&x| x < 100).collect(); xs
[01:30:54] -rusti- ~[10, 22, 34, 46, 58, 70, 82, 94]
[01:30:55] <dbaupp> bjz: the iterators proposal will reduce the verbosity of `for` and iterators
[01:31:13] <strcat> let xs = [1, 2, 3]; let ys = [4, 5, 6]; for xs.zip(ys) |(x, y)| { ... }
[01:31:15] <strcat> that could be valid
[01:31:28] <strcat> if 'for' knew about Iterator and a yet-to-be-implemented Iterable
[01:32:00] <strcat> atm it's...
[01:32:14] *** Quits: infynyxx (infynyxx@DB780A29.749BA1D.DCC373F0.IP) (Ping timeout)
[01:32:31] <SiegeLord> rusti: let a = 1.iter();
[01:32:33] -rusti- more than 5 lines of output, pastebinned: http://sprunge.us/KfGj
[01:32:35] <strcat> rusti: let xs = [1, 2, 3]; let ys = [4, 5, 6]; for xs.iter().zip(ys.iter()).advance |(x, y)| { println(fmt!("%? %?", x, y)) }
[01:32:43] -rusti- more than 5 lines of output, pastebinned: http://sprunge.us/ScTI
[01:32:58] <strcat> rusti: use std::iterator::*; let xs = [1, 2, 3]; let ys = [4, 5, 6]; for xs.iter().zip(ys.iter()).advance |(x, y)| { println(fmt!("%? %?", x, y)) }
[01:33:00] -rusti- &1 &4
[01:33:00] -rusti- &2 &5
[01:33:00] -rusti- &3 &6
[01:33:00] -rusti- ()
[01:33:02] <dbaupp> strcat: we *really* need IteratorUtil in the prelude :(
[01:33:10] <dbaupp> damn method conflicts :/
[01:33:12] <strcat> dbaupp: well we need that method resolve bug fixed ;p
[01:33:16] <SiegeLord> It would be pretty convenient if scalars implemented iter()...
[01:33:44] <strcat> SiegeLord: count(start, step), range(start, stop, step) are things we can have
[01:33:49] <strcat> what would it do on scalars?
[01:33:50] <dbaupp> SiegeLord: with what behaviour? iterate once, or repeat indefinitely?
[01:33:57] <SiegeLord> Repeat infinitely
[01:34:04] <strcat> we can't do that
[01:34:06] <SiegeLord> Otherwise you'd use [1].iter()
[01:34:08] *** Quits: SimonSapin (simon@5924A8D9.7F79A810.4065847B.IP) (Quit: Leaving.)
[01:34:09] <strcat> it would conflict with explicit impls
[01:34:19] <strcat> SiegeLord: we can have a repeat iterator
[01:34:30] <SiegeLord> Yes... that would work too
[01:35:18] <strcat> dbaupp: anyway I think 'count' is a better constructor name than Counter::new() because there aren't conflicting names
[01:35:31] <strcat> not sure if others will agree
[01:35:32] *** Quits: carllerche (carllerche@moz-BF6CB667.hsd1.ca.comcast.net) (Quit: carllerche)
[01:35:32] <dbaupp> strcat: I agree
[01:35:33] <strcat> but...
[01:35:39] <strcat> count(0, 10) vs Count::new(0, 10)
[01:35:55] <strcat> for range(0, 10, 2) |x| {}
[01:35:58] <strcat> for range(0, 10, 2).zip(xs) |x| {}
[01:36:03] <strcat> for range(0, 10, 2).zip(xs) |(x, y)| {} *
[01:36:29] <strcat> not much different than python. where you'd have
[01:36:38] *** Joins: ghrust (ghrust@24260B07.6A2AE50.F3114085.IP)
[01:36:38] <ghrust> 01[13rust01] 15bors merged 06auto into 06incoming: 02http://git.io/Y1L1ow
[01:36:38] *** Parts: ghrust (ghrust@24260B07.6A2AE50.F3114085.IP) ()
[01:36:46] <strcat> for x, y in zip(range(0, 10, 2), xs):
[01:37:12] <MaikKlein> wouldn't it be much better if we could skip the .iter? like xs.iter().zip -> xs.zip
[01:37:30] <strcat> MaikKlein: we'd need Iterable and default methods
[01:37:38] <strcat> it can't be done until default methods work
[01:37:49] <strcat> we can't have O(n) 'find' on hashmap ;p
[01:37:50] <MaikKlein> is it planed?
[01:37:58] <strcat> MaikKlein: they are supposed to work, it will get fixed
[01:38:04] <xenocons> map with RBT
[01:38:07] <MaikKlein> nice 
[01:38:23] <SiegeLord> "error: failed to find an implementation of trait std::num::NumCast for &int" Err...
[01:38:56] <strcat> MaikKlein: although Iterable is just a special case
[01:39:07] <strcat> xs.iter().zip(ys.iter())
[01:39:10] <strcat> xs.rev_iter().zip(ys.iter())
[01:39:12] <strcat> different things
[01:39:32] <strcat> xs.split_char(',').zip(ys.iter())
[01:39:40] *** Joins: ghrust (ghrust@FD7BC443.6A2AE50.F3114085.IP)
[01:39:40] <ghrust> 01[13rust01] 15bors pushed 0 new commits to 06auto: 02http://git.io/-zKB_w
[01:39:40] *** Parts: ghrust (ghrust@FD7BC443.6A2AE50.F3114085.IP) ()
[01:39:42] <dbaupp> SiegeLord: dereference it
[01:40:39] <SiegeLord> I'm trying to get this to work: fn plot<Tx : NumCast, X : Iterator<Tx>>(x : X) ... plot([1, 2].iter());
[01:40:49] <xenocons> dbaupp: is there any ghetto tricks to get *search++ (incr ptr search) in 0.6 ? heh
[01:41:11] <dbaupp> xenocons: not sure
[01:41:16] <cmr> xenocons: there's no increment operator
[01:41:19] <dbaupp> xenocons: does vec::raw::to_ptr work
[01:41:23] <cmr> So that's a pretty big barrier :p
[01:41:27] <xenocons> let me try
[01:41:30] <dbaupp> cmr: there is search = search.offset(1)
[01:41:32] <xenocons> cmr: yeah but you just add 1 ;p
[01:41:41] <strcat> xenocons: use a slice
[01:41:46] <strcat> xenocons: and then slice into the slice
[01:42:05] <dbaupp> strcat: I'm guess xenocons is going for performance
[01:42:07] <strcat> so get &[T] and then keep slicing away 1 from the start
[01:42:10] <xenocons> so i can slice while i slice :) ?
[01:42:10] <strcat> that will perform well
[01:42:13] <strcat> xenocons: yep
[01:42:19] <dbaupp> strcat: oh, cool
[01:42:19] <strcat> xenocons: can slice into slices ;p
[01:42:28] <xenocons> can you give me an example
[01:42:40] *** Joins: ghrust (ghrust@AC22872E.6A2AE50.F3114085.IP)
[01:42:40] <ghrust> 01[13rust01] 15bors pushed 0 new commits to 06auto: 02http://git.io/-zKB_w
[01:42:40] *** Parts: ghrust (ghrust@AC22872E.6A2AE50.F3114085.IP) ()
[01:42:41] <xenocons> when you say slice, do you mean a[1..2]; etc?
[01:42:50] <dbaupp> rusti: let x = ~[1,2,3]; let y = x.slice(1,3); (x, y, y.slice(1,2))
[01:42:51] -rusti- more than 5 lines of output, pastebinned: http://sprunge.us/QNNG
[01:43:08] <dbaupp> rusti: let x = ~[1,2,3]; let y = x.slice(1,3); fmt!("%?", (x, y, y.slice(1,2)))
[01:43:10] -rusti- more than 5 lines of output, pastebinned: http://sprunge.us/CQKi
[01:43:12] <xenocons> ah method
[01:43:27] <dbaupp> rusti: let x = ~[1,2,3]; let y = x.slice(1,3); fmt!("%?", (y, y.slice(1,2)))
[01:43:29] -rusti- ~"(&[2, 3], &[3])"
[01:43:38] <strcat> we need better slice methods
[01:43:44] <strcat> need a way to slice only from the start or the end
[01:43:54] <strcat> then they will be like D ranges, and we can make them generic
[01:43:55] <xenocons> consts.rs:569:15: 569:18 error: binary operation + cannot be applied to type `*u8` :(
[01:44:09] <dbaupp> strcat: [..] sugar'd be nice
[01:44:15] <strcat> xenocons: it's .offset
[01:44:17] <dbaupp> xenocons: you can't + 1 to a *ptr
[01:44:31] <dbaupp> xenocons: foo.offset(1)
[01:44:34] <xenocons> hrm, so i need to change offset instead of just adding 1
[01:44:35] <xenocons> ok
[01:45:08] <xenocons> but this shortcuts things i guess
[01:45:13] <xenocons> i dont need to get the ptr
[01:45:14] <xenocons> right?
[01:45:20] <xenocons> offset should work on ~[u8]
[01:45:24] <strcat> xenocons: no
[01:45:27] <strcat> you don't want a raw pointer
[01:45:30] <strcat> you want a slice
[01:45:35] *** Quits: q66 (q66@6EE9DE40.46454B5D.33AABD5F.IP) (Client exited)
[01:45:39] <strcat> or an iterator, depending on what you're doing
[01:45:42] <xenocons> hm
[01:46:05] <xenocons> im trying to translate C: do{skiptable[*search++] = i; } while (i--); in rust
[01:46:11] <strcat> rusti: let xs = ~[1, 2, 3]; let mut it = xs.mut_iter(); fmt!("%?", it.next())
[01:46:12] -rusti- more than 5 lines of output, pastebinned: http://sprunge.us/jWHh
[01:46:12] <bjz> dbaupp: https://github.com/mozilla/rust/issues/4160
[01:46:24] <strcat> rusti: use std::iterator::*; let xs = ~[1, 2, 3]; let mut it = xs.mut_iter(); fmt!("%?", it.next())
[01:46:31] -rusti- more than 5 lines of output, pastebinned: http://sprunge.us/KHXY
[01:46:38] <strcat> stupid sprunge is getting slow
[01:46:43] <dbaupp> bjz: yup
[01:46:47] <strcat> rusti: use std::iterator::*; let mut xs = ~[1, 2, 3]; let mut it = xs.mut_iter(); fmt!("%?", it.next())
[01:46:48] -rusti- ~"Some(&mut 1)"
[01:46:53] <dbaupp> bjz: thanks :)
[01:47:07] <xenocons> maybe i should think about how i would pseudo translate it first heh
[01:47:08] <strcat> or use slices
[01:47:22] *** Joins: alisdair (textual@moz-EA60A466.dedicated.allstream.net)
[01:47:38] <strcat> xenocons: you need a mutable iterator (mut_iter) or a mutable slice or an index into skiptable
[01:47:54] <strcat> and a for loop for the counter
[01:47:56] *** Quits: bytbox (s@moz-D83E9B31.wireless.umd.edu) (Ping timeout)
[01:48:10] <cmr> http://cmr.github.io/blog/2013/06/07/this-week-in-rust/
[01:48:11] <xenocons> hmm
[01:48:20] <cmr> Any comments/additions before I post this to reddit and the ML?
[01:48:29] <cmr> I don't *think* I missed anything...
[01:48:39] *** Joins: bytbox (s@moz-D83E9B31.wireless.umd.edu)
[01:48:53] <dbaupp> cmr: the each_* functions in vec are starting to be removed
[01:48:59] <cmr> Oh right, iterator work.
[01:49:08] <dbaupp> cmr: https://github.com/mozilla/rust/pull/6999
[01:49:25] <dbaupp> cmr: and https://github.com/mozilla/rust/pull/6995
[01:49:44] <strcat> (same PR, just needed a fix)
[01:50:03] *** Quits: devbug (quassel@moz-E1DE087C.bchsia.telus.net) (Ping timeout)
[01:50:15] *** Quits: jgilbert (jgilbert@2557E599.66715431.D25A875A.IP) (Ping timeout)
[01:51:01] <dbaupp> cmr: looks good otherwise
[01:51:41] <dbaupp> cmr: (you're allowed to say 'I' instead of 'Corey Richardson' though ;P )
[01:52:00] <cmr> heh, ok :)
[01:52:14] <cmr> This is, admittedly, the first bloggy thing I've written
[01:52:30] <SiegeLord> Hmm... so I'm confused. [1].iter() returns Iterator<&int>, but I don't know how to write a function that takes that type
[01:52:31] *** Quits: bytbox (s@moz-D83E9B31.wireless.umd.edu) (Ping timeout)
[01:52:50] <Eridius> SiegeLord: what are you trying to do?
[01:53:21] <SiegeLord> Well, originally, this: fn plot<Tx : NumCast, X : Iterator<Tx>>(x : X) ... plot([1, 2].iter());
[01:53:30] <SiegeLord> But I can ignore the NumCast issue for now
[01:53:45] <xenocons> strcat: alright so it.next() will +1 each time its used?
[01:53:48] <dbaupp> SiegeLord: that should work
[01:53:50] <strcat> xenocons: yes
[01:53:56] <xenocons> alright lets try this
[01:54:03] <strcat> SiegeLord: the methods available are in std::iterator
[01:54:24] <SiegeLord> dbaupp, That specifically does not
[01:54:40] <SiegeLord> And I don't know how to write the alternative with a specific type Tx
[01:54:40] <dbaupp> SiegeLord: what's the error?
[01:54:42] <xenocons> strcat: so that will be equivilant to s++, is there a way to get ++s behavior ;)
[01:54:56] <SiegeLord> dbaupp, "error: failed to find an implementation of trait std::num::NumCast for &int"
[01:55:00] <cmr> Hot damn, I froze vim again. That's two times in a month, and the only two times in my life!
[01:55:04] <xenocons> because that means i could use it like skiptable[search.next()] = i; 
[01:55:11] <Eridius> SiegeLord: try Iterator<&Tx>
[01:55:17] <xenocons> and also in sutations where its ++search
[01:55:31] <dbaupp> xenocons: not really
[01:55:47] <dbaupp> xenocons: .next() returns Option<&ElementOfVector>
[01:55:56] *** Joins: bjz_ (brendanzab@B398BE78.F804C29E.D35A31DF.IP)
[01:56:01] <SiegeLord> Eridius, Illegal anonymous lifetime
[01:56:17] *** Quits: bjz (brendanzab@B398BE78.F804C29E.D35A31DF.IP) (Connection reset by peer)
[01:56:26] <strcat> because you need to give & type parameters a lifetime
[01:56:46] <dbaupp> SiegeLord: fn plot<'a, Tx: NumCast: X: Iterator<&'a Tx>(x: X) { .. }
[01:58:08] <xenocons> ah :\
[01:58:13] <cmr> rusti: [0, ..-1]
[01:58:15] -rusti- more than 5 lines of output, pastebinned: http://sprunge.us/cNUE
[01:58:22] <SiegeLord> error: Illegal lifetime 'a: only 'self is allowed as part of a type declaration
[01:58:24] <dbaupp> cmr: while you're at it, there are likely to be many more removals from vec and str in the near future
[01:58:25] <SiegeLord> dbaupp, ^
[01:58:35] <dbaupp> SiegeLord: use 'self instead of 'a
[01:59:00] <SiegeLord> illegal lifetime parameter name: `'self :P
[01:59:13] <SiegeLord> Or Illegal lifetime 'self: the `self` lifetime must be declared
[01:59:31] <dbaupp> strcat: ^ ?
[01:59:35] <SiegeLord> Or error: no region bound is allowed on `std::iterator::Iterator`, which is not declared as containing region pointers
[02:00:02] <cmr> hey it's my 1 year reddit anniversary
[02:00:08] <strcat> you don't want a region bound on Iterator
[02:00:38] <dbaupp> cmr: happy cake day (that's the reddit thing, right?)
[02:00:47] <cmr> dbaupp: iunno, something like that
[02:00:59] * cmr rarely uses reddit
[02:01:02] <xenocons> happy bday
[02:01:04] <xenocons> cmr: LIAR
[02:01:05] <xenocons> lol
[02:01:15] <strcat> rusti: use std::iterator::*; fn foo<A, T: Iterator<A>(xs: T) { for xs.advance |x| { } }
[02:01:16] -rusti- <anon>:10:55: 10:56 error: expected `,` but found `(`
[02:01:16] -rusti- <anon>:10          use std::iterator::*; fn foo<A, T: Iterator<A>(xs: T) { for xs.advance |x| { } }
[02:01:16] -rusti-                                                                  ^
[02:01:16] -rusti- application terminated with error code 101
[02:01:20] <xenocons> how can you not read /r/funny everyday :(
[02:01:24] <strcat> rusti: use std::iterator::*; fn foo<A, T: Iterator<A>>(xs: T) { for xs.advance |x| { } }
[02:01:25] -rusti- more than 5 lines of output, pastebinned: http://sprunge.us/bXZJ
[02:01:32] <cmr> I haven't even heard of /r/funny until just now
[02:01:34] <strcat> rusti: use std::iterator::*; fn foo<A, T: Iterator<A>>(mut xs: T) { for xs.advance |x| { } }
[02:01:35] -rusti- ()
[02:01:42] <xenocons> :D
[02:01:56] <strcat> cmr: r/mildlyinteresting
[02:01:59] *** Joins: carllerche (carllerche@6B070D22.7E6A0813.1428D117.IP)
[02:02:01] *** Quits: brendan (brendaneic@E9758364.9EC0A5AF.CFE928A7.IP) (Quit: brendan)
[02:02:17] <cmr> wow that is a thing
[02:02:17] <dbaupp> SiegeLord: the solutions is probably to just take a plain Tx: NumCast, X: Iterator<Tx> iterator
[02:02:25] <dbaupp> SiegeLord: and .transform it with a derefence
[02:02:26] *** Joins: infynyxx (infynyxx@DB780A29.749BA1D.DCC373F0.IP)
[02:02:38] <xenocons> rusti: use std::iterator::*; let mut xs = ~[1, 2, 3]; let mut it = xs.mut_iter(); match it.next() { Some n => n, None => 0 }
[02:02:39] -rusti- <anon>:10:107: 10:108 error: expected `=>` but found `n`
[02:02:39] -rusti- <anon>:10          use std::iterator::*; let mut xs = ~[1, 2, 3]; let mut it = xs.mut_iter(); match it.next() { Some n => n, None => 0 }
[02:02:39] -rusti-                                                                                                                      ^
[02:02:39] *** Joins: dylukes (dylukes@moz-E4DF3FED.pitbpa.fios.verizon.net)
[02:02:39] -rusti- application terminated with error code 101
[02:02:56] <dbaupp> SiegeLord: or just take a Iterator<float> and let the user do the .transform, if necessary
[02:02:57] *** Joins: brendan (brendaneic@E9758364.9EC0A5AF.CFE928A7.IP)
[02:03:15] *** Quits: annodomini (lambda@moz-6424FBF8.hfc.comcastbusiness.net) (Quit: annodomini)
[02:03:27] <bblum> strcat: well, hm
[02:03:34] <bblum> i could grow to like this iterator thing
[02:03:38] <bblum> to be honest
[02:03:40] <xenocons> rusti: match Some(5) { Some(n) => n, None => 0 }
[02:03:42] <dbaupp> rusti: use std::iterator::*; let mut xs = ~[1, 2, 3]; let mut it = xs.mut_iter(); match it.next() { Some(n) => n, None => 0 }
[02:03:42] -rusti- 5
[02:03:44] -rusti- more than 5 lines of output, pastebinned: http://sprunge.us/MOQa
[02:03:53] <xenocons> ah i see, parens required
[02:03:58] <dbaupp> rusti: use std::iterator::*; let mut xs = ~[1, 2, 3]; let mut it = xs.mut_iter(); match it.next() { Some(n) => *n, None => 0 }
[02:03:59] -rusti- 1
[02:04:02] <xenocons> is this the usual way to decompose the maybe type?
[02:04:11] <xenocons> sorry option tyype
[02:04:26] *** Joins: SimonSapin (simon@5924A8D9.7F79A810.4065847B.IP)
[02:04:28] <engla> xenocons: with match yes
[02:04:32] <xenocons> k
[02:04:34] <cmr> xenocons: eh. yes and no. you can frequently get away with .unwrap() or .expect()
[02:04:36] <dbaupp> xenocons: it's probably good practice to use .chain/.map where possible
[02:04:38] <engla> or you can use .chain
[02:04:38] *** Joins: bytbox (s@moz-D83E9B31.wireless.umd.edu)
[02:04:39] <strcat> .get_or_zero ;p
[02:04:41] <strcat> for that case
[02:04:43] <dbaupp> xenocons: but it's not always possible
[02:04:45] <xenocons> oh right
[02:04:50] <xenocons> get_or_zero is nice
[02:04:53] <cmr> not for iterators though
[02:04:56] <xenocons> oh
[02:04:59] <SiegeLord> dbaupp, I don't see how the first one would work... and I don't quite get the second one
[02:05:01] <xenocons> what do you do with iterators?
[02:05:09] <cmr> see above
[02:05:10] <strcat> use adaptors, usually
[02:05:21] <dbaupp> SiegeLord: fn plot<X: Iterator<float>(x: X) { .. } for the second
[02:05:22] <strcat> unless you're writing an adaptor
[02:05:29] <xenocons> hm
[02:05:39] <strcat> like merging two sorted ranges since we're missing that
[02:05:40] <xenocons> so get_or_zero wont work on iterators?
[02:05:47] <bjz_> xenocons: .map_default(0, |&n| n)
[02:05:48] <dbaupp> SiegeLord: and the user would call `plot(it.transform(|x| cast_to_a_float(x)))`
[02:05:58] <xenocons> bjz_: neat, hehe
[02:06:09] <bjz_> xenocons: get_or_zero seems superfluous
[02:06:24] <dbaupp> SiegeLord: for the first: fn plot<Tx: NumCast, X: Iterator<Tx>>(x: X) { .. } plot(it.transform(|x| *x))
[02:06:36] <dbaupp> SiegeLord: if `it` is a iterator of references
[02:06:37] <xenocons> hrmm
[02:06:44] <strcat> dbaupp: well you don't need the lambda
[02:06:44] <bjz_> xenocons: where possible, use the higher order functions
[02:06:52] <dbaupp> strcat: ?
[02:06:53] <strcat> just it.transform(cast_to_float)
[02:07:00] <dbaupp> strcat: oh right
[02:07:08] <bblum> strcat: i do like the infinite list thing about Counter in the example
[02:07:09] <dbaupp> strcat: but normally such a cast would be a method, I guess
[02:07:10] <bjz_> xenocons: unfortunately rust doesn't have do notation like haskell
[02:07:10] <xenocons> bjz_: yeah that makes sense
[02:07:11] <strcat> unless it has to be dereferenced or something
[02:07:19] <dbaupp> bjz_: it's possible though
[02:07:20] <xenocons> bjz_: heh, time for you to submit a patch :)
[02:07:32] <xenocons> lets take over rust and add sane lambda and partial application!!!
[02:07:59] <bjz_> xenocons: I'd rather not have forks just yet :)
[02:08:09] <strcat> bblum: it's mostly about only having to have 1 implementation of the adaptor algorithms like filter
[02:08:15] <strcat> bblum: instead of on each container
[02:08:15] <xenocons> should send out the haskell bat signal
[02:08:27] <dbaupp> xenocons: https://mail.mozilla.org/pipermail/rust-dev/2013-May/004182.html
[02:08:36] <bblum> strcat: do you anticipate being able to get rid of the old 'for' convention?
[02:08:44] <bjz_> xenocons: plus developing a complex language is super tricky
[02:08:48] <strcat> bblum: well... if we had 'yield' :(
[02:08:54] * bjz_ salutes the developers
[02:08:59] <strcat> bblum: sometimes external iterators are really hard to write
[02:09:03] <bblum> yield?
[02:09:08] <xenocons> bjz_: yeah of course
[02:09:11] <xenocons> dbaupp: nice
[02:09:11] <strcat> bblum: well like in python or C#
[02:09:19] <dbaupp> bjz_: you're a developer too ;P
[02:09:20] <xenocons> bjz_: hardest thing is keeping everyone happy i bet
[02:09:38] <tjc> keeping people happy?! that's not in my job description
[02:09:39] <tjc> ;-)
[02:09:54] <xenocons> hah
[02:09:59] <tjc> would anyone with bors-reviewing powers like to review https://github.com/mozilla/rust/pull/6920 ? it's pretty easy
[02:10:03] <xenocons> well, i dont really know about developing i guess
[02:10:23] *** Joins: jmgrosen (jmgrosen@moz-848F6087.sb.sd.cox.net)
[02:10:27] <bjz_> tjc: you're job is to be a bastard and make the hard descisions
[02:10:32] <bjz_> tjc: :)
[02:10:39] *** Quits: tedh (tedh@moz-F0B37C08.hsd1.il.comcast.net) (Client exited)
[02:10:39] <tjc> bjz_: well, I've got one of those down
[02:10:47] <bjz_> hehe
[02:11:03] *** Quits: RMF (RMF@moz-D471E70.dsl.telepac.pt) (Quit: Textual IRC Client: www.textualapp.com)
[02:11:06] * tjc got feedback at a past job for not being friendly enough
[02:11:06] <xenocons> bjz_: ok, so is this sane? search.next().map_default(0, |&n| n); will this return search++ or ++search
[02:11:09] *** Quits: vosen (vosen@moz-266BA656.icpnet.pl) (Connection reset by peer)
[02:11:15] *** Joins: jack (jack@moz-F1B36F9F.hsd1.nm.comcast.net)
[02:11:22] *** Joins: RMF (RMF@moz-D471E70.dsl.telepac.pt)
[02:11:24] *** Quits: themgt (themgt@moz-248BBB96.dhcp.gnvl.sc.charter.com) (Quit: Pogoapp - http://www.pogoapp.com)
[02:11:26] <bjz_> xenocons: pretty sure
[02:11:27] <jmgrosen> how does one represent a c enum as a return type on a c foreign function?
[02:11:28] <xenocons> (search being an iterator)
[02:11:34] <strcat> bblum: for example, you could transform any function using the 'fn foo(f: &fn(T) -> bool) { f(thing_to_yield_pattern) }'
[02:11:37] *** Quits: MaikKlein (maik@moz-76A64E0E.dip0.t-ipconnect.de) (Ping timeout)
[02:11:43] <bjz_> xenocons: hooray for monads!
[02:11:46] <cmr> jmgrosen: you write a Rust enum corresponding to it
[02:11:49] <strcat> bblum: to 'fn foo() { yield thing; }'
[02:11:54] <xenocons> oh right we have rusti, we have the techn ology
[02:11:59] <strcat> bblum: and then in C#, that gets compiled to an Iterator-like thing
[02:12:05] <jmgrosen> cmr: and then i just set the return type to the rust enum?
[02:12:11] <cmr> jmgrosen: yes
[02:12:14] <bblum> strcat: i don't know what yield is.
[02:12:14] <jmgrosen> thanks
[02:12:24] <strcat> bblum: coroutines/generators
[02:12:31] <cmr> jmgrosen: at least, that's how I've been doing it. the ABI for enums isn't settled or even defined yet, so, ymmv
[02:12:37] <xenocons> rusti: let s = [8,8,8,8,8,8,8,8,8,8,8].mut_iter(); s.next().map_default(0, |&n| n);
[02:12:39] -rusti- more than 5 lines of output, pastebinned: http://sprunge.us/GZFM
[02:12:41] <strcat> bblum: as in when you 'yield' it transfers back control but saves the function's local state
[02:12:52] <strcat> bblum: python uses a context switch, C# compiles the function to a state machine
[02:12:54] <jmgrosen> cmr: alright, i'll be careful
[02:13:01] <strcat> rust could do the latter
[02:13:08] <dbaupp> rusti: use std::iterator::*; let s = [8,8,8,8,8,8,8,8,8,8,8].mut_iter(); s.next().map_default(0, |&n| n);
[02:13:12] -rusti- more than 5 lines of output, pastebinned: http://sprunge.us/VJYL
[02:13:29] <xenocons> is it |n| &n ?
[02:13:37] <xenocons> or |&n| n heh
[02:13:38] <dbaupp> rusti: use std::iterator::*; let s = [8,8,8,8,8,8,8,8,8,8,8].mut_iter(); s.next().map_default(0, |n| **n);
[02:13:42] -rusti- more than 5 lines of output, pastebinned: http://sprunge.us/LWWY
[02:13:55] <bjz_> xenocons: |&n| destructures the argument
[02:14:02] <bblum> i... hm
[02:14:06] <xenocons> ah
[02:14:07] <cmr> tjc: would if I could, sorry :(. A useful pull though
[02:14:17] <dbaupp> rusti: use std::iterator::*; let x =  [8,8,8,8,8,8,8,8,8,8,8]; let mut s = x.mut_iter(); s.next().map_default(0, |n| **n);
[02:14:19] -rusti- more than 5 lines of output, pastebinned: http://sprunge.us/fWVj
[02:14:24] <tjc> cmr: no worries :-)
[02:14:31] <dbaupp> rusti: use std::iterator::*; let x = [8,8,8,8,8,8,8,8,8,8,8]; let mut s = x.iter(); s.next().map_default(0, |n| **n);
[02:14:32] -rusti- ()
[02:14:52] <bjz_> rusti: let left = |(x,_)| x; left((1, 2))
[02:15:00] -rusti- more than 5 lines of output, pastebinned: http://sprunge.us/LIAa
[02:15:01] <dbaupp> xenocons: mut_iter is only if you need to mutate the contents of the iterator (i.e. change the elements of the vector)
[02:15:19] *** Joins: Axord (xord@moz-C3CCF156.lsanca.dsl-w.verizon.net)
[02:15:21] <lkuper> cmr: I just saw your rust-dev post
[02:15:22] <dbaupp> xenocons: also, you'll need an recent incoming build to be able to use iterators nicely
[02:15:22] <bjz_> rusti: let left = |(x,_):(int,int)| x; left((1, 2))
[02:15:23] -rusti- 1
[02:15:37] <dbaupp> xenocons: and definitely one beyond 0.6 if you want to use them at all
[02:15:46] <bjz_> xenocons: unfortunately rust's type inference failed there
[02:15:48] *** Quits: infynyxx (infynyxx@DB780A29.749BA1D.DCC373F0.IP) (Client exited)
[02:15:51] <lkuper> cmr: I wanted to note that you led off with naming the three interns and I remembered you asked the other day in chat who the interns were and I mentioned the three I was aware of
[02:15:53] <strcat> bblum: http://ix.io/62D anyway, likely not something that would be easily implemented ;p
[02:16:08] <cmr> lkuper: I asked again and bblum (an intern) thinks I got them all
[02:16:22] <strcat> bblum: but what C# does is take that function, and compile it to a struct with 'start' and 'step' as state under the hood
[02:16:24] <SiegeLord> Woo... I decided to just implement a trait on &int :P
[02:16:34] <lkuper> cmr: ok, just wanted to make clear that I'm not an official source.  I'm an ex-intern
[02:16:44] <cmr> lkuper: sure, thanks for the concern :)
[02:17:46] *** Joins: Sodel_the_V (user@moz-853663E1.va.shawcable.net)
[02:17:46] <bblum> i am not a reliable source either
[02:18:05] <cmr> Only source I have atm, so, ...
[02:18:12] <cmr> I'm off to bed though. 'night
[02:18:18] *** Joins: reyre_ (reyre@moz-9002CDDA.cpe.net.cable.rogers.com)
[02:18:39] *** Joins: ghrust (ghrust@E7A4CCE2.6A2AE50.F3114085.IP)
[02:18:39] <ghrust> 01[13rust01] 15bors 04force-pushed 06auto from 14d2a5e21 to 149b0986a: 02http://git.io/N3iJvQ
[02:18:39] *** Parts: ghrust (ghrust@E7A4CCE2.6A2AE50.F3114085.IP) ()
[02:18:41] *** Joins: ghrust (ghrust@24260B07.6A2AE50.F3114085.IP)
[02:18:41] <ghrust> 01[13rust01] 15bors pushed 3 new commits to 06auto: 02http://git.io/YMIXgQ
[02:18:41] <ghrust> 13rust/06auto 14853eb12 15Philipp BrÃ¼schweiler: rustc::middle::trans::reachable: remove some unneeded code...
[02:18:41] <ghrust> 13rust/06auto 14f21bea0 15Philipp BrÃ¼schweiler: tests: make lots of main functions public
[02:18:42] <ghrust> 13rust/06auto 140b08ca5 15bors: auto merge of #6945 : Blei/rust/remove-export-all, r=catamorphism...
[02:18:44] *** Parts: ghrust (ghrust@24260B07.6A2AE50.F3114085.IP) ()
[02:19:25] <strcat> heh, python iterators are iterables. forgot about that
[02:19:29] *** Joins: infynyxx (infynyxx@DB780A29.749BA1D.DCC373F0.IP)
[02:19:52] *** Quits: carllerche (carllerche@6B070D22.7E6A0813.1428D117.IP) (Quit: carllerche)
[02:19:58] <strcat> + they have coroutines since yield can return a value (but no one uses them ;p)
[02:22:20] <xenocons> one of the guys from 2600 last night is doing his phd on RBMM for Go
[02:22:30] <xenocons> imo he should abandon and come to rust :)
[02:24:42] <xenocons> tried to convince me to take a look at go, i may have to at some stage i guess
[02:25:03] <xenocons> but if i need to worry about null ptrs i may aswell use C
[02:25:23] <xenocons> dbaupp: ah
[02:25:24] *** Quits: infynyxx (infynyxx@DB780A29.749BA1D.DCC373F0.IP) (Client exited)
[02:25:36] <xenocons> i dont want to go down the 'trying to compiler rust on windows' path this weekend
[02:25:42] <xenocons> for it may end in sorrow and frustration
[02:25:54] <xenocons> (i tried for 0.6 when 0.5 was release iirc)
[02:25:58] <SiegeLord> Another stupid question... how should I take an Iterator as an argument to a function?
[02:26:13] <SiegeLord> If I do this:  fn plot<Tx : NumCast, X : Iterator<Tx>>(x : X) the iterator is immutable and I can't iterate
[02:26:21] <strcat> SiegeLord: so either
[02:26:24] <strcat> let mut x = x;
[02:26:29] <strcat> or mark it as mut in the parameter list
[02:26:33] <strcat> (mut x: X)
[02:26:54] <SiegeLord> Oh, I put mut in the wrong place
[02:27:05] <SiegeLord> Tried to do x : mut X... 
[02:27:28] <dbaupp> xenocons: oh, you're on windows? that does make it hard
[02:27:49] <xenocons> dbaupp: yeah :(
[02:28:05] <xenocons> maybe i will try implement a different algorithm that doesnt require so much pointer kungfu
[02:28:29] <dbaupp> xenocons: you can just use an index
[02:28:54] *** Quits: zz_kimundi (kimundi@moz-21CA7C26.dip0.t-ipconnect.de) (Ping timeout)
[02:29:06] <xenocons> i dont really mind too much about metal perf atm.. so will [1,2,3,4,5].index_of(2,3,4); or something work?
[02:29:31] <dbaupp> what's that supposed to do?
[02:29:48] <xenocons> return the index (offset) of where the sequence begins
[02:30:15] <xenocons> e.g. in F# 
[02:30:15] <xenocons> > "abcdefg".IndexOf "def";;
[02:30:15] <xenocons> val it : int = 3
[02:30:19] <bstrie> xenocons: you might want to tell your friend that he can basically crib from here: http://safari.ece.cmu.edu/MSPC2012/slides_posters/davis-slides.pdf :P
[02:30:42] <xenocons> bstrie: heh, thats him
[02:30:46] <xenocons> matt davis anyway
[02:30:47] <bjz_> cmr: clarification: http://cmr.github.io/blog/2013/06/07/this-week-in-rust/#comment-922995096
[02:31:15] <dbaupp> xenocons: hm, str::find_str exists for strings
[02:31:28] <dbaupp> xenocons: but there doesn't appear to be a search for vectors
[02:31:31] <xenocons> dbaupp: for strings yeh, but what about byte sequences?
[02:31:34] <xenocons> yeah :(
[02:32:17] *** Joins: zz_kimundi (kimundi@moz-DAF39C0A.dip0.t-ipconnect.de)
[02:32:22] * strcat really wishes default methods worked
[02:32:31] <strcat> IteratorUtil could just all be default methods on Iterator
[02:32:38] *** zz_kimundi is now known as kimundi
[02:32:49] <strcat> and we could have a default method for a size hint returning None before implementing it
[02:33:01] <dbaupp> strcat: so any *Util traits could be merged
[02:33:03] <strcat> and Iterable, with default methods for all the iterator algorithms ;p
[02:33:05] <strcat> dbaupp: yes
[02:33:10] <dbaupp> strcat: things would get faster
[02:33:14] <strcat> dbaupp: and then the person implementing can pick and choose ones to override
[02:33:18] <dbaupp> strcat: default methods would be amazing
[02:33:19] <strcat> if they can do it better
[02:33:31] <dbaupp> strcat: I've been hanging out for it for aaages
[02:33:35] <strcat> heh
[02:33:38] <dbaupp> strcat: exactly
[02:33:57] <dbaupp> eurgh, I appear to have broken extra::bigint :/
[02:36:21] *** Quits: jmgrosen (jmgrosen@moz-848F6087.sb.sd.cox.net) (Quit: jmgrosen)
[02:36:47] <moonchrome> can you compile out logging messages ?
[02:37:36] *** Quits: MrFahrenheit (RageOfThou@3FEF494C.29C984D5.783DEDCA.IP) (Ping timeout)
[02:38:40] <xenocons> wonder if KMP would be easy to implement in rust
[02:38:52] <xenocons> i wish i knew this algorithms naturally
[02:41:02] *** Quits: alisdair (textual@moz-EA60A466.dedicated.allstream.net) (Quit: My MacBook Pro has gone to sleep. ZZZzzzâ€¦)
[02:41:10] *** Quits: erickt (Adium@49C4075F.3AC15C18.2321E71E.IP) (Quit: Leaving.)
[02:44:36] <xenocons> wait..
[02:44:57] <xenocons> dbaupp: would it be cheating to ~[u8] -> str and then use indexof on the str 
[02:44:58] *** Joins: mflamer (Mibbit@moz-C6ED16AA.hsd1.ca.comcast.net)
[02:45:45] <dbaupp> xenocons: are all the u8's ascii?
[02:46:06] <xenocons> its any byte 0s..255s
[02:46:44] <xenocons> works in .net
[02:46:45] <dbaupp> converting to str won't work
[02:47:07] <xenocons> just converted needle and haystack to strings, index'd it and got back correct offset
[02:47:12] <xenocons> oh :(
[02:47:15] <dbaupp> str is always utf8, and so you'll break Rust's assumptions if you do that
[02:47:19] <dbaupp> oh
[02:47:28] <dbaupp> xenocons: you could use vec::windowed to do a naive search
[02:47:39] <xenocons> yeah, my origional F# implementation did that
[02:47:43] <xenocons> but it was incredibly slow
[02:47:50] <dbaupp> yup
[02:47:57] *** Quits: tjc (tjc@moz-44841960.tukw.qwest.net) (Quit: Places to go, people to annoy)
[02:47:58] <xenocons> unworkably slow almost
[02:48:07] <dbaupp> well, there isn't much option other than writing it yourself
[02:48:10] <xenocons> so i went to boyer moore, which had great perf
[02:48:11] <xenocons> yeh
[02:48:23] <xenocons> i guess i could call native C from rust for the moment
[02:51:12] <SiegeLord> I want to convert float to &[u8]... is there a function for that?
[02:51:40] <SiegeLord> I see io::u64_to_le_bytes but that seems... awkward
[02:52:09] <SiegeLord> I guess I can rewrite it for my own needs
[02:52:28] <dbaupp> SiegeLord: you can cast
[02:52:46] <dbaupp> rusti: unsafe { cast::transmute::<float, [u8, ..8]>(1.0) }
[02:52:48] -rusti- more than 5 lines of output, pastebinned: http://sprunge.us/OUOj
[02:53:00] <dbaupp> rusti: unsafe { std::cast::transmute::<float, [u8, ..8]>(1.0) }
[02:53:01] -rusti- [0, 0, 0, 0, 0, 0, 240, 63]
[02:53:30] <Eridius> SiegeLord: if you're ok with ~[u8] there's std::to_bytes::ToBytes
[02:53:44] <SiegeLord> dbaupp, That might run into endian issues, right?
[02:53:45] <Eridius> rusti: use std::to_bytes::ToBytes; 1.0.to_bytes()
[02:53:46] -rusti- more than 5 lines of output, pastebinned: http://sprunge.us/MTVA
[02:53:47] <Eridius> rusti: use std::to_bytes::ToBytes; 1.0.to_bytes(true)
[02:53:49] -rusti- more than 5 lines of output, pastebinned: http://sprunge.us/LUQa
[02:53:57] <Eridius> rusti: use std::to_bytes::ToBytes; 1.0f.to_bytes(true)
[02:53:59] -rusti- more than 5 lines of output, pastebinned: http://sprunge.us/hVac
[02:54:06] <dbaupp> SiegeLord: I guess
[02:54:07] <Eridius> rusti: use std::to_bytes::ToBytes; 1.0f32.to_bytes(true)
[02:54:08] -rusti- more than 5 lines of output, pastebinned: http://sprunge.us/bffh
[02:54:27] <Eridius> huh I thought there was one for floats
[02:54:32] <Eridius> all the integral types have ToBytes
[02:54:32] <xenocons> damn, no sneaky way around it
[02:54:34] <xenocons> rusti: let x = ~[77, 90, 144, 0, 3, 0, 0, 0, 4, 0, 0, 0, 255]; std::str::from_bytes(x);
[02:54:36] -rusti- rust: task failed at 'assertion failed: is_utf8(vv)', /build/rust-incoming-git/src/rust/src/libstd/str.rs:54
[02:54:36] -rusti- rust: domain main @0x7f335e81f810 root task failed
[02:54:36] -rusti- application terminated with error code 101
[02:54:48] <Eridius> xenocons: what are you trying to do?
[02:55:04] <Eridius> you can use std::str::raw::from_bytes() if you want to skip the utf-8 check, but other parts of the standard library will assume any str is utf-8
[02:55:12] <Eridius> so you're onlys upposed to do that if you can prove that the input really is utf-8 without needing a runtime test
[02:55:26] <dbaupp> xenocons: the string find_str is also a naive search
[02:55:38] <dbaupp> xenocons: so you don't really avoid much doing that :(
[02:56:03] *** Joins: erickt (Adium@49C4075F.3AC15C18.2321E71E.IP)
[02:56:27] <Eridius> the description of IterBytes explicitly calls out "64 bit floating-point value"s as a place where the endian flag is relevant... but f64 does not implement IterBytes
[02:56:45] *** Joins: eatkinson (eatkinson@2557E599.66715431.D25A875A.IP)
[02:57:36] *** Joins: ghrust (ghrust@1E8607E8.6A2AE50.F3114085.IP)
[02:57:36] <ghrust> 01[13rust01] 15bors 04force-pushed 06auto from 140b08ca5 to 149b0986a: 02http://git.io/N3iJvQ
[02:57:36] *** Parts: ghrust (ghrust@1E8607E8.6A2AE50.F3114085.IP) ()
[02:57:37] *** Joins: ghrust (ghrust@5FEF1C87.6A2AE50.F3114085.IP)
[02:57:37] <ghrust> 01[13rust01] 15bors pushed 2 new commits to 06auto: 02http://git.io/6nd2yQ
[02:57:37] <ghrust> 13rust/06auto 14aac1298 15Tim Chevalier: testsuite: Add test cases that pass
[02:57:37] <ghrust> 13rust/06auto 14e34756c 15bors: auto merge of #6695 : catamorphism/rust/moretestcases, r=catamorphism
[02:57:38] *** Parts: ghrust (ghrust@5FEF1C87.6A2AE50.F3114085.IP) ()
[02:58:27] *** Quits: seth (seth@2557E599.66715431.D25A875A.IP) (Input/output error)
[02:58:43] <xenocons> dbaupp: ah well
[02:58:54] * xenocons wonders now how .net is doing IndexOf, its very fast
[02:59:10] <xenocons> probably some fancy trie
[02:59:12] *** Quits: eatkinson (eatkinson@2557E599.66715431.D25A875A.IP) (Quit: eatkinson)
[02:59:36] <dbaupp> xenocons: I'd guess they just use Boyer-moore or something
[02:59:56] <xenocons> yeah probably heh
[03:00:06] <xenocons> maybe depending on the string size it uses diff stuff
[03:01:28] <pcwalton> shaved another second off trans
[03:01:45] <xenocons> pcwalton: i demand more blog posts from you :P
[03:02:25] <xenocons> (a complementing, non pressuring kind of demand)
[03:02:44] <pcwalton> well, I need to figure out what exactly my sigil-related proposal is
[03:02:56] <pcwalton> taking into account the feeling of the core team and community
[03:03:03] <Eridius> pcwalton: owned pointers are ~owned~T, GC are ~gc~T
[03:03:16] <pcwalton> @<~gc~>@T
[03:03:38] <Eridius> ~ownedPtr, ~<@gc>GCPtr
[03:03:49] <Eridius> ~<@raw>RawPtr
[03:04:14] <sp3d> ~@<sephiroth_pointer_t_1999>@~
[03:04:19] <sp3d> ;)
[03:07:49] *** Quits: dylukes (dylukes@moz-E4DF3FED.pitbpa.fios.verizon.net) (Quit: ["Textual IRC Client: www.textualapp.com"])
[03:07:57] *** Joins: sankha93 (Instantbir@83A1CD4B.EEA5FE15.8B6C1D65.IP)
[03:11:39] <SiegeLord> There's no fast way to get the vector's length from within an indexing operator? Like D's $ or Python's -1?
[03:11:50] *** Joins: aatch (aatch@moz-2BB0AC01.cable.telstraclear.net)
[03:12:13] <bjz_> SiegeLord: https://github.com/mozilla/rust/issues/4160
[03:12:39] <bjz_> SiegeLord: it's not a priority atm
[03:12:57] <bjz_> SiegeLord: but maybe in the future
[03:13:00] <SiegeLord> Maybe there's a last() method...
[03:13:18] <bjz_> .len()?
[03:13:35] <SiegeLord> I'm trying to avoid writing a[a.len() - 1]
[03:13:39] <Eridius> SiegeLord: you can write your own method .sliceFrom that does the len implicitly
[03:13:44] <Eridius> or .last
[03:13:58] *** Quits: mflamer (Mibbit@moz-C6ED16AA.hsd1.ca.comcast.net) (Quit: http://www.mibbit.com ajax IRC Client)
[03:14:47] <SiegeLord> Hmm, last returns an immutable reference... oh well
[03:14:57] <bjz_> rusti: match [1, 2, 3] { [.._, x] => x, _ => fail!() }
[03:14:59] -rusti- 3
[03:15:34] <bjz_> not really an improvement :P
[03:16:11] <SiegeLord> Well... more DRY, I suppose
[03:16:16] *** Quits: erickt (Adium@49C4075F.3AC15C18.2321E71E.IP) (Quit: Leaving.)
[03:17:12] <dbaupp> strcat: any particular reason iterator.all() passes a &A rather than just A?
[03:17:44] <aatch> Otherwise A would have to be Copy
[03:18:21] *** Joins: erickt (Adium@49C4075F.3AC15C18.2321E71E.IP)
[03:18:24] <bjz_> rusti: let [.._,x] = [1, 2, 3]; x // it's a shame you can't do this, but it would have to fail at runtime
[03:18:26] -rusti- more than 5 lines of output, pastebinned: http://sprunge.us/WFVg
[03:19:09] <dbaupp> aatch: I don't think so?
[03:19:32] <dbaupp> aatch: it's an std::iterator iterator, so A can be moved into the closure
[03:19:56] <strcat>  dbaupp I guess not
[03:20:08] <dbaupp> strcat: should I change it?
[03:20:12] <strcat> dbaupp: yes
[03:20:31] <strcat> dbaupp: take_while/skip_while actually have to be that way but any/all shouldn't be
[03:21:38] <dbaupp> strcat: transform as well?
[03:21:52] <strcat> dbaupp: transform takes T by-value already
[03:21:55] <strcat> err, A
[03:22:12] <engla> strcat: have you thought about .tee() for iterators (to split it into two copies)? I've only implemented an obvious proof of concept using deque for a copy of used elements
[03:22:16] <dbaupp> strcat: oh, right.. it's just the vec iterator that requires the &x match
[03:22:17] <strcat> dbaupp: take_while/skip_while use a ref because they check a predicate and then pass it along
[03:22:22] * aatch is tempted to lower-case type params, just to fuck with people.
[03:22:31] <strcat> engla: not sure, but most iterators are clonable
[03:22:34] <strcat> or at least, can be
[03:22:40] <strcat> we need to mark them #[deriving(Clone)]
[03:22:41] <engla> that's true
[03:22:45] <dbaupp> aatch: you'll be banned from #rust :P
[03:22:53] <engla> that's much simpler of course
[03:22:58] <aatch> NoooOOooOOooooo!
[03:23:18] <dbaupp> strcat: that might be unreliable with the borrowed pointers
[03:23:38] <dbaupp> strcat: auto-deref makes the autogenerated .clone call fail :/
[03:24:29] <engla> strcat: next experiment, you can trivially implement .next() on a Port to just be try_recv(). You can make buffered channe/port pairs and in principle go-style iterators
[03:25:00] <dbaupp> engla: that'd be awesome!
[03:25:26] *** Quits: aatch (aatch@moz-2BB0AC01.cable.telstraclear.net) (Client exited)
[03:25:50] <engla> well, in go it's easy since they just share memory and iterate a datastructure in a different goroutine. Rust doesn't allow that
[03:27:18] <strcat> dbaupp: I implemented Clone for borrowed pointers.
[03:27:21] *** Quits: jrfeenst (jrfeenst@moz-F912484F.cpe.norwoodlight.com) (Quit: jrfeenst)
[03:27:36] <dbaupp> strcat: that's not the problem
[03:27:54] <strcat> impl<'self, T> Clone for &'self T {
[03:27:56] <strcat>     /// Return a shallow copy of the borrowed pointer.
[03:27:59] <strcat>     #[inline(always)]
[03:28:00] <strcat>     fn clone(&self) -> &'self T { *self }
[03:28:02] <strcat> }
[03:28:04] <strcat> dbaupp: oh right, I remember now
[03:28:06] <strcat> evil auto-deref
[03:28:22] <strcat> that shouldn't happen with deriving though... right?
[03:28:26] <engla> wouldn't rust just copy the borrowed pointer
[03:28:35] <dbaupp> strcat: nah, deriving just creates an AST
[03:28:39] *** Joins: doomlord (doomlod@moz-8F385DB0.range109-153.btcentralplus.com)
[03:28:43] <dbaupp> strcat: which gets typechecked/resolved as normal
[03:28:52] <strcat> dbaupp: ah that's a problem :(
[03:29:13] <dbaupp> strcat: I (or someone) really needs to go through and change the method calls to a function call
[03:29:20] <dbaupp> (for TotalEq and TotalOrd also)
[03:30:06] <strcat> meh I hate auto-deref
[03:30:11] *** Joins: devbug (quassel@moz-E1DE087C.bchsia.telus.net)
[03:30:16] <strcat> auto-ref? great ;p
[03:31:11] <dbaupp> uniform call syntax would be nice
[03:31:20] <strcat> although I can see auto-ref going wrong too
[03:31:21] <dbaupp> rusti: 1.clone::<int>()
[03:31:25] -rusti- more than 5 lines of output, pastebinned: http://sprunge.us/hULE
[03:31:39] <dbaupp> or if that worked
[03:33:07] <SiegeLord> Heh, after an hour of every change causing a whole bunch of type errors, having some changes not cause any is strangely satisfying
[03:33:26] *** Joins: aruniiird (arun@C0F82CED.3DC1015B.FFE8C4AF.IP)
[03:34:00] <engla> dbaupp: this is the fun test for channel/port iterators http://paste.debian.net/plain/9132
[03:34:34] <Jeaye> Cool to see "This week in Rust"; well done, folks.
[03:34:41] *** Quits: pcwalton (pcwalton@2557E599.66715431.D25A875A.IP) (Quit: pcwalton)
[03:35:14] <dbaupp> engla: nice!
[03:36:34] <SiegeLord> Are there any heredocs in Rust?
[03:36:50] *** Joins: infynyxx (infynyxx@moz-E95B370B.nyc.res.rr.com)
[03:37:44] <dbaupp> engla: that's really cool, because it Just Works, with .transform and so on
[03:38:10] <dbaupp> SiegeLord: strings are multline
[03:38:34] *** Quits: SimonSapin (simon@5924A8D9.7F79A810.4065847B.IP) (Quit: Leaving.)
[03:38:40] <SiegeLord> In this case, I want to embed a whole bunch of "'s
[03:39:13] <erickt> Hey folks! I just got a "make check" failure with a message like "Please don't failâ€¦ please?" anyone else getting that?
[03:39:27] <SiegeLord> I think I saw an issue on this... by graydon of all people
[03:39:31] *** Quits: Sorella (queen@B12A78F5.BA14766C.95C8B7C6.IP) (Quit: (quit))
[03:39:51] *** Quits: aruniiird (arun@C0F82CED.3DC1015B.FFE8C4AF.IP) (Ping timeout)
[03:40:36] <erickt> Luqman: ping
[03:41:18] <erickt> SiegeLord: thanks, I'll look for it, assuming that was for me :)
[03:41:28] <SiegeLord> erickt, No, it wasn't
[03:41:31] <SiegeLord> Sorry XD
[03:41:37] <erickt> shucks :)
[03:42:48] *** Joins: jmgrosen (jmgrosen@moz-848F6087.sb.sd.cox.net)
[03:42:50] <SiegeLord> Yes, I was thinking of this issue: https://github.com/mozilla/rust/issues/2755?source=cc
[03:44:35] <erickt> Is Alex Crichton online?
[03:44:39] <jmgrosen> is it possible to use c variadic functions from the ffi?
[03:45:57] *** Joins: jrfeenst (jrfeenst@moz-F912484F.cpe.norwoodlight.com)
[03:46:13] *** Parts: jrfeenst (jrfeenst@moz-F912484F.cpe.norwoodlight.com) ()
[03:46:53] <dbaupp> jmgrosen: nope
[03:47:02] <jmgrosen> :(
[03:47:08] <jmgrosen> so no curl_easy_setopt?
[03:47:26] <jmgrosen> with a signature of "CURL_EXTERN CURLcode curl_easy_setopt(CURL *curl, CURLoption option, â€¦);"
[03:47:53] <strcat> no, you can't without wrapping them in C
[03:47:53] <dbaupp> jmgrosen: nope
[03:48:08] <jmgrosen> :/ alright
[03:50:52] *** Quits: jmgrosen (jmgrosen@moz-848F6087.sb.sd.cox.net) (Quit: jmgrosen)
[03:51:19] <SiegeLord> So... would a backtic delimited raw string be out of the question for Rust?
[03:51:31] <strcat> or we could just do what python does
[03:51:34] <strcat> r"foo"
[03:51:36] *** Joins: ghrust (ghrust@9C8B94D4.6A2AE50.F3114085.IP)
[03:51:36] <ghrust> 01[13rust01] 15bors merged 06auto into 06incoming: 02http://git.io/6nd2yQ
[03:51:36] *** Parts: ghrust (ghrust@9C8B94D4.6A2AE50.F3114085.IP) ()
[03:52:25] <SiegeLord> I don't know enough parser theory to know whether a proposed syntax is regular or LL(1)...
[03:52:34] <strcat> we're slowly building up little whitespace errors again ;p
[03:53:18] <SiegeLord> In my own little language I did <token>"..."<token>... but I think that's absolutely out of the question
[03:54:14] <strcat> >>> print("\\")
[03:54:15] <strcat> \
[03:54:17] <strcat> >>> print(r"\\")
[03:54:19] <strcat> \\
[03:54:34] *** Joins: ghrust (ghrust@24260B07.6A2AE50.F3114085.IP)
[03:54:34] <ghrust> 01[13rust01] 15bors pushed 0 new commits to 06auto: 02http://git.io/CkyVwg
[03:54:34] *** Parts: ghrust (ghrust@24260B07.6A2AE50.F3114085.IP) ()
[03:54:37] *** Joins: ghrust (ghrust@AC22872E.6A2AE50.F3114085.IP)
[03:54:37] <ghrust> 01[13rust01] 15bors pushed 4 new commits to 06auto: 02http://git.io/OzC2BQ
[03:54:37] <ghrust> 13rust/06auto 14ab7a43a 15Tim Chevalier: std: Fix search-and-replace typos
[03:54:37] <ghrust> 13rust/06auto 147844e78 15Tim Chevalier: rustpkg: Extract version number from git, as per #5684...
[03:54:39] <ghrust> 13rust/06auto 149cffe49 15Tim Chevalier: rustpkg: Accept package IDs like github.com/foo/bar#0.3...
[03:54:40] *** Parts: ghrust (ghrust@AC22872E.6A2AE50.F3114085.IP) ()
[03:54:41] <dbaupp> strcat: whitespace errors?
[03:54:54] <strcat> git diff $(git hash-object -t tree /dev/null) HEAD --check
[03:54:58] *** Joins: carllerche (carllerche@6B070D22.7E6A0813.1428D117.IP)
[03:55:07] <SiegeLord> Anyway, r"" doesn't handle embedded "'s so it's useless for my use case
[03:55:30] <strcat> SiegeLord: it does unless there's 3 of them, in python ;p
[03:55:34] <dbaupp> strcat: make tidy doesn't check for tabs?
[03:55:37] *** Joins: aruniiird (arun@28692F0C.661AAE84.FFE8C4AF.IP)
[03:55:43] <strcat> dbaupp: it doesn't check everything
[03:55:54] <strcat> dbaupp: if only everyone had the sample git pre-commit hook enabled :)
[03:55:55] <dbaupp> strcat: couldn't make tidy just run that git command?
[03:56:03] <strcat> dbaupp: git can run that git command ;p
[03:56:17] <SiegeLord> strcat, r""" doesn't work... and neither does """""""
[03:56:30] <strcat> so you need here docs?
[03:56:47] <SiegeLord> Well, at least with respect to "'s
[03:56:50] *** Joins: SimonSapin (simon@5924A8D9.7F79A810.4065847B.IP)
[03:56:53] <dbaupp> strcat: yes... it'll be almost impossible to get everyone to have it enabled
[03:58:22] <dbaupp> strcat: '13 files changed, 78 insertions(+), 241 deletions(-)'
[03:58:28] <dbaupp> strcat: removing vec::all/any
[03:58:29] <strcat> dbaupp: :)
[03:58:31] <xenocons> http://www-igm.univ-mlv.fr/~lecroq/string/index.html great site
[03:58:53] *** Joins: jmgrosen (jmgrosen@moz-848F6087.sb.sd.cox.net)
[03:59:39] <jmgrosen> so curl_easy_setopt is implemented using variadic arguments, but it always only takes one argument
[04:00:12] <jmgrosen> is there some way i can have it be a generic type that i can cast to from different types? (e.g. strings, ints)
[04:00:30] <strcat> jmgrosen: rust doesn't know the C varargs calling convention
[04:00:33] <strcat> you need to wrap it from C
[04:00:56] <strcat> for example, when you push a float into varargs on windows you push it into 2 places
[04:01:26] <jmgrosen> huh, okay
[04:02:13] *** Quits: aruniiird (arun@28692F0C.661AAE84.FFE8C4AF.IP) (Ping timeout)
[04:02:34] *** Quits: carllerche (carllerche@6B070D22.7E6A0813.1428D117.IP) (Quit: carllerche)
[04:02:45] <strcat> if we did have a way to encode the calling convention
[04:02:50] <strcat> #[link_name = "foo"]
[04:03:15] <strcat> fn foo1(count: c_int, one: u32);
[04:03:17] <strcat> #[link_name = "foo"]
[04:03:24] <strcat> fn foo2(count: c_int, one: u32, two: u32);
[04:03:32] <strcat> but we don't
[04:03:45] <jmgrosen> okay, i'll try a wrapper for now i suppose
[04:03:49] <jmgrosen> thanks for the help
[04:06:05] *** Quits: infynyxx (infynyxx@moz-E95B370B.nyc.res.rr.com) (Client exited)
[04:06:54] *** Joins: carllerche (carllerche@6B070D22.7E6A0813.1428D117.IP)
[04:07:12] <jmgrosen> do i have to implement a different wrapper for each type?
[04:07:52] <jmgrosen> e.g. curl_easy_setopt_str(CURL *curl, CURLoption option, char* str) and then curl_easy_setopt_func(CURL *curl, CURLoption option, void* func) ?
[04:09:10] <strcat> jmgrosen: if they're all the same size (pointers) you can make 1
[04:09:46] <jmgrosen> ok, then what type should i declare it as in rust?
[04:09:52] <jmgrosen> what's the generic pointer type
[04:10:24] *** Quits: reyre_ (reyre@moz-9002CDDA.cpe.net.cable.rogers.com) (Client exited)
[04:10:52] <jmgrosen> sorry for these rather newbie questions, i'm new to rust but find it very interesting
[04:11:36] <strcat> jmgrosen: there isn't a generic pointer type
[04:11:44] <strcat> you can use anything, all pointers are the same size
[04:11:54] <strcat> *(), *c_void, *u8, doesn't matter
[04:12:10] <strcat> the binding has to be unsafe code, you'll be wrapping it into a safe API anyway
[04:12:29] <jmgrosen> ok, and then how do i cast to that from other pointer type?
[04:12:30] <jmgrosen> just `as`?
[04:14:44] <strcat> yes
[04:15:35] *** Joins: ghrust (ghrust@AC22872E.6A2AE50.F3114085.IP)
[04:15:35] <ghrust> 01[13rust01] 15bors 04force-pushed 06auto from 14a303718 to 14e34756c: 02http://git.io/N3iJvQ
[04:15:35] *** Parts: ghrust (ghrust@AC22872E.6A2AE50.F3114085.IP) ()
[04:15:36] *** Joins: ghrust (ghrust@5FEF1C87.6A2AE50.F3114085.IP)
[04:15:36] <ghrust> 01[13rust01] 15bors pushed 2 new commits to 06auto: 02http://git.io/4jrFPw
[04:15:36] <ghrust> 13rust/06auto 14239b81f 15Tim Chevalier: std: Change str::from_bytes to raise a condition on invalid input...
[04:15:36] <ghrust> 13rust/06auto 143fc0524 15bors: auto merge of #6920 : catamorphism/rust/issue-4765, r=bstrie...
[04:15:36] *** Parts: ghrust (ghrust@5FEF1C87.6A2AE50.F3114085.IP) ()
[04:15:58] <mark_edward> can structs/enums have trait types as members?
[04:17:12] *** Quits: carllerche (carllerche@6B070D22.7E6A0813.1428D117.IP) (Quit: carllerche)
[04:17:42] *** Joins: infynyxx (infynyxx@moz-E95B370B.nyc.res.rr.com)
[04:18:21] *** Joins: aruniiird (arun@E34C0E2D.6935F445.FFE8C4AF.IP)
[04:19:02] *** Joins: carllerche (carllerche@6B070D22.7E6A0813.1428D117.IP)
[04:20:03] *** Joins: FreezerburnV (freezerbur@moz-5718C330.bltmmd.fios.verizon.net)
[04:21:06] *** Quits: mark_edward (quassel@moz-6B90E517.rh.uchicago.edu) (Client exited)
[04:21:30] <xenocons> rusti: let x,y = ~[1],~[2]; x,y;
[04:21:33] -rusti- more than 5 lines of output, pastebinned: http://sprunge.us/NYcW
[04:21:58] <xenocons> rusti: let (x,y) = (~[1],~[2]); x,y;
[04:21:59] -rusti- <anon>:10:35: 10:36 error: expected `;` or `}` after expression but found `,`
[04:21:59] -rusti- <anon>:10          let (x,y) = (~[1],~[2]); x,y;
[04:21:59] -rusti-                                              ^
[04:21:59] -rusti- application terminated with error code 101
[04:22:14] <xenocons> rusti: let (x,y) = (~[1],~[2]); {x,y{;
[04:22:14] -rusti- <anon>:11:5: 11:6 error: incorrect close delimiter: `)`
[04:22:14] -rusti- <anon>:11     }));
[04:22:14] -rusti-                ^
[04:22:14] -rusti- application terminated with error code 101
[04:22:16] <xenocons> rusti: let (x,y) = (~[1],~[2]); {x,y};
[04:22:17] -rusti- <anon>:10:36: 10:37 error: expected `;` or `}` after expression but found `,`
[04:22:17] <xenocons> argh
[04:22:17] -rusti- <anon>:10          let (x,y) = (~[1],~[2]); {x,y};
[04:22:17] -rusti-                                               ^
[04:22:17] -rusti- application terminated with error code 101
[04:22:17] *** concrete.mozilla.org sets mode: +M 
[04:25:19] *** Joins: mark_edward (quassel@moz-6B90E517.rh.uchicago.edu)
[04:25:43] <strcat> that spam protection is really overly-sensitive ;p
[04:26:12] * strcat could add a second delay between each line...
[04:27:14] *** concrete.mozilla.org sets mode: -M 
[04:27:38] <xenocons> my bad, forgot i can privmsg rusti heh
[04:28:03] *** Quits: thou (thou@moz-1C1CA9F7.fasttrackcomm.net) (Input/output error)
[04:28:37] <mark_edward> strcat: do you know if structs/enums can have trai types as members?
[04:28:45] <strcat> as in trait objects?
[04:28:54] <strcat> ~Trait?
[04:29:10] <strcat> or type parameters with type bounds
[04:30:08] <mark_edward> i guess. like `trait Do { fn() -> ~str; } struct Action { d: Do}
[04:30:28] <strcat> it can't be unboxed like that
[04:30:33] <mark_edward> "i guess" was to your first 2 suggestions
[04:30:37] <mark_edward> i guess. like `trait Do { fn() -> ~str; } struct Action { d: ~Do}
[04:30:42] <mark_edward> should be okay then?
[04:30:45] <strcat> yes
[04:30:47] *** Joins: aatch (aatch@moz-2BB0AC01.cable.telstraclear.net)
[04:30:53] <strcat> although it seems like it would be rare to actually want that
[04:31:01] <strcat> rather than a type parameter
[04:31:14] <mark_edward> i was thinking about a problem i was having trying to do some basic socket io
[04:31:34] <bblum> you might want a list of heterogeneous thingies
[04:31:36] <mark_edward> and the fact that chain and map on results are difficult to use because some important types
[04:31:38] <bblum> which is when boxing traits matters
[04:31:48] <mark_edward> like TcpSocket can't be copied
[04:32:01] <mark_edward> and the Err() part of the resutls don't have the same type
[04:32:25] <strcat> there are lots of legacy methods using Copy
[04:32:29] <strcat> they should mostly be removed.
[04:32:29] <mark_edward> so maybe Results could be an enum of Result<ThingIWant,~Error>
[04:32:35] <mark_edward> where error is a trait?
[04:33:05] <strcat> mark_edward: it doesn't need to be that way
[04:33:12] <xenocons> trying to work out how to do for(i=0; hs[i]==ps[i]; --i) { ... } with int::rage
[04:33:14] <strcat> you don't need dynamic dispatch for that
[04:33:15] <xenocons> sorry int::range
[04:33:45] <xenocons> i guess range_rev
[04:34:04] <mark_edward> what should be done then? because i have to deal with TcpConnectError,TcpErr,IpAddrError, and TcpSockets which are noncopyable
[04:34:05] <strcat> enum Result<R, E> { Err(E), Ok(R) }
[04:34:07] <strcat> and then on the impl
[04:34:09] <aatch> worst timed crash. Ever
[04:34:11] <mark_edward> so chain and map don' work
[04:34:18] <strcat> mark_edward: because they are legacy, deprecated methods
[04:34:21] <strcat> they shouldn't use copy
[04:34:40] <strcat> they should either return a reference or move
[04:34:52] <mark_edward> so you're saying that library is going to be changed soon
[04:35:01] <strcat> well chain doesn't require Copy in result
[04:35:04] <strcat> looking in there now
[04:35:14] <strcat> map does, it will be removed in the current form
[04:35:18] *** Quits: moonchrome (moonchrome@moz-AE4D19CF.dsl.iskon.hr) (Quit: Leaving)
[04:35:29] <mark_edward> but chain requires the Error types to be the same
[04:35:51] *** Joins: sbpraveen34 (chatzilla@571389A0.DF58F48B.A3D1B221.IP)
[04:36:02] *** Joins: alisdair (textual@moz-EBE9F394.bchsia.telus.net)
[04:36:32] <strcat> mark_edward: so if you want to use a trait object, use one 
[04:36:47] <strcat> but dynamic dispatch and heap allocations are expensive, and trait objects are both
[04:36:47] *** Joins: mib_axrosj (Mibbit@moz-2B535B0A.f3.protectedgroup.com)
[04:36:53] *** Quits: mib_axrosj (Mibbit@moz-2B535B0A.f3.protectedgroup.com) (User has been banned from Mozilla (no spamming here))
[04:37:02] <mark_edward> i don't really don't * want to use a trait object*
[04:37:09] <dbaupp> aatch: ?
[04:37:23] <dbaupp> aatch: also you were talking about macros and empty sequences yesterday?
[04:37:26] <mark_edward> but the whole get ipaddr -> connect to that host -> write to it -> readfrom it
[04:37:35] <mark_edward> workflow, which i think would be pretty commen
[04:37:38] <aatch> dbaupp, oh yeah, I almost got it fixed.
[04:37:48] <mark_edward> deals with 3 different error types, and a noncopyable resul type
[04:37:50] <aatch> but it was late and I was at the office.
[04:37:51] <mark_edward> *result
[04:37:59] <mark_edward> *common
[04:38:08] <dbaupp> aatch: what do you mean by empty sequences?
[04:38:11] <strcat> it doesn't matter that the result isn't copyable
[04:38:25] <strcat> we can have an OSError struct
[04:38:32] <mark_edward> it does for map
[04:38:37] <strcat> mark_edward: map is deprecated
[04:38:42] <strcat> on Result
[04:38:59] <mark_edward> oh ok
[04:39:02] <strcat> you can have map without Copy
[04:39:03] <aatch> dbaupp, something like `([ $( $i:ident),* ])` won't match ([])
[04:39:16] <mark_edward> but then what do you do with several different error types?
[04:39:37] <strcat> mark_edward: you convert them to a common error type, but all of the I/O stuff should be using the same error type
[04:39:45] <strcat> without any conversions
[04:39:48] <dbaupp> aatch: oh, right
[04:39:54] <strcat> they are just bubbling up errno
[04:39:54] <dbaupp> aatch: what's the problem/fix?
[04:40:15] <mark_edward> oh ok. but o convert them to another error type, won't i have to use a match construct?
[04:40:24] <mark_edward> which defeats the purpose of chain i think?
[04:40:51] <aatch> because the macro parser tries the ']' against the non-terminal $i, which always works, then tries it against ']' which also works, resulting in an "ambiguous" parse
[04:40:54] <strcat> if they don't have the same error type you can't handle both errors the same way
[04:41:05] <strcat> but pretty much every single I/O function should be using a general OSError
[04:41:41] <strcat> with the error code and a function to convert it to a string
[04:41:47] <strcat> s/function/method/
[04:42:06] <dbaupp> aatch: oh, so it doesn't look ahead?
[04:42:18] <dbaupp>  /backtrack?
[04:42:57] <aatch> dbaupp, nope. it also parses against every matcher at once (I think)
[04:43:19] <xenocons> er, how does one initialise an a n+1 vec again ~[0..15]; doesnt seem to work
[04:43:36] <aatch> xenocons, [0,..15]
[04:43:45] <xenocons> that initialises all values to 0 right?
[04:43:50] <aatch> xenocons, correct
[04:44:08] <xenocons> how does one do it so [0,1,2,3,4,5...n]
[04:44:14] <xenocons> do you need to use int::range?
[04:44:22] <aatch> xenocons, presumably.
[04:44:27] <xenocons> ah k
[04:44:43] * strcat should add a proper generic range function
[04:44:50] <xenocons> yup :D
[04:45:22] <dbaupp> rusti: std::vec::from_fn(16, |i| i)
[04:45:23] -rusti- ~[0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15]
[04:45:28] <dbaupp> xenocons: ^
[04:45:40] <xenocons> ohh ok
[04:45:41] <xenocons> ty
[04:46:05] <xenocons> dbaupp: can you specify the initial value with that
[04:46:12] <xenocons> e.g. 15..30 instead of 0..15
[04:46:13] <dbaupp> aatch: oh, I see... no wonder it is so hard to write a macro that's no trivial
[04:46:32] <dbaupp> rusti: std::vec::from_fn(5, |i| (2*i + 16, None))
[04:46:34] -rusti- error: internal compiler error: unexpected failure
[04:46:34] -rusti- note: the compiler hit an unexpected failure path. this is a bug
[04:46:34] -rusti- note: try running with RUST_LOG=rustc=1,::rt::backtrace to get further details and report the results to github.com/mozilla/rust/issues
[04:46:34] -rusti- application terminated with error code 101
[04:46:39] <xenocons> D:
[04:46:42] <dbaupp> rusti: std::vec::from_fn(5, |i| (2*i + 16, Some(1.0)))
[04:46:44] -rusti- ~[(16, Some(1)), (18, Some(1)), (20, Some(1)), (22, Some(1)), (24, Some(1))]
[04:47:14] <dbaupp> Blei: you fixed/are fixing the None ICE... has it landed yet?
[04:47:40] <engla> rusti: 
[04:47:41] -rusti- ()
[04:49:22] <engla> rusti:  use std::iterator::*; let v: ~[int] = std::iterator::Counter::new(15,1).take(15).collect(); v
[04:49:23] -rusti- ~[15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29]
[04:50:35] <engla> maybe a std::iterator::range would be useful
[04:50:49] <strcat> yeah
[04:51:00] <dbaupp> engla: it's hard to do properly
[04:51:06] <xenocons> when i saw [0,..15] i expected [0..15] i guess
[04:51:07] <strcat> overflow
[04:51:09] <dbaupp> engla: (i.e. generically)
[04:52:09] <xenocons> rusti: 15u8;
[04:52:11] -rusti- ()
[04:52:19] <xenocons> rusti: let x = 15u8; x
[04:52:20] -rusti- 15
[04:52:43] <engla> oh
[04:52:57] <xenocons> rusti: let x : ~[u8] = std::vec::from_fn(3u8, |i| i); x
[04:52:59] -rusti- more than 5 lines of output, pastebinned: http://sprunge.us/gXbh
[04:53:14] <xenocons> oh :(
[04:53:40] <xenocons> guess that makes sense
[04:53:51] *** Parts: Sodel_the_V (user@moz-853663E1.va.shawcable.net) (Killing koopas in another castle)
[04:55:44] *** Quits: SiegeLord (sl@moz-CAF07B4C.hsd1.ma.comcast.net) (Quit: It's a joke. It's all a joke.)
[04:58:37] <dbaupp> doener: you're doing really well at speeding things up!
[04:59:17] <xenocons> is there a fn uint -> int
[04:59:32] *** Quits: sam1 (sam@moz-ADDDDFB1.mc.videotron.ca) (Quit: WeeChat 0.4.0)
[04:59:50] <xenocons> seems range is fussy about the types it takes, so that range(0, some_u8_vec.len()); wont work
[04:59:50] <dbaupp> rusti: 1u as int
[04:59:52] -rusti- 1
[04:59:55] <xenocons> ahhh
[05:00:12] <xenocons> ok i think my code *may* be working
[05:00:13] <dbaupp> xenocons: you can just use uint::range(0, ..)
[05:00:21] <xenocons> oh right
[05:00:51] *** Joins: sam1 (sam@moz-ADDDDFB1.mc.videotron.ca)
[05:01:00] <xenocons> i think i wrote a brute force for byte indexes offset :\ http://codepad.org/3qHIJvdB
[05:02:18] *** Joins: pcwalton (pcwalton@moz-481A040C.hsd1.ca.comcast.net)
[05:02:18] *** ChanServ sets mode: +o pcwalton
[05:02:27] <engla> dbaupp: is there anything hard besides the problem with the last value in integer range?
[05:02:50] <dbaupp> engla: yeah
[05:02:58] <dbaupp> engla: well, depends what you mean
[05:03:14] <engla> a generic impl using Add<A,A> seems simple
[05:03:19] <dbaupp> but e.g. counting down like [7,5,3,1]
[05:03:23] <dbaupp> for unsigneds
[05:03:24] <engla> and Ord of course.
[05:03:27] <engla> hm
[05:03:28] <dbaupp> is really hard to stop
[05:03:37] <dbaupp> since a comparison against 0 doesn't work
[05:03:57] <dbaupp> (specifically, counting towards 0 with unsigned numbers breaks)
[05:04:09] <engla> hm ok
[05:06:11] <strcat> dbaupp: we can expose operations returning Option<Self>
[05:06:17] <strcat> None on overflow
[05:06:33] *** Joins: ghrust (ghrust@C621748.6A2AE50.F3114085.IP)
[05:06:33] <ghrust> 01[13rust01] 15bors merged 06auto into 06incoming: 02http://git.io/4jrFPw
[05:06:33] *** Parts: ghrust (ghrust@C621748.6A2AE50.F3114085.IP) ()
[05:06:57] <strcat> dbaupp: http://llvm.org/docs/LangRef.html#arithmetic-with-overflow-intrinsics
[05:07:18] <dbaupp> strcat: oh, you mean for the numbers themselves?
[05:07:22] <strcat> yes
[05:07:29] <xenocons> hrm, something weird is happening with ~[uint] to_bytes...
[05:07:34] <dbaupp> strcat: CheckedAdd/... traits?
[05:07:37] <dbaupp> sounds good!
[05:08:06] <dbaupp> strcat: 25 files changed, 72 insertions(+), 192 deletions(-) for removing fold[lr]
[05:08:57] <strcat> dbaupp: do we actually have a foldl (or is it foldr? ;p) equivalent?
[05:09:30] *** Joins: ghrust (ghrust@614D05BD.6A2AE50.F3114085.IP)
[05:09:30] <ghrust> 01[13rust01] 15bors pushed 0 new commits to 06auto: 02http://git.io/dtJMUQ
[05:09:30] *** Parts: ghrust (ghrust@614D05BD.6A2AE50.F3114085.IP) ()
[05:09:32] *** Joins: ghrust (ghrust@614D05BD.6A2AE50.F3114085.IP)
[05:09:32] <ghrust> 01[13rust01] 15bors pushed 2 new commits to 06auto: 02http://git.io/nHM6FQ
[05:09:32] <ghrust> 13rust/06auto 14a82f6b0 15Ramkumar Ramachandra: configure: replace echo "" with plain echo...
[05:09:32] <ghrust> 13rust/06auto 14da7fbd5 15bors: auto merge of #6970 : artagnon/rust/configure, r=catamorphism...
[05:09:32] *** Parts: ghrust (ghrust@614D05BD.6A2AE50.F3114085.IP) ()
[05:09:47] <dbaupp> strcat: what do you mean?
[05:09:58] <dbaupp> strcat: .iter().fold for foldl .rev_iter().fold for foldr
[05:10:05] <strcat> dbaupp: ah, right :)
[05:10:33] <dbaupp> I'm not sure if removing each and eachi is worth it yet
[05:10:52] <dbaupp> actually, maybe it is
[05:11:02] <strcat> we really need the 'for' sugar
[05:11:07] <strcat> without advance
[05:11:07] <dbaupp> and just convert them to .each method calls
[05:11:08] <strcat> well...
[05:11:21] <dbaupp> strcat: yeah
[05:12:21] <jmgrosen> can i cast a ~[u8] to *() ?
[05:12:27] <jmgrosen> somehow
[05:12:32] <engla> dbaupp: foldr is not about reversing order. 
[05:12:43] <dbaupp> engla: sure it is
[05:12:52] <dbaupp> ?
[05:13:13] *** Joins: BizarreCake (BizarreCak@32C9829A.151E84E7.561471F8.IP)
[05:13:14] <xenocons> rusti: fmt!("0x%02x",155);
[05:13:15] -rusti- ()
[05:13:24] <xenocons> rusti: let x = fmt!("0x%02x",155); x
[05:13:25] -rusti- ~"0x9b"
[05:13:42] <dbaupp> rusti: unsafe { (~[1]).unsafe_ref(0) as *() }
[05:13:44] -rusti- 140374788079760
[05:13:50] <dbaupp> jmgrosen: ^ ?
[05:13:53] <engla> ok not in my mental model
[05:14:06] <dbaupp> engla: this is just for plain vectors
[05:14:28] <dbaupp> so there's not laziness or anything to account for
[05:14:33] <jmgrosen> dbaupp: what is the 0 in unsafe_ref for?
[05:14:46] <dbaupp> jmgrosen: the index into the vector
[05:14:51] <jmgrosen> ah, ok
[05:14:59] <dbaupp> jmgrosen: so you can get an unsafe ref to the 10'th element
[05:15:07] <jmgrosen> ok, thanks
[05:15:41] <jmgrosen> so then would the function accepting it have an argument typed *~[u8]?
[05:15:45] <jmgrosen> or just ~[u8]?
[05:16:25] <jmgrosen> but ack
[05:16:39] <jmgrosen> "error: internal compiler error: translating unsupported cast."
[05:16:42] <dbaupp> jmgrosen: the function that casts to *() ?
[05:16:57] <dbaupp> jmgrosen: it can actually just accept &[u8], I think
[05:17:07] <dbaupp> what version of rust?
[05:17:12] <jmgrosen> almost incoming
[05:17:30] *** Parts: pcwalton (pcwalton@moz-481A040C.hsd1.ca.comcast.net) ()
[05:18:06] *** Quits: alisdair (textual@moz-EBE9F394.bchsia.telus.net) (Quit: My MacBook Pro has gone to sleep. ZZZzzzâ€¦)
[05:18:44] *** Quits: tiffany (kawaii@moz-1E0FE6E8.dhcp.embarqhsd.net) (Ping timeout)
[05:19:06] *** Quits: Earnestly (earnest@6A917A59.5E1FD793.39C00A7A.IP) (Ping timeout)
[05:19:46] <xenocons> ok very strange
[05:20:21] <xenocons> my code works individually (searching for bytes in a file), but when i loop over a collection of bytes with for each, it doesnt work 
[05:20:40] *** Joins: reyre_ (reyre@moz-9002CDDA.cpe.net.cable.rogers.com)
[05:21:06] *** Quits: carllerche (carllerche@6B070D22.7E6A0813.1428D117.IP) (Quit: carllerche)
[05:21:50] *** Joins: dymk (dymk@44EEE21C.A6E21E6E.5E500FC7.IP)
[05:21:54] *** Joins: alisdair (textual@moz-EBE9F394.bchsia.telus.net)
[05:22:31] *** Quits: reyre_ (reyre@moz-9002CDDA.cpe.net.cable.rogers.com) (Ping timeout)
[05:22:54] <jmgrosen> still getting the "internal compiler error: translating unsupported cast."
[05:23:07] <jmgrosen> there's probably something wrong in my code, though
[05:24:23] <erickt> Does anyone know if #[link_name="foo"] changed? I can't seem to link against a c library using it. Instead I need to use link_args
[05:24:53] <xenocons> http://codepad.org/gQJfPl1D anything obvious?
[05:25:08] *** Quits: brendan (brendaneic@E9758364.9EC0A5AF.CFE928A7.IP) (Quit: brendan)
[05:25:23] *** Quits: Amanieu (amanieu@moz-D5D10CA8.halls.manchester.ac.uk) (Connection reset by peer)
[05:25:45] <strcat> erickt: it only worked on 'extern mod' and for selecting new symbol names
[05:25:57] *** Joins: Amanieu (amanieu@moz-D5D10CA8.halls.manchester.ac.uk)
[05:26:08] <strcat> erickt: could implement it for extern blocks as a shortcut
[05:26:14] <erickt> strcat: that's how I was trying to use it.
[05:26:24] <erickt> I used to have a "extern mod zmq"
[05:26:36] <strcat> yeah it has to be #[link_args = "-lzmq"] atm
[05:26:40] <erickt> and at one point it got migrated to #[link_name = "zmq"] extern { â€¦ }
[05:26:44] <erickt> ok
[05:26:48] <erickt> thanks
[05:26:54] <strcat> the only use for #[link_name] right now is to select an alternate name for a function symbol
[05:27:04] <strcat> perhaps it works on 'static' too
[05:38:05] <xenocons> whats different from let test = &[1u]; and static x:sig<'static> = sig { test : &[1u]; } x.test
[05:39:29] <strcat> xenocons: well
[05:39:39] <strcat> let x = &[1u];
[05:39:40] <strcat> vs
[05:39:55] <strcat> static x: &'static [uint] = &[1u];
[05:40:19] <strcat> 'let' is on the stack and the variable itself has a limited lifetime
[05:40:34] <strcat> static things have a lifetime as long as the life of the program and are stored in rodata
[05:41:04] <xenocons> right, but say you have both of those, static is set someplace globa, and let is bound within main
[05:41:27] <xenocons> let p = &[1u]; println(fmt!("%b",p==x)); should be true or false?
[05:42:14] <aatch> xenocons, true
[05:42:37] <xenocons> not what im getting :(
[05:42:44] <xenocons> i must be doing something wrong
[05:42:59] <aatch> What are you getting?
[05:43:33] <xenocons> let me create a minimal test just to confirm
[05:43:56] <aatch> rusti: static x : &'static [uint] = &[1u]; let p : &[uint] = &[1u]; assert_eq!(x, p);
[05:43:58] -rusti- ()
[05:44:06] <aatch> rusti: static x : &'static [uint] = &[1u]; let p : &[uint] = &[2u]; assert_eq!(x, p);
[05:44:08] -rusti- rust: task failed at 'left: &[1] does not equal right: &[2]', <anon>:9
[05:44:08] -rusti- rust: domain main @0x7f0eeb81f810 root task failed
[05:44:08] -rusti- application terminated with error code 101
[05:44:40] <xenocons> im getting false
[05:44:56] <xenocons> im surely screwing something up : http://codepad.org/sWHqTETA
[05:45:05] <aatch> are you sure you haven't haven't shadowed the static?
[05:45:23] <xenocons> uhh i may have? im not sure what that means
[05:46:03] <aatch> rusti: assert_eq!(&[0x243f6a88u32,0x85a308d3u32,0x13198a2eu32,0x03707344u32,0xa4093822u32,0x299f31d0u32], &[0x243f6a88u32,0x85a308d3u32,0x13198a2eu32,0x03707344u32,0xa4093822u32,0x299f31d0u32]);
[05:46:04] -rusti- ()
[05:46:22] <xenocons> hrmm
[05:46:27] <xenocons> why does it return false for me
[05:46:45] <xenocons> (btw im assuming this assert fails if not equal?)
[05:47:18] <xenocons> rusti: assert_eq!(1,2);
[05:47:19] -rusti- rust: task failed at 'left: 1 does not equal right: 2', <anon>:9
[05:47:19] -rusti- rust: domain main @0x7ff8ea01f810 root task failed
[05:47:19] -rusti- application terminated with error code 101
[05:47:22] <xenocons> right
[05:47:28] <xenocons> so how bizare
[05:47:29] <aatch> Hmm, well I can reproduce it.
[05:47:32] <aatch> looks like a bug
[05:47:55] <xenocons> ah i was hoping i screwed something up :(
[05:48:28] *** Joins: ghrust (ghrust@24260B07.6A2AE50.F3114085.IP)
[05:48:28] <ghrust> 01[13rust01] 15bors 04force-pushed 06auto from 14da7fbd5 to 143fc0524: 02http://git.io/N3iJvQ
[05:48:28] *** Parts: ghrust (ghrust@24260B07.6A2AE50.F3114085.IP) ()
[05:48:31] *** Joins: ghrust (ghrust@CFE85B59.6A2AE50.F3114085.IP)
[05:48:31] <ghrust> 01[13rust01] 15bors pushed 3 new commits to 06auto: 02http://git.io/mgjykA
[05:48:32] <ghrust> 13rust/06auto 143209951 15Philipp BrÃ¼schweiler: Add test for #6155
[05:48:32] <ghrust> 13rust/06auto 14080a462 15Philipp BrÃ¼schweiler: rustc::typeck: fix array out of bounds...
[05:48:32] <ghrust> 13rust/06auto 1488517f9 15bors: auto merge of #7000 : Blei/rust/fix-6155, r=catamorphism
[05:48:34] *** Parts: ghrust (ghrust@CFE85B59.6A2AE50.F3114085.IP) ()
[05:50:13] *** Quits: BizarreCake (BizarreCak@32C9829A.151E84E7.561471F8.IP) (Connection reset by peer)
[05:52:32] <xenocons> aatch: interestingly it doesnt seem limited to comparisons, i have about 65 signature structs with patterns in them when i manually write out the pattern (let test = &[...]) and run it, my code works, but when i loop over a vector of signature structs with for signature_vec.each |pat| { search(&bytes,pat.pattern_to_bytes(true)) }, it seems it only finds 1 of the signatures
[05:53:12] <xenocons> but i confirmed by manually println "%x" that to_bytes does indeed translate the search bytes properly, and that im 100% sure that these search bytes are present in the haystack
[05:53:22] <xenocons> so could be tricky bug if it is one
[05:54:08] <xenocons> (then again im using equality to check for bytes in bytes)
[05:54:47] *** Joins: ghrust (ghrust@5FEF1C87.6A2AE50.F3114085.IP)
[05:54:47] <ghrust> 01[13rust01] 15thestinger 04deleted 06jemalloc at 14aefd047: 02http://git.io/ActrJw
[05:54:47] *** Parts: ghrust (ghrust@5FEF1C87.6A2AE50.F3114085.IP) ()
[05:58:00] *** Quits: nielsle (nielsle@moz-5CE8ECCD.boa.fiberby.dk) (Ping timeout)
[05:58:34] *** Joins: mflamer (Mibbit@moz-C6ED16AA.hsd1.ca.comcast.net)
[05:59:46] <aatch> xenocons, yup, it's a bug in rustc
[06:00:13] <xenocons> :D
[06:00:22] <xenocons> was i helpful
[06:03:00] *** Quits: adu (ajr@moz-96FE9B84.washdc.fios.verizon.net) (Quit: adu)
[06:03:57] *** Quits: Amanieu (amanieu@moz-D5D10CA8.halls.manchester.ac.uk) (Connection reset by peer)
[06:04:14] *** Joins: Amanieu (amanieu@moz-D5D10CA8.halls.manchester.ac.uk)
[06:06:09] <Jeaye> Sorry for the duplicate email. >.< Housecleaning of Thunderbird went wrong.
[06:11:12] <dymk> How much memory does rustc typically eat when building rust? 
[06:11:16] <dymk> I'm pushing 1.1gb here
[06:11:50] <Jeaye> I believe the docs for Windows say around 2GB
[06:11:59] <strcat> dymk: librustc compilation peaks at 2.5GiB in stage0 due to fixed regressions, and 1.5GiB in stage1/stage2
[06:11:59] <Jeaye> I've never looked while building on Linunx
[06:12:03] <Jeaye> Linux
[06:12:07] <sp3d> I was seeing ~2GB on Linux earlier today
[06:12:30] <dymk> ah that's consistent with what I'm getting right now
[06:13:44] *** Joins: nielsle (nielsle@moz-5CE8ECCD.boa.fiberby.dk)
[06:18:10] *** Joins: Voomer__ (Voomer@moz-E97E8EB7.br.br.cox.net)
[06:18:10] *** Quits: Voomer_ (Voomer@moz-E97E8EB7.br.br.cox.net) (Connection reset by peer)
[06:20:01] *** Quits: blitter (blitter@moz-BA14D5CF.dyn.centurytel.net) (Ping timeout)
[06:23:00] *** Joins: Blei (philipp@moz-96D25F7A.cust.bluewin.ch)
[06:23:44] *** Quits: jmgrosen (jmgrosen@moz-848F6087.sb.sd.cox.net) (Quit: jmgrosen)
[06:25:57] *** Quits: dymk (dymk@44EEE21C.A6E21E6E.5E500FC7.IP) (Connection reset by peer)
[06:29:03] <xenocons> aatch: is there an existing bug report for this issue?
[06:30:29] <xenocons> also, can you help with a workaround heh
[06:32:16] *** Quits: FreezerburnV (freezerbur@moz-5718C330.bltmmd.fios.verizon.net) (Quit: FreezerburnV)
[06:37:46] *** Quits: Amanieu (amanieu@moz-D5D10CA8.halls.manchester.ac.uk) (Connection reset by peer)
[06:38:28] *** Joins: Amanieu (amanieu@moz-D5D10CA8.halls.manchester.ac.uk)
[06:39:28] *** Joins: ghrust (ghrust@E7A4CCE2.6A2AE50.F3114085.IP)
[06:39:29] <ghrust> 01[13rust01] 15bors merged 06auto into 06incoming: 02http://git.io/mgjykA
[06:39:29] *** Parts: ghrust (ghrust@E7A4CCE2.6A2AE50.F3114085.IP) ()
[06:42:27] *** Joins: ghrust (ghrust@9C8B94D4.6A2AE50.F3114085.IP)
[06:42:27] <ghrust> 01[13rust01] 15bors pushed 0 new commits to 06auto: 02http://git.io/XAof5w
[06:42:27] *** Parts: ghrust (ghrust@9C8B94D4.6A2AE50.F3114085.IP) ()
[06:42:29] *** Joins: ghrust (ghrust@9C8B94D4.6A2AE50.F3114085.IP)
[06:42:29] <ghrust> 01[13rust01] 15bors pushed 2 new commits to 06auto: 02http://git.io/bDNw3Q
[06:42:29] <ghrust> 13rust/06auto 1493b2ddf 15Alexei Sholik: A reminder that a block is a single expr in closures...
[06:42:29] <ghrust> 13rust/06auto 141cf57f7 15bors: auto merge of #7003 : alco/rust/tutorial-block-expr, r=bstrie...
[06:42:30] *** Parts: ghrust (ghrust@9C8B94D4.6A2AE50.F3114085.IP) ()
[06:46:44] <aatch> xenocons, I don't think theres an issue for it.
[06:47:07] <aatch> and the only work around I can think of is copying the array.
[06:50:14] *** Quits: alisdair (textual@moz-EBE9F394.bchsia.telus.net) (Quit: My MacBook Pro has gone to sleep. ZZZzzzâ€¦)
[06:57:31] *** Joins: kolmodin (Mibbit@1A66952D.7A36ABA4.59B6123A.IP)
[06:59:13] *** Quits: erickt (Adium@49C4075F.3AC15C18.2321E71E.IP) (Quit: Leaving.)
[07:02:21] *** Quits: strcat (strcat@moz-54F7FD49.cpe.net.cable.rogers.com) (Quit: WeeChat 0.4.1)
[07:02:21] <Jeaye> Is it possible to have fmt!() not add type information with '%?'?
[07:02:48] <Jeaye> rusti: println(fmt!("%?", "false"));
[07:02:49] -rusti- "false"
[07:02:49] -rusti- ()
[07:02:55] <Jeaye> rusti: println(fmt!("%?", ~"false"));
[07:02:57] -rusti- ~"false"
[07:02:57] -rusti- ()
[07:03:12] <Jeaye> rusti: println(fmt!("%?", &~"false"));
[07:03:13] -rusti- &~"false"
[07:03:13] -rusti- ()
[07:04:16] <kolmodin> Here's a few lines of rust I can't get working: https://gist.github.com/kolmodin/5734355
[07:05:12] <aatch> Jeaye, not really. it's supposed to put out a a string that is valid Rust code to get the given value.
[07:05:30] <Jeaye> Ahh, didn't realize it was for outputing code.
[07:05:46] <kolmodin> "by-move pattern bindings may not occur behind @ or & bindings"
[07:05:52] <Jeaye> I can manage by adding a bit of type safety though. Thanks, aatch 
[07:06:29] <aatch> kolmodin, that is because matchings mimic construction.
[07:06:44] <kolmodin> hmmm... ?
[07:09:03] <aatch> so the it's kinda hard to explain, but basically, you're trying to move something out of the matched binding you made
[07:09:15] <aatch> s/so the//
[07:09:30] <aatch> Is that the /actual/ code?
[07:10:03] <xenocons> aatch: i guess ill create a bug for it
[07:10:54] <kolmodin> aatch: it's part of the 50 lines of rust I've written so far :)
[07:11:08] <kolmodin> aatch: so can I copy it out of there, or what's the general approach?
[07:11:19] *** Quits: mflamer (Mibbit@moz-C6ED16AA.hsd1.ca.comcast.net) (Quit: http://www.mibbit.com ajax IRC Client)
[07:12:11] <aatch> kolmodin, hang on, I'll fork the gist.
[07:13:54] <kolmodin> aatch: cool, thanks
[07:15:32] <aatch> btw, what version are you on?
[07:15:37] <kolmodin> 0.6
[07:15:47] <aatch> hmm, did you build, or install from a package?
[07:15:56] <kolmodin> I built it
[07:16:23] *** Joins: true_droid (Adium@moz-123FD9B8.beck.volia.net)
[07:18:09] <aatch> Ok, well you might want to update, since the standard libraries were renamed
[07:18:23] <aatch> specifically, core -> std, std -> extra
[07:18:35] <aatch> so I can't even resolve your code atm.
[07:18:53] *** Quits: solancile (solancile@moz-A1CFFAE5.hsd1.wa.comcast.net) (Ping timeout)
[07:19:03] <kolmodin> I thought 0.6 was the latest?
[07:20:22] <kolmodin> or do you suggest me to use the development head?
[07:20:26] <Blei> https://gist.github.com/Blei/5734388
[07:20:28] <aatch> latest release, but 0.7pre has some pretty major changes
[07:20:37] <Blei> (just change all the std:: to extra::)
[07:20:52] <aatch> kolmodin, build from the incoming branch
[07:22:13] <kolmodin> Blei: wow, thanks! that works
[07:22:47] <kolmodin> I read the tutorial, but haven't seen the ref keyword yet
[07:22:54] <Blei> np, but you should really update to incoming if you are building rust yourself
[07:23:06] *** Joins: mzabaluev (mzabaluev@moz-91FFD755.dhcp.inet.fi)
[07:23:18] <Blei> kolmodin: https://github.com/mozilla/rust/issues/6743https://github.com/mozilla/rust/issues/6743 ;)
[07:24:52] <kolmodin> Sweet!
[07:24:57] <kolmodin> Ok, I'll build 0.7pre then
[07:29:01] <kolmodin> Thanks for the help, guys
[07:29:07] *** Joins: busylizzy (lisa@85228838.12D0DC84.211374C4.IP)
[07:33:26] *** Joins: ghrust (ghrust@AC22872E.6A2AE50.F3114085.IP)
[07:33:26] <ghrust> 01[13rust01] 15bors merged 06auto into 06incoming: 02http://git.io/bDNw3Q
[07:33:26] *** Parts: ghrust (ghrust@AC22872E.6A2AE50.F3114085.IP) ()
[07:33:59] <Jeaye> rusti: let s = ~"foo\nbar"; for s.each_line |x| { println(x); }
[07:34:01] -rusti- more than 5 lines of output, pastebinned: http://sprunge.us/VfZf
[07:34:20] <Jeaye> What the heck is up what that error?
[07:34:34] <Jeaye> I've been running into it in my own code, but that bit looks like it should work.
[07:36:25] *** Joins: ghrust (ghrust@1E8607E8.6A2AE50.F3114085.IP)
[07:36:25] <ghrust> 01[13rust01] 15bors pushed 0 new commits to 06auto: 02http://git.io/99eF7A
[07:36:25] *** Parts: ghrust (ghrust@1E8607E8.6A2AE50.F3114085.IP) ()
[07:36:27] *** Joins: ghrust (ghrust@DE823A67.6A2AE50.F3114085.IP)
[07:36:27] <ghrust> 01[13rust01] 15bors pushed 2 new commits to 06auto: 02http://git.io/F7pI-Q
[07:36:27] <ghrust> 13rust/06auto 1443cae88 15BjÃ¶rn Steinbrink: Lexer: Fix offset handling in get_str_from()...
[07:36:27] <ghrust> 13rust/06auto 141d06aea 15bors: auto merge of #7005 : dotdash/rust/fix_get_str_from, r=bstrie...
[07:36:27] *** Parts: ghrust (ghrust@DE823A67.6A2AE50.F3114085.IP) ()
[07:36:53] <Jeaye> rusti: let s = ~"foo\nbar"; for str::each_line(s) |x| { println(x); }
[07:36:54] -rusti- more than 5 lines of output, pastebinned: http://sprunge.us/CMch
[07:37:14] *** Quits: mzabaluev (mzabaluev@moz-91FFD755.dhcp.inet.fi) (Ping timeout)
[07:37:35] <Jeaye> rusti: let s = ~"foo\nbar"; for each_line(s) |x| { println(x); }
[07:37:36] -rusti- more than 5 lines of output, pastebinned: http://sprunge.us/TDMV
[07:37:58] <Jeaye> rusti: let s = ~"foo\nbar"; for std::str::each_line(s) |x| { println(x); }
[07:38:00] -rusti- foo
[07:38:00] -rusti- bar
[07:38:00] -rusti- ()
[07:38:17] <Jeaye> rusti: let s = ~"foo\nbar"; for s.each_line |x| { println(x); }
[07:38:19] -rusti- more than 5 lines of output, pastebinned: http://sprunge.us/efWF
[07:38:27] <Jeaye> Yeah, that error is kind of silly.
[07:39:30] <Luqman> seems like just isn't a method
[07:40:21] *** Joins: brendan (brendaneic@E9758364.9EC0A5AF.CFE928A7.IP)
[07:40:57] <Jeaye> Agreed.
[07:41:12] <Jeaye> I don't get that from the error at all though.
[07:41:27] <Blei> Jeaye: https://github.com/mozilla/rust/issues/5898
[07:41:30] <Jeaye> And the position of the error is at the close brace
[07:42:05] <Jeaye> ah
[07:42:38] <Blei> basically, rustc has problems with impls like `impl <T: Bar> Foo for T {`
[07:42:47] <Blei> it doesn't respect the bound on Bar
[07:43:11] <Blei> at least not in a first pass, which causes method conflicts or confusing error messages
[07:44:40] *** Quits: Blei (philipp@moz-96D25F7A.cust.bluewin.ch) (Quit: WeeChat 0.4.1)
[07:51:06] <Jeaye> hmm
[07:51:07] <true_droid> task.rs:1:4: 1:20 error: unresolved name
[07:51:07] <true_droid> task.rs:1 use extra::arc::ARC;
[07:51:11] <true_droid> has it been renamed?
[07:51:45] <true_droid> I'm on rust 0.6 stable
[07:52:00] <Jeaye> 0.6 will be std::arc::ARC
[07:52:19] <Jeaye> std became extra after 0.6
[07:53:29] <true_droid> same error with std::arc::ARC;
[07:54:33] <Jeaye> See rust/src/libstd/arc.rs
[07:54:55] <dbaupp> true_droid: have you got 'extern mod std'?
[07:55:58] <true_droid> dbaupp: thanks, that fixed that
[07:56:23] <Jeaye> void upcall_call_shim_on_rust_stack(void*, void*): Assertion `false && "Rust task failed after reentering the Rust stack"' failed.
[07:56:26] <Jeaye> Oh dear.
[07:57:01] <Jeaye> We need an acronym for Internal Runtime Error, or similar.
[07:57:19] <dbaupp> IRE
[07:57:28] <true_droid> which branch corresponds to "trunk" mentioned on the site? Is it incoming?
[07:57:28] <Jeaye> Naturally.
[07:57:32] <dbaupp> true_droid: yes
[07:57:36] <dbaupp> Jeaye: :P
[07:57:51] <Jeaye> ^_^
[07:59:09] *** Joins: thomaslee (thomaslee@moz-306D3DF4.hsd1.or.comcast.net)
[07:59:22] *** Quits: aruniiird (arun@E34C0E2D.6935F445.FFE8C4AF.IP) (Ping timeout)
[08:01:21] <aatch> kolmodin, https://gist.github.com/Aatch/5734372
[08:01:53] <aatch> (this is why I took a while to respond)
[08:04:31] *** Quits: brendan (brendaneic@E9758364.9EC0A5AF.CFE928A7.IP) (Quit: brendan)
[08:07:55] *** Joins: ravi_ (ravi@moz-F439A643.jetstream.xtra.co.nz)
[08:08:38] <ravi_> what's the canonical way to write a index loop in rust?
[08:09:17] <ravi_> something like for (i = 0; i < alist.count(); i++) { doSomething(alist[i]); }
[08:09:33] <aatch> ravi_, .each
[08:09:56] <dbaupp> ravi_: for alist.each |elem| { doSomething(*elem) }
[08:10:23] <dbaupp> aatch: that gist is awesome! :)
[08:10:32] <aatch> rusti: let v = &[1u,2u,3u,4u]; for v.each |&i| { println(fmt!("%u", i)); }
[08:10:34] -rusti- 1
[08:10:34] -rusti- 2
[08:10:34] -rusti- 3
[08:10:34] -rusti- 4
[08:10:34] -rusti- ()
[08:10:58] <ravi_> aatch, dbaupp, i see... what if I want to using index notation?
[08:11:12] <ravi_> for e.g. I want to randomly access various elements
[08:11:26] <dbaupp> ravi_: you'll have to give an example
[08:11:27] <ravi_> [0] and [1] ... or [i] and [i + 1]
[08:11:56] <dbaupp> ravi_: but `for uint::range(0, limit) |i| { ... }` gives you an integer
[08:11:58] <ravi_> for e.g. to write a bubble sort, i need to compare pairs of adjacent numbers
[08:12:12] <aatch> dbaupp, look at it now, I just updated it.
[08:12:34] <ravi_> how do I get the limit of a list?
[08:12:40] <ravi_> (or vector)
[08:12:41] <dbaupp> aatch: that use of stringify is magical!
[08:12:47] <dbaupp> ravi_: .len()
[08:13:08] <aatch> dbaupp, I thought you might like it.
[08:13:15] <dbaupp> aatch: that's actually my favourite part of rust now ;P
[08:13:35] <dbaupp> rusti: stringify!({"foo":1.0, "bar":[1,2,null]})
[08:13:37] -rusti- "{ \"foo\" : 1.0 , \"bar\" : [ 1 , 2 , null ] }"
[08:14:43] *** Joins: aruniiird (arun@36F014DA.DEE8D51C.FFE8C4AF.IP)
[08:14:52] *** Joins: solancile (solancile@moz-A1CFFAE5.hsd1.wa.comcast.net)
[08:15:29] <aatch> dbaupp, it was funny, I went to write the string and thought "Dammit, I wish we had raw strings so I didn't have to escape all those quotes!"
[08:15:37] <aatch> then stringify! hit me.
[08:15:46] <dbaupp> did it hurt? :S
[08:16:00] <aatch> lol
[08:16:04] <dbaupp> hehe, that's really awesome
[08:16:31] <dbaupp> aatch: http://www.reddit.com/r/rust/comments/1fx1vl/an_example_of_using_lifetimes_and_regions/ ;P
[08:16:43] <ravi_> rusti: let mut alist = [1, 2, 3, 4]; println(fmt!("%d", alist.count()));
[08:16:44] -rusti- more than 5 lines of output, pastebinned: http://sprunge.us/PeUO
[08:17:27] <ravi_> rusti: let mut alist = [1, 2, 3, 4]; println(fmt!("%d", alist.len()));
[08:17:29] -rusti- more than 5 lines of output, pastebinned: http://sprunge.us/OLeP
[08:17:33] <aatch> dbaupp, cool, thanks
[08:19:42] <Jeaye> rust-buildbot: let v = &[1, 2, 3, 4]; println(fmt!("%d", v.len()));
[08:19:50] <Jeaye> rusti: let v = &[1, 2, 3, 4]; println(fmt!("%d", v.len()));
[08:19:51] -rusti- more than 5 lines of output, pastebinned: http://sprunge.us/PJfE
[08:20:11] <Jeaye> rusti: let v = &[1, 2, 3, 4]; println(fmt!("%?", v.len()));
[08:20:12] -rusti- 4
[08:20:12] -rusti- ()
[08:20:26] <Jeaye> ravi_: Bah, I generally just "%?" and call it a day.
[08:20:31] <Luqman> aatch: i agree, the use of stringify! is pretty sweet
[08:20:51] <aatch> the one limitation is that it needs to tokenize.
[08:21:05] <aatch> But that's not actually much of a limitation, since most things tokenize.
[08:21:28] <aatch> rusti: stringify!({ "boo")
[08:21:29] -rusti- <anon>:10:27: 10:28 error: incorrect close delimiter: `)`
[08:21:29] -rusti- <anon>:10          stringify!({ "boo")
[08:21:29] -rusti-                                      ^
[08:21:30] -rusti- application terminated with error code 101
[08:21:42] <aatch> I'm not sure if that's a pro or a con.
[08:24:32] <Jeaye> I have a flag to enable stringify! in my check! macro for OpenGL calls (that checks glError and fails if needed) which really can help show the flow of OpenGL calls by just printing them out as they're called.
[08:25:15] *** Quits: int3_ (int3_@moz-ABE52D50.hsd1.ca.comcast.net) (Client exited)
[08:25:30] <Jeaye> Would be preferable to have cfg attributes on macros for that, but those will come in time.
[08:26:01] *** Joins: int3_ (int3_@moz-ABE52D50.hsd1.ca.comcast.net)
[08:27:57] *** Quits: Jeaye (Jeaye@moz-FD505E54.hsd1.ca.comcast.net) (Quit: zzz)
[08:29:17] *** Quits: devbug (quassel@moz-E1DE087C.bchsia.telus.net) (Connection reset by peer)
[08:30:09] <xenocons> aatch: https://github.com/mozilla/rust/issues/7012 fyi
[08:30:22] *** Joins: ghrust (ghrust@CFE85B59.6A2AE50.F3114085.IP)
[08:30:22] <ghrust> 01[13rust01] 15bors merged 06auto into 06incoming: 02http://git.io/F7pI-Q
[08:30:22] *** Parts: ghrust (ghrust@CFE85B59.6A2AE50.F3114085.IP) ()
[08:30:30] *** Quits: int3_ (int3_@moz-ABE52D50.hsd1.ca.comcast.net) (Ping timeout)
[08:31:42] *** Joins: pyrac (pyrac@moz-96C2FD1F.w109-214.abo.wanadoo.fr)
[08:33:21] *** Joins: ghrust (ghrust@2EE61FCC.6A2AE50.F3114085.IP)
[08:33:21] <ghrust> 01[13rust01] 15bors pushed 0 new commits to 06auto: 02http://git.io/k4D3Dw
[08:33:21] *** Parts: ghrust (ghrust@2EE61FCC.6A2AE50.F3114085.IP) ()
[08:33:23] *** Joins: ghrust (ghrust@CFE85B59.6A2AE50.F3114085.IP)
[08:33:23] <ghrust> 01[13rust01] 15bors pushed 2 new commits to 06auto: 02http://git.io/pdzvKQ
[08:33:23] <ghrust> 13rust/06auto 14a593d8f 15Daniel Micay: pass correct flags to jemalloc for cross-compiling
[08:33:23] <ghrust> 13rust/06auto 148db1d2c 15bors: auto merge of #7007 : thestinger/rust/jemalloc, r=catamorphism...
[08:33:23] *** Parts: ghrust (ghrust@CFE85B59.6A2AE50.F3114085.IP) ()
[08:33:36] *** Quits: engla (engla@moz-DBD1D96E.cust.bredbandsbolaget.se) (Ping timeout)
[08:35:04] *** Quits: SimonSapin (simon@5924A8D9.7F79A810.4065847B.IP) (Quit: Leaving.)
[08:36:31] *** Quits: jaen (jaen@moz-E0979827.copit.pl) (Quit: WeeChat 0.4.1)
[08:37:25] <aatch> xenocons, tagged, commented and nominated
[08:38:33] <doener> foo.rs:19:38: 19:41 error: mismatched types: expected `uint` but found `'a` (expected uint but found type parameter)
[08:38:42] *** Joins: SimonSapin (simon@5924A8D9.7F79A810.4065847B.IP)
[08:39:06] <doener> tried to see where in eq it messes up -- https://gist.github.com/dotdash/5734534
[08:39:13] <doener> I don't really understand that error
[08:39:36] *** Joins: Blub\w (wry@7E3BB9D.71150E1A.237AE2BA.IP)
[08:40:08] <xenocons> nice aatch ty, good investigating
[08:41:32] <aatch> doener, generic function, but you use '%u' inside the format string
[08:42:00] <dbaupp> doener: use %? instead
[08:42:19] <doener> ah!
[08:42:25] * doener didn't have coffee yet
[08:42:57] * aatch is apparently procrastinating from llvm-rs by helping people instead.
[08:44:13] *** Joins: EXetoC (ex@moz-2DBEB1E4.customer.t3.se)
[08:44:58] <doener> len for test1.pattern is seen as 4
[08:45:16] <doener> Guess I know where I have to look
[08:45:27] *** Joins: mib_920xao (Mibbit@9D0BDEA6.99C5783E.E5977C21.IP)
[08:46:33] *** Joins: donri (dag@moz-9BB61102.tbcn.telia.com)
[08:46:38] <aatch> doener, good find!
[08:46:56] <dbaupp> doener: that's strange
[08:47:03] *** Joins: brendan (brendaneic@E9758364.9EC0A5AF.CFE928A7.IP)
[08:49:56] *** Quits: mib_920xao (Mibbit@9D0BDEA6.99C5783E.E5977C21.IP) (Quit: http://www.mibbit.com ajax IRC Client)
[08:50:20] <doener> only wrong for statics
[08:52:56] <doener> even only if it's a field in a struct
[08:54:04] *** Quits: aruniiird (arun@36F014DA.DEE8D51C.FFE8C4AF.IP) (Ping timeout)
[08:54:26] *** Joins: engla (engla@moz-DBD1D96E.cust.bredbandsbolaget.se)
[08:54:39] *** Joins: aruniiird (arun@36F014DA.DEE8D51C.FFE8C4AF.IP)
[08:58:03] *** Quits: sankha93 (Instantbir@83A1CD4B.EEA5FE15.8B6C1D65.IP) (Ping timeout)
[09:01:38] *** Quits: aruniiird (arun@36F014DA.DEE8D51C.FFE8C4AF.IP) (Ping timeout)
[09:02:20] *** Joins: sankha93 (Instantbir@83A1CD4B.EEA5FE15.8B6C1D65.IP)
[09:02:44] *** Quits: sbpraveen34 (chatzilla@571389A0.DF58F48B.A3D1B221.IP) (Client exited)
[09:03:42] *** Quits: brendan (brendaneic@E9758364.9EC0A5AF.CFE928A7.IP) (Quit: brendan)
[09:06:50] <kolmodin> aatch: thanks!
[09:08:46] *** Quits: solancile (solancile@moz-A1CFFAE5.hsd1.wa.comcast.net) (Ping timeout)
[09:10:00] <aatch> kolmodin, it make sense?
[09:16:25] *** Joins: barosl (barosl@E287D94F.C81E10FB.7544CABF.IP)
[09:17:21] *** Joins: aruniiird (arun@D539706.4D9A0560.73686190.IP)
[09:17:21] *** Joins: BizarreCake (BizarreCak@32C9829A.151E84E7.561471F8.IP)
[09:22:14] <xenocons> hmm
[09:22:45] <kolmodin> aatch: I'm still reading...
[09:23:10] <aatch> kolmodin, lol, fair enough
[09:23:21] *** Joins: BitPuffin (quassel@moz-4A6FDDFB.cust.tele2.se)
[09:23:46] *** Joins: Yurume_ (yurume@AC58A8CE.8A059B47.E313B915.IP)
[09:23:50] <xenocons> whats the issue with making io.rs:1022 "rb" instead of "r"? i ended up writing my own (simply just adding "rb") not sure if its worth pull request tho
[09:23:58] *** Joins: solancile (solancile@moz-A1CFFAE5.hsd1.wa.comcast.net)
[09:24:17] *** Quits: sankha93 (Instantbir@83A1CD4B.EEA5FE15.8B6C1D65.IP) (Ping timeout)
[09:24:24] <aatch> xenocons, well the io library is being completely re-written so probably not worth it.
[09:24:30] <xenocons> ahh k
[09:24:44] <xenocons> i saw so on mailing list i guess
[09:25:03] *** Quits: Yurume (yurume@AC58A8CE.8A059B47.E313B915.IP) (Ping timeout)
[09:25:14] * xenocons cant wait for a nice clean io
[09:25:16] *** Quits: BitPuffin (quassel@moz-4A6FDDFB.cust.tele2.se) (Ping timeout)
[09:25:21] *** Joins: BitPuffin (quassel@moz-4A6FDDFB.cust.tele2.se)
[09:26:23] <xenocons> heh
[09:26:39] <xenocons> just reflecting with a chuckle at how insane cool watching a language being developed is
[09:27:12] *** Joins: Earnestly (earnest@6A917A59.5E1FD793.39C00A7A.IP)
[09:27:20] *** Joins: ghrust (ghrust@79968228.6A2AE50.F3114085.IP)
[09:27:20] <ghrust> 01[13rust01] 15bors merged 06auto into 06incoming: 02http://git.io/pdzvKQ
[09:27:20] *** Parts: ghrust (ghrust@79968228.6A2AE50.F3114085.IP) ()
[09:27:59] <aatch> xenocons, definitely cooler being on the developing side.
[09:28:13] <xenocons> heh
[09:28:44] <xenocons> i dont think i want to 'spoil the broth' my best stance is to probably try to use the language for insane stuff like i normally do, and hopefully post bugs
[09:28:50] *** Quits: SimonSapin (simon@5924A8D9.7F79A810.4065847B.IP) (Quit: Leaving.)
[09:29:03] <aatch> xenocons, that's cool too.
[09:29:26] <aatch> I just tend to have the "How hard could that be to fix?" mentality.
[09:29:46] <xenocons> heh
[09:29:56] <aatch> and then it doesn't matter how hard it is normally because I get sucked in by the challenge.
[09:30:18] *** Joins: ghrust (ghrust@2EE61FCC.6A2AE50.F3114085.IP)
[09:30:18] <ghrust> 01[13rust01] 15bors pushed 0 new commits to 06auto: 02http://git.io/YkRFcw
[09:30:18] *** Parts: ghrust (ghrust@2EE61FCC.6A2AE50.F3114085.IP) ()
[09:30:18] <xenocons> i keep going back and forward to rust, but this is the first project where im like 'fuck it, ill do it' i feel maybe after a few of these i might be in a position to add stuff
[09:30:21] *** Joins: ghrust (ghrust@AD60B2E3.6A2AE50.F3114085.IP)
[09:30:21] <ghrust> 01[13rust01] 15bors pushed 2 new commits to 06auto: 02http://git.io/ZsRFrg
[09:30:21] <ghrust> 13rust/06auto 14d27ba09 15Daniel Micay: add the Iterator trait to the prelude
[09:30:21] <ghrust> 13rust/06auto 14e2ec8e7 15bors: auto merge of #7008 : thestinger/rust/iterator, r=catamorphism...
[09:30:21] *** Parts: ghrust (ghrust@AD60B2E3.6A2AE50.F3114085.IP) ()
[09:30:39] <xenocons> challenge is good
[09:31:06] <kolmodin> aatch: the lifetime parameters makes perfect sense. I thought it was silly that I needed to copy stuff, although I'm returning to the same scope where the data came from
[09:31:12] <EXetoC> xenocons: cool. what about compile-time ray tracing though? :>
[09:31:30] <xenocons> EXetoC: that would be cool, heh
[09:31:47] <kolmodin> aatch: however, why do we need to slice? 
[09:31:58] <xenocons> i could maybe help with some of the type unification stuff + lambda + partial application once i know more
[09:32:03] <aatch> kolmodin, well a ~str is a unique ptr
[09:33:02] <kolmodin> aatch: so we're creating a new pointer to the same data?
[09:33:07] <aatch> so you can't have more than one at a time. (as in, for any T ptr_eq(~T, ~T) === false)
[09:33:23] *** Joins: wilsonk|2 (kvirc@moz-39EFBFC2.cg.shawcable.net)
[09:33:25] <aatch> kolmodin, correct.
[09:33:43] *** Quits: wilsonk-laptop (kvirc@moz-39EFBFC2.cg.shawcable.net) (Ping timeout)
[09:33:50] <kolmodin> aatch: and what if it's a data type that doesn't allow slicing?
[09:34:10] <aatch> kolmodin, well then you can normally just do &'r T
[09:34:23] <aatch> strings and vectors are a little odd.
[09:34:31] <kolmodin> oh
[09:34:56] <aatch> there is a proposal to make it a little more sane
[09:34:56] <kolmodin> so I can't return a &'r str then
[09:35:11] <aatch> kolmodin, you can.
[09:35:12] <kolmodin> right, it'd be cool if it'd be the same for all types
[09:35:28] <aatch> that's what the function does
[09:36:15] <aatch> rusti: std::sys::size_of::<Option<~str>>()
[09:36:16] -rusti- 8
[09:37:20] *** Joins: spider-mario (spidermari@moz-AC2C1EAE.rev.sfr.net)
[09:38:48] <aatch> kolmodin, I do mention that you can return a &'r ~str if you want, but a &str is easier to work with.
[09:38:57] <aatch> &'r str rather.
[09:39:33] <kolmodin> aatch: ah, right, we do return a &str
[09:40:49] <kolmodin> aatch: that was an excellent guide, thanks!
[09:41:02] <aatch> kolmodin, no problem.
[09:42:24] <aatch> borrowed pointers can be a little confusing at times, but I figured that framing it in terms of guaranteeing that the data lasts for a certain period would work.
[09:42:53] *** Quits: Blub\w (wry@7E3BB9D.71150E1A.237AE2BA.IP) (Quit: bbl)
[09:50:30] *** Quits: kolmodin (Mibbit@1A66952D.7A36ABA4.59B6123A.IP) (Quit: http://www.mibbit.com ajax IRC Client)
[09:50:46] *** Quits: aruniiird (arun@D539706.4D9A0560.73686190.IP) (Ping timeout)
[09:55:41] <xenocons> aatch: looks like dotdash narrowed down that bug
[09:55:53] <xenocons> btw how does one see the llvm generated?
[09:56:05] <aatch> xenocons, rustc -S --emit-llvm
[09:56:06] <doener> rustc --emit-llvm -S foo.rs
[09:56:34] <xenocons> ahh cool
[09:56:38] *** Joins: FrozenCow (FrozenCow@moz-B2DF4929.chello.nl)
[09:56:51] <aatch> `-S` emits assembly, `--emit-llvm` emits llvm IR, so when both are used, you get llvm IR assembly.
[09:57:13] <xenocons> awesome, so you can emit plain architecture specific asm too?
[09:57:19] <doener> couldn't figure out where the difference comes up (didn't quite grasp the constant translation...), and I have to go now, so I just dumped my clues on the issue :-)
[09:57:26] <doener> xenocons: just -S
[09:57:53] <xenocons> doener: oh thats you? ty!
[09:58:15] <doener> you're welcome
[09:58:22] <xenocons> also the fact that i can dump asm is way cool heh
[09:58:47] <xenocons> ehehe a high level language with ptr control and nasty asm glory *giggles*
[10:00:43] *** Quits: pyrac (pyrac@moz-96C2FD1F.w109-214.abo.wanadoo.fr) (Quit: pyrac)
[10:01:31] <aatch> xenocons, there is also an asm! syntax extension
[10:01:46] <aatch> so you can actually write assembly in rust.
[10:02:11] <aatch> xenocons, have you seen the ring-0 code written in rust?
[10:02:50] <xenocons> nowi havent!
[10:03:01] <xenocons> i havent*
[10:03:50] <aatch> https://github.com/jmgrosen/shorai
[10:05:23] *** Joins: pyrac (pyrac@moz-96C2FD1F.w109-214.abo.wanadoo.fr)
[10:05:56] *** Quits: BitPuffin (quassel@moz-4A6FDDFB.cust.tele2.se) (Ping timeout)
[10:06:12] *** Quits: heftig (heftig@moz-B679706C.dip0.t-ipconnect.de) (Ping timeout)
[10:07:33] <aatch> best. commit. ever. https://github.com/jmgrosen/shorai/commit/abca3c5542e0d025c1933d9c2fe24399ae610c74
[10:08:10] <xenocons> wow 
[10:08:25] *** Joins: pseudoku (quassel@E11BF0D0.96D08489.C28326FD.IP)
[10:08:57] <pseudoku> what does the `self lifetime parameter on structs signify?
[10:10:12] <aatch> pseudoku, lifetimes are a parameter, &-ptrs inside structs need explicit lifetimes, so structs with &-ptrs need a lifetime parameter.
[10:10:58] <aatch> the 'self itself isn't actually significant other than a temporary case the currently 'self is the only name allowed in the list.
[10:11:23] <aatch> other than that, the name itself is unimportant.
[10:11:41] <aatch> in the future you will be able to have multiple lifetime parameters in a struct.
[10:13:02] *** Joins: BitPuffin (quassel@moz-4A6FDDFB.cust.tele2.se)
[10:13:06] *** Joins: heftig (heftig@moz-B5C1FECB.dip0.t-ipconnect.de)
[10:13:37] <xenocons> so low level
[10:13:43] <xenocons> yet so high level
[10:13:43] <xenocons> heh
[10:14:09] <pseudoku> aatch: is there any example which explains the motivation and usage of lifetime parameters on structs?
[10:15:54] <aatch> pseudoku, not on hand sorry.
[10:16:05] <EXetoC> the reason you need it is because there's no implicit "'self". right?
[10:16:23] <aatch> EXetoC, correct
[10:16:25] *** wuwei`lab is now known as wuwei|away
[10:17:44] <EXetoC> so it's quite simple in that regard. you just have to remember where to add <'self> etc
[10:17:44] <pseudoku> aatch: no problem, and regarding what ExetoC said, could you please explain a bit more about it?
[10:17:49] *** Joins: q66 (q66@6EE9DE40.46454B5D.33AABD5F.IP)
[10:18:42] <pseudoku> EXetoC: thats my confusion...
[10:20:00] <aatch> pseudoku, well Rust tends to shy away from implicit behaviour. That is why we have explicit self in methods. The same idea extends to lifetimes.
[10:20:20] <aatch> You need to supply explicit lifetimes any time they can't be inferred.
[10:21:21] *** Joins: ghrust (ghrust@AC22872E.6A2AE50.F3114085.IP)
[10:21:22] <ghrust> 01[13rust01] 15bors merged 06auto into 06incoming: 02http://git.io/ZsRFrg
[10:21:22] *** Parts: ghrust (ghrust@AC22872E.6A2AE50.F3114085.IP) ()
[10:21:54] <aatch> rust has absolutely no way of /inferring/ the lifetime in that context.
[10:22:38] <aatch> (by inferrence, I mean the same kind as types)
[10:24:47] <pseudoku> so by specifying the lifetime parameter, we can instruct the compiler that the lifetime of the borrowed pointer inside the struct is the same as the struct itself? 
[10:25:00] <aatch> pseudoku, correct
[10:25:21] <aatch> it also relates to the fact that rust doesn't do any non-local reasoning.
[10:25:23] <EXetoC> *at least* that of the instance, yeah?
[10:25:35] <aatch> EXetoC, well yeah.
[10:26:22] <pseudoku> aatch: what are the other possiblities of lifetimes that we have for a borrowed pointer inside a struct?
[10:26:53] <aatch> pseudoku, well that's the thing, right now there isn't, hence why there is only a single choice of names.
[10:27:14] <aatch> but in the future there might be semantics that allow it.
[10:28:38] *** Joins: jensnockert (jensnocker@moz-8BE55278.customer.t3.se)
[10:29:32] <pseudoku> aatch: are there any scenarios that we know of which require such multiple lifetime parameters?
[10:30:08] <aatch> pseudoku, I think so. I believe pcwalton encountered one once.
[10:30:19] <aatch> they aren't common, I'll give you that much
[10:31:11] <EXetoC> seems useful
[10:31:49] <pseudoku> aatch: that clears up a lot, thanks for answering my questions :)
[10:32:25] <aatch> pseudoku, no problem. I'm feeling in a educator mood today.
[10:32:50] <aatch> pseudoku, btw, did you see the gist I did for someone else that goes into borrowed pointers more?
[10:33:06] *** Quits: BitPuffin (quassel@moz-4A6FDDFB.cust.tele2.se) (Client exited)
[10:33:43] <pseudoku> aatch: nope, can you provide me the link? thanks again
[10:34:02] <aatch> https://gist.github.com/Aatch/5734372
[10:35:10] *** Joins: BitPuffin (quassel@moz-4A6FDDFB.cust.tele2.se)
[10:36:59] *** Quits: BitPuffin (quassel@moz-4A6FDDFB.cust.tele2.se) (Ping timeout)
[10:37:28] *** Joins: BitPuffin (quassel@moz-4A6FDDFB.cust.tele2.se)
[10:39:10] *** Joins: tgt (tgt@moz-D59EE478.aztw.cable.virginmedia.com)
[10:39:35] <dbaupp> pseudoku: you're allowed 'static instead of 'self
[10:39:49] <dbaupp> pseudoku: i.e. pointers to static constants
[10:40:45] <pseudoku> aatch: that was a really good example...i feel it should be in the tutorial
[10:40:46] *** Joins: MaikKlein (maik@moz-76A64E0E.dip0.t-ipconnect.de)
[10:41:37] <aatch> pseudoku, I might have a look at the borrowed pointers tutorial and see if I can add it in somewhere.
[10:42:00] * aatch has dreams of writing a Rust book
[10:42:07] <xenocons> how can one copy a vector?
[10:42:15] <xenocons> testing workaround for this eq issue
[10:42:33] <aatch> xenocons, assuming the contents are Copy-able, then .clone()
[10:42:37] <xenocons> ah
[10:42:47] <dbaupp> aatch: that'd require Clone'ability
[10:43:01] <dbaupp> .to_owned() makes a copy via Copy
[10:43:06] <aatch> rusti: let a = ~[1u,2u,3u]; let b = a.clone(); (a, b)
[10:43:07] -rusti- (~[1, 2, 3], ~[1, 2, 3])
[10:43:24] <aatch> dbaupp, oh yeah, mixed up my bounds.
[10:43:46] <dbaupp> aatch: Copy really should be removed in favour of Clone
[10:43:56] <dbaupp> (at least, the pervasive use of it)
[10:44:25] <aatch> dbaupp, I know that much, hence suggesting .clone() instead of copy
[10:44:39] *** Quits: Jesin (Jessin_@moz-3AD6F09F.res.lehigh.edu) (Ping timeout)
[10:44:46] <dbaupp> :)
[10:44:50] <aatch> rusti: let a = ~[1u,2u,3u]; let b = copy a; (a,b)
[10:44:51] -rusti- (~[1, 2, 3], ~[1, 2, 3])
[10:44:57] <aatch> Bah!
[10:45:04] * aatch hate
[10:45:11] <Amanieu> dbaupp: wouldn't you still need Copy for value-copies of structs?
[10:45:21] <xenocons> hm
[10:45:25] <dbaupp> Amanieu: not really
[10:45:28] <Amanieu> ie types which aren't moved by default
[10:45:38] <dbaupp> Amanieu: Clone has that behaviour
[10:45:39] <pseudoku> dbaupp: thats interesting, couldn't the compiler infer it? 
[10:45:59] <dbaupp> pseudoku: 'static?
[10:46:06] <pseudoku> yes
[10:46:22] <dbaupp> Amanieu: currently Copy is too restrictive, since one can't define a custom copy-er
[10:46:26] *** Quits: MaikKlein (maik@moz-76A64E0E.dip0.t-ipconnect.de) (Ping timeout)
[10:46:33] <dbaupp> Amanieu: Clone fills that gap
[10:46:50] <xenocons> hmm
[10:46:58] <xenocons> copy doesnt help unfortunately
[10:46:59] <dbaupp> Amanieu: one can use #[deriving(Clone)] struct A {...} to not have to implement it by hand
[10:47:08] <dbaupp> pseudoku: not really
[10:47:13] *** Joins: MaikKlein (maik@moz-76A64E0E.dip0.t-ipconnect.de)
[10:47:23] <aatch> xenocons, in light of the source of the problem, that makes sense
[10:47:25] <Amanieu> I've always wondered, what does the deriving attribute do?
[10:47:35] <Amanieu> how is it different from writing an impl for a trait
[10:47:36] <dbaupp> pseudoku: one might want a datastructure that is restricted to storing static strings, e.g. struct A { s: &'static str }
[10:47:40] <xenocons> aatch: yeah hrmm
[10:47:41] <aatch> Amanieu, generates code to implement the trait
[10:47:46] <dbaupp> Amanieu: no different, it's just automatic
[10:47:47] *** Joins: Jesin (Jessin_@moz-3AD6F09F.res.lehigh.edu)
[10:47:54] <xenocons> wonder if it can be possible to force llvm to not recognise the optimisation of ret 0
[10:48:01] <dbaupp> Amanieu: i.e. less writing
[10:48:02] <aatch> dbaupp here did a lot of the work here.
[10:48:16] <aatch> xenocons, that's not the issue at all here.
[10:48:32] <pseudoku> dbaupp: oh, now i get it. thanks
[10:48:48] <xenocons> oh right, array sizes
[10:48:51] <xenocons> er vector sizes
[10:48:55] <xenocons> totally forgot latest entry
[10:48:59] <aatch> it's that the comparison goes (4 == 6) -> false then does dead code elimination
[10:49:01] <dbaupp> rusti: struct A { s: &'static str }
[10:49:02] -rusti- ()
[10:50:34] *** Quits: MaikKlein (maik@moz-76A64E0E.dip0.t-ipconnect.de) (Ping timeout)
[10:50:36] <aatch> I only pointed out that the optimization did that because it showed that it was a static problem, as in whatever we were putting out allowed LLVM to do that optimization
[10:50:36] <dbaupp> aatch: that code sets the length to 24 bytes always
[10:50:51] <dbaupp> aatch: (i.e. even for empty arrays)
[10:50:57] <Amanieu> so does deriving only work on built-in traits or can it generate code for any trait?
[10:51:31] <aatch> dbaupp, really?
[10:51:33] <dbaupp> Amanieu: only for specific builtin ones
[10:51:52] <dbaupp> aatch: yeah, just deleting the contents of the test1 array
[10:52:01] <dbaupp> and the output doesn't change
[10:52:09] <pseudoku> just to make sure i understood correctly, lifetime parameters on structs put a constraint on the minimum lifetime of the members. The `self lifetime tells the lifetime has to be atleast that of the instance itself while the `static lifetime tells that whatever that member is pointing to, must exist for the entire execution of the program.
[10:52:25] <dbaupp> Amanieu: http://static.rust-lang.org/doc/rust.html#deriving
[10:53:07] <dbaupp> pseudoku: that seems correct
[10:53:19] *** Joins: MrFahrenheit (RageOfThou@3FEF494C.29C984D5.783DEDCA.IP)
[10:53:38] <dbaupp> pseudoku: (one could also look at 'self as restricting the lifetime of the instance, so that it can't outlive the validity of it's contents)
[10:54:22] <Amanieu> thanks
[11:00:38] *** Joins: MaikKlein (maik@moz-76A64E0E.dip0.t-ipconnect.de)
[11:01:28] *** Joins: Cromulent (Cromulent@moz-983B638D.cable.virginmedia.com)
[11:01:46] <pseudoku> dbaupp: interesting, i didn't think of that way. Thanks for highlighting it.
[11:01:51] *** Joins: int3_ (int3_@moz-ABE52D50.hsd1.ca.comcast.net)
[11:05:56] *** Quits: solancile (solancile@moz-A1CFFAE5.hsd1.wa.comcast.net) (Ping timeout)
[11:09:31] *** Quits: SingingBoyo (brandon@moz-94AE1D3A.bchsia.telus.net) (Ping timeout)
[11:14:37] *** Joins: berak (chatzilla@719C9BD5.3A27401E.16E13E53.IP)
[11:14:53] *** Parts: berak (chatzilla@719C9BD5.3A27401E.16E13E53.IP) ()
[11:17:38] <aatch> dbaupp, hmm, for me the length in the struct is fixed at 16
[11:17:44] *** Joins: tiffany (kawaii@moz-1E0FE6E8.dhcp.embarqhsd.net)
[11:17:55] <dbaupp> aatch: strange
[11:18:16] <dbaupp> aatch: but looking at doener's IR suggests their's is also fixed at 16
[11:18:45] <dbaupp> aatch: `i32* getelementptr inbounds ([6 x i32]* @const, i32 0, i32 0), i64 24`
[11:18:52] <dbaupp> *fixed at 24
[11:19:30] <aatch> which one is that?
[11:19:37] *** Quits: tiffany (kawaii@moz-1E0FE6E8.dhcp.embarqhsd.net) (Ping timeout)
[11:19:46] <dbaupp> 'const1'?
[11:20:15] <dbaupp> yeah, `@const1 =  private constant { i32*, i64 } { ^that }`
[11:20:30] <aatch> mine changes.
[11:21:03] <dbaupp> does yours print the bug?
[11:21:31] <aatch> dbaupp, yep
[11:21:56] <aatch> because the size inside the struct is fixed for some reason.
[11:22:01] <aatch> at 16 for me
[11:22:12] <dbaupp> this is strange, because mine definitely prints "Static &[u32] field:    4"  always
[11:22:49] <dbaupp> wait... what's the 24 doing if it's printing 4?
[11:23:06] <aatch> dbaupp, I'm not sure if you're looking that the right thing
[11:23:16] <dbaupp> aatch: I'm now sure that I'm not
[11:23:19] <dbaupp> heh
[11:23:53] <aatch> inside the constant for test1, there is a {{ i32* i64 } i64}
[11:24:06] <aatch> I don't think it should be nested like that.
[11:24:53] <dbaupp> yeah, and so the 16 there explains the 4
[11:25:28] <aatch> I think what's happening is that when it's nested, it calculates the size of the {i32*, i64}, which is 16 on a 64-bit system.
[11:26:16] <dbaupp> given that, it's not surprising that fmt!("%?", test1.pattern) prints `&[4258896, 0, 24, 0]`
[11:26:16] <dbaupp> `
[11:26:57] <dbaupp> rusti: struct A { f: &'static [u32] } static a: A = A {f: &[1,2,3,4,5,6,7,8]}; (a.len(), a)
[11:26:59] <aatch> well now I know where to look
[11:26:59] -rusti- more than 5 lines of output, pastebinned: http://sprunge.us/EBPe
[11:27:14] <dbaupp> rusti: struct A { f: &'static [u32] } static a: A = A {f: &[1,2,3,4,5,6,7,8]}; (a.f.len(), a.f)
[11:27:15] -rusti- (4, &[4220368, 0, 32, 0])
[11:28:47] *** Joins: Blub\w (wry@7E3BB9D.71150E1A.237AE2BA.IP)
[11:30:56] *** Joins: youknowone (youknowone@A826BD81.8A0DEF81.38747683.IP)
[11:30:56] *** Quits: youknowone (youknowone@A826BD81.8A0DEF81.38747683.IP) (Z:lined (Open Proxy found on your host. Please visit www.blitzed.org/proxy?ip=115.68.131.49 for more information.))
[11:34:32] *** Quits: int3_ (int3_@moz-ABE52D50.hsd1.ca.comcast.net) (Client exited)
[11:34:37] <xenocons> heh
[11:41:29] *** Joins: SimonSapin (simon@A5049320.3E93794D.61EA6C28.IP)
[11:42:14] *** Quits: pyrac (pyrac@moz-96C2FD1F.w109-214.abo.wanadoo.fr) (Quit: pyrac)
[11:43:58] <MaikKlein> how do I generate rust doc for rust itself, so that I have the tutorials on my local machine?
[11:44:09] <MaikKlein> I have no idea what crate I have to specify
[11:44:21] *** Joins: pyrac (pyrac@moz-96C2FD1F.w109-214.abo.wanadoo.fr)
[11:44:23] <cmr> MaikKlein: it's not actually a crate
[11:44:29] <cmr> MaikKlein: they're markdown in doc/
[11:47:02] *** Quits: Cromulent (Cromulent@moz-983B638D.cable.virginmedia.com) (Ping timeout)
[11:48:42] <MaikKlein> whats a good way to display markdown?
[11:49:42] <cmr> You should be able to do a "make docs" and it will build html
[11:50:18] *** Joins: z0w0 (zack@FDF4EF6A.2CA5CD8.5F93A189.IP)
[11:52:16] *** Joins: snearch (snearch@moz-AA459792.pool.mediaways.net)
[11:53:45] <MaikKlein> yeah stupid me
[11:54:01] <MaikKlein> I should probably have read the readme :x thanks
[11:54:06] <cmr> np :)
[11:54:30] *** Joins: Cromulent (Cromulent@moz-983B638D.cable.virginmedia.com)
[11:55:32] <aatch> Grrr, this is frustrating.
[11:56:48] <aatch> we have a struct definition %"struct signature" = type { { i32*, i64 } }, which is correct. but that definition isn't used when constructing a constant.
[11:57:26] *** Quits: tgt (tgt@moz-D59EE478.aztw.cable.virginmedia.com) (Connection reset by peer)
[11:57:29] *** Quits: jensnockert (jensnocker@moz-8BE55278.customer.t3.se) (Input/output error)
[11:57:48] *** Joins: tgt (tgt@moz-D59EE478.aztw.cable.virginmedia.com)
[11:58:00] *** Joins: jensnockert (jensnocker@moz-8BE55278.customer.t3.se)
[12:01:16] <MaikKlein> if I have sth like "struct Test{ i:int} and I do let a = ~Test {i:1}; is i then on the exhchange heap too?
[12:01:26] <cmr> aatch: "Here we de-reference the json object so we can carry the lifetime through properly" would you be able to explain that more? It isn't obvious at all what dereferencing gets you
[12:02:16] <dbaupp> MaikKlein: i is just a name for some bytes inside what a points to
[12:02:21] <dbaupp> MaikKlein: so yes
[12:02:46] <MaikKlein> dbaupp, okay thanks
[12:04:47] *** Joins: int3_ (int3_@moz-ABE52D50.hsd1.ca.comcast.net)
[12:06:25] <aatch> cmr, it's hard to explain, but basically it's just because you have to put & in front of the match arms, which get's rid of the lifetime.
[12:06:37] <aatch> for reasons I don't fully understand.
[12:06:48] <cmr> Fair enough :)
[12:07:00] *** Joins: sankha93 (Instantbir@1B27BD90.7C1EA8E.8B6C1D65.IP)
[12:07:11] <aatch> I am aware that it's not that clear, you should have seen it 3 revisions earlier :P
[12:08:42] *** Joins: rajul (quassel@A2DDF553.812B5995.2051BA92.IP)
[12:10:03] *** Quits: infynyxx (infynyxx@moz-E95B370B.nyc.res.rr.com) (Client exited)
[12:10:05] *** Quits: int3_ (int3_@moz-ABE52D50.hsd1.ca.comcast.net) (Ping timeout)
[12:10:12] <cmr> http://lwn.net/SubscriberLink/553131/05a3ce32d9aa9fac/
[12:10:30] *** Joins: jaen (jaen@moz-E0979827.copit.pl)
[12:11:43] <rajul> hi all...
[12:11:58] <rajul> i am new to compiler design and implementation...
[12:12:05] <rajul> and i want to start with rust...
[12:12:17] <rajul> is there some bug i can start with...
[12:12:31] <rajul> or some project that i can work on??
[12:12:36] <rajul> kindly help!!
[12:12:41] <cmr> rajul: hi!
[12:12:48] <rajul> hi cmr
[12:13:03] <rajul> i want to contribute to rust...
[12:13:10] <aatch> rajul, just a moment, I remember seeing some E-easy issues
[12:13:12] <cmr> rajul: there's lots of work that needs to be done all over the place. do you know rust yet?
[12:13:22] <rajul> no...
[12:13:37] <rajul> i have just started looking a tutorial
[12:13:46] <aatch> Ah, learn some actual Rust before hacking on the compiler
[12:13:56] <cmr> rajul: Alright, so I'd get started with the tutorial (http://static.rust-lang.org/doc/tutorial.html) and write some simple programs.
[12:14:08] <rajul> okay...
[12:14:20] <dbaupp> aatch: I think the first thing I wrote in rust was a patch for the compiler ;P
[12:14:26] <cmr> Do not work off the 0.6 documentation, because the compiler isn't writen in rust 0.6
[12:14:35] <aatch> dbaupp, well you're... special
[12:14:39] <rajul> okay..
[12:14:46] <dbaupp> yay! I'm special!
[12:15:09] <aatch> rajul, I also suggest building the compiler yourself from the 'incoming' branch
[12:15:12] <dbaupp> aatch: (admittedly it was a single line)
[12:15:32] <rajul> cmr: is there some easy bug that can assigned to me too...like i wanted to write some code too :)
[12:15:44] <rajul> aatch: okay...
[12:15:59] <aatch> dbaupp, meh, I found the documentation lacking so I read the compiler source instead.
[12:16:16] <cmr> rajul: is there any particular part of the compiler you're interested in? there's a lot to it.
[12:16:17] <dbaupp> aatch: ?
[12:16:39] <cmr> rajul: you can look through https://github.com/mozilla/rust/issues?labels=E-easy&page=1&state=open for something that interests you.
[12:16:43] <dbaupp> aatch: that's very true... but I think I missed something
[12:16:45] <rajul> cmr: well i dont know...i could not find the bugzilla page too..
[12:16:59] <rajul> can you please give me its link!!
[12:16:59] <cmr> rajul: we use github issues, not bugzilla
[12:17:07] <rajul> okay,,,
[12:17:09] <aatch> dbaupp, oh, right that prompted me to want to fix various things
[12:18:14] <rajul> cmr: i see there...so can you please point me to some issue
[12:18:21] <MaikKlein> what is "ref" doing?
[12:18:22] <rajul> which you think is suitable for a beginner..
[12:19:02] <dbaupp> rajul: https://github.com/mozilla/rust/issues/6430
[12:19:11] <rajul> just to get a keep coding side by side and getting a whiff of codebase while i read the tutorial
[12:19:19] <rajul> dbaupp: thanks!!
[12:19:39] <cmr> That actually seems to be fixed already, dbaupp and rajul
[12:19:55] <rajul> cmr: ohh :(
[12:20:03] <dbaupp> aatch: can you close that ^
[12:20:15] <rajul> can you please suggest something else??
[12:20:48] <dbaupp> rajul: https://github.com/mozilla/rust/issues?labels=E-easy&state=open
[12:21:02] <cmr> rajul: https://github.com/mozilla/rust/issues/3965 would be a good one, get to see lots of different code.
[12:21:23] *** Quits: pyrac (pyrac@moz-96C2FD1F.w109-214.abo.wanadoo.fr) (Quit: pyrac)
[12:22:19] <rajul> dbaupp, cmr: thanks!!
[12:22:31] <rajul> i will look here....and see if i can do anything!!
[12:22:36] <rajul> thanks a lot!!
[12:22:50] <aatch> MaikKlein, ref binds to a variable by reference
[12:23:12] <xenocons> cmr: where is your thisweek in rust post?
[12:23:28] <cmr> xenocons: http://cmr.github.io/blog/2013/06/07/this-week-in-rust/
[12:23:35] <xenocons> ty
[12:24:29] <rajul> cmr: do i need to be assigned to the bug you suggested to work on it??
[12:24:32] <aatch> rusti: (match Some(1u) { Some(a) => a, _ => fail!() }, match Some(1u) { Some(ref a) => a, _ => fail!() })
[12:24:34] *** kimundi is now known as zz_kimundi
[12:24:35] -rusti- more than 5 lines of output, pastebinned: http://sprunge.us/RjCW
[12:24:38] <aatch> rajul, no
[12:24:39] <cmr> rajul: nope
[12:24:53] <cmr> rajul: https://github.com/mozilla/rust/wiki/Note-getting-started-developing-Rust https://github.com/mozilla/rust/wiki/Note-development-policy
[12:24:59] <MaikKlein> so ref is doing sth like this? let a = 5; let b= &a; ?
[12:25:10] <cmr> rajul:  There's a list of a bunch of useful documentation at https://github.com/mozilla/rust/wiki/Notes
[12:25:15] <rajul> okay....so i will just leave a comment that i am looking into this one!!
[12:25:24] <rajul> cmr: thanks!!
[12:25:39] <aatch> rusti: (match Some(1u) { Some(a) => a, _ => fail!() }, match Some(1u) { Some(ref a) => fmt!("%?", a), _ => ~"" })
[12:25:41] -rusti- (1, ~"&1")
[12:25:48] <aatch> MaikKlein, correct
[12:25:52] *** Joins: solancile (solancile@moz-A1CFFAE5.hsd1.wa.comcast.net)
[12:26:24] <xenocons> rusti: let a = 5; let b = &a; let c = &b; c
[12:26:25] -rusti- more than 5 lines of output, pastebinned: http://sprunge.us/EZfW
[12:26:44] <dbaupp> rusti: let a = 5; let b = &a; let c = &b; fmt!("%?", c)
[12:26:45] -rusti- ~"&&5"
[12:26:57] <xenocons> rusti: let a = 5; fmt("%?, &a);
[12:26:58] -rusti- more than 5 lines of output, pastebinned: http://sprunge.us/dHfh
[12:27:01] <xenocons> rusti: let a = 5; fmt("%?", &a);
[12:27:03] -rusti- more than 5 lines of output, pastebinned: http://sprunge.us/PdSP
[12:27:12] <xenocons> sigh
[12:27:14] <xenocons> getting to that time
[12:27:17] <xenocons> rusti: let a = 5; fmt!("%?", &a);
[12:27:18] -rusti- ()
[12:27:40] <aatch> rusti: fmt!("%?", &**@@*@**~~~@@~@*@1) // whut
[12:27:41] -rusti- more than 5 lines of output, pastebinned: http://sprunge.us/WhTB
[12:27:48] <xenocons> haha
[12:28:09] <aatch> rusti: fmt!("%?", &@@@~~~@@~@@1) // whut
[12:28:10] -rusti- ~"&@@@~~~@@~@@1"
[12:28:24] <aatch> rusti: fmt!("%?", @*@@~~~@*@~@@1) // whut
[12:28:25] -rusti- more than 5 lines of output, pastebinned: http://sprunge.us/CEMW
[12:28:43] <xenocons> rusti: fmt!("%?",fmt!("%?"));
[12:28:43] -rusti- <anon>:10:19: 10:29 error: not enough arguments to fmt! for the given format string
[12:28:43] -rusti- <anon>:10          fmt!("%?",fmt!("%?"));
[12:28:43] -rusti-                              ^~~~~~~~~~
[12:28:43] -rusti- application terminated with error code 101
[12:29:41] <xenocons> being able to return fmt!("%?"); would be kinda cool hehe
[12:30:06] <aatch> xenocons, what would that even mean?
[12:30:28] <xenocons> partial application so a function ('a -> string) is returned i guess
[12:30:45] <aatch> xenocons, which require partial application.
[12:30:50] <xenocons> heh yup
[12:30:50] <aatch> also fmt! is a macro
[12:31:17] <xenocons> let s = sprintf "Host name is %s";; val s : (string -> string)
[12:31:28] <xenocons> type is infered via format specifier
[12:32:20] <EXetoC> rusti: fmt!("%?",fmt!("%?", "cake"));
[12:32:21] -rusti- ()
[12:32:24] <EXetoC> rusti: fmt!("%?",fmt!("%?", "cake"))
[12:32:25] -rusti- ~"~\"\\\"cake\\\"\""
[12:32:33] <EXetoC> :>
[12:32:34] <aatch> yo dawg
[12:32:35] <xenocons> rusti: fn x(a: T) { return fmt!("%s",a); }
[12:32:36] -rusti- more than 5 lines of output, pastebinned: http://sprunge.us/aiaU
[12:33:00] <xenocons> whats the type in rust for 'a 
[12:33:02] <xenocons> i forget
[12:33:12] <aatch> xenocons, type parameters
[12:33:13] <xenocons> i think someone has told me before
[12:33:15] <cmr> rusti: fn x<T>(a: T) { fmt!("%s",a) } x(4)
[12:33:16] -rusti- more than 5 lines of output, pastebinned: http://sprunge.us/RfCf
[12:33:32] <aatch> return types people
[12:33:40] <cmr> yeah thems a pain
[12:33:48] <cmr> xenocons: anyway it doesn't work because %s only prints strings
[12:34:09] <cmr> rusti: fn x<T>(a: T) -> ~str { fmt!("%?", a) } x(4)
[12:34:11] -rusti- ~"4"
[12:34:11] <xenocons> yeah, but shouldnt inference fill in a: str ?
[12:34:22] <aatch> xenocons, nope.
[12:34:35] <aatch> rust only does local reasoning.
[12:34:36] <EXetoC> rusti: fmt!("%?",fmt!("%?", fmt!("%?", fmt!("%?", fmt!("%?", @~"hi")))))
[12:34:37] <cmr> xenocons: ... no, why would you use generics if you just want a str?
[12:34:38] -rusti- ~"~\"~\\\"~\\\\\\\"~\\\\\\\\\\\\\\\"@~\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"hi\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"\\\\\\\\\\\\\\\"\\\\\\\"\\\"\""
[12:34:47] <xenocons> cmr: just an example
[12:34:56] <xenocons> aatch: ah
[12:35:04] <aatch> every function must be correct in isolation
[12:35:14] <xenocons> right, thats kind of nice
[12:35:17] <dbaupp> EXetoC: :D
[12:35:34] <aatch> otherwise compiled libraries would be virtually impossible.
[12:35:54] <xenocons> with out some runtime generics goop i guess
[12:35:57] <cmr> also ABIs would be an absolute mess to maintain
[12:36:16] <xenocons> hmm i can imagine
[12:36:59] *** Joins: jrfeenst (jrfeenst@moz-F912484F.cpe.norwoodlight.com)
[12:37:12] <xenocons> can rust make the quality of this startrek rip better ? :)
[12:37:41] <xenocons> btw im starting a fresh attempt to build incomming in windows, maybe better luck this time
[12:40:58] <dbaupp> good luck :)
[12:41:15] *** Quits: BitPuffin (quassel@moz-4A6FDDFB.cust.tele2.se) (Ping timeout)
[12:41:17] <dbaupp> aatch: one could imagine that crate-local reasoning might work
[12:41:31] <dbaupp> aatch: but the local-only is far simpler
[12:41:45] *** Quits: SimonSapin (simon@A5049320.3E93794D.61EA6C28.IP) (Quit: Leaving.)
[12:42:01] *** Quits: MaikKlein (maik@moz-76A64E0E.dip0.t-ipconnect.de) (Ping timeout)
[12:43:14] *** Joins: SimonSapin (simon@A5049320.3E93794D.61EA6C28.IP)
[12:43:24] *** Joins: kyle2000 (kyle2000@D3528B97.7E2E8376.3031298E.IP)
[12:43:42] <aatch> dbaupp, well crate-local would introduce different behaviour for public vs private, which is bad.
[12:43:55] <aatch> and arguably counts as "not working"
[12:45:02] <dbaupp> oh, yes
[12:45:43] *** Quits: SimonSapin (simon@A5049320.3E93794D.61EA6C28.IP) (Quit: Leaving.)
[12:46:42] <aatch> Rust is kinda unfortunate in that regard, as it's the only reasonable thing to do, but people coming from haskell are used to non-local reasoning and people from C++ aren't used to any reasoning at all
[12:46:46] *** Joins: victorporof (victorporo@FE2F04DC.63E19875.D111398B.IP)
[12:47:25] *** Joins: BitPuffin (quassel@881E5F2F.5078E8B1.CB45D44D.IP)
[12:48:01] <dbaupp> I guess (partially) count as coming from Haskell, and yeah, it was annoying having write so many signatures to begin with
[12:48:06] <dbaupp> but now... meh
[12:48:21] <dbaupp> *I guess I
[12:48:30] <cmr> I come from the other side, C/C++, I think it's wonderful as it is
[12:48:51] * dbaupp glares at cmr
[12:48:53] *** Joins: SimonSapin (simon@A5049320.3E93794D.61EA6C28.IP)
[12:50:53] <aatch> cmr, same, but more C than C++, so I don't try to write templates.
[12:51:25] <Amanieu> Also coming from C++, this is exactly what they were trying to do in C++11 with concepts
[12:53:36] * jensnockert hugs cmr for the Week in Rust summaries.
[12:54:38] *** Quits: tgt (tgt@moz-D59EE478.aztw.cable.virginmedia.com) (Ping timeout)
[12:57:12] <aatch> cmr, oh yeah! Thanks for mentioning me twice! I feel so special
[12:57:18] <cmr> aatch: :p
[12:58:02] *** Joins: MaikKlein (maik@moz-76A64E0E.dip0.t-ipconnect.de)
[12:58:34] *** Quits: SimonSapin (simon@A5049320.3E93794D.61EA6C28.IP) (Quit: Leaving.)
[12:58:37] *** Joins: tgt (tgt@moz-D59EE478.aztw.cable.virginmedia.com)
[12:58:55] <aatch> I especially like the "fixed a huge regression that he caused" (no sarcasm, I fully accept my mistakes, I just find it hilarious)
[13:02:08] <q66> reasoning?
[13:02:17] <q66> why not call it what sane people call it
[13:02:19] <q66> that is, type inference
[13:02:46] <aatch> q66, because it extends to other things, like the borrow checker
[13:02:58] <aatch> and liveness
[13:03:06] *** Quits: rusti (rusti@moz-54F7FD49.cpe.net.cable.rogers.com) (Ping timeout)
[13:03:08] <q66> i've never heard anyone call this stuff "reasoning" except here now
[13:03:16] *** Joins: rusti (rusti@moz-54F7FD49.cpe.net.cable.rogers.com)
[13:03:20] <kyle2000> yeah i agree q66. i find it a very confusing term too.
[13:03:35] *** Quits: KindOne (KindOne@moz-D173A859.dynamic.ip.windstream.net) (Ping timeout)
[13:04:01] <aatch> q66, how many languages are done in a way that make it noticeable?
[13:04:11] <q66> even rust manual says type inference :P
[13:04:30] <q66> aatch, I don't understand your question
[13:04:43] <dbaupp> FWIW, I've heard others use "reasoning" with respect to Rust
[13:04:54] <q66> *shrug*
[13:04:58] *** Quits: rusti (rusti@moz-54F7FD49.cpe.net.cable.rogers.com) (Ping timeout)
[13:05:11] <q66> also what's up with rusti
[13:05:13] <q66> why does it keep timeouting
[13:05:16] *** Joins: rusti (rusti@moz-54F7FD49.cpe.net.cable.rogers.com)
[13:05:31] <q66> i think the bot can't properly respond to ping requests or something
[13:05:33] <aatch> q66, well most languages either don't have that kind of reasoning, or do whole-program reasonaing.
[13:05:57] <q66> aatch, there are languages that have way more advanced inference than rust does
[13:06:13] <aatch> q66, no, it's because it lives on strcat's laptop and has to live with his shitty wifi
[13:06:31] <q66> there are languages that do full global inference
[13:06:33] <q66> like ocaml
[13:06:46] <cmr> q66: right... that's not local reasoning.
[13:06:51] <aatch> q66, yes. and I admit that.
[13:06:52] <q66> ATS can figure out a lot of stuff at compile time
[13:07:08] <q66> but sure, in rust i guess it doesn't make much sense
[13:07:12] <aatch> but that has trade-offs that rust decided not to make.
[13:07:28] <aatch> the point is that few languages are in between. most are all-or-nothing
[13:07:45] *** Joins: KindOne (KindOne@moz-FFCAD1D.dynamic.ip.windstream.net)
[13:08:41] <aatch> in C, you get none. it either type-checks there and then, or it's fine. no inference, no effects from other parts of the program, just "does this type equal this other type".
[13:08:54] <q66> obviously
[13:09:03] <aatch> in Haskell, ML, ATS you get a full global check
[13:09:07] <q66> I think global inference wouldn't work too well in Rust anyway
[13:09:10] <kyle2000> as just a normal rust user, not a genius or anything, i find the term "inference" to make more sense. it doesn't say "type" because it can go beyond just the types of course.
[13:09:26] <q66> this is on wikipedia's article on inference
[13:09:27] <q66> "The process by which a conclusion is inferred from multiple observations is called inductive reasoning."
[13:09:34] <q66> so I guess they're pretty much overlapping terms
[13:09:53] <aatch> kyle2000, sure, but I wasn't suggesting using it in the manual
[13:10:08] <q66> kyle2000, some languages use "type deduction" too
[13:10:15] <q66> I hear "inference" the most though
[13:10:24] <kyle2000> "reasoning" and "deduction" make me think of sherlock holmes. sherlock holmes makes me think of victorian england. victorian england makes me think of steam engines. steam engines make me think of stuff that isn't computers and isn't internet.
[13:10:52] <aatch> kyle2000, that is... I don't even know
[13:10:52] <kyle2000> i associate "inference" more with science, which is more like rust and software and computers and internet.
[13:11:18] <kyle2000> like i said, i'm not a genius. i'm kind of stupid. i'm just a normal rust user not a rust genius like you guys.
[13:11:45] *** Quits: KindOne (KindOne@moz-FFCAD1D.dynamic.ip.windstream.net) (Ping timeout)
[13:12:09] <kyle2000> us little people can get really confused by the complex words especially when we associate them with stuff that has nothing to do with computing and software.
[13:12:18] <engla> The name Rust makes me think of rust, engines and steam
[13:12:23] <q66> yep
[13:12:30] <q66> and the rust logo http://www.rust-lang.org/logos/rust-logo-128x128-blk.png
[13:12:38] *** Joins: KindOne (KindOne@moz-FFCAD1D.dynamic.ip.windstream.net)
[13:12:56] <aatch> kyle2000, don't talk to haskellers
[13:13:10] <q66> haha
[13:14:11] <kyle2000> i have unfortunately. they tell me of monads and categories and so on and so forth. after i decypher their high brow terms i then realize that the concepts are actually quite simple. but i think it is most unfortunate that other of us small mind programmers sometimes can't get beyond the academic terms.
[13:15:02] <aatch> kyle2000, that was my biggest thing for me.
[13:15:31] <aatch> "monads are easy once you understand applicative functors"
[13:15:51] <q66> if they add monads to Go, they have a cool name for them: "gonads". In Rust, no such thing is possible :(
[13:16:03] <engla> just like in math, the terms don't become familiar until you use the objects a bit
[13:16:56] <aatch> engla, it's more the fact that most of the Haskell community seem to forget that most programmers aren't academics.
[13:17:24] <engla> well I thought they called it a research language
[13:17:54] <xenocons> q66: heh,heh
[13:17:57] <kyle2000> engla: i think languages like c++ use terms that make sense but still describe the concepts without being all academic and high brow and uppity. average folk like me can understand what an "object" or a "template" or a "virtual function" is. they are everyday words.
[13:18:19] <engla> there's nothing obvious about virtual function
[13:18:22] <aatch> engla, well yeah, but that doesn't explain the hundreds of monads tutorials
[13:18:30] <q66> there's nothing obvious about C++ either
[13:18:42] *** Quits: sankha93 (Instantbir@1B27BD90.7C1EA8E.8B6C1D65.IP) (Ping timeout)
[13:18:49] <q66> TBH, C++ is kinda terrible
[13:19:08] <aatch> "Inside C++ is a great language struggling to get out"
[13:19:22] <engla> aatch: I don't think it makes sense to "blame" haskell for not making it more accessible.. I think most open source projects always become what the contributors want, they don't build it for someone else
[13:19:44] <q66> aatch, I have a custom definition for C++: "C, a few handy extensions and a pile of shit I pretend doesn't exist"
[13:19:52] <engla> they are writing the language that makes sense for them
[13:20:07] <q66> then it's pretty usable
[13:20:13] <q66> but it's hard to pretend the rest it doesn't exist :(
[13:20:32] *** Joins: infynyxx (infynyxx@moz-E95B370B.nyc.res.rr.com)
[13:21:34] <xenocons> for what its worth, ive heard inference the most, but reasoning makes perfect sense
[13:21:55] <q66> I guess it does make sense, but I've never heard it before until here now :P
[13:21:59] <q66> in programming context
[13:22:15] <xenocons> fair enough
[13:22:18] *** Quits: infynyxx (infynyxx@moz-E95B370B.nyc.res.rr.com) (Ping timeout)
[13:22:25] <q66> that was my original point anyway
[13:22:28] <kyle2000> yeah that's what i'm experiencing too. i expect to see the word "inference" used but not the word "reasoning" even if it does make sense after putting some thinking into it.
[13:22:44] <xenocons> well, one 'reasons' about their program
[13:23:02] *** Joins: sankha93 (Instantbir@1B27BD90.7C1EA8E.8B6C1D65.IP)
[13:23:14] <xenocons> but i think inference is the typical compiler term
[13:23:15] <kyle2000> to me "reasoning" includes more thinking and subjective analysis. but "inference" is looking at just the facts objectively.
[13:23:22] <xenocons> kyle2000: nice
[13:23:42] <xenocons> i like that
[13:24:32] <cmr> Inference analyzes the facts and produces subjective interpretation of them, outside of programmiland
[13:24:40] <q66> "inference" is when I infer knowledge from what I have
[13:24:51] <q66> "reasoning" is when I analyze a thing to get something.
[13:25:02] <q66> in the end it ends up the same I guess
[13:28:35] <kyle2000> the end result may be the same but it makes me think that the approach to getting there could vary in ways i don't want. if the docs say the compiler is "inferring", then i expect it to be looking at the facts i have expressed in the source code. if it can figure it out easily, then it does so. if it can't, it immediately gives up and gives me an error message. but with "reasoning" it makes me think it's doing more guessing about what i wan
[13:28:35] <kyle2000> t, and it may guess wrong but still go with its incorrect guess anyway to the detriment of my program's correctness without me being any the wiser!
[13:29:37] <MaikKlein> do you think it is possible to write a rust plugin for qtcreator? 
[13:30:02] <cmr> MaikKlein: that would generate rust code? no, until rust has qt bindings :p
[13:30:52] <q66> qt bindings for anything are typically a major pain in the ass
[13:31:17] <kyle2000> MaikKlein: if you mean to turn qtcreator into an ide that can be used for rust too then i think that would be a fantastic thing to have. qtcreator is one of the best ides out there and if you or somebody else made it work for developing rust apps then i would be very pleased.
[13:31:19] <EXetoC> there should be an official C API :>
[13:31:43] *** Joins: annodomini (lambda@moz-9AC5B452.hsd1.ma.comcast.net)
[13:31:50] <EXetoC> for qt that is. who wants to write one?
[13:32:08] <MaikKlein> kyle2000, yes that's what I meant
[13:32:09] <q66> nobody
[13:32:20] <q66> qt is terrible and writing a c api for it would be even worse
[13:32:48] <MaikKlein> But I haven't looked under the hood of qtcreator and I am not sure if you can write an Rust IDE plugin for it
[13:33:06] *** Quits: sankha93 (Instantbir@1B27BD90.7C1EA8E.8B6C1D65.IP) (Ping timeout)
[13:33:20] <q66> why do you need an IDE anyway, a decent text editor with syntax support and shell tools work just fine
[13:33:20] <cmr> I've only used it briefly before, but QtCreator doesn't look like an IDE I would want to use...
[13:33:44] <cmr> only IDE I've used that's worth using is visual studio
[13:33:51] <q66> oh nope.
[13:34:07] <MaikKlein> cmr, when did you try qtcreator?
[13:34:26] <cmr> MaikKlein: few months ago trying to get started with some simple qt code
[13:34:32] <xenocons> kyle2000: there is a tricky component to that (potentially) and one i might not be qualified to answer, but for actual correctness a formalisation via inference needs to take place, so i would need to ask: is there any inference heurestics (guessing) at compile time
[13:34:47] <xenocons> i think i need to check out the inference stuff more i guess
[13:35:07] <cmr> xenocons: the compiler doesn't guess. either you give it enough information that it *knows* what you want, or it errors out.
[13:35:49] <cmr> For example
[13:35:55] <cmr> rusti: let x = 5; x.to_str()
[13:35:58] -rusti- more than 5 lines of output, pastebinned: http://sprunge.us/acLV
[13:36:14] <xenocons> so i guess there isnt any reason for saying inference in docs :)
[13:36:24] <xenocons> er
[13:36:33] <xenocons> isnt any reason for not saying inference in docs*
[13:36:48] <cmr> xenocons: that's what is in the docs, and nobody planned on changing it
[13:36:58] <xenocons> cmr: so type ambiguity is your example?
[13:37:02] <cmr> It's called inference in all the literature I've read (which admittedly isn't much)
[13:37:07] <mleise> cmr: awesome example :)
[13:37:10] <MaikKlein> I really want to start some rust ide but just not completely from scratch. I probably want to extend some other ide or editor. I know that I could use eclipse for that, but I am not the biggest fan of eclipse :/ Any recommendations?
[13:37:20] *** Quits: jrfeenst (jrfeenst@moz-F912484F.cpe.norwoodlight.com) (Quit: jrfeenst)
[13:37:21] * xenocons coulda been sure that someone was saying calling it reasoning was bad 
[13:37:22] <xenocons> heh
[13:37:34] <cmr> MaikKlein: Well, what do you expect the IDE to accomplish?
[13:37:50] <xenocons> MaikKlein: emacs could be nice
[13:37:52] <cmr> MaikKlein: The best thing would be a completion daemon that hooks into the compiler to provide completion, which is entirely IDE-agnostic.
[13:37:57] <dbaupp> MaikKlein: emacs and/or vim ;P
[13:38:11] <mleise> Hey Eclipse is better than MonoDevelop
[13:38:15] *** Joins: sankha93 (Instantbir@E986871.E546FA5E.8B6C1D65.IP)
[13:38:18] <q66> vim, not emacs :P
[13:38:20] <xenocons> cmr: this could be a nice case for work on the REPL right?
[13:38:22] <MaikKlein> well I only want to have snippets which most ide' support and proper autocompletion 
[13:38:34] <q66> emacs is a pretty decent OS, but the text editor part is lacking
[13:38:56] <xenocons> q66: im not going into emacs vs vim war, but i dontn find its editor lacking
[13:39:07] <q66> they should create Emacs/Hurd
[13:39:25] <kyle2000> MaikKlein: what if you try geany? you can write plugins for it real easy like.
[13:39:33] <cmr> MaikKlein: proper autocompletion doesn't belong in an IDE, it belongs outside of it, so everyone can use it.
[13:39:54] *** Quits: sankha93 (Instantbir@E986871.E546FA5E.8B6C1D65.IP) (Ping timeout)
[13:39:58] *** Quits: BizarreCake (BizarreCak@32C9829A.151E84E7.561471F8.IP) (Ping timeout)
[13:40:01] <q66> IDEs are useless on pretty much any sane platform
[13:40:19] <q66> (sane == not windows)
[13:40:20] *** Joins: sankha93 (Instantbir@2BF6F88C.4C100BA0.8B6C1D65.IP)
[13:40:22] <xenocons> everyone wants something. TAB and get a nice list of functions you can call ;)
[13:40:58] <xenocons> getting RSI going to the rust docs all teh time to find out what functions are available heh
[13:41:27] <xenocons> tab completion and a rust repl, gogogo :)
[13:41:35] <MaikKlein> I never done autocompletion before but shouldn't this be really easy? I mean can't I just ask the compiler?
[13:41:38] <cmr> xenocons: there's already a repl, it's just mostly broken.
[13:41:47] <xenocons> cmr: yeah
[13:41:52] <EXetoC> I'm sure we'll have that for vim or whatever soon. yay
[13:41:58] <xenocons> i saw on the mailing list someone accusingit of being a hack too
[13:42:31] <cmr> MaikKlein: it's harder than it looks on the surface, for a variety of reasons, most of them being parsing an incomplete program to figure out the types of the things you're trying to complete on.
[13:43:48] *** Quits: sankha93 (Instantbir@2BF6F88C.4C100BA0.8B6C1D65.IP) (Ping timeout)
[13:44:04] <EXetoC> A first step might be to not consider any of the modified parts
[13:44:56] <dbaupp> is it possible to get the test runner to print the args it's compiling each test with?
[13:45:04] <EXetoC> assuming that the actual saved data does compile
[13:45:19] <aatch> dbaupp, you do make VERBOSE=1 check
[13:45:28] <cmr> MaikKlein: If you're up to it, adding in support to query the compiler for all the methods it can see on a type, or functions/types/modules in a certain scope, would be nice.
[13:45:39] <aatch> which'll make it print the command for each test.
[13:45:47] *** Quits: snearch (snearch@moz-AA459792.pool.mediaways.net) (Quit: Verlassend)
[13:46:02] <aatch> Oh, actually, nvm
[13:46:20] <dbaupp> aatch: that work, thanks
[13:46:39] <dbaupp> it seems my changes made the test runner itself crash... oops
[13:46:53] <aatch> lol
[13:48:14] <MaikKlein> cmr, the compiler already knows which methods are available for a given type right? So I just need to find a way to extract the information
[13:48:21] <cmr> MaikKlein: yup
[13:48:50] <cmr> MaikKlein: I'm not familiar with the code that does this. I imagine it's in librustc/middle/resolve.rs, but I don't know.
[13:49:03] <MaikKlein> cmr, cool this sounds like realistic project
[13:49:14] <MaikKlein> thanks
[13:50:28] <EXetoC> q66: indeed. rust for example is so greppable most of the time. I'd still use a symbol browser though had it existed, but using it in vim for example wouldn't really turn it into an IDE I guess
[13:50:42] <cmr> EXetoC: there's ctags support.
[13:50:42] *** Joins: jrfeenst (jrfeenst@moz-F912484F.cpe.norwoodlight.com)
[13:50:51] <kyle2000> MaikKlein: i am getting very excited to see what you produce. your efforts are getting me extremely aroused and i am only just hearing of them for the first time!
[13:51:06] *** Quits: FrozenCow (FrozenCow@moz-B2DF4929.chello.nl) (Ping timeout)
[13:52:08] *** Joins: sankha93 (Instantbir@BFECE1D6.6ABDE3A6.8B6C1D65.IP)
[13:52:45] <EXetoC> cmr: it seems to be a bit basic, but yeah I should give it a go some time
[13:52:50] <EXetoC> the rust plugin that is
[13:54:47] *** Joins: moonchrome (moonchrome@moz-A3A6B427.dsl.iskon.hr)
[13:56:47] *** Joins: e98 (e98@moz-70B1DE3B.dip0.t-ipconnect.de)
[13:56:53] <e98> hi
[13:57:05] <MaikKlein> cool there is already some documentation that I can read https://github.com/mozilla/rust/wiki/Note-Intrinsics
[13:57:42] <e98> I tried using a freshly built rustc to build rust @incoming, but it didn't work right away
[13:57:43] <MaikKlein> kyle2000, yeah I want auto completion so badly, that I am doing it now
[13:57:54] <cmr> e98: what do you mean?
[13:57:56] <e98> should it work and if so wouldn't it be great to update the snapshot
[13:58:07] <e98> cmr: --enable-local-rust --local-rust-root
[13:58:20] <cmr> e98: That almost never works, nor should it.
[13:58:30] <MaikKlein> btw is --parse-only already implemented?
[13:58:32] <cmr> You need a compiler old enough that it's compatible with the snapshot
[13:58:36] <cmr> MaikKlein: yes.
[13:59:20] <MaikKlein> cmr, ah I just didn't save my file, okay thats pretty nice
[13:59:42] *** Joins: jviereck (Adium@moz-74E0337C.dip0.t-ipconnect.de)
[13:59:51] <MaikKlein> what we also have linting support?
[14:00:11] <MaikKlein> ah
[14:00:14] <MaikKlein> ok nvm
[14:00:14] <cmr> Yes, those are the warnings. Most of them are on already.
[14:00:26] *** Joins: BizarreCake (BizarreCak@32C9829A.151E84E7.561471F8.IP)
[14:00:28] <e98> cmr: ok, I was trying to make use of the compiler speed ups that happened in incoming, but maybe stage1 or 2 already use the bootstrapped compiler and that should already be as fast as it can get
[14:00:46] <cmr> e98: Yes, after stage0 you're using the bootstrapped compiler.
[14:01:06] <MaikKlein> I just though it would already lint for https://github.com/mozilla/rust/wiki/Note-style-guide
[14:01:20] <e98> cmr: ok, so stage0 alwatys used the one from the dl/rust-foobar-tarball?
[14:01:30] <kyle2000> the more i use rust the more it reminds me of eminem. it's a tough young man coming of age in a difficult time in difficult surroundings. it's only got one shot to make it big. it's standing on the stage right now with go in a rap duel. the thugs are surrounding them and things are going to get heated.
[14:01:37] <kyle2000> snap back to reality, oh there goes gravity
[14:02:02] <e98> kyle2000: go and rust do not cater to the same needs or use cases from my point of view, to be honest
[14:02:15] *** Quits: victorporof (victorporo@FE2F04DC.63E19875.D111398B.IP) (Ping timeout)
[14:03:43] <e98> I haven't yet seen a description what rustc is doing that makes it look like there's a super expensive global optimization and lto phase going on
[14:04:02] <kyle2000> e98: i agree to some extent. but there is a lot of overlap and there is a duel in progress. the world needs a premiere compiled language with high level features. c++ was that language and still is to a big extent. but the only other real competitors are go and rust. d is a good language but let's face it, it isn't catching on. ocaml is good, too, but it's a wee bit too academic. and haskell is far too academic to see widespread use.
[14:04:18] <aatch> e98, the optimization stage is quite slow for a number of reasons
[14:04:20] <e98> but for even a oneliner change building rust takes a long time
[14:04:35] <aatch> e98, the unit of compilation is an entire library.
[14:05:25] <e98> kyle2000: I won't go into that due to having strong opinions
[14:05:36] <cmr> e98: yup
[14:05:43] <doomlord> the rust compile units are large, because so many functions are effectiely like C++ templates ?
[14:05:59] *** Quits: MaikKlein (maik@moz-76A64E0E.dip0.t-ipconnect.de) (Ping timeout)
[14:06:14] *** Joins: victorporof (victorporo@FE2F04DC.63E19875.D111398B.IP)
[14:06:17] <aatch> doomlord, well actually, it's got more to do with the fact that rustc is massive.
[14:06:17] <cmr> doomlord: no, because the compliation unit is a single crate, and crates get huge
[14:06:20] <doomlord> but at least rust could theoretically do more work on each translation unit independently than C++ can, i think
[14:06:49] <aatch> doomlord, except that the library is the translation unit
[14:07:08] <aatch> or the entire binary.
[14:07:34] <aatch> while it is possible to get just an object file, you don't get multiple object files.
[14:07:41] <doomlord> whats the full terminology here... in C++ you need header files.. i word that as "translation unit" - smallest peice of source that can be processed
[14:07:58] <cmr> doomlord: Yes, that's the same terminology we're using.
[14:07:58] <e98> kyle2000: let me just say that I wish rust will lean into the expressive strong type system camp with an emphasis on static checking even more to distinguish itself
[14:08:15] <doomlord> what words am i looking for to describe the difference between rust (context-free?) and C++ (half the program in headers included to compile a source file)
[14:08:38] <aatch> doomlord, I have no idea.
[14:08:44] <cmr> I don't know if there are words for that
[14:08:47] <aatch> there aren't really words for that.
[14:08:51] <e98> doomlord: header files have been a constant waste of energy and human life time for over 30 years now that it's not funny and someone should be punished for it
[14:09:15] <doomlord> e98 - agree 100%
[14:09:28] <aatch> wow. that is intense.
[14:09:42] <kyle2000> doomlord: cohesion?
[14:10:20] <cmr> header files aren't *that* bad, and they allow compilation without having a local, compiled copy of a library, which you need with both rust and other systems that use the metadata-in-binary approach
[14:10:21] <kyle2000> header files aren't so bad if using a compiler that supports precompiled headers.
[14:10:56] <doomlord> header files are bad because when you refactor things you have to navigate to and modify more locations, needlessly
[14:11:16] <cmr> I agree. They aren't good and definitely not preferable.
[14:11:29] <EXetoC> copy/paste yay
[14:11:52] <doomlord> blah::foo(a,b,c) -->  declaration is blah { ..... foo(a,b,c) ... can't copy/paste it
[14:12:28] <cmr> I once spent days debugging a weird transient issue with a program, turned out it was dying because I didn't include <algorithm> or something like that, and that was causing issues with the STL
[14:12:39] <doomlord> annoys me so much, because it would take such a small change to C++ syntax to avoid it
[14:13:31] <doomlord> a few extra keywords or bits of syntax 'let','fn','var:type'  ... win ,IMO
[14:13:45] <doomlord> preferable to headers any day
[14:13:49] *** Joins: Sorella (queen@B12A78F5.BA14766C.95C8B7C6.IP)
[14:14:40] <doomlord> i would even be interested in C++ with a cleaned up syntax like that ( i gather there was a proposal).. imagine some mutated subset of rust as a *literally* cleaned up C++ :)
[14:16:06] <EXetoC> might as well kill it off instead and give other languages a chance to shine huehue
[14:17:01] <kyle2000> doomlord: i don't think that you can really just reduce c++ or clean it up. it has developed as it has because deficiencies have been experienced with earlier, simpler subsets. just look at how many others have tried something similar and then look at how they all evolve closer to c++ over time. java has done this, c# has done this, and d has done this.
[14:17:38] <e98> doomlord: before ANSI C (89) it wasn't clear that would become the English of computer languages
[14:18:10] <e98> I think header files are really bad and it's a reason why the cupertino llvm team proposed a C and C++ syntax extension for modules
[14:18:20] <e98> at last November's llvm dev meeting
[14:18:44] <cmr> Yeah, that proposal was interesting and I hope it becomes widely adopted.
[14:18:54] <doomlord> i wondered this too, could some simple extra keywords disambiguate..and add new compiler warnings to encourage people to do minor refactoring
[14:19:18] <e98> I haven't used precompiled headers on non-Windows systems but with msvc at least it was a source of build errors
[14:19:31] <e98> cmr: me too
[14:19:51] <doomlord> i dont like the way C++ makes headers worse
[14:19:52] <e98> cmr: much more important than all the bling they're adding atop C++98
[14:21:14] *** Quits: kyle2000 (kyle2000@D3528B97.7E2E8376.3031298E.IP) (Quit: Leaving)
[14:21:30] *** Quits: jaen (jaen@moz-E0979827.copit.pl) (Quit: WeeChat 0.4.1)
[14:24:52] *** Quits: e98 (e98@moz-70B1DE3B.dip0.t-ipconnect.de) (Quit: leaving)
[14:26:19] *** Quits: jviereck (Adium@moz-74E0337C.dip0.t-ipconnect.de) (Quit: Leaving.)
[14:28:08] *** Joins: e98 (e98@moz-70B1DE3B.dip0.t-ipconnect.de)
[14:28:25] *** cscott is now known as cscottnet_away
[14:34:17] *** Quits: Cromulent (Cromulent@moz-983B638D.cable.virginmedia.com) (Quit: KVIrc 4.2.0 Equilibrium http://www.kvirc.net/)
[14:36:31] <q66> <EXetoC> q66: indeed. rust for example is so greppable most of the time. I'd still use a symbol browser though had it existed, but using it in vim for example wouldn't really turn it into an IDE I guess
[14:36:42] <q66> EXetoC, that's mainly thanks to Rust's well designed context free grammar
[14:36:48] *** Joins: SiegeLord (sl@moz-CAF07B4C.hsd1.ma.comcast.net)
[14:36:59] <q66> you exactly know where a type belongs and stuff
[14:37:04] <q66> so you can easily grep for anything using patterns
[14:38:08] <EXetoC> right
[14:39:36] <q66> some people hate types on the right side in function arguments or how "let" works (e.g. let foo: int = ... rather than int foo = ....)
[14:39:44] <q66> but it's really useful in the end :P
[14:42:06] *** Joins: FrozenCow (FrozenCow@moz-B2DF4929.chello.nl)
[14:52:21] *** Joins: reyre_ (reyre@moz-9002CDDA.cpe.net.cable.rogers.com)
[14:54:15] <bstrie> q66: I agree, I'm so happy with how easy it is to grep for `fn foo` and `let foo`
[14:54:21] *** Quits: jrfeenst (jrfeenst@moz-F912484F.cpe.norwoodlight.com) (Quit: jrfeenst)
[14:54:22] <bstrie> and it avoids that C nonsense of
[14:54:23] <bstrie> int
[14:54:24] <bstrie> foo()
[14:56:51] <q66> I never use that nonsense in C(++)
[14:56:54] <q66> I just write "int foo()"
[14:57:06] <cmr> doesn't help old codebases.
[14:57:48] *** Joins: int3_ (int3_@moz-ABE52D50.hsd1.ca.comcast.net)
[15:00:36] *** Quits: FrozenCow (FrozenCow@moz-B2DF4929.chello.nl) (Ping timeout)
[15:02:44] *** Quits: reyre_ (reyre@moz-9002CDDA.cpe.net.cable.rogers.com) (Client exited)
[15:03:01] <xenocons> woot, got rustc compiled on windows 
[15:03:31] <cmr> xenocons: are you a windows developer?
[15:03:34] <dbaupp> xenocons: \o/
[15:04:31] <bstrie> xenocons: congratulations
[15:04:33] <xenocons> cmr: i use windows yup, wouldn't call myself a dev though hehe
[15:04:49] <bstrie> I really can't remember anyone actually achieving that before
[15:05:06] <cmr> I build rust on windows at least weekly..
[15:05:08] <xenocons> lol, i am the only person using windows? doubtful
[15:06:05] <EXetoC> xenocons: yup!
[15:06:54] <dbaupp> someone open a pull request! bors is getting bored ;p
[15:07:37] <xenocons> dbaupp: do you want to fix the static struct vector length bug :P
[15:07:55] <cmr> what bug is that?
[15:08:01] <xenocons> https://github.com/mozilla/rust/issues/7012
[15:08:30] <dbaupp> rusti: struct A { f: &'static [u32] } static a: A = A { f: &[1,2,3,4,5,6] }; a
[15:08:33] -rusti- {f: &[4220240, 0, 24, 0]}
[15:08:42] <dbaupp> cmr: ^
[15:09:14] <cmr> that's yucky
[15:09:49] <dbaupp> yeah
[15:10:53] <xenocons> i think its the last problem im facing before i can release my code at work :^)
[15:10:59] *** Joins: FreezerburnV (freezerbur@moz-5718C330.bltmmd.fios.verizon.net)
[15:11:08] <xenocons> might see if i can get some exp tmr looking at the codegen stuff
[15:11:13] <cmr> xenocons: you're using rust in production :|
[15:11:21] <xenocons> production? nah heh
[15:11:24] <cmr> (that was a quyestion)
[15:11:31] <xenocons> oh nah im not
[15:11:47] <xenocons> im not a developer\programmer but i do need to write pocs\prototypes for stuff
[15:11:55] <xenocons> mostly for my own use
[15:12:08] <cmr> Why use rust, then?
[15:12:20] <xenocons> i was waiting for an excuse to try rust out, had some GC issues with .net
[15:12:31] <xenocons> felt it might be nice to jump completely in the deep end
[15:12:41] <xenocons> hurray because i found a bug and felt like i achieved something heh
[15:13:11] <xenocons> and i feel like ive definetly learned a lot more rust in the 2 days ive been doing it
[15:13:29] <xenocons> im even more motivated to write stuff now (pending IO rewrite of course)
[15:13:34] *** Joins: MaikKlein (maik@moz-76A64E0E.dip0.t-ipconnect.de)
[15:13:38] <dbaupp> xenocons: aatch investigated the bug and he knows the problem
[15:13:44] <dbaupp> not sure if he's working on it
[15:13:50] <xenocons> ah
[15:14:00] <aatch> dbaupp, I am
[15:14:05] <dbaupp> yay :D
[15:14:08] <xenocons> id love to hear how its fixed, not just it getting fixed, so i can work out how to get further next time
[15:14:35] <xenocons> this is fun, like pokemon but with programming
[15:15:11] <dbaupp> I believe the problem is (possibly) the constant-generating code isn't emitting the correct thing
[15:15:29] <aatch> at some point the struct that represents the vector gets re-wrapped in another struct.
[15:15:31] <dbaupp> and so a pointer gets wrapped in a pointer, when it should just be keep unwrapped
[15:15:53] <dbaupp> aatch: oh, I got close? :)
[15:16:04] <aatch> dbaupp, yep.
[15:16:24] <xenocons> interesting, so this happens between rustc and llvm?
[15:16:57] <xenocons> (or is it a problem in llvm)
[15:17:39] <aatch> xenocons, it's a rustc problem
[15:19:11] <xenocons> if i wanted to look at the code responsible for generating the bytecode before consumed by llvm, wherer to look?
[15:19:15] <xenocons> is it librustc?
[15:19:22] <cmr> xenocons: src/librustc/middle/trans
[15:19:24] <cmr> have fun
[15:19:26] *** Joins: Cromulent (Cromulent@moz-983B638D.cable.virginmedia.com)
[15:19:28] <xenocons> heh
[15:19:49] <xenocons> bigfiles
[15:20:06] <xenocons> advantage: learn nuts and bolts? :)
[15:20:15] <dbaupp> xenocons: that folder specifically is some of the oldest code around
[15:20:28] <dbaupp> so don't go picking up idioms from it ;P
[15:20:33] <xenocons> heh
[15:20:53] <xenocons> maybe i should not cast my eyes upon it?
[15:20:53] <aatch> xenocons, I do not wish trans upon anyone...
[15:21:10] <aatch> xenocons, learn Rust proper first
[15:21:39] <xenocons> aatch: right, i guess i can rewrite some more code into rust?
[15:21:52] <aatch> insulate yourself from the horror of trans
[15:21:53] *** Joins: jrfeenst (jrfeenst@moz-F912484F.cpe.norwoodlight.com)
[15:22:01] <xenocons> heh
[15:22:09] <aatch> xenocons, sure, if you want
[15:22:10] <xenocons> lets rename it tranny
[15:22:14] <dbaupp> xenocons: now you've got new rust write Boyer-Moore and get it merged back into std :D
[15:22:44] <xenocons> dbaupp: good idea , im guessing my current hacky horspol wouldnt get allowed into std
[15:23:11] <cmr> "Hacky horspol"
[15:23:14] <cmr> I like how that sounds
[15:23:20] <xenocons> hah
[15:23:37] <xenocons> i think its 'horspool' whoops
[15:24:06] <xenocons> i cant help feel its bruteforce
[15:24:12] <xenocons> i think KMP could be easy to add though
[15:24:28] <dbaupp> anything better than a naive search!
[15:24:31] <xenocons> optimized boyer moore (from what ive seen) seems to require a lot of weird stuff
[15:24:47] <xenocons> dbaupp: http://codepad.org/Pd5hxSwC one im using atm
[15:25:10] <xenocons> id like to add kmp and test
[15:25:16] <xenocons> but sometimes naive will be fastest i think
[15:25:36] <dbaupp> for short strings
[15:25:44] <xenocons> wait i found a really excellent link today
[15:25:54] <xenocons> http://www-igm.univ-mlv.fr/~lecroq/string/index.html
[15:26:00] <cmr> the silver searcher uses boyer-moore-horspool
[15:26:33] <dbaupp> xenocons: that code doesn't look too bad
[15:26:54] <xenocons> dbaupp: its mostly translated from some C i found on google
[15:27:17] <xenocons> i think a hashed approach could be better for larger strings
[15:27:20] <xenocons> like a modified kmp
[15:27:38] <cmr> how large are we talking?
[15:27:41] <dbaupp> *anything* other than naive! ;P
[15:27:48] <cmr> after a certain point, strings aren't a good data structure anymore
[15:27:52] <xenocons> http://www-igm.univ-mlv.fr/~lecroq/string/node32.html#SECTION00320 or this (already has the C!)
[15:27:57] *** Quits: tgt (tgt@moz-D59EE478.aztw.cable.virginmedia.com) (Quit: Computer has gone to sleep.)
[15:28:05] <xenocons> cmr: right, even worse that i use it for byte arrays!
[15:28:12] <xenocons> but good point to ask how large
[15:29:20] <xenocons> i guess 67967488 is the biggest length i have atm
[15:30:31] <dbaupp> rusti: str::find_str(str::repeat("a", 1000000), fmt!("%sX", str::repeat("a", 10000)))
[15:30:33] -rusti- more than 5 lines of output, pastebinned: http://sprunge.us/iBJO
[15:30:48] <dbaupp> rusti: use std::str; str::find_str(str::repeat("a", 1000000), fmt!("%sX", str::repeat("a", 10000)))
[15:30:55] -rusti- timeout triggered!
[15:31:02] <xenocons> yeah thats quite slow lol
[15:31:23] *** Quits: MaikKlein (maik@moz-76A64E0E.dip0.t-ipconnect.de) (Ping timeout)
[15:31:45] <dbaupp> ('a'*10000+'X') in ('a'*1000000) in Python answers instantaneously
[15:33:09] <xenocons> likewise with .net
[15:33:24] <xenocons> need to reverse indexof
[15:33:32] <xenocons> i like its perf on strings
[15:33:49] <xenocons> crud 1;30 bbtmr
[15:34:58] <aatch> xenocons, pussy! 3:30am here
[15:36:45] <dbaupp> xenocons: australia? (sydney?)
[15:39:12] *** Quits: jensnockert (jensnocker@moz-8BE55278.customer.t3.se) (Input/output error)
[15:41:44] <doener> dbaupp: was there any progress on the static slice issue?
[15:42:00] <dbaupp> doener: aatch is working on it
[15:42:19] <doener> ah, great, then I can look for something I actually understand :-)
[15:42:51] *** Joins: jmgrosen (jmgrosen@moz-848F6087.sb.sd.cox.net)
[15:43:23] <aatch> doener, yeah, I know the problem, I'm just not sure where it occurs
[15:43:42] *** Joins: pongad (Mibbit@moz-483DE200.hfc.comcastbusiness.net)
[15:44:20] *** Quits: pongad (Mibbit@moz-483DE200.hfc.comcastbusiness.net) (Quit: http://www.mibbit.com ajax IRC Client)
[15:45:17] <doener> aatch: I was pretty confused by the whole constant translation. Couldn't figure out where it actually walks the struct.
[15:45:43] <aatch> it's split between trans/consts.rs and trans/adt.rs
[15:46:39] <doener> oh, trans_const
[15:47:01] *** Quits: rajul (quassel@A2DDF553.812B5995.2051BA92.IP) (Client exited)
[15:50:28] *** Quits: jmgrosen (jmgrosen@moz-848F6087.sb.sd.cox.net) (Quit: jmgrosen)
[15:52:34] *** Quits: a__ (a__@moz-250D9B4.nycmny.fios.verizon.net) (Client exited)
[15:54:32] *** Joins: erickt (Adium@49C4075F.3AC15C18.2321E71E.IP)
[15:55:11] <cmr> Has the whole structure of the compiler even been audited?
[15:55:15] <cmr> The callgraph and such
[15:55:46] *** Quits: RMF (RMF@moz-D471E70.dsl.telepac.pt) (Ping timeout)
[15:55:46] *** Quits: igl1 (igl@moz-B79703D8.adsl.alicedsl.de) (Ping timeout)
[15:56:01] *** Joins: igl (igl@moz-EDD2E3B6.adsl.alicedsl.de)
[15:56:04] *** Joins: steven_is_false (user@moz-144077DE.bchsia.telus.net)
[15:56:51] *** Joins: askalski (akuda@moz-1BD89C3F.neoplus.adsl.tpnet.pl)
[15:58:19] <doener> is somebody with a 32bit build of rust around who could this? https://github.com/mozilla/rust/issues/7012#issuecomment-19146215
[15:59:14] *** Joins: RMF (RMF@E80DA7BB.A3D80C3C.8D19547B.IP)
[15:59:39] <doener> nvm, got my answer
[15:59:43] <aatch> doener, I can already tell you the result, it would say the vector is 3 long instead of 4
[16:00:38] <doener> yeah, it's the auto borrow that doesn't deref, right? Dropping the & from the "pattern" field initializer makes the problem go away
[16:01:06] <aatch> doener, still compiles though?
[16:01:26] <doener> Sure. Triggers the auto borrowing, doesn't it?
[16:01:39] <aatch> doener, weird
[16:02:13] *** Joins: tgt (tgt@moz-D59EE478.aztw.cable.virginmedia.com)
[16:02:26] <doener> aatch: same as for the signature2 case, which also has just a static str, not a slice
[16:03:07] <aatch> but otherwise, it looks like you're right.
[16:03:15] *** Joins: jensnockert (jensnocker@moz-8BE55278.customer.t3.se)
[16:03:54] <doener> just that the string also works with a & in front, which could make sense given that some parts I looked at earlier handled string in a special way, but not vectors
[16:04:52] <dbaupp> doener: I thought &str was syntactic sugar for &[u8]?
[16:07:07] *** Joins: MaikKlein (maik@moz-76A64E0E.dip0.t-ipconnect.de)
[16:07:44] *** Quits: Cromulent (Cromulent@moz-983B638D.cable.virginmedia.com) (Quit: KVIrc 4.2.0 Equilibrium http://www.kvirc.net/)
[16:11:44] *** Quits: askalski (akuda@moz-1BD89C3F.neoplus.adsl.tpnet.pl) (Quit: Wychodzi)
[16:12:06] <doener> sorry, confused vstore vs. vec, not vs. str
[16:13:06] *** Joins: reyre_ (reyre@moz-9002CDDA.cpe.net.cable.rogers.com)
[16:13:48] <aatch> doener, ok, so it's the auto-borrow.
[16:14:23] *** Quits: MaikKlein (maik@moz-76A64E0E.dip0.t-ipconnect.de) (Ping timeout)
[16:14:33] *** Joins: jfbk (user@moz-EEA9CFB3.nyc.res.rr.com)
[16:14:48] <aatch> as in, I know the exact line that adds the extra wrap
[16:14:53] *** Joins: jmgrosen (jmgrosen@moz-848F6087.sb.sd.cox.net)
[16:14:53] *** Quits: reyre_ (reyre@moz-9002CDDA.cpe.net.cable.rogers.com) (Ping timeout)
[16:15:27] <aatch> (which won't map to what you have because I've adding debugging stuff)
[16:15:38] <dbaupp> aatch: delete it!
[16:15:49] <dbaupp> it's probably not useful, right? ;P
[16:18:41] *** Quits: e98 (e98@moz-70B1DE3B.dip0.t-ipconnect.de) (Quit: leaving)
[16:20:15] <cmr> Can I break out of a match arm?
[16:20:35] <aatch> cmr, in what way?
[16:21:36] *** Quits: steven_is_false (user@moz-144077DE.bchsia.telus.net) (Client exited)
[16:22:26] <dbaupp> rusti: loop { match 1 { 2 => {}, _ => break } } 1
[16:22:28] -rusti- 1
[16:23:07] *** Yurume_ is now known as Yurume
[16:23:46] <Yurume> is there any way to switch the ABI of extern block depending on the --cfg switch?
[16:24:35] <aatch> dbaupp, strangely, your idea worked.
[16:24:52] <dbaupp> aatch: does it break other things?
[16:25:00] <aatch> I haven't checked yet
[16:25:08] <dbaupp> Yurume: you could wrap it in a module and put #[cfg(foo)] on the module
[16:25:50] <aatch> dbaupp, it does break other things.
[16:25:59] <dbaupp> delete them?
[16:26:00] <dbaupp> :P
[16:26:00] <EXetoC> cmr: it's possible to define blocks inside the arms, so just insert some logic there
[16:26:24] <Yurume> dbaupp, like this: `#[cfg(foo)] #[abi="stdcall"] mod ll; #[cfg(not(foo))] #[abi="cdecl"] mod ll;`?
[16:26:50] <dbaupp> cmr: don't put `return match { ... break ... }` though, the combination of return and break... err... breaks things
[16:26:58] <cmr> https://github.com/cmr/rust/blob/eb1ef2a84b205bb9d0c631ffcbf12372fda321fe/src/libextra/terminfo/parm.rs#L86
[16:27:00] <dbaupp> Yurume: I guess so... not really sure
[16:27:05] <cmr> (Ignore the previous arm, it's broken)
[16:27:09] <cmr> I want something like that
[16:27:16] <EXetoC> rusti: match 2 { 1 => { "0" }, _ => { if 42 > 0 { "cats" } else { dogs } } } 
[16:27:17] -rusti- more than 5 lines of output, pastebinned: http://sprunge.us/AaBP
[16:27:20] <Yurume> I don't know whether #[abi] is propagated or not
[16:27:20] <EXetoC> rusti: match 2 { 1 => { "0" }, _ => { if 42 > 0 { "cats" } else { "dogs" } } } 
[16:27:21] -rusti- "cats"
[16:27:34] <dbaupp> cmr: oh... `loop`
[16:27:39] <dbaupp> ?
[16:27:59] <cmr> dbaupp: No, I want the stuff in the while loop but outside of that match to execute
[16:28:02] <cmr> https://github.com/cmr/rust/blob/eb1ef2a84b205bb9d0c631ffcbf12372fda321fe/src/libextra/terminfo/parm.rs#L202
[16:28:05] <cmr> What I really want is goto :p
[16:28:09] <dbaupp> cmr: oh
[16:28:48] <dbaupp> you can do `loop { if .. { break } ... break; }`
[16:28:50] <jmgrosen> could someone help me? i'm getting "error: internal compiler error: translating unsupported cast." https://gist.github.com/jmgrosen/5735727
[16:29:48] <dbaupp> jmgrosen: I can reproduce it
[16:29:48] <cmr> jmgrosen: pretty sure you want *mut c_void, not *()
[16:30:08] <jmgrosen> okay, i'll try that, someone else had recommended *()
[16:31:02] <jmgrosen> same error :(
[16:31:17] <dbaupp> cmr: there's also `Percent if state == ... => {} Percent => { match cur { ... } }`
[16:31:22] <dbaupp> which is probably nicer
[16:31:36] <dbaupp> (i.e. split the Percent arm into 2)
[16:31:40] <cmr> dbaupp: ohh, that is nicer
[16:31:44] <EXetoC> jmgrosen: you replaced all instances?
[16:31:51] <jmgrosen> yup
[16:32:22] *** Joins: MaikKlein (maik@moz-76A64E0E.dip0.t-ipconnect.de)
[16:33:07] <dbaupp> jmgrosen: it appears to be the `mem_callback as *()` cast
[16:33:07] <cmr> I'm guessing it's "mem_callback as *()"
[16:33:21] <cmr> You want extern "C" fn mem_callback...
[16:33:30] <cmr> Then you should be able to pass it in directly I think
[16:33:34] <cmr> not sure
[16:33:35] <dbaupp> cmr: yep, that works
[16:33:35] <jmgrosen> okay, i'll try that
[16:33:44] <dbaupp> cmr: just tested it
[16:33:45] <cmr> might be pending on nmatsakis's extern fn cleanup
[16:34:00] <dbaupp> (works in the sense of "compiles")
[16:34:23] *** Joins: askalski (akuda@moz-1BD89C3F.neoplus.adsl.tpnet.pl)
[16:34:32] <jmgrosen> compilesâ€¦ then segfaults :(
[16:34:36] <jmgrosen> time to debug
[16:34:58] <cmr> userp: &mut ~[u8]
[16:35:08] <dbaupp> jmgrosen: passing Rust functions into C is unreliable/doesn't work (as far as I understand it)
[16:35:08] <cmr> Giving that to a C function sounds like a really really bad idea.
[16:35:45] <jmgrosen> alright then
[16:35:49] <jmgrosen> :/
[16:36:18] <jmgrosen> well, it looks like the callback is getting called, as debugged from a debug!
[16:36:30] <jmgrosen> so now to find where the bug is
[16:36:32] <cmr> I'm guessing accessing userp is killing it
[16:36:43] <cmr> because ~[] aren't just a pointer to bytes.
[16:37:00] <cmr> or maybe they are and I'm confusing them with &[]
[16:37:23] <dbaupp> &[] is (pointer, length) combo
[16:37:33] <dbaupp> ~[] is "plain" pointer
[16:37:40] <jmgrosen> well, i've narrowed it down to the vdc::push_all_move part
[16:37:43] <jmgrosen> *vec
[16:37:54] <jmgrosen> so it's probably something to do with the vector pointer, eys
[16:37:55] <jmgrosen> *yes
[16:37:57] <dbaupp> (as in, it should be, but currently points to (header, data) rather than just data)
[16:39:35] *** zz_kimundi is now known as kimundi
[16:39:41] <jmgrosen> is there anyway i can give it the pointer to the data correctly?
[16:39:59] <jmgrosen> i'm still a little fuzzy with ~ and &
[16:40:09] <aatch> I have reached the end of my knowledge here, as the issue seems to relate to adjustments but I have no idea how that works
[16:40:28] *** Quits: koomi (koomi@moz-E8AECC1E.pools.arcor-ip.net) (Ping timeout)
[16:40:32] *** Quits: nielsle (nielsle@moz-5CE8ECCD.boa.fiberby.dk) (Ping timeout)
[16:40:35] *** aatch is now known as aatch|sleep_now_autoborrow_lat
[16:40:46] <dbaupp> jmgrosen: you can pass a * pointer
[16:40:53] *** aatch|sleep_now_autoborrow_lat is now known as aatch|sleepnowautoborrowlater
[16:40:58] <dbaupp> but I don't know how you can pass one that you can extend
[16:41:36] <MaikKlein> is it possible to just compile rustc?
[16:41:43] <cmr> MaikKlein: as opposed to?
[16:42:06] <MaikKlein> so I don't have to rebuild rust all the time
[16:42:18] <cmr> you don't have to build all the stages
[16:42:34] <cmr> make stage1-rustc works I think
[16:42:37] <cmr> might be rustc-stage1
[16:43:03] <EXetoC> also, there's a snapshot repository for arch linux
[16:43:22] <cmr> the binary is in, on my system, x86_64-unknown-linux-gnu/stage1/bin
[16:43:43] *** Quits: erickt (Adium@49C4075F.3AC15C18.2321E71E.IP) (Quit: Leaving.)
[16:48:22] *** Joins: unbracketed (textual@moz-7F0EE151.lsanca.fios.verizon.net)
[16:49:09] *** Joins: erickt (Adium@49C4075F.3AC15C18.2321E71E.IP)
[16:54:38] <MaikKlein> cmr, thanks <3
[16:57:34] *** Joins: nielsle (nielsle@moz-5CE8ECCD.boa.fiberby.dk)
[17:00:52] *** Quits: jrfeenst (jrfeenst@moz-F912484F.cpe.norwoodlight.com) (Quit: jrfeenst)
[17:01:49] *** Joins: strcat (strcat@moz-54F7FD49.cpe.net.cable.rogers.com)
[17:03:11] <Yurume> dbaupp, okay, #[abi=...] approach doesn't work, mainly because only the `extern "abi" { ... }` form works now
[17:03:23] <Yurume> and `extern "abi" { include!(...) }` doesn't work
[17:03:32] <Yurume> :S
[17:04:51] *** kimundi is now known as zz_kimundi
[17:07:50] *** Quits: MaikKlein (maik@moz-76A64E0E.dip0.t-ipconnect.de) (Ping timeout)
[17:08:45] <strcat> dbaupp: how is that vector thing going?
[17:09:13] <dbaupp> strcat: just running final tests now
[17:09:16] <strcat> :)
[17:09:28] <dbaupp> doing test [pretty] atm
[17:09:34] <dbaupp> so almost there
[17:10:19] <dbaupp> strcat: 449 insertions(+), 952 deletions(-)
[17:10:27] <dbaupp> just made it to 500 lines removed :D
[17:10:36] <dbaupp> Yurume: oh... not sure
[17:12:38] <strcat> dbaupp: once we have default optimizations one of the simple examples we can do is range(1, 100, 2).len() ;p
[17:12:53] <strcat> well... it depends
[17:13:25] <dbaupp> "default optimizations"?
[17:13:31] <strcat> default methods.
[17:13:34] <strcat> brain is melted
[17:13:42] <dbaupp> heh
[17:14:35] *** Quits: Jesse (jruderman@moz-537BCF9.hsd1.ca.comcast.net) (Quit: Jesse)
[17:14:59] *** Joins: Jesse (jruderman@moz-537BCF9.hsd1.ca.comcast.net)
[17:15:17] *** Parts: z0w0 (zack@FDF4EF6A.2CA5CD8.5F93A189.IP) ()
[17:15:51] *** Joins: MaikKlein (maik@moz-76A64E0E.dip0.t-ipconnect.de)
[17:16:45] <dbaupp> strcat: https://github.com/mozilla/rust/pull/7015
[17:18:12] <strcat> yay
[17:19:32] *** Quits: RMF (RMF@E80DA7BB.A3D80C3C.8D19547B.IP) (Ping timeout)
[17:20:29] * strcat hated those all2 methods
[17:21:48] <dbaupp> and now they're (almost) gone
[17:22:43] <dbaupp> wow, just looking at the commit list... I'm really inconsistent
[17:23:38] <dbaupp> strcat: also... I guess there should be some documentation about iterators
[17:23:51] <dbaupp> given they're becoming the main iteration tool
[17:24:34] <dbaupp> (documentation, as in, in the tutorial/manual)
[17:25:40] <strcat> yeah
[17:25:46] <strcat> dbaupp: I want to make a container/iterator tutorial
[17:25:56] <dbaupp> I want you to too :P
[17:26:00] <strcat> and we can use them as examples in the tutorial
[17:26:04] <strcat> like for freezing
[17:26:16] <dbaupp> yup
[17:26:46] <strcat> cleaning up the APIs is a big deal - it will make vectors/strings much easier to use
[17:27:10] <strcat> same tools for working with any container/generator :)
[17:27:17] *** Joins: ghrust (ghrust@79968228.6A2AE50.F3114085.IP)
[17:27:17] <ghrust> 01[13rust01] 15bors pushed 0 new commits to 06auto: 02http://git.io/RnZxfQ
[17:27:18] *** Parts: ghrust (ghrust@79968228.6A2AE50.F3114085.IP) ()
[17:27:21] *** Joins: ghrust (ghrust@AC22872E.6A2AE50.F3114085.IP)
[17:27:21] <ghrust> 01[13rust01] 15bors pushed 8 new commits to 06auto: 02http://git.io/7T52Zg
[17:27:21] <ghrust> 13rust/06auto 14ce4f63d 15Huon Wilson: std: add reverse vec iterators, replace vec::each*_reverse.
[17:27:21] <ghrust> 13rust/06auto 1465c7c58 15Huon Wilson: std: remove {all*,any*,count} in favour of iterators
[17:27:21] <ghrust> 13rust/06auto 14ed299af 15Huon Wilson: std: remove fold[lr] in favour of iterators
[17:27:23] *** Parts: ghrust (ghrust@AC22872E.6A2AE50.F3114085.IP) ()
[17:27:23] *** Quits: annodomini (lambda@moz-9AC5B452.hsd1.ma.comcast.net) (Quit: annodomini)
[17:27:51] <dbaupp> yup. all we need now is default methods
[17:28:18] <MaikKlein> I am only compiling rustc but it still takes around 8min, can I somehow speed up the process?
[17:28:22] <dbaupp> (vec.rs + str.rs are now only 8300 lines combined)
[17:28:38] <dbaupp> MaikKlein: get a faster computer is the only solution
[17:28:54] <dbaupp> (well, diving into the compiler would work too)
[17:29:25] <strcat> dbaupp: I've also been pondering making them a bit more D-like
[17:29:29] <strcat> but that's a simple change
[17:29:37] <MaikKlein> I thought maybe I could turn the optimizations off or sth?
[17:29:42] <strcat> we could rename Iterator to ForwardRange and next to pop_front
[17:29:58] <strcat> and slices could *be* the iterators for strings/vectors
[17:30:02] <MaikKlein> if there are some for rustc , I have no idea 
[17:30:24] <dbaupp> MaikKlein: ./configure --disable-optimize or something (./configure --help probably lists it)
[17:30:35] <dbaupp> strcat: I've not used D... documentation link?
[17:30:44] <strcat> dbaupp: http://dlang.org/phobos/std_range.html
[17:30:56] <bblum> CFG_DISABLE_OPTIMIZE=1 make
[17:31:01] <bblum> will speed up stage1 but slow down stage2
[17:31:07] <strcat> dbaupp: anyway it involves some complications so I don't want to worry about that yet
[17:31:18] <strcat> it's an easy change to make later, none of the adaptors are different
[17:31:24] <strcat> essentially Iterator == ForwardRange
[17:31:47] *** Quits: true_droid (Adium@moz-123FD9B8.beck.volia.net) (Ping timeout)
[17:31:50] <strcat> slices are RandomAccessRange, ForwardRange and BidirectionalRange
[17:32:03] <strcat> because you can pop_front() and pop_back()
[17:32:05] *** Joins: true_droid (Adium@moz-123FD9B8.beck.volia.net)
[17:32:36] <strcat> let range = [1, 2, 3, 4, 5].slice(); range.pop_front()
[17:32:40] <strcat> would be &[2, 3, 4, 5]
[17:33:09] <strcat> but first lets finish the basics.
[17:33:10] <dbaupp> would that loose us speed?
[17:33:13] <strcat> dbaupp: no
[17:33:21] <strcat> dbaupp: Iterator == ForwardRange, it's implemented the same way
[17:33:28] <strcat> but it means we can also have more advanced ranges
[17:33:50] <strcat> slices are ptr + len and our vector iterator is ptr + ptr (could be ptr + len)
[17:35:06] *** Quits: askalski (akuda@moz-1BD89C3F.neoplus.adsl.tpnet.pl) (Quit: Wychodzi)
[17:35:13] <strcat> so we could have...
[17:35:43] <strcat> let mut range = [1, 2, 3, 4, 5, 6].slice(); range.take_while(|x| *x < 4)
[17:35:45] <strcat> and then range would be
[17:35:55] *** Quits: thomaslee (thomaslee@moz-306D3DF4.hsd1.or.comcast.net) (Client exited)
[17:35:59] <strcat> &[4, 5, 6]
[17:36:10] <strcat> (after you advanced the take_while range)
[17:36:10] <dbaupp> range itself?
[17:36:22] *** Quits: solancile (solancile@moz-A1CFFAE5.hsd1.wa.comcast.net) (Ping timeout)
[17:36:28] <strcat> dbaupp: we'd need to make it possible to disassemble a range adaptor back into what you used to make it
[17:36:31] <dbaupp> oh right
[17:36:57] <strcat> anyway Iterator is fine for now, this is just future stuff ;p
[17:37:00] <strcat> simple things first
[17:37:09] <dbaupp> that'd require storing a "lot" of data
[17:37:18] <dbaupp> (i.e. an extra word for a veciterator)
[17:37:27] <strcat> dbaupp: I don't think so, slices are 2 words
[17:37:38] *** Joins: Palmik (palmik@moz-5CA3F354.pks.muni.cz)
[17:37:54] <dbaupp> hmm, ok
[17:38:08] <strcat> reverse iterators on vectors would have to stay as they are
[17:38:15] <strcat> I think.
[17:38:24] <strcat> err no, they wouldn't
[17:39:36] <strcat> dbaupp: anyway this would need default methods working.
[17:39:49] <dbaupp> do we know the problem?
[17:39:58] <strcat> I think they are just not finished at all
[17:40:02] <strcat> not a specific problem
[17:40:03] <dbaupp> :/
[17:40:04] <strcat> a whole bunch!
[17:40:24] <dbaupp> maybe we should just excise everything other than external iterators from vec
[17:40:33] <dbaupp> so people get annoyed at the horrible syntax
[17:40:40] <dbaupp> and fix default methods
[17:40:40] <strcat> well it won't stay horrible ;p
[17:40:53] <dbaupp> and implement a new for protocol
[17:41:04] <dbaupp> and then Rust'll be amazing-er!
[17:41:09] <strcat> dbaupp: xs.iter().fold(0, |a, b| a + b) isn't that bad
[17:41:24] <dbaupp> strcat: not at all, but for xs.iter().advance |c| ...
[17:41:27] <strcat> dbaupp: xs.fold(0, |a, b| a + b) with default methods would be really nice though
[17:41:34] <strcat> dbaupp: yeah but I think that part is easy to fix
[17:41:36] <dbaupp> is much worse than `for xs.each`
[17:41:44] <strcat> for xs.iter() |c| { }
[17:41:49] <strcat> for xs.rev_iter() |c| { }
[17:41:54] <strcat> for xs.iter().take(30) |c| { }
[17:41:59] <dbaupp> strcat: of course, but this'd be a way to force the issue ;P
[17:42:17] <strcat> dbaupp: I think pcwalton will probably do it
[17:42:36] <strcat> it's a compile-speed issue
[17:43:13] <strcat> if 'for' worked with the external iterator trait and we replaced every 'for foo.each |x| {}' with 'for foo.iter |x| {}' we'd be generating a lot less code
[17:43:27] *** Joins: blitter (blitter@moz-BA14D5CF.dyn.centurytel.net)
[17:43:35] <strcat> not that it's a primary motivation, but it's a side benefit
[17:43:44] <dbaupp> yeah
[17:43:52] <dbaupp> and it'd allow us to reduce allocations
[17:44:14] <dbaupp> since I'm pretty sure there are many points in the compiler where a .map could be a lazier .transform
[17:44:34] <strcat> which we can hopefully rename to map soon.
[17:44:40] <strcat> :_
[17:44:42] <strcat> :)
[17:44:56] <dbaupp> what's the bug stopping IteratorUtil being the prelude, btw?
[17:45:12] <strcat> dbaupp: method resolve bugs
[17:45:12] <dbaupp> is it just other traits/impls with the same method names?
[17:45:20] <strcat> dbaupp: yeah they aren't supposed to conflict though
[17:45:34] <dbaupp> i.e. can we just go and change them?
[17:45:50] <strcat> dbaupp: we could but then we'd be essentially reserving a bunch of method names until that bug is fixed
[17:46:04] <strcat> it won't let you have 'take' on *any* type if IteratorUtil is in scope atm
[17:46:20] <dbaupp> well, all the other *Util traits in the prelude are doing that too
[17:46:22] <Yurume> dbaupp, I basically gave up with the cfg-configurable ABI, even macro_rules! does not work.
[17:46:27] <strcat> dbaupp: https://github.com/mozilla/rust/issues/5898?source=cc
[17:46:31] <dbaupp> Yurume: :(
[17:47:01] <Yurume> so for now I sticked to sed hack
[17:47:05] <Yurume> and here is the result: https://github.com/lifthrasiir/rust-opengles-angle
[17:47:30] <dbaupp> which file has the hack?
[17:47:54] <Yurume> *.rs.in.
[17:48:20] <Yurume> Makefile contains lines like: sed 's/"ABI"/"$(ABI)"/' foo.rs.in > foo.rs
[17:48:34] <dbaupp> oh, ew
[17:49:00] <Yurume> *phew*
[17:49:34] <Yurume> personally I dislike stdcall at my heart, practically it has to be worked around...
[17:49:43] <strcat> dbaupp: the language has already changed to accommodate external iterators more
[17:49:49] <dbaupp> did you try `#[cfg(foo)] mod wrapper { extern "ABI1" { ... } } #[cfg(not(foo))] mod wrapper { extern "ABI2" { .. } }`? (Although I guess repeating everything twice is far worse)
[17:50:02] <dbaupp> strcat: other than my recent changes?
[17:50:05] <strcat> dbaupp: borrowing rvalues as &mut, and I don't think that's used anywhere else
[17:50:14] <EXetoC> will iterator zipping be possible, or do we need variadics or do/for improvements for that?
[17:50:16] <dbaupp> oh, yeah, that's really nice
[17:50:17] <Yurume> dbaupp, it would work but I don't want to repeat them
[17:50:24] <dbaupp> EXetoC: it is possible now
[17:50:34] <dbaupp> (zipping 2 at a time)
[17:51:12] <strcat> rusti: use std::iterator::*; let xs = [1, 2, 3]; let ys = ["foo", "bar", "baz"]; for xs.iter().zip(ys.iter()).advance |(x, y)| { println(fmt!("%? %?", x, y)) }
[17:51:14] -rusti- &1 &"foo"
[17:51:15] -rusti- &2 &"bar"
[17:51:15] -rusti- &3 &"baz"
[17:51:15] -rusti- ()
[17:51:32] <strcat> rusti: use std::iterator::*; let xs = [1, 2, 3]; let ys = ["foo", "bar", "baz"]; for xs.iter().take(2).zip(ys.iter()).advance |(x, y)| { println(fmt!("%? %?", x, y)) }
[17:51:33] -rusti- &1 &"foo"
[17:51:33] -rusti- &2 &"bar"
[17:51:33] -rusti- ()
[17:51:46] <dbaupp> :D it's just so nice
[17:51:49] <EXetoC> that might be good enough actually
[17:51:54] <strcat> so in the future 'iter()' and 'advance' can go away
[17:52:00] <strcat> but that's a long road ;p
[17:52:17] <strcat> for xs.take(2).zip(ys) |(x, y)| {}
[17:52:54] <dbaupp> EXetoC: yeah, you can repeatedly zip to zip several together (giving nested 2-tuples)
[17:53:07] <strcat> we could hardcode zip3, zip4, etc.
[17:53:43] <dbaupp> zipping to (,,) and (,,,) ? or (,(,)) and ((,),(,)), if that makes sense?
[17:53:51] *** Quits: jfbk (user@moz-EEA9CFB3.nyc.res.rr.com) (Quit: ERC Version 5.3 (IRC client for Emacs))
[17:54:00] <EXetoC> ok. maybe D needs variadics because of its lousy tuple support
[17:54:24] <EXetoC> for zipping that is
[17:56:48] *** Joins: maik_ (maik@moz-B464C230.dip0.t-ipconnect.de)
[17:57:50] *** Quits: MaikKlein (maik@moz-76A64E0E.dip0.t-ipconnect.de) (Ping timeout)
[18:05:13] *** Joins: steven_is_false (user@moz-144077DE.bchsia.telus.net)
[18:05:47] *** Quits: BizarreCake (BizarreCak@32C9829A.151E84E7.561471F8.IP) (Ping timeout)
[18:07:21] <steven_is_false> Hi! There don't seem to be any bindings to XML libraries for Rust yet so I will create one. I respect your opinions, and want to know Which XML parsing library you most want to see have a Rust binding?
[18:07:38] <strcat> steven_is_false: they are honestly all pretty terrible :(
[18:07:47] <steven_is_false> strcat: True
[18:08:09] <strcat> expat doesn't actually handle xml according to the standard and uses int instead of size_t so it's really annoying with mapped memory (38GiB wikipedia dumps! ;p)
[18:08:31] <strcat> libxml2 is pretty sane. but also has terrible docs and crufty apis
[18:09:17] <strcat> steven_is_false: so I guess libxml2.... there is both a streaming API and a tree building API
[18:09:38] <strcat> and it's MIT licensed now
[18:09:52] <steven_is_false> strcat: I've had bad experiences with libxml2 before but if there's no other options...
[18:10:02] <strcat> steven_is_false: yeah I think it's the least bad :(
[18:10:51] <steven_is_false> strcat: What does Mozilla use to parse all it's XML (XUL etc..) stuff?
[18:11:00] <strcat> dunno
[18:11:07] <steven_is_false> okay
[18:11:21] <strcat> I wouldn't be surprised if xul had an xml parser itself, but I don't know
[18:11:44] <strcat> steven_is_false: https://developer.mozilla.org/en/docs/XML_in_Mozilla that says they use expat
[18:11:47] <strcat> which I find hard to believe
[18:11:48] <strcat> ;p
[18:12:36] <maik_> I wrote a short tutorial about "how to hack rustc" http://maikklein.github.io/2013/06/08/how-to-hack-rustc/
[18:12:58] <steven_is_false> strcat: THEN TO THE HACKMOBILE!
[18:13:09] * steven_is_false sit's down goes nowhere
[18:13:32] <sp3d> haha
[18:13:45] <strcat> steven_is_false: it would probably make sense for someone to write a new suckless xml lib in rust for servo eventually
[18:13:55] <strcat> streaming API + tree building like libxml2
[18:14:04] <dbaupp> steven_is_false: there's basic bindings to expat somewhere on github
[18:14:14] <dbaupp> (FWIW)
[18:15:02] * strcat hates xml
[18:15:09] *** Joins: MaikKlein (maik@moz-B464C230.dip0.t-ipconnect.de)
[18:15:11] <strcat> too many choices on how to encode anything
[18:15:35] <steven_is_false> It's just S-Expressions (as long as you ignore attributes)
[18:15:38] <strcat> and most xml APIs just overuse tags for *everything* and use attributes inconsistently so it's a huge mess
[18:15:50] <strcat> steven_is_false: yeah but... so many weird other ways of doing things
[18:15:58] <strcat> weird namespaces too
[18:16:00] *** Joins: dherman (dherman@moz-6CA476B1.hsd1.ca.comcast.net)
[18:16:00] *** ChanServ sets mode: +o dherman
[18:18:12] *** Quits: unbracketed (textual@moz-7F0EE151.lsanca.fios.verizon.net) (Quit: Computer has gone to sleep.)
[18:18:24] <steven_is_false> Thanks strcat, I have to leave now
[18:18:29] *** Joins: ghrust (ghrust@DE823A67.6A2AE50.F3114085.IP)
[18:18:29] <ghrust> 01[13rust01] 15bors merged 06auto into 06incoming: 02http://git.io/7T52Zg
[18:18:29] *** Parts: ghrust (ghrust@DE823A67.6A2AE50.F3114085.IP) ()
[18:18:37] *** Parts: steven_is_false (user@moz-144077DE.bchsia.telus.net) (ERC Version 5.3 (IRC client for Emacs))
[18:19:18] <dbaupp> cue people asking about why their vector/string handling code is broken
[18:19:50] <MaikKlein> do you think it would be useful if I would add stuff like this to the official wiki? http://maikklein.github.io/2013/06/08/how-to-hack-rustc/
[18:21:10] *** Quits: jensnockert (jensnocker@moz-8BE55278.customer.t3.se) (Input/output error)
[18:22:32] <strcat> MaikKlein: your blog is probably easier to find
[18:22:39] <strcat> github wikis are pretty awful
[18:23:05] <strcat> they don't even have search.
[18:23:42] <MaikKlein> then maybe we should create a real wiki? :)
[18:24:09] <MaikKlein> like http://www.haskell.org/haskellwiki/Introduction
[18:25:21] <strcat> yeah a real wiki would be nice. perhaps even a wiki written in rust ;)
[18:25:27] <strcat> libgit2 makes that easy
[18:25:34] <sp3d> sounds a little NIH ;)
[18:26:10] <Yurume> remember that HaskellWiki is just a MediaWiki. ;)
[18:26:14] <strcat> sp3d: NIH is the best way to improve a language + ecosystem
[18:26:26] <strcat> Yurume: yeah, gitit is much nicer than MediaWiki though.
[18:26:27] *** Quits: dbaupp (Thunderbir@DD5A5B3.5DFF0E76.CCE6F5F4.IP) (Ping timeout)
[18:26:32] <strcat> http://gitit.net/
[18:26:39] <sp3d> I guess, but users are more curious about if the docs are here this week/next vs. what the wiki is written with
[18:26:52] <strcat> sp3d: well the wiki is here now
[18:26:54] *** Joins: jensnockert (jensnocker@moz-8BE55278.customer.t3.se)
[18:27:48] <sp3d> mm, point
[18:28:07] <strcat> I'm not sure if I hate github wikis or mediawiki more
[18:28:10] <strcat> it's a tough call
[18:28:26] <strcat> at least github wikis let you use a fairly sane variant of markdown, rst, etc.
[18:28:38] <strcat> they just really lack features.
[18:29:03] <jensnockert> Yeah, they are pretty annoying.
[18:29:10] <jensnockert> Should be TeX instead.
[18:29:32] *** Joins: caitp (caitp@moz-9FE842F.cpe.net.cable.rogers.com)
[18:29:44] <strcat> jensnockert: pandoc markdown lets you embed latex ;p
[18:30:16] <jensnockert> Yeah, but I cannot use that on Github :(
[18:30:17] <Amanieu> Because a markup language isn't usable unless it is Turing-complete :P
[18:30:25] <caitp> would there be any value in changing core::io's read_line routines so that they can deal with old mac linefeeds and windows crlf linefeeds?
[18:30:55] <strcat> jensnockert: well you can embed latex in rst for math but I doubt they are using docutils + mathjax
[18:31:01] <strcat> or an alternative
[18:31:26] <jensnockert> Probably mathjax.
[18:32:23] *** Joins: carter (carter@moz-8B414CBF.apng.seas.upenn.edu)
[18:32:37] <strcat> anyway pandoc markdown is the only document format that should exist :)
[18:32:39] <jensnockert> bjz_: Btw. I wrote some minor tests for the interpolation code.
[18:33:06] <strcat> it steals the parts of rst I like
[18:33:08] <strcat> tables!
[18:33:10] <jensnockert> strcat: Or just LuaTeX and HTML?
[18:33:35] *** Quits: doomlord (doomlod@moz-8F385DB0.range109-153.btcentralplus.com) (Connection reset by peer)
[18:33:47] <strcat> jensnockert: pandoc markdown is very readable as plain-text though :)
[18:33:58] *** Joins: koomi (koomi@moz-E8AECC1E.pools.arcor-ip.net)
[18:34:45] *** Joins: doomlord (doomlod@moz-8F385DB0.range109-153.btcentralplus.com)
[18:34:50] <strcat> jensnockert: http://docs.python.org/3/_sources/library/array.txt rst is nice too
[18:35:00] <strcat> that becomes http://docs.python.org/3/library/array.html but it's remarkably readable as text
[18:36:50] <doomlord> heh. "NIH" ... rust is a great excuse to indulge  NIH
[18:39:01] <MaikKlein> what is NIH?
[18:39:19] <doomlord> NotInventedHere. tendancy to re-write things
[18:40:39] *** Quits: carter (carter@moz-8B414CBF.apng.seas.upenn.edu) (Quit: Textual IRC Client: www.textualapp.com)
[18:40:45] <jensnockert> If you write RustTeX then you're king.
[18:40:49] <doomlord> so now we have an excuse to re-write things in a language with cleaner syntax, more multicore friendly, with better OOP system...  
[18:40:53] <jensnockert> *RusTeX.
[18:41:15] <doomlord> NIH exists because code i usually easier to write than it is to read
[18:42:00] *** Quits: moonchrome (moonchrome@moz-A3A6B427.dsl.iskon.hr) (Input/output error)
[18:42:19] <strcat> pretty much all software sucks so it's not hard to write replacements that suck less
[18:42:35] <strcat> the problem is someone probably isn't going to maintain the replacement so it will end up sucking too
[18:43:24] <doomlord> realistically its usually that... you just have to deal with the problems , build on what exists...
[18:44:15] <doomlord> but at least with rust there is the potential benefit of having new source that will be easier to maintain for so many reasons
[18:46:12] <strcat> ha there's so many of these duplicate iterator functions in vec/str
[18:46:21] <strcat> going to take ages to convert to the generic ones
[18:46:49] <doomlord> how is that structured, is a str to be a vector of chars?
[18:46:58] <doomlord> common traits?
[18:47:03] <strcat> I mean they duplicate iterators
[18:47:39] <strcat> eachi, all, any, foldl, position, each_mut, each
[18:47:47] <strcat> filter_to_vec, min, max
[18:47:53] <strcat> each_val
[18:48:15] <strcat> dbaupp killed off most of the "2" suffixed ones that can be replaced with zip
[18:48:17] *** Joins: ghrust (ghrust@C621748.6A2AE50.F3114085.IP)
[18:48:17] <ghrust> 01[13rust01] 15bors pushed 0 new commits to 06auto: 02http://git.io/frIqvQ
[18:48:17] *** Parts: ghrust (ghrust@C621748.6A2AE50.F3114085.IP) ()
[18:48:18] *** Joins: ghrust (ghrust@1E8607E8.6A2AE50.F3114085.IP)
[18:48:18] <ghrust> 01[13rust01] 15bors pushed 2 new commits to 06auto: 02http://git.io/R5y8fQ
[18:48:18] <ghrust> 13rust/06auto 148b87deb 15Ramkumar Ramachandra: configure: replace echo "" with plain echo...
[18:48:18] <ghrust> 13rust/06auto 1459bbbe4 15bors: auto merge of #6970 : artagnon/rust/configure, r=catamorphism...
[18:48:18] *** Parts: ghrust (ghrust@1E8607E8.6A2AE50.F3114085.IP) ()
[18:49:00] <doomlord> heh and here's me wanting pure versions :)
[18:49:04] <maik_> .
[18:49:07] <MaikKlein> .
[18:49:13] <doomlord> (versions which only accept pure functions)
[18:49:16] <MaikKlein> hm
[18:49:22] *** Parts: maik_ (maik@moz-B464C230.dip0.t-ipconnect.de) (Leaving)
[18:49:52] <strcat> heh
[18:49:52] <strcat> vec has
[18:49:58] <strcat> filter, filter_to_vec *and* filtered
[18:50:01] <strcat> all 3 are redundant :)
[18:50:25] * strcat will start by eliminating those
[18:50:52] *** Joins: Jeaye (Jeaye@moz-FD505E54.hsd1.ca.comcast.net)
[18:51:20] *** Joins: Nisstyre (wes@moz-FD86289.netflash.net)
[18:55:27] *** Joins: RMF (RMF@E80DA7BB.A3D80C3C.8D19547B.IP)
[18:56:41] *** Quits: victorporof (victorporo@FE2F04DC.63E19875.D111398B.IP) (Quit: victorporof)
[18:58:14] *** Quits: engla (engla@moz-DBD1D96E.cust.bredbandsbolaget.se) (Ping timeout)
[18:58:30] *** Quits: dherman (dherman@moz-6CA476B1.hsd1.ca.comcast.net) (Quit: dherman)
[18:58:57] *** Quits: RMF (RMF@E80DA7BB.A3D80C3C.8D19547B.IP) (Quit: Textual IRC Client: www.textualapp.com)
[19:01:47] *** Joins: askalski (akuda@moz-1BD89C3F.neoplus.adsl.tpnet.pl)
[19:09:08] *** Quits: koomi (koomi@moz-E8AECC1E.pools.arcor-ip.net) (Quit: WeeChat 0.4.1)
[19:10:50] <ssbr> Curious: I know that Option<~X> is optimized now, but what about ~Option<X>? (Or do I have that backwards?) Ideally I figure both would be represented internally as possibly-null pointers to X.
[19:11:27] <strcat> ssbr: the 2nd can't be optimized
[19:11:36] <strcat> let x = ~Some(5);
[19:11:41] <strcat> let y = &*x;
[19:11:56] <strcat> semantically different
[19:12:45] *** Quits: strcat (strcat@moz-54F7FD49.cpe.net.cable.rogers.com) (Quit: kernel update)
[19:12:52] <ssbr> Well. I assume you could add in more code to make it work. But point taken.
[19:13:02] *** Quits: rusti (rusti@moz-54F7FD49.cpe.net.cable.rogers.com) (Client exited)
[19:14:15] *** Joins: dylukes (dylukes@moz-AB04B0EB.public.wayport.net)
[19:14:38] *** Joins: rusti (rusti@moz-54F7FD49.cpe.net.cable.rogers.com)
[19:15:44] *** Joins: strcat (strcat@moz-54F7FD49.cpe.net.cable.rogers.com)
[19:17:53] *** Joins: smccarthy (smccarthy@moz-AA336B8D.ph.ph.cox.net)
[19:23:11] *** Joins: Cromulent (Cromulent@moz-983B638D.cable.virginmedia.com)
[19:23:38] *** Quits: askalski (akuda@moz-1BD89C3F.neoplus.adsl.tpnet.pl) (Quit: Wychodzi)
[19:27:17] *** Joins: victorporof (victorporo@FE2F04DC.63E19875.D111398B.IP)
[19:28:49] *** Quits: Cromulent (Cromulent@moz-983B638D.cable.virginmedia.com) (Quit: KVIrc 4.2.0 Equilibrium http://www.kvirc.net/)
[19:31:16] *** Joins: tikue (tkuehn@moz-CF8BEBEF.dia.static.qwest.net)
[19:33:16] *** Joins: carllerche (carllerche@6B070D22.7E6A0813.1428D117.IP)
[19:33:21] *** Quits: MaikKlein (maik@moz-B464C230.dip0.t-ipconnect.de) (Ping timeout)
[19:33:49] *** Quits: victorporof (victorporo@FE2F04DC.63E19875.D111398B.IP) (Ping timeout)
[19:34:53] *** Joins: RMF (RMF@E80DA7BB.A3D80C3C.8D19547B.IP)
[19:35:10] *** Joins: brson (brson@2557E599.66715431.D25A875A.IP)
[19:35:10] *** ChanServ sets mode: +o brson
[19:35:14] *** Quits: Amanieu (amanieu@moz-D5D10CA8.halls.manchester.ac.uk) (Connection reset by peer)
[19:35:19] *** Quits: RMF (RMF@E80DA7BB.A3D80C3C.8D19547B.IP) (Quit: Textual IRC Client: www.textualapp.com)
[19:35:31] *** Joins: koomi (koomi@moz-B2B8B6D1.superkabel.de)
[19:36:27] *** Joins: askalski (akuda@moz-1BD89C3F.neoplus.adsl.tpnet.pl)
[19:38:20] <jensnockert> bjz_: Pushed some tests.
[19:39:17] *** Joins: ghrust (ghrust@614D05BD.6A2AE50.F3114085.IP)
[19:39:17] <ghrust> 01[13rust01] 15bors merged 06auto into 06incoming: 02http://git.io/R5y8fQ
[19:39:17] *** Parts: ghrust (ghrust@614D05BD.6A2AE50.F3114085.IP) ()
[19:39:23] *** Joins: Amanieu (amanieu@moz-D5D10CA8.halls.manchester.ac.uk)
[19:40:11] <strcat> brson: I left a comment on the jemalloc cross-compile issue about what still needs to be fixed
[19:41:19] *** Quits: Axord (xord@moz-C3CCF156.lsanca.dsl-w.verizon.net) (Quit: I'm sure it's perfectly safe)
[19:42:18] *** Joins: ghrust (ghrust@5FEF1C87.6A2AE50.F3114085.IP)
[19:42:18] <ghrust> 01[13rust01] 15bors pushed 0 new commits to 06auto: 02http://git.io/IWt0Pg
[19:42:18] *** Parts: ghrust (ghrust@5FEF1C87.6A2AE50.F3114085.IP) ()
[19:42:20] *** Joins: ghrust (ghrust@FD7BC443.6A2AE50.F3114085.IP)
[19:42:20] <ghrust> 01[13rust01] 15bors pushed 5 new commits to 06auto: 02http://git.io/SciACA
[19:42:20] <ghrust> 13rust/06auto 14c786b68 15Philipp BrÃ¼schweiler: Add a test that causes an ICE currently
[19:42:20] <ghrust> 13rust/06auto 14f3f9db1 15Philipp BrÃ¼schweiler: rustc: Fix an ICE "Autoderef but type not derefable"...
[19:42:20] <ghrust> 13rust/06auto 14c74f397 15Philipp BrÃ¼schweiler: Add test for #5062
[19:42:22] *** Parts: ghrust (ghrust@FD7BC443.6A2AE50.F3114085.IP) ()
[19:44:01] <alexrp> is it actually possible to create instances of empty structs?
[19:44:14] <strcat> alexrp: yes
[19:44:27] <alexrp> how do?
[19:44:27] <strcat> rusti: struct Foo; let x = Foo; x
[19:44:34] -rusti- timeout triggered!
[19:44:35] <strcat> rusti: struct Foo; let x = Foo; x
[19:44:40] -rusti- {}
[19:44:42] <alexrp> ah, I should update my rust
[19:44:49] <alexrp> hm
[19:44:55] <strcat> alexrp: they just act like empty enum variants
[19:44:59] <alexrp> rusti: struct Foo; let x = Foo; match x { };
[19:45:02] -rusti- more than 5 lines of output, pastebinned: http://sprunge.us/CEfK
[19:45:15] <alexrp> weeell
[19:45:18] <alexrp> I did not expect that
[19:45:33] <strcat> rusti: struct Foo; let x = Foo; match x { _ => () };
[19:45:38] -rusti- ()
[19:45:44] *** Quits: pseudoku (quassel@E11BF0D0.96D08489.C28326FD.IP) (Connection reset by peer)
[19:46:04] <strcat> rusti: 1
[19:46:05] <alexrp> the thing I was actually trying to find out is if 'match' always requires at least one arm
[19:46:06] -rusti- 1
[19:46:08] <strcat> rusti: 1
[19:46:09] -rusti- 1
[19:46:12] <strcat> rusti: 1
[19:46:13] -rusti- 1
[19:46:49] *** Quits: smccarthy (smccarthy@moz-AA336B8D.ph.ph.cox.net) (Client exited)
[19:48:59] <alexrp> are there actually any cases where it's semantically valid to have no arms in a match?
[19:49:45] <strcat> rusti: enum YouCannotMakeOneOfMe {};
[19:49:47] -rusti- ()
[19:50:06] <strcat> alexrp: seems like it's broken with structs because you definitely can make them
[19:50:11] <strcat> alexrp: should report it
[19:51:29] <strcat> anyway enums with no variants are the best way of representing opaque types
[19:51:52] <strcat> since you can only ever have a pointer to them
[19:52:08] *** Quits: bytbox (s@moz-D83E9B31.wireless.umd.edu) (Ping timeout)
[19:52:15] <strcat> well, any sort of nullable reference
[19:52:21] <alexrp> strcat: sure - what I'm actually after is something rather unrelated :)
[19:52:30] <alexrp> (the match thing)
[19:52:45] <alexrp> was wondering if maybe an empty struct would allow a match with no arms
[19:54:08] *** Joins: FrozenCow (FrozenCow@moz-B2DF4929.chello.nl)
[19:54:47] *** Quits: EXetoC (ex@moz-2DBEB1E4.customer.t3.se) (Quit: WeeChat 0.4.1)
[19:54:56] *** Joins: EXetoC (ex@moz-2DBEB1E4.customer.t3.se)
[20:00:32] <caitp> what is a good replacement for function pointers in rust?
[20:00:52] *** Quits: busylizzy (lisa@85228838.12D0DC84.211374C4.IP) (Ping timeout)
[20:01:21] <Amanieu> closures
[20:01:31] <caitp> closures aren't good enough
[20:01:40] <strcat> caitp: functions
[20:01:41] <Amanieu> what are you trying to do?
[20:01:41] <strcat> &fn, ~fn, @fn
[20:01:52] <caitp> doesn't seem to work, strcat
[20:01:54] <strcat> or if you really want no environment, extern fn
[20:01:55] <strcat> caitp: work for what
[20:03:10] <caitp> what I'd like to do is have a mutable function pointer &fn or @fn, doesn't really matter, in a structure where it can be set to a different routine
[20:03:41] <strcat> caitp: that will work
[20:03:47] <caitp> doesn't work
[20:03:57] <strcat> it does, you're not showing the specific code you've written that doesn't
[20:04:52] <caitp> if it's a borrowed pointer, it will complain about an illegal anonymous lifetime
[20:05:03] <strcat> because it needs to be given a lifetime
[20:05:09] <strcat> named lifetime
[20:05:19] <caitp> if it's a managed pointer, I can't actually dereference it for whatever reason
[20:05:21] <strcat> borrowed pointers in structs need named lifetimes
[20:05:38] <strcat> caitp: because it's not a pointer, it's an @fn
[20:05:45] *** Quits: erickt (Adium@49C4075F.3AC15C18.2321E71E.IP) (Quit: Leaving.)
[20:05:48] <strcat> it's a single unit
[20:07:00] <strcat> rusti: struct Foo<'self> { f: &'self fn(int) }; let x = Foo{f: |x| println(x.to_str())}; x.f(2)
[20:07:02] -rusti- more than 5 lines of output, pastebinned: http://sprunge.us/ZFFb
[20:07:13] <strcat> rusti: struct Foo<'self> { f: &'self fn(int) }; let x = Foo{f: |x| println(x.to_str())}; (x.f)(2)
[20:07:15] -rusti- 2
[20:07:15] -rusti- ()
[20:07:41] <caitp> so, so terrible
[20:08:02] <strcat> what do you mean?
[20:08:17] <strcat> rusti: struct Foo { f: @fn(int) }; let x = Foo{f: |x| println(x.to_str())}; (x.f)(2)
[20:08:19] -rusti- 2
[20:08:19] -rusti- ()
[20:08:43] *** Quits: sankha93 (Instantbir@BFECE1D6.6ABDE3A6.8B6C1D65.IP) (Quit: Instantbird 1.4 -- http://www.instantbird.com)
[20:09:24] <strcat> rusti: struct Foo { f: @fn(int) }; let mut x = Foo{f: |x| println(x.to_str())}; x.f = |x| println((x + 1).to_str()); (x.f)(2)
[20:09:25] -rusti- 3
[20:09:25] -rusti- ()
[20:12:46] *** Joins: akuda_ (akuda@moz-ECDED8BD.neoplus.adsl.tpnet.pl)
[20:12:50] *** Quits: Yurume (yurume@AC58A8CE.8A059B47.E313B915.IP) (Ping timeout)
[20:13:08] *** Quits: askalski (akuda@moz-1BD89C3F.neoplus.adsl.tpnet.pl) (Ping timeout)
[20:14:35] *** Quits: Sorella (queen@B12A78F5.BA14766C.95C8B7C6.IP) (Quit: (quit))
[20:17:56] *** Joins: Sorella (queen@B12A78F5.BA14766C.95C8B7C6.IP)
[20:19:57] *** Joins: steven_is_false (user@moz-144077DE.bchsia.telus.net)
[20:21:35] *** Joins: Cromulent (Cromulent@moz-983B638D.cable.virginmedia.com)
[20:23:15] *** Joins: bytbox (s@moz-D83E9B31.wireless.umd.edu)
[20:23:38] *** Quits: carllerche (carllerche@6B070D22.7E6A0813.1428D117.IP) (Quit: carllerche)
[20:23:51] <steven_is_false> Hi, I'm just curious, I know we have a bunch of C++ glue code, and I'm wondering if anyone has bothered to use clang's static-analyzer (integrated into XCode, and usable manually with the scan-build program) on it?
[20:24:34] <strcat> it's not really a bunch, most is third-party libs
[20:24:42] *** Joins: vosen (vosen@moz-266BA656.icpnet.pl)
[20:24:49] *** zz_kimundi is now known as kimundi
[20:25:00] <strcat> and being replaced with rust by brson :)
[20:25:41] *** Joins: jrfeenst (jrfeenst@moz-F912484F.cpe.norwoodlight.com)
[20:25:50] <jmgrosen> anyone know how to get c pointer of a dynamic vector, pass it into a c function that will then call a callback with that pointer?
[20:25:56] <jmgrosen> so that i can use the vector in the callback
[20:26:02] <steven_is_false> strcat: Fair enough.
[20:26:10] <jmgrosen> the c code doesn't actually care what the pointer is
[20:26:22] <strcat> jmgrosen: the pointer to the start of the elements?
[20:26:37] <strcat> or you mean you want to get a ptr to the vector and pass it back into rust
[20:26:43] <jmgrosen> the second thing
[20:26:55] <jmgrosen> so i can still append to it and such from my rust callback
[20:27:00] <strcat> ~[T]?
[20:27:35] <jmgrosen> yeah, something like that
[20:27:41] *** Quits: dylukes (dylukes@moz-AB04B0EB.public.wayport.net) (Quit: Computer has gone to sleep.)
[20:27:42] <jmgrosen> but i don't know how to get it through c
[20:27:46] <strcat> well you could just take the ptr to the variable
[20:27:54] <strcat> if it's owned, the variable can't go away anyway
[20:27:57] <strcat> during the call
[20:28:15] <jmgrosen> how does one take the ptr of it?
[20:28:25] <steven_is_false> strcat: Doesn't Rust use fat pointers so he can't just use a void * for the pointer?
[20:28:28] <Jeaye> true is to false as #[cfg(foo)] is to ____?
[20:28:34] <strcat> rusti: let x = 5; let y: *int = &x; y
[20:28:36] -rusti- 140115255290336
[20:28:42] <jmgrosen> huh
[20:28:48] <strcat> Jeaye: #[cfg(not(foo), bar, not(baz)]
[20:28:49] *** Joins: devbug (quassel@moz-E1DE087C.bchsia.telus.net)
[20:29:07] <Jeaye> strcat: Those three are logically &&?
[20:29:11] <strcat> Jeaye: yes
[20:29:15] <Jeaye> Cool, thanks.
[20:29:18] <strcat> !foo && bar && !baz
[20:32:37] *** Joins: victorporof (victorporo@FE2F04DC.63E19875.D111398B.IP)
[20:33:48] <Amanieu> I've written up proposal to unify functions and traits
[20:33:59] <Amanieu> should I just append it to the closure reform proposal page?
[20:34:09] <Amanieu> on the wiki
[20:34:27] *** Quits: victorporof (victorporo@FE2F04DC.63E19875.D111398B.IP) (Ping timeout)
[20:35:43] *** Joins: infynyxx (infynyxx@moz-E95B370B.nyc.res.rr.com)
[20:36:15] *** Joins: ghrust (ghrust@79968228.6A2AE50.F3114085.IP)
[20:36:15] <ghrust> 01[13rust01] 15bors merged 06auto into 06incoming: 02http://git.io/SciACA
[20:36:15] *** Parts: ghrust (ghrust@79968228.6A2AE50.F3114085.IP) ()
[20:36:24] *** Joins: doomlord__ (servitor@moz-8F385DB0.range109-153.btcentralplus.com)
[20:36:46] <jmgrosen> "error: use of partially moved value"?
[20:36:50] <jmgrosen> what does that mean?
[20:37:02] <strcat> jmgrosen: means you moved a field out of the value so now the value as a whole can't be used
[20:37:23] <strcat> it will show you where you moved out a field and where you're trying to use it after the move
[20:37:41] <jmgrosen> huh
[20:37:41] <strcat> fixable by either taking a reference instead of moving or by copying
[20:38:01] <jmgrosen> i'm doing
[20:38:07] <strcat> http://static.rust-lang.org/doc/tutorial.html#move-semantics
[20:38:10] <jmgrosen> debug!(foo);
[20:38:25] <jmgrosen> well, nvm
[20:39:13] *** Joins: ghrust (ghrust@DE823A67.6A2AE50.F3114085.IP)
[20:39:13] <ghrust> 01[13rust01] 15bors pushed 0 new commits to 06auto: 02http://git.io/QMEUuA
[20:39:13] *** Parts: ghrust (ghrust@DE823A67.6A2AE50.F3114085.IP) ()
[20:39:14] *** Joins: ghrust (ghrust@9C8B94D4.6A2AE50.F3114085.IP)
[20:39:15] <ghrust> 01[13rust01] 15bors pushed 8 new commits to 06auto: 02http://git.io/1u8VPw
[20:39:15] <ghrust> 13rust/06auto 14b870477 15BjÃ¶rn Steinbrink: Avoid unnecessary (re-)allocations in the lexer
[20:39:15] <ghrust> 13rust/06auto 1451e85f5 15BjÃ¶rn Steinbrink: Avoid unnecessary heap allocations in the metadata ty decoder
[20:39:15] <ghrust> 13rust/06auto 1496798f5 15BjÃ¶rn Steinbrink: tydecode: Accept a plain borrowed pointer to the data
[20:39:16] *** kimundi is now known as zz_kimundi
[20:39:17] *** Parts: ghrust (ghrust@9C8B94D4.6A2AE50.F3114085.IP) ()
[20:39:24] <jmgrosen> let foo: *~[u8] = &~[];
[20:39:33] <jmgrosen> debug!(*foo);
[20:39:43] <jmgrosen> vec::append(*foo, other_vec);
[20:39:49] <jmgrosen> debug!(*foo);
[20:40:02] <jmgrosen> and the second debug!() gets me the partially moved value error
[20:40:09] <strcat> jmgrosen: and points to the first as the partial move?
[20:40:10] <jmgrosen> is there a way i can append without moving?
[20:40:21] <strcat> what's the full error
[20:41:04] <jmgrosen> https://gist.github.com/jmgrosen/5736491
[20:41:29] *** Quits: akuda_ (akuda@moz-ECDED8BD.neoplus.adsl.tpnet.pl) (Quit: Wychodzi)
[20:41:48] <strcat> jmgrosen: oh, you don't want append
[20:41:53] <strcat> append takes it by-value and returns a new one
[20:41:57] <strcat> you want push_all
[20:42:22] <strcat> jmgrosen: err
[20:42:25] <Amanieu> nmatsakis: https://github.com/mozilla/rust/wiki/Proposal-for-closure-reform added my proposal to unify functions and traits
[20:42:26] <strcat> jmgrosen: no, push_all_move
[20:42:33] <strcat> I think
[20:42:49] *** Quits: mleise (marco@moz-3468AB5B.pools.arcor-ip.net) (Quit: Leaving.)
[20:43:43] <ssbr> I am having some trouble with some code, where I want to pattern match a thing and maybe move values out of it. Here's a pastebin: https://gist.github.com/ssbr/43726d3eb48ed6718376
[20:43:55] <jmgrosen> strcat: awesome!
[20:43:56] <ssbr> anyone have an approach that will work with more generality?
[20:44:05] <jmgrosen> it works :D
[20:44:08] <strcat> jmgrosen: :)
[20:44:10] <jmgrosen> thanks so much
[20:44:14] <strcat> np
[20:44:23] <jmgrosen> still wrapping my head around rust, it's very intriguing but also complex :P
[20:44:41] <strcat> the vec/str modules are a huge mess btw, it's a known problem
[20:44:41] <jmgrosen> hopefully i'll have time with a lighter load this summer than over the school year
[20:44:51] <strcat> they have about 20x as many functions as they should
[20:44:53] <strcat> ;p
[20:45:01] <jmgrosen> i wouldn't argue with that
[20:45:19] <strcat> many ways of doing the exact same thing, some better than others
[20:45:40] <strcat> jmgrosen: in the past two dozens a dozen functions were removed from them so it's looking good :)
[20:45:45] <strcat> past two days*
[20:45:46] <strcat> silly brain
[20:45:52] <cmr> ssbr: What do you want to accomplish, in the general case? Extracting elements from a data structure? Not a good idea to move out the ~Xyzzy because then the data structure is consumed (ie, no longer valid for use)
[20:46:03] <jmgrosen> strcat: less is more :P
[20:46:16] <strcat> jmgrosen: yep, we need more minimal, reusable APIs
[20:46:27] <ssbr> cmr: That's what I want to happen. I am mutating a binary tree in-place.
[20:46:40] <ssbr> cmr: So, _sometimes_ I want to replace the current element (based on the contents), and sometimes I don't
[20:47:00] <ssbr> if I'm replacing the current node, then I don't care if the current node is consumed; and I will use the stuff I move out to make the new node
[20:47:17] <strcat> ssbr: well look at what extra::treemap does
[20:47:24] <strcat> it has good examples of various patterns
[20:47:31] <ssbr> strcat: OK, will do presently
[20:47:32] <cmr> ssbr: and did you try matching on *x?
[20:47:35] <strcat> since it doesn't *ever* perform copies or doesn't use @
[20:47:55] <strcat> ssbr: swaps and 'ref mut' in match pattern are used a lot
[20:47:55] <ssbr> cmr: doesn't that always consume it?
[20:47:58] <Amanieu> bblum: https://github.com/mozilla/rust/wiki/Proposal-for-closure-reform added my proposal to unify functions and traits
[20:48:08] <cmr> ssbr: oh hm, I don't know. sorry :(
[20:48:14] <ssbr> well, I can always try.
[20:48:37] <ssbr> hmmmm
[20:48:57] <ssbr> oh right, there was something where if I consumed the whole thing, then I couldn't do *x = ...
[20:49:07] <ssbr> I can only consume the interior. And even then only maybe.
[20:49:23] <ssbr> (it's never successfully compiled, so...)
[20:50:18] *** Quits: infynyxx (infynyxx@moz-E95B370B.nyc.res.rr.com) (Client exited)
[20:50:21] <bjz_> jensnockert: neat!
[20:51:42] <ssbr> "// *could* be done without recursion, but it won't borrow check" -- I know that feeling :(
[20:51:55] *** Joins: mib_bx3rbd (Mibbit@moz-72830A1C.nyc.res.rr.com)
[20:52:19] <ssbr> strcat: yup, it does everything via swapping
[20:52:23] <ssbr> I guess I should try that next
[20:54:15] <ssbr> yeah, that should definitely resolve this, thinking about it.
[20:54:20] <ssbr> strcat: thanks for your advice!
[20:54:23] <ssbr> cmr: thank you too :)
[20:55:01] *** Joins: atticus (Mibbit@moz-C0A7ED45.hsd1.mn.comcast.net)
[20:55:47] *** Joins: jviereck (Adium@moz-74E0337C.dip0.t-ipconnect.de)
[20:56:23] *** Joins: erickt (Adium@49C4075F.3AC15C18.2321E71E.IP)
[20:56:26] *** Quits: jviereck (Adium@moz-74E0337C.dip0.t-ipconnect.de) (Quit: Leaving.)
[20:56:41] <jmgrosen> not sure if this is a compiler bug or a result of my unsafety, but after main finishes, it gets an error like "curl(41296,0x1100fb000) malloc: *** error for object 0x7ffe33600000: pointer being freed was not allocated" and crashes
[20:56:52] <jmgrosen> this is the code: https://gist.github.com/jmgrosen/5736542
[20:57:07] <jmgrosen> (although other than that, it works :D)
[20:57:20] <cmr> jmgrosen: did curl return a CurlHandle that you didn't free?
[20:57:47] <strcat> it's saying he's freeing something that wasn't malloc'ed
[20:57:51] <jmgrosen> well, the error says that something that *wasn't* allocated is trying to be freed
[20:57:52] <cmr> oh right
[20:57:57] <cmr> I know how to read :)
[20:58:04] * cmr sometimes has doubts
[21:03:07] *** Joins: dylukes (dylukes@moz-E4DF3FED.pitbpa.fios.verizon.net)
[21:03:11] *** Joins: victorporof (victorporo@FE2F04DC.63E19875.D111398B.IP)
[21:04:39] *** Joins: mattin (user@60DE62B6.DC7A989C.7F8AB798.IP)
[21:04:57] *** Quits: Palmik (palmik@moz-5CA3F354.pks.muni.cz) (Quit: Lost terminal)
[21:05:25] *** Quits: victorporof (victorporo@FE2F04DC.63E19875.D111398B.IP) (Ping timeout)
[21:05:37] *** Quits: Jeaye (Jeaye@moz-FD505E54.hsd1.ca.comcast.net) (Ping timeout)
[21:05:53] <jmgrosen> any idea?
[21:06:30] *** Joins: bb_ddd (Mibbit@moz-B0D1E047.dynamic.tstt.net.tt)
[21:07:34] *** Quits: tikue (tkuehn@moz-CF8BEBEF.dia.static.qwest.net) (Quit: tikue)
[21:07:52] *** Joins: Jeaye (Jeaye@moz-FD505E54.hsd1.ca.comcast.net)
[21:09:03] *** Joins: carter (carter@moz-8B414CBF.apng.seas.upenn.edu)
[21:11:26] *** Joins: mzabaluev (mzabaluev@moz-91FFD755.dhcp.inet.fi)
[21:12:54] *** Joins: carllerche (carllerche@6B070D22.7E6A0813.1428D117.IP)
[21:13:04] <jmgrosen> it seems like it can't be in my code, because my last statement (debug!("done here")) is called
[21:13:06] *** Quits: carllerche (carllerche@6B070D22.7E6A0813.1428D117.IP) (Quit: carllerche)
[21:13:10] <jmgrosen> so it has to be after fn main()
[21:13:10] *** Joins: carllerche (carllerche@6B070D22.7E6A0813.1428D117.IP)
[21:13:12] *** Quits: carllerche (carllerche@6B070D22.7E6A0813.1428D117.IP) (Quit: carllerche)
[21:13:38] <cmr> jmgrosen: get symbols for libcurl and pop it into gdb
[21:14:02] *** Joins: annodomini (lambda@moz-9AC5B452.hsd1.ma.comcast.net)
[21:15:04] <jmgrosen> ok, the error says to set a breakpoint in "malloc_error_break" to debug, so i did so
[21:16:30] *** Parts: steven_is_false (user@moz-144077DE.bchsia.telus.net) (ERC Version 5.3 (IRC client for Emacs))
[21:17:52] *** Joins: adu (ajr@moz-96FE9B84.washdc.fios.verizon.net)
[21:18:37] <jmgrosen> can't wait until rust code gets better debugging support
[21:18:39] <cmr> strcat: the tree is still red, didn't you fix it?
[21:18:47] <strcat> cmr: no
[21:18:50] <cmr> oh
[21:19:05] <strcat> cmr: https://github.com/mozilla/rust/issues/6998?source=cc#issuecomment-19143479
[21:19:07] *** Quits: adu (ajr@moz-96FE9B84.washdc.fios.verizon.net) (Quit: adu)
[21:19:28] <cmr> ah
[21:20:34] <cmr> strcat: might shoot jason an email (jasone@canonware.com), he's been responsive when I've had issues before
[21:20:50] <strcat> I know what has to be done to fix it though
[21:21:06] <strcat> just need someone willing to figure out how to deal with autoconf to do it
[21:21:13] <bjz_> jensnockert: should we define the float interpolate functions in terms of f64, like the others?
[21:21:47] <jensnockert> bjz_: Preferably not.
[21:22:20] <bjz_> jensnockert: I'm also wondering if things like abs should be associated functions
[21:22:26] *** Joins: MaikKlein (maik@moz-B464C230.dip0.t-ipconnect.de)
[21:22:26] <jensnockert> bjz_: That is just a workaround for not being able to write a single implementation and using it everywhere, ne?
[21:22:38] <bjz_> jensnockert: pretty much
[21:22:54] <bjz_> jensnockert: we could have a float_macros mod
[21:23:16] <jensnockert> Which is also just a workaround for traits not being powerful enough yet :(
[21:23:18] <bjz_> jensnockert: like the uints and ints
[21:23:23] <bjz_> yeah :(
[21:23:39] <bjz_> jensnockert: what do you think about the associated functions?
[21:23:51] <jensnockert> I like associated functions, I think.
[21:24:06] <bjz_> like, .to_radians() makes sense
[21:24:12] <bjz_> .abs() does not
[21:24:46] <bjz_> I'll pull your changes
[21:25:22] <bjz_> jensnockert: I'll also rebase to the current incoming
[21:25:27] <MaikKlein> what are  associated functions?
[21:25:44] <MaikKlein> vec::dot() ?
[21:25:45] <jensnockert> bjz_: Why doesn't #abs make sense?
[21:26:17] <strcat> bjz_: I don't understand why .abs() doesn't make sense
[21:26:37] <bjz_> isn't the normal mathematical notation abs(x)?
[21:26:48] <strcat> the normal mathematical notation doesn't use = for assignment either
[21:27:09] <bjz_> heh, true
[21:27:10] <strcat> what makes sense in math isn't the same as what makes sense for math in rust
[21:27:19] <strcat> ruby uses .abs
[21:27:23] <bjz_> mmk
[21:27:38] <bjz_> granted
[21:27:47] <strcat> math doesn't have methods at all ;p
[21:28:02] <strcat> the notation
[21:28:18] <bjz_> jensnockert: why are the interpolate functions associated functions?
[21:28:34] <bjz_> jensnockert: what was your reasoning? (just curious)
[21:28:40] <strcat> bjz_: problem is for big integers and other things like that you're going to want an in-place abs too
[21:28:44] <jensnockert> bjz_: Because they have no obvious self.
[21:28:46] <strcat> and same with everything else
[21:28:53] <strcat> so naming is going to be hard
[21:29:04] <jensnockert> t would be the obvious self-parameter, but Barycentric etc. has multiple such parameters.
[21:29:12] <bjz_> it should be something we should nail down, for the style guide
[21:29:31] <bjz_> ie. when to use an associated function, vs a method
[21:29:39] <bjz_> jensnockert: good reasoning
[21:29:51] <strcat> what do you mean by associated fn?
[21:30:12] <jensnockert> #abs on the other hand has a pretty obvious self parameter.
[21:30:13] <bjz_> jensnockert: should min/max be associated fns then, seeing as they don't have an obvious self?
[21:30:15] *** Joins: ghrust (ghrust@E7A4CCE2.6A2AE50.F3114085.IP)
[21:30:15] <ghrust> 01[13rust01] 15bors merged 06auto into 06incoming: 02http://git.io/1u8VPw
[21:30:15] *** Parts: ghrust (ghrust@E7A4CCE2.6A2AE50.F3114085.IP) ()
[21:30:26] <bjz_> strcat: static methods
[21:30:30] *** Quits: mzabaluev (mzabaluev@moz-91FFD755.dhcp.inet.fi) (Ping timeout)
[21:30:38] <jensnockert> bjz_: Probably.
[21:31:00] <bjz_> strcat: the naming makes more sense once we have associated types and statics
[21:31:21] <jensnockert> Preferably they would be [T].min() &c. But I doubt the compiler can make that fast.
[21:31:37] <strcat> (x, y).max()
[21:31:41] <strcat> can certainly make that fast
[21:31:50] <strcat> (x, y, z).max()
[21:31:57] <strcat> ;p
[21:31:58] <bjz_> strcat: what I was about to say
[21:32:05] <jensnockert> strcat: Yeah, but you need to write impls for every combination.
[21:32:11] <jensnockert> (At least for now)
[21:32:16] <bjz_> yeah :(
[21:32:28] <bjz_> can't really template it
[21:32:33] <jensnockert> Unfortunately.
[21:32:55] <jensnockert> Could remove barycentric and make t the self-param, would make the API much nicer tbh.
[21:33:05] <jensnockert> 0.5.interpolate(0.0, 2.0) 
[21:33:14] *** Joins: ghrust (ghrust@C8693FCB.6A2AE50.F3114085.IP)
[21:33:14] <ghrust> 01[13rust01] 15bors pushed 0 new commits to 06auto: 02http://git.io/qAufIw
[21:33:14] *** Parts: ghrust (ghrust@C8693FCB.6A2AE50.F3114085.IP) ()
[21:33:16] *** Joins: ghrust (ghrust@AD60B2E3.6A2AE50.F3114085.IP)
[21:33:16] <ghrust> 01[13rust01] 15bors pushed 2 new commits to 06auto: 02http://git.io/3mbf_A
[21:33:16] <ghrust> 13rust/06auto 14fe3ad0a 15Daniel Micay: rm some uses of to_mut_unsafe_ptr
[21:33:16] <ghrust> 13rust/06auto 14470bf0d 15bors: auto merge of #7016 : thestinger/rust/ptr, r=luqmana
[21:33:16] *** Parts: ghrust (ghrust@AD60B2E3.6A2AE50.F3114085.IP) ()
[21:33:22] <jensnockert> t.interpolate(0.0, 2.0) looks less silly.
[21:33:49] <bjz_> (x, y).lerp(t)?
[21:34:06] <EXetoC> derp
[21:34:32] <bjz_> EXetoC: :P
[21:36:02] <jensnockert> t.linear(x, y) is nicer.
[21:36:07] <jensnockert> imho.
[21:36:10] <bjz_> jensnockert: but somebody might want (vec, vec).lerp(t). dunno how that would factor in
[21:36:27] <jensnockert> bjz_: Couldn't that just be t.lerp(vec, vec) ?
[21:36:58] <jensnockert> Or more likely, t is a vector and x/y are scalars.
[21:37:13] <jensnockert> Complex trait could turn comple.
[21:37:15] <jensnockert> *complex
[21:37:26] *** Quits: erickt (Adium@49C4075F.3AC15C18.2321E71E.IP) (Quit: Leaving.)
[21:37:45] *** Joins: hanny (Mibbit@moz-F157A3B4.static.spk.cz)
[21:37:59] <bjz_> jensnockert: https://gist.github.com/bjz/6c5e7e72fbb43d9c8361
[21:38:05] <bjz_> jensnockert: ugly I know
[21:38:34] *** Quits: hanny (Mibbit@moz-F157A3B4.static.spk.cz) (Quit: http://www.mibbit.com ajax IRC Client)
[21:38:35] *** Quits: annodomini (lambda@moz-9AC5B452.hsd1.ma.comcast.net) (Quit: annodomini)
[21:40:27] <MaikKlein> what does AST mean?
[21:40:46] <bjz_> abstract syntax tree
[21:40:48] <bjz_> usually
[21:41:00] <bjz_> (in the context of compilers)
[21:41:09] <MaikKlein> thanks
[21:41:57] <bjz_> MaikKlein: http://en.wikipedia.org/wiki/Abstract_syntax_tree
[21:43:33] <bjz_> jensnockert: rebased the branch
[21:43:38] <jensnockert> Noice.
[21:43:39] <EXetoC> bjz_: c(:)-<
[21:44:22] <bjz_> jensnockert: it would be nice to find a solution that meant we didn't have to give up barycentric
[21:44:35] *** Joins: erickt (Adium@49C4075F.3AC15C18.2321E71E.IP)
[21:44:41] <jensnockert> bjz_: We could just factor it out to another trait, or pass in t as a tuple/vector.
[21:45:22] <bjz_> jensnockert: I think the associated functions are fine for now, tbh
[21:46:38] <bjz_> I can remove the // TODO: tests?
[21:47:53] <bjz_> oh wait
[21:47:55] <bjz_> crap
[21:48:08] <bjz_> I think I rebased over your tests -_-
[21:48:31] <bjz_> ffff
[21:48:46] <bjz_> jensnockert: sorry! and I pushed to the branch
[21:49:30] <jensnockert> Not like I don't have the code on my computer ;)
[21:50:11] <bjz_> #reckless_rebasing
[21:50:30] <doomlord__> lerp is well known , vs linear
[21:50:38] <doomlord__> hlsl etc
[21:50:49] <bjz_> yeah
[21:51:11] <bjz_> doomlord__: are the associated functions ok?
[21:51:13] <doomlord__> (x,y).lerp(t) better than t.lerp(x,y) imo
[21:51:21] <bjz_> doomlord__: yeah
[21:51:21] *** Joins: Axord (xord@moz-C3CCF156.lsanca.dsl-w.verizon.net)
[21:51:22] <jensnockert> Interpolate::linear is kind of obvious imho.
[21:51:36] <doomlord__> since the line is an 'object'
[21:51:58] <bjz_> doomlord__: but I guess if somebody wanted to do that in a lib, that would be more appropriate
[21:52:21] <bjz_> doomlord__: this is the std, and folks might not be working in the area of graphics
[21:52:33] <bjz_> doomlord__: where lerp is the jargon
[21:52:42] <bjz_> doomlord__: just a thought though
[21:52:43] <doomlord__> not sure i would want all the interpolation in one trait - lerp is  very primitive
[21:52:55] <doomlord__> curves etc have many options
[21:53:20] <doomlord__> lerp / invlerp would be used in 2d layout (windoe mapping?)
[21:53:52] <bjz_> doomlord__: makes me wonder if we should even include it, tbh
[21:54:13] <bjz_> doomlord__: might make more sense to leave intoperlation up to libs
[21:54:25] <bjz_> *interpolation
[21:54:59] <doomlord__> if you have lerp/invlerp in the standard libraries ... perhaps graphics poeople will be impressed and flock to rust, making lots of visually appealing code that brings more users in :)
[21:55:23] *** Joins: steven_is_false (user@moz-144077DE.bchsia.telus.net)
[21:55:44] <doomlord__> i would put lerp at the level of min/max ... not in the same trait of course, but its such a simple, common , widely-used operation
[21:56:13] <jensnockert> Most languages with a touch of maths have some sort of linspace method around.
[21:58:01] <doomlord__> jensnockert, r.e. "interpolate::linear", you'd have "interpolate::cubic" etc ?
[21:58:18] *** Quits: Cromulent (Cromulent@moz-983B638D.cable.virginmedia.com) (Quit: KVIrc 4.2.0 Equilibrium http://www.kvirc.net/)
[21:58:51] <jensnockert> doomlord__: Python has even weirder ones, like logspace.
[21:59:18] *** Quits: bb_ddd (Mibbit@moz-B0D1E047.dynamic.tstt.net.tt) (Quit: http://www.mibbit.com ajax IRC Client)
[21:59:41] <jensnockert> Well, numpy.
[21:59:42] <jensnockert> http://docs.scipy.org/doc/scipy/reference/interpolate.html
[22:00:36] <doomlord__> ok interesting
[22:00:48] *** Quits: carter (carter@moz-8B414CBF.apng.seas.upenn.edu) (Quit: Textual IRC Client: www.textualapp.com)
[22:01:31] <doomlord__> if you need part of a trait - you're supposed to implement *all* - i can see plenty of code needing lerp but without needing the more complex cases
[22:01:44] <doomlord__> ^ is that the case , implement the whole trait.
[22:01:44] <MaikKlein> how do I make the compiler verbose again?
[22:03:01] <jensnockert> Wtf, why did a git pull --rebase overwrite my test-code? *cries*
[22:03:02] *** Quits: dylukes (dylukes@moz-E4DF3FED.pitbpa.fios.verizon.net) (Quit: Computer has gone to sleep.)
[22:03:23] <ssbr> Is there a better way to write this? https://gist.github.com/ssbr/200ba05f8187efc2451c
[22:03:41] <doomlord__> http://en.wikipedia.org/wiki/Lerp_%28computing%29#Programming_language_support << :)
[22:03:43] *** Joins: victorporof (victorporo@FE2F04DC.63E19875.D111398B.IP)
[22:03:51] <strcat> nmatsakis: btw I think the vector iterators could just be slices - we don't necessarily need an iterator object for them at all
[22:04:01] <strcat> slices could just impl Iterator
[22:04:17] <strcat> although we do need an object for the reverse...
[22:04:18] <Eridius> jensnockert: you can get the previous state of your branch back by checking out `@{1}'
[22:04:22] <Eridius> s/`/'/
[22:04:46] <jensnockert> Eridius: No, my commit is gone.
[22:05:01] <Eridius> jensnockert: your commit will not disappear from your local repo for at least 30 days
[22:05:04] *** Joins: eholk (eholk@moz-9AB4D52F.hsd1.ut.comcast.net)
[22:05:16] <strcat> jensnockert: git reflog
[22:05:40] <jensnockert> Oh, thanks.
[22:05:41] <Eridius> the reflog will anchor the commit for a while, which is what the @{1} syntax accesses, and it will take 2 weeks after the first GC after it disappears from the reflog before it gets truly collected
[22:05:46] *** Quits: victorporof (victorporo@FE2F04DC.63E19875.D111398B.IP) (Ping timeout)
[22:05:55] <strcat> jensnockert: unreachable objects last 2 weeks, reflog (deleted branches, etc.) lasts 30 days
[22:06:35] <strcat> it's a persistent data structure with gc, only the pointers to it can be modified :)
[22:06:43] <strcat> and the gc is very delayed.
[22:06:47] <jensnockert> I just checked the log.
[22:06:53] <Eridius> ssbr: why are you swapping through a temporary?
[22:06:54] <jensnockert> And it was *poof*
[22:07:00] *** Quits: donri (dag@moz-9BB61102.tbcn.telia.com) (Client exited)
[22:07:10] <ssbr> Eridius: Because I can't swap directly.
[22:07:35] <ssbr> if I match against MyTuple(~ref mut a, ~ref mut b), the borrow checker fails me for having two mutable borrows of a tuple
[22:07:42] <strcat> ssbr: use incoming
[22:07:53] <ssbr> arrooo
[22:08:00] <ssbr> I've been waiting for incoming to build. Maybe it's done!
[22:08:28] <ssbr> (nope)
[22:08:30] <Eridius> woo, all the vec changes lately have broken pretty much every rust file I've written
[22:08:34] <strcat> rusti: let t = (1, 2); let (x, y) = match t { (ref mut x, ref mut y) => (x, y) };
[22:08:35] <ssbr> strcat: is this changed in incoming?
[22:08:40] <ssbr> or do you just mean generally
[22:08:43] <strcat> rusti: let t = (1, 2); let (x, y) = match t { (ref mut x, ref mut y) => (x, y) }; swap(x, y); t
[22:08:48] -rusti- more than 5 lines of output, pastebinned: http://sprunge.us/QTbY
[22:08:48] -rusti- more than 5 lines of output, pastebinned: http://sprunge.us/QOEB
[22:09:10] <strcat> rusti: let mut t = (1, 2); let (x, y) = match t { (ref mut x, ref mut y) => (x, y) }; std::util::swap(x, y); t
[22:09:11] -rusti- (2, 1)
[22:09:20] <strcat> (I used match instead of let because let is unsound)
[22:09:33] <strcat> to prove it works with sound borrowck ;p
[22:09:48] <strcat> rusti: let mut t = (1, 2); let (ref mut x, ref mut y) = t; std::util::swap(x, y); t
[22:09:50] -rusti- more than 5 lines of output, pastebinned: http://sprunge.us/YjSE
[22:10:01] *** Joins: twm (twm@moz-13417AD3.dsl.static.sonic.net)
[22:10:04] <strcat> heh let doesn't work at all
[22:10:31] * jensnockert hugs Eridius for teaching me something new.
[22:11:15] <ssbr> strcat: so it is fixed, and I just have to wait for rust to compile?
[22:11:21] <strcat> ssbr: yes
[22:11:28] <strcat> rusti: let mut t = (1, 2); let (x, y) = match t { (ref mut x, ref mut y) => (x, y) }; std::util::swap(x, y); t
[22:11:30] -rusti- (2, 1)
[22:11:33] *** Quits: jmgrosen (jmgrosen@moz-848F6087.sb.sd.cox.net) (Quit: jmgrosen)
[22:11:37] <ssbr> that'll be another hour. I make clean'd because it had some weir conflict with existing DLLs :(
[22:11:42] <strcat> ssbr: borrowck is much, much better than it was in 0.6
[22:11:49] <ssbr> strcat: this is an old incoming.
[22:11:55] <Eridius> jensnockert: <3 git, I never lose my work
[22:11:58] <ssbr> like, maybe a month old
[22:12:03] <ssbr> it's after the borrowck changes
[22:12:10] <strcat> ssbr: there were more though
[22:12:37] <steven_is_false> I was just reading reddit.com/r/rust let json = from_str(stringify!({"language": "Rust","level" : 9001 })).unwrap(); works!??
[22:12:46] <caitp> what would you use to copy values from one vector to another
[22:12:51] *** Quits: MaikKlein (maik@moz-B464C230.dip0.t-ipconnect.de) (Ping timeout)
[22:12:56] <Eridius> what's stringify!()?
[22:13:26] <steven_is_false> I don't know!
[22:13:42] <Eridius> stringify! : pretty-print the Rust expression given as an argument
[22:13:48] <Eridius> rusti: stringify!(3)
[22:13:50] -rusti- "3"
[22:13:53] <strcat> Eridius: makes a string from tokens at compile-time
[22:14:07] <strcat> rusti: stringify(<< < < < < < < < < <)
[22:14:07] <Eridius> rusti: stringify!(foo bar)
[22:14:07] <steven_is_false> rusti: stringify!("foo" "bar" "foo")
[22:14:08] -rusti- <anon>:10:19: 10:21 error: unexpected token: `<<`
[22:14:09] -rusti- <anon>:10          stringify(<< < < < < < < < < <)
[22:14:09] -rusti-                              ^~
[22:14:09] -rusti- application terminated with error code 101
[22:14:10] -rusti- "foo bar"
[22:14:10] -rusti- "\"foo\" \"bar\" \"foo\""
[22:14:14] <strcat> heh
[22:14:29] <jensnockert> bjz_: Managed to re-add the commit.
[22:14:30] <strcat> rusti: stringify(< < < < < < < < <)
[22:14:30] -rusti- <anon>:10:19: 10:20 error: unexpected token: `<`
[22:14:30] -rusti- <anon>:10          stringify(< < < < < < < < <)
[22:14:30] -rusti-                              ^
[22:14:30] -rusti- application terminated with error code 101
[22:14:45] <steven_is_false> Oh so this isn't as cool as I thought it was.
[22:14:51] <steven_is_false> Oh well.
[22:15:07] <strcat> steven_is_false: what did you think it did?
[22:15:22] <Eridius> we really should update rust-lang.org's "trunk" docs for recent incoming
[22:15:25] <caitp> rusti: be clever enough to print an analog for memcpy/strcpy in rust
[22:15:25] -rusti- <anon>:10:9: 10:11 error: `be` is a reserved keyword
[22:15:25] -rusti- <anon>:10          be clever enough to print an analog for memcpy/strcpy in rust
[22:15:25] -rusti-                    ^~
[22:15:25] -rusti- application terminated with error code 101
[22:15:37] <strcat> Eridius: when incoming is green again we can just get rid of it.
[22:15:38] <steven_is_false> strcat: For a moment I thought there was a json! macro
[22:15:45] <Eridius> strcat: get rid of it?
[22:15:50] <strcat> Eridius: get rid of incoming
[22:15:53] <Eridius> huh.. rust-lang.org's "std" docs is now incoming's std
[22:16:01] <Eridius> and it's "core" docs are, well, core
[22:16:05] <Eridius> so there's no documentation on extra anymore
[22:16:15] <SiegeLord> What does ^@ character mean in vim?
[22:16:20] <strcat> Eridius: known issue, need graydon around to fix it
[22:16:23] <Eridius> heh ok
[22:16:31] <strcat> SiegeLord: not valid text (nul)
[22:16:33] * Eridius disappears to go eat food
[22:16:58] <ssbr> yup, looks fixed (with private rusti session)
[22:17:02] *** Joins: mhi (mhi@moz-4814EA55.sanctioned.net)
[22:17:17] <strcat> I still need to make a web interface for rusti.
[22:17:24] <strcat> maybe I'll do that now
[22:17:29] <ssbr> What's up with this?
[22:17:33] <ssbr> rusti: pub struct Mything(int, int); Mything(1, 2)
[22:17:34] -rusti- {__field__: 1, __field__: 2}
[22:17:47] <strcat> that's how fmt!("%?", x) prints anon fields
[22:17:51] *** Joins: maxli (maxli@C03F2759.C70D537E.2FA4EA88.IP)
[22:17:54] <ssbr> I would've expected "Mything(1, 2)" :(
[22:17:55] <SiegeLord> rusti: use std::str; str::byte_slice_no_callback("a").len()
[22:17:57] -rusti- 2
[22:18:03] <ssbr> strcat: is the order guaranteed to match up?
[22:18:07] <strcat> ssbr: yes
[22:18:11] <SiegeLord> I see... str::byte_slice_no_callback is buggy, so I'm writing NULLs
[22:18:34] *** Quits: spider-mario (spidermari@moz-AC2C1EAE.rev.sfr.net) (Input/output error)
[22:18:37] <strcat> SiegeLord: not necessarily buggy, just not what you expected
[22:18:53] <SiegeLord> The documentation says that it shouldn't include the trailing NULL
[22:19:01] <strcat> well then it's buggy :)
[22:19:02] <SiegeLord> // Work with the string as a byte slice, not including trailing null
[22:19:09] <bjz_> rusti: stringify!(< < < < < < < < <)
[22:19:10] -rusti- "< < < < < < < < <"
[22:19:17] <bjz_> strcat: ^
[22:19:33] <caitp> what does the phrase "byte slice" mean to you
[22:19:46] <bjz_> a slice of bytes
[22:19:52] <bjz_> x)
[22:19:57] <caitp> what does that mean to you
[22:20:09] <bjz_> &'a [u8]
[22:20:14] <strcat> bjz_: heh I was forgetting the ! >.<
[22:20:18] <strcat> bjz_: *sigh*
[22:20:31] <SiegeLord> rusti: use std::str; str::to_bytes("a").len()
[22:20:32] -rusti- 1
[22:21:41] <SiegeLord> rusti: use std::str; do str::byte_slice("a") |v| { v.len() }
[22:21:42] -rusti- 1
[22:23:26] <SiegeLord> I'll submit a  bug... I'm not sure if the issue is with that function, or cast::transmute
[22:23:33] *** Joins: dylukes (dylukes@moz-E4DF3FED.pitbpa.fios.verizon.net)
[22:24:12] *** Joins: ghrust (ghrust@1E8607E8.6A2AE50.F3114085.IP)
[22:24:12] <ghrust> 01[13rust01] 15bors merged 06auto into 06incoming: 02http://git.io/3mbf_A
[22:24:12] *** Parts: ghrust (ghrust@1E8607E8.6A2AE50.F3114085.IP) ()
[22:27:12] *** Joins: ghrust (ghrust@DE823A67.6A2AE50.F3114085.IP)
[22:27:12] <ghrust> 01[13rust01] 15bors pushed 0 new commits to 06auto: 02http://git.io/VcUB3g
[22:27:12] *** Parts: ghrust (ghrust@DE823A67.6A2AE50.F3114085.IP) ()
[22:27:13] *** Joins: ghrust (ghrust@C8693FCB.6A2AE50.F3114085.IP)
[22:27:13] <ghrust> 01[13rust01] 15bors pushed 3 new commits to 06auto: 02http://git.io/991cvQ
[22:27:13] <ghrust> 13rust/06auto 148ddd9f6 15Bill Myers: fix decoding of multiple attributes (fixes #7017)...
[22:27:13] <ghrust> 13rust/06auto 14a0fc975 15Bill Myers: add test for RcMut being Const and Owned, tests #7017 being fixed
[22:27:13] <ghrust> 13rust/06auto 14b347ed7 15bors: auto merge of #7018 : bill-myers/rust/fix_7017, r=luqmana...
[22:27:15] *** Parts: ghrust (ghrust@C8693FCB.6A2AE50.F3114085.IP) ()
[22:28:00] <steven_is_false> Is anyone else seeing control characters pop up in their reader from ghrust?
[22:28:25] <strcat> steven_is_false: nope
[22:28:36] <strcat> it does use bold/colors
[22:28:39] <steven_is_false> strange, maybe it's just an Emacs problem.
[22:30:07] <strcat> steven_is_false: http://i.imgur.com/F7RGLGq.png
[22:30:37] *** Quits: erickt (Adium@49C4075F.3AC15C18.2321E71E.IP) (Connection reset by peer)
[22:31:11] <steven_is_false> I think I need to set erc-interpret-mirc-color to true to fix this problem
[22:31:16] <strcat> I guess it could be from bold?
[22:31:43] *** Joins: erickt (Adium@49C4075F.3AC15C18.2321E71E.IP)
[22:31:45] <steven_is_false> Okay can you give me a color code now?
[22:31:47] *** Quits: FreezerburnV (freezerbur@moz-5718C330.bltmmd.fios.verizon.net) (Quit: FreezerburnV)
[22:31:48] <strcat> 5test
[22:31:52] <strcat> 6test
[22:31:55] <strcat> 1test
[22:31:59] *** Quits: dylukes (dylukes@moz-E4DF3FED.pitbpa.fios.verizon.net) (Quit: Computer has gone to sleep.)
[22:32:09] <strcat> reverse
[22:32:14] <strcat> italic
[22:32:19] <strcat> italic *
[22:32:27] <strcat> underlined
[22:33:08] <steven_is_false> Fixed it, I had to set erc-interpret-controls-p
[22:33:43] <steven_is_false> Test italic *
[22:34:00] <strcat> this should be italic
[22:34:03] <strcat> this should be bold
[22:34:14] *** Parts: twm (twm@moz-13417AD3.dsl.static.sonic.net) ()
[22:34:39] <steven_is_false> Strange, underlining works but the other stuff doesn't.
[22:34:48] <steven_is_false> Whatever.
[22:38:35] *** Joins: alisdair (textual@E1CEBB1A.D061F0C9.AA6AEE7B.IP)
[22:39:19] *** Quits: eholk (eholk@moz-9AB4D52F.hsd1.ut.comcast.net) (Quit: eholk)
[22:44:13] <ssbr> strcat: nice, it works
[22:44:38] <ssbr> is there any updated reference to how borrowing works now? I need to reorient my intuition for when I should used @-ptrs and when I should use ~/&
[22:45:02] <ssbr> up until now I would've said that if I need to update multiple parts of a data structure at once, borrowing won't work out
[22:45:04] *** Joins: tiffany (kawaii@moz-1E0FE6E8.dhcp.embarqhsd.net)
[22:45:43] *** Quits: maxli (maxli@C03F2759.C70D537E.2FA4EA88.IP) (Quit: Leaving.)
[22:46:23] <SiegeLord> What crate do I use to do file IO?
[22:46:36] <SiegeLord> *module
[22:47:18] *** Quits: Blub\w (wry@7E3BB9D.71150E1A.237AE2BA.IP) (Quit: night)
[22:47:39] <mattin> SiegeLord: there should be an io module
[22:48:09] <mattin> http://static.rust-lang.org/doc/0.6/core/io.html
[22:48:29] *** Quits: alisdair (textual@E1CEBB1A.D061F0C9.AA6AEE7B.IP) (Quit: My MacBook Pro has gone to sleep. ZZZzzzâ€¦)
[22:48:49] <mhi> At the moment there is no quick way to play around with Rust without compiling it + LLVM (for Linux), right?
[22:49:07] <SiegeLord> Oh, I see... I was looking for something with the word "open" in it...
[22:49:43] *** Quits: int3_ (int3_@moz-ABE52D50.hsd1.ca.comcast.net) (Client exited)
[22:49:58] <steven_is_false> mhi: Right but you don't need to compile clang as well so it doesn't take that long
[22:51:12] <mhi> steven_is_false: Well, I just had the problem that I only have a laptop right now. Last time I tried buildig Rust the laptop ran hot and shut down itself, heh.
[22:51:58] <SiegeLord> Hmm... file_writer puzzles me... it uses @Writer, does that mean it won't close by itself?
[22:52:07] <steven_is_false> mhi: Hmm that's a difficult problem.
[22:53:12] <mhi> steven_is_false: Yup, I see no workaround apart from outsourcing to another system.
[22:53:41] <steven_is_false> mhi: I dunno compile in a refrigerator?
[22:54:07] <steven_is_false> mhi: Also, try cleaning out the dust from your laptop
[22:54:56] *** Joins: RMF (RMF@E80DA7BB.A3D80C3C.8D19547B.IP)
[22:55:15] <EXetoC> SiegeLord: deterministically?
[22:55:23] <SiegeLord> Yes
[22:57:12] <caitp> how do I say "the owned pointer returned from this function needs to share the lifetime of the structure which owns it"
[22:59:45] <EXetoC> caitp: use the same named lifetime for both
[22:59:58] <caitp> i'm asking how
[23:01:11] <EXetoC> rusti: struct S<'self> { x: &int }
[23:01:13] -rusti- more than 5 lines of output, pastebinned: http://sprunge.us/beAW
[23:01:25] <EXetoC> rusti: struct S<'self> { x: &'self int }
[23:01:27] -rusti- ()
[23:01:50] <caitp> like, how would I initialize core::io::BytesReader's 'bytes' attribute with the result of str::to_bytes()
[23:02:17] <EXetoC> rusti: struct S<'self> { x: &'self int } impl<'self> S<'self> { fn get<'a>(&'a self) -> &'a int { self.x } }
[23:02:18] -rusti- ()
[23:03:57] <caitp> rusti: use core::io::*; let x = BytesReader { bytes: str::to_bytes(~"fucking rust"), pos: @mut 0, };
[23:03:58] -rusti- more than 5 lines of output, pastebinned: http://sprunge.us/XUYb
[23:04:11] *** Joins: victorporof (victorporo@FE2F04DC.63E19875.D111398B.IP)
[23:04:17] <caitp> derf
[23:04:21] <Eridius> caitp: rusti uses incoming, where core is std and std is extra
[23:04:51] <caitp> such a headache
[23:04:59] *** Parts: mhi (mhi@moz-4814EA55.sanctioned.net) ()
[23:05:25] <Eridius> rusti: use std::io::*; let x = BytesReader { bytes: std::str::to_bytes(~"fucking rust"), pos: @mut 0 }; x
[23:05:27] -rusti- more than 5 lines of output, pastebinned: http://sprunge.us/JFQf
[23:05:42] <EXetoC> alpha quality you know :>
[23:05:54] <Eridius> rusti: use std::io::*; let s = std::str::to_bytes(~"fucking rust"); let x = BytesReader { bytes: s, pos: @mut 0 }; x
[23:05:57] -rusti- more than 5 lines of output, pastebinned: http://sprunge.us/OijM
[23:06:15] *** Quits: victorporof (victorporo@FE2F04DC.63E19875.D111398B.IP) (Ping timeout)
[23:06:16] <Eridius> oh x outlives s because it's returned
[23:06:18] <Eridius> rusti: use std::io::*; let s = std::str::to_bytes(~"fucking rust"); let x = BytesReader { bytes: s, pos: @mut 0 }; (x, s)
[23:06:20] -rusti- more than 5 lines of output, pastebinned: http://sprunge.us/TOMX
[23:06:26] <Eridius> bah
[23:06:44] <steven_is_false> How much more has to be compiled after jemalloc?
[23:06:45] <Eridius> rusti: use std::io::*; let s = std::str::to_bytes(~"fucking rust"); let x = BytesReader { bytes: s, pos: @mut 0 }; fmt!("%?", x)
[23:06:46] -rusti- more than 5 lines of output, pastebinned: http://sprunge.us/JURH
[23:06:59] <Eridius> rusti: use std::io::*; let s = std::str::to_bytes("fucking rust"); let x = BytesReader { bytes: s, pos: @mut 0 }; fmt!("%?", x)
[23:07:00] -rusti- line longer than 150 columns, pastebinned: http://sprunge.us/WZaR
[23:07:11] <Eridius> sweet, llvm error
[23:07:15] <caitp> nice
[23:07:32] <Eridius> but hey, that fixed the lifetime issue
[23:07:50] <Eridius> basically, whatever bytes you're reading needs to live at least as long as the bytereader
[23:08:32] <caitp> I get that, but it's not clear at all how to make that happen
[23:09:34] <caitp> like, why does initiallizing s outside of BytesReader let that happen
[23:09:59] <caitp> it is very obtuse and unclear
[23:10:24] <Eridius> caitp: because I'm keeping the owned pointer alive by storing it in a variable
[23:10:32] <Eridius> if nothing actually holds onto the owned pointer it disappears
[23:10:34] <caitp> also this apparently does not work in this code
[23:18:22] <mattin> is 'make doc' supposed to generate offline documentation in the doc/ directory?
[23:19:14] <Eridius> mattin: I assume that documentation is supposed to be generated if you have pandoc installed. Unfortunately I can't build pandoc's dependencies using the current haskell platform :/
[23:20:03] *** Joins: int3_ (int3_@moz-ABE52D50.hsd1.ca.comcast.net)
[23:20:14] *** Quits: BitPuffin (quassel@881E5F2F.5078E8B1.CB45D44D.IP) (Client exited)
[23:21:11] <mattin> Eridius: i used my distro's pandoc, but im having issues with the 'make' command in general.  it tells me "make: Nothing to be done for `doc'".
[23:21:29] <mattin> but i can't find the docs anywhere....
[23:22:10] *** Quits: RMF (RMF@E80DA7BB.A3D80C3C.8D19547B.IP) (Quit: Textual IRC Client: www.textualapp.com)
[23:22:21] *** Joins: dylukes (dylukes@moz-E4DF3FED.pitbpa.fios.verizon.net)
[23:23:12] *** Quits: dylukes (dylukes@moz-E4DF3FED.pitbpa.fios.verizon.net) (Quit: Computer has gone to sleep.)
[23:23:35] <mattin> in particular my doc/core and doc/std directories are both empty
[23:23:42] *** Quits: brson (brson@2557E599.66715431.D25A875A.IP) (Quit: leaving)
[23:25:32] *** Quits: int3_ (int3_@moz-ABE52D50.hsd1.ca.comcast.net) (Ping timeout)
[23:25:45] *** Joins: jaen (jaen@moz-E0979827.copit.pl)
[23:27:15] *** Quits: mattin (user@60DE62B6.DC7A989C.7F8AB798.IP) (Ping timeout)
[23:27:33] *** aatch|sleepnowautoborrowlater is now known as aatch
[23:29:40] *** Joins: mattin (user@9E32F7E8.DC7A989C.7F8AB798.IP)
[23:31:53] <SiegeLord> Woo... I managed to get something to plot using my gnuplot controller
[23:32:25] <SiegeLord> https://github.com/SiegeLord/RustGnuplot/blob/master/example.rs
[23:34:16] *** Joins: RMF (RMF@E80DA7BB.A3D80C3C.8D19547B.IP)
[23:36:42] <bjz_> SiegeLord: neat!
[23:39:34] *** Joins: dylukes (dylukes@moz-E4DF3FED.pitbpa.fios.verizon.net)
[23:41:26] *** Quits: true_droid (Adium@moz-123FD9B8.beck.volia.net) (Quit: Leaving.)
[23:43:02] <Eridius> if I want to call FFI that uses a struct defined in a C header file, do I have to recreate the struct in rust or is there some way to pull it from the header file?
[23:44:21] *** Quits: tgt (tgt@moz-D59EE478.aztw.cable.virginmedia.com) (Quit: Computer has gone to sleep.)
[23:45:30] <SiegeLord> Eridius, You have to recreate it, but there are tools to automate the process like rust-bindgen
[23:46:03] <steven_is_false> The Rust compiler is built twice right?
[23:46:23] <EXetoC> just define empty structs for those that are opaque
[23:46:33] <aatch> rust-bindgen isn't particularly good though.
[23:46:38] <SiegeLord> Let's say I have an enum E {A, B} Is there a shortcut that'd allow me to say: let a = A; let e = a == A; ?
[23:46:54] <SiegeLord> Without doing a full match block...
[23:47:05] <aatch> SiegeLord, #[deriving(Eq)] on the enum
[23:47:38] <steven_is_false> EXetoC: It's probable a better idea to use enum MyAbstractType {} than struct MyAbstractType;
[23:47:49] *** Joins: MaikKlein (maik@moz-B464C230.dip0.t-ipconnect.de)
[23:48:05] <steven_is_false> Or use std::util::Void
[23:48:06] <SiegeLord> aatch, Thanks!
[23:48:37] <SiegeLord> aatch, I find fixing up the output of bindgen is faster than generating it myself from scratch, heh
[23:48:54] *** Joins: moonchrome (moonchrome@moz-A3A6B427.dsl.iskon.hr)
[23:49:24] <aatch> SiegeLord, heh, thank pcwalton for insisting that we have #[deriving] for most of those traits, and dbaupp for working so hard on the deriving code itself.
[23:49:41] <Eridius> where is bindgen?
[23:51:00] *** Joins: solancile (solancile@moz-A1CFFAE5.hsd1.wa.comcast.net)
[23:51:06] <Eridius> hmm is it https://github.com/crabtw/rust-bindgen ?
[23:51:43] *** Joins: dbaupp (Thunderbir@DD5A5B3.5DFF0E76.CCE6F5F4.IP)
[23:52:49] *** Joins: wilsonk-laptop (kvirc@moz-39EFBFC2.cg.shawcable.net)
[23:53:15] <SiegeLord> Eridius, Yeah
[23:53:25] *** Quits: wilsonk|2 (kvirc@moz-39EFBFC2.cg.shawcable.net) (Ping timeout)
[23:53:28] *** Quits: jensnockert (jensnocker@moz-8BE55278.customer.t3.se) (Input/output error)
[23:55:37] *** Quits: Jesin (Jessin_@moz-3AD6F09F.res.lehigh.edu) (Ping timeout)
[23:55:37] *** Quits: bytbox (s@moz-D83E9B31.wireless.umd.edu) (Ping timeout)
[23:57:33] *** Quits: steven_is_false (user@moz-144077DE.bchsia.telus.net) (Ping timeout)
[23:58:25] *** Joins: steven_is_false (user@moz-144077DE.bchsia.telus.net)

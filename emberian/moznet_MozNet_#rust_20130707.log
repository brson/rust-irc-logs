[00:00:07] <strcat> you just write 'yield x' instead of 'f(x)'
[00:00:17] <engla> iter bytes seems like a good usecase
[00:00:19] *** Joins: ghrust (ghrust@F6EE6DE3.6A2AE50.F3114085.IP)
[00:00:20] <ghrust> 01[13rust01] 15Aatch merged 06master into 06snap-stage3: 02http://git.io/5IkNow
[00:00:20] *** Parts: ghrust (ghrust@F6EE6DE3.6A2AE50.F3114085.IP) ()
[00:00:25] <Sergio965> strcat: Yeah, yield would do it.
[00:00:28] <dbaupp> aatch: yay!
[00:00:45] <strcat> engla: it won't be any harder with an external iterator
[00:00:53] *** Quits: tiffany (kawaii@moz-28A8742A.dhcp.embarqhsd.net) (Ping timeout)
[00:00:55] <strcat> and it will optimize better than closures do
[00:01:02] <engla> I don't see it being easy
[00:01:04] <strcat> rust's closures are a big performance issue
[00:01:10] <Sergio965> strcat: But I thought there wouldn't be support for external iterators? My initial question was if they're both sticking around.
[00:01:10] <strcat> engla: I don't see why it would be any harder.
[00:01:21] <strcat> Sergio965: there won't be support for *internal* iterators
[00:01:23] <engla> would be a lot more work for each impl of IterBytes
[00:01:27] <Sergio965> Ah, yeah. Sorry.
[00:01:41] <engla> strcat: the problem is how do you put the iterator into the trait?
[00:01:42] <strcat> engla: how exactly?
[00:01:45] *** Joins: tiffany (kawaii@moz-28A8742A.dhcp.embarqhsd.net)
[00:01:58] <strcat> engla: dunno what you mean
[00:02:08] <Sergio965> Doesn't "yield" create a generator and not an iterator?
[00:02:09] <strcat> traits have type parameters
[00:02:20] <engla> have you tried this?
[00:02:23] <aatch> trait Type<T:Bound> { }
[00:02:24] <strcat> Sergio965: a generator is another word for an iterator
[00:02:27] <strcat> engla: yes I made an Iterable trait
[00:02:28] <engla> it's unweildy
[00:02:29] <strcat> works fine
[00:03:05] *** Quits: kyle2000 (kyle2000@6EDB4D7A.341FCD98.3031298E.IP) (Quit: Leaving)
[00:03:06] <Sergio965> strcat: That's not true.
[00:03:12] <dcolish> Iterable is a pretty common pattern
[00:03:20] <engla> I think the internal iterators are easier to use with traits right now.  pub type Cb<'self> = &'self fn(buf: &[u8]) -> bool;  
[00:03:22] <strcat> Sergio965: so what about yield in C# or python isn't an iterator?
[00:03:27] <strcat> C# compiles yield to a state machine
[00:03:32] <strcat> python uses context switches
[00:03:33] <strcat> both are iterators
[00:03:38] <aatch> engla, I hate that pattern
[00:03:58] <aatch> it makes reading type signatures so much harder
[00:04:02] <strcat> engla: and now you need to wrap everything with partial function wrappers
[00:04:24] <strcat> and you can't use any adaptors with it
[00:04:26] *** Quits: tedh (tedh@moz-38ABF348.central.biz.rr.com) (Ping timeout)
[00:04:30] *** Joins: tedh (tedh@moz-38ABF348.central.biz.rr.com)
[00:04:33] <strcat> internal iterator adaptors don't work with borrowed pointers, try it
[00:04:40] <strcat> you'll get lifetime errors inside generics
[00:04:40] *** Quits: webber46 (webber46@moz-98D2F3C5.cust.bredband2.com) (Quit: webber46)
[00:04:44] *** Quits: tiffany (kawaii@moz-28A8742A.dhcp.embarqhsd.net) (Connection reset by peer)
[00:04:45] <strcat> because T means &'r T
[00:04:51] <engla> anyway, when implementing shrinking for quickcheck it has the same  problem.. one trait that requires a lazy sequence and containers implementing shrink depend on elements implementing shrink
[00:04:51] *** Joins: tiffany (kawaii@moz-28A8742A.dhcp.embarqhsd.net)
[00:04:53] <strcat> so fn(T) means *same region for each iteration*
[00:05:02] <engla> composing those hierarchies together is not easy
[00:05:15] <engla> it's the same as IterBytes
[00:05:21] <strcat> I really didn't have any issues defining Iterator, FromIterator and Iterable
[00:05:36] <engla> not the same thing
[00:05:50] <Sergio965> strcat: I mean not all iterators are generators.
[00:05:52] *** Quits: erickt (erickt@8C9ECD8F.3A598286.F12515B4.IP) (Quit: Leaving.)
[00:05:54] <engla> impl <T: IterBytes> IterBytes for ~[T]  and so on
[00:06:07] <aatch> Sergio965, true, but all generators are iterators
[00:06:07] <strcat> Sergio965: well a 'generator' in C# is just sugar for writing an iterator
[00:06:13] <strcat> and in rust it would be too
[00:06:23] <Sergio965> aatch: Agreed.
[00:06:43] <Sergio965> strcat: That's great. I like the "yield" syntax.
[00:06:49] <Sergio965> Or, generators.
[00:06:52] *** Joins: jaen (jaen@moz-E0979827.copit.pl)
[00:07:28] *** Quits: tedh (tedh@moz-38ABF348.central.biz.rr.com) (Client exited)
[00:08:32] <engla> strcat: anyway, the shrink trait solves that by providing a concrete type for a common lazy sequence
[00:09:31] *** Joins: webber46 (webber46@moz-98D2F3C5.cust.bredband2.com)
[00:09:37] *** Quits: webber46 (webber46@moz-98D2F3C5.cust.bredband2.com) (Quit: webber46)
[00:09:54] *** Quits: mreedell (mreedell@moz-9950CA28.hsd1.pa.comcast.net) (Quit: Computer has gone to sleep.)
[00:12:38] *** Quits: BitPuffin (quassel@moz-911FB3CE.cust.tele2.se) (Ping timeout)
[00:12:39] <strcat> engla: I really don't think replacing IterBytes with an external iterator will be an issue
[00:12:46] *** Quits: bytewise (bytewise@moz-649C630D.unitymediagroup.de) (Quit: Leaving)
[00:12:47] <strcat> it's just a version of the Iterable trait
[00:13:19] <engla> ok that's good. I'm interested how it turns out
[00:13:55] <krdln> Are there plans to allow executing arbitrary code at compile time in macros (like in haskell)?
[00:14:08] <strcat> krdln: yes, syntax extensions will be pluggable
[00:14:28] <strcat> it's just iter_bytes() -> T with <'self, T: Iterator<&'self [u8]>>
[00:15:10] <strcat> on the trait
[00:15:12] <aatch> Grr, the build bots are being weird
[00:15:58] <aatch> queuing up like 4 builds for snap-stage3
[00:18:44] *** Joins: z0w0 (zack@E2E93C1.54F16452.2CE63F58.IP)
[00:20:25] *** Joins: pnathan (Adium@moz-E3C3FAF2.hfc.comcastbusiness.net)
[00:20:28] <aatch> ok, so the windows bot is doing the same build 3 times, but the others now are now just waiting to do 1 build
[00:20:39] *** Quits: int3_ (int3_@moz-ABE52D50.hsd1.ca.comcast.net) (Client exited)
[00:21:02] *** Joins: h3r3tic (heretic@moz-8BC3B3DB.se)
[00:23:20] *** Joins: int3_ (int3_@moz-ABE52D50.hsd1.ca.comcast.net)
[00:25:21] *** Quits: bjz (brendanzab@B398BE78.F804C29E.D35A31DF.IP) (Quit: Leaving...)
[00:26:43] *** Quits: pnathan (Adium@moz-E3C3FAF2.hfc.comcastbusiness.net) (Ping timeout)
[00:27:39] *** cade_lunch is now known as cade
[00:28:53] <aatch> Ok, so the visitor is becoming a problem.
[00:29:16] <aatch> so many changes blocked on the AST visitor not being the way it is.
[00:30:12] <dbaupp> we need a snapshot! ;)
[00:30:13] *** Quits: int3_ (int3_@moz-ABE52D50.hsd1.ca.comcast.net) (Client exited)
[00:30:19] <aatch> dbaupp, working on it.
[00:30:31] <dbaupp> yup
[00:31:02] <h3r3tic> onoz, bindgen doesn't build with master! halp! http://pastie.org/8116856
[00:31:14] *** Quits: Sergio965 (sergiobz@moz-986B8AEA.dyn.mit.edu) (Quit: My MacBook Pro has gone to sleep. ZZZzzzâ€¦)
[00:32:05] <aatch> Though I'm still waiting for linux slave to be free.
[00:33:17] *** Quits: dwrensha (chatzilla@moz-DE44EA45.hsd1.pa.comcast.net) (Ping timeout)
[00:34:37] <dbaupp> h3r3tic: I think that codemap::ExpandedFrom(codemap::CallInfo { ... }) => codemap::ExpnInfo { ... }
[00:35:33] *** Joins: vk (vk@moz-389FEE13.hsd1.ca.comcast.net)
[00:37:00] *** Quits: Houm (Houm@moz-25669AA8.fbx.proxad.net) (Ping timeout)
[00:38:18] <h3r3tic> dbaupp: thanks! that did it for one of the errors :) still got ExpandedFrom to fix
[00:38:32] <h3r3tic> oh
[00:38:43] <h3r3tic> nevermind :D
[00:38:51] <h3r3tic> yeah, that does it, thanks :D
[00:39:35] *** Joins: Houm (Houm@moz-25669AA8.fbx.proxad.net)
[00:40:27] *** Joins: lucian (lucian@moz-22A14C6A.cable.virginmedia.com)
[00:42:14] <doener> woah, trans_intrinsic IR shrank from 22k lines to 16k lines
[00:42:25] <aatch> doener, nice
[00:42:39] <doener> that's _way_ more than I expected
[00:43:25] *** mcpherrin is now known as mm
[00:43:33] *** mm is now known as mcpherrin
[00:43:35] <doener> hm, diff is pretty useless for a comparison
[00:44:18] *** Quits: MrFahrenheit (RageOfThou@3FEF494C.29C984D5.783DEDCA.IP) (Ping timeout)
[00:45:01] *** Quits: duckinator (nick@moz-74B346B5.mostlyincorrect.info) (Quit: Nickname collision due to Services enforced nickname change, your nick was overruled)
[00:45:32] *** Joins: dwrensha (chatzilla@moz-DE44EA45.hsd1.pa.comcast.net)
[00:49:05] *** Joins: wilsonk|2 (kvirc@moz-39EFBFC2.cg.shawcable.net)
[00:49:38] *** Quits: wilsonk-laptop (kvirc@moz-39EFBFC2.cg.shawcable.net) (Ping timeout)
[00:50:12] *** Quits: dwhyte (dwhyte@ED9190FB.B72E355F.7BF4A4B0.IP) (Client exited)
[00:51:29] *** Quits: smvv_ (sander@moz-BAEA8EB2.dynamic.upc.nl) (Ping timeout)
[00:52:15] *** Quits: cdidd (cdidd@moz-EC454021.broadband.corbina.ru) (Input/output error)
[00:52:39] *** Joins: duckinator (nick@moz-74B346B5.mostlyincorrect.info)
[00:52:55] *** Joins: int3_ (int3_@moz-ABE52D50.hsd1.ca.comcast.net)
[00:52:59] <Jeaye> doener: Hell, that's nice.
[00:56:17] <doener> Jeaye: mostly helps nopt though, because it's only eliminating pointless blocks/jumps. "Fortunately", nopt is currently the slowest of our builds
[00:56:27] *** Quits: lucian (lucian@moz-22A14C6A.cable.virginmedia.com) (Input/output error)
[00:56:43] <doener> well, it helps inlining, too, but not enough to help with rustc itself
[00:57:38] *** Joins: sp3d (a@moz-49806493.dhcp.stls.mo.charter.com)
[00:59:25] <engla> does it affect build time?
[00:59:46] <doener> engla: ~-1.5% with opt, ~-11% without opt
[01:00:50] <engla> ok still nice
[01:00:52] <doener> I'll benchmark the testsuite without opt over night
[01:01:15] <doener> if the 11% hold, that would be about 5 minutes 
[01:01:33] <aatch> heh, pattern-matching &@ref i
[01:01:45] <doener> o.O
[01:02:05] *** Quits: dwrensha (chatzilla@moz-DE44EA45.hsd1.pa.comcast.net) (Input/output error)
[01:02:06] <doener> you can ref into a box?
[01:02:10] <aatch> doener, it's a temporary measure to make my life easier later
[01:02:13] <doener> in patterns?
[01:02:15] <aatch> doener, yeah
[01:02:25] <doener> sweet, didn't know that
[01:02:36] <aatch> it's incredibly useful for getting stuff out of ~
[01:02:47] *** Quits: a__ (a__@moz-250D9B4.nycmny.fios.verizon.net) (Client exited)
[01:02:47] * aatch wishes it worked on ~str
[01:03:50] *** Joins: a__ (a__@moz-250D9B4.nycmny.fios.verizon.net)
[01:07:48] *** Joins: dwhyte (dwhyte@ED9190FB.B72E355F.7BF4A4B0.IP)
[01:08:25] *** Quits: tiffany (kawaii@moz-28A8742A.dhcp.embarqhsd.net) (Ping timeout)
[01:11:16] *** Quits: vk (vk@moz-389FEE13.hsd1.ca.comcast.net) (Quit: vk)
[01:12:23] *** Joins: erickt (erickt@moz-B83DBBF6.pixar.com)
[01:13:49] *** Joins: james4k (james@moz-E7990244.consolidated.net)
[01:17:05] *** Joins: cdidd (cdidd@moz-F3DF983E.broadband.corbina.ru)
[01:19:43] *** Quits: donri (dag@moz-9BB61102.tbcn.telia.com) (Client exited)
[01:24:51] *** Joins: tiffany (kawaii@moz-1E0FE6E8.dhcp.embarqhsd.net)
[01:27:20] *** Quits: jmgrosen (jmgrosen@moz-848F6087.sb.sd.cox.net) (Quit: jmgrosen)
[01:30:14] *** Quits: jfbk (user@moz-EEA9CFB3.nyc.res.rr.com) (Ping timeout)
[01:31:00] *** Joins: jfbk (user@moz-EEA9CFB3.nyc.res.rr.com)
[01:31:50] <mark_edward> aatch: can you take a look at this? i can't tell if it will merge or not
[01:35:35] <mark_edward> https://github.com/mozilla/rust/pull/7631
[01:38:21] *** Quits: wilsonk|2 (kvirc@moz-39EFBFC2.cg.shawcable.net) (Ping timeout)
[01:39:53] <h3r3tic> I'm getting 'unresolved name' error on uint::range after transitioning from 0.6 to 0.7. is there a module I need to import? I tried a few, but to no avail
[01:40:31] <strcat> std::uint
[01:40:40] <strcat> or qualify it all the way
[01:41:17] *** Quits: q66 (q66@6EE9DE40.46454B5D.33AABD5F.IP) (Quit: Leaving)
[01:41:19] <h3r3tic> ah, I had "use std::uint::*" rather than "use std::uint;". thanks!
[01:41:27] *** Quits: james4k (james@moz-E7990244.consolidated.net) (Ping timeout)
[01:42:51] *** Joins: vk (vk@moz-389FEE13.hsd1.ca.comcast.net)
[01:43:02] <mark_edward> strcat: can you tell if my PR can merge? 
[01:44:33] <dbaupp> mark_edward: yes
[01:45:12] <mark_edward> ok cool. i won't colossally screw things up this time
[01:45:15] <dbaupp> mark_edward: any particular reason you didn't just call `self.offset(rhs.to_int() as uint)`?
[01:45:37] <dbaupp> (and `.offset(-rhs.to_int() as uint)`)
[01:46:10] *** Joins: james4k (james@moz-E7990244.consolidated.net)
[01:46:23] <mark_edward> i felt that doing it this way made it more obvious what i was doing. easier to see any errors in my casting logic
[01:47:21] <dbaupp> right, but using the already-defined function means that there is less code duplication (no need to write it 3 times when it can be written once)
[01:48:21] *** Joins: reyre_ (reyre@moz-9002CDDA.cpe.net.cable.rogers.com)
[01:48:28] *** Quits: maxli (maxli@B5559308.9C54E60.2FA4EA88.IP) (Quit: Leaving.)
[01:48:44] *** Joins: maxli (maxli@B5559308.9C54E60.2FA4EA88.IP)
[01:48:48] <mark_edward> true. also i just realized i need to add variations for *const T and *mut T. can i unmake a PR request
[01:49:04] <doener> just close it
[01:49:29] <doener> but you might as well just add a comment that it's not ready yet and update it later
[01:50:26] *** Quits: maxli (maxli@B5559308.9C54E60.2FA4EA88.IP) (Ping timeout)
[01:50:47] <mark_edward> oops, already closed it
[01:50:56] <strcat> it can be reopened later
[01:51:01] <mark_edward> i did comment on the issue that i'm working on it though
[01:52:30] *** Quits: int3_ (int3_@moz-ABE52D50.hsd1.ca.comcast.net) (Client exited)
[01:54:21] *** Joins: int3_ (int3_@moz-ABE52D50.hsd1.ca.comcast.net)
[01:54:25] *** Quits: vk (vk@moz-389FEE13.hsd1.ca.comcast.net) (Quit: vk)
[01:54:34] *** Joins: vk (vk@moz-389FEE13.hsd1.ca.comcast.net)
[01:56:58] *** Quits: erickt (erickt@moz-B83DBBF6.pixar.com) (Quit: Leaving.)
[01:57:34] *** Quits: tiffany (kawaii@moz-1E0FE6E8.dhcp.embarqhsd.net) (Ping timeout)
[01:57:59] *** Quits: reyre_ (reyre@moz-9002CDDA.cpe.net.cable.rogers.com) (Client exited)
[01:59:09] *** Joins: jmgrosen (jmgrosen@moz-848F6087.sb.sd.cox.net)
[02:00:00] *** Quits: vk (vk@moz-389FEE13.hsd1.ca.comcast.net) (Quit: vk)
[02:00:52] *** Joins: bjz (brendanzab@B398BE78.F804C29E.D35A31DF.IP)
[02:03:59] <mark_edward> are *T and *const T the same type?
[02:04:12] <aatch> mark_edward, no
[02:04:15] <mark_edward> because they are giving me a conflicting implementation problem
[02:04:41] <aatch> mark_edward, hmm... try ignoring *const T for now
[02:04:45] <aatch> it's not used much
[02:04:59] <aatch> and you can always change it to *T without losing much
[02:05:13] <aatch> (especially if you're just doing arithmetic)
[02:05:14] <mark_edward> ok. I noticed the RawPtr trait wasn't implemented for it either
[02:05:23] <mark_edward> maybe theyy had the same problem
[02:06:48] *** Joins: lucian (lucian@moz-22A14C6A.cable.virginmedia.com)
[02:08:39] *** Quits: lucian (lucian@moz-22A14C6A.cable.virginmedia.com) (Ping timeout)
[02:08:46] *** Joins: alisdair (textual@moz-EBE9F394.bchsia.telus.net)
[02:08:59] *** Joins: pnathan (Adium@B9840254.2CD8A5F8.477B877D.IP)
[02:09:48] *** Quits: dforsyth (dforsyth@A677A619.1C765EF.EE6E63A5.IP) (Ping timeout)
[02:09:57] *** Quits: joelteon (joel@moz-317E8D0C.io) (Ping timeout)
[02:13:27] *** Joins: dforsyth (dforsyth@A677A619.1C765EF.EE6E63A5.IP)
[02:13:31] *** Joins: erickt (erickt@moz-B83DBBF6.pixar.com)
[02:13:51] *** Joins: reyre_ (reyre@moz-9002CDDA.cpe.net.cable.rogers.com)
[02:14:00] *** Quits: bjz (brendanzab@B398BE78.F804C29E.D35A31DF.IP) (Quit: Leaving...)
[02:15:09] *** Quits: pnathan (Adium@B9840254.2CD8A5F8.477B877D.IP) (Ping timeout)
[02:15:19] *** Joins: joelteon (joel@moz-317E8D0C.io)
[02:15:41] *** Quits: bytbox (s@moz-DC83764A.washdc.fios.verizon.net) (Ping timeout)
[02:17:35] *** Joins: bytbox (s@moz-DC83764A.washdc.fios.verizon.net)
[02:19:27] *** Quits: bytbox (s@moz-DC83764A.washdc.fios.verizon.net) (Ping timeout)
[02:19:55] *** Joins: vk (vk@moz-389FEE13.hsd1.ca.comcast.net)
[02:19:57] <strcat> doener: heh I think I found it
[02:20:18] *** Quits: vk (vk@moz-389FEE13.hsd1.ca.comcast.net) (Quit: vk)
[02:20:28] *** Joins: vk (vk@moz-389FEE13.hsd1.ca.comcast.net)
[02:20:30] <strcat> errr, or not
[02:23:41] <doener> heh, that's what the last week looked like when I tried to get the scope cleanup working. It's actually embarassing how trivial the actual bugs were :-/
[02:23:55] <doener> anyway, time to call it a day
[02:24:01] <strcat> \o
[02:24:54] *** Quits: int3_ (int3_@moz-ABE52D50.hsd1.ca.comcast.net) (Client exited)
[02:25:41] *** Joins: sankha93 (Instantbir@513CD6A2.E6798AF8.8B6C1D65.IP)
[02:27:48] *** Quits: joelteon (joel@moz-317E8D0C.io) (Ping timeout)
[02:28:55] *** Joins: dymk (dymk@44EEE21C.A6E21E6E.5E500FC7.IP)
[02:29:07] <dbaupp> rusti: Counter::new(~"foo", ~"bar").take_(3).collect::<~[~str]>()
[02:29:09] -rusti- more than 5 lines of output, pastebinned: http://sprunge.us/SAAN
[02:29:21] *** Joins: joelteon (joel@moz-317E8D0C.io)
[02:29:23] <dbaupp> rusti: std::iterator::Counter::new(~"foo", ~"bar").take_(3).collect::<~[~str]>()
[02:29:23] -rusti- <anon>:7:9: 7:62 error: failed to find an implementation of trait std::ops::Add<~str,~str> for ~str
[02:29:24] -rusti- <anon>:7          std::iterator::Counter::new(~"foo", ~"bar").take_(3).collect::<~[~str]>()
[02:29:24] -rusti-                   ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
[02:29:24] -rusti- application terminated with error code 101
[02:30:07] <strcat> dbaupp: it's only implemented for &str, ~str
[02:30:26] <dbaupp> rusti: std::iterator::Counter::new(~[], ~[1i]).take_(3).collect::<~[~[int]]>()
[02:30:27] -rusti- ~[~[], ~[1], ~[1, 1]]
[02:30:35] <dbaupp> strcat: yeah, I thought I'd fixed that. :/
[02:33:00] *** Joins: mye (mye@moz-DCE005F1.dip0.t-ipconnect.de)
[02:33:18] *** Quits: mye (mye@moz-DCE005F1.dip0.t-ipconnect.de) (Quit: mye)
[02:34:54] <sfackler> does there exist some rust equivalent of C-style bitvectors or Java EnumSet to represent a C-style enum?
[02:36:25] <engla> there is an EnumSet only inside librustc
[02:37:14] *** Quits: FrozenCow (FrozenCow@moz-B2DF4929.chello.nl) (Client exited)
[02:37:55] *** Quits: erickt (erickt@moz-B83DBBF6.pixar.com) (Quit: Leaving.)
[02:38:58] * dbaupp thinks it could be moved to extra
[02:39:31] <engla> the crucial part is how to map int -> enum variant
[02:39:53] <strcat> well you don't actually use enums for a set-like one
[02:41:07] *** kimundi is now known as zz_kimundi
[02:42:37] <strcat> you would need to define 2**(n_base_variants) of actual variants if you did that
[02:43:21] *** Quits: zz_kimundi (kimundi@moz-179808A0.dip0.t-ipconnect.de) (Ping timeout)
[02:43:52] <engla> I was looking at the EnumSet in librustc 
[02:43:59] <engla> and it's used together with an enum
[02:44:06] <engla> of course not in that way
[02:44:28] <strcat> it's just abusing an enum to declare constants though
[02:44:41] <strcat> what you really want is for the flags to have the same type as the flag type
[02:44:49] <strcat> and you can do it, but there's no sugar
[02:44:51] *** Quits: dwhyte (dwhyte@ED9190FB.B72E355F.7BF4A4B0.IP) (Quit: Leaving.)
[02:44:54] <engla> not sure if  that is abuse
[02:45:10] <strcat> it certainly makes things more painful for a user of it
[02:45:22] <strcat> FlagA | FlagB should work
[02:45:37] <Jeaye> rusti: let f = ~[1, 2, 3]; for f.iter().advance |x| { println(fmt!("%?", x)); }
[02:45:38] -rusti- &1
[02:45:38] -rusti- &2
[02:45:38] -rusti- &3
[02:45:38] -rusti- ()
[02:45:50] <Jeaye> How can I iteratebackward?
[02:45:58] <strcat> use the reverse iterator
[02:46:04] <engla> .rev_iter()
[02:46:13] <Jeaye> rusti: let f = ~[1, 2, 3]; for f.rev_iter().advance |x| { println(fmt!("%?", x)); }
[02:46:14] -rusti- &3
[02:46:14] -rusti- &2
[02:46:14] -rusti- &1
[02:46:15] -rusti- ()
[02:46:24] <Jeaye> Sexy
[02:46:36] *** Quits: vk (vk@moz-389FEE13.hsd1.ca.comcast.net) (Quit: vk)
[02:46:39] *** Joins: zz_kimundi (kimundi@moz-CF4108F.dip0.t-ipconnect.de)
[02:47:03] <Jeaye> rusti: let mut f = ~[1, 2, 3]; for f.rev_mut_iter().advance |x| { println(fmt!("%?", x)); }
[02:47:03] -rusti- <anon>:7:37: 7:54 error: type `~[<VI2>]` does not implement any method in scope named `rev_mut_iter`
[02:47:03] -rusti- <anon>:7          let mut f = ~[1, 2, 3]; for f.rev_mut_iter().advance |x| { println(fmt!("%?", x)); }
[02:47:04] -rusti-                                               ^~~~~~~~~~~~~~~~~
[02:47:04] -rusti- error: aborting due to previous error
[02:47:04] -rusti- application terminated with error code 101
[02:47:05] *** zz_kimundi is now known as kimundi
[02:47:11] <strcat> mut_rev ;p
[02:48:11] <Jeaye> rusti: let mut f = ~[1, 2, 3]; for f.mut_rev_iter().advance |x| { println(fmt!("%?", x)); }
[02:48:12] -rusti- &mut 3
[02:48:12] -rusti- &mut 2
[02:48:12] -rusti- &mut 1
[02:48:12] -rusti- ()
[02:48:17] <sfackler> strcat: FlagA | FlagB is convinient, but not really necessary.
[02:48:41] <strcat> it's easy to get it though
[02:48:48] <strcat> just define the constants as being of the type
[02:49:43] <strcat> static a: Flag = Flag{v: 0}; // no syntactic sugar for a whole bunch of these ;[
[02:54:58] *** Joins: erickt (erickt@moz-B83DBBF6.pixar.com)
[02:55:33] *** Joins: vk (vk@moz-389FEE13.hsd1.ca.comcast.net)
[02:55:40] *** Joins: ssbr (ssbr@moz-141F89C6.block0.gvtc.com)
[02:56:42] <sfackler> strcat: I think you should be able to get that sugar to work by implementing std::ops::bit{or,and,xor,etc} on the enum and the enumset appropriately
[02:57:14] <strcat> sfackler: well all you need is a struct with a priv field
[02:57:20] <strcat> and the constants are just instances of it
[02:57:29] *** Quits: ssbr (ssbr@moz-141F89C6.block0.gvtc.com) (Ping timeout)
[02:57:32] <strcat> macros can't generate multiple items yet
[02:57:37] <strcat> only reason we don't have one for this already
[02:57:44] <sfackler> ah
[02:58:14] *** Joins: ssbr (ssbr@moz-141F89C6.block0.gvtc.com)
[02:58:40] <strcat> sfackler: http://ix.io/6xr doing it manually is a pain ;p
[02:59:00] <strcat> and it should support the other bit ops
[02:59:26] <h3r3tic> yay, upgrade from 0.6 to 0.7 was relatively painless :D
[03:00:19] *** Joins: cowboyd (cowboyd@moz-DD0FF83.lightspeed.austtx.sbcglobal.net)
[03:00:43] <strcat> flag!(Name, FOO = 1, BAR = 2, BAZ = 3) *should* be able to do it
[03:00:50] * strcat hopes that'll be fixed soon
[03:03:15] <strcat> aatch: are you planning on doing another snap?
[03:03:29] <aatch> strcat, doing one now
[03:03:33] <strcat> ooo
[03:03:48] <aatch> actually, it's done for all the platforms except linux
[03:03:55] <aatch> which hasn't started...
[03:04:44] <sam113101> when will rust be stable?
[03:04:46] <aatch> bad luck that the only slave for util-snap-stage3 grabbed linux-64-opt-vg
[03:04:54] <aatch> sam113101, when it's stable
[03:05:13] <sam113101> aatch: but when will it be stable?
[03:05:15] <strcat> it is getting more stable
[03:05:20] <strcat> languages are never "finished"
[03:05:48] <aatch> sam113101, if you mean stable as in "won't break every other day" then probably a couple years yet.
[03:06:06] <sam113101> oh, really?
[03:06:15] <sfackler> strcat: this is what I'd ideally like http://pastebin.com/wdbc1yaJ but I guess you'd need some convert-value-to-index trait that basic enums would implement
[03:06:19] <aatch> sam113101, in context, that's actually not that far away
[03:06:31] <aatch> Rust has been under development for like 8-9 years now
[03:06:46] <sam113101> why does it take so long?
[03:06:58] <strcat> aatch: it hasn't been under serious development for that long
[03:07:55] <aatch> strcat, fair enough, and I'm probably being too conservative with my stability estimate
[03:07:59] <strcat> 0.1 was released at the start of 2012
[03:08:20] <strcat> being graydon's hobby project for a long time doesn't mean much
[03:08:27] <aatch> strcat, good point
[03:08:27] <strcat> it was a much different language anyway
[03:09:01] <aatch> sam113101, ok, I revise my estimate back to "I got no idea"
[03:09:04] <strcat> it'll probably be like 6 months before the language is mostly backwards compatible (as much as a language like python is today)
[03:09:12] <strcat> but... libraries? libraries are never stable ;p
[03:09:27] <sam113101> strcat: ok
[03:09:52] <aatch> strcat, yeah, I guess I look at the work to do and go "holy crap that will take a while"
[03:09:54] <strcat> and libraries will have to change as language features are completed/added (that doesn't really involve backwards compat)
[03:10:12] <strcat> aatch: the language isn't too far from something backwards compatible though
[03:10:27] <strcat> completing or adding a feature can be done post 1.0
[03:10:31] <aatch> strcat, true
[03:10:40] <strcat> the existing features should just be nearly finished/stable
[03:10:45] <strcat> and it's not far from that
[03:14:58] *** Joins: bjz (brendanzab@B398BE78.F804C29E.D35A31DF.IP)
[03:15:58] <strcat> hm
[03:16:02] <strcat> vector take glue
[03:19:23] *** Quits: cowboyd (cowboyd@moz-DD0FF83.lightspeed.austtx.sbcglobal.net) (Client exited)
[03:21:32] <mark_edward> cool, reopened PR. wish i could understand what happens with *const T though
[03:27:10] <sam113101> IÂ want to wait until 1.0 to start learing rust
[03:27:19] <aatch> sam113101, why?
[03:27:30] <dbaupp> mark_edward: r+ :)
[03:27:34] *** Joins: Yurume (yurume@AC58A8CE.8A059B47.E313B915.IP)
[03:27:40] <strcat> oh well I narrowed this down
[03:27:49] <strcat> I think malloc_raw_dyn returns the wrong type for vectors
[03:27:52] <sam113101> don't want my code to break all the time
[03:27:57] <strcat> it's the unique vector take glue failing to build
[03:28:10] <mark_edward> dbaupp: Cool! :)
[03:28:16] <bstrie> aatch: I already know rust, and I'm still waiting for it to settle down before doing anything with it :P
[03:28:17] <aatch> sam113101, it's not actually that bad. and it's happening less and less
[03:28:22] <mark_edward> wonder if i can find something more significant to do
[03:28:29] <strcat> ugh
[03:28:33] <strcat> no ~ headers within reach :(
[03:28:41] <sam113101> do you think rust will become more popular than C with time?
[03:28:48] * bstrie cheers strcat
[03:29:31] <bstrie> sam113101: I don't know if any language will ever be "more popular" than C, depending on how you measure it
[03:29:35] <aatch> sam113101, it's possible, but C has like 30 years on us
[03:29:43] <aatch> do maybe in like 50-60 years?
[03:30:12] <bstrie> aatch: by that point we won't even be programming any more
[03:30:15] <strcat> aatch: http://ix.io/6xs
[03:30:17] <bstrie> machines can do that for us
[03:30:19] <strcat> that's where it dies atm
[03:30:21] <strcat> ;[
[03:30:22] <SiegeLord> Better beat all the C++ alternatives first ;)
[03:30:28] * strcat is a bit clueless on how to debug it
[03:30:36] <dbaupp> strcat: I don't understand why you can't use a macro for the MAGIC constants?
[03:30:39] <strcat> I guess if I print out the ty::t I'll have a bit of an idea
[03:30:40] <aatch> strcat, what does it say?
[03:30:46] <strcat> dbaupp: because it can't generate multiple items yet
[03:30:50] <strcat> aatch: well it's an invalid store
[03:30:57] <strcat> aatch: the types don't match
[03:31:08] <strcat> but I don't really know how to print out a type for ValueRef
[03:31:17] <dbaupp> strcat: oh, right, just wrap it in a mod? mod constants { ... }
[03:31:27] <strcat> dbaupp: makes it annoying though
[03:31:34] <aatch> strcat, oo, I can help with that.
[03:31:37] <aatch> 2 seconds
[03:31:46] <dbaupp> strcat: and then `pub use self::constants::*;` at the top of the file.
[03:32:11] *** Joins: ghrust (ghrust@AC22872E.6A2AE50.F3114085.IP)
[03:32:11] <ghrust> 01[13rust01] 15bors 04force-pushed 06auto from 1439e9b77 to 14a9f178c: 02http://git.io/N3iJvQ
[03:32:11] *** Parts: ghrust (ghrust@AC22872E.6A2AE50.F3114085.IP) ()
[03:32:13] *** Joins: ghrust (ghrust@C621748.6A2AE50.F3114085.IP)
[03:32:13] <ghrust> 01[13rust01] 15bors pushed 3 new commits to 06auto: 02http://git.io/xq8OQA
[03:32:13] <ghrust> 13rust/06auto 14656c8f9 15Gareth Smith: Make the error messages that result from referencing...
[03:32:13] <ghrust> 13rust/06auto 14908a22b 15Gareth Smith: Address @catamorphism's error message grammar nit.
[03:32:13] <ghrust> 13rust/06auto 14d243e00 15bors: auto merge of #7572 : Dretch/rust/missing-trait-message-followup, r=pcwalton...
[03:32:14] <aatch> strcat, ok, so cx.tn.val_to_str(val)
[03:32:15] *** Parts: ghrust (ghrust@C621748.6A2AE50.F3114085.IP) ()
[03:32:20] <strcat> ah
[03:32:23] <strcat> thanks
[03:32:24] <aatch> grr, that's just a timeout
[03:32:44] <sam113101> did you guys settle on which types of pointers to keep, how to name them, etc.?
[03:32:47] <strcat> aatch: cx is a block context?
[03:32:56] <aatch> strcat, oh no, the crate context
[03:33:05] <aatch> so bcx.ctx().tn...
[03:33:10] <strcat> ah
[03:33:23] <aatch> strcat, I know...
[03:33:25] <strcat> alright we'll see what happens
[03:33:43] <strcat> /home/strcat/projects/rust/src/librustc/middle/trans/glue.rs:587:43: 587:53 error: type `@mut middle::trans::common::block_` does not implement any method in scope named `ctx`
[03:33:45] <strcat> ;[
[03:33:55] <dbaupp> sam113101: no pointers will be removed, just the syntactic sugar for some of them might be removed (specifically, @)
[03:34:06] <dbaupp> sam113101: and no, naming isn't stable yet.
[03:34:11] <sam113101> ok
[03:34:21] <strcat> naming isn't a language change though
[03:34:36] <aatch> strcat, it's ccx() sorry
[03:34:38] <strcat> ah
[03:34:39] <sam113101> well you guys have convinced me to read into rustâ€¦ it will be my first compiled language
[03:34:57] <aatch> sam113101, and feel free to ask questions here
[03:35:12] <aatch> we are well aware that the state of the documentation is poor
[03:35:21] <sam113101> ok, thanks
[03:35:46] <strcat> aatch: no tn_to_str :(
[03:35:59] <strcat> do I need the type context?
[03:36:26] <strcat> ah it's not a method
[03:36:28] <aatch> strcat, no. its `bcx.ccx().tn.val_to_str(val)`
[03:36:32] <strcat> ohh
[03:36:49] <strcat> what is 'tn'?
[03:37:03] <strcat> trans is weird
[03:37:08] <aatch> strcat, actually, nevermind, there's an equivalent on the block context
[03:37:16] <aatch> bcx.val_to_str(val)
[03:37:23] <strcat> it must have been written in a time of great vowel shortage
[03:37:43] <aatch> strcat, and for the record, tn is "TypeNames"
[03:37:54] <strcat> if only it was called type_names
[03:38:17] *** Quits: dforsyth (dforsyth@A677A619.1C765EF.EE6E63A5.IP) (Ping timeout)
[03:38:40] <aatch> strcat, hey, could be worse, before I got at it there weren't even methods on the TypeName struct
[03:39:03] <strcat> if only it compiled faster
[03:39:13] * strcat wants to get past this silly assert and onto the runtime memory corruption
[03:39:40] <strcat> if ~Trait isn't broken I'll be disappointed ;p
[03:39:48] *** Quits: joelteon (joel@moz-317E8D0C.io) (Ping timeout)
[03:40:16] <strcat> lol
[03:40:20] <strcat> fmt! on a ty::t is useless
[03:40:27] <aatch> strcat, yep
[03:40:29] <strcat> ty_to_str is what I need I guess
[03:40:35] <strcat> vec uniq store: 140190879442768
[03:40:37] <strcat> vec uniq store: ~"*{i64, *tydesc, *i8, *i8, {i64, i64, [{i64, i64, [*{} x 0]} x 0]}}"
[03:40:39] <strcat> rustc: /home/strcat/projects/rust/src/llvm/lib/IR/Instructions.cpp:1084: void llvm::StoreInst::AssertOK(): Assertion `getOperand(0)->getType() == cast<PointerType>(getOperand(1)->getType())->getElementType() && "Ptr must be a pointer to Val type!"' failed.
[03:40:52] <strcat> so the val is the correct type afaict
[03:40:57] <strcat> I think the ty::t is wrong
[03:41:38] <aatch> strcat, yep, bcx.ty_to_str() is what you want
[03:41:56] *** Quits: Earnestly (earnest@2A2BF8F5.321FA5E6.BFD1ABFD.IP) (Ping timeout)
[03:42:04] *** Quits: heftig (heftig@moz-D52CF73C.dip0.t-ipconnect.de) (Ping timeout)
[03:42:44] *** Joins: dforsyth (dforsyth@A677A619.1C765EF.EE6E63A5.IP)
[03:42:54] * strcat wonders what he's doing wron
[03:42:57] <strcat> g
[03:43:09] <strcat> about to find out..
[03:43:27] *** Joins: int3_ (int3_@moz-ABE52D50.hsd1.ca.comcast.net)
[03:43:30] *** Joins: joelteon (joel@moz-317E8D0C.io)
[03:45:05] *** Joins: dwhyte (dwhyte@ED9190FB.B72E355F.7BF4A4B0.IP)
[03:46:09] <strcat> and.... error
[03:46:15] <strcat> vec uniq store: ~"~[*libc::types::common::c95::c_void]"
[03:46:17] <strcat> value: ~"*{i64, *tydesc, *i8, *i8, {i64, i64, [{i64, i64, [*{} x 0]} x 0]}}"
[03:46:19] <strcat> pointer: ~"**{i64, *tydesc, *i8, *i8, {i64, i64, [*{} x 0]}}"
[03:46:28] <strcat> ok
[03:46:31] <strcat> I know what's wrong
[03:47:10] *** Quits: KindOne (KindOne@moz-A3E70241.dynamic.ip.windstream.net) (Ping timeout)
[03:47:17] <strcat> aatch: any idea how to go from vec body type to vec element type?
[03:47:30] <strcat> hm
[03:47:36] <strcat> ty_unboxed_vec I guess it is
[03:47:37] <aatch> strcat, what do you mean, in LLVM?
[03:47:42] <strcat> no rust types
[03:47:49] <strcat> I guess I can just extract it
[03:48:07] <strcat> ah it's just one of these stupid "mutable types"
[03:48:51] *** Quits: int3_ (int3_@moz-ABE52D50.hsd1.ca.comcast.net) (Client exited)
[03:50:30] <strcat> aatch: such a silly error
[03:50:51] <aatch> strcat, heh, always it
[03:50:53] <aatch> is*
[03:51:27] *** Joins: KindOne (KindOne@moz-7505E461.dynamic.ip.windstream.net)
[03:51:42] *** Joins: heftig (heftig@moz-72EDF21D.dip0.t-ipconnect.de)
[03:52:23] *** Joins: ross (ross@moz-8A84103E.br.br.cox.net)
[03:54:13] <sfackler> if I have an enum like enum Foo { Bar = 10 }
[03:54:27] <sfackler> is there any way to go from the integer 10 to Bar?
[03:54:47] <strcat> not in safe code
[03:54:51] <sfackler> without iterating over every thing of type Foo
[03:54:51] <strcat> it's not what enums are meant for
[03:54:53] <sfackler> unsafe is fine
[03:54:59] <sfackler> this is for an ffi interface
[03:55:17] <strcat> yeah but it's really unlikely you want an enum for that ;p
[03:55:37] <strcat> sfackler: you can transmute... if it's guarantee to be one of the variants you listed
[03:55:44] <strcat> it can't be one that's not listed or it's undefined
[03:55:51] <strcat> guaranteed*
[03:55:57] <sfackler> hmm
[03:56:11] <strcat> if you list { Bar = 1, Baz = 2 } in the enum, you definitely can't then store 3 in it
[03:56:16] <sfackler> right
[03:56:32] <strcat> cast::transmute will let you arbitrary cast between types though
[03:56:48] <sp3d> rusti: enum Foo {Bar = 10}; unsafe{std::cast::transmute::<int,Foo>(10)}
[03:56:49] -rusti- Bar
[03:56:50] <sfackler> so what would the rusty way of handling the return of http://jcatki.no-ip.org:8080/SDL_ttf/SDL_ttf.html#SEC25 then?
[03:57:20] <strcat> sfackler: oh an enum is fine for that, if it's just a set of things
[03:57:32] *** Joins: pnathan (Adium@moz-E3C3FAF2.hfc.comcastbusiness.net)
[03:57:33] <sfackler> yeah
[03:57:44] *** Quits: alisdair (textual@moz-EBE9F394.bchsia.telus.net) (Quit: My MacBook Pro has gone to sleep. ZZZzzzâ€¦)
[03:58:18] <sfackler> are enums like Foo guaranteed to be represented as an int?
[03:58:55] <engla> no
[03:59:14] <aatch> engla, actually, I think C-style ones are.
[03:59:26] <strcat> C-style ones are guaranteed to be represented as the type of integer you use
[03:59:27] <engla> that was the plan
[03:59:32] <strcat> just keep in mind that rust int isn't C's int
[04:00:20] <strcat> aatch: oh well another attempt
[04:00:28] *** Joins: alisdair (textual@moz-EBE9F394.bchsia.telus.net)
[04:00:32] <strcat> my intuition tells me I'll hit another issue now
[04:00:35] <strcat> ;p
[04:01:15] <ross> how easy is it to pull changes from forks into my local repo? (changes in open pull requests)
[04:01:34] <ross> do I just specify the remote to use when pulling
[04:01:38] <aatch> ross, yep
[04:02:02] <strcat> YAY
[04:02:03] <strcat> a new problem
[04:02:57] <strcat> YAYrustc: /home/strcat/projects/rust/src/llvm/lib/IR/Instructions.cpp:1084: void llvm::StoreInst::AssertOK(): Assertion `getOperand(0)->getType() == cast<PointerType>(getOperand(1)->getType())->getElementType() && "Ptr must be a pointer to Val type!"' failed.
[04:03:00] <strcat> ;p
[04:03:04] * strcat sighs
[04:03:18] <strcat> oh fun, another take glue crash!
[04:04:30] * strcat moves the debugging code to the ~T branch
[04:04:39] <strcat> so much pain
[04:06:43] <aatch> strcat, feel the burn!
[04:07:19] *** Quits: jfbk (user@moz-EEA9CFB3.nyc.res.rr.com) (Ping timeout)
[04:07:58] <strcat> value: ~"**{{i64}, {{{i64}, *{}, *{}}, {i64, [i8 x 56]}}}"
[04:08:00] <strcat> pointer: ~"**{{i64}, {{{i64}, *{}, *{}}, {i64, [i8 x 56]}}}"
[04:08:05] <strcat> rustc: /home/strcat/projects/rust/src/llvm/lib/IR/Instructions.cpp:1084: void llvm::StoreInst::AssertOK(): Assertion `getOperand(0)->getType() == cast<PointerType>(getOperand(1)->getType())->getElementType() && "Ptr must be a pointer to Val type!"' failed.
[04:08:10] <strcat> hm
[04:08:12] <strcat> what the hell
[04:08:31] *** Quits: jmgrosen (jmgrosen@moz-848F6087.sb.sd.cox.net) (Quit: jmgrosen)
[04:08:37] <strcat> am I missing something? ;p
[04:09:01] *** Quits: pnathan (Adium@moz-E3C3FAF2.hfc.comcastbusiness.net) (Ping timeout)
[04:09:07] <strcat>         println(fmt!("value: %?", bcx.ccx().tn.val_to_str(val)));
[04:09:09] <strcat>         println(fmt!("pointer: %?", bcx.ccx().tn.val_to_str(v)));
[04:09:11] <strcat>         Store(bcx, val, v);
[04:09:13] <strcat> how are those not the same?
[04:09:21] <Luqman> they shouldn't be the same
[04:09:23] <aatch> strcat, they /shouldn't/ be the same
[04:09:27] <strcat> ah
[04:09:29] <strcat> I see ;p
[04:09:33] <aatch> one should be a T, the other a *T
[04:09:38] <strcat> the value has an extra ptr
[04:09:42] <aatch> since you are storing a value to a location
[04:09:44] <strcat> uniq store: ~"~pipes::Buffer<pipes::Packet<comm::pipesy::streamp::Open<task::TaskResult>>>"
[04:09:55] * strcat ponders
[04:10:16] * strcat tries removing a random ptr_to
[04:10:40] <aatch> I did that once, it worked
[04:10:51] <strcat> hm
[04:12:12] <Luqman> it could be that the value is getting passed ByRef
[04:12:21] <roo> i get that, when i do this
[04:12:33] <roo> rusti: let &ref a = &1; a
[04:12:34] -rusti- line longer than 150 columns, pastebinned: http://sprunge.us/UjZd
[04:12:37] <dbaupp> aatch: do you happen to remember if https://github.com/mozilla/rust/pull/6778 is the one where you made rustc really slow?
[04:12:49] <strcat> Luqman: https://github.com/mozilla/rust/pull/7605/files well... see anything obvious? ;p
[04:12:57] <aatch> dbaupp, I think so
[04:13:00] <strcat> err
[04:13:03] <strcat> Luqman: https://github.com/thestinger/rust/commit/905ba96481cc1b7b3d299cd8885ac23aa0bc4ff7 just this commit
[04:13:25] <strcat> oh
[04:13:26] <strcat>  +        rslt(bcx, PointerCast(bcx, Load(bcx, rval), llty_value.ptr_to())) 
[04:13:34] <strcat> maybe that
[04:13:48] <strcat> does PointerCast take the ptr type or the value type?
[04:14:00] <dbaupp> aatch: ok, cool, explains the spike on IRSY :)
[04:14:31] <aatch> dbaupp, heh
[04:15:06] <strcat> I'll narrow it down a bit by checking if this is unique or managed-unique....
[04:15:22] *** Quits: engla (engla@moz-DBD1D96E.cust.bredbandsbolaget.se) (Ping timeout)
[04:18:20] *** Quits: sankha93 (Instantbir@513CD6A2.E6798AF8.8B6C1D65.IP) (Quit: Instantbird 1.4 -- http://www.instantbird.com)
[04:19:25] <Luqman> strcat: i don't see anything glaringly obvious but i make no claims as to knowing rustc well enough
[04:19:40] <strcat> errmanaged: false
[04:19:52] <strcat> well
[04:20:02] <strcat> at least I know the code path to check ;p
[04:20:38] <strcat> I don't really see where the issue is
[04:21:13] *** sam113101 is now known as testttttttttttttt
[04:21:16] <Luqman> where is that Store?
[04:21:22] *** Quits: glinscott (garylinsco@789A6618.53EB7C1.FFFE3AA.IP) (Quit: glinscott)
[04:21:24] <strcat> Luqman: take glue, but the problem is in malloc_raw_dyn
[04:21:36] <strcat> I think maybe the ty::t passed to malloc_raw_dyn is actually a pointer...
[04:22:04] <strcat> no, can't be
[04:22:06] *** Joins: glinscott (garylinsco@789A6618.53EB7C1.FFFE3AA.IP)
[04:22:27] <strcat> (at least I'm 95% sure it's in malloc_raw_dyn, in the heap_exchange code path)
[04:23:37] <strcat> or my type_of could be wrong but I really doubt it
[04:25:46] <strcat> or uniq::duplicate could be wrong...
[04:28:20] <Luqman> does your branch also modify trans::Type::unique to not just call Type::box which has the box header fields?
[04:28:56] <strcat> Luqman: no, Type::unique is only for managed-unique now
[04:29:06] <strcat> but I fixed the type_of and I don't *think* Type::unique is called elsewhere
[04:29:08] <strcat> might be wrong
[04:29:12] <sfackler> what's the best way to convert from a null terminated *c_char to a ~str?
[04:30:07] <strcat>           if ty::type_contents(cx.tcx, mt.ty).contains_managed() {
[04:30:09] <strcat>               Type::unique(cx, &ty).ptr_to()
[04:30:11] <strcat>           } else {
[04:30:13] *** Quits: alisdair (textual@moz-EBE9F394.bchsia.telus.net) (Quit: My MacBook Pro has gone to sleep. ZZZzzzâ€¦)
[04:30:13] <strcat>               ty.ptr_to()
[04:30:15] <strcat>           }
[04:30:25] <strcat> Type::unique is also still abused for vectors since I'm not removing headers from them.
[04:30:31] <strcat> Luqman: the issue is a double ptr though
[04:30:37] <strcat> so I think it must be something I did wrong
[04:30:39] <strcat> not something I missed
[04:31:38] <strcat> I think by box_body is wrong
[04:31:40] <strcat> sec
[04:31:53] <sfackler> ah, nvm
[04:33:42] <Luqman> strcat: so in malloc_raw_dyn, if t is ~T then as long as it doesn't contain any @ it'll hit the heap == heap_exchange branch right?
[04:34:09] <strcat> Luqman: yes
[04:35:07] <Luqman> so then can't won't the type_of::type_of() call hit the ty_uniq case?
[04:35:51] *** Parts: jared (jared@moz-EE5D17ED.ph.ph.cox.net) (WeeChat 0.3.8)
[04:35:58] *** Joins: vilonis (jared@moz-EE5D17ED.ph.ph.cox.net)
[04:35:58] <strcat> Luqman: yeah but I updated ty_uniq
[04:36:11] <strcat> in type_of
[04:36:18] <strcat>           if ty::type_contents(cx.tcx, mt.ty).contains_managed() {
[04:36:20] <strcat>               Type::unique(cx, &ty).ptr_to()
[04:36:22] <strcat>           } else {
[04:36:24] <strcat>               ty.ptr_to()
[04:36:26] <strcat>           }
[04:36:28] <strcat> it's possible it makes a double ptr
[04:36:41] <strcat> but I don't think so.
[04:36:43] <glinscott> ok, beginner question, but can I use the generic iterator<char> to refer to the string iterator?  for example - let b : ~std::iterator::Iterator<char> = "abc".iter();
[04:36:44] <strcat> mt.ty is the contained type
[04:37:05] <Luqman> ah, i'm looking at the wrong revision here :P
[04:37:17] <strcat> glinscott: you probably don't want to use trait objects, what's the use case?
[04:37:32] <glinscott> i want to store an iterator in a struct
[04:38:15] <strcat> glinscott: you'll want to use the actual type
[04:38:23] *** Joins: pnathan (Adium@B9840254.2CD8A5F8.477B877D.IP)
[04:38:25] <roo> .iter() returns a VecIterator i think. so it would be std::vec::VecIterator<char>
[04:38:31] <glinscott> strcat: ah, ok.  so, then second question :)
[04:38:32] *** Quits: erickt (erickt@moz-B83DBBF6.pixar.com) (Quit: Leaving.)
[04:38:52] <glinscott> how do i declare this type correctly?  std::str::StrCharIterator<>
[04:39:30] <strcat> glinscott: 'self as the parameter?
[04:39:33] <vilonis> how do I create a local Result that contains a mutable type?
[04:39:33] <strcat> not sure if it will work
[04:39:53] <strcat> rusti: Ok(5)
[04:39:54] -rusti- more than 5 lines of output, pastebinned: http://sprunge.us/gVZF
[04:39:59] <glinscott> strcat: oops, internal compiler error :)
[04:40:00] <strcat> rusti: Ok(5i)
[04:40:01] -rusti- more than 5 lines of output, pastebinned: http://sprunge.us/CcUO
[04:40:22] *** Quits: SiegeLord (sl@moz-CAF07B4C.hsd1.ma.comcast.net) (Quit: Leaving)
[04:40:24] <strcat> oh it's just mad because the error type isn't inferred
[04:40:41] *** Joins: alisdair (textual@moz-EBE9F394.bchsia.telus.net)
[04:40:43] <strcat> glinscott: well, I'd just use a generic type param on the struct
[04:40:48] <strcat> struct Foo<T> { iter: T }
[04:41:03] <strcat> the string iterator will have a different type depending on the lifetime
[04:41:13] <strcat> so by using a generic type you can just let the compiler deal with it
[04:41:22] <glinscott> strcat: ok, thanks for the help!  i'll fiddle around some more
[04:41:32] *** Quits: reyre_ (reyre@moz-9002CDDA.cpe.net.cable.rogers.com) (Client exited)
[04:44:38] *** Quits: pnathan (Adium@B9840254.2CD8A5F8.477B877D.IP) (Ping timeout)
[04:51:46] *** Quits: cubic (cubic@moz-FE5AD6C7.mc.videotron.ca) (Quit: Leaving)
[04:52:12] <strcat> Luqman: oh or maybe I'm missing a ptr_to...
[04:52:20] <strcat> na
[04:52:22] <strcat> nah*
[04:52:30] <vilonis> Hey guys, just started learning Rust and I am following the SDL tutorial and am a little stuck...
[04:52:44] <ross> using rust-sdl?
[04:52:48] <vilonis> yeah
[04:53:11] <ross> if you have the latest version of rust-sdl and a recent version of rust (past few weeks), then you will get build errors
[04:53:26] <vilonis> I merged in a pull request that fixed them
[04:53:29] <ross> oh ok
[04:53:33] <strcat> Luqman: error in free glue this time :(
[04:53:37] <strcat> same thing
[04:53:50] <Luqman> strcat: after adding the ptr_to ?
[04:54:26] <vilonis> I have a struct `Engine` that I want to be mutable, and a constructor that returns a Result, how do I "unpack" the result if it is Ok such that I can pass the new Engine to a mutable method?
[04:56:45] <aatch> Sigh, I have to use transmute_region
[04:56:54] <aatch> but the alternative is a new visitor
[04:57:25] <ross> vilonis I'm new to rust myself, but I think you can just match on Result. or is your question more about the mutability
[04:57:54] <Luqman> rusti: struct Engine; fn new_engine() -> Result<Engine, ~str> { Ok(Engine) } fn start_engine(_x: &mut Engine) { println("Starting engine"); } let x = new_engine(); match x { Ok(ref mut e) => start_engine(e), _ => {} }
[04:57:55] -rusti- line longer than 150 columns, pastebinned: http://sprunge.us/cYPG
[04:58:20] <glinscott> strcat: ok, adding a <T> didn't quite work (i think).  when doing the imll of the struct, it seems i have to specify the type
[04:58:43] <glinscott> trying just this basic struct: struct Foo { priv iter: std::str::StrCharIterator<> }, fails with "error: Illegal anonymous lifetime: anonymous lifetimes are not permitted here"
[04:59:46] <vilonis> Luqman: `ref mut engine` seemed to work, now I am just getting link errors, woohoo progress!
[05:00:03] *** Joins: mark_edward_mobile (AndChat437@moz-807A30B9.dynamic.utc.edu)
[05:00:29] <roo> rusti: struct Foo<'self> { priv iter: std::str::StrCharIterator<'self> }
[05:00:30] -rusti- ()
[05:01:43] <glinscott> roo: ah, that seems to work!  thanks!  i'll have to read up on <'self>
[05:02:37] <roo> I still don't really understand what 'self is, but yeah, it compiles :P
[05:04:47] <strcat> roo: it's not actually special
[05:05:02] <strcat> it's just that the compiler has a rule only allowing 'self or 'static as type parameters
[05:06:34] *** Quits: dymk (dymk@44EEE21C.A6E21E6E.5E500FC7.IP) (Quit: Leaving)
[05:08:14] <roo> well, my understanding of explicit lifetimes it that it relates the lifetimes of otherwise independent things. I do not understand what association is being made in struct Foo<'self> { baz: Bar<'self> }.
[05:08:19] <roo> is*
[05:08:59] <aatch> roo, lifetimes are an assertion that a 'lives' as long as b
[05:09:43] <roo> so what are a and b here? Doesn't a struct always live as long as its parts?
[05:09:59] <aatch> roo, a and b are just "things"
[05:10:04] <aatch> roo, and yes
[05:10:39] <roo> right, i get that, but in this example, what are those 'things'. 
[05:10:45] <aatch> but if those parts contain borrowed pointers, then it won't be _valid_ for as long as it might be
[05:11:05] <roo> i see
[05:11:14] <aatch> roo, ok, so if I have a string, `let a : ~str = foo`, then I can slice it.
[05:11:15] *** Joins: ghrust (ghrust@C8693FCB.6A2AE50.F3114085.IP)
[05:11:16] <ghrust> 01[13rust01] 15bors merged 06auto into 06master: 02http://git.io/xq8OQA
[05:11:16] *** Parts: ghrust (ghrust@C8693FCB.6A2AE50.F3114085.IP) ()
[05:11:37] <aatch> `let slice : &str = a.as_slice()`
[05:12:14] <aatch> but `slice` doesn't own the memory
[05:12:36] <aatch> so if `a` dies, `slice` will be pointing to invalid memory
[05:13:15] *** Quits: Nisstyre (wes@moz-FD86289.netflash.net) (Quit: Leaving)
[05:13:23] <aatch> now, in order to make this useful, you sometimes need to return references into objects
[05:13:33] <aatch> I actually have a really good example in a gist
[05:13:35] <aatch> one sec
[05:13:39] <sfackler> is there any way to disable a warning with rustc? I'm calling into a C function that takes out-params but rustc is complaining about the variables being tagged as mut
[05:13:48] <roo> ok, so StrCharIterator, by containing borrows, has to expose livetime information
[05:13:57] <roo> lifetime*
[05:14:10] *** Joins: ghrust (ghrust@E7A4CCE2.6A2AE50.F3114085.IP)
[05:14:10] <ghrust> 01[13rust01] 15bors pushed 0 new commits to 06auto: 02http://git.io/QTFHkQ
[05:14:10] *** Parts: ghrust (ghrust@E7A4CCE2.6A2AE50.F3114085.IP) ()
[05:14:19] <aatch> roo https://gist.github.com/Aatch/5734372
[05:15:01] <aatch> sfackler, it should stop complaining if you make the out-params *mut
[05:17:03] <sfackler> aatch: thanks!
[05:17:09] *** Joins: ghrust (ghrust@E7A4CCE2.6A2AE50.F3114085.IP)
[05:17:09] <ghrust> 01[13rust01] 15bors pushed 0 new commits to 06auto: 02http://git.io/QTFHkQ
[05:17:09] *** Parts: ghrust (ghrust@E7A4CCE2.6A2AE50.F3114085.IP) ()
[05:17:10] *** Joins: ghrust (ghrust@2EE61FCC.6A2AE50.F3114085.IP)
[05:17:10] <ghrust> 01[13rust01] 15bors pushed 2 new commits to 06auto: 02http://git.io/zTvFFg
[05:17:10] <ghrust> 13rust/06auto 14e80dcf7 15Alex Crichton: Use #[allow(warnings)] in rusti instead of explicitly listing warnings
[05:17:10] <ghrust> 13rust/06auto 14b168252 15bors: auto merge of #7581 : alexcrichton/rust/better-rusti, r=pcwalton...
[05:17:11] *** Parts: ghrust (ghrust@2EE61FCC.6A2AE50.F3114085.IP) ()
[05:18:06] <roo> well i get it for functions, because both parts of the constraint are visible, its always something like fn foo<'a>(&'a str) -> &'a char; which esentially says that 'the &char is borrowed from the &str' (or depends on it existing somehow). the struct thing was kind of screwing me up because I wasn't seeing both parts of the constraint. I think i get it now though :)
[05:19:12] <roo> (and the silly 'self thing)
[05:22:02] <glinscott> ok, i was able to get that to compile in main.rs, however, in another file it gives an error - very strange: https://gist.github.com/glinscott/5942408
[05:25:11] <roo> aatch: is it correct to assume any concrete type that takes a lifetime as a static/generic argument, contains borrows?
[05:25:40] <strcat> glinscott: you need 'use std;' in the non-top-level crate
[05:25:41] <aatch> roo, kinda, it has a bounded lifetime
[05:25:42] <strcat> don't know why
[05:25:46] <strcat> think it's a bug
[05:26:07] <aatch> it /might/ not contain any borrowed pointers.
[05:26:33] *** Quits: mark_edward_mobile (AndChat437@moz-807A30B9.dynamic.utc.edu) (Quit: Bye)
[05:26:50] <glinscott> strcat: ah, thanks!
[05:28:22] *** Joins: jmgrosen (jmgrosen@moz-848F6087.sb.sd.cox.net)
[05:29:45] <Luqman> strcat: do you have a small test to reproduce the assert without having to compile libstd?
[05:30:20] <strcat> Luqman: I can't get the stage1 compiler to actually work independently atm
[05:30:27] <strcat> not sure what I'm doing wrong
[05:30:32] <strcat> it's missing a lang item (opaque)
[05:31:30] <Eridius> hrm, I keep finding myself wanting to have arithmetic that sticks to the bounds instead of modulo arithmetic (I forget what this is called). I wish there was a trivial way of doing that
[05:32:01] <mcpherrin> saturating arith
[05:32:10] <Eridius> yes, that's it, thanks
[05:34:17] *** Joins: ChrisMorgan (chris@moz-6AC741CA.static.tpgi.com.au)
[05:37:10] *** Joins: echristo (echristo@moz-1892C634.hsd1.ca.comcast.net)
[05:37:40] *** Quits: Axord (xord@moz-C3CCF156.lsanca.dsl-w.verizon.net) (Quit: I'm sure it's perfectly safe)
[05:37:45] *** Joins: Axord (xord@moz-C3CCF156.lsanca.dsl-w.verizon.net)
[05:40:12] *** Quits: alisdair (textual@moz-EBE9F394.bchsia.telus.net) (Quit: My MacBook Pro has gone to sleep. ZZZzzzâ€¦)
[05:41:17] <roo> aatch: ok, so it may not contain borrows, but over all, it represents something borrowed, right? in the StrCharIterator example, you might say that you don't really get to take ownership of the iterator.
[05:41:44] <strcat> you own the iterator, the iterator doesn't own what it references
[05:41:49] <aatch> roo, you do own the iterator, you just have a bound on how long it lives for
[05:41:59] <aatch> (in this case, the life of the string)
[05:43:54] *** Joins: Yurumechan (23f9939a@B2F514.E4420F21.EEF52F3A.IP)
[05:48:25] <strcat> Luqman: ok my box_body seems to be wrong
[05:48:28] <strcat> lets see
[05:48:51] <strcat> yeah box_body is supposed to deref
[05:48:54] <strcat> it wasn't >.,
[05:48:55] <strcat> >.< *
[05:51:43] <Luqman> that would explain why uniq::duplicate was giving back something with an extra pointer
[05:52:11] *** Quits: vilonis (jared@moz-EE5D17ED.ph.ph.cox.net) (Quit: WeeChat 0.3.8)
[05:52:13] <strcat> how do I just deref a ptr?
[05:52:18] <strcat> GEPi with [0, 0] isn't working
[05:52:32] <strcat> aatch: 
[05:52:33] <aatch> strcat, Load
[05:52:53] <strcat> heh
[05:53:02] * strcat should have known that
[05:53:36] <strcat> it's always the little mistakes like this
[05:53:37] * strcat sighs
[05:53:44] <strcat> box_ptr was a no-op
[05:53:46] <strcat> ;p
[05:53:48] <strcat> er, box_body
[05:56:29] <strcat> ughhhh
[05:57:09] <strcat> now it's mad that something isn't a ptr
[05:57:11] <strcat> ;p
[05:59:14] *** Joins: gour (gour@moz-F18C6C0D.adsl.net.t-com.hr)
[06:01:49] * strcat throws in a cast :(
[06:02:40] <gour> morning all
[06:03:18] <gour> is rustdoc going to continue using markdown as documeantation markup?
[06:03:26] <strcat> likely
[06:03:40] <aatch> gour, cmr is who you'd want to ask though
[06:04:07] <gour> aatch: yeah, i saw he's working on rustdoc-ng
[06:04:33] <gour> however, i must say i like the choice of md...
[06:05:11] <gour> ...especially pandoc's flavour :-)
[06:05:47] <strcat> Luqman: well, now I'm just frustrated ;p
[06:06:02] <strcat> Luqman: I thought I fixed box_body but now I hit an assert because something *isn't* a pointer
[06:06:05] <strcat> *sigh*
[06:06:14] <strcat> don't know if that's a step forward or a step back
[06:06:23] <Luqman> was the assert in body_datum.copy_to ?
[06:06:32] <strcat> rustc: /home/strcat/projects/rust/src/llvm/lib/IR/Instructions.cpp:2394: static llvm::CastInst* llvm::CastInst::CreatePointerCast(llvm::Value*, llvm::Type*, const llvm::Twine&, llvm::Instruction*): Assertion `S->getType()->isPtrOrPtrVectorTy() && "Invalid cast"' failed.
[06:06:38] <strcat> #5  0x00007ffff4e0a375 in LLVMBuildPointerCast ()
[06:06:40] <strcat>    from /home/strcat/projects/rust/x86_64-unknown-linux-gnu/stage1/bin/../lib/librustllvm.so
[06:06:42] <strcat> #6  0x00007ffff6133eea in middle::trans::build::PointerCast::_b44ff5955e9718d6::_07 ()
[06:06:44] <strcat>    from /home/strcat/projects/rust/x86_64-unknown-linux-gnu/stage1/bin/../lib/librustc-d3cb8c2ccd84a7a7-0.7.so
[06:06:46] <strcat> #7  0x00007ffff613f7b1 in middle::trans::glue::call_tydesc_glue_full::_e987aaff8cdbe2fb::_07 ()
[06:07:05] <strcat>     let llrawptr = PointerCast(bcx, v, Type::i8p());
[06:07:46] <strcat> Luqman: http://ix.io/6xv this is what I made box_body do
[06:07:48] <strcat> maybe it's incorrect
[06:08:13] <strcat> I don't really know what GEPi returns - does it actually return the deref'ed value?
[06:08:49] <strcat>     let boxptr = PointerCast(bcx, boxptr, ty.ptr_to());
[06:08:52] <strcat>     GEPi(bcx, boxptr, [0u, abi::box_field_body])
[06:08:54] <strcat> in opaque_box_body
[06:09:19] <aatch> strcat, GEPi returns a pointer to the element.
[06:09:35] <strcat> ok so I think my box_body *was* doing the right thing
[06:10:19] <aatch> for the vector, each element traverses into the structure, to the 0 goes through the pointer, the second one get the "box_field_body" element
[06:10:32] <strcat> so it returns a pointer to that field
[06:10:35] <strcat> anyway
[06:10:40] <strcat> dunno where I'm making a double pointer then
[06:11:11] <strcat> I'd be so happy if this just worked
[06:11:56] <strcat> anyway I give up again ;p, at least I fixed the vector issue
[06:12:52] *** Joins: jpochyla (jpochyla@moz-8D99AE5D.broadband18.iol.cz)
[06:13:06] *** Joins: Cromulent (Cromulent@moz-983B638D.cable.virginmedia.com)
[06:13:19] <strcat> either I'm making a double pointer or not making a pointer
[06:13:21] <strcat> ;p
[06:14:34] <Luqman> the trade offs between whether to build with optimizations or not :(
[06:20:08] *** Joins: jensnockert (jensnocker@moz-C5F27039.cust.bredband2.com)
[06:22:25] <Eridius> rusti: 0 / 0
[06:22:26] -rusti- rust: task failed at 'attempted to divide by zero', <anon>:7
[06:22:26] -rusti- rust: domain main @0x9141b0 root task failed
[06:22:26] -rusti- application terminated with error code 101
[06:26:06] *** Joins: Archer (Archer@moz-DA478E33.bb.online.no)
[06:26:39] *** Quits: jaen (jaen@moz-E0979827.copit.pl) (Ping timeout)
[06:26:53] *** Joins: pnathan (Adium@B9840254.2CD8A5F8.477B877D.IP)
[06:28:36] <Luqman> strcat: got a bit farther by changing the Store in make_take_glue to Store(bcx, Load(bcx, val), v);
[06:29:04] <Luqman> but now hitting a GEPi assertion somewhere 
[06:29:07] <strcat> Luqman: seems like that's a workaround for something wrong though
[06:29:33] <strcat> I should just be changing *Box<T> to *T
[06:29:47] <strcat> and *T from box_body should just be *T still
[06:30:06] <strcat> I don't think the glue should have to be edited
[06:30:32] <strcat> I'm only changing ~T where T is non-managed so changing the generic glue won't work
[06:33:02] *** Quits: pnathan (Adium@B9840254.2CD8A5F8.477B877D.IP) (Ping timeout)
[06:34:07] *** Joins: sankha93 (Instantbir@513CD6A2.E6798AF8.8B6C1D65.IP)
[06:35:29] * gour hopes rustpkg will get 'uninstall' command unlike eg. haskell's cabal
[06:37:06] *** Joins: wilsonk-laptop (kvirc@moz-39EFBFC2.cg.shawcable.net)
[06:38:54] *** Quits: wilsonk-laptop (kvirc@moz-39EFBFC2.cg.shawcable.net) (Ping timeout)
[06:39:08] *** Quits: jpochyla (jpochyla@moz-8D99AE5D.broadband18.iol.cz) (Ping timeout)
[06:39:20] *** Quits: Diamond (dick@moz-C01E1CD1.ks.ks.cox.net) (Client exited)
[06:40:33] *** Quits: vk (vk@moz-389FEE13.hsd1.ca.comcast.net) (Quit: vk)
[06:42:27] *** Quits: Cromulent (Cromulent@moz-983B638D.cable.virginmedia.com) (Quit: KVIrc 4.2.0 Equilibrium http://www.kvirc.net/)
[06:44:07] *** Quits: echristo (echristo@moz-1892C634.hsd1.ca.comcast.net) (Quit: echristo)
[06:46:15] *** Quits: sankha93 (Instantbir@513CD6A2.E6798AF8.8B6C1D65.IP) (Quit: Instantbird 1.4 -- http://www.instantbird.com)
[06:50:05] *** Quits: z0w0 (zack@E2E93C1.54F16452.2CE63F58.IP) (Client exited)
[06:50:20] *** Joins: z0w0 (zack@E2E93C1.54F16452.2CE63F58.IP)
[06:54:21] *** Quits: strcat (strcat@moz-54F7FD49.cpe.net.cable.rogers.com) (Quit: WeeChat 0.4.1)
[06:55:28] *** Joins: alisdair (textual@moz-EBE9F394.bchsia.telus.net)
[06:56:07] *** Joins: ghrust (ghrust@1E8607E8.6A2AE50.F3114085.IP)
[06:56:07] <ghrust> 01[13rust01] 15bors merged 06auto into 06master: 02http://git.io/zTvFFg
[06:56:07] *** Parts: ghrust (ghrust@1E8607E8.6A2AE50.F3114085.IP) ()
[06:56:14] <Luqman> strcat: success!
[06:56:31] <Luqman> he's gone, just when i finally got libstd to compile
[06:58:56] *** Joins: vilonis (jared@moz-EE5D17ED.ph.ph.cox.net)
[06:59:08] *** Joins: ghrust (ghrust@AC22872E.6A2AE50.F3114085.IP)
[06:59:08] <ghrust> 01[13rust01] 15bors pushed 0 new commits to 06auto: 02http://git.io/jDKz8w
[06:59:08] *** Parts: ghrust (ghrust@AC22872E.6A2AE50.F3114085.IP) ()
[06:59:10] *** Joins: ghrust (ghrust@CFE85B59.6A2AE50.F3114085.IP)
[06:59:10] <ghrust> 01[13rust01] 15bors pushed 2 new commits to 06auto: 02http://git.io/e4Ndyw
[06:59:10] <ghrust> 13rust/06auto 14866a5b1 15Michael Woerister: Added support for struct-like enum variants in middle::ty::enum_variants().
[06:59:10] <ghrust> 13rust/06auto 1488487d8 15bors: auto merge of #7557 : michaelwoerister/rust/enum_structs, r=pcwalton...
[06:59:10] *** Parts: ghrust (ghrust@CFE85B59.6A2AE50.F3114085.IP) ()
[06:59:19] *** Quits: jmgrosen (jmgrosen@moz-848F6087.sb.sd.cox.net) (Quit: jmgrosen)
[07:02:13] *** Joins: jpochyla (jpochyla@moz-8D99AE5D.broadband18.iol.cz)
[07:04:57] <aatch> yes!
[07:04:59] <aatch> woo
[07:05:18] <aatch> now have an @-free ast map
[07:06:22] <dbaupp> nice! (did you finish expr?)
[07:06:54] <aatch> dbaupp, no, gave up
[07:06:59] <aatch> because of the ast map
[07:07:05] <aatch> which required a new visitor
[07:07:41] <aatch> I had to cheat a little to get the compiler to be ok with the lifetimes though
[07:08:46] *** Joins: robert (robertknig@moz-B6DD6E0B.range86-166.btcentralplus.com)
[07:10:43] *** Joins: igl1 (igl@moz-FAB28512.adsl.alicedsl.de)
[07:11:20] *** Quits: igl (igl@moz-4745C1B6.adsl.alicedsl.de) (Ping timeout)
[07:16:01] <aatch> dbaupp, this is me cheating, https://github.com/Aatch/rust/blob/trait-visitor/src/libsyntax/ast_map.rs#L125
[07:16:10] *** aatch is now known as aatch|food
[07:16:48] *** Joins: int3_ (int3_@moz-ABE52D50.hsd1.ca.comcast.net)
[07:17:19] *** Quits: jpochyla (jpochyla@moz-8D99AE5D.broadband18.iol.cz) (Ping timeout)
[07:21:27] *** Joins: Blub\w (wry@7E3BB9D.71150E1A.237AE2BA.IP)
[07:23:46] *** Joins: Voomer (Voomer@moz-E97E8EB7.br.br.cox.net)
[07:23:46] *** Quits: Voomer__ (Voomer@moz-E97E8EB7.br.br.cox.net) (Connection reset by peer)
[07:23:51] *** Joins: jpochyla (jpochyla@moz-8D99AE5D.broadband18.iol.cz)
[07:28:03] *** Joins: achim (achim@moz-F552CCA4.pools.arcor-ip.net)
[07:30:47] *** Quits: jpochyla (jpochyla@moz-8D99AE5D.broadband18.iol.cz) (Ping timeout)
[07:30:51] *** Joins: bytewise (bytewise@moz-649C630D.unitymediagroup.de)
[07:33:54] <jensnockert> rusti: let mut result = std::unstable::u32x4(0x00, 0x00, 0x00, 0x00); let a = std::unstable::u32x4(0x20, 0x30, 0x40, 0x50); let b = std::unstable::u32x4(0x20, 0x50, 0x10, 0x30); unsafe { asm!("pxor $2, $0" : "=x"(result) : "0"(a), "x"(b)) }; result
[07:33:56] -rusti- more than 5 lines of output, pastebinned: http://sprunge.us/NEZe
[07:34:20] <jensnockert> rusti: let mut result = std::unstable::simd::u32x4(0x00, 0x00, 0x00, 0x00); let a = std::unstable::simd::u32x4(0x20, 0x30, 0x40, 0x50); let b = std::unstable::simd::u32x4(0x20, 0x50, 0x10, 0x30); unsafe { asm!("pxor $2, $0" : "=x"(result) : "0"(a), "x"(b)) }; result 
[07:34:21] -rusti- {__field__: 16, __field__: 0, __field__: 0, __field__: 0}
[07:34:32] <jensnockert> Ok, it is brokenâ€¦
[07:34:59] *** Joins: relistan (relistan@moz-2DE8112B.cable.virginmedia.com)
[07:35:02] <jensnockert> rusti: let mut result = std::unstable::simd::u32x4(0x00, 0x00, 0x00, 0x00); let a = std::unstable::simd::u32x4(0x20, 0x30, 0x40, 0x50); let b = std::unstable::simd::u32x4(0x20, 0x50, 0x10, 0x30); unsafe { asm!("pand $2, $0" : "=x"(result) : "0"(a), "x"(b)) }; result 
[07:35:03] -rusti- {__field__: 38457120, __field__: 0, __field__: 0, __field__: 0}
[07:39:29] <dbaupp> jensnockert: it could easily be asm! being broken
[07:39:39] <dbaupp> aatch|food: that is very cheating ;P
[07:39:41] <jensnockert> That's what I am implying.
[07:39:48] <jensnockert> And/or LLVM.
[07:40:22] <dbaupp> I see
[07:40:50] <dbaupp> (I believe aatch|food is/was working on making asm! match clang/gcc more closely)
[07:41:05] <jensnockert> That would be good.
[07:41:24] <jensnockert> And SIMD needs to actually be implemented :S
[07:41:55] *** Joins: MrFahrenheit (RageOfThou@3FEF494C.29C984D5.783DEDCA.IP)
[07:42:27] <jensnockert> Since with the current Trait design, you cannot actually implement traits on the SIMD types, and you can do _nothing_ with them as implemented in libstd :(
[07:43:38] <dbaupp> really?
[07:43:55] <dbaupp> can't you implement the traits in libstd?
[07:44:07] *** aatch|food is now known as aatch
[07:44:39] *** Joins: offline (offline@moz-202FF72A.dip0.t-ipconnect.de)
[07:45:12] <aatch> jensnockert, what register does `pand` put it's result in?
[07:45:12] <jensnockert> Well, you cannot implement a libstd trait on a libstd type outside of libstd.
[07:45:23] <jensnockert> aatch: I'll check, wait.
[07:45:26] *** Quits: alisdair (textual@moz-EBE9F394.bchsia.telus.net) (Quit: My MacBook Pro has gone to sleep. ZZZzzzâ€¦)
[07:46:22] <jensnockert> aatch: xmm0 / xmm1
[07:46:39] <aatch> rusti: let mut result = std::unstable::simd::u32x4(0x00, 0x00, 0x00, 0x00); let a = std::unstable::simd::u32x4(0x20, 0x30, 0x40, 0x50); let b = std::unstable::simd::u32x4(0x20, 0x50, 0x10, 0x30); unsafe { asm!("pand $2, $0" : "={xmm0}"(result) : "0"(a), "x"(b)) }; result
[07:46:39] <jensnockert> aatch: But it moves it in/out from rdx.
[07:46:39] <dbaupp> jensnockert: yeah, I mean, can't you put the impls in libstd? (they'll need to be there at some point.)
[07:47:24] -rusti- {__field__: 21028640, __field__: 0, __field__: 0, __field__: 0}
[07:47:25] <jensnockert> dbaupp: Yeah, you can. Which is what I am saying needs to be done at some point.
[07:47:25] <dbaupp> cool! we agree :)
[07:47:25] <jensnockert> dbaupp: But without ASM working, wellâ€¦ it kind of is pointless.
[07:47:32] <aatch> jensnockert, it works, it's just hard to use
[07:47:39] <dbaupp> in theory they should use the llvm intrinsics, right?
[07:47:57] <dbaupp> (there are intrinsics for simd, aren't there.)
[07:48:07] <jensnockert> dbaupp: Yeah, but you cannot use them for simple ops like +.
[07:48:17] <dbaupp> woah, why?
[07:48:54] <jensnockert> (There are only intrinsics for complex instructions, the other use IR instructions)
[07:49:15] *** Joins: tedh (tedh@moz-F0B37C08.hsd1.il.comcast.net)
[07:49:15] <Luqman> aatch: looking at the output for -S it seems to understand the 'x' constraint (i.e. it puts the args into xmm0/1 and mov's it from xmm0)
[07:49:51] <aatch> Luqman, interesting
[07:50:14] <jensnockert> Luqman: Problem is that it uses a 32-bit move.
[07:50:32] <dbaupp> I see: xmm2 -> mem, mem -> xmm2, xmm2 -> mem, mem -> xmm2 just before the result of the asm!, strangely enough
[07:51:08] <aatch> rusti: let mut result = std::unstable::simd::u32x4(0x00, 0x00, 0x00, 0x00); let a = std::unstable::simd::u32x4(0x20, 0x30, 0x40, 0x50); let b = std::unstable::simd::u32x4(0x20, 0x50, 0x10, 0x30); unsafe { asm!("pand $2, $0" : "=x"(result) : "x"(a), "x"(b)) }; result
[07:51:11] -rusti- {__field__: 37023520, __field__: 0, __field__: 0, __field__: 0}
[07:51:13] <jensnockert> *one problem
[07:51:53] <dbaupp> (also, the simd constructors aren't inlined.)
[07:52:16] <jensnockert> let mut result = 0x00; let a = 0x20; let b = 0x30; unsafe { asm!("and $2, $0" : "=r", "0"(a), "r"(b)) }; result
[07:52:22] <aatch> Argh, I'm pretty sure that the linux1b bot keeps breaking.
[07:52:23] <jensnockert> rusti: let mut result = 0x00; let a = 0x20; let b = 0x30; unsafe { asm!("and $2, $0" : "=r", "0"(a), "r"(b)) }; result
[07:52:24] -rusti- <anon>:7:93: 7:94 error: expected `(` but found `,`
[07:52:24] -rusti- <anon>:7          let mut result = 0x00; let a = 0x20; let b = 0x30; unsafe { asm!("and $2, $0" : "=r", "0"(a), "r"(b)) }; result
[07:52:24] -rusti-                                                                                                       ^
[07:52:24] -rusti- application terminated with error code 101
[07:52:32] <jensnockert> rusti: let mut result = 0x00; let a = 0x20; let b = 0x30; unsafe { asm!("and $2, $0" : "=r"(result), "0"(a), "r"(b)) }; result
[07:52:34] -rusti- more than 5 lines of output, pastebinned: http://sprunge.us/WbLH
[07:52:54] <jensnockert> rusti: let mut result = 0x00; let a = 0x20; let b = 0x30; unsafe { asm!("and $2, $0" : "=r"(result) : "0"(a), "r"(b)) }; result
[07:52:55] -rusti- 32
[07:53:45] *** Joins: vk (vk@moz-389FEE13.hsd1.ca.comcast.net)
[07:53:50] <jensnockert> So by analogy, if asm! wasn't broken for x-constraints, it should work with my code, right?
[07:54:07] <jensnockert> Oh, waitâ€¦
[07:54:07] <aatch> jensnockert, correct
[07:54:15] <aatch> but I don't think that ^^^ works
[07:54:27] <jensnockert> Why doesn't it work?
[07:54:40] <jensnockert> Erâ€¦ what doesn't work?
[07:54:46] <aatch> rusti: let mut result = 0x00; let a = 0x20; let b = 0x30; unsafe { asm!("and $2, $1" : "=r"(result) : "r"(a), "r"(b)) }; result
[07:54:47] -rusti- 32
[07:54:56] <jensnockert> What's wrong with that?
[07:55:04] <aatch> because 0x20 + 0x30 != 32
[07:55:11] <aatch> oh wait, and
[07:55:15] <aatch> not add
[07:55:23] <jensnockert> Important distinction ;)
[07:55:40] <aatch> I thought it was strange you didn'
[07:55:41] *** Joins: SimonSapin (simon@moz-D0C2F181.zone2.bethere.co.uk)
[07:55:45] <aatch> t say anything
[07:56:23] <aatch> rusti: let mut result = std::unstable::simd::u32x4(0x00, 0x00, 0x00, 0x00); let a = std::unstable::simd::u32x4(0x20, 0x30, 0x40, 0x50); let b = std::unstable::simd::u32x4(0x20, 0x50, 0x10, 0x30); unsafe { asm!("pand $2, $1" : "=x"(result) : "x"(a), "x"(b)) }; result
[07:56:24] -rusti- {__field__: 24010528, __field__: 0, __field__: 0, __field__: 0}
[07:56:24] <jensnockert> It might be that rust stores SIMD objects on stack always though.
[07:56:51] <aatch> jensnockert, eh, I dunno
[07:59:58] <ChrisMorgan> Opinion: std::io::Writer shouldn't include seek() or tell(). They're not applicable far too often.
[08:00:16] <Luqman> hmmm finally got past stage1 but hitting double frees now
[08:01:24] <aatch> ChrisMorgan, the new versions in rt::io only have write and flush
[08:01:35] <ChrisMorgan> Oh, good.
[08:01:46] <aatch> and while flush isn't always applicable, it can be a no-op without breaking things
[08:02:15] <ChrisMorgan> That's why I only said seek() and tell().
[08:02:28] <ChrisMorgan> The idea with std::rt::* is that they will move into std::*, is it?
[08:02:36] <aatch> ChrisMorgan, not all of it.
[08:02:44] <aatch> ChrisMorgan, in fact most of it wont
[08:02:45] *** Quits: busylizzy (lisa@85228838.12D0DC84.211374C4.IP) (Ping timeout)
[08:02:53] <aatch> since most of it is, well, runtime stuff
[08:03:24] *** Quits: km (quassel@FDBAF0A0.DBF71E41.29C67456.IP) (Ping timeout)
[08:03:45] <ChrisMorgan> But io will?
[08:03:54] <aatch> ChrisMorgan, most of it, yes
[08:04:10] *** Joins: km (quassel@FDBAF0A0.DBF71E41.29C67456.IP)
[08:04:17] *** Quits: vk (vk@moz-389FEE13.hsd1.ca.comcast.net) (Quit: vk)
[08:04:31] *** Joins: busylizzy (lisa@85228838.12D0DC84.211374C4.IP)
[08:04:32] <aatch> the runtime integration stuff will probably stay under rt::io
[08:08:31] <aatch> Well that's a new error: found value name used as a type
[08:14:15] *** Quits: ross (ross@moz-8A84103E.br.br.cox.net) (Quit: )
[08:15:27] *** Joins: pnathan (Adium@moz-E3C3FAF2.hfc.comcastbusiness.net)
[08:17:15] *** Quits: pnathan (Adium@moz-E3C3FAF2.hfc.comcastbusiness.net) (Ping timeout)
[08:21:57] *** Quits: roo (jesse.rudo@moz-B7585E4C.dynamic.ip.windstream.net) (Ping timeout)
[08:22:47] <ChrisMorgan> aatch: if I'm wanting to work on an HTTP server, would you recommend writing against std::io or std::rt::io?
[08:23:18] <aatch> ChrisMorgan, no idea
[08:23:29] <aatch> I'm not really familiar with either
[08:24:06] * aatch is more of an library person
[08:24:13] <ChrisMorgan> OK
[08:24:31] <dbaupp> ChrisMorgan: rt::io if there is enough there to actually get it to work, possibly with a std::io shim over the top
[08:24:54] * dbaupp isn't particularly familiar with either either
[08:25:09] <aatch> dbaupp, I had to make some minor changes, but the libsyntax I linked to before compiles with a snapshot!
[08:25:19] * ChrisMorgan has some rather grand ideas in mind for a web framework and Rust as a language fits in very well with them
[08:25:20] <dbaupp> aatch: \o/
[08:26:01] <aatch> dbaupp, we might actually get a non-copying ast map!
[08:26:11] <dbaupp> ChrisMorgan: it'd be neat if Rust worked with emscripten, so Rust could run on both ends
[08:26:24] <dbaupp> aatch: you're almost my favourite person
[08:27:14] <dbaupp> aatch: (the whole English/NZ thing are black marks, unfortunately ;P )
[08:27:15] *** Joins: jviereck (Adium@moz-4A3B22C6.pool.mediaways.net)
[08:29:21] <aatch> dbaupp, now I get thread lifetimes through ~90% of rustc
[08:29:37] <aatch> basically anything after crate indexing
[08:29:37] <dbaupp> that sounds... fun.
[08:30:45] <ChrisMorgan> dbaupp: I'm counting on someone managing that somewhere along the line.
[08:31:26] <ChrisMorgan> Emscripten is marvellous for compiled languages in exactly that wayâ€”Node.js needn't have it all its own way any more.
[08:31:55] <dbaupp> ChrisMorgan: yeah, I believe it's on the radar, there's an issue open about it, at least. (And the whole mozilla thing, too, I guess.)
[08:32:19] <aatch> ChrisMorgan, well in a purely technical sense we aren't too far away.
[08:33:07] <dbaupp> aatch: addrspaces are gone now, aren't they?
[08:33:20] <aatch> In fact, I think it might be possible to do now
[08:33:33] <aatch> I mean, you'd only be able to use a limited subset of rust
[08:33:52] * aatch has no idea what emscripten can/can't handle though
[08:35:12] *** Joins: pyrac (pyrac@moz-18D74BD0.w90-60.abo.wanadoo.fr)
[08:36:20] * ChrisMorgan compiled DOSBox a few weeks ago... 120MB of nonfunctional JS.
[08:38:03] *** Quits: ChrisMorgan (chris@moz-6AC741CA.static.tpgi.com.au) (Ping timeout)
[08:38:05] *** Joins: ghrust (ghrust@DE823A67.6A2AE50.F3114085.IP)
[08:38:05] <ghrust> 01[13rust01] 15bors merged 06auto into 06master: 02http://git.io/e4Ndyw
[08:38:05] *** Parts: ghrust (ghrust@DE823A67.6A2AE50.F3114085.IP) ()
[08:38:40] <aatch> Argh
[08:38:45] *** Quits: jensnockert (jensnocker@moz-C5F27039.cust.bredband2.com) (Input/output error)
[08:38:46] <aatch> conflicts
[08:39:28] *** Joins: jpochyla (jpochyla@moz-8D99AE5D.broadband18.iol.cz)
[08:41:04] *** Joins: ghrust (ghrust@9C8B94D4.6A2AE50.F3114085.IP)
[08:41:04] <ghrust> 01[13rust01] 15bors pushed 0 new commits to 06auto: 02http://git.io/Fwbpig
[08:41:04] *** Parts: ghrust (ghrust@9C8B94D4.6A2AE50.F3114085.IP) ()
[08:41:23] *** Quits: jpochyla (jpochyla@moz-8D99AE5D.broadband18.iol.cz) (Ping timeout)
[08:41:47] *** Joins: bytbox (s@moz-DC83764A.washdc.fios.verizon.net)
[08:44:05] *** Joins: ghrust (ghrust@FD7BC443.6A2AE50.F3114085.IP)
[08:44:05] <ghrust> 01[13rust01] 15bors pushed 2 new commits to 06auto: 02http://git.io/OkQSYA
[08:44:05] <ghrust> 13rust/06auto 148cb1a29 15Armin Ronacher: Removed drop from the keyword list in the docs
[08:44:05] <ghrust> 13rust/06auto 1463f7857 15bors: auto merge of #7582 : mitsuhiko/rust/doc-fixes, r=huonw...
[08:44:06] *** Parts: ghrust (ghrust@FD7BC443.6A2AE50.F3114085.IP) ()
[08:44:23] *** Joins: snadon (chatzilla@moz-3BC727E8.mc.videotron.ca)
[08:45:35] *** Joins: pnathan (Adium@B9840254.2CD8A5F8.477B877D.IP)
[08:46:05] *** Quits: robert (robertknig@moz-B6DD6E0B.range86-166.btcentralplus.com) (Ping timeout)
[08:48:33] <mark_edward> poor aatch
[08:48:40] *** Joins: Ms2ger (Ms2ger@moz-E9883900.access.telenet.be)
[08:48:44] <mark_edward> i wonder when trait objects will work...
[08:48:51] * mark_edward pines after trait objects
[08:48:56] <aatch> mark_edward, well fortunately that change ^^ is just a one-line change
[08:48:59] <aatch> mark_edward, they do mostly
[08:49:04] *** Joins: roo (jesse.rudo@moz-B7585E4C.dynamic.ip.windstream.net)
[08:49:12] <aatch> not in all cases, but enough to be used in a few places in the compiler
[08:49:23] <mark_edward> don't work with inheritance though. or maybe it's changes
[08:49:26] <mark_edward> *changed
[08:49:39] <aatch> mark_edward, oh, no, they don't handle inheritance at all
[08:49:46] <aatch> but that's traits in general
[08:49:49] <mark_edward> but they should right?
[08:49:59] <mark_edward> eventually i mean
[08:50:05] <aatch> mark_edward, yes
[08:50:23] <mark_edward> you think trait objects will be fully functional by 1.0?
[08:50:33] <aatch> mark_edward, maybe not "fully"
[08:50:40] <aatch> but better, certainly
[08:50:51] <aatch> there are always going to be edge-cases
[08:51:06] *** Joins: Ubaion (Archer@moz-DA478E33.bb.online.no)
[08:51:09] <mark_edward> i understand that. wish i new enough to help make them work rather then pine after it
[08:51:35] <aatch> mark_edward, it's fine. We have actual interns to do that kind of work.
[08:51:39] *** Quits: Archer (Archer@moz-DA478E33.bb.online.no) (Ping timeout)
[08:51:43] <aatch> like sully and bblum.
[08:51:55] *** Quits: pnathan (Adium@B9840254.2CD8A5F8.477B877D.IP) (Ping timeout)
[08:52:04] <mark_edward> are your interns paid or volunteers?
[08:52:40] <aatch> mark_edward, no idea.
[08:52:45] <aatch> probably
[08:53:04] <mark_edward> being a mozilla intern would be sweet. right now im working at a startup accelerator internship
[08:53:13] <mark_edward> don't like it. too much business, not enough code
[08:53:22] <bblum> we are paid
[08:53:47] <aatch> mark_edward, I enjoyed working in a start-up accelerator
[08:53:57] <aatch> learning about the business and that
[08:54:26] <aatch> mark_edward, bblum here managed to make traits not completely unsound
[08:54:27] <mark_edward> maybe yours was different. i don't really want to learn that stuff. i want to be a skilled tradesman. 
[08:54:35] * mark_edward thanks bblum
[08:54:40] <bblum> woo
[08:54:56] *** Quits: vilonis (jared@moz-EE5D17ED.ph.ph.cox.net) (Quit: WeeChat 0.3.8)
[08:55:01] <aatch> bblum, your continuous strive towards correctness is appreciated
[08:55:17] <bblum> woo :)
[08:55:29] <bblum> correctness is v. important
[08:55:59] <aatch> bblum, I'm currently trying to make libsyntax suck less
[08:56:59] <bblum> good! how?
[08:57:05] <aatch> I've managed to re-write two visitors using traits and make the ast map do no copies
[08:57:14] <aatch> (well no copies of the ast anyway)
[08:57:30] <aatch> it borrows out of the AST
[08:57:59] <aatch> since it's effectively immutable after indexing anyway
[08:58:31] <aatch> so the lifetime of the map is tied to the lifetime of the AST now
[08:58:38] <bblum> cool, i don't understand the impact of much of that, but cool
[08:58:54] <aatch> bblum, my goal is to have 0 `@` in the AST
[08:59:08] <bblum> that seems difficult
[08:59:11] <aatch> this goes a long way towards that goal
[08:59:11] <Luqman> aatch: lofty goal considering how much it's used
[08:59:14] <aatch> bblum, it is.
[08:59:27] <aatch> but I'm actually doing surprisingly well
[08:59:33] <cmr> gour: hello
[08:59:46] <aatch> Luqman, don't I know it...
[08:59:46] <cmr> Markdown probably yes
[08:59:51] <cmr> Haven't gotten that far yet
[08:59:56] <cmr> Minor detail :)
[09:00:25] <aatch> fortunately it only uses @ and not @mut, so the vast majority of current usages can be replaced with &
[09:00:33] <aatch> (as arguments)
[09:00:40] <mark_edward> why did it use @ before?
[09:00:50] <mark_edward> was there an issue with borrowed pointers?
[09:00:54] <cmr> laziness + ease of use + nonexistence of borrowed pointers
[09:00:58] <aatch> mark_edward, we didn't have the region system before
[09:01:01] <bblum> the issue was that they did not exist
[09:01:06] <cmr> (in reverse order)
[09:01:13] *** Quits: jviereck (Adium@moz-4A3B22C6.pool.mediaways.net) (Quit: Leaving.)
[09:01:16] <mark_edward> oooh, that's a pretty big issue
[09:01:24] <mark_edward> borrowed pointers in Rust are so cool
[09:01:30] <Luqman> aatch: good luck!
[09:01:39] <mark_edward> i'd say it's a bigger feature than owned ptrs in a sense
[09:01:52] <mark_edward> owned ptrs could be a library
[09:01:55] <aatch> mark_edward, well they don't make sense without ownership
[09:02:03] <mark_edward> true
[09:02:03] <Luqman> so far, i've gotten strcat's branch  to get pass stage1 but now stage2 rustc segfaults :(
[09:02:16] <aatch> mark_edward, we still have ownership semantics though
[09:02:25] <aatch> Luqman, ouch, that'll be hard to debug
[09:03:00] <mark_edward> Luqman: what are you working on?
[09:03:11] <Luqman> yep, stage2 only bugs are the worst
[09:03:17] <aatch> Luqman, also, I am aware of my goals loftiness, hence why my process has been to remove a little and then keep it building
[09:03:45] *** Quits: dwhyte (dwhyte@ED9190FB.B72E355F.7BF4A4B0.IP) (Client exited)
[09:03:45] <Luqman> mark_edward: strcat has been working towards getting rid of useless box headers
[09:03:53] *** Joins: jviereck (Adium@moz-4A3B22C6.pool.mediaways.net)
[09:04:00] <mark_edward> oh right. that's a pretty big change too
[09:04:19] <aatch> mark_edward, and it's really hard to work with because trans is a mess
[09:04:20] <dbaupp> cmr: out of interest, is that script running yet?
[09:04:30] <cmr> dbaupp: I fired it off when I went to bed
[09:04:33] <cmr> did anything explode?
[09:04:38] <mark_edward> just as i want to workk on some rust code, my cronjob start's rebuilding rustc
[09:04:42] <dbaupp> cmr: didn't seem to
[09:04:47] *** Joins: untitaker (yaaic@moz-BFC77EB9.adsl.highway.telekom.at)
[09:04:47] <cmr> dbaupp: \o/
[09:04:52] <dbaupp> cmr: and the page seems to be updating
[09:05:12] <cmr> https://gist.github.com/cmr/0d07dcc88333b7fcfb66
[09:05:16] <cmr> it did explode, sadly
[09:05:59] <cmr> suppose I should touch that file eh?
[09:06:02] <untitaker> hey guys it's me again :>
[09:06:10] <dbaupp> cmr: make a last_auto.txt with the commit it should start going backwards from, in the directory that the script runs from
[09:06:32] <dbaupp> cmr: (the complete hash)
[09:06:40] <untitaker> i want to define a twodimensional vector. This would be &[&[int]], right?
[09:07:07] <aatch> untitaker, that would work for two-dimensional slice, yes
[09:07:09] <cmr> dbaupp: it only does ones it hasn't done yet, so starting from master shouldn't hurt, right?
[09:07:18] <dbaupp> cmr: (well, to be clear, it should be the commit that it has tested most recently, so it starts at the TIME_MACHINE_SPEED'th parent of that one)
[09:07:19] <untitaker> aatch: thanks
[09:07:22] <dbaupp> cmr: right, should be fine
[09:07:48] <untitaker> i tried iterating over this with for field.each |row| {...}
[09:08:07] <aatch> untitaker, .each was removed
[09:08:07] <untitaker> but it tells me that the type &[&[int]] doesnt have a method each
[09:08:12] <untitaker> oh
[09:08:23] <aatch> we're transitioning to external iterators
[09:08:31] <untitaker> what'd be the equivalent in 0.7?
[09:08:38] <cmr> .iter().advance
[09:08:41] <aatch> right now it's vec.iter().advance
[09:10:19] <untitaker> ok i got that far, now how do i print w/o newlines?
[09:10:26] <cmr> print()
[09:10:41] <untitaker> i did try to find all of these in the docs btw
[09:11:10] <untitaker> thanks again!
[09:13:01] *** Quits: Ubaion (Archer@moz-DA478E33.bb.online.no) (Ping timeout)
[09:14:00] *** Quits: james4k (james@moz-E7990244.consolidated.net) (Ping timeout)
[09:16:12] *** Quits: jviereck (Adium@moz-4A3B22C6.pool.mediaways.net) (Quit: Leaving.)
[09:17:12] *** Joins: Blei (philipp@moz-650B9C6A.cust.bluewin.ch)
[09:20:11] *** Joins: dwhyte (dwhyte@ED9190FB.B72E355F.7BF4A4B0.IP)
[09:20:41] *** Joins: pnathan (Adium@moz-BDC3EE62.tukw.qwest.net)
[09:21:31] <pnathan> "error: cannot borrow immutable field as mutable"  This is in reference to a struct. How do I define a struct as mutable?
[09:21:59] <cmr> pnathan: let mut foo = ...
[09:22:21] <cmr> Or, if it's a function arg, foo(mut foo: T)
[09:24:39] <pnathan> Hrm. It's a impl function on the struct. Trying to mutate the self. 
[09:24:46] *** Joins: geomyidae (geomyidae@DD6F7E3A.21468E9A.30200F38.IP)
[09:24:47] <cmr> &mut self, then
[09:25:25] <aatch> 43 resolve errors to go
[09:25:26] <pnathan> Aha. There we go. 
[09:25:33] <aatch> (started at 140)
[09:25:47] *** Quits: heftig (heftig@moz-72EDF21D.dip0.t-ipconnect.de) (Ping timeout)
[09:26:59] <geomyidae> can anyone help me use quote_tokens? I don't know what value ext_cx should be here: https://github.com/mozilla/rust/blob/master/src/test/run-pass-fulldeps/quote-tokens.rs
[09:27:15] <geomyidae> I can't find anything that calls it or any other usages of quote_*()
[09:27:32] *** Quits: pyrac (pyrac@moz-18D74BD0.w90-60.abo.wanadoo.fr) (Quit: pyrac)
[09:27:40] <cmr> pauls: ^?
[09:28:56] *** Joins: spider-mario (spidermari@moz-81131DB6.fbx.proxad.net)
[09:32:42] *** Joins: heftig (heftig@moz-21B2BBB0.dip0.t-ipconnect.de)
[09:33:24] *** Quits: flowsnake (flowsnake@moz-1918C33E.aztw.cable.virginmedia.com) (Connection reset by peer)
[09:37:32] <geomyidae> there's got to be a macro for getting the current parser context or something
[09:38:05] *** Joins: flowsnake (flowsnake@moz-1918C33E.aztw.cable.virginmedia.com)
[09:38:11] <aatch> geomyidae, what are you trying to do?
[09:39:17] <geomyidae> aatch: I'd like to be able to write an extension/macro that will internally use parse_expr/parse_tokens to let people write LINQ like expressions.
[09:39:37] <aatch> geomyidae, we don't have pluggable macros atm
[09:39:44] <geomyidae> aatch: can you elaborate?
[09:39:50] <geomyidae> or describe pluggable?
[09:40:03] <Luqman> aatch: wasn't there basic support?
[09:40:15] <aatch> Luqman, more like proof-of-concept support
[09:40:58] <geomyidae> what does pluggable mean?
[09:41:13] <mark_edward> can defualt implementations rely on having a certain member?
[09:41:26] <aatch> geomyidae, the quote_expr! tokens are only intended to be used by the compiler at the moment
[09:41:27] <aatch> mark_edward, no
[09:41:30] <geomyidae> oh, does it mean my crate can't export them?
[09:41:36] <aatch> geomyidae, correct
[09:41:36] <mark_edward> okay dokey
[09:41:42] <cmr> mark_edward: (yet)
[09:41:50] <cmr> I think associated items is that feature
[09:41:58] <aatch> Well, that's also a different thing
[09:42:04] <aatch> cmr, I don't think so.
[09:42:07] <geomyidae> aatch: I kinda figured at much but was hoping it was robust enough (:P)  that I could fake an empty parser session or something
[09:42:14] *** Quits: Blei (philipp@moz-650B9C6A.cust.bluewin.ch) (Quit: WeeChat 0.4.1)
[09:42:49] <aatch> I think mark_edward was talking about requiring, say, a struct to have a 'foo' field
[09:43:21] <mark_edward> yeah that ^^
[09:43:30] <aatch> mark_edward, you probably want an accessor method in the trait
[09:44:04] <geomyidae> any good exercises that have explanations of how to uniquely solve them well in Rust?
[09:44:23] <cmr> geomyidae: nope
[09:44:43] <geomyidae> Oh I've seen one or two blog posts that were decent.
[09:44:51] <cmr> geomyidae: you could prototype your linq stuff in libsyntax
[09:45:27] <geomyidae> cmr: sounds fun, I need to do a lot more basic stuff first I think, I haven't written that much rust at all yet
[09:45:43] <aatch> geomyidae, if you're looking for something that showcases Rust's features, this might be something: https://gist.github.com/Aatch/5734372
[09:45:59] *** Quits: offline (offline@moz-202FF72A.dip0.t-ipconnect.de) (Quit: oO0°)
[09:46:52] <geomyidae> aatch: this'll definitely work.
[09:47:33] <geomyidae> aatch: this is wonderful, I appreciate people that write "it does this, and not [this other wrong thing you're probably thinking] because of X"
[09:47:35] <geomyidae> :)
[09:50:22] *** Quits: snadon (chatzilla@moz-3BC727E8.mc.videotron.ca) (Ping timeout)
[09:51:02] <mark_edward> can you implement traits on enum variants?
[09:52:53] <geomyidae> aatch: you mind if I ask a few questions?
[09:53:17] <aatch> geomyidae, shoot
[09:53:21] <aatch> mark_edward, not variants
[09:53:25] <geomyidae> Is the s.slice(0, s.len()) on line 59 a way of copying the string, or what? I'm not entirely sure I understand the terminology or implications of 'take a slice'
[09:53:29] <mark_edward> man
[09:53:41] <cmr> aatch: you should update that to as_slice
[09:53:45] <mark_edward> though i'd figured out a sneaky way to get around trait problems...
[09:53:58] <aatch> geomyidae, no, and it should be as_slice as cmr says. I'm updating it now
[09:54:16] <cmr> geomyidae: It's a way to take an immutable reference to a string
[09:55:38] <geomyidae> rust always makes me question how much I really know CS sometimes. even when I read this and think I understand, I'm not sure I'd ever know it well enough to write it to leverage rusts abilities :O
[09:56:05] <aatch> geomyidae, basically, it means you can have a "view" into the string, without needing to copying the string
[09:56:08] <geomyidae> cmr: So if it were just Some(s) or Some(copy s), those aren't immutable refs to a string?
[09:56:18] <aatch> the down side is that you can make the view bigger
[09:56:25] <geomyidae> aatch: a slice is a view into the array, is it similar to go's slices then?
[09:56:35] <aatch> geomyidae, pretty much identical
[09:56:54] <aatch> at runtime, a slice is a (ptr, len) pair
[09:57:04] <geomyidae> "the down side"... is bad because you can skirt bounds checks?
[09:57:06] <geomyidae> or?
[09:57:18] <aatch> geomyidae, sorry, "can't"*
[09:57:27] <aatch> typo'd
[09:57:31] <geomyidae> ah
[09:57:35] <geomyidae> okay
[09:58:29] <geomyidae> alright, going to read some more, I'm sure I'll be back soon, thanks
[09:59:45] *** Joins: jpochyla (jpochyla@moz-8D99AE5D.broadband18.iol.cz)
[10:00:01] <untitaker> what is the latest way of making a twodimensional vector with mutable content?
[10:00:02] *** Joins: quvarxa (chatzilla@moz-978E4C31.static.tpgi.com.au)
[10:00:15] <untitaker> eg i want to have a vector where i can do foo[x][y] = 1233
[10:00:23] <cmr> untitaker: ~[~[]] or &mut[&mut[]]
[10:00:32] <untitaker> ahh
[10:00:53] <untitaker> i thought the mut on the vectors themselves would mean that they would be replaceable
[10:01:33] <aatch> untitaker, &[&mut[]] might also work
[10:01:58] * aatch isn't sure about how Rust would deal with the mutability there
[10:02:10] <cmr> the borrow checker will probably just implode ;p
[10:02:21] <doomlord> thats going to have variable size per column though isn't it 
[10:02:27] <cmr> doomlord: yeah
[10:02:37] <cmr> You'd want to use [T, ..n] for fixed size
[10:02:37] <geomyidae> cmr, do you think something like LINQ would be implementable outside the language itself if macros were able to be exported?
[10:02:45] <geomyidae> cmr, sorry to jump back to that old topic
[10:02:47] <doomlord> i was just doing images with interface functions, i wasn't sure what the best way would be
[10:02:47] <cmr> geomyidae: absolutely
[10:03:23] <doomlord> Image {  buffer:~[T], width:int /* height=buffer.len()/width*/}   etc
[10:03:28] *** Quits: km (quassel@FDBAF0A0.DBF71E41.29C67456.IP) (Ping timeout)
[10:03:50] <geomyidae> cool, I thought as much, I have something prototyped with eq!() and noteq!() and a couple others that output some correct things. I think it would be fun to work on, as I really like LINQ for doing ORM/DB work and I want to use Rust for that when the io and http work lands from brson
[10:03:56] <aatch> geomyidae, that's the point of them. Especially for syntax extensions
[10:03:56] <doomlord> .get(i,j)   .set(i,j, value)
[10:04:14] <cmr> doomlord: that works too
[10:04:23] <cmr> probably works better as it's dense
[10:04:24] <aatch> (which would be rust libraries loaded at compile time containing more complex logic)
[10:04:37] *** Joins: km (quassel@FDBAF0A0.DBF71E41.29C67456.IP)
[10:04:38] <geomyidae> aatch: any idea if there's a bug for making quote* more usable externally?
[10:05:00] <aatch> geomyidae, well it's a sub-bug of loadable syntax extensions
[10:05:01] <mark_edward> i have a problem. i have a subdirectory monster, as seen here: https://github.com/MarkJr94/rust_adventure
[10:05:15] <aatch> 1 error!
[10:05:18] <mark_edward> and i want to pub use the structs located in skeleton.rs and mummy.rs
[10:05:27] <cmr> aatch: fixing that 1 will spawn a thousand more...
[10:05:28] <untitaker> hmm, it appears a func that takes &[&[int] can't take a &[&mut[int]]
[10:05:33] <aatch> cmr I know
[10:05:33] <cmr> you're in resole errors right? ;)
[10:05:37] <geomyidae> aatch: I see, so there are macros that don't require syntax extension that work now without requiring the other extended features for proper pluggability?
[10:05:38] <aatch> cmr, yep
[10:05:41] <geomyidae> sorry to be super verbose
[10:05:41] <mark_edward> but i can't because i can't use use statements after mod statements
[10:05:43] <cmr> untitaker: Correct, &mut and & can't alias
[10:05:54] <mark_edward> and without the mod statement it can't resolve the struct names
[10:05:57] <cmr> geomyidae: no, macros can't be exported from crates either
[10:05:59] <aatch> geomyidae, there are macros, defined with macro_rules!
[10:06:24] <geomyidae> cmr: ah, I didn't necessarily mean in that respect
[10:06:24] <mark_edward> any
[10:06:30] <untitaker> cmr: the thing is... i have a tictactoe field and a function that prints it. The func doesn't have to have "write-access" to the field, but i'd like the func to work on both mutable and immutable 2d vectors
[10:06:31] <mark_edward>  *any ideas
[10:06:35] <rntz> does rust not have assert any more? or has it been turned into a macro?
[10:06:45] <cmr> rntz: assert!(), yes
[10:07:01] <geomyidae> hm, well, I'll try to patiently wait and look for any kind of bug tracking for syn exts. :)
[10:07:54] <doomlord> trait Array2d<T> {  fn get(&self,i:int,j:int)->T;  fn set(&mut self,i:int,j:int,T);  .....}
[10:08:14] <kimundi> untitaker: passing &mut T where &T is expected works, but there is no nice solution for nested conversions, so &[&mut T] -> &[&T] won't work as is
[10:08:35] <roo> untitaker: I use ~[~[]] inside another data structure usually. Then fn method(&mut self) can mutate them freely... i guess it depends on what you are doing.
[10:08:54] <mark_edward> cmr: ca you help?
[10:09:06] <cmr> mark_edward: sec
[10:09:45] <untitaker> something like <VI8> is a pointer, right?
[10:09:50] <untitaker> (in a error msg)
[10:10:27] <aatch> untitaker, no, unbounded type
[10:10:31] <cmr> mark_edward: what do you want to do?
[10:10:41] <mark_edward> i think i explained it
[10:10:50] <cmr> you did but I don't understand :)
[10:11:04] <cmr> where do you want to reexport the mummy and such?
[10:11:18] <mark_edward> but i want to "export" (pub use skeleton::Skeleton; and pub use mummy::Mummy) in monster.rs
[10:11:40] <cmr> pub use super::mummy::Mummy
[10:11:42] <mark_edward> so i can say use monster::{Skeleton,Mummy} in say level.rs
[10:12:41] <mark_edward> that doesn't seem to work. (you want me to delete the mod statements right?
[10:12:42] <untitaker> http://sprunge.us/YGSX
[10:12:46] <untitaker> that's what i have so far
[10:13:22] <aatch> cmr, this is my last resolve error: https://github.com/Aatch/rust/blob/trait-visitor/src/librustc/middle/lint.rs#L981
[10:13:26] <cmr> mark_edward: no, you should add them before
[10:14:02] <aatch> because the id_visitor uses a new-style visitor
[10:15:44] <mark_edward> cmr: this is what i ahve: http://pastebin.com/M7aC46HX and it's failing to resolve imports
[10:16:10] <cmr> mark_edward: your crate structure is all weird
[10:16:22] *** Joins: Earnestly (earnest@2A2BF8F5.321FA5E6.BFD1ABFD.IP)
[10:16:29] <mark_edward> hwo so? isn't this how you have to do subdirectories now?
[10:16:29] <cmr> mark_edward: all of your mod statements should be in adventure.rc
[10:16:59] *** Quits: Earnestly (earnest@2A2BF8F5.321FA5E6.BFD1ABFD.IP) (Quit: WeeChat 0.4.2-dev)
[10:17:20] <kimundi> well, it's not a necessary to gather them all in your crate root
[10:17:58] <mark_edward> but then it says error; cant open monster/monster.rs/skeleton.rs
[10:18:10] <mark_edward> if i do mod monster { mod mummy;  mod skeleton; }
[10:18:14] *** Quits: relistan (relistan@moz-2DE8112B.cable.virginmedia.com) (Quit: relistan)
[10:18:16] *** Joins: Earnestly (earnest@2A2BF8F5.321FA5E6.BFD1ABFD.IP)
[10:18:21] <mark_edward> in adventure.rc
[10:18:21] <roo> unitaker: i would do something like struct Field(~[~[uint]]);, then pass around &Field.
[10:18:27] <cmr> don't use the #[path] attribute
[10:18:38] <mark_edward> i though you had to
[10:18:54] <cmr> Not if you use a mod tree like that
[10:19:11] <roo> untitaker, &mut Field
[10:19:28] <untitaker> shorter version: http://sprunge.us/gMZF
[10:19:41] <mark_edward> okay, but now it says "there is no Monster in monster" and i'm asssuming monster = monster subdir
[10:20:11] <untitaker> mark_edward: You're also in the mid of rust for rubyists?
[10:20:15] <aatch> Ok, easy way out for now, don't have the lint_session pass :/
[10:20:37] <mark_edward> untitaker: no, i looked at it a while back,but im doing somehting else
[10:20:44] <kimundi> untitaker: Whats the problem you have with that code?
[10:21:00] <untitaker> kimundi: It doesn't compile :P
[10:21:24] <kimundi> A bit more detail please :D
[10:22:48] <untitaker> kimundi: http://sprunge.us/FiO
[10:23:02] *** Joins: ghrust (ghrust@5FEF1C87.6A2AE50.F3114085.IP)
[10:23:02] <ghrust> 01[13rust01] 15bors merged 06auto into 06master: 02http://git.io/OkQSYA
[10:23:02] *** Parts: ghrust (ghrust@5FEF1C87.6A2AE50.F3114085.IP) ()
[10:23:30] <aatch> Ok, hopefully my PR doesn't hang this time.
[10:23:33] <untitaker> if i change the funcs signature it fails earlier
[10:23:37] <kimundi> that link is bad
[10:23:41] <untitaker> (if i remove the "mut" from the signatore
[10:23:49] <untitaker> http://sprunge.us/FiOA
[10:24:39] <aatch> Things that need lifetimes: anything that uses the AST map
[10:24:52] <aatch> Things that use the AST map: everything after it's creation
[10:26:00] *** Joins: ghrust (ghrust@9C8B94D4.6A2AE50.F3114085.IP)
[10:26:00] <ghrust> 01[13rust01] 15bors pushed 0 new commits to 06auto: 02http://git.io/lfhd1g
[10:26:00] *** Parts: ghrust (ghrust@9C8B94D4.6A2AE50.F3114085.IP) ()
[10:26:03] *** Joins: ghrust (ghrust@C621748.6A2AE50.F3114085.IP)
[10:26:04] <ghrust> 01[13rust01] 15bors pushed 10 new commits to 06auto: 02http://git.io/C058PQ
[10:26:04] <ghrust> 13rust/06auto 14d7b6b4c 15James Miller: Stop allocating view_items with @
[10:26:04] <ghrust> 13rust/06auto 144099866 15James Miller: De-managed ast::Path
[10:26:04] <ghrust> 13rust/06auto 140ef52a4 15James Miller: De-manage Lifetime
[10:26:04] *** Parts: ghrust (ghrust@C621748.6A2AE50.F3114085.IP) ()
[10:26:34] <Ms2ger> aatch++
[10:26:50] <aatch> Ms2ger, take... 3 I think
[10:27:01] <kimundi> untitaker: Could you try replacing one or both iter() calls with iter_mut() ?
[10:28:10] <kimundi> (or mut_iter()... dunno wich way the naming sheme works)
[10:28:32] *** Joins: xLII (xLII@4BED3CB3.F5F53E8A.2D6DB75E.IP)
[10:28:37] <untitaker> it works
[10:28:55] <untitaker> i don't get it
[10:29:03] *** Joins: ghrust (ghrust@2EE61FCC.6A2AE50.F3114085.IP)
[10:29:03] <ghrust> 01[13rust01] 15bors 04force-pushed 06auto from 1421c3716 to 1463f7857: 02http://git.io/N3iJvQ
[10:29:03] *** Parts: ghrust (ghrust@2EE61FCC.6A2AE50.F3114085.IP) ()
[10:29:08] <kimundi> could you paste the code that works?
[10:29:36] <aatch> NOO
[10:30:06] <bjz> ?
[10:30:14] <untitaker> kimundi: changing both to mut_iter works
[10:30:17] <untitaker> http://sprunge.us/cMiF
[10:30:41] <aatch> Ok, it's just being bors/buildbots being weird
[10:30:54] <mark_edward> the way subdirs work is funky.if you have a module with submodules that are large enough to be their own  files
[10:31:12] <mark_edward> then how do you also have a file that is that module with things in it?
[10:33:12] <untitaker> hmm, should something like python's tuple unpacking work if i have a func that returns (x, y)
[10:33:14] <untitaker> and i do
[10:33:16] <aatch> mark_edward, you can have mod { ... }
[10:33:20] <untitaker> let (x, y) = (0, 0)
[10:33:24] <untitaker> (x, y) = func()
[10:33:28] <mark_edward> aatch: what do you mean?
[10:33:36] <kimundi> untitaker: That works
[10:33:37] <aatch> untitaker, you cannot do that ^^
[10:33:47] <kimundi> aatch: hu?
[10:33:47] <untitaker> which one
[10:33:48] <aatch> kimundi, no it doesn't
[10:33:53] <roo> yeah that doesnt work :D
[10:33:54] <aatch> the second one
[10:34:01] <kimundi> ah, witouh a let
[10:34:02] <untitaker> i get an internal compiler error
[10:34:07] *** Joins: pnathan1 (Adium@B9840254.2CD8A5F8.477B877D.IP)
[10:34:09] <kimundi> yeah, that doesn't work
[10:34:16] <kimundi> would be niac if, though
[10:34:31] <aatch> untitaker, you shouldn't get an error, but it doesn't work because it's not a pattern
[10:34:42] <doomlord> subdirs in the path become parts of the module path?
[10:34:48] <aatch> kimundi, it probably won't work because the second one is expr = expr
[10:34:57] <aatch> not let pat = expr
[10:35:13] <aatch> they are syntactically different
[10:35:20] <mark_edward> say i want module structure mod Foo { mod Bar; mod Baz } and i want to define some structs in mod Foo, and i want Bar and Baz to be in their own files
[10:35:25] <untitaker> so if i have a loop that does a lot of reassigning i should put let inside the loop
[10:35:27] <untitaker> ?
[10:35:57] <mark_edward> and i want to export some structs so that i can say Foo::BarStruct instead of Foo::Bar::Barstruct
[10:36:01] <aatch> untitaker, depends, do you need to re-use the actual variables?
[10:36:02] <mark_edward> how would you do that?
[10:36:11] <doomlord> i think struct/traits/impls gives you a lot more freedom with distributing code between files than classes do
[10:36:52] <kimundi> hm, if we get the 'in' keyword we could introduce an assingment statement for patters: 'let (mut x, mut y) = (456, 96); in (x, _) = foo()'
[10:37:08] <aatch> kimundi, that could work
[10:37:47] <untitaker> aatch: i basically have two temp vars that will be used inside the loop
[10:38:00] *** Joins: ASenR (ASenR@6E26B819.8EF580C8.6B1291C6.IP)
[10:38:06] <aatch> untitaker, then having the let inside the loop is fine
[10:38:26] <aatch> assuming that you don't need the values outside the loop
[10:38:36] <untitaker> nope
[10:39:48] *** Quits: Houm (Houm@moz-25669AA8.fbx.proxad.net) (Ping timeout)
[10:40:35] *** Quits: pnathan1 (Adium@B9840254.2CD8A5F8.477B877D.IP) (Ping timeout)
[10:41:01] *** Joins: ghrust (ghrust@C8693FCB.6A2AE50.F3114085.IP)
[10:41:01] <ghrust> 01[13rust01] 15bors 04force-pushed 06auto from 14f431be9 to 1463f7857: 02http://git.io/N3iJvQ
[10:41:01] *** Parts: ghrust (ghrust@C8693FCB.6A2AE50.F3114085.IP) ()
[10:41:03] *** Joins: ghrust (ghrust@E7A4CCE2.6A2AE50.F3114085.IP)
[10:41:03] <ghrust> 01[13rust01] 15bors pushed 2 new commits to 06auto: 02http://git.io/sajM2A
[10:41:03] <ghrust> 13rust/06auto 143c5cfdf 15Philipp BrÃ¼schweiler: libsyntax: fix infinite loop when recursively including modules...
[10:41:03] <ghrust> 13rust/06auto 14d91ac39 15bors: auto merge of #7585 : Blei/rust/fix-circular-modules, r=huonw...
[10:41:03] *** Parts: ghrust (ghrust@E7A4CCE2.6A2AE50.F3114085.IP) ()
[10:42:02] <aatch> I checked that!
[10:42:21] *** Quits: ASenR (ASenR@6E26B819.8EF580C8.6B1291C6.IP) (Ping timeout)
[10:42:22] *** Joins: AndroUser2 (ASenR@E8D750B8.8EF580C8.6B1291C6.IP)
[10:43:49] *** Quits: AndroUser2 (ASenR@E8D750B8.8EF580C8.6B1291C6.IP) (Quit: AndroIRC - Android IRC Client ( http://www.androirc.com ))
[10:45:32] *** Joins: Houm (Houm@moz-25669AA8.fbx.proxad.net)
[10:50:03] *** Quits: SimonSapin (simon@moz-D0C2F181.zone2.bethere.co.uk) (Ping timeout)
[10:50:13] *** Joins: q66 (q66@6EE9DE40.46454B5D.33AABD5F.IP)
[10:50:45] <dbaupp> cmr, mark_edward: that directory/mod structure isn't particularly strange.
[10:51:02] <mark_edward> how do i make it work? so frustrating
[10:51:07] *** Joins: SimonSapin (simon@moz-D0C2F181.zone2.bethere.co.uk)
[10:51:14] <dbaupp> mark_edward: I'm talking about your current one
[10:51:21] <mark_edward> i just want a module, with submodules, and the aforementioned moduels has stuff in it
[10:51:27] <dbaupp> e.g. the standard library/compiler uses it extensively
[10:51:57] *** Joins: smvv_ (sander@moz-BAEA8EB2.dynamic.upc.nl)
[10:52:06] <dbaupp> although `monster/monster.rs` would normally be `monster/mod.rs`
[10:52:28] *** Joins: tiffany (kawaii@moz-1E0FE6E8.dhcp.embarqhsd.net)
[10:52:33] *** Joins: pyrac (pyrac@moz-18D74BD0.w90-60.abo.wanadoo.fr)
[10:53:29] <aatch> dbaupp, I am now officially at the "threading lifetime annotations everywhere"
[10:53:52] *** Joins: Sindwiller (quassel@moz-743130B2.dynamic.hispeed.ch)
[10:53:54] <aatch> which, btw, will actually make a lot of future changes easier
[10:54:01] <dbaupp> aatch: how much progress?
[10:54:12] <dbaupp> aatch: yeah, it'd allow the mmap change to be relaitively painless
[10:54:16] <dbaupp> *relatively
[10:54:26] <aatch> dbaupp, only just started on that bit
[10:54:26] <dbaupp> since you're taking all the the pain now.
[10:54:27] <mark_edward> dbaupp: but you can't have mod monster { mod skeleton; mod mummy; mod mod; }
[10:54:38] <mark_edward> the compiler complains at "mod mod;"
[10:55:04] <dbaupp> mark_edward: https://gist.github.com/huonw/5943096
[10:55:06] <aatch> dbaupp, if you want to help, the linter needs re-writing to use the new visitor trait...
[10:55:23] <dbaupp> aatch: oh, that's landed?
[10:55:31] <aatch> dbaupp, nope
[10:55:45] <aatch> but I'm using a snapshot that never made it live
[10:56:15] <mark_edward> dbaupp: what if in a_mod.rs you want to go "pub use b::foo;"
[10:56:16] <dbaupp> and the visitor trait is in that, or are you just working on top of your branch?
[10:56:28] <aatch> dbaupp, the visitor trait is in my branch
[10:56:37] *** Quits: xLII (xLII@4BED3CB3.F5F53E8A.2D6DB75E.IP) (Client exited)
[10:56:51] <aatch> but it needs a snapshot to compile
[10:56:52] <dbaupp> mark_edward: updated
[10:57:04] <dbaupp> aatch: what branch?
[10:57:11] <mark_edward> ah!
[10:57:12] <aatch> dbaupp, trait-visitor
[10:57:17] <dbaupp> (I can probably work on it in half an hour or so)
[10:57:23] <dbaupp> cmr: ping
[10:57:29] <aatch> dbaupp, it won't actually compile
[10:57:33] <mark_edward> the self and super keyword aren't document anywhere!!! I was searching all the tutorials and docs and the wiki
[10:57:53] <dbaupp> mark_edward: they are documented on IRC though ;P
[10:58:20] <aatch> since I haven't fixed all that, but there's some commented out code, lint_session, in lint.rs
[10:58:36] <aatch> because it uses the id_visitor, which doesn't exist anymore
[10:59:37] *** Quits: jpochyla (jpochyla@moz-8D99AE5D.broadband18.iol.cz) (Quit: leaving)
[10:59:38] <dbaupp> ok
[11:00:25] <mark_edward> dbaupp: thanks again! you are a lifesaver!
[11:00:28] *** Joins: cr (anonymous@moz-331999F1.dip0.t-ipconnect.de)
[11:00:43] <aatch> but because of the architecture of it, it's difficult to work with.
[11:00:59] <aatch> specifically, that the new IdVisitor uses a stack closure
[11:00:59] <dbaupp> 'it' = trait visitor?
[11:01:07] <aatch> dbaupp, the linter
[11:01:17] <dbaupp> right
[11:01:25] <aatch> as in, I can't just update that one pass
[11:01:43] <dbaupp> yeah, it requires some more detailed work.
[11:03:42] <cmr> dbaupp: pong
[11:03:57] <cmr> benchit.py still had the make failure bug but I fixed it
[11:04:04] <cmr> needed to catch an exception rather than just retrying
[11:04:10] *** Joins: mnemotic (niko@8FFD1BD2.9D81E74C.53DF0002.IP)
[11:04:20] <dbaupp> so it's working "properly" now?
[11:04:26] <cmr> I think so
[11:04:46] <cmr> at the very least, it's doing its thing again :p
[11:04:58] <dbaupp> (also, I noticed you closed a few bugs; I think it's normal to also make sure there's an associated test. :) )
[11:05:07] <cmr> oh poop
[11:05:38] * cmr rapidly ctrl-shift-t's
[11:06:10] <dbaupp> (obviously some of them don't make sense to have a test.)
[11:06:58] *** Joins: engla (engla@moz-DBD1D96E.cust.bredbandsbolaget.se)
[11:11:56] *** Quits: engla (engla@moz-DBD1D96E.cust.bredbandsbolaget.se) (Ping timeout)
[11:11:59] *** Joins: engla (engla@moz-DBD1D96E.cust.bredbandsbolaget.se)
[11:15:53] *** Joins: ChrisMorgan (chris@moz-6AC741CA.static.tpgi.com.au)
[11:17:39] *** Joins: maxli (maxli@B5559308.9C54E60.2FA4EA88.IP)
[11:18:18] <ChrisMorgan> Is it possible to have a generic struct (for static rather than dynamic lookup)?
[11:18:30] <cmr> Yes, struct Foo<T>
[11:18:38] <aatch> ChrisMorgan, like struct Foo<T> { t: T }?
[11:18:44] <ChrisMorgan> Yep
[11:18:59] <aatch> no :P
[11:19:34] <ChrisMorgan> So you'd be stuck with a Foo { t: &Trait }
[11:19:47] <aatch> ChrisMorgan, I was joking...
[11:19:57] <aatch> I gave you the exact syntax...
[11:20:14] * ChrisMorgan was too lazy to try it: shame on him!
[11:21:10] <roo> shouldn't #[should_fail] tests fail silently, and report that they passed?
[11:21:43] <aatch> roo, it's a little difficult to suppress the output, but they do report they passed, if they fail.
[11:21:54] <kimundi> roo: They report that they passed, but failing right now is harcodod to not be silent :P
[11:23:01] *** Quits: maxli (maxli@B5559308.9C54E60.2FA4EA88.IP) (Ping timeout)
[11:24:57] <roo> hmm. yeah these arent reporting that they passed, but they are definitely failing, and definitely tests. http://sprunge.us/adEb
[11:26:45] <kimundi> IT might have something to do with windows
[11:27:01] <kimundi> afaik failure is kinde broken there
[11:27:10] <roo> cant even fail! fail!
[11:27:23] <cmr> failure isn't implemented at all on windows
[11:27:37] <cmr> so there's no way it could catch it
[11:28:51] *** Joins: jensnockert (jensnocker@moz-C5F27039.cust.bredband2.com)
[11:29:05] <roo> well as long as its not me doing something dumb, im alright with it
[11:29:27] <cmr> (Windows: the Tier 3 Tier 1 Platform)
[11:29:58] *** Quits: z0w0 (zack@E2E93C1.54F16452.2CE63F58.IP) (Client exited)
[11:30:28] *** Joins: BizarreCake (BizarreCak@moz-361FE9B2.dynamic.barak-online.net)
[11:31:24] *** Quits: int3_ (int3_@moz-ABE52D50.hsd1.ca.comcast.net) (Client exited)
[11:31:34] *** Joins: maxli (maxli@B5559308.9C54E60.2FA4EA88.IP)
[11:31:54] *** Joins: int3_ (int3_@moz-ABE52D50.hsd1.ca.comcast.net)
[11:32:15] <blaphmat> is it possible to create shallow copies of borrowed owned values?
[11:32:31] <cmr> blaphmat: of &~Foo?
[11:32:53] <blaphmat> yeah, i have &mut &Foo
[11:33:02] <blaphmat> whoops &mut ~Foo
[11:33:32] <cmr> Hm, if Foo has the... Send kind, I think you should be able to? Not sure
[11:34:17] <blaphmat> if it doesn't does it mean i should be using managed boxes rather than owned boxes?
[11:36:09] <cmr> If you want to be making copies, yes.
[11:36:18] <kimundi> blaphmat: you can reborrow a &mut ~Foo to a new &mut ~Foo, but you can't copy the &mut because a there needs to be only one &mut to the same data at all time
[11:36:21] *** Quits: krdln (Mibbit@moz-6F8A8560.dynamic.chello.pl) (Quit: http://www.mibbit.com ajax IRC Client)
[11:36:44] *** Joins: robert (robertknig@moz-B6DD6E0B.range86-166.btcentralplus.com)
[11:36:48] <cmr> kimundi: I think he's asking if you can do `copy *foo` where foo is your &mut ~Foo
[11:37:58] <geomyidae> err  what's supposed to be in the prelude? :/
[11:37:59] <aatch> you cannot make a shallow copy of owned data
[11:38:01] <kimundi> well, a shallow copy of the ~ would also be illigal, and a deep copy of the ~Foo is... not e shallow copy :P
[11:38:12] <aatch> as it would no longer be uniquely owned
[11:38:33] <cmr> geomyidae: universally useful stuff like ToStr or Option
[11:39:04] <kimundi> geomyidae: usefull functions and types that are so common that needing to write a 'use' for them in every file would get tedios
[11:39:04] <geomyidae> hm, after upgrading a ton of stuff is no longer available that seemed to have been automatically available previously
[11:39:08] <roo> geomyidae: it imports other modules in std, so the documentation is empty
[11:39:19] <roo> it has nothing of its own
[11:39:23] <cmr> geomyidae: Yes, all of the reexports were removed.
[11:39:36] <dbaupp> geomyidae: (reexported modules, that is.)
[11:39:42] <cmr> aatch: what about a POD type?
[11:39:42] <kimundi> geomyidae: Recently all _module_ reexports where reoved from the prelude
[11:40:15] <aatch> cmr, well that's still copying all the data.
[11:40:27] <engla> geomyidae: all the submodules of std were removed from the prelude. They are still under std::
[11:40:44] *** Joins: true_droid (Adium@moz-123FD9B8.beck.volia.net)
[11:41:05] <cmr> aatch: ...good point
[11:41:26] <engla> geomyidae: for example str, uint etc
[11:41:27] *** Joins: krdln (Mibbit@moz-6F8A8560.dynamic.chello.pl)
[11:41:43] <mark_edward> rusti: struct Foo { mem: &mut ~int} let mut x = ~1; let f = Foo { mem: &mut x}; f.mem
[11:41:44] -rusti- <anon>:7:27: 7:36 error: Illegal anonymous lifetime: anonymous lifetimes are not permitted here
[11:41:44] -rusti- <anon>:7          struct Foo { mem: &mut ~int} let mut x = ~1; let f = Foo { mem: &mut x}; f.mem
[11:41:44] -rusti-                                     ^~~~~~~~~
[11:41:44] -rusti- error: aborting due to previous error
[11:41:44] -rusti- application terminated with error code 101
[11:42:10] <ChrisMorgan> I presume there's no form of byte literal? writer.write([13, 10]) vs. writer.write("\r\n".as_bytes())...
[11:42:22] <cmr> rusti: bytes!("\r\n")
[11:42:23] -rusti- &[13, 10]
[11:42:27] <ChrisMorgan> Oh!
[11:42:27] <mark_edward> rusti: struct Foo<'self> { mem: &'self mut ~int} let mut x = ~1; let f = Foo { mem: &mut x}; f.mem
[11:42:28] -rusti- more than 5 lines of output, pastebinned: http://sprunge.us/XIdM
[11:42:37] <ChrisMorgan> If only these things were documented :-(
[11:42:44] *** Quits: blaphmat (Mibbit@moz-C207C5B5.range86-145.btcentralplus.com) (Quit: http://www.mibbit.com ajax IRC Client)
[11:42:45] <ChrisMorgan> Fortunately, this channel is absolutely *great*.
[11:42:52] <ChrisMorgan> (Hope I'm not too burdensome.)
[11:42:57] <cmr> (not at all)
[11:43:02] <aatch> ChrisMorgan, nah, it's fine
[11:43:02] <kimundi> They are! In the collective hivemind that is #rust
[11:43:16] <aatch> we've got to do something while we wait for things to compile
[11:43:20] <dbaupp> #rust is the best documentation
[11:43:24] <mark_edward> rusti: struct Foo<'self> { mem: &'self mut ~int} let mut x = ~1; let borrow = &mut x; let f = Foo { mem: borrow}; f.mem
[11:43:26] -rusti- more than 5 lines of output, pastebinned: http://sprunge.us/bXjg
[11:43:29] <cmr> All of us together add up to maybe 1.8 rust programmers ;)
[11:43:39] <cmr> rust experts, I mean
[11:43:46] <ChrisMorgan> dbaupp: that's certainly my opinion at present!
[11:44:21] * dbaupp thinks we should automatically redirect the docs website to mibbit
[11:44:28] <cmr> heh
[11:44:52] <aatch> Things that are nice: when structs already have lifetime parameters so I know I won't have to do much
[11:44:57] <mark_edward> what i did should work though, in a normal .rs file though, right?
[11:45:11] <aatch> mark_edward, yes
[11:45:24] <cmr> rust-buildbot: struct Foo<'self> { mem: &'self mut ~int} let mut x = ~1; let borrow = &mut x; let f = Foo { mem: borrow}; println(fmt!("%?", f.mem));
[11:45:33] <cmr> rusti: struct Foo<'self> { mem: &'self mut ~int} let mut x = ~1; let borrow = &mut x; let f = Foo { mem: borrow}; println(fmt!("%?", f.mem));
[11:45:34] -rusti- &mut ~1
[11:45:34] -rusti- ()
[11:45:39] <aatch> rusti: struct Foo<'self> { mem: &'self mut ~int} let mut x = ~1; let borrow = &mut x; let f = Foo { mem: borrow}; fmt!("%?", f.mem)
[11:45:41] -rusti- ~"&mut ~1"
[11:45:53] <mark_edward> what's the difference there?
[11:46:21] <cmr> It's not returning the value from the block
[11:46:23] <kimundi> f.mem gets retured to an outer block in wich it is not alive anymore
[11:46:29] <mark_edward> ah, i see
[11:46:34] <geomyidae> where's my os.exit() ? :s
[11:46:36] <mark_edward> i'll have to remember that
[11:47:00] <kimundi> geomyidae: os::set_exit_code() ant return from main
[11:47:08] <kimundi> and*
[11:47:26] <geomyidae> that's the only way
[11:47:27] <geomyidae> ?
[11:47:39] <geomyidae> that is interesting, seems a bit opinionated?
[11:48:03] <kimundi> without failure or calling underlying c functions, yes
[11:48:05] <cmr> geomyidae: it's so other tasks can run to completion and such
[11:48:36] <geomyidae> or so you're forced to deal with their lifecycle at least
[11:48:45] <geomyidae> it makes sense, I like it.
[11:52:47] *** Joins: FrozenCow (FrozenCow@moz-B2DF4929.chello.nl)
[11:54:34] <geomyidae> Is this the typical way of using this function? FromStr::from_str::<bool>("true")
[11:56:08] *** Joins: donri (dag@moz-9BB61102.tbcn.telia.com)
[11:56:52] <kimundi> I think yes :P
[11:57:25] <geomyidae> why is from_str<bool>... not sufficient?
[11:57:39] <aatch> geomyidae, syntactic ambiguity
[11:57:40] <kimundi> ambiguity in a expression
[11:57:49] <aatch> from_str < bool 
[11:58:01] <cmr> rusti: let x: bool = from_str("true")
[11:58:01] -rusti- <anon>:8:4: 8:5 error: expected `;` but found `}`
[11:58:02] -rusti- <anon>:8     };
[11:58:02] -rusti-              ^
[11:58:02] -rusti- application terminated with error code 101
[11:58:06] <cmr> rusti: let x: bool = from_str("true"); x
[11:58:06] -rusti- <anon>:7:23: 7:31 error: unresolved name `from_str`.
[11:58:08] -rusti- <anon>:7          let x: bool = from_str("true"); x
[11:58:09] <kimundi> foo<Bar>() <-> foo < Bar > ()
[11:58:10] -rusti-                                 ^~~~~~~~
[11:58:12] -rusti- error: aborting due to previous error
[11:58:14] -rusti- application terminated with error code 101
[11:58:32] <aatch> heh, is `Bar` between foo and ()
[11:59:23] *** Joins: sigma1 (sigma@51C589B3.EF2694B5.DFAC6AA7.IP)
[11:59:32] <geomyidae> I'm sorry.
[11:59:51] <geomyidae> rusti: let x: bool = from_str::<bool>("true"); x
[11:59:51] -rusti- <anon>:7:23: 7:39 error: unresolved name `from_str`.
[11:59:52] -rusti- <anon>:7          let x: bool = from_str::<bool>("true"); x
[11:59:52] -rusti-                                 ^~~~~~~~~~~~~~~~
[11:59:52] -rusti- error: aborting due to previous error
[11:59:52] -rusti- application terminated with error code 101
[11:59:55] <aatch> geomyidae, don't be, it's a valid question
[11:59:59] <roo> use std::FromStr::from_str; let x : uint = from_str("1") + from_str("2")
[12:00:04] <geomyidae> aatch: thats what I meant though ^
[12:00:08] <geomyidae> not what I originally wrote :o
[12:00:09] <roo> erf, no rusti
[12:00:27] <aatch> rusti: let x: bool = FromStr::from_str::<bool>("true"); x
[12:00:29] <engla> from_str returns Option<T>
[12:00:39] -rusti- <anon>:7:23: 7:57 error: mismatched types: expected `bool` but found `std::option::Option<bool>` (expected bool but found enum std::option::Option)
[12:00:41] <roo> oh duh
[12:00:42] -rusti- <anon>:7          let x: bool = FromStr::from_str::<bool>("true"); x
[12:00:44] -rusti-                                 ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
[12:00:46] -rusti- error: aborting due to previous error
[12:00:48] -rusti- application terminated with error code 101
[12:00:54] <aatch> rusti: let x = FromStr::from_str::<bool>("true"); x
[12:00:55] -rusti- Some(true)
[12:01:11] <geomyidae> rusti: use std::FromStr::from_Str; let x = from_str::<bool>("true"); x
[12:01:12] -rusti- more than 5 lines of output, pastebinned: http://sprunge.us/SDVa
[12:01:24] <aatch> it has to be FromStr::from_str
[12:01:31] <engla> you can't do that anymore
[12:01:31] <aatch> FromStr is a trait
[12:01:35] <geomyidae> rusti: use FromStr::from_Str; let x = from_str::<bool>("true"); x
[12:01:37] -rusti- more than 5 lines of output, pastebinned: http://sprunge.us/hZjV
[12:01:44] <aatch> geomyidae, won't work
[12:01:55] <aatch> you have to call it as FromStr::from_str(...)
[12:02:00] <geomyidae> aatch: do I want to ask why ? :p
[12:02:09] <aatch> geomyidae, because it's a static trait method
[12:02:26] <geomyidae> oh crap, I think last time I was here I got this far and asked something similar :o
[12:02:35] <engla> you could do it in 0.6
[12:02:37] <engla> it was removed
[12:02:50] <geomyidae> oh well, then this must be new, I feel less bad asking about it :)
[12:03:55] <geomyidae> wait, so are from_str and to_str different in that regard?
[12:04:05] <cmr> yes
[12:04:07] <geomyidae> because to_str can be called obj.to_str() right?
[12:04:12] <cmr> to_str is a method
[12:04:17] <aatch> geomyidae, what would you call from_str on?
[12:04:23] <geomyidae> aatch: right
[12:04:24] <cmr> guh static method is a terrible name
[12:04:26] <engla> on a str :-)
[12:04:54] <engla> "true".from_str()  would be easier
[12:04:58] <geomyidae> engla: yeah, I suppose? I mean, I guess it makes sense, it seems a bit weird to me that "FromStr" lives at what looks like a top level namesapce
[12:05:03] <geomyidae> if that makes sense?
[12:05:03] <kimundi> call it assoziated function then :)
[12:05:05] <aatch> engla, and make no sense
[12:05:17] <geomyidae> engla: but it would have to be "true".from_str<bool>();
[12:05:19] <engla> of course it does. it might have to change name
[12:05:27] <engla> geomyidae: or type inference
[12:05:31] <geomyidae> could taht be done? "true".from_str<bool>();
[12:05:37] <engla> yes sure
[12:05:51] <aatch> it also makes it harder to extend
[12:05:51] <engla> with a different name it makes sense
[12:05:55] <geomyidae> engla: can that sort of type inference be done though? type inference from the LHS to the RHS?
[12:06:01] <engla> aatch: it would still use the same trait
[12:06:08] <engla> just add a method on str that uses it
[12:06:15] <engla> geomyidae: yes!
[12:06:40] <geomyidae> should it? that seems strange, or is that typical in other rust usage? (if so could you show me a tiny ex?)
[12:07:13] <engla> rusti: if std::rand::random() { 77 } else { 6 }
[12:07:13] -rusti- 77
[12:07:22] <engla> if requires bool so it's inferred
[12:07:56] <geomyidae> isn't that just because non-zero is treated as true in most languages?
[12:07:59] <engla> no
[12:08:19] <gour> mark_edward: hiya, afaict, rust provides enough features to be good-enough for going low-level as much as one wants, but i'm curious, considering you did some haskell, what do you think how it covers the other (higher-level of abstraction) end of the spectrum?
[12:08:24] <aatch> engla, also, there is a possibility that for a concrete type implementing a trait, you'd be able to do Trait::static_method()
[12:08:26] <engla> rusti: if 1 { println("hi") }
[12:08:27] -rusti- <anon>:7:12: 7:13 error: mismatched types: expected `bool` but found `<VI0>` (expected bool but found integral variable)
[12:08:27] -rusti- <anon>:7          if 1 { println("hi") }
[12:08:27] -rusti-                      ^
[12:08:27] -rusti- error: aborting due to previous error
[12:08:27] -rusti- application terminated with error code 101
[12:08:46] <mark_edward> gour: not too well right now.
[12:08:52] <mark_edward> that's a fault of the libraries though
[12:09:05] <mark_edward> the main things missing now are good/easy to use networking and I/O
[12:09:08] <gour> mark_edward: you mean design or implementation-wise?
[12:09:19] <mark_edward> just implementation wise
[12:09:23] <gour> ahh, ok
[12:09:24] <engla> aatch: you mean Type::static_method() ?
[12:09:35] <aatch> mark_edward, design of some could be improved
[12:09:37] <aatch> engla, yes
[12:09:42] <mark_edward> aatch: like what?
[12:09:43] <aatch> engla, sorry, kinda tired.
[12:09:49] <aatch> mark_edward, most of libextra
[12:10:01] <engla> aatch: anyway, str could have an extra method to invoke FromStr.. you could even implement it separately, anywhere in a new trait
[12:10:06] <mark_edward> but that's a library thing, not a language thing
[12:10:08] <cmr> I don't see how the libraries affect how well the language covers high levels of abstraction
[12:10:18] <gour> is the basic syntax mostly done and/or stable?
[12:10:21] <cmr> gour: no
[12:10:27] <cmr> gour: more or less yes
[12:10:42] <geomyidae> @ is still being decided right
[12:10:49] <cmr> as is for loops
[12:11:09] <gour> cmr: 'no' in regard to design-wise?
[12:11:11] <aatch> The major syntax is stable.
[12:11:50] <cmr> gour: there's still some wiggle room wrt syntax
[12:12:40] <gour> cmr: ta...and good luck with rustdoc/md ;)
[12:13:32] <gour> i like(d) nimrod's syntax, but not the fact it's mostly one-man-show...that's why i'm seriously looking at rust...
[12:13:47] <krdln> kimundi: is your proposition for custom @ sugar still considered?
[12:14:09] <kimundi> No idea
[12:14:29] <kimundi> I proposed it to the davs, they are aware of it, the rest is up to them
[12:14:36] <kimundi> devs*
[12:15:48] *** Joins: MaikKlein (maik@moz-CA56C650.dip0.t-ipconnect.de)
[12:17:40] <gour> Nimrod is probably, due to the number of devs and/or backing up, not rust's competitor, but wonder how does Rust compare with today's D in terms of language design, mostly in regard to type/memory safety? to me it seems not many languages are aiming at the level of rust's safety?
[12:18:59] <cmr> afaik D gets its safety through gc
[12:19:26] <MaikKlein> D is more like nimrod
[12:19:56] <cmr> does D prevent data races?
[12:19:59] *** Joins: ghrust (ghrust@5FEF1C87.6A2AE50.F3114085.IP)
[12:19:59] <ghrust> 01[13rust01] 15bors merged 06auto into 06master: 02http://git.io/sajM2A
[12:19:59] *** Parts: ghrust (ghrust@5FEF1C87.6A2AE50.F3114085.IP) ()
[12:20:52] <aatch> cmr, not really
[12:21:05] <aatch> it has some stuff relating to shared memory
[12:21:12] <gour> i stopped following D months ago...when i was reading http://www.reddit.com/r/programming/comments/1f1uz3/sebastian_sylvans_language_design_deal_breakers/, besides Rust, only Ada seemed as serious contender
[12:21:24] <mark_edward> i think GC also makes D not available in certain systems applications
[12:21:34] <mark_edward> wouldn't write a browser engine in it, it hink
[12:21:54] <aatch> mark_edward, more importantly, it's 1. a global gc, and 2. relied upon
[12:22:10] <aatch> gour, I was a D contributor for a while
[12:22:10] <mark_edward> yeah, the whole standar dlibrary requires it right?
[12:22:24] <geomyidae> what would @ look like as an ext lib?
[12:22:30] <mark_edward> do you think you could get rid of all @ptrs in std and extra?
[12:22:39] <aatch> mark_edward, in theory, yes
[12:22:40] *** Joins: pnathan1 (Adium@moz-E3C3FAF2.hfc.comcastbusiness.net)
[12:22:42] <cmr> geomyidae: Gc<T>
[12:22:48] <mark_edward> is it a worthy goal?
[12:22:54] <aatch> mark_edward, yes
[12:22:57] *** Joins: ghrust (ghrust@F6EE6DE3.6A2AE50.F3114085.IP)
[12:22:57] <ghrust> 01[13rust01] 15bors pushed 0 new commits to 06auto: 02http://git.io/QAfMfA
[12:22:57] *** Parts: ghrust (ghrust@F6EE6DE3.6A2AE50.F3114085.IP) ()
[12:23:01] *** Joins: ghrust (ghrust@1E8607E8.6A2AE50.F3114085.IP)
[12:23:01] <ghrust> 01[13rust01] 15bors pushed 11 new commits to 06auto: 02http://git.io/bk3y7g
[12:23:01] <ghrust> 13rust/06auto 14a69eb95 15James Miller: Stop allocating view_items with @
[12:23:01] <ghrust> 13rust/06auto 14cd1b6c8 15James Miller: De-managed ast::Path
[12:23:01] <ghrust> 13rust/06auto 1462c83bb 15James Miller: De-manage Lifetime
[12:23:03] *** Parts: ghrust (ghrust@1E8607E8.6A2AE50.F3114085.IP) ()
[12:23:10] <mark_edward> i can't think of any types that need it
[12:23:10] <aatch> 4th times a charm?
[12:23:20] <aatch> mark_edward, there are a few, but not many
[12:23:28] <aatch> if you have cycles.
[12:23:32] *** Quits: KindOne (KindOne@moz-7505E461.dynamic.ip.windstream.net) (Ping timeout)
[12:23:34] <mark_edward> like why do Files and Sockets have it?? they shouldn't need it right?
[12:23:35] <engla> there aren't many @ that matter in std, mostly just obsolete io
[12:23:49] <mark_edward> aatch: right. but what htings in std/extra would have cycles?
[12:24:04] <aatch> mark_edward, they do not.
[12:24:13] <cmr> mark_edward: because it's old code
[12:24:20] <cmr> from the time before time
[12:24:33] * dbaupp cheers bors on
[12:24:36] <mark_edward> before my people walked the plains of IRC
[12:25:12] <mark_edward> aatch: what sort of things would have cycles that *could* be in std/extra at some pint?
[12:25:28] <dbaupp> mark_edward: doubly linked lists
[12:25:34] <gour> aatch: for D1 or D2?
[12:25:39] <aatch> gour, D2
[12:26:02] <gour> aatch: ohh, that's significant...what do you think about nimrod?
[12:26:15] <mark_edward> dbaupp: can you think of anything else?
[12:26:18] <MaikKlein> gour, I think nimrod is similar
[12:26:19] <aatch> gour, never looked at it
[12:26:28] <dbaupp> mark_edward: not really
[12:26:44] <mark_edward> why do double linked lists need it? couldn't they be implemented with unsafe code and the right destructors?
[12:26:52] <gour> MaikKlein: so, you also prefer rust over nimrod?
[12:26:54] <mark_edward> i'm pretty sure i did it in C++ once.
[12:27:00] <mark_edward> no GC there
[12:27:03] <dbaupp> mark_edward: but @ is also useful for persistent datastructures (that don't necessarily have cycles)
[12:27:07] <MaikKlein> gour, nimrod uses the gc afaik
[12:27:19] <cmr> https://github.com/mozilla/rust/commit/3c5cfdf2e7e53967eb330928aaeedfbb8ea1db4d
[12:27:22] <cmr> Blei is a hero!
[12:27:32] <gour> MaikKlein: yes, but they say it's not stop-the-world one, afaik
[12:27:44] <dbaupp> mark_edward: yeah, obviously you can use unsafe code, and it's probably actually a better route for a doubly-linked list, since it requires @mut
[12:27:55] <dbaupp> and @mut is worse than the black-death
[12:28:23] <mark_edward> indeed. i've avoided @ pretty much completely outside of I/O code so far.
[12:28:49] *** Joins: KindOne (KindOne@moz-2FCD28ED.dynamic.ip.windstream.net)
[12:28:50] <dbaupp> yeah, @ is just annoying, but @mut can make your program crash at runtime if you use it wrong
[12:28:52] *** Quits: pnathan1 (Adium@moz-E3C3FAF2.hfc.comcastbusiness.net) (Ping timeout)
[12:29:02] <dbaupp> (which is easy to do.)
[12:29:17] <kimundi> not crash
[12:29:22] <dbaupp> right, fail
[12:29:44] <aatch> fail, crash, bad things
[12:29:48] <MaikKlein> gour, it's task local afaik but it'S still a gc. It might be possible to write a game engine in Nimrod but then rust seems like a better option. Rust lets you decide when yo want to use the gc which is pretty cool
[12:31:45] *** Quits: KindOne (KindOne@moz-2FCD28ED.dynamic.ip.windstream.net) (Ping timeout)
[12:31:49] <gour> MaikKlein: i agree...otoh, i do not plan to write game engine, but looking for type-safe language with good performance (for desktop gui app) being more pragmatic than e.g. haskell...and if it's native allowing us to avoid .net/mono, even better :-)
[12:32:10] <cmr> gour: rust is not a good choice for a gui app
[12:32:13] <cmr> no gui libs!
[12:32:38] <gour> cmr: that's now, but wikipedia article says: "Rust is a general purpose..."
[12:32:53] <cmr> gour: well yes, but if you want to actually use it, you're going need to write/wrap your own lib
[12:32:54] * gour hopes something is going to change in regards...
[12:33:06] <MaikKlein> well GUI is possilbe
[12:33:10] <MaikKlein> just not right now
[12:33:25] <aatch> it's all possible.
[12:33:26] <MaikKlein> gtk and stuff should be easy to port though
[12:33:27] <gour> i hope i'm not the only one considering such route
[12:33:46] <aatch> people are writing _kernels_ in Rust for godsakes
[12:33:54] <mark_edward> MaikKlein: i want to work on porting GTK
[12:34:04] <mark_edward> but to port GTK you have to first port Glib
[12:34:04] <gour> otherwise, one niche would be still reserved for C(+++)
[12:34:09] <mark_edward> it's a lot of work
[12:34:19] <MaikKlein> mark_edward, isn't glib already ported?
[12:34:30] <cmr> https://github.com/mzabaluev/grust was updated
[12:34:37] <gour> there is some binding generator, available, right?
[12:34:40] <cmr> the author was in irc the other day
[12:35:06] <gour> doint it all by hand these days, is certinly not pretty
[12:35:09] *** Joins: KindOne (KindOne@moz-F727BE0E.dynamic.ip.windstream.net)
[12:35:09] <bjz> r? https://github.com/mozilla/rust/pull/7635
[12:35:12] <geomyidae> Qt is all the hotness lately though.
[12:35:19] <mark_edward> yeah
[12:35:28] <mark_edward> but we  have no way to make C++ bindings
[12:35:32] <gour> yeah, lxde is also going to qt
[12:35:44] <mark_edward> is it even possible? we can't replicate all their template shenanigans
[12:35:46] <dbaupp> rusti: !true
[12:35:46] -rusti- false
[12:35:49] <MaikKlein> Atm I am writing my gui app in Qt c++ and expose my rust program though c functions
[12:36:05] <gour> uhh
[12:36:07] <dbaupp> bjz: this is one of those strange builtin types thing?
[12:36:07] <cmr> mark_edward: there are C bindings for Qt, via SMOKE
[12:36:19] <mark_edward> really... i do like Qt...
[12:36:45] <MaikKlein> cmr, I think someone here said that it's not possible to use smoke atm
[12:36:48] <gour> cmr: are you sure? i was investigating about it,  but didn't find anything
[12:37:01] <dbaupp> gour: https://github.com/crabtw/rust-bindgen
[12:37:02] <cmr> https://github.com/reusee/go-qt uses it
[12:37:03] <gour> wx is also mostly dead...
[12:37:08] <bjz> dbaupp: yup :(
[12:37:21] <gour> even .net/mono have qt bindings...
[12:37:58] <bjz> dbaupp: I wish we could define the llvm code directly, same for the num operators
[12:38:01] *** Quits: KindOne (KindOne@moz-F727BE0E.dynamic.ip.windstream.net) (Ping timeout)
[12:38:21] <dbaupp> bjz: instead of having the special ones builtin to the compiler, you mean?
[12:38:22] <bjz> dbaupp: that way we wouldn't be repeating stuff stupidly like this
[12:38:26] <MaikKlein> u can't make a 1 to 1 bind in rust, because we have no inheritance 
[12:38:27] <bjz> ya
[12:38:32] *** Quits: robert (robertknig@moz-B6DD6E0B.range86-166.btcentralplus.com) (Ping timeout)
[12:38:47] <dbaupp> bjz: yeah, it'd be nice
[12:39:12] <dbaupp> bjz: llvm!() like asm!() or something
[12:40:04] <cmr> gour: the .net bindings also use smoke
[12:41:08] <geomyidae> cmr: ? .net bindings for what?
[12:41:11] <cmr> qt
[12:41:14] <geomyidae> oh
[12:41:23] <gour> cmr: yeah, but wonder if smoke can help rust bindings? otherwise, having qt for rust would be more than cool
[12:42:04] <cmr> gour: it could be used, but the rust code might not be very rusty
[12:42:09] <bjz> dbaupp: I've discussed it with Luqman and jensnockert before
[12:42:23] <gour> geomyidae: http://techbase.kde.org/Development/Languages/Qyoto
[12:42:42] <jensnockert> llvm! would be <3.
[12:42:55] <bjz> dbaupp: a valid concern is that we may not want to couple closely to llvm
[12:43:11] <bjz> dbaupp: or encourge people with llvm!
[12:43:19] <jensnockert> bjz: Unlike asm! ?
[12:43:31] <dbaupp> bjz: yeah, I think I've been around for a few of these discussions
[12:43:51] <mark_edward> isn't rust already tightly coupled with LLVM?
[12:43:54] <bjz> jensnockert: well, asm! is compiler independant, no?
[12:43:57] <gour> cmr: "blind uncle is better than no uncle"...it's anyway the common situation when calling libs from lwer-level languages
[12:43:57] <cmr> mark_edward: no
[12:44:03] <dbaupp> mark_edward: only the compiler
[12:44:16] <cmr> gour: yup
[12:44:20] <bjz> mark_edward: I should have said, 'couple std with llvm'
[12:44:33] <mark_edward> but Rust is the compiler... the compiler is all there is...
[12:44:34] <bjz> mark_edward: although we already make use of intrinsics
[12:44:44] <mark_edward> you think someone else would write another rust compiler?
[12:44:45] <cmr> mark_edward: Rust is a language
[12:44:50] <cmr> Yes
[12:44:52] <mark_edward> i know it's a language
[12:44:58] <doomlord_> i actually think it would be interesting if rust compiled to C ... i know thats an unpopular suggestion though.  IMO 'mid level langauges' like c++,objC,rust can complement C instead of trying to replace it
[12:45:04] <mark_edward> but who is goign to do all that work before rust hits mainstream
[12:45:04] <jensnockert> bjz: Not really, no.
[12:45:13] <dbaupp> bjz: do other languages make any effort to share the stdlib implementations between compilers?
[12:45:26] <bjz> dbaupp: I don't think so
[12:45:30] <dbaupp> so, just thinking about it, it might not be a huge concern...
[12:45:32] <cmr> mark_edward: just because nobody is going to do it doesn't mean we should couple the language to a specific implementation
[12:45:38] <mark_edward> true
[12:45:49] <jensnockert> bjz: MSVC uses Intel syntax for ASM, while GCC/Clang uses AT&T for example.
[12:46:02] <jensnockert> bjz: Constraints etc. also vary.
[12:46:42] <dbaupp> gah, I don't want to push this new version of IRFY... but i'm gonna have to do it sometime
[12:46:44] * dbaupp sighs
[12:46:51] * jensnockert hugs dbaupp
[12:47:05] <bjz> dbaupp: tbh, I don't think it's a huge issue within std
[12:47:05] <cmr> doomlord_: I think there's a C backend for llvm
[12:47:20] <mnemotic> dbaupp: ::shipit::
[12:47:22] <dbaupp> bjz: yeah, I don't disagree (anymore)
[12:47:28] <cmr> doomlord_: what advantage would generating C confer?
[12:47:33] <cmr> is the FFI insufficient?
[12:47:41] *** Joins: KindOne (KindOne@moz-E11303C3.dynamic.ip.windstream.net)
[12:47:51] <bjz> dbaupp: I have a bigger concern about making llvm! easy to use in client code
[12:48:01] <dbaupp> bjz: right
[12:48:03] *** Quits: Earnestly (earnest@2A2BF8F5.321FA5E6.BFD1ABFD.IP) (Ping timeout)
[12:48:09] <doomlord> places where you might have a c compiler but no llvm
[12:48:28] <gour> hmm
[12:48:43] <dbaupp> bjz: I looked at implementing it a while ago, but I couldn't find any other language that provided something similar (not even clang!), so I gave up :(
[12:48:45] <doomlord> strange DSPs.. game console with proprietary compiler .. 
[12:49:09] *** Joins: KindTwo (KindOne@moz-BD665EC4.dynamic.ip.windstream.net)
[12:49:12] <bjz> dbaupp: like, perhaps it could be possible to use llvm! in client code, but the ergonomics could be engineered to make it painful
[12:49:35] *** Quits: KindOne (KindOne@moz-E11303C3.dynamic.ip.windstream.net) (Ping timeout)
[12:50:11] <doomlord> i suppose a more productive endevour would be to contribute to LLVM though & port it , if one had no llvm support
[12:50:22] *** KindTwo is now known as KindOne
[12:50:30] <aatch> done. 129 errors worth of lifetime annotations added to librustc
[12:50:46] <bjz> aatch: what was that?
[12:50:55] *** Joins: Earnestly (earnest@2A2BF8F5.321FA5E6.BFD1ABFD.IP)
[12:51:03] *** Quits: doomlord (doomlod@moz-6651F8D4.range86-145.btcentralplus.com) (Quit: Leaving)
[12:51:12] *** Joins: doomlord (doomlod@moz-6651F8D4.range86-145.btcentralplus.com)
[12:51:14] <cmr> doomlord_: yeah. and there *is* a C backend for llvm
[12:51:18] *** Quits: doomlord (doomlod@moz-6651F8D4.range86-145.btcentralplus.com) (Connection reset by peer)
[12:51:29] <cmr> aatch: and it works?
[12:51:44] <aatch> bjz, making the ast_map not use @
[12:51:52] <aatch> cmr, nope, this is just this step
[12:51:53] <bjz> aatch: yay!
[12:52:20] <bjz> aatch: de@ing?
[12:52:51] <aatch> now I have to thread the lifetimes through everywhere it doesn't mind there being an anonymous lifetime, but needs one anyway
[12:52:56] <bjz> jensnockert: how did you go on that numeric conversion thingy?
[12:53:19] <aatch> bjz, yep, the AST map is a blocker
[12:53:27] <MaikKlein> is there somewhere a open PR for the new_visitor?
[12:53:28] <jensnockert> bjz: Partially, I have a patch, but I think it doesn't work for Big(U)Int.
[12:53:38] <bjz> jensnockert: ooh!
[12:53:41] <aatch> MaikKlein, no, because it needs a snapshot.
[12:53:52] <geomyidae> https://github.com/brson/rust/tree/io/src/libstd/rt/io/net :(
[12:54:15] <jensnockert> I wish bigint was twos-complement, and used word-sized blocks :S
[12:54:56] <bjz> jensnockert: do you think it should be changed?
[12:55:00] *** Quits: int3_ (int3_@moz-ABE52D50.hsd1.ca.comcast.net) (Client exited)
[12:55:01] <cmr> geomyidae: there's no work on the actual io code yet afaik
[12:55:06] <cmr> geomyidae: it's all in the rt
[12:55:31] <jensnockert> bjz: I assume it is done this way because there isn't a simple way to do add-with-carry in Rust yet.
[12:55:36] *** Joins: int3_ (int3_@moz-ABE52D50.hsd1.ca.comcast.net)
[12:55:39] *** Quits: quvarxa (chatzilla@moz-978E4C31.static.tpgi.com.au) (Quit: ChatZilla 0.9.90 [Firefox 23.0/20130703181823])
[12:56:04] <jensnockert> But once there is, you could simplify it, by dropping the silly sign/zero bits.
[12:56:18] <bjz> jensnockert: I think gifnksm was behind it
[12:56:26] <bjz> dunno if he's on irc
[12:57:05] <cmr> dbaupp: so using extra::json::Object doesn't let me use Object::new
[12:57:18] <bjz> jensnockert: you could just be awful and set it to fail for Big(U)Int
[12:57:20] *** Quits: int3_ (int3_@moz-ABE52D50.hsd1.ca.comcast.net) (Ping timeout)
[12:57:20] <cmr> Object is a typedef to HashMap<~str, Json>
[12:57:24] <bjz> jensnockert: :D
[12:57:33] <jensnockert> bjz: But that would be against the point, wouldn't it?
[12:57:38] *** Quits: MaikKlein (maik@moz-CA56C650.dip0.t-ipconnect.de) (Ping timeout)
[12:57:38] <dbaupp> cmr: right, typedefs don't get static methods.
[12:57:44] <aatch> cmr, HashMap::new()
[12:57:46] <cmr> gah
[12:57:47] *** Quits: Earnestly (earnest@2A2BF8F5.321FA5E6.BFD1ABFD.IP) (Ping timeout)
[12:58:05] *** Joins: relistan (relistan@moz-2DE8112B.cable.virginmedia.com)
[12:58:19] <bjz> jensnockert: well, as in, we'd then get gifnksm to do the conversions for them
[12:58:40] <jensnockert> I'll try and find him.
[12:59:08] <bjz> or you could get him to push to your branch
[13:00:43] <aatch> current state of my branch, 114 changed files with 2,499 additions and 1,856 deletions
[13:00:59] *** Quits: untitaker (yaaic@moz-BFC77EB9.adsl.highway.telekom.at) (Ping timeout)
[13:03:02] *** Quits: km (quassel@FDBAF0A0.DBF71E41.29C67456.IP) (Ping timeout)
[13:03:15] *** Joins: km (quassel@FDBAF0A0.DBF71E41.29C67456.IP)
[13:04:15] *** Joins: pauls_ (paul@moz-9B39917C.c3-0.smr-ubr2.sbo-smr.ma.cable.rcn.com)
[13:04:17] <doener> r? this is really hard to debug :(
[13:04:17] <doener> 01:18:46  * strcat has just been blindly editing based on greps
[13:04:17] <doener> 01:18:47 -!- naq has joined #rust
[13:04:17] <doener> 01:18:49  * dbaupp quite likes his implementation of visvalignam
[13:04:21] <doener> dammit!
[13:04:25] <doener> r? https://github.com/mozilla/rust/pull/7636
[13:04:27] <dbaupp> aatch: I'm currently at `251 files changed, 57155 insertions(+), 56987 deletions(-)`
[13:04:36] <dbaupp> doener: I get this sense of deja vu
[13:04:46] <aatch> dbaupp, what's that for?
[13:04:57] <dbaupp> aatch: folder migrations for irfy
[13:05:03] <doener> dbaupp: yeah, had the box running over night to benchmark the test suite, so it's still the same messed up clipboard
[13:05:08] <dbaupp> aatch: apparently I have some huge librares or something
[13:05:14] <doener> dbaupp: must be something I changed in my tmux configuration
[13:05:29] <dbaupp> doener: heh
[13:05:43] <dbaupp> doener: benchmarking that pr?
[13:05:55] <doener> dbaupp: yeah
[13:06:06] <dbaupp> doener: that's a pretty nice speed up
[13:06:10] <doener> dbaupp: the nopt testsuite runs quite it bit faster :-)
[13:06:22] <doener> cpu time this is really hard to debug :(
[13:06:22] <doener> 01:18:46  * strcat has just been blindly editing based on greps
[13:06:22] <doener> 01:18:47 -!- naq has joined #rust
[13:06:22] <doener> 01:18:49  * dbaupp quite likes his implementation of visvalignam
[13:06:27] <doener> aergH!
[13:06:38] * dbaupp does like his implementation of visvalignam
[13:06:45] <doener> cputime goes from 80m56.405s to 69m6.580s
[13:06:58] <dbaupp> nice
[13:07:09] <dbaupp> bors might get faster... :D
[13:07:11] <doener> wall clock just from 22m56.803s to 21m13.328s
[13:07:15] <doener> yeah, I hope so
[13:07:19] *** Joins: yong (chatzilla@74DA0C97.4E87ADC2.263D9828.IP)
[13:07:33] <dbaupp> (it'll be valgrind blocking it now though.)
[13:08:03] <doener> currently bors clocks in at about 60 minutes for the testsuite, so maybe we win 7 minutes or so
[13:08:39] <aatch> I'll deal with the lifetime errors later
[13:08:47] <aatch> now is time for sleep
[13:08:56] <doener> good night!
[13:09:06] <mnemotic> nn
[13:09:31] *** Quits: aatch (aatch@moz-2BB0AC01.cable.telstraclear.net) (Client exited)
[13:10:54] *** Joins: Earnestly (earnest@2A2BF8F5.321FA5E6.BFD1ABFD.IP)
[13:15:10] *** Quits: Sindwiller (quassel@moz-743130B2.dynamic.hispeed.ch) (Connection reset by peer)
[13:17:06] <dbaupp> cmr: does 0.6 build now?
[13:17:20] *** Joins: gour_ (gour@moz-DD806E2F.adsl.net.t-com.hr)
[13:17:30] *** Quits: gour (gour@moz-F18C6C0D.adsl.net.t-com.hr) (Ping timeout)
[13:17:33] <dbaupp> it'd be awesome to be able to say "look how much better 0.7 is"
[13:19:47] <mark_edward> doener: that's a pretty boss PR
[13:20:12] <doener> mark_edward: took me a week to get that right
[13:20:40] <cmr> dbaupp: added to the fancy override list
[13:20:53] <dbaupp> cmr: :D
[13:21:01] <mark_edward> You get a Hero of Rust medal
[13:21:02] * dbaupp hopes this works
[13:21:08] * mark_edward gives medal
[13:21:10] <doener> mark_edward: heh, thanks ;-)
[13:21:30] <dbaupp> mark_edward: doener deserves at least 10 for the perf work he's done
[13:22:06] * mark_edward has to build a metal shop in his closet
[13:22:37] <cmr> dbaupp: irsy paints a pretty downward slope
[13:22:52] <dbaupp> cmr: it's very nice :)
[13:23:09] * dbaupp is preparing an email to the ML
[13:23:19] <dbaupp> (just waiting on 0.6, if that comes in.)
[13:23:19] <cmr> dbaupp: the color selection for irsy's commit picker could be a lot better
[13:23:36] <dbaupp> cmr: it just takes the first 6 hex digits as the colour
[13:23:39] <cmr> I know
[13:23:49] <cmr> I'm looking at two that I can't visually distinguish though :p
[13:23:50] *** Joins: nano (nano@moz-972880B.superkabel.de)
[13:23:59] <dbaupp> link?
[13:24:00] <cmr> f254d11 and e946b4f
[13:24:03] <cmr> http://huonw.github.io/isrustfastyet/mem/#88487d8,e946b4f,f254d11
[13:24:06] <cmr> fancy, linkable
[13:24:24] <dbaupp> haha, yeah, that's not great
[13:24:47] <jensnockert> Medals?! I like medals!
[13:24:56] <jensnockert> Hard to make them rusty thoughâ€¦
[13:24:57] <dbaupp> (although e9 is very slightly dark on my screen.)
[13:25:28] <cmr> I can distinguish them on the graph, but takes a lot of effort int hte list
[13:25:33] <dbaupp> right
[13:25:35] *** Quits: pyrac (pyrac@moz-18D74BD0.w90-60.abo.wanadoo.fr) (Quit: pyrac)
[13:25:49] *** Joins: int3_ (int3_@moz-ABE52D50.hsd1.ca.comcast.net)
[13:25:50] <cmr> maybe when you highlight something in the list, that line turns some color, or gets a highlight or something?
[13:25:50] <dbaupp> yeah, I'm afraid that's a bit of a WONTFIX :(
[13:26:01] <dbaupp> oh, maybe
[13:26:23] <jensnockert> Also, my Rust AES implementation works \o/
[13:26:29] *** Quits: spider-mario (spidermari@moz-81131DB6.fbx.proxad.net) (Input/output error)
[13:26:36] <jensnockert> ECB and CBC modes work!
[13:26:37] <dbaupp> (but I want the colours to be the same for a commit always, so there's always going to be a problem of similar colours)
[13:26:47] <cmr> right
[13:27:01] <cmr> it's fine as long as there is some way I can distinguis them even if it needs manual intervention
[13:27:18] <cmr> maybe clicking on it in the list could double the thickness
[13:27:20] <cmr> anything!
[13:27:20] <dbaupp> enabling/disabling 'passes'?
[13:27:33] <cmr> that works
[13:27:43] <cmr> for when they're dissimilar, at least
[13:27:45] <dbaupp> yeah, hovering over the card could double the thickness, good idea
[13:28:06] <dbaupp> however, I'm busy breaking links right now... :S
[13:28:16] * dbaupp apologises in advance
[13:28:16] <cmr> cool links don't break, man
[13:28:26] <dbaupp> I know :'(
[13:29:09] <dbaupp> there we go...
[13:29:23] <dbaupp> IRFY now has a shitty landing page, and a shitty about page.
[13:30:01] * dbaupp waits for github pages to update
[13:30:12] <cmr> I see the new pages
[13:30:25] <cmr> The very least you could do is center body on the page :p
[13:30:25] <jensnockert> I wish we could have ASCII strings in Rustâ€¦
[13:30:36] <dbaupp> cmr: which body?
[13:30:38] <jensnockert> No idea why my string breaks tbh, ASCII should be UTF8.
[13:30:41] <cmr> dbaupp: the html body
[13:30:47] <dbaupp> cmr: I have a feeling the css isn't updated or something
[13:31:01] <cmr> ah
[13:31:01] <dbaupp> cmr: because it's centered for me
[13:31:05] <cmr> well then
[13:31:08] <cmr> silly github pages!
[13:31:12] *** Quits: int3_ (int3_@moz-ABE52D50.hsd1.ca.comcast.net) (Ping timeout)
[13:31:22] <cmr> and their silly caching, trying to make it "efficient"
[13:31:33] <cmr> dbaupp: I think 0.6 will build if I do a clean-llvm
[13:31:45] <cmr> I'll add that step to benchit, with ccache it's not too huge of a hit
[13:31:48] <dbaupp> cmr: right, yeah, I see it too... no CSS :/
[13:32:02] <dbaupp> cmr: awesome
[13:34:34] *** Parts: mnemotic (niko@8FFD1BD2.9D81E74C.53DF0002.IP) ()
[13:35:09] *** gour_ is now known as gour
[13:35:11] <krdln> how to open file in rust? this doesn't work for me
[13:35:21] <krdln> rusti: use std::{io,path}; io::file_reader(GenericPath::from_str("foo"));
[13:35:22] -rusti- <anon>:7:45: 7:66 error: failed to find an implementation of trait std::path::GenericPath for &std::path::PosixPath
[13:35:22] -rusti- <anon>:7          use std::{io,path}; io::file_reader(GenericPath::from_str("foo"));
[13:35:22] -rusti-                                                       ^~~~~~~~~~~~~~~~~~~~~
[13:35:22] -rusti- application terminated with error code 101
[13:35:37] <cmr> krdln: use Path("foo")
[13:36:00] <krdln> mismatched types
[13:36:07] <cmr> Are you using 0.7?
[13:36:11] <krdln> yup
[13:36:13] *** Joins: pyrac (pyrac@moz-18D74BD0.w90-60.abo.wanadoo.fr)
[13:36:46] *** Joins: MaikKlein (maik@moz-CA56C650.dip0.t-ipconnect.de)
[13:36:51] <mark_edward> jensnockert: your AES stuff, can i see it?
[13:36:56] <mark_edward> is it on github?
[13:37:04] <jensnockert> mark_edward: Not yet, but I can upload it.
[13:37:09] <jensnockert> mark_edward: Wait a minute.
[13:37:16] <dbaupp> cmr: ah, that was my screwup
[13:37:28] <mark_edward> is it your own project, or are you trying to get some crypto into extra?
[13:37:31] <dbaupp> cmr: hopefull y it's gonna have the CSS soon now.
[13:37:38] *** Joins: BitPuffin (quassel@moz-911FB3CE.cust.tele2.se)
[13:38:14] <jensnockert> mark_edward: Well, it is my own project, but it would be nice if it got merged into extra?
[13:38:34] <cmr> I'd be very hesitant to include any crypto at all into extra
[13:38:51] <cmr> Until it is proven resistant to esp timing attacks
[13:38:54] <MaikKlein> yeah crypto is very hard to get right :(
[13:39:21] <jensnockert> cmr: OpenSSL is not resistant to timing attacks.
[13:39:42] <cmr> then we shouldn't include it in extra
[13:40:03] <jensnockert> cmr: You will never be able to write timing attack resistant code in Rust
[13:40:25] <jensnockert> I don't even think most primitives can be made timing attack resistant.
[13:40:27] <krdln> cmr: ok, I'm stupid, ~Path worked
[13:41:18] <dbaupp> jensnockert: isn't go's crypto stuff timing-attack resistant?
[13:41:24] <jensnockert> dbaupp: I doubt it.
[13:41:54] *** Quits: Jesse (jruderman@moz-537BCF9.hsd1.ca.comcast.net) (Quit: Jesse)
[13:43:11] <cmr> dbaupp: of course, ccache doesn't help when it's an old version of llvm I've never built
[13:43:14] <dbaupp> it seems that their aes implementation is in asm, but that's no guarantee of strength
[13:43:14] <cmr> this'll be a while
[13:43:22] *** Quits: sigma1 (sigma@51C589B3.EF2694B5.DFAC6AA7.IP) (Ping timeout)
[13:43:27] <dbaupp> cmr: oh :(
[13:43:58] <dbaupp> (the CSS is slowly appearing on different pages,btw)
[13:45:39] <cmr> jensnockert: I remembered incorrectly, you're right.
[13:46:09] <jensnockert> About?
[13:46:12] <cmr> timing attacks
[13:46:35] <jensnockert> Still, I think it is a valid concern.
[13:46:49] <cmr> dbaupp: ah, fancy stuff with the css
[13:46:51] <jensnockert> But the people who need to protect against them, hopefully know what they are doing.
[13:47:19] <engla> lots of users of crypto don't know what they are doing
[13:48:05] <dbaupp> engla: many *writers* of crypto don't know what they're doing
[13:48:07] <dbaupp> :(
[13:48:18] <cmr> jensnockert: Any crypto should have warnings in the docs that it's not a robust, secure implementation, until its thoroughly audited and stuff. I'd be ok with that
[13:48:20] *** Joins: sigma1 (sigma@51C589B3.EF2694B5.DFAC6AA7.IP)
[13:48:30] <cmr> "A collection of poorly written scripts, and badly authored HTML, which collates data from several (well, 2) sources and turns it into graphs."
[13:48:32] <cmr> nice :p
[13:48:45] <engla> crypto can't rely on abstractions. For example when verifying a MAC you need a constant-time memcmp for that size.. you have to know your compiler to be sure
[13:48:53] <jensnockert> cmr: Yes.
[13:48:58] <dbaupp> cmr: it's true ;P
[13:49:12] <jensnockert> engla: Also, cache misses.
[13:49:23] * dbaupp is the world's most prolific producer of spaghetti
[13:49:24] <engla> yeah
[13:49:55] <jensnockert> engla: Also silliness, like that stuff in the front of a cache line loads faster than at the end.
[13:50:42] <ChrisMorgan> What's the current opinion of the branding pattern, as advocated in http://pcwalton.github.io/blog/2012/12/26/typestate-is-dead/?
[13:51:13] <jensnockert> mark_edward: https://github.com/jensnockert/crypto.rs
[13:51:27] *** Quits: maxli (maxli@B5559308.9C54E60.2FA4EA88.IP) (Quit: Leaving.)
[13:51:36] *** Quits: yong (chatzilla@74DA0C97.4E87ADC2.263D9828.IP) (Quit: ChatZilla 0.9.90 [Firefox 21.0/20130511120803])
[13:52:05] <jensnockert> dbaupp: *most* writers of crypto don't know what they are doing.
[13:52:20] <jensnockert> I think I am at the stage where I know that I am doing crazy stuff.
[13:52:21] *** Joins: yong (chatzilla@74DA0C97.4E87ADC2.263D9828.IP)
[13:52:58] <dbaupp> jensnockert: that's a neat hack to get around the traits-in-std thing
[13:53:17] <jensnockert> dbaupp: Redefining the SIMD vectors in simd.rs?
[13:53:27] <dbaupp> yeah
[13:53:49] <dbaupp> (it's cool how compiler "built-ins" aren't really.)
[13:54:07] <jensnockert> I wish you could do similar stuff with all types.
[13:54:22] <MaikKlein> aren't there secure c crypto libs that we can port?
[13:54:51] <jensnockert> MaikKlein: You need CPU model specific ASM to be even close to resistant to local timing attacks.
[13:54:56] <mark_edward> jensnockert: cool library
[13:55:32] <MaikKlein> jensnockert, so it will probably will never be secure to timing attacks?
[13:56:08] <jensnockert> MaikKlein: I'll never be able to code anything resistant to timing attacks, even though I'll of course try to avoid the most obvious mistakes.
[13:56:29] <jensnockert> (No short-circuiting comparison etc.)
[13:57:53] <jensnockert> (And most certainly no allocations)
[13:58:35] *** Quits: FrozenCow (FrozenCow@moz-B2DF4929.chello.nl) (Ping timeout)
[14:01:44] <engla> maybe it's possible to wrap libsodium
[14:02:05] *** Joins: ghrust (ghrust@C8693FCB.6A2AE50.F3114085.IP)
[14:02:05] <ghrust> 01[13rust01] 15bors merged 06auto into 06master: 02http://git.io/bk3y7g
[14:02:05] *** Parts: ghrust (ghrust@C8693FCB.6A2AE50.F3114085.IP) ()
[14:02:21] <cmr> slow down bors!
[14:02:38] <engla> awesome
[14:03:41] *** Quits: Earnestly (earnest@2A2BF8F5.321FA5E6.BFD1ABFD.IP) (Ping timeout)
[14:03:56] <dbaupp> do we have less @ in libsyntax?
[14:04:01] <cmr> we do now
[14:04:08] <dbaupp> yay, we do \o/
[14:04:25] <dbaupp> cmr: also, just pushing hover-to-emphasise :)
[14:04:37] <jensnockert> engla: That would probably work.
[14:05:06] *** Joins: ghrust (ghrust@AC22872E.6A2AE50.F3114085.IP)
[14:05:06] <ghrust> 01[13rust01] 15bors pushed 0 new commits to 06auto: 02http://git.io/2n9OpQ
[14:05:06] *** Parts: ghrust (ghrust@AC22872E.6A2AE50.F3114085.IP) ()
[14:05:07] *** Joins: ghrust (ghrust@E7A4CCE2.6A2AE50.F3114085.IP)
[14:05:07] <ghrust> 01[13rust01] 15bors pushed 2 new commits to 06auto: 02http://git.io/uy79kg
[14:05:07] <ghrust> 13rust/06auto 14e9ce97c 15AljazÌŒ "g5pw" SrebrnicÌŒ: Copy the correct libs when using local-rust-root...
[14:05:07] <ghrust> 13rust/06auto 140b36b88 15bors: auto merge of #7586 : g5pw/rust/master, r=cmr...
[14:05:08] *** Parts: ghrust (ghrust@E7A4CCE2.6A2AE50.F3114085.IP) ()
[14:05:40] <engla> of course libsodium is basically a new library that's untested. even if djb's underlying code has been around for a bit
[14:06:09] <MaikKlein> what the heck is \o/ ?
[14:06:24] <MaikKlein> is this a cheering guy?
[14:06:24] <monk> a person raising their arms in the air xD
[14:06:27] <jensnockert> Problem is that it only includes secure stuff :S
[14:06:29] <MaikKlein> haha
[14:06:38] <jensnockert> mark_edward: Yes.
[14:06:44] <jensnockert> MaikKlein: Yes.
[14:06:56] <jensnockert> mark_edward: Sorry, didn't mean to ping you, so I do it again.
[14:07:02] <engla> jensnockert: yeah it's a protocol of its own
[14:07:17] <dbaupp> mark_edward: I don't mean to ping you either
[14:07:18] <mark_edward> lol, no problem
[14:07:25] * jensnockert hugs mark_edward
[14:07:27] <dbaupp> ;P
[14:07:29] <mark_edward> i enjoy being pinged.
[14:07:39] <mark_edward> every bit of attention validates my existence
[14:07:42] <mark_edward> :P
[14:08:09] <dbaupp> rusti: for 4u.times { println("mark_edward: ping"); }
[14:08:10] -rusti- mark_edward: ping
[14:08:10] -rusti- mark_edward: ping
[14:08:10] -rusti- mark_edward: ping
[14:08:10] -rusti- mark_edward: ping
[14:08:11] -rusti- ()
[14:08:22] <mark_edward> clever!
[14:08:46] <dbaupp> cmr: pushed... should be able to distinguish between identically coloured commits now ;)
[14:09:07] <cmr> sure can!
[14:09:37] <dbaupp> yay
[14:11:18] *** Joins: pnathan1 (Adium@B9840254.2CD8A5F8.477B877D.IP)
[14:12:47] <MaikKlein> rusti: println("/me I am bored");
[14:12:48] -rusti- /me I am bored
[14:12:48] -rusti- ()
[14:12:51] <MaikKlein> :(
[14:13:03] <cmr> MaikKlein: want an issue to work on?
[14:13:13] <MaikKlein> cmr, what issue?
[14:13:23] <cmr> I dunno, do you want one? :p
[14:13:45] <MaikKlein> cmr, yeah but I have no time atm :( but I am free at the hm 22th
[14:13:59] <MaikKlein> I am writing all my exams now :(
[14:14:02] *** Joins: ghrust (ghrust@1E8607E8.6A2AE50.F3114085.IP)
[14:14:02] <ghrust> 01[13rust01] 15bors 04force-pushed 06auto from 140b36b88 to 140f25155: 02http://git.io/N3iJvQ
[14:14:02] *** Parts: ghrust (ghrust@1E8607E8.6A2AE50.F3114085.IP) ()
[14:14:06] *** Joins: ghrust (ghrust@1E8607E8.6A2AE50.F3114085.IP)
[14:14:06] <ghrust> 01[13rust01] 15bors pushed 2 new commits to 06auto: 02http://git.io/Ra-6XQ
[14:14:06] <ghrust> 13rust/06auto 148f973bb 15Alex Crichton: Fix a warning when generating tests
[14:14:06] <ghrust> 13rust/06auto 14c3bd965 15bors: auto merge of #7591 : alexcrichton/rust/fix-warnings, r=huonw...
[14:14:06] *** Parts: ghrust (ghrust@1E8607E8.6A2AE50.F3114085.IP) ()
[14:14:07] <cmr> ah
[14:14:51] <ChrisMorgan> So, you can do struct S<T>, but not struct S<T: MyTrait>. Why's that?
[14:14:57] <MaikKlein> cmr, but I definitely want to work on rustdoc because it is very similar to the auto complete that I want to do.
[14:15:35] <dbaupp> ChrisMorgan: either: same reason you can't do it in Haskell, or it's a bug
[14:15:47] <engla> ChrisMorgan: you don't need trait bounds on structs though
[14:16:00] <ChrisMorgan> Why not? That should go on the impl, should it?
[14:16:04] <engla> yes
[14:16:20] <ChrisMorgan> Kinda seems messy that way.
[14:16:26] <dbaupp> ChrisMorgan: http://www.haskell.org/haskellwiki/Data_declaration_with_constraint
[14:17:23] *** Quits: pnathan1 (Adium@B9840254.2CD8A5F8.477B877D.IP) (Ping timeout)
[14:17:26] <engla> but it doesn't really belong with the struct
[14:17:34] *** Quits: pyrac (pyrac@moz-18D74BD0.w90-60.abo.wanadoo.fr) (Quit: pyrac)
[14:18:10] <engla> it's redundant there and the bounds would have to be written out in impls anyway
[14:18:17] *** Quits: MaikKlein (maik@moz-CA56C650.dip0.t-ipconnect.de) (Ping timeout)
[14:18:19] *** Joins: offline (offline@moz-202FF72A.dip0.t-ipconnect.de)
[14:18:33] <ChrisMorgan> rusti: struct S<T>; impl S<T: MyTrait> {}
[14:18:34] -rusti- more than 5 lines of output, pastebinned: http://sprunge.us/UQBe
[14:18:42] *** Joins: pyrac (pyrac@moz-18D74BD0.w90-60.abo.wanadoo.fr)
[14:19:02] <cmr> rusti: struct S<T>; impl<T: ToStr> S<T> {}
[14:19:03] -rusti- ()
[14:19:07] <ChrisMorgan> rusti: trait MyTrait{} struct S<T>; impl S<T: MyTrait> {}
[14:19:07] -rusti- <anon>:7:45: 7:55 error: use of undeclared type name `T`
[14:19:08] -rusti- <anon>:7          trait MyTrait{} struct S<T>; impl S<T: MyTrait> {}
[14:19:08] -rusti-                                                       ^~~~~~~~~~
[14:19:08] -rusti- error: aborting due to previous error
[14:19:08] -rusti- application terminated with error code 101
[14:19:24] <ChrisMorgan> Oh, so it goes on the impl. Thanks.
[14:20:02] <engla> you can have multiple impl blocks with different bounds. The methods don't overlap, though
[14:20:15] <cmr> can't, not don't :p
[14:20:27] <engla> can't so they don't hehe
[14:21:00] <ChrisMorgan> That can easily lead to problems if you ever let structs be created that don't match that, somehow... then you'd be getting compile errors "X<Y> doesn't implement method Z".
[14:21:16] <ChrisMorgan> I presume the solution to that is using constructors.
[14:21:17] <dbaupp> ChrisMorgan: right
[14:21:29] <dbaupp> yeah, if you want to shield the user from that
[14:23:21] <engla> it would be possible to create empty hashmaps with any type of key, but the public hashmap api doesn't allow it
[14:23:25] *** Joins: bjz_ (brendanzab@B398BE78.F804C29E.D35A31DF.IP)
[14:23:29] *** Quits: bjz (brendanzab@B398BE78.F804C29E.D35A31DF.IP) (Connection reset by peer)
[14:23:54] <ChrisMorgan> So, what's the general opinion at present with regards to the  branding pattern as mentioned at http://pcwalton.github.io/blog/2012/12/26/typestate-is-dead/ ?
[14:24:23] <dbaupp> I haven't seen it used much at all
[14:24:28] <cmr> Neither have I
[14:24:34] <cmr> It seems more-or-less fine though
[14:25:00] <cmr> Although I'm not sure you couldn't use enums for the same purpose?
[14:25:12] <dbaupp> I've experimented with it (as has aatch), and it was tricky to get to work with rust's type system at points
[14:25:13] <smvv_> prior to 0.7, this snippet worked: https://gist.github.com/smvv/5943633. why is rust saying that f is moved out? does this have to do with f being inside the closure?
[14:25:24] <dbaupp> cmr: that's not type level information
[14:25:26] <engla> for a file handle in particular, I think ~File is enough
[14:25:45] <dbaupp> smvv_: without looking at it, you might need to rewrap f in a new closure
[14:25:48] * dbaupp checks
[14:26:08] <dbaupp> smvv_: right yeah, |bytes| f(bytes) should work
[14:26:31] <cmr> Closures are really weird
[14:26:41] <cmr> I hope the reform cleans them up, I don't understand them at all
[14:26:43] <bstrie> rusti: let (mut x, y) = (1, 2); x
[14:26:44] -rusti- more than 5 lines of output, pastebinned: http://sprunge.us/GPLY
[14:26:59] <ChrisMorgan> Contemplating what to do when writing an HTTP response; can have write() call write_headers() if it hasn't been called and have write_headers() fail! if called twice, but I was contemplating using that style of branding pattern instead, whereby you just about can't call write_headers twice.
[14:27:10] <dbaupp> smvv_: https://github.com/mozilla/rust/wiki/Doc-under-construction-FAQ#noncopyable-stack-closures
[14:27:39] <smvv_> changing to  unsafe { vec::raw::buf_as_slice(data, len, |data| f(data)) } works indeed. thanks :)
[14:28:29] *** Quits: offline (offline@moz-202FF72A.dip0.t-ipconnect.de) (Quit: oO0°)
[14:28:52] *** Joins: cubic (cubic@moz-FE5AD6C7.mc.videotron.ca)
[14:30:56] *** Quits: BitPuffin (quassel@moz-911FB3CE.cust.tele2.se) (Ping timeout)
[14:31:12] <cmr> km: did you figure out the FFI weirdness?
[14:31:42] <dbaupp> ChrisMorgan: that'd be neat if you got it to work!
[14:32:16] <ChrisMorgan> dbaupp: it looks like it should work and is fairly straightforward.
[14:32:27] <dbaupp> ChrisMorgan: (note that the modern version would just be `struct Open;` and `struct Closed;`)
[14:32:38] <ChrisMorgan> Yep, I figured that part out
[14:33:25] *** Joins: doomlord (doomlod@moz-6651F8D4.range86-145.btcentralplus.com)
[14:34:04] <dbaupp> ChrisMorgan: unit-structs don't work cross crate, I think, so it might have to be enum Open { Open } and enum Closed { Closed } (if you want to be able to construct values of each type), or even just `enum Open {} enum Closed {}`(if you only need the type)
[14:34:49] <cmr> (they don't)
[14:34:51] *** Joins: BitPuffin (quassel@moz-911FB3CE.cust.tele2.se)
[14:35:32] <doomlord> if you input a type into a generic, is there a way of referencing contained types (let me provide an example to clarify..)
[14:36:10] <doomlord> impl<TILE> TiledArray<TILE>   { ..... TILE::Element}      <<< TILE would be[T,..TileSize]
[14:36:27] <doomlord> ... want to reference T in implementeation code
[14:37:11] <doomlord> as a workaround i could say TiledArray<T,TILE>   and you instantiate it TiledArray<float,[float,..8]>  for 8-element tiles
[14:37:21] <doomlord> just wonddering if there is a neater way
[14:37:44] <dbaupp> nope
[14:38:03] <dbaupp> Rust doesn't have higher-kinded types (yet, I hope.)
[14:38:12] <ChrisMorgan> Hang on, once it's struct X<T> I can't have an X::new method, can I.
[14:38:31] <doomlord> i suppose i can fudge it like this then say TiledArray8<T> = TiledArray<T,[T,..8]>   TiledArray16=... etc
[14:39:10] <cmr> ChrisMorgan: why not?
[14:39:24] <ChrisMorgan> I mean, it then needs type arguments.
[14:39:34] <ChrisMorgan> Thingummies. Whatever they are.
[14:39:50] *** Joins: MaikKlein (maik@moz-CA56C650.dip0.t-ipconnect.de)
[14:39:56] <dbaupp> ChrisMorgan: only if the function returns a generic struct
[14:40:28] <dbaupp> ChrisMorgan: if you have `fn new() -> HTTP<NoHeaders> { .. }` then it's fine
[14:40:47] <dbaupp> (where NoHeaders is a concrete type)
[14:40:49] <cmr> Hang on a sec, this is encoding a state machine into the type system?
[14:41:00] <dbaupp> cmr: essentially
[14:41:02] <cmr> whoa
[14:41:05] *** Joins: ghrust (ghrust@5FEF1C87.6A2AE50.F3114085.IP)
[14:41:05] <ghrust> 01[13rust01] 15bors 04force-pushed 06auto from 14c3bd965 to 140f25155: 02http://git.io/N3iJvQ
[14:41:05] *** Parts: ghrust (ghrust@5FEF1C87.6A2AE50.F3114085.IP) ()
[14:41:05] *** Joins: reyre_ (reyre@moz-9002CDDA.cpe.net.cable.rogers.com)
[14:41:07] *** Joins: ghrust (ghrust@24260B07.6A2AE50.F3114085.IP)
[14:41:07] <ghrust> 01[13rust01] 15bors pushed 3 new commits to 06auto: 02http://git.io/mVBWyg
[14:41:07] <ghrust> 13rust/06auto 14bbfef92 15Chris Morgan: Move `extra::net_*` to `extra::net::*` properly....
[14:41:07] <ghrust> 13rust/06auto 14b6024e4 15Chris Morgan: Remove superfluous super::super::
[14:41:07] <ghrust> 13rust/06auto 14005c9bd 15bors: auto merge of #7594 : chris-morgan/rust/proper-net-module-structure, r=huonw...
[14:41:09] *** Parts: ghrust (ghrust@24260B07.6A2AE50.F3114085.IP) ()
[14:43:47] <ChrisMorgan> rusti: struct Y; struct X<T>; impl X { fn new() -> X<Y> { X<Y>{} } }
[14:43:47] -rusti- <anon>:7:37: 7:39 error: wrong number of type arguments: expected 1 but found 0
[14:43:48] -rusti- <anon>:7          struct Y; struct X<T>; impl X { fn new() -> X<Y> { X<Y>{} } }
[14:43:48] -rusti-                                               ^~
[14:43:48] -rusti- application terminated with error code 101
[14:44:18] <roo> you could go one better an use uninhabited enums
[14:44:40] <ChrisMorgan> Whoa!
[14:44:45] <cmr> rusti: struct Y; struct X<T>; impl X<Y> { fn new() -> X<Y> { X<Y>{} } }
[14:44:45] <ChrisMorgan> rusti: struct Y; struct X<T>; impl<T> X<T> { fn new() -> X<Y> { X<Y>{} } }
[14:44:46] -rusti- <anon>:7:66: 7:69 error: binary operation < cannot be applied to type `main::X<<V0>>`
[14:44:46] -rusti- <anon>:7          struct Y; struct X<T>; impl<T> X<T> { fn new() -> X<Y> { X<Y>{} } }
[14:44:46] -rusti-                                                                            ^~~
[14:44:46] -rusti- error: aborting due to previous error
[14:44:47] -rusti- application terminated with error code 101
[14:44:48] -rusti- <anon>:7:63: 7:66 error: binary operation < cannot be applied to type `main::X<<V0>>`
[14:44:51] -rusti- <anon>:7          struct Y; struct X<T>; impl X<Y> { fn new() -> X<Y> { X<Y>{} } }
[14:44:54] -rusti-                                                                         ^~~
[14:44:55] <cmr> heh
[14:44:56] -rusti- error: aborting due to previous error
[14:44:58] -rusti- application terminated with error code 101
[14:45:07] <roo> lol
[14:45:10] <cmr> rusti: struct Y; struct X<T>; impl X<Y> { fn new() -> X<Y> { X::<Y> } }
[14:45:11] -rusti- ()
[14:45:13] <ChrisMorgan> Yeah, just noticed that! That's seriously messed up the AST, I guess.
[14:45:36] <ChrisMorgan> Oh, so no? Just my expectations are wrong?
[14:45:55] <roo> i dont think you need to do X<Y>{}, just X{}
[14:46:03] <cmr> You can't do X{}
[14:46:06] <cmr> It's just X
[14:46:11] <cmr> rusti: struct Y; struct X<T>; impl X<Y> { fn new() -> X<Y> { X } }
[14:46:11] <km> cmr: Yeah, it was user error (and/or lack of documentation...)
[14:46:12] -rusti- ()
[14:46:14] <km> I had the functions returning `c_void`, thinking that mapped to C functions that return void
[14:46:16] <roo> right, thats what i meant
[14:46:24] *** Joins: maxli (maxli@B5559308.9C54E60.2FA4EA88.IP)
[14:46:52] <km> but it looks like c_void is just an empty struct, and cdecl returns structs by passing in a hidden pointer
[14:47:08] <ChrisMorgan> rusti: struct Y; struct X<T>; impl<T> X<T> { fn new() -> X<Y> { X::<Y> } } X::new()
[14:47:09] -rusti- <anon>:7:77: 7:83 error: cannot determine a type for this expression: unconstrained type
[14:47:09] -rusti- <anon>:7          struct Y; struct X<T>; impl<T> X<T> { fn new() -> X<Y> { X::<Y> } } X::new()
[14:47:09] -rusti-                                                                                       ^~~~~~
[14:47:09] -rusti- error: aborting due to previous error
[14:47:11] -rusti- application terminated with error code 101
[14:47:11] <cmr> ahhhh
[14:47:25] <cmr> dbaupp: data for 0.6 has just landed
[14:47:38] <dbaupp> ooooooo
[14:47:39] <km> I'm assuming c_void is only intended to be used for void pointers, not used as a type itself.
[14:47:44] <cmr> km: yeah
[14:47:48] <engla> ChrisMorgan: X{field: value}  doesn't need a type parameter
[14:47:48] <dbaupp> km: yeah
[14:48:12] <cmr> km: functions with no return value are just `-> ()`, which you can omit.
[14:48:19] <ChrisMorgan> engla: ?
[14:48:33] <dbaupp> rusti: struct Y; struct X<T>; impl<T> X<T> { fn new() -> X<Y> { X::<Y> } } X::new::<Y>()
[14:48:34] -rusti- {}
[14:48:46] <dbaupp> hm, seems that I was wrong :/
[14:48:52] <cmr> dbaupp: how long does it take the mem thing to update, usually?
[14:49:07] <ChrisMorgan> engla: this is where T is being used as poor man's typestate, so the value Y there will never appear in the struct
[14:49:33] <dbaupp> cmr: it runs every 15 minutes, so 7.5 + github pages time
[14:49:38] <cmr> I'm on the edge of my seat!
[14:49:43] <dbaupp> cmr: (if you want it exactly ;P) 
[14:50:00] <dbaupp> cmr: I'm ran it by hand just then though
[14:50:37] <engla> ChrisMorgan: right ok, then you need to specify the parameter. The syntax then uses ::<Y>  with :: because the hint is optional in the syntax
[14:50:56] <ChrisMorgan> So, looks like that variant of poor-man's-typestate leads to not being able to use aught but inelegant constructor methods. (Hah! Double negatives! Yay!)
[14:51:21] <cmr> I'm going to give the time machine a step of 15, to hopefully get a bunch of historical data
[14:51:42] <dbaupp> yeah, sounds good
[14:51:51] <ChrisMorgan> Well, I'm going to give up on this for the moment and see what it's like going to bed only an hour late rather than three.
[14:52:02] <dbaupp> (we can go back and run through again to fill the gaps "later")
[14:52:06] <km> Anyway, thanks for your help yesterday cmr, and I'll go close the bug.
[14:52:13] <cmr> km: np, thanks
[14:53:04] <km> and if I can find where the documentation is in the source, maybe I'll submit a patch documenting c_void.
[14:53:18] <cmr> it's somewhere deep in std::libc
[14:53:35] *** Quits: ChrisMorgan (chris@moz-6AC741CA.static.tpgi.com.au) (Ping timeout)
[14:54:28] *** Quits: MaikKlein (maik@moz-CA56C650.dip0.t-ipconnect.de) (Ping timeout)
[14:55:39] *** Quits: huseby (huseby@moz-4E8C421A.husebyhome.com) (Quit: Leaving)
[14:58:34] *** Joins: huseby (huseby@moz-4E8C421A.husebyhome.com)
[15:03:00] <dbaupp> cmr: http://huonw.github.io/isrustfastyet/mem/#d91ac39,00dbbd0
[15:03:25] <cmr> well that's significantly less exciting than I had hoped.
[15:03:28] <dbaupp> (it's not as big as I'd hoped)
[15:03:29] <dbaupp> yeah
[15:03:42] <dbaupp> still, we're improving
[15:04:22] <cmr> I should really be storing the build artifacts somewhere so I can go back and run benches from 7532 on them...
[15:04:47] <dbaupp> can just rebuild them, right?
[15:04:52] <cmr> yes
[15:04:55] <cmr> but that takes time :p
[15:05:12] <dbaupp> heh
[15:05:22] <dbaupp> then, quick, set it up now!
[15:05:45] <cmr> 305G free on the disk, no reason not to
[15:06:01] <dbaupp> (um, just a thought... it's unlikely that they'll compile very far back in history.)
[15:06:18] <cmr> oh yeah
[15:06:20] <cmr> damn
[15:07:23] *** Joins: SiegeLord (sl@moz-CAF07B4C.hsd1.ma.comcast.net)
[15:07:38] <dbaupp> some subset of them might compile, which would still be interesting
[15:08:16] <dbaupp> so, if/when these benchmarks get run, just record the ones that fail as None, or whatever.
[15:10:19] <busylizzy> hi! when there will be macros in rust like in nemerle? to be able to write syntax extensions as part of a program, not part of compiler.
[15:11:18] <dbaupp> busylizzy: "when it's done"
[15:12:06] <dbaupp> (it's planned, and I even had a proof-of-concept that sort-of worked, but it's hard to get to be reliable.)
[15:14:11] *** Joins: Sorella (queen@78575561.924F2739.95C8B7C6.IP)
[15:14:51] *** Quits: pyrac (pyrac@moz-18D74BD0.w90-60.abo.wanadoo.fr) (Quit: pyrac)
[15:16:23] <cmr> {"name":"Foo","type":"Plain","fields":[{"visibility":"inherit","name":"feeble","attrs":[{"doc":"\"/// Is this Foo weak?\""}]},{"visibility":"inherit","attrs":[{"doc":"\"/// How many bars this Foo owns\""}],"name":"bars"},{"visibility":"inherit","name":"undoc","attrs":[]}],"attrs":[{"doc":"\"/// A Foo\""}],"id":"12"}
[15:16:43] *** Joins: pyrac (pyrac@moz-18D74BD0.w90-60.abo.wanadoo.fr)
[15:18:19] <dbaupp> cmr: you win!
[15:19:15] <cmr> I didn't know that rustc /literally/ put the doc comment into the doc attr
[15:19:32] <cmr> makes sense though, most flexible.
[15:20:23] <dbaupp> yeah, it's just suggar
[15:20:34] <dbaupp> sugar, too
[15:21:13] <SiegeLord> Why are there escaped quotes in the docs?
[15:21:49] <cmr> I can't wait 'till the commit that turned everything after parsing+expansion into a flat line rather than a curve turns up
[15:22:33] <cmr> SiegeLord: that's what rustdoc_ng spits out for https://github.com/cmr/rustdoc_ng/blob/master/tests/basic_struct.rs#L2
[15:22:58] <SiegeLord> Why though?
[15:23:01] <cmr> dunno
[15:23:37] <SiegeLord> Didn't you code it :P
[15:23:43] <cmr> No
[15:23:46] <cmr> That's the string rustc gives me
[15:23:52] <cmr> for the doc attribute
[15:24:11] <SiegeLord> That's a bit bizzare
[15:24:21] <dbaupp> cmr: except we now use more memory for that section :(
[15:24:23] <cmr> at least, I think so....
[15:24:30] <dbaupp> cmr: what does rustdoc_og say?
[15:24:35] <cmr> rusti: "foo".to_str()
[15:24:36] -rusti- ~"foo"
[15:24:53] <dbaupp> cmr: (you don't happen to be calling fmt!("%?",) on things, do you?)
[15:25:03] <cmr> Nope
[15:25:08] <cmr> ast::meta_word(s) => Word(s.to_owned()),
[15:25:22] <cmr> rusti: @\"foo".to_owned()
[15:25:23] -rusti- <anon>:7:10: 7:11 error: unknown start of token: 92
[15:25:23] -rusti- <anon>:7          @\"foo".to_owned()
[15:25:23] -rusti-                    ^
[15:25:23] -rusti- application terminated with error code 101
[15:25:25] <cmr> rusti: @"foo".to_owned()
[15:25:26] -rusti- @~"foo"
[15:25:33] <cmr> not what I meant rustc
[15:25:38] <cmr> rusti: (@"foo").to_owned()
[15:25:39] -rusti- ~"foo"
[15:25:47] <cmr> rusti: println((@"foo").to_owned())
[15:25:48] -rusti- foo
[15:25:48] -rusti- ()
[15:26:25] <dbaupp> cmr: I'm guess it's the lit_to_str call
[15:26:42] <cmr> oh right that's a n/v pair
[15:26:48] <dbaupp> cmr: converts it into a format that can be read back in, i.e. quoted strings
[15:26:54] *** Joins: spider-mario (spidermari@moz-81131DB6.fbx.proxad.net)
[15:27:04] <dbaupp> L119 of clean.rs, btw
[15:27:43] <roo> http://sprunge.us/UMhA theres my go at the static state stuff.
[15:28:42] * cmr copies the pretty printer code
[15:29:57] *** Joins: ross (ross@moz-8A84103E.br.br.cox.net)
[15:31:27] <busylizzy> is rusti bot opensource? i want such bot on my channel :3
[15:31:47] <cmr> he's a few lines of bash and a bit of python
[15:32:04] <cmr> plus https://github.com/thestinger/playpen
[15:32:31] <dbaupp> cmr: I'm expecting 100s of new benchmarks when I wake up ;P
[15:32:43] * dbaupp is off to bed
[15:33:33] <cmr> dbaupp: maybe 15, depending on how long you sleep :p
[15:34:15] *** Quits: true_droid (Adium@moz-123FD9B8.beck.volia.net) (Quit: Leaving.)
[15:37:22] *** Quits: dbaupp (Thunderbir@moz-712A1135.lns20.syd6.internode.on.net) (Ping timeout)
[15:40:10] <busylizzy> cmr: thanks for sandbox :)
[15:40:53] <doomlord> is there a way to construct a ~[T] from initial value and count.. i tried [value,..count] but it wouldn't allow me a variable there
[15:41:26] <busylizzy> rust desperately needs irc library
[15:41:31] <cmr> rusti: std::vec::from_elem(10, 0u)
[15:41:33] -rusti- ~[0, 0, 0, 0, 0, 0, 0, 0, 0, 0]
[15:41:34] <cmr> busylizzy: write one
[15:41:42] <busylizzy> okay
[15:41:45] <doomlord> thank
[15:42:13] <cmr> doomlord: from_elem isn't as efficient as a memset for creating a zeroed vec though
[15:42:24] <cmr> (also, [T, ..n] is only for fixed-length vectors)
[15:42:39] <doomlord> ok i figured the latter
[15:42:58] *** Quits: RMF (RMF@moz-2CA5F393.dsl.telepac.pt) (Quit: Textual IRC Client: www.textualapp.com)
[15:43:07] <doomlord> fleshing out some 2d array types here.. (tiled etc..)
[15:43:56] *** Joins: RMF (RMF@moz-2CA5F393.dsl.telepac.pt)
[15:46:01] *** testttttttttttttt is now known as sam113101
[15:48:04] *** Joins: MaikKlein (maik@moz-CA56C650.dip0.t-ipconnect.de)
[15:50:29] <heftig> nmatsakis: is DST going anywhere?
[15:50:32] <cmr> SiegeLord: it was lit_to_str, but it was simple to reimplement. So simple, in fact, that I question the validity of the original implementation...
[15:50:38] <cmr> but it's best not to question the pretty printer.
[15:51:19] <SiegeLord> It'll turn into an ugly printer and try to poison you with an apple?
[15:51:34] *** Quits: achim (achim@moz-F552CCA4.pools.arcor-ip.net) (Quit: Computer has gone to sleep.)
[15:51:50] *** Quits: pyrac (pyrac@moz-18D74BD0.w90-60.abo.wanadoo.fr) (Quit: pyrac)
[15:54:19] <cmr> worse: it will make all the tests fail!
[15:56:29] <mark_edward> what's DST
[15:56:41] <cmr> mark_edward: dynamically sized types
[15:56:50] <mark_edward> what's the use case
[15:56:52] <cmr> http://smallcultfollowing.com/babysteps/blog/2013/06/06/reducing-dst-annotation/ and its references
[15:57:08] <mark_edward> thanks!
[15:57:36] <doener> memory usage went up :-(
[15:58:12] <cmr> Youch that's a big hit
[15:58:23] <cmr> We really need to drop the ast after trans
[15:58:36] <doener> interestingly it shoots through the roof initially, but grows a lot less after that
[15:58:39] <cmr> also rewrite the ast
[15:58:48] <cmr> well that's how it worked before too
[15:59:16] <cmr> I don't know why it doesn't grow more during trans...
[15:59:37] <cmr> maybe the allocator isn't marking pages as free and is reusing them?
[15:59:48] *** Joins: pnathan1 (Adium@moz-E3C3FAF2.hfc.comcastbusiness.net)
[16:00:23] <doener> doing that for 600MB seems a little excessive
[16:00:41] <cmr> yeah
[16:00:48] <cmr> dunno what's goin on there
[16:01:31] <doener> hm, strange, your first benchmark in the PR doesn't look like that at all
[16:02:12] <cmr> I had originally benchmarks.... the first three commits I think
[16:02:22] <doener> ah, ok
[16:02:23] <cmr> I'd bet it was ast::Ty that killed it
[16:02:27] <cmr> that guy is ubiquitous
[16:04:04] <doener> hm, yeah, that added a bunch of copies
[16:05:51] *** Quits: pnathan1 (Adium@moz-E3C3FAF2.hfc.comcastbusiness.net) (Ping timeout)
[16:08:55] <mark_edward> I blame Maxwell's demon
[16:09:15] <mark_edward> His entropy defying antics have gone too far!
[16:10:07] *** Joins: pyrac (pyrac@moz-18D74BD0.w90-60.abo.wanadoo.fr)
[16:12:47] *** Quits: RMF (RMF@moz-2CA5F393.dsl.telepac.pt) (Quit: Textual IRC Client: www.textualapp.com)
[16:16:36] *** Joins: ahsanulhaque (Adium@moz-1C21C94F.banglalionwimax.com)
[16:19:56] <indutny> cmr: hehe
[16:20:08] *** Joins: ghrust (ghrust@614D05BD.6A2AE50.F3114085.IP)
[16:20:08] <ghrust> 01[13rust01] 15bors merged 06auto into 06master: 02http://git.io/mVBWyg
[16:20:08] *** Parts: ghrust (ghrust@614D05BD.6A2AE50.F3114085.IP) ()
[16:20:58] <indutny> hm...
[16:21:04] <indutny> looks like rust broke backwards compatibility
[16:21:09] <indutny> or name lookup just broken a bit
[16:22:12] <doomlord> http://pastebin.com/T61m3Kub <<< difficulty with struct initialization, doesn't seem to let me do this..
[16:22:29] <doomlord> (i've simplified this down from something more complex)
[16:23:05] *** Joins: ghrust (ghrust@CFE85B59.6A2AE50.F3114085.IP)
[16:23:05] <ghrust> 01[13rust01] 15bors pushed 0 new commits to 06auto: 02http://git.io/yfHlrQ
[16:23:05] *** Parts: ghrust (ghrust@CFE85B59.6A2AE50.F3114085.IP) ()
[16:23:17] <doomlord> it just will not let me initialize a struct there :(
[16:25:49] *** Quits: maxli (maxli@B5559308.9C54E60.2FA4EA88.IP) (Quit: Leaving.)
[16:26:02] <doomlord> ah. i need to say new<T> perhpas
[16:26:05] *** Joins: ghrust (ghrust@614D05BD.6A2AE50.F3114085.IP)
[16:26:05] <ghrust> 01[13rust01] 15bors pushed 0 new commits to 06auto: 02http://git.io/yfHlrQ
[16:26:05] *** Parts: ghrust (ghrust@614D05BD.6A2AE50.F3114085.IP) ()
[16:26:06] *** Joins: ghrust (ghrust@1E8607E8.6A2AE50.F3114085.IP)
[16:26:06] <ghrust> 01[13rust01] 15bors pushed 3 new commits to 06auto: 02http://git.io/PWPP2g
[16:26:06] <ghrust> 13rust/06auto 1438e25ea 15James Miller: Add VecRef to std::vec...
[16:26:06] <ghrust> 13rust/06auto 1441029c9 15James Miller: Implement a StringRef...
[16:26:06] <ghrust> 13rust/06auto 14a3e0db7 15bors: auto merge of #7599 : Aatch/rust/vec-ref, r=huonw...
[16:26:06] *** Parts: ghrust (ghrust@1E8607E8.6A2AE50.F3114085.IP) ()
[16:26:24] *** Joins: maxli (maxli@B5559308.9C54E60.2FA4EA88.IP)
[16:26:32] <doener> doomlord: drop the <T> from line 17
[16:27:41] <doener> doomlord: or write it as TiledSparseArray2d::<T>
[16:27:43] *** Joins: ferminter (Mibbit@moz-A209989E.broadband.corbina.ru)
[16:27:47] <doomlord> ahhhh.
[16:28:01] <doomlord> it doesn't know its a type there
[16:28:17] <doener> it doesn't want a type there, but a "constructor"
[16:28:22] *** Quits: maxli (maxli@B5559308.9C54E60.2FA4EA88.IP) (Ping timeout)
[16:28:57] <doomlord> that works! thanks.
[16:35:05] *** Joins: ghrust (ghrust@AD60B2E3.6A2AE50.F3114085.IP)
[16:35:05] <ghrust> 01[13rust01] 15bors 04force-pushed 06auto from 14a3e0db7 to 14005c9bd: 02http://git.io/N3iJvQ
[16:35:05] *** Parts: ghrust (ghrust@AD60B2E3.6A2AE50.F3114085.IP) ()
[16:35:07] *** Joins: ghrust (ghrust@F6EE6DE3.6A2AE50.F3114085.IP)
[16:35:07] <ghrust> 01[13rust01] 15bors pushed 3 new commits to 06auto: 02http://git.io/m1A47g
[16:35:07] <ghrust> 13rust/06auto 14d805b83 15blake2-ppc: vec: Add .pop_opt() -> Option<T>...
[16:35:07] <ghrust> 13rust/06auto 14fc17d43 15blake2-ppc: vec: Add .shift_opt() -> Option<T>...
[16:35:07] <ghrust> 13rust/06auto 143c44265 15bors: auto merge of #7602 : blake2-ppc/rust/vec-pop-opt, r=cmr...
[16:35:09] *** Parts: ghrust (ghrust@F6EE6DE3.6A2AE50.F3114085.IP) ()
[16:35:58] *** Quits: pyrac (pyrac@moz-18D74BD0.w90-60.abo.wanadoo.fr) (Quit: pyrac)
[16:42:49] *** Quits: ferminter (Mibbit@moz-A209989E.broadband.corbina.ru) (Quit: http://www.mibbit.com ajax IRC Client)
[16:43:46] *** Quits: santiago (santiago@320E3E2A.D15AA1B4.A535BD55.IP) (Quit: Computer has gone to sleep.)
[16:47:50] *** Joins: pyrac (pyrac@moz-18D74BD0.w90-60.abo.wanadoo.fr)
[16:50:02] <krdln> I found annoying difference in lifetimes between Rust and C++ https://gist.github.com/anonymous/5943994 Is this a bug or feature?
[16:50:21] *** Joins: vilonis (jared@moz-EE5D17ED.ph.ph.cox.net)
[16:50:22] *** Quits: pnathan (Adium@moz-BDC3EE62.tukw.qwest.net) (Ping timeout)
[16:50:33] *** Joins: pnathan (Adium@moz-BDC3EE62.tukw.qwest.net)
[16:50:40] <doener> krdln: bug, let me look up the issue
[16:51:33] <cmr> was also just discussed on the ML
[16:52:30] <krdln> what is ML?
[16:52:37] <cmr> mailing list
[16:52:45] <krdln> oh, ok
[16:52:55] *** Quits: MaikKlein (maik@moz-CA56C650.dip0.t-ipconnect.de) (Ping timeout)
[16:52:56] *** Joins: mzabaluev (mzabaluev@moz-91FFD755.dhcp.inet.fi)
[16:53:05] *** Joins: alisdair (textual@moz-EBE9F394.bchsia.telus.net)
[16:53:50] *** Joins: jmgrosen (jmgrosen@moz-848F6087.sb.sd.cox.net)
[16:54:01] <krdln> hope it will be fixed soon, especially when we switched to external iterators
[16:54:50] <doener> hm, can't find it
[16:55:24] *** Joins: int3_ (int3_@moz-ABE52D50.hsd1.ca.comcast.net)
[16:57:23] <vilonis> is there literal syntax for a hashmap?
[16:57:24] *** Quits: int3_ (int3_@moz-ABE52D50.hsd1.ca.comcast.net) (Ping timeout)
[16:57:33] <doener> no
[16:57:38] <ross> no, but somebody wrote a macro for one
[16:57:41] <sfackler> doener: https://github.com/mozilla/rust/issues/3511 ?
[16:58:48] <doener> sfackler: I thought there was one specifically for method chaining, but that is probably covered by that one
[16:59:14] <vilonis> thanks
[16:59:22] *** Quits: relistan (relistan@moz-2DE8112B.cable.virginmedia.com) (Quit: relistan)
[16:59:57] <doomlord> [T,..N] doesn't have clone by default?
[17:04:53] <cmr> doomlord: no, fixed-length vecs are a little weird because every length is a separate type
[17:05:50] <doomlord> i have to impl<T:Clone> Clone for [T,..MySize] then perhaps
[17:06:19] <bblum> i'm surprised it doesn't autoderive clone
[17:06:23] <doomlord> <cmr> doomlord: no, fixed-length vecs are a little weird because every length is a separate type
[17:06:26] <doomlord> oops
[17:06:33] <doomlord> tiledarray2d.rs:14:0: 15:1 error: cannot provide an extension implementation for a trait not defined in this crate
[17:06:33] <doomlord> tiledarray2d.rs:14 impl<T:Clone> Clone for [T,..8] {
[17:06:59] <bblum> you could also consider making a newtype around the vector and just deriving(Clone) that
[17:08:02] <doomlord> http://pastebin.com/P3YMpsLK <<< what i was trying
[17:08:06] <doomlord> ok let me try a newtype..
[17:15:13] <doomlord> ok. I got this to compile... worryingly convoluted though and i wouldn't have figured that out for myself :(
[17:15:25] <cmr> bblum: Is there an explanation of that datasort thing somewhere? Afaict from context it's enum variant subtyping
[17:16:15] *** Quits: pnathan (Adium@moz-BDC3EE62.tukw.qwest.net) (Quit: Leaving.)
[17:16:31] <bblum> cmr: that's pretty much it
[17:16:51] <doomlord> (anyone know off hand if there's a vector constructor taking a function of index..)
[17:16:57] <SiegeLord> rusti: let a = 1, 2; a
[17:16:58] -rusti- more than 5 lines of output, pastebinned: http://sprunge.us/gADG
[17:17:12] <bblum> doomlord: from_fn
[17:17:28] <SiegeLord> rusti: let a = 1; a = 1, 2; a
[17:17:29] -rusti- <anon>:7:25: 7:26 error: expected `;` or `}` after expression but found `,`
[17:17:29] -rusti- <anon>:7          let a = 1; a = 1, 2; a
[17:17:29] -rusti-                                   ^
[17:17:29] -rusti- application terminated with error code 101
[17:17:37] <SiegeLord> No comma operator in Rust, I take it?
[17:17:42] <bblum> cmr: i believe they would have to be structural, not nominal, in order to not make the inference(?) hard
[17:17:42] <cmr> doomlord: (it's really slow because closures optimize poorly, though)
[17:17:55] <cmr> bblum: I don't even know what that means
[17:18:14] <doomlord> http://pastebin.com/zaMq6t16 <<< lol
[17:18:23] <bblum> cmr: struct Foo { x: A, y: B } "Foo" is a nominal type; "(A,B)" is a structural type
[17:18:53] <cmr> bblum: Ah, so it's the "shape" of a type?
[17:18:53] <bblum> "if you define it again, is it the same type?"
[17:18:57] <bblum> yeah
[17:19:20] <Ms2ger> SiegeLord, indeed
[17:19:46] <SiegeLord> I wonder if it'd be useful to make stuff like array[1, 2] parse
[17:19:58] <cmr> but you can havee array[(1, 2)]
[17:20:03] <SiegeLord> It'd call array.index([1, 2])
[17:21:41] *** Joins: pnathan (Adium@moz-BDC3EE62.tukw.qwest.net)
[17:22:04] *** Quits: ahsanulhaque (Adium@moz-1C21C94F.banglalionwimax.com) (Ping timeout)
[17:22:26] *** Joins: vk (vk@moz-389FEE13.hsd1.ca.comcast.net)
[17:22:46] *** Quits: jmgrosen (jmgrosen@moz-848F6087.sb.sd.cox.net) (Quit: jmgrosen)
[17:22:58] *** Joins: Diamond (dick@moz-C01E1CD1.ks.ks.cox.net)
[17:23:44] *** Joins: hort (hort@2E6FD454.2AEE264E.CA6E2165.IP)
[17:25:20] <SiegeLord> Yeah, I guess array[[1, 2]] isn't that bad
[17:25:35] <SiegeLord> Just brainstorming what'd look good for multidimensional array indexing
[17:25:54] <cmr> parens, not brackets
[17:25:57] <SiegeLord> array[[1..2, 2..]]
[17:26:05] <cmr> tuples are more useful because they can be hetereogenous
[17:26:12] *** Joins: HollyRain (HollyRain@moz-50A83091.dyn.user.ono.com)
[17:26:24] <SiegeLord> They are fixed in size, however
[17:26:34] *** Quits: HollyRain (HollyRain@moz-50A83091.dyn.user.ono.com) (Quit: bye, bye)
[17:26:38] <cmr> so are [] that aren't ~[] or &[]
[17:26:54] <SiegeLord> The function would take &[]
[17:28:34] *** Joins: sw17ch (sw17ch@moz-675AFBCF.hsd1.mi.comcast.net)
[17:28:55] <SiegeLord> The point here is that the number of dimensions is a runtime quantitty
[17:29:18] <SiegeLord> At least, given the abilities of Rust's type system
[17:29:55] <SiegeLord> Although it might be possible to have nested types... like Dimension<Dimension<Dimension>> or something, I don't know if that'd work
[17:30:03] <SiegeLord> Or if that'd be efficient
[17:30:09] <cmr> &[] also requires a dereference
[17:32:31] *** Quits: sw17ch (sw17ch@moz-675AFBCF.hsd1.mi.comcast.net) (Quit: sw17ch)
[17:34:16] *** Joins: Jesse (jruderman@moz-537BCF9.hsd1.ca.comcast.net)
[17:34:24] <SiegeLord> That's ok, hehe
[17:34:33] <doomlord> http://pastebin.com/uKntsm0S <<< got this to compile but wonder why i needed the '&tile',didn't entirely know i could put the & there either... doesn't let me match against the enum any other way
[17:34:44] <cmr> I don't know what numeric computing you're doing where willy-nilly dereferences are ok :p
[17:35:36] <SiegeLord> The real kind :P
[17:35:44] <cmr> doomlord: `let tile = self.tiles.data[tileI+tileJ*self.tiles.width];` doesn't work, but &tile does?
[17:35:53] <SiegeLord> 1 dereference for an operation that then does 1000000 multiplies doesn't matter ;)
[17:35:57] <doomlord> yes exactly
[17:36:05] <cmr> doomlord: I think that's a bug
[17:36:07] <cmr> bblum: ^?
[17:36:17] <doomlord> .. for the subsequent match, and i tried lots of combinations r.e &'s in the matches
[17:36:40] <cmr> they should be equivalent I think, and if one doesn't work, the other shouldn't either
[17:36:55] <cmr> maybe the &tile is an implicit copy
[17:37:03] *** Quits: krdln (Mibbit@moz-6F8A8560.dynamic.chello.pl) (Quit: http://www.mibbit.com ajax IRC Client)
[17:37:28] <doomlord> the intent is not to copy the tile itself, just extract the value for returning
[17:37:32] *** Quits: jensnockert (jensnocker@moz-C5F27039.cust.bredband2.com) (Connection reset by peer)
[17:37:41] *** Joins: Waka_Flocka_Flame (Mibbit@moz-E06A5D83.sub-70-192-199.myvzw.com)
[17:37:46] <cmr> that would require a move though
[17:37:53] *** Joins: jensnockert (jensnocker@moz-8BE55278.customer.t3.se)
[17:38:01] <doomlord> (i'm using an enum which can hold a single uniform value, or an owned ptr to an  8x8 tile of data)
[17:38:18] <doomlord> yeah by now i would have expected to write a .clone somehwere
[17:38:21] <doomlord> let me try that..
[17:38:48] <doomlord> tiledarray2d.rs:55:3: 55:15 error: mismatched types: expected `&tiledarray2d::TileHolder<T>` but found an enum or structure pattern
[17:38:55] *** Joins: strcat (strcat@moz-54F7FD49.cpe.net.cable.rogers.com)
[17:38:56] <doomlord> ^^still says that 
[17:39:05] *** Parts: Waka_Flocka_Flame (Mibbit@moz-E06A5D83.sub-70-192-199.myvzw.com) ()
[17:39:18] <cmr> do you have reservations about pastbinning all your code? I'd like to play with it a bit, this seems very weird
[17:39:36] <doomlord> i'll try, its split into modules  abit
[17:40:25] <doomlord> http://pastebin.com/Vr3N6rEM <<< "tiledarray2d.rs"
[17:40:39] *** Joins: ahsanulhaque (Adium@moz-1C21C94F.banglalionwimax.com)
[17:40:48] *** Joins: gamakichi (Mibbit@moz-C207C5B5.range86-145.btcentralplus.com)
[17:40:59] <doomlord> http://pastebin.com/q71JTdHC  <<<< "array2d.rs"  ,whicih the above uses as a component
[17:41:30] <doomlord> the gist is.. LinearArray2d /trait array2d implements a 2d interface to a vector'
[17:41:59] <doomlord> ... and 'TiledSparseArray2d'  is supposed to be an array of optional 8x8 tiles, (empty tile represented by a single value)
[17:42:22] *** Parts: hort (hort@2E6FD454.2AEE264E.CA6E2165.IP) ()
[17:43:12] *** Joins: sankha93 (Instantbir@513CD6A2.E6798AF8.8B6C1D65.IP)
[17:43:13] *** Quits: km (quassel@FDBAF0A0.DBF71E41.29C67456.IP) (Ping timeout)
[17:43:39] *** Joins: km (quassel@FDBAF0A0.DBF71E41.29C67456.IP)
[17:43:41] <doomlord> i'm going to extend this to 3d aswell, and have some more variations like RLE representations in one axis, that sort of thing
[17:43:46] <cmr> my rustc hangs on it :\
[17:44:14] <doomlord> rustc 0.7 (d324014 2013-07-01 02:26:46 -0700)
[17:44:15] <cmr> it hangs even when doing --parse-only, hm
[17:44:29] <cmr> rustc 0.7 (19d97dd 2013-07-04 16:54:46 -0400)
[17:45:16] <strcat> hm
[17:45:20] <strcat> bors is being weird
[17:45:37] <doomlord> in c++ it would be a vector<unique_ptr<array<array<T,8>,8>>>
[17:45:53] <doomlord> with some 2d wrapper around the 'vector'. 
[17:46:39] <cmr> oh I curl'd the wrong file
[17:47:40] <cmr> doomlord: `let tile = self.tiles.data[tileI+tileJ*self.tiles.width].clone();` works for me
[17:47:51] <cmr> I was right, it is a move, and the &tile does an implicit copy.
[17:48:13] <doomlord> ouch!!
[17:48:22] *** Joins: pnathan1 (Adium@moz-E3C3FAF2.hfc.comcastbusiness.net)
[17:48:31] *** Quits: rusti (rusti@moz-54F7FD49.cpe.net.cable.rogers.com) (Ping timeout)
[17:48:40] *** Joins: rusti (rusti@moz-54F7FD49.cpe.net.cable.rogers.com)
[17:48:40] <doomlord> i dont mind having to put a clone in, the intent is it looks up a single tile element to return
[17:49:15] <doomlord> wait 'move' ... what exactly does that mean
[17:49:43] <doomlord> is "let tile=..." closer to my desired behaviour?
[17:49:45] <cmr> Move is implemented as a shallow copy that invalidates (ie, zeroes) the old location
[17:49:54] <cmr> a transfer of ownership
[17:50:12] <doomlord> is that moving from a temporary in the expresion? the 'self' is immutable
[17:50:18] <doomlord> (i thought:) )
[17:50:53] <cmr> no, it's invalid because self is immutable, that is the "invalid move from dereference of &-ptr" error (or whatever it is, I forget the exact wording)
[17:50:58] *** Joins: MaikKlein (maik@moz-CA56C650.dip0.t-ipconnect.de)
[17:51:42] <cmr> I think https://gist.github.com/cmr/7c13ac969a78e59171b3 is closer to what you want?
[17:51:53] <cmr> It takes a reference to the tile, and then clones the value at the location to return it
[17:52:00] <cmr> rather than cloning the potentially largish tile
[17:52:06] *** Quits: ski (md9slj@moz-B0548857.ce.chalmers.se) (Quit: Lost terminal)
[17:52:45] <doomlord> 'cannot move out of ..' right that explaoins those errors i get in many permuations
[17:53:04] <cmr> yeah
[17:53:07] <cmr> that's the one
[17:53:36] <doomlord> magic keyword ref, new to me
[17:53:44] <doomlord> that is what i want i think
[17:53:57] <doomlord> i was trying &x's 
[17:54:02] <cmr> when destructuring in a pattern, rather than moving, `ref` gives you the pointer to the element
[17:54:12] <cmr> also `mut ref` for &mut
[17:54:12] *** Quits: pyrac (pyrac@moz-18D74BD0.w90-60.abo.wanadoo.fr) (Quit: pyrac)
[17:54:35] *** Quits: pnathan1 (Adium@moz-E3C3FAF2.hfc.comcastbusiness.net) (Ping timeout)
[17:54:36] *** Quits: Yurume (yurume@AC58A8CE.8A059B47.E313B915.IP) (Ping timeout)
[17:54:45] *** Quits: alisdair (textual@moz-EBE9F394.bchsia.telus.net) (Quit: My MacBook Pro has gone to sleep. ZZZzzzâ€¦)
[17:54:52] <cmr> or it might be ref mut, I don't remember ;p
[17:55:18] <doomlord> ok great. that does what i want, and i'm a bit happper about how
[17:55:46] <doomlord> i do find myself feeling quite hazy on what & does compared to C++ :)
[17:56:01] <doomlord> tend to flail around with the errors moving &'s randomly..
[17:56:21] <cmr> it's just a plain pointer, but the compiler does lots of verification of how it's used
[17:56:30] <Luqman> strcat: i got your vec branch to get past stage1 last night https://gist.github.com/luqmana/aca93b8a8856619c2c6e
[17:56:47] <cmr> confuses the bejesus out of me a lot of the time too :p
[17:56:47] <strcat> Luqman: ;D
[17:56:52] <doomlord> If this *didn't* have the matching with & ....ref .... would it be able to optimize to the same result ?
[17:57:12] <strcat> Luqman: ah so it was from patterns
[17:57:16] <cmr> doomlord: no, it'd generate potentially invalid code I think
[17:57:32] <strcat> Luqman: does it still die somewhere? at runtime I guess?
[17:57:43] <cmr> doomlord: not really sure
[17:58:00] <Luqman> strcat: yea, double free when it tries to build stage2 libstd
[17:58:10] <strcat> odd
[17:58:23] <cmr> doener got lots of double frees when doing his recent work iirc
[17:58:43] <Luqman> strcat: i'm not quite sure about my changes to trans/uniq though
[17:59:01] <strcat> Luqman: I'll just start by applying the pattern ones
[17:59:03] <doomlord> http://pastebin.com/ySYcfJda ,<< this  compiles, not sure what it does r.e. copies :)
[17:59:28] <cmr> doomlord: me neither
[18:00:20] *** Joins: krdln (Mibbit@moz-6F8A8560.dynamic.chello.pl)
[18:00:41] <doomlord> i need to examine asm output..  
[18:01:03] <cmr> there's also rustc --emit-llvm -S if you can read llvm
[18:01:11] <doomlord> i can't (yet)
[18:01:16] *** Parts: ahsanulhaque (Adium@moz-1C21C94F.banglalionwimax.com) ()
[18:01:41] <cmr> it's pretty easy to read most of the time, at least the optimized output
[18:01:51] <Luqman> doomlord: llvm ir isn't that bad, more readble than asm most of the time
[18:01:55] <doener> cmr: except for a bug in calling trait methods, that was all my fault though. Remaining is (maybe) a bug that leaks
[18:02:12] <doomlord> yeah i hate x86 asm too
[18:03:06] <strcat> Luqman: I'll be so happy when this finally works ;p
[18:03:10] <strcat> ugh
[18:03:15] <doomlord> i would guess this latter paste should be ok, it would do a select based on some sort of tag, it has a ref x/ref-data ... so its not going to be copying the whole tile as an intermediate
[18:04:01] <cmr> strcat: let's hope it wins back the memory aatch barfed up in his de-@ of ast::Ty
[18:04:36] <strcat> well if they're 16 byte allocations, they'll be 16-byte instead of 64-byte
[18:04:38] <strcat> ;p
[18:05:35] <cmr> http://huonw.github.io/isrustfastyet/mem/#d91ac39,0f25155
[18:06:18] <strcat> huh
[18:06:20] <strcat> that's not good
[18:06:23] <strcat> cmr: that won't be fixed
[18:06:28] <strcat> it's too much
[18:06:33] <cmr> yeah
[18:06:36] <strcat> wait you mean this black one
[18:06:50] * strcat is confused by there being 3
[18:07:06] <cmr> if there's three that means dbaupp has a bug in the viewer :p
[18:07:16] <cmr> but yes the black one is the regression
[18:07:21] <cmr> 0f25155
[18:08:38] <cmr> hm, you can zoom out as far as centuries
[18:08:51] <cmr> let's hope rust is replaced by something better in at least 100 years :p
[18:11:26] <strcat> I guess he unboxed a really huge struct
[18:11:29] <strcat> that should be ~T
[18:11:36] <strcat> in a recursive data structure
[18:14:05] *** Joins: ghrust (ghrust@24260B07.6A2AE50.F3114085.IP)
[18:14:06] <ghrust> 01[13rust01] 15bors merged 06auto into 06master: 02http://git.io/m1A47g
[18:14:06] *** Parts: ghrust (ghrust@24260B07.6A2AE50.F3114085.IP) ()
[18:14:22] <cmr> rusti: fn foo() -> uint { extern mod syntax; std::sys::size_of<syntax::ast::Ty>() } foo()
[18:14:22] -rusti- <anon>:7:28: 7:46 error: "extern mod" declarations are not allowed here
[18:14:22] -rusti- <anon>:7          fn foo() -> uint { extern mod syntax; std::sys::size_of<syntax::ast::Ty>() } foo()
[18:14:23] -rusti-                                      ^~~~~~~~~~~~~~~~~~
[18:14:23] -rusti- error: aborting due to previous error
[18:14:23] -rusti- application terminated with error code 101
[18:14:26] <cmr> feh
[18:15:11] <cmr> "only" 80 bytes it seems
[18:15:15] *** Quits: SiegeLord (sl@moz-CAF07B4C.hsd1.ma.comcast.net) (Quit: Leaving)
[18:17:01] *** Joins: ghrust (ghrust@9C8B94D4.6A2AE50.F3114085.IP)
[18:17:01] <ghrust> 01[13rust01] 15bors pushed 0 new commits to 06auto: 02http://git.io/bPwxPw
[18:17:01] *** Parts: ghrust (ghrust@9C8B94D4.6A2AE50.F3114085.IP) ()
[18:17:03] *** Joins: ghrust (ghrust@5FEF1C87.6A2AE50.F3114085.IP)
[18:17:03] <ghrust> 01[13rust01] 15bors pushed 2 new commits to 06auto: 02http://git.io/hKTUSw
[18:17:03] <ghrust> 13rust/06auto 14e41e435 15BjÃ¶rn Steinbrink: Implement scopes independent of LLVM basic blocks...
[18:17:03] <ghrust> 13rust/06auto 1452abd1c 15bors: auto merge of #7636 : dotdash/rust/scope_cleanup, r=graydon...
[18:17:04] *** Parts: ghrust (ghrust@5FEF1C87.6A2AE50.F3114085.IP) ()
[18:17:20] *** Joins: enix (enix@moz-A50569DD.c3-0.slvr-ubr1.lnh-slvr.md.cable.rcn.com)
[18:18:15] <strcat> cmr: that's a ton ;p
[18:18:23] <strcat> if it's recursively included
[18:19:13] <doomlord> when you specify lifetimes, 'self' doesnt seem to default to 'self .. you haveto manually write that?
[18:19:37] <strcat> yes
[18:19:48] <strcat> 'self is the lifetime of the *internal* borrowed pointers
[18:19:52] <strcat> it's unrelated to the self parameter
[18:20:33] <doomlord> http://pastebin.com/RYZ3zxdm <<<< what i had to do to make mt 'get' returnn a ptr
[18:20:41] *** Quits: pnathan (Adium@moz-BDC3EE62.tukw.qwest.net) (Quit: Leaving.)
[18:20:58] <doomlord> internal as in locals?
[18:21:27] <doomlord> is my use of 'self erroneous
[18:21:58] <strcat> Luqman: heh, I really wonder where the double free happens
[18:22:00] <strcat> very strange.
[18:22:52] <cmr> doomlord: it should be fn get<'a>(&'a self, ...) -> &'a T { &self.data[...] } I think
[18:23:29] *** Quits: vk (vk@moz-389FEE13.hsd1.ca.comcast.net) (Quit: vk)
[18:23:40] <geomyidae> are slices a language level concept?
[18:23:44] <cmr> geomyidae: yes
[18:23:45] <indutny> hm...
[18:23:52] <heftig> strcat: you mean if the struct contains pointers?
[18:23:54] <indutny> it feels so odd that one can't just write this
[18:24:00] <indutny> enum X { Y { field: uint } }
[18:24:08] <strcat> heftig: yes
[18:24:17] <cmr> rusti: enum X { Y { field: uint } };
[18:24:19] -rusti- ()
[18:24:19] <Luqman> strcat: no idea, gdb says run_compiler::_3c17751ecb73e2a4::_0$x2e7, getopts::groups::getopts::_e474f085d191ff11::_0$x2e7, __morestack, _int_free
[18:24:23] <indutny> oh
[18:24:24] <strcat> heftig: struct Foo<'self> { x: &'self int }
[18:24:25] <indutny> it works?
[18:24:26] <indutny> :)
[18:24:28] <cmr> seems so :p
[18:24:33] <indutny> why isn't it documented then?
[18:24:43] <heftig> strcat: is identical to struct Foo { x: &int } ?
[18:24:45] <cmr> who needs documentation when you have #rust?
[18:24:53] <indutny> haha :)
[18:24:53] <indutny> ok
[18:24:54] <indutny> thanks
[18:24:57] <strcat> heftig: you can't do that, it will complain about not having a lifetime
[18:25:02] <indutny> I'm writing disassembler for arm
[18:25:02] <heftig> okay.
[18:25:07] <geomyidae> cmr: :D
[18:25:07] <strcat> heftig: it used to be implicit but the inference was buggy so it was removed
[18:25:36] <doomlord> ahhhh.
[18:25:52] <vilonis> thanks
[18:26:01] <heftig> rusti: struct Foo<'self> { x: Option<&'self int> }
[18:26:02] -rusti- ()
[18:26:25] <doomlord> 'self is the lifetime of the fields, i still think thats what i want in my case..?
[18:26:41] <heftig> rusti: struct Foo<'self> { x: Option<&'self int> }; let a = Foo { x: &3 }; ()
[18:26:42] -rusti- line longer than 150 columns, pastebinned: http://sprunge.us/ecYh
[18:26:45] <cmr> doomlord: 'self has no meaning besides that it's the only lifetime allowed in some contexts
[18:26:58] <heftig> rusti: struct Foo<'self> { x: Option<&'self int> }; let a = Foo { x: Some(&3) }; ()
[18:26:59] -rusti- more than 5 lines of output, pastebinned: http://sprunge.us/iiKb
[18:27:01] <cmr> doomlord: using `&'a self` does what you want
[18:27:17] <heftig> rusti: struct Foo<'self> { x: Option<&'self int> }; let b = 3; let a = Foo { x: Some(&b) }; ()
[18:27:18] -rusti- <anon>:7:69: 7:70 warning: unused variable: `a` [-W unused-variable (default)]
[18:27:18] -rusti- <anon>:7          struct Foo<'self> { x: Option<&'self int> }; let b = 3; let a = Foo { x: Some(&b) }; ()
[18:27:18] -rusti-                                                                               ^
[18:27:18] -rusti- ()
[18:27:23] <doomlord> ok i have to go back through the traits to change it
[18:27:29] *** Joins: robert (robertknig@moz-B6DD6E0B.range86-166.btcentralplus.com)
[18:28:13] <doomlord> hazy on where/why it can and can't infer lifetime parameters ... manually writing them is no great problem though
[18:28:28] <Ms2ger> Stuff is hard
[18:30:32] <fredy> hello, I am new on rust and I am still learning the basics of the language... Is there any function for reading int from stdin?
[18:31:23] *** Quits: Luqman (laden@moz-DCEF6040.csclub.uwaterloo.ca) (Ping timeout)
[18:31:29] <krdln> fredy: I tried to find such once, without success
[18:31:42] <cmr> probably doesn't exist, io code is crap
[18:33:06] *** Quits: Amanieu (amanieu@moz-D5D10CA8.halls.manchester.ac.uk) (Quit: leaving)
[18:33:45] <fredy> krdln: I see... so I guess I can create one using each_byte... thanks :)
[18:35:08] *** Quits: MaikKlein (maik@moz-CA56C650.dip0.t-ipconnect.de) (Ping timeout)
[18:35:51] *** Joins: pyrac (pyrac@moz-18D74BD0.w90-60.abo.wanadoo.fr)
[18:38:46] <krdln> fredy: if these ints are in separate lines, you coud use FromStr::from_str::<int>( std::io::stdin().read_line() )
[18:39:41] *** Joins: Amanieu (amanieu@CB5576F2.F4BF8C9A.9510F13D.IP)
[18:40:06] <fredy> krdln: thx, that was exactly what I have done on a previous rust program I wrote, but now the data are on the same line seperated by space
[18:41:33] <krdln> fredy: maybe word_iter?
[18:42:33] <gamakichi> say i have a tree with each node being an owned box. I want to walk down it and keep a mutable list of the nodes visited, but also want to have a mutable reference to each node as i walk down the tree, is this possible?
[18:45:40] <fredy> krdln: this looks ok but you have to convert the str to int again... I was thinking something like each_byte which will give me bytes until it finds a white space and an anonymous function will change in each byte a mutable int variable
[18:46:37] <strcat> gamakichi: if by node you mean the data stored in the node, yes
[18:46:49] <strcat> gamakichi: if you mean mutable references to the actual nodes with children, no - you can't alias &mut
[18:47:35] <gamakichi> strcat should i be using managed boxes instead?
[18:47:38] <kimundi> fredy: What exactly do you want to do? Read in a string of whitespace seperated ints in base 10?
[18:48:30] <fredy> kimundi: exactly! for example "34 123"
[18:48:47] *** Joins: kud1ing (Mibbit@moz-26001AE4.pools.arcor-ip.net)
[18:49:12] <kimundi> rusti: let i = "45 99 98 74".word_iter(); i.transform(|s| std:FromStr::from_str::<int>()).collect::<~[int]>()
[18:49:13] -rusti- <anon>:7:63: 7:64 error: expected `,` but found `:`
[18:49:13] -rusti- <anon>:7          let i = "45 99 98 74".word_iter(); i.transform(|s| std:FromStr::from_str::<int>()).collect::<~[int]>()
[18:49:13] -rusti-                                                                         ^
[18:49:13] -rusti- application terminated with error code 101
[18:49:22] <kimundi> rusti: let i = "45 99 98 74".word_iter(); i.transform(|s| std::FromStr::from_str::<int>()).collect::<~[int]>()
[18:49:23] -rusti- more than 5 lines of output, pastebinned: http://sprunge.us/RBdK
[18:49:39] <kimundi> rusti: let i = "45 99 98 74".word_iter(); i.transform(|s| FromStr::from_str::<int>()).collect::<~[int]>()
[18:49:41] -rusti- more than 5 lines of output, pastebinned: http://sprunge.us/fjbF
[18:49:47] *** Joins: Luqman (laden@moz-DCEF6040.csclub.uwaterloo.ca)
[18:49:58] <kimundi> rusti: let i = "45 99 98 74".word_iter(); i.transform(|s| FromStr::from_str::<int>(s)).collect::<~[int]>()
[18:49:59] -rusti- more than 5 lines of output, pastebinned: http://sprunge.us/TIFT
[18:50:33] <doomlord> (ok get<'a>(...) worked for what i was doing, i had been blindly stuffing 'self in the traits  - seems i could remove that . Still hazy on when/why you'd need that
[18:50:45] <kimundi> rusti: let i = "45 99 98 74".word_iter(); i.transform(|s| FromStr::from_str::<int>(s).get()).collect::<~[int]>()
[18:50:46] -rusti- ~[45, 99, 98, 74]
[18:50:55] <thiez> some days it concerns me that even experienced rust users need brute force just to write a single correct line :p
[18:50:58] <kimundi> fredy: ^
[18:51:26] <kimundi> thiez: Thats just because the compiler is in a steady state of incompletless
[18:51:36] <doomlord> http://pastebin.com/GjGdmnK4
[18:51:39] <fredy> kimundi: thanks, now I have to decode you code :P :)
[18:52:11] <thiez> kimundi: what would that line look like with a hypothetical complete compiler?
[18:52:40] <kimundi> fredy: string.word_iter() returns an iterator for iterating over words of a string, that is whitespace seperated.
[18:54:25] *** Quits: kud1ing (Mibbit@moz-26001AE4.pools.arcor-ip.net) (Quit: http://www.mibbit.com ajax IRC Client)
[18:54:41] <fredy> kimundi: the part I don't understand because I don't have played enough with rust is the .get() and .collect... but don't worry I will read the docs :)
[18:55:36] *** Joins: Nisstyre (wes@moz-FD86289.netflash.net)
[18:56:16] <kimundi> transform takes a function that calls FromStr for each of those words (by specifying the int implementation because we want to read a int from the string, and), calls get() on it because FromStr returns an Option<int>that we need to unwrap, and puts all that ints an new Iteratorreturns an iterator over ints. Then we use the collect() call to gather all elements of the iteraor in a data structure, here a ~[int]
[18:56:30] *** Quits: victorporof (victorporo@74A9C5E8.1745F5FA.9B1E38F4.IP) (Ping timeout)
[18:57:15] <kimundi> (oops, should have read that once before sending it)
[18:57:18] <krdln> btw, why does http://static.rust-lang.org/doc/core still exist? I often land there from google. It should at least redirected to std
[18:57:29] *** Joins: int3_ (int3_@moz-ABE52D50.hsd1.ca.comcast.net)
[18:57:55] <krdln> (I mean .index.html or sth)
[18:58:19] <fredy> :)
[18:59:31] <thiez> it's kind of bad that we just .get() all the time without checking if the Option contains a proper value
[18:59:53] <thiez> in some ways we're just as bad as null pointers :)
[18:59:58] <fredy> thiez: this is exactly what I was going to ask...
[19:00:17] <fredy> I didn't know get() so I used pattern matching
[19:00:20] <kimundi> thiez: I think in theory it could get down to this: let res: ~[int] = "45 99 98 74".word_iter().map( |s| s.parse().get() ).collect();
[19:00:32] <fredy> and worked fine with non integers...
[19:00:40] <fredy> in this example...
[19:00:57] <thiez> rusti: let i = "45 99 foo 98 74".word_iter(); i.transform(|s| FromStr::from_str::<int>(s).get_or_default(0)).collect::<~[int]>()
[19:00:58] <engla> .get() isn't as bad, since the behavior should be well defined
[19:00:58] -rusti- ~[45, 99, 0, 98, 74]
[19:01:00] <thiez> ;)
[19:01:39] <thiez> the behaviour for dereferencing null is quite well defined in several languages, such as Java
[19:02:29] <kimundi> well in this case we knew it wouldn't fail. To handle invalid inputs you could either handle the case in the map closure, or just gather a ~[Option<int>] and work with that.
[19:02:41] <strcat> thiez: it's only really an issue in kernel-space anyway
[19:03:02] <strcat> not having data races or dangling references is much more compelling
[19:03:10] *** Quits: int3_ (int3_@moz-ABE52D50.hsd1.ca.comcast.net) (Client exited)
[19:03:11] <engla> thiez: at least my  vec.pop_opt() landed. So you can pop safely!
[19:03:23] *** Quits: glinscott (garylinsco@789A6618.53EB7C1.FFFE3AA.IP) (Quit: glinscott)
[19:03:48] *** Quits: BizarreCake (BizarreCak@moz-361FE9B2.dynamic.barak-online.net) (Ping timeout)
[19:04:00] *** Joins: true_droid (Adium@moz-123FD9B8.beck.volia.net)
[19:04:16] *** Joins: glinscott (garylinsco@789A6618.53EB7C1.FFFE3AA.IP)
[19:04:26] <kimundi> rusti: let x: ~[int] = ~[]; x.pop_opt()
[19:04:27] -rusti- <anon>:7:30: 8:5 error: type `~[int]` does not implement any method in scope named `pop_opt`
[19:04:27] -rusti- <anon>:7          let x: ~[int] = ~[]; x.pop_opt()
[19:04:27] -rusti- <anon>:8     };
[19:04:27] -rusti- error: aborting due to previous error
[19:04:27] -rusti- application terminated with error code 101
[19:04:32] <kimundi> rusti: let x: ~[int] = ~[]; x.pop()
[19:04:33] -rusti- <anon>:7:30: 7:31 error: cannot borrow immutable local variable as mutable
[19:04:33] -rusti- <anon>:7          let x: ~[int] = ~[]; x.pop()
[19:04:33] -rusti-                                        ^
[19:04:33] -rusti- error: aborting due to previous error
[19:04:33] *** concrete.mozilla.org sets mode: +M 
[19:04:35] -rusti- application terminated with error code 101
[19:04:44] <strcat> Luqman: maybe it's just from pretending ~fn is @
[19:05:13] *** Joins: tjc (tjc@moz-CC24D9B1.tmodns.net)
[19:05:13] *** ChanServ sets mode: +o tjc
[19:05:54] *** Quits: gamakichi (Mibbit@moz-C207C5B5.range86-145.btcentralplus.com) (Quit: http://www.mibbit.com ajax IRC Client)
[19:06:16] *** Joins: sw17ch (sw17ch@moz-675AFBCF.hsd1.mi.comcast.net)
[19:06:39] *** Quits: sw17ch (sw17ch@moz-675AFBCF.hsd1.mi.comcast.net) (Quit: sw17ch)
[19:07:18] <thiez> it still surprises me that the atomic ops are somehow considered unsafe, when in fact they are more safe than the default read/write :p
[19:08:09] <strcat> Luqman: oh well trying to make a failing test case
[19:09:29] *** concrete.mozilla.org sets mode: -M 
[19:11:38] *** Quits: true_droid (Adium@moz-123FD9B8.beck.volia.net) (Quit: Leaving.)
[19:12:03] <bblum> thiez: feel free to open a bug/rfc about it
[19:12:06] <bblum> i basically agree
[19:12:37] <thiez> bblum: right now they do work on & and &mut, but there is a PR to change it to use * and *mut
[19:12:51] <strcat> Luqman: there are uninit reads
[19:12:52] <bblum> hmm why
[19:12:58] <bblum> that seems backwards
[19:13:20] <strcat> ==19909== Invalid read of size 8
[19:13:22] <strcat> ==19909==    at 0x594DA14: rust_try_get_task (rust_task.h:661)
[19:13:23] <thiez> bblum: https://github.com/mozilla/rust/issues/6314
[19:13:24] <strcat> ==19909==    by 0x4ED4A55: rt::context::_e6f35cc2e94e979::_0$x2e7 (in /home/strcat/projects/rust/x86_64-unknown-linux-gnu/stage1/lib/rustc/x86_64-unknown-linux-gnu/lib/libstd-6c65cf4b443341b1-0.7.so)
[19:13:26] <strcat> ==19909==    by 0x4EFB72E: _$SP$$SP$$x3f::_10fa27a6944913ec::glue_drop_17847 (in /home/strcat/projects/rust/x86_64-unknown-linux-gnu/stage1/lib/rustc/x86_64-unknown-linux-gnu/lib/libstd-6c65cf4b443341b1-0.7.so)
[19:13:28] <strcat> ;[
[19:13:35] <strcat> hm
[19:13:38] <thiez> brson considers them 'very unsafe operations' :p
[19:14:13] <strcat> these could just be ones that are usually suppressed though
[19:14:19] <strcat> we suppress too much so I can't debug with it
[19:15:32] <strcat> okay I think I broke vectors/strings
[19:15:34] <strcat> hm
[19:15:46] *** Quits: sankha93 (Instantbir@513CD6A2.E6798AF8.8B6C1D65.IP) (Quit: Instantbird 1.4 -- http://www.instantbird.com)
[19:16:15] *** Quits: jensnockert (jensnocker@moz-8BE55278.customer.t3.se) (Input/output error)
[19:17:24] *** Joins: relistan (relistan@moz-2DE8112B.cable.virginmedia.com)
[19:19:58] *** Quits: pyrac (pyrac@moz-18D74BD0.w90-60.abo.wanadoo.fr) (Quit: pyrac)
[19:20:34] *** Joins: pyrac (pyrac@moz-18D74BD0.w90-60.abo.wanadoo.fr)
[19:20:35] *** Joins: Blub\0 (wry@7E3BB9D.71150E1A.237AE2BA.IP)
[19:20:53] *** Quits: Blub\w (wry@7E3BB9D.71150E1A.237AE2BA.IP) (Ping timeout)
[19:21:35] *** Quits: tjc (tjc@moz-CC24D9B1.tmodns.net) (Ping timeout)
[19:22:04] *** Joins: tjc (tjc@moz-CC24D9B1.tmodns.net)
[19:22:04] *** ChanServ sets mode: +o tjc
[19:22:38] *** Quits: nano (nano@moz-972880B.superkabel.de) (Connection reset by peer)
[19:26:30] *** Joins: jensnockert (jensnocker@moz-C5F27039.cust.bredband2.com)
[19:30:37] *** Joins: wilsonk-laptop (kvirc@moz-39EFBFC2.cg.shawcable.net)
[19:31:21] *** Joins: RMF (RMF@moz-2CA5F393.dsl.telepac.pt)
[19:33:28] *** Joins: int3_ (int3_@moz-ABE52D50.hsd1.ca.comcast.net)
[19:36:57] *** Joins: pnathan (Adium@moz-E3C3FAF2.hfc.comcastbusiness.net)
[19:39:33] *** Quits: int3_ (int3_@moz-ABE52D50.hsd1.ca.comcast.net) (Ping timeout)
[19:41:23] *** Joins: hjr3 (hradtke@moz-842BF853.hsd1.ca.comcast.net)
[19:43:05] *** Quits: pnathan (Adium@moz-E3C3FAF2.hfc.comcastbusiness.net) (Ping timeout)
[19:45:31] *** Quits: tjc (tjc@moz-CC24D9B1.tmodns.net) (Quit: zzzzzzzzzz)
[19:46:49] <AutomatedTester> hi, can methods have default values?
[19:47:07] <strcat> there are default methods, yes
[19:47:14] <strcat> if that's what you mean
[19:47:35] <heftig> i think they mean default values for omitted arguments
[19:47:46] <thiez> in that case, nope
[19:47:54] <AutomatedTester> I mean what heftig said
[19:48:24] <AutomatedTester> so I cant equate def foo(bar='baz'): from python to Rust
[19:48:44] <thiez> indeed you cannot
[19:48:57] *** Joins: Earnestly (earnest@2A2BF8F5.321FA5E6.BFD1ABFD.IP)
[19:49:07] <AutomatedTester> ok cool
[19:49:10] * strcat really can't figure this issue out
[19:49:18] <thiez> I agree it would be a nice feature
[19:50:07] *** Joins: ghrust (ghrust@DE823A67.6A2AE50.F3114085.IP)
[19:50:07] <ghrust> 01[13rust01] 15bors merged 06auto into 06master: 02http://git.io/hKTUSw
[19:50:07] *** Parts: ghrust (ghrust@DE823A67.6A2AE50.F3114085.IP) ()
[19:50:19] <roo> bah, you can hide all the default arguments you want in &self :P
[19:51:25] <strcat> bblum: any idea if the scheduler uses exchange allocs somewhere? ;\
[19:51:37] <strcat> hrm
[19:51:38] <strcat> or TLS
[19:51:55] <bblum> strcat: the new rust one?
[19:52:00] <bblum> it uses exchange allocs everywhere
[19:52:02] <strcat> bblum: no the current one
[19:52:11] <strcat> and I mean using the exchange allocator directly for something
[19:52:12] <bblum> oh, uh, i don't think so
[19:52:17] <strcat> rather than through ~
[19:52:19] <strcat> hm
[19:52:20] <bblum> by TLS do you mean rust TLS or linux TLS
[19:52:27] <strcat> rust tls
[19:53:02] <bblum> well, it takes care of rust tls
[19:53:07] <strcat> I think what must be happening is that something is pretending to be ~T
[19:53:08] <bblum> like there's a pointer and some cleanup code
[19:53:09] *** Joins: ghrust (ghrust@1E8607E8.6A2AE50.F3114085.IP)
[19:53:09] <ghrust> 01[13rust01] 15bors pushed 0 new commits to 06auto: 02http://git.io/pNepEg
[19:53:09] *** Parts: ghrust (ghrust@1E8607E8.6A2AE50.F3114085.IP) ()
[19:53:10] *** Joins: ghrust (ghrust@CFE85B59.6A2AE50.F3114085.IP)
[19:53:10] <ghrust> 01[13rust01] 15bors pushed 2 new commits to 06auto: 02http://git.io/SvXYfw
[19:53:10] <ghrust> 13rust/06auto 14f80d6dc 15Graydon Hoare: rustc: improve -Z trans-stats to report per-fn LLVM instruction counts and translation timing
[19:53:10] <ghrust> 13rust/06auto 1428643d4 15bors: auto merge of #7456 : graydon/rust/better-trans-stats, r=cmr...
[19:53:10] *** Parts: ghrust (ghrust@CFE85B59.6A2AE50.F3114085.IP) ()
[19:53:29] <AutomatedTester> does rust handle variable argument length?
[19:53:41] <strcat> bblum: aha, there are places with casts from ~
[19:54:18] <thiez> AutomatedTester: do you mean method overloading by argument number, such as 'foo(&self, x: int)' and 'foo(&self, x: int, y:int)' ? We don't support that afaik.
[19:54:55] <heftig> AutomatedTester: varargs aren't supported, either
[19:54:58] <strcat> hm
[19:55:05] <heftig> the printf-like fmt! is special sauce
[19:55:07] <engla> AutomatedTester: only variadic macros.
[19:55:10] *** Quits: Amanieu (amanieu@CB5576F2.F4BF8C9A.9510F13D.IP) (Quit: leaving)
[19:55:17] *** Joins: victorporof (victorporo@74A9C5E8.1745F5FA.9B1E38F4.IP)
[19:55:27] <AutomatedTester> thiez: either overloading or just have something analogous to python/ruby *args 
[19:55:29] *** Joins: Amanieu (amanieu@CB5576F2.F4BF8C9A.9510F13D.IP)
[19:55:36] <thiez> 'fraid not
[19:55:53] <AutomatedTester> ok
[19:56:00] <AutomatedTester> is it planned?
[19:56:12] <strcat> don't really think so
[19:56:15] <thiez> not as far as I'm aware
[19:56:17] <strcat> there has been no proposal for it
[19:56:25] <thiez> I believe it has been mentioned on irc before
[19:56:42] <strcat> no one has actually thought over the implications and made a concrete proposal
[19:57:02] <strcat> hrm
[19:57:07] <AutomatedTester> fair enough
[19:57:36] *** Quits: BitPuffin (quassel@moz-911FB3CE.cust.tele2.se) (Ping timeout)
[19:57:44] *** Joins: graydon (graydon@moz-9918B407.vc.shawcable.net)
[19:57:44] *** ChanServ sets mode: +qo graydon graydon
[19:57:58] *** Quits: graydon (graydon@moz-9918B407.vc.shawcable.net) (Quit: Leaving.)
[19:58:11] <AutomatedTester> I have been abusing variable argument length/overloading for years so need to relearn things ;)
[19:59:41] <Ms2ger> That seems annoying
[19:59:48] *** Joins: jmgrosen (jmgrosen@moz-848F6087.sb.sd.cox.net)
[20:00:05] <thiez> Ms2ger: why is that?
[20:00:34] <thiez> I wouldn't mind if option had get() and get(default:T) instead of get() and get_or_default(default:T)
[20:01:10] <AutomatedTester> did I imagine that rust had implicit returns?
[20:01:15] <Ms2ger> It does
[20:01:30] <Ms2ger> fn foo() -> int { 0 }
[20:01:44] <Ms2ger> (Leave out the semicolon)
[20:01:50] <thiez> last statement = return value, iff it doesn't end with a semicolon
[20:02:23] <thiez> it can even get complex:
[20:02:42] *** Joins: BitPuffin (quassel@moz-911FB3CE.cust.tele2.se)
[20:04:39] <thiez> rusti: fn foo<T>(o: Option<T>) -> bool { match o { Some(_) => true, _ => false } } let (o1,o2): (Option<int>,Option<int>) = (Some(0),None); (foo(o1),foo(o2))
[20:04:40] -rusti- (true, false)
[20:04:46] <thiez> nice implicit returns
[20:07:14] <strcat> Luqman: I have a simple test case with an issue now
[20:07:32] <strcat> Luqman: http://ix.io/6y4
[20:07:32] *** Quits: BitPuffin (quassel@moz-911FB3CE.cust.tele2.se) (Ping timeout)
[20:10:37] <doener> strcat: what does that cause?
[20:10:58] <strcat> doener: it doesn't call the drop function (this is with removed exchange alloc headers)
[20:11:08] <strcat> I think what's happening is that ~[T] is being treated as ~T somewhere
[20:11:11] <strcat> and ~T has no headers
[20:11:47] <doener> strcat: but ~T would call drop
[20:12:23] <strcat> doener: but ~T has a different layout now
[20:13:19] <doener> strcat: hm, wouldn't that only explain a crash, but not that drop is not called at all?
[20:13:51] <strcat> doener: no, there's no guarantee on what happens when stuff goes wrong like that
[20:13:57] <strcat> the glue has checks for drop flags, etc.
[20:14:04] <strcat> it could just be reading the wrong memory
[20:15:22] <doener> ah, it reads the flag from the value
[20:18:47] *** kimundi is now known as zz_kimundi
[20:21:21] *** Quits: jmgrosen (jmgrosen@moz-848F6087.sb.sd.cox.net) (Quit: jmgrosen)
[20:22:15] *** Quits: roo (jesse.rudo@moz-B7585E4C.dynamic.ip.windstream.net) (Ping timeout)
[20:23:23] *** Quits: glinscott (garylinsco@789A6618.53EB7C1.FFFE3AA.IP) (Quit: glinscott)
[20:23:26] *** Joins: roo (jesse.rudo@moz-B7585E4C.dynamic.ip.windstream.net)
[20:23:51] *** Quits: gour (gour@moz-DD806E2F.adsl.net.t-com.hr) (Quit: WeeChat 0.4.0)
[20:27:00] *** Joins: FrozenCow (FrozenCow@moz-B2DF4929.chello.nl)
[20:30:28] *** Quits: enix (enix@moz-A50569DD.c3-0.slvr-ubr1.lnh-slvr.md.cable.rcn.com) (Quit: Konversation terminated!)
[20:36:04] *** Joins: vk (vk@moz-389FEE13.hsd1.ca.comcast.net)
[20:39:52] *** Quits: vk (vk@moz-389FEE13.hsd1.ca.comcast.net) (Quit: vk)
[20:40:14] <strcat>   %28 = getelementptr inbounds { i64, %tydesc*, i8*, i8*, { i64, i64, [0 x i8] } }* %26, i32 0, i32 4
[20:40:19] <strcat> before my changes it's doing that
[20:40:29] <strcat>   %28 = bitcast { i64, %tydesc*, i8*, i8*, { i64, i64, [0 x i8] } }* %26 to { i64, i64, [0 x i8] }*
[20:40:32] <strcat> now it started doing this
[20:40:35] * strcat sighs
[20:40:51] <strcat> don't really see where I broke it though
[20:43:31] <strcat> I guess it pretends it's ~T
[20:43:34] <strcat> and box_body is wrong
[20:43:36] <strcat> makes sense
[20:45:10] <strcat> expand_boxed_vec_ty is to blame
[20:45:33] <strcat> Luqman: wooo, found the issue
[20:46:27] *** Joins: maxli (maxli@B5559308.9C54E60.2FA4EA88.IP)
[20:46:31] <thiez> strcat: do you have any data about (reduced) memory used yet?
[20:48:20] <strcat> thiez: no, but I know exactly how much less memory exchange allocs will use
[20:48:27] <strcat> it removes a 4 word header from each one
[20:48:36] <strcat> and the jemalloc/glibc size classes are known
[20:48:43] *** Joins: sankha93 (Instantbir@513CD6A2.E6798AF8.8B6C1D65.IP)
[20:48:45] <strcat> 8 byte alloc: 64 bytes now, will be 16 bytes
[20:48:50] <strcat> 16 byte alloc: 64 bytes now, will be 16 bytes
[20:48:59] <strcat> 32 byte alloc: 64 bytes now, will be 32 bytes
[20:49:26] <strcat> 64 byte alloc: 128 bytes now, will be 64 bytes
[20:49:39] <thiez> sure, I was just wondering how much this would reduce memory use of rustc
[20:49:48] <thiez> I know about your work on the headers :)
[20:49:58] <thiez> (and it's awesome)
[20:49:59] <strcat> thiez: I have a feeling not much
[20:50:06] <strcat> they are all @ or managed-unique
[20:50:19] <thiez> that's a shame
[20:50:49] <thiez> has there been any more discussion about making a Unique trait lang-item-thingy?
[20:51:26] *** zz_kimundi is now known as kimundi
[20:51:45] *** Quits: geomyidae (geomyidae@DD6F7E3A.21468E9A.30200F38.IP) (Quit: Konversation terminated!)
[20:51:53] <strcat> thiez: not yet
[20:53:51] *** Joins: vk (vk@moz-389FEE13.hsd1.ca.comcast.net)
[20:53:56] <thiez> I look forward to hearing what the other devs thing about it
[20:56:46] <thiez> s/thing/think
[20:57:14] <jensnockert> I wish Rust had some sort of Clippy-equivalent: "It looks like you're trying to byte-swap things until it works? Would you like toâ€¦"
[20:57:53] <strcat> anyway
[20:58:00] <strcat> now that I can get a "working" compiler
[20:58:03] <strcat> I can just look at the IR ;p
[20:58:06] <strcat> easy mode!
[20:58:26] <strcat> I think this will land today :)
[20:59:41] *** Quits: Ms2ger (Ms2ger@moz-E9883900.access.telenet.be) (Quit: nn)
[21:00:15] * jensnockert hugs strcat.
[21:00:34] <engla> wow cool
[21:00:52] <strcat> error: internal compiler error: box_body() invoked on non-box type ~str
[21:00:59] <strcat> just need to make a way to get the body
[21:01:02] <strcat> without pretending it is ~T
[21:01:09] <doomlord> https://github.com/mozilla-servo/rust-cocoa <<< interesting, does any of thiswork?
[21:01:23] <strcat> unless there is one already..
[21:01:25] <strcat> hm
[21:01:27] <strcat> pub fn get_bodyptr(bcx: block, vptr: ValueRef) -> ValueRef {
[21:01:29] <strcat> heh
[21:02:37] <jensnockert> doomlord: I think Servo uses it on OS X.
[21:03:09] *** Joins: echristo (echristo@moz-1892C634.hsd1.ca.comcast.net)
[21:03:53] *** Quits: km (quassel@FDBAF0A0.DBF71E41.29C67456.IP) (Ping timeout)
[21:04:20] <jensnockert> doomlord: Not that it actually does much. You could just use the C FFI instead.
[21:07:05] *** Quits: dwhyte (dwhyte@ED9190FB.B72E355F.7BF4A4B0.IP) (Client exited)
[21:08:19] *** Joins: jfbk (user@moz-EEA9CFB3.nyc.res.rr.com)
[21:08:31] *** Quits: spider-mario (spidermari@moz-81131DB6.fbx.proxad.net) (Input/output error)
[21:08:42] *** Joins: dwhyte (dwhyte@ED9190FB.B72E355F.7BF4A4B0.IP)
[21:09:01] <Luqman> strcat: \o/ awesome! i was just going to try and trace out your test case through trans. guess i don't need to now :D
[21:11:58] *** Quits: mzabaluev (mzabaluev@moz-91FFD755.dhcp.inet.fi) (Ping timeout)
[21:12:02] <strcat> Luqman: the IR made the mistake obvious
[21:12:09] <strcat> luckily
[21:12:16] <strcat> I'm totally incapable of debugging asserts ;p
[21:12:49] <strcat> Luqman: http://ix.io/6ya I'll see if this works
[21:12:59] <strcat> Luqman: basically, the free glue was faking it being ~T
[21:15:17] <Luqman> fingers crossed
[21:17:21] *** Quits: robert (robertknig@moz-B6DD6E0B.range86-166.btcentralplus.com) (Ping timeout)
[21:19:38] <strcat> meh
[21:19:41] <strcat> /bin/sh: line 1: 23295 Segmentation fault      x86_64-unknown-linux-gnu/stage2/bin/rustc --cfg stage2 -O -Z no-debug-borrows --target=x86_64-unknown-linux-gnu -D warnings -o x86_64-unknown-linux-gnu/stage2/lib/rustc/x86_64-unknown-linux-gnu/lib/libstd.so /home/strcat/projects/rust/src/libstd/std.rs
[21:19:50] *** Quits: vilonis (jared@moz-EE5D17ED.ph.ph.cox.net) (Quit: WeeChat 0.3.8)
[21:19:59] *** Quits: Blub\0 (wry@7E3BB9D.71150E1A.237AE2BA.IP) (Quit: night)
[21:20:50] <strcat> Luqman: I didn't fix it
[21:20:52] <strcat> I made it worse
[21:20:54] <strcat> same issue
[21:22:38] <Luqman> well, for the simple test case at least it's a segfault instead of being silently wrong
[21:22:59] <strcat> Luqman: yeah the IR is very wrong
[21:23:08] <strcat> anyway I know what I have to fix, just not exactly how
[21:23:10] <strcat> ;p
[21:23:34] <strcat> I could try teaching box_body to handle vectors/strings
[21:24:33] *** Joins: mib_gtatqc (Mibbit@moz-C207C5B5.range86-145.btcentralplus.com)
[21:25:36] *** Joins: pnathan (Adium@B9840254.2CD8A5F8.477B877D.IP)
[21:26:04] *** Joins: ghrust (ghrust@79968228.6A2AE50.F3114085.IP)
[21:26:04] <ghrust> 01[13rust01] 15bors merged 06auto into 06master: 02http://git.io/SvXYfw
[21:26:04] *** Parts: ghrust (ghrust@79968228.6A2AE50.F3114085.IP) ()
[21:27:19] *** Quits: eevee (eevee@moz-58058235.evrt.wa.frontiernet.net) (Connection reset by peer)
[21:27:22] *** Joins: tikue (tkuehn@moz-A7CDB794.dia.static.qwest.net)
[21:27:25] *** Joins: eevee (eevee@moz-58058235.evrt.wa.frontiernet.net)
[21:27:28] *** Quits: vk (vk@moz-389FEE13.hsd1.ca.comcast.net) (Quit: vk)
[21:29:02] *** Joins: ghrust (ghrust@F6EE6DE3.6A2AE50.F3114085.IP)
[21:29:02] <ghrust> 01[13rust01] 15bors pushed 0 new commits to 06auto: 02http://git.io/vgBWPw
[21:29:02] *** Parts: ghrust (ghrust@F6EE6DE3.6A2AE50.F3114085.IP) ()
[21:29:04] *** Joins: ghrust (ghrust@CFE85B59.6A2AE50.F3114085.IP)
[21:29:04] <ghrust> 01[13rust01] 15bors pushed 5 new commits to 06auto: 02http://git.io/GGrgMw
[21:29:04] <ghrust> 13rust/06auto 142a6c60e 15Fedor Indutny: libc: add _SC_* consts for non-mips linux too...
[21:29:04] <ghrust> 13rust/06auto 14f93eda5 15Fedor Indutny: libc: VirtualAlloc and FileMapping bindings
[21:29:04] <ghrust> 13rust/06auto 147a1db82 15Fedor Indutny: libc: add errno values
[21:29:05] *** Parts: ghrust (ghrust@CFE85B59.6A2AE50.F3114085.IP) ()
[21:29:51] *** Joins: glinscott (garylinsco@789A6618.53EB7C1.FFFE3AA.IP)
[21:30:28] <strcat> Luqman: http://ix.io/6ye yet another attempt
[21:30:30] <strcat> ;p
[21:30:38] <Luqman> the ir for glue_drop is weird, it does 3 bitcasts, i8* to BoxRepr** to i8* to BoxRepr**
[21:30:42] <sfackler> does anyone know how to get this to work? https://gist.github.com/sfackler/5945054
[21:30:54] <strcat> Luqman: yep I'm not worried about the huge mess it is yet ;p
[21:30:58] <strcat> just want ~ headers gone
[21:31:05] <strcat> then ~[] headers
[21:31:11] <strcat> then I can try cleaning up ;p
[21:31:45] *** Quits: pnathan (Adium@B9840254.2CD8A5F8.477B877D.IP) (Ping timeout)
[21:33:54] *** Joins: jmgrosen (jmgrosen@moz-848F6087.sb.sd.cox.net)
[21:34:04] <strcat> Luqman: well it's compiling
[21:34:06] <strcat> ;p
[21:34:10] <strcat> stage1 I mean
[21:34:44] *** Quits: tikue (tkuehn@moz-A7CDB794.dia.static.qwest.net) (Quit: tikue)
[21:35:13] *** Quits: sankha93 (Instantbir@513CD6A2.E6798AF8.8B6C1D65.IP) (Quit: Instantbird 1.4 -- http://www.instantbird.com)
[21:35:18] *** Joins: geomyidae (geomyidae@DD6F7E3A.21468E9A.30200F38.IP)
[21:35:33] <Luqman> hopefully the code it generates actually works too
[21:36:55] *** Quits: hjr3 (hradtke@moz-842BF853.hsd1.ca.comcast.net) (Ping timeout)
[21:37:11] <sfackler> hrm, apparently Foo::bar::<int, int>() does it
[21:37:26] <thiez> that is strange
[21:37:46] <strcat> Luqman: yeah but I expect no
[21:37:49] <strcat> ;p
[21:37:55] <strcat> not*
[21:38:39] *** Joins: paulfryzel (paulfryzel@moz-C751AD73.nyc.res.rr.com)
[21:38:51] <strcat> Luqman: still wrong!
[21:39:00] *** Joins: BluePeppers (user@moz-3799699A.range81-151.btcentralplus.com)
[21:39:10] <Luqman> :(
[21:39:44] <strcat> it refuses to work ;[
[21:40:22] <strcat> Luqman: oh I see what I did wrong
[21:40:51] <strcat> silly mistake
[21:41:20] <strcat> I left the branch I added as saying there's no header
[21:41:25] <strcat> so it accomplished nothing
[21:41:33] <strcat> flipped the bool, should work now
[21:41:40] *** Quits: relistan (relistan@moz-2DE8112B.cable.virginmedia.com) (Quit: relistan)
[21:41:41] <strcat> and renamed it
[21:41:43] <strcat> ;p
[21:42:43] *** Joins: hjr3 (hradtke@moz-842BF853.hsd1.ca.comcast.net)
[21:43:39] <paulfryzel> anyone else been having trouble building 0.7? i'm getting the error "multiple matching crates for `std`"
[21:44:20] <Luqman> paulfryzel: you probably have old versions laying around
[21:44:55] *** Joins: SiegeLord (sl@moz-CAF07B4C.hsd1.ma.comcast.net)
[21:44:59] <Luqman> strcat: \o/
[21:45:21] *** Parts: dwhyte (dwhyte@ED9190FB.B72E355F.7BF4A4B0.IP) ()
[21:45:27] <paulfryzel> Luqman: hmm, that's what i was thinking... but I thought i got rid of all the 0.6 references. i'll take another look, thanks.
[21:46:31] *** Joins: vk (vk@moz-389FEE13.hsd1.ca.comcast.net)
[21:47:38] *** Quits: mib_gtatqc (Mibbit@moz-C207C5B5.range86-145.btcentralplus.com) (Quit: http://www.mibbit.com ajax IRC Client)
[21:47:49] <jensnockert> Kill me slowly, please.
[21:48:09] <jensnockert> rusti: 0xFFu8 >> 3
[21:48:10] -rusti- 31
[21:48:21] <thiez> paulfryzel: try doing 'make clean'
[21:48:41] <jensnockert> rusti: -1i8 >> 3
[21:48:42] -rusti- -1
[21:48:56] <jensnockert> Hmâ€¦ apparently not.
[21:48:57] <strcat> rusti: let b = 5 as bool; (b, b == true)
[21:48:58] -rusti- (true, false)
[21:49:04] <jensnockert> Still no idea why my rotate is b0rken.
[21:49:18] <strcat> jensnockert: just blame rustc, it's easier that way
[21:49:20] <strcat> :p
[21:49:33] <jensnockert> strcat: Yeah, but then I would have to fix it :(
[21:49:34] <strcat> Luqman: stage2 compiler doesn't crash
[21:49:38] <strcat> oh wait
[21:49:39] <paulfryzel> thiez: thanks, i'll try that. haven't clean'd since removing 0.6.
[21:49:46] <strcat> Luqman: err, it does
[21:50:55] <strcat> Luqman: ah nvm
[21:50:58] * strcat is silly
[21:51:02] <strcat> was looking at the wrong term
[21:51:06] <strcat> *sigh*
[21:51:15] *** Joins: james4k (james@moz-E7990244.consolidated.net)
[21:51:25] <strcat> Luqman: fixed that issue :D
[21:51:27] <Luqman> lol, too many terms
[21:51:50] <Luqman> even worse when you have more than 10 in screen so accessing them becomes a pain
[21:51:52] <strcat> Luqman: it made it through stage2 libstd/libextra :)
[21:51:58] <Luqman> strcat: yay \o/
[21:52:06] <strcat> I could be asking for an r+ soon... we'll see ;p
[21:52:13] *** Joins: tikue (tkuehn@moz-A7CDB794.dia.static.qwest.net)
[21:52:19] <strcat> and a p=50000
[21:52:21] <strcat> ;p
[21:53:01] <thiez> p=9001 should be big enough
[21:53:38] * strcat wants his stage2 compiler
[21:53:43] <strcat> hurry up rustc
[21:53:51] <strcat> I have trees to benchmark!
[21:56:12] *** Quits: jmgrosen (jmgrosen@moz-848F6087.sb.sd.cox.net) (Quit: jmgrosen)
[21:56:19] <engla> I saw owned doubly-linked lists mentioned. I'm giving it a go now
[21:57:09] <strcat> noooooo
[21:57:11] <strcat> a test failed
[21:57:16] *** Joins: alex-abreu (alex@moz-7421D6C9.mc.videotron.ca)
[21:57:42] <strcat> test [run-pass] run-pass/borrowck-mut-uniq.rs ... FAILED
[21:57:44] <strcat> ;[
[21:57:57] <thiez> preserve_the_pointless_headers.rs ... FAILED
[21:58:01] *** Joins: Jesin (Jessin_@moz-3AD6F09F.res.lehigh.edu)
[21:59:53] *** Joins: km (quassel@FDBAF0A0.DBF71E41.29C67456.IP)
[22:01:26] <Luqman> strcat: that tests seems to segault in visit_int
[22:01:31] <cmr> strcat: you're in the test suite now? nice!
[22:02:05] *** Joins: ghrust (ghrust@C621748.6A2AE50.F3114085.IP)
[22:02:05] <ghrust> 01[13rust01] 15bors 04force-pushed 06auto from 147c6fa09 to 1428643d4: 02http://git.io/N3iJvQ
[22:02:05] *** Parts: ghrust (ghrust@C621748.6A2AE50.F3114085.IP) ()
[22:02:07] *** Joins: ghrust (ghrust@1E8607E8.6A2AE50.F3114085.IP)
[22:02:07] <ghrust> 01[13rust01] 15bors pushed 2 new commits to 06auto: 02http://git.io/RpV-ew
[22:02:07] <ghrust> 13rust/06auto 1401833de 15Daniel Micay: remove extra::rope...
[22:02:07] <ghrust> 13rust/06auto 142504791 15bors: auto merge of #7629 : thestinger/rust/rope, r=graydon...
[22:02:07] *** Parts: ghrust (ghrust@1E8607E8.6A2AE50.F3114085.IP) ()
[22:02:30] <strcat> error: test run failed!
[22:02:32] <strcat> command: x86_64-unknown-linux-gnu/test/run-pass/trait-bounds-in-arc.stage2-x86_64-unknown-linux-gnu 
[22:02:38] <strcat> error: compilation failed!
[22:02:39] <strcat> command: x86_64-unknown-linux-gnu/stage2/bin/rustc /home/strcat/projects/rust/src/test/run-pass/unique-destructure.rs -o x86_64-unknown-linux-gnu/test/run-pass/unique-destructure.stage2-x86_64-unknown-linux-gnu -L x86_64-unknown-linux-gnu/test/run-pass -L x86_64-unknown-linux-gnu/test/run-pass/unique-destructure.libaux -O --target=x86_64-unknown-linux-gnu
[22:02:46] <strcat> rustc: /home/strcat/projects/rust/src/llvm/include/llvm/IR/Instructions.h:704: llvm::Type* llvm::checkGEPType(llvm::Type*): Assertion `Ty && "Invalid GetElementPtrInst indices for type!"' failed.
[22:03:01] <strcat> rust: task failed at 'left: 0 does not equal right: 10', /home/strcat/projects/rust/src/test/run-pass/unique-object.rs:28
[22:03:02] <strcat> rust: domain main @0x243d1b0 root task failed
[22:03:04] <strcat> ;[
[22:03:07] <strcat> 6 failed
[22:03:56] <strcat> it doesn't make treemap faster... hrm
[22:04:14] <thiez> does it make treemap smaller?
[22:04:18] <strcat> dunno
[22:04:20] <strcat> sec
[22:04:28] <strcat> something seems wrong if it's not faster.
[22:04:42] <thiez> perhaps both the old and the new version still fit in cache
[22:04:48] <thiez> how big are you making it?
[22:04:53] <strcat> 100k
[22:04:57] <strcat> nodes
[22:05:05] <strcat>   %3 = call i8* @"_ZN2rt11global_heap15exchange_malloc17_85cf99a172767d357_0$x2e0E"({ i64, %tydesc*, i8*, i8*, i8 }* undef, i32 8, i64 8)
[22:05:07] <strcat> now
[22:05:10] <strcat> for an ~5
[22:05:23] <strcat> err
[22:05:25] <strcat> sorry
[22:05:32] <strcat> that's not relevant
[22:05:34] <strcat> ;p
[22:06:10] <thiez> sure it is, you're teaching us IR through osmosis.
[22:06:22] <strcat> the call to exchange_malloc is the same in both though
[22:06:30] <strcat> the internals are different
[22:06:39] <strcat> anyway hm
[22:06:53] <strcat> the treemap I'm testing could just be an unfortunate size
[22:07:54] <strcat> key, value, ptr, ptr, word
[22:07:55] <strcat> so..
[22:07:57] *** Quits: reyre_ (reyre@moz-9002CDDA.cpe.net.cable.rogers.com) (Client exited)
[22:08:33] <strcat> *shrug*
[22:09:30] *** Quits: hjr3 (hradtke@moz-842BF853.hsd1.ca.comcast.net) (Ping timeout)
[22:09:54] *** Quits: vk (vk@moz-389FEE13.hsd1.ca.comcast.net) (Quit: vk)
[22:11:04] *** Joins: ghrust (ghrust@24260B07.6A2AE50.F3114085.IP)
[22:11:04] <ghrust> 01[13rust01] 15bors 04force-pushed 06auto from 142504791 to 1428643d4: 02http://git.io/N3iJvQ
[22:11:04] *** Parts: ghrust (ghrust@24260B07.6A2AE50.F3114085.IP) ()
[22:11:05] *** Joins: ghrust (ghrust@AD60B2E3.6A2AE50.F3114085.IP)
[22:11:05] <ghrust> 01[13rust01] 15bors pushed 2 new commits to 06auto: 02http://git.io/9gcv7w
[22:11:05] <ghrust> 13rust/06auto 1495dabe4 15Andrew Paseltiner: iterator: Add `IteratorUtil::peek_` method
[22:11:05] <ghrust> 13rust/06auto 144cc78e3 15bors: auto merge of #7604 : apasel422/rust/peek, r=pcwalton...
[22:11:05] *** Parts: ghrust (ghrust@AD60B2E3.6A2AE50.F3114085.IP) ()
[22:11:11] <strcat> wtf bors
[22:11:33] <strcat> make: g++: Command not found
[22:11:34] <strcat> make: *** [rt/i686-pc-mingw32/stage0/sync/timer.o] Error 127
[22:12:17] <strcat> before
[22:12:19] <strcat> ==15086==   total heap usage: 1,000,030 allocs, 1,000,029 frees, 48,400,736 bytes allocated
[22:12:20] <paulfryzel> Luqman, thiez: 'make clean' after removing 0.6 did the trick. thanks for the help!
[22:12:21] <strcat> after
[22:12:23] <strcat> ==15128==   total heap usage: 1,000,030 allocs, 1,000,029 frees, 16,400,736 bytes allocated
[22:12:28] <strcat>     for 1000000.times {
[22:12:30] <strcat>         let x = ~5;
[22:12:32] <strcat>     }
[22:12:34] <strcat> with that
[22:12:36] <strcat> ;p
[22:16:38] <Luqman> strcat: i think the visit glue is not right somewhere
[22:17:04] <thiez> that seems like quite a significant change
[22:17:35] *** Quits: tikue (tkuehn@moz-A7CDB794.dia.static.qwest.net) (Quit: tikue)
[22:17:49] <thiez> I wonder where that 1 alloc memory leak is
[22:17:56] <thiez> probably in the runtime
[22:17:59] <strcat> thiez: yep
[22:18:43] <strcat> thiez: it's not the speed improvement I thought it would be for treemap though :(
[22:18:44] <strcat> makes me sad
[22:18:52] <strcat> means we have other serious perf issues
[22:19:06] <thiez> was there ever any doubt about that?
[22:19:26] <strcat> yeah but I hoped a large part of it was this
[22:19:28] <strcat> for treemap
[22:19:53] <engla> the allocation call itself too right?
[22:20:01] <strcat> engla: yeah
[22:20:02] *** Joins: ghrust (ghrust@F6EE6DE3.6A2AE50.F3114085.IP)
[22:20:02] <ghrust> 01[13rust01] 15bors 04force-pushed 06auto from 144cc78e3 to 1428643d4: 02http://git.io/N3iJvQ
[22:20:02] *** Parts: ghrust (ghrust@F6EE6DE3.6A2AE50.F3114085.IP) ()
[22:20:05] <strcat> our ffi is slow
[22:20:06] *** Joins: ghrust (ghrust@9C8B94D4.6A2AE50.F3114085.IP)
[22:20:07] <ghrust> 01[13rust01] 15bors pushed 2 new commits to 06auto: 02http://git.io/3qhO-Q
[22:20:07] <ghrust> 13rust/06auto 1401833de 15Daniel Micay: remove extra::rope...
[22:20:07] <ghrust> 13rust/06auto 14ddf8247 15bors: auto merge of #7629 : thestinger/rust/rope, r=graydon...
[22:20:07] *** Parts: ghrust (ghrust@9C8B94D4.6A2AE50.F3114085.IP) ()
[22:29:43] *** Joins: pnkfelix (pnkfelix@moz-43495417.fbx.proxad.net)
[22:31:31] <strcat> Luqman: well I didn't update any visitor stuff
[22:31:34] <strcat> maybe I was supposed to
[22:37:37] <strcat> Luqman: I don't really know what's wrong
[22:37:39] <engla> in option, shouldn't the 'a lifetime be on self here?
[22:37:39] <strcat> :(
[22:37:39] <engla> pub fn map<'a, U>(&self, f: &fn(&'a T) -> U) -> Option<U>
[22:37:56] <engla> I just ran into that.
[22:41:03] <thiez> engla: I don't think so, because the &T only has to live as long as the value in the Option, not as long as the option itself
[22:41:49] <cmr> doomlord: did you figure out whatever it was that was confusing you?
[22:41:59] <engla> but if the lifetime locks the self, the T will be unchanged
[22:42:15] *** Quits: FrozenCow (FrozenCow@moz-B2DF4929.chello.nl) (Ping timeout)
[22:42:18] <doomlord> cmr - i have progress with what i'm doing certainly,
[22:42:39] <engla> I'm doing   self.attr.map(|x| &x.value)  and I can't, but I can do the same thing (similar formulation) with .chain_ref and .map_default
[22:42:43] <engla> so I think it's an oversight
[22:42:57] <doomlord> i can't get the &'s.. refs right instinctively yet by any strech.. but i'm usually able to get what i want done, experimenting with the errors..
[22:43:39] <cmr> doomlord: every lifetime error is a potential dangling reference averted :)
[22:43:42] <doomlord> i think the amount of auto-derefing for . (and in other contexts?) makes the code look a little deceptive sometimes, for a C head expecting . & -> :)
[22:43:43] <Luqman> strcat: i'm pretty sure i know why unique-destructure is failing xD
[22:43:56] <strcat> Luqman: why?
[22:44:06] <doomlord> yes, i can see that a little more typing & thought with lifetime annotations saves pain later..
[22:44:10] <Luqman> you forgot to remove the GEPi in line 1877 of trans/_match.rs
[22:44:14] <strcat> Luqman: heh
[22:44:29] <strcat> uggggh
[22:44:31] * strcat sighs
[22:44:49] <doomlord> Wow, you can destructure tuples in function arguments!
[22:44:59] <Luqman> strcat: i'm kinda surprised it didn't fail earlier
[22:45:24] <strcat> doomlord: any irrefutable patterns work there
[22:45:32] <strcat> just as with closures and let statements
[22:45:54] <doomlord> i enjoyed this ability alot in haskel/clojure.. i didn't know rust could do it
[22:46:32] <doomlord> just been using enums' a bit for the first time, great fun
[22:52:25] *** Quits: pyrac (pyrac@moz-18D74BD0.w90-60.abo.wanadoo.fr) (Quit: pyrac)
[22:55:50] <indutny> shit
[22:55:57] <indutny> cmr: sorry :(
[22:56:02] <indutny> I'll figure it out tomorrow
[22:56:02] <cmr> indutny: it's ok :p
[22:58:30] *** Joins: webber46 (webber46@moz-98D2F3C5.cust.bredband2.com)
[22:59:38] <Luqman> strcat: a bit sadly that only fixes that single test
[23:00:55] *** Quits: webber46 (webber46@moz-98D2F3C5.cust.bredband2.com) (Quit: webber46)
[23:01:01] *** Joins: dbaupp (Thunderbir@moz-712A1135.lns20.syd6.internode.on.net)
[23:01:41] <dbaupp> cmr: ping
[23:01:43] *** Joins: enix (enix@moz-A50569DD.c3-0.slvr-ubr1.lnh-slvr.md.cable.rcn.com)
[23:03:35] *** Joins: int3_ (int3_@moz-ABE52D50.hsd1.ca.comcast.net)
[23:03:42] *** Quits: SimonSapin (simon@moz-D0C2F181.zone2.bethere.co.uk) (Ping timeout)
[23:05:20] <cmr> dbaupp: pong
[23:05:22] *** Quits: cr (anonymous@moz-331999F1.dip0.t-ipconnect.de) (Ping timeout)
[23:05:22] *** Quits: int3_ (int3_@moz-ABE52D50.hsd1.ca.comcast.net) (Ping timeout)
[23:05:42] <dbaupp> cmr: nothing exploded?
[23:05:45] <cmr> nope
[23:05:52] <cmr> should be dutifully chugging away
[23:06:02] <cmr> I've been keeping an eye on it
[23:06:04] <dbaupp> (other than memory use, due to aatch's ast stuff)
[23:06:14] <dbaupp> cool!
[23:06:17] <Luqman> strcat: so 3 of the remaining tests fail due to issues with owned trait objects and the other 2 due to something with repr/reflect/visit
[23:06:31] *** Quits: pnkfelix (pnkfelix@moz-43495417.fbx.proxad.net) (Quit: Leaving.)
[23:06:46] <dbaupp> cmr: http://huonw.github.io/isrustfastyet/mem/#0f25155,d91ac39
[23:07:06] <strcat> Luqman: https://github.com/mozilla/rust/pull/7605 could you add it in a comment here?
[23:07:14] <strcat> I don't really feel like working on it anymore atm
[23:07:32] <strcat> very frustrating thing ;p
[23:11:38] *** Joins: aatch (aatch@moz-B437F499.pocketrent.com)
[23:12:06] <Jeaye> meow, darkf 
[23:12:17] <Jeaye> darkf: Have any Rust projects?
[23:14:01] *** Joins: pnathan (Adium@moz-E3C3FAF2.hfc.comcastbusiness.net)
[23:15:06] <aatch> WTF: http://buildbot.rust-lang.org/builders/snap3-linux/builds/479
[23:15:31] <aatch> 10hrs
[23:16:53] <cmr> aatch: "I guess it's a case of gets-worse-before-it-gets-better" I'm not sure that's true unless you plan on rewriting the AST
[23:17:14] <cmr> shared pointers may be ugly but they're real good at keeping memory usage down in spaghetti code
[23:17:15] <aatch> cmr, huh?
[23:17:27] <cmr> Oh dbaupp wrote that
[23:17:41] <cmr> aatch: look what you did: http://huonw.github.io/isrustfastyet/mem/#0f25155,d91ac39
[23:18:06] <strcat> cmr: I don't think it has anything to do with @
[23:18:10] <strcat> it's because he removed boxes
[23:18:21] <strcat> so there's much stuff directly in the recursive type
[23:18:28] <strcat> it just needs some ~ on the big ones
[23:18:31] *** Joins: mindginative (mindginati@moz-9C555AF3.spmconsultants.co.nz)
[23:18:32] *** Quits: paulfryzel (paulfryzel@moz-C751AD73.nyc.res.rr.com) (Client exited)
[23:18:41] <cmr> Even if he replaces them with ~T, it'd be a separate ~ box of the same size for everything?
[23:18:54] <aatch> cmr, agh, but the benchmark you did didn't show anything...
[23:19:03] <cmr> aatch: that was before you did ast::Ty
[23:19:07] <strcat> cmr: it's a recursive enum
[23:19:18] <strcat> if you put a big type unboxed in it, it's bigger
[23:19:39] <strcat> at least that seems to be what's causing it
[23:19:51] <strcat> I really don't think he removed any structural sharing
[23:20:18] *** Quits: pnathan (Adium@moz-E3C3FAF2.hfc.comcastbusiness.net) (Ping timeout)
[23:20:47] <aatch> There's pretty much no significant _actual_ change in the sharing/copy semantics
[23:21:12] <aatch> seriously, really only the the ast map keeps references to the AST
[23:21:15] <cmr> *shrug* throw in some ~ and see what changes
[23:21:29] <aatch> cmr, I'm gonna do that and push it to the same branch
[23:21:39] <aatch> mind doing a bench when I'm done?
[23:21:42] <strcat> aatch: one of those types is huge
[23:21:44] <strcat> just figure out which
[23:21:46] <strcat> Ty?
[23:21:49] <aatch> strcat, probably
[23:22:00] <aatch> it /was/ infinitely sized
[23:22:08] <strcat> aatch: I'm so close to ~ headers being gone
[23:22:11] <cmr> Ty was 80 bytes before, for reference
[23:22:11] <strcat> 5 failing run-pass traits
[23:22:14] <aatch> strcat, I saw
[23:22:41] <cmr> I haven't had a recent master since I started on rustdoc_ng, won't until the new visitor lands
[23:23:18] <dbaupp> aatch: it's almost certainly the Option<Option<TyParamBound>>
[23:24:11] <aatch> dbaupp, nah, that's only vector sized
[23:24:14] <dbaupp> aatch: since that includes several layers of enums and their discriminants, and then a Path, which is pretty big
[23:24:28] <dbaupp> are you sure?
[23:24:47] <aatch> dbaupp, vec + discrim
[23:24:58] <dbaupp> aatch: that's not a vecotr?
[23:25:40] <aatch> dbaupp, hang on, do you mean Option<OptVec<T>>?
[23:25:56] *** Quits: yichoi (yichoi@5AB4884B.FCC4549.14D5B978.IP) (Ping timeout)
[23:26:00] <dbaupp> aatch: ah, right
[23:26:08] * dbaupp misread
[23:26:18] <aatch> the Path though.
[23:26:22] <aatch> might do it.
[23:30:23] *** Quits: mindginative (mindginati@moz-9C555AF3.spmconsultants.co.nz) (Quit: brb)
[23:31:04] <aatch> cmr, I'm glad we have these benchmarks, regressions like these are incredibly frustrating.
[23:31:17] <aatch> So at least we can catch them early
[23:32:13] <strcat> cmr: could benchmark https://github.com/mozilla/rust/pull/7605 even though it fails 5 tests still ;p
[23:32:21] <strcat> I don't think it'll help much with rustc though
[23:32:25] <strcat> too much @
[23:32:54] <dbaupp> cmr: what's the hash in last_auto.txt?
[23:32:58] <cmr> tests shmests!
[23:33:22] <cmr> dbaupp: 45f588e8fd938c65df056ab72861e144cf35e674%
[23:33:34] <aatch> strcat, hey at least it gets as far tests
[23:33:39] <cmr> dbaupp: I'll drop a symlink to last_auto.txt in hnn.mrsd.org/~cmr
[23:33:51] <dbaupp> cmr: good idea
[23:33:57] <strcat> aatch: well nothing uses ~Trait
[23:33:59] <strcat> I broke it well
[23:34:01] <strcat> ;p
[23:34:04] <strcat> and some other issue
[23:34:06] <strcat> it's so close!
[23:34:11] <aatch> strcat, weren't you expecting that?
[23:34:15] <strcat> yeah
[23:34:19] <dbaupp> cmr: (the time machine's at June 21, btw)
[23:34:27] <cmr> dbaupp: http://hnn.mrsd.org/~cmr/last_auto.txt
[23:34:38] <cmr> yeah bors has been actually doing his job :(
[23:35:04] <dbaupp> haha, turn that frown upside down ;P
[23:36:01] <engla> bors is on a nice streak of actually merging stuff
[23:36:02] <cmr> strcat: meh, not tonight, sorry
[23:37:18] <doomlord> comparisons between a:&T,b:&T ....a==b ... is that comparing the value or the pointer
[23:37:29] <aatch> doomlord, value
[23:37:36] <doomlord> phew
[23:37:50] <dbaupp> rusti: &2 == &3
[23:37:53] -rusti- false
[23:38:00] <dbaupp> rusti: &2 == &2
[23:38:02] -rusti- true
[23:38:09] <strcat> rusti: &(5 as int)
[23:38:10] -rusti- more than 5 lines of output, pastebinned: http://sprunge.us/GKIe
[23:38:18] <strcat> rusti: *&(5 as int)
[23:38:19] -rusti- 5
[23:38:27] <strcat> rusti: *&(5 as bool) == true
[23:38:28] -rusti- false
[23:38:30] <strcat> rusti: *&(5 as bool) == false
[23:38:31] -rusti- false
[23:38:36] <strcat> rusti: *&(5 as char)
[23:38:37] -rusti- '\x05'
[23:39:03] <strcat> rusti: *&(-1 as char)
[23:39:04] -rusti- '\xff'
[23:39:12] * strcat sighs
[23:39:57] <glinscott> more 'static fun, i'm getting this error "error: cannot pack type `@std::str::StrCharIterator<>`, which does not fulfill `'static`, as a trait bounded by 'static", for this code: "@s.iter() as @iterator::Iterator<char>", where s : @str
[23:40:32] <strcat> you really just don't want to use trait objects ;p
[23:40:40] <strcat> especially for an iterator, that'd be really slow
[23:41:25] * strcat is likely about to break ~Trait more anyway
[23:41:38] <engla> but what you want to do is to be able to put closures into trait objects
[23:41:44] <engla> it should be possible in the future
[23:42:15] <engla> including closures in those iterators
[23:42:23] <Luqman> strcat: do unique trait object also use exchange heap?
[23:42:36] <glinscott> strcat: ok - i was thinking trait's are like interfaces, and i wanted to store an interface pointer
[23:42:45] <strcat> Luqman: a unique trait object is just a unique ptr + another ptr to the vtable stuff
[23:42:47] <strcat> Luqman: so yes
[23:42:57] <strcat> glinscott: you want to use generics
[23:43:06] <strcat> it's really, really unlikely you want dynamic dispatch with a trait object
[23:43:38] <strcat> especially with an iterator because that means virtual dispatch for every step
[23:44:40] <glinscott> ok, so instead of my iterator::Iterator<char> type in my struct, i make my struct<T> and use T?
[23:45:23] <strcat> yes
[23:45:38] <strcat> and on the impl bound T with <T: Iterator<char>>
[23:45:43] <glinscott> gotcha!
[23:45:46] <glinscott> thanks once again :)
[23:45:50] <glinscott> i'm slowing getting there
[23:46:16] <strcat> I think it's a pretty big language flaw that the slow, edge case solution is easier to reach for than the superior one
[23:46:34] <strcat> everyone seems to reach for trait objects when they're meant for rare cases
[23:46:41] * strcat shrugs
[23:46:42] *** Joins: etw (john@moz-B2936CAB.nyc.res.rr.com)
[23:46:43] <cmr> yeah
[23:46:45] <glinscott> on the plus side, even with the slow trait version, the perf of json parsing continues to get better.  down 0.07s now (from 0.11s after the original pull request)
[23:47:03] <doomlord> With an enum (tagged union), is it possible to compare the tag only,without the data. ive tried   "if (myenum)==SomeEnumSubtype(_) {..}' but that doesn't work. I have the code working with pattern matching, BUT what this is doing makes that look ineficient
[23:47:05] <cmr> that's down from ~2.5 seconds originally, right?
[23:47:37] <strcat> doomlord: look at the optimized IR
[23:47:39] <doomlord> i need to modify the value being tested... with a pattern match, the borrow system requires i make a copy
[23:47:48] <engla> doomlord: yes. Some(*)
[23:47:55] <jensnockert> Haha, FML.
[23:47:58] <strcat> doomlord: it doesn't require that you make a copy
[23:48:02] <strcat> jensnockert: ?
[23:48:06] <glinscott> cmr: yup
[23:48:11] <dbaupp> glinscott: o_O
[23:48:17] <jensnockert> Bonus points if anyone guesses what was wrong with my SHA256 implementation?
[23:48:22] <dbaupp> glinscott: you're amazing!
[23:48:29] <dbaupp> jensnockert: off-by-1
[23:48:29] <aatch> cmr, can you tell me the size of Ty, Path, mt and expr?
[23:48:46] <jensnockert> dbaupp: No, worse.
[23:48:47] <aatch> I borked my previous install
[23:48:47] <dbaupp> jensnockert: macros expand to the first expression?
[23:48:56] <jensnockert> dbaupp: No, worse.
[23:49:02] <jensnockert> (as in, more silly)
[23:49:07] <dbaupp> jensnockert: typo i for j
[23:49:12] <aatch> jensnockert, +1 instead of -1
[23:49:13] <cmr> aatch: 
[23:49:14] <jensnockert> dbaupp: More sillyâ€¦
[23:49:15] <cmr> 80
[23:49:17] <cmr> 16
[23:49:19] <cmr> 128
[23:49:21] <cmr> 56
[23:49:23] <cmr> respectively
[23:49:26] <dbaupp> jensnockert: not calling a function?
[23:49:26] <cmr> wait
[23:49:31] <cmr> that's ty, mt, expr, path
[23:49:32] <jensnockert> I forgot 0x in front of the hex number in the test case.
[23:49:33] <cmr> sorry :p
[23:49:41] <jensnockert> And the number just happened to not have A-F in it.
[23:49:44] <dbaupp> jensnockert: ah
[23:49:47] <aatch> cmr, in libsyntax/ast.rs
[23:49:54] * dbaupp hugs jensnockert
[23:50:00] <cmr> aatch: yes, that is all from syntax::ast
[23:50:17] <cmr> as of 19d97dd
[23:50:20] <glinscott> dbaupp: it's getting there!  still some good low hanging fruit though.  not competitive with the good c++ json parsers yet either
[23:50:37] <aatch> cmr, ok, well I got 176, 104, 16 and *296* respectively
[23:50:46] <cmr> aatch: with your patch?
[23:50:59] <aatch> cmr, I haven't made any changes yet
[23:51:07] <cmr> so on master?
[23:51:24] <dbaupp> glinscott: don't care 
[23:51:27] <aatch> but I'm pretty sure that the size of expr there is from a single variant
[23:51:30] <aatch> expr_cast
[23:51:34] <dbaupp> glinscott: any improvement is amazing
[23:51:47] <doomlord> http://pastebin.com/e3NPnbaE <<< here's what i'm trying to do.. this code will work, but to me it seems it risks an unnecasery copy. C++ code would test what type the tile is and modify imperatively.
[23:52:01] <strcat> glinscott: https://github.com/thestinger/rust/commit/51eb1e14d4285f157e9820f5ee61bc150cf554ad there's this problem too
[23:52:04] <strcat> it makes invalid strings
[23:52:15] <doomlord> ^^^ i realise i could still implement it manually in rust :) ... just trying to get the hang of using the features properly..
[23:52:17] <strcat> I couldn't figure out why because I'm not familiar with that code
[23:52:19] <strcat> :(
[23:52:25] <glinscott> strcat: i haven't taken a look at the encoding part to be honest
[23:52:25] <aatch> Other things have Ty objects, but inside vectors
[23:53:06] *** Joins: ghrust (ghrust@24260B07.6A2AE50.F3114085.IP)
[23:53:06] <ghrust> 01[13rust01] 15bors merged 06auto into 06master: 02http://git.io/3qhO-Q
[23:53:06] *** Parts: ghrust (ghrust@24260B07.6A2AE50.F3114085.IP) ()
[23:53:29] <dbaupp> doomlord: set should take value by-value
[23:53:41] <dbaupp> doomlord: let the caller call clone if they need to
[23:54:31] <dbaupp> doomlord: but what's the problem with the commented out code at the bottom?
[23:54:48] <doomlord> oops the uncomented code is incomplete too.
[23:54:51] <cmr> ttp://rustlog.octayn.net/post/54868266945/status-update, 'night all
[23:54:57] <cmr> http://rustlog.octayn.net/post/54868266945/status-update, sorry
[23:55:00] <doomlord> i can't compare on the enum tag alone
[23:55:59] *** Joins: ghrust (ghrust@CFE85B59.6A2AE50.F3114085.IP)
[23:55:59] <ghrust> 01[13rust01] 15bors pushed 0 new commits to 06auto: 02http://git.io/LgVTTQ
[23:55:59] *** Parts: ghrust (ghrust@CFE85B59.6A2AE50.F3114085.IP) ()
[23:56:01] *** Joins: ghrust (ghrust@C621748.6A2AE50.F3114085.IP)
[23:56:01] <ghrust> 01[13rust01] 15bors pushed 2 new commits to 06auto: 02http://git.io/FSsdtQ
[23:56:01] <ghrust> 13rust/06auto 14d7474b6 15Alex Crichton: Add rusti/rustpkg to check-lite
[23:56:01] <ghrust> 13rust/06auto 14829d745 15bors: auto merge of #7568 : alexcrichton/rust/check-lite, r=pcwalton...
[23:56:02] *** Parts: ghrust (ghrust@C621748.6A2AE50.F3114085.IP) ()
[23:56:15] <dbaupp> doomlord: what about `match self.tiles.get(tile_ij) { &DataTile(_) => if-case, _ => else-case }`?
[23:56:35] <dbaupp> that's exactly equivalent to the if-else construction
[23:56:45] <doomlord> match is what risks a copy - it borrows the tile contents, and the match arms are going to modify tile contents
[23:56:46] <dbaupp> (except for possibly borrow checking.)
[23:57:15] <doomlord> i ran into that, it didn't let me mutate the thing matched against :)
[23:57:16] <dbaupp> right, then `let is_data_tile = match self.tiles.get(..) { .. => true, _ => false }; if is_data_tile { } else { }
[23:57:36] <doomlord> ah.. set a flag in the match...
[23:57:40] <doomlord> then act on it after..
[23:57:44] <doomlord> silly me
[23:58:13] <jensnockert> Oh, wellâ€¦ now since it is on Github, it is bug-free.
[23:58:16] <jensnockert> Well-known fact.

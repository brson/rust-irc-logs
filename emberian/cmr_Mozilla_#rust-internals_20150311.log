[00:00:03] *** Quits: bjz (bjz@moz-4l6.mjm.52.113.IP) (Quit: My Mac has gone to sleep. ZZZzzz…)
[00:01:35] <bstrie> arrrrrrr1: I think streaming on bandcamp for any given artist has always consumed tokens, which are an invisible currency that artists get after they sell songs for money and also periodically for free
[00:01:51] <arrrrrrr1> oh, I didn't know
[00:02:19] <arrrrrrr1> well, I usually buy the song after I've listened to it enough times but bandcamp stops it after listening to it two times
[00:02:33] <arrrrrrr1> then I've got to delete cookies
[00:02:36] <bstrie> yeah that sounds new :P
[00:02:56] <arrrrrrr1> gotta write an extension that automatically deletes cookies
[00:03:52] *** Quits: bluss (bluss@moz-ec5o68.cust.bredbandsbolaget.se) (Ping timeout: 121 seconds)
[00:04:40] <arrrrrrr1> hmm, move slices have to be fat points of some kind
[00:05:00] <arrrrrrr1> because they have to clean up the memory they are slicing into
[00:05:21] <arrrrrrr1> e.g. Vec::as_move_slice() has to deallocate the vector at the end of its lifetime
[00:05:37] <reem> arrrrrrr1: This is why I pinged eddyb, &move is actually not a sufficient type
[00:05:56] <arrrrrrr1> for sized types it is. but not for slices
[00:05:58] <reem> you need a special type which has both a data type parameter and a cleanup-er
[00:06:11] <reem> Nah, you need it for sized data too
[00:06:17] <reem> since it can come from things which need to be cleaned up
[00:06:26] <reem> i.e. &move T out of a Box<T.
[00:06:27] <arrrrrrr1> how, &move T is just like `T` for cleanup
[00:06:32] <arrrrrrr1> ah, yeah
[00:06:35] <reem> arrrrrrr1: It can point to memory that needs cleanup
[00:06:38] <reem> ya
[00:06:50] <arrrrrrr1> I was thinking about taking stack references
[00:06:57] <reem> So you end up with Move<T, Stack<'a>> for stack references
[00:07:03] <reem> and Move<T, Heap> for Box references
[00:07:04] <reem> for instance
[00:07:35] <arrrrrrr1> I'm a bit worried that &move [T] needs 3 or even 4 pointer sized fields
[00:07:53] <reem> &move can't ever exist
[00:08:03] <reem> it's not enough
[00:08:19] <reem> Move<[T], Stack<'a>> can be two words
[00:08:54] <reem> struct Move<T: ?Sized, D: MoveCleanup<T>>(Unique<T>) should do it, I think.
[00:09:25] *** Quits: tjakubo_ (tom@moz-dia6e2.warp2biz.com) (Ping timeout: 121 seconds)
[00:09:42] *** Joins: tjakubo_ (tom@moz-dia6e2.warp2biz.com)
[00:09:54] <reem> MoveCleanup has one unsafe method that receives *mut T or something
[00:10:09] <reem> I guess you have to actually embed an instance of D
[00:10:27] *** Quits: ytain (ytain@moz-lio.ur1.175.184.IP) (Quit: Textual IRC Client: www.textualapp.com)
[00:10:36] <reem> so struct Move<T: ?Sized, D: MoveCleanup<T>>(Unique<T>, D) where D is usually zero-sized (but isn't for types that need more metadata) should work
[00:11:25] <Luqman> arrrrrrr1: passing around a func to do the cleanup wouldn't be too hard, we basically already do that for Box<Trait> with it's drop glue
[00:12:02] <arrrrrrr1> Luqman: sure, &move T is two words. &move [T] is more complicated depending on if you want to be able to take a sub-move-slice
[00:12:34] <arrrrrrr1> e.g. &move vec[1..]
[00:13:00] <arrrrrrr1> then you also have to store a pointer to the vec itself
[00:18:11] *** Joins: Astrum|Lap (Astrum|Lap@moz-skcefh.co.comcast.net)
[00:19:38] *** Joins: bjz (bjz@moz-b43.1aa.161.202.IP)
[00:20:51] *** Quits: eibwen (eibwen@moz-l622e8.dip0.t-ipconnect.de) (Ping timeout: 121 seconds)
[00:21:06] <reem> I'm convinced you need another type parameter for cleanup metadata
[00:21:24] <reem> or else we're limiting the use case of this reference type singificantly
[00:22:10] <arrrrrrr1> you need struct MoveSlice { cleanup_pointer: *mut (), cleanup_vtable: *mut (), slice_start: *mut (), slice_len: usize }
[00:22:27] <arrrrrrr1> that should be enough
[00:23:37] *** Joins: blaenk_ (blaenkdenum@moz-em283u.res.rr.com)
[00:24:49] *** Quits: brson (brson@moz-obm.e0n.56.172.IP) (Quit: leaving)
[00:26:19] <arrrrrrr1> yes, that's definitely enough
[00:26:34] *** Quits: bjz (bjz@moz-b43.1aa.161.202.IP) (Quit: My Mac has gone to sleep. ZZZzzz…)
[00:26:56] *** Quits: blaenk (blaenkdenum@moz-em283u.res.rr.com) (Ping timeout: 121 seconds)
[00:27:17] *** Quits: mystor_ (mystor@moz-rrn.r78.15.130.IP) (Connection closed)
[00:29:20] *** Joins: dinfuehr (dinfuehr@moz-6jjoqr.highway.telekom.at)
[00:30:13] <japaric> aturon: ping
[00:30:16] <japaric> acrichto: ping
[00:30:23] <acrichto> japaric: pong
[00:30:37] <japaric> acrichto: hey, I got a question about libcore libcoretest
[00:30:41] <acrichto> shoot
[00:30:47] <japaric> acrichto: is the reason of the split because of the lang items?
[00:30:54] <japaric> acrichto: they conflict when build with --test?
[00:31:06] <acrichto> yeah
[00:31:12] <acrichto> also dealing with realstd
[00:31:16] <acrichto> aka libtest links to one version of std
[00:31:21] <acrichto> which is not what libcore links to
[00:31:32] <acrichto> and it's really easy to get them mixed up
[00:31:48] <acrichto> or rather I should say libtest links to libcore, but coretest also links to a different libcore
[00:32:07] *** Quits: pcwalton (pcwalton@moz-l8ebtf.sfo1.mozilla.com) (Client exited)
[00:32:15] <japaric> acrichto: hmm, so I'm seeing the conflicting lang items error in unicode and collections on my inherent impl branch because I added lang items
[00:32:40] <japaric> acrichto: I would have to split the tests out of the crate in that case?
[00:32:40] <acrichto> aha, yes that would be about right
[00:32:56] <acrichto> I feel like we should just have libstdtest
[00:33:02] <acrichto> with the entire facade tested within it
[00:33:05] <acrichto> to deal with this problem
[00:33:20] <acrichto> japaric: but if #[cfg(not(test))] does the trick then that should also be fine
[00:33:23] *** Quits: dinfuehr (dinfuehr@moz-6jjoqr.highway.telekom.at) (Ping timeout: 121 seconds)
[00:33:28] <acrichto> albeit unfortunate
[00:33:57] <reem> does mem::forget actually move out of what is passed to it?
[00:34:09] <reem> if it does, I think it shouldn't
[00:34:15] <japaric> acrichto: I'll try the not(test) but I don't think it'd work because then the inherent methods won't be accessible (I think)
[00:34:29] <japaric> acrichto: moving all the tests to a stdtest sounds good though
[00:34:52] <arrrrrrr1> reem: forget is an intrinsic without a wrapper
[00:35:49] *** Quits: summerlight_ (summerlight@moz-99k.2mj.130.121.IP) (Ping timeout: 121 seconds)
[00:35:54] <arrrrrrr1> so mem::forget(x) should just set the "drop this" flag on the stack to 0 (assuming non-zeroing drop)
[00:36:29] <reem> Does it zero today though, since we do have zeroing
[00:37:55] <reem> e.g. If I do let x = &mut y as *mut _; then mem::forget(y); am I going to have a bad time trying to read from x?
[00:38:09] <arrrrrrr1> reem: forget is internally the same as uninit for some reason
[00:38:19] <arrrrrrr1> https://gist.github.com/anonymous/41e38acd945019e2c1fb
[00:38:50] <arrrrrrr1> I guess another part of the compiler that deals with moves does the zeroing then just as if forget were a normal function
[00:39:39] <bstrie> steveklabnik: on that HN comment, I think `for x in &mut numbers[..] {` can just be `for x in &mut numbers {`
[00:40:05] <reem> arrrrrrr1: because they're both noops, according to that comment.
[00:40:40] <arrrrrrr1> x is moved into the forget function but the forget function is a noop so x will not be dropped in the forget function
[00:40:44] <arrrrrrr1> it makes sense
[00:40:54] <bstrie> steveklabnik: also don't think you need {:?} when plain {} will do
[00:41:33] *** Quits: ^BR (br@moz-egk.dm6.194.78.IP) (Client exited)
[00:42:49] <steveklabnik> bstrie: roger, yeah
[00:42:59] *** Joins: ^BR (br@moz-egk.dm6.194.78.IP)
[00:44:28] *** Quits: adu (ajr@moz-0foa9t.md.comcast.net) (Client exited)
[00:50:34] *** Quits: reem (reem@moz-2icmmi.ca.comcast.net) (Connection closed)
[00:57:35] <japaric> acrichto: I got further with not(test), but now I'm getting a bunch of "error: expected `vec::Vec<_>` found `collections::vec::Vec<_>`" - seen this before?
[00:57:36] *** Joins: theme (theme@moz-i3mhhb.asianet.co.th)
[00:59:12] *** blaenk_ is now known as blaenk
[01:00:02] <acrichto> japaric: yeah :(
[01:00:08] <acrichto> this is the point sfackler gave up and created cortest
[01:00:13] <acrichto> coretest*
[01:00:22] <acrichto> you *can* work around it all in theory with some clever imports here and there
[01:00:28] <acrichto> but it does get out of hand quickly
[01:01:02] <japaric> hmmm
[01:01:09] <sfackler> i kind of like having separate libs anyway - you don't have to worry about NO_REBUILD if you're tweaking tests
[01:01:15] <sfackler> gogo libcollectionstest
[01:01:45] <japaric> is okay to add libcollectionstest and libunicodetests with my inherent impls PR?
[01:01:50] *** Quits: James (quassel@moz-5qldmp.range109-148.btcentralplus.com) (Ping timeout: 121 seconds)
[01:01:56] <japaric> or should we consider libstdtest in another PR?
[01:02:02] <acrichto> japaric: nah that's fine
[01:02:05] <acrichto> the more crates the merrier!
[01:02:24] <japaric> heh, ok
[01:02:40] *** Joins: reem (reem@moz-2icmmi.ca.comcast.net)
[01:02:59] <acrichto> sfackler: what was it you did to allow #[derive] to expand to unstable method calls?
[01:03:08] <acrichto> I'm trying to do the same for Eq, but I can't get it to work out
[01:04:14] <sfackler> i am actually trying to fix it
[01:04:19] <sfackler> i rebased and it stopped working?
[01:04:28] <sfackler> i'm honestly a bit confused
[01:04:39] <sfackler> i will poke more when i get home
[01:04:58] <acrichto> ah ok
[01:05:03] <acrichto> I'll wait for you to figure it out then :P
[01:05:14] <sfackler> this check right here is wrong: https://github.com/rust-lang/rust/blob/master/src/libsyntax/codemap.rs#L851
[01:05:16] *** Quits: reem (reem@moz-2icmmi.ca.comcast.net) (Connection closed)
[01:05:20] <sfackler> but I'm not sure if that's the only fix i needed
[01:05:23] *** Joins: reem (reem@moz-2icmmi.ca.comcast.net)
[01:06:43] *** Joins: SiegeLord (sl@moz-9jtaei.ca.comcast.net)
[01:08:55] <arrrrrrr1> I didn't know that you could `impl Trait` to construct extension methods
[01:09:19] *** Quits: gleb (gleb@moz-3u1drv.rusanovka-net.kiev.ua) (Ping timeout: 121 seconds)
[01:09:23] <sfackler> i think that ability is pretty new
[01:09:44] <arrrrrrr1> I take it this is so that implementations can't overwrite them?
[01:10:20] <arrrrrrr1> They are kind of spooky because rustdoc doesn't show them
[01:11:12] <sfackler> yeah rustdoc is very behind right now
[01:11:23] <sfackler> also doesn't show things like IntoIterator impls for &Foo
[01:11:50] <reem> arrrrrrr1: It also eliminates some otherwise necessary extension traits like AnyRefExt
[01:12:05] <reem> (which is replaced by impl Any { .. })
[01:13:37] *** Quits: simias (simias@moz-hesd72.svkt.org) (Connection closed)
[01:13:39] *** Joins: simias (simias@moz-hesd72.svkt.org)
[01:17:33] <bstrie> woooo I just realized that you can do `let [x, y, z] = foo;` for fixed-sized arrays :)
[01:18:48] <arrrrrrr1> &move might give us a bit of a vtable explosion
[01:18:51] <arrrrrrr1> hmm
[01:18:56] <arrrrrrr1> we'll see
[01:23:57] *** Quits: Tobba (Tobba@moz-o13d22.bredband.telia.com) (Ping timeout: 121 seconds)
[01:24:32] <arrrrrrr1> oooh, looks like &move requires non-zeroing drops
[01:24:40] <arrrrrrr1> that's pretty cool
[01:29:57] *** Quits: Nekit1234007 (nekit@moz-vfr.64q.51.84.IP) (A TLS packet with unexpected length was received.)
[01:30:49] <XMPPwocky> bstrie: and in matches
[01:31:00] <XMPPwocky> bstrie: AND you can match *slices* too
[01:31:05] <XMPPwocky> great for little argument-parsing things
[01:31:27] *** Quits: erickt (erickt@moz-4hh.6p3.217.74.IP) (Ping timeout: 121 seconds)
[01:31:48] <XMPPwocky> .split(" ").collect(); match { &["hello", "i'm", name] => { user.name = name; } }
[01:32:09] <bstrie> arrrrrrr1: implement non-zeroing drop before 1.0 pls :)
[01:32:48] *** Joins: dinfuehr (dinfuehr@moz-hkmhqm.highway.telekom.at)
[01:33:24] <bstrie> XMPPwocky: sadly os::args no longer returns a slice, but an iterator :P basically a wash
[01:34:04] <arrrrrrr1> bstrie: eddyb_ bugged me some time ago to implement a little thing in the compiler. I fought with the built system for two hours before a realized that it hasn't improved since I tried it last a year ago. Having the built system set up properly is kind of critical when you do non-incremental compilation on a tiny laptop.
[01:34:34] <arrrrrrr1> the feature itself looked trivial to implement, but the work around it is too much
[01:34:44] <arrrrrrr1> (maybe not trivial but not too hard)
[01:36:55] *** Quits: dinfuehr (dinfuehr@moz-hkmhqm.highway.telekom.at) (Ping timeout: 121 seconds)
[01:37:28] *** Joins: adu (ajr@moz-0foa9t.md.comcast.net)
[01:37:56] <reem> Is it safe to ptr::read_and_zero things in a Drop impl?
[01:38:06] <arrrrrrr1> there is such a function?
[01:38:08] <arrrrrrr1> I've never seen it
[01:38:15] <reem> std::ptr::read_and_zero
[01:38:33] <arrrrrrr1> huh, that's crazy
[01:38:42] <arrrrrrr1> literally zeroing-drops: the function
[01:39:19] *** Quits: jdm (jdm@moz-ak9a3r.ckpj.s0pt.0450.2001.IP) (Quit: )
[01:39:59] <arrrrrrr1> when they make "zeroing" drops put ones everywhere instead of zeroed so that people cannot depend on zeroing in 1.0, then it will have to be renamed to read_and_ones
[01:40:31] *** Quits: adu (ajr@moz-0foa9t.md.comcast.net) (Client exited)
[01:40:55] <reem> typeof! as a type-macro would be quite useful for writing macros
[01:41:18] <arrrrrrr1> I think a typeof keyword is part of the sizeof keyword rfc
[01:41:33] *** Joins: minzh (minzh@moz-97h.bjh.14.103.IP)
[01:42:16] <XMPPwocky> arrrrrrr1: wait, is that planned/
[01:42:20] <XMPPwocky> i proposed that jokingly
[01:42:28] <arrrrrrr1> the thing with the 1?
[01:42:31] <arrrrrrr1> 11111
[01:42:46] <arrrrrrr1> I think it was mentioned in last week's meeting notes
[01:43:05] <arrrrrrr1> https://github.com/rust-lang/meeting-minutes/blob/master/weekly-meetings/2015-03-03.md#zerohhhhfilling-drop
[01:43:52] *** Quits: swgillespie (swgillespie@moz-upj.3un.220.167.IP) (Quit: My MacBook Pro has gone to sleep. ZZZzzz…)
[01:44:29] <theme> what?
[01:44:46] <theme> what does ^H mean, any way?
[01:45:16] <theme> ok... so people can start depending on one-ing drops :P
[01:45:30] <doener> theme: Control+H, works like backspace
[01:45:43] *** Quits: minzh (minzh@moz-97h.bjh.14.103.IP) (Connection closed)
[01:45:43] <arrrrrrr1> and ^W deletes a word
[01:45:45] <arrrrrrr1> the more you know
[01:46:03] <arrrrrrr1> but don't forget that ^W closes the tab in your browser even when you are editing text on github
[01:46:44] <arrrrrrr1> you can use ^Backspace in a browser
[01:47:07] <reem> Your browser doesn't warn you when you try to close a window while editing text?
[01:47:16] <doener> luckily vimperator fixes that in firefox
[01:47:17] <arrrrrrr1> nope
[01:47:17] <reem> Mine does, but it's spotty.
[01:47:23] <arrrrrrr1> reem: which one is that?
[01:47:39] <reem> arrrrrrr1: Chrome and Safari on OS X
[01:47:47] <bstrie> firefox saves my text if I ctrl+shift+T a closed tab
[01:47:51] <arrrrrrr1> not on linux
[01:47:53] *** Joins: minzh (minzh@moz-97h.bjh.14.103.IP)
[01:47:54] <arrrrrrr1> in chromium
[01:48:06] <arrrrrrr1> bstrie: same in chromium
[01:48:35] <pnkfelix> theme: it probably won't be actually one'ing drops in practice
[01:48:53] <pnkfelix> theme: as noted in the dicussion, it makes more sense to use a nontrivial bit pattern
[01:49:03] <arrrrrrr1> in any case read_and_zero becomes quite useless when that's no longer specified
[01:49:11] <arrrrrrr1> well, there might be some usecases
[01:49:20] <arrrrrrr1> but probably not enough to justify a function
[01:55:03] *** Quits: pnkfelix (pnkfelix@moz-eljppb.fbx.proxad.net) (Quit: rcirc on GNU Emacs 24.3.92.1)
[02:03:17] *** Joins: p1start (p1start@moz-nftjhe.org)
[02:04:08] *** Joins: japaric_ (japaric@moz-hvi.8pc.42.190.IP)
[02:06:57] *** Quits: japaric (japaric@moz-h53.6gb.236.190.IP) (Ping timeout: 121 seconds)
[02:09:04] <arrrrrrr1> unsized objects cannot be cast to traits, right?
[02:09:22] <arrrrrrr1> &unsized as &Trait
[02:09:40] <Mutabah> arrrrrrr1: I don't think so
[02:09:44] <arrrrrrr1> that's good
[02:09:54] <Mutabah> arrrrrrr1: I think there's issues getting the correct vtable for the unknown object
[02:10:05] <arrrrrrr1> I was panicking for 5 minutes because my design doesn't support casting &move [T] to &move Trait
[02:10:14] <Mutabah> actually - Slices you can (assuming there's an impl of Trait for &[T])
[02:10:30] <arrrrrrr1> no, I mean Trait for [T]
[02:10:40] <arrrrrrr1> with an additional reference it works
[02:12:49] *** Joins: swgillespie (swgillespie@moz-rn1.vmq.232.104.IP)
[02:15:15] *** Joins: acharles (acharles@moz-ulbdcn.ca.comcast.net)
[02:17:21] *** Joins: pcwalton (pcwalton@moz-6kjabm.ca.comcast.net)
[02:17:21] *** ChanServ sets mode: +o pcwalton
[02:17:30] *** Quits: pcwalton (pcwalton@moz-6kjabm.ca.comcast.net) (Client exited)
[02:20:32] <arrrrrrr1> anyone want to read an RFC?
[02:22:11] *** Quits: japaric_ (japaric@moz-hvi.8pc.42.190.IP) (Ping timeout: 121 seconds)
[02:22:49] <awe> acrichto: So, I apparently missed more places where Path is used. Should I change something like PluginManager in librustdoc?
[02:23:00] <awe> acrichto: where old_path is used with dynamic library, rather.
[02:23:33] *** Joins: japaric (japaric@moz-hvi.8pc.42.190.IP)
[02:26:31] <theme> arrrrrrr1, maybe
[02:29:42] *** Quits: reem (reem@moz-2icmmi.ca.comcast.net) (Connection closed)
[02:30:03] *** Joins: reem (reem@moz-2icmmi.ca.comcast.net)
[02:30:05] *** Quits: reem (reem@moz-2icmmi.ca.comcast.net) (Connection closed)
[02:30:06] *** Joins: reem (reem@moz-rpuemk.coob.q2h1.0009.2601.IP)
[02:31:42] <arrrrrrr1> https://github.com/rust-lang/rfcs/pull/965
[02:31:45] <arrrrrrr1> here it goes
[02:33:37] *** Joins: dinfuehr (dinfuehr@moz-hkmhqm.highway.telekom.at)
[02:34:27] *** Quits: reem (reem@moz-rpuemk.coob.q2h1.0009.2601.IP) (Connection closed)
[02:34:48] *** Joins: reem (reem@moz-rpuemk.coob.q2h1.0009.2601.IP)
[02:34:49] <huon> I suspect &move can be a library type
[02:35:10] <bstrie> we do already have the keyword reserved...
[02:35:33] <huon> not just reserved
[02:35:34] <bstrie> &move move||
[02:35:37] <arrrrrrr1> huon: I don't think it can actually.
[02:35:42] <arrrrrrr1> for example:
[02:36:07] <huon> assuming we have something like https://github.com/rust-lang/rfcs/pull/197
[02:36:09] <theme> huon, we need DerefMove for it to be a library type
[02:36:19] <theme> maybe
[02:36:23] <arrrrrrr1> we have an object x: T and want to take a MoveReference<'a, T>. but when we call .move_out_of(), then x is suddenly no longer borrowed
[02:36:43] <arrrrrrr1> because move_out_of consumes the MoveReference
[02:36:55] *** Joins: reem_ (reem@moz-2icmmi.ca.comcast.net)
[02:37:13] <huon> seems reasonable
[02:37:16] <huon> should be in the RFC ;)
[02:37:22] <theme> ok... so we want moving object-safety?
[02:37:24] <arrrrrrr1> I'll add it
[02:37:32] <huon> also, I don't see why "This can wait until post 1.0 because it needs non-zeroing drops anyway."
[02:37:36] <theme> moving trait objects
[02:37:40] *** Quits: dinfuehr (dinfuehr@moz-hkmhqm.highway.telekom.at) (Ping timeout: 121 seconds)
[02:37:40] <huon> why does it *need* non-zeroing drops?
[02:37:44] <bstrie> arrrrrrr1: note that `&move||` becomes ambiguous
[02:37:59] <theme> whoops
[02:38:11] <arrrrrrr1> huon: because the original object must not be dropped in the original function. but we also need the &move to point to valid memory
[02:38:21] <arrrrrrr1> huon: it would work if zeroing drops only zero the drop byte
[02:38:26] <arrrrrrr1> (maybe)
[02:38:28] <huon> arrrrrrr1: I don't understand
[02:38:41] <huon> wouldn't taking &move just not immediately run the destructor and hence not zero?
[02:38:48] *** Joins: adu (ajr@moz-0foa9t.md.comcast.net)
[02:38:56] <theme> &move is like Box?
[02:38:59] <arrrrrrr1> huon: what if you only take &move in a branch?
[02:39:00] *** Quits: reem (reem@moz-rpuemk.coob.q2h1.0009.2601.IP) (Ping timeout: 121 seconds)
[02:39:09] <theme> arrrrrrr1, dynamic drop?
[02:39:15] <arrrrrrr1> theme: yo, zeroing drop
[02:39:26] <arrrrrrr1> if we have stack bits that indicate if an object is dropped then it works
[02:39:33] *** Quits: reem_ (reem@moz-2icmmi.ca.comcast.net) (Connection closed)
[02:39:48] <huon> arrrrrrr1: how is it different to moving out in a branch?
[02:39:52] <theme> arrrrrrr1, still works with zeroing drops
[02:39:54] <huon> this should also be in the RFC...
[02:40:00] <arrrrrrr1> I'll add all this to the RFC
[02:40:04] <bstrie> I feel like this can't be the first RFC for &move, people have been asking for it for ages
[02:41:27] <nrc> Do we ever prevent `pub use` rexporting an item which is otherwise visible in the module with the `pub use`?
[02:41:35] <arrrrrrr1> huon: because if you move out in a branch then you know at the end of the function whether you have to drop based on it containing only zero bytes. but if you take a &move then it must no zero because the reference must stay valid
[02:41:58] <arrrrrrr1> so taking the &move must not zero
[02:42:00] <theme> arrrrrrr1, then zero out *x ?
[02:42:04] <arrrrrrr1> but maybe the &move destructor can zero
[02:42:06] <arrrrrrr1> yes
[02:42:15] <arrrrrrr1> I'll think about it
[02:42:24] <huon> surely the &move destructor does exactly what a normal destructor does?
[02:42:42] <arrrrrrr1> huon: you're absolutely correct. it should already work fine
[02:42:49] <huon> I think stack flags make this harder, in fact
[02:42:54] <huon> since you need a pointer to them?
[02:43:03] <theme> I think that &move for trait should be relatively easy to design
[02:43:09] <arrrrrrr1> you can just zero the flag right when you take the &move
[02:43:14] <theme> but I just don't understand about &move [T]
[02:43:19] <arrrrrrr1> the &move has its own flag
[02:43:28] <huon> makes sense
[02:43:36] <bstrie> huon: we could also consider just disallowing conditional moves when using &move
[02:43:43] <bstrie> as the maximally conservative choice
[02:43:46] <arrrrrrr1> pls no
[02:43:55] <arrrrrrr1> I think it works the way huon explained it
[02:44:18] <theme> arrrrrrr1, what are the arguments for container_destructor in MoveSlice?
[02:44:44] <arrrrrrr1> theme: if you slice a Vec<T>, then you have to deallocate the Vec when you drop the &move [T]
[02:44:46] <theme> I think you only need fn(*mut ())
[02:45:08] <theme> arrrrrrr1, In that case, you only need the *mut Vec<T>, right?
[02:45:13] <arrrrrrr1> theme: if you've moved out of your &move [T] slice, then the container_destructor must not try to drop those again
[02:45:28] <arrrrrrr1> theme: we might want to slice into other containers
[02:45:35] <theme> arrrrrrr1, hmm
[02:45:39] <arrrrrrr1> but the container pointer is in fact *mut Vec<T> in that case
[02:45:48] <theme> how does dropping single elements work any way
[02:46:24] <arrrrrrr1> because container_destructor will only drop the ones before and after the slice
[02:46:28] <theme> arrrrrrr1, if x is Vec<T>, what happens when I do `let y = x[1]`?
[02:46:37] <arrrrrrr1> that doesn't work
[02:46:41] <arrrrrrr1> all of this will use unsafe code
[02:46:53] <arrrrrrr1> similar to the drain(1..2) function for Vec<T>
[02:47:02] <theme> arrrrrrr1, ok
[02:48:30] <sfackler> acrichto: ok, got the unstable thing working again
[02:48:31] <arrrrrrr1> bstrie: oh, &move || is indeed a problem
[02:49:16] <theme> arrrrrrr1, can you reslice a &move?
[02:49:52] <arrrrrrr1> theme: yep
[02:50:03] <arrrrrrr1> reslicing doesn't drop anytihng
[02:50:06] <theme> if you have `x: &move [T]`, can you do `let y: &move [T] = &move x[1..2]`?
[02:50:06] <arrrrrrr1> *anything
[02:50:14] <arrrrrrr1> yo
[02:50:26] <theme> arrrrrrr1, also, how would the MoveIndex trait or something work?
[02:50:41] <arrrrrrr1> that will just bump the data pointer and decrease the length
[02:50:45] <arrrrrrr1> theme: what is that?
[02:50:49] <nathan7> bstrie: so, there's this idea I had
[02:50:57] <theme> arrrrrrr1, how do you get &move [T] from Vec<T>?
[02:51:10] <nathan7> bstrie: make an &move be fat, and have the second pointer be a pointer to a drop flag
[02:51:17] <arrrrrrr1> theme: &move vec[..] I guess
[02:51:23] <theme> arrrrrrr1, what is the trait?
[02:51:29] <theme> how to deal with Drop?
[02:51:51] <theme> that's what I mean by MoveIndex
[02:51:52] <arrrrrrr1> there would have to be an unsafe trait
[02:52:03] <theme> arrrrrrr1, add that to the RFC
[02:52:06] *** Quits: madmalik (uid13697@moz-lfin5p.brockwell.irccloud.com) (Quit: Connection closed for inactivity)
[02:52:15] <theme> I believe that you would get some problems designing that
[02:52:16] <arrrrrrr1> hmmmm
[02:52:40] <arrrrrrr1> I don't think so. you just need a single function -> as_move_slice()
[02:52:42] *** Joins: reem (reem@moz-dhk9um.coob.q2h1.0009.2601.IP)
[02:52:52] <bstrie> nathan7: I feel a little weird about & and &mut being thin and &move being fat
[02:53:00] <arrrrrrr1> the subslicing can be done by the compiler the same way it's done afterwards
[02:53:03] <bstrie> I guess &[] is fat tho
[02:53:14] <nathan7> bstrie: yeah
[02:53:46] <reem> The primitive we need to get &move with macros is mem::forget that does nothing, not even zero the data.
[02:53:49] *** Joins: tedh (tedh@moz-ctbj7i.il.comcast.net)
[02:53:53] <nathan7> bstrie: like, my issue with the current way conditional moves work is that the mechanism is not first-class
[02:53:55] <reem> I almost have it implemented as a library type
[02:54:24] <nathan7> bstrie: you can't pass a conditional move to a function
[02:54:31] <arrrrrrr1> what's the name of the normal slice trait?
[02:54:44] <arrrrrrr1> for stuff like &mut vec[1..]
[02:54:49] <reem> nathan7: +1, this is exactly the issue I have with moves into closures
[02:54:49] <theme> arrrrrrr1, Index
[02:55:08] <theme> Index<RangeFrom>, to be precise
[02:55:43] <arrrrrrr1> oh, then MoveIndex should be just that, except that it takes self and not &self
[02:55:45] <nathan7> could even have an unsafe &'a *move T -> Option<&'a move T>
[02:55:57] <arrrrrrr1> ugh, no
[02:56:06] *** Quits: tjakubo_ (tom@moz-dia6e2.warp2biz.com) (Quit: WeeChat 1.1)
[02:56:10] <reem> *move T is desirable
[02:56:20] <reem> I guess it has no actual semantics though
[02:56:39] <nathan7> well, I have a few ptr::reads I want to get rid of
[02:56:50] <reem> It could replace Unique<T>, I guess.
[02:57:02] <theme> arrrrrrr1, index_move(&move self) -> &move Target?
[02:57:11] <arrrrrrr1> yo
[02:57:41] <theme> arrrrrrr1, btw I'd name it IndexMove to be consistent with IndexMut
[02:57:52] <reem> And DerefMove if you are defining that too
[02:57:57] <reem> (as opposed to MoveDeref)
[02:57:59] <theme> reem, yes
[02:58:34] <theme> this probably will affect quite some stdlib API
[02:58:45] <theme> not sure if it will be backcompat in those cases
[02:59:27] <bstrie> every potential feature affects the ideal stdlib api
[02:59:57] <theme> arrrrrrr1, added 2 comments on the RFC
[03:00:19] *** Joins: summerlight_ (summerlight@moz-99k.2mj.130.121.IP)
[03:00:47] <theme> also, Box
[03:00:52] *** Joins: c0170 (c0170@moz-4stj9o.cable.virginm.net)
[03:02:23] <reem> How tricky would this be to implement? https://github.com/rust-lang/rfcs/issues/966
[03:03:33] <huon> it has to behave correctly wrt to conditional moves
[03:03:39] <huon> if foo { forget(bar) }
[03:04:09] <huon> meaning the same concerns apply as to normal moves
[03:04:30] <huon> basically, the compiler isn't set-up for not zeroing
[03:04:43] <huon> reem: ^
[03:04:50] <theme> arrrrrrr1, that RFC is going to be hard to get the details right
[03:05:04] <reem> huon: forget should mean do nothing
[03:05:09] <theme> I made 3 comments for 3 unresolved questions already
[03:05:28] <reem> huon: if foo { forget(bar) } can not drop bar in both paths
[03:05:42] <reem> basically, forget should not be marked as a move
[03:05:57] <reem> maybe it should be a macro
[03:06:08] <huon> reem: it has to cancel the destructor
[03:06:16] <huon> like, that's compulsory
[03:06:17] <theme> reem, forget(&mut T)?
[03:06:25] <huon> currently the way to cancel the destructor is zeroing
[03:06:36] <reem> arrrrrrr1: Just independently figured out why &move requires non-zeroing drop ^ :)
[03:06:39] <theme> would that work?
[03:06:57] <theme> reem, ??
[03:06:57] <arrrrrrr1> reem: unfortunately huon explained that &move doesn't require it
[03:07:03] <huon> reem: it doesn't need it, if &move is a language feature
[03:07:08] <arrrrrrr1> reem: don't worry. we were both wrong.
[03:07:17] <reem> arrrrrrr1: :D
[03:07:18] <theme> forget(&move T)? lol
[03:07:39] <reem> huon: I've been trying to implement it as a library type
[03:08:02] <huon> reem: yes, you'll need to hack around with Option or something
[03:08:11] <reem> I just need a way to mark data moved without zeroing it, which I've just realized is clearly impossible.
[03:08:46] <arrrrrrr1> theme: I believe just uncovered a fundamental but easy to fix mistake that is kind of obvious when you look at it. a &move [T] is always created from a &move U. therefore the &move [T] must contain a fat pointer itself. in my design it only contains a thin pointer right now. but that can be fixed
[03:08:54] <arrrrrrr1> *believe you just
[03:10:23] *** Quits: tedh (tedh@moz-ctbj7i.il.comcast.net) (Quit: Textual IRC Client: www.textualapp.com)
[03:11:10] *** Quits: Rym_ (y@moz-232.ad4.144.109.IP) (Ping timeout: 121 seconds)
[03:15:58] <theme> arrrrrrr1, is &move T valid if T is a concrete type?
[03:16:03] <theme> like &move i32
[03:17:48] <arrrrrrr1> it should be
[03:18:09] *** Joins: srh (User@moz-tvc5sp.sntcca.sbcglobal.net)
[03:18:48] <arrrrrrr1> do you see another problem?
[03:19:17] <arrrrrrr1> theme: ^
[03:19:52] <theme> arrrrrrr1, is &move [ &move T ] valid?
[03:20:04] * theme likes whacking the mole on edge cases
[03:20:13] <arrrrrrr1> theme: yes
[03:20:18] <arrrrrrr1> theme: I appreciate it
[03:20:43] <arrrrrrr1> it's 4:20 and I should probably go to be though
[03:20:53] <theme> :)
[03:21:10] <arrrrrrr1> I also thought about &move &move T maybe making problems, but it's ok
[03:21:14] <arrrrrrr1> (I think)
[03:23:13] <theme> arrrrrrr1, &move &mut T?
[03:23:21] <arrrrrrr1> I see no problem with that
[03:23:25] <theme> see the comments https://github.com/rust-lang/rfcs/pull/965
[03:24:04] <arrrrrrr1> theme: &move &mut T works like &mut &mut T unless you hove out of it
[03:24:12] <arrrrrrr1> *move
[03:25:04] *** Quits: c0170 (c0170@moz-4stj9o.cable.virginm.net) (Ping timeout: 121 seconds)
[03:34:23] *** Joins: dinfuehr (dinfuehr@moz-hkmhqm.highway.telekom.at)
[03:36:04] *** Quits: ^BR (br@moz-egk.dm6.194.78.IP) (Client exited)
[03:38:26] *** Quits: dinfuehr (dinfuehr@moz-hkmhqm.highway.telekom.at) (Ping timeout: 121 seconds)
[03:42:30] *** Quits: zz_kimundi (kimundi@moz-j326j4.dip0.t-ipconnect.de) (Ping timeout: 121 seconds)
[03:43:12] *** Quits: kmcguire (kmcguire@moz-c955nf.res.rr.com) (Connection closed)
[03:43:29] *** Joins: kmcguire (kmcguire@moz-c955nf.res.rr.com)
[03:43:59] *** Joins: zz_kimundi (kimundi@moz-sbftss.dip0.t-ipconnect.de)
[03:44:01] *** zz_kimundi is now known as kimundi
[03:44:12] *** Quits: scott (uid25790@moz-e5ok1n.brockwell.irccloud.com) (Quit: Connection closed for inactivity)
[03:45:50] *** Quits: japaric (japaric@moz-hvi.8pc.42.190.IP) (Connection closed)
[03:46:11] *** Joins: japaric (japaric@moz-ml2.qmr.240.201.IP)
[03:49:36] *** Quits: swgillespie (swgillespie@moz-rn1.vmq.232.104.IP) (Quit: My MacBook Pro has gone to sleep. ZZZzzz…)
[03:53:03] *** Joins: Rym_ (y@moz-232.ad4.144.109.IP)
[03:53:21] *** Quits: theme (theme@moz-i3mhhb.asianet.co.th) (Ping timeout: 121 seconds)
[03:56:45] *** Quits: johnsoft (johnsoft@moz-69mrig.res.rr.com) (Ping timeout: 121 seconds)
[03:56:55] *** Quits: arrrrrrr1 (arrrrrrrrs@moz-c0r0b0.dynamic.qsc.de) (Ping timeout: 121 seconds)
[03:57:03] *** Joins: johnsoft (johnsoft@moz-69mrig.res.rr.com)
[03:57:31] *** Quits: Rym_ (y@moz-232.ad4.144.109.IP) (Ping timeout: 121 seconds)
[03:57:58] *** Quits: Diggsey (diggsey@moz-u3erf7.dsl.pipex.com) (Ping timeout: 121 seconds)
[03:59:31] *** Quits: minzh (minzh@moz-97h.bjh.14.103.IP) (A TLS packet with unexpected length was received.)
[04:01:54] <eddyb_> comex: that's exactly how I thought about consts
[04:02:21] *** Joins: minzh (minzh@moz-97h.bjh.14.103.IP)
[04:02:24] <eddyb_> comex: but in the real world, not everything goes our (perfectionist) ways :(
[04:06:03] *** Joins: theme (theme@moz-i3mhhb.asianet.co.th)
[04:17:45] *** Joins: srh_ (User@moz-tvc5sp.sntcca.sbcglobal.net)
[04:21:05] *** Quits: srh (User@moz-tvc5sp.sntcca.sbcglobal.net) (Ping timeout: 121 seconds)
[04:21:32] *** Joins: semarie (semarie@moz-umep2l.guilhem.org)
[04:28:02] <comex> eddyb_: :)
[04:35:08] *** Joins: dinfuehr (dinfuehr@moz-hkmhqm.highway.telekom.at)
[04:39:11] *** Quits: acharles (acharles@moz-ulbdcn.ca.comcast.net) (Client exited)
[04:39:16] *** Quits: dinfuehr (dinfuehr@moz-hkmhqm.highway.telekom.at) (Ping timeout: 121 seconds)
[04:42:11] *** Joins: acharles (acharles@moz-ulbdcn.ca.comcast.net)
[04:43:28] *** Quits: mib_g9nqnt (Mibbit@moz-g6k.oht.161.46.IP) (Quit: http://www.mibbit.com ajax IRC Client)
[04:47:11] *** Joins: Rym_ (y@moz-232.ad4.144.109.IP)
[04:50:19] *** Quits: minzh (minzh@moz-97h.bjh.14.103.IP) (Connection closed)
[04:50:24] *** Joins: minzh (minzh@moz-97h.bjh.14.103.IP)
[04:51:43] *** Quits: Rym_ (y@moz-232.ad4.144.109.IP) (Ping timeout: 121 seconds)
[04:59:19] *** Joins: frogoniafc (Mibbit@moz-juv.9o3.252.72.IP)
[05:01:40] *** Quits: srh_ (User@moz-tvc5sp.sntcca.sbcglobal.net) (Quit: Leaving)
[05:03:12] *** sunfish is now known as sunfish-away
[05:07:53] *** Quits: mitsuhiko (mitsuhiko-m@moz-dcduic.srv.pocoo.org) (Quit: ZNC - http://znc.sourceforge.net)
[05:16:20] *** Quits: frogoniafc (Mibbit@moz-juv.9o3.252.72.IP) (Quit: http://www.mibbit.com ajax IRC Client)
[05:16:29] <eddyb_> reem: among other things, &move T is not actually that useful
[05:16:33] <eddyb_> reem: by itself, I mean
[05:16:46] <eddyb_> reem: have you seen my Move<T, S> drafts?
[05:16:51] <reem> eddyb_: Ya, we've talked about it
[05:16:57] <reem> this is why I pinged you in that convo
[05:17:09] <eddyb_> I... didn't see a ping
[05:17:17] <eddyb_> oh, there it is
[05:17:27] <reem> earlier discussion
[05:17:29] <reem> about the same thing
[05:17:46] <eddyb_> yeah, I need to start at the start
[05:17:56] <eddyb_> reem: but I gtg to school right now
[05:17:57] *** Quits: Johannes (Johannes@moz-4et8d7.ocn.ne.jp) (Connection closed)
[05:17:59] *** eddyb_ is now known as eddyb
[05:28:37] *** Quits: adu (ajr@moz-0foa9t.md.comcast.net) (Client exited)
[05:33:17] *** Joins: {0}grant ({0}grant@moz-63ubas.in.charter.com)
[05:33:20] *** Joins: {0}grant- ({0}grant@moz-63ubas.in.charter.com)
[05:33:24] *** Quits: {0}grant ({0}grant@moz-63ubas.in.charter.com) (Connection closed)
[05:34:19] *** {0}grant- is now known as {0}grant
[05:34:25] *** Quits: {0}grant ({0}grant@moz-63ubas.in.charter.com) (Connection closed)
[05:34:31] *** Joins: {0}grant ({0}grant@moz-63ubas.in.charter.com)
[05:34:46] <semarie> Manishearth: I see you prepare a rollup merge. could you patch the bitrig commit of src/snapshots.txt to correct "birig -> bitrig" ?
[05:35:00] *** Quits: {0}grant ({0}grant@moz-63ubas.in.charter.com) (Connection closed)
[05:35:42] *** Joins: {0}grant ({0}grant@moz-63ubas.in.charter.com)
[05:35:54] *** Joins: dinfuehr (dinfuehr@moz-hkmhqm.highway.telekom.at)
[05:35:55] *** Joins: erickt (erickt@moz-njt.vqi.14.76.IP)
[05:38:28] *** Quits: minzh (minzh@moz-97h.bjh.14.103.IP) (A TLS packet with unexpected length was received.)
[05:39:16] *** Quits: theme (theme@moz-i3mhhb.asianet.co.th) (Quit: Leaving)
[05:39:24] *** Quits: japaric (japaric@moz-ml2.qmr.240.201.IP) (Ping timeout: 121 seconds)
[05:39:57] *** Quits: dinfuehr (dinfuehr@moz-hkmhqm.highway.telekom.at) (Ping timeout: 121 seconds)
[05:41:20] *** Joins: Rym_ (y@moz-232.ad4.144.109.IP)
[05:41:49] *** Joins: munksgaard (munksgaard@moz-478pev.u.parknet.dk)
[05:43:35] <Manishearth> semarie: rebase isn't working properly for some reason
[05:43:41] <Manishearth> ill try though
[05:44:26] *** Quits: reem (reem@moz-dhk9um.coob.q2h1.0009.2601.IP) (Connection closed)
[05:45:51] *** Quits: Rym_ (y@moz-232.ad4.144.109.IP) (Ping timeout: 121 seconds)
[05:46:54] *** Quits: O01eg (o01eg@moz-ict.vtv.112.37.IP) (Client exited)
[05:47:49] <eddyb> nrc: only some pretty-rpass failures left on gh23265, I've pushed the fix and I'm testing it right now
[05:47:49] <[o__o]> Refactor the way methods are stored in ast::ImplItem/TraitItem.: https://github.com/rust-lang/rust/pull/23265
[05:48:16] <nrc> cool
[05:50:00] <nrc> eddyb: could we merge TypeItems and ImplItems?
[05:50:18] <nrc> The only difference seems to be the macro variant in impls
[05:53:01] <eddyb> eh
[05:53:04] <eddyb> nrc: look closer
[05:53:26] <eddyb> nrc: traits have optional defaults, impls have required "values"
[05:53:36] <eddyb> for everything
[05:54:05] <eddyb> (I noticed this when I tried to add constants. I got to metadata then gave up working with the old hierarchy)
[05:55:03] <nrc> I guess assoc types are pretty different
[05:55:23] <eddyb> yupp, you can add bounds in traits, but those bounds don't make sense in impls
[05:55:33] <nrc> (I was thinking impls could always just have Some(...), but I guess that would mean a lot of unwraps)
[05:55:33] <eddyb> even if we implement non-trait-impl associated types
[05:55:57] * eddyb rebases const-fn
[05:56:43] *** Joins: japaric (japaric@moz-gdm.bsv.236.190.IP)
[05:57:03] <eddyb> I really wish git would support splitting a file into multiple parts
[05:59:10] *** Joins: marsel (user@moz-o0t.pfd.255.92.IP)
[06:02:29] *** Quits: SiegeLord (sl@moz-9jtaei.ca.comcast.net) (Quit: It's a joke, it's all a joke.)
[06:05:11] *** Joins: reem (reem@moz-49b1rn.coob.q2h1.0009.2601.IP)
[06:07:24] *** Quits: munksgaard (munksgaard@moz-478pev.u.parknet.dk) (Ping timeout: 121 seconds)
[06:10:01] *** Joins: minzh (minzh@moz-97h.bjh.14.103.IP)
[06:11:20] <eddyb> wait wat
[06:11:45] <eddyb> nrc: I started rebasing that pretty-printing PR of mine and I've found that someone has rewritten pretty-printing to write to a buffer instead of a file :|
[06:11:47] <eternaleye> eddyb: What do you mean by 'splitting a file into multiple parts' ?
[06:12:04] <eternaleye> eddyb: If you mean staging hunks in one file in multiple commits, yes it can.
[06:12:05] <eddyb> eternaleye: when you move half a file somewhere else, git doesn't detect that
[06:12:09] <eddyb> no
[06:12:21] <eternaleye> eddyb: -M2 to diff?
[06:12:29] <eddyb> eternaleye: that only detects moved files
[06:12:32] <eternaleye> (or show, or other diff-like commands)
[06:12:34] <eddyb> not splitting
[06:12:43] <eternaleye> eddyb: Not sure of that; it could very well count it as copy + change
[06:12:57] <eddyb> eternaleye: it doesn't
[06:12:59] <eternaleye> eddyb: The number says to be more lenient with "how similar" they are
[06:13:14] <eddyb> I want *both* resulting files to be linked to the original
[06:13:24] <eternaleye> eddyb: Git does not track files.
[06:13:28] <eddyb> that's just something beyond current technology :P
[06:13:32] <eternaleye> eddyb: Git stores snapshots in time
[06:13:50] <eternaleye> eddyb: It then heuristics up history between files in a chain of snapshots
[06:13:51] <eddyb> yes, I meant a link during diff
[06:14:20] <eddyb> anyways, until then I'll have to merge changes across a split manually
[06:14:51] <reem> Can I use include! to include a docstring from another file?
[06:15:57] <eternaleye> eddyb: Ah, with -C it does
[06:16:14] <eternaleye> git log --patch -C  -> http://ix.io/gQj
[06:16:31] <eternaleye> eddyb: So yes, 50% of a file _does_ count as "copy and change"
[06:16:44] <eddyb> eternaleye: that's useless
[06:17:00] <eddyb> I mean, it's useful in some cases
[06:17:15] <eternaleye> eddyb: It does the closest thing _possible_ to what you want for git's data model.
[06:17:17] <eddyb> but the half it doesn't see is going to break merging
[06:17:27] <eddyb> eternaleye: no, that's not actually true
[06:17:36] <eddyb> I said the technology is not there yet
[06:18:07] <eddyb> our diffs are pretty old and battle-worn
[06:18:12] <eternaleye> eddyb: git merge -Xrename-threshold=30
[06:18:23] <eddyb> eternaleye: will it find both?
[06:18:39] <eddyb> I'm pretty sure it's exclusive right now
[06:22:29] *** Quits: reem (reem@moz-49b1rn.coob.q2h1.0009.2601.IP) (Connection closed)
[06:22:32] <eternaleye> Can never remember if it's "% lines unchanged" or something else
[06:22:35] <eternaleye> Ah, -Xrename-threshold=30%
[06:22:38] <eternaleye> The trailing % makes it a percentage
[06:22:42] *** Quits: erickt (erickt@moz-njt.vqi.14.76.IP) (Ping timeout: 121 seconds)
[06:22:43] <eddyb> yes
[06:22:44] <eternaleye> eddyb: Not sure
[06:23:00] <eternaleye> (my network died  for a sec; thank goodness for ZNC)
[06:23:24] <eddyb> and if you split off part of a file, with the original in place, I don't think it even bothers considering a move
[06:23:30] <eternaleye> Mm
[06:23:49] <eddyb> even with a threshold that would pick the move, you now lose changes on the original
[06:24:23] <eddyb> I know what I want is not doable right now, I'm just wishing for better
[06:24:30] *** Joins: reem (reem@moz-gu93u2.coob.q2h1.0009.2601.IP)
[06:25:00] <eternaleye> It may not be especially hard
[06:25:25] <eternaleye> If it already does moves, then porting the copies logic from diff-like commands is likely not prohibitive
[06:25:41] <eternaleye> Probably worth filing a bug at least
[06:26:59] <eddyb> copy + changing the original?
[06:27:52] <eddyb> bloody hell, I still can't switch branches in 2015 without LLVM rebuilds triggering - only ccache is saving me now
[06:30:48] *** Joins: Nekit1234007 (nekit@moz-vfr.64q.51.84.IP)
[06:34:14] *** Joins: killercup (killercup@moz-edmf2j.dip0.t-ipconnect.de)
[06:34:23] *** Joins: bluss (bluss@moz-ec5o68.cust.bredbandsbolaget.se)
[06:35:29] *** Joins: Rym_ (y@moz-232.ad4.144.109.IP)
[06:38:10] *** Joins: Tobba (Tobba@moz-o13d22.bredband.telia.com)
[06:40:03] *** Quits: Rym_ (y@moz-232.ad4.144.109.IP) (Ping timeout: 121 seconds)
[06:40:31] <WindowsBunny> lol llvm
[06:40:50] <WindowsBunny> eddyb: Someone needs to fix that :D
[06:42:02] *** Quits: killercup (killercup@moz-edmf2j.dip0.t-ipconnect.de) (Quit: My Mac has gone to sleep. ZZZzzz…)
[06:42:15] <huon> if you switch branches and LLVM needs to rebuild that means an LLVM updated landed, so it does actually need to rebuild, right?
[06:44:08] *** Joins: bjz (bjz@moz-4l6.mjm.52.113.IP)
[06:45:55] <eddyb> huon: src/llvm doesn't change
[06:46:16] <eddyb> or rather, the built version matches src/llvm perfectly
[06:46:31] <eddyb> actually, instead of hashing everything...
[06:47:30] <eddyb> one could use git's own hashes - as I almost never change files in src/llvm
[06:48:49] <eddyb> nmatsakis, nrc, acrichto: const-fn appears to be building again after the rebase, reviews welcome ;)
[06:48:49] *** Quits: bfops (uid58242@moz-e5u6m0.charlton.irccloud.com) (Quit: Connection closed for inactivity)
[06:49:13] <huon> hm, I don't remember ever seeing LLVM rebuild itself after a branch-switch unless the switch was across LLVM update(s)
[06:49:22] <huon> maybe I'm just lucky...
[06:49:24] <eddyb> huon: that it was
[06:50:01] <huon> wait, so it was changing the LLVM source?
[06:50:06] <eddyb> oh, I'm dumb, I forgot the rebase trick, I still switch to branches before attempting to rebase them
[06:50:31] *** Quits: bjz (bjz@moz-4l6.mjm.52.113.IP) (Ping timeout: 121 seconds)
[06:50:38] <eddyb> huon: A -> B -> A, where B had an older LLVM, but it was never built
[06:50:50] <huon> oh, yeah, that's annoying
[06:50:54] <eddyb> I don't see how it would have even been checked out, I thought make was doing it
[06:51:03] <eddyb> not git checkout branch
[06:51:39] <eddyb> huon: the smart way to do that is rebase B on top of upstream/master without checking it out first
[06:51:54] <eddyb> but git pull --rebase is so nice :(
[06:53:00] <eddyb> huon: I may just write a script to replace my checkout + pull --rebase workflow with a combined fetch + rebase
[06:54:57] *** Quits: Tobba (Tobba@moz-o13d22.bredband.telia.com) (Ping timeout: 121 seconds)
[07:01:39] *** Quits: minzh (minzh@moz-97h.bjh.14.103.IP) (Quit: Leaving...)
[07:03:19] *** Quits: reem (reem@moz-gu93u2.coob.q2h1.0009.2601.IP) (Connection closed)
[07:15:07] *** Joins: reem (reem@moz-7vt6pf.coob.q2h1.0009.2601.IP)
[07:16:46] *** Joins: bjz (bjz@moz-puppgq.tpgi.com.au)
[07:22:31] *** Quits: gsingh93 (gulshan@moz-3fu4am.mi.comcast.net) (Ping timeout: 121 seconds)
[07:22:35] *** Quits: reem (reem@moz-7vt6pf.coob.q2h1.0009.2601.IP) (Connection closed)
[07:23:41] *** Quits: Astrum|Lap (Astrum|Lap@moz-skcefh.co.comcast.net) (Client exited)
[07:24:07] *** Quits: untitaker (untitaker@moz-8ceamf.highway.telekom.at) (Ping timeout: 121 seconds)
[07:26:35] *** Joins: c0170 (c0170@moz-bb29a4.cambridge.arm.com)
[07:29:39] *** Joins: Rym_ (y@moz-232.ad4.144.109.IP)
[07:30:39] *** Joins: untitaker (untitaker@moz-0kb2h3.highway.telekom.at)
[07:32:33] *** Joins: reem (reem@moz-2icmmi.ca.comcast.net)
[07:34:13] *** Quits: Rym_ (y@moz-232.ad4.144.109.IP) (Ping timeout: 121 seconds)
[07:35:31] *** Quits: reem (reem@moz-2icmmi.ca.comcast.net) (Connection closed)
[07:37:00] *** Joins: reem (reem@moz-2icmmi.ca.comcast.net)
[07:42:01] *** Quits: njn (chatzilla@moz-i76q70.iinet.net.au) (Quit: ChatZilla 0.9.91.1 [Firefox 39.0a1/20150309142159])
[07:42:54] *** Quits: reem (reem@moz-2icmmi.ca.comcast.net) (Connection closed)
[07:43:50] *** Joins: reem (reem@moz-2icmmi.ca.comcast.net)
[07:49:45] *** Quits: reem (reem@moz-2icmmi.ca.comcast.net) (Connection closed)
[07:50:05] *** Joins: swgillespie (swgillespie@moz-rn1.vmq.232.104.IP)
[07:50:06] *** Joins: reem (reem@moz-2btb4f.coob.q2h1.0009.2601.IP)
[07:51:31] *** Quits: swgillespie (swgillespie@moz-rn1.vmq.232.104.IP) (Quit: My MacBook Pro has gone to sleep. ZZZzzz…)
[07:51:50] *** Joins: reem_ (reem@moz-2icmmi.ca.comcast.net)
[07:54:18] *** Quits: reem (reem@moz-2btb4f.coob.q2h1.0009.2601.IP) (Ping timeout: 121 seconds)
[08:01:58] *** Quits: kmcguire (kmcguire@moz-c955nf.res.rr.com) (Connection closed)
[08:02:20] *** Joins: Tobba|Laptop (Tobba@moz-1hh.7ki.21.217.IP)
[08:02:45] *** Joins: kmcguire (kmcguire@moz-c955nf.res.rr.com)
[08:12:05] *** Quits: barosl (barosl@moz-7vg.qma.67.220.IP) (Connection closed)
[08:13:26] *** Joins: barosl (barosl@moz-7vg.qma.67.220.IP)
[08:14:00] *** Quits: achernya (quassel@moz-i01917.mit.edu) (*.net *.split)
[08:14:00] *** Quits: sully (sully@moz-qhc979.emarhavil.com) (*.net *.split)
[08:14:00] *** Quits: Jesin (Jesin@moz-q46lj1.fios.verizon.net) (*.net *.split)
[08:14:00] *** Quits: jevin (jevin@moz-sra.ovp.12.72.IP) (*.net *.split)
[08:14:00] *** Quits: poorman (poorman@moz-7p5b2o.res.rr.com) (*.net *.split)
[08:14:00] *** Quits: WindowsBunny (Peter@moz-gv8vtu.east.verizon.net) (*.net *.split)
[08:14:00] *** Quits: steveklabnik (steveklabni@moz-kkp.qlp.131.104.IP) (*.net *.split)
[08:14:00] *** Quits: ctennis (ctennis@moz-vcpg3c.in.comcast.net) (*.net *.split)
[08:14:00] *** Quits: pjenvey (pjenvey@moz-ph7jic.org) (*.net *.split)
[08:14:00] *** Quits: comex (comex@moz-0m1t01.compute-1.amazonaws.com) (*.net *.split)
[08:14:00] *** Quits: hugod (user@moz-885.jmo.24.70.IP) (*.net *.split)
[08:14:00] *** Quits: kemurphy (kemurphy@moz-ke1.ea2.241.192.IP) (*.net *.split)
[08:14:00] *** Quits: blank_name (blank_name@moz-mteiba.mi.frontiernet.net) (*.net *.split)
[08:14:00] *** Quits: cgaebel (cgaebel@moz-aq9.qj7.199.198.IP) (*.net *.split)
[08:14:00] *** Quits: zeiris (zeiris@moz-8jbmam.letter.agency) (*.net *.split)
[08:14:00] *** Quits: [o__o] ([o__o]@moz-4s2t5k.compute-1.amazonaws.com) (*.net *.split)
[08:14:00] *** Quits: semarie (semarie@moz-umep2l.guilhem.org) (*.net *.split)
[08:14:00] *** Quits: jmorton (jmorton@moz-83s.irv.199.198.IP) (*.net *.split)
[08:14:00] *** Quits: lu324 (lu324___@moz-3v8ljg.dhcp.embarqhsd.net) (*.net *.split)
[08:14:00] *** Quits: kmehall (quassel@moz-i98f9d.kevinmehall.com) (*.net *.split)
[08:14:00] *** Quits: kwantam (kwantam@moz-1adqok.DYNAPOOL.NYU.EDU) (*.net *.split)
[08:14:00] *** Quits: tjakubow (tom@moz-kim.9e3.51.173.IP) (*.net *.split)
[08:14:00] *** Quits: alfred (rndm@moz-fg3.o0i.131.104.IP) (*.net *.split)
[08:14:00] *** Quits: Luqman (laden@moz-qhp202.csclub.uwaterloo.ca) (*.net *.split)
[08:14:00] *** Quits: geofft (geofft@moz-vfphq1.mit.edu) (*.net *.split)
[08:14:00] *** Quits: mmun (mmun@moz-iar.moo.170.107.IP) (*.net *.split)
[08:14:00] *** Quits: bitemyapp (callen@moz-s2l.6j9.199.198.IP) (*.net *.split)
[08:14:00] *** Quits: dustinm (dustinm@moz-9ms.n6q.68.208.IP) (*.net *.split)
[08:14:00] *** Quits: Sergio (Sergio@moz-23roph.bz) (*.net *.split)
[08:14:00] *** Quits: lahwran (lahwran@lahwran.net) (*.net *.split)
[08:14:00] *** Quits: jmesmon (ydoc@moz-naocu2.einic.org) (*.net *.split)
[08:14:00] *** Quits: carter (carter@moz-0253uj.members.linode.com) (*.net *.split)
[08:14:00] *** Quits: rovar (rovar@moz-d89.n7f.126.38.IP) (*.net *.split)
[08:14:00] *** Quits: kaptainkayak (kaptainkaya@moz-iar.moo.170.107.IP) (*.net *.split)
[08:14:00] *** Quits: tdfischer (tdfischer@hackerbots.net) (*.net *.split)
[08:14:00] *** Quits: johnsoft (johnsoft@moz-69mrig.res.rr.com) (*.net *.split)
[08:14:00] *** Quits: frewsxcv (frewsxcv@moz-lr4.h2r.241.192.IP) (*.net *.split)
[08:14:00] *** Quits: k1i (k1i@moz-cu3.cgm.243.162.IP) (*.net *.split)
[08:14:00] *** Quits: Anchovieshat (cloin@moz-4t5baq.pentaquine.com) (*.net *.split)
[08:14:00] *** Quits: awe (awe@moz-vpr.va5.236.104.IP) (*.net *.split)
[08:14:00] *** Quits: dmu (dmu@moz-eam.eti.221.66.IP) (*.net *.split)
[08:14:00] *** Quits: burntsushi (burntsushi@moz-t92kn9.ma.charter.com) (*.net *.split)
[08:14:00] *** Quits: ndt (ndt@moz-t0t.9gv.241.192.IP) (*.net *.split)
[08:14:00] *** Quits: pauls (pauls@moz-e5p333.ccs.neu.edu) (*.net *.split)
[08:14:00] *** Quits: BlakeWilliams (BW@moz-32q.80a.230.173.IP) (*.net *.split)
[08:14:00] *** Quits: bstrie (ben@moz-avu3ju.members.linode.com) (*.net *.split)
[08:14:00] *** Quits: {0}grant ({0}grant@moz-63ubas.in.charter.com) (*.net *.split)
[08:14:00] *** Quits: kmcguire (kmcguire@moz-c955nf.res.rr.com) (*.net *.split)
[08:14:00] *** Quits: freebroccolo (sid51271@moz-ealde0.ealing.irccloud.com) (*.net *.split)
[08:14:00] *** Quits: jroesch (sid26078@moz-o13a59.charlton.irccloud.com) (*.net *.split)
[08:14:00] *** Quits: huseby (huseby@moz-m7l0au.d2vr.5em6.6400.2605.IP) (*.net *.split)
[08:14:00] *** Quits: zwarich (sid63988@moz-402giv.ealing.irccloud.com) (*.net *.split)
[08:14:00] *** Quits: crail (sid24674@moz-s17jb5.charlton.irccloud.com) (*.net *.split)
[08:14:00] *** Quits: carllerche (sid50851@moz-8i75uq.brockwell.irccloud.com) (*.net *.split)
[08:14:00] *** Quits: tekacs (sid17636@moz-43fj8g.uxbridge.irccloud.com) (*.net *.split)
[08:14:00] *** Quits: ggherdov_ (sid11402@moz-u71qnt.charlton.irccloud.com) (*.net *.split)
[08:14:00] *** Quits: amanone (amanone@moz-eh1rje.sk83.bjud.7e00.2a01.IP) (*.net *.split)
[08:14:00] *** Quits: vadimcn (uid46608@moz-o7asbu.uxbridge.irccloud.com) (*.net *.split)
[08:14:00] *** Quits: bgamari (bgamari@moz-uvr07v.q402.fm1a.0470.2001.IP) (*.net *.split)
[08:14:00] *** Quits: aturon (sid36348@moz-n3h4qj.brockwell.irccloud.com) (*.net *.split)
[08:14:00] *** Quits: Fenhl (sid30770@moz-oh0hem.charlton.irccloud.com) (*.net *.split)
[08:14:00] *** Quits: balpert_ (sid15886@moz-eceqqb.uxbridge.irccloud.com) (*.net *.split)
[08:14:00] *** Quits: jack (sid19593@moz-d7cue0.uxbridge.irccloud.com) (*.net *.split)
[08:14:00] *** Quits: yuriks (quassel@moz-hnlou0.yuriks.net) (*.net *.split)
[08:14:00] *** Quits: martin_ (martin@moz-bmp33l.u0v6.gff7.1608.2001.IP) (*.net *.split)
[08:14:00] *** Quits: dherman (sid7996@moz-u0jlif.ealing.irccloud.com) (*.net *.split)
[08:14:00] *** Quits: richo (richo@moz-slrmp8.fs1g.619c.a880.2604.IP) (*.net *.split)
[08:14:00] *** Quits: huon (huon@moz-hj272o.8rnv.rggd.6180.2400.IP) (*.net *.split)
[08:14:00] *** Quits: sprang (sprang@moz-d0kmvi.12d9.sm5v.0009.2601.IP) (*.net *.split)
[08:14:00] *** Quits: Awerush (Awerush@moz-15s7c4.udtd.gaqb.04f8.2a01.IP) (*.net *.split)
[08:14:00] *** Quits: jvns (sid26231@moz-p7mvuh.brockwell.irccloud.com) (*.net *.split)
[08:14:00] *** Quits: mno2 (sid33176@moz-nd1l6h.brockwell.irccloud.com) (*.net *.split)
[08:14:00] *** Quits: spastorino (sid27384@moz-i6sgse.brockwell.irccloud.com) (*.net *.split)
[08:14:00] *** Quits: goffrie (uid69670@moz-1c9019.brockwell.irccloud.com) (*.net *.split)
[08:14:00] *** Quits: larsberg (sid16141@moz-fnneme.uxbridge.irccloud.com) (*.net *.split)
[08:14:00] *** Quits: Siosm (quassel@moz-hkaoqt.fr) (*.net *.split)
[08:14:00] *** Quits: sp3d (sp3d@moz-ik970v.enn1.s22b.000d.2601.IP) (*.net *.split)
[08:14:00] *** Quits: dbussink (dbussink@moz-hsd6q3.bussink.me) (*.net *.split)
[08:14:00] *** Quits: calc0000 (calc0000@moz-5tn399.mqd9.h8am.0980.2605.IP) (*.net *.split)
[08:14:00] *** Quits: jyyou (jyyou@moz-nhbjfr.bo6r.4bjo.8900.2400.IP) (*.net *.split)
[08:14:00] *** Quits: cha0s (chaos@moz-ebt9bj.q7tv.7c32.b0c0.2a03.IP) (*.net *.split)
[08:14:00] *** Quits: wycats (sid79@moz-b4lrm3.brockwell.irccloud.com) (*.net *.split)
[08:14:00] *** Quits: huhlig (sid17687@moz-0p5b0p.uxbridge.irccloud.com) (*.net *.split)
[08:14:00] *** Quits: Gankro (uid71432@moz-sc2bd6.charlton.irccloud.com) (*.net *.split)
[08:14:00] *** Quits: gus (quassel@moz-s29c4j.1136.t8sg.1801.2401.IP) (*.net *.split)
[08:14:00] *** Quits: jld (jld@moz-onnk26.xlerb.net) (*.net *.split)
[08:14:00] *** Quits: seanmonstar (seanmonstar@moz-jd3i0j.fkdv.ulf6.3c01.2600.IP) (*.net *.split)
[08:14:00] *** Quits: Levans (levans@moz-usvfnf.safaradeg.net) (*.net *.split)
[08:14:00] *** Quits: stask (sid61294@moz-0bjq4h.ealing.irccloud.com) (*.net *.split)
[08:14:00] *** Quits: tca (sid17279@moz-rjco49.uxbridge.irccloud.com) (*.net *.split)
[08:14:00] *** Quits: jethrogb (jethrob@moz-p2iedd.scintilla.utwente.nl) (*.net *.split)
[08:14:00] *** Quits: lkuper (sid44041@moz-7edef8.ealing.irccloud.com) (*.net *.split)
[08:14:00] *** Quits: zrl (sid22717@moz-0oej6h.brockwell.irccloud.com) (*.net *.split)
[08:14:00] *** Quits: bleibig (bleibig@moz-btk.gm4.170.73.IP) (*.net *.split)
[08:14:00] *** Quits: blaenk (blaenkdenum@moz-em283u.res.rr.com) (*.net *.split)
[08:14:00] *** Quits: Eridius (kevin@moz-6opvqs.us) (*.net *.split)
[08:14:00] *** Quits: ebfull (ebfull@moz-2hf06a.co.comcast.net) (*.net *.split)
[08:14:00] *** Quits: eternaleye (eternaleye@moz-5fh.ehi.245.50.IP) (*.net *.split)
[08:14:00] *** Quits: riveter (riveter@moz-h6gqqm.happyspork.com) (*.net *.split)
[08:14:00] *** Quits: nmatsakis (nmatsakis@moz-dkjr1g.scl3.mozilla.com) (*.net *.split)
[08:14:00] *** Quits: sfackler (sfackler@moz-ko8uu1.com) (*.net *.split)
[08:14:00] *** Quits: apoelstra (username@moz-pvbasl.net) (*.net *.split)
[08:14:00] *** Quits: reem_ (reem@moz-2icmmi.ca.comcast.net) (*.net *.split)
[08:14:00] *** Quits: dustinm` (dustinm@moz-es6jb7.ip-167-114-152.net) (*.net *.split)
[08:14:00] *** Quits: acharles (acharles@moz-ulbdcn.ca.comcast.net) (*.net *.split)
[08:14:00] *** Quits: JustAPerson (JustAPerson@moz-un628q.moe) (*.net *.split)
[08:14:00] *** Quits: playbot-mini (playbot-min@moz-1vk5qd.compute.amazonaws.com) (*.net *.split)
[08:14:00] *** Quits: XMPPwocky (wocky@moz-70npf7.net) (*.net *.split)
[08:14:00] *** Quits: playbot (playbot@moz-1vk5qd.compute.amazonaws.com) (*.net *.split)
[08:14:00] *** Quits: crazysim (crazysim@moz-ir8.6s3.199.198.IP) (*.net *.split)
[08:14:00] *** Quits: gavin (gavin@irc.mozilla.org) (*.net *.split)
[08:14:00] *** Quits: Kroisse (Kroisse@moz-t75tk5.krois.se) (*.net *.split)
[08:14:00] *** Quits: acrichto (acrichto@moz-u3dg2t.sfo1.mozilla.com) (*.net *.split)
[08:14:01] *** Quits: Murarth (Murarth@moz-c6ubhh.phnx.qwest.net) (*.net *.split)
[08:14:01] *** Quits: Amaranth (travis@moz-1raqsl.cpe.cableone.net) (*.net *.split)
[08:14:01] *** Quits: flaper87 (flaper87@moz-fnn.1e9.132.209.IP) (*.net *.split)
[08:14:01] *** Quits: sunfish-away (sunfish@moz-dkjr1g.scl3.mozilla.com) (*.net *.split)
[08:14:01] *** Quits: c74d (c74d3a4ebb6@moz-0ersgu.oc.cox.net) (*.net *.split)
[08:14:01] *** Quits: akawaka (akawaka@moz-0bb8q8.irvnca.sbcglobal.net) (*.net *.split)
[08:14:01] *** Quits: dcrewi (david@moz-3u3d5k.gyrae.net) (*.net *.split)
[08:14:01] *** Quits: det (chris@moz-7bbmke.lv.cox.net) (*.net *.split)
[08:14:01] *** Quits: HKT (HKT@moz-ab9.t40.131.104.IP) (*.net *.split)
[08:14:01] *** Quits: kmc (keegan@moz-gjgn5n.compute.amazonaws.com) (*.net *.split)
[08:14:01] *** Quits: Rusky (russell@moz-2a17lj.slkc.qwest.net) (*.net *.split)
[08:14:01] *** Quits: rs0 (rs0@moz-cfu0jl.compute.amazonaws.com) (*.net *.split)
[08:14:01] *** Quits: japaric (japaric@moz-gdm.bsv.236.190.IP) (*.net *.split)
[08:14:01] *** Quits: Skyler (Skyler@moz-e93b35.sd.cox.net) (*.net *.split)
[08:14:01] *** Quits: joneshf-laptop (joneshf@moz-l4h.b5s.208.98.IP) (*.net *.split)
[08:14:29] *** Joins: goffrie (uid69670@moz-1c9019.brockwell.irccloud.com)
[08:14:29] *** Joins: JustAPerson (JustAPerson@moz-un628q.moe)
[08:14:29] *** Joins: martin_ (martin@moz-bmp33l.u0v6.gff7.1608.2001.IP)
[08:14:29] *** Joins: lkuper (sid44041@moz-7edef8.ealing.irccloud.com)
[08:14:29] *** Joins: ndt (ndt@moz-t0t.9gv.241.192.IP)
[08:14:29] *** Joins: kemurphy (kemurphy@moz-ke1.ea2.241.192.IP)
[08:14:29] *** Joins: jroesch (sid26078@moz-o13a59.charlton.irccloud.com)
[08:14:29] *** Joins: seanmonstar (seanmonstar@moz-jd3i0j.fkdv.ulf6.3c01.2600.IP)
[08:14:29] *** Joins: {0}grant ({0}grant@moz-63ubas.in.charter.com)
[08:14:29] *** Joins: bitemyapp (callen@moz-s2l.6j9.199.198.IP)
[08:14:29] *** Joins: gus (quassel@moz-s29c4j.1136.t8sg.1801.2401.IP)
[08:14:29] *** Joins: tekacs (sid17636@moz-43fj8g.uxbridge.irccloud.com)
[08:14:29] *** Joins: rs0 (rs0@moz-cfu0jl.compute.amazonaws.com)
[08:14:29] *** Joins: akawaka (akawaka@moz-0bb8q8.irvnca.sbcglobal.net)
[08:14:29] *** Joins: carter (carter@moz-0253uj.members.linode.com)
[08:14:29] *** Joins: dmu (dmu@moz-eam.eti.221.66.IP)
[08:14:29] *** Joins: comex (comex@moz-0m1t01.compute-1.amazonaws.com)
[08:14:29] *** Joins: k1i (k1i@moz-cu3.cgm.243.162.IP)
[08:14:29] *** Joins: achernya (quassel@moz-i01917.mit.edu)
[08:14:29] *** Joins: mmun (mmun@moz-iar.moo.170.107.IP)
[08:14:29] *** Joins: Amaranth (travis@moz-1raqsl.cpe.cableone.net)
[08:14:29] *** Joins: richo (richo@moz-slrmp8.fs1g.619c.a880.2604.IP)
[08:14:29] *** Joins: alfred (rndm@moz-fg3.o0i.131.104.IP)
[08:14:29] *** Joins: Siosm (quassel@moz-hkaoqt.fr)
[08:14:29] *** Joins: kaptainkayak (kaptainkaya@moz-iar.moo.170.107.IP)
[08:14:29] *** Joins: mno2 (sid33176@moz-nd1l6h.brockwell.irccloud.com)
[08:14:29] *** Joins: Luqman (laden@moz-qhp202.csclub.uwaterloo.ca)
[08:14:29] *** Joins: sully (sully@moz-qhc979.emarhavil.com)
[08:14:29] *** Joins: rovar (rovar@moz-d89.n7f.126.38.IP)
[08:14:29] *** Joins: cgaebel (cgaebel@moz-aq9.qj7.199.198.IP)
[08:14:29] *** Joins: hugod (user@moz-885.jmo.24.70.IP)
[08:14:29] *** Joins: tca (sid17279@moz-rjco49.uxbridge.irccloud.com)
[08:14:29] *** Joins: freebroccolo (sid51271@moz-ealde0.ealing.irccloud.com)
[08:14:29] *** Joins: Fenhl (sid30770@moz-oh0hem.charlton.irccloud.com)
[08:14:29] *** Joins: huon (huon@moz-hj272o.8rnv.rggd.6180.2400.IP)
[08:14:29] *** Joins: crail (sid24674@moz-s17jb5.charlton.irccloud.com)
[08:14:29] *** Joins: HKT (HKT@moz-ab9.t40.131.104.IP)
[08:14:29] *** Joins: det (chris@moz-7bbmke.lv.cox.net)
[08:14:29] *** Joins: cha0s (chaos@moz-ebt9bj.q7tv.7c32.b0c0.2a03.IP)
[08:14:29] *** belew.mozilla.org sets mode: +o huon
[08:14:29] *** Joins: gavin (gavin@irc.mozilla.org)
[08:14:29] *** Joins: jmesmon (ydoc@moz-naocu2.einic.org)
[08:14:29] *** Joins: Sergio (Sergio@moz-23roph.bz)
[08:14:29] *** Joins: sunfish-away (sunfish@moz-dkjr1g.scl3.mozilla.com)
[08:14:29] *** Joins: Anchovieshat (cloin@moz-4t5baq.pentaquine.com)
[08:14:29] *** Joins: acrichto (acrichto@moz-u3dg2t.sfo1.mozilla.com)
[08:14:29] *** Joins: Awerush (Awerush@moz-15s7c4.udtd.gaqb.04f8.2a01.IP)
[08:14:29] *** Joins: tdfischer (tdfischer@hackerbots.net)
[08:14:29] *** Joins: zwarich (sid63988@moz-402giv.ealing.irccloud.com)
[08:14:29] *** Joins: semarie (semarie@moz-umep2l.guilhem.org)
[08:14:29] *** Joins: pauls (pauls@moz-e5p333.ccs.neu.edu)
[08:14:29] *** Joins: dherman (sid7996@moz-u0jlif.ealing.irccloud.com)
[08:14:29] *** Joins: kmc (keegan@moz-gjgn5n.compute.amazonaws.com)
[08:14:29] *** Joins: nmatsakis (nmatsakis@moz-dkjr1g.scl3.mozilla.com)
[08:14:29] *** Joins: frewsxcv (frewsxcv@moz-lr4.h2r.241.192.IP)
[08:14:29] *** Joins: geofft (geofft@moz-vfphq1.mit.edu)
[08:14:29] *** Joins: balpert_ (sid15886@moz-eceqqb.uxbridge.irccloud.com)
[08:14:29] *** Joins: jvns (sid26231@moz-p7mvuh.brockwell.irccloud.com)
[08:14:29] *** Joins: kmehall (quassel@moz-i98f9d.kevinmehall.com)
[08:14:29] *** Joins: jmorton (jmorton@moz-83s.irv.199.198.IP)
[08:14:29] *** Joins: spastorino (sid27384@moz-i6sgse.brockwell.irccloud.com)
[08:14:29] *** Joins: stask (sid61294@moz-0bjq4h.ealing.irccloud.com)
[08:14:29] *** Joins: ggherdov_ (sid11402@moz-u71qnt.charlton.irccloud.com)
[08:14:29] *** Joins: huseby (huseby@moz-m7l0au.d2vr.5em6.6400.2605.IP)
[08:14:29] *** Joins: wycats (sid79@moz-b4lrm3.brockwell.irccloud.com)
[08:14:29] *** Joins: bstrie (ben@moz-avu3ju.members.linode.com)
[08:14:29] *** Joins: crazysim (crazysim@moz-ir8.6s3.199.198.IP)
[08:14:29] *** Joins: dustinm (dustinm@moz-9ms.n6q.68.208.IP)
[08:14:29] *** Joins: Murarth (Murarth@moz-c6ubhh.phnx.qwest.net)
[08:14:29] *** Joins: zrl (sid22717@moz-0oej6h.brockwell.irccloud.com)
[08:14:29] *** Joins: sfackler (sfackler@moz-ko8uu1.com)
[08:14:29] *** Joins: Kroisse (Kroisse@moz-t75tk5.krois.se)
[08:14:29] *** Joins: [o__o] ([o__o]@moz-4s2t5k.compute-1.amazonaws.com)
[08:14:29] *** Joins: Eridius (kevin@moz-6opvqs.us)
[08:14:29] *** Joins: c74d (c74d3a4ebb6@moz-0ersgu.oc.cox.net)
[08:14:29] *** Joins: jethrogb (jethrob@moz-p2iedd.scintilla.utwente.nl)
[08:14:29] *** Joins: carllerche (sid50851@moz-8i75uq.brockwell.irccloud.com)
[08:14:29] *** Joins: reem_ (reem@moz-2icmmi.ca.comcast.net)
[08:14:29] *** Joins: Skyler (Skyler@moz-e93b35.sd.cox.net)
[08:14:29] *** belew.mozilla.org sets mode: +oooo acrichto nmatsakis wycats bstrie
[08:14:29] *** Joins: bgamari (bgamari@moz-uvr07v.q402.fm1a.0470.2001.IP)
[08:14:29] *** Joins: poorman (poorman@moz-7p5b2o.res.rr.com)
[08:14:29] *** Joins: huhlig (sid17687@moz-0p5b0p.uxbridge.irccloud.com)
[08:14:29] *** Joins: aturon (sid36348@moz-n3h4qj.brockwell.irccloud.com)
[08:14:29] *** Joins: japaric (japaric@moz-gdm.bsv.236.190.IP)
[08:14:29] *** Joins: jack (sid19593@moz-d7cue0.uxbridge.irccloud.com)
[08:14:29] *** Joins: sprang (sprang@moz-d0kmvi.12d9.sm5v.0009.2601.IP)
[08:14:29] *** Joins: dbussink (dbussink@moz-hsd6q3.bussink.me)
[08:14:29] *** Joins: johnsoft (johnsoft@moz-69mrig.res.rr.com)
[08:14:29] *** Joins: riveter (riveter@moz-h6gqqm.happyspork.com)
[08:14:29] *** Joins: yuriks (quassel@moz-hnlou0.yuriks.net)
[08:14:29] *** Joins: lu324 (lu324___@moz-3v8ljg.dhcp.embarqhsd.net)
[08:14:29] *** Joins: XMPPwocky (wocky@moz-70npf7.net)
[08:14:29] *** Joins: amanone (amanone@moz-eh1rje.sk83.bjud.7e00.2a01.IP)
[08:14:29] *** Joins: kwantam (kwantam@moz-1adqok.DYNAPOOL.NYU.EDU)
[08:14:29] *** Joins: pjenvey (pjenvey@moz-ph7jic.org)
[08:14:29] *** Joins: playbot (playbot@moz-1vk5qd.compute.amazonaws.com)
[08:14:29] *** Joins: steveklabnik (steveklabni@moz-kkp.qlp.131.104.IP)
[08:14:29] *** Joins: Gankro (uid71432@moz-sc2bd6.charlton.irccloud.com)
[08:14:29] *** Joins: WindowsBunny (Peter@moz-gv8vtu.east.verizon.net)
[08:14:29] *** Joins: bleibig (bleibig@moz-btk.gm4.170.73.IP)
[08:14:29] *** Joins: zeiris (zeiris@moz-8jbmam.letter.agency)
[08:14:29] *** Joins: ctennis (ctennis@moz-vcpg3c.in.comcast.net)
[08:14:29] *** Joins: kmcguire (kmcguire@moz-c955nf.res.rr.com)
[08:14:29] *** Joins: awe (awe@moz-vpr.va5.236.104.IP)
[08:14:29] *** Joins: apoelstra (username@moz-pvbasl.net)
[08:14:29] *** Joins: lahwran (lahwran@lahwran.net)
[08:14:29] *** Joins: sp3d (sp3d@moz-ik970v.enn1.s22b.000d.2601.IP)
[08:14:29] *** Joins: dustinm` (dustinm@moz-es6jb7.ip-167-114-152.net)
[08:14:29] *** Joins: calc0000 (calc0000@moz-5tn399.mqd9.h8am.0980.2605.IP)
[08:14:29] *** Joins: burntsushi (burntsushi@moz-t92kn9.ma.charter.com)
[08:14:29] *** Joins: vadimcn (uid46608@moz-o7asbu.uxbridge.irccloud.com)
[08:14:29] *** Joins: eternaleye (eternaleye@moz-5fh.ehi.245.50.IP)
[08:14:29] *** Joins: ebfull (ebfull@moz-2hf06a.co.comcast.net)
[08:14:29] *** Joins: jld (jld@moz-onnk26.xlerb.net)
[08:14:29] *** Joins: jevin (jevin@moz-sra.ovp.12.72.IP)
[08:14:29] *** Joins: BlakeWilliams (BW@moz-32q.80a.230.173.IP)
[08:14:29] *** Joins: jyyou (jyyou@moz-nhbjfr.bo6r.4bjo.8900.2400.IP)
[08:14:29] *** Joins: flaper87 (flaper87@moz-fnn.1e9.132.209.IP)
[08:14:29] *** belew.mozilla.org sets mode: +oo aturon steveklabnik
[08:14:29] *** Joins: Rusky (russell@moz-2a17lj.slkc.qwest.net)
[08:14:29] *** Joins: Levans (levans@moz-usvfnf.safaradeg.net)
[08:14:29] *** Joins: tjakubow (tom@moz-kim.9e3.51.173.IP)
[08:14:29] *** Joins: Jesin (Jesin@moz-q46lj1.fios.verizon.net)
[08:14:29] *** Joins: acharles (acharles@moz-ulbdcn.ca.comcast.net)
[08:14:29] *** Joins: playbot-mini (playbot-min@moz-1vk5qd.compute.amazonaws.com)
[08:14:29] *** Joins: blank_name (blank_name@moz-mteiba.mi.frontiernet.net)
[08:14:29] *** Joins: joneshf-laptop (joneshf@moz-l4h.b5s.208.98.IP)
[08:14:29] *** Joins: dcrewi (david@moz-3u3d5k.gyrae.net)
[08:14:29] *** Joins: larsberg (sid16141@moz-fnneme.uxbridge.irccloud.com)
[08:14:29] *** Joins: blaenk (blaenkdenum@moz-em283u.res.rr.com)
[08:15:18] *** Quits: barosl (barosl@moz-7vg.qma.67.220.IP) (Quit: Leaving)
[08:15:52] *** Joins: kushal (kdas@moz-uootr6.redhat.com)
[08:17:08] *** Quits: c0170 (c0170@moz-bb29a4.cambridge.arm.com) (Ping timeout: 121 seconds)
[08:17:45] *** Joins: c0170 (c0170@moz-bb29a4.cambridge.arm.com)
[08:19:37] *** Joins: barosl (barosl@moz-7vg.qma.67.220.IP)
[08:19:50] *** Joins: pnkfelix (pnkfelix@moz-eljppb.fbx.proxad.net)
[08:19:50] *** ChanServ sets mode: +o pnkfelix
[08:19:54] *** Joins: killercup (killercup@moz-4udt1b.dip0.t-ipconnect.de)
[08:20:53] *** Joins: zmack (zmack@moz-4b0.o8l.26.188.IP)
[08:21:34] *** Joins: munksgaard (munksgaard@moz-lui.hq0.225.130.IP)
[08:22:21] <reem_> Gankro: Is it intended that you have to do [*"hello"] to index a BTreeMap<String, ..>?
[08:22:27] *** reem_ is now known as reem
[08:23:51] *** Joins: Rym_ (y@moz-232.ad4.144.109.IP)
[08:24:29] *** Quits: zmack (zmack@moz-4b0.o8l.26.188.IP) (Connection closed)
[08:24:35] *** Joins: zmack (zmack@moz-4b0.o8l.26.188.IP)
[08:25:52] *** Joins: imperio (Mibbit@moz-psdrik.rev.sfr.net)
[08:26:47] <bluss> it can't be intentional
[08:26:54] <bluss> just unfortunate
[08:27:40] *** Quits: reem (reem@moz-2icmmi.ca.comcast.net) (Connection closed)
[08:27:47] *** Joins: reem (reem@moz-2icmmi.ca.comcast.net)
[08:28:22] *** Quits: Rym_ (y@moz-232.ad4.144.109.IP) (Ping timeout: 121 seconds)
[08:31:17] <WindowsBunny> reem: That seems awful
[08:45:53] *** Joins: eddyb_ (eddyb@moz-42r.9jn.166.109.IP)
[08:46:26] <eddyb_> uhm
[08:46:38] <eddyb_> why don't we use () for generic type params?
[08:47:11] <eddyb_> "5".parse::(i32)() may look a bit odd
[08:47:29] <eddyb_> 5.parse().unwrap(): i32
[08:47:43] <eddyb_> ehm, "5"
[08:48:09] <eddyb_> what's really interesting though is at the type level:
[08:48:18] <Yurume> eddyb_: dependently typed Rust!
[08:48:39] <eddyb_> StackVec(T, 2.pow(N))
[08:58:28] <eddyb_> Yurume: bvssvni was talking about trait resolution as a function that takes types and returns a value
[08:58:50] <Yurume> HKT indeed
[08:59:59] <eddyb_> multidispatch in operator overloading was the context IIRC
[09:04:54] *** Quits: kushal (kdas@moz-uootr6.redhat.com) (Quit: Leaving)
[09:04:58] *** Joins: kushal (kdas@moz-uootr6.redhat.com)
[09:05:24] *** Quits: reem (reem@moz-2icmmi.ca.comcast.net) (Connection closed)
[09:06:46] *** Joins: reem (reem@moz-2icmmi.ca.comcast.net)
[09:07:01] *** Quits: reem (reem@moz-2icmmi.ca.comcast.net) (Connection closed)
[09:09:59] <eddyb_> Yurume: please tell me total unifications of types and values is impossible so I don't go nuts trying to get there
[09:10:23] <eddyb_> or is that where dependent types are headed?
[09:11:30] <eddyb_> hmm, const fn's could work on types
[09:11:33] *** Joins: reem (reem@moz-3eef3r.coob.q2h1.0009.2601.IP)
[09:13:06] *** Joins: tcurdt (tcurdt@moz-m3gqr9.dip0.t-ipconnect.de)
[09:17:35] *** Joins: laumann (laumann@moz-3v9.hq0.225.130.IP)
[09:18:02] *** Joins: Rym_ (y@moz-232.ad4.144.109.IP)
[09:19:38] *** Joins: erickt (erickt@moz-njt.vqi.14.76.IP)
[09:19:46] <Manishearth> eddyb_: are you trying to javascript us?
[09:20:51] <eddyb_> Manishearth: JS is unityped
[09:20:53] *** Quits: zmack (zmack@moz-4b0.o8l.26.188.IP) (Connection closed)
[09:21:03] <eddyb_> where uni is short for unicorn
[09:21:53] <imperio> That's funny, I come here and I see unicorn. That's becoming a bit weird...
[09:22:33] *** Quits: Rym_ (y@moz-232.ad4.144.109.IP) (Ping timeout: 121 seconds)
[09:23:48] *** Quits: erickt (erickt@moz-njt.vqi.14.76.IP) (Ping timeout: 121 seconds)
[09:24:44] <Manishearth> stringly typed :P
[09:25:01] <Manishearth> eddyb_: but technically prototypes are functions, which are values, which ....
[09:25:13] <Manishearth> functions/objects
[09:25:17] <Manishearth> you know what I mean
[09:25:31] *** Quits: eddyb_ (eddyb@moz-42r.9jn.166.109.IP) (Ping timeout: 121 seconds)
[09:32:19] *** Joins: eddyb_ (eddyb@moz-1b3.9jn.166.109.IP)
[09:33:46] *** Joins: simukis (nagisa@moz-8t068g.static.zebra.lt)
[09:34:12] <eddyb_> wow
[09:34:36] *** Joins: Diggsey (diggsey@moz-u3erf7.dsl.pipex.com)
[09:35:11] <eddyb_> Yurume: do you know my existential notation for -> impl Trait?
[09:36:30] <eddyb_> if you extend it to values
[09:36:40] <eddyb_> you can encode arbitrary properties
[09:36:45] <eddyb_> typestate
[09:36:53] <eddyb_> refinement types
[09:36:56] <eddyb_> gadt
[09:40:58] *** Quits: eddyb_ (eddyb@moz-1b3.9jn.166.109.IP) (Ping timeout: 121 seconds)
[09:44:32] *** Quits: reem (reem@moz-3eef3r.coob.q2h1.0009.2601.IP) (Connection closed)
[09:46:32] *** Joins: ptalbot (ptalbot@moz-j4gnuh.fbx.proxad.net)
[09:47:00] *** Quits: nrc (nrc@moz-4bhi2i.xtra.co.nz) (Ping timeout: 121 seconds)
[09:55:14] *** Joins: larhat (Adium@moz-8v4.af0.232.213.IP)
[10:08:34] *** Joins: zmack (zmack@moz-b26i0b.home.aster.pl)
[10:10:16] *** Joins: arrrrrrr1 (arrrrrrrrs@moz-c0r0b0.dynamic.qsc.de)
[10:12:11] *** Joins: Rym_ (y@moz-232.ad4.144.109.IP)
[10:16:43] *** Quits: Rym_ (y@moz-232.ad4.144.109.IP) (Ping timeout: 121 seconds)
[10:17:56] *** Joins: eddyb_ (eddyb@moz-1s7.2kg.166.109.IP)
[10:20:22] <eddyb_> you can do existentials in higher level languages with some kind of uniformity (like GC pointers)
[10:20:29] *** Quits: marsel (user@moz-o0t.pfd.255.92.IP) (Ping timeout: 121 seconds)
[10:21:00] <eddyb_> our trait objects are a special case of exists T:Trait.*T
[10:21:47] <eddyb_> value:Type:Trait - do we have a 3-tiered system?
[10:22:30] <eddyb_> T: Trait is not exclusive, while x: T is
[10:22:37] <eddyb_> maybe that is wrong
[10:23:15] *** Quits: arrrrrrr1 (arrrrrrrrs@moz-c0r0b0.dynamic.qsc.de) (Ping timeout: 121 seconds)
[10:26:59] <eddyb_> first thing that has to go: methods
[10:27:57] <eddyb_> associatee values should do
[10:28:05] <eddyb_> *associated
[10:28:38] <eddyb_> you have to add fields, but what are fields?
[10:29:06] *** Quits: kushal (kdas@moz-uootr6.redhat.com) (Ping timeout: 121 seconds)
[10:29:13] <eddyb_> fields and methods are syntactic sugar for type-safe offsets and functions
[10:29:21] *** Joins: Guest63 (textual@moz-56c.qli.61.176.IP)
[10:30:39] <eddyb_> now you can fully describe a structural type with traits
[10:31:21] *** Quits: killercup (killercup@moz-4udt1b.dip0.t-ipconnect.de) (Quit: My Mac has gone to sleep. ZZZzzz…)
[10:31:29] <eddyb_> tagged unions are harder because of the special status of pattern matching
[10:31:50] <eddyb_> so patterns have to be abstracted away
[10:32:07] *** Quits: eddyb_ (eddyb@moz-1s7.2kg.166.109.IP) (Quit: Bye)
[10:32:18] *** Joins: marsel (user@moz-up4.n51.180.94.IP)
[10:34:25] *** Quits: tcurdt (tcurdt@moz-m3gqr9.dip0.t-ipconnect.de) (Quit: Textual IRC Client: www.textualapp.com)
[10:38:19] <Manishearth> barosl: bors might have stalled
[10:38:21] <Manishearth> cc acrichto 
[10:38:27] <Manishearth> it's stuck here: http://buildbot.rust-lang.org/homu/queue/rust
[10:38:34] <Manishearth> nothing in the waterfall
[10:38:38] <Manishearth> and force isn't working
[10:38:42] <barosl> Manishearth, I believe that's because the slaves are dead
[10:38:53] <barosl> Not sure why though
[10:39:00] <Manishearth> they seem connected to me
[10:39:15] <barosl> http://buildbot.rust-lang.org/buildslaves
[10:39:18] <huon> they should be connected to bors
[10:39:20] <huon> not to you
[10:39:29] <Manishearth> huon: no from the buildbot
[10:39:43] <Manishearth> I odn't have access to them anyway
[10:39:45] <barosl> Every windows slave seems to be disconnected
[10:39:45] <Manishearth> huh
[10:39:53] <Manishearth> mac seems up though
[10:40:08] <Manishearth> oh, mac is busy
[10:40:09] <huon> Manishearth: I was making a joke ;P
[10:40:26] <barosl> And the last build results from the Windows builders were "retry exception slave lost"
[10:40:27] <Manishearth> haha
[10:40:48] <barosl> Luckily Homu didn't parse it as an error :P
[10:41:10] <Manishearth> heh
[10:43:42] <barosl> Huh?
[10:43:48] <barosl> http://buildbot.rust-lang.org/homu/queue/rust
[10:44:00] <barosl> The head ref of #22769 is wrong
[10:45:38] <barosl> Hmm, looking at the code, that information is directly retrieved using the GitHub push API
[10:45:47] <barosl> So it may be GitHub's fault again :P
[10:46:18] *** Joins: killercup (killercup@moz-4udt1b.dip0.t-ipconnect.de)
[10:46:52] *** Quits: kmcguire (kmcguire@moz-c955nf.res.rr.com) (Ping timeout: 121 seconds)
[10:48:11] <Manishearth> die github 
[10:50:19] *** Joins: eddyb_ (eddyb@moz-tfh.t0c.166.109.IP)
[10:50:50] <eddyb_> I'm no closer to solving patterns
[10:50:56] <Manishearth> solving patterns?
[10:50:56] *** Joins: arrrrrrr1 (arrrrrrrrs@moz-c0r0b0.dynamic.qsc.de)
[10:50:59] <Manishearth> for constfn?
[10:51:52] <eddyb_> but I'm wondering how close I am to an ECS since I've replaced trait/type/value with "entity"
[10:52:30] <eddyb_> Manishearth: no, isn't it obvious from the backlog that I am trying to reppace type systems?
[10:52:34] <Manishearth> ah
[10:52:57] <eddyb_> Manishearth: maybe I need to take my monologue to offtopic :P
[10:53:04] <Manishearth> hah
[10:56:06] *** Quits: Tobba|Laptop (Tobba@moz-1hh.7ki.21.217.IP) (Ping timeout: 121 seconds)
[11:02:31] <Manishearth> so, buildslaves are dead and there's nothign I can do about it
[11:02:34] * Manishearth -> panic
[11:03:49] *** Quits: eddyb_ (eddyb@moz-tfh.t0c.166.109.IP) (Ping timeout: 121 seconds)
[11:05:22] *** Quits: ptalbot (ptalbot@moz-j4gnuh.fbx.proxad.net) (Ping timeout: 121 seconds)
[11:06:20] *** Joins: Rym_ (y@moz-232.ad4.144.109.IP)
[11:10:05] *** Quits: p1start (p1start@moz-nftjhe.org) (Ping timeout: 121 seconds)
[11:10:52] *** Quits: Rym_ (y@moz-232.ad4.144.109.IP) (Ping timeout: 121 seconds)
[11:11:43] <simukis> Manishearth: I lend you my unicode arrow. Take →
[11:12:03] <Manishearth> simukis: I just see a question mark
[11:12:17] <Manishearth> benefits of using IRC over ssh with different encodings
[11:17:22] <benh> needs more utf-8 :(
[11:19:08] <Manishearth> locally I'm on en-IN, and stuff works fine
[11:19:21] *** Joins: kmcguire (kmcguire@moz-pg1gb9.biz.rr.com)
[11:19:21] <Manishearth> on ssh I'm on en-US.utf8 and it's broken :P
[11:19:34] <benh> if utf-8 isn't working you're not applying enough of it!
[11:20:52] <Manishearth> hah
[11:24:18] *** Joins: gleb (gleb@moz-3u1drv.rusanovka-net.kiev.ua)
[11:24:39] *** Joins: nrc (nrc@moz-4bhi2i.xtra.co.nz)
[11:24:40] *** ChanServ sets mode: +o nrc
[11:28:38] *** Joins: ^BR (br@moz-egk.dm6.194.78.IP)
[11:29:57] *** Quits: nrc (nrc@moz-4bhi2i.xtra.co.nz) (Ping timeout: 121 seconds)
[11:31:33] *** Quits: Guest63 (textual@moz-56c.qli.61.176.IP) (Quit: My Mac has gone to sleep. ZZZzzz…)
[11:35:19] <gleb> if I have fn bar() -> (i32, Foo) and call baz(bar().0) how long is the unused Foo guaranteed to live?
[11:36:13] <gleb> oh, sorry, wrong channel :/
[11:46:39] *** Joins: ytain (ytain@moz-lio.ur1.175.184.IP)
[11:47:46] *** Joins: eibwen (eibwen@moz-42bprd.dip0.t-ipconnect.de)
[11:49:37] *** Joins: japaric_ (japaric@moz-t17.t9l.232.190.IP)
[11:51:45] *** Quits: japaric (japaric@moz-gdm.bsv.236.190.IP) (Ping timeout: 121 seconds)
[11:57:02] <munksgaard> What's the difference between a ty_ptr and a ty_rptr?
[11:57:29] <huon> ty_ptr is *const/*mut, ty_rptr is &/&mut
[11:57:33] *** Joins: mib_cypu37 (Mibbit@moz-juv.9o3.252.72.IP)
[11:57:36] <huon> (rptr == "region pointer")
[11:57:53] <munksgaard> huon: Thanks
[11:59:01] <munksgaard> Is there any idea in putting stuff like that in a docstring in ty.rs ?
[11:59:37] <huon> pull requests adding that sort of documentation would be great :)
[11:59:44] <munksgaard> It seems kind of arbitrary that ty_enum has a docstring, but none of the other items in the sty enum have docstrings
[12:00:08] <munksgaard> huon: Cool, I'll add it to my list :)
[12:00:24] <huon> usually just means someone noticed/added something and took the time to document that fact
[12:00:30] *** Joins: Rym_ (y@moz-232.ad4.144.109.IP)
[12:05:03] *** Quits: Rym_ (y@moz-232.ad4.144.109.IP) (Ping timeout: 121 seconds)
[12:06:44] *** Quits: mib_cypu37 (Mibbit@moz-juv.9o3.252.72.IP) (Quit: http://www.mibbit.com ajax IRC Client)
[12:12:07] *** Quits: ytain (ytain@moz-lio.ur1.175.184.IP) (Ping timeout: 121 seconds)
[12:14:33] *** Joins: ytain (ytain@moz-lio.ur1.175.184.IP)
[12:15:24] *** Quits: marsel (user@moz-up4.n51.180.94.IP) (Ping timeout: 121 seconds)
[12:22:02] *** Joins: ptalbot (ptalbot@moz-1gn7gb.eu0n.jcdj.0660.2001.IP)
[12:27:05] <Manishearth> munksgaard: AST/middle docs are basically whenever someone got bitten by something
[12:27:17] <Manishearth> reminds me, I planned to document all of the AST at one point
[12:27:51] <Manishearth> munksgaard: btw, just realized, the branch-handling system needs to handle returns/breaks/continues too
[12:27:55] <Manishearth> or just disallow them
[12:29:51] <munksgaard> Manishearth: Good point, 
[12:29:51] <Manishearth> huon: hey, is there a single place in the codegen where insertion of drop calls is done?
[12:30:02] <Manishearth> or before codegen; whatever
[12:30:39] <Manishearth> munksgaard: then again, complex flow structures is precisely what we *don't* want
[12:31:07] <Manishearth> well, not precisely
[12:31:08] <Manishearth> but close
[12:35:02] <Manishearth>  /topic TREE CLOSED because it's apparently taken a sick day without telling anyone
[12:37:45] <simukis> Manishearth: glue.rs
[12:37:50] <simukis> trans/glue.rs
[12:38:10] <Manishearth> simukis: thanks
[12:38:42] <Manishearth> only 624 lines of code?
[12:38:46] <Manishearth> wow I was lucky
[12:39:33] <Manishearth> munksgaard: I might try to bake drop protection into the compiler and see
[12:39:36] <Manishearth> it looks simple
[12:39:47] <Manishearth> drop_ty in src/librustc_trans/glue.rs
[12:40:12] <munksgaard> Manishearth: Hah, that's actually one of the places I was looking at in the beginning :)
[12:40:27] <Manishearth> simukis: so if I put a panic there it will crash whenever an implicit drop is inserted?
[12:41:12] <Manishearth> munksgaard: the only hard part is making it ignore whenever it's inside a correctly annotated function
[12:41:20] *** Quits: pnkfelix (pnkfelix@moz-eljppb.fbx.proxad.net) (Quit: rcirc on GNU Emacs 24.3.92.1)
[12:41:26] <simukis> Manishearth: you probably should be doing that in get_drop_glue
[12:42:13] <simukis> this is basically the entry method for drop glue translation
[12:43:11] <Manishearth> simukis: ah
[12:43:43] <Manishearth> simukis: What we want to do basically is that any type with the right annotation should not be alowed to get implicitly dropped (eg at the end of a block)
[12:43:52] <Manishearth> unless this is in a specially marked function
[12:43:57] <Manishearth> or perhaps just an unsafe context
[12:44:17] <Manishearth> would doing this check in get_drop_glue work, or is it called prematurely too?
[12:44:39] <Manishearth> there's some vtable stuff in meth.rs that seems to mean that it's called prematurely
[12:46:00] <simukis> Manishearth: ah, see make_drop_glue then.
[12:47:11] <simukis> I believe you could thread Attributes to it somehow
[12:47:28] <simukis> (wouldn’t be too hard since it has literally one callee)
[12:47:35] <simukis> s/callee/caller/
[12:48:03] <Manishearth> simukis: I have a Ty, so I should be able to get me an attribute
[12:48:22] <Manishearth> the hard part is getting to a fn def
[12:48:28] <Manishearth> or even the unsafe block context
[12:48:52] <munksgaard> Hm, is RUST_LOG broken? I'm not getting everything I used to :/
[12:49:05] <Manishearth> munksgaard: might have changed
[12:49:07] <eddyb> Manishearth: what are you trying to do?
[12:49:11] <eddyb> ah
[12:49:12] <Manishearth> RUST_LOG=debug:crate::mod::mod
[12:49:14] <Manishearth> eddyb: same thing
[12:49:18] <Manishearth> linear types :p
[12:49:22] <eddyb> Manishearth: you're trying to do linear types wrong
[12:49:24] <munksgaard> Manishearth: https://github.com/rust-lang/rust/issues/21871 
[12:49:35] <munksgaard> It doesn't produce any debug output any more
[12:49:41] <Manishearth> eddyb: no, we want something similar to linear types
[12:49:51] <Manishearth> eddyb: how would it be done right?
[12:49:55] <eddyb> Manishearth: which apparently are harder to implement than my linear types :P
[12:50:07] <Manishearth> eddyb: so what are yours; how do they behave?
[12:50:19] <eddyb> and dubiously flexible
[12:50:27] <eddyb> Manishearth: what is your design space?
[12:50:31] <Manishearth> eddyb: as in?
[12:51:08] <eddyb> what are the bounds of the multi-dimensional parameter space in which you prefer a solution to be found in?
[12:51:41] <eddyb> I think linear programming has a nicer description of what I mean
[12:51:52] <munksgaard> eddyb: I have absolutely no idea what that meant
[12:51:54] <eddyb> (where linear programming has nothing to do with linear types)
[12:52:02] <eddyb> munksgaard: what are your requirements :P?
[12:52:50] <Manishearth> eddyb: Oh, we'd prefer to stick to a plugin, but a maintainable smallish tweak to the compiler  is also okay
[12:53:00] <munksgaard> eddyb: Say we have a struct Foo, I want the user to be notified at compile time if it get's dropped in a function that hasn't been specifically annotated with an attribute
[12:53:02] <eddyb> (this is still pretty cool to visualize in more than 3 dimensions https://en.wikipedia.org/wiki/Linear_programming)
[12:53:13] <munksgaard> s/I/we/
[12:53:29] <eddyb> munksgaard: what if you didn't have an annotation and instead it was privacy-based?
[12:53:30] <Manishearth> eddyb: Anyway, I want to know how your idea for linear types behaves, not how it is implemented (now)
[12:53:53] <Manishearth> eddyb: oh, I know what linear programming is :)
[12:53:58] <Manishearth> privacy based? how?
[12:54:00] <munksgaard> Privacy-based, how? The user needs to write programs that take vales of type Foo as arguments
[12:54:04] <munksgaard> :D
[12:54:11] <eddyb> field privacy
[12:54:21] <Manishearth> again, how?
[12:54:22] <eddyb> would you be okay with "only functions that can create the type can also destroy it"?
[12:54:32] <Manishearth> yes
[12:54:34] <eddyb> good
[12:54:37] <Manishearth> eddyb: well, no
[12:54:40] *** Joins: Rym_ (y@moz-232.ad4.144.109.IP)
[12:54:41] <eddyb> :/
[12:54:45] <munksgaard> ha ha
[12:54:48] <Manishearth> eddyb: we want to have an explicit drop() function to exist
[12:54:50] <Manishearth> I think
[12:54:55] <eddyb> do you?
[12:55:00] <Manishearth> munksgaard: we do, right?
[12:55:04] <eddyb> because that's a pretty bad design, as far as soundness goes
[12:55:05] <munksgaard> Manishearth: Yup
[12:55:15] <Manishearth> eddyb: We want drops to be explicit, basically
[12:55:27] <Manishearth> munksgaard: perhaps this could be implemented via magical transmutes?
[12:55:31] <eddyb> *sigh*
[12:55:34] <munksgaard> eddyb: Well here's the whole story:
[12:56:28] <eddyb> my linear type design allows you to define functions that consume the value (you say "drop", but that's not the right terminology)
[12:56:33] <munksgaard> We are modelling session types using a struct Chan that takes a type parameter (two, actually, but that's irrelevant). That type parameter is supposed to be one of several structs that we've defined, such as Send, Recv, or Eps (meaning end of transmission)
[12:56:51] <eddyb> it's not "mine", really, I just came up with a very simple way to integrate it with Rust
[12:57:01] <munksgaard> So, it could look like `c: Chan<Send<u8, Eps>>`
[12:57:29] <eddyb> munksgaard: so far so good
[12:58:52] <munksgaard> Now, we have methods that take channels of different types and execute the right actions, so the method `send<T>(self, T) -> Chan<R>` is only implemented for Chans of type `Chan<Send<T, R>>`, meaning that it takes the chan and something to send, consumes the chan and returns a new chan (throught transmute)
[12:59:12] *** Quits: Rym_ (y@moz-232.ad4.144.109.IP) (Ping timeout: 121 seconds)
[12:59:12] <munksgaard> That way, you can never, say, receive on a Chan that's supposed to be sent on
[12:59:17] <munksgaard> At that point in time
[13:00:19] <munksgaard> Additionally, we have a method `close(self)` that is implemented for Chan<Eps>, and is used to close a channel once the protocol/session has ended
[13:00:23] *** Joins: jdm (jdm@moz-ilbt2e.cable.teksavvy.com)
[13:00:45] <munksgaard> We'd like to make certain that no Chans get dropped in any other way than through that close method
[13:02:32] <munksgaard> For instance, if I have a function `fn foo(c: Chan<Send<u8, Eps>>) { }`, it will happily compile at the moment, but it's not a valid program, since it'll panic once paired with a proper dual function like `fn bar(c: Chan<Recv<u8, Eps>>) { let (new_c, response) = c.recv(); println!("{}", response); }`
[13:02:51] <munksgaard> (the recv method returns both a value and the new (transmuted) channel)
[13:03:03] <munksgaard> And that's essentially what we want to avoid.
[13:03:19] *** Quits: ctennis (ctennis@moz-vcpg3c.in.comcast.net) (Quit: Leaving...)
[13:03:48] <munksgaard> Additionally, the user can drop channels explicitly throught c.drop(), which is also undesirable
[13:04:00] <munksgaard> Does that make sense?
[13:04:22] <Manishearth> So basically we want linear types, but with a backdoor so that certain select functions (eg close()) can be called on them
[13:04:37] *** Quits: ^BR (br@moz-egk.dm6.194.78.IP) (Connection closed)
[13:04:46] <Manishearth> (Similarly, send() downgrades the channel, so internally it doesn't follow the regular linear types logic)
[13:04:58] <munksgaard> Well, that'd still be a linear type, 'cus we can only call close on Chans that we are done transmitting over
[13:05:01] <munksgaard> I guess
[13:05:24] *** Joins: ^BR (br@moz-egk.dm6.194.78.IP)
[13:06:28] <Manishearth> munksgaard: yeah, but internally send() downgrades, right?
[13:06:35] <Manishearth> send() consumes type A and returns Type B
[13:06:40] <munksgaard> Manishearth: Correct
[13:06:49] <Manishearth> (and B itself might be an Epsified chan)
[13:06:56] <munksgaard> Yup
[13:07:26] <frewsxcv> does anyone know if it's possible to insert macro variables into comments?
[13:07:48] *** Quits: poorman (poorman@moz-7p5b2o.res.rr.com) (Quit: )
[13:08:12] *** Joins: kmcguire_ (kmcguire@moz-pg1gb9.biz.rr.com)
[13:09:32] <Manishearth> frewsxcv: commebts become comments pre-expansion, so no
[13:09:36] *** Joins: poorman (poorman@moz-7p5b2o.res.rr.com)
[13:09:57] <Manishearth> though ... syntax extensions can generate tts, right? /me checks
[13:10:28] *** Joins: arielb1 (Mibbit@moz-cmi.jfj.114.192.IP)
[13:10:39] <Manishearth> nope, not exactly
[13:11:02] *** Quits: kmcguire (kmcguire@moz-pg1gb9.biz.rr.com) (Ping timeout: 121 seconds)
[13:11:08] <frewsxcv> for example https://github.com/rust-lang/rust/pull/23271#discussion_r26190420
[13:14:57] <Manishearth> eddyb: so, to summarize, we want to avoid implicit drop except where we explicitly allow it
[13:15:09] *** Joins: ctennis (ctennis@moz-su6.e72.137.99.IP)
[13:20:33] <Manishearth> well, drops and moves 
[13:23:43] *** Joins: marsel (user@moz-a2k.end.162.188.IP)
[13:28:59] <eddyb> sorry for the unexpected afk - and thanks for the writeup
[13:29:06] <munksgaard> eddyb: No worries
[13:29:42] * Manishearth ties a keyboard to eddyb's forehead
[13:30:34] <eddyb> bstrie, nmatsakis: I have pondered about completely removing the ::<T> style type parameters, but it can only be done for functions when something in the signature contains T
[13:31:04] <Manishearth> with ascription I presume
[13:32:48] *** Joins: pnkfelix (pnkfelix@moz-6v5.3nd.202.89.IP)
[13:32:48] *** ChanServ sets mode: +o pnkfelix
[13:33:23] <eddyb> bstrie, nmatsakis: *however*, if we were to merge type and value parameters into one list, TypeId::of(T) and x.to(String) would work. if they appear in value types in the signature, they can be considered optional, so both 
[13:33:51] <eddyb> "5".parse(): Option(i32) and "5".parse(i32) would work
[13:34:09] <nmatsakis> eddyb: types follow a different grammar for expressions
[13:34:14] <nmatsakis> it'd be pretty hard to parse that sort of thing
[13:34:19] <nmatsakis> I guess you could use `<`
[13:34:20] <nmatsakis> i.e.,
[13:34:24] <eddyb> yes, that's one of the most annoying parts
[13:34:28] <Manishearth> eddyb: ewwwwww
[13:34:29] <nmatsakis> "5".parse(<&T>)
[13:34:36] <Manishearth> eddyb: x.to(:String)
[13:34:39] <nmatsakis> anyway it's way too late to consider such a change, even if I were in favor 
[13:34:39] <Manishearth> might be better
[13:34:56] <nmatsakis> which I'm not sure that I am -- at least, a model which intermingles types/exprs feels quite different
[13:35:03] <eddyb> Manishearth: heh, quoting
[13:35:24] <Manishearth> eddyb: foo.func(:ty_param1, :ty_param2, expr_arg1, expr_arg2, ...)
[13:35:27] <Manishearth> how about that?
[13:35:41] <eddyb> nmatsakis: I'm trying to come up with a nextgen design that we might experiment with in the future
[13:36:03] <Manishearth> eddyb: also, that model breaks with lifetimes
[13:36:11] <eddyb> not 1.0 material
[13:36:30] <Manishearth> hard to parse
[13:36:46] <eddyb> Manishearth: how many times have you had to pass a lifetime parameter to a function?
[13:37:29] <Manishearth> eddyb: good point
[13:37:33] <Manishearth> eddyb: but I might have to?
[13:37:42] <Manishearth> eddyb: basically, does ::<'a> work now?
[13:37:49] <eddyb> nmatsakis: a few hours ago I (think) I managed to distill a part of our type system into an ECS
[13:37:56] <eddyb> Manishearth: not for methods AFAIK
[13:37:58] <Manishearth> because if it does, and if you're trying to kill ::<>, you need a replacement for it
[13:38:01] <Manishearth> eddyb: ah then it's fine
[13:38:09] *** Joins: kmcguire__ (kmcguire@moz-pg1gb9.biz.rr.com)
[13:38:17] <Manishearth> eddyb: but I'd still like to use colons to distinguish types from values
[13:38:21] <eddyb> "have to" implies inference failed or it's unused
[13:38:29] <eddyb> Manishearth: it's a neat trick, I'll give you that
[13:38:30] <Manishearth> yeah
[13:38:39] <kimundi> playbot: fn foo<'a>() -> &'a str { "test" } foo::<'static>()
[13:38:40] -playbot- <anon>:14:50: 14:57 error: too many lifetime parameters provided: expected 0 parameter(s), found 1 parameter(s) [E0088]
[13:38:40] -playbot- <anon>:14         fn foo<'a>() -> &'a str { "test" } foo::<'static>()
[13:38:40] -playbot- output truncated; full output at: http://bit.ly/19bR6IR
[13:38:42] <bjz> Manishearth: I have the idea of mixing static and runtime parameters in the same list
[13:38:47] <eddyb> wait wat
[13:38:49] <bjz> s/have/hate
[13:39:00] <eddyb> kimundi: that's crazy
[13:39:03] <kimundi> lol
[13:39:05] <kimundi> yeah
[13:39:16] <Manishearth> bjz: I'm ambivalent about it, but sicne eddyb seems to want to do it, I'm suggesting what's IMO a better syntax
[13:39:19] <kimundi> playbot: fn xyz<'a>() -> &'a str { "test" } xyz::<'static>()
[13:39:20] -playbot- <anon>:14:50: 14:57 error: too many lifetime parameters provided: expected 0 parameter(s), found 1 parameter(s) [E0088]
[13:39:20] -playbot- <anon>:14         fn xyz<'a>() -> &'a str { "test" } xyz::<'static>()
[13:39:20] -playbot- output truncated; full output at: http://bit.ly/1E5mxw4
[13:39:27] *** Joins: dudel (dud@moz-55rvi2.dclient.hispeed.ch)
[13:39:32] <Manishearth> huh
[13:39:50] <eddyb> kimundi: that's the same code
[13:40:18] <kimundi> eddyb: Sure, just wanted to test the off-chance that it is something in the playpen template that screws it up
[13:40:23] <eddyb> heh
[13:40:33] <eddyb> (I figured)
[13:41:02] *** Quits: kmcguire_ (kmcguire@moz-pg1gb9.biz.rr.com) (Ping timeout: 121 seconds)
[13:41:06] <Manishearth> eddyb: anyway, thoughts on the pseudo-linear-types requirements?
[13:42:57] <eddyb> Manishearth: sorry, tried to get this random idea out of the way first
[13:45:33] <eddyb> munksgaard, Manishearth: you say implicit drop, but that's incorrect linear type terminology
[13:46:29] <eddyb> munksgaard, Manishearth: also, consuming (the typical example is File::close - if File were linear) is not a "back door" but how linear types are supposed to be used
[13:47:00] <eddyb> now... there's a hard part
[13:47:29] <eddyb> what happens in .close()?
[13:47:40] <munksgaard> eddyb: Absolutely nothing atm
[13:47:54] <Manishearth> eddyb: exactly, we want close to be able to be defined without breaking things
[13:48:06] <eddyb> is there a Drop impl on Chan?
[13:48:14] <Manishearth> *eventually* you need to drop() it, but we want that to happen in an environment we control
[13:48:16] <munksgaard> eddyb: impl Chan<Eps> {pub fn close(self) {// Consume `c`}}
[13:48:16] <eddyb> what kind of cleanup do you need to do
[13:48:17] <Manishearth> we can put one
[13:48:23] <munksgaard> Is what it looks like at the moment
[13:48:49] *** Joins: Rym_ (y@moz-232.ad4.144.109.IP)
[13:48:49] <munksgaard> eddyb: No, there is no drop impl on Chan, https://github.com/rust-lang/rust/issues/21135
[13:49:00] <Manishearth> nmatsakis: can you giuve the buildslaves a boot?
[13:49:07] <eddyb> technically you could make everything *but* Chan<Eps> linear
[13:49:21] <eddyb> though that might be too confusing in practice
[13:49:59] <Manishearth> eddyb: it would be nice if the death of Chan<Eps> was explicit, too
[13:50:03] <eddyb> munksgaard: not *now* but later on
[13:50:07] <eddyb> Manishearth: okay, that's fine
[13:50:09] <Manishearth> so making that linear is okay
[13:50:15] <Manishearth> if you need that
[13:50:33] <munksgaard> eddyb: Basically everything is affine now, we'd like linearity
[13:50:50] <eddyb> munksgaard: yeah, but... it really matters what close is supposed to do
[13:51:16] <eddyb> and what you want to happen if a panic occurs before calling .close()
[13:51:19] <munksgaard> eddyb: There is no cleanup. It's merely supposed to drop (in the original Rust sense) the channel and the Sender/Receiver it holds
[13:51:38] <eddyb> munksgaard: so only its contents impl Drop
[13:51:43] <eddyb> okay, that's workable
[13:51:46] <Manishearth> eddyb: panics are okay
[13:51:52] <eddyb> perfect
[13:51:55] <munksgaard> eddyb: The type system guarantees (within reasonable limits) that there cannot occur a panic before calling close
[13:52:03] <munksgaard> Or at least that's the idea
[13:52:09] <Manishearth> eddyb: assume a panicless world, now give us compile time linear types ;p
[13:52:13] <munksgaard> yay
[13:52:25] <eddyb> Manishearth: well, the thing is...
[13:52:25] <Manishearth> panicless, and Chan<Eps> need not be linear if you need that
[13:52:44] <Manishearth> and of course send() and close() should have a way to work around this (unsafe/annotations/etc)
[13:52:47] <eddyb> you can do a lot more without modifying the base compiler if you don't need to impl Drop on a linear type
[13:52:55] <eddyb> Manishearth: privacy
[13:53:20] *** Quits: Rym_ (y@moz-232.ad4.144.109.IP) (Ping timeout: 121 seconds)
[13:53:29] <Manishearth> expound pls
[13:54:07] <eddyb> impl Chan<Eps> {pub fn close(self) { let Chan { rx, tx, marker} = self; marker.consume(); drop(rx); drop(tx); }}
[13:54:25] <Manishearth> oh, nice
[13:54:34] <Manishearth> wfm
[13:54:48] <Manishearth> eddyb: and how do we bake this into a plugin?
[13:54:52] <eddyb> if you had read about that design, you would've known that's how it was supposed to work from day 0
[13:55:00] <eddyb> Manishearth: I had a bit of time to think about that
[13:55:13] <eddyb> in functions that hold such a type, yes
[13:55:30] <Manishearth> eddyb: what's wrong with impling drops, incedentally?
[13:55:43] <Manishearth> *incidentally
[13:55:51] <eddyb> Manishearth: you're not allowed to destructure like that
[13:56:01] <Manishearth> eddyb: in a drop?
[13:56:08] <eddyb> no, in close
[13:56:14] <eddyb> (if you also impl Drop)
[13:56:19] <Manishearth> why not?
[13:56:27] <eddyb> that's just how that works
[13:56:34] <Manishearth> your design I guess?
[13:56:37] <eddyb> no
[13:56:45] <Manishearth> how what works?
[13:57:02] *** Joins: Sindriava (textual@moz-5h093g.fit.cvut.cz)
[13:57:14] <eddyb> playbot: struct Foo { x: i32 } impl Drop for Foo { fn drop(&mut self) {} } let Foo { x } = Foo { x: 0 }; x
[13:57:16] -playbot- 0
[13:57:20] <eddyb> uhm
[13:57:26] <eddyb> wat
[13:57:48] <eddyb> oh, right!
[13:57:50] <Manishearth> why wouldn't that work? o.O
[13:58:08] <eddyb> playbot: struct Foo { x: Vec<i32> } impl Drop for Foo { fn drop(&mut self) {} } let Foo { x } = Foo { x: vec![0] }; x
[13:58:09] <Manishearth> I think eventually we would want a Drop impl. What I meant when I said panicless was that the types need not stay linear in the case of panics
[13:58:10] -playbot- <anon>:14:84: 14:93 error: cannot move out of type `main::Foo`, which defines the `Drop` trait
[13:58:10] -playbot- <anon>:14         struct Foo { x: Vec<i32> } impl Drop for Foo { fn drop(&mut self) {} } let Foo { x } = Foo { x: vec![0] }; x
[13:58:10] -playbot- output truncated; full output at: http://bit.ly/19bUgwt
[13:58:12] <eddyb> here we go
[13:58:26] <Manishearth> Drop takes &mut self now?
[13:58:27] <Manishearth> wut
[13:58:28] <eddyb> I would allow a Drop impl on linear types for manually enforcing exception safety
[13:58:31] <Manishearth> oh
[13:58:46] <eddyb> but it needs special compiler support
[13:59:02] <eddyb> to allow destructuring even when Drop is implemented, at least for linear types
[13:59:21] <eddyb> Manishearth, munksgaard: so, you can implement borrowck as a plugin
[13:59:26] <Manishearth> er
[13:59:35] <Manishearth> that sounds hard :
[13:59:38] <eddyb> you could copy its code and run it from a lint plugin
[13:59:48] <Manishearth> (also, basically what I was doing in humpty_dumpty, except from scratch)
[13:59:53] <eddyb> well... maybe. not sure how well they are integrated
[13:59:54] <Manishearth> eddyb: any specific visitor that does this?
[14:00:06] <eddyb> can you stop it with your visitors :P?
[14:00:21] <Manishearth> what, isn't borrowck one big visitor?
[14:00:29] * Manishearth checks
[14:00:58] <munksgaard> eddyb: That's sort of what we've been doing :)
[14:01:03] <Manishearth> ExprUseVisitor
[14:01:07] <eddyb> assuming you have access to the tcx and you're past typeck match checking, you should be able to just run borrowck
[14:01:17] <eddyb> Manishearth: borrowck is like 6 different things
[14:01:20] <Manishearth> that's the first think I told munksgaard to look at, and it turned out to be quite complicated
[14:01:23] <Manishearth> eddyb: ah
[14:01:32] <Manishearth> eddyb: "run borrowck", as in?
[14:01:33] <eddyb> not sure where you're looking
[14:01:39] <eddyb> Manishearth: as in, invoke it on the crate
[14:01:43] <eddyb> there's an entry point
[14:01:47] <Manishearth> yeah, what is it?
[14:02:05] <eddyb> where a main function would be
[14:02:30] <Manishearth> check_crate?
[14:02:47] <Manishearth> ah, borrowck_fn
[14:02:49] <eddyb> no
[14:02:59] <eddyb> borrowck_fn is not an entry point for the entire crate
[14:03:13] <Manishearth> check_crate just gives some stats
[14:03:31] <eddyb> Manishearth pls
[14:03:43] <eddyb> Manishearth: https://github.com/rust-lang/rust/blob/master/src/librustc_borrowck/borrowck/mod.rs#L77
[14:04:03] <eddyb> those stats are useless when I last checked
[14:04:18] <eddyb> (nothing increases the numbers)
[14:04:23] <Manishearth> eddyb: hah
[14:04:34] <eddyb> Manishearth: forget the fact that it's a visitor
[14:04:37] <Manishearth> but visit::walk_crate is also useless, no?
[14:04:43] <eddyb> no?
[14:04:47] <Manishearth> all it does is modify bccx
[14:05:03] <eddyb> borrowck has a single possible side effect
[14:05:08] <eddyb> and that's erroring
[14:05:08] <Manishearth> or does it also modify tcx?
[14:05:18] <eddyb> it doesn't need to modify tcx
[14:05:27] <eddyb> borrowck is a glorified lint pass
[14:05:34] <eddyb> (and now you know)
[14:05:36] <Manishearth> yes, but we'd need to also modify the borrowck code for that, right?
[14:05:41] <Manishearth> Yeah, I got that
[14:05:51] <eddyb> the important thing is that you can invoke borrowck for fun
[14:05:52] <arielb1> eddyb: soon it will manage dynamic drop flags
[14:05:55] <Manishearth> I thought we'd be able to just call  the entry point
[14:06:08] <eddyb> Manishearth: check_crate is the entry point
[14:06:39] <eddyb> so, if borrowck is not special, and you can run it at lint time (ignoring what arielb1 said :P)
[14:06:47] <Manishearth> oh you were making that point
[14:06:49] <Manishearth> that I know
[14:07:04] <Manishearth> I'm wondering how to modify it to create linear types
[14:07:05] <eddyb> an addition to it can be prototyped from a plugin that runs at lint time
[14:07:20] <eddyb> Manishearth: pnkfelix has some code for static drops
[14:07:46] <Manishearth> eddyb: also, how do you suggest we mark linear types? #[linear]? PhantomLinear?
[14:07:47] <eddyb> the thing is, though, the algorithm is not incredibly hard
[14:08:13] <arrrrrrr1> eddyb: https://github.com/mahkoh/rfcs/blob/move/text/0000-move.md#detailed-design
[14:08:18] <pnkfelix> ?Affine
[14:08:20] <arrrrrrr1> I'm sure you have some insightful comments here
[14:08:45] <eddyb> Manishearth: the big problem is generics
[14:09:08] <eddyb> Manishearth: you have to assume no generic type parameters are linear, otherwise a lot of code just won't compile
[14:09:23] <Manishearth> eddyb: ah
[14:09:45] <Manishearth> eddyb: we can write a lint that checks for many cases that would lead to this
[14:09:46] *** sunfish-away is now known as sunfish
[14:09:54] <Manishearth> but yeah
[14:09:58] <eddyb> Manishearth: but if you do that, nothing stops anyone from using linear types with such generics
[14:10:24] <eddyb> Manishearth: you have to assume a default T: Affine bound (just like Sized is implied in a lot of places)
[14:10:29] <Manishearth> yeah
[14:10:37] <eddyb> hmm
[14:10:44] <pnkfelix> and thus `foo<T: ?Affine>(t: T) { ... }`
[14:10:46] <eddyb> Manishearth: I guess you could check instantiations of generic type params
[14:11:02] <eddyb> pnkfelix: I so wish we'd come up with a good implied bounds system
[14:11:06] <Manishearth> eddyb: exactly
[14:11:27] <munksgaard> So we're back at visitors?
[14:11:37] <Manishearth> munksgaard: ...sort of :p
[14:11:40] <eddyb> hmm
[14:11:54] <Manishearth> munksgaard: I can fix the generics issue. Or patch it up hackishly
[14:11:57] <munksgaard> I had my hopes up for make_drop_glue :)
[14:11:58] <eddyb> Manishearth: not sure how exhaustive you can get
[14:12:14] <Manishearth> munksgaard: this is pluginable, make_drop_glue isn't
[14:12:17] <Manishearth> eddyb: sure
[14:12:19] <eddyb> you can assume types are fine and functions/methods are bad
[14:12:22] <munksgaard> Manishearth: Good points.
[14:12:27] <munksgaard> -s
[14:12:29] <munksgaard> ...
[14:12:29] <eddyb> so... ExprPath and ExprMethodCall?
[14:12:43] <munksgaard> eddyb: https://github.com/Manishearth/humpty_dumpty
[14:12:45] <eddyb> actually, those are the only things that do ever take type params, not that I think of it
[14:12:50] <eddyb> *now that
[14:13:46] <eddyb> pnkfelix: Sized was kind of an obvious annotation disaster - except now we're at a mid-point when ?Sized is the default for traits
[14:13:53] <eddyb> *where
[14:14:09] <arielb1> eddyb: won't the bound be :?Drop
[14:14:14] <Manishearth> munksgaard: I can still try to poke at make_drop_glue, but I don't see an easy way to build in a circumvention method
[14:14:15] <eddyb> arielb1: nothing to do with Drop
[14:14:21] <pnkfelix> eddyb: disaster is in eye of beholder
[14:14:34] <eddyb> pnkfelix: quite true
[14:15:03] <eddyb> pnkfelix: there is a way to deduce Sized bounds, not sure if nmatsakis ever found reasons not to do it
[14:15:08] <pnkfelix> eddyb: e.g. I'm way more annoyed that I cannot make a type item for the trait `FnMut(Something<X>, SomethingElse<X>) -> X`
[14:15:17] *** Joins: AndChat|35156 (AndChat3515@moz-cdr.65n.117.134.IP)
[14:15:31] <pnkfelix> eddyb: so that I could then just write F: FnShorthand<X> for the bound
[14:15:50] <pnkfelix> eddyb: I think nmatsakis is still playing with ideas in that space
[14:16:18] <eddyb> pnkfelix: the sad thing is that it's backwards incompatible
[14:16:43] <eddyb> pnkfelix: a good compromise might be an opt-in "enhancement of defaults"
[14:16:44] <Manishearth> munksgaard: we can still try to go at this from humpty_dumpty though, your choice 
[14:16:59] <eddyb> pnkfelix: which would break a small number of functions
[14:17:00] <Manishearth> it just will probably get rather complicated
[14:17:00] *** AndChat|35156 is now known as Gankro_
[14:17:02] <pnkfelix> eddyb: I find it hard to believe that all designs for implied bounds are backwards-incompat
[14:17:15] <Manishearth> but with humpty we can disallow problem situations anyway
[14:17:28] <eddyb> pnkfelix: well, the best one I know involves never writing ?Sized
[14:17:39] <eddyb> (subjective "best", I guess)
[14:18:38] <munksgaard> Manishearth: I'm okay with moving on with humpty
[14:18:40] <eddyb> pnkfelix: T: Sized only if T is used in the function body in a way that requires it to be sized, and that is not reflected in the signature
[14:19:07] <Manishearth> munksgaard: sure. I might poke at borrowck if I get time
[14:19:15] <eddyb> pnkfelix: e.g. `box uninitialized()`
[14:19:17] <Manishearth> I generally find time to read code, less so to write it
[14:19:23] <pnkfelix> eddyb: well, if you want global type inference, there's a number of lovely languages availalbe that offer it
[14:19:33] <eddyb> pnkfelix: this does not require global type inference :D
[14:19:48] <pnkfelix> eddyb: my point is that I like forcing things to be in the signature
[14:19:56] <pnkfelix> eddyb: and that we do not try to extract them from the bodies
[14:19:56] <eddyb> they already are :D
[14:20:04] <eddyb> pnkfelix: that's the point I'm making
[14:20:32] <eddyb> if the signature doesn't make it clear T must be Sized *and yet* the body uses T like it is Sized, then you'd have to annotate it
[14:20:36] <pnkfelix> eddyb: okay we clearly are not communicating, and I do not have the attention span to attempt to understand you right now.
[14:21:03] <eddyb> but that's the only case ever when you'd have to actually write Sized somewhere
[14:21:36] <eddyb> pnkfelix: sorry, my original phrasing was a bit vague
[14:21:49] <pnkfelix> eddyb: Its okay, I just don't have time to be hanging out in here right now.
[14:21:58] <Manishearth> munksgaard: I guess for humpty then we should add some form of branch protection (basically, make sure X is dropped in every branch), and then disallow returns and breaks and continues in blocks containing protected variables (for now at least), we should have something usable
[14:22:08] <eddyb> pnkfelix: right. I have a lot of things to do as well :(
[14:22:32] <Manishearth> munksgaard: anyway, whatever is more convenient for you
[14:22:36] <eddyb> Manishearth: that's the static drop analysis stuff that pnkfelix has code for
[14:22:56] * pnkfelix wonders when he will get around to rebasing that branch
[14:23:05] <Manishearth> pnkfelix: link?
[14:23:09] <eddyb> pnkfelix: why not make Manishearth do it? he *needs* it :P
[14:23:14] <Manishearth> yeah
[14:23:16] <Manishearth> I don't mind
[14:23:37] <Manishearth> though I'm swamped, only code I'm getting time for is rollups and that's like 1 LOC per rollup
[14:23:55] <eddyb> munksgaard, then?
[14:25:11] <eddyb> arrrrrrr1: do you know my view on &move T, Move<T, S> and Box<T, S>?
[14:25:25] <arrrrrrr1> nope
[14:25:36] <eddyb> slices are not special btw
[14:25:37] <Manishearth> pnkfelix: what does your static drop analysis do?
[14:25:41] <pnkfelix> Manishearth: its probably in here: https://github.com/pnkfelix/rust/tree/fsk-type-fragments-for-needsdrop-2
[14:25:42] <eddyb> &[T] is a reference type
[14:25:49] *** Joins: japaric (japaric@moz-663.3tp.232.190.IP)
[14:25:56] <eddyb> arrrrrrr1: treating them like they are separate only creates confusion, I feel
[14:26:02] <pnkfelix> Manishearth: (there's a collection of branches with variants of the name `needs-drop` or `needsdrop` in them)
[14:26:07] <munksgaard> eddyb: I'll work some more on humpty, perhaps see if I can find the old expr_use_visitor I made
[14:26:11] <arrrrrrr1> eddyb: you're right. I put it there because I wanted to have the "sublicing implies dropping the rest" explicit
[14:26:19] <Manishearth> oct 2014? uh oh
[14:26:40] <pnkfelix> Manishearth: no wait, that can't be the right branch
[14:26:46] <Manishearth> that merged
[14:26:47] <pnkfelix> Manishearth: yeah, I'm saying, these are *super old* branches
[14:26:59] <eddyb> arrrrrrr1: slicing is a library construct, though
[14:27:06] <arrrrrrr1> I agree
[14:27:11] <pnkfelix> Manishearth: that were prototypes that were precursors to the Static Drop RFC: https://github.com/rust-lang/rfcs/pull/210
[14:27:43] <pnkfelix> Manishearth: ah yeah, this is more likely to be the right branch: https://github.com/pnkfelix/rust/commits/fsk-needs-drop-analysis-rebased
[14:27:47] <pnkfelix> Manishearth: but its even older
[14:28:35] <pnkfelix> Manishearth: anyway, its not something one should literally rebase at this point
[14:28:38] <Manishearth> yeah
[14:28:39] *** Quits: japaric_ (japaric@moz-t17.t9l.232.190.IP) (Ping timeout: 121 seconds)
[14:28:44] <eddyb> nmatsakis: I recall asking, forgive me if I did get a reply in the past, but why don't we have by-value self working in trait objects? what part of object safety requires it, other than not having an implementation of &move-like virtual calls? (which I thought we had)
[14:28:51] <pnkfelix> Manishearth: but instead, I should cherry-pick or just outright transcribe the relevant diffs
[14:28:59] <Manishearth> I think for now the options of poking humpty or borrowck are more lucrative
[14:29:04] <Manishearth> but I'll have a look
[14:29:39] *** Joins: adu (ajr@moz-0foa9t.md.comcast.net)
[14:30:18] <eddyb> nmatsakis: oh, I always forget this! it's Box being special-cased, isn't it. duuh. but should a &move T proposal include by-value method calls on &move Trait, without explicit &move self in the method signatures themselves?
[14:30:29] <nmatsakis> eddyb: there was an early impl but it was not done properly and I removed it. I don't think much is blocking it beyond not having done it.
[14:31:20] <nmatsakis> I am still not a big fan of &move, to be claer, but I think any proposal would naturally want to discuss how it interacts with method calls?
[14:31:56] <eddyb> nmatsakis: oh, I thought the fact that it required Box to be special-cased made it harder to justify keeping it around for now
[14:32:06] <eddyb> arrrrrrr1: "Note that Box is a special compiler built-in type for this reason." aaaand you lost
[14:32:17] <arrrrrrr1> how so?
[14:32:27] <arrrrrrr1> maybe not explicitly for this reason
[14:32:35] <arrrrrrr1> but it wouldn't work if it were not built-in
[14:32:41] <nmatsakis> I don't think it's really tied to Box anymore than any other "DerefMove "
[14:32:54] <arrrrrrr1> maybe "must be a built-in type for this reason"
[14:32:54] <nmatsakis> the old impl was kind of hard-coded around Box though (but in a very yucky way)
[14:32:57] <eddyb> if you come up with a &move T design and it cannot handle DerefMove and a library-only Box impl, then it's suboptimal
[14:33:22] <eddyb> which means it will *need* to be *replaced* and as such, it won't be accepted as anything more than a temporary design
[14:34:07] <eddyb> the irony is that my solution to this, Move<T, S> turned out to be Box<T, A>, or at least interchangeable with it
[14:34:09] <arrrrrrr1> eddyb: oh, you can have another one. but then your &move T is a fat pointer for all T and your &move [T] is a 40 bytes pointer
[14:34:12] *** Quits: sinclair (chatzilla@moz-o36q4q.xnet.co.nz) (Connection closed)
[14:34:19] <arrrrrrr1> that one could handle it
[14:34:39] <eddyb> ... what?
[14:35:20] <arrrrrrr1> to get a &move [T] from a &move Vec<T> you have to carry the information to drop the Vec<T> and the container that contains the Vec<T> in your slice with you
[14:35:31] <Manishearth> > With move semantics we can pass an arbitrary type to a function and consume the contained object:
[14:35:37] <eddyb> arrrrrrr1: yeah, well, this is why &move T is not a good solution
[14:35:53] <Manishearth> arrrrrrr1: how would you define the destructor (deallocator, whatever) for this?
[14:35:56] <arrrrrrr1> eddyb: it's fine if you can define your own Box-like containers in the library
[14:36:29] <eddyb> anyways, I'm not sure what to do with my design which is stuck on "we need to make Box special-cased to move Box into the library"
[14:37:18] <arrrrrrr1> Manishearth: the destructor is in the vtable. same for Box<Any>
[14:37:22] <kimundi> eddyb: hah, that sounds like an issue indeed ;)
[14:37:23] <eddyb> unless I compromise...
[14:37:35] <Manishearth> arrrrrrr1: ah
[14:37:40] <eddyb> Box<T, A> wraps Move<T, MoveAllocator<A>>
[14:37:53] *** Joins: Tobba (Tobba@moz-o13d22.bredband.telia.com)
[14:37:56] <Manishearth> arrrrrrr1: oh wait this is the motivation, not the design
[14:38:10] <eddyb> hmm
[14:38:13] <eddyb> or *is* that type?
[14:38:29] <eddyb> I mean, type Box<T> = Move<T, Heap>; might not be that bad
[14:38:41] <Manishearth> yeah
[14:38:49] *** Joins: Astrum|Lap (Astrum|Lap@moz-e4c.9jn.170.50.IP)
[14:38:52] <eddyb> (we are completely ignoring the error messages at this point :P)
[14:39:00] <kimundi> So, is the issue with &move T that you need to keep the original location around while the &move reference exist, but also support it being unitialized because you moved away through the &move somewhere further down the stack?
[14:39:20] <eddyb> kimundi: you need to drag around allocation metadata (and a type)
[14:39:37] <eddyb> kimundi: in the case of Box, it's precisely the allocator (the default one being zero-sized)
[14:39:50] <Manishearth> arrrrrrr1: > Assuming non-zeroing drop, the compiler will generate the following pseudo code:
[14:40:00] <Manishearth> isn't that example doable without a drop flag?
[14:40:04] <eddyb> kimundi: oh, and, it has to be freely movable
[14:40:18] <Manishearth> if flag {g(&move x)} else {drop;}
[14:40:20] <kimundi> eddyb: would it be possible to make creation of a &move _require_ a move out of it further down the stack?
[14:40:22] <arrrrrrr1> Manishearth: yes, everything happens implicitly there. the drop flags are part of the type
[14:40:31] <Manishearth> arrrrrrr1: ah okay
[14:40:38] <Manishearth> arrrrrrr1: so there's no runtime difference
[14:40:50] <eddyb> kimundi: the problem lies in the signature of DerefMove
[14:40:55] <arrrrrrr1> Manishearth: non-zeroing drops should be faster
[14:40:56] <Manishearth> you're just representing compiletime flow neater
[14:41:10] <kimundi> eddyb: or would that be an issue because unwinding could always make the stack unwind before having moved away
[14:41:26] <Manishearth> arrrrrrr1: No, I'm asking if there actually is a hidden `x_needs_drop` generated and used at runtime?
[14:41:33] <eddyb> arrrrrrr1: so that RFC represents the &move T that we knew was insufficient last year
[14:41:41] <eddyb> arrrrrrr1: it's good... historical material
[14:41:48] <arrrrrrr1> eddyb: thanks
[14:41:54] <eddyb> (sorry)
[14:42:09] <arrrrrrr1> I didn't see a &move RFC so I just wrote my own
[14:42:27] <eddyb> arrrrrrr1: oh we are so terrible at documenting "failed ideas"
[14:42:38] *** Quits: oldornew (oldornew@moz-369lu1.dynamic.simnet.is) (Quit: Leaving)
[14:42:52] <arrrrrrr1> A previous version of the RFC had fat pointers with vtables all over the place
[14:42:58] *** Joins: Rym_ (y@moz-232.ad4.144.109.IP)
[14:43:02] <eddyb> that's an interesting way to do it
[14:43:05] <arrrrrrr1> that would allow Vec<T> -> &move [T]
[14:43:15] <eddyb> Move<T, VirtualMoveSource>
[14:43:40] <eddyb> arrrrrrr1: where do you stash the capacity, though?
[14:44:06] <arrrrrrr1> eddyb: there is a pointer to the Vec in the &move [T]
[14:44:16] <eddyb> arrrrrrr1: the only viable (yet possibly unergonomical) solution I found involves a type parameter
[14:44:22] <eddyb> arrrrrrr1: ah that doesn't even work well
[14:44:25] <arrrrrrr1> &move [T] contains a &move U where U is the source of the slice
[14:44:39] <eddyb> it implies a Vec that sits still
[14:44:42] <kimundi> &move T = { *virtual_source, ?Sized T } ?
[14:45:31] <kimundi> eddyb: sitting still seems reasonable, seeing as thats the rquirement references have in general
[14:45:50] <munksgaard> Has the rust wiki been removed?
[14:46:08] <eddyb> arrrrrrr1: my draft supports Vec's by-value IntoIterator impl in a way that works with "&move [T]"
[14:46:26] <eddyb> arrrrrrr1: I'm pretty sure it's a single IntoIterator impl that works with both
[14:47:23] <eddyb> kimundi: DerefMove consumes its input
[14:47:30] *** Quits: Rym_ (y@moz-232.ad4.144.109.IP) (Ping timeout: 121 seconds)
[14:47:48] <eddyb> it can't just have the same lifetime - the original is gone
[14:47:49] <arrrrrrr1> eddyb: what's the problem with having library defined types that you can move out of?
[14:47:57] *** Quits: Gankro_ (AndChat3515@moz-cdr.65n.117.134.IP) (A TLS packet with unexpected length was received.)
[14:48:07] <eddyb> arrrrrrr1: try to design a system to allow doing that
[14:48:33] <arrrrrrr1> sure, unsafe trait DropContainer for X { fn drop(&mut self, moved_out: bool); } 
[14:48:36] <arrrrrrr1> there you go
[14:48:51] <eddyb> wait... what?
[14:48:54] <kimundi> eddyb: so, its a design constraint that &move needs to be supported by starting with a by-value move?
[14:49:00] <eddyb> kimundi: yes
[14:49:10] <eddyb> the & is really improper
[14:49:18] <kimundi> okay, that clears it up a bit
[14:49:27] <arrrrrrr1> eddyb: containers get a custom Drop. if you've moved out of the container when the container is dropped, then the second argument is true, otherwise it is false and you know that you have to drop the contained object.
[14:49:28] <eddyb> now I also got to read what happened this morning with reem
[14:49:42] <eddyb> arrrrrrr1: but how do you drag that along?
[14:49:50] *** Joins: bytewise (bytewise@moz-mecf2n.unity-media.net)
[14:50:03] <arrrrrrr1> what do you mean?
[14:50:07] <eddyb> arrrrrrr1: that, again, implies that your Vec or whatever sits still on the stack waiting to be collected
[14:50:16] <arrrrrrr1> yes, I don't see a problem with that
[14:50:26] <eddyb> that makes the whole thing largely useless
[14:50:31] <kimundi> why?
[14:50:33] <arrrrrrr1> I don't see why
[14:50:53] <kimundi> I mean, I can see both variants being potentially useful
[14:50:59] <eddyb> you can't write a function that takes a Vec<T> and returns vec::Items<T> or whatever the by-value iterator is called
[14:51:17] <kimundi> But you can write one that takes a &move Vec<T>
[14:51:22] <arrrrrrr1>  ^
[14:51:27] <eddyb> kimundi: except you can't
[14:51:36] <eddyb> well...
[14:51:52] <eddyb> kimundi: they both do the same thing, really
[14:52:03] <eddyb> but you didn't let me finish :P
[14:52:06] <kimundi> then I don't see where the difference is :P
[14:52:38] <arrrrrrr1> you can &move Vec<T> -> &move [T] -> impl Items<T>
[14:52:38] <eddyb> and now make that same function work with &'a move [T] -> SameIteratorTypeAsBefore<'a, T>
[14:52:55] <eddyb> ugh this is all terrible to explain in IRC
[14:53:08] <arrrrrrr1> ah, wait
[14:53:13] <arrrrrrr1> you can't really
[14:53:25] <arrrrrrr1> not with a function that takes &move Vec<T>
[14:53:37] <eddyb> hmm, maybe I wasn't very clear
[14:54:34] *** Quits: arielb1 (Mibbit@moz-cmi.jfj.114.192.IP) (Quit: http://www.mibbit.com ajax IRC Client)
[14:54:36] <eddyb> using the same IntoIterator impl, write a function with takes no arguments and returns vec![1, 2, 3].into_iterator()
[14:55:10] <eddyb> and another function which takes xs: &move [T] (or something similar, in your design) and returns xs.into_iterator()
[14:55:13] <kimundi> that wouldn't work with my &'a move T
[14:55:21] <kimundi> the first one, that is
[14:56:06] <eddyb> https://gist.github.com/eddyb/82a442f0ef4d137a762e
[14:57:29] <eddyb> I'm not sure I had working associated types back then
[14:58:42] <eddyb> also, I assumed some excessive automatic T -> Move<T, S> - can probably get away with just regular coercions (if Move<T, _> is expected)
[15:00:45] <eddyb> great, I have no idea what this means anymore https://gist.github.com/eddyb/82a442f0ef4d137a762e#file-move-rs-L53-L54
[15:01:01] <eddyb> aaaah, "the value" is "foo"
[15:01:07] <eddyb> not "box foo"
[15:01:40] *** Quits: imperio (Mibbit@moz-psdrik.rev.sfr.net) (Quit: http://www.mibbit.com ajax IRC Client)
[15:03:35] *** Joins: Guest63 (textual@moz-m125j8.44.threembb.ie)
[15:04:14] *** Quits: Sindriava (textual@moz-5h093g.fit.cvut.cz) (Quit: My Mac has gone to sleep. ZZZzzz…)
[15:06:12] *** Joins: mib_a9smef (Mibbit@moz-juv.9o3.252.72.IP)
[15:07:07] <arrrrrrr1> eddyb: so why haven't you implemented it? 10 minutes. Go!
[15:07:54] <eddyb> arrrrrrr1: it's not actually that hard, especially since this is Box<T, A>, so it can reuse most of the compiler infrastructure...
[15:08:05] <eddyb> but I wanted a good design before I even bothered
[15:08:08] <arrrrrrr1> not that hard? then make it 5 minutes
[15:08:21] <eddyb> not that hard == not months, maybe weeks
[15:09:19] *** Quits: joneshf-laptop (joneshf@moz-l4h.b5s.208.98.IP) (Connection closed)
[15:16:09] <WindowsBunny> for me not hard means within a day given sufficient motivation
[15:18:39] <arrrrrrr1> eddyb: why not use Iterators for varargs?
[15:18:40] *** Joins: WindowsBunny1 (Peter@moz-gv8vtu.east.verizon.net)
[15:20:11] *** Quits: WindowsBunny (Peter@moz-gv8vtu.east.verizon.net) (Ping timeout: 121 seconds)
[15:20:25] <arrrrrrr1> I didn't see your varargs issue (could have at least mentioned the word function in the title) and wrote my own: https://github.com/rust-lang/rfcs/issues/960
[15:20:29] *** Quits: gleb (gleb@moz-3u1drv.rusanovka-net.kiev.ua) (Ping timeout: 121 seconds)
[15:20:40] <arrrrrrr1> you can see why I thought &move would be useful
[15:20:55] <arrrrrrr1> for fn(args: ..&move Any)
[15:21:08] <pnkfelix> arrrrrrr1: try searching for "arity", e.g. https://github.com/rust-lang/rfcs/issues/323
[15:21:42] <arrrrrrr1> I searched for variadic and varargs
[15:22:01] <pnkfelix> arrrrrrr1: I'm just letting you know where you can see some related RFC issues
[15:22:23] <Amaranth> arity is more of a maths and functional language term I think
[15:23:19] * pnkfelix adds "varargs" to title of umbrella issue accordingly
[15:23:19] <arrrrrrr1> I like the iterator based approach. It's quite similar to the way varargs already work in C, just safe
[15:23:44] <arrrrrrr1> (and with &move it's just as powerful)
[15:26:36] <eddyb> arrrrrrr1: &move Any cannot replace VG
[15:26:55] <arrrrrrr1> what is VG?
[15:27:02] <arrrrrrr1> ah, variable generics
[15:27:11] <arrrrrrr1> eddyb: no, it's not as powerful as C++ varargs
[15:27:17] <eddyb> also, what kind of polymorphic chymera iterators are you talking about?
[15:27:24] <eddyb> arrrrrrr1: those are called variadic templates
[15:27:31] <eddyb> varargs are the terrible C ones
[15:27:58] <eddyb> not only it's not as powerful, it can't be used to implement traits on tuples
[15:28:16] <eddyb> and you can only match on a fixed set of types... you might as well be using an enum
[15:28:17] <arrrrrrr1> no shit
[15:28:25] <arrrrrrr1> it's supposed to be varargs, not the second coming of christ
[15:29:18] <arrrrrrr1> eddyb: you could also forward the iterator to other functions so it's not a fixed set
[15:29:20] *** Joins: mystor (mystor@moz-va2.r78.15.130.IP)
[15:29:51] *** Quits: japaric (japaric@moz-663.3tp.232.190.IP) (Ping timeout: 121 seconds)
[15:30:51] *** Quits: Kxepal (Miranda@moz-eodict.pppoe.mtu-net.ru) (Ping timeout: 121 seconds)
[15:32:26] <eddyb> it's a fixed set after monomorphization
[15:32:33] *** Joins: Kxepal (Miranda@moz-i6vigq.pppoe.mtu-net.ru)
[15:32:51] <arrrrrrr1> the set cannot be determined at compile time
[15:32:59] <eddyb> arrrrrrr1: yes it can
[15:33:09] <arrrrrrr1> the user can pass a function that accepts Iterator<&move Any> together with the varargs
[15:33:11] <eddyb> you're generating TypeId's for it
[15:33:28] <eddyb> I can instrument the compiler to print how many of those it computed :P
[15:33:45] <eddyb> (if you're as generic as your arguments, then you could maybe make this work)
[15:34:02] <eddyb> I mean, if you want your thing to spend hours optimizing out millions of virtual calls :D
[15:34:38] <arrrrrrr1> that's just a matter of improving LLVM to the point where it compiles in O(1)
[15:34:59] <arrrrrrr1> and the output should run in O(1) too please
[15:36:13] *** Quits: zmack (zmack@moz-b26i0b.home.aster.pl) (Connection closed)
[15:36:34] *** Joins: zmack (zmack@moz-b26i0b.home.aster.pl)
[15:37:04] *** Quits: c0170 (c0170@moz-bb29a4.cambridge.arm.com) (Connection closed)
[15:37:09] *** Joins: Rym_ (y@moz-232.ad4.144.109.IP)
[15:37:18] *** Joins: japaric (japaric@moz-663.3tp.232.190.IP)
[15:41:41] *** Quits: Rym_ (y@moz-232.ad4.144.109.IP) (Ping timeout: 121 seconds)
[15:43:43] *** Joins: madmalik (uid13697@moz-lfin5p.brockwell.irccloud.com)
[15:47:21] <arrrrrrr1> maybe calling it &out instead of &move makes more sense
[15:47:56] *** Joins: erickt (erickt@moz-njt.vqi.14.76.IP)
[15:48:23] *** Quits: Jesin (Jesin@moz-q46lj1.fios.verizon.net) (Quit: Leaving)
[15:53:58] *** Joins: Jesin (Jesin@moz-q46lj1.fios.verizon.net)
[15:55:54] *** Joins: kushal (kdas@moz-9s6.akp.200.118.IP)
[15:56:33] *** Quits: marsel (user@moz-a2k.end.162.188.IP) (Ping timeout: 121 seconds)
[15:56:39] *** Quits: adu (ajr@moz-0foa9t.md.comcast.net) (Client exited)
[15:57:45] *** Quits: Astrum|Lap (Astrum|Lap@moz-e4c.9jn.170.50.IP) (Client exited)
[15:59:39] *** Quits: larhat (Adium@moz-8v4.af0.232.213.IP) (Quit: Leaving.)
[16:02:22] *** Quits: munksgaard (munksgaard@moz-lui.hq0.225.130.IP) (Ping timeout: 121 seconds)
[16:02:45] <kimundi> playbot: static FOO: &'static mut FnMut() -> i32 = &mut || 100;
[16:02:46] -playbot- error: internal compiler error: no type for node 65: expr 100 (id=65) in fcx 0x7fbd07fed178
[16:02:47] -playbot- note: the compiler unexpectedly panicked. this is a bug.
[16:02:47] -playbot- output truncated; full output at: http://bit.ly/1xd1yVV
[16:02:54] <kimundi> eddyb: ^ Didn't that work at some point?
[16:06:34] *** Quits: laumann (laumann@moz-3v9.hq0.225.130.IP) (Ping timeout: 121 seconds)
[16:09:44] *** Quits: mib_a9smef (Mibbit@moz-juv.9o3.252.72.IP) (Quit: http://www.mibbit.com ajax IRC Client)
[16:10:41] <eddyb> kimundi: I think some typeck stuff is not recursing into closures in constants
[16:10:49] <eddyb> kimundi: and there's no tests :|
[16:11:58] <kimundi> Ah, right, I remember you forgetting those tests ;)
[16:12:58] *** Quits: mystor (mystor@moz-va2.r78.15.130.IP) (Connection closed)
[16:13:03] <eddyb> enjolras: sorry :(
[16:13:40] <eddyb> kimundi: shouldn't be hard to fix, though, once you figured out where it's not recursing
[16:13:53] <enjolras> sorry for what ? :)
[16:14:29] <eddyb> kimundi: it finds closures in free functions, but not constants. so something must be missing from the const/static entry point in typeck::check
[16:14:40] <enjolras> "note: first, the lifetime cannot outlive lifetime ReInfer(ReSkolemized(0, BrNamed(DefId { krate: 0, node: 668 }, "\'a"(100))))." this is a weird error message
[16:14:51] <eddyb> ReInfer?!
[16:15:17] <eddyb> enjolras: add -Z treat-err-as-bug and run with RUST_BACKTRACE=1
[16:15:28] <eddyb> though I bet it's regionck
[16:15:49] <eddyb> kimundi: comparing the entry point for functions with the one for const/static items should be straight-forward
[16:16:47] <enjolras> http://sprunge.us/QhJX
[16:16:53] *** Joins: brson (brson@moz-cfhap5.mtv2.mozilla.com)
[16:16:53] *** ChanServ sets mode: +o brson
[16:17:44] <enjolras> writting a reduced testcase would be hard though :/
[16:18:53] *** Quits: Guest63 (textual@moz-m125j8.44.threembb.ie) (Quit: My Mac has gone to sleep. ZZZzzz…)
[16:21:12] <eddyb> nmatsakis, pnkfelix: any ETA on a const fn decision? the PR is waiting for a review, rebased this morning
[16:22:07] *** Joins: Guest63 (textual@moz-m125j8.44.threembb.ie)
[16:22:14] <pnkfelix> eddyb: was discussed at mtg last night; unforunately I missed that mtg due to time-zone + scheduling confusion
[16:22:16] <nmatsakis> eddyb: not sure but we talked about it some in weekly mtg yesterday; I was meaning to go jot down some notes from that discussion in the RFC; but some poeple (e.g. brson, wycats) were absent and I'd like to get their take too
[16:22:49] <eddyb> nmatsakis: I read through it, seemed mostly positive
[16:23:02] *** Quits: bytewise (bytewise@moz-mecf2n.unity-media.net) (Quit: Quit)
[16:26:39] <wycats> nmatsakis: link?
[16:27:04] <eddyb> I need to answer the macro thing (the short version is "macros are horribles for this")
[16:27:17] <eddyb> s/es/e//
[16:29:50] <nmatsakis> wycats: https://github.com/rust-lang/rfcs/pull/911#issuecomment-78299673 well, that's a summary of what we said in the mtg (and also includes the RFC naturally)
[16:30:29] <eddyb> nmatsakis, pnkfelix: fyi, I have a branch that tried to adjust libcore and libstd to use const fn methods. I had spent so much time putting down #[cfg(stage0)] only to realize the "const" part won't parse at stage0 at all... but it should be salvageable past a snapshot
[16:30:43] *** Joins: Astrum|Lap (Astrum|Lap@moz-7enfbr.co.comcast.net)
[16:30:59] <wycats> nmatsakis: I'm pretty +1 on this
[16:31:11] <eddyb> wycats: :D
[16:31:12] <wycats> I have often hit issues that would be addressed with this
[16:31:20] *** Joins: Rym_ (y@moz-232.ad4.144.109.IP)
[16:31:24] <eddyb> the libstd is *chock full* of _INIT constants
[16:31:47] <wycats> I usually suck it up and make it slow :/
[16:31:57] <wycats> use a regular fn
[16:32:20] <eddyb> want an AtomicInt that starts at -1 instead of 1? tough luck (although *that specific case* might be there, for AtomicBool. or maybe not)
[16:33:34] <eddyb> a bunch of stuff was using UnsafeCell instead of Cell just because Cell can't be initialized in a constant (relevant to thread_local)
[16:34:15] *** Joins: gleb (gleb@moz-3u1drv.rusanovka-net.kiev.ua)
[16:34:31] <eddyb> nmatsakis++ for "why not have both"
[16:35:29] <Gankro> nmatsakis: Would there be anything wrong with having a plugin that basically did "compile and execute this block of code as a program at compile time, and store the result", with the only restrictions being on the contents of the result?
[16:35:47] <eddyb> Gankro: depends what kind of constant it is
[16:35:52] *** Quits: Rym_ (y@moz-232.ad4.144.109.IP) (Ping timeout: 121 seconds)
[16:36:30] <Gankro> eddyb: Can you elaborate?
[16:36:32] <eddyb> we already have around 3 or 4 kinds
[16:37:05] <eddyb> Gankro: can it be used as N in [T; N]?
[16:37:23] <eddyb> if not, maybe you remember ctfe! :P
[16:37:24] <Gankro> eddyb: Seems reasonable, since you can use a `const` there, right?
[16:37:29] <eddyb> Gankro: barely
[16:37:54] <eddyb> Gankro: it has to be rather pure
[16:38:21] <Gankro> rusti: const x: usize = 3; let y: [u32; x];
[16:38:22] -playbot- <anon>:14:9: 14:28 warning: constant `x` should have an upper case name such as `X`, #[warn(non_upper_case_globals)] on by default
[16:38:23] -playbot- <anon>:14         const x: usize = 3; let y: [u32; x];
[16:38:23] -playbot- output truncated; full output at: http://bit.ly/1xd5iqo
[16:38:29] <eddyb> Gankro: that's an easy case
[16:38:38] <eddyb> as pure as you can get a const
[16:38:45] *** Joins: mortisha (Mibbit@moz-g6k.oht.161.46.IP)
[16:38:51] <Gankro> eddyb: That's what the program would look like after the plugin runs though, no?
[16:38:56] <eddyb> Gankro: and that plugin would have to work on untyped code
[16:39:09] <Gankro> eddyb: Why?
[16:39:22] <eddyb> Gankro: because you're computing types with it
[16:40:37] <eddyb> Blow's ctfe thing will never get into the type system, unless he goes for a completely different language/niche
[16:40:45] *** Quits: kushal (kdas@moz-9s6.akp.200.118.IP) (Quit: Leaving)
[16:41:00] *** Joins: laumann (laumann@moz-n9e72h.0.fullrate.dk)
[16:41:06] <kimundi> eddyb: I think the assumption is to have only one kind of constant :P
[16:41:12] <Gankro> eddyb: Seems like a simple pre-processor?
[16:41:16] *** Joins: topolinux (paolo@moz-es8.ls8.75.151.IP)
[16:41:33] <kimundi> As in "equivalent to writing down the final value as a literal"
[16:42:07] *** Joins: O01eg (o01eg@moz-lg9g0t.f537.4n8f.2698.2a02.IP)
[16:42:09] <eddyb> Gankro: well, his ctfe is impure, so you arguably can't build a type system around it
[16:42:15] <kimundi> Gankro: I think the main issue here is allowing that preprocessed program to access the rest of the crates constants and code
[16:42:27] <eddyb> fn foo() -> [i32; rand()]
[16:42:50] <Gankro> kimundi: Yes dependency resolution is definitely tricky. An easy cop-out would be to disallow accessing anything in the current crate.
[16:42:52] <kimundi> Gankro: Its easy if its just a empty "fn main() { ... }" that gets evaluated on its own, and the result pasted
[16:43:07] <kimundi> yeah, that would be a possibility
[16:43:25] <eddyb> Gankro: my prediction is that it will either never work in the type system or Jai/Jei/whatever can be used to make Malbolge look lame
[16:43:44] <eddyb> and... even easy...
[16:43:58] <Gankro> kimundi: Seems like you could see what refers to what and build a DAG?
[16:44:03] <kimundi> eddyb: Or it just does what me an Gankro have been talking about all the time :P
[16:44:03] <eddyb> Gankro: dependency resolution is actually kinda easy :P
[16:44:11] <Gankro> evaluate the blocks in topo sort order?
[16:44:32] <eddyb> you can do it the way we (don't) do it right now in Rust
[16:44:45] <eddyb> kimundi: which is what?
[16:45:00] <kimundi> Gankro: Probably, yeah. The issue then becomes making sure you don't start incrementally compiling the same crate N times, and also making sure the compiled fragments don't diverge from each other
[16:45:20] <eddyb> guys, you're giving the man too much credit...
[16:46:06] <eddyb> anyways, if it's pure it's pretty easy to represent with a tree of sorts
[16:46:43] <kimundi> eddyb: const FOO: Bar = run_rustc!(bar()), that is just a preprocessor that generates the final AST as the result of compiling a code snippet. NAd the issue here is of course to make that code snippet access the rest of the crate
[16:46:51] <eddyb> the plugin would need to be able to advance type-checking for a bit of code
[16:46:52] <Gankro> kimundi: Strikes me as the sort of thing that can go catastrophic on a bad input but wouldn't be a problem in practice
[16:47:00] <eddyb> the current model would have to be scraped
[16:47:28] <eddyb> you end up with a fixed-point type-checking model that can support global inference even if it doesn't, I think
[16:47:45] *** Joins: Rym_ (y@moz-232.ad4.144.109.IP)
[16:47:58] *** Quits: pauls (pauls@moz-e5p333.ccs.neu.edu) (Connection closed)
[16:48:06] <eddyb> kimundi: it's not AST-based
[16:48:26] <kimundi> eddyb: I'm not assuming anything about what that other langauge can do, I'm only going based on facts I heard about it here, which included the phrase "passing command line arguments to the constexpr for the compiler running it"
[16:48:45] <eddyb> he uses an interpreter, which means it's most likely already typed
[16:48:50] <eddyb> kimundi: uh oh
[16:48:54] *** Joins: marsel (user@moz-rh5.rfl.234.188.IP)
[16:49:19] <eddyb> kimundi: what I understood was that you could modify the parameters of the *currently running compilation*
[16:49:49] *** Joins: frogoniaxcc (Mibbit@moz-juv.9o3.252.72.IP)
[16:49:52] <kimundi> Anyway, I know nothing about the other language, but also don't want to argue anything about it. I'm just not seeing how the approach me and Gankro talk about could not also work in another language :P
[16:50:16] <eddyb> kimundi: it has to either be pure or not touch the type system
[16:50:21] <eddyb> we already have link-time constants
[16:50:30] *** Quits: Nekit1234007 (nekit@moz-vfr.64q.51.84.IP) (Connection closed)
[16:50:47] <kimundi> eddyb: This would basically run during macro expansion
[16:50:49] <eddyb> though they are not `const`, at most `static`
[16:51:20] <kimundi> eddyb: So, I don't think either of these would be a problem, but it would proabbyl also not be as powerful as you imagine an acceptable solution :P
[16:51:32] <eddyb> kimundi: I tried to design that once for same-crate syntax extensions
[16:51:47] <kimundi> Yeah, thats the same issue basically
[16:52:23] <eddyb> it involved pruning functions aggresively, but I forgot the logic for it
[16:52:39] *** Joins: Nekit1234007 (nekit@moz-vfr.64q.51.84.IP)
[16:52:43] <kimundi> Imo it an be made to work in theory. Wether its efficient enough to be realistic is another problem of course...
[16:52:54] <eddyb> kimundi: starting from uses of the defined macros, you kill everything
[16:52:59] <kimundi> yeah
[16:53:13] <eddyb> you're going to maybe have some typeck errors because of trait resolution
[16:53:56] <kimundi> For constants, it would be "starting from the definition, keep everthing the constant depends on"
[16:54:14] <eddyb> kimundi: that doesn't work
[16:54:18] <eddyb> you can't compute that set
[16:54:32] <eddyb> without... wait for it... type-checking :P
[16:54:32] <kimundi> yeah, that part needs to run after macro expansion... hm...
[16:55:03] <kimundi> no wait, otherway round then:
[16:55:05] *** Joins: mystor (mystor@moz-va2.r78.15.130.IP)
[16:55:09] <eddyb> yupp
[16:55:17] <eddyb> prune everything that uses the constant
[16:55:34] <eddyb> (that's what I said about syntax-extension-defined macros)
[16:55:39] <kimundi> yeah
[16:55:41] <kimundi> heh
[16:56:17] <kimundi> hm, this might become eaiser with incremental compilation
[16:56:51] <kimundi> you have to add explicit dependency edges for those constants
[16:57:19] <eddyb> meanwhile... I came up with a degenerate "type" system that can freely mix ranks but still requires some kind of "materialization" for values
[16:57:26] *** Joins: mystor_ (mystor@moz-rrn.r78.15.130.IP)
[16:57:31] <kimundi> and then just iteratively reuse the partially compiled crate fragments for the compilation of code dpending on the constant until you are done
[16:57:32] <eddyb> (in terms of memory layout and accesses)
[16:58:03] * kimundi takes away eddyb's kool-aid ration for this week
[16:58:25] *** Quits: killercup (killercup@moz-4udt1b.dip0.t-ipconnect.de) (Quit: My Mac has gone to sleep. ZZZzzz…)
[16:58:35] <eddyb> kimundi: it feels like waking up from a weird dream
[16:58:49] <eddyb> not a nightmare, but something I haven't seen before, not even with dependent types
[16:59:39] <arrrrrrr1> eddyb: has there be a discussion about custom containers like Box? and more importantly: has anyone written anything down?
[16:59:39] <eddyb> kimundi: I guess I could say I went on a trip - exploring future design spaces :P
[16:59:54] <eddyb> arrrrrrr1: not sure why you keep calling them containers
[17:00:06] *** Quits: mystor (mystor@moz-va2.r78.15.130.IP) (Ping timeout: 121 seconds)
[17:00:07] <eddyb> I'm used to Smaht
[17:00:09] <arrrrrrr1> they contain stuff
[17:00:12] <kimundi> thats nitpicky eddyb :P
[17:00:51] <eddyb> kimundi: sorry, I'm very easily confused
[17:01:06] <kimundi> arrrrrrr1: Custom in what way that Box<T> is and Rc<T> isn't? The ability to move out?
[17:01:44] <arrrrrrr1> kimundi: yes, you can move out of them
[17:01:51] <arrrrrrr1> at least that's one requirement I think
[17:01:53] <kimundi> eddyb: Okay, _that_ argument I accept because I have the same issue. So I guess we are both to nitpicky from time to time :P
[17:01:54] <arrrrrrr1> maybe there are more
[17:02:19] <kimundi> arrrrrrr1: I think thats the only thing, apart from a general boxing/pattern matching solution
[17:02:36] <eddyb> Vec<T> is a smaht pointer
[17:02:39] <arrrrrrr1> so, has something been written down?
[17:03:12] <arrrrrrr1> I don't want to think about this if everything I could come up with has already been discussed and rejected
[17:03:55] *** Joins: mystor (mystor@moz-rrn.r78.15.130.IP)
[17:04:13] <kimundi> arrrrrrr1: Not aware of recent RFCs for the move thing, the boxing stuff has recent rfcs, and the pattern matching stuff depends on the solution for the first two ones afaik, and doesn't really have clear proposals yet
[17:04:24] <arrrrrrr1> googling for smaht pointer returns this result: https://github.com/aepsil0n/rust-rfcs/blob/master/text/0130-box-not-special.md
[17:04:26] <arrrrrrr1> thanks, eddyb
[17:04:48] <eddyb> arrrrrrr1: hahaha
[17:04:49] <kimundi> haha
[17:05:07] *** Quits: mystor_ (mystor@moz-rrn.r78.15.130.IP) (Connection closed)
[17:05:13] <eddyb> nmatsakis: look what you've started
[17:05:24] *** Joins: bytewise (bytewise@moz-mecf2n.unity-media.net)
[17:07:01] <arrrrrrr1> https://github.com/rust-lang/rfcs/pull/178
[17:07:05] <arrrrrrr1> huh, didn't see that one
[17:10:58] <faern> Hello all. I made the compiler panic, found a minimum case where it happened. http://is.gd/4uh4KB
[17:11:11] *** Quits: frogoniaxcc (Mibbit@moz-juv.9o3.252.72.IP) (Quit: http://www.mibbit.com ajax IRC Client)
[17:11:24] <faern> Is this a known bug? I did not find exactly this as an already reported issue.
[17:12:33] *** Joins: scialex (scialex@moz-j5mi8i.cs.brown.edu)
[17:14:19] <arrrrrrr1> faern: it's not known to me but the reason it cannot work is that Fn() -> () is not a sized type
[17:15:54] *** Quits: zmack (zmack@moz-b26i0b.home.aster.pl) (Connection closed)
[17:16:11] <faern> arrrrrrr1: Yes, that is the error given if the Vec<> part is removed. But I still don't want the compiler to panic on me :)
[17:16:40] <arrrrrrr1> just open an issue if you can't find another one
[17:16:52] <faern> Ok, I will. Just wanted to check here first
[17:17:27] <faern> Thanks
[17:18:06] <arrrrrrr1> >impl Box<Trait> { }
[17:18:14] <arrrrrrr1> what's this madness..
[17:21:29] *** Quits: mystor (mystor@moz-rrn.r78.15.130.IP) (Connection closed)
[17:29:42] *** Quits: c74d (c74d3a4ebb6@moz-0ersgu.oc.cox.net) (Ping timeout: 121 seconds)
[17:30:15] *** Joins: imperio (Mibbit@moz-8otf3a.fbx.proxad.net)
[17:31:47] *** Joins: mystor_ (mystor@moz-rrn.r78.15.130.IP)
[17:33:13] *** Quits: mystor_ (mystor@moz-rrn.r78.15.130.IP) (Connection closed)
[17:34:15] *** Joins: sigma (sigma@moz-ohog4c.range86-135.btcentralplus.com)
[17:34:32] *** Parts: marsel (user@moz-rh5.rfl.234.188.IP) ("ERC Version 5.3 (IRC client for Emacs)")
[17:34:48] *** Joins: marsel (user@moz-rh5.rfl.234.188.IP)
[17:36:39] *** Quits: Guest63 (textual@moz-m125j8.44.threembb.ie) (Quit: My Mac has gone to sleep. ZZZzzz…)
[17:43:09] *** Quits: summerlight_ (summerlight@moz-99k.2mj.130.121.IP) (Ping timeout: 121 seconds)
[17:43:29] *** WindowsBunny1 is now known as WindowsBunny
[17:44:04] *** Joins: mystor (mystor@moz-rrn.r78.15.130.IP)
[17:46:21] *** Joins: Sindriava (textual@moz-ca79jq.broadband10.iol.cz)
[17:48:16] *** Quits: mystor (mystor@moz-rrn.r78.15.130.IP) (Ping timeout: 121 seconds)
[17:48:17] *** Joins: Guest63 (textual@moz-m125j8.44.threembb.ie)
[17:51:25] <brson> aturon: does the Path type work with windowsy paths on unix, or does it behave differently based on platform?
[17:52:03] <aturon> brson: at the moment it's different per platform; eventually you'll be able to ask for paths on a specific platform (like the old path module allowed)
[17:53:31] <imperio> acrichto: like you said, it fails, but it's supposed to fail so by what do you want to replace it ? gh23156
[17:53:31] <[o__o]> Remove proc keyword: https://github.com/rust-lang/rust/pull/23156
[17:53:40] <imperio> I would have remove it...
[17:55:08] *** Joins: killercup (killercup@moz-edmf2j.dip0.t-ipconnect.de)
[17:58:17] <brson> acrichto: here's my pr for fixing -C rpath https://github.com/rust-lang/rust/pull/23283
[17:58:34] <brson> acrichto: i noted in the pr that the new Path::relative_from seems to have questionable utility
[17:58:38] <brson> it dose not do anything like what the old did
[17:58:41] *** Joins: eerie (eerie@moz-nbbdu3.red.bezeqint.net)
[17:58:47] *** Joins: mystor (mystor@moz-rrn.r78.15.130.IP)
[17:58:54] <acrichto> imperio: you can just update the error message
[17:59:03] *** Quits: scialex (scialex@moz-j5mi8i.cs.brown.edu) (Quit: Leaving)
[17:59:25] <acrichto> brson: the idea I think is that relative_from can complete if it can make a slice
[17:59:38] <acrichto> so it is definitely of less utility than previously
[17:59:41] <acrichto> but you get different guarantees
[18:02:29] *** Joins: larhat (Adium@moz-9vj.vcf.204.37.IP)
[18:03:06] <arrrrrrr1> >cannot pass self by unsafe pointer
[18:03:08] <arrrrrrr1> why?
[18:06:34] <aturon> brson: the problem is that the old version is broken wrt symlinks
[18:06:42] <aturon> (same reason we don't normalize .. any more)
[18:08:02] *** Quits: pnkfelix (pnkfelix@moz-6v5.3nd.202.89.IP) (Quit: rcirc on GNU Emacs 24.3.92.1)
[18:09:28] *** Joins: gsingh93 (gulshan@moz-3fu4am.mi.comcast.net)
[18:10:08] *** Joins: whidgle (Mibbit@moz-juv.9o3.252.72.IP)
[18:11:09] <brson> aturon: i can't think of a scenario on unix where it was broken
[18:12:00] <brson> (due to symlinks)
[18:14:17] <WindowsBunny> foo/../bar is not the same as bar
[18:14:35] <aturon> WindowsBunny: brson: right, that's the example
[18:14:45] <WindowsBunny> because foo can be a symlink, so .. inside a symlink would actually go up to somewhere else entirely
[18:15:09] <aturon> brson: however, your PR is talking about going to an absolute path
[18:15:18] <aturon> which is a case that i think the new path API is handling incorrectly
[18:15:36] <aturon> (in that it should successfully give you that path back)
[18:15:52] <aturon> acrichto: ^
[18:15:59] *** Joins: avikpal (avikpal@moz-bjs.mde.194.117.IP)
[18:16:18] *** Joins: tcurdt (tcurdt@moz-m3gqr9.dip0.t-ipconnect.de)
[18:18:22] <brson> WindowsBunny: what's the incorrect input that produces 'foo/../bar'?
[18:18:42] <brson> bar'.path_relative_from('foo')?
[18:19:19] *** Quits: mystor (mystor@moz-rrn.r78.15.130.IP) (Connection closed)
[18:19:34] <brson> ok, i see that's wrong with symlinks
[18:19:59] <imperio> acrichto: that's what I don't understand. What do you mean by update the error message ? Changing the // comment ?
[18:20:11] <acrichto> imperio: yes
[18:20:28] <WindowsBunny> symlinks basically make working with paths hell
[18:20:35] <imperio> acrichto: by what am I supposed to change it then ? I thought my comment was good...
[18:20:46] <acrichto> imperio: have you run the test?
[18:20:54] <imperio> yes
[18:21:00] <acrichto> imperio: and it passes??
[18:21:09] <imperio> no
[18:21:14] <acrichto> ... (that needs fixing)
[18:21:19] <imperio> it fails (just like it's supposed to)
[18:21:40] <imperio> then I should add a #[should_fail] no ?
[18:21:55] *** Joins: pcwalton (pcwalton@moz-l8ebtf.sfo1.mozilla.com)
[18:21:55] *** ChanServ sets mode: +o pcwalton
[18:21:56] <imperio> I don't get what it would change if I modify the comments
[18:22:16] <acrichto> imperio: you need to update the error message because it has probably changed
[18:22:21] *** Quits: pcwalton (pcwalton@moz-l8ebtf.sfo1.mozilla.com) (Client exited)
[18:22:47] <imperio> I think I got what you meant
[18:22:49] *** Joins: joneshf-laptop (joneshf@moz-ls5uph.ucdavis.edu)
[18:22:52] <imperio> sorry for being slow ^^'
[18:22:55] *** Joins: pcwalton (pcwalton@moz-l8ebtf.sfo1.mozilla.com)
[18:22:55] *** ChanServ sets mode: +o pcwalton
[18:23:03] *** Joins: scott (uid25790@moz-e5ok1n.brockwell.irccloud.com)
[18:24:45] *** Quits: eerie (eerie@moz-nbbdu3.red.bezeqint.net) (Connection closed)
[18:26:19] *** Joins: eerie (eerie@moz-nbbdu3.red.bezeqint.net)
[18:29:33] <kimundi> I have a question at concurrency/typesystem experts. If you have parallel access to a memory location, say gated by an Mutex or via an atomic, then the implementantion inserts cpu instructions to make sure the memory is syncronized between threads, right?
[18:30:03] <aturon> brson: so if relative_from returned self for an absolute path, would that address yoru use case?
[18:30:08] <kimundi> But rust also allows unchecked access from different threads vie &mut now
[18:30:30] <aturon> kimundi: what do you mean by unchecked access?
[18:30:39] <kimundi> They can not alias, but you can create and drop them pretty much instantanious
[18:30:56] <aturon> (are you referencing the Send changes here?)
[18:31:32] <kimundi> aturon: As in, creating a &mut and sending it to another thread does not explicitly run code to make sure the receiving thread's cpu  sees the same memoroy under that address
[18:31:39] *** Quits: laumann (laumann@moz-n9e72h.0.fullrate.dk) (Quit: leaving)
[18:31:51] <aturon> kimundi: it depends on how the &mut is communicated
[18:31:56] *** Joins: laumann (thomas@moz-n9e72h.0.fullrate.dk)
[18:32:05] <aturon> if it's sent over a channel or via a mutex, there's generally a fence instruction
[18:32:40] <kimundi> aturon: But thats just for the data containing the &mut T itself, right?
[18:33:20] <aturon> no, generally it covers essentially all writes that occurred prior to the communication
[18:33:40] <aturon> at the hardware level, this involves flushing various write buffers
[18:34:19] *** Quits: laumann (thomas@moz-n9e72h.0.fullrate.dk) (Quit: leaving)
[18:34:20] <aturon> simply put, it's the job of things like Mutex and channels to ensure that the data being communicated is fully "seen by" the other thread,
[18:34:23] *** Joins: laumann (thomas@moz-n9e72h.0.fullrate.dk)
[18:34:30] <kimundi> aturon: Hmm...
[18:34:32] <aturon> and there are various ways to achieve this using atomic operations
[18:34:47] <aturon> (which in turn emit hardware fences/flushes)
[18:35:44] <kimundi> aturon: The issue I see is that if you _have_ a thread spanning &mut, you can communicate through it without such fences
[18:36:04] *** Joins: adu (ajr@moz-vd1fau.fios.verizon.net)
[18:36:05] <aturon> how so? it cannot be aliased
[18:37:05] *** Quits: bytewise (bytewise@moz-mecf2n.unity-media.net) (Quit: Quit)
[18:37:24] <Manishearth> brson: !
[18:37:28] <Manishearth> buildslaves are dead
[18:37:45] <imperio> acrichto: it's driving me razy ! it says I have to write `proc` is a reserved keyword so I write "//~ ERROR `proc` is a reserved keyword so I write" and still not working. What am I missing ?
[18:40:10] <kimundi> aturon: say you have a &mut &mut T, with the outer reference spanning across threads The initall communication is all done, the two CPUs where doing their own thing for a while. Then you swap out the inner &mut T with something that points at memory touched by the current cpu, which the other cpu did not yet see
[18:41:07] <aturon> kimundi: what do you mean by "the outer reference spanning across threads"? since it's &mut, only one thread can own it (it's an affine value)
[18:41:16] <imperio> acrichto: it's actually only on the first linne, when I rmeove it, all works. Hum...
[18:41:18] <sfackler> if thread b does the swap, thread a can't access that pointer until the thread's been joined, which involves enough synchronization to make the visibility work
[18:42:35] <aturon> kimundi: also, what sfackler said :)
[18:43:06] <aturon> basically the concurrency libraries are set up to ensure that any transfer of ownership is accompanied by hardward synchronization that ensures visibility
[18:43:13] *** Joins: acharles_ (acharles@moz-ulbdcn.ca.comcast.net)
[18:43:25] <aturon> and that includes, for scoped threads, the point where ownership "reverts" to the parent thread, due to the join
[18:43:45] <kimundi> sfackler: okay, thats what I'm getting at - It feels like the sycronization of the _thread_ just happens to syncronize stuff like the reference as a side effect, and I'm not feeling confident that there can never be a situations where this does not work
[18:44:13] *** Quits: acharles (acharles@moz-ulbdcn.ca.comcast.net) (Ping timeout: 121 seconds)
[18:44:13] *** acharles_ is now known as acharles
[18:44:44] <acrichto> imperio: yes the lexer will probably only emit one error
[18:45:10] <imperio> acrichto: I think there is something not working, if I leave only one of the two lines, it works fine, but with the second it doesn't. Any idea ?
[18:45:14] <sfackler> you're not synchronizing a thread, you're synchronizing the entire address space
[18:45:31] <aturon> kimundi: the memory model is set up specifically to help you deal with this
[18:45:41] <kimundi> sfackler: Okay, I was not aware that the mechanism is that blunt :P
[18:45:45] <imperio> acrichto: so what am I supposed to do ? I remove what comment ?
[18:45:57] <aturon> kimundi: at the memory model level, you talk about individual accesses,
[18:46:09] <aturon> kimundi: but that has implications about the visibility of everything that happened before
[18:46:15] <imperio> acrichto: ok that was that ! I push !
[18:46:23] <aturon> kimundi: i don't know if this is helpful, but here's a paper from back when i used to work on this stuff: http://plv.mpi-sws.org/gps/paper.pdf
[18:46:49] <aturon> kimundi: there's a lot of math there, but there's also some prose explanations that might help illuminate what's going on with things like Acquire/Release memory orderings
[18:47:18] <steveklabnik> where does .iter() on slices come from? ther'es no impl Iterator there
[18:47:25] <kimundi> So, its not actual possible to do finer grained memroy syncronization than this?
[18:47:31] <arrrrrrr1> kimundi: or read the C++11 standard on the topic which describes exactly how it works in rust
[18:48:07] <aturon> kimundi: (note that this is a formalization of the C++11 standard; the intro and section 2 are most relevant here)
[18:48:13] <sfackler> steveklabnik: iter doesn't come from Iterator
[18:48:15] <steveklabnik> it clearly _works_
[18:48:15] <sfackler> steveklabnik: http://doc.rust-lang.org/std/slice/trait.SliceExt.html#tymethod.iter
[18:48:20] <steveklabnik> ahhhh i know it had to be somewhere
[18:48:21] <aturon> kimundi: some hardware allows finer-grained synchronization
[18:48:21] <steveklabnik> thanks
[18:48:31] <steveklabnik> extension traits strike again
[18:48:32] <aturon> kimundi: but the memory model doesn't
[18:48:53] <kimundi> aturon: And on that hardware Rust could not make use of those finer grained mechnisms?
[18:49:20] <aturon> kimundi: well, you'd need a different std lib and back end
[18:49:27] <aturon> but there's nothing fundamental preventing it
[18:49:36] <kimundi> aturon: Because it assumes a memory model that is incompatible with non-glob memory syncronization?
[18:49:55] <aturon> kimundi: basically, it assumes the C++11 memory model, which is what LLVM implements
[18:50:11] <aturon> which in turn implies this kind of coarse-grained visibility
[18:52:02] <kimundi> aturon: Right, but a different std lib and a different backend would not change the language semantic. So do you mean that something like the &mut case would have to be forbidden for apis that use finer-grained syncronization?
[18:52:05] <steveklabnik> sfackler: http://www.reddit.com/r/rust/comments/2yor5a/how_vec_becomes_iterator/cpbp1kr?context=1 seem good?
[18:53:01] <sfackler> steveklabnik: yep
[18:53:14] <sfackler> steveklabnik: we'd also ideally be able to directly impl stuff on &[T] and avoid SliceExt entirely
[18:53:17] *** Quits: Guest63 (textual@moz-m125j8.44.threembb.ie) (Quit: My Mac has gone to sleep. ZZZzzz…)
[18:53:35] <aturon> kimundi: well, i don't think it makes much sense for an API to claim to transfer ownership without also ensuring visibility to the other thread
[18:53:55] <Manishearth> steveklabnik: we need docs for blanket impls and deref both
[18:54:03] <aturon> kimundi: but this is getting a bit speculative :)
[18:54:19] <kimundi> aturon: Yeah :) Thanks for the answers!
[18:54:25] <aturon> kimundi: any time!
[18:56:16] <sfackler> I'm also not sure how much hardware actually has finer grained synchronization - maybe something like the Xeon Phi?
[18:57:07] <kmc> i have some of those :3
[18:57:29] *** Quits: whidgle (Mibbit@moz-juv.9o3.252.72.IP) (Quit: http://www.mibbit.com ajax IRC Client)
[18:58:23] *** Joins: avikpal_ (avikpal@moz-bjs.mde.194.117.IP)
[18:58:55] *** Quits: avikpal (avikpal@moz-bjs.mde.194.117.IP) (Ping timeout: 121 seconds)
[18:58:55] <sfackler> nice
[18:59:03] <sfackler> I know you can manually manage cache lines with it
[18:59:22] <sfackler> and I'd assume it'd have a less coherent memory model than x86
[19:00:50] <kimundi> I just assumed CPU architectures had finer access than that in general, as it seems to scale badly otherwise
[19:01:25] <aturon> kimundi: keep in mind that the hardware already has a limited buffer for outstanding writes that haven't gone out to cache yet, anyway
[19:01:39] <aturon> sfackler: i was thinking of cache-incoherent architectures :)
[19:01:47] <aturon> anyway, g2g for now
[19:02:13] *** Quits: dudel (dud@moz-55rvi2.dclient.hispeed.ch) (Quit: Leaving)
[19:10:50] <brson> Manishearth: uh, that looks bad
[19:10:54] <brson> Manishearth: do you know what's going on?
[19:11:20] *** Quits: huseby (huseby@moz-m7l0au.d2vr.5em6.6400.2605.IP) (Client exited)
[19:11:44] *** Joins: huseby (huseby@moz-3oh5i4.linuxprogrammer.org)
[19:12:36] <Manishearth> brson: nope
[19:13:05] <brson> aturon: no i don't think so. the rpath code is looking for a relative path, not an absolute one. it passes two absolute paths and expects a relative path
[19:13:12] *** Joins: fensterxzc (Mibbit@moz-juv.9o3.252.72.IP)
[19:13:52] <brson> aturon: so e.g. '/foo/bar'.path_relative_from('/baz/qux') -> ../../foo/bar
[19:14:21] <Manishearth> brson: but it was stuck like this before I did any strange homu commands (so all those force cleans did not call this)
[19:14:24] <Manishearth> *cause
[19:14:32] *** Quits: imperio (Mibbit@moz-8otf3a.fbx.proxad.net) (Quit: http://www.mibbit.com ajax IRC Client)
[19:14:32] <Manishearth> brson: it seems to be like the slaves are disconnected or something
[19:14:38] <brson> Manishearth: investigating
[19:15:11] *** Joins: imperio (Mibbit@moz-8otf3a.fbx.proxad.net)
[19:16:04] <Manishearth> thx
[19:16:11] *** Quits: fensterxzc (Mibbit@moz-juv.9o3.252.72.IP) (Quit: http://www.mibbit.com ajax IRC Client)
[19:16:36] <brson> Manishearth: i know i have a todo to give you instructions for working on rust-buildbot
[19:17:50] <Manishearth> right, thanks :)
[19:18:50] <arrrrrrr1> is there a reason besides "nobody has done it yet" that one can't refer to all traits?
[19:19:26] *** Joins: reem (reem@moz-m3r0uh.coob.q2h1.0009.2601.IP)
[19:20:16] *** Joins: James (quassel@moz-5qldmp.range109-148.btcentralplus.com)
[19:20:41] <Manishearth> arrrrrrr1: T: ?Sized>?
[19:20:55] <arrrrrrr1> Manishearth: T could also be something that's not a trait
[19:21:08] <arrrrrrr1> so you can't implement something for traits, slices, and sized types separately
[19:21:17] <arrrrrrr1> because T: ?Sized and just T overlap
[19:21:31] <Manishearth> ah
[19:22:00] <Manishearth> arrrrrrr1: um, [T] is ?Sized, right?
[19:22:04] <arrrrrrr1> yes
[19:22:08] <Manishearth> as is str, and Trait
[19:22:11] <Manishearth> and everything else?
[19:22:12] <arrrrrrr1> yes
[19:22:19] <arrrrrrr1> I think so
[19:22:20] <Manishearth> so ?Sized is an everything bound
[19:22:35] <Manishearth> oh I see what you mean
[19:22:40] <Manishearth> you don't want a T: Everything
[19:22:43] <arrrrrrr1> yo
[19:22:49] <Manishearth> you want a T: AllTheUnsizedTraitThingies
[19:23:01] <arrrrrrr1> I want to implement something for traits, slices, and sized types separately
[19:23:05] <Manishearth> hm
[19:23:31] <Manishearth> We need impl priority
[19:23:39] <arrrrrrr1> or just T: trait
[19:23:57] <arrrrrrr1> then you can write [U], T: trait, and T,
[19:24:27] <Manishearth> impl<priority=2> Foo for Bar<T : Baz> {}; impl<priority=1> Foo for Bar<T> {}
[19:24:31] <Manishearth> yeah
[19:24:47] <Manishearth> trait bound arithmetic would be nice too
[19:25:02] <Manishearth> (Just hinking of general features that solve this problem and solve other problems too)
[19:25:07] <Manishearth> but both seem far fetched
[19:26:45] *** Quits: eerie (eerie@moz-nbbdu3.red.bezeqint.net) (Connection closed)
[19:27:00] <arrrrrrr1> this is a requirement for smaht pointer I guess
[19:27:39] <kimundi> arrrrrrr1: I talked about that with nmatsakis a few days ago - its considered, but also not a high priority
[19:27:54] *** Parts: dmu (dmu@moz-eam.eti.221.66.IP) ()
[19:28:14] <arrrrrrr1> god damn it, &out RFC depends on smaht pointers RFC which depends on trait bounds RFC
[19:29:07] <kimundi> yaks all the way down ;)
[19:29:46] <arrrrrrr1> I don't know that one
[19:30:49] <Manishearth> haha
[19:31:05] <Manishearth> yak shaving + turtles all the way down
[19:31:59] <arrrrrrr1> >Yak shaving is a neologism which describes the act of performing seemingly unrelated and often annoying tasks which stand in the way of an ultimate goal. Often these tasks stack up on each other, where one task becomes impossible due to some obstacle, which leads to another unrelated task, yet another obstacle, and so on.
[19:32:36] *** Joins: mib_prrxln (Mibbit@moz-juv.9o3.252.72.IP)
[19:33:00] *** Joins: nrc (nrc@moz-4bhi2i.xtra.co.nz)
[19:33:00] *** ChanServ sets mode: +o nrc
[19:33:02] <brson> acrichto: how do i tell what homu things the state of the world is right now?
[19:33:06] <brson> i susepect homu is confused
[19:33:10] <brson> barosl: ^?
[19:33:16] <brson> *thinks
[19:33:48] <brson> context: all the ec2 buildslaves have shutdown and buildbot is doing nothing
[19:34:02] <brson> i'm guessing homu has decided to stop asking buildbot to build things
[19:34:24] <Manishearth> brson: you restart it
[19:35:17] <Manishearth> brson: it can recover iirc
[19:36:24] <reem> arrrrrrr1: What smart pointer RFC?
[19:36:38] <arrrrrrr1> reem: there isn't one yet
[19:36:51] <reem> Ahok
[19:36:52] <arrrrrrr1> reem: but the &out RFC is limited by the lack of smaht pointers
[19:37:17] <arrrrrrr1> you can't create a &out [T] from anything but [T; N] and Box<[T]>
[19:37:38] <reem> Right because of the issue with extracting from types with drop
[19:37:41] <reem> other than Box
[19:37:48] <arrrrrrr1> yo
[19:37:56] <arrrrrrr1> because Box is the only smaht pointer
[19:38:12] *** Quits: japaric (japaric@moz-663.3tp.232.190.IP) (Ping timeout: 121 seconds)
[19:38:35] <reem> I don't understand why we couldn't write Box as a library type today
[19:38:56] <arrrrrrr1> because you can't move out of anything but T and Box<T>
[19:39:07] <reem> Option<NonZero<*mut T>> has equivalent capabilities
[19:39:13] <reem> and is as efficient as just *mut T
[19:39:19] *** Quits: {0}grant ({0}grant@moz-63ubas.in.charter.com) (Connection closed)
[19:39:19] <reem> (.take())
[19:39:26] *** Joins: {0}grant ({0}grant@moz-63ubas.in.charter.com)
[19:39:50] *** Quits: {0}grant ({0}grant@moz-63ubas.in.charter.com) (Connection closed)
[19:40:06] *** Joins: {0}grant ({0}grant@moz-63ubas.in.charter.com)
[19:45:12] *** Quits: ctennis (ctennis@moz-su6.e72.137.99.IP) (Quit: Leaving...)
[19:48:33] <reem> http://is.gd/3oqIqC
[19:48:39] <reem> Box as a library type ^
[19:48:45] <reem> (no T: !Sized)
[19:50:16] *** Joins: eerie (eerie@moz-nbbdu3.red.bezeqint.net)
[19:50:18] <arrrrrrr1> that doesn't allow you to construct in place
[19:50:23] <arrrrrrr1> and doesn't work with [T]
[19:53:32] <brson> barosl acrichto: I restarted homu but it's still not doing anything. it seems to think it's waiting on 1 build and i don't know which that is. what do i do to jumpstart it?
[19:53:43] <brson> here's the pr homu is confused about https://github.com/rust-lang/rust/pull/23256
[19:55:56] *** Joins: dinfuehr (dinfuehr@moz-r4qvpb.highway.telekom.at)
[19:59:11] *** Quits: simukis (nagisa@moz-8t068g.static.zebra.lt) (Ping timeout: 121 seconds)
[20:00:47] *** Joins: simukis (nagisa@moz-8t068g.static.zebra.lt)
[20:01:30] <arrrrrrr1> there was an RFC about in-place construction
[20:01:34] <arrrrrrr1> anyone got a link?
[20:01:40] <arrrrrrr1> eddyb: I think that was your RFC?
[20:02:37] <arrrrrrr1> no, apparently not
[20:04:58] <arrrrrrr1> https://github.com/rust-lang/rfcs/pull/470
[20:06:57] *** Joins: charmander (Mibbit@moz-juv.9o3.252.72.IP)
[20:07:02] *** Quits: charmander (Mibbit@moz-juv.9o3.252.72.IP) (Quit: http://www.mibbit.com ajax IRC Client)
[20:10:26] <brson> ok, i've figured out which builds homu is confused about
[20:11:21] *** Quits: jethrogb (jethrob@moz-p2iedd.scintilla.utwente.nl) (Ping timeout: 121 seconds)
[20:11:44] *** Joins: swgillespie (swgillespie@moz-upj.3un.220.167.IP)
[20:13:19] *** Quits: avikpal_ (avikpal@moz-bjs.mde.194.117.IP) (Connection closed)
[20:13:30] *** Joins: avikpal (avikpal@moz-bjs.mde.194.117.IP)
[20:14:08] <brson> oh, the three builds homu is waiting on are all listed as 'pending' in  buildbot
[20:14:13] <brson> and they're all windows
[20:14:18] <brson> maybe we just ran out of windows slaves
[20:14:38] <brson> restarting buildbot
[20:16:35] <brson> Manishearth: the bots are running againt
[20:21:10] *** Joins: srh (User@moz-gk35n7.hfc.comcastbusiness.net)
[20:25:16] *** Quits: mib_prrxln (Mibbit@moz-juv.9o3.252.72.IP) (Quit: http://www.mibbit.com ajax IRC Client)
[20:27:10] *** Quits: bjz (bjz@moz-puppgq.tpgi.com.au) (Quit: My Mac has gone to sleep. ZZZzzz…)
[20:30:25] <acrichto> brson: ah sorry was out to lunch
[20:30:36] <acrichto> brson: I've found that `@bors: force` can normally kick homu into action (on a PR(
[20:31:15] <brson> acrichto: what does '@bors: force' do?
[20:31:19] <brson> is there a homu reference?
[20:31:24] <acrichto> http://buildbot.rust-lang.org/homu/
[20:31:27] <acrichto> force: Stop all the builds on the configured builders, and proceed to the next PR
[20:31:52] <brson> that sounds useful!
[20:32:30] <acrichto> yeah we've been using it primarily to push rollups to the top of the queue
[20:32:36] <acrichto> but it may help when bors is stuck as well
[20:32:36] <brson> acrichto: you just write '@bors: force' on any random pr?
[20:34:05] <simukis> brson: it makes the PR you commented on start building “instantly”
[20:34:19] <simukis> so yeah, you can do that on any random r+d PR
[20:35:54] <acrichto> simukis: yeah I think so, although I tend to try to put it on the one I think that should be tested
[20:36:04] <acrichto> not sure if it just cancels the current build or forces that specific PR to build
[20:38:19] <imperio> acrichto: thanks for your help on the PR and the r+ !
[20:38:34] <acrichto> imperio: np
[20:38:58] <arrrrrrr1> is it possible to write something like this:  type X = <i32 as std::fmt::Debug>;
[20:39:09] <arrrrrrr1> to create a short name for the RHS
[20:39:25] <imperio> arrrrrrr1: RHS ?
[20:39:30] <arrrrrrr1> the right hand side
[20:39:40] <imperio> thx
[20:39:46] <arrrrrrr1> http://en.wikipedia.org/wiki/Sides_of_an_equation
[20:40:45] *** Joins: summerlight_ (summerlight@moz-99k.2mj.130.121.IP)
[20:41:52] <imperio> that's weird to have an expression just for that, we don't in my language. Interesting
[20:42:41] <XMPPwocky> thus rvalues/lvalues in C
[20:44:15] *** Quits: avikpal (avikpal@moz-bjs.mde.194.117.IP) (Connection closed)
[20:45:02] *** Quits: semarie (semarie@moz-umep2l.guilhem.org) (A TLS packet with unexpected length was received.)
[20:47:00] *** Quits: jdm (jdm@moz-ilbt2e.cable.teksavvy.com) (Quit: )
[20:53:37] *** Quits: dinfuehr (dinfuehr@moz-r4qvpb.highway.telekom.at) (Connection closed)
[20:54:46] *** Quits: sigma (sigma@moz-ohog4c.range86-135.btcentralplus.com) (Ping timeout: 121 seconds)
[20:55:53] *** Quits: summerlight_ (summerlight@moz-99k.2mj.130.121.IP) (Ping timeout: 121 seconds)
[20:58:42] *** Quits: reem (reem@moz-m3r0uh.coob.q2h1.0009.2601.IP) (Connection closed)
[20:59:58] *** Joins: reem (reem@moz-2icmmi.ca.comcast.net)
[21:02:10] *** Joins: Guest63 (textual@moz-56c.qli.61.176.IP)
[21:03:04] *** Quits: reem (reem@moz-2icmmi.ca.comcast.net) (Connection closed)
[21:05:31] *** Joins: avikpal (avikpal@moz-bjs.mde.194.117.IP)
[21:06:02] *** Quits: tcurdt (tcurdt@moz-m3gqr9.dip0.t-ipconnect.de) (Quit: Textual IRC Client: www.textualapp.com)
[21:06:08] *** Joins: kmcguire_ (kmcguire@moz-pg1gb9.biz.rr.com)
[21:06:25] *** Joins: ctennis (ctennis@moz-0ns.3iq.54.68.IP)
[21:08:00] *** Quits: marsel (user@moz-rh5.rfl.234.188.IP) (Ping timeout: 121 seconds)
[21:09:04] *** Quits: kmcguire__ (kmcguire@moz-pg1gb9.biz.rr.com) (Ping timeout: 121 seconds)
[21:09:50] *** Quits: ptalbot (ptalbot@moz-1gn7gb.eu0n.jcdj.0660.2001.IP) (Ping timeout: 121 seconds)
[21:10:40] *** Joins: sigma (sigma@moz-a5u.m43.48.37.IP)
[21:12:02] *** Joins: reem (reem@moz-2icmmi.ca.comcast.net)
[21:13:50] *** Quits: hugod (user@moz-885.jmo.24.70.IP) (*.net *.split)
[21:13:50] *** Quits: imperio (Mibbit@moz-8otf3a.fbx.proxad.net) (*.net *.split)
[21:13:50] *** Quits: BlakeWilliams (BW@moz-32q.80a.230.173.IP) (*.net *.split)
[21:13:50] *** Quits: Astrum|Lap (Astrum|Lap@moz-7enfbr.co.comcast.net) (*.net *.split)
[21:13:50] *** Quits: lu324 (lu324___@moz-3v8ljg.dhcp.embarqhsd.net) (*.net *.split)
[21:13:50] *** Quits: Anchovieshat (cloin@moz-4t5baq.pentaquine.com) (*.net *.split)
[21:13:50] *** Quits: johnsoft (johnsoft@moz-69mrig.res.rr.com) (*.net *.split)
[21:13:50] *** Quits: kwantam (kwantam@moz-1adqok.DYNAPOOL.NYU.EDU) (*.net *.split)
[21:13:50] *** Quits: jmorton (jmorton@moz-83s.irv.199.198.IP) (*.net *.split)
[21:13:50] *** Quits: kmehall (quassel@moz-i98f9d.kevinmehall.com) (*.net *.split)
[21:13:50] *** Quits: mmun (mmun@moz-iar.moo.170.107.IP) (*.net *.split)
[21:13:50] *** Quits: zeiris (zeiris@moz-8jbmam.letter.agency) (*.net *.split)
[21:13:50] *** Quits: frewsxcv (frewsxcv@moz-lr4.h2r.241.192.IP) (*.net *.split)
[21:13:50] *** Quits: [o__o] ([o__o]@moz-4s2t5k.compute-1.amazonaws.com) (*.net *.split)
[21:13:50] *** Quits: ytain (ytain@moz-lio.ur1.175.184.IP) (*.net *.split)
[21:13:50] *** Quits: kemurphy (kemurphy@moz-ke1.ea2.241.192.IP) (*.net *.split)
[21:13:50] *** Quits: k1i (k1i@moz-cu3.cgm.243.162.IP) (*.net *.split)
[21:13:50] *** Quits: adu (ajr@moz-vd1fau.fios.verizon.net) (*.net *.split)
[21:13:50] *** Quits: jmesmon (ydoc@moz-naocu2.einic.org) (*.net *.split)
[21:13:50] *** Quits: awe (awe@moz-vpr.va5.236.104.IP) (*.net *.split)
[21:13:50] *** Quits: kaptainkayak (kaptainkaya@moz-iar.moo.170.107.IP) (*.net *.split)
[21:13:50] *** Quits: dustinm (dustinm@moz-9ms.n6q.68.208.IP) (*.net *.split)
[21:13:50] *** Quits: ndt (ndt@moz-t0t.9gv.241.192.IP) (*.net *.split)
[21:13:50] *** Quits: alfred (rndm@moz-fg3.o0i.131.104.IP) (*.net *.split)
[21:13:50] *** Quits: srh (User@moz-gk35n7.hfc.comcastbusiness.net) (*.net *.split)
[21:13:50] *** Quits: steveklabnik (steveklabni@moz-kkp.qlp.131.104.IP) (*.net *.split)
[21:13:50] *** Quits: geofft (geofft@moz-vfphq1.mit.edu) (*.net *.split)
[21:13:50] *** Quits: bitemyapp (callen@moz-s2l.6j9.199.198.IP) (*.net *.split)
[21:13:50] *** Quits: tjakubow (tom@moz-kim.9e3.51.173.IP) (*.net *.split)
[21:13:50] *** Quits: poorman (poorman@moz-7p5b2o.res.rr.com) (*.net *.split)
[21:13:50] *** Quits: comex (comex@moz-0m1t01.compute-1.amazonaws.com) (*.net *.split)
[21:13:50] *** Quits: Sergio (Sergio@moz-23roph.bz) (*.net *.split)
[21:13:50] *** Quits: pjenvey (pjenvey@moz-ph7jic.org) (*.net *.split)
[21:13:50] *** Quits: carter (carter@moz-0253uj.members.linode.com) (*.net *.split)
[21:13:50] *** Quits: pcwalton (pcwalton@moz-l8ebtf.sfo1.mozilla.com) (*.net *.split)
[21:13:50] *** Quits: tdfischer (tdfischer@hackerbots.net) (*.net *.split)
[21:13:50] *** Quits: ctennis (ctennis@moz-0ns.3iq.54.68.IP) (*.net *.split)
[21:13:50] *** Quits: bstrie (ben@moz-avu3ju.members.linode.com) (*.net *.split)
[21:13:50] *** Quits: kmcguire_ (kmcguire@moz-pg1gb9.biz.rr.com) (*.net *.split)
[21:13:50] *** Quits: burntsushi (burntsushi@moz-t92kn9.ma.charter.com) (*.net *.split)
[21:13:50] *** Quits: cgaebel (cgaebel@moz-aq9.qj7.199.198.IP) (*.net *.split)
[21:13:50] *** Quits: blank_name (blank_name@moz-mteiba.mi.frontiernet.net) (*.net *.split)
[21:13:50] *** Quits: rovar (rovar@moz-d89.n7f.126.38.IP) (*.net *.split)
[21:13:50] *** Quits: lahwran (lahwran@lahwran.net) (*.net *.split)
[21:13:50] *** Quits: achernya (quassel@moz-i01917.mit.edu) (*.net *.split)
[21:13:50] *** Quits: Luqman (laden@moz-qhp202.csclub.uwaterloo.ca) (*.net *.split)
[21:13:50] *** Quits: sully (sully@moz-qhc979.emarhavil.com) (*.net *.split)
[21:13:50] *** Quits: Jesin (Jesin@moz-q46lj1.fios.verizon.net) (*.net *.split)
[21:13:50] *** Quits: {0}grant ({0}grant@moz-63ubas.in.charter.com) (*.net *.split)
[21:13:50] *** Quits: jevin (jevin@moz-sra.ovp.12.72.IP) (*.net *.split)
[21:13:50] *** Quits: WindowsBunny (Peter@moz-gv8vtu.east.verizon.net) (*.net *.split)
[21:14:22] *** Joins: poorman (poorman@moz-7p5b2o.res.rr.com)
[21:14:22] *** Joins: comex (comex@moz-0m1t01.compute-1.amazonaws.com)
[21:14:22] *** Joins: mmun (mmun@moz-iar.moo.170.107.IP)
[21:14:22] *** Joins: k1i (k1i@moz-cu3.cgm.243.162.IP)
[21:14:22] *** Joins: kemurphy (kemurphy@moz-ke1.ea2.241.192.IP)
[21:14:22] *** Joins: ndt (ndt@moz-t0t.9gv.241.192.IP)
[21:14:22] *** Joins: kmehall (quassel@moz-i98f9d.kevinmehall.com)
[21:14:22] *** Joins: awe (awe@moz-vpr.va5.236.104.IP)
[21:14:22] *** Joins: kaptainkayak (kaptainkaya@moz-iar.moo.170.107.IP)
[21:14:22] *** Joins: carter (carter@moz-0253uj.members.linode.com)
[21:14:22] *** Joins: sully (sully@moz-qhc979.emarhavil.com)
[21:14:22] *** Joins: Jesin (Jesin@moz-q46lj1.fios.verizon.net)
[21:14:22] *** Joins: rovar (rovar@moz-d89.n7f.126.38.IP)
[21:14:22] *** Joins: alfred (rndm@moz-fg3.o0i.131.104.IP)
[21:14:22] *** Joins: tdfischer (tdfischer@hackerbots.net)
[21:14:22] *** Joins: johnsoft (johnsoft@moz-69mrig.res.rr.com)
[21:14:22] *** Joins: jmesmon (ydoc@moz-naocu2.einic.org)
[21:14:22] *** Joins: Luqman (laden@moz-qhp202.csclub.uwaterloo.ca)
[21:14:22] *** Joins: frewsxcv (frewsxcv@moz-lr4.h2r.241.192.IP)
[21:14:22] *** Joins: adu (ajr@moz-vd1fau.fios.verizon.net)
[21:14:22] *** Joins: bitemyapp (callen@moz-s2l.6j9.199.198.IP)
[21:14:22] *** Joins: geofft (geofft@moz-vfphq1.mit.edu)
[21:14:22] *** Joins: cgaebel (cgaebel@moz-aq9.qj7.199.198.IP)
[21:14:22] *** Joins: burntsushi (burntsushi@moz-t92kn9.ma.charter.com)
[21:14:22] *** Joins: [o__o] ([o__o]@moz-4s2t5k.compute-1.amazonaws.com)
[21:14:22] *** Joins: ctennis (ctennis@moz-0ns.3iq.54.68.IP)
[21:14:22] *** Joins: bstrie (ben@moz-avu3ju.members.linode.com)
[21:14:22] *** Joins: kmcguire_ (kmcguire@moz-pg1gb9.biz.rr.com)
[21:14:22] *** Joins: Sergio (Sergio@moz-23roph.bz)
[21:14:22] *** Joins: achernya (quassel@moz-i01917.mit.edu)
[21:14:22] *** Joins: ytain (ytain@moz-lio.ur1.175.184.IP)
[21:14:22] *** Joins: lu324 (lu324___@moz-3v8ljg.dhcp.embarqhsd.net)
[21:14:22] *** Joins: jmorton (jmorton@moz-83s.irv.199.198.IP)
[21:14:22] *** Joins: WindowsBunny (Peter@moz-gv8vtu.east.verizon.net)
[21:14:22] *** Joins: steveklabnik (steveklabni@moz-kkp.qlp.131.104.IP)
[21:14:22] *** Joins: dustinm (dustinm@moz-9ms.n6q.68.208.IP)
[21:14:22] *** Joins: imperio (Mibbit@moz-8otf3a.fbx.proxad.net)
[21:14:22] *** Joins: pjenvey (pjenvey@moz-ph7jic.org)
[21:14:22] *** Joins: Anchovieshat (cloin@moz-4t5baq.pentaquine.com)
[21:14:22] *** levin.mozilla.org sets mode: +oo bstrie steveklabnik
[21:14:22] *** Joins: tjakubow (tom@moz-kim.9e3.51.173.IP)
[21:14:22] *** Joins: jevin (jevin@moz-sra.ovp.12.72.IP)
[21:14:22] *** Joins: {0}grant ({0}grant@moz-63ubas.in.charter.com)
[21:14:22] *** Joins: lahwran (lahwran@lahwran.net)
[21:14:22] *** Joins: zeiris (zeiris@moz-8jbmam.letter.agency)
[21:14:22] *** Joins: pcwalton (pcwalton@moz-l8ebtf.sfo1.mozilla.com)
[21:14:22] *** Joins: BlakeWilliams (BW@moz-32q.80a.230.173.IP)
[21:14:22] *** Joins: Astrum|Lap (Astrum|Lap@moz-7enfbr.co.comcast.net)
[21:14:22] *** Joins: blank_name (blank_name@moz-mteiba.mi.frontiernet.net)
[21:14:22] *** Joins: srh (User@moz-gk35n7.hfc.comcastbusiness.net)
[21:14:22] *** Joins: kwantam (kwantam@moz-1adqok.DYNAPOOL.NYU.EDU)
[21:14:22] *** Joins: hugod (user@moz-885.jmo.24.70.IP)
[21:14:22] *** levin.mozilla.org sets mode: +o pcwalton
[21:17:08] *** Quits: laumann (thomas@moz-n9e72h.0.fullrate.dk) (Quit: leaving)
[21:17:57] *** Joins: doomlord_mbp (textual@moz-n1nvmt.range109-145.btcentralplus.com)
[21:18:32] *** Quits: doomlord_mbp (textual@moz-n1nvmt.range109-145.btcentralplus.com) (Quit: Textual IRC Client: www.textualapp.com)
[21:20:40] *** Joins: srh_ (User@moz-gk35n7.hfc.comcastbusiness.net)
[21:24:02] *** Quits: srh (User@moz-gk35n7.hfc.comcastbusiness.net) (Ping timeout: 121 seconds)
[21:31:53] *** Quits: avikpal (avikpal@moz-bjs.mde.194.117.IP) (Connection closed)
[21:33:23] *** Joins: jdm (jdm@moz-mu9.06r.98.75.IP)
[21:33:42] <arrrrrrr1> when should a trait be unsafe?
[21:33:42] *** Joins: bjz (bjz@moz-lailbo.tpgi.com.au)
[21:34:16] <imperio> and it does unsafe stuff ? ^^
[21:34:20] *** Quits: bjz (bjz@moz-lailbo.tpgi.com.au) (Quit: My Mac has gone to sleep. ZZZzzz…)
[21:34:26] <imperio> like c function for example
[21:35:02] <bluss> arrrrrrr1: when it asserts a property you rely upon in unsafe code blocks?
[21:35:05] <reem> arrrrrrr1: When code that uses that trait is expected to unsafely rely on an additional invariant encoded by that trait, but which implementors are not actually forced to maintain.
[21:35:24] <reem> thus the `unsafe` at the impl site is an acknowledgement of this unsafe contract
[21:35:29] <arrrrrrr1> when should a function in an unsafe trait be unsafe?
[21:35:41] <arrrrrrr1> if my unsafe trait has one function, should it be unsafe?
[21:35:43] <reem> that follows the normal rules for making functions safe/unsafe
[21:35:48] <reem> Usually not
[21:35:58] <reem> Usually the unsafe trait has a safe method
[21:36:09] <arrrrrrr1> no, it has to be unsafe
[21:36:12] <arrrrrrr1> in this case
[21:36:20] <reem> it's not a rule, so sure
[21:36:29] <arrrrrrr1> reem: https://gist.github.com/anonymous/3748c1e3ef1f23408c79
[21:36:43] <arrrrrrr1> oops, wrong
[21:36:46] <arrrrrrr1> one second
[21:36:52] <reem> ok
[21:36:52] <arrrrrrr1> that's an old version
[21:36:55] *** Quits: eerie (eerie@moz-nbbdu3.red.bezeqint.net) (Connection closed)
[21:37:05] <arrrrrrr1> https://gist.github.com/anonymous/2c42f7d71964d4bc2c96
[21:37:08] <arrrrrrr1> ^
[21:37:33] <reem> DerefMove is just Drop?
[21:37:51] <arrrrrrr1> yep. the Drop function that only drops the container but not the contained values
[21:38:09] <arrrrrrr1> for Vec it sets len to 0 before dropping it
[21:38:19] <arrrrrrr1> because the content has already been dropped by the &out reference
[21:38:25] <reem> hmm
[21:38:41] <reem> y: &out [i32], right?
[21:38:57] <arrrrrrr1> &out [String] in the example
[21:39:03] <arrrrrrr1> oops,
[21:39:12] <arrrrrrr1> well, in the desugared it's strings
[21:39:29] <arrrrrrr1> I changed it to Strings there because i32 has no destructor so it's not that interesting
[21:39:39] <arrrrrrr1> just imagine that the definition of x is the same
[21:39:52] <reem> ok
[21:39:59] <arrrrrrr1> https://gist.github.com/anonymous/0f5a351f3e26dc1995e8
[21:40:03] <arrrrrrr1> ^ Box<[T]>
[21:40:08] <reem> ooh fascinating
[21:40:15] *** Joins: njn (chatzilla@moz-i76q70.iinet.net.au)
[21:40:18] <reem> I understand why this approach works for &out, but can't work for other types
[21:40:22] <reem> since &out has a lifetime
[21:40:44] *** Quits: erickt (erickt@moz-njt.vqi.14.76.IP) (Ping timeout: 121 seconds)
[21:41:16] *** Joins: ipetkov (ipetkov@moz-7vc40j.seas.ucla.edu)
[21:41:18] <reem> arrrrrrr1: How does &out [String] know to deallocate itself?
[21:42:20] <reem> I think that your impl of DerefMove for Vec<T> is incomplete
[21:42:29] <reem> oh nvm
[21:42:38] <arrrrrrr1> reem: that's part of what &out does
[21:42:38] <reem> forgot that it will drop the Vec after
[21:43:13] <arrrrrrr1> &out [String] drops all of it's contents when it goes out of scope
[21:43:22] <reem> arrrrrrr1: I don't thin the mem::transmute(x.deref()) desugaring is ok though
[21:43:34] <arrrrrrr1> reem: that's just how you can write it now
[21:43:41] <arrrrrrr1> in practice the compiler can do what it wants
[21:44:14] <reem> arrrrrrr1: Are you still keeping the rule that you can only acquire &out T from Box<T> and T?
[21:44:29] <arrrrrrr1> reem: no, the point of DerefMove is to drop this requirement
[21:44:35] <reem> that's what I thought
[21:44:51] <reem> I don't see how the reference is acquired in the general case, ten
[21:45:03] <arrrrrrr1> reem: DerefMove: Deref
[21:45:23] <reem> arrrrrrr1: I see. I think that is not safe.
[21:45:34] <arrrrrrr1> example?
[21:45:37] <reem> I'm thinking
[21:45:56] *** Joins: kmcguire (kmcguire@moz-pg1gb9.biz.rr.com)
[21:46:16] <reem> I think it would be better as fn deref_move(&out self) -> &out T anyway
[21:46:48] *** Quits: kmcguire_ (kmcguire@moz-pg1gb9.biz.rr.com) (Connection closed)
[21:46:52] <reem> arrrrrrr1: Hmm, I guess if it's not actually a transmute of a & reference, at least from the compiler's perspective, it's ok
[21:46:55] <arrrrrrr1> you can't write that if self has a destructor
[21:47:13] <arrrrrrr1> because you can't sub &out a struct if it has a destructor
[21:47:31] <arrrrrrr1> the point of DerefMove::drop is that we only run the part of the destructor that doesn't kill the thing we've already moved out
[21:47:33] *** Joins: zmack (zmack@moz-4b0.o8l.26.188.IP)
[21:47:51] <eddyb> uhm, what am I missing again?
[21:48:07] <eddyb> "&out [String] drops all of it's contents when it goes out of scope"
[21:48:13] <eddyb> no, that's what &move [String] does
[21:48:22] <arrrrrrr1> eddyb: I've renamed &move to &out
[21:48:24] *** Joins: kmcguire_ (kmcguire@moz-pg1gb9.biz.rr.com)
[21:48:24] <eddyb> &out T doesn't do anything when it goes out of scope
[21:48:25] *** Quits: kmcguire (kmcguire@moz-pg1gb9.biz.rr.com) (Connection closed)
[21:48:29] <eddyb> arrrrrrr1: sheesh
[21:48:34] <eddyb> arrrrrrr1: you do know they're symmetries, right?
[21:48:44] <arrrrrrr1> eddyb: because &move || { }
[21:48:53] <eddyb> it's like renaming the "electron" to "positron"
[21:49:06] <arrrrrrr1> &in, &out, &move
[21:49:11] <arrrrrrr1> who really knows what all of this means
[21:49:33] <eddyb> well, you're the one using the opposite definition from everyone else :P
[21:49:40] <arrrrrrr1> which one is it: &out = you can move out of this     or &out = this is where you store your output
[21:49:49] <eddyb> arrrrrrr1: out pointers are older than Rust
[21:50:11] <eddyb> that's where &out T came
[21:50:16] <arrrrrrr1> hm
[21:51:03] <eddyb> I call it Slot<T, S> (same S as in Move<T, S>) because "out" is somewhat confusing, as you've astutely just pointed out
[21:51:18] <arrrrrrr1> I really don't know of a good name. Apparently you want &move to take complete ownership and not depend on the source being fixed
[21:51:27] <arrrrrrr1> or something like that
[21:51:36] <eddyb> you can't do much without "something like that"
[21:51:45] <reem> &move seems fine
[21:51:46] <eddyb> I should've made notes of all the issues with &move T
[21:52:11] <arrrrrrr1> eddyb: anyway, tell me why https://gist.github.com/anonymous/2c42f7d71964d4bc2c96 is also a stupid idea
[21:52:11] <eddyb> there is a logic to my madness, I swear :P
[21:52:21] *** Joins: foo (ctennis@moz-vcpg3c.in.comcast.net)
[21:52:21] *** Quits: ctennis (ctennis@moz-0ns.3iq.54.68.IP) (Connection closed)
[21:52:39] <arrrrrrr1> the "desugared" version is of course only an approximation of what the compiler really does
[21:52:42] <eddyb> arrrrrrr1: nmatsakis had something like that in mind
[21:53:00] <eddyb> it only serves &move T
[21:53:22] <eddyb> (the borrowed one)
[21:53:49] <eddyb> arrrrrrr1: I guess you also want a method for the actual pointer
[21:54:04] <arrrrrrr1> eddyb: DerefMove: Deref which already gives me a pointer
[21:54:17] <arrrrrrr1> not sure if there has to be a separate method
[21:54:23] <arrrrrrr1> maybe that's more flexible
[21:54:29] <eddyb> arrrrrrr1: deref and deref_mut are two methods
[21:54:35] <arrrrrrr1> true
[21:54:40] *** Quits: foo (ctennis@moz-vcpg3c.in.comcast.net) (Quit: Linkinus - http://linkinus.com)
[21:55:18] <arrrrrrr1> eddyb: but people are supposedly allowed to call deref_mut normally. deref_move would also have to be unsafe because you have to call drop manually if you don't rely on compile support
[21:55:46] <arrrrrrr1> in any cause deref_move would have to take &self which is kind of odd
[21:56:15] *** Quits: zmack (zmack@moz-4b0.o8l.26.188.IP) (Connection closed)
[21:56:32] <eddyb> arrrrrrr1: you're not far from glaebhoerl's original thoughts on fixing the cleanup issue of DerefMove
[21:57:12] <eddyb> which was unsatisfactory at the time - and didn't support genericity - so I came up with that Move<T, S> thing
[21:57:38] *** Joins: eerie (eerie@moz-nbbdu3.red.bezeqint.net)
[21:57:44] *** Joins: zmack (zmack@moz-4b0.o8l.26.188.IP)
[21:57:53] <eddyb> at this rate... you might have an improvement for that in a few days, which is better than where I am with it right now :)
[21:58:05] *** Joins: ctennis (ctennis@moz-vcpg3c.in.comcast.net)
[22:02:05] *** Quits: sigma (sigma@moz-a5u.m43.48.37.IP) (Connection closed)
[22:02:06] *** Joins: tcurdt (tcurdt@moz-m3gqr9.dip0.t-ipconnect.de)
[22:03:45] <eddyb> arrrrrrr1: maybe this clears up my earlier requirements a bit: I expect a FromIterator impl that doesn't mention Vec<T> and yet it allows me to write vec![x, y].into_iter(), where the resulting type is 'static, for T: 'static
[22:04:21] *** Joins: dinfuehr (dinfuehr@moz-r4qvpb.highway.telekom.at)
[22:05:30] *** Quits: swgillespie (swgillespie@moz-upj.3un.220.167.IP) (Quit: My MacBook Pro has gone to sleep. ZZZzzz…)
[22:05:32] *** Joins: kmcguire (kmcguire@moz-pg1gb9.biz.rr.com)
[22:05:35] *** Quits: kmcguire_ (kmcguire@moz-pg1gb9.biz.rr.com) (Connection closed)
[22:05:46] <arrrrrrr1> FromIterator? into_iter?
[22:06:29] <arrrrrrr1> I guess you mean IntoIterator
[22:07:00] *** Quits: adu (ajr@moz-vd1fau.fios.verizon.net) (Ping timeout: 121 seconds)
[22:08:25] *** Quits: dinfuehr (dinfuehr@moz-r4qvpb.highway.telekom.at) (Ping timeout: 121 seconds)
[22:08:51] <eddyb> yes, sorry
[22:09:18] *** Joins: kmcguire_ (kmcguire@moz-pg1gb9.biz.rr.com)
[22:09:39] *** Quits: kmcguire (kmcguire@moz-pg1gb9.biz.rr.com) (Connection closed)
[22:09:46] *** Joins: swgillespie (swgillespie@moz-upj.3un.220.167.IP)
[22:10:59] *** Quits: srh_ (User@moz-gk35n7.hfc.comcastbusiness.net) (Quit: Leaving)
[22:13:15] <arrrrrrr1> eddyb: the first iteration would have done exactly that I think but I didn't like the size of &move [T]
[22:19:01] *** Quits: eerie (eerie@moz-nbbdu3.red.bezeqint.net) (Connection closed)
[22:19:03] *** Joins: eerie (eerie@moz-nbbdu3.red.bezeqint.net)
[22:19:19] *** Quits: eerie (eerie@moz-nbbdu3.red.bezeqint.net) (Connection closed)
[22:22:17] *** Quits: zmack (zmack@moz-4b0.o8l.26.188.IP) (Connection closed)
[22:25:16] * brson still workingo on making undeclared features errors
[22:26:16] *** Quits: Astrum|Lap (Astrum|Lap@moz-7enfbr.co.comcast.net) (Client exited)
[22:26:30] <nrc> acrichto: apologies if you've been having problems using the triage tool - it should work now (I was testing <= 0 instead of < 0 and you were first on the list, so it didn't count you as a valid triager)
[22:28:03] <arrrrrrr1> reem: got an alternative name for &move and &out that is neither ambiguous in rust nor known from other languages with different meaning? someone suggested &owning
[22:28:12] <acrichto> nrc: I see how it is, you just don't respect my nominations!
[22:28:14] <acrichto> :)
[22:28:42] <nrc> damn, he sussed me out!
[22:28:45] *** Joins: pnkfelix (pnkfelix@moz-eljppb.fbx.proxad.net)
[22:28:45] *** ChanServ sets mode: +o pnkfelix
[22:28:55] * acrichto nominates the world
[22:29:01] <reem> arrrrrrr1: I prefer &move, is there a reason against it?
[22:29:13] <arrrrrrr1> reem: bstrie mentioned &move || ..
[22:29:23] <reem> ugh
[22:29:40] <simukis> so, why are we inventing a new reftype?
[22:29:42] <reem> &owned &own
[22:29:58] <reem> &own is good because it's three letters, so it'll line up nicely with mut
[22:30:15] <reem> (like &out, but I think we want &out for out-pointers)
[22:30:20] <arrrrrrr1> yeah but it might also be a reference to another element in a struct if we ever get something like that
[22:30:34] <reem> You can already do that
[22:30:46] <arrrrrrr1> so one field in the struct is an &own to another field
[22:31:03] <reem> I doubt we'd ever get that in the language since it wouldn't be better than the Cell<Option<&'a T>> trick since you wouldn't be able to move it anyway
[22:31:20] *** Quits: topolinux (paolo@moz-es8.ls8.75.151.IP) (Quit: Sto andando via)
[22:31:38] <arrrrrrr1> ok, &own it is
[22:31:40] <arrrrrrr1> for now...
[22:32:43] <reem> (the shed is my color! the shed is my color! :P)
[22:33:22] <simukis> so, what’s the reason for having that shed at all?
[22:33:41] <arrrrrrr1> there is an RFC
[22:34:23] <simukis> the &out one?
[22:34:27] <nrc> damn, the triage tool seems like it went 1.0 beta crazy
[22:34:29] <arrrrrrr1> soon to be &own
[22:34:37] <reem> simukis: It is useful to be able to pass around dynamically sized types in an owning fashion without allocating
[22:35:16] <arrrrrrr1> got a large type that you want to pass through a long chain of function calls? you better &own it
[22:35:40] <reem> we have &'a T, a shared reference to anywhere, &'a mut T, a unique, non-owning reference to anywhere, and Box<T>, a unique owning reference to a heap allocate. We are missing &'a own T, which is a unique owning reference to anywhere.
[22:35:50] <arrrrrrr1> simukis: consider moving out of &own Any. can't do that right now.
[22:37:24] <simukis> reem: &own T being a superset of Box, I believe we should get rid of box with this as well
[22:37:39] <arrrrrrr1> simukis: do you mean the keyword or the type?
[22:37:48] <simukis> the type and everything related to it
[22:38:05] <arrrrrrr1> simukis: how do you create a Box<Trait> without Box?
[22:38:12] <simukis> &own Trait.
[22:38:22] <arrrrrrr1> simukis: that doesn't have static lifetime
[22:38:43] <arrrrrrr1> &own is not a superset of Box. it's still just a reference
[22:39:35] <simukis> well, Box<T> is basically a reference to T as well.
[22:39:44] <arrrrrrr1> but with static lifetime if T has static lifetime
[22:41:06] *** Quits: burntsushi (burntsushi@moz-t92kn9.ma.charter.com) (Ping timeout: 121 seconds)
[22:42:11] <simukis> arrrrrrr1: what forbids you from infering static lifetime for &own?
[22:42:13] <reem> whereas &'a own T still has lifetime 'a even if T: 'static
[22:42:23] <reem> simukis: It could still point to a stack allocation
[22:42:40] <simukis> reem: stack allocation won’t have 'static, will it?
[22:42:44] <arrrrrrr1> yes
[22:42:50] <reem> You could replace Box::new with a special function that allocates and returned an &'static own T
[22:42:57] <reem> that points to a heap allocation
[22:43:06] <arrrrrrr1> simukis: and you can't take an &own of a static variable because you can't move out of static variables
[22:43:12] <simukis> reem: that’s what `box` could do, pretty much
[22:43:17] *** Quits: Guest63 (textual@moz-56c.qli.61.176.IP) (Quit: My Mac has gone to sleep. ZZZzzz…)
[22:43:23] <reem> arrrrrrr1: &'static own T has weird semantics
[22:43:24] <simukis> box the keyword.
[22:43:32] <reem> arrrrrrr1: In terms of when it is cleaned up
[22:43:42] <arrrrrrr1> you can't create a &'static own I think
[22:43:46] *** Quits: tcurdt (tcurdt@moz-m3gqr9.dip0.t-ipconnect.de) (Quit: Textual IRC Client: www.textualapp.com)
[22:43:50] <reem> unsafely
[22:43:55] <reem> Hmm
[22:43:59] <reem> I guess there's no way to clean it up
[22:44:01] <arrrrrrr1> sure, then it's cleaned up when it's dropped
[22:44:17] <arrrrrrr1> drop(&own STATIC_VARIABLE) will move out of the static variable right then and there
[22:44:38] <simukis> arrrrrrr1: you just said yourself you can’t move out from statics
[22:44:47] <reem> arrrrrrr1: I more meant let owned_ref = mem::transmute::<*mut _, &own _>(allocate())
[22:44:53] *** Joins: jethrogb (jethrob@moz-p2iedd.scintilla.utwente.nl)
[22:44:58] <reem> s/&own/&'static own _
[22:45:06] <arrrrrrr1> simukis: you can't create an &own STATIC_VARIABLE safely. but if you do via transmute then that is what will happen
[22:45:33] <reem> simukis: You still need Box because Box needs to know about how to deallocate itself, and &'static own T doesn't how to deallocate itself
[22:45:34] <simukis> arrrrrrr1: you don’t have to consider cases where unsafe code is involved.
[22:45:48] <arrrrrrr1> simukis: reem mentioned unsafety
[22:46:05] <arrrrrrr1> I just wanted to clear up what happens when you do this
[22:51:24] <simukis> hmm, I don’t know. Annoying voice inside my head says that this could be implemented as a library(-ish), not unlike Box, rather than adding to the language
[22:52:03] *** Joins: munksgaard (munksgaard@moz-478pev.u.parknet.dk)
[22:52:07] *** Quits: swgillespie (swgillespie@moz-upj.3un.220.167.IP) (Quit: My MacBook Pro has gone to sleep. ZZZzzz…)
[22:52:33] <arrrrrrr1> simukis: what would be the type signature of an &own T reference?
[22:52:41] <arrrrrrr1> if implemented as a type
[22:52:47] <arrrrrrr1> in a library I mean
[22:52:50] <simukis> will read this more closely with a clearer head tomorrow.
[22:53:19] <simukis> arrrrrrr1: instinctively I think about `Box` for which `new()` does no allocation.
[22:53:40] <reem> simukis: That's just T
[23:01:09] *** Joins: swgillespie (swgillespie@moz-upj.3un.220.167.IP)
[23:01:22] *** Quits: killercup (killercup@moz-edmf2j.dip0.t-ipconnect.de) (Ping timeout: 121 seconds)
[23:03:35] *** Joins: mystor (mystor@moz-vpa.r78.15.130.IP)
[23:03:49] *** Quits: swgillespie (swgillespie@moz-upj.3un.220.167.IP) (Quit: My MacBook Pro has gone to sleep. ZZZzzz…)
[23:05:22] *** Joins: swgillespie (swgillespie@moz-upj.3un.220.167.IP)
[23:06:46] *** Quits: simukis (nagisa@moz-8t068g.static.zebra.lt) (Ping timeout: 121 seconds)
[23:12:47] *** Quits: kmcguire_ (kmcguire@moz-pg1gb9.biz.rr.com) (Ping timeout: 121 seconds)
[23:13:14] *** Joins: kmcguire (kmcguire@moz-pg1gb9.biz.rr.com)
[23:16:06] *** Quits: tjakubow (tom@moz-kim.9e3.51.173.IP) (Ping timeout: 121 seconds)
[23:17:21] *** Quits: _zxq9_ (ceverett@moz-qsm369.mesh.ad.jp) (Quit: Konversation terminated!)
[23:18:12] *** Quits: imperio (Mibbit@moz-8otf3a.fbx.proxad.net) (Quit: http://www.mibbit.com ajax IRC Client)
[23:19:17] *** Quits: ipetkov (ipetkov@moz-7vc40j.seas.ucla.edu) (Client exited)
[23:19:40] *** Quits: jdm (jdm@moz-mu9.06r.98.75.IP) (Quit: )
[23:22:10] *** Joins: quaddle (Mibbit@moz-juv.9o3.252.72.IP)
[23:22:40] *** Quits: quaddle (Mibbit@moz-juv.9o3.252.72.IP) (Quit: http://www.mibbit.com ajax IRC Client)
[23:27:35] *** Quits: Sindriava (textual@moz-ca79jq.broadband10.iol.cz) (Quit: My Mac has gone to sleep. ZZZzzz…)
[23:28:55] <arrrrrrr1> why does impl<'a> &'a T { } not work?
[23:29:18] <arrrrrrr1> you can even do impl Trait { }. why not this?
[23:31:20] *** Joins: tjakubow (tom@moz-ag87jj.fios.verizon.net)
[23:34:18] *** Quits: o11c (ben@moz-9bd9kh.customer.t3.se) (Ping timeout: 121 seconds)
[23:34:34] <acrichto> aturon: ping
[23:42:37] *** nrc is now known as nrc|afk
[23:45:43] *** Quits: eibwen (eibwen@moz-42bprd.dip0.t-ipconnect.de) (Ping timeout: 121 seconds)
[23:45:46] *** Quits: joneshf-laptop (joneshf@moz-ls5uph.ucdavis.edu) (Connection closed)
[23:50:54] <kimundi> playbot: struct Foo; impl<'a> &'a Foo { fn bar(){} }
[23:50:55] -playbot- <anon>:14:21: 14:52 error: no base type found for inherent implementation; implement a trait or new type instead [E0118]
[23:50:55] -playbot- <anon>:14         struct Foo; impl<'a> &'a Foo { fn bar(){} }
[23:50:55] -playbot- output truncated; full output at: http://bit.ly/1E6Wyod
[23:51:31] *** Quits: ytain (ytain@moz-lio.ur1.175.184.IP) (Quit: Textual IRC Client: www.textualapp.com)
[23:53:11] *** Joins: arrrrrrrrr (arrrrrrrrs@moz-6p13k2.dynamic.qsc.de)
[23:53:22] *** Quits: munksgaard (munksgaard@moz-478pev.u.parknet.dk) (Ping timeout: 121 seconds)
[23:55:46] <arrrrrrrrr> reem: I realized that we don't actually need DerefMove
[23:55:57] *** Quits: arrrrrrr1 (arrrrrrrrs@moz-c0r0b0.dynamic.qsc.de) (Ping timeout: 121 seconds)
[23:56:09] <reem> arrrrrrrrr: Oh?
[23:56:23] <arrrrrrrrr> I was looking through the stdlib to see which structs implement DerefMut and saw that VecDeque doesn't do it because it consists of two separate slices
[23:56:40] <arrrrrrrrr> instead it has a function called as_slices()
[23:56:52] <arrrrrrrrr> so I wrote this:
[23:57:10] <arrrrrrrrr> https://gist.github.com/anonymous/bf62f636c657c3e5e1f0
[23:57:11] *** Joins: japaric (japaric@moz-663.3tp.232.190.IP)
[23:57:36] <arrrrrrrrr> reem: this is even better because you can continue using the VecDeque after the slices have been dropped
[23:57:47] <arrrrrrrrr> it's just an empty VecDeque at that point
[23:58:03] <reem> Very similar to drain
[23:58:15] <arrrrrrrrr> reem: exactly, just better because you have random access
[23:58:24] <reem> Wow it's so close to drain I can't believe I never made the connection
[23:58:59] <reem> this requires option dancing for normal types though
[23:59:31] <reem> or actually...
[23:59:32] <reem> it doesn't
[23:59:55] <arrrrrrrrr> >I also found the name &out confusing. I was expecting something completely different from the name, than what the RFC actually describes.
[23:59:55] <reem> You can only implement this for types which (internally) manage memory unsafely
[23:59:58] <arrrrrrrrr> panic

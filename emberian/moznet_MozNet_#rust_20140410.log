[00:00:21] *** Joins: dotfelix (dotfelix@C1C963C6.AB3AC796.40E092AA.IP)
[00:00:26] *** Joins: ChrisMorgan (chris@moz-5889E428.static.tpgi.com.au)
[00:00:41] *** Quits: Ralith (ralith@A8995AA9.62B6AF6A.922221DB.IP) (Ping timeout)
[00:03:11] *** Joins: james4k (james@moz-9BB5AE72.consolidated.net)
[00:03:11] *** Quits: ChrisMorgan (chris@moz-5889E428.static.tpgi.com.au) (Connection reset by peer)
[00:04:03] <doomlord_> can anyone make an RFC or is it just something the core team uses
[00:04:27] <Earnestly> Anyone can it seems
[00:05:54] *** Quits: iliekturtles (mike@moz-3B68092A.hsd1.me.comcast.net) (Quit: leaving)
[00:05:59] *** Joins: iliekturtles (mike@moz-3B68092A.hsd1.me.comcast.net)
[00:06:51] *** Quits: luziie (luziie@moz-CD18B14B.customer.cdi.no) (Connection reset by peer)
[00:07:24] *** Joins: ChrisMorgan (chris@moz-5889E428.static.tpgi.com.au)
[00:07:46] *** Quits: dotfelix (dotfelix@C1C963C6.AB3AC796.40E092AA.IP) (Ping timeout)
[00:08:15] *** Joins: luzie (lu.cy@moz-CD18B14B.customer.cdi.no)
[00:08:24] <pyon> I have an &(A, B).
[00:08:31] <pyon> How do I extract references to the tuple's components?
[00:08:57] <pyon> Is there no shorter way other than "let &(ref a, ref b) = ab;" ?
[00:09:02] *** Quits: ktt3ja (ktt3ja@moz-8D2A07E1.hsd1.va.comcast.net) (Quit: Leaving)
[00:09:08] *** Joins: JamesNZ (james@moz-264643C7.bitstream.orcon.net.nz)
[00:09:45] *** Quits: jvoorhis (jvoorhis@moz-C34F9C32.hfc.comcastbusiness.net) (Client exited)
[00:10:07] *** Joins: jvoorhis (jvoorhis@moz-C34F9C32.hfc.comcastbusiness.net)
[00:10:16] *** Quits: frozendevil (Adium@moz-62FB197F.com) (Quit: Leaving.)
[00:10:37] *** Quits: ChrisMorgan (chris@moz-5889E428.static.tpgi.com.au) (No route to host)
[00:10:41] <mcpherrin> rusti: let mut a = &('a', 'b'); a.mut0() = 'q'; a
[00:10:45] -rusti- pastebinned 8 lines of output: http://ix.io/bBr
[00:10:47] *** Quits: mawuli (mawuli@F7A4F2ED.68EE7C48.E520B65A.IP) (Ping timeout)
[00:11:37] <mcpherrin> rusti: let mut a = &('a', 'b'); let r = a.mut0(); println!("{}", r);
[00:11:39] -rusti- pastebinned 8 lines of output: http://ix.io/bBs
[00:11:48] *** Quits: jvoorhis (jvoorhis@moz-C34F9C32.hfc.comcastbusiness.net) (Ping timeout)
[00:11:52] <doomlord_> i think i prefer ref therr
[00:12:19] <pyon> ah :-)
[00:12:20] <pyon> thanks
[00:13:09] *** Quits: brendan (brendaneic@moz-C07D5168.p2p.sfo1.mozilla.com) (Quit: brendan)
[00:13:49] *** Quits: erickt (etryzelaar@8C9ECD8F.3A598286.F12515B4.IP) (Ping timeout)
[00:14:30] *** Quits: nszceta (nszceta@moz-E458A7C0.pharm.pitt.edu) (Quit: Textual IRC Client: www.textualapp.com)
[00:15:39] *** Joins: cschneid (cschneid@moz-20C37083.hlrn.qwest.net)
[00:16:07] *** Quits: bjz (bjz@B398BE78.F804C29E.D35A31DF.IP) (Ping timeout)
[00:17:28] *** Joins: jroweboy (jrowe7@moz-18814A6B.provo.static.broadweavenetworks.net)
[00:18:12] *** Quits: twi (Adium@moz-DE601661.cust.vodafonedsl.it) (Quit: Leaving.)
[00:18:16] *** Joins: bjz (bjz@B398BE78.F804C29E.D35A31DF.IP)
[00:19:35] <jroweboy> is there a way to catch to see if a task killed itself via fail!()? I don't remember where but I recall seeing something about a try!() macro and some small documentation about recovering from task failure but I can't seem to find it again
[00:21:26] *** Joins: erickt (etryzelaar@8C9ECD8F.3A598286.F12515B4.IP)
[00:22:17] <jroweboy> Oh found the page for macros in std, looks like try is not related at all :)
[00:22:42] <pyon> jroweboy: have a look at how mutexes are poisoned in the sync library
[00:23:06] *** Joins: carllerche (carllerche@moz-CA3FF5F1.hsd1.or.comcast.net)
[00:23:45] *** Quits: erickt (etryzelaar@8C9ECD8F.3A598286.F12515B4.IP) (Ping timeout)
[00:24:01] <pyon> jroweboy: http://static.rust-lang.org/doc/master/std/task/fn.failing.html -- perhaps this?
[00:24:38] <iliekturtles> exit
[00:24:40] *** Quits: iliekturtles (mike@moz-3B68092A.hsd1.me.comcast.net) (Quit: leaving)
[00:24:47] *** Joins: iliekturtles (mike@moz-3B68092A.hsd1.me.comcast.net)
[00:28:09] *** Joins: andelf (nobody@C6CA2C20.60D6AFF3.1CD28F1D.IP)
[00:28:16] <brson> pyon: std::task::try is probably what you want
[00:28:21] <brson> that tells you if *another* task failed
[00:28:27] *** Quits: DAddYE (DAddYE@moz-61EB081B.hfc.comcastbusiness.net) (Quit: Leaving...)
[00:28:42] *** Quits: JustAPerson (JustAPerso@EAC6AADA.C1481309.D9401097.IP) (Ping timeout)
[00:28:45] <pyon> ah!
[00:29:10] <jroweboy> pyon: Looking at the failing function, I wonder exactly how one should use it? So say my function is calling another function that will fail, then when the stack is unwinding, why would it bother to call the failing function?
[00:29:33] *** Joins: spektroskop (spektro@moz-6E21B297.getinternet.no)
[00:30:15] *** Quits: andelf (nobody@C6CA2C20.60D6AFF3.1CD28F1D.IP) (Quit: Mango IRC for iOS and OS X, http://mediaware.sk/mango)
[00:30:17] *** Joins: JustAPerson (JustAPerso@EAC6AADA.C1481309.D9401097.IP)
[00:30:33] *** Quits: TopHattedCoder (tom@moz-5F177A89.cable.virginm.net) (Quit: Leaving.)
[00:31:15] *** Quits: spektroskop (spektro@moz-6E21B297.getinternet.no) (Ping timeout)
[00:31:16] *** Quits: Sharp (Sharp@moz-3301C7AB.static-ip.telepacific.net) (Quit: Sharp)
[00:31:33] *** Joins: ChrisMorgan (chris@moz-5889E428.static.tpgi.com.au)
[00:31:52] *** Joins: Ralith (ralith@moz-67D4EB93.customer.broadstripe.net)
[00:31:59] <jroweboy> I mean, say that fn a is hardcoded to fail!(), then fn main() { a(); if std::task::failing() { do something } } doesn't seem like that will work (but I haven't actually tried it :D )
[00:32:17] *** Quits: JustAPerson (JustAPerso@EAC6AADA.C1481309.D9401097.IP) (Ping timeout)
[00:33:31] *** Quits: tobytailor (tobytailor@moz-CBD810C7.hsd1.ca.comcast.net) (Quit: tobytailor)
[00:33:36] *** Joins: frozendevil (Adium@moz-A9D8109F.hsd1.wa.comcast.net)
[00:33:46] *** Joins: dotfelix (dotfelix@D25DD106.AB3AC796.40E092AA.IP)
[00:33:57] *** Quits: hdevalence (quassel@moz-D125A39F.home3.cgocable.net) (Connection reset by peer)
[00:34:18] *** Joins: jensnockert (jensnocker@moz-33279404.customers.ownit.se)
[00:34:49] *** Quits: adonohue (adonohue@55513BD.95D3F462.59D8BB03.IP) (Quit: adonohue)
[00:34:56] *** Quits: maxli1 (Adium@moz-B19F68ED.student.cs.uwaterloo.ca) (Quit: Leaving.)
[00:36:03] *** Quits: jensnockert (jensnocker@moz-33279404.customers.ownit.se) (Ping timeout)
[00:36:29] *** Joins: DAddYE (DAddYE@moz-61EB081B.hfc.comcastbusiness.net)
[00:36:54] <jroweboy> brson: In my case though, I worry that it would be a little excessive to spawn a new proc when my code where I want to check if the task is failing is already in a proc.
[00:37:26] *** Quits: iliekturtles (mike@moz-3B68092A.hsd1.me.comcast.net) (Quit: Changing server)
[00:37:30] *** Joins: iliekturtles (mike@moz-3B68092A.hsd1.me.comcast.net)
[00:37:42] <burntsushi> is there a way to convert a [T, ..N] to a Vec<T> without allocating? (possibly using unsafe)
[00:38:07] <burntsushi> s/allocating/copying
[00:38:40] *** Joins: infynyxx (infynyxx@DB780A29.749BA1D.DCC373F0.IP)
[00:39:15] *** Joins: maxli (Adium@moz-B19F68ED.student.cs.uwaterloo.ca)
[00:40:27] *** Quits: infynyxx (infynyxx@DB780A29.749BA1D.DCC373F0.IP) (Ping timeout)
[00:40:36] <burntsushi> or perhaps an &'static [T] to a Vec<T>
[00:40:37] <doomlord_> how did you create the [T,..N]
[00:40:56] <doomlord_> the Vec<T> would own it - static is permanent so it doesn't need to be owned
[00:41:45] <doomlord_> i think the plan is you can coerce [T,..N] to slices , you only need a vector for push back.. growing
[00:42:19] <burntsushi> i'm working on a syntax extension and trying to reconstruct my representation which wants a Vec<T>.
[00:42:21] *** Joins: bgamari (ben@moz-467E4786.spfdma.east.verizon.net)
[00:42:38] *** Quits: derek_c (derek@moz-7E31A72.cit.cornell.edu) (Ping timeout)
[00:42:45] *** Joins: atomit (textual@moz-C4708075.hsd1.ca.comcast.net)
[00:43:01] <burntsushi> so basically, i want to write some AST which constructs a Vec<T>.
[00:43:01] *** Joins: erickt (etryzelaar@8C9ECD8F.3A598286.F12515B4.IP)
[00:43:20] <doomlord_> anythign that takes a Vec as an input should in principle be able to take a slice instead, but, you need a vec if you are ever going to append to it
[00:43:56] <doomlord_> they are going to use [T] for slices, i think there's a Slice<T> at the moment, i dont know how coercisions work, there might get .as_slice or something
[00:44:02] *** Joins: Jesin (Jesin@moz-3A2C5D36.washdc.fios.verizon.net)
[00:44:16] <brson> jroweboy: then task::failing may be what you are looking for then after all. it tells you whether the current task is in the process of failing
[00:44:24] <doomlord_> if you really want a vec you'd have to copy it into a new dynamic allocation, i think the point of Vec is it is dynamic allocation
[00:45:11] *** Quits: erickt (etryzelaar@8C9ECD8F.3A598286.F12515B4.IP) (Ping timeout)
[00:45:45] <burntsushi> doomlord_: i guess my problem with using slices is that i'm not sure who the owner would be.
[00:46:07] <burntsushi> once my representation is built (it's a regexp), i no longer need to append to it.
[00:46:08] <doomlord_> well if you want to turn a 'static .. the owner is 'static
[00:46:18] <doomlord_> so you can't have a vec owning it really
[00:46:36] <doomlord_> slices on the other hand can represent a borrowed view
[00:46:38] *** Quits: thewonderidiot (mstewart@moz-E41129BA.ipnetworksinc.net) (Quit: Leaving.)
[00:46:40] *** Joins: JustAPerson (JustAPerso@EAC6AADA.C1481309.D9401097.IP)
[00:47:01] *** Quits: johnsoft (johnsoft@moz-7E09A266.neo.res.rr.com) (Ping timeout)
[00:47:11] <doomlord_> why did do you need to turn 'static into a vec in the first place
[00:47:20] *** Quits: leowoe (Leo@moz-91395654.dip0.t-ipconnect.de) (Quit: Leaving.)
[00:47:23] <burntsushi> it can't be 'static because the regexp can be built at any time. i mentioned 'static before as a way to *write* the regexp's representation at compile time with a syntax extension
[00:47:25] *** Joins: johnsoft (johnsoft@moz-7E09A266.neo.res.rr.com)
[00:47:50] <doomlord_> if you have code that accepts input, i think you can ask for a slice
[00:48:19] <doomlord_> they say you will be able to coerce [T,..N] into a slice for sure,
[00:48:20] *** Quits: q66 (q66@moz-3A46E7D1.range81-129.btcentralplus.com) (Ping timeout)
[00:48:23] <burntsushi> the code accepts a string and then compiles it to a regexp. i could of course tie the life time of the given string to the compiled regexp, but i'm not sure that's a good idea.
[00:48:28] <doomlord_> i dont know if you can now, but i've seen there is a Slice<T>
[00:48:37] <doomlord_> if its static .. not dynamic.. then you dont need a Vec
[00:48:43] <doomlord_> a slice should suffice
[00:49:00] <doomlord_> a vec is an owning pointer plus capacity for growing
[00:49:04] <burntsushi> normal operation is dynamic. a regexp can be compiled from any arbitrary string.
[00:49:12] <doomlord_> well then you have no choice do you
[00:49:19] *** Quits: dotfelix (dotfelix@D25DD106.AB3AC796.40E092AA.IP) (Quit: )
[00:49:25] <burntsushi> in that case, yes, i agree.
[00:49:33] <burntsushi> but i'm trying to get compile-time safe regexps.
[00:49:42] <doomlord_> you'll need to copy it. i can see another option with HKT :) 
[00:49:59] <doomlord_> perhaps you can make a macro to generate your regex structure with either Slice or Vec
[00:50:24] <burntsushi> yes! that's what i'm trying to do :-)
[00:50:25] <doomlord_> with HKT that would be natural  Regex<CollectionType>    Regex<Slice> or Regex<Vec> ..
[00:50:41] <doomlord_> i mean 2 versions of the actual stucture, not the instantiation of data
[00:50:52] <doomlord_> so you can have static ones, or dynamic ones
[00:51:04] <burntsushi> ah, i see... hmm.
[00:51:09] <burntsushi> that's an interesting thought.
[00:51:31] <doomlord_> perhaps you should write it up to explain a use case for HKT , some people are skeptical you'd ever need that :)
[00:51:56] <doomlord_> i've seen similar cases myself... representing the same datastructure but either in a more dynamic form or more static form
[00:52:25] *** Quits: Jesse (jruderman@moz-9754CB0.hsd1.ca.comcast.net) (Ping timeout)
[00:52:35] <kasey> Can someone take a look at my pull request? (https://github.com/mozilla/rust/pull/13371)
[00:52:35] <kasey> I can't figure out what would cause the test to fail, and it works on my machine (Linux Mint).
[00:52:35] <burntsushi> yeah, it would be an interesting use case. 
[00:52:59] <jroweboy> brson: I'm having trouble finding how to use failing() the only place I have seen it called from is the destructor for PoisonOnFail and that is in a special destructor they made for it. Should I do something similar by making a Drop implementation for my struct that catches a failing case and handles that before finishing failing?
[00:53:38] <doomlord_> burntsushi, i think you can do this with macros now, its just not as elegant as HKT would be, but similarly the fact macros CAN workaround means HKT is probably a low priority
[00:54:24] <burntsushi> doomlord_: yeah. well, the problem still is that if i have &'static, i very much don't want to copy that into a Vec<T>.
[00:54:42] <burntsushi> part of the point of a compile time regexp is that you don't have to pay for compiling the regexp
[00:54:42] <doomlord_> burntsushi, i wonder if its possible to make an unsafe hack to do what you want - point a vec directly at your static data... but you would have to know it can't be reallocated...
[00:54:59] <burntsushi> doomlord_: yeah, that's exactly the question i intended to ask.
[00:55:09] <doomlord_> heh. maybe let capacity=0, but size>0 actually indicate its static data.
[00:55:18] *** Joins: zevras (Mibbit@moz-6BD0CBDD.gvllcmtc01.gnvlnc.ab.dh.suddenlink.net)
[00:55:18] *** Joins: Sharp (Sharp@moz-633F3606.hsd1.ca.comcast.net)
[00:55:19] <burntsushi> there is Vec::from_raw_parts, but i don't know how to use it.
[00:55:29] <zevras> What's the current status of Rust IDE supports?
[00:55:41] <doomlord_> zevras i dont think we'll get IDE support any time soon
[00:55:46] *** Joins: radford (Adium@moz-9E6BD4E4.static.mtpk.ca.charter.com)
[00:55:47] *** Quits: Florob (Florob@moz-39532932.de) (Client exited)
[00:56:00] <brson> jroweboy: to make finally ever return true you need to ensure that it actually runs, and to do that it must be called from drop, yes
[00:56:02] <doomlord_> there are various disjoint efforts but i dont know of anything that does serious completion
[00:56:16] <burntsushi> doomlord_: isn't the definition of 'static that the data survives for the lifetime of the ... task?
[00:56:17] <brson> jroweboy: you can use std::unstable::finally too, but it's a bit out of favor
[00:56:26] <brson> jroweboy: finally is just sugar for running in a drop block
[00:56:30] <doomlord_> 'static is the lifetime of the entire program
[00:56:33] *** Joins: Florob (Florob@moz-39532932.de)
[00:57:48] <burntsushi> right. so now i'm basically left with somehow shoe-horning a [T, ..N] or a &'static [T] into a Vec<T> without copying. 
[00:57:49] *** Joins: Jesse (jruderman@moz-9754CB0.hsd1.ca.comcast.net)
[00:57:55] <doomlord_> zevras I think the compiler source isn't stable enough to allow IDE support, there's work needed to generate an incomplete AST
[00:58:00] <burntsushi> there's only one use of from_raw_parts in the stdlib (libsyntax/owned_slice.rs)
[00:58:02] <doomlord_> its a moving target, 
[00:58:13] <zevras> doomlord_: Anything that even has good syntax highlighting?
[00:58:16] <pingveno> I have an toy project that I'm about to start porting from Python. It needs regexp support, so I can use it to test out a regexp library.
[00:58:29] <pingveno> Which library should I go for?
[00:58:33] <doomlord_> there is plenty of good syntax highlighting. emacs, scintilla, vi, gedit
[00:58:38] <burntsushi> pingveno: https://github.com/BurntSushi/regexp is what i'm working on now.
[00:58:45] <doomlord_> kate
[00:58:45] <kasey> Sublime too
[00:58:54] <burntsushi> errm
[00:59:06] <burntsushi> https://github.com/BurntSushi/re2
[00:59:22] <doomlord_> zevras, i have hacked emacs to look up rustdoc from a symbol; and i've written a HTML  view of sourcecode for following links
[01:00:46] *** Joins: cmr (moznet@moz-EC676DFE.members.linode.com)
[01:03:50] *** Joins: cmr (moznet@moz-EC676DFE.members.linode.com)
[01:04:06] <burntsushi> sfackler: i think i was reading your stuff about syntax extensions---fourcc, the sort! and the phf map?

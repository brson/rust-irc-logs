[00:01:41] <kmc> eternaleye: you can argue to instead use a completely different backend for compiling constant time code
[00:02:02] <kmc> nadeko is an example of that approach
[00:02:28] <bascule> < eternaleye> One thing I'd really like is if LLVM could annotate instructions with a constant-time bound
[00:02:38] <bascule> my understand is brson and pcwalton asked the LLVM people about that
[00:02:42] <kmc> it implements non-optimizing, constant-time(*) codegen for a rust subset / dialect
[00:02:42] <bascule> and the answer was tl;dr: no
[00:02:48] <bascule> and yeah, nadeko! :D
[00:02:54] <kmc> (*) except, CPU manufacturers don't really guarantee any constant-time instructions :/
[00:02:59] <bascule> lolololol
[00:03:08] <bascule> best effort constant time! :D
[00:03:14] <kmc> there are cases where mul $0 gets optimized out, etc.
[00:05:50] <kmc> it would be nice to do crypto on the "little" core on an ARM Big/Little chip, or a minion core on RISC-V, and disable complicated instruction handling for that core
[00:05:54] <eternaleye> kmc: Oh, definitely. I'm a huge fan of Nadeko's approach, at least until something more powerful can be done.
[00:06:14] <kmc> (actually I don't think there are any OOE implementations of RISC-V yet, but they're planned)
[00:06:24] <eternaleye> kmc: No, there's at least one.
[00:06:35] <eternaleye> kmc: BOOM, the Berkeley Out-of-Order Microprocessor
[00:06:35] <bascule> kmc: hell yes
[00:06:39] <kmc> nice
[00:06:42] <bascule> kmc: but what's more likely to happen
[00:06:45] <bascule> on x86 anyway
[00:06:49] <bascule> is Intel just adds more instructions
[00:06:57] <bascule> because that's how Intel solves problems
[00:07:01] <bascule> make x86 more bloated!
[00:07:10] <kmc> well we're not stuck on x86 anymore
[00:07:14] <bascule> but yeah I strongly agree a nice little RISC core for doing crypto would be sweet
[00:07:17] <bascule> haha, what?
[00:07:22] * bascule on a laptop with an Intel CPU
[00:07:28] <bascule> talking to servers which likely have Intel CPUs
[00:08:19] <kmc> arguably, Servo cares more about ARM perf than x86 perf, because we're more likely to ship a product on mobile first
[00:08:27] *** Quits: gleb (gleb@moz-3u1drv.rusanovka-net.kiev.ua) (Ping timeout: 121 seconds)
[00:08:52] <kmc> globally, mobile phones are a much bigger deal than laptop computers
[00:08:54] <bascule> sure, that's great for clients... what about servers?
[00:09:00] <bascule> and what gets attacked more?
[00:09:31] <bascule> I am guessing Intel CPUs outnumber ARM CPUs in servers by at least two orders of magnitude
[00:09:34] <kmc> I'm not looking for an argument... I think you interpreted my inital claim as something much stronger than i meant
[00:09:52] <bascule> haha yeah just being needlessly pedantic ;)
[00:09:59] <kmc> if you want to use something non-x86, there are plenty of attractive options, and there are many fields (e.g. mobile, network embedded devices) where it's the rule and not the exception
[00:10:19] <kmc> I think non-x86 servers will catch on eventually, because Intel can't prop up a less efficient architecture with process superiority forever
[00:10:22] <kmc> or maybe they can
[00:10:25] <kmc> but why not just start making ARM chips ;)
[00:10:28] <bascule> this is already largely "solved" in ARM devices
[00:10:34] <bascule> iOS devices have Secure Enclave
[00:10:47] <kmc> anyway I don't imagine the minion cores as a replacement for hardware crypto modules, more like a compliment
[00:10:48] <Dcoder> wait what, x86 is bad now?
[00:10:51] <bascule> others have "TrustZone"
[00:11:01] *** Quits: eternaleye (eternaleye@moz-7ps.ehi.245.50.IP) (Ping timeout: 121 seconds)
[00:11:04] <kmc> Dcoder: yes. things in the world must be categorized into "good" and "bad" and we have just put x86 into the latter bucket, thank you for noticing
[00:11:05] <bascule> kmc: like this thing is commonplace in ARM CPUs already
[00:11:09] <bascule> especially SoC-style devices
[00:11:12] <kmc> what's it do exactly
[00:11:17] <bascule> did I mention we fab our own CPUs?
[00:11:20] <kmc> neat
[00:11:28] <kmc> by which you mean, TSMC or someone fabs your CPUs? ;)
[00:11:28] <bascule> well
[00:11:30] <bascule> we don't fab them
[00:11:31] <bascule> yeah heh
[00:11:33] <kmc> what process?
[00:11:35] <bascule> we design them, someone else fabs them
[00:11:39] <bascule> uhh I honestly don't know, lol
[00:12:01] <bascule> we have a team out in Toronto that works on them
[00:12:25] *** Joins: eternaleye (eternaleye@moz-7ps.ehi.245.50.IP)
[00:12:33] <Dcoder> ok, thanks for clearing that up
[00:12:51] <bascule> kmc: but anyway, these devices often have fixed-function implementations of certain algorithms
[00:12:59] <eternaleye> Ugh, seems my connection dropped sometime after "<kmc> well we're not stuck on x86 anymore"
[00:13:03] <eternaleye> Anyone got backlog?
[00:13:04] <bascule> for example, we have a device that does Curve25519 in hardware
[00:13:19] <bascule> and so I'm really glad the CFRG decided not to change anything! :o
[00:13:22] <kmc> haha
[00:14:01] <bascule> FPGAs would be fun for this ;)
[00:14:16] <bascule> like your Intel CPU has some onboard FPGAs you can blast crypto algorithms onto
[00:14:30] <bascule> and that way you get around the whole fixed function problem
[00:14:56] <eternaleye> bascule: And then NIST is all "Hah! We were right to pick Keccak!"
[00:14:58] <eternaleye> :P
[00:15:04] <bascule> lol
[00:15:11] *** Quits: gsingh93 (gulshan@moz-3fu4am.mi.comcast.net) (Ping timeout: 121 seconds)
[00:17:23] <eternaleye> "BOOST: Berkeleyâ€™s Out-of-Order Stack Thingy"
[00:17:25] <eternaleye> ...
[00:17:41] <eternaleye> Aaaaand Berkeley defends its weirdness champion title
[00:17:57] <eternaleye> (Out of order execution... for stack machines.)
[00:18:09] <eternaleye> (Because you needed more speed in your Forth.)
[00:21:50] *** Quits: Dcoder (test@moz-2gsqbt.compute-1.amazonaws.com) (A TLS packet with unexpected length was received.)
[00:23:02] <o11c> eternaleye: backlog http://pastebin.com/uGx1zJfd
[00:23:17] <eternaleye> o11c: Thanks!
[00:26:02] <eternaleye> bascule: Well, Intel has SGX... but then, *Intel* is designing SGX.
[00:26:06] <eternaleye> bascule: https://www.nccgroup.trust/en/blog/2015/01/intel-software-guard-extensions-sgx-a-researchers-primer/
[00:27:08] *** Quits: erickt (erickt@moz-njt.vqi.14.76.IP) (Quit: leaving)
[00:27:15] <eternaleye> bascule: I will note that RISC-V has a model pretty similar to TrustZone
[00:27:41] <eternaleye> bascule: In that it has user privilege, supervisor privilege, hypervisor privilege, and trusted privilege.
[00:28:01] <eternaleye> bascule: So far, the first spec is done and out for a while, and the second is nearly done
[00:30:30] <eternaleye> bascule: https://groups.google.com/group/chisel-users/attach/7265b0e900ef870f/riscv-privileged.pdf?part=0.1 (the latest available version of the supervisor spec) has a quick table at the top of page 2, and lays out what privileged registers are readable/writable at what levels
[00:35:10] <eternaleye> kmc: If an out-of-order RISC-V intrigues you, this has the most info I've seen in any one place about BOOM: http://www-inst.eecs.berkeley.edu/~cs152/sp14/handouts/lab3.pdf
[00:38:31] <bascule> eternaleye: yeah I've seen SGX
[00:46:32] <eternaleye> bascule: I read that in the "I've seen some shit" meme way :P
[00:54:41] *** Joins: adu (adu@moz-d3un5a.ms5a.74ae.000a.2601.IP)
[00:55:33] <bascule> lol
[01:19:39] *** Joins: theme (theme@moz-i3mhhb.asianet.co.th)
[01:26:23] *** Joins: erickt (erickt@moz-njt.vqi.14.76.IP)
[01:40:58] *** Quits: adu (adu@moz-d3un5a.ms5a.74ae.000a.2601.IP) (Ping timeout: 121 seconds)
[03:51:49] *** Joins: adu (adu@moz-d3un5a.ms5a.74ae.000a.2601.IP)
[04:06:45] *** Joins: gsingh93 (gulshan@moz-3fu4am.mi.comcast.net)
[04:32:08] *** Quits: adu (adu@moz-d3un5a.ms5a.74ae.000a.2601.IP) (Ping timeout: 121 seconds)
[04:48:21] <Ilari> Well, regarding FPGAs in CPUs, such would have to be designed carefully to avoid invalid configurations plus be programmable quite fast.
[04:49:25] <Ilari> E.g. so that one can't do rail-to-rail shorts by invalid bitstreams.
[04:51:56] <Ilari> Internally the FPGA config memory is probably usually SRAM, which can be changed fast. Of course, there is issue of serializing the changes.
[05:10:28] <eternaleye> Hm. Just saw the Git LFS announcement from Github, and my first thought was 
[05:10:40] <eternaleye> "Wait, so you want me to use an anemic git-annex that's tied to your servers?"
[05:21:55] <Ilari> One thingy that could be useful to write: Git smart transport that can deal with things like IP addresses changing.
[05:33:45] <Ilari> bascule: Also, found a document that explicitly says that consumer web browsers do not count as pre-existing infrastructure.
[05:35:34] <theme> I made a PR to rust-crypto
[05:35:35] <theme> https://github.com/DaGenix/rust-crypto/pull/297
[05:35:49] <theme> It is a large refactor :)
[05:35:53] <Ilari> bascule: Also, to me it looks like that for PCI DSS, one needs a migration plan.
[05:37:25] <theme> any comments on my PR?
[05:37:46] <theme> I felt that the number of top level modules were overwhelming when looking at the crate docs
[05:37:57] <theme> so I reduces the number of top level modules
[05:38:03] <theme> s/reduces/reduced/
[05:40:58] *** Quits: Tobba (Tobba@moz-o13d22.bredband.telia.com) (Ping timeout: 121 seconds)
[05:46:04] *** Quits: theme (theme@moz-i3mhhb.asianet.co.th) (Quit: Leaving)
[05:49:44] <Ilari> Hmm... Could one somehow accelerate TLS symmetric encryption in kernelspace (that is, optimize the datapath somehow)?
[05:50:45] <mcpherrin> Ilari: Maybe you could use the kernel cryto APIs to encrypt and write the results directly into the output TCP socket?
[05:51:06] <mcpherrin> I dunno enough about TLS to know how feasible something crazy like that would be
[05:52:55] <Ilari> mcpherrin: I was thinking something like that. Except I don't know if one can do any datapath optimization using capabilities like that.
[05:54:25] <eternaleye> Ilari: That's actually already a thing
[05:54:53] <Ilari> Yeah, I read some BSD confrence paper that had something about doing TLS symmetric encryption in kernelspace.
[05:55:10] <eternaleye> Ilari: I mean, existing patches (possibly upstreamed) for Linux.
[05:55:29] <eternaleye> http://www.spinics.net/lists/linux-crypto/msg11825.html
[05:56:04] <eternaleye> Ilari: Ah, better link: http://thread.gmane.org/gmane.linux.kernel/1758179
[05:56:40] <Ilari> Throughly obsolete crypto tho. :-/
[05:56:54] <eternaleye> Ilari: I think the idea with it was to do something more IPSEC-like with control flow - keying in userspace, bulk data in kernelspace
[05:57:14] <eternaleye> Ilari: Eh, the kernel supports GCM, and that could be added later
[05:57:23] <eternaleye> Ilari: The hard part is getting the record layer in at all
[05:59:02] <eternaleye> Mm, looks like it wound up not going upstream, and I'm not seeing a v2
[05:59:27] <Ilari> Yeah, asymmetric crypto is usually too complicated to do in kernelspace.
[05:59:45] <eternaleye> Yeah, for all its other failings I think ipsec got it right with PF_KEY
[06:00:13] <eternaleye> (Although, the kernel does support verifying RSA signatures)
[06:00:19] <eternaleye> (Because signed modules)
[06:00:48] <eternaleye> (If you're asking whether it's constant-time, you're far more optimistic than I am)
[06:01:49] <Ilari> Well, signature verification usually does not need to be CT.
[06:02:32] <eternaleye> Did I forget to mention the x509 parser?
[06:02:46] <eternaleye> (Yes. Yes, that is a thing.)
[06:03:43] <eternaleye> (This is the kind of thing that got me staring at seL4 with a longing expression)
[06:07:31] <eternaleye> For the masochistic: crypto/asymmetric_keys/x509_cert_parser.c
[06:07:51] <eternaleye> As a bonus: crypto/asymmetric_keys/pkcs7_parser.c
[06:09:15] <Ilari> Probably contains a few (supervisor mode) RCEs...
[06:09:31] <Ilari> *ACEs
[06:11:32] <eternaleye> Yeah, almost certainly.
[06:12:16] <Ilari> What other data besides module signatures (good thing module loading is highly privileged) is fed into that crap?
[06:12:46] <bascule> Ilari: we might end up arguing compensating controls soon :o
[06:13:11] *** Quits: LinuxBunny (Retep998@moz-r1n9v0.east.verizon.net) (Ping timeout: 121 seconds)
[06:13:15] <bascule> Ilari: we have end-to-end encryption of all PANs now, from client to HSM
[06:13:46] *** Joins: LinuxBunny (Retep998@moz-r1n9v0.east.verizon.net)
[06:14:33] <eternaleye> Ilari: Oh, just the IMA signatures read from filesystems.
[06:14:39] <eternaleye> Ilari: You know, like a thumb drive.
[06:15:05] <eternaleye> Ilari: Probably more.
[06:20:04] <eternaleye> Ilari: Ah, no, looks like IMA _only_ loads /etc/keys/x509_ima.der on boot.
[06:20:10] <eternaleye> Ilari: So still a root-only thing
[06:20:20] <eternaleye> ...still.
[06:22:41] <eternaleye> There is a right way to do this.
[06:22:48] <eternaleye> Step 1: Do not use x509
[06:22:55] <eternaleye> Step 2: Do not use pkcs7
[06:23:03] <eternaleye> Step 3: Hire an actual cryptographer
[06:24:12] <eternaleye> (it gets worse, in that the reason it uses pkcs7 is to interoperate with Microsoft's habit of only signing PE binaries, so it parses the PKCS7 out of the PE binary...)
[06:24:34] <eternaleye> (At this point you are probably crying tears of bubbling pitch, so I'll stop now)
[06:24:54] <eternaleye> (Yes, this is still in kernelspace)
[06:25:24] <eternaleye> crypto/asymmetric_keys/verify_pefile.c
[06:25:33] * eternaleye sobs uncontrollably
[06:30:39] *** Quits: erickt (erickt@moz-njt.vqi.14.76.IP) (Ping timeout: 121 seconds)
[06:30:44] *** Quits: gsingh93 (gulshan@moz-3fu4am.mi.comcast.net) (Ping timeout: 121 seconds)
[06:37:59] *** Quits: acharles (acharles@moz-ulbdcn.ca.comcast.net) (Client exited)
[06:41:20] <eternaleye> Hm, on the TLS list, I'm not especially sympathetic to Martin Rex's view on ALPN
[06:42:09] <eternaleye> In part because I really think that you should be binding a handler to each ALPN, either as a callback (eventing-style of some sort) or as a token (mio-style)
[06:42:27] <eternaleye> And that kind of API lends itself to a one-by-one, not array-of-strings
[06:46:01] *** Joins: Tobba|Laptop (Tobba@moz-1hh.7ki.21.217.IP)
[06:55:22] <eternaleye> ...aaaaand the Linux Security Module list has just killed the last of my faith in humanity.
[06:55:40] <eternaleye> In a mail titled "system/ima keyring CA hierarchy"
[06:55:46] <eternaleye> >> I've been playing with IMA for some time and now i am getting to the point where CA hierarchy is needed in either .system or .ima keyrings.  Mimi Zohar pointed me to certain Fedora patches that do the trick by importing CAs into UEFI vars by mokutil.  These CAs are read back into the kernel keyring at next reboot.  However, this approach requires to have secure boot enabled, mounted efivarfs, etc.  Since these aren't immediately 
[06:55:48] <eternaleye> related to the IMA functionality i was wondering if there's a way to get the same effect some other way.
[06:55:59] <eternaleye> Note: Mimi Zohar is the primary developer of the IMA subsystem.
[06:59:23] *** Joins: erickt (erickt@moz-njt.vqi.14.76.IP)
[06:59:25] *** Joins: Tobba|Craptop (Tobba@moz-1hh.7ki.21.217.IP)
[07:02:24] *** Quits: Tobba|Laptop (Tobba@moz-1hh.7ki.21.217.IP) (Ping timeout: 121 seconds)
[07:03:38] *** Quits: erickt (erickt@moz-njt.vqi.14.76.IP) (Ping timeout: 121 seconds)
[07:08:30] *** Tobba|Craptop is now known as Tobba|Laptop
[07:25:04] <Ilari> CA hierarchy... What could possibly go wrong? :->
[09:16:54] <eternaleye> Ooooh, looks like the AF_ALG API has grown RNG and AEAD capabilities in 4.1
[09:40:58] *** Joins: gleb (gleb@moz-3u1drv.rusanovka-net.kiev.ua)
[10:17:14] *** Quits: Tobba|Laptop (Tobba@moz-1hh.7ki.21.217.IP) (Ping timeout: 121 seconds)
[11:27:29] *** Joins: Tobba (Tobba@moz-o13d22.bredband.telia.com)
[13:41:11] *** Joins: erickt (erickt@moz-njt.vqi.14.76.IP)
[14:03:28] *** Quits: erickt (erickt@moz-njt.vqi.14.76.IP) (Ping timeout: 121 seconds)
[15:51:27] *** Joins: brson (brson@moz-u3dg2t.sfo1.mozilla.com)
[16:41:54] *** Quits: randati (antti@moz-o1v1n6.763s.ieq4.0708.2001.IP) (Ping timeout: 121 seconds)
[16:42:55] *** Joins: randati (antti@moz-mr7m5u.763s.ieq4.0708.2001.IP)
[16:49:31] *** Quits: brson (brson@moz-u3dg2t.sfo1.mozilla.com) (Quit: leaving)
[16:49:40] *** Joins: brson (brson@moz-u3dg2t.sfo1.mozilla.com)
[16:51:15] *** Quits: brson (brson@moz-u3dg2t.sfo1.mozilla.com) (Quit: leaving)
[16:56:21] *** Joins: brson (brson@moz-u3dg2t.sfo1.mozilla.com)
[17:30:39] *** Joins: gsingh93 (gulshan@moz-3fu4am.mi.comcast.net)
[17:35:39] *** Quits: gsingh93 (gulshan@moz-3fu4am.mi.comcast.net) (Ping timeout: 121 seconds)
[17:40:24] *** Joins: erickt (erickt@moz-4hh.6p3.217.74.IP)
[17:56:47] *** Quits: brson (brson@moz-u3dg2t.sfo1.mozilla.com) (Connection closed)
[17:57:06] *** Joins: brson (brson@moz-u3dg2t.sfo1.mozilla.com)
[17:57:07] *** Quits: brson (brson@moz-u3dg2t.sfo1.mozilla.com) (Quit: leaving)
[18:00:31] *** Joins: brson (brson@moz-u3dg2t.sfo1.mozilla.com)
[18:05:55] *** Joins: gsingh93 (gulshan@moz-3fu4am.mi.comcast.net)
[18:10:54] *** Joins: rschulman (ross@moz-4gj.ccu.126.76.IP)
[18:12:59] <rschulman> Is there a good example of RSA key usage in rust-openssl?
[18:13:22] <rschulman> the autogenerated docs don't seem to say how to specify the type of PKey
[18:40:01] *** Quits: brson (brson@moz-u3dg2t.sfo1.mozilla.com) (Ping timeout: 121 seconds)
[19:03:31] <eternaleye> rschulman: If you look at the API closely, the only constructors that aren't meant purely for roundtripping keys that are already in rust-openssl are from_handle (which takes one from raw C openssl) and from_pem (which reads one from PEM format)
[19:03:53] <eternaleye> rschulman: Both of _those_ structures specify what kind of key they carry
[19:04:16] <eternaleye> rschulman: So you-the-programmer would never specify the type of a PKey
[19:04:31] <eternaleye> rschulman: The library discovers the type through parsing the data
[19:05:02] <eternaleye> rschulman: Mm, no, my mistake - there's also gen()
[19:05:39] <eternaleye> rschulman: That one does seem like an oversight - it should probably take either an enum (though that does present a compat hazard if extended) or an int.
[19:05:57] <eternaleye> sfackler: ^^^ ?
[19:06:40] <sfackler> yeah, the current APIs are a bit garbage
[19:11:24] <eternaleye> I wonder if you could just do structs for each key type, and impl Rand on them...
[19:11:50] <eternaleye> then you could do let key: RsaKey = std::rand::random()
[19:12:41] <eternaleye> Although it should probably not use std::rand
[19:12:50] <sfackler> yeah, it'd be a bit of an abuse of that trait since Rand::rand is passed an RNG that it's supposed to use
[19:13:22] <eternaleye> sfackler: Not sure it'd be an abuse?
[19:13:32] <eternaleye> sfackler: I mean, generating an RSA keypair _does_ consume randomness.
[19:14:02] <eternaleye> sfackler: But yeah, it's probably a footgun
[19:14:44] <eternaleye> Might be nice to have an unsafe trait CryptoRng: Rng {}
[19:16:11] <eternaleye> Hmm, not sure I like the Rng trait all that much anyway...
[19:19:26] <eternaleye> In particular, I'd much prefer an trait Rng { fill_bytes(); ...methods with default impls... }
[19:20:15] <eternaleye> And the 'gen' stuff seems a bit scattershot
[19:21:18] <eternaleye> I mean, gen_ascii_chars seems downright silly - just use gen_iter with Ascii
[19:22:06] <eternaleye> and gen_weighted_bool ought to just be a use of next_u32 and a greater-than comparison.
[19:23:03] <eternaleye> Mm, and SeedableRng should be using associated types
[19:43:54] <eternaleye> Mm, and gen_iter_ should probably go away too - I mean, it's just iter::iterate(rng, T::rand)
[19:55:06] <rschulman> eternaleye: Yeah, gen() is what I was wondering about.
[20:01:48] <rschulman> (from reading the code, it looks like gen() does indeed generate an RSA pair...)
[20:57:31] <tiffany> er..
[20:57:39] <tiffany> eternaleye, were you the one who said sqlite is strings?
[20:57:44] <tiffany> because I'm looking into it, and finding the opposite
[21:00:11] <tiffany> it's full of redundant type and length tags, but it doesn't seem to be based on strings
[21:00:30] <tiffany> there's multiple distinct layers though
[21:00:57] <tiffany> there's the b-tree page storage, which is simply a b-tree of arbitrary length blobs of data, which then store rows, which are in a format which distinguishes between blobs, text, and numbers
[21:00:59] <tiffany> and null
[21:01:22] <tiffany> I believe that indexes are constructed at the schema layer, not at the low layer
[21:01:31] <eternaleye> tiffany: https://www.pgcon.org/2014/schedule/attachments/319_PGCon2014OpeningKeynote.pdf
[21:01:32] <tiffany> which means that sqlite is not strings
[21:01:43] <eternaleye> tiffany: From the guy who created sqlite
[21:01:48] <eternaleye> See slide 22
[21:02:33] <tiffany> eternaleye: so it allows SQL to implicitly convert between number types
[21:02:52] <tiffany> do other databases prevent that?
[21:03:39] <eternaleye> tiffany: Er, look at the last line
[21:03:52] <eternaleye> tiffany: It silently accepts the string "Hello"
[21:03:55] <tiffany> oh
[21:03:57] <eternaleye> tiffany: In an int-typed field.
[21:04:01] <tiffany> what does that do?
[21:04:14] <eternaleye> tiffany: Well, strictly speaking it should error out...
[21:04:20] <rschulman> sfackler: Am I correct that PKey::gen() generates an RSA pair?
[21:04:22] <tiffany> it seems like it would fire off a constraint error
[21:04:24] <eternaleye> tiffany: Behaviorally, it likely treats it as zero
[21:04:36] <eternaleye> tiffany: It should be a constraint error.
[21:04:37] <tiffany> ugh
[21:04:41] <eternaleye> tiffany: It's not in sqlite.
[21:04:45] <eternaleye> tiffany: Stringly typed.
[21:04:50] <tiffany> yeah, I only ever like to deal with SQL through a type-safe layer
[21:04:57] <eternaleye> tiffany: Link from https://lwn.net/Articles/601144/
[21:05:00] <eternaleye> "SQLite and PostgreSQL"
[21:05:03] <tiffany> it's not like a constraint error would be useful in a complex query anyway
[21:05:09] <eternaleye> >> This year's keynote was delivered by Dr. Richard Hipp, the inventor of SQLite, which is a widely-used embedded SQL database.
[21:05:14] <tiffany> it gives literally zero information besides that it was a constraint error
[21:05:21] <eternaleye> >> The big disagreement between PostgreSQL and SQLite relates to data types. While PostgreSQL has a complex and strictly enforced type system, SQLite uses an undefined type for all data, which can store strings, numbers and other values, much like variables in languages like Perl, Python, and PHP. This difference sparked some discussion between Hipp and a few members of the audience after the talk.
[21:05:54] <tiffany> I was mostly thinking about the low level stuff, not really the semantics
[21:07:31] <tiffany> is there a library relational database like sqlite but without silly semantics on types in queries?
[21:07:42] <tiffany> because as far as I know, postgres can only be run as a daemon
[21:09:34] <eternaleye> tiffany: https://en.wikipedia.org/wiki/Embedded_database
[21:11:23] <eternaleye> tiffany: If you want it from Rust, that rules out a number of them - if you want open-source, it basically comes down to Firebird Embedded, Mysql (and forks) Embedded, or Sqlite
[21:11:46] <eternaleye> tiffany: (about half of those on that page are Java, and most of the rest are closed-source)
[21:11:53] <tiffany> yeah, I noticed that
[21:12:11] <eternaleye> tiffany: A number of things _do_ use MySQL Embedded
[21:12:19] <eternaleye> tiffany: Amarok among them
[21:13:46] <eternaleye> tiffany: There's also sqlite4, but it's not especially lively, and I have no idea if it's got stronger type semantics
[21:17:52] <tiffany> I'm not sure that sqlite has enough downsides for me to switch away from it
[21:18:05] <tiffany> firebird's documentation is all in the form of manuals
[21:18:28] <tiffany> not sure about embedded mysql
[21:18:42] <tiffany> mysql is a pretty big dependency
[21:23:13] <tiffany> I do like the prospect of a capn proto-based relational database
[21:23:47] <tiffany> I wonder if sqlite's underlying table structure is reusable enough to bolt a new schema layer on top
[21:24:35] <tiffany> the backend, they call it
[21:27:00] <tiffany> apparently it's split across incredibly monolithic files
[21:28:05] <tiffany> 3 of them, that is
[21:29:42] <tiffany> it looks like you could pretty easily fork the bits of sqlite which do all the things which deal with ACID
[22:50:54] *** Quits: gsingh93 (gulshan@moz-3fu4am.mi.comcast.net) (Ping timeout: 121 seconds)
[23:03:16] *** Joins: brson (brson@moz-u3dg2t.sfo1.mozilla.com)
[23:27:52] *** Joins: gsingh93 (gulshan@moz-3fu4am.mi.comcast.net)

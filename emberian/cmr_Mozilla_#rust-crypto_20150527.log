[01:42:00] *** Quits: c74d (c74d3a4ebb6@moz-0ersgu.oc.cox.net) (Ping timeout: 121 seconds)
[01:42:23] *** Joins: c74d (c74d3a4ebb6@moz-kfb9ol.mggc.hibn.4404.2002.IP)
[04:36:08] <Ilari> Haha: "Why do they refer to Internet-connected devices as 'smart'? There's nothing smart about running a two-year old version of OpenSSL."
[04:53:54] <bascule> Ilari: lololol Matt Green?
[04:53:57] <bascule> yeah that was awesome
[04:54:05] <eternaleye> Ilari: Oh, I dunno. "Get Smart", "Smart move, wise guy"... there's a good precedent here!
[04:54:52] <bascule> Ilari: https://twitter.com/tqbf/status/602208069020352512
[04:57:52] *** Joins: c74d3 (c74d3a4ebb6@moz-0ersgu.oc.cox.net)
[04:59:26] *** Quits: c74d (c74d3a4ebb6@moz-kfb9ol.mggc.hibn.4404.2002.IP) (Ping timeout: 121 seconds)
[04:59:35] *** c74d3 is now known as c74d
[05:17:48] <eternaleye> Hm, I wonder how hard it'd be to give capnproto a mode that narrows the "amplification attack" defense by presuming valid messages are canonical - i.e. require all pointers to be forward pointers.
[05:18:41] <eternaleye> That'd allow lifting the 64mb limit/heuristic entirely, since forward-only + bounds-check would cover the issue
[05:20:33] <eternaleye> Ah, although it'd require verifying that the schema contains neither void values nor empty structs
[05:20:34] <eternaleye> Still, doable
[05:23:06] <bascule> eternaleye: there's a conversation sort of along those lines going on on the mailing list...
[05:23:11] <bascule> perhaps that inspired your comment?
[05:23:43] <eternaleye> bascule: The link to the canonicalization section from the delta-compression thread is what did it
[05:24:10] <eternaleye> bascule: But I didn't see any mentions of the amplification defense
[05:24:25] <eternaleye> bascule: It's just that reading that section brought the idea to mind
[05:24:56] <bascule> are you thinking of an entity expansion type of attack?
[05:27:15] <eternaleye> No, I'm thinking of a subtly different constraint that still beats amplification, but doesn't constrain message size
[05:27:25] <eternaleye> Basically, the current defense rejects some valid messages
[05:27:48] <eternaleye> The forward-only/no-empty-struct/no-void defense would reject a _different_ subset of valid messages
[05:28:10] <eternaleye> Different usecases might benefit from either one
[05:45:51] <Ilari> And two year old OpenSSL likely has multiple vulns...
[05:53:41] <bascule> two year old OpenSSL has heartbleed
[06:10:34] *** Quits: Tobba (Tobba@moz-o13d22.bredband.telia.com) (Ping timeout: 121 seconds)
[07:22:35] <eternaleye> Ilari: Have you seen this yet? https://github.com/rust-lang/rfcs/pull/1062
[07:45:19] <Ilari> eternaleye: Oh yeah.
[08:04:41] *** Quits: dpc (dpc@moz-t6gr4b.ca.comcast.net) (Connection closed)
[08:20:30] *** Joins: Tobba (Tobba@moz-6oh.7ki.21.217.IP)
[08:33:56] *** Quits: irobevjodu (ident@moz-5bq.k90.254.5.IP) (Ping timeout: 121 seconds)
[11:58:56] *** Quits: mayski (mayski@moz-4n357c.naamio.fi) (Ping timeout: 121 seconds)
[12:01:00] *** Joins: mayski (mayski@moz-0j2.u28.145.83.IP)
[12:15:37] *** Joins: mayski_ (mayski@moz-4n357c.naamio.fi)
[12:17:35] *** Joins: jtdowney (jtdowney@moz-gh1isj.static.twtelecom.net)
[12:17:43] *** Joins: gleb (gleb@moz-3u1drv.rusanovka-net.kiev.ua)
[12:18:04] *** Quits: Tobba (Tobba@moz-6oh.7ki.21.217.IP) (Ping timeout: 121 seconds)
[12:18:27] *** Quits: mayski (mayski@moz-0j2.u28.145.83.IP) (Ping timeout: 121 seconds)
[12:51:48] *** Quits: jtdowney (jtdowney@moz-gh1isj.static.twtelecom.net) (Quit: )
[12:54:50] *** Joins: jtdowney (jtdowney@moz-gh1isj.static.twtelecom.net)
[12:55:00] *** Quits: jtdowney (jtdowney@moz-gh1isj.static.twtelecom.net) (Quit: )
[13:08:21] *** Joins: jtdowney (jtdowney@moz-gh1isj.static.twtelecom.net)
[13:08:24] *** Quits: jtdowney (jtdowney@moz-gh1isj.static.twtelecom.net) (Quit: )
[13:08:51] <Tiffany> forward-only serialization would complicate the implementation a bit
[13:14:13] <Tiffany> maybe it could be a flag in the schema
[13:14:42] <Tiffany> the compiler would make sure your schema is acyclic, and that you have no void/unit lists and so on
[13:14:55] <Tiffany> then the implementation wouldn't need to worry about checking that it's emitting forward-only messages
[13:15:12] <Tiffany> well, if you're doing simple code
[13:15:23] <Tiffany> which I think most people do, because non-simple code leads to wasted space in messages
[13:24:55] *** Quits: gleb (gleb@moz-3u1drv.rusanovka-net.kiev.ua) (A TLS packet with unexpected length was received.)
[13:26:40] *** Joins: Tobba (Tobba@moz-o13d22.bredband.telia.com)
[14:14:22] <eternaleye> Tiffany: Would it? Canonicalization enforces that constraint
[14:14:36] <eternaleye> Tiffany: And I don't think cap'n proto allows reference cycles
[14:14:56] <Tiffany> canonicalization enforces forward-only pointers?
[14:15:32] <Tiffany> this sounds like it'd work fine, then
[15:46:27] *** Joins: irobevjodu (ident@moz-3vi4l0.static-ro.twistednetworks.net)
[16:23:11] *** Joins: brson (brson@moz-48fqub.res.rr.com)
[17:09:03] *** Joins: dpc (dpc@moz-t6gr4b.ca.comcast.net)
[17:42:47] *** Quits: dpc (dpc@moz-t6gr4b.ca.comcast.net) (Connection closed)
[17:44:59] *** Joins: dpc (dpc@moz-t6gr4b.ca.comcast.net)
[17:59:30] *** Quits: brson (brson@moz-48fqub.res.rr.com) (Quit: leaving)
[18:22:09] <bascule> eternaleye: I thought about something like that... re: what you were saying forever ago re "generations"
[18:22:23] <bascule> eternaleye: instead of 1TCS, you have many
[18:22:30] <bascule> the client sends what one it supports
[18:22:34] <bascule> like, the latest one
[18:22:39] <bascule> and the server decides if that's acceptable
[18:24:00] <Ilari> Encryption algorithms are easy to negotiate. It is hashes, cert and kex algorithms that are more difficult.
[18:27:27] <bascule> :(
[18:27:44] <bascule> Ilari: I liked the suggestion of splitting up key exchange from symmetric encryption in TLS
[18:29:42] *** Joins: gsingh93 (uid22642@moz-aq0iah.charlton.irccloud.com)
[18:31:13] <Ilari> The ways TLS key exchange is shown to be secure invoves assuming that prf-hash is CR. But this assumption seems pessimistic.
[18:48:39] <Ilari> Weak key exchange totally screws TLS security.
[18:48:57] <bascule> :(
[18:49:29] <Ilari> And the only defense is unfortunately to disable weak key exchanges.
[18:52:43] <Ilari> Hmm... Wonder what would it take to not have TLS 1.3 break into pieces if AE totally fails...
[18:54:23] <Ilari> ... It breaks into pieces pretty much no matter what. :-/
[18:55:50] <Ilari> Generic composition of encryption and hash-based MAC would help, but those constructs are slow.
[19:01:19] <Ilari> The parts of TLS that negotiate mostly idepedently: Key exchange, Certificates, record protection and prf-hash. There is some coupling between key exchange and certificates however, especially with PSK.
[19:01:20] <eternaleye> I wonder if the number of primitives could be reduced by requiring that the AEAD support (and be collision-resistant/a PRF with) AD and no AE
[19:03:35] <Ilari> I suppose one could consider PSK and DHE-PSK to be key exchange algorithms, distinct from DHE itself.
[19:06:39] <Ilari> Or actually, one might have key exchange algorithms: PSK, DHE-PSK, DHE-ANON and DHE-CERT.
[19:09:31] <bascule> eternaleye: except most clients don't support any AEADs
[19:09:35] <bascule> today
[19:09:43] <bascule> for example GCM is not using the AEAD interface afaik
[19:11:29] <Ilari> bascule: Key exchange part splits up nicely from symmetric encryption.
[19:13:30] <bascule> yes, I wish it worked that way... instead ciphersuite strings have you artesinally list all possible combinations of key exchange and symmetric crypto
[19:13:33] <Ilari> I also counted that TLS has 43 distinct encryption algortihms. If one splits MAC, there are 27.
[19:13:39] <bascule> haha sweet
[19:15:36] <bascule> like, I want to say I support ECDHE-RSA and RSA for key exchange, and AES128-GCM, AES256-GCM, AES128-CBC, and AES256-CBC as symmetric ciphers
[19:15:52] <bascule> and... yeah
[19:16:29] <Ilari> 18/8 of those are crap or worse (including export garbage).
[19:17:16] <bascule> heh :(
[19:17:21] <Ilari> 12 would work in TLS 1.3.
[19:21:11] <Ilari> Things might get more fun when EdDSA/ECIDSA or whatever joins in...
[19:22:42] <bascule> heh
[19:26:34] <Ilari> TLS does have cert negotiation.
[19:32:12] <bascule> hmm, how does that work?
[19:32:22] <bascule> does ClientHello contain signature algorithms?
[19:33:34] <Ilari> There is extension that can carry signaturealgo,hash pairs.
[19:34:20] <bascule> nice
[19:50:15] <Ilari> Actually defined by core TLS 1.2 RFC.
[19:53:52] <Ilari> Wonder if I could get some TLS stack to use ECDSA cert with TLS_DHE_RSA_* ciphersuite...
[19:54:14] <Ilari> I have certainly gotten some TLS stack to use RSA in one direction and DSA in the other...
[20:15:01] <Tiffany> architecture for crypto libraries is something I find interesting
[20:15:06] <Tiffany> it maps so perfectly to type classes and iterators
[20:22:23] <Ilari> Tiffany: Just beware: Many things that look streaming-capable are just plain unsafe if streamed (e.g. AEAD ciphers, signature verfication, etc...)
[20:23:28] <Tiffany> oh, yeah
[20:24:08] <Tiffany> I was mainly thinking of how you can make salsa/chacha and counter-mode block ciphers act as random-access iterators
[20:24:38] <Tiffany> although random-access iterator isn't the best mapping, I suppose
[20:24:49] <Tiffany> iterator of blocks instead of bytes, perhaps
[20:26:51] <Ilari> Then there are all sorts of algorithms that behave in odd ways.
[20:27:38] <Ilari> There are MAC-capable hashes. And even more exotic hash constructs.
[20:29:15] <Tiffany> well, err on the conservative side when it comes to applying type classes to things
[20:29:31] <Tiffany> only allow random access for things which outright support it, like non-authenticated chacha20/counter-mode
[21:05:58] *** Quits: gsingh93 (uid22642@moz-aq0iah.charlton.irccloud.com) (Quit: Connection closed for inactivity)
[21:23:32] *** Joins: gsingh93 (gulshan@moz-ln1ktu.st3l.iv8o.0004.2601.IP)
[22:19:33] *** Quits: o11c (ben@moz-9bd9kh.customer.t3.se) (Connection closed)
[23:08:10] *** Joins: o11c (ben@moz-9bd9kh.customer.t3.se)
[23:24:31] *** Quits: gsingh93 (gulshan@moz-ln1ktu.st3l.iv8o.0004.2601.IP) (Ping timeout: 121 seconds)

[00:03:56] *** Quits: simukis (nagisa@moz-8t068g.static.zebra.lt) (Quit: Leaving.)
[00:06:16] *** Joins: brson (brson@moz-e9i.crj.56.172.IP)
[00:06:16] *** ChanServ sets mode: +qo brson brson
[00:20:05] *** Joins: aatch (james@moz-4tpcve.pd7t.fvcm.e000.2406.IP)
[00:23:06] *** Quits: brson (brson@moz-e9i.crj.56.172.IP) (Quit: leaving)
[01:50:04] *** Joins: Rym (y@moz-m9s4ac.in-addr.btopenworld.com)
[01:54:16] *** Quits: Rym (y@moz-m9s4ac.in-addr.btopenworld.com) (Ping timeout: 121 seconds)
[02:32:25] *** Joins: brson (brson@moz-jbg.c9m.56.172.IP)
[02:32:25] *** ChanServ sets mode: +qo brson brson
[02:32:39] *** Quits: brson (brson@moz-jbg.c9m.56.172.IP) (Quit: leaving)
[02:45:01] *** Quits: zz_kimundi (kimundi@moz-4kjois.dip0.t-ipconnect.de) (Ping timeout: 121 seconds)
[02:45:20] *** Joins: brson (brson@moz-jbg.c9m.56.172.IP)
[02:45:20] *** ChanServ sets mode: +qo brson brson
[02:47:43] *** Joins: zz_kimundi (kimundi@moz-94ap69.dip0.t-ipconnect.de)
[02:47:45] *** zz_kimundi is now known as kimundi
[03:11:25] *** Quits: brson (brson@moz-jbg.c9m.56.172.IP) (Quit: leaving)
[03:56:52] *** Joins: Rym (y@moz-m9s4ac.in-addr.btopenworld.com)
[04:01:18] *** Quits: Rym (y@moz-m9s4ac.in-addr.btopenworld.com) (Ping timeout: 121 seconds)
[04:14:12] <SimonSapin> acrichto: I guess you’ve seen this? https://www.reddit.com/r/rust/comments/31p33q/memcpy_is_backwards/
[04:50:36] *** Joins: Rym (y@moz-m9s4ac.in-addr.btopenworld.com)
[04:54:48] *** Quits: Rym (y@moz-m9s4ac.in-addr.btopenworld.com) (Ping timeout: 121 seconds)
[05:32:29] *** kimundi is now known as zz_kimundi
[05:44:48] *** Joins: Rym (y@moz-m9s4ac.in-addr.btopenworld.com)
[05:49:00] *** Quits: Rym (y@moz-m9s4ac.in-addr.btopenworld.com) (Ping timeout: 121 seconds)
[06:38:57] *** Joins: Rym (y@moz-m9s4ac.in-addr.btopenworld.com)
[06:43:09] *** Quits: Rym (y@moz-m9s4ac.in-addr.btopenworld.com) (Ping timeout: 121 seconds)
[07:33:08] *** Joins: Rym (y@moz-m9s4ac.in-addr.btopenworld.com)
[07:37:17] *** Quits: Rym (y@moz-m9s4ac.in-addr.btopenworld.com) (Ping timeout: 121 seconds)
[08:04:24] *** zz_kimundi is now known as kimundi
[08:27:13] *** Joins: Rym (y@moz-m9s4ac.in-addr.btopenworld.com)
[08:31:27] *** Quits: Rym (y@moz-m9s4ac.in-addr.btopenworld.com) (Ping timeout: 121 seconds)
[08:34:42] *** Joins: simukis (nagisa@moz-8t068g.static.zebra.lt)
[09:21:25] *** Joins: Rym (y@moz-m9s4ac.in-addr.btopenworld.com)
[09:25:37] *** Quits: Rym (y@moz-m9s4ac.in-addr.btopenworld.com) (Ping timeout: 121 seconds)
[09:47:33] *** Quits: nrc (nrc@moz-4bhi2i.xtra.co.nz) (Ping timeout: 121 seconds)
[09:57:39] *** Joins: nrc (nrc@moz-4bhi2i.xtra.co.nz)
[09:57:39] *** ChanServ sets mode: +qo nrc nrc
[10:13:06] *** Joins: pnkfelix (pnkfelix@moz-6v5.3nd.202.89.IP)
[10:13:06] *** ChanServ sets mode: +o pnkfelix
[10:15:33] *** Joins: Rym (y@moz-m9s4ac.in-addr.btopenworld.com)
[10:15:44] *** Quits: simukis (nagisa@moz-8t068g.static.zebra.lt) (Ping timeout: 121 seconds)
[10:19:48] *** Quits: Rym (y@moz-m9s4ac.in-addr.btopenworld.com) (Ping timeout: 121 seconds)
[10:23:59] *** Quits: nrc (nrc@moz-4bhi2i.xtra.co.nz) (Ping timeout: 121 seconds)
[10:26:11] *** Joins: gleb (gleb@moz-3u1drv.rusanovka-net.kiev.ua)
[11:09:42] *** Joins: Rym (y@moz-m9s4ac.in-addr.btopenworld.com)
[11:13:56] *** Quits: Rym (y@moz-m9s4ac.in-addr.btopenworld.com) (Ping timeout: 121 seconds)
[11:55:14] *** kimundi is now known as zz_kimundi
[12:04:01] *** Joins: Rym (y@moz-m9s4ac.in-addr.btopenworld.com)
[12:08:06] *** Quits: Rym (y@moz-m9s4ac.in-addr.btopenworld.com) (Ping timeout: 121 seconds)
[12:17:46] *** Joins: ff (flaper87Moz@moz-ffa.hhs.128.88.IP)
[12:19:16] *** Quits: ff (flaper87Moz@moz-ffa.hhs.128.88.IP) (Quit: 1.1.1)
[12:34:06] *** Joins: simukis (nagisa@moz-pj934t.mif.vu.lt)
[12:35:01] *** Joins: simukis1 (nagisa@moz-pol184.mif.vu.lt)
[12:35:17] *** Quits: simukis1 (nagisa@moz-pol184.mif.vu.lt) (Quit: Leaving.)
[12:35:39] *** Joins: simukis1 (nagisa@moz-pol184.mif.vu.lt)
[12:38:11] *** Quits: simukis (nagisa@moz-pj934t.mif.vu.lt) (Ping timeout: 121 seconds)
[12:58:00] *** Joins: Rym (y@moz-m9s4ac.in-addr.btopenworld.com)
[12:59:14] *** Quits: simukis1 (nagisa@moz-pol184.mif.vu.lt) (Quit: Leaving.)
[13:00:12] *** Joins: simukis (nagisa@moz-pol184.mif.vu.lt)
[13:02:14] *** Quits: Rym (y@moz-m9s4ac.in-addr.btopenworld.com) (Ping timeout: 121 seconds)
[13:52:10] *** Joins: Rym (y@moz-m9s4ac.in-addr.btopenworld.com)
[13:56:24] *** Quits: Rym (y@moz-m9s4ac.in-addr.btopenworld.com) (Ping timeout: 121 seconds)
[14:06:15] *** Joins: killercup (killercup@moz-edmf2j.dip0.t-ipconnect.de)
[14:07:56] *** zz_kimundi is now known as kimundi
[14:17:24] *** Quits: simukis (nagisa@moz-pol184.mif.vu.lt) (Ping timeout: 121 seconds)
[14:24:57] *** Joins: brson (brson@moz-cfhap5.mtv2.mozilla.com)
[14:24:57] *** ChanServ sets mode: +qo brson brson
[14:33:27] *** Quits: killercup (killercup@moz-edmf2j.dip0.t-ipconnect.de) (Quit: My Mac has gone to sleep. ZZZzzz…)
[14:46:19] *** Joins: Rym (y@moz-m9s4ac.in-addr.btopenworld.com)
[14:50:33] *** Quits: Rym (y@moz-m9s4ac.in-addr.btopenworld.com) (Ping timeout: 121 seconds)
[15:13:23] *** Joins: killercup (killercup@moz-edmf2j.dip0.t-ipconnect.de)
[15:13:36] *** Quits: killercup (killercup@moz-edmf2j.dip0.t-ipconnect.de) (Quit: My Mac has gone to sleep. ZZZzzz…)
[15:24:37] *** kimundi is now known as zz_kimundi
[15:40:28] *** Joins: Rym (y@moz-m9s4ac.in-addr.btopenworld.com)
[15:40:37] *** Joins: simukis (nagisa@moz-8t068g.static.zebra.lt)
[15:44:43] *** Quits: Rym (y@moz-m9s4ac.in-addr.btopenworld.com) (Ping timeout: 121 seconds)
[16:27:27] *** zz_kimundi is now known as kimundi
[16:34:38] *** Joins: Rym (y@moz-m9s4ac.in-addr.btopenworld.com)
[16:38:53] *** Quits: Rym (y@moz-m9s4ac.in-addr.btopenworld.com) (Ping timeout: 121 seconds)
[16:41:35] <aturon> nmatsakis: so, people largely want heap::* as-is
[16:41:47] <aturon> well, or at least they're asking either stabilization of that, or of "some way of allocating"
[16:41:57] <aturon> i think there's dissatisfaction with the Vec-based workaround
[16:42:11] <nmatsakis> pnkfelix: ping
[16:42:15] <steveklabnik> in general, i think it kinda aligns with how our _truly_ low-level stuff is unstable
[16:42:20] <aturon> pnkfelix: ^ talking about hearing requests to stabilize some form of alloc
[16:42:20] <steveklabnik> inline asm, et
[16:42:22] <aturon> yes
[16:42:31] <nmatsakis> I'm definitely opposed to allocate
[16:42:33] <nmatsakis> as is
[16:42:56] <nmatsakis> well, that's perhaps stronger than I meant it,
[16:42:59] <nmatsakis> but it's very low-level
[16:43:01] <nmatsakis> untyped
[16:43:45] <aturon> right. i don't really have an opinion about how it "should" look, personally,
[16:43:51] <nmatsakis> it's interesting; at some point the goalposts shifted -- I still feel like we don't expect all things to live on stable
[16:43:55] <aturon> and i know we want to design it so that tracing etc can work later on
[16:44:03] <nmatsakis> I guess because we're very close 
[16:44:25] <aturon> hm, that is an interesting point. right now i think crate authors are feeling a lot of pressure to run on stable rust
[16:44:46] <aturon> and it's not clear how the divide will ultimately end up looking in the ecosystem
[16:45:06] <aturon> anyway, i didn't mean to say we need to do something with allocation *right now*, but just to emphasize that it keeps cropping up
[16:45:19] <nmatsakis> yes
[16:45:24] <nmatsakis> certainly lends credence to it being high priority 
[16:45:48] <nmatsakis> idk maybe there is something minimal  we could do about which we can feel confidence
[16:45:54] <nmatsakis> but I feel yucky about pushing this through last minute
[16:46:33] <nmatsakis> that said
[16:46:41] <nmatsakis> given Box/Vec/workarounds etc
[16:47:03] <nmatsakis> it's not clear if holding out is really buying us much
[16:47:15] <nmatsakis> in "de facto" terms
[16:47:19] <aturon> right
[16:47:33] <nmatsakis> but at least we get to say "hey you used transmute, we're not breaking backwards compat that oyu have to do x y and z now"
[16:47:42] <aturon> like, there's some temptation for people to create an "alloc" crate that just wraps vec etc
[16:47:47] <nmatsakis> right
[16:48:07] <aturon> yeah, this also hooks into the wider question about unsafe "stability", which we don't have a great answer for
[16:48:27] <nmatsakis> s/great/no/
[16:48:36] <nmatsakis> but I feel...sort of sanguine about that
[16:48:58] <nmatsakis> well, not *no* -- but I think people are bending a lot of rules and making assumption about current impl, no doubt
[16:49:06] <nmatsakis> I'm torn because
[16:49:10] <nmatsakis> on the one hand we're not leaving a lot of choice
[16:49:18] <nmatsakis> if you want to extend base system
[16:49:48] <nmatsakis> but I also don't know that I see the value in committing to things like raw::TraitObject etc prematurely
[16:50:07] <aturon> right
[16:50:12] <nmatsakis> (though I was thinking that, for all trait types that exist today, the repr of traitobject is correct)
[16:50:27] <nmatsakis> so maybe we could stabilize with a different name in that particular case ;)
[16:50:32] <aturon> so, a lot of people would be happy with some way to cfg based on rust version, or some such
[16:51:05] <nmatsakis> presumably that will wind up being necessary eventually...
[16:51:08] <aturon> (that is, they're willing to make the changes, but don't want their users to accidentally mix and match rust versions and crate versions in a bad way)
[16:51:28] <nmatsakis> (well, they're willing *now*)
[16:51:31] <aturon> heh, yes
[16:51:50] <aturon> it would be helpful to start collecting areas of unsafe programming we're uncertain about
[16:51:54] <aturon> in terms of long-term promises
[16:51:56] <nmatsakis> yes
[16:52:00] <nmatsakis> I sort of started this
[16:52:03] <nmatsakis> and failed to make good progress
[16:52:08] <nmatsakis> definitely a good idea
[16:52:14] <nmatsakis> to at least document at a high-level
[16:52:36] <aturon> yes, i guess together with the "unsafe contract", which also needs work
[16:52:46] <nmatsakis> aturon: so I'm thinking a bit more
[16:53:17] <aturon> anyway, i think we should hold the line on allocators for now -- there's a clear justification -- but we need to be really clear about it and try to get it done soon
[16:53:34] <nmatsakis> maybe. I mean, realistically,
[16:53:41] <nmatsakis> if/when we add tracing support,
[16:53:48] <nmatsakis> there's tons of codes you can write today with stable APIs
[16:53:50] <nmatsakis> that will not be safe
[16:53:51] <nmatsakis> *code
[16:54:12] <nmatsakis> something as simple as transmuting Box<T> to *mut T
[16:54:20] <nmatsakis> well, it'd depend on the precise design
[16:54:35] <aturon> nmatsakis: hm, so we have an unstable method that does that transformation
[16:54:35] <nmatsakis> but if we went with the tracing approach, you'd presumably need to register a trace hook 
[16:55:01] <nmatsakis> vs the approach the pnkfelix and I initially envisioned, where you hook more at the alloc level
[16:55:05] <nmatsakis> and don't require traciing
[16:55:10] <nmatsakis> (in which case that'd be perfectly safe)
[16:55:20] <aturon> i see
[16:55:20] <nmatsakis> so maybe it's not worth holding the line
[16:55:45] <nmatsakis> and basically just count this as stabilizing unsafe code 
[16:55:56] <nmatsakis> in other words, we can say:
[16:56:01] <nmatsakis> (and have to say anyway, I think)
[16:56:08] <aturon> (well, to be clear, the unsafety would arise only if you actually interacted with a GC, right? which presumably won't be *so* common, at least for the time being)
[16:56:13] <nmatsakis> the transmute API is stable, but uses of it are basically provisionally stable
[16:56:25] <nmatsakis> well, yes, but for libraries it's prob outside your control much of the time
[16:56:30] <aturon> right, but
[16:56:38] <nmatsakis> 9it'll depend on how generic you are)
[16:56:40] <steveklabnik> what about writing a crate that does the workaround with a nicer API?
[16:56:41] <aturon> i was thinking that we could have a way to flag crates as "tracing capable"
[16:56:49] <nmatsakis> yes that's kind of what I'm saying
[16:56:53] <nmatsakis> except that
[16:56:58] <aturon> as people do the work of hooking in
[16:57:17] <nmatsakis> anyway, that's basically what I'm saying -- we're going to need to add add'l requirements, almost certainly,
[16:57:22] <aturon> steveklabnik: sorry, which workaround do you mean? the box/vec stuff?
[16:57:22] <nmatsakis> even on code you can write that is stable today
[16:57:31] <nmatsakis> e.g that workaround :)
[16:57:36] <aturon> heh
[16:57:50] <nmatsakis> and It hink this falls into the more subtle stability requirements
[16:57:54] <nmatsakis> basically that unsafe code is ultimately not stable
[16:58:01] <nmatsakis> and we're just going to have to wrestle wiht it and find a compromise
[16:58:05] <nmatsakis> since of course there's tons of it
[16:58:06] <nmatsakis> but in the end
[16:58:11] <nmatsakis> we could never, ever promise full stability around unsafe code
[16:58:18] <nmatsakis> I mean you can do things like depend on where the linker puts your code
[16:58:19] <nmatsakis> if youw anted to
[16:58:36] <steveklabnik> aturon: yeah
[16:58:36] <nmatsakis> (obviously an extreme example, but you get the idea)
[16:58:37] <aturon> right. we can only make a ever-increasing number of guarantees
[16:58:51] <steveklabnik> aturon: maybe not actually possible, and obviously a bad idea in the long run
[16:59:03] <aturon> steveklabnik: i think it's totally workable, but in a way, it's what i'm worried about :)
[16:59:07] <nmatsakis> it seems that Rust clearly has the idae of a "deafult" allocator baked in by now
[16:59:08] <steveklabnik> heh
[16:59:24] <aturon> steveklabnik: because the worry here is people getting locked into an API that won't work with our eventual allocator plans
[16:59:38] <steveklabnik> ah yeah, i guess that'd be bad
[16:59:42] <nmatsakis> so committing to that, in the form of an alloc fn, doesn't seem so terrible -- coupled with some unsafe guidelines saying transmuting between types and so forth may cause problems with later tracing extensions
[16:59:56] <aturon> nmatsakis: right, so what i'm hearing is (1) de facto stability is already here for unsafe and (2) the alloc stuff isn't so different from other areas of unsafe usage
[16:59:58] <nmatsakis> and if we feel the need to manage that by declaring crates as 'tracing capable', ok
[17:00:12] <aturon> pnkfelix: would love to get your thoughts on the scrollback here
[17:00:32] <nmatsakis> aturon: I Guess I feel like chanelling people through our API is prob ultimately better than transmuting boxes
[17:00:36] <nmatsakis> and certainly no worse
[17:00:40] <aturon> :) yeah
[17:00:42] <nmatsakis> if nothing else
[17:00:44] <nmatsakis> we can deprecate it :)
[17:00:59] <pnkfelix> aturon: (looking)
[17:01:44] <aturon> nmatsakis: right. and given that ultimately a change here isn't actually going to *break code*, but rather will mean some code just can't work with a GC until it's upgraded... doesn't seem like too bad of a commitment
[17:01:51] <aturon> maybe we should discuss this further at today's meeting?
[17:02:06] <nmatsakis> sure, i'd like to get pnkfelix's 2 cents too
[17:10:47] <pnkfelix> Do we actually have an API that we are confident in w.r.t. fwd-compatibility?
[17:11:14] <aturon> pnkfelix: i think it depends on exactly what counts for forward-compat
[17:11:38] <aturon> like, it seems not too hard to continue supporting http://static.rust-lang.org/doc/master/std/rt/heap/index.html
[17:11:43] <pnkfelix> aturon: I mostly am reflecting on nmatsakis's statement that channeling people through our API is better
[17:11:55] <aturon> but it may be that people using those APIs directly wind up locking themselves out of tracing support, for example
[17:12:02] <pnkfelix> aturon: (better than transmuting boxes)
[17:12:16] <nmatsakis> pnkfelix: so I was thinking that in some sense we are already committed to
[17:12:20] <nmatsakis> fn allocate<T>() -> *mut T
[17:12:28] <nmatsakis> e.g.
[17:12:37] <nmatsakis> fn allocate<T>(value: T) -> *mut T { transmute(Box::new(value)) }
[17:12:39] <aturon> put another way, compatibility could be seen in terms of "your existing code will break" versus "your library will not be safe to use in the context of GC"
[17:13:16] <pnkfelix> nmatsakis: yes, but I don't mind breaking transmutes to support GC
[17:13:36] <nmatsakis> but you do mind breaking `allocate`, or mind it more
[17:13:39] <pnkfelix> nmatsakis: Trying to put a proper API in place puts pressure on GC design
[17:13:59] <nmatsakis> it seems like if we wind up adding some add'l API
[17:14:01] <pnkfelix> nmatsakis: well, ... I frankly don't know.
[17:14:01] <nmatsakis> and people are using our API
[17:14:03] <nmatsakis> we can deprecate it
[17:14:06] <nmatsakis> but if they are using transmute
[17:14:08] <nmatsakis> we are stuck
[17:14:11] <nmatsakis> either way their code breaks
[17:14:21] <nmatsakis> but at least one way they get a warning when building
[17:14:48] <pnkfelix> nmatsakis: aturon: Okay, so what we are talking about, is blessing `heap::*` with its current semantics
[17:14:55] <aturon> pnkfelix: that's one possibility
[17:15:01] <pnkfelix> nmatsakis: aturon: with the understanding that it may be deprecated if necessary?
[17:15:18] <nmatsakis> (I'm not sure if my reasoning is totally sound, but that is my reasoning)
[17:15:45] <nmatsakis> aturon: from where does the "pressure" arise? maybe we can ping them in here too?
[17:15:47] <aturon> right. but actually, one question is: if we say that people can safely use this API, but then it ends up not hooking into tracing -- does that mean eventually their code could lead to memory unsafety when hooked into a GC?
[17:16:01] <nmatsakis> probably yes
[17:16:06] <aturon> nmatsakis: the downside of these specialized channels -- the relevant people arent' heare
[17:16:10] <pnkfelix> aturon: well, my thinking there is that we would hopefully have some trait magic here
[17:16:27] <aturon> pnkfelix: ah, so you have to "bless" a type or something
[17:16:28] <pnkfelix> although, there is no trait argument to allocate .
[17:16:32] <pnkfelix> hmm
[17:16:45] <nmatsakis> I mean, this sort of uncertainty is why we left it unstable :)
[17:16:46] <pnkfelix> sed -e 's/trait argument/type parameter/'
[17:16:52] <aturon> yeah
[17:17:50] <aturon> FWIW, i think the people asking for it are mostly just thinking: this is a systems language, I ought to be able to allocate and manage memory myself. i haven't heard detailed thoughts on the precise allocation APIs
[17:18:09] <aturon> i propose we continue this discussion at today's meeting, which will help raise awareness of the issues
[17:18:11] <pnkfelix> aturon: nmatsakis: so what is stopping these people from pulling in jemalloc themselves?
[17:18:28] <aturon> pnkfelix: i think there are some problems with that, but i can never recall the details
[17:18:40] <aturon> acrichto: ^ re: pulling in jemalloc yourself
[17:19:03] <pnkfelix> i.e. its one thing to truly manage memory yourself
[17:19:05] <nmatsakis> aturon: I think they are, ultimately, right
[17:19:12] <nmatsakis> but it's just a question of time
[17:19:14] <pnkfelix> and its another to be able to allocate memory and freely transmute it *to* a Box
[17:19:18] <pnkfelix> and pass it into the runtime
[17:19:22] <pnkfelix> and have everything work out okay
[17:19:34] <nmatsakis> I'm not sure how many people are doing htat 
[17:19:40] <nmatsakis> probably some will want to
[17:19:40] <acrichto> aturon: pnkfelix: hm I may be missing context...
[17:19:42] <pnkfelix> If the *latter* is the goal, then that is certianly a place where we'd *have* to expose our internal allocator.
[17:19:55] <aturon> acrichto: sorry, just asking about: why can't people just bind jemalloc directly for their own allocation?
[17:19:55] <nmatsakis> but I suspect most want to do flat arrays of data etc
[17:20:04] <aturon> acrichto: i know there's a reason, but i always forget the details
[17:20:06] <nmatsakis> (but not scalar data etc)
[17:20:24] <acrichto> aturon: I suppose they can, although what's the failure mode you're worried about?
[17:20:33] <acrichto> aturon: e.g. handing use their jemalloc pointers and praying it's a valid Box?
[17:20:58] <aturon> acrichto: hm, perhaps i'm misremembering, but when you and i first talked about stabilizing the heap API, i think i asked about putting it in an external crate and you thought it couldn't be done for some reason
[17:21:19] <acrichto> oh well the standard library has to use *some* allocator
[17:21:32] <acrichto> so and an external crate would be a second allocator
[17:21:36] <acrichto> and 2 allocators == bad
[17:23:25] <pnkfelix> I need to go, but my current thinking is that we need to better understand our client needs here.
[17:23:29] <pnkfelix>  If its about crates managing their own memory, without transmuting it to e.g. Box<T>, then we should be able to provide access to the system allocator.
[17:23:46] <aturon> pnkfelix: ok. i will try to talk to a few clients
[17:23:56] <aturon> i'll put this on the mtg agenda as well
[17:23:57] <pnkfelix> (but I might prefer that we safeguard it in some way, try to actively prevent people from *doing* the transmute to Box<T> ...)
[17:24:15] <pnkfelix> (which may be a little tricky to do well.)
[17:25:01] <nmatsakis> pnkfelix: it's interesting that this is wha you worry about
[17:25:08] <nmatsakis> I am much more worried about people who FAIL to transmute to Box
[17:25:13] <nmatsakis> because Box will presumably participate in tracing :)
[17:25:21] <nmatsakis> but if you store it in some random MyBox<T>
[17:25:32] <nmatsakis> how are we supposed to know if we should pass through to the *mut T
[17:25:45] <nmatsakis> er, walk through
[17:25:50] <pnkfelix> nmatsakis: I guess these are dual problems
[17:26:13] <nmatsakis> though pnkfelix I was also thinking that PhantomData might provide some idea for how to resurrect our old idae
[17:26:17] <nmatsakis> of hooking in at the allocator level
[17:26:20] <nmatsakis> and avoiding the need to trace
[17:26:24] <nmatsakis> though I think there are still limitations...
[17:26:26] <pnkfelix> nmatsakis: but they are both about violating/disrupting the the GC's invariants.
[17:27:23] * aturon is going to be afk for a little while
[17:27:35] * pnkfelix needs to go afk for a long while, perhaps until the mtg
[17:28:39] <nmatsakis> k
[17:28:46] *** Joins: Rym (y@moz-m9s4ac.in-addr.btopenworld.com)
[17:33:00] *** Quits: Rym (y@moz-m9s4ac.in-addr.btopenworld.com) (Ping timeout: 121 seconds)
[17:45:34] <pnkfelix> aturon: (obviously transmuting or from_raw_parts'ing to Vec is morally equivalent to Vec; I was just skimming of gh24028 which seems to have some of the relevant clients here...)
[17:49:36] *** Quits: pnkfelix (pnkfelix@moz-6v5.3nd.202.89.IP) (Ping timeout: 121 seconds)
[18:22:35] *** Quits: kimundi (kimundi@moz-94ap69.dip0.t-ipconnect.de) (Ping timeout: 121 seconds)
[18:22:55] *** Joins: Rym (y@moz-m9s4ac.in-addr.btopenworld.com)
[18:27:08] *** Quits: Rym (y@moz-m9s4ac.in-addr.btopenworld.com) (Ping timeout: 121 seconds)
[18:37:20] *** Joins: killercup (killercup@moz-edmf2j.dip0.t-ipconnect.de)
[18:37:32] *** Quits: killercup (killercup@moz-edmf2j.dip0.t-ipconnect.de) (Quit: My Mac has gone to sleep. ZZZzzz…)
[18:48:47] *** Joins: nrc (nrc@moz-4bhi2i.xtra.co.nz)
[18:48:47] *** ChanServ sets mode: +qo nrc nrc
[19:09:13] *** Joins: pnkfelix (pnkfelix@moz-eljppb.fbx.proxad.net)
[19:09:13] *** ChanServ sets mode: +o pnkfelix
[19:17:05] *** Joins: Rym (y@moz-m9s4ac.in-addr.btopenworld.com)
[19:19:38] *** Joins: kimundi (kimundi@moz-94ap69.dip0.t-ipconnect.de)
[19:21:19] *** Quits: Rym (y@moz-m9s4ac.in-addr.btopenworld.com) (Ping timeout: 121 seconds)
[20:11:12] *** Joins: Rym (y@moz-m9s4ac.in-addr.btopenworld.com)
[20:15:28] *** Quits: Rym (y@moz-m9s4ac.in-addr.btopenworld.com) (Ping timeout: 121 seconds)
[20:24:54] *** Joins: Rym (y@moz-m9s4ac.in-addr.btopenworld.com)
[20:31:39] *** Quits: simukis (nagisa@moz-8t068g.static.zebra.lt) (Ping timeout: 121 seconds)
[20:49:31] *** Joins: simukis (nagisa@moz-8t068g.static.zebra.lt)
[20:50:14] *** Quits: pnkfelix (pnkfelix@moz-eljppb.fbx.proxad.net) (Ping timeout: 121 seconds)
[21:04:24] *** Joins: pnkfelix (pnkfelix@moz-eljppb.fbx.proxad.net)
[21:04:25] *** ChanServ sets mode: +o pnkfelix
[22:03:24] *** Quits: pnkfelix (pnkfelix@moz-eljppb.fbx.proxad.net) (Ping timeout: 121 seconds)
[23:06:08] *** Quits: gleb (gleb@moz-3u1drv.rusanovka-net.kiev.ua) (Ping timeout: 121 seconds)
[23:06:41] *** Quits: Rym (y@moz-m9s4ac.in-addr.btopenworld.com) (Ping timeout: 121 seconds)
[23:33:18] *** Joins: Rym (y@moz-m9s4ac.in-addr.btopenworld.com)
[23:37:32] *** Quits: Rym (y@moz-m9s4ac.in-addr.btopenworld.com) (Ping timeout: 121 seconds)

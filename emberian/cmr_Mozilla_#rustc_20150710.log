[00:35:52] <nrc> Can anyone tell me about LLVMGetInitializer?
[00:36:02] <nrc> doener, aatch?
[00:36:20] <nrc> What does it do? When should I expect it to fail (return null)?
[00:36:46] <nrc> The answer to the second question is if has_initialiser for the ValueRef is false, but when does that happen?
[00:36:59] <nrc> My google-fu is weak :-(
[01:32:48] *** Quits: Rym (uid91135@moz-n2i7qm.charlton.irccloud.com) (Quit: Connection closed for inactivity)
[01:43:48] <nrc> Definitions have initializers, declarations don't. 
[02:09:08] *** Quits: brson (brson@moz-cfhap5.mtv2.mozilla.com) (Quit: leaving)
[02:15:52] *** Quits: kimundi (kimundi@moz-mgf8eg.hrr4.28s0.57bc.2002.IP) (Ping timeout: 121 seconds)
[02:20:55] *** Joins: kimundi (kimundi@moz-l9v88u.dtlu.8ps3.57bc.2002.IP)
[02:22:52] *** Joins: achanda (achanda@moz-qv7q4n.ca.comcast.net)
[02:42:30] *** Quits: achanda (achanda@moz-qv7q4n.ca.comcast.net) (Connection closed)
[03:53:43] <eddyb> nrc: Datum has a way to print a value
[03:54:09] <eddyb> (which can also be done without creating a Datum. I mean, in trans/datum.rs you'll find a call to a function which can print a ValueRef)
[04:19:54] *** Joins: achanda (achanda@moz-qv7q4n.ca.comcast.net)
[04:55:12] <nrc> I found cx.tn().val_to_string(v)
[05:51:56] *** Joins: laumann (thomas@moz-n9e72h.0.fullrate.dk)
[06:11:19] *** Quits: achanda (achanda@moz-qv7q4n.ca.comcast.net) (Connection closed)
[07:21:51] *** Quits: laumann (thomas@moz-n9e72h.0.fullrate.dk) (Ping timeout: 121 seconds)
[07:53:10] <Luqman> nrc: that's also just bcx.val_to_string(v) if you've got a bcx. less to type
[07:53:25] <Luqman> there's also bcx.llty_str() for Type
[07:57:00] *** Joins: laumann (thomas@moz-3m6.3kq.109.2.IP)
[10:13:04] *** Quits: stl (stl@moz-stg.7dk.15.176.IP) (Ping timeout: 121 seconds)
[10:16:02] *** Joins: stl (stl@moz-stg.7dk.15.176.IP)
[10:56:46] *** Joins: nagisa (nagisa@moz-8t068g.static.zebra.lt)
[10:58:16] <eddyb> jroesch: https://github.com/rust-lang/rust/pull/26935 reminded me that maybe we should just switch to InferCtxt (or whatever it will be, TypedEnv) in const_eval
[10:58:47] <eddyb> jroesch: so that evaluating things after typeck uses concrete types and cannot do the wrong thing
[10:59:21] <eddyb> jroesch: while const_eval during collection would do something with hints... preferably deterministic
[11:00:29] <eddyb> jroesch: so that the type of each sub-expression is the same as what would be inferred with, e.g. `let N: usize = <expr>;` inside a function (this for array lengths)
[11:17:36] *** Joins: madmalik (uid13697@moz-lfin5p.brockwell.irccloud.com)
[12:09:20] <doener> acrichto: what's the state of the LLVM update? I landed a fix upstream today, would be nice to include that
[13:27:09] *** Quits: nagisa (nagisa@moz-8t068g.static.zebra.lt) (Ping timeout: 121 seconds)
[13:32:31] *** Joins: nagisa (nagisa@moz-8t068g.static.zebra.lt)
[13:41:29] *** Quits: blank_name (blank_name@moz-b62.iv2.183.192.IP) (Ping timeout: 121 seconds)
[13:55:44] *** Joins: quantheory (quantheory@moz-pjo3s1.36gq.r6rv.0280.2601.IP)
[14:13:03] *** Joins: brson (brson@moz-bjsp1u.tmodns.net)
[14:13:03] *** ChanServ sets mode: +qo brson brson
[14:13:41] *** Quits: laumann (thomas@moz-3m6.3kq.109.2.IP) (Ping timeout: 121 seconds)
[14:20:58] *** Quits: barosl_ (barosl@moz-tmp.qma.67.220.IP) (Quit: Leaving)
[14:22:11] *** Quits: nagisa (nagisa@moz-8t068g.static.zebra.lt) (Ping timeout: 121 seconds)
[14:38:58] *** Joins: nagisa (nagisa@moz-8t068g.static.zebra.lt)
[14:41:54] <acrichto> doener: there's a failing debuginfo test that I don't know why it's happening, otherwise it's "ready to go"
[14:42:08] <acrichto> doener: I'm currently bisecting LLVM to try and figure out what rev it broke on
[14:43:17] <eddyb> acrichto: that's going to be painful - oh neverming LLVM is C++ so it has incremental recompilation :P
[14:43:42] <acrichto> heh yeah I never said I'd bisect *quickly* :)
[14:43:56] <eddyb> quicker than bisecting rustc by any measure
[14:44:13] <eddyb> I'm still hearing vague news of Rust getting something incremental
[14:59:15] *** Quits: nagisa (nagisa@moz-8t068g.static.zebra.lt) (Connection closed)
[15:28:19] <doener> acrichto: cool!
[15:45:02] <acrichto> doener: fwiw it's looking like https://github.com/llvm-mirror/llvm/commit/60bd365 is the faulty commit
[15:45:14] <acrichto> although... I'm not sure what to do with that
[15:45:18] <acrichto> didn't help as much as I thought it would
[15:50:33] <doener> acrichto: what's the failure you're getting?
[15:52:14] <acrichto> doener: https://gist.github.com/alexcrichton/1cadf8d1196c1796db6c
[15:52:25] <acrichto> doener: e.g. Some(8i16) is being pretty-printed as None
[15:52:51] <acrichto> although I don't think it's related to the pretty printers themselves, b/c with them turned off it still prints None (but with a payload of 8)
[15:53:06] <acrichto> also the bug goes away if there's not the "".to_string() above it
[15:53:15] <acrichto> also it looks like the llvm upgrade breaks 32-bit windows
[15:53:20] <acrichto> so now also investigating that
[15:53:41] <acrichto> that llvm commit is indeed the culprit
[15:53:51] <acrichto> e.g. bisect turned up that commit as the one causing the debuginfo regression
[15:53:53] *** Joins: achanda (achanda@moz-qv7q4n.ca.comcast.net)
[15:55:33] *** Joins: Tobba (Tobba@moz-oecqnu.plus.com)
[16:13:09] <doener> *sigh* so this time I didn't break the llvm buildbots but the chromium ones...
[16:26:46] *** Joins: nagisa (nagisa@moz-8t068g.static.zebra.lt)
[16:59:54] *** Joins: blank_name (blank_name@moz-ttfeua.mi.frontiernet.net)
[17:14:25] <eternaleye> Hm. I wonder how hard it'd be to permit '[T; _]' to be used in trait bound position.
[17:15:21] <eternaleye> Almost all of the places I want dependent types are because I want _some_ fixed array size at monomorphization time, but I want to require it's an array
[17:15:44] <nagisa> eternaleye: HKT
[17:17:53] <eddyb> nagisa: how is that HKT?
[17:18:06] <eddyb> eternaleye: do you mean A: [T; _]?
[17:18:28] <eddyb> eternaleye: because we have that already :P. though you cannot extract the size as an associated constant
[17:18:49] <eddyb> A: Unsize<[T]>
[17:19:28] <eternaleye> eddyb: With dependent types, I'd take a natural and use [T; n] in function sigs and such
[17:19:31] <eternaleye> But if I could bound like that, I could do trait Foo<T, U: [T; _]> and actually state what I want
[17:19:36] <eternaleye> Then, once the rules for associated constants from generics get worked out, the literal _ could be relaxed so the trait could put an ident there, which could then be used as an assoc. const.
[17:19:52] <nagisa> oh, I thought everything that wants to be generic over size of sized arrays needs some form of HKTâ€¦
[17:20:02] <eddyb> nagisa: unrelated AFAIK
[17:20:09] <eddyb> eternaleye: but you don't need dependent types
[17:20:15] <eddyb> eternaleye: to get generics over values
[17:20:18] <eternaleye> nagisa: Unrelated - if T there captured, then it would be HKT
[17:20:49] <eternaleye> eddyb: You need either dependent types/type-level naturals OR the ability to access assoc. constants of generics
[17:20:56] <eternaleye> eddyb: Neither works currently
[17:21:15] <eddyb> the latter is not enough
[17:21:18] <eternaleye> eddyb: And I didn't realize A: [T; _] in generics worked
[17:21:26] <eddyb> eternaleye: not with that syntax
[17:21:56] <eddyb> and you don't get coherence to allow multiple blanket impls
[17:22:11] <eddyb> although the latter might be incorrect
[17:22:21] <eddyb> playbot: struct Foo; trait Bar {} impl Bar for Foo {}
[17:22:23] -playbot- ()
[17:22:38] <eternaleye> eddyb: I wouldn't want multiple impls; I want one impl to constrain some type parameter U to _only accept arrays_
[17:22:54] <eternaleye> With some fixed element type T
[17:23:01] <eddyb> playbot-mini: struct Foo; trait Bar {} impl Bar for Foo {} impl<A: std::marker::Unsize<[T]>, T> Bar for A {}
[17:23:02] -playbot-mini- error: main function not found
[17:23:02] -playbot-mini- error: aborting due to previous error
[17:23:02] -playbot-mini- playpen: application terminated with error code 101
[17:23:05] <eddyb> playbot-mini: struct Foo; trait Bar {} impl Bar for Foo {} impl<A: std::marker::Unsize<[T]>, T> Bar for A {} fn main(){}
[17:23:06] -playbot-mini- <anon>:1:80: 1:81 error: the type parameter `T` is not constrained by the impl trait, self type, or predicates [E0207]
[17:23:06] -playbot-mini- <anon>:1 struct Foo; trait Bar {} impl Bar for Foo {} impl<A: std::marker::Unsize<[T]>, T> Bar for A {} fn main(){}
[17:23:06] -playbot-mini- output truncated; full output at: http://bit.ly/1UKrxlf
[17:23:13] <eddyb> playbot-mini: struct Foo; trait Bar {} impl Bar for Foo {} impl<A: std::marker::Unsize<[T]>, T> Bar for (A, T) {} fn main(){}
[17:23:14] -playbot-mini- <anon>:1:54: 1:78 error: use of unstable library feature 'core'
[17:23:14] -playbot-mini- <anon>:1 struct Foo; trait Bar {} impl Bar for Foo {} impl<A: std::marker::Unsize<[T]>, T> Bar for (A, T) {} fn main(){}
[17:23:14] -playbot-mini- output truncated; full output at: http://bit.ly/1JZonEk
[17:23:22] <eddyb> playbot-mini: #![feature(core)] struct Foo; trait Bar {} impl Bar for Foo {} impl<A: std::marker::Unsize<[T]>, T> Bar for (A, T) {} fn main(){}
[17:23:22] -playbot-mini- <anon>:1:19: 1:30 warning: struct is never used: `Foo`, #[warn(dead_code)] on by default
[17:23:23] -playbot-mini- <anon>:1 #![feature(core)] struct Foo; trait Bar {} impl Bar for Foo {} impl<A: std::marker::Unsize<[T]>, T> Bar for (A, T) {} fn main(){}
[17:23:23] -playbot-mini- output truncated; full output at: http://bit.ly/1UKrENY
[17:23:30] <eddyb> hmpf
[17:24:10] <eternaleye> eddyb: Oh, and Unsize<[T]> is from nrc's DST conversions work, and is compiler-implemented only on [T; n], right!
[17:24:24] <eddyb> eternaleye: yeah, the new RFC
[17:24:32] <eddyb> though the old old might have also had it
[17:24:39] <eternaleye> eddyb: I'd seen the parts, but hadn't put them together into what I wanted :D
[17:25:05] <eddyb> eternaleye: check this out though: a type generic over Trait: ?Sized with a method generic over T: Unsize<Trait>
[17:25:17] <eternaleye> eddyb: Also, access to assoc. consts. of generics is equivalent to dependent types...
[17:25:47] <eternaleye> eddyb: Since one can write a new pseudonymous struct for each constant value one wants to parameterize with.
[17:25:51] <eddyb> you can be generic over traits and types that implements those traits
[17:25:55] <eddyb> eternaleye: uhm, no
[17:26:07] <eddyb> eternaleye: dependent types means the relationship is kept with runtime values
[17:26:29] <eternaleye> eddyb: Oh, really? I'd not seen that in any descriptions I'd read; thanks for the clarification!
[17:26:57] <eddyb> you write something like fn interleave([T; N], [T; N]) -> [T; 2*N]
[17:27:04] <eternaleye> eddyb: Everything I'd seen made it seem equivalent to types that depend on values that can be lifted to compile time.
[17:27:04] <eddyb> and then call it on vectors from user input
[17:27:25] <eddyb> what you're talking about is just type-level values (or generics over values)
[17:27:41] <eddyb> now, associated constants means type-level values are possible (if the implementation is finished)
[17:28:06] <eternaleye> Yeah, none of my reading had noted the distinction.
[17:28:09] <eddyb> the problem is creating new values, which to me, warrants generics-over-constants *or* some sugar for creating singletons
[17:28:20] <eternaleye> eddyb: oh, agreed.
[17:28:27] <eddyb> like maybe `const 5`
[17:28:44] <eddyb> but still...
[17:28:45] <eternaleye> eddyb: i'd actually like the singletons way better, TBH
[17:28:56] <eddyb> `const N::VALUE * 2` still is a bit too verbose
[17:29:02] <eddyb> eternaleye: you know what the problem with that is?
[17:29:11] <eddyb> input/output
[17:29:30] <eternaleye> eddyb: having read the type-level ints RFC and the ordering questions in generic param lists
[17:29:51] <eddyb> so if you have
[17:30:17] <eddyb> impl<N: Const<usize>, T: Copy> Copy for [T; N::VALUE]
[17:30:29] <eddyb> how do you unify [T; 5] with [T; N::VALUE]
[17:31:27] <eddyb> the obvious answer is "you don't"
[17:32:10] <eternaleye> eddyb: Singletons come from constexprs; so evaluate, unify, monomorphize, repeat again with newly-leaf definitions.
[17:32:28] <eddyb> okay, let me desugar
[17:32:43] <eddyb> how do you unify <N as Const<usize>>::VALUE with 5?
[17:33:04] <eternaleye> At link time.
[17:33:05] <eddyb> how do you unify <X as Deref>::Target with Y?
[17:33:28] <eddyb> eternaleye: this is a trait impl selection issue
[17:33:42] <eddyb> you cannot extract N from [T; N::VALUE]
[17:34:00] <eddyb> just like you can't extract X from <X as Deref>::Target == Y
[17:34:43] <eddyb> eternaleye: the cheaty solution is to fallback to built-in singletons
[17:34:50] <eternaleye> No, but the definition of the types that N is monomorphized to should be fully-evaluated and unified
[17:34:59] <eddyb> but it seems like too much contortion
[17:35:21] <eddyb> eternaleye: what?
[17:35:58] <eddyb> eternaleye: there can be multiple types N for which <N as Const<usize>>::VALUE == 5
[17:36:11] <eddyb> easily several countable infinities
[17:36:21] <eternaleye> if you have const 5 and const {2+3}, they should be fully evaluated to const 5, then unified
[17:36:28] *** Quits: Tobba (Tobba@moz-oecqnu.plus.com) (A TLS packet with unexpected length was received.)
[17:36:35] <eddyb> eternaleye: that's a single type out of an infinity
[17:36:49] <eddyb> struct Five; impl Const<usize> for Five { const VALUE: usize = 5; }
[17:36:55] <eddyb> this would compile right now AFAIK
[17:37:13] <eddyb> eternaleye: the assumptions is that you're not restricted to singletons
[17:37:29] <eddyb> because if you are, then modelling them as associated constants is a needless complication
[17:37:36] <huon> eddyb: it compiles but is useless
[17:37:36] <eddyb> just make them first-class
[17:37:48] <eddyb> huon: you can't use it in most interesting contexts, yes
[17:37:50] <eternaleye> eddyb: Ah, i've been presuming the singleton trait was a lang item
[17:38:13] <eddyb> eternaleye: oh, unimplementable on user types?
[17:39:44] <eddyb> so the trait could only reflect built-in singletons so you could go from a predicate on the associated const to the Self type
[17:40:52] <eddyb> eternaleye: there's arguably a benefit to the implementation complexity. although... it would be fairly easy to get generics-over-values syntax and desugar to this particular singleton scheme
[17:41:39] <eddyb> (uses of N where N is defined as const N: X are replaced with <N as Const<X>>::VALUE)
[17:46:25] <eddyb> I actually care less about being able to pass constants (because <[(); value]>::LEN :P) and more about unifying with N in [T; N]
[17:47:31] <eternaleye> eddyb: I'm actually fond of singletons because I _don't_ like the effects generics-over-values special syntax has
[17:47:42] <eternaleye> eddyb: None of the options in the RFC looked nice to me at all
[17:48:48] <eddyb> eternaleye: definition or creation?
[17:50:10] <eddyb> I would almost have N: usize with no `const`
[17:50:49] <eddyb> you can't get simpler than that without compromise
[18:04:12] <eternaleye> eddyb: Mainly, it was how generic parameter list declarations interacted with ordering, when the type of the value depended on a generic parameter
[18:04:15] <eternaleye> eddyb: Singletons don't require anything new there, since the actual parameters are all types, just like before
[18:05:24] <eternaleye> eddyb: And I'm really not a fan of the <Types; Values> way
[18:05:36] <eternaleye> eddyb: (even if it _is_ consistent with arrays)
[18:08:35] <eddyb> wait wait what?
[18:08:40] <eddyb> eternaleye: what's that about ordering?
[18:09:09] <eternaleye> eddyb: It was discussed in the RFC
[18:09:24] <eddyb> since you can desugar `const N: T` to `N: Const<T>`, where's the issue?
[18:09:25] <eternaleye> eddyb: What constraints to place wrt types depending on values depending on types
[18:09:43] <eddyb> none?
[18:10:31] <eternaleye> eddyb: Lemme find the thing
[18:15:14] <eternaleye> eddyb: https://github.com/rust-lang/rfcs/pull/884#issuecomment-75602025
[18:15:39] <eternaleye> eddyb: It was _defaults_ - I was misremembering it
[18:15:59] <eddyb> ahhhh
[18:16:11] <eddyb> eternaleye: singletons have the same issue
[18:16:28] <eternaleye> eddyb: Only inasmuch as types already do, IMO
[18:16:35] <eddyb> but yes, it's double trouble with separated types/value lists
[18:17:00] <eddyb> I think I list mixed list
[18:17:54] <eddyb> the only issue I take with singletons exposed in the language is that they feel hacky around unification
[18:21:55] <eddyb> huon: about SIMD, I think we can rescue aatch's simd![...] macro from last year by simply making it forward to the library structures, right?
[18:23:13] <eddyb> (I personally don't like seeing (T, T, T, T) instead of [T; 4] but it's not like struct Simd4<T>[T; 4]; is valid...)
[18:26:04] <eternaleye> eddyb: struct Simd4<T>(T) where T: std::marker::Unsize<[T]> + Deref<[T; 4]>; ?
[18:26:35] <eddyb> eternaleye: the whole point is to have a named array
[18:26:58] <eddyb> wrapping an array type is not enough
[18:27:21] <huon> struct Simd4<T>([T; 4]); can be made to work fine
[18:27:54] <eddyb> nobody will want to construct it, lol
[18:28:21] <huon> what do you mean?
[18:31:33] <eddyb> huon: Simd4([a, b, c, d])
[18:31:51] <huon> Simd4::new(a, b, c, d)
[18:31:57] <eddyb> although if you only expose it through a macro, simd![a, b, c, d] would still look the same
[18:32:05] <huon> (is likely to be the API)
[18:32:05] <eddyb> huon: ::new! that's worse!
[18:32:23] <huon> one usually isn't constructing simd values from scalars like that anyway
[18:32:27] <eddyb> I guess then you could even use named fields
[18:32:52] <huon> Simd4::splat(a) => broadcast across all fields
[18:33:13] <huon> Simd4::load(slice, i) => load slice[i..i+4]
[18:33:17] <eddyb> #[repr(simd)] struct Rgba<T=f32> { r: T, g: T, b: T, a: T }
[18:33:44] <eddyb> with a nice way to construct it, I think that would work rather well
[18:34:07] <eddyb> huon: ooh that load method, I want it
[18:34:18] * huon does too
[18:35:30] <eddyb> I wonder how terrible rgba!(#0f0faa) would be to implement
[18:36:03] <eddyb> you get a decimal literal followed by an identifier
[18:36:11] <eddyb> stringify! might be the best option there
[18:36:43] <huon> macro_rules! rgb { (#$value: expr) => { Rgba { r: $value / (256 * 256), g: ($value / 256) % 256, b: $value % 256 } )
[18:37:05] <huon> oh, erm, hex.
[18:37:09] * huon ignores hex.
[18:44:53] <nagisa> numerify!
[18:57:32] <acrichto> doener: hm so I'm still trying to pinpoint this debuginfo thing, but upgrading is dead in the water with a 32-bit windows build just segfaulting on bootstrap
[18:57:52] <acrichto> doener: can't get a repro via llc to reduce via bugpoint either, so all I've got is a stack trace :\
[18:59:16] *** Joins: laumann (thomas@moz-n9e72h.0.fullrate.dk)
[19:08:50] *** Quits: laumann (thomas@moz-n9e72h.0.fullrate.dk) (Ping timeout: 121 seconds)
[19:15:55] *** Quits: achanda (achanda@moz-qv7q4n.ca.comcast.net) (Ping timeout: 121 seconds)
[19:16:49] *** Joins: Tobba (Tobba@moz-4l45on.skybroadband.com)
[20:02:01] *** Joins: brson_ (brson@moz-bro.mg6.56.172.IP)
[20:02:59] *** Joins: arielb1 (Ariel@moz-sol.pro.64.109.IP)
[20:04:39] *** Quits: brson (brson@moz-bjsp1u.tmodns.net) (Ping timeout: 121 seconds)
[20:12:34] *** Quits: Tobba (Tobba@moz-4l45on.skybroadband.com) (A TLS packet with unexpected length was received.)
[20:35:52] <nmatsakis> was somebody rebasing aatch's patch ever?
[20:35:59] * nmatsakis sad
[20:38:56] <doener> nmatsakis: which one?
[20:39:09] <nmatsakis> the one that introduced StructDefs etc
[20:39:25] <nmatsakis> I'm just thinking over how to cleanup the handling of closures some. don't mind me.
[20:41:18] *** Joins: laumann (thomas@moz-n9e72h.0.fullrate.dk)
[20:43:33] *** Joins: achanda (achanda@moz-qv7q4n.ca.comcast.net)
[20:51:20] <arielb1> nmatsakis: I was
[20:51:24] <arielb1> but I got busy with wf
[20:51:34] <arielb1> and the rebase was destroyed by the refactors
[20:51:48] <arielb1> I need to fix wf
[20:51:51] <arielb1> *finish
[20:52:04] <nmatsakis> arielb1: I'm doing a lot to that code right now :)
[20:52:31] <arielb1> nmatsakis: is refactor season over?
[20:52:44] <nmatsakis> refactor season?
[20:52:58] <arielb1> there were so many refactors 1.1/1.2
[20:53:12] <arielb1> there weren't so many before
[20:54:54] <arielb1> nmatsakis: what was the decision on trait method well-formedness?
[20:55:25] <arielb1> trait Foo<T:?Sized> { fn bar(&self, foo: T, bar: [[T]], baz: [[u8]]) }
[20:57:58] <nmatsakis> arielb1: my plan is that `foo` is legal, i'm not sure about `bar` and `baz` but prob they are not.
[20:58:08] <nmatsakis> sorry, about to step out the door, I was hoping to have a PR up today, but early next week
[20:58:11] <nmatsakis> (and accompanying RFC)
[20:58:13] <arielb1> PR for?
[20:58:25] <nmatsakis> cleaned up code and revamped rules
[20:58:30] <arielb1> for?
[20:58:32] <nmatsakis> to fix various open soundness issues
[20:58:41] <arielb1> which
[20:59:19] *** Quits: arielb1 (Ariel@moz-sol.pro.64.109.IP) (Quit: Ex-Chat)
[20:59:56] <nmatsakis> see the RFCs for details: /q jroesch
[21:00:00] <nmatsakis> oops :)
[21:00:02] <nmatsakis> sorry, fishing up a link
[21:01:05] <nmatsakis> https://github.com/nikomatsakis/rfcs/tree/projection-and-lifetimes/text
[21:01:10] <nmatsakis> the two 0000-rfcs there
[21:14:35] *** Quits: achanda (achanda@moz-qv7q4n.ca.comcast.net) (Ping timeout: 121 seconds)
[21:26:09] *** Joins: achanda (achanda@moz-qv7q4n.ca.comcast.net)
[21:32:33] *** Quits: laumann (thomas@moz-n9e72h.0.fullrate.dk) (Ping timeout: 121 seconds)
[21:50:11] *** Quits: achanda (achanda@moz-qv7q4n.ca.comcast.net) (Ping timeout: 121 seconds)
[21:54:08] *** Joins: achanda (achanda@moz-qv7q4n.ca.comcast.net)
[22:59:46] <acrichto> pnkfelix: ping
[22:59:54] <acrichto> oh wait it's like 3am there

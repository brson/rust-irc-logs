[00:13:36] <dbaupp> I'm in NSW, bjz and ChrisMorgan are in Victoria, and pcmattman's in QLD(yeah?)... so we're pretty spread out.
[00:17:50] <pcmattman> yeah, QLD
[00:22:33] *** Quits: tiffany (kawaii@moz-EB8B0C08.dhcp.embarqhsd.net) (Ping timeout)
[00:24:39] *** Joins: tiffany (kawaii@moz-28A8742A.dhcp.embarqhsd.net)
[00:38:31] *** Quits: erickt (etryzelaar@8C9ECD8F.3A598286.F12515B4.IP) (Quit: leaving)
[00:41:45] *** Quits: pcwalton (pcwalton@moz-7B0110AD.mv.mozilla.com) (Quit: pcwalton)
[00:52:56] *** Quits: strcat (strcat@moz-54F7FD49.cpe.net.cable.rogers.com) (Ping timeout)
[00:53:50] *** Quits: jeffdb_ (jeff@moz-D13B6004.hsd1.ca.comcast.net) (Quit: jeffdb_)
[01:02:14] *** Quits: rusti (rusti@moz-54F7FD49.cpe.net.cable.rogers.com) (Ping timeout)
[01:02:35] *** Joins: rusti (rusti@moz-54F7FD49.cpe.net.cable.rogers.com)
[01:08:26] *** Joins: jeffdb_ (jeff@moz-D13B6004.hsd1.ca.comcast.net)
[01:09:47] *** sam113101 is now known as sam113101_afk
[01:56:18] *** Quits: geoffhill (geoffhill@moz-244CF33A.amazon.com) (Ping timeout)
[01:59:27] *** sam113101_afk is now known as sam113101
[02:07:21] *** sam113101 is now known as sam113101_afk
[02:08:38] *** sam113101_afk is now known as sam113101
[02:14:30] *** Quits: kimundi (kimundi@moz-16FE982D.dip0.t-ipconnect.de) (Ping timeout)
[02:15:52] *** sam113101 is now known as sam113101_afk
[02:17:52] *** Joins: kimundi (kimundi@moz-FD9221F2.dip0.t-ipconnect.de)
[02:21:26] *** sam113101_afk is now known as sam113101
[02:22:14] *** kimundi is now known as zz_kimundi
[02:29:18] *** zz_kimundi is now known as kimundi
[02:38:11] *** Quits: rusti (rusti@moz-54F7FD49.cpe.net.cable.rogers.com) (Client exited)
[02:38:15] *** Joins: rusti (rusti@moz-54F7FD49.cpe.net.cable.rogers.com)
[02:42:39] *** Joins: strcat (strcat@moz-54F7FD49.cpe.net.cable.rogers.com)
[03:07:02] *** Quits: kimundi (kimundi@moz-FD9221F2.dip0.t-ipconnect.de) (Ping timeout)
[03:10:23] *** Joins: kimundi (kimundi@moz-9BA34749.dip0.t-ipconnect.de)
[03:14:49] *** kimundi is now known as zz_kimundi
[03:21:38] *** zz_kimundi is now known as kimundi
[03:45:03] *** Quits: brson (brson@moz-BBE3ABD.mv.mozilla.com) (Quit: leaving)
[04:14:48] *** Quits: canhtak (jeremy@moz-3BB8F.wl.t.ulaval.ca) (Quit: canhtak)
[05:29:01] *** sam113101 is now known as sam113101_afk
[05:30:48] *** sam113101_afk is now known as sam113101
[07:00:28] *** Quits: strcat (strcat@moz-54F7FD49.cpe.net.cable.rogers.com) (Quit: sleep)
[07:03:46] *** Quits: eddyb (eddy@37F72125.9065A63B.FCAAE698.IP) (Ping timeout)
[07:07:48] *** Joins: eddyb (eddy@37F72125.9065A63B.FCAAE698.IP)
[08:00:47] *** Quits: jeffdb_ (jeff@moz-D13B6004.hsd1.ca.comcast.net) (Quit: jeffdb_)
[09:28:16] <Leo`> dafuq
[09:28:21] <Leo`> http://static.rust-lang.org/doc/0.8/std/hashmap/struct.HashSet.html
[09:28:28] <Leo`> I can't use the function from_iterator
[09:28:37] <Leo`> unresolved name `HashSet::from_iterator`
[09:37:16] <eddyb> Leo`: those are 0.8 docs :P
[10:27:30] <dbaupp> Leo`: it's part of the FromIterator trait
[10:27:45] <dbaupp> so you call it like FromIterator::from_iterator(...)
[10:28:25] <dbaupp> however, the idiomatic call is to use `.collect()` which is a just a method wrapper for it. So `foo.iter().map().whatever().collect()`
[10:33:33] <dbaupp> rusti: let v = [1,2,3,4]; v.iter().map(|&x| x).collect::<std::hashmap::HashSet<int>>().to_str()
[10:33:35] -rusti- ~"{2, 4, 1, 3}"
[10:44:55] *** Quits: devbug (quassel@23AC5F12.9D950176.3655BBF5.IP) (Connection reset by peer)
[11:16:05] *** Quits: eddyb9 (eddy@37F72125.9065A63B.FCAAE698.IP) (Quit: Leaving)
[11:42:58] *** Joins: canhtak (jeremy@moz-3BB8F.wl.t.ulaval.ca)
[11:49:47] <Leo`> I can't implement a trait on a "newtype" ? :|
[11:50:20] <dbaupp> Leo`: you can
[11:50:54] <dbaupp> rusti: struct Foo(int); impl Eq for Foo { fn eq(&self, other: &Foo) -> bool { **self == **other } } Foo(0) == Foo(1)
[11:50:55] -rusti- false
[11:52:19] <Leo`> mhh
[11:52:37] <Leo`> by newtype I mean type Foo = Bar
[11:52:49] <Leo`> but nevermind, it looks like it works eventually
[11:53:53] <dbaupp> that's a type alias or typedef, not a newtype :P
[11:54:12] <Leo`> mh
[11:54:44] <Leo`> ok
[11:54:56] <Leo`> I thought it was the equivalent for Haskell's newtype but no
[11:55:00] <Leo`> it's struct
[11:56:35] <Leo`> http://static.rust-lang.org/doc/0.8/std/to_bytes/trait.IterBytes.html this doesn't specify the type of Cb
[11:56:41] <Leo`> is this a standard type ?
[11:58:52] <Leo`> oh ok
[11:58:57] <Leo`> I can just click on it
[11:59:00] <Leo`> .____.
[12:02:17] <dbaupp> `type Foo = Bar` is the equivalent of `type Foo = Bar` in haskell
[12:02:43] <Leo`> seems legit
[12:03:13] <Leo`> how would you implement a hashing function on a Set of integers ?
[12:04:58] <Leo`> I thought of just summing the elements of the set
[12:09:23] <eddyb> bad idea...
[12:10:40] <pcmattman> set(1, 2) == set(3) then :)
[12:11:06] <pcmattman> (to be honest, "how would you implement a hashing function for a set of integers" sounds like a nice interview question)
[12:11:12] <dbaupp> http://cstheory.stackexchange.com/questions/3390/is-there-a-hash-function-for-a-collection-i-e-multi-set-of-integers-that-has
[12:13:12] <dbaupp> hm, I guess that's not really designed for a set.
[12:14:43] <dbaupp> Leo`: you could look at CPython's implementation of hash for frozenset
[12:17:12] <Leo`> or maybe I should find a better way than using "hashmaps of hashsets" :|
[12:21:25] <dbaupp> Leo`: https://github.com/python-git/python/blob/715a6e5035bb21ac49382772076ec4c630d6e960/Objects/setobject.c#L771-L797
[12:29:57] <eddyb> Leo`: wtf are you doing?
[12:30:54] <eddyb> Leo`: you can always feed hex digits into a string hasher, with a separator between numbers
[12:31:03] <eddyb> (hex because it's really easy)
[12:31:54] <dbaupp> eddyb: order
[12:32:34] <dbaupp> Rust's hashsets have random order of their elements
[12:32:54] <Leo`> eddyb: implementing an algorithm 
[12:35:02] <dbaupp> Leo`: that's the least specific answer you could possibly give :P
[12:35:10] <Leo`> I know
[12:35:21] <Leo`> I dunno the name of the algorithm
[12:35:26] <dbaupp> (well, I guess "doing things" would be less specific.)
[12:35:36] <Leo`> it builds a DFA from a regex
[12:41:24] <Leo`> it uses a set of states of the DFA
[12:41:47] <Leo`> each state corresponds to a set of "positions" in the regex
[12:41:53] <Leo`> so it's a set of sets
[12:42:17] <dbaupp> sounds like you could at least use a TreeSet, which gives you a guaranteed ordering.
[12:43:15] <dbaupp> or even `extra::bitv::Bitv`
[12:43:36] <Leo`> what's that
[12:43:54] <dbaupp> a set of integers represented by bits being 0 or 1
[12:44:08] <Leo`> mhhh
[12:44:20] <Leo`> the set of positions is not exactly a set of integers
[12:44:25] <dbaupp> it looks like it doesn't implement TotalOrd or IterBytes though. so you can't put it in a HashSet or TreeSet
[12:44:27] <Leo`> it's a set of (char, position)
[12:44:48] <dbaupp> you can convert that to integers, right :P just stick 'em in a vec and use the index as the integer
[12:46:40] <Leo`> mh yeah I suppose so
[12:47:15] <dbaupp> that doesn't really help though, since a Bitv still can't go in a HashSet
[12:47:19] <dbaupp> (or HashMap)
[13:03:59] <Leo`> yeah :/
[13:04:42] <Leo`> well I think I will re-read the algorithm and see which complexities I *actually* need
[13:04:58] <Leo`> it becomes a bit confused in my mind
[13:09:06] <Leo`> what's the complexity or eq on a Set ?
[13:09:11] <Leo`> HashSet *
[13:09:14] <Leo`> O(n) ?
[13:09:22] <dbaupp> check the implementation, but yeah, probably O(n)
[13:09:34] <Leo`> of*
[13:39:19] <Leo`> otherwise...
[13:39:57] <Leo`> I can also create a NFA and determinise it
[13:45:12] *** Parts: canhtak (jeremy@moz-3BB8F.wl.t.ulaval.ca) ()
[13:45:32] *** Joins: canhtak (jeremy@moz-3BB8F.wl.t.ulaval.ca)
[16:29:52] *** Quits: dbaupp (Thunderbir@moz-EA27E3E6.lns20.syd6.internode.on.net) (Ping timeout)
[17:05:59] *** Quits: canhtak (jeremy@moz-3BB8F.wl.t.ulaval.ca) (Quit: canhtak)
[17:20:09] <Leo`> when I declare 2 items with a let with let (a, b) = some_func_returning_pair();
[17:20:19] <Leo`> how can I have b to be mut ?
[17:23:17] *** Joins: jeffdb_ (jeff@moz-D13B6004.hsd1.ca.comcast.net)
[17:29:42] <eddyb> Leo`: I think it may be a FIXME. have you tried mut b there?
[17:30:00] <eddyb> rusti: let (a, b) = (1, 2); (a, b)
[17:30:01] -rusti- (1, 2)
[17:30:09] <eddyb> rusti: let (a, mut b) = (1, 2); b = 0; (a, b)
[17:30:10] -rusti- pastebinned 9 lines of output: http://sprunge.us/bbab
[17:30:13] <Leo`> :|
[17:31:55] *** Quits: jeffdb_ (jeff@moz-D13B6004.hsd1.ca.comcast.net) (Ping timeout)
[17:40:51] <Leo`> also, eddyb, I've got a struct that containts two own values
[17:41:02] <Leo`> I want to move them both
[17:41:09] <Leo`> (I don't care if this consumes the struct)
[17:41:16] <Leo`> but how can I do this ?
[17:41:34] <eddyb> Leo`: I'd ask in #rust, I'm still new to this :P
[17:42:32] <cmr> Leo`: pattern matchnig
[17:42:49] <cmr> let Struct { a: foo, b: bar } = some_struct;
[17:42:57] <cmr> foo and bar are now local variables.
[17:43:10] <Leo`> oO I didn't know that
[17:47:00] <Leo`> cmr: same kind of question, can I borrow a variable as mutable in a pattern matching ?
[17:47:11] <cmr> Good question'
[17:47:16] <cmr> `ref mut` exists
[17:47:41] <Leo`> i'm matching a Option<&~foo>
[17:47:49] <Leo`> i want to do something like Some(mut ref foo)
[17:47:58] <Leo`> to modify the foo in the option, if there is some
[17:48:04] <Leo`> i'm not very clear...
[17:48:32] <cmr> Leo`: that's not possible.
[17:48:43] <cmr> You have a &T, which means you cannot mutate it.
[17:48:54] <Leo`> mh
[17:49:01] <Leo`> sure
[17:50:23] <Leo`> oh but 
[17:50:41] <Leo`> I see there is a function in hashmap that returns an Option<& mut V>
[17:50:45] <Leo`> this is what I need, I think
[17:51:00] <cmr> Yes, &mut T is a different type than &T
[17:51:30] <Leo`> of course
[17:52:05] <Leo`> and concerning my previous question ?
[17:52:16] <Leo`> i've got a function that returns a (uint, ~Foo)
[17:52:32] <Leo`> I get its return value by writing something like let (i, f) = function();
[17:52:45] <Leo`> is there a way I can make f mutable ?
[17:53:08] <cmr> let mut f = f; after that line
[17:53:17] <Leo`> oh.
[17:53:31] <cmr> let (i, mut f) will work eventually.
[17:53:37] <cmr> Luqman has a patch for it
[17:53:47] <Leo`> okay
[17:53:50] <cmr> https://github.com/mozilla/rust/pull/10026
[17:54:45] <Leo`> looks fine :)
[17:55:07] <Leo`> and last question but probably most stupid one :
[17:55:20] <Leo`> i've got a let mut foo = 0
[17:55:43] <Leo`> why can't I pass it to a function that expects a &mut uint by simply doing function(&id) ... ?
[17:55:50] <cmr> &mut id
[17:56:22] <Leo`> I have to re-specify mutability when I take a reference on a variable ?
[17:56:53] <cmr> `let mut` creates a mutable binding:
[17:56:59] <cmr> 1. You can reassign
[17:57:03] <cmr> 2. You can take &mut to it
[17:57:14] <cmr> But &T and &mut T are still two different types.
[17:57:23] <cmr> You can take a &T to a `let mut`
[17:57:38] <Leo`> mhh okay
[17:58:10] <Leo`> I thought that when taking a reference to a var, it whould get its mutability
[18:01:19] <eddyb> everything is immutable unless deemed otherwise
[18:01:32] <eddyb> (apart from structs and other things, but I'm too lazy to give precise semantics)
[18:02:12] <cmr> there are no special cases for mutability.
[18:02:53] <Leo`> would*
[18:02:57] <Leo`> mh
[18:03:03] <Leo`> okay
[18:03:11] <eddyb> cmr: oh, just the field mutability inheritance for structs?
[18:03:41] <cmr> eddyb: that's not a special case. All mutability is inherited through the ownership tree.
[18:03:54] <eddyb> right
[18:04:38] <eddyb> I would like immutable fields, if possible (as an optimization), but it's fine like it is now
[18:05:16] <cmr> We used to have the opposite (mutable fields), and it makes everything harder to reason about.
[18:05:32] <cmr> I also fail to see any optimization opportunities there.
[18:05:51] <eddyb> cmr: fields that are constant after creation
[18:06:17] <eddyb> they could be inlined if they were known to be immutable
[18:06:32] <cmr> Inlined how and where?
[18:06:49] <cmr> Foo { a: some_non_const_expr() }
[18:06:56] <cmr> (A is a hypothetical immutable field)
[18:07:05] <cmr> foo(that_struct)
[18:08:28] <eddyb> it's a weak form of specialization, compared to generics or traits, but... oh, well, I did fix my problem by passing that field's value to the methods I was using it in - and the value is taken from a [u8, ..N] generic type param
[18:09:48] <eddyb> there's a large if/else chain (would've used match if that wasn't broken in macros) calling the right specialized wrapper with ::<[u8, ..N]>
[18:15:48] *** Quits: tiffany (kawaii@moz-28A8742A.dhcp.embarqhsd.net) (Ping timeout)
[18:26:43] <Leo`> now... I've got a struct that contains a ~HashSet
[18:27:00] <Leo`> how can I copy an element of the set without causing the entire struct to be borrowed ?
[18:31:45] <eddyb> Leo`: .clone(), maybe?
[18:32:15] <Leo`> clone on what ?
[18:33:19] <eddyb> dunno, what type is a set element?
[18:33:20] <Leo`> i don't want to clone the entire struct, not even the set, it wouldn't be efficient at all
[18:34:02] <Leo`> problem is I can't iter (for example) on the HashSet without causing the struct to be borrowed
[18:34:42] <Leo`> can't I "yield back" the struct after borrowing it ?
[18:37:21] <eddyb> Leo`: I was considering cloning an element, but it seems the problem is elsewhere :P
[18:38:03] <Leo`> yep
[18:38:04] <eddyb> rusti: let foo = [1, 2, 3]; for &i in foo {print!("{} ", i);}
[18:38:06] -rusti- pastebinned 13 lines of output: http://sprunge.us/DVYa
[18:38:16] <eddyb> rusti: let foo = [1, 2, 3]; for &i in foo.iter() {print!("{} ", i);}
[18:38:17] -rusti- 1 2 3 ()
[18:38:21] <Leo`> I solved it by creating a function that took the struct as a reference, and returned the thing
[18:38:33] <Leo`> but it is quite dirty 
[18:38:36] <eddyb> rusti: let foo = [0, 1, 2, 3]; for &i in foo.iter() {print!("{} ", i); foo[i] = i+1;}
[18:38:38] -rusti- pastebinned 7 lines of output: http://sprunge.us/jNWM
[18:38:38] <Leo`> takes*
[18:38:50] <eddyb> rusti: let mut foo = [0, 1, 2, 3]; for &i in foo.iter() {print!("{} ", i); foo[i] = i+1;}
[18:38:51] -rusti- pastebinned 10 lines of output: http://sprunge.us/OJJc
[18:39:10] <eddyb> rusti: let mut foo = [0, 1, 2, 3]; for &i in foo.iter() {print!("{} ", i);} foo[0] += 5; foo[0]
[18:39:10] -rusti- 0 1 2 3 5
[18:39:15] <eddyb> Leo`: ^^
[18:40:07] <Leo`> eddyb: http://paste.placeholder.fr/show/478/ this is more or less what I tried to achieve
[18:40:37] <eddyb> Leo`: hmm, can't you wrap the borrow in a block?
[18:41:06] <Leo`> I tried, but didn't change anything
[19:04:35] <cmr> eddyb: no, borrowck still isn't perfect.
[19:40:21] *** Joins: strcat (strcat@moz-54F7FD49.cpe.net.cable.rogers.com)
[19:50:40] *** Joins: canhtak (jeremy@moz-830A7AA1.wl.t.ulaval.ca)
[20:32:38] *** Joins: brson (brson@moz-BBE3ABD.mv.mozilla.com)
[20:51:02] *** Quits: brson (brson@moz-BBE3ABD.mv.mozilla.com) (Ping timeout)
[20:55:29] *** Joins: brson (brson@981AA104.E81F12CD.76F66111.IP)
[21:03:50] *** Quits: strcat (strcat@moz-54F7FD49.cpe.net.cable.rogers.com) (Quit: WeeChat 0.4.2)
[21:03:55] *** Quits: rusti (rusti@moz-54F7FD49.cpe.net.cable.rogers.com) (Client exited)
[21:05:39] *** Joins: rusti (rusti@moz-54F7FD49.cpe.net.cable.rogers.com)
[21:33:13] *** Joins: dbaupp (Thunderbir@moz-EA27E3E6.lns20.syd6.internode.on.net)
[21:41:21] <Leo`> https://dl.dropboxusercontent.com/u/68492947/Capture%20d%E2%80%99%C3%A9cran%202013-10-26%20%C3%A0%2023.39.42.png
[21:41:24] <Leo`> :D
[21:42:16] <cmr> ohh whassat
[21:42:27] <Leo`> cmr: a NFA :p
[21:42:49] <cmr> sure but what's it do
[21:42:50] <Leo`> generated from a set of regexs
[21:43:06] <Leo`> cmr: i'm doing a Lex-like
[21:43:07] <Leo`> in Rust
[21:43:10] <cmr> Oh!
[21:43:12] <cmr> Fancy
[21:43:21] <Leo`> :)
[21:44:05] <dbaupp> Leo`: looks eeeeeeeasy. :P
[21:44:15] <Leo`> dbaupp: ?
[21:44:22] <dbaupp> Leo`: a joke
[21:44:30] <dbaupp> (there are lots of 'e's)
[21:44:44] <Leo`> it's not that hard 
[21:45:16] <Leo`> I think i've done the hardest part :p
[21:45:27] <Leo`> now all I've got to do is determine it, minimize it, and write the function that matches an input against a DFA
[21:45:47] <dbaupp> and getting it merged back into the standard lib :P
[21:46:18] <Leo`> not sure if a lexical analyser generator has its place in the stdlib :p
[21:46:26] <dbaupp> the regex part does
[21:46:33] <Leo`> well maybe
[21:46:37] <dbaupp> assuming you get something matches regexes in the end.
[21:47:17] <Leo`> a lexical analyser is just a giant DFA that matches several regexes
[21:47:44] <Leo`> trying to match the longest part possible
[21:49:52] <Leo`> I read somewhere someone in the Rust core devs saying that Rust was a great langage for writing compilers
[21:50:04] <Leo`> what misses is a Lex and Yacc like :p
[21:51:12] *** Joins: devbug (quassel@23AC5F12.9D950176.3655BBF5.IP)
[21:55:54] <eddyb> lex/yacc feel sucky
[21:56:23] <eddyb> it could work with generators
[21:56:41] <eddyb> that reminds me I should try codeaze in rust :D
[21:57:09] <Leo`> codeaze ?
[21:57:27] <eddyb> my own custom parser thing
[21:57:43] <eddyb> recursive descent on primitives
[21:57:53] <eddyb> (used regexp in JS/ES6)
[22:12:06] *** Quits: canhtak (jeremy@moz-830A7AA1.wl.t.ulaval.ca) (Quit: canhtak)
[22:13:02] *** Quits: eddyb (eddy@37F72125.9065A63B.FCAAE698.IP) (Ping timeout)
[22:24:06] *** Joins: tiffany (kawaii@moz-28A8742A.dhcp.embarqhsd.net)
[22:46:34] *** Quits: tiffany (kawaii@moz-28A8742A.dhcp.embarqhsd.net) (Ping timeout)
[22:48:33] *** Joins: tiffany (kawaii@moz-EB8B0C08.dhcp.embarqhsd.net)
[23:42:10] *** sam113101 is now known as sam113101_afk

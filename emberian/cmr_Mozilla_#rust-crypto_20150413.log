[00:02:18] *** Joins: oakwhiz (oakwhiz@moz-26tbpb.vc.shawcable.net)
[00:07:03] <eternaleye> Ilari: Sure, but TLS over SCTP didn't do that...
[00:07:55] <eternaleye> Ilari: And it also threw away any semantics besides STREAM, despite every layer having all the information needed to support SEQPACKET
[00:08:08] <Ilari> AFAIK, the only standard thingy that obtains keying material off TLS-Extractor is SRTP.
[00:08:25] <eternaleye> Ilari: (I've _always_ wondered why TLS doesn't expose a SEQPACKET interface mapping 1-to-1 to records)
[00:09:17] <eternaleye> I mean, all the information is already RIGHT THERE in the protocl
[00:09:21] <eternaleye> *protocol
[00:18:15] <Ilari> What's wrong with TLS: Bad key exchange (cryptographically), Bad authentication support, key exchange is boobytrapped, etc...
[00:20:23] <bascule> lol
[00:21:55] <eternaleye> True enough
[00:23:36] <eternaleye> Although all of those are with the setup parts, which could be nicely addressed with noise/Handshake[XE]E + channel binding.
[00:23:37] <Ilari> The current key exchange in TLS 1.3 is semi-decent (cryptographically), but they are planning to revamp it.
[00:25:34] <eternaleye> One other nice thing about CHAIN: it builds the "if a record fails to validate, terminate the connection" thing into the crypto, not the implementation.
[00:26:07] <eternaleye> Since if a record fails to validate, it won't be the correct AD for the subsequent record, and everything subsequent will fail too.
[00:26:46] <eternaleye> Whereas with TLS, a bad implementation could ignore a bad record and keep going
[00:27:04] <eternaleye> With CHAIN, even that kind of failure simply results in "dead air"
[00:27:51] <eternaleye> I'm rapidly approaching the view that CHAIN is what the TLS record layer (and all similar things) should have been.
[00:28:21] <eternaleye> Because if you can require ordered behavior, it seems to be pretty much entirely optimal.
[00:30:26] <Ilari> Regarding DTLS 1.3, the same tricks as were used to derive DTLS 1.2 out of TLS 1.2 probably work there too, since DTLS 1.2 already needs to construct the key exchange in-order for things to work.
[00:39:40] *** Joins: brson (brson@moz-jjc.abh.232.109.IP)
[00:41:03] <Ilari> Also, 0-RTT is looking to be quite a hairy issue.
[00:53:54] <Ilari> Oh, and for extra fun, I think the underlying assumptions made in design of "DH-based" key exchange (reminds me of certain other infamous X-based word) are quite buggered (and when those are buggered, the crypto is pretty much to be buggered too).
[01:23:27] *** Quits: c74d3 (c74d3a4ebb6@moz-0ersgu.oc.cox.net) (Ping timeout: 121 seconds)
[01:24:16] *** Joins: c74d (c74d3a4ebb6@moz-lm47dn.mggc.hibn.4404.2002.IP)
[01:38:30] <Ilari> Okay, looks like DOWNGRADE_SCSV RFC number will be 7507. Of course, it is already pretty much obsolete.
[01:51:19] <Ilari> ~5.0% still vulernable to POODLE TLS?
[01:59:41] *** Quits: brson (brson@moz-jjc.abh.232.109.IP) (Ping timeout: 121 seconds)
[02:00:31] *** Quits: erickt (erickt@moz-njt.vqi.14.76.IP) (Ping timeout: 121 seconds)
[02:02:55] *** Joins: brson (brson@moz-cfhap5.mtv2.mozilla.com)
[02:14:46] *** Quits: brson (brson@moz-cfhap5.mtv2.mozilla.com) (Quit: leaving)
[02:44:18] *** Joins: brson (brson@moz-vvt35d.tmodns.net)
[02:45:02] *** Quits: brson (brson@moz-vvt35d.tmodns.net) (Quit: leaving)
[03:31:54] *** Joins: erickt (erickt@moz-njt.vqi.14.76.IP)
[03:50:39] *** Joins: gsingh93 (gulshan@moz-3fu4am.mi.comcast.net)
[04:06:18] *** Quits: Tobba (Tobba@moz-o13d22.bredband.telia.com) (Ping timeout: 121 seconds)
[04:42:28] <Ilari> That 5.0% is probably totally insecure for reasons other than POODLE TLS as well...
[04:45:46] <eternaleye> Ilari: Sure, but DOWNGRADE_SCSV isn't obsolete even so
[04:46:47] <eternaleye> Ilari: As long as old versions keep being suboptimal, newer versions keep being made, and #@%@#@ing browsers keep doing fallbacks, DOWNGRADE_SCSV is useful.
[04:47:36] <Ilari> Well, TLS v1.3 will be its own mess with fallbacks.
[04:48:10] <Ilari> And it doesn't help that DOWNGRADE_SCSV intolerance is actually greater than TLS v1.3 intolerance.
[04:48:46] <Ilari> IIRC, TLSv1.3 intolerance is currently ~1.5% or so.
[04:52:30] <eternaleye> Ilari: By intolerance (for the SCSV), do you mean stacks that don't support it, stacks that error out on it, or connections that fail if you turn it on?
[04:53:04] <Ilari> Ah, FALLBACK intolerance is something like ~15%.
[04:53:17] <eternaleye> Ilari: Because the last one is actually more the sum of all cases that _induce_ fallbacks in the middle of the path
[04:53:31] <eternaleye> Ilari: Rather than intolerance to the SCSV itself
[04:53:46] <Ilari> The scenario is: 1) Client tries TLSv1.3. 2) Network error causes failure. 3) Client falls back to TLSv1.2 + FALLBACK. 4) TLS v1.2 Server fails the handshake.
[04:54:31] <eternaleye> Sure, and that's actually it working as designed, not "intolerance" in the sense of it being mishandled by some party
[04:54:40] <eternaleye> The network error stuff is what it's supposed to catch
[04:55:11] <eternaleye> i.e. some third party to the connection inducing a downgrade attack on the protocol version
[04:55:12] <Ilari> Nope. The spec says server is supposed to accept, since client_version >= server_maxversion.
[04:55:53] <eternaleye> Mm
[04:56:00] <Ilari> The servers that are both intolerant to FALLBACK and v1.3 are very rare, so network error is needed to cause problems.
[04:56:33] <eternaleye> Let's just burn it all down and let the cockroaches have a go.
[04:56:57] <eternaleye> (or honestly, scrap "TLS" as a thing and make something that doesn't fucking suck)
[04:57:33] <eternaleye> Heck, could even support the certs we have now with channel binding-based auth, by signing a hash of the binding.
[04:57:41] <Ilari> And I suppose TLS stack vendors wouldn't be too thrilled at allowing server to upnegotiate (TLSv1.3 ClientHello has some extensions not present in v1.2).
[04:58:42] <eternaleye> My opinion on the vast majority of those is that they can sit and spin.
[04:59:21] <Ilari> You could even do certificate validation over HTTP after anon connection.
[04:59:32] <eternaleye> Sure.
[04:59:58] <eternaleye> Though I was more saying that if you want to provide a relatively seamless API to transfer stuff to, then you'd do it before appdata
[05:00:19] <Ilari> Pretty much needs 0RTT to be performant tho, and one sees just how nasty 0-RTT is.
[05:02:05] <eternaleye> Eh, not necessarily.
[05:02:20] <Ilari> Also if possible, it could be worthwhile to avoid having to detangle some nasty format (like X.509 certs) as part of the main protocol.
[05:02:26] <eternaleye> After all, "sign the hash of the channel binding" fits perfectly with DH,  where the server speaks first.
[05:02:48] <eternaleye> You just need to define that the server MAY offer up credentials in its first flight.
[05:03:13] <eternaleye> And leave the "credentials" as a list of enum
[05:03:25] <eternaleye> Ilari: Oh, agreed
[05:03:40] <Ilari> Well, wouldn't that then need server to signal its public key, and have the client then have to match those up somehow?
[05:03:43] <eternaleye> Ilari: But channel bindings make pluggable auth a lot better, and many of them can fit into server-speaks-first
[05:04:22] <eternaleye> Ilari: No, the "X509" auth type would carry the cert [chain] and the signed channel-binding
[05:05:12] <eternaleye> Ilari: Anyway, I'm thinking in terms of making it so that programs could be (relatively) trivially ported over
[05:05:37] <eternaleye> Ilari: X509 auth wouldn't be the only option, nor mandatory, nor recommended
[05:05:57] <Ilari> Except that with the cert chain, one would have to fish the public key out of that, which needs a X.509 parser.
[05:06:01] <eternaleye> Ilari: But it would be an option, and a convenient one for stuff that already uses TLS and has investment in the CA model
[05:06:39] <eternaleye> Ilari: And what I'm saying is that this is "Make it easy to use the better code in a less-than-optimal mode, but still better than the old crap"
[05:07:03] <eternaleye> Ilari: *without* requiring every single program rewrite its handling of encrypted connections.
[05:07:13] <Ilari> As opposed to punting the problem outside the main protocol.
[05:07:22] <eternaleye> Ilari: It would be outside the main protocol.
[05:07:39] <Ilari> How the protocol gets the public key for verification?
[05:07:57] <eternaleye> Ilari: The main protocol is pure channel binding, this is an addon making use of the server-speaks-first behavior _of_ that for the server's first flight
[05:08:55] <eternaleye> Ilari: The addon itself sends a list of (type, length, credential data) in the server's first flight, and defines one "type" as x509.
[05:09:17] <Ilari> Would be easier if one could assume just single server key, and then all certs on the server would have that as a pubkey.
[05:09:35] <eternaleye> Ilari: The idea here is to _allow people to use what they have_
[05:09:56] <eternaleye> Ilari: In order to make it _easy to deploy_
[05:10:10] <eternaleye> Ilari: Once it's deployed, better auth can be ratcheted in.
[05:10:26] <eternaleye> Ilari: It's getting a toe in the door by _not_ changing the world the first time.
[05:10:59] <eternaleye> Ilari: I swear, the worst problem with new better crypto stuff is that it's _so different_ from past stuff that it requires application-level changes
[05:11:03] <eternaleye> Ilari: And thus never happens
[05:11:38] <Ilari> What code validates the PoP on the credentials?
[05:12:06] <eternaleye> Ilari: What I'm suggesting is a sane protocol, with a very simple server-speaks-first auth addon on top of that, and then showing that the server-speaks-first auth can then fit into the APIs people are used to with TLS to make porting easily.
[05:12:19] <eternaleye> Ilari: PoP?
[05:12:29] <Ilari> Proof-of-Possession (of private key).
[05:12:52] <Ilari> Problem is, current TLS model relies on SNI, which is in client's first flight.
[05:12:53] <eternaleye> Ilari: The x509 auth type carries a signature of the channel binding
[05:12:58] <eternaleye> Ah
[05:14:01] <eternaleye> Mm, yeah, the SNI case does complicate it a bit
[05:14:09] <eternaleye> (Have I mentioned I hate multiplexers?)
[05:16:08] <Ilari> There are lots of servers that return different certs based on SNI. Because of IPv4 address shortage. And I suppose even in IPv6, where the needed addresses are just a roundoff error, admins would not appriciate using a single IP per site.
[05:16:12] <eternaleye> I mean, you could add an SNI-equivalent in the clear of the client's first flight and cover it in the handshake's SIGMA
[05:16:17] <eternaleye> Which is equivalent
[05:16:24] <eternaleye> I just think SNI was a mistake from the start...
[05:16:39] <eternaleye> SRV just came too late to help
[05:17:05] <eternaleye> I mean, we have ports. We have mappings from names to locators.
[05:17:14] <eternaleye> That's where it should have gone.
[05:18:27] <Ilari> There was talk about encrypted SNI for TLSv1.3, but the arguments against it were using different crypto for different vhosts (ugh).
[05:18:30] <eternaleye> (Seriously, I think SRV should have been a DNS RR from the beginning, and SNI should never have goddamn happened)
[05:19:43] <eternaleye> But "well-known ports" was the order of the day, and we're still paying for it.
[05:21:16] <eternaleye> If ports had never gone to the IANA, and SRV-like mapping was used instead, I think we'd be much better off.
[05:23:45] <eternaleye> Partially because all the &^(^&E multiplexers would never have proliferated to the same degree
[05:24:01] <Ilari> Lol... TCP port 1.
[05:25:27] <eternaleye> Ilari: Nanomsg has an internal implemntation of TCPMUX, sans HELP command, which it uses for much the same purpose as HTTP/2 uses SNI and ALPN.
[05:25:56] <eternaleye> Ilari: I talked them out of rolling their own protocol for it, though I couldn't get them to drop the multiplexer shit entirely.
[05:27:03] <eternaleye> Seriously, you may look at TCP 1 and think "lol, port for a stupid dead protocol", but I see "Oh yeah, that one multiplexer protocol EVERYONE KEEPS FUCKING REINVENTING IN SLIGHTLY DIFFERENT FORMS"
[05:28:29] <eternaleye> I mean, TCPMUX reduces the 5-tuple to a 4-tuple, because it had to work with ports being typed, rather than resolved.
[05:28:50] <eternaleye> (Typed in the "type of port" sense, not "typed in")
[05:29:14] <eternaleye> "80 is an http port" and other bullshit
[05:29:52] *** Joins: c74d3 (c74d3a4ebb6@moz-0ersgu.oc.cox.net)
[05:30:59] *** Quits: c74d (c74d3a4ebb6@moz-lm47dn.mggc.hibn.4404.2002.IP) (Ping timeout: 121 seconds)
[05:37:56] <Ilari> I think the standard reason why HTTP doesn't use SRV is that SRV lookups are too slow.
[05:38:29] <taryn> yeah
[05:38:35] <taryn> and extra dns lookup
[05:38:39] *** Quits: gsingh93 (gulshan@moz-3fu4am.mi.comcast.net) (Ping timeout: 121 seconds)
[05:38:46] <taryn> although
[05:38:46] <eternaleye> Ilari: No slower than an A record if you use an IP address in the SRV
[05:38:49] <taryn> srv w/anip
[05:38:50] <taryn> yeah
[05:38:51] <taryn> exactly eternaleye 
[05:39:24] <eternaleye> Ilari: With the added benefit that you can just use [] notation to use an IPv6 addr
[05:39:34] <eternaleye> Ilari: And you can use SRV's priorities and such to say which is better!
[05:40:04] <Ilari> Also, I think if target name is within the same nameserver, one can return the A and AAAA records as additional records.
[05:40:18] <eternaleye> Sure, though that bloats the result a little.
[05:40:47] <eternaleye> And relies on the nameserver not sucking
[05:41:15] <Ilari> There are all sorts of amazingly sucky nameservers out there.
[05:41:34] <eternaleye> Yup, hence why directly specifying an IP is a good option
[05:43:53] <Ilari> Doing things like returning NOTIMP if queried AAAA record. Or worse.
[05:44:54] <Ilari> Which if taken literially means that the DNS server does not support looking up records.
[05:47:25] <Ilari> IIRC, one I-D contains some hacks to deal with some utterly broken servers where just querying a record (of somewhat exotic RRTYPE) causes problems.
[05:48:58] <Ilari> Also, nameservers that one can get to claim that some name X exists and doesn't exist at the same time.
[05:50:18] <Ilari> (Because those servers don't understand the difference between NODATA and NXDOMAIN).
[05:50:59] <Ilari> ... I would not be surprised to run into nameservers that responded to AAAA query with NXDOMAIN, even to existent name.
[05:59:30] <eternaleye> You know, that might be a nice usage of Rust.
[05:59:37] <eternaleye> A non-shit DNS server
[06:00:11] <Ilari> Well, there are many. Yet, one keeps running into truly shit ones.
[06:01:29] <eternaleye> Sure, though the non-shit ones tend to be mildly nontrivial to deploy at times - BIND is, IMO, shit for entirely different reasons, and PowerDNS has a nontrivial buildsystem and if you use a binary likely has loads of superfluous dependencies.
[06:02:16] <eternaleye> Meanwhile, Rust's build story with cargo is pretty damn nice, and doesn't require absurd gymnastics for the common platforms even in the cross-compile case
[06:02:45] <Ilari> One well-known (in certain circles) shit domain DNS-wise is outlook.com
[06:02:54] <eternaleye> ...surprise?
[06:04:25] <Ilari> Surprising that it does support AAAA. But not anything more exotic.
[06:05:32] <eternaleye> I wonder how hard it'd be to write a caching nameserver that discovers names by proxying lookups, then looks up every defined RR for the name and answers using those until the TTL passes, at which point it proactively refetches.
[06:06:58] <eternaleye> And have it handle failed cases correctly (like, if it already has data, and something gives NXDOMAIN, give NODATA instead)
[06:07:07] <Ilari> And then one part of DNS suckyness is consultants that think 53/TCP is hacker attack.
[06:07:12] <eternaleye> ...
[06:07:13] <eternaleye> what
[06:07:24] <eternaleye> That-
[06:07:41] <eternaleye> What do they _think_ happens when something doesn't fit in a single UDP packet?
[06:08:05] <Ilari> I know what happens. But some consultants don't.
[06:08:30] <Ilari> And they probably don't even consider the size issue (or assume DNS can fragment somehow).
[06:12:41] <Ilari> Other consultants: CBC modes are vulernable to BEAST (which is worked around in web browsers), so let's use RC4 instead...
[06:27:54] *** Quits: erickt (erickt@moz-njt.vqi.14.76.IP) (Ping timeout: 121 seconds)
[06:41:51] <eternaleye> Oh, one bit of good news: it seems associated constants are in, which will let me move forward on my unified crypto traits
[06:49:41] <Ilari> Link?
[06:52:02] <eternaleye> Ah, no, my mistake. The RFC is in, the PR is still open: https://github.com/rust-lang/rust/pull/23606
[06:53:47] <eternaleye> Since my crypto traits are just that (traits) which concrete stuff with fixed blocksizes &c will implement, associated consts are enough for me (don't need type-level naturals just yet)
[06:55:25] <Ilari> Heh, reminds me of GCM, and how it could be generalalized to other blocksizes. Also, the odd bit order(!) it has.
[06:56:39] <eternaleye> Ilari: GCM in general, or AES-GCM independent of the AES blocksize?
[06:57:15] <eternaleye> Ilari: Because in the former case, it'd just be the generic GCM construction using the constant from its block-cipher type parameter
[06:57:25] <eternaleye> Ilari: In the latter, KILL IT WITH FIRE.
[06:57:54] <Ilari> Independent of AES blocksize.
[06:58:05] <eternaleye> ...FIRE. LOTS OF FIRE.
[07:29:19] <Ilari> Of course, GCM is nasty to implement without CLMUL... If one wants any kind of actual security.
[07:30:33] <eternaleye> One thing I'm really liking is how Rust's move semantics make it very easy to avoid API misuse for crypto traits
[07:31:16] <eternaleye> For instance, I can define trait Sponge: Write { type Squeezable: Read; fn finish(self) -> Self::Squeezable; }
[07:31:33] <eternaleye> And that's a perfectly serviceable definitionm, that enforces the API be used correctly
[07:35:15] <Ilari> Of course, then there are protocols that are not well-behaved cryptographically. Like TLS. And fixing that seems to be impossible
[07:35:24] <eternaleye> Yup
[07:36:08] <Ilari> I think one can even prove that some of the externally visible features of TLS are impossible to implement in well-behaved way.
[07:37:00] <Ilari> No matter what you do with the key exchange (including changing it).
[07:37:23] <eternaleye> Ilari: Do you have any suggestions on a trait name that beat "BlockTransform" ? Its sole function takes a fixed-size array as input, and produces an array of the same size as output.
[07:37:28] <eternaleye> *beats
[07:38:04] <Ilari> tls-unique and resumption are a good candidate for feature pair that is fundamentally incompatible with well-behaved crypto.
[07:39:00] <Ilari> And probably tls-extractor in itself.
[07:40:57] <Ilari> As to how TLS libraries handle that: Those just implement whatever crypto necressary, well-behaved or not.
[08:03:20] <Ilari> ... Since when dealing with most implementations, cryptographically well-behaved or not doesn't really matter.
[08:34:22] *** Joins: Tobba|Laptop (Tobba@moz-1hh.7ki.21.217.IP)
[09:50:48] *** Quits: Tobba|Laptop (Tobba@moz-1hh.7ki.21.217.IP) (Ping timeout: 121 seconds)
[10:03:06] *** Joins: Tobba|Laptop (Tobba@moz-1hh.7ki.21.217.IP)
[10:38:00] <Ilari> Huh... 78M "PKIX" certificate corpus for testing
[11:56:35] *** Joins: theme (theme@moz-i3mhhb.asianet.co.th)
[11:56:59] *** Joins: gleb (gleb@moz-3u1drv.rusanovka-net.kiev.ua)
[12:36:15] *** Quits: Tobba|Laptop (Tobba@moz-1hh.7ki.21.217.IP) (Ping timeout: 121 seconds)
[13:47:08] *** Quits: theme (theme@moz-i3mhhb.asianet.co.th) (Quit: Leaving)
[14:06:56] *** Joins: Tobba (Tobba@moz-o13d22.bredband.telia.com)
[15:55:19] *** Joins: brson (brson@moz-cfhap5.mtv2.mozilla.com)
[16:50:01] *** Joins: erickt (erickt@moz-4hh.6p3.217.74.IP)
[17:03:27] *** Quits: gleb (gleb@moz-3u1drv.rusanovka-net.kiev.ua) (Ping timeout: 121 seconds)
[17:04:51] *** Joins: gleb (gleb@moz-3u1drv.rusanovka-net.kiev.ua)
[17:17:08] *** Joins: gsingh93 (gulshan@moz-3fu4am.mi.comcast.net)
[17:35:53] *** Quits: erickt (erickt@moz-4hh.6p3.217.74.IP) (Connection closed)
[17:51:35] *** Joins: erickt (erickt@moz-4hh.6p3.217.74.IP)
[18:12:05] <Ilari> Yay, SSLv3 diediedie document got approved.
[18:12:21] <bascule> yeah heh
[18:12:27] <bascule> omg Ilari 
[18:12:31] <bascule> we're shutting off RC4
[18:12:32] <bascule> finally
[18:12:33] <bascule> :o
[18:13:16] <tiffany> and mozilla is trying to deprecate plaintext http
[18:15:54] <bascule> so is Google
[18:16:48] <tiffany> that's good
[18:17:35] <tiffany> whenever someone undertakes such endeavours the thing I worry about is that when browser vendors disagree on things, it ends up dying
[18:18:23] <tiffany> we might even have a proper bytecode replacement for javascript by now if mozilla and google didn't both decide to NIH their own extremely incompatible things
[18:35:36] <eternaleye> tiffany: asm.js vs PNACL?
[18:35:40] <tiffany> yeah
[18:35:53] <eternaleye> tiffany: Yeaaaah, I'm actually not all that fond of _either_
[18:36:08] <tiffany> they're both kind of ridiculous
[18:36:12] <eternaleye> tiffany: PNACL is built on LLVM bitcode, which is explicitly not intended to form a stable ABI
[18:36:49] <eternaleye> tiffany: While asm.js is just a set of hints to the optimizer, rather than actually forming a proper bytecode spec
[18:36:59] <tiffany> yeah
[18:37:10] <tiffany> and uses a lot of space because of that
[18:37:30] <eternaleye> Personally, I'd be in favor of burning it all down and using lua bytecode, or similar.
[18:37:53] <tiffany> lua's bytecode isn't stable either
[18:38:11] <eternaleye> Sure, but you can pick a version (each of which is stable) and put that in the header.
[18:38:42] *** Quits: brson (brson@moz-cfhap5.mtv2.mozilla.com) (Quit: leaving)
[18:38:51] <tiffany> I would rather build a new bytecode built to be extensible and a decent compiler target
[18:38:59] <eternaleye> True enough
[18:39:02] <tiffany> as opposed to being luac's internal representation in binary form
[18:39:17] <eternaleye> Clearly, we should just use RISC-V's instruction set!
[18:39:25] <eternaleye> :P
[18:39:25] <tiffany> heh
[18:39:43] <tiffany> I was actually thinking of SPIR-V, although can't actually use it, since it's built around GPUs
[18:39:55] <eternaleye> tiffany: Er, no, it's not really
[18:40:12] <eternaleye> tiffany: SPIR-V is pretty general
[18:40:24] <tiffany> it would require a new capability set, wouldn't it?
[18:40:35] <tiffany> shaders and cl kernels are pretty specific
[18:40:55] <tiffany> there's also the other problem of SPIR-V not having a defined binary format
[18:59:11] *** Quits: oakwhiz (oakwhiz@moz-26tbpb.vc.shawcable.net) (Ping timeout: 121 seconds)
[19:07:02] <kmc> <eternaleye> tiffany: While asm.js is just a set of hints to the optimizer, rather than actually forming a proper bytecode spec
[19:07:06] <kmc> i don't think that's really true
[19:07:14] <kmc> asm.js code uses a completely different path in SpiderMonkey
[19:07:25] <kmc> which basically does a single pass compilation and then runs it
[19:07:29] <kmc> much like you would on a bytecode
[19:08:14] <kmc> the most important difference between PNaCl and asm.js as solutions for native code on the web is that asm.js code talks to standard Web APIs and PNaCl code talks to APIs based on Chrome internals that other browsers can't feasibly implement
[19:08:59] <kmc> otoh, google at one point wanted to work with mozilla on modernizing NPAPI, but Mozilla wasn't interested
[19:09:04] <tiffany> I don't really know that much about asm.js besides that it's a strict subset of javascript
[19:09:07] <kmc> so they are both NIH in a sense
[19:09:12] <tiffany> it's not really x86 specific is it?
[19:09:26] <kmc> no, where did that come from?
[19:09:41] <tiffany> regular old NaCl is and I wanted to make sure
[19:09:48] <kmc> ah
[19:09:54] <Dcoder> wasn0t nacl ported to arm already?
[19:10:08] <tiffany> there is an ARM version, but you need to produce multiple binaries, one for each supported architecture
[19:10:10] <kmc> PNaCl does verification on the machine code output of LLVM
[19:10:16] <kmc> that's important
[19:10:32] <tiffany> PNaCl is different, though
[19:10:47] <kmc> yeah, I'm just saying that the verifier is platform-specific either way
[19:11:26] <tiffany> asm.js is only supported by firefox right?
[19:11:44] <cmr> and Spartan
[19:11:46] <kmc> it will run in any browser
[19:11:52] <tiffany> it will run, but very slowly
[19:11:53] <cmr> at least, with an AOT compiler.
[19:12:04] <kmc> IE is adding an optimized path for asm.js code
[19:12:38] <kmc> tiffany: it depends, of course, but often like 2x slower, not 100x
[19:12:42] <tiffany> I guess I could use asm.js as a backend instead? that would massively bloat the size of any webpage though
[19:12:45] <kmc> JS engines are crazy fast
[19:13:16] <Dcoder> and js is crazy, period
[19:13:30] <tiffany> I suppose compression helps..
[19:13:36] <tiffany> asm.js is probably quite low entropy
[19:14:40] <kmc> i dunno
[19:14:52] <kmc> minified JS code can be pretty dense
[19:15:14] <kmc> and machine code isn't really that dense
[19:15:49] <kmc> in minified JS code you can refer to thousands of different variables with a 2 or 3 byte sequence, which isn't possible in most machine architectures
[19:16:31] <Dcoder> can js beat perl in that dept?
[19:16:36] <kmc> probably not
[19:16:52] <bascule> hopefully now that the CFRG has its house in order, WebCrypto will give you native implementations of the NaCl ciphers
[19:17:02] <cmr> bascule: wrong nacl ;)
[19:17:05] <Dcoder> hahaha its house in order
[19:17:05] <bascule> oh
[19:17:07] <bascule> lol
[19:17:16] <bascule> Dcoder: I'm pleasantly surprised by the results!
[19:17:37] <Dcoder> it's been weirdly non-combative, i give you that
[19:18:13] <bascule> Ben Black disappeared
[19:18:17] <bascule> then things started going more smoothly
[19:18:39] <Dcoder> oh yeah, i barely noticed that
[19:18:42] <Dcoder> but you're right
[19:21:01] <Ilari> Also, Lua bytecode is infamous for security issues.
[19:21:05] <eternaleye> kmc: I was under the impression, though, that even after "use asm;" code containing arbitrary js would work, rather than failing to compile?
[19:22:07] <eternaleye> kmc: That's what I mean by "hint to the optimizer" - it doesn't provide narrow baseline semantics the rest of the system is implemented on top of; it just allows you to note "Hey, I'm not intending to use high-level stuff" so it can sub in something more optimal for that case perf-wise
[19:23:06] <eternaleye> kmc: Since my interest is less in the "run native code in the browser" department and more "provide an interface where the browser doesn't have so much need to be a compiler for a very broad set of semantics"...
[19:24:02] <tiffany> ilari: because it can do things you can't do in source form, and completely bypass pretty much every kind of sandbox mechanism you can device
[19:24:10] <tiffany> devise*
[19:24:23] <kmc> eternaleye: spidermonkey probably implements that by aborting the asm.js compiler entirely and going back to the normal JIT
[19:24:38] <Ilari> Also, standard Javascript has many semantics that are just nasty to compile.
[19:24:48] <eternaleye> kmc: Sure, but what I mean is that it doesn't really allow any stronger reasoning about the behavior of code
[19:25:17] <kmc> it does in terms of performance
[19:25:22] <kmc> but yeah
[19:25:24] <eternaleye> kmc: With a proper bytecode, you could validate that yes, arbitrary bytecode sequences are constrained to not break isolation/security/etc
[19:25:37] <kmc> well I think you can statically validate that js conforms to asm.js
[19:25:39] <eternaleye> kmc: With asm.js, you still have the whole JS model lurking off behind the corner
[19:25:39] <kmc> if that's the question
[19:25:43] <eternaleye> kmc: Mm, true
[19:26:11] <Ilari> tiffany: Nope, the things that it can represent but source code can't fall into two categories: 1) Harmless stuff. 2) All kinds of subtly invalid bytecode.
[19:27:05] <Ilari> tiffany: It got so bad that in 5.2 they added extra parameter to load Lua code functions that lets one disable loading bytecode (so it only loads source).
[19:27:45] <eternaleye> kmc: But then there's how low-level asm.js is since it's meant to be a compilation target for normally-native languages, which means it throws away more semantic meaning relative to a purpose-designed bytecode for dealing with the browser environment
[19:28:00] <kmc> yeah
[19:28:14] <kmc> there are a lot of things it's not suitable for
[19:30:19] <Ilari> I suppose the crap one encounters if one tries to compile JS are similar as to what one would run into if trying to compile Lua...
[19:32:07] <Ilari> Both have things like loose typing, higher-order functions and function creation at runtime.
[19:37:48] *** Joins: oakwhiz (oakwhiz@moz-26tbpb.vc.shawcable.net)
[19:44:39] <kmc> don't forget that JS's  eval("...")  can modify the surrounding scope too!
[19:44:55] <kmc> these days, it only does that if you call it literally as 'eval' and not through, say, 'var evil = eval;'
[19:45:05] <kmc> otherwise efficiently compiling JS would be ~impossible
[19:45:40] <kmc> also the `with` statement is pure madness
[19:46:11] <kmc> i mean it's awesome if you are designing a toy language around scheme and self to do little animations in a webbrowser
[19:46:23] <kmc> it's not awesome if you are designing the language that millions of people will use to build complex apps
[19:46:26] <kmc> "designing"
[19:47:30] <Ilari> What does "with" do?
[19:48:13] <kmc> with (myObject) { x; /* actually refers to myObject.x */ }
[19:48:50] <kmc> basically it causes every local variable within the scope to be an object field looup including prototypes etc
[19:48:54] <kmc> and that's ridicusouly dynamic
[19:49:43] <Ilari> Isn't that equivalent to just some code rewriting?
[19:50:17] <kmc> I don't know if it's hard to compile but it's super hard to reason about formally
[19:50:20] <Ilari> Or does it do some fun fallbacks?
[19:50:25] <kmc> i don't know the full story, either
[19:52:00] <Ilari> Pretty much there has to be something nontrivial into it if it is supposed to be difficult. Because pure rewriting isn't difficult (unless language parsing is already very difficult).
[19:53:56] *** Joins: oakwhiz_ (oakwhiz@moz-26tbpb.vc.shawcable.net)
[19:54:55] <sfackler> Groovy has the same thing, which is kind of useful if you're writing DSL-y things
[19:55:07] *** Quits: oakwhiz (oakwhiz@moz-26tbpb.vc.shawcable.net) (Ping timeout: 121 seconds)
[19:55:46] <Ilari> Oh yes, there are fallbacks with 'with'. So that explains why it is hell.
[19:56:04] <sfackler> (of course Groovy is a bit of a nightmare as well)
[19:56:38] <tiffany> ilari: I know of at least one user of lua which actually patched lua 5.1 to disable bytecode loading
[20:03:43] *** Quits: erickt (erickt@moz-4hh.6p3.217.74.IP) (Ping timeout: 121 seconds)
[20:15:06] *** Joins: erickt (erickt@moz-4hh.6p3.217.74.IP)
[20:21:07] *** Quits: erickt (erickt@moz-4hh.6p3.217.74.IP) (Ping timeout: 121 seconds)
[20:29:11] *** Joins: erickt (erickt@moz-4hh.6p3.217.74.IP)
[20:39:55] *** Quits: erickt (erickt@moz-4hh.6p3.217.74.IP) (Ping timeout: 121 seconds)
[21:14:31] *** Joins: erickt (erickt@moz-4hh.6p3.217.74.IP)
[21:18:41] *** Joins: brson (brson@moz-cfhap5.mtv2.mozilla.com)
[22:19:17] *** Quits: coyotebush (quassel@moz-5oq2q4.coreyford.name) (Ping timeout: 121 seconds)
[22:28:12] <Ilari> tiffany: One of my apps IIRC checks for bytecode and refuses to load those.
[23:01:16] *** Joins: oakwhiz (oakwhiz@moz-26tbpb.vc.shawcable.net)
[23:03:10] *** Joins: oakwhiz__ (oakwhiz@moz-26tbpb.vc.shawcable.net)
[23:03:15] *** Quits: oakwhiz_ (oakwhiz@moz-26tbpb.vc.shawcable.net) (Ping timeout: 121 seconds)
[23:05:57] *** Quits: oakwhiz (oakwhiz@moz-26tbpb.vc.shawcable.net) (Ping timeout: 121 seconds)
[23:32:09] *** Joins: coyotebush (quassel@moz-5oq2q4.coreyford.name)
[23:54:42] *** Joins: fungos (quassel@moz-p1o.6pj.156.69.IP)

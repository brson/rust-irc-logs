[00:14:33] <eternaleye> FYI, Matthew (of Matrix) posted a first-draft of their e2e stuff, and is soliciting feedback in freenode/#matrix - https://github.com/matrix-org/matrix-doc/commit/36e035c79e5efccb76a429194efdc19fcc450d0b
[00:19:49] <bascule> I can't tell if I like Matrix or not
[00:21:57] <eternaleye> bascule: Point in their favor: When I pointed out some issues with their crypto on an LWN article, Matthew showed up and actually took it seriously
[00:23:34] <eternaleye> bascule: And actively solicits feedback on crypto, and is using Axolotl as the core of e2e rather than rolling something from scratch
[00:33:44] <bascule> that all seems ok
[00:34:16] <bascule> but it seems like they fall into the classic trap of building a bunch of crap with no actual motivating use case
[00:34:49] <bascule> it's all a "platform" to punt to the next person
[00:38:51] <bascule> https://twitter.com/ageis/status/619659101946052608
[00:38:56] <eternaleye> bascule: I don't really agree - in particular, big use cases I've personally heard from devs include eliminating the need for IRC bouncers (whether via replacing IRC with Matrix, which has history; or via IRC gateways, which already work); running your own HomeServer on something like the FreedomBox to control your own infra; secure group chat that is neither proprietary nor snake-oil nor has a SPOF; etc.
[00:39:09] <eternaleye> bascule: And these are things that the devs are already doing personally.
[00:39:14] <bascule> design needs to be user-centric
[00:39:16] <eternaleye> bascule: Also some of the non-devs
[00:39:27] <eternaleye> Tor is running his own HS because he wanted to
[00:39:32] <bascule> preferably driven by UX-people, not crypto wanks
[00:39:40] <eternaleye> (Not Tor the protocol; the modern derivative of Thor)
[00:39:42] <bascule> s/wanks/wonks/
[00:39:47] <bascule> but uhh, yeah
[00:40:08] <eternaleye> And Matrix has way more UI folks than crypto wonks :P
[00:40:14] <bascule> orly
[00:40:18] <bascule> where's the UX design doc?
[00:40:26] <bascule> also UI != UX :P
[00:40:32] <eternaleye> bascule: Do you want the one for the new React-js UI?
[00:40:33] <bascule> I have a coworker who proves ^^^
[00:40:36] <eternaleye> Mm
[00:40:38] <bascule> sure
[00:41:28] <eternaleye> Also, Tor implemented a Weechat plugin in ~3 days, because he prefers Weechat :P
[00:42:01] <bascule> Weechat or WeChat?
[00:42:11] <bascule> also: fuck WeChat
[00:42:50] <bascule> like I still think Signal has terrible UX
[00:42:53] <bascule> I can barely get it to work
[00:43:01] <bascule> at least they're UX-motivated
[00:43:02] <eternaleye> bascule: Weechat
[00:43:07] <bascule> I haven't heard of that
[00:43:09] <eternaleye> bascule: The one that's usually an IRC client
[00:43:12] * bascule looks for a screenshot to be judgy
[00:43:21] <bascule> lololol
[00:43:22] <eternaleye> https://github.com/matrix-org/matrix-doc/blob/master/drafts/use_cases.rst
[00:43:26] <eternaleye> bascule: UX doc
[00:43:27] <bascule> well that looks like my current irssi
[00:43:46] <bascule> ok that seems like a good start
[00:43:51] <bascule> lots of text and not a lot of pictures though
[00:44:06] <eternaleye> bascule: Their crypto folks are basically "The picky people in #matrix" :P
[00:44:16] <eternaleye> bascule: And a couple in-house
[00:44:40] <eternaleye> bascule: I'm pickyn and in #matrix, but I have no illusions about my skill level
[00:45:16] <eternaleye> bascule: Hence why I'm trying to get more picky, skilled people looking at stuff
[00:45:33] <bascule> I think you have to start with UX and work backward or you won't get anywhere
[00:45:41] <bascule> and be extremely, snobishly opinionated, heh
[00:45:47] <bascule> as a UX person
[00:45:50] <bascule> not a crypto person
[00:45:54] <bascule> the latter should take a back seat
[00:46:02] <bascule> security should also take a back seat
[00:46:14] <eternaleye> bascule: Sure, and they have - they laid out their UX desiderata, and the crypto constraint at that point was basically "does not prevent end-to-end message confidentiality"
[00:46:14] <bascule> and when people bitch and moan and whine, tell them to shut the fuck up
[00:46:24] <eternaleye> They explicitly punted on metadata confidentiality
[00:46:33] <bascule> seems good, that's privacy vs anonymity
[00:46:46] <bascule> OWS also punts on anonymity, which is fine
[00:46:51] <bascule> Moxie-in-the-middle and I don't care ;)
[00:47:17] <eternaleye> And now they're defining how that e2e condidentiality should work, so they're asking for help making sure it's not fucking terrible :P
[00:47:24] <eternaleye> *confidentiality
[00:48:09] <eternaleye> But so far, crypto's mainly been a tool to achieve their UX goals
[00:48:26] <eternaleye> Like how they use it to make the whole DAG-of-messages thing that their UX relies on work
[00:55:57] <Ilari> Oh fun: There is hacked PKCS#11 module for Firefox that pretends that the card only has one key, in order to improve UX, as firefox seems to want to ask all pins.
[00:56:57] <eternaleye> p11 needs to DIAF
[00:57:18] <bascule> eternaleye: I dislike the DAG of messages ;)
[00:57:25] <eternaleye> bascule: How come?
[00:57:27] <Ilari> (I think Iceweasel PKCS11 package actually contains it in Debian).
[00:57:29] * bascule wants a fully linerizable total ordering of events!
[00:57:32] <bascule> eternaleye: too complicated, bad UX
[00:57:51] <eternaleye> bascule: ohgod, you're one of THOSE PEOPLE!1111one!1!eleven :P
[00:58:04] <eternaleye> bascule: Nah, the UX is pretty damn nice
[00:58:05] <bascule> what, someone who prefers a simpler solution?
[00:58:10] <eternaleye> bascule: It's a DAG at the server level
[00:58:16] <bascule> what happens if messages get delivered out-of-order?
[00:58:19] <eternaleye> bascule: The _user_ sees linearized events
[00:58:23] <bascule> ok
[00:58:29] <bascule> that's "fine" then
[00:58:43] <bascule> all users should see events arrive in the same order, always
[00:58:52] <eternaleye> Ah, that's not the case
[00:58:52] <bascule> no "bouncing around" when messages get delivered out of order
[00:58:54] <bascule> that's madness
[00:59:01] <eternaleye> It's eventual-consistency backfill
[00:59:04] <bascule> lol
[00:59:06] <bascule> yeah that's bad
[00:59:13] <eternaleye> Eh
[00:59:18] <eternaleye> Honestly? It works.
[00:59:30] <bascule> I don't like it
[00:59:34] <eternaleye> Better than IRC where you actually can get client-reordered messages
[00:59:42] <bascule> I guess I will have to write my own chat app when I leave Square ;)
[00:59:52] <eternaleye> With Matrix, there may be holes, but they close up, and the result is never divergent
[00:59:53] <Ilari> Special Relativity: There is no global ordering of cause and effect. :->
[01:00:09] <bascule> yeah like
[01:00:15] <bascule> what I'm proposing goes against Moxierules
[01:00:16] <bascule> I don't care
[01:00:32] <eternaleye> bascule: What you're proposing goes against _physical reality_ :P
[01:00:48] <bascule> no
[01:00:49] <bascule> wrong
[01:01:04] <bascule> bro do you even Spanner or HyperDex
[01:01:21] <eternaleye> bascule: bro do you even Delay-Tolerant Networking?
[01:01:26] <bascule> linerizable is achieveable
[01:01:29] <bascule> blah
[01:01:33] <bascule> linearizability is achievable
[01:01:50] <eternaleye> https://tools.ietf.org/html/rfc4838
[01:01:58] <eternaleye> :P
[01:02:02] <bascule> and a massive simplifying principle for these sorts of systems
[01:02:22] <bascule> the system I'm describing can gracefully tolerate delays
[01:02:32] <eternaleye> bascule: And it also kills some of the use cases for Matrix, like fault-tolerant messaging in disaster-relief
[01:02:34] <bascule> especially if it's just a single client or a few clients
[01:02:37] <bascule> what
[01:02:38] <bascule> no
[01:02:39] <bascule> wrong
[01:03:09] <bascule> you need something like CRDTs
[01:03:25] <bascule> although I would probably punt on that at first
[01:03:45] <eternaleye> bascule: Um, their DAG _is_ a CRDT
[01:03:49] <eternaleye> bascule: It never rolls back
[01:03:49] <bascule> haha cool
[01:03:54] <eternaleye> bascule: It _fills in_ holes
[01:04:06] <bascule> for what I have in mind, I would probably punt on all that
[01:04:07] <eternaleye> bascule: "eventual consistency" is exactly what it does
[01:04:07] <bascule> and just be CP
[01:04:12] <bascule> sure
[01:04:22] <bascule> they want AP, I want CP
[01:04:29] <eternaleye> Sure
[01:04:38] <eternaleye> But CP means you are offline in partition
[01:04:49] <bascule> it means you can't write during a partition
[01:04:56] <eternaleye> Which breaks real-world disaster-relief messaging, yes
[01:05:06] <bascule> ok fine, let them have the "disaster relief" use case :P
[01:05:17] <eternaleye> It also breaks a bunch of other things
[01:05:30] <bascule> I would rather have the "fully linerizable system that's simple to implement and works" use case
[01:05:33] <eternaleye> Any case with intermittent connectivity (not delay, connectivity)
[01:05:39] <bascule> no
[01:05:49] <eternaleye> Sure, but they've already got multiple independent implementations
[01:05:52] <bascule> great
[01:05:53] <eternaleye> In multiple languages
[01:05:54] <bascule> I don't care
[01:06:05] <eternaleye> I think that's good evidence for simple _enough_ to implement and works :P
[01:06:11] <bascule> they have a whole UX doc without any wireframes
[01:06:13] <bascule> wtf
[01:06:20] <bascule> what does the UI of this thing actually look like?
[01:06:25] <eternaleye> <bascule> also UI != UX :P
[01:06:28] <eternaleye> :P
[01:06:29] <bascule> I know bro
[01:06:35] <bascule> do you know what ^^^ means?
[01:06:52] <eternaleye> That the user experience covers both more and less than the interface itself
[01:07:03] <bascule> it means that there are people who can take a PSD and do a great job of turning it into minimalistic HTML and CSS
[01:07:08] <eternaleye> It covers the workflow and such, and doesn't necessarily cover the silly graphical stuff
[01:07:12] <bascule> possibly building a framework to abstract those concerns away!
[01:07:18] <bascule> and still build totally unusable software
[01:07:19] <bascule> but still
[01:07:26] <bascule> some idea of how it looks is kind of important?
[01:07:37] <bascule> lol "silly graphical stuff"
[01:07:47] <eternaleye> bascule: "Should this widget be green or blue"
[01:07:53] <eternaleye> bascule: UI concern, but not UX concern
[01:07:57] <bascule> do you know what a wireframe is?
[01:08:00] <eternaleye> bascule: Yes
[01:08:02] <bascule> they generally don't have colors
[01:08:31] <eternaleye> bascule: However, considering there's Irssi-like Weechat, React.js, the Android client, the iOS client, and they all have different UI idioms...
[01:08:34] <bascule> they're either hand drawn (on paper) or made using a tool like https://precursorapp.com/
[01:08:39] <eternaleye> bascule: I think you place too much weight on wireframes
[01:08:45] <bascule> hahaha
[01:08:55] * bascule just wants real designers to design stuff
[01:09:12] <eternaleye> bascule: The Android client, and an Irssi client, have completely different idioms, because the _context_ differs
[01:09:19] <bascule> how to spot someone who doesn't know UX: they want to make wireframes on a whiteboard
[01:09:33] <eternaleye> bascule: The wireframe depends on the context, which limits its usefulness for that doc
[01:09:57] <bascule> and then they're in the hole of building a platform and not a tool
[01:10:17] <bascule> I wish them luck
[01:10:19] <eternaleye> bascule: Uh, they're building both...
[01:10:25] <bascule> seems like they're more concerned with UX than most
[01:10:35] <eternaleye> bascule: The UX concerns of each tool are a superset of the UX concerns of the platform
[01:10:42] <eternaleye> bascule: But they, the same team, are doing both
[01:10:49] <eternaleye> bascule: That doc is the platform UX doc
[01:10:56] <bascule> where's their actual UX docs?
[01:10:57] <eternaleye> bascule: And thus the baseline for the tools'
[01:11:23] <eternaleye> bascule: dunno, I'd have to look - wasn't especially curious, as I'm not a UX guy
[01:11:37] <eternaleye> bascule: The platform UX is as close as I like to get to UI
[01:11:37] <bascule> https://twitter.com/ageis/status/619659101946052608
[01:11:49] <bascule> ^^^ I liked that
[01:12:49] <eternaleye> bascule: And then ignored point 6 :P
[01:13:23] <eternaleye> bascule: But so far as I can see, Matrix obeys all of them
[01:13:46] <eternaleye> bascule: The android client, for example, allows you to log in, join rooms, talk, and get notified.
[01:13:46] <bascule> no, I ignored point 5
[01:14:16] <dcb> It's not impossible to build a system that is CP and can handle the disaster recovery scenario.  You just have to partition keys on a geographic basis, and make sure that a majority of the replicas for a geography are in that geography.  Kind of hand wavy, but whatever
[01:14:17] <eternaleye> bascule: Global linearization breaks at least one of 5 and 6
[01:14:20] <eternaleye> But it could be others
[01:14:25] <eternaleye> er, either
[01:14:29] <bascule> I'd say it breaks 5 but not 6
[01:14:38] <bascule> or rather
[01:14:39] <eternaleye> bascule: It's implementation-dependent
[01:14:42] <bascule> if you think it breaks 6
[01:14:43] <bascule> then 6 is stupid
[01:14:50] <eternaleye> bascule: See Google Spanner for breaking 6 but not 5
[01:15:07] * bascule talking about systems that can be reasoned about in terms of temporal logic
[01:15:18] <bascule> if your interpretation of 6 is "fuck time, fuck temporal logic" then yes it breaks 6
[01:15:31] <eternaleye> bascule: No, it's fuck _globally-consistent_ time
[01:15:36] <bascule> that's irrelevant
[01:15:55] <bascule> you can produce a total ordering of events without globally consistent time
[01:15:59] <eternaleye> bascule: Yes
[01:16:10] <eternaleye> bascule: Hence why I said "could be either" and "implementation-dependent"
[01:16:26] <eternaleye> bascule: But it must break at least one
[01:16:39] <bascule> that's the whole raison d'etre of these sorts of algorithms
[01:16:43] <Ilari> Wasn't there brief discussion about PKCS#11 changes needed for supporting a new signature primitive?
[01:16:49] <Ilari> ... On CFRG?
[01:16:54] <eternaleye> bascule: Either it requires synchronous consensus, or globally consistent time
[01:17:04] <bascule> Ilari: yes PKCS#11 mandates IUF and thus IUF we get?
[01:17:12] <bascule> eternaleye: I'm describing the former
[01:17:13] <eternaleye> bascule: (and really, synchronous consensus _is_ globally consistent time in an event clock)
[01:17:26] <bascule> it's not "globally consistent time"
[01:17:43] <bascule> it relies on a single node determining the total order of events for a particular key/topic/channel
[01:17:51] <eternaleye> "event clock"
[01:18:21] <bascule> if you do ^^^, a lot of the incidental complexity melts away
[01:18:31] <bascule> at the cost of higher latency for the participants
[01:18:32] <eternaleye> bascule: And Paxos is not a single node doing it :P
[01:18:37] <bascule> but they also never see misordered messages
[01:18:42] * bascule not talking about Paxos :P
[01:18:56] <eternaleye> bascule: And that latency is potentially infinite
[01:19:05] <bascule> if the network is down, sure
[01:19:16] <bascule> that affects the peer whose network is down
[01:19:18] <eternaleye> bascule: Because consistency over asynchronous networks is a proven-insoluble problem
[01:19:21] <bascule> it shouldn't affect the rest of the participants
[01:19:22] <bascule> I know
[01:19:35] <Ilari> Outside smartcards and other very constrained devices, if signer has problems with offline signing, the verifier is probably going to have bad time.
[01:19:44] <bascule> the so-called "impossibility result"?
[01:20:04] <bascule> tell ya what
[01:20:14] <bascule> I'm gonna go off and do my own thing, eventually, when I don't have another day job
[01:20:18] <bascule> and we'll see who wins ;)
[01:20:25] *** Quits: vks (quassel@moz-42n5l0.pools.vodafone-ip.de) (Ping timeout: 121 seconds)
[01:21:18] <eternaleye> bascule: Mainly, I just think you're drastically overestimating how much DAG-ordering complicates things over global-ordering
[01:21:32] <eternaleye> bascule: Since the client just needs sparse-linear, rather than DAG
[01:22:01] <bascule> eternaleye: not sure you completely understand what I'm going for, nor am I particularly inclined to spill all the beans
[01:22:07] <eternaleye> Fair enough
[01:22:16] <bascule> let
[01:22:18] <bascule> bleh
[01:22:34] <bascule> let's just say I'm targeting enterprise use cases more than a bunch of people trying to set up mesh wireless to fight a hostile regime
[01:22:42] <eternaleye> Mm
[01:23:03] <eternaleye> Admittedly, Matrix is targeting both :P
[01:23:24] <eternaleye> (Also, if there's only one homeserver in a room or conversation, ordering is 'global')
[01:23:29] <bascule> if you're targeting both, you're really targeting the latter
[01:23:48] <eternaleye> Which is the case if all peer accounts are on the same HS, which is usually the enterprise case
[01:24:20] <eternaleye> Multi-site introduces the capacity for one branch of the DAG per HS involved
[01:24:28] * bascule needs to GTFO
[01:24:29] <bascule> ttyl
[01:24:33] <eternaleye> bye!
[01:27:12] <Ilari> Online verification is only possible with some protocols, and those tend to not accumulate very much data to be signed anyway.
[01:34:46] *** Joins: dpc (dpc@moz-t6gr4b.ca.comcast.net)
[01:37:02] <Ilari> Also, are there any PKCS series specs that don't need to DIAF?
[01:40:02] <eternaleye> Ilari: PBKDF2 from PKCS#5? Possibly PKCS#3 (Diffie-Hellman)?
[01:41:07] <eternaleye> Ilari: Sure, PBKDF2 isn't _amazing_, but it's also not that bad either
[01:44:39] <Ilari> Isn't that FFDH? Or some sort of general DH?
[01:47:40] *** Quits: brson (brson@moz-cfhap5.mtv2.mozilla.com) (Connection closed)
[01:51:40] <eternaleye> Ilari: Sure, but the spec doesn't need to DIAF because "terrible spec", it's just about a primitive whose time has passed
[01:51:57] *** Quits: dcb (dcb@moz-4hh.6p3.217.74.IP) (Quit: My Mac has gone to sleep. ZZZzzz…)
[01:58:33] *** Quits: dpc (dpc@moz-t6gr4b.ca.comcast.net) (Ping timeout: 121 seconds)
[02:06:57] <bascule> speaking of that sort of thing
[02:07:02] <bascule> I think I have a web site I need to make
[02:08:39] <bascule> woop domain available
[02:08:41] <bascule> this will be fun
[02:26:02] <eternaleye> Huh, I just realized a neat thing about Aaron Swartz' method of squaring Zooko's Triangle while reading Dan Kaminsky's evaluation of it
[02:26:12] <eternaleye> "But of course, it’s no work at all to strip content from the scroll, since we can always remove content and get back to 0-hash."
[02:26:17] <eternaleye> O HAI THAR MACAROONS
[02:38:46] *** Joins: dcb (textual@moz-v6l3du.ca.comcast.net)
[02:43:13] <Ilari> Also, apparently Mozilla::PKIX doesn't implement many "features" of RFC5280.
[02:47:00] <bascule> I think I saw Brian Smith mention something about that
[02:50:29] *** Quits: dcb (textual@moz-v6l3du.ca.comcast.net) (Ping timeout: 121 seconds)
[02:51:25] <bascule> what's the best way to make a well-formatted IETF draft du jour
[02:51:45] *** Joins: dcb (textual@moz-v6l3du.ca.comcast.net)
[02:52:21] <Ilari> I think there are tools for both XML and markdown. Or something.
[02:52:24] <bascule> have things advanced past last time I did this and you wrote some XML that got mangled by some XSLT
[02:52:32] <bascule> into both text and HTML
[02:54:48] <Ilari> There's this: https://github.com/miekg/pandoc2rfc/
[02:55:45] <bascule> aha!
[02:56:51] <bascule> https://github.com/miekg/mmark
[02:57:37] <bascule> things have improved in the last decade, lol
[02:59:13] <Ilari> Planning to make a draft?
[02:59:55] <bascule> not a real one
[03:00:07] <bascule> just wanted to format something in that style
[03:00:20] <bascule> maybe it could become a draft, lol
[03:00:34] <bascule> like a real ietf one, not a parody one I post on a web site
[03:01:03] <bascule> once upon a time I was assigned port 6086
[03:01:54] *** Joins: dpc (dpc@moz-t6gr4b.ca.comcast.net)
[03:11:52] *** Quits: eddyb (eddyb@moz-5k2.pug.25.188.IP) (Ping timeout: 121 seconds)
[03:14:43] *** Joins: eddyb (eddyb@moz-pic.82i.25.188.IP)
[03:22:39] *** Quits: dcb (textual@moz-v6l3du.ca.comcast.net) (Quit: My Mac has gone to sleep. ZZZzzz…)
[03:46:43] *** Quits: dpc (dpc@moz-t6gr4b.ca.comcast.net) (Ping timeout: 121 seconds)
[03:47:39] *** Joins: dcb (textual@moz-v6l3du.ca.comcast.net)
[04:01:36] *** Quits: dcb (textual@moz-v6l3du.ca.comcast.net) (Quit: My Mac has gone to sleep. ZZZzzz…)
[04:06:28] *** Joins: dcb (textual@moz-v6l3du.ca.comcast.net)
[04:06:33] *** Joins: brson (brson@moz-1t0.c9m.56.172.IP)
[04:12:10] *** Joins: dpc (dpc@moz-t6gr4b.ca.comcast.net)
[04:31:41] *** Quits: dcb (textual@moz-v6l3du.ca.comcast.net) (Quit: My Mac has gone to sleep. ZZZzzz…)
[04:33:41] * bascule reads starfighter intro
[04:33:45] <bascule> AVR is not like MSP430. It's not like X86. It is not, as Thomas claims, "like someone vomited up an instruction set". It's a complicated microcontroller instruction set designed for tiny parts with small programs that don't change often. To date, I've 'discovered' 142 instructions through test code. There are something like 16 load and 13 store instructions. A summary table can be found on pages 10-12 of the ATMega8515 Datasheet Summary. 
[04:34:17] <bascule> https://en.wikipedia.org/wiki/Atmel_AVR_instruction_set
[04:34:50] <bascule> but Tom, I really don't care about old shitty CPUs!
[04:39:55] <bascule> Ilari: should there be a diediedie WG? ;)
[04:45:13] <eternaleye> bascule: ...that really sounds like someone vomited up an instruction set.
[04:45:28] <eternaleye> bascule: After eating several from the dumpster.
[04:50:54] *** Joins: dcb (textual@moz-v6l3du.ca.comcast.net)
[04:51:35] *** Quits: dcb (textual@moz-v6l3du.ca.comcast.net) (Quit: My Mac has gone to sleep. ZZZzzz…)
[04:53:15] *** Joins: dcb (textual@moz-v6l3du.ca.comcast.net)
[04:57:59] *** Quits: dpc (dpc@moz-t6gr4b.ca.comcast.net) (Ping timeout: 121 seconds)
[05:01:40] *** Joins: dpc (dpc@moz-t6gr4b.ca.comcast.net)
[05:03:39] *** Quits: brson (brson@moz-1t0.c9m.56.172.IP) (Connection closed)
[06:38:37] *** Quits: dpc (dpc@moz-t6gr4b.ca.comcast.net) (Ping timeout: 121 seconds)
[06:51:00] *** Quits: dcb (textual@moz-v6l3du.ca.comcast.net) (Quit: My Mac has gone to sleep. ZZZzzz…)
[06:51:09] *** Joins: dcb (textual@moz-v6l3du.ca.comcast.net)
[08:18:14] *** Joins: vks (quassel@moz-b54qc9.fias.uni-frankfurt.de)
[08:19:22] *** Joins: Tobba (Tobba@moz-4l45on.skybroadband.com)
[08:27:15] *** Quits: dcb (textual@moz-v6l3du.ca.comcast.net) (Quit: My Mac has gone to sleep. ZZZzzz…)
[09:20:07] *** Joins: gleb (gleb@moz-3u1drv.rusanovka-net.kiev.ua)
[09:26:36] <Elaine> bascule: did starfigher launch?
[09:27:21] <Elaine> eternaleye: eh, it's nice enough to use.
[09:27:35] *** Quits: Tobba (Tobba@moz-4l45on.skybroadband.com) (A TLS packet with unexpected length was received.)
[09:28:35] <Elaine> it is not aesthetically pleasing, but so what
[11:31:20] *** Quits: vks (quassel@moz-b54qc9.fias.uni-frankfurt.de) (Ping timeout: 121 seconds)
[12:14:13] <Ilari> Haha: 'Sorry - you lost me at "secure" and "swf" :)'
[12:56:28] <eternaleye> Ilari: swf can be secure! The trick is not running it!
[13:24:17] <Ilari> Hmm... Compiling list of annoyances various signature primitives have. I somehow get the feeling that "could be fairly slow" (about hashing on smartcards) would be an understatement...
[14:03:52] *** Joins: Tobba (Tobba@moz-oecqnu.plus.com)
[14:41:27] *** Quits: Tobba (Tobba@moz-oecqnu.plus.com) (A TLS packet with unexpected length was received.)
[14:55:23] *** Joins: brson (brson@moz-cfhap5.mtv2.mozilla.com)
[15:19:43] *** Joins: vks (quassel@moz-b54qc9.fias.uni-frankfurt.de)
[16:11:51] *** Joins: dcb (textual@moz-v6l3du.ca.comcast.net)
[16:13:14] *** Quits: vks (quassel@moz-b54qc9.fias.uni-frankfurt.de) (Ping timeout: 121 seconds)
[16:24:56] *** Quits: dcb (textual@moz-v6l3du.ca.comcast.net) (Quit: My Mac has gone to sleep. ZZZzzz…)
[17:09:32] *** Joins: dcb (dcb@moz-4hh.6p3.217.74.IP)
[17:22:37] *** Joins: vks (quassel@moz-42n5l0.pools.vodafone-ip.de)
[17:23:17] *** Joins: mcpherrin (mcpherrin@moz-clk6gh.ca.comcast.net)
[19:02:24] *** Quits: dcb (dcb@moz-4hh.6p3.217.74.IP) (Quit: My Mac has gone to sleep. ZZZzzz…)
[19:27:32] *** Joins: dcb (dcb@moz-4hh.6p3.217.74.IP)
[19:38:04] <Ilari> bascule: Also, wonder how one could annoy sites still using HTTP, without breaking too much with local devices (which seem to have serious problems with HTTPS)...
[19:42:23] <Ilari> Wonder if at some point third-party active content is removed from HTTP support or something like that...
[19:45:59] <Tiffany> is there a poll anywhere that collects reasons why sites lack https?
[19:46:37] <Tiffany> I imagine there's a lot of FUD out there
[19:46:58] <Ilari> Certainly small sites that host forums have severe problems with http links. And then there are likely multitude of pictures, so one can't use upgrade-insecure-requests.
[19:48:52] <Ilari> And HSTS is already quite scary, let alone HPKP (which one needs to deploy for actual security).
[19:49:17] <Ilari> It doesn't help that apparently defaults with Let's Encrypt is to roll keys, which is not compatible with HPKP.
[19:49:43] <Tiffany> some excuses I can think of: certificates cost money, PKI is untrustworthy or otherwise imperfect and therefore as bad or worse than plaintext, shitty homebrew framework/webserver doesn't support it, site is covered in http:// links, performance problems
[19:50:10] <Tiffany> that second to last one isn't wrong, but it's not a very good excuse when you can just run squid or nginx as a reverse proxy
[19:50:19] <Ilari> Also, "I don't have anything private nor login".
[19:50:42] <Ilari> Also, don't use crap crypto. That does wonders for the last one.
[19:51:00] <Tiffany> maybe difficulty to configure might rank on there as well
[19:51:09] <Tiffany> seeing how many people screw it up
[19:51:21] <Tiffany> web servers should really come with sane defaults...
[19:51:35] <Ilari> Well, OpenSSL is terrible to configure. Even Gnutls, which is loads better is hard.
[19:52:17] <Tiffany> part of the problem is probably the lack of autoconfig
[19:52:38] <Tiffany> if there was some sort of autoconfig mechanism, the webserver could just generate dh primes itself
[19:52:47] <Tiffany> hm
[19:52:52] <Tiffany> maybe it could just generate them on startup?
[19:53:01] <Tiffany> I don't remember it taking particularly long
[19:53:19] <Ilari> Tiffany: dh primes? You don't need those if you don't use 70s crypto.
[19:53:40] <Tiffany> well unfortunately a bit under half of the clients listed on ssl labs only support DHE, ilari
[19:54:03] <Tiffany> I mean I guess you could go with paranoid security by default, but then everyone will just downgrade it
[19:54:07] <Tiffany> which will be even worse
[19:54:18] <Ilari> About everything that does anything above TLS 1.0 (soon those are hung high and dry) does ECDHE.
[19:54:37] <Tiffany> like, using TLS 1.2 + ECDHE cuts off just under half of all android phones
[19:55:09] <Ilari> Yeah, those darn old unsupported android phones are a major problem. Let's see how they like when sites taking credit cards have to cut them off.
[19:55:31] <Tiffany> oh, PCI is going to ditch 1.0?
[19:55:57] <Ilari> It is already in transition time (and new services don't get any).
[19:56:40] <Tiffany> oh
[19:56:49] <Tiffany> well, that's nice
[19:57:06] <Tiffany> I wish google would do something about android
[19:57:19] <Tiffany> they should cutout the middlemen when it comes to important updates
[19:57:24] <Ilari> Well, they have already EOL'd the versions that don't do TLS 1.2.
[19:57:43] <Tiffany> the OEMs should only be distributing driver blobs, not the whole OS
[19:57:55] <Tiffany> oh
[19:58:05] <Ilari> Or at least effectively have.
[19:58:06] <Tiffany> so even google won't go back and fix it?
[19:58:14] <Tiffany> don't the newer android versions have higher system requirements?
[19:59:26] <Ilari> Also, if you ask Mozilla TLS config generator for modern parameters, it gives something that isn't compatible with old stuff. Unfortunately, it has DHE enabled.
[19:59:50] <Tiffany> I forgot about that
[20:00:11] <Tiffany> it really bothers me that we have so much effectively abandoned hardware platforms people are still using that aren't getting security updates of any kind
[20:00:14] <Tiffany> it feels irresponsible
[20:00:42] <Ilari> There are people that say that supporting unsupported platforms or clients is irresponsible.
[20:01:37] <Ilari> One was in context of article about how many PHP installs are unsupported (there was some issues collecting the data, given that there are pretty old distro-supported versions).
[20:01:59] <Tiffany> I don't like that argument when applied to hardware
[20:02:39] <Tiffany> software, sure
[20:03:04] <Tiffany> there's like a billion devices that pretty much have no future other than to be thrown away because they're full of security vulnerabilities, even if they still work fine
[20:03:22] <Tiffany> maybe this is a temporary issue
[20:03:36] <Ilari> Also, there are embedded devices that have security holes they have, can't be updated and will have lifetime of >10 years.
[20:06:17] <Tiffany> I don't really see any way out of this issue, non-PC computing devices are almost seen as consumable goods at the moment
[20:06:25] <Tiffany> they get support for 2-3 years and then they're left to die
[20:06:33] <Tiffany> embedded devices are even worse
[20:07:20] <Tiffany> embedded device issues can be mitigated by using rust, at least
[20:07:28] <Tiffany> I wonder if there will be something like VCC for rust soon
[20:07:59] <Ilari> Well, not things like using crap protocols.
[20:08:47] <Tiffany> are there any existing tls libraries in rust?
[20:09:00] <Ilari> But then, transport that is secure even today could have been constructed back in 2001 (with publication of SHA-2).
[20:09:08] <Ilari> Tiffany: No, there aren't. :-/
[20:09:17] <Tiffany> I see suruga
[20:09:21] <Tiffany> but it's incomplete, isn't it?
[20:09:26] <Ilari> Tiffany: Well, there is one seriously incomplete one.
[20:10:08] <Tiffany> maybe I should try working on that a bit
[20:10:32] <Tiffany> I don't know if this motivation streak I have from the horror of embedded devices is going to last more than a couple minutes
[20:11:46] <Ilari> Tiffany: The ciphers that I think are worth anything in TLS: AES-GCM and Chacha20-Poly1305 (there are two variants of this). Unfortunately, due to apple stuff, one might also need AES-CBC on server side. And the only key exchange worth anything is ECDHE.
[20:12:07] <Tiffany> yeah, there's the google private use codepoint and the draft RFC, right?
[20:12:19] <Tiffany> and the RFC uses a 96-bit nonce with a 32-bit block counter
[20:12:30] <Tiffany> for reasons I'm not sure of
[20:12:35] <Tiffany> 96-bit nonces seem like an awkward length
[20:13:00] <Ilari> Not really, but not enough for random generation.
[20:13:22] <Tiffany> yeah
[20:14:48] <Tiffany> there's not really any reason to have more than 64-bit nonces (unless you're planning on sending 10 quintillion messages on the same key, I guess?) when doing counters, and less than 128 bit isn't really safe for random generation
[20:14:53] <Ilari> As for certs, both RSA and ECDSA (and when CFRG stuff appears, that) should be supported. Curves: P-256, P-384, P-521, Curve25519 (when it gets codepoint), Curve448 (ditto).
[20:15:44] <Tiffany> and changing it introduces needless incompatibility (although as long as you leave the low 32 bits of the nonce zero and use less than 2^32 blocks, it stays compatible iirc)
[20:16:06] <Ilari> Well, if you have 128-bit keysize (well, Chacha20 doesn't), extra nonce size is nice for preventing multi-key attacks from eating your security margins.
[20:17:29] <Ilari> Basically, with 128-bit keys, one has to be careful not to accidentially weaken security. With 256 bits, some accidential weakening isn't a big deal.
[20:21:25] <Ilari> Tiffany: The way the I-D uses nonces is to have upper 32 bits generated per-connection (from master secret) and lower 64 bits be block counter.
[20:21:46] <Tiffany> I-D?
[20:23:04] <Ilari> Internet-Draft (things that may become RFCs later, or not).
[20:23:09] <Tiffany> oh
[20:23:37] <Tiffany> I guess I'd better read the TLS 1.2 RFC
[20:24:31] <Ilari> Tiffany: Also, note that TLS 1.2 has some security fix extensions. Secure Renegotiation (which is years old bug) and Extended Master Secret (a.k.a. session hash), which is quite recent.
[20:24:55] <Tiffany> I heard something or other about secure renegotiation
[20:24:57] <Ilari> The latter isn't RFC yet, but should be stable to implement (codepoints have been assigned, just waiting for RFC Editor to copyedit it).
[20:26:00] <Ilari> I think that with secure renego, the client and server should require it. EMS is so new it can't be required (but SHOULD be supported, I think with security fix priority).
[20:28:03] <Ilari> Tiffany: Maybe useful first task would be adding AES-GCM (be careful with timing attacks!) and newer Chacha20-Poly1305 (use Gnutls codepoints so you can do interop tests).
[20:28:48] <Ilari> Tiffany: And then another major missing part is client/server key proof-of-possession (followed by certificate chain validation).
[20:30:49] <Ilari> One idea: Make server certificate check unbypassable (handshake fails if cert is not ok), but let library user set the trust anchors (including trusting server end-entity cert directly) and TLSA records to be used.
[20:33:36] <Tiffany> why does this library implement both the protocol and the ciphers
[20:34:54] <Tiffany> hm
[20:35:40] <Tiffany> I don't remember why bascule wanted me to use sodiumoxide over rust-crypto
[20:35:57] <Ilari> Better implementations of various crypto primitives?
[20:36:10] <Tiffany> sure
[20:36:17] <Tiffany> but rust-crypto has the benefit of being almost pure rust
[20:36:24] <Tiffany> except for this silly C+inline assembly bit
[20:37:00] <Ilari> I would be pretty suspicous about AES-GCM implementation in rust-crypto (but I haven't checked it).
[20:37:16] <Tiffany> does the one in libsodium avoid timing attacks?
[20:37:42] <Ilari> I think it might?
[20:38:45] <Tiffany> so the one in rust-crypto uses either AES-NI or the one located in aessafe.rs
[20:38:58] <Tiffany> and it has a comment mentioning timing problems, and says it uses no data-dependent table lookups
[20:39:16] <Tiffany> I'm not sure how that works
[20:39:17] <Ilari> TODO: Test how timing-safe the non-AES-NI implementation in rust-crypto actually is.
[20:39:49] <Ilari> Tiffany: The problem is, rust compiler can "optimize" in ways that create timing problems from code that had none.
[20:39:56] <Tiffany> it looks like it uses bit slicing
[20:41:07] <Tiffany> I don't see any lookup tables
[20:41:42] <Tiffany> yeah, SubBytes really doesn't use a lookup table
[20:43:00] <Ilari> Tiffany: The problem with doing that testing is that I would need modified version of rust-crypto with AES-NI disabled.
[20:43:41] <Tiffany> ah, yeah
[20:43:48] <Tiffany> it directly tests cpuid for it
[20:44:12] <Tiffany> oh, but only when compiled on x86
[20:44:23] <Tiffany> for obvious reasons
[20:44:38] <Tiffany> hm
[20:44:49] <Tiffany> I don't see an alternate definition of supports_aesni() though
[20:45:04] <Tiffany> so it would fail to compile on non-x86?
[20:45:33] <Tiffany> it wouldn't be a very intrusive change
[20:45:41] <Tiffany> you'd just have to change the #[cfg] block in util.rs
[20:46:07] <Ilari> On non-x86, it doesn't check for AES-NI.
[20:46:22] <fkr> good evening
[20:46:30] <Tiffany> oh, you're right
[20:47:08] <Tiffany> it does look like the authors went out of their way to make sure their implementation isn't prone to timing attacks, but I suppose the only way to really know is to test it
[20:48:14] <Tiffany> so yeah
[20:48:24] <Tiffany> it looks like it avoids timing problems the same way hardware impls do
[20:48:39] <Tiffany> by just computing the S-box table contents directly, instead of reserving space for it
[20:49:25] <Tiffany> and it does that by using bit slicing
[20:49:29] <Tiffany> which is an interesting thing
[20:49:51] <Tiffany> is there any use for  bit slicing besides implementing hardware-friendly ciphers in software?
[20:53:28] <Tiffany> "Secure hash functions (e.g., SHA-1, etc.) are used for MAC computations."
[20:53:38] <Tiffany> I see, TLS 1.2 RFC
[21:04:50] <bascule> Ilari: I'm down for scarybar
[21:04:57] <bascule> http:// should show a broken lock
[21:05:00] <bascule> if nothing else
[21:05:09] <bascule> an open lock that's cracked in half
[21:05:30] <Tiffany> how about just an X?
[21:05:41] <Tiffany> a cracked lock looks too much like a regular lock
[21:06:05] <Tiffany> I think when you add exceptions in chrome it will cross out the https:// with a red X
[21:06:09] <Tiffany> it should do the same for http://
[21:11:08] *** Joins: dpc (dpc@moz-7gui97.nvidia.com)
[21:11:40] <Ilari> Ok, as far as I can tell, the non AES-NI AES-GCM in rust-crypto looks timing-safe (for some odd reason, I can't properly test if the AES-NI version is constant-time).
[21:12:26] <Ilari> The AES-GCM API in rust-crypto looks pretty bad.
[21:13:53] <Tiffany> why?
[21:14:07] <Tiffany> .. oh
[21:14:10] <Tiffany> there's no AD
[21:14:19] <bascule> rust-crypto :(
[21:14:40] <Tiffany> or, no
[21:14:42] <Tiffany> it's just weird
[21:15:16] <Tiffany> the aad is part of the constructor
[21:15:19] <Tiffany> for some reason
[21:15:24] <Ilari> And nonce too...
[21:15:28] <Tiffany> oh, yeah
[21:15:29] <Tiffany> wtf
[21:15:38] <Tiffany> what's the point in having these be separate functions?
[21:15:54] <bascule> Tiffany: on a semi-related note, how are you liking sodiumoxide? ;)
[21:16:16] <Tiffany> it's alright, but there is something about having a pure-rust implementation which would be attractive
[21:16:47] <Ilari> Tiffany: Well, low-level crypto functions are usually not source of memory unsafety.
[21:16:54] <Tiffany> I suppose
[21:17:07] <Tiffany> and of all things, libsodium is the one most likely to be correctly engineered
[21:17:16] <Ilari> Tiffany: Also, with NIST curves, one has to be damn careful about all sorts of edge cases.
[21:17:40] <Tiffany> why do the NIST curves suck so much?
[21:19:41] <Ilari> Tiffany: Such as P and/or Q infinity, P=Q, P=-Q, base field arithmetic exceptional cases (I think "few" in some descriptions is at most 7).
[21:23:47] <Ilari> Probably curves that didn't suck weren't invented back then + incorrect assumptions about base field arithmetic speed.
[21:25:37] <Tiffany> does TLS support non-NIST curves yet?
[21:25:47] <Tiffany> also, is there hope NIST will standardize non-sucky curves?
[21:26:10] <Ilari> Not yet, there's I-D about it in TLS WG.
[21:28:21] <Ilari> There's also Chacha20 I-D. I guess I should ask what issues it has before it can go to WGLC.
[21:31:25] *** Quits: dpc (dpc@moz-7gui97.nvidia.com) (Ping timeout: 121 seconds)
[21:34:03] <bascule> yeah, people are trying really hard to get modern curves into TLS
[22:01:40] *** Joins: Tobba (Tobba@moz-o13d22.bredband.telia.com)
[22:48:15] <Ilari> Wonder how much time it will take until Firefox and Chrome get support for THS fix.
[22:55:59] <Ilari> ... Hmm... For some reason fixing THS in NSS is seeming to involve some shit about PKCS#11... :-/
[22:59:15] *** Quits: dcb (dcb@moz-4hh.6p3.217.74.IP) (Quit: My Mac has gone to sleep. ZZZzzz…)
[23:00:20] <zeiris> bascule: microcontrollers are the last bastion of software that might be auditable/understandable. AVR's a poor choice for something suited to automated analysis, but still a decent playground.
[23:00:30] <zeiris> Really looking forward to starfighter :)
[23:02:38] <Tiffany> that's interesting
[23:02:56] *** Joins: dcb (dcb@moz-4hh.6p3.217.74.IP)
[23:03:00] <Tiffany> seVXWorks, anyone?
[23:03:19] <bascule> zeiris: fuck that, let's just put non-updatable ARMs running Linux in every lightswitch
[23:03:39] <Tiffany> oh it's styled VxWorks
[23:05:13] <zeiris> Oh they're updatable, you just have to get RCE first then upload a Wassenar-exempt remote debugger :)
[23:05:54] <Tiffany> hmm
[23:06:12] <Tiffany> we are heading towards the hacking minigames in deus ex, aren't we
[23:06:41] <Tiffany> even the most trivial piece of electronics is filled to the brim with networked embedded systems blooming with vulnerabilities, with various exploit detection kits watching over them
[23:07:22] <zeiris> Research into automated exploitation makes a lot more sense when you think of targeting the Thingernet rather than 100-MB browser/PDF reader .exes
[23:07:49] <bascule> lololol zeiris 
[23:12:01] <zeiris> Fun embedded device project: bootloader that loads an application encrypted at rest with an ignition key, that key being derived from user inputs. Triggering a tamper switch zeroizes the device.
[23:13:39] <zeiris> This is straightforward to implement on stuff that boots from external EEPROMs or runs on FRAM, can be bolted on to any application firmware compatible with the device, and is the only type of IP protection that'll stand up to well-equipped attacks.
[23:31:08] <Ilari> Also, designing a security protocol that lasts for long time before it croaks is not that easy.
[23:32:50] <Ilari> And for practical reasons, it would be pretty much one true ciphersuite stuff if intended for one or both end to be embedded.
[23:36:35] <Ilari> Also, fun that when I described how signature negotiation in TLS 1.2/1.3 works, many seemed to assume I was describing some crazy new scheme. :-)
[23:41:47] <zeiris> There's some embedded protocols out there that look pretty future-proof. I like Bluetooth Low Energy's enumeration mechanisms, and CoAP isn't horrible either. But for crypto one is stuck with known-broken pairing mechanisms, and the other is at the mercy of embedded DTLS libraries. :p
[23:41:56] *** Quits: gleb (gleb@moz-3u1drv.rusanovka-net.kiev.ua) (Ping timeout: 121 seconds)
[23:46:26] <eternaleye> Ilari: (backlogging) unbypassable cert auth but can set trust root "(including trusting server end-entity cert directly)" - I don't think that's possible. If the trust root has to be set first, this requires one handshake to GET the cert and set it, then another to connect. If one gets a callback after receiving the server cert, it's just one line to accept the cert blindly... no different than "return true" in a validation callback.
[23:49:33] <eternaleye> bascule: What I want to do is create a trait-only lib, that offers traits that any primitives would impl for proper interop
[23:52:16] <eternaleye> bascule: So for example, there'd be struct AesNi128 which would impl Keyed<Keysize=128> + BlockTransform<Block=[u8; 16]>
[23:55:36] <eternaleye> bascule: Then there could be struct Xex<C> where C: Keyed + BlockTransform;  which would impl Keyed<KeySize=C::KeySize> + Tweakable<TweakSize=mem::size_of<C::Block>()> (once SIZE is an assoc const _or_  mem::size_of is a const fn) + BlockTransform<Block=C::Block>
[23:59:24] <bascule> eternaleye: this sounds familiar!
[23:59:32] <eternaleye> bascule: Yes, I've mentioned it before
[23:59:35] <bascule> haha
[23:59:37] <bascule> umm also
[23:59:43] <bascule> 1s
[23:59:44] <eternaleye> bascule: I keep getting blocked on assoc const/assoc type/const fn things

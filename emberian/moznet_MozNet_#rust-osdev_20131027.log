[00:08:07] *** Quits: tiffany (kawaii@moz-EB8B0C08.dhcp.embarqhsd.net) (Ping timeout)
[00:09:51] *** sam113101_afk is now known as sam113101
[00:10:12] *** Joins: tiffany (kawaii@moz-28A8742A.dhcp.embarqhsd.net)
[00:24:27] *** Quits: rusti (rusti@moz-54F7FD49.cpe.net.cable.rogers.com) (Client exited)
[00:26:07] *** Joins: rusti (rusti@moz-54F7FD49.cpe.net.cable.rogers.com)
[00:27:31] *** sam113101 is now known as sam113101_afk
[00:28:04] *** sam113101_afk is now known as sam113101
[02:52:54] *** Quits: tiffany (kawaii@moz-28A8742A.dhcp.embarqhsd.net) (Ping timeout)
[02:53:21] *** Joins: tiffany (kawaii@moz-28A8742A.dhcp.embarqhsd.net)
[03:05:34] *** Quits: kimundi (kimundi@moz-9BA34749.dip0.t-ipconnect.de) (Ping timeout)
[03:09:22] *** Joins: kimundi (kimundi@moz-2953ED52.dip0.t-ipconnect.de)
[03:13:21] *** kimundi is now known as zz_kimundi
[03:20:27] *** zz_kimundi is now known as kimundi
[03:39:22] *** Joins: canhtak (jeremy@moz-830A7AA1.wl.t.ulaval.ca)
[04:12:33] *** Quits: canhtak (jeremy@moz-830A7AA1.wl.t.ulaval.ca) (Quit: canhtak)
[05:37:23] *** Joins: eddyb (eddy@37F72125.9065A63B.FCAAE698.IP)
[05:58:20] *** Quits: dbaupp (Thunderbir@moz-EA27E3E6.lns20.syd6.internode.on.net) (Ping timeout)
[06:00:57] *** Joins: dbaupp (Thunderbir@moz-EA27E3E6.lns20.syd6.internode.on.net)
[06:11:19] *** Joins: jld (jld@moz-B94C75AD.xlerb.net)
[06:49:22] *** Quits: brson (brson@981AA104.E81F12CD.76F66111.IP) (Quit: leaving)
[09:52:50] *** Quits: dbaupp (Thunderbir@moz-EA27E3E6.lns20.syd6.internode.on.net) (Ping timeout)
[09:56:31] *** Joins: dbaupp (Thunderbir@moz-620B4FD1.lns20.syd6.internode.on.net)
[10:34:01] *** Quits: devbug (quassel@23AC5F12.9D950176.3655BBF5.IP) (Connection reset by peer)
[10:42:20] *** Quits: dbaupp (Thunderbir@moz-620B4FD1.lns20.syd6.internode.on.net) (Input/output error)
[10:42:43] *** Joins: dbaupp (Thunderbir@moz-620B4FD1.lns20.syd6.internode.on.net)
[13:59:24] *** Joins: canhtak (jeremy@moz-830A7AA1.wl.t.ulaval.ca)
[14:00:45] *** Parts: canhtak (jeremy@moz-830A7AA1.wl.t.ulaval.ca) ()
[15:00:43] *** Quits: rusti (rusti@moz-54F7FD49.cpe.net.cable.rogers.com) (Ping timeout)
[15:17:42] *** Joins: rusti (rusti@moz-54F7FD49.cpe.net.cable.rogers.com)
[16:08:04] *** Joins: canhtak (canhtak@moz-830A7AA1.wl.t.ulaval.ca)
[16:37:20] <Leo`> i've got a trait A, and a trait B<T: A>
[16:37:47] <Leo`> i implemented A for a type S, and now I impl B<S> for U
[16:37:59] <Leo`> but when I tired to use U as a B, i've got :
[16:38:36] <Leo`> failed to find an implementation of B<<v19>> for ~U
[16:38:37] <Leo`> :|
[16:41:57] <eddyb> ~U is a different type
[16:45:25] <Leo`> mhhhh
[16:45:30] <Leo`> oh I see
[16:46:25] <Leo`> but the error appears when I try to pass a U to a function that takes a &B
[16:46:30] <Leo`> i've got a ~U
[16:46:44] <Leo`> so I do func(&*U)
[16:46:48] <Leo`> but it doesn't help
[16:47:34] <Leo`> *u is a U, so it's a B, since U implement B<S>
[16:47:48] <Leo`> so &*u should be an &B
[17:27:57] *** Joins: jeffdb_ (jeff@moz-D13B6004.hsd1.ca.comcast.net)
[17:52:47] *** Quits: rusti (rusti@moz-54F7FD49.cpe.net.cable.rogers.com) (Ping timeout)
[18:11:06] *** Quits: tiffany (kawaii@moz-28A8742A.dhcp.embarqhsd.net) (Ping timeout)
[18:35:20] <Leo`> wtf
[18:35:45] <Leo`> i've got a fn that takes a &mut std::rt::io::Writer
[18:35:58] <Leo`> i can't pass it std::rt::io::stdio::stdout()
[18:36:17] <Leo`> but stdout returns a StdWriter, that implement Writer
[18:36:26] *** Joins: strcat (strcat@moz-54F7FD49.cpe.net.cable.rogers.com)
[18:36:50] <Leo`> expected `&mut std::rt::io::Writer<no-bounds>` but found `&mut std::rt::io::stdio::StdWriter`
[18:36:52] <Leo`> wtf ?
[18:37:14] <Leo`> http://static.rust-lang.org/doc/0.8/std/rt/io/stdio/struct.StdWriter.html
[18:37:23] <Leo`> impl Writer for StdWriter
[19:27:45] <kimundi> Leo`: One is a trait object, the other a struct
[19:28:03] <kimundi> Leo`: Trait objects don't automatically implement their traits
[19:28:36] <kimundi> Leo`: And types don'T automatically coerce to trait objects yet
[19:29:44] <kimundi> Leo`: "let x: &mut std::rt::io::stdio::StdWriter = ...; x as &mut std::rt::io::Writer" casts x to a trait object for example
[20:05:45] <Leo`> mhh okay
[20:05:49] <Leo`> it's a bit weird but ok
[20:07:25] <Leo`> thx kimundi i'll try this
[20:10:11] <eddyb> pcmattman: woo, I'm getting there: https://gist.github.com/eddyb/83aa138a80615148f2f0
[20:10:38] <eddyb> most of the things should work, and I'll implement retf and iret later
[20:10:47] <eddyb> and then I have to write codegen for the rust emulator
[20:30:59] <Leo`> my minimization algorithm works well
[20:31:11] <Leo`> it minimizes so well it removes useful states ...
[21:07:52] *** Quits: dbaupp (Thunderbir@moz-620B4FD1.lns20.syd6.internode.on.net) (Ping timeout)
[21:11:18] *** Joins: dbaupp (Thunderbir@moz-592B18A.lns20.syd6.internode.on.net)
[21:14:21] *** Quits: canhtak (canhtak@moz-830A7AA1.wl.t.ulaval.ca) (Quit: canhtak)
[21:15:12] <cmr> hah
[21:15:26] *** Joins: canhtak (canhtak@moz-830A7AA1.wl.t.ulaval.ca)
[21:29:59] *** Joins: pnkfelix (pnkfelix@moz-43495417.fbx.proxad.net)
[21:31:08] *** Joins: rusti (rusti@moz-54F7FD49.cpe.net.cable.rogers.com)
[21:31:10] *** Quits: rusti (rusti@moz-54F7FD49.cpe.net.cable.rogers.com) (Client exited)
[21:31:13] *** Joins: rusti (rusti@moz-54F7FD49.cpe.net.cable.rogers.com)
[21:45:12] *** Quits: acrichto (acrichto@moz-69F2E428.ugrad.cs.cmu.edu) (Ping timeout)
[21:48:28] *** Joins: acrichto (acrichto@moz-69F2E428.ugrad.cs.cmu.edu)
[22:41:33] *** Quits: canhtak (canhtak@moz-830A7AA1.wl.t.ulaval.ca) (Quit: canhtak)
[22:42:45] *** Joins: canhtak (canhtak@moz-830A7AA1.wl.t.ulaval.ca)
[22:43:11] *** Quits: canhtak (canhtak@moz-830A7AA1.wl.t.ulaval.ca) (Quit: canhtak)
[22:47:42] <eddyb> pcmattman: I found out how you can do the far jump with a non-compile-time-constant selector: push selector; push target; retf
[22:47:56] <eddyb> I also figured a neat trick... (x - 1) | 1 maps [0, 1] to [-1, 1] :P
[22:48:24] <pcmattman> that is a way to do it, yes
[22:49:03] <pcmattman> (it's how I did it for forge's return-from-Sx-power-state real mode -> protected mode stub)
[22:49:31] <eddyb> segmentation is fun... gaah all the default segments and the overrides.....
[22:49:52] <eddyb> I would be surprised if I can get anywhere with x86_16 support in one day
[22:51:09] <pcmattman> meh
[22:51:20] <pcmattman> wait until you start doing SSEn and AVX ;)
[22:51:33] <eddyb> I don't need that for VBE emulation :P
[22:51:56] * pcmattman goes about writing a VGA BIOS that uses SSE
[22:52:16] <eddyb> can you even touch it from real mode? sheesh
[22:52:43] * pcmattman writes a VGA BIOS that thunks into protected mode, breaking all the things
[22:53:16] <eddyb> I've heard (from an expert in such things) that modern GPU BIOSes implement some kind of VM (but should still run under an emulator)
[22:54:06] <eddyb> pcmattman: lol, writing FLAGS would have no effect in my emulator, it would UD or PF quick :P
[22:54:34] <eddyb> (or I can just kill it when it touches FLAGS in any way)
[22:54:53] <pcmattman> so are you trying to do up something like x86emu in rust?
[22:55:08] <eddyb> short answer: yes
[22:55:19] <pcmattman> cool
[22:55:49] <eddyb> long answer: adapting my "decompiler" project's disasm codegen to output Rust instead of JS, after I get decent output out of x86_16
[22:56:43] <eddyb> (see gist above for demo. the "decompiler" part is still hiding relevant statements and showing useless ones, nowhere near perfect)
[22:58:14] <eddyb> pcmattman: it's symbolic by design, so you can make your own special values (in JS you would just do "new Unknown(numBits)", here it may be trickier) and use them alongside real integers :P
[22:59:50] <eddyb> pcmattman: for example, you could have a special value for SS and your real-mode stack wouldn't have to be mapped below 1MB (or whatever that limit is)
[23:01:07] <eddyb> and you can intercept port IO and match it against a set of PortRanges, same with memory... to the point where the BIOS can't do shit to the kernel
[23:01:23] <eddyb> (unless it's cooperating with the hardware)
[23:01:58] <eddyb> but I'm just going off a tangent now :)
[23:12:09] <eddyb> hmm, I don't understand something... how can the operand size be 32bit in real mode? or is that just for virtual mode?
[23:43:27] <pcmattman> operand size prefix
[23:48:03] <eddyb> pcmattman: is that properly described in the intel manual?
[23:48:18] <pcmattman> I sincerely hope so
[23:48:44] <eddyb> I know how it works on 32bit, and x86.olly agrees with me, but that doesn't have 16bit disasm :(
[23:48:58] <pcmattman> modern real mode is only 16-bit addressing, you can use 32-bit registers, and write 32 bits at a time
[23:49:10] <pcmattman> movl %eax, %cs:(%edi) is fine for example, in real mode
[23:49:26] <eddyb> ahhh
[23:49:50] <eddyb> pcmattman: what about pointer registers?
[23:50:00] <pcmattman> (that should possibly be %cs:(%di) )
[23:50:04] <pcmattman> pointer registers?
[23:50:12] <eddyb> everything that ends with P :P
[23:50:31] <eddyb> EIP, especially
[23:51:21] <pcmattman> should still be usable, but only the lower bits have significance then
[23:52:00] <eddyb> so it doesn't matter which size is picked, that makes sense :D
[23:52:10] <pcmattman> %sp or %ip are just smaller windows to the native register, they're not entirely new registers
[23:53:22] <eddyb> (except for things like iret, which might be able to switch modes)
[23:53:58] <pcmattman> just remember that iret works differently in real mode
[23:54:06] <pcmattman> (pushes/pops 16 bits IIRC)
[23:54:21] <eddyb> I still don't have register aliasing/windowing :(. maybe I can use the 32bit registers even for real mode after I do that
[23:54:52] <eddyb> pcmattman: if it has 32bit operand size, it pops 32bits for CS and only uses the bottom half
[23:55:17] <pcmattman> yup, but it has to have the operand size. something to be wary of is all

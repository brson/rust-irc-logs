[00:00:01] <eternaleye> If TLS used CHAIN + packet-AD, and DTLS used packet-AEAD, they'd each do as well as possible in their domain.
[00:01:53] <Ilari> Also, what does the CHAIN offer over packet-AEAD?
[00:11:08] <Ilari> Also, thinking about it, DH-Cert, DH-PSK and PSK is already quite much when it comes to key exchange.
[00:14:27] <Ilari> Then there's session resumption (which is kinda like PSK).
[00:27:15] *** Quits: gleb (gleb@moz-3u1drv.rusanovka-net.kiev.ua) (Ping timeout: 121 seconds)
[00:28:20] <eternaleye> Ilari: Improved resilience against nonce misuse, though it should still be strongly avoided
[00:47:22] <Ilari> Doesn't TLS rederive keys for every connection, and the connection is stateful?
[00:54:18] <eternaleye> Ilari: It's worth noting that CHAIN is defined as an online AEAD, even though it may be _implemented_ as a mode over multiple invocations of an all-or-nothing AEAD.
[00:55:00] <eternaleye> Ilari: In a sense, what that means is that CHAIN takes the nonce misuse constraints of the TLS record protocol's state inside itself
[00:55:08] <eternaleye> Ilari: It takes its own nonce, _once_
[00:55:33] <eternaleye> Ilari: Which could also be on session resumption, I'll note
[00:55:51] <eternaleye> Ilari: This may also be useful for transports like SST, or SCTP
[00:56:10] <eternaleye> Ilari: Each stream would have a different nonce at the CHAIN level
[00:56:44] <eternaleye> Ilari: Which would be very nice as compared to TLS
[00:57:12] <eternaleye> Ilari: Especially if you use it in a streamlike mode for SCTP SOCK_STREAM, and SCTP SOCK_SEQPACKET is also natural to handle
[00:57:27] <eternaleye> Ilari: No need to do the deeply strange SCTP DTLS mapping... thing that exists
[00:58:22] <Ilari> TLS 1.3 is planned to do nonce derivation from RSN, which is rather difficult to repeat nonces with...
[00:58:34] <eternaleye> RSN?
[00:59:26] <Ilari> Record Sequence Number
[00:59:42] <eternaleye> Anyway, the idea is that it provides a better abstraction - CHAIN provides much the same guarantees as the record protocol _as a whole_, plus a bit.
[01:00:19] <eternaleye> And in the bargain, maps better to transports that are channelized, or otherwise more than just unstructured dgrams or a single stream
[01:01:26] <eternaleye> Unless you need complete packet-level out-of-order, CHAIN is pretty close to ideal
[01:01:44] <eternaleye> If you merely need independent channels, it simply requires a unique nonce on channel init
[01:02:08] <eternaleye> SOCK_SEQPACKET is trivial
[01:02:24] <eternaleye> SOCK_STREAM is just a SOCK_SEQPACKET that ignores the chain link boundaries
[01:03:49] <eternaleye> And it can be generically instantiated with any nonce-misuse-resistant AEAD
[01:04:53] <eternaleye> A good KEX plus CHAIN would go a long way - basically everything except truly raw UDP
[01:11:47] *** Joins: brson (brson@moz-e56.tdl.56.172.IP)
[01:13:47] <Ilari> Well, DTLS is pretty much truly raw UDP.
[01:39:48] *** Quits: erickt (erickt@moz-4hh.6p3.217.74.IP) (Ping timeout: 121 seconds)
[01:45:41] <eternaleye> Except it also gets used for SCTP, because TLS wasn't defined in a way that was useful for it.
[01:45:57] <eternaleye> And with CHAIN, it could be.
[01:46:07] <eternaleye> With better security guarantees than DTLS over SCTP.
[01:47:02] <eternaleye> Generally speaking, raw UDP is only particularly useful to build more sensible abstractions, such as channels.
[01:47:18] <eternaleye> Which are better served by something not DTLS.
[01:48:19] <eternaleye> see also: QUIC, SST, MinimaLT, etc.
[01:48:53] <eternaleye> Something that actually maps well to that kind of behavior would be rather nice, and CHAIN does that.
[01:50:00] <Ilari> Also looks like Michael S. is at it again... Seems to be pretty much alone in defending DSA. (IMO, he has reputation of all kinds of screwy crypto).
[01:50:25] <eternaleye> Agreed
[01:51:12] <eternaleye> For reference, when I mention SCTP and DTLS: https://tools.ietf.org/html/rfc6083
[01:51:16] <bascule> hahahaha
[01:51:24] <eternaleye> This is _crap_
[01:52:27] <eternaleye> It should have never existed, IMO
[01:52:33] <Ilari> I remember when he proposed adding HMAC to "fix" some downgrade attack, that couldn't work.
[01:52:45] <bascule> eternaleye: DTLS, SCTP or all of the above?
[01:53:13] <eternaleye> bascule: SCTP is less crap than DTLS, but the combination of the two is a real steaming pile
[01:53:31] <bascule> SCTP seems cool in theory
[01:53:35] <bascule> if it worked over the Internet
[01:53:41] <eternaleye> bascule: IMO, SCTP's main mistake was static channel count
[01:53:42] <bascule> and there were good implementations of it for every operating system
[01:53:50] <bascule> and they worked everywhere, ubiquitously, and were stable
[01:53:54] <eternaleye> bascule: If not for that, it could have dropped unordered delivery within a channel
[01:54:15] <eternaleye> bascule: And at that point, it would have MUCH friendlier semantics for crypto
[01:54:44] <eternaleye> bascule: Its other big mistake was that it was too late to be deployed, since the narrow waist had already corseted up
[01:55:38] <Ilari> Also, promoting making TLS "hardware-friendly". I think in some discusission I had someone say that "Hardware" is codeword for NSA or something (in discussing some paper from BSI I had absolutely nothing good to say about).
[01:55:59] <eternaleye> bascule: But a simple channelized protocol, with congestion-control, over UDP, using CHAIN per-channel, would be very nice indeed
[01:56:30] <Ilari> Also: Disable replay protection.
[02:01:00] <Ilari> Then there's this: draft-ietf-tsvwg-sctp-dtls-encaps
[02:02:02] <eternaleye> Ilari: Yup.
[02:03:00] <eternaleye> Ilari: Basically, the IETF has _nothing_ that can support channelized semantics without either a.) horrendous performance loss (the 3k-series RFC which did a TLS stream per SCTP stream), or b.) entirely avoidable loss of security (ugh, DTLS)
[02:05:52] <Ilari> { [cipher strengths], [handshake summary families], [kdf modes], [key agreement mechs], [auth mechs], [record mechs]}
[02:06:18] <Ilari> Wtf...
[02:14:19] <tiffany> eternaleye: how hard is it to avoid loss of security with channels?
[02:14:32] <Ilari> GOSTXX ... That's supposedly a key agreement. And WTF is CERT-RSA-ECDSA?
[02:15:44] <tiffany> I thought you could just use a CTR cipher with some bits of the nonce encoding the channel ID and others the sequence number
[02:18:23] <Ilari> eternaleye: How does DTLS lose security when used with chanelization?
[02:23:30] <eternaleye> Ilari: I don't mean that DTLS over channels is less secure than DTLS over unordered
[02:23:47] <eternaleye> Ilari: I mean that DTLS over channels is weaker than channels could support
[02:24:15] <eternaleye> Ilari: _specifically_ because it permits totally-unordered delivery
[02:24:38] <Ilari> Doesn't SCTP have some pretty odd channel modes?
[02:25:22] <eternaleye> Ilari: SOCK_SEQPACKET, SOCK_STREAM, and SOCK_DGRAM
[02:25:41] <eternaleye> Ilari: If it supported cheap dynamic channel creation, SOCK_DGRAM would be unneccessary
[02:25:59] <eternaleye> Ilari: And without SOCK_DGRAM, CHAIN offers real benefits over independent AEAD
[02:27:01] <eternaleye> Ilari: Because it only discloses the similarity of a prefix of segments in the case of channel-init-nonce reuse, rather than disclosing a map of reused segments in perpetuity (among other things)
[02:28:44] <eternaleye> Ilari: Vaguely akin to the distinction between CBC and PCBC
[02:29:38] <eternaleye> Ilari: That's why I say SCTP's big mistake was that the number of channels is fixed after connect()
[02:29:55] <eternaleye> Ilari: It imposed things further down the line that made it rather nasty
[02:30:43] <eternaleye> Ilari: Of course, them being fixed is unsurprising when you realize the intended use was for SS7, where the people involved were used to a fixed-at-setup number of channels over an optical transport...
[02:30:59] <Ilari> Oh, one of those annoying things one needs an extension to fix (I think there is SCTP extension that allows changing number of channels).
[02:31:24] <eternaleye> Ilari: Maybe, but how expensive is it (and what kind of synchronization is involved)?
[02:31:53] <eternaleye> Ilari: *cheap* dynamic channels are what make DGRAM unnecessary - it should be within a (small) constant factor of just sending a datagram.
[02:33:25] <Ilari> WebRTC (haha) uses SCTP for data channels.
[02:33:34] <eternaleye> Over UDP, IIRC
[02:34:16] <eternaleye> Ilari: The (somewhat old) SST paper is really worth a read on the topic
[02:34:23] <eternaleye> Ilari: It's on the Tng site
[02:35:13] <eternaleye> Ilari: PDF: http://bford.info/pub/net/sst.pdf HTML: http://bford.info/pub/net/sst/
[02:36:06] <eternaleye> Ilari: Of course, what I call "channels" it calls "streams"
[02:36:43] <eternaleye> Ilari: It uses "channels" to mean bounded-duration encrypted UDP connections, and the overall session can span multiple of them
[02:37:57] *** Quits: Tobba (Tobba@moz-o13d22.bredband.telia.com) (Ping timeout: 121 seconds)
[02:41:13] <Ilari> Okay, there is GOST key exchange. But it is pretty much just ECDH (albeit with some odd random constant).
[02:45:20] *** Joins: Tobba (Tobba@moz-o13d22.bredband.telia.com)
[02:49:29] *** Quits: Tobba (Tobba@moz-o13d22.bredband.telia.com) (Ping timeout: 121 seconds)
[03:29:43] *** Joins: Tobba (Tobba@moz-o13d22.bredband.telia.com)
[03:32:07] *** Joins: adu (ajr@moz-3ch.s21.191.65.IP)
[03:34:55] *** Joins: BigE (BigE@moz-4gk6rj.torservers.net)
[04:16:45] *** Quits: brson (brson@moz-e56.tdl.56.172.IP) (Ping timeout: 121 seconds)
[04:17:28] *** Quits: gsingh93 (gulshan@moz-3fu4am.mi.comcast.net) (Ping timeout: 121 seconds)
[04:20:43] *** Joins: brson (brson@moz-e56.tdl.56.172.IP)
[04:34:41] *** Quits: Tobba (Tobba@moz-o13d22.bredband.telia.com) (Ping timeout: 121 seconds)
[04:41:08] *** Joins: gsingh93 (gulshan@moz-3fu4am.mi.comcast.net)
[05:56:36] *** Quits: adu (ajr@moz-3ch.s21.191.65.IP) (Client exited)
[06:06:59] *** Quits: brson (brson@moz-e56.tdl.56.172.IP) (Quit: leaving)
[07:37:22] *** Joins: slarti (arthi@moz-55rvi2.dclient.hispeed.ch)
[07:55:08] *** Quits: gsingh93 (gulshan@moz-3fu4am.mi.comcast.net) (Ping timeout: 121 seconds)
[10:54:23] *** Joins: gleb (gleb@moz-3u1drv.rusanovka-net.kiev.ua)
[11:50:20] *** Quits: slarti (arthi@moz-55rvi2.dclient.hispeed.ch) (Quit: Verlassend)
[11:50:25] *** Joins: slarti (arthi@moz-55rvi2.dclient.hispeed.ch)
[11:53:26] *** Joins: Tobba (Tobba@moz-o13d22.bredband.telia.com)
[12:39:51] *** Quits: slarti (arthi@moz-55rvi2.dclient.hispeed.ch) (A TLS packet with unexpected length was received.)
[13:51:56] *** Quits: Church (hatter@moz-e031bf.dyn.optonline.net) (Ping timeout: 121 seconds)
[14:25:18] *** Quits: gleb (gleb@moz-3u1drv.rusanovka-net.kiev.ua) (Ping timeout: 121 seconds)
[15:45:16] *** Joins: gleb (gleb@moz-3u1drv.rusanovka-net.kiev.ua)
[16:12:59] *** Joins: kmc (keegan@moz-gjgn5n.compute.amazonaws.com)
[16:27:39] <bascule>  13_4__8__ 9_11__12_  13_4__ 8_9__11_    13_ 4_8_   11__12_ 13_ 4_ 
[16:27:42] <bascule> 4|  8_9__11|  12_ 13\4|_ 8_9|  11_ 12\  4/ 8\\ 9\ 11/ 12/ 13| 4| 8|
[16:27:45] <bascule> 8| 9|_  12| 13|_4) 8|| 9|11| 12| 13| 4|/ 8_ 9\11\ 12V 13/| 4| 8| 9|
[16:27:48] <bascule> 9|  11_12| 13|  4_ 8< 9| 11|12| 13|_4| 8/ 9__11_ 12\| 13| 4|8_|9_|11_|
[16:27:51] <bascule> 11|_12|   4|_8| 9\_11\_12__13|_4__8_/9_/   12\13_\4_| 8(9_|11_|12_)
[16:27:54] <bascule>                                         
[16:29:27] <eternaleye> Hm, I wonder how hard it'd be to convince kentonv to add a 'multiple timed force' for promises
[16:30:09] <bascule> what does that even mean?
[16:30:35] <eternaleye> i.e. "begin forcing this list of promises, but at $deadline return a 2-tuple of (completed, pending)"
[16:30:46] <eternaleye> If all complete early, return early
[16:31:09] <tiffany> so that means it's been a week since I started using source sans pro in firefox
[16:31:12] <eternaleye> I don't think that can be composed from existing primitives, in the presence of network
[16:32:15] <tiffany> in hexchat*
[16:32:26] <eternaleye> bascule: Nanomsg's 'survey' pattern is what brought the idea to mind, in combination with kentonv's statement a whiiiile back that rather than doing capnproto serialization over nanomsg, nanomsg over capnp rpc would make sense.
[16:35:28] <eternaleye> bascule: If capnp had separate "initiate forcing", "is ready to read", and "read  value" those could be used to initiate it
[16:35:37] <eternaleye> er, implement it
[16:50:22] <Ilari> "[...] skipping certificate verification, assuming hardcoded public keys, and various other measures that are destined to become entertaining Black Hat or Defcon presentations in the future)."
[16:56:07] <bascule> Ilari: lol what is that from?
[16:56:13] <bascule> is it talking about AFNetworking?
[16:56:32] <Ilari> Mail to TLS WG list, about tricks various "IoT" devices play with TLS
[16:56:59] <bascule> oh there it is
[16:56:59] <bascule> heh
[17:08:30] *** Joins: brson (brson@moz-k2tblc.tmodns.net)
[17:08:39] <Ilari> With stuff like that, is there much point in supporting PSK?
[17:37:44] *** Joins: gsingh93 (gulshan@moz-3fu4am.mi.comcast.net)
[17:49:27] <bascule> PSK :(
[17:51:37] <Ilari> Well, not supporting PSK would certainly make things simpler.
[18:05:13] <Ilari> (Then there are other things that could make things simper).
[18:06:44] *** Quits: gsingh93 (gulshan@moz-3fu4am.mi.comcast.net) (Ping timeout: 121 seconds)
[18:10:15] <bascule> I thought about running a CT log service here
[18:10:21] <bascule> but Google's has like zero documentation
[18:37:12] <Ilari> BTW, are all certificates issued by LE planned to be logged?
[18:40:17] <Ilari> I know a possible design for TLS-like key exchange, where there is reason for everything, and removing anything breaks it.
[18:42:54] <bascule> img:popcorn
[18:43:02] <bascule> Ilari: and I hope so re: LE+CT
[18:43:10] <bascule> I just want to log the certs we generate internally
[18:43:17] <bascule> I was just trying to compile CT
[18:43:25] <bascule> it seems somewhat hard to do on a mac, heh
[18:43:34] <bascule> I should just try to build it on our build system
[18:43:41] *** Joins: gsingh93 (gulshan@moz-3fu4am.mi.comcast.net)
[18:52:47] *** Quits: brson (brson@moz-k2tblc.tmodns.net) (Quit: leaving)
[18:55:08] <Ilari> IMO, CT is currently pretty much just a show.
[18:59:15] *** Joins: brson (brson@moz-k2tblc.tmodns.net)
[19:03:42] <Ilari> To be effective, every "public" certificate would have to be logged and clients would have to require stapled (somehow) proofs.
[19:20:21] *** Joins: brson_ (brson@moz-k2tblc.tmodns.net)
[19:22:40] *** Quits: brson (brson@moz-k2tblc.tmodns.net) (Ping timeout: 121 seconds)
[19:23:22] *** Quits: brson_ (brson@moz-k2tblc.tmodns.net) (Quit: leaving)
[19:44:20] <Tobba> keeping track of every certificate ever signed sounds like it could become impractical
[19:44:54] <mcpherrin> Tobba: well, only not expired ones
[19:47:18] <Ilari> How many entries do the Google CT logs have?
[19:47:53] <Tobba> I wouldn't be suprised if they're incomplete
[19:49:00] <Ilari> Well, they are incomplete, but I think there are loads of entries in there.
[19:50:10] <Tobba> you could require all certificates signed to form a hash chain
[19:53:07] <Tobba> browser wouldn't be able to verify it but an external server could
[19:56:37] <Ilari> Grr, I saw some some pretty neat CT log viewer some time back, but I can't find working one now. :-/
[20:26:41] *** Quits: gsingh93 (gulshan@moz-3fu4am.mi.comcast.net) (Ping timeout: 121 seconds)
[20:46:08] <Ilari> And with regard to size of log data, even few GB isn't practicularly large nowadays.
[20:50:18] <Ilari> Haha, someone pointing out that to recognize that no ECC ciphersuites have been proposed, you need to recognize all ECC ciphersuites (including the nonstandard ones).
[20:54:38] <Dcoder> great, feature(core) being now an error makes my entire code unusable
[20:55:21] <Ilari> I still follow nightlies.
[21:01:54] <Ilari> Also, A proposal of removing initial IVs from 1.3, so nonces always start at all zeroes.
[21:17:23] <Dcoder> grr
[21:17:29] <Dcoder> screw memory safety, back to c++
[22:14:46] <Tobba> fuck 1.0
[22:20:42] <Ilari> Or at least 6 weeks more of nightlies.
[22:21:15] <Ilari> Dcoder: volatile_set_memory? Or also some other stuff?
[22:34:23] <bascule> Dcoder: o_O
[22:34:37] <bascule> I haven't tried to compile any Rust code in a week
[22:34:43] <bascule> but I saw a lot of bluster about crazy breaking changes
[22:53:27] <Ilari> Also, in the last TLS meeting, someone expressed concern what would removing the initial IV do to strength of AES-128. The answer was to use AES-256. Of course, that assumes it is supported. Chrome doesn't support AES-256-GCM and is planning to remove AES-256 completely.
[22:56:57] <Ilari> Also, the proposals to make TLS "hardware-friendly" cause GCM mode to expose entiere cipher inputs... Hmm...
[23:01:32] <Ilari> And this is clearly something even worse.
[23:06:48] <Ilari> Also, where I had seen the way TLS was made "hardware friendly"? Oh yeah, SSLv3 _EXPORT_ ciphers.
[23:14:34] *** Quits: gleb (gleb@moz-3u1drv.rusanovka-net.kiev.ua) (Ping timeout: 121 seconds)
[23:16:57] <eternaleye> I'm rapidly approaching the conclusion that the reason competitions work SO MUCH better for crypto than committees isn't so much because of diverse submissions, or timeline, or anything like that; it's because once something breaks it's _out_, and there are a small, fixed number of opportunities to make alterations.
[23:17:16] <eternaleye> Rather than a breakage being responded to with a hasty fix that introduces more breakage ad nauseum
[23:17:57] <eternaleye> So analyses can actually build on each other, instead of having to start over after every single fucking change
[23:18:44] <eternaleye> The other major thing is that with a competition, it's obvious when someone tries to introduce a new requirement in the middle of the goddamn process.
[23:32:43] <kmc> Ilari: why is Chrome removing AES-256?
[23:37:10] <Tobba> wait what
[23:37:21] <Tobba> why would they do that
[23:41:38] <kmc> maybe because it's slower and questionably more secure, but clueless people will demand it because moar bits == moar secure
[23:41:41] <kmc> i dunno
[23:51:29] <eternaleye> kmc: Well, they don't support 256-GCM because NSS doesn't support the PRF construction for it IIRC, which is the same for 256-CCM I think.
[23:51:46] <eternaleye> kmc: So if they drop non-AEAD, then all 256-bit AES is gone regardless
[23:52:21] <eternaleye> kmc: And yeah, AES-256 is of arguable benefit in its own right.
[23:53:02] <kmc> ok
[23:53:15] <eternaleye> kmc: See also https://bugzilla.mozilla.org/show_bug.cgi?id=973755 which depends on https://bugzilla.mozilla.org/show_bug.cgi?id=923089
[23:53:53] <eternaleye> kmc: In the end, I suspect NSS is the biggest factor in the whole thing
[23:53:55] <kmc> 128 bits seems small w/ grover's algorithm... and PFS won't save you from retrospective decryption
[23:54:44] <eternaleye> kmc: I'd argue that by the time grover's of 128 is feasible, AES will be obsolete due to the 128-bit blocksize already
[23:54:52] <kmc> ah, true
[23:55:12] <eternaleye> kmc: Due to birthday-bound limits, among other things
[23:56:17] <kmc> I wonder if people will start to use Rijndael with larger block sizes at that point... AES-NI supports it
[23:56:21] <kmc> hopefully we have better ciphers by then
[23:56:52] <eternaleye> *cough*chacha*cough*
[23:59:23] <eternaleye> But anyway, I do strongly suspect that by the time we hit grover's of 64, there will have been a second AES competition

[00:02:30] <Zoxc> This is the first I've heard of the mask registers
[00:04:26] *** npm is now known as GBGamer
[00:27:09] *** Joins: dpc (dpc@moz-t6gr4b.ca.comcast.net)
[00:32:24] *** Joins: Peach (Fancy3D@moz-500.6lb.246.96.IP)
[00:32:46] <Peach> Hey, I just discovered the joys of dual booting :D
[00:33:44] <Peach> my OS hasn't been updated in 5 years and I finally have an alternate newer OS to use now!
[00:33:50] <Zoxc> Peach: Wait, I have to reboot so I can read your message
[00:36:52] <Peach> oh it's so neat, I used to watch by as all the fancy new features came out for the OS platform I'm on
[00:37:11] <Peach> none of those releases were stable / speedy enough for what I needed
[00:37:38] <Peach> but now I can have all the features AND keep my system exactly as before ^_^
[00:38:14] <Elaine> how about security fixes, letting alone fancy new features...
[00:43:29] *** Joins: npm (npm@moz-3tp.0t6.56.172.IP)
[00:43:37] *** Quits: GBGamer (npm@moz-821.0t6.56.172.IP) (Ping timeout: 121 seconds)
[00:44:26] <Peach> Well I don't need security fixes if I don't use the internet / install plugins / download new apps Elaine 
[00:44:40] <Elaine> fair enough.
[00:45:11] <Peach> IRC is pretty much all I use
[00:45:43] <Peach> and I just write my own software using my own code editor, so my usage is very atypical I suppose
[00:46:39] <Peach> I do wonder in practice how important security fix update are
[00:46:59] <Elaine> well, let's see:  سمووحخ ̷̴̐خ ̷̴̐خ ̷̴̐خ امارتيخ ̷̴̐خ
[00:47:14] <Elaine> shame
[00:47:27] <Peach> shame?
[00:47:32] <Zoxc> If you use a browser, very
[00:47:32] <Elaine> that's the unicode of death :P
[00:47:43] <Zoxc> It looks pretty
[00:47:52] <Zoxc> Retina displays ftw
[00:48:08] <Peach> For what systems would that crash Elaine ?
[00:48:23] <Elaine> Certain versions of OS X using an unpatched CoreFont.
[00:48:32] <Elaine> and iOS
[00:48:55] <Peach> I think I'm on an old version of OS X that had a good CoreFont :P
[00:49:01] <Tiffany> oh
[00:49:40] <Peach> What I don't like is that recent software trends update TOO MUCH - it's a problem because it introduces bugs more than ever
[00:49:52] <whipsch> once upon a time some distribution of xchat binaries were built with a version of pango that would crash with some higher mathematical symbol characters
[00:49:56] <Peach> before there was 5 or 4 YEARS between releases
[00:50:02] <whipsch> if you had persistent scrollback on, then it would crash upon startup
[00:50:18] <Tiffany> people weren't trying so hard to exploit software back then
[00:50:22] <Peach> ***releases that introduced major new features
[00:50:36] <Tiffany> browsers are a larger attack surface than they ever have been before
[00:51:19] <Peach> So now I'm on a 5+ year old OS, but I'm really not that venerable because my system doesn't contain the numerous NEW errors that are introduced by buggy tech teams of the modern day :P
[00:51:29] <Peach> *vunerable
[00:51:35] <Tiffany> that is a very shaky comparison
[00:52:13] <Tiffany> I wouldn't be surprised if there were several CVEs that affect all versions of OS X that have been patched in the past couple years
[00:52:16] <Elaine> Peach: but yet you have every bug that wasn't fixed since, because the team has moved on to different software.
[00:52:43] <Elaine> 10.6 hasn't received updates in over a year.
[00:52:55] <Tiffany> if you really want to be using ancient software that never updates, I suggest installing centOS
[00:53:08] <Tiffany> centOS doesn't even ship with a C++11 compiler
[00:53:20] <Peach> I'm on an older OS than that Elaine :P
[00:53:25] <Tiffany> the -std=c++0x and -std=c++11 options are completely unrecognized by the version of GCC shipped with it
[00:53:27] <Elaine> O_O
[00:53:36] <Peach> I still haven't updated to C++11 either
[00:53:45] <Tiffany> that is horrible
[00:53:49] <scott> heh I'm using C++14 in some projects.
[00:54:00] <Tiffany> C++ was awful before 11
[00:54:00] <Elaine> your irc client claimed to be 10.6.5 at least, when I checked.
[00:54:10] <Tiffany> same elaine
[00:54:21] <Tiffany> I'm using C++14 and also std::experimental::optional, sott
[00:54:23] <Tiffany> scott*
[00:54:43] <Peach> OS version string hacks are fun :>
[00:54:58] <Elaine> sure
[00:55:17] <Peach> C++11 is a mess
[00:55:43] <Peach> Design wise
[00:55:53] <Peach> C++ has 0 aesthetic beauty in its design
[00:56:19] <scott> C++11 is a lot nicer to use than pre-11 (even though it's still not that nice, it's much better).
[00:57:37] <Peach> I wonder how many C++ user go the lightweight route - I use C++ like a more organized C99
[00:58:01] <Peach> I don't use inheritance, or the standard library, or smart pointers
[00:58:27] <Peach> I just use constructors and destructors and very simple dynamic size List classes; and strings
[00:58:46] <scott> I think a lot of people use a small subset of C++.
[00:58:58] <Peach> I bet I use a smaller subset than most
[00:59:01] <scott> Maybe less than should...
[00:59:11] <Peach> I don't even use namespaces
[00:59:20] <scott> People who try to use all of C++ are scary
[00:59:30] <scott> As well as people who try to write Java in C++.
[01:00:04] <scott> I like namespaces. Especially compared to C-style prefixing.
[01:01:15] <Tiffany> I use all of C++
[01:01:25] <Tiffany> when appropriate
[01:01:45] <scott> Even exceptions? Pointers to member? Function pointer template parameters?
[01:01:45] <Tiffany> randomly using C pointers just to say you're using all of C++ is not a good idea
[01:01:58] <Tiffany> yes, yes, haven't had a good reason to use that
[01:02:14] <wrl> *especially* function pointer template parameters
[01:02:14] <Tiffany> but I can see why it exists
[01:02:19] <Tiffany> I have used const char pointer template parameters
[01:04:31] <Tiffany> I am one of those people who write SQL expression templates in order to catch SQL errors at compile time
[01:04:34] <Tiffany> which is a thing I have done
[01:04:43] <Peach> exceptions, virtual destructors,virtual method table
[01:04:56] <Zoxc> Pointers to member (in templates) are awesome for linked lists =P
[01:05:05] <Tiffany> virtual destructors are useful for passing around owned interfaces
[01:05:09] <Peach> C++ is not shaping up to be a cleanly statically analyzable language with all those features
[01:05:20] <Elaine> "shaping up"?
[01:05:25] <Elaine> 1987 is calling
[01:05:32] <Tiffany> uh
[01:05:32] <Elaine> Zoxc: and for generic serialization libraries as well
[01:05:43] <Peach> Lol wut I don't get that last comment Elaine 
[01:05:44] <Tiffany> these features make it so you can catch more things at compile time, by wrapping things in templates
[01:05:54] <Tiffany> which reduce the need for static analysis in the first place, although don't eliminate it
[01:06:06] <Peach> But by shaping up, I mean C++ isn't a lean and straightforward design
[01:06:11] <Elaine> no, it never was.
[01:06:19] <Elaine> what language is, really?
[01:06:33] <Tiffany> you know what's a lean and straightforward design
[01:06:34] <Tiffany> FORTH
[01:06:44] <Tiffany> FORTH LOVE? IF HONK THEN
[01:06:58] <npm> HONK
[01:07:08] <Peach> Elaine that's my mission - to make a programming language with a lean straightforward design
[01:07:17] <Elaine> straightforward to who, from what principles?
[01:07:22] <Elaine> lean compared to what featureset?
[01:07:22] <npm> I prefer RPL tho
[01:07:34] <Tiffany> brainfuck is a very lean language
[01:07:41] <Tiffany> you can write a complete implementation in 40 lines of C!
[01:07:42] <Peach> Ok, I define "lean" as C featureset
[01:08:05] <Elaine> Even C89 has weird bloat.
[01:08:05] <Peach> I do mean a language that is readable and end user friendly
[01:08:15] <Tiffany> I kind of want to write a language in a similar boat as C
[01:08:16] <Peach> Yes C99 minus a lot of cruft
[01:08:18] <npm> Elaine: like function pointers
[01:08:27] <Tiffany> sort of like a concatenative syntax over llvm IR, but with linear typing
[01:08:30] <Peach> Cause C has some baggage
[01:08:36] <npm> and arrays
[01:09:03] <Tiffany> my favourite C weirdness is how [] was originally the pointer syntax
[01:09:25] <Tiffany> and it still exists in the language
[01:09:33] <Peach> Basically - C99 minus the baggage - add a sprinkle of python style and fast built in string/hashmap - and have the zero cost abstractions of C++
[01:09:46] <Peach> I want to make a language that is easily masterable by a young person
[01:09:50] <Tiffany> the zero cost abstractions that you previously admitted to not using?
[01:09:55] <Peach> or someone new to computers
[01:10:11] <Tiffany> C is not a language easily masterable by someone new to computers
[01:10:12] <Peach> Tiffany: I am using zero cost abstractions
[01:10:34] <Peach> Yes, I want to make a language simpler than C but with most of C's feature set
[01:10:36] <npm> Tiffany: yay for UB :D
[01:10:46] <Tiffany> npm: [] isn't UB though
[01:11:00] <Tiffany> oh, wait
[01:11:03] <Tiffany> you're replying to the other thing
[01:11:11] <npm> yup
[01:12:04] <Peach> "simpler than C" would mean no undefined behavior, intuitive pointer syntax, and a build system much cleaner than the C preprocessor macro/header system - but all with zero cost abstractions
[01:12:12] <Tiffany> if you want to make a language that can be understood by someone new to computers, you can't rely on idiosyncrasies or force someone to learn pointers before they can even write basic code
[01:12:29] <Tiffany> and if you do, by the time they can use the language, they will be by definition no longer new to computers
[01:13:10] <Peach> Tiffany: essentially the language has high level zero cost abstractions built in by default, so you don't even have to know about pointers or even memory addresses to program decently
[01:13:14] <Peach> that's the goal
[01:13:24] <Tiffany> abstractions always leak though
[01:13:33] <Tiffany> how are you going to manage memory automatically without GC or smart pointers?
[01:13:33] <Peach> Not always
[01:13:48] <Peach> I have ARC and scoped destructors Tiffany 
[01:14:18] <Tiffany> so you want ARC'd go with generics?
[01:16:27] *** Quits: npm (npm@moz-3tp.0t6.56.172.IP) (Ping timeout: 121 seconds)
[01:16:36] <Peach> AH! Almost Tiffany, but more different
[01:17:01] *** Joins: npm (npm@moz-3tp.0t6.56.172.IP)
[01:18:26] <Peach> Go has a different domain than what I'm going for - I'm making a language for high performance 3D graphics centered things - so game engines, physics engines, path tracers; high level high performance applications for creative professionals
[01:18:58] <Tiffany> you want high performance code using ARC?
[01:19:18] <Tiffany> or oh, that will just be a smart pointer
[01:20:11] *** Quits: brson (brson@moz-f0v.335.39.84.IP) (Ping timeout: 121 seconds)
[01:22:20] *** Joins: brson (brson@moz-cfhap5.mtv2.mozilla.com)
[01:22:21] *** ChanServ sets mode: +o brson
[01:25:18] *** Joins: panicbit2 (panicbit@moz-d1o.7qb.188.87.IP)
[01:25:51] *** Quits: panicbit (panicbit@moz-25i.h2h.188.87.IP) (Ping timeout: 121 seconds)
[01:25:59] <scott> I sometimes get the urge to write a C replacement with a very strict requirement to not extend beyond what C can already do. Just to see how clean I could make it.
[01:26:39] <scott> A language like that will never catch on, but I wonder how hard it is to make it clean.
[01:28:31] <Peach> scott: if you ever do that, or even come up with *ideas* please forward them to me :P
[01:28:48] <Peach> Cause I already started
[01:30:08] <scott> Don't use C type syntax... :p
[01:31:28] <Peach> Guide me
[01:31:36] <Peach> show me the better syntax type route
[01:32:21] <scott> Keep the name and type separated, like Rust or almost any other language.
[01:32:49] <Peach> actually, C's type syntax appears to require the least amount of typing, so I don't know if it's worth it to make type declarations require more typing
[01:32:52] <Peach> int x;
[01:33:01] <Peach> I mean, it can't get simpler than   int x
[01:33:11] <Peach> tell me why an alterative would be better
[01:33:17] <Peach> var x:int  
[01:33:29] <scott> I'm talking about arrays, function pointers, etc.
[01:33:32] <Peach> AH
[01:33:35] <scott> C type syntax is an utter mess.
[01:33:45] <Peach> Ok scott, I have this syntax :
[01:33:55] <scott> It's really easy to do better than C.
[01:33:59] <npm> Peach: also, read https://en.m.wikipedia.org/wiki/The_lexer_hack
[01:34:12] <npm> and learn from your predecessors' mistakes
[01:34:16] <damian> Does anyone have a working demo with metal-io (mio)? I'm trying to wrap my head around it, but I'm new to the whole event-based thing
[01:34:44] <scott> Yeah, read that. Having a keyword like 'var' or 'let' before makes the lexing/parsing a lot simpler.
[01:34:56] <scott> Rust makes a number of choices to make its parsing way cleaner compared to C/C++.
[01:35:03] <scott> e.g. foo::<T>
[01:35:33] <Peach> Ok, so for pointers,
[01:36:10] <Peach> ref[int] x      C:  int* x  
[01:36:14] <Peach> I'm thinking of this syntax for a few reasons:
[01:36:29] <Peach> 1) pointers are the same size regardless of the type they represent
[01:37:08] <Peach> - therefore the focus is that the type is a "pointer" and the fact that it's treated as int gets secondary visual priority
[01:37:39] <Peach> 2) nesting is more obvious:    int** x;    vs   ref[ref[int]] x
[01:38:08] <XMPPwocky> you would not BELIEVE what i've been through today.
[01:38:23] <Peach> (ref stands for reference, which I think is shorter and less cryptic than pointer[int] or  ptr[int])
[01:38:32] <XMPPwocky> so apparently, trying to rebuild the bcd on windows from a recovery USB disk will actually overwrite the one on the recovery disk
[01:38:50] <XMPPwocky> which leaves you with no working OS on the hard drive, and no working recovery disk; and no way to make an new one
[01:39:07] <scott> The bcd?
[01:39:18] <XMPPwocky> boot configuration data or something
[01:39:22] <scott> Ah
[01:39:28] <XMPPwocky> so i got out my ancient olpc xo-1, couldn't find the charger, but i did have the handcrank charger
[01:39:46] <XMPPwocky> and from there, i managed to download an ubuntu image while cranking furiously
[01:39:51] <scott> Hahahha
[01:39:52] <XMPPwocky> so
[01:40:01] <XMPPwocky> i'm really tired, my arm is sore, and i lost all my windows files
[01:40:10] <XMPPwocky> but at least my laptop works
[01:40:20] <Peach> Function pointer syntax:   this language has   the "function" keyword begin the type of a function
[01:40:34] <Peach> C   void (*example)(void);      vs.    function() -> void
[01:40:47] <scott> XMPPwocky: So Microsoft's idea of a recovery disk is a disk which bricks itself.
[01:40:59] <XMPPwocky> scott: yep, it's great
[01:41:05] <npm> scott: Microsoft is pretty fucky
[01:41:23] <scott> I've never heard of using a handcrank charger for a laptop. That sounds like fun.
[01:41:36] <whipsch> thats hilarious
[01:41:40] <XMPPwocky> now maybe it's not supposed to be writeable, because you can only actually make a real recovery disk *from an existing windows install*
[01:41:43] <Peach> (I don't know if anyone here is available to comment on my hypothetical better-C syntax ideas)
[01:41:47] <Peach> :P
[01:41:52] <XMPPwocky> i had a working linux partition, until microsoft's recovery managed to kill that too
[01:41:53] <npm> I'm here
[01:42:11] <XMPPwocky> so from there, i did horrible things with dd to sorta-kinda get microsoft's free windows 8 trial onto a usb drive
[01:42:13] <npm> I don't like the pointer syntax, but function pointer syntax is cool
[01:42:30] <Peach> Do you have a better pointer syntax idea npm?
[01:42:54] <scott> I would keep pointer syntax terse in a C-like.
[01:43:00] <npm> personally, I really like Rust's syntax, honestly
[01:43:04] <npm> &int
[01:43:26] <npm> out of all the things I've seen, Rust's is the best
[01:43:49] <npm> because &x where x: int is an &int
[01:43:56] <scott> My hesitation with trying any new systems language now is how much I would just be copying Rust.
[01:44:01] <npm> so creation == type syntax
[01:44:08] <XMPPwocky> scott: Rust has a destructor, you'd have to move or clone it
[01:44:09] <scott> Even just implementing a toy language.
[01:44:55] <XMPPwocky> now, if i /wanted/ to use windows again, which i'm not entirely sure about (but gaming)
[01:44:59] <npm> scott: I think Rust is a pretty great base
[01:45:04] <amstrad> scott: XMPPwocky this is the problem with dynamic dispatch http://is.gd/XNlYQA
[01:45:05] <Peach> Well to be clear for the intended use case - It's a language where direct pointer manipulation is rare cause there's higher level defaults built in
[01:45:17] <XMPPwocky> i'd need to go and, apparently, download a cracked version of it
[01:45:18] <Peach> and specifically, I want to make this language easily teachable as a first language
[01:45:20] <scott> My C-like would probably look a lot like Rust minus features.
[01:45:24] <npm> Peach: ah then that's probably cool
[01:45:30] <XMPPwocky> sorry, i'd need a cracked version of windows 7
[01:45:33] <amstrad> scott: in this scenario, i need to share a pointer across threads
[01:45:35] <npm> I was thinking a C-like
[01:45:40] <XMPPwocky> because microsoft's program to download the win8 ISOs?
[01:45:42] <XMPPwocky> it only runs
[01:45:43] <XMPPwocky> on windows 7
[01:46:18] <npm> scott: My C-like would be C with better var/pointer syntax, better arrays, better function pointers
[01:46:59] <npm> and tuples
[01:47:33] <XMPPwocky> my C-like would be C with nicer syntax, and also mandating that implementors for a given platform define behavior for almost everything
[01:47:44] <XMPPwocky> even at the cost of missing optimizations
[01:47:57] <scott> amstrad: If you want to move them, you'll need to box them.
[01:48:21] <npm> oh and namespacing
[01:48:24] <XMPPwocky> i use C when I want a nicer asm; being able to do things like violate TBAA and get away with it, or assume int overflow wraps...
[01:48:25] <amstrad> scott: id rather static dispatch them
[01:49:00] <scott> amstrad: Yeah, but that may not be possible.
[01:49:05] <amstrad> scott: here is the solution i have http://is.gd/SJ0LLh
[01:49:17] <scott> amstrad: And besides, if the closures actually have no captures, the boxing might be free.
[01:49:56] <scott> amstrad: That's the best solution I can think of at the moment.
[01:51:13] <amstrad> scott: seems to work http://is.gd/cDYmVw
[01:51:33] *** Quits: npm (npm@moz-3tp.0t6.56.172.IP) (Connection closed)
[01:52:00] <scott> amstrad: I just had another thought... if you're really not using captures, you might be able to use function pointers instead of closures.
[01:52:01] *** Joins: npm (npm@moz-3tp.0t6.56.172.IP)
[01:52:10] <scott> amstrad: I'll edit the playpen to show you what I mean.
[01:52:24] <Peach> The language I'm making has a new idea - you know how Python requires strict indentation rules for the compiler? In my language, the syntax is looser like C with braces BUT it's a compile error if indentation is ambigous
[01:52:29] <amstrad> scott: i do kinda like closures, they let the caller be a bit loose about their implementation
[01:52:37] <Peach> or if you try things like an ambigous dangling else
[01:52:52] <Peach> can anyone verify if this is a good idea?
[01:53:27] <scott> amstrad: http://is.gd/wrOUhV
[01:53:59] <scott> amstrad: The outer is still a closure, so the caller is still unrestricted, but the inner functions are just plain functions since they don't need captures.
[01:54:03] <amstrad> scott: oh, yeah, that is pretty nice :D
[01:54:41] *** Quits: npm (npm@moz-3tp.0t6.56.172.IP) (Connection closed)
[01:54:47] <scott> It just won't work if the inner functions ever need to capture anything. But otherwise it's great.
[01:54:54] *** Joins: npm (npm@moz-3tp.0t6.56.172.IP)
[01:54:56] <Peach> An example of strict indententation rules (but far more relaxed than python):
[01:55:02] <Peach> if (x)
[01:55:07] <amstrad> scott: would this stuff be a example of "advanced rust" programming?
[01:55:10] <Peach>      a();
[01:55:13] <Peach>      b(); // Style Error - b() is not part of a single line if statement, unindent b(); to reflect this
[01:55:26] <amstrad> scott: or, is this intermediate stuff?
[01:56:07] <scott> amstrad: Closures and function pointers are pretty advanced, but you can go deeper (e.g. even crazier type system stuff or unsafe low-level stuff).
[01:56:13] <Peach> (the language uses C style {} braces, but does not allow use of misleading indentation)
[01:56:38] <amstrad> scott: ive been at rust on and off for over 10 months, id like to think ive learnt something about the language
[01:56:45] <scott> Peach: That would be great to have as a warning at the least.
[01:56:59] * amstrad needs some positive reinforcement
[01:57:03] <scott> I would just enforce the braces on if statements like Rust.
[01:57:40] <amstrad> scott: in your example, you were clever enough to remove all that Sync, Send and 'static stuff by just using a fn
[01:57:47] <amstrad> genious
[01:58:25] <scott> amstrad: Closures are a fine mess of traits, generic types, trait objects, auto-generated types, and types you can't write, so grasping all those aspects of closures definitely takes some effort.
[01:58:54] <amstrad> scott: this is all a lead up to being able to do async IO in Rust
[01:59:13] <amstrad> when i started, i thought i could just jump straight into it, how wrong i was
[01:59:15] *** Quits: npm (npm@moz-3tp.0t6.56.172.IP) (Connection closed)
[01:59:17] <scott> Plus moving and non-moving captures... closures really have a lot of details.
[02:01:16] *** Joins: npm (npm@moz-3tp.0t6.56.172.IP)
[02:01:47] <Peach> Wow
[02:01:54] <Peach> I just learned something about C
[02:02:08] <Peach> You can use $ in function names and variable names
[02:02:34] <npm> Peach: no way
[02:02:36] <npm> really
[02:02:37] <scott> I think that's a GNU extension.
[02:02:42] <Peach> npm try it
[02:03:05] <scott> https://gcc.gnu.org/onlinedocs/gcc/Dollar-Signs.html
[02:03:16] <Elaine> it's non-standard, see http://www.open-std.org/jtc1/sc22/wg14/www/docs/n1124.pdf
[02:03:25] <Peach> You guys are too smart
[02:03:28] <npm> I will when I get home
[02:03:33] <Peach> I know it's nonstandard
[02:03:45] <Peach> but let us just pretend it's a magic feature :3
[02:03:47] <Elaine> (page 51)
[02:03:53] <Elaine> Why lie to ourselves?
[02:04:01] <scott> GNU C has a bunch of magic nonstatndard features.
[02:04:07] <Elaine> Like block functions!
[02:04:15] <Elaine> Nested function declaratoin!
[02:04:16] <scott> What are those?
[02:04:33] <scott> Oh like the C closures?
[02:04:34] <Peach> No it's not a lie, it's just fun to know most compilers support it
[02:04:41] <Peach> even though it's non standard
[02:04:50] <scott> There's also block expressions which are like Rust's regular blocks.
[02:05:13] <Peach> C also has a destructor extension, which is pretty funny
[02:05:15] <scott> int a = ({ int x = 2; x + 2; }); // sets a to 4 in GNU C
[02:05:52] <Peach> Oh hey, does anyone know if there's an efficient way to generate C code the implements defer and destructors automatically within any function
[02:06:05] <Peach> I'm exporting C code from a language that supports destructors and defer
[02:06:07] <Elaine> That's a little different since they're not scope-based.
[02:06:57] <Peach> It's easy if it's a defer/destructor in a void function
[02:07:01] <Elaine> Use goto's to represent the various exit edges in your control flow graph?
[02:07:09] <Peach> but if it's in a function that returns a value,
[02:07:12] <Elaine> exit blocks I mean
[02:07:38] <Peach> I suppose I can't really get around copying the return value and THEN inserting the destruct code before the return
[02:08:12] <Elaine> no, you can't.
[02:08:54] <Peach> Say I have:  function int example() { vector<int> somelargedata;   return 0;  }
[02:09:26] <Peach> I would have to make a tempory var at each return point and insert the destructor before the return
[02:11:18] <Peach> Complex question - where to call destructor in    function vector<int> bigvalue() {  vector<int> somelargedata;  return somelargedata;    }
[02:11:44] <Peach> I think it's possible to figure it out at compile time?
[02:11:54] <Elaine> You want to track liveness to know what needs destruction.
[02:12:01] <amstrad> scott: http://is.gd/xII7P7 
[02:12:06] <amstrad> scott: well, thanks for your help today
[02:12:12] <Elaine> look into dataflow analysi
[02:12:14] <Elaine> s
[02:12:18] <amstrad> think i might have learnt a couple new things
[02:12:55] <scott> amstrad: No problem. I figured out a couple things myself along the way.
[02:13:19] <amstrad> scott: still playing around, but this is all important stuff to know i think
[02:13:51] <amstrad> scott: there are still so many things i have yet to grok, 
[02:13:53] <Peach> To implement a language with C++ style destructors, I hope I don't need special features beyond what standard C99 does
[02:14:02] <Elaine> no, you don't.
[02:14:14] <Elaine> but you need to do some amount of analysis if you want static destructor semantics.
[02:14:42] <Peach> Of course, yes the compiler system I'm making is analysis heavy
[02:14:57] *** Quits: npm (npm@moz-3tp.0t6.56.172.IP) (Ping timeout: 121 seconds)
[02:15:01] <Peach> so it's just a matter of being creative and clever
[02:15:09] <Elaine> Track live values and emit destructors for non-live destructors on scope exit
[02:15:39] <Peach> ^
[02:15:44] * Peach writes down
[02:16:04] <Elaine> It's a standard technique :P https://en.wikipedia.org/wiki/Data-flow_analysis
[02:19:15] <Peach> Thanks Elaine, so in addition to that - this http://stackoverflow.com/questions/6376957/implementing-destructors-in-generated-c-code is the closest thing I found on the web, but it's of no direct help; it appears to just be a relatively simple thing that you reason through and program the compiler to handle
[02:19:27] <Peach> (hopefully it's simple)
[02:19:44] <Peach> My language uses no setjmp or exceptions or gotos
[02:19:55] <Peach> so that should make destruction reasoning much simpler
[02:20:24] <Elaine> exceptions and gotos don't really complicate much
[02:20:31] <Elaine> just more edges in the control flow graph
[02:25:28] <Peach> Elaine: do you know about C++ return value optimization?
[02:25:51] <Elaine> yes
[02:26:10] *** Quits: brson (brson@moz-cfhap5.mtv2.mozilla.com) (Quit: leaving)
[02:26:18] <Peach> woah
[02:26:36] <Peach> do you know if C can do it too?
[02:26:39] <Peach> Or only C++
[02:27:00] <Elaine> It's not magic, add an out pointer to the functions you generate and write the return value into that
[02:27:10] <Elaine> (make sure to make it restrict)
[02:28:06] <Elaine> It's only a big deal in C++ because of copy/move constructors
[02:30:58] <Peach> My language is gonna have return value optimization BUT it will respect side effects in the constructor
[02:31:04] <Peach> (is that a bad idea?)
[02:31:22] <Elaine> do you have copy/move constructors?
[02:31:44] <Elaine> if not, then copy elision can't modify observable behavior, and it's just an optimization
[02:35:56] <Peach> I have copy constructors
[02:36:14] <Elaine> yuck
[02:38:01] <XMPPwocky> implicit ones?
[02:38:48] <Peach> no they are direcly named   copy()
[02:39:05] <Elaine> then it's not a copy constructor?
[02:39:22] <Elaine> at least not in the C++ sense, which is the only sense
[02:40:06] <Peach> they are special function in a class that can get invoked on construct/assign
[02:40:16] <Peach> should I take out copy constructors?
[02:40:25] <Elaine> Are they ever a good idea?
[02:40:37] <Peach> that's my honest question
[02:40:51] <Peach> "are they even a good idea"
[02:42:19] <Peach> wait, if I implement templated arrays and smart pointers, would anyone even need a copy constructor?
[02:43:00] <XMPPwocky> move constructors are occasionally a good idea if you need to fix up interior pointers, or do GC stuff...
[02:43:04] <Peach> wait Elaine - is the "ew" at the idea of copy constructors or the idea of them?
[02:43:07] <XMPPwocky> copy constructors are just pretty ew
[02:43:24] <Peach> **the syntax or the idea
[02:43:26] <Elaine> The idea.
[02:43:42] <Peach> what should I do instead?
[02:43:50] <Elaine> Just... not have them?
[02:43:58] <Elaine> What Rust does is pretty sane.
[02:46:26] *** Joins: GBGamer (npm@moz-6mcsgc.tmodns.net)
[02:46:39] <GBGamer> my phone bled out :(
[02:47:11] *** Joins: npm (npm@moz-pi07bg.hfc.comcastbusiness.net)
[02:47:27] <npm> grargh
[02:47:37] *** Quits: GBGamer (npm@moz-6mcsgc.tmodns.net) (NickServ (RECOVER command used by npm))
[02:47:37] *** npm is now known as GBGamer
[02:48:53] *** Joins: Quxxy (chatzilla@moz-efh10q.internode.on.net)
[02:49:06] <scott> I'm wondering what to name the AST node in my shell that groups the things that make up a single argument. e.g. foo"bar$baz"quux is [Text(foo), Text(bar), Var(baz), Text(quux)]
[02:49:13] <scott> "ArgumentClump"
[02:50:17] <GBGamer> Node?
[02:50:17] <Peach> scott: FunctionParam ?
[02:50:37] <GBGamer> Parameter?
[02:50:51] <Peach> FunctionArg?
[02:51:04] <GBGamer> I like Argument
[02:51:19] *** Quits: kimundi (kimundi@moz-k57ctm.dip0.t-ipconnect.de) (Ping timeout: 121 seconds)
[02:51:23] <Peach> No you don't GBGamer 
[02:51:30] <GBGamer> yes I do
[02:51:34] <scott> I guess that's a good way to keep it simple.
[02:52:01] *** Joins: kimundi (kimundi@moz-kjthpr.63qo.amhv.57bc.2002.IP)
[02:52:02] <Peach> Wow I guess you do like Argument GBGamer 
[02:52:08] <GBGamer> no I don't
[02:52:08] <Peach> (get the joke? :P)
[02:52:14] <Peach> lolololol
[02:53:09] <Peach> Ok so
[02:53:23] <Peach> CALLING ALL CS PEOPLE
[02:53:29] <Peach> What's the point of a move constructor
[02:53:44] <Peach> and can I make a compiler that's smart enough that you don't need move constructors
[02:53:53] <Elaine> not in general no
[02:54:02] <GBGamer> Peach: rustc?
[02:54:03] <Elaine> it's for doing things when the location of an object in memory changes
[02:54:08] <XMPPwocky> so a move constructor in C++ will seem like a terrible hack if you're coming from Rust
[02:54:54] <GBGamer> why would the location of an object in memory affect an object?
[02:55:10] <XMPPwocky> you need move constructors for simple things like
[02:55:30] <XMPPwocky> assigning a Vec (std::vector) to another one, invalidating the first Vec along the way
[02:56:02] <Elaine> GBGamer: becauser pointers exist?
[02:56:21] <XMPPwocky> but, you don't need that if you design your language not to
[02:56:24] <Elaine> also stuff like that.
[02:56:59] <GBGamer> Elaine: so like... internal references?
[02:56:59] <XMPPwocky> Rust, for example- you assign, the destructor runs on the old value, and you just copy the raw bytes of the new value into the old
[02:57:22] <XMPPwocky> and there's the drop flag to make sure that the destructor on the value you just moved out of doesn't run
[02:59:18] <scott> Oh I actually want a name for an enum of the possible argument parts (i.e. Text, Var, etc)...
[02:59:31] <scott> And the best I can think of is a variation on ArgumentPart/ArgumentComponent
[02:59:44] <Elaine> scott: what about stuff like $(foo)
[02:59:51] <Elaine> is expression inaccurate?
[03:00:39] * scott ponders
[03:00:49] <Peach> In C, is it possible to get the address of a temporary? I'm trying to think how to handle move semantics in generated C code
[03:01:02] <Elaine> Peach: no.
[03:01:06] <scott> Expression might actually work well for the naming scheme.
[03:01:31] <XMPPwocky> scott: is Type not appropriate?
[03:01:37] <scott> e.g. TextExpr for the bare text / quoted stuff, VarExpr, SomethingExpr for command substitution
[03:01:48] *** Quits: niconii (nicole@moz-5iorc7.frgo.qwest.net) (Quit: leaving)
[03:01:55] <XMPPwocky> i just realized on this ubuntu install i swapped the hostname and my username
[03:01:59] <XMPPwocky> well, shit.
[03:02:16] <GBGamer> Elaine: oh, I guess I didn't understand C++ move
[03:02:16] <scott> XMPPwocky: Well, it's the actual data and not just the discriminant.
[03:02:23] <GBGamer> I thought it was like Rust move
[03:02:25] <XMPPwocky> scott: ah
[03:02:28] <Elaine> no, it's not.
[03:02:51] <GBGamer> yeah, I'm obviously not a C++ person
[03:03:01] <Elaine> I really find myself appreciating TNG much less than TOS so far.
[03:03:52] <GBGamer> oh man, seriously? TNG is so much better than TOS, imho
[03:04:03] <GBGamer> although the first season really isn't good
[03:04:40] <GBGamer> I love Data
[03:06:57] <Zoxc> GBGamer: When the first season is not good, all I can think of is Stockholm syndrome
[03:07:13] <GBGamer> Zoxc, hmm?
[03:11:16] <Peach> Anyone know how temporaries work at low level?
[03:11:45] <GBGamer> Peach: a stack
[03:11:50] <GBGamer> or a register
[03:12:07] <Elaine> Peach: sounds like you should pick up a book on compilers :P
[03:12:13] <Peach> Is it extra overhead when I say     var *x = a+b; functioncall(x);  vs    functioncall(a+b);
[03:12:17] <GBGamer> s/a stack/the stack/
[03:12:24] <GBGamer> Peach: nope
[03:12:38] <GBGamer> you should learn assembly
[03:12:39] <Elaine> GBGamer: that's not strictly true...
[03:12:46] <Elaine> depends on how the compiler lowers those constructs.
[03:12:53] <Elaine> also that shouldn't be a pointer?
[03:13:14] <GBGamer> well... I guess technically?
[03:13:42] <GBGamer> there is no way any good compiler doesn't create the same code
[03:14:34] <XMPPwocky> GBGamer: then rustc is a bad compiler
[03:14:41] <XMPPwocky> because of the rules around how temporaries get dropped
[03:14:47] <XMPPwocky> vs. variable scopes
[03:14:49] <Elaine> it depends on the additional context of the code after that point too
[03:15:03] <GBGamer> oh yeah, I was thinking a C-like language
[03:16:03] <Elaine> If that is the only use of x then an optimizing compiler could elide it
[03:16:59] <Elaine> but as written, they're not equivalent.
[03:18:10] <GBGamer> in C, { int c = a + b; fun(c) } and { fun(a + b) } should be equivalent
[03:18:31] <Peach> For my purposes Elaine, I think a C compiler will auto elide it for me :3
[03:18:40] <Peach> Pretty much any C compiler except TinyC
[03:18:56] <Peach> (I'm sure Tiny C doesn't optimize at all)
[03:19:50] <GBGamer> I'm going to retract my statement, actually
[03:19:57] <GBGamer> they'll be similar
[03:20:11] <GBGamer> but not the same, unless you're using C
[03:21:30] <Elaine> in the abstract machine of the C spec, they're different...
[03:21:48] <GBGamer> unless you're using an optimizing C compiler
[03:21:55] <Elaine> no
[03:22:15] <GBGamer> unless you're using specific optimizing C compilers?
[03:22:26] <Elaine> since there aren't side effects an implementation *can* make that change.
[03:24:24] <Peach> So I worked with old engines like duke and doom, it's surprising that floating point math wasn't really standardized in the 90s
[03:24:35] <Peach> so the games implemented their own math
[03:24:44] <Peach> for division and mult etc.
[03:24:55] <Elaine> oh it was plenty standardized but implementations were buggy
[03:26:07] <Elaine> and slow, depending on what you need
[03:26:14] <Elaine> didn't doom use fixed point?
[03:26:34] <Elaine> yeah
[03:27:38] <Peach> doom used fixed point yup
[03:27:41] <Peach> So now I'm so happy
[03:27:49] <Peach> I get to use float throughout my code
[03:28:28] <Peach> Though I do wonder - wouldn't it be simpler to just use fixed point math as a default for "float" Elaine ?
[03:28:32] <Peach> Why IEEE
[03:29:11] <Peach> why not just predictable decimal math everywhere
[03:29:22] <Elaine> IEEE 754 is predictable, that's why it exists.
[03:29:29] <Elaine> (also it does have a decimal floating point)
[03:30:29] <Elaine> Floating point allows for a wider range of representable values.
[03:32:12] <Peach> ah
[03:32:34] <Peach> But Elaine what I'm really getting at is how I don't like infinite and nan : (
[03:32:40] <Elaine> lol
[03:33:04] <GBGamer> but how would you do 1/0?
[03:33:42] <GBGamer> and 0/0?
[03:33:46] <GBGamer> just panic?
[03:34:04] <Peach> I would be so fine with crashing like integers do
[03:34:15] <Peach> I would even love for it to just lie to me and say 0
[03:34:35] <Elaine> Nobody writing scientific code would appreciate that :P
[03:34:42] <Elaine> Numerical analysis is important.
[03:35:02] <Peach> because currently I have to do   if (Meshdata.tangent.x == 0 || isnan(Meshdata.tangent.x))   in my code
[03:35:10] <Peach> It's annoying that I can't track invalid divisions
[03:35:24] <Peach> So I really wish I could just tell my compiler to crash upon a Nan instruction
[03:35:37] <Elaine> you're allowed to do that.
[03:35:40] <Peach> YOU ARE?
[03:36:06] <Peach> Please do tell Elaine 
[03:36:14] <Elaine> Signaling NaNs
[03:36:31] <Elaine> though I'm not sure if you refer to "my compiler" as the one that you are writing or the one you are using
[03:37:21] *** Quits: Manishearth (manishearth@moz-uc30rq.anapnea.net) (Ping timeout: 121 seconds)
[03:38:19] <Peach> The one I'm using Elaine 
[03:38:21] <Peach> gcc
[03:38:23] *** Joins: Manishearth (manishearth@moz-uc30rq.anapnea.net)
[03:38:23] *** ChanServ sets mode: +o Manishearth
[03:38:45] <Peach> and I'll definitely have to look at how to signal nan on the compiler I'm writting
[03:38:50] <Elaine> yeah you're out of luck
[03:38:57] <Peach> Wait wha @_@
[03:39:05] <Peach> GCC
[03:39:08] <Elaine> no signalling NaNs are a type of NaN, it's not a thing you do
[03:39:52] <Elaine> Quiet NaN propagates, Signalling NaN traps.
[03:41:49] <Peach> Ok, my question is: Is it possible to enable some option to make my GCC compiled program crash upon an instruction that generates Nan or infinity Elaine ?
[03:41:57] <Elaine> no
[03:42:04] <Peach> :(
[03:42:30] <Peach> Why do integers get the luxury of crashing though?
[03:42:50] <Peach> Floats just silently pretend there's no error with their Nans and whatnot
[03:44:06] <Peach> "C signalling Nan gives me no good results"
[03:44:10] <Peach> hmm lemme see
[03:45:19] <GBGamer> Peach: http://stackoverflow.com/questions/2941611/can-i-make-gcc-tell-me-when-a-calculation-results-in-nan-or-inf-at-runtime
[03:45:21] <Elaine> feenableexcept(FE_DIVBYZERO|FE_INVALID|FE_OVERFLOW|FE_UNDERFLOW) should help.
[03:45:43] <Elaine> but it's a thing you need to do in your code
[03:46:17] <Peach> Got it
[03:46:44] <Peach> MAN how come computer setup is so messy for simple things like this
[03:46:54] <Elaine> because it's not actually simple
[03:47:38] <Peach> Well, conceptually simple, I wish low level stuff was better prepared
[03:47:51] *** Havvy[Hex] is now known as Havvy
[03:48:05] <Peach> You'd think it'd be easy to coordinate when something generates an error, how did it work for integer div but not for float :(
[03:48:12] *** Quits: Manishearth (manishearth@moz-uc30rq.anapnea.net) (Ping timeout: 121 seconds)
[03:48:33] *** Quits: Guest11988 (manishearth@moz-uc30rq.anapnea.net) (Ping timeout: 121 seconds)
[03:49:09] <Elaine> it's important to note that gcc will do optimizations that break strict floating point semantics.
[03:49:17] <Peach> aaaaaaaaaa
[03:49:22] <Elaine> so you might miss some exceptions that you might think ought to happen
[03:49:52] <Elaine> it's not actually conceptually simple either, you just have a naive model of how things ought to be that conflicts with the mathematical and implementation realities.
[03:50:25] <Peach> Hmmmmm
[03:50:27] <Peach> int x = 0; int y = 2; int z =  x/y;      <--- This guarantees a crash, right?
[03:50:43] <Elaine> no, that's 0, do you mean y/x?
[03:50:43] <Peach> oops
[03:50:51] <Peach> int x = 2; int y = 0; int z =  x/y;      <--- This guarantees a crash, right?
[03:51:21] <Peach> 2/0
[03:51:26] <Elaine> No, it's undefined behavior.
[03:51:32] <Peach> @_@
[03:52:32] <Zoxc> Stop breaking Peach
[03:52:42] *** Joins: npm (npm@moz-rl3.0t6.56.172.IP)
[03:53:06] <scott> I think C is designed to defy intuitive assumptions.
[03:53:11] <Elaine> In practice the hardware will trap when you divide by zero and the OS will send you a signal (on posix, SIGFPE, like other floating point exceptions)
[03:54:26] <Peach> I really will have to add a LOT of checks to make safe generated C code with no undefined behavior
[03:54:54] *** Joins: Manishearth (manishearth@moz-uc30rq.anapnea.net)
[03:54:54] *** ChanServ sets mode: +o Manishearth
[03:54:58] <Peach> Elaine: how does rust handle int division by zero?
[03:55:05] <Havvy> It panics.
[03:55:10] <Elaine> It checks for zero and panics.
[03:55:14] <Havvy> playbot: 1i / 0i
[03:55:15] -playbot- <anon>:9:9: 9:11 error: illegal suffix `i` for numeric literal
[03:55:15] -playbot- <anon>:9         1i / 0i
[03:55:15] -playbot- output truncated; full output at: http://bit.ly/1LjxyTh
[03:55:19] *** Joins: Manishea1th (manishearth@moz-uc30rq.anapnea.net)
[03:55:20] <Havvy> playbot: 1i32 / 0
[03:55:21] -playbot- <anon>:9:9: 9:17 error: attempted to divide by zero in a constant expression [E0020]
[03:55:21] -playbot- <anon>:9         1i32 / 0
[03:55:21] -playbot- output truncated; full output at: http://bit.ly/1OeQPTB
[03:55:31] <Peach> Rust has no undefined behavior right? (please tell me)
[03:55:45] <Elaine> It does, but only unsafe code can trigger it.
[03:55:57] <Elaine> Inherited from LLVM of course
[03:56:04] <Elaine> since LLVM is a C compiler at heart
[03:56:12] <Peach> playbot:  1773.0 / 0.0
[03:56:13] -playbot- inf
[03:56:16] <Peach> : (
[03:56:24] <Peach> > : (
[03:56:31] *** Quits: GBGamer (npm@moz-pi07bg.hfc.comcastbusiness.net) (Ping timeout: 121 seconds)
[03:56:33] <Havvy> Rust is as TCP as LLVM is to IP.
[03:56:46] <Peach> Why does integer division get special treatment for errors/exceptions
[03:57:15] <scott> playbot: let x = 0; 1 / x
[03:57:16] -playbot- thread '<main>' panicked at 'attempted to divide by zero', <anon>:9
[03:57:16] -playbot- playpen: application terminated with error code 101
[03:57:20] <scott> That's what it looks like at runtime.
[03:57:42] <Havvy> I wouldn't call it special treatment. The floating point spec defines what happens when you do "1f / 0f"
[03:57:49] <Elaine> because there's no meaningful value defined on the integers, but lim (x / y) as y -> 0 is infinity, is one of the reasons.
[03:57:53] <Elaine> and you CAN get floating point exceptions.
[03:58:01] <Elaine> you just need to enable them if they aren't (and they usually aren't)
[03:58:07] <Elaine> but the hardware handles it all correctly.
[03:59:10] <Peach> If I'm in a domain that doesn't care about accuracy - can I used fix point math without any undefined behavior or inf or nan?
[03:59:14] *** Quits: npm (npm@moz-rl3.0t6.56.172.IP) (Ping timeout: 121 seconds)
[03:59:19] *** Joins: npm (npm@moz-pi07bg.hfc.comcastbusiness.net)
[03:59:30] <Elaine> of course you can, but you pay for it with efficiency.
[04:00:05] <Elaine> can't use simd, modern x86 has fast floating point.
[04:02:11] *** Joins: Peach_ (Fancy3D@moz-500.6lb.246.96.IP)
[04:04:14] *** Quits: Peach (Fancy3D@moz-500.6lb.246.96.IP) (Ping timeout: 121 seconds)
[04:04:14] *** Peach_ is now known as Peach
[04:07:00] <Peach> Well to be honest, you can get around that issue if you have a smart static analyzer on all your code
[04:07:16] <Elaine> uh
[04:07:22] <Elaine> really?
[04:07:57] <Peach> So as long as I can make a compiler that enforces conditional branch on division or ops on externally defined values, it should be good
[04:08:25] <Elaine> if you say so
[04:09:01] <Peach> so for example      int a = 1; int b = 2;     a/b; // good
[04:09:20] <Elaine> I'm not talking about division checks, I'm talking about fixed point
[04:09:26] <Peach> int a = 1; int b = readuserinput;  a/b;  // bad - b must check conditional
[04:09:50] <Elaine> function int a(int b) { .. }
[04:09:53] <Elaine> is b tainted?
[04:10:18] <Peach> Oh sorry Elaine - I should have said - you can get around undefined integer division and floating point Nan if we know about which vars need to be checked
[04:10:28] <Peach> Elaine: The analyzer checks globally,
[04:10:34] <Peach> it resolves it on calls of a();
[04:10:49] <Peach> So it's more than just local analysis
[04:10:58] <Elaine> And emits a different function for each combination of taint bits?
[04:11:09] <Elaine> (that is used)
[04:11:37] <Peach> No, it uses the same function, it simply enfoces a branch in the place that calls it - IF the input is "tainted"
[04:11:47] <Peach> a(7) - good, constant
[04:11:56] <Elaine> Ah I see. That can still be local.
[04:12:16] <Peach> int val = 3;   a(val); // good - value known in scope
[04:12:32] <Elaine> Mark arguments if they are used to derive a value used in division locally, callers enforce that it's non-zero.
[04:12:35] <Peach> int val = 3; val = random();  a(val);  // error val could be 0
[04:12:48] <Peach> Exactly Elaine 
[04:12:52] <Elaine> That's not global
[04:13:45] <leftylink> hmm. I might think about doing the resistance in rust
[04:14:12] <Elaine> what's the resistance?
[04:14:43] *** Joins: Peach_ (Fancy3D@moz-500.6lb.246.96.IP)
[04:18:12] *** Quits: Peach (Fancy3D@moz-500.6lb.246.96.IP) (Ping timeout: 121 seconds)
[04:18:12] *** Peach_ is now known as Peach
[04:18:38] <Peach> I wish hardware could support value clamping without a performance penalty
[04:18:44] <Peach> That would solve so many things :P
[04:19:46] <Elaine> FLoats saturate into negative and positive infinity ;)
[04:20:59] <Peach> grkewaghaor;;ohp4ghborbnrebni;oreb
[04:21:19] <Peach> I'm gonna just take out floating point
[04:21:31] <Peach> In fact, the language is gonna just take out all math
[04:21:36] <Peach> because too much is undefined
[04:21:58] <Peach> But yeah...you can't do that :'(
[04:24:42] <Peach> Is it practical to remove NaN / +-inf from the language?
[04:25:18] <Peach> I suppose I can do it,
[04:25:38] <Peach> external input is really the only concern for needing to handle Nan inf
[04:26:07] <Havvy> You could - just don't call it floating point at that point.
[04:27:07] <Peach> Wow Python has infinite precision math by default?
[04:27:27] <Elaine> only for integers.
[04:27:31] <Elaine> it's a bignum
[04:28:40] <Peach> Wow, existing programming language have a very Math/Data processing scope
[04:29:05] <Peach> There are few that are multimedia/interactive entertainment/realtime 3d scope programming  languages
[04:29:31] <Elaine> I wonder why...
[04:30:02] <Peach> Cause the market for high level interactive entertainment just caught on Elaine 
[04:30:24] <Peach> before 2005, very few people did indie gamedev and whatnot
[04:30:35] <Peach> cause there simply weren't platforms or an audience for it
[04:30:38] <Elaine> Is that so?
[04:30:49] <Elaine> That's sort of ignoring the minicomputer and early PC timeline.
[04:31:30] <Peach> Well I do think that the market was rather small compared to now, even today hardcore gaming market is somewhat small
[04:31:48] <Peach> but now casual games are everywhere
[04:32:09] <Peach> and nearly everyone has a mobile device that can do advanced 3D
[04:32:49] <Elaine> fair enough
[04:36:12] <Peach> Oh wow Rust is only 5 years old
[04:36:22] <Elaine> if that ;)
[04:36:31] <Elaine> modern rust is surely no older than 3 years.
[04:38:49] <Peach> Wow GLSL is only 10 years old
[04:39:17] <fmtq> yay I have three screens now
[04:41:23] <Peach> Elaine: what computer do you have?
[04:41:45] <Elaine> I built my own desktop and I have an asus something or other laptop
[04:42:59] <Peach> Favorite OS(es) ?
[04:44:50] <Elaine> I use arch linux exclusively but I've been building some stuff around seL4 that I plan to migrate to as soon as lowRISC releases their first SoC.
[04:47:04] <whipsch> i use windows ME
[04:51:45] <Peach> Really whipsch ?
[04:57:13] <Peach> I use Windows XP sometimes <3
[04:59:09] *** Joins: swgillespie (swgillespie@moz-rn1.vmq.232.104.IP)
[04:59:24] *** Quits: swgillespie (swgillespie@moz-rn1.vmq.232.104.IP) (Quit: My MacBook Pro has gone to sleep. ZZZzzz…)
[05:00:02] <Peach> Guys, anyone here like an OS that isn't linux or windows?
[05:00:09] *** Quits: fmtq (quassel@moz-54c141.sk83.bjud.7e00.2a01.IP) (A TLS packet with unexpected length was received.)
[05:00:22] <Havvy> Probably some fans of BSD here.
[05:00:23] <whipsch> bsd
[05:00:32] <Havvy> And I bet somebody likes their own OSes they've written in Rust.
[05:00:39] <whipsch> my nas runs freebsd, pretty nice
[05:00:42] <Havvy> (See also, #rust-osdev )
[05:00:46] <whipsch> i dream of a solid rust os
[05:01:43] *** Joins: fmtq (quassel@moz-54c141.sk83.bjud.7e00.2a01.IP)
[05:01:49] <Layl> imagine a OS designed to fully sandbox applications without the overhead of multiple kernels
[05:02:03] <Peach> Guys, you know what I want?
[05:02:08] <Peach> An OS with a fancy GUI
[05:02:11] <Peach> that's free
[05:02:20] <Layl> soo... linux with gnome?
[05:02:35] <Havvy> GUIs aren't on the OS level?
[05:02:40] <Peach> Linux has no usability awards going for it > : (
[05:03:11] <Peach> End user GUIs that are fancy and user friendly is what I'd like - and on a free OS too
[05:03:21] <Havvy> I'd like to see a Rust OS that is specifically built for secure POS devices.
[05:03:30] <fmtq> Peach: uh elementary.io
[05:03:39] <Peach> elementary OS is close
[05:03:39] <Elaine> what does fancy even mean
[05:03:42] <Elaine> you use that word a lot
[05:03:51] <Elaine> I don't think I've ever used a computer I'd describe as fancy
[05:04:13] <Peach> That's because you like Linux
[05:04:14] <Peach> :P
[05:04:17] <Peach> (just kidding(
[05:04:30] <Layl> I really want to get an OS project going one of these days
[05:04:30] <Elaine> I don't like linux, I tolerate linux
[05:04:38] <Layl> but I really can't be bothered with getting a compiler toolchain set up
[05:04:43] <Layl> it's so much wooork uuuuggh
[05:04:55] * Havvy tolerates Linux just as much as he tolerates Windows.
[05:04:59] <ChrisMorgan> Peach: Ubuntu?
[05:05:10] <Peach> I'd like a Desktop/GUI thing that integrates user friendliness for developers
[05:05:22] <Peach> Like an OS built for high level software dev
[05:05:34] <Layl> what I really want is this:
[05:06:00] <Layl> a template github repo that just contains a single .c file, a single .asm file and a single .ld file, and a .sh file that compiles it all together
[05:06:10] <Layl> with a vagrant file next to it
[05:06:15] <Peach> Ubuntu doesn't have enough clean UI design - you have to use the terminal too much
[05:06:17] <Layl> really easy start to go from
[05:06:44] <Layl> Peach, that assumes ubuntu with unity
[05:06:51] <Layl> I prefer gnubuntu myself
[05:06:59] <Layl> *gubuntu
[05:07:11] <Peach> Perhaps my area of use is different from the average user
[05:07:16] * ChrisMorgan likes Ubuntu + Unity
[05:07:22] * Elaine likes Ubuntu + Unity
[05:07:43] <Elaine> I've used it on all my new builds.
[05:07:47] * Layl dispises Ubuntu + Unity with a burning passion of a thousend suns
[05:07:54] <Peach> I don't use email and I don't frequently browse the web, I do software development for graphics related things and I like composing music and making videos
[05:08:05] * ChrisMorgan still switched from Unity to i3 eventually as it met his specific requirements better, and then switched to Arch Linux when he got a new laptop
[05:08:30] <Elaine> Still not my main dev laptop, I also use arch and i3 there.
[05:09:34] <ChrisMorgan> Still, my old Ubuntu laptop is amusingly still in active service (with Unity, for the sake of Normal People) for a scanner that we have which doesn’t work on any Windows newer than XP.
[05:09:54] <ChrisMorgan> … whereas, of course, it continues to work just fine on Linux.
[05:13:44] <whipsch> im kinda tired of arch these days
[05:13:59] <whipsch> i really do appreciate the minimalism, but honestly i just cant be bothered to deal with it
[05:14:06] <Peach> User friendly Interface design is seriously lacking in open source
[05:14:12] <Peach> everything is command line centric
[05:14:25] <Elaine> Not everything.
[05:14:27] <Peach> and even the command line commands are poorly named
[05:15:30] <whipsch> usually i find clis to be superior to gui alternatives for linux apps, however it varies
[05:16:00] <Peach> ^
[05:16:19] <Peach> And it's that type of preference that dominates open source everything
[05:16:42] <whipsch> copying files i would much rather cp /som/path/with/a/bunch/of/tabbing/for/completion ... much easier than wading through some gui file manager
[05:16:48] <whipsch> er
[05:16:50] <Elaine> For good reasons. The various GUIs tend to be inflexible and non-automatable.
[05:16:57] <whipsch> i changed my sentence halfway through, you can figure it out
[05:17:17] <whipsch> yup Elaine 
[05:18:00] <whipsch> usually for a given behavior there is *some* way to accomplish via various clis, but with a gui you have to hope the functionality is exposed or you're out of luck
[05:18:01] <Peach> Is it possible to make a GUI that IS flexible and automatable?
[05:18:15] <Elaine> Of course it is.
[05:18:32] <whipsch> i suppose you could expose every piece of meaningful functinality as a ui component and let the user build their own ui as they see fit
[05:18:34] <Elaine> See applescript, the various smalltalk systems, etc.
[05:18:39] <Elaine> Blender
[05:18:53] <Elaine> Most commercial EDAs and CAD tools.
[05:18:54] <whipsch> oh and automatable
[05:19:25] <whipsch> you may even consider autohotkey as a gui automation tool i guess
[05:19:37] <whipsch> (on windows)
[05:19:51] <whipsch> not really user friendly though..
[05:20:21] <Elaine> Plus there are plenty of ways to structure software such that the GUI is just a frontend to some programmatic backend
[05:20:42] <Elaine> so even if your GUI toolkit isn't flexible or automatable, it doesn't matter.
[05:21:22] <whipsch> sometimes i think the best way to write real applications is to just have it deliver an api, rest or json rpc or something, and then build interfaces around that
[05:21:28] <whipsch> for whatever sort of use case
[05:21:48] <Elaine> (Which is how the EDA and CAD tools tend to work)
[05:22:03] <Elaine> (but you can hardly call those user friendly or well designed, most of the time)
[05:22:24] <whipsch> i guess most users would be engineers who may not mind anyway :)
[05:22:32] <Elaine> exactly
[05:22:37] <whipsch> or can at least deal with it
[05:22:41] <XMPPwocky> and it grows on you
[05:22:43] <Elaine> which is the same case as for most open source software!
[05:22:44] <XMPPwocky> like a bacterium
[05:22:50] <whipsch> man
[05:22:53] <whipsch> problem solved
[05:28:00] <Peach> >:(
[05:28:14] <Peach> Cycle detected
[05:28:26] <Peach> Logic conjecture self referenced
[05:28:40] <Peach> Problem.solved = FALSE
[05:29:02] <fmtq> my favourite feature of OS X: it handles multiple monitors without human interaction.
[05:29:07] <fmtq> you plug it in, the monitor appears.
[05:30:08] <o11c> fmtq: last I checked that works for me on Linux
[05:30:29] <o11c> it does pop up the settings windows so you can move it around since computers don't know the physical order
[05:30:50] <XMPPwocky> extraordinary claims like "something related to x11 works" require extraordinary evidence
[05:32:30] <fmtq> ^
[05:38:14] *** Quits: Dabo (dabo@znc.dabo.guru) (Ping timeout: 121 seconds)
[05:41:30] *** Joins: Dabo (dabo@znc.dabo.guru)
[05:55:15] <Layl> translating a makefile into what the hell is actually going on is always fun
[05:55:20] <Layl> and with fun I mean excruciating pain
[06:10:30] <zwarich> Elaine: I hope you like Tcl
[06:10:39] <Layl> wget seems very determined to trash all over my output
[06:10:50] <Layl> 1000 lines of "wget: ."
[06:13:33] *** Quits: dpc (dpc@moz-t6gr4b.ca.comcast.net) (Ping timeout: 121 seconds)
[06:15:12] <Layl> and it's ignoring -q, --quiet, -quiet and -nv
[06:15:18] <Layl> quite vexing
[06:22:58] <Layl> it's even managing to get around being piped to /dev/null
[06:23:04] <Layl> this is quite amazing
[06:23:19] <scott> stdout and stderr both piped?
[06:23:50] <scott> I noticed gpg getting around that once by writing directly to the pty...
[06:24:18] <Layl> I don't get why it's ignoring the -q flag though
[06:39:02] <Peach> fmtq: my favourite feature of OS X: it handles multiple monitors without human interaction. you plug it in, the monitor appears.   woah <3
[06:39:20] <Peach> I forgot Macs did that
[06:39:38] <Peach> Also Layl Makefile is evil
[06:39:53] <Peach> In fact 90% of programmer tools are poorly designed
[06:40:11] <Peach> why programmers why ;-;
[06:40:15] <Layl> well, they ARE designed by the kind of people who take time out of their day to solve a meta problem
[06:40:27] <Layl> rather than the actual problem at hand
[06:40:49] <Peach> Those same people totally could think about "user friendliness" from a programmer's perspective though
[06:40:53] <Layl> shouldn't be a big surprise when they all end up in some way being turing complete
[06:41:20] <Peach> developers, developers, developers
[06:41:33] <Peach> many of them are so silly :3
[06:41:40] <Peach> smart yet silly
[06:42:18] <Peach> over-engineering is too common
[06:42:57] <Peach> Oh wow
[06:43:04] <Peach> I need sleeeeeeeeeeeeeeeeeep
[06:43:04] *** Quits: Peach (Fancy3D@moz-500.6lb.246.96.IP) (Client exited)
[07:32:32] <Layl> Quxxy, you can look at your most played games over the last month on steam
[07:32:38] <Layl> and see what countries they came from
[07:32:55] <Quxxy> Except then I'd have to hunt down the devs individually
[07:32:59] <Quxxy> And I just don't care enough to do that
[07:33:32] <Layl> I know a lot by head so
[07:33:34] <Layl> just checking out mine
[07:35:39] <Layl> France, USA, UK, ???, USA, Netherlands, USA, Poland
[07:35:45] <Layl> on my steam recently played list
[07:38:15] <Quxxy> Two Tribes, Tasharen, GalaxyTrail, Zachtronics, DoubleFine, DoubleDutch, Nicalis, Devil's Details
[07:39:33] <Layl> was that a guess at the developers of those games?
[07:39:44] <Quxxy> No, those *are* the devs
[07:39:47] <Layl> they're all wrong if it was
[07:39:57] <Quxxy> From *my* list
[07:40:03] <Layl> ah I see
[07:41:26] <Layl> we play very different types of games then, I only recognize a quarter of the devs on that list
[07:41:53] <Quxxy> ... DoubleFine and Nicalis? :P
[07:42:35] <Layl> for me it was Eugen Systems, Valve, Splash Damage, Knuckle Cracker, Volition, Splitpolygon, Landon Podbielski, CD Projekt Red
[07:42:49] <Layl> nope, doublefine and zachtronics
[07:43:49] <Quxxy> Hmm... Dunno, TF2/CS Go, Dunno, Red Faction Something, Dunno, Dunno, Witcher 3
[07:45:01] <Layl> Act of Aggression, TF2, Dirty Bomb, Red Faction Guerrilla, Creeper World 3: Arc Eternal, Interstellar Rift, DUCK GAME, The Witcher 3
[07:45:59] <Layl> replaying red faction guerrilla now that I've got a mod that replaces all safe house vehicles with combat walkers with rocket launchers
[07:46:14] <XMPPwocky> tf2, source sdk, occasionally csgo
[07:46:27] <Layl> they're a very effective way of taking out convoys
[07:46:47] <Layl> still my favorite modded in weapon in red faction guerrilla is the gun that repairs things
[07:46:59] <Layl> so you can smash a hole in a wall, walk in, then repair the hole behind you
[07:49:18] <Quxxy> Oh, I forgot Splash Damage; was going to guess Wolfenstein
[07:49:51] <Quxxy> Toki Tori 2+, Windward (barely), Freedom Planet (so hard), TIS-100, Broken Age, SpeedRunners, The Binding of Isaac: Rebirth
[07:50:02] <Quxxy> Oh, and Sonic Generations
[07:50:23] <Quxxy> I need to get around to playing Guerrilla 
[07:52:06] <Layl> Quxxy, imo red faction guerrilla is best played at eazy difficulty with a bunch of mods
[07:53:24] <Layl> the best way to rescue hostages is by pulling off a really nice jump to park the escape car right on the third story of the building those hostages are in
[07:53:54] <Layl> they didn't need those windows anyways
[08:23:10] *** Quits: Romster (Romster@moz-4g83e8.rev.eftel.com) (Ping timeout: 121 seconds)
[08:25:13] *** Joins: Romster (Romster@moz-4g83e8.rev.eftel.com)
[08:32:42] *** Quits: Romster (Romster@moz-4g83e8.rev.eftel.com) (Ping timeout: 121 seconds)
[08:33:39] *** Joins: Romster (Romster@moz-4g83e8.rev.eftel.com)
[09:10:18] <npm> boop
[09:11:27] *** npm is now known as GBGamer
[09:27:08] *** Joins: fkaa (fkaa@moz-501od2.business.telia.com)
[09:31:29] *** Joins: npm (npm@moz-9jn.0t6.56.172.IP)
[09:35:22] *** Quits: GBGamer (npm@moz-pi07bg.hfc.comcastbusiness.net) (Ping timeout: 121 seconds)
[09:42:18] <Astraea> Yawn
[09:42:22] <Astraea> What a night
[09:43:41] <Quxxy> Late December back in '63
[09:49:00] <npm> what happened in '63?
[09:49:35] <fkaa> can you use numbers for lifetime names?
[09:50:14] <npm> I think you'd have to start with [_a-z]
[09:51:01] *** Joins: spider-mario (spidermario@moz-coblcf.fbx.proxad.net)
[09:55:36] *** Quits: johnsoft (johnsoft@moz-69mrig.res.rr.com) (Ping timeout: 121 seconds)
[09:55:45] *** Joins: johnsoft (johnsoft@moz-69mrig.res.rr.com)
[10:08:21] *** Quits: perillamint (perillamint@moz-pvo.3mu.72.61.IP) (Ping timeout: 121 seconds)
[10:12:53] *** Joins: perillamint (perillamint@moz-pvo.3mu.72.61.IP)
[10:56:29] *** Quits: Tiktalik (quassel@moz-j5b0ac.8ou1.oi46.fcd0.2607.IP) (Quit: No Ping reply in 180 seconds.)
[10:57:40] *** Joins: Tiktalik (quassel@moz-j5b0ac.8ou1.oi46.fcd0.2607.IP)
[11:01:05] *** Quits: npm (npm@moz-9jn.0t6.56.172.IP) (Quit: AndroIRC - Android IRC Client ( http://www.androirc.com ))
[11:06:06] *** Joins: Lilly (Lilly@moz-pfkvo9.bredband.comhem.se)
[11:14:06] *** panicbit2 is now known as panicbit
[11:15:08] *** panicbit is now known as Guest61097
[11:16:03] <delma> Long time without programming with Java: Writing System.out.println!();
[11:16:06] <delma> xD
[11:16:30] *** Guest61097 is now known as panicbit
[11:47:09] *** Joins: niconii (nicole@moz-5iorc7.frgo.qwest.net)
[12:03:07] *** Joins: Sho (sho@moz-770.gd6.28.5.IP)
[12:40:32] *** Joins: Rym (uid91135@moz-n2i7qm.charlton.irccloud.com)
[13:49:20] <fkaa> haha https://twitter.com/rygorous/status/622661671949983744
[13:50:30] <Tiffany> hahaha
[13:56:55] *** Quits: rovar (rovar@moz-6iq.47m.88.38.IP) (NickServ (RECOVER command used by rovar_))
[13:56:55] *** Joins: rovar (rovar@moz-96effg.dyn.optonline.net)
[13:57:08] *** Joins: rovar_ (rovar@moz-6iq.47m.88.38.IP)
[14:04:50] *** Quits: Romster (Romster@moz-4g83e8.rev.eftel.com) (Ping timeout: 121 seconds)
[14:05:51] *** Joins: Romster (Romster@moz-4g83e8.rev.eftel.com)
[14:28:48] *** Joins: blue_deref (blue_deref@moz-eqnijv.res.rr.com)
[14:30:43] <eddyb> it's okay, our MIR won't be SSA-form
[14:35:41] <eddyb> (no, don't think about reversing both acronyms. nope, they're fine, don't mind me)
[15:32:36] *** Joins: ytain (ytain@moz-u0rb5h.dsl.teksavvy.com)
[15:37:34] *** Joins: Peach (Fancy3D@moz-500.6lb.246.96.IP)
[15:53:24] <Peach> Ok, so from a language design perspective,
[15:53:40] <Peach> I'm making a language that defaults to use local scope for the lifetime of objects
[15:54:02] <Peach> so it's deterministic and overall you need no garbage collector
[15:54:24] <Peach> Now, from a high level standpoint - when using a programming language,
[15:55:03] <Peach> Is having an object accessible outside of local scope the only logical reason to use a pointer?
[15:55:33] <Peach> Would it be sufficient that in all other cases, programmers can just use local objects that automatically destruct on scope leave?
[16:08:29] <panicbit> 7b 7
[16:08:36] <panicbit> ...
[16:13:14] <Peach> why do generics use <>
[16:13:26] <Peach> wouldn't [] be better and less ambigous?
[16:13:39] <Peach> [] means lookup - and it makes sense for a generic type
[16:16:33] <eddyb> Peach: yeah, good luck with that
[16:16:37] *** Quits: spider-mario (spidermario@moz-coblcf.fbx.proxad.net) (A TLS packet with unexpected length was received.)
[16:16:42] <eddyb> Peach: how do you do array indexing?
[16:16:48] <Peach> the same way
[16:16:53] <Peach> the compiler just resolves it
[16:17:02] <eddyb> compilers are not magic
[16:17:15] <Peach> If I write one it can be
[16:17:32] <eddyb> it doesn't work like that :P
[16:17:54] <eddyb> C++ for example doesn't require anything before <, like Rust does (:: in expressions)
[16:18:01] <eddyb> but if it's ambiguous, it's very nasty
[16:18:04] <Peach> Yeah it does -   List[int] x; is a valid declaration, and    arr[val]  is a valid lookup
[16:18:28] <Peach> It isn't ambigous cause you have to do symbol lookup anyway
[16:18:29] <eddyb> Peach: what about generic functions?
[16:19:02] <eddyb> or static methods on generic types?
[16:19:19] <Peach> For generic functions, the language can pass types as first class arguments (gets resolved at compile time)
[16:19:37] <zofrex> <Peach> If I write one it can be < not necessarily
[16:19:44] <eddyb> oh so you're trying that clever thing I also thought of
[16:19:46] <zofrex> you're potentially going to learn about ambiguous grammar the hard way
[16:20:06] <eddyb> Peach: do you want any inference?
[16:20:19] <eddyb> how do you encode Vec::new() vs Vec::<T>::new()?
[16:20:28] <Peach> zofrex - Well you all are prematurely assuming issues in a language spec and compiler that you haven't seen ;)
[16:20:37] <Peach> eddyb: I have type inference
[16:20:52] <zofrex> yeah I'm extrapolating from prior experience
[16:21:06] <eddyb> Peach: you sound like me when I was 13
[16:21:15] <eddyb> learning the truth did hurt, fwiw
[16:21:26] <zofrex> you are basically asserting that everyone else in the world who ever made a compiler wasn't as smart as you, if you think you have a unique solution to this...
[16:21:39] <niconii> err, let's tone it down a bit
[16:21:51] <eddyb> I have a partial solution that is similar to what Peach is saying
[16:21:57] <eddyb> but it doesn't play well with inference
[16:21:59] <Peach> zofrex: yeah that's what 90% of computer people do, they don't scientifically ask questions and just use assumptions :P
[16:22:10] <eddyb> /facepalm
[16:22:16] <Peach> You haven't even seen my compiler zofrex 
[16:22:17] <zofrex> that said, I don't mean to discourage you at all, I do think this is hands down the best way to learn about the limitations and trade-offs inherent in building a parser
[16:22:32] <zofrex> niconii: sorry, that sounded less harsh in my head
[16:22:40] <Peach> what is your solution eddyb ?
[16:23:15] <eddyb> it involves removing the tiered discrimination between values, types, traits, etc
[16:23:30] <eddyb> you are left with entities and functions between entities
[16:24:07] <eddyb> I have a few examples around, but they're of different dialects
[16:24:28] <eddyb> T: Trait can be encoded in a few different ways, and they all have their issues
[16:24:28] <Peach> zofrex: You could be a bit more engaging by asking what compilers and languages I've studied, and what my ideas are
[16:24:55] <Peach> Actually zofrex, what all of us have that previous compiler makers didn't have is retrospect ;)
[16:25:05] <eddyb> let's see...
[16:25:16] <eddyb> "5".parse(i32) was one example
[16:25:41] <Peach> Compiler making can improved as long as we understand the issues of the systems that came before us :P
[16:25:41] <eddyb> but then, if you want to infer it and have "5".parse(): Option(i32) work
[16:26:06] <eddyb> you need to accept both the form where the type parameter is passed as an argument to the method
[16:26:10] <eddyb> and the form where it isn't
[16:26:23] <eddyb> the Vec::new example is worse
[16:26:30] <Peach> It sounds complex eddyb 
[16:26:44] <eddyb> Vec.new(), Vec(i32).new(), Vec.new(i32)
[16:26:48] <Peach> Let's get back to your previous question,
[16:26:50] <zofrex> Peach: apologies if I rubbed you the wrong way with my comments
[16:26:53] <eddyb> which forms should be valid and *why*
[16:26:58] <Peach> you were asking how I handled generic new
[16:27:05] <zofrex> I have been following your escapades on and off in this channel and I am cheering you on from the sidelines :)
[16:27:12] <Peach> :D
[16:27:42] <eddyb> if you always pass type params explicitely, I might have a working mutation of Rust's syntax with almost unchanged semantics
[16:28:03] <Peach> Ok, so it works like this eddyb
[16:29:01] <Peach> function min(x) { if (typeof x is int)  return x + 7; else something; }
[16:29:22] <Peach> the compiler can generate overloads of the function based on that static if
[16:29:30] <eddyb> OH
[16:30:03] <eddyb> I thought you had static types. or at least an usual variety of them
[16:30:11] <Peach> I do
[16:30:19] <Peach> It's all statically typed
[16:30:20] <Elaine> zwarich: ;)
[16:30:29] <Elaine> zwarich: it's better than nothing!
[16:30:37] <Elaine> Strings or bust yo
[16:30:53] <eddyb> Peach: what about bounded polymorphism?
[16:30:54] <Elaine> tcl/tk is ugly as sin but it works.
[16:30:57] <Peach> all types are known by the compiler and the programmer can directly use a source file's AST to do serious high level metaprogramming
[16:31:13] <Elaine> Altera's EDA Quartus is Tcl with Qt, I was surprised to experience that.
[16:31:40] <Peach> the compiler can check the constraints on a type by how  you use it, so it can know which types are allowed for any given function
[16:31:55] <eddyb> so C++-style duck types
[16:32:03] <eddyb> Peach: hmpf. so you have generic types but not *explicitley* generic functions
[16:32:19] <eddyb> Peach: still, how does the Vec::<T>::new() example work?
[16:32:35] <eddyb> you don't have values to get T from
[16:32:54] <Peach> pretty much:    function writelog(x) { writefile(x.getdata()) } - would work for anytype that implements getdata that is usable with "writefile"
[16:33:04] <Peach> and for the new,
[16:33:24] <Peach> Well I have generic dynamic arrays built into the language
[16:33:43] <eddyb> forget that
[16:34:08] <eddyb> how do you call a static method with no arguments on a user-defined Foo[T] type?
[16:35:09] <Peach> Can you give a C++ example of what you mean eddyb ?
[16:35:28] <eddyb> Foo<T>::bar()
[16:35:52] <eddyb> given template<typename T> struct Foo { static void bar() {} }
[16:35:59] <Peach> OH
[16:36:14] <eddyb> that what the Vec::new example was meant to be about
[16:36:28] <eddyb> becuase Vec is a library type (a struct) in Rust
[16:36:29] <Peach> Foo[T]::bar();
[16:36:48] <eddyb> and Foo::bar() also works?
[16:36:53] <eddyb> (via inference, where possible)
[16:37:40] <Peach> Yeah it also works, the language has full type inspection more powerful than C++, so yup
[16:38:27] <eddyb> so do you have a cover grammar?
[16:39:05] <Elaine> type inspection more powerful than C++?? it's already turing complete!
[16:40:28] <Peach> In practice elaine, C++ requires many template enum hacks to do stuff, I say it's more powerful because you can pass types and generate code based on types - ALL using the same syntax/semantics as the rest of the default language
[16:40:56] <eddyb> you have something that resembles D, but is somewhat weaker
[16:41:43] <Peach> weaker in what way eddyb ? I wanna learn how to improve :3
[16:42:05] <eddyb> Peach: the part where you don't put types in signatures
[16:42:11] <zofrex> Elaine: LOL. I work with Tcl full-time. It doesn't get enough love. Or enough hate.
[16:42:12] <eddyb> Peach: that makes your static typing weak
[16:42:25] <Peach> Nope eddyb , types are in the signatures too
[16:42:35] <Peach> (I should really write up all the grammar)
[16:42:36] <eddyb> only if not generic?
[16:42:41] <Elaine> zofrex: I agree.
[16:42:50] <Elaine> zofrex: A wonderful, disgusting language.
[16:42:59] <zofrex> :D
[16:43:34] <Elaine> expect is soooo nice.
[16:43:50] <eddyb> Peach: like, how do you write fn strict_eq<T: Eq>(x: T, y: T) -> bool { x == y }?
[16:44:17] <eddyb> Peach: can you type-check calls to strict_eq without knowing its body, but just the signature?
[16:44:50] <eddyb> C++ is trying to move away from duck-typing (see: concepts)
[16:45:17] <eddyb> and AFAICT the design you have is fundamentally incompatible with the ML family, Haskell or Rust
[16:45:45] <eddyb> it's arguably better than Go
[16:46:18] <eddyb> heck, you might be able to extend Go without creating a new language from scratch, but I'm not sure
[16:46:31] <eddyb> (name it Go++ aka "Go with generics")
[16:46:35] <Peach> eddyb -  function strict_equals(x:Equatable, typeof(x) y) returns bool { x == y }
[16:46:50] <eddyb> wait
[16:47:19] <eddyb> so you do have constraints, albeit... okay
[16:47:50] <eddyb> Peach: so if you had a function to return the size of the type, how would you write that?
[16:48:35] <Peach> sizeof(typeof(x));  or just  sizeof(x);
[16:49:12] <eddyb> no
[16:49:27] <eddyb> Peach: I mean, write a function that returns the size of a type that is a generic type parameter of the function
[16:50:23] <Peach> function genericsizeof(type x) -> size_t { return sizeof(x); }
[16:50:30] <eddyb> more challenging example: fn size_and_align<T>() -> (usize, usize) { (mem::size_of::<T>(), mem::align_of::<T>() ) }
[16:50:32] <Peach> genericsizeof(int);   genericsizeof(float);
[16:50:35] <eddyb> Peach: ah
[16:50:51] <eddyb> if I were you I would use T for types, it makes what you're doing much clearer
[16:51:12] <eddyb> like the "sizeof(typeof(x));  or just  sizeof(x);" above, makes more sense as "sizeof(typeof(x));  or just  sizeof(T);"
[16:51:39] <eddyb> Peach: okay, so it's not as weak as I thought it was, uhm
[16:52:15] <eddyb> let me see...
[16:52:27] <niconii> Peach: so, is there any way to write a function that gets the size of a type, without passing in a value of that type
[16:52:40] <eddyb> niconii: note `type x`
[16:52:47] <Elaine> niconii: function genericsizeof(type x) -> size_t { return sizeof(x); }
[16:52:48] <eddyb> niconii: should be `type T` IMO
[16:52:49] <niconii> aha
[16:52:50] <Elaine> It's a type function!
[16:52:50] <eddyb> that argument is a type
[16:52:53] <niconii> missed that bit
[16:52:55] <Elaine> mm
[16:52:58] <eddyb> fn default<T>() -> T { Default::default() }
[16:52:59] <Elaine> I did too the first time
[16:53:06] <eddyb> let x: i32 = default();
[16:53:11] <eddyb> let x = default::<i32>();
[16:53:18] <eddyb> Peach: ^^ how do you encode those?
[16:53:38] <Peach> also "type" is a first class metatype, it's more than a usual template parameter,
[16:53:49] <Peach> type atype = int;   atype x = 7;  if (atype.is_convertable_to(float))
[16:53:51] <eddyb> (you managed to somehow avoid my edge cases :P)
[16:54:52] <Peach> hmmm
[16:56:28] <Elaine> One of my friends just brought in an iMac G4
[16:56:33] <Elaine> What a straaaange form factor
[16:56:37] <Elaine> But I think I like it.
[16:57:41] <eddyb> Peach: some semi-relevant crazy shit from about a month ago https://www.reddit.com/r/rust/comments/393u6x/this_week_in_rust_82/cs13rxb?context=30
[16:59:11] <Peach> eddyb: so you're asking if it's possible to make a function that returns a type based only on what it's supposed to convert to?
[16:59:22] <Peach> let x: i32 = default();
[16:59:27] <eddyb> that's what inference is
[16:59:35] <eddyb> C++ doesn't have type inference
[16:59:43] <eddyb> if there was any confusion about that
[17:00:03] <eddyb> also, it's not converting to anything, that's its actual type all the way through
[17:00:17] <Layl> huh that const fn looks interesting
[17:00:58] <eddyb> Layl: that link wasn't meant for you
[17:01:01] <eddyb> :P
[17:01:14] <Layl> I know, but it looks interesting
[17:01:38] <eddyb> and there's a half-assed attempt at encoding traits https://gist.github.com/eddyb/4aa0c4bd6060ca7facd1
[17:01:59] <eddyb> this is mostly stuff I thought about while walking home from school and being sleep-deprived
[17:02:16] <eddyb> some of it is hideously unsound and/or ambigous
[17:02:20] <Peach> eddyb: what is the type of   calling just:     default();
[17:02:22] <eddyb> the rest would work, but not by itself
[17:02:25] <Peach> in your example
[17:02:26] <Elaine> Peach: unconstrained, type error.
[17:02:29] <eddyb> Peach: it's an error
[17:03:05] <eddyb> I'm not sure you have inference if you don't already handle cases like these
[17:04:01] <eddyb> Peach: btw you never answered about cover grammar
[17:04:12] <eddyb> C++ syntax is so silly
[17:04:27] <eddyb> a bunch of things in C are hard to parse and C++ kept almost all of C
[17:04:44] <eddyb> and made them impossible to parse
[17:05:48] <eddyb> it has to do type-checking and crazy template resolution during parsing (*maybe* the lexing is context-free)
[17:05:57] <Elaine> nope, see the lexer hack.
[17:06:08] <Peach> I saw lexer hack
[17:06:08] <eddyb> not only that, but template resolution is stateful
[17:06:17] <eddyb> you can detect whether an instantiation has occurred
[17:06:27] <eddyb> i.e. parsing can mutate constexprs
[17:06:38] <Peach> I want the language to be parseable without a symbol table
[17:06:42] <Peach> and it is
[17:06:50] <eddyb> Peach: so do you have a cover grammar?
[17:07:16] <Peach> to be honest I've heard of formal grammar but not "cover grammar"
[17:07:24] <eddyb> Peach: C's variable definition syntax is terrible for parsing
[17:07:27] *** Quits: Quxxy (chatzilla@moz-efh10q.internode.on.net) (Ping timeout: 121 seconds)
[17:07:30] <Elaine> it's not a standard term afaik
[17:07:45] <Layl> it is pretty nice that Rust has a plan for deprecation of language features
[17:07:55] <Layl> it means that experimentation is possible without building up cruft
[17:07:58] <eddyb> Peach: in this case, I mean "can you encode something in your AST that you don't know whether it's a type or an expression?"
[17:08:02] <Layl> since that cruft can be cut out on a major version
[17:08:15] *** Joins: Diggsey (diggsey@moz-ftoajf.dsl.pipex.com)
[17:08:30] <Elaine> eddyb: trivially, given the previous examples.
[17:08:36] <Elaine> function foo(type x)
[17:08:46] <Elaine> foo(bar)
[17:08:48] <Elaine> what's bar?
[17:08:49] <Elaine> don't know
[17:08:52] <Elaine> but that's ok.
[17:08:58] <Elaine> types and expressions don't have to be distinct.
[17:09:06] <Elaine> especially when you have powerful type-level programming
[17:09:11] <Elaine> (consider: gallina)
[17:09:16] <eddyb> Peach: and "is parsing a type or an expression going to always result in the same number of tokens being consumed?"
[17:09:23] <eddyb> Elaine: was just making sure
[17:10:25] <eddyb> so a variable declaration is an expression followed by a name?
[17:11:27] <eddyb> Peach: why use [] for type parameters and not (), then?
[17:12:17] <eddyb> (I guess you still haven't given an encoding for the "default" example)
[17:14:28] <Peach> one sec,
[17:14:47] *** Joins: listochkin (listochkin@moz-u28j0j.interview.volia.net)
[17:15:18] <Peach> eddyb - is parsing a type or an expression going to always result in the same number of tokens being consumed   < Yes
[17:15:34] <Peach> variable declaration is also an expression followed by a name
[17:16:46] <Peach> I use [] for type parameters solely for typing convenience - You don't have to press shift to input [] and it's nearer to the {}; it's a small detail but I think it is valuable when typing lots of code - the language is designed for productivity 
[17:18:14] <Elaine> why not use [] for all application?
[17:18:22] <Elaine> in fact, why require anything at all? :)
[17:18:40] <Peach> you mean you want like   print "hello world"
[17:18:51] <Elaine> that is what I'm suggesting, yes.
[17:19:27] <Elaine> draw cube origin 0 0 0 radius 5
[17:19:41] <Peach> and the reason is - projects written in this language will be a lot of code - more than average python projects, so I want syntax to be easily parsable by a human at a glance
[17:19:44] <Elaine> function draw(type shape, type ...) { ... }
[17:19:53] <Layl> Elaine, let me just change a function call I have here to that
[17:19:57] <Layl> to show why that might not be the best of ideas
[17:20:05] <Elaine> where the function inspects the additional arguments based on the shape type
[17:20:07] <Elaine> as an example.
[17:20:25] <eddyb> oh
[17:20:45] <Peach> To answer - because all those commands/code would look like a huge wall of text and be difficult to parse by a human at a glance , that's the real reason
[17:20:45] <Elaine> The difference between "type foo" and "concrete-type foo" is really the distinction between meta-programming and not
[17:20:48] <eddyb> one dillema I had was how to encode purity
[17:20:56] <Elaine> Peach: I'm not sure I agree tbh
[17:20:56] <Peach> eddyb: my language has purity
[17:21:06] <Peach> Really Elaine ? :O
[17:21:14] <Layl> data.push DrawData::new Some Point::new 32 0 64 32 Point::new 64 0 96 32
[17:21:19] <Layl> what's going on in that call?
[17:21:34] <Elaine> Well, that's completely ambiguous, you'd need to disambiguate.
[17:21:35] <Layl> what function in that line is receiving what arguments
[17:22:07] <Layl> and if you start adding () now and then but not always, your code starts looking messier, it doesn't stay uniform in style
[17:22:34] <Elaine> Haskell gets away with it pretty well.
[17:22:54] <Layl> opinions on that differ
[17:22:59] <Elaine> True.
[17:23:04] <eddyb> so, I thought = vs => might work (= would be pure)
[17:23:05] <Elaine> I think I've made my opinion clear ;P
[17:23:15] <eddyb> but then I wondered how well the IO monad would work
[17:23:26] <Peach> Elaine: I was considering that syntax of symbols programming - Bu I decided it will be so hard to skim by a uman
[17:23:33] <Peach> *symbol-less
[17:23:37] <eddyb> so if you can write pure code with the IO monad
[17:24:04] <eddyb> you can do I/O at compile-time
[17:24:21] <eddyb> provided the compiler executes your pure+IO code
[17:24:58] <eddyb> it would be too crazy in a non-PGCFP language, though
[17:25:10] <Peach> eddyb:  and for the default example, could you tell me if this a good design idea:     I have it setup so each function returns a definite return type when given the type of its input parameters
[17:25:16] <Layl> hm, can main return a result and can that be used to return error codes
[17:25:20] <Peach> so say   div(int,float) -> float
[17:25:24] <Elaine> Layl: not in rust
[17:25:27] <eddyb> Peach: that's not enough
[17:25:32] <Peach> really?
[17:25:36] <eddyb> Layl: not *yet* in Rust
[17:25:40] <Layl> would it be an idea to let main return a Result
[17:25:52] <eddyb> there's a RFC open for it. or it's an issue on the rust-lang/rfcs repo
[17:26:01] <eddyb> opinions differ
[17:26:10] <Peach> what more do I need, and why is good to have an undecidable return type without even constraints or anything?
[17:26:19] <Elaine> Peach: the constraints come from the caller.
[17:26:31] <Peach> yes
[17:26:38] <eddyb> Peach: it means you don't have type inference
[17:27:00] <eddyb> just C++-style one-way deduction
[17:27:17] <Peach> I need an explaination, how do I upgrade to "true type inference" ?
[17:27:44] <eddyb> you probably need a book :D
[17:28:05] <Peach> and what are the flaws of "every function's return type is definite given input vars"
[17:28:38] <eddyb> Peach: there are several examples in Rust
[17:28:39] <Peach> var x = 3.0; var y = sin(45);  var d = div(x,y);
[17:28:47] <eddyb> Default::default()
[17:28:54] *** Joins: GBGamer (npm@moz-i1s.m67.56.172.IP)
[17:28:57] <eddyb> Iterator::collect
[17:28:59] <GBGamer> home again!
[17:29:04] <GBGamer> Hi all
[17:29:11] <Layl> eddyb, I guess with a bit of macro trickery you could just make main returning a Result a crate
[17:29:18] <eddyb> you can collect any iterator to any collection (with the same element type)
[17:29:44] <eddyb> Layl: eh, we can do it in the language (while cleaning up our #[start] story)
[17:29:48] <Peach> What would be the benefit for the programmer if function return types are undecidable? and any more examples of useful code that would be impossible with my current type system eddyb ?
[17:29:58] <GBGamer> eddyb: can you collect an Iter<char> -> String?
[17:29:58] <eddyb> Iterator::collect
[17:30:02] <eddyb> GBGamer: yes
[17:30:10] <GBGamer> thanks
[17:30:12] <eddyb> GBGamer: as in, any iterator over chars
[17:30:19] <eddyb> or an iterator over &str, I think
[17:30:36] <eddyb> playbot: ["foo", "bar", "baz"].iter().cloned().collect::<String>()
[17:30:37] -playbot- "foobarbaz"
[17:31:05] <GBGamer> playbot: ["foo", "bar", "baz"].iter().collect::<String>()
[17:31:06] -playbot- <anon>:9:38: 9:57 error: the trait `core::iter::FromIterator<&&str>` is not implemented for the type `collections::string::String` [E0277]
[17:31:06] -playbot- <anon>:9         ["foo", "bar", "baz"].iter().collect::<String>()
[17:31:06] -playbot- output truncated; full output at: http://bit.ly/1JqQXeU
[17:31:16] <GBGamer> ah interestinf
[17:31:19] <GBGamer> *g
[17:32:16] <eddyb> Peach: at least in the Rust compiler, the way this works is that at every function call, all the type parameters of the called function are substituted with inference variables
[17:32:39] <eddyb> so let x: i32 = default(); is let x: i32 = default::<_>();
[17:33:21] <eddyb> if we give an explicit name to that _, let's say $1, we have let x: i32 = default::<$1>();
[17:33:33] <Peach> Oh
[17:33:43] <Peach> Well that's easy to add then
[17:33:56] <eddyb> default::<T> returns T, so in that case default::<$1>() will have type $1
[17:34:15] <eddyb> $1 is unified with i32 so $1 becomes i32
[17:34:30] <eddyb> after type-checking completes, you have `let x: i32 = default::<i32>();`
[17:35:09] <eddyb> Peach: inference variables aren't *horribly* hard, but they are a bit more work than not having inference at all
[17:35:28] <eddyb> I don't know other strategies (are there other strategies? I don't know that either!)
[17:39:23] *** Joins: npm (npm@moz-92sbjt.wa.comcast.net)
[17:40:59] <eddyb> this pisses me off every time
[17:41:05] <eddyb> why doesn't gist search work?
[17:41:28] <eddyb> am I doing something wrong?
[17:43:09] *** Quits: GBGamer (npm@moz-i1s.m67.56.172.IP) (Ping timeout: 121 seconds)
[17:43:55] *** npm is now known as GBGamer
[17:51:09] <Peach> eddyb: I think I do have inference already - the language just doesn't currently have access to the inference itself
[17:59:01] *** Quits: blue_deref (blue_deref@moz-eqnijv.res.rr.com) (Quit: bbn)
[18:00:07] <eddyb> one hour until I know whether I've made it into the University of Bucharest
[18:00:14] <eddyb> which is the uni I don't want to go to anymore :P
[18:06:07] *** Quits: barosl (barosl@moz-tmp.qma.67.220.IP) (Quit: Leaving)
[18:09:21] <eddyb> GBGamer: did you ask me about DerefOwn? I linked a revised draft here https://github.com/rust-lang/rfcs/pull/1180#discussion_r34960371
[18:09:31] <eddyb> not even a draft, a rough sketch
[18:10:05] <fkaa> is naming a spir-v parsing & stuff lib "sparv" too similar?
[18:10:25] <Elaine> fkaa: too similar to what?
[18:10:29] <Elaine> why not just name it spirv? :)
[18:10:32] <fkaa> spirv / sparv
[18:10:46] <GBGamer> eddyb: can
[18:10:51] <fkaa> hm, i like sparv
[18:10:51] <GBGamer> *thank you
[18:10:59] <fkaa> "sparrow" in swedish
[18:11:01] <Elaine> ah
[18:11:19] <fkaa> always room for change i guess
[18:12:09] <fkaa> "parse_be_header" my parser is deadly :)
[18:12:42] *** Quits: hugod (user@moz-jka.jmo.24.70.IP) (Ping timeout: 121 seconds)
[18:27:42] <Layl> there's a lot of things about the language JAI that I find really fishy :/
[18:32:54] <Peach> Jai programming language
[18:32:59] <Peach> Did someone just say gamedev?
[18:33:18] *** Joins: barosl (barosl@moz-tmp.qma.67.220.IP)
[18:33:25] <Peach> @ Layl 
[18:33:31] <Layl> yep
[18:33:45] <Layl> just certain design things of Jai feel fishy to me
[18:39:34] <fkaa> anything in particular?
[18:40:08] <Layl> one thing, the context specific allocators
[18:40:23] <fkaa> same as arena allocators?
[18:40:23] <Layl> very nice idea, I love the concept of being able to control your allocators like that
[18:40:30] <Layl> but I very much don't like the way it's done
[18:40:34] <fkaa> rust has something similar iirc
[18:40:38] <Layl> feels too.. global variable-y
[18:46:20] <GBGamer> Layl: agreed, i was watching that episode and i was very weirded out by the idea...
[18:48:32] <GBGamer> it didnt feel very nice
[18:49:17] <Elaine> It's a good use of dynamic scope I think.
[18:50:00] <GBGamer> I'd prefer it if it were compile time, like a generic over allocator
[18:50:16] <Elaine> But allocator choice isn't always a static decision
[18:50:29] <Elaine> You want your code to be able to control where the libraries it calls allocates its data.
[18:51:15] <GBGamer> exactly
[18:52:06] <Layl> what would be the ideal solution is if you somehow could treat the heap as another resource and receive it as parameter, but the problem would be that that would require you passing heaps along everywhere
[18:52:35] <GBGamer> I would prefer it if (and I'm going to use rust syntax), every allocating function is defined like fn allocating<fn(size) -> void *>()
[18:53:06] <GBGamer> so it'd be generic over allocator, but not require you to pass the allocator
[18:53:36] <XMPPwocky> GBGamer: but you also need to free
[18:54:30] <GBGamer> XMPPwocky: right, okay, then fn allocating<F: Allocator>() where Allocator has a malloc and a free
[18:54:35] <GBGamer> and a realloc
[18:54:40] <GBGamer> and whatever else
[18:54:46] <Elaine> You need an instance of the allocator for arenas.
[18:54:50] <Elaine> Not all allocators are stateless.
[18:55:11] <GBGamer> hmm, yeah
[18:55:20] <GBGamer> this thought is not fully thought out
[18:55:31] <Elaine> indeed not :P
[18:55:31] <GBGamer> I'll need to think it out and come back
[18:55:41] <Layl> Elaine, how can an allocator be stateless at all?
[18:55:51] <Elaine> Layl: well, malloc has implicit global or thread-local state.
[18:55:56] <GBGamer> Layl: sbrk?
[18:56:00] <Elaine> bump allocators are stateless though
[18:56:03] <Elaine> you just can't free
[18:56:05] <Elaine> lol
[18:56:09] <Layl> that's still not stateless
[18:56:14] <dw> the current allocation offset is state
[18:56:16] <Elaine> ah right
[18:56:29] *** Joins: hugod (user@moz-jka.jmo.24.70.IP)
[18:56:57] <GBGamer> "calling sbrk with an increment of 0 can be used to find the current program break"
[18:57:17] <Elaine> Layl: yeah it's bogus.
[18:57:21] <XMPPwocky> i refuse to pronounce sbrk/brk as anything other than "bork"
[18:57:37] <GBGamer> I say berk or sberk
[18:57:39] <Elaine> Layl: but what I really meant is that the state isn't shared with other instances of the allocator.
[19:00:22] <Peach> guys help me find a cheap USB SSD hard drive
[19:00:37] <Layl> isn't "cheap SSD" an oxymoron
[19:00:55] <Elaine> Peach: http://www.amazon.com/PNY-Turbo-64GB-Flash-Drive/dp/B00FDUHDAC/ref=sr_1_2?ie=UTF8&qid=1437332440&sr=8-2&keywords=64+gig+flash+drive
[19:01:17] <Peach> Oh but isn't that Not SSD Elaine ?
[19:01:27] <Elaine> Sure it is.
[19:01:44] <GBGamer> hey, fun fact
[19:02:01] <GBGamer> A C implementation requires a 64 bit integer type
[19:02:20] <GBGamer> (at least a 64 bit integer type)
[19:02:21] <Elaine> it's all nand.
[19:02:25] <Peach> Oh
[19:02:30] <Peach> So wait
[19:02:52] <Elaine> Alternatively you could get a "real" SSD and a SATA <-> USB
[19:02:54] <Peach> how come USB is usually so slow, but SSD hard drives are called "fast"
[19:03:05] <Elaine> Peach: bus speed.
[19:03:06] <Peach> USB drives
[19:03:07] <Peach> OH
[19:03:11] <Elaine> which USB 3.0 alleviates mostly.
[19:04:24] <Elaine> also cheap USB drives are usually crap
[19:04:39] <Peach> USB 3.0 is almost as fast as native SATA stuff?
[19:05:01] <GBGamer> 5Gb/s
[19:05:31] <Elaine> The bus *can* be.
[19:05:36] <Elaine> But fast SSDs don't go over SATA.
[19:05:41] <Elaine> They go over the PCIe bus.
[19:05:55] <GBGamer> versus 16 Gb/s
[19:06:30] <Elaine> What SATA controller does 16Gbps?
[19:06:43] <Elaine> To my knowledge SATA 3 only does 6Gbps
[19:07:01] *** Quits: listochkin (listochkin@moz-u28j0j.interview.volia.net) (Quit: My Mac has gone to sleep. ZZZzzz…)
[19:07:23] <GBGamer> 3.2
[19:07:44] <Elaine> Ah I see.
[19:07:50] <GBGamer> and PCIe can do 30 GB/s
[19:07:58] <GBGamer> v4, x16
[19:08:12] <GBGamer> (which is 240Gb/s
[19:08:13] <GBGamer> )
[19:08:41] <Peach> So I have have an external solid state disk over USB 2.0 it'll still be the same speed as a 5400rpm disk on USB 2.0?
[19:08:53] <Peach> *so if I have
[19:09:31] <Elaine> Very likely.
[19:11:34] <GBGamer> actually, correction: USB 3.1 maxes out at 10Gb/s
[19:12:15] *** Quits: dustinm` (dustinm@moz-es6jb7.ip-167-114-152.net) (Ping timeout: 121 seconds)
[19:13:38] *** Joins: listochkin (listochkin@moz-u28j0j.interview.volia.net)
[19:17:20] <Peach> Elaine: what's your opinion on:  http://www.apple.com/shop/buy-mac/macbook/space-gray-512gb  ?
[19:17:47] <Peach> from a broad perspective of computers
[19:17:48] <Elaine> I'm worried about the keyboard and I've seen bad reviews.
[19:17:52] <Peach> Oh?
[19:17:52] <Elaine> Would wait for the next revision.
[19:18:26] <Peach> Elaine - what do you think about the trend of "premium for thinness and less power"
[19:18:46] <Elaine> Seems legit.
[19:18:56] <Peach> do you like that trend?
[19:20:03] <Elaine> Well I mean...
[19:20:12] <Elaine> It's just economics, most of the time. Not much opinion to it.
[19:21:01] <Elaine> http://www.marco.org/2015/05/19/mistake-one
[19:22:34] <Elaine> I'm going to build a novena-alike around a lowRISC SoC.
[19:22:39] <Elaine> once they release.
[19:22:53] *** Quits: Rym (uid91135@moz-n2i7qm.charlton.irccloud.com) (Quit: Connection closed for inactivity)
[19:27:54] <Peach> it seems like laptops are basically going toward "smartphone with keyboard"
[19:28:07] <Elaine> In what ways?
[19:28:20] <Peach> fanless, thin, less power
[19:28:30] <Elaine> Well, what's wrong with that :)
[19:28:52] <Peach> I like raw GPU power and fast CPUs and lots of hard drive space
[19:28:59] <Elaine> There's always thinkpads for that.
[19:29:07] <Elaine> The "mobile workstation" won't go away.
[19:29:08] <Tiffany> those first two things generate a lot of heat
[19:29:20] <Peach> Honestly,
[19:29:25] <Tiffany> it's not very portable if you can't put it on your lap or on your bed without getting burned
[19:29:26] <Elaine> On the other hand, thin clients aren't such a bad thing either.
[19:29:27] <XMPPwocky> everything's going towards locked down smartphones, glorified thin clients for the web
[19:29:29] <Peach> It's fine as long as it's faster than my current computer
[19:29:35] <fkaa> Tiffany: free house heating!
[19:29:39] <fkaa> well, "free"
[19:29:51] <XMPPwocky> rms was right
[19:30:15] <Peach> the new thinness trend isn't so bad since mobile stuff is getting decently fast
[19:30:26] <Peach> But I don't like how hard drive space is often so limited
[19:30:33] <Peach> I expected 1TB to be standard
[19:30:34] <Tiffany> the thinness trend isn't very new
[19:30:51] <Tiffany> I have a laptop from 1998 or so which is 5 centimeters thick
[19:31:06] <Elaine> Peach: Most people don't use, need, or want that much storage, it doesn't make economical sense to have that be the standard.
[19:31:08] <Tiffany> and it weighs about 5 kilograms
[19:31:55] <Tiffany> earlier laptops often had handles so you could carry them like a very heavy briefcase
[19:32:12] <XMPPwocky> i could get either 1TB of spinny-metal-bitbucket or 256GB of SSD, and i went w/ the ssd
[19:32:31] <XMPPwocky> if you don't have movies saved (everybody's streaming now), it's darn hard to fill 256GB
[19:32:43] <Elaine> or a large game library
[19:32:52] <Peach> I ordered a new iPod touch with A8 processor
[19:32:58] <XMPPwocky> Elaine: yeah, that was my issue
[19:33:01] <Elaine> same here
[19:33:03] <Tiffany> yeah, games and video are the real space eaters
[19:33:07] <Peach> It was the most impulse buy I ever made
[19:33:11] <Elaine> I had to dump most of my steam library to make space for more source trees
[19:33:30] <Tiffany> I have a 512GB rotating disk
[19:33:34] <Peach> I don't know if I should have ordered the largest capped out size for it
[19:33:50] <Elaine> my laptop has a 256GB SSD.
[19:33:51] <Peach> cause I'm only using it for programming dev
[19:34:08] <Tiffany> if I get another laptop I'm definitely going to get an SSD
[19:34:25] <Elaine> my desktop, on the other hand... 64GB SSD for the OS, with various large hard drives for games and source code.
[19:34:25] <Tiffany> steam and video can go on an external HDD if needed
[19:35:18] <Peach> Anyone have a problem with tech impulse buys?
[19:35:27] <Peach> Cause I totally buy stuff and rarely use it
[19:35:46] <Tiffany> I impulse bought a steam game once
[19:35:52] <Peach> So right now I just ordered a $199 system with A8 chip
[19:35:53] <Tiffany> since it was on sale for really cheap
[19:35:54] <Elaine> I don't have problems with impulse buys
[19:36:10] <Elaine> I don't have enough money to afford to have that luxury
[19:36:15] <Peach> Only 16GB iPod touch with A8 chip
[19:36:20] <Tiffany> yeah same elaine
[19:36:42] <Peach> Was I wise to not spend more on storage since I'm only going to use it for game dev testing?
[19:36:50] <Tiffany> amazon's one-click buy thing was really terrifying until I figured out how it works
[19:37:14] <Elaine> I haven't used it, how does it work?
[19:37:30] <Tiffany> it uses your primary payment method (whatever it is), it does indeed subtract from gift cards, and you have a 30 minute grace period where you can cancel an order, even though any digital orders go through immediately
[19:37:43] <Tiffany> so you can click a button to buy a book on your kindle, and undo it if you pressed the button by accident
[19:38:30] <Elaine> mm
[19:38:58] <Tiffany> which is pretty convenient when you're settling down for some reading time and forgot to buy a new book to read
[19:39:19] <Peach> I Impulse buy anything that is programmable and has graphics
[19:39:22] <Tiffany> kindle books being $3-$10 is nice as well
[19:39:27] <Elaine> lol
[19:40:24] <Elaine> It's absurd that I can't figure out how to operate facebook yet can write programs that simulate circuits.
[19:40:37] <Elaine> What a strange thing, the web.
[19:40:40] <Tiffany> nah
[19:40:46] <Peach> IMPULSE BUY
[19:40:48] <Peach> <3
[19:44:38] <eddyb> Elaine: what bit about facebook?
[19:44:48] <Elaine> various profile settings etc
[19:44:53] <eddyb> also, don't be so hard on yourself, it's made by PHP developers
[19:44:59] <Elaine> also its privacy model confuses me now.
[19:45:11] <eddyb> oh that stuff might be twisted on purpose :P
[19:45:27] <Elaine> it's hard to understand what transitive relationships allow non-friends to see my content.
[19:45:33] <Tiffany> most people don't really bother with privacy settings on facebook
[19:45:59] <Peach> Guys
[19:46:06] <Peach> I need raw power in a laptop
[19:46:11] <Peach> I don't care how bulky
[19:46:19] <Peach> I want cheap and lastest OpenGL features
[19:46:28] <eddyb> Elaine: this is what happens when people rediscover graph theory by accident
[19:47:29] <eddyb> which reminds me, I don't think I ever figured out why they used "Graph API" as a name
[19:47:57] <ytain>  Peach look for Asus ROG laptops
[19:52:05] <Elaine> Peach: how cheap is cheap?
[19:52:28] <Peach> OpenGL 4.0+ gpu for less than 700
[19:53:07] <XMPPwocky> lenovo y40 can do that
[19:53:51] <Tiffany> ivybridge and newer integrated graphics will do GL 4.1+
[19:54:10] <XMPPwocky> Tiffany: really? my haswell only seems to show up as GL3
[19:54:15] <Elaine> On what OS?
[19:54:20] <Tiffany> xmppwocky: that's because mesa still only supports GL3
[19:54:23] <XMPPwocky> inux
[19:54:24] <XMPPwocky> ah
[19:54:28] <Elaine> there you go :P
[19:55:12] *** Joins: dustinm` (dustinm@moz-1c1j82.fu2o.sj0n.5300.2607.IP)
[20:16:00] *** Joins: eddyb_ (eddyb@moz-iut.q07.26.188.IP)
[20:17:31] *** Quits: eddyb (eddyb@moz-042.8f9.121.86.IP) (Ping timeout: 121 seconds)
[20:27:33] <GBGamer> could anyone help me with gh-pages?
[20:28:52] <Elaine> what's up?
[20:29:29] <GBGamer> my docs do not appear for github.com/GBGamer/Algae
[20:29:40] <GBGamer> at gbgamer.github.io/Algae
[20:30:08] <GBGamer> wait oh wtf
[20:30:23] <GBGamer> nvm, I just figured it out
[20:30:23] <Elaine> Looks like it redirects with the wrong case to me.
[20:30:29] <GBGamer> yep
[20:30:29] <Elaine> in the index.
[20:31:25] <GBGamer> lets see if I can fix that
[20:34:02] *** Joins: madmalik (uid13697@moz-lfin5p.brockwell.irccloud.com)
[20:40:08] <GBGamer> Elaine: why did you stop working on Crenshaw?
[20:42:20] <Elaine> excuse me?
[20:42:27] <Elaine> OH
[20:42:45] <Elaine> I got bored of it, it was underneath my knowledge level.
[20:43:02] <GBGamer> ah
[20:45:54] <fkaa> oh man
[20:46:05] <fkaa> i've completely missed the spir-v session
[20:46:19] <fkaa> 1 hour of goodieness \o/
[20:46:36] <fkaa> what's a good license?
[20:46:42] <fkaa> if i don't care what people do with my code
[20:47:00] <Elaine> Boost Software License
[20:47:10] <scott> I like MIT and ISC
[20:47:13] <Elaine> ISC is good too.
[20:47:18] <wrl> wtfpl tbh
[20:47:18] <Elaine> MIT has attribution requirements.
[20:47:26] <GBGamer> cc-0
[20:47:33] <fkaa> zlib/png?
[20:47:34] <GBGamer> is always an option
[20:47:55] <Peach> OH
[20:47:59] <Elaine> GBGamer: Creative Commons advises against using any of their licenses (including CC0) for software.
[20:48:01] <Peach> Nvidia shield tablet <3
[20:48:16] <Peach> It has the fastest ultra mobile GPU available
[20:48:30] <GBGamer> Elaine: no, CC0 is useful for software, iirc
[20:48:33] <Elaine> Peach: I have one, it's rather bad overall, would not recommend.
[20:48:40] <Peach> :'(
[20:48:47] <Peach> Even for programming Elaine ?
[20:49:00] <Elaine> Peach: What, do you want to code on it?
[20:49:05] <Elaine> GBGamer: Oh, they updated it: http://creativecommons.org/weblog/entry/27081
[20:49:13] <Peach> testing programs on the device
[20:49:19] <Peach> GPU experimenting
[20:49:25] <Peach> shading languages
[20:49:34] <Peach> CUDA/OpenCL stuff
[20:49:39] <wrl> Elaine: yeah it was originally not recommended for software (and i was using unlicense.org for my stuff at the time) but they fixed it up
[20:49:44] <fkaa> you could get a jetkins for that Peach 
[20:50:00] <Elaine> Peach: Ok, that'd work, but it's not representative of actual end-user devices.
[20:50:02] <fkaa> err
[20:50:02] <Elaine> It's too powerful.
[20:50:03] <fkaa> jetson*
[20:50:13] <fkaa> Peach: https://developer.nvidia.com/jetson-tk1
[20:51:52] <Elaine> I'm a big fan of the BSL.
[20:52:11] <Elaine> ISC is great though too
[20:52:28] <Peach> It's "too powerful" : O
[20:52:37] <Elaine> cat: http://i.imgur.com/Ac3EEuY.jpg
[20:52:48] <Peach> Well for my own graphics programming amusement then
[20:52:50] <Peach> WAIT
[20:52:56] <ytain> Peach you could buy the wifi version of Nvidia Shield Tablet or Nvidia Shield Android TV, they have CUDA/OpenGL 4.5 besides Open GL ES 3.1
[20:52:57] <fkaa> Elaine: bear with whiskers
[20:52:57] *** Joins: Rym (uid91135@moz-n2i7qm.charlton.irccloud.com)
[20:52:58] <Peach> Is android SDK ugly to program for
[20:53:02] <Elaine> Peach: yes.
[20:53:10] <Peach> :'(
[20:54:01] <ytain> Well you don't really have to use the Android SDSK for java part of programming
[20:54:10] <ytain> only the native part
[20:54:22] <ytain> for accessing the touch/sensors etc and the native glue
[20:56:31] <fkaa> the zlib/png seems rather short and to the point. unsure about the "must rename" part
[20:56:57] <fkaa> well, "Altered source versions must be plainly marked as such, and must not be misrepresented as being the original software."
[20:57:50] <Elaine> if you're going to use zlib/png you might as well use MIT/Expat or ISC.
[20:58:12] <Peach> Wait, who is doing source code license?
[20:58:22] <fkaa> isn't expat the word for americans who live abroad?
[20:58:25] <Peach> Go with Public Domain if possible
[20:58:45] <Elaine> fkaa: Expat is an XML parser.
[21:01:22] <fkaa> MIT looks cool
[21:01:39] <Elaine> The BSL is good because many organizations use Boost and thus have the license approved by legal and have no qualms using it.
[21:02:32] <Elaine> I think MIT etc are annoying since the require distributing the copyright notice in binary distributinos.
[21:02:38] <Peach> I hope apple never tapers the rest of the macbook line
[21:02:51] <Peach> I think the taper in the Air and Macbook 2015 is ugly
[21:03:08] <Peach> I'd totally love longer battery life from an untappered design
[21:04:29] <Astraea> But how else is apple going to win the thinness war that no one else is participating in anymore?
[21:04:57] <Peach> Thiness should only count the thickest part
[21:05:16] <Peach> Plus with the newest Macbook 2015, the keyboard suffered from the tapper
[21:05:40] <Peach> If they just had it untappered, they could have put nicer keys
[21:06:52] *** Quits: GBGamer (npm@moz-92sbjt.wa.comcast.net) (Quit: AndroIRC - Android IRC Client ( http://www.androirc.com ))
[21:07:11] *** Joins: npm (npm@moz-92sbjt.wa.comcast.net)
[21:07:22] *** npm is now known as GBGamer
[21:07:38] <Peach> So hey - educate me - How does C++11 not have type inference
[21:07:44] <Peach> Or "true type inference"
[21:07:54] <Peach> and what would true type inference in C++ look like?
[21:08:11] <Astraea> A new language
[21:08:41] <Peach> I need an example with code snippets
[21:08:50] <Elaine> https://akrzemi1.wordpress.com/2012/03/27/gotchas-of-type-inference/
[21:08:53] <fkaa> Elaine: the legal world is annoying :(
[21:09:01] <Astraea> Rust-Lang.org
[21:09:02] <fkaa> wish i could have my own personal lawyer
[21:09:05] <Elaine> It's not inference in the traditional use of the term.
[21:09:21] <Elaine> Since the type must be fully specified.
[21:09:39] <Elaine> An example of type inference would be able to say `auto foo = vector();`
[21:09:52] <Elaine> And have it figure out the template parameter of the vector from its later use.
[21:12:01] <Elaine> http://www.codecommit.com/blog/scala/what-is-hindley-milner-and-why-is-it-cool is a quick introduction to the "classic" type inference algorithm.
[21:12:30] <Elaine> http://fsharpforfunandprofit.com/posts/type-inference/ explores it more deeply in the context of F#
[21:13:26] <Elaine> The C++ spec calls it "type deduction" which is more accurate.
[21:18:01] <Elaine> You know, I want to see a physical device that supports every feature of USB HID.
[21:31:31] *** Quits: ytain (ytain@moz-u0rb5h.dsl.teksavvy.com) (Quit: Textual IRC Client: www.textualapp.com)
[21:40:26] <Peach> Elaine: you're so super useful, do you have like all these subjects bookmarked
[21:40:53] <Elaine> no, I don't use bookmarks.
[21:41:01] <Elaine> I just have an extensive browser history :P
[21:41:07] <Peach> oh!
[21:41:12] <Peach> haha nice
[21:49:12] <Peach> so I guess I do have type inference
[21:49:22] <Peach> cause my compiler can do generic min
[21:49:29] <Peach> and infer the return type
[21:59:05] <eddyb_> Peach: if the type comes from the arguments, it's not necessarily inference
[21:59:20] <eddyb_> Peach: check this out:
[21:59:43] <eddyb_> playbot: fn min<T: Ord>(x: T, y: T) -> T { if x < y { x } else { y } } min(0, 1)
[21:59:44] -playbot- 0
[22:00:01] <eddyb_> playbot: fn min<T: Ord>(x: T, y: T) -> T { if x < y { x } else { y } } let x = min(Default::default(), Default::default()); [1, x]
[22:00:03] -playbot- [1, 0]
[22:00:41] *** Joins: Binero (Binero@moz-33frsg.tp6s.jp58.a03f.2a02.IP)
[22:00:47] <eddyb_> Peach: ^^ it sets the type used in both Default::default() calls and min from the fact that x is used in an array alongside an integer (so x has to be the same type as that integer)
[22:00:58] <eddyb_> Peach: that's inference :P
[22:01:16] <eddyb_> oh Elaine said a bunch a things already
[22:03:09] <eddyb_> anyways, I've been admitted to unibuc's faculty of maths and CS (the CS section)
[22:03:18] <Elaine> eddyb_: congratulations :P
[22:03:29] <eddyb_> thanks. but I have harder exams for where I actually want to go
[22:03:45] <eddyb_> and I haven't practiced enough
[22:03:45] <Elaine> mm
[22:05:21] <Binero> what's a good name for an interface component? 
[22:05:27] <Binero> Say an individual set of buttons on a page 
[22:05:40] <Elaine> Widget? Frame? Depends...
[22:05:46] <Binero> Widget is good
[22:05:50] <Binero> yeah
[22:05:54] <eddyb_> or, you know... Component :P
[22:06:00] <Binero> :p
[22:13:45] *** Joins: blueridanus (Mibbit@moz-k63.43p.20.201.IP)
[22:24:48] *** Joins: fkaa_ (fkaa@moz-aoro5s.cust.tele2.se)
[22:27:57] *** Quits: fkaa (fkaa@moz-501od2.business.telia.com) (Ping timeout: 121 seconds)
[22:28:52] <Astraea> ugh
[22:29:02] <Astraea> work is going to make my hair turn gray
[22:34:24] <Astraea> I mean... if genetics wasn't already working on it
[22:40:44] *** Joins: blue_deref (blue_deref@moz-eqnijv.res.rr.com)
[23:13:40] *** Quits: listochkin (listochkin@moz-u28j0j.interview.volia.net) (Quit: My Mac has gone to sleep. ZZZzzz…)
[23:17:22] <Peach> what is the type of Default::default()  ?
[23:18:15] <Peach> "generic type"
[23:18:53] <Peach> Oh
[23:18:54] <Peach> wow
[23:19:02] <Peach> Type inference is tooooo "infery"
[23:19:19] <Peach> That would be really confusing for a human to understand code
[23:19:50] <Peach> cause you can't deduce type at variable declaration, so ......
[23:20:21] <Peach> and the compiler would have to do extra work
[23:20:27] <Peach> How fast does Rust compile?
[23:23:32] <Peach> eddyb_:  ok so that type inference is very extensive, but doesn't the compiler have to work harder and the programmer has to read more to reason about code if a type is conditional on how it gets used?
[23:24:12] <Peach> playbot:   fn min<T: Ord>(x: T, y: T) -> T { if x < y { x } else { y } } let x = min(Default::default(), Default::default()); [1.0, x]
[23:24:13] -playbot- <anon>:9:81: 9:84 error: the trait `core::cmp::Ord` is not implemented for the type `_` [E0277]
[23:24:13] -playbot- <anon>:9           fn min<T: Ord>(x: T, y: T) -> T { if x < y { x } else { y } } let x = min(Default::default(), Default::default()); [1.0, x]
[23:24:13] -playbot- output truncated; full output at: http://bit.ly/1RHXvjg
[23:25:24] <Peach> playbot: fn min<T: Ord>(x: T, y: T) -> T { if x < y { x } else { y } } let x = min(Default::default(), Default::default()); [1, x]
[23:25:26] -playbot- [1, 0]
[23:25:31] <Peach> playbot: fn min<T: Ord>(x: T, y: T) -> T { if x < y { x } else { y } } let x = min(Default::default(), Default::default()); [1.0, x]
[23:25:32] -playbot- <anon>:9:79: 9:82 error: the trait `core::cmp::Ord` is not implemented for the type `_` [E0277]
[23:25:32] -playbot- <anon>:9         fn min<T: Ord>(x: T, y: T) -> T { if x < y { x } else { y } } let x = min(Default::default(), Default::default()); [1.0, x]
[23:25:32] -playbot- output truncated; full output at: http://bit.ly/1OglFLw
[23:26:15] *** Quits: madmalik (uid13697@moz-lfin5p.brockwell.irccloud.com) (Quit: Connection closed for inactivity)
[23:26:55] <Peach> Ok eddyb_ , it even though Hindley-Milner is theoretically cool, it looks to complicate code in practice - unless you can show me what I'm doing wrong
[23:27:27] <scott> Peach: Floats don't impl Ord
[23:28:39] <scott> You can change the bound to PartialOrd, but then it will behave oddly with NaN.
[23:29:10] <scott> (By oddly I mean min(nan, x) will not be the same as min(x, nan).)
[23:29:27] <Peach> playbot: fn min<T: PartialOrd>(x: T, y: T) -> T { if x < y { x } else { y } } let x = min(Default::default(), Default::default()); [1, x]
[23:29:28] -playbot- [1, 0]
[23:29:34] <Peach> playbot: fn min<T: PartialOrd>(x: T, y: T) -> T { if x < y { x } else { y } } let x = min(Default::default(), Default::default()); [1.0, x]
[23:29:35] -playbot- [1, 0]
[23:30:05] <Peach> Uh... so what is the typeof x in that case eddyb_  ?
[23:30:28] <Peach> int, double(f64), or float(f32)?
[23:31:27] <mbrubeck> f64 (the default type for unconstrained floating-point literals in Rust)
[23:31:27] <scott> Peach: f64, since it's the default type for float literals
[23:31:52] <scott> In the example with 1 instead of 1.0 it's i32
[23:32:34] <Peach> Wow, uh so type inference that is that "infer-y" just seems like a major candidate for human error and difficult code reviews
[23:33:01] <Peach> I am yet to be sold on full context aware type inference :|
[23:33:22] <Peach> playbot: [0,1,2]
[23:33:23] -playbot- [0, 1, 2]
[23:33:27] *** Joins: dpc (dpc@moz-t6gr4b.ca.comcast.net)
[23:33:43] <Peach> playbot: [0, "text", 1]
[23:33:44] -playbot- <anon>:9:13: 9:19 error: mismatched types:
[23:33:44] -playbot-  expected `_`,
[23:33:44] -playbot- output truncated; full output at: http://bit.ly/1RHYwI4
[23:34:44] <mbrubeck> Peach: Type inference is not an exotic feature, or anything. It's in most modern statically typed languages... C++, C#, D, F#, Haskell, ML, Rust, Swift...
[23:34:46] <scott> Peach: Rust made some choices to keep type inference more manageable, like requiring complete concrete types on top leve items
[23:34:52] <scott> level*
[23:35:07] <scott> Peach: And within a function it's the programmer'
[23:35:18] <scott> programmer's choice whether to include type annotations.
[23:35:30] <scott> I include them whenever it's not clear.
[23:36:04] <Peach> mbrubeck: No I'm talking about type inference where the type of variable can be unknown at declaration, and it's type changes depending on how its used
[23:36:14] <mbrubeck> Peach: So am I.
[23:36:47] <mbrubeck> well, C++'s version is kind of limited, last I looked
[23:36:52] <Peach> Well C++ doesn't have this form of type inference - it requires type to be known at declaration of a variable
[23:36:59] <Peach> yeah
[23:37:07] <fkaa_> i think macros can help clean up my code, do i need to have #[macro_use] on my crate even if it's only used internally?
[23:37:24] <fkaa_> eh, wrong channel i guess
[23:37:38] <Peach> Man, is the point of programming to get work done or have fancy puzzles for the programmer to see :P
[23:38:45] <scott> Type inference helps me get work done more quickly.
[23:39:13] <Peach> Which level of type inference are you talking about though scott?
[23:39:23] <Peach> declare and infer at later use inferecne?
[23:39:27] <scott> The kind in Rust/Haskell/ML/etc
[23:39:40] <scott> C++ type deduction also helps a bit but it's limited.
[23:40:33] <Peach> playbot: let x = Default::default(); std::num::sqrt(x);
[23:40:34] -playbot- <anon>:9:37: 9:51 error: unresolved name `std::num::sqrt`
[23:40:34] -playbot- <anon>:9         let x = Default::default(); std::num::sqrt(x);
[23:40:34] -playbot- output truncated; full output at: http://bit.ly/1OgmIuV
[23:40:44] <Peach> how do I sqrt in rust?
[23:41:20] <Peach> playbot:   use std::num::sqrt;  playbot: let x = Default::default();  sqrt(x);
[23:41:21] -playbot- <anon>:9:39: 9:40 error: expected one of `!`, `.`, `::`, `;`, `{`, `}`, or an operator, found `:`
[23:41:21] -playbot- <anon>:9           use std::num::sqrt;  playbot: let x = Default::default();  sqrt(x);
[23:41:21] -playbot- output truncated; full output at: http://bit.ly/1RHZcwV
[23:41:35] <blueridanus> Isn't sqrt a f32/f64 function?
[23:41:43] <scott> playbot: 1.0f64.sqrt()
[23:41:44] -playbot- 1
[23:41:51] <blueridanus> ^
[23:42:04] *** Quits: rovar_ (rovar@moz-6iq.47m.88.38.IP) (Ping timeout: 121 seconds)
[23:42:04] <Peach> playbot: let x = Default::default(); x.sqrt();
[23:42:04] -playbot- <anon>:9:37: 9:45 error: the type of this value must be known in this context
[23:42:05] -playbot- <anon>:9         let x = Default::default(); x.sqrt();
[23:42:05] -playbot- output truncated; full output at: http://bit.ly/1RHZiVi
[23:42:27] <Peach> Yeah ugly error :(
[23:43:09] <Peach> I need to see a lot more edge cases
[23:44:28] <Peach> but basically allowing code where you declare variable storage but  "it doesn't have a type", I need concrete more beautiful examples of why I neeeeeed
[23:44:30] <Peach> it
[23:44:42] <Peach> Lemme look at eddyb_ 's sort / iterate example again....
[23:45:29] <scott> let v = vec![String::from("foo"), String::from("bar")]; // why would I want to write out the type when it's obvious?
[23:47:21] *** Quits: Binero (Binero@moz-33frsg.tp6s.jp58.a03f.2a02.IP) (Quit: Leaving)
[23:48:14] <mbrubeck> That can be done in C# with `var` or C++ with `auto`, to be fair.
[23:49:06] <mbrubeck> On the other hand, stuff like `let mut v = Vec::new(); v.push("hello");` is handy and requires more complete inference.
[23:50:08] *** Quits: GBGamer (npm@moz-92sbjt.wa.comcast.net) (Ping timeout: 121 seconds)
[23:51:23] <Peach> scott:  wait, I'm confused
[23:51:56] <Peach> Ok so we're talking about 2 types of type inference - "basic inference" and "specified later infererence"
[23:52:25] <Peach> var x = ["apple", "butter", "cinnamon"];
[23:52:32] <Peach> that's "basic infererence"
[23:53:00] <Peach> function add(x,y) { return x+y }  < still "basic inference" 
[23:53:42] <Peach> var x; add(1,x);     // "specified later inference"
[23:53:56] <Peach> x would be "0" of type int
[23:54:17] <Peach> But the "specified later inference is the kind of inference I don't want to add by design
[23:54:26] <Peach> cause I think it would be a hinderence to understanding code
[23:55:36] <Peach> I'm going with - functions can be generic typeless functions, but upon the declaration of an actual variable with storage, the type must be resolved from the expression used to initialize the variable
[23:57:08] <Peach> scott: so my real question is - why is "specified later" inference useful?
[23:57:36] <scott> mbrubeck gave a good example above
[23:58:59] <Peach> scott: but from a human understanding standpoint - what about:    let mut v = Vec::new(); v.push("hello");  v.push(5);   ?
[23:59:29] <Peach> You would have to scan the code to find out the type of values v supports
[23:59:37] <scott> Peach: What about it? It gives a pretty clear error message.

[00:00:07] *** Quits: echristo (echristo@CFC3C6C3.D6CCE4AE.77834EAA.IP) (Quit: echristo)
[00:01:00] *** Quits: ssbr_ (ssbr@moz-6A5A684C.wireless.utoronto.ca) (Ping timeout)
[00:01:53] *** Quits: ssbr (scorchsabe@A9D9D38C.B6F034AC.72A31D6.IP) (Ping timeout)
[00:02:07] *** Joins: mib_mmst8j (Mibbit@DF3ED29D.52D01038.50A7E6A6.IP)
[00:02:47] <strcat> graydon: could the string interner be something in libstd?
[00:03:40] <graydon> oh, probably
[00:03:46] <graydon> I'm trying to be as surgical as possible today
[00:03:47] <graydon> but yeah
[00:03:55] *** Joins: ssbr (scorchsabe@A9D9D38C.B6F034AC.72A31D6.IP)
[00:03:58] <graydon> it's really trivial
[00:04:32] <strcat> well so are deque and smallintmap :)
[00:04:37] *** Quits: mib_mmst8j (Mibbit@DF3ED29D.52D01038.50A7E6A6.IP) (Quit: http://www.mibbit.com ajax IRC Client)
[00:06:00] <tjc> graydon: does --test enable #[bench] things? there doesn't seem to be a --bench flag
[00:06:14] <graydon> --test when compiling will compile the #[bench] things, yes
[00:06:21] <graydon> --bench is passed to the _runner_ to run the benchmarks
[00:06:23] <tjc> thx
[00:07:13] *** Quits: rusti (rusti@moz-54F7FD49.cpe.net.cable.rogers.com) (Client exited)
[00:08:46] *** Quits: ssbr (scorchsabe@A9D9D38C.B6F034AC.72A31D6.IP) (Ping timeout)
[00:08:49] *** Quits: brson (brson@2557E599.66715431.D25A875A.IP) (Quit: leaving)
[00:09:26] *** Joins: rusti (rusti@moz-54F7FD49.cpe.net.cable.rogers.com)
[00:09:37] <strcat> rusti: 5
[00:09:39] <rusti> 5
[00:09:58] <strcat> rusti: core::run::run_program("pacman", [~"-Q", ~"rust-incoming-git"]);
[00:09:58] *** Quits: Yurume (yurume@AC58A8CE.8A059B47.E313B915.IP) (Ping timeout)
[00:09:59] <rusti> rust-incoming-git release.0.6.1156.gd546493-1
[00:10:58] *** Joins: ssbr (scorchsabe@A9D9D38C.B6F034AC.72A31D6.IP)
[00:15:54] *** Quits: ssbr (scorchsabe@A9D9D38C.B6F034AC.72A31D6.IP) (Ping timeout)
[00:16:18] <graydon> oh for goodness sake
[00:16:29] <graydon> yay mutability
[00:16:49] <strcat> oh
[00:17:00] <strcat> it seems that LLVM actually considers immutable pointers to be non-aliasing
[00:17:22] <strcat> The NoAlias response may be used when there is never an immediate dependence between any memory reference based on one pointer and any memory reference based the other. The most obvious example is when the two pointers point to non-overlapping memory ranges. Another is when the two pointers are only ever used for reading memory.
[00:17:52] <Luqman> vgman 
[00:21:45] <graydon> huh. well, it _almost_ builds!
[00:21:49] <strcat> so assuming no broken unsafe code, & and &mut seem like they can always give the NoAlias response
[00:21:53] *** Joins: ssbr (scorchsabe@A9D9D38C.B6F034AC.72A31D6.IP)
[00:22:17] <strcat> &const can't
[00:22:41] <strcat> the concepts map exactly to LLVM's alias analysis ;p
[00:23:39] <strcat> (for Const objects)
[00:24:34] *** Quits: jorendorff (jorendorff@moz-2F32ACA3.hsd1.tn.comcast.net) (Quit: jorendorff)
[00:25:14] *** Quits: graydon (Adium@A5087023.2354C43D.D8E68FF6.IP) (Quit: Leaving.)
[00:25:17] *** Quits: sully (sully@moz-45967CBE.emarhavil.com) (Ping timeout)
[00:25:19] *** Quits: joshua_ (joshua@moz-45967CBE.emarhavil.com) (Ping timeout)
[00:26:03] *** Joins: ssbr_ (ssbr@A9D9D38C.B6F034AC.72A31D6.IP)
[00:33:29] *** Joins: sully (sully@moz-45967CBE.emarhavil.com)
[00:33:39] *** Joins: joshua_ (joshua@moz-45967CBE.emarhavil.com)
[00:33:42] *** Quits: Jesin (Jessin_@moz-5654D37.washdc.fios.verizon.net) (Ping timeout)
[00:37:45] *** Quits: jdm (jdm@F2D29657.F60B0462.67AC9B1.IP) (Ping timeout)
[00:38:01] *** Joins: Jesin (Jessin_@moz-5654D37.washdc.fios.verizon.net)
[00:38:41] *** Joins: Sodel_the_V (user@moz-853663E1.va.shawcable.net)
[00:43:02] *** Quits: inolen (Adium@moz-9F4F17DF.tourcaster.com) (Quit: Leaving.)
[00:46:26] *** Joins: Thad (chatzilla@moz-C35F90AE.tx.res.rr.com)
[00:49:48] *** Joins: spaceships (spaceships@moz-8323E7E6.msl-mt.client.bresnan.net)
[00:50:07] *** Quits: themgt (themgt@moz-F5F3FFDF.dhcp.gnvl.sc.charter.com) (Quit: themgt)
[00:50:21] *** Quits: ssbr (scorchsabe@A9D9D38C.B6F034AC.72A31D6.IP) (Ping timeout)
[00:50:35] *** Quits: ssbr_ (ssbr@A9D9D38C.B6F034AC.72A31D6.IP) (Ping timeout)
[00:51:37] <sammykim> Isn't there any API to check whether port is being used ?
[00:52:15] *** Quits: maxli (maxli@C03F2759.C70D537E.2FA4EA88.IP) (Quit: Leaving.)
[00:52:22] *** Joins: ssbr (ssbr@A9D9D38C.B6F034AC.72A31D6.IP)
[00:52:28] *** Joins: ssbr_ (scorchsabe@A9D9D38C.B6F034AC.72A31D6.IP)
[00:52:49] <sammykim> What I am talking is the port about network communication.
[00:54:05] *** Joins: z0w0 (zack@D1D2DBCB.806EA3ED.2CE63F58.IP)
[00:54:20] <ssbr> nmatsakis: Alright, well, thanks.
[00:55:40] *** Quits: tcsc (tcsc@moz-A838B260.dhcp.nwtn.ct.charter.com) (Quit: computer sleeping)
[00:55:49] <nmatsakis> ssbr: my plans to improve the message is to have them record more than just the location in the code, but also an explanation of *why* that location caused the constraint 
[00:55:57] <nmatsakis> ssbr: so who knows, it may have been helpful here
[00:56:08] <nmatsakis> ssbr: anyway, glad you resolved it :)
[00:56:22] *** Joins: themgt (themgt@moz-F5F3FFDF.dhcp.gnvl.sc.charter.com)
[00:56:47] *** Joins: wilmoore (wilmoore@moz-71431C3A.hsd1.co.comcast.net)
[00:57:31] *** Quits: ssbr (ssbr@A9D9D38C.B6F034AC.72A31D6.IP) (Ping timeout)
[00:57:34] *** Quits: ssbr_ (scorchsabe@A9D9D38C.B6F034AC.72A31D6.IP) (Ping timeout)
[00:57:38] *** Joins: ghrust (ghrust@moz-4EF5B6E5.rs.github.com)
[00:57:38] <ghrust> 01[13rust01] 15bors 04force-pushed 06auto from 1470fbd00 to 14d546493: 02http://git.io/N3iJvQ
[00:57:38] *** Parts: ghrust (ghrust@moz-4EF5B6E5.rs.github.com) ()
[00:57:40] *** Joins: ghrust (ghrust@moz-4EF5B6E5.rs.github.com)
[00:57:40] <ghrust> 01[13rust01] 15bors pushed 10 new commits to 06auto: 02http://git.io/I5KNNA
[00:57:40] <ghrust> 13rust/06auto 140cde8ba 15Alex Crichton: Implement a new protocol for `for` loops that's much more easily composable
[00:57:40] <ghrust> 13rust/06auto 142825605 15Alex Crichton: core: Use the new `for` protocol
[00:57:40] <ghrust> 13rust/06auto 143ce9dba 15Alex Crichton: std: Use the new `for` protocol
[00:57:42] *** Parts: ghrust (ghrust@moz-4EF5B6E5.rs.github.com) ()
[00:59:22] *** Joins: ssbr (scorchsabe@A9D9D38C.B6F034AC.72A31D6.IP)
[00:59:34] *** Joins: ssbr_ (ssbr@A9D9D38C.B6F034AC.72A31D6.IP)
[00:59:45] <ssbr_> ugh I don't know what to do about this internet.
[00:59:59] <ssbr_> I guess to keep from annoying people I should turn everything off before I go to bed.
[01:00:23] <sp3d> interner?
[01:00:32] <sp3d> oh, no
[01:00:52] *** Quits: ssbr (scorchsabe@A9D9D38C.B6F034AC.72A31D6.IP) (Quit: Leaving)
[01:01:14] <seth> hmm, so do i have to import impl's somehow?
[01:01:47] <seth> trying to call a method that's on a trait for an enum that implements that trait, and rustc is complaining that the method isn't in scope
[01:02:15] *** Quits: FrozenCow (FrozenCow@moz-9DF5D010.dynamic.upc.nl) (Ping timeout)
[01:02:22] <ssbr_> seth: you have to import the trait, I think
[01:04:05] <kimundi> seth: If it's a trait impl, the trait has to be in scope (import with use). If it's an type impl, the type must be in scope.
[01:04:28] *** Quits: ssbr_ (ssbr@A9D9D38C.B6F034AC.72A31D6.IP) (Ping timeout)
[01:06:04] <seth> ssbr_/kimundi: thanks, got it
[01:06:08] *** Quits: BitPuffin (quassel@moz-8370D1B9.bredband.comhem.se) (Client exited)
[01:07:00] *** Joins: ssbr (ssbr@A9D9D38C.B6F034AC.72A31D6.IP)
[01:11:16] *** Quits: MrFahrenheit (RageOfThou@3FEF494C.29C984D5.783DEDCA.IP) (Ping timeout)
[01:12:04] *** Quits: ssbr (ssbr@A9D9D38C.B6F034AC.72A31D6.IP) (Ping timeout)
[01:13:20] *** bent is now known as bent|away
[01:13:20] *** Joins: ssbr (ssbr@A9D9D38C.B6F034AC.72A31D6.IP)
[01:16:05] *** Joins: infynyxx (infynyxx@moz-E95B370B.nyc.res.rr.com)
[01:16:48] *** Joins: bEcker (Thunderbir@moz-20F755D7.resnet.ucsc.edu)
[01:18:22] *** Quits: q66 (q66@6EE9DE40.46454B5D.33AABD5F.IP) (Client exited)
[01:18:31] *** Quits: ssbr (ssbr@A9D9D38C.B6F034AC.72A31D6.IP) (Ping timeout)
[01:18:51] <seth> jack: you know resizing is broken right?
[01:18:54] <seth> jack: on OS X at least
[01:19:08] <seth> gives me some truly bonkers graphical corruption
[01:19:30] <seth> ack, wrong channel
[01:20:18] *** Joins: ssbr (ssbr@A9D9D38C.B6F034AC.72A31D6.IP)
[01:21:37] *** Joins: ghrust (ghrust@moz-4EF5B6E5.rs.github.com)
[01:21:37] <ghrust> 01[13rust01] 15yichoi merged 06incoming into 06master: 02http://git.io/GT2yvg
[01:21:37] *** Parts: ghrust (ghrust@moz-4EF5B6E5.rs.github.com) ()
[01:22:24] *** Joins: maxli (maxli@C03F2759.C70D537E.2FA4EA88.IP)
[01:23:04] *** Quits: maxli (maxli@C03F2759.C70D537E.2FA4EA88.IP) (Quit: Leaving.)
[01:23:27] *** Quits: acrichto (acrichto@moz-FE112B96.res.cmu.edu) (Ping timeout)
[01:25:01] *** Quits: ssbr (ssbr@A9D9D38C.B6F034AC.72A31D6.IP) (Ping timeout)
[01:26:52] *** Joins: acrichto (acrichto@moz-FE112B96.res.cmu.edu)
[01:26:53] *** Joins: FrozenCow (FrozenCow@942DDF7C.D91BB06F.EF374763.IP)
[01:27:18] *** Joins: ssbr (ssbr@A9D9D38C.B6F034AC.72A31D6.IP)
[01:27:25] *** Joins: steven_is_false (quassel@moz-144077DE.bchsia.telus.net)
[01:29:08] *** Quits: FrozenCow (FrozenCow@942DDF7C.D91BB06F.EF374763.IP) (Connection reset by peer)
[01:31:15] *** Joins: ghrust (ghrust@moz-4EF5B6E5.rs.github.com)
[01:31:15] <ghrust> 01[13rust01] 15yichoi 04force-pushed 06master from 14d546493 to 14c081ffb: 02http://git.io/V2xBBQ
[01:31:15] *** Parts: ghrust (ghrust@moz-4EF5B6E5.rs.github.com) ()
[01:32:02] *** Quits: ssbr (ssbr@A9D9D38C.B6F034AC.72A31D6.IP) (Ping timeout)
[01:32:04] *** Quits: Diablo-D3 (diablo@moz-28CF78D6.port.east.myfairpoint.net) (Quit: This computer has gone to sleep)
[01:33:16] *** Joins: Diablo-D3 (diablo@moz-28CF78D6.port.east.myfairpoint.net)
[01:33:35] <Eridius> in rust 0.6, using a 'self lifetime was just fine. I just built trunk and now it's complaining that it must be declared. Is this to be expected?
[01:33:54] *** Quits: Sodel_the_V (user@moz-853663E1.va.shawcable.net) (Quit: Eaten by a grue)
[01:33:59] <pcwalton> Eridius: yeah, you need something like enum Foo<'self> { ... 'self ... }
[01:34:05] <Eridius> pcwalton: why the change?
[01:34:18] *** Joins: ssbr (ssbr@A9D9D38C.B6F034AC.72A31D6.IP)
[01:34:19] <pcwalton> because 'self isn't special anymore
[01:34:21] <Eridius> oops, afk for 15-20 min. feel free to answer anyway I'll see it ;)
[01:34:23] <pcwalton> it's just any other type parameter
[01:34:29] <pcwalton> you could call it 'widget
[01:34:38] <nmatsakis> (not yet)
[01:34:39] <pcwalton> but that means you have to declare it
[01:34:44] <pcwalton> well, that's the plan anyway
[01:34:47] <nmatsakis> :)
[01:34:56] <nmatsakis> yes
[01:35:06] <cantsin> but 'self still refers to the lifetime?
[01:35:25] <pcwalton> it's just a parameter
[01:36:03] *** Quits: KindOne (KindOne@5CB1B25D.B11A32F.EC6A1518.IP) (Ping timeout)
[01:36:08] <nmatsakis> cantsin: a lifetime parameter----so it still refers to a lifetime
[01:36:13] *** Quits: judder (maradukewa@DABDEEA3.F2C0D0AC.78E362FE.IP) (Ping timeout)
[01:36:40] <cantsin> ah gotcha. was wondering if 'self and 'a denoted specific lifetimes
[01:37:42] <cantsin> (apologies if that is already in the docs somewhere)
[01:37:56] <sammykim> In rust make check, when I got failed while testing run_tcp_test_server . becuase of port is being used, I think it needs some condition statement, if the port is being used. port needs to be changed another one.
[01:37:59] *** kimundi is now known as zz_kimundi
[01:38:11] <pcwalton> the only lifetime with a special name is 'static, the rest are just parameters
[01:38:20] *** Joins: KindOne (KindOne@moz-FC94EAE7.dynamic.ip.windstream.net)
[01:38:27] <cantsin> pcwalton: that's what i wanted to know. thanks!
[01:39:34] *** Quits: ssbr (ssbr@A9D9D38C.B6F034AC.72A31D6.IP) (Ping timeout)
[01:40:24] <aatch> pcwalton, why is `syntax` a keyword now?
[01:40:32] <pcwalton> it isn't
[01:40:36] <pcwalton> that was a mistake in the commit message
[01:40:45] <aatch> Ahh, thought that might be the case
[01:40:47] *** Joins: nass (nass@4F314BB3.5408CE6B.B38D1DE0.IP)
[01:41:16] *** Joins: ssbr (ssbr@A9D9D38C.B6F034AC.72A31D6.IP)
[01:42:14] *** Quits: dbaupp (Thunderbir@moz-856B3C14.lns20.syd6.internode.on.net) (Quit: dbaupp)
[01:43:36] *** Quits: doy (doy@moz-5FE28A32.akrasiac.org) (Ping timeout)
[01:45:01] *** Joins: doy (doy@moz-5FE28A32.akrasiac.org)
[01:45:29] *** Quits: Thad (chatzilla@moz-C35F90AE.tx.res.rr.com) (Quit: ChatZilla 0.9.90 [Firefox 21.0/20130506154904])
[01:45:47] *** Joins: dbaupp (Thunderbir@moz-856B3C14.lns20.syd6.internode.on.net)
[01:46:05] *** Quits: ssbr (ssbr@A9D9D38C.B6F034AC.72A31D6.IP) (Ping timeout)
[01:47:24] <acrichto> yay, new for loop iterators!
[01:47:37] <pcwalton> yes, exciting!
[01:47:42] <aatch> acrichto, oh, has that landed now?
[01:47:49] <pcwalton> tests just passed
[01:47:57] <aatch> schweet
[01:48:06] <pcwalton> bors better notice
[01:48:11] <pcwalton> if not I'll just manually land it
[01:48:17] *** Joins: ssbr (ssbr@A9D9D38C.B6F034AC.72A31D6.IP)
[01:48:27] <aatch> pcwalton, you rebel! :P
[01:48:35] <acrichto> bors has been emailing a little before the results actually show up
[01:48:39] *** Joins: ghrust (ghrust@moz-4EF5B6E5.rs.github.com)
[01:48:39] <ghrust> 01[13rust01] 15bors merged 06auto into 06incoming: 02http://git.io/I5KNNA
[01:48:39] *** Parts: ghrust (ghrust@moz-4EF5B6E5.rs.github.com) ()
[01:48:41] <acrichto> or commenting on pull requests at least
[01:48:43] <pcwalton> yay!
[01:48:49] <tjc> well, that's because bors has the power to predict the future
[01:48:54] <aatch> (I think he heard us...)
[01:49:07] <aatch> (she? it?)
[01:49:18] <acrichto> next up, <-> removal!
[01:50:12] <aatch> acrichto, I'm glad I know that's coming, since I've been using util::swap a bit
[01:50:13] *** Quits: rpearl (rpearl@moz-2B41ACB5.andrew.cmu.edu) (Ping timeout)
[01:50:42] *** Quits: bblum (bblum@moz-2B41ACB5.andrew.cmu.edu) (Ping timeout)
[01:50:52] <cantsin> nice, looking forward to the new changes :P i'm curious, when does the master branch update vis a vis incoming?
[01:51:16] <acrichto> aatch: only catch is that if you're swapping vector elements you'll need to use vec::swap instead, because taking two mutable loans out of an array isn't allowed
[01:51:17] <tjc> cantsin: when someone gets around to it and when incoming is green on all platforms
[01:51:21] <tjc> in other words, no particular schedule :-)
[01:51:31] <aatch> acrichto, ahh, good to know thanks
[01:51:33] *** Joins: ghrust (ghrust@moz-4EF5B6E5.rs.github.com)
[01:51:33] <ghrust> 01[13rust01] 15bors pushed 0 new commits to 06auto: 02http://git.io/OMJf2w
[01:51:33] *** Parts: ghrust (ghrust@moz-4EF5B6E5.rs.github.com) ()
[01:51:35] *** Joins: ghrust (ghrust@moz-4EF5B6E5.rs.github.com)
[01:51:35] <ghrust> 01[13rust01] 15bors pushed 4 new commits to 06auto: 02http://git.io/WrpV7A
[01:51:35] <ghrust> 13rust/06auto 14a033e77 15Alex Crichton: Implement util::swap without the '<->' operator
[01:51:35] <ghrust> 13rust/06auto 146d790c1 15Alex Crichton: Stop using the '<->' operator
[01:51:35] <ghrust> 13rust/06auto 1462588ad 15Alex Crichton: Remove the '<->' operator from the language
[01:51:38] *** Parts: ghrust (ghrust@moz-4EF5B6E5.rs.github.com) ()
[01:51:47] <cantsin> tjc: :) sounds good to me!
[01:52:03] <tjc> cantsin: also, we're going to get rid of the master/incoming distinction soon, since bors is generally working well to keep incoming green (though there have been some exceptions I don't know the details of)
[01:52:29] <cantsin> tjc: yea, it definitely seems like incoming has a lot of churn these days. exciting!
[01:53:12] *** Joins: maxli (maxli@C03F2759.C70D537E.2FA4EA88.IP)
[01:53:32] *** Quits: ssbr (ssbr@A9D9D38C.B6F034AC.72A31D6.IP) (Ping timeout)
[01:54:01] *** Quits: rntz (rntz@moz-C76A8D96.sp.cs.cmu.edu) (Ping timeout)
[01:54:16] *** Quits: pcwalton (pcwalton@43CB6079.66715431.D25A875A.IP) (Quit: pcwalton)
[01:54:22] *** Quits: acrichto (acrichto@moz-FE112B96.res.cmu.edu) (Ping timeout)
[01:55:13] *** Joins: ssbr (ssbr@A9D9D38C.B6F034AC.72A31D6.IP)
[01:57:20] *** Joins: rntz (rntz@moz-C76A8D96.sp.cs.cmu.edu)
[01:57:40] *** Quits: maxli (maxli@C03F2759.C70D537E.2FA4EA88.IP) (Ping timeout)
[01:57:44] *** Joins: acrichto (acrichto@moz-FE112B96.res.cmu.edu)
[01:58:25] *** Quits: lerc (quassel@121.75.155.67) (Client exited)
[01:58:35] *** Quits: rusti (rusti@moz-54F7FD49.cpe.net.cable.rogers.com) (Client exited)
[01:58:48] *** Joins: rpearl (rpearl@moz-2B41ACB5.andrew.cmu.edu)
[01:59:18] *** Joins: bblum (bblum@moz-2B41ACB5.andrew.cmu.edu)
[02:00:07] *** Quits: ssbr (ssbr@A9D9D38C.B6F034AC.72A31D6.IP) (Ping timeout)
[02:02:18] *** Joins: ssbr (ssbr@A9D9D38C.B6F034AC.72A31D6.IP)
[02:03:34] <Eridius> damn, I missed pcwalton
[02:04:07] <Eridius> ACK! configure: error: bad CLANG version: 5.0, need >=3.0svn
[02:04:16] <Eridius> how is 5.0 not >= 3.0svn?
[02:04:47] <Eridius> blah, it's using a case statement and doesn't handle 5.0*
[02:05:03] <tjc> Eridius: if that clang version works for you, submit an issue and we'll add it
[02:05:07] <cmr> did I wake up 3 years in the future? where did you get clang 5.0?
[02:05:14] <tjc> hmm
[02:05:19] <tjc> I don't even know what the latest version of clang is
[02:05:22] <cmr> 3.2
[02:05:33] <cmr> though they just branched 3.3svn
[02:05:37] <tjc> well, maybe Eridius has clang aliased toâ€¦ something else that's on version 5.0? :-)
[02:05:52] <Eridius> Apple's clang is a version greater than open source I think (dunno why; the version string always says what LLVM it's based on)
[02:06:00] <cmr> huh
[02:06:02] <Eridius> and I'm, um, using pre-release Apple clang...
[02:06:30] <cmr> learn something every day :)
[02:06:37] <tjc> :-)
[02:06:44] <Eridius> that's why your configure supports Clang 4.2, because that's Apple's version of Clang 3.2
[02:07:04] *** Quits: ssbr (ssbr@A9D9D38C.B6F034AC.72A31D6.IP) (Ping timeout)
[02:07:08] *** Quits: seth (seth@moz-BE33DA21.fw1.sfo1.mozilla.net) (Input/output error)
[02:07:20] <Eridius> anyway, if pcwalton was still around I was gonna ask why 'self is no longer special
[02:07:34] <aatch> Eridius, because there is no reason for it to be
[02:07:47] <Eridius> aatch: isn't it useful to tie things to the lifetime of self? It certainly was in rust 0.6
[02:08:26] <aatch> Eridius, you can still do that, you just have to explicitly declare the lifetime now
[02:08:55] <strcat> cmr: they actually have a 3.4 branch now afaik
[02:08:57] <Eridius> aatch: sure, but one would think that tying things to self is useful enough to make it special. It certainly was before
[02:09:15] *** Joins: ssbr (ssbr@A9D9D38C.B6F034AC.72A31D6.IP)
[02:09:20] <aatch> Eridius, it complicated things though
[02:09:27] <Eridius> oh?
[02:09:27] <strcat> cmr: since 3.3 is being prepared for release
[02:09:40] <Eridius> strcat: apparently my Clang 5.0 is based on 3.3svn
[02:09:49] <aatch> now all parameters are either type or lifetime parameters
[02:09:49] <Eridius> the version of Apple clang is just a marketing thing
[02:09:59] <Eridius> might be better if rust found the "based on 3.3svn" string and used that instead
[02:10:09] <strcat> marketing by confusing users?
[02:10:11] <strcat> ;p
[02:10:40] <Eridius> aatch: what other parameters were there before?
[02:10:49] <Eridius> I mean, &'self foo is still &'self foo even if I have to explicitly declare 'self
[02:11:06] <aatch> Eridius, I mean that self had to be checked for and added
[02:11:14] <Eridius> meh
[02:11:26] <Eridius> it just seems annoyingly verbose now
[02:11:29] <strcat> Eridius: 'self is related to &self unless you explicitly make it so
[02:11:38] <Eridius> strcat: I assume you meant to say "not"
[02:11:39] <strcat> it's the lifetime of the borrowed pointers *inside* the object
[02:11:48] <strcat> Eridius: yeah I mean isn't*
[02:12:01] <Eridius> strcat: well 'self doesn't exist at all now
[02:12:47] <strcat> it does still exist
[02:12:58] *** Quits: Diablo-D3 (diablo@moz-28CF78D6.port.east.myfairpoint.net) (Quit: This computer has gone to sleep)
[02:13:18] <strcat> it won't have a special meaning in the future but it's the only thing you can use as a parameter on an object now afaik
[02:13:22] <Eridius> strcat: the error tells me I have to declaer it now
[02:13:24] <strcat> other than 'static
[02:13:28] <strcat> Eridius: yes
[02:13:31] <strcat> you have to declare it
[02:13:45] <Eridius> ok I'm confused then. Since I have to declare it, isn't 'self now just like any other 'foo lifetime parameter?
[02:13:49] <strcat> no
[02:14:05] <strcat> Eridius: 'self always meant "lifetime of borrowed pointers in the object"
[02:14:21] <strcat> but before it *also* meant "lifetime of the self parameter pointer"
[02:14:29] <strcat> which crippled methods
[02:14:39] *** Quits: ssbr (ssbr@A9D9D38C.B6F034AC.72A31D6.IP) (Ping timeout)
[02:14:45] <strcat> you couldn't have &mut self to modify an object with borrowed ptrs in it
[02:14:53] <Eridius> ok I'm confused. Based on the 0.6 documentation, my understanding was that &'self foo meant that &foo had the same lifetime as &self
[02:15:06] <strcat> no it's unrelated to the self parameter
[02:15:09] <Eridius> which made me believe it was just like any other lifetime parameter, except implicitly present and tied to &self
[02:15:28] <strcat> 'self is the lifetime of borrowed ptrs inside the object and it's explicitly stated as a parameter to the object now
[02:15:36] <sammykim> Isn't self like this in C++ or JAVA?
[02:15:36] <strcat> it's in no way tied to &self or &mut self anymore
[02:15:43] <strcat> sammykim: yes
[02:16:00] *** Joins: akash__ (akash@CB2F1E5.9EA85462.35E3DDC8.IP)
[02:16:00] <strcat> we're talking about the 'self lifetime
[02:16:38] <strcat> Eridius: http://ix.io/5A9 that's an example of 'self
[02:16:45] *** Joins: ssbr (ssbr@A9D9D38C.B6F034AC.72A31D6.IP)
[02:16:48] <strcat> it's unrelated to the parameter now
[02:16:53] *** Quits: akashj87_ (akash@C94538B6.311ED440.35E3DDC8.IP) (Ping timeout)
[02:17:29] *** Joins: lerc (quassel@6174E42B.BEFA2430.788638A4.IP)
[02:17:37] <strcat> it's just a limitation of the language right now that you still have to call it 'self
[02:18:19] <Eridius> ssbr: why is predicate marked as 'self?
[02:18:46] <strcat> because it's a borrowed ptr inside the struct
[02:18:49] <sammykim> borrowed pointer's life is decided on reference count?
[02:18:58] <aatch> sammykim, nope
[02:19:03] <aatch> statically verified
[02:19:14] <aatch> only @-ptrs have a ref count
[02:19:17] <sammykim> In compile time?
[02:19:17] <strcat> sammykim: there's no runtime instrumentation for & pointers
[02:19:28] <strcat> they are just a pointer, with a statically verified lifetime
[02:19:30] <sammykim> Oh I see I was confued. 
[02:19:47] <Eridius> strcat: ok better question: under what circumstances would predicate not need a 'self lifetime? And if the answer is "none", then why does it need to be declared?
[02:19:47] <aatch> And very little instrumentation for ~-ptrs
[02:20:09] <strcat> Eridius: because in the future you will have to explicitly parameterize the struct with a region with any name
[02:20:12] <strcat> right now only 'self works
[02:20:21] <strcat> that's a limitation of the current iteration of the language
[02:20:27] *** Quits: thomaslee_ (thomaslee@moz-6C3931E3.static.twtelecom.net) (Client exited)
[02:20:29] <strcat> there will be multiple lifetime params at some pointer
[02:20:30] <strcat> point*
[02:21:04] <cantsin> strcat: what about 'a?
[02:21:10] <Eridius> strcat: ok, so the rust 0.6 code that prompted this was a trait function that looked like pub fn xor(&self, rhs: &'self [Elem]) -> Result;
[02:21:15] <Eridius> is the 'self even required now on rhs?
[02:21:21] <strcat> the only region name with special meaning is 'static
[02:21:32] <Eridius> (I'm still compiling trunk on this machine so I can't test)
[02:21:35] *** Quits: ssbr (ssbr@A9D9D38C.B6F034AC.72A31D6.IP) (Ping timeout)
[02:21:45] <strcat> 'self is the only region name currently allowed for a struct parameter other than 'static, but it has *no special meaning*
[02:22:24] <cantsin> but i do see 'a in rust code. e.g., pub unsafe fn transmute_mut<'a,T>(ptr: &'a T) -> &'a mut T { transmute(ptr) }
[02:22:34] <strcat> cantsin: that's not a struct parameter
[02:22:41] <Eridius> strcat: I was never talking about struct parameters to begin with :/
[02:22:42] <strcat> you can name regions anything you want
[02:22:47] <Eridius> I was talking about parameters to a trait fn
[02:22:58] <strcat> type parameter* then
[02:23:16] <cantsin> strcat: ahhhh gotcha. yea, that does make sense.
[02:23:17] *** Joins: ssbr (ssbr@A9D9D38C.B6F034AC.72A31D6.IP)
[02:23:32] <strcat> cantsin: the only region name with special meaning is 'static, meaning a static lifetime (valid for the entire existence of the program)
[02:24:07] <strcat> but the compiler rejects names other than 'self and 'static right now for type params because it hasn't been updated to accept any name
[02:24:18] <cantsin> strcat: perfectly clear! thank you so much :)
[02:24:25] <strcat> when it is, 'self and 'notself will both be perfectly equivalent/valid names for a type param
[02:25:06] <aatch> And static values are currently stored in a read-only segment (unless they are in an extern block, in which case, there is no data to store.
[02:26:02] <strcat> I think 'static will eventually apply to unsafe global variables too
[02:26:18] <strcat> perhaps even safe atomic globals
[02:26:55] <aatch> strcat, I think that's the plan
[02:27:01] *** Quits: SiegeLord (sl@moz-56D7E78.bstnma.fios.verizon.net) (Client exited)
[02:27:24] *** Joins: SiegeLord (sl@moz-56D7E78.bstnma.fios.verizon.net)
[02:28:08] *** Quits: ssbr (ssbr@A9D9D38C.B6F034AC.72A31D6.IP) (Ping timeout)
[02:28:22] <sammykim> when is the named life time being used? I don't actually know when I apply that to my code :(
[02:28:50] <tjc> sammykim: usually, when you want to borrow a sub-component of a data structure and need to prove to the compiler that the child has the same lifetime as the parent
[02:29:29] *** Quits: themgt (themgt@moz-F5F3FFDF.dhcp.gnvl.sc.charter.com) (Quit: themgt)
[02:29:44] <strcat> when you have a fn signature like 'fn foo<T, U>(x: &T) -> &U', the return value is ephemeral
[02:29:51] <strcat> you can't keep it after the call is over
[02:30:01] <aatch> sammykim, like type parameters, lifetimes are inferred. Also like type parameters, the inference is limited to function scopes.
[02:30:19] *** Joins: ssbr (ssbr@A9D9D38C.B6F034AC.72A31D6.IP)
[02:30:23] <strcat>  foo<'r, T, U>(x: &'r T, y: &T) -> &'r U
[02:30:30] <strcat> that means the return value has the same lifetime as the x parameter
[02:30:30] <sammykim> aatch: right. 
[02:30:33] *** Quits: heftig (heftig@moz-2F4A1158.dip0.t-ipconnect.de) (Quit: Quitting)
[02:30:34] <aatch> So the borrow checker has no idea what the lifetime of the returned value is because it can't see inside the function
[02:30:38] <sammykim> then
[02:30:45] <strcat> whatever you pass as the x parameter has to outlive it (and is frozen as long as the return value exists)
[02:30:52] *** Joins: heftig (heftig@moz-2F4A1158.dip0.t-ipconnect.de)
[02:30:54] <strcat>  foo<'r, T, U>(x: &'r T, y: &'r T) -> &'r U
[02:31:01] <cmr> sammykim: re: your earlier message about if a port is used, did that get answered?
[02:31:07] <strcat> that means the return value has the *intersection* of the two lifetimes
[02:31:18] <sammykim> Is is the life time of return valuethe same as life time of x in caller funtion ?
[02:31:19] <strcat> both the x and y parameters have to outlive it, and remain immutable as long as it exists
[02:31:29] <sammykim> Is is the life time of return valuethe same as life time of x in caller funtion ?
[02:31:34] <strcat> yes
[02:31:36] <strcat> well
[02:31:38] <strcat> in the 2nd example
[02:31:39] <sammykim> *Is is the life time of return value same as life time of x in caller funtion ?
[02:31:40] <sammykim> sorry
[02:31:43] <strcat> it's different
[02:31:48] <strcat>  foo<'r, T, U>(x: &'r T, y: &T) -> &'r U
[02:31:57] *** Joins: dherman (dherman@moz-6CA476B1.hsd1.ca.comcast.net)
[02:31:57] *** ChanServ sets mode: +o dherman
[02:31:59] <strcat> in that one the return's lifetime is the same as the x parameter's lifetime in the caller
[02:32:13] <strcat> well, it can go away sooner
[02:32:14] <aatch> I tend to read it as "given a pointer to 'x' that has a lifetime of 'r', I will give you a pointer that is valid for the same lifetime 'r'"
[02:32:29] <sammykim> oh I see..
[02:32:32] <sammykim> what you mean,
[02:32:33] <strcat> yeah
[02:32:37] <strcat> the return is valid for the lifetime of x
[02:32:45] <strcat> foo<'r, T, U>(x: &'r T, y: &'r T) -> &'r U
[02:32:52] <strcat> in that one x and y share the 'r lifetime
[02:32:59] <strcat> meaning the return value can't outlive *either* of them
[02:33:05] <aatch> Much in the same way that fn foo<T>(a:T) -> T; says "Give me something of type T, and I will give you something of the same type"
[02:33:25] <strcat> regions intersect though, which is a major difference
[02:33:28] <strcat> for a real example:
[02:33:59] <Eridius> boy, rust sure takes a while to compile
[02:34:00] <strcat> well, I'll leave of trait bounds
[02:34:53] <strcat> so a breadth-first function is going to take a graph as a parameter, and a start node (or more than one start node) key as another
[02:35:11] <strcat> and lets say you want to implement it for potentially non-copyable node types (or ones where copying is expensive)
[02:35:30] <strcat> internally, you need a queue and a visited set - those need to store ptrs to nodes
[02:35:37] *** Quits: ssbr (ssbr@A9D9D38C.B6F034AC.72A31D6.IP) (Ping timeout)
[02:35:44] <strcat> and you'll be yielding ptrs to nodes
[02:36:18] <strcat> so to actually store them and yield them... they need to have a non-ephemeral lifetime
[02:36:47] <strcat> and it needs to be as short as the lifetime of the ones in the graph *and* as short as the start node
[02:37:18] *** Joins: ssbr (ssbr@A9D9D38C.B6F034AC.72A31D6.IP)
[02:37:59] <strcat> fn bfs<'r>(graph: &'r Graph, start: &'r Node, f: &fn(node: &'r Node) -> bool)
[02:38:02] <strcat> so something like that
[02:38:33] <sammykim> I don't undestand if it's working in same functions. Why do they need named lifetime?
[02:39:13] <strcat> they're being passed to the callback with that lifetime param
[02:39:23] <strcat> &fn(node: &'r Node)
[02:39:40] <strcat> so the caller can see that the nodes have to be outlived by the graph and start node params
[02:40:02] *** Joins: bnicholson (bnicholson@moz-E98974C1.hsd1.ca.comcast.net)
[02:40:04] <strcat> it's part of the function signature
[02:40:17] <strcat> if there aren't region parameters, the function isn't as useful
[02:40:20] <aatch> It means the callback can do anything it wants, for example making a list of nodes without copying the nodes
[02:40:43] <sammykim> If i declare funtion as like &fn(node: &Node) ,
[02:40:43] <aatch> as long as they won't out-last the graph they came from
[02:40:54] <strcat> sammykim: so now the &Node can't outlive the function call
[02:40:56] <sammykim> Does the node have different life time?
[02:40:58] <strcat> you can't store them
[02:41:01] <strcat> sammykim: yes it's ephemeral
[02:41:07] <strcat> it only lives as long as the function call
[02:41:17] *** Quits: dherman (dherman@moz-6CA476B1.hsd1.ca.comcast.net) (Quit: dherman)
[02:41:17] <strcat> or in other cases, as long as the scope
[02:41:29] <strcat> if there's no explicit lifetime, it lives as long as the scope
[02:41:42] <sammykim> right
[02:41:46] <sammykim> strcat: right
[02:41:53] <strcat> so if you have something like
[02:42:12] *** Quits: ssbr (ssbr@A9D9D38C.B6F034AC.72A31D6.IP) (Ping timeout)
[02:42:13] <strcat> fn front(&self) -> &T
[02:42:35] *** Joins: ghrust (ghrust@moz-4EF5B6E5.rs.github.com)
[02:42:35] <ghrust> 01[13rust01] 15bors 04force-pushed 06auto from 141399d57 to 143e0400f: 02http://git.io/N3iJvQ
[02:42:35] *** Parts: ghrust (ghrust@moz-4EF5B6E5.rs.github.com) ()
[02:42:36] <strcat> the return value can't even outlive beyond where the call happens
[02:42:36] <aatch> Basically, you can't return borrowed pointers
[02:42:39] *** Joins: ghrust (ghrust@moz-4EF5B6E5.rs.github.com)
[02:42:39] <ghrust> 01[13rust01] 15bors pushed 2 new commits to 06auto: 02http://git.io/GviN2g
[02:42:39] <ghrust> 13rust/06auto 147652f3d 15Brian Anderson: Move flate from core to std
[02:42:39] <ghrust> 13rust/06auto 14c49cf8b 15bors: auto merge of #6205 : brson/rust/flate, r=brson...
[02:42:39] *** Parts: ghrust (ghrust@moz-4EF5B6E5.rs.github.com) ()
[02:42:57] <strcat> fn front(&'a self) -> &'a T
[02:43:11] <aatch> unadorned borrowed pointers rather.
[02:43:15] <strcat> now it lives as long as the object the self parameter refers to
[02:43:15] <sammykim> Hm, then the return value is not valid? we can still use it. 
[02:43:26] <sammykim> But what does it outlive exactly..?
[02:43:48] <strcat> sammykim: it's ephemeral, it's gone as soon as the call ends
[02:43:56] <sammykim> oh,
[02:44:02] <strcat> all you can really do is dereference it immediately without a lifetime
[02:44:28] *** Joins: ssbr (ssbr@A9D9D38C.B6F034AC.72A31D6.IP)
[02:44:31] <sammykim> Yeah, what was that?
[02:44:33] <aatch> `fn foo<T>() -> &T` the returned pointer's lifetime ends when it is returned.
[02:45:41] <strcat> and from a practical point of view
[02:45:43] <strcat> if you see
[02:46:07] <strcat> fn foo<'a>(x: &'a T, y: &T, z: &'a T) -> &'a T
[02:46:35] <strcat> you know the return value probably points at or into x or z
[02:47:03] *** Joins: Diablo-D3 (diablo@moz-28CF78D6.port.east.myfairpoint.net)
[02:47:10] <strcat> unless it's implemented with something like TLS and unsafe code....
[02:47:50] *** Joins: rusti (rusti@moz-54F7FD49.cpe.net.cable.rogers.com)
[02:48:03] <strcat> rusti: stop timing out ;p
[02:48:04] <rusti> foo.rs:5:14: 5:20 error: expected `;` or `}` after expression but found `timing`
[02:48:04] <rusti> foo.rs:5          stop timing out ;p
[02:48:04] <rusti>                        ^~~~~~
[02:48:11] <cmr> lol
[02:48:11] *** Quits: infynyxx (infynyxx@moz-E95B370B.nyc.res.rr.com) (Client exited)
[02:48:52] <sammykim> x is the pointer of caller's value . right.?
[02:49:17] *** Quits: ssbr (ssbr@A9D9D38C.B6F034AC.72A31D6.IP) (Ping timeout)
[02:49:19] <strcat> x y and z are pointers passed by the caller
[02:49:32] <sammykim> Then the lifetime of return value follows lifetime of caller's value(x, y, z)?
[02:49:38] <strcat> x, z and the return value have the 'a region
[02:49:42] <strcat> y doesn't
[02:49:49] <strcat> so the return value has to be outlived by x and z
[02:49:54] <strcat> y doesn't matter, it can go away earlier
[02:50:06] <sammykim> oh
[02:50:08] <sammykim> yeaya
[02:50:17] <sammykim> y doens't matter, I missed it
[02:51:03] <sammykim> Now I undertsnad, If I call foo function in main func, the return value outlive as long as main is done.
[02:51:09] <sammykim> Does it make sense?
[02:51:23] *** Joins: ssbr (ssbr@A9D9D38C.B6F034AC.72A31D6.IP)
[02:51:39] <sammykim> Exactly until x,z changes to be free
[02:51:51] <sammykim> * x,z is changed to be free
[02:52:10] <strcat> well until either x or z are gone
[02:52:37] <aatch> sammykim, it's a safety checking mechanism.
[02:52:49] *** Joins: Jesse (jruderman@moz-537BCF9.hsd1.ca.comcast.net)
[02:52:52] <aatch> All the memory is freed when it would normally be.
[02:53:03] <strcat> regions make the function more useful - they let you keep the return value or values passed to a closure longer
[02:53:03] <aatch> This just makes sure you can't have use-after-free
[02:53:06] <sammykim> Could you explain how checking mechanism is working simply?
[02:53:23] <strcat> sammykim: it checks that a borrowed pointer can't outlive what it points at
[02:53:38] <strcat> named regions allow it to a check one function at a time
[02:53:48] <strcat> instead of whole-program analysis (which would rule out having libraries)
[02:54:02] <aatch> and take a very long time
[02:54:23] <strcat> and named region make it easy for a human to understand
[02:54:28] <strcat> otherwise errors would be inexplicable
[02:54:40] <aatch> strcat, like Haskell type errors
[02:54:43] <sammykim> Thx guys :)
[02:54:51] <strcat> aatch: haskell type errors are the same as rust ones ;p
[02:54:57] <sammykim> It was helpful to me understand about named life time :)
[02:55:07] <strcat> named lifetimes are similar to trait bounds
[02:55:13] <strcat> it allows a function to type-checked when it's defined
[02:55:23] <sammykim> I don't acutlly understand about trait deeply.. :(
[02:55:38] <aatch> sammykim, don't worry about it.
[02:55:45] <aatch> Rust is not a simple language.
[02:55:48] <sammykim> Is trait like interface ?
[02:55:58] <sammykim> aatch : Great :)
[02:55:58] <aatch> sammykim, similar, yes
[02:56:02] <sammykim> aatch : little funny :)
[02:56:14] *** Quits: ssbr (ssbr@A9D9D38C.B6F034AC.72A31D6.IP) (Ping timeout)
[02:56:16] <sammykim> trait = interface, impl = class?
[02:56:26] <aatch> sammykim, kinda.
[02:56:33] <aatch> It's not a perfect comparison.
[02:56:34] <sammykim> aatch : Thx :p
[02:56:41] <aatch> But more-or-less works
[02:56:59] <sammykim> I think so. That's why rust was mde.
[02:57:07] <sammykim> *made
[02:57:17] <aatch> The difference is that implementation and representation are separate
[02:58:18] <cantsin> fwiw, i liked this article about rust vs go wrt objects/classes: http://lwn.net/Articles/548560/
[02:58:21] *** Joins: ssbr (ssbr@A9D9D38C.B6F034AC.72A31D6.IP)
[02:58:41] <strcat> cantsin: it doesn't really explain the difference though
[02:59:32] *** Quits: zz_kimundi (kimundi@moz-22B719B7.dip0.t-ipconnect.de) (Ping timeout)
[02:59:59] <cantsin> rust vs go? not really, i suppose. but it's a good intro to why both languages aren't really doing traditional oo.
[03:00:06] <sammykim> Can't I check the network port is using or not in rust?
[03:00:32] <strcat> methods in Go are part of the type implementing them - they can only be implemented by the library implementing the type
[03:01:15] *** Quits: bEcker (Thunderbir@moz-20F755D7.resnet.ucsc.edu) (Quit: bEcker)
[03:01:20] <sammykim> Cuz I set up the hudson but it's already using the port the rust test code is using. So I got make check error
[03:01:31] <strcat> an impl of a trait in rust is associated with the trait - you can add a trait and implement it for 'int' as long as 'int' doesn't already implement it
[03:01:31] <cantsin> strcat: very interesting. i haven't done any go programming myself, so i wouldn't know.
[03:01:45] *** Joins: dherman (dherman@moz-6CA476B1.hsd1.ca.comcast.net)
[03:01:45] *** ChanServ sets mode: +o dherman
[03:01:46] <cantsin> strcat: right. rust >> go, but we all knew that ;)
[03:01:50] <strcat> if the trait is defined in your crate, you can implement it for any type
[03:01:53] <strcat> cantsin: well, it's different
[03:02:18] <strcat> and if the type is defined in your crate, you can implement any trait for it (but only because anyone using your type can see that it's already implemented - it's still associated with the trait)
[03:02:37] *** Joins: zz_kimundi (kimundi@moz-9D7D84EF.dip0.t-ipconnect.de)
[03:02:56] <strcat> Go interfaces are just based on structural typing (it checks that the method name and types are the same, and that counts as an implementation)
[03:02:56] *** zz_kimundi is now known as kimundi
[03:03:03] <strcat> so... you can't add methods to a type you didn't define
[03:03:11] <aatch> Go is simpler, but you have less control. Rust is complex but you get much more control
[03:03:22] <strcat> but you can make interfaces that use the methods it already has (interfaces aren't explicitly implemented in Go)
[03:03:43] *** Quits: ssbr (ssbr@A9D9D38C.B6F034AC.72A31D6.IP) (Ping timeout)
[03:03:45] <strcat> it's a tradeoff
[03:03:54] <cantsin> hmm.
[03:04:12] <strcat> Go makes it easier to define interfaces (nothing has to be explicitly done by types), but you can't add methods to types and there's no explicit implementation of the right semantics
[03:05:11] <strcat> and Go's interfaces are only usable as dynamic dispatch. they're always vtables
[03:05:44] *** Joins: ssbr (ssbr@A9D9D38C.B6F034AC.72A31D6.IP)
[03:05:55] <cantsin> yea, i can see the tradeoff there. hrm.
[03:06:09] <strcat> and rust's traits can inherit from other traits, and generic parameters can be bounded by multiple traits
[03:06:52] <Eridius> tjc: btw I filed an issue saying that configure needs to extract the "based on" version when present. I even provided a sed command to do it ;)
[03:06:58] <strcat> in Go you add all the methods needed by the interface to the interface and anything with those method signatures implements the interface
[03:07:01] <strcat> so it's much different.
[03:07:05] <Eridius> I don't want to file an issue specifically requesting knowledge of version 5.0 because that's not public yet AFAIK
[03:07:05] <tjc> Eridius: Thanks :-)
[03:07:12] <tjc> okay
[03:07:38] <steven_is_false> Dang it I keep forgetting to use the -j4 flag.
[03:07:45] <strcat> only helps LLVM
[03:07:52] <cantsin> strcat: phew. thanks for the explanation!
[03:07:57] <strcat> cantsin: np
[03:09:47] <Eridius> hah, I deleted the 'self annotations from the code that originally triggered my question, and no complaints
[03:09:50] <Eridius> I'm sure rust 0.6 demanded them though, because I wouldn't have added them otherwise
[03:09:50] <strcat> in rust if you needed something like a Queue trait you would inherit from traits providing the methods or implement them for the types yourself if there wasn't something to inherit from
[03:09:50] <aatch> strcat, if I want to take a value from an vector, without touching any other elements would this work: https://gist.github.com/Aatch/e92b48cc1ac7c94b5911
[03:10:12] *** Quits: ssbr (ssbr@A9D9D38C.B6F034AC.72A31D6.IP) (Ping timeout)
[03:10:22] <strcat> in Go you would define method signatures matching existing ones and if the types all had the same signatures + method names it would work
[03:11:00] <Eridius> damn, rustcrypto needs an update again for trunk
[03:11:35] <strcat> aatch: that looks fine
[03:11:41] <aatch> strcat, cool
[03:11:52] <aatch> it's for a circular buffer
[03:12:13] <aatch> so moving everything kinda defeats the point
[03:12:15] <strcat> deque is a circular buffer btw, but it's 2x as big as it could be because it's safe code
[03:12:18] *** Joins: ssbr (ssbr@A9D9D38C.B6F034AC.72A31D6.IP)
[03:13:08] <strcat> would probably be better to just use unsafe code.
[03:13:34] <aatch> strcat, yeah, I'm doing this for the work-stealing deque
[03:13:46] <Eridius> what happened to cast::reinterpret_cast<>?
[03:13:46] <strcat> ah
[03:13:55] <strcat> Eridius: it's transmute_copy now
[03:14:02] <strcat> but you probably want transmute
[03:14:02] <Eridius> ah
[03:14:08] <Eridius> well this is preexisting code
[03:14:19] *** Joins: inolen (Adium@moz-FA2406D8.socal.res.rr.com)
[03:14:28] <Eridius> strcat: what's the difference between the two?
[03:14:59] <cantsin> transmute_copy doesn't bump the refcount?
[03:15:03] <strcat> transmute consumes it, transmute_copy copies/bitcasts it
[03:15:10] <strcat> cantsin: not about a refcount
[03:15:34] <Eridius> strcat: well I don't know what the cast is for in this code. It's wrapped up in another function, so I guess there's no knowing whether the caller is going to keep using the original input
[03:15:38] <Eridius> so I'll stick with transmute_copy
[03:15:45] <aatch> cantsin, no refcounts anywhere except `@`
[03:15:55] <strcat> and @ will eventually be gc'ed
[03:16:12] <aatch> oh, and in std::rc
[03:16:15] <strcat> std::rc (task-local) and std::arc (shared) are refcounted boxes
[03:16:26] <Eridius> strcat: @ isn't gc'd right now?
[03:16:33] <heftig> no, refcounted
[03:16:37] <strcat> Eridius: no it's refcounted, but graydon has a working gc in a branch
[03:16:40] <cantsin> yea, i got confused with bump_box_refcount in the tests.
[03:16:45] <Eridius> strcat: I see. I thought it was cycle-collected like python
[03:16:57] <aatch> Eridius, it is if you count refcounting as a form of garbage collection
[03:17:05] <aatch> (which I do)
[03:17:07] <Eridius> I don't
[03:17:13] <strcat> Eridius: there used to be a cycle collector but there isn't a working one anymore
[03:17:13] *** Quits: ssbr (ssbr@A9D9D38C.B6F034AC.72A31D6.IP) (Ping timeout)
[03:17:16] <Eridius> I see
[03:17:23] <strcat> just going to be replaced by a tracing gc
[03:17:38] <heftig> mark and sweep?
[03:17:47] <Eridius> what happened to ptr::addr_of? Am I just supposed to cast the &foo to a *foo myself?
[03:17:54] <aatch> Eridius, coercion
[03:17:55] <strcat> heftig: yes, stop-the-task conservative mark-and-sweep at first
[03:17:56] *** Joins: seth (seth@moz-D840E602.dsl.static.sonic.net)
[03:18:07] <strcat> heftig: and it will be very slow at first ;p
[03:18:19] <Eridius> aatch: I'm not sure what coercion means in the context of rust
[03:18:32] <strcat> Eridius: yes & coerces implicitly to *
[03:18:34] <aatch> Eridius, &T coerces to *T automatically
[03:18:44] <Eridius> huh, ok
[03:18:48] <strcat> rusti: let x = 5; let y: *int = &x; y
[03:18:49] <rusti> 25354000
[03:18:57] <aatch> the same way ~T coerces to &T
[03:19:04] <strcat> dereferencing it is regarded as the unsafe operation
[03:19:11] *** Joins: Sodel_the_V (user@moz-853663E1.va.shawcable.net)
[03:19:20] *** Joins: ssbr (ssbr@A9D9D38C.B6F034AC.72A31D6.IP)
[03:19:48] <strcat> getting a pointer and doing arithmetic on it is the same as doing it with an integer
[03:20:14] <strcat> could use the integer to call an unsafe array index function, that's the unsafe boundary
[03:20:24] <aatch>  /having/ a null pointer is perfectly safe
[03:20:32] <Eridius> woo, unnecessary `unsafe` blocks!
[03:20:36] *** Quits: seth (seth@moz-D840E602.dsl.static.sonic.net) (Ping timeout)
[03:20:37] <strcat> well or a dangling pointer, or a ptr to some random memory ;p
[03:24:10] <Eridius> yay, updating rustcrypto for trunk was easy enough
[03:24:12] *** Quits: ssbr (ssbr@A9D9D38C.B6F034AC.72A31D6.IP) (Ping timeout)
[03:24:53] <strcat> Eridius: openssl bindings?
[03:25:14] <Eridius> strcat: yeah
[03:25:18] <Eridius> not mine, but I ported them to 0.6
[03:25:24] <strcat> hopefully not like the code in the old ffi-tutorial which was unsafe ;p
[03:25:41] <Eridius> strcat: well ffi is unsafe. But what did you mean?
[03:25:43] * strcat has doubts that it's possible to expose a safe interface on top of openssl without locks
[03:25:55] <strcat> Eridius: openssl uses internal global variables for some return values
[03:26:00] <Eridius> ewww really?
[03:26:08] <strcat> it doesn't have the caller allocate memory or allocate it itself in many cases
[03:26:09] <strcat> Eridius: yup
[03:26:18] *** Joins: ssbr (ssbr@A9D9D38C.B6F034AC.72A31D6.IP)
[03:26:19] <cmr> is openssl threadsafe?
[03:26:29] <strcat> cmr: not really
[03:26:33] <cmr> didn't think so
[03:26:34] <strcat> look at 'man MD5'
[03:26:43] <strcat> well
[03:26:47] <Eridius> I love how Go has its own crypto implementation. I wish rust did
[03:26:48] <strcat> the caller can allocate an array and pass it is.
[03:26:52] <aatch> aren't most people using other implementations though?
[03:26:58] <strcat> you can't use the default return value
[03:27:10] <strcat>        MD2(), MD4(), and MD5() compute the MD2, MD4, and MD5 message digest of the n bytes at d and place it in md (which must have
[03:27:11] *** Parts: Sodel_the_V (user@moz-853663E1.va.shawcable.net) (Killing koopas in another castle)
[03:27:12] <strcat>        space for MD2_DIGEST_LENGTH == MD4_DIGEST_LENGTH == MD5_DIGEST_LENGTH == 16 bytes of output). If md is NULL, the digest is
[03:27:14] <strcat>        placed in a static array.
[03:27:15] <cmr> Eridius: What's to love about bespoke crypto?
[03:27:18] <strcat> the old tutorial was passing in null and calling it safe
[03:27:27] <Eridius> strcat: eww don't pass NULL
[03:27:35] <Eridius> cmr: because it's all self-contained and doesn't require dealing with openssl?
[03:27:44] <Eridius> and comes bundled with the language
[03:28:39] <cantsin> wow, that is disgusting. (wrt openssl)
[03:29:03] <Eridius> strcat: for what it's worth, any code I've seen that uses OpenSSL's hashing functions always provides its own buffer
[03:29:06] <cmr> Crypto isn't easy to properly implement, I hope they put in the requisite effort.
[03:29:18] <strcat> Eridius: : lots of the high level interfaces are unsafe though
[03:29:38] <Eridius> cmr: sure, it's not. And they've admitted there are areas that are vulnerable to timing attacks, but they've certainly done work to mitigate that where they can, and document what parts of their crypto is vulnerable
[03:29:40] <strcat>         const EVP_MD *EVP_md5(void);
[03:29:43] <strcat>         const EVP_MD *EVP_sha(void);
[03:29:45] <strcat>         const EVP_MD *EVP_sha1(void);
[03:29:47] <strcat> like those ones.
[03:29:50] <cmr> Eridius: that's good, then.
[03:29:51] <Eridius> Go does have an implementation of timing-safe cryptographic primitive operations
[03:30:15] <Eridius> but I love how incredibly easy it is to just hook up an SSL connection
[03:30:32] <Eridius> it's quite literally just using crypto/tls.Dial instead of net.Dial
[03:30:46] <strcat> it's the same in other languages like python with batteries included libs
[03:31:10] <Eridius> but my Go program isn't dependent on third-party libs
[03:31:28] <strcat> using python's stdlib only requires that you have python
[03:32:07] <Eridius> strcat: sure, but I'm guessing python requires openssl if it's providing crypto (because I'm not aware of python reimplementing this stuff)
[03:32:08] *** Quits: ssbr (ssbr@A9D9D38C.B6F034AC.72A31D6.IP) (Ping timeout)
[03:32:11] <strcat> it doesn't matter whether it ships a library itself, ships a third-party library itself or uses the system library from the program's POV (it does either of the latter 2)
[03:32:19] <strcat> Eridius: but it ships it internally unless you build it with the system lib
[03:32:32] <strcat> it's not an extra dependency unless you're using a package manager letting you factor out duplicate deps
[03:33:20] *** Joins: ssbr (ssbr@A9D9D38C.B6F034AC.72A31D6.IP)
[03:33:38] *** Joins: ghrust (ghrust@moz-4EF5B6E5.rs.github.com)
[03:33:38] <ghrust> 01[13rust01] 15bors merged 06auto into 06incoming: 02http://git.io/GviN2g
[03:33:38] *** Parts: ghrust (ghrust@moz-4EF5B6E5.rs.github.com) ()
[03:33:49] <strcat> libuv isn't an external dep for rust (but it should be possible to use the system one, ideally)
[03:34:54] <cantsin> is there a concurrency module that will let task(s) produce/consume the items of a list one by one?
[03:35:05] <aatch> cantsin, doubt it.
[03:35:09] <cmr> What algorithm does flate implement anyway? deflate?
[03:35:17] <strcat> cmr: yes
[03:36:05] <cantsin> aatch: thanks. i'll use DuplexStream for now.
[03:36:37] *** Joins: ghrust (ghrust@moz-4EF5B6E5.rs.github.com)
[03:36:37] <ghrust> 01[13rust01] 15bors pushed 0 new commits to 06auto: 02http://git.io/hTv8JQ
[03:36:37] *** Parts: ghrust (ghrust@moz-4EF5B6E5.rs.github.com) ()
[03:36:41] *** Joins: ghrust (ghrust@moz-4EF5B6E5.rs.github.com)
[03:36:41] <ghrust> 01[13rust01] 15bors pushed 5 new commits to 06auto: 02http://git.io/ZVteNg
[03:36:41] <ghrust> 13rust/06auto 147d22437 15Alex Crichton: Implement util::swap without the '<->' operator
[03:36:41] <ghrust> 13rust/06auto 14998fece 15Alex Crichton: Stop using the '<->' operator
[03:36:41] <ghrust> 13rust/06auto 1463c7e2f 15Alex Crichton: Remove the '<->' operator from the language
[03:36:43] *** Parts: ghrust (ghrust@moz-4EF5B6E5.rs.github.com) ()
[03:37:18] *** Joins: brendan (brendaneic@moz-C252503F.public.wayport.net)
[03:37:23] * aatch likes that a lot of the recent patches have been removing features
[03:38:19] *** Quits: ssbr (ssbr@A9D9D38C.B6F034AC.72A31D6.IP) (Ping timeout)
[03:40:05] *** Joins: ssbr (ssbr@A9D9D38C.B6F034AC.72A31D6.IP)
[03:40:39] *** Quits: inolen (Adium@moz-FA2406D8.socal.res.rr.com) (Ping timeout)
[03:41:37] *** Joins: inolen (Adium@moz-FA2406D8.socal.res.rr.com)
[03:43:18] <spaceships> what was the <-> operator?
[03:43:21] <strcat> swap
[03:43:48] <strcat> was needed when rust had a weird concept of purity
[03:43:53] <spaceships> ahh
[03:44:13] <strcat> the rule was that you couldn't call functions taking &mut from a pure fn
[03:44:29] <strcat> pure basically meant no &mut params... not a strong form of purity
[03:44:59] <strcat> and that's already part of the type signature anyway so all it did was make code not very generic and annoy people ;p
[03:45:11] * spaceships nods
[03:45:11] *** Quits: ssbr (ssbr@A9D9D38C.B6F034AC.72A31D6.IP) (Ping timeout)
[03:46:54] <dbaupp> strcat: https://github.com/mozilla/rust/pull/6420 r?
[03:47:15] <aatch> dbaupp, bahahaha
[03:47:19] <strcat> hmm, where did that come from ;p
[03:47:30] <strcat> ah there
[03:50:22] *** Joins: ssbr (ssbr@A9D9D38C.B6F034AC.72A31D6.IP)
[03:50:27] <steven_is_false> rusti: 5 as uint.times |_| { io::println ("I"); true }
[03:50:28] <rusti> foo.rs:5:18: 5:19 error: expected `;` or `}` after expression but found `.`
[03:50:28] <rusti> foo.rs:5          5 as uint.times |_| { io::println ("I"); true }
[03:50:28] <rusti>                            ^
[03:50:49] <steven_is_false> rusti: let x : uint = 5; 5.times |_| { io::println ("I"); true }
[03:50:49] <rusti> foo.rs:5:36: 5:37 error: unexpected token: `_`
[03:50:50] <rusti> foo.rs:5          let x : uint = 5; 5.times |_| { io::println ("I"); true }
[03:50:50] <rusti>                                              ^
[03:50:54] <dbaupp> rusti: for (5 as uint).times |_| { io::println ("I") }
[03:50:55] <rusti> more than 5 lines of output, pastebinned: http://sprunge.us/EbML
[03:50:59] <steven_is_false> rusti: let x : uint = 5; x.times |_| { io::println ("I"); true }
[03:51:00] <rusti> foo.rs:5:36: 5:37 error: unexpected token: `_`
[03:51:00] <rusti> foo.rs:5          let x : uint = 5; x.times |_| { io::println ("I"); true }
[03:51:00] <rusti>                                              ^
[03:51:17] <dbaupp> rusti: for 5u.times { io::println ("I") }
[03:51:18] <rusti> I
[03:51:18] <rusti> I
[03:51:18] <rusti> I
[03:51:18] <rusti> I
[03:51:18] <rusti> I
[03:51:23] <steven_is_false> rusti: let x : uint = 5; x.times(|_| { io::println ("I"); true })
[03:51:25] <rusti> more than 5 lines of output, pastebinned: http://sprunge.us/CLHH
[03:51:35] <sammykim> https://github.com/mozilla/rust/issues/4334 graydon comments about bytes macro.
[03:51:43] <steven_is_false> rusti: let x : uint = 5; x.times(|| { io::println ("I"); true })
[03:51:44] <rusti> I
[03:51:44] <rusti> I
[03:51:44] <rusti> I
[03:51:44] <rusti> I
[03:51:44] <rusti> I
[03:51:51] <steven_is_false> rusti: let x : uint = 5; x.times(|| { io::println ("I"); false })
[03:51:52] <rusti> I
[03:51:56] <sammykim> I have a question Is there anyone have idea?
[03:52:09] <sammykim> Gosh. rusti is it really rustc and rust runtime?
[03:52:24] <sammykim> I think it's a person :p
[03:52:35] <Luqman> rusti the bot uses rustc :P
[03:53:10] <sammykim> rusti : fmt!("%s", hello");
[03:53:16] <sammykim> rusti: fmt!("%s", hello");
[03:53:17] <rusti> more than 5 lines of output, pastebinned: http://sprunge.us/FaSD
[03:53:33] <Luqman> missing a "
[03:53:42] <sammykim> rusti : fmt!("%s", "hello");
[03:53:51] <sammykim> rusti: fmt!("%s", "hello");
[03:54:02] <Luqman> try removing the semicolon
[03:54:07] <sammykim> rusti: fmt!("%s", "hello")
[03:54:08] <rusti> ~"hello"
[03:54:10] <sammykim> return value 
[03:54:12] <sammykim> right :)
[03:54:19] <sammykim> thx Luq :P
[03:54:49] <sammykim> Is it just working on this room?
[03:55:16] <Luqman> you can also private message it
[03:55:45] <sammykim> I don't acutlly know to use IRC exactly.:(
[03:56:00] <cmr>  /query rusti
[03:56:05] *** Quits: akash__ (akash@CB2F1E5.9EA85462.35E3DDC8.IP) (Quit: Leaving)
[03:57:10] <strcat> sammykim: yes it's rustc in a secure sandbox
[03:57:29] <strcat> the actual REPL is totally broken ;p
[03:57:37] *** Quits: ysuzuki (ysuzuki@moz-60FA9D06.net119083145.t-com.ne.jp) (Client exited)
[03:57:51] <strcat> and AOT compilation is probably faster anyway.......
[03:58:04] <cantsin> strcat: actually, i submitted a two-line patch that will fix the leak.
[03:58:12] <cmr> link?
[03:58:23] <strcat> cantsin: there's more broken than a leak
[03:58:37] <strcat> it can't run 20% of rust code even when it's working
[03:58:39] <cantsin> https://github.com/mozilla/rust/pull/6397
[03:58:43] <cantsin> strcat: baby steps first :)
[03:58:48] <cantsin> next step is to get tests in there
[03:59:01] <cantsin> yes, the whole thing will need to be rewritten at some point
[03:59:49] <strcat> does it optimize by default? I don't know why it's so damn slow ;p
[04:00:13] <sammykim> cantsin: what kind of patch is that?
[04:00:53] *** Joins: cdidd (cdidd@moz-23D9B633.broadband.corbina.ru)
[04:00:53] <sammykim> Is rusti same as rusti in this room? ? 
[04:01:04] *** Quits: sammykim (sammy.kim@5AB4884B.FCC4549.14D5B978.IP) (Quit: leaving)
[04:01:10] *** Joins: sammykim (sammy.kim@5AB4884B.FCC4549.14D5B978.IP)
[04:01:18] <strcat> sammykim: no
[04:02:04] <strcat> what they do have in common is that they're quickly throw together hacks without tests that are slowly being improved ;p
[04:02:30] <cantsin> strcat: you don't want to know. it basically compiles the history + new input wrapped up in a main function... every time.
[04:02:58] <strcat> cantsin: still, 1+1 is slower than running rustc on a file with 1+1 in main afaict
[04:03:05] <strcat> it eats a ton of memory
[04:03:10] *** Quits: tiffany (kawaii@moz-1E0FE6E8.dhcp.embarqhsd.net) (Ping timeout)
[04:04:20] <aatch> cantsin, that's almost exactly what the bot here does though.
[04:04:35] <aatch> except for the history bit.
[04:04:52] *** Quits: dherman (dherman@moz-6CA476B1.hsd1.ca.comcast.net) (Quit: dherman)
[04:05:04] <cantsin> aatch, strcat, that's true. its dog slow. not sure why yet.
[04:05:46] <cantsin> afaics it takes the same code path as actual compilation, calls a llvm jit function, and exits a bit early
[04:06:08] <strcat> there might not be a point in using the JIT
[04:06:24] <strcat> it would be faster if it's optimizing though
[04:06:46] <cantsin> jit can't do anything if it's re-compiled (from scratch) every time. nothing is being reused.
[04:07:48] <strcat> ah it doesn't keep it around?
[04:07:59] <strcat> I thought it would keep it around for functions you declared
[04:08:04] <cantsin> strcat: nope.
[04:08:28] <strcat> what happens if there's an error?
[04:09:20] <cantsin> boom? :)
[04:09:32] <cantsin> assert! terminates it too
[04:09:53] <strcat> so if you write print("foo"), will it then print foo for each line you enter?
[04:10:42] *** Quits: tjc (tjc@A5087023.2354C43D.D8E68FF6.IP) (Quit: zzzzzzzzzz)
[04:12:32] <cantsin> strcat: yea.
[04:12:39] <strcat> heh
[04:12:55] * cantsin shrugs.
[04:13:32] <aatch> Bah, this is insane code
[04:13:42] *** Joins: akashj87 (akash@E35F59C6.D90B5583.35E3DDC8.IP)
[04:14:12] *** Quits: mzabaluev (mzabaluev@moz-91FFD755.dhcp.inet.fi) (Ping timeout)
[04:14:19] <cantsin> actually, it won't print again, which is nice -- i just tested. but it will emit warnings again and again and again...
[04:14:27] <cantsin> i guess it only takes the output of the last input
[04:15:25] <aatch> Abandon all hope, ye who enter: https://gist.github.com/Aatch/7f0de04dc3ec4aef66a4
[04:16:17] <sammykim> Can't I allocate the string literal? Is this only way to allocate string literal as like "string literal"?
[04:16:27] <strcat> aatch: forget doesn't destroy
[04:17:03] <cmr> sammykim: ~"string literal"
[04:17:07] <strcat> sammykim: a string literal like "foo" is &'static str
[04:17:22] <aatch> strcat, dammit, fixed the incorrect free
[04:17:31] <aatch> Forgot to handle dangling allocation
[04:18:01] <strcat> aatch: std::rc just swaps in uninit
[04:18:13] <strcat> which hopefully will just optimize to a destructor call...
[04:18:53] <aatch> strcat, cool.
[04:19:09] * strcat wonders what vec does
[04:19:21] <cmr> Which is good style, &mut'a self, or &'a mut self?
[04:19:27] <strcat> oh I guess the compiler generates the code for vec
[04:19:30] <cmr> (is the first even valid?)
[04:19:30] <strcat> cmr: it won't let you do the former
[04:19:34] <strcat> you don't have a choice :)
[04:19:48] <cmr> I love not havin choice, so easy :)
[04:19:50] <aatch> unfortunately, concurrent access means I can't rely on there being a contiguous block of memory
[04:19:54] *** Joins: dylukes (dylukes@moz-E4DF3FED.pitbpa.fios.verizon.net)
[04:20:13] <strcat> aatch: you can swap one value with uninit though, right?
[04:20:28] <strcat> just to get it on the stack so it's freed
[04:20:37] <aatch> strcat, yep
[04:20:42] <strcat> sadly I don't think there's a way to call the destructor on a memory location
[04:20:42] <strcat> I want one
[04:20:59] <aatch> I'm just explaining why I'm commiting such an atrocity
[04:21:04] <strcat> ah
[04:21:28] <strcat> one day I'm going to finish these gmp bindings instead of just patching them up for language changes...
[04:21:54] <strcat> http://ix.io/5Ad seriously though that's like 30% of the API :|
[04:22:17] <strcat> and all I really did was implement the traits for them...
[04:22:24] <cmr> Why is gmp __ prefixed?
[04:22:25] <cantsin> oh wow, that will be useful.
[04:22:37] <strcat> the bindings + tests are now 1200 lines
[04:22:39] <strcat> \o/
[04:22:53] <strcat> cmr: because they're evil ;p
[04:22:57] <cmr> lol
[04:23:05] <strcat> every "function" in the header is really a #define
[04:23:17] *** Joins: tjc (tjc@A5087023.2354C43D.D8E68FF6.IP)
[04:23:17] *** ChanServ sets mode: +o tjc
[04:23:27] <strcat> they #define mpz_add __gmpz_add
[04:23:37] <strcat> don't know why
[04:23:42] <strcat> don't want to know really ;p
[04:23:48] <cantsin> damn
[04:24:21] <strcat> anyway the functions are all op(output, input) or op(output, input, input2)
[04:24:33] <strcat> and an output can be the same as an input, so that's how you do in-place ops
[04:24:41] <strcat> so..... atm I've only wrapped the ones that copy
[04:25:02] <strcat> I guess it'll end up being 3k lines of wrapping code ;p
[04:25:51] <cantsin> i don't know the details but can you use rust macros to simplify some of it?
[04:26:13] <strcat> cantsin: yeah, I could
[04:26:22] <strcat> gmpy (python bindings) are 30k lines of code
[04:26:36] *** Quits: heftig (heftig@moz-2F4A1158.dip0.t-ipconnect.de) (Ping timeout)
[04:26:37] <cantsin> O_o
[04:26:53] <strcat> they have a bunch of C implementing a cpython extension
[04:27:30] <strcat> 21k lines in the non-test/doc part
[04:27:56] <cantsin> ouch.
[04:28:25] <cmr> Would it also be possible to write a binding generator? Writing bindings is really tedious, boring work
[04:28:34] <strcat> cmr: not really
[04:28:44] <strcat> you can generate the declarations with clang (rust-bindgen does that)
[04:28:49] <strcat> you can't write actual bindings automatically
[04:29:24] <strcat> C declarations aren't enough to deal with memory management or anything
[04:30:04] *** Joins: heftig (heftig@moz-8FBC8595.dip0.t-ipconnect.de)
[04:30:50] <strcat> cmr: http://static.rust-lang.org/doc/tutorial-ffi.html there's a good example there
[04:30:56] <strcat> the extern block can be automatically generated
[04:31:00] <strcat> the hard part can't be ;p
[04:31:16] <strcat> I don't mind writing out the declarations by hand as I wrap them because I need to read the docs for the functions anyway
[04:31:20] <aatch> strcat, I'm pretty sure you can use cast::ignore to "destroy" a value
[04:31:29] <cantsin> yea, that does make sense. as an aside, on that page, it says that c++ isn't supported (yet?) -- is c++ support planned?
[04:31:29] <cmr> well you said all the gmp functinos have the same basic (output, input) or (output, input, input2). I guess I just don't know enough about gmp
[04:31:51] <aatch> cantsin, it's a "maybe, and if it is, it will be limited" type thing
[04:32:13] <cantsin> aatch: i'm sure, but even that would be useful imo
[04:32:27] <cantsin> cool.
[04:32:30] <aatch> cantsin, it may happen, but it's very low on the list
[04:32:40] <cantsin> aatch: yeah, that's what i figured. 
[04:32:40] <strcat> it can't be automatic, you need to read the docs and figure out memory management + thread safety
[04:32:52] <strcat> some functions can't have safe bindings at all
[04:32:57] <strcat> without making global locks
[04:33:09] <strcat> ofc macros can help with all of these similar ones
[04:34:02] <sammykim> strcat: what is unsafe pointer exactly?
[04:34:20] <strcat> sammykim: a pointer without borrow checking
[04:34:27] <strcat> & and * are the same at runtime
[04:34:45] <strcat> except there are invariants about & that could let the compiler generate better code than with *
[04:35:06] <sammykim> Is * unsafe pointer?
[04:35:08] <strcat> cmr: http://gmplib.org/manual/Integer-Division.html#Integer-Division those for example, they all have the same pattern
[04:35:12] <heftig> yes, that's a raw pointer
[04:35:13] <sammykim> Thx
[04:35:22] <strcat> cmr: check for zero, and pass the arguments in the same way
[04:36:15] <strcat> the mpz_t and function names aren't actually the types though, just defines in the header.
[04:37:04] <strcat> void __gmpz_tdiv_q (mpz_ptr q, mpz_srcptr n, mpz_srcptr d);
[04:37:07] <strcat> ^ the real signature
[04:39:14] *** Quits: brendan (brendaneic@moz-C252503F.public.wayport.net) (Quit: brendan)
[04:40:10] *** Joins: brendan (brendaneic@moz-C252503F.public.wayport.net)
[04:43:59] <aatch> Man, I am being paranoid about this code.
[04:47:48] <cmr> Where is the code that implements #[deriving] ?
[04:48:02] *** Quits: brendan (brendaneic@moz-C252503F.public.wayport.net) (Quit: brendan)
[04:48:02] <aatch> cmr, syntax::ext::deriving
[04:48:08] <cmr> aatch: thanks
[04:48:23] <aatch> dbaupp worked on most of that code, so bug him.
[04:48:37] *** Joins: ghrust (ghrust@moz-4EF5B6E5.rs.github.com)
[04:48:37] <ghrust> 01[13rust01] 15bors merged 06auto into 06incoming: 02http://git.io/ZVteNg
[04:48:37] *** Parts: ghrust (ghrust@moz-4EF5B6E5.rs.github.com) ()
[04:51:33] *** Joins: ghrust (ghrust@moz-4EF5B6E5.rs.github.com)
[04:51:33] <ghrust> 01[13rust01] 15bors pushed 0 new commits to 06auto: 02http://git.io/8z4pfA
[04:51:33] *** Parts: ghrust (ghrust@moz-4EF5B6E5.rs.github.com) ()
[04:51:37] <cmr> dbaupp: So deriving requires core to be imported, but if it's the only use of core, you get an unused import warning. if it isn't imported you get https://gist.github.com/cmr/a3b3f24c9aa7523b29ec. how should this be fixed?
[04:52:19] <cmr> I guess the unused import checker thing is running before anything is expanded?
[04:52:38] <aatch> cmr, nope
[04:53:13] <aatch> it's part of resolve
[04:54:34] *** Joins: ghrust (ghrust@moz-4EF5B6E5.rs.github.com)
[04:54:34] <ghrust> 01[13rust01] 15bors pushed 0 new commits to 06auto: 02http://git.io/8z4pfA
[04:54:34] *** Parts: ghrust (ghrust@moz-4EF5B6E5.rs.github.com) ()
[04:54:35] *** Joins: ghrust (ghrust@moz-4EF5B6E5.rs.github.com)
[04:54:35] <ghrust> 01[13rust01] 15bors pushed 2 new commits to 06auto: 02http://git.io/AHkd9Q
[04:54:35] <ghrust> 13rust/06auto 1407cd5a8 15Tim Chevalier: testsuite: Add two test cases (one xfailed)
[04:54:35] <ghrust> 13rust/06auto 14842e304 15bors: auto merge of #6368 : catamorphism/rust/issue-5315, r=catamorphism
[04:54:35] *** Parts: ghrust (ghrust@moz-4EF5B6E5.rs.github.com) ()
[04:54:59] *** Joins: Sodel_the_V (user@moz-853663E1.va.shawcable.net)
[04:55:38] *** Quits: steven_is_false (quassel@moz-144077DE.bchsia.telus.net) (Ping timeout)
[04:55:39] <cmr> hm
[04:58:45] *** Joins: igl1 (igl@moz-12E538EE.adsl.alicedsl.de)
[04:59:12] *** Quits: igl (igl@moz-21D8C29B.adsl.alicedsl.de) (Ping timeout)
[04:59:33] *** Quits: engla (engla@moz-DBD1D96E.cust.bredbandsbolaget.se) (Ping timeout)
[05:05:22] *** Quits: thomaslee (thomaslee@moz-306D3DF4.hsd1.or.comcast.net) (Quit: Leaving)
[05:05:44] *** Quits: wilmoore (wilmoore@moz-71431C3A.hsd1.co.comcast.net) (Client exited)
[05:11:57] *** Joins: jdm (jdm@DB05BBF2.BB1F48F2.971E19F6.IP)
[05:12:32] *** Quits: dylukes (dylukes@moz-E4DF3FED.pitbpa.fios.verizon.net) (Quit: ["Textual IRC Client: www.textualapp.com"])
[05:13:07] *** Joins: engla (engla@moz-DBD1D96E.cust.bredbandsbolaget.se)
[05:16:46] *** Quits: tjc (tjc@A5087023.2354C43D.D8E68FF6.IP) (Quit: Places to go, people to annoy)
[05:28:23] *** Joins: xorcon (Mibbit@moz-65489226.hsd1.ga.comcast.net)
[05:28:42] *** Quits: xorcon (Mibbit@moz-65489226.hsd1.ga.comcast.net) (Quit: http://www.mibbit.com ajax IRC Client)
[05:30:59] *** Joins: thomaslee (thomaslee@moz-306D3DF4.hsd1.or.comcast.net)
[05:31:52] *** Quits: ssbr (ssbr@A9D9D38C.B6F034AC.72A31D6.IP) (Ping timeout)
[05:33:53] *** Joins: ssbr (ssbr@A9D9D38C.B6F034AC.72A31D6.IP)
[05:37:07] *** Quits: Diablo-D3 (diablo@moz-28CF78D6.port.east.myfairpoint.net) (Quit: This computer has gone to sleep)
[05:39:52] *** Quits: ssbr (ssbr@A9D9D38C.B6F034AC.72A31D6.IP) (Ping timeout)
[05:40:54] *** Joins: ssbr (ssbr@A9D9D38C.B6F034AC.72A31D6.IP)
[05:41:35] *** Joins: akashj87_ (akash@D26569FE.81BE2642.35E3DDC8.IP)
[05:42:07] *** Quits: akashj87 (akash@E35F59C6.D90B5583.35E3DDC8.IP) (Ping timeout)
[05:43:57] *** Quits: SiegeLord (sl@moz-56D7E78.bstnma.fios.verizon.net) (Quit: It's a joke. It's all a joke.)
[05:45:17] *** Joins: akash__ (akash@A6502C1C.C8AE44CB.35E3DDC8.IP)
[05:45:30] *** Quits: akashj87_ (akash@D26569FE.81BE2642.35E3DDC8.IP) (Ping timeout)
[05:45:55] *** Quits: ssbr (ssbr@A9D9D38C.B6F034AC.72A31D6.IP) (Ping timeout)
[05:47:04] *** Joins: BizarreCake (BizarreCak@32C9829A.151E84E7.561471F8.IP)
[05:47:42] *** Joins: ssbr (ssbr@A9D9D38C.B6F034AC.72A31D6.IP)
[05:54:31] *** Quits: ssbr (ssbr@A9D9D38C.B6F034AC.72A31D6.IP) (Ping timeout)
[05:54:32] *** Joins: ghrust (ghrust@moz-4EF5B6E5.rs.github.com)
[05:54:32] <ghrust> 01[13rust01] 15bors merged 06auto into 06incoming: 02http://git.io/AHkd9Q
[05:54:32] *** Parts: ghrust (ghrust@moz-4EF5B6E5.rs.github.com) ()
[05:54:42] *** Joins: ssbr (ssbr@A9D9D38C.B6F034AC.72A31D6.IP)
[05:56:01] *** Joins: Diablo-D3 (diablo@moz-28CF78D6.port.east.myfairpoint.net)
[05:57:30] *** Joins: ghrust (ghrust@moz-4EF5B6E5.rs.github.com)
[05:57:31] <ghrust> 01[13rust01] 15bors pushed 0 new commits to 06auto: 02http://git.io/6gIHRQ
[05:57:31] *** Parts: ghrust (ghrust@moz-4EF5B6E5.rs.github.com) ()
[05:58:52] *** Quits: Diablo-D3 (diablo@moz-28CF78D6.port.east.myfairpoint.net) (Quit: do coders dream of sheep()?)
[05:59:58] *** Quits: ssbr (ssbr@A9D9D38C.B6F034AC.72A31D6.IP) (Ping timeout)
[06:00:30] *** Joins: ghrust (ghrust@moz-4EF5B6E5.rs.github.com)
[06:00:30] <ghrust> 01[13rust01] 15bors pushed 0 new commits to 06auto: 02http://git.io/6gIHRQ
[06:00:30] *** Parts: ghrust (ghrust@moz-4EF5B6E5.rs.github.com) ()
[06:01:40] *** Joins: ssbr (ssbr@A9D9D38C.B6F034AC.72A31D6.IP)
[06:07:30] *** Quits: ssbr (ssbr@A9D9D38C.B6F034AC.72A31D6.IP) (Ping timeout)
[06:08:41] *** Joins: ssbr (ssbr@A9D9D38C.B6F034AC.72A31D6.IP)
[06:09:50] *** Joins: Diablo-D3 (diablo@moz-28CF78D6.port.east.myfairpoint.net)
[06:13:59] *** Quits: ssbr (ssbr@A9D9D38C.B6F034AC.72A31D6.IP) (Ping timeout)
[06:15:40] *** Joins: ssbr (ssbr@A9D9D38C.B6F034AC.72A31D6.IP)
[06:18:30] *** Quits: ssbr (ssbr@A9D9D38C.B6F034AC.72A31D6.IP) (Ping timeout)
[06:20:50] *** Joins: akashj87_ (akash@C8DCA18.46EB02D4.35E3DDC8.IP)
[06:21:19] *** Quits: bent|away (chatzilla@moz-932324BF.hsd1.ca.comcast.net) (Ping timeout)
[06:21:21] *** Quits: akash__ (akash@A6502C1C.C8AE44CB.35E3DDC8.IP) (Ping timeout)
[06:29:12] *** Joins: jviereck (Adium@moz-340574DC.dclient.hispeed.ch)
[06:33:27] *** Quits: KindOne (KindOne@moz-FC94EAE7.dynamic.ip.windstream.net) (Ping timeout)
[06:34:35] *** Joins: catpig (catpig@moz-DB8BBE41.dip0.t-ipconnect.de)
[06:34:57] *** Joins: KindOne (KindOne@moz-FC94EAE7.dynamic.ip.windstream.net)
[06:38:20] *** Quits: engla (engla@moz-DBD1D96E.cust.bredbandsbolaget.se) (Ping timeout)
[06:40:51] *** Quits: jviereck (Adium@moz-340574DC.dclient.hispeed.ch) (Connection reset by peer)
[06:41:24] <aatch> How do I do a simple memcmp-style equality test?
[06:41:25] *** Joins: jviereck1 (Adium@moz-340574DC.dclient.hispeed.ch)
[06:41:42] *** Quits: jviereck1 (Adium@moz-340574DC.dclient.hispeed.ch) (Max SendQ exceeded)
[06:41:58] *** Joins: lbonn (olcc@moz-29C8E1BA.ap-w02.canvas.ne.jp)
[06:44:07] <dbaupp> aatch: vec::{raw,bytes}::memcmp(?)
[06:44:19] <dbaupp> aatch: or ptr::mem<something>
[06:44:35] <dbaupp> cmr: I can't reproduce it... can you put the code online?
[06:44:46] <aatch> dbaupp, there doesn't seem to be a memcmp in ptr
[06:45:18] <aatch> Bah!, I'll just do it myself using libc
[06:45:41] *** Joins: mjh563 (mjh563@moz-D891C5B8.cable.virginmedia.com)
[06:47:11] <dbaupp> aatch: you could cast to &[u8] and just use the standard .cmp method
[06:47:55] <aatch> dbaupp, wouldn't that break because &[u8] has the length attached?
[06:48:28] <dbaupp> yeah... are you working with * pointers?
[06:48:41] <aatch> dbaupp, nope, arbitrary data
[06:49:00] <aatch> I have no idea what I might have, but I want to make sure that the actual thing I have is a certain value
[06:49:01] <dbaupp> vector?
[06:49:10] <dbaupp> oh...
[06:49:18] <aatch> Basically, I need to see if it's 0.
[06:49:24] <dbaupp> well. do you know what size it is?
[06:49:30] <aatch> Well I have the type
[06:49:34] <aatch> So yes.
[06:49:42] <aatch> I'm just implement a memeq helper
[06:49:55] *** Quits: BizarreCake (BizarreCak@32C9829A.151E84E7.561471F8.IP) (Ping timeout)
[06:50:03] <dbaupp> rusti: unsafe { cast::transmute::<(uint,uint),&[u8]>((1u, 2u)) }
[06:50:04] <rusti> Segmentation fault (core dumped)
[06:50:04] <aatch> It's for an assertion.
[06:50:13] *** Joins: sammykim_ (sammykim__@48AEBDE2.ACF655DA.97B9B372.IP)
[06:50:35] <dbaupp> rusti: let x = 1u; unsafe { cast::transmute::<(uint,uint),&[u8]>((&x, 1u)) }
[06:50:37] <rusti> more than 5 lines of output, pastebinned: http://sprunge.us/IiPU
[06:50:41] *** Quits: sammykim_ (sammykim__@48AEBDE2.ACF655DA.97B9B372.IP) (Quit: Leaving)
[06:50:47] <dbaupp> rusti: let x = 1u; unsafe { cast::transmute::<(&uint,uint),&[u8]>((&x, 1u)) }
[06:50:48] <rusti> &[1]
[06:51:19] <dbaupp> rusti: let x = 1u; unsafe { cast::transmute::<(&uint,uint),&[u8]>((&x, sys::size_of_val(&x))) }
[06:51:20] <rusti> &[1, 0, 0, 0, 0, 0, 0, 0]
[06:51:50] <dbaupp> aatch: that ^ might work?
[06:52:16] <aatch> dbaupp, probably, but it's verbose enough that I'd extract it into a helper anyway
[06:52:35] <dbaupp> aatch: yeah, that's reasonable
[06:52:58] <aatch> so I might as well just skip straight to using memcmp from libc
[06:53:31] <dbaupp> yup
[06:53:40] *** Joins: jviereck (Adium@moz-2B0BB5C.dclient.hispeed.ch)
[06:53:58] *** Quits: rfw (rfw@moz-C65A114.rfw.name) (Ping timeout)
[06:58:18] *** Joins: rfw (rfw@moz-C65A114.rfw.name)
[07:03:33] *** Joins: ghrust (ghrust@moz-4EF5B6E5.rs.github.com)
[07:03:33] <ghrust> 01[13rust01] 15bors merged 06auto into 06incoming: 02http://git.io/ihd9rg
[07:03:33] *** Parts: ghrust (ghrust@moz-4EF5B6E5.rs.github.com) ()
[07:04:15] *** Quits: blitter (blitter@moz-7C98731E.dyn.centurytel.net) (Ping timeout)
[07:05:53] *** Quits: spaceships (spaceships@moz-8323E7E6.msl-mt.client.bresnan.net) (Quit: leaving)
[07:06:04] <darkf> can rustc build in parallel yet?
[07:06:19] <dbaupp> darkf: nope
[07:06:28] *** Joins: ghrust (ghrust@moz-4EF5B6E5.rs.github.com)
[07:06:28] <ghrust> 01[13rust01] 15bors pushed 0 new commits to 06auto: 02http://git.io/4fG0wg
[07:06:28] *** Parts: ghrust (ghrust@moz-4EF5B6E5.rs.github.com) ()
[07:06:45] *** Quits: lbonn (olcc@moz-29C8E1BA.ap-w02.canvas.ne.jp) (Quit: leaving)
[07:07:21] *** Joins: BizarreCake (BizarreCak@32C9829A.151E84E7.561471F8.IP)
[07:08:25] *** Joins: Cromulent (Cromulent@moz-983B638D.cable.virginmedia.com)
[07:08:46] *** Joins: Blub\w (wry@7E3BB9D.71150E1A.237AE2BA.IP)
[07:08:49] <darkf> aw
[07:08:52] <darkf> well this is rather annoying
[07:09:29] *** Joins: ghrust (ghrust@moz-4EF5B6E5.rs.github.com)
[07:09:29] <ghrust> 01[13rust01] 15bors pushed 0 new commits to 06auto: 02http://git.io/4fG0wg
[07:09:29] *** Parts: ghrust (ghrust@moz-4EF5B6E5.rs.github.com) ()
[07:09:30] *** Joins: ghrust (ghrust@moz-4EF5B6E5.rs.github.com)
[07:09:30] <ghrust> 01[13rust01] 15bors pushed 2 new commits to 06auto: 02http://git.io/gd3sYQ
[07:09:30] <ghrust> 13rust/06auto 14ea5c413 15Huon Wilson: Perform expansion before stripping/building a test harness....
[07:09:30] <ghrust> 13rust/06auto 14fe56ddf 15bors: auto merge of #6383 : huonw/rust/rustc-expand-then-strip, r=Aatch...
[07:09:30] *** Parts: ghrust (ghrust@moz-4EF5B6E5.rs.github.com) ()
[07:09:32] <darkf> trying to compile rust on windows, rustc terminates with std::bad_alloc even though I still have a good 1 or 2gb of RAM left and rustc is only using 1,887mb
[07:10:54] <aatch> "only"
[07:11:36] *** Joins: mzabaluev (mzabaluev@moz-91FFD755.dhcp.inet.fi)
[07:11:40] <darkf> yes, only :) 
[07:13:36] *** Joins: lbonn (lbonn@moz-29C8E1BA.ap-w02.canvas.ne.jp)
[07:13:49] <darkf> the wiki did say it will need around ~2gb, but i don't know why it throws bad_alloc - even if it is a 32-bit process it should still be under the limit
[07:22:35] *** Quits: jaen (jaen@moz-E0979827.copit.pl) (Ping timeout)
[07:23:10] *** Joins: jaen (jaen@moz-E0979827.copit.pl)
[07:44:20] <dbaupp> hm, does anyone know what's up with this test? http://buildbot.rust-lang.org/builders/auto-linux/builds/1185/steps/test/logs/stdio
[07:45:11] <dbaupp> (I can't see anything called "maps" or even "*.map" in the Rust tree)
[07:45:26] *** Joins: ghrust (ghrust@moz-4EF5B6E5.rs.github.com)
[07:45:27] <ghrust> 01[13rust01] 15bors 04force-pushed 06auto from 14fe56ddf to 14d43d3e5: 02http://git.io/N3iJvQ
[07:45:27] *** Parts: ghrust (ghrust@moz-4EF5B6E5.rs.github.com) ()
[07:45:29] *** Joins: ghrust (ghrust@moz-4EF5B6E5.rs.github.com)
[07:45:29] <ghrust> 01[13rust01] 15bors pushed 3 new commits to 06auto: 02http://git.io/cl6ThQ
[07:45:29] <ghrust> 13rust/06auto 149042e1e 15Tom Lee: Include static methods on traits in reexports.
[07:45:29] <ghrust> 13rust/06auto 141e241ce 15Tom Lee: Test case for issue #4202
[07:45:29] <ghrust> 13rust/06auto 1418a47f9 15bors: auto merge of #6384 : thomaslee/rust/issue-4202, r=catamorphism...
[07:45:31] *** Parts: ghrust (ghrust@moz-4EF5B6E5.rs.github.com) ()
[07:45:53] <dbaupp> It's run-pass/issue-2904.rs, and the error is `error: error opening /home/rustbuild/src/rust-buildbot/slave/auto-linux/build/src/test/run-pass/./maps/contest1.map`
[07:46:41] <strcat>     #[test]
[07:46:43] <strcat>     pub fn read_simple_board() {
[07:46:45] <strcat>         let s = include_str!("./maps/contest1.map");
[07:46:47] <strcat>         io::with_str_reader(s, read_board_grid)
[07:46:49] <strcat>     }
[07:46:52] <strcat> I guess it's incorrect?
[07:47:25] <dbaupp> Should I file an issue?
[07:47:38] <strcat> I don't understand why it hasn't been failing ;p
[07:47:45] <strcat> dbaupp: seems so
[07:47:46] *** Quits: mzabaluev (mzabaluev@moz-91FFD755.dhcp.inet.fi) (Ping timeout)
[07:48:06] <dbaupp> strcat: hmm
[07:48:19] <strcat> the include_str! part seems to be broken for sure
[07:48:25] <strcat> but not failing for whatever reason
[07:48:35] <dbaupp> ooooh, I know... that changed moved macro expansion to before dealing with #[test] etc
[07:48:43] <dbaupp> so the #[test] fn was stripped
[07:48:55] <dbaupp> and the macro was never expanded, normally
[07:49:12] <dbaupp> *changeset
[07:49:42] *** Quits: jgilbert (jgilbert@2557E599.66715431.D25A875A.IP) (Ping timeout)
[07:52:38] *** Quits: solancile (solancile@moz-A1CFFAE5.hsd1.wa.comcast.net) (Ping timeout)
[07:54:36] *** Quits: Cromulent (Cromulent@moz-983B638D.cable.virginmedia.com) (Quit: KVIrc 4.2.0 Equilibrium http://www.kvirc.net/)
[07:58:23] *** Quits: Jeaye (Jeaye@moz-FD505E54.hsd1.ca.comcast.net) (Quit: zzzZZZzzz)
[08:04:56] *** Quits: catpig (catpig@moz-DB8BBE41.dip0.t-ipconnect.de) (Quit: Verlassend)
[08:08:34] *** Quits: devbug (quassel@moz-E1DE087C.bchsia.telus.net) (Connection reset by peer)
[08:10:53] *** Joins: donri (dag@moz-9BB61102.tbcn.telia.com)
[08:17:44] *** Joins: zakora (NC@moz-8EAF945F.fbx.proxad.net)
[08:18:06] *** Joins: doener (doener@moz-121949B3.unitymediagroup.de)
[08:22:47] *** Quits: jaen (jaen@moz-E0979827.copit.pl) (Quit: WeeChat 0.4.0)
[08:23:01] *** Joins: jaen (jaen@moz-E0979827.copit.pl)
[08:24:06] *** Joins: Cromulent (Cromulent@moz-983B638D.cable.virginmedia.com)
[08:25:53] *** Joins: Palmik (palmik@moz-DADC71F0.pks.muni.cz)
[08:26:59] <darkf> heh, ok sweet, got it compiled on windows with gcc 4.5 (which is unfortunate)
[08:27:31] <dbaupp> strcat: https://github.com/mozilla/rust/pull/6383 r?
[08:27:36] <dbaupp> darkf: nice :D
[08:28:01] <dbaupp> strcat: I had to xfail a test because HashMap doesn't implement ToStr
[08:38:37] *** Joins: wilmoore (wilmoore@moz-71431C3A.hsd1.co.comcast.net)
[08:42:27] *** Joins: ghrust (ghrust@moz-4EF5B6E5.rs.github.com)
[08:42:27] <ghrust> 01[13rust01] 15bors merged 06auto into 06incoming: 02http://git.io/cl6ThQ
[08:42:27] *** Parts: ghrust (ghrust@moz-4EF5B6E5.rs.github.com) ()
[08:45:27] *** Joins: ghrust (ghrust@moz-4EF5B6E5.rs.github.com)
[08:45:27] <ghrust> 01[13rust01] 15bors pushed 0 new commits to 06auto: 02http://git.io/NoJyWQ
[08:45:27] *** Parts: ghrust (ghrust@moz-4EF5B6E5.rs.github.com) ()
[08:45:31] *** Joins: ghrust (ghrust@moz-4EF5B6E5.rs.github.com)
[08:45:31] <ghrust> 01[13rust01] 15bors pushed 27 new commits to 06auto: 02http://git.io/NGWASw
[08:45:31] <ghrust> 13rust/06auto 14b68c464 15Brian Anderson: core::rt: Remove Close trait...
[08:45:31] <ghrust> 13rust/06auto 1497d54b5 15Brian Anderson: core::rt: Fix a warning about unnecessary mutable variable
[08:45:32] <ghrust> 13rust/06auto 14e523d14 15Brian Anderson: core::rt: Begin implementing TcpStream...
[08:45:34] *** Parts: ghrust (ghrust@moz-4EF5B6E5.rs.github.com) ()
[08:46:10] *** Quits: Cromulent (Cromulent@moz-983B638D.cable.virginmedia.com) (Quit: KVIrc 4.2.0 Equilibrium http://www.kvirc.net/)
[08:46:50] <cmr> dbaupp: I got it by removing the 'use core;' from librustc/moddile/ty.rs
[08:48:03] <cmr> I can't get it in other code though...
[08:48:16] <cmr> Does librustc not have the prelude included?
[08:50:50] <dbaupp> cmr: yeah, it is included.
[08:51:35] <dbaupp> cmr: hmmm, just thinking about it, the problem you saw is probably because the paths used by 'deriving' are global paths, so local imports are ignored/unused
[08:51:42] *** Quits: strcat (strcat@moz-54F7FD49.cpe.net.cable.rogers.com) (Quit: WeeChat 0.4.0)
[08:52:13] <dbaupp> rusti: use core; ::core::path::Path("foo")
[08:52:15] <rusti> foo.rs:5:13: 5:17 warning: unused import
[08:52:15] <rusti> foo.rs:5          use core; ::core::path::Path("foo")
[08:52:15] <rusti>                       ^~~~
[08:52:15] <rusti> {is_absolute: false, components: ~[~"foo"]}
[08:52:21] <dbaupp> yep
[08:52:28] <dbaupp> rusti: use core; core::path::Path("foo")
[08:52:29] <rusti> {is_absolute: false, components: ~[~"foo"]}
[08:52:38] <dbaupp> ok, cool. That's the issue
[08:52:40] <cmr> That seems like a bug to me.
[08:53:29] <cmr> What is https://gist.github.com/cmr/a3b3f24c9aa7523b29ec, though?
[08:53:41] <dbaupp> cmr: the bug is that the deriving code uses global paths, or that the global paths don't count as "uses"?
[08:53:53] <cmr> dbaupp: global paths don't count as uses
[08:53:58] <dbaupp> cmr: which particular part of it?
[08:54:14] <dbaupp> (the gist)
[08:54:15] <cmr> dbaupp: The unresolved names / undeclared modules in core
[08:54:34] <dbaupp> what was the change that caused that, btw?
[08:55:16] <cmr> Removing line 31 ("use core;") from ty.rs, I think
[08:55:21] <dbaupp> cmr: I would say the global path thing isn't a bug, but you should file an issue, because the error message could be better
[08:55:23] <cmr> Retesting that now
[08:55:41] <dbaupp> cmr: waait
[08:55:49] <dbaupp> cmr: IterBytes was recently updated
[08:56:17] <dbaupp> and the old version probably didn't use global paths (I didn't write it, and I didn't look at the generic set-up part of the old code much)
[08:56:30] <dbaupp> which would give that behaviour, I think
[08:56:55] <dbaupp> (I'm not actually sure if it used local/global paths)
[08:57:08] <dbaupp> how recent is your rust?
[08:57:22] <cmr> fdf601e, 22 hours ago
[08:58:01] <dbaupp> hm
[08:58:03] <dbaupp> strange
[08:58:24] <cmr> Yeah, removing the "use core;" is what did it
[09:00:10] <dbaupp> um, is this on the stage0 compile?
[09:00:14] <cmr> yeah
[09:00:29] <dbaupp> that compiler is older
[09:00:47] <dbaupp> so it's using non-global-path IterBytes
[09:01:01] <dbaupp> solution: wait for a snapshot :(
[09:01:19] <cmr> doh, yup
[09:01:30] <dbaupp> in the meantime, you can try putting a #[cfg(stage0)] on the use core import
[09:01:44] <dbaupp> so that it only happens with the old compiler
[09:02:56] <cmr> dbaupp: thanks :)
[09:03:17] <dbaupp> cmr: no problem :)
[09:05:27] *** Quits: jdm (jdm@DB05BBF2.BB1F48F2.971E19F6.IP) (Ping timeout)
[09:06:22] *** Quits: Sodel_the_V (user@moz-853663E1.va.shawcable.net) (Quit: Eaten by a grue)
[09:06:25] *** Joins: pyrac (pyrac@moz-B95F505.w92-156.abo.wanadoo.fr)
[09:14:13] <dbaupp> cmr: ok, my build has got to stage1 rustc, without either problem. so the #[cfg(.)] thing seems to fix it :)
[09:15:15] <cmr> dbaupp: yup. already bootstrapped here, it's #6423
[09:15:50] <dbaupp> cmr: wow, your computer is fast!
[09:17:14] <dbaupp> cmr: there's a use core in borrowck/mod.rs that also gets warned about in stage[12]
[09:17:39] <dbaupp> and typeck/infer/region_inference.rs
[09:17:53] <dbaupp> possibly the same reason (?)
[09:19:11] <cmr> dbaupp: yeah. I'm waiting for tim's warning cleanup to get merged for those though.
[09:19:39] <dbaupp> oh, ok :)
[09:28:51] *** Joins: berak (chatzilla@4463979.4742BCFA.1A5CC7E5.IP)
[09:32:02] *** Joins: CanhTak (Mibbit@moz-18B09BA7.rev.sfr.net)
[09:33:38] *** Quits: CanhTak (Mibbit@moz-18B09BA7.rev.sfr.net) (Quit: http://www.mibbit.com ajax IRC Client)
[09:33:40] *** Quits: victorporof (victorporo@B86E46F.1B500F07.6A4F8DA2.IP) (Quit: victorporof)
[09:37:26] *** Joins: tiffany (kawaii@moz-1E0FE6E8.dhcp.embarqhsd.net)
[09:41:37] *** Joins: Cromulent (Cromulent@moz-983B638D.cable.virginmedia.com)
[09:45:55] *** Joins: spider-mario (spidermari@moz-2BC095A6.rev.sfr.net)
[09:52:38] *** Quits: thou (thou@moz-1C1CA9F7.fasttrackcomm.net) (Input/output error)
[09:59:17] *** Quits: zakora (NC@moz-8EAF945F.fbx.proxad.net) (Quit: Textual IRC Client: www.textualapp.com)
[10:05:22] *** Joins: q66 (q66@6EE9DE40.46454B5D.33AABD5F.IP)
[10:19:24] *** Joins: EXetoC (ex@moz-C741B177.customer.t3.se)
[10:20:18] *** Joins: wilsonk-laptop (kvirc@moz-39EFBFC2.cg.shawcable.net)
[10:20:50] *** Quits: wilsonk|2 (kvirc@moz-39EFBFC2.cg.shawcable.net) (Ping timeout)
[10:27:55] *** Joins: Dj_Sunwoo (Mibbit@8EAD7F70.DD996240.8F1562BB.IP)
[10:29:23] <Dj_Sunwoo> 10;) Hi all  i'm from Seoul Korea  N joy the Electro_Trance_ d[Â°_Â°]b [Afterhours FM]Sunwoo@Trance.house....:::[Old & New Tracks]:::...       Paul_van_Dyk_-_Live_at_A_State_of_Trance_600_Miami_24-03-2013-Razorato     http://sunwoo.inlive.co.kr/listen.pls  Tune_in_  
[10:29:30] <Dj_Sunwoo> 10:P
[10:32:37] *** Joins: ssbr (ssbr@A9D9D38C.B6F034AC.72A31D6.IP)
[10:33:53] *** Quits: jviereck (Adium@moz-2B0BB5C.dclient.hispeed.ch) (Quit: Leaving.)
[10:34:50] <Dj_Sunwoo> 10Are you lookin' for the  Electronic _House_Trance_files?   Why don't you Click!!   :P    
[10:34:53] <Dj_Sunwoo> 10http://soundcloud.com/indecentnoise/indecent-noise-radio-bosh-037
[10:40:53] *** Quits: Cromulent (Cromulent@moz-983B638D.cable.virginmedia.com) (Ping timeout)
[10:41:30] <dbaupp> nmatsakis: ^
[10:44:14] <EXetoC> :E
[10:44:39] *** Joins: BitPuffin (quassel@moz-8370D1B9.bredband.comhem.se)
[10:50:18] <Dj_Sunwoo> 10and   i'm sure that everyone like Armni van buuren ..right?   ;)   if you like  ...Armin   Click!!!  Look around.  http://www.astateoftrance.com/   
[11:07:55] *** Joins: judder (maradukewa@DABDEEA3.F2C0D0AC.78E362FE.IP)
[11:08:29] *** Quits: BitPuffin (quassel@moz-8370D1B9.bredband.comhem.se) (Client exited)
[11:11:34] *** Joins: BitPuffin (quassel@moz-8370D1B9.bredband.comhem.se)
[11:11:49] <Dj_Sunwoo> 10;)
[11:15:41] *** Joins: jviereck (Adium@moz-2B0BB5C.dclient.hispeed.ch)
[11:19:29] *** Joins: Cromulent (Cromulent@moz-983B638D.cable.virginmedia.com)
[11:23:15] *** Quits: Cromulent (Cromulent@moz-983B638D.cable.virginmedia.com) (Quit: KVIrc 4.2.0 Equilibrium http://www.kvirc.net/)
[11:23:25] <Dj_Sunwoo> 10Hi all  i'm from Seoul Korea  N joy the Electro_Trance_ d[Â°_Â°]b [Afterhours FM]Sunwoo@Trance.house....:::[Old & New Tracks]:::...          http://sunwoo.inlive.co.kr/listen.pls  Tune_in_   
[11:25:25] <Dj_Sunwoo> 10thanks~;)
[11:33:21] *** Joins: FrozenCow (FrozenCow@moz-9DF5D010.dynamic.upc.nl)
[11:34:08] <Dj_Sunwoo> 10http://kvirc.visualscripts.com   Good!!!  very  good!!:P
[11:34:21] <Dj_Sunwoo> 10;) thanks 
[11:34:52] <EXetoC> now where's that ban hammer
[11:35:11] <Dj_Sunwoo> 10EXetoC  ? 
[11:36:14] <ssbr> benning this person would be good.
[11:36:39] <Dj_Sunwoo> 10ssbr  Hey ;)
[11:44:27] <jaen> I have a burning urge to say HALT! HAMMERZEIT!, but I don't have a banhammer to back it up ; /
[11:45:22] *** nmatsakis sets mode: +b *!*Mibbit@*.DD996240.8F1562BB.IP
[11:45:41] <tiffany> at first I was pretty sure that's an entirely automated spambot but I don't think anyone would put as much time into trying to make it believable by having it randomly mention people who talk
[11:45:53] *** Dj_Sunwoo was kicked by nmatsakis (nmatsakis)
[11:46:24] <nmatsakis> ok, I don't really know what I'm doing when it comes to this sort of thing, but hopefuly that worked
[11:46:43] <jaen> tiffany: i don't think it's that hard, my bot in clojure did it
[11:47:43] <dbaupp> nmatsakis: looks like there are 100% fewer dj spammers
[11:48:11] *** Quits: rfw (rfw@moz-C65A114.rfw.name) (Ping timeout)
[11:48:32] *** Joins: rfw (rfw@moz-C65A114.rfw.name)
[11:51:26] *** Quits: libertas (libertas@2D228712.FAA7B709.593B3862.IP) (Ping timeout)
[11:51:46] *** Quits: thomaslee (thomaslee@moz-306D3DF4.hsd1.or.comcast.net) (Quit: Leaving)
[11:55:42] *** Joins: libertas (libertas@24705417.947171E6.593B3862.IP)
[12:11:28] *** Quits: akashj87_ (akash@C8DCA18.46EB02D4.35E3DDC8.IP) (Quit: Leaving)
[12:13:37] <aatch> Looks like I missed a party
[12:18:40] <dbaupp> aatch: the Electronic _House_Trance_files was pumping
[12:20:14] *** Quits: disjukr (disjukr@D4D5F731.A5F7C7E2.84F431B6.IP) (Quit: Leaving)
[12:23:08] *** Joins: robertknight (robertknig@moz-54528EE0.wby.mendeley.com)
[12:25:36] *** Quits: jviereck (Adium@moz-2B0BB5C.dclient.hispeed.ch) (Quit: Leaving.)
[12:25:58] *** Quits: robertknight (robertknig@moz-54528EE0.wby.mendeley.com) (Quit: Computer has gone to sleep.)
[12:26:13] *** Joins: disjukr (disjukr@D4D5F731.A5F7C7E2.84F431B6.IP)
[12:27:00] <aatch> Yay! my re-written queue doesn't segfault when you give it pointers!
[12:27:20] <aatch> (which is nice given that it has to store pointers to Tasks)
[12:28:23] <dbaupp> that sounds convenient
[12:28:37] <dbaupp> was the problem a double free?
[12:28:38] <ssbr> Is the reason that rust uses internal iterators for `for` loops so that code gets inlined nicely? I originally thought the reason was so that borrowed pointer lifetimes worked out, but those can be parameterized so it's fine.
[12:29:07] <dbaupp> ssbr: history, mostly. I guess
[12:29:18] <ssbr> dbaupp: what was the reason originally?
[12:29:48] <dbaupp> ssbr: no idea, I've really only be around (less than) 6 months
[12:29:57] <ssbr> Barp.
[12:29:58] <aatch> dbaupp, not sure. I was either getting invalid frees, segfaults or dangling allocations, depending on what I changed
[12:30:01] <ssbr> OK, thanks anyway :)
[12:31:10] <aatch> But in the process I wrote a ton of code to handle various conditions, then finally fixed the last issue which obviated all the previous work
[12:31:11] <kimundi> ssbr: The reason for internal iterator support is that they are easier to write
[12:31:40] <aatch> (the answer was zero-initializing the array)
[12:31:58] <kimundi> ssbr: However, they don't compose well, and some iterations are not possible to be written with them
[12:32:04] <ssbr> kimundi: ah, because rust doesn't / (maybe) can't have something like generators
[12:32:08] <ssbr> yeah, the composing has been bothering me
[12:32:19] <ssbr> I'm also finding that external iterators are really nice
[12:32:33] <kimundi> ssbr: external iteratiors are harder to write, but compose well, and can easily be converted to an internal
[12:32:42] <aatch> ssbr, well composability has increased a little with the new for loop protocol
[12:33:05] <kimundi> ssbr: I really recommend reading http://journal.stuffwithstuff.com/2013/01/13/iteration-inside-and-out/ :)
[12:33:21] <dbaupp> has the new for loop protocol landed?
[12:33:31] <aatch> dbaupp, I think it's landing
[12:33:35] *** Joins: jviereck (Adium@moz-2B0BB5C.dclient.hispeed.ch)
[12:33:39] <kimundi> That explains the main differences, and why it's not possible to generalise more than  external/internal
[12:33:39] <ssbr> I'm also just generally put off by the idea that "for ... { return; }" can loop forever
[12:34:00] <dbaupp> aatch: I don't see it on bors' queue...
[12:34:03] <aatch> ssbr, that's part of the reason for the new protocol
[12:34:21] <kimundi> ssbr: Well it" a libary call. Those can loop forever even if ity,s not a loop.
[12:34:39] <ssbr> kimundi: right, that's what gets to me.
[12:34:59] <ssbr> I only _really_ control the control flow within the closure, everything else is me asking the iterator nicely to do things
[12:35:21] <ssbr> AIUI anyway.
[12:35:59] <kimundi> ssbr: I'm still of the opinion that a return returns right away btw... Need to test it. Doesn't make sense otherwise...
[12:36:12] <aatch> Hang on, a return inside a closure will return from the function
[12:36:24] <dbaupp> ssbr: yeah... but you basically asking nicely whatever libraries you're using to do things always anyway
[12:36:25] <aatch> unless you mean for ... { break; } can loop forever
[12:36:36] <ssbr> aatch: for ... { return; } acts the same
[12:36:36] <dbaupp> aatch: only in a for loop (I think?)
[12:36:40] <pascal> What's the reason that callback definitions from C have to be *u8 and not the actual type of the fn?
[12:36:49] <kimundi> aatch: That's what I think too, but ssbr seems to have tested it and it didn't work that way. Wich I find strange myself...
[12:36:50] <dbaupp> rusti: let f = || { return; }; f()
[12:36:52] <rusti> more than 5 lines of output, pastebinned: http://sprunge.us/XAKQ
[12:37:23] <aatch> https://github.com/mozilla/rust/pull/6223
[12:37:51] <dbaupp> rusti: println("hi"); for 2u.times { return; } println("bye");
[12:37:52] <rusti> hi
[12:38:01] <ssbr> dbaupp: https://gist.github.com/ssbr/f0a1f8699cd148d17d8f
[12:38:27] <ssbr> that's a copy of rust incoming I built maybe 20 hours ago
[12:38:42] <ssbr> idk when the new for loops landed, and if they change anything
[12:39:10] <aatch> ssbr, does it work as expected if you have a semi-colon after the return?
[12:39:23] <kimundi> rusti: fn foo(f: fn() -> bool) { let mut i = 0; while i < 5 { if !f() { break; } i += 1;} } for foo { print("test") }
[12:39:23] <dbaupp> ssbr: hm, strange
[12:39:24] <rusti> foo.rs:5:27: 5:31 error: obsolete syntax: bare function type
[12:39:24] <rusti> foo.rs:5          fn foo(f: fn() -> bool) { let mut i = 0; while i < 5 { if !f() { break; } i += 1;} } for foo { print("test") }
[12:39:24] <rusti>                                     ^~~~
[12:39:24] <rusti> note: use `&fn` or `extern fn` instead
[12:39:24] <rusti> error: aborting due to previous error
[12:39:26] <ssbr> aatch: same behavior
[12:39:36] <kimundi> rusti: fn foo(f: &fn() -> bool) { let mut i = 0; while i < 5 { if !f() { break; } i += 1;} } for foo { print("test") };
[12:39:37] <rusti> testtesttesttesttest
[12:39:54] <kimundi> rusti: fn foo(f: &fn() -> bool) { let mut i = 0; while i < 5 { if !f() { break; } i += 1;} } for foo { print("test "); break };
[12:39:54] <rusti> test
[12:39:57] <dbaupp> rusti: fn foo(f: &fn() -> bool) { let mut i = 0; while i < 5 { if !f() { break; } i += 1;} } for foo { print("test"); return; };
[12:39:58] <rusti> test
[12:40:04] <kimundi> rusti: fn foo(f: &fn() -> bool) { let mut i = 0; while i < 5 { if !f() {  } i += 1;} } for foo { print("test "); break };
[12:40:04] <rusti> test test test test test
[12:40:16] <kimundi> rusti: fn foo(f: &fn() -> bool) { let mut i = 0; while i < 5 { if !f() {  } i += 1;} } for foo { print("test "); return; };
[12:40:17] <rusti> test test test test test
[12:40:22] <ssbr> BAM
[12:40:22] <aatch> The new loop protocol landed 11 hours ago btw.
[12:40:37] <ssbr> aatch: OK, I'll rebuild incoming when I next take a break
[12:40:56] <ssbr> anyway, this is what I find disturbing about internal iterators
[12:41:07] <aatch> ssbr, that's a bug
[12:41:10] <ssbr> that, and that external iterators are very composable'manipulable
[12:41:15] *** Quits: an0nymous (an0nymous@moz-A6B0CE4.tx.res.rr.com) (Input/output error)
[12:41:27] <ssbr> aatch: it seems like the only natural behavior to me. anything else would be "magic"
[12:41:36] <ssbr> after all, if return can exit the iterator, why can't break?
[12:41:40] <aatch> ssbr, for loops are already magical
[12:42:01] <ssbr> aatch: they don't look magical to me. It's just some syntax sugar around a function call, isn't it?
[12:42:17] <aatch> ssbr, yes, but they also re-write break and loop statements
[12:42:32] <samebchase> Does this look alright: https://github.com/mozilla/rust/pull/6414/files ?
[12:42:46] <ssbr> aatch: right, but that's a whole different game from making "return" exit not just out of a closure, but out of the function calling the closure
[12:42:53] <ssbr> which is Very magical
[12:43:25] <dbaupp> samebchase: any particular reason for spaces on both sides of the : ?
[12:43:35] <kimundi> ssbr, aatch: It seems there is simply more magic in a for loop than thought: http://static.rust-lang.org/doc/rust.html#for-expressions
[12:43:54] <aatch> And any reason you aren't using methods?
[12:44:13] <dbaupp> (bors looks crashed... :( )
[12:44:18] <aatch> kimundi, that is exactly what I thought.
[12:44:24] <kimundi> Apparently, the closure really needs to exit AND ADDITIONALLY an extra flag gets set behind the scenes so that it returns
[12:44:37] <aatch> It's based on Ruby's protocol
[12:44:48] <aatch> so it naturally follows the same semantics.
[12:44:59] <dbaupp> samebchase: acc.push_str("foo") works :)
[12:45:01] <z0w0> brson's obsession with emoticons is starting to scare me
[12:45:12] <aatch> z0w0, I've noticed that too
[12:45:13] <samebchase> dbaupp: no strong/good reason. I just thought it'd look more symmetric that way
[12:45:26] <ssbr> kimundi: yeah, that's what I expected
[12:45:36] <ssbr> "return" is like a break that also returns something after the for loop returns
[12:45:44] <ssbr> but it can't actually force the for loop to return
[12:45:46] <ssbr> without Magic
[12:45:58] <kimundi> ssbr: Yeah, I thought it was implemented otherwise, my bad :)
[12:45:58] *** Parts: berak (chatzilla@4463979.4742BCFA.1A5CC7E5.IP) ()
[12:46:10] <dbaupp> samebchase: most languages/formats seems to not have the space before the : (e.g. javascript, python, json)
[12:46:31] <aatch> if you are using ':' then no space.
[12:46:42] <samebchase> dbaupp: okay. I'll do it the Python way and also do acc.push_str
[12:47:13] <dbaupp> samebchase: also, you don't need ~"foo bar"... in most cases (except ~"{"), you can use a static string, e..g ", " and ": "
[12:47:21] <aatch> since you wouldn't put a space if you were using it in regular text
[12:47:21] *** Joins: Yurume (yurume@AC58A8CE.8A059B47.E313B915.IP)
[12:47:45] <dbaupp> (the ~ represent memory allocations, which should be avoided as much as is reasonable in the stdlib.)
[12:48:21] <dbaupp> rusti: let mut acc = ~"{"; acc.push_str(", "); acc
[12:48:23] <rusti> ~"{, "
[12:49:20] <dbaupp> samebchase: alsoalso, the to_str instance might be better in hashmap.rs
[12:49:31] <dbaupp> (but maybe not)
[12:49:45] <samebchase> dbaupp: you want {3: 5, 6: 7} ?
[12:49:58] <dbaupp> samebchase: yup
[12:50:01] <samebchase> okay
[12:50:24] <aatch> mostly because it's not "this is a list : 1, 2, 3"
[12:50:58] <aatch> samebchase, also, for future reference, pointers are automatically borrowed
[12:51:18] <aatch> Actually, nevermind
[12:51:28] <aatch> (misread the code slightly)
[12:52:23] <samebchase> 1. acc.push_str 2. offcentre ":" 3. no "~" except the first "{" ?
[12:52:36] <aatch> samebchase, yep.
[12:52:45] <aatch> I made some comments to that effect
[12:52:48] <dbaupp> samebchase: also, (only if you feel like it) you could add ToStr for HashSet... the format would/could be {4, 2, 1, 3}
[12:53:49] <samebchase> dbaupp: cool. I'll see what I can do.
[12:54:26] <samebchase> Rust takes 20 min to build (w/o having to build llvm) and 20 more minues to run all the tests. Is this normal?
[12:54:44] <dbaupp> yes
[12:55:15] <dbaupp> you can use `make check-stage1` (which only does one bootstrap)
[12:55:20] <kimundi> I'd call those times fast even.
[12:55:30] <dbaupp> and `make check-stage1-core` to only run the code tests
[12:56:00] <aatch> It takes me like an hour to do a full build :(
[12:56:19] <dbaupp> you can even go to src/libcore and run `rustc --test --cfg stage2 core.rc` to get the test runner without doing the bootstrap
[12:56:40] <aatch> dbaupp, sometimes anyway
[12:56:41] <dbaupp> (assuming you have a relatively recent rustc installed/available)
[12:56:48] <dbaupp> aatch: yup
[12:56:51] <samebchase> aatch: woah. How do you manage to get work done?
[12:56:54] <indutny> hey people
[12:57:03] <aatch> samebchase, multiple workspaces
[12:57:07] <indutny> can mod "re-export" structs and functions from another mod?
[12:57:11] <aatch> I think brson has like 4-5 at once
[12:57:30] <dbaupp> samebchase: there are a few general tricks here https://github.com/mozilla/rust/wiki/Note-testsuite
[12:57:34] <aatch> so you have 1 building while you work on the next.
[12:57:50] <aatch> Or you do the bulk of the work outside the tree and merge it in.
[12:57:51] <samebchase> aatch: hmm
[12:58:05] <dbaupp> aatch: I always screw up with that... editing a file in the wrong workspace and wondering why my changes aren't showing up :(
[12:58:21] <aatch> dbaupp, which is why I don't actually do it lol
[12:58:24] <indutny> (nvm, figured it out)
[12:59:30] <samebchase> How do you guys manage to have multiple rust compilers on your system? I'm doing out of source builds, and I plan to have a seperate build for my branch in future. I symlink rustc to the "install" dir.
[13:00:05] <aatch> samebchase, I just add the directory to my PATH for the session.
[13:00:23] <samebchase> oh. that's simpler.
[13:03:43] <aatch> Woo, automatic growing works too!
[13:03:50] *** Joins: mcomella (mcomella@moz-B10FF54F.ri.ri.cox.net)
[13:04:54] <dbaupp> aatch: :D ... shrinking?
[13:05:06] <aatch> dbaupp, not even implemented :P
[13:05:21] <aatch> I'm more worried about concurrency atm.
[13:05:43] *** Quits: mcomella (mcomella@moz-B10FF54F.ri.ri.cox.net) (Quit: Leaving)
[13:05:51] *** Joins: mcomella (mcomella@moz-B10FF54F.ri.ri.cox.net)
[13:06:39] <aatch> It works as a queue though
[13:07:18] <thiez> do we have explicit alignment in the language?
[13:07:21] <dbaupp> that's pretty good
[13:07:30] <dbaupp> *and* it's not segfaulting
[13:07:39] <aatch> dbaupp, yep, with growing too and everything
[13:07:59] <dbaupp> thiez: other than using #[packed] structs with [u8, .. size] padding, no
[13:08:00] <aatch> Now I'm implementing a test to make sure it doesn't segfault when I have massive concurrent access.
[13:08:24] <dbaupp> thiez: (as far as I know... I could be wrong.)
[13:09:00] <dbaupp> aatch: massive == 100 or 1000000 ?
[13:09:41] <aatch> dbaupp, ~20, but that's individual threads that are /only/ stealing, no other work
[13:09:48] <thiez> dbaupp: I'll take your word for it :D
[13:10:22] <dbaupp> aatch: so it's getting a work out
[13:10:30] <aatch> dbaupp, yep
[13:10:48] <aatch> hopefully it'll be enough to exercise the race conditions I have to detect
[13:13:22] <dbaupp> as in, the ones that (in theory) aren't a problem because of the way the algorithm is designed, right? (not some other problem... ?)
[13:13:44] *** Joins: MrFahrenheit (RageOfThou@3FEF494C.29C984D5.783DEDCA.IP)
[13:13:54] <aatch> dbaupp, more like the "Somebody took the element we were about to take, detect it and do something else" races
[13:14:06] <aatch> as in, it would be a race if there wasn't detection code
[13:14:16] <dbaupp> oh, yeah... the expected ones :)
[13:14:27] <aatch> obviously single-threaded code can't exercise those checks
[13:14:41] <aatch> but those bits are the entire reason for using the algorithm
[13:14:52] <aatch> (stupid concurrency)
[13:16:14] *** Quits: MrFahrenheit (RageOfThou@3FEF494C.29C984D5.783DEDCA.IP) (Connection reset by peer)
[13:20:05] <thiez> concurrency is fun
[13:20:25] <indutny> hm...
[13:20:34] <indutny> still have a problem with struct and impl in different files
[13:20:48] <aatch> thiez, I agree, just hard to test
[13:20:48] <indutny> how can I make impl visible for 3rd paries?
[13:20:58] <aatch> indutny, pub impl?
[13:21:08] <indutny> doesn't work
[13:21:18] <indutny> says this syntax is no longer supported
[13:21:37] <indutny> `pub` or `priv` is meaningless for trait implementations, because the `impl...for...` form defines overloads for methods that already exist; remove the `pub` or `priv`
[13:21:38] <indutny> well
[13:21:39] <indutny> this ^
[13:21:59] <aatch> indutny, then it's already exported
[13:22:03] <indutny> well
[13:22:06] <indutny> I can't see it
[13:22:06] <thiez> aatch: you may wish to test on some other processors too, x86/x64 can be too forgiving
[13:22:16] <indutny> I'll publish gist
[13:22:19] <aatch> thiez, I don't have that luxury
[13:22:22] <kimundi> indutny: impl TYPe or impl TRAIT for TYPE?
[13:22:38] <indutny> impl<K> Trait for Struct<K> {}
[13:22:51] <indutny> and `pub trait Trait { â€¦ }` before it
[13:22:53] <aatch> thiez, but I'm just making sure that my invariants are, well, invariant.
[13:22:58] <indutny> with `pub fn method(...)`
[13:23:07] <kimundi> that is automatically visible if the trait isvisible
[13:23:23] <indutny> let me upload files...
[13:23:25] <aatch> indutny, is the Struct public?
[13:23:30] <indutny> yes
[13:23:35] <indutny> but its in another mod
[13:23:48] <indutny> I use struct
[13:23:53] <kimundi> its not possible to make a impl TRAIT for TYPE public or private, its automatically visible through the trait
[13:23:54] <indutny> and other methods are visible
[13:23:59] <dbaupp> indutny: you need to have the trait in scope
[13:24:09] <indutny> err
[13:24:10] <indutny> one se
[13:24:12] <indutny> uploading files :)
[13:24:23] <dbaupp> so you might need to put `use module::Trait` as well
[13:24:47] <thiez> btw, I'm not sure we can make the atomic primitives work with all numeric types, not all hardware supports atomic stores to locations smaller than a machine-word afaik
[13:25:09] <indutny> https://gist.github.com/indutny/cefdad0cefd3159412f3#file-tests-rs-L20
[13:25:10] <thiez> you'd have to pad and use the int-atomics anyway :(
[13:25:13] <indutny> basically, allocate is invisible here
[13:25:30] <aatch> thiez, yeah, I know, it's just a pain having to cast everywhere.
[13:25:33] <indutny> dbaupp: I've use module::Trait
[13:25:59] <dbaupp> indutny: you need it in tests.rs
[13:26:03] <indutny> aah
[13:26:12] <indutny> yay
[13:26:12] <indutny> it works!
[13:26:13] <indutny> thank you
[13:26:22] <indutny> still its odd that it isn't exported
[13:26:38] <indutny> why does rust have such semantics?
[13:26:42] <dbaupp> indutny: it is exported, just via the trait
[13:26:47] <indutny> well
[13:27:01] <indutny> hm...
[13:27:01] <thiez> aatch: I'll see what I can do :)
[13:27:13] <aatch> thiez, don't worry too much about it.
[13:27:19] <indutny> dbaupp: ok, I'll just deal with it
[13:27:34] <aatch> If I was that bothered, I would have done it myself.
[13:29:11] *** Quits: ivan (ivan@moz-531C3EC9.members.linode.com) (Ping timeout)
[13:29:17] <thiez> it would be nice to have a DS9K-like machine for concurrency
[13:29:53] <aatch> thiez, my use case was also fairly benign, along the lines of "now it will only be able to run for 60 years on 32-bit platforms before crashing instead on 10000 years"
[13:30:26] <aatch> thiez, DS9K?
[13:30:35] <dbaupp> indutny: I can understand why it's confusing, i've been tripped up by it a few times :)
[13:30:42] <indutny> hehe
[13:30:52] *** Joins: ivan (ivan@moz-531C3EC9.members.linode.com)
[13:30:58] <indutny> yeah, I'm just considering it from the point of API
[13:31:07] <indutny> because I'm writing a library and will use it later
[13:31:20] <indutny> and importing some internal traits to make it work...
[13:31:25] <indutny> doesn't really look like a good API
[13:31:28] <dbaupp> aatch: (thiez is talking about datatypes smaller than a word, not larger. I think.)
[13:31:32] <thiez> aatch: the DeathStation9000 was a hypothetical machine that followed the C-standard exactly, but failed in creative and destructive ways whenever there was undefined behavior
[13:31:40] <thiez> dbaupp: I was
[13:32:02] <aatch> thiez, apologies, I mis-read
[13:32:33] <aatch> thiez, that sounds awesome.
[13:32:35] <dbaupp> indutny: you might have to reorganise to package up the external API into a few traits... unfortunately
[13:32:49] <indutny> that breaks modularity
[13:33:06] <samebchase> dbaupp: I'm getting a" 63:35 error: type `~str` does not implement any method in scope named `push_str`
[13:33:06] <indutny> and makes impossible splitting code into multiple files
[13:34:25] <aatch> samebchase, is it mutable?
[13:34:32] <samebchase> yeah
[13:34:34] *** Joins: maxli (maxli@C03F2759.C70D537E.2FA4EA88.IP)
[13:35:03] <samebchase> the same code works in a test file.
[13:35:17] <aatch> http://static.rust-lang.org/doc/core/str.html#implementation-of-ownedstr-for-str
[13:36:29] <dbaupp> samebchase: you might need to put `use str::OwnedStr` at the top of the file to import the trait
[13:37:32] <kimundi> indutny: Well, you'r using an internal api in those tests, what did you expect?
[13:37:43] <indutny> that's not internal API
[13:37:48] <samebchase> dbaupp: thanks. It seems to work now.
[13:38:00] <indutny> I'm just trying to split graph builder and allocator
[13:38:01] <dbaupp> indutny: you can define a trait like `trait API { fn foo(&self); }`
[13:38:04] <indutny> s/split/separate/
[13:38:06] <dbaupp> indutny: `impl<A: Internal1 + Internal2> API for A { fn foo(&self) { self.other_foo() } }`
[13:38:17] <indutny> hm...
[13:38:21] <indutny> yeah, thank you
[13:38:26] <indutny> I'll definitely do it
[13:38:26] <dbaupp> and that can just be wrapper for several traits
[13:39:43] *** Quits: FrozenCow (FrozenCow@moz-9DF5D010.dynamic.upc.nl) (Ping timeout)
[13:40:37] *** Joins: Cromulent (Cromulent@moz-983B638D.cable.virginmedia.com)
[13:45:41] *** Quits: jaen (jaen@moz-E0979827.copit.pl) (Ping timeout)
[13:46:21] *** Joins: jaen (jaen@moz-27EED90D.play-internet.pl)
[14:03:07] *** Quits: z0w0 (zack@D1D2DBCB.806EA3ED.2CE63F58.IP) (Quit: Leaving.)
[14:06:33] <indutny> dbaupp: still it feels odd :P
[14:08:51] <aatch> dbaupp, Woo, I managed to get a 13,000 entry long backtrace
[14:10:48] <dbaupp> indutny: yep, it is a bit strange
[14:11:01] <dbaupp> aatch: only 13,000? try harder next time :P
[14:11:06] <dbaupp> how??
[14:11:36] <aatch> dbaupp, turns out that trying to the borrow the local scheduler when it doesn't exist causes an infinite loop
[14:12:23] <heftig> aatch: the wonders of split stacks?
[14:12:50] <aatch> I think it tries to borrow the local scheduler, fails, and then tries to print a message saying so, which requires the local scheduler to allocate memory
[14:19:32] *** Quits: BizarreCake (BizarreCak@32C9829A.151E84E7.561471F8.IP) (Ping timeout)
[14:19:36] *** Joins: mzabaluev (mzabaluev@moz-91FFD755.dhcp.inet.fi)
[14:23:10] *** Quits: mzabaluev (mzabaluev@moz-91FFD755.dhcp.inet.fi) (Ping timeout)
[14:25:01] <aatch> man, I am getting the /best/ errors at the moment
[14:25:01] *** Quits: mcomella (mcomella@moz-B10FF54F.ri.ri.cox.net) (Connection reset by peer)
[14:25:43] *** Joins: mcomella (mcomella@moz-B10FF54F.ri.ri.cox.net)
[14:25:45] <thiez> of the 'interesting' variety?
[14:26:03] <aatch> thiez, of the non-deterministic variety.
[14:26:19] <aatch> I'm getting segfaults sometimes, other times just task failure
[14:26:56] <thiez> sounds like fun, is your code online?
[14:26:59] <aatch> and random number successfully added items to the queue.
[14:27:03] <aatch> thiez, not at the moment.
[14:27:33] <aatch> I'll try to eliminate some confounding variables.
[14:29:38] *** Joins: jtheterrible (Mibbit@moz-EEA9CFB3.nyc.res.rr.com)
[14:30:34] *** Quits: maxli (maxli@C03F2759.C70D537E.2FA4EA88.IP) (Quit: Leaving.)
[14:31:52] *** Joins: haard (fredrik@moz-6A86987C.dynamic.se.alltele.net)
[14:32:44] *** Joins: rgrinberg (rgrinberg@AE999E95.52DE4C60.258AD6F5.IP)
[14:33:30] *** Quits: Cromulent (Cromulent@moz-983B638D.cable.virginmedia.com) (Ping timeout)
[14:36:32] *** Joins: BizarreCake (BizarreCak@32C9829A.151E84E7.561471F8.IP)
[14:37:30] *** Quits: rgrinberg (rgrinberg@AE999E95.52DE4C60.258AD6F5.IP) (Ping timeout)
[14:39:49] <jtheterrible> hi all, noob q on fixed-size vectors:  why can't i 'let k: ~[u8,..4] = ~[1,2,3,4];'?
[14:39:59] *** Quits: cstrahan (cstrahan@moz-4C7E5789.hsd1.dc.comcast.net) (Ping timeout)
[14:40:35] <aatch> jtheterrible, because ~[] is a dynamic vector
[14:40:50] <kimundi> jtheterrible, use ~([1,2,3,4])
[14:40:52] <aatch> rusti: let k: ~[u8,..4] = ~([1,2,3,4]); k
[14:40:53] <rusti> ~[1, 2, 3, 4]
[14:41:17] <EXetoC> oh
[14:43:40] <doener> hm, feels similar to "foo" being &'static str, &"foo" being &str and &(str) being &&'static str
[14:43:55] <aatch> doener, because it is the same
[14:43:57] <doener> err, the last one should of course be &("foo")
[14:44:35] <jtheterrible> ok, thanks.
[14:45:18] <aatch> both ~[] and ~str (and variants) are special-cased in the grammar 
[14:45:40] <aatch> which is why `[]` and `str` aren't valid types
[14:47:10] <jtheterrible> follow up:  trying to insert into a LinearMap<~[u8,..4], uint>, the compiler complains "failed to find an implementation of trait core::to_bytes::IterBytes for [u8 * 4]"
[14:47:30] <aatch> jtheterrible, that would be because there isn't one...
[14:48:23] <jtheterrible> but then when I try to impl IterBytes for [u8,..4], it complains "cannot provide an extension implementation for a trait not defined in this crate"
[14:49:26] <jaen> aatch: is there any reason ~"a" isn't sugared to "a", since they are always references?
[14:49:36] <cyndis> fixed size arrays are problematic at the moment because you can't parametrize the size
[14:49:49] <cyndis> better to just use dynamically sized ones
[14:49:58] <aatch> jaen, because "a" is always a static string.
[14:50:16] <aatch> they are different types.
[14:50:20] <thiez> I get many 'cannot borrow immutable captured outer variable as mutable' errors with incoming, am I doing something wrong?
[14:50:34] <thiez> this worked a week ago... :D
[14:50:40] <jaen> ook, looks like I need to rtfm, I must have missed something
[14:50:45] <thiez> also 'cannot borrow immutable non-lvalue as mutable'
[14:50:50] <aatch> thiez, there have been a lot of changes in the last week
[14:51:04] <aatch> including a massive patch that nmatsakis landed
[14:51:20] <thiez> that patch has some annoying consequences
[14:51:21] <aatch> that fixed a lot of issues with the borrow checker
[14:51:36] <aatch> thiez, it makes things more safe.
[14:51:51] <thiez> for example, 'rand::task_rng().next()' gives me 'cannot borrow immutable non-lvalue as mutable'
[14:52:13] *** Joins: Cromulent (Cromulent@moz-983B638D.cable.virginmedia.com)
[14:52:30] <thiez> seems I have to break up many chained methods just to satisfy the borrow checker
[14:52:39] <aatch> thiez, yep
[14:52:48] <thiez> but the original is perfectly safe?
[14:52:48] *** Quits: Cromulent (Cromulent@moz-983B638D.cable.virginmedia.com) (Quit: KVIrc 4.2.0 Equilibrium http://www.kvirc.net/)
[14:53:30] <aatch> thiez, it's really complicated
[14:54:30] <jaen> aatch: looked at the fine manual, so it's more like &"str" sugared to "str", yes?
[14:55:01] <aatch> jaen, I'm not sure what you mean by "sugared"
[14:56:21] <doener> coerced maybe?
[14:56:25] <jaen> I mean what sort of string is a string without a sigil, but I get it now, sorry for having a brainfart.
[14:56:36] <jtheterrible> think i've got it, thanks all.
[14:56:38] <thiez> rusti: struct S; impl S { fn new() -> S { S } fn foo(&mut self) -> int {8} } S::new().foo() // but it was so very convenient :(
[14:56:39] <rusti> more than 5 lines of output, pastebinned: http://sprunge.us/aJUe
[14:56:59] *** Parts: jtheterrible (Mibbit@moz-EEA9CFB3.nyc.res.rr.com) ()
[14:57:25] <aatch> "foo" is a &'static str, ~"foo" is a ~str, @"foo" is a @str and &"foo" is a &str
[14:57:47] <jaen> Ok, that seems about right, sorry.
[14:58:06] <aatch> thiez, but mutability has consequences for borrowing though
[14:58:10] <dbaupp> thiez: rand::random() should work for that specific example
[14:58:39] <thiez> dbaupp: sure, but it seems this kills many perfectly acceptable instances of method chaining
[14:59:03] <jaen> I just confused myself when I was wondering if some syntax sugar for not repeating the sigil in ~[~"a", ~"b"] would make any sens
[14:59:23] <aatch> jaen, not really.
[14:59:29] <dbaupp> thiez: yes (it was just in case you were looking to use the task_rng)
[14:59:35] <jaen> Ok, I see
[14:59:46] <thiez> dbaupp: so is this temporary?
[15:00:07] <aatch> since the compiler would now be making some probably-invalid assumptions
[15:00:30] <aatch> and you'd then need even more syntax to undo it.
[15:00:49] <dbaupp> thiez: what is temporary?
[15:01:06] <aatch> "But I /wanted/ an owned vector of static strings!"
[15:01:13] <thiez> dbaupp: this limitation on method chaining
[15:01:54] <dbaupp> thiez: no idea, probably... there is https://github.com/mozilla/rust/pull/5974
[15:01:56] <thiez> if 'let mut x = someFn() ; x.someMutSelfFn()' is safe, then I want to be able to do 'someFn().someMutSelfFn()'
[15:02:00] <jaen> aatch: yeah, that looks like something that would produce even more syntax unfortunately...
[15:02:26] <thiez> beautiful, can't wait for that pr to land :)
[15:03:00] *** Joins: mzabaluev (mzabaluev@moz-91FFD755.dhcp.inet.fi)
[15:03:10] <kimundi> aatch: Something similar to that could in theory be implemented as deep borrowing onc nmatsakis Unsized typen proposal gets implemented
[15:04:00] <aatch> kimundi, yeah, that's the next big thing I want to see.
[15:05:17] <kimundi> As in: It might be possible in principle for ~[~str] to coerce to &[&str]. WOuld still need a additional change to ~[] vectors though
[15:05:39] <aatch> kimundi, that kind of coercion would be nice
[15:05:52] <aatch> I've run into it
[15:09:45] <kimundi> aatch: It just has a few problems. A ~[] includes a capacity field, so that would have to be stored at an offset inaccessible from it's representation as &[], wich wuold complicate it a bit more. And the question is if it's desirable to have deep coercions like that. They could only work on structural types, as you can't just change the parts of an nominal type and have it still be usable.
[15:10:07] <indutny> rust: task failed at 'ty_fn_sig() called on non-fn type: &ty_err', /Users/indutny/Code/mozilla/rust/src/librustc/middle/ty.rs:2773
[15:10:09] <indutny> ohai
[15:10:20] <aatch> indutny, yeah, I think that's a regression
[15:10:27] <aatch> since I've hit it a few times.
[15:10:32] <indutny> hm...
[15:10:34] <indutny> ok, just FYI
[15:10:41] <aatch> basically, you have a type error somewhere
[15:10:50] <aatch> and you are trying to call a method on the type error
[15:11:27] <indutny> oh, great
[15:11:28] <indutny> :)
[15:12:02] *** Joins: ljrmorgan (Mibbit@moz-63C2D615.sgyl.cable.virginmedia.com)
[15:12:06] <indutny> ah no
[15:12:12] <indutny> it was just allocation of SmallIntMap::new()
[15:12:16] <indutny> without type declaration
[15:12:22] <indutny> well, almost the same
[15:12:28] <indutny> but a bit different
[15:12:41] <indutny> rusti: let x = SmallIntMap::new()
[15:12:41] <rusti> foo.rs:6:4: 6:5 error: expected `;` but found `}`
[15:12:41] <rusti> foo.rs:6     });
[15:12:41] <rusti>              ^
[15:12:44] <aatch> indutny, it can't infer the type.
[15:12:44] <indutny> rusti: let x = SmallIntMap::new();
[15:12:45] <rusti> more than 5 lines of output, pastebinned: http://sprunge.us/MFPb
[15:13:17] <samebchase> aatch: https://github.com/mozilla/rust/pull/6414
[15:16:47] <aatch> samebchase, looks ok to me
[15:17:12] <samebchase> hmm.
[15:17:28] *** Quits: jviereck (Adium@moz-2B0BB5C.dclient.hispeed.ch) (Quit: Leaving.)
[15:18:10] <aatch> r+'d
[15:18:14] <thiez> rusti: struct S; impl S { fn new() -> S { S } fn foo(&self) -> S {*self} } S::new().foo()
[15:18:16] <rusti> {}
[15:18:20] <thiez> rusti: struct S; impl S { fn new() -> S { S } fn foo(&'self self) -> S {*self} } S::new().foo()
[15:18:21] <rusti> error: internal compiler error: unexpected failure
[15:18:21] <rusti> note: the compiler hit an unexpected failure path. this is a bug
[15:18:21] <rusti> note: try running with RUST_LOG=rustc=1,::rt::backtrace to get further details and report the results to github.com/mozilla/rust/issues
[15:18:23] <thiez> boom :D
[15:19:20] *** Quits: BitPuffin (quassel@moz-8370D1B9.bredband.comhem.se) (Ping timeout)
[15:19:38] <samebchase> aatch: what does "r+'d" mean reported?
[15:19:46] <aatch> samebchase, approved
[15:19:53] <dbaupp> rusti: struct S; impl S { fn new() -> S { S } fn foo<'r>(&'r self) -> S {*self} } S::new().foo()
[15:19:54] <rusti> {}
[15:20:06] <samebchase> heh, that's non intuitive
[15:20:06] <dbaupp> samebchase: "review positive"
[15:20:07] <aatch> it tells bors (the integration bot) to add it to it's queue
[15:20:10] <samebchase> oh.
[15:20:30] <dbaupp> (you'll occasionally see r- around too)
[15:20:41] <aatch> dbaupp, what's r- for?
[15:20:48] <aatch> (I've never seen it)
[15:21:05] <dbaupp> aatch: rejection
[15:21:31] <aatch> dbaupp, what's the purpose? just notation?
[15:21:34] <dbaupp> I've seen it once or twice "r- I was thinking we should do foo. I've got a branch with bar."
[15:21:42] <dbaupp> I guess so
[15:21:52] <aatch> Since bors doesn't need to know about it.
[15:21:58] <dbaupp> yup
[15:22:12] *** Quits: mzabaluev (mzabaluev@moz-91FFD755.dhcp.inet.fi) (Ping timeout)
[15:22:27] *** Quits: judder (maradukewa@DABDEEA3.F2C0D0AC.78E362FE.IP) (Client exited)
[15:23:12] *** Joins: judder (maradukewa@DABDEEA3.F2C0D0AC.78E362FE.IP)
[15:24:04] *** Joins: BitPuffin (quassel@moz-8370D1B9.bredband.comhem.se)
[15:24:18] *** Joins: artemgr (Mibbit@A84065D0.D3908BC4.B5A68B59.IP)
[15:25:26] <aatch> dbaupp, in other news, I seem to be getting closer to getting this working wrt races
[15:25:55] <dbaupp> fewer explosions?
[15:25:58] <dbaupp> :)
[15:26:10] <aatch> dbaupp, yep
[15:27:50] <aatch> It's hard to tell which are from me getting things wrong while I try to trick the compiler into letting me share state and which are from errors in the actual code.
[15:31:25] <aatch> dbaupp, 4 runs of the test: 1: 1004 dangling allocations, 2: segfault, 3: invalid free, 4: succeeded
[15:31:48] <dbaupp> wow
[15:32:00] <dbaupp> that'll be fun to debug :P
[15:32:30] *** Joins: leal (user@moz-BC5B28B3.c3-0.smr-ubr2.sbo-smr.ma.cable.rcn.com)
[15:32:33] <aatch> dbaupp, yeah...
[15:33:08] <thiez> what was the trick to get the llvm ir assembly from rustc again?
[15:33:23] <cmr> rustc --emit-llvm and llvm-dis, is what I use
[15:33:31] <thiez> thanks
[15:33:33] <dbaupp> thiez: rustc --emit-llvm -S
[15:33:37] <cmr> ah
[15:33:41] <dbaupp> (will output a .ll file)
[15:33:51] * aatch makes a lot of use of that
[15:34:21] <thiez> nice
[15:34:49] *** Quits: busylizzy (lisa@85228838.12D0DC84.211374C4.IP) (Input/output error)
[15:34:59] *** Joins: infynyxx (infynyxx@moz-E95B370B.nyc.res.rr.com)
[15:35:20] <ssbr> Aw crap. error: internal compiler error: Asked to compute contents of fictitious type
[15:35:40] <cmr> That's... a unique error.
[15:35:42] <bblum> that's a great error message
[15:36:04] <aatch> 3am is not a good time to debug race conditions.
[15:36:06] <ssbr> Any tips? I just was finishing up a fairly big refactor (switching from ~str to iterators), I have no idea what caused it among my numerous changes :(
[15:36:17] *** aatch is now known as aatch|bed
[15:36:49] *** Quits: BitPuffin (quassel@moz-8370D1B9.bredband.comhem.se) (Client exited)
[15:36:58] <dbaupp> aatch|bed: night!
[15:37:20] <aatch|bed> ssbr, parting gift: https://github.com/mozilla/rust/issues/6319
[15:37:43] <ssbr> aatch|bed: thank you :)
[15:37:48] <ssbr> (good night!)
[15:37:56] *** Quits: sk (sk@61A494B3.BA40E8A.AAC02D62.IP) (Input/output error)
[15:38:11] *** Joins: mdu (mdu@moz-9962C9F4.rev.numericable.fr)
[15:38:48] *** Joins: BitPuffin (quassel@moz-8370D1B9.bredband.comhem.se)
[15:41:05] <ssbr> I guess commenting out functions until it stops ICEing is a way to solve this, yeah?
[15:41:27] <ssbr> (to figure out at least where the error is)
[15:41:48] <cmr> mhm
[15:42:28] *** Joins: spaceships (spaceships@moz-8323E7E6.msl-mt.client.bresnan.net)
[15:42:28] <cmr> Is bors stuck? It has done anything at all in like 5 hours
[15:43:35] <thiez> ssbr: probably. We should have something like https://github.com/CyberShadow/DustMite/wiki for Rust :)
[15:44:25] <ssbr> thiez: Wow, that is neat. Yes, we should! :)
[15:46:11] *** Joins: busylizzy (lisa@85228838.12D0DC84.211374C4.IP)
[15:46:39] <sp3d> the name writes itself
[15:47:56] <kimundi> hmm, can subtracting numbers from a positive float until it reaches a value >0 but <1 decrease the precision of the remaining part of the number? The value of it would only get smaller, but I'm not sure if float subtraction can cause significant bits to get lost...
[15:49:01] <thiez> kimundi: what exactly did you have in mind?
[15:49:05] <cmr> kimundi: It shouldn't, as long as you don't get too small, afaik
[15:49:33] <thiez> if your starting number is big enough there might be nothing left
[15:51:22] *** Quits: leal (user@moz-BC5B28B3.c3-0.smr-ubr2.sbo-smr.ma.cable.rcn.com) (Ping timeout)
[15:51:40] <ssbr> well, I found the cause of the error
[15:52:00] <ssbr> "(i, '[') => i" in a pattern match. But AFAICT it's well-typed. Guh.
[15:52:00] <kimundi> Just trying to think about wether it's necessary to split a float into fractional and integer parts first to convert each part into a string representation, or wether I just can keep subtracting from the same variable in two loops.
[15:52:10] *** Joins: HOLYCOWBATMAN (Mibbit@moz-AB722A1C.mc.videotron.ca)
[15:53:07] <kimundi> thiez: Sure, if its to big the digits <1 never where there to begin with.
[15:53:36] <ssbr> If I match (_, _) it doesn't error out, but if I match (a, _) or (_, a) it ICEs
[15:53:40] <ssbr> ugh
[15:53:50] <dbaupp> ssbr: what's it matching on?
[15:54:08] <ssbr> Oh right
[15:54:09] <ssbr> heh
[15:54:11] <dbaupp> (and, what are the types?)
[15:54:20] <ssbr> that should be Some((x, y))
[15:54:23] <ssbr> not (x, y)
[15:54:28] <ssbr> so it wasn't well-typed after all'
[15:54:49] * ssbr checks if he can create a minimal test case with this in mind
[15:55:42] <dbaupp> rusti: match Some((1u, 'a')) => { (_, _) => 1u, _ => 2u }
[15:55:43] <rusti> foo.rs:5:31: 5:33 error: expected `{` but found `=>`
[15:55:43] <rusti> foo.rs:5          match Some((1u, 'a')) => { (_, _) => 1u, _ => 2u }
[15:55:43] <rusti>                                         ^~
[15:55:52] <dbaupp> rusti: match Some((1u, 'a')) { (_, _) => 1u, _ => 2u }
[15:55:53] <rusti> error: internal compiler error: adt::represent_type called on non-ADT type
[15:56:06] <ssbr> Yeah, I got that when I tried too.
[15:56:17] <ssbr> Well. A compiler error is a compiler error, right? :)
[15:56:39] <dbaupp> ssbr: https://github.com/mozilla/rust/issues/6319
[15:57:01] <dbaupp> it's already been discovered
[15:57:06] <ssbr> dbaupp: that one had to do with representing (), though
[15:57:12] <ssbr> () wasn't involved here
[15:57:43] <dbaupp> ssbr: it's presumably more general than just ()
[15:57:55] <ssbr> presumably
[15:58:21] <ssbr> the type-checker is surprisingly unsound, huh?
[15:58:33] <dbaupp> rusti: fn f(p: ~[Option<(uint, char)>]) { let (a,b) = p[0]; } f(~[Some((1,'a'))])
[15:58:34] <rusti> more than 5 lines of output, pastebinned: http://sprunge.us/IPQR
[15:58:41] <ssbr> (I guess "sound" probably has a technical meaning here, so I shouldn't say that precisely)
[15:59:15] <ssbr> rusti: match Some((1u, 'a')) { (x, _) => 1u, _ => 2u }
[15:59:16] <rusti> error: internal compiler error: Asked to compute contents of fictitious type
[15:59:19] <ssbr> there we go. :)
[15:59:33] <ssbr> Should I post this as a comment to that bug report then?
[15:59:38] <dbaupp> yup
[16:00:20] <ssbr> rusti: match Some((1u, 'a')) { (_, _) => 1u, _ => 2u }
[16:00:21] <rusti> error: internal compiler error: adt::represent_type called on non-ADT type
[16:01:08] <ssbr> done
[16:02:25] <thiez> kimundi: perhaps you can use some magic to 'unpack' the number as (mantissa,exponent)
[16:03:10] <thiez> perhaps then you can convert to a string without affecting precision
[16:05:03] <ssbr> This error is not good for me.
[16:05:14] <ssbr> I've confused Option<T> and T in a lot of places :(
[16:05:36] <kimundi> thiez: Maybe, but atm I'm just trying to understand if the subtraction would introduce errors. I'm currently walking through the floating point addition algorithm for that :)
[16:06:14] <thiez> it might. If I give you 1e100, good luck subtracting :p
[16:06:36] <ssbr> P.S. thank you very much dbaupp and aatch|bed for your help :)
[16:06:42] *** Joins: jviereck (Adium@moz-2B0BB5C.dclient.hispeed.ch)
[16:06:48] <dbaupp> ssbr: np :)
[16:07:03] <dbaupp> kimundi: there is floading point modulo, right?
[16:08:39] <kimundi> dbaupp: yup, that's not the problem. What I want to do I already have solved, just trying to see if I can do it better.
[16:09:36] <kimundi> That is, trace what is actually happening to the float, and see if I did some non obvios errors that might cause precisiosn loss under non-obvios  conditions
[16:09:48] *** Quits: artemgr (Mibbit@A84065D0.D3908BC4.B5A68B59.IP) (Quit: http://www.mibbit.com ajax IRC Client)
[16:10:13] <ssbr> Woo, successful compilation! :)
[16:10:21] <thiez> kimundi: how about performing your operations, then performing their opposites (in theory restoring the original number), then comparing?
[16:10:37] <thiez> try it for a few billion randomly generated floats... :D
[16:10:55] <thiez> (ofc a formal proof is nicer)
[16:10:58] <kimundi> thiez: He, that would also ba a possibility :D
[16:11:31] <ssbr> kimundi: subtracting floats is dangerous, you might end up doing that forever if you do it wrong :(
[16:11:36] <thiez> it would probably give you a quick counterexample if they are common
[16:11:48] <thiez> also what ssbr says
[16:11:50] <ssbr> what exactly are you subtracting?
[16:11:50] <kimundi> ssbr: Oh, I know that. 
[16:12:02] *** Quits: pyrac (pyrac@moz-B95F505.w92-156.abo.wanadoo.fr) (Quit: pyrac)
[16:12:16] <ssbr> (I only have like, one semester in numerical computing, but I can try to help)
[16:12:28] <kimundi> ssbr: decreasing powers of an arbitrary base until there are no bits left and it terminates
[16:13:08] <ssbr> kimundi: I wouldn't subtract non-base-2 things
[16:13:13] <kimundi> ssbr: Also had that stuff three semesters ago, atm trying to remember how it worked :)
[16:13:21] <dbaupp> kimundi: http://www.cs.indiana.edu/~burger/FP-Printing-PLDI96.pdf ?
[16:13:41] <ssbr> kimundi: like, implicitly converting it to binary on the way to the other base, will definitely work
[16:14:01] <ssbr> subtracting only powers of two
[16:14:15] <kimundi> ssbr: Well but I have to for my goal, so I'm trying to analyze what happens.
[16:14:28] <ssbr> :9
[16:15:06] <kimundi> ssbr: Oh wait, I didn't get that last part
[16:15:34] *** Joins: pyrac (pyrac@moz-B95F505.w92-156.abo.wanadoo.fr)
[16:16:00] *** Quits: ljrmorgan (Mibbit@moz-63C2D615.sgyl.cable.virginmedia.com) (Quit: http://www.mibbit.com ajax IRC Client)
[16:16:06] <kimundi> ssbr: what do you mean with implicitly converting it?
[16:16:14] <ssbr> I think I was saying nonsense
[16:16:30] <ssbr> I just mean that it's very safe to read out a base 2 number from a float
[16:16:50] <ssbr> and converting a base 2 number to base n is easy. But working on the float, I don't know, it's easy to make a mistake and then poof
[16:16:59] <ssbr> I think that only matters if you make a mistake though.
[16:17:05] <ssbr> (thus, nonsense)
[16:18:28] <ssbr> Ugh, assert_eq! output is basically unreadable: rust: task failed at 'left: ~[{start: 0, end: 1, ty: Token_Char('{')}, {start: 1, end: 2, ty: Token_Char('1')}, {start: 2, end: 3, ty: Token_Char('2')}, {start: 3, end: 4, ty: Token_Char(',')}, {start: 4, end: 5, ty: Token_Char('3')}] != right: ~[{start: 0, end: 1, ty: Token_Char('{')}, {start: 1, end: 2, ty: Token_Char('1')}, {start: 2, end: 3, ty: Token_Char('2')}, {start: 3, end: 4, ty: Token_Char('
[16:18:28] <ssbr> ,')}, {start: 5, end: 6, ty: Token_Char('3')}]', src/lex.rs:693
[16:18:34] <dbaupp> printing a floating point accurately has known solutions, so unless this has some special requirements, I think using a published algorithm would be more reliable
[16:18:59] <ssbr> (the answer is: hey look at token 5!)
[16:19:01] <kimundi> dbaupp: Yeah, looking at that paper.
[16:20:08] <kimundi> ssbr: Yeah, fmt!("%?", ...) is a problem for bigger structures sadly...
[16:20:50] <ssbr> I was thinking I probably wanted to write a PrettyDiff trait with definitions for all the types I need.
[16:21:21] <ssbr> Python unittest's assertEqual method is specialized for comparisons in all the builtin containers, for example
[16:21:50] <ssbr> so it can tell you, "hey, the left set has these extra elements: ... , and the right set has these extra elements: ..."
[16:21:55] <ssbr> and things such as that.
[16:21:57] <kimundi> ssbr: Problem is, how to abstract it? Need some way to structurally compare two types for differences... hm actally that could be done, just not with a simple equality check and %? ....
[16:22:06] *** Joins: blitter (blitter@moz-7C98731E.dyn.centurytel.net)
[16:22:42] <ssbr> kimundi: well, surely it's sufficiently abstracted just by having a trait for it
[16:23:21] <ssbr> there's some issues of what the diff method should take/return that lets you format everything nicely, but...
[16:23:27] *** Quits: jaen (jaen@moz-27EED90D.play-internet.pl) (Ping timeout)
[16:23:30] *** Joins: jaen (jaen@moz-E0979827.copit.pl)
[16:23:36] <kimundi> ssbr: Yeah, started it with the thought 'how to compare arbitrary types?', but both would have the same type, so no problem
[16:23:58] <ssbr> right.
[16:30:12] *** Quits: sp3d (a@moz-17CB39F1.fidnet.com) (Ping timeout)
[16:33:45] *** Quits: mdu (mdu@moz-9962C9F4.rev.numericable.fr) (Quit: mdu)
[16:36:42] *** Quits: infynyxx (infynyxx@moz-E95B370B.nyc.res.rr.com) (Client exited)
[16:43:52] <ssbr> Man, I'm up to 1600 lines of code, almost all of which is parsing
[16:44:01] <ssbr> life was better when I used someone else's parser for things.
[16:44:41] <kimundi> ssbr: You can do it! :)
[16:46:03] *** Joins: MrFahrenheit (RageOfThou@3FEF494C.29C984D5.783DEDCA.IP)
[16:48:35] *** Quits: pyrac (pyrac@moz-B95F505.w92-156.abo.wanadoo.fr) (Quit: pyrac)
[16:48:40] <ssbr> kimundi: I can, but I dun wanna! ;___;
[16:48:56] <ssbr> I should do something that isn't parsing for a bit. Like converting the entire webkit test bank to rust
[16:49:03] <ssbr> (webkit regexp test bank)
[16:51:33] <kimundi> I understand xD. I also don't want to rewrite the float-string conversion path a second time, but I kinda have to because my first attempt was ... imperformant :P
[16:51:46] *** Joins: pyrac (pyrac@moz-B95F505.w92-156.abo.wanadoo.fr)
[17:00:30] *** Quits: Jesin (Jessin_@moz-5654D37.washdc.fios.verizon.net) (Ping timeout)
[17:01:38] *** Joins: Jesin (Jessin_@moz-5654D37.washdc.fios.verizon.net)
[17:03:45] *** Joins: tedh (tedh@moz-F0B37C08.hsd1.il.comcast.net)
[17:04:22] *** Joins: catpig (catpig@moz-DB8BBE41.dip0.t-ipconnect.de)
[17:06:59] *** Joins: infynyxx (infynyxx@moz-E95B370B.nyc.res.rr.com)
[17:12:12] *** Quits: MX80 (MX80@moz-32BE33CD.dsl.g3telecom.net) (Ping timeout)
[17:13:04] *** Quits: infynyxx (infynyxx@moz-E95B370B.nyc.res.rr.com) (Ping timeout)
[17:14:14] *** Quits: pyrac (pyrac@moz-B95F505.w92-156.abo.wanadoo.fr) (Quit: pyrac)
[17:14:51] *** Joins: mzabaluev (mzabaluev@moz-91FFD755.dhcp.inet.fi)
[17:15:32] *** Joins: engla (engla@moz-DBD1D96E.cust.bredbandsbolaget.se)
[17:15:52] *** Joins: MX80 (MX80@moz-32BE33CD.dsl.g3telecom.net)
[17:16:54] *** Joins: pyrac (pyrac@moz-B95F505.w92-156.abo.wanadoo.fr)
[17:19:41] *** Quits: BizarreCake (BizarreCak@32C9829A.151E84E7.561471F8.IP) (Ping timeout)
[17:37:18] *** Joins: BizarreCake (BizarreCak@32C9829A.151E84E7.561471F8.IP)
[17:44:43] *** Quits: Axord (xord@moz-C3CCF156.lsanca.dsl-w.verizon.net) (Quit: I'm sure it's perfectly safe)
[17:48:06] *** Joins: dherman (dherman@moz-6CA476B1.hsd1.ca.comcast.net)
[17:48:06] *** ChanServ sets mode: +o dherman
[17:48:13] *** Quits: dherman (dherman@moz-6CA476B1.hsd1.ca.comcast.net) (Quit: dherman)
[17:49:26] *** Joins: zakora (NC@moz-8EAF945F.fbx.proxad.net)
[17:53:20] *** Quits: EXetoC (ex@moz-C741B177.customer.t3.se) (Quit: WeeChat 0.4.0)
[17:54:28] *** Joins: ghrust (ghrust@moz-4EF5B6E5.rs.github.com)
[17:54:28] <ghrust> 01[13rust01] 15bors 04force-pushed 06auto from 14e7c4967 to 1418a47f9: 02http://git.io/N3iJvQ
[17:54:28] *** Parts: ghrust (ghrust@moz-4EF5B6E5.rs.github.com) ()
[17:54:33] *** Joins: ghrust (ghrust@moz-4EF5B6E5.rs.github.com)
[17:54:33] <ghrust> 01[13rust01] 15bors pushed 3 new commits to 06auto: 02http://git.io/gQJbug
[17:54:33] <ghrust> 13rust/06auto 14ea5c413 15Huon Wilson: Perform expansion before stripping/building a test harness....
[17:54:33] <ghrust> 13rust/06auto 149b30fa3 15Huon Wilson: Correct testcases that passed because fns with #[test] were stripped before expansion.
[17:54:33] <ghrust> 13rust/06auto 1496de2b0 15bors: auto merge of #6383 : huonw/rust/rustc-expand-then-strip, r=thestinger...
[17:54:35] *** Parts: ghrust (ghrust@moz-4EF5B6E5.rs.github.com) ()
[17:56:45] *** Quits: mzabaluev (mzabaluev@moz-91FFD755.dhcp.inet.fi) (Quit: Ð£Ñ…Ð¾Ð¶Ñƒ Ñ Ð¾Ñ‚ Ð²Ð°Ñ)
[17:58:41] <BitPuffin> has anyone tried compiling rust code with emscripten yet?
[17:59:56] *** Joins: jensnockert (jensnocker@moz-8BE55278.customer.t3.se)
[18:00:51] <ssbr> BitPuffin: there's an open bug or two about that. It doesn't work.
[18:01:15] <ssbr> https://github.com/mozilla/rust/issues/2235
[18:01:55] <ssbr> Hm, I wonder if it works (better) now that you can use rust without the runtime?
[18:03:26] <kimundi> ssbr: afaik you can't use rust without the runtime yet?
[18:03:43] <kimundi> ssbr: Or didi I miss such an bg event :)
[18:03:47] <BitPuffin> hmm maybe without the runtime then
[18:03:57] <BitPuffin> shouldn't emscripten be able to compile the runtime though?
[18:04:01] <ssbr> kimundi: what is it I get when I invoke rust functions from a C program?
[18:04:01] <BitPuffin> if it's written in rust
[18:04:08] <ssbr> BitPuffin: C++
[18:04:21] <ssbr> the bug discusses this, I don't know the details.
[18:04:35] <ssbr> kimundi: my understanding is that this is RT-less rust
[18:04:45] <BitPuffin> ssbr: That also compiles with emscripten though
[18:04:47] <ssbr> and that's why things like @ and fail!() don't work
[18:04:53] <ssbr> BitPuffin: apparently not
[18:05:07] <ssbr> (C++ does; the runtime doesn't)
[18:05:09] <BitPuffin> ssbr: It should! Strange though
[18:05:15] <BitPuffin> ah
[18:05:18] *** Joins: maxli (maxli@C03F2759.C70D537E.2FA4EA88.IP)
[18:05:20] <BitPuffin> is it funky spooky C++?
[18:06:08] <kimundi> ssbr: Depends on wether the c-> rust call started as rust -> c call or not
[18:06:35] <ssbr> kimundi: It's a plain C application that links to a rust crate and calls some functions.
[18:06:40] <ssbr> that much is possible today
[18:06:48] <kimundi> hmm... Interesting.
[18:07:03] <ssbr> (but the rust crate can't use managed pointers, can't fail!(), can't print "hello world" (because io uses managed pointers), ...)
[18:07:26] <kimundi> yeah, those issues are to be expected.
[18:08:02] *** Joins: Axord (xord@moz-C3CCF156.lsanca.dsl-w.verizon.net)
[18:08:28] <BitPuffin> how will rust be able to be ported to other platforms if the compiler is written in rust? I mean if you don't have rust then you can't compile rust on the platform haha
[18:08:44] <BitPuffin> Say I wanna run rust on haiku
[18:08:49] <BitPuffin> what when how
[18:09:49] <ssbr> BitPuffin: the usual approach is cross-compilation to make the first compiler that runs on the foreign platform
[18:09:58] <ssbr> (AFAIK)
[18:10:12] <BitPuffin> but how do you cross-compile?
[18:10:25] <BitPuffin> you mean you would compile in linux for haiku?
[18:10:35] <ssbr> yes
[18:10:49] <ssbr> and then the output is a working compiler that runs in haiku
[18:10:59] <BitPuffin> weird
[18:11:05] <BitPuffin> now how does that work :P
[18:11:12] <BitPuffin> voodoo stuff
[18:11:14] <ssbr> it's not hard to imagine that working
[18:11:19] <ssbr> self-hosting compilers themselves are way weirder
[18:11:30] <ssbr> http://cm.bell-labs.com/who/ken/trust.html
[18:11:59] *** Joins: EXetoC (ex@moz-C741B177.customer.t3.se)
[18:12:18] <BitPuffin> EXetoC: get back in D!!!
[18:14:49] *** Joins: themgt (themgt@moz-F5F3FFDF.dhcp.gnvl.sc.charter.com)
[18:15:28] *** Quits: SirSkidmore (taylor@A8CF1C90.14855463.8C3A19BB.IP) (Quit: WeeChat 0.4.0)
[18:21:16] *** Quits: dbaupp (Thunderbir@moz-856B3C14.lns20.syd6.internode.on.net) (Ping timeout)
[18:22:04] *** Joins: FrozenCow (FrozenCow@moz-9DF5D010.dynamic.upc.nl)
[18:23:39] <EXetoC> BitPuffin: no u
[18:25:05] *** Joins: lmandel (lmandel@FE1F74.86ED00A7.971E19F6.IP)
[18:25:09] <pascal> Is this a known error? I'm compiling my project and rustc gives me "unexpected char in type string: +": https://gist.github.com/pascalj/bbef0062964ac2c25f00
[18:25:22] <BitPuffin> EXetoC: I'm already stuck
[18:25:28] *** Quits: pyrac (pyrac@moz-B95F505.w92-156.abo.wanadoo.fr) (Quit: pyrac)
[18:25:42] <EXetoC> BitPuffin: glue?
[18:26:19] <engla> Is there any plan for how the new iterators will work with traits? I would like to say  trait Graph<Node> { fn nodes(&self) -> Iterator<Node>; }    Just that the trait includes a function that returns an iterable that yields Nodes...   it's easy as  trait Graph<Node> { fn nodes(&self, &fn(&Node) -> bool); }
[18:26:32] <ssbr> pascal: I bet you're trying to compile old rust code with a new compiler
[18:26:39] <ssbr> pascal: there used to be mode syntax that used "++"
[18:26:51] <ssbr> it's gone now. (I don't know what it did.)
[18:27:25] <engla> (one solution is to make the iterator type a generic parameter.. but it doesn't scale with more functions returning iterators in the trait!)
[18:28:30] <BitPuffin> EXetoC: No, just awesomeness :)
[18:29:32] <kimundi> engla: You have to write an iterator type for your graph that holds the necessary state and references to the graph and implements the Iterator trait.
[18:29:46] *** Quits: mjh563 (mjh563@moz-D891C5B8.cable.virginmedia.com) (Ping timeout)
[18:30:13] <engla> yeah I know how to implement it. But I can't find a way to write the trait in a generic way
[18:30:39] <kimundi> hm,...
[18:30:40] <engla> unless a type parameter is added for each iterator used
[18:30:56] <engla> maybe associated objects in traits can fix that
[18:30:57] <pascal> ssbr: grepping through the complete source doesnt find "++" - any pointers on how I can find that old/broken code?
[18:30:57] <EXetoC> ssbr: what was it called again? ++
[18:31:08] <ssbr> pascal: if you could post the source that'd be helpful
[18:31:11] <ssbr> I was guessing
[18:31:14] <ssbr> EXetoC: I don't know.
[18:31:47] <kimundi> modes
[18:32:06] *** Joins: infynyxx (infynyxx@moz-E95B370B.nyc.res.rr.com)
[18:32:09] <EXetoC> thanks
[18:32:15] <kimundi> Don't know what ++ did exactly though... bycopy?
[18:37:03] *** Quits: HOLYCOWBATMAN (Mibbit@moz-AB722A1C.mc.videotron.ca) (Quit: http://www.mibbit.com ajax IRC Client)
[18:38:42] *** Quits: BizarreCake (BizarreCak@32C9829A.151E84E7.561471F8.IP) (Quit: Leaving)
[18:40:37] *** Joins: pyrac (pyrac@moz-B95F505.w92-156.abo.wanadoo.fr)
[18:40:38] <pascal> ssbr: the line that triggers the error is: let parser = expat::XML_ParserCreate(ptr::null()); where expat::* is from: https://github.com/pascalj/rust-expat/blob/master/expat.rs
[18:41:40] <ssbr> pascal: what? the error you gave me was about rust-jabberd.rs
[18:44:20] *** Quits: MrFahrenheit (RageOfThou@3FEF494C.29C984D5.783DEDCA.IP) (Ping timeout)
[18:45:28] *** Joins: ghrust (ghrust@moz-4EF5B6E5.rs.github.com)
[18:45:29] <ghrust> 01[13rust01] 15bors merged 06auto into 06incoming: 02http://git.io/gQJbug
[18:45:29] *** Parts: ghrust (ghrust@moz-4EF5B6E5.rs.github.com) ()
[18:46:04] <pascal> ssbr: minimal testcase: https://gist.github.com/pascalj/9e6a8e057db88db9bd55
[18:46:57] *** Quits: lbonn (lbonn@moz-29C8E1BA.ap-w02.canvas.ne.jp) (Quit: leaving)
[18:48:00] <ssbr> Man, I got nothing.
[18:48:09] <ssbr> I don't see any +s anywhere.
[18:48:17] *** Parts: ssbr (ssbr@A9D9D38C.B6F034AC.72A31D6.IP) (Channel tab borked.)
[18:48:20] *** Joins: ssbr (ssbr@A9D9D38C.B6F034AC.72A31D6.IP)
[18:48:27] *** Joins: ghrust (ghrust@moz-4EF5B6E5.rs.github.com)
[18:48:27] <ghrust> 01[13rust01] 15bors pushed 0 new commits to 06auto: 02http://git.io/yCv10Q
[18:48:27] *** Parts: ghrust (ghrust@moz-4EF5B6E5.rs.github.com) ()
[18:48:31] <ssbr> (in the other file either)
[18:48:39] <pascal> Maybe I'll compile everything again and try again. Seems like a weird glitch to me
[18:49:56] *** Joins: thomaslee (thomaslee@moz-306D3DF4.hsd1.or.comcast.net)
[18:51:26] *** Joins: ghrust (ghrust@moz-4EF5B6E5.rs.github.com)
[18:51:26] <ghrust> 01[13rust01] 15bors pushed 0 new commits to 06auto: 02http://git.io/yCv10Q
[18:51:26] *** Parts: ghrust (ghrust@moz-4EF5B6E5.rs.github.com) ()
[18:51:28] *** Joins: ghrust (ghrust@moz-4EF5B6E5.rs.github.com)
[18:51:28] <ghrust> 01[13rust01] 15bors pushed 4 new commits to 06auto: 02http://git.io/P8H5eA
[18:51:28] <ghrust> 13rust/06auto 14f6743fe 15Huon Wilson: librustc: allow destructuring of structs with destructors if the pattern has no moves....
[18:51:29] <ghrust> 13rust/06auto 1481e06a5 15Huon Wilson: Issue number on xfailed test
[18:51:29] <ghrust> 13rust/06auto 14912a352 15Huon Wilson: Add some positive tests for dtor struct destructuring
[18:51:30] *** Parts: ghrust (ghrust@moz-4EF5B6E5.rs.github.com) ()
[19:00:32] *** Quits: jensnockert (jensnocker@moz-8BE55278.customer.t3.se) (Input/output error)
[19:07:30] *** Joins: Jeaye (Jeaye@moz-FD505E54.hsd1.ca.comcast.net)
[19:07:39] *** Quits: pyrac (pyrac@moz-B95F505.w92-156.abo.wanadoo.fr) (Quit: pyrac)
[19:14:41] *** Joins: pyrac (pyrac@moz-B95F505.w92-156.abo.wanadoo.fr)
[19:16:55] *** Joins: thou (thou@moz-1C1CA9F7.fasttrackcomm.net)
[19:19:40] *** Quits: infynyxx (infynyxx@moz-E95B370B.nyc.res.rr.com) (Client exited)
[19:20:45] *** Quits: maxli (maxli@C03F2759.C70D537E.2FA4EA88.IP) (Quit: Leaving.)
[19:21:59] *** Joins: jensnockert (jensnocker@moz-8BE55278.customer.t3.se)
[19:34:04] *** Quits: paulproteus (quassel@rose.makesad.us) (Ping timeout)
[19:35:00] *** Joins: paulproteus (quassel@moz-E86A3B42.makesad.us)
[19:36:15] *** Joins: CMCL (kvirc@93BFFDB9.74CE3134.2C38E6B5.IP)
[19:36:46] *** Quits: zakora (NC@moz-8EAF945F.fbx.proxad.net) (Quit: Textual IRC Client: www.textualapp.com)
[19:40:00] *** Quits: jviereck (Adium@moz-2B0BB5C.dclient.hispeed.ch) (Ping timeout)
[19:40:08] *** Joins: jviereck (Adium@moz-340574DC.dclient.hispeed.ch)
[19:46:24] *** Quits: cdidd (cdidd@moz-23D9B633.broadband.corbina.ru) (Input/output error)
[19:46:43] *** Joins: CanhTak (Mibbit@moz-18B09BA7.rev.sfr.net)
[19:47:22] *** Quits: CanhTak (Mibbit@moz-18B09BA7.rev.sfr.net) (Quit: http://www.mibbit.com ajax IRC Client)
[19:49:22] *** Joins: maxli (maxli@C03F2759.C70D537E.2FA4EA88.IP)
[19:51:25] *** Joins: ghrust (ghrust@moz-4EF5B6E5.rs.github.com)
[19:51:25] <ghrust> 01[13rust01] 15bors merged 06auto into 06incoming: 02http://git.io/P8H5eA
[19:51:25] *** Parts: ghrust (ghrust@moz-4EF5B6E5.rs.github.com) ()
[19:53:04] *** Joins: tjc (tjc@moz-987EA512.vc.shawcable.net)
[19:53:04] *** ChanServ sets mode: +o tjc
[19:54:26] *** Joins: ghrust (ghrust@moz-4EF5B6E5.rs.github.com)
[19:54:26] <ghrust> 01[13rust01] 15bors pushed 0 new commits to 06auto: 02http://git.io/0FUANg
[19:54:26] *** Parts: ghrust (ghrust@moz-4EF5B6E5.rs.github.com) ()
[19:57:25] *** Joins: ghrust (ghrust@moz-4EF5B6E5.rs.github.com)
[19:57:25] <ghrust> 01[13rust01] 15bors pushed 0 new commits to 06auto: 02http://git.io/0FUANg
[19:57:25] *** Parts: ghrust (ghrust@moz-4EF5B6E5.rs.github.com) ()
[19:57:27] *** Joins: ghrust (ghrust@moz-4EF5B6E5.rs.github.com)
[19:57:27] <ghrust> 01[13rust01] 15bors pushed 3 new commits to 06auto: 02http://git.io/4bxlhg
[19:57:27] <ghrust> 13rust/06auto 14b7da975 15Youngsoo Son: renamed vec::from_slice to vec::to_owned
[19:57:27] <ghrust> 13rust/06auto 1424ef88c 15Youngsoo Son: renamed str::from_slice to str::to_owned
[19:57:28] <ghrust> 13rust/06auto 149572518 15bors: auto merge of #6389 : sonwow/rust/issue-3356, r=bstrie...
[19:57:30] *** Parts: ghrust (ghrust@moz-4EF5B6E5.rs.github.com) ()
[19:59:20] *** Joins: doomlord (doomlod@moz-1D2F91FA.range86-150.btcentralplus.com)
[19:59:28] *** Quits: doomlord (doomlod@moz-1D2F91FA.range86-150.btcentralplus.com) (Quit: doomlord)
[19:59:59] *** Joins: doomlord (doomlod@moz-1D2F91FA.range86-150.btcentralplus.com)
[20:02:12] *** Quits: engla (engla@moz-DBD1D96E.cust.bredbandsbolaget.se) (Ping timeout)
[20:04:33] *** Quits: yosemite (sam@moz-8CEAB1B0.dasbistro.com) (Quit: leaving)
[20:05:31] *** Joins: yosemite (sam@moz-8CEAB1B0.dasbistro.com)
[20:10:20] *** Joins: strcat (strcat@moz-54F7FD49.cpe.net.cable.rogers.com)
[20:11:27] *** Quits: pyrac (pyrac@moz-B95F505.w92-156.abo.wanadoo.fr) (Quit: pyrac)
[20:22:08] <pascal> ssbr: compiling everything again worked - the +s error is gone
[20:24:05] *** Quits: jensnockert (jensnocker@moz-8BE55278.customer.t3.se) (Input/output error)
[20:25:33] *** Quits: Diablo-D3 (diablo@moz-28CF78D6.port.east.myfairpoint.net) (Ping timeout)
[20:29:34] *** Joins: Diablo-D3 (diablo@moz-6317EE8A.port.east.myfairpoint.net)
[20:30:20] *** Quits: Yurume (yurume@AC58A8CE.8A059B47.E313B915.IP) (Ping timeout)
[20:39:37] *** Joins: pyrac (pyrac@moz-B95F505.w92-156.abo.wanadoo.fr)
[20:40:55] <fread2281> how can I do something like fn compress_bound<T: Add<T, T>, Div>(size: T) -> T {size + (size/255) + 16} ?
[20:42:33] <fread2281> using NumCast doesn't work either (but seems more correct to me)
[20:44:01] <fread2281> that is, make a function that does some math on a number of any type
[20:44:48] <kimundi> fread2281, that should work...
[20:45:12] <fread2281> kimundi: error: binary operation / cannot be applied to type `'a`
[20:45:40] <kimundi> only thing missing there is either a Copy bound or explicit .clone() calls
[20:46:00] <kimundi> Then your Div bound is strange
[20:46:29] <kimundi> shoult be Div<T, T> like Add
[20:46:41] *** Joins: brson (brson@2557E599.66715431.D25A875A.IP)
[20:46:41] *** ChanServ sets mode: +o brson
[20:46:50] <kimundi> but you can also just take Num as bound
[20:46:58] <doy> also, that , is wrong
[20:47:06] <strcat> kimundi: don't need Copy/Clone for that
[20:47:10] <doy> it's declaring two type parameters, one named T and the other named Div
[20:47:21] <strcat> but the operators are buggy and don't work properly with references
[20:47:31] <strcat> so you have to explicitly use the methods
[20:47:50] <kimundi> fread2281: What doy said
[20:48:37] <fread2281> kimundi: right
[20:48:46] *** Quits: tjc (tjc@moz-987EA512.vc.shawcable.net) (Quit: zzzzzzzzzz)
[20:51:26] <fread2281> how can I make it so I can Add a literal?
[20:52:08] <kimundi> fread2281, I don't understand your question
[20:52:24] <fread2281> kimundi: so I can do size + 123
[20:52:48] <kimundi> ah. write + num::cast(123)
[20:53:30] <kimundi> or num::cast::<uint, T>(123) to be explicit
[20:53:56] <fread2281> kimundi: so I can do size + 123
[20:54:00] <fread2281> whops
[20:58:32] *** Quits: CMCL (kvirc@93BFFDB9.74CE3134.2C38E6B5.IP) (Quit: KVIrc 4.0.2 Insomnia http://www.kvirc.net/)
[21:00:23] *** Joins: ghrust (ghrust@moz-4EF5B6E5.rs.github.com)
[21:00:24] <ghrust> 01[13rust01] 15bors merged 06auto into 06incoming: 02http://git.io/4bxlhg
[21:00:24] *** Parts: ghrust (ghrust@moz-4EF5B6E5.rs.github.com) ()
[21:00:35] *** Joins: CMCL (cmcl@moz-8C2E912C.co.uk)
[21:01:28] *** Quits: pyrac (pyrac@moz-B95F505.w92-156.abo.wanadoo.fr) (Quit: pyrac)
[21:03:02] <fread2281> kimundi: error: failed to find an implementation of trait core::num::NumCast for <V8> and some with casting to int
[21:03:17] *** Joins: devbug (quassel@moz-E1DE087C.bchsia.telus.net)
[21:03:22] *** Joins: ghrust (ghrust@moz-4EF5B6E5.rs.github.com)
[21:03:22] <ghrust> 01[13rust01] 15bors pushed 0 new commits to 06auto: 02http://git.io/Dm8Xbg
[21:03:22] *** Parts: ghrust (ghrust@moz-4EF5B6E5.rs.github.com) ()
[21:03:57] <kimundi> fread2281: That means that it doesn't know what type T you put in. Might need explicit type annotations
[21:03:57] *** Joins: sp3d (a@moz-17CB39F1.fidnet.com)
[21:04:14] *** Joins: HOLYCOWBATMAN (Mibbit@moz-AB722A1C.mc.videotron.ca)
[21:05:40] <fread2281> kimundi: huh?
[21:05:49] *** Quits: Axord (xord@moz-C3CCF156.lsanca.dsl-w.verizon.net) (Quit: I'm sure it's perfectly safe)
[21:06:08] <kimundi> fread2281: I need an code example where the error happens :)
[21:06:21] *** Joins: ghrust (ghrust@moz-4EF5B6E5.rs.github.com)
[21:06:21] <ghrust> 01[13rust01] 15bors pushed 0 new commits to 06auto: 02http://git.io/Dm8Xbg
[21:06:21] *** Parts: ghrust (ghrust@moz-4EF5B6E5.rs.github.com) ()
[21:06:23] *** Joins: ghrust (ghrust@moz-4EF5B6E5.rs.github.com)
[21:06:24] <ghrust> 01[13rust01] 15bors pushed 2 new commits to 06auto: 02http://git.io/YBThaw
[21:06:24] <ghrust> 13rust/06auto 143db74dd 15James Tranovich: Fixes rusti crashes....
[21:06:24] <ghrust> 13rust/06auto 148ca64a4 15bors: auto merge of #6397 : cantsin/rust/rusti-fixes, r=catamorphism...
[21:06:24] *** Parts: ghrust (ghrust@moz-4EF5B6E5.rs.github.com) ()
[21:07:30] <fread2281> rusti: fn compress_bound<T: Add<T, T> + Div<T, T>, NumCast>(size: T) -> T { size + (size/num::cast(255)) + num::cast(16) }
[21:07:31] <rusti> foo.rs:5:91: 5:100 error: failed to find an implementation of trait core::num::NumCast for 'a
[21:07:31] <rusti> foo.rs:5          fn compress_bound<T: Add<T, T> + Div<T, T>, NumCast>(size: T) -> T { size + (size/num::cast(255)) + num::cast(16) }
[21:07:31] <rusti>                                                                                                     ^~~~~~~~~
[21:07:31] <rusti> note: in expansion of fmt!
[21:07:31] <rusti> foo.rs:4:12: 6:7 note: expansion site
[21:07:43] <fread2281> kimundi: ^
[21:08:36] <strcat> fread2281: you're not adding NumCast as a bound for T
[21:08:41] <kimundi>  rusti: fn compress_bound<T: Add<T, T> + Div<T, T>, NumCast>(size: T) -> T { size + (size/num::cast::<int, T>(255)) + num::cast::<int, T>(16) }
[21:08:44] <strcat> it's a separate type parameter because of the ,
[21:09:01] <kimundi> rusti: fn compress_bound<T: Add<T, T> + Div<T, T> + NumCast>(size: T) -> T { size + (size/num::cast::<int, T>(255)) + num::cast::<int, T>(16) }
[21:09:17] <strcat> kimundi: I don't think the parameters need to be explicit for cast
[21:09:31] <kimundi> rusti: fn compress_bound<T: Add<T, T> + Div<T, T> + NumCast>(size: T) -> T { size + (size/num::cast::<int, T>(255)) + num::cast::<int, T>(16) } compress_bound(1234)
[21:09:32] <rusti> 1254
[21:09:50] <fread2281> kimundi: thanks
[21:09:56] <kimundi> rusti: fn compress_bound<T: Add<T, T> + Div<T, T> + NumCast>(size: T) -> T { size + (size/num::cast(255)) + num::cast(16) } compress_bound(1234)
[21:09:58] <rusti> 1254
[21:10:09] <fread2281> that's a bit messy though :/
[21:10:20] <kimundi> rusti: fn compress_bound<T: Add<T, T> + Div<T, T>>(size: T) -> T { size + (size/num::cast(255)) + num::cast(16) } compress_bound(1234)
[21:10:21] <rusti> foo.rs:5:82: 5:91 error: failed to find an implementation of trait core::num::NumCast for 'a
[21:10:21] <rusti> foo.rs:5          fn compress_bound<T: Add<T, T> + Div<T, T>>(size: T) -> T { size + (size/num::cast(255)) + num::cast(16) } compress_bound(1234)
[21:10:21] <rusti>                                                                                            ^~~~~~~~~
[21:10:21] <rusti> note: in expansion of fmt!
[21:10:22] <rusti> foo.rs:4:12: 6:7 note: expansion site
[21:10:44] <kimundi> rusti: use num::cast; fn compress_bound<T: Add<T, T> + Div<T, T> + NumCast>(size: T) -> T { size + (size/cast(255)) + cast(16) } compress_bound(1234)
[21:10:46] <rusti> more than 5 lines of output, pastebinned: http://sprunge.us/GIQE
[21:10:57] <kimundi> rusti: use core::num::cast; fn compress_bound<T: Add<T, T> + Div<T, T> + NumCast>(size: T) -> T { size + (size/cast(255)) + cast(16) } compress_bound(1234)
[21:10:58] <rusti> 1254
[21:11:11] <kimundi> rusti: use core::num::cast; fn compress_bound<T: Num>(size: T) -> T { size + (size/cast(255)) + cast(16) } compress_bound(1234)
[21:11:13] <rusti> foo.rs:5:85: 5:89 error: failed to find an implementation of trait core::num::NumCast for 'a
[21:11:13] <rusti> foo.rs:5          use core::num::cast; fn compress_bound<T: Num>(size: T) -> T { size + (size/cast(255)) + cast(16) } compress_bound(1234)
[21:11:13] <rusti>                                                                                               ^~~~
[21:11:13] <rusti> note: in expansion of fmt!
[21:11:13] <rusti> foo.rs:4:12: 6:7 note: expansion site
[21:11:23] <kimundi> rusti: use core::num::cast; fn compress_bound<T: Num + NumCast>(size: T) -> T { size + (size/cast(255)) + cast(16) } compress_bound(1234)
[21:11:25] <rusti> 1254
[21:11:29] *** Quits: skchrko__ (sk@61A494B3.BA40E8A.AAC02D62.IP) (Input/output error)
[21:11:41] *** Joins: erickt (Adium@1021DD2F.1E1F6C0.AF6F698.IP)
[21:11:45] <kimundi> I don't think you get it smaller than that
[21:13:23] *** Quits: strcat (strcat@moz-54F7FD49.cpe.net.cable.rogers.com) (Quit: WeeChat 0.4.0)
[21:14:26] *** Quits: rusti (rusti@moz-54F7FD49.cpe.net.cable.rogers.com) (Client exited)
[21:16:10] *** Quits: jviereck (Adium@moz-340574DC.dclient.hispeed.ch) (Quit: Leaving.)
[21:16:31] *** Quits: erickt (Adium@1021DD2F.1E1F6C0.AF6F698.IP) (Quit: Leaving.)
[21:18:10] *** Joins: Sodel_the_V (user@moz-853663E1.va.shawcable.net)
[21:18:25] *** Quits: Jesin (Jessin_@moz-5654D37.washdc.fios.verizon.net) (Ping timeout)
[21:20:21] *** Quits: lerc (quassel@121.75.155.67) (Client exited)
[21:20:50] *** Joins: Jesin (Jessin_@moz-5654D37.washdc.fios.verizon.net)
[21:28:08] *** Joins: bbrittain (ben@moz-632384CB.dr02.roch.ny.frontiernet.net)
[21:28:54] *** Joins: duckinator (nick@moz-74B346B5.mostlyincorrect.info)
[21:30:51] *** Quits: haard (fredrik@moz-6A86987C.dynamic.se.alltele.net) (Ping timeout)
[21:35:47] *** Joins: tcsc (tcsc@moz-A838B260.dhcp.nwtn.ct.charter.com)
[21:37:23] *** Quits: tcsc (tcsc@moz-A838B260.dhcp.nwtn.ct.charter.com) (Quit: bye!)
[21:37:32] *** Joins: tcsc (tcsc@moz-A838B260.dhcp.nwtn.ct.charter.com)
[21:41:09] *** Joins: ercax (timmayyyy@moz-D4CF4859.dyn.optonline.net)
[21:41:58] *** Quits: Sodel_the_V (user@moz-853663E1.va.shawcable.net) (Ping timeout)
[21:45:00] *** Quits: ercax (timmayyyy@moz-D4CF4859.dyn.optonline.net) (Quit: Lost terminal)
[21:51:25] *** Joins: infynyxx (infynyxx@moz-E95B370B.nyc.res.rr.com)
[21:54:00] *** Joins: mdu (mdu@moz-9962C9F4.rev.numericable.fr)
[21:54:16] *** Quits: tcsc (tcsc@moz-A838B260.dhcp.nwtn.ct.charter.com) (Quit: bye!)
[21:54:24] *** Joins: tcsc (tcsc@moz-A838B260.dhcp.nwtn.ct.charter.com)
[21:55:46] *** Quits: HOLYCOWBATMAN (Mibbit@moz-AB722A1C.mc.videotron.ca) (Quit: http://www.mibbit.com ajax IRC Client)
[21:56:57] *** Joins: rusti (rusti@moz-54F7FD49.cpe.net.cable.rogers.com)
[22:03:54] *** Quits: Palmik (palmik@moz-DADC71F0.pks.muni.cz) (Quit: Lost terminal)
[22:03:59] *** Quits: spider-mario (spidermari@moz-2BC095A6.rev.sfr.net) (Input/output error)
[22:06:23] *** Joins: ghrust (ghrust@moz-4EF5B6E5.rs.github.com)
[22:06:23] <ghrust> 01[13rust01] 15bors merged 06auto into 06incoming: 02http://git.io/YBThaw
[22:06:23] *** Parts: ghrust (ghrust@moz-4EF5B6E5.rs.github.com) ()
[22:06:49] *** Quits: maxli (maxli@C03F2759.C70D537E.2FA4EA88.IP) (Quit: Leaving.)
[22:09:21] *** Joins: strcat (strcat@moz-54F7FD49.cpe.net.cable.rogers.com)
[22:09:25] *** Joins: ghrust (ghrust@moz-4EF5B6E5.rs.github.com)
[22:09:25] <ghrust> 01[13rust01] 15bors pushed 0 new commits to 06auto: 02http://git.io/v84J3A
[22:09:25] *** Parts: ghrust (ghrust@moz-4EF5B6E5.rs.github.com) ()
[22:10:12] *** Quits: tcsc (tcsc@moz-A838B260.dhcp.nwtn.ct.charter.com) (Quit: bye!)
[22:10:19] *** Joins: tcsc (tcsc@moz-A838B260.dhcp.nwtn.ct.charter.com)
[22:12:22] *** Joins: ghrust (ghrust@moz-4EF5B6E5.rs.github.com)
[22:12:22] <ghrust> 01[13rust01] 15bors pushed 0 new commits to 06auto: 02http://git.io/v84J3A
[22:12:22] *** Parts: ghrust (ghrust@moz-4EF5B6E5.rs.github.com) ()
[22:12:25] *** Joins: ghrust (ghrust@moz-4EF5B6E5.rs.github.com)
[22:12:25] <ghrust> 01[13rust01] 15bors pushed 2 new commits to 06auto: 02http://git.io/VGXnUg
[22:12:25] <ghrust> 13rust/06auto 14017e7e8 15Olivier Saut: Replace io::println by println as it is now included in prelude.rs
[22:12:25] <ghrust> 13rust/06auto 149ee8d50 15bors: auto merge of #6398 : osaut/rust/master, r=bstrie...
[22:12:26] *** Parts: ghrust (ghrust@moz-4EF5B6E5.rs.github.com) ()
[22:12:59] *** Quits: jaen (jaen@moz-E0979827.copit.pl) (Ping timeout)
[22:13:13] *** Parts: micrypt (micrypt@moz-A42A6DC5.eu-west-1.compute.amazonaws.com) ()
[22:16:48] *** Quits: mcomella (mcomella@moz-B10FF54F.ri.ri.cox.net) (Ping timeout)
[22:24:17] *** Quits: donri (dag@moz-9BB61102.tbcn.telia.com) (Quit: Leaving)
[22:32:48] *** Quits: Blub\w (wry@7E3BB9D.71150E1A.237AE2BA.IP) (Quit: night)
[22:36:57] *** Joins: tjc (tjc@A5087023.2354C43D.D8E68FF6.IP)
[22:36:57] *** ChanServ sets mode: +o tjc
[22:37:08] *** Joins: zippity (Mibbit@moz-AB722A1C.mc.videotron.ca)
[22:39:41] *** Joins: jaen (jaen@moz-DF7245BD.play-internet.pl)
[22:41:57] *** Joins: maxli (maxli@C03F2759.C70D537E.2FA4EA88.IP)
[22:45:57] *** Joins: steven_is_false (steven@moz-144077DE.bchsia.telus.net)
[22:46:23] *** Quits: steven_is_false (steven@moz-144077DE.bchsia.telus.net) (Quit: Leaving.)
[22:46:45] *** Joins: steven_is_false (steven@moz-144077DE.bchsia.telus.net)
[22:49:17] *** Quits: infynyxx (infynyxx@moz-E95B370B.nyc.res.rr.com) (Connection reset by peer)
[22:49:38] *** Joins: infynyxx (infynyxx@moz-E95B370B.nyc.res.rr.com)
[22:54:04] *** Joins: lerc (quassel@6174E42B.BEFA2430.788638A4.IP)
[22:54:39] *** Quits: rusti (rusti@moz-54F7FD49.cpe.net.cable.rogers.com) (Client exited)
[22:54:40] *** Joins: rusti (rusti@moz-54F7FD49.cpe.net.cable.rogers.com)
[22:58:28] *** Joins: solancile (solancile@moz-A1CFFAE5.hsd1.wa.comcast.net)
[22:59:56] <steven_is_false>  rusti: 2 + 4
[23:13:52] *** Parts: steven_is_false (steven@moz-144077DE.bchsia.telus.net) ()
[23:13:55] *** Joins: steven_is_false (steven@moz-144077DE.bchsia.telus.net)
[23:14:18] <steven_is_false> rust: 1 + 32
[23:14:44] *** Parts: steven_is_false (steven@moz-144077DE.bchsia.telus.net) ()
[23:14:52] *** Quits: FrozenCow (FrozenCow@moz-9DF5D010.dynamic.upc.nl) (Client exited)
[23:15:17] *** Joins: ghrust (ghrust@moz-4EF5B6E5.rs.github.com)
[23:15:17] <ghrust> 01[13rust01] 15bors merged 06auto into 06incoming: 02http://git.io/VGXnUg
[23:15:17] *** Parts: ghrust (ghrust@moz-4EF5B6E5.rs.github.com) ()
[23:18:19] *** Joins: ghrust (ghrust@moz-4EF5B6E5.rs.github.com)
[23:18:19] <ghrust> 01[13rust01] 15bors pushed 0 new commits to 06auto: 02http://git.io/-lV04g
[23:18:19] *** Parts: ghrust (ghrust@moz-4EF5B6E5.rs.github.com) ()
[23:18:20] *** Joins: ghrust (ghrust@moz-4EF5B6E5.rs.github.com)
[23:18:20] <ghrust> 01[13rust01] 15bors pushed 2 new commits to 06auto: 02http://git.io/zFo0fQ
[23:18:20] <ghrust> 13rust/06auto 147d4bb90 15Corey Richardson: Remove redundant import error
[23:18:20] <ghrust> 13rust/06auto 14f84464c 15bors: auto merge of #6400 : cmr/rust/remove_useless_import_error, r=pcwalton...
[23:18:21] *** Parts: ghrust (ghrust@moz-4EF5B6E5.rs.github.com) ()
[23:22:46] *** Quits: tiffany (kawaii@moz-1E0FE6E8.dhcp.embarqhsd.net) (Ping timeout)
[23:27:55] <fread2281> rusti: 1 + 32
[23:28:00] <rusti> 33
[23:28:29] *** Quits: Jesin (Jessin_@moz-5654D37.washdc.fios.verizon.net) (Ping timeout)
[23:30:37] *** Quits: Diablo-D3 (diablo@moz-6317EE8A.port.east.myfairpoint.net) (Quit: do coders dream of sheep()?)
[23:31:28] *** Joins: Diablo-D3 (diablo@moz-6317EE8A.port.east.myfairpoint.net)
[23:32:37] *** Quits: barosl (barosl@1E71221E.C81E10FB.7544CABF.IP) (Quit: ëžœë¤ì€ ì‡ í‡´í–ˆìŠµë‹ˆë‹¤.)
[23:35:49] *** Quits: infynyxx (infynyxx@moz-E95B370B.nyc.res.rr.com) (Client exited)
[23:37:09] <brson> aatch|bed: here are my current thoughts on how to implement work stealing in Rust https://github.com/mozilla/rust/issues/3095#issuecomment-17769438
[23:40:29] *** Quits: RMF (RMF@moz-A559AD33.dsl.telepac.pt) (Ping timeout)
[23:42:33] *** Joins: RMF (RMF@moz-A559AD33.dsl.telepac.pt)
[23:43:25] *** Joins: Jesin (Jessin_@moz-5654D37.washdc.fios.verizon.net)
[23:44:30] *** Quits: maxli (maxli@C03F2759.C70D537E.2FA4EA88.IP) (Quit: Leaving.)
[23:50:51] <Jeaye> rust: task failed at 'lookup_item: id not found: 117681', /build/rust-incoming-git/src/rust/src/librustc/metadata/decoder.rs:90
[23:50:57] <Jeaye> Look familiar to anyone?
[23:51:19] *** Joins: ghrust (ghrust@moz-4EF5B6E5.rs.github.com)
[23:51:19] <ghrust> 01[13rust01] 15bors pushed 2 new commits to 06auto: 02http://git.io/HKBe3Q
[23:51:19] <ghrust> 13rust/06auto 1452610c3 15Lenny222: more back-ticks, less colons
[23:51:19] <ghrust> 13rust/06auto 1482164a1 15bors: auto merge of #6402 : kud1ing/rust/fixes, r=pcwalton
[23:51:19] *** Parts: ghrust (ghrust@moz-4EF5B6E5.rs.github.com) ()
[23:51:20] *** Joins: ghrust (ghrust@moz-4EF5B6E5.rs.github.com)
[23:51:20] <ghrust> 01[13rust01] 15bors 04force-pushed 06auto from 14f84464c to 149ee8d50: 02http://git.io/N3iJvQ
[23:51:20] *** Parts: ghrust (ghrust@moz-4EF5B6E5.rs.github.com) ()
[23:58:46] <Jeaye> Hmm https://github.com/mozilla/rust/issues/5862
[23:59:07] *** Quits: eternaleye (eternaleye@moz-76321711.hsd1.wa.comcast.net) (Ping timeout)

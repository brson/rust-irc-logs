[00:00:30] <mm> Maybe my system is broken in some confusing way that confuses make.
[00:01:42] *** Quits: RMF (RMF@100FCB1B.10FB11BA.8D19547B.IP) (Quit: Textual IRC Client: www.textualapp.com)
[00:02:30] <toddaaro> brson: ah, pretty sure I found my memory issue - double-free in the contested steal case triggered by the fact that we dequeue but do not return the element in that case. I just misparsed the jemalloc error message, which seemed less clear than regular malloc's "double free or coruption"
[00:03:19] *** Quits: jorendorff (jorendorff@moz-2F32ACA3.hsd1.tn.comcast.net) (Quit: jorendorff)
[00:03:22] *** Quits: brendan (brendaneic@moz-BBE3ABD.mv.mozilla.com) (Quit: brendan)
[00:04:12] <strcat> toddaaro: glibc has double-free protection
[00:04:26] <strcat> I think it pays a perf cost for it
[00:04:33] *** Quits: vosen (vosen@moz-266BA656.icpnet.pl) (Quit: Leaving)
[00:04:40] *** Quits: josedonizetti (josedonize@moz-CA73D699.cpe.teksavvy.com) (Quit: josedonizetti)
[00:04:41] <strcat> jemalloc has that stuff behind runtime configuration flags
[00:04:42] <toddaaro> ah, so strip it out and go faster
[00:04:45] <toddaaro> makes sense
[00:05:37] <strcat> compile-time configure flags*
[00:06:00] <strcat> toddaaro: if you add --enable-debug to the jemalloc configure line, it would catch it
[00:06:16] <strcat> I think it has a huge perf cost though
[00:06:41] <toddaaro> hm, I'll keep that in mind
[00:06:46] <toddaaro> it might prove useful in the future
[00:06:55] <toddaaro> well, the core of the chase-lev seems to work
[00:07:00] <toddaaro> astonishingly enough
[00:07:24] <toddaaro> need to do a bit more stress testing, but it looks like I'm on track to enable it tomorrow
[00:07:39] <toddaaro> (optimistically - not sure how long interface beautifying will take)
[00:08:43] *** Joins: brendan (brendaneic@moz-BBE3ABD.mv.mozilla.com)
[00:08:47] <toddaaro> I think shrinking the work queues will be future work unless anyone thinks that is important sooner than later
[00:09:16] <toddaaro> (memory leakish situation where the work queue gets mega-big for a moment then stays small, deques would still be sized for the mega-big moment)
[00:10:06] <aatch> toddaaro, I remember it not being too hard to shrink, at least for the "slow" method.
[00:10:29] <aatch> (still non-trivial though)
[00:10:41] <toddaaro> aatch: it should be really easy, but doing so requires testing and testing doesn't care how easy your change was
[00:10:53] *** Quits: yosemite (sam@moz-8CEAB1B0.dasbistro.com) (Client exited)
[00:11:38] *** Joins: ghrust (ghrust@C8693FCB.6A2AE50.F3114085.IP)
[00:11:38] <ghrust> 01[13rust01] 15bors merged 06auto into 06master: 02http://git.io/3q5vIw
[00:11:38] *** Parts: ghrust (ghrust@C8693FCB.6A2AE50.F3114085.IP) ()
[00:12:09] *** Joins: noam (noam@F6B530A7.720527A7.416762B.IP)
[00:12:26] *** Joins: RMF (RMF@100FCB1B.10FB11BA.8D19547B.IP)
[00:13:20] *** Quits: tcr (tcr@moz-EE576D3C.hsd1.ma.comcast.net) (Client exited)
[00:13:41] *** Joins: tcr (tcr@moz-EE576D3C.hsd1.ma.comcast.net)
[00:14:57] <brson> acrichto: so libuv doesn't support capturing subprocess output?!
[00:15:21] *** Quits: tcr (tcr@moz-EE576D3C.hsd1.ma.comcast.net) (Ping timeout)
[00:15:21] <brson> oh sorry misunderstood
[00:15:29] <brson> you added rust bindings for libuv pipes
[00:15:29] *** Quits: mihneadb_ (mihneadb@moz-BE33DA21.fw1.sfo1.mozilla.net) (Connection reset by peer)
[00:15:35] *** Quits: ecr (Thunderbir@moz-BBE3ABD.mv.mozilla.com) (Quit: ecr)
[00:15:51] *** Quits: jmgrosen (jmgrosen@moz-A3814C08.sd.sd.cox.net) (Quit: jmgrosen)
[00:16:14] <toddaaro> rusti: let x = std::vec::Vector::with_capacity(5)
[00:16:15] -rusti- <anon>:6:4: 6:5 error: expected `;` but found `}`
[00:16:15] -rusti- <anon>:6     };
[00:16:15] -rusti-              ^
[00:16:15] -rusti- application terminated with error code 101
[00:16:25] <toddaaro> rusti: let x = std::vec::Vector::with_capacity(5); x
[00:16:26] -rusti- <anon>:5:17: 5:48 error: unresolved name `std::vec::Vector::with_capacity`.
[00:16:26] -rusti- <anon>:5          let x = std::vec::Vector::with_capacity(5); x
[00:16:26] -rusti-                           ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
[00:16:26] -rusti- error: aborting due to previous error
[00:16:26] -rusti- application terminated with error code 101
[00:16:33] <toddaaro> rusti: let x = std::vec::with_capacity(5); x
[00:16:36] -rusti- pastebinned 6 lines of output: http://ix.io/7tb
[00:16:45] <toddaaro> rusti: let x: ~[uint] = std::vec::with_capacity(5); x
[00:16:46] -rusti- ~[]
[00:16:49] * ChrisMorgan is contemplating getting http://www.dell.com/au/p/inspiron-15r-se-7520/pd?oc=dw510267au&model_id=inspiron-15r-se-7520 so that he can compile Rust more quickly (among other reasons)... just asking now if the "refund or credit" stipulated in the Windows 8 EULA for non-acceptanceâ€”e.g. installing Ubuntu insteadâ€”can be applied.
[00:17:03] <acrichto> brson: correct
[00:17:16] <toddaaro> what is the best way to create a vector containing N uninitialized but valid indicies?
[00:17:23] <toddaaro> is with_capacity the preferred way?
[00:17:34] <acrichto> toddaaro: I wrote something with with_capacity/raw::set_len
[00:17:35] <toddaaro> rusti: let x: ~[uint] = std::vec::with_capacity(5); x[4] = 120; x[4]
[00:17:36] -rusti- <anon>:5:54: 5:57 error: cannot assign to immutable vec content
[00:17:36] -rusti- <anon>:5          let x: ~[uint] = std::vec::with_capacity(5); x[4] = 120; x[4]
[00:17:36] -rusti-                                                                ^~~
[00:17:37] -rusti- error: aborting due to previous error
[00:17:37] -rusti- application terminated with error code 101
[00:17:49] <toddaaro> rusti: let mut x: ~[uint] = std::vec::with_capacity(5); x[4] = 120; x[4]
[00:17:50] -rusti- task <unnamed> failed at 'index out of bounds: the len is 0 but the index is 4', <anon>:5
[00:17:50] -rusti- application terminated with error code 101
[00:18:06] <strcat> toddaaro: length and capacity are separate
[00:18:08] <toddaaro> acrichto: raw::set_len to open up the empty slots?
[00:18:16] <strcat> yeah
[00:18:19] <acrichto> toddaaro: yeah, it makes the out of bounds go away
[00:18:45] <toddaaro> rusti: let mut x: ~[uint] = std::vec::with_capacity(5); std::vec::raw::set_len(5); x[4] = 120; x[4]
[00:18:45] -rusti- <anon>:5:58: 5:84 error: this function takes 2 parameters but 1 parameter was supplied
[00:18:46] -rusti- <anon>:5          let mut x: ~[uint] = std::vec::with_capacity(5); std::vec::raw::set_len(5); x[4] = 120; x[4]
[00:18:46] -rusti-                                                                    ^~~~~~~~~~~~~~~~~~~~~~~~~~
[00:18:46] -rusti- error: aborting due to previous error
[00:18:47] -rusti- application terminated with error code 101
[00:18:56] <toddaaro> rusti: let mut x: ~[uint] = std::vec::with_capacity(5); std::vec::raw::set_len(x, 5); x[4] = 120; x[4]
[00:18:57] -rusti- <anon>:5:81: 5:82 error: mismatched types: expected `&mut ~[<V6>]` but found `~[uint]` (expected &-ptr but found vector)
[00:18:57] -rusti- <anon>:5          let mut x: ~[uint] = std::vec::with_capacity(5); std::vec::raw::set_len(x, 5); x[4] = 120; x[4]
[00:18:57] -rusti-                                                                                           ^
[00:18:57] -rusti- error: aborting due to previous error
[00:18:57] <engla> it's an unsafe function too
[00:18:59] -rusti- application terminated with error code 101
[00:19:08] <toddaaro> rusti: let mut x: ~[uint] = std::vec::with_capacity(5); std::vec::raw::set_len(&mut x, 5); x[4] = 120; x[4]
[00:19:08] -rusti- <anon>:5:58: 5:92 error: call to unsafe function requires unsafe function or block
[00:19:08] -rusti- <anon>:5          let mut x: ~[uint] = std::vec::with_capacity(5); std::vec::raw::set_len(&mut x, 5); x[4] = 120; x[4]
[00:19:08] -rusti-                                                                    ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
[00:19:10] -rusti- error: aborting due to previous error
[00:19:12] -rusti- application terminated with error code 101
[00:19:17] <toddaaro> rusti: unsafe { let mut x: ~[uint] = std::vec::with_capacity(5); std::vec::raw::set_len(&mut x, 5); x[4] = 120; x[4] }
[00:19:19] -rusti- 120
[00:19:21] <toddaaro> awesome
[00:19:23] <toddaaro> I'll do that
[00:19:45] <acrichto> rusti: unsafe { let mut x: ~[uint] = std::vec::with_capacity(4); std::vec::raw::set_len(&mut x, 4); x }
[00:19:46] -rusti- ~[0, 0, 0, 0]
[00:19:53] <acrichto> aww it's not random
[00:20:06] <engla> arbitrary is not random
[00:20:11] *** Quits: dherman (dherman@moz-BBE3ABD.mv.mozilla.com) (Quit: dherman)
[00:20:17] <sfackler> anonymous pages
[00:20:27] *** Quits: leonvv (leonvv@moz-7D83A5F1.ip.telfort.nl) (Client exited)
[00:21:10] <strcat> acrichto: to get junk you need to reuse cached allocations
[00:21:17] <strcat> like
[00:21:22] <acrichto> or get lucky :)
[00:21:35] *** Joins: ghrust (ghrust@F6EE6DE3.6A2AE50.F3114085.IP)
[00:21:35] <ghrust> 01[13rust01] 15bors pushed 0 new commits to 06auto: 02http://git.io/w3rXTg
[00:21:35] *** Parts: ghrust (ghrust@F6EE6DE3.6A2AE50.F3114085.IP) ()
[00:21:35] *** Joins: ghrust (ghrust@24260B07.6A2AE50.F3114085.IP)
[00:21:35] <ghrust> 01[13rust01] 15bors pushed 4 new commits to 06auto: 02http://git.io/vogwag
[00:21:35] <ghrust> 13rust/06auto 14ed6694a 15Vadim Chugunov: Fixed -Z print-link-args
[00:21:35] <ghrust> 13rust/06auto 14c8354ff 15Vadim Chugunov: Rename functional-struct-update.rs to avoid tripping Windows installer detector....
[00:21:35] <ghrust> 13rust/06auto 142b10968 15Vadim Chugunov: Trimmed whitespace
[00:21:36] *** Parts: ghrust (ghrust@24260B07.6A2AE50.F3114085.IP) ()
[00:21:39] <dbaupp> rusti: unsafe { let mut x: ~[uint] = std::vec::with_capacity(1_000_000); std::vec::raw::set_len(&mut x, 4); x[0] = 1; x[1] = 2; x[2] = 3; } unsafe { let mut x: ~[uint] = std::vec::with_capacity(1_000_000); std::vec::raw::set_len(&mut x, 4); x }
[00:21:40] -rusti- ~[0, 0, 0, 0]
[00:22:14] <strcat> it won't hand you back the same one right away though
[00:23:22] <strcat> rusti: for i in range(0, 1000) { let _ = ~[1, 2, 3, 4]; } let mut xs: ~[int] = std::vec::with_capacity(4); std::vec::raw::set_len(&mut xs, 4); xs
[00:23:24] -rusti- line longer than 150 columns, pastebinned 5 lines of output: http://ix.io/7td
[00:23:37] <strcat> rusti: for i in range(0, 1000) { let _ = ~[1, 2, 3, 4]; } let mut xs: ~[int] = std::vec::with_capacity(4); unsafe { std::vec::raw::set_len(&mut xs, 4) }; xs
[00:23:39] -rusti- line longer than 150 columns, pastebinned 4 lines of output: http://ix.io/7te
[00:23:46] <dbaupp> neat
[00:23:56] <strcat> rusti: for _ in range(0, 10) { let _ = ~[1, 2, 3, 4]; } let mut xs: ~[int] = std::vec::with_capacity(4); unsafe { std::vec::raw::set_len(&mut xs, 4) }; xs
[00:23:57] -rusti- ~[1, 2, 3, 4]
[00:24:10] <strcat> rusti: let _ = ~[1, 2, 3, 4]; let mut xs: ~[int] = std::vec::with_capacity(4); unsafe { std::vec::raw::set_len(&mut xs, 4) }; xs
[00:24:11] -rusti- ~[1, 2, 3, 4]
[00:24:15] <strcat> hm in that case it did
[00:24:19] * strcat shrugs
[00:25:17] <strcat> rusti: let _ = ~[1, 2, 3, 4]; let _ = [5, 6, 7, 8]; for _ in range(0, 2) { let mut xs: ~[int] = std::vec::with_capacity(4); std::vec::raw::set_len(&mut xs, 4); printfln!("%?", xs) }
[00:25:19] -rusti- line longer than 150 columns, pastebinned 5 lines of output: http://ix.io/7tf
[00:25:39] <strcat> rusti: let _ = ~[1, 2, 3, 4]; let _ = [5, 6, 7, 8]; for _ in range(0, 2) { let mut xs: ~[int] = std::vec::with_capacity(4); unsafe { std::vec::raw::set_len(&mut xs, 4) }; printfln!("%?", xs) }
[00:25:39] -rusti- ~[1, 2, 3, 4]
[00:25:40] -rusti- ~[1, 2, 3, 4]
[00:25:40] -rusti- ()
[00:26:20] <strcat> rusti: let _ = ~[1, 2, 3, 4]; let _ = [5, 6, 7, 8]; let mut xss = ~[]; for _ in range(0, 2) { let mut xs: ~[int] = std::vec::with_capacity(4); unsafe { std::vec::raw::set_len(&mut xs, 4) }; printfln!("%?", xs); xss.push(xs) }
[00:26:21] -rusti- ~[0, 0, 0, 0]
[00:26:21] -rusti- ~[0, 0, 140063178489857, 140064197833056]
[00:26:22] -rusti- ()
[00:26:32] <strcat> wat
[00:26:46] <acrichto> printfln performs @ allocations
[00:26:48] <strcat> ah
[00:27:07] <strcat> rusti: let _ = ~[1, 2, 3, 4]; let _ = [5, 6, 7, 8]; let mut xss = ~[]; for _ in range(0, 2) { let mut xs: ~[int] = std::vec::with_capacity(4); unsafe { std::vec::raw::set_len(&mut xs, 4) }; xss.push(xs) } for xs in xss { printfln!("%?", xs) }
[00:27:09] -rusti- line longer than 150 columns, pastebinned 5 lines of output: http://ix.io/7tg
[00:27:21] <strcat> rusti: let _ = ~[1, 2, 3, 4]; let _ = [5, 6, 7, 8]; let mut xss = ~[]; for _ in range(0, 2) { let mut xs: ~[int] = std::vec::with_capacity(4); unsafe { std::vec::raw::set_len(&mut xs, 4) }; xss.push(xs) } for xs in xss.move_iter() { printfln!("%?", xs) }
[00:27:22] -rusti- ~[0, 0, 0, 0]
[00:27:22] -rusti- ~[0, 0, 0, 0]
[00:27:22] -rusti- ()
[00:27:39] <strcat> rusti: { let _ = ~[1, 2, 3, 4]; let _ = [5, 6, 7, 8]; } let mut xss = ~[]; for _ in range(0, 2) { let mut xs: ~[int] = std::vec::with_capacity(4); unsafe { std::vec::raw::set_len(&mut xs, 4) }; xss.push(xs) } for xs in xss.move_iter() { printfln!("%?", xs) }
[00:27:40] -rusti- ~[0, 0, 0, 0]
[00:27:40] -rusti- ~[0, 0, 0, 0]
[00:27:40] -rusti- ()
[00:27:47] * strcat gives up
[00:27:48] <sully> what are you trying to do?
[00:28:01] <strcat> the default capacity is 4
[00:28:18] <strcat> sully: retrieve the old vector from the allocator cache ;p
[00:28:23] <strcat> I succeeded with 1
[00:29:29] <strcat> they are something like 48 byte allocations so they'll be in the 64-byte bin
[00:32:43] *** Quits: strcat (strcat@moz-54F7FD49.cpe.net.cable.rogers.com) (Ping timeout)
[00:34:19] *** Joins: strcat (strcat@moz-54F7FD49.cpe.net.cable.rogers.com)
[00:34:36] *** Joins: jmgrosen (jmgrosen@moz-848F6087.sb.sd.cox.net)
[00:35:34] *** Quits: lenstr (lenstr@AF8EB999.6049B16A.85938D85.IP) (Client exited)
[00:36:18] *** Joins: samx (sami@moz-48EC0983.dyn.optonline.net)
[00:36:25] *** Joins: lenstr (lenstr@AF8EB999.6049B16A.85938D85.IP)
[00:36:37] *** Quits: rusti (rusti@moz-54F7FD49.cpe.net.cable.rogers.com) (Ping timeout)
[00:36:39] *** Joins: rusti (rusti@moz-54F7FD49.cpe.net.cable.rogers.com)
[00:36:45] *** Joins: Kruppe (user@moz-E150F49F.cpe.net.cable.rogers.com)
[00:37:09] *** Quits: lenstr (lenstr@AF8EB999.6049B16A.85938D85.IP) (Client exited)
[00:37:47] <brson> acrichto: is it possible to preserve the old blocking std::run code? eventually we need both blocking and non-blocking versions of everything
[00:38:15] *** Joins: int3_ (int3_@moz-ABE52D50.hsd1.ca.comcast.net)
[00:38:16] <brson> acrichto: there's a folder in rt::io::native that implements nothing yet for the blocking stuff
[00:38:22] <acrichto> brson: oh huh, I didn't know we wanted to do that
[00:38:31] <acrichto> brson: I could just copy the current std::run into that folder?
[00:38:50] <brson> acrichto: my ultimate goal is to have std::io be some sort of facade that dynamically picks which implementation to used based on context
[00:39:07] <brson> and probably similar for std::run
[00:39:11] <acrichto> for support in runtime-less situations?
[00:39:13] <brson> yes
[00:39:35] <acrichto> huh ok, the I/O between the parent/child could get interesting
[00:39:43] <brson> acrichto: is the new run interface similar enough to the old that the old can be preserved and they both implement the same interface?
[00:40:03] *** Quits: int3_ (int3_@moz-ABE52D50.hsd1.ca.comcast.net) (Ping timeout)
[00:40:07] <acrichto> brson: yeah they're exactly the same right now, although it needs a redesign
[00:40:10] <brson> if the old can't be preserved I'm *ok* with throwing it out, but that module did have a lot of accumulated knowledge, grungy as it is
[00:40:44] *** Quits: tiffany (kawaii@moz-EB8B0C08.dhcp.embarqhsd.net) (Ping timeout)
[00:40:50] <strcat> brson: it's not very robust though
[00:40:57] <strcat> infinite loops if exec fails, etc.
[00:40:59] *** Joins: tiffany (kawaii@moz-EB8B0C08.dhcp.embarqhsd.net)
[00:41:17] <acrichto> brson: that is a good point, is the idea that rt::io::native::process would also implement the RtioProcess trait?
[00:41:27] *** Quits: bent (chatzilla@moz-BE33DA21.fw1.sfo1.mozilla.net) (Quit: ChatZilla 0.9.90.1-rdmsoft [XULRunner 22.0/20130619132145])
[00:41:37] <acrichto> brson: and then std::run could select between rt::uv::process and rt::io::native::process
[00:41:52] <brson> acrichto: that has not been my plan, no, but it could be concievably structured that way
[00:42:10] <acrichto> pipes are the trickiest part about that
[00:42:23] <acrichto> but that might be able to get abstracted a bit
[00:42:40] *** Joins: jorendorff (jorendorff@moz-2F32ACA3.hsd1.tn.comcast.net)
[00:43:26] <dbaupp> cmr: any update on the bencher? (did you say something about it being borked?)
[00:48:53] *** Joins: Yurume (yurume@AC58A8CE.8A059B47.E313B915.IP)
[00:49:27] *** Joins: heftig_ (heftig@moz-EA55FCAD.dip0.t-ipconnect.de)
[00:49:33] <strcat> acrichto: hm, so how exactly will the formatting to a writer work?
[00:49:40] *** Quits: heftig (heftig@moz-B80FE22D.dip0.t-ipconnect.de) (Ping timeout)
[00:49:41] <strcat> like, what method will it use on the writer?
[00:49:45] <acrichto> .write()
[00:50:07] <acrichto> it'd just emit to a `&mut io::Writer`
[00:50:43] <strcat> so, it will output &[u8]?
[00:51:09] *** Joins: james4k (james@moz-E7990244.consolidated.net)
[00:51:13] <dbaupp> acrichto: so we're definitely using a trait object?
[00:52:14] *** Quits: ozten|afk (ozten@moz-DD3B00B4.hsd1.wa.comcast.net) (Quit: ozten|afk)
[00:52:16] <acrichto> dbaupp: yes
[00:52:26] <acrichto> strcat: kinda? fprintf would return () ?
[00:52:37] <dbaupp> :(
[00:52:39] *** Quits: maxli1 (maxli@B5559308.9C54E60.2FA4EA88.IP) (Quit: Leaving.)
[00:52:45] <acrichto> is that bad?
[00:52:57] <pcwalton> graydon: I have code for lazy resolve written, need to debug it
[00:53:03] <pcwalton> just FYI
[00:53:59] *** Quits: eatkinson (eatkinson@moz-BBE3ABD.mv.mozilla.com) (Quit: eatkinson)
[00:54:05] *** Quits: jmgrosen (jmgrosen@moz-848F6087.sb.sd.cox.net) (Quit: jmgrosen)
[00:54:08] <dbaupp> acrichto: it's just it means that we *always* have the cost of a virtual call, rather than having the flexibility to choose.
[00:54:54] <acrichto> dbaupp: true, although I would want to bench it to see if that actually matters. the bonuses of an object are hopefully less codegen and also less writing <T: Trait> in all the format trait impls
[00:54:56] *** Joins: jmgrosen (jmgrosen@moz-848F6087.sb.sd.cox.net)
[00:55:16] <acrichto> dbaupp: I think the only case where that would matter would possibly be sprintf, if you're doing any sort of I/O I don't think a virtual method call is going to matter that much
[00:55:22] <acrichto> (I could be wrong though)
[00:55:35] <dbaupp> acrichto: yes, I think so
[00:55:47] *** Quits: dew (Instantbir@moz-D2FA52B6.static.stls.mo.charter.com) (Ping timeout)
[00:55:58] *** Joins: dew (Instantbir@moz-D2FA52B6.static.stls.mo.charter.com)
[00:56:08] <dbaupp> (although the codegen wouldn't be that bad, since it'd just be monomorphised to &mut Writer and MemWriter in the stdlib, I guess.)
[00:56:37] <acrichto> If you have <T: Trait> can you actually pass it a trait object?
[00:56:46] <pcwalton> no
[00:56:49] <dbaupp> if it implements the trait, yes
[00:57:06] <dbaupp> i.e. you need `impl Foo for &'self mut Foo { ... }`
[00:57:09] *** Joins: MrByte (MrByte@moz-147070D0.chy-wy.client.bresnan.net)
[00:57:27] <dbaupp> (this could be done automatically by a syntax extension)
[00:57:36] <pcwalton> in some cases
[00:57:39] <pcwalton> there are edge cases which are tricky
[00:57:59] *** Quits: tiffany (kawaii@moz-EB8B0C08.dhcp.embarqhsd.net) (Ping timeout)
[00:58:27] *** Quits: jmgrosen (jmgrosen@moz-848F6087.sb.sd.cox.net) (Quit: jmgrosen)
[00:58:28] <acrichto> dbaupp: https://gist.github.com/anonymous/6302082 doesn't compile?
[00:59:14] *** Quits: reyre (reyre@moz-9002CDDA.cpe.net.cable.rogers.com) (Client exited)
[00:59:15] <dbaupp> acrichto: https://gist.github.com/huonw/6302086 should
[00:59:19] *** Quits: hjr3 (hradtke@1A0AE795.28A5F6C3.A2D40ED2.IP) (Quit: My MacBook has gone to sleep. ZZZzzzâ€¦)
[00:59:38] <acrichto> doesn't for me
[01:00:10] <acrichto> dbaupp: oh, change the second call to foo(&(&a as &A)); and it works
[01:00:21] *** Quits: bytewise (bytewise@moz-4A801D04.unitymediagroup.de) (Quit: Leaving)
[01:00:31] *** Joins: tiffany (kawaii@moz-EB8B0C08.dhcp.embarqhsd.net)
[01:00:52] *** Joins: recrack (Mibbit@B4104EBB.3CC170B1.1E14B209.IP)
[01:01:01] *** Quits: BitPuffin (quassel@moz-8370D1B9.bredband.comhem.se) (Client exited)
[01:01:21] *** Joins: lkuper_ (lkuper@moz-C0CD33ED.hsd1.in.comcast.net)
[01:02:41] *** Joins: eatkinson (eatkinson@moz-BBE3ABD.mv.mozilla.com)
[01:02:45] <toddaaro> how do I free the memory used by a vector, but not free the elements pointed to by the inside?
[01:02:58] <toddaaro> cast to ~[uint]?
[01:03:16] *** Quits: tiffany (kawaii@moz-EB8B0C08.dhcp.embarqhsd.net) (Ping timeout)
[01:03:23] <strcat> cast to a * and call exchange_free on it
[01:03:28] <strcat> assuming it has no @ inside
[01:03:35] <toddaaro> mmm exchange_free where is this
[01:03:42] *** Quits: MrFahrenheit (RageOfThou@3FEF494C.29C984D5.783DEDCA.IP) (Ping timeout)
[01:03:42] *** Quits: jclements (jclements@moz-37891906.dsl.snlo01.pacbell.net) (Quit: jclements)
[01:03:45] <strcat> std::rt::global_heap maybe
[01:03:51] <aatch> toddaaro, this is for shrinking?
[01:04:14] <toddaaro> aatch: growing
[01:04:36] <toddaaro> post-copying gotta dump the old raw vector
[01:04:38] *** Quits: jorendorff (jorendorff@moz-2F32ACA3.hsd1.tn.comcast.net) (Quit: jorendorff)
[01:04:48] <toddaaro> I think unsafe_copy is going to work out for the elements
[01:05:22] *** Joins: tiffany (kawaii@moz-EB8B0C08.dhcp.embarqhsd.net)
[01:05:37] <toddaaro> rusti: unsafe { std::rt::global_heap::exchange_free(transmute(120)) }
[01:05:40] -rusti- <anon>:5:54: 5:63 error: unresolved name `transmute`.
[01:05:40] -rusti- <anon>:5          unsafe { std::rt::global_heap::exchange_free(transmute(120)) }
[01:05:40] -rusti-                                                                ^~~~~~~~~
[01:05:40] -rusti- error: aborting due to previous error
[01:05:40] -rusti- application terminated with error code 101
[01:05:50] <toddaaro> rusti: unsafe { std::rt::global_heap::exchange_free(std::cast::transmute(120)) }
[01:05:52] -rusti- application terminated abnormally with signal 11 (Segmentation fault)
[01:05:56] <toddaaro> perfect
[01:08:54] *** Joins: reyre (reyre@moz-9002CDDA.cpe.net.cable.rogers.com)
[01:09:29] *** Quits: engla (engla@moz-DBD1D96E.cust.bredbandsbolaget.se) (Ping timeout)
[01:10:40] <strcat> #[non_nullable_pointer] or #[unsafe_non_nullable_pointer] for an attribute that will make Option<Rc<T>> 1-word? it's unsafe to stick on an arbitrary thing
[01:10:56] *** Joins: HalcyonQc (bzlandfill@moz-4BC5F491.cpe.net.cable.rogers.com)
[01:11:10] <dbaupp> strcat: the latter
[01:11:13] <toddaaro> so this would guarentee a thing is one word?
[01:11:32] <strcat> generalize things that are 1-word but *never* zero
[01:11:40] <strcat> since it uses zero as the tag
[01:11:51] <toddaaro> hm
[01:11:57] *** Quits: HalcyonQc (bzlandfill@moz-4BC5F491.cpe.net.cable.rogers.com) (Quit: CGI:IRC (EOF))
[01:11:59] <dbaupp> strcat: it'd be really neat if the nullable pointer optimisation also looked inside structures and used ptrs there, e.g. Option<(uint, ~int)> == 2 words
[01:12:07] <strcat> so, with #[unsafe_no_drop_flag] + #[unsafe_non_nullable_pointer] you'd get a 1-word smart ptr with a destructor + the Option optimization
[01:12:19] <dbaupp> #[unsafe_never_zero] ?
[01:12:20] *** Joins: HalcyonQc (bzlandfill@moz-4BC5F491.cpe.net.cable.rogers.com)
[01:12:30] <strcat> no it's specifically about pointers
[01:12:39] <strcat> atm at least
[01:13:06] <toddaaro> rusti: unsafe { let x: uint = transmute(~[1,2,3]); x }
[01:13:06] -rusti- <anon>:5:32: 5:41 error: unresolved name `transmute`.
[01:13:06] -rusti- <anon>:5          unsafe { let x: uint = transmute(~[1,2,3]); x }
[01:13:06] -rusti-                                          ^~~~~~~~~
[01:13:06] -rusti- error: aborting due to previous error
[01:13:07] -rusti- application terminated with error code 101
[01:13:09] <strcat> it'd likely be wrong to put it on a non-word-size thing
[01:13:14] <toddaaro> rusti: unsafe { let x: uint = std::cast::transmute(~[1,2,3]); x }
[01:13:14] -rusti- 139659611074720
[01:13:48] <dbaupp> strcat: it doesn't have to be specific to pointers? anything that word-sized and always non-zero can have this optimisation.
[01:13:57] <strcat> not right now
[01:14:16] <toddaaro> what is the best way to call a ~self method on a *?
[01:14:23] <strcat> I'm not adding an enum optimization, just making the current one a feature usable by library types
[01:14:26] <toddaaro> transmute? or is there something cleaner
[01:15:24] <dbaupp> toddaaro: it's unsafe, so anything other than transmute would be (mostly) redudant
[01:15:29] <aatch> toddaaro, pretty much just transmute
[01:15:38] <toddaaro> k, I'll do that then
[01:15:47] <strcat> dbaupp: I mean it's totally possible it would work for a more general case
[01:15:56] <strcat> but the code would need to be validated/tested for that
[01:16:07] <strcat> it wasn't considere
[01:16:08] <strcat> d
[01:16:21] <dbaupp> right
[01:16:59] <strcat> adt.rs explicitly calls that representation NullablePointer
[01:17:18] <strcat> and what does zero mean on a non-word sized thing? :) 
[01:17:21] <strcat> could have padding
[01:17:38] <dbaupp> ... that's why it'd be an error to apply it to a non-word-sized thing.
[01:17:54] <strcat> #[non_zero_word] ?
[01:18:00] <strcat> unsafe_non_zero_word
[01:18:51] <strcat> I'm not going to add any checks for size though
[01:19:47] <strcat> rusti: match (1, 2) { (x, 2) if x == 1 => true, _ => false }
[01:19:48] -rusti- true
[01:20:03] <toddaaro> how do I ignore a cannot assign because borrowed error and assign anyway?
[01:20:41] <dbaupp> toddaaro: transmute
[01:20:53] <toddaaro> on the source?
[01:20:57] <toddaaro> or the dest
[01:20:59] <toddaaro> dest I guess
[01:21:19] *** Joins: jmgrosen (jmgrosen@moz-848F6087.sb.sd.cox.net)
[01:21:31] <dbaupp> how/why are you having to abuse the typesystem so much?
[01:21:42] <strcat> rusti: std::sys::size_of::<extra::rc::Rc>()
[01:21:43] -rusti- <anon>:5:29: 5:42 error: wrong number of type arguments: expected 1 but found 0
[01:21:43] -rusti- <anon>:5          std::sys::size_of::<extra::rc::Rc>()
[01:21:44] -rusti-                                       ^~~~~~~~~~~~~
[01:21:44] -rusti- application terminated with error code 101
[01:21:46] <toddaaro> writing low-level atomic datastructures
[01:21:48] <strcat> rusti: std::sys::size_of::<extra::rc::Rc<()>>()
[01:21:49] -rusti- 8
[01:21:55] <strcat> rusti: std::sys::size_of::<Option<extra::rc::Rc<()>>>()
[01:21:56] -rusti- 16
[01:22:30] *** Joins: erickt1 (Adium@49C4075F.3AC15C18.2321E71E.IP)
[01:22:36] *** Quits: brendan (brendaneic@moz-BBE3ABD.mv.mozilla.com) (Quit: brendan)
[01:22:37] <toddaaro> right now I'm writing a grow for a circular array that allows access to the old array until the copy into the new one is done
[01:22:39] <erickt1> graydon: ping
[01:22:54] <erickt1> and strcat too
[01:23:00] <strcat> erickt1: pong
[01:23:11] *** Quits: jmgrosen (jmgrosen@moz-848F6087.sb.sd.cox.net) (Ping timeout)
[01:23:46] <erickt1> strcat: heya. so I can't remember if you participated in the conversation I had earlier with graydon about converting serialize.rs to use iterators
[01:23:53] <strcat> a bit
[01:24:07] * strcat suggested the mmap/bswap trickery
[01:24:13] <erickt1> ah, righto
[01:24:16] *** Joins: tcr (tcr@moz-EE576D3C.hsd1.ma.comcast.net)
[01:24:17] <strcat> but not really anything about iterators/serialize
[01:24:22] *** Joins: enix (enix@moz-A50569DD.c3-0.slvr-ubr1.lnh-slvr.md.cable.rcn.com)
[01:25:00] <erickt1> well if we do do the conversion, #[deriving(Encodable,Decodable)] is going to have to be migrated to a state machine to keep tracking of things, and that's going to essentially be a generator in all but name
[01:25:46] <erickt1> so maybe we should get generators working sooner rather than later
[01:25:57] *** Quits: tcr (tcr@moz-EE576D3C.hsd1.ma.comcast.net) (Ping timeout)
[01:26:37] <strcat> dbaupp: http://ix.io/7tk/diff attempt one
[01:26:48] <strcat> things never turn out to be as simple as they seem ofc
[01:26:59] *** Quits: eatkinson (eatkinson@moz-BBE3ABD.mv.mozilla.com) (Quit: eatkinson)
[01:27:04] * strcat has to update the users of mono_data_classify
[01:27:05] *** Quits: huseby (huseby@moz-4E8C421A.husebyhome.com) (Quit: Leaving)
[01:27:14] <strcat> and not making typos in the signature.
[01:27:53] <dbaupp> erickt1: the deriving({En,De}codable) state-machine-maker one would be much simpler than the fully general generator compiler
[01:28:26] <dbaupp> strcat: easy enough
[01:28:47] <erickt1> dbaupp: but not *that* much simpler
[01:28:49] *** Quits: james4k (james@moz-E7990244.consolidated.net) (Ping timeout)
[01:28:57] <dbaupp> strcat: (I think adding the error message would be good & relatively easy, wouldn't it?)
[01:29:18] <strcat> on non-word size things?
[01:29:22] <dbaupp> strcat: if ty.size_of() != tcx.word_size { tcx.span_err(...) }
[01:29:27] <erickt1> dbaupp: although maybe my "fully general generator compiler" is more specific than yours
[01:29:37] <dbaupp> strcat: assuming that you can get size_of at this point of trans.
[01:29:58] <strcat> dbaupp: well I think we get the size by asking LLVM, so I might need more stuff
[01:29:59] <dbaupp> erickt1: possibly/probably
[01:30:13] <strcat> you need the whole ccx
[01:30:13] *** Joins: eatkinson (eatkinson@moz-BBE3ABD.mv.mozilla.com)
[01:30:28] <erickt1> dbaupp: were you considering yielding from closures? I figured I would prevent that
[01:30:58] <erickt1> dbaupp: so the only tricky bit is how to deal with loops
[01:30:59] *** Joins: z0w0 (corrz@C3BC732A.9254B1A4.F22F0031.IP)
[01:31:18] <aatch> strcat, you could be a bit sneaky and pull the LLVM context out of the task-local-storage.
[01:31:29] <strcat> the hard part of generator compilation is recursion
[01:32:02] <erickt1> dbaupp: I figure it's not that hard though. each loop would get it's own state machine
[01:32:18] <strcat> I don't think you need anything special for loops
[01:32:37] <aatch> strcat, we could just do what PHP does and make the generator re-yield.
[01:32:41] <erickt1> strcat: you do if you want to do `loop { yield 1; yield 2; }`
[01:33:10] <brson> does anybody know what the recent compile time regression was?
[01:33:24] <dbaupp> brson: the LLVM probably
[01:33:40] <erickt1> strcat: to get to the "yield 2", you first need to jump to the loop state, then jump past the "yield 1"
[01:33:56] <dbaupp> brson: self.zero_pad(self.hash(key).digest),
[01:34:04] <dbaupp> brson: https://github.com/mozilla/rust/issues/8665 (sorry)
[01:34:09] <toddaaro> generator compilation seems like it would have a lot of literature
[01:34:10] <erickt1> strcat: there's probably a more optimal way of implementing it, but the first pass should be not *that* difficult
[01:34:17] <strcat> dbaupp: that doesn't show up on http://huonw.github.io/isrustfastyet/buildbot/ though
[01:34:19] <toddaaro> any papers that describe implementations/issues?
[01:34:41] <dbaupp> strcat: I don't see any recent regression?
[01:34:48] <strcat> that's what I mean
[01:35:22] <aatch> Was there any consensus on generator declaration functions? `yeild fn`?
[01:35:38] <pcwalton> graydon: resolve goes from 0.145 s -> 0.012 s
[01:35:40] <pcwalton> for hello world
[01:35:48] <acrichto> pcwalton: !!! awesome!!
[01:35:52] <erickt1> strcat: regarding recursion, we'd follow the python model of `gen fn foo(inner: bool) -> int { if inner { yield 1; } else { for x in foo(true) { yield 2 } }`
[01:36:04] *** Joins: james4k (james@moz-E7990244.consolidated.net)
[01:36:30] <dbaupp> pcwalton: woah
[01:37:08] <pcwalton> in order to fix the coherence problem we need to make method lookup lazy
[01:37:21] <pcwalton> and then decompression of metadata
[01:37:24] <strcat> what's the coherence problem?
[01:37:30] <erickt1> strcat: generators would have a context object, for recursion we'd just have a recursive structure 
[01:37:31] <pcwalton> strcat: we load all method info for all types eagerly
[01:37:37] <strcat> pcwalton: so it clobbers?
[01:37:38] <pcwalton> which is bad
[01:37:39] <ion> erickt1: What does that achieve that closures donâ€™t? (Asking sincerely.)
[01:37:41] *** Joins: josedonizetti (josedonize@moz-CA73D699.cpe.teksavvy.com)
[01:37:58] <pcwalton> strcat: it just loads info for all types from the metadata even if you don't call any methods on them
[01:38:02] <erickt1> ion: it'd be very similar to a closure
[01:38:06] <strcat> pcwalton: ah
[01:38:16] <dbaupp> ion: speed (via better optimisability) I think
[01:38:55] <erickt1> ion: oh, I was talking implementation of a generator. generators are essentially a closure and a state machine
[01:38:59] *** Quits: strcat (strcat@moz-54F7FD49.cpe.net.cable.rogers.com) (Connection reset by peer)
[01:39:04] *** Joins: strcat (strcat@moz-54F7FD49.cpe.net.cable.rogers.com)
[01:39:16] <ion> dbaupp: ok
[01:40:11] *** Quits: pcwalton (pcwalton@moz-7B0110AD.mv.mozilla.com) (Quit: pcwalton)
[01:40:39] <strcat> ion: not really representing the same thing as a closure
[01:41:03] <strcat> lets say you want to traverse a binary tree
[01:41:28] <strcat> fn traverse(tree, callback) { visit(tree.left); callback(tree.value); visit(tree.right) }
[01:41:36] <strcat> now, lets say you want that traversal to be *stateful*
[01:41:36] *** Joins: ghrust (ghrust@C8693FCB.6A2AE50.F3114085.IP)
[01:41:36] <ghrust> 01[13rust01] 15bors merged 06auto into 06master: 02http://git.io/vogwag
[01:41:36] *** Parts: ghrust (ghrust@C8693FCB.6A2AE50.F3114085.IP) ()
[01:41:41] <strcat> you should be able to pause it at any time
[01:41:47] <strcat> i.e. you can zip two trees
[01:42:02] <ion> strcat: Alright, thanks
[01:42:06] <strcat> you need to define a struct with the state, and manually build a "call stack"
[01:42:10] <strcat> so
[01:42:36] <strcat> fn traverse(tree) { for x in visit(tree.left) { yield x; } yield tree.value; for x in visit(tree.right) { yield x } }
[01:42:38] *** Joins: sankha93 (Instantbir@7061CD01.D6BD0D91.22D41759.IP)
[01:42:38] <strcat> rather than
[01:43:30] *** Quits: tedh_ (tedh@moz-F0B37C08.hsd1.il.comcast.net) (Broken pipe)
[01:43:31] *** Quits: jgilbert (jgilbert@moz-BBE3ABD.mv.mozilla.com) (Ping timeout)
[01:43:37] <strcat> hrm, treemap's iterator is way more complex now
[01:43:51] *** Joins: tedh (tedh@moz-F0B37C08.hsd1.il.comcast.net)
[01:43:59] <strcat> it doesn't seem like lower/upper bounds should use the same iterator
[01:44:04] *** Quits: jaen (jaen@moz-E0979827.copit.pl) (Ping timeout)
[01:44:24] <strcat> oh well ;p
[01:45:31] *** Quits: tedh (tedh@moz-F0B37C08.hsd1.il.comcast.net) (Ping timeout)
[01:47:53] <strcat> oh because of the bidirectional thing
[01:48:39] <strcat> dbaupp: there have been a lot of mem usage regressions.
[01:49:27] <dbaupp> strcat: ok
[01:49:45] <strcat> hm
[01:49:46] <dbaupp> strcat: (the only one I know about is https://github.com/mozilla/rust/issues/8589 )
[01:49:50] *** Quits: eschweic (Adium@moz-BBE3ABD.mv.mozilla.com) (Quit: Leaving.)
[01:50:02] <strcat> yeah but we never fixed the AST one
[01:50:05] <strcat> and that was 400MiB
[01:50:16] <strcat> so it's 900MiB from just those two
[01:50:31] <jld> I think something in the Rust build blew away the uncommitted changes I had in my src/libuv submodule.  Was that intentional?
[01:50:40] <dbaupp> strcat: we *almost* caught up to the AST one despite not fixing it.
[01:50:50] <strcat> jld: it touches them, yeah
[01:51:02] <strcat> maybe not supposed to force, I dunno
[01:51:12] <strcat> ./configure updates them
[01:51:27] <strcat> well and make
[01:51:29] <dbaupp> well, 150MB away. (1200 vs 1350)
[01:51:44] *** Joins: ghrust (ghrust@1E8607E8.6A2AE50.F3114085.IP)
[01:51:44] <ghrust> 01[13rust01] 15bors pushed 0 new commits to 06auto: 02http://git.io/ttwM1w
[01:51:44] *** Parts: ghrust (ghrust@1E8607E8.6A2AE50.F3114085.IP) ()
[01:51:45] *** Joins: ghrust (ghrust@79968228.6A2AE50.F3114085.IP)
[01:51:46] <ghrust> 01[13rust01] 15bors pushed 11 new commits to 06auto: 02http://git.io/zJ8qXA
[01:51:46] <ghrust> 13rust/06auto 14369f7fa 15Ben Blum: Prevent Send, Freeze, and Sized from being manually implemented. Close #8517.
[01:51:46] <ghrust> 13rust/06auto 1469322d9 15Ben Blum: Allow traits to use builtin kinds as supertraits for #7083.
[01:51:46] <ghrust> 13rust/06auto 144ca2e55 15Ben Blum: Add tests for #7083.
[01:51:47] *** Parts: ghrust (ghrust@79968228.6A2AE50.F3114085.IP) ()
[01:53:13] *** Quits: lmandel (lmandel@moz-BBE3ABD.mv.mozilla.com) (Quit: lmandel)
[01:55:15] <toddaaro> does rust expose memcpy?
[01:55:28] *** Quits: sankha93 (Instantbir@7061CD01.D6BD0D91.22D41759.IP) (Quit: Gone to save the world!)
[01:55:34] <dbaupp> toddaaro: in unstable::intrinsics iirc
[01:55:50] <toddaaro> dbaupp: awesome, thanks
[01:55:55] <strcat> toddaaro: ptr::copy_nonoverlapping_memory
[01:56:03] <strcat> and ptr::copy_memory has memmove semantics
[01:56:17] <strcat> they wrap the intrinsics
[01:57:46] *** Quits: dave1629 (dave@moz-17578A1A.hsd1.va.comcast.net) (Quit: dave1629)
[01:58:14] *** Quits: HalcyonQc (bzlandfill@moz-4BC5F491.cpe.net.cable.rogers.com) (Quit: CGI:IRC (EOF))
[01:59:50] <toddaaro> ah, cool, I'll use those
[02:00:43] *** Quits: diverse (Mibbit@moz-601F0275.static.mtpk.ca.charter.com) (Quit: http://www.mibbit.com ajax IRC Client)
[02:01:41] *** Joins: eschweic (Adium@moz-BBE3ABD.mv.mozilla.com)
[02:02:09] <strcat> dbaupp: well, it works
[02:02:35] <dbaupp> strcat: awesome
[02:04:06] *** Joins: jmgrosen (jmgrosen@moz-F947D1B7.cs.ucsb.edu)
[02:04:15] *** Quits: dbaupp (Thunderbir@moz-EAA09AEF.lns20.syd7.internode.on.net) (Ping timeout)
[02:04:36] *** Joins: sk (sk@61A494B3.BA40E8A.AAC02D62.IP)
[02:05:10] <toddaaro> what is the type of a vector? in the context of "how do I make a *mut to a vector?"
[02:05:15] <toddaaro> I can't figure it out
[02:05:20] <toddaaro> it isn't Vector
[02:05:24] <toddaaro> and it isn't []
[02:05:37] <strcat> you mean ~[T]?
[02:05:41] <toddaaro> yea
[02:05:54] <toddaaro> how do I get a *mut to the first element
[02:06:07] <Eridius> toddaaro: cast &v[0]
[02:06:21] <Eridius> naturally this requires the vector to have at least 1 element, but if it doesn't, then there's nothing to take a pointer to anyway
[02:06:33] *** Quits: samx (sami@moz-48EC0983.dyn.optonline.net) (Quit: This computer has gone to sleep)
[02:07:07] <strcat> rusti: use std::unstable::raw::Repr; let xs = ~[1, 2, 3]; xs.repr()
[02:07:13] -rusti- timeout triggered!
[02:07:19] <strcat> rusti: use std::unstable::raw::Repr; let xs = ~[1, 2, 3]; xs.repr()
[02:07:25] -rusti- timeout triggered!
[02:07:25] <strcat> :s
[02:07:32] <strcat> rusti: use std::unstable::raw::Repr; let xs = ~[1, 2, 3]; xs.repr()
[02:07:34] -rusti- {data: (0x7fc93141f0b0 as *()), len: 24}
[02:07:45] *** Joins: infynyxx (infynyxx@moz-E95B370B.nyc.res.rr.com)
[02:07:49] <strcat> oh that did a slice
[02:07:55] <strcat> wat
[02:08:03] <Eridius> yeah, Repr doesn't seem to be implemented for ~[T]
[02:08:14] <strcat> I guess it'd be unsafe
[02:08:16] <Eridius> probably because it needs to take a &self so it can't take an owned vector anyway
[02:08:26] <strcat> would leak
[02:08:38] <benh> rusti: use std::unstable::raw::Repr; let xs = ~[1, 2, 3]; (&xs).repr()
[02:08:42] <strcat> without a dtor
[02:08:43] <Eridius> yeah, Vec appears to be a fixed-size structure but it's really dynamically-sized
[02:08:44] -rusti- timeout triggered!
[02:08:56] <strcat> rusti is being weird
[02:09:00] <Eridius> rusti: 42
[02:09:05] -rusti- timeout triggered!
[02:09:10] <Eridius> heh
[02:09:26] <strcat> rusti: 2
[02:09:29] -rusti- 2
[02:09:42] <benh> I'll probably just get the pointer...
[02:09:43] <benh> rusti: use std::unstable::raw::Repr; let xs = ~[1, 2, 3]; (&xs).repr()
[02:09:44] -rusti- {data: (0x7f34b641f0b0 as *()), len: 24}
[02:09:52] *** Joins: samx (sami@moz-48EC0983.dyn.optonline.net)
[02:09:57] <toddaaro> Eridius: ah, I think that does the trick, thanks
[02:10:11] <benh> :(
[02:10:38] *** Quits: tjc (tjc@moz-BBE3ABD.mv.mozilla.com) (Quit: Places to go, people to annoy)
[02:10:46] <toddaaro> is there something like array that isn't secretly silly?
[02:11:04] <toddaaro> or is the with_capacity and set_len trick the best option
[02:11:18] <strcat> that's the best option
[02:11:34] <toddaaro> is it guarenteed to not do anything fishy?
[02:11:51] <strcat> when the length is full and you push, it doubles capacity
[02:12:04] <toddaaro> ok, so as long as I take over before that I'm safe
[02:12:24] <strcat> er I mean when length == capacity and you push, it doubles capacity
[02:12:53] <Eridius> strcat: given the number of iterators in std that don't implement size_hint, I wonder if we could add a lint pass where you can mark a default method as should-implement, and the lint pass then checks to see if all impls actually do implement it
[02:13:11] <Eridius> the idea being that the default size_hint is ok, but pretty much every iterator in std should actually implement it directly
[02:13:11] *** Quits: q66 (q66@6EE9DE40.46454B5D.33AABD5F.IP) (Quit: Leaving)
[02:13:19] <strcat> Eridius: not all of them
[02:13:32] <Eridius> most of them do, and the ones that don't, having to type (0, None) isn't that onerous
[02:14:13] <Eridius> or typing #[allow(unimplemented-should-impl)] or whatever it would be called
[02:14:53] *** Quits: doomlord (doomlod@moz-13E69BC8.range86-180.btcentralplus.com) (Ping timeout)
[02:15:24] *** Quits: josedonizetti (josedonize@moz-CA73D699.cpe.teksavvy.com) (Quit: josedonizetti)
[02:16:28] <strcat> Eridius: there are going to be a lot of iterators unable to have size_hint
[02:16:35] <strcat> beyond the default
[02:17:00] <Eridius> strcat: a lot of iterators in general, or a lot in std? Because most in std have a non-default impl
[02:17:12] <Eridius> this lint pass would be set to Allow by default, and maybe Warn for std
[02:17:36] <strcat> a lot more iterators are going to be implemented in std without the ability to give a size hint
[02:17:55] <strcat> there are currently more adaptors + container iterators than anything else
[02:17:56] <Eridius> strcat: not even the simplistic `if self.done { (0, Some(0)) } else { (0, None) }` ?
[02:18:18] <strcat> that's not useful
[02:18:20] <Eridius> I mostly just want people to think about size_hint when adding new iterators, because right now the tendency is to omit size_hint entirely even when it can be known precisely
[02:18:46] <aatch> Eridius, then it should get picked up in review. I don't think this is worth an entirely new lint.
[02:19:20] <Eridius> aatch: I dunno. I've submitted 3 PRs so far adding size_hints to iterators that forgot them
[02:19:24] <toddaaro> ok, now I'm stumped on dealocation of my initial vector
[02:19:31] <toddaaro> what exactly do I give exchange_free?
[02:20:18] <strcat> toddaaro: the ptr
[02:20:21] <strcat> to the vector
[02:20:27] <strcat> not to the data
[02:20:44] <aatch> Eridius, so? We should also have tests for everything, but we don't have a lint for that, we rely on people catching it during review.
[02:21:03] <toddaaro> I tried transmute(&this.raw) where raw is a struct field raw: ~[AtomicPtr<T>]
[02:21:07] <toddaaro> that should do the trick right?
[02:21:20] <Eridius> aatch: yes, code review should be better, but as it stands right now a lot of code review is basically "does it have tests? Ok, r+"
[02:21:43] <brson> anybody seen '/home/brian/dev/rust/src/rustllvm/RustWrapper.cpp:46:43: error: â€˜llvm::sys::fsâ€™ has not been declared' and know how to resolve it?
[02:21:46] <SingingBoyo> speaking of tests, what do I exec to run them?
[02:21:55] <aatch> SingingBoyo, make check
[02:22:00] <Eridius> SingingBoyo: `make check` runs _everything_
[02:22:08] <Eridius> SingingBoyo: depending on what you're actually changing, there are smaller sets to run
[02:22:46] *** Joins: azita (Azita@moz-C1FB2A8.hsd1.ca.comcast.net)
[02:22:47] <strcat> brson: make a make clean-llvm? it was updated
[02:22:52] <SingingBoyo> Eridius: just the json module in libextra.  which... actually doesn't seem to be tested very well
[02:23:10] <SingingBoyo> now that I think about it, I only had to change one line in test.rs
[02:23:12] <Eridius> SingingBoyo: `make check-stage2-extra NO_REBUILD=1 NO_BENCH=1` will run the libextra tests from stage2, without rebuilding the compiler (and without running benchmarks)
[02:23:24] <toddaaro> be wary of NO_REBUILD
[02:23:27] <Eridius> you can pass it TESTNAME=json to restrict it to the json tests as well
[02:23:34] <brson> strcat: i've done so
[02:23:36] <toddaaro> if you get suspicious failures look at it first
[02:23:40] <brson> strcat: is it possible ccache is betraying me?
[02:23:59] <strcat> brson: not sure :(
[02:24:08] <Eridius> of course, if you think your change might have affected compilation of anything outside of that one module (i.e. compiling the compiler itself), you should go ahead and run the full `make check` suite
[02:24:21] <Eridius> typically a good idea to run `make check` anyway, if you have the time, since that's what the builders will be doing and you don't want to see unexpected failures
[02:24:25] <strcat> brson: maybe you need make clean too
[02:24:29] <strcat> but I doubt it
[02:24:30] <Eridius> but running the more limited sets is nice when you're iterating
[02:24:41] <eatkinson> does anyone know what RP means in the context "region parameterization should have inferred that this type is RP"?
[02:24:45] <brson> maybe I just botched this merge ...
[02:24:49] *** nrc|afk is now known as nrc
[02:25:01] <SingingBoyo> Eridius: well, it'd break anything using json::to_xxx but I don't expect any of the compiler code to run that
[02:25:19] <SingingBoyo> wonder if I'd be better off leaving the old methods in place for now and just adding the impl...
[02:25:23] *** Joins: jclements (jclements@moz-37891906.dsl.snlo01.pacbell.net)
[02:25:33] <brson> yep
[02:25:33] *** Joins: snadon (chatzilla@moz-3BC727E8.mc.videotron.ca)
[02:26:33] <Eridius> SingingBoyo: typically, if you're just adding new API, running the limited suite is fine because nothing else could be using that API. If you're modifying or removing API, you may want to run the full test suite before submitting
[02:27:22] *** Quits: azakai (alon@moz-BBE3ABD.mv.mozilla.com) (Ping timeout)
[02:27:23] <SingingBoyo> Eridius: alright.  thinking about it now, I should probably just stick to adding and then the json::to_xxx can get removed later.
[02:27:29] <strcat> hm
[02:27:53] <Eridius> SingingBoyo: or just remove it now and run `make check`
[02:28:03] *** Quits: azita (Azita@moz-C1FB2A8.hsd1.ca.comcast.net) (Quit: azita)
[02:29:04] <strcat> jld: do you think it would ever make sense to extend the Option<~T> optimization to structs? would have to require that people never store null in ~, but that's already required if we have fmt!("%?") able to visit priv fields
[02:29:04] <SingingBoyo> Eridius: well given how long the builds take, I guess testing can't be worse...
[02:29:32] <strcat> anyway for now just Rc
[02:32:48] <toddaaro> is there just a flag I can disable borrow check on a function with
[02:32:58] <toddaaro> that would make my life so much easier
[02:33:07] <toddaaro> no_borrowck!(...)
[02:33:29] <toddaaro> transmute helps with type errors but using it to avoid borrowck is so frustrating
[02:33:39] <toddaaro> and it completely obfuscates what is going on compared to just C code
[02:34:25] <toddaaro> I want to allocate some new memory, copy N bytes into it, and put the pointer to it in my slot where the old block_ptr was
[02:34:29] <toddaaro> this is taking hours to write
[02:34:54] *** Joins: Sergio965 (sergiobz@moz-8D9DFEEF.hsd1.ma.comcast.net)
[02:35:18] <Sergio965> Hi all. What's the difference between a vector and a slice?
[02:35:25] *** Quits: jmgrosen (jmgrosen@moz-F947D1B7.cs.ucsb.edu) (Quit: jmgrosen)
[02:35:36] <Sergio965> A slice is a borrowed pointer to a vector?
[02:35:42] <strcat> a slice is a view into any vector
[02:35:47] <strcat> it has similar semantics to a borrowed pointer
[02:36:08] <strcat> (well, a view into any block of memory)
[02:36:27] <strcat> you could considers slices a type of vector, they're the borrowed form of a vector
[02:36:48] <strcat> can't be resized (since they're a view, not a data structure)
[02:37:15] <Sergio965> I see.
[02:37:26] <Sergio965> Why are vectors and slices represented so differently internally?
[02:37:27] *** Joins: m_kato (m_kato@moz-C286AD9A.bitcat.net)
[02:37:40] *** Joins: jmgrosen (jmgrosen@moz-F947D1B7.cs.ucsb.edu)
[02:37:41] <strcat> a slice is a pointer and a length, because it's a view
[02:37:47] <Sergio965> Mhmm.
[02:37:48] <strcat> it points at some block of memory, and knows how long it is
[02:38:05] <strcat> a vector (lets just pretend ~[] is the only kind for now) is a length + capacity + the data
[02:38:27] <strcat> a fixed-size vector is just the data, the length is part of the type
[02:38:33] <Sergio965> What do "fill" and "alloc" correspond to?
[02:38:40] <Eridius> fill is length, alloc is capacity
[02:38:42] <strcat> fill is length in bytes, alloc is capacity in bytes
[02:39:07] <Sergio965> Sorry, what's the different between length and capacity? Is length <= capacity?
[02:39:26] <Eridius> yes
[02:40:02] <SingingBoyo> Sergio965: yes, length <= capacity.  length is the currently used amount of memory, capacity is the amount of memory allocated.
[02:40:36] <Sergio965> So, in memory, a vector is stored like this?: length | capacity | first_item | second_item | â€¦ | length_item | .. | empty | capacitith_empty_item?
[02:41:09] *** Quits: glennsl (textual@moz-5D7B804F.getinternet.no) (Quit: My MacBook Pro has gone to sleep. ZZZzzzâ€¦)
[02:41:13] <strcat> ~[1, 2, 3, 4] is [4|4|1|2|3|4] in a malloc'ed block
[02:41:19] <strcat> if you .push(5)
[02:41:20] <strcat> it's now
[02:41:31] <strcat> [5|8|1|2|3|4|5|x|x|x]
[02:41:33] <strcat> where x is uninit
[02:41:39] <Sergio965> Size is doubled?
[02:41:44] <Sergio965> Capacity*
[02:41:44] <strcat> (except 5 and 8 are in bytes)
[02:41:55] <strcat> Sergio965: yes, that's how vectors have O(1) amortized append
[02:41:57] <Sergio965> Ah, sounds good, sounds good.
[02:42:05] <strcat> and the same for hash tables and deques
[02:42:11] <Sergio965> Indeed.
[02:42:24] <Sergio965> Makes sense.
[02:43:07] <strcat> Sergio965: although if there are managed pointers in a vector, it also has a 4-byte @ header
[02:43:10] <strcat> even if it's ~[]
[02:43:14] <strcat> that applies to ~T too though
[02:43:14] <SingingBoyo> is there any reason my build's always stop for a while at Warning: removing previous 'lib...' libraries: ...?
[02:43:44] <Sergio965> Interesting.
[02:44:11] *** Joins: etw (john@moz-D871A25B.nyc.res.rr.com)
[02:44:20] <strcat> just because the managed allocator adds the header
[02:44:45] <strcat> and ~T and ~[T] where T is managed have to use that instead (since they are gc roots)
[02:45:09] <etw> I'm trying to pass a ~str.iter() around but unsure how to declare the type signature, CharIterator? &mut Iterator<~Str> ? any help?
[02:45:10] <Sergio965> When you say T is managed, you mean T contained a managed type?
[02:45:13] <strcat> Sergio965: yes
[02:45:29] <Sergio965> Ah, you're talking about the Box?
[02:45:36] <strcat> Sergio965: yeah, that
[02:45:52] <Sergio965> Understood.
[02:46:05] <strcat> Sergio965: ref_count (-2 for managed unique allocations), prev/next to free cycles and the tydesc to call the right destructor
[02:46:22] <Sergio965> And the data.
[02:46:23] <Sergio965> :)
[02:46:26] <strcat> when there's a mature gc, it will just have metadata in whatever form it wants
[02:46:28] <strcat> Sergio965: yeah :)
[02:46:49] <strcat> it could use headers or just store it separately - implementation detail :P
[02:46:54] <Sergio965> Indeed.
[02:47:56] <Sergio965> Is there a reason they're named fill and alloc? Length and capacity make more send, in my opinion.
[02:48:03] <Sergio965> Or rather, are more descriptive and telling.
[02:48:26] <strcat> just legacy
[02:48:38] <Sergio965> sense*
[02:49:22] <strcat> the stdlib calls them len/capacity
[02:49:26] <strcat> in the public APIs
[02:50:18] <erickt1> strcat: do you know if "for" is desugared in libsyntax or librustc?
[02:50:23] <strcat> erickt1: libsyntax
[02:51:20] <erickt1> thanks
[02:53:23] *** Quits: mihneadb (Mihnea@moz-BE33DA21.fw1.sfo1.mozilla.net) (Quit: Leaving)
[02:53:27] *** Joins: jdm (jdm@97DF0582.DEAB171B.971E19F6.IP)
[02:54:12] <strcat> erickt1: it's just a single little 5 line fn
[02:55:20] *** Joins: int3_ (int3_@moz-ABE52D50.hsd1.ca.comcast.net)
[02:55:51] <erickt1> strcat: it's a bit longer than 5 lines :)
[02:55:54] *** Quits: james4k (james@moz-E7990244.consolidated.net) (Ping timeout)
[02:55:59] *** Quits: samx (sami@moz-48EC0983.dyn.optonline.net) (Quit: This computer has gone to sleep)
[02:56:09] *** Joins: pcwalton (pcwalton@moz-481A040C.hsd1.ca.comcast.net)
[02:56:09] *** ChanServ sets mode: +o pcwalton
[02:56:11] <erickt1> graydon touched a lot of code there, maybe he rewrote it
[02:56:19] <strcat> he wrote it
[02:56:37] *** Quits: pcwalton (pcwalton@moz-481A040C.hsd1.ca.comcast.net) (Quit: .)
[02:56:40] <graydon> it should only be 5 lines if it used the quoter
[02:57:00] *** Quits: infynyxx (infynyxx@moz-E95B370B.nyc.res.rr.com) (Client exited)
[02:57:01] <graydon> the quoter doesn't know how to quote patterns though, and a couple other small bits I didn't want to hack in
[02:57:04] <graydon> so I just wrote it the hard way :(
[02:57:16] <graydon> probably not a wise cost/benefit trade. I wanted to unblock strcat.
[02:57:31] *** Joins: tcr (tcr@moz-EE576D3C.hsd1.ma.comcast.net)
[02:57:33] <erickt1> hey there graydon! I pinged you a couple minutes ago
[02:57:48] <strcat> graydon: I think it will probably need to eventually be in librustc
[02:57:54] <strcat> so it can distinguish rvalues from lvalues
[02:58:04] <strcat> well
[02:58:47] <strcat> atm it uses a temporary
[02:59:02] <erickt1> so I was thinking more about this converting the serialization stuff to iterators, and I think rewriting #[deriving(Encodable,Decodable)] would nearly be everything we need for generators
[02:59:04] <strcat> so therefore to preserve an lvalue's state (after break) it uses &mut *always*
[02:59:33] <strcat> but that means the iterator is borrowed for the loop body, even though it doesn't always need to do that
[02:59:42] <strcat> (ever?)
[02:59:52] *** Quits: nrc (nrc@7BE24E90.A5032A01.3CFC199D.IP) (Ping timeout)
[02:59:55] *** Quits: kimundi (kimundi@moz-BFDA4039.dip0.t-ipconnect.de) (Ping timeout)
[02:59:58] <strcat> yeah, it should always be not borrowed for the body
[03:00:10] <strcat> since if you already have an lvalue, it can just call next() on that
[03:00:11] <benh> does rusti (the repl, not the bot) currently work?
[03:00:17] <strcat> if it's mutable
[03:00:22] <strcat> benh: not really.
[03:00:26] <strcat> don't think it has enough stack
[03:00:59] <graydon> erickt1: I don't really know what you mean by that. how is encoding related to generators?
[03:01:09] <graydon> (note: writing long email elsewhere and soon to depart, not a _great_ time to chat)
[03:01:12] *** Joins: nrc (nrc@7BE24E90.A5032A01.3CFC199D.IP)
[03:01:43] <benh> on my last build, it segfaulted every time it compiled something, and now it seems to embed argv[0] into the input and fails very spuriously... I'm confused
[03:01:54] <erickt1> graydon: it's not encoding per-se, it's that our auto-generation of encodables/decodables will need a state machine to drive the iterators 
[03:01:57] *** Joins: jorendorff (jorendorff@moz-2F32ACA3.hsd1.tn.comcast.net)
[03:02:24] <erickt1> graydon: and that state machine generation is nearly everything we need to support generators
[03:02:33] <erickt1> graydon: okay, we can chat more about this tomorrow :)
[03:03:02] *** Joins: kimundi (kimundi@moz-7B43CEA1.dip0.t-ipconnect.de)
[03:03:48] <benh> http://ix.io/7tr -- i wasn't even really going to anything with rusti, but now I'm curious how I could have confused it this badly. I just built from master :(
[03:04:22] <strcat> we disabled the rusti tests so it broke
[03:04:30] <Eridius> benh: https://github.com/mozilla/rust/pull/8627
[03:04:41] <benh> ah :D
[03:04:42] <benh> thanks
[03:04:48] *** Joins: james4k (james@moz-E7990244.consolidated.net)
[03:05:06] *** Joins: ross (ross@moz-8A84103E.br.br.cox.net)
[03:06:52] *** Quits: jclements (jclements@moz-37891906.dsl.snlo01.pacbell.net) (Quit: jclements)
[03:06:57] <Sergio965> When you have a vector of type ~[T], and you do something like match vec { ([first, ..rest]) => something_here, }, is first of type T and rest a slice of Ts?
[03:07:09] <Sergio965> IE, is the match "rest" a cheap operationg?
[03:07:14] <Sergio965> operation*
[03:07:19] *** Quits: bjz (brendanzab@B398BE78.F804C29E.D35A31DF.IP) (Connection reset by peer)
[03:07:21] *** Joins: bjz (brendanzab@B398BE78.F804C29E.D35A31DF.IP)
[03:07:25] <strcat> Sergio965: pretty sure it always makes a slice atm
[03:07:33] <strcat> so yes
[03:07:38] <Sergio965> Cool, cool.
[03:07:40] *** Quits: Azdle (patrick@moz-8C723B60.hsd1.mn.comcast.net) (Ping timeout)
[03:07:45] *** kimundi is now known as zz_kimundi
[03:08:06] <Sergio965> Does that mean you can never get a slice from a vector of type ~[~T]?
[03:08:14] <Sergio965> (Because that would require moving the object.)
[03:08:23] <eatkinson> anybody ever got an error like "found value name used as a type: def_mod({crate: 0, node: 28166})"
[03:09:00] <eatkinson> the thing rustc thinks is a module is most certainly an enum
[03:09:28] *** Quits: rovar__ (rovar@moz-203658CB.nycmny.fios.verizon.net) (Quit: Leaving)
[03:10:16] *** Joins: lmandel (lmandel@moz-BBE3ABD.mv.mozilla.com)
[03:10:40] <SingingBoyo> Sergio965: afaik you can get a slice from any vector.  you'd get something like &[~T]
[03:10:42] <aatch> eatkinson, yep, known issue. Try qualifying the name.
[03:10:54] <toddaaro> is *mut ~[T] a pointer to a pointer to the start of memory
[03:11:04] <toddaaro> or is it not
[03:11:07] <eatkinson> aatch: thanks just found the issue on github
[03:11:19] <Sergio965> toddaaro: Pointer to the start of the vector.
[03:11:26] <toddaaro> sigh
[03:11:30] <strcat> toddaaro: pointer to the vector pointer
[03:11:31] <benh> really?
[03:11:34] *** Joins: ghrust (ghrust@C8693FCB.6A2AE50.F3114085.IP)
[03:11:34] <ghrust> 01[13rust01] 15bors merged 06auto into 06master: 02http://git.io/zJ8qXA
[03:11:34] *** Parts: ghrust (ghrust@C8693FCB.6A2AE50.F3114085.IP) ()
[03:11:39] <Sergio965> Actually, yeah, pointer to the pointer.
[03:11:43] <toddaaro> ok
[03:11:43] <strcat> toddaaro: and the vector pointer is from exchange_malloc
[03:11:48] <toddaaro> how do I get a vector pointer
[03:11:54] *** Joins: jviereck (Adium@moz-C7B1E34.dip0.t-ipconnect.de)
[03:11:56] <toddaaro> as far as I can tell it is impossible with transmute
[03:12:08] <benh> you won't get *[T]
[03:12:12] <toddaaro> why not
[03:12:15] <toddaaro> that is what I need
[03:12:17] <strcat> toddaaro: you can get *Vec
[03:12:24] <toddaaro> what is a *Vec?
[03:12:30] <Sergio965> Transmute into the vector, and then get the *T from the data attribute.
[03:13:05] <toddaaro> so into the vector struct?
[03:13:08] <Sergio965> Yeah.
[03:13:11] <aatch> isn't a vector represented as {*data, length, capacity}?
[03:13:17] <strcat> no
[03:13:24] *** Quits: jorendorff (jorendorff@moz-2F32ACA3.hsd1.tn.comcast.net) (Quit: jorendorff)
[03:13:35] <benh> {fill, alloc, data...} apparently
[03:13:42] <strcat> rusti: let xs = ~[1, 2, 3]; unsafe { let x: std::unstable::raw::Vec = std::std::cast::transmute(xs); x }
[03:13:48] -rusti- pastebinned 11 lines of output: http://ix.io/7ts
[03:13:50] <benh> Are box headers gone yet?
[03:13:50] <Sergio965> fill = length, alloc = capacity, I've learned.
[03:13:55] <strcat> benh: if it's non-managed
[03:14:08] <strcat> ~T, ~[T] have headers if T is managed
[03:14:10] <strcat> ~str never does
[03:14:15] * strcat killed them
[03:14:19] <Sergio965> Lol.
[03:14:39] *** zz_kimundi is now known as kimundi
[03:14:44] <strcat> rusti: let xs = ~[1, 2, 3]; unsafe { let x: std::unstable::raw::Vec = std::cast::transmute(xs); x }
[03:14:45] -rusti- <anon>:5:46: 5:70 error: wrong number of type arguments: expected 1 but found 0
[03:14:45] -rusti- <anon>:5          let xs = ~[1, 2, 3]; unsafe { let x: std::unstable::raw::Vec = std::cast::transmute(xs); x }
[03:14:45] -rusti-                                                        ^~~~~~~~~~~~~~~~~~~~~~~~
[03:14:45] -rusti- application terminated with error code 101
[03:14:51] <strcat> rusti: let xs = ~[1, 2, 3]; unsafe { let x: std::unstable::raw::Vec<int> = std::cast::transmute(xs); x }
[03:14:52] -rusti- <anon>:1:0: 1:0 error: transmute called on types with different sizes: ~[int] (64 bits) to std::unstable::raw::Vec<int> (192 bits)
[03:14:52] -rusti- <anon>:1 extern mod extra;
[03:14:52] -rusti-          ^
[03:14:53] -rusti- application terminated with error code 101
[03:15:00] <strcat> rusti: let xs = ~[1, 2, 3]; unsafe { let x: *std::unstable::raw::Vec<int> = std::cast::transmute(xs); x }
[03:15:01] -rusti- 140005834092704
[03:15:06] <strcat> rusti: let xs = ~[1, 2, 3]; unsafe { let x: *std::unstable::raw::Vec<int> = std::cast::transmute(xs); *x }
[03:15:07] -rusti- {fill: 24, alloc: 32, data: 1}
[03:15:08] <strcat> toddaaro: 
[03:15:10] <acrichto> strcat: you can just call `.repr()`
[03:15:12] <toddaaro> ahh
[03:15:15] <strcat> acrichto: not on ~[]
[03:15:17] <toddaaro> that is looking better
[03:15:17] <toddaaro> thanks
[03:15:19] <strcat> it's only impl'ed on slices
[03:15:20] <acrichto> oh yeah, true
[03:15:26] <SingingBoyo> aww.  bunch of tests to fix cause I moved methods into an impl :(
[03:15:36] <strcat> toddaaro: although due to transmute, you are now responsible for freeing that vector ptr
[03:15:38] *** Joins: jclements (jclements@moz-37891906.dsl.snlo01.pacbell.net)
[03:15:38] <strcat> since it moves
[03:15:49] <strcat> you could just transmute back to ~[]
[03:15:56] <toddaaro> perfect, I want to do the freeing
[03:16:09] <Sergio965> Transmute is magical .
[03:16:32] <Sergio965> It's the workhorse of low-level programming in Rust.
[03:16:56] <SiegeLord> transmute::<bug_free_function>(foo)
[03:17:01] <strcat> well in C++ it's static_cast/reinterpret_cast
[03:17:13] <strcat> static_cast isn't as easy to screw up though
[03:17:14] * benh is still easily confused by when ~[T] turns into &[T] 
[03:17:15] <toddaaro> yea, you just need to know what to go to and from
[03:17:20] <strcat> it won't let you cast between unrelated types
[03:17:31] <Sergio965> benh: When you take a slice, it becomes &[T].
[03:17:45] <benh> When do I take a slice?
[03:17:52] <Sergio965> When you want a view into the vector.
[03:18:15] <Sergio965> A slice is a view into the vector beginning at some element into the vector and proceeding for some length number of items.
[03:18:49] <aatch> benh, it's a coercion, so `let a = ~[1,2,3]; let b : &[int] = a;` <- b will coerce a into a slice.
[03:18:57] <Sergio965> Like when you match a vector: match vec { ([a, b, ..rest]) => func(rest) }, rest is a slice.
[03:19:53] <toddaaro> rusti: let xs = ~[1,2,3]; unsafe { let x: *std::unstable::raw::Vec<int> = std::cast::transmute(xs); x.data }
[03:19:54] -rusti- <anon>:5:102: 5:108 error: attempted access of field `data` on type `*std::unstable::raw::Vec<int>`, but no field with that name was found
[03:19:54] -rusti- <anon>:5          let xs = ~[1,2,3]; unsafe { let x: *std::unstable::raw::Vec<int> = std::cast::transmute(xs); x.data }
[03:19:54] -rusti-                                                                                                                ^~~~~~
[03:19:54] -rusti- error: aborting due to previous error
[03:19:56] -rusti- application terminated with error code 101
[03:20:01] <toddaaro> rusti: let xs = ~[1,2,3]; unsafe { let x: *std::unstable::raw::Vec<int> = std::cast::transmute(xs); (*x).data }
[03:20:02] -rusti- 1
[03:20:13] <toddaaro> rusti: let xs = ~[1,2,3]; unsafe { let x: *std::unstable::raw::Vec<int> = std::cast::transmute(xs); &(*x).data }
[03:20:14] -rusti- &1
[03:20:25] <Sergio965> Hooray!
[03:20:51] <Sergio965> rusti: let xs = ~[1,2,3]; unsafe { let x: std::unstable::raw::Vec<int> = std::cast::transmute(xs); &x.data }
[03:20:54] -rusti- pastebinned 15 lines of output: http://ix.io/7tu
[03:20:57] *** Quits: boredomist (user@moz-63CF9F31.res-cmts.sesp.ptd.net) (Ping timeout)
[03:21:10] <toddaaro> rusti: let xs = ~[1,2,3]; unsafe { let x: *std::unstable::raw::Vec<int> = std::cast::transmute(xs); let d: *int = transmute(&x.data); d }
[03:21:11] -rusti- <anon>:5:116: 5:125 error: unresolved name `transmute`.
[03:21:11] -rusti- <anon>:5          let xs = ~[1,2,3]; unsafe { let x: *std::unstable::raw::Vec<int> = std::cast::transmute(xs); let d: *int = transmute(&x.data); d }
[03:21:11] -rusti-                                                                                                                              ^~~~~~~~~
[03:21:11] -rusti- error: aborting due to previous error
[03:21:12] -rusti- application terminated with error code 101
[03:21:13] <Sergio965> rusti: let xs = ~[1,2,3]; unsafe { let x: std::unstable::raw::Vec<int> = std::cast::transmute(xs); x.data }
[03:21:14] -rusti- <anon>:1:0: 1:0 error: transmute called on types with different sizes: ~[int] (64 bits) to std::unstable::raw::Vec<int> (192 bits)
[03:21:16] -rusti- <anon>:1 extern mod extra;
[03:21:18] -rusti-          ^
[03:21:18] <Sergio965> Sigh.
[03:21:19] <toddaaro> rusti: let xs = ~[1,2,3]; unsafe { let x: *std::unstable::raw::Vec<int> = std::cast::transmute(xs); let d: *int = std::cast::transmute(&x.data); d }
[03:21:20] -rusti- application terminated with error code 101
[03:21:22] -rusti- line longer than 150 columns, pastebinned 5 lines of output: http://ix.io/7tv
[03:21:34] *** Joins: ghrust (ghrust@2EE61FCC.6A2AE50.F3114085.IP)
[03:21:34] <ghrust> 01[13rust01] 15bors pushed 0 new commits to 06auto: 02http://git.io/A5Uz_Q
[03:21:34] *** Parts: ghrust (ghrust@2EE61FCC.6A2AE50.F3114085.IP) ()
[03:21:36] *** Joins: ghrust (ghrust@F6EE6DE3.6A2AE50.F3114085.IP)
[03:21:36] <ghrust> 01[13rust01] 15bors pushed 14 new commits to 06auto: 02http://git.io/jzu2qg
[03:21:37] <ghrust> 13rust/06auto 1477279a7 15Tim Chevalier: testsuite: Tests for #6458. Closes #6458
[03:21:37] <ghrust> 13rust/06auto 145da4b4d 15Tim Chevalier: std/extra: changing XXX to FIXME; cleanup...
[03:21:37] <ghrust> 13rust/06auto 141b86088 15Tim Chevalier: extra: change XXX to FIXME and elaborate on comments
[03:21:39] *** Parts: ghrust (ghrust@F6EE6DE3.6A2AE50.F3114085.IP) ()
[03:22:02] *** Joins: mihneadb (mihneadb@moz-329F29A3.lightspeed.sntcca.sbcglobal.net)
[03:22:05] <Sergio965> Sleep time, night all.
[03:22:06] <toddaaro> rusti: let xs = ~[1,2,3]; unsafe { let x: *std::unstable::raw::Vec<int> = std::cast::transmute(xs); let d: *int = std::cast::transmute(&(*x).data); d }
[03:22:06] -rusti- 140384705573040
[03:22:09] <toddaaro> woo
[03:22:19] *** Joins: josedonizetti (josedonize@moz-CA73D699.cpe.teksavvy.com)
[03:22:28] *** Quits: Sergio965 (sergiobz@moz-8D9DFEEF.hsd1.ma.comcast.net) (Quit: My MacBook Pro has gone to sleep. ZZZzzzâ€¦)
[03:22:29] <strcat> acrichto: #[unsafe_non_zero_word] struct { x: int, y: int } does actually work
[03:22:40] <strcat> although I'm not sure if it works in all cases
[03:22:54] <acrichto> strcat: interesting... it's None if the first word is 0?
[03:22:57] <strcat> don't really want to support it without anything needing it
[03:22:59] <strcat> acrichto: yeah
[03:23:04] <acrichto> so basically you're guaranteeing the first word isn't 0
[03:23:08] <strcat> acrichto: well, assuming you put it in Some
[03:23:11] <strcat> acrichto: yeah
[03:23:27] * strcat pokes at it a bit
[03:23:31] <acrichto> well if we have unsafe_non_zero_word, we should test that behavior
[03:23:42] <acrichto> otherwise we should enforce that the struct is just one word (what I'd prefer)
[03:23:52] <strcat> I'll do that for now
[03:23:56] *** Quits: erickt1 (Adium@49C4075F.3AC15C18.2321E71E.IP) (Quit: Leaving.)
[03:24:09] *** Quits: mihneadb (mihneadb@moz-329F29A3.lightspeed.sntcca.sbcglobal.net) (Input/output error)
[03:25:54] *** Quits: RMF (RMF@100FCB1B.10FB11BA.8D19547B.IP) (Quit: Textual IRC Client: www.textualapp.com)
[03:26:03] <jeaye> rusti: let f = @mut 2; f.clone();
[03:26:04] -rusti- ()
[03:26:06] <jeaye> rusti: let f = @mut 2; f.clone()
[03:26:07] -rusti- @2
[03:26:44] <toddaaro> blah
[03:26:53] <toddaaro> so how do I escape these "use of partially moved value"
[03:27:03] <strcat> acrichto: I'm not sure how to possibly check for it though
[03:27:17] <strcat> the check can't be in this function
[03:27:30] <strcat> because... this is when you're *using* one
[03:27:42] <strcat> hm
[03:27:56] <strcat> it needs to report it from typeck
[03:29:22] <strcat> rusti: struct { x: int, x: int }
[03:29:23] -rusti- <anon>:5:16: 5:17 error: expected ident, found `{`
[03:29:23] -rusti- <anon>:5          struct { x: int, x: int }
[03:29:23] -rusti-                          ^
[03:29:23] -rusti- application terminated with error code 101
[03:29:28] <strcat> rusti: struct p { x: int, x: int }
[03:29:31] -rusti- pastebinned 8 lines of output: http://ix.io/7ty
[03:29:54] *** Quits: recrack (Mibbit@B4104EBB.3CC170B1.1E14B209.IP) (Quit: http://www.mibbit.com ajax IRC Client)
[03:30:11] *** Quits: jmgrosen (jmgrosen@moz-F947D1B7.cs.ucsb.edu) (Ping timeout)
[03:30:15] <acrichto> strcat: it should report it during trans
[03:30:27] <strcat> acrichto: during trans when?
[03:30:31] *** Quits: graydon (Adium@A5087023.2354C43D.D8E68FF6.IP) (Quit: Leaving.)
[03:30:38] <strcat> the code I added is when it does stuff with enums
[03:30:43] <strcat> if you put it in the enum
[03:30:49] <strcat> it should report an error before you use it in an enum
[03:31:11] <acrichto> just when trans_crate hits item_struct make sure that the unsafe_non_zero_word is sane
[03:31:22] <acrichto> doesn't really matter when the error gets emitted so long as it is
[03:32:08] <jld> strcat: As in cases where an enum field is (a struct/tuple that contains)+ a non-nullable pointer?
[03:32:14] <strcat> acrichto: that's too early
[03:32:21] <strcat> it hasn't monomorphized yet
[03:32:29] <strcat> well I mean it won't know if it's 1 word if it's generic
[03:32:52] <strcat> jld: yeah like 'struct Foo { x: ~int }'
[03:33:01] <strcat> or @int, or &'self int
[03:33:06] *** Quits: eschweic (Adium@moz-BBE3ABD.mv.mozilla.com) (Quit: Leaving.)
[03:33:44] <strcat> rusti: mod foo { pub struct Foo { priv x: ~int } }
[03:33:44] -rusti- ()
[03:33:46] <acrichto> oh hm
[03:34:00] <strcat> rusti: mod foo { pub struct Foo { priv x: ~int } } Foo { x: 5 }
[03:34:01] -rusti- <anon>:5:53: 5:56 error: `Foo` does not name a structure
[03:34:01] -rusti- <anon>:5          mod foo { pub struct Foo { priv x: ~int } } Foo { x: 5 }
[03:34:01] -rusti-                                                               ^~~
[03:34:01] -rusti- error: aborting due to previous error
[03:34:01] -rusti- application terminated with error code 101
[03:34:06] <strcat> rusti: mod foo { pub struct Foo { priv x: ~int } } foo::Foo { x: 5 }
[03:34:07] -rusti- <anon>:5:67: 5:68 error: mismatched types: expected `~int` but found `<VI0>` (expected ~-ptr but found integral variable)
[03:34:07] -rusti- <anon>:5          mod foo { pub struct Foo { priv x: ~int } } foo::Foo { x: 5 }
[03:34:07] -rusti-                                                                             ^
[03:34:10] -rusti- error: aborting due to previous error
[03:34:11] <strcat> rusti: mod foo { pub struct Foo { priv x: ~int } } foo::Foo { x: 5i }
[03:34:12] -rusti- application terminated with error code 101
[03:34:13] -rusti- <anon>:5:67: 5:69 error: mismatched types: expected `~int` but found `int` (expected ~-ptr but found int)
[03:34:16] -rusti- <anon>:5          mod foo { pub struct Foo { priv x: ~int } } foo::Foo { x: 5i }
[03:34:17] <strcat> rusti: mod foo { pub struct Foo { priv x: ~int } } foo::Foo { x: ~5i }
[03:34:19] -rusti-                                                                             ^~
[03:34:22] -rusti- error: aborting due to previous error
[03:34:23] <strcat> wat
[03:34:24] -rusti- application terminated with error code 101
[03:34:25] -rusti- <anon>:5:53: 5:61 error: field `x` is private
[03:34:27] -rusti- <anon>:5          mod foo { pub struct Foo { priv x: ~int } } foo::Foo { x: ~5i }
[03:34:27] <strcat> oh
[03:34:30] -rusti-                                                               ^~~~~~~~
[03:34:32] -rusti- error: aborting due to previous error
[03:34:34] -rusti- application terminated with error code 101
[03:34:34] <jld> strcat: That should be doable in principle.  It'd be a GEPi path to the nonzero part rather than a single field index, I guess.
[03:35:02] *** kimundi is now known as zz_kimundi
[03:35:08] <strcat> jld: I added an #[unsafe_non_zero_word] and it already works for structs you tag manually, like Rc
[03:35:20] <strcat> so it would just need to detect those always safe cases itself
[03:35:27] *** Quits: jclements (jclements@moz-37891906.dsl.snlo01.pacbell.net) (Quit: jclements)
[03:35:40] <strcat> assuming we decide sticking nulls in private non-nullable ptr fields is not allowed
[03:36:00] <jld> strcat: So, for something Option<(int, ~T)> that'd zero out (and check for zeroness) the entire tuple, if I understand correctly.
[03:36:08] <SingingBoyo> is it possible to just build libextra instead of going through all of the build stages?
[03:36:13] *** Joins: tedh (tedh@moz-F0B37C08.hsd1.il.comcast.net)
[03:36:57] <jld> strcat: Whereas I'd like to treat it the same as if it were "flattened" into fields of the enum and just have one word of discriminant.
[03:37:04] <strcat> SingingBoyo: rustc extra.rs --test --cfg stage2 (with a recent enough stage2 compiler)
[03:37:36] *** Quits: tcr (tcr@moz-EE576D3C.hsd1.ma.comcast.net) (Client exited)
[03:37:56] *** Quits: sigma (sigma@51C589B3.EF2694B5.DFAC6AA7.IP) (Ping timeout)
[03:37:56] *** Joins: tcr (tcr@moz-EE576D3C.hsd1.ma.comcast.net)
[03:39:36] *** Quits: tcr (tcr@moz-EE576D3C.hsd1.ma.comcast.net) (Ping timeout)
[03:43:39] *** Joins: eschweic (Adium@moz-BBE3ABD.mv.mozilla.com)
[03:44:41] *** Quits: eschweic (Adium@moz-BBE3ABD.mv.mozilla.com) (Quit: Leaving.)
[03:46:31] *** Joins: jmgrosen (jmgrosen@moz-848F6087.sb.sd.cox.net)
[03:47:32] *** Joins: tcr (tcr@moz-EE576D3C.hsd1.ma.comcast.net)
[03:48:34] <strcat> rusti: #[packed] struct Foo;
[03:48:35] -rusti- ()
[03:48:37] <strcat> rusti: #[packed] struct Foo; Foo
[03:48:38] -rusti- {}
[03:48:40] <toddaaro> rusti: 2^8
[03:48:41] -rusti- 10
[03:48:46] <toddaaro> what
[03:48:52] <toddaaro> oh god
[03:48:55] <toddaaro> is that not exponent
[03:48:57] <strcat> it's XOR
[03:49:02] <toddaaro> fuuuuuuuuuuuuuuuuuuu
[03:49:05] <strcat> 8 is 100
[03:49:08] <strcat> 2 is 001
[03:49:16] <toddaaro> this is likely a source of some of my issues
[03:49:16] <strcat> so it makes 101, 10 ;p
[03:49:40] <toddaaro> is there an exp defined somewhere?
[03:50:04] <strcat> if it's just powers of two you could use shifts
[03:50:14] <toddaaro> ah yes, is that >>
[03:50:19] <toddaaro> rusti: 8 >> 2
[03:50:21] -rusti- 2
[03:50:27] <strcat> rusti: 2 << 8
[03:50:28] -rusti- 512
[03:50:33] <toddaaro> cool
[03:50:35] <toddaaro> thanks
[03:50:37] <strcat> er
[03:50:48] <strcat> 2 ** 8 == 1 << 8
[03:51:10] <toddaaro> oh, wait 512, isn't that 2^9
[03:51:18] <strcat> yes
[03:51:38] <darkf> because you're using 2 << and not 1 << yeah
[03:51:48] <toddaaro> rusti: 1 << 8
[03:51:49] -rusti- 256
[03:51:50] <strcat> because it shifts the bit and 2 is already 1 << 1
[03:51:53] <toddaaro> oh duh
[03:58:10] *** Quits: SiegeLord (sl@moz-CAF07B4C.hsd1.ma.comcast.net) (Connection reset by peer)
[03:58:32] *** Joins: jorendorff (jorendorff@moz-2F32ACA3.hsd1.tn.comcast.net)
[03:59:52] *** Joins: mihneadb (mihneadb@moz-329F29A3.lightspeed.sntcca.sbcglobal.net)
[04:00:16] *** Quits: mihneadb (mihneadb@moz-329F29A3.lightspeed.sntcca.sbcglobal.net) (Input/output error)
[04:02:30] <jeaye> I'm trying to learn these fancy lifetimes to get rid of all the @mut in my code. Trying a simple example to return a borrowd pointer from a function, but I'm not quite getting it; is there something easy I'm missing here?  https://gist.github.com/Jeaye/3d9eec2a1624ea250654
[04:03:03] *** Quits: brson (brson@moz-BBE3ABD.mv.mozilla.com) (Quit: leaving)
[04:03:24] *** Quits: lkuper_ (lkuper@moz-C0CD33ED.hsd1.in.comcast.net) (Quit: lkuper_)
[04:03:46] *** Quits: lmandel (lmandel@moz-BBE3ABD.mv.mozilla.com) (Quit: lmandel)
[04:04:13] *** Joins: jclements (jclements@moz-37891906.dsl.snlo01.pacbell.net)
[04:04:22] *** Quits: snadon (chatzilla@moz-3BC727E8.mc.videotron.ca) (Quit: ChatZilla 0.9.90.1 [Firefox 24.0/20130819170952])
[04:05:07] *** Joins: dherman (dherman@moz-6CA476B1.hsd1.ca.comcast.net)
[04:05:07] *** ChanServ sets mode: +o dherman
[04:05:10] *** Joins: erickt_ (etryzelaar@8C9ECD8F.3A598286.F12515B4.IP)
[04:05:22] *** Quits: erickt (etryzelaar@8C9ECD8F.3A598286.F12515B4.IP) (Connection reset by peer)
[04:06:23] <Eridius> jeaye: you don't need a lifetime on your struct. You need a lifetime on the `&mut self` pointer (though it also doesn't have to be mutable)
[04:06:36] <Eridius> jeaye: `pub fn get_x<'a>(&'a self) -> &'a i32 { self.x }`
[04:08:21] <jeaye> Eridius: If it's mutable, where does the mut go here?
[04:08:32] <Eridius> jeaye: if it needs to be mutable, &'a mut self
[04:08:33] <jeaye> `&mut 'self self` doesn't seem to work
[04:08:48] *** Quits: jviereck (Adium@moz-C7B1E34.dip0.t-ipconnect.de) (Quit: Leaving.)
[04:08:50] <jeaye> Ah, because the lifetime i boung to the borrowedness
[04:08:52] <jeaye> I get it.
[04:08:57] <jeaye> is bound*
[04:11:49] <jeaye> Eridius: Badass, got it working. Thanks for the clarification.
[04:12:06] <jeaye> Eridius: Another question, if you don't mind.
[04:12:24] *** Joins: ryanc (ryanc@5AB4884B.FCC4549.14D5B978.IP)
[04:12:47] <jeaye> I've heard that 'self and 'static are special. I'm currently using: https://gist.github.com/Jeaye/4c9c5ac73c25e1e1aa32
[04:13:20] <jeaye> Should I be using 'self instead of 's? When would I know to use which?
[04:13:32] *** Quits: Kruppe (user@moz-E150F49F.cpe.net.cable.rogers.com) (Client exited)
[04:13:36] *** Quits: tcr (tcr@moz-EE576D3C.hsd1.ma.comcast.net) (Client exited)
[04:13:57] *** Joins: tcr (tcr@moz-EE576D3C.hsd1.ma.comcast.net)
[04:14:26] <darkf> jeaye: I'm certainly no expert but I'm sure &'s mut self would be functionally the same as 'self (only 's is explicitly declared) since they're both the lifetime of the input (self)
[04:14:26] *** Quits: tcr (tcr@moz-EE576D3C.hsd1.ma.comcast.net) (Connection reset by peer)
[04:14:32] *** Quits: jmgrosen (jmgrosen@moz-848F6087.sb.sd.cox.net) (Quit: jmgrosen)
[04:14:38] *** Joins: tcr (tcr@moz-EE576D3C.hsd1.ma.comcast.net)
[04:14:46] <darkf> just go for using -> &'self mut i32 probably
[04:14:53] *** Joins: azita (Azita@moz-C1FB2A8.hsd1.ca.comcast.net)
[04:15:05] <jeaye> darkf: So 'self is implicitly declared?
[04:15:20] <darkf> jeaye: yes, it's the lifetime of the object
[04:15:26] <jeaye> Right.
[04:16:22] <jeaye> If it's implicitly declared, couldn't I use: `pub fn get_x(&mut self) -> &'self mut i32`
[04:16:38] <darkf> yup
[04:16:43] <jeaye> (the above doesn't work for me)
[04:16:54] <jeaye> Illegal lifetime 'self: the `self` lifetime must be declared
[04:17:00] <darkf> might need to use impl<'self> actually
[04:17:04] *** Quits: vodik (simon@moz-CBE4BB13.cable.teksavvy.com) (Ping timeout)
[04:17:26] <darkf> argh, these things are easy to forget
[04:18:07] <jeaye> Adding it to the impl brought me further
[04:18:29] <jeaye> But (on line 9) I get: error: cannot infer an appropriate lifetime due to conflicting requirements
[04:19:08] <jeaye> darkf: https://gist.github.com/Jeaye/6868dac80bf31d58eed8
[04:19:32] <jeaye> Tried `{ &'self mut self.x }`
[04:20:02] *** Quits: eatkinson (eatkinson@moz-BBE3ABD.mv.mozilla.com) (Quit: eatkinson)
[04:21:23] <Luqman> jeaye: https://gist.github.com/luqmana/2d536992571149bb02a4
[04:21:28] *** Quits: dherman (dherman@moz-6CA476B1.hsd1.ca.comcast.net) (Quit: dherman)
[04:21:36] *** Joins: dbaupp (Thunderbir@368DC27E.D5A1DCF.37681C44.IP)
[04:25:20] <cmr> dbaupp: yeah, bencher is borked
[04:25:30] <cmr> don't really have time to fix it until next week though
[04:26:20] <jeaye> Luqman: Yup, I have that one working. We were just trying to get it working with 'self
[04:26:29] <dbaupp> cmr: np
[04:26:36] <jeaye> Instead of declaring 'a for each function.
[04:26:41] <jeaye> Luqman: Is that possible?
[04:26:49] <jeaye> 'self on the impl level
[04:27:09] <Luqman> jeaye: oh, so then changing it to &'self mut self should working
[04:27:10] *** Quits: josedonizetti (josedonize@moz-CA73D699.cpe.teksavvy.com) (Quit: josedonizetti)
[04:27:39] <jeaye> Ah
[04:27:53] *** Quits: jclements (jclements@moz-37891906.dsl.snlo01.pacbell.net) (Quit: jclements)
[04:28:09] <jeaye> So make it impl<'self> and &'self mut self and then return &'self mut i32
[04:28:19] <jeaye> Perfect. Thanks, Luqman 
[04:33:05] <cmr> self self self self. I can't wait until that bug gets fixed.
[04:33:41] <cmr> semantic satiation is a serious issue with rust right now :P
[04:35:46] *** Joins: nsf (nsf@moz-EEF3238A.convex.ru)
[04:36:36] <jeaye> What if I'm returning a borrowed pointer to an owned box in TLS from a static function? https://gist.github.com/Jeaye/daed70def59f804c1071
[04:36:37] *** Quits: enix (enix@moz-A50569DD.c3-0.slvr-ubr1.lnh-slvr.md.cable.rcn.com) (Quit: Konversation terminated!)
[04:38:16] *** Joins: lmandel (lmandel@moz-9CE00FC0.holiday-inn-express.mozilla.hq)
[04:40:31] *** Quits: strcat (strcat@moz-54F7FD49.cpe.net.cable.rogers.com) (Quit: WeeChat 0.4.1)
[04:41:16] *** Quits: tristram (tristram@moz-C498CC41.eu) (Client exited)
[04:41:16] *** Joins: jclements (jclements@moz-37891906.dsl.snlo01.pacbell.net)
[04:41:32] *** Joins: ghrust (ghrust@79968228.6A2AE50.F3114085.IP)
[04:41:32] <ghrust> 01[13rust01] 15bors merged 06auto into 06master: 02http://git.io/jzu2qg
[04:41:32] *** Parts: ghrust (ghrust@79968228.6A2AE50.F3114085.IP) ()
[04:41:37] <jeaye> Luqman: ^?
[04:42:13] <dbaupp> jeaye: you can't
[04:42:31] <dbaupp> there's no way for rust to enforce the lifetime of such a borrowed pointer
[04:42:53] <jeaye> So I either have to move out of it or use a managed pointer?
[04:43:21] <toddaaro> sigh, this code, I'm finally giving up for the day
[04:43:24] <dbaupp> yup, or pass it into fn passed to get_active
[04:43:42] <toddaaro> for reasons I cannot fathom it is setting an atomic uint to a different value, and the change is evaporating
[04:43:54] <jeaye> dbaupp: "or pass it into fn passed to get_active" I'm not sure what you mean.
[04:43:57] <dbaupp> fn get_active(handler: fn(&mut Camera) -> T) -> T { ... }
[04:44:19] <dbaupp> and then in the Some branch `handler(&mut **x)`
[04:44:27] *** Quits: azita (Azita@moz-C1FB2A8.hsd1.ca.comcast.net) (Quit: azita)
[04:44:34] *** Joins: hjr3 (hradtke@moz-E87BDF1F.socal.res.rr.com)
[04:44:49] <jeaye> dbaupp: So I can use it in the function as &mut **x, just not return it?
[04:44:57] <dbaupp> right
[04:45:11] <dbaupp> because it can't connect the lifetime to TLS properly
[04:45:20] <jeaye> Makes sense.
[04:45:24] <jeaye> Thanks for the explanation.
[04:45:33] <dbaupp> (either it would have to freeze it forever after, or you would have to explicitly unborrow it.)
[04:45:49] <jeaye> I understand some of the design decisions of Rust's stdlib now.
[04:46:01] <dbaupp> :)
[04:46:29] <dbaupp> yeah, it's slowly migrating to returning lifetimes where possible, otherwise using a closure as a last resort
[04:48:11] <jeaye> Understood.
[04:51:31] *** Joins: ghrust (ghrust@9C8B94D4.6A2AE50.F3114085.IP)
[04:51:31] <ghrust> 01[13rust01] 15bors pushed 0 new commits to 06auto: 02http://git.io/2YtKSg
[04:51:31] *** Parts: ghrust (ghrust@9C8B94D4.6A2AE50.F3114085.IP) ()
[04:51:32] *** Joins: ghrust (ghrust@79968228.6A2AE50.F3114085.IP)
[04:51:32] <ghrust> 01[13rust01] 15bors pushed 13 new commits to 06auto: 02http://git.io/ogIioQ
[04:51:32] <ghrust> 13rust/06auto 14548bdba 15blake2-ppc: std::str: Bench test for char iterators
[04:51:32] <ghrust> 13rust/06auto 144043c70 15blake2-ppc: std::str: Small fix for slice
[04:51:33] <ghrust> 13rust/06auto 143cb5b8d 15blake2-ppc: std::str: Special case char_range_at_reverse so it is faster...
[04:51:35] *** Parts: ghrust (ghrust@79968228.6A2AE50.F3114085.IP) ()
[04:55:38] <jeaye> dbaupp: I feel like I'm close here: https://gist.github.com/Jeaye/0b71f6f2483fae2e84c0
[04:55:45] <jeaye> error: cannot borrow immutable dereference of & pointer as mutable
[04:56:12] <dbaupp> jeaye: I think you need local_data::get_mut
[04:56:14] <jeaye> So when I dereference *f it becomes immutable, which is a problem (even though I &mut right after)
[04:56:40] <jeaye> Ah, you're absolutely right.
[04:56:44] <dbaupp> (since you're retrieving a &float from TLS, so you can't ever mutate it)
[04:58:06] <jeaye> got it
[04:58:30] <jeaye> dbaupp: Now, should (in a more practical case) that data be ~ or not?
[04:58:56] <jeaye> If it's just taking a closure to modify it each time, there's no need for it to be ~, right?
[04:59:06] <dbaupp> only if you're going to be transferring ownership a lot (and if it's in TLS then I guess not), so no ~
[04:59:38] <dbaupp> anyway, I gtg; good luck with your de-@-ing. :)
[04:59:43] <jeaye> Thanks. :)
[05:00:38] *** Joins: mihneadb (mihneadb@moz-329F29A3.lightspeed.sntcca.sbcglobal.net)
[05:01:00] <olsonjeffery> rusti: struct Foo(int); impl { fn foo(&mut self) {} fn bar(&
[05:01:00] -rusti- <anon>:6:4: 6:5 error: incorrect close delimiter: `}`
[05:01:00] -rusti- <anon>:6     };
[05:01:00] -rusti-              ^
[05:01:00] -rusti- application terminated with error code 101
[05:01:18] *** Quits: dbaupp (Thunderbir@368DC27E.D5A1DCF.37681C44.IP) (Ping timeout)
[05:01:25] *** Quits: ryanc (ryanc@5AB4884B.FCC4549.14D5B978.IP) (Quit: ryanc)
[05:02:02] <olsonjeffery> rusti: struct Foo(int); impl { fn foo(&mut self, _i: int) {} fn bar(&mut self) -> int { *self } } let f = Foo(1); f.bar(f.foo());
[05:02:04] -rusti- pastebinned 7 lines of output: http://ix.io/7tC
[05:02:24] <olsonjeffery> rusti: struct Foo(int); impl Foo { fn foo(&mut self, _i: int) {} fn bar(&mut self) -> int { *self } } let f = Foo(1); f.bar(f.foo());
[05:02:27] -rusti- pastebinned 11 lines of output: http://ix.io/7tD
[05:03:11] <olsonjeffery> rusti: struct Foo(int); impl Foo { fn foo(&mut self, _i: int) {} fn bar(&mut self) -> int { *self } } let f = Foo(1); f.foo(f.bar());
[05:03:11] -rusti- <anon>:5:94: 5:101 error: mismatched types: expected `int` but found `main::Foo` (expected int but found struct main::Foo)
[05:03:11] -rusti- <anon>:5          struct Foo(int); impl Foo { fn foo(&mut self, _i: int) {} fn bar(&mut self) -> int { *self } } let f = Foo(1); f.foo(f.bar());
[05:03:12] -rusti-                                                                                                        ^~~~~~~
[05:03:12] -rusti- error: aborting due to previous error
[05:03:13] -rusti- application terminated with error code 101
[05:03:28] <olsonjeffery> rusti: struct Foo(int); impl Foo { fn foo(&mut self, _i: int) {} fn bar(&mut self) -> int { **self } } let f = Foo(1); f.foo(f.bar());
[05:03:30] -rusti- pastebinned 14 lines of output: http://ix.io/7tE
[05:03:48] <olsonjeffery> there we go.
[05:04:05] <olsonjeffery> rusti: struct Foo(int); impl Foo { fn foo(&mut self, _i: int) {} fn bar(&mut self) -> int { **self } } let f = Foo(1); let r = f.bar(); f.foo(r);
[05:04:07] -rusti- pastebinned 8 lines of output: http://ix.io/7tF
[05:04:30] <olsonjeffery> rusti: struct Foo(int); impl Foo { fn foo(&mut self, _i: int) {} fn bar(&mut self) -> int { **self } } let mut f = Foo(1); let r = f.bar(); f.foo(r);
[05:04:31] -rusti- ()
[05:04:42] <olsonjeffery> rusti: struct Foo(int); impl Foo { fn foo(&mut self, _i: int) {} fn bar(&mut self) -> int { **self } } let mut f = Foo(1); f.foo(f.bar());
[05:04:44] -rusti- pastebinned 8 lines of output: http://ix.io/7tG
[05:06:02] <olsonjeffery> so .. could the compiler by taught to deal with this? are there cases where we wouldn't want to allow that?
[05:06:22] <olsonjeffery> nmatsakis: ping
[05:08:02] *** Quits: dcrewi (david@moz-AB8667CE.gyrae.net) (Ping timeout)
[05:10:01] *** Joins: dherman (dherman@moz-6CA476B1.hsd1.ca.comcast.net)
[05:10:01] *** ChanServ sets mode: +o dherman
[05:11:05] *** Joins: jaen (jaen@moz-E0979827.copit.pl)
[05:12:43] *** Joins: milfhunter (Mibbit@C55D5264.8F53C16E.2321E71E.IP)
[05:15:20] *** Parts: milfhunter (Mibbit@C55D5264.8F53C16E.2321E71E.IP) ()
[05:15:38] *** Quits: dherman (dherman@moz-6CA476B1.hsd1.ca.comcast.net) (Quit: dherman)
[05:15:45] *** Quits: jaen (jaen@moz-E0979827.copit.pl) (Ping timeout)
[05:17:29] *** Joins: dherman (dherman@moz-6CA476B1.hsd1.ca.comcast.net)
[05:17:29] *** ChanServ sets mode: +o dherman
[05:20:31] *** Quits: tcr (tcr@moz-EE576D3C.hsd1.ma.comcast.net) (Client exited)
[05:20:51] *** Joins: tcr (tcr@moz-EE576D3C.hsd1.ma.comcast.net)
[05:21:03] *** Joins: doomlord (doomlod@moz-13E69BC8.range86-180.btcentralplus.com)
[05:21:52] *** Joins: eatkinson (eatkinson@moz-5CF47426.dia.static.qwest.net)
[05:22:30] *** Quits: int3_ (int3_@moz-ABE52D50.hsd1.ca.comcast.net) (Client exited)
[05:22:32] *** Quits: tcr (tcr@moz-EE576D3C.hsd1.ma.comcast.net) (Ping timeout)
[05:23:26] *** Joins: tcr (tcr@moz-EE576D3C.hsd1.ma.comcast.net)
[05:23:54] *** Quits: jclements (jclements@moz-37891906.dsl.snlo01.pacbell.net) (Quit: jclements)
[05:26:14] *** Joins: jclements (jclements@moz-37891906.dsl.snlo01.pacbell.net)
[05:28:14] <SingingBoyo> should I expect all the rustpkg tests to pass?  just came back to find that one of them failed but it doesn't seem to have anything to do with what I've changed, and all the other tests are fine...
[05:29:19] *** Quits: dherman (dherman@moz-6CA476B1.hsd1.ca.comcast.net) (Quit: dherman)
[05:32:20] *** Joins: dcrewi (david@moz-AB8667CE.gyrae.net)
[05:32:30] *** Joins: recrack (Mibbit@B4104EBB.3CC170B1.1E14B209.IP)
[05:37:21] *** Quits: tcr (tcr@moz-EE576D3C.hsd1.ma.comcast.net) (Client exited)
[05:37:42] *** Joins: tcr (tcr@moz-EE576D3C.hsd1.ma.comcast.net)
[05:39:22] *** Quits: tcr (tcr@moz-EE576D3C.hsd1.ma.comcast.net) (Ping timeout)
[05:39:31] *** Quits: klutzy (th@BA61F396.8E859986.ECA1BB11.IP) (Ping timeout)
[05:39:52] *** Joins: klutzy (th@BA61F396.8E859986.ECA1BB11.IP)
[05:40:59] *** Joins: snadon (chatzilla@moz-3BC727E8.mc.videotron.ca)
[05:42:49] *** Joins: geomyidae (geomyidae@DD6F7E3A.21468E9A.30200F38.IP)
[05:45:23] *** Joins: tgummerer (tgummerer@moz-3CF4EF2C.unibz.it)
[05:47:12] <ChrisMorgan> I wish I could implement ToStr for &'self [MyType], but I can't as it's already specified for the generic &'self [T] :-(
[05:48:10] *** Quits: lmandel (lmandel@moz-9CE00FC0.holiday-inn-express.mozilla.hq) (Quit: lmandel)
[05:49:56] <olsonjeffery> ChrisMorgan: so did you see that d3cap project? i haven't looked at the code, but apparently it has enough of a websocket server for the client-side stuff to work. im pretty intrigued
[05:50:12] <ChrisMorgan> olsonjeffery: I haven't seen it.
[05:50:29] <olsonjeffery> do you think there's room for that in rust-http?
[05:50:40] <ChrisMorgan> What d3cap project?
[05:51:00] <olsonjeffery> https://github.com/jfager/d3cap
[05:51:01] <ChrisMorgan> Of a certainty there is, in the longer term.
[05:51:58] *** Joins: BizarreCake (BizarreCak@moz-361FE9B2.dynamic.barak-online.net)
[05:52:13] <olsonjeffery> yeah. just really interesting. i thought of it as a longterm thing, too. but someone just went and did it, heh.
[05:52:28] *** Quits: rusti (rusti@moz-54F7FD49.cpe.net.cable.rogers.com) (Client exited)
[05:52:39] <ChrisMorgan> I see it gets around the hardest parts by hardcoding its secret token.
[05:53:01] *** Joins: rusti (rusti@moz-54F7FD49.cpe.net.cable.rogers.com)
[05:53:06] <olsonjeffery> how would you do it in a robust impl?
[05:55:21] *** Quits: jclements (jclements@moz-37891906.dsl.snlo01.pacbell.net) (Quit: jclements)
[05:57:17] <ChrisMorgan> The specification covers that. I have only looked at it, never implemented it, and can't remember the details.
[05:57:35] <ChrisMorgan> It involves bit twiddling and so forth. Crypto stuff.
[06:02:56] *** Joins: klapaucius (klapaucius@272B8F8B.5692770D.BB41F968.IP)
[06:06:52] *** Quits: jdm (jdm@97DF0582.DEAB171B.971E19F6.IP) (Ping timeout)
[06:09:01] *** Quits: mihneadb (mihneadb@moz-329F29A3.lightspeed.sntcca.sbcglobal.net) (Input/output error)
[06:11:33] *** Joins: ghrust (ghrust@1E8607E8.6A2AE50.F3114085.IP)
[06:11:33] <ghrust> 01[13rust01] 15bors merged 06auto into 06master: 02http://git.io/ogIioQ
[06:11:33] *** Parts: ghrust (ghrust@1E8607E8.6A2AE50.F3114085.IP) ()
[06:13:05] *** Quits: jorendorff (jorendorff@moz-2F32ACA3.hsd1.tn.comcast.net) (Quit: jorendorff)
[06:13:47] *** Quits: ross (ross@moz-8A84103E.br.br.cox.net) (Quit: )
[06:14:16] *** Quits: dcrewi (david@moz-AB8667CE.gyrae.net) (Ping timeout)
[06:17:22] *** Joins: vodik (simon@moz-CBE4BB13.cable.teksavvy.com)
[06:18:39] *** Joins: vfetwnuncszu (david@moz-AB8667CE.gyrae.net)
[06:18:50] *** vfetwnuncszu is now known as dcrewi
[06:21:31] *** Joins: ghrust (ghrust@79968228.6A2AE50.F3114085.IP)
[06:21:31] <ghrust> 01[13rust01] 15bors pushed 0 new commits to 06auto: 02http://git.io/vW05sA
[06:21:31] *** Parts: ghrust (ghrust@79968228.6A2AE50.F3114085.IP) ()
[06:21:33] *** Joins: ghrust (ghrust@C8693FCB.6A2AE50.F3114085.IP)
[06:21:33] <ghrust> 01[13rust01] 15bors pushed 8 new commits to 06auto: 02http://git.io/p-by6w
[06:21:33] <ghrust> 13rust/06auto 144d888c8 15Vadim Chugunov: On Windows, use g++ for linking, instead of gcc....
[06:21:33] <ghrust> 13rust/06auto 14d6e7e68 15Vadim Chugunov: Un-disable stack unwinding on Windows.
[06:21:33] <ghrust> 13rust/06auto 144c32ebc 15Vadim Chugunov: Emit unwind info in rustrt assembly files on Windows.
[06:21:35] *** Parts: ghrust (ghrust@C8693FCB.6A2AE50.F3114085.IP) ()
[06:22:38] *** Joins: Ms2ger (Ms2ger@moz-590E79FE.adsl-dyn.isp.belgacom.be)
[06:24:43] *** Joins: leonvv (leonvv@moz-7D83A5F1.ip.telfort.nl)
[06:26:27] *** Quits: josh (josh@moz-D3896A24.dhcp.dlth.mn.charter.com) (Ping timeout)
[06:28:52] *** Joins: josh (josh@moz-D3896A24.dhcp.dlth.mn.charter.com)
[06:39:02] *** Quits: vodik (simon@moz-CBE4BB13.cable.teksavvy.com) (Ping timeout)
[06:47:12] *** Quits: cubic (cubic@moz-FE5AD6C7.mc.videotron.ca) (Connection reset by peer)
[06:51:00] *** Quits: eatkinson (eatkinson@moz-5CF47426.dia.static.qwest.net) (Ping timeout)
[06:51:51] *** Joins: eatkinson (eatkinson@moz-5CF47426.dia.static.qwest.net)
[06:52:55] *** Quits: jeaye (Jeaye@moz-FD505E54.hsd1.ca.comcast.net) (Quit: zzz)
[06:54:22] *** Joins: dbaupp (Thunderbir@moz-EAA09AEF.lns20.syd7.internode.on.net)
[06:57:42] *** Ms2ger is now known as Ms2ger|sheriff
[07:01:34] *** Joins: ghrust (ghrust@24260B07.6A2AE50.F3114085.IP)
[07:01:35] <ghrust> 01[13rust01] 15bors 04force-pushed 06auto from 1409ca061 to 14f113249: 02http://git.io/N3iJvQ
[07:01:35] *** Parts: ghrust (ghrust@24260B07.6A2AE50.F3114085.IP) ()
[07:01:35] *** Joins: ghrust (ghrust@F6EE6DE3.6A2AE50.F3114085.IP)
[07:01:35] <ghrust> 01[13rust01] 15bors pushed 2 new commits to 06auto: 02http://git.io/YTZQ0g
[07:01:35] <ghrust> 13rust/06auto 144d97b6e 15Kevin Ballard: Fix some parsing errors in extra::url...
[07:01:35] <ghrust> 13rust/06auto 14f51d30d 15bors: auto merge of #8616 : kballard/rust/url-parse-errors, r=catamorphism...
[07:01:36] *** Parts: ghrust (ghrust@F6EE6DE3.6A2AE50.F3114085.IP) ()
[07:02:38] *** Joins: fyolnish (fyolnish@moz-BE2BAE5B.miinet.jp)
[07:05:06] *** Joins: lenstr (lenstr@AF8EB999.6049B16A.85938D85.IP)
[07:06:02] <ChrisMorgan> RFC: byte and byte vector literals: (b'x') as equivalent to ('x' as u8), and (b"xyz") as equivalent to (bytes!("xyz"))
[07:06:56] <dbaupp> ChrisMorgan: for what purpose?
[07:08:01] <dbaupp> (as in, we have those two equivalents)
[07:08:04] <ChrisMorgan> dbaupp: readers and writers will often need to work with u8 and [u8]; in rust-http code of both these forms is quite common
[07:08:29] *** Parts: z0w0 (corrz@C3BC732A.9254B1A4.F22F0031.IP) ()
[07:09:00] *** Joins: [squiddy] (squiddy@moz-A5352A4F.adsl.alicedsl.de)
[07:13:27] <dbaupp> ChrisMorgan: in any case, I personally wouldn't disagree with python style literals like that; but I think it was "decided" that a syntax extension was the way to go.
[07:13:53] <dbaupp> ChrisMorgan: https://github.com/mozilla/rust/issues/4334
[07:17:20] <dbaupp> (what I would like, though, is r"...")
[07:18:03] <dbaupp> is github 500'ing for anyone else?
[07:18:48] <klutzy> my friends are complaning it now
[07:19:23] <klutzy> Experiencing Problems https://status.github.com/
[07:20:50] *** Quits: lenstr (lenstr@AF8EB999.6049B16A.85938D85.IP) (Client exited)
[07:24:49] <dbaupp> klutzy: aha. :(
[07:25:52] *** Quits: eatkinson (eatkinson@moz-5CF47426.dia.static.qwest.net) (Quit: eatkinson)
[07:28:49] <leonvv> Does anyone know if there is some kind of "IsFunction" trait?
[07:29:37] <dbaupp> leonvv: there's not one; but every sort of function can get coerced to &fn at no cost
[07:31:26] *** Joins: sebcrozet (sebcrozet@moz-D8879CC3.w80-13.abo.wanadoo.fr)
[07:31:31] <leonvv> dbaupp: Okay, thanks!
[07:31:45] *** Joins: lenstr (lenstr@AF8EB999.6049B16A.85938D85.IP)
[07:37:08] <ChrisMorgan> dbaupp: r"..." is a good idea. Then we'd want br"..." too.
[07:37:59] <dbaupp> ChrisMorgan: bytes!(r"...") covers that case. (assuming you can stomach using bytes!.)
[07:38:21] *** Joins: jviereck (Adium@moz-C7B1E34.dip0.t-ipconnect.de)
[07:38:34] <ChrisMorgan> Frankly, I don't understand why anyone would argue in favour of bytes!("...") over b"...".
[07:38:54] *** Quits: dcrewi (david@moz-AB8667CE.gyrae.net) (Ping timeout)
[07:39:05] <dbaupp> because it's using the built-in syntax-ext infrastructure, rather than "complicating" the parser
[07:39:35] <ChrisMorgan> Did Rust formerly support L"..."? The Vim syntax thing has it. Might be a leftover from the C syntax file if that's what it was based on.
[07:39:44] * dbaupp doesn't know
[07:40:07] <ChrisMorgan> It ain't valid now, anyway.
[07:41:45] *** Quits: lenstr (lenstr@AF8EB999.6049B16A.85938D85.IP) (Client exited)
[07:43:49] *** Joins: lenstr (lenstr@AF8EB999.6049B16A.85938D85.IP)
[07:48:31] *** Joins: goku12 (gokuldas@F85D8811.D41F22C4.768E2BF5.IP)
[07:56:48] *** Quits: sk (sk@61A494B3.BA40E8A.AAC02D62.IP) (Quit: Leaving)
[07:58:09] <SingingBoyo> I keep seeing rt::io::Writer mentioned vs io::Writer... where is rt::io?  Can't seem to find it
[07:59:46] *** Joins: squiddy_ (squiddy@moz-1E8AEB3B.adsl.alicedsl.de)
[08:00:07] <dbaupp> SingingBoyo: std::rt::io
[08:00:43] *** Quits: [squiddy] (squiddy@moz-A5352A4F.adsl.alicedsl.de) (Ping timeout)
[08:01:52] <SingingBoyo> dbaupp: any idea what file it's in?  trying to find docs or failing that read the code and see if I can figure it out
[08:01:56] <klutzy> rt module is not on docs
[08:02:14] <klutzy> src/libstd/rt/io/mod.rs I guess
[08:02:46] *** Quits: BizarreCake (BizarreCak@moz-361FE9B2.dynamic.barak-online.net) (Connection reset by peer)
[08:03:57] *** Ms2ger|sheriff is now known as Ms2ger
[08:04:25] <SingingBoyo> ah, helps when you actually go to src/libstd/rt instead of src/rt
[08:06:08] *** Quits: lenstr (lenstr@AF8EB999.6049B16A.85938D85.IP) (Client exited)
[08:08:53] *** Joins: sankha93 (Instantbir@7061CD01.D6BD0D91.22D41759.IP)
[08:09:25] *** Joins: lenstr (lenstr@AF8EB999.6049B16A.85938D85.IP)
[08:10:53] *** Joins: engla (engla@moz-DBD1D96E.cust.bredbandsbolaget.se)
[08:18:38] <dbaupp> does someone feel like making a reasoned response to http://www.reddit.com/r/programming/comments/1kub90/a_week_with_mozillas_rust/cbsvrme ?
[08:20:55] <Ms2ger> dbaupp, I dunno if that kind of person responds well to reasoned responses
[08:21:31] *** Joins: ghrust (ghrust@24260B07.6A2AE50.F3114085.IP)
[08:21:31] <ghrust> 01[13rust01] 15bors merged 06auto into 06master: 02http://git.io/YTZQ0g
[08:21:31] *** Parts: ghrust (ghrust@24260B07.6A2AE50.F3114085.IP) ()
[08:21:45] <dbaupp> Ms2ger: it'd be directed at others reading it.
[08:25:58] <bjz> don't feed the trolls, just vote them down ;)
[08:26:24] *** Joins: CarpNet (ac@moz-FD24B77.sohonet.co.uk)
[08:26:52] * bjz votes him down
[08:27:14] * dbaupp doesn't quite understand why some people hate terse-but-obvious names like "str"
[08:28:05] <klutzy> short names may be bad to read at first, but it gets better if they are once remembered
[08:28:15] <dbaupp> klutzy++
[08:28:30] <klutzy> and I think most names are quite common so easy to remember
[08:29:29] <bjz> most common to use stuff should be shorter, less used stuff longer
[08:30:17] * dbaupp likes huffman-encoded language keywords too
[08:30:26] <bjz> when it's less used, you need to remember what it does, when it's common, you remember what it means and don't want it to be a chore to type
[08:31:24] <Ms2ger> I don't like abbreviations much myself, but str and fmt seem pretty harmless
[08:31:31] *** Joins: ghrust (ghrust@F6EE6DE3.6A2AE50.F3114085.IP)
[08:31:31] <ghrust> 01[13rust01] 15bors pushed 0 new commits to 06auto: 02http://git.io/uU-Htg
[08:31:31] *** Parts: ghrust (ghrust@F6EE6DE3.6A2AE50.F3114085.IP) ()
[08:31:44] <klutzy> keyboards are really hard to use if you don't remember key locations :)
[08:33:30] <klutzy> so non-technical users usually use mouse. I think it's sort of targetting-audience problem
[08:36:30] <sammykim> How can I print u8 as hexadecimal? 
[08:37:04] *** Quits: engla (engla@moz-DBD1D96E.cust.bredbandsbolaget.se) (Ping timeout)
[08:37:20] <dbaupp> rusti: printfln!(128u8.to_str_radix(16))
[08:37:20] *** Joins: sk (sk@5FD88F96.77870B72.78DD174B.IP)
[08:37:22] -rusti- ~"80"
[08:37:22] -rusti- ()
[08:37:37] <dbaupp> rusti: println(255u8.to_str_radix(16))
[08:37:38] -rusti- ff
[08:37:39] -rusti- ()
[08:37:47] <sammykim> dbaupp: Thanks!
[08:38:58] *** Joins: engla (engla@moz-DBD1D96E.cust.bredbandsbolaget.se)
[08:39:07] <dbaupp> rusti: printfln!("0x%02x 0x%02x", 255u8 as uint, 13u8 as uint)
[08:39:09] -rusti- 0xff 0x0d
[08:39:09] -rusti- ()
[08:39:55] <sammykim> rusti:     let data: u8 = 1u8;     println(fmt!("%?", data.to_str_radix(16)));
[08:39:56] -rusti- ~"1"
[08:39:56] -rusti- ()
[08:40:06] *** Joins: bjz_ (brendanzab@B398BE78.F804C29E.D35A31DF.IP)
[08:40:07] *** Quits: bjz (brendanzab@B398BE78.F804C29E.D35A31DF.IP) (Connection reset by peer)
[08:40:51] <bjz_> dbaupp: oh wells, fed the troll for you: http://www.reddit.com/r/programming/comments/1kub90/a_week_with_mozillas_rust/cbswaj5
[08:41:21] *** Quits: klapaucius (klapaucius@272B8F8B.5692770D.BB41F968.IP) (Quit: klapaucius)
[08:41:32] *** Joins: ghrust (ghrust@24260B07.6A2AE50.F3114085.IP)
[08:41:32] <ghrust> 01[13rust01] 15bors pushed 0 new commits to 06auto: 02http://git.io/uU-Htg
[08:41:32] *** Parts: ghrust (ghrust@24260B07.6A2AE50.F3114085.IP) ()
[08:41:32] *** Joins: ghrust (ghrust@DE823A67.6A2AE50.F3114085.IP)
[08:41:32] <ghrust> 01[13rust01] 15bors pushed 2 new commits to 06auto: 02http://git.io/xSb4fQ
[08:41:32] <ghrust> 13rust/06auto 14a02a759 15Brian Anderson: test: Add test for #7563. Closes #7563
[08:41:32] <ghrust> 13rust/06auto 14b95c135 15bors: auto merge of #8620 : brson/rust/issue-7563, r=alexcrichton
[08:41:33] *** Parts: ghrust (ghrust@DE823A67.6A2AE50.F3114085.IP) ()
[08:42:46] <doomlord> i like short names like str, ptr, .. so long as they're unambiguous
[08:45:01] *** Joins: lucian (lucian@6B2B4644.4304AE1E.CE5E78F6.IP)
[08:45:32] <engla> dbaupp: shouldn't it be char::from_digit in your comment? Instead of Char
[08:46:10] <dbaupp> engla: I used the trait static method
[08:46:18] * dbaupp double checks it exists
[08:46:37] <dbaupp> right, the standalone function would be nicer.
[08:46:39] * dbaupp edits
[08:46:53] <doomlord> heh. looking at that thread, its just people who dont want to learn something different
[08:46:54] <engla> oh I didn't know Char existed
[08:47:28] <doomlord> so they pick up on little things to disagree with. 
[08:47:59] *** Quits: leonvv (leonvv@moz-7D83A5F1.ip.telfort.nl) (Client exited)
[08:48:16] <doomlord> i'm only content if i'm encountering new things on a regular basis :)
[08:48:26] *** Quits: lenstr (lenstr@AF8EB999.6049B16A.85938D85.IP) (Client exited)
[08:49:01] *** Quits: wilkie (wilkie@moz-A435EAAD.pitbpa.fios.verizon.net) (Ping timeout)
[08:49:32] *** Joins: wilkie (wilkie@moz-A435EAAD.pitbpa.fios.verizon.net)
[08:50:06] <dbaupp> engla: yeah, to get any methods, the built-in types require traits... hence Vector, Str, Char etc.
[08:51:13] *** Joins: novabyte (Instantbir@moz-D1C6C853.mullvad.net)
[08:57:37] <engla> I know what you mean
[08:57:52] <engla> even if Vector and Str are used as "real" traits
[09:00:18] <dbaupp> yeah, I guess Char is the only one that is purely for methods. (assuming there's not a Bool.)
[09:00:27] <dbaupp> oh, and Ptr for *
[09:00:44] <engla> Ptr is implemented for *mut T too
[09:00:46] <engla> :)
[09:01:08] <dbaupp> meh, pretty much the same :P
[09:01:47] <dbaupp> (I even think there's a proposal to remove *mut T?)
[09:02:07] *** Quits: paulproteus (quassel@rose.makesad.us) (Ping timeout)
[09:02:51] *** AutomatedTester|AFK is now known as AutomatedTester
[09:06:28] *** Joins: anders (anders@moz-329650BE.cust.bredbandsbolaget.se)
[09:09:02] *** Joins: q66 (q66@6EE9DE40.46454B5D.33AABD5F.IP)
[09:11:01] <SingingBoyo> acrichto: ping
[09:14:32] *** Joins: BizarreCake (BizarreCak@moz-361FE9B2.dynamic.barak-online.net)
[09:16:16] *** Joins: fabiand (fabiand@moz-37A8C5D8.adsl.alicedsl.de)
[09:17:52] *** Quits: nrc (nrc@7BE24E90.A5032A01.3CFC199D.IP) (Ping timeout)
[09:19:14] *** Quits: james4k (james@moz-E7990244.consolidated.net) (Ping timeout)
[09:19:38] *** Joins: FrozenCow (FrozenCow@moz-B2DF4929.chello.nl)
[09:20:31] *** Joins: paulproteus (quassel@moz-E86A3B42.makesad.us)
[09:20:34] *** Quits: KindOne (KindOne@CAA28FF2.B2471F87.34F73994.IP) (Ping timeout)
[09:21:53] *** Quits: jviereck (Adium@moz-C7B1E34.dip0.t-ipconnect.de) (Quit: Leaving.)
[09:22:17] *** Joins: lenstr (lenstr@AF8EB999.6049B16A.85938D85.IP)
[09:22:50] *** Joins: int3_ (int3_@moz-ABE52D50.hsd1.ca.comcast.net)
[09:23:46] *** Joins: donri (dag@moz-9BB61102.tbcn.telia.com)
[09:24:37] *** Quits: int3_ (int3_@moz-ABE52D50.hsd1.ca.comcast.net) (Ping timeout)
[09:24:37] *** Joins: KindOne (KindOne@D1270FBE.5ADC762.34F73994.IP)
[09:28:24] *** Quits: hjr3 (hradtke@moz-E87BDF1F.socal.res.rr.com) (Quit: My MacBook has gone to sleep. ZZZzzzâ€¦)
[09:29:18] *** Quits: flowsnake (flowsnake@moz-1918C33E.aztw.cable.virginmedia.com) (Connection reset by peer)
[09:33:38] *** Joins: flowsnake (flowsnake@moz-1918C33E.aztw.cable.virginmedia.com)
[09:34:18] *** Joins: hjr3 (hradtke@moz-E87BDF1F.socal.res.rr.com)
[09:40:53] *** Joins: robertknight (robertknig@moz-54528EE0.wby.mendeley.com)
[09:42:17] *** Quits: lenstr (lenstr@AF8EB999.6049B16A.85938D85.IP) (Client exited)
[09:42:20] *** Joins: Earnestly (earnest@B0BDF733.8FDE20A.5411983D.IP)
[09:46:00] *** Quits: hjr3 (hradtke@moz-E87BDF1F.socal.res.rr.com) (Quit: My MacBook has gone to sleep. ZZZzzzâ€¦)
[09:46:15] *** Joins: lenstr (lenstr@AF8EB999.6049B16A.85938D85.IP)
[09:48:03] *** Quits: SingingBoyo (brandon@4DF3381A.51F4D838.4F048BDC.IP) (Ping timeout)
[09:49:45] *** Joins: pnkfelix (pnkfelix@87C1F78E.1DE10CA8.D8E68FF6.IP)
[09:53:10] *** Joins: leonvv (leonvv@moz-7D83A5F1.ip.telfort.nl)
[09:53:34] *** Quits: sebcrozet (sebcrozet@moz-D8879CC3.w80-13.abo.wanadoo.fr) (Ping timeout)
[09:56:21] *** Quits: snadon (chatzilla@moz-3BC727E8.mc.videotron.ca) (Ping timeout)
[09:58:14] *** Joins: mib_d88cvc (Mibbit@55AA4F49.9CEE5B55.C34545D8.IP)
[09:58:44] *** Quits: sankha93 (Instantbir@7061CD01.D6BD0D91.22D41759.IP) (Quit: Gone to save the world!)
[09:59:12] *** Joins: sankha93 (Instantbir@7061CD01.D6BD0D91.22D41759.IP)
[10:00:45] *** Quits: sankha93 (Instantbir@7061CD01.D6BD0D91.22D41759.IP) (Quit: Gone to save the world!)
[10:01:31] *** Joins: ghrust (ghrust@9C8B94D4.6A2AE50.F3114085.IP)
[10:01:31] <ghrust> 01[13rust01] 15bors merged 06auto into 06master: 02http://git.io/xSb4fQ
[10:01:31] *** Parts: ghrust (ghrust@9C8B94D4.6A2AE50.F3114085.IP) ()
[10:04:30] *** Joins: fhahn (flo@55AA4F49.9CEE5B55.C34545D8.IP)
[10:05:49] *** Quits: mib_d88cvc (Mibbit@55AA4F49.9CEE5B55.C34545D8.IP) (Quit: http://www.mibbit.com ajax IRC Client)
[10:11:30] *** Joins: ghrust (ghrust@F6EE6DE3.6A2AE50.F3114085.IP)
[10:11:31] <ghrust> 01[13rust01] 15bors pushed 0 new commits to 06auto: 02http://git.io/l11oig
[10:11:31] *** Parts: ghrust (ghrust@F6EE6DE3.6A2AE50.F3114085.IP) ()
[10:11:31] *** Joins: ghrust (ghrust@C8693FCB.6A2AE50.F3114085.IP)
[10:11:31] <ghrust> 01[13rust01] 15bors pushed 2 new commits to 06auto: 02http://git.io/0xYUAw
[10:11:31] <ghrust> 13rust/06auto 148aa4799 15Kevin Ballard: Don't skip token after @'static...
[10:11:31] <ghrust> 13rust/06auto 147e50260 15bors: auto merge of #8626 : kballard/rust/issue-8615, r=catamorphism...
[10:11:31] *** Parts: ghrust (ghrust@C8693FCB.6A2AE50.F3114085.IP) ()
[10:18:36] *** Quits: donri (dag@moz-9BB61102.tbcn.telia.com) (Client exited)
[10:18:43] *** Joins: donri (dag@moz-9BB61102.tbcn.telia.com)
[10:19:54] *** Joins: maxli (maxli@B5559308.9C54E60.2FA4EA88.IP)
[10:20:12] *** Quits: maxli (maxli@B5559308.9C54E60.2FA4EA88.IP) (Input/output error)
[10:22:16] *** Joins: MrFahrenheit (RageOfThou@3FEF494C.29C984D5.783DEDCA.IP)
[10:23:40] *** Joins: maxli (maxli@B5559308.9C54E60.2FA4EA88.IP)
[10:23:41] *** Quits: maxli (maxli@B5559308.9C54E60.2FA4EA88.IP) (Input/output error)
[10:26:29] *** Joins: youknowone (youknowone@A826BD81.8A0DEF81.38747683.IP)
[10:26:29] *** Quits: youknowone (youknowone@A826BD81.8A0DEF81.38747683.IP) (Z:lined (Open Proxy found on your host. Please visit www.blitzed.org/proxy?ip=115.68.131.49 for more information.))
[10:29:20] *** Quits: leonvv (leonvv@moz-7D83A5F1.ip.telfort.nl) (Client exited)
[10:30:17] *** Joins: jensnockert (jensnocker@moz-8BE55278.customer.t3.se)
[10:31:56] *** Joins: maik (maik___@moz-8068AB43.dip0.t-ipconnect.de)
[10:33:08] *** Quits: nsf (nsf@moz-EEF3238A.convex.ru) (Quit: WeeChat 0.4.1)
[10:36:18] *** Joins: toqueteos (Mibbit@moz-3B73572C.dynamic.jazztel.es)
[10:36:29] *** Joins: sebcrozet (sebcrozet@moz-D8879CC3.w80-13.abo.wanadoo.fr)
[10:36:34] *** Joins: Florob (Florob@moz-39532932.de)
[10:38:52] *** Joins: richard|s (mindginati@moz-D2CEE0E6.dyn.cust.vf.net.nz)
[10:39:16] *** Quits: recrack (Mibbit@B4104EBB.3CC170B1.1E14B209.IP) (Quit: http://www.mibbit.com ajax IRC Client)
[10:40:51] <toqueteos> rust newbie here, did anyone in the past propose visibility for Rust like Go?
[10:45:47] *** Quits: igl (igl@moz-684C758E.adsl.alicedsl.de) (Connection reset by peer)
[10:46:38] *** Quits: Kauhsa (kauhsa@moz-A78B2D1A.fi) (Quit: ~)
[10:46:43] *** Quits: fabiand (fabiand@moz-37A8C5D8.adsl.alicedsl.de) (Ping timeout)
[10:47:00] *** Quits: squiddy_ (squiddy@moz-1E8AEB3B.adsl.alicedsl.de) (Ping timeout)
[10:47:00] *** Quits: sebcrozet (sebcrozet@moz-D8879CC3.w80-13.abo.wanadoo.fr) (Ping timeout)
[10:47:20] *** Joins: igl (igl@moz-684C758E.adsl.alicedsl.de)
[10:48:28] *** Joins: Kauhsa (kauhsa@moz-A78B2D1A.fi)
[10:48:34] *** Joins: fabiand (fabiand@moz-37A8C5D8.adsl.alicedsl.de)
[10:48:34] *** Joins: rovar_ (rovar@moz-203658CB.nycmny.fios.verizon.net)
[10:48:47] *** Joins: sebcrozet (sebcrozet@moz-6DA639AF.w80-13.abo.wanadoo.fr)
[10:49:07] *** Joins: squiddy_ (squiddy@moz-1E8AEB3B.adsl.alicedsl.de)
[10:49:30] *** Quits: rovar (rovar@moz-203658CB.nycmny.fios.verizon.net) (Ping timeout)
[10:53:20] *** Quits: anders (anders@moz-329650BE.cust.bredbandsbolaget.se) (Quit: anders)
[10:57:22] *** Quits: jensnockert (jensnocker@moz-8BE55278.customer.t3.se) (Input/output error)
[10:58:12] *** Joins: jviereck (Adium@moz-C7B1E34.dip0.t-ipconnect.de)
[10:59:14] *** Quits: jviereck (Adium@moz-C7B1E34.dip0.t-ipconnect.de) (Quit: Leaving.)
[10:59:18] *** Quits: fyolnish (fyolnish@moz-BE2BAE5B.miinet.jp) (Ping timeout)
[11:02:46] *** Quits: goku12 (gokuldas@F85D8811.D41F22C4.768E2BF5.IP) (Ping timeout)
[11:12:12] *** Quits: reyre (reyre@moz-9002CDDA.cpe.net.cable.rogers.com) (Client exited)
[11:16:18] *** Quits: maik (maik___@moz-8068AB43.dip0.t-ipconnect.de) (Ping timeout)
[11:16:49] <engla> toqueteos: if you mean that capitalization matters, I don't think so
[11:17:10] <engla> I'd guess it's not something for rust
[11:17:59] <engla> there are some visibility pieces missing in rust at the moment, a proposal to remove `priv`, and some bugs that expose private items
[11:18:04] *** Joins: victorporof_ (victorporo@256FD045.43CE31D0.9B1E38F4.IP)
[11:18:08] <toqueteos> thanks engla
[11:18:36] <engla> at the moment types are CamelCase and methods are lowercase_with_underscores
[11:18:45] <engla> and public items are denoted with pub
[11:18:55] <toqueteos> i got used to that and now checking rust for pub is getting weird
[11:19:14] *** Quits: victorporof (victorporo@256FD045.43CE31D0.9B1E38F4.IP) (Ping timeout)
[11:19:28] <toqueteos> and something like rustfmt? is it available as 3rd party?
[11:19:39] <ChrisMorgan> Given a ~[T], can one get a &[T]?
[11:19:47] <ChrisMorgan> (Or rather, a &mut [T].)
[11:20:47] <dbaupp> toqueteos: you can use `rustc foo.rs --pretty`, but it's not very good at all.
[11:21:03] <dbaupp> ChrisMorgan: it should automatically coerce if the ~[T] is in a mutable slot
[11:21:10] <toqueteos> i really like rust for having some things Go doesn't, they always say it's no possible because memory safety but hey.. rust can and it's memory safe, someone is lying to me here
[11:21:35] *** Joins: victorporof (victorporo@256FD045.43CE31D0.9B1E38F4.IP)
[11:21:46] <engla> I think rust is more complex to accomodate that toqueteos
[11:21:55] <toqueteos> yep, for sure
[11:21:57] <dbaupp> toqueteos: a proper rustfmt tool is desired, just there are more important things to work on at the moment (like glaring compiler bugs) 
[11:22:22] <toqueteos> right now i don't feel confident enough to use rust, at least not until 1.0
[11:22:30] <toqueteos> it's to "changy"
[11:22:34] <toqueteos> too*
[11:22:41] <ChrisMorgan> That's part of the fun of working in Rust :-)
[11:22:42] <dbaupp> yeah, it is like that :)
[11:22:45] *** Quits: victorporof_ (victorporo@256FD045.43CE31D0.9B1E38F4.IP) (Ping timeout)
[11:22:56] <toqueteos> also i miss lots of libraries i find on go std..
[11:22:57] <toqueteos> damn it
[11:23:32] *** Joins: msingle (Thunderbir@moz-930E5D97.hr.hr.cox.net)
[11:24:06] <engla> golang didn't have that many libraries at release either
[11:24:10] *** Joins: z0w0 (zack@moz-7E6DC3A.lnse2.woo.bigpond.net.au)
[11:24:41] <dbaupp> also, if we're comparing against go, go was made public *much* latter in the stability cycle; rust has been public from very very early
[11:24:46] <toqueteos> i know it's not a fair comparison
[11:25:09] <ChrisMorgan> Still, it does sound like Rust's standard library will be a little smaller than Go's at the point where the language is called 1.0.
[11:25:17] <toqueteos> not blaming anyone, rust devs are doing an awesome job
[11:25:33] <toqueteos> but, no offense here, it seems they are trying to do too much at the moment
[11:25:49] <toqueteos> at least from a newcomer's point of view
[11:26:01] <engla> it seems go has a much different vision. their compiler is simple and fast  (from over here it looks like)
[11:26:05] <dbaupp> what do you mean by "too much"?
[11:26:22] <toqueteos> i've been reading some proposals on the github wiki
[11:26:36] <dbaupp> the effects one?
[11:26:37] <toqueteos> and some of the approved ones feel bloated
[11:26:48] <dbaupp> which?
[11:26:53] <toqueteos> let me check i closed
[11:27:07] <toqueteos> maybe it's just my inexpertise with the language (probably that)
[11:27:41] <toqueteos> ow, my bad
[11:27:55] <dbaupp> heh, this is "active" apparently: https://github.com/mozilla/rust/wiki/Proposal-for-fixits "last edited 2 years ago"
[11:27:56] <toqueteos> the one i'm saying it's closed (predicates) my bad
[11:28:06] <toqueteos> sorry
[11:28:28] <toqueteos> anyways, right now i'm researching how tests work
[11:28:35] <toqueteos> i was expecting some testing library
[11:28:44] <toqueteos> but there's just flags and rustc --test right?
[11:28:54] <toqueteos> #[test] and such
[11:29:10] <dbaupp> ah, yes, typestate was removed a while ago, because it was deemed unhelpful
[11:29:44] <dbaupp> and, yes, #[test] (+ #[should_fail]), and #[bench] is the built-in unit-testing/benching
[11:30:10] <engla> the test harness should be mostly inside  extra::test
[11:30:37] <dbaupp> it is
[11:30:58] *** Quits: novabyte (Instantbir@moz-D1C6C853.mullvad.net) (Quit: bye bye)
[11:31:15] <engla> but it is in fact marked hidden
[11:31:22] <toqueteos> http://static.rust-lang.org/doc/extra/test.html ?
[11:31:32] *** Joins: ghrust (ghrust@F6EE6DE3.6A2AE50.F3114085.IP)
[11:31:32] <ghrust> 01[13rust01] 15bors merged 06auto into 06master: 02http://git.io/0xYUAw
[11:31:32] *** Parts: ghrust (ghrust@F6EE6DE3.6A2AE50.F3114085.IP) ()
[11:31:33] *** Joins: maik (maik___@moz-BEACDBF.dip0.t-ipconnect.de)
[11:31:47] <dbaupp> engla: oh; I guess it's not designed (yet) for external use
[11:32:14] <dbaupp> toqueteos: https://github.com/mozilla/rust/blob/master/src/libextra/test.rs
[11:33:01] <maik> btw can we compile rust to javascript with https://github.com/kripken/emscripten ?
[11:33:16] <dbaupp> maik: not yet
[11:33:37] <engla> check-stage1-std is supposed to run the benchmarks compiled with -O ?
[11:33:41] <dbaupp> maik: https://github.com/mozilla/rust/issues/2235
[11:33:52] <dbaupp> engla: doesn't it?
[11:34:20] *** Joins: Cromulent (Cromulent@moz-983B638D.cable.virginmedia.com)
[11:34:20] *** Quits: Cromulent (Cromulent@moz-983B638D.cable.virginmedia.com) (Quit: Cromulent)
[11:34:26] <toqueteos> mmm
[11:34:46] <toqueteos> now i'm thinking about "whatever_test.rs"
[11:34:49] <engla> I'd say no, since benches that were formerly the same speed are now different and both much slower
[11:35:02] <engla> rustc -O --test std.rs is the same
[11:35:27] <engla> maybe something else changed
[11:35:33] <maik> dbaupp, thanks
[11:35:54] <dbaupp> engla: LLVM got upgraded and caused known perf regressions (sec)
[11:36:06] <maik> do you think it could be possible to compile a c++ lib to llvm and translate it to rust?
[11:36:11] <dbaupp> engla: https://github.com/mozilla/rust/issues/8665
[11:36:24] <engla> aha
[11:36:33] <toqueteos> anways, thanks guys for your help, i'll continue toying around with the language 'til i'm a bit more used to rust
[11:36:46] <dbaupp> toqueteos: np, #rust is always happy to help :)
[11:37:28] <engla> ok thanks dbaupp, that could cause this too
[11:39:55] <doomlord> maik i have limited translation of c++ prototypes
[11:40:18] <doomlord> oh c++ to llvm -> rust heh
[11:40:53] <doomlord> i think you could translate some subset of c++
[11:41:18] <dbaupp> maik: I guess the decompiled llvm IR would end up being horrible rust
[11:41:29] *** Joins: ghrust (ghrust@F6EE6DE3.6A2AE50.F3114085.IP)
[11:41:29] <ghrust> 01[13rust01] 15bors pushed 0 new commits to 06auto: 02http://git.io/LvoWAg
[11:41:29] *** Parts: ghrust (ghrust@F6EE6DE3.6A2AE50.F3114085.IP) ()
[11:41:30] *** Joins: ghrust (ghrust@DE823A67.6A2AE50.F3114085.IP)
[11:41:30] <ghrust> 01[13rust01] 15bors pushed 2 new commits to 06auto: 02http://git.io/Ml9cow
[11:41:31] <ghrust> 13rust/06auto 14aeb06f2 15Kevin Ballard: Fix broken rusti...
[11:41:31] <ghrust> 13rust/06auto 143f6f79b 15bors: auto merge of #8627 : kballard/rust/fix-rusti, r=catamorphism...
[11:41:31] *** Parts: ghrust (ghrust@DE823A67.6A2AE50.F3114085.IP) ()
[11:42:12] *** Joins: goku12 (gokuldas@D5F4666E.278F6213.6AA50C35.IP)
[11:43:24] *** Joins: reyre (reyre@moz-9002CDDA.cpe.net.cable.rogers.com)
[11:51:02] *** Quits: BizarreCake (BizarreCak@moz-361FE9B2.dynamic.barak-online.net) (Connection reset by peer)
[11:52:08] *** Quits: goku12 (gokuldas@D5F4666E.278F6213.6AA50C35.IP) (Quit: Konversation terminated!)
[11:52:48] *** Joins: Azdle (patrick@moz-8C723B60.hsd1.mn.comcast.net)
[11:54:06] *** Quits: z0w0 (zack@moz-7E6DC3A.lnse2.woo.bigpond.net.au) (Client exited)
[11:54:24] *** AutomatedTester is now known as AutomatedTester|AFK
[12:01:58] *** Joins: BitPuffin (quassel@moz-8370D1B9.bredband.comhem.se)
[12:06:35] *** Joins: jensnockert (jensnocker@moz-8BE55278.customer.t3.se)
[12:11:17] *** Joins: jorendorff (jorendorff@moz-2F32ACA3.hsd1.tn.comcast.net)
[12:11:33] *** Joins: adridu59 (Mibbit@moz-6C393FDD.rev.numericable.fr)
[12:14:00] <maik> doomlord, oh cool
[12:14:10] <maik> doomlord, do you have a git repo?
[12:17:40] <doomlord> yes
[12:18:16] <doomlord> *disclaimer* , i did say limited . i'd started a tool aimed at c++ bindings , parsing collection classes in headers
[12:18:48] <doomlord> https://github.com/dobkeratops/cpp2rust
[12:18:51] *** Quits: Azdle (patrick@moz-8C723B60.hsd1.mn.comcast.net) (Ping timeout)
[12:20:12] <doomlord> it tries to spit out C functions for the C++ methods, and rust impls, .. C++ method-> C wrapper -> rust call to C wrapper from an impl.
[12:20:58] <doomlord> ... the intention was to substitute rust side equivalents of C++ vectors etc. I figured i could re-work my own C++ within the limitations of my tool.
[12:21:05] *** Quits: KindOne (KindOne@D1270FBE.5ADC762.34F73994.IP) (Ping timeout)
[12:21:24] <doomlord> i think you could handle overloading with some sort of double-dispatch wrappers in rust..
[12:21:32] <doomlord> it doesn't do that yet
[12:21:58] <doomlord> default parameters are another sticking point which is why i wanted to try adding those :) 
[12:22:09] *** Joins: relistan (relistan@A7E4EF66.4C1F25E9.4BA0249.IP)
[12:22:39] *** Joins: maxli (maxli@13F2CEC5.7672369.D8E68FF6.IP)
[12:23:17] <maik> doomlord, it's a very cool project,  it definitely eases the translation
[12:24:35] *** Joins: RMF (RMF@moz-4C3A3FAA.dsl.telepac.pt)
[12:24:51] *** Joins: KindOne (KindOne@moz-49B9C261.dynamic.ip.windstream.net)
[12:25:10] *** Quits: robertknight (robertknig@moz-54528EE0.wby.mendeley.com) (Ping timeout)
[12:25:36] *** Quits: jorendorff (jorendorff@moz-2F32ACA3.hsd1.tn.comcast.net) (Quit: jorendorff)
[12:25:46] <maik> btw does pure c has some functionality that we don't have?
[12:26:28] <maik> s/have/has I guess
[12:26:39] <doomlord> i got the impression rust unsafe {} is identical to pure C, but macros would likely  defy translation.
[12:26:39] *** Quits: reyre (reyre@moz-9002CDDA.cpe.net.cable.rogers.com) (Client exited)
[12:26:44] <pnkfelix> The C preprocessor?  ;)
[12:27:21] <doomlord> pointer arithmetic was recently added. Again, i wondered if a translator could be written,and interested people rework their C macros and provide rust substitutions manualy written
[12:28:21] *** Joins: samx (sami@moz-48EC0983.dyn.optonline.net)
[12:28:56] <doomlord> i thinnk they have some rust benchmarks of test programs in unsafe code to prove C equivalence
[12:29:59] *** Quits: m_kato (m_kato@moz-C286AD9A.bitcat.net) (Quit: Leaving...)
[12:30:19] <dbaupp> goto's
[12:30:47] <maik> c has goto?
[12:31:06] <dbaupp> doomlord: Rust get C speeds (for some things) even without unsafe code
[12:31:07] <dbaupp> maik: yes
[12:31:16] <maik> I thought only asm has goto :D
[12:31:42] <doomlord> ...oh of course, goto :) 
[12:32:19] <maik> do ppl even use goto in c applications?
[12:32:33] <ChrisMorgan> Yes.
[12:32:33] <pnkfelix> maik: Sure.
[12:32:38] <doomlord> i just did yesterday :(
[12:32:38] <maik> :X
[12:32:38] *** Joins: dave1629 (dave@moz-17578A1A.hsd1.va.comcast.net)
[12:32:46] <ChrisMorgan> There are certain patterns where goto is a *good* thing to use.
[12:32:58] <pnkfelix> maik: http://cs.sjsu.edu/~mak/CS185C/KnuthStructuredProgrammingGoTo.pdf
[12:32:59] <dbaupp> clean-up after errors is the most common(?) use of goto
[12:33:14] <ChrisMorgan> That's the most common one I've seen.
[12:33:14] <doomlord> early function return, with free()
[12:33:52] <doomlord> avoidded duplicating free() code, whcih C++ would have done for you with  destructors
[12:33:58] *** Quits: dave1629 (dave@moz-17578A1A.hsd1.va.comcast.net) (Quit: dave1629)
[12:34:01] <ChrisMorgan> A codebase I've worked with has a significant portion in C, and "bail" is the most common goto target by a landslide. Most functions of any meat use that pattern.
[12:34:13] <dbaupp> maik: i.e. instead of `if (some_condition) { free(x); free(y); return } ... if (some_other_condition) { free(x); free(y); return }`
[12:34:57] <dbaupp> maik: you can use `if (some_condition) goto bail; ... if (some_other_condition) goto bail; ... /* end of function */ bail: free(x); free(y); return }`
[12:35:30] <adridu59> Linux Kernel uses goto's that way
[12:35:37] <jensnockert> I'm not proud of it, but I have even emulated goto with various constructs (like exceptions), mostly for building FSMs.
[12:35:44] <maik> ah okay thanks
[12:35:48] <adridu59> to do cleanups at the end of function when there are different type cases to handle
[12:36:00] *** Quits: dsirenko (mitra@8E712A0.54C21BA0.9F317420.IP) (Quit: Konversation terminated!)
[12:36:37] <doomlord> wasnt there a gcc extention for computable gotos or something :)
[12:36:52] *** Quits: samx (sami@moz-48EC0983.dyn.optonline.net) (Quit: This computer has gone to sleep)
[12:36:53] <Ms2ger> I believe we used that in spidermonkey
[12:37:16] <heftig_> jensnockert: exceptions aren't for that
[12:37:18] <dbaupp> doomlord: yeah, `goto array_of_labels[x];` works
[12:37:22] <heftig_> the stack unwinding is very expensive
[12:37:29] <jensnockert> heftig_: I am well aware.
[12:37:56] <jensnockert> heftig_: But they work essentially the same, so you can replace one with the other.
[12:37:57] <doomlord> there aren't any requests for goto in rust i take it :)
[12:38:15] <heftig_> comefrom is better :p
[12:38:20] <dbaupp> doomlord: there are; for FSMs
[12:38:34] <doomlord> wow ok.
[12:38:38] <dbaupp> doomlord: that said, we actually have forward-goto already with labelled breaks
[12:39:11] <dbaupp> rusti: 'foo: loop { loop { break 'foo; } println("not printed"); } "foo"
[12:39:12] -rusti- "foo"
[12:39:18] *** Joins: dsirenko (mitra@8E712A0.54C21BA0.9F317420.IP)
[12:40:30] *** Quits: toqueteos (Mibbit@moz-3B73572C.dynamic.jazztel.es) (Quit: http://www.mibbit.com ajax IRC Client)
[12:40:33] <jensnockert> But I am sure there is a sane non-goto we can implement in Rust that allows us to write really succint 
[12:40:44] <jensnockert> FSMs.
[12:40:56] <jensnockert> *succinct
[12:40:56] <dbaupp> yeah, erickt is working on things
[12:40:59] <jensnockert> \o/
[12:41:05] * dbaupp has an interest in it too
[12:41:21] <dbaupp> jensnockert: https://gist.github.com/huonw/6145412
[12:41:36] <jensnockert> FSMs and error handling are essentially the only times goto is useful in C, I think?
[12:41:45] <jensnockert> Please tell me if I am wrong.
[12:42:10] <dbaupp> I heard that computed-goto + a random number generator was fun.
[12:42:29] <jensnockert> dbaupp: That syntax seems pretty clean.
[12:43:01] <jensnockert> dbaupp: Yeah, rng + computed goto, what can go wrong?
[12:44:06] *** Quits: ChrisMorgan (chris@moz-6AC741CA.static.tpgi.com.au) (Ping timeout)
[12:44:58] *** Joins: ChrisMorgan (chris@moz-6AC741CA.static.tpgi.com.au)
[12:45:03] *** Quits: Earnestly (earnest@B0BDF733.8FDE20A.5411983D.IP) (Ping timeout)
[12:47:28] *** Joins: sankha93 (Instantbir@7061CD01.D6BD0D91.22D41759.IP)
[12:50:32] *** Quits: BitPuffin (quassel@moz-8370D1B9.bredband.comhem.se) (Client exited)
[12:53:04] <adridu59> hey guys, how do you do a simple for loop that iterate "i" from 0 to 4?
[12:53:42] <adridu59> the tutorial examples only show how to iterate from arrays which is nice but overkill for my uses
[12:53:46] <engla> do you have the latest rust master?
[12:53:53] <bjz_> rusti: for i in range(0, 4) { printfln("%?", i) }
[12:53:54] -rusti- <anon>:5:32: 5:40 error: unresolved name `printfln`.
[12:53:54] -rusti- <anon>:5          for i in range(0, 4) { printfln("%?", i) }
[12:53:54] -rusti-                                          ^~~~~~~~
[12:53:54] -rusti- error: aborting due to previous error
[12:53:54] -rusti- application terminated with error code 101
[12:54:00] <ChrisMorgan> !
[12:54:01] <bjz_> rusti: for i in range(0, 4) { printfln!("%?", i) }
[12:54:02] -rusti- 0
[12:54:02] -rusti- 1
[12:54:02] -rusti- 2
[12:54:02] -rusti- 3
[12:54:02] -rusti- ()
[12:54:20] <ChrisMorgan> for i in range(0, 5) { printf!("%? ", i) }
[12:54:28] <ChrisMorgan> rusti: for i in range(0, 5) { printf!("%? ", i) }
[12:54:29] -rusti- 0 1 2 3 4 ()
[12:54:45] *** Joins: Kruppe (user@moz-E150F49F.cpe.net.cable.rogers.com)
[12:54:54] <Jontte> so is rust able to unwind that kinds of constant-size loops in general?
[12:55:00] <adridu59> for i in range(0, 5) { printf!("%? ", i) }
[12:55:01] <Jontte> should it choose to
[12:55:03] <bjz_> yep
[12:55:07] <adridu59> rusti: for i in range(0, 5) { printf!("%? ", i) }
[12:55:08] -rusti- 0 1 2 3 4 ()
[12:55:19] <bjz_> llvm does.
[12:55:21] <cmr> Jontte: I think LLVM can, yes.
[12:55:37] <adridu59> so range 0 to 5 does not include 5?
[12:55:58] <bjz_> its [lo, hi)
[12:56:13] <adridu59> that's weird
[12:56:25] <engla> it matches python
[12:56:28] <cmr> not really?
[12:56:48] <adridu59> why is it so?
[12:56:58] <engla> it's useful adridu59, vector indices start from zero
[12:57:05] <cmr> it's a standard for i < max, I don't know of a function that doesn't use half inclusive ranges.
[12:57:46] *** Joins: azita (Azita@moz-C1FB2A8.hsd1.ca.comcast.net)
[12:58:01] <adridu59> I see, I always done -1 for vectors, so, for standard iterating where you go from 1 to VALUE you just start from zero
[12:58:42] <engla> which language are you used to?
[12:59:00] <adridu59> I have coded mostly in C, Arduino and Java in the past. JS too
[12:59:04] <dbaupp> rusti: for i in std::iterator::range_inclusive(0, 5) { printf!("%? ", i) }
[12:59:06] -rusti- 0 1 2 3 4 5 ()
[12:59:18] <adridu59> ah nice dbaupp
[12:59:35] <doomlord> range works correctly :)
[13:00:08] <doomlord> 0,5 are the boundaries. range (0,5)  range(5,10) touch but dont overlap
[13:00:30] <doomlord> size is hi-lo... all logial
[13:00:40] <doomlord> logical^
[13:00:42] <adridu59> I see
[13:01:00] <dbaupp> http://www.cs.utexas.edu/users/EWD/transcriptions/EWD08xx/EWD831.html is/should be the go-to rationale
[13:01:03] <adridu59> range and range_inclusive are not mentioned in the for doc here: http://static.rust-lang.org/doc/tutorial-container.html#for-loops
[13:01:12] <engla> for (i = 0; i < 5; i++) {}  is the common C idiom, matches [lo, hi) as well
[13:01:28] *** Joins: ghrust (ghrust@2EE61FCC.6A2AE50.F3114085.IP)
[13:01:29] <ghrust> 01[13rust01] 15bors merged 06auto into 06master: 02http://git.io/Ml9cow
[13:01:29] *** Parts: ghrust (ghrust@2EE61FCC.6A2AE50.F3114085.IP) ()
[13:01:34] *** zz_kimundi is now known as kimundi
[13:01:56] <cmr> adridu59: it's a tuttorial, not exhaustive documentation
[13:03:05] <bjz_> cmr: it might be nice to include range in there too
[13:03:10] *** Quits: engla (engla@moz-DBD1D96E.cust.bredbandsbolaget.se) (Ping timeout)
[13:03:14] <cmr> yes, definitely, now that it exists ;p
[13:03:25] <dbaupp> adridu59: http://static.rust-lang.org/doc/std/iterator.html#function-range
[13:03:36] <dbaupp> (the ToC of that page is fun.)
[13:03:47] <dbaupp> <3 rustdoc_ng
[13:04:01] <bjz_> cmr: heh, yup
[13:04:57] <dbaupp> adridu59: one subtlety is `range` is in the prelude, and so is in scope automatically; `range_inclusive` isn't, and so has to be explicitly imported from std::iterator.
[13:05:42] *** Quits: Liothen (liothen@moz-80EF0CD7.spkn.qwest.net) (Quit: Textual IRC Client: www.textualapp.com)
[13:07:22] *** Quits: sp3d (a@moz-6F12212B.fidnet.com) (Ping timeout)
[13:08:47] *** Joins: BitPuffin (quassel@moz-8370D1B9.bredband.comhem.se)
[13:08:59] *** Joins: cowboyd (cowboyd@1D8844A7.1B729417.CEE440B6.IP)
[13:11:27] *** Joins: ghrust (ghrust@C8693FCB.6A2AE50.F3114085.IP)
[13:11:27] <ghrust> 01[13rust01] 15bors pushed 0 new commits to 06auto: 02http://git.io/xPJl6w
[13:11:27] *** Parts: ghrust (ghrust@C8693FCB.6A2AE50.F3114085.IP) ()
[13:11:29] *** Joins: ghrust (ghrust@2EE61FCC.6A2AE50.F3114085.IP)
[13:11:30] <ghrust> 01[13rust01] 15bors pushed 2 new commits to 06auto: 02http://git.io/aLfzEA
[13:11:30] <ghrust> 13rust/06auto 145eb79ad 15Brandon Sanderson: Clarify use_decl module resolution docs.
[13:11:30] <ghrust> 13rust/06auto 1487869d8 15bors: auto merge of #8639 : singingboyo/rust/use-decl-doc, r=alexcrichton...
[13:11:30] *** Parts: ghrust (ghrust@2EE61FCC.6A2AE50.F3114085.IP) ()
[13:12:25] *** Joins: infynyxx (infynyxx@moz-E95B370B.nyc.res.rr.com)
[13:13:14] *** Quits: pnkfelix (pnkfelix@87C1F78E.1DE10CA8.D8E68FF6.IP) (Quit: Leaving.)
[13:13:33] *** Joins: Blub\w (wry@7E3BB9D.71150E1A.237AE2BA.IP)
[13:14:09] *** Joins: pnkfelix (pnkfelix@87C1F78E.1DE10CA8.D8E68FF6.IP)
[13:16:42] *** Quits: lenstr (lenstr@AF8EB999.6049B16A.85938D85.IP) (Client exited)
[13:18:55] *** sankha93 is now known as sankha93|afk
[13:20:27] *** Joins: nsf (nsf@moz-EEF3238A.convex.ru)
[13:20:54] *** Joins: jviereck (Adium@moz-C7B1E34.dip0.t-ipconnect.de)
[13:23:29] *** Quits: rovar_ (rovar@moz-203658CB.nycmny.fios.verizon.net) (Ping timeout)
[13:23:43] <maik> do we have a thread safe println?
[13:23:51] *** Joins: rovar (rovar@moz-203658CB.nycmny.fios.verizon.net)
[13:24:28] *** Quits: Kruppe (user@moz-E150F49F.cpe.net.cable.rogers.com) (Client exited)
[13:24:37] <cmr> maik: no, console io is inherently racy. push a newline to your string, print it, and pop the newline off.
[13:25:36] *** Quits: jfbk (textual@moz-EEA9CFB3.nyc.res.rr.com) (Quit: My MacBook has gone to sleep. ZZZzzzâ€¦)
[13:26:51] <maik> cmr, thanks it works
[13:29:16] *** Joins: jorendorff (jorendorff@moz-2F32ACA3.hsd1.tn.comcast.net)
[13:30:35] <bjz_> maik: the fix is slowly making its way up the queue: http://buildbot.rust-lang.org/bors/bors.html
[13:31:17] <bjz_> maik: I need to add a way to specify what extensions you want to use
[13:31:38] <maik> bjz_, oh nice thanks for the heads up
[13:31:39] <bjz_> maik: atm I generate the full spec
[13:31:41] *** Quits: jviereck (Adium@moz-C7B1E34.dip0.t-ipconnect.de) (Quit: Leaving.)
[13:32:11] <bjz_> maik: ie. a 1.4 mb file (that's with macros to reduce code duplication)
[13:33:04] * cmr gives it a little help
[13:33:11] <maik> bjz_, oh yeah the xml files contain everything right?
[13:33:19] <bjz_> yup
[13:33:27] <adridu59> rusti: for i in range(0, 5) { printf!("%d ", i) }
[13:33:28] -rusti- 0 1 2 3 4 ()
[13:34:31] *** Quits: josh (josh@moz-D3896A24.dhcp.dlth.mn.charter.com) (Quit: josh)
[13:35:03] *** Joins: reyre (reyre@916689EC.33EE9F8A.1139E686.IP)
[13:35:16] * maik checks the xml source
[13:35:19] <adridu59> ok I commited a pull request for that range doc thing https://github.com/mozilla/rust/pull/8682
[13:35:22] <bjz_> maik: but it comes with a thing at the end that specifies the enums/commands/types that each extension requires
[13:35:24] *** Joins: sigma (sigma@51C589B3.EF2694B5.DFAC6AA7.IP)
[13:37:05] *** Joins: engla (engla@moz-DBD1D96E.cust.bredbandsbolaget.se)
[13:37:57] *** Joins: Earnestly (earnest@B0BDF733.8FDE20A.5411983D.IP)
[13:37:59] <maik> bjz_, that may sound stupid but can't you just parse with a gl version? seems like they used "<feature api="gl" name="GL_VERSION_4_3" number="4.3">"
[13:38:14] *** Joins: josedonizetti (josedonize@DF22210B.35D9DDB.8EF76F75.IP)
[13:39:22] *** Joins: sammykim_ (Mibbit@48AEBDE2.ACF655DA.97B9B372.IP)
[13:39:33] *** Joins: chozza (Mibbit@DDF2FC12.F553F9.14D5B978.IP)
[13:39:47] <bjz_> maik: there are also vendor extensions
[13:39:56] *** Joins: bytewise (bytewise@moz-4A801D04.unitymediagroup.de)
[13:40:03] <bjz_> maik: that are specific to certain cards/drivers
[13:40:52] *** Joins: cubic (cubic@moz-FE5AD6C7.mc.videotron.ca)
[13:42:48] *** Quits: richard|s (mindginati@moz-D2CEE0E6.dyn.cust.vf.net.nz) (Quit: zzZZZ)
[13:43:52] *** Quits: pnkfelix (pnkfelix@87C1F78E.1DE10CA8.D8E68FF6.IP) (Quit: Leaving.)
[13:44:05] <maik> bjz_, not sure.. but I have very little experience in that area of opengl :(
[13:49:09] *** Quits: azita (Azita@moz-C1FB2A8.hsd1.ca.comcast.net) (Quit: azita)
[14:01:29] *** Joins: ghrust (ghrust@2EE61FCC.6A2AE50.F3114085.IP)
[14:01:29] <ghrust> 01[13rust01] 15bors 04force-pushed 06auto from 1487869d8 to 143f6f79b: 02http://git.io/N3iJvQ
[14:01:29] *** Parts: ghrust (ghrust@2EE61FCC.6A2AE50.F3114085.IP) ()
[14:01:31] *** Joins: ghrust (ghrust@24260B07.6A2AE50.F3114085.IP)
[14:01:31] <ghrust> 01[13rust01] 15bors pushed 4 new commits to 06auto: 02http://git.io/YAHVwg
[14:01:31] <ghrust> 13rust/06auto 1494a084a 15Niko Matsakis: Fix crash(!) by using the *Rust fn type* not the extern fn type...
[14:01:31] <ghrust> 13rust/06auto 1482a9abb 15Niko Matsakis: Change type of extern fns from `*u8` to `extern "ABI" fn`...
[14:01:32] <ghrust> 13rust/06auto 14ffb6404 15Niko Matsakis: Adjust callbacks in the libraries for the new type of extern fns...
[14:01:34] *** Parts: ghrust (ghrust@24260B07.6A2AE50.F3114085.IP) ()
[14:05:34] *** Quits: tiffany (kawaii@moz-EB8B0C08.dhcp.embarqhsd.net) (Ping timeout)
[14:06:30] *** Joins: lenstr (lenstr@AF8EB999.6049B16A.85938D85.IP)
[14:12:45] <maik> any idea how I can avoid this? "cannot implement a destructor on a structure with type parameters"
[14:14:46] *** Joins: mindcat (mindcat@2DE37087.C6D6E0F5.857BDFA9.IP)
[14:15:01] *** sankha93|afk is now known as sankha93
[14:15:29] *** Joins: kvark (Mibbit@9A8A5739.49975FB2.AE2D72A6.IP)
[14:16:42] <kvark> wow 281 rust-lover here... impressing!
[14:17:08] <engla> yes
[14:17:23] <kvark> Actually, I just wanted to ask for basics about bare Rust on ARMv7. I.e.: is it possible? what do I need to know/read to do it?
[14:17:42] <engla> maik: there is an override for that called #[unsafe_destructor] I think, but there are some broken things with generic drop
[14:18:01] <kvark> (have this nasty idea on my head to write Lego NXT code with Rust...)
[14:19:24] <maik> engla, what if I want a safe destructor with type parameter? I tried to do impl < T: Drop> Drop for Foo<T> but it didn't help
[14:19:33] *** Joins: erickt (Adium@49C4075F.3AC15C18.2321E71E.IP)
[14:21:21] <engla> here's a bug https://github.com/mozilla/rust/issues/6971
[14:22:02] *** Quits: erickt (Adium@49C4075F.3AC15C18.2321E71E.IP) (Quit: Leaving.)
[14:24:26] <maik> bjz_, it is though!
[14:24:29] *** Joins: josh (josh@moz-6ACE5AE6.reserved.cptelecom.net)
[14:26:39] *** Quits: lenstr (lenstr@AF8EB999.6049B16A.85938D85.IP) (Client exited)
[14:26:46] <maik> when ghrust is pushing commit to "auto" does this also mean they are in master now?
[14:27:11] <maik> or is "auto" for testing?
[14:28:01] <Ms2ger> I believe auto is for testing
[14:32:50] <engla> auto is merged into master if it passes all the integration tests
[14:34:58] *** Joins: pnkfelix (pnkfelix@87C1F78E.1DE10CA8.D8E68FF6.IP)
[14:38:18] *** Quits: jorendorff (jorendorff@moz-2F32ACA3.hsd1.tn.comcast.net) (Quit: jorendorff)
[14:38:25] *** Quits: jesse99 (jesse99@moz-F226420.hsd1.wa.comcast.net) (Quit: jesse99)
[14:39:10] *** Joins: tcr (tcr@D26BCFC9.C2203064.EDCE493E.IP)
[14:40:15] <mindcat> rusti: extern mod std; use std::int; let a = "1"; int.from_str(a);
[14:40:15] -rusti- <anon>:5:9: 5:24 error: "extern mod" declarations are not allowed here
[14:40:15] -rusti- <anon>:5          extern mod std; use std::int; let a = "1"; int.from_str(a);
[14:40:15] -rusti-                   ^~~~~~~~~~~~~~~
[14:40:16] -rusti- error: aborting due to previous error
[14:40:16] -rusti- application terminated with error code 101
[14:40:35] <mindcat> rusti: let a = "1"; int.from_str(a);
[14:40:35] -rusti- <anon>:5:22: 5:25 error: unresolved name `int`. Did you mean `a`?
[14:40:35] -rusti- <anon>:5          let a = "1"; int.from_str(a);
[14:40:36] -rusti-                                ^~~
[14:40:36] -rusti- error: aborting due to previous error
[14:40:36] -rusti- application terminated with error code 101
[14:40:55] <mindcat> rusti: use core::int; let a = "1"; int.from_str(a);
[14:40:58] -rusti- pastebinned 8 lines of output: http://ix.io/7u0
[14:41:01] *** Quits: tcr (tcr@D26BCFC9.C2203064.EDCE493E.IP) (Ping timeout)
[14:41:29] <mindcat> rusti: use std::int; let a = "1"; int.from_str(a);
[14:41:30] -rusti- <anon>:5:36: 5:39 error: unresolved name `int`. Did you mean `a`?
[14:41:30] -rusti- <anon>:5          use std::int; let a = "1"; int.from_str(a);
[14:41:30] -rusti-                                              ^~~
[14:41:30] -rusti- error: aborting due to previous error
[14:41:30] -rusti- application terminated with error code 101
[14:41:43] <mindcat> rusti: use std::int; let a = "1"; int::from_str(a);
[14:41:44] -rusti- ()
[14:41:51] <mindcat> Ouch
[14:42:02] <adridu59> mindcat: use the "as" operator
[14:42:27] <kvark> rusti: use std::int; let a = "1"; int::from_str(a)
[14:42:28] -rusti- Some(1)
[14:42:29] *** Joins: tcr (tcr@D26BCFC9.C2203064.EDCE493E.IP)
[14:42:38] <adridu59> let a ="1"; let b = a as int;
[14:42:44] <adridu59> rusti: let a ="1"; let b = a as int;
[14:42:45] -rusti- <anon>:5:29: 5:37 error: non-scalar cast: `&'static str` as `int`
[14:42:45] -rusti- <anon>:5          let a ="1"; let b = a as int;
[14:42:45] -rusti-                                       ^~~~~~~~
[14:42:45] -rusti- error: aborting due to previous error
[14:42:45] -rusti- application terminated with error code 101
[14:42:53] <adridu59> haha my bad
[14:43:33] <kvark> that would be very JS-like. I'm glad it doesn't work this way :)
[14:43:40] *** Quits: Florob (Florob@moz-39532932.de) (Client exited)
[14:44:20] <adridu59> avoids derp is what you mean? probably so
[14:44:45] *** Joins: Scriptor (historium@moz-E06F46F0.corp.bitshelter.com)
[14:46:00] *** Joins: jorendorff (jorendorff@moz-2F32ACA3.hsd1.tn.comcast.net)
[14:46:56] <kvark> Guys, so really no ideas on compiling for ARMv7? I was under impression that Samsung made it work, but couldn't find any info...
[14:47:20] *** Joins: jviereck (Adium@moz-AF73A9F4.dip0.t-ipconnect.de)
[14:48:01] <maik> rusti: let a ="1"; let b = int::from_str(a)
[14:48:02] -rusti- <anon>:6:4: 6:5 error: expected `;` but found `}`
[14:48:02] -rusti- <anon>:6     };
[14:48:02] -rusti-              ^
[14:48:02] -rusti- application terminated with error code 101
[14:48:11] <maik> rusti: let a ="1"; let b = int::from_str(a);
[14:48:13] -rusti- pastebinned 11 lines of output: http://ix.io/7u1
[14:48:26] *** Quits: jorendorff (jorendorff@moz-2F32ACA3.hsd1.tn.comcast.net) (Ping timeout)
[14:48:26] <maik> rusti: let a ="1"; let b = std::int::from_str(a);
[14:48:27] -rusti- <anon>:5:25: 5:26 warning: unused variable: `b` [-W unused-variable (default)]
[14:48:28] -rusti- <anon>:5          let a ="1"; let b = std::int::from_str(a);
[14:48:28] -rusti-                                   ^
[14:48:28] -rusti- ()
[14:48:35] <maik> rusti: let a ="1"; let b = std::int::from_str(a); b
[14:48:36] -rusti- Some(1)
[14:49:15] <maik> adridu59, ^
[14:49:42] <adridu59> :)
[14:53:05] <mindcat> rusti: use std::int; let a = "1"; print(int::from_str(a));
[14:53:05] -rusti- <anon>:5:42: 5:59 error: mismatched types: expected `&str` but found `std::option::Option<int>` (expected &str but found enum std::option::Option)
[14:53:06] -rusti- <anon>:5          use std::int; let a = "1"; print(int::from_str(a));
[14:53:06] -rusti-                                                    ^~~~~~~~~~~~~~~~~
[14:53:06] -rusti- error: aborting due to previous error
[14:53:06] -rusti- application terminated with error code 101
[14:54:20] *** Joins: nano (nano@moz-74CAD1CA.superkabel.de)
[14:54:58] <adridu59> rusti: use std::int; let a = "1"; printf!(int::from_str(a));
[14:54:59] -rusti- Some(1)()
[14:55:11] <adridu59> mindcat ^
[14:55:12] *** Joins: SiegeLord (sl@moz-CAF07B4C.hsd1.ma.comcast.net)
[14:55:33] <adridu59> print() is only for strings
[14:55:51] <kvark> mindcat: you seem to be testing very basic stuff. Please consider doing it privately with "rusti" if you don't have rust locally. I.e. open a personal message channel with "rusti". (note that I don't represent the community here, just my position)
[14:56:12] <mindcat> adridu59, kvark: ok.. 
[14:57:12] <adridu59> I use http://www.compileonline.com/compile_rust_online.php personally
[14:57:33] <adridu59> but it's on release 0.7, rusti is on master isn't it?
[14:57:42] <adridu59> I mean compiled regularly
[14:58:05] <kvark> adridu59: nice link, thanks!
[14:58:32] <engla> just use /query or similar to priv msg rusti
[15:01:11] <adridu59> guys, is there a var.isDefined() sort of thing in rust?
[15:01:34] <adridu59> I have a function with optional parameter and I want different behavior if that parameter is passed
[15:02:34] *** Joins: dherman (dherman@moz-6CA476B1.hsd1.ca.comcast.net)
[15:02:34] *** ChanServ sets mode: +o dherman
[15:02:35] <kvark> I didn't know rust have optional parameters... You could wrap yours in Option<T> any time, and then match it.
[15:03:13] *** Joins: dcrewi (david@moz-AB8667CE.gyrae.net)
[15:03:41] *** Joins: andrew-d (andrew@moz-F84C8FD7.hm.shawcable.net)
[15:05:12] <andrew-d> Hi there.  I've run into the "too many open files" error on Mac OS X when running 'make check', but fixed it with some fiddling with sysctl/launchd.  Was wondering if it'd be helpful for others if I shared the details somewhere?
[15:05:15] <adridu59> I see, a match statement with _
[15:05:37] *** Joins: dan_johnsin (dan_johnsi@6902762D.11B071D.FB9A45AF.IP)
[15:05:47] <adridu59> @andrew_d: rust wiki https://github.com/mozilla/rust/wiki/_pages
[15:05:51] <adridu59> https://github.com/mozilla/rust/wiki
[15:05:59] <adridu59> andrew_d
[15:06:07] <adridu59> andrew-d derp
[15:06:46] <klutzy> andrew-d: sounds like https://github.com/mozilla/rust/issues/7772 again
[15:07:12] <andrew-d> Yeah, that looked like the problem
[15:07:23] <andrew-d> I just raised the number of possible open files on my system to a "large number"
[15:07:26] <andrew-d> And it compiled fine
[15:07:39] <adridu59> klutzy there has been a commit revert
[15:07:44] <adridu59> in this issue
[15:08:09] <pnkfelix> andrew-d: such a note would probably belong under Nodes (https://github.com/mozilla/rust/wiki/Notes) somewhere, perhaps Getting Started ( https://github.com/mozilla/rust/wiki/Note-getting-started-developing-Rust )
[15:08:18] <pnkfelix> andrew-d: s/Nodes/Notes/
[15:08:21] <andrew-d> Yeah, I'm adding a section under "OS X" there.
[15:09:18] <pnkfelix> andrew-d: another option could be to put the note in: https://github.com/mozilla/rust/wiki/Note-testsuite   (or make a new page dedicated to OS X specific notes/issues)
[15:09:46] <pnkfelix> andrew-d: (I mainly mention these alternatives because Note-getting-started seemed like it might be getting a bit long...)
[15:10:03] <andrew-d> I think I'll put it in "getting started" for now, since it seems like more people will read it
[15:11:24] *** Quits: chozza (Mibbit@DDF2FC12.F553F9.14D5B978.IP) (Quit: http://www.mibbit.com ajax IRC Client)
[15:13:51] *** Quits: tgummerer (tgummerer@moz-3CF4EF2C.unibz.it) (Ping timeout)
[15:17:02] <andrew-d> OK, added.
[15:17:18] *** erickt_ is now known as erickt
[15:20:29] *** Quits: ChrisMorgan (chris@moz-6AC741CA.static.tpgi.com.au) (Ping timeout)
[15:20:32] *** Quits: dew (Instantbir@moz-D2FA52B6.static.stls.mo.charter.com) (Ping timeout)
[15:20:38] *** Joins: dew (Instantbir@moz-D2FA52B6.static.stls.mo.charter.com)
[15:21:01] <maik> do you think it was a good idea to use @ for as patterns? I just wrote a@~"Hello World" looks a bit funky
[15:21:31] *** Joins: ghrust (ghrust@79968228.6A2AE50.F3114085.IP)
[15:21:31] <ghrust> 01[13rust01] 15bors merged 06auto into 06master: 02http://git.io/YAHVwg
[15:21:31] *** Parts: ghrust (ghrust@79968228.6A2AE50.F3114085.IP) ()
[15:21:51] <maik> bjz_, okay now it is in master :)
[15:22:00] *** Joins: huseby (huseby@19BD73A1.5D8BCA3A.A0C1B52F.IP)
[15:23:46] <Ms2ger> "do you think it was a good idea to use @..."
[15:23:48] <Ms2ger> No ;)
[15:24:14] *** Quits: Jesin (Jessin_@moz-5654D37.washdc.fios.verizon.net) (Quit: Leaving)
[15:24:27] <maik> Ms2ger, @ has two meanings :)
[15:24:31] *** Joins: dave1629 (dave@moz-17578A1A.hsd1.va.comcast.net)
[15:24:39] <Ms2ger> Oh, that @
[15:24:55] <Ms2ger> Yeah, that's weird
[15:25:02] <SimonSapin> maik: does a @ ~"Hello World" look better?
[15:25:30] <maik> SimonSapin, not for me :D
[15:25:40] *** Quits: sammykim_ (Mibbit@48AEBDE2.ACF655DA.97B9B372.IP) (Quit: http://www.mibbit.com ajax IRC Client)
[15:26:38] *** Quits: engla (engla@moz-DBD1D96E.cust.bredbandsbolaget.se) (Ping timeout)
[15:28:09] *** Quits: maik (maik___@moz-BEACDBF.dip0.t-ipconnect.de) (Connection reset by peer)
[15:29:04] *** Joins: eholk (eholk@moz-9F56BC82.hsd1.wa.comcast.net)
[15:29:07] *** Joins: lbergstrom (Adium@moz-5D8E4B14.lightspeed.cicril.sbcglobal.net)
[15:31:26] *** Joins: boredomist (user@moz-63CF9F31.res-cmts.sesp.ptd.net)
[15:31:31] *** Joins: ghrust (ghrust@C8693FCB.6A2AE50.F3114085.IP)
[15:31:31] <ghrust> 01[13rust01] 15bors pushed 0 new commits to 06auto: 02http://git.io/H3N7Ww
[15:31:31] *** Parts: ghrust (ghrust@C8693FCB.6A2AE50.F3114085.IP) ()
[15:31:33] *** Joins: ghrust (ghrust@DE823A67.6A2AE50.F3114085.IP)
[15:31:33] <ghrust> 01[13rust01] 15bors pushed 3 new commits to 06auto: 02http://git.io/GlatQQ
[15:31:33] <ghrust> 13rust/06auto 145e87f2f 15Seo Sanghyeon: Android: Change directory before running tests
[15:31:33] <ghrust> 13rust/06auto 140276fe4 15Seo Sanghyeon: Android: Run benchmarks and copy metrics
[15:31:33] <ghrust> 13rust/06auto 145003f60 15bors: auto merge of #8642 : sanxiyn/rust/arm-test, r=catamorphism...
[15:31:35] *** Parts: ghrust (ghrust@DE823A67.6A2AE50.F3114085.IP) ()
[15:34:31] *** Joins: Jesin (Jessin_@moz-5654D37.washdc.fios.verizon.net)
[15:34:35] <mindcat> how to continue or skip this time loop?
[15:35:20] *** Quits: fredy (fredy@moz-E7647C0E.vm.okeanos.grnet.gr) (Ping timeout)
[15:35:49] *** Quits: fhahn (flo@55AA4F49.9CEE5B55.C34545D8.IP) (Quit: leaving)
[15:37:25] <pnkfelix> mindcat: the `loop;` statement will act much like a continue statement from other languages.  i.e. loop { â€¦ stuff â€¦ loop; stuff-that-wont-run â€¦ }
[15:37:51] *** Quits: jviereck (Adium@moz-AF73A9F4.dip0.t-ipconnect.de) (Quit: Leaving.)
[15:38:29] <pnkfelix> mindcat: note I'm distinguishing between the opening `loop { â€¦ }` that defines the whole loop, versus the interior `loop;` that causes it to start a new iteration.
[15:38:29] *** Joins: graydon (graydon@moz-F14EE0DB.cable.teksavvy.com)
[15:38:29] *** ChanServ sets mode: +qo graydon graydon
[15:39:18] * Ms2ger has always wondered why rust didn't use continue for that
[15:39:56] <bjz_> maybe it was during the 'four letter keyword' stage
[15:40:04] <pnkfelix> Ms2ger: I think its probably a mix of "No, not another keyword!!  You couldn't!!!" and also "short keywords good, long keywords bad."
[15:40:48] <bjz_> I remember vaguely at the time I started using rust they were debating alt/match and ret/return
[15:40:58] <Ms2ger> pnkfelix, I tend to follow the "short keywords meh, long keywords meh, understandable keywords good" philosophy :)
[15:42:09] *** Quits: erickt (etryzelaar@8C9ECD8F.3A598286.F12515B4.IP) (Input/output error)
[15:42:52] * fread2281 thinks loop actually more understandable, but just unusual
[15:43:10] *** Joins: azita (Azita@moz-C1FB2A8.hsd1.ca.comcast.net)
[15:43:22] *** Quits: eholk (eholk@moz-9F56BC82.hsd1.wa.comcast.net) (Quit: eholk)
[15:45:05] *** Joins: jdm (jdm@97DF0582.DEAB171B.971E19F6.IP)
[15:45:06] *** Joins: jorendorff (jorendorff@moz-1747FB68.hsd1.tn.comcast.net)
[15:45:42] *** Joins: erickt (etryzelaar@8C9ECD8F.3A598286.F12515B4.IP)
[15:46:18] *** Joins: sp3d (a@moz-6F12212B.fidnet.com)
[15:48:42] *** Quits: azita (Azita@moz-C1FB2A8.hsd1.ca.comcast.net) (Quit: azita)
[15:50:23] *** Joins: lenstr (lenstr@AF8EB999.6049B16A.85938D85.IP)
[15:51:09] *** Joins: jeaye (Jeaye@moz-FD505E54.hsd1.ca.comcast.net)
[15:51:46] *** Quits: infynyxx (infynyxx@moz-E95B370B.nyc.res.rr.com) (Client exited)
[15:53:03] *** Quits: eagen (eagen@8737942B.7A99C13A.B7961A98.IP) (Quit: Leaving)
[15:53:19] <toddaaro> rusti: 1 << 20
[15:53:20] -rusti- 1048576
[15:53:27] <toddaaro> rusti: 1 << 18
[15:53:28] -rusti- 262144
[15:53:30] <toddaaro> rusti: 1 << 17
[15:53:31] -rusti- 131072
[15:53:39] <adridu59> rusti: 1 << 2
[15:53:40] -rusti- 4
[15:54:38] <adridu59> interesting, never used those bitshifts
[15:55:52] <toddaaro> I've been using them for log2 based sizing of arrays
[15:58:04] *** Joins: maik (maik___@moz-BEACDBF.dip0.t-ipconnect.de)
[15:58:20] <erickt> graydon: ping
[16:01:48] *** Joins: infynyxx (infynyxx@moz-E95B370B.nyc.res.rr.com)
[16:02:22] *** Joins: engla (engla@moz-DBD1D96E.cust.bredbandsbolaget.se)
[16:02:28] *** Joins: tgummerer (tgummerer@51D3B54.FEF996EA.EA6FEF3D.IP)
[16:02:44] <SimonSapin> Is parent:: in a path not what I think it is? Did it use to?
[16:04:16] *** Joins: Sergio965 (sergiobz@moz-22323788.dyn.mit.edu)
[16:08:58] *** kimundi is now known as zz_kimundi
[16:10:01] *** Quits: relistan (relistan@A7E4EF66.4C1F25E9.4BA0249.IP) (Quit: relistan)
[16:12:54] *** Joins: vodik (simon@moz-396533B6.dsl.bell.ca)
[16:14:32] *** Joins: glennsl (textual@moz-5D7B804F.getinternet.no)
[16:16:38] *** Quits: infynyxx (infynyxx@moz-E95B370B.nyc.res.rr.com) (Client exited)
[16:16:39] <acrichto> SimonSapin: if you want the parent module you can use `super::`
[16:17:41] *** Quits: maik (maik___@moz-BEACDBF.dip0.t-ipconnect.de) (Ping timeout)
[16:17:52] *** zz_kimundi is now known as kimundi
[16:21:39] <adridu59> "rusti"
[16:21:51] *** Quits: doomlord (doomlod@moz-13E69BC8.range86-180.btcentralplus.com) (Ping timeout)
[16:22:38] *** Joins: int3_ (int3_@moz-ABE52D50.hsd1.ca.comcast.net)
[16:22:54] *** Joins: maik (maik___@moz-BEACDBF.dip0.t-ipconnect.de)
[16:24:06] *** Quits: jensnockert (jensnocker@moz-8BE55278.customer.t3.se) (Input/output error)
[16:24:41] <SimonSapin> acrichto: ah, thatâ€™s it. thanks
[16:27:58] <graydon> erickt: pong
[16:28:05] <graydon> triage meeting in 3 minutes :(
[16:28:09] <adridu59> is there some recent downloadable rust snapshots?
[16:28:22] <graydon> adridu59: they'll be in  your build dir, in the dl/ directory
[16:28:26] <erickt> graydon: oh ok, ping me when you get back
[16:28:27] <graydon> those are stage0
[16:28:51] <erickt> graydon: I was going to continue the serialization conversation
[16:29:14] <adridu59> yup but can I download directly a snapshot or current master branch from the web (I don't want to compile it)
[16:29:26] <adridu59> of*
[16:29:39] <graydon> there are packages for various distributions
[16:31:25] <adridu59> I would like to have a  recent win32 snapshot, but where are they located?
[16:31:31] <adridu59> on the rust server
[16:31:49] <Ms2ger> Rust builds on windows?
[16:31:55] <adridu59> yea
[16:33:12] *** Joins: azita (Azita@moz-BBE3ABD.mv.mozilla.com)
[16:33:31] <SimonSapin> I believe that rustc is stuck in an infinite loop when building servo with my latest patch. How can I debug this?
[16:34:29] <pnkfelix> SimonSapin: use a debug build, and RUST_LOG ?
[16:34:50] <pnkfelix> SimonSapin: and/or run a debug build under gdb, and hit Ctrl-C ?
[16:35:10] *** Joins: lmandel (lmandel@moz-BE33DA21.fw1.sfo1.mozilla.net)
[16:35:12] *** Joins: echristo (echristo@DCF57675.D6CCE4AE.77834EAA.IP)
[16:36:04] <graydon> erickt: will do
[16:36:27] <SimonSapin> pnkfelix: debug build of rust, I assume? Is it a configure flag?
[16:36:40] <pnkfelix> SimonSapin: Yeah, configure --enable-debug
[16:36:47] *** Quits: adridu59 (Mibbit@moz-6C393FDD.rev.numericable.fr) (Quit: http://www.mibbit.com ajax IRC Client)
[16:37:07] *** Quits: a__ (a__@moz-250D9B4.nycmny.fios.verizon.net) (Ping timeout)
[16:37:23] <pnkfelix> SimonSapin: you can (and should) keep using â€”enable-optimize along with it.
[16:37:53] <SimonSapin> thanks pnkfelix, Iâ€™ll try it
[16:37:57] *** Joins: tjc (tjc@moz-6EB4E533.dsl.tsoft.com)
[16:37:57] *** ChanServ sets mode: +o tjc
[16:38:14] *** sankha93 is now known as sankha93|afk
[16:38:51] *** Joins: brson (brson@moz-BBE3ABD.mv.mozilla.com)
[16:38:52] *** ChanServ sets mode: +o brson
[16:39:43] *** Joins: bent (chatzilla@moz-BE33DA21.fw1.sfo1.mozilla.net)
[16:42:15] <toddaaro> what is the way to get the size of a rust type?
[16:42:36] <pnkfelix> toddaaro: one sec, I have this somehwere
[16:43:21] <toddaaro> rusti: unsafe { let x = std::unstable::atomics::AtomicPtr::new::<uint>(120); std::unstable::raw::size_of(x) }
[16:43:22] -rusti- <anon>:5:79: 5:106 error: unresolved name `std::unstable::raw::size_of`.
[16:43:22] -rusti- <anon>:5          unsafe { let x = std::unstable::atomics::AtomicPtr::new::<uint>(120); std::unstable::raw::size_of(x) }
[16:43:22] -rusti-                                                                                         ^~~~~~~~~~~~~~~~~~~~~~~~~~~
[16:43:22] -rusti- error: aborting due to previous error
[16:43:22] -rusti- application terminated with error code 101
[16:44:01] *** Quits: dave1629 (dave@moz-17578A1A.hsd1.va.comcast.net) (Quit: dave1629)
[16:44:46] <pnkfelix> toddaaro: You want sys::size_of::<T>()
[16:45:01] <pnkfelix> toddaaro: see e.g. https://github.com/mozilla/rust/issues/6320
[16:45:52] <toddaaro> rusti: unsafe { let x = std::unstable::atomics::AtomicPtr::new::<uint>(120); std::size_of::<AtomicPtr<*uint>() }
[16:45:53] -rusti- <anon>:5:110: 5:111 error: expected `,` but found `(`
[16:45:53] -rusti- <anon>:5          unsafe { let x = std::unstable::atomics::AtomicPtr::new::<uint>(120); std::size_of::<AtomicPtr<*uint>() }
[16:45:53] -rusti-                                                                                                                        ^
[16:45:53] -rusti- application terminated with error code 101
[16:45:59] <toddaaro> rusti: unsafe { let x = std::unstable::atomics::AtomicPtr::new::<uint>(120); std::size_of::<AtomicPtr<~uint>() }
[16:45:59] -rusti- <anon>:5:110: 5:111 error: expected `,` but found `(`
[16:45:59] -rusti- <anon>:5          unsafe { let x = std::unstable::atomics::AtomicPtr::new::<uint>(120); std::size_of::<AtomicPtr<~uint>() }
[16:45:59] -rusti-                                                                                                                        ^
[16:46:00] -rusti- application terminated with error code 101
[16:46:03] <toddaaro> rusti: unsafe { let x = std::unstable::atomics::AtomicPtr::new::<uint>(120); std::size_of::<AtomicPtr<uint>() }
[16:46:03] -rusti- <anon>:5:109: 5:110 error: expected `,` but found `(`
[16:46:03] -rusti- <anon>:5          unsafe { let x = std::unstable::atomics::AtomicPtr::new::<uint>(120); std::size_of::<AtomicPtr<uint>() }
[16:46:06] -rusti-                                                                                                                       ^
[16:46:09] -rusti- application terminated with error code 101
[16:46:10] *** Joins: mihneadb (Mihnea@moz-BE33DA21.fw1.sfo1.mozilla.net)
[16:46:10] <engla> missing >
[16:46:19] <toddaaro> rusti: unsafe { let x = std::unstable::atomics::AtomicPtr::new::<uint>(120); std::size_of::<AtomicPtr<uint>>() }
[16:46:21] -rusti- pastebinned 11 lines of output: http://ix.io/7uf
[16:46:53] *** Quits: lenstr (lenstr@AF8EB999.6049B16A.85938D85.IP) (Client exited)
[16:46:57] <toddaaro> rusti: unsafe { std::size_of::<std::unstable::atomics::AtomicPtr<uint>>() }
[16:46:58] -rusti- <anon>:5:18: 5:73 error: unresolved name `std::size_of`.
[16:46:58] -rusti- <anon>:5          unsafe { std::size_of::<std::unstable::atomics::AtomicPtr<uint>>() }
[16:46:59] -rusti-                            ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
[16:46:59] -rusti- error: aborting due to previous error
[16:46:59] -rusti- application terminated with error code 101
[16:47:09] <toddaaro> rusti: unsafe { std::sys::size_of::<std::unstable::atomics::AtomicPtr<uint>>() }
[16:47:10] -rusti- <anon>:5:9: 5:82 warning: unnecessary `unsafe` block [-W unused-unsafe (default)]
[16:47:10] -rusti- <anon>:5          unsafe { std::sys::size_of::<std::unstable::atomics::AtomicPtr<uint>>() }
[16:47:10] -rusti-                   ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
[16:47:10] -rusti- 8
[16:47:15] <toddaaro> awesome, thanks
[16:47:35] *** Joins: spider-mario (spidermari@moz-81131DB6.fbx.proxad.net)
[16:48:01] *** Quits: huseby (huseby@19BD73A1.5D8BCA3A.A0C1B52F.IP) (Quit: Leaving)
[16:48:01] *** Quits: pnkfelix (pnkfelix@87C1F78E.1DE10CA8.D8E68FF6.IP) (Quit: Leaving.)
[16:48:43] *** Joins: huseby (huseby@19BD73A1.5D8BCA3A.A0C1B52F.IP)
[16:51:31] *** Joins: Florob (Florob@moz-39532932.de)
[16:51:32] *** Joins: ghrust (ghrust@DE823A67.6A2AE50.F3114085.IP)
[16:51:32] <ghrust> 01[13rust01] 15bors merged 06auto into 06master: 02http://git.io/GlatQQ
[16:51:32] *** Parts: ghrust (ghrust@DE823A67.6A2AE50.F3114085.IP) ()
[16:52:36] *** Quits: vodik (simon@moz-396533B6.dsl.bell.ca) (Quit: WeeChat 0.4.2-dev)
[16:53:57] *** Joins: fredy (fredy@moz-E7647C0E.vm.okeanos.grnet.gr)
[16:55:55] *** Joins: lenstr (lenstr@AF8EB999.6049B16A.85938D85.IP)
[16:56:20] *** Quits: dherman (dherman@moz-6CA476B1.hsd1.ca.comcast.net) (Quit: dherman)
[16:57:36] *** Joins: dherman (dherman@moz-6CA476B1.hsd1.ca.comcast.net)
[16:57:36] *** ChanServ sets mode: +o dherman
[16:57:40] *** Quits: brson (brson@moz-BBE3ABD.mv.mozilla.com) (Ping timeout)
[16:59:06] *** Joins: brson (brson@moz-BBE3ABD.mv.mozilla.com)
[16:59:06] *** ChanServ sets mode: +o brson
[17:00:26] *** Quits: lmandel (lmandel@moz-BE33DA21.fw1.sfo1.mozilla.net) (Quit: lmandel)
[17:00:34] *** Joins: adridu59 (Mibbit@moz-6C393FDD.rev.numericable.fr)
[17:00:53] *** Quits: brson (brson@moz-BBE3ABD.mv.mozilla.com) (Ping timeout)
[17:01:33] *** Joins: ghrust (ghrust@1E8607E8.6A2AE50.F3114085.IP)
[17:01:34] <ghrust> 01[13rust01] 15bors pushed 0 new commits to 06auto: 02http://git.io/7ORVPQ
[17:01:34] *** Parts: ghrust (ghrust@1E8607E8.6A2AE50.F3114085.IP) ()
[17:01:39] *** Quits: huseby (huseby@19BD73A1.5D8BCA3A.A0C1B52F.IP) (Quit: Leaving)
[17:02:45] *** Joins: azakai (alon@moz-BBE3ABD.mv.mozilla.com)
[17:04:03] *** Joins: brson (brson@moz-BBE3ABD.mv.mozilla.com)
[17:04:04] *** ChanServ sets mode: +o brson
[17:04:40] *** Quits: sp3d (a@moz-6F12212B.fidnet.com) (Ping timeout)
[17:05:42] *** Quits: heftig_ (heftig@moz-EA55FCAD.dip0.t-ipconnect.de) (Ping timeout)
[17:05:46] *** Joins: eschweic (Adium@moz-BBE3ABD.mv.mozilla.com)
[17:05:57] *** Joins: ozten (ozten@19BD73A1.5D8BCA3A.A0C1B52F.IP)
[17:06:08] *** Quits: fredy (fredy@moz-E7647C0E.vm.okeanos.grnet.gr) (Ping timeout)
[17:06:21] *** Joins: lmandel (lmandel@moz-BE33DA21.fw1.sfo1.mozilla.net)
[17:06:44] *** Joins: eagen (eagen@15B176CF.7A99C13A.B7961A98.IP)
[17:06:55] *** Quits: eagen (eagen@15B176CF.7A99C13A.B7961A98.IP) (Client exited)
[17:08:58] *** Quits: StarLight (StarLight@moz-B18EBA4B.dynamic.avangarddsl.ru) (Ping timeout)
[17:10:04] <olsonjeffery> brson: so ive got a big batch of updates.. all of those static actions (open, unlink, etc..) .. was just thinking of perhaps making functions on the top-level of the module?
[17:10:37] <olsonjeffery> as opposed to static methods on FileStream
[17:10:59] *** Joins: heftig (heftig@moz-EA55FCAD.dip0.t-ipconnect.de)
[17:11:05] *** Joins: pcwalton (pcwalton@moz-7B0110AD.mv.mozilla.com)
[17:11:05] *** ChanServ sets mode: +o pcwalton
[17:11:31] *** Joins: ghrust (ghrust@9C8B94D4.6A2AE50.F3114085.IP)
[17:11:32] <ghrust> 01[13rust01] 15bors pushed 3 new commits to 06auto: 02http://git.io/6N58sA
[17:11:32] <ghrust> 13rust/06auto 140bfaf82 15Alex Crichton: Upgrade libuv to the current master + our patches...
[17:11:32] <ghrust> 13rust/06auto 14003bf59 15Alex Crichton: Implement process bindings to libuv...
[17:11:32] <ghrust> 13rust/06auto 149eac86c 15bors: auto merge of #8645 : alexcrichton/rust/issue-6436-run-non-blocking, r=brson...
[17:11:34] *** Parts: ghrust (ghrust@9C8B94D4.6A2AE50.F3114085.IP) ()
[17:12:11] *** Joins: valenting (Thunderbir@8758046C.84D5EFD5.FB866788.IP)
[17:13:09] *** Quits: jez0990 (quassel@moz-3BA8545E.kimsufi.com) (Quit: http://quassel-irc.org - Chat comfortably. Anywhere.)
[17:13:23] *** Joins: StarLight (StarLight@moz-A3DC7D73.pppoe.avangarddsl.ru)
[17:13:30] *** Quits: cowboyd (cowboyd@1D8844A7.1B729417.CEE440B6.IP) (Client exited)
[17:13:53] *** Joins: jez0990 (quassel@moz-3BA8545E.kimsufi.com)
[17:14:16] <sully> uggggggh
[17:14:27] <sully> I need to set up that script that takes a picture every time there is a merge conflict
[17:14:49] <toddaaro> of you? or of it
[17:14:58] *** Quits: BitPuffin (quassel@moz-8370D1B9.bredband.comhem.se) (Client exited)
[17:15:18] <sully> of me
[17:15:21] <sully> grimacing
[17:15:28] *** Joins: fredy (fredy@moz-E7647C0E.vm.okeanos.grnet.gr)
[17:16:08] <toddaaro> the timelapse would be hilarious
[17:16:12] <toddaaro> if you had a bad rebase
[17:17:43] *** Quits: adridu59 (Mibbit@moz-6C393FDD.rev.numericable.fr) (Quit: http://www.mibbit.com ajax IRC Client)
[17:18:26] *** Joins: ecr (Thunderbir@moz-BBE3ABD.mv.mozilla.com)
[17:19:41] <maik> do we already have something like bind in c++11 that turns functions into partial functions?
[17:20:25] *** Quits: nano (nano@moz-74CAD1CA.superkabel.de) (Connection reset by peer)
[17:21:08] <toddaaro> maik: as in providing a few of the arguments and getting a closure out?
[17:21:11] <engla> sully: you probably know it already exists? :-)
[17:21:20] *** Joins: infynyxx (infynyxx@DB780A29.749BA1D.DCC373F0.IP)
[17:21:21] <maik> toddaaro, yes
[17:21:38] <sully> we had that, years ago
[17:21:39] <sully> and got rid of it
[17:21:42] <toddaaro> maik: I don't think so
[17:21:45] <toddaaro> that
[17:22:24] <maik> toddaaro, okay nice then I have something to experiment with
[17:22:54] *** Quits: Florob (Florob@moz-39532932.de) (Client exited)
[17:23:17] *** Quits: tcr (tcr@D26BCFC9.C2203064.EDCE493E.IP) (Client exited)
[17:23:19] *** Joins: Florob (Florob@moz-39532932.de)
[17:24:00] *** Quits: CarpNet (ac@moz-FD24B77.sohonet.co.uk) (Quit: Leaving)
[17:26:29] *** Quits: mihneadb (Mihnea@moz-BE33DA21.fw1.sfo1.mozilla.net) (Quit: Leaving)
[17:26:45] *** Joins: mihneadb (Mihnea@moz-BE33DA21.fw1.sfo1.mozilla.net)
[17:26:55] <Ralith> maik: 'partial function' usually means 'function which does not return a value for all possible inputs'
[17:27:37] *** Joins: infynyxx_ (infynyxx@moz-E95B370B.nyc.res.rr.com)
[17:28:23] *** Joins: eatkinson (eatkinson@moz-BBE3ABD.mv.mozilla.com)
[17:29:17] *** Quits: infynyxx_ (infynyxx@moz-E95B370B.nyc.res.rr.com) (Ping timeout)
[17:30:29] <maik> Ralith, I meant partial functions as in Haskell, I have no experience with dynamic languages
[17:30:44] *** Quits: Amanieu (amanieu@10FEE2FD.ECEF57A4.2CFD4520.IP) (Client exited)
[17:30:56] *** Joins: Amanieu (amanieu@10FEE2FD.ECEF57A4.2CFD4520.IP)
[17:31:27] *** Joins: ghrust (ghrust@C8693FCB.6A2AE50.F3114085.IP)
[17:31:28] <ghrust> 01[13rust01] 15bors 04force-pushed 06auto from 149eac86c to 145003f60: 02http://git.io/N3iJvQ
[17:31:28] *** Parts: ghrust (ghrust@C8693FCB.6A2AE50.F3114085.IP) ()
[17:31:28] *** Joins: ghrust (ghrust@C8693FCB.6A2AE50.F3114085.IP)
[17:31:28] <ghrust> 01[13rust01] 15bors pushed 2 new commits to 06auto: 02http://git.io/yccFoQ
[17:31:28] <ghrust> 13rust/06auto 143613c22 15Lindsey Kuper: Refactor type combining to use default methods.  Woohoo!...
[17:31:28] <ghrust> 13rust/06auto 14063a005 15bors: auto merge of #8669 : lkuper/rust/infer-refactor, r=nikomatsakis...
[17:31:29] *** Parts: ghrust (ghrust@C8693FCB.6A2AE50.F3114085.IP) ()
[17:31:30] <Ralith> maik: that is especially what 'partial function' means in haskell.
[17:32:02] <Ralith> maik: you're thinking of 'partially applied functions', which haskell also does not have.
[17:32:31] <jeaye> rusti: ||{ print("ok"); }();
[17:32:32] -rusti- <anon>:5:11: 5:30 error: expected function but found `()`
[17:32:32] -rusti- <anon>:5          ||{ print("ok"); }();
[17:32:32] -rusti-                     ^~~~~~~~~~~~~~~~~~~
[17:32:32] -rusti- error: aborting due to previous error
[17:32:33] -rusti- application terminated with error code 101
[17:32:43] <maik> Ralith, oh you are right, I am not an Haskller :)
[17:32:45] <jeaye> rusti: (||{ print("ok"); })();
[17:32:46] -rusti- ok()
[17:33:04] <jeaye> rusti: (||{ println("ok"); })();
[17:33:05] -rusti- ok
[17:33:05] -rusti- ()
[17:34:03] *** Joins: tcr (tcr@D26BCFC9.C2203064.EDCE493E.IP)
[17:35:37] *** Joins: cowboyd (cowboyd@moz-1BD02A1E.sw.biz.rr.com)
[17:37:50] *** Quits: tjc (tjc@moz-6EB4E533.dsl.tsoft.com) (Quit: zzzzzzzzzz)
[17:37:54] *** Joins: mschifer (Adium@moz-BBE3ABD.mv.mozilla.com)
[17:38:01] *** Quits: sk (sk@5FD88F96.77870B72.78DD174B.IP) (Input/output error)
[17:38:07] *** Quits: eschweic (Adium@moz-BBE3ABD.mv.mozilla.com) (Quit: Leaving.)
[17:40:10] <maik> Ralith, http://learnyouahaskell.com/higher-order-functions calls it partially applied functions
[17:41:13] <maik> toddaaro, do you think it is possible to create partially applied functions without an unsafe block in Rust?
[17:41:56] <Ralith> maik: it is in error.
[17:42:28] *** Quits: josh (josh@moz-6ACE5AE6.reserved.cptelecom.net) (Quit: josh)
[17:42:43] <toddaaro> maik: dunno, I haven't thought much about it
[17:42:53] *** Quits: kvark (Mibbit@9A8A5739.49975FB2.AE2D72A6.IP) (Quit: http://www.mibbit.com ajax IRC Client)
[17:42:56] <toddaaro> maik: depends what semantics and syntax you want I guess
[17:44:25] <toddaaro> rusti: unsafe { std::sys::nonzero_size_of::<std::unstable::atomics::AtomicPtr<T>>() }
[17:44:35] -rusti- pastebinned 8 lines of output: http://ix.io/7ug
[17:45:03] <toddaaro> rusti: unsafe { std::sys::nonzero_size_of::<std::unstable::atomics::AtomicPtr<uint>>() }
[17:45:04] -rusti- <anon>:5:9: 5:90 warning: unnecessary `unsafe` block [-W unused-unsafe (default)]
[17:45:04] -rusti- <anon>:5          unsafe { std::sys::nonzero_size_of::<std::unstable::atomics::AtomicPtr<uint>>() }
[17:45:05] -rusti-                   ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
[17:45:05] -rusti- 8
[17:45:06] <ecr> maik: you might be able to make a macro that could partially apply a function
[17:45:23] <ecr> I don't think you would need unsafe at all.
[17:45:31] <pcwalton> wrote the code for lazy-loading inherent impls
[17:45:38] <pcwalton> now to debug it
[17:45:43] *** Joins: sp3d (a@moz-6F12212B.fidnet.com)
[17:45:45] <toddaaro> rusti: struct Foo { x: uint, y: uint } std::sys::nonzero_size_of::<std::unstable::atomics::AtomicPtr<Foo>>()
[17:45:46] -rusti- 8
[17:45:50] <pcwalton> should be able to do it for non-inherent impls too although that's trickier
[17:46:40] <toddaaro> does an atomic ptr need to be initialized to use?
[17:46:43] <maik> ecr, yeah I was trying it without a macro and I don't find a way to do it.
[17:46:49] <toddaaro> or can I just take 8 bytes of memory and transmute then load/store?
[17:47:01] <maik> ecr, I try it with a macro now
[17:47:02] *** Quits: SiegeLord (sl@moz-CAF07B4C.hsd1.ma.comcast.net) (Connection reset by peer)
[17:47:15] <ecr> maik: for any particular function, you can just wrap it in a closure. writing a general version would certainly be macro territory.
[17:48:30] <olsonjeffery> "Right now, Rust goes along the way of "trust me". That said, there are idioms (like `take`) which can hide the nastiness in their inside."
[17:48:34] <olsonjeffery> that's a pretty good critique.
[17:48:34] *** Joins: hjr3 (hradtke@374E545A.3A8E9B0C.F9D9C60E.IP)
[17:48:41] <olsonjeffery> Cell, as well.
[17:48:41] <joelteon> tRust me
[17:48:42] <toddaaro> rusti: unsafe { let x: std::unstable::atomics::AtomicPtr<uint> = std::cast::transmute(std::rt::global_heap::malloc_raw(8); x.store(120, std::unstable::atomics::SeqCst); x.load(std::unstable::atomics::SeqCst) }
[17:48:43] -rusti- line longer than 150 columns, pastebinned 4 lines of output: http://ix.io/7uh
[17:49:03] *** Quits: sp3d (a@moz-6F12212B.fidnet.com) (Ping timeout)
[17:49:10] <ecr> best bet would to make a macro that would take something like `partiallyapply!(func(a, b, _, d, _)) and have it generate the closure |c, e| { func(a, b, c, d, e) }
[17:49:26] *** Quits: brson (brson@moz-BBE3ABD.mv.mozilla.com) (Ping timeout)
[17:49:29] <toddaaro> rusti: unsafe { let x: std::unstable::atomics::AtomicPtr<uint> = std::cast::transmute(std::rt::global_heap::malloc_raw(8)); x.store(120, std::unstable::atomics::SeqCst); x.load(std::unstable::atomics::SeqCst) }
[17:49:31] -rusti- line longer than 150 columns, pastebinned 5 lines of output: http://ix.io/7ui
[17:50:10] <toddaaro> rusti: unsafe { let x: std::unstable::atomics::AtomicPtr<uint> = std::cast::transmute(std::rt::global_heap::malloc_raw(8)); x.store(~120, std::unstable::atomics::SeqCst); *x.load(std::unstable::atomics::SeqCst) }
[17:50:13] -rusti- line longer than 150 columns, pastebinned 5 lines of output: http://ix.io/7uj
[17:50:20] <toddaaro> rusti: unsafe { let x: std::unstable::atomics::AtomicPtr<uint> = std::cast::transmute(std::rt::global_heap::malloc_raw(8)); x.store(~120, std::unstable::atomics::SeqCst); x.load(std::unstable::atomics::SeqCst) }
[17:50:23] -rusti- line longer than 150 columns, pastebinned 5 lines of output: http://ix.io/7uk
[17:50:23] *** Joins: eschweic (Adium@moz-BBE3ABD.mv.mozilla.com)
[17:50:35] <toddaaro> rusti: unsafe { let x: std::unstable::atomics::AtomicPtr<uint> = std::cast::transmute(std::rt::global_heap::malloc_raw(8)); x.store(transmute(~120), std::unstable::atomics::SeqCst); x.load(std::unstable::atomics::SeqCst) }
[17:50:37] -rusti- line longer than 150 columns, pastebinned 5 lines of output: http://ix.io/7ul
[17:51:09] <toddaaro> rusti: unsafe { let x: std::unstable::atomics::AtomicPtr<uint> = std::cast::transmute(std::rt::global_heap::malloc_raw(8)); x.store(std::cast::transmute(~120), std::unstable::atomics::SeqCst); x.load(std::unstable::atomics::SeqCst) }
[17:51:11] -rusti- line longer than 150 columns, pastebinned 5 lines of output: http://ix.io/7um
[17:51:33] <maik> ecr, yeah that is what I am thinking now, I probably have to write a lot of cases 
[17:52:58] <engla> toddaaro: you can allocate using ~T instead of calling malloc (like extra::rc does)
[17:53:43] <toddaaro> engla: does that mean destructors care what is going on?
[17:55:14] <engla> no, extra::rc transmutes it back to ~T in the destructor
[17:55:21] <toddaaro> hm, ok
[17:55:25] <engla> rusti: let mut x = ~1u; let ptr = std::unstable::atomics::AtomicPtr::new(&mut *x); unsafe { std::cast::forget(x); } ptr
[17:55:26] -rusti- {p: (0x7fb0f5823058 as *())}
[17:56:30] *** Joins: tjc (tjc@moz-BBE3ABD.mv.mozilla.com)
[17:56:30] *** ChanServ sets mode: +o tjc
[17:58:21] *** Joins: jmgrosen (jmgrosen@moz-848F6087.sb.sd.cox.net)
[17:58:22] *** Quits: lucian (lucian@6B2B4644.4304AE1E.CE5E78F6.IP) (Ping timeout)
[17:58:31] <jmgrosen> is `super` used for anything yet, or just reserved?
[17:59:23] <engla> for the super module, as in   use super::*;
[18:00:00] <ecr> basically super is to modules as '..' is to directories
[18:00:25] <ecr> although I don't know if it's limited to going up only one level or not
[18:01:55] *** Joins: brson (brson@moz-BBE3ABD.mv.mozilla.com)
[18:01:55] *** ChanServ sets mode: +o brson
[18:02:08] <jmgrosen> huh
[18:02:09] <jmgrosen> ok
[18:02:17] *** Joins: mschifer1 (Adium@moz-BBE3ABD.mv.mozilla.com)
[18:02:20] *** Quits: mschifer (Adium@moz-BBE3ABD.mv.mozilla.com) (Connection reset by peer)
[18:02:20] <graydon> I believe it might also be wired up presently to let you call default methods when you provide an override
[18:02:29] <graydon> though I've not tried this myself
[18:05:07] <jmgrosen> is IterBytes going to be changed to use an Iterator, or will it stay function-based?
[18:05:16] <engla> doesn't look that super is used for a method call anywhere in the tree
[18:05:34] <engla> IterBytes is only for feeding into the hash function
[18:06:11] <engla> I'd personally guess it should wind up be implemented with Writer (a "coiterator"?)
[18:06:31] *** Quits: bent (chatzilla@moz-BE33DA21.fw1.sfo1.mozilla.net) (Quit: ChatZilla 0.9.90.1-rdmsoft [XULRunner 22.0/20130619132145])
[18:06:33] <jmgrosen> ok
[18:06:40] <jmgrosen> are we not supposed to use IterBytes in our own code?
[18:06:53] <engla> only if you want a type to be hashable
[18:08:02] *** Joins: bent (chatzilla@moz-BE33DA21.fw1.sfo1.mozilla.net)
[18:09:31] <toddaaro> how do I get this to work manually specifying types in the second transmute?
[18:09:36] <toddaaro> rusti: use std::cast::*; unsafe { let x: *mut uint = transmute(~120); let y: ~uint = transmute<*mut uint, ~uint>(x); y}
[18:09:38] -rusti- pastebinned 7 lines of output: http://ix.io/7us
[18:09:43] <toddaaro> rusti: use std::cast::*; unsafe { let x: *mut uint = transmute(~120); let y: ~uint = transmute<*uint, ~uint>(x); y}
[18:09:45] -rusti- pastebinned 8 lines of output: http://ix.io/7ut
[18:09:48] <toddaaro> both error
[18:10:19] <tjc> graydon: ping
[18:10:36] <graydon> tjc: pong
[18:10:45] <tjc> graydon: question about discovered inputs in workcache...
[18:10:48] <engla> syntax is transmute::<T, U>()  toddaaro 
[18:10:51] <engla> with ::
[18:10:51] <tjc> currently there's no method for adding discovered inputs
[18:11:03] <maik> how can I add lifetime to a closure? |x|x I want the closure to be of type &'r fn(int)->int is this possible? 
[18:11:08] <tjc> is it just as simple as the client (rustpkg in this case) adding to the discovered_inputs map?
[18:11:15] <tjc> or was the intent to have something more automatic?
[18:11:36] <maik> I mean I can do ~fn but then every argument has to be sendable :(
[18:12:07] <graydon> tjc: sec, checking
[18:12:07] *** Quits: andrew-d (andrew@moz-F84C8FD7.hm.shawcable.net) (Client exited)
[18:12:18] <engla> maik: just specify the type with a lifetime?
[18:13:09] <graydon> tjc: yeah. I think probably the inner closure should be changed to take &mut Exec then
[18:13:28] <graydon> tjc: does that work?
[18:13:49] <tjc> graydon: possibly. just wanted to make sure I had the right thing in mind --
[18:14:08] <tjc> that there would be another method like declare_input, but taking both the declared input and one of its discovered dependencies
[18:14:11] *** Joins: markluffel (markluffel@179F0C2A.5C4C7C24.8354FB35.IP)
[18:15:15] *** Quits: Yurume (yurume@AC58A8CE.8A059B47.E313B915.IP) (Ping timeout)
[18:16:55] <nmatsakis> maik: `let my_closure: &'r fn(int)->int = |x| ...`
[18:17:15] <graydon> tjc: the cache treats all the outputs as depending on all the inputs.
[18:17:32] <graydon> tjc: it doesn't do fine grained "just this output comes from just these inputs"
[18:17:37] <tjc> graydon: oh, hmm
[18:17:47] *** Joins: huseby (huseby@19BD73A1.5D8BCA3A.A0C1B52F.IP)
[18:18:05] <tjc> for rustpkg, we want more fine-grained dependencies than that, don't we?
[18:18:46] *** Quits: Sergio965 (sergiobz@moz-22323788.dyn.mit.edu) (Quit: My MacBook Pro has gone to sleep. ZZZzzzâ€¦)
[18:19:56] *** Joins: sp3d (a@moz-6F12212B.fidnet.com)
[18:20:47] <maik> nmatsakis, hm, I also tried that but it didn't help. https://gist.github.com/MaikKlein/6310876 Do you see the problem?
[18:20:48] <toddaaro> engla: ah, duh, thanks
[18:21:39] <graydon> tjc: I don't think so. a crate depends on all its inputs.
[18:21:56] <tjc> graydon: so rustpkg will have to have a separate workcache-database-file for each package?
[18:22:04] <tjc> I suppose that makes sense, I was thinking at first it would have one global database
[18:22:41] <graydon> tjc: I do not think it needs separate database files
[18:22:50] <graydon> tjc: I think a global one will do
[18:22:57] <tjc> graydon: Oh, yeah, I see
[18:22:59] <tjc> ok
[18:23:04] *** Joins: SiegeLord (sl@moz-CAF07B4C.hsd1.ma.comcast.net)
[18:23:34] <nmatsakis> maik: the problem is that you cannot return a stack allocated closure
[18:23:43] <graydon> tjc: I think an output would be a crate-in-a-package and its inputs would be all of its sources and any config vars or similar environmental influences on the build of that crate.
[18:23:51] <nmatsakis> maik: such closures are always allocated on the function's stack frame, so if you returned it, you would be referencing freed memory
[18:24:16] <graydon> tjc: and I think one database should be able to support multiple package-crate outputs
[18:24:30] <graydon> tjc: (or really, I guess, package-target-config-crate outputs)
[18:24:37] <tjc> graydon: yeah, makes sense
[18:24:39] <maik> nmatsakis, ah right.. :( but if I make it ~fn then every argument has to be sendable 
[18:24:40] <nmatsakis> maik: honestly, the best thing would be not to return a closure at all but rather a struct or an object
[18:24:44] *** Quits: markluffel (markluffel@179F0C2A.5C4C7C24.8354FB35.IP) (Quit: Coyote finally caught me)
[18:25:01] <nmatsakis> maik: and then define a `call()` method for the returned value
[18:25:07] <maik> nmatsakis, ah that I can try, thanks
[18:25:28] <graydon> tjc: please do tell me if I'm saying something that doesn't make sense, especially wrt its design / structure
[18:25:37] <engla> maik: you can only return such closures that have no captures (so are not really closures)
[18:25:44] *** Quits: tcr (tcr@D26BCFC9.C2203064.EDCE493E.IP) (Client exited)
[18:25:46] <engla> maik: with 'static as lifetime then
[18:25:48] <graydon> I expect there's lots of impedance mismatch between my imagination and what actually works in code
[18:25:52] <nmatsakis> maik: however, you could write the type as `~fn:'r` instead, and it will not require that it be sendable
[18:26:02] <tjc> graydon: it makes sense. for a while I didn't quite know what each of the categories of inputs and outputs would map onto concretely
[18:26:05] <nmatsakis> maik: but in general `~fn` and `@fn` are deprecated
[18:26:10] <tjc> since the comments in the workcache module are pretty abstract
[18:26:27] <graydon> tjc: yeah, it's a little abstract, sorry :(
[18:27:18] <graydon> tjc: if you think of it like an abstraction of make(1), that happens to include the functionality to capture the output of gcc -MM (discovering the deps of a file while it's compiling it), does that help any?
[18:27:22] *** Quits: lenstr (lenstr@AF8EB999.6049B16A.85938D85.IP) (Client exited)
[18:27:44] <tjc> graydon: not that much, since I don't know how gcc -MM works :-)
[18:27:53] <tjc> but I think I'll have more questions as I continue trying to use it in rustpkg
[18:27:59] <graydon> tjc: and where each .prep() is the part where make checks freshness, and each .exec() is where it runs the rule
[18:28:00] <graydon> ok
[18:29:02] *** Joins: Sergio965 (sergiobz@moz-BB21156B.dynamic.csail.mit.edu)
[18:29:14] *** Joins: Jesse (jruderman@moz-BBE3ABD.mv.mozilla.com)
[18:29:45] *** Joins: yosemite (sam@moz-8CEAB1B0.dasbistro.com)
[18:30:28] <sully> grahdfadjkdlfa;jdaf
[18:30:37] <sully> unused variable warnings on master make me irrationally angry
[18:30:58] <graydon> tjc: gcc -M is kinda awesome: https://gist.github.com/graydon/d84f719461f4768768f4
[18:31:12] <maik> nmatsakis, what is the replacement for ~fn?
[18:31:15] <graydon> tjc: it compiles your file and then _prints out a make rule_ that lists all the dependencies it read while it was compiling it
[18:31:29] <graydon> tjc: so you can capture that and feed it into a makefile as a fragment
[18:31:39] <graydon> tjc: this is how "make depend" works in most makefiles that support it
[18:31:46] <tjc> graydon: ah, ok
[18:31:47] <tjc> makes sense
[18:31:59] <nmatsakis> maik: structs and objects.
[18:32:11] <graydon> tjc: (gcc -MM only prints out the local dependencies, not the system deps. -M does all deps)
[18:32:14] <nmatsakis> maik: at least this is the current plan, there are some obstacles in the way of making this nice to use,
[18:32:28] <nmatsakis> maik: which are gradually being lifted as bugs get fixed :)
[18:32:36] <maik> nmatsakis, ah ok thanks
[18:32:47] *** Quits: fabiand (fabiand@moz-37A8C5D8.adsl.alicedsl.de) (Quit: Verlassend)
[18:32:54] <nmatsakis> maik: http://smallcultfollowing.com/babysteps/blog/2013/06/03/more-on-fns/ is a blog post on the topic, there are a few predecessors to it
[18:34:15] *** Quits: mihneadb (Mihnea@moz-BE33DA21.fw1.sfo1.mozilla.net) (Quit: Leaving)
[18:35:09] <graydon> tjc: the main problem with make(1), from the perspective of folks like .. those who wrote fbuild and/or redo and similar tools, is that it requires you to either list perfect deps in advance or hack up extremely awkward "make depend" logic to pull in the output of gcc -M, rather than support it more-naturally as part of the build system. so in many projects, deps are subtly broken.
[18:35:12] *** Joins: mihneadb (mihneadb@moz-BE33DA21.fw1.sfo1.mozilla.net)
[18:35:45] <graydon> tjc: the design-fix is to provide first class support for discovered dependencies during initial builds and a first class, well supported place to save those deps between runs (the database)
[18:35:50] <tjc> graydon: Yeah, it seems like inherently a problem to have this extra file capturing dependencies that can get out of sync with the code
[18:36:28] <graydon> tjc: along the way they also switch (generally) to using hash-based deps rather than datestamps, and a few other tidy-ups. but that's the main design change.
[18:36:47] <tjc> graydon: Oh, speaking of datestamps
[18:36:48] <Ms2ger> graydon, *subtly* broken? :)
[18:37:12] <tjc> right now I have rustpkg calling a version of digestFile I made that hashes both the contents and the last-modified time
[18:37:27] <tjc> so that if you just `touch` a file and dont' change the contents, rustpkg will see that file as having been changed
[18:37:35] <tjc> I did that because some of my tests depended on it working that way
[18:37:39] <tjc> but I don't know if it's the right thing
[18:38:18] <graydon> Ms2ger: sometimes dramatically. sometimes subtly. "make depend" usually indicates a valiant effort with a bunch of edge cases missing and/or adhering to same named files in wrong dirs.
[18:38:42] *** Joins: jclements (jclements@moz-37891906.dsl.snlo01.pacbell.net)
[18:39:25] <SiegeLord> I always thought redo was more about failure tolerance and better recursion
[18:40:25] *** Quits: jclements (jclements@moz-37891906.dsl.snlo01.pacbell.net) (Quit: jclements)
[18:40:33] <sully> did something about build director structure change recently?
[18:41:00] *** Joins: lenstr (lenstr@AF8EB999.6049B16A.85938D85.IP)
[18:41:06] <graydon> SiegeLord: https://github.com/apenwarr/redo#whats-so-special-about-redo
[18:41:25] <SiegeLord> I've read that dozens of times, that's the main bits I got from it :P
[18:41:27] <graydon> SiegeLord: it's redo-ifchange that's the point of it. your rule has a helper it can call to record the discovered deps.
[18:41:49] <graydon> gcc -MD -MF $2.d -c -o $3 $2.c read DEPS <$2.d redo-ifchange ${DEPS#*:}
[18:42:02] *** Quits: mihneadb (mihneadb@moz-BE33DA21.fw1.sfo1.mozilla.net) (Connection reset by peer)
[18:42:04] <graydon> that's the thing. it's saying "I discovered these deps after I ran gcc, please remember then for next time"
[18:42:10] *** Joins: mihneadb (mihneadb@moz-BE33DA21.fw1.sfo1.mozilla.net)
[18:42:11] *** Joins: tcr (tcr@D26BCFC9.C2203064.EDCE493E.IP)
[18:42:26] <maik> nmatsakis, ok I probably will use it like this https://gist.github.com/MaikKlein/6311121
[18:42:50] <maik> for now
[18:43:10] *** Joins: gandalf (zbraniecki@moz-BE33DA21.fw1.sfo1.mozilla.net)
[18:43:21] <SiegeLord> I guess that never really clicked for me...
[18:44:24] *** AutomatedTester|AFK is now known as AutomatedTester
[18:46:36] *** Quits: sp3d (a@moz-6F12212B.fidnet.com) (Ping timeout)
[18:47:41] *** Quits: eatkinson (eatkinson@moz-BBE3ABD.mv.mozilla.com) (Quit: eatkinson)
[18:48:42] <graydon> SiegeLord: mhm. I think it's a little hard to pick up from the docs. plus the UI uses words that all sound the same.
[18:49:00] *** Joins: lkuper_ (lkuper@moz-D862222C.dhcp-bl.indiana.edu)
[18:49:12] *** Quits: int3_ (int3_@moz-ABE52D50.hsd1.ca.comcast.net) (Client exited)
[18:50:01] <brson> olsonjeffery: functions instead of statics sounds good, yes
[18:50:18] <brson> what's the easiest + fastest way to copy a vector of u8?
[18:51:27] *** Joins: josh (josh@moz-D3896A24.dhcp.dlth.mn.charter.com)
[18:51:27] *** Joins: ghrust (ghrust@C8693FCB.6A2AE50.F3114085.IP)
[18:51:27] <ghrust> 01[13rust01] 15bors merged 06auto into 06master: 02http://git.io/yccFoQ
[18:51:27] *** Parts: ghrust (ghrust@C8693FCB.6A2AE50.F3114085.IP) ()
[18:51:47] <jeaye> rusti: 4 | 1
[18:51:48] -rusti- 5
[18:51:54] <ecr> brson: wouldn't it just be .clone()?
[18:51:55] *** [a]bacus is now known as abacus
[18:52:03] <sully> tjc: ping
[18:52:07] <sully> er
[18:52:07] <tjc> sully: pong
[18:52:22] <sully> er, I guess I meant to ping graydon, but you might be able to help too
[18:52:33] <brson> ecr: clone does an element-wise clone. it's too slow
[18:52:35] <graydon> sully: what's up?
[18:52:37] <sully> I need to rebase one of my PRs, and want to add two more bugfixes to it while I'm at it
[18:52:42] <sully> so need another review
[18:53:09] *** Quits: josh (josh@moz-D3896A24.dhcp.dlth.mn.charter.com) (Ping timeout)
[18:53:27] <toddaaro> brson: there is a memcpy equivilant, I think there is a wrapper on top of vector?
[18:53:30] <graydon> sully: ok. which one?
[18:53:37] *** Quits: ozten (ozten@19BD73A1.5D8BCA3A.A0C1B52F.IP) (Quit: ozten)
[18:53:38] *** Joins: josh (josh@moz-D3896A24.dhcp.dlth.mn.charter.com)
[18:53:42] <graydon> erickt: I'm free to chat a little now, if you like
[18:53:49] <sully> https://github.com/mozilla/rust/pull/8659
[18:53:51] <ecr> brson: vec.iter().collect() ?
[18:54:22] *** Quits: huseby (huseby@19BD73A1.5D8BCA3A.A0C1B52F.IP) (Quit: Leaving)
[18:54:53] <ecr> brson: or maybe .to_owned() ?
[18:55:39] <ecr> but I think that uses clone behind the scenes
[18:55:42] <toddaaro> brson: vec::raw::copy_memory
[18:55:48] *** Quits: lkuper_ (lkuper@moz-D862222C.dhcp-bl.indiana.edu) (Ping timeout)
[18:56:03] <jeaye> What's the difference between &fn, @fn, and ~fn? It's not the same as normal &, @, and ~, right?
[18:56:10] <engla> clone should be fast enough with u8
[18:56:14] *** Joins: eatkinson (eatkinson@moz-BBE3ABD.mv.mozilla.com)
[18:56:34] <kmc> jeaye: it's analogous. it's about where the free variables of the closure are stored
[18:56:35] <jeaye> (for example, I wasn't able to capture the mutable variable I wanted in anything but &fn, but I don't know why)
[18:56:57] *** Joins: int3_ (int3_@moz-BE33DA21.fw1.sfo1.mozilla.net)
[18:57:03] *** Quits: int3_ (int3_@moz-BE33DA21.fw1.sfo1.mozilla.net) (Client exited)
[18:57:07] <kmc> but you're right that &fn is its own kind of thing, not an & type constructor applied to a fn type
[18:57:25] <brson> toddaaro: yeah, it looks like that's the best i can do: vec::with_capacity, then vec::raw::copy_memory
[18:57:32] <brson> not awful
[18:57:48] <kmc> I think ~fn can only have sendable free variables, so that ~fn is always sendable
[18:58:09] <jeaye> kmc: That's true.
[18:58:24] <kmc> which is odd because that's not true of ~ in general -- you can have ~@Foo and that's not sendable
[18:58:25] <toddaaro> brson: just be careful to use the right destination, grab the data: T field
[18:58:30] <jeaye> sendable being ~, right? (well, movable or copyable?)
[18:58:32] <engla> brson: there seems to be a big perf regression the last two days. not sure if it's only in iterators
[18:58:55] <kmc> jeaye: yeah there's a trait Send which describes the types you can send between tasks
[18:59:01] *** Joins: int3_ (int3_@moz-BE33DA21.fw1.sfo1.mozilla.net)
[18:59:03] <brson> engla: is anybody looking at those regressions?
[18:59:06] *** Joins: georgeburton (georgeburt@moz-43046875.as13285.net)
[18:59:11] <engla> https://github.com/mozilla/rust/issues/8665
[18:59:12] <kmc> and we do have trait bounds on fn so I'm not sure why it's not just expressed as ~fn: Send
[18:59:15] <engla> don't think so
[18:59:20] <bjz_> nmatsakis: uhhh
[18:59:24] <bjz_> nmatsakis: error: mismatched types: expected `extern "C" fn(std::libc::types::common::c95::c_void, *u8, i32)` but found `extern "C" extern fn(*std::libc::types::common::c95::c_void, *u8, i32)` (expected enum std::libc::types::common::c95::c_void but found *-ptr)
[18:59:36] *** Joins: doomlord (doomlod@moz-13E69BC8.range86-180.btcentralplus.com)
[18:59:48] <brson> acrichto: do you have any opinions on how to fix the llvm upgrade perf regressions
[18:59:53] *** Joins: mschifer (Adium@moz-BBE3ABD.mv.mozilla.com)
[18:59:55] *** Quits: mschifer1 (Adium@moz-BBE3ABD.mv.mozilla.com) (Connection reset by peer)
[18:59:59] <engla> brson: just mentioning because the hope is that normal loops should optimize well enough to not need copy memory
[19:00:11] <brson> engla: yeah, understood
[19:00:16] <bjz_> nmatsakis: owait dw
[19:00:22] <brson> seems like strcat and dbaupp (?) were discussing problems with our pass handling?
[19:00:25] <nmatsakis> bjz_: I'm not sure what's up with the extern extern, but...
[19:00:32] <toddaaro> engla brson : we should have a bench for this somewhere in the testsuite
[19:00:32] <bjz_> yeh
[19:00:49] <nmatsakis> bjz_: can you file a bug maybe about the extern extern thing? but hopefully it'll work for you when you correct the type of the argument
[19:01:12] * brson lunch
[19:01:19] *** sankha93|afk is now known as sankha93
[19:01:24] <engla> toddaaro: well I noticed the bench tests for "".iter() were much slower. those minibenchmarks are kind of bogus though (but they are now 10x slower)
[19:01:26] <bjz_> nmatsakis: how would I transmute to a void fnptr?
[19:01:29] *** Joins: ghrust (ghrust@79968228.6A2AE50.F3114085.IP)
[19:01:29] <ghrust> 01[13rust01] 15bors pushed 0 new commits to 06auto: 02http://git.io/SHrugA
[19:01:29] *** Parts: ghrust (ghrust@79968228.6A2AE50.F3114085.IP) ()
[19:01:30] *** Joins: ghrust (ghrust@24260B07.6A2AE50.F3114085.IP)
[19:01:30] <ghrust> 01[13rust01] 15bors pushed 2 new commits to 06auto: 02http://git.io/bNKb-w
[19:01:30] <ghrust> 13rust/06auto 14da87eb8 15Steven Fackler: Rename {Reader,Writer}ByteConversions methods...
[19:01:30] <ghrust> 13rust/06auto 146f6bb84 15bors: auto merge of #8607 : sfackler/rust/extensions, r=catamorphism...
[19:01:30] *** Parts: ghrust (ghrust@24260B07.6A2AE50.F3114085.IP) ()
[19:01:42] <nmatsakis> bjz_: I don't know what you mean by a void fnptr
[19:01:46] *** Quits: lenstr (lenstr@AF8EB999.6049B16A.85938D85.IP) (Connection reset by peer)
[19:01:53] <toddaaro> engla: for byte copying?
[19:02:19] *** Joins: lenstr (lenstr@AF8EB999.6049B16A.85938D85.IP)
[19:02:26] *** Quits: Ms2ger (Ms2ger@moz-590E79FE.adsl-dyn.isp.belgacom.be) (Quit: nn)
[19:02:27] <bjz_> nmatsakis: like, some C libs, if you hand it a void function pointer, it ignores or removes a callback
[19:02:46] *** Quits: jmgrosen (jmgrosen@moz-848F6087.sb.sd.cox.net) (Quit: jmgrosen)
[19:02:57] <toddaaro> it seems like fast byte copying relies on llvm auto-vectorizing the loop, and I'm not sure if it does that well? it probably does
[19:03:01] <bjz_> tranmute(null())? but then you get an unconstrained type error
[19:03:20] *** Quits: eschweic (Adium@moz-BBE3ABD.mv.mozilla.com) (Quit: Leaving.)
[19:03:42] <engla> toddaaro: don't know if that exists, no
[19:04:29] <sully> ok, does anybody else on linux run full make checks?
[19:04:46] <sully> the rustpkg test suite fails for me but apparently nobody else in the world
[19:04:53] <sully> I just did a clean clone of master and it does it there
[19:05:08] <bjz_> rusti: let fptr: extern "C" fn() = unsafe { std::cast::transmute(std::ptr::null()) };
[19:05:08] *** Quits: dsirenko (mitra@8E712A0.54C21BA0.9F317420.IP) (Ping timeout)
[19:05:09] -rusti- <anon>:5:67: 5:84 error: cannot determine a type for this expression: unconstrained type
[19:05:09] -rusti- <anon>:5          let fptr: extern "C" fn() = unsafe { std::cast::transmute(std::ptr::null()) };
[19:05:09] -rusti-                                                                             ^~~~~~~~~~~~~~~~~
[19:05:09] -rusti- error: aborting due to previous error
[19:05:11] -rusti- application terminated with error code 101
[19:05:14] *** Quits: hjr3 (hradtke@374E545A.3A8E9B0C.F9D9C60E.IP) (Quit: My MacBook has gone to sleep. ZZZzzzâ€¦)
[19:05:20] <bjz_> nmatsakis:^
[19:05:27] <nmatsakis> bjz_: oh, so nullability of extern fns is an interesting question,
[19:05:43] <nmatsakis> bjz_: whta I'd prefer to do is make nullable extern fns representable by Option<extern "C" fn>, I think
[19:05:48] <bjz_> nmatsakis: it gets tricky with more complex etern fn types
[19:05:49] <nmatsakis> bjz_: but I don't think that works
[19:05:51] <bjz_> oh
[19:05:57] <nmatsakis> bjz_: the other option is just using *c_void and transmute :)
[19:06:08] <nmatsakis> and ptr::null() 
[19:06:33] <bjz_> wait, isn't that what I just did there? ^
[19:06:56] <nmatsakis> bjz_: well, transmute(null()) won't work because null() needs to "pointer to what"
[19:07:11] <nmatsakis> bjz_: perhaps transmute(null::<()>())
[19:07:20] <nmatsakis> but I was more intending to go the other way,
[19:07:23] <nmatsakis> and transmute the fn to a *void
[19:07:26] *** Joins: hjr3 (hradtke@374E545A.3A8E9B0C.F9D9C60E.IP)
[19:07:30] <bjz_> ah
[19:07:32] <nmatsakis> though it doesn't matter
[19:07:43] <nmatsakis> I just wanted to preserve invariant that extern "C" fn() values are always non-NULL
[19:07:54] <nmatsakis> since otherwise calling an extern "C" fn must be unsafe
[19:08:06] <bjz_> mm
[19:08:06] <nmatsakis> since it could segfault
[19:08:10] <bjz_> yep
[19:08:29] <bjz_> heh: transmute(null::<()>())
[19:09:04] <bjz_> such a funny looking thing :P
[19:09:12] *** Joins: dave1629 (dave@moz-17578A1A.hsd1.va.comcast.net)
[19:09:16] <acrichto> brson: I was looking into that, and I rewrote LLVM pass handling to be "correct" in the sense that it's pretty much the exact same as clang, and it didn't help at all. The most disturbing thing to me is that in the profiles of slower code at opt-level=3 you're seeing transmutes. I'm trying to reproduce on a smaller test case to see what's preventing the inlining
[19:10:46] <mindcat> ok.. is possible to make dynamic functions? I just ask, not for others.
[19:11:29] *** Joins: sanxiyn (tinuviel@AE8B10D7.A92E374.57C4C441.IP)
[19:11:36] <Ralith> mindcat: what is a dynamic function?
[19:12:18] *** Quits: tjc (tjc@moz-BBE3ABD.mv.mozilla.com) (Quit: zzzzzzzzzz)
[19:14:35] <mindcat> Ralith: http://paste.ubuntu.com/6015139/
[19:14:54] <sully> god, I am super baffled by this rustpkg test failure.
[19:14:56] *** Quits: eatkinson (eatkinson@moz-BBE3ABD.mv.mozilla.com) (Quit: eatkinson)
[19:15:10] <bjz_> rusti: let f = || print("hi"); f()
[19:15:11] -rusti- hi()
[19:15:20] <bjz_> mindcat: ^
[19:15:30] <mindcat> bjz_: oh
[19:15:30] <bjz_> rusti: let f = || { print("hi") }; f()
[19:15:31] -rusti- hi()
[19:15:49] <bjz_> rusti: let f = |s| { print(s) }; f("yohowdy")
[19:15:50] -rusti- yohowdy()
[19:16:19] <bjz_> rusti: let f = |x| 1 + x * x; f(34)
[19:16:19] -rusti- <anon>:5:25: 5:26 error: the type of this value must be known in this context
[19:16:20] -rusti- <anon>:5          let f = |x| 1 + x * x; f(34)
[19:16:20] -rusti-                                   ^
[19:16:20] -rusti- error: aborting due to previous error
[19:16:20] -rusti- application terminated with error code 101
[19:16:26] <bjz_> rusti: let f = |x| x * x; f(34)
[19:16:27] -rusti- <anon>:5:21: 5:22 error: the type of this value must be known in this context
[19:16:27] -rusti- <anon>:5          let f = |x| x * x; f(34)
[19:16:27] -rusti-                               ^
[19:16:27] -rusti- error: aborting due to previous error
[19:16:29] -rusti- application terminated with error code 101
[19:16:33] *** Joins: vosen (vosen@moz-266BA656.icpnet.pl)
[19:16:40] <bjz_> :/
[19:16:52] <bjz_> wut
[19:16:56] <mindcat> rusti: let f = |x| {1 + x * x}; f(36)
[19:16:56] <bjz_> rusti: let f = |x| x * x; f(34i)
[19:16:57] -rusti- <anon>:5:26: 5:27 error: the type of this value must be known in this context
[19:16:57] -rusti- <anon>:5          let f = |x| {1 + x * x}; f(36)
[19:16:58] -rusti-                                    ^
[19:16:58] -rusti- error: aborting due to previous error
[19:16:58] -rusti- application terminated with error code 101
[19:16:58] -rusti- <anon>:5:21: 5:22 error: the type of this value must be known in this context
[19:17:01] -rusti- <anon>:5          let f = |x| x * x; f(34i)
[19:17:03] -rusti-                               ^
[19:17:05] -rusti- error: aborting due to previous error
[19:17:07] -rusti- application terminated with error code 101
[19:17:20] <Florob> rusti: let f = |x: uint| x * x; f(34)
[19:17:21] -rusti- 1156
[19:17:21] <myname> can't you do |x as int|?
[19:17:24] <myname> :D
[19:18:15] <mindcat> I can do like Python things :D
[19:18:20] <mindcat> now
[19:18:45] *** Quits: int3_ (int3_@moz-BE33DA21.fw1.sfo1.mozilla.net) (Client exited)
[19:19:48] *** Quits: jorendorff (jorendorff@moz-1747FB68.hsd1.tn.comcast.net) (Quit: jorendorff)
[19:20:05] *** Quits: doomlord (doomlod@moz-13E69BC8.range86-180.btcentralplus.com) (Ping timeout)
[19:20:13] <mindcat> I learned Python first, C++/C is too hard so I going learn Rust now.
[19:20:15] *** Quits: bent (chatzilla@moz-BE33DA21.fw1.sfo1.mozilla.net) (Ping timeout)
[19:21:15] *** Joins: bent (chatzilla@moz-BE33DA21.fw1.sfo1.mozilla.net)
[19:22:15] <bjz_> mindcat: well the advantage is that the can be multiline ;)
[19:22:38] <graydon> pcwalton: you have preliminary version of lazy resolve?
[19:24:01] <mindcat> bjz_: multiline?
[19:24:18] *** Quits: bent (chatzilla@moz-BE33DA21.fw1.sfo1.mozilla.net) (Quit: ChatZilla 0.9.90.1-rdmsoft [XULRunner 22.0/20130619132145])
[19:24:30] <bjz_> mindcat: in python you can only do single-line closures?
[19:24:48] <maik> bjz_, does gl-rs work now?
[19:25:06] <bjz_> maik: working through the errors
[19:25:15] <Florob> bjz_, I have a hunch the python version of that would've been Â«def a() printâ€¦Â»
[19:25:17] <bjz_> maik: finxing glfw-rs first though
[19:25:41] <maik> bjz_, okay nice <3
[19:28:07] *** Joins: RayWizard (kvirc@E248DB08.9470356F.5B864609.IP)
[19:28:09] <maik> is there a way to print out types?
[19:28:46] *** Joins: bent (chatzilla@moz-BE33DA21.fw1.sfo1.mozilla.net)
[19:29:12] <maik> rusti: struct Functor<T>(T); let f1 = Functor(|x:int|x+x); printfln!(*f1);
[19:29:13] -rusti- ()
[19:29:24] <maik> is not that helpful :)
[19:29:24] <mindcat> bjz_: sorry, I don't know what is "closure"...
[19:29:46] <maik> mindcat, |x| x is a closure
[19:30:02] <maik> mindcat, sth like an anonymous function
[19:30:29] <ecr> how do I put labels on an issue? i'm not seeing an option
[19:30:56] <bjz_> mindcat: lambda and closures anre technically not interchangable terms, but they are intermixed
[19:31:34] <maik> http://stackoverflow.com/questions/220658/what-is-the-difference-between-a-closure-and-a-lambda
[19:31:48] *** Joins: doomlord (doomlod@moz-13E69BC8.range86-180.btcentralplus.com)
[19:31:49] <mindcat> oh, it seem I did it before
[19:32:18] <bjz_> mindcat: http://docs.python.org/3.3/reference/expressions.html#lambda
[19:33:03] <bjz_> mindcat: my remark was a cheeky prod at the fact that python's lambdas can only be written on a single line
[19:33:21] <mindcat> bjz_: oh yes
[19:33:30] <olsonjeffery> brson: is there ever a reason we would prefer an element-wise copy of a vector vs a memcpy approach? if so, why isn't the latter approach the default?
[19:33:33] <mindcat> bjz_: one line
[19:33:51] *** Joins: eschweic (Adium@moz-BBE3ABD.mv.mozilla.com)
[19:34:34] <ecr> olsonjeffery: he's at lunch right now
[19:35:06] <olsonjeffery> ah, thanks.
[19:36:01] <olsonjeffery> rusti: struct Foo(int); impl Foo { fn foo(i: int) -> { i } fn bar() { *self } } let f = Foo(42); let r = &f; let res = r.bar(); r.foo(res)
[19:36:02] -rusti- <anon>:5:59: 5:60 error: expected `:` but found `}`
[19:36:02] -rusti- <anon>:5          struct Foo(int); impl Foo { fn foo(i: int) -> { i } fn bar() { *self } } let f = Foo(42); let r = &f; let res = r.bar(); r.foo(res)
[19:36:02] -rusti-                                                                     ^
[19:36:02] -rusti- application terminated with error code 101
[19:36:02] <kmc> but nested 'def' in Python can close over variables as well
[19:36:03] *** Quits: Jesin (Jessin_@moz-5654D37.washdc.fios.verizon.net) (Quit: Leaving)
[19:36:28] <olsonjeffery> rusti: struct Foo(int); impl Foo { fn foo(i: int) -> int { i } fn bar() -> int { *self } } let f = Foo(42); let r = &f; let res = r.bar(); r.foo(res)
[19:36:30] -rusti- line longer than 150 columns, pastebinned 5 lines of output: http://ix.io/7uC
[19:36:43] <vadimcn> hi, when I call extern fn defined in another crate, how is linking supposed to work?   Right now I'm getting 
[19:36:52] <vadimcn> "undefined reference to `OpenProcess'" (this is on Windows)
[19:37:07] <ecr> olsonjeffery: as for your question, I don't think a memcpy approach would work if the elements of a vector for @s or ref-counted. you need to increment the ref count, which .clone() will do.
[19:37:13] <ecr> could be wrong though.
[19:37:19] <olsonjeffery> fair nuff
[19:37:29] <vadimcn> this is a call to std::libc::funcs::extra::kernel32::OpenProcess
[19:37:44] <bjz_> kmc: Oh I see
[19:37:50] <olsonjeffery> ecr: that distinction could be teased out w/ Traits for various pointer/value contents of a trait, right?
[19:38:01] <olsonjeffery> rusti: struct Foo(int); impl Foo { fn foo(i: int) -> int { i } fn bar(&self) -> int { *self } } let f = Foo(42); let r = &f; let res = r.bar(); r.foo(res)
[19:38:03] -rusti- pastebinned 8 lines of output: http://ix.io/7uD
[19:38:25] <vadimcn> I thought this call would pass through libstd, which is already linked to kernel32.lib
[19:38:32] <Florob> olsonjeffery, ecr, I think if we could determine whether a vec is over POD one could optimize that case with memcpy, yes.
[19:38:56] <ecr> olsonjeffery: I think it already has been. For example, look at CopyableVector's to_owned and into_owned methods.
[19:39:04] * olsonjeffery nods
[19:39:10] <vadimcn> brson: any idea about this?
[19:39:24] <bjz_> nmatsakis: how would I test if a extern fn returned/set by a C lib was null or not?
[19:39:43] *** Quits: eschweic (Adium@moz-BBE3ABD.mv.mozilla.com) (Ping timeout)
[19:39:51] <bjz_> nmatsakis: transmute to a *c_void?
[19:40:29] <ecr> bjz_: ptr::is_null?
[19:40:39] <olsonjeffery> rusti: struct Foo(int); impl Foo { fn foo(&self, i: int) -> int { i } fn bar(&self) -> int { *self as int } } let f = Foo(42); let r = &f; let res = r.bar(); r.foo(res)
[19:40:41] -rusti- line longer than 150 columns, pastebinned 5 lines of output: http://ix.io/7uE
[19:40:45] *** Joins: jorendorff (jorendorff@moz-364496FE.hsd1.tn.comcast.net)
[19:41:03] <nmatsakis> bjz_: yes
[19:41:14] <bjz_> ecr: extern fn pointers are no longer *u8s as of last night
[19:41:25] *** Joins: ghrust (ghrust@DE823A67.6A2AE50.F3114085.IP)
[19:41:25] <ghrust> 01[13rust01] 15bors 04force-pushed 06auto from 146f6bb84 to 14063a005: 02http://git.io/N3iJvQ
[19:41:25] *** Parts: ghrust (ghrust@DE823A67.6A2AE50.F3114085.IP) ()
[19:41:25] *** Joins: ghrust (ghrust@F6EE6DE3.6A2AE50.F3114085.IP)
[19:41:25] <ghrust> 01[13rust01] 15bors pushed 3 new commits to 06auto: 02http://git.io/DCV8fw
[19:41:25] <ghrust> 13rust/06auto 140bfaf82 15Alex Crichton: Upgrade libuv to the current master + our patches...
[19:41:25] <ghrust> 13rust/06auto 14003bf59 15Alex Crichton: Implement process bindings to libuv...
[19:41:26] <ghrust> 13rust/06auto 146c25638 15bors: auto merge of #8645 : alexcrichton/rust/issue-6436-run-non-blocking, r=brson...
[19:41:28] *** Parts: ghrust (ghrust@F6EE6DE3.6A2AE50.F3114085.IP) ()
[19:42:14] <bjz_> ecr: which is super awesome
[19:42:14] * graydon excited
[19:42:15] <bytewise> rusti: (std::sys::size_of::<extern "C" fn()>(), std::sys::size_of::<Option<extern "C" fn()>>())
[19:42:17] -rusti- (8, 8)
[19:42:24] <nmatsakis> bjz_: I guess I really ought to get Option<extern "C" fn> working properly...
[19:42:33] <bjz_> nmatsakis: heh, sorry
[19:42:37] <nmatsakis> bjz_: jld and strcat assure me that this is easy :)
[19:42:59] * bjz_ is always giving nmatsakis a hard time :[
[19:43:03] *** Quits: georgeburton (georgeburt@moz-43046875.as13285.net) (Quit: georgeburton)
[19:43:04] <ecr> blz_: wat. where do I read about this miracle?
[19:43:11] *** Quits: reyre (reyre@916689EC.33EE9F8A.1139E686.IP) (Client exited)
[19:43:13] <bjz_> ecr: here
[19:43:16] <bjz_> ecr: now
[19:43:20] <bjz_> x)
[19:43:28] <olsonjeffery> nmatsakis: heh, i got an error on stage1 because of two match arms.. one returns an extern fn by name and the other did 0 as *u8
[19:43:38] * nmatsakis sighs 
[19:43:40] <bjz_> ecr: https://github.com/mozilla/rust/pull/8666
[19:43:48] <olsonjeffery> this was to drive logic in a libuv call (certain calls take a null fn pty for sync behavior)
[19:43:49] <nmatsakis> in theory I...just fixed it so that Option<> will work :)
[19:43:50] <nmatsakis> let's see 
[19:43:55] <nmatsakis> it was indeed quite easy
[19:44:37] <olsonjeffery> so i ended up just casting the extern fn value to *u8 to make it work.. i guess i didn't bother trying to cast the 0 to extern "C" fn. would that work?
[19:44:49] <olsonjeffery> or should i just stick w/ *u8?
[19:45:16] <mindcat> rusti: let a = || println("abcd");
[19:45:17] -rusti- <anon>:5:13: 5:14 warning: unused variable: `a` [-W unused-variable (default)]
[19:45:17] -rusti- <anon>:5          let a = || println("abcd");
[19:45:17] -rusti-                       ^
[19:45:17] -rusti- ()
[19:45:32] <mindcat> rusti: let a = || println("abcd");a
[19:45:57] <olsonjeffery> rusti: struct Foo(int); impl Foo { fn foo(&self, i: int) -> int { i } fn bar(&self) -> int { **self } } let f = Foo(42); let r = &f; let res = r.bar(); r.foo(res)
[19:45:58] -rusti- 42
[19:45:58] <nmatsakis> olsonjeffery: either one will work, I think, I'd...say casting to *u8 is marginally cleaner
[19:46:07] <mindcat> rusti: let a = || println("abcd");a()
[19:46:08] -rusti- abcd
[19:46:08] -rusti- ()
[19:46:09] *** Quits: maik (maik___@moz-BEACDBF.dip0.t-ipconnect.de) (Ping timeout)
[19:46:18] <olsonjeffery> rusti: struct Foo(int); impl Foo { fn foo(&self, i: int) -> int { i } fn bar(&self) -> int { **self } } let f = Foo(42); let r = &f; r.foo(r.bar())
[19:46:19] -rusti- 42
[19:46:25] <olsonjeffery> heh.
[19:46:39] <olsonjeffery> that was failing for me last night. wonder if something changed.
[19:46:45] <olsonjeffery> with a "double borrow" error
[19:46:50] <mindcat> well, this is not working when use rust 0.7.
[19:46:57] <mindcat> i mean my
[19:47:42] <mindcat> http://paste.ubuntu.com/6015251/
[19:47:49] <mindcat> like that :D
[19:47:58] *** Quits: FrozenCow (FrozenCow@moz-B2DF4929.chello.nl) (Client exited)
[19:48:22] *** Joins: FrozenCow (FrozenCow@moz-B2DF4929.chello.nl)
[19:48:49] *** Joins: FrozenCow_ (FrozenCow@moz-B2DF4929.chello.nl)
[19:48:50] *** Quits: FrozenCow (FrozenCow@moz-B2DF4929.chello.nl) (Connection reset by peer)
[19:49:01] <Florob> mindcat, semicolons are non-optional. I.e. you need to do a(); not a()
[19:49:58] <mindcat> Florob: oh I forget it...
[19:52:12] <sfackler> ugh, that's the second time in a row i've run make check on the wrong branch
[19:52:17] *** Joins: FrozenCow (FrozenCow@moz-B2DF4929.chello.nl)
[19:52:19] *** Quits: FrozenCow_ (FrozenCow@moz-B2DF4929.chello.nl) (No route to host)
[19:55:29] <jld> nmatsakis: grep reminds me that it's mono_data_classify in middle/trans/common.rs
[19:55:50] <nmatsakis> jld: found it, thanks
[19:57:01] <jld> ...wait.  rusti said the size of `extern "C" fn()` and `Option<extern "C" fn()>` were the same.
[19:57:24] <jld> Shouldn't that not work yet?
[19:58:18] <sully> graydon: ping
[19:58:25] <mindcat> rusti: fn main() -> int {1};main()
[19:58:26] -rusti- 1
[19:58:27] <graydon> sully: pong
[19:58:31] *** Quits: lmandel (lmandel@moz-BE33DA21.fw1.sfo1.mozilla.net) (Ping timeout)
[19:58:32] <sully> graydon: I have a question about the layout of build directories on the build bot
[19:58:37] <graydon> sully: shoot
[19:58:41] <sully> graydon: is the build directory inside the source directory?
[19:58:48] <graydon> yes
[19:58:52] <sully> or is it put off to the side somewhere
[19:58:55] <sully> hm...
[19:58:56] <graydon> we check out into a subdir called obj
[19:58:58] <Sergio965> Is there any way to take a lifetime argument in a macro?
[19:59:00] <graydon> or rather
[19:59:08] <graydon> we check out into (weirdly, this is buildbot's choice) build/
[19:59:11] *** Joins: eschweic (Adium@moz-BBE3ABD.mv.mozilla.com)
[19:59:12] <graydon> and then build in build/obj/
[19:59:43] <graydon> so build/obj/<host>/<stage>/bin/rustc will be an output, for example
[19:59:49] <pauls> Sergio965: you should be able to handle it as an `ident`, provided you leave off the `'` until final transcription.
[20:00:03] <Sergio965> That's unfortunate.
[20:00:23] <graydon> built from build/src/driver/driver.rs
[20:00:41] <graydon> sully: does that answer your question?
[20:01:22] <sully> ok, so, where is the makefile?
[20:01:26] <sully> is configure run from build/obj?
[20:01:44] <nmatsakis> jld: huh, does it work already? not sure why it would
[20:01:44] *** Joins: ghrust (ghrust@F6EE6DE3.6A2AE50.F3114085.IP)
[20:01:45] <ghrust> 01[13rust01] 15bors 04force-pushed 06auto from 146c25638 to 14063a005: 02http://git.io/N3iJvQ
[20:01:45] *** Parts: ghrust (ghrust@F6EE6DE3.6A2AE50.F3114085.IP) ()
[20:01:46] *** Joins: ghrust (ghrust@F6EE6DE3.6A2AE50.F3114085.IP)
[20:01:46] <ghrust> 01[13rust01] 15bors pushed 6 new commits to 06auto: 02http://git.io/Hf7Csw
[20:01:46] <ghrust> 13rust/06auto 1448a6823 15Michael Sullivan: Don't ICE if an argument in a default method doesn't have a name. Closes #8417.
[20:01:46] <ghrust> 13rust/06auto 14451de33 15Michael Sullivan: Add `self` to the ast_map for provided methods. Closes #8010.
[20:01:46] <ghrust> 13rust/06auto 148a9cdda 15Michael Sullivan: Fix type parameter handling for static default methods. Closes #8654.
[20:01:48] *** Parts: ghrust (ghrust@F6EE6DE3.6A2AE50.F3114085.IP) ()
[20:02:02] <nmatsakis> jld: oh, wait, the entry is already there!
[20:02:04] <nmatsakis> jld: I take that back
[20:02:06] <nmatsakis> bjz_: ping
[20:02:23] <nmatsakis> bjz_: you should be able to translate a "nullable" extern "C" fn into Option<extern "C" fn(...)>
[20:02:44] <nmatsakis> olsonjeffery: ^
[20:02:54] <bjz_> Oh cool
[20:03:04] <bjz_> So just use that?
[20:03:07] <nmatsakis> yes
[20:03:14] <nmatsakis> then you can just do None for null
[20:03:38] <nmatsakis> jld: good catch :)
[20:03:59] <bjz_> nmatsakis: you are amazing :)
[20:04:17] *** Joins: lmandel (lmandel@moz-BE33DA21.fw1.sfo1.mozilla.net)
[20:04:23] <nmatsakis> this one is all jld
[20:04:42] *** Parts: sanxiyn (tinuviel@AE8B10D7.A92E374.57C4C441.IP) (Bye)
[20:04:46] <graydon> hm
[20:05:00] <graydon> I think the new visitors + default methods were a perf hit
[20:05:31] <sully> default methods are probably not the culprit
[20:05:38] <graydon> still bisecting, it's not like .. there doesn't seem to be a single culprit
[20:05:46] <graydon> just a bunch of new code generated
[20:06:07] <graydon> well, when I say "default methods" here, I mean, I think when you use a visitor and override 1 method, we stamp out the 20 you don't override anew
[20:06:14] <olsonjeffery> nmatsakis: nice, thanks.
[20:06:15] <sully> ok, right
[20:06:20] <graydon> whereas in the old visitor we reused the code of those default closures
[20:06:34] <graydon> all the new symbols I see are visitor walkers of various sorts
[20:06:58] <graydon> *shrug* lunch time, will keep bisecting until something clear emerges, that's the best guess so far
[20:07:00] <sully> graydon: which directory on the buildbots does configure get run from/the makefile get pushed?
[20:07:02] <acrichto> graydon: it's looking like the llvm upgrade may also be a fairly large perf hit (if that's somewhere in the middle)
[20:07:02] <graydon> I wonder how to overcome it
[20:07:08] <sully> build/obj?
[20:07:09] <graydon> yeah, llvm is in the middle too
[20:07:15] <graydon> build/obj
[20:07:22] <graydon> sully: build/obj
[20:07:23] <acrichto> there's a 10x slowdown on a particular benchmark someone found :(
[20:07:40] <sully> ok, so, the build root is *not* the source root
[20:07:42] *** Joins: tjc (tjc@moz-BBE3ABD.mv.mozilla.com)
[20:07:42] *** ChanServ sets mode: +o tjc
[20:07:44] <sully> aha.
[20:08:03] <sully> ok, I have figured out what is going on with this rustpkg test that is failing for me
[20:08:20] <brson> olsonjeffery: the memcpy isn't the default because it's only valid for POD types and that would require some sort of specialization of .clone which is not something we do
[20:08:33] <nmatsakis> graydon: I think this is just a special case of the more general problem of sharing monomorphized instances
[20:08:53] <sully> it assumes a particularly layout of build directories
[20:08:55] <nmatsakis> graydon: in particular I still think that the best way to think of a default method is as a monomorphized version of the default for the case where Self == TheImplType
[20:09:09] <brson> vadimcn: this may be fallout from the recent ffi changes
[20:09:12] <sully> which is the layout on the build bots (and apparently a lot of people's checkouts)
[20:09:18] <sully> but not my layout
[20:09:21] <sully> aaaaargh.
[20:09:25] <brson> vadimcn: which would be unfortunate
[20:09:26] *** Joins: eatkinson (eatkinson@moz-BBE3ABD.mv.mozilla.com)
[20:09:32] <sully> ok, so, what this test is doing
[20:09:35] <nmatsakis> graydon: though I think there is still some work to do on the code to merge the code paths more and more, could be wrong, the details of sully's excellent work have fled my head already
[20:10:26] <sully> namely, trying to find the rust source directory based on the location of the test executable
[20:10:37] <sully> is just totally unprincipled
[20:10:53] * nmatsakis frowns
[20:11:30] *** Quits: pcwalton (pcwalton@moz-7B0110AD.mv.mozilla.com) (Quit: pcwalton)
[20:12:26] *** Quits: jorendorff (jorendorff@moz-364496FE.hsd1.tn.comcast.net) (Ping timeout)
[20:13:21] *** Joins: jorendorff (jorendorff@moz-364496FE.hsd1.tn.comcast.net)
[20:15:14] *** Quits: azita (Azita@moz-BBE3ABD.mv.mozilla.com) (Quit: azita)
[20:17:24] <ecr> graydon: ping
[20:17:55] *** Joins: carllerche (carllerche@6B070D22.7E6A0813.1428D117.IP)
[20:18:38] *** Joins: brendan (brendaneic@moz-BBE3ABD.mv.mozilla.com)
[20:19:45] <echristo> lkuper: oncenesses?
[20:19:53] <echristo> now that's a function name designed in hell. :)
[20:20:59] <nmatsakis> outmoded anyhow
[20:21:06] <nmatsakis> or it will be eventually...
[20:21:11] <nmatsakis> but lkuper is not to blame for it, rather me :)
[20:22:00] *** Joins: pcwalton (pcwalton@moz-7B0110AD.mv.mozilla.com)
[20:22:00] *** ChanServ sets mode: +o pcwalton
[20:22:14] <sully> ok, hm
[20:22:21] *** Quits: sankha93 (Instantbir@7061CD01.D6BD0D91.22D41759.IP) (Ping timeout)
[20:22:23] <sully> I need to figure out what to do about this silly test
[20:22:34] *** Quits: ecr (Thunderbir@moz-BBE3ABD.mv.mozilla.com) (Quit: ecr)
[20:23:05] *** Quits: mindcat (mindcat@2DE37087.C6D6E0F5.857BDFA9.IP) (Quit: Lost terminal)
[20:25:09] <bblum> silly sully test
[20:25:29] *** Joins: ozten (ozten@19BD73A1.5D8BCA3A.A0C1B52F.IP)
[20:28:51] *** Joins: tiffany (kawaii@moz-EB8B0C08.dhcp.embarqhsd.net)
[20:29:03] *** Joins: int3_ (int3_@moz-BE33DA21.fw1.sfo1.mozilla.net)
[20:30:51] *** Quits: int3_ (int3_@moz-BE33DA21.fw1.sfo1.mozilla.net) (Ping timeout)
[20:31:32] *** Joins: jviereck (Adium@moz-AF73A9F4.dip0.t-ipconnect.de)
[20:33:02] *** Joins: ecr (Thunderbir@moz-BBE3ABD.mv.mozilla.com)
[20:33:04] *** Joins: nrc (nrc@7BE24E90.A5032A01.3CFC199D.IP)
[20:33:36] *** Quits: ecr (Thunderbir@moz-BBE3ABD.mv.mozilla.com) (Quit: ecr)
[20:36:05] *** Joins: EXetoC (ex@moz-2DBEB1E4.customer.t3.se)
[20:36:10] *** Parts: EXetoC (ex@moz-2DBEB1E4.customer.t3.se) (WeeChat 0.4.1)
[20:36:31] *** Joins: huseby (huseby@19BD73A1.5D8BCA3A.A0C1B52F.IP)
[20:36:57] *** Quits: brson (brson@moz-BBE3ABD.mv.mozilla.com) (Ping timeout)
[20:37:00] *** Joins: brson (brson@moz-BBE3ABD.mv.mozilla.com)
[20:37:00] *** ChanServ sets mode: +o brson
[20:37:06] *** Quits: msingle (Thunderbir@moz-930E5D97.hr.hr.cox.net) (Ping timeout)
[20:37:06] *** Joins: mib_28g3y9 (Mibbit@5C4A0371.9A23277B.4B0B8C68.IP)
[20:37:08] *** Quits: Florob (Florob@moz-39532932.de) (Client exited)
[20:37:25] *** Quits: Blub\w (wry@7E3BB9D.71150E1A.237AE2BA.IP) (Quit: night)
[20:38:05] *** Joins: maik (maik___@moz-BEACDBF.dip0.t-ipconnect.de)
[20:38:11] *** Quits: lmandel (lmandel@moz-BE33DA21.fw1.sfo1.mozilla.net) (Ping timeout)
[20:38:11] *** Quits: paulproteus (quassel@rose.makesad.us) (Ping timeout)
[20:38:35] *** Joins: msingle (Thunderbir@moz-930E5D97.hr.hr.cox.net)
[20:38:48] *** Joins: lmandel (lmandel@moz-BE33DA21.fw1.sfo1.mozilla.net)
[20:39:07] <mib_28g3y9> I'm following the "Rust for Rubyists" tutorial and there's a code snippet that looks like `for 100.times { ... }` (paste: http://hastebin.com/fegevulifo.rs). However when I try to compile it, I get "error: expected `in` got `.`". Can anyone advise?
[20:39:09] <maik> bjz_, any further complications :)?
[20:39:40] <sully> hm, I kind of want to just disable the test
[20:40:14] <mib_28g3y9> (sorry if this is the wrong channel to ask for getting-started help)
[20:40:50] <Sergio965> How does as_imm_buf work for both vectors and slices? Won't it return the wrong information for vectors?
[20:41:29] *** Joins: ghrust (ghrust@2EE61FCC.6A2AE50.F3114085.IP)
[20:41:29] <ghrust> 01[13rust01] 15bors 04force-pushed 06auto from 141b11cd9 to 14063a005: 02http://git.io/N3iJvQ
[20:41:29] *** Parts: ghrust (ghrust@2EE61FCC.6A2AE50.F3114085.IP) ()
[20:41:30] *** Joins: ghrust (ghrust@24260B07.6A2AE50.F3114085.IP)
[20:41:30] <ghrust> 01[13rust01] 15bors pushed 2 new commits to 06auto: 02http://git.io/6Incpw
[20:41:30] <ghrust> 13rust/06auto 14405c54a 15Kevin Ballard: Implement size_hint() on RangeInclusive
[20:41:30] <ghrust> 13rust/06auto 14f05b766 15bors: auto merge of #8671 : kballard/rust/range_inclusive-size-hint, r=thestinger...
[20:41:30] *** Parts: ghrust (ghrust@24260B07.6A2AE50.F3114085.IP) ()
[20:41:34] *** Quits: brson (brson@moz-BBE3ABD.mv.mozilla.com) (Ping timeout)
[20:42:45] <maik> mib_28g3y9, thats out of date
[20:43:05] <maik> mib_28g3y9, it's do 100.times(){} now
[20:43:47] <maik> rusti: do 2.times(){print("He ");}
[20:43:48] -rusti- He He ()
[20:43:55] <erickt> graydon: ping
[20:43:57] <mib_28g3y9> maik: Thanks! That compiled and ran properly.
[20:44:12] <kmc> mib_28g3y9: that too is going away, though
[20:44:41] <kmc> the preferred way now is   for _ in range(0,100) { ... }
[20:45:18] <myname> for to do to for
[20:45:19] <mib_28g3y9> kmc: is `_` special, or just convention to indicate that the variable isnt' being used?
[20:45:25] *** Joins: brson (brson@moz-BBE3ABD.mv.mozilla.com)
[20:45:25] *** ChanServ sets mode: +o brson
[20:45:48] <myname> it should be special in the way that it doesn't produce a warnung about it being unused
[20:46:14] <kmc> it's not a variable, it's a pattern that matches anything and binds no variables
[20:46:29] *** Joins: paulproteus (quassel@moz-E86A3B42.makesad.us)
[20:46:30] *** Quits: tgummerer (tgummerer@51D3B54.FEF996EA.EA6FEF3D.IP) (Ping timeout)
[20:46:53] <mib_28g3y9> oh right, I remember that section from the docs tutorial.
[20:47:19] *** Quits: lmandel (lmandel@moz-BE33DA21.fw1.sfo1.mozilla.net) (Ping timeout)
[20:47:32] *** Joins: lmandel (lmandel@moz-BE33DA21.fw1.sfo1.mozilla.net)
[20:47:36] <mib_28g3y9> thanks very much for your help!
[20:47:38] <kmc> :)
[20:47:55] *** Quits: mib_28g3y9 (Mibbit@5C4A0371.9A23277B.4B0B8C68.IP) (Quit: http://www.mibbit.com ajax IRC Client)
[20:47:59] <kmc> but also rustc does respect the convention that variables whose names start with _ are allowed to be unused
[20:48:02] <kmc> welp
[20:48:53] <brson> is somebody working on snapshot?
[20:49:29] *** Joins: azita (Azita@moz-BBE3ABD.mv.mozilla.com)
[20:49:31] *** Quits: nsf (nsf@moz-EEF3238A.convex.ru) (Quit: WeeChat 0.4.1)
[20:53:57] *** Joins: mschifer1 (Adium@moz-BBE3ABD.mv.mozilla.com)
[20:53:57] *** Quits: mschifer (Adium@moz-BBE3ABD.mv.mozilla.com) (Connection reset by peer)
[20:54:23] <maik> is this a bug?
[20:54:25] <maik> rusti: struct Functor<T>(T); let f1 = Functor(|x:int|x+x); printfln!(*f1);
[20:54:25] *** Joins: mschifer (Adium@moz-BBE3ABD.mv.mozilla.com)
[20:54:26] -rusti- ()
[20:54:36] *** Quits: mschifer1 (Adium@moz-BBE3ABD.mv.mozilla.com) (Connection reset by peer)
[20:54:56] *** Quits: lmandel (lmandel@moz-BE33DA21.fw1.sfo1.mozilla.net) (Ping timeout)
[20:55:28] <bblum> iface.
[20:55:35] <bblum> hard to believe we used to call it 'iface'
[20:56:00] <maik> what does iface even mean?
[20:56:02] *** Quits: tjc (tjc@moz-BBE3ABD.mv.mozilla.com) (Quit: Places to go, people to annoy)
[20:56:05] <maik> ah
[20:56:06] <maik> interface
[20:56:07] <maik> :D
[20:56:10] *** Joins: lmandel (lmandel@moz-BE33DA21.fw1.sfo1.mozilla.net)
[20:57:08] *** sam113101 is now known as sam113101_afk
[20:57:55] <mm> rusti: use std::rt::rtio::RtioTimer; std::rt::io::timer::Timer::new().unwrap().sleep(0);
[20:57:56] -rusti- error: internal compiler error: drop_ty_immediate: non-box ty
[20:57:56] -rusti- application terminated with error code 101
[20:57:59] <mm> :(
[20:59:36] <mm> ^ Is there a working way to sleep?
[21:00:14] *** Joins: reyre (reyre@moz-9002CDDA.cpe.net.cable.rogers.com)
[21:00:17] *** Quits: dwhyte (dwhyte@1922756A.EDC594B0.7BF4A4B0.IP) (No route to host)
[21:00:23] *** Quits: azita (Azita@moz-BBE3ABD.mv.mozilla.com) (Quit: azita)
[21:00:24] *** Joins: strcat (strcat@moz-54F7FD49.cpe.net.cable.rogers.com)
[21:00:48] *** Joins: tjc (tjc@moz-BBE3ABD.mv.mozilla.com)
[21:00:49] *** ChanServ sets mode: +o tjc
[21:01:29] *** Joins: ghrust (ghrust@24260B07.6A2AE50.F3114085.IP)
[21:01:30] <ghrust> 01[13rust01] 15bors 04force-pushed 06auto from 14f05b766 to 14063a005: 02http://git.io/N3iJvQ
[21:01:30] *** Parts: ghrust (ghrust@24260B07.6A2AE50.F3114085.IP) ()
[21:01:30] *** Joins: ghrust (ghrust@F6EE6DE3.6A2AE50.F3114085.IP)
[21:01:30] <ghrust> 01[13rust01] 15bors pushed 5 new commits to 06auto: 02http://git.io/7w2u9Q
[21:01:30] <ghrust> 13rust/06auto 14dd40636 15Ben Blum: Add assert_once_ever macro. Close #7748. (fixme cf #8472)
[21:01:30] <ghrust> 13rust/06auto 14b81f5c5 15Ben Blum: small cleanups in task/spawn.rs
[21:01:31] <ghrust> 13rust/06auto 14598072a 15Ben Blum: Don't fail in port.try_recv() the second time. Close #7800.
[21:01:33] *** Parts: ghrust (ghrust@F6EE6DE3.6A2AE50.F3114085.IP) ()
[21:02:00] *** Joins: azita (Azita@moz-BBE3ABD.mv.mozilla.com)
[21:02:45] <brson> mm: Timer should not be implementing RtioTimer
[21:02:45] <bblum> hey, there iam
[21:03:01] <brson> though that may not be the actually problem here
[21:03:11] *** Joins: Florob (Florob@moz-39532932.de)
[21:03:25] *** Quits: brendan (brendaneic@moz-BBE3ABD.mv.mozilla.com) (Quit: brendan)
[21:03:47] <brson> rusti: use std::rt::rtio::RtioTimer; let mut timer = std::rt::io::timer::Timer::new().unwrap(); timer.sleep(0);
[21:03:53] *** Quits: mschifer (Adium@moz-BBE3ABD.mv.mozilla.com) (Quit: Leaving.)
[21:03:53] *** Quits: azita (Azita@moz-BBE3ABD.mv.mozilla.com) (Quit: azita)
[21:03:57] <brson> hm
[21:03:58] *** Quits: eschweic (Adium@moz-BBE3ABD.mv.mozilla.com) (Quit: Leaving.)
[21:04:03] <toddaaro> firedrill time
[21:04:44] *** Quits: msingle (Thunderbir@moz-930E5D97.hr.hr.cox.net) (Quit: msingle)
[21:05:49] *** Quits: tjc (tjc@moz-BBE3ABD.mv.mozilla.com) (Ping timeout)
[21:05:52] *** Quits: jviereck (Adium@moz-AF73A9F4.dip0.t-ipconnect.de) (Quit: Leaving.)
[21:06:14] *** Joins: a__ (a__@moz-25043B93.nycmny.fios.verizon.net)
[21:06:56] *** Joins: tjc (tjc@moz-BBE3ABD.mv.mozilla.com)
[21:06:56] *** ChanServ sets mode: +o tjc
[21:07:11] <acrichto> graydon: ping
[21:07:32] <graydon> acrichto: pong
[21:07:51] <acrichto> graydon: for http://buildbot.rust-lang.org/builders/auto-mac-32-opt/builds/1038/steps/compile/logs/stdio
[21:08:10] <acrichto> would you rather the course of action of fixing the bots or finding a better build system for libuv?
[21:08:36] *** Quits: tjc (tjc@moz-BBE3ABD.mv.mozilla.com) (Ping timeout)
[21:09:15] <graydon> what the
[21:09:25] <acrichto> yeah :(
[21:09:25] <graydon> I suspect "fixing the bots", but what does that even mean?
[21:09:36] <acrichto> are they vnc-able?
[21:09:47] <acrichto> or ssh-able I suppose with the command it suggests
[21:10:18] <myname> for the record, i find that sleep code above pretty ugly
[21:10:32] *** Quits: maik (maik___@moz-BEACDBF.dip0.t-ipconnect.de) (Ping timeout)
[21:12:48] <sully> ok, I think I am just going to disable this test?
[21:12:57] *** sam113101_afk is now known as sam113101
[21:13:05] *** Quits: josh (josh@moz-D3896A24.dhcp.dlth.mn.charter.com) (Quit: josh)
[21:14:25] *** Joins: vodik (simon@moz-396533B6.dsl.bell.ca)
[21:14:28] <nmatsakis> sully: sounds like it, file a bug?
[21:15:17] *** Quits: eatkinson (eatkinson@moz-BBE3ABD.mv.mozilla.com) (Quit: eatkinson)
[21:15:30] <nmatsakis> (presuming you're still talking about that rustpkg test...)
[21:15:51] <Sergio965> If you have something of type T, (call it val), does doing val as *T automatically take the address of val?
[21:16:28] *** Joins: jviereck (Adium@moz-AF73A9F4.dip0.t-ipconnect.de)
[21:16:34] *** Quits: SiegeLord (sl@moz-CAF07B4C.hsd1.ma.comcast.net) (Connection reset by peer)
[21:16:46] *** Quits: jviereck (Adium@moz-AF73A9F4.dip0.t-ipconnect.de) (Client exited)
[21:17:39] <Sergio965> Nevermind.
[21:18:42] *** Joins: SingingBoyo (brandon@4DF3381A.51F4D838.4F048BDC.IP)
[21:19:34] <sully> nmatsakis: yeah
[21:22:14] *** Quits: infynyxx (infynyxx@DB780A29.749BA1D.DCC373F0.IP) (Client exited)
[21:24:42] <Sergio965> Have the way vectors are handled changed between 0.7 and the trunk?
[21:25:07] <kmc> what about it specifically?
[21:26:02] <kmc> there are almost 2000 commits between 0.7 and the current HEAD :)
[21:26:08] <olsonjeffery> la la la refacoring song la la la
[21:26:13] <kmc> and no "as *T" will not take an address, afaik
[21:26:39] <Sergio965> It looks like 0.7 expects an owned vector to have a box header.
[21:26:54] <ion> In http://static.rust-lang.org/doc/tutorial-ffi.html the â€œ#[fixed_stack_segment]; #[inline(never)];â€ is outside the function definition in some examples and inside in others. Is there a difference?
[21:27:10] <Sergio965> Even if it doesn't contained managed objects.
[21:27:22] <Sergio965> But the code for trunk doesn't seem to take this into account.
[21:27:53] <Sergio965> in trunk*
[21:27:53] <SingingBoyo> Is there a way to have something like #[allow(unused_import)] on a doc example?
[21:28:23] <vadimcn> Can anyone here please explain me about test conditionals? 
[21:28:39] <Sergio965> vadimcn: Test conditions? Like assert_eq!()?
[21:28:49] <vadimcn> I mean stuff line  #[ignore(...)]
[21:29:18] <Sergio965> Specifically, for bounds checking, Rust 0.7 seems to look 16 byte after the start of the address of the vector (16 bytes is the size of the box header).
[21:29:22] <Sergio965> bytes*
[21:29:27] <vadimcn> Specifically, to ignore test on windows, should it be  #[ignore(windows)] or  #[ignore(cfg(windows))]  ?
[21:29:54] <Sergio965> The latter.
[21:30:00] <Florob> ion, No, those are the same. However, note that the ones above the function do not have a ';' which makes them apply to the following item, the ones inside have one, which makes them apply to the containing function.
[21:30:04] <strcat> Sergio965: unique pointers/vectors/strings always used to have headers
[21:30:16] <vadimcn> Ok, so what would  #[ignore(windows)] do?
[21:30:18] <Sergio965> strcat: They no longer do?
[21:30:26] <strcat> they no longer do unless they contain managed pointers
[21:30:28] <ion> florob: Ah, thanks.
[21:30:36] <Sergio965> vadimcn: It would ignore that function when compiled under Windows.
[21:30:43] <Sergio965> strcat: That makes sense.
[21:31:11] <Sergio965> strcat: Spent a couple of hours trying to figure out what was going one. Went in with GDB, saw a 16 byte offset, saw that the header was 16 bytes, and finally put two and two together.
[21:31:14] <Sergio965> on*
[21:32:51] <Sergio965> Is there some kind of magic that converts a vector into a slice? How is it that as_imm_buf and to_mut_ptr works for both vectors (~[T]) and slices?
[21:32:52] *** Joins: richard|s (mindginati@moz-C1729134.dsl.clear.net.nz)
[21:33:05] <toddaaro> we survived, no more firedrill
[21:33:25] <brson> real    25m43.332s
[21:33:25] <brson> user    55m37.172s
[21:33:25] <brson> sys     8m52.700s
[21:33:27] *** Joins: eatkinson (eatkinson@moz-BBE3ABD.mv.mozilla.com)
[21:33:29] <brson> er
[21:33:34] <brson> rusti: use std::rt::rtio::RtioTimer; let mut timer = std::rt::io::timer::Timer::new().unwrap(); timer.sleep(1);
[21:33:35] *** Joins: ecr (Thunderbir@moz-BBE3ABD.mv.mozilla.com)
[21:33:47] *** Joins: eschweic (Adium@moz-BBE3ABD.mv.mozilla.com)
[21:33:52] *** Joins: sp3d (a@moz-6F12212B.fidnet.com)
[21:34:05] *** Joins: mschifer (Adium@moz-BBE3ABD.mv.mozilla.com)
[21:34:18] <ecr> graydon: ping
[21:34:28] <Sergio965> work*
[21:34:28] *** Joins: tjc (tjc@moz-BBE3ABD.mv.mozilla.com)
[21:34:28] *** ChanServ sets mode: +o tjc
[21:34:34] <graydon> ecr: pong
[21:34:39] <graydon> toddaaro: PHEW!
[21:34:44] *** Joins: azita (Azita@moz-BBE3ABD.mv.mozilla.com)
[21:34:49] <olsonjeffery> brson: ?
[21:34:56] <olsonjeffery> re: rusti above..
[21:35:04] <ecr> graydon: could I get permissions to label issues on github?
[21:35:20] <graydon> ecr: oh gosh, sure, sorry. you're not in the collaborator groups?
[21:35:26] <ecr> I guess not
[21:35:41] <pcwalton> graydon: preliminary results with my lazy trait loading results indicate a vicinity of 100x speedup for coherence
[21:35:45] <olsonjeffery> Sergio965: vec.slice() , slice_to(), slice_from() etc?
[21:35:47] <pcwalton> however this is preliminary and subject to change
[21:36:07] <olsonjeffery> pcwalton: too late. posted to HN.
[21:36:35] <graydon> pcwalton: 'course
[21:36:45] <Sergio965> olsonjeffery: Nah. For example, from_fn calls to_mut_ptr on ~[T] to get a pointer to the vector's data. But to_mut_ptr returns a pointer to the data of a slice, not a vector.
[21:36:49] <graydon> pcwalton: did I see you poking at resolve yet, or still just coherence?
[21:36:53] <pcwalton> graydon: already done resolve
[21:36:55] <ecr> graydon: my github handle is anasazi btw
[21:36:56] <pcwalton> 10x speedup
[21:37:01] <graydon> pcwalton: wow, that's great!
[21:37:01] <pcwalton> for hello world
[21:37:20] <pcwalton> overall this is coming out to about a 3x speedup
[21:37:20] *** Joins: infynyxx (infynyxx@DB780A29.749BA1D.DCC373F0.IP)
[21:37:21] <SingingBoyo> brson: while your here.  You suggesting marking a doc change as notrust...  Is there a way to just mark it to allow unused_imports instead?
[21:37:23] <pcwalton> for small crates
[21:37:30] <pcwalton> brson is working on the other thing which indicates a large speedup
[21:37:35] <pcwalton> the not-compressing-libstd
[21:37:38] <graydon> oh?
[21:37:40] <pcwalton> yeah
[21:37:50] <graydon> that's weird. make sure you test it on windows too..
[21:37:56] <graydon> it wasn't compressed at first
[21:38:04] <graydon> and I'm pretty sure we compressed it for a speedup
[21:38:34] *** Quits: jorendorff (jorendorff@moz-364496FE.hsd1.tn.comcast.net) (Quit: jorendorff)
[21:38:48] <brson> SingingBoyo: can you provide more background? I don't recall this subject
[21:39:13] <SingingBoyo> https://github.com/mozilla/rust/pull/8639
[21:39:18] <SingingBoyo> brson: ^
[21:39:30] *** Quits: saml (sam@moz-14C16814.cst.lightpath.net) (Quit: Leaving)
[21:39:49] <SingingBoyo> One of the tests failed due to unused imports, as far as I can tell
[21:41:02] <brson> SingingBoyo: yes you should be able to put `# #[allow(unused_imports)]` on some scope in the code, with the extra #, to make that work
[21:41:12] *** Quits: spider-mario (spidermari@moz-81131DB6.fbx.proxad.net) (Input/output error)
[21:41:29] *** Joins: ghrust (ghrust@F6EE6DE3.6A2AE50.F3114085.IP)
[21:41:29] <ghrust> 01[13rust01] 15bors 04force-pushed 06auto from 14859eb4d to 14063a005: 02http://git.io/N3iJvQ
[21:41:29] *** Parts: ghrust (ghrust@F6EE6DE3.6A2AE50.F3114085.IP) ()
[21:42:36] <brson> SingingBoyo: actually, it'll have to go on a fn decl. can't put them on arbitrary scopes
[21:43:11] <ecr> graydon: permissions went through. thanks :)
[21:43:25] *** Quits: Sergio965 (sergiobz@moz-BB21156B.dynamic.csail.mit.edu) (Ping timeout)
[21:43:48] <graydon> ecr: you're also a reviewer now fwiw
[21:44:00] <graydon> use the privileges for good, not evil :)
[21:44:16] <ecr> graydon: of course >:]
[21:44:30] <graydon> ecr: (are you getting triage mail? do you want it?)
[21:44:41] <ecr> graydon: no, but sure
[21:44:54] <SingingBoyo> brson: alright, thanks, I'll find somewhere for it that makes it build cleanly.
[21:45:02] *** Quits: mihneadb (mihneadb@moz-BE33DA21.fw1.sfo1.mozilla.net) (Connection reset by peer)
[21:45:08] <graydon> ecr: preferred email>
[21:45:08] <graydon> ?
[21:45:19] *** Joins: mihneadb (mihneadb@moz-BE33DA21.fw1.sfo1.mozilla.net)
[21:45:43] *** Quits: Jesse (jruderman@moz-BBE3ABD.mv.mozilla.com) (Ping timeout)
[21:45:55] <ecr> graydon: hm, probably my UW email (ecreed@cs.washington.edu)
[21:46:07] <bblum> is_strict_keyword looks like it is buggy (the63 should be a 66), can someone familiar with the parser confirm?
[21:47:14] <brson> bblum: i think it's correct. the strict and reserved keywords don't overlap
[21:47:31] <bblum> brson: oh i see
[21:47:51] <bblum> i missed is_reserved_keyword just below, thanks
[21:48:40] <bblum> not sure why we draw a distinction... is it just for the sake of errors?
[21:49:54] <brson> yes
[21:50:39] <bblum> i see
[21:52:02] <kmc> how do I get a unique ID for the current task, within GDB?
[21:52:14] *** Joins: leonvv (leonvv@moz-7D83A5F1.ip.telfort.nl)
[21:52:16] <sully> hey, so
[21:52:20] <sully> is something up with the tree
[21:52:40] <sully> one of my builds failed due to CR characers and an incorrect license in files that had nothing to do with me
[21:52:45] *** Quits: echristo (echristo@DCF57675.D6CCE4AE.77834EAA.IP) (Quit: echristo)
[21:55:14] <brson> kmc: I haven't done it but if you can figure out the demangled name of std::rt::local::Local::unsafe_borrow::<Task> and call it (or any of the Local methods) then you'll get a pointer value that can be considered like a task id
[21:55:37] <brson> oh there may be a simpler way
[21:55:39] *** Quits: dherman (dherman@moz-6CA476B1.hsd1.ca.comcast.net) (Quit: dherman)
[21:55:42] <acrichto> sully: oh dear that's my fault
[21:56:15] <acrichto> graydon: for the libuv update I downloaded into src/libuv/build/gyp the build system for libuv, and it breaks the makefiles on master so all the bots are failing
[21:56:41] <brson> kmc: well not much simpler but local_ptr::unsafe_take<Task> will give you the same value. still have to find the demangled name
[21:56:50] <jld> nmatsakis: So ty_bare_fn is extern "C" fn?
[21:56:53] <acrichto> graydon: I think that specific directory will need to get cleaned from the bots for now, I can make a separate pull request to fix the makefiles later
[21:56:53] <graydon> so I should shut off bors?
[21:56:58] <graydon> ok, bors off
[21:57:01] <brson> kmc: can probably break on pthread_getspecific to find the names somewhere in the backtrace
[21:57:11] <sully> acrichto: :(
[21:57:23] <kmc> brson: ok, thanks
[21:57:40] <jld> (This might make more sense to me if I'd been following the changes in extern fn and such lately.)
[21:57:56] *** Joins: adridu59 (Mibbit@moz-6C393FDD.rev.numericable.fr)
[21:58:31] <adridu59> is the next Rust release planned already?
[21:58:50] <acrichto> graydon: r? https://github.com/mozilla/rust/pull/8688
[21:59:01] <acrichto> with a p=N then bors can be re-enabled
[21:59:46] <graydon> acrichto: oh, ok
[22:00:05] <graydon> bors re-enabled
[22:00:07] *** Joins: ChrisMorgan (chris@moz-6AC741CA.static.tpgi.com.au)
[22:00:09] <graydon> (do I have to go clean the bots?
[22:00:10] <graydon> )
[22:00:18] <graydon> adridu59: we do releases every 3 months
[22:00:21] <acrichto> not if that request goes through first
[22:00:30] *** Joins: sevvie (sevvierose@moz-8BC5868E.hfc.comcastbusiness.net)
[22:00:43] <graydon> acrichto: ok, thanks.
[22:00:48] <brson> adridu59: scheduled for the first week of october
[22:00:54] <acrichto> I'll @bors: retry the failed pulls as well
[22:01:00] <adridu59> thanks for the info
[22:01:08] <strcat> bblum: that keyword stuff is a PITA :(
[22:01:13] <strcat> needs to be redone
[22:01:23] <strcat> rusti: let pure = 5;
[22:01:23] -rusti- <anon>:5:13: 5:17 error: `pure` is a reserved keyword
[22:01:23] -rusti- <anon>:5          let pure = 5;
[22:01:23] -rusti-                       ^~~~
[22:01:23] -rusti- application terminated with error code 101
[22:01:26] <strcat> rusti: let for = 5;
[22:01:26] -rusti- <anon>:5:9: 5:12 error: found `for` in ident position
[22:01:26] -rusti- <anon>:5          let for = 5;
[22:01:26] -rusti-                   ^~~
[22:01:27] -rusti- error: aborting due to previous error
[22:01:29] -rusti- application terminated with error code 101
[22:01:38] <strcat> anyway hardcoded indices ftl
[22:02:15] <erickt> graydon: ping
[22:02:29] <jeaye> strcat: Why would I only be able to capture a mutable stack variable from a &fn and not @fn or ~fn?
[22:02:53] <graydon> erickt: pong
[22:03:20] <sully> acrichto: eta to repair?
[22:03:25] <acrichto> sully: already fixed
[22:03:32] <erickt> graydon: hey there! got a moment to chat about serialization?
[22:03:34] <sully> ok
[22:03:37] <acrichto> sully: or rather bors will take an hour or so to merge it
[22:03:43] <sully> so what happened?
[22:04:43] *** Joins: lkuper_ (lkuper@moz-D862222C.dhcp-bl.indiana.edu)
[22:04:58] <acrichto> for binding to libuv processes, it required updating libuv. Now libuv uses a different build system than before, and this build system requires downloading some gyp thing from google. This gyp thing was located inside of src/libuv, and it had some files named `*.rc`. As a result, these files were detected by the `make tidy` target and errored as a result. To fix, I changed `make tidy` to ignore src/libuv and src/llvm (for any future updates)
[22:05:38] <bblum> thanks for the prompt fix acrichto 
[22:05:41] <sully> and it didn't fail the first time because the files hadn't been created until after make tidy ran?
[22:05:56] <sully> and so the second build it did with them killed it?
[22:06:02] <acrichto> sully: in my pull request I had already altered the makefiles to ignore libuv/llvm, but the pull request bounced but had a dirty tree
[22:06:15] <acrichto> but master didn't have my makefile fixes
[22:07:09] <acrichto> graydon: you turned down the bors polling frequency to 10 minutes, right?
[22:07:55] <veddan> is it possible to write a macro for implementing a trait?
[22:08:22] <veddan> like `impl_my_trait!(u8)`
[22:08:36] <engla> normally yes
[22:08:42] <graydon> acrichto: I did. I can turn it back up probably, now that we're lower down. but I would also really like to turn V back on.
[22:08:53] <graydon> acrichto: is 10 min too slow? 5 will probably work fine.
[22:08:56] *** Joins: fn_apply0 (fn_apply0@moz-78F0587F.ca.astound.net)
[22:08:58] <veddan> ignore me, I made a silly mistake
[22:09:15] <graydon> I'll try 5, see if it overflows again
[22:09:17] <acrichto> graydon: I figured that with a 10min polling frequency it could add up to 20 mins to each pull request which may add up after awhile
[22:09:23] <graydon> yeah, it's true
[22:09:28] <acrichto> graydon: also the queue is much smaller now so valgrind could probably come back on
[22:09:37] <erickt> graydon: so about the connection between serialization and generators
[22:09:45] <graydon> erickt: yes! do tell, I'm curious :)
[22:10:10] *** Joins: dwhyte (dwhyte@1922756A.EDC594B0.7BF4A4B0.IP)
[22:10:15] <erickt> graydon: it's all about the auto derivation syntax extension for Encodable and Decodable
[22:10:20] <adridu59> so that's why bors took 2 hours for each commit lol, seeing Google servers not responding was weird indeed
[22:10:35] *** Quits: valenting (Thunderbir@8758046C.84D5EFD5.FB866788.IP) (Ping timeout)
[22:11:05] <adridu59> is bors opensourced?
[22:11:32] *** Joins: brendan (brendaneic@moz-BBE3ABD.mv.mozilla.com)
[22:11:44] <erickt> graydon: when I convert Encodable to be an iterator, the implementations of Encodable will need to somehow track where they are in a structure
[22:11:48] *** Quits: Florob (Florob@moz-39532932.de) (Client exited)
[22:11:51] *** AutomatedTester is now known as AutomatedTester|AFK
[22:11:56] <graydon> adridu59: yes, I got approval to publish the source recently. github.com/graydon/bors
[22:12:08] <adridu59> nice, thanks graydon!
[22:12:25] <erickt> graydon: the simplest is to just use a state machine, where each state is a separate item in the structure
[22:12:30] <graydon> adridu59: if you find a glaring security hole, please let me know :)
[22:12:57] <erickt> graydon: in order to support #[deriving(Encodable)
[22:13:07] <sully> graydon: is it all right if I add a commit ignoring a bogus rustpkg test to my PR and mark it r=graydon?
[22:13:15] *** Joins: sk (sk@61A494B3.BA40E8A.AAC02D62.IP)
[22:13:30] <graydon> sully: um, can you consult with tjc about it?
[22:13:49] <erickt> graydon: the compiler will have to auto-generate the state machine. Doing this process is not *that* dissimilar to generating a state machine to drive a generator
[22:13:52] <sully> tjc: ping
[22:13:58] <graydon> erickt: I guess. don't you also potentially need a stack of where you're at in the structure?
[22:13:59] <tjc> sully: you can ignore the test, just make an issue and assign it to me
[22:14:05] <sully> ok
[22:15:04] <erickt> graydon: yeah. doing that is also not that dissimilar to dealing with loops in a generator
[22:16:07] <graydon> erickt: really? I'd have thought it's more like dealing with sub-generators inside a generator
[22:16:16] <graydon> erickt: suppose you're serializing a linked list...
[22:16:22] *** Quits: sp3d (a@moz-6F12212B.fidnet.com) (Ping timeout)
[22:16:32] *** Joins: ghrust (ghrust@C8693FCB.6A2AE50.F3114085.IP)
[22:16:32] <ghrust> 01[13rust01] 15bors 04force-pushed 06auto from 14d1a7aa8 to 14063a005: 02http://git.io/N3iJvQ
[22:16:32] *** Parts: ghrust (ghrust@C8693FCB.6A2AE50.F3114085.IP) ()
[22:16:34] *** Joins: ghrust (ghrust@1E8607E8.6A2AE50.F3114085.IP)
[22:16:34] <ghrust> 01[13rust01] 15bors pushed 2 new commits to 06auto: 02http://git.io/w1dlAA
[22:16:34] <ghrust> 13rust/06auto 14d765522 15Alex Crichton: Don't attempt to run tidy over libuv or llvm
[22:16:34] <ghrust> 13rust/06auto 14f858452 15bors: auto merge of #8688 : alexcrichton/rust/fix, r=graydon
[22:16:34] *** Parts: ghrust (ghrust@1E8607E8.6A2AE50.F3114085.IP) ()
[22:16:35] <graydon> or rather, a tree. so you have to return to structures you already descended into
[22:17:39] <erickt> graydon: that's exactly what I'm thinking about doing. if we had generators, serialization iterators would be trivial
[22:18:31] <jeaye> graydon: What's bors' license?
[22:18:39] <kmc> brson et al: how can I tell from Rust code whether I'm in the 'cleanup' phase of a task, when annihilate() etc. run?
[22:18:48] <graydon> jeaye: oh, I forgot to put a license on it. duh.
[22:18:51] <jeaye> :)
[22:19:22] *** Quits: cowboyd (cowboyd@moz-1BD02A1E.sw.biz.rr.com) (Client exited)
[22:19:22] <erickt> graydon: for example, `struct A { x: int, y: ~[float] }` would have `fn encode(&mut self) -> Value { yield self.x.encode(); for y in self.y.encode() { yield y; } }`
[22:19:24] *** Quits: q66 (q66@6EE9DE40.46454B5D.33AABD5F.IP) (Quit: Leaving)
[22:19:34] *** Joins: Nisstyre (wes@moz-FD86289.netflash.net)
[22:19:41] <graydon> erickt: um, that's probably true. let's back up a step: I only very, very vaguely "liked the sound" of you doing iterators-for-serialization on the basis that it sounded plausible that it might generate less code than the current one (which seems to generate quite a lot). what's the deeper motive at work here?
[22:19:46] *** Quits: ChrisMorgan (chris@moz-6AC741CA.static.tpgi.com.au) (Ping timeout)
[22:19:47] <adridu59> graydon: not familiar with Python but I'll take a look at it, seems interesting
[22:20:16] <graydon> erickt: (not saying it's a bad idea, but this is a ways down a path and I'm not sure how deep we need to be going vs. are just meandering out of speculation)
[22:20:56] <erickt> graydon: I had a couple parallel interests that converged in my head
[22:21:02] *** Joins: dherman (dherman@moz-6CA476B1.hsd1.ca.comcast.net)
[22:21:02] *** ChanServ sets mode: +o dherman
[22:21:11] *** Quits: dherman (dherman@moz-6CA476B1.hsd1.ca.comcast.net) (Quit: dherman)
[22:21:36] <erickt> graydon: first, I'm still not thrilled by the recursive methods in serialize.rs and it'd be nice to use iterators
[22:21:56] *** Quits: azita (Azita@moz-BBE3ABD.mv.mozilla.com) (Quit: azita)
[22:21:58] <erickt> graydon: second, there's the metadata issue.
[22:22:15] *** Quits: jdm (jdm@97DF0582.DEAB171B.971E19F6.IP) (Quit: Lost terminal)
[22:22:28] <fn_apply0> Is it possible to do something like "let arr: [int, ..10] = {0}" in rust? Or do I need to initialize all 10 elements by hand?
[22:22:29] <erickt> graydon: third, I'd like some compiler support to make my ragel state machine generator faster
[22:22:47] <graydon> what sort of compiler support? 
[22:22:50] <erickt> fn_apply0: try `vec::from_elem(10, 0)`
[22:22:54] <graydon> like code gen or like frontend stuff?
[22:22:58] <fn_apply0> thanks
[22:23:07] * graydon smells "computed gotos" :)
[22:23:24] <erickt> graydon: I think I just need classical gotos :)
[22:23:27] <engla> fn_apply0: let arr = [0, ..10]
[22:23:39] <fn_apply0> oooh
[22:23:43] *** Quits: victorporof (victorporo@256FD045.43CE31D0.9B1E38F4.IP) (Ping timeout)
[22:23:44] <strcat> inline LLVM IR! ;p
[22:23:58] <aatch> graydon, the C code ragel generates doesn't have computed gotos
[22:24:03] <erickt> graydon: dbaupp and I have been playing around with a way to do constrained gotos
[22:24:26] <aatch> I've only really seen computed gotos in vm implementations.
[22:24:28] <graydon> how's that?
[22:24:39] <graydon> aatch: yeah, they're like "semi-jits"
[22:24:44] <graydon> can be quite effective
[22:24:46] <graydon> but anyway
[22:25:24] <erickt> graydon: where we somehow extend match to essentially allow for gotos. For example, in pseudo-rust we could do `match 'a { 'a => { loop 'b; } 'b => { loop 'c } 'c => {} }`
[22:26:21] <erickt> or something of that ilk
[22:26:34] <graydon> hopefully not _quite_ that syntax, but I get your meaning..
[22:26:50] <graydon> we talked some before about using loop + labeled blocks this way for sideways jumps
[22:26:56] <graydon> I think there's an issue on it somewhere
[22:27:23] <erickt> ooh, I'll see if I can find it
[22:27:43] <bjz_> rusti: extern "C" fn f() { println("hi") }
[22:27:44] -rusti- ()
[22:27:51] <bjz_> rusti: extern "C" fn f() { println("hi") } f()
[22:27:52] -rusti- <anon>:5:45: 6:5 error: expected function but found `*u8`
[22:27:52] -rusti- <anon>:5          extern "C" fn f() { println("hi") } f()
[22:27:52] -rusti- <anon>:6     };
[22:27:52] -rusti- error: aborting due to previous error
[22:27:52] -rusti- application terminated with error code 101
[22:28:20] <bjz_> huh
[22:28:40] *** Quits: brson (brson@moz-BBE3ABD.mv.mozilla.com) (Ping timeout)
[22:28:47] <bjz_> maybe rusti is old
[22:28:53] <strcat> rusti: extern "C" fn f() { println("hi") } f()
[22:28:54] -rusti- <anon>:5:45: 5:46 error: invoking non-Rust fn in fn without #[fixed_stack_segment] [-D cstack (default)]
[22:28:54] -rusti- <anon>:5          extern "C" fn f() { println("hi") } f()
[22:28:54] -rusti-                                                       ^
[22:28:54] -rusti- error: aborting due to previous error
[22:28:54] -rusti- application terminated with error code 101
[22:29:20] <strcat> rusti: #[fixed_stack_segment]; extern "C" fn f() { println("hi") } f()
[22:29:21] -rusti- <anon>:5:30: 5:31 error: expected item after attributes
[22:29:21] -rusti- <anon>:5          #[fixed_stack_segment]; extern "C" fn f() { println("hi") } f()
[22:29:21] -rusti-                                        ^
[22:29:21] -rusti- error: aborting due to previous error
[22:29:21] -rusti- application terminated with error code 101
[22:29:29] <strcat> oh right it's not at the top
[22:29:36] *** Quits: vodik (simon@moz-396533B6.dsl.bell.ca) (Quit: WeeChat 0.4.2-dev)
[22:29:46] <strcat> rusti: fn foo() { #[fixed_stack_segment]; extern "C" fn f() { println("hi") } f() } foo()
[22:29:48] -rusti- hi
[22:29:48] -rusti- ()
[22:29:52] <graydon> erickt: https://github.com/mozilla/rust/wiki/Meeting-weekly-2012-08-14
[22:29:54] <erickt> graydon: so for my purposes, I believe the current semantics of `loop 'a` would satisfy my needs for ragel. My ragel generator pre-allocates everything before the state machine
[22:29:57] <aatch> I think if the static analysis was conservative in the presence of goto (or goto-like) it would allow for the kind of state machine code Ragel generates without breaking safety too badly.
[22:30:00] *** Joins: sp3d (a@moz-6F12212B.fidnet.com)
[22:30:08] <aatch> (or at all)
[22:30:16] <erickt> graydon: thanks
[22:30:28] <graydon> erickt: yeah, loop 'a that could jump sideways from one loop to another was all (I think) we were discussing back then.
[22:30:36] <graydon> erickt: currently it only lets you jump outwards
[22:30:41] *** Joins: jensnockert (jensnocker@moz-8BE55278.customer.t3.se)
[22:30:49] <bjz_> rusti: extern "C" unsafe fn f() {}
[22:30:49] -rusti- <anon>:5:20: 5:26 error: expected `{` or `mod` but found `unsafe`
[22:30:49] -rusti- <anon>:5          extern "C" unsafe fn f() {}
[22:30:49] -rusti-                              ^~~~~~
[22:30:50] -rusti- application terminated with error code 101
[22:30:59] <bjz_> rusti: unsafe extern "C" fn f() {}
[22:30:59] -rusti- <anon>:5:16: 5:22 error: expected `fn`, found `extern`
[22:30:59] -rusti- <anon>:5          unsafe extern "C" fn f() {}
[22:31:00] -rusti-                          ^~~~~~
[22:31:00] -rusti- application terminated with error code 101
[22:31:32] <erickt> graydon: hrm, both pcwalton and nmatsakis seem resistant to the idea
[22:31:35] <graydon> yeah
[22:31:36] <bjz_> nmatsakis: is there a way of marking an etern fn unsafe?
[22:31:43] *** Quits: vosen (vosen@moz-266BA656.icpnet.pl) (Quit: Leaving)
[22:31:47] <graydon> I wasn't deeply keen on it either. just pointing out it came up before.
[22:31:53] <aatch> I thought they were unsafe by default?
[22:32:45] <bjz_> aatch: strcat seems to have called one fine
[22:33:02] <bjz_> aatch: oh, I mean a user-defined extern fn
[22:33:18] <erickt> graydon: I'm pretty sure llvm doesn't compile a loop-match into a goto soup, but I'll confirm
[22:33:28] <graydon> erickt: should probably also point out that niko is part way through (or perhaps all-the-way-through) converting to a more general cfg in the middle-portions of the compiler, so his comment about breaking block-based-reasoning is no longer certain. you should probably ask him, this is past my knowledge.
[22:34:13] <bjz_> nmatsakis: basically, I want a function that calls a C fn to be inlined and for the fixed_stack_segment choice to be pushed up a level
[22:34:38] *** Quits: lmandel (lmandel@moz-BE33DA21.fw1.sfo1.mozilla.net) (Ping timeout)
[22:34:39] *** Quits: jensnockert (jensnocker@moz-8BE55278.customer.t3.se) (Input/output error)
[22:34:46] <bjz_> nmatsakis: but I also need to mark some of them unsafe
[22:35:04] <sully> oh, hm
[22:35:17] <graydon> jeaye: now licensed
[22:35:23] <sully> acrichto told bors to retry my PR, and then I added something to it...
[22:35:36] *** Joins: lmandel (lmandel@moz-BE33DA21.fw1.sfo1.mozilla.net)
[22:35:52] <acrichto> sully: r+
[22:36:45] *** Joins: Sergio965 (sergiobz@moz-8D9DFEEF.hsd1.ma.comcast.net)
[22:36:59] *** Quits: RayWizard (kvirc@E248DB08.9470356F.5B864609.IP) (Ping timeout)
[22:37:16] <jeaye> graydon: Thanks. :)
[22:38:38] <erickt> graydon: I think my constrained gotos would avoid the issue nmatsakis was referring to. the labels would follow the same rules as match variants, so it'd be impossible to jump into a loop
[22:39:10] <sully> acrichto: thanks
[22:40:21] *** Quits: mschifer (Adium@moz-BBE3ABD.mv.mozilla.com) (Connection reset by peer)
[22:40:21] *** Joins: mschifer (Adium@moz-BBE3ABD.mv.mozilla.com)
[22:40:50] *** Quits: sp3d (a@moz-6F12212B.fidnet.com) (Ping timeout)
[22:41:39] <erickt> graydon: although I wonder if it would be simpler to write a optimization pass that converted a `loop { match state { state1 => { state = state2; ...` into a goto soup
[22:42:20] *** Quits: eatkinson (eatkinson@moz-BBE3ABD.mv.mozilla.com) (Quit: eatkinson)
[22:43:15] <graydon> erickt: I don't know, off hand. I basically don't mind either idea; I just worry about timetables and feature creep, stability, the usual things that keep me up at night.
[22:43:21] *** Joins: josh (josh@moz-D3896A24.dhcp.dlth.mn.charter.com)
[22:43:45] <graydon> if it waits until rust 1.2 or something, is that bad?
[22:43:52] *** Joins: eatkinson (eatkinson@moz-BBE3ABD.mv.mozilla.com)
[22:44:35] *** Joins: sp3d (a@moz-6F12212B.fidnet.com)
[22:44:54] *** Quits: sebcrozet (sebcrozet@moz-6DA639AF.w80-13.abo.wanadoo.fr) (Quit: Gone)
[22:45:33] <erickt> graydon: got to do a meetung now back in a bit
[22:46:14] <nmatsakis> bjz_: all extern fn are unsafe, I think?
[22:46:25] <nmatsakis> graydon: my opposition to constrained `goto` has ... softened
[22:46:34] <pcwalton> bah, broke default methods
[22:46:41] <sully> oh?
[22:46:42] <pcwalton> needs a good amount of metadata work to make them work
[22:46:50] <pcwalton> with this lazy trait loading thing
[22:46:54] <pcwalton> I think I know what needs to be done
[22:46:56] <pcwalton> working on it
[22:47:04] <sully> yeah, the metadata is tricky for default methods
[22:47:14] <sully> what are you trying to do?
[22:47:18] *** Quits: Sergio965 (sergiobz@moz-8D9DFEEF.hsd1.ma.comcast.net) (Quit: My MacBook Pro has gone to sleep. ZZZzzzâ€¦)
[22:47:38] <pcwalton> loading trait method info lazily (upon method call) instead of eagerly
[22:47:48] <pcwalton> this results in a 100x speedup for coherence on hello world
[22:47:55] <pcwalton> but it requires care to avoid breaking default methods
[22:48:44] <pcwalton> since trans_fn_ref_with_vtables now has to load a trait from the metadata if it's transing a default method, in order to figure out whether it is a default method
[22:49:29] <erickt> graydon: not really. I see optimizing state machines with gotos as a low priority thing
[22:50:02] <erickt> nmatsakis: oh really? what softened your position on them?
[22:51:14] <sully> yeah, it shouldn't be too hard to abstract that out to do metadata checks if it cross crate
[22:51:30] *** Joins: Sojourn (Mibbit@moz-9DD0F4FC.icsincorporated.com)
[22:51:58] <erickt> graydon: btw, here are some of the other syntaxes dbaupp and I were playing around with to support classic gotos and computed gotos: https://gist.github.com/huonw/6145412 
[22:52:17] <sully> are we thinking of addings gotos...?
[22:52:39] <sully> I love goto as much as the next person, but...
[22:53:10] <erickt> sully: not really, but more active support for state machines
[22:53:24] <erickt> I'm calling the idea a constrained goto
[22:54:22] <toddaaro> what exactly does this do that optimized functions don't?
[22:55:04] <toddaaro> "they couldn't do TCO so they brought back GOTO" is not a flattering article title
[22:55:06] *** Joins: dherman (dherman@moz-6CA476B1.hsd1.ca.comcast.net)
[22:55:06] *** ChanServ sets mode: +o dherman
[22:55:09] *** Quits: dherman (dherman@moz-6CA476B1.hsd1.ca.comcast.net) (Quit: dherman)
[22:55:13] <erickt> hah
[22:55:22] <graydon> none of those look like computed goto, if I'm reading right..
[22:55:26] *** Joins: alexrp (zor@moz-180BED6.rfw.name)
[22:55:31] *** Quits: huseby (huseby@19BD73A1.5D8BCA3A.A0C1B52F.IP) (Quit: Leaving)
[22:55:43] <erickt> graydon: it's the computed.rs
[22:55:59] <graydon> ah I see
[22:56:02] <erickt> toddaaro: yeah, it's an optimization the compiler could do
[22:56:11] <erickt> graydon: I don't think it'd work though.
[22:56:27] *** Quits: eschweic (Adium@moz-BBE3ABD.mv.mozilla.com) (Quit: Leaving.)
[22:56:37] *** Joins: eschweic (Adium@moz-BBE3ABD.mv.mozilla.com)
[22:56:40] <toddaaro> erickt: ok, so there is no goto in user accessible code
[22:56:59] <strcat> toddaaro: rust has TCO, it's just not guaranteed TCO
[22:57:00] *** Quits: eschweic (Adium@moz-BBE3ABD.mv.mozilla.com) (Connection reset by peer)
[22:57:00] *** Joins: eschweic (Adium@moz-BBE3ABD.mv.mozilla.com)
[22:57:07] <strcat> we run tailcallelim
[22:57:07] <graydon> toddaaro: well, yeah, that's option (b) which we've always considered as the plausible-yet-costly form of reviving 'be', which is to only permit it on really-local sets of functions. like say "can't cross a crate boundary, or call any first class functions, or be turned into a first class function"
[22:57:40] *** Quits: Scriptor (historium@moz-E06F46F0.corp.bitshelter.com) (Quit: Scriptor)
[22:57:47] <erickt> toddaaro: but I'm finding I'm writing a lot of state machines recently, and I find jumping between variant arms to be more understandable than doing `loop { match state { ... `
[22:57:53] <strcat> graydon: or work on some architectures
[22:57:55] <strcat> possibly ARM
[22:58:02] <graydon> oh, yeah. that too :(
[22:58:25] <strcat> sibling call optimization can be guaranteed, just not general TCO
[22:58:31] *** Joins: goffrie (goffrie@moz-BF2A8336.dsl.ncf.ca)
[22:58:36] *** alexrp is now known as Zor
[22:58:58] *** Quits: lmandel (lmandel@moz-BE33DA21.fw1.sfo1.mozilla.net) (Quit: lmandel)
[22:59:14] *** Quits: reyre (reyre@moz-9002CDDA.cpe.net.cable.rogers.com) (Client exited)
[22:59:31] *** Quits: brendan (brendaneic@moz-BBE3ABD.mv.mozilla.com) (Quit: brendan)
[23:01:07] <erickt> strcat: do sibling calls depend on just the function arguments being the same? Or do they also need to take up the same amount of stack space?
[23:01:13] <bjz_> nmatsakis: is there a way of ensuring a function is inlined, then bumping up fixed_stack_segment thing up to the next caller?
[23:02:35] *** Quits: eatkinson (eatkinson@moz-BBE3ABD.mv.mozilla.com) (Quit: eatkinson)
[23:03:37] <Eridius> is there any documentation on fixed_stack_segment? e.g. when you're supposed to use it? My guess is you should use it if you're going to be calling multiple C functions (but not if you just call one), is this correct?
[23:03:42] <bjz_> nmatsakis: basically I have `#[inline] pub fn End() -> c_void { unsafe { (storage::End.f)() } }` where the field `f` is an extern fn pointer
[23:03:56] <bjz_> Eridius: in the ffi tute
[23:04:03] *** Quits: josh (josh@moz-D3896A24.dhcp.dlth.mn.charter.com) (Quit: josh)
[23:04:21] <bjz_> Eridius: http://static.rust-lang.org/doc/tutorial-ffi.html
[23:04:21] *** Joins: azita (Azita@moz-BBE3ABD.mv.mozilla.com)
[23:04:38] *** Joins: brendan (brendaneic@moz-BBE3ABD.mv.mozilla.com)
[23:04:41] *** Quits: donri (dag@moz-9BB61102.tbcn.telia.com) (Client exited)
[23:04:49] <Eridius> bjz_: ah, didn't realize that got updated
[23:05:28] *** Joins: brson (brson@moz-BBE3ABD.mv.mozilla.com)
[23:05:28] *** ChanServ sets mode: +o brson
[23:05:47] *** Quits: josedonizetti (josedonize@DF22210B.35D9DDB.8EF76F75.IP) (Ping timeout)
[23:06:05] <bjz_> nmatsakis: would it be ok to inline a function like that?
[23:08:17] <fn_apply0> how can I convert &mut T to &mut [u8] without non-scalar cast error?
[23:08:20] *** Quits: maxli (maxli@13F2CEC5.7672369.D8E68FF6.IP) (Quit: Leaving.)
[23:08:44] <pcwalton> you can't
[23:08:49] <pcwalton> they have different sizes
[23:08:52] <pcwalton> what are you trying to do?
[23:09:07] <Eridius> if I need to run a block of code and ensure it stays on the same OS thread (i.e. if the task deschedules, it won't get rescheduled on another thread), is the only solution to spawn a new task in SingleThreaded mode, and wait for it to complete?
[23:10:03] <fn_apply0> trying to use Reader to read data into a struct
[23:10:05] *** Quits: azita (Azita@moz-BBE3ABD.mv.mozilla.com) (Quit: azita)
[23:10:12] *** Joins: mschifer1 (Adium@moz-BBE3ABD.mv.mozilla.com)
[23:10:16] *** Quits: squiddy_ (squiddy@moz-1E8AEB3B.adsl.alicedsl.de) (Input/output error)
[23:10:17] <fn_apply0> and converting the struct as & [u8]
[23:10:18] *** Quits: mschifer (Adium@moz-BBE3ABD.mv.mozilla.com) (Connection reset by peer)
[23:11:13] <strcat> erickt: just args being the same
[23:11:25] <Eridius> fn_apply0: that sounds dangerous. But if you really want to, you could convert it to a *u8, then convert that to a ~[u8] using vec::raw::from_buf_raw() (and std::sys::size_of() to get the size of the struct)
[23:11:37] <strcat> erickt: well the whole signature (ret value too)
[23:11:41] <Eridius> actually a ~[u8] is wrong ,because that owns
[23:11:57] <Eridius> vec::raw::mut_buf_as_slice() would give you a &mut [u8]
[23:12:24] <erickt> strcat: thanks. Maybe I'll try a pass at getting ragel to generate sibling functions
[23:12:31] *** Quits: leonvv (leonvv@moz-7D83A5F1.ip.telfort.nl) (Client exited)
[23:13:03] <strcat> erickt: also make sure they're private
[23:13:20] <fn_apply0> basically want to do something like: reader.read(reinterpret_cast<char *>(pData), sizeof(Data))
[23:13:47] <fn_apply0> converting some C++ code to rust
[23:13:56] <fn_apply0> maybe there is a smarter way to do this though
[23:14:02] <Eridius> rusti: struct Foo(int, int) let x = Foo(2, 3); do std::vec::raw::buf_as_slice(&x, std::sys::size_of_val(x)) |buf: &[u8]| { printfln!(buf) }
[23:14:09] -rusti- line longer than 150 columns, pastebinned 4 lines of output: http://ix.io/7uZ
[23:14:16] <Eridius> rusti: struct Foo(int, int); let x = Foo(2, 3); do std::vec::raw::buf_as_slice(&x, std::sys::size_of_val(x)) |buf: &[u8]| { printfln!(buf) }
[23:14:19] -rusti- pastebinned 11 lines of output: http://ix.io/7v0
[23:14:34] <Eridius> rusti: struct Foo(int, int); let x = Foo(2, 3); do std::vec::raw::buf_as_slice(&x, std::sys::size_of_val(&x)) |buf: &[u8]| { printfln!(buf) }
[23:14:37] -rusti- pastebinned 8 lines of output: http://ix.io/7v1
[23:14:57] <Eridius> oh I didn't cast the pointer, silly me
[23:15:18] <Eridius> rusti: let x: int = 0; &x as *u8
[23:15:19] -rusti- <anon>:5:25: 5:27 error: mismatched types: expected `*u8` but found `&int` (expected u8 but found int)
[23:15:19] -rusti- <anon>:5          let x: int = 0; &x as *u8
[23:15:19] -rusti-                                   ^~
[23:15:19] -rusti- error: aborting due to previous error
[23:15:19] -rusti- application terminated with error code 101
[23:15:23] <Eridius> rusti: let x: int = 0; &x as *int as *u8
[23:15:24] -rusti- 139960990679216
[23:15:41] <Eridius> rusti: struct Foo(int, int); let x = Foo(2, 3); do std::vec::raw::buf_as_slice(&x, std::sys::size_of_val(&x as *Foo as *u8)) |buf| { printfln!(buf) }
[23:15:43] -rusti- line longer than 150 columns, pastebinned 5 lines of output: http://ix.io/7v2
[23:15:55] <Eridius> oops wrong one
[23:16:03] <Eridius> rusti: struct Foo(int, int); let x = Foo(2, 3); do std::vec::raw::buf_as_slice(&x as *Foo as *u8, std::sys::size_of_val(&x)) |buf| { printfln!(buf) }
[23:16:05] -rusti- line longer than 150 columns, pastebinned 5 lines of output: http://ix.io/7v3
[23:16:23] <Eridius> rusti: struct Foo(int, int); let x = Foo(2, 3); unsafe { do std::vec::raw::buf_as_slice(&x as *Foo as *u8, std::sys::size_of_val(&x)) |buf| { printfln!(buf) } }
[23:16:24] -rusti- &[2, 0, 0, 0, 0, 0, 0, 0, 3, 0, 0, 0, 0, 0, 0, 0]
[23:16:24] -rusti- ()
[23:16:26] <Eridius> there we go
[23:16:27] *** Quits: infynyxx (infynyxx@DB780A29.749BA1D.DCC373F0.IP) (Client exited)
[23:16:30] <Eridius> fn_apply0: ^
[23:16:31] <sully> sigh
[23:16:45] <sully> I love when I find bugs that are clearly easier to fix than they were to document and file
[23:16:51] <Eridius> never seen a use for `a as b as c` before
[23:17:41] *** Quits: sevvie (sevvierose@moz-8BC5868E.hfc.comcastbusiness.net) (Quit: bye~)
[23:18:37] <fn_apply0> ah thanks
[23:19:44] <Eridius> rusti: struct Foo(int, int); let mut x = Foo(2, 3); unsafe { do std::vec::raw::mut_buf_as_slice(&mut x as *mut Foo as *mut u8, std::sys::size_of_val(&x)) |buf { buf[0] = 7; }; x
[23:19:44] -rusti- <anon>:8:0: 8:1 error: file ended with unbalanced delimiters
[23:19:44] -rusti- <anon>:8 }
[23:19:44] -rusti-          ^
[23:19:44] -rusti- application terminated with error code 101
[23:19:50] <Eridius> rusti: struct Foo(int, int); let mut x = Foo(2, 3); unsafe { do std::vec::raw::mut_buf_as_slice(&mut x as *mut Foo as *mut u8, std::sys::size_of_val(&x)) |buf| { buf[0] = 7; }; x
[23:19:50] -rusti- <anon>:8:0: 8:1 error: file ended with unbalanced delimiters
[23:19:50] -rusti- <anon>:8 }
[23:19:51] -rusti-          ^
[23:19:51] -rusti- application terminated with error code 101
[23:19:58] <Eridius> rusti: struct Foo(int, int); let mut x = Foo(2, 3); unsafe { do std::vec::raw::mut_buf_as_slice(&mut x as *mut Foo as *mut u8, std::sys::size_of_val(&x)) |buf| { buf[0] = 7; } }; x
[23:19:59] -rusti- {__field__: 7, __field__: 3}
[23:20:25] <Eridius> I have to wonder if %? should maybe print that as `Foo(7,3)`
[23:21:05] <Seldaek> I was doing propaganda earlier and someone asked me if rust's owned pointers are similar to c++'s auto_ptr, sounds similar to me but I don't know the specifics of auto_ptr. Can anyone enlighten me on that?
[23:21:18] <Eridius> Seldaek: more like C++11's unique_ptr
[23:21:31] <Eridius> auto_ptr isn't very safe to use, but until C++11 you couldn't make a safe version
[23:21:43] <Seldaek> okay thanks :)
[23:21:51] *** Quits: sigma (sigma@51C589B3.EF2694B5.DFAC6AA7.IP) (Ping timeout)
[23:21:58] <Eridius> Seldaek: auto_ptr transfers ownership of a memory buffer every time it's copied, leaving the old object behind with a null buffer. But the compiler could not prevent you from still using the old object
[23:22:12] *** Joins: maik (maik___@moz-BEACDBF.dip0.t-ipconnect.de)
[23:22:14] <Eridius> unique_ptr uses C++11's move semantics to transfer ownership on a move, and prohibit copying, which means that you cannot re-use the old value as it's been moved
[23:23:07] *** Quits: ecr (Thunderbir@moz-BBE3ABD.mv.mozilla.com) (Quit: ecr)
[23:23:17] <strcat> Eridius: actually in C++ you can reuse the old value
[23:23:35] <strcat> it's in an undefined state, but you are allowed to assign to it
[23:23:41] <Eridius> strcat: ah true, but you can't read, right?
[23:23:52] <strcat> Eridius: well a specific type might be able to define it
[23:23:57] <strcat> but I don't think it is for the stdlib
[23:24:39] <strcat> for example you could move types one by one from a vector
[23:25:19] <bjz_> Eridius: it's probably not implemented yet :P (the %? thing)
[23:25:41] <bjz_> acrichto: did you fix it with ifmt?
[23:26:16] <acrichto> bjz_: that's more of a repr/reflect issue than a %? issue
[23:26:24] <bjz_> yeah, thought so
[23:26:28] *** Joins: ghrust (ghrust@9C8B94D4.6A2AE50.F3114085.IP)
[23:26:28] <ghrust> 01[13rust01] 15bors merged 06auto into 06master: 02http://git.io/w1dlAA
[23:26:28] *** Parts: ghrust (ghrust@9C8B94D4.6A2AE50.F3114085.IP) ()
[23:26:28] <acrichto> bjz_: I did fix a long time ago the derived ToStr impl for those kinds of structs though
[23:26:30] <Eridius> hrm, function annotations placed inside the function still use the same syntax?
[23:26:46] <Eridius> oh there's a trailing semicolon
[23:27:01] *** Quits: ozten (ozten@19BD73A1.5D8BCA3A.A0C1B52F.IP) (Quit: ozten)
[23:27:27] *** Joins: eatkinson (eatkinson@moz-BBE3ABD.mv.mozilla.com)
[23:27:41] *** Quits: lbergstrom (Adium@moz-5D8E4B14.lightspeed.cicril.sbcglobal.net) (Quit: Leaving.)
[23:28:09] <bjz_> maik: oh well, it compiles now
[23:28:17] <maik> bjz_, nice 
[23:28:25] <bjz_> maik: I have yet to test it though :P
[23:28:28] <maik> bjz_, and does it work?
[23:28:31] <maik> bjz_, oh :D
[23:28:32] <bjz_> need to head out
[23:28:37] <bjz_> :(
[23:28:40] <maik> :(
[23:29:00] *** Quits: Sojourn (Mibbit@moz-9DD0F4FC.icsincorporated.com) (Quit: http://www.mibbit.com ajax IRC Client)
[23:29:01] <bjz_> will let you know how I go though
[23:29:21] <maik> bjz_, I give it a try now
[23:29:44] *** Quits: hjr3 (hradtke@374E545A.3A8E9B0C.F9D9C60E.IP) (Quit: My MacBook has gone to sleep. ZZZzzzâ€¦)
[23:30:06] <bjz_> maik: you'll need an up-to-date glfw-rs
[23:30:41] <bjz_> also, it might take a good time to compile, seeing as it does the whole spec by default -_-
[23:31:29] *** Joins: ghrust (ghrust@1E8607E8.6A2AE50.F3114085.IP)
[23:31:29] <ghrust> 01[13rust01] 15bors pushed 0 new commits to 06auto: 02http://git.io/dqbzbw
[23:31:29] *** Parts: ghrust (ghrust@1E8607E8.6A2AE50.F3114085.IP) ()
[23:31:29] *** Joins: ghrust (ghrust@9C8B94D4.6A2AE50.F3114085.IP)
[23:31:30] <ghrust> 01[13rust01] 15bors pushed 2 new commits to 06auto: 02http://git.io/CSBUVA
[23:31:30] <ghrust> 13rust/06auto 1462e8ef3 15Kevin Ballard: run: Process::new() should take &[Str] instead of &[~str] for args...
[23:31:30] <ghrust> 13rust/06auto 148313695 15bors: auto merge of #8203 : kballard/rust/process-new-args, r=pcwalton...
[23:31:30] *** Parts: ghrust (ghrust@9C8B94D4.6A2AE50.F3114085.IP) ()
[23:31:48] <maik> bjz_, do I need to generate it by myself? or can I just use the gl_prt.rs?
[23:32:03] <bjz_> no, just use gl_ptr
[23:32:14] *** Joins: Houm (Houm@moz-25669AA8.fbx.proxad.net)
[23:32:22] <maik> bjz_, okay I give it a try :) <3
[23:32:28] <bjz_> :)
[23:32:59] *** Joins: hjr3 (hradtke@374E545A.3A8E9B0C.F9D9C60E.IP)
[23:33:56] <benh> rusti: &5i + 5i
[23:33:57] -rusti- 10
[23:34:04] <benh> rusti: 5i + &5i
[23:34:05] -rusti- <anon>:5:14: 5:17 error: mismatched types: expected `int` but found `&int` (expected int but found &-ptr)
[23:34:05] -rusti- <anon>:5          5i + &5i
[23:34:05] -rusti-                        ^~~
[23:34:05] -rusti- error: aborting due to previous error
[23:34:05] -rusti- application terminated with error code 101
[23:34:19] <olsonjeffery> brson: rebase + big batch of fixes for newrt_file_io
[23:35:17] <bjz_> rusti: (&5i).add(&5i)
[23:35:18] -rusti- 10
[23:35:29] <bjz_> rusti: 5i.add(&&5i)
[23:35:30] -rusti- <anon>:5:16: 5:18 error: unexpected token: `&&`
[23:35:30] -rusti- <anon>:5          5i.add(&&5i)
[23:35:30] -rusti-                          ^~
[23:35:30] -rusti- application terminated with error code 101
[23:35:55] <Eridius> rusti: 5i.add(& &5i)
[23:35:56] -rusti- <anon>:5:16: 5:21 error: mismatched types: expected `&int` but found `&&int` (expected int but found &-ptr)
[23:35:56] -rusti- <anon>:5          5i.add(& &5i)
[23:35:56] -rusti-                          ^~~~~
[23:35:56] -rusti- error: aborting due to previous error
[23:35:56] -rusti- application terminated with error code 101
[23:36:03] <maik> bjz_, okay glfw doesn't compile but maybe there was a last minute change that I don't have in rust.
[23:36:07] <graydon> we don't have a 'task lifetime, eh?
[23:36:19] *** Joins: igl1 (igl@moz-3792139.adsl.alicedsl.de)
[23:36:29] *** Quits: igl (igl@moz-684C758E.adsl.alicedsl.de) (Ping timeout)
[23:36:36] <bjz_> maik: yeah, the needed changes went through last night
[23:36:55] <nmatsakis> bjz_: not sure I understood your question
[23:37:01] <maik> bjz_, I just compiled after the u8 pointer change
[23:37:06] <nmatsakis> bjz_: if you do #[fixed_stack_segment] #[inline] fn foo() { ... }
[23:37:13] <bjz_> maik: whar is the error?
[23:37:22] <nmatsakis> bjz_: and then foo() is inlined into a caller, the caller SHOULD inherit the fixed_stack_segment attribute
[23:37:32] <bjz_> nmatsakis: ahh I see
[23:37:39] <nmatsakis> bjz_: (unless of course there is a bug)
[23:37:42] <maik> bjz_, error: mismatched types: expected `std::option::Option<extern "C" fn(*ffi::GLFWwindow, i32)>` but found `std::option::Option<*u8>` (expected extern fn but found *-ptr)
[23:37:56] <nmatsakis> bjz_: the goal of inline(never) is to prevent the fixed_stack_segment from propagating all the way up to the main fn of the task or something like that,
[23:38:00] <adridu59> graydon: is there a way to set up a local bors machine to do some tests?
[23:38:06] <nmatsakis> bjz_: in which case you would enter the task with a large stack segment and never give it up
[23:38:06] <graydon> adridu59: nope
[23:38:09] <maik> maybe I git pulled to early and the change wasn't there yet
[23:38:13] <nmatsakis> graydon: ping
[23:38:21] <graydon> adridu59: you have to configure it against a buildbot and a git repo
[23:38:22] <bjz_> nmatsakis: but it's ok to inline them?
[23:38:23] <graydon> nmatsakis: pong
[23:38:26] *** Joins: snadon (chatzilla@moz-3BC727E8.mc.videotron.ca)
[23:38:27] <nmatsakis> bjz_: yes it's k
[23:38:33] <bjz_> nmatsakis: cool
[23:38:44] <nmatsakis> bjz_: that's why I didn't make it so that #[fixed_stack_segment] ALWAYS implies inline(never)
[23:38:47] <adridu59> graydon: k!
[23:38:53] *** Joins: maxli (maxli@B5559308.9C54E60.2FA4EA88.IP)
[23:38:57] <nmatsakis> graydon: you mentioned a prob that the new visitor made a lot of code dup --
[23:38:59] <bjz_> nmatsakis: with gl calls I want to make sure it's up to the user
[23:39:08] <nmatsakis> graydon: I was thinking about this, it'd be fairly easy to refactor to avoid it I suspect
[23:39:10] <Eridius> hrm, the ffi tutorial uses an undocumented std::unstable::intrinsics function.
[23:39:19] <graydon> nmatsakis: it appears to have done, yes
[23:39:25] <bjz_> maik: hum
[23:39:36] <graydon> nmatsakis: refactor the visitor or the code that emits default methods?
[23:39:41] <nmatsakis> graydon: the former
[23:39:52] <maik> bjz_, don't worry I just recompile rust and try again
[23:39:53] <graydon> nmatsakis: I think the thing is that when you have a default method we're not doing the moral equivalent of type_use on it at all
[23:40:02] <bjz_> maik: ok
[23:40:02] <maik> bjz_, I probably messed sth up
[23:40:12] <nmatsakis> graydon: well, that may be part of it, but we all know type_use is also not that great
[23:40:14] *** Quits: eatkinson (eatkinson@moz-BBE3ABD.mv.mozilla.com) (Quit: eatkinson)
[23:40:25] <nmatsakis> graydon: but what we could do in the visitor case in specific
[23:40:32] <graydon> nmatsakis: so it just gets stamped out in every instance. though ... it's also not clear to me that if we _did_ that we'd win a lot, since if the type of self is truly different and one of the leaf functions is type-dependent, all the non-leaves would be too.
[23:40:33] <brson> olsonjeffery: thanks. really epic pr
[23:40:44] <graydon> nmatsakis: I wonder if vtable-call-through-self would do
[23:40:49] <nmatsakis> graydon: is replace the fns like fn<V:Visitor>(v: &V, ...) with fn(v: &Visitor, ...)
[23:41:02] <nmatsakis> graydon: you'd still have copies of the default fns,
[23:41:11] <nmatsakis> graydon: but not the ones that do the meat of the work
[23:41:27] <Eridius> hrm, unsafe_destructor isn't documented anywhere, and is only ever used once in the FFI tutorial. Why is it necessary?
[23:41:44] <nmatsakis> graydon: to be fair, pnkfelix and I discussed this a bit and I think I pushed him to using <V:Visitor>, but maybe I was wrong to do so :)
[23:41:56] <kmc> Eridius: it's needed to put a dtor on anything which doesn't implement Send
[23:42:04] <nmatsakis> Eridius: actually I think it will go away, since we plan on generalizing that rule
[23:42:10] <Eridius> kmc: or types that have type parameters
[23:42:12] <graydon> nmatsakis: do you think it'd be possible to go a step further and have the calls to self.walk_foo() go via vtable also?
[23:42:12] <nmatsakis> though I need to figure out how to do so soundly :)
[23:42:13] <maik> make -j4 is acting super strange lately
[23:42:14] <Eridius> I just don't know why this is necessary
[23:42:30] <kmc> I think it prevents cycles of access between dtors
[23:42:34] <graydon> nmatsakis: that is, impl Visitor for &Visitor (I think?)
[23:42:51] <pcwalton> cycles between dtors would have to leak to be sound
[23:42:59] <graydon> nmatsakis: speed / codesize is always a tricky trade
[23:42:59] <pcwalton> well...
[23:43:06] <pcwalton> we could do something like what boehm suggests
[23:43:19] <pcwalton> just run the destructors in an arbitrary order before sweeping anything
[23:43:28] <pcwalton> but that's incompatible with RC
[23:43:36] <nmatsakis> Eridius: http://smallcultfollowing.com/babysteps/blog/2013/01/17/destructors-and-finalizers-in-rust/
[23:43:47] <nmatsakis> graydon: I'm not sure what that impl would do
[23:43:52] <nmatsakis> graydon: maybe I'm missing something
[23:43:57] <Eridius> nmatsakis: ok
[23:44:00] <nmatsakis> graydon: let me look at the code again and refresh my memory
[23:44:15] <nmatsakis> Eridius: that post explains the current rule and its motivations; I need to write a sequel with the rule we've agreed upon to replace it
[23:44:30] * nmatsakis realizes how far behind he is in blogging! argh!
[23:44:47] <graydon> nmatsakis: suppose you have 100 visitors each of which only customizes visit_expr. what I'm aiming for is to have 100 x visit_expr generated, not 100x all-the-visit_foo-fns
[23:44:51] <Eridius> nmatsakis: would be nice if there was some canonical place to find all the "important" blog posts that explain design decisions in force today (and planned future ones)
[23:44:56] <maik> that seems like a good time to ask, why can't we have safe destructors for structs with type parameters?
[23:45:00] *** Joins: ecr (Thunderbir@moz-BBE3ABD.mv.mozilla.com)
[23:45:08] <graydon> nmatsakis: so when you visit_stmt and it calls self.visit_expr(), that would need to be dispatched not statically but via vtable
[23:45:23] <nmatsakis> graydon: so hmm I guess part of the problem is that Visitor is still parameterized by this type E for some reason
[23:45:24] <graydon> nmatsakis: that is, self would need to be an obj type
[23:45:25] *** Quits: tjc (tjc@moz-BBE3ABD.mv.mozilla.com) (Quit: zzzzzzzzzz)
[23:45:41] *** Quits: ecr (Thunderbir@moz-BBE3ABD.mv.mozilla.com) (Quit: ecr)
[23:46:07] <graydon> nmatsakis: though ... now that I think of it, if you make obj types from 100 visitors-that-used-default-methods, it's not clear to me that you'd avoid making 100 copies of all the methods still
[23:46:32] <nmatsakis> graydon: so, the default methods for visitor are basically just real short calls to walk_stmt etc
[23:46:40] <nmatsakis> graydon: what I was proposing is to avoid the multpile copies of walk_stmt
[23:46:41] *** Joins: infynyxx (infynyxx@DB780A29.749BA1D.DCC373F0.IP)
[23:46:48] <nmatsakis> graydon: the copies of the default methods THEMSELVES would remain
[23:46:53] <nmatsakis> graydon: but I thikn it'd be a big net savings
[23:46:53] *** Quits: infynyxx (infynyxx@DB780A29.749BA1D.DCC373F0.IP) (Connection reset by peer)
[23:46:56] *** Quits: brendan (brendaneic@moz-BBE3ABD.mv.mozilla.com) (Quit: brendan)
[23:47:11] *** Joins: infynyxx (infynyxx@DB780A29.749BA1D.DCC373F0.IP)
[23:47:31] <nmatsakis> graydon: and my plan to remove the copies of walk_stmt was to make them non-generic
[23:47:36] <Eridius> something's wrong with the builders: http://buildbot.rust-lang.org/builders/auto-win-32-nopt-t/builds/153/steps/compile/logs/stdio
[23:47:43] <nmatsakis> graydon: though I realize we still carry this vestigial argument type E which makes this a bit harder
[23:47:44] *** Joins: tjc (tjc@moz-BBE3ABD.mv.mozilla.com)
[23:47:44] *** ChanServ sets mode: +o tjc
[23:47:47] <graydon> ok. so there are multiple inter-related problems here
[23:48:05] <graydon> one is the leaves being large and duplicated. one is the interior symbols being duplicated.
[23:48:17] <nmatsakis> though probably many of the visitors could be converted to use E=() or something, if they don't need a context argument
[23:48:34] <graydon> and possibly the causes of the latter are both static dispatch (rather than vtable) and inadequate monomorphic recycling
[23:48:53] <graydon> I hate to dwell on this too much, but it's not so academic: we gained 10% binary size
[23:48:59] <graydon> (and compile time)
[23:49:06] <graydon> (and number of symbols)
[23:49:21] <nmatsakis> it'd be good to know which it is -- 
[23:49:29] <nmatsakis> because the visit functions were always generic in the type of the use data --
[23:49:33] <nmatsakis> now that I think about it --
[23:49:46] <nmatsakis> so I would assume that the walk_stmt was always being duplicated
[23:49:49] <nmatsakis> unless type_use took care of it
[23:50:35] <Eridius> nmatsakis: from your blog: "Apple's failed attempt at an Objective-C garbage collector" <- it didn't fail. It worked. It just had issues
[23:50:44] <graydon> 14 new copies of visit::walk_item; 32 new copies of visit::walk_local ...
[23:51:08] <nmatsakis> Eridius: it's been publicly called deprecated 
[23:51:11] <graydon> 23 copies of visit::walk_method_helper
[23:51:20] <graydon> etc. etc.
[23:51:23] <Eridius> IIRC it's not officially deprecated yet, just... you're encouraged not to start new projects using it
[23:51:25] <pcwalton> so do something about it
[23:51:27] <graydon> (path, stmt, mod)
[23:51:28] <Eridius> ARC is better
[23:51:29] *** Joins: ghrust (ghrust@2EE61FCC.6A2AE50.F3114085.IP)
[23:51:29] <ghrust> 01[13rust01] 15bors 04force-pushed 06auto from 148313695 to 14f858452: 02http://git.io/N3iJvQ
[23:51:29] *** Parts: ghrust (ghrust@2EE61FCC.6A2AE50.F3114085.IP) ()
[23:51:30] *** Joins: ghrust (ghrust@79968228.6A2AE50.F3114085.IP)
[23:51:30] <ghrust> 01[13rust01] 15bors pushed 2 new commits to 06auto: 02http://git.io/n7U8Sw
[23:51:30] <ghrust> 13rust/06auto 149d72302 15Alex Crichton: Correctly encode item visibility in metadata...
[23:51:30] <ghrust> 13rust/06auto 146a3d129 15bors: auto merge of #8365 : alexcrichton/rust/correct-item-visibility, r=pcwalton...
[23:51:30] *** Parts: ghrust (ghrust@79968228.6A2AE50.F3114085.IP) ()
[23:51:31] *** Joins: lbergstrom (Adium@moz-5D8E4B14.lightspeed.cicril.sbcglobal.net)
[23:51:32] <nmatsakis> Eridius: I agree it was a technical achievement and I didn't mean to put it ddown in that respect
[23:51:39] <nmatsakis> Eridius: but it failed to achieve adoption
[23:51:51] <nmatsakis> or dominance or whatever :)
[23:51:58] *** Quits: lkuper_ (lkuper@moz-D862222C.dhcp-bl.indiana.edu) (Ping timeout)
[23:51:58] <graydon> pcwalton: was that directed at me?
[23:52:02] <Eridius> heh. One big reason is because it never made it to iOS
[23:52:03] <pcwalton> yes, sorry
[23:52:05] <graydon> totally fair
[23:52:06] <Eridius> (for performance and memory usage reasons)
[23:52:07] <nmatsakis> graydon: those are the copies I was saying we could consolidate
[23:52:11] <graydon> I just didn't recognize the unicode symbol
[23:52:21] <pcwalton> I don't know whether you're suggesting we go back to not monomorphizing
[23:52:25] <graydon> I actually don't know how. I was asking recently about type_use.
[23:52:25] <pcwalton> when you bring this up again and again
[23:52:35] <graydon> absolutely not
[23:52:37] <pcwalton> ok
[23:52:38] <strcat> maybe mergefunc can work now
[23:52:46] <strcat> we could just remove type_use and run mergefunc early
[23:52:56] * strcat doesn't know how slow it is
[23:53:02] <pcwalton> strcat: is mergefunc designed to do what type_use does?
[23:53:02] <nmatsakis> graydon: enough discussion, let me do a quick experiment :)
[23:53:13] <strcat> pcwalton: it throws the functions in a hash table by IR and merges them
[23:53:24] <nmatsakis> graydon: to show you what I mean :)
[23:53:24] <pcwalton> well, the problem here is that the types are "equivalent"
[23:53:29] <pcwalton> but may not be at the IR level
[23:53:32] <pcwalton> ... or maybe they are?
[23:53:42] <strcat> pcwalton: they should be afaik, since LLVM types are so boring :)
[23:53:43] <graydon> pcwalton: I bring it up because I think some combination of strategically using vtables in places where we're using static binding, and maybe fixes to type_use (there are a bunch of bugs open on it and a general "it doesn't work" consensus) might be big wins
[23:53:51] *** Quits: infynyxx (infynyxx@DB780A29.749BA1D.DCC373F0.IP) (Ping timeout)
[23:54:07] <nmatsakis> pcwalton: I think they may not be the same at the IR level
[23:54:09] <graydon> also possibly better type canonicalization, I really don't know. I'd like to spend time on it. it seems to me that it's the most obvious thing to stab at.
[23:54:13] *** Joins: jensnockert (jensnocker@moz-8BE55278.customer.t3.se)
[23:54:23] <pcwalton> oh interesting... mergefunc *does* consider all pointer types to be equivalent
[23:54:32] <pcwalton> regardless of what the thing behind the pointer is in the IR sense
[23:54:34] <pcwalton> http://llvm.org/docs/doxygen/html/MergeFunctions_8cpp_source.html
[23:54:35] <graydon> we don't really have small tests of the sort "these two functions definitely ought to merge"
[23:54:45] <graydon> which I think might be helpful in figuring out what's working or not
[23:54:45] <strcat> pcwalton: yeah because without TBAA, there are no type semantics on pointers
[23:54:55] <pcwalton> MergeFunctions finds functions which will generate identical machine code,
[23:54:55] <pcwalton> by considering all pointer types to be equivalent. Once identified,
[23:54:55] <pcwalton> MergeFunctions will fold them by replacing a call to one to a call to a
[23:54:55] <pcwalton> bitcast of the other.
[23:54:59] *** Joins: sigma (sigma@51C589B3.EF2694B5.DFAC6AA7.IP)
[23:55:04] <pcwalton> maybe our time would be better spent just running mergefunc
[23:55:09] <pcwalton> and figuring out why it doesn't work
[23:55:24] <graydon> possibly, if it runs early enough
[23:55:28] <pcwalton> just run it first
[23:55:34] <strcat> we can run it at the start and the end, if it's worth it
[23:55:35] <pcwalton> we can control order of LLVM passes
[23:55:48] <strcat> or just at the end
[23:55:50] <aatch> pcwalton, when I first enabled it, I'm pretty sure it broke hashtables.
[23:55:51] <graydon> no, I mean, is it allowed to run first? does it know what "will generate identical machine code" means at that point?
[23:56:01] *** Joins: ofeldt- (ofeldt@moz-3FD1E9EA.dip0.t-ipconnect.de)
[23:56:06] <pcwalton> aatch: interesting, we should figure out why that is
[23:56:06] <strcat> graydon: yes you can run it first
[23:56:08] <strcat> before other opt passes
[23:56:27] <nmatsakis> graydon: oh grr I have to build llvm before I can test my idea :0
[23:56:29] <strcat> graydon: it would catch more post-optimization though
[23:56:39] <strcat> but then you might waste time optimizing the same code - depends how fast mergefunc is
[23:56:40] *** Quits: ofeldt (ofeldt@moz-7DA3D443.dip0.t-ipconnect.de) (Ping timeout)
[23:56:45] <graydon> mhm
[23:56:48] <nmatsakis> pcwalton: oh that is interesing (about mergefunc)
[23:56:58] * nmatsakis can't keep up with all the discussion hre
[23:57:14] <nmatsakis> Eridius: anyway, I don't mean to put down the obj c GC :) it was a bit of a leaky abstraciton thogh
[23:57:35] <graydon> this seems worth experimenting on.
[23:57:35] <aatch> pcwalton, my guess is that it wasn't happy with the undefined IR we were generating.
[23:57:36] <nmatsakis> Eridius: there were some careful patterns iirc needed to keep things rooted
[23:57:48] <pcwalton> aatch: right
[23:57:53] <aatch> but much of it has been fixed now.
[23:57:53] <graydon> guh. I think I have to give up on this. I can't blindly rebase john's stuff anymore, I don't understand it :(((
[23:57:54] <pcwalton> well, that should be fixed anyhow :)
[23:58:16] <aatch> I think there is one common case, but the LLVM guys say it's a false-positive anyway.
[23:58:50] <pcwalton> IMHO we should remove type_use, get mergefunc working and then see if we need type_use again
[23:59:04] <aatch> Something to do with bitcasting functions
[23:59:10] *** Quits: bent (chatzilla@moz-BE33DA21.fw1.sfo1.mozilla.net) (Quit: ChatZilla 0.9.90.1-rdmsoft [XULRunner 22.0/20130619132145])
[23:59:42] * strcat wonders how mergefunc interacts with TBAA

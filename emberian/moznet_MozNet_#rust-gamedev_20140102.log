[00:07:20] *** Quits: brson (brson@moz-BBE3ABD.mv.mozilla.com) (Ping timeout)
[00:10:09] *** Quits: tikue_ (tkuehn@moz-C55F9DFF.hsd1.pa.comcast.net) (Quit: tikue_)
[00:10:27] *** Joins: brson (brson@981AA104.E81F12CD.76F66111.IP)
[00:37:18] *** Joins: samx (sami@moz-D9DA5773.dyn.optonline.net)
[00:51:27] *** Joins: bjz (bjz@B398BE78.F804C29E.D35A31DF.IP)
[00:55:18] *** Quits: bjz (bjz@B398BE78.F804C29E.D35A31DF.IP) (Ping timeout)
[00:55:36] *** Joins: bjz (bjz@B398BE78.F804C29E.D35A31DF.IP)
[01:13:29] <bjz> not sure if this got trhough before - I had connection issues: Do you think Rust will ever be able to run on consoles? the PS4 uses C++/LLVM - I'm guessing the APIs would have to be wrapped
[01:15:52] <dbaupp> bjz: are consoles computers? (hint: the answer is yes :P )
[01:16:17] <bjz> :)
[01:16:43] <bjz> http://www.reddit.com/r/programming/comments/1t5rss/ps4_toolchain_pdf/
[01:17:06] <bjz> seems the PS4 is closer to a 'regular' computer than ever before
[01:17:16] <bjz> ie. a desktop
[01:17:34] <bjz> also the steam box is practically a desktop for the TV
[01:17:54] <bjz> not sure how the Xbox would go though
[01:19:25] <dbaupp> It may require some compiler changes, but Rust is very similar to C/C++ in terms of computers it can theoretically run on
[01:19:37] <dbaupp> especially with the freestanding/static linking stuff.
[01:19:49] <bjz> yep
[01:21:19] <csherratt> Considering unity runs on consoles, I think rust will have no problem.
[01:22:16] *** Quits: mitsuhiko (mitsuhiko-@moz-BC29B73E.srv.pocoo.org) (Ping timeout)
[01:22:19] <csherratt> My real wonder is what the PS4 licence looks like, and if any work done on it could be given back to the community.
[01:24:56] *** Joins: mitsuhiko (mitsuhiko-@moz-BC29B73E.srv.pocoo.org)
[01:29:17] <bjz> csherratt: aye
[01:29:44] <bjz> csherratt: btw, what do you think of the glfw refactor so far? it's a bit convoluted atm
[01:30:00] <bjz> (and doesn't compile :P)
[01:34:54] <csherratt> I'm a bit worries about forcing a threading model on users.
[01:35:04] *** Joins: skrylar (skrylar@moz-F692F728.austin.res.rr.com)
[01:35:32] <bjz> csherratt: aye
[01:35:36] <csherratt> But I think it could be useful, it makes serialization of events pretty straightforward.
[01:36:06] <bjz> I'm not going to expose the Chans directly
[01:37:34] <csherratt> Just return a port?
[01:38:27] <bjz> you think that would make things more composable?
[01:38:44] <bjz> I didn't want to expose that low level stuff
[01:38:50] <skrylar> talking about how to get events out of SDL?
[01:38:59] <bjz> no, glfw
[01:39:16] <skrylar> I'm not sure why the callback model doesn't work; it *should*.
[01:39:31] <skrylar> unless they're getting garbage collected
[01:39:35] <bjz> it's because rust doesn't have global vars
[01:39:47] *** Quits: mark_edward (quassel@moz-E0F1AB04.hsd1.in.comcast.net) (Ping timeout)
[01:39:49] <bjz> well, it does
[01:39:51] <skrylar> well you were using dynamic trait dispatch, so that gets converted Go-style IIRC
[01:40:01] <bjz> I'm trying to make a safe API
[01:40:01] <skrylar> and I saw you using the userdata for glfw to store the callback traits
[01:40:15] <bjz> yeah, I'm moving away from that
[01:40:23] <skrylar> It didn't work on my computer, though it should
[01:40:28] <bjz> why?
[01:40:32] <skrylar> I donno
[01:40:35] <skrylar> It wouldn't send me events
[01:40:44] <bjz> it works for everyone else I'm pretty sure - weird
[01:40:57] <skrylar> that's why I ended up going and hand-wrapping a chunk of SDL
[01:41:30] *** Quits: mitsuhiko (mitsuhiko-@moz-BC29B73E.srv.pocoo.org) (Ping timeout)
[01:42:01] <skrylar> I guess you could register callbacks to GLFW that just put events on a channel
[01:42:17] <bjz> that's what I'm in the process of doing
[01:42:24] <bjz> :)
[01:42:29] <skrylar> in my SDL wrapper I just use an iterator for the event pump
[01:42:36] <skrylar> for e in blah.event_itr_mut()
[01:42:38] <bjz> yep, SDL is easier
[01:42:45] <bjz> because it doesn't use callbacks
[01:42:54] <skrylar> once you wrap GLFW to channels you can probably do the same, use an iterator to pump the port
[01:42:55] *** Joins: mitsuhiko (mitsuhiko-@moz-BC29B73E.srv.pocoo.org)
[01:43:03] <bjz> believe me, I've thought of this :)
[01:43:24] * bjz added the PortIterator
[01:43:37] <bjz> <3 Iterators
[01:43:54] <bjz> https://github.com/bjz/glfw-rs/pull/64
[01:43:59] <csherratt> the python way of life
[01:44:34] <skrylar> I'm not a huge fan of iterators, mostly because it bothers me that the computer is allocating tiny structs on the heap
[01:44:43] <skrylar> that live for like 1 second
[01:45:31] *** Quits: mitsuhiko (mitsuhiko-@moz-BC29B73E.srv.pocoo.org) (Ping timeout)
[01:45:41] <bjz> skrylar: if you do it right, the optimise away
[01:45:47] <bjz> talk to strcat
[01:46:11] <csherratt> unless your iterator has a owned pointer inside of it, it should be allocated on the stack not the heap.
[01:46:49] <skrylar> bjz: that gets eerily close to the 'sufficiently smart compiler' problem
[01:47:44] <bjz> btw, why are you allocating them on the heap?
[01:48:07] <bjz> Iterators should ideally use borrowed pointers
[01:48:14] <bjz> *references
[01:48:25] *** Joins: mitsuhiko (mitsuhiko-@moz-BC29B73E.srv.pocoo.org)
[01:50:11] *** Quits: mitsuhiko (mitsuhiko-@moz-BC29B73E.srv.pocoo.org) (Ping timeout)
[01:50:15] <bjz> skrylar: see #rust
[01:52:25] *** Joins: mitsuhiko (mitsuhiko-@moz-BC29B73E.srv.pocoo.org)
[01:54:58] *** Quits: mitsuhiko (mitsuhiko-@moz-BC29B73E.srv.pocoo.org) (Ping timeout)
[01:57:02] *** Quits: brson (brson@981AA104.E81F12CD.76F66111.IP) (Quit: leaving)
[02:21:35] *** Joins: luz (lucy@moz-CD18B14B.customer.cdi.no)
[02:29:09] *** Joins: jhasse_ (jhasse@moz-3128EA21.ewe-ip-backbone.de)
[02:29:54] *** Quits: jhasse_ (jhasse@moz-3128EA21.ewe-ip-backbone.de) (Quit: Verlassend)
[02:30:08] *** Joins: jhasse_ (jhasse@moz-3128EA21.ewe-ip-backbone.de)
[02:30:21] *** Quits: jhasse (jhasse@moz-39E0351E.ewe-ip-backbone.de) (Ping timeout)
[02:30:26] *** Quits: jhasse_ (jhasse@moz-3128EA21.ewe-ip-backbone.de) (Quit: Verlassend)
[02:30:36] *** Joins: jhasse (jhasse@moz-3128EA21.ewe-ip-backbone.de)
[02:36:01] *** Quits: Ferreus (ferreus@moz-A4A53361.pools.arcor-ip.net) (Ping timeout)
[02:38:29] *** Quits: tiffany (kawaii@moz-FC0DB29D.dhcp.embarqhsd.net) (Input/output error)
[02:40:25] <skrylar> okay, i think thats enough prodding termbox for now
[02:46:50] <bjz> heh
[02:47:18] <bjz> skrylar: is that that funky terminal thing from a while back
[02:54:37] *** Joins: Ferreus (ferreus@moz-A4A53361.pools.arcor-ip.net)
[02:58:29] <skrylar> yeah its a light version of ncurses
[02:58:46] <skrylar> there was already a set of bindings but i wrote a skrylar version
[03:02:29] <bjz> heh
[03:02:34] <bjz> yayrust
[03:02:51] <bjz> did it turn out nicer?
[03:03:11] *** Quits: jhasse (jhasse@moz-3128EA21.ewe-ip-backbone.de) (Quit: Verlassend)
[03:07:04] <csherratt> this should probably get merged https://github.com/bjz/glfw-rs/pull/67
[03:12:55] *** Joins: mitsuhiko (mitsuhiko-@moz-BC29B73E.srv.pocoo.org)
[03:13:36] *** Joins: jhasse (jhass_000@moz-3128EA21.ewe-ip-backbone.de)
[03:13:43] <skrylar> bjz: it should be nicer, yes. its a wrapper and I used a singleton struct to enforce terminal I/O restrictions
[03:13:58] <skrylar> so they have to go through the terminal object, which only gets one init
[03:14:18] <cmr> csherratt: no, it shouldn't be. it's a rustc bug.
[03:14:41] <cmr> Option<NonNullablePointer> is supposed to optimize down to a nullable pointer.
[03:14:47] <cmr> That it doesn't on some ABIs needs to be fixed
[03:15:45] <cmr> (I would comment on the PR but my touchpad is currently nonfunctional and github isn't very keyboard friendly)
[03:19:31] <bjz> cmr: is there a rust bug?
[03:20:06] *** Quits: Ferreus (ferreus@moz-A4A53361.pools.arcor-ip.net) (Quit: WeeChat 0.4.2)
[03:20:07] <skrylar> bleh, i remember reading the argument that Option<*T> should not be required
[03:20:24] <skrylar> the argument was based around pointers should be the "let me do what i need to" box
[03:21:16] <bjz> Option<*T> is not required
[03:21:24] <bjz> you can use ptr::null
[03:21:29] <skrylar> they were debating making them required
[03:21:34] <bjz> but it shows intent in the FFI
[03:21:41] <bjz> yeah, and I disagree
[03:22:20] <bjz> an escape hatch should always be there
[03:23:53] <skrylar> Hrm..
[03:24:00] <skrylar> My wrapper has better documentation than termbox does.
[03:24:01] <skrylar> rofl
[03:24:15] <bjz> ie. I disagree with them being required, but I still think that nullable pointers should use Options
[03:24:26] <bjz> (in ffis)
[03:28:08] <csherratt> cmr, this bug? https://github.com/mozilla/rust/issues/10570
[03:39:06] *** Quits: zz_kimundi (kimundi@moz-AA8877D1.dip0.t-ipconnect.de) (Ping timeout)
[03:39:26] <skrylar> bjz: https://github.com/Skrylar/RustTerm/blob/master/docs.adoc success
[03:41:50] <bjz> skrylar: what about using rustdoc?
[03:42:46] *** Joins: zz_kimundi (kimundi@moz-56BCBF80.dip0.t-ipconnect.de)
[03:42:47] *** zz_kimundi is now known as kimundi
[03:43:14] <cmr> csherratt: that's not the issue, unrelated.
[03:43:27] <cmr> this is a codegen bug, that's a niggling semantics issue
[03:43:27] <skrylar> bjz: didn't feel like doing inline docs
[03:43:41] <cmr> (I'm pretty sure bjz and I have the same opinion on #10570)
[03:44:01] <bjz> cmr: which is?
[03:44:37] <cmr> bjz: Option<*T> shouldn't be changed because *T shouldn't impose any restrictions on the value of the pointer.
[03:44:54] <bjz> yep
[03:45:01] <bjz> *T is unsafe
[03:45:08] <bjz> :)
[03:45:18] <csherratt> Some(ptr::null()) != None?
[03:45:23] <cmr> I'm quite content with Option<NonNullable> -> nullable pointer semantics, would be happy formalizing them.
[03:45:34] <cmr> csherratt: right
[03:46:01] <bjz> csherratt:	 Some::<*T>(ptr::null()) == None::<*T>
[03:47:27] <bjz> cmr: ^?
[03:47:36] <bjz> cmr: that was my understanding
[03:47:56] <cmr> bjz: If the optimization were applied to *T, which I don't think it should be, yes.
[03:48:28] <bjz> Some::<extern fn()>(transmute(ptr::null())) == None::<extern fn()>
[03:48:36] <bjz> cmr: why not?
[03:48:46] <cmr> bjz: because *T is unsafe and nullable.
[03:49:13] <cmr> Forthe extern fn() case, yes, since extern fn() isn't nullable.
[03:49:28] *** Quits: ecl3ctic (Mibbit@moz-E1FAD64C.wzfv1.vic.bigpond.net.au) (Quit: http://www.mibbit.com ajax IRC Client)
[03:49:33] <bjz> Hmm
[03:51:27] <bjz> cmr: wouldn't that just be because we can't impl a Ptr::<for extern fn()>::null() on all extern fn(..) ->Ts?
[03:51:43] <skrylar> i should do a #[bench] rig some time to see just how badly the wrapping mauls SDL's event performance
[03:51:47] <cmr> bjz: what do you mean?
[03:53:02] <skrylar> If I rewrote the way it runs a little, I could probably get away with avoiding rebinds
[03:53:26] <skrylar> e.g. take the C struct you get, make the fields private, and supply getters that transmute
[03:53:42] <bjz> skrylar: yep
[03:54:30] <bjz> skrylar: look at my ffi
[03:54:49] <bjz> I have the unsafe ones, but the wrapper could return Options
[03:55:25] <skrylar> i'll poke around with it later
[03:55:37] <skrylar> i'm not in a huge hurry to fiddle with event code i just got working
[03:58:17] *** Quits: samx (sami@moz-D9DA5773.dyn.optonline.net) (Quit: This computer has gone to sleep)
[04:03:01] <skrylar> the best part is that i still have to do all this to physfs and lua too :|
[04:05:29] <csherratt> skrylar: I think there are already bindings for lua https://github.com/kballard/rust-lua
[04:06:00] *** Joins: samx (sami@moz-D9DA5773.dyn.optonline.net)
[04:06:15] <cmr> there are many bindings to lua
[04:06:42] <cmr> that's the most recent, probably only one maintained by now
[04:48:32] *** Joins: tiffany (kawaii@moz-FC0DB29D.dhcp.embarqhsd.net)
[05:07:05] *** Joins: doomlord_ (servitor@moz-D40D68D6.range86-184.btcentralplus.com)
[05:07:29] *** Quits: samx (sami@moz-D9DA5773.dyn.optonline.net) (Quit: This computer has gone to sleep)
[05:09:50] *** Quits: ChristopherBurg (Christophe@moz-2C03E71B.hfc.comcastbusiness.net) (Quit: My MacBook Pro has gone to sleep. ZZZzzzâ€¦)
[05:22:14] *** Quits: doomlord_ (servitor@moz-D40D68D6.range86-184.btcentralplus.com) (Quit: Leaving)
[05:26:01] *** Quits: csherratt (csherratt@moz-CAF331EA.cable.teksavvy.com) (Quit: csherratt)
[05:28:50] *** Joins: jdm (jdm@moz-3FFA85CA.dsl.teksavvy.com)
[05:29:45] *** Quits: jhasse (jhass_000@moz-3128EA21.ewe-ip-backbone.de) (Ping timeout)
[05:31:37] *** Joins: csherratt (csherratt@moz-CAF331EA.cable.teksavvy.com)
[05:34:16] *** Quits: SiegeLord (sl@moz-CAF07B4C.hsd1.ma.comcast.net) (Quit: It's a joke, it's all a joke.)
[05:47:22] *** Joins: canhtak (canhtak@moz-59105D0.wl.t.ulaval.ca)
[06:20:07] *** Joins: acrichto (acrichto@moz-B63D64BD.res.cmu.edu)
[06:20:20] <acrichto> bjz: should have thought of this earlier
[06:20:28] <bjz> ok
[06:20:38] <bjz> so what's up?
[06:20:45] <acrichto> so far I have learned that I need to create a texture
[06:20:46] <bjz> (for the benefit of the channel)
[06:20:54] <acrichto> I have a large call to TexImage2D
[06:21:05] <acrichto> I basically have a large rgba array I just want to put on the screen
[06:21:21] <acrichto> I'm using glfw so far to make a window, and that's all working great, but putting pixels on the screen is eluding me
[06:21:28] <acrichto> been awhile since I used opengl...
[06:21:41] <acrichto> I thought I needed to do something like draw a quad, but I'm not sure how to do that with gl-rs
[06:21:46] <bjz> so no transformations on the said array of pixels?
[06:22:04] <acrichto> eventually I'll want to blow it up and down
[06:22:14] <acrichto> just like 2x/3x etc, but other than that nothing fancy
[06:22:20] <bjz> there is an example here: http://www.open.gl/textures
[06:23:00] <acrichto> oh man this got real complicated real fast
[06:23:25] <bjz> heh
[06:23:26] <acrichto> sounds like I need vertex arrays...
[06:23:39] <bjz> it's not too bad once you do all the boilerplate
[06:23:49] <bjz> do you have a repo?
[06:23:52] <Yurume> acrichto: https://github.com/snrs/sonorous/blob/master/src/gfx/gl.rs would it be helpful?
[06:23:54] <acrichto> sec
[06:24:20] <Yurume> (I really have to move that to a separate repo...)
[06:24:27] <acrichto> bjz: https://github.com/alexcrichton/jba/blob/rust/src/gl_imp.rs
[06:25:00] <acrichto> Yurume: I'm sure it would be! I just need to re-learn how to re-learn gl code lol
[06:25:10] <acrichto> let's say I wanted to just draw a square
[06:25:18] <bjz> ooh! I like your use of chans
[06:25:22] <Yurume> acrichto: so did I, I haven't used OpenGL 2+ before learning Rust
[06:25:43] <acrichto> bjz: yeah I didn't know how else to communicate back to the main thread b/c of the Send requirements
[06:25:51] <bjz> mm
[06:25:57] <Yurume> acrichto: https://github.com/snrs/sonorous/blob/master/src/gfx/draw.rs and this. (for default shaders and draw primitives)
[06:26:10] <acrichto> oh no shaders
[06:26:22] <Yurume> it targets rust-opengles but it would be trivial to convert to glfw-rs
[06:26:39] <bjz> Yurume: I don't think acrichto want's anything too complex
[06:26:54] <acrichto> yeah just looking to put a textured square on screen
[06:26:55] <bjz> Yurume: just rendering an array of pixels for an emulator
[06:26:59] <acrichto> yeah
[06:27:07] <Yurume> how about using SDL2 then?
[06:27:21] <acrichto> I just picked gl, dunno if SDL would be more appropriate
[06:27:27] <Yurume> (I'm not sure rust-sdl2 is mature enough)
[06:27:28] <acrichto> I wanted to do both to get familiar with them
[06:27:49] * bjz is also working on his own sdl2 wrapper - found rust-sdl2 lacking
[06:27:54] <acrichto> bjz: so I was looking at http://www.gamedev.net/page/resources/_/technical/opengl/opengl-texture-mapping-an-introduction-r947 
[06:27:56] <Yurume> if you do the emulator stuffs, almost everything OpenGL offers is useless.
[06:28:05] <acrichto> near the end there's "A Textured Quad"
[06:28:12] <acrichto> but I don't think those functions are bound for gl-rs
[06:28:17] <bjz> acrichto: the benefit of opengl is its fast
[06:28:24] <acrichto> hurray! I like fast
[06:28:26] <Yurume> heck, even SDL may suffice
[06:28:36] <Yurume> (since it exposes a raw framebuffer)
[06:28:49] <Yurume> (and that's why SDL was sloooooooow)
[06:28:49] <bjz> acrichto: be careful with opengl, there's lots of old tutes out there
[06:29:06] <acrichto> so I've seen lol
[06:29:15] <acrichto> right now I'm at 3k fps, so I don't think I have too much to worry about
[06:29:20] <acrichto> or I wrote things horribly wrong
[06:29:27] <bjz> hah
[06:30:37] <bjz> acrichto: you could probably get away with making your own mini-gl bindings rather than bringing the full weight of gl-rs to bear
[06:30:49] <bjz> seeing as you only need so little
[06:30:54] <acrichto> I'll stick to just putting a square on the screen first lol
[06:31:26] <acrichto> man rendering is crazy
[06:31:31] <Yurume> if you want to go with the modern OpenGL, you have to make at least one set of shaders (like ProgramForTextures above), one vertex buffer for a single draw call, and one texture which are synchronized to the internal framebuffer.
[06:31:58] <acrichto> surely I can do this without shaders
[06:32:05] <acrichto> I just want a square on the screen :(
[06:32:15] <acrichto> and that's all I'll ever want lol
[06:32:15] <Yurume> so that you track a dirty rect within the internal framebuffer and substitute the appropriate portion of GPU-bound texture via glTexSubImage etc.
[06:32:27] <Yurume> in that case you don't need the modern OpenGL, which is my point
[06:32:31] <acrichto> whoa that sounds fancy
[06:32:41] <acrichto> there's this switch_buffers() thing with glfw
[06:32:54] <acrichto> which makes me think that the buffer I draw into isn't on screen until I do the switch
[06:32:56] <bjz> Yurume: I suspect you are going over his head
[06:33:03] <Yurume> bjz: eh, sorry for that :S
[06:33:28] * bjz is feeling lost - doesn't do much work with textures
[06:33:29] <acrichto> ok, I'm gonna see if I can re-learn vertex buffers
[06:33:33] <acrichto> looks like that's what I need to use
[06:33:43] <bjz> acrichto: those tutes are super simple
[06:33:53] <acrichto> do you know of an example somewhere?
[06:33:54] <bjz> acrichto: http://www.open.gl/introduction
[06:33:59] <acrichto> yay!
[06:34:11] <Yurume> open.gl tutorial is recommendable
[06:34:15] <bjz> just go up to the one with the kitten
[06:34:20] <bjz> that's all you need
[06:34:21] <acrichto> oh glBegin is deprecated
[06:34:25] <bjz> yep
[06:34:27] <Yurume> it even has a WebGL-based live example
[06:34:42] <acrichto> the kitten doesn't have a lot of vertex buffer things
[06:34:52] <acrichto> some calls to glVertexAttribPointer
[06:35:05] *** Quits: jdm (jdm@moz-3FFA85CA.dsl.teksavvy.com) (Ping timeout)
[06:35:11] * acrichto goes back to drawing polygons
[06:35:32] *** Joins: jdm (jdm@moz-3FFA85CA.dsl.teksavvy.com)
[06:37:11] *** Quits: canhtak (canhtak@moz-59105D0.wl.t.ulaval.ca) (Quit: canhtak)
[06:37:37] *** Joins: jdm_ (jdm@moz-3FFA85CA.dsl.teksavvy.com)
[06:37:40] *** Quits: jdm (jdm@moz-3FFA85CA.dsl.teksavvy.com) (Connection reset by peer)
[06:37:55] <bjz> acrichto: the tute uses SOIL for the images, but SOIL actually wraps stb_image. and there are rust bindings for those (servo uses them)
[06:38:13] <bjz> not sure how you'd do drawing to it directly though
[06:38:43] <Yurume> isn't acrichto making an emulator?
[06:38:49] <bjz> yes
[06:38:54] <acrichto> task '<unnamed>' failed at 'BindTexture was not loaded', src/gl-rs/src/gl/lib.rs:3131
[06:39:05] <bjz> unsigned char* image = SOIL_load_image("sample.png", &width, &height, 0, SOIL_LOAD_RGB);
[06:39:05] <bjz> glTexImage2D(GL_TEXTURE_2D, 0, GL_RGB, width, height, 0, GL_RGB, GL_UNSIGNED_BYTE, image);
[06:39:16] <acrichto> do I call TexImage2D before BindTexture?
[06:39:20] <bjz> maybe you will create the chars yourself
[06:39:27] <acrichto> oh whoops
[06:39:30] <acrichto> need to generate a texture
[06:39:38] <bjz> yay! `fail!` instead of segfault :D
[06:39:47] <Yurume> lol
[06:39:49] <bjz> um, did you load the context up right?
[06:39:56] <acrichto> what's that?
[06:40:05] <acrichto> it's in a glfw::start block
[06:40:42] <bjz> you need to specify what opengl version you are using otherwise it defaults to an old version
[06:40:51] <bjz> look at the gl-rs examples
[06:41:01] <acrichto> like in https://github.com/bjz/gl-rs/blob/master/src/examples/triangle/main.rs 
[06:41:04] <acrichto> ah ok
[06:41:21] <bjz> https://github.com/bjz/gl-rs/blob/master/src/examples/triangle/main.rs#L108
[06:41:23] <bjz> yep
[06:41:39] <acrichto> hmm still not loaded
[06:41:44] <bjz> hm
[06:42:10] <bjz> when do you load gl-rs? after you set the windows context to current?
[06:42:13] <acrichto> https://github.com/alexcrichton/jba/blob/rust/src/gl_imp.rs
[06:42:49] <bjz> yeah, move `gl::load_with(glfw::get_proc_address);` to below `window.make_context_current();`
[06:42:55] <acrichto> oh whoops
[06:43:19] <acrichto> progress, it didn't fail, but still a black screen
[06:43:23] <bjz> yeah, that's an ugly gotcha
[06:43:24] <Yurume> bjz: wait, why? :)
[06:43:30] <acrichto> maybe I didn't draw the buffer..
[06:43:53] <Yurume> does gl::load_with more than initializing function tables?
[06:44:29] <bjz> Yurume: it's using glfw's loader function
[06:44:52] <bjz> you would do the same with sdl
[06:45:04] <acrichto> how do I draw an array buffer?
[06:46:29] <bjz> acrichto: https://github.com/bjz/gl-rs/blob/master/src/examples/triangle/main.rs#L127
[06:46:36] *** Joins: Skrylar_ (Skrylar@moz-F692F728.austin.res.rr.com)
[06:46:44] <bjz> oh wait
[06:46:45] <bjz> hm
[06:46:52] <Yurume> glDrawElements?
[06:46:58] <Skrylar_> whats going on?
[06:47:31] <Yurume> acrichto is making a Gameboy emulator in Rust
[06:47:36] <bjz> Skrylar_: acrichto is trying to get his emulator to draw things
[06:48:05] <Skrylar_> Which GL? 1.5? 2? 3+?
[06:48:20] <acrichto> how would I check?
[06:48:31] <Skrylar_> you have to pick which version you want to develop for :P
[06:48:52] <Skrylar_> then you tell the system to give you that when you set up OpenGL for the program
[06:48:55] <acrichto> "my version"
[06:49:16] <bjz> oh what fun is rendering
[06:49:25] <Yurume> acrichto: do you want to use a shader? :)
[06:49:27] <Skrylar_> yeaaah, and its not a simple answer either :(
[06:49:35] <Skrylar_> because its your opengl loader that tells you the version
[06:49:54] <Skrylar_> well if he's on a mac, he *has* to write GL3+
[06:50:03] * bjz wonders if we need a basic "draw pixel to screen lib" for folks
[06:50:06] <acrichto> if I want to draw a square on a screen, I am 100% certain I do not need a shader
[06:50:19] <Skrylar_> bjz: it seems like sam lantinga made one of those...
[06:50:26] <Skrylar_> acrichto: you would be incorrect
[06:50:34] <Skrylar_> GL3-4+ require shaders for all functionality
[06:50:35] <Yurume> ...and it's called a Simple Directmedia Layer...
[06:50:51] <bjz> acrichto: you might be better off using SDL2
[06:51:06] <Yurume> bjz: just out of curiosity, what was missing from rust-sdl2?
[06:51:10] <acrichto> at this point wow you're right
[06:51:23] <bjz> Yurume: I'm just not a real fan of how its wrapped
[06:51:27] <Yurume> I'm seriously trying to move from SDL to SDL2
[06:51:45] <Yurume> (and I'm not a fan of SDL_gfx ;)
[06:51:47] <bjz> Yurume: I'm making my own wrapper, although I only have the ffi done
[06:51:57] <Skrylar_> there's mine too, it has a nice wrapper xD
[06:52:02] <bjz> Yurume: https://github.com/bjz/sdl2-rs/
[06:52:09] <Yurume> I think rust-sdl2 was broken in Windows, not sure it has been fixed
[06:52:25] <Skrylar_> bjz: k'now, if you already did the whole API I can wrap it
[06:52:39] <bjz> Skrylar_: I have most of the ffi
[06:52:47] <Skrylar_> i have events and half the window commands
[06:52:57] <Skrylar_> trying to figure out how to take a borrowed pointer and unsafely construct a ref around it
[06:53:03] <bjz> Skrylar_: still needs to be tested though
[06:53:13] <Skrylar_> i put a borrowed pointer to the window in SDL userdata, so i can get the window ref back later
[06:53:15] <bjz> oh, I can figure that stuff out
[06:53:29] <bjz> ah
[06:53:35] <Skrylar_> the window object is destroyed when dropped, so there's no leak
[06:53:38] <Skrylar_> its a weak reference
[06:53:49] <bjz> yeah, that kind of stuff is tricky to do safely
[06:54:04] <Skrylar_> i changed it out to = theRc.borrow() because I was told that gives you a pointer to the data
[06:54:05] *** Quits: csherratt (csherratt@moz-CAF331EA.cable.teksavvy.com) (Quit: csherratt)
[06:54:14] <Skrylar_> now i pulled it back as a borrowed pointer, need to box it
[06:54:37] <bjz> I'm leaning more towards doing that stuff with channels now
[06:54:49] <bjz> but I dunno
[06:54:57] <Skrylar_> i use a pump because thats what SDL does
[06:55:10] <Skrylar_> and since SDL doesn't appreciate threading in the event pump, I don't see a benefit
[06:55:13] <bjz> yeah, you can wrap that in an iterator nicely
[06:55:38] <Skrylar_> refactoring these pointers to be better, then.. donno
[06:55:52] <Skrylar_> I have it on my list to do the event overhaul so theres no more copying overhead
[06:55:56] *** Joins: csherratt (csherratt@moz-CAF331EA.cable.teksavvy.com)
[06:56:06] <Skrylar_> even though it makes it a little weirder because you have to x.timestamp() instead of accessing directly
[06:56:19] <bjz> yep
[06:57:24] <bjz> well you can make the union so its SDL_Event { type: Uint32, timestamp: Uint32, data: [u8, ..40] }
[06:57:41] <bjz> seeing as those are common
[06:58:04] <Skrylar_> yeah i thought about having the iterator instance the union
[06:58:12] <Skrylar_> that might be unsafe, hrm
[06:58:23] <bjz> what do you mean?
[06:58:33] <Skrylar_> i thought about having it prepare the union, then step each event
[06:58:42] <Skrylar_> though i guess the union could just live in the iterator as a permanent buffer
[06:58:57] <Skrylar_> now how do you get events back out?
[06:59:02] <Skrylar_> you can't shove borrowed pointers in an enum
[06:59:30] <bjz> well, you would have .as_button(&'a self) -> Option<&'a ButtonEvent>
[06:59:39] <Skrylar_> i don't know how lifetimes work :B
[06:59:40] <bjz> maybe
[06:59:55] <Skrylar_> right now its just match event { hey handle this and unpack the data locally }
[07:00:00] <bjz> I mean, Event::as_button<'a>(&'a self) -> Option<&'a ButtonEvent>
[07:00:13] <Skrylar_> i could have it so you get the match and then a separate event check with as_X
[07:00:29] <Skrylar_> match { text_input => x.as_text_input }
[07:00:45] <bjz> so that basically means that `&'a ButtonEvent` is tied to the lifetime of self, which means no copying takes place
[07:00:49] <Skrylar_> i could put the union in a RefCell 
[07:00:51] <Skrylar_> maybe
[07:00:58] <Skrylar_> but that opens up unsafety
[07:01:03] <Skrylar_> no it doesn't
[07:01:09] <Skrylar_> why are people holding refs to a refcell they know its mutable
[07:01:10] <bjz> not if you check the event type
[07:01:16] <Skrylar_> a refcell would work
[07:01:21] <Skrylar_> can put that in the enum, handle events one at a time
[07:01:29] <bjz> then return None if its not a button event
[07:01:31] <Skrylar_> RefCell already indicates "THE CONTENTS WILL CHANGE" so people know to clone if they want to hold it
[07:01:39] <bjz> why a RefCell?
[07:01:40] <bjz> :S
[07:01:49] <Skrylar_> put the union in a refcell, put refcell in iterator
[07:01:54] <Skrylar_> now the iterator can return an enum
[07:02:00] <Skrylar_> with the transmuted refcell
[07:02:05] <bjz> :S
[07:02:45] <Skrylar_> actually i think you can turn a refcell in to a cell
[07:02:52] <Skrylar_> if you can, then that could work
[07:03:13] <Skrylar_> i mostly would just prefer the API be not-ugly, and having to "as_event" when match just proved the event is correct is ugly
[07:04:23] <Skrylar_> i was wrong; *thinks*
[07:04:41] <bjz> I dunnopub fn as_window<'a>(&'a self) -> Option<&'a SDL_WindowEvent> { match transmute::<SDL_Event, SDL_WindowEvent>(self.data) { e if e.event_type == SDL_WINDOWEVENT => Some(e), _ => None } } }
[07:05:08] <bjz> yeah, it is ugly, unfortunately
[07:08:24] * bjz gets back to glfw
[07:08:31] <bjz> acrichto: how goes things?
[07:09:29] <acrichto> bjz: I still have no idea what I'm doing
[07:10:08] <bjz> acrichto: http://i.imgur.com/xVyoSl.jpg
[07:10:18] <acrichto> hahaha that is exactly how I feel
[07:10:39] <acrichto> so all code examples I have found are apparently all deprecated
[07:10:48] <acrichto> and the bindings don't even exist in gl-rs
[07:11:18] <bjz> yep. I made sure of that. I should put an FAQ
[07:11:35] <bjz> if you are desparate for them, you could make your own mini ffi
[07:11:44] <acrichto> nah I should do this the right way
[07:11:50] <bjz> but they *are* deprecated
[07:11:53] <acrichto> just kinda depressing that it's like 200 lines to draw a square on the screen
[07:12:02] <bjz> yay opengl 3+
[07:12:15] <bjz> :)
[07:12:27] <acrichto> ok, so I copied your triangle example
[07:12:33] <acrichto> now I need to get it to draw a square
[07:12:42] <Skrylar_> bjz: i'll try to figure out something elegant when i get this pointery fixed
[07:12:48] <acrichto> I am unsuccessful in doing that so far
[07:12:52] <bjz> acrichto: add another triangle
[07:12:57] <bjz> xD
[07:13:09] <Skrylar_> yeah, the newer GL is..
[07:13:13] <Skrylar_> not newbie friendly
[07:13:16] <acrichto> oh there we go!
[07:13:21] <acrichto> found the third location I had to tweak
[07:13:44] <Skrylar_> for the newer GL you have to write a fragment shader to replace gl1.1 functinoality
[07:14:25] <bjz> acrichto: the tute shows a rectangle - you can adapt the triangle code: http://www.open.gl/drawing
[07:14:34] <acrichto> I have a square!
[07:14:50] <acrichto> the tutorial doesn't have a lot of complete code
[07:15:00] <acrichto> it has a lot of code snippets, but I'm having trouble weaving them all together
[07:15:03] <bjz> http://www.open.gl/content/code/c2_triangle_elements.txt
[07:15:16] <bjz> look at the bottom of the tutes - it is poorly marked
[07:15:17] <acrichto> omg you are a lifesaver
[07:15:28] <bjz> but there are full code examples
[07:15:59] * bjz should really update https://github.com/bjz/open.gl-tutorials
[07:16:04] <Skrylar_> there's a cool library they made for C++
[07:16:08] <acrichto> ok, now I need to upload a texture to the shader
[07:16:09] <acrichto> I think
[07:16:16] <Skrylar_> its supposed to re-add the old GL1.x stuff as compliant but new API
[07:16:16] <bjz> but he is in pain from Rust dependency management
[07:16:18] <Skrylar_> i forget the name
[07:16:30] * bjz groans
[07:17:37] <bjz> why dependency management so hard
[07:17:57] <bjz> such pain, many sad
[07:18:33] <Skrylar_> isn't rustc supposed to deal with that for you?
[07:18:50] <Skrylar_> admittedly so is that rustpackage tool or i forget, but that won't build exe's due to bugs
[07:19:29] <bjz> rustpkg - i really dunno
[07:19:44] * bjz gave up on it
[07:20:43] <bjz> wow, rust_stb_image is out of date https://github.com/mozilla-servo/rust-stb-image
[07:25:16] <Skrylar_> eddyb was wanting a pure-rust png loader
[07:25:40] <bjz> yeah
[07:25:47] <bjz> that would be rad
[07:25:55] <Skrylar_> hr
[07:26:04] <Skrylar_> can't find a way to make a ref to a borrowed pointer
[07:26:16] <Skrylar_> well, a Rc
[07:26:40] <bjz> could you give a gist?
[07:27:04] <Skrylar_> one minute
[07:27:33] <Yurume> Skrylar_: pure-rust zlib plus png?
[07:28:53] <Skrylar_> bjz: what exactly do you want the gist of?
[07:29:11] <Skrylar_> i can make one, but i just do transmute(Rc.borrow()) to get the c_void
[07:29:26] <bjz> Yurume: something like stb-image
[07:29:36] <Skrylar_> Yurume: i think eddy did want a pure zlib+png
[07:29:48] <Skrylar_> but he kept getting distracted from writing the deflater
[07:29:48] <bjz> https://github.com/mozilla-servo/rust-stb-image/blob/master/stb_image.c
[07:31:16] <Yurume> Skrylar_: is there a particular reason for that? while zlib's decompression is not the best it's not slow.
[07:31:44] <Skrylar_> he said it'd be safe
[07:31:52] <Skrylar_> if done with all the rustic types
[07:32:03] <Skrylar_> i remember zlib has had its share of security holes but meh
[07:35:40] <Yurume> well, pure-Rust zlib/libpng is as safe as its `unsafe` parts and non-memory safety (not guranteed by rustc).
[07:36:06] <Yurume> I'm interested in that but mostly don't buy the safety argument.
[07:48:43] <Yurume> Skrylar_: I don't know it's performant, but there is rust-deflate: https://github.com/yjh0502/rust-deflate/blob/master/deflate.rs
[07:48:57] <Yurume> interested in eddyb's version of deflater
[08:03:43] <Skrylar_> hrm
[08:03:49] <Skrylar_> i guess you just can't re-box a ref
[08:06:15] <Skrylar_> if there was a WeakRc that would do it
[08:06:30] <bjz> That kind of thing will probably be improved
[08:06:56] <Skrylar_> so what am i supposed to do for these events that return refereences to the applicable window
[08:08:49] <Yurume> Skrylar_: so that WeakRc::borrow() returns Option<&'r T>?
[08:09:20] <Skrylar_> hrm
[08:09:28] <Skrylar_> if i transmute to an owned pointer it does let it get reboxed
[08:09:44] <Skrylar_> all though i'm sort of concerned as to if new_unchecked is going to behave poorly regarding that
[08:13:55] <Skrylar_> ah no, you can't have mutable fields in an enum
[08:14:16] <Skrylar_> okay, this will take some serious retooling
[08:20:43] <acrichto> bjz: ok, I have a square and lots of shaders and everything looks hooked up correctly, except nothing is getting drawn :(
[08:20:59] <bjz> lots of shaders?
[08:21:08] <acrichto> just 2
[08:21:15] <bjz> not just a frag and a vert?
[08:21:15] <acrichto> more than 0 :P
[08:21:17] <bjz> oh ok
[08:21:21] <bjz> haha
[08:21:23] <bjz> you funny
[08:21:36] <bjz> are you calling glGetError?
[08:21:43] <acrichto> no
[08:21:59] <bjz> oh the joys of opengl debugging xD
[08:22:03] <acrichto> oh whoops the fragment shader was wrong
[08:22:16] <acrichto> aww still blue
[08:22:30] <bjz> are you checking for compile errors with the shader?
[08:22:45] <acrichto> probably not
[08:23:03] <acrichto> CompileShader doesn't return anything?
[08:23:06] <bjz> unfortuntately the tute doesn't go into that
[08:23:15] <bjz> just a sec, I'll get an example
[08:24:08] <bjz> acrichto: https://gist.github.com/bjz/a0f15bb2b03fda0f97cc#file-terrain-rs-L61-L104
[08:24:39] <acrichto> dear god
[08:24:45] <bjz> hah!
[08:24:57] <bjz> oh wait
[08:25:02] <bjz> that's a bad version
[08:25:17] <bjz> I have a simpler one...
[08:25:21] <bjz> somewhere
[08:26:09] * bjz looks through old gists
[08:26:13] <acrichto> ERROR: One or more attached shaders not successfully compiled
[08:26:21] *** Quits: tiffany (kawaii@moz-FC0DB29D.dhcp.embarqhsd.net) (Input/output error)
[08:26:33] <acrichto> sounds suspicious
[08:27:30] <bjz> https://gist.github.com/bjz/2eddf79971df6df87f8d#file-shader-rs-L41-L50
[08:27:47] <bjz> https://gist.github.com/bjz/2eddf79971df6df87f8d#file-shader-rs-L149-L160
[08:27:51] <acrichto> ah thanks
[08:28:23] <bjz> the actual shader thingy there is overengineered - so just look at those bits
[08:28:30] <acrichto> ERROR: 0:9: ';' : syntax error syntax error
[08:28:34] <bjz> heh
[08:28:38] <bjz> there you go
[08:28:50] <acrichto> hmm...
[08:29:12] <acrichto> lol copy paste
[08:29:18] <acrichto> I have a black square in a blue square!
[08:29:29] <acrichto> I was hoping the black square wouldn't be black..
[08:29:34] <bjz> also, if you still have errors, try sprinkling glGetError around. it's woefully inadequate, but it can help you zero in on a problem
[08:29:35] *** Joins: ecl3ctic (Mibbit@moz-E1FAD64C.wzfv1.vic.bigpond.net.au)
[08:29:44] <acrichto> cool
[08:30:12] <acrichto> how do I stringify the error?
[08:30:18] <bjz> it basically stores a single error in a global var
[08:30:26] <bjz> it's an error code -_-#
[08:30:33] <acrichto> that's it?
[08:30:39] <bjz> there are.... like five I think?
[08:30:49] <bjz> and you have to refer to the docs
[08:30:54] <Yurume> acrichto: glGetShaderInfoLog returns a string
[08:30:55] <acrichto> INVALID_ENUM
[08:31:06] <Yurume> (or rather, receives a pointer to the buffer and fills it)
[08:31:06] <acrichto> these aren't with shaders though
[08:31:11] <bjz> acrichto: yep
[08:31:16] <Yurume> ah
[08:31:22] <acrichto> gl::TexImage2D(gl::TEXTURE_2D, 0, gl::RGB as i32,     gpu::WIDTH as i32, gpu::HEIGHT as i32, 0, gl::RGBA8, gl::UNSIGNED_BYTE,       data.as_ptr() as *libc::c_void);      
[08:31:39] <acrichto> does that mean that RGBA8 isn't supported?
[08:31:56] <bjz> acrichto: so you did gl::GetError before and after it?
[08:32:01] <acrichto> zomg it works!
[08:32:12] <acrichto> RGBA8  => RGBA and it's happy
[08:32:19] <bjz> nice!
[08:32:27] <bjz> you see emulatorness?
[08:32:37] <acrichto> I see asteroides!
[08:32:41] <bjz> YAY!!!
[08:32:52] <acrichto> and tetris!
[08:32:53] <bjz> now close up the file, and never look at it again
[08:32:57] <bjz> :D
[08:32:58] <acrichto> poorly rendered...
[08:33:06] <acrichto> man this is tiny
[08:33:17] <acrichto> 160x144 is really teeny
[08:33:21] <bjz> hehe
[08:33:24] *** Quits: jdm_ (jdm@moz-3FFA85CA.dsl.teksavvy.com) (Connection reset by peer)
[08:33:26] <bjz> on a retina?
[08:33:29] <acrichto> I guess there isn't a "2x blowup" function
[08:33:31] <acrichto> yeah
[08:33:36] <bjz> xD
[08:33:42] <bjz> look at the kitten tute
[08:33:46] <acrichto> lol still have to look at sdl
[08:33:48] <acrichto> opengl*
[08:34:09] *** Joins: jdm (jdm@moz-3FFA85CA.dsl.teksavvy.com)
[08:34:39] <bjz> what happens if you just use a bigger window?
[08:35:25] <acrichto> whoa that just worked!
[08:35:36] <bjz> heh
[08:35:37] <acrichto> hm I need to lock the aspect ratio
[08:35:41] <bjz> yeah
[08:35:44] <acrichto> can you do that?
[08:35:55] <bjz> I think glfw has a window hint
[08:36:05] <bjz> now you can show this code to pcwalton
[08:36:20] <bjz> he wants to move to opengl I think
[08:36:27] <acrichto> lol
[08:36:39] <acrichto> oh hm resizable
[08:36:44] <acrichto> not quite what I want
[08:37:01] <acrichto> not sure that it has one for ratios
[08:37:24] <bjz> acrichto: https://github.com/bjz/glfw-rs/blob/master/src/glfw/lib.rs#L624
[08:37:27] <bjz> ah
[08:37:44] <acrichto> maybe I should just control it manually
[08:38:02] <bjz> could you do something with the window resize callback
[08:38:17] <bjz> you could also just map the +/- keys
[08:38:26] <bjz> to blow up in multiples
[08:38:28] <acrichto> I guess I can resize
[08:38:33] <acrichto> +/- it is
[08:43:17] <acrichto> ok I need to modify this code from the tude
[08:43:18] <acrichto> tute*
[08:43:24] <acrichto> it has a border, I don't need a border
[08:43:28] <acrichto> I have to understnd things ;_;
[08:43:55] <acrichto> oh that was easy
[08:44:24] <Skrylar_> hrm
[08:44:36] * Skrylar_ ponders how to deal with this window id setup
[08:44:37] <acrichto> bjz: omg thank you so much!
[08:44:48] <bjz> acrichto: yay, no worries
[08:44:57] <Skrylar_> the problem is sdl gives you IDs, which means i need to store a window ref to that id, which means the ref table holds the reference open, so you can't close windows by dropping them out of scope :/
[08:44:58] <bjz> acrichto: I had no idea what I was doing btw
[08:44:58] <acrichto> my god I have some gpu bugs to fix
[08:45:02] <bjz> :D
[08:45:06] <acrichto> bjz: but everythign works now!
[08:45:12] <acrichto> and it's at 6% cpu usage
[08:45:17] <bjz> opengl is so weird xD
[08:45:20] <acrichto> which is awesome
[08:45:24] <bjz> really?
[08:45:35] <acrichto> in my js version it never went below 50
[08:45:39] <bjz> heh
[08:45:42] <bjz> yay
[08:45:49] <acrichto> now to compile this with emscripten!
[08:45:51] <bjz> go systems langs
[08:45:58] <acrichto> I wonder if that would "just work" for the opengl stuff
[08:46:14] <bjz> heh, no idea
[08:46:20] * bjz somehow doubts it
[08:46:37] <acrichto> yeah...
[08:46:39] <bjz> acrichto: I dunno anything about webgl
[08:47:07] <bjz> I believe it uses similar stuff to opengles - which uses the new pipeline
[08:47:17] <bjz> so you are lucky you did it using that
[08:47:24] <acrichto> lol
[08:47:29] <acrichto> this is all voodoo magic to me
[08:48:02] <acrichto> bjz: btw, have you seen https://travis-ci.org/alexcrichton/jba/builds/16246407 on travis before?
[08:48:08] <acrichto> it couldn't find libglfw.so
[08:48:12] <Yurume> bjz: OpenGL ES (2) is actually a compatibility-breaking version of OpenGL (4?), so it should be fine
[08:48:14] <acrichto> even though I have your same .travis stuff which install glfw
[08:48:36] <Yurume> actually I positioned to OpenGL ES 2+ in order to make myself familiar to the modern OpenGL pipeline
[08:48:42] <Yurume> (and do not use glBegin etc.)
[08:48:45] <bjz> I think I need to use some tool to get the location of glfw
[08:48:59] <bjz> seeing as som pakage managers label it differently
[08:49:31] <acrichto> maybe /usr/local/lib just isn't in the path
[08:50:50] <acrichto> bjz: oh you just build the examples on travis, you don't run them
[08:50:59] <acrichto> that would explain that
[08:51:03] <bjz> acrichto: hmm
[08:51:09] <bjz> should I?
[08:51:16] <bjz> I wouldn't know how to stop them
[08:51:26] <acrichto> oh I just have unit tests
[08:51:29] <acrichto> nothing that uses gl
[08:51:34] <bjz> http://www.glfw.org/docs/latest/build.html
[08:51:35] <acrichto> but it's a linked .so
[08:51:38] <acrichto> so it's gotta find it
[08:51:49] <bjz> ahh, pkg-config
[08:52:02] <acrichto> yet another thing I have no clue how it works
[08:52:25] <acrichto> gl-rs takes awhile to build
[08:53:00] <bjz> acrichto: you can cut down the number of extensions you include
[08:53:02] <acrichto> nothing compared to rustc though!
[08:53:09] <bjz> but yeah, it does
[08:53:13] <bjz> :(
[08:53:30] <acrichto> oh it's not long at all lol
[08:53:35] <acrichto> I build it once and I'm done
[08:53:43] <acrichto> just watching travis
[08:53:51] <acrichto> which is somehow hypnotic
[08:54:06] <bjz> it is
[08:54:10] <bjz> whuh
[08:54:16] <bjz> a sparrow is in my room
[08:54:21] <bjz> shoo
[08:54:22] <acrichto> ...
[08:54:26] <acrichto> that is not normal
[08:54:55] <bjz> weird
[08:55:03] <bjz> (my window is open)
[08:55:13] <acrichto> yay! passing on travis now
[08:55:15] <bjz> well, balcony door
[08:55:34] <bjz> ok, so fmt::Format passes
[08:55:37] <bjz> yay
[08:55:41] <acrichto> nice!
[08:55:43] <acrichto> ok it's 3am
[08:55:45] <acrichto> I need sleep
[08:55:47] <acrichto> but it work!
[08:55:48] <bjz> night!
[08:55:49] <acrichto> bjz: you're the best
[08:55:53] <bjz> no worries
[08:55:58] <bjz> lad to help
[08:56:01] <bjz> *glad
[08:56:03] <acrichto> :D
[08:56:15] *** Parts: acrichto (acrichto@moz-B63D64BD.res.cmu.edu) ()
[09:07:53] <Skrylar_> bjz: hrm, it looks like if you use chans for events you get back in to the copying problem
[09:08:07] <bjz> with what?
[09:08:11] <Skrylar_> SDL events
[09:08:23] <bjz> yeah you will
[09:08:34] <bjz> if you want to use a custom enum
[09:08:41] <Skrylar_> you can avoid that, kinda, with a direct iterator and some craziness
[09:08:52] <bjz> yep
[09:09:05] <Skrylar_> i tried a for_all_events() method which takes a lambda
[09:09:23] <Skrylar_> that introduces some... problems of other types
[09:09:56] <Skrylar_> i wonder if its possible to do a mutable enum
[09:10:25] <Skrylar_> bleh
[09:10:43] <Skrylar_> its either copy a 56-byte struct for every event, or check the event tag twice
[09:11:24] <Skrylar_> well there's another option but its horrible
[09:11:29] <Skrylar_> make a trait that handles every SDL event
[09:11:35] <Skrylar_> pass a borrowed pointer in to that trait
[09:11:50] <Skrylar_> that does avoid copying every event
[09:13:53] * Skrylar_ ponders
[09:14:36] <Skrylar_> i think the trait method is the only one that doesn't involve copying or horrible API
[09:15:15] <Skrylar_> i don't think you can do blocking channels
[09:15:27] <Skrylar_> I know in Go you can have channels with a limit of 1, so they block until someone handles it
[09:15:29] <bjz> yeah, you might be right
[09:15:57] <Skrylar_> in that case, you can do some tricks like giving an immutable ref through the channel, and since the chan has a limit of 1 you know that the message has been dealt with when the line clears
[09:16:06] *** Quits: csherratt (csherratt@moz-CAF331EA.cable.teksavvy.com) (Quit: csherratt)
[09:16:22] <Skrylar_> now the question is
[09:16:31] <Skrylar_> one big trait for all events or a dozen traits and a pointer container
[09:16:54] <Skrylar_> i could actually store the trait table in the userdata, which sideskirts the "which window got this event?" problem entirely
[09:17:02] <Skrylar_> ... basically like glfw-rs did, haha
[09:17:10] <bjz> yayy
[09:17:43] <Yurume> what's the copying problem?
[09:18:30] <Yurume> I thought SDL events are mostly PODs (other than some handles) and not discouraged for copying
[09:18:56] <bjz> yeah, I am wondering why Skrylar_ want's to copy stuff
[09:19:27] <bjz> oh you mean it's not bad to copy?
[09:19:33] <Yurume> yeah
[09:19:46] <bjz> ah
[09:19:59] <bjz> see you could copy into a nicer rustic enum
[09:20:09] <bjz> as opposed to the union
[09:20:18] <Yurume> aha
[09:20:33] <Yurume> so you need to translate C SDL_Event into Rust enum everytime?
[09:20:42] <bjz> no, only once
[09:20:50] <bjz> per event though
[09:20:53] <Yurume> *per event
[09:20:56] <bjz> yep
[09:21:47] <Skrylar_> well what my first stab did was just that
[09:21:54] <Skrylar_> it copied data from the SDL POD in to the nicer rust one
[09:21:57] <Yurume> I'm more concerned with the central event handling
[09:22:38] <Skrylar_> if i make the fields private for the FFI struct, i can pass those to SDL to fill in
[09:22:47] <Skrylar_> then use an impl on the rust-side to provide accessors that should get inlined out
[09:22:54] <Skrylar_> but do the conversions lazily when they're actually needed
[09:23:03] <bjz> yep
[09:23:09] <Skrylar_> and using trait dispatch, i don't have to copy the event because it just borrows it 
[09:23:10] <Yurume> well, translating (as opposed to copying) is in my opinion not very costly, though you may want not to translate during internal processing
[09:23:27] <Skrylar_> so the downside is it feels like Objective-C
[09:23:30] <Skrylar_> but the upside is zero-copy
[09:23:35] <Skrylar_> and lazy evaluatino
[09:24:10] <Skrylar_> i'd rather do the match event {...} because that feels right, but i want to avoid pointless copying more
[09:24:18] <Skrylar_> especially because GUI libs on top are going to do more copying on their own
[09:24:33] <Yurume> so that i) SDL2 internally has a mapping from the window handle to the trait and ii) explicit event loop delegates the struct to the corresponding trait?
[09:24:48] <Skrylar_> yeah
[09:24:54] <Skrylar_> bjz did that for glfw, basically
[09:25:03] <Skrylar_> except he did it to handle C callbacks
[09:25:23] <Yurume> I think the similar argument or strategy also applies to Win32 API
[09:25:32] <Yurume> which has basically the same design
[09:26:22] <Yurume> (of course, Win32 message is much smaller than SDL event in size, but as mentioned before I think the size difference is not that severe)
[09:27:54] <bjz> Yurume: what do you mean by, "you may want not to translate during internal processing"
[09:28:10] <Skrylar_> my guess is a lot of boxing while you get the PODs in an enum
[09:28:22] <Skrylar_> e.g. just slotting it over is okay but a lot of moving things around isn't
[09:28:59] <Yurume> bjz: e.g. if there is no event handler for window handle 42, then you don't want to convert the event for that window to Rust-friendly structs or whatever.
[09:29:27] <bjz> Yurume: ah
[09:29:27] <Skrylar_> well i re-engineered it so it doesn't translate anymore
[09:29:32] <Skrylar_> though dispatch is up for debate
[09:30:22] <Skrylar_> problem with enum dispatch is the window handle
[09:30:30] <Skrylar_> whereas trait dispatch avoids that problem
[09:30:55] <bjz> window handles.... fml
[09:31:38] <Skrylar_> rust is a very strange language to do GUIs in
[09:31:48] <Skrylar_> because so many normal GUI paradigms run in the face of what rust doesn't like you doing
[09:32:08] <bjz> aye
[09:33:02] <Skrylar_> is there a 'sizeof' operator in rust?
[09:33:12] <Yurume> I recall my friend doing heavy Win32 programming often runs a local message loop in order to catch some special message, I think
[09:33:19] <Yurume> Skrylar_: std::mem::size_of::<T>()
[09:33:29] * bjz should have a closer look at eXene
[09:33:53] <Skrylar_> Yurume: can i do a static assert with it?
[09:33:59] <bjz> no
[09:34:15] <Skrylar_> https://mail.mozilla.org/pipermail/rust-dev/2012-December/002838.html balls
[09:34:31] <bjz> rust has very limited static stuff
[09:34:32] <Yurume> Skrylar_: I think no
[09:34:38] <Skrylar_> i miss D :(
[09:34:41] <Skrylar_> when D was good
[09:35:06] <Yurume> sizeof is a reserved word (unused however)
[09:35:13] <Yurume> for that reason
[09:35:15] <Skrylar_> i guess i'll just put in a test module that makes sure the struct sizes are correct
[09:35:23] <Yurume> it's a good compromise
[09:36:01] <bjz> Skrylar_: that was at the end of 2012 btw - I think pcwalton's views are evolving
[09:36:08] <bjz> re. CTFE
[09:39:32] <Skrylar_> yay, unresolved names of things in parent modules
[09:39:41] <Skrylar_> all though earlier ::Struct worked, now it doesn't
[09:41:13] <bjz> rust paths are weird :]
[09:42:48] <Skrylar_> so are some of the functions
[09:42:58] <Skrylar_> mem::size_of<StructName>()
[09:43:05] <Skrylar_> "nope that isn't a fully instantiated struct" fml
[09:44:14] <bjz> mem::size_of::<StructName>()
[09:44:24] <bjz> (need the ::)
[09:44:27] <Skrylar_> what an aggravating and undocumented syntax ._.
[09:44:57] <bjz> it's for disambiguating the stupid <> :P
[09:45:14] <bjz> yay, thanks C++ for your lovely syntax
[09:47:31] <Skrylar_> sometimes i have to keep reminding myself
[09:47:33] <Skrylar_> "at least its not c"
[09:47:53] <Skrylar_> C/C++: Spend 12 hours getting simple code to stop bugging
[09:47:59] <Skrylar_> Rust: Spend 12 hours getting simple code to compile
[09:48:15] <bjz> heh :D
[09:48:32] <Skrylar_> admittedly that code has never crashed in my experience
[09:49:04] <bjz> indeed
[09:49:12] <Skrylar_> okay, that unit test works
[09:49:21] <Skrylar_> i put in a test that makes sure each union struct is padded correctly
[09:49:42] *** Joins: squiddy (squiddy@moz-4265BEBB.adsl.alicedsl.de)
[09:51:18] <Skrylar_> globs better stay
[09:51:43] <Skrylar_> they're useful when you want to pull in a module's submodules in to a single import, for lib writing
[09:53:34] *** Quits: jdm (jdm@moz-3FFA85CA.dsl.teksavvy.com) (Input/output error)
[09:53:44] *** Joins: jdm (jdm@moz-3FFA85CA.dsl.teksavvy.com)
[09:55:29] <Skrylar_> aren't pre-given implementations in a trait overriden if you specify them?
[09:55:35] <Skrylar_> i thought they were there so you could put in defaults
[09:58:11] <Yurume> yes
[09:58:33] <Skrylar_> i'm using the cocoa names for events :|
[09:58:35] <Skrylar_> mouse_did_move
[09:59:12] <Yurume> so there are two uses of default methods: convenient defaults for implementors, and helper methods using core and more primitive methods (not intended to be overriden)
[10:02:10] <Skrylar_> now to remember the minor hell of doing trait casts in 0.9
[10:02:43] <Yurume> &T to &Trait?
[10:02:51] <Skrylar_> nope
[10:02:51] <Yurume> I think 0.9 implicitly coerces it
[10:02:54] <Skrylar_> has to be stored
[10:03:00] <Skrylar_> which means wrapping it up in a thing
[10:11:53] <zokier`> glfw does not build with rustpkg anymore?
[10:12:19] <bjz> zokier`: it might, but I reccomend just compiling via rustc directly
[10:12:28] * Skrylar_ peers
[10:12:32] <Skrylar_> if i do use mod::x
[10:12:36] <Skrylar_> it says no module, missing mod
[10:12:41] <Skrylar_> if i do mod, it says use must precede items
[10:12:52] <bjz> zokier`: were you using it?
[10:13:27] <zokier`> yup. used couple of months ago, and now trying to catch up again
[10:13:34] <bjz> ah
[10:14:05] <bjz> rustpkg is super broken. can't even get the tests to compile with make check when compiling rust
[10:16:53] <Skrylar_> okay, figured it out
[10:19:16] <Skrylar_> cannot assign to immutable field... of a mutable struct. :hrm:
[10:19:36] * Skrylar_ fiddles with the mut flags
[10:31:52] <Skrylar_> i'm about to bash my head in to the floor
[10:32:10] <Skrylar_> it won't let me use::, but if I mod everything builds; but then I can't use:: what i just mod'd
[10:37:48] <Skrylar_> ah, moving some files around worked. blegh
[10:38:00] <Skrylar_> this has been such a pain, trying to get SDL to work
[10:38:39] <bjz> yay rust x)
[10:56:14] *** Joins: siavashserver (siavash@EF3CD9D1.3DEB375.82A25C10.IP)
[10:59:51] <Skrylar_> i thought moving things to different .rs files would keep things clean
[10:59:56] <Skrylar_> it only made everything a colossal headache
[11:02:37] <zokier`> that is why i'm still stuck on on 700ish line file for my game
[11:03:19] <zokier`> s/on on/on a single/
[11:03:29] <bjz> why?
[11:03:51] *** Quits: ecl3ctic (Mibbit@moz-E1FAD64C.wzfv1.vic.bigpond.net.au) (Quit: http://www.mibbit.com ajax IRC Client)
[11:04:09] <bjz> Skrylar_: you will need to gist an example of your mod issues
[11:04:19] <zokier`> because i haven't yet gotten so far to understand how linking and modules work in rust
[11:04:26] <Skrylar_> bjz: i fixed them with more moving around
[11:04:38] <bjz> zokier`: feel free to ask on #rust
[11:04:39] <Skrylar_> all though the stupid thing is you can't tell rustc to work on a module using the proper module name
[11:04:55] <bjz> that is the best place for those questions
[11:04:58] <Skrylar_> the manual says x/mod.rs is a valid name for the central of X, and any other files in that are related
[11:05:06] *** kimundi is now known as zz_kimundi
[11:05:07] <Skrylar_> but rustc wants the filename, and then it acts stupid about it
[11:05:08] <bjz> What do you mean?
[11:05:20] <Skrylar_> rustc x/mod.rs or x/lib.rs will compile... as liblib
[11:05:22] <Skrylar_> or libmod
[11:05:29] <Skrylar_> UNLESS you tell it to output a specific name
[11:05:34] <Skrylar_> *then* it ignores you, but names it correctly
[11:05:52] <bjz> you need:
[11:05:54] <bjz> #[crate_type = "lib"];
[11:05:54] <bjz> #[crate_id = "github.com/bjz/glfw-rs#glfw:0.1"];
[11:06:06] <Skrylar_> i had that in one iirc
[11:06:14] <bjz> in your lib.rs
[11:06:16] <Skrylar_> i had to add -o blah, then it issued a warning about ignoring -o
[11:06:51] <bjz> try again, with a small test one - just for kicks
[11:07:43] <bjz> that one outputs libglfw-b34bcc5c-0.1.dylib for me
[11:08:03] <bjz> when compiling like: rustc lib.rs
[11:08:19] <Skrylar_> its the id
[11:08:24] <Skrylar_> rustpkg IDs don't work in normal rust
[11:08:31] <Skrylar_> if i set crate_id to simply 'sdl' it behaves
[11:08:35] <Skrylar_> sdl:0.1, it breaks
[11:08:56] <Skrylar_> foof@sdl:0.1, it builds
[11:08:59] <bjz> yeah I'm not sure if there is a syntax or what
[11:09:01] <Skrylar_> er, foof#sdl:0.1
[11:09:21] <bjz> and it probabkly isn't documented yet - I dunno
[11:10:56] <bjz> Skrylar_: http://static.rust-lang.org/doc/master/tutorial.html#crate-metadata-and-settings
[11:11:35] <bjz> wierd that is accepts "github.com/bjz/glfw-rs#glfw:0.1
[11:11:46] <Skrylar_> yeah .. eh
[11:11:59] <Skrylar_> now back to the migraine of getting event dispatching again, i guess
[11:12:05] <bjz> complain to acrichto
[11:12:10] <bjz> x)
[11:17:41] <siavashserver> Is there some kind of IDE for rust too? (With ability to debug visually instead of using gdb directly)
[11:19:13] *** Joins: FrozenCow (FrozenCow@moz-B2DF4929.chello.nl)
[11:19:16] <bjz> no :(
[11:19:42] <bjz> I think you can profile nicely with OSX's Instruments.app
[11:19:52] <bjz> and inspect all the functions
[11:19:57] <bjz> but not sure what else
[11:20:18] <zokier`> wasn't there some eclipse rust debug support?
[11:20:19] <dbaupp> siavashserver: yes, iirc you can use any application that can understand DWARF debug info
[11:20:24] <dbaupp> e.g. eclipse
[11:20:41] * bjz advises anybody not to listen to him
[11:20:55] <siavashserver> thank you guys :)
[11:20:56] <dbaupp> http://michaelwoerister.github.io/2013/09/27/what-you-call-the-present.html
[11:22:00] <Skrylar_> https://gist.github.com/Skrylar/8217841
[11:24:14] <bjz> Skrylar_: hey, that looks like glfw-rs!
[11:24:17] <bjz> xD
[11:24:31] <Skrylar_> heh
[11:24:41] <Skrylar_> and it doesn't actually work, just like when i used glfw-rs \o/
[11:24:45] * Skrylar_ fixes
[11:24:50] <siavashserver> lol
[11:24:54] <bjz> :P
[11:28:13] *** Quits: squiddy (squiddy@moz-4265BEBB.adsl.alicedsl.de) (Input/output error)
[11:32:05] *** Joins: ofeldt (ofeldt@moz-D989B272.dip0.t-ipconnect.de)
[11:33:05] *** Quits: ofeldt- (ofeldt@moz-3736EFF2.dip0.t-ipconnect.de) (Ping timeout)
[11:50:19] *** Quits: jdm (jdm@moz-3FFA85CA.dsl.teksavvy.com) (Quit: Lost terminal)
[11:53:41] *** Joins: jhasse (jhass_000@moz-3128EA21.ewe-ip-backbone.de)
[11:54:28] <Skrylar_> Rc<RefCell<T>> is one of the most ugly types to work with, lol
[12:06:10] <Skrylar_> bjz: woot, mouse events
[12:08:10] <Skrylar_> https://gist.github.com/Skrylar/8218341 heinous hackery
[12:17:51] *** Quits: Skrylar_ (Skrylar@moz-F692F728.austin.res.rr.com) (Ping timeout)
[12:35:58] *** Quits: siavashserver (siavash@EF3CD9D1.3DEB375.82A25C10.IP) (Quit: Konversation terminated!)
[12:52:23] *** Joins: samx (sami@moz-D9DA5773.dyn.optonline.net)
[12:53:03] *** Quits: samx (sami@moz-D9DA5773.dyn.optonline.net) (Quit: This computer has gone to sleep)
[13:34:36] *** zz_kimundi is now known as kimundi
[13:36:45] *** Quits: jhasse (jhass_000@moz-3128EA21.ewe-ip-backbone.de) (Quit: Verlassend)
[14:29:12] *** Joins: samx (sami@moz-D9DA5773.dyn.optonline.net)
[14:31:38] *** Joins: Ferreus (ferreus@moz-B23984A6.pools.arcor-ip.net)
[14:38:10] *** Quits: samx (sami@moz-D9DA5773.dyn.optonline.net) (Quit: This computer has gone to sleep)
[14:50:27] *** Joins: SiegeLord (sl@moz-CAF07B4C.hsd1.ma.comcast.net)
[14:54:28] *** Joins: tiffany (kawaii@moz-FC0DB29D.dhcp.embarqhsd.net)
[14:58:53] *** Quits: bjz (bjz@B398BE78.F804C29E.D35A31DF.IP) (Quit: Textual IRC Client: www.textualapp.com)
[14:59:00] *** Joins: bjz (bjz@B398BE78.F804C29E.D35A31DF.IP)
[15:19:24] *** Joins: ChristopherBurg (Christophe@moz-2C03E71B.hfc.comcastbusiness.net)
[16:12:00] *** Joins: csherratt (csherratt@moz-CAF331EA.cable.teksavvy.com)
[16:26:06] *** Parts: csherratt (csherratt@moz-CAF331EA.cable.teksavvy.com) ()
[16:33:15] *** Quits: bjz (bjz@B398BE78.F804C29E.D35A31DF.IP) (Ping timeout)
[16:37:44] *** Joins: bjz (bjz@B398BE78.F804C29E.D35A31DF.IP)
[16:53:03] *** Joins: samx (sami@moz-D9DA5773.dyn.optonline.net)
[17:00:09] *** Joins: jdm (jdm@moz-3FFA85CA.dsl.teksavvy.com)
[17:40:54] *** Quits: [o__o] (~o__o@moz-24EBFAC7.me) (Input/output error)
[17:41:11] *** Joins: [o__o] (~o__o@moz-24EBFAC7.me)
[17:51:02] *** Quits: [o__o] (~o__o@moz-24EBFAC7.me) (Input/output error)
[17:54:31] *** Joins: [o__o] (~o__o@moz-24EBFAC7.me)
[17:57:44] *** Joins: sebcrozet (sebcrozet@moz-F96421F3.w80-13.abo.wanadoo.fr)
[17:57:54] *** Quits: sebcrozet (sebcrozet@moz-F96421F3.w80-13.abo.wanadoo.fr) (Quit: Gone)
[18:04:00] *** Joins: brson (brson@moz-BBE3ABD.mv.mozilla.com)
[18:14:20] *** Joins: csherratt (csherratt@moz-CAF331EA.cable.teksavvy.com)
[18:16:01] *** Quits: csherratt (csherratt@moz-CAF331EA.cable.teksavvy.com) (Ping timeout)
[18:25:30] *** Joins: pcwalton (pcwalton@moz-C07D5168.p2p.sfo1.mozilla.com)
[18:25:31] *** ChanServ sets mode: +qo pcwalton pcwalton
[18:30:50] *** Quits: samx (sami@moz-D9DA5773.dyn.optonline.net) (Quit: This computer has gone to sleep)
[18:36:28] *** Joins: TimAbraldes (quassel@moz-7FD19BDC.hsd1.or.comcast.net)
[19:57:56] *** jdm is now known as jdm|busy
[20:30:31] *** jdm|busy is now known as jdm
[21:22:31] *** Joins: ecl3ctic (Mibbit@moz-E1FAD64C.wzfv1.vic.bigpond.net.au)
[21:29:19] *** Joins: geoffhill (geoffhill@moz-738DC0DB.org)
[22:11:27] *** Quits: larsberg (sid16141@moz-A42E5B7B.irccloud.com) (Ping timeout)
[22:12:11] *** Quits: dmarcos (sid15240@moz-31ABA2C0.irccloud.com) (Ping timeout)
[22:12:11] *** Quits: robert (uid15951@moz-A42E5B7B.irccloud.com) (Ping timeout)
[22:12:11] *** Quits: jack (sid19593@moz-A42E5B7B.irccloud.com) (Ping timeout)
[22:14:08] *** Quits: whitglint (uid15486@moz-31ABA2C0.irccloud.com) (Ping timeout)
[22:14:49] *** Joins: jack (sid19593@moz-A42E5B7B.irccloud.com)
[22:16:32] *** Quits: jack (sid19593@moz-A42E5B7B.irccloud.com) (Ping timeout)
[22:18:24] *** Quits: escalant3 (uid14896@moz-31ABA2C0.irccloud.com) (Ping timeout)
[22:18:37] *** Joins: escalant3 (uid14896@moz-31ABA2C0.irccloud.com)
[22:20:25] *** Quits: escalant3 (uid14896@moz-31ABA2C0.irccloud.com) (Ping timeout)
[22:26:50] *** Quits: ChristopherBurg (Christophe@moz-2C03E71B.hfc.comcastbusiness.net) (Ping timeout)
[22:31:00] *** Joins: Jarrett (chatzilla@moz-465FA06E.dhcp.rvsd.ca.charter.com)
[23:01:43] *** Joins: bjustin (bjustin@moz-8FC28563.sierrabravo.net)
[23:02:58] *** Joins: canhtak (canhtak@moz-59105D0.wl.t.ulaval.ca)
[23:05:54] *** Quits: geoffhill (geoffhill@moz-738DC0DB.org) (Ping timeout)
[23:07:53] *** Joins: samx (sami@moz-D9DA5773.dyn.optonline.net)
[23:10:12] *** Quits: tikue (tikue@moz-FEADCD38.hsd1.pa.comcast.net) (Ping timeout)
[23:10:20] *** Joins: tikue (tikue@moz-FEADCD38.hsd1.pa.comcast.net)
[23:12:11] *** Quits: bjustin (bjustin@moz-8FC28563.sierrabravo.net) (Quit: Textual IRC Client: www.textualapp.com)
[23:21:17] *** Joins: ChristopherBurg (Christophe@moz-2C03E71B.hfc.comcastbusiness.net)
[23:29:24] *** Quits: samx (sami@moz-D9DA5773.dyn.optonline.net) (Quit: This computer has gone to sleep)
[23:34:43] *** Quits: jdm (jdm@moz-3FFA85CA.dsl.teksavvy.com) (Quit: Lost terminal)
[23:41:40] *** Quits: FrozenCow (FrozenCow@moz-B2DF4929.chello.nl) (Client exited)
[23:44:57] *** Joins: csherratt (csherratt@moz-CAF331EA.cable.teksavvy.com)
[23:46:46] *** Quits: csherratt (csherratt@moz-CAF331EA.cable.teksavvy.com) (Ping timeout)
[23:49:26] *** Quits: canhtak (canhtak@moz-59105D0.wl.t.ulaval.ca) (Quit: canhtak)
[23:50:19] *** Joins: csherratt (csherratt@moz-8D848271.cpe.teksavvy.com)
[23:59:31] *** Joins: canhtak (canhtak@moz-59105D0.wl.t.ulaval.ca)

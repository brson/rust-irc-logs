[00:00:53] <noct> Question: is there a list of issues blocking a msvc build somewhere?
[00:01:07] <strcat> we use g++ exception handling
[00:01:15] *** Joins: ghrust (ghrust@614D05BD.6A2AE50.F3114085.IP)
[00:01:15] <ghrust> 01[13rust01] 15alexcrichton 04force-pushed 06try from 1484792ee to 145bdbe9d: 02http://git.io/k471pw
[00:01:15] <ghrust> 13rust/06try 145bdbe9d 15Alex Crichton: Turn off fast_ffi for some rarely-used LLVM calls
[00:01:15] *** Parts: ghrust (ghrust@614D05BD.6A2AE50.F3114085.IP) ()
[00:01:20] <cmr> noct: it's an unbounded problem atm
[00:01:45] <noct> ah, too bad
[00:01:49] *** Joins: steven_is_false (user@moz-144077DE.bchsia.telus.net)
[00:01:55] <cmr> noct: just getting the runtime (the c++ part) to build would be a nice first step
[00:01:58] <strcat> graydon: atm we have memory leaks from fixed_stack_segment
[00:02:05] <strcat> we have to choose
[00:02:27] <strcat> err
[00:02:35] * strcat cut off half that sentence
[00:02:37] <cmr> noct: we also need a linker to use.
[00:03:19] <cmr> noct: lld would ideally fill that roll, but if we could use the mingw linker or something provided by msvc, and not rely on the cc to handle linking for us, that'd be nice
[00:03:29] <cmr> (just for windows; it's fine on other platforms)
[00:03:48] <strcat> we can remove the C++ part of the runtime and just bootstrap from the stage0 compiler + a linker
[00:03:58] <steven_is_false> In my fixup of extra::arc I'm using a bad pattern. What should I actually do on lines 63 to 73 of https://github.com/sstewartgallus/rust/blob/refactor_arc/src/libextra/extra.rs ?
[00:04:03] <strcat> it's not hard to remove it, it's just boring
[00:04:11] <strcat> need to port code from C++ -> rust
[00:04:18] <cmr> strcat: it's not boring!
[00:04:20] <cmr> it's E-easy
[00:04:22] <cmr> ;p
[00:04:25] <strcat> E-boring
[00:04:28] <noct> haha
[00:04:35] <noct> thanks for the info cmr
[00:04:35] <cmr> yeah we probably need one of those actually :\
[00:05:23] <cmr> steven_is_false: pub mod sync { pub mod shared; pub mod wait_queue; ... }, probably
[00:05:33] <steven_is_false> I should probable make sync it's own module, and reexport it's submodules in extra but I don't know how to do that.
[00:05:38] <cmr> steven_is_false: you'd need to fix every caller though
[00:05:55] <cmr> hopefully just some imports
[00:06:01] <cmr> shouldn't be hard or that invasive though
[00:06:08] <steven_is_false> cmr: Yeah just a few.
[00:06:23] *** Joins: pnathan (Adium@B9840254.2CD8A5F8.477B877D.IP)
[00:06:41] <steven_is_false> Just doing pub use sync::*; at the top of extras should do it right?
[00:07:27] <cmr> steven_is_false: sure, but that's just a bandaid, rip it out altogether
[00:07:45] <steven_is_false> cmr: Okay
[00:07:51] <bjz> cmr: hum?
[00:07:59] <cmr> bjz: unsigned types implementing Neg
[00:08:14] <bjz> cmr: we need to divide up the trait
[00:08:24] <bjz> cmr: just haven't got around to it
[00:08:26] *** Joins: dherman (dherman@moz-6CA476B1.hsd1.ca.comcast.net)
[00:08:26] *** ChanServ sets mode: +o dherman
[00:08:32] <cmr> korenchkin: ^
[00:08:37] <cmr> that's why :)
[00:09:05] <bjz> korenchkin: https://github.com/mozilla/rust/issues/4819
[00:09:27] <bjz> korenchkin: please join in the discussion there if you feel you have something to add
[00:09:50] <bjz> korenchkin: :)
[00:10:16] <korenchkin> well, documenting was what i was up to, but now i'm waiting for rust tu build... again...
[00:10:52] <bjz> strcat: interesting to see how the iteration discussion has progressed on the D forum: http://forum.dlang.org/thread/kr2vpp$2jmf$1@digitalmars.com
[00:11:49] <bjz> korenchkin: oh were you? awesome!
[00:12:05] <bjz> korenchkin: we really need more documentation for the numerics
[00:12:35] *** Quits: pnathan (Adium@B9840254.2CD8A5F8.477B877D.IP) (Ping timeout)
[00:13:53] <aatch> is lld actually usable?
[00:14:04] <cmr> not robustly afaik
[00:14:21] <aatch> last I checked it only did static linking
[00:14:58] *** Quits: barosl (barosl@E287D94F.C81E10FB.7544CABF.IP) (Quit: ÎûúÎç§ÏùÄ Ïá†Ìá¥ÌñàÏäµÎãàÎã§.)
[00:15:26] *** Joins: roo (jesse.rudo@moz-B7585E4C.dynamic.ip.windstream.net)
[00:15:52] <korenchkin> How can i add documentation for the  i* and u* types? All the methods are defined in the *_macros.rs files, so it's not obvious where the doc comments should go
[00:16:25] <cmr> korenchkin: it might be best to wait until rustdoc2 is a bit farther along... it does proper macro expansion and stuff, whereas current rustdoc doesn't
[00:16:33] <korenchkin> okay
[00:16:53] <cmr> how they interact with the new rustdoc is an unknown atm
[00:17:19] <bjz> korenchkin: you could just add generic doc comments, rather than referring to the types directly
[00:17:31] <bjz> for now
[00:17:42] <korenchkin> to what? num.rs?
[00:18:07] <bjz> the int/uint macros
[00:18:47] <engla> the type-specific modules will disappear surely? they are not that useful
[00:18:58] <engla> once range is generic and other functions too
[00:19:45] <bjz> engla: hopefully, but it is sometimes important to specialise for the type size
[00:19:59] *** Quits: dherman (dherman@moz-6CA476B1.hsd1.ca.comcast.net) (Quit: dherman)
[00:20:50] <bjz> engla: hopefully the default methods will improve things, but I hope there can eventually be some kind of trait overload thiningy as me and nmatsakis have discussed
[00:22:01] <bjz> engla: ie. `impl Float for f64` would override impl<T:...> Float for T
[00:22:14] <engla> I imagine std::num::sin just being  fn sin<T: Trigonometric>(x: T) { x.sin() }  and so on
[00:22:20] <engla> hm ok
[00:22:29] <bjz> yep
[00:22:33] *** Quits: graydon (Adium@A5087023.2354C43D.D8E68FF6.IP) (Quit: Leaving.)
[00:22:34] <bjz> I want that too
[00:23:07] <bjz> the .sin() thingy is bloody irritating
[00:25:23] *** Joins: dherman (dherman@moz-6CA476B1.hsd1.ca.comcast.net)
[00:25:23] *** ChanServ sets mode: +o dherman
[00:25:25] <eevee> hm, vector addition went away
[00:25:42] <bjz> eevee?
[00:26:09] <eevee> i cannot do &[] + [], but i could in 0.6
[00:26:10] *** Quits: jmgrosen (jmgrosen@moz-848F6087.sb.sd.cox.net) (Quit: jmgrosen)
[00:26:35] <strcat> still looks like it's defined
[00:26:39] <dbaupp> eevee: &[] + &[] should work
[00:26:47] <strcat> the only thing that's gone is += implementations from the Add trait
[00:26:52] <strcat> because it will be done by AddAssign
[00:26:58] <dbaupp> eevee: (it's just that fixed length vectors are pretty broken)
[00:27:21] <eevee> hm, nope
[00:27:21] <eevee> amulet/ll.rs:244:30: 244:47 error: binary operation + cannot be applied to type `&[int]`
[00:27:25] <eevee> amulet/ll.rs:244             let padded_args = args + &[0, .. 8];
[00:28:23] <engla> yeah. the fixed size array won't add
[00:28:36] <engla> rusti: &[1,2,3] + &[2,3] // this is ok
[00:28:37] -rusti- ~[1, 2, 3, 2, 3]
[00:28:52] <dbaupp> cmr: after battling with some very strange bugs, IRSY is updating again
[00:28:58] <cmr> dbaupp: yay!
[00:28:59] <eevee> ah
[00:29:11] *** Joins: bytbox (s@moz-F994426C.wireless.umd.edu)
[00:29:41] <dbaupp> cmr: it appears that std::f64::from_str("2.410") fails on some computers :/
[00:29:44] <eevee> wait no it doesn't like that either, what
[00:29:54] <dbaupp> eevee: what's the output of rustc --version
[00:30:00] *** Quits: jaen (jaen@moz-E0979827.copit.pl) (Ping timeout)
[00:30:08] <bjz> dbaupp: those string conversions are in dire need of an overhaul
[00:30:16] <cmr> bjz: tests are failing
[00:30:17] *** Joins: jaen (jaen@moz-E0979827.copit.pl)
[00:30:18] <dbaupp> bjz: yep
[00:30:19] <bjz> dbaupp: as I'm sure you know
[00:30:23] <cmr> I don't know how they are passing on the buildbots
[00:30:26] <cmr> but they fail on my box
[00:30:29] <cmr> and a bunch of other peoples'
[00:30:43] <bjz> some awesome fellow needs to rewrite it
[00:30:43] <dbaupp> cmr: on an unmodified master?
[00:30:47] <cmr> dbaupp: yeah
[00:30:55] <dbaupp> cmr: what test?
[00:31:02] <dbaupp> cmr: (rustpkg something something?)
[00:31:04] <cmr> dbaupp: strconv
[00:31:08] <dbaupp> oh
[00:31:25] <bjz> cmr: hopefully we can get rid of strconv
[00:31:32] <cmr> some 5.28 being strconv'd to "0" silliness
[00:31:55] <bjz> cmr: I created it as an interim measure to shift alot of ugliness out of the num modules
[00:31:57] <cmr> guh, I forgot to ask graydon about webhooks *again*
[00:32:16] <bjz> cmr: we await an angel to help to rewrite it
[00:32:28] <cmr> bjz: is there an issue open about it?
[00:32:32] *** Quits: dherman (dherman@moz-6CA476B1.hsd1.ca.comcast.net) (Quit: dherman)
[00:32:51] *** Joins: jmgrosen (jmgrosen@moz-848F6087.sb.sd.cox.net)
[00:32:56] <bjz> cmr: I think there was some, but we might need a new one
[00:32:59] *** Quits: jaen (jaen@moz-E0979827.copit.pl) (Ping timeout)
[00:33:13] *** Joins: jaen (jaen@moz-E0979827.copit.pl)
[00:33:41] <cmr> http://rustlog.octayn.net/post/54635504503/status-update, good night all
[00:33:57] *** Quits: jmgrosen (jmgrosen@moz-848F6087.sb.sd.cox.net) (Quit: jmgrosen)
[00:34:00] <eevee> rustc 0.7
[00:34:00] <eevee> host: x86_64-unknown-linux-gnu
[00:34:18] <bjz> aatch: how busy are you at the moment?
[00:34:36] <aatch> bjz, this moment? not hugely.
[00:35:03] <dbaupp> eevee: does it work if you make the args ~[] rather than &[]?
[00:35:05] *** Joins: Yurume (yurume@AC58A8CE.8A059B47.E313B915.IP)
[00:35:09] <bjz> aatch: we need an awesome parser fellow to help out with num-string convs
[00:35:36] <bjz> aatch: are you interested?
[00:35:36] <dbaupp> eevee: (well, the left one particularly.)
[00:35:38] <aatch> bjz, hmm, I guess I could give it a shot.
[00:35:48] <bjz> aatch: sorry to put you on the spot
[00:36:00] *** Quits: bytbox (s@moz-F994426C.wireless.umd.edu) (Ping timeout)
[00:36:08] <aatch> bjz, it's fine. I looked at when doing some of the fmt! stuff
[00:36:16] <aatch> (which I should probably finish some day)
[00:36:55] <bjz> aatch: basically a rewrite would be the best option I'm thinking, as strcat says, it does a huge amount of allocation
[00:37:35] *** Quits: q66 (q66@6EE9DE40.46454B5D.33AABD5F.IP) (Quit: Leaving)
[00:37:47] <dbaupp> kimundi has a WIP of a lower allocation one, I think (fwiw)
[00:38:45] *** Quits: int3_ (int3_@moz-ABE52D50.hsd1.ca.comcast.net) (Client exited)
[00:39:12] <eevee> dbaupp: seems to.  it's a &[int] argument; that's the only difference from rusti
[00:39:22] *** Joins: jpochyla (jpochyla@moz-8D99AE5D.broadband18.iol.cz)
[00:39:53] <aatch> eevee, actually, engla's example is two &[]
[00:40:09] <aatch> rusti: &[1,2] + &[2,3]
[00:40:09] -rusti- ~[1, 2, 2, 3]
[00:40:29] <eevee> right, and i was trying to add a &[] arg and a &[] literal
[00:40:56] <aatch> rusti: let a = &[1,2,3]; a + &[4,5,6]
[00:40:57] -rusti- ~[1, 2, 3, 4, 5, 6]
[00:41:11] *** Quits: jpochyla (jpochyla@moz-8D99AE5D.broadband18.iol.cz) (Ping timeout)
[00:41:21] <aatch> rusti: let a = &[1,2,3]; a + &[0,..8]
[00:41:21] -rusti- <anon>:7:27: 7:39 error: failed to find an implementation of trait std::vec::Vector<<VI2>> for &[int, .. 8]
[00:41:21] -rusti- <anon>:7          let a = &[1,2,3]; a + &[0,..8]
[00:41:21] -rusti-                                     ^~~~~~~~~~~~
[00:41:22] -rusti- application terminated with error code 101
[00:41:36] <eevee> i got rid of the fixed size
[00:43:01] <aatch> rusti: let a = &[1,2,3]; a + [0,..8]
[00:43:02] -rusti- <anon>:7:27: 7:38 error: failed to find an implementation of trait std::vec::Vector<<VI2>> for [int, .. 8]
[00:43:02] -rusti- <anon>:7          let a = &[1,2,3]; a + [0,..8]
[00:43:02] -rusti-                                     ^~~~~~~~~~~
[00:43:02] -rusti- application terminated with error code 101
[00:43:09] <aatch> aw.
[00:43:28] <aatch> rust sometimes auto-slices fixed-sized vectors
[00:49:23] <acrichto> llvm can be upgraded! windows passed!
[00:49:25] <acrichto> r? https://github.com/mozilla/rust/pull/7115
[00:49:52] <aatch> acrichto, and done
[00:49:58] <acrichto> woo thanks!
[00:52:44] <dbaupp> eevee: so ~[] + &[] works? (I guess my changes to vec + must've landed just after the 0.7 version...)
[00:53:07] <eevee> ~[] + ~[] works; didn't try mixed sigils
[00:57:57] *** Quits: FrozenCow (FrozenCow@moz-B2DF4929.chello.nl) (Quit: Leaving)
[00:58:43] *** Joins: vk (vk@2AAA6DD0.B568D26C.93B001FA.IP)
[00:59:40] <Luqman> acrichto: upgraded to upstream llvm (+ our patches) ?
[00:59:54] <acrichto> Luqman: upgraded to llvm 3.3
[00:59:56] <acrichto> + our patches
[01:00:23] <acrichto> it's got lots of JIT improvements
[01:00:32] <acrichto> so pretty much all the JIT issues are going to get closed after this
[01:00:41] <steven_is_false> Hoorah!
[01:01:24] *** Joins: jmgrosen (jmgrosen@moz-848F6087.sb.sd.cox.net)
[01:02:13] <acrichto> one of the best things is that assert! won't terminate rusti
[01:02:24] <acrichto> the jit now has exception handling support so it'll just work
[01:03:21] *** Joins: bytbox (s@moz-DC83764A.washdc.fios.verizon.net)
[01:04:09] *** Joins: Thad (chatzilla@moz-C35F90AE.tx.res.rr.com)
[01:05:04] <Thad> Luqman: Luck yet ?
[01:06:31] <Luqman> Thad: got a bit farther but stopped since i need to work on assignments first :P
[01:06:50] <Thad> Luqman: assignments ?
[01:07:08] <Luqman> school
[01:07:24] <eevee> amulet/ll.rs:434:53: 434:70 error: cannot pack type `@ll::TidyTermcap<>`, which does not fulfill `'static`, as a trait bounded by 'static
[01:07:27] <eevee> amulet/ll.rs:434         canv.tidyables = ~[@tidy_termstate as @Drop, @tidy_kx as @Drop, @tidy_cup as @Drop];
[01:07:35] *** Joins: snadon (chatzilla@moz-3BC727E8.mc.videotron.ca)
[01:07:38] <Thad> Luqman: ah, haha
[01:07:42] <eevee> (squiggly red arrows on the second and third elements, not the first)
[01:08:26] <eevee> i have no idea where 'static is coming from
[01:09:07] <aatch> eevee, does TidyTermcap have any borrowed pointers in it?
[01:10:19] *** Quits: Sorella (queen@78575561.924F2739.95C8B7C6.IP) (Ping timeout)
[01:10:26] <eevee> yyyes
[01:10:46] <aatch> eevee, well before the code accepted it, but was wrong.
[01:11:30] <aatch> since it had no way to enforce that the trait object didn't outlast the object it came from
[01:11:53] <aatch> or more accurately, that object it came from didn't outlast it's contents
[01:11:54] <eevee> you guys gotta stop fixing things
[01:12:06] <aatch> so it was possible to get segfaults and stuff
[01:12:13] <eevee> ah.  well.
[01:12:50] <paupau> does rust have weak managed pointers?
[01:12:58] <aatch> paupau, nope
[01:13:14] <paupau> okay
[01:13:15] <aatch> they are hilariously unsafe.
[01:13:35] <paupau> I want to do something a little different than that anyway
[01:13:44] <paupau> I heard something about library pointer types
[01:13:56] <Jeaye> How can I allow default methods? They error out right now.
[01:13:58] *** Joins: ghrust (ghrust@CFE85B59.6A2AE50.F3114085.IP)
[01:13:58] <ghrust> 01[13rust01] 15bors 04force-pushed 06auto from 14cc00003 to 14b055a10: 02http://git.io/N3iJvQ
[01:13:58] *** Parts: ghrust (ghrust@CFE85B59.6A2AE50.F3114085.IP) ()
[01:13:59] *** Joins: ghrust (ghrust@614D05BD.6A2AE50.F3114085.IP)
[01:13:59] <ghrust> 01[13rust01] 15bors pushed 1 new commit to 06auto: 02http://git.io/mc5Btw
[01:13:59] <ghrust> 13rust/06auto 14cf64c32 15bors: auto merge of #7115 : alexcrichton/rust/llvm-upgrades, r=Aatch...
[01:13:59] *** Parts: ghrust (ghrust@614D05BD.6A2AE50.F3114085.IP) ()
[01:14:07] <paupau> maybe rather @ becoming a library feature?
[01:14:12] <aatch> Jeaye, #[allow(default_methods)]
[01:14:14] <aatch> paupau, kinda
[01:14:19] <paupau> are there docs on writing your own pointer types?
[01:14:27] <Jeaye> aatch: So it's per-module?
[01:14:30] <aatch> it's more about possibly moving them into the library
[01:14:31] <steven_is_false> I don't see why one couldn't make a safe interface to weak managed pointers.
[01:14:45] <aatch> Jeaye, you can do it at a crate level
[01:14:50] <strcat> acrichto: wait, why are we turning off #[fast_ffi]?
[01:14:50] <aatch> it's just a lint
[01:14:58] <strcat> acrichto: it's supposed to be becoming the default
[01:15:12] <acrichto> strcat: doesn't fast_ffi do something like not always allocate enough stack?
[01:15:13] <steven_is_false> Something like, fn get(&self) -> Option<T> for Weak<T>?
[01:15:19] <paupau> steven_is_false: yeah
[01:15:20] <strcat> acrichto: that's rust_stack
[01:15:27] <acrichto> strcat: so what is fast_ffi?
[01:15:31] <strcat> acrichto: the new ffi
[01:15:33] <aatch> strcat, there are still bugs around it though
[01:15:35] <strcat> it's just not the default yet
[01:15:37] <paupau> steven_is_false: I would hope that would be possible, although I guess it needs GC support
[01:15:40] <acrichto> well, but how is it different?
[01:15:46] <acrichto> on it segfaults, off it doesn't
[01:15:58] <acrichto> so there's some difference between the two
[01:16:08] <strcat> acrichto: the old ffi keeps a C stack segment around
[01:16:21] <strcat> and stack switches
[01:16:29] <strcat> fast_ffi is in theory supposed to reuse a large stack
[01:16:34] <strcat> but anyway they both suck
[01:16:36] <steven_is_false> As I understand it the GC is still being worked on. So adding something extra like weak pointers would be too soon.
[01:16:49] *** Joins: Sorella (queen@78575561.924F2739.95C8B7C6.IP)
[01:16:53] <strcat> we won't have weak pointers
[01:16:56] <acrichto> strcat: well it looked like the stack was being clobbered during LLVM functions which executed for awhile
[01:16:57] <strcat> gc doesn't need them
[01:17:00] <acrichto> like running passes
[01:17:11] <acrichto> I was just guessing to the cause...
[01:17:21] <paupau> steven_is_false: right, I want a weak pointer where the strong object holds a list of its referrers
[01:17:30] <aatch> strcat, from what I can he didn't actually turn off fast_ffi
[01:17:31] <paupau> steven_is_false: so it would be just a library
[01:17:48] <aatch> can tell*
[01:18:01] <aatch> he just removed the marker from some of the LLVM functions
[01:18:05] <steven_is_false> okay
[01:18:09] <paupau> steven_is_false: I guess what I want is probably implementable today with drop() and some unsafe magic
[01:18:23] <steven_is_false> I wouldn't know.
[01:18:33] <aatch> paupau, there is Rc in libextra
[01:19:12] <paupau> aatch: neat thanks
[01:19:19] <aatch> which is pretty much a perfect implementation of a reference-counting pointer. There's just no pointer-sugar for it
[01:19:24] *** Quits: dwrensha (chatzilla@moz-DE44EA45.hsd1.pa.comcast.net) (Ping timeout)
[01:19:42] <strcat> without weak pointers though because you can just use @ and not get weak pointer failures
[01:20:13] <strcat> and then you have to keep a list or counter object for weak pointers
[01:20:43] <aatch> I'm not sure what Rust's use case for weak-pointers is. You either want it shared, or you can borrow and get the compiler to ensure the lifetime.
[01:21:17] <paupau> aatch: I want an object graph with things pointing to each other all over the place
[01:21:21] <steven_is_false> I don't know what paupau wanted weak-pointers for but I was thinking they could be used for a cache.
[01:21:43] <paupau> aatch: where components can get loaded in and out at any time, so the pointers could get invalidated
[01:21:55] <paupau> aatch: if it's possible to do with borrows that would be great
[01:21:56] <aatch> paupau, then that's inherently unsafe
[01:22:26] <strcat> not if you just use @
[01:22:28] <paupau> aatch: yeah, thus I'll likely need to write a custom pointer that invalidates everything when objects drop
[01:22:54] <paupau> the problem with @ is then I can't rip components out, they'll leak
[01:23:12] <paupau> unless I could do my own GC root traversal... hmmmmm
[01:23:46] <aatch> paupau, it seems likely that the new GC will grow a rooting api, fwiw
[01:23:53] <paupau> aatch: cool
[01:24:05] <aatch> Assuming graydon doesn't go insane before then.
[01:24:40] <paupau> the fellowship of the rust
[01:24:52] <paupau> graydon must take the rust to production
[01:25:33] *** Joins: sankha93 (Instantbir@D8F0AB2E.498FC86C.8B6C1D65.IP)
[01:25:55] *** Joins: MaikKlein (maik@moz-51F0F9C8.dip0.t-ipconnect.de)
[01:25:58] <steven_is_false> So this morning I was asking about an error in the test cases of rust: task failed at 'left: ~"0" does not equal right: ~"5.82"', src/test/run-pass/syntax-extension-fmt.rs:16 but I didn't have time to pursue it further. Can anyone help me now?
[01:26:33] <aatch> steven_is_false, some weird error in strconv.rs
[01:26:41] <aatch> No idea what the problem is.
[01:27:10] <steven_is_false> aatch: I'll just comment it out then for now.
[01:32:01] *** Quits: paupau (NEAT@moz-C616DA0A.hsd1.ca.comcast.net) (Quit: out)
[01:36:30] *** Quits: jdm (jdm@F2D29657.F60B0462.67AC9B1.IP) (Quit: Lost terminal)
[01:37:00] *** Parts: korenchkin (smuxi@moz-8DE1FF0F.pools.arcor-ip.net) ()
[01:40:27] <Jeaye> rusti: trait N { fn new() -> Self; } struct F; impl N for F { fn new() -> F { F { } } } F::new()
[01:40:28] -rusti- <anon>:7:82: 7:83 error: expected `;` or `}` after expression but found `{`
[01:40:28] -rusti- <anon>:7          trait N { fn new() -> Self; } struct F; impl N for F { fn new() -> F { F { } } } F::new()
[01:40:28] -rusti-                                                                                            ^
[01:40:28] -rusti- application terminated with error code 101
[01:41:02] <dbaupp> Jeaye: just plain `F`
[01:41:10] <Jeaye> rusti: trait N { fn new() -> Self; } struct F; impl N for F { fn new() -> F { F } } F::new()
[01:41:13] -rusti- more than 5 lines of output, pastebinned: http://sprunge.us/hBjH
[01:41:28] <Jeaye> Right, now why doesn't that work?
[01:42:23] <dbaupp> rusti: trait N { fn new() -> Self; } struct F; impl N for F { fn new() -> F { F } } N::new::<F>()
[01:42:24] -rusti- {}
[01:42:31] <Jeaye> I see.
[01:42:42] <dbaupp> the function is associated with the trait, not the type
[01:42:50] <dbaupp> (although this might change)
[01:44:02] <Jeaye> I think it should, as a very nice sugar addition.
[01:44:46] <dbaupp> http://blog.pnkfx.org/blog/2013/04/22/designing-syntax-for-associated-items-in-rust/
[01:45:26] *** Quits: vk (vk@2AAA6DD0.B568D26C.93B001FA.IP) (Connection reset by peer)
[01:45:41] <aatch> strings and vectors are represented the same way, right?
[01:46:03] <aatch> So memory layout of ~[u8] == memory layout of ~str?
[01:46:26] <dbaupp> right
[01:46:38] <aatch> cool, makes this easier
[01:46:46] <dbaupp> `str` = `[u8]`
[01:46:55] *** Quits: MaikKlein (maik@moz-51F0F9C8.dip0.t-ipconnect.de) (Ping timeout)
[01:47:29] <aatch> I'm implementing a VecRef<T> type, that contains either a `&'static [T]` or a `~[T]`
[01:47:52] <dbaupp> Ah nice
[01:48:28] <aatch> so I can just have a StringRef which is actually just a VecRef<u8> under-the-hood.
[01:48:49] <dbaupp> (be careful with null termination :/ )
[01:49:00] <dbaupp> what's this for?
[01:49:19] <aatch> dbaupp, partially looking at the float-formatting bug.
[01:49:24] <dbaupp> right
[01:49:38] <aatch> noticed that a lot of the allocation is converting static strings
[01:49:39] <strcat> the formatting stuff really shouldn't allocate
[01:50:03] <strcat> it should write out to a Writer
[01:50:12] <aatch> strcat, the int-converter one is actually pretty good
[01:50:19] <strcat> but doesn't it always allocate?
[01:50:30] *** Joins: lmandel (lmandel@moz-BBE1EA67.dsl.bell.ca)
[01:50:37] <aatch> strcat, not the low-level one in strconv
[01:50:48] <strcat> so it uses a Writer?
[01:51:03] <aatch> strcat, no, it takes a builder fn
[01:51:29] <aatch> which is called for each character
[01:51:35] <aatch> (well, byte)
[01:52:05] <aatch> There may very well be lots of allocation in the extfmt usage though
[01:52:37] <aatch> but the `int_to_str_bytes_common` does no dynamic allocation itself.
[01:52:59] <aatch> it has a 64-byte stack-allocated buffer
[01:53:38] <strcat> except the problem of stack allocation being slow in rust ;p
[01:53:52] *** Quits: maxli (maxli@B5559308.9C54E60.2FA4EA88.IP) (Quit: Leaving.)
[01:53:58] <aatch> strcat, but there's not much you can do about that.
[01:54:07] <aatch> the data needs to be _somewhere_
[01:54:15] <aatch> Write it to file!
[01:54:18] <strcat> that's too big though
[01:54:54] <strcat> you only need 64 bytes to print an unsigned 64-bit int in base2
[01:54:56] *** Joins: pnathan (Adium@moz-E3C3FAF2.hfc.comcastbusiness.net)
[01:54:59] <ChrisMorgan> Say I have a string "1.0" and I want to convert it to ~[1, 0]. How can I do that?
[01:55:11] <ChrisMorgan> rusti: let z: ~[Option<u8>] = "1.0".split_iter('.').transform(|num| std::u8::from_str_radix(num, 10)).collect(); &z
[01:55:13] -rusti- more than 5 lines of output, pastebinned: http://sprunge.us/gYII
[01:55:50] <aatch> let z: ~[Option<u8>] = "1.0".split_iter('.').transform(|num| std::u8::from_str_radix(num, 10)).collect(); z
[01:55:57] <aatch> rusti: let z: ~[Option<u8>] = "1.0".split_iter('.').transform(|num| std::u8::from_str_radix(num, 10)).collect(); z
[01:55:58] -rusti- ~[Some(1), Some(0)]
[01:56:17] <ChrisMorgan> Curious... my version works in my rusti and your version doesn't.
[01:56:18] <aatch> rusti: let z: ~[Option<u8>] = "1.0".split_iter('.').transform(|num| std::u8::from_str_radix(num, 10).get()).collect(); z
[01:56:19] -rusti- more than 5 lines of output, pastebinned: http://sprunge.us/FCgh
[01:56:46] <aatch> rusti: let z: ~[u8] = "1.0".split_iter('.').transform(|num| std::u8::from_str_radix(num, 10).get()).collect(); z
[01:56:47] -rusti- ~[1, 0]
[01:56:56] *** Quits: rfw (rfw@moz-C65A114.rfw.name) (Input/output error)
[01:57:01] <aatch> ChrisMorgan, this rusti isn't the same as the one you have
[01:57:22] <aatch> the bot just throws the string into a main, compiles and runs
[01:57:39] <aatch> but the line is in a block, so you can't return a &T
[01:57:46] <aatch> (unless it's static)
[01:58:26] <ChrisMorgan> Hang on, how come you're able to cast it from Option<u8> to u8 there?
[01:58:31] <aatch> the rusti program is still kinda borked.
[01:58:36] <aatch> ChrisMorgan, the .get() call
[01:58:50] <aatch> it'll fail if it's None though
[01:59:09] <aatch> rusti: let z: ~[u8] = "1.0.steve".split_iter('.').transform(|num| std::u8::from_str_radix(num, 10).get()).collect(); z
[01:59:10] -rusti- rust: task failed at 'option::get none', /build/rust-git/src/rust/src/libstd/option.rs:331
[01:59:10] -rusti- rust: domain main @0xeee1b0 root task failed
[01:59:10] -rusti- application terminated with error code 101
[01:59:24] <aatch> rusti: let z: ~[u8] = "1.0.steve".split_iter('.').transform(|num| std::u8::from_str_radix(num, 36).get()).collect(); z
[01:59:24] <ChrisMorgan> Yeah... and I can't have it failing.
[01:59:25] -rusti- rust: task failed at 'option::get none', /build/rust-git/src/rust/src/libstd/option.rs:331
[01:59:26] -rusti- rust: domain main @0xc691b0 root task failed
[01:59:26] -rusti- application terminated with error code 101
[01:59:47] <aatch> rusti: let z: ~[uint] = "1.0.steve".split_iter('.').transform(|num| std::uint::from_str_radix(num, 36).get()).collect(); z
[01:59:49] -rusti- ~[1, 0, 48401546]
[02:00:01] <aatch> ChrisMorgan, well you don't have to use .get()
[02:00:09] <aatch> I did out of convenience.
[02:00:13] <aatch> I wouldn't in real code
[02:00:16] <Thad> ChrisMorgan: (forget rusti... just go old school and compile and run, you will have more fun that way... rusti is very borked still)
[02:00:39] <aatch> But you need some sort of error-handling strategy
[02:00:57] *** Quits: pnathan (Adium@moz-E3C3FAF2.hfc.comcastbusiness.net) (Ping timeout)
[02:01:10] <ChrisMorgan> I figured I'd need to do something along the lines of all(|num| num != None), but can't see how that could be worked into a one-liner.
[02:01:23] <ChrisMorgan> ... not that one-liners are all there should be ever.
[02:01:56] <aatch> ChrisMorgan, do you just want to ignore the None
[02:01:57] <aatch> s?
[02:01:57] *** Joins: ghrust (ghrust@C621748.6A2AE50.F3114085.IP)
[02:01:57] <ghrust> 01[13rust01] 15bors 04force-pushed 06auto from 14cf64c32 to 14b055a10: 02http://git.io/N3iJvQ
[02:01:57] *** Parts: ghrust (ghrust@C621748.6A2AE50.F3114085.IP) ()
[02:02:13] <ChrisMorgan> Well, my method would need to return None itself in that case.
[02:02:20] <strcat> acrichto: our segmented stacks just don't work
[02:02:30] * dbaupp wants monads
[02:02:34] <strcat> 10-150% slower than C++ and all kinds of corner case bugs, for what?
[02:02:36] <strcat> :(
[02:02:42] *** Quits: km (quassel@FDBAF0A0.DBF71E41.29C67456.IP) (Ping timeout)
[02:03:00] <strcat> acrichto: anyway fast_ffi is supposed to make sure there's 2MiB on the stack for the call
[02:03:00] <dbaupp> ChrisMorgan: you're probably forced to use .advance manually
[02:03:07] <strcat> it's not different in that regard
[02:03:11] <ChrisMorgan> I can use verbose iteration, but that ends up ten lines rather than one. A pity.
[02:03:15] <strcat> #[rust_stack] makes it not allocate stack space
[02:03:27] *** Joins: rfw (rfw@moz-C65A114.rfw.name)
[02:03:58] *** Joins: dherman (dherman@moz-6CA476B1.hsd1.ca.comcast.net)
[02:03:58] *** ChanServ sets mode: +o dherman
[02:04:11] *** Joins: km (quassel@FDBAF0A0.DBF71E41.29C67456.IP)
[02:04:30] <dbaupp> rusti: fn f() -> Option<~[uint]> { let mut z = ~[]; for "1.0.steve".split_iter('.').advance { match std::uint::from_str_radix(num, 10) { None => return None, Some(a) => z.push(a) } } Some(z) } f()
[02:04:31] -rusti- line longer than 150 columns, pastebinned: http://sprunge.us/BMci
[02:04:42] <dbaupp> rusti: fn f() -> Option<~[uint]> { let mut z = ~[]; for "1.0.steve".split_iter('.').advance |num| { match std::uint::from_str_radix(num, 10) { None => return None, Some(a) => z.push(a) } } Some(z) } f()
[02:04:43] -rusti- None
[02:04:50] <dbaupp> rusti: fn f() -> Option<~[uint]> { let mut z = ~[]; for "1.0.steve".split_iter('.').advance |num| { match std::uint::from_str_radix(num, 36) { None => return None, Some(a) => z.push(a) } } Some(z) } f()
[02:04:51] -rusti- Some(~[1, 0, 48401546])
[02:05:41] <dbaupp> ChrisMorgan: it's not too much longer with a separate function :)
[02:07:20] <ChrisMorgan> Thanks.
[02:08:38] *** Quits: lmandel (lmandel@moz-BBE1EA67.dsl.bell.ca) (Ping timeout)
[02:11:30] *** Quits: join (DrunkenPan@745B767B.989A61DC.CA5B6332.IP) (Ping timeout)
[02:11:56] *** Parts: steven_is_false (user@moz-144077DE.bchsia.telus.net) (ERC Version 5.3 (IRC client for Emacs))
[02:12:18] <aatch> heh, I just wrote a match with 1 arm
[02:13:03] <strcat> dbaupp: we can't have Iterable until method resolve is fixed
[02:13:05] <strcat> because the names conflict
[02:13:46] <dbaupp> strcat: right :/
[02:13:50] *** Joins: steven_is_false (user@moz-144077DE.bchsia.telus.net)
[02:14:25] <dbaupp> rusti: struct Foo(int, int); match Foo(1, 2) { Foo(a, b) => a + b }
[02:14:26] -rusti- 3
[02:14:34] <dbaupp> aatch: ^ ?
[02:15:16] <steven_is_false> So I'm mostly done my refactoring of extra::arc but it's buggy, and doesn't work (it hangs indefinitely.) Unfortunately, I don't really know how to debug multithreaded code. What should I do?
[02:15:45] <strcat> you can write a match with 0 arms
[02:16:13] <aatch> rusti: let x : Either<~[int], &'static [int]> = Left(~[1,2,3]); match x { Left(~ref slice) | Right(slice) => fmt!("%?", slice) }
[02:16:14] -rusti- <anon>:7:101: 7:106 error: variable `slice` is bound with different mode in pattern #2 than in pattern #1
[02:16:14] -rusti- <anon>:7          let x : Either<~[int], &'static [int]> = Left(~[1,2,3]); match x { Left(~ref slice) | Right(slice) => fmt!("%?", slice) }
[02:16:14] -rusti-                                                                                                               ^~~~~
[02:16:14] -rusti- error: aborting due to previous error
[02:16:15] <steven_is_false> rusti: fn (x: std::util::Void) { match x { } }
[02:16:16] -rusti- application terminated with error code 101
[02:16:17] -rusti- more than 5 lines of output, pastebinned: http://sprunge.us/cKFK
[02:16:19] <strcat> rusti: enum Bottom {} fn foo() -> Bottom { fail!() } match foo() {}
[02:16:20] -rusti- more than 5 lines of output, pastebinned: http://sprunge.us/bEVL
[02:16:26] <aatch> rusti: let x : Either<~[int], &'static [int]> = Left(~[1,2,3]); match x { Left(~ref slice) | Right(&ref slice) => fmt!("%?", slice) }
[02:16:27] -rusti- more than 5 lines of output, pastebinned: http://sprunge.us/jCKR
[02:16:32] <strcat> rusti: enum Bottom {} fn foo() -> Bottom { fail!() } fn bar() { match foo() {} } bar()
[02:16:33] -rusti- rust: task failed at 'explicit failure', <anon>:7
[02:16:33] -rusti- rust: domain main @0x8ab1b0 root task failed
[02:16:33] -rusti- application terminated with error code 101
[02:16:40] <aatch> Aw... doesn't work
[02:16:59] <strcat> we should really get rid of !
[02:17:11] * strcat is more convinced now
[02:18:39] <ChrisMorgan> There, I made my PR for moving extra::net_* to extra::net::* properly - https://github.com/mozilla/rust/pull/7594
[02:18:52] *** Quits: dherman (dherman@moz-6CA476B1.hsd1.ca.comcast.net) (Quit: dherman)
[02:19:28] <dbaupp> ChrisMorgan: I commented already :)
[02:19:32] *** Joins: Nisstyre (wes@moz-FD86289.netflash.net)
[02:19:41] * dbaupp is fast as lightning
[02:22:22] *** Joins: sanxiyn (tinuviel@858F408C.B797260D.EF43EC08.IP)
[02:22:31] <sanxiyn> https://github.com/mozilla/rust/pull/7593 (heh, already reviewed)
[02:22:56] <sanxiyn> I fixed this while porting some sizable codebase from June rustc to 0.7
[02:23:09] <sanxiyn> That is, unknown method was "each"
[02:23:17] <sanxiyn> And for all those errors closing bracket was highlighted :(
[02:23:38] * strcat ran into that a million times :(
[02:23:51] <dbaupp> sanxiyn: nice fix :)
[02:23:55] <sanxiyn> strcat: Now it at least shows ".each" for all such cases
[02:24:19] <strcat> sanxiyn: yeah it was really annoying, showing the closing brace of the loop
[02:24:21] * strcat sighs
[02:24:27] <strcat> lucking % goes to the first brace
[02:24:30] <strcat> luckily*
[02:26:31] *** Quits: bytbox (s@moz-DC83764A.washdc.fios.verizon.net) (Ping timeout)
[02:26:32] *** Joins: arete (arete@moz-CE1DC602.xen.prgmr.com)
[02:26:32] <sanxiyn> strcat: Thank you for dealing with bots
[02:26:42] <sanxiyn> What are some causes of sporadic failures?
[02:26:47] <sanxiyn> (I think I've seen hangs)
[02:28:10] <strcat> sanxiyn: dunno
[02:28:16] <strcat> I just forced an llvm clean by doing a push to master
[02:28:23] <strcat> touching the llvm clean trigger thing
[02:28:27] <sanxiyn> Well you also did @retry's
[02:28:49] *** Quits: paulproteus (quassel@rose.makesad.us) (Ping timeout)
[02:28:52] <engla> sanxiyn: that's a very nice change
[02:28:55] *** Joins: paulproteus (quassel@moz-E86A3B42.makesad.us)
[02:29:49] <sanxiyn> engla: Thanks
[02:32:32] *** Joins: cowboyd (cowboyd@moz-DD0FF83.lightspeed.austtx.sbcglobal.net)
[02:35:14] *** Quits: jack (jack@moz-F1B36F9F.hsd1.nm.comcast.net) (Quit: Leaving.)
[02:35:16] <sanxiyn> By the way, BytePos is a newtype for uint
[02:35:23] <sanxiyn> So benefits from my recent optimization :)
[02:35:24] *** Joins: jack (jack@moz-F1B36F9F.hsd1.nm.comcast.net)
[02:35:32] <sanxiyn> A little speedup (~1 sec) must be from that
[02:36:30] <engla> what about structs with only one field, are they handled the same way?
[02:36:52] <dbaupp> engla: no
[02:37:05] <aatch> dbaupp, I thought someone changed that
[02:37:09] <ChrisMorgan> dbaupp: should I alter my PR to drop the extra::extra::?
[02:37:22] * strcat is going to turn off small stacks by default
[02:37:24] <aatch> so they are passed as immediates still.
[02:37:37] <dbaupp> aatch: yeah, for newtype structs, not `struct Foo { f : int }` (I think(
[02:37:40] <sanxiyn> aatch: You mean https://github.com/mozilla/rust/pull/7543 ? (mine)
[02:37:49] <sanxiyn> dbaupp: Yes, only for newtype structs
[02:37:57] *** Quits: reyre_ (reyre@moz-9002CDDA.cpe.net.cable.rogers.com) (Client exited)
[02:38:02] <strcat> I wonder if we can actually squeeze a nice 10-30% gain from the rustc compile out of that
[02:38:04] <aatch> sanxiyn, ah yes
[02:38:14] <dbaupp> ChrisMorgan: you mean super::super? yes
[02:38:27] <ChrisMorgan> Yes, that is what I meant.
[02:38:28] <sanxiyn> Mainly, because *newtype_struct already has separate path
[02:38:31] <strcat> aatch: did you see the mailing list thread about segmented stacks?
[02:38:36] <aatch> strcat, yep
[02:38:39] <sanxiyn> But onefield_struct.field does not
[02:38:43] <dbaupp> ChrisMorgan: (you probably only have to run make rust-stage1 to check that change, btw)
[02:38:46] <sanxiyn> In principle, it should work the same
[02:39:10] <dbaupp> sanxiyn: isn't there an explicit check that there is one field and that that field is unnamed?
[02:39:20] <engla> ok sanxiyn, but could llvm end up fixing it in optimization anyway?
[02:39:23] <dbaupp> (ie. it should be as simple as removing the unnamed check)
[02:39:39] <sanxiyn> dbaupp: No, because you need to fix ".field" codegen path too
[02:39:51] <dbaupp> sanxiyn: I see :(
[02:39:54] <strcat> aatch: anyway, I think that'll solve most of our perf issues...
[02:40:00] <ChrisMorgan> dbaupp: that'd be rustc-stage1, I presume?
[02:40:01] <sanxiyn> engla: In general, yes, but can't do that in function argument/return signature
[02:40:04] <aatch> strcat, well...
[02:40:06] <strcat> aatch: not compile-time, but runtime
[02:40:08] <dbaupp> ChrisMorgan: right
[02:40:16] <sanxiyn> engla: And BytePos is in a lot of function signatures
[02:40:17] <aatch> strcat, fair enough
[02:40:18] <ChrisMorgan> OK, I'll see what happens.
[02:40:29] <strcat> aatch: we can just abandon the fast_ffi caching
[02:40:44] <strcat> 5MiB stack by default, assume C calls need 2MiB
[02:40:54] <strcat> if you want a small stack, you pay for a 2MiB allocation on every C call
[02:41:04] <strcat> and if you don't want to pay for it, port stuff to rust
[02:41:45] *** Quits: eevee (eevee@moz-58058235.evrt.wa.frontiernet.net) (Ping timeout)
[02:41:58] <strcat> it's just ridiculous to have a 2-3x perf hit on lots of code for an edge case where you want 500k I/O handling tasks
[02:42:08] <strcat> when the I/O code could just... ask for a small stack
[02:42:19] <strcat> anyway I expect our I/O is bottlenecked by FFI too
[02:42:40] <sanxiyn> strcat: Yeah until I/O is all in Rust. :(
[02:42:50] <aatch> strcat, I'm not too enthused by the reliance on libuv for all io
[02:42:52] <strcat> sanxiyn: or just until we turn off segmented stacks
[02:43:22] <strcat> everything but tasks explicitly spawned asking for small stacks will be fast
[02:43:24] <sanxiyn> As I understand Perl does not use stdio (has its own for all platforms) because it's slow
[02:43:32] <dbaupp> strcat: won't that make each call to e.g. putc really slow?
[02:43:38] <sanxiyn> And Python used to use stdio, but abandoned it in Python 3
[02:43:56] <strcat> dbaupp: only in a task you explicitly asked to optimize for virtual memory usage over performance
[02:44:00] <aatch> sanxiyn, it's not so much that stdio is slow, its that ffi in most languages is slow
[02:44:05] <dbaupp> strcat: right
[02:44:11] <strcat> dbaupp: but yes, it will be slow
[02:44:17] <strcat> dbaupp: but those tasks should be I/O bound anyway
[02:44:33] <strcat> right now we're paying *across the board*
[02:44:39] <strcat> rust is usually slower than java when you have allocations
[02:44:44] <strcat> anything with strings, vectors, a tree
[02:44:49] <dbaupp> strcat: (so, it's only does the 2MiB allocation if there isn't enough space left on the 5 MiB stack?)
[02:44:55] <strcat> RUST_MIN_STACK=5000000, bam it's as fast as C++
[02:44:56] <strcat> that's just wrong
[02:45:00] <sanxiyn> aatch: Well, Perl often beats C in I/O benchmark (say readling lines and priting)
[02:45:07] <strcat> dbaupp: yes, it won't allocate if it has space
[02:45:22] *** Quits: zz_kimundi (kimundi@moz-7A7B928D.dip0.t-ipconnect.de) (Ping timeout)
[02:45:23] <strcat> dbaupp: and it will always have space, so tasks with large stacks won't pay for anything but checks that are needed for safety anyway
[02:45:25] <aatch> sanxiyn, I doubt it's a fair comparison tbh
[02:45:39] <dbaupp> strcat: well, C++ is cheating by starting with CXX_MIN_STACK=8000000 ;P
[02:45:39] <strcat> dbaupp: tasks using task::spawn_reserve(0) will pay for allocations on FFI calls
[02:45:41] <sanxiyn> aatch: Fair in comparable programming effort, IMO
[02:45:48] <strcat> dbaupp: that's not "cheating", that's the correct thing to do
[02:45:51] <aatch> since the perl runtime can do stuff behind-the-scenes to speed things up.
[02:45:56] <dbaupp> strcat: right, makes sense. sounds like a decent plan.
[02:46:07] *** Joins: eevee (eevee@moz-58058235.evrt.wa.frontiernet.net)
[02:46:31] <strcat> dbaupp: mmap 100MiB, it consumes 4k when you touch the first page (it will usually assume you will touch more, and allocate a few pages - but you can stop that)
[02:47:03] <strcat> stack allocation is supposed to be the fastest thing in a language, and we've made it slow as hell
[02:47:11] <sanxiyn> Yeah :(
[02:47:23] <sanxiyn> Worse than nursery in GC languages :(
[02:47:28] <aatch> strcat, we could probably have our own stack allocator, right?
[02:47:36] <strcat> rust != systems language until headers on ~ are gone and segmented stacks are opt-in
[02:47:38] <strcat> imo
[02:47:57] <strcat> aatch: no, because realloc invalidates all pointers
[02:48:03] <strcat> you have to ask for the whole stack up front in rust
[02:48:15] <strcat> it can grow by segments
[02:48:18] <strcat> but you can't reallocate it
[02:48:27] <strcat> aatch: or do you mean we can call mmap ourselves?
[02:48:32] <aatch> strcat, yeah
[02:48:34] <aatch> that
[02:48:35] <strcat> oh
[02:48:40] <strcat> yeah we can do that, but jemalloc will already do that
[02:48:43] <strcat> if we were using it again
[02:48:50] <dbaupp> strcat: just thought of another work around for the 5898. Have `IteratorUtil: Iterator` as default methods, and just write `impl IteratorUtil<T> for FooIterator<T> {}`. It's annoying, yes, but it gets around the ugliness of _ and transform etc. (assuming default methods work...)
[02:49:01] *** Joins: zz_kimundi (kimundi@moz-2AE0A3D9.dip0.t-ipconnect.de)
[02:49:01] <aatch> strcat, doesn't it need to run in the tiny 128 byte red-zone though?
[02:49:08] <dbaupp> (or just have all of IteratorUtil as default methods in Iterator.)
[02:49:12] <aatch> Or do we have a bigger red zone?
[02:49:27] *** zz_kimundi is now known as kimundi
[02:49:28] <sanxiyn> Was jemalloc disabled because it didn't run in red zone?
[02:49:32] <strcat> sanxiyn: yep
[02:49:59] <strcat> possibly because we're already going deep into the red zone
[02:51:42] <dbaupp> strcat: (this could be aided by a #[no_override] attribute, so that all the *Util traits are unnecessary.)
[02:51:45] <aatch> ok, so we actually use a 2KB redzone on linux and 20KB everywhere else!
[02:51:50] *** Joins: mark_edward_mobile (AndChat437@moz-6EC51FA8.dynamic.utc.edu)
[02:51:57] <strcat> aatch: yep but we wander deep into it
[02:52:04] <strcat> we often clobber the canary *without* jemalloc
[02:52:08] <aatch> strcat, ugh
[02:52:10] <strcat> just randomly in lots of our tests and rustc
[02:52:20] <aatch> strcat, what runs in the red-zone?
[02:52:24] <mark_edward_mobile> Hey guys. Does rust depend in the C standard library?
[02:52:32] <strcat> aatch: everything? I don't think segmented stacks really work
[02:52:35] <aatch> mark_edward_mobile, unfortunately, yes?
[02:52:39] <strcat> we run off the end all the time
[02:52:40] <aatch> ignore the '?'
[02:52:42] <sanxiyn> strcat: Is "rollup" worth doing? (re pull request queue)
[02:52:47] <strcat> sanxiyn: yes but I'm lazy
[02:53:01] <aatch> strcat, ok, what is _supposed_ to run in the red zone?
[02:53:02] <strcat> sanxiyn: say a PR takes 3 hours to land, if you combine 5 into one, you've turned 15 hours into 3
[02:53:13] <dbaupp> (it's a time machine!)
[02:53:22] <mark_edward_mobile> What about stuff like zero.rs
[02:53:28] <strcat> sanxiyn: takes ~15 mins for me to build all stages locally + whatever the tests are, so rolling up platform independent PRs is pretty fail-proof
[02:53:35] <strcat> just have to test them
[02:53:38] <aatch> mark_edward_mobile, well that's for the lang items
[02:53:47] <sanxiyn> strcat: ok then I will try that myself this time...
[02:53:48] <aatch> and you still need a few symbols from libc
[02:53:58] <aatch> malloc, free, abort
[02:54:01] <aatch> a few others.
[02:54:04] <sanxiyn> I have 4 PRs in the queue and they can land at the same time...
[02:54:04] *** Quits: Earnestly (earnest@2A2BF8F5.321FA5E6.BFD1ABFD.IP) (Ping timeout)
[02:54:07] <dbaupp> realloc too, I guess
[02:54:08] <sanxiyn> (all reviewed now)
[02:54:50] <mark_edward_mobile> I see. Would that stop you from writing an OS in rust?
[02:55:09] <strcat> sanxiyn: just put the r=name in the PR message and bors includes it in the merge commit, that's what graydon suggested
[02:55:17] <strcat> commitid r=foo
[02:55:27] <strcat> doesn't really matter.
[02:55:35] <dbaupp> sanxiyn: if you're doing that, then https://github.com/mozilla/rust/pull/7582, https://github.com/mozilla/rust/pull/7586 and https://github.com/mozilla/rust/pull/7591 could probably be included. :)
[02:55:39] <sanxiyn> strcat: Hm not sure I understand... is there an example I can look at?
[02:55:50] <dbaupp> mark_edward_mobile: I think it just means you have to provide them yourself
[02:55:59] <strcat> sanxiyn: https://github.com/mozilla/rust/pull/7479
[02:56:09] <dbaupp> mark_edward_mobile: https://github.com/charliesome/rustboot/blob/master/runtime.asm
[02:56:26] <strcat> sanxiyn: https://github.com/mozilla/rust/commit/4e78c1e2a89f65a1827e1f65afc741cee05cee0a and then you know who reviewed each from the merge commit bors makes
[02:57:02] <strcat> I don't think it really matters anyway
[02:57:05] <sanxiyn> strcat: Ah thanks
[02:59:56] <sanxiyn> Lunchtime
[03:00:08] <sanxiyn> (perfect time to leave the build running! :)
[03:01:56] *** Quits: sanxiyn (tinuviel@858F408C.B797260D.EF43EC08.IP) (Quit: Leaving)
[03:03:22] <aatch> Oh wow... the way it allocates new stacks...
[03:04:06] *** Joins: reyre_ (reyre@moz-9002CDDA.cpe.net.cable.rogers.com)
[03:04:09] *** Joins: alisdair (textual@moz-EBE9F394.bchsia.telus.net)
[03:06:17] *** Quits: reyre_ (reyre@moz-9002CDDA.cpe.net.cable.rogers.com) (Client exited)
[03:07:03] *** Quits: mark_edward_mobile (AndChat437@moz-6EC51FA8.dynamic.utc.edu) (Quit: Bye)
[03:08:06] <ChrisMorgan> There, dbaupp, I removed the super::super::
[03:08:42] <dbaupp> ChrisMorgan: r+ (much cleaner :) )
[03:12:20] *** Quits: alisdair (textual@moz-EBE9F394.bchsia.telus.net) (Quit: My MacBook Pro has gone to sleep. ZZZzzz‚Ä¶)
[03:13:06] *** Quits: cowboyd (cowboyd@moz-DD0FF83.lightspeed.austtx.sbcglobal.net) (Client exited)
[03:13:21] *** Joins: alisdair (textual@moz-EBE9F394.bchsia.telus.net)
[03:13:23] *** Quits: jack (jack@moz-F1B36F9F.hsd1.nm.comcast.net) (Quit: Leaving.)
[03:13:23] <strcat> rusti: 2
[03:13:24] -rusti- 2
[03:14:47] *** Quits: SiegeLord (sl@moz-CAF07B4C.hsd1.ma.comcast.net) (Quit: It's a joke, it's all a joke.)
[03:14:52] *** Joins: SiegeLord (sl@moz-CAF07B4C.hsd1.ma.comcast.net)
[03:17:56] *** Quits: sankha93 (Instantbir@D8F0AB2E.498FC86C.8B6C1D65.IP) (Quit: Instantbird 1.4 -- http://www.instantbird.com)
[03:18:06] *** Joins: cowboyd (cowboyd@moz-DD0FF83.lightspeed.austtx.sbcglobal.net)
[03:23:15] <roo> if I match a against an enum variant of the form V(~T), what is the type of n in V(ref n) => n? 
[03:23:32] <aatch> roo, it's &~T
[03:23:39] <roo> ah, ok
[03:23:44] <roo> thanks
[03:23:50] <aatch> you can do V(~ref n) to get a &T
[03:24:01] <aatch> (doesn't work on vectors though)
[03:24:07] <aatch> (or strings)
[03:24:41] <roo> makes sense
[03:24:54] *** Quits: Thad (chatzilla@moz-C35F90AE.tx.res.rr.com) (Quit: ChatZilla 0.9.90 [Firefox 23.0/20130625125232])
[03:26:05] <steven_is_false> rusti: 1+1+3
[03:26:05] -rusti- <anon>:7:12: 7:13 error: unknown start of token: 12
[03:26:05] -rusti- <anon>:7          1+1+3
[03:26:05] -rusti-                      ^
[03:26:05] -rusti- application terminated with error code 101
[03:26:19] *** Quits: cowboyd (cowboyd@moz-DD0FF83.lightspeed.austtx.sbcglobal.net) (Client exited)
[03:28:29] <steven_is_false> rusti: 1+1+3
[03:28:29] -rusti- <anon>:7:12: 7:13 error: unknown start of token: 12
[03:28:29] -rusti- <anon>:7          1+1+3
[03:28:30] -rusti-                      ^
[03:28:30] -rusti- application terminated with error code 101
[03:28:34] <steven_is_false> rusti: 1+1+3
[03:28:34] -rusti- <anon>:7:12: 7:13 error: unknown start of token: 8
[03:28:35] -rusti- <anon>:7          1+1+3
[03:28:35] -rusti-                      ^
[03:28:35] -rusti- application terminated with error code 101
[03:28:46] <roo> lol '--pretty typed' on match expressions is... not pretty
[03:29:02] <steven_is_false> Nope.
[03:29:18] <steven_is_false> I don't remember if there's a bug filed on it yet.
[03:29:46] *** Joins: mnemotic (niko@8FFD1BD2.9D81E74C.53DF0002.IP)
[03:29:57] <dbaupp> rusti: 1+1+3
[03:29:58] -rusti- 5
[03:30:07] *** Quits: Sorella (queen@78575561.924F2739.95C8B7C6.IP) (Quit: (quit))
[03:30:10] *** Joins: jack (jack@moz-F1B36F9F.hsd1.nm.comcast.net)
[03:31:12] <steven_is_false> rusti: 1+1+3
[03:31:12] -rusti- <anon>:7:12: 7:13 error: unknown start of token: 20
[03:31:12] -rusti- <anon>:7          1+1+3
[03:31:12] -rusti-                      ^
[03:31:12] -rusti- application terminated with error code 101
[03:31:20] <steven_is_false> rusti: 1+1+3
[03:31:21] <roo> nvm, I was looking at a derived impl for Eq, it was right above my match. The match is not too bad
[03:31:21] -rusti- <anon>:7:12: 7:13 error: unknown start of token: 7
[03:31:21] -rusti- <anon>:7          1+1+3
[03:31:21] -rusti-                      ^
[03:31:21] -rusti- application terminated with error code 101
[03:31:21] *** concrete.mozilla.org sets mode: +M 
[03:32:23] <aatch> steven_is_false, you can message rusti
[03:32:32] <aatch> so you don't trigger the flood
[03:32:47] <aatch> and spam the channel
[03:36:19] *** concrete.mozilla.org sets mode: -M 
[03:36:24] *** Joins: reyre_ (reyre@moz-9002CDDA.cpe.net.cable.rogers.com)
[03:36:33] *** Joins: int3_ (int3_@moz-C0E38A24.dsl.static.sonic.net)
[03:37:30] *** Parts: steven_is_false (user@moz-144077DE.bchsia.telus.net) (ERC Version 5.3 (IRC client for Emacs))
[03:37:51] *** Quits: int3_ (int3_@moz-C0E38A24.dsl.static.sonic.net) (Client exited)
[03:41:53] *** Quits: heftig (heftig@moz-229FDAED.dip0.t-ipconnect.de) (Ping timeout)
[03:42:08] *** Quits: reyre_ (reyre@moz-9002CDDA.cpe.net.cable.rogers.com) (Client exited)
[03:42:59] *** Quits: taylanub (taylanub@moz-5D69E26C.dip0.t-ipconnect.de) (Ping timeout)
[03:43:30] *** Joins: pnathan (Adium@moz-E3C3FAF2.hfc.comcastbusiness.net)
[03:43:38] *** Joins: vk (vk@moz-389FEE13.hsd1.ca.comcast.net)
[03:45:26] *** Joins: Jesin (Jessin_@moz-3AD6F09F.res.lehigh.edu)
[03:47:55] *** Quits: bct (bct@moz-D3BEA05.ed.shawcable.net) (Ping timeout)
[03:50:06] *** Joins: ghrust (ghrust@C8693FCB.6A2AE50.F3114085.IP)
[03:50:06] <ghrust> 01[13rust01] 15bors merged 06auto into 06master: 02http://git.io/EAii_g
[03:50:06] *** Parts: ghrust (ghrust@C8693FCB.6A2AE50.F3114085.IP) ()
[03:50:41] *** Joins: heftig (heftig@moz-FA34310B.dip0.t-ipconnect.de)
[03:53:03] *** Joins: ghrust (ghrust@614D05BD.6A2AE50.F3114085.IP)
[03:53:03] <ghrust> 01[13rust01] 15bors pushed 0 new commits to 06auto: 02http://git.io/w0fxJQ
[03:53:03] *** Parts: ghrust (ghrust@614D05BD.6A2AE50.F3114085.IP) ()
[03:53:05] *** Joins: ghrust (ghrust@DE823A67.6A2AE50.F3114085.IP)
[03:53:05] <ghrust> 01[13rust01] 15bors pushed 2 new commits to 06auto: 02http://git.io/KorMtw
[03:53:05] <ghrust> 13rust/06auto 1487b6129 15Alex Crichton: Compare values in TreeMap's 'lt' function...
[03:53:05] <ghrust> 13rust/06auto 148c50ee3 15bors: auto merge of #7530 : alexcrichton/rust/issue-5194, r=thestinger...
[03:53:05] *** Parts: ghrust (ghrust@DE823A67.6A2AE50.F3114085.IP) ()
[03:54:28] *** Joins: bytbox (s@moz-DC83764A.washdc.fios.verizon.net)
[03:54:40] <Jeaye> rusti: trait N { fn bar(); } struct F; impl N for F { fn bar(){ println("bar"); } } let f = F; f.bar();
[03:54:41] -rusti- <anon>:7:97: 7:105 error: type `main::F` does not implement any method in scope named `bar`
[03:54:41] -rusti- <anon>:7          trait N { fn bar(); } struct F; impl N for F { fn bar(){ println("bar"); } } let f = F; f.bar();
[03:54:41] -rusti-                                                                                                           ^~~~~~~~
[03:54:41] -rusti- error: aborting due to previous error
[03:54:42] -rusti- application terminated with error code 101
[03:55:04] <Jeaye> rusti: trait N { fn bar(&self); } struct F; impl N for F { fn bar(&self){ println("bar"); } } let f = F; f.bar();
[03:55:05] -rusti- bar
[03:55:05] -rusti- ()
[03:57:29] <Jeaye> rusti: trait N { fn bar(&self); } struct F; impl N for F { fn bar(&self){ println("bar"); } } let f = @mut F; f.bar();
[03:57:30] -rusti- bar
[03:57:31] -rusti- ()
[03:58:24] *** Quits: mnemotic (niko@8FFD1BD2.9D81E74C.53DF0002.IP) (Ping timeout)
[04:00:22] *** Quits: pnathan (Adium@moz-E3C3FAF2.hfc.comcastbusiness.net) (Ping timeout)
[04:01:22] *** Quits: engla (engla@moz-DBD1D96E.cust.bredbandsbolaget.se) (Ping timeout)
[04:09:28] *** Quits: Kruppe (user@moz-E150F49F.cpe.net.cable.rogers.com) (Client exited)
[04:09:47] *** Quits: alisdair (textual@moz-EBE9F394.bchsia.telus.net) (Quit: My MacBook Pro has gone to sleep. ZZZzzz‚Ä¶)
[04:10:05] *** Parts: judder (maradukewa@5B9E91E7.2C8A8E2E.78E362FE.IP) ()
[04:17:46] *** Quits: jmgrosen (jmgrosen@moz-848F6087.sb.sd.cox.net) (Quit: jmgrosen)
[04:18:23] <ChrisMorgan> I want a pub struct X(str) of some form, with both some static variables and some runtime instances of it, but I can't figure out if this is possible.
[04:18:38] <ChrisMorgan> Static only: pub struct Foo(&'static str); pub static BAR: &'static Foo = &'static Foo("BAR");
[04:18:47] *** Joins: alisdair (textual@moz-EBE9F394.bchsia.telus.net)
[04:19:01] *** Joins: jmgrosen (jmgrosen@moz-848F6087.sb.sd.cox.net)
[04:19:36] *** Quits: SiegeLord (sl@moz-CAF07B4C.hsd1.ma.comcast.net) (Client exited)
[04:20:24] <aatch> ChrisMorgan, good timing. I'm actually implementing a StringRef type right now
[04:20:40] <aatch> that holds either a &'static str, or a ~str
[04:20:50] <ChrisMorgan> Oh, good.
[04:21:26] <ChrisMorgan> I was trying to work out whether there was some other way that it could be made to support both &'static str or ~str... would an enum cut it?
[04:21:35] <aatch> ChrisMorgan, that's what I'm doing
[04:21:46] <aatch> it makes it slightly harder to use
[04:21:51] <aatch> but not too bad
[04:21:57] <ChrisMorgan> Good, I'm glad my train of thought was correct.
[04:23:24] <dbaupp> aatch: if you impl the `Str` trait, then you get all the string methods (almost) for free
[04:23:40] <aatch> dbaupp, what about the Vector trait in vec?
[04:23:56] <dbaupp> aatch: well, yeah, that's for vectors
[04:24:06] *** Quits: Amanieu (amanieu@moz-D5D10CA8.halls.manchester.ac.uk) (Ping timeout)
[04:24:11] <dbaupp> (and it should achieve the same thing)
[04:26:02] <aatch> dbaupp, you sure? I don't see much that impls on T:Str
[04:26:35] *** Joins: Amanieu (amanieu@moz-D5D10CA8.halls.manchester.ac.uk)
[04:27:04] <dbaupp> aatch: right, the "almost" means you have to call .as_slice() to call the StrSlice methods
[04:27:16] <aatch> dbaupp, ahhh.
[04:27:30] <aatch> Ok, that makes sense
[04:27:35] <dbaupp> (i've got a plan that uses default methods to get around this, fwiw.)
[04:27:58] <aatch> I'm glad I didn't waste time actually implementing the methods for most of them then.
[04:28:56] *** Joins: pnathan (Adium@moz-E3C3FAF2.hfc.comcastbusiness.net)
[04:29:41] <dbaupp> :)
[04:30:12] <aatch> they're all just wrappers, going self.as_slice().foo
[04:34:44] *** Joins: metajack (jack@moz-DF5A9AA3.members.linode.com)
[04:34:57] *** Quits: pnathan (Adium@moz-E3C3FAF2.hfc.comcastbusiness.net) (Ping timeout)
[04:36:35] *** Joins: sankha93 (Instantbir@9276287F.8CAC2DA9.D2D1FAF0.IP)
[04:39:10] <aatch> man I love #[deriving]
[04:39:51] *** Quits: cubic (cubic@moz-FE5AD6C7.mc.videotron.ca) (Quit: Leaving)
[04:40:56] *** Quits: jack (jack@moz-F1B36F9F.hsd1.nm.comcast.net) (Quit: Leaving.)
[04:40:56] *** metajack is now known as jack
[04:42:00] <aatch> Also, thanks to what's already there, I get stuff like .equiv() for free.
[04:43:22] <aatch> Which means I can use it in hash maps and stuff
[04:43:34] <dbaupp> that's pretty cool
[04:44:41] <mark_edward> hey guys, what are some good tests for iterators?
[04:44:54] <aatch> mark_edward, what do you mean?
[04:45:02] <aatch> As in, you've written some?
[04:45:16] <mark_edward> xwell im tryinh to write the smallintmap iterators. it compiles, but i dont have any tests
[04:45:31] <mark_edward> shouldn't need to much testing, as it's just using already written ones
[04:45:56] <mark_edward> there doesn't seem to be any special iterator testing in hashmap, for example, as it uses the VecIterator underneath
[04:45:58] *** Joins: Giphat (Mibbit@37A46BCE.E818C2BF.2051BA92.IP)
[04:46:00] <dbaupp> you can look at the vec iterator tests
[04:46:02] <Giphat> Hi?
[04:46:12] <Giphat> anyone there? im new here
[04:46:22] <mark_edward> hello!
[04:46:27] <aatch> Giphat, heyo
[04:46:37] <Giphat> Hello
[04:46:51] <Giphat> Nice to see u all
[04:47:01] <Giphat> aatch Heyo lolz
[04:48:08] <Giphat> maybe bot alot then people ;/
[04:48:35] <aatch> Giphat, especially not at this time of the day
[04:49:02] <Giphat> aacth oohhh
[04:49:29] <Giphat> aatch where your from sir?
[04:49:39] <aatch> I'm in New Zealand
[04:49:56] <Giphat> ohhh
[04:49:58] <arete> hello, rust newbie here and unable to figure out the cause of this "borrowed value does not live long enough" error with https://gist.github.com/anonymous/5931741
[04:49:58] <Giphat> Well
[04:50:18] <arete> what am I failing to understand?
[04:50:56] <aatch> arete, right now, &Trait objects need a static lifetime.
[04:51:11] <aatch> it's a temporary limitation until trait bounds are finished
[04:51:45] <aatch> basically, without it we have no way of proving that the &Trait object is alive at any given time.
[04:52:07] <arete> oh, what does it meant o have a static lifetime?
[04:52:25] <aatch> arete, it lasts for the entire lifetime of the program
[04:52:35] <strcat> arete: use generic functions, it's unlikely you want trait objects
[04:52:46] <arete> ahh I see, thank you!
[04:52:55] <strcat> fn echo<T: Echo>(f: &T) { }
[04:53:11] <strcat> no need for a trait object there when static dispatch will work
[04:53:50] *** Quits: tedh (tedh@moz-F0B37C08.hsd1.il.comcast.net) (Client exited)
[04:54:03] <arete> strcat: thanks! this is actually extracted from some other code where I need to pass a reference in and out of unsafe calls to C
[04:54:34] <strcat> it's unlikely you want a trait object though
[04:55:53] <arete> yeah? fundamentally I want to pass in
[04:56:13] <arete> er something that implements trait T, then on a C callback invoke one of T's methods on it
[04:57:02] <aatch> arete, you only need trait objects if the true type can only be known at runtime.
[04:57:50] <strcat> fn foo<T>(v: &T, cb: extern fn(&T)) { bar(v, cb) }
[04:59:21] <arete> thanks! I'll try playing around with that
[04:59:27] <aatch> strcat, I have found an advantage of having all the string/vec methods be in traits.
[04:59:47] * strcat is going to kill off even more of them soon
[05:00:29] <aatch> strcat, will it stop me from being able to call StrSlice methods on my StringRef type?
[05:00:37] <strcat> no
[05:00:47] <strcat> aatch: the methods will just be defined on ranges, at least for vectors
[05:00:49] <aatch> strcat, then fine.
[05:02:47] *** Joins: tedh (tedh@moz-F0B37C08.hsd1.il.comcast.net)
[05:06:35] <ChrisMorgan> Is there any good reason why extra::net::url::Url is Url and not URL?
[05:06:44] <aatch> ChrisMorgan, convention
[05:07:01] <aatch> We eventually settled on Pascal case, even for acronyms
[05:07:09] *** Joins: tiffany (kawaii@moz-1E0FE6E8.dhcp.embarqhsd.net)
[05:07:17] <ChrisMorgan> So you'd have e.g. an HttpServer
[05:07:23] <aatch> especially ones like URL which are often used as their own words anyway
[05:07:31] <aatch> ChrisMorgan, yes.
[05:07:41] <aatch> Though it's not like it's a hard-and-fast rule
[05:07:46] <ChrisMorgan> (The inconsistency in Django on this point has always grated on me, where most things are HTTP but some are Http.)
[05:07:56] *** Parts: jack (jack@moz-DF5A9AA3.members.linode.com) (ERC Version 5.3 (IRC client for Emacs))
[05:08:08] <ChrisMorgan> I'd prefer it as URL &c., but if it's a consistently applied rule I don't mind so much.
[05:08:35] <aatch> ChrisMorgan, and what with it being Python, you might managed to get quite far before it complained about Http vs HTTP
[05:08:55] *** Quits: tedh (tedh@moz-F0B37C08.hsd1.il.comcast.net) (Client exited)
[05:09:22] <ChrisMorgan> I love Python and it's my preferred language at present, but that sort of thing is part of the reason why I'm investigating Rust.
[05:09:26] *** Quits: vk (vk@moz-389FEE13.hsd1.ca.comcast.net) (Quit: vk)
[05:09:52] <mark_edward> i wish iterators were more transparent about whether they gave you references or copies or not
[05:10:00] <mark_edward> they type signatures don't tell you anything
[05:10:01] <ChrisMorgan> Tried Go briefly, found it often too simplistic.
[05:10:04] <aatch> mark_edward, the iterator's themselves are
[05:10:28] <aatch> but more often than no, you get a reference. Strings give you values
[05:10:36] <aatch> but that's because it's always u8
[05:10:46] <mark_edward> say you zip two ~[u8] together into a zip iterator
[05:11:01] <strcat> ~[u8] isn't an iterator
[05:11:20] <mark_edward> ~[u8] iterators then, is wht i meant
[05:11:24] <strcat> which?
[05:11:30] <strcat> there's more than one type
[05:11:42] *** Parts: Giphat (Mibbit@37A46BCE.E818C2BF.2051BA92.IP) ()
[05:11:47] *** Joins: vk (vk@moz-389FEE13.hsd1.ca.comcast.net)
[05:11:56] <mark_edward> is the type of it.next()'s result (&Option<&u8>, &Option<&u8>) or (Option<&u8>, Option<&u8>)
[05:11:57] <strcat> there's iter() for &T, mut_iter() for &mut T, consume_iter for T
[05:12:17] <strcat> the options are never by-reference
[05:12:21] <strcat> next returns Option<A>
[05:12:42] <mark_edward> yes, but when iterators wrap things, they seem to give references. enumerate iterator seems to do that
[05:12:45] <strcat> if you use a consume_iter it's Option<u8>, if you use iter it's Option<&u8>, if you use mut_iter it's Option<&mut T>
[05:12:49] <strcat> mark_edward: it doesn't
[05:12:56] <strcat> the adaptors pass along whatever they were given
[05:12:59] <strcat> zip doesn't change types
[05:13:01] <strcat> it takes 
[05:13:04] <mark_edward> prolly something up with my type signature then
[05:13:06] <strcat> Iterator<A> and Iterator<B>
[05:13:14] <strcat> and it returns Option<(A, B)>
[05:13:17] <strcat> it adds no references
[05:13:22] <strcat> it can't
[05:13:50] <strcat> mark_edward: look at the code in the iterator.rs module
[05:13:58] <strcat> adaptors just pass along types
[05:14:31] <mark_edward> ok then
[05:14:31] <strcat>     fn zip<B, U: Iterator<B>>(self, other: U) -> ZipIterator<A, Self, B, U>;
[05:14:41] <strcat>     fn next(&mut self) -> Option<(A, B)> {
[05:15:07] <strcat> if you have Iterator<uint> and Iterator<&f64>
[05:15:09] <strcat> zipping them will give
[05:15:14] <strcat> Option<(uint, &f64)>
[05:16:14] <strcat> rusti: let xs = ~[1, 2, 3]; for xs.consume_iter() |x| { println(fmt!("%?", x)) }
[05:16:15] -rusti- more than 5 lines of output, pastebinned: http://sprunge.us/EjEP
[05:16:27] <strcat> rusti: let xs = ~[1, 2, 3]; for xs.consume_iter().advance |x| { println(fmt!("%?", x)) }
[05:16:28] -rusti- 1
[05:16:28] -rusti- 2
[05:16:28] -rusti- 3
[05:16:28] -rusti- ()
[05:16:35] <strcat> rusti: let xs = ~[1, 2, 3]; for xs.iter().advance |x| { println(fmt!("%?", x)) }
[05:16:36] -rusti- &1
[05:16:36] -rusti- &2
[05:16:36] -rusti- &3
[05:16:36] -rusti- ()
[05:18:27] <dbaupp> strcat: out of interest, what's your plan with the vec methods?
[05:19:22] <strcat> extending Iterator to a more generic range concept, making slices into the range implementation
[05:20:03] <strcat> so, no need for the random access methods on vectors either
[05:20:14] <strcat> they can be shared with types like extra::deque
[05:20:34] <strcat> strings are more complicated. but the u8 methods can go
[05:21:00] <strcat> the only things left should be stuff changing the size
[05:21:43] <dbaupp> I see
[05:22:05] <dbaupp> (by u8 methods you mean bytes_iter(), etc?)
[05:22:25] <brendanc> does this look like it would use large stacks on 64-bit? https://gist.github.com/bcully/5932059
[05:22:42] <brendanc> not sure what the canonical way to get address space size at compile time is
[05:23:21] <aatch> brendanc, the way is to use the target architecture size
[05:23:41] <strcat> brendanc: I really think it would be better to make an api for it
[05:23:47] <strcat> segmented stacks are smaller than pages
[05:23:58] <strcat> and you still need big stacks on 32-bit
[05:24:15] <mark_edward> i like how when you have macro errors the error message points to line of definition in the macro
[05:24:16] <brendanc> aatch: how do I get the target architecture size at CPP time?
[05:24:21] <mark_edward> whoever did that needs a cookie
[05:24:43] <aatch> brendanc, their will probably be a define for it somewhere.
[05:24:49] <brendanc> strcat: I was trying to leave things they way they are on 32-bit
[05:24:58] <strcat> brendanc: segmented stacks are useful on 64-bit though
[05:25:02] <strcat> brson convinced me
[05:25:06] <brendanc> he did?
[05:25:13] <strcat> brendanc: they need to be opt-in though
[05:25:19] <brendanc> what's the argument for them on 64-bit?
[05:25:30] <strcat> well the API needs to be made
[05:25:40] <strcat> brendanc: because they're smaller than 4k
[05:25:52] <strcat> and the OS doesn't actually just allocate a page with the current way we allocate stack
[05:26:08] <strcat> you can make it allocate page-by-page (on Linux at least) but it's a bit more eager than that by default
[05:26:10] <mark_edward> strcat: matching seems to freeze things.. i'm matching on Some(e) where e: &'r mut T and i need tp return Some(i: uint, e : &'r mut T) 
[05:26:28] <brendanc> I didn't think linux allocated a page until it was touched
[05:26:31] <mark_edward> which i do by returns Some(i, e), but the compilr complains that e is no longer mutable
[05:26:32] <dbaupp> mark_edward: what's the error message
[05:26:37] <dbaupp> ?
[05:26:46] <dbaupp> mark_edward: (and what's the code?)
[05:26:49] <aatch> mark_edward, Some(mut e)
[05:26:49] <strcat> brendanc: the kernel predicts your usage patterns though
[05:27:06] <mark_edward> aatch: thanks
[05:27:10] <strcat> brendanc: you need to madvise it to make it not assume you're about to initialize a sequence of 30+ pages, I experimented a bit
[05:27:59] *** Joins: dherman (dherman@moz-6CA476B1.hsd1.ca.comcast.net)
[05:27:59] *** ChanServ sets mode: +o dherman
[05:28:07] <strcat> here
[05:28:09] <strcat> sec
[05:28:33] <strcat> brendanc: and on windows I don't think the stack allocations we do are lazy at all
[05:28:34] <brendanc> is memory released to the os when the stack is unwound, or do you just put the stack on a reuse list?
[05:28:43] <brendanc> hmm, well 4MB non-lazy isn't ideal
[05:29:09] <mark_edward> dbaupp: error is ehre
[05:29:11] <mark_edward> https://github.com/MarkJr94/rust/blob/smallintmap_enum/src/libextra/smallintmap.rs#L236
[05:29:26] <brendanc> don't know anything about windows but it seems odd to allocate everything up front :)
[05:29:38] <dbaupp> mark_edward: and the exact error message?
[05:29:41] <strcat> brendanc: they don't have overcommit
[05:29:50] <mark_edward> and it says: http://pastebin.com/rJrH6Bzh
[05:29:57] <strcat> brendanc: if you have 8GiB of memory on windows and 4GiB of swap, you go OOM when VIRT reaches 12GiB
[05:30:03] <strcat> even if you're using 2GiB of it
[05:30:20] <brendanc> well that changes things
[05:31:26] <brendanc> but maybe it just means if sizeof(size_t) < 8 || windows: use small min stack
[05:31:37] <strcat> brendanc: I really think the API we need is that task::spawn gives you a big stack (2MiB is what pthreads get by default on linux), and you can do task::spawn_reserve(n) to change 2MiB to a smaller number
[05:31:53] <strcat> so on both x86 and x86_64, you get good general perf by default
[05:31:59] <dbaupp> mark_edward: what happens if you comment out the Mut iterators
[05:32:06] <strcat> and if you use task::spawn_reserve(0) you get minimum mem usage at the expense of performance
[05:32:12] <strcat> or... you can reserve exactly what you need and get both
[05:32:37] <brendanc> that seems fine. increasing the default size seems like a good first step though :)
[05:32:45] <strcat> except it has to be more than 2MiB
[05:32:48] <strcat> since we pretend C calls need that
[05:33:15] * strcat has no idea what happens when C calls back to rust
[05:33:37] <brendanc> not sure how many tasks rust expects to support on 32-bit
[05:34:01] <strcat> brendanc: well for I/O stuff you want to be able to make 1 per client on a server, that's the use case of segmented stacks
[05:34:17] <strcat> so 200k wouldn't be an unrealistic number
[05:34:26] <strcat> but those ones don't need to be fast
[05:34:37] <brendanc> at 4MB per task you'd be in trouble
[05:34:42] <aatch> but often you don't need much stack space for that kind of operation.
[05:34:48] *** Quits: sankha93 (Instantbir@9276287F.8CAC2DA9.D2D1FAF0.IP) (Quit: Instantbird 1.4 -- http://www.instantbird.com)
[05:34:56] <aatch> brendanc, but you'd use spawn_reserve(0)
[05:35:07] <aatch> which is the minimum amount
[05:35:23] <strcat> or spawn_reserve(12 * 1024) if you knew they needed 12KiB at most
[05:35:27] <brendanc> I like the idea of dynamically adjusting the initial stack size based on available address space / number of current tasks 
[05:35:41] <brendanc> it could be complementary to explicitly setting a size
[05:35:45] <aatch> brendanc, that seems like trouble.
[05:35:55] <strcat> brendanc: the problem is that different tasks have different needs
[05:36:07] <brendanc> right now everything starts small, which is trouble
[05:36:08] <strcat> some are going to be waiting on I/O, others are going to be CPU-bound and making FFI calls
[05:36:20] <strcat> so I think it should just be pushed up to the caller
[05:36:22] <aatch> brendanc, but at least it starts at the same size
[05:36:46] <brendanc> well you could always request a size
[05:36:58] <brendanc> if you said 0, you'd get a small initial stack
[05:37:08] <strcat> brendanc: pcwalton originally suggested something like halving stack size each time, but it's just too coarse
[05:37:30] <strcat> think about a program like servo - it's going to have heavyweight threads responsible for stuff like rendering and event handling
[05:37:38] <strcat> but it's also going to spawning hundreds of lightweight I/O tasks
[05:37:51] <aatch> I prefer the simple default vs explicit.
[05:38:00] <brendanc> I'm proposing you don't start shrinking the stack until you have many threads. I'd expect that when you're out spawning task 500, it's probably an IO thread that's ok with having a small stack
[05:38:22] <strcat> brendanc: but you might spawn 400 I/O tasks and then some CPU bound ones
[05:38:30] <strcat> the performance has to be predictable
[05:38:34] <strcat> it's not a best-effort thing
[05:38:41] <brendanc> predictable is good, but you can always be explicit
[05:38:47] *** Joins: jack (jack@moz-DF5A9AA3.members.linode.com)
[05:39:00] <strcat> brendanc: big stacks are predictable ;p
[05:39:03] <strcat> they're what 99% of languages use
[05:39:06] <brendanc> it just would be nice if you could get good perf and lots of tasks without having to guess at stack size
[05:39:17] <mark_edward> dbaupp: i dunno, getting a weird error on extra braces, but i'm counting them and they seem right...
[05:39:18] <aatch> I don't want to have to think about the order I'm spawning my tasks in as an optimization
[05:39:31] <strcat> brendanc: well you'll get good performance, you'll just hit the VM limit on x86 and then fix your I/O ones to not reserve big stacks
[05:39:45] <strcat> or do it in advance
[05:40:01] <strcat> I/O is still going to be faster on a big stack, especially if you're hitting FFI
[05:40:31] <brendanc> yeah. I just think it's sometimes hard for the programmer to know how much stack a task is going to need up front
[05:40:55] <aatch> brendanc, that's why it's a hint, not an absolute
[05:40:59] <strcat> brendanc: well that's why they should just default to a big stack
[05:41:17] <strcat> brendanc: you don't have to get the reserve hint right, it'll just do what it does now and make segments if you don't
[05:41:31] <aatch> if I say "1kb" and it actually needs 10kb, it'll just start allocating
[05:41:40] <brendanc> if you guess too large you limit the number of tasks you can have though
[05:41:42] *** Quits: Jesin (Jessin_@moz-3AD6F09F.res.lehigh.edu) (Connection reset by peer)
[05:41:59] <aatch> brendanc, only on 32-bit, realistically
[05:42:06] <brendanc> yes
[05:42:13] *** Joins: seth (seth@moz-D840E602.dsl.static.sonic.net)
[05:42:17] <brendanc> on 64-bit, large stacks all the way
[05:42:20] <aatch> and even then, you're guessing pretty high
[05:42:26] <brendanc> (except for the windows craziness)
[05:42:32] <strcat> brendanc: Go stacks start at something like 1KiB
[05:42:37] <strcat> so it's less than a page
[05:42:47] <brendanc> go doesn't seem super fast
[05:43:18] *** Quits: jack (jack@moz-DF5A9AA3.members.linode.com) (Quit: ZNC - http://znc.in)
[05:43:21] <strcat> because they care about I/O more than CPU-bound stuff
[05:43:25] <brendanc> yeah
[05:43:40] <strcat> we can easily do both
[05:43:43] <brendanc> I am just not sure their stack algorithm is a model for speed
[05:43:55] <strcat> brendanc: it's a model for scalable I/O though, on 64-bit too
[05:43:59] *** Quits: seth (seth@moz-D840E602.dsl.static.sonic.net) (Ping timeout)
[05:44:31] <strcat> they're competitive with entirely async event-loop code
[05:44:51] *** Joins: jack (jack@moz-DF5A9AA3.members.linode.com)
[05:44:53] *** Quits: Axord (xord@moz-C3CCF156.lsanca.dsl-w.verizon.net) (Quit: I'm sure it's perfectly safe)
[05:44:57] <brendanc> yeah, I like the goroutines
[05:45:11] *** Joins: gour (gour@moz-F4263343.adsl.net.t-com.hr)
[05:46:22] <brendanc> I don't think I'm disagreeing with anything. large stacks good, api to request small stacks good
[05:46:39] *** Joins: bct (bct@moz-D3BEA05.ed.shawcable.net)
[05:46:55] <brendanc> some heuristic to balance stack size versus total number of possible tasks: controversial
[05:47:24] <brendanc> thought we could start by just turning on large stacks on 64-bit :)
[05:47:33] <brendanc> except apparently it's dangerous on windows
[05:47:39] *** Quits: gour (gour@moz-F4263343.adsl.net.t-com.hr) (Quit: WeeChat 0.4.0)
[05:48:44] *** Joins: gour (gour@moz-F4263343.adsl.net.t-com.hr)
[05:49:03] *** Quits: alisdair (textual@moz-EBE9F394.bchsia.telus.net) (Quit: My MacBook Pro has gone to sleep. ZZZzzz‚Ä¶)
[05:50:26] *** Quits: jmgrosen (jmgrosen@moz-848F6087.sb.sd.cox.net) (Quit: jmgrosen)
[05:50:44] *** Joins: wilsonk|2 (kvirc@moz-39EFBFC2.cg.shawcable.net)
[05:51:16] *** Quits: wilsonk-laptop (kvirc@moz-39EFBFC2.cg.shawcable.net) (Ping timeout)
[05:51:27] <strcat> brendanc: graydon was really against doing anything overly clever before
[05:51:37] <strcat> when pcwalton wanted to just divide the size in 2 with each spawn
[05:52:10] <strcat> pretty much for the same reason we have ~ and @ instead of @ + ages spent on whole program escape analysis
[05:52:37] <aatch> Oh god, that would be...
[05:52:38] <aatch> ugh
[05:53:14] *** Quits: dherman (dherman@moz-6CA476B1.hsd1.ca.comcast.net) (Quit: dherman)
[05:53:24] <brendanc> I wouldn't advocate whole-program escape analysis either :)
[05:53:53] <brendanc> I can appreciate the argument against dynamically adjusting initial stack size
[05:54:50] <aatch> rusti: let a = &"123"; let b = a.clone(); (a,b)
[05:54:51] -rusti- ("123", "123")
[05:55:21] *** Joins: alisdair (textual@moz-EBE9F394.bchsia.telus.net)
[05:55:41] <roo> is there some sort of generic concat somewhere in the std lib that would work on Option?
[05:56:11] <aatch> roo, not to my knowledge.
[05:56:27] <aatch> Why, what do you want to do?
[05:56:29] <dbaupp> aatch: my string plan has crashed on the rocks of lifetimes :/
[05:56:36] <mark_edward> dbaupp: now i'm getting an ICE after making these changes: https://github.com/MarkJr94/rust/blob/smallintmap_enum/src/libextra/smallintmap.rs#L252-L284
[05:56:38] <aatch> dbaupp, aw
[05:57:00] <dbaupp> aatch: it's really quite annoying... these things clearly live long enough
[05:57:02] <aatch> I kinda-sorta hit that string to implement StrSlice
[05:57:04] <roo> something like concat([Some(1),None,Some(2)] -> Some(~[1,2])
[05:57:16] <mark_edward> dbaupp: here is the  error http://pastebin.com/FgEeg2Ja
[05:57:17] <aatch> s/string/trying/
[05:57:24] * dbaupp considers applying `unsafe` generously
[05:57:37] <aatch> dbaupp, heh, better not.
[05:57:41] <dbaupp> mark_edward: hm, I thought that'd been fixed
[05:58:09] <aatch> mark_edward, is that during compile?
[05:58:10] <brendanc> btw what stack size do threads get on windows normally?
[05:58:14] <mark_edward> aatch: yes
[05:58:39] <aatch> Ah, ok, you need to stage off the size_hint to have one without the #[inline]
[05:58:41] <dbaupp> mark_edward: can you try just writing out the mut one without macros? (don't bother with MutRev for the moment)
[05:58:42] <aatch> or forgo the inline
[05:58:50] <strcat> brendanc: dunno, but it's a lot smaller than linux iirc
[05:58:52] <mark_edward> dbaupp: ok cool
[05:58:55] <dbaupp> aatch: it's privacy, isn't it?
[05:58:59] <strcat> on linux it's 2MiB (you get a bigger main thread)
[05:59:15] <aatch> dbaupp, but didn't killing the #[inline] on it work?
[05:59:42] <dbaupp> aatch: don't know/can't remember
[05:59:45] <strcat> brendanc: ok so by default it does scale precisely with the number of pages you've touched
[06:00:17] <brendanc> you mean no madvise needed?
[06:00:17] <strcat> 100k 8MiB stacks each with 1 page touched -> 781GiB VIRT, 390MiB RES
[06:00:18] <dbaupp> https://github.com/mozilla/rust/issues/7481
[06:00:23] <brendanc> ah
[06:00:57] <joelteon> 781GiB VIRT...
[06:01:20] <brendanc> 390MiB RES  -- isn't that somehow less than 1 page per thread?
[06:01:23] <dbaupp> mark_edward: you'll possibly have to use #[cfg(not(stage0))]
[06:01:28] <aatch> joelteon, yeah.
[06:01:29] <strcat> brendanc: nope, use / 1024
[06:01:31] <strcat> ;p
[06:01:39] <aatch> the wonders of overcommit
[06:01:40] <mark_edward> dbaupp: what would that do? what is the problem?
[06:01:41] <strcat> >>> 400000 / 1024
[06:01:43] <strcat> 390.625
[06:01:49] <brendanc> doh :)
[06:02:04] <strcat> brendanc: http://ix.io/6w5 little test program
[06:02:22] <dbaupp> mark_edward: it's a bug that has been fixed, but is not currently in the snapshot compiler (i.e. the one that is used in the first stage of bootstrapping)
[06:02:33] <brendanc> yep that looks good
[06:02:35] *** Quits: km (quassel@FDBAF0A0.DBF71E41.29C67456.IP) (Ping timeout)
[06:02:38] <mark_edward> Ah, i understand
[06:03:03] <aatch> I'll do a new snapshot tomorrow or at the weekend.
[06:03:08] <strcat> brendanc: glibc's malloc is just really dumb
[06:03:55] <brendanc> and the 64-bit argument  for segmented stacks is that rust's tiny stacks would have < 100MB res for 100k tasks
[06:04:12] <brendanc> 100k noop tasks
[06:04:31] <strcat> brendanc: yeah, they could be under a kilobyte each
[06:04:33] *** Joins: santiago (santiago@320E3E2A.D15AA1B4.A535BD55.IP)
[06:05:02] <strcat> if you wanted something like coroutines or passing along data from a socket to another socket
[06:05:11] <mark_edward> dbaupp: where should i add that directive?
[06:05:53] <strcat> brendanc: also the VIRT usage turns into more RES usage
[06:05:55] <strcat> as in overall
[06:06:09] <strcat> not sure how much overhead there is
[06:06:27] <brendanc> I wouldn't expect that to change much?
[06:06:31] <strcat> 200k -> 1562GiB VIRT, 781MiB RES
[06:06:44] <strcat> but it's using more system memory than that
[06:06:57] <strcat> brendanc: afaict the page table overhead is 1-2 pages
[06:07:02] <dbaupp> mark_edward: hmm, putting `#[cfg(stage0)] fn size_hint(&self) -> (Option<uint>, Option<uint>) { (None, None) }` in the impls might work
[06:07:11] <mark_edward> ok thanks
[06:07:25] <strcat> hm
[06:07:33] <strcat> if I don't touch them it doesn't change sys mem usage, weird
[06:07:37] <dbaupp> mark_edward: (it might not work.)
[06:07:47] <strcat> but it's using... maybe double what it says the RES is
[06:07:51] <mark_edward> what else could fix it? not implementing size_hint?
[06:07:53] <strcat> if I touch 1 page
[06:08:13] <dbaupp> mark_edward: wait, are you implementing size_hint already?
[06:08:33] <mark_edward> well, yes. that's where the error is.
[06:08:44] <mark_edward> don't you have to to implement the Iterator<A> trait?
[06:08:46] <dbaupp> mark_edward: hm, so you are. Maybe try removing the #[inline] as aatch suggested?
[06:08:49] * strcat wonders how high VIRT will go
[06:08:56] <brendanc> I thought pagetables were like .1% of the memory they managed
[06:09:22] <dbaupp> mark_edward: (nope, it's a default method, so there's an implementation that gets substituted if it is left unimplemented)
[06:09:23] <brendanc> 1000 ptes per page
[06:09:23] <strcat> brendanc: yeah but it might have 1 page overhead per mmap or something
[06:09:41] <strcat> brendanc: it doesn't have *any* overhead until you touch it, it's weird
[06:09:46] <strcat> any measurable overhead*
[06:09:50] <mark_edward> dbaupp: cool, i may leave it unimplemented. std::hashmap::HashMap does't implement it
[06:10:00] <aatch> mark_edward, that's fine for now.
[06:10:06] <brendanc> pagetables are lazy too
[06:10:14] <strcat> I mean it's at 7812GiB of VIRT with a million ;p
[06:10:59] <strcat> it broke htop
[06:11:00] <aatch> strcat, probably somewhere in the terabytes
[06:11:01] * strcat sighs
[06:11:48] <strcat> aatch: yeah 76TiB
[06:11:51] * strcat tries more
[06:12:00] <brendanc> wonder if you're actually only getting one vma
[06:12:12] <strcat> mmap: Cannot allocate memory
[06:12:14] <strcat> ;[
[06:12:20] <aatch> strcat, It has to cap at 256TB
[06:12:29] <aatch> you run out of addresses there.
[06:12:40] <strcat> 23813 strcat    20   0  0.112p    348    280 S   0.0  0.0   0:03.05 a.out                                                                            
[06:12:41] <strcat> :p
[06:12:51] * strcat wants that much physical memory
[06:13:05] <strcat> how much does userland actually get?
[06:13:06] <brendanc> try unmapping every other stack :)
[06:13:19] <brendanc> wonder if it's just growing a vma
[06:14:08] <strcat> brendanc: it dies
[06:14:10] <strcat> ;p
[06:14:13] <brendanc> hmm
[06:14:58] <mark_edward> dbaupp: im still having that mutability problem. and aatch: Some(mut e) is a syntax error. so confusing!!!
[06:15:15] <brendanc> how does it die? segv on unmap?
[06:15:19] <strcat> segv yeah
[06:15:20] <dbaupp> mark_edward: is that without macros?
[06:15:32] <strcat> with 1 million -> 7.6TiB
[06:15:36] <aatch> mark_edward, don't implement the Muts with the macro
[06:15:38] <strcat> munmap every odd stack -> 7.1TiB
[06:15:49] <mark_edward> dbaupp: i made a second macro just for the Muts
[06:15:53] <mark_edward> but i can unmacro them
[06:15:58] <strcat> half million from the start -> 3.8TiB
[06:15:59] * strcat shrugs
[06:16:11] <brendanc> maybe it's ooming when it actually needs to split the vmas
[06:16:24] <dbaupp> mark_edward: yeah, until we workout the bug, just having a single SIMMutIterator without a macro would be easiest
[06:16:38] <mark_edward> ok
[06:16:47] <dbaupp> (can do the Rev once it's fixed.)
[06:16:58] <brendanc> linux is impressively lazy :)
[06:17:29] *** Joins: pnathan1 (Adium@moz-E3C3FAF2.hfc.comcastbusiness.net)
[06:18:16] <brendanc> I think that's probably what's happening -- runs out of room to allocate a new vma
[06:18:48] <strcat> rusti: 2
[06:18:49] -rusti- 2
[06:19:59] *** Joins: jmgrosen (jmgrosen@moz-848F6087.sb.sd.cox.net)
[06:20:55] <strcat> brendanc: so when it says RES is 390MiB (for 100k, with 1 page touched), it really uses about double that
[06:21:14] <strcat> I could probably measure it with a cgroup and see the real usage
[06:22:12] <Eridius> hmm, `make check` ended by telling me that 1167 tests passed, but if I scroll up I had compilation errors.
[06:22:19] <brendanc> how do you tell it's doubled? free drops by 2x?
[06:22:20] <Eridius> in the vec tests
[06:22:25] *** Quits: vk (vk@moz-389FEE13.hsd1.ca.comcast.net) (Quit: vk)
[06:22:26] <strcat> brendanc: yeah
[06:22:51] <aatch> Hmm, StringRef and VecRef aren't good names
[06:22:54] <aatch> any ideas?
[06:23:13] <brendanc> not sure what that other memory is
[06:23:34] <brendanc> page per mapping would explain it, but then I"m confused about unmap
[06:23:42] *** Quits: pnathan1 (Adium@moz-E3C3FAF2.hfc.comcastbusiness.net) (Ping timeout)
[06:23:46] <strcat> well I haven't tried mmap with a relatively sane number
[06:23:53] <strcat> er
[06:23:55] <strcat> unmap
[06:23:57] *** Joins: darkf (darkf@moz-F9058B8A.net)
[06:24:17] <brendanc> also page per mapping seems high
[06:24:25] <dbaupp> aatch: this is really annoying, it seems that `&'a self` with Self = &str doesn't imply that self is `&'a str` :(
[06:24:37] <strcat> brendanc: let me set up a cgroup so I can measure properly
[06:24:40] <strcat> sec
[06:24:59] <aatch> dbaupp, nope, it's &'a &'self str
[06:25:10] <darkf> I'm trying to use read_u8() on a boxed pointer implementing reader but it won't seem to work like I want - http://paste.pm/858.txt how do I do this?
[06:25:41] <dbaupp> aatch: yeah... but, presumably 'a <= 'self
[06:25:51] <ChrisMorgan> I have implemented poor man's StringRef briefly, `enum StringRef { StaticStr(&'static str), OwnedStr(~str)}`, but then when I have a `struct X(StringRef)` and I want to check which type of StringRef it is, I can't figure out a correct match clause.
[06:26:06] <dbaupp> aatch: (i.e. I'd hope that borrowck enforced that.)
[06:26:37] <aatch> dbaupp, well, it's a borrow of a slice, but I'm not sure borrowck is smart enough to reason about it properly.
[06:26:45] <mark_edward> dbaupp: http://pastebin.com/DeNAjM2w this error is happening on this line https://github.com/MarkJr94/rust/blob/smallintmap_enum/src/libextra/smallintmap.rs#L287
[06:26:49] <dbaupp> ChrisMorgan: match x { X(StaticStr(..)) => .., X(OwnedStr(..)) => .. }
[06:26:55] <aatch> ChrisMorgan, why do you need to check?
[06:27:09] <dbaupp> ChrisMorgan: or,  match *x { StaticStr(..) => .., OwnedStr(..) => .. }
[06:27:20] <aatch> Anyway, I kinda want a better name...
[06:27:31] <ChrisMorgan> aatch: to implement to_owned - which I presume you're doing properly.
[06:27:53] <aatch> ChrisMorgan, I am, but I implemented it on to_slice()
[06:27:57] <aatch> as_slice()
[06:28:26] <aatch> so I have a grand total of 2 matches
[06:28:28] <ChrisMorgan> dbaupp: your first is what I tried second and it didn't work; your second suddenly occurred to me *just* before you sent it :-)
[06:28:42] <ChrisMorgan> What's the deal with to_* and as_*?
[06:28:46] <aatch> for VecRef
[06:28:57] <darkf> oh, apparently I need to dereference it even with the dot operator :\
[06:28:59] <aatch> ChrisMorgan, to_* allocates/copies as_* does not
[06:29:20] <aatch> darkf, yeah, Trait objects aren't very good at the moment.
[06:29:23] *** Quits: Nisstyre (wes@moz-FD86289.netflash.net) (Quit: Leaving)
[06:29:31] <dbaupp> ChrisMorgan: (i.e. what aatch said is the convention.)
[06:29:50] <dbaupp> ChrisMorgan: what do you mean it didn't work?
[06:30:09] <aatch> dbaupp, you got any better names?
[06:30:23] <ChrisMorgan> dbaupp: sorry, my own fault‚ÄîI was working with &self rather than self accidentally.
[06:30:28] <dbaupp> aatch: nope
[06:30:39] * dbaupp is particularly bad at naming
[06:30:43] <aatch> Ugh.
[06:30:54] <aatch> I might leave it for now.
[06:31:00] *** Quits: lkuper (lkuper@moz-C0CD33ED.hsd1.in.comcast.net) (Ping timeout)
[06:31:05] <aatch> It's not _that_ bad I guess.
[06:31:10] <dbaupp> rusti: extra::fileinput::pathify(&["foo", "bar"], false)
[06:31:11] <mark_edward> dbaupp: any advice
[06:31:12] -rusti- <anon>:7:35: 7:50 error: mismatched types: expected `&[~str]` but found `&[&'static str]` (str storage differs: expected ~ but found &'static )
[06:31:12] -rusti- <anon>:7          extra::fileinput::pathify(&["foo", "bar"], false)
[06:31:13] -rusti-                                             ^~~~~~~~~~~~~~~
[06:31:13] -rusti- error: aborting due to previous error
[06:31:13] -rusti- application terminated with error code 101
[06:31:21] <dbaupp> rusti: extra::fileinput::pathify(&[~"foo", ~"bar"], false)
[06:31:23] -rusti- ~[Some({is_absolute: false, components: ~[~"foo"]}), Some({is_absolute: false, components: ~[~"bar"]})]
[06:31:26] <dbaupp> mark_edward: yeah, working on it now
[06:31:41] <mark_edward> no rush! just wondering if you got my message
[06:31:47] <mark_edward> don't want to bother you or anything
[06:31:52] <dbaupp> aatch: see. I had to resort to calling a function `pathify` :(
[06:32:05] <dbaupp> mark_edward: np, I think I've narrowed it down though
[06:32:50] <strcat> brendanc: ugh it's evil
[06:33:17] <brendanc> ?
[06:33:22] * strcat can't figure it out ;p
[06:33:46] *** Quits: Amanieu (amanieu@moz-D5D10CA8.halls.manchester.ac.uk) (Connection reset by peer)
[06:33:56] <strcat> 100k 8MiB allocations, 1 page touched -> it says ~400MiB
[06:34:15] <strcat> that's userspace though
[06:34:25] <strcat> I don't think my kernel has kmem memory usage stats
[06:34:29] *** Joins: Amanieu (amanieu@moz-D5D10CA8.halls.manchester.ac.uk)
[06:34:43] <darkf> and also apparently .times doesn't exist on specific types like u32 which is weird
[06:34:53] <brendanc> yeah it seems like you'd need the kernel side
[06:35:04] <strcat> oh memory.kmem.usage_in_bytes is always 0...
[06:35:08] <strcat> it's just there as a stub I guess
[06:35:16] <cmr> darkf: it was removed to compensate for a bug and nobody added it back because honestly, not that useful
[06:35:16] <dbaupp> mark_edward: -impl<'self, T> Iterator<(uint, &'self mut T)> for SmallIntMapMutIterator<'self, &'self T> {
[06:35:16] <dbaupp> mark_edward: +impl<'self, T> Iterator<(uint, &'self mut T)> for SmallIntMapMutIterator<'self, T> {
[06:35:47] <dbaupp> cmr: the bug still exists, I believe
[06:35:53] <cmr> dbaupp: I don't think so
[06:36:15] <darkf> cmr: it is when I am reading binary data and want to loop `length` (u32) times :)
[06:36:15] <cmr> It's the same asto_str ambiguous method call
[06:36:19] <dbaupp> cmr: the bug is that 1.times would cause a "multiple applicable methods in scope" error, right?
[06:36:22] <mark_edward> dbaupp: still not working
[06:36:30] <dbaupp> mark_edward: same error?
[06:36:34] <cmr> dbaupp: no, the bug is that it would *randomly pick* which method touse!
[06:36:37] <mark_edward> yup
[06:36:49] <dbaupp> mark_edward: oh, right, you also, need `Some(ref mut e)`
[06:36:53] <cmr> freakin' netbook spacebar is the worst..
[06:37:01] <dbaupp> mark_edward: (in the match)
[06:37:36] <strcat> brendanc: well the kernel says it's not using much at all...
[06:37:42] <mark_edward> God bless you man!!!!
[06:37:45] <aatch> https://github.com/mozilla/rust/pull/7599 <-- ChrisMorgan
[06:37:46] <brendanc> I can't see how a vma would take a page, and it kind of seemed like it wasn't allocating a vma per map
[06:37:48] <dbaupp> cmr: oh, I see. however, I imagine that the multiple applicable methods in scope error would pop up
[06:37:48] <mark_edward> And i'm not even religious!
[06:37:54] <strcat>  Active / Total Size (% used)       : 34527.59K / 37877.77K (91.2%)
[06:37:57] <strcat> without it
[06:38:02] <brendanc> so that other memory is pretty mysterious
[06:38:04] <strcat>  Active / Total Size (% used)       : 34625.72K / 37917.68K (91.3%)
[06:38:09] <strcat> with it
[06:38:42] <cmr> dbaupp: sure, but that's harmless and easy to fix
[06:38:46] <brendanc> maybe free is full of lies :)
[06:39:11] <dbaupp> cmr: not really, it causes a huge explosion of errors
[06:39:58] <brendanc> I wonder if free memory is actually a figment used to tune other overcommit functions
[06:39:58] <strcat> brendanc: ok it might be that I need to turn overcommit to the non-default setting to actually get close to my real RES limit...
[06:40:57] <strcat> ' Within this mode, the total commit can not exceed the swap space(s) size + overcommit_ratio percent * RAM size. By default, the overcommit ratio is 50.'
[06:40:58] <strcat> that's what it is
[06:41:07] <brendanc> aha
[06:41:25] <dbaupp> cmr: also, http://huonw.github.io/isrustfastyet/mem/#b055a10,6caaa34 (the `passes` checkboxes on the right)
[06:41:46] <ChrisMorgan> aatch: thanks
[06:42:01] <strcat> brendanc: oh nvm
[06:42:04] <strcat> brendanc: that's not the default mode.
[06:42:09] <strcat> 0 means that the kernel will use predefined heuristics when deciding whether to allow such an overcommit. This is the default.
[06:42:15] <strcat> the default is not very descriptive
[06:42:16] <cmr> dbaupp: any way to tease apart all the scrunched up passes?
[06:42:19] <brendanc> does kern usage go up when you're doing the unmap thing?
[06:42:45] <dbaupp> cmr: yeah, planning on doing zooming sometime.
[06:42:49] <cmr> ok
[06:42:51] <strcat> When this flag is 0, the kernel attempts to estimate the amount
[06:42:52] <strcat> of free memory left when userspace requests more memory.
[06:43:02] <strcat> When this flag is 1, the kernel pretends there is always enough
[06:43:04] <strcat> memory until it actually runs out.
[06:43:10] <strcat> When this flag is 2, the kernel uses a "never overcommit"
[06:43:12] <strcat> policy that attempts to prevent any overcommit of memory.
[06:43:12] <brendanc> hmm
[06:43:14] <ChrisMorgan> I wish Rust would let you call functions with explicit argument names. For structs, you have to (`Point2D {x: 0, y: 0}`), and for functions, you can't (`complex_config(true, false, true, false, 1, 0, 1, 0, 'b', "a")`).
[06:43:14] * strcat tries 1 instead of 0
[06:43:27] <brendanc> I think this basically means you can't trust free :)
[06:43:33] <dbaupp> cmr: (It's not that important though, since the most useful information/biggest gains are in the longest passes.)
[06:43:38] <aatch> ChrisMorgan, that's a sign you need to refactor your function
[06:43:47] <dbaupp> ChrisMorgan: combine the two
[06:43:52] <cmr> dbaupp: trans always comes with a very distinctive drop, I wonder if it'd be possible to automagically align trans-end with that drop?
[06:44:12] <dbaupp> ChrisMorgan: complex_config(Config { x: true, y: false , ... })
[06:44:16] <ChrisMorgan> aatch: I'll agree with you in general; but sometimes, you simply can't do that to any benefit, and explicit is better than implicit
[06:44:20] <strcat> brendanc: it still seems to use more than it says
[06:44:46] <dbaupp> ChrisMorgan: this also allows `complex_config(default_config())` and `complex_config(Config { foo: 10, .. default_config() })`
[06:44:58] <dbaupp> cmr: hm
[06:44:59] * strcat gives up
[06:45:01] <brendanc> I suspect free is a lie
[06:45:12] <ChrisMorgan> Whoa, `Config { foo: 10, .. default_config() }`?
[06:45:23] <cmr> ChrisMorgan: yup!
[06:45:32] <dbaupp> cmr: are we sure that it's that drop?
[06:45:50] <aatch> dbaupp, yes
[06:46:01] <cmr> that thatdrop is trans ending? yes
[06:46:14] <strcat> rusti: 2
[06:46:17] <brendanc> if you touch two pages, is the ratio of free drop to res usage still 2x?
[06:46:17] -rusti- 2
[06:46:18] <strcat> poor rusti
[06:46:19] <ChrisMorgan> I take back any hypothetical disappointment I might have hypothetically hypothecated to structs.
[06:46:22] <strcat> keeps getting flushed from cache
[06:46:38] <dbaupp> cmr: I feel like linking is wrong though
[06:47:00] <dbaupp> cmr: and sliding the passes left will make it even wronger
[06:47:01] <cmr> ChrisMorgan: Once we have a Default trait I'd like ..super to be syntax sugar for ..Default::default()
[06:47:22] <dbaupp> cmr: s/left/right/
[06:47:43] <dbaupp> cmr: ..super? surely {..default } would be better?
[06:47:55] <aatch> dbaupp, strcat, any thoughts on my PR? since you two have been doing lots of work in those modules
[06:47:55] <cmr> dbaupp: well super is already a keyword
[06:48:15] <dbaupp> rusti: let super = 1; super
[06:48:15] <cmr> dbaupp: anyone I dunno about linking...
[06:48:16] -rusti- more than 5 lines of output, pastebinned: http://sprunge.us/CHET
[06:48:25] <dbaupp> cmr: so it is
[06:48:32] <aatch> linking takes a lot of memory
[06:48:42] *** Joins: vk (vk@moz-389FEE13.hsd1.ca.comcast.net)
[06:48:44] <ChrisMorgan> cmr: why `..Default:Default()`? Surely you mean `..Default()`?
[06:48:52] <cmr> ChrisMorgan: Default::default()
[06:48:57] <cmr> ChrisMorgan: static method on a trait
[06:49:13] <dbaupp> aatch: looks fine. however having to reimplement all the methods not in the trait is annoying 
[06:49:26] <ChrisMorgan> *sigh* That's what comes of not thinking properly when reversing Pidgin's smilification of the :D mentally
[06:49:30] *** Joins: vegai (vegai@moz-84E87CA5.kapsi.fi)
[06:49:38] <strcat> brendanc: 100k allocs, 4 pages touched -> 1562MiB RES
[06:49:45] <dbaupp> aatch: right, hence why I think linking is aligned wrong on the graphs
[06:49:47] <mark_edward> rusti: let x =  ~[1,2,3].iter().next(); x
[06:49:50] -rusti- more than 5 lines of output, pastebinned: http://sprunge.us/JIeF
[06:50:14] <brendanc> free drop?
[06:50:18] <strcat> brendanc: 400k allocs, 1 page touched -> near 4GiB memory actually consumed, despite it thinking RES is the same
[06:50:20] *** Quits: jmgrosen (jmgrosen@moz-848F6087.sb.sd.cox.net) (Quit: jmgrosen)
[06:50:24] <brendanc> huh
[06:50:29] <strcat> brendanc: it uses waaaaay more with more allocs
[06:50:29] <dbaupp> rusti: let v = ~[1,2,3]; let x = v.iter().next(); println(fmt!("%?", x))
[06:50:31] -rusti- Some(&1)
[06:50:31] -rusti- ()
[06:50:35] <strcat> brendanc: despite being the same # of pages
[06:50:47] <strcat> dunno how much more, it scales strangely
[06:50:53] <aatch> dbaupp, the test?
[06:50:54] <brendanc> now I'm pretty confused
[06:51:00] <mark_edward> rusti: let v = ~[1,2,3]; let x = v.iter().next(); x
[06:51:01] -rusti- more than 5 lines of output, pastebinned: http://sprunge.us/GQXI
[06:51:04] <cmr> ChrisMorgan: https://github.com/mozilla/rust/issues/7312
[06:51:05] <mark_edward> :-(
[06:51:07] <brendanc> unless it's just that free is a lie :)
[06:51:10] <aatch> Yeah, I tried that, it didn;t like it.
[06:51:19] <roo> trait Something<A> { fn put(A) -> Self<A>; fn default(...) -> ... { Self::put(x) } } does something like this make sense for default methods?
[06:51:22] <brendanc> how much actual ram do you have?
[06:51:23] <dbaupp> aatch: "test"?
[06:51:37] <cmr> roo: we already have default method :p
[06:51:51] <roo> well, ignoring the names XD
[06:51:54] <mark_edward> rusti: use std::vec::*; let v = ~[1,2,3]; let x: VecIterator<int>  = v.iter().next(); println(fmt!("%?", x))
[06:51:55] -rusti- line longer than 150 columns, pastebinned: http://sprunge.us/RNhc
[06:51:56] <strcat> brendanc: well I have 12GiB but it has 4GiB available now since I put it in a container after it destroyed all my caches
[06:51:59] <cmr> s/method/methods
[06:51:59] <aatch> dbaupp, what you just did, was simlar to one of my vec tests
[06:52:05] <cmr> roo: the feature exists
[06:52:26] <strcat> brendanc: anyway it *definitely* uses less memory with smaller alloc sizes
[06:52:28] <roo> right, i am saying within the context of default methods, does that sort of pattern even make sense
[06:52:29] <brendanc> I am wondering if you ca run past the amount of free space reported
[06:52:32] <brendanc> can
[06:52:34] <cmr> ah
[06:52:36] <dbaupp> aatch: I was just getting mark_edward's code to run
[06:52:51] <aatch> dbaupp, oh, so you were.
[06:52:51] <strcat> brendanc: well I tried outside the container and mmap failed
[06:52:57] <strcat> brendanc: but that was with overcommit=0
[06:53:00] <strcat> so weird heuristics
[06:53:01] <dbaupp> rusti: let v = ~[1,2,3]; let x: Option<&int> = v.iter().next(); println(fmt!("%?", x)) // mark_edward
[06:53:02] -rusti- Some(&1)
[06:53:02] -rusti- ()
[06:53:06] <strcat> it didn't get OOM killed
[06:53:12] <strcat> so I suspect you're right
[06:53:16] <mark_edward> ok thanks dbaupp!
[06:54:14] <aatch> ugh, looks like some of the dependencies have been done properly in the Makefile
[06:54:22] <brendanc> fun stuff but I'd better get to bed :)
[06:54:39] <aatch> haven't*
[06:54:55] * roo is trying to write a typeclass, not a trait.. :(
[06:55:17] <roo> sort of.
[06:55:19] <dbaupp> aatch: (I know that the file dependencies don't go deep enough for libsyntax.)
[06:55:28] <dbaupp> roo: typeclass = trait?
[06:55:41] <strcat> aatch: which PR?
[06:56:00] <aatch> strcat, https://github.com/mozilla/rust/pull/7599
[06:56:13] <ChrisMorgan> aatch: yes, that StringRef is exactly what I want :-)
[06:56:21] <strcat> oh already r+'ed ;p
[06:56:39] <dbaupp> rusti: trait Foo { fn foo<'a>(&'a self) -> &'a self; } impl<'self> Foo for &'self str { fn foo<'a>(&'a self) -> &'a self { *self } }
[06:56:40] -rusti- more than 5 lines of output, pastebinned: http://sprunge.us/KDGT
[06:56:50] <aatch> ChrisMorgan, yeah, well there was already an open issue about it anyway.
[06:56:58] <dbaupp> rusti: trait Foo { fn foo<'a>(&'a self) -> &'a str; } impl<'self> Foo for &'self str { fn foo<'a>(&'a self) -> &'a str { *self } }
[06:56:59] -rusti- ()
[06:57:02] <strcat> aatch: what's the use case for it? I don't really get it
[06:57:14] <dbaupp> hm that works, so i'm clearly misunderstanding something
[06:57:17] <dbaupp> :/
[06:57:41] <dbaupp> strcat: when you need a string that lasts arbitrarily long
[06:57:44] <aatch> strcat, basically there are times where you normally can use a static value, and allocation is less common, but does happen
[06:57:55] <dbaupp> strcat: i.e. it lasts forever or you own it
[06:58:15] <strcat> oh okay
[06:58:39] <strcat> makes sense now
[06:58:45] <aatch> strcat, oh, good example, the passes array
[06:59:10] <aatch> it only needs to be ~strs because you can pass them on the command line too
[06:59:20] <ChrisMorgan> strcat: my example for wanting something like it is where I wish to represent HTTP methods; e.g. static GET: &'static str = "GET", but also have the option of accepting a non-standard method.
[06:59:57] <strcat> ChrisMorgan: you could just use an enum there though
[07:01:17] * strcat sees that you could want something like a sendable vector of strings though
[07:01:26] <strcat> and StringRef lets you make some &'static str
[07:01:59] <aatch> strcat, it's definately an optimization case
[07:02:31] <strcat> aatch: yep it makes sense
[07:02:34] <strcat> passes is a good example
[07:04:34] <ChrisMorgan> strcat: I'm not seeing how that would work
[07:04:56] <strcat> ChrisMorgan: enum Method { Get, Post, ... }
[07:05:03] <strcat> why do you need a string?
[07:05:09] *** Quits: alisdair (textual@moz-EBE9F394.bchsia.telus.net) (Quit: My MacBook Pro has gone to sleep. ZZZzzz‚Ä¶)
[07:05:13] <ChrisMorgan> strcat: as I said, you may have non-standard methods.
[07:05:16] <aatch> ChrisMorgan, you have enum Method { GET, POST, ..., Other(~str) }
[07:05:27] <ChrisMorgan> Aah!
[07:05:49] <ChrisMorgan> That makes more sense.
[07:05:59] *** Quits: vk (vk@moz-389FEE13.hsd1.ca.comcast.net) (Quit: vk)
[07:06:12] <aatch> You could, if you wanted, put a StringRef in there, but I doubt it's worth it in this case.
[07:06:24] <strcat> or just Other(~MethodTrait)
[07:06:30] <strcat> ;p
[07:06:35] <darkf> what's a good way to convert a ~[u8] to a string?
[07:07:00] <aatch> darkf, from_bytes
[07:07:06] <darkf> ty
[07:07:49] <aatch> rusti: let v : ~[u8] = ~['a' as u8,'b' as u8,'c' as u8]; std::str::from_bytes(v)
[07:07:50] -rusti- ~"abc"
[07:09:04] <roo> dbaupp: I think the distinction probably isn't between traits and typeclasses, but between the rust type system and something with higher kinded types. It is more that I am trying to write haskell stuff in rust.
[07:09:09] <ChrisMorgan> But then, the other similar case is response codes, where you'll have lots of predefined ones and again the option of custom ones. I guess that can work in a similar way, but the code would end up three times as many lines (over six times as long) as what I have at present, going through defining the options, then defining the status, then the messages, rather than defining each in turn, tabular fashion.
[07:09:26] <dbaupp> roo: right
[07:09:43] <dbaupp> foo: (I'd higher kinded types.)
[07:09:59] <aatch> roo, I know that feeling
[07:10:09] <roo> ;P
[07:10:12] <aatch> trying to replicate Parsec in Rust
[07:10:26] <aatch> I mostly just ran into type inference bugs though
[07:13:55] *** Quits: gour (gour@moz-F4263343.adsl.net.t-com.hr) (Quit: WeeChat 0.4.0)
[07:14:07] *** Joins: Axord (xord@moz-C3CCF156.lsanca.dsl-w.verizon.net)
[07:15:05] *** Joins: vk (vk@moz-389FEE13.hsd1.ca.comcast.net)
[07:15:12] <darkf> so uhh, how do I use .each on ~[T]?
[07:15:24] <aatch> darkf, you don't
[07:15:31] <aatch> you use .iter.advance
[07:15:38] <aatch> .iter().advance I mean
[07:15:43] * darkf shrugs
[07:15:54] <darkf> is there an equivalent of .eachi then besides making a counter?
[07:16:00] <strcat> there's no eachi anymore
[07:16:05] <strcat> darkf: enumerate
[07:16:05] <darkf> :(
[07:16:06] <aatch> darkf, iter().enumerate()
[07:16:11] <darkf> ty
[07:16:13] <aatch> look at std::iterator
[07:16:13] * strcat misunderstood
[07:16:40] <strcat> darkf: http://static.rust-lang.org/doc/tutorial-container.html#iterators this explains why things are the way they are (as in why .advance is needed for now, etc.)
[07:16:52] <strcat> it will get much nicer as the compiler issues are fixed
[07:17:12] <darkf> ah, I see
[07:18:18] <roo> aatch: yeah, I had a go the other day at a rust parser combinator, and became intimately familiar with how tricky heap closures can be.
[07:18:29] *** Joins: gour (gour@moz-F4263343.adsl.net.t-com.hr)
[07:18:31] <aatch> roo, I tried using traits
[07:19:06] * strcat wonders what boost spirit does
[07:19:31] <roo> yeah, i have a one shot heap closure-like trait thing im using now
[07:19:50] *** Joins: SimonSapin (simon@moz-D0C2F181.zone2.bethere.co.uk)
[07:20:12] <roo> it moves itself into its apply() method.
[07:20:48] *** Joins: sankha93 (Instantbir@9276287F.8CAC2DA9.D2D1FAF0.IP)
[07:20:55] <mark_edward> how do i run the tests?
[07:21:02] <aatch> mark_edward, make check
[07:21:07] <mark_edward> cool
[07:22:47] *** Quits: robn (robn@moz-76B0302C.static.internode.on.net) (Quit: Coyote finally caught me)
[07:22:53] *** Joins: robn (robn@moz-76B0302C.static.internode.on.net)
[07:23:21] *** Joins: Voomer_ (Voomer@moz-E97E8EB7.br.br.cox.net)
[07:23:21] *** Quits: Voomer__ (Voomer@moz-E97E8EB7.br.br.cox.net) (Connection reset by peer)
[07:23:24] <dbaupp> mark_edward: while you're experimenting on just extra, you can probably do `make check-stage1-extra`
[07:23:33] <mark_edward> ok, thanks db
[07:23:36] *** Joins: Ms2ger (Ms2ger@moz-AC84CFF6.adsl-dyn.isp.belgacom.be)
[07:23:53] <dbaupp> mark_edward: (or do a full make, and then use `make check-stage2-extra NO_REBUILD=1`, which is even faster.)
[07:24:48] <darkf> oh dear, advance works but enumerate doesn't
[07:24:58] <dbaupp> darkf: you need .enumerate().advance
[07:25:16] <darkf> oh
[07:25:18] <darkf> ouch
[07:25:37] <dbaupp> (enumerate() returns a new iterator, so it can be combined with other iterators.)
[07:25:51] <dbaupp> .advance will disappear, so it'll be fine
[07:26:12] <darkf> thanks
[07:28:54] <strcat> darkf: it will eventually just become
[07:29:06] <strcat> for container.enumerate |(i, x)| {}
[07:29:19] <darkf> that is significantly nicer
[07:29:30] <Ms2ger> Possibly ;)
[07:32:52] <dbaupp> there's no way around this, right https://gist.github.com/huonw/5932680 (since self is no longer `self<'self>`)
[07:32:56] <dbaupp> strcat: that seems unlikely
[07:33:09] <dbaupp> strcat: since that conflicts with property access
[07:33:20] <dbaupp> strcat: so container.enumerate() is the best it can be
[07:33:41] <strcat> dbaupp: true
[07:33:47] <aatch> dbaupp, that's what I hit too.
[07:34:09] <aatch> and if you add a 'self to &'self you get a mis-matched type error
[07:34:17] <dbaupp> right
[07:34:21] *** Quits: snadon (chatzilla@moz-3BC727E8.mc.videotron.ca) (Ping timeout)
[07:34:22] <mark_edward> dbaupp: help me think this through. i think my implementation is wrong. if i call self.iter.rev_iter().enumerate() where (self.iter = underlying vec iterator)
[07:34:32] <mark_edward> i think i'll get the keys in the wrong order
[07:34:50] <dbaupp> as in .enumerate() is backwards, yes
[07:35:03] <dbaupp> (you can go `len() - 1 - i`)
[07:35:23] <mark_edward> where would i do that?
[07:35:44] <dbaupp> mark_edward: wherever you need the true index
[07:35:54] <dbaupp> aatch: this is really annoying :(
[07:36:15] <aatch> dbaupp, I know
[07:36:40] <strcat> dbaupp: look at TreeMap's iterator, it works somehow
[07:36:42] <strcat> aatch: *
[07:37:04] <aatch> strcat, what?
[07:37:22] * strcat doesn't really understand the issue
[07:37:27] <mark_edward> dbaupp: can the length of the of the smallintmap change while you have a mutable iterator to it?
[07:37:40] <strcat> mark_edward: no, it can't change while you have an iterator over it
[07:37:56] <mark_edward> but how? if it's mutable?
[07:37:56] <strcat> at all, assuming you have a &/&mut to it
[07:38:08] <aatch> strcat, what are you talking about?
[07:38:08] <strcat> mark_edward: because &/&mut are memory safe, they provide the guarantees needed already
[07:38:15] <strcat> aatch: I don't know! :p
[07:38:15] <mark_edward> oh, ok
[07:38:26] <strcat> mark_edward: & points at immutable memory, &mut is a unique handle
[07:38:32] <strcat> those rules are always upheld
[07:38:45] <strcat> unique mutable handle*
[07:40:25] <mark_edward> dbaupp: i think instead of an enumerateiterator, i need a zipiterator with a counter...
[07:41:00] <strcat> that'll work
[07:41:45] <strcat> if we had BidirectionalIterator we could add rfind/rposition as convenience functions again
[07:41:49] <mark_edward> what bout te performance though? will that hurt? i think it will double the size of the struct though, right?
[07:42:07] <strcat> the structs are optimized out unless you store them somewhere weird
[07:42:27] <aatch> hah, this is a good start.
[07:43:19] <aatch> I'm trying to remove some of the @'s from the AST, a bit at a time
[07:43:20] <mark_edward> ok cool
[07:44:16] <aatch> started easy and went with view items. removing the `@` from it everywhere seems to have got me about 50% there for libsyntax
[07:45:25] * strcat wonders where Iterable traits should go
[07:45:27] *** Joins: Blub\w (wry@7E3BB9D.71150E1A.237AE2BA.IP)
[07:45:34] <strcat> will just put them in iterator.rs for now
[07:46:03] <strcat> cmr: cgroups are going to completely change btw ;p
[07:46:21] *** Joins: jpochyla (jpochyla@moz-8D99AE5D.broadband18.iol.cz)
[07:48:17] *** Joins: pyrac (pyrac@F9CC429.73C89388.AD05C589.IP)
[07:49:05] *** Joins: mib_axb4wr (Mibbit@moz-D3D8B7EA.members.linode.com)
[07:49:36] <mib_axb4wr> hi
[07:50:04] *** Quits: mib_axb4wr (Mibbit@moz-D3D8B7EA.members.linode.com) (Quit: http://www.mibbit.com ajax IRC Client)
[07:50:15] *** Joins: Asaka (Mibbit@moz-D3D8B7EA.members.linode.com)
[07:50:45] <dbaupp> aatch: 50% of what?
[07:51:02] <aatch> dbaupp, removing the @ from view_item
[07:51:09] <aatch> not a big change, I'll grant
[07:51:17] <aatch> but baby steps... baby steps
[07:52:19] *** Quits: jpochyla (jpochyla@moz-8D99AE5D.broadband18.iol.cz) (Ping timeout)
[07:52:30] <Asaka> Hi, i want to know is there any http server avialable?
[07:52:39] <aatch> Asaka, there is not
[07:52:52] <Ms2ger> Unless you write one, of course :)
[07:52:52] <Asaka> thx..
[07:53:00] <strcat> you can use something like libmicrohttpd, or similar
[07:53:12] *** Joins: rubber-duck (rubber-duc@moz-A944829F.dsl.iskon.hr)
[07:53:21] <rubber-duck> how do I get a stacktrace from fail!() ?
[07:53:44] <strcat> RUST_LOG=::rt::backtrace, I think
[07:54:27] <Asaka> i saw the libmicrohttpd, but if i use it , if i want connect other service like database, i can not use the async io ,is it?
[07:55:20] <strcat> Asaka: don't really know, ideally we would have http bindings in libextra but we don't
[07:55:27] <strcat> or an implementation in rust
[07:56:09] <rubber-duck> lol that "stack-trace" only prints stack-adresses - not even function names :|
[07:56:16] <Asaka> hope it came out soon
[07:56:32] *** Quits: bjz (brendanzab@B398BE78.F804C29E.D35A31DF.IP) (Client exited)
[07:57:03] <rubber-duck> eg.  ./test[0x41df63]
[07:57:17] <aatch> rubber-duck, that's odd, I normally see function names
[07:57:21] <strcat> rubber-duck: what platform?
[07:57:38] <dbaupp> rubber-duck: what happens if you compile with -Z debug-info?
[07:58:15] <rubber-duck> linux 
[07:58:21] <rubber-duck> dbaupp, let me try 
[07:58:48] <rubber-duck> dbaupp, same thing
[07:58:55] <rubber-duck> I get functioni names for runtime functions
[07:58:59] <rubber-duck> but not my app functions
[07:59:37] <rubber-duck> https://gist.github.com/rubber-duck/5932806
[07:59:54] <aatch> rubber-duck, if your app is small enough, you might have everything inlined
[07:59:55] <strcat> impl<'self, A> Iterable<'self A, VecIterator<'self, A>> for &'self [A] {
[07:59:57] <strcat> ;p
[08:00:07] <strcat> ugh missing comma
[08:00:34] <rubber-duck> aatch, so how do I debug this :O it's not that small - it's ~600 lines
[08:00:37] <mark_edward> what are all the stages for when compiling rust?
[08:00:52] <Ms2ger> 1, 2 and 3? :)
[08:01:09] <aatch> rubber-duck, compile with --passes=""
[08:01:26] <aatch> it'll be really, really slow
[08:01:32] <aatch> but will work.
[08:01:44] <rubber-duck> aatch, same deal - no function names
[08:01:52] <aatch> rubber-duck, very odd
[08:01:57] <strcat> aatch: there's no inlining without opt though
[08:02:00] <strcat> except alwaysinline
[08:02:07] <strcat> and same at --opt-level=1
[08:02:11] <aatch> strcat, I thought it might always?
[08:02:26] <strcat> aatch: only when the inline pass is run
[08:02:32] <strcat> at O2 and O3
[08:02:46] <rubber-duck> i did "export RUST_LOG=::rt::backtrace" - maybe this is wrong ?
[08:02:47] <strcat> aatch: I mean O0 and O1 don't run 'inline'
[08:02:52] <rubber-duck> because I only get runtime function names
[08:02:56] <strcat> so they don't do any inlining based on cost
[08:03:17] <aatch> strcat, and I meant his inlined functions might be always inline
[08:03:32] <strcat> ugh this is annoying
[08:03:36] <strcat> it autoborrows ~[] as &[]
[08:03:39] <strcat> but not &&[]
[08:04:02] <aatch> rubber-duck, Oh, it's possible that because you have a binary, LLVM is ignoring the names of the functions.
[08:04:03] <rubber-duck> aatch, I don't think it's inlining everything because it shows different addresses in that stack trace - just no names
[08:04:43] <aatch> since in an executable, they all get marked as internal
[08:05:25] <mark_edward> Ms2ger: yes, i know what they are, but why are they there? wwht do they signify?
[08:05:29] <rubber-duck> please tell me that there's an easy way to disable this - i don't want to insert tracing printfs in 600 lines of code 
[08:05:36] <Ms2ger> No idea
[08:06:04] *** Joins: pnathan (Adium@moz-E3C3FAF2.hfc.comcastbusiness.net)
[08:06:05] <strcat> rubber-duck: it works here so I don't know
[08:06:14] * strcat shrugs
[08:06:19] <rubber-duck> I can upload it on github
[08:06:20] <mark_edward> does anyone know what all the stages are for when compiling in rust?
[08:06:47] <aatch> mark_edward, do you mean the compiler, or just arbitrary rust code?
[08:07:27] <mark_edward> the compiler
[08:07:38] <aatch> mark_edward, each stage is essentially the same.
[08:07:45] *** Quits: pnathan (Adium@moz-E3C3FAF2.hfc.comcastbusiness.net) (Ping timeout)
[08:07:51] <mark_edward> so why are they there?
[08:07:52] <aatch> stage1 is build with the downloaded snapshot (stage0)
[08:08:00] <aatch> mark_edward, (gimme a moment)
[08:08:22] <mark_edward> okey dokes
[08:08:29] <aatch> stage2 is built with the stage1 compiler.
[08:08:42] <aatch> and stage3 is build with the stage2 compiler
[08:08:52] <aatch> the last stage isn't _strictly_ necessary
[08:09:11] <mark_edward> why 3 times? doesn't gcc just use the last version once? (i'm not sure on this)
[08:09:21] <strcat> no
[08:09:38] <strcat> http://gcc.gnu.org/install/build.html
[08:09:42] <strcat> For a native build, the default configuration is to perform a 3-stage bootstrap of the compiler when ‚Äòmake‚Äô is invoked. This will build the entire GCC system and ensure that it compiles itself correctly. It can be disabled with the --disable-bootstrap parameter to ‚Äòconfigure‚Äô, but bootstrapping is suggested because the compiler will be tested more completely and could also have better
[08:09:44] <strcat> performance. 
[08:09:45] <aatch> mark_edward, you first get a compiler that has new changes, but hasn't been built with them.
[08:10:03] *** Quits: Asaka (Mibbit@moz-D3D8B7EA.members.linode.com) (Quit: http://www.mibbit.com ajax IRC Client)
[08:10:18] *** Joins: mib_a4zz4i (Mibbit@moz-D3D8B7EA.members.linode.com)
[08:10:26] <aatch> then you get a compiler that has been built with the new changes, the last compiler ensures that the previous one still works
[08:11:02] <aatch> as you cannot be sure that the changes you made (especially if its in, e.g. codegen) work until then.
[08:12:29] *** Quits: mib_a4zz4i (Mibbit@moz-D3D8B7EA.members.linode.com) (Quit: http://www.mibbit.com ajax IRC Client)
[08:14:07] *** Quits: pyrac (pyrac@F9CC429.73C89388.AD05C589.IP) (Quit: pyrac)
[08:14:23] <rubber-duck> can anyone try to build and run https://github.com/rubber-duck/srsc/tree/master/libsyntax - just rustc test.rs and run it - and see if you can get stack trace ?
[08:15:02] *** Joins: bytewise (bytewise@moz-649C630D.unitymediagroup.de)
[08:15:42] *** Joins: fabiand (fabiand@moz-90C26BF4.adsl.alicedsl.de)
[08:19:06] <mark_edward> when you change test code, why does it recompile everything? i thought the tests weren't even compiled when you do a normal compile
[08:19:31] <aatch> mark_edward, because the build system doesn't know that you only changed a test
[08:19:41] <mark_edward> you mean make?
[08:19:47] <aatch> mark_edward, yes
[08:20:23] <mark_edward> why do you use make? couldn't you just use the snapshots of rustc and let that handle the dependencies?
[08:20:32] <aatch> mark_edward, not really
[08:20:44] <mark_edward> why not?
[08:20:46] *** Joins: doener (doener@moz-121949B3.unitymediagroup.de)
[08:21:14] <aatch> we have to manage 3 stages of building, cross-compiling and numerous non-rust dependencies (LLVM for example)
[08:22:19] <Ms2ger> Make is horrible
[08:22:23] <Ms2ger> But so is everything else
[08:22:33] <mark_edward> true. why do you have to build llvm? do you make patches? or couldn't you download a snapshot?
[08:22:34] <aatch> the long-term idea is to use rustpkg
[08:22:49] <aatch> mark_edward, we have a patched version
[08:23:24] <aatch> I mean, we could download a snapshot, but it has to get built at some point
[08:25:03] *** Joins: CarpNet (ac@moz-FD24B77.sohonet.co.uk)
[08:26:02] <aatch> Ok, so literally nowhere in the codebase relies on the `@`-ness of ast::view_item.
[08:26:04] <aatch> good
[08:26:09] <mark_edward> right. but it'd be boss if it wasn't on my laptop. 
[08:26:16] <mark_edward> I miss my desktop :'-(
[08:26:31] <aatch> mark_edward, LLVM doesn't normally get re-built
[08:26:40] <mark_edward> built him myself you know. he was my first :'-(
[08:26:54] <klutzy> I sometimes hope I can download binary built by bors just because I have slooow computer
[08:27:23] <mark_edward> aatch: oh true. guess i just wish rust built faster
[08:27:43] <aatch> mark_edward, well it's about 30x slower than it should be
[08:27:53] <mark_edward> why is that?
[08:27:57] <aatch> bad IR
[08:28:03] <aatch> I'm not going to explain
[08:28:17] *** Joins: robertknight (robertknig@moz-54528EE0.wby.mendeley.com)
[08:28:49] <mark_edward> oh right
[08:30:12] *** Quits: flowsnake (flowsnake@moz-1918C33E.aztw.cable.virginmedia.com) (Connection reset by peer)
[08:31:34] <strcat> aatch: how slow are calls to C right now? I remember you measure getpid
[08:31:42] <strcat> as in nanoseconds per call
[08:31:48] <strcat> measured*
[08:31:51] *** Joins: offline (offline@moz-1CDCC36B.dip0.t-ipconnect.de)
[08:31:57] <aatch> strcat, it was 36ns vs 6ns
[08:32:12] <aatch> I'm not sure if that was fast_ffi or not
[08:32:33] <strcat> doesn't matter
[08:32:39] <strcat> fast_ffi is slower without a preallocated stack anyway
[08:32:44] *** Joins: pyrac (pyrac@F9CC429.73C89388.AD05C589.IP)
[08:33:05] <aatch> I don't think I did any stack trickery
[08:34:12] *** Joins: bjz (brendanzab@B398BE78.F804C29E.D35A31DF.IP)
[08:34:42] *** Joins: flowsnake (flowsnake@moz-1918C33E.aztw.cable.virginmedia.com)
[08:35:45] *** Joins: tikue (tkuehn@moz-A7CDB794.dia.static.qwest.net)
[08:36:14] *** Joins: pnathan (Adium@B9840254.2CD8A5F8.477B877D.IP)
[08:37:18] *** Joins: Blei (philipp@moz-650B9C6A.cust.bluewin.ch)
[08:38:06] <doener> heh, the stack trickery reminded me that I wanted to get a flamegraph for the json benchmarck with a large initial stack.
[08:38:37] <doener> Most time is still spent in malloc/free, but this time because read_char calls read_chars which returns a ~[char]
[08:38:52] <strcat> doener: malloc/free should be much faster than they are though
[08:39:08] <strcat> they are 3x as slow from rust than C
[08:39:13] <strcat> thanks to FFI overhead
[08:39:28] <Ms2ger> Seems like a lot of things should be faster than they are :)
[08:39:31] <doener> still, allocating that array for each char is more than just overkill
[08:39:34] <strcat> jemalloc/tcmalloc take 10ns to allocate a small object :(
[08:39:51] <strcat> doener: yeah, we should still avoid allocations
[08:40:04] <strcat> it's just way slower than it should be :)
[08:40:33] <strcat> with glibc malloc, TreeMap is 3x slower than C++ - I can understand why, because of the ~ headers
[08:40:39] <strcat> with jemalloc/tcmalloc, it's 10x-20x slower....
[08:41:00] <strcat> as in, both C++ and Rust using those allocators
[08:42:16] *** Quits: pnathan (Adium@B9840254.2CD8A5F8.477B877D.IP) (Ping timeout)
[08:43:12] *** Joins: int3_ (int3_@moz-ABE52D50.hsd1.ca.comcast.net)
[08:44:37] *** Quits: sk (sk@61A494B3.BA40E8A.AAC02D62.IP) (Quit: Leaving)
[08:48:28] <Eridius> hrm, I ran a `make check` earlier, and now that I look back at it, it ended with an ICE :/
[08:52:52] *** Joins: lucian (lucian@6B2B4644.4304AE1E.CE5E78F6.IP)
[08:53:56] *** Quits: ChrisMorgan (chris@moz-6AC741CA.static.tpgi.com.au) (Ping timeout)
[08:54:02] *** Quits: tikue (tkuehn@moz-A7CDB794.dia.static.qwest.net) (Quit: tikue)
[08:55:44] <Eridius> hrm, re-running `make check` passed
[08:56:02] <Eridius> wait, no. There's an ICE buried in there. It just didn't stop at that
[08:56:21] <Eridius> oops no again, I just scrolled past the prompt. So that was a lie
[09:00:13] *** Quits: bjz (brendanzab@B398BE78.F804C29E.D35A31DF.IP) (Ping timeout)
[09:01:06] *** Joins: jpochyla (jpochyla@moz-8D99AE5D.broadband18.iol.cz)
[09:02:54] *** Quits: jpochyla (jpochyla@moz-8D99AE5D.broadband18.iol.cz) (Ping timeout)
[09:03:18] * gour is reading http://pcwalton.github.io/ blog...interesting things
[09:03:20] *** Quits: offline (offline@moz-1CDCC36B.dip0.t-ipconnect.de) (Quit: oO0∞)
[09:04:38] *** Joins: offline (offline@moz-1CDCC36B.dip0.t-ipconnect.de)
[09:05:03] <mark_edward> error: cannot borrow `a` as immutable because it is also borrowed as mut
[09:05:50] <mark_edward> does that make anysense? as long is it's not shared across thrreads, you should be abale to take an immutable view of an object at anytime shouldnn't you?
[09:06:52] <aatch> mark_edward, not while there is an mutable borrow
[09:07:05] <aatch> since you can't guarentee that it won't change from under you
[09:07:18] <Eridius> aatch: I don't know why the immutable borrow doesn't just freeze the mutable one, so to speak
[09:07:24] <mark_edward> yes you can. you can guarantee that statically in a single threaded context
[09:07:34] <aatch> Eridius, because that doesn't work.
[09:07:46] <aatch> It would require non-local analysis
[09:07:52] <Eridius> aatch: ah
[09:07:59] <aatch> mark_edward, not without looking past function boundaries
[09:08:08] <aatch> and once you start doing that, all bets are off
[09:08:30] <Eridius> mark_edward: no you can't. if I have a function foo(&T, &fn ()), the &T could change out from under me if the fn happens to have a mutable reference that it's mutating
[09:08:31] <aatch> since things can break when you start having to jump across libraries
[09:09:17] * Eridius goes to bed, it's too late to think about stuff like this
[09:09:22] <mark_edward> youd be able to see that can't you. the compiler knows if a function takes the reference mutably or has a mutable reference doesn't it?
[09:09:22] <strcat> aatch: https://github.com/mozilla/rust/issues/5768#issuecomment-20507701 we'll see what brson thinks ;p
[09:09:24] *** Joins: z0w0 (zack@E2E93C1.54F16452.2CE63F58.IP)
[09:09:43] <mark_edward> closures are basically compiled to function object structs aren't they?*
[09:09:49] <aatch> mark_edward, but a closure can mutable capture an upvar
[09:09:52] <strcat> mark_edward: not really
[09:10:06] <mark_edward> strcat: well someones blog said that.
[09:10:11] <strcat> closures are an environment and a function pointer
[09:10:17] <mark_edward> aatch: but doesn't the compiler know that?
[09:10:30] <aatch> mark_edward, not without looking past function boundaries
[09:10:36] *** Quits: offline (offline@moz-1CDCC36B.dip0.t-ipconnect.de) (Quit: oO0∞)
[09:10:42] <strcat> C++ lambdas compile to what are essentially uniquely typed structs with a method
[09:10:50] <strcat> rust closures aren't as efficient
[09:11:09] *** Quits: vk (vk@moz-389FEE13.hsd1.ca.comcast.net) (Quit: vk)
[09:11:13] <strcat> we could be marking functions pointers as invariant though
[09:11:16] <aatch> the signature Eridius gave ^ that function knows jack-shit about what the closure does-or-doesn't capture
[09:11:31] <strcat> yeah in C++ each lambda has a unique type
[09:11:35] <mark_edward> strcat: if rust closures did that, couldn't it be easy to ttell if it had a reference o something?
[09:11:42] <mark_edward> *to
[09:11:47] <aatch> mark_edward, still no
[09:11:51] <strcat> rust really can't do that because it doesn't have templates
[09:12:03] <strcat> I guess you could make a Callable trait
[09:12:10] <strcat> but without that it wouldn't work
[09:12:26] <strcat> and we don't have variadic generics so... that wouldn't work either
[09:12:55] <strcat> just need to start putting llvm.invariant on the code pointers and remove the headers
[09:12:57] <aatch> mark_edward, trust us, there is a good reason it doesn't work.
[09:13:07] <mark_edward> i see. are variadic generics in Rust's future? C++'s function object representtion is efficient isn't
[09:13:10] *** Joins: snadon (chatzilla@moz-3BC727E8.mc.videotron.ca)
[09:13:33] <mark_edward> aatch: oh i trust you, just trying to figure these thigns out. the opportunity to talk to language writers like you guys is just so rare
[09:13:50] <aatch> mark_edward, probably won't have variadic generics
[09:13:51] <mark_edward> just trying to take advantage of it; sorry if i ask too many questions or wrongheeaded ones
[09:14:23] <aatch> from my understanding the type system can't really support them without some serious change
[09:15:44] *** Joins: davbo (dave@moz-3FFA637C.oucs.ox.ac.uk)
[09:17:34] *** Quits: cr (anonymous@moz-4B675928.dip0.t-ipconnect.de) (Ping timeout)
[09:18:09] <mark_edward> thanks for all the info guys! I really don't mean to bother you or anything. 
[09:18:40] <mark_edward> on another note, tests are passing for the extra::SmallIntMap iterators, so now i just need to do the SmallIntSet stuff
[09:19:04] <mark_edward> finally, your smallint collections will have strcat's wonderful iterators, lol
[09:19:22] *** Quits: strcat (strcat@moz-54F7FD49.cpe.net.cable.rogers.com) (Quit: sleep)
[09:19:30] <aatch> And I'm slowly turning our AST into an AST
[09:19:53] <aatch> instead of a Tree-with-some-changes
[09:20:02] <mark_edward> what's the difference?
[09:20:12] <aatch> mark_edward, technically our AST is a graph
[09:20:13] <mark_edward> and what will it help?
[09:20:29] <mark_edward> is that good or bad?
[09:20:29] <aatch> mark_edward, I'm actually trying to remove all the @
[09:20:40] <aatch> so it can be made sendable
[09:20:45] <mark_edward> oh ok. that should help with performance right?
[09:20:50] <aatch> mark_edward, yep
[09:21:13] <mark_edward> will you parallelize rustc as well? send it across Ports and Chans?
[09:21:30] <aatch> it should also make rusti much faster.
[09:21:39] <aatch> mark_edward, not all at once, lol.
[09:21:49] <aatch> but in theory, yes
[09:22:12] <mark_edward> aatch: yeah, i just realized what a big task that'd be after i wrote it!
[09:22:42] <mark_edward> speaking of rusti is there a reason rusti requires every intermediate statement's type to be encodable?
[09:22:57] <mark_edward> or is it an implementation issue?
[09:23:07] <aatch> mark_edward, implementation issue
[09:23:12] <aatch> because the AST isn't sendable
[09:23:31] <mark_edward> 2 birds with one rusty stone then
[09:24:51] <aatch> Ideally with rusti, it should just send the AST back and forth
[09:25:00] <aatch> instead of encoding it, then decoding it.
[09:25:54] *** Quits: jaen (jaen@moz-E0979827.copit.pl) (Ping timeout)
[09:25:55] <mark_edward> i see. what branch of your rust fork are you doing this on? i'm just curious to see what sort of changes you have to/have had to make for this
[09:26:51] <aatch> mark_edward, I haven't pushed it yes
[09:26:53] <aatch> yet*
[09:27:15] <aatch> but it'll be on syntax-deshare
[09:27:26] <mark_edward> oh ok. are you going to do a writeup on this work? it sounds important
[09:27:32] <mark_edward> thanks for the info!
[09:27:50] <aatch> mark_edward, I dunno, I might not finish it.
[09:28:02] <mark_edward> too little time?
[09:28:15] <aatch> mark_edward, it's also not easy
[09:28:40] <aatch> I'm doing the easy bits right now and it's still quite a lot to change
[09:28:54] <mark_edward> yep. doesn't sound easy. can i asked what/if you studied on this sort of stuff in university?
[09:29:12] <aatch> mark_edward, nope, I didn't even graduate
[09:29:35] <aatch> dropped out because I was horribly in debt and got a job with a start-up
[09:29:46] <mark_edward> how'd you learn to hack on compilers then? it seems like a tough topic to learn unassisted!
[09:29:54] <mark_edward> aatch: you're american then?
[09:30:09] <aatch> mark_edward, no, New Zealand
[09:30:21] <aatch> I just had some bad luck.
[09:30:40] <aatch> I also wasn't doing very well
[09:30:40] <mark_edward> really? i thought only americans had the pleasure of bearing a massive debt burden because of college
[09:31:00] *** Joins: jaen (jaen@moz-E0979827.copit.pl)
[09:31:11] <mark_edward> yet you are major contributor to an awesome and ambitious new PL
[09:31:18] <aatch> mark_edward, it wasn't the university fees, it was the fact that two of my flatmates decided to suddenly leave
[09:31:33] <mark_edward> wow, that sucks hard.
[09:31:39] <aatch> mark_edward, I'm a self-taught programmer to start with anyway
[09:31:50] <aatch> I'm 22 and have programming for ~8 years
[09:32:14] <mark_edward> i have college to thank for my skill. i didn't really know what programming was until i did intro-tocompsci, but then i fell in love
[09:32:27] <mark_edward> wish i started earlier
[09:32:45] <mark_edward> but i didn't really have a computer  until i went to college
[09:33:18] <aatch> mark_edward, see, I was into computers from about the age of 10
[09:34:04] <mark_edward> wow. feel like i'd be a very different person if i was into computers that early.
[09:34:57] <aatch> mark_edward, but you are not that person, you are you.
[09:35:20] <aatch> I'd probably be a very difference person if my ADD was diagnosed _before_ I was 20
[09:35:20] *** Quits: Amanieu (amanieu@moz-D5D10CA8.halls.manchester.ac.uk) (Connection reset by peer)
[09:35:21] *** Joins: BizarreCake (BizarreCak@51AA6B33.6D202491.34A7550B.IP)
[09:35:27] <mark_edward> but what if me isn't as good a programmer as he could have been.
[09:35:54] <mark_edward> aatch: that's true. i know it's big deal. my fiancee was diagnosed earlier, but she still struggles with it
[09:36:00] <aatch> what if's get you nowhere
[09:36:20] *** Joins: Amanieu (amanieu@moz-D5D10CA8.halls.manchester.ac.uk)
[09:36:53] <mark_edward> they can help plan for the future, for others. my kids will learn x86 assembly before they go to primaryy school, lol
[09:37:13] <aatch> mark_edward, ok, what if's about the past.
[09:37:24] <mark_edward> yeah, you're right
[09:37:42] <mark_edward> are you mozilla employee, or community contributor?
[09:38:02] <aatch> mark_edward, contributor
[09:38:17] <aatch> woo, down to 26 type errors
[09:38:31] *** Quits: noam (noam@F6B530A7.720527A7.416762B.IP) (Ping timeout)
[09:38:36] * mark_edward opens champagne
[09:38:42] * mark_edward but not a lot
[09:38:52] *** Joins: FrozenCow (FrozenCow@moz-B2DF4929.chello.nl)
[09:39:14] *** Joins: noam (noam@F6B530A7.720527A7.416762B.IP)
[09:39:15] *** Quits: bytewise (bytewise@moz-649C630D.unitymediagroup.de) (Quit: Leaving)
[09:48:31] <roo> I would be a different person if I hadn
[09:48:44] <roo> 'nt eaten that taco bell yesterday
[09:49:39] <mark_edward> LOL
[09:49:57] *** Joins: ghrust (ghrust@AD60B2E3.6A2AE50.F3114085.IP)
[09:49:57] <ghrust> 01[13rust01] 15bors merged 06auto into 06master: 02http://git.io/KorMtw
[09:49:57] *** Parts: ghrust (ghrust@AD60B2E3.6A2AE50.F3114085.IP) ()
[09:51:16] *** Joins: Earnestly (earnest@2A2BF8F5.321FA5E6.BFD1ABFD.IP)
[09:51:37] <aatch> Woo, no more @Path
[09:52:15] <aatch> I did have to add in 4 copy expressions, but 2 of those are bad
[09:52:37] <aatch> (as in, they should need a copy)
[09:52:58] *** Joins: ghrust (ghrust@AC22872E.6A2AE50.F3114085.IP)
[09:52:58] <ghrust> 01[13rust01] 15bors pushed 0 new commits to 06auto: 02http://git.io/_HCl2g
[09:52:58] *** Parts: ghrust (ghrust@AC22872E.6A2AE50.F3114085.IP) ()
[09:53:00] *** Joins: ghrust (ghrust@1E8607E8.6A2AE50.F3114085.IP)
[09:53:00] <ghrust> 01[13rust01] 15bors pushed 6 new commits to 06auto: 02http://git.io/lX_lQA
[09:53:00] <ghrust> 13rust/06auto 14c9b9462 15Seo Sanghyeon: Remove visit_struct_method
[09:53:00] <ghrust> 13rust/06auto 142e65782 15Seo Sanghyeon: Do not rely on newtype enum dereference
[09:53:00] <ghrust> 13rust/06auto 142045889 15Seo Sanghyeon: vim: Highlight 0i as number
[09:53:02] *** Parts: ghrust (ghrust@1E8607E8.6A2AE50.F3114085.IP) ()
[09:53:18] <mark_edward> aatch: nice!
[09:55:24] *** Quits: busylizzy (lisa@85228838.12D0DC84.211374C4.IP) (Quit: No Ping reply in 180 seconds.)
[09:56:36] *** Quits: Ms2ger (Ms2ger@moz-AC84CFF6.adsl-dyn.isp.belgacom.be) (Quit: bbiab)
[09:57:07] <aatch> Bah, I hate dynamic borrows so much
[09:58:10] *** Joins: doomlord (doomlod@moz-6651F8D4.range86-145.btcentralplus.com)
[09:58:15] *** Quits: doomlord (doomlod@moz-6651F8D4.range86-145.btcentralplus.com) (Quit: doomlord)
[09:59:52] *** Joins: busylizzy (lisa@85228838.12D0DC84.211374C4.IP)
[10:03:38] *** Joins: engla (engla@moz-DBD1D96E.cust.bredbandsbolaget.se)
[10:04:19] *** Joins: bjz (brendanzab@B398BE78.F804C29E.D35A31DF.IP)
[10:04:59] *** Quits: fabiand (fabiand@moz-90C26BF4.adsl.alicedsl.de) (Quit: Verlassend)
[10:05:13] *** Joins: fabiand (fabiand@moz-90C26BF4.adsl.alicedsl.de)
[10:06:40] *** Quits: fabiand (fabiand@moz-90C26BF4.adsl.alicedsl.de) (Client exited)
[10:07:04] *** Joins: novabyte (Instantbir@moz-C2F8389B.mullvad.net)
[10:07:47] *** Joins: thomas_adam (n6tadam@moz-66E7E77B.vm.bytemark.co.uk)
[10:08:42] *** Joins: sk (sk@1696E5A5.E92B26F8.78DD174B.IP)
[10:08:54] *** Joins: q66 (q66@6EE9DE40.46454B5D.33AABD5F.IP)
[10:09:15] *** Joins: fabiand (fabiand@moz-90C26BF4.adsl.alicedsl.de)
[10:10:08] *** Joins: seth (seth@moz-D840E602.dsl.static.sonic.net)
[10:10:53] <aatch> Finally found the correct incantation to make rustc happy
[10:11:02] <aatch> Goddamn I hate @mut so much
[10:11:59] *** Quits: seth (seth@moz-D840E602.dsl.static.sonic.net) (Ping timeout)
[10:12:10] *** Quits: SimonSapin (simon@moz-D0C2F181.zone2.bethere.co.uk) (Ping timeout)
[10:14:49] *** Joins: jpochyla (jpochyla@moz-8D99AE5D.broadband18.iol.cz)
[10:16:41] <aatch> mark_edward, I'm about to head off, but here's what I have (it also has my Vec/StringRef stuff in it)
[10:16:42] <aatch> https://github.com/Aatch/rust/tree/syntax-deshare
[10:16:46] *** aatch is now known as aatch|gone
[10:16:58] <mark_edward> thanks aatch|gone! i really appreciate it
[10:18:46] *** Joins: Ms2ger (Ms2ger@moz-AC84CFF6.adsl-dyn.isp.belgacom.be)
[10:20:21] *** Quits: fabiand (fabiand@moz-90C26BF4.adsl.alicedsl.de) (Quit: Verlassend)
[10:20:24] *** Joins: fabiand (fabiand@moz-90C26BF4.adsl.alicedsl.de)
[10:20:50] *** Quits: aatch|gone (aatch@moz-B437F499.pocketrent.com) (Client exited)
[10:24:46] *** Joins: pnathan (Adium@B9840254.2CD8A5F8.477B877D.IP)
[10:28:01] *** Quits: pyrac (pyrac@F9CC429.73C89388.AD05C589.IP) (Quit: pyrac)
[10:29:01] *** Joins: pyrac (pyrac@F9CC429.73C89388.AD05C589.IP)
[10:44:27] *** Quits: snadon (chatzilla@moz-3BC727E8.mc.videotron.ca) (Ping timeout)
[10:46:16] *** Quits: pnathan (Adium@B9840254.2CD8A5F8.477B877D.IP) (Ping timeout)
[10:47:15] <gour> i'd like to build rust...what do you recommend: g++ or clang?
[10:53:31] <mark_edward> depends
[10:53:59] <mark_edward> clang has faster compile times, but generally poorer code performeance, although it's caught up to g++ a lot recently
[10:54:13] <gour> ok, let me try with clang then
[10:54:28] <mark_edward> but most of your time will be spent with the rust compiler compiling rUst code
[10:54:40] <mark_edward> so it doesn't matter too much
[10:55:05] <gour> ok...i'd like to get a feeling for rust to check whether i can count on it for the future project
[10:55:06] <mark_edward> rust compiles itself 3 times in the build process, as i learned today
[10:55:41] <gour> heh...i recall when building ghc on gentoo years ago :-)
[10:56:00] <mark_edward> it's not stable now. there are changes everyday. i have to fix pretty much any wode that's a week or more old to work with the current compiler
[10:56:08] <mark_edward> so it depends on what you want to do
[10:56:26] <mark_edward> the rust compiler is written in rust, so a big project is certainly feasible, but hard
[10:56:56] <gour> get some feeling for the language itself and try to bind some 3rd party C lib...eventually, i'm thinking about (multi-platform) gui app
[10:57:37] <gour> rust seems better than go and, somehow, i'm not so inclined for mono/fsharp
[10:58:10] <gour> ...as well as JVM stuff
[10:58:38] <mark_edward> yeah i understand
[10:58:40] <gour> so, not much is left if we eliminate C(++) :-)
[10:58:48] <mark_edward> also rust is not nearly performing as well as it can
[10:59:05] <mark_edward> since they have to write the compiler in rust, they are often held back by old problems
[10:59:29] <mark_edward> if rust was emitting optimal LLVM IR, it'd be many times faster than it is now, at C++ levels
[10:59:33] <mark_edward> but it's not there yet
[10:59:35] <gour> that's understandable now, but it will be better than if i stick with python+cython
[10:59:43] *** Joins: km (quassel@FDBAF0A0.DBF71E41.29C67456.IP)
[11:00:16] <gour> some months ago i played with nimrod - nice language, but too small dev team to invest into it
[11:01:02] *** Joins: Sorella (queen@78575561.924F2739.95C8B7C6.IP)
[11:03:20] *** Quits: km (quassel@FDBAF0A0.DBF71E41.29C67456.IP) (Ping timeout)
[11:04:03] <mark_edward> rust is definitely better performing than pthon
[11:04:11] <mark_edward> and a much nicer language in my opinion
[11:04:16] <mark_edward> i hate duck-typing
[11:04:24] <mark_edward> makes reading any large codebase near impossible
[11:04:43] <gour> heh, i also prefer static-typing
[11:04:51] <mark_edward> only clue you have to an objects function is the variable name and how it's used
[11:05:19] <mark_edward> rust also has sweet iterators
[11:05:24] <mark_edward> brand new
[11:06:27] <gour> hmm, i installed (on debian) clang, but configure still complains
[11:06:38] *** Joins: km (quassel@FDBAF0A0.DBF71E41.29C67456.IP)
[11:07:31] <gour> g++|clang++|icc required but not found
[11:07:59] *** Joins: ghrust (ghrust@AC22872E.6A2AE50.F3114085.IP)
[11:07:59] <ghrust> 01[13rust01] 15bors 04force-pushed 06auto from 1498ce2c8 to 148c50ee3: 02http://git.io/N3iJvQ
[11:07:59] *** Parts: ghrust (ghrust@AC22872E.6A2AE50.F3114085.IP) ()
[11:08:00] *** Joins: ghrust (ghrust@79968228.6A2AE50.F3114085.IP)
[11:08:00] <ghrust> 01[13rust01] 15bors pushed 3 new commits to 06auto: 02http://git.io/tvzkIA
[11:08:00] <ghrust> 13rust/06auto 14d31d8e3 15Felix S. Klock II: Refactored int/uint range code in preparation for change to range_rev semantics....
[11:08:00] <ghrust> 13rust/06auto 140b639c8 15Felix S. Klock II: Switch over to new range_rev semantics; fix #5270.
[11:08:01] <gour> i'm going to install g++
[11:08:01] <ghrust> 13rust/06auto 14ab2e729 15bors: auto merge of #7524 : pnkfelix/rust/fsk-invert-range-rev-halfclosedness-issue5270, r=cmr...
[11:08:03] *** Parts: ghrust (ghrust@79968228.6A2AE50.F3114085.IP) ()
[11:09:10] <mark_edward> theres probably an option you can pass to make, but i don't know it offhand
[11:09:55] <gour> it's happy with g++ now
[11:10:24] <mark_edward> cool
[11:10:48] <mark_edward> good luck playing around with Rust. it's a great langauge, and i love watching it grow, and talking with the developers
[11:10:53] <mark_edward> they're on IRC all the time
[11:10:59] <gour> thanks
[11:11:17] <mark_edward> and as the language gets faster, the compiler will too! since it's written in rust
[11:11:28] <gour> any estimation when it might be useful for writing apps with it?
[11:11:44] <mark_edward> you can do things in it now. depends on what you mean by apps
[11:12:09] <gour> i mea stable enough for real-world
[11:12:14] <mark_edward> there are no GUI bindings for now except SDL i think. someone is also writing some sort of game framework for it
[11:12:31] <mark_edward> something you would try and sell? i wouldn't say so
[11:12:33] <gour> sqlite bindings?
[11:12:52] * gour plans open-source only
[11:13:00] *** Joins: ChrisMorgan (chris@moz-6AC741CA.static.tpgi.com.au)
[11:13:40] <mark_edward> hmm... i dunno, 
[11:13:49] <mark_edward> you can sell open source things too
[11:14:05] <gour> that's true, but i won't
[11:14:08] <mark_edward> https://github.com/linuxfood/rustsqlite there's this. i have no idea how good it is. the dev keeps it up to date working with the latest rust
[11:14:19] <mark_edward> seeing as the last commit is 4  days ago
[11:14:58] *** Quits: james4k (james@moz-E7990244.consolidated.net) (Ping timeout)
[11:15:07] <mark_edward> it's a wrapper over the C API
[11:15:16] *** Joins: pnathan (Adium@B9840254.2CD8A5F8.477B877D.IP)
[11:15:44] <mark_edward> networking is tough right now though. the current library is and is hard to use and is up for a major rewrite, 
[11:15:54] <mark_edward> i did write this wrapper over libcurl though
[11:16:04] <mark_edward> don't know how useful it is though
[11:16:29] <mark_edward> https://github.com/MarkJr94/rust_curl?source=c
[11:16:39] *** Quits: FrozenCow (FrozenCow@moz-B2DF4929.chello.nl) (Quit: Leaving)
[11:17:31] <mark_edward> gour: here are some examples https://github.com/MarkJr94/rust_curl/blob/master/examples.rs
[11:17:52] *** Quits: pnathan (Adium@B9840254.2CD8A5F8.477B877D.IP) (Ping timeout)
[11:18:28] *** Joins: FrozenCow (FrozenCow@moz-B2DF4929.chello.nl)
[11:19:17] <gour> mark_edward: have you tried haskell/ocaml/D?
[11:19:28] <mark_edward> i've tried haskell and D
[11:19:37] <mark_edward> haven't written anything really in D
[11:19:47] <gour> you prefer rust over 'em?
[11:19:58] <mark_edward> https://github.com/MarkJr94/federalists
[11:20:01] <mark_edward> gour: definitely
[11:20:08] *** Quits: pyrac (pyrac@F9CC429.73C89388.AD05C589.IP) (Quit: pyrac)
[11:20:29] <gour> that's nice to hear
[11:20:31] <mark_edward> getting anything done in Haskell seems like such a drag once you need to do anything that isn't math/data structures, like IO
[11:20:40] *** Quits: FrozenCow (FrozenCow@moz-B2DF4929.chello.nl) (Ping timeout)
[11:20:41] <gour> :-D
[11:20:43] <mark_edward> the above link is something i wrote in haskell
[11:20:50] *** Joins: FrozenCow (FrozenCow@moz-B2DF4929.chello.nl)
[11:20:59] <gour> i never grokked monads, i confess
[11:21:35] *** Joins: maxli (maxli@B5559308.9C54E60.2FA4EA88.IP)
[11:21:44] <mark_edward> me neither, not really at least
[11:22:03] *** Joins: bugweiser (Mibbit@moz-9B117CC8.glbb.ne.jp)
[11:22:07] <mark_edward> here is the same thing in Rust: https://github.com/MarkJr94/rusty_feds
[11:22:17] <mark_edward> probably doesn't compile now, i havent checked in a few weeks
[11:22:29] <bugweiser> Are the automatically derivable traits added with compiler magic or can they be added in user-land like macros?
[11:22:36] <gour> otoh, just wonder if rust will be used for gui apps, or only for internet/cloud...
[11:22:55] *** Joins: jviereck (Adium@50FF3E25.58E250DC.172227A7.IP)
[11:23:00] *** Quits: FrozenCow (FrozenCow@moz-B2DF4929.chello.nl) (Ping timeout)
[11:23:31] <mark_edward> well, we just have to wait and see
[11:23:38] <mark_edward> there aren't any good GUI bindings yyet
[11:23:58] <mark_edward> IMO that will wait until the language hits 1.0 at the end of the year, at least
[11:24:27] <gour> i'm told that's not probable
[11:24:44] <gour> yesterday someone mentioned it here, iirc
[11:26:12] <gour> mark_edward: have you seen nimrod?
[11:26:23] <mark_edward> only a little bit.
[11:26:37] <mark_edward> gour: nothing is too probable at this stage in languae dev
[11:26:47] <mark_edward> IMO rust is a great choice for a gui binding
[11:27:03] <gour> even for C++ libs?
[11:27:09] <roo> if only most of them weren't written in c++ :(
[11:27:15] <roo> no, not so much
[11:27:29] <gour> gtk is not the greatest choice for non-linux OS
[11:28:22] <mark_edward> qt bindings would be great, but it's hard-to-impossible to do good C++ binding s in may languages, let alone a new one
[11:28:24] *** Joins: pyrac (pyrac@F9CC429.73C89388.AD05C589.IP)
[11:28:29] <mark_edward> GGTK bindings would be a good start
[11:28:58] <gour> mark_edward: python has decent qt bindings :-)
[11:28:59] *** Joins: ghrust (ghrust@9C8B94D4.6A2AE50.F3114085.IP)
[11:28:59] <ghrust> 01[13rust01] 15bors 04force-pushed 06auto from 14ab2e729 to 148c50ee3: 02http://git.io/N3iJvQ
[11:28:59] *** Parts: ghrust (ghrust@9C8B94D4.6A2AE50.F3114085.IP) ()
[11:29:32] <gour> there is eeven qtada
[11:29:32] <mark_edward> i have no idea how they pulled that off
[11:29:34] *** Quits: busylizzy (lisa@85228838.12D0DC84.211374C4.IP) (Ping timeout)
[11:29:57] <gour> pyqt uses SIP
[11:30:56] <mark_edward> SIP?
[11:31:03] *** Joins: busylizzy (lisa@85228838.12D0DC84.211374C4.IP)
[11:31:15] <ChrisMorgan> if I have `pub enum Method { Get, Post, ..., OtherMethod(~str) }`, then am trying to implement ToStr on it, but that operates on &self, and so then `match *method { OtherMethod(s) => copy s }` doesn't work; how can I get it to work?
[11:31:33] <ChrisMorgan> rusti: pub enum Method { OtherMethod(~str) } impl ToStr for Method { fn to_str(&self) -> ~str { match *self { OtherMethod(s) => copy s } } } println(OtherMethod(~"PANIC").to_str());
[11:31:35] -rusti- line longer than 150 columns, pastebinned: http://sprunge.us/fNDD
[11:31:58] <ChrisMorgan> (Highlights OtherMethod(s), and says "cannot move out of dereference of & pointer")
[11:32:07] <doener> ChrisMorgan: OtherMethod(ref s)
[11:32:15] <ChrisMorgan> Ah, thanks.
[11:32:20] <doener> ChrisMorgan: that gives you a borrowed pointer to the ~str
[11:32:25] <engla> yeah ref s  paired with copy *s
[11:32:39] *** Joins: Cromulent (Cromulent@moz-983B638D.cable.virginmedia.com)
[11:32:54] <gour> mark_edward: http://www.riverbankcomputing.com/software/sip/intro
[11:33:07] <ChrisMorgan> Thanks, the combination of those things works.
[11:33:12] <engla> ChrisMorgan: instead of printing PANIC you can use the fail!() function
[11:33:22] <ChrisMorgan> engla: "PANIC" was just an example there.
[11:33:33] <engla> hehe ok
[11:33:36] <ChrisMorgan> There ain't an HTTP method called PANIC.
[11:36:08] *** Quits: bugweiser (Mibbit@moz-9B117CC8.glbb.ne.jp) (Quit: http://www.mibbit.com ajax IRC Client)
[11:36:36] *** Joins: aatch (aatch@moz-2BB0AC01.cable.telstraclear.net)
[11:39:51] *** Quits: jviereck (Adium@50FF3E25.58E250DC.172227A7.IP) (Quit: Leaving.)
[11:40:15] <mark_edward> glib binding would be interesting
[11:41:20] *** Quits: maxli (maxli@B5559308.9C54E60.2FA4EA88.IP) (Quit: Leaving.)
[11:41:43] <roo> yeah. It would be a PITA to maintain at this point I think. I think a good TK binding wouldn't be to hard though.
[11:41:44] *** Quits: Blei (philipp@moz-650B9C6A.cust.bluewin.ch) (Quit: WeeChat 0.4.1)
[11:44:02] *** Joins: mr_evil (Mibbit@DC6A06C.E6A28E7F.9A83BB32.IP)
[11:45:18] *** Quits: mr_evil (Mibbit@DC6A06C.E6A28E7F.9A83BB32.IP) (Quit: http://www.mibbit.com ajax IRC Client)
[11:45:34] *** Joins: maxli (maxli@B5559308.9C54E60.2FA4EA88.IP)
[11:47:19] *** Quits: maxli (maxli@B5559308.9C54E60.2FA4EA88.IP) (Ping timeout)
[11:48:59] *** Joins: msingle (Thunderbir@moz-930E5D97.hr.hr.cox.net)
[11:53:03] *** Joins: boohoo (Mibbit@B3EB1324.AFB3B193.17C5DB85.IP)
[11:53:28] <boohoo> help!
[11:53:42] <boohoo> help!
[11:53:47] <boohoo> i definitely got snowed'end
[11:53:48] <mark_edward> roo: it's ambitious , but lookig at the glibmm source, doesn't look impossible
[11:53:51] <boohoo> help!!!
[11:54:01] <mark_edward> boohoo: never fear, a fellow noob is here
[11:54:16] <boohoo> can someone please help me
[11:54:20] <aatch> boohoo, care to narrow it down?
[11:54:27] <mark_edward> i might be able too...
[11:54:43] <boohoo> i realised recently that my apple id, gmail accounts, have been compromised for the last 3 years by my brothers
[11:54:57] <aatch> boohoo, we cannot help you with this.
[11:55:07] <boohoo> oh no
[11:55:20] <boohoo> https://iforgot.apple.com/iForgot/iForgot.html?app_type=ext&app_id=93&returnURL=https%3A%2F%2Fappleid.apple.com%2Fcgi-bin%2FWebObjects%2FMyAppleId.woa&language=US-ENhttps://iforgot.apple.com/iForgot/iForgot.html?app_type=ext&app_id=93&returnURL=https%3A%2F%2Fappleid.apple.com%2Fcgi-bin%2FWebObjects%2FMyAppleId.woa&language=US-ENhttps://iforgot.apple.com/iForg
[11:55:24] <boohoo> https://iforgot.apple.com/iForgot/iForgot.html?app_type=ext&app_id=93&returnURL=https%3A%2F%2Fappleid.apple.com%2Fcgi-bin%2FWebObjects%2FMyAppleId.woa&language=US-EN
[11:55:29] *** Joins: maxli (maxli@B5559308.9C54E60.2FA4EA88.IP)
[11:55:32] <boohoo> that is a fake webpage
[11:55:41] <boohoo> (the second one)
[11:55:55] <mark_edward> boohoo: i think you're in the wrong channel... why did you choose here?
[11:56:09] <boohoo> i keep getting redirected to it when i try to retrieve my original apple id
[11:56:27] <aatch> boohoo, this channel is for users and developers of the Rust programming language
[11:56:55] <mark_edward> boohoo: this is the wrong channel for you. We're not going to be of any help
[11:57:27] <boohoo> i have no idea i stumbled upon this www.mibbit.com 
[11:57:30] <aatch> we have no affiliation with Apple, and even if we did, we would not be able to help
[11:57:33] <boohoo> in control panel
[11:57:43] <boohoo> i am so sad
[11:58:09] <boohoo> can someone direct me to the appropriate channel? or should i goto the policee?
[11:58:10] <mark_edward> please, try and find the proper authorities. you should be contacting apple about this
[11:58:17] <boohoo> i can't
[11:58:20] <boohoo> ip phones
[11:58:38] <mark_edward> apple is who you should be talking to
[11:58:47] <mark_edward> they have customer service for this
[11:59:06] <boohoo> i tried can't reach them......my voip call gets rerouted
[11:59:19] <boohoo> i can't get out of voip in my home
[11:59:42] <mark_edward> we're stil of no use to you. go to other people
[11:59:51] <mark_edward> this is not what this is channel is for
[11:59:56] <boohoo> i realised my blackberry was on UMTS instead of GSM when our security dept made some error
[12:00:13] <boohoo> ok fine do could you please tell me where i should go
[12:01:22] <mark_edward> http://www.apple.com/support/appleid/
[12:02:19] <mark_edward> https://expresslane.apple.com/GetproductgroupList.action
[12:02:53] <mark_edward> please take your inquiries to the proper place, we can do nothing here. Moreover this is unrelated to the channel's purpose
[12:05:56] <mark_edward> aatch: is nmatsakis the only operator
[12:06:07] <aatch> mark_edward, at the moment? yes
[12:06:32] <mark_edward> well on some channels there are people who have the permissions to make themselves mods
[12:06:38] <mark_edward> i don't remember how it works thoug
[12:06:38] *** Quits: boohoo (Mibbit@B3EB1324.AFB3B193.17C5DB85.IP) (Quit: http://www.mibbit.com ajax IRC Client)
[12:07:01] <mark_edward> maybe we need one more for things like this. i would've kicked poor old boohoo
[12:07:25] <mark_edward> aatch: what do you think about an attempt at glib bindings?
[12:07:46] <aatch> mark_edward, it was frustrating because my troll-sense started tingling almost immediately
[12:07:52] <aatch> mark_edward, no idea.
[12:07:55] *** Quits: maxli (maxli@B5559308.9C54E60.2FA4EA88.IP) (Quit: Leaving.)
[12:08:13] <mark_edward> i looked at the source for their C++ binding, doesn't seem undoable
[12:08:28] <mark_edward> and it'd be a step towards a GTK binding!
[12:10:02] *** Quits: pyrac (pyrac@F9CC429.73C89388.AD05C589.IP) (Quit: pyrac)
[12:12:43] <engla> mark_edward: did you look at the g-i/grust link?
[12:12:54] <mark_edward> no i didn't where is it?
[12:12:58] <engla> this one https://github.com/mzabaluev/grust
[12:13:10] <engla> it was mentioned here recently
[12:13:17] <engla> it's based on g-i
[12:13:47] *** Joins: SimonSapin (simon@moz-D0C2F181.zone2.bethere.co.uk)
[12:14:28] <mark_edward> cool. i forgot about that. and it's necessary for a glib binding isn't it?
[12:15:13] <engla> not sure. g-i is their infrastructure to unify glib bindings
[12:15:45] <engla> so if it works it binds a lot of libraries.
[12:16:39] *** Joins: offline (offline@moz-1CDCC36B.dip0.t-ipconnect.de)
[12:18:06] *** Joins: korenchkin (smuxi@moz-8DE1FF0F.pools.arcor-ip.net)
[12:18:25] <mark_edward> cool, thanks fir the pointer engla!
[12:20:28] <engla> yeah just wanted to make sure you had at least seen it
[12:23:55] <dbaupp> cmr: ping
[12:26:11] *** Joins: MaikKlein (maik@moz-DD7D2879.dip0.t-ipconnect.de)
[12:29:26] <korenchkin> Is there any additional information on how to write library documentation?
[12:29:26] <korenchkin> So far I found this https://github.com/mozilla/rust/wiki/Note-style-guide#comments and this https://github.com/mozilla/rust/wiki/Doc-using-rustdoc#recommended-conventions-for-rustdocs
[12:29:30] <aatch> @Lifetime has almost bit the dust.
[12:30:01] <aatch> korenchkin, don't hold too much to the second one, rustdoc is being re-written
[12:30:07] <bstrie> korenchkin: it's all up in the air right now
[12:30:31] <bstrie> do whatever you feel like. poorly styled docs are still better than no docs
[12:30:58] <korenchkin> bstrie: i can do that ;)
[12:31:02] *** Quits: SirSkidmore (taylor@A8CF1C90.14855463.8C3A19BB.IP) (Quit: WeeChat 0.4.0)
[12:31:06] <doener> dbaupp: hey, passes can be shown now! awesome! Though it's a pity that firefox can't zoom in on svgs, the short passes are just a mess of text :-D
[12:33:03] <aatch> I wonder if I can _actually_ get the AST sendable.
[12:33:14] <aatch> It's actually looking pretty promising.
[12:33:36] *** Quits: MaikKlein (maik@moz-DD7D2879.dip0.t-ipconnect.de) (Client exited)
[12:34:14] *** Joins: MaikKlein (maik@moz-DD7D2879.dip0.t-ipconnect.de)
[12:34:42] *** Joins: pyrac (pyrac@F9CC429.73C89388.AD05C589.IP)
[12:35:22] <bstrie> doener: that's a feature, firefox wants to keep you from bothering with optimizing with any pass that's too small to even read
[12:37:11] <doener> ah, cross-project cooperation at Mozilla, smart
[12:37:52] <kimundi> aatch: nice :)
[12:40:10] <aatch> grr, infinite struct size.
[12:40:57] *** Joins: mr_fribble (Mibbit@F844C947.4D267D1B.4D55033E.IP)
[12:41:03] *** Parts: mr_fribble (Mibbit@F844C947.4D267D1B.4D55033E.IP) ()
[12:41:11] <aatch> AST representation of types is a recursive type
[12:41:20] <aatch> Also, 114 type errors
[12:44:14] <dbaupp> doener: thanks :)
[12:44:38] <dbaupp> doener: planning to make the time axis zoomable, which should separate them out
[12:44:49] <dbaupp> (also, what bstrie said :P )
[12:49:20] *** Joins: bytewise (bytewise@moz-649C630D.unitymediagroup.de)
[12:50:34] <aatch> 63
[12:53:59] *** Quits: offline (offline@moz-1CDCC36B.dip0.t-ipconnect.de) (Quit: oO0∞)
[12:54:17] <aatch> 37
[12:55:16] * doener has just 1 problem
[12:55:17] <doener> leaked memory in rust main loop (1 objects)
[12:55:31] <aatch> doener, ugh
[12:56:32] *** Quits: Cromulent (Cromulent@moz-983B638D.cable.virginmedia.com) (Quit: KVIrc 4.2.0 Equilibrium http://www.kvirc.net/)
[12:56:38] *** Joins: Cromulent (Cromulent@moz-983B638D.cable.virginmedia.com)
[12:57:04] <doener> and I have absolutely no idea why
[12:57:19] <cmr> dbaupp: pong
[12:57:33] <doener> though I thought the same about the previous bug (block already terminated), which took me the better part of two days to figure out
[12:57:34] <mark_edward> i have the weirdest problem
[12:57:44] <dbaupp> cmr: b055a10662ecc77db518cb1dc3561a8bde67c47c seems to appear twice http://hnn.mrsd.org/~cmr/history.txt
[12:58:09] *** Quits: int3_ (int3_@moz-ABE52D50.hsd1.ca.comcast.net) (Client exited)
[12:58:18] <mark_edward> when i do ` make check-stage1-extra` it doesn't seem to be picking up changes i made
[12:58:22] <cmr> dbaupp: fixed
[12:58:59] <dbaupp> cmr: (also, I haven't noticed anything new for hours?)
[12:59:16] <dbaupp> mark_edward: have you saved the file?
[12:59:23] <mark_edward> yup. a lot
[12:59:27] <dbaupp> heh
[12:59:33] <doener> mark_edward: what kind of changes?
[12:59:41] <cmr> dbaupp: yeah, it's not automated yet, unfortunately...
[12:59:50] <dbaupp> cmr: oh, right
[12:59:54] <cmr> and it doesn't help when I run the same one twice ;p
[12:59:56] <mark_edward> dbaupp:  im trying to fix a failing test on my iterators, but it didn't seem to be working
[13:00:05] <mark_edward> on a whim, i inserted a print statement
[13:00:20] <mark_edward> and i've changed it several times since then
[13:00:37] <dbaupp> cmr: (you could make a file with a list of hashes and run it on that, right?)
[13:00:38] <mark_edward> but i must've run that make command 10 times now, and it keeps printing the same thing
[13:00:46] <doener> mark_edward: IIRC output of tests goes into a log, not sure if what make shows you is the raw output
[13:01:24] <engla> mark_edward: you can build the test runner manually with rustc --test extra.rs
[13:01:38] <cmr> dbaupp: yes, but LLVM rebuilds cause it to fail, and I don't know why yet.
[13:01:39] <engla> then   ./extra keyword   to only run tests that match that keyword
[13:01:46] <cmr> make returns non-0 and doesn't build everything
[13:02:04] <dbaupp> cmr: oh :(
[13:02:47] <mark_edward> engla: doesn't work. i get tons of errors (not from my changes)
[13:03:27] *** Joins: pnathan (Adium@moz-E3C3FAF2.hfc.comcastbusiness.net)
[13:03:29] <aatch> Aw... 39
[13:03:47] <engla> mark_edward: it probably requires the installed rustc to be up to date.
[13:03:57] <mark_edward> by rustc was built 5am this morning
[13:04:02] <engla> ok then
[13:04:12] <cmr> mark_edward: you need to pass --cfg stage1
[13:04:18] <mark_edward> ah i see
[13:04:19] <cmr> Or anything that isn't nothing or stage0 :p
[13:04:26] *** Quits: jpochyla (jpochyla@moz-8D99AE5D.broadband18.iol.cz) (Ping timeout)
[13:04:33] <cmr> mark_edward: use make VERBOSE=1 and copy the line it spits out for libextra for best results.
[13:05:00] <engla> don't know why it works here
[13:05:19] *** Joins: FrozenCow (FrozenCow@moz-B2DF4929.chello.nl)
[13:05:39] <mark_edward> `rustc extra.rs --test --cfg stage1` gives me 52 erros
[13:06:12] <cmr> what are they?
[13:06:33] <mark_edward> all sorts of things. mostly unresloved names
[13:06:42] <dbaupp> mark_edward: your system rustc is probably too old
[13:06:46] <engla> is the installed rustc the recent one?
[13:06:56] <engla> rustc --version
[13:06:59] <dbaupp> mark_edward: you can use one of the stages you've build previously
[13:07:01] <mark_edward> rustc 0.7 (e89dcb8 2013-07-04 19:01:54 -0700)
[13:07:25] *** Joins: donri (dag@moz-9BB61102.tbcn.telia.com)
[13:07:43] <dbaupp> mark_edward: `<RUST_DIR>/x86_64-unknown-linux-gnu/stage2/bin/rustc ...` might work
[13:07:45] *** Joins: ghrust (ghrust@5FEF1C87.6A2AE50.F3114085.IP)
[13:07:45] <ghrust> 01[13rust01] 15bors merged 06auto into 06master: 02http://git.io/CPyPCg
[13:07:45] *** Parts: ghrust (ghrust@5FEF1C87.6A2AE50.F3114085.IP) ()
[13:07:54] <mark_edward> ok
[13:08:19] <mark_edward> dbaupp: that worked!
[13:09:15] *** Joins: doomlord (doomlod@moz-6651F8D4.range86-145.btcentralplus.com)
[13:09:21] *** Quits: doomlord (doomlod@moz-6651F8D4.range86-145.btcentralplus.com) (Client exited)
[13:09:28] *** Quits: pnathan (Adium@moz-E3C3FAF2.hfc.comcastbusiness.net) (Ping timeout)
[13:09:51] <ChrisMorgan> Eek! I've only been using Rust for a couple of days and my Python code is already sprouting semicolons again!
[13:09:57] <bstrie> every time bors successfully merges into master, we sacrifice a chicken to the pagan god of integration
[13:10:11] <aatch> Ahh! 80
[13:10:17] <bstrie> ChrisMorgan: writing javascript nowadays is impossible because I keep forgetting the parens on all my if statements :(
[13:10:33] <ChrisMorgan> Yeah, I never understood why C put parens there.
[13:10:41] <ChrisMorgan> ... or why most everyone copied it.
[13:10:43] <bstrie> ChrisMorgan: so you could get rid of the brances!
[13:10:46] <bstrie> *braces
[13:10:52] *** Quits: igl (igl@moz-275D3E76.adsl.alicedsl.de) (Ping timeout)
[13:10:55] *** Joins: ghrust (ghrust@2EE61FCC.6A2AE50.F3114085.IP)
[13:10:55] <ghrust> 01[13rust01] 15bors pushed 0 new commits to 06auto: 02http://git.io/mJB-WA
[13:10:55] *** Parts: ghrust (ghrust@2EE61FCC.6A2AE50.F3114085.IP) ()
[13:10:55] *** Joins: ghrust (ghrust@5FEF1C87.6A2AE50.F3114085.IP)
[13:10:55] <ghrust> 01[13rust01] 15bors pushed 2 new commits to 06auto: 02http://git.io/wLuwAw
[13:10:55] <ghrust> 13rust/06auto 14866a5b1 15Michael Woerister: Added support for struct-like enum variants in middle::ty::enum_variants().
[13:10:55] <ghrust> 13rust/06auto 1491caf17 15bors: auto merge of #7557 : michaelwoerister/rust/enum_structs, r=pcwalton...
[13:10:56] *** Parts: ghrust (ghrust@5FEF1C87.6A2AE50.F3114085.IP) ()
[13:10:58] *** Joins: igl (igl@moz-B2AC20A9.adsl.alicedsl.de)
[13:11:06] <cmr> aatch: what are you counting? error messages?
[13:11:21] <aatch> cmr, yes
[13:11:30] <cmr> aatch: de-@ing?
[13:11:34] <aatch> cmr, yes
[13:11:37] <cmr> good luck
[13:11:52] <dbaupp> bstrie: every `if` in IRSY caught me out for exactly that reason :/
[13:12:01] * dbaupp prefers writing Rust
[13:12:11] <aatch> I have successfully de-@ed 3 Types so far
[13:12:34] <bstrie> dbaupp: IRSY?
[13:12:38] <dbaupp> aatch: it's really fun how the compiler exists really early, and so you think you're done, but a huge bunch of errors pops up
[13:12:44] <dbaupp> bstrie: is rust slim yet
[13:12:46] <bstrie> dbaupp: ah, you mean the javascript bits
[13:12:50] <dbaupp> bstrie: right
[13:12:54] <bstrie> thought this was some obscure language
[13:12:58] <dbaupp> bstrie: heh
[13:13:15] <bstrie> INTERMEDAITE REPORT SYSTEMS YEERK
[13:13:28] <bstrie> the misspellings are codified by the standard
[13:13:36] <mark_edward> this odd... so my new print statement is showing up... *along with* the old...
[13:14:02] <aatch> cmr, I'm doing it in a way where I can stop if I want and submit a PR that gets some of the work done
[13:14:03] *** Joins: seth (seth@A01051A9.6F669779.3D1CA460.IP)
[13:14:11] <aatch> rather than trying to do it all at once.
[13:15:47] <cmr> bstrie: I never know how to spell referer anymore
[13:15:54] <ChrisMorgan> What's `//!`?
[13:16:00] <cmr> ChrisMorgan: Doc comment
[13:16:09] <cmr> Applies to the *parent* item, rather than the following item
[13:16:13] <ChrisMorgan> cmr: ain't that `///`?
[13:16:33] <ChrisMorgan> cmr: http://static.rust-lang.org/doc/rust.html#comments
[13:16:36] <cmr> so like putting it in a mod attaches the doc string to the mod, rather than whatever follows it
[13:16:49] *** Joins: gour_ (gour@moz-2DE8C055.adsl.net.t-com.hr)
[13:16:57] *** Quits: gour (gour@moz-F4263343.adsl.net.t-com.hr) (Ping timeout)
[13:17:04] <ChrisMorgan> ... but no mention of it in rust.md there.
[13:17:15] <cmr> nope
[13:17:19] <cmr> nobody ever updates the manual
[13:17:20] <ChrisMorgan> So //! applies to what it's inside, while /// applies to what comes next?
[13:17:26] <cmr> yes
[13:17:28] <ChrisMorgan> ARGH! (:-()
[13:17:37] <cmr> just like the difference between #[foo] and #[foo];
[13:17:40] <bstrie> ChrisMorgan: our doc comments are awful. we all want to nuke them with bobms
[13:17:44] <bstrie> bombas
[13:18:08] <bstrie> it's just one of those low-priority things that nobody can agree on how to replace
[13:18:10] <mark_edward> Tsar Bombas
[13:18:17] <engla> can't we just say //! is for module descriptions?
[13:18:25] <bstrie> we can say a lot of things
[13:18:34] <ChrisMorgan> And why exactly is the GitHub Wiki used? It's lousy, always has been.
[13:18:48] <cmr> ChrisMorgan: because using something else would require hosting it somewhere
[13:19:02] <engla> at least it doesn't have a spam problem
[13:19:04] <ChrisMorgan> ... what exactly is static.rust-lang.org?
[13:19:12] <cmr> ChrisMorgan: amazon s3
[13:19:13] <bstrie> ChrisMorgan: we use the wiki just for a few things. docs should be in-tree, and RFCs should be in the bug tracker
[13:19:34] <cmr> Only some of the mozilla people have access to s3
[13:19:39] <cmr> but everyone can edit the wiki
[13:20:26] *** Joins: jviereck (Adium@moz-FC72D7C5.pool.mediaways.net)
[13:22:40] *** Joins: jpochyla (jpochyla@moz-8D99AE5D.broadband18.iol.cz)
[13:23:56] <aatch> ok, now I'll get like 200 errors
[13:24:29] *** Quits: korenchkin (smuxi@moz-8DE1FF0F.pools.arcor-ip.net) (Ping timeout)
[13:28:32] *** Quits: jaen (jaen@moz-E0979827.copit.pl) (Ping timeout)
[13:28:48] <bstrie> aatch: I think you're going in the wrong direction
[13:28:53] <cmr> nope
[13:28:58] <cmr> gotta get worse before it gets better
[13:29:14] <aatch> bstrie, I hit an issue where I need to change quite a lot at once.
[13:29:17] <bstrie> cmr: so what you're saying is, if it ever gets better it means that we're doing it wrong
[13:29:22] <mark_edward> dbaupp: i can't figure it out... the print statement is gone, i deleted my build directory, and still that original print statement is showing up..
[13:29:23] <cmr> bstrie: yup
[13:31:10] *** Joins: smvv_ (sander@moz-BAEA8EB2.dynamic.upc.nl)
[13:33:27] *** Joins: cowboyd (cowboyd@moz-1BD02A1E.sw.biz.rr.com)
[13:33:33] *** Joins: mib_0dtkis (Mibbit@moz-9B8221B3.rivrw1.nsw.optusnet.com.au)
[13:33:39] <mib_0dtkis> hi
[13:34:00] <mib_0dtkis> if I have a struct, and one member is a function, how do I call that function?
[13:34:11] <cmr> mib_0dtkis: (s.foo)()
[13:34:15] <aatch> mib_0dtkis, (foo.field)()
[13:34:18] <smvv_> Hi I've a question regarding initialising fixed-length vectors with elements of type enum { None, struct1, struct2 }. I'm using rust version 0.7. https://gist.github.com/smvv/5934520 What would be the right approach to solve the "copying a value of non-copyable type [...]"? I tried solving it with "impl Clone for ..." but I'm not sure that's the right direction
[13:34:20] *** Quits: KindOne (KindOne@7D0DB6F0.E114B4AE.EC6A1518.IP) (Ping timeout)
[13:34:23] <cmr> mib_0dtkis: needed to disambiguate method call
[13:34:50] <mib_0dtkis> awesome, that works
[13:34:51] <bstrie> mib_0dtkis: rust parses `foo.bar()` as a method call, always
[13:34:52] <mib_0dtkis> thanks!
[13:35:55] <aatch> smvv_, you can only use the [T,..n] syntax with implicitly-copyable types
[13:36:29] <aatch> so if the type contains any pointers, it won't work
[13:37:11] <smvv_> ok. The problem is that if i remove the pointer to BTree in the enum, i get:
[13:37:15] <smvv_> error: illegal recursive enum type; wrap the inner value in a box to make it representable
[13:37:46] <mark_edward> rusti: struct A { foo: &fn(int) -> int}  let a = A {foo: |x| x * x}; a.foo(50)
[13:37:47] -rusti- <anon>:7:25: 7:40 error: Illegal anonymous lifetime: anonymous lifetimes are not permitted here
[13:37:47] -rusti- <anon>:7          struct A { foo: &fn(int) -> int}  let a = A {foo: |x| x * x}; a.foo(50)
[13:37:47] -rusti-                                   ^~~~~~~~~~~~~~~
[13:37:47] -rusti- error: aborting due to previous error
[13:37:48] -rusti- application terminated with error code 101
[13:37:57] <mark_edward> rusti: struct A { foo: ~fn(int) -> int} let a = A {foo: |x| x * x}; a.foo(50)
[13:37:58] -rusti- <anon>:7:70: 8:5 error: type `main::A` does not implement any method in scope named `foo`
[13:37:58] -rusti- <anon>:7          struct A { foo: ~fn(int) -> int} let a = A {foo: |x| x * x}; a.foo(50)
[13:37:58] -rusti- <anon>:8     };
[13:37:58] -rusti- error: aborting due to previous error
[13:37:59] -rusti- application terminated with error code 101
[13:38:07] <mark_edward> rusti: struct A { foo: ~fn(int) -> int} let a = A {foo: |x| x * x}; (a.foo)(50)
[13:38:08] -rusti- 2500
[13:38:45] <aatch> smvv_, you have to construct it a different way
[13:39:02] <mark_edward> why doesn't rusti need everything to be encodable, but rusti on my machine does?
[13:39:03] <aatch> mark_edward, it's because a method call is it's own syntax
[13:39:03] <bstrie> smvv_: can you use vec::from_fn(BTreeDegree, |_| None) ? though this will make a ~[] rather than a [], so you'd have to change your struct definition
[13:39:22] <mark_edward> aatch: i see that
[13:39:31] <cmr> mark_edward: rusti-the-bot is a wrapper over rustc
[13:39:41] <mark_edward> oh i see.
[13:39:41] <cmr> mark_edward: rusti-the-program is like 70% broken
[13:39:49] <mark_edward> :-(
[13:39:57] *** Quits: MaikKlein (maik@moz-DD7D2879.dip0.t-ipconnect.de) (Ping timeout)
[13:40:20] <aatch> mark_edward, hey it's an improvement on the 99% broken from a couple months ago
[13:40:28] <cmr> or the 100% broken!
[13:40:30] <mark_edward> that's a silver lining!
[13:40:59] <bstrie> smvv_: this is actually a bug https://github.com/mozilla/rust/issues/5244
[13:42:39] *** Joins: TylerE (TylerE@30EB7FA0.D733EB4E.5E8712DE.IP)
[13:43:24] <TylerE> Are there any other tutorials? The "official" one seems to have lots of missing content (For instance, it says at one point that for loops will be explained in the next section, and then completely ignores them hereafter)
[13:43:43] <TylerE> pragmatic library doc would be good too... how to read command line arguments, dealing with files, that sort of thign
[13:43:50] *** Joins: korenchkin (smuxi@moz-8DE1FF0F.pools.arcor-ip.net)
[13:43:55] <smvv_> bstrie: ty for the issue number. i'll watch the thread
[13:43:55] *** Quits: korenchkin (smuxi@moz-8DE1FF0F.pools.arcor-ip.net) (Client exited)
[13:43:55] <cmr> TylerE: http://www.rustforrubyists.com/book/index.html is the only other real documentation
[13:44:08] <cmr> TylerE: it's not updated for 0.7 yet though (I'm about half done the upgrade)
[13:44:29] <bstrie> TylerE: anything to do with i/o will be terrible right now. our io library is badbad
[13:44:29] <cmr> TylerE: Documentation is severely lacking though, yes
[13:44:41] <TylerE> ok, fair enough
[13:44:44] <bstrie> it's not even worth documenting, because nobody should be using it
[13:44:56] <bstrie> who even needs io?? rust programs are totally capable of warming your house
[13:45:01] <mib_0dtkis> btw, is there a reason that vec has .rposition, but not .position?
[13:45:04] <roo> lol
[13:45:16] <bstrie> what is .rposition?
[13:45:16] <cmr> mib_0dtkis: just hasn't been replaced yet.
[13:45:21] <aatch> mib_0dtkis, because it shouldn't have rposition
[13:45:58] <cmr> And by replaced I mean removed
[13:46:12] <bstrie> mib_0dtkis: basically, any question of the form "is there a reason for this stupid and terrible thing" is "no, sorry, we're working on it" :)
[13:46:21] <mib_0dtkis> oh, so how are we doing it these days?
[13:46:59] <aatch> mib_0dtkis, iterators, but implementing rposition properly with iterators proved challenging
[13:47:16] <mib_0dtkis> I actually just want to find the first instance that matches a predicate
[13:47:31] <cmr> v.iter().position_(|x| cond), then
[13:47:44] <cmr> although find_ also does it
[13:47:46] <mib_0dtkis> ok, I was scared off by the underscore
[13:47:48] <cmr> position_ returns the index
[13:47:55] <cmr> the underscore is to work around a method resolution bug
[13:48:08] <bstrie> mib_0dtkis: sorry, we're working on it :P
[13:48:13] <mib_0dtkis> okay, cool
[13:48:17] <mib_0dtkis> thanks :-D
[13:48:45] <engla> you can use iter().find_(..) for the elt
[13:50:17] *** Joins: Jesin (Jessin_@moz-3AD6F09F.res.lehigh.edu)
[13:52:27] *** Quits: sankha93 (Instantbir@9276287F.8CAC2DA9.D2D1FAF0.IP) (Quit: Instantbird 1.4 -- http://www.instantbird.com)
[13:54:41] *** kimundi is now known as zz_kimundi
[13:54:50] *** Quits: jviereck (Adium@moz-FC72D7C5.pool.mediaways.net) (Quit: Leaving.)
[13:54:51] <aatch> I have a function that takes a slice of borrowed pointers and returns a slice that lasts for as long that pointers in the slice.
[13:54:55] <aatch> uh
[13:57:20] <aatch> heh, items.iter().collect()
[13:57:59] *** Quits: seth (seth@A01051A9.6F669779.3D1CA460.IP) (No route to host)
[13:58:06] *** Joins: MaikKlein (maik@moz-DD7D2879.dip0.t-ipconnect.de)
[13:58:07] <aatch> rusti: let xs = ~[1,2,3]; fmt!("%?", xs.iter().collect::<~[&int]>())
[13:58:08] -rusti- ~"~[&1, &2, &3]"
[13:59:07] *** Joins: seth (seth@A01051A9.6F669779.3D1CA460.IP)
[13:59:19] <Yurume> angolmois.rs:6000:62: 6000:68 note: `atexit` moved here because it has type `&fn<no-bounds>()`, which is moved by default (use `copy` to override)
[13:59:20] <Yurume> hmm...
[13:59:36] <Yurume> is the function bounds syntax available in 0.7?
[13:59:41] <bstrie> ...maybe??
[13:59:48] <cmr> I think so
[13:59:49] <aatch> Yurume, I think so
[13:59:52] <bstrie> couldn't hurt to try
[13:59:59] <bstrie> &fn:Copy()
[14:00:28] <Yurume> oh, it parses
[14:00:29] <bstrie> rusti: fn foo(f: &fn:Copy()) {}
[14:00:31] -rusti- <anon>:7:16: 7:17 warning: unused variable: `f` [-W unused-variable (default)]
[14:00:31] -rusti- <anon>:7          fn foo(f: &fn:Copy()) {}
[14:00:31] -rusti-                          ^
[14:00:31] -rusti- ()
[14:00:43] <Yurume> so it is missing only in the documentation right?
[14:00:44] *** Joins: obi_wan (Mibbit@BFB8A642.16F8E39D.AE26B834.IP)
[14:00:55] *** Quits: obi_wan (Mibbit@BFB8A642.16F8E39D.AE26B834.IP) (Quit: http://www.mibbit.com ajax IRC Client)
[14:01:01] *** Joins: cubic (cubic@moz-FE5AD6C7.mc.videotron.ca)
[14:01:13] <MaikKlein> rusti: fn foo(f: &fn:Copy + Send()) {}
[14:01:14] -rusti- <anon>:7:16: 7:17 warning: unused variable: `f` [-W unused-variable (default)]
[14:01:14] -rusti- <anon>:7          fn foo(f: &fn:Copy + Send()) {}
[14:01:14] -rusti-                          ^
[14:01:15] -rusti- ()
[14:01:45] *** Joins: Guest_ (textual@moz-A3295542.nycmny.fios.verizon.net)
[14:02:48] <roo> but what does it mean?
[14:03:12] <MaikKlein> can I implement traits for functions?
[14:03:22] <cmr> MaikKlein: yes actually
[14:04:23] <Yurume> function bounds specify the lifetime and characteristics of environments associated to the function
[14:04:40] <roo> hmm, cool
[14:04:41] <Yurume> so &fn:Copy(), for example, means that the environment is copyable
[14:04:53] <Yurume> anyway
[14:05:18] <bstrie> rusti: trait Foo { fn foo(&self); } impl Foo for &fn() { fn foo(&self) { println("hello"); } } let bar = || { 1 }; bar.foo();
[14:05:19] -rusti- <anon>:7:51: 7:56 error: Illegal anonymous lifetime: anonymous lifetimes are not permitted here
[14:05:19] -rusti- <anon>:7          trait Foo { fn foo(&self); } impl Foo for &fn() { fn foo(&self) { println("hello"); } } let bar = || { 1 }; bar.foo();
[14:05:19] -rusti-                                                             ^~~~~
[14:05:19] -rusti- error: aborting due to previous error
[14:05:20] -rusti- application terminated with error code 101
[14:05:20] <Yurume> an explicit type specification works, but then it fails to coerce &fn<no-bounds>() to &fn:Copy()
[14:06:22] <MaikKlein> rusti; fn rust_foo(i: i32)-> i32 {return i;} trait Test{} impl Test for rust_foo;
[14:06:22] *** Quits: mib_0dtkis (Mibbit@moz-9B8221B3.rivrw1.nsw.optusnet.com.au) (Quit: http://www.mibbit.com ajax IRC Client)
[14:06:31] <MaikKlein> rusti: fn rust_foo(i: i32)-> i32 {return i;} trait Test{} impl Test for rust_foo;
[14:06:32] -rusti- <anon>:7:74: 7:82 error: use of undeclared type name `rust_foo`
[14:06:32] -rusti- <anon>:7          fn rust_foo(i: i32)-> i32 {return i;} trait Test{} impl Test for rust_foo;
[14:06:32] -rusti-                                                                                    ^~~~~~~~
[14:06:32] -rusti- error: aborting due to previous error
[14:06:32] -rusti- application terminated with error code 101
[14:07:02] <Yurume> rusti: fn foo(i:int) { println(fmt!("foo(%d)", i)); } fn bar(f:&fn()) { f(); f(); } let baz = || { foo(42); }; bar(baz);
[14:07:03] -rusti- foo(42)
[14:07:03] -rusti- foo(42)
[14:07:03] -rusti- ()
[14:07:09] <bstrie> MaikKlein: rust_foo isn't its own type there, you have to impl on &fn
[14:07:26] <bstrie> just like when I say `let bar = 2;`, bar isn't its own type
[14:07:52] <mark_edward> rusti: trait Foo { fn foo<'r>(&'r self); } impl<'r> Foo for &'r fn() { fn foo(&'r self) { println("hello"); } } let bar = || { 1 }; bar.foo();
[14:07:54] -rusti- more than 5 lines of output, pastebinned: http://sprunge.us/cRDL
[14:07:57] <aatch> cmr, btw I've managed to drop `@` from @view_items, @Path and @Lifetime
[14:08:15] <cmr> good!
[14:08:24] <cmr> what are you fighting with now?
[14:08:30] *** Joins: int3_ (int3_@moz-ABE52D50.hsd1.ca.comcast.net)
[14:08:46] <MaikKlein> bstrie, ah thanks that makes more sense
[14:08:47] <aatch> I've just given up on @Ty for the night
[14:08:52] <aatch> (tis 2am here)
[14:08:53] *** Joins: jfbk (user@moz-EEA9CFB3.nyc.res.rr.com)
[14:08:55] <cmr> Oh Ty
[14:08:57] <MaikKlein> bstrie, so can functions have methods?
[14:09:02] <cmr> Yeah that one is pervasive :\
[14:09:02] <bstrie> MaikKlein: yes
[14:09:11] <bstrie> MaikKlein: at least, I've done it in the past. it isn't a very common thing
[14:09:15] <engla> aatch: sounds good. how many @types are there in syntax?
[14:09:22] <MaikKlein> this sounds really weird :D
[14:09:22] <aatch> cmr, this biggest issue is the pretty-printer
[14:09:25] <aatch> engla, too many
[14:09:28] <MaikKlein> gonna try it now
[14:09:32] <bstrie> aatch: throw away the pretty printer
[14:09:35] <cmr> engla: basically everything is a @foo
[14:09:40] <cmr> (in syntax)
[14:09:40] <engla> yeah
[14:09:45] <bstrie> aatch: graydon has said that it just needs to be rewritten, don't waste effort on it
[14:09:47] <engla> are there @Trait objects too?
[14:10:02] <cmr> No, there are few if any traits
[14:10:08] <aatch> bstrie, I'm not really trying to improve it, just keep things compiling.
[14:10:21] *** Quits: int3_ (int3_@moz-ABE52D50.hsd1.ca.comcast.net) (Ping timeout)
[14:11:40] <aatch> engla, the stupid thing about all the @Ts in the AST is that it's an AST!
[14:11:51] <aatch> Why do trees need shared pointers!
[14:11:59] <bstrie> abstract syntax graph
[14:12:01] <cmr> aatch: it's not actually a tree, though
[14:12:07] <cmr> see: ast_map
[14:12:36] <cmr> I think the ast needs rewriting
[14:12:44] <aatch> cmr, the actual AST is still a tree
[14:12:50] <aatch> the map is just augmentation
[14:13:02] <MaikKlein> is the new_visitor already in the master?
[14:13:05] <cmr> MaikKlein: no
[14:13:12] <mark_edward> rusti: trait Foo { fn foo<'r>(&'r self); } impl<'self> Foo for &'self fn() { fn foo(&'self self) { println("hello"); } } let bar = || { 1 }; bar.foo();
[14:13:13] -rusti- more than 5 lines of output, pastebinned: http://sprunge.us/eTcg
[14:13:45] *** zz_kimundi is now known as kimundi
[14:13:47] <cmr> mark_edward: needs to be fn foo<'r>(&'r self)
[14:13:56] <cmr> that's a very poor error message though
[14:13:57] <mark_edward> rusti: trait Foo { fn foo<'r>(&'r self); } impl<'self> Foo for &'self fn() { fn foo<'self>(&'self self) { println("hello"); } } let bar = || { 1 }; bar.foo();
[14:13:58] -rusti- more than 5 lines of output, pastebinned: http://sprunge.us/PEXA
[14:14:24] <mark_edward> hm...
[14:14:32] <engla> aatch: if it's a persistent data structure maybe
[14:14:35] *** Quits: smvv_ (sander@moz-BAEA8EB2.dynamic.upc.nl) (Quit: leaving)
[14:15:26] *** gour_ is now known as gour
[14:15:27] <aatch> engla, what do you mean by persistent?
[14:15:42] <cmr> dbaupp: almost caught up with bors
[14:16:33] <engla> aatch: different trees can share common parts
[14:16:47] <engla> haskellish manipulation of datastructures
[14:17:07] *** Quits: pyrac (pyrac@F9CC429.73C89388.AD05C589.IP) (Quit: pyrac)
[14:17:08] <aatch> engla, for a general tree, maybe, but not an AST
[14:17:22] <cmr> Actually I think syntax exploits that
[14:17:31] <cmr> it keeps a separate tree around for every macro expansion
[14:19:05] <aatch> cmr, I don't think so
[14:20:45] <cmr> I remember reading a comment to that effect
[14:20:53] <cmr> But we all know how accurate the comments are...
[14:21:21] *** Quits: acrichto (acrichto@moz-B63D64BD.res.cmu.edu) (Connection reset by peer)
[14:22:31] *** Quits: Cromulent (Cromulent@moz-983B638D.cable.virginmedia.com) (Quit: KVIrc 4.2.0 Equilibrium http://www.kvirc.net/)
[14:22:41] *** Quits: mjrosenb (mjrosenb@moz-B3592BDA.club.cc.cmu.edu) (Ping timeout)
[14:22:41] *** Quits: rpearl (rpearl@moz-2B41ACB5.andrew.cmu.edu) (Ping timeout)
[14:22:59] *** Quits: rntz (rntz@moz-C76A8D96.sp.cs.cmu.edu) (Ping timeout)
[14:23:31] <aatch> I can't see anything that suggests that in my reading here.
[14:23:42] *** Joins: jedestep (jedestep@34641662.FB4DE631.66C78B76.IP)
[14:23:51] *** Joins: jviereck (Adium@moz-FC72D7C5.pool.mediaways.net)
[14:24:04] *** Quits: jviereck (Adium@moz-FC72D7C5.pool.mediaways.net) (Client exited)
[14:24:22] *** Quits: jedestep (jedestep@34641662.FB4DE631.66C78B76.IP) (Quit: leaving)
[14:24:25] *** Joins: jedestep (jedestep@34641662.FB4DE631.66C78B76.IP)
[14:24:40] *** Joins: maxli (maxli@B5559308.9C54E60.2FA4EA88.IP)
[14:24:58] *** Quits: bblum (bblum@moz-2B41ACB5.andrew.cmu.edu) (Ping timeout)
[14:25:55] *** Joins: ghrust (ghrust@AD60B2E3.6A2AE50.F3114085.IP)
[14:25:55] <ghrust> 01[13rust01] 15bors 04force-pushed 06auto from 1491caf17 to 1458eb70a: 02http://git.io/N3iJvQ
[14:25:55] *** Parts: ghrust (ghrust@AD60B2E3.6A2AE50.F3114085.IP) ()
[14:25:58] *** Joins: ghrust (ghrust@1E8607E8.6A2AE50.F3114085.IP)
[14:25:58] <ghrust> 01[13rust01] 15bors pushed 5 new commits to 06auto: 02http://git.io/8KtwgA
[14:25:58] <ghrust> 13rust/06auto 14fb689d1 15blake2-ppc: deque: Fix grow condition in add_front...
[14:25:58] <ghrust> 13rust/06auto 14237574b 15blake2-ppc: deque: Add tests and bench tests...
[14:25:58] <ghrust> 13rust/06auto 14d7dec5d 15blake2-ppc: deque: Speed up deque growth by a lot...
[14:26:00] *** Parts: ghrust (ghrust@1E8607E8.6A2AE50.F3114085.IP) ()
[14:26:01] *** Quits: seth (seth@A01051A9.6F669779.3D1CA460.IP) (Input/output error)
[14:27:35] *** Joins: acrichto (acrichto@moz-B63D64BD.res.cmu.edu)
[14:27:47] *** Quits: Guest_ (textual@moz-A3295542.nycmny.fios.verizon.net) (Ping timeout)
[14:28:34] *** Quits: jpochyla (jpochyla@moz-8D99AE5D.broadband18.iol.cz) (Ping timeout)
[14:28:53] *** Joins: jorendorff (jorendorff@moz-AF5FD687.hsd1.tn.comcast.net)
[14:29:27] *** Quits: acrichto (acrichto@moz-B63D64BD.res.cmu.edu) (Ping timeout)
[14:29:47] *** Quits: Jesin (Jessin_@moz-3AD6F09F.res.lehigh.edu) (Quit: Leaving)
[14:33:18] *** Quits: rubber-duck (rubber-duc@moz-A944829F.dsl.iskon.hr) (Input/output error)
[14:33:23] *** Quits: jorendorff (jorendorff@moz-AF5FD687.hsd1.tn.comcast.net) (Quit: jorendorff)
[14:35:03] <roo> "Drop trait can only be implemented on structures", well it was worth a shot :P
[14:35:04] *** Quits: MaikKlein (maik@moz-DD7D2879.dip0.t-ipconnect.de) (Ping timeout)
[14:35:09] *** Joins: reyre_ (reyre@moz-9002CDDA.cpe.net.cable.rogers.com)
[14:36:55] *** Joins: rpearl (rpearl@moz-2B41ACB5.andrew.cmu.edu)
[14:36:58] *** Joins: sankha93 (Instantbir@86B78288.EA57944B.8B6C1D65.IP)
[14:37:19] *** Joins: mjrosenb (mjrosenb@moz-B3592BDA.club.cc.cmu.edu)
[14:37:35] *** Joins: rntz (rntz@moz-C76A8D96.sp.cs.cmu.edu)
[14:39:23] *** Joins: bblum (bblum@moz-2B41ACB5.andrew.cmu.edu)
[14:40:00] *** Joins: SiegeLord (sl@moz-CAF07B4C.hsd1.ma.comcast.net)
[14:41:32] *** Joins: teratorn (teratorn@moz-5363C32C.teratorn.org)
[14:41:52] *** Quits: bytbox (s@moz-DC83764A.washdc.fios.verizon.net) (Ping timeout)
[14:45:04] <dbaupp> cmr: cool!
[14:45:49] *** kimundi is now known as zz_kimundi
[14:47:06] *** Quits: Ms2ger (Ms2ger@moz-AC84CFF6.adsl-dyn.isp.belgacom.be) (Quit: Leaving)
[14:48:38] *** Joins: KindOne (KindOne@7D0DB6F0.E114B4AE.EC6A1518.IP)
[14:48:39] <cmr> https://gist.github.com/cmr/d90b34384ba5fc0123a1
[14:48:42] <cmr> Anyone have anything to add?
[14:49:48] <darkf> what is the type of ~["a", "b"]? I'm trying to use it in a static constant (e.g. static foo: ~[&static str] = ["a", "b"]) but I get "error: found `static` in ident position"
[14:49:59] <cmr> darkf: ~[&'static str]
[14:50:12] <cmr> darkf: you can't have ~[] in a static though
[14:50:19] <bstrie> cmr: this looks awesome
[14:50:26] <cmr> darkf: static foo: &'static[&'static str] = &["a", "b"]
[14:50:37] <bstrie> cmr: mention the underscore methods and link to the bug
[14:50:40] <darkf> cmr: ah, thanks
[14:50:55] <darkf> ~[] *does* work though
[14:51:07] <cmr> It shouldn't :S
[14:51:12] <darkf> (or at least it compiles)
[14:51:26] <cmr> well, maybe it should
[14:51:29] <engla> darkf: it should not work in a    static X: ~[..] = ~[..]   variable
[14:51:55] <cmr> rusti: static foo: ~[int] = ~[1, 2, 3]; foo
[14:51:57] -rusti- <anon>:7:30: 7:40 error: constant contains unimplemented expression type
[14:51:57] -rusti- <anon>:7          static foo: ~[int] = ~[1, 2, 3]; foo
[14:51:57] -rusti-                                        ^~~~~~~~~~
[14:51:57] -rusti- error: aborting due to previous error
[14:51:57] -rusti- application terminated with error code 101
[14:52:01] <cmr> mmm
[14:52:02] *** Joins: pnathan (Adium@B9840254.2CD8A5F8.477B877D.IP)
[14:52:02] <darkf> ah. nevermind - an error further down was getting shown before it. 
[14:52:05] <bstrie> cmr: also, io has been a losing proposition since at least 0.2 :P
[14:52:07] <darkf> weird
[14:52:31] <cmr> bstrie: noted!
[14:54:36] <bstrie> cmr: title this "The State of Rust 0.7"
[14:54:43] <cmr> ok
[14:54:55] <bstrie> "The State of the Release Address"
[14:57:06] <bstrie> cmr: if this is a resource for newcomers, it also couldn't hurt to add link to the mailing list and irc channel. but add them at the bottom, so that we can avoid answering the questions within
[14:57:17] <cmr> bstrie: clever!
[14:57:38] *** zz_kimundi is now known as kimundi
[14:58:02] *** Quits: pnathan (Adium@B9840254.2CD8A5F8.477B877D.IP) (Ping timeout)
[14:58:17] *** Quits: cowboyd (cowboyd@moz-1BD02A1E.sw.biz.rr.com) (Client exited)
[14:58:49] *** Joins: BitPuffin (quassel@82A16641.B9945E9.8F92419C.IP)
[15:00:38] *** Joins: BitPuffin_ (quassel@moz-49828767.cust.tele2.se)
[15:01:24] *** Joins: taylanub (taylanub@moz-4942D212.dip0.t-ipconnect.de)
[15:02:19] *** Joins: Kruppe (user@moz-E150F49F.cpe.net.cable.rogers.com)
[15:02:46] <Seldaek> cmr: btw regarding Iterable, maybe my english fails me, but it sounds like a borked word. How about Traversable? 
[15:03:02] <cmr> Seldaek: Iterable is what it is and will be called.
[15:03:10] <Seldaek> fair enough :p
[15:03:15] <cmr> it's a common word
[15:03:22] <cmr> (at least in programming)
[15:03:39] <Seldaek> just checking :)
[15:04:02] <cmr> np, thanks :)
[15:04:32] <bstrie> Seldaek: if it were following the usual english heuristics it would probably be called "Iterateable", but apparently some snooty programmer thought otherwise
[15:05:15] <Seldaek> well, that'd be a decrease in world productivity due to typos by 2% or something
[15:05:42] <Seldaek> like the most awesome Referer header
[15:05:47] <cmr> yeah
[15:06:09] <Seldaek> I wonder if any dictionary has Referer in by now
[15:06:23] <ChrisMorgan> Referer is different, because it's simply wrong. On the other hand, people never used iterateable.
[15:06:54] <sp3d> there is precedent, e.g. "venerate"/"venerable"
[15:06:55] *** Quits: huseby (huseby@moz-4E8C421A.husebyhome.com) (Quit: Leaving)
[15:07:07] *** Joins: huseby (huseby@moz-4E8C421A.husebyhome.com)
[15:07:41] <bstrie> but "venerateable" isn't *technically* illegal, just weird
[15:07:51] <ChrisMorgan> And iterable was used back in the late 1700s.
[15:07:54] <doy> iterable is fairly common, in my experience
[15:07:57] *** Quits: donri (dag@moz-9BB61102.tbcn.telia.com) (Client exited)
[15:08:03] <ChrisMorgan> ;-)
[15:08:07] <doy> iterateable sounds pretty wrong
[15:08:19] *** Joins: kesserich (Mibbit@moz-7ABC9BDB.hsd1.pa.comcast.net)
[15:08:22] <bstrie> you can stick "able" on any verb
[15:08:25] <bstrie> it's great
[15:08:30] <ChrisMorgan> Yeah, you would drop the "e"
[15:08:31] <bstrie> find me a verb you can't do it with and I'll eat this hat
[15:08:44] <Seldaek> the venerable iterator souds better than iterable iterator though. Maybe it should be a Venerable trait :p
[15:08:52] <darkf> ateable?
[15:08:57] <engla> iterable is in webster's 1913 dictionary
[15:08:58] <darkf> eatable?
[15:09:02] <cmr> darkf: eatable is a thing
[15:09:06] <darkf> :o
[15:09:09] <bstrie> engla: what's the definition?
[15:09:11] <ChrisMorgan> See also: http://books.google.com/ngrams/graph?content=iterable%2Citeratable%2Citerateable&year_start=1500&year_end=2013&corpus=15&smoothing=3&share=
[15:09:27] <engla>  It"er*a*ble (?), a. [L. iterabilis. See Iterate.] Capable of being iterated or repeated. [Obs.] 
[15:09:30] *** Joins: lkuper (lkuper@moz-C0CD33ED.hsd1.in.comcast.net)
[15:09:36] <cmr> obsolete!
[15:09:40] <cmr> the gumption!
[15:09:42] <ChrisMorgan> !
[15:09:52] *** Quits: msingle (Thunderbir@moz-930E5D97.hr.hr.cox.net) (Ping timeout)
[15:10:05] <kesserich> howdy. can anyone point to me to a tutorial on using rustpkg?  I haven't been able to unearth one on google.
[15:10:05] *** Joins: msingle (Thunderbir@moz-930E5D97.hr.hr.cox.net)
[15:10:05] <cmr> Seldaek: well iterators are iterables, but often you have non-iterator objects that are iterable
[15:10:12] <cmr> kesserich: there isn't one
[15:10:29] <cmr> kesserich: https://github.com/mozilla/rust/blob/master/doc/rustpkg.md is the best you're going to get
[15:10:33] <cmr> kesserich: it's still heavily WIP
[15:10:34] <Seldaek> cmr: yeah sorry I'm just talking garbage because what I have to work on is really boring right now
[15:10:39] <bstrie> kesserich: it's still very unfinished right now
[15:10:44] <bstrie> docs will do you no good
[15:10:52] <bstrie> except to yearn at what might be
[15:11:31] <ChrisMorgan> The problem with developing a language in the open: people start using it, so you get lots of requests about "how do I do this?" and lots of obsolete information on the Internet (after only a week or two, sometimes!).
[15:12:15] <cmr> ChrisMorgan: Case in point: the recent LWN article on iterators in Rust was obsolete before it was published.
[15:12:18] <cmr> literally
[15:12:40] <ChrisMorgan> And people *don't update them* most of the time.
[15:12:44] <kesserich> cmr: thanks for the link.  
[15:12:49] <ChrisMorgan> Or even indicate "THIS IS OBSOLETE!"
[15:12:51] *** Joins: nano (nano@moz-972880B.superkabel.de)
[15:13:24] <ChrisMorgan> Anyone worked with Rust's ctags stuff? I'd like to start using it, but I've never worked with ctags directly before and Rust doesn't seem to provide any harness for it yet.
[15:13:50] <cmr> ChrisMorgan: I think there's a few users.
[15:14:02] <cmr> I'm not among them
[15:15:24] <bstrie> ChrisMorgan: nmatsakis might use ctags?
[15:15:42] <ChrisMorgan> One of the great things about Rust's traits model is that not all of the code for a "class" needs to be in the one place‚Äîor even the one file. One of the pesky things about Rust's traits model is „ÄÉ.
[15:16:04] <cmr> What is that symbol?
[15:16:33] <ChrisMorgan> U+3003 DITTO MARK
[15:16:38] <cmr> oh
[15:16:41] <cmr> ditto
[15:16:58] <ChrisMorgan> I was feeling fancy ;-)
[15:17:05] <engla> maybe you should just have said <U+3003 DITTO MARK> instead.
[15:17:08] <engla> ;-)
[15:17:46] <ChrisMorgan> Is it unusual to actually go typing things like em-dashes as Ctrl+Shift+U 2014 <CR> as a matter of course? ‚Äî
[15:18:06] <engla> yes‚Äîfor that reason I've mapped to a better place.
[15:18:26] <ChrisMorgan> Sure, I wish everything had Vim's digraph support‚Äî<C-S-K>-M‚Äîbut they don‚Äôt.
[15:18:27] * cmr just uses the first 128 codepoints
[15:18:45] * bstrie just uses the first 16 codepoints
[15:18:49] <cmr> heh
[15:18:54] *** Joins: Ms2ger (Ms2ger@moz-AC84CFF6.adsl-dyn.isp.belgacom.be)
[15:18:56] * engla says m√∏√∏se
[15:19:09] <kimundi> Meh, just need a proper unicode overloaded layout ‚ô•
[15:19:16] <bstrie> engla: a moose bit my sister once
[15:19:30] * ChrisMorgan mostly uses the first 128 codepoints but then strays around U+2000 to U+2020 fairly regularly
[15:19:36] <Ms2ger> She was not a moose?
[15:20:14] <cmr> https://gist.github.com/cmr/d90b34384ba5fc0123a1
[15:20:16] <cmr> bstrie: ^
[15:20:48] <kesserich> The default value of RUST_PATH ultimately defaults to ~/.rust.   Is this is a good default for OS X?  Any opinions?
[15:21:09] <ChrisMorgan> cmr: nested quotation marks, you should be alternating single and double!
[15:21:24] <bstrie> Ms2ger: no really! she was carving her initials on the moose with the sharpened end of... you know, it's quite a long story actually
[15:21:42] <Ms2ger> I've got time, go for it ;)
[15:22:07] <cmr> ChrisMorgan: pfft...
[15:22:12] <ChrisMorgan> (And then put a non-breaking space between the ‚Äô and ‚Äù, too. See, I really am a typography snob.)
[15:22:44] <Ms2ger> You're the kind of person who'd use óÖ?
[15:23:02] <ChrisMorgan> U+00A0, that is. That's one that I remember in decimal (160) rather than in hex :-/
[15:23:04] *** Joins: enix (enix@moz-A50569DD.c3-0.slvr-ubr1.lnh-slvr.md.cable.rcn.com)
[15:23:23] *** Joins: cowboyd (cowboyd@1D8844A7.1B729417.CEE440B6.IP)
[15:23:37] <engla> remembering codepoints is no fun.. the computer is the tool, not I
[15:23:48] <sp3d> s/o to compose keys
[15:23:49] <dbaupp> cmr: the plain URLs in the list could be niceified :)
[15:23:51] <cmr> engla: keep thinking that
[15:23:51] <bstrie> the only code that I remember is alt+0153, which is the trademark symbol on windows but just ¬ô in putty
[15:24:02] <sp3d> ‚Ñ¢
[15:24:05] <dbaupp> useful!
[15:24:13] <ChrisMorgan> I don't remember them intentionally... it just happens.
[15:24:31] *** Quits: maxli (maxli@B5559308.9C54E60.2FA4EA88.IP) (Quit: Leaving.)
[15:25:16] <cmr> https://gist.github.com/cmr/d90b34384ba5fc0123a1
[15:25:16] *** Quits: Kruppe (user@moz-E150F49F.cpe.net.cable.rogers.com) (Client exited)
[15:25:20] <cmr> ChrisMorgan: happy? :p
[15:25:21] <bstrie> cmr: disregard ChrisMorgan's pedantry in favor of *my* pedantry, and turn the quote into a blockquote!
[15:25:58] <ChrisMorgan> But to be sure, I prefer Vim's <C-K>TM, <C-K>NS, <C-K>-M, <C-K>6", &c. to recalling Unicode code points.
[15:26:02] <cmr> as long as we're bikeshedding about the formatting of the quotes, I think it's good to publish :p
[15:26:44] <SiegeLord> That's the most pessimistic Rust summary I've ever read :P
[15:27:00] <ChrisMorgan> cmr: that was just because it was in the first paragraph ;-)
[15:27:02] <cmr> SiegeLord: most honest, you mean ;)
[15:27:07] *** Joins: Kruppe (user@moz-E150F49F.cpe.net.cable.rogers.com)
[15:27:28] <SiegeLord> cmr: It misses the fact that things were worse before ;)
[15:27:29] <cmr> Rust is actually in a fairly good position, it's just... not quite all there yet
[15:27:49] <SiegeLord> It'd be nice if you had that ^ sentence there :P
[15:27:55] * cmr adds
[15:28:25] <bstrie> also
[15:28:31] <bstrie> as long as strcat isn't here
[15:28:34] <engla> the issule links are good to outweigh the pessimism
[15:28:35] <cmr> uhoh
[15:28:41] <bstrie> does anyone else agree that fold is a terrible name for reduce? :P
[15:28:52] <ChrisMorgan> cmr: so, extra::net::* will be being redone quite a bit with the IO work?
[15:28:55] <dbaupp> bstrie: no, reduce is a terrible name for fold
[15:29:01] <dbaupp> :P
[15:29:01] * bstrie fights dbaupp
[15:29:02] <cmr> ChrisMorgan: torn out and replaced!
[15:29:04] <rntz> fold is a terrible name for reduce, and reduce is a terrible name for fold
[15:29:11] <rntz> they're different functions!
[15:29:20] <rntz> reduce :: Monoid a => [a] -> a
[15:29:27] <bstrie> are you kidding me
[15:29:32] <bstrie> my whole life is a lie
[15:29:34] <engla> that's mconcat?
[15:29:43] <bstrie> and this means I STILL don't friggin understand fold
[15:29:46] <rntz> foldr :: (a -> b) -> b -> [a] -> b
[15:29:52] <rntz> engla: correct
[15:29:58] <rntz> reduce is a better name for mconcat :P
[15:30:04] <engla> nah
[15:30:06] *** Quits: bytewise (bytewise@moz-649C630D.unitymediagroup.de) (Ping timeout)
[15:30:12] * roo agrees
[15:30:37] <dbaupp> foldr :: (a -> b -> b) -> b -> [a] -> b
[15:30:44] <ChrisMorgan> cmr: but how different will the interface be?
[15:30:44] *** Quits: Kruppe (user@moz-E150F49F.cpe.net.cable.rogers.com) (Client exited)
[15:30:45] <rntz> argleblarg
[15:30:47] <Ms2ger> That's making more sense
[15:30:49] <bstrie> please... stop... too many arrows...
[15:30:50] <cmr> ChrisMorgan: unknown
[15:30:52] <rntz> yes, (a -> b -> b) not (a -> b)
[15:30:54] <rntz> i r dum
[15:31:13] <cmr> https://gist.github.com/cmr/d90b34384ba5fc0123a1
[15:31:18] <Ms2ger> bstrie, yeah, Haskellites like to hide what they mean behind arrows
[15:31:19] <cmr> SiegeLord: ^ last paragraph
[15:31:32] <rntz> Ms2ger: it's not hiding, it's just a different notation. how would *you* write it?
[15:31:44] <ChrisMorgan> By the way, something I *really* want for rustdoc's HTML output is a tree TOC on the side, indicating where I am in the document at present.
[15:31:48] <bstrie> exhibit 1: haskell: http://images2.wikia.nocookie.net/__cb20111011195552/villains/images/d/d7/Arrowed.png
[15:31:51] <SiegeLord> cmr: That's more like it... end on a positive note!
[15:31:59] <cmr> ChrisMorgan: https://github.com/mozilla/rust/wiki/Bikeshed-rustdoc second item :p
[15:32:02] <Ms2ger> (((a, b) -> b), b, [a]) -> b?
[15:32:22] <cmr> (and third)
[15:32:22] <Ms2ger> There's conceptually two functions, so two arrows
[15:32:42] <ChrisMorgan> Good.
[15:32:47] <rntz> Ms2ger: okay, sure. and an MLer would write it ('a * 'b -> b) * 'b * 'a list -> 'b
[15:32:53] <rntz> they're just different notations
[15:33:15] <rntz> I mean, there is a difference between your & the ML version and the haskell version, namely currying, but it doesn't really matter that much
[15:33:44] <rntz> similarly there's reasoning behind the difference between rust & haskells (a,b) and ML's a * b, but it doesn't matter that much
[15:33:51] <rntz> *haskell's
[15:33:54] *** Quits: z0w0 (zack@E2E93C1.54F16452.2CE63F58.IP) (Client exited)
[15:34:03] * kimundi wonders how many decades it will take till unicode is ingrained enough into computing that a language that uses syntax like 'if ‚àÄx ‚àà xs. x ‚â§ 42 ‚àß xs ‚äÇ ys { ... }' will be seen as nothing special
[15:34:09] <engla> Ms2ger: your thing is a valid signature in haskell too. not unusual
[15:34:10] <Ms2ger> Well, yes, I find that the currying makes it less obvious what you mean
[15:34:12] <darkf> rntz: OCaml uses ('a -> 'b -> 'b) -> 'a list -> 'b -> 'b
[15:34:14] <engla> *but unusual
[15:34:28] <bstrie> kimundi: forget unicode, the blocker here is a better input method :P
[15:34:33] <rntz> darkf: okay. my point remains the same.
[15:34:43] <roo> kimundi: looks like perfectly valid agda
[15:34:53] <Ms2ger> roo++
[15:34:54] <bstrie> kimundi: also, boo math notation! programming languages can do better :P
[15:35:01] <rntz> I think SML actually uses ('a * 'b -> 'b) -> 'b -> 'a list -> 'b, which is curried but expects an uncurried folder function, but whatever
[15:35:06] <dbaupp> bstrie: huge keyboard!
[15:35:09] <Ms2ger> bstrie, hey, hey, be nice to math, please :)
[15:35:13] <roo> though i dont think there is any unicode string that isnt ;P
[15:35:14] <bstrie> silly mathematicians, believing their notation to be superior to all else!
[15:35:32] <bstrie> we don't buy into their lies
[15:35:38] <Ms2ger> bstrie, as a mathematician, it is :)
[15:35:44] <cmr> also high dpi displays. I can't have my 3mm tall glyphs with the current awful DPIs.
[15:35:48] <kimundi> well, people need to evolve beyond a keyboard layout that was choosen to not jam your typewriter till then.
[15:35:56] <ion> That‚Äôs not math notation at all, just a crude ASCII approximation. :-P
[15:36:02] <dbaupp> silly bstrie, believing that mathematical notation can be beaten
[15:36:05] <dbaupp> :P
[15:36:15] <bstrie> in the immortal words of graydon: http://quotes.burntelectrons.org/6221
[15:36:38] <cmr> *in the words of the immortal mecha-graydon
[15:37:00] <bstrie> graydon has spoken, math has been found wanting
[15:37:14] <cmr> http://cmr.github.io/blog/2013/07/05/the-state-of-rust/
[15:37:16] <Ms2ger> And crap, did I start a syntax discussion again?
[15:37:27] <cmr> Ms2ger: every time you open your mouth. jeez!
[15:37:31] <bstrie> haha
[15:38:07] <rntz> Ms2ger: meh? currying is less obvious until you are used to it, but that happens reasonably fast.
[15:38:25] <rntz> I wonder if there's some bizarro world where people find sum types more intuitive than products and currying more intuitive than uncurrying
[15:38:45] <rntz> or whether you could raise someone to find things that way
[15:38:51] * cmr doesn't even know what most of these words are
[15:39:04] <Ms2ger> rntz, *shrug* I got to write haskell last semester and I'm still translating the curried version
[15:39:34] <dbaupp> cmr: 'I' 'wonder' 'if' 'there's' 'some' ... (I'm onto your lies :P )
[15:39:51] <rntz> cmr: product types = records = structs = tuples = "A and B and C"; sum types = rust enums = "A or B or C"
[15:40:09] <rntz> well, except rust enums also give you recursive (self-referential) types
[15:40:20] <bstrie> rntz: now you'll tell me that you can just do algebra with anything at all!
[15:40:25] <bstrie> what silliness
[15:40:38] <rntz>  yeah, pretty much :P
[15:41:50] <rntz> cmr: do you know what currying and uncurrying are?
[15:41:50] <cmr> Well that's my prose quota, back to rustdoc
[15:41:56] <kimundi> I agree with graydon there. Math might have more common notations today, but there are still thousand of different ways to write down the same thing
[15:42:07] <cmr> rntz: I vaguely know what currying is, never heard of the other one
[15:42:14] <rntz> uncurrying is just... not currying.
[15:42:32] <rntz> like, (a -> b -> b) is curried, ((a,b) -> b) is uncurried or not curried
[15:43:07] <Ms2ger> Currying means that you can encode multi-argument functions as one-argument-functions
[15:43:12] <rntz> and currying is representing a multiple argument function, say plus, by a function that returns a function. so "plus : Int -> Int -> Int"
[15:43:23] *** Quits: a__ (a__@moz-250D9B4.nycmny.fios.verizon.net) (Client exited)
[15:43:28] <rntz> or plus : @fn(int) -> @fn(int) -> int
[15:43:46] <rntz> vs. uncurrying, where you represent a multiple-argument function by one which takes a tuple
[15:44:00] <rntz> so plus : (Int, Int) -> Int
[15:44:08] <rntz> or plus : fn@((int,int)) -> int
[15:44:25] *** Joins: a__ (a__@moz-250D9B4.nycmny.fios.verizon.net)
[15:44:35] <rntz> most languages make taking multiple arguments a built-in feature of the language, which is sort of an "automatic uncurrying"
[15:44:58] <rntz> I guess in bizarro world multiple return values would be considered more natureal than multiple argument values.
[15:45:05] <rntz> *natural
[15:45:17] *** Quits: nano (nano@moz-972880B.superkabel.de) (Connection reset by peer)
[15:46:10] <dbaupp> cmr: http://hnn.mrsd.org/~cmr/d161e630d8378e9705987e0b746d8dbf0da48842/ (mem.json is empty?)
[15:47:12] *** Joins: bytbox (s@moz-DFB39B01.wireless.umd.edu)
[15:48:20] <cmr> dbaupp: obnoxious, rerunning
[15:48:31] <jfbk> fixed-length byte vectors don't impl IterBytes. is this b/c each distinct length is a distinct type and providing an implementation for all is infeasible?
[15:48:52] <dbaupp> jfbk: yes
[15:49:13] <bstrie> jfbk: you're right about them being different types, but I don't know if that's *the* reason that it doesn't impl IterBytes
[15:49:19] <engla> what happened to the testsuite numbers at isrustfastyet?
[15:49:26] <dbaupp> (fixed-length vectors don't implement any traits at the moment because of that issue :/ )
[15:49:49] <bstrie> jfbk: for example, tuples of different arity are all different types, but we still generate the usual methods on all tuples up to 12
[15:49:53] <engla> I think the short vectors will get templated trait impls
[15:50:02] *** Quits: gour (gour@moz-2DE8C055.adsl.net.t-com.hr) (Quit: WeeChat 0.4.0)
[15:51:00] <jfbk> should be rare to have large tuples, while large fixed-length vectors are common
[15:51:15] *** Joins: stepancheg (Mibbit@moz-58AD93C5.yandex.net)
[15:51:21] <jfbk> so payoff for adding small-vec impls is low
[15:51:36] <engla> yes
[15:52:07] *** Quits: sk (sk@1696E5A5.E92B26F8.78DD174B.IP) (Quit: Leaving)
[15:52:20] <dbaupp> cmr: strange
[15:52:23] <jfbk> workaround is to just implement iterbytes as needed?
[15:52:36] *** Joins: bytewise (bytewise@moz-649C630D.unitymediagroup.de)
[15:52:57] <kimundi> can'- you use the &[T] impls?
[15:53:20] <dbaupp> in any case, the computer running IRFY is no longer responding to SSH, so I'm not sure if it'll update automatically until tomorrow when I can poke it. :/
[15:53:48] <engla> jfbk: yes
[15:53:53] <engla> rusti: use std::hash::*; let x: [int, ..2] = [2,3]; std::util::id::<&[int]>(x).hash()
[15:53:54] -rusti- 12971421950716681303
[15:54:15] <engla> borrow to &[]
[15:54:22] *** Quits: lkuper (lkuper@moz-C0CD33ED.hsd1.in.comcast.net) (Ping timeout)
[15:54:29] *** Quits: Ms2ger (Ms2ger@moz-AC84CFF6.adsl-dyn.isp.belgacom.be) (Quit: bbl)
[15:55:19] <dbaupp> rusti: use std::hash::*; let x: [int, .. 2] = [2,3]; x.as_slice().hash()
[15:55:20] -rusti- 12971421950716681303
[15:55:23] *** Joins: maxli (maxli@B5559308.9C54E60.2FA4EA88.IP)
[15:55:27] <dbaupp> rusti: use std::hash::*; let x: [int, .. 2] = [2,3]; x.hash()
[15:55:28] -rusti- <anon>:7:55: 8:5 error: failed to find an implementation of trait std::to_bytes::IterBytes for [int, .. 2]
[15:55:28] -rusti- <anon>:7          use std::hash::*; let x: [int, .. 2] = [2,3]; x.hash()
[15:55:28] -rusti- <anon>:8     };
[15:55:29] -rusti- application terminated with error code 101
[15:55:37] <engla> ah as_slice is the natural way
[15:55:38] <cmr> Struct fields can have attributes?
[15:55:42] <cmr> Oh, duh, docs
[15:56:15] *** Quits: FrozenCow (FrozenCow@moz-B2DF4929.chello.nl) (Quit: Leaving)
[15:56:17] <bstrie> rusti: use std::hash::*; let x = [2i,3]; (&x).hash()
[15:56:17] -rusti- <anon>:7:43: 8:5 error: failed to find an implementation of trait std::to_bytes::IterBytes for [int, .. 2]
[15:56:18] -rusti- <anon>:7          use std::hash::*; let x = [2i,3]; (&x).hash()
[15:56:18] -rusti- <anon>:8     };
[15:56:18] -rusti- application terminated with error code 101
[15:56:20] *** Joins: FrozenCow (FrozenCow@moz-B2DF4929.chello.nl)
[15:56:37] <bstrie> why doesn't &x do the same thing as as_slice
[15:56:58] <dbaupp> bstrie: because &[] is different to &([])
[15:57:18] * bstrie head asplode
[15:57:20] <dbaupp> bstrie: &[] = (ptr, length), &([]) = ptr
[15:57:41] <dbaupp> ([] and str are special little types)
[15:57:45] <bstrie> I thought borrowing a fixed-length vec was automatically a slice
[15:57:54] <dbaupp> right, but & isn't a borrow
[15:58:11] <dbaupp> it takes a reference to the fixed-length vec, i.e. &([])
[15:58:21] <jfbk> i've got a struct w/ a fixed-length vec field, trying to derive IterBytes for it but fails b/c of that field.
[15:58:52] <dbaupp> jfbk: yeah, the only work around would be to define a newtype struct, and impl IterBytes on it by hand
[15:58:56] <kimundi> jfbk: deriving probably doesn't know about fixed length vecs yet
[15:59:35] <dbaupp> jfbk: struct Wrapper([int, .. 100]); impl IterBytes for Wrapper { .. } #[deriving(IterBytes)] struct Foo { fixed: Wrapper }
[16:00:16] <jfbk> ok, thanks.
[16:00:45] <dbaupp> kimundi: deriving doesn't know about any types. it just assumes/hopes that the types in the data structure impl the relevant trait.
[16:01:04] <dbaupp> kimundi: and then typeck comes along and shouts at the programmer if they don't.
[16:01:05] <Yurume> rusti: fn a(f:&fn()){f();} fn b(f:&fn()){for std::uint::range(0,5)|i|{a(f);}} b(|| print("foon "));
[16:01:06] -rusti- <anon>:7:74: 7:75 error: cannot move out of captured outer variable
[16:01:06] -rusti- <anon>:7          fn a(f:&fn()){f();} fn b(f:&fn()){for std::uint::range(0,5)|i|{a(f);}} b(|| print("foon "));
[16:01:06] -rusti-                                                                                    ^
[16:01:06] -rusti- error: aborting due to previous error
[16:01:07] -rusti- application terminated with error code 101
[16:01:11] <Yurume> hmm.
[16:01:45] <dbaupp> jfbk: (obviously that is most useful if `Foo` has more than just one field.)
[16:02:13] <Yurume> should an &fn closure be copied (but `copy` doesn't seem to work) explicitly now?
[16:02:30] <engla> you can reborrow the closure with   |x| f(x)
[16:02:33] *** Joins: dherman (dherman@moz-6CA476B1.hsd1.ca.comcast.net)
[16:02:33] *** ChanServ sets mode: +o dherman
[16:02:46] <engla> or use a loop without a closure
[16:02:51] <Yurume> rusti: fn a(f:&fn()){f();} fn b(f:&fn()){for std::uint::range(0,5)|i|{a(|| f());}} b(|| print("foon "));
[16:02:51] <engla> so not a for loop
[16:02:52] -rusti- <anon>:7:69: 7:70 warning: unused variable: `i` [-W unused-variable (default)]
[16:02:52] -rusti- <anon>:7          fn a(f:&fn()){f();} fn b(f:&fn()){for std::uint::range(0,5)|i|{a(|| f());}} b(|| print("foon "));
[16:02:53] -rusti-                                                                               ^
[16:02:53] -rusti- foon foon foon foon foon ()
[16:03:05] <Yurume> huh, that's strange, any rationale?
[16:03:19] <engla> I'll find it
[16:03:19] <Yurume> I was not aware of such change
[16:03:58] <Yurume> (and I have 30+ such errors while converting Angolmois Rust edition for 0.7)
[16:04:51] <stepancheg> Hi all. I'm trying to measure performance of context switch in rust. I created test case: https://github.com/stepancheg/perftest-rust/blob/master/switch.rs . Compiled with -O, executed with RUST_THREADS=1 on Linux. Duration of context switch (+send/receive) is about 2us. It is too long, and should be comparable to function call, right?
[16:05:03] <engla> yurume, it's merge  132cfcdd8898a12b19ba01ae64cd9cff9a4c45d9
[16:05:28] <engla> https://github.com/mozilla/rust/pull/7363
[16:05:32] <SiegeLord> Can you not make a type that you can add with multiple types?
[16:05:32] <dbaupp> stepancheg: why should it be comparable to a function call?
[16:05:47] <cmr> SiegeLord: not right now, it's a bug
[16:06:01] <SiegeLord> cmr: How wide is the scope of the bug?
[16:06:04] <cmr> stepancheg: might try with the new scheduler, RUST_NEWRT=1
[16:06:20] <SiegeLord> Will it work for more than just the operator overloading?
[16:06:34] <cmr> SiegeLord: yes
[16:06:39] <Yurume> engla, so it is a temporary measure until the language makes a decision about how stack closures are borrowed...
[16:06:39] <SiegeLord> Sweeet
[16:06:50] <cmr> SiegeLord: trying to find the issue
[16:07:09] <stepancheg> dbaupp: because threads are green and lightweight, and context switch does not involve syscalls
[16:07:18] <Yurume> I thought that issue is significant enough to be mentioned in RELEASES ;)
[16:07:21] <cmr> stepancheg: btw, opening a PR with that test and referencing https://github.com/mozilla/rust/issues/7532 would be awesome!
[16:07:21] <engla> Yurume: not sure. When for loops change to not use closures, the issue is less important
[16:07:38] *** Quits: Blub\w (wry@7E3BB9D.71150E1A.237AE2BA.IP) (Quit: bb2morrow)
[16:07:41] <engla> Yurume: good point
[16:08:06] <cmr> stepancheg: Our tasks are green threads for now, but the scheduler is old, inefficient, and being rewritten
[16:08:16] <dbaupp> stepancheg: right, that doesn't make it costless though. the scheduler has to do some work... not exactly sure what, but it's not free.
[16:08:18] *** Quits: BitPuffin_ (quassel@moz-49828767.cust.tele2.se) (Ping timeout)
[16:08:42] <dbaupp> stepancheg: (and as cmr says, there's a new scheduler on the way that should perform better, hopefully.)
[16:08:43] <stepancheg> cmr: it is 1.5us with RUST_NEWRT=1, but good thing is that performance is almost the same with RUST_THREADS=5. Thanks!
[16:08:51] <Yurume> engla, and I think it is a bit too much to use iterators on this code: `for "hello".find('e').iter().advance |v| { ... }`
[16:09:13] <dbaupp> SiegeLord: work around http://smallcultfollowing.com/babysteps/blog/2012/10/04/refining-traits-slash-impls/
[16:09:19] <Yurume> (especially since `"hello".find('e')` part should be kept during the iteration and this code does not do that)
[16:09:33] <engla> Yurume: it's a WIP
[16:09:34] <dbaupp> SiegeLord: heading "What if I want overloading?"
[16:09:44] <Yurume> though I've heard that that code eventually will become `for "hello".find('e') |v| { ... }`
[16:09:58] *** Joins: erickt (erickt@8C9ECD8F.3A598286.F12515B4.IP)
[16:10:18] <SiegeLord> dbaupp: Am I asking for method overloading?
[16:10:23] <dbaupp> SiegeLord: yes
[16:10:31] <SiegeLord> I think I'm asking for something a little bit more restricted
[16:10:40] <dbaupp> SiegeLord: operator overloading = overloading the add method
[16:10:41] <SiegeLord> Since I don't need argument-based mangling
[16:10:56] <SiegeLord> I'm fine with one method name per trait
[16:11:09] <cmr> https://github.com/mozilla/rust/issues/7590
[16:11:13] <dbaupp> (I mean, having a + x, a + y with x and y different types = overloading the add method)
[16:11:15] <cmr> dbaupp: it's ^ that, isn't it?
[16:11:42] <dbaupp> cmr: I think so, yeah
[16:12:07] <SiegeLord> Wait, lol... this was just opened?
[16:12:38] <dbaupp> Yurume: what are you trying to do with .find? (it returns an Option<uint>, right?)
[16:13:09] <Yurume> dbaupp, right, that is just an illustration though
[16:13:14] <engla> you can iterate Option
[16:13:29] <dbaupp> engla: oh, true
[16:13:30] *** Quits: enix (enix@moz-A50569DD.c3-0.slvr-ubr1.lnh-slvr.md.cable.rcn.com) (Quit: Konversation terminated!)
[16:13:48] *** Joins: pyrac (pyrac@moz-18D74BD0.w90-60.abo.wanadoo.fr)
[16:14:20] <engla> dbaupp: you've removed a lot of functions from vec.. I want to add one. shouldn't containers have fn pop_opt() -> Option<T>
[16:14:26] <mark_edward> what does Option ieratordo?
[16:14:41] <Yurume> mark_edward, calls the function once or does nothing
[16:14:42] <dbaupp> engla: yeah, probably
[16:14:49] <mark_edward> thanks
[16:14:57] <Yurume> executes the loop body*
[16:15:06] <engla> mark_edward: Option is eqiuvalent to a vec of either 0 or 1 elements
[16:15:07] <engla> in a way
[16:15:18] <mark_edward> ah, i see
[16:15:37] <dbaupp> engla: (I'd not disagree with removing (most of) the failing functions, and getting the user to call .unwrap() if they want possibility-of-failure like that.)
[16:15:58] <dbaupp> (i.e. replacing them with -> Option<whatever>)
[16:15:58] <stepancheg> And one more question. Currently Port and Chan process only one message at a time. Shouldn't they also have bulk send_multiple() and recv_all() operations? To reduce overhead of context switch under high load.
[16:16:02] <engla> dbaupp: not sure about pop since it's common
[16:16:42] * roo is ok with that, he got the chain macro to work
[16:16:43] <dbaupp> engla: yes
[16:16:49] <engla> dbaupp: since vec uses shift/unshift, pop/push shouldn't deque also use the same names
[16:16:54] *** Quits: SiegeLord (sl@moz-CAF07B4C.hsd1.ma.comcast.net) (Quit: It's a joke, it's all a joke.)
[16:17:24] <dbaupp> engla: I guess so (I don't have a strong opinion... all I know is how to delete things from vec & str ;P )
[16:17:30] <engla> hehe
[16:17:30] *** Quits: cowboyd (cowboyd@1D8844A7.1B729417.CEE440B6.IP) (Client exited)
[16:17:57] <engla> I have opinions but I know it's frowned upon!
[16:18:01] <engla> so 
[16:18:21] <engla> it's true, it is distracting
[16:18:45] *** Joins: acrichto (acrichto@moz-B63D64BD.res.cmu.edu)
[16:19:03] *** Parts: acrichto (acrichto@moz-B63D64BD.res.cmu.edu) ()
[16:19:26] *** Joins: zslayton (Mibbit@moz-14AA87A9.nyc.res.rr.com)
[16:20:07] <dbaupp> engla: feel free to make the naming more consistent (presumably changing deque) and submit a pr :)
[16:21:00] *** Joins: cowboyd (cowboyd@1D8844A7.1B729417.CEE440B6.IP)
[16:21:07] *** Joins: acrichto_ (acrichto@moz-B63D64BD.res.cmu.edu)
[16:21:11] <engla> I will
[16:21:29] <engla> I don't like shift/unshift though
[16:21:33] <engla> but what can I do
[16:21:39] *** Quits: Jesse (jruderman@moz-537BCF9.hsd1.ca.comcast.net) (Ping timeout)
[16:21:39] *** Quits: bytbox (s@moz-DFB39B01.wireless.umd.edu) (Ping timeout)
[16:21:39] <engla> I keep my head down ;-)  (not really)
[16:21:56] <cmr> stepancheg: probably
[16:22:07] <cmr> stepancheg: bring it up with brson, toddaaro, or bblum
[16:26:18] *** Quits: davbo (dave@moz-3FFA637C.oucs.ox.ac.uk) (Client exited)
[16:26:27] <stepancheg> cmr: you mean here on irc when they are online?
[16:27:09] <cmr> stepancheg: or on the ML, yeah
[16:28:17] *** Quits: jedestep (jedestep@34641662.FB4DE631.66C78B76.IP) (Ping timeout)
[16:31:36] *** Joins: hjr3 (hradtke@moz-1EBFFE8.public.wayport.net)
[16:33:57] <Yurume> error: borrowed value does not live long enough -- for to_type(obj).iter().advance |&t| { ... }
[16:34:24] <Yurume> I think it is also a big annoyance with the current iterator :( (aforementioned a bit though)
[16:35:01] <Yurume> so... rooting the iterator (to lengthen its lifetime til the for loop ends) does not work?
[16:35:17] <engla> you probably need to root the object you are iterating
[16:35:38] <engla> maybe the retval of to_type in your case
[16:35:47] <jfbk> dbaupp: I can't get as_slice() to work like you showed https://gist.github.com/jfager/de6a41e04a347faf5029
[16:36:16] *** Quits: hjr3 (hradtke@moz-1EBFFE8.public.wayport.net) (Ping timeout)
[16:36:27] <dbaupp> jfbk: hm, I don't think .as_slice() had landed when 0.7 was released :(
[16:36:28] <Yurume> engla, ah, rooting the object instead of the iterator, anyway that is another big annoyance :S
[16:36:37] *** Joins: pnathan (Adium@B9840254.2CD8A5F8.477B877D.IP)
[16:37:19] <dbaupp> Yurume: (fwiw, that's a problem with rvalues having their lifetimes inferred to be very/too short, not iterators specifically)
[16:37:45] <jfbk> dbaupp: ah, ok. i'm building off master, i'll try updating. thanks
[16:38:23] <Yurume> dbaupp, any issue numbers? "temporary value" or similar didn't yield a meaningful issue to link (for the later use)
[16:38:35] <engla> Yurume: rust 0.7 is basically just a development snapshot. Particularly iterators are already a good design but still a WIP
[16:39:12] <dbaupp> Yurume: https://github.com/mozilla/rust/issues/3511
[16:39:22] <Yurume> I know, I'll work around as I need (as I have been done in 0.5 and 0.6) but I couldn't find a detailed explanation or issue about those issues.
[16:39:33] <Yurume> dbaupp, thank you!
[16:39:44] *** Joins: acrichto1 (acrichto@moz-B63D64BD.res.cmu.edu)
[16:39:57] *** Joins: hjr3 (hradtke@moz-1EBFFE8.public.wayport.net)
[16:40:28] *** Quits: SimonSapin (simon@moz-D0C2F181.zone2.bethere.co.uk) (Ping timeout)
[16:43:02] *** Joins: jpochyla (jpochyla@28372D4.B0CB31E3.6CA70FD7.IP)
[16:47:51] *** Quits: ChrisMorgan (chris@moz-6AC741CA.static.tpgi.com.au) (Ping timeout)
[16:48:55] *** Quits: fabiand (fabiand@moz-90C26BF4.adsl.alicedsl.de) (Quit: Verlassend)
[16:49:02] *** Quits: jpochyla (jpochyla@28372D4.B0CB31E3.6CA70FD7.IP) (Ping timeout)
[16:53:50] *** Quits: stepancheg (Mibbit@moz-58AD93C5.yandex.net) (Quit: http://www.mibbit.com ajax IRC Client)
[16:55:00] *** Joins: jmgrosen (jmgrosen@moz-848F6087.sb.sd.cox.net)
[16:55:16] *** Quits: robertknight (robertknig@moz-54528EE0.wby.mendeley.com) (Quit: Computer has gone to sleep.)
[16:56:58] *** Joins: jedestep (jedestep@34641662.FB4DE631.66C78B76.IP)
[16:57:36] *** Joins: jpochyla (jpochyla@28372D4.B0CB31E3.6CA70FD7.IP)
[17:01:24] *** Quits: cowboyd (cowboyd@1D8844A7.1B729417.CEE440B6.IP) (Client exited)
[17:01:44] *** Quits: dbaupp (Thunderbir@moz-712A1135.lns20.syd6.internode.on.net) (Ping timeout)
[17:01:58] *** Joins: erickt1 (erickt@8C9ECD8F.3A598286.F12515B4.IP)
[17:02:04] *** Quits: erickt (erickt@8C9ECD8F.3A598286.F12515B4.IP) (Connection reset by peer)
[17:02:30] *** Joins: vk (vk@moz-389FEE13.hsd1.ca.comcast.net)
[17:02:53] *** cade is now known as cade_lunch
[17:02:53] *** Quits: jedestep (jedestep@34641662.FB4DE631.66C78B76.IP) (Ping timeout)
[17:03:03] *** Quits: km (quassel@FDBAF0A0.DBF71E41.29C67456.IP) (Ping timeout)
[17:03:31] *** Quits: BitPuffin (quassel@82A16641.B9945E9.8F92419C.IP) (Ping timeout)
[17:08:42] *** Quits: kesserich (Mibbit@moz-7ABC9BDB.hsd1.pa.comcast.net) (Quit: http://www.mibbit.com ajax IRC Client)
[17:08:45] *** Quits: CarpNet (ac@moz-FD24B77.sohonet.co.uk) (Quit: Leaving)
[17:09:49] *** Quits: Excureo (c@moz-EB93D257.static.knwc.wa.charter.com) (Ping timeout)
[17:09:54] *** Joins: Excureo (c@moz-EB93D257.static.knwc.wa.charter.com)
[17:10:59] *** Quits: jpochyla (jpochyla@28372D4.B0CB31E3.6CA70FD7.IP) (Ping timeout)
[17:13:01] *** Joins: mnemotic (niko@8FFD1BD2.9D81E74C.53DF0002.IP)
[17:13:38] *** Joins: jpochyla (jpochyla@28372D4.B0CB31E3.6CA70FD7.IP)
[17:13:41] *** Joins: km (quassel@FDBAF0A0.DBF71E41.29C67456.IP)
[17:14:40] *** Quits: Axord (xord@moz-C3CCF156.lsanca.dsl-w.verizon.net) (Quit: I'm sure it's perfectly safe)
[17:17:36] <engla> looks like the bot auto-linux-64-opt-vg is stuck
[17:18:07] *** Parts: acrichto_ (acrichto@moz-B63D64BD.res.cmu.edu) ()
[17:21:21] *** Joins: cowboyd (cowboyd@1D8844A7.1B729417.CEE440B6.IP)
[17:23:31] *** Quits: vk (vk@moz-389FEE13.hsd1.ca.comcast.net) (Quit: vk)
[17:24:57] *** Quits: reyre_ (reyre@moz-9002CDDA.cpe.net.cable.rogers.com) (Client exited)
[17:25:39] *** Quits: jpochyla (jpochyla@28372D4.B0CB31E3.6CA70FD7.IP) (Ping timeout)
[17:27:50] *** Joins: reyre_ (reyre@moz-9002CDDA.cpe.net.cable.rogers.com)
[17:29:01] *** Parts: mnemotic (niko@8FFD1BD2.9D81E74C.53DF0002.IP) ()
[17:29:33] <engla> or just slow
[17:31:32] <bstrie> what a terrible game show that sounds like
[17:31:39] <bstrie> STUCK! OR! SLOW!!!!
[17:31:59] *** Quits: novabyte (Instantbir@moz-C2F8389B.mullvad.net) (Quit: bye bye)
[17:32:05] <engla> playrust
[17:32:06] <engla> hehe
[17:32:47] <engla> playrust.com or somesuch is a game
[17:34:36] *** Quits: cowboyd (cowboyd@1D8844A7.1B729417.CEE440B6.IP) (Client exited)
[17:35:24] *** Joins: pcwalton (pcwalton@43CB6079.66715431.D25A875A.IP)
[17:35:24] *** ChanServ sets mode: +o pcwalton
[17:36:34] <pcwalton> is bors stuck?
[17:36:47] <cmr> pcwalton: seems so
[17:36:48] <bstrie> STUCK... OR... SLOW!!!
[17:36:54] <pcwalton> bleh
[17:36:57] <pcwalton> I have no access to it
[17:37:01] <bstrie> the game show where everyone loses!
[17:37:36] <engla> maybe this pull actually passes so it has to wait for the valgrind bot
[17:38:19] <engla> but the ETA time is stuck at 1 hrs 10m
[17:39:36] *** Joins: bytbox (s@moz-DC83764A.washdc.fios.verizon.net)
[17:40:10] *** Joins: SiegeLord (sl@moz-CAF07B4C.hsd1.ma.comcast.net)
[17:40:43] <Eridius> last night I was considering the problem of supporting various encodings to handle str<->[u8]. My thought was to represent an encoding as a pair of iterator adaptors. FromEncoding would wrap Iterator<u8> and provide char, and ToEncoding would wrap Iterator<char> and provide u8
[17:40:52] *** Quits: dherman (dherman@moz-6CA476B1.hsd1.ca.comcast.net) (Quit: dherman)
[17:41:02] <Eridius> does that sound reasonable?
[17:41:20] <Eridius> one benefit is you can plug two of these things together, so you could wrap a FromUTF8 with a ToUTF16 and end up with an Iterator<u8> that spits out utf-16 bytes
[17:41:21] <engla> just need a plan for error handling
[17:41:33] <Eridius> engla: that was my next thought. right now str uses a condition handler.
[17:41:34] <bstrie> Eridius: implement it!
[17:41:42] <Eridius> could conditions be used to return an enum that declares the expected behavior
[17:41:52] <pcwalton> Eridius: sounds good. we will possibly need encodings in Servo
[17:42:02] <pcwalton> it is not clear to what extent Servo will be UTF-8 versus UTF-16
[17:42:10] <bstrie> pcwalton: is servo entirely utf-16, because of javascript?
[17:42:10] <pcwalton> but it's best to plan for the future
[17:42:14] <pcwalton> bstrie: it's UTF-8
[17:42:22] <Eridius> so we could have a condition with 3 possible results: 1) RuneError (U+FFEF IIRC), 2) fail, or 3) abort the iterator
[17:42:26] <pcwalton> and the plan is to stick with that for as long as we can
[17:42:39] <pcwalton> but it's possible that we will be forced to change to UTF-16 which will make us sad
[17:42:40] <Eridius> my preference for the default would be RuneError
[17:43:25] *** Joins: jedestep (jedestep@34641662.FB4DE631.66C78B76.IP)
[17:43:42] <engla> so the replacement character
[17:43:52] <Eridius> ok when I get the time, hopefully this weekend, I'll start trying to implement this and see if it works
[17:44:18] <Eridius> oh it's U+FFFD
[17:44:23] <Eridius> and yeah it's the replacement character
[17:44:25] <pcwalton> it's amazing how often trying to make the language opinionated ends up failing when you have to implement a web browser
[17:44:28] <pcwalton> which has to do everything
[17:44:32] <pcwalton> and fast
[17:44:59] *** Joins: ross (ross@moz-8A84103E.br.br.cox.net)
[17:45:10] <pcwalton> I can't really think of a better application to make sure a language really holds together
[17:45:12] <Eridius> pcwalton: developing a large-scale project in the language as it's being developed seems like a great way to make sure the language actually works well
[17:45:17] <pcwalton> yeah
[17:45:50] *** Joins: ksev (DrunkenPan@745B767B.989A61DC.CA5B6332.IP)
[17:46:34] <pcwalton> btw, implementing CSS layout is harder than implementing a compiler :)
[17:46:41] <Eridius> so the one quirk with this encoding idea is going from [u8] to str when it's already utf-8, it seems like overkill to use a ToUTF8 wrapped around a FromUTF8 just to do validation
[17:46:56] <Eridius> but maybe that will compile down nicely? I don't know
[17:47:02] <bstrie> need a wikipedia category for "list of general-purpose programming languages that were originally made specifically for a single large application"
[17:47:06] <Eridius> I suppose I should just implement it, and then benchmark it next to a non-iterator-based utf-8 validator
[17:47:12] <bstrie> C, Rust, Erlang (?)
[17:47:23] <pcwalton> PHP maybe?
[17:47:28] <pcwalton> Personal Home Page
[17:47:44] <pcwalton> Rails would count... if it was a language ;)
[17:47:45] <bstrie> rasmus must have had a badass home page
[17:47:53] <Eridius> CSS layout is crazy
[17:48:24] <pcwalton> imagine implementing a compiler... then having to deal with arbitrary mutations to the IR and updating the assembly code on the fly
[17:48:47] <Eridius> clearly you just recompile the whole thing every time ;)
[17:48:48] <bstrie> isn't that a JIT? :)
[17:48:55] <pcwalton> without recompiling everything
[17:49:10] <pcwalton> bstrie: only if you're JITting self modifying code
[17:49:17] <pcwalton> which to be fair emulators do
[17:49:21] <pcwalton> but dynarec is also very hard
[17:49:43] <bstrie> I thought css layout was handled by a library? what else does libcss do?
[17:49:49] <Eridius> pcwalton: you should just convince Dave Hyatt to leave Apple and come work on Servo ;)
[17:49:57] <bstrie> or am I thinking of one of the other libs, like libharfbuzz or libpuckywuckle
[17:50:00] <Eridius> bstrie: parsing, I assume?
[17:50:10] <pcwalton> bstrie: well, libcss is pretty bad perf wise
[17:50:13] <pcwalton> so we need to replace it
[17:50:13] <Eridius> the problem is when changes are made to CSSOM you have to know what parts of the layout to invalidate
[17:50:21] <pcwalton> but it just does parsing and selector matching
[17:50:23] <bstrie> pcwalton: does firefox use libcss? or any other browser?
[17:50:25] <Eridius> also, the CSSOM API really sucks :/
[17:50:28] <pcwalton> no
[17:50:33] <pcwalton> nobody uses it really
[17:51:11] <pcwalton> yeah, Gecko propagates "dirty bits" to decide what to invalidate
[17:51:17] <pcwalton> based on the changes in the CSSOM
[17:51:23] *** Joins: lkuper (lkuper@moz-C0CD33ED.hsd1.in.comcast.net)
[17:51:32] <pcwalton> then reflow uses the dirty bits to decide what to invalidate
[17:51:49] <pcwalton> WebKit is more direct, it just uses CSSOM changes to reflow directly as I understand
[17:52:07] <pcwalton> Servo is using Gecko's approach because it seems to play better with parallelism
[17:52:08] <Eridius> well it doesn't recalculate layout until something needs it
[17:52:25] <Eridius> if I make 100 changes in a tight loop to the CSS, it should only layout the final one
[17:52:29] <pcwalton> yeah, it has lazy frame construction
[17:53:05] <Eridius> sadly if you need to update the user stylesheet it's not smart about that and forces an entire relayout
[17:53:16] * Eridius works on iBooks, has had to deal with webkit's various idiosyncracies for a while
[17:54:02] <pcwalton> WebKit tries to avoid ever nuking RenderObjects and just restitches them together even when big changes like display: occurs
[17:54:15] <pcwalton> it has some bugs though like if you set display: table-cell
[17:54:17] <pcwalton> it does it wrong
[17:54:20] <Eridius> heh
[17:54:32] <pcwalton> Gecko just gives up and calls this function WipeContainingBlock()
[17:54:42] <pcwalton> which throws away the layout and rebuilds it
[17:54:49] <pcwalton> which is correct but can be slower
[17:54:55] <Eridius> webkit may display wrong, but at least it's fast!
[17:55:02] <Eridius> and that's what matters, right? who cares about correctness
[17:55:21] <pcwalton> well, WebKit's approach should be better, it just requires more work
[17:55:42] <pcwalton> I'm kind of neutral, we're probably going to go with Gecko's approach for display: changes (except display:none) just because it's simpler
[17:55:58] <Eridius> when building a brand new engine, simpler seems good
[17:56:02] <pcwalton> since people usually don't change display: except for none
[17:56:03] <pcwalton> yeah
[17:56:36] *** Quits: jedestep (jedestep@34641662.FB4DE631.66C78B76.IP) (Ping timeout)
[17:58:30] <Eridius> blah, laptop's about dead. Good thing I'm picking up a new power adaptor today
[17:58:52] <cmr> pcwalton: yeah, that's why I'm working on the compiler and not servo ;)
[17:59:02] <cmr> (re: @pcwalton | [17:46:34] btw, implementing CSS layout is harder than implementing a compiler :) )
[17:59:08] <pcwalton> servo is fun! but yeah, it's tricky
[17:59:15] <pcwalton> there's a lot of low hanging fruit
[17:59:21] <pcwalton> e.g. backgrounds or border styles would be easy
[18:00:32] *** Joins: jedestep (jedestep@34641662.FB4DE631.66C78B76.IP)
[18:01:02] *** Joins: cowboyd (cowboyd@1D8844A7.1B729417.CEE440B6.IP)
[18:01:07] *** Joins: spider-mario (spidermari@moz-81131DB6.fbx.proxad.net)
[18:04:09] *** Joins: mib_2bp0ey (Mibbit@moz-D3D15A0C.vie.surfer.at)
[18:04:46] *** Joins: vk (vk@moz-389FEE13.hsd1.ca.comcast.net)
[18:05:32] <jfbk> some macros for trait impls for fixed-len vecs: https://gist.github.com/jfager/5936197
[18:05:57] *** Joins: jpochyla (jpochyla@moz-8D99AE5D.broadband18.iol.cz)
[18:06:15] *** Quits: maxli (maxli@B5559308.9C54E60.2FA4EA88.IP) (Quit: Leaving.)
[18:06:16] *** Quits: lucian (lucian@6B2B4644.4304AE1E.CE5E78F6.IP) (Ping timeout)
[18:06:59] <doener> t
[18:07:16] <doener> oops
[18:10:22] <engla> needs review, adding vec.pop_opt().  https://github.com/mozilla/rust/pull/7602
[18:10:36] <engla> although I feel bad for piling on the PR queue
[18:10:50] *** Quits: hjr3 (hradtke@moz-1EBFFE8.public.wayport.net) (Quit: My MacBook has gone to sleep. ZZZzzz‚Ä¶)
[18:11:22] *** Joins: mnemotic (niko@8FFD1BD2.9D81E74C.53DF0002.IP)
[18:11:57] <cmr> I'll go through later and roll up a bunch I guess
[18:12:05] <engla> ok that's good
[18:12:33] <mnemotic> why is `&mut var` compatible with `&T` but not `*T`? :S
[18:12:49] <cmr> mnemotic: what do you mean?
[18:13:50] <sp3d> safety concerns, since you can safely dereference &mut var but not *T?
[18:14:34] <engla> &mut T coerces to *mut T but not *T
[18:14:53] *** Joins: maxli (maxli@B5559308.9C54E60.2FA4EA88.IP)
[18:15:07] <mnemotic> alright, that makes sense
[18:15:43] <bstrie> rusti: ~1i as *int
[18:15:45] -rusti- <anon>:7:9: 7:20 error: non-scalar cast: `~int` as `*int`
[18:15:46] -rusti- <anon>:7          ~1i as *int
[18:15:49] -rusti-                   ^~~~~~~~~~~
[18:15:50] -rusti- error: aborting due to previous error
[18:15:52] -rusti- application terminated with error code 101
[18:16:38] *** Quits: maxli (maxli@B5559308.9C54E60.2FA4EA88.IP) (Ping timeout)
[18:16:43] <cmr> bstrie: gotta transmute
[18:16:52] <cmr> and you need at least 6 levels in alchemy
[18:17:29] <bstrie> rusti: std::cast::transmute(~1)
[18:17:30] -rusti- more than 5 lines of output, pastebinned: http://sprunge.us/VMNS
[18:17:49] <bstrie> rusti: std::cast::transmute::<*int>(~1i)
[18:17:51] -rusti- more than 5 lines of output, pastebinned: http://sprunge.us/EEhX
[18:18:03] <engla> bstrie: it takes parameters for from and to
[18:18:12] <bstrie> rusti: std::cast::transmute::<~int, *int>(~1i)
[18:18:13] -rusti- <anon>:7:9: 8:5 error: call to unsafe function requires unsafe function or block
[18:18:13] -rusti- <anon>:7          std::cast::transmute::<~int, *int>(~1i)
[18:18:13] -rusti- <anon>:8     };
[18:18:13] -rusti- error: aborting due to previous error
[18:18:13] -rusti- application terminated with error code 101
[18:18:19] <pcwalton> "Higher-order functions simply are not suitable for a system programming language. "
[18:18:23] <bstrie> rusti: unsafe { std::cast::transmute::<~int, *int>(~1i) }
[18:18:24] -rusti- 139984260565248
[18:18:26] <pcwalton> best reddit comment ever
[18:19:21] <bstrie> pcwalton: higher-order functions are simply not suitable, period. nothing useful has ever used them
[18:19:26] *** Joins: Sergio965 (sergiobz@moz-BB21156B.dynamic.csail.mit.edu)
[18:19:40] <cmr> and especially not the kernel
[18:19:49] <bstrie> The Kernel
[18:19:51] <pcwalton> qsort(3) uses higher order functions
[18:19:53] <cmr> seriously people are dumb :\
[18:20:24] <bstrie> pcwalton: source?
[18:20:48] <pcwalton> http://www.reddit.com/r/programming/comments/1hl2qr/rust_07_released/cawiedm?context=3
[18:21:09] *** Joins: hjr3 (hradtke@moz-1EBFFE8.public.wayport.net)
[18:21:59] <mnemotic> pcwalton: you shouldn't read the bottom half of the Internet ;)
[18:22:27] <engla> don't take it too seriously. can't argue with everyone that is wrong
[18:22:51] <mnemotic> that'd be a monumental waste of effort
[18:22:59] <cmr> oh that troll again
[18:23:04] <bstrie> mnemotic: a paradox; both halves of the internet are the bottom half of the internet
[18:23:30] <bstrie> the only winning move is not to read the internet
[18:23:46] <bstrie> in that sense servo is the best web browser around, because it can read the least amount of the internet
[18:23:52] *** Quits: mib_2bp0ey (Mibbit@moz-D3D15A0C.vie.surfer.at) (Quit: http://www.mibbit.com ajax IRC Client)
[18:24:54] <mnemotic> bstrie: 90% of Internet is porn, 5% are cats
[18:25:08] <mnemotic> therefore lynx is superior for reading the Internet
[18:25:19] <cmr> I thought netflix was 90% of the internet
[18:25:21] <mnemotic> or does it have support for images... idk
[18:25:27] *** Joins: int3_ (int3_@moz-ABE52D50.hsd1.ca.comcast.net)
[18:26:08] <Yurume> https://github.com/lifthrasiir/angolmois-rust/commit/55e0226 yeah, I've managed to convert to 0.7.
[18:26:26] <cmr> Yurume: nice!
[18:26:32] *** Joins: maxli (maxli@B5559308.9C54E60.2FA4EA88.IP)
[18:26:36] <Yurume> and github doesn't show the full diff ;)
[18:27:01] <Yurume> that was not very hard, but some tasks were quite mechanical
[18:27:38] <cmr> engla: I think the docs for either shift_opt or pop_opt are wrong
[18:27:47] <cmr> they both claim to remove the first element from the vector?
[18:28:00] <bstrie> Yurume: you should have used amazon mechanical turk to convert to 0.7
[18:28:04] <Yurume> what's going on proper pretty-printing? (it is required for automatic syntax conversion, like go fmt)
[18:28:25] *** Joins: steven_is_false (user@moz-144077DE.bchsia.telus.net)
[18:28:32] <Yurume> bstrie, haha
[18:29:05] <bstrie> Yurume: graydon wants to rewrite the pretty-printer to use the same strategy that gofmt uses iirc
[18:29:11] <bstrie> right now it's unsuitable for that
[18:29:20] <bstrie> but also, gofix doesn't do *everything*
[18:29:42] <bstrie> we've had a lot more enormous changes than go did
[18:30:20] <engla> cmr: oops
[18:30:22] <Yurume> yeah, I finally scrapped `core_compat` over the course, which can't be accomplished with gofix etc.
[18:30:31] <bstrie> for all intents and purposes, go sprang fully formed from the mind of rob pike. p sure gofix was mostly for changing library APIs
[18:30:47] <engla> cmr: that's obviously an error.
[18:31:24] *** Joins: Jesse (jruderman@moz-537BCF9.hsd1.ca.comcast.net)
[18:32:10] <engla> cmr: thanks for pointing that out
[18:35:11] <engla> cmr: btw your question mark might be resolved by saying that 'return' returns from the function, not the match clause (?)
[18:35:40] <cmr> engla: I figured it out
[18:36:59] *** Joins: seth (seth@A01051A9.6F669779.3D1CA460.IP)
[18:37:06] <engla> thanks
[18:37:10] *** Quits: pyrac (pyrac@moz-18D74BD0.w90-60.abo.wanadoo.fr) (Quit: pyrac)
[18:37:13] <engla> comments were fixed
[18:37:22] <cmr> I saw, I r+'d
[18:40:33] *** Joins: jclements (jclements@2557E599.66715431.D25A875A.IP)
[18:41:04] <pcwalton> I think the biggest change that gofix did was semicolons
[18:41:08] <pcwalton> removing them
[18:41:29] <pcwalton> but that's a trivial change
[18:41:47] <pcwalton> (also I don't really like Go's automatic semicolon insertion rules)
[18:42:00] *** Quits: dew (Instantbir@moz-66796D51.dhcp.stls.mo.charter.com) (Ping timeout)
[18:42:19] *** Quits: reyre_ (reyre@moz-9002CDDA.cpe.net.cable.rogers.com) (Client exited)
[18:42:39] <bblum> engla: i disagree with the decision to remove the "sorry" fail message
[18:42:50] *** Joins: mye (mye@moz-B464BB1C.dip0.t-ipconnect.de)
[18:42:58] <bblum> engla: even gcc has "long long long too long for gcc"
[18:43:06] *** Joins: dew (Instantbir@moz-66796D51.dhcp.stls.mo.charter.com)
[18:43:08] *** Quits: mye (mye@moz-B464BB1C.dip0.t-ipconnect.de) (Quit: mye)
[18:43:13] *** Joins: mye (mye@moz-B464BB1C.dip0.t-ipconnect.de)
[18:43:37] *** Joins: reyre_ (reyre@moz-9002CDDA.cpe.net.cable.rogers.com)
[18:43:51] *** Joins: pyrac (pyrac@moz-18D74BD0.w90-60.abo.wanadoo.fr)
[18:45:41] <doener> hmm, when my stage1 compiler dies with a memory leak, that should be an existing bug triggered by my changes, right?
[18:46:03] <cmr> doener: I think so
[18:47:12] <doener> not sure if that makes it any better though. I have no idea how to go from here
[18:49:44] *** Joins: MaikKlein (maik@moz-DD7D2879.dip0.t-ipconnect.de)
[18:50:04] *** Quits: maxli (maxli@B5559308.9C54E60.2FA4EA88.IP) (Quit: Leaving.)
[18:51:34] <doener> also interesting that I see that failure when compiling libextra, not when compiling libstd
[18:56:01] *** Joins: cp (cp@moz-993078EE.plus.com)
[18:58:24] *** Quits: cowboyd (cowboyd@1D8844A7.1B729417.CEE440B6.IP) (Client exited)
[18:59:41] *** Joins: kesserich (Mibbit@moz-7ABC9BDB.hsd1.pa.comcast.net)
[18:59:58] <engla> bblum: ok, but the messages should be consistent and also clearly say which method was called
[19:00:29] <bblum> it can be "cannot pop() an empty vector"
[19:00:34] <engla> consistency wasn't there before, pop had a fail with informal message and shift just an assert. 
[19:00:43] <bblum> ("sorry, cannot pop() an empty vector", i mean)
[19:00:50] <engla> sure, the head/last did have a format though. and a precedent with _opt()
[19:01:03] <bblum> sure, shift and pop can both say sorry
[19:01:15] <jclements> doener: typically this error comes with a suggestion to enable RUST_LOG. Have you done this? Sorry for the dumb question, but there can sometimes be an unrelated ICE hiding under the memory issue.
[19:01:45] <doener> jclements: seems to be in the clean task shutdown path, no ICE there
[19:01:50] *** Quits: mye (mye@moz-B464BB1C.dip0.t-ipconnect.de) (Quit: mye)
[19:02:09] <jclements> doener: too bad.
[19:02:10] <doener> jclements: happens after the llvm passes, too
[19:02:20] <doener> jclements: so I'd guess it's a valid memleak
[19:02:45] *** Joins: SimonSapin (simon@moz-D0C2F181.zone2.bethere.co.uk)
[19:02:57] <doener> waiting for the run under valgrind to finish
[19:03:26] <engla> bblum: ok I'll add another commit to adjust all the failure messages
[19:03:53] <bblum> thanks :)
[19:05:13] *** Quits: pyrac (pyrac@moz-18D74BD0.w90-60.abo.wanadoo.fr) (Quit: pyrac)
[19:06:40] <engla> bblum: what do you think about these messages? http://paste.debian.net/plain/14614
[19:06:53] <cmr> I think bikeshedding over the message is dumb and what it is now is fine
[19:07:14] <engla> we're done in a sec cmr 
[19:07:28] *** Quits: MaikKlein (maik@moz-DD7D2879.dip0.t-ipconnect.de) (Ping timeout)
[19:07:49] *** Joins: strcat (strcat@moz-54F7FD49.cpe.net.cable.rogers.com)
[19:07:52] <Eridius> engla: should the language really be apologizing?
[19:08:03] * engla hides
[19:08:06] <engla> don't bikeshed
[19:08:08] *** Joins: tedh (tedh@moz-38ABF348.central.biz.rr.com)
[19:08:16] <engla> we're doing what bblum says and we're GTD
[19:08:17] <engla> hehe
[19:08:43] <bblum> Eridius: no but the libraries have a lot to apologise for
[19:08:52] <Eridius> hah
[19:08:55] <doener> we could have flags, like "rustc --apologetic" or "rustc --insulting", so everyone can have its own style
[19:08:58] <engla> rustc, the sorrowful compiler
[19:09:00] *** Quits: BizarreCake (BizarreCak@51AA6B33.6D202491.34A7550B.IP) (Ping timeout)
[19:09:23] <Eridius> rustc --ponies. All error messages are piped through ponysay
[19:09:37] *** Quits: kesserich (Mibbit@moz-7ABC9BDB.hsd1.pa.comcast.net) (Quit: http://www.mibbit.com ajax IRC Client)
[19:10:09] *** Quits: cp (cp@moz-993078EE.plus.com) (Ping timeout)
[19:11:13] <cmr> rustc --fixitforme, truncates all input files to ensure they compile.
[19:11:28] <doener> sounds like f' it js
[19:11:38] <doener> https://github.com/mattdiamond/fuckitjs
[19:12:19] <cmr> hahah
[19:12:39] * strcat likes https://github.com/videlalvaro/gifsockets
[19:13:44] <pcwalton> hmm, HashMap and Json didn't derive Clone before this patch
[19:13:46] <pcwalton> adding it
[19:14:09] <strcat> pcwalton: I think we're supposed to reseed the keys on a hash table clone
[19:14:09] *** Quits: vk (vk@moz-389FEE13.hsd1.ca.comcast.net) (Quit: vk)
[19:14:14] <pcwalton> strcat: I did
[19:14:22] <pcwalton> the old way of using "copy
[19:14:22] <pcwalton> "
[19:14:25] <pcwalton> on it was sketchy to me
[19:14:30] <strcat> ah
[19:15:35] <bstrie> engla: tell bblum that apologizing in error messages makes it seem like the error is the compiler's fault, when in reality it's PEBKAC
[19:15:46] <bstrie> engla: if anything the compiler should be insulting the user for being so incompetent
[19:16:25] <bblum> this is a library failure message though not a compiler one
[19:17:48] <bstrie> if nothing else I think it's a bad precedent to put words in the error message that distract from the meaning
[19:17:53] <bstrie> keep the errors as concise as possible
[19:18:20] <engla> I pushed the additional commit, those with review rights decide
[19:18:45] <engla> I don't either want to have a long discussion about this
[19:18:50] <bstrie> haha
[19:19:08] <bstrie> I'm sure at some point we'll have to redo all the compiler+stdlib errors anyway for internationalization
[19:19:26] <bstrie> damn know I know why people say i18n
[19:19:42] <brendanc> just write them in the same international language ocaml uses for errors :)
[19:19:52] <bblum> it's not too hard of a word to type, at least not on qwerty
[19:19:53] <engla> supposedly the 18 represents 18 omitted letters incuding/not including i and n, I don't know
[19:19:54] <bblum> internationalization
[19:19:58] <bblum> internationalization
[19:20:11] <engla> l10n localization
[19:20:40] *** Quits: strcat (strcat@moz-54F7FD49.cpe.net.cable.rogers.com) (Quit: WeeChat 0.4.1)
[19:20:43] <bstrie> a10n abbreviation
[19:20:47] *** Quits: rusti (rusti@moz-54F7FD49.cpe.net.cable.rogers.com) (Client exited)
[19:20:51] <bblum> localization is significantly harder on the fingers
[19:21:03] *** Joins: cowboyd (cowboyd@moz-1BD02A1E.sw.biz.rr.com)
[19:21:19] <engla> ise spelling is easier on the fingers
[19:21:42] <mnemotic> doener: fuckitjs had me in stitches! :D
[19:21:55] *** Quits: Yurume (yurume@AC58A8CE.8A059B47.E313B915.IP) (Ping timeout)
[19:21:59] <bstrie> l10n is s11y h4r on the f4rs
[19:22:00] *** Joins: pwalton (pcwalton@2557E599.66715431.D25A875A.IP)
[19:22:02] *** Joins: seth_ (seth@A01051A9.6F669779.3D1CA460.IP)
[19:22:12] *** Joins: strcat (strcat@moz-54F7FD49.cpe.net.cable.rogers.com)
[19:22:22] *** Quits: seth (seth@A01051A9.6F669779.3D1CA460.IP) (No route to host)
[19:22:40] *** Quits: pcwalton (pcwalton@43CB6079.66715431.D25A875A.IP) (Ping timeout)
[19:22:40] *** pwalton is now known as pcwalton
[19:22:53] <engla> this code is perfect for newspeak
[19:24:51] <bstrie> this sounds like a challenge
[19:25:42] *** Quits: pnathan (Adium@B9840254.2CD8A5F8.477B877D.IP) (Quit: Leaving.)
[19:28:50] <engla> bors is still waiting on auto-linux-64-opt-vg
[19:29:02] *** Quits: victorporof (victorporo@74A9C5E8.1745F5FA.9B1E38F4.IP) (Quit: victorporof)
[19:29:20] <bstrie> it just occurred to me that my "stuck or slow" game show reduces to the halting problem
[19:29:59] <bblum> of course
[19:30:14] <engla> since it's testing, is the test and the pull broken or not
[19:30:19] <engla> it seems to have passed all other bots
[19:30:41] <doener> is bors' valgrind build only running the tests under valgrind?
[19:31:02] <engla> it's my deque pull so that's why I was wondering. and was watching over it to hope the tests pass
[19:31:35] <bstrie> engla: conceivably we could roll the dice and manually push it to master, presuming that it's fine...
[19:32:13] *** Quits: jpochyla (jpochyla@moz-8D99AE5D.broadband18.iol.cz) (Ping timeout)
[19:33:27] <engla> I'd do that. I know that if this current PR merges there is a two line fix needed in a later PR in the queue
[19:34:22] <engla> maybe you get the testsuite log if the vg bot is interrupted? they are not available now
[19:34:27] <engla> then you have more info
[19:36:09] <bstrie> strcat: no need to strain yourself by responding to reddit trolls :)
[19:36:31] <strcat> bstrie: as long as other people are still upvoting me, it means someone else is reading them ;p
[19:36:38] <bstrie> haha
[19:37:27] * strcat is going to give removing ~ headers another shot
[19:37:33] <strcat> stupid take glue
[19:37:54] <engla> I upvoted the pointer guy.. when everyone posts interesting comments in response to it, you have to upvote so that it becomes visible
[19:38:47] *** Quits: msingle (Thunderbir@moz-930E5D97.hr.hr.cox.net) (Quit: msingle)
[19:40:56] <pcwalton> getting through removing all "copy" from the tests
[19:40:57] *** Joins: dwhyte (dwhyte@ED9190FB.B72E355F.7BF4A4B0.IP)
[19:41:01] <pcwalton> it's all done, just needs to be compiling
[19:41:06] <pcwalton> already done one round through, time for another
[19:42:05] *** Quits: dew (Instantbir@moz-66796D51.dhcp.stls.mo.charter.com) (Client exited)
[19:43:25] *** Quits: seth_ (seth@A01051A9.6F669779.3D1CA460.IP) (Input/output error)
[19:43:27] *** Joins: maxli (maxli@B5559308.9C54E60.2FA4EA88.IP)
[19:43:34] <bstrie> pcwalton: are these unnecessary copies or are you converting to .clone() ?
[19:45:27] *** Quits: wilsonk|2 (kvirc@moz-39EFBFC2.cg.shawcable.net) (Ping timeout)
[19:45:42] <strcat> meh
[19:45:44] <strcat> pub fn simplified_glue_type(tcx: ty::ctxt, field: uint, t: ty::t) -> ty::t {
[19:45:46] <strcat> this is really a problem
[19:45:58] <strcat> it pretends ~[] is ~T ;[
[19:47:07] <pcwalton> yeah, that's bad
[19:47:08] <bstrie> honestly I'm not even sure what the glue is
[19:47:12] * strcat tries without simplifying it
[19:47:24] <strcat> pcwalton: it can go back to pretending that when I remove headers from ~[] actually
[19:47:26] <strcat> but for now...
[19:47:27] *** Quits: hjr3 (hradtke@moz-1EBFFE8.public.wayport.net) (Quit: My MacBook has gone to sleep. ZZZzzz‚Ä¶)
[19:47:40] <strcat> although I'm sure this kind of thing makes invalid casts
[19:49:00] <strcat> bstrie: the trick is that now we've trained people who don't use rust on r/programming to downvote those trolls
[19:49:08] <strcat> the comments are really a lot saner than they used to be
[19:49:10] *** Quits: steven_is_false (user@moz-144077DE.bchsia.telus.net) (Ping timeout)
[19:49:38] * strcat hopes this works
[19:49:52] <strcat> although malloc pretending ~fn is @T instead of ~T like it did before might break
[19:49:57] <strcat> I'm hoping it just casts from it immediately...
[19:50:26] *** Joins: wilsonk|2 (kvirc@moz-39EFBFC2.cg.shawcable.net)
[19:52:04] *** Joins: dew (Instantbir@moz-66796D51.dhcp.stls.mo.charter.com)
[19:54:21] <strcat> ugh and unique + managed-unique are treated the same
[19:54:23] <strcat> hm
[19:54:39] <bstrie> now's the time to remove managed!
[19:55:07] <bstrie> wait, you mean there's special code for @~T ?
[19:55:13] <strcat> no
[19:55:16] <strcat> ~T containing @
[19:55:19] <strcat> is managed-unique
[19:55:24] <strcat> and ~[T] containing @
[19:55:29] <bstrie> I'd call that unique-managed :P
[19:55:38] <strcat> the unique pointer is managed
[19:55:41] <strcat> that's why
[19:55:54] *** Joins: pnathan (Adium@B9840254.2CD8A5F8.477B877D.IP)
[19:56:01] <strcat> I wonder if we even need simplified_glue_type
[19:56:09] <strcat> it seems like it might be there just to add a shortcut
[19:56:14] <bstrie> is it really special-cased for containing @ or is it just for containing any non-Send type?
[19:56:17] <strcat> @
[19:56:41] <strcat> unique and managed-unique are completely different code paths with the unique headers removed
[19:56:55] <strcat> ~T where T is non-managed (there's no trait) will have no headers
[19:57:00] <strcat> 8 byte alloc -> 8 byte malloc
[19:57:14] <strcat> with @ inside it, it will still have 4 word headers
[19:58:03] <strcat> and since that means it misses the 32-byte size class, it will do a 64-byte allocation
[19:58:09] <strcat> instead of 16
[19:58:20] *** Joins: webber46 (webber46@moz-98D2F3C5.cust.bredband2.com)
[20:00:54] *** Quits: TylerE (TylerE@30EB7FA0.D733EB4E.5E8712DE.IP) (Client exited)
[20:02:08] *** Quits: pnathan (Adium@B9840254.2CD8A5F8.477B877D.IP) (Ping timeout)
[20:04:39] *** Joins: wilsonk-laptop (kvirc@moz-39EFBFC2.cg.shawcable.net)
[20:05:12] *** Quits: wilsonk|2 (kvirc@moz-39EFBFC2.cg.shawcable.net) (Ping timeout)
[20:05:52] <strcat> ugh
[20:05:57] <strcat> I can't figure out why this invalid store happens
[20:06:00] *** Joins: Blei (philipp@moz-650B9C6A.cust.bluewin.ch)
[20:06:49] *** Quits: tiffany (kawaii@moz-1E0FE6E8.dhcp.embarqhsd.net) (Ping timeout)
[20:08:03] *** Quits: diegoyam (quassel@FF9B1514.A4EC3D18.3A1EC144.IP) (Ping timeout)
[20:08:54] <doener> hm, is it expected that compiling libextra under valgrind takes more than half an hour?
[20:09:15] <bstrie> actually, I just got a brilliant idea
[20:09:20] *** Quits: txdv (quassel@966F3542.3BA477DA.14C26596.IP) (Ping timeout)
[20:09:21] *** Joins: diegoyam (quassel@FF9B1514.A4EC3D18.3A1EC144.IP)
[20:09:29] <bstrie> if we just delete nearly all of libextra, compile times will go down
[20:09:41] <mnemotic> brilliant!
[20:09:45] *** Joins: txdv (quassel@966F3542.3BA477DA.14C26596.IP)
[20:09:49] <Eridius> we didn't need that baggage anyway
[20:09:59] <mnemotic> we didn't want that code anyways
[20:10:12] <strcat> we might as well delete stuff like rope
[20:10:50] <strcat> and arena
[20:11:02] <bstrie> it's always in source control if we want it back
[20:11:15] <bstrie> leaving rope around is like leaving around commented-out code
[20:11:48] <strcat> arena isn't going to work anymore, it uses the header tydesc afaict
[20:12:04] *** Joins: Earnestea (earnest@2A2BF8F5.321FA5E6.BFD1ABFD.IP)
[20:12:14] <strcat> maybe it makes those itself
[20:12:15] *** Quits: Earnestly (earnest@2A2BF8F5.321FA5E6.BFD1ABFD.IP) (Ping timeout)
[20:12:51] <jedestep> I don't suppose there's an MD5 library out there somewhere?
[20:13:03] <strcat> just call openssl
[20:13:05] <engla> I was just going to ask why md4 is in there
[20:13:30] <jedestep> it does seem weird to have md4 but not md5
[20:13:39] <bstrie> strcat: didn't you say that extra::deque needs a rewrite
[20:13:50] <jld> So: `let a: [int, ..4294967296] = [];`.  Should that be a type error?
[20:13:52] <strcat> bstrie: not as in it needs to be removed
[20:13:53] <SiegeLord> It seems weird to be missing all sorts of things people haven't yet written ;)
[20:13:57] *** Quits: diegoyam (quassel@FF9B1514.A4EC3D18.3A1EC144.IP) (Client exited)
[20:13:58] <strcat> as in it could use unsafe code and be more efficient
[20:14:07] <Eridius> jedestep: I've been maintaining a fork of rustcrypto for current master at https://github.com/kballard/rustcrypto
[20:14:13] <Eridius> this is a set of OpenSSL libcrypto bindings. should have MD5
[20:14:24] <jedestep> Eridius: wonderful thank you :D
[20:14:40] <bstrie> jld: is it now?
[20:15:21] <jld> bstrie: Depends on whether your rustc is 32-bit or 64-bit.  Note: not the target's word size; the host's.
[20:15:29] <engla> I didn't understand graydon's suggestion for deque. You can use a backing vector with init() values but it's going to crash if code traverses that vector (which fmt's %? does)
[20:15:57] <strcat> fmt's %? is incorrect
[20:16:10] <strcat> it should be unsafe anyway
[20:16:13] *** Joins: diegoyam (quassel@FF9B1514.A4EC3D18.3A1EC144.IP)
[20:16:19] <engla> it's really neat for debugging
[20:16:24] <strcat> yeah but it should be unsafe
[20:16:47] <strcat> all reflection like that should, it lets you see in priv fields
[20:16:59] <strcat> and you can't expect them to be valid, they don't have to be
[20:17:05] <engla> I understood graydon as deque could be implemented with ~[] and using std::unstable::intrinsics::init() for the unoccupied slots
[20:17:10] <engla> and it works
[20:17:10] <bstrie> why is reading priv fields unsafe?
[20:17:18] <strcat> bstrie: because you don't know that they are valid objects
[20:17:53] <Eridius> there should be a trait to let you support %? safely
[20:17:57] <Eridius> one that supports deriving()
[20:18:02] <bstrie> whereas you can assume that all public fields are valid?
[20:18:07] <strcat> bstrie: yes
[20:18:55] *** Joins: tiffany (kawaii@moz-1E0FE6E8.dhcp.embarqhsd.net)
[20:19:12] <strcat> Eridius: that's not %? then
[20:19:22] <strcat> that's just a sane Writer-based string conversion
[20:19:39] *** Joins: pnathan (Adium@B9840254.2CD8A5F8.477B877D.IP)
[20:19:45] <strcat> the purpose of %? is reflection, and reflection like that is unsafe
[20:19:51] <Eridius> strcat: well the point of %? is to show you the structure of something. So why not let types declare that they can expose their structure safely as a string
[20:19:53] <jedestep> Eridius: I feel like that's sort of the intent of ToStr
[20:20:02] <strcat> Eridius: because that's not the point of %?
[20:20:15] <strcat> the entire reason %? exists is to override what the objects think and just print the structure
[20:20:15] <Eridius> strcat: is "being unsafe" really a design goal of %?
[20:20:18] <strcat> Eridius: yes
[20:20:43] <Eridius> strcat: "being unsafe" is a side-effect of the goal of printing the structure
[20:20:54] <strcat> Eridius: %? doesn't exist to call a trait
[20:20:57] <engla> maybe %? shouldn't try to deref ~T that are zero'd out
[20:20:57] <strcat> it exists for reflection
[20:21:09] <strcat> engla: there are other ways of making it unsafe
[20:21:19] <strcat> fmt!("%?", x) needs to require an unsafe block
[20:21:25] <strcat> incentive to make a proper trait-based alternative
[20:21:36] <strcat> anyway it's unsound so it needs to require unsafe {}
[20:21:49] <engla> it's so useful it should be illegal
[20:22:05] *** Joins: steven_is_false (user@1E3F14AE.29819A33.115CE8E4.IP)
[20:22:07] <strcat> it's for debugging, as you said - it's not an alternative to a proper trait-based conversion
[20:22:17] <strcat> you can't just walk private fields of arbitrary types
[20:22:18] <engla> ok. I'm not one of those core people who even has a clue about where the unsafe level is even
[20:22:33] <engla> sure. the repr of hashmap is useless for example
[20:22:42] <engla> or well, not very readable
[20:22:59] <strcat> engla: walking private fields of potentially invalid types
[20:23:04] <strcat> that's unsafe, you can deref dangling pointers
[20:23:22] <engla> there are different philosophies at play here I think. I'll find a niko quote
[20:23:26] <strcat> private fields don't have to be valid objects that something is able to walk
[20:23:42] <strcat> dangling ptr deref is clearly unsafe
[20:26:14] *** Joins: jpochyla (jpochyla@moz-8D99AE5D.broadband18.iol.cz)
[20:26:47] <engla> ok can't find it
[20:26:55] *** Quits: steven_is_false (user@1E3F14AE.29819A33.115CE8E4.IP) (Ping timeout)
[20:27:04] <engla> something about not passing values like  init() in function arguments
[20:27:22] <SiegeLord> rusti: use std::cast; struct A { a : ~int } let a : A; unsafe { a = A{ a : cast::transmute(0)}; } a
[20:27:51] <engla> rusti is offline
[20:27:52] *** Joins: rusti (rusti@moz-54F7FD49.cpe.net.cable.rogers.com)
[20:30:21] <strcat> engla: https://github.com/mozilla/rust/issues/7606
[20:32:19] *** Joins: pyrac (pyrac@moz-18D74BD0.w90-60.abo.wanadoo.fr)
[20:32:23] <engla> you got pretty far with removing headers now
[20:33:41] <strcat> engla: I guess, but it's nowhere near done
[20:33:43] *** Joins: vk (vk@2AAA6DD0.B568D26C.93B001FA.IP)
[20:33:50] <strcat> there are many places in the compiler still treats managed-unique and unique the same
[20:33:57] <strcat> and pretending ~[] is ~T
[20:34:03] <strcat> treating*
[20:34:29] <strcat> I'm really not going to be able to finish it
[20:34:36] <strcat> not familiar enough with the compiler
[20:38:27] <SiegeLord> Hmm... specifying units via methods... great idea? Like 5.m() / 3.s()
[20:39:15] <SiegeLord> No compile time verification though... not enough metaprogramming
[20:39:31] <strcat> doesn't seem useful if you don't use types
[20:40:00] <strcat> http://msdn.microsoft.com/en-us/library/dd233243.aspx
[20:40:51] <SiegeLord> Well 5.m() will return Meters(5)
[20:41:06] <SiegeLord> Which could be a variant of enum Length
[20:41:10] *** Joins: james4k (james@moz-E7990244.consolidated.net)
[20:41:12] <SiegeLord> You have to stop there though
[20:41:24] *** Quits: Blei (philipp@moz-650B9C6A.cust.bluewin.ch) (Quit: WeeChat 0.4.1)
[20:42:38] <engla> you don't need more than one type per quantity I think
[20:42:51] *** Joins: queos (Mibbit@moz-1ADE39B3.hsd1.ca.comcast.net)
[20:43:27] *** Joins: marc (marc@E31B39DA.F9D61A8.416A0103.IP)
[20:44:05] <strcat> they have dimensions though
[20:44:16] <strcat> F# does this really well
[20:44:43] <SiegeLord> I wonder how widely used it is
[20:45:06] <SiegeLord> I think the D folks managed to implement something like this too, which isn't too surprising
[20:45:06] <engla> the types should make sure you pass a velocity, a distance etc as function arguments
[20:45:11] <engla> actual units used doesn't matter
[20:45:21] <engla> that's just a convenience
[20:45:31] <strcat> engla: dimensions as in....
[20:45:42] <strcat> distance / time
[20:45:44] <strcat> distance / time / time
[20:45:46] <engla> sure
[20:45:47] <strcat> those aren't the same unit
[20:46:06] <strcat> and I don't think rust's type system can express it yet
[20:46:10] <engla> I know enough physics to be able to separate those two :)
[20:46:16] <strcat> since we don't have integers in the type system
[20:47:46] <bjz> it would be great to be able to have consts in parameter lists
[20:48:14] <bjz> would allow you to have units of measure like that
[20:48:19] <engla> strcat: there are tuples though
[20:48:37] <strcat> engla: we lack tuple metaprogramming too
[20:48:42] <doomlord_> i've seen this sort of thing done in c+
[20:49:07] <strcat> I don't think it's at all possible to represent arbitrary dimensions of units
[20:49:09] <strcat> in rust
[20:49:13] <strcat> in C++, sure
[20:49:39] <doomlord_> does f# have a different way of doing it ? i think the way its just possible with ints in the type system is great in C++
[20:49:49] *** Quits: wilsonk-laptop (kvirc@moz-39EFBFC2.cg.shawcable.net) (Ping timeout)
[20:49:58] *** Quits: pcwalton (pcwalton@2557E599.66715431.D25A875A.IP) (Quit: pcwalton)
[20:50:11] <bjz> doomlord_: http://en.wikibooks.org/wiki/F_Sharp_Programming/Units_of_Measure
[20:50:24] <bjz> doomlord_: it's built in I think
[20:50:44] <strcat> http://fsharpforfunandprofit.com/posts/units-of-measure/ is better
[20:50:54] <bstrie> units sounds like a backwards-compatible thing
[20:51:14] <bjz> we'd have to do it at run time in rust, which means we can't have type safety :(
[20:51:32] <strcat> bjz: or speed
[20:51:38] <strcat> so you just wouldn't do it
[20:51:42] * bjz would love the trig functions to output Radians
[20:51:52] <bjz> (or take Radians)
[20:52:02] <bstrie> hey, that's what we could use the spiderweb for. custom units
[20:52:04] <SiegeLord> You can still do it, you just can't combine units
[20:52:06] <bstrie> let x = 1#cm
[20:52:35] <doomlord_> someone said name mangling is the same as in C++ on linux .. does that mean i prototype setup c++ structs with memberfunctions and they would link with rust 'impl' funtions .. 
[20:53:14] <doomlord_> (^mean i could setup c++ struct with .. )
[20:53:15] <strcat> doomlord_: no
[20:53:35] <bstrie> I don't think we mangle the same as C++
[20:53:40] <strcat> the name mangling isn't the same as C++, and we don't support the C++ calling conventions for methods or virtual functions at all
[20:53:47] <bstrie> we might mangle in the same sort of philosophy as C++ though
[20:53:51] <doomlord_> virtuals i wouldn't expect
[20:53:56] <strcat> bstrie: not really, C++ has sane mangling
[20:53:57] <strcat> we don't
[20:54:19] <strcat> rust uses hacks like integers of the item id
[20:54:34] <strcat> and the symbols are enormously long, starting large rust programs will be very slow
[20:54:35] <doomlord_> again i wouldn't expect generics/templates to match either..
[20:54:43] <strcat> doomlord_: well methods won't work
[20:55:00] <strcat> and any type that's not POD won't work
[20:55:08] <bstrie> strcat: you should file bugs for all this stuff, you act like these deficiencies are obvious to everyone :)
[20:55:13] <strcat> if the type has a destructor/constructor or private fields in C++, you're out of luck
[20:55:37] <strcat> bstrie: I do, there are just a lot of issues
[20:55:41] <SiegeLord> How does gdb demangle Rust symbols then?
[20:55:44] <strcat> I don't want to spend all day filing bugs
[20:56:04] <strcat> SiegeLord: it doesn't demangle them all the way
[20:56:11] <strcat> it can't because our mangling isn't reversible
[20:56:22] <strcat> and we have all kinds of weird stuff like $LT$ and $UP$ now
[20:56:24] <SiegeLord> Well, it demangles a little bit
[20:56:37] <SiegeLord> So it must resemble some existing mangling protocol
[20:56:40] <engla> what does $UP$ mean?
[20:56:44] <strcat> engla: no clue
[20:56:52] <strcat> but the symbols are ridiculous
[20:56:54] <engla> LT is easy, <
[20:57:51] <strcat> SiegeLord: are you sure you're looking at mangled symbols?
[20:57:54] <strcat> as in, generics
[20:58:06] <SiegeLord> Nope
[20:58:09] <strcat> non-generics aren't mangled
[20:58:29] <strcat> unless the hack of sticking ids on extension methods instead of using the trait name counts
[20:58:43] <SiegeLord> I mean, I see stuff like this: iterator::__extensions__::transform_3366::_9c9d03aa710263a::_00
[20:58:58] <SiegeLord> I assume that's generic
[20:59:01] <strcat> that's not a generic function, it's the extension method hack
[20:59:07] <SiegeLord> Ah...
[20:59:10] <strcat> it doesn't really get mangled, it just uses an irreversible id
[20:59:13] <strcat> 3366
[20:59:27] <strcat> which type is that an iterator implementation for?
[20:59:29] <strcat> no way to know
[20:59:34] <SiegeLord> But what about the ::
[20:59:41] <strcat> what about it?
[20:59:51] <SiegeLord> We really stick that symbol into the mangled name?
[20:59:54] <strcat> ::__extensions__:: means is an implementation of *some* trait for Iterator
[21:00:04] <strcat> SiegeLord: yes, we need some separator
[21:00:34] <strcat> the 3366 is a total hack to make it not conflict with 1) different generic types and 2) different traits
[21:00:56] <strcat> __extensions__ is really IteratorUtil there
[21:00:58] *** Quits: ksev (DrunkenPan@745B767B.989A61DC.CA5B6332.IP) (Ping timeout)
[21:01:18] <strcat> _3366 is the hack to make it not conflict with other traits (you could have Foo with the same trait name + impl for the same type)
[21:01:33] <strcat> and _3366 also makes Iterator<int> not conflict with Iterator<f64>
[21:01:40] <strcat> but anyway that's not mangling - it's irreversible...
[21:01:49] <SiegeLord> Why do we need a separator? D doesn't use one (I think it resembles C++ in that respect)
[21:02:04] <SiegeLord> It's just length, string, length, string etc
[21:02:32] <strcat> that's really far from the biggest issues with it, I don't think it matters if we use :: or not
[21:03:21] <strcat> C++ name mangling can be reversed to a specific method/function + specific type parameters
[21:03:23] <SiegeLord> I see... so Rust's mangled name is just very readable, hehe
[21:03:33] <SiegeLord> (except for all the numbers)
[21:03:44] <strcat> arbitrary numbers ;\
[21:04:17] *** Quits: erickt1 (erickt@8C9ECD8F.3A598286.F12515B4.IP) (Quit: Leaving.)
[21:04:38] <SiegeLord> Well... I mean, it could be more efficient that way
[21:04:59] <SiegeLord> Ability to demangle requires your symbols to be longer than they can be
[21:06:05] <SiegeLord> Well, maybe not... I think just broke information theory there
[21:07:49] *** Joins: hjr3 (hradtke@moz-1EBFFE8.public.wayport.net)
[21:08:24] <cmr> pnathan, hullo
[21:09:41] *** Joins: wilsonk-laptop (kvirc@moz-39EFBFC2.cg.shawcable.net)
[21:09:45] <engla> bors still has that thing.. let's call it the "halting problem"
[21:14:42] *** Joins: donri (dag@moz-9BB61102.tbcn.telia.com)
[21:15:22] *** Quits: pyrac (pyrac@moz-18D74BD0.w90-60.abo.wanadoo.fr) (Quit: pyrac)
[21:16:36] *** Quits: jedestep (jedestep@34641662.FB4DE631.66C78B76.IP) (Ping timeout)
[21:16:53] <jmgrosen> what's the best way for an extern "C" function being used as a callback to communicate to main rust code?
[21:17:30] *** Quits: jclements (jclements@2557E599.66715431.D25A875A.IP) (Quit: jclements)
[21:17:38] <cmr> jmgrosen, a RWARC maybe?
[21:17:58] <cmr> some sort of message queue would be easiest I'd think
[21:18:10] <jmgrosen> cmr: ok, but how do i get it in the callback? with a `static mut`?
[21:18:14] <doener> I must be doing something wrong here, valgrind is running for 99 minutes for a compilation that normally takes 12 seconds
[21:18:26] <cmr> doener, yikes
[21:18:45] <cmr> jmgrosen, I have no idea! hopefully someone else does
[21:19:11] <jmgrosen> cmr: do you know at least if a `static mut` would at the least /work/>
[21:19:13] <jmgrosen> ?
[21:19:18] <cmr> jmgrosen, it should
[21:19:26] <jmgrosen> cmr: ok, i'll try it out
[21:19:53] <bjz> I think aatch was going to fix something with static muts and fns
[21:20:55] <bjz> jmgrosen: for glfw-rs I use tls to store a rust callback, then call that from the C callback
[21:21:36] *** Joins: paupau (NEAT@moz-446DB75D.tmodns.net)
[21:22:20] <jmgrosen> bjz: tls? and i'm trying to get a callback for the glfw window resize, so if there's a higher level way, that would be awesome
[21:22:44] <bjz> are you using my bindings?
[21:22:49] <jmgrosen> bjz: yeah
[21:23:19] <bjz> there is window.set_resize_callback
[21:23:34] <bjz> is that what you want?
[21:23:49] <bjz> or do you want to get the callback after the fact?
[21:24:09] <jmgrosen> bjz: ah, ok, that should work -- my only gripe with it is that i'm trying to avoid GC like the plague
[21:24:19] <bjz> yeah :(
[21:24:29] <bjz> I hate that we have to use @fns
[21:24:44] *** Joins: kkris (kkris@moz-CB70009.yourvserver.net)
[21:24:57] <bjz> I've been talking to jack about possible ways around this
[21:25:12] <jmgrosen> bjz: ok, @fn should be fine for now :P
[21:25:37] <bjz> one of the things we've been considering is having messaging behind the scenes
[21:25:52] <bjz> which might make things easier - I don't know
[21:26:55] *** Quits: dwhyte (dwhyte@ED9190FB.B72E355F.7BF4A4B0.IP) (Ping timeout)
[21:27:13] <bjz> it's definitely something I would love to improve, so if you have any ideas/suggestions, let me know
[21:27:53] <bjz> it would be great to have an example of how best to wrap C callbacks
[21:28:00] <jmgrosen> bjz: will do, but i'm not much of a rust expert yet :/
[21:28:03] *** Quits: jpochyla (jpochyla@moz-8D99AE5D.broadband18.iol.cz) (Ping timeout)
[21:28:25] <bjz> unfortuntely at the moment it's pretty hairy
[21:28:32] *** Joins: dwhyte (dwhyte@ED9190FB.B72E355F.7BF4A4B0.IP)
[21:28:38] <bjz> jmgrosen: np, you will get better!
[21:28:55] <jmgrosen> bjz: i'm certainly trying -- it's quite the language
[21:29:08] <bjz> what do you mean by that?
[21:29:20] <bjz> as in, you think it's worth learning?
[21:29:29] <jmgrosen> bjz: yeah, but also it takes some getting used to
[21:29:33] <bjz> mm
[21:29:52] <jmgrosen> better than c or c++ though :)
[21:29:52] <bjz> it helps that it's hard to screw up memory
[21:29:58] <jmgrosen> definitely
[21:29:58] <bjz> yeah
[21:30:35] <bjz> I always found memory/pointers hard to grasp in C/C++ - Rust has helped me understand
[21:30:50] <doomlord_> intersting, you can't overload functions for parameters... but you can get the same effect by impl for tupls
[21:31:09] <doomlord_> ... and just stuff all the parameters you want to overload for at the front...
[21:31:12] <engla> you can get the same effect with traits yes
[21:31:51] <cmr> doomlord_, there's a workaround for overloading in http://smallcultfollowing.com/babysteps/blog/2012/10/04/refining-traits-slash-impls/
[21:32:04] <doomlord_> earlier i remember asking how you'd do render(renderable, object) .. so its just (renderable,drawable).render() :)
[21:32:09] <bjz> doomlord_: there's a huge plethora of ways of 'hacking' overloading
[21:32:19] <engla> doomlord_: str::split_iter is overloaded like this.. you can split either by a char or by a function
[21:32:29] <mnemotic> why are people so bent on avoiding the GC?
[21:32:50] <bjz> mnemotic: it's poorly implemented atm
[21:33:03] <doomlord_> and to get c++ like deterministic performance ?
[21:33:09] <bjz> mnemotic: also, you shouldn't usually need it in rust
[21:33:13] *** Quits: paupau (NEAT@moz-446DB75D.tmodns.net) (Client exited)
[21:33:16] <bjz> mnemotic: we have found
[21:33:17] <doomlord_> (to use rust as a c++ replacemnet..)
[21:33:52] <strcat> mnemotic: shared ownership + mutability -> dynamic failures and no static mutability control
[21:33:53] <bjz> cmr unfortunately with that method you get a proliferation of RHS traits that you need to add to bounds
[21:34:12] *** Joins: mib_swy5ol (Mibbit@moz-8C830382.superkabel.de)
[21:34:21] <bjz> cmr: I think nmatsakis has plans for a better way
[21:34:22] *** Quits: tiffany (kawaii@moz-1E0FE6E8.dhcp.embarqhsd.net) (Connection reset by peer)
[21:34:24] *** Joins: erickt (erickt@8C9ECD8F.3A598286.F12515B4.IP)
[21:34:26] <cmr> mnemotic, plus not using the GC is always more efficient than using it
[21:34:45] <cmr> bjz, yes, sec
[21:35:01] *** Joins: ghrust (ghrust@2EE61FCC.6A2AE50.F3114085.IP)
[21:35:01] <ghrust> 01[13rust01] 15bors 04force-pushed 06auto from 14cbbf228 to 1458eb70a: 02http://git.io/N3iJvQ
[21:35:01] *** Parts: ghrust (ghrust@2EE61FCC.6A2AE50.F3114085.IP) ()
[21:35:06] *** Joins: ghrust (ghrust@AD60B2E3.6A2AE50.F3114085.IP)
[21:35:06] <ghrust> 01[13rust01] 15bors pushed 5 new commits to 06auto: 02http://git.io/ii3gHg
[21:35:06] <ghrust> 13rust/06auto 14fb689d1 15blake2-ppc: deque: Fix grow condition in add_front...
[21:35:06] <ghrust> 13rust/06auto 14237574b 15blake2-ppc: deque: Add tests and bench tests...
[21:35:07] <ghrust> 13rust/06auto 14d7dec5d 15blake2-ppc: deque: Speed up deque growth by a lot...
[21:35:09] *** Parts: ghrust (ghrust@AD60B2E3.6A2AE50.F3114085.IP) ()
[21:35:09] <cmr> https://github.com/mozilla/rust/issues/7590 is what I've seen
[21:35:15] <mnemotic> thanks for the explanation :)
[21:35:33] <doomlord_> this tuple-based overload would mean an IDE can be smarter in displaying potential functions to call... type several arguemnets then press . for droplist of what functions are available
[21:35:45] <bjz> mnemotic: the good thing is that rust can do all the memory management at compile time. you do have to figure out the lifetimes though
[21:36:03] *** Quits: SiegeLord (sl@moz-CAF07B4C.hsd1.ma.comcast.net) (Quit: It's a joke, it's all a joke.)
[21:36:39] <mnemotic> bjz: that does sound awfully neat :)
[21:37:00] <doomlord_> i dont want to go back to C++ now :)
[21:37:09] <bjz> doomlord_: I dunno... that's hard to make it discoverable
[21:37:22] <bjz> doomlord_: like the argument order could be flipped
[21:38:00] <doomlord_> i think it would still get you further
[21:38:13] <engla> strcat: fyi setting RUST_MIN_STACK larger also helps to get more consistent timings with the bench runner
[21:38:34] *** Joins: mr_boo (Mibbit@F1E839AA.DF28F885.26446627.IP)
[21:38:37] *** Quits: mr_boo (Mibbit@F1E839AA.DF28F885.26446627.IP) (Quit: mr_boo)
[21:38:47] <doomlord_> . call notation is so much more useable here
[21:38:55] *** Joins: fuogo (Mibbit@F1E839AA.DF28F885.26446627.IP)
[21:39:19] *** Quits: fuogo (Mibbit@F1E839AA.DF28F885.26446627.IP) (Quit: http://www.mibbit.com ajax IRC Client)
[21:39:37] *** Quits: erickt (erickt@8C9ECD8F.3A598286.F12515B4.IP) (Connection reset by peer)
[21:39:38] *** Joins: erickt (erickt@8C9ECD8F.3A598286.F12515B4.IP)
[21:41:15] <roo> I avoid GC in rust mostly just because it gives me more information about my program. Like, who depends on what and how.
[21:41:46] <jmgrosen> roo: one of the biggest reasons i do so too
[21:42:03] *** Quits: james4k (james@moz-E7990244.consolidated.net) (Ping timeout)
[21:42:25] <doomlord_> is compile time analysis of cycles possible in any language ?
[21:42:34] *** Joins: glinscott (bzlandfill@789A6618.53EB7C1.FFFE3AA.IP)
[21:42:40] *** Joins: tiffany (kawaii@moz-1E0FE6E8.dhcp.embarqhsd.net)
[21:43:03] <doomlord_> (re using refcounting instead of gc)
[21:45:04] <glinscott> hi there!  i saw the recent post in rust-dev about json performance, and thought exploring that would be a great way to learn some rust.  from a first pass, read_char is quite inefficient, so i was going to convert it to using read_bytes.  however, is there a more efficient fread equivalent.  as i believe read_bytes still returns a new array each time it's called
[21:46:05] <doener> glinscott: yeah, the allocations are killing it. IIRC each read_char call ends up allocating and freeing at least 3 arrays
[21:46:48] *** Joins: tiffnya (kawaii@moz-1E0FE6E8.dhcp.embarqhsd.net)
[21:46:56] *** Quits: tiffany (kawaii@moz-1E0FE6E8.dhcp.embarqhsd.net) (Ping timeout)
[21:47:39] <glinscott> doener: yes, switching to read_bytes of 128k or so should help a huge amount.  even so, it would be even better to avoid a new allocation on each read_bytes if possible.  is this something which will be supported by the io library?
[21:48:29] <doener> glinscott: I'm not familiar with the io rewrite
[21:49:49] <engla> you can profile to see which size buffer is the best
[21:50:25] <glinscott> oh, there is an IO rewrite in progress?
[21:50:39] <engla> I'd guess around 8-32k is better
[21:50:59] <glinscott> engla: yes, definitely.  but for now, just working on switching over to read_bytes.  i got 128k from ultrajson in python land
[21:52:33] <doener> glinscott: http://www.mail-archive.com/rust-dev@mozilla.org/msg04291.html
[21:54:09] <glinscott> doener: ok, great, thanks
[21:55:36] *** Quits: Ralith (ralith@moz-50F3C77.vc.shawcable.net) (Ping timeout)
[21:56:20] *** Quits: vk (vk@2AAA6DD0.B568D26C.93B001FA.IP) (Quit: vk)
[21:56:35] *** Parts: bct (bct@moz-D3BEA05.ed.shawcable.net) (WeeChat 0.4.1)
[22:01:37] *** Quits: cowboyd (cowboyd@moz-1BD02A1E.sw.biz.rr.com) (Client exited)
[22:02:49] * brendanc wants to talk about segmented stacks again
[22:03:59] <brendanc> wonder if you can make morestack cheaper if you spray the tiny stacks evenly around your address space, then mremap to grow the stack when you need to
[22:05:42] *** Quits: hjr3 (hradtke@moz-1EBFFE8.public.wayport.net) (Quit: My MacBook has gone to sleep. ZZZzzz‚Ä¶)
[22:06:17] <strcat> brendanc: you can't mremap
[22:06:21] <strcat> not all pointers are managed
[22:07:48] <brendanc> mremap won't move the address if you don't tell it to?
[22:08:54] <brendanc> you'd have to fall back to the current scheme if the area below you wasn't available. but if you distributed the stacks evenly that would be uncommon
[22:09:09] <strcat> brendanc: won't malloc be grabbing that space?
[22:09:22] *** Quits: mib_swy5ol (Mibbit@moz-8C830382.superkabel.de) (Quit: http://www.mibbit.com ajax IRC Client)
[22:09:25] *** Joins: hjr3 (hradtke@moz-1EBFFE8.public.wayport.net)
[22:10:37] <brendanc> I am naive here but I thought the heap lived at the other end of the address space
[22:11:37] <brendanc> I'm basically suggesting placing the stacks as if they were large, but only mapping the first page
[22:12:00] <strcat> brendanc: I don't see why we wouldn't just map the whole thing though
[22:12:03] <strcat> the OS already deals with this
[22:13:02] * strcat just doesn't see when you would ever have a use case for 500k tasks on 32-bit
[22:13:06] <strcat> no one has 32-bit servers
[22:13:43] <brendanc> mapping the whole thing == large stack == address space shortage?
[22:13:45] *** Quits: maxli (maxli@B5559308.9C54E60.2FA4EA88.IP) (Quit: Leaving.)
[22:14:36] <brendanc> plus you were telling me windows doesn't overcommit. but I don't suppose mremap applies to windows anyway.
[22:15:06] <strcat> brendanc: right but windows doesn't really matter here, it doesn't scale to high load anyway
[22:15:27] <jmgrosen> is there anything like python's `*` to turn a tuple into args?
[22:15:39] <strcat> jmgrosen: no
[22:15:43] <jmgrosen> strcat: ok
[22:16:51] <brendanc> my understanding is people generally agree that large stacks are good on 64-bit. but on 32-bit, that's not settled
[22:17:10] <brendanc> so if you wanted to keep small stacks on 32-bit, how could you make them less expensive?
[22:17:35] <strcat> brendanc: it's settled that the performance hit from them is unacceptable
[22:17:41] <strcat> 10% is unacceptable
[22:17:50] *** Joins: maxli (maxli@B5559308.9C54E60.2FA4EA88.IP)
[22:18:11] <strcat> how do you support both the systems language use case and scaling up tasks for each I/O request
[22:18:17] <brendanc> I'm guessing mremap might be a lot cheaper when the address space is available
[22:18:21] <strcat> I think the answer is to support both large stacks and small ones
[22:18:32] <strcat> brendanc: you'll waste the address space though by leaving holes
[22:18:38] <strcat> you only get 4GiB for everything
[22:18:49] <strcat> if you space out stacks and forbid malloc from grabbing them, you're still wasting it
[22:19:52] <brendanc> I'd think it would waste a lot less than large stacks
[22:20:11] <brendanc> since you'd be able to fit a bunch of small stack tasks in the holes
[22:20:21] <strcat> brendanc: but then you can no longer mremap
[22:20:26] *** Quits: maxli (maxli@B5559308.9C54E60.2FA4EA88.IP) (Ping timeout)
[22:20:37] <strcat> some tasks are fundamentally I/O handlers
[22:20:52] <strcat> some need to be fast, because they're CPU/memory-bound and possibly do FFI
[22:21:07] <strcat> you can't have 500k CPU-bound tasks whether or not the stacks are smal
[22:21:09] <brendanc> I'm not arguing _against_ explicit stack size
[22:21:11] <strcat> there's a *clear* distinction
[22:21:18] <strcat> brendanc: the size doesn't have to be explicit
[22:21:27] <strcat> there are 2 kinds of tasks
[22:21:39] <strcat> either it spends all the time waiting on syscalls or it doesn't
[22:21:49] <strcat> if it doesn't, there's no point in a small stack or a userland thread
[22:22:11] <brendanc> I'm not sure that rule is completely hard and fast
[22:22:12] <strcat> 500k userland tasks with one in a CPU-bound loop -> they are all blocked
[22:22:16] <strcat> brendanc: it is
[22:22:23] <strcat> if one of them blocks on CPU, it blocks the entire stack
[22:22:28] <strcat> you already have to think about this
[22:23:02] *** Joins: ghrust (ghrust@CFE85B59.6A2AE50.F3114085.IP)
[22:23:02] <ghrust> 01[13rust01] 15bors 04force-pushed 06auto from 14984824a to 1458eb70a: 02http://git.io/N3iJvQ
[22:23:02] *** Parts: ghrust (ghrust@CFE85B59.6A2AE50.F3114085.IP) ()
[22:23:03] *** Joins: ghrust (ghrust@9C8B94D4.6A2AE50.F3114085.IP)
[22:23:03] <ghrust> 01[13rust01] 15bors pushed 2 new commits to 06auto: 02http://git.io/SLOppA
[22:23:03] <ghrust> 13rust/06auto 14d7474b6 15Alex Crichton: Add rusti/rustpkg to check-lite
[22:23:03] <ghrust> 13rust/06auto 1404fe441 15bors: auto merge of #7568 : alexcrichton/rust/check-lite, r=pcwalton...
[22:23:03] *** Parts: ghrust (ghrust@9C8B94D4.6A2AE50.F3114085.IP) ()
[22:23:10] <brendanc> nothing stops you from having a task that changes personality
[22:23:13] <brendanc> right?
[22:23:19] <strcat> brendanc: you can't really do that
[22:23:33] <strcat> brendanc: if it starts using CPU and it's a userland thread, it blocks that entire OS thread
[22:23:39] <strcat> userland threads don't have preemption
[22:23:53] <strcat> if they did preempt, they'd be useless
[22:24:11] <brendanc> why is using CPU == having a large stack?
[22:24:49] <strcat> brendanc: because the only use case for small stacks is scaling up for I/O requests
[22:24:54] <strcat> if they start doing CPU work, it won't scale
[22:25:45] <strcat> I'm not saying we should never allow an OS thread with a small stack
[22:25:51] <strcat> but it's an incredibly rare use case - what is it for?
[22:26:05] <strcat> we should cover the *real* use cases well
[22:26:08] <strcat> not theoretical ones
[22:26:13] <strcat> rust is too slow to be a systems language right now
[22:26:20] <strcat> the main real use case for rust isn't met
[22:26:49] * strcat shrugs
[22:27:00] <Earnestea> Is it far off?
[22:27:07] <strcat> Earnestea: yes, it's far off
[22:27:08] <brendanc> I like large stacks, and it's great if the developer can mark the expected stack usage of a task too
[22:27:26] <strcat> Earnestea: if you just have loops and hardware sized ints, it's as fast as C++
[22:27:38] <strcat> because of segmented stacks, as soon as you touch something like allocation, it's 3-5x slower
[22:27:41] <brendanc> just would like it if the developer weren't forced to do it
[22:28:01] *** Quits: glinscott (bzlandfill@789A6618.53EB7C1.FFFE3AA.IP) (Quit: CGI:IRC (Ping timeout))
[22:28:25] <strcat> brendanc: I think we should have a working solution before trying to come up with tricky heuristics
[22:28:30] <strcat> we need a baseline to compare to
[22:28:35] <brendanc> yes, agree
[22:28:42] <brendanc> these things are all complementary
[22:28:53] <brendanc> doing one doesn't prevent another
[22:28:57] <strcat> brendanc: yeah, I know
[22:29:03] <strcat> I just don't like the idea of doing anything fancy
[22:29:13] <strcat> we have a lot of attempts to do fancy stuff right now and in every case it's a huge failure
[22:29:18] <brendanc> :)
[22:29:42] <strcat> the inline(always) stuff that's now mostly gone for example
[22:29:48] <brendanc> that's why I tried to just turn on large stacks on 64-bit yesterday :)
[22:30:03] <strcat> brendanc: but I think that hides the problem, x86 needs to be fast too
[22:30:22] <strcat> we all use x86_64 so we're never going to care or fix it
[22:30:39] <brendanc> that's the point :)
[22:30:50] <strcat> if we don't have a better solution than big stacks on x86 we should just use them there too
[22:31:05] <strcat> rust has to perform well with 1 thread before we worry about scaling
[22:31:09] *** Parts: mnemotic (niko@8FFD1BD2.9D81E74C.53DF0002.IP) ()
[22:31:11] *** Joins: james4k (james@moz-E7990244.consolidated.net)
[22:31:50] <brendanc> rust does advertise a fancy scalable concurrency model though
[22:31:50] <strcat> I just don't think anyone is going to use the language if it's not fast - you pay for complexity with borrowed pointers and ownership already
[22:32:14] <strcat> brendanc: it's not as central to the current language as ownership, destructors and borrowed pointers
[22:32:30] <strcat> rust is primarily a systems language, it might not be what it was intended for - but no one is writing servers in rust
[22:32:36] <brendanc> the memory model is the most attractive thing to me about it
[22:32:38] <strcat> people are writing games, emulators, little baremetal things
[22:32:47] <strcat> there isn't even an http server
[22:33:07] <strcat> why bother trying to scale before we can make an http connection at all? :|
[22:33:32] <strcat> it's an imagined use case as of right now
[22:33:42] <brendanc> there's no real tension on 64-bit anyway
[22:33:53] <strcat> servo doesn't need lightweight threads on 32-bit
[22:34:10] <strcat> I really doubt a browser needs even 10k concurrent I/O tasks
[22:34:31] * strcat shrugs
[22:34:42] * brendanc wouldn't speculate
[22:34:52] <strcat> anyway I just think we're not meeting the needs of any specific niche well right now
[22:35:07] <brendanc> turn on large stacks on 64-bit :)
[22:35:10] <strcat> brendanc: we also need to purge usage of libc before segmented stacks work
[22:35:15] <strcat> on 32-bit too
[22:36:34] *** Joins: jpochyla (jpochyla@moz-8D99AE5D.broadband18.iol.cz)
[22:36:39] <jmgrosen> it's probably something stupid, but what's wrong with just "extern mod extra; use extra::arc;"?
[22:38:24] *** Quits: jpochyla (jpochyla@moz-8D99AE5D.broadband18.iol.cz) (Ping timeout)
[22:38:24] *** Quits: hjr3 (hradtke@moz-1EBFFE8.public.wayport.net) (Ping timeout)
[22:39:14] <strcat> wow wikipedia's new editing mode is horrific
[22:39:34] <strcat> they took something hard to use and made it impossible to use
[22:40:22] <strcat> so... now you have to deal with a clunky GUI to select areas, and you still have mediawiki markup inside it to edit manually
[22:40:27] * strcat shrugs ;p
[22:41:38] *** Quits: km (quassel@FDBAF0A0.DBF71E41.29C67456.IP) (Ping timeout)
[22:41:49] *** Joins: km (quassel@FDBAF0A0.DBF71E41.29C67456.IP)
[22:43:00] *** Quits: sawrubh (uid6719@moz-D8B63698.irccloud.com) (Client exited)
[22:43:05] *** Quits: wilfred (uid159@moz-C944F5EC.irccloud.com) (Input/output error)
[22:43:05] *** Quits: geomyidae__ (uid214@moz-C944F5EC.irccloud.com) (Input/output error)
[22:43:05] *** Quits: Aetherspawn_BNC (uid6924@moz-C944F5EC.irccloud.com) (Input/output error)
[22:43:05] *** Quits: jyeo (uid12229@moz-C944F5EC.irccloud.com) (Input/output error)
[22:43:05] *** Quits: gazoombo (uid6629@moz-C944F5EC.irccloud.com) (Input/output error)
[22:43:05] *** Quits: ggherdov_ (uid11402@moz-C944F5EC.irccloud.com) (Broken pipe)
[22:48:17] <engla> wikipedia also moved to a new programming language for templates
[22:48:23] <engla> ..lua!
[22:49:52] *** Joins: glinscott (garylinsco@789A6618.53EB7C1.FFFE3AA.IP)
[22:50:09] *** Quits: SimonSapin (simon@moz-D0C2F181.zone2.bethere.co.uk) (Ping timeout)
[22:50:25] *** Joins: Ralith (ralith@moz-4D9F8DC3.wireless.sfu.ca)
[22:50:56] *** Quits: int3_ (int3_@moz-ABE52D50.hsd1.ca.comcast.net) (Client exited)
[22:51:43] *** Quits: spider-mario (spidermari@moz-81131DB6.fbx.proxad.net) (Input/output error)
[22:51:44] *** Joins: vk (vk@2AAA6DD0.B568D26C.93B001FA.IP)
[22:53:06] *** Quits: donri (dag@moz-9BB61102.tbcn.telia.com) (Client exited)
[22:57:46] *** Quits: pnathan (Adium@B9840254.2CD8A5F8.477B877D.IP) (Quit: Leaving.)
[22:58:10] *** Joins: pnathan (Adium@B9840254.2CD8A5F8.477B877D.IP)
[23:05:41] <aatch> strcat, you know graydon's confusion about the use-case for StringRef?
[23:05:48] <strcat> aatch: yes
[23:06:29] <aatch> strcat, it's especially hilarious because _he himself implemented something similar_. In extra::test, there is an enum for an owned-or-static string
[23:06:45] * strcat shrugs
[23:08:03] <engla> Eridius: I'll look at the deque iterators now
[23:09:06] *** Quits: dwhyte (dwhyte@ED9190FB.B72E355F.7BF4A4B0.IP) (Client exited)
[23:12:40] <glinscott> i took a first pass over the json code (https://github.com/glinscott/rust/compare/json_perf), converting read_char to read_chars, and got a decent speed-up.  however, it's still burning a huge amount of time in read_chars, which is calling as_imm_buf, and cast::transmute, taking about 25% of the execution time
[23:13:21] <aatch> glinscott, is that with optimizations on?
[23:13:42] <glinscott> an excellent question, i just did "rust build"
[23:13:46] <Eridius> engla: ok
[23:13:53] <strcat> glinscott: so no optimizations
[23:14:02] <strcat> you need to optimize to get any meaningful numbers
[23:14:13] <aatch> glinscott, yeah, our un-optimzed output terrible.
[23:14:25] <glinscott> ok, cool.  so "rust build -O ‚Ä¶" ?
[23:15:02] <aatch> glinscott, if that works, I don't really use the rust tool
[23:15:07] <aatch> I just rustc
[23:15:43] *** Joins: cr (anonymous@moz-1A53C558.dip0.t-ipconnect.de)
[23:18:14] <glinscott> ah, very nice.  from 1.7s to 0.16s with the new code.  old code does not seem to gain at all from optimizations strangely.
[23:18:58] <aatch> glinscott, I can't explain, but it's not surprising
[23:19:37] <engla> also you could maybe benchmark it with RUST_MIN_STACK=8000000  set
[23:20:27] *** Quits: igl (igl@moz-B2AC20A9.adsl.alicedsl.de) (Ping timeout)
[23:20:29] *** Joins: jaen (jaen@moz-E0979827.copit.pl)
[23:20:44] <glinscott> engla: just "export RUST_MIN_STACK=8000000", then run?  or need a rebuild?
[23:20:53] *** Joins: igl (igl@moz-DB2E5F2B.adsl.alicedsl.de)
[23:20:55] <aatch> glinscott, that'll work
[23:21:14] *** Joins: int3_ (int3_@moz-ABE52D50.hsd1.ca.comcast.net)
[23:21:19] <aatch> it just tells the runtime how big the minimum stack size is
[23:21:28] *** Quits: int3_ (int3_@moz-ABE52D50.hsd1.ca.comcast.net) (Connection reset by peer)
[23:21:43] *** Joins: int3_ (int3_@moz-ABE52D50.hsd1.ca.comcast.net)
[23:21:49] <glinscott> aatch: ok, gave it a try, it didn't seem to change the results
[23:21:58] <glinscott> it looks like it's taking most of it's time in unicode parsing now, which is more sane :)
[23:22:02] <aatch> glinscott, it doesn't always.
[23:22:09] *** kimundi is now known as zz_kimundi
[23:23:53] <aatch> hmm, I think as_imm_buf should probably be marked inline(always)
[23:25:23] <strcat> aatch: it really shouldn't
[23:25:37] <strcat> just make it saner code and it will always get inlined
[23:25:53] <strcat> transmute doesn't get inlined because of codegen bugs
[23:26:09] <aatch> strcat, I meant so it gets inlined /without/ optimization on
[23:26:22] *** Quits: Sergio965 (sergiobz@moz-BB21156B.dynamic.csail.mit.edu) (Ping timeout)
[23:26:28] <strcat> aatch: it shouldn't though, without optimization it's probably 100 instructions
[23:26:28] <aatch> it almost always gets inlined otherwise
[23:27:02] *** Quits: int3_ (int3_@moz-ABE52D50.hsd1.ca.comcast.net) (Ping timeout)
[23:28:06] *** Quits: Excureo (c@moz-EB93D257.static.knwc.wa.charter.com) (Ping timeout)
[23:30:05] *** Joins: Excureo (c@moz-EB93D257.static.knwc.wa.charter.com)
[23:32:02] *** Joins: ghrust (ghrust@5FEF1C87.6A2AE50.F3114085.IP)
[23:32:02] <ghrust> 01[13rust01] 15bors 04force-pushed 06auto from 1404fe441 to 1458eb70a: 02http://git.io/N3iJvQ
[23:32:02] *** Parts: ghrust (ghrust@5FEF1C87.6A2AE50.F3114085.IP) ()
[23:32:03] *** Joins: ghrust (ghrust@9C8B94D4.6A2AE50.F3114085.IP)
[23:32:03] <ghrust> 01[13rust01] 15bors pushed 4 new commits to 06auto: 02http://git.io/233xTA
[23:32:03] <ghrust> 13rust/06auto 14dc9b3ff 15Kevin Ballard: Change signature of Iterator.size_hint...
[23:32:03] <ghrust> 13rust/06auto 1420016b9 15Kevin Ballard: Implement .size_hint() on the remaining Iterator adaptors...
[23:32:03] <ghrust> 13rust/06auto 14770c9f9 15Kevin Ballard: Implement size_hint() on all remaining Iterators...
[23:32:05] *** Parts: ghrust (ghrust@9C8B94D4.6A2AE50.F3114085.IP) ()
[23:32:34] <acrichto1> that's the same spurious failure twice now...
[23:35:55] <brendanc> how do you tell it's spurious?
[23:37:34] *** Quits: FrozenCow (FrozenCow@moz-B2DF4929.chello.nl) (Quit: Leaving)
[23:37:38] <aatch> Holy crap, how did I not know that you could do a backwards search in vim with '?'
[23:37:56] <engla> failure in test run::tests::test_inherit_env  in std
[23:38:06] <engla> unrelated to the changes pushed (it looks like)
[23:38:06] <acrichto1> brendanc: spurious may be the wrong adjective, twice in a row probably means that it actually needs fixing
[23:38:37] <strcat> aatch: heh
[23:38:53] <strcat> since there's n and N I never really care
[23:39:02] <acrichto1> engla: there is unsound behavior in that test, so I'm curious if that's causing the failure
[23:39:10] <strcat> I use the reverse character find though
[23:39:13] <aatch> strcat, I just found it by accident, noticed that my prompt said ?
[23:39:56] <strcat> aatch: but what about more obscure things like all the wonderful forms of text objects
[23:39:58] <strcat> and :TOhtml
[23:40:17] <engla> is TOhtml useful
[23:40:20] <strcat> yes!
[23:40:25] <aatch> strcat, I still don't know most of the ways to move
[23:40:30] <strcat> I like it for making diffs in html with vimdiff
[23:40:45] <strcat> aatch: :help text-objects
[23:40:47] <strcat> ;p
[23:40:49] <strcat> most useful feature
[23:40:57] <strcat> like a" for a quoted thing
[23:41:01] <strcat> da"
[23:41:07] <strcat> deletes "foo" from anywhere inside it
[23:41:09] <strcat> etc.
[23:41:50] * strcat has a plugin to make indented blocks text objects to deal with python too
[23:43:12] <rpearl> https://github.com/michaeljsmith/vim-indent-object
[23:43:13] <aatch> strcat, cool. I like the editing features, like doing a block select and then Inserting at the beginning of every line, at the left-most edge of the block
[23:44:05] *** Quits: eternaleye (eternaleye@moz-76321711.hsd1.wa.comcast.net) (Ping timeout)
[23:44:58] *** Joins: eternaleye (eternaleye@moz-76321711.hsd1.wa.comcast.net)
[23:46:24] <engla> ci)  change inside parantheses etc
[23:49:45] *** Quits: cr (anonymous@moz-1A53C558.dip0.t-ipconnect.de) (Ping timeout)
[23:50:59] *** Quits: vk (vk@2AAA6DD0.B568D26C.93B001FA.IP) (Quit: vk)
[23:51:27] *** Joins: dwrensha (chatzilla@moz-DE44EA45.hsd1.pa.comcast.net)
[23:52:21] *** Joins: vk (vk@2AAA6DD0.B568D26C.93B001FA.IP)

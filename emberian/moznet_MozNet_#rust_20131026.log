[00:00:15] *** Quits: Jesse (jruderman@moz-537BCF9.hsd1.ca.comcast.net) (Ping timeout)
[00:00:46] <weirdo> so i change it to other: &SocketAddr and it says it expects ~str... im so lost
[00:01:44] <kimundi> weirdo: Just paste your code somewhere
[00:02:30] *** Quits: clayton (Mibbit@moz-CF186609.nintendo.com) (Quit: http://www.mibbit.com ajax IRC Client)
[00:02:34] <benh> also is src/libextra/json.rs supposed to have both the "Copyright 2012-2013 The Rust Project Developers" header and a "Copyright (c) 2011 Google Inc." line?
[00:02:50] <benh> I assume the former was added mechanically afterwards
[00:03:16] <weirdo> rusti: impl Ord for ~str { fn lt (&self, other: &SocketAddr) {} }
[00:03:17] -rusti- pastebinned 7 lines of output: http://sprunge.us/fYOM
[00:04:05] <kimundi> rusti: impl Ord for SocketAddr { fn lt (&self, other: &SocketAddr) {} }
[00:04:06] -rusti- pastebinned 10 lines of output: http://sprunge.us/REPW
[00:04:27] <kimundi> you probably want that one ^?
[00:04:39] <weirdo> kimundi: i feel like an idiot. thanks
[00:06:37] *** Quits: mark_edward (quassel@moz-DCB0B750.lightspeed.cicril.sbcglobal.net) (Quit: http://quassel-irc.org - Chat comfortably. Anywhere.)
[00:06:57] *** Joins: mark_edward (quassel@75BF936B.B013F95F.2DC05E66.IP)
[00:07:59] *** Quits: donri (donri@moz-9BB61102.tbcn.telia.com) (Client exited)
[00:08:23] <Sharp> Okay, it ceases to crash if I replace the borrowed string reference with a number (it doesn't work, but it doesn't crash :P).  Let's see if I can isolate it further, it's probably already a known issue.
[00:08:53] <brson> anybody else have opinions on float to ratio conversion https://github.com/mozilla/rust/pull/9838
[00:09:57] *** Quits: leon (leon@moz-87C88638.superkabel.de) (Input/output error)
[00:12:04] *** Quits: eatkinson (eatkinson@moz-261EDE03.hsd1.ca.comcast.net) (Quit: eatkinson)
[00:12:40] <maikeru> is it just me or is std::rt::io's documentation horribly out of date?
[00:13:33] <cmr> maikeru: are you looking at the 0.8 docs?
[00:14:01] <maikeru> no, master.
[00:14:49] <Sharp> Yeah, it doesn't happen with a borrowed reference to a number either, only a string.
[00:15:41] *** Quits: squiddy (squiddy@moz-90823E24.adsl.alicedsl.de) (Ping timeout)
[00:16:29] <dbaupp> brson: it's pretty hard to get correct; I think bill-myers objections are blockers for that landing.
[00:17:09] <brson> dbaupp: so is ironpython just doing something wrong, or useless?
[00:17:15] *** Joins: maik (maik@moz-10F9C3B5.dip0.t-ipconnect.de)
[00:17:36] <dbaupp> brson: is that ironpython's implementation?
[00:17:55] <brson> supposedly
[00:18:10] <dbaupp> ah, link in the PR.
[00:18:24] <dbaupp> at the very least I think it should return Option<...> to handle infinite and NaN
[00:18:33] <maikeru> so like.. write_line doesn't exist any more?
[00:18:34] <dbaupp> *infinity
[00:18:50] <Sharp> It seems to be failing at this assertion in char_range_at / multibyte_char_range_at: let w = UTF8_CHAR_WIDTH[val] as uint; assert!((w != 0));
[00:19:23] <dbaupp> Sharp: code?
[00:19:35] *** Quits: Ferreus (ferreus@moz-9EABADA2.pools.arcor-ip.net) (Quit: WeeChat 0.4.2)
[00:19:54] <Sharp> Let me gist the whole thing.
[00:20:25] *** Quits: Ralith (ralith@A8995AA9.62B6AF6A.922221DB.IP) (Ping timeout)
[00:20:54] <brson> maikeru: write_line doesn't appear to exist. acrichto do you know if we have a replacement for it yet?
[00:21:19] <dbaupp> brson: some googling suggests e.g. http://www.math.niu.edu/~rusin/known-math/95/rationalize might be better. (But I haven't read it yet.)
[00:21:25] <maikeru> I think I have to just use write(str.as_bytes) or similiar
[00:21:36] <acrichto> maikeru: dealing with strings on readers/writers currently is not a fantastic story, but this is intentional currently
[00:21:46] *** Quits: dherman (dherman@moz-DFAA4E15.p2p.sfo1.mozilla.com) (Quit: dherman)
[00:21:52] <dbaupp> brson: I'll comment as such
[00:21:55] <acrichto> we plan on improving it (having a write_str/write_line method equivalent), but we want to flesh out the encoding story first
[00:22:14] <maikeru> alright.. I'll see what I can do with what we got then :)
[00:22:24] <maikeru> just wanted to make sure I wasn't going crazy
[00:22:32] <acrichto> maikeru: also yeah the documentation is falling out of date kinda quickly, but I hope to get around to it soon!
[00:22:33] *** Quits: tiffany (kawaii@moz-EB8B0C08.dhcp.embarqhsd.net) (Ping timeout)
[00:22:44] <Sharp> dbaupp: https://gist.github.com/pythonesque/7163820
[00:22:47] <acrichto> the state of I/O is starting to hone in on a final "we'd like to push this" position
[00:23:29] <brson> dbaupp: thanks
[00:23:48] <benh> I recall that "let's look at how other libraries/languages do it" process, did there end up being any particular inspiration for our IO API or are you pretty much tackling unique-to-rust concerns right now?
[00:23:55] <Sharp> Doesn't actually work yet, but I'm not primarily interested in that aspect of it right now :P
[00:24:04] *** Joins: RMF (RMF@moz-3DF68881.dsl.telepac.pt)
[00:24:39] *** Joins: tiffany (kawaii@moz-28A8742A.dhcp.embarqhsd.net)
[00:25:34] <brson> benh: .NET and Go were the ones we looked at most closely, but we weren't very thorough. there are some rust-specific concerns thanks to linearity
[00:25:44] <dbaupp> Sharp: what's the error? an assertion with string handling?
[00:25:48] <Sharp> Yeah.
[00:25:53] <Sharp> task <unnamed> failed at 'assertion failed: (w != 0)', /home/ubuntu/rust/rust-0.8/src/libstd/str.rs:2052
[00:26:05] <dbaupp> can you get a backtrace with gdb?
[00:26:09] <Sharp> On 0.7 it was just segfaulting, so that's an improvement :)
[00:26:12] <Sharp> Sure, hold on.
[00:26:16] *** Quits: refold (gman@moz-42D68426.a258.priv.bahnhof.se) (Quit: leaving)
[00:26:25] <dbaupp> either `catch throw` or `break rust_begin_unwind`
[00:27:40] *** Joins: ksf (ksf@moz-7906A1B7.adsl.hansenet.de)
[00:28:25] <weirdo> okay .. so i wrote out some code for lt in std::cmp::Ord. only to find it doesnt want it to return a boolean value, but it wants std::bool. and to use std::bool, i have to implement the trait?
[00:29:00] <dbaupp> that sounds weird
[00:29:09] <dbaupp> I don't think that is correct.
[00:29:21] <Sharp> dbaupp: https://gist.github.com/pythonesque/7163820#file-gistfile1-txt
[00:29:39] <weirdo> i have..
[00:29:44] *** Joins: barosl (barosl@3DE683B6.E551553C.7544CABF.IP)
[00:29:59] <dbaupp> rusti: struct Backwards { x: int } impl Ord for Backwards { fn lt(&self, other: &Backwards) -> bool { self.x > other.x } } Backwards { x: 0  } < Backwards { x: 1 }
[00:30:00] -rusti- false
[00:30:04] <dbaupp> weirdo: ^
[00:30:13] <weirdo> rusti: fn lt(&self, other: &socketAddr) { *codeblock* return true/false}
[00:30:14] -rusti- pastebinned 9 lines of output: http://sprunge.us/DjgQ
[00:30:36] <dbaupp> Sharp: looks like it's this line https://gist.github.com/pythonesque/7163820#file-phonebook-rs-L148
[00:30:48] <dbaupp> Sharp: based on https://gist.github.com/pythonesque/7163820#file-gistfile1-txt-L22
[00:31:07] <Sharp> Yeah, that's my suspicion as well, but I'm not sure why that should be happening.
[00:31:16] <Sharp> I didn't use any unsafe functions (that I know of).
[00:31:27] <dbaupp> that's really strange.
[00:31:41] <dbaupp> can you try just println(num)?
[00:31:52] <Sharp> I had that before, I'm pretty sure it did the same thing
[00:32:05] <Sharp> But let me try putting it back
[00:32:42] <dbaupp> hm, how about `printfln!("%?", num.as_bytes())` too? (and, if that works, show the output)
[00:32:45] *** Quits: DAddYE (DAddYE@moz-61EB081B.hfc.comcastbusiness.net) (Client exited)
[00:32:48] <Sharp> "error writing buffer"
[00:32:49] <Sharp> Bad address
[00:32:49] <Sharp> task <unnamed> failed at 'explicit failure', /home/ubuntu/rust/rust-0.8/src/libstd/io.rs:1269
[00:32:53] <Sharp> (Before num.as_bytes())
[00:32:59] <Sharp> I'll try with num.as_bytes().
[00:33:08] <Sharp> You think it's an encoding issue?
[00:33:08] *** Joins: DAddYE (DAddYE@moz-61EB081B.hfc.comcastbusiness.net)
[00:33:21] <dbaupp> possibly
[00:33:42] <dbaupp> "error writing buffer"... that doesn't sound like an encoding issue.
[00:33:57] <Sharp> Same issue as before when I tried to use as_bytes()
[00:34:01] <Sharp> And no, it doesn't :(
[00:34:39] <dbaupp> https://github.com/mozilla/rust/blob/0.8/src/libstd/io.rs#L1197 or https://github.com/mozilla/rust/blob/0.8/src/libstd/io.rs#L1267
[00:34:51] <Sharp> 1267.
[00:34:51] *** Quits: DAddYE (DAddYE@moz-61EB081B.hfc.comcastbusiness.net) (Ping timeout)
[00:35:00] <dbaupp> would it be too much to ask to just upgrade to master?
[00:35:11] <Sharp> Not at all.
[00:35:31] <dbaupp> there's a nightly package in https://launchpad.net/~hansjorg/+archive/rust
[00:36:08] <Sharp> Sure, I can grab that.  I could also probably build from source, though I don't know how long that usually takes.  It took awhile this time but I imagine it's faster if you already have rust installed.
[00:36:54] *** Joins: robertknight (robertknig@moz-54528EE0.wby.mendeley.com)
[00:36:57] *** Parts: thewonderidiot (mstewart@moz-E41129BA.ipnetworksinc.net) ()
[00:37:08] <maikeru> Sharp: not really :)
[00:37:27] <dbaupp> Sharp: not really, the only gain you get from having built it before is the time it takes to clone submodules etc & if you get to share any of the LLVM build from the run (which is quite common, but I imagine that we've upgraded LLVM since 0.8, so probably not for that build)
[00:37:39] <dbaupp> *the previous run
[00:37:51] <Sharp> Yeah, LLVM was the advantage I was thinking… but yes, you're right :D
[00:38:31] *** Quits: erickt (etryzelaar@8C9ECD8F.3A598286.F12515B4.IP) (Quit: leaving)
[00:38:41] *** Quits: robertknight (robertknig@moz-54528EE0.wby.mendeley.com) (Ping timeout)
[00:41:45] *** Quits: pcwalton (pcwalton@moz-7B0110AD.mv.mozilla.com) (Quit: pcwalton)
[00:44:57] <maikeru> type `std::rt::io::buffered::BufferedWriter<std::rt::io::file::FileWriter>` does not implement any method in scope named `write`
[00:45:00] <maikeru> o_O
[00:45:14] <acrichto> maikeru: rt::io::Writer isn't in the prelude just yet
[00:45:15] <acrichto> (soon)
[00:45:52] <maikeru> ah
[00:46:23] <Sharp> dbaupp: Working (or at least not crashing) on master.
[00:46:27] <maikeru> mo' bettah
[00:46:30] <Sharp> Sweet!
[00:47:27] *** Quits: fyolnish (fyolnish@moz-CD4B139D.uqwimax.jp) (Ping timeout)
[00:47:32] <dg> speaking of io, what's the right way to pass FileMode into open_reader? I keep getting unresolved name with http://pastebin.com/xe623yPZ
[00:48:28] *** Joins: jensnockert (jensnocker@moz-7DC16A5F.afb.bredband2.com)
[00:49:00] <acrichto> dg: you'll need to add 'Open' to the imports from std::rt::io
[00:49:32] *** Joins: fyolnish (fyolnish@moz-2AC61E89.uqwimax.jp)
[00:50:15] <dg> ah, thank you
[00:50:21] *** Quits: jensnockert (jensnocker@moz-7DC16A5F.afb.bredband2.com) (Ping timeout)
[00:50:48] <dbaupp> Sharp: awesome!
[00:50:56] <Sharp> Yay march of progress!
[00:51:02] <Sharp> Now to figure out why it isn't *working* :P
[00:52:21] <ercxx> Who works on the docs?
[00:52:24] <ercxx> mainly
[00:52:56] *** Quits: strcat (strcat@moz-54F7FD49.cpe.net.cable.rogers.com) (Ping timeout)
[00:53:50] *** Quits: jeffdb_ (jeff@moz-D13B6004.hsd1.ca.comcast.net) (Quit: jeffdb_)
[00:54:04] <dbaupp> ercxx: no-one in particular
[00:54:30] <dbaupp> I'll write docs for library stuff I add/modify and most others do too, but the manual & tutorials are mostly unmaintained
[00:54:59] <dbaupp> (and the examples in the docs in the libraries aren't tested, so they bitrot quickly)
[00:55:01] <maikeru> Hey, I just committed minor doc updates earlier this week! >.<
[00:55:22] <dbaupp> maikeru: <3
[00:55:36] <maikeru> I'll probably be submitting some doc PRs sooner or later, because it drives me nuts.
[00:55:50] <maikeru> the trick is to just edit it when you run into it.
[00:55:58] <ercxx> I mentioned yesterday. There's no direct link from std to extra. 
[00:56:25] <ercxx> Where's the underlying system that creates the docs?
[00:56:49] <ercxx> Or the search system etc.
[00:56:52] *** Quits: q66_ (q66@6EE9DE40.46454B5D.33AABD5F.IP) (Quit: Leaving)
[00:57:07] <dbaupp> ercxx: ah, src/rustdoc
[00:57:10] <dbaupp> maikeru: <3
[00:57:38] <ercxx> rustdoc creates all? How about the crate main pages?
[00:58:08] <ercxx> it's all in the source. I see.
[00:58:27] <maikeru> yar
[00:58:33] <maikeru> rustdoc
[00:59:29] *** Joins: jordyd (jordyd@moz-DCF6CBC4.seg76.ucf.edu)
[01:00:09] *** Quits: TeXitoi (texitoi@moz-EA958D66.texitoi.eu) (Ping timeout)
[01:00:25] *** Joins: TeXitoi (texitoi@moz-EA958D66.texitoi.eu)
[01:00:27] <maikeru> eh.. `BUG[0u]`...
[01:01:22] <maikeru> update ALL THE CODE
[01:01:29] <maikeru> well all the io code
[01:02:14] *** Quits: rusti (rusti@moz-54F7FD49.cpe.net.cable.rogers.com) (Ping timeout)
[01:02:35] *** Joins: rusti (rusti@moz-54F7FD49.cpe.net.cable.rogers.com)
[01:03:02] <maikeru> Result still uses unwrap... get vs unwrap.. FIGHT
[01:03:43] *** Quits: nkoep (nik@moz-796C383E.pool.mediaways.net) (Client exited)
[01:04:20] <maikeru> wait.. why is match expecting an Option instead of a Result? >.<
[01:04:21] <dbaupp> maikeru: https://github.com/mozilla/rust/issues/9784
[01:04:46] <dbaupp> maikeru: because the types of some things changed to be Option's rather than Result's
[01:04:51] <maikeru> Yeah, I guess I should cast my vote eh? :)
[01:05:45] <maikeru> of course..
[01:05:49] <maikeru> duh. 
[01:05:59] <Sharp> Hm, so this still doesn't seem good, dbaupp: it looks like when I println a value at https://gist.github.com/pythonesque/7163820#file-phonebook-rs-L79, that overwrites the value of val--because when I print "text" there, the "Some" clause in main matches and "text" is printed as the value.  When I remove the println, I get the failure path in main().
[01:07:12] <Sharp> And yes, I'm using a semicolon :)  Though I imagine the type of println() is probably ().
[01:07:21] <maikeru> If I don't come back it's because I'm lost in the weeds.
[01:07:45] <dbaupp> Sharp: that seems really really bad o_O
[01:07:50] *** Quits: fyolnish (fyolnish@moz-2AC61E89.uqwimax.jp) (Ping timeout)
[01:07:51] <Sharp> Yes.  Yes, it does.
[01:08:03] <Sharp> Let me update the gist with my current program.  Try it on your machine, see if it's happening there.
[01:08:26] *** Joins: jeffdb_ (jeff@moz-D13B6004.hsd1.ca.comcast.net)
[01:09:47] *** sam113101 is now known as sam113101_afk
[01:09:49] <Sharp> dbaupp: https://gist.github.com/pythonesque/7163820#file-phonebook-rs
[01:09:59] *** Joins: eatkinson (eatkinson@moz-E57448EF.airbears2.berkeley.edu)
[01:10:09] *** Joins: Kruppe (user@moz-E150F49F.cpe.net.cable.rogers.com)
[01:10:12] *** Joins: fyolnish (fyolnish@moz-6DFF5F92.uqwimax.jp)
[01:10:51] <Sharp> Line 84 is the one that, if you comment it out (on my machine anyway) causes the failure branch to occur in main().
[01:11:43] *** Joins: adu (ajr@moz-60B25736.washdc.fios.verizon.net)
[01:11:47] <dbaupp> Sharp: yup, I see it o_O
[01:12:24] <Sharp> Want me to try for a smaller testcase?
[01:12:31] <Sharp> Or is it already known?
[01:13:24] *** Joins: mib_4y71zq (Mibbit@moz-3EF1C327.washdc.fios.verizon.net)
[01:13:58] *** Joins: Jesin (Jessin_@moz-9BB5F6CF.cc.lehigh.edu)
[01:15:02] <dbaupp> Sharp: no idea (and yeah, smaller test case would be good)
[01:15:19] *** Quits: eatkinson (eatkinson@moz-E57448EF.airbears2.berkeley.edu) (Quit: eatkinson)
[01:15:25] <Sharp> 'kay, let me work on that.
[01:16:09] *** Quits: enix (enix@moz-A50569DD.c3-0.slvr-ubr1.lnh-slvr.md.cable.rcn.com) (Quit: Konversation terminated!)
[01:16:46] *** Quits: dew (Instantbir@moz-E4452B8F.static.stls.mo.charter.com) (Ping timeout)
[01:16:53] *** Joins: dew (Instantbir@moz-E4452B8F.static.stls.mo.charter.com)
[01:20:37] <dbaupp> Sharp: I guess the problem is storing &'self Entry in the hashmap and inserting &Val(value).
[01:20:51] <dbaupp> since &Val(value) is on the stack, and isnt connected to the lifetime of the hashmap
[01:21:02] <dbaupp> i.e. this is a big bug in the region system.
[01:21:04] <Sharp> Yeah, that's probably it.
[01:21:29] <Sharp> Trying to simplify it right now.
[01:22:13] <Sharp> Actually, wait.  Isn't &Val(value) connected to the hashmap lifetime?  I just realized I never made it do that.
[01:22:14] *** Joins: thewonderidiot (mike@moz-5506A033.hsd1.ca.comcast.net)
[01:22:18] <Sharp> I suppose I would have if Rust pointed it out to me :)
[01:25:11] <dbaupp> no it's not
[01:25:44] <dbaupp> &foo() is the same as `let tmp = foo();  &tmp`, i.e. it's placed on the stack, so the &-reference shouldn't be allowed to escape
[01:26:43] <dbaupp> (no matter what lifetime annotations you put on it, it should never be able to escape that stack-frame; lifetime annotations just tell the compiler information, they don't actually change the (maximum) lifetime of the underlying object.)
[01:27:19] <benh> Doesn't &foo() have a shorter lifetime than the explicit-temporary version?
[01:28:08] *** Quits: fyolnish (fyolnish@moz-6DFF5F92.uqwimax.jp) (Ping timeout)
[01:28:56] <dbaupp> benh: bugs
[01:29:17] <Sharp> dbaupp: That's a good point.  Actually, the only reason I was creating a pointer was that I'm pretty sure MutableMaps don't guarantee that the pointer they hand you for a given value entry will always be the same for its key.
[01:29:34] <dbaupp> benh: (as in yes, but not by design; and anyway, short lifetimes make this situation worse.)
[01:30:00] <Sharp> So ideally, Rust would have forced me to provide the Val() pointer in the scope of main()?
[01:30:37] *** Joins: ChrisMorgan (chris@moz-6AC741CA.static.tpgi.com.au)
[01:30:59] *** Joins: fyolnish (fyolnish@moz-84E122F6.uqwimax.jp)
[01:31:24] <dbaupp> yes
[01:31:30] <Sharp> Makes sense.
[01:31:51] *** Quits: weirdo (Mibbit@moz-A1446906.bootp.virginia.edu) (Quit: http://www.mibbit.com ajax IRC Client)
[01:32:08] *** Joins: ktt3ja (Mibbit@moz-6B6EE8C0.hsd1.va.comcast.net)
[01:32:30] <Sharp> In this usecase, what I really want is just the ability to allocate some pointers on the heap that go out of scope when the Table does, but don't have to be allocated in main().  But I'm not sure I can do that safely (without using managed pointers).
[01:32:39] <Sharp> Well, I can do it safely, but not with Rust's rules, I don't think.
[01:33:04] <Sharp> Because I can have multiple references to an entry and I don't think Rust likes that for owned pointers.
[01:33:58] *** Joins: DAddYE (DAddYE@moz-98D3933F.hsd1.ca.comcast.net)
[01:34:15] *** Joins: jxv (jxv@moz-4CC5F5E9.dsl.irvnca.pacbell.net)
[01:34:17] <Sharp> Or, wait.  HashMap.insert takes a plain V, right?  Shouldn't that just copy my reference?  Then it doesn't matter if it dies with the stack.
[01:34:23] <inspur> how to connect str
[01:34:37] <inspur> let mut output = ~"";
[01:34:37] <inspur> 	output += ~"aa";
[01:34:47] <inspur> error: binary operation + cannot be applied to type `~str`
[01:34:49] <dbaupp> Sharp: it shallow copies the reference
[01:35:02] *** Quits: KindOne (KindOne@moz-589A7B87.dynamic.ip.windstream.net) (Ping timeout)
[01:35:04] <dbaupp> inspur: `output.push_str("aa");`
[01:35:13] <Sharp> Ohhh, right, I see what you're saying
[01:35:19] <Sharp> The problem is where the Val is allocated.
[01:35:25] <Sharp> Not the reference.
[01:35:34] <inspur> thankyou
[01:35:46] *** Quits: DAddYE (DAddYE@moz-98D3933F.hsd1.ca.comcast.net) (Ping timeout)
[01:35:56] <dbaupp> Sharp: I think you need managed pointers for this, since the lifetimes/ownership is so tangled. 
[01:36:17] <dbaupp> Sharp: my reduced-ish test case https://gist.github.com/huonw/5cb75040809402c4e12f
[01:36:19] <Sharp> I don't really, though (in the sense that I, personally, could keep track of them pretty easily).
[01:36:30] <dbaupp> as a human?
[01:36:42] <Sharp> In this reduced environment, yes.
[01:36:59] <dbaupp> if you had a backing vector and stored indexing into that, this might work better.
[01:37:08] <dbaupp> *indices
[01:37:11] <Sharp> Right.
[01:37:27] <Sharp> Or if the HashMap deep-copied the Val
[01:37:29] <Sharp> That would work too :P
[01:37:52] <Sharp> (I assume it already uses a backing vector of some sort so it would be kind of silly to have two).
[01:38:07] *** Quits: azakai (alon@moz-BBE3ABD.mv.mozilla.com) (Ping timeout)
[01:38:39] <dbaupp> well, the hashmap would onle be storing indices, so there'd be two backing vectors of different things (but yes, it'd be a bit peculiar)
[01:38:39] <inspur>  type `~str` does not implement any method in scope named `pushstr`
[01:38:39] <inspur> output.pushstr(g[i][j].to_str());
[01:38:39] <inspur> the parameter 
[01:38:40] *** Joins: KindOne (KindOne@moz-64116AE8.dynamic.ip.windstream.net)
[01:39:15] *** Quits: pnkfelix (pnkfelix@moz-43495417.fbx.proxad.net) (Quit: Leaving.)
[01:39:22] <Sharp> Oh, I see.  That seems silly and indirect :P
[01:39:46] <Sharp> Any way I can get the Val ref to deep copy?
[01:39:50] <dbaupp> inspur: push_str
[01:40:01] <dbaupp> Sharp: use .clone()
[01:40:12] <Sharp> Where?  Presumably I'd have to do it within HashMap, no?
[01:40:21] <Sharp> Otherwise the clone() is still scoped to the function, isn't it?
[01:40:25] <dbaupp> that will copy as deep as it needs to to ensure ownership
[01:41:11] *** Quits: SilverKey (SilverKey@moz-B589DA51.sw.biz.rr.com) (Quit: My MacBook Pro has gone to sleep. ZZZzzz…)
[01:41:16] <dbaupp> well, I don't really know what you're trying to do... so maybe? (If you store them in the hashmap as non-references, then .clone()ing will be fine)
[01:41:46] <Sharp> If I store them as nonreferences, what can I point to that I know won't change places?
[01:42:09] <dbaupp> nothing
[01:42:47] <dbaupp> the backing vector can get resized and everything rehashed, and Rust objects aren't allowed to depend on their position in memory.
[01:43:02] <Sharp> Right.  That was why I added the references in the first place.
[01:43:41] <dbaupp> that links you to the stack frame of the elements.
[01:44:24] <Sharp> Well, yes, but everything in the Val() is already available in main().  It's just whatever boxing Val() does that isn't present.
[01:44:26] <Sharp> I imagine, anyway.
[01:45:31] <Sharp> Maybe if I return the Val() rather than bool I can give it a longer lifetime.
[01:45:57] <dbaupp> nope
[01:46:20] <dbaupp> you can't move it in memory while there is a reference too it.
[01:46:23] <dbaupp> *to
[01:46:42] <Sharp> So even if you explicitly specify that the returned &Val() should have the same lifetime as the table, Rust won't let you?
[01:47:35] <dbaupp> yes, specifying lifetimes doesn't change the fundamental lifetimes of objects, it just tells the compiler that this thing has a certain lifetime (just like specifying a type doesn't change the type, it just tells the compiler what type it is)
[01:47:43] <sp3d> it can't, due to the way the stack works
[01:47:57] <Sharp> It could preallocate space on the caller's stack.
[01:48:01] <Sharp> In theory.
[01:48:06] <Sharp> Probably not in the general case, just in this case :P
[01:48:16] <dbaupp> that's getting very weird.
[01:48:26] <dbaupp> and it basically reduces to the caller basing in the reference.
[01:48:29] <dbaupp> *passing
[01:48:35] <Sharp> Not really, it's effectively the same as defining the Val() in main in the first place.
[01:48:39] <Sharp> Right.
[01:49:29] <Sharp> It would mostly be convenient from an abstraction perspective, though.  The client shouldn't need to know about the implementation details of Entry.
[01:50:39] <Sharp> I am just reluctant to use a garbage collector for something where I pretty clearly know what the possible lifetime is.
[01:50:52] *** Joins: bleibig (bleibig@moz-CB11172C.hsd1.ca.comcast.net)
[01:52:03] *** Quits: hjr3 (hradtke@374E545A.3A8E9B0C.F9D9C60E.IP) (Quit: My MacBook has gone to sleep. ZZZzzz…)
[01:52:05] <dbaupp> the other option would be HashMap<Name, Entry> where enum Entry { Alias(Name), Val(Number) }, which means you do a full look-up on an Alias
[01:52:24] <Sharp> Yeah, that's the implementation I used in Lisp, for example
[01:52:27] <dbaupp> (which is pretty slow, but shouldn't be too bad, if you flatten the Alias chains to be length at most 1.)
[01:52:30] <Sharp> But I was hoping I would get to use pointers in Rust
[01:52:40] <Sharp> Since, y'know, that's the selling point :)
[01:52:41] *** Quits: inspur (inspurhua@54B0D324.D4DDBED4.B3490680.IP) (Ping timeout)
[01:53:03] <dbaupp> internal pointers don't work, so no, very difficult to get to be safe.
[01:53:09] <Sharp> I can always use unsafe pointers I suppose.
[01:53:16] <dbaupp> (to be safe and abstracted.)
[01:53:24] <dbaupp> ... that won't be safe. :/
[01:53:31] <Sharp> No, it won't :P
[01:53:43] *** Joins: inspur (inspurhua@54B0D324.D4DDBED4.B3490680.IP)
[01:54:09] <Sharp> Underlying Vector may be the best safe solution.
[01:55:01] *** Quits: blank_name (blank_name@2E4E7E43.800E1818.31EC03F3.IP) (Quit: leaving)
[01:55:51] *** Joins: Jesse (jruderman@moz-537BCF9.hsd1.ca.comcast.net)
[01:56:07] <ktt3ja> I need help with my code
[01:56:18] *** Quits: geoffhill (geoffhill@moz-244CF33A.amazon.com) (Ping timeout)
[01:56:22] <ktt3ja> http://pastebin.com/Fff2950L
[01:56:27] <ktt3ja> error is at the bottom
[01:57:15] <Sharp> Anyway, should I file a bug for this with your testcase?  Since I assume it is still not a good thing.
[01:57:35] *** Joins: blank_name (blank_name@2E4E7E43.800E1818.31EC03F3.IP)
[01:58:02] <dbaupp> Sharp: yes yes yes! it's a horrible horrible thing.
[01:58:08] <Sharp> Will do.
[01:58:28] *** Joins: Cromulent (Cromulent@moz-C2470BE2.cable.virginm.net)
[01:59:15] <maikeru> is there a good way to do format!(blahblabhablh).as_bytes()?
[01:59:27] *** sam113101_afk is now known as sam113101
[01:59:39] *** Joins: skade (skade@moz-A89F791B.pools.arcor-ip.net)
[02:02:31] *** Joins: lkuper (lkuper@moz-C0CD33ED.hsd1.in.comcast.net)
[02:02:43] *** Quits: steffenomak (steffenoma@moz-FB0A4BEB.student.uu.se) (Ping timeout)
[02:03:16] *** Quits: glennsl (textual@moz-5D7B804F.getinternet.no) (Quit: My MacBook Pro has gone to sleep. ZZZzzz…)
[02:03:43] <Sharp> @dbaupp: https://github.com/mozilla/rust/issues/10078
[02:03:58] <Sharp> Probably a better way to format those links, I'm not sure how to link to Gists in GFM.
[02:05:36] <cmr> Sharp: it will autolink URLs
[02:05:50] <cmr> not really w hat I meant
[02:06:00] <Sharp> Yeah… but they are kind of ugly.  I thought it might autolink GIST-x or something.
[02:06:07] <cmr> if github knows how to make a pretty format for a given url, it will shorten it if you paste a link it can understand.
[02:06:33] <Sharp> Ah.  Apparently it doesn't, then.  Or I pasted the links in a very unintuitive way.
[02:07:17] <dbaupp> Sharp: in general keep the issues entirely self contained and not relying on (e.g.) me not accidentally deleting that gist is better
[02:07:21] *** sam113101 is now known as sam113101_afk
[02:07:27] <dbaupp> I've edited the code to be inline.
[02:07:27] <Sharp> Ah.  Okay.  I'll paste the testcase, then.
[02:07:36] *** Quits: bleibig (bleibig@moz-CB11172C.hsd1.ca.comcast.net) (Quit: bleibig)
[02:07:37] <dbaupp> Sharp: already done :P
[02:07:42] <Sharp> Haha, great.
[02:08:38] *** sam113101_afk is now known as sam113101
[02:09:33] *** Quits: ksf (ksf@moz-7906A1B7.adsl.hansenet.de) (Client exited)
[02:10:51] <dbaupp> Sharp: I've added a println! at the end that demonstrates that it's creating invalid data too
[02:10:56] <Sharp> Ah, good.
[02:11:20] <Sharp> Looking through the lifetime bugs I don't *think* this is a dup, but I could be wrong.
[02:12:05] <dbaupp> nmatsakis: just in case you miss the cc, https://github.com/mozilla/rust/issues/10078
[02:13:17] <maikeru> right... into_bytes... eh
[02:13:22] *** Joins: brendan (brendaneic@175FECE6.103DC7D.4EA770CF.IP)
[02:13:52] <maikeru> can't as_bytes and into_bytes be consolidated?
[02:14:30] *** Quits: kimundi (kimundi@moz-16FE982D.dip0.t-ipconnect.de) (Ping timeout)
[02:15:18] <cmr> maikeru: look at the type signatures and you tell me :)
[02:15:33] <dbaupp> ktt3ja: you're trying to steal ownership of the V out of the map, assuming that you're not trying to actually move the V out of the map in .get, you need that to be `fn get<'a>(&'a self, key: &K) -> Option<&'a V>`
[02:15:52] *** sam113101 is now known as sam113101_afk
[02:16:22] *** Joins: earlzlap (earlz@moz-9E279EAD.neo.res.rr.com)
[02:16:31] *** Quits: heftig (heftig@moz-22DF79F3.dip0.t-ipconnect.de) (Ping timeout)
[02:16:56] *** Joins: alisdair (textual@28441AAB.AC6E1995.F0AE27BD.IP)
[02:17:06] <dbaupp> ktt3ja: oh! it looks like .get is trying to pop that element? I think you need (1) to use self.map.pop(key), and (2) use some more unsafe functions to move out from behind the *.
[02:17:30] *** Joins: kimundi (kimundi@moz-FD9221F2.dip0.t-ipconnect.de)
[02:18:42] <ktt3ja> it's for lookup and moving the node to the beginning of the list
[02:18:54] <dbaupp> ktt3ja: std::ptr::read_and_zero_ptr
[02:19:00] <ktt3ja> I'm basically trying to translate this code into Rust: http://www.cs.uml.edu/~jlu1/doc/codes/lruCache.html
[02:19:06] <dbaupp> (that's if you want to move the element out.)
[02:20:04] <dbaupp> hm, that could be tricky.
[02:21:09] *** Joins: heftig (heftig@moz-7FB4D0C8.dip0.t-ipconnect.de)
[02:21:18] <ktt3ja> I have been working on this all day, but whatever type of pointer I use I just can't seem to get it right :(
[02:21:26] *** sam113101_afk is now known as sam113101
[02:22:02] *** Quits: jvns (quassel@87D98E32.4046EB22.428F94DD.IP) (Ping timeout)
[02:22:10] *** Joins: tikue_ (tikue_star@moz-FEADCD38.hsd1.pa.comcast.net)
[02:22:14] *** kimundi is now known as zz_kimundi
[02:22:34] <dbaupp> yeah, you'll need to work out the exact semantics of get: does it remove the V from the LRU? it looks like that's a no, which means you need to return a borrowed pointer
[02:22:38] <dbaupp> i.e. a reference into the map
[02:23:00] <dbaupp> which is Option<&'a V>
[02:23:10] <dbaupp> with &'a self.
[02:23:24] <dbaupp> err, sorry, &'a mut self.
[02:24:10] <dbaupp> unfortunately, the mutability means this gets weird, because you can then only .get() one element from the LRU cache at a time. however, I'm not 100% sure there's a way do it that avoids this.
[02:25:00] <Sharp> There's no non-mutable option?
[02:25:34] <dbaupp> Sharp: there's no way to extract an element out of a LRU cache and update the recently-used bit without mutability
[02:25:42] <Sharp> Oh, heh.  Missed the update.
[02:26:41] *** Joins: brianm (brianm@moz-9B7D279E.dsl.static.sonic.net)
[02:26:53] <ktt3ja> I got a different error: lru_cache.rs:53:8: 60:9 error: mismatched types: expected `std::option::Option<&'a V>` but found `std::option::Option<V>` (expected &-ptr but found type parameter)
[02:27:01] <brianm> is there a way to statically link a binary?
[02:27:17] <dbaupp> in fact, it's almost certainly non-memory safe in general to get a reference from an LRU cache like this and still allow adding elements to it, so this is a "compulsory" restriction. (i.e. one should be able to .get() multiple elements, but we don't offer fine-grained control of what can be disallow.)
[02:27:26] <Sharp> Actually, thinking about it, it would be kind of nice to be able to say you wanted a mutable reference to just one element.
[02:27:42] <dbaupp> ktt3ja: you need totake a reference explicitly, Some(&node.value) (or whatever)
[02:28:13] <dbaupp> ktt3ja: you may need to call http://static.rust-lang.org/doc/master/std/cast/fn.transmute_region.html too
[02:28:51] <dbaupp> brianm: it's being worked on https://github.com/mozilla/rust/issues/552
[02:29:07] <dbaupp> brianm: (as in, not now, but hopefully soon.)
[02:29:18] *** zz_kimundi is now known as kimundi
[02:29:44] *** Quits: Jesin (Jessin_@moz-9BB5F6CF.cc.lehigh.edu) (Ping timeout)
[02:29:46] <kmc> a macro var always expands to a single AST node right? like I don't need to put parens around it no matter the precedence of surrounding operators?
[02:30:04] <dbaupp> yes
[02:30:15] *** Quits: maik (maik@moz-10F9C3B5.dip0.t-ipconnect.de) (Ping timeout)
[02:30:33] <dbaupp> rusti: macro_rules! foo ( () => { 1 + 2 } ); foo!() * 2
[02:30:34] -rusti- pastebinned 12 lines of output: http://sprunge.us/BAFH
[02:30:48] <dbaupp> rusti: macro_rules! foo ( () => { 1 + 2 } ); 2 * foo!()
[02:30:49] -rusti- 6
[02:31:08] *** Quits: inspur (inspurhua@54B0D324.D4DDBED4.B3490680.IP) (Ping timeout)
[02:31:22] *** Joins: Jesin (Jessin_@moz-9BB5F6CF.cc.lehigh.edu)
[02:32:08] *** Joins: inspur (inspurhua@54B0D324.D4DDBED4.B3490680.IP)
[02:32:44] *** Joins: sphoorti (chatzilla@B29CD426.DD70063C.E3E2C386.IP)
[02:32:49] <brianm> dbaupp: awesome, thanks
[02:34:33] *** Quits: lkuper (lkuper@moz-C0CD33ED.hsd1.in.comcast.net) (Ping timeout)
[02:35:06] <earlzlap> Does anyone with rust-http know what this means on Request.request_uri: 
[02:35:06] <earlzlap> /// You will almost never need to use this; you should prefer the `url` field instead.
[02:35:07] <ktt3ja> dbaupp: would it be easier or better if I use managed pointer instead?
[02:35:29] <earlzlap> I don't see a url field in the struct 
[02:35:33] *** Joins: DAddYE (DAddYE@moz-98D3933F.hsd1.ca.comcast.net)
[02:35:54] <dbaupp> ktt3ja: possibly, but if you're trying to submit it to the standard libraries it won't be accepted with managed pointers.
[02:36:08] <dbaupp> ChrisMorgan: ^ earlzlap's question
[02:36:32] <dbaupp> ktt3ja: (as in, it's possibly easier, but it's not better.)
[02:36:34] <ChrisMorgan> earlzlap: unimplemented
[02:36:38] <maikeru> ChrisMorgan: I had literally JUST got done updating rust-http for latest master when I noticed you updated trunk. >.< Still, mine was slightly different, think it's a bit more ideomatic...
[02:37:10] <kmc> also, it seems to be the case that macros aren't visible (even with #[macro_escape];) unless their module is included directly from the crate root
[02:37:13] <kmc> is that known to be the case?
[02:37:15] *** Quits: DAddYE (DAddYE@moz-98D3933F.hsd1.ca.comcast.net) (Ping timeout)
[02:37:15] <ChrisMorgan> maikeru: if you watch the repository you'll hear about PRs, of which that was one
[02:37:29] <earlzlap> ah :( 
[02:37:50] *** Joins: robertknight (robertknig@moz-54528EE0.wby.mendeley.com)
[02:37:51] <dbaupp> kmc: they will be included for everything after/below them in the AST
[02:38:11] *** Quits: rusti (rusti@moz-54F7FD49.cpe.net.cable.rogers.com) (Client exited)
[02:38:15] *** Joins: rusti (rusti@moz-54F7FD49.cpe.net.cable.rogers.com)
[02:38:16] <maikeru> Yeah, I suppose if I'm going to be hacking on it, I should watch it.. eh.
[02:38:34] <maikeru> ChrisMorgan: It's all good regardless, learned alot ;)
[02:38:39] <dbaupp> kmc: i.e. mod bar { fn baz() {} macro_rules! foo() fn qux() {} }, `foo` is visible in `qux` but nothing else
[02:39:00] <kmc> ok
[02:39:10] <ChrisMorgan> Anyone want to implement that url field?
[02:39:11] <dbaupp> kmc: i.e. mod bar { fn baz() {} #[macro_escape] mod module { macro_rules! foo() }  fn qux() {} }, it's visible for the rest of `module`, and `qux`
[02:39:21] *** Quits: brendan (brendaneic@175FECE6.103DC7D.4EA770CF.IP) (Quit: brendan)
[02:39:33] *** Quits: robertknight (robertknig@moz-54528EE0.wby.mendeley.com) (Ping timeout)
[02:39:35] <dbaupp> and putting a #[macro_escape] on `bar` would make it visibel for things after `bar`
[02:40:54] <maikeru> I haven't done anything with the server side code yet...
[02:41:05] <maikeru> earlzlap: you should implement it!
[02:41:47] *** Joins: SilverKey (SilverKey@moz-B589DA51.sw.biz.rr.com)
[02:42:35] *** Joins: strcat (strcat@moz-54F7FD49.cpe.net.cable.rogers.com)
[02:44:41] *** Joins: z0w0 (zack@moz-C877F2F7.lnse2.cha.bigpond.net.au)
[02:48:36] *** Quits: inspur (inspurhua@54B0D324.D4DDBED4.B3490680.IP) (Ping timeout)
[02:48:44] <kmc> how do I (unsafely) declare that a given function never returns, when rustc doesn't know that fact? is an extern "C" import with -> ! my only option?
[02:48:49] *** Joins: inspur (inspurhua@54B0D324.D4DDBED4.B3490680.IP)
[02:49:26] *** Joins: jensnockert (jensnocker@moz-7DC16A5F.afb.bredband2.com)
[02:50:12] *** Quits: huhlig-home (huhlig@moz-C8339267.hfc.comcastbusiness.net) (Connection reset by peer)
[02:50:29] *** Quits: inspur (inspurhua@54B0D324.D4DDBED4.B3490680.IP) (Ping timeout)
[02:51:25] *** Quits: jensnockert (jensnocker@moz-7DC16A5F.afb.bredband2.com) (Ping timeout)
[02:51:45] *** Joins: inspur (inspurhua@54B0D324.D4DDBED4.B3490680.IP)
[02:52:54] *** Quits: skade (skade@moz-A89F791B.pools.arcor-ip.net) (Quit: My MacBook Pro has gone to sleep. ZZZzzz…)
[02:53:23] <earlzlap> noooo. The latest rust broke my code :( 
[02:53:29] <kmc> let's say it doesn't return because it uses asm!() to make an _exit(0) syscall directly
[02:53:33] <earlzlap> Something to do with indexers
[02:54:25] *** Quits: jordyd (jordyd@moz-DCF6CBC4.seg76.ucf.edu) (Quit: Leaving)
[02:54:56] <dbaupp> kmc: I think so
[02:55:00] *** Quits: paulproteus (quassel@199.199.210.158) (Ping timeout)
[02:55:20] <earlzlap> So does the Index trait not work anymore? 
[02:55:36] *** Joins: paulproteus (quassel@458FE134.3EC36C88.CBDCF1DC.IP)
[02:55:37] <kmc> :/
[02:55:37] <SiegeLord> kmc: Is it impractical to stick unreachable!() at the end?
[02:55:46] *** Quits: sphoorti (chatzilla@B29CD426.DD70063C.E3E2C386.IP) (Ping timeout)
[02:55:53] <kmc> SiegeLord: with #[no_std]; yes, I think
[02:56:56] <SiegeLord> Ah, it's just a fail!
[02:57:32] <ktt3ja> dbaupp: sorry for bothering you once more, but I got the same error again. I only changed the get() method: http://pastebin.com/0YM0Q9jT
[02:59:01] *** Joins: Ralith (ralith@moz-132F2FD4.sea.wa.customer.broadstripe.net)
[03:00:47] *** Joins: tautologico (shung@703660AA.CFE755C8.C27E1635.IP)
[03:00:58] <dbaupp> ktt3ja: try `Some(ref value) => Some(cast::transmute_region(value))`
[03:01:05] *** Joins: sphoorti (chatzilla@B25BB462.6904729C.E3E2C386.IP)
[03:01:32] <tautologico> I get this error from a macro, I don't know what is it
[03:01:33] <tautologico> error: No rules expected the token: 3
[03:01:51] <dbaupp> ktt3ja: or, even, replace the match on `(*node).value` with `(*node).value.as_ref().map(|value| cast::transmute_region(value))`
[03:02:19] <earlzlap> ChrisMorgan: How am I suppose to make a non-cloneable mutable Server with rust-http? Basically I need a constructor that can create the Server and set a few fields, but then trying to use server.serve_forever(), it tries to clone it, and it's not cloneable.
[03:02:30] <earlzlap> I thought about get_config, but self isn't mutable there
[03:02:52] <dbaupp> ktt3ja: cf. http://static.rust-lang.org/doc/master/std/option/enum.Option.html#method.as_ref and http://static.rust-lang.org/doc/master/std/option/enum.Option.html#method.map
[03:02:58] *** Quits: tedh (tedh@moz-F0B37C08.hsd1.il.comcast.net) (Ping timeout)
[03:03:16] *** jorendorff is now known as jorendorff_away
[03:03:34] <ktt3ja> dbaupp: ah, it compiled with your first suggestion
[03:03:36] <Sharp> Idly: does master compile on OS X?  I haven't upgraded to 10.9 yet.
[03:03:40] <dbaupp> rusti: let value = Some(1); let x: Option<&'static int> = value.as_ref().map(std::cast::transmute_region)
[03:03:41] -rusti- pastebinned 6 lines of output: http://sprunge.us/ALMh
[03:03:51] <dbaupp> rusti: let value = Some(1); let x: Option<&'static int> = unsafe { value.as_ref().map(std::cast::transmute_region) }
[03:03:52] -rusti- pastebinned 6 lines of output: http://sprunge.us/cYjP
[03:03:53] <Sharp> Wanted to try tackling some of the E-easy issues.
[03:04:04] <dbaupp> ktt3ja: \o/
[03:04:15] <dbaupp> rusti: let value = Some(1); let x: Option<&'static int> = unsafe { value.as_ref().map(std::cast::transmute_region) }; x
[03:04:15] -rusti- <anon>:9:60: 9:118 warning: unnecessary `unsafe` block, #[warn(unused_unsafe)] on by default
[03:04:16] -rusti- <anon>:9          let value = Some(1); let x: Option<&'static int> = unsafe { value.as_ref().map(std::cast::transmute_region) }; x
[03:04:16] -rusti-                                                                      ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
[03:04:16] -rusti- Some(&1)
[03:04:30] <dbaupp> rusti: let value = Some(1); let x: Option<&'static int> = value.as_ref().map(std::cast::transmute_region); x
[03:04:30] -rusti- Some(&1)
[03:04:34] <dbaupp> woah
[03:04:38] *** Joins: tedh (tedh@moz-F0B37C08.hsd1.il.comcast.net)
[03:04:39] <dbaupp> that's not great
[03:04:54] <Sharp> Wait… &1?
[03:04:57] *** Quits: jeaye (Jeaye@moz-34FEF2BB.hsd1.ca.comcast.net) (Ping timeout)
[03:05:12] <dbaupp> Sharp: "reference to an int with value 1"
[03:05:16] <Sharp> Ah, okay.
[03:05:27] <Sharp> Better than the alternative anyway :)
[03:05:37] <ktt3ja> dbaupp: what do I need to watch out for when using raw pointer? For example, do I need to take care of destroying an object explicitly?
[03:05:56] <dbaupp> ktt3ja: yes, and they can be null pointers too
[03:06:31] <ktt3ja> dbaupp: erm... how do I destroy an object?
[03:06:42] *** Joins: jeaye (Jeaye@moz-34FEF2BB.hsd1.ca.comcast.net)
[03:07:02] *** Quits: kimundi (kimundi@moz-FD9221F2.dip0.t-ipconnect.de) (Ping timeout)
[03:08:39] *** Quits: doy (doy@moz-8F23663C.net) (Quit: rebooting)
[03:09:53] *** Joins: jvns (quassel@moz-DE62990.nyc.res.rr.com)
[03:10:05] *** Joins: kimundi (kimundi@moz-9BA34749.dip0.t-ipconnect.de)
[03:10:07] *** Quits: inspur (inspurhua@54B0D324.D4DDBED4.B3490680.IP) (Ping timeout)
[03:10:09] <dbaupp> ktt3ja: um, there will likely be some function in std::ptr
[03:10:58] *** Joins: inspur (inspurhua@54B0D324.D4DDBED4.B3490680.IP)
[03:11:47] <dbaupp> ktt3ja: hm, I think something like `std::ptr::read_ptr(foo);` will make the value behind `foo` have it's destructor called
[03:12:13] <dbaupp> ktt3ja: you could even use std::util::ignore to be explicit `ignore(read_ptr(foo));`.
[03:12:40] <strcat> or just add a comment :)
[03:13:00] <dbaupp> either way would need a comment
[03:13:04] <ercxx> Is it possible to group tests?
[03:13:07] <kmc> or «let _ = read_ptr(foo)» (servo uses this style)
[03:13:15] <Earnestly> “Don’t comment bad code, rewrite it” :P
[03:13:37] <dbaupp> kmc: I don't think that runs the dtor immediately... does it?
[03:13:43] <kmc> i think it does
[03:13:50] <brson> it's actually a special case that does
[03:13:57] <kmc> i mean, _ is not a variable
[03:13:59] <brson> for better or worse
[03:14:05] <strcat> brson: _ doesn't work though
[03:14:20] <strcat> brson: https://github.com/mozilla/rust/issues/6892 :s
[03:14:32] <dbaupp> rusti: struct Foo;  impl Foo { fn new() -> Foo { Foo } } impl Drop for Foo { fn drop(&mut self) { println("dropping") ; } } let _ = Foo::new(); println("after drop?");
[03:14:33] -rusti- dropping
[03:14:33] -rusti- after drop?
[03:14:33] -rusti- ()
[03:14:43] <strcat> it works on unit structs
[03:14:49] *** kimundi is now known as zz_kimundi
[03:14:49] <strcat> hrm
[03:14:55] <strcat> maybe I fixed some things by making them immediate
[03:15:06] <dbaupp> rusti: struct Foo(int, int);  impl Foo { fn new() -> Foo { Foo(0, 0) } } impl Drop for Foo { fn drop(&mut self) { println("dropping") ; } } let x = Foo::new(); let _ = x; println("after drop?");
[03:15:07] -rusti- after drop?
[03:15:07] -rusti- dropping
[03:15:07] -rusti- ()
[03:15:20] <dbaupp> rusti: struct Foo(int, int);  impl Foo { fn new() -> Foo { Foo(0, 0) } } impl Drop for Foo { fn drop(&mut self) { println("dropping") ; } } let _ = Foo::new();  println("after drop?");
[03:15:21] -rusti- dropping
[03:15:21] -rusti- after drop?
[03:15:21] -rusti- ()
[03:15:36] <strcat> um, wat
[03:15:40] <dbaupp> the difference between those last two are the use of the temporary `x`.
[03:15:51] *** Joins: doy (doy@moz-8F23663C.net)
[03:15:56] *** Joins: voxpopuli (fanservice@moz-CEF3689A.hsd1.pa.comcast.net)
[03:16:34] *** Quits: maxli (maxli@moz-4D28BA20.student.cs.uwaterloo.ca) (Quit: Leaving.)
[03:18:20] *** Quits: JanC_ (janc@moz-A151DD45.dsl.scarlet.be) (Ping timeout)
[03:21:08] <ChrisMorgan> earlzlap: you know about #[deriving(Clone)], right? (I mean, the server needs to be Clone because of the task model employed.)
[03:21:38] *** zz_kimundi is now known as kimundi
[03:22:21] *** Quits: Jesse (jruderman@moz-537BCF9.hsd1.ca.comcast.net) (Quit: Jesse)
[03:25:20] <earlzlap> Yea, I see it now. 
[03:25:45] *** Quits: Earnestly (earnest@moz-BE290A2B.dyn.plus.net) (Quit: WeeChat 0.4.3-dev)
[03:26:29] *** Joins: Earnestly (earnest@moz-BE290A2B.dyn.plus.net)
[03:28:50] *** Quits: earlzlap (earlz@moz-9E279EAD.neo.res.rr.com) (Ping timeout)
[03:30:51] *** jorendorff_away is now known as jorendorff
[03:31:19] *** Joins: earlzlap (earlz@moz-9E279EAD.neo.res.rr.com)
[03:31:29] <earlzlap> I don'
[03:31:40] *** Quits: eevee (eevee@moz-B20A74DC.evrt.wa.frontiernet.net) (Ping timeout)
[03:31:58] *** Joins: eevee (eevee@moz-14DB8285.evrt.wa.frontiernet.net)
[03:32:14] <earlzlap> I don't understand this error when using derived(clone). ` error: mismatched types: expected `rustymvc::router::Router` but found `&rustymvc::router::Router` (expected struct rustymvc::router::Router but found &-ptr)
[03:32:20] <earlzlap> But my actual code is `router: Router`
[03:32:28] <dbaupp> Router needs Clone too
[03:32:41] * dbaupp hates that error message, but can't find a way around it :(
[03:33:14] *** Quits: tikue_ (tikue_star@moz-FEADCD38.hsd1.pa.comcast.net) (Ping timeout)
[03:33:41] <earlzlap> is there any actual documentation over derived(Clone). I understand roughly what it does, but not how it handles (or doesn't handle) pointers
[03:34:06] <dbaupp> earlzlap: https://github.com/mozilla/rust/issues/7621
[03:34:23] <dbaupp> earlzlap: it literally just calls .clone() on the subfields of a struct
[03:34:33] <earlzlap> ah. 
[03:34:34] *** Joins: JanC_ (janc@moz-E01EC4AC.dsl.scarlet.be)
[03:34:46] *** Quits: MrFahrenheit (RageOfThou@3FEF494C.29C984D5.783DEDCA.IP) (Ping timeout)
[03:34:46] <dbaupp> so it's entirely up to the clone() impls of the pointers
[03:35:08] <earlzlap> sucks that some things are not easily cloneable... and really it's immutable, so other than to conform with rust-http, it doesn't /need/ to be cloned for any reason
[03:35:27] <earlzlap> Time to fork rust-http I guess heh
[03:35:45] <dbaupp> put it in an Arc
[03:36:24] *** Joins: DAddYE (DAddYE@moz-98D3933F.hsd1.ca.comcast.net)
[03:36:40] <dbaupp> I believe that's what rust-http is designed for: shared stuff goes into Arcs (RWArc for mutable), so the Clone isn't actually particularly expensive.
[03:36:54] *** Quits: Earnestly (earnest@moz-BE290A2B.dyn.plus.net) (Input/output error)
[03:36:57] *** Joins: Earnestly (earnest@moz-BE290A2B.dyn.plus.net)
[03:37:14] <dbaupp> Any other design would essentially force the use of Arcs and RWArcs even for a simple thing like a single read-only integer.
[03:38:10] *** Quits: DAddYE (DAddYE@moz-98D3933F.hsd1.ca.comcast.net) (Ping timeout)
[03:38:44] <ChrisMorgan> earlzlap: because rust-http spawns new tasks for each request and must call the handle_request method on the server in that new request, the server must be cloned into the new task
[03:39:29] <ercxx> earlzlap: Put your router(or probably the lambda in it), in an Arc.
[03:39:47] <ercxx> earlzlap: https://github.com/eerden/lale/blob/master/src/router.rs
[03:41:22] *** Joins: pnkfelix (pnkfelix@moz-43495417.fbx.proxad.net)
[03:41:40] <Sharp> Is it more efficient to create a HashSet and insert elements afterwards during a for loop than it is to call from_iter() on a map()?
[03:42:48] *** Quits: sphoorti (chatzilla@B25BB462.6904729C.E3E2C386.IP) (Ping timeout)
[03:42:54] *** Quits: johns (johns@moz-BBE3ABD.mv.mozilla.com) (Ping timeout)
[03:42:55] *** Joins: johns (johns@moz-BBE3ABD.mv.mozilla.com)
[03:43:36] <dbaupp> Sharp: .collect()/from_iter are never less efficient, and can be more efficient if the length of the iterator is known
[03:43:49] <Sharp> Awesome.
[03:44:28] *** Joins: maik (maik@moz-10F9C3B5.dip0.t-ipconnect.de)
[03:45:03] *** Quits: brson (brson@moz-BBE3ABD.mv.mozilla.com) (Quit: leaving)
[03:47:13] *** Joins: maxli (maxli@moz-4D28BA20.student.cs.uwaterloo.ca)
[03:47:57] *** Joins: sphoorti (chatzilla@B25BB462.6904729C.E3E2C386.IP)
[03:48:23] *** Quits: pnkfelix (pnkfelix@moz-43495417.fbx.proxad.net) (Ping timeout)
[03:51:54] *** Quits: sphoorti (chatzilla@B25BB462.6904729C.E3E2C386.IP) (Ping timeout)
[03:52:30] *** Quits: inspur (inspurhua@54B0D324.D4DDBED4.B3490680.IP) (Quit: )
[03:52:40] *** Quits: maxli (maxli@moz-4D28BA20.student.cs.uwaterloo.ca) (Ping timeout)
[03:55:17] *** Quits: jeaye (Jeaye@moz-34FEF2BB.hsd1.ca.comcast.net) (Quit: gf)
[03:58:02] *** Quits: maik (maik@moz-10F9C3B5.dip0.t-ipconnect.de) (Ping timeout)
[04:00:53] <earlzlap> How can I find out why a struct isn't freezable? My struct contains no mutable fields, or @ pointers. Just simple types, ~vec, ~str, and ~fn
[04:01:20] *** Quits: Cromulent (Cromulent@moz-C2470BE2.cable.virginm.net) (Quit: KVIrc 4.2.0 Equilibrium http://www.kvirc.net/)
[04:01:26] *** Quits: adu (ajr@moz-60B25736.washdc.fios.verizon.net) (Quit: adu)
[04:01:34] <ercxx> It's the ~fn probably.
[04:01:52] <earlzlap> shouldn't an ~fn be immutable and as such freezable? 
[04:02:03] <earlzlap> Or how can I make it so? 
[04:02:18] <ercxx> take a look : https://github.com/eerden/lale/blob/master/src/router.rs
[04:02:38] *** Joins: adu (ajr@moz-60B25736.washdc.fios.verizon.net)
[04:02:45] *** Joins: erickt (Adium@49C4075F.3AC15C18.2321E71E.IP)
[04:02:54] *** Quits: Sorella (quildreen@9D963F5D.DF5D8AE7.54BCAB54.IP) (Quit: Ex-Chat)
[04:03:18] <ercxx> erickt: arc::Arc<~fn:Send+Freeze(&Request) -> ~str>
[04:03:54] <erickt> ?
[04:04:09] *** Joins: Jesse (jruderman@moz-537BCF9.hsd1.ca.comcast.net)
[04:04:11] <ercxx> sorry
[04:04:20] <erickt> no prob :)
[04:04:20] <ercxx> that was for earlzlap 
[04:04:41] <earlzlap> ugh. Then I run into problems with captured variables :( 
[04:04:46] <ercxx> you joined at the perfect moment.
[04:05:00] <ercxx> Clone them?
[04:06:24] <earlzlap> It's a mutable fluent API, so it creates a lambda using captured variables and such, but eventually it collapses so that the mutable fluent API is collected and all that's left is a immutable and freezable lambda, except for I don't know how to show the compiler that
[04:07:01] *** Joins: bleibig (bleibig@moz-CB11172C.hsd1.ca.comcast.net)
[04:08:32] <earlzlap> For more context: https://github.com/Earlz/rustymvc/blob/master/src/librustymvc/router.rs but with changing line 33 to     handler: ~fn:Send+Freeze(&mut ControllerContext)\
[04:11:49] <earlzlap> It starts off mutable, but before I can actually use the lambda that gets generated, the variable it captures must explicitly go out of scope, by forcing it with `{ }` 
[04:12:16] <earlzlap> Maybe Rc<T> would do what I need
[04:13:28] <ercxx> What is Rc?
[04:13:33] <ercxx> New name for @?
[04:14:41] <erickt> anyone online that knows much about rustpkg?
[04:14:48] *** Quits: canhtak (jeremy@moz-3BB8F.wl.t.ulaval.ca) (Quit: canhtak)
[04:15:02] <Jesse> Rc is a reference-counting smart pointer. similar to @ but a separate implementation.
[04:15:14] <earlzlap> Ugh, Rc requires Freeze as well
[04:15:52] <Jesse> does @ require Freeze?
[04:16:27] *** Quits: tav (tav@moz-40D7C5F6.range109-154.btcentralplus.com) (Quit: tav)
[04:16:37] <strcat> Rc requires Freeze due to language deficiencies
[04:17:05] <strcat> https://github.com/mozilla/rust/issues/9509
[04:17:42] <earlzlap> ah :( 
[04:18:15] <strcat> it should be able to require Freeze *or* Send
[04:18:32] <strcat> or even better, come up with a nicer way to prevent cycles (once that Freeze/Send bubbling up issue is fixed)
[04:18:39] <earlzlap> So, when that finally gets fixed (or smart pointer syntax added) it won't be a requirement.. Guess I'll just have to hold off on rust-http integration :( 
[04:19:04] <strcat> earlzlap: hm?
[04:21:05] <earlzlap> Well, I need to somehow get my Router into rust-http's handle_request. My Router type is sendable, but not freezable, and making it freezable looks nontrivial at this point
[04:22:33] *** Quits: paulproteus (quassel@199.199.210.158) (Ping timeout)
[04:22:57] *** Quits: johns (johns@moz-BBE3ABD.mv.mozilla.com) (Ping timeout)
[04:22:59] *** Joins: johns (johns@moz-BBE3ABD.mv.mozilla.com)
[04:23:03] *** Quits: madmoose (Hat@moz-E1973371.nerp.net) (Ping timeout)
[04:24:28] <ercxx> earlzlap:  I wrapped the lambdas in an Arc and it worked.
[04:25:50] <earlzlap> ercxx: I couldn't get the lamdbas to be freezable due to my mutable fluent API
[04:26:24] *** Joins: madmoose (Hat@moz-E1973371.nerp.net)
[04:26:41] *** Joins: paulproteus (quassel@458FE134.3EC36C88.CBDCF1DC.IP)
[04:28:54] <earlzlap> Maybe I could rework how the fluent API constructs the lambda so that it collapses at the deconstructor or something. 
[04:29:01] <ercxx> rustymvc compiles at the moment. can you put up a gist with what you're trying to do?
[04:29:12] *** Quits: tautologico (shung@703660AA.CFE755C8.C27E1635.IP) (Quit: tautologico)
[04:29:59] <ercxx> earlzlap: disregard
[04:30:11] <earlzlap> It compiles, but the Router isn't freezable, even though it should be because it contains Routes which contain non-freezable lambdas
[04:32:54] <earlzlap> Are destructors deterministic? Like is it guaranteed that one will be called on foo when you do {let foo=Foo; }
[04:33:12] <strcat> earlzlap: unless you're using @/@mut, it's all deterministic
[04:33:18] *** Joins: brendan (brendaneic@moz-A19854B6.mcln.va.megapath.net)
[04:33:24] <earlzlap> Does it happen as soon as it goes out of scope? 
[04:33:29] <strcat> yes
[04:33:45] <strcat> earlzlap: for example Rc has a destructor, it decreases the refcount when it goes out of scope
[04:33:55] <strcat> so the box is freed as soon as the last owner goes out of scope
[04:34:12] <strcat> and you can be sure you only get a new owner when you call clone
[04:34:51] *** Joins: GeneralMaximus (ankur@5D4FDDCE.241AFF02.D2D1FAF0.IP)
[04:34:57] <earlzlap> Ok then. I think I can fix my fluent API so that it constructs a freezable lambda at destroy time
[04:36:48] <Sharp> I'm looking at fixing https://github.com/mozilla/rust/issues/7718.  I think I already have it "fixed" (unless compilation fails, anyway :)) but I'm not sure what the best way to test it would be.  Do we have other examples of tests of similar components I can take a look at?
[04:37:38] *** Joins: DAddYE (DAddYE@moz-98D3933F.hsd1.ca.comcast.net)
[04:38:02] <ercxx> earlzlap: take a look https://github.com/Earlz/rustymvc/pull/1
[04:38:42] *** Joins: robertknight (robertknig@moz-54528EE0.wby.mendeley.com)
[04:39:21] *** Quits: DAddYE (DAddYE@moz-98D3933F.hsd1.ca.comcast.net) (Ping timeout)
[04:40:31] *** Quits: robertknight (robertknig@moz-54528EE0.wby.mendeley.com) (Ping timeout)
[04:41:50] <sfackler> Sharp: the rustpkg tests may have some infrastructure you could use
[04:42:26] <Sharp> Cool, thanks.  I'll take a look.
[04:44:33] *** Quits: Amaranth (travis@moz-F81BB56A.cpe.cableone.net) (Ping timeout)
[04:44:35] *** Joins: Amaranth (travis@moz-F81BB56A.cpe.cableone.net)
[04:46:34] <Sharp> I take it I shouldn't actually use infrastructure from rustpkg, right?  Or is it okay for rustc to depend on it?
[04:48:28] <earlzlap> ercxx: oh I see now. You just had to change all the function signatures. I was just changing one and gettng a borrowing error (so I didn't suspect the function signatures) 
[04:49:09] <ercxx> I had the same problem before. People here are very helpful if you can show exactly where you're getting stuck.
[04:49:47] *** Quits: gazoombo (uid6629@moz-E77DEB21.irccloud.com) (Ping timeout)
[04:49:47] *** Quits: etrepum (uid763@moz-5F4AA75A.irccloud.com) (Ping timeout)
[04:50:03] *** Joins: etrepum (uid763@moz-5F4AA75A.irccloud.com)
[04:50:14] *** Joins: jensnockert (jensnocker@moz-7DC16A5F.afb.bredband2.com)
[04:50:44] <earlzlap> Well thanks :) 
[04:51:09] <ercxx> no problem.
[04:51:24] *** Joins: gazoombo (uid6629@moz-E77DEB21.irccloud.com)
[04:51:26] <ercxx> rust-http needs more work though
[04:52:00] *** Quits: jensnockert (jensnocker@moz-7DC16A5F.afb.bredband2.com) (Ping timeout)
[04:52:26] *** Quits: jxv (jxv@moz-4CC5F5E9.dsl.irvnca.pacbell.net) (Quit: Leaving)
[04:52:40] <earlzlap> ugh. Router is still not freezable though. Is there any way to get rustc to tell me why a type isn't Freezable or Sendable etc? 
[04:53:34] *** Joins: BizarreCake (BizarreCak@moz-361FE9B2.dynamic.barak-online.net)
[04:53:43] <earlzlap> oh wait, yes it is. I was using `~Router` in my test code, changing to just Router works :) 
[04:54:13] *** Joins: vodik (simon@moz-FD4ADBC6.cable.teksavvy.com)
[04:54:29] <earlzlap> oh wait, false alarm. Still not freezable. Maybe because of ~vec ? 
[04:55:23] <sfackler> I think basically everything's freeze except for things like Cell and maybe some of the Arcs
[04:55:36] <sfackler> and @mut
[04:55:58] <ktt3ja> what does it mean when I do `unsafe{ println!("{:?}", *node); }`, where node is a *mut ptr, and get the error `task <unnamed> failed at 'enum value matched no variant', /build/buildd/rust-0.8-0.8/src/libstd/repr.rs:570`?
[04:56:22] <earlzlap> I'm not using anything out of the ordinary though. Not @mut or Arcs or Cell 
[04:56:44] *** Quits: jvns (quassel@moz-DE62990.nyc.res.rr.com) (Ping timeout)
[04:57:04] <dbaupp> ktt3ja: it means that the data stored in `node` isn't valid
[04:57:27] <strcat> sfackler: and &fn, &mut
[04:58:18] <ktt3ja> dbaupp: can't win against pointer...
[04:59:02] <strcat> ktt3ja: looks like you're doing something unsound then
[04:59:09] <earlzlap> This is my entire struct tree. I don't see a reason for Router to not be freezable. https://gist.github.com/Earlz/7165430
[04:59:19] <strcat> you have an enum somewhere in there and it's set to an invalid value - you might get a crash, you might get an error like that
[04:59:42] <dbaupp> ktt3ja: I'd help, but I've got to go :(
[05:00:17] <ktt3ja> dbaupp: well, I'm going to bed soon, so it's k
[05:00:21] <ktt3ja> thanks for helping me
[05:01:23] <sfackler> earlzlap: Try putting a freeze bound on the matcher field in Route
[05:02:29] <ktt3ja> dbaupp: is it okay if I look for you tomorrow? This assignment is due in a few days and I don't think I can fix this bug alone
[05:07:28] <earlzlap> I did that, but then get `error: mismatched types: expected `~simplepattern::PatternMatcher:Freeze` but found `~simplepattern::PatternMatcher:Send` (expected bounds `Freeze` but found bounds `Send`)` which I don't quite understand :/ 
[05:07:57] <earlzlap> (at line 97) self.router.add(~Route{matcher: ~SimplePattern::new(self.path) as ~PatternMatcher, handler: |c| { ... 
[05:08:21] <earlzlap> Is a type either freezable or sendable but not both or something? 
[05:11:22] <sfackler> shouldn't be
[05:11:35] <earlzlap> oh. I found it. 
[05:12:05] <earlzlap> i had  ~SimplePattern::new(self.path) as ~PatternMatcher... Needed to change to ~PatternMatcher:Freeze. ugh
[05:12:11] <earlzlap> Traits are hard heh
[05:12:20] <sfackler> ah
[05:12:32] <sfackler> the manual cast is going to go away
[05:12:45] <sfackler> hopefully soon
[05:13:48] *** Quits: ged (deveiant@moz-610E9711.org) (Ping timeout)
[05:14:41] <Sharp> Bah, apparently Rust is, in fact, still broken on OS X :(
[05:14:44] *** Joins: ged (deveiant@moz-610E9711.org)
[05:16:27] *** Quits: erickt (Adium@49C4075F.3AC15C18.2321E71E.IP) (Quit: Leaving.)
[05:16:30] <earlzlap> ugh. Apparently Router isn't sendable like I thought :( 
[05:17:25] *** Quits: Kxepal (Miranda@moz-C9C3DD3D.pppoe.mtu-net.ru) (Ping timeout)
[05:18:17] <earlzlap> Sometimes I feel like Rust's phases of compilation is the 7 circles of hell lol 
[05:19:17] <strcat> if you're heavily using heap closures and trait objects, you're already swimming against the current
[05:19:29] *** Quits: vodik (simon@moz-FD4ADBC6.cable.teksavvy.com) (Ping timeout)
[05:20:36] *** Joins: Kxepal (Miranda@moz-A7BD37A0.pppoe.mtu-net.ru)
[05:21:01] <ktt3ja> when is an object pointed to by a raw pointer destroyed? It looks like I have a dangling pointer
[05:21:39] <strcat> ktt3ja: it isn't
[05:21:53] <strcat> well, I'm not really sure what you mean
[05:22:08] <strcat> a raw pointer is in no way tied to the lifetime of what's behind it - it won't make it live longer, or clean it up
[05:23:53] *** Quits: brendan (brendaneic@moz-A19854B6.mcln.va.megapath.net) (Ping timeout)
[05:24:58] <ktt3ja> strcat: I add a raw pointer (say rp1) to a hashmap, then take it out (as say rp2) in another method. println! tells me that both rp1 and rp2 point at the same memory location, but when I dereference rp2, I get an invalid memory location
[05:25:35] <ktt3ja> so I thought I got a dangling pointer
[05:25:48] <strcat> why do you need raw ptrs?
[05:26:06] <sfackler> sounds like rp1 and rp2 both point to the same invalid memory location
[05:26:08] *** Joins: brendan (brendaneic@moz-A19854B6.mcln.va.megapath.net)
[05:26:09] <strcat> what do they point at?
[05:26:25] <ercxx> strcat: what did you mean with 'if you're heavily using heap closures and trait objects, you're already swimming against the current' ?
[05:26:57] *** Quits: thewonderidiot (mike@moz-5506A033.hsd1.ca.comcast.net) (Connection reset by peer)
[05:26:58] <strcat> ercxx: I mean they aren't the idiomatic way to do most things (and ~fn is going to be removed soon)
[05:27:17] <ercxx> okay
[05:27:46] <ktt3ja> strcat: I'm making an lru cache; I tried to do it with owned pointer/managed pointer, but I kept running into compiler error
[05:28:37] <strcat> a raw pointer is just making you responsible for memory safety - you'll get non-deterministic memory corruption instead of a compile-time error
[05:28:47] <strcat> you can definitely write an LRU cache with @mut
[05:28:50] <strcat> or RcMut
[05:28:57] <SimonSapin> We say that Rust is a "systems language", what does that mean?
[05:29:01] *** sam113101 is now known as sam113101_afk
[05:29:22] <ercxx> strcat: but an url router basically matches a string to a function buried somewhere. How would you do it in rust?
[05:30:47] <strcat> SimonSapin: efficient (time and space), usable without a runtime/VM, high level control over memory layout and resource management, support for inline asm
[05:30:48] *** sam113101_afk is now known as sam113101
[05:31:12] <strcat> I don't think rust is really all the way there yet as a systems language
[05:31:18] <strcat> but it's getting closer
[05:34:49] <ktt3ja> strcat: I tried using @mut before but ran into an error I didn't know how to fix; I may try RcMut if this doesn't work out
[05:35:27] <strcat> I don't think RcMut will actually work for that atm
[05:36:36] <strcat> SimonSapin: for example, containers with custom allocators are blocked on me figuring out a weird cross-crate dtor bug ;p
[05:37:26] <ktt3ja> here's my code: http://pastebin.com/zgcLQLgE  , think of `node_ptr` in the put() method as rp1 and `node` in the get() method as rp2; output is at the bottom
[05:38:53] *** Joins: DAddYE (DAddYE@moz-98D3933F.hsd1.ca.comcast.net)
[05:39:12] *** Quits: Kxepal (Miranda@moz-A7BD37A0.pppoe.mtu-net.ru) (Quit: Kxepal)
[05:39:13] <utkarsh> How do I make a syscall in Rust? I'm trying to translate this Go code: https://gist.github.com/e763dff06764323d3391
[05:39:24] <cmr> utkarsh: on what platform?
[05:39:29] *** Joins: Kxepal (Miranda@moz-A7BD37A0.pppoe.mtu-net.ru)
[05:39:42] <strcat> utkarsh: glibc syscall function
[05:40:04] <strcat> extern { fn syscall(n: c_int) -> c_int; }
[05:40:12] <strcat> well
[05:40:15] <strcat> you need variadic fns
[05:40:22] <strcat> otherwise you have to hardcode the rest of the parameters ;P
[05:40:36] *** Quits: DAddYE (DAddYE@moz-98D3933F.hsd1.ca.comcast.net) (Ping timeout)
[05:41:30] <strcat> so I guess you will end up needing inline asm until Luqman's PR lands :)
[05:41:50] <cmr> Wait what PR is this?
[05:41:50] <strcat> (that libc function exists on BSD too.... but obviously the numbers/parameters aren't the same for syscalls)
[05:41:54] <strcat> variadic fns
[05:42:31] <cmr> whoaa
[05:42:37] <cmr> didn't think we'd ever get that
[05:43:22] <earlzlap> I have an external enum. How do I access it? I've tried `foo::MyEnum`, but that yields use of undeclared type name. Is there special syntax for enums? 
[05:43:25] <strcat> more accurately, a way to call variadic C functions (which is completely unsafe!)
[05:43:44] <cmr> I'm ok with extern "C" variadics, but strongly against anything further.
[05:43:48] <strcat> earlzlap: that will work if it's public
[05:43:50] <strcat> cmr: I agree
[05:44:03] <strcat> I think rust is large enough already and will argue against adding anything non-essential ;p
[05:44:12] <earlzlap> But it's not :/ 
[05:44:24] <ChrisMorgan> strcat: that just requires classification as essential.
[05:44:26] *** Joins: fyolnish_ (fyolnish@moz-3E59912C.uqwimax.jp)
[05:44:29] <strcat> earlzlap: well, without a code sample all I can tell you is that it works
[05:44:33] <utkarsh> That Go code uses an inbuilt package http://golang.org/pkg/syscall/
[05:44:41] <utkarsh> Hmm, I should probably write a small C wrapper then..
[05:44:43] <strcat> ChrisMorgan: we have nearly everything essential :)
[05:44:56] <ChrisMorgan> "Do all these things." "Too much to do, please prioritise them." "Oh, OK. They're all essential." :-)
[05:45:02] <pcmattman> earlzlap, is MyEnum an enum value, or the name of the enum itself?
[05:45:16] <cmr> utkarsh: aatch's grease-bench has syscall code for linux.
[05:45:26] *** Quits: fyolnish (fyolnish@moz-84E122F6.uqwimax.jp) (Ping timeout)
[05:45:28] <strcat> ChrisMorgan: s/essential/not sugar for stuff you can already write/
[05:45:45] <Sharp> Then the inline assembler makes everything nonessential, no?
[05:45:50] <strcat> Sharp: not portable
[05:45:53] <earlzlap> MyEnumi s the enum itself
[05:45:58] <strcat> and not safe
[05:46:05] <Sharp> Both true.
[05:46:19] <earlzlap> you can see this behavior if you are to take rust-http and take this sample: https://github.com/chris-morgan/rust-http/blob/master/src/examples/server/info.rs
[05:46:21] <cmr> variadic functions aren't required for safety or abstraction, and actively *hurt* having a useful ABI
[05:46:55] <earlzlap> and add fn(uri: http::server::RequestUri){} ... where RequestUri is here: https://github.com/chris-morgan/rust-http/blob/master/src/libhttp/server/request.rs
[05:46:59] *** Quits: cubic (cubic@moz-80241A3A.mc.videotron.ca) (Quit: Leaving)
[05:47:01] *** Quits: hoverbear (andrew@moz-86FCBF4B.gv.shawcable.net) (Quit: hoverbear)
[05:47:18] <strcat> cmr: and you can just use arrays, unless you're talking about generic variadic fns ;p
[05:47:34] <Sharp> Are macros not variadic?
[05:47:42] <strcat> macros aren't aware of types
[05:47:52] <strcat> they're just token tree transformations
[05:47:54] <sfackler> Variadic functions in the style of Java or Go are a lot more palatable than C's system imo
[05:47:57] <cmr> Sharp: they are, but they're a syntactic construct separate from anything else.
[05:48:09] <sfackler> where it just ends up being syntactic sugar for an array as the last argument
[05:48:23] <pcmattman> earlzlap, tried `foo::enumvalue` (instead of the enum itself)?
[05:48:25] <Sharp> Okay, cool.  I was curious--it was conceivable we just had a lot of overloaded names with different arities :P
[05:48:41] <sfackler> it's not as much of a deal in Rust, since the array syntax is just [foo] instead of new Object[] {foo} or whatever
[05:48:44] <cmr> we don't have any overloading.
[05:48:59] <strcat> sfackler: yeah I'm fine with foo([a, b, c])
[05:49:11] <strcat> the complexity of another feature hurts more than it helps there imo
[05:49:20] <cmr> I agree
[05:49:32] <strcat> variadic *generics* (like C++11) would be nice but would obviously cause incredible type system complication, and I don't think that's worth it
[05:49:54] <ChrisMorgan> earlzlap: it's `http::server::request::RequestUri`
[05:49:56] <earlzlap> pcmattman: well, it's a function definition so I'm not sure how I woudl use the enum value
[05:50:17] <strcat> for example, in C++11 I can write a type-safe generic zip() for iterators
[05:50:18] <earlzlap> But, then how is Request defined under http::server::Request? 
[05:50:31] <strcat> in rust I can't, but I prefer chaining zip over that complexity in the type system
[05:50:36] <ChrisMorgan> earlzlap: https://github.com/chris-morgan/rust-http/blob/master/src/libhttp/server/mod.rs#L15
[05:50:43] <ChrisMorgan> It's reexported.
[05:50:51] <cmr> rusti: enum Foo { A, B } fn f(a: Foo) { println!("{:?}", a); } f(A); f(B); let x: Foo = A; f(x);
[05:50:52] -rusti- A
[05:50:52] -rusti- B
[05:50:53] -rusti- A
[05:50:53] -rusti- ()
[05:50:58] <cmr> earlzlap: ^
[05:51:07] <strcat> zip(a, b, c, d) can be happily wired up to return an iterator of std::tuple<A, B, C, D> in C++
[05:51:36] <strcat> as long as you're okay with recursive template expansion errors and so on :)
[05:52:15] <earlzlap> ah I forgot about that. ugh so many hidden things heh
[05:52:20] * strcat thinks losing that power is well worth having clear descriptions of requirements and clear errors
[05:52:23] <cmr> Forgot about what?
[05:53:41] <ChrisMorgan> cmr: the reexporting that I linked to, I presume
[05:53:47] <cmr> oh
[05:55:19] *** Joins: squiddy (squiddy@moz-C33F1661.adsl.alicedsl.de)
[05:55:56] *** Quits: dew (Instantbir@moz-E4452B8F.static.stls.mo.charter.com) (Ping timeout)
[05:55:58] *** Joins: dew (Instantbir@moz-E4452B8F.static.stls.mo.charter.com)
[05:56:19] *** Joins: fyolnish (fyolnish@moz-84E122F6.uqwimax.jp)
[05:57:25] *** Quits: fyolnish_ (fyolnish@moz-3E59912C.uqwimax.jp) (Ping timeout)
[05:59:13] *** Quits: GeneralMaximus (ankur@5D4FDDCE.241AFF02.D2D1FAF0.IP) (Ping timeout)
[06:00:24] <earlzlap> How do I use an enum with a value attached? I have a RequestUri which has AbsolutePath(~str).. but when I do `match uri { AbsolutePath(path) => path.clone(), .. }`, I get `unresolved enum variant, struct or const `AbsolutePath``
[06:00:55] <earlzlap> If I d just use `AbsolutePath` and return a garbage value from the match, it works though
[06:01:20] <strcat> pcmattman: https://github.com/thestinger/rust-core#allocators sad that I can't push this already :P
[06:01:46] <strcat> err, typo
[06:01:54] * strcat quickly amends like the evildoer he is
[06:02:03] <jstevans> Do I have to bind to my external IP if I want to listen for external requests, or do I still bind to 127.0.0.1?
[06:02:32] <cmr> jstevans: you bind to the address you want to receive requests on.
[06:02:34] <strcat> jstevans: you can bind to 0.0.0.0 to listen on every interface
[06:02:39] <cmr> jstevans: or 0.0.0.0 for all of the interfaces
[06:02:43] *** Joins: fyolnish_ (fyolnish@moz-3E59912C.uqwimax.jp)
[06:03:00] *** Quits: johns (johns@moz-BBE3ABD.mv.mozilla.com) (Ping timeout)
[06:03:03] *** Joins: johns (johns@moz-BBE3ABD.mv.mozilla.com)
[06:03:13] *** Quits: fyolnish (fyolnish@moz-84E122F6.uqwimax.jp) (Ping timeout)
[06:05:33] *** Quits: Kruppe (user@moz-E150F49F.cpe.net.cable.rogers.com) (Client exited)
[06:06:06] <jstevans> Hmm. Is there a reason why, when I try to bind to my external IP address, I get "address not available"?
[06:06:26] <Sharp> Hoom.  How do I use from_iterator properly?
[06:07:19] <strcat> Sharp: FromIterator::from_iterator(iter)
[06:07:26] <strcat> or just do iter.collect(), it's the same thing
[06:07:36] <strcat> rusti: range(0, 3).collect::<~[int]>()
[06:07:37] -rusti- ~[0, 1, 2]
[06:07:48] <strcat> rusti: range(0, 3).collect::<std::hashmap::HashSet<int>>()
[06:07:50] -rusti- pastebinned 1 lines of output: http://sprunge.us/LIYN
[06:08:03] <strcat> rusti: range(0, 3).collect::<extra::treemap::TreeSet<int>>()
[06:08:04] -rusti- pastebinned 1 lines of output: http://sprunge.us/UgdH
[06:08:20] <Sharp> It can't be the same thing completely.  In this case, for example, I want to convert from a ~[] iter to a HashSet.
[06:08:27] <Sharp> Or maybe that just won't work :P
[06:08:32] <strcat> Sharp: that will work fine
[06:08:38] <strcat> collect calls FromIterator::from_iterator
[06:08:49] <Sharp> How does it know which type to use, though?
[06:08:53] <ChrisMorgan> jstevans: it's got to be an interface that your computer recognises itself as serving.
[06:09:04] <strcat> Sharp: it's inferred, or you can pass it explicitly
[06:09:06] <strcat> like I did above
[06:09:12] <jstevans> ChrisMorgan: what does that mean?
[06:09:13] <Sharp> Ah, right.  Cool.  Thanks.
[06:09:24] *** Joins: tikue_ (tikue_star@moz-FEADCD38.hsd1.pa.comcast.net)
[06:09:33] <cmr> jstevans: if you're on linux, do an `ip addr`. Those are the addresses your interfaces have.
[06:09:42] <strcat> rusti: let xs = [1u, 2, 3]; let ys: std::hashmap::HashSet<int> = xs.iter().map(|&x| x).collect(); ys.len()
[06:09:44] -rusti- pastebinned 10 lines of output: http://sprunge.us/XXDF
[06:09:53] <strcat> rusti: let xs = [1u, 2, 3]; let ys: std::hashmap::HashSet<uint> = xs.iter().map(|&x| x).collect(); ys.len()
[06:09:54] -rusti- 3u
[06:09:55] <strcat> like that
[06:09:58] <Sharp> <3 type inference.
[06:10:08] <Sharp> Not that that was a good example of type inference, but in this case I think I can use it.
[06:10:12] <strcat> Sharp: for collect it's a pain because we lack partial type hints
[06:10:33] <strcat> https://github.com/mozilla/rust/issues/9508 not an important thing, but somewhat useful
[06:10:34] <Sharp> What would that look like?  ...?
[06:10:48] <Sharp> Oh, _.  That's better.
[06:10:49] <strcat> just saves you repeating the element type (it is sometimes very long)
[06:10:58] <Sharp> Yep.
[06:10:58] <jstevans> cmr: But then how do I accept incoming requests to my external IP address?
[06:11:06] *** Quits: tikue_ (tikue_star@moz-FEADCD38.hsd1.pa.comcast.net) (Ping timeout)
[06:13:26] <strcat> jstevans: if your interface IP isn't your external IP, you need to forward from the NAT/firewall you're behind
[06:13:29] <cmr> jstevans: Your gateway needs to be configured to forward them to the internal network.
[06:14:20] <jstevans> And then in Rust, I'd just bind to 0.0.0.0 or to my internal IP?
[06:14:37] <cmr> s/gateway/router
[06:15:30] <strcat> cmr: well, if it's an NAT :]
[06:15:44] <strcat> with a true IPv6 ISP you can likely just have a bunch of external addresses
[06:15:53] * strcat dreams of not having canadian internet
[06:16:44] <cmr> strcat: can a single interface have multiple addresses? Or is there some magic to split a single physical interfacde into multiple logical ones? (Or are vlans reused for that?)
[06:17:51] <tiffany> I dream of the day 90% of people (including me) have ipv6 connections with external addresses assigned to each machine
[06:18:25] <strcat> cmr: dunno, IPv6 stuff is magic to me because I haven't used it
[06:18:35] <cmr> strcat: same here :p
[06:18:50] <strcat> my router supports it but that's no good
[06:19:41] <strcat> and by 'my router supports it' I mean the nice router with openwrt on it that I used before my ISP decided everyone had to use their modem/router combo with a broken 'dumb gateway' mode :(
[06:19:46] <jstevans> BEAUTIFUL. Azure endpoints mystify me.
[06:20:06] <jstevans> Thanks cmr and strcat and ChrisMorgan!
[06:20:22] <tiffany> how can they enforce that strcat?
[06:20:22] <earlzlap> So. I have something like this: http://pastebin.com/rKCTzNqs and I get an error about duplicate definition of Star
[06:20:29] * ChrisMorgan gets fed up when he has to write assignments in Java, thinking how much more pleasant both Python and Rust would be in solving the problem
[06:21:00] <strcat> cmr: I was going to show you the horrible router I'm forced to use but their site is down :s
[06:21:05] <cmr> hahah
[06:21:07] <cmr> that's ironic
[06:21:24] <SiegeLord> earlzlap: Can't have that, because variants are not scoped under the enum type
[06:21:44] <strcat> cmr: ah their "americas" alternate site is up
[06:21:49] <strcat> cmr: http://www.hitron-americas.com/products/cgn-2/
[06:21:54] *** Quits: alisdair (textual@28441AAB.AC6E1995.F0AE27BD.IP) (Quit: My MacBook Pro has gone to sleep. ZZZzzz…)
[06:22:05] <strcat> such a terrible thing
[06:22:09] <McPherrin> strcat: You could get IPv6 with Teksavvy!
[06:22:47] *** Quits: dew (Instantbir@moz-E4452B8F.static.stls.mo.charter.com) (Ping timeout)
[06:23:01] <strcat> McPherrin: but then you still have to deal with bell/rogers and they intentionally break stuff.
[06:23:20] <McPherrin> strcat: Oh, I know.  I'm happy to be rid of the lot of them
[06:23:37] <earlzlap> So, you have to have those two in separate modules SiegeLord? 
[06:23:55] <SiegeLord> earlzlap: Yes, if you choose to have them have the same name
[06:23:59] <strcat> that PITA modem is half the reason I disconnect all the time :(
[06:24:00] *** Joins: GeneralMaximus (ankur@5013E005.F3B6E096.BE90E62C.IP)
[06:24:09] <strcat> and other half is just rogers throttling
[06:24:33] <strcat> you know, if I open up the router admin page all my connections stall
[06:24:42] <cmr> hahah
[06:24:54] <strcat> until it loads
[06:25:03] <cmr> how do you even screw something up that much
[06:25:11] <tiffany> my router's admin page is very moody, half the time it times out while loading for an hour
[06:25:18] <strcat> cmr: *shrug*
[06:25:25] <tiffany> it uses some httpd I've never heard of
[06:25:52] <earlzlap> What was the ideas for why that was a good way to do enums/variants? 
[06:26:10] *** Joins: dew (Instantbir@moz-E4452B8F.static.stls.mo.charter.com)
[06:26:15] <cmr> The old modem we had from before verizon and then fairpoint bought up the local ISP was rock solid. It died (of age, presumably) and the new one is total crap.
[06:26:20] <cmr> Needs to be reset at least daily.
[06:27:06] * ChrisMorgan waaannts enums soooo much in this Java project
[06:27:20] <strcat> cmr: https://paste.xinu.at/UvX8vo/ glorious admin pages 'can aid troubleshooting for the network connectivity'
[06:27:59] *** Quits: dew (Instantbir@moz-E4452B8F.static.stls.mo.charter.com) (Ping timeout)
[06:28:12] *** Joins: dew (Instantbir@moz-E4452B8F.static.stls.mo.charter.com)
[06:28:21] <cmr> ChrisMorgan: yeah. Rust's enums are probably the feature I miss the most when usnig  other language.s
[06:28:25] <tiffany> got to love paying $80 for a 200mhz MIPS CPU running very badly put together linux installs
[06:28:32] <cmr> The other stuff is just convenience, but I've come to rely very heavily on ADTs.
[06:28:34] <strcat> cmr: this page opens a java applet if I click ping
[06:28:55] <cmr> strcat: and it's served with asp
[06:29:01] <ChrisMorgan> cmr: I would only complain a little if it had tuples/multiple return instead, but no—
[06:29:09] <tiffany> that's some nice engrish your router has going there strcat
[06:29:33] <strcat> their footer is a low quality jpg of text
[06:30:07] <strcat> and they use js to make it so you can't easily click it
[06:30:13] *** ercxx is now known as ercxx__away
[06:30:15] <ktt3ja> why do I get different outputs even though the two cases run about the same code? http://pastebin.com/KeK28izF
[06:31:20] <cmr> ChrisMorgan: don't forget about http://docs.octayn.net/http/ for whoever is using rust-http ;)
[06:31:22] <strcat> System Uptime -080.0 days 12h:29m:15s
[06:31:49] <ChrisMorgan> cmr: I won't.
[06:32:52] *** Quits: voxpopuli (fanservice@moz-CEF3689A.hsd1.pa.comcast.net) (Ping timeout)
[06:33:05] <earlzlap> Well, I thought I was going to go crazy there for a bit, but rustymvc finally works with rust-http 
[06:33:06] <earlzlap> https://github.com/Earlz/rustymvc/blob/master/examples/rust-http.rs
[06:33:07] <ChrisMorgan> strcat: I see you use i3. I've been using it for the past few weeks too :-)
[06:33:18] <strcat> <3 i3
[06:34:00] * ChrisMorgan even made his power button do a fancy mode switch to offer the option to press it again to turn it off (just like a projector!), lock, sleep, hibernate, reboot
[06:35:45] *** Parts: z0w0 (zack@moz-C877F2F7.lnse2.cha.bigpond.net.au) ()
[06:35:51] <strcat> ChrisMorgan: I wish I had an excuse to use screen locking ;p
[06:35:54] <strcat> i3lock -c $(openssl rand -hex 3)
[06:36:08] <strcat> you never know what you'll get! :)
[06:36:10] *** Joins: z0w0 (zack@moz-C877F2F7.lnse2.cha.bigpond.net.au)
[06:36:16] <ChrisMorgan> ... interesting idea; I like it.
[06:36:47] *** Joins: FreeFull (freefull@DC27D1D7.255A7E04.6B0ACFBD.IP)
[06:37:01] *** Quits: z0w0 (zack@moz-C877F2F7.lnse2.cha.bigpond.net.au) (Quit: z0w0)
[06:37:32] *** Joins: alisdair (textual@28441AAB.AC6E1995.F0AE27BD.IP)
[06:39:34] *** Joins: robertknight (robertknig@moz-54528EE0.wby.mendeley.com)
[06:40:05] *** Quits: alisdair (textual@28441AAB.AC6E1995.F0AE27BD.IP) (Quit: My MacBook Pro has gone to sleep. ZZZzzz…)
[06:40:06] *** Joins: DAddYE (DAddYE@moz-98D3933F.hsd1.ca.comcast.net)
[06:40:20] * ChrisMorgan quickly restarts his window manager and locks his machine, basking in his newfound colour
[06:41:19] *** Quits: robertknight (robertknig@moz-54528EE0.wby.mendeley.com) (Ping timeout)
[06:41:56] *** Quits: DAddYE (DAddYE@moz-98D3933F.hsd1.ca.comcast.net) (Ping timeout)
[06:43:20] *** Quits: johns (johns@moz-BBE3ABD.mv.mozilla.com) (Ping timeout)
[06:43:21] *** Joins: johns (johns@moz-BBE3ABD.mv.mozilla.com)
[06:43:53] <Luqman> cmr: i don't plan on adding support for non-foreign functions :P
[06:44:29] * strcat can make sane seccomp bindings soon!
[06:45:21] *** Quits: mark_edward (quassel@75BF936B.B013F95F.2DC05E66.IP) (Quit: http://quassel-irc.org - Chat comfortably. Anywhere.)
[06:47:07] *** Joins: jdavis (jdavis@moz-1BE8A6A1.hsd1.ca.comcast.net)
[06:47:34] <jdavis> Is there a library (ideally in the standard library) for date/time handling?
[06:51:06] <strcat> kmc: I think LLVM won't actually generate recursive calls for a memcpy in rust, but we do need that linkage issue fixed first
[06:51:07] *** Joins: jensnockert (jensnocker@moz-7DC16A5F.afb.bredband2.com)
[06:52:58] *** Quits: jensnockert (jensnocker@moz-7DC16A5F.afb.bredband2.com) (Ping timeout)
[06:53:14] *** jorendorff is now known as jorendorff_away
[06:53:16] <jdavis> OK, I found https://github.com/mozilla/rust/wiki/Lib-datetime , but it took a while because "rust" is not the most google-friendly term (though better than "go" ;-)
[06:53:56] <Sharp> Nor is C, nor BASIC.  Nor many a language name.  That's one thing Java got right :P
[06:54:47] *** Quits: earlzlap (earlz@moz-9E279EAD.neo.res.rr.com) (Ping timeout)
[06:55:14] <McPherrin> Sharp: There are other means of Java too :p
[06:55:29] <Sharp> Yes, but they don't seriously conflict with it in Google results.
[06:55:34] <McPherrin> golang isn't so bad
[06:55:49] <McPherrin> Rustlang isn't as catchy :)
[06:56:19] <FreeFull> Nobody has trouble finding Malbolge, assuming they spelled it correctly
[06:56:20] <jdavis> Though I don't think I found an actual library, I think I found a wiki page asking for a library to be written.
[06:56:33] <SiegeLord> jdavis: At the very end there is a repository
[06:56:42] <FreeFull> Although it is named after another thing too
[06:56:50] <eddyb9> the light at the end of the tunnel
[06:56:50] <jdavis> Ah, cool.
[06:56:52] <Sharp> type `~[std::path::posix::Path]` does not implement any method in scope named `collect` -- what am I doing wrong here?
[06:57:13] <SiegeLord> jdavis: It looks outdated though... so it might as well not exist
[06:57:18] <FreeFull> INTERCAL? I don't think there is anything called INTERCAL other than the language
[06:57:20] <Eridius> Sharp: why are you trying to call .collect() on a ~[]? That's a method that belongs to ITerator
[06:57:35] <Sharp> Well, I can transfer it to .iter().
[06:57:53] <SiegeLord> I don't think it counts if you add a string after your language name to make it easier to find :P
[06:57:58] <Sharp> But when I do, I can't seem to get it to create an array of unboxed values.
[06:57:58] *** Joins: feduser (feduser@6445537B.5167330B.CDBED010.IP)
[06:58:15] <myname> FreeFull: when in doubt you can still search for "programming language with no pronouncable acronym"
[06:58:27] <Eridius> Sharp: you seem to be confused. .collect() accumulates an iterator into a container. The most common container used this way is a ~[], which you already have
[06:58:31] <Eridius> Sharp: what exactly are you trying to do?
[06:58:44] <Sharp> See, that's actually not what I'm trying to do :P  I'm turning it into a HashSet, as described earlier.
[06:58:46] <Eridius> ~[std::path::posix::Path] already is a vector of unboxed values. There's no boxes on the Paths
[06:58:49] <feduser> is there any operator/function to find type of a variable? 
[06:58:55] <Eridius> Sharp: ok, try .move_iter().collect()
[06:59:00] <Sharp> Ah, move_iter().  Will do.
[06:59:02] <Eridius> feduser: just trigger a compiler error
[06:59:21] <Eridius> Sharp: so by "boxed values" what you meant is you ended up with references?
[06:59:35] <Sharp> Boxed may not have been the right word :P  I'm tired.
[06:59:39] <strcat> Sharp: if you use iter, you get references, so you'd need to .map(|&x| x) or .map(|x| x.clone())
[06:59:48] <jdavis> I am trying to implement something similar to "range types" in postgres, which are most useful for ranges of time. One snag though is that there might be two different range types over the same base type with a different total order.
[06:59:50] <strcat> but if it's a ~[T] and it's the last use, move_iter is better
[06:59:57] <Sharp> Yes, it wouldn't let me do .map(|&x| x) due to liveness issues.  And yes, it's the last use.
[06:59:58] <strcat> (in many cases)
[07:00:09] <Sharp> Yep, that worked, thanks.
[07:00:15] <Eridius> Sharp: well you'd have to call .clone(). it's not implicitly clonable
[07:00:17] <strcat> Sharp: |&x| x will only work if it's not a type that does moves
[07:00:18] <Eridius> err implicitly copyable
[07:00:28] *** Quits: strcat (strcat@moz-54F7FD49.cpe.net.cable.rogers.com) (Quit: sleep)
[07:00:31] <Sharp> Right
[07:00:32] *** Joins: Axord (xord@moz-1B228827.lsanca.dsl-w.verizon.net)
[07:00:36] <feduser> eh, i did find size_of function, so then, no way to get typeof.
[07:00:38] <Sharp> I'd rather not clone() stuff unless I have to, though
[07:00:40] <Sharp> Which in this case I don't.
[07:00:50] <jdavis> In postgres, you can do that, e.g. two different text range orderings based on two different locales. Any pointers on a good way to do that in rust?
[07:00:52] <myname> wait, |&x| x does a clone?
[07:00:56] <myname> *makes
[07:00:57] <myname> wtf
[07:01:32] <dbaupp> myname: no, where did you get that idea?
[07:01:34] <Eridius> myname: |&x| x only works for types that can be implicitly copied
[07:01:44] <Eridius> for example, int
[07:01:45] <dbaupp> only .clone() does a clone.
[07:01:52] <myname> Eridius: but it does not clone?
[07:02:19] <Eridius> myname: for such types, the end result is most likely identical to what you'd get if you called .clone(), but a type could always choose to implement .clone() differently if it wanted to
[07:02:22] <dbaupp> SHcalling .clone() isn't necessary very expensive, e.g. |&x|  x and |x| x.clone() will compile to the same thing (with optimisation on) for primitive types
[07:02:24] *** Quits: JamesNZ (james@moz-264643C7.bitstream.orcon.net.nz) (Quit: Busying myself...)
[07:02:40] <dbaupp> *Sharp: ^
[07:03:05] <Eridius> rusti: struct Foo { x: int } impl Clone for Foo { fn clone(&self) -> Foo { Foo { x: self.x+1 } } } let f = Foo { x: 3 }; let g = f.clone(); println!("{:?}, {:?}", f, g)
[07:03:05] <Sharp> For primitives, maybe :)  It's hard to do anything expensive with primitives though.
[07:03:06] -rusti- main::Foo{x: 3}, main::Foo{x: 4}
[07:03:06] -rusti- ()
[07:03:11] <Eridius> myname: ^
[07:03:35] <jdavis> Can one type have several implementations of the same trait? E.g. text might be Orderable according to several different total orders.
[07:03:46] *** Quits: eddyb (eddy@37F72125.9065A63B.FCAAE698.IP) (Ping timeout)
[07:03:46] *** Quits: dew (Instantbir@moz-E4452B8F.static.stls.mo.charter.com) (Ping timeout)
[07:03:50] *** Joins: dew (Instantbir@moz-E4452B8F.static.stls.mo.charter.com)
[07:04:39] <dbaupp> jdavis: no
[07:04:45] *** Quits: jstevans (Instantbir@D27AFFDF.362CC69C.B7830B68.IP) (Ping timeout)
[07:05:02] <jdavis> Any suggestions about how that kind of thing might be handled? 
[07:05:30] *** jorendorff_away is now known as jorendorff
[07:05:35] <jdavis> E.g. different collations?
[07:05:54] <eddyb9> different modules?
[07:05:57] <Eridius> you could define a newtype struct that implements the different ordering, and then wrap your type in the newtype struct
[07:05:57] <jdavis> OK.
[07:06:03] <myname> you could make your own trait with an ordering parameter, but i'm not sure if you can use </==/> then
[07:06:04] *** Joins: Jessin (Jessin_@moz-9BB5F6CF.cc.lehigh.edu)
[07:06:08] <jdavis> Oh, ok.
[07:06:25] <jdavis> Is newtype kind of like in haskell?
[07:06:40] <Eridius> struct Foo(int);
[07:06:51] <Eridius> rusti: struct Foo(int); let x = 3i; let y = Foo(x); y
[07:06:52] -rusti- main::Foo(3)
[07:07:03] *** Quits: Jesin (Jessin_@moz-9BB5F6CF.cc.lehigh.edu) (Ping timeout)
[07:07:09] <Eridius> and you can "dereference" such structs to get the original value back
[07:07:12] <Eridius> rusti: struct Foo(int); let x = 3i; let y = Foo(x); *y
[07:07:13] -rusti- 3
[07:07:35] <jdavis> OK. I will try that out. Thanks!
[07:07:41] *** Joins: Ms2ger (Ms2ger@moz-EC6C128C.adsl-dyn.isp.belgacom.be)
[07:07:48] *** Joins: eddyb (eddy@37F72125.9065A63B.FCAAE698.IP)
[07:12:42] *** Joins: oberstet (quassel@moz-B2946949.dynamic.mnet-online.de)
[07:13:51] *** Quits: james4k (james@moz-E7990244.consolidated.net) (Ping timeout)
[07:13:54] <ChrisMorgan> "Argh! If I added another item to this enum I'd have to expect everything to break all over the place, at runtime!" — Java never had much shine in my eyes (though for different reasons when I was 12 and first played with it!), but Rust has made it even more unpleasant to work in. Requiring exhaustive matches is a *great* thing.
[07:16:29] <Sharp> How many times does rust compile itself when I make check?
[07:17:04] <Eridius> I think 3 times?
[07:17:22] <Sharp> Okay, cool.  That's what I'd expect.
[07:17:23] <McPherrin> once more than usual I think
[07:17:33] <Eridius> builds stage0 libs, uses them to build stage1 compile. Then that builds stage1 libs, uses them to build stage2 compiler. then that builds stage2 libs, uses them to build stage3 compiler. And that's it
[07:17:37] <Sharp> Third time is presumably to verify that the output is identical to the second time.
[07:18:25] <Eridius> stage1 compiler is often different than stage2 compiler, because of newly-added features that had to be disabled for stage0 (because the snapshot compiler couldn't handle them)
[07:18:53] <Sharp> Makes sense.
[07:18:58] <Eridius> so the stage2 compiler hopefully includes all the latest stuff, which is then used to build stage3 compiler
[07:19:09] <Eridius> because you want your compiler built by the correct fully-functional compiler, not by the handicapped one
[07:19:15] <Sharp> Heh.  Right.
[07:20:55] *** Quits: SilverKey (SilverKey@moz-B589DA51.sw.biz.rr.com) (Quit: My MacBook Pro has gone to sleep. ZZZzzz…)
[07:26:31] *** Joins: sankha93 (Instantbir@7061CD01.D6BD0D91.22D41759.IP)
[07:28:11] *** Quits: ktt3ja (Mibbit@moz-6B6EE8C0.hsd1.va.comcast.net) (Quit: http://www.mibbit.com ajax IRC Client)
[07:32:12] *** Quits: squiddy (squiddy@moz-C33F1661.adsl.alicedsl.de) (Ping timeout)
[07:35:09] *** Quits: SiegeLord (sl@moz-CAF07B4C.hsd1.ma.comcast.net) (Quit: It's a joke, it's all a joke.)
[07:39:25] <Sharp> How do I run tests without building?  I want to make sure my test actually failed before my changes.
[07:40:54] <Eridius> you can't build tests without building the thing you're testing
[07:41:06] <dbaupp> Sharp: is it a library #[test], or a src/test test?
[07:41:14] <Sharp> src/test test.
[07:41:17] <Eridius> ok good point. The compile/runtests can be built separately
[07:41:29] <Eridius> Sharp: just build them manually with rustc
[07:41:39] *** Joins: DAddYE (DAddYE@moz-98D3933F.hsd1.ca.comcast.net)
[07:41:46] <Sharp> That won't build the directives, though, will it?
[07:41:59] <Eridius> directives?
[07:42:26] <Sharp> e.g. // xfail-fast
[07:42:31] <Sharp> Or // aux-build:issue_3979_traits.rs
[07:42:46] <Eridius> oh. There's a whole test runner, but I'm not familiar enough with it
[07:42:48] <Sharp> I care about the latter more than the former.
[07:42:59] *** Quits: johns (johns@moz-BBE3ABD.mv.mozilla.com) (Ping timeout)
[07:43:00] *** Joins: johns (johns@moz-BBE3ABD.mv.mozilla.com)
[07:43:00] <dbaupp> Sharp: you can do that by hand too
[07:43:11] <Sharp> Well, sure, but I want to make sure it's actually doing what I think it's doing :)
[07:43:23] *** Quits: DAddYE (DAddYE@moz-98D3933F.hsd1.ca.comcast.net) (Ping timeout)
[07:43:37] <dbaupp> oh, it's doing something weird with the directives?
[07:43:54] <Sharp> Yeah, I'm using aux-build: twice with the same source.
[07:44:00] <Sharp> In order to simulate -L duplication.
[07:44:10] <Eridius> I didn't even know about aux-build
[07:44:14] <dbaupp> you can probably do something like `make -n check-stage2-rpass VERBOSE=1`
[07:44:25] <dbaupp> and copy the last command
[07:44:26] <Eridius> dbaupp: that won't rebuild the libraries too?
[07:44:27] <dbaupp> (that will just show the commands, not run them.)
[07:44:32] <Eridius> ah I see what you're saying
[07:44:33] <Sharp> Yeah, once it's done completely I will.
[07:44:42] <Eridius> ideally it would respect NO_REBUILD=1 but very few commands actually do :/
[07:44:44] <Sharp> Was just curious if there was a way to do it before that.
[07:44:46] <Sharp> Heh.
[07:45:07] <dbaupp> Sharp: note that the `-n` means make won't actually do the building.
[07:45:20] <Sharp> Good to know.
[07:45:35] <Sharp> Is there a check-stage0-rpass?
[07:45:36] <dbaupp> and with the VEBOSE=1 it'll show the whole command it will run
[07:45:45] <Sharp> Or, wait.  Never mind :P
[07:45:49] <dbaupp> so you can copy that to get the invocation.
[07:46:11] <dbaupp> wait. you probably want to pass `TESTNAME=<filename>` to run just your test
[07:46:16] <Sharp> Yes.
[07:46:34] *** Joins: bholley (anonymous@moz-CB983BB6.superkabel.de)
[07:47:18] *** jorendorff is now known as jorendorff_away
[07:57:46] *** Quits: bholley (anonymous@moz-CB983BB6.superkabel.de) (Quit: bholley)
[07:58:59] *** Quits: BizarreCake (BizarreCak@moz-361FE9B2.dynamic.barak-online.net) (Connection reset by peer)
[07:59:16] *** Quits: Sharp (Sharp@1710C26.8381A41.8725677B.IP) (Quit: Sharp)
[08:00:41] *** Joins: sk (sk@33BA8621.70EDD053.57C4AB8D.IP)
[08:00:47] *** Quits: jeffdb_ (jeff@moz-D13B6004.hsd1.ca.comcast.net) (Quit: jeffdb_)
[08:03:21] <jld> ...oh.  The rustpkg tests were failing with confusing assertions about files not existing... because it was shelling out to rustpkg and rustpkg was dying with SIGILL because it ran out of stack.
[08:03:24] *** Quits: johns (johns@moz-BBE3ABD.mv.mozilla.com) (Ping timeout)
[08:03:29] *** Joins: johns (johns@moz-BBE3ABD.mv.mozilla.com)
[08:06:35] <jdavis> I am trying to install https://github.com/sfackler/rust-postgres -- what do I do? It looks like I can use it as an external module, but then when I try to compile the example in the readme, it says: "can't find crate for `postgres`".
[08:07:25] <jld> ...and it eats the subprocess's log messages.
[08:08:38] *** Quits: dew (Instantbir@moz-E4452B8F.static.stls.mo.charter.com) (Ping timeout)
[08:08:50] *** Joins: dew (Instantbir@moz-E4452B8F.static.stls.mo.charter.com)
[08:11:56] <SimonSapin> I seem to remember that we’re aiming for Rust 1.0 next year, is this still accurate?
[08:12:15] *** Quits: sankha93 (Instantbir@7061CD01.D6BD0D91.22D41759.IP) (Ping timeout)
[08:13:54] *** Joins: sankha93 (Instantbir@7061CD01.D6BD0D91.22D41759.IP)
[08:16:44] *** Quits: Earnestly (earnest@moz-BE290A2B.dyn.plus.net) (Ping timeout)
[08:17:42] *** Joins: Bort (dontyuthin@moz-16692C89.lnse2.win.bigpond.net.au)
[08:17:47] *** Parts: Bort (dontyuthin@moz-16692C89.lnse2.win.bigpond.net.au) ()
[08:20:16] *** Quits: fyolnish_ (fyolnish@moz-3E59912C.uqwimax.jp) (Client exited)
[08:20:20] *** Joins: fyolnish (fyolnish@moz-3E59912C.uqwimax.jp)
[08:23:42] *** Joins: nsf (nsf@moz-EEF3238A.convex.ru)
[08:24:58] *** Quits: sp3d (s@6361F3B1.19CD1E54.8354FB35.IP) (Ping timeout)
[08:26:01] *** Quits: adu (ajr@moz-60B25736.washdc.fios.verizon.net) (Quit: adu)
[08:26:06] *** Joins: lenstr (lenstr@AF8EB999.6049B16A.85938D85.IP)
[08:27:23] *** Quits: Jesse (jruderman@moz-537BCF9.hsd1.ca.comcast.net) (Connection reset by peer)
[08:41:06] *** Quits: Jessin (Jessin_@moz-9BB5F6CF.cc.lehigh.edu) (Ping timeout)
[08:42:32] *** Joins: DAddYE (DAddYE@moz-98D3933F.hsd1.ca.comcast.net)
[08:42:58] *** Quits: johns (johns@moz-BBE3ABD.mv.mozilla.com) (Ping timeout)
[08:43:03] *** Joins: johns (johns@moz-BBE3ABD.mv.mozilla.com)
[08:43:49] *** Joins: Jesse (jruderman@moz-537BCF9.hsd1.ca.comcast.net)
[08:44:15] *** Quits: DAddYE (DAddYE@moz-98D3933F.hsd1.ca.comcast.net) (Ping timeout)
[08:45:02] <jld> It looks like rustpkg might be bypassing rustc::monitor.
[08:46:49] *** Joins: Blub\w (wry@7E3BB9D.71150E1A.237AE2BA.IP)
[08:46:55] *** Quits: GeneralMaximus (ankur@5013E005.F3B6E096.BE90E62C.IP) (Ping timeout)
[08:50:00] *** Quits: lenstr (lenstr@AF8EB999.6049B16A.85938D85.IP) (Client exited)
[08:50:34] *** Joins: lenstr (lenstr@AF8EB999.6049B16A.85938D85.IP)
[08:51:09] *** Joins: lenstr_ (lenstr@AF8EB999.6049B16A.85938D85.IP)
[08:51:10] *** Quits: lenstr (lenstr@AF8EB999.6049B16A.85938D85.IP) (Connection reset by peer)
[08:52:03] *** Joins: jensnockert (jensnocker@moz-7DC16A5F.afb.bredband2.com)
[08:53:52] *** Quits: jensnockert (jensnocker@moz-7DC16A5F.afb.bredband2.com) (Ping timeout)
[08:58:44] *** Joins: Jessin (Jessin_@moz-9BB5F6CF.cc.lehigh.edu)
[08:59:04] *** Joins: GeneralMaximus (ankur@5013E005.F3B6E096.BE90E62C.IP)
[08:59:45] *** Joins: Sharp (Sharp@moz-7B61DF4.dsl.static.sonic.net)
[09:03:02] *** Joins: Jesse_ (jruderman@moz-537BCF9.hsd1.ca.comcast.net)
[09:03:53] *** Quits: Jesse (jruderman@moz-537BCF9.hsd1.ca.comcast.net) (Ping timeout)
[09:12:31] *** Joins: glennsl (textual@moz-5D7B804F.getinternet.no)
[09:15:19] *** Joins: skade (skade@moz-A89F791B.pools.arcor-ip.net)
[09:18:14] *** Quits: skade (skade@moz-A89F791B.pools.arcor-ip.net) (Quit: My MacBook Pro has gone to sleep. ZZZzzz…)
[09:18:16] *** Joins: nkoep (nik@moz-8E4694BE.pool.mediaways.net)
[09:22:39] *** Quits: feduser (feduser@6445537B.5167330B.CDBED010.IP) (Quit: Leaving)
[09:23:09] *** Quits: sankha93 (Instantbir@7061CD01.D6BD0D91.22D41759.IP) (Ping timeout)
[09:23:34] *** Joins: sankha93 (Instantbir@7061CD01.D6BD0D91.22D41759.IP)
[09:25:04] *** Joins: squiddy (squiddy@moz-C33F1661.adsl.alicedsl.de)
[09:34:03] *** Joins: nano (nano@moz-74CAD1CA.superkabel.de)
[09:39:39] *** Joins: skade (skade@moz-A89F791B.pools.arcor-ip.net)
[09:40:24] *** Quits: brendan (brendaneic@moz-A19854B6.mcln.va.megapath.net) (Quit: brendan)
[09:42:05] *** Quits: GeneralMaximus (ankur@5013E005.F3B6E096.BE90E62C.IP) (Ping timeout)
[09:42:06] *** Quits: lenstr_ (lenstr@AF8EB999.6049B16A.85938D85.IP) (Client exited)
[09:42:40] *** Joins: lenstr (lenstr@AF8EB999.6049B16A.85938D85.IP)
[09:44:16] *** Joins: DAddYE (DAddYE@moz-98D3933F.hsd1.ca.comcast.net)
[09:44:21] *** Quits: lenstr (lenstr@AF8EB999.6049B16A.85938D85.IP) (Ping timeout)
[09:45:59] *** Quits: DAddYE (DAddYE@moz-98D3933F.hsd1.ca.comcast.net) (Ping timeout)
[09:46:41] *** Joins: lenstr (lenstr@AF8EB999.6049B16A.85938D85.IP)
[09:48:06] *** Quits: nattofriends (tsutsumi@moz-4CEEC7AA.warosu.org) (Ping timeout)
[09:48:41] *** Joins: nattofriends (tsutsumi@moz-A9E340E1.fuqu.jp)
[09:49:15] *** Joins: spider-mario (spidermari@moz-81131DB6.fbx.proxad.net)
[09:49:48] *** Quits: a__ (a__@moz-4CC03B10.nycmny.fios.verizon.net) (Ping timeout)
[09:50:30] *** Joins: jensnockert (jensnocker@moz-7DC16A5F.afb.bredband2.com)
[09:54:32] *** Joins: GeneralMaximus (ankur@5013E005.F3B6E096.BE90E62C.IP)
[09:55:14] *** Quits: fyolnish (fyolnish@moz-3E59912C.uqwimax.jp) (Client exited)
[09:56:22] *** Quits: barosl (barosl@3DE683B6.E551553C.7544CABF.IP) (Quit: 랜덤은 쇠퇴했습니다.)
[09:59:57] *** Joins: mikezaby (mikezaby@moz-B26868E.home.otenet.gr)
[10:06:55] *** Joins: Jackneill (Jackneill@moz-7F14DEFC.pool.digikabel.hu)
[10:16:12] *** Quits: lenstr (lenstr@AF8EB999.6049B16A.85938D85.IP) (Client exited)
[10:16:43] *** Joins: lenstr (lenstr@AF8EB999.6049B16A.85938D85.IP)
[10:18:23] *** Quits: lenstr (lenstr@AF8EB999.6049B16A.85938D85.IP) (Ping timeout)
[10:21:18] *** Quits: mikezaby (mikezaby@moz-B26868E.home.otenet.gr) (Input/output error)
[10:21:24] *** Quits: squiddy (squiddy@moz-C33F1661.adsl.alicedsl.de) (Ping timeout)
[10:31:23] *** Joins: Cromulent (Cromulent@moz-C2470BE2.cable.virginm.net)
[10:32:24] *** Joins: maik (maik@moz-10F9C3B5.dip0.t-ipconnect.de)
[10:35:53] *** Quits: nano (nano@moz-74CAD1CA.superkabel.de) (Connection reset by peer)
[10:40:03] *** Joins: robertknight (robertknig@moz-1FB7516D.range81-157.btcentralplus.com)
[10:41:16] *** Joins: robertkn_ (robertknig@moz-54528EE0.wby.mendeley.com)
[10:43:02] *** Quits: robertkn_ (robertknig@moz-54528EE0.wby.mendeley.com) (Ping timeout)
[10:44:55] *** Quits: devbug (quassel@23AC5F12.9D950176.3655BBF5.IP) (Connection reset by peer)
[10:45:25] *** Joins: DAddYE (DAddYE@moz-98D3933F.hsd1.ca.comcast.net)
[10:45:32] <TeXitoi> -W unnecessary-allocation : what it is supposed to detect? I can't find code that emit it.
[10:45:55] <dbaupp> rusti: "foo" == ~"bar"
[10:45:56] -rusti- <anon>:9:18: 9:24 warning: unnecessary allocation, the sigil can be removed, #[warn(unnecessary_allocation)] on by default
[10:45:56] -rusti- <anon>:9          "foo" == ~"bar"
[10:45:56] -rusti-                            ^~~~~~
[10:45:56] -rusti- false
[10:47:11] <dbaupp> rusti: fn f(_: &str) {} f(~"foo")
[10:47:12] -rusti- <anon>:9:28: 9:34 warning: unnecessary allocation, the sigil can be removed, #[warn(unnecessary_allocation)] on by default
[10:47:12] -rusti- <anon>:9          fn f(_: &str) {} f(~"foo")
[10:47:12] -rusti-                                      ^~~~~~
[10:47:12] -rusti- ()
[10:47:18] *** Quits: DAddYE (DAddYE@moz-98D3933F.hsd1.ca.comcast.net) (Ping timeout)
[10:47:38] <eddyb> that's smart... pretty much opposite from Java :P
[10:48:02] <dbaupp> it's not very smart
[10:48:05] <dbaupp> rusti: rusti: fn f(_: &int) {} f(~1)
[10:48:06] -rusti- pastebinned 6 lines of output: http://sprunge.us/ZZFg
[10:48:13] <dbaupp> rusti: rusti: fn f(_: &int) {} f(~1)
[10:48:14] -rusti- pastebinned 6 lines of output: http://sprunge.us/FgMB
[10:48:18] <dbaupp> rusti: fn f(_: &int) {} f(~1)
[10:48:19] -rusti- ()
[10:48:43] <eddyb> lol
[10:49:38] <TeXitoi> thanks
[10:49:38] <eddyb> rusti: fn f(_: &[int]) {} f(~[1, 2, 3])
[10:49:39] -rusti- <anon>:9:30: 9:40 warning: unnecessary allocation, the sigil can be removed, #[warn(unnecessary_allocation)] on by default
[10:49:39] -rusti- <anon>:9          fn f(_: &[int]) {} f(~[1, 2, 3])
[10:49:39] -rusti-                                        ^~~~~~~~~~
[10:49:39] -rusti- ()
[10:51:30] <dbaupp> just strings and vectors, which are better than nothing since they (should be) the place that most people see ~
[10:51:40] *** Quits: Sharp (Sharp@moz-7B61DF4.dsl.static.sonic.net) (Quit: Sharp)
[10:51:41] *** Joins: q66 (q66@6EE9DE40.46454B5D.33AABD5F.IP)
[10:52:03] <kimundi> dbaupp: Could you put a r+ on https://github.com/mozilla/rust/pull/9967 ? brson already reviewed and r+ed it a few times yesterday, but the build failed because of a unreachable gyp repo first, and then because I removed an import line that was only necessary for windows. That last one is the only difference between the current commit, and the one brson put a r+ on :)
[10:52:41] <jensnockert> If anyone is interested in IEEE 754 / floating-point, please comment on https://github.com/mozilla/rust/issues/10087
[10:53:01] *** Quits: FreeFull (freefull@DC27D1D7.255A7E04.6B0ACFBD.IP) (Ping timeout)
[10:53:08] <TeXitoi> rusti: fn f(_: int) {} f(*~0) 
[10:53:08] -rusti- ()
[10:53:22] <dbaupp> jensnockert: that includes compensating for deficiencies/inaccuracies in LLVM/libc, right?
[10:53:27] *** Joins: FreeFull (freefull@DC27D1D7.255A7E04.6B0ACFBD.IP)
[10:53:43] <dbaupp> kimundi: could you copy the "updated description" into the PR text?
[10:53:46] <jensnockert> dbaupp: The idea is to find the deficiencies, another bug would be to fix them.
[10:53:55] <dbaupp> kimundi: it just makes the log nicer
[10:54:02] *** Joins: fyolnish (fyolnish@moz-2D12B841.uqwimax.jp)
[10:54:04] <jensnockert> dbaupp: My idea is to build up a test suite.
[10:54:16] <dbaupp> kimundi: (i.e. including correct information, rather than outdated stuf)
[10:54:34] <jensnockert> So we know what is broken on what platforms.
[10:54:47] <dbaupp> jensnockert: yup; I meant, the goal would be full ieee compliance, not just saying "the platform is broken so we're broken too"
[10:55:03] <jensnockert> dbaupp: In the long run, that is what I want, yes.
[10:55:08] * dbaupp agrees
[10:55:19] *** Quits: fyolnish (fyolnish@moz-2D12B841.uqwimax.jp) (No route to host)
[10:55:22] <kimundi> dbaupp: Hm, I actually did it this way because otherwise the comments and discussions below it wouldn't make sense. But I guess I could just prepend the new text in front of the old one
[10:55:40] *** Joins: fyolnish (fyolnish@moz-2D12B841.uqwimax.jp)
[10:56:15] <jensnockert> dbaupp: If we want to be able to support cross-platform reproducible floating-point, we need to do it. (And since a lot of people want to write games in Rust, that could be a killer feature)
[10:56:41] <dbaupp> jensnockert: apparently graydon was on some of the ieee floating point commities (random fact of the day :P )
[10:57:11] <dbaupp> jensnockert: yeah, having "guaranteed" reproducability across all platforms would be very nice
[10:57:23] *** Quits: fyolnish (fyolnish@moz-2D12B841.uqwimax.jp) (Ping timeout)
[10:57:45] <kimundi> dbaupp: Updated description
[10:57:45] <jensnockert> dbaupp: Yeah, he helped write IEEE 754-2008 apparently.
[10:58:22] <jensnockert> This probably means that Graydon is even more of my idol now.
[10:58:23] *** Joins: Ferreus (ferreus@moz-596EAB7.pools.arcor-ip.net)
[10:58:33] *** Quits: Amaranth (travis@moz-F81BB56A.cpe.cableone.net) (Ping timeout)
[10:59:19] <dbaupp> kimundi: hopefully this won't break buildbot (super long commit messages have made it unhappy in the past... I hope that's either fixed or this one is short enough.)
[10:59:40] *** Quits: GeneralMaximus (ankur@5013E005.F3B6E096.BE90E62C.IP) (Ping timeout)
[10:59:56] <dbaupp> jensnockert: heh
[10:59:58] <dbaupp> it'll nice if he comes back and starts rusting again
[11:00:18] <kimundi> dbaupp: Hm. Commit or PR message?
[11:00:35] <dbaupp> kimundi: both, bors makes a commit with the PR message :P
[11:00:45] <kimundi> Oh, okay xD
[11:01:32] <kimundi> If it breaks, I'll just trim the old from it
[11:02:00] <kimundi> history of those things goes bad fast anyway once you start refactoring and changing things around
[11:02:46] <dbaupp> "those things" == PR text?
[11:03:00] <dbaupp> that's why you update it as you refactor ;P
[11:04:56] *** Joins: GeneralMaximus (ankur@5013E005.F3B6E096.BE90E62C.IP)
[11:04:57] *** Joins: nano (nano@moz-74CAD1CA.superkabel.de)
[11:05:43] *** Quits: _1126 (1126@moz-83D60E55.lileth.net) (Quit: leaving)
[11:07:08] *** Joins: lenstr (lenstr@AF8EB999.6049B16A.85938D85.IP)
[11:08:57] *** Quits: lenstr (lenstr@AF8EB999.6049B16A.85938D85.IP) (Ping timeout)
[11:16:05] *** Quits: eddyb9 (eddy@37F72125.9065A63B.FCAAE698.IP) (Quit: Leaving)
[11:18:58] *** Joins: lenstr (lenstr@AF8EB999.6049B16A.85938D85.IP)
[11:19:07] *** Joins: sebcrozet (sebcrozet@moz-87D51607.w80-13.abo.wanadoo.fr)
[11:20:10] *** Quits: sebcrozet (sebcrozet@moz-87D51607.w80-13.abo.wanadoo.fr) (Quit: Gone)
[11:20:38] <dbaupp> jensnockert: your text and quote in https://github.com/mozilla/rust/issues/10087#issuecomment-27144180 appear to contradict each other "I don't want to take on the gargantuan task ...", "In the long run, that is what I want, yes."
[11:20:59] <jensnockert> Yes, I noticed, I had edited it.
[11:21:21] <jensnockert> There should be a "yet" somewhere in there now.
[11:21:56] <XMunkki> ieee 754-2008 sounds nice (in functionality) but perhaps a bit expensive (with current hardware not necessarily doing it yet, so we'd have to resort to software emulation?)
[11:22:36] <jensnockert> XMunkki: Almost all hardware supports most of it.
[11:22:59] <jensnockert> XMunkki: FMA / Sqrt are the only things that most do not implement in hardware.
[11:23:20] <dbaupp> XMunkki: we can at least work out where we differ (which is what that bug is addressing)
[11:23:22] <XMunkki> tried googling but a quick google didn't reveal too much.. (perhaps fail at googling :)
[11:23:41] <XMunkki> dbaupp: yeah of course :)
[11:23:50] <jensnockert> XMunkki: Some slower chips have software path for denormals, but then the user can disable the software path if they need it.
[11:24:20] <XMunkki> and I guess having a "fast math" type flag to allow for result changing optimizations (like in some other languages) would still be possible
[11:24:40] *** Quits: nsf (nsf@moz-EEF3238A.convex.ru) (Connection reset by peer)
[11:25:20] <jensnockert> XMunkki: Yeah, in a fast-math mode, all bets would be off.
[11:26:13] <XMunkki> hmm should actually return to my 32.32 fixed point library project at some point :)
[11:26:20] *** Joins: nsf (nsf@moz-EEF3238A.convex.ru)
[11:26:31] <XMunkki> or even port it to rust
[11:26:50] <jensnockert> Yeah, I had one at one point too.
[11:26:52] <jensnockert> brb.
[11:27:03] <dbaupp> assuming llvm has a fast-math flag rustc --llvm-args='-ffast-math' would work now in theory.
[11:27:22] <FreeFull> rusti: unsafe { let foo : *int = 0; *foo; }
[11:27:23] -rusti- pastebinned 7 lines of output: http://sprunge.us/aCQT
[11:27:48] <dbaupp> rusti: unsafe { let foo = 0 as *int; *foo; }
[11:27:49] -rusti- ()
[11:28:00] <dbaupp> rusti: unsafe { let foo = 0 as *int; *foo }
[11:28:01] -rusti- application terminated abnormally with signal 11 (Segmentation fault)
[11:28:12] <dbaupp> dead-statement elimination
[11:28:15] <FreeFull> Ok, makes sense
[11:28:46] <FreeFull> It's always nice to find out how to segfault in any given programming language
[11:29:04] <FreeFull> In Haskell you can  peek nullPtr
[11:29:25] <dbaupp> rusti: let mut a = ~1; a = a;
[11:29:26] -rusti- <anon>:9:25: 9:26 warning: value assigned to `a` is never read, #[warn(dead_assignment)] on by default
[11:29:26] -rusti- <anon>:9          let mut a = ~1; a = a;
[11:29:26] -rusti-                                   ^
[11:29:26] -rusti- ()
[11:29:29] <dbaupp> rusti: let mut a = ~1; a = a; a
[11:29:30] -rusti- ~application terminated abnormally with signal 11 (Segmentation fault)
[11:29:58] * Ms2ger raises an eyebrow
[11:30:00] <dbaupp> (that one is just a compiler bug with a short test-case though.)
[11:30:03] <XMunkki> I guess it's been discussed to death already, but maybe special casing a trailing ';' -separator to default to the previous expression instead of a (not visible) unit might cause less confusion? as to a c/c++ programmer "*foo" and "*foo;" look like they should do the same thing (as ";" is thought or a delimiter, not a separator)
[11:30:22] <XMunkki> and requiring an explicit "*foo;()" if you wanted to return a unit
[11:30:44] <dbaupp> XMunkki: how often do you write a `*foo` and care that it remains?
[11:31:07] *** Joins: reedlepee (Mibbit@9B9315E1.A6025CA.1C37C358.IP)
[11:31:18] *** Joins: fyolnish (fyolnish@moz-7D8CE57B.uqwimax.jp)
[11:31:19] <XMunkki> well talking about more generic expressions here.. like "1;" vs "1"
[11:31:39] <dbaupp> Ms2ger: I assume it's getting itself tied into knows about running destructors at the correct time/place.
[11:31:42] <dbaupp> *knots
[11:31:52] <Ms2ger> Apparently :)
[11:32:21] <reedlepee> dbaupp: Could you please help me in selecting another bug to work on ..
[11:32:31] *** Quits: tedh (tedh@moz-F0B37C08.hsd1.il.comcast.net) (Ping timeout)
[11:34:42] <dbaupp> reedlepee: there's all the E-easy bugs, and there's this list https://wiki.mozilla.org/GNOME_Outreach_December2013#Contributions_for_Rust of a subset of the E-easy bugs that tjc (etc) have selected as managable
[11:35:50] <reedlepee> yeah from that only which one i should work on ?
[11:36:13] *** Quits: lenstr (lenstr@AF8EB999.6049B16A.85938D85.IP) (Client exited)
[11:36:27] <dbaupp> any! choose one that you're interested in
[11:36:28] *** Joins: tedh (tedh@moz-F0B37C08.hsd1.il.comcast.net)
[11:38:11] *** Joins: lenstr (lenstr@AF8EB999.6049B16A.85938D85.IP)
[11:40:21] <reedlepee> dbaupp: https://github.com/mozilla/rust/issues/2181 what about this ?
[11:41:11] <reedlepee> would it be ok to work on it ?
[11:42:39] <dbaupp> reedlepee: yes! looks good :) (make sure to comment on it to say that you're working on it)
[11:42:58] *** Joins: canhtak (jeremy@moz-3BB8F.wl.t.ulaval.ca)
[11:43:21] *** Joins: james4k (james@moz-E7990244.consolidated.net)
[11:43:42] *** Joins: steffenomak (steffenoma@moz-FB0A4BEB.student.uu.se)
[11:45:05] *** Quits: james4k (james@moz-E7990244.consolidated.net) (Ping timeout)
[11:45:16] <reedlepee> dbaupp: Could you please a little about the bug!! How should i go about it ?
[11:45:41] *** Quits: bleibig (bleibig@moz-CB11172C.hsd1.ca.comcast.net) (Quit: bleibig)
[11:46:03] <dbaupp> reedlepee: http://stackoverflow.com/a/4049562/1256624 looks like it's got code for linux, mac osx and windows
[11:46:15] *** Joins: DAddYE (DAddYE@moz-98D3933F.hsd1.ca.comcast.net)
[11:46:16] <dbaupp> so converting that into a form that can be used by Rust is how to start.
[11:47:01] *** Joins: Earnestly (earnest@moz-BE290A2B.dyn.plus.net)
[11:47:58] *** Quits: DAddYE (DAddYE@moz-98D3933F.hsd1.ca.comcast.net) (Ping timeout)
[11:48:39] <reedlepee> u mean to say that the code here http://stackoverflow.com/a/4049562/1256624 should be converted to rust..
[11:48:56] <jensnockert> dbaupp: Yeah, LLVM has a fast-math mode.
[11:49:23] <dbaupp> reedlepee: yes. but looking at the actual code, that is probably very hard to do for all 3 platforms.
[11:49:37] <jensnockert> dbaupp: But I think it is enabled per-instruction.
[11:49:44] <jensnockert> dbaupp: http://llvm.org/docs/LangRef.html#fast-math-flags
[11:51:06] <dbaupp> jensnockert: ah, so there's no global mode?
[11:51:16] <jensnockert> dbaupp: No idea, actually.
[11:51:36] *** Quits: nano (nano@moz-74CAD1CA.superkabel.de) (Connection reset by peer)
[11:54:25] *** Quits: victorporof|away (victorporo@75D4E0BA.E3B14EAA.D111398B.IP) (Quit: victorporof|away)
[11:55:48] *** Quits: lenstr (lenstr@AF8EB999.6049B16A.85938D85.IP) (Client exited)
[11:59:57] *** Joins: lenstr (lenstr@AF8EB999.6049B16A.85938D85.IP)
[12:00:16] *** Joins: mortisha (Mibbit@moz-31DDF89A.dip0.t-ipconnect.de)
[12:00:41] *** Parts: mortisha (Mibbit@moz-31DDF89A.dip0.t-ipconnect.de) ()
[12:12:10] *** Joins: donri (donri@moz-9BB61102.tbcn.telia.com)
[12:15:06] *** Parts: robert (robert@moz-C7DC1A73.lin.openzula.org) ()
[12:15:41] *** Joins: victorporof (victorporo@75D4E0BA.E3B14EAA.D111398B.IP)
[12:16:10] *** Quits: lenstr (lenstr@AF8EB999.6049B16A.85938D85.IP) (Client exited)
[12:16:42] *** Quits: skade (skade@moz-A89F791B.pools.arcor-ip.net) (Quit: My MacBook Pro has gone to sleep. ZZZzzz…)
[12:16:44] *** Joins: lenstr (lenstr@AF8EB999.6049B16A.85938D85.IP)
[12:18:31] *** Quits: lenstr (lenstr@AF8EB999.6049B16A.85938D85.IP) (Ping timeout)
[12:18:40] *** Quits: robertknight (robertknig@moz-1FB7516D.range81-157.btcentralplus.com) (Ping timeout)
[12:19:17] <dbaupp> reedlepee: ping
[12:20:21] <reedlepee> dbaupp: yep
[12:21:28] *** Joins: lenstr (lenstr@AF8EB999.6049B16A.85938D85.IP)
[12:21:55] <dbaupp> reedlepee: you emailed me :P I think the best thing would be to implement the algorithms from https://github.com/mozilla/rust/issues/6220#issuecomment-21306047
[12:22:00] *** Joins: maxli (maxli@moz-4D28BA20.student.cs.uwaterloo.ca)
[12:22:25] *** Quits: tedh (tedh@moz-F0B37C08.hsd1.il.comcast.net) (Ping timeout)
[12:22:31] <reedlepee> dbaupp: yeah just i came to know that u are Huon Wilson :P
[12:23:07] <dbaupp> reedlepee: I guess the newer one ( http://www.cs.tufts.edu/%7Enr/cs257/archive/florian-loitsch/printf.pdf ) would be a good place to start
[12:23:13] *** Quits: lenstr (lenstr@AF8EB999.6049B16A.85938D85.IP) (Ping timeout)
[12:25:06] <reedlepee> dbaupp: I would like to know where are you online on irc?
[12:25:15] <reedlepee> if you tell me your timings 
[12:25:32] <reedlepee> so that i can communicate with you 
[12:25:43] <reedlepee> sorry when?
[12:25:50] *** Joins: tedh (tedh@moz-F0B37C08.hsd1.il.comcast.net)
[12:26:27] *** Joins: CarpNet (Alasdair@moz-25C796BC.cable.virginm.net)
[12:26:35] *** Quits: CarpNet (Alasdair@moz-25C796BC.cable.virginm.net) (Connection reset by peer)
[12:26:38] *** Joins: mrmonday (mrmonday@moz-C7DC1A73.lin.openzula.org)
[12:27:31] <dbaupp> reedlepee: I'm in Australia, so I'm mostly online from 2300 to 1300 UTC, but it varies
[12:27:43] * dbaupp hopes he got the timezone conversions correct
[12:29:36] *** JanC_ is now known as JanC
[12:30:31] <dbaupp> reedlepee: I can't offer much more help than anyone else here, though, the only stuff I know was from some brief research 6 months ago. (which is all documented in that bug)
[12:30:34] *** Quits: RMF (RMF@moz-3DF68881.dsl.telepac.pt) (Ping timeout)
[12:31:38] <dbaupp> reedlepee: basically what I am saying is you can ask for help with that bug from people other than me. They will know just as much as I do. :)
[12:32:23] *** Quits: reedlepee (Mibbit@9B9315E1.A6025CA.1C37C358.IP) (Quit: http://www.mibbit.com ajax IRC Client)
[12:34:07] *** Joins: RMF (RMF@moz-1EE56143.dsl.telepac.pt)
[12:39:28] *** Quits: RMF (RMF@moz-1EE56143.dsl.telepac.pt) (Ping timeout)
[12:41:04] *** Joins: skade (skade@moz-A89F791B.pools.arcor-ip.net)
[12:42:05] *** Joins: robertknight (robertknig@moz-54528EE0.wby.mendeley.com)
[12:43:14] *** Joins: RMF (RMF@moz-1EE56143.dsl.telepac.pt)
[12:43:15] *** Quits: johns (johns@moz-BBE3ABD.mv.mozilla.com) (Ping timeout)
[12:43:23] *** Joins: johns (johns@moz-BBE3ABD.mv.mozilla.com)
[12:43:55] *** Quits: robertknight (robertknig@moz-54528EE0.wby.mendeley.com) (Ping timeout)
[12:45:26] *** Joins: lenstr (lenstr@AF8EB999.6049B16A.85938D85.IP)
[12:46:35] *** Quits: jensnockert (jensnocker@moz-7DC16A5F.afb.bredband2.com) (Broken pipe)
[12:47:51] *** Quits: lenstr (lenstr@AF8EB999.6049B16A.85938D85.IP) (Client exited)
[12:48:16] *** Joins: DAddYE (DAddYE@moz-98D3933F.hsd1.ca.comcast.net)
[12:49:56] *** Quits: DAddYE (DAddYE@moz-98D3933F.hsd1.ca.comcast.net) (Ping timeout)
[12:56:47] *** Joins: lenstr (lenstr@AF8EB999.6049B16A.85938D85.IP)
[12:58:23] *** Quits: lenstr (lenstr@AF8EB999.6049B16A.85938D85.IP) (Client exited)
[13:00:05] *** Quits: Cromulent (Cromulent@moz-C2470BE2.cable.virginm.net) (Quit: KVIrc 4.2.0 Equilibrium http://www.kvirc.net/)
[13:01:06] *** Quits: sk (sk@33BA8621.70EDD053.57C4AB8D.IP) (Quit: Leaving)
[13:01:55] *** Joins: Amaranth (travis@moz-F81BB56A.cpe.cableone.net)
[13:02:34] *** Joins: lenstr (lenstr@AF8EB999.6049B16A.85938D85.IP)
[13:04:38] *** Quits: lenstr (lenstr@AF8EB999.6049B16A.85938D85.IP) (Client exited)
[13:05:45] *** Joins: vu3rdd (vu3rdd@721FA998.2EC825E7.BE90E62C.IP)
[13:06:25] *** Joins: lenstr (lenstr@AF8EB999.6049B16A.85938D85.IP)
[13:06:51] *** Quits: lenstr (lenstr@AF8EB999.6049B16A.85938D85.IP) (Client exited)
[13:07:23] *** Joins: lenstr (lenstr@AF8EB999.6049B16A.85938D85.IP)
[13:09:03] *** Quits: lenstr (lenstr@AF8EB999.6049B16A.85938D85.IP) (Ping timeout)
[13:13:02] *** Joins: alonlevy (alon@moz-61A0AD83.red.bezeqint.net)
[13:14:59] *** Joins: jvns (quassel@moz-DE62990.nyc.res.rr.com)
[13:15:50] *** Joins: MrFahrenheit (RageOfThou@3FEF494C.29C984D5.783DEDCA.IP)
[13:23:25] *** Quits: johns (johns@moz-BBE3ABD.mv.mozilla.com) (Ping timeout)
[13:23:28] *** Joins: johns (johns@moz-BBE3ABD.mv.mozilla.com)
[13:24:12] *** Joins: lenstr (lenstr@AF8EB999.6049B16A.85938D85.IP)
[13:25:03] *** Joins: z0w0 (zack@moz-238C2341.lnse3.cha.bigpond.net.au)
[13:25:53] *** Quits: lenstr (lenstr@AF8EB999.6049B16A.85938D85.IP) (Ping timeout)
[13:26:04] *** Quits: fyolnish (fyolnish@moz-7D8CE57B.uqwimax.jp) (Client exited)
[13:27:23] <maikeru> So many rust aussies...
[13:30:15] *** Joins: jensnockert (jensnocker@moz-7DC16A5F.afb.bredband2.com)
[13:36:16] <dbaupp> maikeru: not enough
[13:37:02] *** Quits: victorporof (victorporo@75D4E0BA.E3B14EAA.D111398B.IP) (Ping timeout)
[13:38:11] <Ms2ger> Never enough aussies, clearly
[13:39:52] *** Quits: alonlevy (alon@moz-61A0AD83.red.bezeqint.net) (Ping timeout)
[13:40:20] <dbaupp> not enough until #rust is equally busy 24 hours a day
[13:40:49] *** Joins: alisdair (textual@28441AAB.AC6E1995.F0AE27BD.IP)
[13:44:56] *** Joins: cowboyd (cowboyd@moz-DD0FF83.lightspeed.austtx.sbcglobal.net)
[13:45:11] *** Parts: canhtak (jeremy@moz-3BB8F.wl.t.ulaval.ca) ()
[13:45:32] *** Joins: canhtak (jeremy@moz-3BB8F.wl.t.ulaval.ca)
[13:47:04] *** Joins: victorporof (victorporo@75D4E0BA.E3B14EAA.D111398B.IP)
[13:49:59] *** Quits: cowboyd (cowboyd@moz-DD0FF83.lightspeed.austtx.sbcglobal.net) (Client exited)
[13:50:22] *** Quits: jensnockert (jensnocker@moz-7DC16A5F.afb.bredband2.com) (Input/output error)
[13:52:21] *** Joins: bjz_ (brendanzab@B398BE78.F804C29E.D35A31DF.IP)
[13:52:33] *** Quits: nsf (nsf@moz-EEF3238A.convex.ru) (Quit: WeeChat 0.4.2)
[13:52:48] *** Quits: bjz (brendanzab@B398BE78.F804C29E.D35A31DF.IP) (Client exited)
[13:53:46] <ChrisMorgan> At least there are a few Australians.
[13:54:10] *** Quits: blank_name (blank_name@2E4E7E43.800E1818.31EC03F3.IP) (Ping timeout)
[13:54:44] *** Joins: lenstr (lenstr@AF8EB999.6049B16A.85938D85.IP)
[13:56:27] *** Joins: fyolnish (fyolnish@moz-7D8CE57B.uqwimax.jp)
[13:56:41] *** Quits: lenstr (lenstr@AF8EB999.6049B16A.85938D85.IP) (Ping timeout)
[13:59:06] *** Quits: fyolnish (fyolnish@moz-7D8CE57B.uqwimax.jp) (Ping timeout)
[14:00:40] *** Joins: cowboyd (cowboyd@moz-DD0FF83.lightspeed.austtx.sbcglobal.net)
[14:00:41] *** Quits: maxli (maxli@moz-4D28BA20.student.cs.uwaterloo.ca) (Quit: Leaving.)
[14:00:44] *** Joins: maxli (maxli@moz-4D28BA20.student.cs.uwaterloo.ca)
[14:01:40] *** Quits: alisdair (textual@28441AAB.AC6E1995.F0AE27BD.IP) (Quit: My MacBook Pro has gone to sleep. ZZZzzz…)
[14:01:56] *** Quits: skade (skade@moz-A89F791B.pools.arcor-ip.net) (Quit: My MacBook Pro has gone to sleep. ZZZzzz…)
[14:03:46] *** Quits: jvns (quassel@moz-DE62990.nyc.res.rr.com) (Ping timeout)
[14:06:32] *** Joins: alonlevy (alon@moz-B0E66DB7.static.bezeqint.net)
[14:07:00] *** Joins: tetsuharu (tetsuharu@moz-A3FEAA56.ap219.ftth.ucom.ne.jp)
[14:07:35] *** Quits: tetsuharu (tetsuharu@moz-A3FEAA56.ap219.ftth.ucom.ne.jp) (Client exited)
[14:07:36] *** Joins: tetsuharu (tetsuharu@moz-A3FEAA56.ap219.ftth.ucom.ne.jp)
[14:10:51] *** Quits: victorporof (victorporo@75D4E0BA.E3B14EAA.D111398B.IP) (Ping timeout)
[14:11:47] *** Joins: Mogul (Mibbit@moz-19D52E4F.skybroadband.com)
[14:12:43] <Mogul> Hey, I just have a quick question as I'm still learning Rust - what exactly is the * pointer type for? I can't find any information in the tutorial
[14:13:05] <Mogul> I might just not be looking hard enough though
[14:13:12] <zokier`> (mostly) for c interoperation
[14:13:54] <Mogul> Ah, so they're more or less the same as I'd expect * to work in C?
[14:14:34] <kimundi> * Is a raw pointer, which doesn't consider anything about ownership, mutability or memory safeness. Dereferencing it is unsafe because of that.
[14:14:39] <kimundi> yes
[14:14:50] *** Joins: victorporof (victorporo@75D4E0BA.E3B14EAA.D111398B.IP)
[14:15:12] <kimundi> We also have *mut T, but that is more for being able to notate the intent, it doesn't have a real difference to plain *T
[14:16:23] <vu3rdd> Mogul: I am on the same path as you. Found this post very useful: http://pcwalton.github.io/blog/2013/03/18/an-overview-of-memory-management-in-rust/
[14:16:47] <Mogul> Ah I see, thank you kimundi.
[14:16:52] <Mogul> vu3rdd: will give it a read now, thanks
[14:19:18] *** Joins: pseudoku (quassel@63872.787D7D11.520CDC98.IP)
[14:19:23] *** Joins: mib_ecgrox (Mibbit@moz-FAC32130.dsl.telepac.pt)
[14:20:10] <pseudoku> hi, what is the rustic way of reading a single byte from a FileReader?
[14:20:57] * kimundi has a feeling IO needs to get sorted out fast, and that he needs to learn about it once its ready.
[14:23:53] *** Joins: blank_name (blank_name@2E4E7E43.800E1818.31EC03F3.IP)
[14:25:44] *** Joins: jdm (jdm@moz-6A7642F9.rave.ac.uk)
[14:25:44] *** ChanServ sets mode: +o jdm
[14:27:18] *** Joins: lenstr (lenstr@AF8EB999.6049B16A.85938D85.IP)
[14:29:58] *** Quits: Jessin (Jessin_@moz-9BB5F6CF.cc.lehigh.edu) (Ping timeout)
[14:31:02] *** Quits: Axord (xord@moz-1B228827.lsanca.dsl-w.verizon.net) (Quit: I'm sure it's perfectly safe)
[14:31:44] <pseudoku> how do i cast [u8,..1] (stack allocated) to &mut  [u8] ?
[14:31:58] <Ms2ger> &mut foo?
[14:32:21] <Ms2ger> Wasn't there a way to split an array into non-overlapping mutable slices?
[14:32:26] <pseudoku> i get 'mismatched types: expected `&mut [u8]` but found `&mut [u8, .. 1]` (expected vector but found &-ptr)'
[14:32:52] <eddyb> pseudoku: *~, maybe?
[14:33:09] *** Joins: BizarreCake (BizarreCak@moz-361FE9B2.dynamic.barak-online.net)
[14:33:11] <eddyb> rusti: *~[u8,..1]
[14:33:12] -rusti- pastebinned 7 lines of output: http://sprunge.us/PZZh
[14:33:14] <eddyb> rusti: *~[0u8,..1]
[14:33:15] -rusti- pastebinned 7 lines of output: http://sprunge.us/IhAd
[14:33:26] <eddyb> rusti: ~[0u8,..1]
[14:33:27] -rusti- ~[0u8]
[14:33:45] <eddyb> rusti: let mut a = ~[0u8,..1]; *a
[14:33:46] -rusti- pastebinned 7 lines of output: http://sprunge.us/BYEX
[14:33:47] <eddyb> rusti: let mut a = ~[0u8,..1]; a
[14:33:48] -rusti- <anon>:9:17: 9:18 warning: variable does not need to be mutable, #[warn(unused_mut)] on by default
[14:33:48] -rusti- <anon>:9          let mut a = ~[0u8,..1]; a
[14:33:48] -rusti-                           ^
[14:33:48] -rusti- ~[0u8]
[14:33:53] <eddyb> meh, no idea
[14:34:01] <pseudoku> basically i need to read a single byte from a file. the read function expects a &mut [u8], eddyb: i'd like to avoid an allocation
[14:35:07] <eddyb> rusti: [0u8].to_slice()
[14:35:08] -rusti- pastebinned 7 lines of output: http://sprunge.us/LdbJ
[14:35:21] <eddyb> rusti: &[0u8]
[14:35:22] -rusti- &[0u8]
[14:35:26] <eddyb> rusti: &mut [0u8]
[14:35:27] -rusti- &mut [0u8]
[14:35:50] <eddyb> rusti: let a = [0u8]; &mut a
[14:35:51] -rusti- pastebinned 21 lines of output: http://sprunge.us/NUig
[14:36:03] <eddyb> pseudoku: I'm not sure :/
[14:36:32] <pseudoku> eddyb: no problem, thanks any ways
[14:36:58] *** Quits: cowboyd (cowboyd@moz-DD0FF83.lightspeed.austtx.sbcglobal.net) (Client exited)
[14:38:33] <ChrisMorgan> pseudoku: rust-http needs single byte reading a lot; it's a common pattern. (a) it's as_slice that you need.
[14:38:40] <ChrisMorgan> rusti: let a: [u8, ..1] = [0u8]; format!("{:?}", a.as_slice())
[14:38:40] -rusti- ~"&[0u8]"
[14:39:27] <eddyb> aaaah, as_slice. I was close :P
[14:39:29] <ChrisMorgan> (b) there's a method read_byte() on std::rt::io::extensions::ReaderUtil which abstracts this away
[14:40:04] <pseudoku> ChrisMorgan: thanks, thats exactly what i needed
[14:40:38] <ChrisMorgan> eddyb: as_* means "make a reference to self of some other type", while to_* means "make a copy of self in some other type", and into_* means "consume self, turning it into something of some other type"
[14:42:20] <ChrisMorgan> pseudoku: ReaderUtil has some other things there that you might like, like `push_bytes(&mut ~[u8])` and `bytes()`, which turns it into an byte iterator
[14:43:23] * ChrisMorgan wonders whether push_bytes really needs to take &mut ~[u8] rather than &mut [u8], but admits he doesn't have time to investigate the point at present
[14:44:23] *** Joins: ozten (ozten@moz-DD3B00B4.hsd1.wa.comcast.net)
[14:45:20] <kimundi> ChrisMorgan: Can'T grow a &mut [u8]
[14:45:21] <ChrisMorgan> Oh, of course it does. Only ~[u8] allows pushing because it could entail an allocation.
[14:45:26] <kimundi> right
[14:45:37] *** Quits: vu3rdd (vu3rdd@721FA998.2EC825E7.BE90E62C.IP) (Ping timeout)
[14:48:08] <pseudoku> after reading the byte i'd like to check if it a character i expect. when i use the following code '  Some('d' as u8) => None,'  i get  error: expected `,` but found `as`
[14:48:33] <kimundi> pseudoku: Not that a byte != a character
[14:48:50] <kimundi> Note*
[14:49:12] <pseudoku> kimundi: so the cast is disallowed? 
[14:49:15] <kimundi> Of course, if you only care about ascii that'S moot
[14:49:27] <kimundi> AH, casts in match arms are disallowed
[14:50:13] <kimundi> try matching on 'match opt.map(|v| v as char) { Some('d') => None, ... }'
[14:50:18] <ChrisMorgan> Correct. Some time we should get byte literals, of the form 'd'u8
[14:50:42] *** Quits: z0w0 (zack@moz-238C2341.lnse3.cha.bigpond.net.au) (Client exited)
[14:50:58] <ChrisMorgan> Two solutions: `Some(b) if b == 'd' as u8`, and defining a constant and using it like `Some(_b@U8_d)`
[14:51:08] *** Joins: jvns (quassel@moz-DE62990.nyc.res.rr.com)
[14:51:09] *** Joins: DAddYE (DAddYE@moz-98D3933F.hsd1.ca.comcast.net)
[14:51:34] *** Joins: a__ (a__@moz-6F5CFC76.nycmny.fios.verizon.net)
[14:51:57] <kimundi> ... Or option three: map it beforehand like I proposed :P
[14:52:05] <canhtak> Hi rust-devs, someone know if rustc works on os x 10.9 or not?
[14:52:22] <pseudoku> ChrisMorgan: if i use a constant how will rustc know if it is a binding or a constant name?
[14:52:53] <ChrisMorgan> pseudoku: that's where the Some(_b@U8_d) came in; _b is the binding, which is required to be equal to the value U8_d
[14:52:54] <pseudoku> kimundi: thanks
[14:53:23] * kimundi has no idea what ChrisMorgan is talking about here xD
[14:54:06] *** Quits: jdm (jdm@moz-6A7642F9.rave.ac.uk) (Quit: Lost terminal)
[14:54:07] <ChrisMorgan> I was using that earlier today like this: `Some(b@SP) | Some(b@CR) | Some(b@LF)`, then checking if b was SP, CR or LF to determine what precisely to do deeper in.
[14:54:12] <eddyb> pseudoku: I would try to get a character, not a byte, but that requires a str and retrying to get a character until you actually have a valid one. and normalization can be a bitch. hmpf. you only need this for ASCII, nvm me
[14:54:25] <eddyb> ChrisMorgan: what's with @ in there?
[14:54:42] <eddyb> I haven't seen infix @ at all until now
[14:54:43] <ChrisMorgan> It's a feature taken from Haskell, can't remember what it's called.
[14:54:45] *** Quits: DAddYE (DAddYE@moz-98D3933F.hsd1.ca.comcast.net) (Ping timeout)
[14:54:59] <eddyb> rusti: let foo@bar = 7; foo@bar
[14:55:00] -rusti- pastebinned 6 lines of output: http://sprunge.us/hhHU
[14:55:08] <ChrisMorgan> It's in patterns.
[14:55:13] <eddyb> ChrisMorgan: oh, I see what you mean
[14:55:18] <eddyb> it's still odd
[14:55:45] <ChrisMorgan> I only know about it because of someone asking about that feature from Haskell and someone in here said that it was in, in exactly the same form. And lo and behold, it is.
[14:55:57] <eddyb> rusti: match Some(7) {Some(x@7) => x, Some(x) => -x, None => 0}
[14:55:58] -rusti- 7
[14:56:04] <eddyb> rusti: match Some(5) {Some(x@7) => x, Some(x) => -x, None => 0}
[14:56:04] -rusti- -5
[14:57:04] <ChrisMorgan> The alternative of `Some(x) if x == 7` isn't always possible if you're dealing with multiple possibilities, such as `Foo(x@7) | Bar(x@3)`.
[14:57:05] <eddyb> rusti: let I7 = 7; match Some(7) {Some(x@I7) => x, Some(x) => -x, None => 0}
[14:57:06] -rusti- pastebinned 7 lines of output: http://sprunge.us/iNdX
[14:57:16] *** Joins: ambimorph (amber@moz-F1964F26.hlrn.qwest.net)
[14:57:22] <eddyb> woot?
[14:57:32] *** Joins: fyolnish (fyolnish@moz-4A1CB68C.uqwimax.jp)
[14:57:47] <ChrisMorgan> Still, it's a feature most won't immediately understand or be familiar with, so I've been contemplating suggesting its removal and seeing what uproar occurs.
[14:58:02] <ChrisMorgan> It's always fun doing that sort of thing :D
[14:58:06] <eddyb> ChrisMorgan: but... it doesn't work :/
[14:58:22] <eddyb> rusti: let I7 = 7; match Some(7) {Some(I7) => x, Some(x) => -x, None => 0}
[14:58:23] -rusti- pastebinned 7 lines of output: http://sprunge.us/VMUY
[14:58:38] <eddyb> wait, that seems to work, though
[14:59:00] *** Joins: hjr3 (hradtke@moz-E87BDF1F.socal.res.rr.com)
[14:59:15] *** Quits: fyolnish (fyolnish@moz-4A1CB68C.uqwimax.jp) (Ping timeout)
[14:59:25] <eddyb> nvm it matches into I7 not against I7
[14:59:49] <pseudoku> ChrisMorgan: how do i call read_byte on a &Reader...i've imported ReaderUtil but still get an compile error ... error: failed to find an implementation of trait std::rt::io::Reader for &std::rt::io::Reader<no-bounds>
[14:59:53] <eddyb> ChrisMorgan: can you actually get b@v to work with non-literal v?
[15:00:10] <ChrisMorgan> eddyb: I haven't any notion, any notion.
[15:00:14] *** Joins: nano (nano@moz-74CAD1CA.superkabel.de)
[15:01:08] <ChrisMorgan> pseudoku: that's correct; a trait object &T doesn't implement T for reasons that are typically considered Quite Abstruse.
[15:01:53] <ChrisMorgan> (That is, it doesn't implement it automatically. In almost all situations, it can be implemented manually.)
[15:02:00] <ChrisMorgan> Sorry, that's actually not the reason in this case.
[15:02:10] <ChrisMorgan> pseudoku: you need a &mut Reader, a &Reader won't do.
[15:03:22] *** Quits: johns (johns@moz-BBE3ABD.mv.mozilla.com) (Ping timeout)
[15:03:23] *** Joins: johns (johns@moz-BBE3ABD.mv.mozilla.com)
[15:04:17] *** Quits: glennsl (textual@moz-5D7B804F.getinternet.no) (Quit: My MacBook Pro has gone to sleep. ZZZzzz…)
[15:04:53] <pseudoku> I'm still getting an error, 
[15:04:53] <pseudoku> error: cannot borrow immutable argument as mutable
[15:04:53] <pseudoku> match reader.read_byte() {
[15:05:07] <pseudoku> reader is an &mut Reader
[15:05:56] <ChrisMorgan> Are you sure that's where the problem is occurring?
[15:06:14] <eddyb> rusti: [].iter.filter
[15:06:15] -rusti- pastebinned 7 lines of output: http://sprunge.us/HXGD
[15:06:17] <eddyb> rusti: [].iter().filter
[15:06:18] -rusti- pastebinned 7 lines of output: http://sprunge.us/FfVM
[15:06:46] <pseudoku> ChrisMorga: thats the line the compiler prints out...
[15:09:07] <eddyb> http://www.reddit.com/r/rust/comments/1p99x8/request_for_code_review_dawkins_weasel/ <3 `code` in comments
[15:09:45] *** Joins: tikue_ (tikue_star@F6141FA3.3B4A6B80.689607DE.IP)
[15:15:03] *** Joins: nsf (nsf@moz-EEF3238A.convex.ru)
[15:20:05] *** Joins: james4k (james@moz-E7990244.consolidated.net)
[15:20:34] *** Joins: mib (Mibbit@moz-5AF9AA47.hsd1.va.comcast.net)
[15:22:00] *** Quits: james4k (james@moz-E7990244.consolidated.net) (Ping timeout)
[15:24:23] *** Joins: alisdair (textual@E1CEBB1A.D061F0C9.AA6AEE7B.IP)
[15:24:54] <mib> is there a way to directly access the cache using rust 0.8?
[15:25:12] *** Quits: hjr3 (hradtke@moz-E87BDF1F.socal.res.rr.com) (Quit: My MacBook has gone to sleep. ZZZzzz…)
[15:25:23] *** Quits: jvns (quassel@moz-DE62990.nyc.res.rr.com) (Ping timeout)
[15:25:23] <kimundi> what cache?
[15:27:02] <pseudoku> ChrisMorgan: is this a bug in the compiler or is the code wrong?  https://gist.github.com/anonymous/7170668
[15:27:26] *** Quits: mib (Mibbit@moz-5AF9AA47.hsd1.va.comcast.net) (Quit: http://www.mibbit.com ajax IRC Client)
[15:28:27] <ChrisMorgan> pseudoku: oh, I percieve. `reader` must also be in a mutable slot, e.g. `parse(mut reader: &mut Reader)`.
[15:28:34] <ChrisMorgan> s/percieve/perceive/
[15:28:36] * ChrisMorgan should go to bed
[15:28:37] *** Quits: tikue_ (tikue_star@F6141FA3.3B4A6B80.689607DE.IP) (Ping timeout)
[15:29:39] <ChrisMorgan> Still, that's odd, because it's only for trait objects that it needs to be in a mutable slot.
[15:29:50] <pseudoku> ChrisMorgan: mutable slots?...i've never heard of them before..
[15:29:59] <ChrisMorgan> (reader: &mut FileReader) works fine, but (reader: &mut Reader) needs to be (mut reader: &mut Reader).
[15:30:24] <ChrisMorgan> The binding needs to be mutable—as in `let mut x` in contrast to `let x`.
[15:30:31] <kimundi> pseudoku: "mutable slot", "mutable variable" "mutable location", etc
[15:30:36] <eddyb> http://www.reddit.com/r/rust/comments/1p99x8/request_for_code_review_dawkins_weasel/cd01avb?context=5 am I right?
[15:30:50] <kimundi> basically, "the owner is allowed to mutate it"
[15:31:47] <ChrisMorgan> pseudoku: my assessment is that the "cannot borrow immutable argument as mutable" is a bug; the trait object &mut T should be considered mutable just as the struct object &mut T is.
[15:31:58] <pseudoku> kimundi: then what does the &mut in &mut Reader mean??
[15:32:26] <kimundi> pseudoku: Its a reference trait object that can mutate the value through the reference
[15:32:52] <pseudoku> ChrisMorgan: yeah, that seems to make more sense
[15:33:02] <TeXitoi> kimundi: that's dynamic polymorphism?
[15:33:37] <ChrisMorgan> pseudoku: please feel free to search for a bug on GitHub and if you can't find anything quickly, report it.
[15:33:56] *** Joins: tikue_ (tikue_star@F6141FA3.3B4A6B80.689607DE.IP)
[15:34:00] <pseudoku> kimundi: isn't having a mutable reference enough to invoke read_byte? why should the variable holding the reference also be mutable
[15:35:10] <kimundi> pseudoku: No idea, should not be necessary if read_bytes only takes &mut self
[15:35:23] <ChrisMorgan> pseudoku: that's the bug; `t: &mut T` should be enough, and it is for a struct object, but for a trait object it isn't at present and you need `mut t: &mut T`.
[15:36:21] *** Quits: clement (clement@moz-D3DDF83F.delafargue.name) (Quit: WeeChat 0.3.2)
[15:36:33] <pseudoku> ChrisMorgan: I think you are more qualified to open the bug than me...i have no idea what you just said :)
[15:36:46] *** Quits: alisdair (textual@E1CEBB1A.D061F0C9.AA6AEE7B.IP) (Quit: My MacBook Pro has gone to sleep. ZZZzzz…)
[15:36:55] <ChrisMorgan> pseudoku: well, I'm finishing off this bit of assignment and then going to bed, at being 2:36am.
[15:37:22] <ChrisMorgan> pseudoku: enjoy yourself! it'll boost your morale to file it yourself!
[15:37:25] *** Quits: ambimorph (amber@moz-F1964F26.hlrn.qwest.net) (Ping timeout)
[15:37:55] * ChrisMorgan has sneaky motives: no one who files a bug report can then ever escape from the language again, even if they had hope before that... they have too much invested in it.
[15:38:10] <ChrisMorgan> Somehow Unicode still hasn't devised a way of conveying evil laughter.
[15:38:13] *** Joins: ambimorph (amber@moz-B376C52.hlrn.qwest.net)
[15:38:29] <pseudoku> ChrisMorgan: ha ha! i guess i'll do it then
[15:38:51] *** Joins: thewonderidiot (mike@moz-5506A033.hsd1.ca.comcast.net)
[15:39:35] * ChrisMorgan triumphs
[15:39:51] *** Quits: nano (nano@moz-74CAD1CA.superkabel.de) (Connection reset by peer)
[15:40:51] *** Joins: james4k (james@moz-E7990244.consolidated.net)
[15:41:21] *** Joins: hoverbear (andrew@moz-86FCBF4B.gv.shawcable.net)
[15:42:36] <bblum> ChrisMorgan: it does have the see no evil, hear no evil, and speak no evil monkeys
[15:42:41] <pseudoku> ChrisMorgan: sorry if i'm keeping you up...but i found this https://github.com/mozilla/rust/issues/8398 ...the issue is closed??
[15:43:04] *** Quits: hoverbear (andrew@moz-86FCBF4B.gv.shawcable.net) (Quit: hoverbear)
[15:44:30] <ChrisMorgan> pseudoku: interesting... it's only when you actually try *using* it that it fails, now.
[15:44:31] *** Quits: maxli (maxli@moz-4D28BA20.student.cs.uwaterloo.ca) (Quit: Leaving.)
[15:44:53] <maikeru> ohhh.. Any trait just got merged
[15:45:43] <kimundi> maikeru: No it didn't :P
[15:46:18] <kimundi> maikeru: It just started the 5th attempt to, though.
[15:46:40] <ChrisMorgan> pseudoku: actually, it looks to be weirder than that. My own simple check is working...
[15:46:56] <pseudoku> ChrisMorgan: i don't understand...
[15:46:59] <ChrisMorgan> I suggest you submit the code in that gist and indicate that *it* isn't working. It'll get reopened.
[15:47:20] <pseudoku> ChrisMorgan: but you said it works for you?
[15:47:32] <ChrisMorgan> Actually, I've finally pinned it down.
[15:47:53] *** Quits: james4k (james@moz-E7990244.consolidated.net) (Quit: WeeChat 0.4.1)
[15:48:13] <pseudoku> ChrisMorgan: whats the problem? 
[15:48:36] <ChrisMorgan> pseudoku: if you change `let f = ...` to `let mut f = ...` in your example, it starts to work.
[15:49:35] <ChrisMorgan> Whoops, that's wrong; it's reader that you're sending...
[15:49:54] <pseudoku> ChrisMorgan: yes, it still doesn't work...
[15:49:55] * ChrisMorgan is now baffled by the conflicting results he is seeing with that and with his own simple trait
[15:50:50] <ChrisMorgan> I suggest you create a new issue with your failing case there, referencing the other, closed issue.
[15:51:10] <ChrisMorgan> Then others who know what they're doing can argue about why it's not working and what should be happening and so forth :-)
[15:51:15] *** Quits: six600110 (six600110@moz-C663577C.hsd1.il.comcast.net) (Ping timeout)
[15:51:30] <pseudoku> ChrisMorgan: ok, will do...thanks for all the help..:)
[15:51:35] <ChrisMorgan> You're welcome.
[15:55:45] *** Joins: DAddYE (DAddYE@moz-98D3933F.hsd1.ca.comcast.net)
[15:57:39] *** Joins: fyolnish (fyolnish@moz-9127BB9E.uqwimax.jp)
[15:58:21] *** Quits: DAddYE (DAddYE@moz-98D3933F.hsd1.ca.comcast.net) (Ping timeout)
[15:59:31] *** Quits: fyolnish (fyolnish@moz-9127BB9E.uqwimax.jp) (Ping timeout)
[16:00:29] *** Quits: BizarreCake (BizarreCak@moz-361FE9B2.dynamic.barak-online.net) (Connection reset by peer)
[16:08:19] <eddyb> rusti: [0, ..size_of::<uint>()]
[16:08:20] -rusti- pastebinned 7 lines of output: http://sprunge.us/AiMX
[16:08:37] <eddyb> rusti: [0, ..std::mem::size_of::<uint>()]
[16:08:38] -rusti- pastebinned 7 lines of output: http://sprunge.us/GbcT
[16:08:58] <eddyb> rusti: [false, ..64]
[16:08:59] -rusti- pastebinned 1 lines of output: http://sprunge.us/cUII
[16:09:16] <eddyb> rusti: std::mem::size_of([false, ..64])
[16:09:17] -rusti- pastebinned 7 lines of output: http://sprunge.us/EAYh
[16:09:33] <eddyb> rusti: std::mem::size_of::<[bool, ..64]>()
[16:09:34] -rusti- 64u
[16:09:37] <eddyb> hmpf
[16:09:52] <eddyb> is there no optimized bitvec *within the language*?
[16:09:55] <kimundi> eddyb: size_of is technically a function call, and not allowed in constantr expressions
[16:10:25] *** Joins: voxpopuli (fanservice@moz-CEF3689A.hsd1.pa.comcast.net)
[16:10:25] <kimundi> And we can't be generic of different vector sizes yet
[16:10:37] *** Quits: tetsuharu (tetsuharu@moz-A3FEAA56.ap219.ftth.ucom.ne.jp) (Client exited)
[16:10:52] *** Quits: a__ (a__@moz-6F5CFC76.nycmny.fios.verizon.net) (Client exited)
[16:10:57] <eddyb> I'm using the [u8, ..N] trick to pass an uint to a generic type, and that works fine when I don't need anything other than [u8, ..N] within the structure
[16:10:58] *** Joins: tetsuharu (tetsuharu@moz-A3FEAA56.ap219.ftth.ucom.ne.jp)
[16:11:14] <eddyb> methods can use size_of::<...>() to get N
[16:11:36] *** Joins: six600110 (six600110@moz-C663577C.hsd1.il.comcast.net)
[16:12:16] *** Joins: a__ (a__@moz-6F5CFC76.nycmny.fios.verizon.net)
[16:12:20] <eddyb> but now I need [uint, ..((N + UINT_BITS - 1) / UINT_BITS)] :(
[16:12:49] <ercxx__away> Owned pointers aren't allowed in top level static variables because it doesn't make sense right?
[16:12:49] <eddyb> I guess I can us a macro, but then strcat's rust-core will miss another feature
[16:12:51] *** Quits: tetsuharu (tetsuharu@moz-A3FEAA56.ap219.ftth.ucom.ne.jp) (Ping timeout)
[16:13:12] *** ercxx__away is now known as ercxx
[16:13:18] <cmr> ercxx__away: correct. they require a heap allocation and imply ownership, which statics do not have.
[16:13:22] <eddyb> (getting things into rust-core can be a nightmare, so might as well do it myself)
[16:14:10] <ercxx> cmr: so anything that touches the heap is not going there?
[16:14:32] <cmr> ercxx: yep
[16:14:55] <ercxx> cmr: Is that by design or it's just not done yet?
[16:15:01] <cmr> ercxx: by design.
[16:15:16] <cmr> statics require zero runtime initialization. that's not changing.
[16:15:42] <eddyb> ercxx: you want heap-located singletons?
[16:15:48] <ercxx> :)
[16:16:03] <eddyb> rusti: static mut foo : Option(~int) = None; foo
[16:16:03] -rusti- pastebinned 6 lines of output: http://sprunge.us/WBAh
[16:16:20] <eddyb> rusti: static mut foo : Option<~int> = None; foo
[16:16:21] -rusti- pastebinned 7 lines of output: http://sprunge.us/eGJU
[16:16:34] <eddyb> rusti: static mut foo : Option<~int> = None; unsafe { foo }
[16:16:35] -rusti- None
[16:16:51] <eddyb> rusti: static mut foo : Option<~int> = Some(~5); unsafe { foo }
[16:16:52] -rusti- pastebinned 7 lines of output: http://sprunge.us/MQUg
[16:17:04] <eddyb> ercxx: ^^ that may works
[16:17:09] <eddyb> s/s$//
[16:17:46] <kimundi> rusti: static mut foo : Option<~int> = None; unsafe { foo = Some(~5); foo }
[16:17:47] -rusti- Some(~5)
[16:17:57] <ercxx> I remember trying an Option there but later had hard time modifying the static mut.
[16:18:13] <ercxx> so that works
[16:18:51] <eddyb> ercxx: you can maybe make it safe by using an atomic Option, if there's one
[16:19:03] <ercxx> thanks
[16:22:08] <cmr> eddyb: it won't not require unsafe code, but that would avoid races.
[16:23:02] *** Quits: johns (johns@moz-BBE3ABD.mv.mozilla.com) (Ping timeout)
[16:23:03] *** Joins: johns (johns@moz-BBE3ABD.mv.mozilla.com)
[16:23:08] *** Joins: bholley (anonymous@moz-85A2A193.dip0.t-ipconnect.de)
[16:23:12] <eddyb> cmr: you mean it would still require unsafe code?
[16:23:57] *** Quits: alonlevy (alon@moz-B0E66DB7.static.bezeqint.net) (Ping timeout)
[16:25:19] *** Joins: eholk (eric@moz-F70D5031.hsd1.in.comcast.net)
[16:25:27] <eholk> where did std::io go?
[16:27:08] <kimundi> nirvana
[16:27:27] <kimundi> (It got deleted to make room for the replacement std::rt::io)
[16:29:43] *** Joins: hoverbear (hoverbear@moz-86FCBF4B.gv.shawcable.net)
[16:29:52] *** Quits: dbaupp (Thunderbir@moz-EA27E3E6.lns20.syd6.internode.on.net) (Ping timeout)
[16:32:01] <cmr> eddyb: yes.
[16:32:07] <cmr> eddyb: accessing static mut is always unsafe.
[16:32:26] <eholk> kimundi: thanks!
[16:32:48] <eholk> oh sad, read_whole_file_str seems to be missing
[16:33:17] <zokier`> there is read_to_end which I think does mostly the same thing
[16:33:29] <ChrisMorgan> eholk: std::rt::io::extensions::ReaderUtil.read_to_end
[16:34:28] *** Joins: Axord (xord@moz-1B228827.lsanca.dsl-w.verizon.net)
[16:36:41] *** Joins: zippity (Mibbit@moz-DFAED48A.lightspeed.sntcca.sbcglobal.net)
[16:36:55] <zokier`> rustc can utilize only a single cpu core when building itself, right?
[16:37:21] <zippity> how do i get the stdin or stdout as Reader/Writer?
[16:38:05] <cmr> zokier`: most of the build is serial, and rustc itself isn't parallelized yet, so yes.
[16:40:46] *** Joins: sp3d (s@6361F3B1.19CD1E54.8354FB35.IP)
[16:41:49] *** Quits: Dartakio (Dartakio@moz-147070D0.chy-wy.client.bresnan.net) (Ping timeout)
[16:42:33] <zippity> stdin() and stdout() in rt/io/stdio.rs simply fail.  are they not implemented?
[16:43:32] *** Quits: lenstr (lenstr@AF8EB999.6049B16A.85938D85.IP) (Client exited)
[16:43:55] *** Joins: robertknight (robertknig@moz-54528EE0.wby.mendeley.com)
[16:45:41] *** Quits: robertknight (robertknig@moz-54528EE0.wby.mendeley.com) (Ping timeout)
[16:49:34] <eholk> hmm... how do i do file::open with a string literal as the path name?
[16:50:07] *** Joins: erickt (Adium@49C4075F.3AC15C18.2321E71E.IP)
[16:51:12] <cmr> eholk: Path::new("foo/bar")
[16:51:34] *** Joins: mikezaby (mikezaby@moz-B26868E.home.otenet.gr)
[16:52:46] *** Quits: oberstet (quassel@moz-B2946949.dynamic.mnet-online.de) (Ping timeout)
[16:52:54] *** Joins: oberstet (quassel@moz-DA1D1420.dynamic.mnet-online.de)
[16:53:28] *** Joins: nwmcsween (nwmcsween@E0025B86.51EE1362.3655BBF5.IP)
[16:54:20] <maikeru> for some reason my brain keeps wanting to think of "Path" as "Dir"... and I have to smack it down and tell it that's not what it means
[16:55:06] *** Quits: ChrisMorgan (chris@moz-6AC741CA.static.tpgi.com.au) (Ping timeout)
[16:57:32] *** Joins: fyolnish (fyolnish@moz-4465AF51.uqwimax.jp)
[16:58:00] <ercxx> How does `==` compare strings?
[16:58:17] *** Joins: DAddYE (DAddYE@moz-98D3933F.hsd1.ca.comcast.net)
[16:58:30] *** Quits: eholk (eric@moz-F70D5031.hsd1.in.comcast.net) (Quit: Konversation terminated!)
[16:58:33] <ercxx> There are bunch of functions for comparing equivalence.
[16:59:10] *** Quits: zippity (Mibbit@moz-DFAED48A.lightspeed.sntcca.sbcglobal.net) (Quit: http://www.mibbit.com ajax IRC Client)
[16:59:16] <cmr> ercxx: bytewise.
[16:59:19] *** Quits: fyolnish (fyolnish@moz-4465AF51.uqwimax.jp) (Ping timeout)
[16:59:20] *** Joins: ofeldt- (ofeldt@moz-AA8DE3B1.dip0.t-ipconnect.de)
[16:59:23] <cmr> ercxx: see the Eq implementation in std::str
[16:59:27] <ercxx> thank you
[17:00:02] <Jesse_> where can i find a list of things that require unsafe blocks? i know: calling unsafe fns, dereferencing unsafe pointers, and touching static mut
[17:00:02] *** Quits: DAddYE (DAddYE@moz-98D3933F.hsd1.ca.comcast.net) (Ping timeout)
[17:00:11] *** Quits: ofeldt (ofeldt@moz-A32C5EAD.dip0.t-ipconnect.de) (Ping timeout)
[17:00:39] *** Joins: cubic (cubic@moz-80241A3A.mc.videotron.ca)
[17:00:42] <kimundi> ercxx: In general, unless explicitly noted our equivalance is implemented as content-equivalence everywhere
[17:00:43] <cmr> Jesse_: http://static.rust-lang.org/doc/master/rust.html#unsafety
[17:01:29] *** Joins: pyrac (pyrac@moz-CB14E320.w92-162.abo.wanadoo.fr)
[17:01:46] <ercxx> I was looking at this SO question: http://stackoverflow.com/questions/19599490/comparing-string-with-static-string/19601270#19601270 thinking
[17:01:50] *** Joins: earlzlap (earlz@moz-9E279EAD.neo.res.rr.com)
[17:02:40] <ercxx> so using `==` is probably going to be simpler than type juggling with eq() or equiv(), is that right?
[17:05:00] *** jorendorff_away is now known as jorendorff
[17:05:50] *** Quits: pyrac (pyrac@moz-CB14E320.w92-162.abo.wanadoo.fr) (Quit: pyrac)
[17:05:59] *** Quits: canhtak (jeremy@moz-3BB8F.wl.t.ulaval.ca) (Quit: canhtak)
[17:06:06] <eddyb> ercxx: well, .eq is Eq, i.e. operator==
[17:06:37] <eddyb> ercxx: equiv probably (beware: I haven't checked with the docs) does some sort of unicode normalization, too
[17:06:47] *** Joins: tetsuharu (tetsuharu@moz-A3FEAA56.ap219.ftth.ucom.ne.jp)
[17:07:08] *** Joins: alonlevy (alon@moz-61A0AD83.red.bezeqint.net)
[17:07:31] <Jesse_> cmr: thanks
[17:07:49] *** Joins: bodie_ (bodie@moz-10569756.cmdnnj.fios.verizon.net)
[17:08:02] *** Quits: earlzlap (earlz@moz-9E279EAD.neo.res.rr.com) (Ping timeout)
[17:08:33] *** Quits: tetsuharu (tetsuharu@moz-A3FEAA56.ap219.ftth.ucom.ne.jp) (Ping timeout)
[17:08:34] *** Joins: tetsuharu (tetsuharu@moz-A3FEAA56.ap219.ftth.ucom.ne.jp)
[17:08:34] *** Quits: bholley (anonymous@moz-85A2A193.dip0.t-ipconnect.de) (Quit: bholley)
[17:09:08] <bodie_> Hi all -- I'm a newcomer to Rust with moderate to high ability in C / C++ -- I'm looking to build a VERY simple Redis interface for Rust.  Where should I start?
[17:09:33] <bodie_> (I was thinking also that maybe I should just make a binding for the Hiredis C library.  Would that be a good idea?)
[17:10:49] *** Quits: tetsuharu (tetsuharu@moz-A3FEAA56.ap219.ftth.ucom.ne.jp) (Ping timeout)
[17:11:09] *** Quits: Mogul (Mibbit@moz-19D52E4F.skybroadband.com) (Quit: http://www.mibbit.com ajax IRC Client)
[17:13:40] <cmr> bodie_: where should you start what? Learning Rust, or implementing the library?
[17:14:12] *** Quits: jdavis (jdavis@moz-1BE8A6A1.hsd1.ca.comcast.net) (Quit: Leaving)
[17:15:19] <bodie_> I guess my confusion is where the two meet.  I should be fine self-teaching the language but I'm not sure how I would go about writing a binary interface for Redis.  Would I just want to wrap a C library?
[17:15:37] <bodie_> I guess I don't understand how such a thing would be put together.
[17:15:58] <bodie_> Is that what an ABI is?
[17:16:12] <eddyb> ABI == application binary interface
[17:16:40] <eddyb> bodie_: you can access C functions from Rust. Rust structures are equivalent to C (as long as you use the same types inside)
[17:17:00] <bodie_> OK.  Would there be a performance penalty there, as there is when calling C from Java, for example?
[17:17:13] *** Joins: jdavis (jdavis@moz-1BE8A6A1.hsd1.ca.comcast.net)
[17:17:33] <eddyb> bodie_: I think there's something stack-related, but apart from that it's like a non-inlined call from C to C :)
[17:17:35] *** jorendorff is now known as jorendorff_away
[17:18:03] <eddyb> bodie_: it can be even better, with LTO https://github.com/mozilla/rust/wiki/Mixed-language-link-time-optimization
[17:18:15] <bodie_> Interesting.
[17:18:41] <bodie_> So let me make sure I've got this straight: there are two options.  ABI or C wrappers.  yus?
[17:18:46] <eddyb> passing strings might have a cost, not sure on that
[17:18:55] <eddyb> bodie_: it's the same thing
[17:19:07] * bodie_ blinks
[17:19:19] <jdavis> (novice) I am trying to install https://github.com/sfackler/rust-postgres -- what do I do to install and use it?
[17:20:05] <eddyb> bodie_: you import C functions by declaring that they have a C ABI. if you have a C++ library, you need to write C wrappers
[17:20:13] <cmr> bodie_: An ABI is the machine-level interface to a piece of code. How it is called, which functions there are, what arguments they take.
[17:20:14] <bodie_> eddyb I thought it was more like -- there is already a C library written to interface with Redis.  I can wrap this library for Rust, or I can write my own interface in Rust.
[17:20:28] *** Joins: earlzlap (earlz@moz-9E279EAD.neo.res.rr.com)
[17:20:30] <bodie_> I would prefer to do the latter (on a VERY simple level as I am very time crunched)
[17:20:31] <eddyb> bodie_: how does it interface?
[17:20:49] <eddyb> (with Redis, that is)
[17:20:50] <bodie_> Ummm, I'm not entirely sure to be honest.
[17:21:06] <bodie_> I would imagine similarly to how C might interface with MySQL, for example
[17:21:12] <dcrewi> http://redis.io/topics/protocol
[17:21:47] <eddyb> bodie_: so you have the option of using a C library or writing your own client
[17:21:56] <bodie_> jdavis I guess you would install that to the libs folder where the rest of your user libraries for Rust are
[17:22:28] <eddyb> bodie_: nope
[17:22:49] <jdavis> bodie_, this is the first thing I am trying to do, please excuse my ignorance -- I don't have other libraries
[17:22:50] <eddyb> jdavis: check the example on that page (within the readme)
[17:23:06] <bodie_> jdavis, I've never done anything in rust myself beyond hello world, that is just my first instinct :)
[17:23:14] <eddyb> jdavis: you don't need to download anything, as long as you have rustpkg - which should come with any instalation of rust
[17:23:17] *** Joins: jeffdb_ (jeff@moz-D13B6004.hsd1.ca.comcast.net)
[17:23:25] <jdavis> Yeah, I have rustpkg
[17:23:26] <bodie_> I think he is trying to ask where to put Rust libraries that you would like to link against
[17:23:35] <bodie_> ah nvm I will shut up now haha
[17:24:04] <jdavis> No, you're right, that is what I'm asking (I think)
[17:24:08] <eddyb> bodie_: I don't know too much either, only the random things I've seen while being in here for the past two weeks
[17:24:16] <jdavis> I have rustpkg but I have never used it.
[17:24:31] <bodie_> eddyb I think I'm trying to ask a) how to begin to go about writing my own client in Rust, b) what the performance penalties might be like for wrapping C and where to go for more info on that
[17:24:35] <eddyb> jdavis: extern mod postgres = "github.com/sfackler/rust-postgres"; // rustpkg will download, compile and use that crate, automatically
[17:25:10] <jdavis> Yeah, I have that in my file, but it says "pg.rs:2:0: 2:58 error: can't find crate for `postgres`
[17:25:11] <jdavis> pg.rs:2 extern mod postgres = "github.com/sfackler/rust-postgres";
[17:25:11] <jdavis> "
[17:25:21] <cmr> jdavis: You can't actually use rustpkg  like that, as it is broken.
[17:25:27] <eddyb> cmr: :(((
[17:25:31] <cmr> jdavis: you need to clone the repo and do `rustpkg install`
[17:25:38] <jdavis> oh
[17:25:59] <eddyb> cmr: so a rustpkg bug made me provide bad intel? or was it bad anyways :(?
[17:26:06] <eddyb> I hoped I was right :P
[17:26:06] <cmr> eddyb: bug
[17:26:16] <cmr> you *are* right, except rustpkg is broken :p
[17:26:28] <jdavis> OK, trying a few rustpkg commands (I am on 0.8)
[17:26:35] *** Joins: jsingh (Mibbit@C3D7FFFE.4DB138C4.DDE5D3F6.IP)
[17:26:42] <cmr> jdavis: rust-postgres doesn't support 0.8
[17:26:57] <eddyb> almost nothing is stable. all hail master
[17:27:25] <eddyb> bodie_: a) you probably want to look in std::rt::io for TCP support b) I only know about needing a different stack model. I think I've seen a guide somewhere about wrapping a C library, let me look
[17:27:31] <jdavis> OK, got past that error, but hit another.
[17:28:03] <jdavis> http://pastebin.com/rrAMPkeZ
[17:28:09] <eddyb> bodie_: b) http://static.rust-lang.org/doc/master/tutorial-ffi.html
[17:28:25] <bodie_> thank you my good sir!
[17:28:34] <cmr> jdavis: rust-postgres doesn't support 0.8
[17:28:57] <jdavis> cmr: which version does it support?
[17:29:00] <eddyb> jdavis: I would hope your distro has a rust-git package, if I were you :P
[17:29:06] <cmr> jdavis: none of them. it tracks master.
[17:29:14] *** Joins: SilverKey (SilverKey@moz-B589DA51.sw.biz.rr.com)
[17:29:21] <jdavis> OK. I will try that then, I guess.
[17:29:45] <jdavis> I am determined to get this library working.
[17:30:13] <jdavis> Do I just checkout the git master of rust and compile it?
[17:30:33] <eddyb> jdavis: which distro are you using?
[17:30:41] <jdavis> ubuntu 13.04
[17:30:48] <jdavis> but upgrading to 13.10 soon.
[17:30:56] <cmr> jdavis: https://launchpad.net/~hansjorg/+archive/rust
[17:31:05] *** Joins: vu3rdd (vu3rdd@721FA998.2EC825E7.BE90E62C.IP)
[17:31:35] <jdavis> OK, cool, there are packages.
[17:31:55] *** Quits: jeffdb_ (jeff@moz-D13B6004.hsd1.ca.comcast.net) (Ping timeout)
[17:31:57] <jsingh> is there any way to redirect a TcpStream? e.g. to implement browser redirection
[17:32:07] <kimundi> ercxx, eddyb: ==, .eq, .cmp and .equiv all do the same thing to determine if a string is equal to some other
[17:32:12] <jdavis> Thanks everyone. I'll work on it.
[17:32:20] <cmr> jsingh: there's no such thing.
[17:32:29] <ercxx> kimundi: Thank you.
[17:32:32] <eddyb> jsingh: browser redirection is achieved by sending a redirection code and a new location
[17:32:34] <cmr> jsingh: HTTP redirection works off of a specific type of response.
[17:32:38] <eddyb> jdavis: in the response headers
[17:32:44] <eddyb> err, jsingh^
[17:33:01] <jsingh> cmr, eddyb ah gotcha
[17:33:12] <bodie_> Anybody know whether 512MB of RAM is enough to compile average Rust applications?
[17:33:18] <eddyb> kimundi: so what's equiv for? it would make sense to do normalization
[17:33:25] <eddyb> bodie_: way less than that should be ok
[17:33:48] *** Quits: maik (maik@moz-10F9C3B5.dip0.t-ipconnect.de) (Ping timeout)
[17:34:14] <eddyb> bodie_: the high memory usage arises when building rustc itself, because it compiles the entire program (well, actually, it's a library. the rustc executable calls into that library) at once
[17:34:15] *** Joins: Sharp (Sharp@moz-7B61DF4.dsl.static.sonic.net)
[17:34:32] <kimundi> ercxx, eddyb: == is the same as .eq and they are for partial ordering, .cmp is for total ordering, which for strings is the same as partial one. equiv exists to allow generic code to use &str and ~str interchangably. If you want to compare for unicode normalized equivalnce, you have to transform the string into a normalized one and compare that
[17:34:35] *** Quits: SilverKey (SilverKey@moz-B589DA51.sw.biz.rr.com) (Ping timeout)
[17:34:35] <bodie_> I see, so it has to load the ENTIRE Rust language
[17:34:50] <bodie_> lol, btw, #redis is being totally uninterested and unhelpful
[17:35:19] <eddyb> bodie_: you better hope they wrote good docs :P
[17:35:52] <bodie_> I think I found what I'm looking for.  :) https://redis-docs.readthedocs.org/en/latest/ProtocolSpecification.html
[17:35:53] <eddyb> kimundi: I would move equiv into eq, before anyone else thinks it does normalization :P
[17:36:07] <kimundi> eddyb: Why would anybody think that?
[17:36:09] <bodie_> eddyb, there are ZERO good Rust clients for Redis
[17:36:49] *** Joins: eatkinson (eatkinson@moz-E57448EF.airbears2.berkeley.edu)
[17:36:51] <bodie_> dcrewi thanks, that's what I was looking for
[17:36:54] <eddyb> kimundi: equivalence vs equality. I don't know, it just feels... different
[17:37:11] <kimundi> hm, yeah
[17:37:34] <kimundi> But the point is kinda moot, becuase once we get DST we don't need equiv anymore, I think
[17:37:48] <eddyb> DST (in this context) being?
[17:37:58] <cmr> dynamically sized types
[17:38:05] <cmr> [T] is DST
[17:38:38] <kimundi> instead of ~str and &str, makes str (and [T]) an independent unsized type
[17:38:40] *** Joins: SilverKey (SilverKey@moz-B589DA51.sw.biz.rr.com)
[17:39:00] <eddyb> I'm not sure I understand the difference :/
[17:39:02] <cmr> I don't really understand DST tbh
[17:39:11] <kimundi> It's easy
[17:39:14] <ercxx> bodie_: There was an attempt : https://github.com/mneumann/rust-redis
[17:39:43] <kimundi> The compiler needs to know about the size of a type in order to be able to put it on the stack, or in a vector, etc.
[17:39:54] <cmr> Right
[17:39:54] <bodie_> I think the biggest Git repo for a Rust Redis client had a grand total of 18 commits
[17:40:07] <cmr> bodie_: commits != completion.
[17:40:24] <kimundi> But [T] and str would represent "A at compiletime-unknown number of elements of fixed size"
[17:40:29] <eddyb> kimundi: aaah, like variable-sized stack arrays in C/C++?
[17:40:37] <bodie_> .... that is a thing?
[17:40:48] <bodie_> *mind blown*
[17:40:54] <kimundi> eddyb: Maybe, don'T kabout C/C++ ;)
[17:41:05] <cmr> kimundi: I don't see how that can be implemented efficiently or why it is desirable.
[17:41:14] <eddyb> kimundi: you mean don't talk about either, or does the slash annoy you?
[17:41:39] <kimundi> eddyb: Sorry, "don't know about"
[17:41:51] <sp3d> cmr: being able to allocate a dynamically-determined amount of space on the stack instead of the heap?
[17:42:01] <eddyb> oh wow, how did I read "talk" in there? I'm a wizard
[17:42:06] <kimundi> I need a "C++ for rust programmers" book ;)
[17:42:13] <kimundi> cmr: What is unclear?
[17:42:20] *** Joins: sweet_kid (Upasana@A78CFDAE.2EC9110A.4A5F0685.IP)
[17:42:32] <eddyb> kimundi: so it's a slice allocated on the stack?
[17:42:35] <bodie_> I thought one of the points of Rust was to use immutable types when possible
[17:42:40] <bodie_> am I mistaken?
[17:42:50] <eddyb> bodie_: immutable storage, not types
[17:43:08] <Jesse_> i don't think "let you put dynamically sized things on the stack" is part of the DST proposal
[17:43:11] <cmr> bodie_: how is that related?
[17:43:13] <bodie_> er.... maybe that went over my head
[17:43:20] <sp3d> hm, no?
[17:43:22] <kimundi> eddyb: No, the point and problem of unsized types is that they _can't_ be allocated on the stack, or anywhere else where the size needs to be known at compiletime :)
[17:43:39] <cmr> kimundi: I don't see how DST is different than the current situatino with ~[T]/&[T]
[17:43:46] <eddyb> me neither
[17:43:59] <bodie_> dynamically sized types implies dynamically sized storage in my mind, which implies a need to put stuff in a place, which sounds like that stuff is going to be transmuted
[17:44:13] <bodie_> I'm totally new here, pardon me if I'm being ignorant, just curious and interested :)
[17:44:19] <kimundi> The DST proposal is basically about allowing to treat [T] as a seperate type in context where it makes sense, and where you can construct a value of it through an pointer.
[17:44:31] <eddyb> bodie_: be careful, transmute is an (unsafe) intrinsic which does something like reinterpret_cast
[17:44:39] <bodie_> ah
[17:44:52] <bodie_> I meant the opposite of immutable, in verb form, whatever that would be :P
[17:45:00] <eddyb> mutate?
[17:45:05] <bodie_> yeah, that
[17:45:12] <kimundi> so, impl [T] { fn foo(&self) { ... } fn bar(~self) { ... } } would work, but impl [T] { fn baz(self) { ... } } would refuse to compile
[17:45:43] <eddyb> kimundi: okay, and how does that compare to the current situation?
[17:45:51] <kimundi> currently you can only do
[17:46:24] <kimundi> impl &[T] { fn baz(self) { ... }  fn foo(&self) { ... } fn bar(~self) { ... } } or impl ~[T] { fn baz(self) { ... }  fn foo(&self) { ... } fn bar(~self) { ... } }
[17:46:38] *** Joins: d3xter (sinz@moz-839BDF11.adsl.highway.telekom.at)
[17:46:46] <d3xter> hey guys
[17:46:47] <kimundi> That is, you need to duplicate a lot of definitions for each pointer type
[17:47:02] <eddyb> https://github.com/mneumann/rust-redis/blob/master/parser.rs#L138-L302 this looks like it could benefit from generators, although state machines look nicer in Rust :D
[17:47:30] *** Joins: kelvin (Mibbit@183BB334.C422786F.DDE5D3F6.IP)
[17:47:38] <eddyb> oooh, wait, you can store local variables in the state enum, and that deals with liveness, too :D
[17:48:30] <eddyb> kimundi: oh, I see :D - that makes a lot of sense
[17:48:31] <kimundi> For example, start scrolling down from here: https://github.com/mozilla/rust/blob/master/src/libstd/str.rs#L1226
[17:48:46] <kimundi> That could all just become one impl for the 'str' type
[17:49:03] <cmr> kimundi: Ok, so nothing is changing runtime representatino wise?
[17:49:37] <eddyb> cmr: strcat has separate plans for the repr (unless he merged them already)
[17:49:57] <cmr> eddyb: the vec stuff hasn't.
[17:50:01] <kimundi> cmr: Right, it just building the idea of unsized types into the type system without changing anything about the representation of such types
[17:50:05] <cmr> that's orthogonal to thisissue though
[17:50:13] <cmr> kimundi: Ok, +1 from me
[17:50:23] *** Joins: james4k (james@moz-E7990244.consolidated.net)
[17:50:27] <cmr> kimundi: thanks for explaining :D
[17:50:38] <kimundi> Well, with DST we wouldn't need equiv, which is how this discussion started
[17:51:05] <Jesse_> how many words is an ~[int]?
[17:51:09] <eddyb> at least I know why he's delaying implementing the slice methods, this DST change should make them easier to write :D
[17:51:12] <cmr> Jesse_: one
[17:51:25] <cmr> Jesse_: it's a pointer to a {len, capacity, T}
[17:51:43] <cmr> Where T is `len` values of type T
[17:51:48] <eddyb> [T, ..len], that is
[17:52:19] <cmr> eddyb: no, since it can change.
[17:52:42] <eddyb> T[len] if you don't want overlap with actual syntax :)
[17:52:42] <kimundi> eddyb: The problem with [T, ..N] is that we can't express the N as a type parameter right now
[17:53:31] <kimundi> ~[T] might change from *{ len, cap, data... } to {len, cap, *data} btw
[17:53:56] <eddyb> kimundi: len was runtime-known there, anyway. and you can have [T, ..N] itself as a type parameter, and extract the length (at runtime, though it gets inlined), but it has limited usecases
[17:53:59] <Sharp> cmr: Not that this is (usually) a good idea, but I assume there's a way to get an array without len or capacity?
[17:54:24] <cmr> Sharp: what do you mean?
[17:54:38] <Sharp> Just a regular C array.
[17:54:44] <eddyb> you can get a slice
[17:54:55] <Sharp> Ah, okay.
[17:55:23] <cmr> slices still have a len
[17:55:36] <cmr> [T, ..N] has no extra "overhead"
[17:55:54] <eddyb> Sharp: derp, I know
[17:56:10] <eddyb> Sharp: &vec[0] as *T
[17:56:16] <Sharp> Ah, gotcha.  Thanks :)
[17:56:25] <Sharp> Like I said, I doubt I'll use it all that much, but it's good to know it's an option.
[17:56:48] <Jesse_> kimundi: if ~[T] becomes 3 words but ~int remains 1 word, that makes ~T a DST?
[17:56:51] <eddyb> I've forgotten that I used that trick (in unsafe code with safe-ish semantics :P)
[17:57:23] <eddyb> Jesse_: ~ is an unique pointer
[17:57:31] *** Joins: fyolnish (fyolnish@moz-AB77D9F8.uqwimax.jp)
[17:57:40] <cmr> Jesse_: no?
[17:58:28] <Jesse_> i guess you know the size for any given T
[17:58:31] <eddyb> Jesse_: ~T will always be as large as an uint, but the data pointer to might have different sizes. ~u8 will point to one byte
[17:58:55] *** Joins: maik (maik@moz-10F9C3B5.dip0.t-ipconnect.de)
[17:58:56] <cmr> Jesse_: ~T is *always* just a pointer.
[17:58:59] <cmr> That's the reason it exists.
[17:59:17] *** Quits: fyolnish (fyolnish@moz-AB77D9F8.uqwimax.jp) (Ping timeout)
[17:59:29] <Jesse_> i was replying to "~[T] might change from *{ len, cap, data... } to {len, cap, *data} btw"
[17:59:29] <kimundi> [T] would be unsized type, and the support for ~ and & to point to unsized types and have a different representation that case would fall under supporting dynamically sized types
[17:59:36] *** Joins: DAddYE (DAddYE@moz-98D3933F.hsd1.ca.comcast.net)
[17:59:48] <d3xter> are there any plans to extend the functional programming stuff in rust?
[17:59:52] <kimundi> That data layout change would just be an optimization
[17:59:53] <benh> ~T is already not ~[T]
[17:59:55] <cmr> d3xter: in what way?
[18:00:02] <eddyb> ~[T], @[T], ~str and @str (the last two are internally equivalent to [u8], and @ will be gone soon) are the only special cases that I know of
[18:00:08] <kimundi> &[T] today is already {*data..., len }
[18:00:09] *** Quits: kelvin (Mibbit@183BB334.C422786F.DDE5D3F6.IP) (Quit: http://www.mibbit.com ajax IRC Client)
[18:00:18] <eddyb> well, there's also &[T] and &str, which are slices
[18:00:56] *** jorendorff_away is now known as jorendorff
[18:01:11] <d3xter> cmr: like you always return Option<T> when something can fail, but then the user has to unpack it to work with it later
[18:01:23] *** Quits: DAddYE (DAddYE@moz-98D3933F.hsd1.ca.comcast.net) (Ping timeout)
[18:01:31] <d3xter> most of the functions require T as an argument, not Option<T>
[18:01:35] <Ms2ger> @ will be gone soon, then?
[18:01:50] <cmr> Ms2ger: it's a 1.0 priority
[18:02:03] <Ms2ger> And is 1.0 soon? :
[18:02:03] <Ms2ger> )
[18:02:06] <eddyb> d3xter: I think there's a map method on Option
[18:02:20] <cmr> Ms2ger: "soon"
[18:02:28] <jsingh> cmr LOL
[18:02:30] <Ms2ger> Right, that's what I though :)
[18:02:31] <kimundi> ~[T], &[T] and @[T] are all special cases right now, and will continue to be or get removed.
[18:02:33] <Ms2ger> t
[18:02:40] * Ms2ger grumbles at his typing
[18:02:43] <cmr> I'd put my money on 6-8 months.
[18:02:44] <kimundi> str is just a [u8]
[18:02:46] <cmr> max
[18:02:52] *** Joins: robertknight (robertknig@moz-1FB7516D.range81-157.btcentralplus.com)
[18:03:12] <kimundi> [T, ..N] is a sized type though, and can be put on the stack because of that
[18:03:39] <eddyb> cmr: just don't go with Valve's "soon"
[18:03:42] <kimundi> That also why [T, ..N] is a new different type for each N, and why N needs to be a constant
[18:04:29] *** Quits: alonlevy (alon@moz-61A0AD83.red.bezeqint.net) (Ping timeout)
[18:04:40] <jsingh> Half Life 3: built on Rust
[18:04:42] <jsingh> GG
[18:04:49] <Ms2ger> Rust 1.0 may be released in 6 months
[18:04:52] <Ms2ger> 6 = 2 * 3
[18:04:57] <Ms2ger> HL3 confirmed
[18:05:03] <eddyb> jsingh: linux only
[18:05:04] *** Joins: alonlevy (alon@moz-61A0AD83.red.bezeqint.net)
[18:05:15] <jsingh> Ms2ger I lol'd
[18:06:57] *** Quits: alonlevy (alon@moz-61A0AD83.red.bezeqint.net) (Ping timeout)
[18:09:30] *** Joins: JamesNZ (james@moz-264643C7.bitstream.orcon.net.nz)
[18:09:45] *** Quits: pseudoku (quassel@63872.787D7D11.520CDC98.IP) (Client exited)
[18:09:53] *** Quits: vu3rdd (vu3rdd@721FA998.2EC825E7.BE90E62C.IP) (Ping timeout)
[18:10:12] *** Joins: DasIch (dasich@moz-5EDA591.de)
[18:11:05] <d3xter> eddyb: oh yeah, there's the "and_then" i was looking for :)
[18:11:38] <d3xter> thanks
[18:12:18] <Sharp> Maybe Rust's release is holding up HL3 because Valve refuses to write it in any other language.
[18:12:29] *** Quits: oberstet (quassel@moz-DA1D1420.dynamic.mnet-online.de) (Client exited)
[18:13:08] <jsingh> more rust lolz from earlier this week https://twitter.com/jasdev/status/393519289212633088 
[18:13:38] *** Joins: kelvin (Mibbit@2B0B4E57.83BCE10.DDE5D3F6.IP)
[18:13:48] *** Joins: ksf (ksf@moz-1B00089E.adsl.hansenet.de)
[18:15:48] *** Quits: tiffany (kawaii@moz-28A8742A.dhcp.embarqhsd.net) (Ping timeout)
[18:15:48] *** Quits: Sharp (Sharp@moz-7B61DF4.dsl.static.sonic.net) (Ping timeout)
[18:17:06] <Jesse_> jsingh: HL3 in Rust as your final project for CS4414?
[18:17:39] <eddyb> I'd move that to CS31337
[18:17:54] <jsingh> Jesse_ I wanna graduate on time lolol
[18:18:59] *** Joins: Sharp (Sharp@moz-7B61DF4.dsl.static.sonic.net)
[18:19:54] *** Joins: SiegeLord (sl@moz-CAF07B4C.hsd1.ma.comcast.net)
[18:20:34] *** Quits: vk (chatzilla@moz-760B8023.dsl.dynamic.sonic.net) (Client exited)
[18:21:38] *** Quits: blank_name (blank_name@2E4E7E43.800E1818.31EC03F3.IP) (Ping timeout)
[18:22:01] <earlzlap> Does anyone know if query strings are parsed yet in rust-http ?
[18:22:32] <cmr> earlzlap: they aren't.
[18:23:18] *** Joins: skade (skade@moz-A89F791B.pools.arcor-ip.net)
[18:23:36] *** Joins: tetsuharu (tetsuharu@moz-A3FEAA56.ap219.ftth.ucom.ne.jp)
[18:24:10] *** Quits: skade (skade@moz-A89F791B.pools.arcor-ip.net) (Quit: My MacBook Pro has gone to sleep. ZZZzzz…)
[18:24:36] *** Quits: erickt (Adium@49C4075F.3AC15C18.2321E71E.IP) (Quit: Leaving.)
[18:24:46] *** Joins: nif (Mibbit@moz-B6DFA19D.wireless.oberlin.edu)
[18:25:16] *** Quits: tetsuharu (tetsuharu@moz-A3FEAA56.ap219.ftth.ucom.ne.jp) (Ping timeout)
[18:25:22] <earlzlap> why isn't rust-http feature complete already? :) 
[18:25:46] <cmr> Because you haven't sent the pull request making it so :)
[18:26:31] *** Joins: alonlevy (alon@moz-61A0AD83.red.bezeqint.net)
[18:27:34] *** Joins: hatman (Mibbit@9B9315E1.A6025CA.1C37C358.IP)
[18:28:26] *** Quits: mikezaby (mikezaby@moz-B26868E.home.otenet.gr) (Input/output error)
[18:29:52] *** Quits: mib_ecgrox (Mibbit@moz-FAC32130.dsl.telepac.pt) (Quit: http://www.mibbit.com ajax IRC Client)
[18:29:55] *** Quits: maik (maik@moz-10F9C3B5.dip0.t-ipconnect.de) (Ping timeout)
[18:30:00] *** Quits: hoverbear (hoverbear@moz-86FCBF4B.gv.shawcable.net) (Quit: Textual IRC Client: www.textualapp.com)
[18:31:59] <kelvin> does rust have a sleep() equivalent?
[18:32:44] <kelvin> or mayhaps some sort of interval timer?
[18:32:55] <kimundi> yes
[18:33:03] <kimundi> rt::timer or  so
[18:34:55] <kelvin> gracias
[18:35:45] *** Joins: erickt (Adium@49C4075F.3AC15C18.2321E71E.IP)
[18:36:23] <d3xter> hey guys, how i can i use the values of an enum outside of its crate? when i try to include the enum called "LogLevel" and i try to access it with "LogLevel.Info" i get "LogLevel unresolved. any hints?
[18:38:03] <benh> It's themodulewheretheneumisfrom::Info
[18:38:45] <kimundi> d3xter: Did you link to the crate with 'extern mod cratename', and imported the enum from that with 'use cratename::themodule::{EnumType, Variant1, Variant2};' ?
[18:39:47] *** Quits: kelvin (Mibbit@2B0B4E57.83BCE10.DDE5D3F6.IP) (Quit: http://www.mibbit.com ajax IRC Client)
[18:40:17] *** jorendorff is now known as jorendorff_away
[18:40:32] *** Joins: annodomini (lambda@moz-9AC5B452.hsd1.ma.comcast.net)
[18:41:00] *** Quits: silotis (quassel@moz-4B8C4631.oc.oc.cox.net) (Connection reset by peer)
[18:41:13] *** Quits: mib_4y71zq (Mibbit@moz-3EF1C327.washdc.fios.verizon.net) (Quit: http://www.mibbit.com ajax IRC Client)
[18:41:25] *** Joins: silotis (quassel@moz-4B8C4631.oc.oc.cox.net)
[18:41:29] <d3xter> kimundi: indeed, but it still cant find my "LogLevel" struct. using "Info" on its own works
[18:41:44] <d3xter> s/struct/enum
[18:42:10] <kimundi> d3xter: Are you sure you got the paths right?
[18:42:25] *** Quits: hatman (Mibbit@9B9315E1.A6025CA.1C37C358.IP) (Quit: http://www.mibbit.com ajax IRC Client)
[18:43:08] <d3xter> kimundi: yes. "logMessage(Info, "msg")" works, but "logMesage(LogLevel.Info, "msg")" doesnt
[18:43:44] <d3xter> oh btw, i'm running master from yesterday. maybe something is broken right now?
[18:43:44] <kimundi> LogInfo.Info is not rust syntax
[18:44:03] <kimundi> Is Info a variant of the LogLevel Enum?
[18:44:24] <d3xter> kimundi: oh right, thats java syntax :D yes, Info is a variant of LogLevel
[18:44:28] *** Joins: reedlepee (Mibbit@9B9315E1.A6025CA.1C37C358.IP)
[18:44:42] *** Joins: robertkn_ (robertknig@moz-54528EE0.wby.mendeley.com)
[18:45:02] *** Joins: rust_hipster (Mibbit@2B0B4E57.83BCE10.DDE5D3F6.IP)
[18:45:06] <rust_hipster> http://instacod.es/82045
[18:45:16] <jsingh> rust_hipster ++
[18:45:24] <kimundi> The first one works because the ifrst one is how it's supposed to be used. If you want to be explicit in scoping, you need to access the module LogLevel is defined in, like "use x::y::z; logMesage(z::Info, "msg")"
[18:46:06] *** Quits: annodomini (lambda@moz-9AC5B452.hsd1.ma.comcast.net) (Quit: annodomini)
[18:46:25] *** Quits: robertkn_ (robertknig@moz-54528EE0.wby.mendeley.com) (Ping timeout)
[18:46:36] <d3xter> kimundi: oh, so there is no way like "use log::LogLevel; logMessage(LogLevel::Info..."?
[18:46:43] <kimundi> Not currently
[18:46:52] <d3xter> kimundi: ok thanks
[18:47:18] *** Joins: blank_name (blank_name@2E4E7E43.800E1818.31EC03F3.IP)
[18:47:39] <kimundi> The is hypothetical planned syntax like "enum mod Foo { Bar, Baz, ... }" that would scope like that, but the regular enum scopes the variants at the same level as the type
[18:48:29] *** Joins: skade (skade@moz-A89F791B.pools.arcor-ip.net)
[18:48:50] <kimundi> rust_hipster: haha
[18:49:17] <d3xter> kimundi: is there any issue yet to cover the progress?
[18:49:25] <kimundi> no idea
[18:49:40] *** Joins: annodomini (lambda@moz-9AC5B452.hsd1.ma.comcast.net)
[18:49:52] *** Quits: rust_hipster (Mibbit@2B0B4E57.83BCE10.DDE5D3F6.IP) (Quit: http://www.mibbit.com ajax IRC Client)
[18:49:59] *** Joins: kelvin (Mibbit@2B0B4E57.83BCE10.DDE5D3F6.IP)
[18:50:15] <kimundi> Can'T find one right now
[18:50:17] *** Quits: skade (skade@moz-A89F791B.pools.arcor-ip.net) (Quit: My MacBook Pro has gone to sleep. ZZZzzz…)
[18:50:31] * kimundi opens an issue
[18:50:52] <eddyb> you can still do it with mod Foo { enum Foo { Bar, Baz, ...} } using Foo::Foo;, can't you?
[18:51:21] <kimundi> Sure, but then the type is Foo::Foo, not Foo
[18:51:37] <eddyb> pub use, sorry :P
[18:51:46] <kimundi> So, not identical, and way more boilerplaty
[18:52:28] <eddyb> the use statement at the top of the outer module is the troubling part. not sure if "enum mod" is the best scoping name
[18:52:29] <kimundi> Meh, I'm not a fan of explicitly constructing overlapping mod/type definitions
[18:52:43] * kimundi things they should be forbidden
[18:52:55] *** Joins: ziad (Mibbit@moz-5729CEA7.hsd1.ca.comcast.net)
[18:52:56] <eddyb> kimundi: associated items first, pls
[18:53:11] <ziad> need some GIT help :)
[18:53:21] <kimundi> ziad: Ask :)
[18:53:28] <d3xter> ziad: dont ask for help, just ask :)
[18:53:57] *** Joins: ktt3ja (Mibbit@moz-6B6EE8C0.hsd1.va.comcast.net)
[18:54:12] *** Quits: annodomini (lambda@moz-9AC5B452.hsd1.ma.comcast.net) (Quit: annodomini)
[18:54:19] <ziad> https://github.com/mozilla/rust/pull/10085
[18:54:27] <ziad> Tim's comment
[18:54:33] <ziad> Can you rebase this so there's no merge node? See https://github.com/mozilla/rust/wiki/Note-git-workflow
[18:54:43] <ziad> How do I do that? I already pushed to my fork on github
[18:54:57] <ziad> I did rebase -i HEAD~3, but now I have 20 or so commits to chose from
[18:55:43] *** Joins: jstevans (Instantbir@630B0C0.117F92C2.B7830B68.IP)
[18:55:52] <ziad> 3 of them are mine, the rest are in between
[18:55:52] <d3xter> ziad: just rebase your branch on top of the official rust/master branch
[18:56:00] <ziad> how do I do that?
[18:56:14] <kimundi> git rebase upstream/master
[18:56:31] <kimundi> assuming you have added the official git repo as the remote 'upstream'
[18:56:31] <d3xter> ziad: git rebase origin/master, if origin is the mozilla/rust repo
[18:56:45] <kimundi> origin will likely be his fork, not the official one
[18:57:30] <d3xter> kimundi: yeah, probably
[18:57:41] *** Joins: fyolnish (fyolnish@moz-AE0E2B81.uqwimax.jp)
[18:58:20] <ziad> origin is my fork, and upstream is the mozilla one
[18:58:42] <kimundi> git fetch upstream; git rebase upstream/master
[18:58:51] <kimundi> should at least do the rebase
[18:59:08] <kimundi> if that works, then we can look further into it :)
[18:59:15] <d3xter> ziad: a nice explanation of what "git rebase" does: http://git-scm.com/book/en/Git-Branching-Rebasing :)
[18:59:19] *** Quits: earlzlap (earlz@moz-9E279EAD.neo.res.rr.com) (Ping timeout)
[18:59:27] *** Quits: fyolnish (fyolnish@moz-AE0E2B81.uqwimax.jp) (Ping timeout)
[18:59:32] <ziad> cool, that worked locally, but now when I try to do a push, it complains that there is a conflic
[18:59:39] <kimundi> git push -f
[18:59:49] <d3xter> you have to rewrite the history, y
[19:00:07] <kimundi> if you rebase, then you change the history of your repo, which means you have to force the other side to accept your changes (-f)
[19:00:40] * Sharp doesn't like to rebase except when pushing to someone else's repository.
[19:00:52] *** Joins: DAddYE (DAddYE@moz-98D3933F.hsd1.ca.comcast.net)
[19:00:53] <ziad> Great! Seems to have worked.
[19:00:54] <ziad> Thanks all
[19:00:57] * Sharp prefers merge.
[19:01:15] <kimundi> In general, what I always do is to only work with 'git fetch upstream; git rebase upstream/master' to update my code :P
[19:01:23] <Sharp> It's nice to have clean history sometimes, I guess.
[19:01:29] <Sharp> But not critical.
[19:01:41] <kimundi> bors already ensure that the history is full of merge nodes :P
[19:01:46] <Sharp> Heh, good point.
[19:02:05] * kimundi rembers a time before bors, when viewing the repos branch history in a graphical interface was actually readable
[19:02:34] *** Quits: DAddYE (DAddYE@moz-98D3933F.hsd1.ca.comcast.net) (Ping timeout)
[19:04:37] <kelvin> so out of curiosity, when I change println to print in one of my programs, I immediately get the following runtime error on it's execution
[19:04:38] <kelvin> task <unnamed> failed at 'explicit failure', /home/kelvin/rust-0.8/src/libstd/rt/io/stdio.rs:20
[19:04:56] *** Quits: Axord (xord@moz-1B228827.lsanca.dsl-w.verizon.net) (Ping timeout)
[19:05:13] <kelvin> but the println statement works perfectly fine in it's place
[19:05:24] <kelvin> any ideas what's causing it?
[19:06:03] <cmr> kelvin: are you using std::rt::io::print ?
[19:06:21] <kelvin> that's what it seems like
[19:06:34] <cmr> rusti: print("hi\n")
[19:06:35] <kelvin> but why would it import that for print, and not for println?
[19:06:35] -rusti- hi
[19:06:36] -rusti- ()
[19:06:41] <cmr> rusti: std::rt::io::print("hi\n")
[19:06:42] -rusti- pastebinned 7 lines of output: http://sprunge.us/BMfR
[19:06:47] <cmr> rusti: std::rt::io::println("hi\n")
[19:06:49] -rusti- pastebinned 7 lines of output: http://sprunge.us/MXDT
[19:06:53] <cmr> oops
[19:07:21] *** Joins: tetsuharu (tetsuharu@moz-A3FEAA56.ap219.ftth.ucom.ne.jp)
[19:07:34] <cmr> Well, regardless, it's all implemented now.
[19:07:36] <cmr> Quite curious
[19:09:39] *** Quits: tetsuharu (tetsuharu@moz-A3FEAA56.ap219.ftth.ucom.ne.jp) (Ping timeout)
[19:11:22] <kelvin> cmr: http://instacod.es/82046
[19:11:56] <bodie_> for stabililty purposes, should I focus on major revisions, or just follow master?
[19:12:31] <cmr> bodie_: master
[19:12:31] <jsingh> bodie_ if you like to live on the edge, master
[19:12:35] <cmr> jsingh: no
[19:12:42] <Sharp> master is more stable in my experience.
[19:12:42] <cmr> the releases are less stable than master
[19:13:01] <cmr> kelvin: Are you usnig 0.8?
[19:13:10] <kelvin> yeah
[19:13:13] <cmr> That explains it
[19:14:04] <kelvin> also, I found the issue
[19:14:38] <kelvin> I had an import use std::io::println; and an import use std::rt::io::*;
[19:15:08] <kelvin> so it was calling std::rt::io::print for print statements
[19:15:19] *** Quits: reedlepee (Mibbit@9B9315E1.A6025CA.1C37C358.IP) (Quit: http://www.mibbit.com ajax IRC Client)
[19:15:58] *** Quits: james4k (james@moz-E7990244.consolidated.net) (Quit: WeeChat 0.4.2)
[19:16:29] *** Quits: RMF (RMF@moz-1EE56143.dsl.telepac.pt) (Quit: Computer has gone to sleep.)
[19:16:47] *** Joins: reedlepee (Mibbit@9B9315E1.A6025CA.1C37C358.IP)
[19:16:48] <kelvin> why is std::rt::io:: print set to fail though?
[19:17:21] <cmr> kelvin: because it wasn't implemented in 0.8
[19:17:26] <kimundi> Made an issue about enum mod: https://github.com/mozilla/rust/issues/10090
[19:17:28] <cmr> it has since been implemented.
[19:17:57] <kelvin> gotcha
[19:18:12] <cmr> Rust is still a work in progress
[19:18:48] <kelvin> yeah, I've come to realize this haha
[19:18:57] <reedlepee> Can someone explain about the bug https://github.com/mozilla/rust/issues/1766?
[19:19:28] <cmr> reedlepee: what is unclear?
[19:20:40] <cmr> reedlepee: whenever there is a `type X = Y`, where X is one of the builtins (u8, i8, etc etc), there whould be a warning.
[19:21:25] *** Quits: jstevans (Instantbir@630B0C0.117F92C2.B7830B68.IP) (Ping timeout)
[19:21:25] <d3xter> kimundi: thx for the issue
[19:22:42] <reedlepee> What is meant by shadowed types ?
[19:23:16] <SiegeLord> Oh huh, I didn't know those weren't keywords
[19:23:23] *** Quits: victorporof (victorporo@75D4E0BA.E3B14EAA.D111398B.IP) (Ping timeout)
[19:23:30] *** Joins: victorporof (victorporo@75D4E0BA.E3B14EAA.D111398B.IP)
[19:23:33] <SiegeLord> rusti: let int = 1; int
[19:23:33] -rusti- 1
[19:23:34] *** Joins: jeaye (Jeaye@moz-34FEF2BB.hsd1.ca.comcast.net)
[19:23:52] *** Joins: Jesin (Jessin_@moz-9BB5F6CF.cc.lehigh.edu)
[19:24:50] *** Joins: jstevans (Instantbir@630B0C0.117F92C2.B7830B68.IP)
[19:25:20] <Sharp> kimundi: What's wrong with the second definition in that issue?
[19:25:25] <Sharp> The emulated variant?
[19:25:29] <kimundi> reedlepee: Something is "shadowed" if their name is defined twice, with the latter definitions hiding the first one
[19:25:39] *** Quits: victorporof (victorporo@75D4E0BA.E3B14EAA.D111398B.IP) (Ping timeout)
[19:26:06] <kimundi> Sharp: ... Apart form the fact that its more verbose than just prefixing every enum variant?
[19:26:26] <Sharp> Yeah, apart from that :)  I guess it depends how often you think it will be used.
[19:26:46] <kimundi> I'd say most enums in bigger modules will use this
[19:27:13] *** Joins: james4k (james@moz-E7990244.consolidated.net)
[19:27:40] <kimundi> For example, my current PR adds a enum UnwindReason{ UnwindReasonStr(SendStr), UnwindReasonAny(~Any), UnwindReasonLinked  }
[19:28:08] <kimundi> Woulb be _much_ nicer if it could just be enum mod UnwindReason{ Str(SendStr), Any(~Any), Linked  }
[19:28:24] <Sharp> And you'd rather be able to include the relevant mod?  Otherwise it's even more verbose :)
[19:28:42] <benh> kimundi: mod unwind_reason { enum Ty { Str(...), Any(...), Linked } }?
[19:28:48] <kimundi> Sharp: I don't undertsand this last question :)
[19:29:04] <Sharp> Well, UnwindReason::Str is longer than UnwindReasonStr.
[19:29:18] <Sharp> That's pretty much all I meant.
[19:29:29] *** Joins: Axord (xord@moz-1B228827.lsanca.dsl-w.verizon.net)
[19:29:56] *** Joins: victorporof (victorporo@75D4E0BA.E3B14EAA.D111398B.IP)
[19:30:49] <kimundi> Sharp: You're right it isn't, but it measn you don't repeat yourself all the time, diverging styles of prefixes can't develop, and if you know you don't have a conflict you can 'use UnwindReason::*;'
[19:31:34] <kimundi> It would just all fit nicer together that way :|
[19:31:54] <Sharp> Fair enough.  I don't feel strongly about it either way :)
[19:32:20] <kimundi> Anyway, this enum is just an exmaple, there are a lot of similar examples in rustcs code
[19:32:23] <Sharp> I know that there are compilation-related reasons dacons have to be unique but I don't think this really changes that.
[19:33:03] <kimundi> It would not complicate anything that is possible today
[19:33:09] <Sharp> Right.
[19:34:17] <kimundi> Random example of what happens if you start encoding the enum type in the variant name: https://github.com/mozilla/rust/blob/master/src/libsyntax/ast.rs#L190
[19:35:09] <kimundi> Or this one: https://github.com/mozilla/rust/blob/master/src/libsyntax/ast.rs#L227
[19:35:14] <ktt3ja> would anyone be willing to look at this and explain to me why the value in the same memory address gets changed? https://gist.github.com/ktt3ja/7173503
[19:35:34] <Sharp> I guess I'm just used to seeing dacons like that from ML :P
[19:35:38] <Sharp> They don't bother me too much.
[19:35:49] <kimundi> "dacon"?
[19:35:54] <Sharp> data constructors.
[19:36:00] <kimundi> Ah.
[19:40:21] *** Joins: strcat (strcat@moz-54F7FD49.cpe.net.cable.rogers.com)
[19:40:37] <d3xter> btw, does from_str::<u8>("..") convert the string to a single u8?
[19:40:52] <d3xter> or parts of it
[19:41:15] *** Quits: reedlepee (Mibbit@9B9315E1.A6025CA.1C37C358.IP) (Quit: http://www.mibbit.com ajax IRC Client)
[19:41:43] <FreeFull> > from_str::<u8>("..")
[19:41:47] <FreeFull> rusti: from_str::<u8>("..")
[19:41:48] -rusti- None
[19:42:07] <kimundi> d3xter: from_str tries to parse, not to cast
[19:42:08] <FreeFull> Seems it actually tries to parse the string to get an u8
[19:42:11] <FreeFull> rusti: from_str::<u8>("43")
[19:42:12] -rusti- Some(43u8)
[19:42:21] <FreeFull> And puts a single one in an Option
[19:42:25] <kimundi> rusti: from_str::<u8>("256")
[19:42:26] -rusti- None
[19:42:30] <kimundi> rusti: from_str::<u8>("255")
[19:42:31] -rusti- Some(255u8)
[19:42:46] <kimundi> rusti: 97u8 as char
[19:42:47] -rusti- 'a'
[19:42:54] <FreeFull> rusti: from_str::<u8>("43u8")
[19:42:55] -rusti- None
[19:43:03] <kimundi> rusti: (97u8 as char).to_str()
[19:43:04] -rusti- ~"a"
[19:43:32] <kimundi> rusti: "a".char_at(0).to_u8()
[19:43:34] -rusti- pastebinned 7 lines of output: http://sprunge.us/OeGA
[19:43:39] <kimundi> rusti: "a".char_at(0)
[19:43:40] -rusti- 'a'
[19:43:57] <ercxx> why is it not u8::from_str()?
[19:44:52] <kimundi> because u8 is module, and from_str is a standalone function that works around the fact that we can't call it like "FromStr::<for u8>::from_str("45")" right now
[19:45:30] <kimundi> We used to have u8::from_str() etc, but they are just redunant definitions for something that should be solved at an language level
[19:45:48] *** Quits: StarLight (StarLight@moz-36BD674D.dynamic.avangarddsl.ru) (Ping timeout)
[19:45:56] <ercxx> that's what I'm trying to understand.
[19:46:55] *** Joins: reedlepee (Mibbit@9B9315E1.A6025CA.1C37C358.IP)
[19:47:02] <kimundi> rusti: from_str::<char>("a")
[19:47:03] -rusti- pastebinned 6 lines of output: http://sprunge.us/SFjG
[19:47:26] <kimundi> rusti: from_str::<u32>("9787")
[19:47:27] -rusti- Some(9787u32)
[19:47:46] <ercxx> I this where the magic happens: http://static.rust-lang.org/doc/master/src/std/home/rustbuild/src/rust-buildbot/slave/doc/build/src/libstd/num/uint_macros.rs.html#249 ?
[19:48:25] <kimundi> Thats just a implementation of it
[19:48:32] <kimundi> of the FromStr trait
[19:48:38] <d3xter> btw, how can i convert &str -> &[u8]?
[19:48:46] <kimundi> .as_bytes()
[19:49:19] <d3xter> kimundi: thanks :)
[19:49:33] *** Joins: lenstr (lenstr@CD7D5ABA.83A99F98.85938D85.IP)
[19:49:42] *** Quits: eevee (eevee@moz-14DB8285.evrt.wa.frontiernet.net) (Ping timeout)
[19:49:48] <kimundi> ercxx: The from_str function and the FromStr trait is defined in the module std::from_str
[19:50:06] *** Joins: StarLight (StarLight@moz-85949F9B.dynamic.avangarddsl.ru)
[19:50:11] *** Joins: loudly (Mibbit@E8C1E873.17A0D1EC.B7830B68.IP)
[19:50:25] <kimundi> rusti: let x: Option<u16> = std::from_str::FromStr::from_str("159"); x
[19:50:26] -rusti- Some(159u16)
[19:50:40] *** Joins: canhtak (jeremy@moz-830A7AA1.wl.t.ulaval.ca)
[19:50:48] <FreeFull> Has anyone made a non-unicode str type for rust?
[19:51:07] <ercxx> kimundi: That has only one line: FromStr::from_str(s)
[19:51:08] <kimundi> Not as part of the std lib
[19:51:25] <FreeFull> I mean, overall
[19:51:26] <kimundi> ercxx: What where has one line?
[19:51:43] <ercxx> http://static.rust-lang.org/doc/master/src/std/home/rustbuild/src/rust-buildbot/slave/doc/build/src/libstd/from_str.rs.html#24-26
[19:51:48] <loudly> rusti: impl Ord for SocketAddr { fn lt(&self, other: &SocketAddr) -> bool { self.to_str() == other.to_str()
[19:51:49] -rusti- pastebinned 12 lines of output: http://sprunge.us/XZZc
[19:52:17] <ercxx> I'm still trying to understand how some things work in rust. It feels like a lot of magic.
[19:52:22] <loudly> anyone can tell me why i get "cannot provide extension implementation for a trait not defined in this crate" error?
[19:52:54] <loudly> rusti: impl Ord for SocketAddr { fn lt(&self, other: &SocketAddr) -> bool { self.to_str() == other.to_str() } }
[19:52:55] -rusti- pastebinned 10 lines of output: http://sprunge.us/PdFF
[19:53:01] <kimundi> ercxx: Okay, https://github.com/mozilla/rust/blob/master/src/libstd/from_str.rs looks indeed very empty, but there is nothing else to it, its just a regular trait :)
[19:53:14] *** Joins: eevee (eevee@moz-3625B552.evrt.wa.frontiernet.net)
[19:53:17] *** Quits: eatkinson (eatkinson@moz-E57448EF.airbears2.berkeley.edu) (Quit: eatkinson)
[19:53:18] <kimundi> A trait is a trait definion +-
[19:53:29] <d3xter> kimundi: last question for today :) is it possible to call a function from another function inside the same implementation?
[19:53:38] <kimundi> A trait is a trait definion + implementations of that trait for types
[19:54:06] <kimundi> d3xter: I don't understand the question :)
[19:54:08] <loudly> rusti: use std::cmp::Ord;  impl Ord for SocketAddr { fn lt(&self, other: &SocketAddr) -> bool { self.to_str() == other.to_str() } }
[19:54:09] -rusti- pastebinned 10 lines of output: http://sprunge.us/ONfE
[19:54:11] *** Quits: Jackneill (Jackneill@moz-7F14DEFC.pool.digikabel.hu) (Input/output error)
[19:54:16] <Sharp> d3xter: Yes.
[19:54:26] *** Joins: iguano (iguano@262C1533.877470F0.D6ED2E20.IP)
[19:54:30] <iguano> http://www.theweeklypay.com/index.php?share=19844/
[19:54:40] <ercxx> loudly: It's complaining about an undeclared type.
[19:55:02] <ercxx> loudly: SocketAddr
[19:55:05] <myname> ol
[19:55:06] <strcat> FreeFull: do you have a specific encoding in mind?
[19:55:19] <d3xter> i've got an implementation for my Logger with 2 methods: newFileLogger(path) and new(), both return a Logger struct, but i cant call new() from newFileLogger()
[19:55:32] <kimundi> rusti: "hello".to_ascii()
[19:55:33] -rusti- pastebinned 1 lines of output: http://sprunge.us/WPgM
[19:55:42] <ercxx> loudly: use std::rt::io::net::ip::SocketAddr;
[19:55:43] <loudly> rusti: use:: std::rt::io::net::ip::SocketAddr; use std::cmp::Ord;  impl Ord for SocketAddr { fn lt(&self, other: &SocketAddr) -> bool { self.to_str() == other.to_str() } }
[19:55:43] -rusti- pastebinned 6 lines of output: http://sprunge.us/DYBY
[19:55:51] <sp3d> loudly: I think the problem is that you're only allowed to impl a trait for a type if you declared the trait or the type in the current crate, but Ord and SockedAddr are both from the stdlib
[19:56:06] <kimundi> Exactly that
[19:56:08] <sp3d> SocketAddr*
[19:56:28] <strcat> you can ofc wrap it and define Ord on the wrapper
[19:56:29] <ercxx> loudly: you have a syntax error there. 'use:: '
[19:56:37] <Sharp> It's awesome that you can't do that :)
[19:57:01] <ercxx> rusti:  use std::rt::io::net::ip::SocketAddr; use std::cmp::Ord;  impl Ord for SocketAddr { fn lt(&self, other: &SocketAddr) -> bool {        │ bran
[19:57:02] -rusti- pastebinned 6 lines of output: http://sprunge.us/SUOM
[19:57:03] <ercxx>                         ┃ self.to_str() == other.to_str() } } 
[19:57:12] <ercxx> kkkoops
[19:57:25] <ercxx> rusti:  use std::rt::io::net::ip::SocketAddr; use std::cmp::Ord;  impl Ord for SocketAddr { fn lt(&self, other: &SocketAddr) -> bool { self.to_str() == other.to_str() } }
[19:57:26] -rusti- pastebinned 7 lines of output: http://sprunge.us/QPFD
[19:57:34] <d3xter> Sharp: all i get is "unresolved name new()" :/
[19:57:37] *** Joins: fyolnish (fyolnish@moz-3962E7B9.uqwimax.jp)
[19:57:56] <Sharp> Weird.  I would have thought it would work, I'm pretty sure I have called methods from within the same impl in the past.
[19:58:16] <loudly> ercxx: yep, thats the error im getting when i compile
[19:58:20] <sp3d> d3xter: does self.new() work?
[19:58:22] <kimundi> Sharp: Hm? What doesn't work?
[19:58:25] <ercxx> error: cannot provide an extension implementation where both trait and type are not defined in this crate
[19:58:36] <ercxx> What does this mean?
[19:58:41] <Sharp> d3xter: I doubt there's a self, it's new() :)
[19:58:43] <d3xter> sp3d: "self is not allowed in this context"
[19:58:46] <kimundi> ercxx: Thats intentional
[19:58:53] <sp3d> hm
[19:58:56] <d3xter> and yes, there is no self in new()
[19:58:58] <Sharp> d3xter: Try Type::new()
[19:59:03] <sp3d> oh
[19:59:15] *** Quits: kelvin (Mibbit@2B0B4E57.83BCE10.DDE5D3F6.IP) (Quit: http://www.mibbit.com ajax IRC Client)
[19:59:20] *** Quits: fyolnish (fyolnish@moz-3962E7B9.uqwimax.jp) (Ping timeout)
[19:59:38] <Sharp> kimundi: d3xter's thing.
[19:59:51] <kimundi> ercxx: If you implement a trait for a type, you have to either have the type or the trait defined in the crate where you write the impl
[20:00:15] <d3xter> Sharp: worked, thanks :)
[20:00:23] <kimundi> ercxx: This ensures that you can always link two rust libraries together
[20:00:28] <Sharp> NP, I'm still learning Rust too :)
[20:00:29] <ercxx> kimundi: thanks
[20:01:25] <kimundi> ercxx: If you could implement a trait for a type that are both not defined in your crate, then someone else could too, and if sa third party links against the first two, then the compiler/linker wouldn't know which one to pick
[20:01:28] *** Joins: eatkinson (eatkinson@moz-E57448EF.airbears2.berkeley.edu)
[20:01:42] *** Quits: iguano (iguano@262C1533.877470F0.D6ED2E20.IP) (Quit: )
[20:02:03] *** Joins: DAddYE (DAddYE@moz-98D3933F.hsd1.ca.comcast.net)
[20:02:08] *** Joins: iguano (iguano@262C1533.877470F0.D6ED2E20.IP)
[20:02:27] *** Quits: iguano (iguano@262C1533.877470F0.D6ED2E20.IP) (Quit: )
[20:03:47] *** Quits: DAddYE (DAddYE@moz-98D3933F.hsd1.ca.comcast.net) (Ping timeout)
[20:04:35] <loudly> im sorry, im still new to rust and dont fully understand traits/crates. what do i do to fix the crate issue?
[20:05:11] <d3xter> alright guys, thanks for the help. cya :)
[20:05:41] *** Joins: hjr3 (hradtke@moz-E87BDF1F.socal.res.rr.com)
[20:05:51] <ercxx> kimundi: so that means I can not implement a trait exists in std for SocketAddr?
[20:06:03] *** Quits: d3xter (sinz@moz-839BDF11.adsl.highway.telekom.at) (Quit: WeeChat 0.4.2)
[20:06:06] <kimundi> loudly: Open a pull request to implement Ord on SockketAddr in the rust standart library, or define a wrapper for SocketAddr
[20:06:09] *** Quits: hjr3 (hradtke@moz-E87BDF1F.socal.res.rr.com) (Quit: My MacBook has gone to sleep. ZZZzzz…)
[20:06:20] <kimundi> ercxx: Right
[20:06:33] *** Quits: jstevans (Instantbir@630B0C0.117F92C2.B7830B68.IP) (Ping timeout)
[20:06:38] <ercxx> I see.
[20:06:46] <ercxx> It would be cool though :)
[20:07:21] *** Joins: tetsuharu (tetsuharu@moz-A3FEAA56.ap219.ftth.ucom.ne.jp)
[20:07:25] <kimundi> ercxx: It has the issue that a library writer has to thing of everything, but it's better than randomly not being able to link libraries together
[20:07:52] <kimundi> Again, You can just define a wrapper for SocketAddr
[20:07:58] *** Quits: JamesNZ (james@moz-264643C7.bitstream.orcon.net.nz) (Client exited)
[20:08:04] <ercxx> thanks for the explanation
[20:08:09] <Sharp> Another place delegators would be useful, IMO.
[20:08:31] <kimundi> struct MySocketAddr(SoccketAddr); impl Ord for MySocketAddr { ... }  MySocketAddr(a) < MySocketAddr(b)
[20:08:36] <kimundi> Sharp: Yeah
[20:08:57] *** Quits: eatkinson (eatkinson@moz-E57448EF.airbears2.berkeley.edu) (Quit: eatkinson)
[20:09:03] *** Quits: tetsuharu (tetsuharu@moz-A3FEAA56.ap219.ftth.ucom.ne.jp) (Ping timeout)
[20:09:32] <kimundi> Hm, maybe have a convention for doing that stuff in a as less verbose way as possible
[20:10:02] <ercxx> kimundi: Is that the inheritance syntax?
[20:10:09] <kimundi> No
[20:10:24] *** Joins: jstevans (Instantbir@630B0C0.117F92C2.B7830B68.IP)
[20:10:31] <kimundi> That was just meant to look like invoke the less-than operator
[20:10:33] *** Quits: alonlevy (alon@moz-61A0AD83.red.bezeqint.net) (Ping timeout)
[20:10:55] <ercxx> no I meant the first part
[20:11:01] <ercxx>  struct MySocketAddr(SoccketAddr)
[20:11:14] <Sharp> That's just a tuple struct.
[20:11:27] <Sharp> Though it's not a very good wrapper since tuple fields are pub.
[20:11:51] *** Quits: jsingh (Mibbit@C3D7FFFE.4DB138C4.DDE5D3F6.IP) (Quit: http://www.mibbit.com ajax IRC Client)
[20:12:06] <ercxx> The single field tuple thing we have?
[20:12:23] <Sharp> 1-tuples are still tuples :)
[20:13:16] <ercxx> I want to read about newtypes now.
[20:14:09] <loudly> kimundi: thanks for the help :)
[20:15:01] *** Quits: lenstr (lenstr@CD7D5ABA.83A99F98.85938D85.IP) (Client exited)
[20:15:07] <benh> I think we call them newtype structs if they have just one field tho
[20:15:14] <benh> since you can get the field out with *
[20:15:30] <benh> also surely you can make the fields priv anyway?
[20:18:58] <kimundi> Hm, do you think a convention for wrapper structs would be good?
[20:19:02] <kimundi> Something like this:
[20:19:03] <kimundi> rusti: trait ToMyWrapper<T> { fn my(self) -> T; }; struct MyInt(int); impl ToMyWrapper<MyInt> for int { fn my(self) -> MyInt { MyInt(self) } }; impl ToStr for MyInt { fn to_str(&self) -> ~str { (**self).to_str() + " !!!" } }; (45i.to_str(), 45i.my().to_str())
[20:19:04] -rusti- (~"45", ~"45 !!!")
[20:19:46] <kimundi> Basically, if you need to defne a wrapper implement ToMyWrapper to enable convenient wrapping syntax
[20:20:00] <kimundi> err, to get a convenient method at elast
[20:20:05] <kimundi> at least*
[20:21:05] *** Joins: lenstr (lenstr@CD7D5ABA.83A99F98.85938D85.IP)
[20:21:21] <eddyb> kimundi: with UFCS, you don't need the "anonymous" trait :P
[20:21:34] <kimundi> As soon as we can do impl TraitA<TypeB> for TypeD and impl TraitA<TypeC> for TypeD at the same time that would be really convenient, and could be supported with a deriving mode
[20:21:47] <kimundi> eddyb: Hm?
[20:22:16] <eddyb> struct MyInt(int); fn my(self : int) -> MyInt { MyInt(self) }
[20:22:24] <kimundi> Unified function call syntax is just for calling a method like a function
[20:22:53] <eddyb> I was under the impression it allowed calling a function like a method, too
[20:22:55] <kimundi> Still need to define that
[20:23:12] <kimundi> No, that not
[20:23:15] <eddyb> :(
[20:23:27] <kimundi> and self: int would also not work
[20:23:36] <kimundi> At least not in the proposal I know of
[20:24:02] *** Joins: enix (enix@moz-A50569DD.c3-0.slvr-ubr1.lnh-slvr.md.cable.rcn.com)
[20:24:07] <eddyb> maybe &int, not sure
[20:24:15] <kimundi> Also no
[20:24:27] <kimundi> &T is just as much a externally defined type as int
[20:25:13] <kimundi> YOu can only add methods to a type not defined in your crate by implementing an extension trait for it
[20:25:26] <kimundi> Which ToMyWrapper (bad name) would be
[20:25:50] <kimundi> Hm, I think I'll make an issue about this...
[20:25:51] *** Joins: nejucomo (Adium@moz-A94CACD5.dsl.pltn13.sbcglobal.net)
[20:26:13] *** Quits: jstevans (Instantbir@630B0C0.117F92C2.B7830B68.IP) (Ping timeout)
[20:26:40] *** Quits: robertknight (robertknig@moz-1FB7516D.range81-157.btcentralplus.com) (Ping timeout)
[20:27:12] <eddyb> kimundi: that's why I was thinking UFCS, I completely forgot about actual impl's :P
[20:28:02] <SiegeLord> There was a thread about this on the ML recently... using the method call syntax for free functions had a cool reception
[20:29:46] *** Joins: jstevans (Instantbir@630B0C0.117F92C2.B7830B68.IP)
[20:29:55] *** Joins: Gokhan (Geveze@B2F92B4A.980B3CB7.E084BF44.IP)
[20:30:56] <ercxx> I tried debugging using gdb, and failed miserably before.
[20:31:09] <ercxx> Is gdb support ok?
[20:31:11] <eddyb> kimundi: Ruby has straight-forward semantics (no special syntax) for extending built-ins, that could be cool
[20:31:26] <eddyb> JS allows for monkey-patching almost anything, but that's a different story :P
[20:31:26] *** Quits: jstevans (Instantbir@630B0C0.117F92C2.B7830B68.IP) (Ping timeout)
[20:32:07] <strcat> ercxx: yes
[20:32:12] <strcat> you do have to enable debug symbol support
[20:32:17] <Sharp> Ruby's builtin extensions are kind of nightmarish, IMO.
[20:32:26] <ercxx> I did. I was using ddd.
[20:32:38] *** Joins: brson (brson@moz-BBE3ABD.mv.mozilla.com)
[20:32:38] *** ChanServ sets mode: +ao brson brson
[20:32:41] <ercxx> I'll look at some proper gdb tutorials first.
[20:32:41] <Sharp> Gives you too much freedom, there's no reliable check you can perform on a type :P
[20:33:10] <kimundi> eddyb: We won't change rusts syntax that majorly anymore though, so I only see solutions that make the existing system more useful as realistic at this point :)
[20:35:55] *** Quits: Gokhan (Geveze@B2F92B4A.980B3CB7.E084BF44.IP) (Quit: )
[20:36:25] *** Joins: jstevans (Instantbir@630B0C0.117F92C2.B7830B68.IP)
[20:37:47] *** Quits: reedlepee (Mibbit@9B9315E1.A6025CA.1C37C358.IP) (Quit: http://www.mibbit.com ajax IRC Client)
[20:39:19] <eddyb> strcat: oh hi. you remind me I have to deal with your new Allocators :(
[20:39:35] <strcat> I still didn't fix that dtor bug
[20:40:33] <eddyb> also, you don't mention wrapping static mut allocator instances, which is what the libc Heap allocator is (inside libc itself)
[20:41:24] <loudly> rusti: use extra::priorityqueue; fn main() { let req_vec: ~[str] = ~[]; let prio_vec= priority_queue::PriorityQueue::from_vec(req_vec) }
[20:41:26] -rusti- pastebinned 6 lines of output: http://sprunge.us/ZdgG
[20:41:43] <loudly> rusti: use extra::priorityqueue; fn main() { let req_vec: ~[str] = ~[]; let prio_vec= priority_queue::PriorityQueue::from_vec(req_vec); }
[20:41:44] <eddyb> if it's reentrant, it will work. fancy allocators being stored in Rc<..> require a default heap in the first place
[20:41:46] -rusti- pastebinned 10 lines of output: http://sprunge.us/KiEc
[20:42:12] <eddyb> loudly: priorityqueue vs priority_queue
[20:42:35] <eddyb> loudly: and rusti already is inside main
[20:42:38] *** Joins: jsingh (Mibbit@C3D7FFFE.4DB138C4.DDE5D3F6.IP)
[20:42:41] <loudly> ah whoops. working in vm. i cant copy zz
[20:43:00] <eddyb> rusti: use extra::priority_queue; let req_vec: ~[str] = ~[]; let prio_vec = priority_queue::PriorityQueue::from_vec(req_vec); 
[20:43:01] <loudly> rusti: use extra::priority_queue; let req_vec: ~[str] = ~[]; let prio_vec= priority_queue::PriorityQueue::from_vec(req_vec);
[20:43:02] -rusti- pastebinned 7 lines of output: http://sprunge.us/CddP
[20:43:03] -rusti- pastebinned 7 lines of output: http://sprunge.us/GTFP
[20:43:05] <eddyb> lol
[20:43:08] <loudly> haha
[20:43:42] <Earnestly> •_•
[20:44:23] <jsingh> what's best way to go from an ~[char] to it's equiv ~str?
[20:44:39] <loudly> hi justdave
[20:44:42] *** Joins: reedlepee (Mibbit@9B9315E1.A6025CA.1C37C358.IP)
[20:44:53] <jsingh> loudly who is this haha
[20:44:55] <eddyb> jsingh: where do you have ~[char] from?
[20:45:03] <loudly> who is this i wonder?
[20:45:16] <sp3d> rusti: match &mut [1u, 2u, 3] { [] => {}, [ref mut a] => *a=1, [ref mut a, ref mut b] => {*a=2; *b=3}, [ref mut a, ref mut b, ref mut c, .._/*rest*/] => {*a=3; *b=4; *c=4/*+ rest.len()*/} }
[20:45:16] -rusti- ()
[20:45:21] *** Quits: reedlepee (Mibbit@9B9315E1.A6025CA.1C37C358.IP) (Quit: http://www.mibbit.com ajax IRC Client)
[20:45:22] *** Joins: robertknight (robertknig@moz-54528EE0.wby.mendeley.com)
[20:45:24] <cmr> jsingh: str::from_chars
[20:45:32] <jsingh> cmr thanks!
[20:45:36] <sp3d> ^ is there any chance this, with comments uncommented, will ever be allowed?
[20:45:38] *** Joins: mib_1wt6zx (Mibbit@9B9315E1.A6025CA.1C37C358.IP)
[20:46:00] <cmr> sp3d: does vector matching not have that now?
[20:46:01] <eddyb> rest would be actually easy to do, since we have slices :D
[20:46:04] <sp3d> (or something like it; I can't find any way to bind the tail of the list in such a situation)
[20:46:14] <eddyb> (if it's not there already)
[20:46:38] <cmr> rusti: let x = &[1u, 2, 3]; match x { &[1, ..rest] => println!("{:?}", rest), _ => print("foo") }
[20:46:39] -rusti- pastebinned 7 lines of output: http://sprunge.us/ZaBQ
[20:46:52] <cmr> rusti: let x = &[1u, 2, 3]; match x { [1, ..rest] => println!("{:?}", rest), _ => println("foo") }
[20:46:53] -rusti- &[2u, 3u]
[20:46:53] -rusti- ()
[20:47:05] *** Quits: robertknight (robertknig@moz-54528EE0.wby.mendeley.com) (Ping timeout)
[20:47:08] <sp3d> rusti: match &mut [1u, 2u, 3] { [] => {}, [ref mut a] => *a=1, [ref mut a, ref mut b] => {*a=2; *b=3}, [ref mut a, ref mut b, ref mut c, .._rest] => {*a=3; *b=4; *c=4+ rest.len()} }
[20:47:09] -rusti- pastebinned 7 lines of output: http://sprunge.us/abSH
[20:47:20] <sp3d> er
[20:47:26] <sp3d> rusti: match &mut [1u, 2u, 3] { [] => {}, [ref mut a] => *a=1, [ref mut a, ref mut b] => {*a=2; *b=3}, [ref mut a, ref mut b, ref mut c, ..rest] => {*a=3; *b=4; *c=4+ rest.len()} }
[20:47:27] -rusti- pastebinned 10 lines of output: http://sprunge.us/iINW
[20:47:40] <cmr> hm
[20:47:52] <eddyb> jsingh: I'm asking where do you get ~[char] from because that's a 3 byte per char overhead with ASCII, you may be able to avoid it
[20:47:55] <cmr> git clone https://cmr@github.com/cmr/0ad.git
[20:47:57] <cmr> whoops
[20:48:03] <sp3d> but "ref mut rest" gives an &mut &mut [T] which can't be moved-out-of afaict
[20:48:25] <cmr> sp3d: it can't be, but rest.len() doesn't move.
[20:48:30] <sp3d> it's almost like it's syntactically borrowed to an &[T]?
[20:48:37] <cmr> sp3d: you're matching on a slice, which you can't move out of anyway.
[20:48:39] *** Joins: brendan (brendaneic@moz-A19854B6.mcln.va.megapath.net)
[20:48:44] <sp3d> yeah
[20:49:04] <sp3d> the code isn't quite relevant to a real-world use case as I was trying to simplify it to prod at the language
[20:49:08] *** Quits: sweet_kid (Upasana@A78CFDAE.2EC9110A.4A5F0685.IP) (Quit: Leaving)
[20:49:27] <jsingh> eddyb ah I'm incrementally parsing some query params
[20:49:37] <jsingh> eddyb any more effective ways to go about that?
[20:50:04] <eddyb> jsingh: so you push a char to a ~[char]?
[20:50:20] <sp3d> but it seems like such a thing should allow writing a safe function to split an &'a mut [T] into an &mut T and another &mut [T] for the tail?
[20:50:31] <sp3d> (with appropriate lifetime)
[20:50:32] <cmr> sp3d: seems that way, yeah
[20:50:45] <eddyb> jsingh: http://static.rust-lang.org/doc/master/std/str/trait.OwnedStr.html#tymethod.push_char
[20:50:53] <eddyb> jsingh: that will be more memory-efficient
[20:51:02] *** Quits: brson (brson@moz-BBE3ABD.mv.mozilla.com) (Ping timeout)
[20:51:05] <jsingh> eddyb GG
[20:51:22] <Ms2ger> sp3d, can't mut_split do that?
[20:51:30] <sp3d> yes
[20:54:07] <jsingh> eddyb got it working with push_char, thanks
[20:55:29] *** Joins: brson (brson@981AA104.E81F12CD.76F66111.IP)
[20:55:29] *** ChanServ sets mode: +ao brson brson
[20:55:46] <eddyb> hmm, http://static.rust-lang.org/doc/master/std/str/trait.StrSlice.html#tymethod.slice_shift_char
[20:56:17] <eddyb> anbd there's other nifty tricks in there
[20:57:31] *** Joins: fyolnish (fyolnish@moz-8364E19.uqwimax.jp)
[20:57:33] * eddyb now wants an IDE that can highlight based on memory cost/algorithmic complexity
[20:58:01] <SiegeLord> How do you run #[bench] functions?
[20:58:06] <McPherrin> eddyb: heh
[20:58:09] <cmr> SiegeLord: rustc --test ...; ./... --bench
[20:58:32] <McPherrin> That's a neat idea, though very hard to make work
[20:58:41] <SiegeLord> Huh, that's... roundabout, but ok
[20:58:52] <cmr> Why?
[20:59:20] *** Quits: fyolnish (fyolnish@moz-8364E19.uqwimax.jp) (Ping timeout)
[20:59:28] <SiegeLord> When you do --test, is the main function not compiled at all?
[20:59:34] <cmr> No
[20:59:43] <cmr> It builds the test runner;.
[20:59:52] <cmr> (Which lives in extra)
[21:00:10] *** Quits: jstevans (Instantbir@630B0C0.117F92C2.B7830B68.IP) (Ping timeout)
[21:00:13] <cmr> does some minor magic to extract the #[test}/#[bench] paths to pass to it
[21:00:33] *** Joins: squiddy (squiddy@moz-C33F1661.adsl.alicedsl.de)
[21:01:00] <bodie_> anybody have a comment on whether erlang or go would be preferable to prototype a rust application in?
[21:01:11] <bodie_> i.e. which one is more similar to the rust "way"
[21:01:15] <cmr> bodie_: SML
[21:01:18] <cmr> Or OCaml
[21:01:21] <cmr> :p
[21:01:46] <bodie_> *ponders*
[21:01:49] <SiegeLord> I might almost prefer having rustc --bench... dunno
[21:01:54] <strcat> bodie_: rust? ;p
[21:02:19] <cmr> (the bootstrap compiler was written in ocaml, and rust borrows a lot from ml)
[21:02:51] <eddyb> why would you prototype a rust app in another language?
[21:03:07] <bodie_> Completely new to Rust
[21:03:19] *** Joins: DAddYE (DAddYE@moz-98D3933F.hsd1.ca.comcast.net)
[21:03:31] *** Joins: RMF (RMF@moz-A9053785.dsl.telepac.pt)
[21:03:37] <bodie_> Wanting to "just get something working" and then start rebuilding core bits in Rust until I'm a little more comfortable in it
[21:03:47] <bodie_> also I need a working Redis client 
[21:03:48] *** Joins: jstevans (Instantbir@630B0C0.117F92C2.B7830B68.IP)
[21:03:50] *** Quits: strcat (strcat@moz-54F7FD49.cpe.net.cable.rogers.com) (Quit: WeeChat 0.4.2)
[21:03:55] *** Quits: rusti (rusti@moz-54F7FD49.cpe.net.cable.rogers.com) (Client exited)
[21:04:00] <bodie_> cmr, interesting
[21:04:26] * Sharp finds Rust to be pretty close to a C/Ocaml hybrid.
[21:04:38] <Ms2ger> Isn't that what it is? :)
[21:05:00] <Sharp> Nothing wrong with that :)
[21:05:06] *** Quits: DAddYE (DAddYE@moz-98D3933F.hsd1.ca.comcast.net) (Ping timeout)
[21:05:17] <tikue_> more like C++/Ocaml imo
[21:05:23] <tikue_> since C doesn't really have OO
[21:05:29] <Ms2ger> Neither does rust :)
[21:05:34] <tikue_> sure it does
[21:05:34] <Earnestly> ._.
[21:05:37] <Sharp> OCaml does, anyway.
[21:05:39] *** Joins: rusti (rusti@moz-54F7FD49.cpe.net.cable.rogers.com)
[21:05:45] <Ms2ger> Have you seen Servo's excuse for inheritance? :)
[21:05:47] <Earnestly> Suddenly sillyness
[21:05:51] <tikue_> and it's looking like it's getting single inheritance :P
[21:06:04] <Sharp> Yeah, which I'm not sure I'm a fan of but if it's necessary it's necessary.
[21:06:10] <tikue_> word
[21:06:29] <eddyb> it's sugar + more powerful traits :)
[21:06:42] <cmr> eddyb: sugar for what?
[21:06:50] <Ralith> C/SML would probably be a better way of putting it
[21:06:56] * Earnestly worships the all powerful cargo-cult of OO
[21:07:00] <Sharp> Hah.
[21:07:17] <Sharp> Yeah, it's more like SML than OCaml I suppose
[21:07:17] *** Quits: Ms2ger (Ms2ger@moz-EC6C128C.adsl-dyn.isp.belgacom.be) (Quit: nn)
[21:07:21] <eddyb> cmr: you can fake something like single inheritance without language support, but it's not really nice
[21:07:23] <Sharp> Less signatures and some other stuff.
[21:07:25] <Earnestly> Inheritance!  Encapsulation!  Classes!
[21:07:30] <Earnestly> ._.
[21:07:36] <cmr> eddyb: it's also slow
[21:07:40] *** Joins: tetsuharu (tetsuharu@moz-A3FEAA56.ap219.ftth.ucom.ne.jp)
[21:07:55] <cmr> Earnestly: Abstract virtual interfaces!
[21:08:02] <bodie_> I prefer Abjective-C
[21:08:18] *** Joins: annodomini (lambda@moz-9AC5B452.hsd1.ma.comcast.net)
[21:08:18] <eddyb> bodie_: that better not be a typo!
[21:08:22] <bodie_> :P
[21:08:29] <eddyb> cmr: well, trait objects :D
[21:08:40] <Earnestly> Someone long ago said Rust was what C might have looked like if it was designed today and the author knew haskell
[21:08:48] <Sharp> Heh.
[21:08:58] <tikue_> wait there's a really good quote
[21:09:06] <eddyb> C++ would've been unnecessary then :)
[21:09:14] <eddyb> or it would end up being much better
[21:09:23] *** Joins: dherman (dherman@moz-B31C6965.dsl.pltn13.sbcglobal.net)
[21:09:23] *** ChanServ sets mode: +ao dherman dherman
[21:09:25] *** Quits: tetsuharu (tetsuharu@moz-A3FEAA56.ap219.ftth.ucom.ne.jp) (Ping timeout)
[21:09:27] <tikue_> idk who it's originally by but it's in https://air.mozilla.org/intern-presentation-sullivan/ somewhere
[21:09:40] <eddyb> (this is my view of C++ from the rust side. I know most people hate it in general :/)
[21:09:59] <loudly> rusti: use extra::priority_queue; let queue = priority_queue::PriorityQueue::new();
[21:10:02] -rusti- pastebinned 6 lines of output: http://sprunge.us/VjeB
[21:10:16] *** Joins: CarpNet (Alasdair@moz-25C796BC.cable.virginm.net)
[21:10:59] *** Quits: jstevans (Instantbir@630B0C0.117F92C2.B7830B68.IP) (Ping timeout)
[21:11:07] <cmr> Rust will probably never approach C++'s power.
[21:11:15] <tikue_> in what sense
[21:11:23] <eddyb> template metaprogramming?
[21:11:28] <cmr> Yeah
[21:11:35] <Sharp> I don't think it needs to.
[21:11:38] <cmr> Neither do I
[21:12:04] <cmr> To me the question isn't "Why use Rust when I have C++", it's "Why use Rust when I have C"
[21:12:05] <eddyb> but certain applications can be better implemented in other ways
[21:12:20] <Amaranth> The fact that C++ gives you every tool in the toolbox and lets you decide what makes sense where is why it is where it is
[21:12:31] <tikue_> cmr: i disagree
[21:12:41] *** Quits: mib_1wt6zx (Mibbit@9B9315E1.A6025CA.1C37C358.IP) (Quit: http://www.mibbit.com ajax IRC Client)
[21:12:47] <cmr> tikue_: about what?
[21:12:47] <eddyb> CTFE shouldn't be as restrictive as C++11 constexprs
[21:13:12] <eddyb> Amaranth: and I see a lot of people claiming it's bad just because they weren't able to make some choices :P
[21:13:59] <eddyb> C++ comes in handy to abstract away some of the problems inherent in C, but Rust is closer to a clean slate :D
[21:14:38] *** Joins: FrozenCow (FrozenCow@moz-B2DF4929.chello.nl)
[21:16:10] *** Joins: reedlepee (Mibbit@9B9315E1.A6025CA.1C37C358.IP)
[21:17:38] *** Quits: ambimorph (amber@moz-B376C52.hlrn.qwest.net) (Quit: Leaving.)
[21:18:14] *** Joins: CurlyBrace (Mibbit@moz-21083258.hsd1.va.comcast.net)
[21:20:47] *** Joins: jensnockert (jensnocker@moz-5D53B643.cust.bredband2.com)
[21:22:23] <CurlyBrace> greetings
[21:23:26] *** Joins: ross (ross@moz-5EA04060.br.br.cox.net)
[21:26:14] *** jorendorff_away is now known as jorendorff
[21:27:45] *** Joins: earlzlap (earlz@moz-9E279EAD.neo.res.rr.com)
[21:29:20] *** Joins: bleibig (bleibig@moz-CB11172C.hsd1.ca.comcast.net)
[21:30:57] *** Quits: GeneralMaximus (ankur@5013E005.F3B6E096.BE90E62C.IP) (Quit: Computer has gone to sleep.)
[21:33:10] *** Joins: dbaupp (Thunderbir@moz-EA27E3E6.lns20.syd6.internode.on.net)
[21:34:46] *** Joins: refold (gman@moz-42D68426.a258.priv.bahnhof.se)
[21:36:44] *** Joins: glennsl (textual@moz-5D7B804F.getinternet.no)
[21:37:02] *** Quits: brendan (brendaneic@moz-A19854B6.mcln.va.megapath.net) (Quit: brendan)
[21:38:00] *** Joins: jstevans (Instantbir@630B0C0.117F92C2.B7830B68.IP)
[21:41:46] *** Joins: eatkinson (eatkinson@moz-261EDE03.hsd1.ca.comcast.net)
[21:43:44] *** Quits: jsingh (Mibbit@C3D7FFFE.4DB138C4.DDE5D3F6.IP) (Quit: http://www.mibbit.com ajax IRC Client)
[21:44:28] *** jorendorff is now known as jorendorff_away
[21:47:25] *** Quits: reedlepee (Mibbit@9B9315E1.A6025CA.1C37C358.IP) (Quit: http://www.mibbit.com ajax IRC Client)
[21:48:00] *** Quits: Blub\w (wry@7E3BB9D.71150E1A.237AE2BA.IP) (Quit: night)
[21:49:07] *** Quits: dherman (dherman@moz-B31C6965.dsl.pltn13.sbcglobal.net) (Quit: dherman)
[21:50:14] *** Quits: lenstr (lenstr@CD7D5ABA.83A99F98.85938D85.IP) (Client exited)
[21:50:15] *** Joins: dherman (dherman@moz-B31C6965.dsl.pltn13.sbcglobal.net)
[21:50:15] *** ChanServ sets mode: +ao dherman dherman
[21:51:12] *** Joins: devbug (quassel@23AC5F12.9D950176.3655BBF5.IP)
[21:51:28] *** jorendorff_away is now known as jorendorff
[21:55:13] *** Quits: Sharp (Sharp@moz-7B61DF4.dsl.static.sonic.net) (Quit: Sharp)
[21:57:31] *** Joins: fyolnish (fyolnish@moz-3E302AAD.uqwimax.jp)
[21:58:05] <dbaupp> sp3d: https://github.com/mozilla/rust/issues/8636 for the &mut[] matching not working properly
[21:59:14] *** Quits: fyolnish (fyolnish@moz-3E302AAD.uqwimax.jp) (Ping timeout)
[22:03:52] *** Joins: fyolnish (fyolnish@moz-3E302AAD.uqwimax.jp)
[22:04:32] *** Joins: DAddYE (DAddYE@moz-98D3933F.hsd1.ca.comcast.net)
[22:06:16] *** Quits: DAddYE (DAddYE@moz-98D3933F.hsd1.ca.comcast.net) (Ping timeout)
[22:06:39] *** Joins: mib_l7rklv (Mibbit@9B9315E1.A6025CA.1C37C358.IP)
[22:07:09] <mib_l7rklv> dbaupp:ping
[22:07:20] *** Joins: tetsuharu (tetsuharu@moz-A3FEAA56.ap219.ftth.ucom.ne.jp)
[22:07:23] <mib_l7rklv> sorry its ping :)
[22:07:30] *** Quits: mib_l7rklv (Mibbit@9B9315E1.A6025CA.1C37C358.IP) (Quit: http://www.mibbit.com ajax IRC Client)
[22:07:45] *** Joins: mib_07l7wu (Mibbit@9B9315E1.A6025CA.1C37C358.IP)
[22:07:49] <dbaupp> ... pong?
[22:07:55] *** Quits: mib_07l7wu (Mibbit@9B9315E1.A6025CA.1C37C358.IP) (Quit: http://www.mibbit.com ajax IRC Client)
[22:07:56] <cmr> they parted
[22:08:00] <dbaupp> I know
[22:08:12] *** Joins: reedlepee (Mibbit@9B9315E1.A6025CA.1C37C358.IP)
[22:08:22] <reedlepee> dbaupp: ping
[22:08:39] <dbaupp> reedlepee: hi
[22:08:45] <CurlyBrace> host people.chat not found
[22:08:48] <dbaupp> reedlepee: I answered your email
[22:09:03] *** Quits: tetsuharu (tetsuharu@moz-A3FEAA56.ap219.ftth.ucom.ne.jp) (Ping timeout)
[22:09:41] <reedlepee> dbaupp: i just now saw your email 
[22:10:41] *** Quits: nif (Mibbit@moz-B6DFA19D.wireless.oberlin.edu) (Quit: http://www.mibbit.com ajax IRC Client)
[22:11:15] *** Joins: nif (Mibbit@moz-B6DFA19D.wireless.oberlin.edu)
[22:11:25] <reedlepee> dbaupp: I think before selecting any project I should learn rust .. So i am currently reading rust tutorial
[22:11:52] <dbaupp> reedlepee: yes, learning rust is very very good idea
[22:12:01] <bjz_> heh :)
[22:12:03] <dbaupp> (if you want to work on Rust)
[22:12:06] *** Quits: canhtak (jeremy@moz-830A7AA1.wl.t.ulaval.ca) (Quit: canhtak)
[22:12:31] <bjz_> reedlepee: maybe trying a small project of your own first might be a good idea?
[22:12:59] <reedlepee> at the same time i want to work on something dat's y i asked for the bug..
[22:13:02] *** Quits: eddyb (eddy@37F72125.9065A63B.FCAAE698.IP) (Ping timeout)
[22:13:06] <bjz_> maybe re-implement the basic runctionality of a unix tool or something?
[22:13:42] <CurlyBrace> anyone know the best way to do substring matching?
[22:13:56] *** Quits: Jesin (Jessin_@moz-9BB5F6CF.cc.lehigh.edu) (Quit: Leaving)
[22:14:02] <reedlepee> bjz_ : unix tool?
[22:14:16] <bjz_> reedlepee: super basic: echo
[22:14:20] <dbaupp> reedlepee: learning Rust while implementing the algorithms from the papers might be fun
[22:14:41] <bjz_> yep ^
[22:14:59] <bjz_> (whichever the 'papers' dbaup implies are)
[22:15:17] <Earnestly> echo is usually a shell builtin (and shouldn’t be used), just putting it out there.
[22:15:18] <bjz_> CurlyBrace: what do you mean by 'substring'?
[22:15:35] *** Quits: sankha93 (Instantbir@7061CD01.D6BD0D91.22D41759.IP) (Quit: Gone to save the world!)
[22:15:47] <CurlyBrace> x = "asdf"
[22:15:51] <Earnestly> Try `cat` instead or it’s close neigbour, `tac`
[22:15:55] <CurlyBrace> I want to compare against "as"
[22:16:30] <Earnestly> s/its
[22:16:42] <bjz_> rusti: match "asdf" { ["as", .._] => 1, _ => 0 }
[22:16:43] -rusti- pastebinned 7 lines of output: http://sprunge.us/LEXA
[22:17:00] <bjz_> hum :/
[22:17:43] <CurlyBrace> just being able to take a substring of another string would help now
[22:17:47] <bjz_> well you could use a function
[22:17:48] <CurlyBrace> is that what  'slice' is?
[22:17:55] <cmr> CurlyBrace: yes
[22:17:59] *** Joins: jxv (jxv@moz-B6559D27.socal.res.rr.com)
[22:18:41] <bjz_> http://static.rust-lang.org/doc/master/std/str/trait.StrSlice.html
[22:18:59] <dbaupp> CurlyBrace: http://static.rust-lang.org/doc/master/std/str/trait.StrSlice.html#tymethod.contains
[22:19:15] <bjz_> Earnestly: I'm talking about reimplementing something small, not actually *using* it
[22:19:53] <Earnestly> bjz_: Yeah fair.  I have to see many bad shell scripts so it gets my goat :p
[22:20:02] <bjz_> :)
[22:20:18] <bjz_> np
[22:22:34] <SiegeLord> I kind of wish there was some syntax for one one conditionals
[22:22:49] <SiegeLord> Like : or => or w/e
[22:24:06] *** Joins: tiffany (kawaii@moz-28A8742A.dhcp.embarqhsd.net)
[22:24:07] <dbaupp> rusti: unsafe { std::cast::transmute::<f64, [u8, .. 8]>(1.2345678) } // ktt3ja 
[22:24:07] -rusti- [93u8, 29u8, 91u8, 42u8, 202u8, 192u8, 243u8, 63u8]
[22:24:33] <dbaupp> rusti: unsafe { std::cast:transmute::<~int, *mut int>(~1234) } // ktt3ja 
[22:24:35] -rusti- pastebinned 6 lines of output: http://sprunge.us/DIPf
[22:24:49] <dbaupp> rusti: unsafe { std::cast::transmute::<~int, *mut int>(~1234) } // ktt3ja 
[22:24:49] -rusti- (0x7f647c000f50 as *mut ())
[22:25:30] <SiegeLord> I guess that's nothing a macro can't fix... sel!(a ? b : c)
[22:26:48] *** Quits: RMF (RMF@moz-A9053785.dsl.telepac.pt) (Quit: Computer has gone to sleep.)
[22:27:20] *** Quits: eatkinson (eatkinson@moz-261EDE03.hsd1.ca.comcast.net) (Ping timeout)
[22:28:54] <doomlord_> seems like you might as well just write if {}else{}
[22:28:56] <SiegeLord> Or, alternatively, make if not require a block... it could just be if <expr> <expr>
[22:30:03] <dbaupp> SiegeLord: I don't think that works without parens on the condition
[22:30:04] *** Joins: RMF (RMF@moz-A9053785.dsl.telepac.pt)
[22:30:14] <doomlord_> i do like ?  : in c.. but i'm ok with them simplifying it out with one consistent rule , "all blocks have return value.."
[22:30:47] <SiegeLord> rusti: if 1 2 { 1 }
[22:30:48] -rusti- pastebinned 6 lines of output: http://sprunge.us/hRJb
[22:31:09] <SiegeLord> I think it works in most cases
[22:31:23] <SiegeLord> rusti: if 1 (-1) { 1 }
[22:31:24] -rusti- pastebinned 10 lines of output: http://sprunge.us/RJPd
[22:31:33] <SiegeLord> Or not, nvm :P
[22:31:49] <dbaupp> SiegeLord: if true {&x} {&y} becomes `if true &x {&y}`
[22:34:01] <SiegeLord> It's so verbose, that I think when you have if,else with both branches being one lines, it's shorter to use a match
[22:34:37] <nif> does anyone have any insight on traits and generic types?  I'm still new to this and looking for a little help.
[22:34:47] <SiegeLord> dbaupp: I'm not sure what's wrong with that... :s
[22:35:10] <dbaupp> SiegeLord: it could be parsed as `if (true & x) { ... }`
[22:35:38] <dbaupp> nif: what sort of "insight" do you want?
[22:36:00] *** Quits: earlzlap (earlz@moz-9E279EAD.neo.res.rr.com) (Ping timeout)
[22:36:21] <SiegeLord> Ah... yeah, it's not actually a good idea... I'd prefer => :P
[22:36:30] *** Quits: jstevans (Instantbir@630B0C0.117F92C2.B7830B68.IP) (Ping timeout)
[22:36:55] <nif> dbaupp: I'm trying to ensure that the K of a generic <K, V> pair uses Ord, but I'm not sure what I need to do.
[22:37:37] <nif> maybe "uses" is the wrong word, too. either way, I want to have less than, greater than, etc. usable for my Ks.
[22:37:41] <dbaupp> nif: in what context is the generic?
[22:37:50] <dbaupp> on a struct? on an impl?
[22:37:54] <dbaupp> (on a trait?)
[22:38:47] <nif> dbaupp: they're part of structs (and the relevant impls to the structs).  I'm implementing a BTree.
[22:39:14] <dbaupp> nif: ah, so when you write the impl, you write `impl<K: Ord, V> BTree<K, V> { ... }`
[22:39:30] <dbaupp> or `impl<K: Ord, V> Trait for BTree<K,V> { .. }`
[22:39:47] <nif> dbaupp: okay!  cool.
[22:40:10] <nif> dbaupp: I think I had tried that but I didn't put it everywhere it was needed, so I will go back through and see where it goes.
[22:40:23] <dbaupp> nif: awesome!
[22:40:34] <nif> dbaupp: thanks for the help.  :)
[22:40:49] <dbaupp> nif: you might also want to use TotalOrd rather than Ord, since Ord doesn't guarantee that `x < y || x >= y`
[22:41:08] <dbaupp> (e.g. with floats, NaN is not  < NaN, nor is it >= NaN)
[22:41:45] <nif> dbaupp: ooh, right!  okay.  I will do that.
[22:42:00] *** Joins: mib_xi8d91 (Mibbit@9B9315E1.A6025CA.1C37C358.IP)
[22:42:06] *** Quits: mib_xi8d91 (Mibbit@9B9315E1.A6025CA.1C37C358.IP) (Quit: mib_xi8d91)
[22:42:21] *** Quits: spider-mario (spidermari@moz-81131DB6.fbx.proxad.net) (Input/output error)
[22:42:23] <dbaupp> nif: that means you'll have to use left.cmp(&right) rather than the operators
[22:43:02] <nif> dbaupp: okay.  good to know.
[22:44:41] *** Joins: krebbit (Mibbit@9B9315E1.A6025CA.1C37C358.IP)
[22:44:51] *** Quits: krebbit (Mibbit@9B9315E1.A6025CA.1C37C358.IP) (Quit: http://www.mibbit.com ajax IRC Client)
[22:45:22] *** Quits: reedlepee (Mibbit@9B9315E1.A6025CA.1C37C358.IP) (Quit: http://www.mibbit.com ajax IRC Client)
[22:45:47] *** Joins: reedlepee (Mibbit@9B9315E1.A6025CA.1C37C358.IP)
[22:46:26] *** Joins: robertknight (robertknig@moz-54528EE0.wby.mendeley.com)
[22:46:34] *** Quits: KindOne (KindOne@moz-64116AE8.dynamic.ip.windstream.net) (Ping timeout)
[22:46:34] *** Quits: tiffany (kawaii@moz-28A8742A.dhcp.embarqhsd.net) (Ping timeout)
[22:48:03] *** Quits: jensnockert (jensnocker@moz-5D53B643.cust.bredband2.com) (Input/output error)
[22:48:16] *** Quits: robertknight (robertknig@moz-54528EE0.wby.mendeley.com) (Ping timeout)
[22:48:33] *** Joins: tiffany (kawaii@moz-EB8B0C08.dhcp.embarqhsd.net)
[22:50:11] *** Joins: KindOne (KindOne@moz-58618BC7.dynamic.ip.windstream.net)
[22:50:53] *** Quits: CarpNet (Alasdair@moz-25C796BC.cable.virginm.net) (Quit: Leaving)
[22:58:47] <CurlyBrace> Thanks for the help guys
[22:58:50] *** Quits: CurlyBrace (Mibbit@moz-21083258.hsd1.va.comcast.net) (Quit: http://www.mibbit.com ajax IRC Client)
[22:58:55] *** Quits: Ferreus (ferreus@moz-596EAB7.pools.arcor-ip.net) (Ping timeout)
[23:01:26] *** Quits: ilyoan (ilyoan@B4104EBB.3CC170B1.1E14B209.IP) (Ping timeout)
[23:01:26] *** Quits: yichoi (yichoi@5AB4884B.FCC4549.14D5B978.IP) (Ping timeout)
[23:05:33] *** Quits: nsf (nsf@moz-EEF3238A.convex.ru) (Quit: WeeChat 0.4.2)
[23:05:47] *** Joins: DAddYE (DAddYE@moz-98D3933F.hsd1.ca.comcast.net)
[23:07:20] *** Joins: tetsuharu (tetsuharu@moz-A3FEAA56.ap219.ftth.ucom.ne.jp)
[23:07:34] *** Quits: DAddYE (DAddYE@moz-98D3933F.hsd1.ca.comcast.net) (Ping timeout)
[23:09:35] *** Quits: tetsuharu (tetsuharu@moz-A3FEAA56.ap219.ftth.ucom.ne.jp) (Ping timeout)
[23:10:42] *** Quits: papalazarou (papalazaro@moz-BE1C9F3F.lightspeed.frokca.sbcglobal.net) (Ping timeout)
[23:11:11] *** Quits: brianm (brianm@moz-9B7D279E.dsl.static.sonic.net) (Quit: Leaving...)
[23:12:15] *** Parts: reedlepee (Mibbit@9B9315E1.A6025CA.1C37C358.IP) ()
[23:12:24] *** Joins: Skif (emschwar@moz-4C5BB5A8.beyondbb.com)
[23:14:59] *** Quits: Skif (emschwar@moz-4C5BB5A8.beyondbb.com) (Ping timeout)
[23:17:24] *** Joins: Ferreus (ferreus@moz-596EAB7.pools.arcor-ip.net)
[23:17:48] *** Quits: donri (donri@moz-9BB61102.tbcn.telia.com) (Client exited)
[23:17:56] *** Quits: ziad (Mibbit@moz-5729CEA7.hsd1.ca.comcast.net) (Quit: http://www.mibbit.com ajax IRC Client)
[23:21:44] *** Quits: erickt (Adium@49C4075F.3AC15C18.2321E71E.IP) (Quit: Leaving.)
[23:27:55] *** jorendorff is now known as jorendorff_away
[23:28:26] *** jorendorff_away is now known as jorendorff
[23:30:11] <ercxx> does std::rt::run() start a new os thread?
[23:30:22] *** Quits: tikue_ (tikue_star@F6141FA3.3B4A6B80.689607DE.IP) (Ping timeout)
[23:30:59] *** Joins: earlzlap (earlz@moz-9E279EAD.neo.res.rr.com)
[23:31:13] *** Quits: SilverKey (SilverKey@moz-B589DA51.sw.biz.rr.com) (Quit: My MacBook Pro has gone to sleep. ZZZzzz…)
[23:31:53] <brson> ercxx: yes. it creates a thread per core or as per the RUST_THREADS env var
[23:32:25] <ercxx> how about std::rt::start() ?
[23:33:23] <brson> ercxx: yes, start just does global initialization then delegates to run
[23:33:32] <ercxx> thank you
[23:33:40] <brson> if you want to set up the runtime without any extra threads it would require some refactoring of 'run'
[23:34:25] *** Quits: squiddy (squiddy@moz-C33F1661.adsl.alicedsl.de) (Ping timeout)
[23:35:12] <ercxx> ok
[23:35:29] <earlzlap> How would one go about building rustc for an unsupported OS, like OpenBSD?
[23:35:50] *** Quits: tedh (tedh@moz-F0B37C08.hsd1.il.comcast.net) (Ping timeout)
[23:36:41] <ercxx> brson: I just saw a SO question mentioning real time stuff. The person wanted 1 task -> 1 thread so that's not happenning atm.
[23:36:53] *** Joins: tikue_ (tikue_star@F6141FA3.3B4A6B80.689607DE.IP)
[23:38:22] <brson> ercxx: having 1 thread globally is not possible at the moment, but it is possible to dedicate a thread to a task by using spawn(SingleThreaded)
[23:38:50] <brson> rust's I/O system also maintains a thread pool for various purposes
[23:38:52] <brson> so threads abound
[23:38:57] *** Joins: skade (skade@moz-A89F791B.pools.arcor-ip.net)
[23:39:09] *** Joins: tedh (tedh@moz-F0B37C08.hsd1.il.comcast.net)
[23:39:19] <ercxx> ok
[23:40:22] *** Quits: KindOne (KindOne@moz-58618BC7.dynamic.ip.windstream.net) (Ping timeout)
[23:41:33] *** Joins: brianm (brianm@moz-9B7D279E.dsl.static.sonic.net)
[23:42:10] *** sam113101 is now known as sam113101_afk
[23:43:28] *** Quits: brianm (brianm@moz-9B7D279E.dsl.static.sonic.net) (Ping timeout)
[23:44:15] *** Joins: KindOne (KindOne@moz-12CD79CD.dynamic.ip.windstream.net)
[23:56:16] <dg> i'm having some trouble with ownership, would someone be able to help me debug? http://pastebin.com/ysEspRxV 
[23:57:26] *** Joins: tautologico (shung@E14878C0.75051ED3.7B974E06.IP)
[23:57:39] <cmr> dg: what bug is there to debug?
[23:58:22] <dg> cmr: well, I'm not sure how to solve the "cannot move out of dereference of & pointer" error
[23:59:25] <cmr> dg: Self is a &T. You cannot move out of a &T because you do not own it. Either make create_from_pixels take a reference, clone self, or use some type which allows shared ownership.
[23:59:42] *** Quits: six600110 (six600110@moz-C663577C.hsd1.il.comcast.net) (Client exited)

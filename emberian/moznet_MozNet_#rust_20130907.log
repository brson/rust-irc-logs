[00:00:00] *** Quits: fyolnish (fyolnish@moz-AE42C26E.uqwimax.jp) (Ping timeout)
[00:03:37] *** Joins: jmgrosen (jmgrosen@moz-848F6087.sb.sd.cox.net)
[00:04:25] <ecr> flaper87: what if you made ActorRef a wrapper around the SharedChan<~str>? move get_channel() to be a method on Actor and call it get_ref() and return an ActorRef (just a wrapped channel). make start() a method on Actor that takes self by value (consuming the Actor). keep stop() a method on ActorRef that works as it does now, but you'll just operate on the SharedChan directly (arguably, stop() should consume the ActorRef since you can't really do a
[00:04:32] <ecr> that's what I'd do based on what I see here
[00:05:02] <ecr> calvin: which blog posts exactly?
[00:05:38] *** Quits: tjc (tjc@moz-33A2B6AA.googlewifi.com) (Ping timeout)
[00:06:25] <flaper87> ecr: mmh, sounds good, I think I had something along those lines before I started playing with this. Thanks for the advice, I'll do it and share the results
[00:06:47] <ecr> flaper87: good luck :)
[00:06:53] *** Joins: jclements_ (jclements@moz-E4774872.dsl.snlo01.pacbell.net)
[00:09:09] *** Quits: miza (miza@moz-4DD51325.home.otenet.gr) (Input/output error)
[00:11:22] <calvin> http://calvinmetcalf.com
[00:11:26] <calvin> adventures in rust
[00:11:27] *** Joins: tjc (tjc@moz-96763409.tmodns.net)
[00:11:27] *** ChanServ sets mode: +o tjc
[00:13:12] <calvin> http://www.reddit.com/r/rust/comments/1lszyq/adventures_in_rust_part_ii_modules_and_control/
[00:13:47] *** Joins: tikue_ (tkuehn@DB1DCCAA.EB08480C.689607DE.IP)
[00:14:02] <ecr> calvin: neat! looks like I have some reading to do :)
[00:16:07] <calvin> I've been trying to learn rust out loud
[00:16:13] *** Joins: eatkinson (eatkinson@moz-DC7CD72F.airbears2.berkeley.edu)
[00:16:33] <flaper87> calvin: that's the best way to do it
[00:16:38] *** Quits: Infiltrator (Infiltrato@4669028E.25A9890C.4B4F1E7A.IP) (Ping timeout)
[00:17:14] *** Joins: Infiltrator (Infiltrato@4669028E.25A9890C.4B4F1E7A.IP)
[00:17:18] *** Quits: nkoep (nik@moz-B3D6DFF0.vpn.rwth-aachen.de) (Client exited)
[00:19:33] *** Quits: Ralith (ralith@A8995AA9.62B6AF6A.922221DB.IP) (Ping timeout)
[00:19:57] *** Quits: ecr (Thunderbir@moz-BBE3ABD.mv.mozilla.com) (Quit: ecr)
[00:21:56] *** Joins: jstevans (Instantbir@moz-F3C02489.bootp.virginia.edu)
[00:21:56] *** Quits: jstevans1 (Instantbir@moz-F3C02489.bootp.virginia.edu) (Connection reset by peer)
[00:22:12] *** Quits: enix (enix@moz-A50569DD.c3-0.slvr-ubr1.lnh-slvr.md.cable.rcn.com) (Quit: Konversation terminated!)
[00:24:27] *** Joins: bytbox (s@moz-F125BB72.apng.wireless-pennnet.upenn.edu)
[00:24:52] *** Quits: brendan (brendaneic@moz-BE33DA21.fw1.sfo1.mozilla.net) (Quit: brendan)
[00:27:45] *** Joins: brendan (brendaneic@moz-BE33DA21.fw1.sfo1.mozilla.net)
[00:28:08] *** Quits: DAddYE (DAddYE@moz-61EB081B.hfc.comcastbusiness.net) (Client exited)
[00:29:05] <clements> dear michael woerister: you write awesome comments. Many thanks.
[00:30:29] <calvin> if I am generating ints in an random (ish) order and then need them in a sequetial order... smallintmap the way to go? hashset seams REALLY slow and hashmap a bit slower
[00:31:06] *** Quits: brendan (brendaneic@moz-BE33DA21.fw1.sfo1.mozilla.net) (Quit: brendan)
[00:31:49] *** Joins: jgilbert_ (jgilbert@moz-7B0110AD.mv.mozilla.com)
[00:31:59] *** Quits: jgilbert (jgilbert@moz-7B0110AD.mv.mozilla.com) (Ping timeout)
[00:33:46] *** Quits: jgilbert_ (jgilbert@moz-7B0110AD.mv.mozilla.com) (Ping timeout)
[00:33:58] *** Joins: jgilbert (jgilbert@moz-7B0110AD.mv.mozilla.com)
[00:35:16] *** Quits: mark_edward (quassel@moz-97E995A.hsd1.in.comcast.net) (Ping timeout)
[00:37:46] *** Quits: jfbk (jfbk@moz-EEA9CFB3.nyc.res.rr.com) (Quit: )
[00:37:59] <jmgrosen> is there a way to just recompile libsyntax?
[00:38:46] *** Quits: wilsonk-laptop (kvirc@moz-8E86F35A.cg.shawcable.net) (Connection reset by peer)
[00:38:59] *** Joins: wilsonk-laptop (kvirc@moz-8E86F35A.cg.shawcable.net)
[00:39:02] <engla> jmgrosen: you can compile the crate file manually
[00:39:07] <engla> jjja
[00:39:18] <jmgrosen> ok
[00:39:29] <engla> oops
[00:40:05] <engla> calvin: hashset doesn't have any order, but treeset has
[00:43:05] <clements> jmgrosen: if you're doing development work on libsyntax (or any of the rust crates), I *highly* recommend writing unit tests and just using rust test syntax.rs
[00:43:17] *** Quits: eatkinson (eatkinson@moz-DC7CD72F.airbears2.berkeley.edu) (Quit: eatkinson)
[00:43:34] <jmgrosen> clements: huh, that's a good idea; thanks!
[00:43:40] *** Quits: io2 (io2@moz-A6202C16.home.otenet.gr) (Quit: )
[00:44:24] <calvin> so if you iterate it it comes out in a random order ?
[00:46:02] <engla> calvin: the hashset? well at least arbitrary order
[00:46:30] *** Quits: jdm (jdm@FCCEA34F.7672369.D8E68FF6.IP) (Quit: Lost terminal)
[00:46:41] <engla> but in the case of this implementation we can say random order, at least if you have elements A, B, C ; every time you put them in a new hashset, they will iterate out in a new random order
[00:47:01] <engla> because every hashmap/set has its own key for the hash function
[00:47:45] <engla> own random key
[00:48:15] <calvin> ah, so that's out but that vs say smallintmap/hashmap with values of 1
[00:48:25] *** Quits: jclements_ (jclements@moz-E4774872.dsl.snlo01.pacbell.net) (Quit: jclements_)
[00:50:12] *** Quits: jstevans (Instantbir@moz-F3C02489.bootp.virginia.edu) (Ping timeout)
[00:50:14] *** Quits: heftig (heftig@moz-2345FF9F.dip0.t-ipconnect.de) (Ping timeout)
[00:51:37] <engla> values of 1?
[00:51:50] <engla> treeset in extra::treemap is an ordered set
[00:52:33] *** Quits: tjc (tjc@moz-96763409.tmodns.net) (Ping timeout)
[00:53:27] <calvin> 1u jus tputting a value into the map
[00:55:11] *** Quits: bent (chatzilla@moz-932324BF.hsd1.ca.comcast.net) (Quit: ChatZilla 0.9.90.1-rdmsoft [XULRunner 22.0/20130619132145])
[00:55:21] <calvin> that is faster https://github.com/calvinmetcalf/simplify-rs/commit/a161212e841dbea2cb21a47b34157bf1a05dc7ab
[00:55:30] <tikue_> does iter().map(|&x| x) work for things that are not implicitly cloneable?
[00:55:41] *** Quits: riley (riley@8BA43816.9AA11D69.65DDFA89.IP) (Client exited)
[00:56:00] *** Joins: ghrust (ghrust@24260B07.6A2AE50.F3114085.IP)
[00:56:00] <ghrust> 01[13rust01] 15bors merged 06auto into 06master: 02http://git.io/gnqpdg
[00:56:00] *** Parts: ghrust (ghrust@24260B07.6A2AE50.F3114085.IP) ()
[00:56:31] <cmr> tikue_: I don't think so, no.
[00:56:35] <engla> tikue_: implicitly copyable no
[00:56:43] <cmr> rusti is still gone :(
[00:56:50] *** Joins: heftig (heftig@moz-6548E3EC.dip0.t-ipconnect.de)
[00:56:57] <engla> yeah
[00:57:02] <tikue_> cmr, engla: and only builtins are implicitly cloneable right? i.e. there's no way to make something i create implicitly cloneable
[00:57:10] <tikue_> cmr: i know and my rust isn't currently built :\
[00:57:29] <engla> tikue_: generic types are not implicitly clonable and there is no trait for it
[00:57:40] <engla> tikue_: but normal types you define will be if their components are
[00:57:48] <tikue_> in that case i petition for a clone_iter(), which would only be redundant if iter().map(|&x| x) worked generally
[00:57:59] <tikue_> engla: oh really? i did not know that
[00:58:09] <engla> for example   struct X<'self> { iter: CharIterator<'self>, v: int }    this is implicitly copyable
[00:58:12] *** Quits: SiegeLord (sl@moz-CAF07B4C.hsd1.ma.comcast.net) (Connection reset by peer)
[00:58:14] <engla> because CharIterator and v is
[00:58:18] *** Joins: tjc (tjc@moz-6EB4E533.dsl.tsoft.com)
[00:58:18] *** ChanServ sets mode: +o tjc
[00:58:19] <tikue_> that's cool
[00:59:05] *** Joins: Houm (Houm@moz-25669AA8.fbx.proxad.net)
[00:59:37] <tikue_> is that documented somewhere? it's a really useful thing to know
[01:00:21] *** Joins: SiegeLord (sl@moz-CAF07B4C.hsd1.ma.comcast.net)
[01:00:39] <dbaupp> tikue_: don't think so (https://github.com/mozilla/rust/issues/7774)
[01:00:51] <tikue_> dbaupp: thank you :)
[01:01:43] <tikue_> dbaupp: any ~Struct has a destructor right?
[01:01:46] <SiegeLord> How do you build rustc with debug symbols? ./configure --enable-debug?
[01:02:26] <dbaupp> tikue_: yes, ~ has a dtor that calls free
[01:02:31] <dbaupp> SiegeLord: yes
[01:02:33] <cmr> SiegeLord: rustc can't be built with debuginfo.
[01:02:38] <cmr> that's just debug! logging
[01:02:40] *** Joins: jdsanders (Adium@moz-84CB7548.hlrn.qwest.net)
[01:02:44] <dbaupp> (oh, right)
[01:02:58] <SiegeLord> All of rustc?
[01:02:58] <cmr> dbaupp: considering *you* implemented that, you should know :P
[01:03:13] <cmr> I think libstd might be able to build with debuginfo
[01:03:15] <SiegeLord> I guess I'm only interested in librustc
[01:03:16] <cmr> but besides that yeah, nothing.
[01:03:18] * dbaupp just followed pcwalton's instructions
[01:03:27] * dbaupp is a robot-coder
[01:03:29] <tikue_> ok, so I think that clone_iter() could potentially be very useful, because it handles cases for things not implicitly cloneable
[01:03:34] *** Quits: jmgrosen (jmgrosen@moz-848F6087.sb.sd.cox.net) (Ping timeout)
[01:03:44] <dbaupp> tikue_: on vec?
[01:03:49] <SiegeLord> That's a bummer... maybe I should stick a whole bunch of debugging statements everywhere...
[01:03:54] <tikue_> dbaupp: and &[T] 
[01:03:59] <SiegeLord> Is it possible to build just rustc and nothing else?
[01:04:17] <dbaupp> tikue_: ... it would be better to have .clone_each(), because a lot of things yield &T (basically any container iterator)
[01:04:53] <dbaupp> (that is, as an adaptor, <T: Clone> Iterator<&T>.clone_each() -> Iterator<T>, if you'll ignore my abuse of notation)
[01:05:16] <engla> and by clone each you mean deref &T to T ah
[01:05:27] <engla> because clone on &T yields &T too :)
[01:05:31] <dbaupp> right
[01:06:00] <tikue_> that seems confusing though
[01:06:09] <tikue_> or at least unintuitive
[01:06:23] *** Quits: Sorella (queen@9D963F5D.DF5D8AE7.54BCAB54.IP) (Quit: G'night everynyan~!)
[01:06:25] <dbaupp> but having yet another iterator method on [] would be worse, if it was only implemented on vec.
[01:06:31] <tikue_> i guess it's not useful since you can just do map(|x| x.clone())
[01:06:33] <tikue_> i take it all back
[01:06:36] <engla> yes clone is a special case because there is a need to be able to clone &T pointers
[01:06:50] <dbaupp> ("why doesn't deque have .clone_iter()? why doesn't HashSet have .clone_iter()? ..."
[01:06:51] <dbaupp> )
[01:06:56] <tikue_> right
[01:07:08] <tikue_> ok, i'm persuaded
[01:07:08] <engla> dbaupp: we would implement them quickly though
[01:07:14] <engla> but it would grow the forest of iterators
[01:07:21] <engla> iterator methods
[01:07:28] <tikue_> engla: is it worth it when you can just do iter().map(|x| x.clone())
[01:07:31] <dbaupp> engla: yeah, that's why I mean.
[01:07:36] <dbaupp> *what
[01:07:52] <dbaupp> 1 adaptor, or n new iterators methods.
[01:07:58] * dbaupp prefers the former
[01:08:00] <engla> tikue_: borderline. I don't particularly enjoy typing ()|x| a lot
[01:08:30] <engla> but that might be a trait I need to de-implement
[01:08:31] *** Quits: jdsanders (Adium@moz-84CB7548.hlrn.qwest.net) (Ping timeout)
[01:08:41] <tikue_> engla: neither do i, butâ€¦without iter() it's more reasonable imo
[01:09:03] <engla> yes
[01:09:05] <dbaupp> (some keyboards are particularly bad for typing `|` and other weird symbols like that.)
[01:09:19] <tikue_> dbaupp: prefer an adaptor you mean?
[01:09:20] <engla> I have modifed my keyboard layout a bit though
[01:09:44] <tikue_> i would enjoy an adaptor as long as it wasn't clone_each() because that's confusing since &T.clone() -> &T
[01:09:56] <dbaupp> clone_deref() or something
[01:09:57] <dbaupp> ?
[01:10:05] * dbaupp is particularly bad at naming things
[01:10:54] <tikue_> something like clone_deref() would be palatable i think
[01:11:03] <tikue_> or deref_clone
[01:12:06] <tikue_> clone_deref() is 13 chars and map(|x| x.clone()) is 18. not much of a difference.
[01:12:47] <dbaupp> but ( and | are awkward to type, so keeping it all alphabetic is nice; but i'm not particularly fussed either way
[01:12:58] <tikue_> likewise
[01:13:16] *** flaper87 is now known as flaper87|afk
[01:13:53] <tikue_> would an iterable trait essentially have the default methods fn foo(&self) { self.iter().foo() }
[01:14:09] <dbaupp> basically, yes
[01:14:31] <tikue_> that seems like somethign that could be implemented now, even if there is not yet syntax support for `for pat in vec`
[01:14:36] <tikue_> or rather `for pat in iterable`
[01:15:11] *** Joins: jstevans (Instantbir@moz-F3C02489.bootp.virginia.edu)
[01:15:36] <tikue_> i suppose the issue with that is it would exclude iterators from implementing iterable
[01:15:38] <dbaupp> there are certain tricky points (e.g. I don't think one can make Iterators Iterable.), but probably
[01:15:43] <dbaupp> yeah
[01:15:45] <tikue_> hivemind
[01:16:08] <dbaupp> heh
[01:16:18] <dbaupp> also, http://domenic.me/2013/09/06/es6-iterators-generators-and-iterables/ everyone has iterators now! \o/
[01:16:50] <tikue_> :) i suppose there isn't much reason for iterators to be `iterable` -- the only reason that comes to mind is that it's "weird" that they wouldn't be
[01:17:04] <tikue_> because the for syntax could simply look for Iterator OR Iterable
[01:17:04] *** Quits: glyc (Mibbit@moz-20CEEF38.hsd1.ca.comcast.net) (Quit: http://www.mibbit.com ajax IRC Client)
[01:18:29] *** Quits: josh (josh@moz-348C4790.hsd1.mn.comcast.net) (Quit: josh)
[01:18:47] * tikue_ wants rustic generators >:)
[01:18:50] *** Joins: josh (josh@moz-348C4790.hsd1.mn.comcast.net)
[01:19:18] *** Quits: lmandel (lmandel@moz-76CE9D51.cable.teksavvy.com) (Ping timeout)
[01:20:10] *** Joins: eatkinson (eatkinson@moz-DC7CD72F.airbears2.berkeley.edu)
[01:21:55] <engla> I think iterators need to be iterable
[01:22:15] <tikue_> engla: to what end?
[01:22:26] <dbaupp> yeah, unfortunately for is currently just a syntax extension, so it can't examine types; but it needs to move deeper anyway (the error messages suck) so presumably that type-based stuff can happen then.
[01:22:45] <engla> that's half the purpose of the trait, so that functions can be declared to take an iterable
[01:23:34] <engla> for example the extend method. Should be able to do both  v.extend(range(..)) and v.extend(u.iter().map(.. ugh))
[01:24:10] <tikue_> engla: those are both iterators
[01:24:17] <engla> oops
[01:24:20] <engla> v.extend(u)
[01:24:31] <tikue_> yeah that's a really good point.
[01:24:57] <tikue_> what if iterators just implemented iter :\
[01:25:16] *** Joins: lmandel (lmandel@moz-76CE9D51.cable.teksavvy.com)
[01:25:21] <tikue_> fn iter(self) -> FooIterator { self }
[01:25:38] <tikue_> though that's pretty hacky i admit
[01:26:19] *** Quits: eatkinson (eatkinson@moz-DC7CD72F.airbears2.berkeley.edu) (Quit: eatkinson)
[01:26:56] *** Quits: lmandel (lmandel@moz-76CE9D51.cable.teksavvy.com) (Ping timeout)
[01:27:13] <tikue_> there is a line i was looking at in glob.rs that is basically `for ti in range(i, self.tokens.len()) { let token = self.tokens[ti]; /* do stuff with token */ }`
[01:27:20] <dbaupp> nmatsakis: btw, there are some issues you may (or not) have seen that are probably caused by the repeated NodeIds: https://github.com/mozilla/rust/issues/7971, https://github.com/mozilla/rust/issues/6304, https://github.com/mozilla/rust/issues/8367 (those all look kinda the same), https://github.com/mozilla/rust/issues/8754, https://github.com/mozilla/rust/issues/8852
[01:27:42] *** Joins: lmandel (lmandel@moz-104CC309.mv.mozilla.com)
[01:27:54] <dbaupp> tikue_: that looks like it should be `for token in self.tokens.slice_from(i).iter() { ... }`
[01:27:56] <tikue_> and i thought hm, that'd look better using enumerate. but it actually doesn't. it ends up looking like `for (ti, token) in self.tokens.slice_from(i).iter().map(|x| x.clone()).enumerate() {`
[01:28:05] <tikue_> dbaupp: yes but look at the mess
[01:28:25] <dbaupp> for &token in ... { .. } I guess, since it's presumably implicitly copyable
[01:28:28] <tikue_> dbaupp: doesn't work
[01:28:40] <dbaupp> oh :(
[01:28:44] <tikue_> it's not implicitly copyable :\ cuz one of the enum variants is Foo(~[char])
[01:28:57] <dbaupp> how does let self.tokens[ti] work then? :S
[01:29:06] <dbaupp> doesn't that move self.tokens
[01:29:08] <dbaupp> ?
[01:30:04] <ww> question: for object serialization, should i use the extra::serialize? or the std::serialization?
[01:30:08] <tikue_> dbaupp: i'm not sure
[01:30:31] <engla> ww: I don't thinnk the latter exists
[01:30:47] <ww> ok, i'm probably looking at the old doc
[01:31:02] <cmr> which docs *are* you looking at?
[01:31:11] <ww> so go with extra:: serialize::Encoder Decoder?
[01:31:18] <cmr> In the ~5 months I've been with the project I've never seen std::serialization
[01:31:25] <ww> 0.4 doc
[01:31:29] <cmr> oh
[01:31:32] <ww> haha
[01:31:40] <cmr> so yeah, a year old :P
[01:31:44] <ww> i just google rust serialization and it's the first thing comes up
[01:32:32] <engla> ww: extra::serialize is just the interface, there are two implementations in extra ebml and json. 
[01:33:07] <ww> i see.  is there one implementation that serializes to bytes?  [u8]?
[01:33:32] *** Quits: tikue_ (tkuehn@DB1DCCAA.EB08480C.689607DE.IP) (Ping timeout)
[01:33:51] *** Quits: jstevans (Instantbir@moz-F3C02489.bootp.virginia.edu) (Ping timeout)
[01:33:52] *** Joins: MrByte (MrByte@moz-147070D0.chy-wy.client.bresnan.net)
[01:33:52] *** Joins: tikue_ (tkuehn@DB1DCCAA.EB08480C.689607DE.IP)
[01:34:16] *** Quits: doomlord (doomlod@moz-13E69BC8.range86-180.btcentralplus.com) (Ping timeout)
[01:34:21] *** Joins: Jesin (Jessin_@moz-130D8933.cc.lehigh.edu)
[01:34:25] *** Quits: bjz (brendanzab@B398BE78.F804C29E.D35A31DF.IP) (Quit: Bye!)
[01:34:33] *** Joins: bjz (brendanzab@B398BE78.F804C29E.D35A31DF.IP)
[01:35:11] <tikue_> dbaupp: it never does let token = self.tokens[ti]; it uses it in two places and both are match expressions
[01:35:29] <engla> I don't know ww 
[01:35:34] <tikue_> so it looks like match self.tokens[ti] { â€¦. _ => { match self.tokens[ti] { â€¦ } } }
[01:36:10] *** Joins: Ralith (ralith@114DA04D.CD83ED0A.BCDF04A6.IP)
[01:36:21] <ww> ok, thanks.  i'll look for it
[01:36:36] *** Quits: lmandel (lmandel@moz-104CC309.mv.mozilla.com) (Quit: lmandel)
[01:37:06] <tikue_> i could put a pr in, it's only a 3 line change though
[01:37:41] *** Quits: calvin (calvin@moz-468348D6.hsd1.ma.comcast.net) (Quit: leaving)
[01:38:24] *** Joins: Cromulent (Cromulent@moz-983B638D.cable.virginmedia.com)
[01:42:31] <dbaupp> tikue_: ah! I guess all the branches use `ref` or are implicitly copyable
[01:42:34] * dbaupp understands
[01:42:56] <tikue_> dbaupp: yeah i think that's what's going on
[01:43:16] *** Joins: jmgrosen (jmgrosen@moz-848F6087.sb.sd.cox.net)
[01:43:27] <tikue_> i think it's probably better to use the enumerate() even though it's kind of long and icky
[01:43:44] <tikue_> idk
[01:44:13] <dbaupp> tikue_: I think `for token in tokens.iter() { match *token { ... } }` should work
[01:44:17] <dbaupp> (and is better, yeah)
[01:44:28] <tikue_> dbaupp: yeah that works too
[01:44:41] <dbaupp> (plus whatever .slice_from-ing and enumerate-ing is required, I guess)
[01:44:48] <dbaupp> <3 iterators
[01:44:54] <tikue_> :) me2
[01:45:15] *** Quits: brson (brson@moz-BBE3ABD.mv.mozilla.com) (Ping timeout)
[01:45:48] *** Quits: mihneadb (Mihnea@moz-BE33DA21.fw1.sfo1.mozilla.net) (Quit: Leaving)
[01:46:05] <tikue_> dbaupp: r? https://github.com/mozilla/rust/pull/9030
[01:47:10] *** Quits: ww (Mibbit@moz-7385AD13.dia.static.qwest.net) (Quit: http://www.mibbit.com ajax IRC Client)
[01:47:19] <dbaupp> tikue_: commented
[01:47:20] *** jack|dinner is now known as jack
[01:48:31] <tikue_> dbaupp: can you explain? i'm not sure i follow the logic
[01:48:48] <tikue_> self.tokens.slice_from(i) will give u the ith to the len() - 1th
[01:48:59] <engla> yeah the new ti is not the same as the old
[01:49:04] *** Joins: SingingBoyo (brandon@4DF3381A.51F4D838.4F048BDC.IP)
[01:49:20] <dbaupp> tikue_: range(i, len) = (i, i+1, ..., len-1); tokens.slice_from(i).enumerate() == (0, 1, 2, ..., len - i)
[01:49:41] *** Joins: brson (brson@6A848D32.C1B840DD.76F66111.IP)
[01:49:41] *** ChanServ sets mode: +ao brson brson
[01:49:42] <dbaupp> (len - i - 1, I guess)
[01:49:54] <tikue_> oh wow, good point
[01:50:15] <engla> .enumerate() can be confusing
[01:50:56] <engla> say rev_iter().enumerate()  or indeed slice().enumerate
[01:51:30] <tikue_> ti is only used in one place
[01:51:45] <tikue_> ti + i + 1
[01:51:50] <dbaupp> nah, ti + i
[01:52:00] <dbaupp> (unless, it's already ti + 1 ?)
[01:52:06] <tikue_> yeah it's currently ti + 1
[01:52:36] <tikue_> or i can add a map
[01:52:38] <tikue_> :P 
[01:53:01] <tikue_> |(ti, token)| (ti + i, token)
[01:53:18] <dbaupp> if it's only used once, just adjust that spot
[01:53:23] <tikue_> kk
[01:53:34] <tikue_> well once per iteration presumably
[01:53:41] <tikue_> at most* once per iteration
[01:53:51] *** Quits: josh (josh@moz-348C4790.hsd1.mn.comcast.net) (Quit: josh)
[01:55:37] *** Quits: maxli (maxli@moz-6EADA619.cpe.net.cable.rogers.com) (Quit: Leaving.)
[01:55:42] *** Quits: FrozenCow (FrozenCow@moz-B2DF4929.chello.nl) (Ping timeout)
[01:56:26] <tikue_> updated, dbaupp, thank you for the reality check
[01:56:48] <dbaupp> r+
[01:59:13] <tikue_> thx :)
[01:59:15] *** Quits: tikue_ (tkuehn@DB1DCCAA.EB08480C.689607DE.IP) (Quit: tikue_)
[01:59:23] *** Quits: hjr3 (hradtke@1A0AE795.28A5F6C3.A2D40ED2.IP) (Quit: My MacBook has gone to sleep. ZZZzzzâ€¦)
[02:01:04] *** Joins: ghrust (ghrust@79968228.6A2AE50.F3114085.IP)
[02:01:05] <ghrust> 01[13rust01] 15bors pushed 0 new commits to 06auto: 02http://git.io/ixGsVw
[02:01:05] *** Parts: ghrust (ghrust@79968228.6A2AE50.F3114085.IP) ()
[02:01:08] <jmgrosen> how do I use quasiquoting in a syntax extension?
[02:03:28] *** Quits: jgilbert (jgilbert@moz-7B0110AD.mv.mozilla.com) (Ping timeout)
[02:05:34] *** Quits: tjc (tjc@moz-6EB4E533.dsl.tsoft.com) (Quit: zzzzzzzzzz)
[02:06:44] *** Joins: tjc (tjc@moz-6EB4E533.dsl.tsoft.com)
[02:06:44] *** ChanServ sets mode: +o tjc
[02:07:15] <dbaupp> jmgrosen: iirc, you write something like `quote_expr!(cx, $foo + 1)` (where `foo` is a local variable that's an @Expr too, and cx is an ExtCtxt)
[02:07:41] <dbaupp> (and that'll give you an @Expr, and similarly for quote_item, etc.)
[02:07:43] *** Quits: Cromulent (Cromulent@moz-983B638D.cable.virginmedia.com) (Quit: KVIrc 4.2.0 Equilibrium http://www.kvirc.net/)
[02:07:59] <jmgrosen> dbaupp: ah, cool
[02:08:07] *** Quits: dave1629 (dave@moz-17578A1A.hsd1.va.comcast.net) (Quit: dave1629)
[02:08:30] <dbaupp> jmgrosen: I could easily be wrong, though
[02:08:34] <jmgrosen> ok :P
[02:08:37] <acrichto> dbaupp: wait, you can create compiler asts with quote_expr!() ?
[02:08:52] <dbaupp> acrichto: kinda maybe? I've never used it
[02:09:00] <acrichto> that would make ifmt so much prettier
[02:09:02] * dbaupp just uses syntax::ext::build::AstBuilder
[02:09:13] <acrichto> yeah, it's so verbose though :(
[02:09:17] <dbaupp> yeah :(
[02:09:51] <dbaupp> jmgrosen: (as I said, I've never used it; so I'm likely to be saying untrue things)
[02:10:11] *** Quits: q66 (q66@6EE9DE40.46454B5D.33AABD5F.IP) (Quit: Leaving)
[02:10:21] <jmgrosen> dbaupp, well, how do you use AstBuilder? :3
[02:12:20] *** Joins: jstevans (Instantbir@moz-F3C02489.bootp.virginia.edu)
[02:13:14] *** Quits: azakai (alon@moz-BBE3ABD.mv.mozilla.com) (Ping timeout)
[02:13:40] *** Joins: dave1629 (dave@moz-17578A1A.hsd1.va.comcast.net)
[02:16:15] *** Joins: azita (Azita@moz-C1FB2A8.hsd1.ca.comcast.net)
[02:17:12] *** Quits: jmgrosen (jmgrosen@moz-848F6087.sb.sd.cox.net) (Quit: jmgrosen)
[02:17:20] *** Quits: jclements (jclements@moz-9C0ABCFC.wireless.calpoly.edu) (Ping timeout)
[02:17:47] *** Joins: jclements (jclements@moz-9C0ABCFC.wireless.calpoly.edu)
[02:18:13] *** Quits: mindcat_ (root@3F395A48.DE7505BB.291A146C.IP) (Ping timeout)
[02:18:17] *** Joins: z0w0 (zack@moz-74A8B350.lnse4.cha.bigpond.net.au)
[02:18:40] *** Quits: dave1629 (dave@moz-17578A1A.hsd1.va.comcast.net) (Quit: dave1629)
[02:21:24] *** jorendorff_away is now known as jorendorff
[02:22:24] *** Quits: zz_kimundi (kimundi@moz-FA4E113C.dip0.t-ipconnect.de) (Ping timeout)
[02:26:06] *** Joins: Jesse_ (jruderman@moz-BBE3ABD.mv.mozilla.com)
[02:26:07] *** Joins: zz_kimundi (kimundi@moz-F1E531D4.dip0.t-ipconnect.de)
[02:26:35] *** zz_kimundi is now known as kimundi
[02:26:42] *** Quits: Jesse (jruderman@moz-BBE3ABD.mv.mozilla.com) (Connection reset by peer)
[02:26:50] *** Quits: z0w0 (zack@moz-74A8B350.lnse4.cha.bigpond.net.au) (Client exited)
[02:26:51] *** Quits: azita (Azita@moz-C1FB2A8.hsd1.ca.comcast.net) (Quit: azita)
[02:27:00] <ChrisMorgan> My attempt to compile Rust with ./configure --target-triples=arm-unknown-linux-gnueabi didn't work :-(. ICE in compiling stage1 librustc.so for x86_64.
[02:27:24] *** Joins: z0w0 (zack@moz-74A8B350.lnse4.cha.bigpond.net.au)
[02:27:29] <ChrisMorgan> brson: why the Expire header change from Tm back to ~str?
[02:28:06] <dbaupp> ChrisMorgan: file a bug?
[02:28:24] <ChrisMorgan> dbaupp: I will, just trying it again first.
[02:28:35] <ChrisMorgan> Then it can get the new A-ARM tag :-)
[02:29:37] <dbaupp> :)
[02:29:52] *** Joins: dave1629 (dave@moz-17578A1A.hsd1.va.comcast.net)
[02:29:55] <dbaupp> (also, I think host-triples might be relevant if you're trying to run rustc on arm?)
[02:30:09] *** Quits: dave1629 (dave@moz-17578A1A.hsd1.va.comcast.net) (Quit: dave1629)
[02:30:26] <ChrisMorgan> This is still on my x86_64 machineâ€”it hasn't got far enough to let me build rustc for arm.
[02:31:14] <dbaupp> I thought that host-triples would build a rustc that runs on that host (presumably this happens as the last step of the bootstrap), but I dunno
[02:33:02] <ChrisMorgan> I believe that means it'll build the _libraries_ for that platform, but not rustc. I'll find out... if it works.
[02:33:24] *** Quits: bytbox (s@moz-F125BB72.apng.wireless-pennnet.upenn.edu) (Ping timeout)
[02:36:26] *** Joins: bytbox (s@moz-F125BB72.apng.wireless-pennnet.upenn.edu)
[02:38:41] <ChrisMorgan> ! "task <unnamed> failed at 'failure in fork: Cannot allocate memory', /home/chris/vc/arm-rust/src/libstd/run.rs:662"
[02:38:51] *** Joins: Larry (larryfox@26EE99DC.88C61CC9.ECED8BE3.IP)
[02:38:59] <ChrisMorgan> And that's what's making my build fail?
[02:39:45] *** Joins: echristo (echristo@moz-1892C634.hsd1.ca.comcast.net)
[02:40:52] <ChrisMorgan> I reckon at that point my machine had at least half a gigabyte of RAM left unused. Is that a genuine memory allocation problem, or a bug?
[02:41:11] *** Joins: enix (enix@moz-A50569DD.c3-0.slvr-ubr1.lnh-slvr.md.cable.rcn.com)
[02:45:19] *** Joins: azita (Azita@moz-C1FB2A8.hsd1.ca.comcast.net)
[02:48:42] <ChrisMorgan> But still... why would fork() be failing thus?
[02:49:48] *** Joins: dave1629 (dave@moz-17578A1A.hsd1.va.comcast.net)
[02:51:06] *** Quits: Jesse_ (jruderman@moz-BBE3ABD.mv.mozilla.com) (Quit: Jesse_)
[02:54:40] *** Quits: MrFahrenheit (RageOfThou@3FEF494C.29C984D5.783DEDCA.IP) (Ping timeout)
[02:55:00] *** Joins: pheleas_frog (Mibbit@moz-1E63D6FD.eb.protectedgroup.com)
[02:55:05] *** Quits: pheleas_frog (Mibbit@moz-1E63D6FD.eb.protectedgroup.com) (User has been banned from Mozilla (no spamming here))
[02:56:54] <benh> ChrisMorgan: That vaguely sounds like overcommit is off, so fork() needs as much free memory as that process currently has mapped, even though it's probably not gonna use any of it
[02:57:12] *** Quits: SingingBoyo (brandon@4DF3381A.51F4D838.4F048BDC.IP) (Ping timeout)
[02:57:17] <ChrisMorgan> If that were the case, I guess it wouldn't have enough spare memory.
[02:57:29] *** Joins: robertknight (robertknig@moz-54528EE0.wby.mendeley.com)
[02:58:31] *** Joins: SingingBoyo (brandon@4DF3381A.51F4D838.4F048BDC.IP)
[02:58:59] *** Quits: tjc (tjc@moz-6EB4E533.dsl.tsoft.com) (Quit: zzzzzzzzzz)
[02:59:09] *** Quits: robertknight (robertknig@moz-54528EE0.wby.mendeley.com) (Ping timeout)
[02:59:39] <SiegeLord> Is there a way to dump the uncompressed metadata?
[03:00:13] <acrichto> SiegeLord: I've heard of a mystical rustc --ls, but it's not like a pretty-printed xml document
[03:01:43] <SiegeLord> That just shows me the create attributes
[03:01:50] *** Joins: tjc (tjc@moz-6EB4E533.dsl.tsoft.com)
[03:01:50] *** ChanServ sets mode: +o tjc
[03:01:59] * ChrisMorgan closes just about everything and tries building rust again
[03:02:18] <SiegeLord> *crate
[03:02:51] <SiegeLord> Not 100% sure where it is in the code either...
[03:04:41] <acrichto> SiegeLord: oh nvmd then :(
[03:06:01] *** Joins: ghrust (ghrust@DE823A67.6A2AE50.F3114085.IP)
[03:06:01] <ghrust> 01[13rust01] 15bors merged 06auto into 06master: 02http://git.io/xX9_cg
[03:06:01] *** Parts: ghrust (ghrust@DE823A67.6A2AE50.F3114085.IP) ()
[03:06:32] *** Quits: dave1629 (dave@moz-17578A1A.hsd1.va.comcast.net) (Quit: dave1629)
[03:07:04] <ChrisMorgan> Hmm, it worked, reaching peak memory consumption of 45% (about 1.8GB). It'd be good if the fork() call's "Cannot allocate memory" error were printed normally, rather than suppressing it and just showing the ICE message.
[03:08:53] *** Joins: ross (ross@moz-5EA04060.br.br.cox.net)
[03:09:38] *** Joins: jmgrosen (jmgrosen@moz-848F6087.sb.sd.cox.net)
[03:10:06] *** Joins: josh (josh@moz-348C4790.hsd1.mn.comcast.net)
[03:10:25] <ChrisMorgan> I guess I can still file an issue about that :-)
[03:10:56] <benh> I found https://github.com/mozilla/rust/issues/5772 but that might just be the regular kind of out-of-memory problem
[03:10:57] * ChrisMorgan wishes building rust was a multi-core affair.
[03:10:58] *** Joins: ghrust (ghrust@DE823A67.6A2AE50.F3114085.IP)
[03:10:58] <ghrust> 01[13rust01] 15bors pushed 0 new commits to 06auto: 02http://git.io/rGgxKA
[03:10:58] *** Parts: ghrust (ghrust@DE823A67.6A2AE50.F3114085.IP) ()
[03:11:00] *** Joins: ghrust (ghrust@79968228.6A2AE50.F3114085.IP)
[03:11:01] <ghrust> 01[13rust01] 15bors pushed 2 new commits to 06auto: 02http://git.io/VFondA
[03:11:01] <ghrust> 13rust/06auto 14caf5321 15Aaron Laursen: fix for issue #7588, overflow now handled correctly
[03:11:01] <ghrust> 13rust/06auto 1425f3b29 15bors: auto merge of #9010 : aaronlaursen/rust/master, r=alexcrichton...
[03:11:01] *** Parts: ghrust (ghrust@79968228.6A2AE50.F3114085.IP) ()
[03:11:29] *** jorendorff is now known as jorendorff_away
[03:12:04] *** Joins: Cromulent (Cromulent@moz-983B638D.cable.virginmedia.com)
[03:13:18] * ChrisMorgan pulls out lynx, the browser for those who are avoiding using too much memory
[03:13:48] <benh> Are you actually on a system that doesn't overcommit memory allocations?
[03:13:53] <benh> I was just guessing :)
[03:15:28] *** Quits: dherman (dherman@moz-6CA476B1.hsd1.ca.comcast.net) (Quit: dherman)
[03:15:31] <ChrisMorgan> Ubuntu 13.10, 64-bit.
[03:16:54] <jmgrosen> dbaupp: how do I have a let expression with the value being something like std::cell::new_empty() ?
[03:17:04] <jmgrosen> with AstBuilder, that is
[03:18:32] *** Joins: zeuxcg (zeuxcg@moz-80D1F912.hsd1.ca.comcast.net)
[03:18:40] *** Quits: Larry (larryfox@26EE99DC.88C61CC9.ECED8BE3.IP) (Quit: My MacBook Pro has gone to sleep. ZZZzzzâ€¦)
[03:18:46] <brson> ChrisMorgan: google.com was sending a value of -1 for Expire that didn't parse
[03:19:26] *** Joins: brendan (brendaneic@EF408078.10A53EE3.77834EAA.IP)
[03:20:21] *** Quits: tjc (tjc@moz-6EB4E533.dsl.tsoft.com) (Quit: zzzzzzzzzz)
[03:21:11] *** Quits: brendan (brendaneic@EF408078.10A53EE3.77834EAA.IP) (Ping timeout)
[03:23:03] <ChrisMorgan> brson: that ain't valid HTTP/1.1; it defines the value for Expires as HTTP-date
[03:23:25] *** Quits: carllerche (carllerche@6B070D22.7E6A0813.1428D117.IP) (Quit: carllerche)
[03:24:11] *** Joins: tjc (tjc@moz-6EB4E533.dsl.tsoft.com)
[03:24:11] *** ChanServ sets mode: +o tjc
[03:24:56] *** Joins: Jesse (jruderman@moz-537BCF9.hsd1.ca.comcast.net)
[03:30:47] *** Quits: Earnestly (earnest@moz-F387F877.dyn.plus.net) (Ping timeout)
[03:31:56] <ChrisMorgan> brson: I see that they do indeed send Expire: -1. Weird, I don't yet know what's expected to happen with that.
[03:32:27] <ChrisMorgan> DuckDuckGo is pleasingly usable in lynx.
[03:32:40] <jmgrosen> anyone know what AstBuilder::expr_method_call expects for its `ident` argument?
[03:33:04] <jmgrosen> nvm, found it in some other source
[03:34:44] *** Joins: dave1629 (dave@moz-17578A1A.hsd1.va.comcast.net)
[03:37:18] *** Joins: ChemicalHarm (Mibbit@moz-A9F37238.hsd1.md.comcast.net)
[03:37:39] *** Quits: ChemicalHarm (Mibbit@moz-A9F37238.hsd1.md.comcast.net) (Quit: http://www.mibbit.com ajax IRC Client)
[03:38:09] <ChrisMorgan> brson: "HTTP/1.1 clients and caches MUST treat other invalid date formats, especially including the value "0", as in the past (i.e., "already expired")." I see from that that I should add an "invalid, expired" sort of value for it rather than just rejecting it outright. I wonder whether using something like Result<Option<E>, T> (more likely a new tri-state enum: none, error, ok) instead of Option<T> would be better.
[03:39:37] *** Quits: Jesin (Jessin_@moz-130D8933.cc.lehigh.edu) (Input/output error)
[03:39:51] *** Quits: Cromulent (Cromulent@moz-983B638D.cable.virginmedia.com) (Quit: KVIrc 4.2.0 Equilibrium http://www.kvirc.net/)
[03:39:58] <dbaupp> jmgrosen: sorry, but std::cell::new_empty would be something like `cx.expr_call(span, cx.expr_path(cx.path_global(span, ~[std, cell, new_empty])), ~[])`
[03:40:10] <dbaupp> jmgrosen: (acrichto wasn't kidding when he said verbose.)
[03:41:14] <jmgrosen> dbaupp, where do you get the ~[std, cell, new_empty] from?
[03:41:50] <ChrisMorgan> HTTP is really not a nice specification :-(
[03:42:08] <dbaupp> jmgrosen: `cx.ident_of("std")` `cx.ident_of("cell")`, `cx.ident_of("new_empty")`
[03:42:14] <jmgrosen> dbaupp: ok
[03:43:31] *** Quits: bjz (brendanzab@B398BE78.F804C29E.D35A31DF.IP) (Ping timeout)
[03:43:45] *** Joins: bjz (brendanzab@B398BE78.F804C29E.D35A31DF.IP)
[03:43:47] *** Quits: azita (Azita@moz-C1FB2A8.hsd1.ca.comcast.net) (Quit: azita)
[03:44:02] *** Joins: alisdair (textual@1697D94C.7742FB18.FBC8476D.IP)
[03:46:18] *** Quits: bjz (brendanzab@B398BE78.F804C29E.D35A31DF.IP) (Ping timeout)
[03:46:36] *** Joins: bjz (brendanzab@B398BE78.F804C29E.D35A31DF.IP)
[03:51:00] *** Quits: igl (igl@moz-79B30EC2.adsl.alicedsl.de) (Ping timeout)
[03:51:28] *** Quits: tjc (tjc@moz-6EB4E533.dsl.tsoft.com) (Quit: zzzzzzzzzz)
[03:52:30] *** Joins: igl (igl@moz-A139B883.adsl.alicedsl.de)
[03:52:46] <acrichto> I just got an absolutely terrifying profile for one of my projects
[03:52:53] <acrichto> cast::transmute_copy is the slowest thing
[03:53:06] <acrichto> with ptr::__extensions__::eq high up as well
[03:53:27] <cmr> wasn't the __extensions__ stuff renamed recently, by strcat?
[03:53:48] <acrichto> I got rid of a lot of them
[03:53:50] <acrichto> but not all of them
[03:54:04] <acrichto> vec::__extensions__::next is also high up (the vector iterator)
[03:54:32] <cmr> this is probably a good thing yeah?
[03:54:42] <acrichto> that shouldn't be one of the slowest functions :(
[03:54:54] <acrichto> this used to run in <5s and now it's 1m 47s
[03:55:12] *** Joins: ww (Mibbit@moz-7385AD13.dia.static.qwest.net)
[03:55:48] <engla>  shouldn't all those be inlined?
[03:55:54] <acrichto> that's what I was thinking...
[03:55:56] *** Quits: dave1629 (dave@moz-17578A1A.hsd1.va.comcast.net) (Quit: dave1629)
[03:56:11] <acrichto> this profile is terrifying
[03:56:16] *** Quits: brson (brson@6A848D32.C1B840DD.76F66111.IP) (Ping timeout)
[03:56:28] *** Joins: dherman (dherman@moz-6CA476B1.hsd1.ca.comcast.net)
[03:56:28] *** ChanServ sets mode: +ao dherman dherman
[03:56:34] <acrichto> I think I'm creating an absurd amount hash maps which isn't good, but it shouldn't take this long?
[03:56:36] *** Joins: azita (Azita@moz-C1FB2A8.hsd1.ca.comcast.net)
[03:56:52] <acrichto> option::Option::Some is 3% of the runtime
[03:57:02] <jmgrosen> o_O
[03:57:02] <acrichto> called from the next() function of the vector iterator
[03:57:10] <acrichto> what is going on!?
[03:57:12] *** Quits: brandon-m-skinner (brandon@moz-C7AC35F5.mh.shawcable.net) (Quit: Konversation terminated!)
[03:57:38] <cmr> That would be the Option constructor
[03:57:46] <cmr> Why isn'tthat getting inlined :\
[03:57:52] <cmr> Is it actually a function call?
[03:57:57] *** Quits: azita (Azita@moz-C1FB2A8.hsd1.ca.comcast.net) (Quit: azita)
[03:58:00] <acrichto> that is a very good question
[03:58:17] <acrichto> I hope xcrate inlining didn't get horked somewhere
[03:58:22] <engla> probably
[03:58:26] <cmr> yeah that'd be really bad
[03:58:34] <cmr> also horked is a new word for me
[03:58:39] <cmr> a fun typo, I assume
[03:58:45] <cmr> (for bork, of course)
[03:59:12] <acrichto> raw::Repr::repr also isn't getting inlined, but it doesn't have #[inline] so I'm recompiling rustc with it inlined and seeing if that makes a difference
[03:59:18] <eevee_> "hork" is the noise a cat makes when horking up a hairball, and also the noise a programmer makes when finding out what idiot thing just cost hours of debugging
[03:59:35] <acrichto> *whoa*
[03:59:52] <acrichto> --opt-level=3 == 1:47, --opt-level=2 == 22s
[04:00:04] <acrichto> llvm what are you doing?!
[04:00:37] <cmr> eevee_: No, I believe that sound is a series of explitives and/or fist banging
[04:00:42] *** Joins: brson (brson@moz-BBE3ABD.mv.mozilla.com)
[04:00:42] *** ChanServ sets mode: +ao brson brson
[04:05:08] *** Quits: parcha (quassel@moz-A9A9F340.hsd1.ma.comcast.net) (Client exited)
[04:05:46] *** Joins: carllerche (carllerche@6B070D22.7E6A0813.1428D117.IP)
[04:06:41] <ww> question: i've just compiled and installed rust 0.8-pre from the master branch.  i notice a few things won't compile now.  just want to clarify the followings.
[04:07:12] <cmr> brson: the language example onthe frontpage needs to use the new iterator syntax
[04:07:15] *** Joins: lenstr (lenstr@CD7D5ABA.83A99F98.85938D85.IP)
[04:07:20] *** Quits: lenstr (lenstr@CD7D5ABA.83A99F98.85938D85.IP) (Client exited)
[04:07:21] <cmr> it's a super simple change
[04:07:30] <ww> priv is gone?  extra::net::ip is gone?  extra::net::tcp is gone?  extra::uv is gone?
[04:07:46] <cmr> ww: priv is not gone, just not allowed where it adds no extra informatino
[04:07:50] <cmr> extra::net is gone
[04:07:52] <cmr> also uv
[04:08:19] <cmr> obsoleted by the new runtime.
[04:08:20] <Luqman> ww: you want std::rt::io::net
[04:08:22] *** Joins: tjc (tjc@moz-6EB4E533.dsl.tsoft.com)
[04:08:22] *** ChanServ sets mode: +o tjc
[04:08:38] <ww> i see.  so the std::rt::io::net::* is replacing the extra::net and uv?
[04:08:54] <cmr> it will eventually be std::net or std::io::net
[04:08:58] <cmr> but yes
[04:09:01] <Ralith> that fqn is almost half colons
[04:09:08] <ww> ok, i see.  thanks
[04:10:07] *** Joins: parcha (quassel@moz-A9A9F340.hsd1.ma.comcast.net)
[04:11:48] *** Joins: glyc (Mibbit@moz-20CEEF38.hsd1.ca.comcast.net)
[04:13:43] *** Parts: ww (Mibbit@moz-7385AD13.dia.static.qwest.net) ()
[04:15:58] *** Joins: ghrust (ghrust@2EE61FCC.6A2AE50.F3114085.IP)
[04:15:58] <ghrust> 01[13rust01] 15bors merged 06auto into 06master: 02http://git.io/VFondA
[04:15:58] *** Parts: ghrust (ghrust@2EE61FCC.6A2AE50.F3114085.IP) ()
[04:18:38] *** Quits: itdaniher (it@moz-6C3ABA7E.bstnma.fios.verizon.net) (Ping timeout)
[04:18:57] *** Joins: glyc2 (Mibbit@moz-20CEEF38.hsd1.ca.comcast.net)
[04:20:57] *** Joins: ghrust (ghrust@2EE61FCC.6A2AE50.F3114085.IP)
[04:20:57] <ghrust> 01[13rust01] 15bors pushed 0 new commits to 06auto: 02http://git.io/vdUTgQ
[04:20:57] *** Parts: ghrust (ghrust@2EE61FCC.6A2AE50.F3114085.IP) ()
[04:20:58] *** Joins: ghrust (ghrust@1E8607E8.6A2AE50.F3114085.IP)
[04:20:58] <ghrust> 01[13rust01] 15bors pushed 2 new commits to 06auto: 02http://git.io/lrUFTA
[04:20:58] <ghrust> 13rust/06auto 143c30ecb 15Steven Fackler: Add fractional second support to str{p,f}time...
[04:20:58] <ghrust> 13rust/06auto 14eae5fbd 15bors: auto merge of #9016 : sfackler/rust/nanoseconds, r=alexcrichton...
[04:20:58] *** Parts: ghrust (ghrust@1E8607E8.6A2AE50.F3114085.IP) ()
[04:20:58] *** Parts: glyc (Mibbit@moz-20CEEF38.hsd1.ca.comcast.net) ()
[04:21:31] *** Quits: glyc2 (Mibbit@moz-20CEEF38.hsd1.ca.comcast.net) (Quit: http://www.mibbit.com ajax IRC Client)
[04:22:20] <jmgrosen> cool, I got my hashmap! syntax extension working :D
[04:22:44] <jmgrosen> so I can do hashmap!("foo" => "bar", "blah" => "cool")
[04:22:59] <jmgrosen> or hashmap!(5 => ~[1, 2, 3], 9 => ~[6, 5, 4])
[04:23:08] <jmgrosen> much more convenient than doing it manually
[04:23:21] <cubic> I installed mingw this morning and apparently gcc/++ <4.6 can't use the windows headers
[04:23:36] *** Joins: steven_is_false (user@C5B76363.1FF1EBF8.1ECA502.IP)
[04:24:20] <Luqman> jmgrosen: https://gist.github.com/luqmana/6219956 :P
[04:24:55] <jmgrosen> Luqman: ah, didn't realize you could do it with just a macro >.<
[04:25:00] <jmgrosen> but cool
[04:25:14] <jmgrosen> I learned about syntax extensions :I)
[04:25:31] *** Quits: echristo (echristo@moz-1892C634.hsd1.ca.comcast.net) (Quit: echristo)
[04:25:44] <SingingBoyo> anyone with rt::io input:  would a with_mem_writer function be worth including in rt::io::mem?  similar to with_str_writer we have in std::io right now.
[04:26:11] <steven_is_false> Hi. I have simple style checker script (see http://pastebin.mozilla.org/2990056 ) but it's really slow. I was thinking that if I'm going to fix the speed issue I might as well write the script the proper way. And I believe the proper way to be a compiler plugin.
[04:26:27] <steven_is_false> What's the current support for plugging in stuff to the Rust compiler?
[04:27:03] <steven_is_false> I know there are plans to add syntax extension plugins but will people be able t to plug in to other parts of the compiler as well?
[04:28:09] <jmgrosen> Luqman: the syntax extension method ends up being /slightly/ faster because I know how many there are, and can `resize` or `reserve_at_least` that many (but that probably doesn't matter much for small maps :P)
[04:28:16] <cmr> steven_is_false: all "style information" such as indentation will be gone by the time you get an AST
[04:28:32] <cmr> steven_is_false: And there's currently 0 support for plugins.
[04:28:48] <steven_is_false> cmr: Shouldn't the style information be perserved then.
[04:28:57] <cmr> steven_is_false: No, because it's not semantically relevant
[04:29:11] <steven_is_false> cmr: Right but it's useful for error messages.
[04:29:13] <cmr> I think it preserves some newline information
[04:29:23] <cmr> steven_is_false: What sort of error messages?
[04:29:41] <steven_is_false> cmr: I'm not sure how much information needs to be preserved.
[04:29:43] <jmgrosen> are there plans to have a hashmap! in libsyntax?
[04:29:44] <cmr> AST elements "know where they came from" in that they have a span which is the byte range they were parsed from.
[04:29:58] <cmr> but other than that the information is gone
[04:30:05] <cmr> and spans never include leading indentation for example
[04:30:15] <steven_is_false> cmr: Okay
[04:31:04] <steven_is_false> cmr: I think it's either the lexer, or the parser which is very hacky, and crufty. It wouldn't be easy to hook into those.
[04:31:34] <steven_is_false> And by the time the AST is generated such information is gone.
[04:31:45] <steven_is_false> Thanks for the information.
[04:33:29] <cmr> steven_is_false: rust is designed to be lexed with regex, so a relatively simple regex-based tool should be able to do an okish job?
[04:34:29] <steven_is_false> cmr: Yup, it's the parser which needs to be reworked.
[04:34:58] <cmr> steven_is_false: Look at tidy.py
[04:35:06] <cmr> It is our style checker, very basic though
[04:36:01] <steven_is_false> cmr: Thanks.
[04:37:02] <steven_is_false> Suppose, I made a parser combinators library for Rust?
[04:37:27] <cmr> It has been done in the past: https://github.com/jesse99/rparse
[04:37:45] <cmr> I tried updating it to 0.6 but failed
[04:38:04] <steven_is_false> Oh.
[04:38:10] <steven_is_false> It's 0.8 now.
[04:38:13] <cmr> So, it's possible.
[04:42:20] *** Quits: carllerche (carllerche@6B070D22.7E6A0813.1428D117.IP) (Quit: carllerche)
[04:43:19] *** Quits: jstevans (Instantbir@moz-F3C02489.bootp.virginia.edu) (Ping timeout)
[04:47:24] *** Quits: RMF (RMF@moz-BFEC31A2.dsl.telepac.pt) (Ping timeout)
[04:47:28] <steven_is_false> It just occurred to me. It's been argued that due to Rust's lifetime analysis goto would be difficult to support but that Rust already supports return, and breaks. Why would goto be so much more difficult?
[04:49:11] <engla> I have a toy one using  struct Pars<A, R>(~fn<'a>(Iter<'a, A>) -> Result<(Iter<'a, A>, R),~str>);
[04:49:21] *** Joins: jdsanders (Adium@moz-84CB7548.hlrn.qwest.net)
[04:49:47] <steven_is_false> engla: Is using functions better than using traits?
[04:50:59] <engla> probably not. It's just to mimic Parsec and the simple way of defining the parser
[04:51:25] <steven_is_false> Okay
[04:58:15] *** Quits: tjc (tjc@moz-6EB4E533.dsl.tsoft.com) (Quit: zzzzzzzzzz)
[05:01:16] *** Joins: tjc (tjc@moz-6EB4E533.dsl.tsoft.com)
[05:01:16] *** ChanServ sets mode: +o tjc
[05:01:48] *** Quits: brson (brson@moz-BBE3ABD.mv.mozilla.com) (Quit: leaving)
[05:02:06] *** Quits: dherman (dherman@moz-6CA476B1.hsd1.ca.comcast.net) (Quit: dherman)
[05:02:09] *** Joins: jstevans (Instantbir@moz-F3C02489.bootp.virginia.edu)
[05:02:20] *** Joins: carllerche (carllerche@6B070D22.7E6A0813.1428D117.IP)
[05:02:23] *** Parts: steven_is_false (user@C5B76363.1FF1EBF8.1ECA502.IP) (ERC Version 5.3 (IRC client for Emacs))
[05:07:49] <sfackler> this doesn't look good. 
[05:07:54] <sfackler> http://buildbot.rust-lang.org/builders/auto-bsd-64-opt/builds/1112/steps/test/logs/stdio
[05:08:01] <sfackler> pretty sure my change didn't cause that
[05:09:21] *** Quits: tjc (tjc@moz-6EB4E533.dsl.tsoft.com) (Quit: Places to go, people to annoy)
[05:10:22] <SingingBoyo> Also why is there a paragraph in there starting with "The ocean ate the last of the land and poured into the smoking gulf"?
[05:10:51] <ChrisMorgan> That BSD buildbot is giving those spurious failures regularly.
[05:11:16] <sfackler> SingingBoyo: for whatever reason, that's what happens if you double-fail
[05:11:26] *** Quits: cubic (cubic@moz-FE5AD6C7.mc.videotron.ca) (Quit: Leaving)
[05:11:39] <sfackler> that's disturbing
[05:11:46] *** Quits: engla (engla@moz-DBD1D96E.cust.bredbandsbolaget.se) (Ping timeout)
[05:11:49] <sfackler> https://github.com/mozilla/rust/pull/9016 retry I guess?
[05:15:21] *** Quits: brendanc (brendan@moz-CA4BEC19.cs.ubc.ca) (Input/output error)
[05:17:20] *** Joins: brendanc (brendan@moz-CA4BEC19.cs.ubc.ca)
[05:18:35] *** Joins: dherman (dherman@moz-6CA476B1.hsd1.ca.comcast.net)
[05:18:35] *** ChanServ sets mode: +ao dherman dherman
[05:20:15] *** Quits: z0w0 (zack@moz-74A8B350.lnse4.cha.bigpond.net.au) (Client exited)
[05:23:56] *** Joins: brendan (brendaneic@moz-99385846.sub-70-197-1.myvzw.com)
[05:24:42] <acrichto> sfackler: https://github.com/mozilla/rust/issues/8969
[05:24:44] <acrichto> it's sad :(
[05:25:30] *** Joins: roboguy (roboguy@moz-266CFD9E.cm.sunflower.com)
[05:26:01] *** Joins: ghrust (ghrust@24260B07.6A2AE50.F3114085.IP)
[05:26:01] <ghrust> 01[13rust01] 15bors 04force-pushed 06auto from 14eae5fbd to 1425f3b29: 02http://git.io/N3iJvQ
[05:26:01] *** Parts: ghrust (ghrust@24260B07.6A2AE50.F3114085.IP) ()
[05:26:02] *** Joins: ghrust (ghrust@2EE61FCC.6A2AE50.F3114085.IP)
[05:26:02] <ghrust> 01[13rust01] 15bors pushed 2 new commits to 06auto: 02http://git.io/CSUBdw
[05:26:02] <ghrust> 13rust/06auto 143c30ecb 15Steven Fackler: Add fractional second support to str{p,f}time...
[05:26:02] <ghrust> 13rust/06auto 143e6de6b 15bors: auto merge of #9016 : sfackler/rust/nanoseconds, r=alexcrichton...
[05:26:03] *** Parts: ghrust (ghrust@2EE61FCC.6A2AE50.F3114085.IP) ()
[05:28:50] *** Quits: dherman (dherman@moz-6CA476B1.hsd1.ca.comcast.net) (Quit: dherman)
[05:29:01] <cmr> Aw the interns left?
[05:34:26] *** Quits: jdsanders (Adium@moz-84CB7548.hlrn.qwest.net) (Quit: Leaving.)
[05:35:17] <nielsle> Random idea. It could be cool to have a command line tool to list the contents of a compiled rust library (just for  debugging)
[05:36:00] <cmr> nielsle: rustc --ls *used* to be that
[05:36:06] <cmr> Now you just have to use nm plus c++filt
[05:36:59] <nielsle> Thanks. I will try.
[05:39:58] *** Joins: robertknight (robertknig@moz-29DA0AFD.range86-162.btcentralplus.com)
[05:43:04] *** Quits: jstevans (Instantbir@moz-F3C02489.bootp.virginia.edu) (Ping timeout)
[05:43:48] *** Quits: josh (josh@moz-348C4790.hsd1.mn.comcast.net) (Quit: josh)
[05:44:25] *** Joins: jdsanders (Adium@moz-84CB7548.hlrn.qwest.net)
[05:48:55] *** Joins: jaen (jaen@moz-E0979827.copit.pl)
[05:53:43] <SingingBoyo> so do for loops only work for structs implementing std::iterator::Iterator?  Or are there other things they can take?
[05:53:44] *** Quits: jdsanders (Adium@moz-84CB7548.hlrn.qwest.net) (Quit: Leaving.)
[05:53:58] <cmr> SingingBoyo: any type implementing Iterator, correct.
[06:00:12] *** Joins: bjz_ (brendanzab@B398BE78.F804C29E.D35A31DF.IP)
[06:00:13] *** Quits: bjz (brendanzab@B398BE78.F804C29E.D35A31DF.IP) (Connection reset by peer)
[06:06:30] <SiegeLord> Am I correct in thinking that the metadata contains more than just the necessary AST for interfacing?
[06:07:08] <cmr> SiegeLord: it also contains the signature of every function/method iirc
[06:07:20] <cmr> look in librustc/metadata/encoder.rs perhaps
[06:07:21] <acrichto> SiegeLord: it also has all the type information for linking, plus stuff for inlining across crates, plus generics
[06:07:34] *** Joins: Ms2ger (Ms2ger@moz-B53902AE.adsl-dyn.isp.belgacom.be)
[06:09:47] *** Quits: tiffany (kawaii@moz-EB8B0C08.dhcp.embarqhsd.net) (Ping timeout)
[06:20:08] *** Joins: eatkinson (eatkinson@moz-261EDE03.hsd1.ca.comcast.net)
[06:20:13] *** Quits: eatkinson (eatkinson@moz-261EDE03.hsd1.ca.comcast.net) (Quit: eatkinson)
[06:21:35] *** Joins: nsf (nsf@moz-EEF3238A.convex.ru)
[06:21:40] *** Quits: igl (igl@moz-A139B883.adsl.alicedsl.de) (Ping timeout)
[06:21:41] *** Joins: igl (igl@moz-40EB6DD1.adsl.alicedsl.de)
[06:22:40] *** Quits: jmgrosen (jmgrosen@moz-848F6087.sb.sd.cox.net) (Quit: jmgrosen)
[06:23:21] *** Quits: igl (igl@moz-40EB6DD1.adsl.alicedsl.de) (Ping timeout)
[06:23:22] *** Joins: igl (igl@moz-AE87D624.adsl.alicedsl.de)
[06:25:25] <SiegeLord> It'd have been somewhat simpler if it was only the AST...
[06:26:29] <acrichto> you don't necessarily want the whole AST though
[06:26:38] <acrichto> but you do want metadata about everything public in the AST
[06:29:33] *** Joins: bjz (brendanzab@B398BE78.F804C29E.D35A31DF.IP)
[06:30:04] *** Quits: bjz_ (brendanzab@B398BE78.F804C29E.D35A31DF.IP) (Connection reset by peer)
[06:31:00] *** Joins: ghrust (ghrust@2EE61FCC.6A2AE50.F3114085.IP)
[06:31:00] <ghrust> 01[13rust01] 15bors merged 06auto into 06master: 02http://git.io/CSUBdw
[06:31:00] *** Parts: ghrust (ghrust@2EE61FCC.6A2AE50.F3114085.IP) ()
[06:35:59] *** Joins: ghrust (ghrust@79968228.6A2AE50.F3114085.IP)
[06:35:59] <ghrust> 01[13rust01] 15bors pushed 0 new commits to 06auto: 02http://git.io/m0o8Qw
[06:35:59] *** Parts: ghrust (ghrust@79968228.6A2AE50.F3114085.IP) ()
[06:36:01] *** Joins: ghrust (ghrust@1E8607E8.6A2AE50.F3114085.IP)
[06:36:01] <ghrust> 01[13rust01] 15bors pushed 71 new commits to 06auto: 02http://git.io/pVrImg
[06:36:01] <ghrust> 13rust/06auto 14acad9f3 15John Clements: commenting out special Eq implementation for now...
[06:36:01] <ghrust> 13rust/06auto 14e1734f6 15John Clements: rename resolve to mtwt_resolve
[06:36:02] <ghrust> 13rust/06auto 149ec1623 15John Clements: ident->name
[06:36:03] *** Parts: ghrust (ghrust@1E8607E8.6A2AE50.F3114085.IP) ()
[06:36:27] *** Quits: Ms2ger (Ms2ger@moz-B53902AE.adsl-dyn.isp.belgacom.be) (Quit: bbl)
[06:36:58] <SiegeLord> Ok... I think I sort of know what to do... I need to create a new tag for struct variant argument type names... and then decode it
[06:37:45] *** Joins: azita (Azita@moz-C1FB2A8.hsd1.ca.comcast.net)
[06:38:09] *** Joins: nkoep (nik@moz-AA5864F1.pool.mediaways.net)
[06:38:58] *** Quits: SingingBoyo (brandon@4DF3381A.51F4D838.4F048BDC.IP) (Ping timeout)
[06:40:48] *** Quits: enix (enix@moz-A50569DD.c3-0.slvr-ubr1.lnh-slvr.md.cable.rcn.com) (Quit: Konversation terminated!)
[06:43:02] *** Joins: SingingBoyo (brandon@4DF3381A.51F4D838.4F048BDC.IP)
[06:46:52] *** Joins: valenting (Thunderbir@BC8F8C4C.4ABED146.FB866788.IP)
[06:47:00] *** Joins: jviereck (Adium@moz-58A87BA7.dip0.t-ipconnect.de)
[06:47:32] *** Quits: igl (igl@moz-AE87D624.adsl.alicedsl.de) (Connection reset by peer)
[06:47:42] *** Joins: drrb (drrb@4D561226.896EE5A.377B9828.IP)
[06:48:09] *** Joins: igl (igl@moz-C4A95D19.adsl.alicedsl.de)
[06:53:35] *** Quits: azita (Azita@moz-C1FB2A8.hsd1.ca.comcast.net) (Quit: azita)
[07:00:01] *** Joins: RMF (RMF@moz-1A0DBA5B.dsl.telepac.pt)
[07:01:43] <SingingBoyo> what happened to str::from_bytes?
[07:02:03] <SingingBoyo> removed in favor of from_utfXX?
[07:02:13] <dbaupp> SingingBoyo: yeah, from_utf8
[07:02:59] *** Quits: carllerche (carllerche@6B070D22.7E6A0813.1428D117.IP) (Quit: carllerche)
[07:06:29] *** Quits: igl (igl@moz-C4A95D19.adsl.alicedsl.de) (Ping timeout)
[07:08:03] *** Joins: igl (igl@moz-CDE4D349.adsl.alicedsl.de)
[07:08:04] <SiegeLord> Hmm... metadata_encoding_version is 0.0.0.1
[07:08:15] <SiegeLord> Was it really never changed during Rust's entire development history?
[07:09:35] <acrichto> SiegeLord: that may just be prep for once rust is production-type ready, right now it changes so much it's probably not worth maintaining that
[07:09:39] <acrichto> just a guess though
[07:11:35] <dbaupp> also, people may've just completely forgotten that it exists
[07:11:46] * dbaupp didn't even know that it was there
[07:11:50] <SiegeLord> It is kind of in the middle of the file
[07:13:33] *** Quits: roboguy (roboguy@moz-266CFD9E.cm.sunflower.com) (Input/output error)
[07:21:38] <acrichto> whoa, llvm didn't optimize (i % uint::bits) to a mask
[07:22:07] <acrichto> ok no hang on
[07:22:17] <acrichto> llvm isn't optimizing xcrate inlined methods at all
[07:28:46] *** Quits: alisdair (textual@1697D94C.7742FB18.FBC8476D.IP) (Quit: My MacBook Pro has gone to sleep. ZZZzzzâ€¦)
[07:28:48] *** Joins: jclements_ (jclements@moz-E4774872.dsl.snlo01.pacbell.net)
[07:31:38] <bjz> zeuxcg: so llvm inlines the closure ok atm?
[07:31:43] <bjz> *closures
[07:32:28] *** Quits: robertknight (robertknig@moz-29DA0AFD.range86-162.btcentralplus.com) (Ping timeout)
[07:35:01] *** Joins: squiddy (squiddy@moz-2D3E7455.adsl.alicedsl.de)
[07:36:34] *** Joins: robertknight (robertknig@moz-29DA0AFD.range86-162.btcentralplus.com)
[07:38:07] *** Quits: bct (bct@moz-D3BEA05.ed.shawcable.net) (Ping timeout)
[07:38:25] <SiegeLord> What is the interner used for? Should I use it to get ident's for field names?
[07:39:05] <clements> pauls: ping
[07:41:02] *** Joins: ghrust (ghrust@24260B07.6A2AE50.F3114085.IP)
[07:41:02] <ghrust> 01[13rust01] 15bors merged 06auto into 06master: 02http://git.io/pVrImg
[07:41:02] *** Parts: ghrust (ghrust@24260B07.6A2AE50.F3114085.IP) ()
[07:41:07] <clements> gadzooks! Hygiene landed! Now, let's see if anything terrible happens over the next few days....
[07:41:31] *** Joins: Yurume (yurume@AC58A8CE.8A059B47.E313B915.IP)
[07:44:04] *** Joins: bct (bct@moz-D3BEA05.ed.shawcable.net)
[07:44:08] <SiegeLord> How do hygienic macros work in Rust?
[07:44:43] *** Quits: igl (igl@moz-CDE4D349.adsl.alicedsl.de) (Ping timeout)
[07:45:02] <jclements_> SiegeLord: hopefully, you never notice them at all; they prevent bad stuff from happening if, for instance, you write a macro that binds a variable that was already in scope.  
[07:45:14] *** Joins: igl (igl@moz-508134EE.adsl.alicedsl.de)
[07:46:20] <SiegeLord> Will I be able to refer to variables from the outside without explicitly passing them to the macro?
[07:46:41] <jclements_> SiegeLord: yes, if the macro is declared in the scope of those variables.
[07:46:50] <SiegeLord> I see
[07:47:27] <SiegeLord> Hmm... it's nearly 4AM... do I want to wait for rustc to finish compiling to see if my fix works?
[07:47:49] <jclements_> SiegeLord: if you have to ask, you probably know the answer.... :)
[07:47:57] <SiegeLord> Maybe I should get a faster computer...
[07:48:12] *** Joins: io2 (io2@moz-A6202C16.home.otenet.gr)
[07:48:30] *** Quits: jclements_ (jclements@moz-E4774872.dsl.snlo01.pacbell.net) (Quit: jclements_)
[07:50:02] *** Joins: doomlord (doomlod@moz-13E69BC8.range86-180.btcentralplus.com)
[07:54:24] *** Quits: igl (igl@moz-508134EE.adsl.alicedsl.de) (Ping timeout)
[07:54:59] *** Quits: brendan (brendaneic@moz-99385846.sub-70-197-1.myvzw.com) (Quit: brendan)
[07:55:45] *** Joins: igl (igl@moz-513920C6.adsl.alicedsl.de)
[07:59:34] <doomlord> anyone know of any libraries similiar to rusts' chainable iterator stuff for c++
[08:01:13] *** Joins: squiddy_ (squiddy@moz-C983446B.adsl.alicedsl.de)
[08:01:53] *** Quits: drrb (drrb@4D561226.896EE5A.377B9828.IP) (Quit: drrb)
[08:02:10] *** Quits: squiddy (squiddy@moz-2D3E7455.adsl.alicedsl.de) (Ping timeout)
[08:02:40] *** Quits: bjz (brendanzab@B398BE78.F804C29E.D35A31DF.IP) (Ping timeout)
[08:03:00] *** Joins: bjz (brendanzab@B398BE78.F804C29E.D35A31DF.IP)
[08:03:20] *** Joins: frau (frau@moz-C616DA0A.hsd1.ca.comcast.net)
[08:03:41] *** Joins: sebcrozet (sebcrozet@moz-87D51607.w80-13.abo.wanadoo.fr)
[08:04:15] *** Joins: feduser (feduser@39F1B265.AAE9A62C.650F25DA.IP)
[08:08:37] <SiegeLord> Damn, it didn't work...
[08:11:48] <ChrisMorgan> When rust is compiled, it needs LLVM, right? Where is it? I can't find it in my PREFIX.
[08:15:15] <ChrisMorgan> The answer seems to end up SOURCE_REPO/(llvm/)?x86_64-unknown-linux-gnu/llvm/Release+Asserts/bin (both of them!), but that doesn't make senseâ€”should it not be in the PREFIX?
[08:17:25] *** Quits: igl (igl@moz-513920C6.adsl.alicedsl.de) (Ping timeout)
[08:17:34] *** Quits: jclements (jclements@moz-9C0ABCFC.wireless.calpoly.edu) (Ping timeout)
[08:17:55] *** Quits: SiegeLord (sl@moz-CAF07B4C.hsd1.ma.comcast.net) (Quit: It's a joke, it's all a joke.)
[08:18:05] *** Joins: jclements (jclements@moz-9C0ABCFC.wireless.calpoly.edu)
[08:18:06] *** Joins: drrb (drrb@4D561226.896EE5A.377B9828.IP)
[08:18:12] *** Joins: igl (igl@moz-E3D869C5.adsl.alicedsl.de)
[08:19:20] *** Quits: jaen (jaen@moz-E0979827.copit.pl) (Ping timeout)
[08:19:54] *** Quits: james4k (james@moz-E7990244.consolidated.net) (Ping timeout)
[08:21:16] *** Joins: igl1 (igl@moz-E9EE11FA.adsl.alicedsl.de)
[08:21:33] *** Quits: igl (igl@moz-E3D869C5.adsl.alicedsl.de) (Ping timeout)
[08:27:01] * ChrisMorgan embarks on yet another attempt to compile Rust for ARM on his x86_64 machine
[08:28:13] *** Joins: hjr3 (hradtke@moz-E87BDF1F.socal.res.rr.com)
[08:29:44] *** Joins: Blub\w (wry@7E3BB9D.71150E1A.237AE2BA.IP)
[08:33:58] *** Joins: jaen (jaen@moz-E0979827.copit.pl)
[08:34:07] <frau> I see there's vim goodies in src/etc/vim... is there a recommended way to install them?
[08:38:39] *** Joins: fabiand (fabiand@moz-75B41A0D.adsl.alicedsl.de)
[08:40:17] <ChrisMorgan> frau: for myself, I use Pathogen and have a symlink ~/.vim/bundle/rust to that directory
[08:42:29] *** Joins: Uther (Instantbir@moz-1B244B05.hfc.dyn.abo.bbox.fr)
[08:46:37] *** Joins: donri (dag@moz-9BB61102.tbcn.telia.com)
[08:49:01] <frau> ah cool, thanks!
[08:49:05] *** Quits: frau (frau@moz-C616DA0A.hsd1.ca.comcast.net) (Quit: byebye)
[08:52:19] *** Quits: KindOne (KindOne@moz-2951E403.dynamic.ip.windstream.net) (Ping timeout)
[08:52:53] *** Quits: fabiand (fabiand@moz-75B41A0D.adsl.alicedsl.de) (Quit: Verlassend)
[08:57:13] *** Joins: KindOne (KindOne@moz-AEC3CB34.dynamic.ip.windstream.net)
[09:03:58] <ChrisMorgan> LLVM does actually seem to be building for ARM. 'Course, it remains to be seen whether it gets it rightâ€”still hours until I'll know, by the looks of it...
[09:04:49] *** Joins: igl (igl@moz-23D362E.adsl.alicedsl.de)
[09:05:26] *** Quits: igl1 (igl@moz-E9EE11FA.adsl.alicedsl.de) (Ping timeout)
[09:07:52] *** Quits: valenting (Thunderbir@BC8F8C4C.4ABED146.FB866788.IP) (Ping timeout)
[09:13:44] <ChrisMorgan> Failed at jemalloc configure :-(
[09:18:28] *** Joins: rust-noob (Mibbit@moz-3112320B.graz.surfer.at)
[09:19:33] <rust-noob> hi! how do I remove the last n elements of a mutable slice? (I found initn, but it copies the vector I think..)
[09:23:18] *** Quits: barosl (barosl@3DE683B6.E551553C.7544CABF.IP) (Ping timeout)
[09:25:10] <SingingBoyo> rust-noob: truncate would do what you want I think.
[09:26:44] *** Joins: jensnockert (jensnocker@moz-8BE55278.customer.t3.se)
[09:27:36] <SingingBoyo> rust-noob: though it'd be myVec.truncate(myVec.len() - n), not myVec.truncate(n)
[09:27:51] *** Quits: jensnockert (jensnocker@moz-8BE55278.customer.t3.se) (Input/output error)
[09:28:18] *** Joins: jensnockert (jensnocker@moz-8BE55278.customer.t3.se)
[09:29:35] <rust-noob> perfect! thank you ;)
[09:29:51] *** Joins: nano (nano@moz-74CAD1CA.superkabel.de)
[09:29:59] *** Quits: jensnockert (jensnocker@moz-8BE55278.customer.t3.se) (Ping timeout)
[09:30:11] <rust-noob> rusti [1u,2,3,4].truncate(3);
[09:30:18] <rust-noob> rusti: [1u,2,3,4].truncate(3);
[09:30:43] <rust-noob> well whatever ;)
[09:32:20] *** Joins: vodik (simon@moz-CBE4BB13.cable.teksavvy.com)
[09:33:09] <dbaupp> rust-noob: looks like strcat's laptop is off, so rusti is awol
[09:34:08] *** Joins: jensnockert (jensnocker@moz-8BE55278.customer.t3.se)
[09:34:17] <rust-noob> haha ok :D
[09:38:45] *** Joins: q66 (q66@6EE9DE40.46454B5D.33AABD5F.IP)
[09:39:39] <dbaupp> rust-noob: in any case, .truncate is only on ~[], since that is the only vector that is dynamically sized
[09:41:22] <SingingBoyo> rust-noob: ah whoops.  you probably really want slice_to, sorry.
[09:42:38] *** Quits: nano (nano@moz-74CAD1CA.superkabel.de) (Connection reset by peer)
[09:43:24] <SingingBoyo> rust-noob: or rather, slice_to if you want to leave the other elements in the original array, truncate to delete the extra elements.  
[09:43:31] *** Quits: squiddy_ (squiddy@moz-C983446B.adsl.alicedsl.de) (Input/output error)
[09:43:37] * dbaupp reads the back-scroll
[09:43:55] <ski> hm, someone mentioned "type state and argument modes" being removed. what did those do ?
[09:45:16] <dbaupp> ski: the former allowed one to express invariants about functions (e.g. for reverse(input) -> output, len(input) == len(output))
[09:45:46] <rust-noob> I think truncate is right, I want ~[1,2,3,4,5] to become ~[1,2,3] for example
[09:45:46] <dbaupp> and I think the latter was a little bit like C++ pass-by-reference, but with more control and options
[09:46:06] <ski> checked invariants ? statically ?
[09:46:09] <dbaupp> ski: they both ended up being deemed too complicated to be worth it
[09:46:10] <dbaupp> yeah
[09:46:38] <dbaupp> so one could say zip_equal(a,b) requires len(a) == len(b), and then zip_equal(a, reverse(a)) would type check
[09:46:54] <dbaupp> (since reverse has said that it's input and output have the same length)
[09:47:12] <SingingBoyo> that'd break like all code anyone has written though
[09:47:17] <dbaupp> (NB. I only started using rust after these were removed, so I don't have first hand experience)
[09:47:17] <ski> hm, ok
[09:47:37] <dbaupp> SingingBoyo: I think there was an "trust-me" escape hatch
[09:47:44] <ski> the latter bearing any similarity to multi-moded predicates and functions in Mercury ?
[09:47:50] * dbaupp doesn't know
[09:48:09] *** Quits: igl (igl@moz-23D362E.adsl.alicedsl.de) (Ping timeout)
[09:48:21] <dbaupp> but it'd allow you to say pass this by reference, this by copy, etc
[09:49:28] <ski> would it allow a function to have several "interfaces", say one where an argument is by copy, and another where it is by reference ?
[09:49:38] * dbaupp doesn't know that either
[09:49:52] *** Joins: igl (igl@moz-9A70E6AB.adsl.alicedsl.de)
[09:49:54] <ski> (possibly being compiled to different code, but doing "essentially the same thing")
[09:49:57] <ski> ok
[09:50:23] <ski> ty
[09:50:44] <SingingBoyo> I wish rustc would auto-convert from T to &T when you pass things as arguments.  
[09:51:57] <doomlord> double edge sword, every now and again that bites in C++
[09:52:00] <dbaupp> ski: you got #rust at the quietest time btw; there'll be more knowledgeable people around in a few hours (and there was a few hours ago)
[09:52:12] *** Joins: igl1 (igl@moz-5C473CD3.adsl.alicedsl.de)
[09:52:22] *** Quits: igl (igl@moz-9A70E6AB.adsl.alicedsl.de) (Ping timeout)
[09:52:59] <ski> i see
[09:54:01] <dbaupp> timezones and all that
[09:54:33] <ski> doomlord : thing being passed as argument unexpectedly changed or something else ?
[09:57:03] <doomlord> unexpectedly declaring the argument as T instead of &T but all the surrounding code (caller, & function body) looks the same
[09:58:36] <dbaupp> it's presumably less bad in Rust, since accidentally passing a ~T by val will move, and so the compiler will catch use-after-free etc that might happen in C++ without move semantics
[09:58:44] <dbaupp> (this has been fixed in C++11, hasn't it?)
[09:59:00] *** Quits: rust-noob (Mibbit@moz-3112320B.graz.surfer.at) (Quit: http://www.mibbit.com ajax IRC Client)
[09:59:01] <SingingBoyo> doomlord: got any examples in mind?  I can't think of a problem with it assuming lifetimes are dealt with properly.
[09:59:43] <doomlord> its just that that i've seen in C++ ... you thinnk you're passing a pointer, instead you're passing a whole copy :)
[10:00:52] <SingingBoyo> doomlord:  wasn't saying it should copy, just create a borrowed pointer to the object without forcing me to put the & in front.
[10:01:41] <SingingBoyo> Minor, but it's more consistent with object.someMethod's conversion
[10:05:15] *** Quits: SingingBoyo (brandon@4DF3381A.51F4D838.4F048BDC.IP) (Ping timeout)
[10:06:50] <doomlord> i suppose it might work
[10:07:19] <doomlord> might get hairy with pointer to pointers but then again you only have all that in unsafe code
[10:08:42] *** Quits: vodik (simon@moz-CBE4BB13.cable.teksavvy.com) (Ping timeout)
[10:09:08] *** Joins: vodik (simon@moz-CBE4BB13.cable.teksavvy.com)
[10:10:32] *** Quits: igl1 (igl@moz-5C473CD3.adsl.alicedsl.de) (Ping timeout)
[10:11:34] *** Joins: igl (igl@moz-FEE1DF38.adsl.alicedsl.de)
[10:17:20] *** Quits: drrb (drrb@4D561226.896EE5A.377B9828.IP) (Quit: drrb)
[10:17:31] *** Joins: tgummerer (tgummerer@51D3B54.FEF996EA.EA6FEF3D.IP)
[10:21:45] *** Quits: StarLight (StarLight@moz-987794D0.dynamic.avangarddsl.ru) (Ping timeout)
[10:24:04] *** Quits: jensnockert (jensnocker@moz-8BE55278.customer.t3.se) (Input/output error)
[10:26:10] *** Joins: StarLight (StarLight@moz-A1B43C26.dynamic.avangarddsl.ru)
[10:30:12] *** Joins: drrb (drrb@4D561226.896EE5A.377B9828.IP)
[10:36:39] *** Joins: bytewise (bytewise@moz-4A801D04.unitymediagroup.de)
[10:37:07] *** Quits: drrb (drrb@4D561226.896EE5A.377B9828.IP) (Quit: drrb)
[10:40:47] <mindcat> rusti: [0u8,1u16,2u32]
[10:42:58] *** Quits: vodik (simon@moz-CBE4BB13.cable.teksavvy.com) (Quit: work)
[10:48:29] *** Joins: drrb (drrb@4D561226.896EE5A.377B9828.IP)
[10:49:54] *** Joins: victorporof (victorporo@338A6DC2.9CD5E4C4.D111398B.IP)
[10:50:06] *** Joins: squiddy (squiddy@moz-C983446B.adsl.alicedsl.de)
[10:51:41] <mindcat> how can we store different types in vector?
[10:52:12] <mindcat> or List?
[10:56:47] *** Quits: KindOne (KindOne@moz-AEC3CB34.dynamic.ip.windstream.net) (Ping timeout)
[10:57:28] <doomlord> make an enum and have a vector of that?
[10:58:00] <doomlord> (enum variant for each type you want..)
[10:59:31] <mindcat> doomlord: ok...
[10:59:54] *** Joins: miza (miza@moz-4DD51325.home.otenet.gr)
[11:01:36] *** Joins: KindOne (KindOne@moz-A27C5CD4.dynamic.ip.windstream.net)
[11:07:34] *** Quits: feduser (feduser@39F1B265.AAE9A62C.650F25DA.IP) (Ping timeout)
[11:10:41] *** Joins: BizarreCake (BizarreCak@moz-361FE9B2.dynamic.barak-online.net)
[11:10:42] *** Joins: bernard (Mibbit@moz-FAE37203.superkabel.de)
[11:10:53] *** Quits: zxcdw (r-a@858B320D.B543C4DE.3933CC16.IP) (Ping timeout)
[11:11:12] *** Quits: sigma (sigma@51C589B3.EF2694B5.DFAC6AA7.IP) (Ping timeout)
[11:11:48] *** Quits: bernard (Mibbit@moz-FAE37203.superkabel.de) (Quit: http://www.mibbit.com ajax IRC Client)
[11:13:47] *** Quits: KindOne (KindOne@moz-A27C5CD4.dynamic.ip.windstream.net) (Ping timeout)
[11:15:18] *** Joins: zxcdw (r-a@858B320D.B543C4DE.3933CC16.IP)
[11:16:31] *** Quits: squiddy (squiddy@moz-C983446B.adsl.alicedsl.de) (Input/output error)
[11:17:46] *** Joins: KindOne (KindOne@moz-90FB114A.dynamic.ip.windstream.net)
[11:18:52] *** Joins: aeqwa (aeqwa@moz-C1B65A90.dsl.tropolys.de)
[11:19:53] *** Joins: spider-mario (spidermari@moz-81131DB6.fbx.proxad.net)
[11:22:24] *** Joins: sigma (sigma@51C589B3.EF2694B5.DFAC6AA7.IP)
[11:24:50] *** Quits: KindOne (KindOne@moz-90FB114A.dynamic.ip.windstream.net) (Ping timeout)
[11:26:11] *** Joins: gavinb (gavinb@moz-9EC182F0.lowrp3.vic.optusnet.com.au)
[11:27:08] *** Joins: Earnestly (earnest@moz-DAE7D1AD.dyn.plus.net)
[11:29:31] *** Joins: FrozenCow (FrozenCow@moz-B2DF4929.chello.nl)
[11:29:39] *** Joins: KindOne (KindOne@90FCC87.7E8839F4.34F73994.IP)
[11:33:15] *** Quits: tgummerer (tgummerer@51D3B54.FEF996EA.EA6FEF3D.IP) (Ping timeout)
[11:35:11] *** Quits: jviereck (Adium@moz-58A87BA7.dip0.t-ipconnect.de) (Quit: Leaving.)
[11:39:59] <Thiez> cast::transmute should compile to a noop, right?
[11:40:03] *** Joins: squiddy (squiddy@moz-C983446B.adsl.alicedsl.de)
[11:40:36] <Thiez> perf claims a rust program is spending 4.17% of the time in cast::transmute
[11:40:53] <Thiez> consider me confused :p
[11:42:41] *** Joins: jviereck (Adium@moz-58A87BA7.dip0.t-ipconnect.de)
[11:43:29] *** Quits: lerc (quassel@B2E8CAD3.A8D14E52.788638A4.IP) (Client exited)
[11:46:37] <Thiez> is there a good way of having several versions of rust living on the same machine?
[11:47:49] *** Joins: tgummerer (tgummerer@moz-5DC8FA44.tbcn.telia.com)
[11:49:29] *** Quits: tgummerer (tgummerer@moz-5DC8FA44.tbcn.telia.com) (Ping timeout)
[11:49:44] <Thiez> mindcat: what are you trying to accomplish?
[11:52:03] *** Quits: Uther (Instantbir@moz-1B244B05.hfc.dyn.abo.bbox.fr) (Quit: Instantbird 1.4 -- http://www.instantbird.com)
[11:57:56] *** Joins: MrFahrenheit (RageOfThou@3FEF494C.29C984D5.783DEDCA.IP)
[12:01:36] *** Joins: jensnockert (jensnocker@moz-8BE55278.customer.t3.se)
[12:04:12] *** Joins: tgummerer (tgummerer@51D3B54.FEF996EA.EA6FEF3D.IP)
[12:10:30] <mindcat> Thiez: Named Binary Tag
[12:10:59] <Thiez> minecraft?
[12:11:18] <mindcat> Thiez: just this data format
[12:11:29] <Thiez> interesting :)
[12:12:05] <mindcat> error: type `&mut std::rt::io::mem::MemReader` does not implement any method in scope named `read_be_u16`
[12:12:19] <dbaupp> Thiez: transmute should be a noop, yes
[12:12:35] <mindcat> I don't know why "â€‹stdâ€‹::rtâ€‹::ioâ€‹::extensions::ReaderByteConversions" is not work
[12:12:45] <dbaupp> I've seen it be expensive too, but I've never been able to get a small test case that demonstrates it
[12:13:07] <Thiez> perhaps it's an error in the debug info?
[12:13:20] <dbaupp> Thiez: I believe copying the build directory (i.e. host_triple/stage2/...) to whereever you want works
[12:13:57] <mindcat> Thiez: http://paste.ubuntu.com/6074594/
[12:14:37] <dbaupp> mindcat: I don't think std::rt::io have all the fancy utility methods that std::io has
[12:14:42] <Thiez> dbaupp: I just created another clone of the repo and will build there
[12:15:02] <Thiez> having two separate build directories was awful as switching between branches triggered a llvm rebuild :(
[12:15:20] <mindcat> dbaupp: I didn't use std::io
[12:15:31] <dbaupp> Thiez: oh; I see; you didn't just want two different installed version?
[12:15:48] <dbaupp> mindcat: that's what I mean; std::rt::io does not have the same methods as std::io
[12:16:16] <dbaupp> mindcat: hm, actually, it seems it does
[12:16:35] <dbaupp> but they've got a trailing underscore to work around #6898
[12:16:40] * dbaupp isn't sure of the bug number
[12:16:52] <Thiez> dbaupp: yes but it seems when I install one version programs compiled with the other version stop working because they can't find the right versions of libraries?
[12:16:57] <dbaupp> mindcat: i.e. .read_be_u16_()
[12:17:12] <dbaupp> Thiez: right, you won't be able to make install both of them into the same directory
[12:17:23] <mindcat> dbaupp: oh!
[12:17:27] <Thiez> so I switch back and forth with 'make install' but they detect that I've switched branches (even when I didn't make any edits) and rebuild everything :p
[12:18:00] <dbaupp> Thiez: aha; yeah, having 2 checkouts sounds like it's the easiest
[12:20:30] <Thiez> why does 'rustpkg list' show me an executable script file I have in ~/bin ? It claims it is one of my 'Installed packages:' but it is not rust, has never touched rustpkg, and isn't part of any package :D
[12:20:50] <mindcat> dbaupp: thanks! :D
[12:21:05] *** Joins: ghrust (ghrust@24260B07.6A2AE50.F3114085.IP)
[12:21:05] <ghrust> 01[13rust01] 15bors pushed 10 new commits to 06auto: 02http://git.io/wuzlCA
[12:21:05] <ghrust> 13rust/06auto 14e7d5af8 15Micah Chalmer: Fix glitches with struct field aligned indents
[12:21:05] <ghrust> 13rust/06auto 141c527df 15Micah Chalmer: Indent correctly after opening square bracket
[12:21:06] <ghrust> 13rust/06auto 149ef0b9c 15Micah Chalmer: Allow indenting to align struct fields after curly brace
[12:21:08] *** Parts: ghrust (ghrust@24260B07.6A2AE50.F3114085.IP) ()
[12:21:32] <Thiez> hmmn, it seems 'rustpkg list' will list every file in ~/bin, even nonexecutable ones
[12:21:43] <dbaupp> Thiez: sounds like bug material?
[12:21:55] <Thiez> I'm just wondering what its intended behaviour is
[12:22:04] <Thiez> I don't think it should even be looking in ~/bin
[12:25:35] *** jorendorff_away is now known as jorendorff
[12:25:54] <dbaupp> yeah, definitely a bug, even just to get tjc to tell us what the behaviour should be :)
[12:27:01] <dbaupp> (cc catamorphism if you do open one)
[12:28:17] <Thiez> wouldn't it better for rustpkg to move to its own repo?
[12:28:21] <dbaupp> ok, yeah, I see it too, running rustpkg list in ~ is the same as ls ~/bin
[12:28:34] <dbaupp> probably not while the language is still so unstable
[12:29:32] *** Quits: Yurume (yurume@AC58A8CE.8A059B47.E313B915.IP) (Ping timeout)
[12:30:24] <dbaupp> (hm, I got close; the relevant bug from above is https://github.com/mozilla/rust/issues/5898)
[12:30:55] <Thiez> I guess I'll just wait for it to mature a bit more. I was considering moving rustray to rustpkg but if it can't even list the correct files it'll probably be an exercise in frustration :p
[12:32:01] <dbaupp> I dunno
[12:32:15] <dbaupp> I've got a few projects using rustpkg and it pretty much works
[12:32:44] <dbaupp> there's a significant few issues... e.g. can't build with optimisations; but other than that, nothings exploded yet
[12:33:14] <dbaupp> bjz is has converted all/most of his packages to rustpkg too
[12:33:18] <dbaupp> s/is //
[12:33:36] <nmatsakis> dbaupp: I think I have fixed all the repeated node-id issues
[12:33:39] <Thiez> building rustray without optimizations is not really an option, even for low resolutions compiletime+runtime is usually better with --opt-level 3 ;)
[12:33:56] <nmatsakis> dbaupp: thanks for the links, I was aware there various issues but I hadn't gathered them all, I am testing them now
[12:33:59] <Thiez> okay I'll have a look at those, see how much work it is.
[12:34:14] <dbaupp> nmatsakis: awesome! sorry for causing you issues. :)
[12:34:55] <dbaupp> nmatsakis: are you working on something with the CFG that gets totally confused by repeated ids?
[12:35:00] <nmatsakis> dbaupp: not to worry :) 
[12:35:06] <nmatsakis> dbaupp: yes precisely
[12:35:36] <nmatsakis> dbaupp: I've made some improvements to borrowck that are getting *very* confused by repeated node-ids (it also happened before, but not as frequently for some reason)
[12:35:51] <nmatsakis> dbaupp: as a positive side-effect, I found a ton of bugs and omissions in the AST folding code
[12:35:59] <nmatsakis> dbaupp: that is, portions of the AST that never got folded
[12:36:01] <dbaupp> Thiez: you can still build by running rustc directly, of course
[12:36:49] <dbaupp> nmatsakis: oh! :( it's amazing how much stuff is broken when it has no tests.
[12:37:11] * dbaupp is always surprised how much revision he has to do if he writes the tests second
[12:37:35] <dbaupp> nmatsakis: looking forward to an even better borrowck :)
[12:38:32] <nmatsakis> dbaupp: well -- these changes may make it a bit more annoying in some cases :( but it will be more correct... and it paves the way for fixing up the moves
[12:38:59] <dbaupp> nmatsakis: handling self.foo(self.bar()) too, or mostly little cleanups?
[12:39:12] <dbaupp> nmatsakis: fixing moves == not zeroing unnecessarily?
[12:39:41] *** Quits: squiddy (squiddy@moz-C983446B.adsl.alicedsl.de) (Input/output error)
[12:39:55] <nmatsakis> dbaupp: no, it doesn't handle that yet unfortunately
[12:40:09] <nmatsakis> dbaupp: yes, not zeroing unnecessarily, and probably being a bit more flexible too
[12:40:28] <nmatsakis> dbaupp: hopefully this'll mean faster build times, though that's ... unproven
[12:40:37] <nmatsakis> dbaupp: oh, and fixing temporary rvalue lifetimes too
[12:40:43] <nmatsakis> dbaupp: I think I can do that at the same time
[12:41:21] <nmatsakis> dbaupp: so there's at least one improvement that'll make things nicer to use :) -- but still a bit down the road
[12:41:40] <dbaupp> nmatsakis: yay! #3511 will be nice to close :)
[12:41:50] * dbaupp has certain bug numbers burned into his brain
[12:42:11] *** Joins: alex_abreu (alex@moz-7421D6C9.mc.videotron.ca)
[12:42:31] <dbaupp> nmatsakis: I would guess that doing fewer memsets (etc) would mean faster compiles, but it might be offset by having to do more expensive analyses?
[12:42:41] *** Quits: alex__ (alex@moz-7421D6C9.mc.videotron.ca) (Ping timeout)
[12:44:09] <nmatsakis> dbaupp: no, I don't think extensive new analyses are needed, just making better use of the results of the ones we already do
[12:44:16] <nmatsakis> ok, gotta go
[12:44:21] <dbaupp> nmatsakis: oh, even nicer :)
[12:46:37] *** Joins: squiddy (squiddy@moz-C983446B.adsl.alicedsl.de)
[12:47:55] *** Joins: Larry (larryfox@26EE99DC.88C61CC9.ECED8BE3.IP)
[12:51:23] <Thiez> can't compile librustc while running my browser... yay rustc memory usage :p
[12:51:59] *** Joins: mib_ewfdan (Mibbit@9BE26321.3E410295.CA6E2165.IP)
[12:52:01] <dbaupp> Thiez: fix it? :P
[12:52:14] * dbaupp should get cgroups set up so that he can actually measure it
[12:52:19] <dbaupp> cmr: ping
[12:52:30] <Thiez> I think there was a fix that brought it all the way down to 1400mb a while ago, but it regressed
[12:52:52] <dbaupp> yeah
[12:53:03] * dbaupp even filed a bug about the regression
[12:53:19] <Thiez> do you know what's causing it?
[12:53:23] <dbaupp> https://github.com/mozilla/rust/issues/8589
[12:53:24] <dbaupp> no idea
[12:53:32] <Thiez> can't open that until my compile completes :p
[12:53:35] <dbaupp> (actually, that's a lie)
[12:54:15] <Thiez> ah, visitor changes
[12:54:18] <dbaupp> yeah
[12:55:20] <dbaupp> it has met with no comment at all; so I imagine that it's slipped under the radar
[12:55:29] * dbaupp should post it to the mailing list
[12:55:42] <Thiez> I noticed back then but I have no idea how most of that code works
[12:55:55] <Thiez> the great advantage of compiling in a VM, you notice memory regressions ;)
[12:55:59] <dbaupp> haha
[12:56:23] <miza> i wonder where is the implementation of [x, ..N]
[12:56:32] <miza> i would like to see how is this implemented
[12:57:13] <dbaupp> Thiez: yeah, I'm pretty sure these memory regressions are normally just accidentally scoping something slightly wrong, so it lasts for the rest of the compiler process, rather than just the single analysis phase that needs it
[12:57:28] <dbaupp> (at least, that's what the one before this one was fixed by.)
[12:57:46] <dbaupp> miza: in what sense? the internal compiler implementation?
[12:58:25] <Thiez> dbaupp: I think bors should just reject any PR that increases RAM usage by more than 50MB unless it's told to make an exception
[12:58:28] *** Quits: Larry (larryfox@26EE99DC.88C61CC9.ECED8BE3.IP) (Quit: My MacBook Pro has gone to sleep. ZZZzzzâ€¦)
[12:59:32] <miza> dbaupp: just curious and i want to see how optimal is this?
[12:59:39] <dbaupp> Thiez: yeah, I definitely think that monitoring memory usage would be wonderful; I don't know if buildbot can do it though
[13:00:00] *** Quits: squiddy (squiddy@moz-C983446B.adsl.alicedsl.de) (Input/output error)
[13:00:07] <miza> dbaupp: how much is depended to the length
[13:00:11] <Thiez> that is a shame.
[13:00:15] <miza> is this looping N times?
[13:00:17] * dbaupp checks
[13:00:50] <Thiez> miza: you could just check the IR output and find out
[13:01:40] <Thiez> I think at some point rustc emitted c*N instructions for [x, ..N] but I'm not sure these days
[13:02:07] <dbaupp> miza: it is a loop
[13:03:30] <dbaupp> miza: this is the relevant bit of the compiler: https://github.com/mozilla/rust/blob/master/src/librustc/middle/trans/tvec.rs#L416-L460
[13:03:33] *** Joins: engla (engla@moz-DBD1D96E.cust.bredbandsbolaget.se)
[13:03:46] <miza> Thiez: what is IR output and how can i check it :p
[13:04:29] <dbaupp> miza: given [x, .. n]; it is emitting the LLVM IR for `v = [empty, empty, ..., empty]; i = 0; while i < n { v[i] = x; } return v;`
[13:04:39] <dbaupp> (basically)
[13:04:58] <Thiez> miza: rustc uses LLVM as a backend. It compiles rustc to IR, which stands for 'intermediate representation' (if I remember correctly) and is a low-level (assembly-like) language that LLVM compiles to actual machine code
[13:05:07] <Thiez> it compiles rust*
[13:05:34] <dbaupp> (it *does* compiles rustc to IR, when you're building the compiler :P )
[13:05:59] <miza> ok thanks guys
[13:06:01] *** Joins: jdsanders (Adium@moz-84CB7548.hlrn.qwest.net)
[13:06:51] <Thiez> I think with 'rustc --emit-llvm -S' you save the generated IR
[13:06:56] <Thiez> or perhaps it was --save-temps
[13:07:12] <Thiez> it's in 'rustc --help' somewhere :p
[13:07:28] <dbaupp> I think that --emit-llvm -S is the most userfriendly one
[13:07:50] <dbaupp> (I believe --save-temps emits everything in a binary format)
[13:08:21] <Thiez> how strange to see 'userfriendly' and the emission of assembly/IR in the same sentence
[13:08:47] <dbaupp> well; reading the binary bitcode is probably trickier :P
[13:09:41] <Thiez> I don't have to read it, I just stare at it menacingly until it reveals its secrets.
[13:09:55] <miza> --opt-level LEVEL   Optimize with possible levels 0-3
[13:10:00] <dbaupp> hahaha
[13:10:03] <miza> what is the diferent of levels?
[13:10:07] <Thiez> miza: larger is better
[13:10:14] <miza> more time to compile?
[13:10:15] <Thiez> 0 is almost no optimization, 3 is the most
[13:10:18] * dbaupp isn't menacing enough for anything to reveal any secrets
[13:10:29] <Thiez> yes, it compiles slower but the generated program usually runs faster
[13:10:30] <miza> why not always level 3 then?
[13:10:38] <miza> ah ok
[13:10:49] <dbaupp> (note that 2 is the most supported one, and is the same as `-O`; 3 can actually make programs run much much slower)
[13:11:32] <Thiez> ^ that should probably be considered a bug :p
[13:11:52] <Thiez> we don't have the option to optimize for size, do we?
[13:11:56] <dbaupp> yes; it's just something to be aware of
[13:11:59] <dbaupp> don't think so
[13:12:09] * dbaupp remembers seeing strcat open a bug about it
[13:12:13] *** Quits: gavinb (gavinb@moz-9EC182F0.lowrp3.vic.optusnet.com.au) (Quit: gavinb)
[13:12:39] *** jorendorff is now known as jorendorff_away
[13:12:45] *** Quits: KindOne (KindOne@90FCC87.7E8839F4.34F73994.IP) (Ping timeout)
[13:13:32] <dbaupp> hm, can't find an issue if he did open one
[13:14:09] <miza> i did a test with the level
[13:14:30] <miza> indeed level 3 is almost almost the same as 2
[13:14:46] <Thiez> https://github.com/mozilla/rust/issues/6925 <- it seems it is impossible for transmute to show up when profiling, I have achieved the impossible :D
[13:14:53] <miza> i could tell that 3 is a bit ms slower
[13:15:12] <mindcat> I have a enum, but how get a type slot number?
[13:15:20] <dbaupp> Thiez: is the testcase the entirety of rustray?
[13:16:18] <mindcat> or it does not exist?
[13:16:40] <Thiez> dbaupp: it's actually the rt-messaging-ping-pong.rs benchmark that brson uses to test messagepassing performance
[13:16:53] *** Joins: KindOne (KindOne@90FCC87.7E8839F4.34F73994.IP)
[13:17:12] <Thiez> it spends about 4% of the time in transmute on my system on --opt-level 3
[13:17:17] <Thiez> perhaps I should try with -O
[13:17:40] *** Joins: mib_1q27pf (Mibbit@moz-8A2D1B65.hsd1.ga.comcast.net)
[13:17:53] <Thiez> too bad it generates 37485 lines of IR :p
[13:17:55] <dbaupp> diff tells be the difference between 2 and 3 are 3 runs 4 extra passes: Promote 'by reference' arguments to scalars, Natural Loop Information, Scalar Evolution Analysis, SLP Vectorizer
[13:18:01] <dbaupp> *tells me
[13:18:41] <Thiez> okay so it shouldn't make a difference.
[13:18:53] <dbaupp> (rustc -Z print-llvm-passes, if you're interested)
[13:19:21] <Thiez> that is really cool.
[13:19:36] <dbaupp> Thiez: ah; are you just compiling that benchmark and running it under perf?
[13:19:41] * dbaupp experiments
[13:19:41] <Thiez> I am.
[13:20:29] <dbaupp> mindcat: what does "type slot number" mean?
[13:20:58] <Thiez> I have a slightly modified message-queue that is lockless but it only makes a 5% difference or so.
[13:21:09] *** Quits: six600110 (six600110@moz-2FA48202.neo.res.rr.com) (Ping timeout)
[13:21:12] <Thiez> messagepassing seems to be slow for other reasons.
[13:21:16] <dbaupp> I don't see transmute at all?
[13:21:20] <Thiez> you do not?
[13:21:27] * Thiez retries.
[13:21:41] <dbaupp> the port/chan we have currently allocates a box for each message
[13:21:43] <Thiez> my vanilla-rust compile is almost complete.
[13:22:00] <dbaupp> (which is reflected by free and malloc being 2nd and 3rd respectively)
[13:22:08] <Thiez> yes I am aware.
[13:22:20] <dbaupp> rt::comm::__extension__::try_send_inner is first for me
[13:22:27] <Thiez> dbaupp: what is the command line you used to compile?
[13:22:34] <dbaupp> rustc -O rt-....rs
[13:22:41] <dbaupp> with a plain rustc
[13:22:50] <dbaupp> 2bd628e
[13:23:11] <dbaupp> (only a few days old)
[13:23:40] <Thiez> I am on 124eb2119c
[13:24:02] <dbaupp> oh, wow; compiling with --opt-level=3 makes transmute second
[13:24:03] <dbaupp> !
[13:24:20] <Thiez> ah, transmute sucks with --opt-level 3
[13:24:59] <dbaupp> the PortOne glue_drop is first, then transmute, free, try_send_inner, try_recv, ...
[13:25:06] <dbaupp> *then
[13:25:29] <dbaupp> I wonder which pass is breaking things
[13:25:48] *** Joins: eholk (eholk@moz-F70D5031.hsd1.in.comcast.net)
[13:25:57] <Thiez> I also see unstable::atomics::atomic_load in perf, I think that should be inlined as well.
[13:26:33] <Thiez> and cast::transmute is still at 2.83% here.
[13:26:58] <Thiez> but that's on my custom build, plain master is almost done
[13:27:27] *** Quits: jclements (jclements@moz-9C0ABCFC.wireless.calpoly.edu) (Ping timeout)
[13:27:36] <Thiez> (my code does introduce some transmutes but like you said those should be noops)
[13:27:57] *** Joins: jclements (jclements@moz-9C0ABCFC.wireless.calpoly.edu)
[13:29:32] <dbaupp> hm, peculiar; I just tried again with -O, and transmutes are appearing there too now
[13:31:03] <dbaupp> but yeah, I'm pretty sure transmute should be compiling to either nothing at all, or a plain old bitcast (depending on the types)
[13:31:15] <mib_1q27pf> building on linux 64 just stopped working for me - llvm-mc has disappeared from Release+Asserts
[13:31:40] <dbaupp> mib_1q27pf: you may have to re-./configure?
[13:32:05] <dbaupp> (and/or run make twice... that sometimes seems to help)
[13:32:16] <mib_1q27pf> thanks - I have tried a couple of times...
[13:32:29] <mib_1q27pf> will try again - tried switching to clang as well.
[13:33:01] <dbaupp> ah; what's the error message?
[13:33:11] <mib_1q27pf> 127
[13:33:37] <dbaupp> heh, that's not so helpful. :)
[13:33:37] <mib_1q27pf> can't find llvm-mc in the Release+Asserts (tho it exists in other dirs in the repo).
[13:34:18] <mib_1q27pf> I'm doing a make clean && ./configure with no options - this is what i get for doing git pull too often :)
[13:35:00] <dbaupp> jclements: ping
[13:35:21] <dbaupp> mib_1q27pf: I've got no idea... hopefully someone else has a clue :)
[13:35:48] *** Joins: six600110 (six600110@moz-2FA48202.neo.res.rr.com)
[13:36:51] *** Quits: santiago (santiago@moz-8ADE82B4.socal.res.rr.com) (Connection reset by peer)
[13:37:08] *** Joins: santiago (santiago@moz-8ADE82B4.socal.res.rr.com)
[13:37:38] <mib_1q27pf> cool - I'm blowing away my repo and trying again in case it's caching something 
[13:38:18] *** Joins: Yurume (yurume@AC58A8CE.8A059B47.E313B915.IP)
[13:38:35] <mib_1q27pf> are most people using clang over gcc?
[13:38:58] <Thiez> I tried to compile with clang but it didn't work
[13:39:04] *** Joins: dew (Instantbir@moz-D2FA52B6.static.stls.mo.charter.com)
[13:39:34] *** Joins: enomado (nomad@DB5C5EEB.5ED34291.AB610CFE.IP)
[13:39:49] <Thiez> so I had to install gcc :(
[13:40:17] <dbaupp> Thiez: did you use ./configure --enable-clang ?
[13:40:18] *** Quits: dew1 (Instantbir@moz-D2FA52B6.static.stls.mo.charter.com) (Ping timeout)
[13:40:41] <Thiez> dbaupp: I think clang requires some files that are installed along with gcc
[13:40:49] <Thiez> some library
[13:40:52] <Thiez> I forgot the name
[13:41:18] <dbaupp> oh, ok
[13:41:29] * dbaupp just uses whatever the default is, which is presumably gcc
[13:41:37] <Thiez> ah, I think it is libstdc++
[13:41:46] <mib_1q27pf> I tried clang when my gcc stopped working, and it broke faster.
[13:41:50] *** Quits: nsf (nsf@moz-EEF3238A.convex.ru) (Quit: WeeChat 0.4.1)
[13:42:15] <Thiez> but they're writing their own version (libc++) so perhaps we'll be able to compile without a gcc install at some point :)
[13:43:49] *** Quits: jviereck (Adium@moz-58A87BA7.dip0.t-ipconnect.de) (Quit: Leaving.)
[13:44:55] <mib_1q27pf> my build says it's using gcc, then outputs a bunch of llvm compile lines.
[13:45:12] <Thiez> rustc builds LLVM
[13:45:21] <Thiez> as part of its own compilation
[13:45:38] <mib_1q27pf> cool.
[13:45:49] <Thiez> we have some llvm-patches that haven't been adopted upstream yet, so we build our own version
[13:46:46] *** Quits: mib_ewfdan (Mibbit@9BE26321.3E410295.CA6E2165.IP) (Quit: http://www.mibbit.com ajax IRC Client)
[13:46:53] <mib_1q27pf> ah, nice.  has anyone ported the manual to other formats?  would be nice to have an epub for ereaders.
[13:47:24] <Thiez> not as far as I'm aware, but I don't own an ereader so I'm not the right person to ask :p
[13:47:52] <mib_1q27pf> fair enough.
[13:48:03] <Thiez> the manual isn't that good anyway
[13:48:03] <dbaupp> it's written in markdown; so pandoc should be able to magic that into any format you want
[13:49:15] <bjz> dbaupp: bugger was just about to say that :)
[13:49:28] <bjz> mib_1q27pf: pandoc is pretty awesome at that stuff
[13:49:30] <Earnestly> mib_1q27pf: pandoc -f markdown -t epub(3) input.md input.md etc.md -o book.epub
[13:50:04] *** Quits: jdsanders (Adium@moz-84CB7548.hlrn.qwest.net) (Quit: Leaving.)
[13:50:37] * bjz claps Earnestly
[13:50:40] <bjz> hey, that makes sense
[13:51:29] <Earnestly> mib_1q27pf: I even made a silly cover and a custom css which includes a nice monospace font (Latin Modern Mono)
[13:51:33] <Earnestly> http://a.pomf.se/8Gr7.svg heh
[13:53:04] *** Joins: tiffany (kawaii@moz-EB8B0C08.dhcp.embarqhsd.net)
[13:53:06] * dbaupp twitches at the slightly off centre title text :P
[13:53:33] <Earnestly> dbaupp: Not according to the inkscape rulers
[13:54:26] <dbaupp> weird, the R end definitely looks like it extends less far than the ual end
[13:54:41] <dbaupp> (maybe it's the picture that's offset then)
[13:55:23] <Earnestly> mib_1q27pf: Sort of messing about: (all it requires is the rust.md from git every now and then) http://filebin.ca/uCvebmrJWGP/rust_manual.tar.bz2
[13:56:43] <ChrisMorgan> In the makefiles, what is $(1)?
[13:56:53] <dbaupp> bjz: did you end up converting all your repos to rustpkg?
[13:57:00] <Earnestly> dbaupp: The nicest thing about pandoc markdown is it converts " to â€œ and â€ and ' to â€˜ and â€™ with the -S option (--smart)
[13:57:08] <dbaupp> ChrisMorgan: isn't the first arg of the make "function"
[13:57:12] <dbaupp> ?
[13:57:30] <Earnestly> ChrisMorgan: #workingset on freenode might be helpful
[13:57:30] <ChrisMorgan> That was my guess, but how is that figured out? Where does it come from?
[13:58:32] * dbaupp has no idea
[14:00:20] <bjz> Earnestly: the thing about typography, and pretty much all design, is that no matter how mathematically correct your alignment/sizing/etc. is, if it looks wrong it *is* wrong
[14:00:52] <bjz> Earnestly: you have to deal with lots of optical illusion stuff
[14:01:05] <Earnestly> bjz: I'm aware.  The italics is what's causing this
[14:01:48] <dbaupp> bjz: just need a different model of mathematically correctness ;)
[14:02:40] <bjz> dbaupp: it'd have to take into account all the fuzziness, compelxity and bugs that have accumulated in the brain :P
[14:02:47] <Earnestly> Besides, I already accounted for that and the text is aligned /slightly/ more to the left.
[14:03:08] <ChrisMorgan> Earnestly: ##workingset answered satisfactorily very quickly :-)
[14:03:30] <Earnestly> ChrisMorgan: It's the channel for these sorts of questions, makefiles, autoconf, etc.
[14:03:31] *** Joins: dherman (dherman@moz-6CA476B1.hsd1.ca.comcast.net)
[14:03:31] *** ChanServ sets mode: +ao dherman dherman
[14:03:45] <dbaupp> bjz: the word "just" is amazing at papering over non-trivial problems :P
[14:03:47] <ChrisMorgan> So I see. Very good, I shall record it for later reference.
[14:03:59] <bjz> dbaupp: ^^,
[14:04:09] <dbaupp> ChrisMorgan: what's the answer?
[14:04:46] <dbaupp> bjz: the other solution would be to fix the bugs :P
[14:05:01] <ChrisMorgan> dbaupp: $(1) etc. can be arguments, when you get $(call thing,args)
[14:05:26] <bjz> dbaupp: typography is pretty neat once you start going into it. a mathematical 'S' looks really top-heavy, and leaning over
[14:05:58] <dbaupp> bjz: a mathematical 'S'?
[14:06:14] <dbaupp> ChrisMorgan: ah, so it's `call` that does the magic?
[14:06:39] <dbaupp> bjz: you don't mean an integral sign, do you? :P
[14:06:44] <bjz> dbaupp: well one where the top bowl is the same size as the bottom. sorry, not a very rigourous description
[14:07:10] <ChrisMorgan> dbaupp: yeah; so then the rules get put inside a `define` block and you have something like this from rt.mk: $(foreach stage,$(STAGES), $(foreach target,$(CFG_TARGET_TRIPLES), $(eval $(call DEF_RUNTIME_TARGETS,$(target),$(stage)))))
[14:07:24] <bjz> dbaupp: maybe it would have been better to say, 'geometric' :)
[14:07:28] <dbaupp> bjz: I see; I'd imagine it'd look weird
[14:07:28] <ChrisMorgan> (The latter parts I figured out on my own; once call is explained, the rest follows.)
[14:07:53] <dbaupp> ChrisMorgan: ah, so that creates all the rules?
[14:07:57] <ChrisMorgan> Yep.
[14:08:29] * dbaupp is looking forward to the day when rustpkg replaces the makefiles
[14:08:41] <bjz> dbaupp: Os always look too small. basically anything round has to be bigger than you think. and where things join you have to make things thinner, because they look too heavy otherwise
[14:08:46] * dbaupp has a feeling this day will be never
[14:08:53] <bjz> dbaupp: anyway, re: rustpkg
[14:09:06] <bjz> dbaupp: not yet, but my most used ones yes
[14:09:13] <Earnestly> bjz: http://www.rastertragedy.com/
[14:09:17] *** Quits: dherman (dherman@moz-6CA476B1.hsd1.ca.comcast.net) (Quit: dherman)
[14:09:30] <ChrisMorgan> dbaupp: you'd still probably get a makefile to download a rustpkg snapshot to do the rest.
[14:10:06] <bjz> Earnestly: neat!
[14:10:09] <Earnestly> bjz: Did you know that Courier was designed in 1955, Garamond in 1916, etc.
[14:10:34] <dbaupp> ChrisMorgan: yeah, and coordinating the external non-rust builds
[14:10:50] <ChrisMorgan> dbaupp: let's assume rustpkg can manage them.
[14:10:51] <dbaupp> (although I had a feeling that the plan was for rustpkg to handle C libs too)
[14:11:02] <dbaupp> ChrisMorgan: hopefully
[14:11:04] <bjz> bjz: aye. used to study graphic design
[14:11:08] <dbaupp> bjz: cool
[14:11:12] <bjz> * Earnestly
[14:11:16] <Earnestly> bjz: RT is a nice website as it also includes interactive demonstrations and has evolved to serve as pretty much the canonical source for information on hinting
[14:13:11] <bjz> Earnestly: the challenge is to separate separate out what's 'true' and not just accumulated tradition when it comes to graphic design.
[14:13:37] *** Joins: jfbk (jfbk@moz-EEA9CFB3.nyc.res.rr.com)
[14:14:50] <Yurume> anyone called me?
[14:14:57] <dbaupp> bjz: that's the challenge with everything
[14:15:15] <bjz> dbaupp: oh so true.
[14:17:51] *** Joins: feduser (feduser@1FEEBA37.894E1D07.8D466B92.IP)
[14:19:59] *** Quits: dew (Instantbir@moz-D2FA52B6.static.stls.mo.charter.com) (Ping timeout)
[14:20:42] <mindcat> http://paste.ubuntu.com/6074985/ "for i in [1,2,3,4].each" it is not work
[14:21:40] *** Quits: ChrisMorgan (chris@moz-6AC741CA.static.tpgi.com.au) (Ping timeout)
[14:21:47] *** Joins: squiddy (squiddy@moz-C983446B.adsl.alicedsl.de)
[14:23:17] <dbaupp> mindcat: each was removed months ago; it'd have to be `for &i in x.iter()`
[14:23:47] <mindcat> dbaupp: oh
[14:25:20] <dbaupp> mindcat: are you reading a tutorial/example code?
[14:25:51] *** Quits: Earnestly (earnest@moz-DAE7D1AD.dyn.plus.net) (Input/output error)
[14:25:55] *** Joins: Earnestly (earnest@moz-DAE7D1AD.dyn.plus.net)
[14:26:31] <mindcat> dbaupp: where? do you mean "http://static.rust-lang.org/doc/tutorial.html"
[14:28:03] <dbaupp> mindcat: I mean, did you copy vec.each out of some other code?
[14:29:31] *** Quits: squiddy (squiddy@moz-C983446B.adsl.alicedsl.de) (Input/output error)
[14:30:17] <mindcat> dbaupp: I didn't, but I see that before
[14:32:49] <olsonjeffery> SimonSapin: ping
[14:33:00] <SimonSapin> olsonjeffery: pong
[14:33:20] <olsonjeffery> howdy.. how familiar are you w/ rust-encoding? i see you have a PR and issues in
[14:33:54] <SimonSapin> Somewhat. What about it?
[14:34:27] <olsonjeffery> im evaluating it to see if we can pull some of it (at least ascii and utf8) into std
[14:35:10] <olsonjeffery> im working on getting in touch w/ lifthrasiir right now
[14:35:25] *** Joins: nsf (nsf@moz-EEF3238A.convex.ru)
[14:35:34] <SimonSapin> for now I think it makes sense to keep it a separate project
[14:35:42] <SimonSapin> so that it can be updated without updating rust
[14:35:59] <olsonjeffery> well having *some* encodings in std is high-priority for the project
[14:36:25] <olsonjeffery> as backing impls for a TextStream trait that would sit on type of a raw Stream
[14:36:34] *** Quits: igl (igl@moz-FEE1DF38.adsl.alicedsl.de) (Ping timeout)
[14:37:04] *** Joins: igl (igl@moz-4801663D.adsl.alicedsl.de)
[14:37:10] *** Quits: jclements (jclements@moz-9C0ABCFC.wireless.calpoly.edu) (Ping timeout)
[14:37:54] <olsonjeffery> if anything, an Encoding trait will be added to std::rt::io that generalizes the encoding task
[14:38:06] <olsonjeffery> and the various encodings would impl that trait.. so they could stay out of tree, for the most part
[14:38:10] *** Joins: jclements (jclements@moz-9C0ABCFC.wireless.calpoly.edu)
[14:38:36] <olsonjeffery> but, there is a subset of encodings that do need to be in-tree.. probably ascii, utf8 and utf16
[14:38:41] <SimonSapin> designing a solid API is definitely important
[14:38:53] <olsonjeffery> not hard..
[14:39:16] <SimonSapin> supporting different kinds of error handling may not be obvious
[14:39:38] *** Joins: jviereck (Adium@moz-58A87BA7.dip0.t-ipconnect.de)
[14:39:42] <SimonSapin> not sure how I feel about TextStream
[14:39:50] <SimonSapin> especially if itâ€™s seekable
[14:40:14] <olsonjeffery> seekability is an artifact of the underlying impl
[14:40:27] <olsonjeffery> and it should be noted at Stream impls Reader+Writer
[14:40:28] <olsonjeffery> not Seek
[14:40:33] <engla> using conditions may add too much overhead to decoding. Might be better to just specify error handling when instantiating the decoder
[14:40:39] <olsonjeffery> so thats orthogonal
[14:40:49] <olsonjeffery> but the point about error handling in different encodings is valid
[14:41:25] <SimonSapin> is std::rt::io different from std::io? I donâ€™t find it in the docs
[14:41:35] <olsonjeffery> engla: do you mean assuming there are lots of errors to handle? conditions don't have overhead (besides the wrapper) unless you hit the error path..
[14:41:50] <olsonjeffery> SimonSapin: std::rt::io is in "newrt"
[14:42:02] <olsonjeffery> i think its in the rustdoc_ng docs..
[14:42:07] <olsonjeffery> or you can just look in the src
[14:42:11] <engla> hm ok, yeah my testcases have been on input where there are errors to handle
[14:42:13] <SimonSapin> ...
[14:43:00] <engla> olsonjeffery: I think possibly raising a condition inside the decoder has implications for the optimizer though
[14:43:39] <engla> with a ReplaceDefault error handler you have no possibility of fail()/condition raised inside the decoder loop so it should generate much better code
[14:43:46] <SimonSapin> Iâ€™m not looking forward to do read and write (decode and encode) on the same stream either
[14:43:50] <SimonSapin> especially with BOM detection
[14:44:57] <olsonjeffery> well tcp is full-duplex. that's a fact of life. file io, at least, can be access controlled.
[14:45:07] <olsonjeffery> so you get just a Reader or Writer or Both
[14:45:32] *** Joins: sinma (sinma@moz-6A11C47C.fbx.proxad.net)
[14:45:40] <sinma> Hi
[14:45:53] <SimonSapin> I believe that encodings should not be tied to IO
[14:46:20] <SimonSapin> I donâ€™t think it makes sense to read or write Unicode directly from TCP
[14:46:24] <sinma> Iâ€™m using Rust master branch and my for loops donâ€™t work (for i in (0, 100) or for i in [0, 100])
[14:46:35] <SimonSapin> all protocols I can think of are based on bytes, and decode to Unicode later
[14:46:48] <sinma> It says: Â«error: type `&mut [<VI1>, .. 2]` does not implement any method in scope named `next`Â»
[14:47:11] <engla> say reading text files, the user will want to get a file object, with a buffer, with an encoder/decoder?
[14:47:27] <engla> sinma: you must request an iterator explicitly, like  [0, 100].iter()
[14:47:27] <bjz> sinma: you need .iter()
[14:47:36] <sinma> ok thx very much
[14:48:23] *** Quits: austincheney (quassel@8276C73B.985A737F.603BFF2.IP) (No route to host)
[14:48:32] *** Quits: jviereck (Adium@moz-58A87BA7.dip0.t-ipconnect.de) (Quit: Leaving.)
[14:48:50] <bjz> sinma: that returns a struct that maintians the state of the iterator. the struct gets optimised out at compile time
[14:48:51] <dbaupp> sinma: you'll probably also need to save the array into a temporary, i.e. `let v = [0, 100]; for i in v.iter()`
[14:49:05] <dbaupp> sinma: (this is a bug)
[14:49:41] <sinma> Yes, thereâ€™s a bug
[14:49:47] <sinma> thx to pointing it out
[14:49:59] <bjz> sinma: there are quite a few iterators, including .rev_iter() and .mut_iter(), and they can be chained together in useful ways
[14:50:01] <sinma> I was wondering what I was doing wrong this time
[14:50:09] <dbaupp> https://github.com/mozilla/rust/issues/3511 if you're interested
[14:50:40] <SimonSapin> Reader.read(buf) reads up to the length of buf, easy. How does TextReader.read() know how bytes it should read, for variable-width encodings?
[14:50:50] <dbaupp> sinma: also, the vector iterator yields references into the vector (i.e. a [T] gives &T), so i will have type &int, not int.
[14:51:15] <dbaupp> sinma: you can use `for &i in v.iter()` to pattern-match to get i to be an int
[14:51:36] <sinma> Can i use an uint?
[14:51:45] <SimonSapin> Iâ€™m much rather have decoders/encoders with .feed() and .flush() like rust-encoding does now, and maybe add IO sugar later
[14:51:53] <bjz> dbaupp: is there an issue regarding improving the error for: Â«error: type `&mut [<VI1>, .. 2]` does not implement any method in scope named `next`Â»
[14:51:57] <dbaupp> sinma: yeah, sure
[14:52:08] <dbaupp> bjz: dunno about issue; but it's a known problem
[14:52:18] <dbaupp> bjz: I have a feeling bstrie opened one(?)
[14:52:23] <bjz> dbaupp: should be something like "Does not implement Iterator" or something
[14:52:28] <sinma> dbaupp: I donâ€™t understand what you said about &i
[14:52:32] <kimundi> sinma: the int in this case is just the type of the elements you're iterating over. if you something like [1 ,2 ,3] the numbers default to int
[14:52:53] <engla> SimonSapin: iterator-based it could be easier, you just pull everything byte by byte from the reader and the decoder yields char? but it doesn't sound efficient
[14:52:56] <dbaupp> sinma: let v = [0u, 100] will force them to be uint; but often the inference will make this unnecessary
[14:53:18] <olsonjeffery> SimonSapin: no one is saying that
[14:53:22] <dbaupp> sinma: (i.e. rustc can work out from the places you use `i` that it needs to be a uint, sometimes this isn't possible)
[14:53:28] <SimonSapin> engla: byte-by-byte is definitely too slow
[14:53:30] *** Joins: jdsanders (Adium@moz-84CB7548.hlrn.qwest.net)
[14:53:41] <sinma> dbaupp: you said that Â«[1,2,3] the numbers default to intÂ»
[14:53:55] <SimonSapin> iterators of "chuncks" could work
[14:53:57] <sinma> So in this case itâ€™s necessary, right?
[14:53:58] <dbaupp> sinma: (kimundi said that), but yes
[14:54:11] <SimonSapin> itâ€™s "push" vs. "pull", just like external vs. internal iterators
[14:54:17] <sinma> ooops sry, wong line Ì‚Ì‚
[14:54:26] <kimundi> engla: I have no idea about the design space, but would it be possible to design it so that you have a trait with two default methods, one that works with char and one that works with u8? And then impl one or both depending on what would be the fastest.
[14:54:27] <dbaupp> sinma: that is, if there are no other clues then a literal integer will be assumed to be an int
[14:54:36] <engla> SimonSapin: is it definitely? With a buffering layer beneath
[14:54:37] <olsonjeffery> encoders themselves would've be tightly bound to io
[14:54:54] <sinma> Thatâ€™s why I think itâ€™s better to tell the compiler the type
[14:55:07] <dbaupp> sinma: but if there are clues, then it can infer to be something else (e.g. `vector.len() + i` => i is a uint, because len returns a uint)
[14:55:26] <dbaupp> sinma: yeah, sure
[14:55:50] <SimonSapin> engla: well, "too slow" is subjective, and Iâ€™m confident that a function call for each byte would be significantly slower than passing around big buffers
[14:55:52] <kimundi> sinma: which you can do by either giving one of the elments a concrete type. ( like [ 1_u16, 2, 3]) or using the vector in a way that makes it infer the right type
[14:55:55] *** Joins: Sorella (queen@9D963F5D.DF5D8AE7.54BCAB54.IP)
[14:56:24] <engla> SimonSapin: it doesn't have to compile into a function call per byte (I hope)
[14:56:34] <sinma> kimundi: yeah thatâ€™s what Iâ€™ve understand
[14:58:26] <sinma> my code just go to 0 from 100!
[14:58:49] <sinma> let vec = [1u, 100]; for i in vec.iter() { â€¦ }
[14:59:20] <dbaupp> sinma: are you trying to iterate over 0, 1, 2, ..., 100?
[14:59:23] <sinma> yes
[14:59:32] <dbaupp> you need range()
[14:59:45] <dbaupp> [1,100].iter() will just give 1, 100
[14:59:59] <dbaupp> i.e. for i in range(start, stop) { ... }
[15:00:03] <kimundi> actually it will give you &1 and &100 here ;)
[15:00:38] <sinma> Way nicer
[15:00:42] <kimundi> for i in range(0,101) { ... } // for 0 till 100
[15:01:28] <sinma> Works very well
[15:03:09] <bjz> dbaupp: we at least need range in the Tute right?
[15:03:49] *** Quits: drrb (drrb@4D561226.896EE5A.377B9828.IP) (Quit: drrb)
[15:03:54] <bjz> dbaupp: I imagine folks would scan it, trying to figure out how to iterate
[15:04:04] <kimundi> the tutorial needs a lot of things. like the new formating stuff
[15:04:09] <bjz> yeah
[15:04:14] <bjz> so much to do
[15:04:15] <dbaupp> std::iterator::range_inclusive(0, 100) { ... } also
[15:04:52] <dbaupp> bjz: http://static.rust-lang.org/doc/tutorial-container.html#for-loops
[15:04:53] <sinma> dbaupp: a bit long though :p
[15:05:00] <engla> just say range(0, 101)
[15:05:24] * dbaupp doesn't quite understand why range is mentioned first, despite being the discouraged in most situations
[15:05:31] <dbaupp> *discouraged method
[15:05:33] *** Joins: jstevans (Instantbir@7994AFA1.362CC69C.B7830B68.IP)
[15:05:36] <bjz> dbaupp: yeah I know, but in the main tutorial is important, maybe with a link at the end to the in-depth tutorial
[15:05:42] <kimundi> it needs to prominently cover "(&[T]).iter() gives you &T; (&[T]).mut_iter() gives you &mut T and (~[T]).move_iter() gives you T"
[15:05:43] <dbaupp> bjz: take it up with strcat
[15:05:47] <bjz> dbaupp: sure
[15:05:48] <engla> dbaupp: range is discouraged?
[15:06:02] <dbaupp> engla: yeah, use the vec (etc) iterator
[15:06:12] <bjz> dbaupp: yeah, sorry, not complaining or anything
[15:06:22] <engla> ah of course. But range is encouraged if you want a numeric loop
[15:06:49] <dbaupp> engla: right
[15:07:06] * dbaupp is very sensitive about people indexing a vec when they should be iteratoring it
[15:07:11] <engla> the halfopen interval logic of range(a, b) also corresponds to how v.slice(a, b)  works so it's nice
[15:07:35] <dbaupp> sinma: the point of range_inclusive is it has correct overflow behaviour with the finite integer types
[15:07:40] <engla> dbaupp: as you know, an integer is immediately convertible into either a &T *or* &mut T, so sometimes it's more convenient than iterators :)
[15:08:08] <dbaupp> sinma: i.e. range(0u8, 256u8) doesn't work for iterating 0, 1, ..., 255, since 256u8 == 0
[15:08:23] <dbaupp> engla: true
[15:08:24] <sinma> dbaupp: ok
[15:08:32] <engla> dbaupp: see for example hashmap => FoundEntry(uint) :-(
[15:09:05] <sinma> so itâ€™ll better if range is inclusive by default, right?
[15:09:23] <miza> i have in the same directory, a.rs, b.rs, main.rs, a and b has a stack and an implentation (strcut A, struct B)
[15:09:23] <miza> in main i do use a::A;pub mod a; and it works ok
[15:09:23] <miza> in a i do use b::B;pub mod b; and i got error: unresolved import. maybe a missing 
[15:09:29] <miza> any idea?
[15:10:09] *** Joins: jdm (jdm@92FB48CA.8B5E9DF.9A8C35B4.IP)
[15:10:09] *** ChanServ sets mode: +o jdm
[15:10:47] <kimundi> "If you need to iterate over a interval of numbers, range(starte, end) is encouraged. Note however that you very seldom need to actuality do that, as the most common usage for that pattern in other languages - generating indices for iterating over some kind of collection - is handled by iterators for those collections."
[15:11:05] <engla> sinma: no. range is good as it is, see the comparison to .slice()
[15:12:31] *** Joins: glyc (Mibbit@moz-20CEEF38.hsd1.ca.comcast.net)
[15:12:37] <kimundi> miza: use paths are allways global paths
[15:12:48] <dbaupp> miza: yes, you need either `use self::b::B` or `use a::b::B`
[15:13:17] <kimundi> miza: in your case, your crate looks like ROOT{ mod a{ mod b{ ... } } }, so it should be 'use a::b::B'
[15:13:32] <kimundi> or self::b::B; as dbaupp said
[15:13:32] <glyc> Open question: is there a C-header helper, like to h2rs, to make it easy to call into a c library... or some way to #include with rust translation?
[15:13:43] <sinma> engla: so thereâ€™s no solution?
[15:14:08] <dbaupp> glyc: rust-bindgen
[15:14:09] <kimundi> glyc: there is rust-bindgen, but you need to ask someone else where to find it and how it works :P
[15:14:18] <dbaupp> glyc: https://github.com/crabtw/rust-bindgen
[15:14:23] <kimundi> sinma: solution for what?
[15:14:35] <dbaupp> glyc: you'll still need to ask someone else how it works :P
[15:14:37] <glyc> dbaupp, kimundi: I'll checkout rust-bindgen, thanks!
[15:14:46] <glyc> :-)
[15:15:22] <kimundi> glyc: There are also vague plans to have that functionality build into the compiler in the future
[15:15:36] <glyc> kimundi: that would be elegant indeed
[15:15:37] *** Joins: jviereck (Adium@moz-58A87BA7.dip0.t-ipconnect.de)
[15:15:47] <sinma> kimundi: thereâ€™s std::iterator::range_inclusive but itâ€™s a bit long â€” tought itâ€™s not used very frequentlyâ€¦
[15:16:13] *** Quits: cdidd (cdidd@moz-3C04A381.broadband.corbina.ru) (Ping timeout)
[15:16:20] <kimundi> of course, there are non triviola problems, like c macros and deciding what's safe to use etc
[15:16:28] <glyc> kimundi: it would be nice to be able to say:  #cimport "my_c_library_header.h" in rust
[15:17:31] <glyc> kimundi: macros that don't do token pasting could just be turned into inline functions (99% cases)
[15:18:01] <kimundi> sinma: I would just use the right one of range and range_inclusive depending on what you need. You just need to import range_inclusive into local scope, while range is imported per default
[15:18:03] <glyc> kimundi: err... I should say, rust macros?
[15:18:04] <engla> sinma: solution to what?
[15:19:52] <kimundi> glyc: the problem is deciding what they do, and how to handle them etc. some macros are really just inline-always functions, some could be expressed as an rust macro, and some are just not translateable as they can produce invalid things
[15:19:52] <glyc> hmm... bindgen doesn't have a Makefile or a configure... any idea how to build it with just .rs files?
[15:20:08] <miza> aah mod includes my code inside a, so i have to use as you said
[15:20:22] <kimundi> glyc: In general, locate the file that contains the crate root, and just rustc foo.rs it
[15:20:57] <kimundi> miza: right
[15:21:38] <glyc> kimundi: is the crate root the short bindgen.rs file that starts with: #[crate_type = "bin"];
[15:22:49] <dbaupp> glyc: yes
[15:24:07] <glyc> hmm I'm trying rustc bindgen.rs ; but I get unresolved name ast::MutMutable 
[15:24:50] <dbaupp> ah, it hasn't been updated for the latest changes :(
[15:24:54] <kimundi> are you using current git trunk rust?
[15:25:02] <glyc> kimundi: yes
[15:25:06] <dbaupp> kimundi: another complaint about your sedding :P
[15:25:11] <dbaupp> (well, ruby-ing)
[15:25:19] <kimundi> dbaupp: actually, that error mesage implies the opposite. It got updated, but the installed rustc is still old
[15:25:29] <dbaupp> kimundi: ah
[15:25:30] <kimundi> strange...
[15:25:42] <dbaupp> glyc: `rustc -v` says?
[15:25:43] <glyc> kimundi: well, my rustc might be 2 days old...
[15:25:45] <kimundi> glyc: could you paste the full error message?
[15:25:55] <glyc> rustc 0.8-pre (bb35e23 2013-08-30 21:40:32 -0700)
[15:26:04] <dbaupp> that's a week old :P
[15:26:05] <glyc> kimundi: yes, just sec
[15:26:05] <kimundi> the change is from... I  think monday
[15:26:17] <kimundi> that explains it ;)
[15:26:19] <glyc> kimundi: lol, okay, I'll update rustc, just sec...
[15:26:28] <kimundi> sure, take your time
[15:26:30] <glyc> love the pace of change, seriously
[15:26:35] <glyc> it's great
[15:26:55] <kimundi> indeed
[15:28:22] <glyc> kimundi: while that's building, couldn't many of the macro issues be resolved simply by pre-processing the headers first, like the output of gcc -E
[15:28:58] *** Joins: cubic (cubic@moz-FE5AD6C7.mc.videotron.ca)
[15:29:14] <sinma> I have a Some(int) type and I want to check if itâ€™s an int
[15:29:25] <sinma> is it possible?
[15:29:57] <glyc> kimundi: I know that macro-preprocessing wouldn't handle the cases where client code is supposed to use macros, but it should get things down to intrinsic types at the ABI interface to the C library
[15:29:57] <sinma> I do: Â«let nbr = std::int::from_str(std::io::stdin().read_line());Â» and I get Some() in return
[15:30:57] <sinma> I think I might use match
[15:31:00] *** Joins: cdidd (cdidd@moz-A045BC3D.broadband.corbina.ru)
[15:31:02] <sinma> But I donâ€™t see how
[15:32:24] <glyc> btw, this is not a big complaint, but with the rapid pace of change and the obsolescence (sp?) of 0.7, wouldn't it be easier just to drop the 0.7 docs from the website. More than half the time I can't use google to search for stuff about rust because I get misled when it lands on old and out-of-date docs.
[15:32:48] <glyc> just a newbie perspective on maintaining 2 versions of docs
[15:33:08] <dbaupp> sinma: `match nbr { Some(x) => { /* x is the int */ } None => { /* couldn't parse an int */ } }`
[15:33:18] <engla> there is also the version 0.4 docs laid out as a trap glyc 
[15:33:25] <dbaupp> and even older
[15:33:28] <glyc> engla: indeed
[15:33:32] <dbaupp> they look so strange
[15:33:47] <sinma> dbaupp: has simple has that? great
[15:34:05] <glyc> engla: it would make sense if 0.7 was stable, but as far as I can tell there's no reason whatsoever to be on 0.7... master is what new people should use
[15:34:17] <engla> yes
[15:34:32] <engla> there is that college class that's using 0.7 though
[15:34:39] <glyc> engla: why?
[15:34:40] *** Joins: jmgrosen (jmgrosen@moz-848F6087.sb.sd.cox.net)
[15:34:52] <dbaupp> glyc: 0.7 is a "stable" point of reference
[15:35:25] <dbaupp> glyc: i.e. it's essentially just specifying a specific git hash to use because the class needs to be standardised on something
[15:35:31] <dbaupp> and a version sounds cooler, I guess?
[15:35:59] <glyc> dbaupp: those "stable" quotes should be large
[15:36:05] <sinma> dbaupp: I want to do nothing, but thereâ€™s no break for match. Any idea?
[15:37:23] <dbaupp> glyc: stable in the sense that it's not a moving target like HEAD
[15:37:35] <dbaupp> sinma: match { ... None => {} }
[15:38:24] <sinma> ok thx
[15:40:49] *** Quits: donri (dag@moz-9BB61102.tbcn.telia.com) (Client exited)
[15:41:27] *** Joins: donri (dag@moz-9BB61102.tbcn.telia.com)
[15:42:50] <sinma> match is really a killer feature of Rust
[15:43:12] <glyc> sinma: I'm new to match, could you elaborate?
[15:43:28] *** Joins: dherman (dherman@moz-6CA476B1.hsd1.ca.comcast.net)
[15:43:28] *** ChanServ sets mode: +ao dherman dherman
[15:43:39] <sinma> match check if you donâ€™t forget some cases
[15:43:50] <glyc> sinma: nice
[15:44:23] <glyc> sinma: ocaml people really like that they can change an enum in one place, and the compiler tells them all the other places they need to fix
[15:44:36] <miza> As i read in Rust description, rusts supports metaprogramming
[15:44:42] <glyc> sinma: I assume its the same in rust
[15:45:00] <dbaupp> glyc: yes; and it's amazing
[15:45:01] <sinma> You can match var in tuples and struct
[15:45:05] <miza> could you show me with a small examble or in existed code in github
[15:45:07] <miza> how it works
[15:45:20] *** Quits: jdsanders (Adium@moz-84CB7548.hlrn.qwest.net) (Quit: Leaving.)
[15:45:29] * dbaupp has made some ridiculous renaming changes affecting the whole code base and got told exactly where things were missing
[15:45:30] *** Joins: brine (Mibbit@moz-CF697891.tampfl.fios.verizon.net)
[15:45:31] <glyc> miza: this? http://static.rust-lang.org/doc/tutorial-macros.html
[15:45:39] <mindcat> I get lots "error: cannot move out of dereference of & pointer", how fix it? http://paste.ubuntu.com/6075295/
[15:45:51] <miza> glyc: thanks
[15:46:05] <ski> (glyc : also SML)
[15:46:22] <glyc> ski: yes
[15:46:22] <dbaupp> mindcat: match like `ref x` for anything variant that has a ~ in it
[15:47:01] <mindcat> dbaupp: ok
[15:47:16] <sinma> glyc: and match is very handy to handle errors and None
[15:47:29] <dbaupp> mindcat: and don't iterate with `for &i in x.iter()` for [Tag] or [Tags]
[15:48:02] <dbaupp> mindcat: and `let n = i.name;` needs to be `let n = &i.name;` (and similarly for `d`)
[15:48:09] <glyc> arg.  I did a make clean and now all of llvm is rebuilding. drat. Have the rust-specific llvm changes made it into llvm HEAD yet?
[15:48:25] <dbaupp> glyc: nope
[15:48:29] <dbaupp> glyc: do you have ccache?
[15:48:44] <glyc> dpaupp: don't know what ccache is
[15:48:49] <mindcat> dbaupp: ok...
[15:48:56] <dbaupp> https://github.com/mozilla/rust/wiki/Note-ccache it makes llvm builds much faster
[15:49:09] <dbaupp> PSA: use ccache if you can
[15:49:15] <glyc> dbaupp: whoa, sweet
[15:50:14] * dbaupp -> bed
[15:50:15] *** Quits: brine (Mibbit@moz-CF697891.tampfl.fios.verizon.net) (Quit: http://www.mibbit.com ajax IRC Client)
[15:51:28] *** Joins: jdsanders (Adium@moz-84CB7548.hlrn.qwest.net)
[16:01:20] *** Quits: nsf (nsf@moz-EEF3238A.convex.ru) (Quit: WeeChat 0.4.1)
[16:02:42] *** Joins: itdaniher (it@moz-6C3ABA7E.bstnma.fios.verizon.net)
[16:04:11] *** Joins: igl1 (igl@moz-3CB2D632.adsl.alicedsl.de)
[16:04:34] *** Quits: igl (igl@moz-4801663D.adsl.alicedsl.de) (Ping timeout)
[16:07:01] <glyc> strange, on rebuild with ccache and clang, my rustc is pegging its thread at 100% cpu, for minutes
[16:07:11] <glyc> (rebuild of rust)
[16:08:09] *** Joins: nsf (nsf@moz-EEF3238A.convex.ru)
[16:08:17] <glyc> when I used gcc before I don't recall it pausing like this
[16:09:59] <glyc> oh well, it finished ok; rustc -v  now gives rustc 0.8-pre (124eb21 2013-09-06 23:35:57 -0700)
[16:10:26] *** Joins: rusti (rusti@moz-54F7FD49.cpe.net.cable.rogers.com)
[16:14:13] *** Quits: jmgrosen (jmgrosen@moz-848F6087.sb.sd.cox.net) (Quit: jmgrosen)
[16:14:33] <glyc> bindgen builds, but generates some alarming warnings about "warning: Dynamic freeze scope artifically extended (see Issue #6248)"  ...filed as https://github.com/crabtw/rust-bindgen/issues/39
[16:16:38] *** Quits: dherman (dherman@moz-6CA476B1.hsd1.ca.comcast.net) (Quit: dherman)
[16:17:37] *** Joins: dherman (dherman@moz-6CA476B1.hsd1.ca.comcast.net)
[16:17:37] *** ChanServ sets mode: +ao dherman dherman
[16:22:02] *** Parts: donri (dag@moz-9BB61102.tbcn.telia.com) (Leaving)
[16:23:04] <sinma> glyc: Rust have some interesting features that came from functionnal languages
[16:23:24] <sinma> Type inference for example
[16:27:43] <doomlord> functional/oop.. all best described as a continuum perhaps.
[16:28:01] <enomado> https://gist.github.com/enomado/6477015 
[16:28:15] <enomado> perf stat -B ./src/main said 1.279 CPUs utilized  
[16:28:25] <enomado> can i get more cpu utilization ?
[16:28:38] <engla> did you compile with -O ?
[16:31:13] *** Joins: ghrust (ghrust@1E8607E8.6A2AE50.F3114085.IP)
[16:31:13] <ghrust> 01[13rust01] 15bors 04force-pushed 06auto from 1425abb0a to 14124eb21: 02http://git.io/N3iJvQ
[16:31:13] *** Parts: ghrust (ghrust@1E8607E8.6A2AE50.F3114085.IP) ()
[16:31:14] *** Joins: ghrust (ghrust@C8693FCB.6A2AE50.F3114085.IP)
[16:31:15] <ghrust> 01[13rust01] 15bors pushed 2 new commits to 06auto: 02http://git.io/8f1wgA
[16:31:15] <ghrust> 13rust/06auto 14739df23 15Alex Crichton: Flag the Repr::repr function with #[inline]...
[16:31:15] <ghrust> 13rust/06auto 14aa1d4ef 15bors: auto merge of #9032 : alexcrichton/rust/inline-repr, r=thestinger...
[16:31:15] *** Parts: ghrust (ghrust@C8693FCB.6A2AE50.F3114085.IP) ()
[16:31:27] *** Quits: eholk (eholk@moz-F70D5031.hsd1.in.comcast.net) (Quit: eholk)
[16:35:25] <glyc> is the new runtime optional?  task scheduling frameworks take years to mature, and y'all seem to be doing a research project on the runtime rather than build on existing solutions (tbb, etc)
[16:36:44] *** Quits: jdm (jdm@92FB48CA.8B5E9DF.9A8C35B4.IP) (Quit: Lost terminal)
[16:37:59] <engla> glyc: optional in a way, you need something like zero.rs with no runtime   https://github.com/huonw/rust-malloc/blob/master/zero.rs
[16:38:15] <engla> also some want to split the libstd into a runtimeless part
[16:38:39] *** Quits: tgummerer (tgummerer@51D3B54.FEF996EA.EA6FEF3D.IP) (Ping timeout)
[16:38:49] <glyc> engla: great, I'll check out zero.rs
[16:39:04] <glyc> engla: that would make sense to split things into runtime-dependent and not parts.
[16:39:34] <doomlord> i like the idea of layered stdlib
[16:39:55] <glyc> doomlord: yes, so you don't pay in slowness for features you aren't using
[16:40:11] <glyc> doomlord: and you can embed easily
[16:40:20] <doomlord> reduce dependancies if it makes sense
[16:41:08] <doomlord> ability to strip down without runtime is a part of the C/C++ niche i hope rust can compete in
[16:41:22] <glyc> yes
[16:43:48] <enomado> engla, 1.8 with -O. i have 3 cores. actually i want to figure out why spawn call is blocking and lenght of pool size(i notice that rust spawning 4 threads), and how scheduling works. is it documented ?
[16:45:41] <glyc> I'm trying to compile rust-malloc for zero.rs, but I get: "zero.rs:21:11: 21:16 error: invoking non-Rust fn in fn without #[fixed_stack_segment] [-D cstack (default)] zero.rs:21     unsafe{abort()}"   ... should I just add #[fixed_stack_segment] in 7 places?
[16:45:52] *** Joins: valenting (Thunderbir@BC8F8C4C.4ABED146.FB866788.IP)
[16:46:14] *** Quits: dcrewi (david@moz-AB8667CE.gyrae.net) (Ping timeout)
[16:46:22] <engla> rusti: "yay I'm back"
[16:46:24] -rusti- "yay I\'m back"
[16:46:27] <glyc> for what it's worth, #[fixed_stack_segment] does seem to allow it to compile
[16:48:51] *** Quits: jdsanders (Adium@moz-84CB7548.hlrn.qwest.net) (Quit: Leaving.)
[16:50:44] <sinma> Hi again, what does Â«14:1 error: incorrect close delimiter: `}`Â» means?
[16:51:18] <sinma> All } match a previous { in my code
[16:51:24] <engla> it's a syntax error sinma, probably something is missing before }
[16:51:38] *** Joins: squiddy (squiddy@moz-C983446B.adsl.alicedsl.de)
[16:51:49] <engla> say a missing )
[16:52:17] <engla> rusti: { std::rand::random( }
[16:52:18] -rusti- <anon>:5:30: 5:31 error: incorrect close delimiter: `}`
[16:52:18] -rusti- <anon>:5          { std::rand::random( }
[16:52:18] -rusti-                                        ^
[16:52:18] -rusti- application terminated with error code 101
[16:53:21] <engla> enomado: I can't find it. docs are usually here https://github.com/mozilla/rust/wiki/Docs
[16:53:22] <sinma> engla: yes, but the error is far from the line 14
[16:53:34] <miza> is there a way to avoiding parenthesis when i calling the method and the only argument that have is self?
[16:54:06] <kimundi> no
[16:54:23] <kimundi> function call uses always ()
[16:54:43] <miza> kk
[16:55:06] <kimundi> the only situation where you can leave them of is with the do sugar, if the function takes no other argument aside the closure
[16:55:40] <kimundi> do foo.bar { ... } == foo.bar(|| { ... })
[16:57:19] *** Quits: sp3d (a@moz-6F12212B.fidnet.com) (Ping timeout)
[16:57:27] *** Joins: tgummerer (tgummerer@moz-5DC8FA44.tbcn.telia.com)
[16:57:34] *** Quits: valenting (Thunderbir@BC8F8C4C.4ABED146.FB866788.IP) (Ping timeout)
[16:57:38] *** Joins: dew (Instantbir@moz-D2FA52B6.static.stls.mo.charter.com)
[16:57:43] *** Joins: dave1629 (dave@moz-17578A1A.hsd1.va.comcast.net)
[17:03:33] *** Quits: nsf (nsf@moz-EEF3238A.convex.ru) (Quit: WeeChat 0.4.1)
[17:03:56] *** Joins: youknowone (youknowone@A826BD81.8A0DEF81.38747683.IP)
[17:03:56] *** Quits: youknowone (youknowone@A826BD81.8A0DEF81.38747683.IP) (Z:lined (Open Proxy found on your host. Please visit www.blitzed.org/proxy?ip=115.68.131.49 for more information.))
[17:09:04] *** Joins: carllerche (carllerche@6B070D22.7E6A0813.1428D117.IP)
[17:09:49] *** Joins: sp3d (a@moz-6F12212B.fidnet.com)
[17:10:12] *** Quits: jviereck (Adium@moz-58A87BA7.dip0.t-ipconnect.de) (Quit: Leaving.)
[17:10:41] *** Quits: victorporof (victorporo@338A6DC2.9CD5E4C4.D111398B.IP) (Quit: victorporof)
[17:11:16] *** Quits: lbergstrom (Adium@moz-5D8E4B14.lightspeed.cicril.sbcglobal.net) (Quit: Leaving.)
[17:11:32] *** Joins: donri (donri@moz-9BB61102.tbcn.telia.com)
[17:13:17] *** Quits: parcha (quassel@moz-A9A9F340.hsd1.ma.comcast.net) (Client exited)
[17:15:01] *** Quits: dave1629 (dave@moz-17578A1A.hsd1.va.comcast.net) (Quit: dave1629)
[17:16:21] *** Quits: zalzane|alt (zalzane@moz-38310FA7.socal.res.rr.com) (Connection reset by peer)
[17:20:27] *** Joins: strcat (strcat@moz-54F7FD49.cpe.net.cable.rogers.com)
[17:21:40] *** Joins: bytbox_ (s@moz-F125BB72.apng.wireless-pennnet.upenn.edu)
[17:21:42] *** Quits: bytbox (s@moz-F125BB72.apng.wireless-pennnet.upenn.edu) (Ping timeout)
[17:25:02] *** Joins: ofeldt- (ofeldt@moz-4F1F2E91.dip0.t-ipconnect.de)
[17:25:41] *** Quits: ofeldt (ofeldt@moz-8ECF7AD4.dip0.t-ipconnect.de) (Ping timeout)
[17:25:46] *** Quits: dherman (dherman@moz-6CA476B1.hsd1.ca.comcast.net) (Quit: dherman)
[17:27:31] *** Quits: jclements (jclements@moz-9C0ABCFC.wireless.calpoly.edu) (Ping timeout)
[17:27:59] *** Joins: jclements (jclements@moz-9C0ABCFC.wireless.calpoly.edu)
[17:28:19] *** Quits: jpf (jan@moz-A8C26A15.org) (Ping timeout)
[17:30:44] *** Joins: parcha (quassel@moz-A9A9F340.hsd1.ma.comcast.net)
[17:31:06] <strcat> acrichto: https://github.com/mozilla/rust/pull/9042 r?
[17:31:36] <strcat> well actually
[17:31:39] <strcat> do we even link this atm?
[17:31:45] * strcat hasn't checked if we still do
[17:32:00] <acrichto> I'm not even sure what @PLT is
[17:32:32] <cmr> Procedure Linking Table iirc
[17:32:34] <strcat> it makes it position independent code like it should be
[17:32:36] <cmr> it's for PIC
[17:32:53] <strcat> anyway it's still worth fixing just so it's not broken again when we turn morestack back on, assuming we reuse some of the asm
[17:33:29] <acrichto> oh yeah we're not using morestack now
[17:33:36] <acrichto> hmm, maybe this should wait till we have it turned back on
[17:33:43] <acrichto> just so we can make sure that nothing is oddly dying
[17:33:47] <strcat> acrichto: it needs to be fixed anyway
[17:33:59] <acrichto> but it looks like it caused spurious segfaults when it was first attempted?
[17:34:08] <strcat> where?
[17:34:29] <acrichto> https://github.com/mozilla/rust/issues/5714#issuecomment-18310562
[17:34:42] *** Joins: jpf (jan@moz-A8C26A15.org)
[17:34:43] *** Joins: jviereck (Adium@moz-58A87BA7.dip0.t-ipconnect.de)
[17:34:49] * strcat shrugs
[17:34:59] *** Joins: jmgrosen (jmgrosen@moz-848F6087.sb.sd.cox.net)
[17:35:06] *** Quits: jviereck (Adium@moz-58A87BA7.dip0.t-ipconnect.de) (Quit: Leaving.)
[17:35:06] <glyc> can functions in rust have static variables inside them ala C ? 
[17:35:09] <strcat> I won't worry about it then
[17:35:21] <cmr> glyc: no
[17:35:27] <acrichto> strcat: yeah I'm just worried that if we're not using it now it may be difficult to debug if we do start using it again
[17:35:32] <cmr> glyc: static locals are shared state and not threadsafe in any way
[17:35:44] *** Joins: austincheney (quassel@8276C73B.985A737F.603BFF2.IP)
[17:35:53] <strcat> you can scope statics to functions though in rust
[17:36:02] <strcat> it's no more/less safe than having them not scoped
[17:36:07] *** Joins: ghrust (ghrust@9C8B94D4.6A2AE50.F3114085.IP)
[17:36:07] <ghrust> 01[13rust01] 15bors merged 06auto into 06master: 02http://git.io/8f1wgA
[17:36:07] *** Parts: ghrust (ghrust@9C8B94D4.6A2AE50.F3114085.IP) ()
[17:36:10] <cmr> oh right, a local static mut?
[17:36:18] <strcat> well it's not safe globally or in a function
[17:36:21] <strcat> it's just scope
[17:36:30] <glyc> cmr,strcat: for example?
[17:36:32] <cmr> yes
[17:36:44] *** Quits: huseby (huseby@moz-4E8C421A.husebyhome.com) (Quit: Leaving)
[17:37:14] <cmr> rusti: fn foo(a: bool) { static mut x: uint = 5u; unsafe {x = 3u}; if a { printfln!(x); } } foo(false); foo(true);
[17:37:23] -rusti- pastebinned 9 lines of output: http://ix.io/7Uj
[17:37:40] <cmr> rusti: fn foo(a: bool) { static mut x: uint = 5u; unsafe {x = 3u}; if a { printfln!(unsafe {x}); } } foo(false); foo(true);
[17:37:41] -rusti- 3u
[17:37:41] -rusti- ()
[17:37:47] <cmr> glyc: ^
[17:37:58] <glyc> cmr: studying...
[17:37:59] <strcat> ofc that's not safe at all
[17:39:24] <glyc> I guess I'm trying to model the idea of "this persistent variable in this function is only accessed by this function". I could write a struct and a method, but that's more decoupled than my intent
[17:40:12] <strcat> glyc: is it mutable or not?
[17:40:44] *** Joins: SiegeLord (sl@moz-CAF07B4C.hsd1.ma.comcast.net)
[17:40:51] <glyc> strcat: yes mutable, like a random number seed
[17:41:05] *** Joins: ghrust (ghrust@F6EE6DE3.6A2AE50.F3114085.IP)
[17:41:05] <ghrust> 01[13rust01] 15bors pushed 0 new commits to 06auto: 02http://git.io/AAfo_g
[17:41:05] *** Parts: ghrust (ghrust@F6EE6DE3.6A2AE50.F3114085.IP) ()
[17:41:05] *** Joins: ghrust (ghrust@DE823A67.6A2AE50.F3114085.IP)
[17:41:05] <ghrust> 01[13rust01] 15bors pushed 2 new commits to 06auto: 02http://git.io/VUiexQ
[17:41:05] <ghrust> 13rust/06auto 1475afcff 15Alex Crichton: Run gyp with CFG_PYTHON which is python < 3...
[17:41:05] <ghrust> 13rust/06auto 1417f9cd8 15bors: auto merge of #9041 : alexcrichton/rust/use-python-2, r=thestinger...
[17:41:06] *** Parts: ghrust (ghrust@DE823A67.6A2AE50.F3114085.IP) ()
[17:41:14] <glyc> in rand()
[17:41:16] *** Joins: victorporof (victorporo@338A6DC2.9CD5E4C4.D111398B.IP)
[17:41:16] <strcat> glyc: well the state has to be passed in by the caller in some way then
[17:41:25] <strcat> unless you want to use TLS
[17:41:52] <glyc> does ~ get me thread local storage?
[17:42:01] <strcat> no
[17:42:13] <strcat> ~ is just a pointer to memory from malloc
[17:42:18] <strcat> nothing special about it
[17:42:40] <glyc> strcat: k, @ gets TLS?
[17:43:11] <strcat> they are only task-local because they can't be sent, putting them in a static would be invalid
[17:43:17] <strcat> you need std::local_data
[17:43:38] <glyc> strcat: I'll look that up, thanks.
[17:47:59] *** Quits: victorporof (victorporo@338A6DC2.9CD5E4C4.D111398B.IP) (Ping timeout)
[17:48:54] *** Quits: carllerche (carllerche@6B070D22.7E6A0813.1428D117.IP) (Quit: carllerche)
[17:51:39] *** Joins: dherman (dherman@moz-6CA476B1.hsd1.ca.comcast.net)
[17:51:39] *** ChanServ sets mode: +ao dherman dherman
[17:55:26] *** Joins: igl (igl@moz-8AB223D0.adsl.alicedsl.de)
[17:55:51] *** Quits: igl1 (igl@moz-3CB2D632.adsl.alicedsl.de) (Ping timeout)
[18:00:06] *** Quits: cubic (cubic@moz-FE5AD6C7.mc.videotron.ca) (Ping timeout)
[18:00:51] *** Quits: aeqwa (aeqwa@moz-C1B65A90.dsl.tropolys.de) (Quit: Lost terminal)
[18:01:17] *** Joins: aeqwa (aeqwa@moz-C1B65A90.dsl.tropolys.de)
[18:02:40] *** Quits: aeqwa (aeqwa@moz-C1B65A90.dsl.tropolys.de) (Quit: Lost terminal)
[18:03:09] *** Joins: aeqwa (aeqwa@moz-C1B65A90.dsl.tropolys.de)
[18:06:34] *** Quits: jensnockert (jensnocker@moz-8BE55278.customer.t3.se) (Input/output error)
[18:08:09] *** Joins: victorporof (victorporo@338A6DC2.9CD5E4C4.D111398B.IP)
[18:09:52] *** Joins: fabiand (fabiand@moz-75B41A0D.adsl.alicedsl.de)
[18:09:55] <sfackler> does rust's debuginfo not handle local variables yet?
[18:10:26] <acrichto> sfackler: mw is the man for that, you're using the -Z flag?
[18:10:36] <sfackler> yep -Z debug-info
[18:10:42] <acrichto> src/tests/debug-info are all working tests
[18:10:46] <acrichto> you may need -Z extra-debug-info
[18:10:56] <acrichto> (I think locals work)
[18:10:57] *** Quits: jaen (jaen@moz-E0979827.copit.pl) (Ping timeout)
[18:10:58] <sfackler> line numbers match up, but trying to do "p foo" just gives an unknown ident error
[18:11:22] <sfackler> er, no symbol 'foo" in current context
[18:11:25] <acrichto> I'm not too familiar with the state of debug info
[18:12:14] <sfackler> uh oh
[18:12:17] <sfackler> rustc: /home/sfackler/rust/src/llvm/include/llvm/ADT/APInt.h:238: llvm::APInt::APInt(unsigned int, uint64_t, bool): Assertion `BitWidth && "bitwidth too small"' failed.
[18:12:57] <acrichto> yeah extra-debug-info doesn't work for everything just yet
[18:13:12] <acrichto> although I've never seen an llvm assertion before
[18:13:28] <sfackler> there doesn't appear to be an issue for it
[18:13:29] <acrichto> feel free to open an issue and cc @micaelwoerister (I think I spelled that right)
[18:13:33] <sfackler> will do
[18:13:35] <acrichto> michael*
[18:13:52] <sfackler> i'm also running into a segfault inside of safe code after upgrading, so there may be bigger issues
[18:14:05] <acrichto> oh dear
[18:14:39] <sfackler> it's a match arm inside of a macro, so it may be related to the let var hygene commit?
[18:15:01] <acrichto> still shouldn't cause a segfault though...
[18:15:48] *** Quits: igl (igl@moz-8AB223D0.adsl.alicedsl.de) (Connection reset by peer)
[18:16:16] *** Quits: tgummerer (tgummerer@moz-5DC8FA44.tbcn.telia.com) (Ping timeout)
[18:16:33] *** Joins: igl (igl@moz-8AB223D0.adsl.alicedsl.de)
[18:18:50] *** Quits: dherman (dherman@moz-6CA476B1.hsd1.ca.comcast.net) (Quit: dherman)
[18:19:13] *** Quits: fabiand (fabiand@moz-75B41A0D.adsl.alicedsl.de) (Quit: Verlassend)
[18:19:13] <sfackler> weird, running rustc in GDB ends up falling off the stack infinite looping over enum_metatdata, type_metadata and vec_metadata
[18:19:54] <SiegeLord> Hmm... there must be some other spot where enum variants are decoded aside from decoder::get_enum_variants
[18:20:36] <SiegeLord> I observe the variant already misclassified even before it gets in that function... (and then it gets confused and ICEs)
[18:22:28] <acrichto> sfackler: are you compiling rustc with extra-debug-info?
[18:23:10] *** Joins: dcrewi (david@moz-AB8667CE.gyrae.net)
[18:23:18] <sfackler> nope, rustc is compiled without any debug info
[18:23:26] <sfackler> https://github.com/mozilla/rust/issues/9044
[18:23:43] *** Joins: igl1 (igl@moz-B537B2FF.adsl.alicedsl.de)
[18:23:45] <acrichto> just as in what code is causing that?
[18:24:04] *** Quits: igl (igl@moz-8AB223D0.adsl.alicedsl.de) (Ping timeout)
[18:24:09] <sfackler> oh, right, rust-postgres
[18:24:56] <acrichto> if you could minmize it that would be awesome, but a link to the code would also be useful
[18:25:15] <sfackler> i updated the ticket
[18:25:22] <sfackler> i'll try to get a more minimal example
[18:25:51] <acrichto> cool thanks
[18:25:58] *** Joins: nsf (nsf@moz-EEF3238A.convex.ru)
[18:27:43] <jmgrosen> is zero.rs not needed anymore for runtime-less programs?
[18:28:04] *** Quits: dcrewi (david@moz-AB8667CE.gyrae.net) (Ping timeout)
[18:28:26] <strcat> if you don't use the runtime/stdlib, you need to provide the lang items required by your code
[18:28:28] <strcat> no change there
[18:28:38] *** Quits: zeuxcg (zeuxcg@moz-80D1F912.hsd1.ca.comcast.net) (Ping timeout)
[18:28:48] *** Joins: vfetwnuncszu (david@moz-AB8667CE.gyrae.net)
[18:29:00] *** vfetwnuncszu is now known as dcrewi
[18:29:12] *** Quits: cstrahan (cstrahan@moz-A0710861.c3-0.161-ubr1.lnh-161.md.cable.rcn.com) (Ping timeout)
[18:29:37] *** Quits: nsf (nsf@moz-EEF3238A.convex.ru) (Quit: WeeChat 0.4.1)
[18:31:09] *** Joins: ghrust (ghrust@79968228.6A2AE50.F3114085.IP)
[18:31:09] <ghrust> 01[13rust01] 15bors 04force-pushed 06auto from 1417f9cd8 to 14aa1d4ef: 02http://git.io/N3iJvQ
[18:31:09] *** Parts: ghrust (ghrust@79968228.6A2AE50.F3114085.IP) ()
[18:31:09] *** Joins: ghrust (ghrust@24260B07.6A2AE50.F3114085.IP)
[18:31:09] <ghrust> 01[13rust01] 15bors pushed 3 new commits to 06auto: 02http://git.io/hH_bmw
[18:31:09] <ghrust> 13rust/06auto 14c891fa3 15novalis: Fix #6031.  Allow symbolic log levels, not just numbers.
[18:31:09] <ghrust> 13rust/06auto 14c684df1 15novalis: Handle global log levels (fixes #6033)
[18:31:10] <ghrust> 13rust/06auto 1479e78c4 15bors: auto merge of #8906 : novalis/rust/master, r=alexcrichton...
[18:31:12] *** Parts: ghrust (ghrust@24260B07.6A2AE50.F3114085.IP) ()
[18:31:57] *** Quits: dew (Instantbir@moz-D2FA52B6.static.stls.mo.charter.com) (Ping timeout)
[18:42:58] *** Quits: dcrewi (david@moz-AB8667CE.gyrae.net) (Ping timeout)
[18:44:13] *** Quits: robertknight (robertknig@moz-29DA0AFD.range86-162.btcentralplus.com) (Ping timeout)
[18:44:23] *** Quits: huhlig-home (huhlig@moz-C8339267.hfc.comcastbusiness.net) (Ping timeout)
[18:44:36] *** Joins: huhlig-home (huhlig@moz-C8339267.hfc.comcastbusiness.net)
[18:45:26] *** Quits: feduser (feduser@1FEEBA37.894E1D07.8D466B92.IP) (Quit: Leaving)
[18:47:44] <strcat> rusti: '"'
[18:47:44] -rusti- '\"'
[18:51:24] *** Quits: victorporof (victorporo@338A6DC2.9CD5E4C4.D111398B.IP) (Quit: victorporof)
[18:54:37] <glyc> newbie 'use' question: I've generated rust bindings using bindgen for nanomsg, put them all in a nanomsg.rs file.  Now I want to 'import' those headers. I try 'use nanomsg::*;'  but I get error: unresolved import. maybe a missing `extern mod nanomsg` ; if I add the 'extern mod nanomsg', then I get 'error: can't find crate for `nanomsg`'
[18:55:03] *** Quits: bytbox_ (s@moz-F125BB72.apng.wireless-pennnet.upenn.edu) (Ping timeout)
[18:55:12] <glyc> how do I #include those translated c library header
[18:55:56] <strcat> mod nanomsg;
[18:56:04] <strcat> extern mod is to link against a crate, not to include a module
[18:56:08] *** Joins: Voomer (Voomer@moz-CC05FF5E.hsd1.wa.comcast.net)
[18:56:42] <glyc> strcat: I thought mod nanomsg would mean that I am declaring the start of a module... is mod like require?
[18:57:18] <strcat> the mod statement creates a module
[18:57:27] <strcat> you can define it inline or load it from a fine
[18:57:31] <strcat> mod foo;
[18:57:33] <strcat> is equivalent to
[18:57:40] <strcat> mod foo { /* content of foo.rs */ }
[18:57:55] <glyc> strcat: got it
[18:58:26] *** Joins: bytbox (s@moz-F125BB72.apng.wireless-pennnet.upenn.edu)
[18:58:36] <glyc> I translated all the header files from nanomsg, but my trick to concatenate them all into one .rs seems to fail, since I get: error: `use` and `extern mod` declarations must precede items
[18:58:57] <glyc> I have multiple use std::libc::*;  interspersed with items
[19:01:36] *** Joins: valenting (Thunderbir@BC8F8C4C.4ABED146.FB866788.IP)
[19:01:44] <glyc> here is what the nanomsg.rs (concatenated bindgen outputs) looks like: http://paste.ubuntu.com/6076099/
[19:04:02] <glyc> am I using bindgen incorrectly?  why aren't multiple use std::libc::*; allowed?
[19:04:18] *** Quits: bytbox (s@moz-F125BB72.apng.wireless-pennnet.upenn.edu) (Ping timeout)
[19:04:46] <strcat> the error explains why - use statements have to precede other items
[19:04:50] *** Joins: lenstr (lenstr@CD7D5ABA.83A99F98.85938D85.IP)
[19:05:09] <strcat> I'm sure you'll run into more errors from the duplicate type aliases
[19:05:12] <glyc> strcat: so I have to manually hack the bindgen output?
[19:05:38] <strcat> don't know, bindgen is a third party project and I haven't used it
[19:07:02] <glyc> see http://paste.ubuntu.com/6076099/ for sample output, there is a use std::libc::*;  at the top of every translated header
[19:07:04] *** Quits: igl1 (igl@moz-B537B2FF.adsl.alicedsl.de) (Ping timeout)
[19:07:41] *** Joins: bytbox (s@moz-F125BB72.apng.wireless-pennnet.upenn.edu)
[19:07:46] *** Joins: igl (igl@moz-517C9E2F.adsl.alicedsl.de)
[19:07:55] <glyc> strcat: is there a better tool for getting c headers into rust??
[19:08:34] <strcat> don't know
[19:08:38] <glyc> k
[19:08:46] <strcat> you have to wrap every function anyway so I've just done it by hand
[19:10:15] <glyc> oh wait, you have to wrap every function?
[19:11:03] <strcat> to define a safe API
[19:13:06] <glyc> I see. I was hoping to get by with externfn!
[19:13:29] <strcat> it takes work/thought to define a safe API
[19:13:43] <glyc> darn.
[19:14:29] <glyc> what does a safe API require?
[19:15:01] <strcat> well that's a case-by-case basis thing
[19:15:12] <strcat> you need to understand rust's memory safety rules and not leave any holes
[19:15:32] *** Joins: aeqwa_ (aeqwa@moz-F3A62310.dsl.tropolys.de)
[19:15:52] <glyc> rustc will point out the holes I assume, outside of unsafe{} blocks ?
[19:16:06] <strcat> ?
[19:16:07] *** Quits: aeqwa (aeqwa@moz-C1B65A90.dsl.tropolys.de) (Ping timeout)
[19:16:11] <strcat> safe rust code is memory safe
[19:16:16] <strcat> unsafe {} blocks are trusted to be correct
[19:16:29] <strcat> it's entirely up to you to provide correctness for bindings, since you'll be using unsafe {}
[19:16:58] <glyc> okay, I was just trying to figure out what correctness meant for ffi
[19:17:15] <glyc> are the 'memory safety rules' enumerated?
[19:17:22] <strcat> no
[19:17:35] <strcat> it's not really something you can enumerate though
[19:17:38] <glyc> str: lol
[19:17:40] <strcat> your API just has to be memory safe
[19:17:52] <glyc> strcat: what does memory safe mean?
[19:18:23] <strcat> no data races, dangling pointers, use-after-free, double-free, and so on
[19:18:35] <strcat> no buffer overflows, stack overflows
[19:18:53] <glyc> okay, so let me start with an assumption that the c library is correct.
[19:19:07] <glyc> and that the rust safe code will be correct.
[19:19:13] <strcat> okay
[19:19:22] <glyc> so the remaining part that needs to be dealt with is the interface between the two
[19:19:26] *** Quits: BizarreCake (BizarreCak@moz-361FE9B2.dynamic.barak-online.net) (Ping timeout)
[19:19:35] <strcat> sure but I don't think that really conveys what your job is
[19:19:46] *** Joins: mib_0163eq (Mibbit@moz-867AD760.cust.bredbandsbolaget.se)
[19:19:47] <strcat> the C type system cannot express memory safety for the API of most libraries
[19:19:58] *** Quits: mib_0163eq (Mibbit@moz-867AD760.cust.bredbandsbolaget.se) (Quit: http://www.mibbit.com ajax IRC Client)
[19:20:00] <glyc> right
[19:20:35] <strcat> any pointer parameter or return value is inherently unsafe
[19:20:43] <strcat> and they often have invalid values for non-pointer parameters
[19:21:03] <strcat> so you need to translate the ownership/lifetime semantics to rust
[19:21:21] <glyc> by assigning to an ~ or @ variable?
[19:21:25] <strcat> no
[19:21:27] <strcat> lets say there's foo_open, foo_close, foo_get_ref
[19:21:33] <glyc> got it
[19:21:40] <strcat> foo makes a Foo, foo_close destroys it, foo_get_ref gets a reference into one
[19:21:47] <glyc> ok
[19:22:06] *** Joins: brendan (brendaneic@moz-99385846.sub-70-197-1.myvzw.com)
[19:22:07] <strcat> so you need to wrap Foo into a struct with a priv field + a destructor and have an appropriate lifetime on foo_get_ref
[19:22:19] <strcat> the compiler won't help you with this, it can't
[19:22:22] <strcat> up to you to get it right
[19:22:36] <glyc> that example makes sense
[19:22:54] <strcat> in general 90% of it is as easy as that
[19:22:59] <strcat> sometimes it requires more thought
[19:23:11] <glyc> would it be natural to have a new function that does foo_open
[19:23:16] <strcat> yeah
[19:23:23] <glyc> ok
[19:23:30] <glyc> that makes sense
[19:23:36] *** Quits: brendan (brendaneic@moz-99385846.sub-70-197-1.myvzw.com) (Quit: brendan)
[19:23:43] *** Quits: bytbox (s@moz-F125BB72.apng.wireless-pennnet.upenn.edu) (Ping timeout)
[19:23:58] <strcat> the destructor makes it non-copyable so that eliminates double-free, etc.
[19:24:05] *** Quits: six600110 (six600110@moz-2FA48202.neo.res.rr.com) (Ping timeout)
[19:24:08] <glyc> nice
[19:24:12] <engla> And it's up to you how the new() function handles failure (iff applicable), return Option<Foo>, or fail, or you want
[19:24:13] <strcat> and then you just need the lifetime of the ref to depend on the object
[19:25:09] <glyc> lifetime of the ref can depend upon the object by using 'self lifetime annotation, yes
[19:25:11] <glyc> ?
[19:25:28] <strcat> no
[19:25:31] <strcat> not what 'self does
[19:25:33] <glyc> oh?
[19:25:49] <strcat> 'self is unrelated to the self parameter
[19:26:19] <strcat> it's a legacy naming restriction on what you're allowed to call a lifetime parameter to a type
[19:26:48] <glyc> ok
[19:27:05] <engla> normally it looks like this glyc   fn member_ref<'a>(&'a self) -> &'a MemberType { &self.member } 
[19:27:12] <glyc> how should I make lifetime of the ref to depend on the object ?
[19:27:26] <glyc> engla: ah, ok
[19:27:40] *** Joins: bytbox (s@moz-F125BB72.apng.wireless-pennnet.upenn.edu)
[19:28:34] *** Joins: dave1629 (dave@moz-17578A1A.hsd1.va.comcast.net)
[19:28:58] <engla> this part  fn member_ref<'a>(&'a self) -> &'a MemberType  -- will still be correct even if you use some unsafe code to create the &MemberType pointer
[19:29:51] <glyc> engla: and that is saying that whatever the life time of self is, call it 'a, that is going to be the same as the lifetime of the self.member, yes?
[19:29:56] *** Quits: squiddy (squiddy@moz-C983446B.adsl.alicedsl.de) (Input/output error)
[19:30:09] <kimundi> right
[19:30:18] <glyc> kimundi: cool
[19:30:22] <kimundi> that's basically all rthat named lifetimes do anyway
[19:30:36] <kimundi> link the lifetime of one thing to another thing
[19:31:42] <engla> I realized closures can have the <'a> parameter as well
[19:31:43] *** Joins: eskatrem (user@moz-A2027762.dyn.user.ono.com)
[19:31:47] <engla> but it's buggy
[19:32:14] <engla> well it works fine with ~fn<'a>() but not &fn<'a>
[19:32:46] <kimundi> isn't that supposed to be fn:'a ?
[19:32:54] <kimundi> like other type bounds
[19:32:55] <engla> that's different
[19:32:57] <glyc> is there ever a case where you use an additional lifetime 'b, say in the case of returned memory being rust code's responsibility to call ::free() on
[19:32:58] <eskatrem> another beginner's question: can I create a hashmap like {"key1":1, "key2": 2} ?
[19:33:13] <engla> no eskatrem 
[19:33:36] <strcat> glyc: 'a is an arbitrary name
[19:33:39] <strcat> doesn't mean anything
[19:33:46] <eskatrem> engla: :(
[19:33:51] <strcat> just like 'let a = 5;' is an arbitrary name
[19:33:58] <kimundi> glyc: ther could be something like fn foo<'a, 'b>(&'a A, &'b B) -> (&'a C, &'b D)
[19:34:04] <SiegeLord> eskatrem: Obviously "no" means do it with macros ;)
[19:34:19] <strcat> glyc: borrowed pointers represent non-ownership
[19:34:26] <glyc> yes
[19:34:48] <strcat> so... there is never a responsibility to free/destroy one
[19:34:49] <glyc> as a contrived example, I want to call strdup
[19:35:03] <strcat> a borrowed pointer would be incorrect for the ret value of strdup
[19:35:15] *** Joins: james4k (james@moz-E7990244.consolidated.net)
[19:35:17] <strcat> it would leak
[19:35:22] <glyc> right
[19:35:43] <strcat> you have to make a struct with the raw ptr in a priv field and a Drop impl
[19:36:05] *** Joins: ghrust (ghrust@24260B07.6A2AE50.F3114085.IP)
[19:36:05] <ghrust> 01[13rust01] 15bors merged 06auto into 06master: 02http://git.io/hH_bmw
[19:36:05] *** Parts: ghrust (ghrust@24260B07.6A2AE50.F3114085.IP) ()
[19:36:26] <glyc> how do I tell rust, "you didn't do the malloc, but you should do the free" ? ok, raw ptr in priv field, Drop impl, and assign to ptr in unsafe{}, correct?
[19:36:55] <strcat> yes
[19:37:03] <kimundi> glyc: free() call in the Drop impl
[19:37:19] <engla> glyc: std::c_str supports this for C strings
[19:37:32] <glyc> kimundi: ok
[19:37:49] <glyc> engla: std:c_str has examples?
[19:38:43] <glyc> for some reason I thought I wanted to get it into an @ variable, but maybe I just say, allocate my struct as @
[19:38:46] <engla> yeah
[19:38:56] <glyc> engla: got it
[19:39:31] *** Joins: six600110 (six600110@moz-2FA48202.neo.res.rr.com)
[19:40:50] <sinma> Is this normal? Â«failed to find an implementation of trait std::num::Algebraic for intÂ»
[19:41:05] *** Joins: ghrust (ghrust@2EE61FCC.6A2AE50.F3114085.IP)
[19:41:05] <ghrust> 01[13rust01] 15bors pushed 0 new commits to 06auto: 02http://git.io/D9eaLQ
[19:41:05] *** Parts: ghrust (ghrust@2EE61FCC.6A2AE50.F3114085.IP) ()
[19:41:06] *** Joins: ghrust (ghrust@9C8B94D4.6A2AE50.F3114085.IP)
[19:41:06] <ghrust> 01[13rust01] 15bors pushed 2 new commits to 06auto: 02http://git.io/aUy2ng
[19:41:06] <ghrust> 13rust/06auto 1475afcff 15Alex Crichton: Run gyp with CFG_PYTHON which is python < 3...
[19:41:06] <ghrust> 13rust/06auto 1482b6ef6 15bors: auto merge of #9041 : alexcrichton/rust/use-python-2, r=thestinger...
[19:41:07] *** Parts: ghrust (ghrust@9C8B94D4.6A2AE50.F3114085.IP) ()
[19:41:07] <sinma> I canâ€™t compute the sqrt of my int
[19:41:12] <engla> it's normal
[19:41:26] <strcat> int doesn't implement sqrt, what would the return value be?
[19:41:47] <eskatrem> SiegeLord: that's gotta be tough for me...
[19:41:50] <glyc> as float64 first?
[19:41:57] <engla> sinma: compared with other languages, integer types don't convert automatically to other types
[19:41:59] <strcat> I guess it could do the truncated integer square root
[19:42:05] <engla> numeric types even
[19:42:08] <sinma> How am I supposed to calculate the sqrt then?
[19:42:11] <strcat> engla: well I don't know a language where integers impl a sqrt method
[19:42:34] <glyc> sinma: turn it into a floating point number first perhaps
[19:42:34] <engla> strcat: right, but in many languages sqrt(i)  will implicitly convert i to float or similar, that's what I meant
[19:42:36] *** Quits: lenstr (lenstr@CD7D5ABA.83A99F98.85938D85.IP) (Client exited)
[19:43:03] <sinma> In C++ there are many implicit cast, thatâ€™s why I was a bit confused
[19:43:03] <sfackler> rusti: (5i32 as f64).sqrt()
[19:43:04] -rusti- 2.23606798f64
[19:43:13] <engla> for exapmle in python
[19:43:25] <sinma> I just want to truncate the result
[19:43:36] <glyc> floor or ceiling function typically
[19:43:45] <glyc> or as i32 will do it, likely?
[19:43:47] <sinma> Canâ€™t cast directly?
[19:43:50] <kimundi> rusti: (5i32 as f64).sqrt().to_uint()
[19:43:52] -rusti- 2u
[19:43:56] <kimundi> rusti: (5i32 as f64).sqrt() as uint
[19:43:57] -rusti- 2u
[19:44:05] <sinma> Ok thx
[19:44:11] <kimundi> rusti: (5i32 as f64).sqrt().ceil().to_uint()
[19:44:11] -rusti- 3u
[19:44:13] <cmr> What rounding mode does to_uint use?
[19:44:22] <SiegeLord> eskatrem: Just plop this in your code: https://gist.github.com/luqmana/6219956
[19:44:24] <kimundi> to_uint() == as uint
[19:44:27] <cmr> oh
[19:45:02] * strcat doubts 'as' conversions are usually what you want
[19:45:09] <kimundi> yeah
[19:45:19] <kimundi> better to be explicit
[19:45:30] <strcat> rusti: 256 as u8
[19:45:30] -rusti- 0u8
[19:45:31] <kimundi> even better if the language forces you to be explicit
[19:45:40] <sinma> Can I directly compute the sqrt from the int?
[19:45:51] <kimundi> sinma: no
[19:45:54] <strcat> no I don't think we have an integer sqrt function
[19:46:03] <sinma> let sqrt = num::sqrt(myint); Donâ€™t work
[19:46:10] <strcat> it's possible, but most languages don't have it
[19:46:27] <strcat> C/C++ only have floating point sqrt
[19:46:32] <kimundi> let x: int = 5; x.to_f64().sqrt().to_int()
[19:46:40] <kimundi> rusti: let x: int = 5; x.to_f64().sqrt().to_int()
[19:46:41] -rusti- 2
[19:46:47] <sinma> Itâ€™s weird
[19:47:13] <kimundi> It's the same as in other languages, we just don't hide it like them
[19:47:35] <strcat> integer square roots are likely slower to compute than converting since the CPU doesn't support int sqrt
[19:47:43] <sinma> ok
[19:47:46] *** Quits: igl (igl@moz-517C9E2F.adsl.alicedsl.de) (Ping timeout)
[19:47:52] <sinma> I havenâ€™t tough about the implementation
[19:47:56] *** Joins: igl (igl@moz-27D0EFC2.adsl.alicedsl.de)
[19:48:09] <sinma> Many things are a bit surprising about Rust ;)
[19:48:20] <strcat> I don't really see how this part is surprising
[19:48:25] <strcat> do you know a language with integer square roots?
[19:48:36] <strcat> not C, not C++, not Python, not Ruby
[19:48:40] *** Quits: bct (bct@moz-D3BEA05.ed.shawcable.net) (Ping timeout)
[19:48:46] <sinma> No, but Iâ€™m used to use sqrt with integers
[19:48:52] <strcat> in which language?
[19:49:08] <strcat> sqrt in C++ only takes floats, and returns floats
[19:49:13] <doomlord> doing a sqrt is usually followed by things best done with floats anyway
[19:49:18] <eskatrem> is switch supported in rust?
[19:49:18] <sinma> But the cast is implicit
[19:49:33] <sinma> eskatrem: nope, we have match
[19:50:01] <SiegeLord> I wonder if that's another thing that can be done with macros
[19:50:15] <strcat> SiegeLord: why though?
[19:50:21] <SiegeLord> strcat: fallthrough
[19:50:23] <eskatrem> sinma: ok, I saw switch after some googling, but it doesn't appear in the source code of the languag
[19:50:25] <eskatrem> e
[19:50:25] <kimundi> sinma: In general we try to not do things implicit if it can lead to bugs or confusing behavior
[19:50:26] <SiegeLord> Duff's device
[19:50:26] <doomlord> what do you want an int sqrt for ...
[19:50:27] <sinma> Why not make sqrt accept integer but returns float? Easier to write than cast
[19:50:35] <strcat> SiegeLord: can't do those things with macros, they are lower-level
[19:50:38] <sinma> Yes, explicit is better
[19:50:46] <sinma> But simpler is also better ;)
[19:51:17] <strcat> sinma: because we don't have an implementation of integer square roots
[19:51:26] <kimundi> sadly, for simple you're using the wrong language :P
[19:51:46] <sinma> As long as the language is coherent, I donâ€™t care, but Iâ€™m learning the language soâ€¦ :)
[19:51:51] <doomlord> (you can't compete with c++ and be simple)
[19:52:45] *** Quits: james4k (james@moz-E7990244.consolidated.net) (Ping timeout)
[19:52:48] *** Joins: robertknight (robertknig@moz-29DA0AFD.range86-162.btcentralplus.com)
[19:52:50] <sinma> doomlord: haha, right
[19:54:14] <SiegeLord> strcat: Macro would manually implement the fallthrough with a match statements
[19:54:14] <doomlord> C++ problem isn't complexity, i think whats there is needed and i still want more features :) .. 
[19:54:25] <sinma> doomlord: to compete with C++, we need to considere 1/0 a valid operation :p
[19:54:36] <strcat> SiegeLord: I don't see how you think that would be done
[19:54:59] <glyc> I'm unclear why you would ever be in i32 land if you are doing a sqrt, so it seems natural not to do the truncation silently
[19:55:14] <strcat> glyc: can be useful for limits
[19:55:26] <strcat> if you actually want the truncated result as an iteration limit
[19:55:46] <strcat> there are algorithms where you'd want it, but I think it should be very rare
[19:55:52] <doomlord> the time i'd want int sqrt is doing fixed-point arithmetic .. but there , these days, you'd only use fixed as a storage format and convert to/from float for operations
[19:55:52] <glyc> strcat: ok, but often as not you will want the ceil instead of the floor
[19:55:56] <SiegeLord> switch a { case 1: foo() case 2: bar() } -> match a { 1 => {foo(); bar()}, 2 => bar() }
[19:57:03] <strcat> SiegeLord: and how do you not fall through?
[19:57:23] <SiegeLord> Well, stick a break into it?
[19:57:28] <strcat> you can't use 'break' because loops already use it
[19:57:41] <SiegeLord> Well, use something else... the syntax is irrelevant
[19:57:59] <strcat> the syntax is relevant, we're talking about a macro
[19:58:08] <strcat> I don't see how you're going to implement it as a whole
[19:58:13] <SiegeLord> Well, break_ then :P
[19:58:22] <strcat> that's a valid identifier, can't use that
[19:59:00] <strcat> but I'm not clear on how you're going to match on the break and choose to copy or not copy the tokens
[19:59:02] <kimundi> match_fall!{ 5 =v foo(), 6 => bar(), }
[19:59:26] <kimundi> how about that? :P
[19:59:38] <strcat> I don't think rust's macros are up to the task of implementing something like that
[19:59:47] <kimundi> of course, might need a syntax extension rather than just a macro
[20:01:51] <sinma> Are there any support for internationalization in Rust (gettext or something else?)
[20:02:00] <kimundi> actually, couldn't that just become official support? I'm pretty sure a =v token at this place would be unambiguous :P
[20:02:17] <strcat> kimundi: it's not going to be officially supported
[20:02:40] <kimundi> specific design reasons against it?
[20:02:47] <strcat> C switch doesn't have fallthrough for semantic reasons
[20:03:00] <strcat> it's there because C is designed to allow writing fast code without an optimizing compiler
[20:03:22] <strcat> match already handles what you'd use foo: bar: baz: for
[20:03:23] <kimundi> well, the history of a feature does not influence wether the feature is useful
[20:03:33] <strcat> not talking about it from a history POV
[20:04:52] <strcat> rust doesn't include syntactic sugar for incredibly obscure use cases, where you won't have a single one in the over 200k line rust codebase
[20:05:17] <sinma> because gettext is a really useful tool I think
[20:05:19] <kimundi> sure, it would only ever be added if it's something commonly used
[20:05:21] <strcat> I doubt anyone is ever going to use a syntax extension for inefficient fallthrough
[20:05:49] <SiegeLord> sinma: The new formatting syntax was created with internationalization in mind
[20:06:04] <kimundi> I want however point out here that I've never written/read much C or C++, so I don't know about how often it's used :P
[20:06:27] *** Joins: jdsanders (Adium@moz-84CB7548.hlrn.qwest.net)
[20:06:33] <SiegeLord> Yeah, it'd have to be efficient... I don't know if my transfommation would actually optimize well
[20:06:37] <strcat> kimundi: it's never used unless you're trying to micro-optimize... it makes more sense to factor code into functions instead of having some 2000 line switch
[20:06:47] <sinma> SiegeLord: ifmt? Or a name like that?
[20:06:50] <kimundi> yeah
[20:07:01] <strcat> kimundi: gcc/clang both have the ability to warn whenever it is used
[20:07:04] <SiegeLord> sinma: format! println! etc
[20:07:12] <sinma> SiegeLord: but no internationalization tough
[20:07:35] <sinma> SiegeLord: ok, I saw a printf! somewhere on the tuto, really useful
[20:07:46] <sinma> But the syntax is the name, itâ€™s just simpler to use
[20:08:02] <SiegeLord> sinma: It has support for plurals etc... that seems to go beyond "nicer syntax" :P
[20:08:19] <kimundi> he, there is currently I think print, println, printfln!, print! println! printf! ...
[20:08:36] <sinma> Where is the doc for this Â«nicer syntaxÂ»?
[20:08:53] <sinma> Or some example
[20:08:55] <SiegeLord> Half of those use the old syntax... I don't know which half though >_<
[20:08:58] <engla> kimundi: printf is going out of course, I hope print and println are removed too
[20:09:03] <kimundi> rusti: println!("{}", 5u);
[20:09:03] -rusti- 5
[20:09:03] -rusti- ()
[20:09:09] <engla> print() and println() should be gone
[20:09:12] <kimundi> rusti: println!("{}, %?", 5u, 5u);
[20:09:13] -rusti- <anon>:5:32: 5:34 error: argument never used
[20:09:13] -rusti- <anon>:5          println!("{}, %?", 5u, 5u);
[20:09:13] -rusti-                                          ^~
[20:09:13] -rusti- error: aborting due to previous error
[20:09:13] -rusti- application terminated with error code 101
[20:09:23] <sinma> The functions with ! are the new I presume
[20:09:26] <SiegeLord> I think printfln! is old, and println! is new
[20:09:30] <kimundi> rusti: println!("{}, %?", 5u); printfln!("{}, %?", 5u);
[20:09:30] -rusti- 5, %?
[20:09:31] -rusti- {}, 5u
[20:09:31] -rusti- ()
[20:09:31] <sinma> I havnâ€™t saw them before
[20:09:48] <strcat> kimundi: {} and %? aren't the same thing
[20:09:53] <strcat> {:?} corresponds to {}
[20:09:56] <strcat> er
[20:09:57] <strcat> {:?} corresponds to %? *
[20:10:02] <kimundi> sinma: Don't use any of them with an 'f' in name, they're old
[20:10:16] <kimundi> rusti: println!("{:?}, %?", 5u); printfln!("{:?}, %?", 5u);
[20:10:17] -rusti- 5u, %?
[20:10:17] -rusti- {:?}, 5u
[20:10:17] -rusti- ()
[20:10:27] <sinma> Ok, so the doc need an update
[20:10:39] <kimundi> strcat: only wanted to test which one is which anyway
[20:10:52] <kimundi> sinma: the docs, the tutorials, the manual, ...
[20:10:54] <strcat> I think it'd be easy to just remove printf!/printfln! right now
[20:11:01] <strcat> I doubt they're used much, if at all
[20:11:14] <sinma> So what I must use to replace printf!?
[20:11:22] <engla> print!
[20:11:25] <strcat> just one place I used them in the container tutorial and 2 run-pass tests
[20:11:39] <strcat> printfln got used for debug printing :s
[20:11:45] <kimundi> sinma: remove the letter f, change any %... formating foo to the new {:...} formating foo
[20:12:01] <sinma> Ok
[20:13:01] <SiegeLord> sinma: Here are the docs for the new syntax, as far as I can tell: http://static.rust-lang.org/doc/std/fmt.html
[20:13:42] <sinma> I hope there is the possibility to explicit the things to get displayed elsewhere (sometimes we need to display var.to_str() or something longer)
[20:13:58] <sinma> And put it directly in the string can be quite ugly
[20:14:04] <sinma> SiegeLord: thx
[20:14:07] *** Joins: dcrewi (david@moz-AB8667CE.gyrae.net)
[20:14:18] <strcat> there are macros for formatting to a writer
[20:14:26] <strcat> including a string or byte vector
[20:14:39] <sinma> SiegeLord: the doc answer my question
[20:15:24] *** Joins: james4k (james@moz-E7990244.consolidated.net)
[20:15:26] *** Quits: igl (igl@moz-27D0EFC2.adsl.alicedsl.de) (Ping timeout)
[20:15:56] <sinma> I canâ€™t use the ("something {1}", something_very_long.to_str()) with print
[20:16:07] *** Joins: igl (igl@moz-ACA983B5.adsl.alicedsl.de)
[20:16:13] <strcat> don't know what you mean
[20:16:20] <sinma> What are the print* functions that I can use now?
[20:16:36] <strcat> you mean the formatting ones?
[20:16:47] <sinma> yes
[20:16:50] <sinma> In the doc
[20:16:59] <sinma> Â«Positional parametersÂ»
[20:17:35] <strcat> format!, print!, println!, write!
[20:17:48] *** Quits: igl (igl@moz-ACA983B5.adsl.alicedsl.de) (Ping timeout)
[20:17:51] <strcat> positional parameters start at 0
[20:17:59] <kimundi> rusti: println!("{1} {0}", "foo", "bar")
[20:18:00] -rusti- bar foo
[20:18:00] -rusti- ()
[20:18:05] <sinma> Ok, I have to use print!
[20:18:07] <kimundi> rusti: println!("{1:s} {0:s}", "foo", "bar")
[20:18:07] -rusti- bar foo
[20:18:08] -rusti- ()
[20:18:20] <sinma> print isnâ€™t used deprecated?
[20:18:26] <sinma> *is deprecated?
[20:18:29] <kimundi> no
[20:18:38] <strcat> printf!/printfln!/fmt! are deprecated
[20:18:38] *** Joins: igl (igl@moz-7A6DEE0B.adsl.alicedsl.de)
[20:18:44] <sinma> Ok
[20:19:01] * sinma is a Rust noob
[20:19:05] <kimundi> print, println are the base functions that take a &str, print! and println! are macros around it that use the new {} formating
[20:19:15] *** Joins: carllerche (carllerche@6B070D22.7E6A0813.1428D117.IP)
[20:19:20] <strcat> we need a snapshot before we can remove the old ones
[20:19:28] <strcat> and it's not possible to make a snapshot at the moment
[20:19:29] <doomlord> is there a page to read onthe new {} formatting
[20:19:32] <strcat> because the tree isn't green
[20:19:41] <kimundi> it isn't?
[20:19:48] <strcat> nope, we don't run valgrind bots on auto
[20:19:53] <strcat> so it's on fire right now
[20:19:54] <strcat> at least 2 issues
[20:20:00] <kimundi> hmm
[20:20:02] <sinma> That works, awesome
[20:20:11] * sinma is proud of his print! line
[20:20:59] <sinma> I think Iâ€™ll publish a news on Linuxfr (french website about free software) when the 0.8 will be released
[20:21:06] <kimundi> doomlord: See the link further above
[20:22:02] *** Joins: enix (enix@moz-A50569DD.c3-0.slvr-ubr1.lnh-slvr.md.cable.rcn.com)
[20:22:03] <sinma> Iâ€™ve heard the io lib has been rewritten or is going to be rewrited
[20:22:38] <sinma> I use Â«int::from_str(io::stdin().read_line())Â» to get a int from stdin, but maybe thereâ€™s a simpler way?
[20:22:58] *** Quits: austincheney (quassel@8276C73B.985A737F.603BFF2.IP) (Ping timeout)
[20:23:34] <doomlord> so {} is like %? was ?
[20:23:38] *** Joins: cstrahan (cstrahan@5A8F6E3.9F7BDBDF.8B824544.IP)
[20:23:45] <kimundi> no
[20:23:52] <kimundi> {:?} is like %?
[20:24:13] <kimundi> {} calls a default formating trait I think
[20:24:31] <SiegeLord> Yeah
[20:24:39] <SiegeLord> No direct equivalent to {} in the old syntax
[20:24:57] <doomlord> formatting.. distinct to 'ToStr' ?
[20:25:11] <strcat> yes, distinct
[20:25:20] <strcat> ToStr is likely going to be removed as a trait
[20:25:23] <strcat> it always allocates
[20:25:36] <strcat> as a method, to_owned_str does make sense
[20:25:41] <strcat> but it can be a default method from the formatting trait
[20:26:09] *** Quits: igl (igl@moz-7A6DEE0B.adsl.alicedsl.de) (Ping timeout)
[20:26:39] *** Joins: igl (igl@moz-F80FCEC3.adsl.alicedsl.de)
[20:27:26] <kimundi> It seems the docs on fmt still claim that {} is the same as {:?}
[20:27:42] <sinma> strcat: is there a simpler to do Â«int::from_str(io::stdin().read_line())Â» to get a int from stdin?
[20:27:52] <doomlord> how can you avoid the allocation, can you really deal with strings without a lot of dynamic allocations
[20:28:35] <doomlord> unless using all the unsafe clike tricks.. presized buffers that are 'usually enough'...
[20:29:11] *** Joins: joebobjoe (Mibbit@1EEF8F2.50A2C647.5A42B74E.IP)
[20:29:18] <engla> doomlord: the method signature of .to_str() requires an allocation for every call, and the default derived impl of ToStr will call this once on every member
[20:29:25] <joebobjoe> Are there any book on Rust? Or are there going to be?
[20:29:37] <SiegeLord> I'm sure one day there'll be one
[20:29:39] <engla> doomlord: formatting into a writer can use one single buffer instead of multiple allocations
[20:29:48] <doomlord> ok that makes sense
[20:30:05] *** Joins: frau (frau@moz-C616DA0A.hsd1.ca.comcast.net)
[20:30:48] <sinma> joebebjoe, SiegeLord: that would be awesomely great!
[20:31:01] <sinma> But I think we should wait the 1.0
[20:31:09] <SiegeLord> It'll definitely be after 1.0
[20:31:15] <joebobjoe> When is 1.0
[20:31:18] <sinma> (or prepare the book to release it when the 1.0 will be out)
[20:32:28] <doomlord> i think i'll still miss 'ToStr'
[20:32:32] <engla> we have some books to write already; the manual and all other the documentation
[20:33:11] <SiegeLord> I semi-formal specification would be great too
[20:33:17] <sinma> engla: haha, right
[20:33:33] <sinma> I translate the main tuto in french right now
[20:33:47] <strcat> doomlord: I don't know why you would
[20:33:48] <engla> that's great
[20:33:55] <frau> What's the deal with rustdoc_ng?
[20:34:04] <engla> it will need to be updated often sinma. And please tell if you find something that's incorrect
[20:34:05] <sinma> I hope it can grow the Rust community ;)
[20:34:10] <doomlord> its convinient.. of course adding something else more efficient in some situations is nice
[20:34:36] <strcat> doomlord: things won't get less convenient
[20:34:57] <strcat> I think you misunderstood what I was saying if that's your impression
[20:35:00] <doomlord> ok
[20:35:11] <SiegeLord> It'll get 6 characters more inconvenient, but that's about it ;)
[20:35:18] <sinma> engla: of course. I think Iâ€™ll translate it, then when itâ€™s done I check on time to time if thereâ€™s some modifications
[20:35:38] <joebobjoe> Wait, isn't rust bad?
[20:36:04] *** Quits: joebobjoe (Mibbit@1EEF8F2.50A2C647.5A42B74E.IP) (Quit: http://www.mibbit.com ajax IRC Client)
[20:36:16] <frau> depends on your objectives, rust patina can look pretty sweet
[20:36:32] <SiegeLord> rust has a pretty color
[20:36:37] <sinma> engla: I translate Â«2.1 Compiling your first programÂ» right now
[20:36:54] <engla> in absolutely current master I find "Stored value type does not match pointer operand type".. " Running pass 'Module Verifier'"  does anyone know what this is?
[20:37:02] <engla> (when compiling my own code)
[20:37:19] <strcat> means the LLVM bytecode is invalid
[20:37:37] <strcat> it catches a small subset of ways it could be invalid via the verifier
[20:37:49] <SiegeLord> So... looks like resolve runs before reading all of the metadata... anybody know where it gets its datastructures from?
[20:38:17] <engla> hm ok strcat. I have no llvm skills but I can see if I can reduce it
[20:38:19] *** Quits: igl (igl@moz-F80FCEC3.adsl.alicedsl.de) (Ping timeout)
[20:38:51] *** Joins: igl (igl@moz-178E00A8.adsl.alicedsl.de)
[20:38:55] <doomlord> so basically wherever one is doing 'to_str()' at the minute.. the interface might take some buffer to add to 
[20:39:21] <strcat> SiegeLord: it happens after loading the metadata
[20:39:29] <frau> are there any docs about rust thread local storage?
[20:39:36] <strcat> well, I think metadata loading is probably as-needed now
[20:39:46] <SiegeLord> Yes, that's what I am saying
[20:39:50] <SiegeLord> I guess I'll keep digging
[20:40:13] <frau> oh, task::local_data?
[20:41:03] *** Joins: poiuytrewq (poiuytrewq@862B47F5.24C2377D.6262EFFB.IP)
[20:41:22] *** Parts: poiuytrewq (poiuytrewq@862B47F5.24C2377D.6262EFFB.IP) ()
[20:42:04] *** Quits: james4k (james@moz-E7990244.consolidated.net) (Quit: WeeChat 0.4.1)
[20:43:59] *** Joins: pyrac (pyrac@moz-CA60DD3A.w86-213.abo.wanadoo.fr)
[20:46:04] <strcat> SiegeLord: it gets loaded from the metadata as it asks for it
[20:46:05] *** Joins: ghrust (ghrust@2EE61FCC.6A2AE50.F3114085.IP)
[20:46:05] <ghrust> 01[13rust01] 15bors merged 06auto into 06master: 02http://git.io/aUy2ng
[20:46:05] *** Parts: ghrust (ghrust@2EE61FCC.6A2AE50.F3114085.IP) ()
[20:46:32] <strcat> it caches it though
[20:46:34] <SiegeLord> I guess I need to find where... it's depressing to me that my search led me to resolve >_<
[20:46:51] <sinma> I saw that we need python 2.6 to build Rust
[20:46:53] <strcat> you mean where metadata loading is done?
[20:46:56] <sinma> Why not python 3?
[20:47:07] <strcat> sinma: not python 2.6, python 2.x
[20:47:09] <strcat> 2.7 works fine
[20:47:14] <strcat> LLVM requires it
[20:47:18] <SiegeLord> strcat: Yes, but the metadata relevant for resolve
[20:47:22] *** Quits: carllerche (carllerche@6B070D22.7E6A0813.1428D117.IP) (Quit: carllerche)
[20:48:01] <strcat> they're not writing a python library so they have no need to support *both* py2/py3
[20:48:20] <strcat> and it was originally written in py2, and they likely still need to support platforms without py3
[20:48:56] <strcat> they also don't use C++11 outside of LLD
[20:49:13] <sinma> strcat: ok
[20:49:34] <miza> is there in rust syntax like `something == true ? 1 : 2;`
[20:49:42] <doomlord> if else works like that
[20:49:51] <miza> i know this
[20:49:56] <doomlord> every block is an expression
[20:49:57] <miza> i speak i about syntax
[20:50:14] <miza> i speak about syntax*
[20:50:16] <frau> there's no ?: syntax
[20:50:21] <sinma> It works like that: let nbr = if something == true { 1 } else { 2 }
[20:50:29] <sinma> Thereâ€™s no ternary condition
[20:50:35] <sinma> In Rust, as far as I know
[20:50:43] <sinma> Not necessary
[20:50:47] <frau> just if expressions yeah
[20:51:04] *** Joins: ghrust (ghrust@DE823A67.6A2AE50.F3114085.IP)
[20:51:04] <ghrust> 01[13rust01] 15bors pushed 0 new commits to 06auto: 02https://github.com/mozilla/rust/compare/82b6ef66c22a...82b6ef66c22a
[20:51:04] *** Parts: ghrust (ghrust@DE823A67.6A2AE50.F3114085.IP) ()
[20:51:05] *** Joins: ghrust (ghrust@79968228.6A2AE50.F3114085.IP)
[20:51:06] <ghrust> 01[13rust01] 15bors pushed 2 new commits to 06auto: 02http://git.io/4_oTfQ
[20:51:06] <ghrust> 13rust/06auto 143eaf750 15Steven Fackler: Renamed Uuid::from_utf8 to Uuid::from_bytes...
[20:51:06] <ghrust> 13rust/06auto 147f8ada9 15bors: auto merge of #9043 : sfackler/rust/uuid-from-bytes, r=alexcrichton...
[20:51:06] *** Parts: ghrust (ghrust@79968228.6A2AE50.F3114085.IP) ()
[20:51:07] <sinma> And there are easier to read
[20:51:38] <doomlord> i'm used to the ?  : stuff in C but i like the consistency of 'everything is an expression'in rust
[20:51:38] <miza> for simple thning i like the  `something == true ? 1 : 2;`
[20:51:55] <miza> if not abuse is a good syntax
[20:52:17] <doomlord> i wouldn't ask for it in rust because i like keeping the : for its other uses
[20:52:55] <Seldaek> miza: another way to do this is with match, depending on the use case, like:
[20:52:57] <Seldaek> rusti: let something = false; let foo = match something { true => 1, _ => 2 }; foo
[20:52:58] -rusti- 2
[20:53:21] <Seldaek> I'd guess if/else is usually clearer though
[20:53:35] <sinma> doomlord: itâ€™s a great feature yeah, I wonders if thereâ€™s others languages that do that
[20:53:43] <doomlord> lisps do i think
[20:53:58] <sinma> Not many languages I guess
[20:54:20] <doomlord> haskell is quite expression based too? all the "let ... in.." and "where" stuff..
[20:54:37] *** Quits: jmgrosen (jmgrosen@moz-848F6087.sb.sd.cox.net) (Quit: jmgrosen)
[20:54:43] <sinma> Functionnals languages have many qualities but are barely used today
[20:54:53] <frau> speaking of haskell... rustdoc requires pandoc?
[20:54:56] <frau> big dependency...
[20:55:01] <strcat> frau: yes, it requires pandoc
[20:55:17] <sinma> Thatâ€™s why I think Rust is great, it has many awesome features not found in procedural and OO-oriented languages
[20:55:29] <doomlord> [ r.e. "6 characters less convinient", i like to_str() meaning to_owned_str() ... i like common things being compact]
[20:55:37] <Seldaek> frau: new-rustdoc won't require it, though it'll have to support it optionally since people ranted :p
[20:55:51] <frau> Seldaek: neat!
[20:56:03] <strcat> doomlord: ~str isn't the only kind of string
[20:56:22] <Seldaek> frau: so far it works with a node lib for markdown support, but that doesn't support all of pandoc features, so pandoc will still be used for rustdoc'ing libstd/libextra
[20:56:22] <SiegeLord> Is node.js smaller than pandoc?
[20:56:24] <strcat> does to_str return ~str, @str, a small string or a rope?
[20:56:43] <strcat> SiegeLord: node.js isn't a documentation builder so I don't really understand the comparison :s
[20:56:47] <doomlord> i realise you could create @str,but~str is a nice default, what about small strs and ropes
[20:57:03] <SiegeLord> strcat: Last I checked, it was a requirement for rustdoc_ng... or am I wrong?
[20:57:03] <benh> strcat: don't we require node to build docs right now?
[20:57:05] <Seldaek> strcat: new-rustdoc depends on nodejs at the moment.. long term I hope it can be rewritten in rust
[20:57:06] <miza> if you speak about expression, in ruby all is expressions, not only blocks
[20:57:06] <benh> or did at one point?
[20:57:07] <frau> we've got libuv already, what's a little node on top ;)
[20:57:51] <strcat> Seldaek: we're really going to rewrite all of the inline math, footnote, table, etc. functionality in pandoc? doubt it
[20:58:20] <doomlord>  to_str return ~str, @str, a small string or a rope? <<<< to_str could return whichever of those is the most common perhaps
[20:58:38] <sinma> engla: Â«he `rust` tool provides central access to the other rust toolsÂ», s/rust/Rust ?
[20:59:05] <strcat> doomlord: 'most common' doesn't mean it *should* be the most common
[20:59:20] *** flaper87|afk is now known as flaper87
[20:59:50] <engla> sinma: `rust` is an executable
[20:59:54] <Seldaek> strcat: no I meant rewrite the node parts  in rust once there are more libs out there
[21:00:01] <benh> the latter rust
[21:00:04] <Seldaek> strcat: so that rustdoc can work standalone if you don't *need* pandoc features
[21:00:08] <benh> "the other rust tools" / Rust tools?
[21:00:38] <strcat> Seldaek: our documentation is defined as being written in pandoc markdown though :s
[21:00:49] <doomlord> rope sounds like something distinct to strs (specialized for a lot of manipulation, right?)  @str... is and should be less common than ~str, right?  ... small-str... well fine but is that  unsafe if there's a fixed limit (does it work like that?)
[21:00:54] <sinma> Yep, `rust` is the command so rust might be Rust
[21:00:57] <Seldaek> strcat: yes I'm not talking about building libstd/libextra, but for usage by other people to doc their libs
[21:01:04] <strcat> doomlord: small strings are not unsafe
[21:01:09] <doomlord> (is smallstr something like an embedded fixed length string with optional ptr to overflow?)
[21:01:10] <strcat> and there's not a fixed limit
[21:01:16] <Seldaek> strcat: I'm assuming most people can live with a smaller subset of markdown 
[21:01:18] <doomlord> i'd be happy with smallstr as a default if its like that
[21:01:21] <strcat> doomlord: yes
[21:01:24] <doomlord> ~smallstr ok
[21:01:36] <doomlord> okthen make to_str() return that :) i'm still happy
[21:01:43] <strcat> Seldaek: sure, but we should really have a defined language for our documentation
[21:02:02] <strcat> there are differences between how different markdown rendering utilities/libraries deal with nesting
[21:02:12] <strcat> and basic features like tables have varying syntax
[21:02:32] <doomlord> (so i guess 'smallstr' is a good choice for throwing around as parameters for common useage ok)
[21:02:39] <strcat> we either need to use a less fragmented format like RST or pick a markdown variant
[21:02:47] <strcat> right now the markdown variant is pandoc markdown, but it doesn't have to be
[21:02:54] <Seldaek> strcat: yes for sure, but from a few discussions it seems unlikely we get everyone to agree, and pandoc is a heavy dependency as far as I understand.. Anyway this is all kinda hypothetical talk at this point, and I have to run :)
[21:02:54] *** Quits: Yurume (yurume@AC58A8CE.8A059B47.E313B915.IP) (Ping timeout)
[21:02:59] <sinma> strcat: thereâ€™s also textile
[21:02:59] <strcat> it would be very bad to not have a stable syntax
[21:03:30] <Seldaek> strcat: my ideal situation would be pandoc + native rust markdown that does a compatible subset  of pandoc
[21:03:38] <sinma> strcat: I totally agree.
[21:03:49] <strcat> Seldaek: yeah, that makes sense
[21:05:43] <sinma> Damn, this tutoriel is very long! Translating is not as easy as it looks
[21:09:30] <engla> I think the only RST implementation available is in python docutils?
[21:10:16] <strcat> engla: pandoc has one too ;p
[21:10:27] <strcat> the docutils one is the only fully complete one
[21:10:53] <strcat> sphinx uses it, so 95% of python projects use it (and a few projects like LLVM use it)
[21:11:28] *** Joins: dew (Instantbir@moz-D2FA52B6.static.stls.mo.charter.com)
[21:11:55] <strcat> and things like graphviz support exist as plugins for docutils so...
[21:12:16] *** Joins: curiousTraveller (alex@moz-12347B81.bootp.virginia.edu)
[21:12:18] <engla> I don't think Markdown is easy to read at all in source text form
[21:12:30] *** Parts: curiousTraveller (alex@moz-12347B81.bootp.virginia.edu) ()
[21:12:53] <strcat> python + docutils is actually much bigger than a static pandoc binary
[21:14:08] *** Joins: lex (lex@moz-12347B81.bootp.virginia.edu)
[21:15:17] <sinma> engla: titles are more difficult to recognize.
[21:15:21] *** Parts: lex (lex@moz-12347B81.bootp.virginia.edu) ()
[21:15:25] *** Joins: lex (lex@moz-12347B81.bootp.virginia.edu)
[21:15:29] <sinma> engla: have you seen my previous message?
[21:15:45] *** Joins: jensnockert (jensnocker@moz-8BE55278.customer.t3.se)
[21:16:06] <engla> and links are noisy etc
[21:16:11] <engla> I'm not sure sinma
[21:17:06] <engla> about rust? I think it's correct to write it Rust
[21:17:10] <engla> like C, Python etc.
[21:17:13] *** Joins: jviereck (Adium@moz-58A87BA7.dip0.t-ipconnect.de)
[21:17:31] <strcat> [link text](url) vs. `link text <url>` isn't much of a difference
[21:17:43] <engla> I think it is
[21:17:44] <strcat> er, `link text <url>`_
[21:17:59] <strcat> engla: which do you prefer?
[21:18:24] <engla> ReST
[21:18:34] <strcat> I think most people like the markdown one better, but I like the URL being in <> because it means it can actually be found by a proper URL regexp
[21:18:44] <strcat> (parentheses can appear anywhere in a link)
[21:19:03] <engla> normally you don't put the URL inside the `` like that
[21:19:14] <engla> it's normally `link`_  and then later the URL
[21:20:07] <engla>    Read more about Rust_     .. _Rust: http://rust-lang.org
[21:20:43] <strcat> engla: well, pandoc markdown has ref links to
[21:20:50] <strcat> (as in factoring out the urls)
[21:21:11] <engla> just saying that's the normal style in ReST
[21:21:32] <engla> and that markdown as a whole is noisy and doesn't look readable in plain text
[21:21:53] <strcat> here is [a link]
[21:21:55] <engla> Part is because the ReST parser is much more strict
[21:22:04] <strcat> [a link]: http://foo.com/
[21:22:22] <strcat> engla: I don't think it's really any more strict than pandoc's markdown variant
[21:22:22] <engla> yes, [] don't look good in text.
[21:22:31] <sinma> engla: Â«[â€¦] to the other rust toolsÂ» â†’ itâ€™s not about `rust` but about Rust, right?
[21:22:46] <strcat> docutils is kind of weird, since it can't do basic things like nesting bold in italic
[21:22:49] <strcat> you get one or the other
[21:22:49] <engla> sinma: I think so sinma. I didn't understand the question the first time.
[21:23:10] <strcat> I love rst's directives/roles
[21:23:10] <sinma> So, iâ€™ll make a little modif in the docâ€¦
[21:23:36] <strcat> but I prefer pandoc markdown to it as a whole...
[21:23:56] <engla> strcat: docutils' ReST will give you grief for indentation problems etc. sometimes it's really a pain
[21:25:13] *** Parts: doomlord (doomlod@moz-13E69BC8.range86-180.btcentralplus.com) (Leaving)
[21:25:36] <sinma> Why are there Â«#, fuzzyÂ» in <https://github.com/mozilla/rust/blob/master/doc/po/tutorial.md.pot>?
[21:26:05] *** Quits: pyrac (pyrac@moz-CA60DD3A.w86-213.abo.wanadoo.fr) (Quit: pyrac)
[21:29:55] *** Joins: lkuper (lkuper@moz-C0CD33ED.hsd1.in.comcast.net)
[21:31:32] *** Quits: bjz (brendanzab@B398BE78.F804C29E.D35A31DF.IP) (Connection reset by peer)
[21:31:33] *** Joins: bjz (brendanzab@B398BE78.F804C29E.D35A31DF.IP)
[21:33:32] <sinma> and how to create a directory via github by the way
[21:35:24] *** Quits: sigma (sigma@51C589B3.EF2694B5.DFAC6AA7.IP) (Ping timeout)
[21:35:27] <benh> in the last code example in http://static.rust-lang.org/doc/tutorial.html#crate-metadata-and-settings , what's the deal with that free-floating non-inner warn attribute?
[21:35:46] <benh> (last example under that header i mean)
[21:36:15] <benh> the .md file has a line "# pub fn farm() {}" - is that supposed to show and is the warning change supposed to apply to that? or should it apply to the crate?
[21:40:04] *** Joins: carllerche (carllerche@6B070D22.7E6A0813.1428D117.IP)
[21:41:01] *** Quits: Axord (xord@moz-1B228827.lsanca.dsl-w.verizon.net) (Quit: I'm sure it's perfectly safe)
[21:41:11] *** Joins: doomlord (doomlod@moz-13E69BC8.range86-180.btcentralplus.com)
[21:41:38] *** Joins: mib_1snice (Mibbit@moz-84CF6FE.protectedgroup.com)
[21:41:47] *** Quits: mib_1snice (Mibbit@moz-84CF6FE.protectedgroup.com) (User has been banned from Mozilla (no spamming here))
[21:42:01] <strcat> acrichto: https://github.com/mozilla/rust/pull/9046 r?
[21:42:02] *** Quits: jdsanders (Adium@moz-84CB7548.hlrn.qwest.net) (Quit: Leaving.)
[21:42:03] *** Quits: Blub\w (wry@7E3BB9D.71150E1A.237AE2BA.IP) (Quit: bb2m)
[21:42:49] *** Quits: rfw (rfw@moz-C65A114.rfw.name) (Quit: WeeChat 0.3.7)
[21:45:20] *** Quits: sinma (sinma@moz-6A11C47C.fbx.proxad.net) (Quit: Konversation terminated!)
[21:46:16] *** Quits: carllerche (carllerche@6B070D22.7E6A0813.1428D117.IP) (Quit: carllerche)
[21:47:31] *** Joins: bct (bct@moz-D3BEA05.ed.shawcable.net)
[21:49:08] *** Parts: flaper87 (flaper87@moz-107AD163.redhat.com) (0.4.1)
[21:50:19] *** Quits: spider-mario (spidermari@moz-81131DB6.fbx.proxad.net) (Input/output error)
[21:51:56] <glyc> I'm working on translating this C library header. What is the equivalent of a "#define MYCONSTANT  12" ? I can write let MYCONSTANT = 12;  but since it is global at the start of the file, rustc complains if it isn't in a function. "error: expected item but found `let`"
[21:53:04] <SiegeLord> static MYCONSTANT: u32 = 12;
[21:53:16] <SiegeLord> u32 can be something else, but it's usually appropriate
[21:53:17] <glyc> SiegeLord: Thanks!
[21:55:53] <glyc> SiegeLord: are static constants actually allocated static storage, or are they compile time only?
[21:56:01] *** Joins: rfw (rfw@moz-7D453A5B.rfw.name)
[21:56:03] *** Joins: ghrust (ghrust@2EE61FCC.6A2AE50.F3114085.IP)
[21:56:03] <ghrust> 01[13rust01] 15bors merged 06auto into 06master: 02http://git.io/4_oTfQ
[21:56:03] *** Parts: ghrust (ghrust@2EE61FCC.6A2AE50.F3114085.IP) ()
[21:56:10] <SiegeLord> Not 100% sure, but I'm thinking the former
[21:56:13] <glyc> ok
[21:57:13] <SiegeLord> You could probably use a C-like enum for that... but you're limited to whatever integer type those use
[21:58:49] <SiegeLord> A macro is a more general solution, but you can't export them atm...
[21:58:52] *** Quits: sebcrozet (sebcrozet@moz-87D51607.w80-13.abo.wanadoo.fr) (Quit: Gone)
[21:59:00] <SiegeLord> Somewhat of a heavyhanded solution too
[21:59:38] <SiegeLord> Maybe a candidate for an attribute... #[manifest_constant] or something
[22:00:26] <engla> what does manifest constant mean?
[22:00:28] <engla> there is pub static
[22:01:05] *** Joins: ghrust (ghrust@79968228.6A2AE50.F3114085.IP)
[22:01:05] <ghrust> 01[13rust01] 15bors pushed 0 new commits to 06auto: 02http://git.io/e0OnxQ
[22:01:05] *** Parts: ghrust (ghrust@79968228.6A2AE50.F3114085.IP) ()
[22:01:17] <SiegeLord> It means that that they don't exist at runtime
[22:01:33] <SiegeLord> Can't take address of them etc... they are gone by the time the binary is produced
[22:01:58] <SiegeLord> Exactly what a macro does, in principle... it's just somewhat syntax heavy to use it for that purpose
[22:03:00] <SiegeLord> Although maybe a macro producing macro would be good? Used like manifest_constant!(blah = blah)
[22:03:01] *** Quits: igl (igl@moz-178E00A8.adsl.alicedsl.de) (Ping timeout)
[22:03:07] <strcat> that's not necessary
[22:03:08] <SiegeLord> And then blah!() wherever you need it
[22:03:24] <strcat> LLVM can do whatever it likes with the definition of a constant
[22:03:39] <strcat> we do need #[inline] for static, to allow revealing the definition cross-crate
[22:03:43] *** Joins: igl (igl@moz-1ABA9E39.adsl.alicedsl.de)
[22:04:04] <strcat> or something similar
[22:04:31] <strcat> if you do 'static x: int = 5', nothing forces LLVM to output a symbol for it - it will inline it everywhere
[22:04:51] <strcat> only an issue with pub statics, and only a temporary fixable issue
[22:07:52] <benh> The difference to C defines is still that C doesn't make you specify a type :)
[22:08:21] <engla> SiegeLord: aha, there is an attribute for that it's called #[address_insignificant]
[22:08:33] <SiegeLord> Oh yeah? Great
[22:08:35] <strcat> engla: will likely become the default
[22:08:46] <engla> sounds logical
[22:09:01] <strcat> it doesn't really do much
[22:09:51] <strcat> address_insignificant just tells it that the address doesn't have any meaning, for example if you compared the addresses of globals
[22:10:07] <strcat> it can/will still eliminate the need for an actual global variable if it's not big
[22:10:28] <strcat> address_insignificant means if it doesn't want to inline it, it can at least merge it
[22:15:49] *** Joins: tikue_ (tkuehn@moz-FEADCD38.hsd1.pa.comcast.net)
[22:19:24] *** Quits: cstrahan (cstrahan@5A8F6E3.9F7BDBDF.8B824544.IP) (Ping timeout)
[22:20:27] *** Quits: robertknight (robertknig@moz-29DA0AFD.range86-162.btcentralplus.com) (Ping timeout)
[22:21:52] *** Quits: dave1629 (dave@moz-17578A1A.hsd1.va.comcast.net) (Quit: dave1629)
[22:23:35] <tikue> should the string from println! be atomic?
[22:23:39] *** Joins: dave1629 (dave@moz-17578A1A.hsd1.va.comcast.net)
[22:24:26] <tikue> right now if you do something like "for i in range(x) { do spawn { println!("{} says hi!", i); } }" the newlines can get messed up
[22:24:47] <cmr> a problem with println in general
[22:24:57] <tikue> like `1 says hi! 2 says hi!\n\n3 says hi!`
[22:24:59] <cmr> you either need to allocate or have interleaving
[22:25:13] <tikue> what do you think is better?
[22:25:19] <tikue> i suppose you can use print instead
[22:25:30] <strcat> still not atomic
[22:25:34] <tikue> really?
[22:25:38] <strcat> really
[22:25:50] <cmr> iirc posix guarantees writes smaller than the page size are atomic
[22:25:57] <tikue> in the code for println i think it looks like `print(s); print("\n");`
[22:26:09] <strcat> print itself isn't atomic
[22:26:37] <tikue> well print(s); print("\n"); is doubly not atomic lol
[22:26:51] <SiegeLord> Damn, I wish there was an easy way to print identifiers...
[22:27:08] *** Quits: jensnockert (jensnocker@moz-8BE55278.customer.t3.se) (Input/output error)
[22:27:11] <engla> I wish we could do without both print and println
[22:27:55] <kimundi> rusti: stringify!(SiegeLord)
[22:27:57] -rusti- "SiegeLord"
[22:28:38] <tikue> kimundi: that's in the prelude?
[22:28:45] <SiegeLord> kimundi: ast::Ident
[22:29:06] <cmr> tikue: libsyntax
[22:29:11] <tikue> ah
[22:29:18] <tikue> engla: you'd prefer just print?
[22:29:37] <cmr> SiegeLord: syntax::parse::token::ident_to_str
[22:29:50] * tikue still prefers having print!(foo, bar, baz) and printf!
[22:30:08] <SiegeLord> Oh huh... that works I guess
[22:32:10] <engla> tikue: yeah
[22:32:14] *** Quits: six600110 (six600110@moz-2FA48202.neo.res.rr.com) (Connection timed out)
[22:32:37] *** Joins: six600110 (six600110@moz-2FA48202.neo.res.rr.com)
[22:32:53] *** Joins: jmgrosen (jmgrosen@moz-848F6087.sb.sd.cox.net)
[22:33:59] *** Joins: barosl (barosl@3DE683B6.E551553C.7544CABF.IP)
[22:34:37] <miza> a let clojure isn't possible to call itself?
[22:34:45] <miza> closure*
[22:35:46] <miza> let a = |i: u8| -> u8 { if something == true { i } else { a(i+1) } };
[22:35:53] <miza> something like this for examble
[22:35:54] <tikue> miza: there are ways around it
[22:36:12] <miza> i know i could do it with function
[22:36:25] <tikue> rusti: let mut recursive_closure = |n: uint| -> uint { n }; 
[22:36:34] -rusti- pastebinned 7 lines of output: http://ix.io/7Uv
[22:36:47] <tikue> and then take that and rebind it
[22:37:31] <tikue> rusti: let mut recursive_closure = |n: uint| -> uint { n };  recusrive_closure = |n: uint| -> uint { if n == 1 { n } else { n * recursive_closure(n - 1) } } recursive_closure(5u)
[22:37:34] -rusti- pastebinned 4 lines of output: http://ix.io/7Uw
[22:37:36] <tikue> gah spelling
[22:39:48] <dbaupp> rusti: let mut rec_f = None; let f = |n: uint| -> uint { if n <= 1 {1} else {n * (*rec_f.get_ref())()} }; rec_f = Some(f); f(5)
[22:39:58] -rusti- failed to pastebin 8 lines of output
[22:40:03] <dbaupp> rusti: let mut rec_f = None; let f = |n: uint| -> uint { if n <= 1 {1} else {n * (*rec_f.get_ref())()} }; rec_f = Some(f); f(5)
[22:40:06] -rusti- pastebinned 8 lines of output: http://ix.io/7Uz
[22:40:19] <tikue> rusti: let mut recursive_closure = |n: uint| -> uint { n }; recursive_closure = |n: uint| -> uint { if n == 1 { n } else { n * recursive_closure(n - 1) } }; recursive_closure(5u)
[22:40:20] -rusti- 120u
[22:40:35] *** Joins: valenting1 (Thunderbir@BC8F8C4C.4ABED146.FB866788.IP)
[22:40:38] <tikue> miza: ^
[22:40:42] *** Quits: valenting (Thunderbir@BC8F8C4C.4ABED146.FB866788.IP) (Connection reset by peer)
[22:41:20] *** Parts: valenting1 (Thunderbir@BC8F8C4C.4ABED146.FB866788.IP) ()
[22:42:34] *** Quits: aeqwa_ (aeqwa@moz-F3A62310.dsl.tropolys.de) (Quit: Lost terminal)
[22:42:39] *** Quits: clements (clements@moz-E4774872.dsl.snlo01.pacbell.net) (Ping timeout)
[22:43:26] <miza> tikue: thanks
[22:43:43] <tikue> np
[22:45:03] * tikue would like a filter_scan iter method
[22:45:22] *** Quits: bytewise (bytewise@moz-4A801D04.unitymediagroup.de) (Quit: Leaving)
[22:46:05] <engla> I'm curious why
[22:47:42] <tikue> for when the filter depends on some state which changes from iteration to iteration
[22:48:11] <engla> the closure can access something outside
[22:48:18] <tikue> not if you want to return the filter
[22:48:46] <engla> true
[22:49:16] <jmgrosen> what does "failed in non-task context" mean?
[22:49:32] <tikue> not even sure how to use filter() and scan() together though -- because the filter would have to occur first, but it would need to take an argument that doesn't yet exist
[22:49:48] *** Quits: Earnestly (earnest@moz-DAE7D1AD.dyn.plus.net) (Connection reset by peer)
[22:49:52] <dbaupp> tikue: use scan then filter?
[22:50:07] <tikue> dbaupp: wouldn't that scan every item though?
[22:50:23] <tikue> the scan should only occur for filtered items
[22:50:36] <dbaupp> can you give an example?
[22:50:48] <tikue> yeah
[22:50:58] *** Joins: Earnestly (earnest@moz-DAE7D1AD.dyn.plus.net)
[22:52:10] <engla> tikue: I think you can use Unfoldr in a convoluted way
[22:52:15] <tikue> `let the_ints = count(2u, 1); let mut the_primes = the_ints.filter(|cur_primes, i|  is_prime(cur_primes, i)).scan(~[], |cur_primes, next_prime| cur_primes.append(next_prime);)`
[22:52:32] <tikue> that wouldn't compile of course, since cur_primes wouldn't exist at the point filter is called
[22:52:50] <tikue> oh and i didn't return the next_prime
[22:54:22] <dbaupp> the_ints.scan(~[], |cur_primes, i| { if is_prime(cur_primes, i) { append(); Some(Some(i)) } else { Some(None) }).filter_map(|x| x)
[22:55:22] <tikue> yeah, that looks pretty good haha
[22:56:01] <dbaupp> nested Option; oh yeah! :P
[22:56:27] <tikue> or you could have a filter_scan which would look like `the_ints.filter_scan(~[], |cur_primes, i| is_prime(cur_prime, i), |cur_primes, i| cur_primes.append(i))`
[22:56:33] <tikue> just take two closures
[22:56:57] *** Joins: aajk (aajk@moz-E1AE6B5.ip.telfort.nl)
[22:57:11] <tikue> i guess it's kind of a niche use case, but...
[22:57:34] <engla> rusti: std::iterator::Unfoldr::new((~[2], std::iterator::count(3,2)), |&(ref mut p, ref mut it)| { let mut x; loop { x = it.next().unwrap(); if p.iter().all(|&p| x % p != 0) { p.push(x); break } } Some(x) } ).take(20).to_owned_vec()
[22:57:35] -rusti- ~[3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53, 59, 61, 67, 71, 73]
[22:57:46] *** Quits: nielsle (nielsle@moz-5CE8ECCD.boa.fiberby.dk) (Ping timeout)
[22:57:58] <engla> but it's missing the two
[22:58:16] * tikue is parsing this, one moment
[22:58:59] <engla> and you can return it
[22:59:29] <engla> rusti: let primes = Some(2).chain(std::iterator::Unfoldr::new((~[2], std::iterator::count(3,2)), |&(ref mut p, ref mut it)| { let mut x; loop { x = it.next().unwrap(); if p.iter().all(|&p| x % p != 0) { p.push(x); break } } Some(x) } )); primes.take(20).to_owned_vec()
[22:59:32] -rusti- pastebinned 14 lines of output: http://ix.io/7UF
[22:59:51] <engla> rusti: let mut primes = Some(2).move_iter().chain(std::iterator::Unfoldr::new((~[2], std::iterator::count(3,2)), |&(ref mut p, ref mut it)| { let mut x; loop { x = it.next().unwrap(); if p.iter().all(|&p| x % p != 0) { p.push(x); break } } Some(x) } )); primes.take(20).to_owned_vec()
[22:59:54] -rusti- pastebinned 4 lines of output: http://ix.io/7UG
[23:00:16] <tikue> that's w weird warning. why would it not need to be mutable :\
[23:00:29] <engla> because it's taken by value into .take(20)
[23:00:32] <tikue> ohh
[23:00:32] *** Quits: donri (donri@moz-9BB61102.tbcn.telia.com) (Client exited)
[23:01:39] <tikue> engla: where does it up date it?
[23:01:55] <tikue> meh, i need more time to comprehend this lol
[23:02:29] <engla> some great obfuscation by shadowing variables even though there are only around 3 of them
[23:03:49] *** Joins: nielsle (nielsle@moz-5CE8ECCD.boa.fiberby.dk)
[23:04:55] *** jld is now known as jld|SFO-LHR-OSL
[23:05:12] *** Quits: barosl (barosl@3DE683B6.E551553C.7544CABF.IP) (Ping timeout)
[23:06:01] *** Joins: ghrust (ghrust@9C8B94D4.6A2AE50.F3114085.IP)
[23:06:01] <ghrust> 01[13rust01] 15bors merged 06auto into 06master: 02http://git.io/txu82g
[23:06:01] *** Parts: ghrust (ghrust@9C8B94D4.6A2AE50.F3114085.IP) ()
[23:06:47] <tikue> engla: why doesn't starting the state at ~[2] work to return 2?
[23:07:16] *** Quits: lkuper (lkuper@moz-C0CD33ED.hsd1.in.comcast.net) (Ping timeout)
[23:07:39] <tikue> engla: btw, this is really cool :D thank you for showing me
[23:07:49] <engla> here is a better version https://gist.github.com/anonymous/1ae1563a916f46a8f7e7
[23:07:59] <engla> oh it only returns the filtered values
[23:08:08] *** Joins: barosl (barosl@3DE683B6.E551553C.7544CABF.IP)
[23:08:21] <tikue> you can also throw in a take_while(|p| p.to_float() <= sqrt_i)
[23:08:58] <engla> right I did
[23:10:30] <tikue> engla: why filter instead of take_while? is there any functional difference?
[23:10:42] <engla> no, you are smarter
[23:10:50] <frau> so I have four lines of io operations that all return Result<..., ~str> and line n+1 depends on line n
[23:10:50] <tikue> hah
[23:10:59] *** Joins: ghrust (ghrust@2EE61FCC.6A2AE50.F3114085.IP)
[23:11:00] <ghrust> 01[13rust01] 15bors pushed 0 new commits to 06auto: 02http://git.io/pwezog
[23:11:00] *** Parts: ghrust (ghrust@2EE61FCC.6A2AE50.F3114085.IP) ()
[23:11:01] *** Joins: ghrust (ghrust@9C8B94D4.6A2AE50.F3114085.IP)
[23:11:01] <ghrust> 01[13rust01] 15bors pushed 10 new commits to 06auto: 02http://git.io/zTYuyw
[23:11:01] <ghrust> 13rust/06auto 14e7d5af8 15Micah Chalmer: Fix glitches with struct field aligned indents
[23:11:01] <ghrust> 13rust/06auto 141c527df 15Micah Chalmer: Indent correctly after opening square bracket
[23:11:01] <ghrust> 13rust/06auto 149ef0b9c 15Micah Chalmer: Allow indenting to align struct fields after curly brace
[23:11:03] *** Parts: ghrust (ghrust@9C8B94D4.6A2AE50.F3114085.IP) ()
[23:11:06] <frau> is there a pretty way to write that? currently I have them all nested with std::result::map_move everywhere
[23:11:32] *** Joins: Florob (Florob@moz-39532932.de)
[23:12:08] <dbaupp> engla, tikue: div * div <= y is surely what you want?
[23:12:08] <bjz> frau: are you using the methods?
[23:12:24] <dave1629> is there anyone on the Rust team willing to provide some feedback to students using Rust in my OS course?  I would like to find a Rust expert who can volunteer to look at some short code and explain what is/isn't "rustic", or better ways to do something. 
[23:12:50] <tikue> dbaupp: that's functionally equivalent, i believe
[23:13:03] <dbaupp> tikue: nope, y * y => div is the equivalent
[23:13:05] *** Quits: io2 (io2@moz-A6202C16.home.otenet.gr) (Quit: )
[23:13:07] <dbaupp> (to the code there)
[23:13:15] <bjz> frau: you should be able to chain the methods together using map/chain
[23:13:20] <dbaupp> dave1629: I'm happy to; is it one-on-one feedback you're looking for?
[23:13:26] <frau> bjz: looks something like: do read_whole_file(p).map_move |b| { do use_bytes(b).map_move |c| { do blargle(c).map_move |d| { // etc
[23:13:34] *** Quits: eskatrem (user@moz-A2027762.dyn.user.ono.com) (Client exited)
[23:13:34] <tikue> dbaupp: ah good point
[23:13:42] <frau> bjz: any way to flatten it? like monadic syntax or something?
[23:13:43] *** Quits: igl (igl@moz-1ABA9E39.adsl.alicedsl.de) (Ping timeout)
[23:13:47] <engla> dbaupp: yeah it's a thinko
[23:13:47] <dave1629> dbaupp: awesome!  the question is "Exercise 3" on this page: http://www.cs.virginia.edu/~evans/rust-course/pages/ps1.html
[23:13:51] *** Joins: igl (igl@moz-3E4507E4.adsl.alicedsl.de)
[23:13:52] <dbaupp> dave1629: (i'm not on the rust team; but I do have commit access/reviewer privileges; is that good enough?)
[23:14:19] *** Quits: jstevans (Instantbir@7994AFA1.362CC69C.B7830B68.IP) (Ping timeout)
[23:14:33] <dave1629> sureâ€¦I just meant someone who is an expert
[23:15:18] <dave1629> but, to see the discussion you have to register for the Piazza forum here: https://piazza.com/virginia/fall2013/cs4414
[23:15:39] <dave1629> you need to give them an email to enroll in the class (but it can be any email address)
[23:15:47] <bjz> frau: hum. yeah I'm not sure. :(
[23:15:55] <mindcat> NBT format, brainfuck format.
[23:15:57] <bjz> frau: could you gist it?
[23:16:31] <mindcat> even so simple for me
[23:16:47] *** Quits: jmgrosen (jmgrosen@moz-848F6087.sb.sd.cox.net) (Quit: jmgrosen)
[23:17:14] <dbaupp> dave1629: enrolled
[23:18:19] <dave1629> if you add ?cid=6 to whatever hash URL piazza generated, you should see the post about this exercise
[23:19:01] *** Joins: jmgrosen (jmgrosen@moz-848F6087.sb.sd.cox.net)
[23:19:36] <frau> bjz: https://gist.github.com/killballad/6480283
[23:19:36] <dave1629> take a look at the code that is "the student's answer" (this is collaboratively edited to be what the student's think is the best code for this) and let us know what you think.  
[23:20:07] <dave1629> note: limited to using rust 0.7 for this, but fine if you want to mention better ways they could do this in latest dev version
[23:20:28] <mindcat> This is last night, I wrote code: https://gist.github.com/mindcat/6480281
[23:20:33] <dbaupp> dave1629: yeah
[23:20:39] <glyc> I'm getting back () when I expect an int from nn_socket(), but my first starter client program does link (it appears); I put my initial attempt at bindings for the nanomsg messaging library on github:  https://github.com/glycerine/rust-nanomsg
[23:20:47] <bjz> frau: map_move takes a fn(T)->U right?
[23:21:01] <dbaupp> dave1629: Kiet Tran's first answer looks the best so far
[23:21:01] *** Quits: jviereck (Adium@moz-58A87BA7.dip0.t-ipconnect.de) (Quit: Leaving.)
[23:21:02] <bjz> frau: not a fn(&T)->U?
[23:21:23] <dbaupp> dave1629: (should I comment on the students answer?)
[23:21:29] <frau> bjz: fn map_move<U>(self, op: &fn(T) -> U) -> Result<U, E>
[23:21:34] <tikue> dbaupp: can i get your review on my answer too :3
[23:21:35] <dave1629> would be cool if you could post comments in the forum (and a bit of a note explaining who you are)
[23:21:45] <dbaupp> dave1629: (or; how should I provide feedback?)
[23:22:05] <bjz> frau: oh wait, no what I was thinking wouldn't work
[23:22:19] <frau> bjz: need currying or something eh
[23:22:20] <dave1629> tikue: anyone is welcome to follow the directions to join the course forum, so you could post your answer there too if you want dbaupp to see it
[23:22:24] <glyc> in an FFI call where the function declaration is: pub fn nn_socket(domain: c_int, protocol: c_int) -> c_int;   why would this call give me () and not an int: let sc = unsafe { nn_socket (AF_SP, NN_PAIR); };
[23:22:31] <tikue> dave1629: awesome! thank you 
[23:23:00] <frau> bjz: I guess pretty syntax will have to wait... maybe a macro could flatten it something... but not a big deal anyway, just wondering what is idiomatic
[23:23:07] *** Joins: maxli (maxli@4DE38BA0.46676847.808B495B.IP)
[23:23:09] <bjz> yeah :(
[23:23:20] <dave1629> btw, i would be very happy to have any willing Rust experts to join and look at and answer/comment on any of the other posts there also
[23:23:31] <frau> ok, thanks for your assistance!
[23:24:34] * mindcat want write rust code like python
[23:24:57] <glyc> mindcat: :D
[23:25:26] *** Quits: jmgrosen (jmgrosen@moz-848F6087.sb.sd.cox.net) (Ping timeout)
[23:26:17] <bjz> frau: does this work? https://gist.github.com/bjz/6480329
[23:27:01] <mindcat> ok, how define a static variable at outside?
[23:27:14] *** Quits: aajk (aajk@moz-E1AE6B5.ip.telfort.nl) (Quit: Ik ga weg)
[23:27:30] <dbaupp> dave1629: I think Kiet Tran's first answer is "correct"; as in, that's pretty much how I'd write it except for the 0.7 warts.
[23:27:54] *** Joins: jmgrosen (jmgrosen@moz-848F6087.sb.sd.cox.net)
[23:29:01] <dave1629> cool!  would be great if you could post that in the forum, and explain real briefly what you're doing with rust.
[23:31:13] <engla> acrichto: I'm still seeing a lot of transmute calls
[23:33:28] <strcat> engla: where?
[23:33:41] <strcat> you need -Z no-monomorphic-collapse or they don't get inlined
[23:33:47] <dbaupp> dave1629: how do i get syntax highlighting?
[23:33:50] <dbaupp> Thiez: ^
[23:34:05] <engla> hm
[23:34:11] <dbaupp> dave1629: (and; how are you doing the syntax highlighting? :) )
[23:34:17] <engla> shouldn't transmute always disappear?
[23:34:21] <strcat> engla: no
[23:34:31] <strcat> need -Z no-monomorphic-collapse or inlining doesn't work
[23:34:37] <dave1629> dbaupp: I don't think its highlighter knows rust, but if you click the "code" button at the top of the editor it tries
[23:34:43] <strcat> our IR has undefined behaviour with monomorphic collapse
[23:34:53] <strcat> and one of the results is inlining not working
[23:35:21] <strcat> it's something that should likely work, but it happens to not be supported by LLVM
[23:35:24] <strcat> explicitly
[23:35:38] <dave1629> dbaupp: on the course site, its using markdown (which does have :::rust support)
[23:36:00] <engla> right. that made a ton of difference
[23:36:32] <dbaupp> dave1629: ah, right; it doesn't seem to highlight for the "live" comment, it requires a page reload
[23:36:48] *** Joins: jakub (jakub@D9037AF.8AB8D9CD.806C54C8.IP)
[23:37:29] <enomado> I'm trying to build glfw-rs with local glfw. I build glfw and don't install it. So when i do `rustpkg build glfw`, i get "note: /usr/bin/ld: cannot find -lglfw"
[23:37:29] <enomado> How can i make rust see the libglfw.so? Running `LD_LIBRARY_PATH=<my_path_here>:$LD_LIBRARY_PATH rustpkg build glfw` doesn't work.
[23:37:29] <enomado> Is there a way to pass -L flag to compliler via rustpkg?
[23:37:47] <dave1629> dbaupp: i see it there now - awesome, thanks a bunch!
[23:38:02] <enomado> It works only when I put libglfw.so into glfw-rs dir
[23:38:22] <bjz> enomado: ugh, that's irritating
[23:38:39] <glyc> I'm puzzled. Why would an ffi call that is supposed to return an int, return () instead?  
[23:39:04] <glyc> rustc says:  nanocli.rs:37:21: 37:59 error: mismatched types: expected `i32` but found `()` (expected i32 but found ()) 
[23:39:11] <glyc> on this line:  nanocli.rs:37     let sc : c_int = unsafe { nn_socket (AF_SP, NN_PAIR); };
[23:39:42] <bjz> enomado: not sure, about flags, rustpkg is still a wip though
[23:39:43] <acrichto> strcat: is there a reason to have monomorphic collapse turned on by default?
[23:39:48] <acrichto> it looks like it's just hurting us
[23:39:51] <glyc> the declaration: pub fn nn_socket(domain: c_int, protocol: c_int) -> c_int;
[23:40:31] *** Quits: igl (igl@moz-3E4507E4.adsl.alicedsl.de) (Ping timeout)
[23:40:35] *** Joins: igl (igl@moz-DE06D6E3.adsl.alicedsl.de)
[23:40:46] <strcat> acrichto: because I'm the only person who realized there was a problem with it, I guess
[23:40:58] *** Quits: igl (igl@moz-DE06D6E3.adsl.alicedsl.de) (Quit: Leaving.)
[23:40:59] <glyc> is this a rustc compiler bug where int is turned into () ?
[23:41:00] <acrichto> strcat: perhaps open an issue
[23:41:04] <strcat> acrichto: I have
[23:41:08] <acrichto> oh, nvmd then
[23:41:25] <strcat> I already removed the monomorphic normalization
[23:41:27] <strcat> just not type_use
[23:41:34] <strcat> because mergefunc doesn't work on our code
[23:41:42] <acrichto> when was that determined?
[23:41:46] <acrichto> before the 3.4 update?
[23:41:52] <strcat> when was what determined?
[23:42:00] <acrichto> that mergefunc doesn't work
[23:42:06] <strcat> it never worked
[23:42:16] <strcat> it only was supposed to work since llvm 3.3
[23:42:21] <strcat> but anyway
[23:42:26] <acrichto> oh huh
[23:42:29] <strcat> it's not necessarily mergefunc that's broken
[23:42:32] <strcat> we are generating invalid IR
[23:42:37] <strcat> so we can't blame LLVM for *anything* really
[23:42:44] <strcat> unless you reduce a test case to happening with clang
[23:43:24] <strcat> lint-llvm even catches them, one of the few things it does
[23:43:41] <strcat> every single time a call happens to a type_use merged function, it triggers a lint
[23:43:49] *** Quits: Earnestly (earnest@moz-DAE7D1AD.dyn.plus.net) (Connection reset by peer)
[23:43:53] <strcat> over 10000 of them in libstd
[23:44:07] <strcat> (and only 2 undef behaviour lints from other things)
[23:44:22] <strcat> anyway it's not as simple as disabling it
[23:44:25] <strcat> it's something we need to have
[23:44:31] <strcat> it just needs to be implemented properly
[23:44:38] <acrichto> hmm ok, I don't fully understand what it is anyway
[23:44:43] <strcat> fyi mergefunc makes invalid IR too, but instcombine fixes it
[23:44:59] <strcat> so if you run mergefunc+instcombine+inline+instcombine it will be fine
[23:45:02] <strcat> in that order
[23:45:40] *** Quits: alex_abreu (alex@moz-7421D6C9.mc.videotron.ca) (Ping timeout)
[23:45:52] <acrichto> woo
[23:46:01] <strcat> that's part of what instcombine is supposed to do
[23:46:09] <strcat> allow certain passes to make technically invalid IR
[23:47:15] <tikue> dbaupp: ping
[23:47:36] <dbaupp> tikue: pong
[23:47:57] <tikue_> dbaupp: do you know if my solution is 0.7 compatible? also what do you think :3 https://gist.github.com/tikue/431c068e37315f87d80f
[23:48:54] <dbaupp> tikue_: no idea... you might have to check out release-0.7 to check if AdditiveIterator exists
[23:49:48] <dbaupp> tikue_: also, from the question spec " If any command line argument is not a valid number, your program should print out a warning about that input and skip it (but otherwise continue). "
[23:49:54] <tikue> oh, woops
[23:50:00] <strcat> or if map was even called map then
[23:50:07] <strcat> println! didn't exist
[23:50:18] <strcat> slice_from might not have existed
[23:50:32] <tikue> ah right
[23:50:35] <strcat> it sucks that they're using 0.7 :\
[23:50:37] <tikue> what was it called? printfln!?
[23:50:42] *** Joins: alex_abreu (alex@moz-7421D6C9.mc.videotron.ca)
[23:50:56] <strcat> that might not have existed then, don't remember
[23:51:27] <dbaupp> yeah, map was presumably transform still
[23:51:27] *** Quits: jmgrosen (jmgrosen@moz-848F6087.sb.sd.cox.net) (Quit: jmgrosen)
[23:51:31] <strcat> feels like it has been ages since 'advance' became unnecessary
[23:51:53] <dbaupp> 0.7 was even ages-er ago
[23:52:40] <strcat> acrichto: anyway if you figure out how to get mergefunc working we can likely turn off type_use
[23:53:04] <strcat> but last time I tried, it hit an assert
[23:53:06] <strcat> ;[
[23:55:21] *** Joins: clements (clements@moz-E4774872.dsl.snlo01.pacbell.net)
[23:55:51] <glyc> oh my. the ffi thing? it turned out to be I was writing a ;  when I should have left it off.
[23:55:58] <glyc> *ouch*
[23:56:14] <strcat> acrichto: the morestack thing does still end up in the code afaict
[23:56:27] <strcat> rust-git W: ELF file ('usr/lib/rustc/i686-unknown-linux-gnu/lib/libstd-6c65cf4b443341b1-0.8-pre.so') has text relocations.
[23:57:14] *** Quits: enix (enix@moz-A50569DD.c3-0.slvr-ubr1.lnh-slvr.md.cable.rcn.com) (Quit: Konversation terminated!)
[23:57:18] <dbaupp> dave1629: would it be inappropriate for me to link to https://github.com/huonw/rust-malloc given they may be writing one themselves?
[23:57:46] <Jesse> sure, rustc can find errors in your code. but can it find errors in your *comments*? http://www.textfromxcode.com/post/57802799970/xcodes-error-checking-is-getting-a-little-out-of
[23:57:55] <dave1629> dbaupp: not at allâ€¦great that you are working on that.
[23:58:15] <dbaupp> strcat: /me crashes from a stack overflow (https://github.com/mozilla/rust/issues/5771#issuecomment-24012220)
[23:59:06] <strcat> dbaupp: fixed already

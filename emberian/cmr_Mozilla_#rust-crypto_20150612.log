[00:00:36] <bascule> hahahahahaha
[00:00:38] <bascule> yeah
[00:00:50] <bascule> the panel had Dan Brown and Brian Lamacchia
[00:01:51] <bascule> Mr. "Big endian Weierstrass please!" and "Montgomery curves suck!"
[00:01:54] <bascule> respectively
[00:04:13] *** Quits: Tobba (Tobba@moz-o13d22.bredband.telia.com) (Ping timeout: 121 seconds)
[00:09:02] <bascule> Lochter bemoaning the damage that BADA55 and SafeCurves have done to the industry, by causing potential users to back off from ECC.
[00:09:03] <Ilari> There's also Dan Brown on the same pannel as the IETF Security AD...
[00:09:05] <bascule> Lochter and Costello: trust is more important than speed.  Speed is not very important: itâ€™s a small difference and most EC is fast enough most of the time.  Also speed may be ephemeral since platform change.  Also using it as a criterion allows talented implementors to pull the wool over peopleâ€™s eyes.
[00:09:10] <bascule> lolololol
[00:09:15] <bascule> these people are all talking out of both sides of their mouth
[00:09:32] <bascule> "Damn you djb for pointing out ECC security problems!" "Security is more important than performance!"
[00:09:36] <bascule> uhh
[00:10:03] <bascule> no, security and performance are both important, and if you care about security then you shouldn't call people out for pointing out security problems
[00:11:48] <Ilari> Well, it isn't certainly easy to find fast and weak curve (over big enough prime field)
[00:11:54] <bascule> wonder how much of Brian Lamaccia's apparent distaste for the CFRG is just sour grapes
[00:12:12] <bascule> Ilari: sure but... we're talking about Curve25519 and Ed448-Goldilocks here...
[00:12:27] <bascule> fast and safe?
[00:12:29] <bascule> :o
[00:13:31] <bascule> NUMS curves were originally short Weierstrass, then they switched to twisted Edwards, then they wanted to define the standard for generating Edwards curves, then agl massaged it to where it generates Curve25519... then Microsoft basically disappeared from the process
[00:14:24] <bascule> after Brian Lamacchia had his little rant about "why not use twisted Edwards for D-H?" and everyone's like "uhh the Montgomery ladder?" and he's like "screw your stupid Montgomery ladder"
[00:14:35] <bascule> and after that he stopped posting, afaict
[00:16:30] <bascule> Microsoft originally claimed the NUMS curves were faster, too... and SUPERCOP said otherwise...
[00:27:21] *** Quits: brson (brson@moz-u3dg2t.sfo1.mozilla.com) (Ping timeout: 121 seconds)
[00:28:46] <Ilari> Also, claiming that edwards-only is faster than hybrid (maybe if you do things dangerously).
[00:36:43] <eternaleye> bascule: They don't care about security problems; they care about their products being perceived as secure.
[00:37:17] <bascule> eternaleye: hahahahahahahaha <3
[00:37:22] <eternaleye> bascule: Similarly, they don't care about performance; they care about their products being perceived as the fastest sanely-secure option.
[00:37:44] *** Joins: Tobba (Tobba@moz-o13d22.bredband.telia.com)
[00:37:48] <bascule> eternaleye: Brian Lamacchia: "performance doesn't matter since security is more important" "we can't use the CFRG's curves, they're only thinking of software performance!"
[00:37:54] <eternaleye> bascule: So they hate BADA55 for introducing doubt, they hate Curve25519 for beign secure, fast, and not theirs, etc.
[00:39:09] <bascule> eternaleye: yup
[00:39:19] <bascule> they have a huge sunk cost in crappy elliptic curve implementations in hardware
[00:39:22] <bascule> of course they don't want to change
[00:42:34] <eternaleye> bascule: Someone should provide them with a framed copy of the Wikipedia article on the sunk-costs fallacy.
[00:42:50] <eternaleye> bascule: "We have spent money on this, therefore it must be made successful!"
[00:44:05] <eternaleye> Then again, it's not like Microsoft would actually bear any real fraction of the enduring costs...
[00:44:17] <eternaleye> No, that'd be borne by retailers, banks, etc.
[00:46:04] <bascule> I went to a standards body thing similar to this...
[00:46:15] <bascule> the W3C WebCrypto workshop on hardware tokens
[00:46:39] <eternaleye> Does hardware crypto just spontaneously remove brain cells?
[00:46:48] <bascule> lots and lots of talk about identity, nobody talking about encryption, or privacy :(
[00:46:53] <bascule> apparently!
[00:47:15] <bascule> "we've already done all this work on PKCS#11, why the hell would we use U2F?"
[00:47:34] <bascule> uhh because PKCS#11 sucks and U2F is actually designed for browsers and respects the same-origin policy?
[00:55:24] <Tobba> eternaleye: sounds like it might make for a fun psychology paper
[00:56:22] <Tobba> "Intellectual Effects of Hardware Cryptography"
[00:57:18] <eternaleye> bascule: Has anyone done work integrating U2F and Macaroons, using them as a third-party caveat?
[00:57:40] <bascule> eternaleye: I mean... I'm actually working on something sort of like that now, heh
[00:57:55] <bascule> not using macaroons
[00:58:16] <bascule> we have an app that defaults to read-only, but if you want to make changes you can "click the lock" and then you have to auth with U2F
[00:58:20] <eternaleye> bascule: Awww
[00:58:22] <bascule> then you get a 5-minute rw session
[00:58:33] <eternaleye> bascule: Part of what I like about macaroons is the potential for substitutable components
[00:58:56] <eternaleye> bascule: If people ever manage to standardize some variety of (partial) schema, especially
[00:59:17] <eternaleye> bascule: Hell, a schema for time alone would be sufficient for a lot of cases.
[00:59:27] <bascule> eternaleye: I need to write up a Macaroons design doc
[00:59:48] <eternaleye> Personally, I think that one of the (concise, textual) forms of RDF would work well
[01:00:24] <eternaleye> I mean, if you've got subject-verb-object, using it to make bounding assertions falls out pretty naturally
[01:00:30] *** Joins: dpc (dpc@moz-gtf.u17.177.128.IP)
[01:01:15] <bascule> eternaleye: we have a proxy that's our SSO frontend. I want it to get a Macaroon from the target service with a third party caveat to talk to our central AuthZ service
[01:02:00] <bascule> then the proxy presents the user session credential and the macaroon for the target service to the central AuthZ service
[01:02:07] <bascule> and gets a discharge
[01:03:00] <eternaleye> Actually, N-Triples or N-Quads might be perfect...
[01:03:05] <eternaleye> Both are line-based
[01:03:19] <eternaleye> and the N-Quads "context" thing could be used to specify schema
[01:03:48] <bascule> I think there's really one important thing re: standardizing predicates
[01:03:58] <bascule> tokenizing on the first " " character
[01:04:25] <bascule> and using the lhs as a unique identifier for the predicate matcher
[01:04:36] <bascule> (it could be a URN or whatever, or not)
[01:04:39] <eternaleye> bascule: Well, N-triples was explicitly designed to be easy to parse
[01:04:56] <eternaleye> bascule: I figure doing each line of the macaroon = an n-triples line, in pkt-lines format
[01:04:59] <bascule> getting consensus on anything more complicated than that sounds hard
[01:05:19] <bascule> well, this is kind of a microcosm of how the format works already
[01:05:24] <eternaleye> bascule: Well, the nice thing with N-triples is you can refer to RDF ontologies for semantic meaning
[01:05:24] <bascule> it's more like a 2-tuple
[01:05:32] <eternaleye> bascule: So when you specify time, that's a well-defined thing
[01:05:46] <eternaleye> bascule: And when you specify "the current user", that too is a well-defined thing
[01:05:51] *** Quits: erickt (erickt@moz-4hh.6p3.217.74.IP) (Connection closed)
[01:06:02] <eternaleye> bascule: With a common notation, that can be used for interoperation
[01:06:04] <bascule> I really doubt you're going to get consensus on anything hyperspecific
[01:06:23] <bascule> and if you want that, we should rock out an IETF BoF ;)
[01:06:24] <eternaleye> bascule: That's exactly why RDF is great for this
[01:06:33] <bascule> uhh, good luck pitching that, heh
[01:06:41] <bascule> I just want a way to generically register predicate matchers
[01:06:47] <eternaleye> bascule: RDF _isn't_ hyperspecific
[01:06:57] <bascule> that isn't the problem
[01:07:01] <bascule> the problem is "I want to use RDF"
[01:07:16] <eternaleye> bascule: It's a way of encoding predicates/predicate matchers, with the ability to refer to definitions on what your nouns and verbs mean in a common way
[01:07:24] <bascule> sure, that's great
[01:07:24] <eternaleye> bascule: The 'refer' is the crucial part
[01:07:29] <bascule> good luck getting everyone to agree on it
[01:07:49] <eternaleye> bascule: If some subcabal happens to agree on an ontology for one thing, they interoperate on any lines that use that ontology
[01:08:07] <eternaleye> bascule: And that means you can ratchet towards more interoperability _over time_
[01:08:13] <bascule> the only time any of this matters is third party caveats
[01:08:19] <eternaleye> bascule: Yes?
[01:08:20] <bascule> and... there are bigger fish to fry there
[01:08:30] <bascule> like public keys for discharge services
[01:08:32] <eternaleye> bascule: But those are the single most fascinating/useful thing with macaroons, IMO
[01:08:37] <bascule> right now the only option is symmetric
[01:08:41] <eternaleye> Mm
[01:08:57] <bascule> I agree predicates should be better standardized
[01:09:12] <bascule> step one is getting people to agree on the " " thing IMO
[01:09:14] <eternaleye> Besides, N-triples is pretty nice
[01:09:22] <eternaleye> It's literally subject verb object
[01:09:25] <bascule> which seems relatively uncontroversial considering it's how the pkt-lines are already formatted
[01:09:27] *** Joins: erickt (erickt@moz-4hh.6p3.217.74.IP)
[01:09:47] <eternaleye> <http://www.w3.org/2001/sw/RDFCore/ntriples/> <http://www.w3.org/1999/02/22-rdf-syntax-ns#type> <http://xmlns.com/foaf/0.1/Document> .
[01:10:03] <eternaleye> "The N-triples spec URL" "has type" "Document"
[01:10:13] <eternaleye> Just specified in the unambiguous form
[01:10:44] <eternaleye> and a dot unambiguously marks the end of the utterance
[01:10:56] <bascule> people disagree about that even
[01:13:08] <eternaleye> bascule: Not in N-Triples
[01:13:18] <eternaleye> Oh, you mean about the " " thing
[01:13:20] <bascule> yes
[01:13:25] <bascule> some people want
[01:13:32] <bascule> "time-before [XXX]"
[01:13:35] <bascule> some people want
[01:13:38] <bascule> "time < XXX"
[01:13:38] <eternaleye> See, that's the benefit of using a _specific_ standardized line-based format :P
[01:13:43] <bascule> uhh
[01:13:48] <bascule> good luck getting people to agree on one
[01:13:53] <bascule> I can't get them to agree on the " " thing :(
[01:14:16] <eternaleye> Yes, because 'the " " thing' looks like a fractional solution
[01:14:26] <eternaleye> It bans what they want, but doesn't suggest a cohesive plan
[01:14:35] <bascule> it doesn't "ban what they want"
[01:14:47] <bascule> nobody has specifically pointed out they're using predicates that don't work with the " " thing
[01:14:57] <bascule> in fact I think it should probably cover all existing cases
[01:15:05] <bascule> and matches how the format already works with regard to individual pkt-lines
[01:15:07] <eternaleye> Also, honestly, I kind of hate time-before and (to a lesser degree) time <
[01:15:18] <eternaleye> subject verb object uber alles
[01:15:30] <bascule> but it's important if you're exposing a Macaroon verifier API
[01:15:40] <bascule> because it lets you look up *which* predicate matcher you need for a particular predicate
[01:15:54] <bascule> it seems right now most people just run every matcher against every predicate every time they verify a Macaroon o_O
[01:15:57] <bascule> that's silly
[01:16:10] <eternaleye> Yes, and a proper format like N-triples fixes that too.
[01:16:16] <bascule> ok but
[01:16:22] <bascule> again
[01:16:23] <bascule> that's a much harder sell
[01:16:31] <bascule> and people already have stuff deployed that's incompatible
[01:16:39] <bascule> and those are the people writing the Macaroons libraries
[01:16:44] <eternaleye> ugh
[01:16:48] <bascule> so, good luck convincing them!
[01:17:02] <bascule> needs a BoF/WG ;)
[01:33:25] *** Joins: dpc_ (dpc@moz-t6gr4b.ca.comcast.net)
[01:36:23] *** Quits: dpc (dpc@moz-gtf.u17.177.128.IP) (Ping timeout: 121 seconds)
[01:48:58] <eternaleye> bascule: Well, I'm in the Seattle(-ish) area, so if one happens around here I'll try to attend...
[01:54:31] <bascule> we'd need to go through the whole IETF process around it
[01:54:38] <bascule> which I suggested doing
[01:54:48] <bascule> then decided it might be a wee bit too early
[01:57:19] <eternaleye> Incidentally, the N-Triples grammar is nice and simple: http://www.w3.org/TR/n-triples/#n-triples-grammar
[01:57:48] *** Joins: esclear_ (esclear@moz-drlmgm.dip0.t-ipconnect.de)
[01:59:08] <eternaleye> If each pkt-line is one triple, the whole thing gets very simple.
[01:59:21] *** Quits: esclear (esclear@moz-0lvqao.dip0.t-ipconnect.de) (Ping timeout: 121 seconds)
[01:59:23] <eternaleye> Heck, it's probably flat-out regular from looking at it...
[02:01:35] <eternaleye> bascule: Actually...
[02:02:11] <eternaleye> bascule: Since every valid triple starts with an IRIREF, and thus with '<', it might well be possible to trivially disambiguate between token-based and N-Triples
[02:02:38] <eternaleye> bascule: Since I doubt anyone is using Lisp notation of '< time 234524523452'
[02:03:13] <eternaleye> bascule: (of course, if you _mention_ that, then the Sexp fanatics will show up...)
[02:18:12] *** Quits: Tobba (Tobba@moz-o13d22.bredband.telia.com) (Ping timeout: 121 seconds)
[02:37:24] *** Joins: Tobba (Tobba@moz-o13d22.bredband.telia.com)
[02:37:56] <bascule> eternaleye: yeah, it's recursive regular with the length prefix and all. interpreting the pkt-lines is completely regular
[02:38:11] <bascule> also I just noticed Marsh Ray left Microsoft :(
[02:39:21] <eternaleye> bascule: Length prefix? I was referring to the N-triples grammar alone, not necessarily embedded in pkt-lines
[02:39:26] <bascule> yeah
[02:39:34] <eternaleye> bascule: And I think it's fully regular, since you can inline all the stuff
[02:39:42] <eternaleye> bascule: No rule self-references
[02:44:54] *** Quits: erickt (erickt@moz-4hh.6p3.217.74.IP) (Ping timeout: 121 seconds)
[02:45:53] <eternaleye> Oh, I see what you mean now
[02:45:56] <eternaleye> I got a reversed sense of what you meant; I read "interpreting the list-of-pkt-lines layer is completely regular" and read "it" as "the N-Triples format", and so was wondering wtf length prefix you saw in N-Triples
[02:46:25] <bascule> yeah I mean the format of Macaroons themselves
[02:46:40] <bascule> it's kind of a shame they were specified the way they are. They could've been proper Merkle-Damgaard :|
[02:46:48] <eternaleye> Although, with a strict line-based format like n-triples, I don't know if pkt-lines are even needed.
[02:47:07] <eternaleye> Then the whole thing is strictly regular, and still amenable to appending etc.
[02:47:26] <bascule> lol
[02:47:47] <bascule> yeah I'd love to change everything too, good luck ;)
[02:48:22] <eternaleye> Well, it's a new format then, but not a complex one.
[02:48:56] <eternaleye> I mean, it's literally a (hmac, N-triples-doc) tuple at that point
[02:49:16] <eternaleye> That's something you can handle with _existing_ libraries.
[02:50:01] <eternaleye> The fact that N-Triples bans newlines except at end-of-utterance is nice too
[02:50:15] <eternaleye> Makes the HMAC boundary easy to spec
[02:51:36] <bascule> it'd be easy to do (better) with pkt-lines too
[02:51:44] <bascule> terminate the Macaroon with a flush-pkt
[02:51:49] <eternaleye> Mm
[02:51:51] <bascule> signature follows
[02:52:07] <bascule> and then you just do Merkle-Damgaard across the bodies of the pkt-lines
[02:52:26] <eternaleye> I still want my nice purely-regular syntax :P
[02:52:42] <bascule> binary safety was one of the design goals
[02:52:46] <bascule> and one I like
[02:52:46] <eternaleye> Mm
[02:52:52] <eternaleye> Yeah, that makes sense
[02:53:06] <eternaleye> Of course, that's what NUL is for...
[02:53:09] <eternaleye> :P
[02:53:10] <bascule> like, why escape/encode cryptographic keys if you don't have to?
[02:53:15] <eternaleye> Oh, I see
[02:53:23] <bascule> the signature is binary
[02:53:27] <bascule> "signature" :|
[02:53:28] * eternaleye thought you meant embedding into without len fields for some reason
[02:53:50] <eternaleye> Self-delimiting as opposed to capable of encapsulating binary
[02:53:50] <bascule> for the most part you can think about predicates as opaque binary blobs
[02:53:54] <bascule> yeah
[02:54:15] <bascule> like, I want third party caveats with public keys
[02:54:27] <eternaleye> Ah well, n-triples works either way :P
[02:54:33] <bascule> to do that you need to include a public key in the third party caveat
[02:54:38] <bascule> that is, if you use D-H for auth
[02:54:43] <bascule> which seems ok to me?
[02:54:49] <bascule> well
[02:54:51] <eternaleye> Might be nice to specify a type byte or something, though, if you want binary predicates...
[02:54:52] <bascule> I guess it's encryption
[02:54:57] <bascule> since you're encrypting the caveat key
[02:55:07] <bascule> so the discharger can solve the "holder of key proof"
[02:55:07] <bascule> heh
[02:55:17] <bascule> what do you mean?
[02:55:42] <eternaleye> bascule: Try tokenizing a key on space :P
[02:56:47] <eternaleye> Of course, then pkt-lines devolve into TLV (or LTV, really), and we all know how that goes.
[02:59:22] *** Joins: adu (ajr@moz-0foa9t.md.comcast.net)
[03:33:32] <bascule> eternaleye: yeah, having even a single delimiter already complicates the "opaque binary blob" idea
[03:33:40] <bascule> but it's expressible as a simple regular language
[03:34:03] <bascule> /\A[^ ]+ .*\z/
[03:36:43] <adu> hey bascule 
[03:37:19] <bascule> ohai
[03:37:31] <adu> sounds like xml:TOKENS
[03:38:11] <bascule> it's basically "split the blob at the first space" ;)
[03:38:29] <adu> yup, xml:TOKENS
[03:39:15] <adu> I feel so meta right now
[03:39:19] *** Quits: Tobba (Tobba@moz-o13d22.bredband.telia.com) (Ping timeout: 121 seconds)
[03:39:54] <eternaleye> adu: Not as meta as Hofstatder :P
[03:39:57] <adu> I've been looking over my hobbies for the past 5 years: rust, python, html5, etc...
[03:40:04] <eternaleye> "I'm So Meta, Even This Sentence"
[03:40:21] <eternaleye> Wait, Acronym, not Sentence
[03:40:28] <eternaleye> Been too long since I used that joke
[03:40:49] <adu> I had a short stint with Go, I wrote a Scheme in Go, then I decided not to use Go
[03:41:51] <adu> eternaleye: ha?
[03:43:01] <adu> Rust is good, Go is too simple, HTML5 is what is is, and I still haven't accomplished my dream
[03:44:17] <eternaleye> adu: It makes more sense if I do it right
[03:44:26] <eternaleye> adu: "I'm So Meta, Even This Acronym"
[03:44:38] <eternaleye> adu: (it collapses to "ISMETA")
[03:45:05] <adu> oh, ok
[03:46:31] <eternaleye> adu: It's from a joke on... XKCD? about Douglas Hofstatder
[03:46:45] <eternaleye> Whose primary works are about how meta language and thought get.
[03:47:20] * adu <3 xkcd
[03:47:59] <adu> http://xkcd.com/1501/
[03:49:12] * adu thinks the Voynich manuscript is a hoax
[03:52:05] <adu> I'm a server-side developer, so I naturally understand almost all of the jokes on xkcd
[03:54:39] <adu> and I studied the Ackermann function for a decade or so, so I also am fond of:
[03:54:40] <adu> http://xkcd.com/207/
[03:55:22] <eternaleye> adu: I'm more fond of Hyper than the Ackermann Function
[03:55:35] <adu> eternaleye: really?
[03:55:50] <eternaleye> adu: To the point that my first exercise of C++ TMP was implementing Hyper in the Lambda Calculus for the C++ Error Explosion Contest
[03:55:52] <adu> welcome to my lair of hyperoperations...
[03:56:07] <eternaleye> Using Church numerals
[03:56:36] <adu> eternaleye: did you ever visit the TetrationForum?
[03:56:39] <eternaleye> adu: Literate-ish version: http://ix.io/bXn/
[03:56:46] <eternaleye> adu: I've never heard of it before
[03:56:53] <adu> tetration = hyper4
[03:59:28] <adu> I'm kind of a superhero/celebrity of the TetrationForum
[03:59:33] <eternaleye> Well, yes
[03:59:34] <eternaleye> What I mean is I'd never heard of the forum
[04:00:17] *** Joins: brson (brson@moz-4pq.28j.56.172.IP)
[04:00:17] <adu> granted, that was back when there was like 5 people in the world who were interested
[04:01:47] <eternaleye> I'm reasonably familiar with tetration (though the notation for tetration is something of a vexation :P)
[04:02:03] <adu> how does it vex you?
[04:02:09] <eternaleye> It's right to left.
[04:02:23] <adu> just use exp_x^y(1) then
[04:02:31] <eternaleye> Fair enough.
[04:02:49] <adu> it's the least creative notation
[04:03:58] <adu> also, it helps to think of it as function application instead of expression evaluation
[04:05:23] <adu> then it's obvious that you have to evaluate the inside first
[04:06:45] <bascule> eternaleye: lolol hard to be more meta than Hofstadter
[04:07:14] <bascule> we're having a sort of Go-backlash where I work
[04:07:24] <adu> "Metacat" lol
[04:07:29] <bascule> it may be due to the Go enthusiasts being total cowboys
[04:07:48] <adu> bascule: Go cowboys should learn Rust
[04:07:48] <bascule> and even some of its strongest proponents are like "damn, we should've just written this in Java"
[04:08:07] <bascule> Go seems nice for, uhh, CLIs?
[04:08:13] <eternaleye> bascule: Because at least then you have generics?
[04:08:17] <eternaleye> bascule: (Java)
[04:08:19] <bascule> hahahahaha :D
[04:08:27] <bascule> bad bolt-on generics but sure, at least you have them!
[04:09:16] <bascule> it's kind of funny how pretty much every popular statically typed language (C doesn't count because its type system is a joke) has some form of parametric polymorphism... except Go
[04:09:32] <cmr> yeah, because you can't model shit without it.
[04:09:50] <bascule> I guess Go comes from the C school of thought
[04:09:54] <bascule> and its type system is a joke too
[04:09:54] <bascule> so
[04:09:56] <bascule> there's that
[04:10:00] <cmr> if you can't model propositional logic, your type system isn't worthy of the name.
[04:10:34] <eternaleye> Seriously, Go looks (to me) like someone in love with C's (lack of a) type system smoked a bowl of Erlang and early Java.
[04:10:35] <eternaleye> OH WAIT
[04:11:10] <bascule> lololol
[04:11:31] <bascule> Go is CSP though, not actors, so... not really Erlang
[04:11:47] <eternaleye> Mm
[04:11:53] <bascule> they're two sides of the same coin but Erlang is all about the asynchronous messaging and unbounded nondeterminism
[04:12:08] <adu> Go = C + Duck
[04:12:24] <eternaleye> I was more focusing on that both of them focus on making lightweight concurrency _cheap_, not necessarily _fast_
[04:12:33] <bascule> heh, well there's that
[04:13:00] <bascule> I was talking about how the concurrency model is actually quite different in Erlang
[04:13:05] <eternaleye> Yeah
[04:13:09] <bascule> Go actually does Erlang one better though
[04:13:21] <bascule> if a goroutine is blocked on a system call, Go will make more OS threads
[04:13:23] <bascule> Erlang won't
[04:13:25] <eternaleye> Mm
[04:13:27] <bascule> which is rather silly
[04:13:36] <eternaleye> I wonder how it does that, though
[04:13:41] <bascule> and a big bottleneck for e.g. Riak when it's trying to make "NIF" native calls into LevelDB
[04:13:46] <eternaleye> Does some watchdog thread wait for a timeout?
[04:14:05] <eternaleye> Does it have a list of calls that might-block, and preemptively spawns if there's not a floating thread?
[04:14:08] <adu> but any language with bindings to pthread can make a 2-letter function called "go"
[04:14:09] <bascule> I assume it has an elastic thread pool and if things are blocked on system calls it spawns more threads as necessary *shrug*
[04:14:20] <bascule> yeah, I think so... that's the only way
[04:14:25] <eternaleye> bascule: detecting blockage is the tricky part
[04:14:29] <bascule> kind of like "old IO" in Rust
[04:14:46] <bascule> NIFs in Erlang block a scheduler thread
[04:14:52] <bascule> and the Erlang VM has a fixed-size pool
[04:15:07] <bascule> you can turn that up but there's diminishing returns the more threads you add :|
[04:15:22] <adu> eternaleye: well, I have to go to sleep
[04:15:30] <eternaleye> adu: 'night!
[04:15:36] <adu> eternaleye: let me know if you want to chat about tetration
[04:16:23] *** Quits: adu (ajr@moz-0foa9t.md.comcast.net) (Client exited)
[04:21:40] *** Quits: atomic (atomic@moz-26347v.snydernet.net) (Connection closed)
[04:21:52] *** Joins: atomic (atomic@moz-mhj04e.tor-exit.calyxinstitute.org)
[04:29:59] *** Quits: cmn (cmn@moz-r1h.buc.47.78.IP) (Connection closed)
[04:32:36] *** Quits: atomic (atomic@moz-mhj04e.tor-exit.calyxinstitute.org) (Connection closed)
[04:32:48] *** Joins: atomic (atomic@moz-92h6ej.jinetic.net)
[04:37:32] *** Quits: dpc_ (dpc@moz-t6gr4b.ca.comcast.net) (Ping timeout: 121 seconds)
[04:37:39] *** Joins: erickt (erickt@moz-njt.vqi.14.76.IP)
[04:50:47] *** Quits: erickt (erickt@moz-njt.vqi.14.76.IP) (Ping timeout: 121 seconds)
[04:59:11] <bascule> Ilari: want to know the funniest part about this whole Brian LaMacchia / Manfred Lochter angle that Curve25519 is poorly suited for hardware implementations?
[05:00:31] <bascule> we shipped Curve25519 scalar multiplication as a fixed function in a hardware device
[05:00:42] <bascule> I mean, it's actually a bit more generic than that, but
[05:01:12] <bascule> I know they're full of shit because we've fucking shipped it
[05:02:01] <bascule> on one side we have a hardware device, on the other side we actually have a Weierstrass whitebox, but we represent points as Montgomery-x, then do point conversion to Weierstrass before using the whitebox functions
[05:02:28] <bascule> there are unfortunately no off-the-shelf solutions for whitebox Montgomery :(
[05:02:56] <bascule> anyway, those people are literally talking out of their ass, and affecting NIST standardization efforts
[05:03:09] <bascule> err, excuse the "literally" but ;)
[05:04:05] <bascule> kind of makes me want to scream "BULLSHIT!"
[05:04:39] <bascule> we have some pretty spectacular hardware people: https://squareup.com/news/square-acquires-kili
[05:05:09] <bascule> that's the SoC that powers our new Apple Pay device
[05:05:18] <mayski> is this on cfrg?
[05:05:27] <bascule> mayski: nah, NIST ECC workshop
[05:05:29] <mayski> <- interested in all hw crypto
[05:06:27] <mayski> wait, session today?
[05:06:35] <bascule> yes
[05:06:45] <mayski> ok thanks looks interesting
[05:06:57] <bascule> Brian LaMacchia was also opposed to new signature algorithms o_O
[05:06:59] <bascule> ECDSA 4eva
[05:08:36] <bascule> using the Montgomery ladder is what enables an efficient fixed-function multiplier. It helps if your head of hardware security is a maths PhD who knows Verilog ;)
[05:11:10] *** Joins: dpc_ (dpc@moz-t6gr4b.ca.comcast.net)
[05:15:36] <mayski> meh video still being processed at youtube it seems
[05:17:51] <bascule> oh NIST posted it?
[05:17:51] <bascule> nice
[05:18:06] <mayski> looks like it https://www.youtube.com/watch?v=ctvJJtbhym4
[05:18:14] <bascule> nice
[05:18:23] <bascule> I actually asked them about that on YouTube
[05:18:24] <bascule> err
[05:18:25] <bascule> derp
[05:18:26] <bascule> TWitter
[05:18:26] <bascule> heh
[05:18:40] <mayski> day 1 is up already
[05:20:03] <bascule> I was actually interested in the remarks from today
[05:20:12] <bascule> and like... djb
[05:20:12] <bascule> heh
[05:20:44] <mayski> 7 and a half hours to go ;)
[05:22:27] <bascule> :(
[05:26:26] <bascule> eternaleye: one other thing to note is regardless of what warts Macaroons have, they're in a way better place than JWT
[05:29:30] <eternaleye> bascule: Oh, agreed
[05:29:46] <eternaleye> bascule: Macaroons at least have a clean, elegant concept.
[05:30:16] <eternaleye> bascule: Besides, the current tokenization style may actually be compatible with using N-Trig anyway
[05:30:45] <eternaleye> bascule: So long as nobody uses a matcher whose leading token starts with '<', they're disjoint.
[05:30:47] <bascule> JWT: just use this malleable, attacker-controlled data to verify me! It's GREAT!
[05:30:59] <eternaleye> er, N-Triples
[05:31:20] <eternaleye> For some reason N-Triples and that brand of touch-tablet get mixed up in my head.
[05:33:59] <Ilari> The list for partipicants for panel doesn't sound too fun: Stephen Farrell, Dan Brown, Lily Chen and Rene Struik ...
[05:35:20] <bascule> Ilari: and... Brian LaMacchia :(
[05:35:57] <bascule> but yeah I was like
[05:36:02] <bascule> Dan Brown and Brian LaMacchia
[05:36:04] <bascule> this panel sucks
[05:36:08] <bascule> at least those two do
[05:36:45] <bascule> Dan Brown at best has outmoded opinions and at worst is a slave to the Certicom/Blackberry patent portfolio
[05:37:17] <bascule> Brian LaMacchia likes to wield the Microsoft hat to spout his uninformed and generally bad opinions about ECC
[05:38:19] <bascule> "the CFRG isn't thinking about hardware!" he says, based on his extensive experience implementing Curve25519 in hardware
[05:38:53] <Ilari> Efficient side channel attacks... Wonder if those involve RSA multiplier with insufficient blinding bits.
[05:39:00] <bascule> lolololololol
[05:39:48] <bascule> like, we're never gonna do Goldilocks in hardware, but we can do Curve25519 just fine...
[05:40:50] <bascule> Goldilocks in hardware is a red herring
[05:41:02] <bascule> who's even going to use Goldilocks?
[05:42:12] <bascule> it's almost like guilt by association
[05:42:55] <bascule> "Goldilocks is poorly suited for hardware implementations, therefore by specious reasoning Curve25519 is too because they were both selected by the CFRG and nobody there knows anything about hardware"
[05:58:32] *** Quits: mmmonk (mmmonk@moz-lqu7bd.xlshosting.net) (Connection closed)
[05:58:45] *** Joins: cmn (cmn@moz-r1h.buc.47.78.IP)
[05:58:55] *** Joins: mmmonk (mmmonk@moz-r4g9gf.lkkh.1qm1.0348.2a02.IP)
[06:14:22] <Ilari> Okay, seems like reference implentation and more real-world implementation are getting the same answers in basic online and offline opration. :-)
[06:15:21] <bascule> Ilari: nice
[06:15:34] <bascule> Ilari: if only you could use SAW ;)
[06:15:45] <bascule> and there were Cryptol references
[06:15:56] <bascule> one can dream
[06:16:37] *** Quits: dpc_ (dpc@moz-t6gr4b.ca.comcast.net) (Ping timeout: 121 seconds)
[06:18:26] <Ilari> SAW?
[06:24:16] *** Quits: brson (brson@moz-4pq.28j.56.172.IP) (Ping timeout: 121 seconds)
[06:28:59] <Ilari> Bugs in initial version (fixed before I could get any tests to pass) included using wrong type byte in one place (0x01, should have been 0x00) and writing one length into wrong place (written at index 0, should have written at write index).
[06:29:50] <Ilari> Oh, I also need to test scatter-gather operation.
[06:32:38] <Ilari> Okay, Scatter-gather works. :-)
[06:35:15] <Ilari> "An Analysis of High-Performance Primes at High-Security Levels" ... Wonder what's in that... It is some MS guy at least.
[07:03:22] *** Joins: gleb (gleb@moz-3u1drv.rusanovka-net.kiev.ua)
[07:23:05] <bascule> Ilari: http://saw.galois.com/
[07:27:13] <cmr> oh, neat.
[07:27:25] <cmr> Really neat.
[07:28:12] <cmr> Should write a cryptol -> rust
[07:33:14] <bascule> cmr: https://github.com/aisamanra/saw-script/blob/master/doc/tutorial/sawScriptTutorial.md#cross-language-proofs-rust
[07:34:01] <cmr> bascule: I thought cryptol had mechanisms to also translate to languages, and not just prove equivalence.
[07:34:07] <bascule> it's more like you could use cryptol to formally verify rust programs
[07:34:19] <bascule> umm until SAW was released like... a few days ago it couldn't even do the latter
[07:34:51] <bascule> there is no "magically spit out cryptographically secure Rust code" mechanism yet, no ;)
[07:34:54] <cmr> the latter is a much harder problem :P
[07:35:03] <bascule> haha, uhh
[07:35:19] <bascule> there's a lot of pitfalls producing sidechannel-free crypto
[07:35:39] <bascule> especially on a crazysauce architecture like x86/x64
[07:35:52] <cmr> yeah I'm not even sure it's feasible in pure rust.
[07:36:04] <cmr> depending on llvm to do the Right Thing is pretty sketch
[07:36:05] <bascule> only if nadeko works ;)
[07:36:08] <cmr> hehe
[07:36:45] <cmr> klutzy: are you still working on nadeko? repo hasn't seen much love recently.
[07:38:02] <bascule> I thought he had a branch to make it work on 1.0
[07:38:23] <cmr> in other news the group I'm working with on crypto protocol analysis probably isn't going to get any practical results, but the unification people might like the theoretical framework we've come up with even if it's useless.
[07:38:25] <bascule> or not?
[07:38:27] <bascule> *shrug*
[07:41:34] <Ilari> Hmm... In Ed25519 curve signing, optimized version is about twice the speed for small messages (assuming keys get reused). For verification, the difference is almost nonexistent.
[07:43:25] <Ilari> Kinda makes sense, as ref does two fixed-base multiplies for signing, whereas optimized does only one. And both verifies do double-scalar mults.
[07:44:11] <klutzy> cmr: I'm still aware of it! I'm however a bit busy these days :-/
[07:56:24] <Ilari> Also, I see no use for random ECC curves (there might be use for some special curves if ECC turns out to be mostly weak).
[08:03:50] <Ilari> AFAIK, there actually are weak fields for ECC (fortunately, those are of the kind nobody is using). And if one hits one, I think pretty much every curve over that will be weak.
[08:47:12] *** Joins: skeuomorf (skeuomorf@moz-d5k.lok.32.197.IP)
[08:49:15] *** Quits: Yurume (Yurume@moz-0t8.piq.68.115.IP) (Ping timeout: 121 seconds)
[08:49:58] *** Quits: klutzy (not@moz-0t8.piq.68.115.IP) (Ping timeout: 121 seconds)
[09:17:16] *** Joins: klutzy (not@moz-0t8.piq.68.115.IP)
[09:26:14] <Ilari> The level of detail in those annotated examples: http://codepad.org/Vgss4eso
[10:08:59] *** Quits: klutzy (not@moz-0t8.piq.68.115.IP) (Ping timeout: 121 seconds)
[10:36:21] *** Joins: klutzy (not@moz-0t8.piq.68.115.IP)
[11:18:26] *** Joins: Yurume (Yurume@moz-0t8.piq.68.115.IP)
[13:35:51] *** Joins: Tobba (Tobba@moz-o13d22.bredband.telia.com)
[13:50:53] <Ilari> Wonder if there are efficient semiprimes for ECC, and if blinding those would be easier in hardware...
[13:52:04] <Ilari> Trying to construct elliptic curve over semiprime won't work properly, but the subring structure will still be correct.
[15:13:04] <eternaleye> bascule: Well, cryptol v1 could compile to C, native, or Verilog
[15:13:11] <eternaleye> bascule: But v2 kinda lost most of that
[15:13:21] <eternaleye> bascule: Including Verilog, sadly
[15:33:52] <Ilari> Wonder how many pieces of software would get TLS 1.2 server selecting DHE with ECDSA correctly...
[15:48:24] <Ilari> Grr... Identifying a curve the way I did doesn't actually work...
[16:22:18] *** Joins: erickt (erickt@moz-4hh.6p3.217.74.IP)
[16:24:40] <bascule> hmm
[16:24:47] * bascule watching this Microsoft presentation on FourQ
[16:27:02] <bascule> http://research.microsoft.com/apps/pubs/default.aspx?id=246916
[16:58:02] <bascule>  13_4__8__ 9_11__12_  13_4__ 8_9__11_    13_ 4_8_   11__12_ 13_ 4_ 
[16:58:05] <bascule> 4|  8_9__11|  12_ 13\4|_ 8_9|  11_ 12\  4/ 8\\ 9\ 11/ 12/ 13| 4| 8|
[16:58:08] <bascule> 8| 9|_  12| 13|_4) 8|| 9|11| 12| 13| 4|/ 8_ 9\11\ 12V 13/| 4| 8| 9|
[16:58:11] <bascule> 9|  11_12| 13|  4_ 8< 9| 11|12| 13|_4| 8/ 9__11_ 12\| 13| 4|8_|9_|11_|
[16:58:14] <bascule> 11|_12|   4|_8| 9\_11\_12__13|_4__8_/9_/   12\13_\4_| 8(9_|11_|12_)
[16:58:17] <bascule>                                         
[17:11:11] <Ilari> Heh, the paper from Mike seems to have a typo: The prime is 2^389-21, not 2^389-17 (which isn't a prime).
[17:19:14] <bascule> heh
[17:19:40] <Ilari> FourQ: Cofactor 392???
[17:19:57] <bascule> heh
[17:23:22] <Ilari> Also, reverted that change, and instead regrouped the keys to include hash and curve.
[17:26:27] <bascule> https://twitter.com/hashbreaker/status/605059959202693120
[17:26:28] <bascule> hahaha
[17:34:22] <Ilari> Also, removing the change cut some complexity (especially since my ECC lib doesn't export the needed data, so it needs to be indirectly obtained).
[17:43:43] *** Joins: dpc_ (dpc@moz-t6gr4b.ca.comcast.net)
[17:45:35] *** Joins: brson (brson@moz-cfhap5.mtv2.mozilla.com)
[18:05:13] *** Quits: skeuomorf (skeuomorf@moz-d5k.lok.32.197.IP) (Ping timeout: 121 seconds)
[18:09:35] *** Joins: skeuomorf (skeuomorf@moz-d5k.lok.32.197.IP)
[18:34:56] <Ilari> Also, where the heck is the CFRG basepoint on Goldilocks paper from?
[18:37:11] <Ilari> The point is on the curve, but I certainly can't figure out how to recover the CFRG basepoint (whereas I can easily recover that from the basepoint my ECC lib uses, which is totally different).
[18:41:09] *** Quits: dpc_ (dpc@moz-t6gr4b.ca.comcast.net) (Ping timeout: 121 seconds)
[18:42:52] <Ilari> He might have used dual isogeny to derive the point, instead of inverting the isogeny I did.
[18:45:22] <Ilari> Inverting the isogeny causes transforming the curve into Montgomery to recover the standard Montgomery basepoint.
[18:56:37] <Ilari> Well, there should be recording of Day 2 sessions available in few hours or so...
[19:02:43] <eternaleye> I'm liking Dave Garrett's proposal re: a la carte
[19:05:40] <Ilari> The reference implementation of this signature primitive (relying on ECC and hash code in other crates) is ~250 or so LOC of rust code, after stripping code printing annotated examples.
[19:18:05] <Ilari> eternaleye: Well, that seems certainly reasonable (without going to splitting ciphersites).
[19:20:22] *** Quits: mmmonk (mmmonk@moz-r4g9gf.lkkh.1qm1.0348.2a02.IP) (Ping timeout: 121 seconds)
[19:20:54] *** Joins: mmmonk (mmmonk@moz-r4g9gf.lkkh.1qm1.0348.2a02.IP)
[19:27:03] <Ilari> I still consider that splitting ciphersuites would be the cleanest way (however, many seem to think that it would be difficult to support; I think that pretty much all implementations have decoding tables anyway).
[19:30:49] *** Joins: dpc_ (dpc@moz-t6gr4b.ca.comcast.net)
[19:32:35] <Ilari> Also, the Curve25519 draft seems to think that ECDHE_ECDSA ciphersuites are the only ones that can use ECDSA certs. Not so in TLS 1.2
[19:41:45] *** Quits: dpc_ (dpc@moz-t6gr4b.ca.comcast.net) (Ping timeout: 121 seconds)
[19:55:56] *** Joins: dpc_ (dpc@moz-t6gr4b.ca.comcast.net)
[20:12:51] <Ilari> bascule: Seen link to video recording on youtube somewhere?
[20:17:19] *** Quits: dpc_ (dpc@moz-t6gr4b.ca.comcast.net) (Ping timeout: 121 seconds)
[20:26:47] <Ilari> Lol: '"rigid"'.
[20:26:56] <Ilari> About MS curve generation method.
[20:31:02] *** Quits: erickt (erickt@moz-4hh.6p3.217.74.IP) (Ping timeout: 121 seconds)
[20:31:53] *** Joins: erickt (erickt@moz-4hh.6p3.217.74.IP)
[20:57:45] <bascule> Ilari: yep
[20:57:57] <bascule> oh, you mean for today?
[20:58:06] <bascule> I have yesterday's
[20:58:20] <Ilari> Yeah, saw yesterday's.
[20:58:52] <bascule> doesn't look like it's up yet
[20:58:57] <bascule> yeah I do want to watch the CFRG stuff, heh
[21:13:55] <bascule> Brian LaMacchia says the CFRG failed. Yeah, sour grapes
[21:24:45] <Ilari> Well, seemed like choosing curves took enormous amount of time... What do we know abou elliptic curves that we didn't a year ago?
[21:26:40] <bascule> Ilari: I guess FourQ? heh
[21:29:32] *** Quits: irobevjodu (ident@moz-mikldi.static-ro.twistednetworks.net) (Ping timeout: 121 seconds)
[21:36:39] <Ilari> Hmm... https://briansmith.org/GFp-0 
[21:39:51] *** Quits: gleb (gleb@moz-3u1drv.rusanovka-net.kiev.ua) (Ping timeout: 121 seconds)
[21:51:33] <bascule> Ilari: eenteresting
[21:52:30] *** Joins: dpc_ (dpc@moz-t6gr4b.ca.comcast.net)
[21:56:28] <Ilari> Also, multiple versions of the same code... Does storage size matter that much? All modern OSes can demand-page...
[22:01:33] *** Quits: skeuomorf (skeuomorf@moz-d5k.lok.32.197.IP) (Ping timeout: 121 seconds)
[22:06:37] <bascule> Ilari: depends who you ask
[22:18:39] *** Quits: brson (brson@moz-cfhap5.mtv2.mozilla.com) (Quit: Lost terminal)
[22:18:49] *** Joins: brson (brson@moz-cfhap5.mtv2.mozilla.com)
[22:20:43] *** Joins: irobevjodu (ident@moz-mikldi.static-ro.twistednetworks.net)
[22:39:25] *** Quits: irobevjodu (ident@moz-mikldi.static-ro.twistednetworks.net) (Connection closed)
[22:39:33] *** Joins: irobevjodu (ident@moz-mikldi.static-ro.twistednetworks.net)
[22:41:25] *** Quits: dpc_ (dpc@moz-t6gr4b.ca.comcast.net) (Ping timeout: 121 seconds)
[22:53:47] *** Joins: dpc (dpc@moz-6hj.vgf.99.38.IP)
[23:06:23] *** Quits: brson (brson@moz-cfhap5.mtv2.mozilla.com) (Quit: leaving)

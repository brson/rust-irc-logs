[00:00:01] <Eridius> well you need an allocation for the new array, but the ~[] seems unnecessary
[00:00:04] <Eridius> as it's not actually used
[00:00:17] <cmr> maikklein2: yes
[00:00:42] <dbaupp> Eridius: it is
[00:01:01] <Eridius> dbaupp: oh hmm, I forgot you called .extend(). I was thinking you still had m.structs = ....to_owned_vec()
[00:01:02] <dbaupp> Eridius: it becomes the new m.structs and is filled up by the output of the .filter
[00:01:09] <engla> Eridius: it could just be transformed in place I guess
[00:01:10] <dbaupp> yeah :)
[00:01:38] <brson> bblum: understood
[00:01:39] <Eridius> dbaupp: that said, it still involves an extra allocation in best-case scenario (best-case being where the .size_hint() is completely accurate), because it has to allocate the vec, then reallocate it while extending
[00:01:53] <sully> sigh
[00:02:05] <sully> the hardest part about actually fixing this bug
[00:02:11] <sully> is documenting it
[00:02:16] <dbaupp> Eridius: I imagine that's better than reallocating the whole AST with the transform(|x| x.clone() :)
[00:02:19] <cmr> sully: and adding testcases!
[00:02:22] <Eridius> dbaupp: true
[00:02:35] <sully> eh, the test cases are easy
[00:02:40] <cmr> yes but don't forget them
[00:03:04] <strcat> http://ix.io/76j C++ at -O2, and http://ix.io/76k -O3 (vectorized)
[00:03:05] *** Quits: samx (sami@moz-48EC0983.dyn.optonline.net) (Quit: This computer has gone to sleep)
[00:03:06] <strcat> hrmm
[00:04:15] <cmr> dbaupp: that'd be swap from std::util right?
[00:05:23] *** Quits: james4k (james@moz-E7990244.consolidated.net) (Ping timeout)
[00:05:23] <maikklein2> what is the replacement for platformthread?
[00:05:44] *** Joins: james4k (james@moz-E7990244.consolidated.net)
[00:06:23] <Eridius> cmr: yeah
[00:06:24] <maikklein2> is it "rt::start_on_main_thread"?
[00:07:09] <pcwalton> maikklein2: use #[start], and the entry point function there will be on the main thread
[00:07:14] <pcwalton> do your stuff there and then start the runtime
[00:08:12] *** Joins: ghrust (ghrust@FD7BC443.6A2AE50.F3114085.IP)
[00:08:13] <ghrust> 01[13rust01] 15bors merged 06auto into 06master: 02http://git.io/NrxBAQ
[00:08:13] *** Parts: ghrust (ghrust@FD7BC443.6A2AE50.F3114085.IP) ()
[00:08:17] <maikklein2> pcwalton, thanks
[00:08:49] <strcat> ughhhh why is it comparing with null
[00:11:08] *** Joins: ghrust (ghrust@AD60B2E3.6A2AE50.F3114085.IP)
[00:11:08] <ghrust> 01[13rust01] 15bors pushed 0 new commits to 06auto: 02http://git.io/GJ8gCQ
[00:11:08] *** Parts: ghrust (ghrust@AD60B2E3.6A2AE50.F3114085.IP) ()
[00:11:11] *** Joins: ghrust (ghrust@24260B07.6A2AE50.F3114085.IP)
[00:11:11] <ghrust> 01[13rust01] 15bors pushed 21 new commits to 06auto: 02http://git.io/KsBHdQ
[00:11:11] <ghrust> 13rust/06auto 146011f83 15Erick Tryzelaar: std: minor cleanup
[00:11:11] <ghrust> 13rust/06auto 1408b6cb4 15Erick Tryzelaar: std: add str.to_c_str()
[00:11:11] <ghrust> 13rust/06auto 14fd293df 15Erick Tryzelaar: std: rewrite run::with_{argv,envp,dirp} to copy C strings
[00:11:12] *** Parts: ghrust (ghrust@24260B07.6A2AE50.F3114085.IP) ()
[00:12:11] <cmr> dbaupp: all right!
[00:12:15] <cmr> visit.rs:22:8: 22:76 error: type `~[clean::Item]` does not implement any method in scope named `extend`
[00:12:35] <Eridius> cmr: update your rust?
[00:13:00] <Eridius> or is iterator::Extendable not in the prelude?
[00:13:04] <Eridius> maybe that's it. use iterator::Extendable
[00:13:11] *** Joins: Yurume (yurume@AC58A8CE.8A059B47.E313B915.IP)
[00:13:28] <Eridius> yeah, it's not in the prelude. That might want to be fixed
[00:13:29] <cmr> yup that was it
[00:13:34] <strcat> Eridius: https://github.com/mozilla/rust/pull/8326
[00:13:39] <Eridius> strcat: hah
[00:13:40] <strcat>  add Extendable to the prelude 
[00:16:02] *** Quits: azakai (alon@moz-BBE3ABD.mv.mozilla.com) (Ping timeout)
[00:16:44] <cmr> Much closer now it seems: https://github.com/cmr/rustdoc_ng/blob/wip/visit.rs#L24
[00:16:47] <cmr> Now I just get a lot of
[00:16:55] <cmr> visit.rs:23:76: 23:77 error: cannot borrow immutable dereference of & pointer as mutable
[00:16:57] <cmr> visit.rs:23         m.structs.extend(&mut foo.consume_iter().filter(|x| self.visit_item(x)));
[00:16:59] <cmr>                                                                                         ^
[00:17:07] <cmr> I think this is because filter wants/gives a & rather than &mut?
[00:17:10] *** Joins: ghrust (ghrust@2EE61FCC.6A2AE50.F3114085.IP)
[00:17:10] <ghrust> 01[13rust01] 15bors 04force-pushed 06auto from 146c6e853 to 145b4244d: 02http://git.io/N3iJvQ
[00:17:10] *** Parts: ghrust (ghrust@2EE61FCC.6A2AE50.F3114085.IP) ()
[00:17:11] *** Joins: ghrust (ghrust@1E8607E8.6A2AE50.F3114085.IP)
[00:17:11] <ghrust> 01[13rust01] 15bors pushed 3 new commits to 06auto: 02http://git.io/P6bTag
[00:17:11] <ghrust> 13rust/06auto 148a91ab9 15Jordi Boggiano: Add missing getopts::groups::optflagmulti function
[00:17:11] <ghrust> 13rust/06auto 14c86f2ff 15Jordi Boggiano: Turn OptGroups into a main opt and a main and an aliased opts...
[00:17:12] <ghrust> 13rust/06auto 146b8170a 15bors: auto merge of #8307 : Seldaek/rust/getopts_fixes, r=brson...
[00:17:14] *** Parts: ghrust (ghrust@1E8607E8.6A2AE50.F3114085.IP) ()
[00:17:16] <Eridius> cmr: |mut x|
[00:17:29] <strcat> cmr: use filter_map
[00:17:39] <strcat> filter passes you &A
[00:17:39] <Eridius> oh right you're using filter now
[00:17:50] *** Quits: jedisct1 (Mibbit@F4489DB3.9747582C.3464FAC3.IP) (Quit: http://www.mibbit.com ajax IRC Client)
[00:18:15] <cmr> strcat: I really don't want filter_map, that would imply moves of these non-trivially-sized values
[00:18:41] <Eridius> cmr: so you need some sort of filter_mut()
[00:18:46] <cmr> I think so, yes
[00:19:37] <Eridius> cmr: you're moving them internally anyway btw
[00:19:47] <strcat> yeah consume_iter moves
[00:20:05] <strcat> the pipeline is already moving them along
[00:20:22] <cmr> Oops, replaced with mut_iter
[00:20:35] <cmr> dbaupp: (thanks :p)
[00:20:36] <strcat> and use filter_map with that
[00:20:40] *** Quits: busylizzy (lisa@85228838.12D0DC84.211374C4.IP) (Ping timeout)
[00:20:55] *** Joins: infynyxx (infynyxx@DB780A29.749BA1D.DCC373F0.IP)
[00:21:33] <Eridius> cmr: just use filter_map. this will get inlined anyway, which will hopefully remove the actual cost of the moves
[00:21:34] <cmr> wait is mut_iter doing moves too?
[00:21:45] <strcat> no it's using &mut
[00:21:49] <cmr> ok
[00:21:55] <Eridius> cmr: how can you use .mut_iter, unless you reintroduce cloning?
[00:22:02] <strcat> iter yields &T, mut_iter yields &mut T
[00:22:03] <cmr> ah to_mut_ptr I see now
[00:22:09] <strcat> where the vector is ~[T]
[00:22:23] *** Quits: james4k (james@moz-E7990244.consolidated.net) (Ping timeout)
[00:22:48] <cmr> Oh the impl is also a macro, that'd be why / didn't find it
[00:23:18] <cmr> Eridius: anyway I would like the semantics of my program to be as near as possible to the desired behavior pre-optimization
[00:23:43] <Eridius> cmr: unless you're willing to write a .filter_mut() adaptor, I think your alternative is to switch over to an explicit for loop
[00:23:58] <strcat> I don't see why you need filter_mut
[00:24:11] <strcat> use mut_iter and filter_map, and filter_map will pass you &mut
[00:24:13] *** Quits: hjr3 (hradtke@374E545A.3A8E9B0C.F9D9C60E.IP) (Quit: My MacBook has gone to sleep. ZZZzzzâ€¦)
[00:24:38] <Eridius> strcat: he can't use mut_iter because then he'll have to reintroduce cloning in order to avoid having the results be ~[&Item]
[00:24:47] <Eridius> but .consume_iter + .filter_map will work
[00:25:04] <strcat> consume_iter + filter_map won't be any slower than consume_iter + filter
[00:25:17] <cmr> I'm not using consumer_iter
[00:25:23] <cmr> guh every time I make that typo
[00:25:30] <engla> pro_iter is better
[00:25:35] <Eridius> cmr: you are in the most recent version you linked
[00:25:49] <cmr> pushed
[00:26:20] <cmr> strcat: basically I'm visiting a huge structure and anything that moves or copies in this visitor is going to move or copy every single item in it, and that sucks
[00:26:33] <Seldaek> yay sane getopts merged, small victories :p
[00:26:45] <Eridius> cmr: if you use .mut_iter(), that yields &mut Item, but it doesn't actually move htem out of foo. Which means that your final iterator chain is Iterator<&Item>, which isn't valid
[00:27:07] <strcat> cmr: if you're using mut_iter, filter_map is just handing you &mut
[00:27:11] <strcat> it's not somehow moving the actual object
[00:27:21] <cmr> strcat: but I'm *returning* a T, not a &mut T, aren't I?
[00:27:25] <cmr> in the Option?
[00:27:30] <maikklein2> brson, ping
[00:27:40] <strcat> cmr: I'm not sure what you're doing anymore
[00:27:43] <Peter> hey, is anyone else seeing the same crash in this program: https://gist.github.com/peterdn/6170153 (Ubuntu 12.04; in both rust 0.7 and 0.8-pre)
[00:27:45] <strcat> if you use mut_iter
[00:27:53] <strcat> the iterator's generic type is &mut T
[00:27:53] <Eridius> cmr: foo.mut_iter() is an Iterator<&mut Item>. calling .filter on it doesn't change that. And you can't use .filter_map to get Iterator<Item> because that will have to move out of a &mut pointer
[00:28:07] <strcat> filter_mut will pass you &mut T and expect Option<&mut T>
[00:28:13] <doomlord_> doesn't look too nice yet, but i've got 'rustfind' generating linked html source (.. and not everything links yet)
[00:28:30] <strcat> iterators don't deref references
[00:28:41] <strcat> they are generic - they have no knowledge of A, there are no bounds
[00:29:02] <strcat> the only want to change the type is by actually using transform/filter_map to change it
[00:29:07] <strcat> but you can leave it the same
[00:29:58] <Eridius> I'm beginning to think that maybe OwnedVector should have a fn filter() on it (and I guess a .filter_mut(), since that's really what cmr needs), because it can do that efficiently
[00:30:15] <strcat> don't know what you mean - an in-place one?
[00:30:20] <cmr> Ok, right, and I need to move out of the Iterator into the new array anyway
[00:30:29] <Eridius> yeah
[00:30:38] <kmc> so I have a simple internal iterator for trees, which is recursive; is there a nice way to make it into an external iterator, or do I pretty much need to reify what used to be the call stack into a struct
[00:30:38] <cmr> strcat: yeah, I'm basically trying to do an efficient in-place filter
[00:30:43] <cmr> ...that mutates the items
[00:30:56] <cmr> right now I'm just building a new vector
[00:30:56] <strcat> cmr: well you don't want iterators then, because random access iterators aren't mature
[00:31:00] <Eridius> cmr: you should just use .consume_iter and .filter_map and then double-check the generated code (assuming you can read LLVM IR and/or assembly)
[00:31:01] <maikklein2> Peter, I added a comment
[00:31:09] *** Quits: tcr (tcr@D26BCFC9.C2203064.EDCE493E.IP) (Client exited)
[00:31:14] <cmr> strcat: why do I need RAI? going in one direction until the end is fine
[00:31:22] <strcat> cmr: because you want to remove elements
[00:31:28] <strcat> you can't remove an element from the middle of a vector
[00:31:33] <strcat> you have to swap it to the end (random access)
[00:31:34] <cmr> right; I'm building a new vector for that right now unfortunately
[00:31:42] <cmr> Ah I see
[00:31:44] <engla> there is an inplace filter in vec, .retain()
[00:31:45] <strcat> if you want to do it in-place you need swap
[00:31:57] <cmr> keeping order would be nice..
[00:32:03] <maikklein2> Peter, you shoul still file an issue
[00:32:07] <Eridius> engla: huh. Didn't know that. why is it retain() instead of filter()?
[00:32:15] <strcat> cmr: you can't both keep order and avoid inefficiency
[00:32:24] <engla> I guess old vec filter used to return a new ~[]
[00:32:25] <cmr> strcat: Yes, I see that now
[00:32:30] *** Quits: ecr (Thunderbir@moz-BBE3ABD.mv.mozilla.com) (Quit: ecr)
[00:32:41] <Eridius> strcat: you can do in-place with a single move per element
[00:33:05] <strcat> Eridius: that's still pretty inefficient
[00:33:11] *** Quits: snadon (chatzilla@moz-3BC727E8.mc.videotron.ca) (Ping timeout)
[00:33:23] <cmr> I guess what I want is ~[~Item] so that the moves aren't huge copies
[00:33:26] <Eridius> strcat: unless you start with a linked list, or some other non-dense structure, I don't see any alternative
[00:33:33] <Eridius> strcat: and if you don't end up filtering anything you don't need any moves
[00:33:43] <Eridius> cmr: maybe so
[00:33:51] <engla> Eridius: it's one swap per element deleted (one swap is ~2 moves?)
[00:33:57] <strcat> you need 1 swap per element you remove if you don't maintain order
[00:34:11] <Eridius> engla: 2 moves, but it's also 2 elements, so that makes it one move per element
[00:34:26] <Eridius> strcat: no you can do it maintaining order
[00:34:33] <strcat> then you need more swaps?
[00:34:55] <strcat> you need to touch the elements you didn't remove too
[00:34:59] <strcat> to fill the gaps
[00:35:09] <Eridius> strcat: right, but that's just one move per element, to move it into its correct location
[00:35:09] <cmr> Oh maybe I'm doing it wrong!
[00:35:14] <cmr> Is there a better data structure for this?
[00:35:20] <Eridius> and any elements that occur before the first filtered-out element don't need any moves
[00:35:21] <cmr> I by no means need to use a vector
[00:35:35] <Peter> maikklein2: ah, thanks -- is that the correct way of doing this? I think I'm still missing some subtleties about what makes the two different :)
[00:35:40] <Eridius> cmr: a linked list lets you remove elements trivially
[00:36:00] <Eridius> cmr: of course it requires an allocation per element, which is basically what you'd get if you used ~[~Item]
[00:36:37] <maikklein2> Peter, I think there are issues with mut and let I don't think you can do this in one line atm
[00:36:43] *** Joins: pnkfelix (pnkfelix@moz-43495417.fbx.proxad.net)
[00:38:20] <cmr> So now I'm confused too
[00:38:25] <maikklein2> can we bind objective-c atm?
[00:40:09] <strcat> if the objective-C exposes a stable ABI with cdecl calling conventions
[00:40:11] <strcat> same as C++
[00:40:15] <Eridius> ok I'm actually slightly wrong. Worst-case is 2 moves per element
[00:40:25] <cmr> Requirements: maintain order, filter out elements using a filter function that can mutate the element, don't be horribly inefficient
[00:40:54] <Eridius> strcat: you can call objc_msgSend() directly if you want
[00:41:16] *** Joins: SiegeLord (sl@moz-CAF07B4C.hsd1.ma.comcast.net)
[00:41:27] <Eridius> I can drop it back down to 1 move per element if I'm willing to use some unsafe code
[00:43:28] <maikklein2> brson, I made a small PR
[00:43:33] <Eridius> looks like fn retain() is already implemented pretty much the way I was thinking of (for the safe version), except of course it doesn't give mutable values to the closure
[00:44:33] *** Quits: RMF (RMF@moz-713EF9F4.dsl.telepac.pt) (Ping timeout)
[00:44:54] <cmr> strcat: Wouldn't using mut_iter + filter_map require a clone, to "strip" the &mut, since I'm extending a vector with the iterator it returns?
[00:45:08] *** Quits: maikklein2 (maik@moz-89870D9B.dip0.t-ipconnect.de) (Ping timeout)
[00:45:08] <engla> Eridius: it could give &mut T  without any problems though?
[00:45:11] <Eridius> cmr: yes, hence why you should use .consume_iter()
[00:45:14] <Eridius> engla: yeah it could
[00:45:28] <cmr> Eridius: Right, but .consume_iter() + filter gives me &Item, which I cannot mutate
[00:45:32] <Eridius> engla: the question is, should it just do that, or should there be a .retain_mut() variant? (and should we rename it back to filter)
[00:45:39] <strcat> cmr: use filter_map.
[00:45:44] <Eridius> cmr: hence filter_map
[00:45:47] *** Joins: adu (ajr@moz-F1F8E03E.washdc.fios.verizon.net)
[00:45:48] <cmr> oh right
[00:46:17] <cmr> that makes my API ugly but I suppose it's fine
[00:46:31] *** Quits: pnkfelix (pnkfelix@moz-43495417.fbx.proxad.net) (Quit: Leaving.)
[00:46:38] *** Quits: ivan (ivan@moz-531C3EC9.members.linode.com) (Ping timeout)
[00:47:13] <Eridius> cmr: every one of these fields appears to be the same, a ~[Item]? And you're processing them the same? You can probably refact that
[00:47:41] <cmr> Eridius: they are the same type, but the contents are different, dynamically.
[00:47:51] <cmr> Instead of using Item<T>, all the possible T are an enum that is included
[00:48:03] <Eridius> cmr: sure, but I mean you could just iterate over [&mut m.structs, &mut m.enums, ...] and only implement the logic once
[00:48:14] *** Quits: Peter (chatzilla@moz-97742234.new.ox.ac.uk) (Quit: ChatZilla 0.9.90-rdmsoft [XULRunner 18.0.2/20130201065344])
[00:48:15] <cmr> Eridius: Oh that'd be really nice, how can I do that? :)
[00:49:15] <Eridius> for field in [&mut m.structs, &mut m.enums, etc].iter() { let mut foo = ~[]; swap(*field, &mut foo); (*field).extend(...); }
[00:49:18] <Eridius> or something like that
[00:49:42] <engla> Eridius: just updating the function was my notion
[00:50:09] <Eridius> engla: I don't have a problem with just updating it to take a &mut, since that works and will be compatible with any code that just wants &
[00:50:56] <Eridius> would like to rename it back to filter() too since retain() is unusual
[00:51:17] <cmr> Cool that typechecks
[00:51:27] <cmr> If it's a perf issue will look into doing something else
[00:51:37] <cmr> but at least it isn't cloning the entire thing like before
[00:51:37] <Seldaek> tjc: got my mail about rustpkg? just checking because I found your email someplace random
[00:51:44] *** Joins: ivan (ivan@moz-531C3EC9.members.linode.com)
[00:51:48] <tjc> Seldaek: I did, sorry I didn't respond yet
[00:51:52] <tikue> rusti: let foo = Some(~"hi"); let bar = foo.expect_ref("why isn't this a real method"); print(bar);
[00:51:53] -rusti- <anon>:5:42: 5:89 error: type `std::option::Option<~str>` does not implement any method in scope named `expect_ref`
[00:51:53] -rusti- <anon>:5          let foo = Some(~"hi"); let bar = foo.expect_ref("why isn't this a real method"); print(bar);
[00:51:53] -rusti-                                                    ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
[00:51:53] -rusti- error: aborting due to previous error
[00:51:55] -rusti- application terminated with error code 101
[00:52:02] <tjc> Seldaek: if you don't mind re-sending it to the mailing list, actually, I can respond there...
[00:52:06] <tjc> that way other people can weigh in :-0
[00:52:07] *** Quits: true_droid (true_droid@moz-123FD9B8.beck.volia.net) (Client exited)
[00:52:08] <tjc> :-)
[00:52:38] <Seldaek> tjc: I'm headed to bed, but feel free to reply to the ml, if you quote relevant parts I guess it's enough context?
[00:52:50] <tjc> Seldaek: Ok, just didn't want to do that without your permission
[00:53:06] <Seldaek> go for it :)
[00:53:07] <Seldaek> cya
[00:53:39] <tjc> 'night
[00:54:17] <kmc> sully: I think merging the traits will work.  though I'd love a better solution if you come up with one :)
[00:54:35] <kmc> merging them produces a lot of static method calls and misc syntactic noise
[00:54:42] <sully> kmc: you might be able to get away with making those methods default methods on one of the traits
[00:54:52] <sully> kmc: I'm not quite sure, though
[00:55:06] <kmc> rather than an impl?
[00:55:11] <sully> yeah
[00:55:14] <kmc> and then each of the (only two) users would have an empty impl
[00:55:14] <kmc> ok
[00:55:19] <kmc> I'll try that tomorrow
[00:55:50] * kmc â†’ away, cheers all
[00:55:52] <Eridius> oh damn, can't use the name .filter() because of the method resolution bug
[00:56:09] *** Joins: ghrust (ghrust@F6EE6DE3.6A2AE50.F3114085.IP)
[00:56:10] <ghrust> 01[13rust01] 15bors 04force-pushed 06auto from 146b8170a to 145b4244d: 02http://git.io/N3iJvQ
[00:56:10] *** Parts: ghrust (ghrust@F6EE6DE3.6A2AE50.F3114085.IP) ()
[00:56:10] *** Joins: ghrust (ghrust@FD7BC443.6A2AE50.F3114085.IP)
[00:56:10] <ghrust> 01[13rust01] 15bors pushed 12 new commits to 06auto: 02http://git.io/-miPOA
[00:56:10] <ghrust> 13rust/06auto 1452787e9 15Brian Anderson: std::rt: 2MB stacks again
[00:56:10] <ghrust> 13rust/06auto 14260b444 15Brian Anderson: std::rt: Pull RUST_MIN_STACK from the environment
[00:56:11] <ghrust> 13rust/06auto 141bf5b19 15Brian Anderson: std: Allow spawners to specify stack size
[00:56:13] *** Parts: ghrust (ghrust@FD7BC443.6A2AE50.F3114085.IP) ()
[00:56:30] <Eridius> also, surprisingly, I was wrong about switching to &mut not breaking anything. If you give it an extern "Rust" fn that takes a &T it complains that the mutability is different
[00:57:43] *** Quits: tchoma (tchoma@moz-BE33DA21.fw1.sfo1.mozilla.net) (Ping timeout)
[00:58:40] <cmr> Alrighty now I get this weird error on https://github.com/cmr/rustdoc_ng/blob/wip/visit.rs#L37
[00:58:48] <cmr> visit.rs:55:34: 55:43 error: cannot borrow immutable anonymous field as mutable
[00:58:49] <cmr> visit.rs:55                 clean::ModuleItem(ref mut m) => m,
[00:58:51] <cmr>                                               ^~~~~~~~~
[00:58:53] <cmr> What in the world in an anonymous field
[00:59:21] <Eridius> cmr: x is immutable
[00:59:39] <adu> is it like a superclass?
[00:59:43] <Eridius> cmr: x is immutable, so x.inner is immutable. the anonymous field is the m in clean::ModuleItem(m)
[00:59:47] <Eridius> cmr: try using |mut x|
[01:00:44] <cmr> Eridius: no change
[01:00:50] <Eridius> :/
[01:00:58] <cmr> Oops
[01:01:00] <cmr> wrong mut x
[01:01:02] <Eridius> hah
[01:01:12] * cmr should have been in bed an hour ago
[01:01:17] <cmr> visit.rs:33:65: 33:66 warning: variable does not need to be mutable [-W unused-mut (default)]
[01:01:19] <cmr> It lies!
[01:01:21] *** Quits: dherman (dherman@moz-6CA476B1.hsd1.ca.comcast.net) (Quit: dherman)
[01:01:21] <Eridius> also, filter_map(..).transform()? You can fold that transform into the prior filter_map
[01:01:38] *** Joins: mihneadb_ (mihneadb@E48845AB.3A9F9BD4.4C2245EF.IP)
[01:01:52] <cmr> Eridius: not without doing the same logic filter_map is already doing with the Option return value
[01:01:58] *** Quits: mihneadb (mihneadb@E48845AB.3A9F9BD4.4C2245EF.IP) (Ping timeout)
[01:01:58] * cmr checks the IR
[01:02:03] *** Joins: dherman (dherman@moz-6CA476B1.hsd1.ca.comcast.net)
[01:02:03] *** ChanServ sets mode: +o dherman
[01:02:48] <Eridius> cmr: you can use .map_consume() on the results of .visit_item() instead of the second transform, although tbh that's not much of a difference
[01:02:55] <Eridius> it just looks weird to have .filter_map().transform()
[01:03:10] *** Joins: tcr (tcr@moz-EE576D3C.hsd1.ma.comcast.net)
[01:03:18] <cmr> Ugh so many monomorphized hashmaps
[01:03:39] <cmr> and option too
[01:03:47] <cmr> This can't be good for code size
[01:04:08] <adu> cmr: in Rust I think an anonymous field is something like Cons(T, List<T>), as opposed to Cons { car: T, cdr: List<T> }
[01:04:09] *** Quits: dherman (dherman@moz-6CA476B1.hsd1.ca.comcast.net) (Quit: dherman)
[01:04:19] <cmr> adu: yeah, that was it I think
[01:04:22] <cmr> I'd just never heard the term before
[01:04:39] <adu> cmr: in Go, anonymous field is a superclass/superstruct
[01:05:17] *** Joins: tcr_ (tcr@moz-EE576D3C.hsd1.ma.comcast.net)
[01:05:22] *** Quits: tcr (tcr@moz-EE576D3C.hsd1.ma.comcast.net) (Connection reset by peer)
[01:06:11] *** Quits: mschifer (Adium@moz-BBE3ABD.mv.mozilla.com) (Quit: Leaving.)
[01:08:25] *** Quits: eschweic (Adium@moz-BBE3ABD.mv.mozilla.com) (Quit: Leaving.)
[01:09:41] <tikue> rusti: let mut foo = 0; match 2 { foo => { foo = 1; } }
[01:09:43] -rusti- pastebinned 13 lines of output: http://sprunge.us/gSAU
[01:09:56] <tikue> rusti: let mut foo = 0; match 2 { foo => { foo = 1; } } foo
[01:09:57] -rusti- pastebinned 10 lines of output: http://sprunge.us/ScJT
[01:10:36] <tikue> rusti: let mut foo = 0; match 2 { foo => { foo = 1; printfln!(foo); } } foo
[01:10:36] -rusti- <anon>:5:17: 5:20 warning: variable does not need to be mutable [-W unused-mut (default)]
[01:10:37] <cmr> tikue: that's a weird combination of errors
[01:10:37] -rusti- <anon>:5          let mut foo = 0; match 2 { foo => { foo = 1; printfln!(foo); } } foo
[01:10:37] -rusti-                           ^~~
[01:10:37] -rusti- 1
[01:10:37] -rusti- 0
[01:10:44] <tikue> cmr: ya
[01:10:45] <cmr> Not errors, but names
[01:10:49] <tikue> lol
[01:10:52] <cmr> I have no idea how that would workd
[01:10:58] <tikue> nor do i
[01:11:07] <cmr> I'd assume the binding introduced by the match would be immutable, and also shadow the eralier binding
[01:11:11] <tikue> same
[01:11:12] <cmr> pcwalton: ^ check that out
[01:12:10] <pcwalton> what am I looking at?
[01:12:30] <cmr> I don't acutlaly know, I thought there was some serious weirdness there for a second but I misread it
[01:12:58] <tikue> why does it let you mutate foo
[01:13:41] <aatch> tikue, move by default
[01:13:57] <aatch> Oh, I guess that without 'mut' it should still be immutable.
[01:14:02] <aatch> Nevermind.
[01:14:09] * aatch goes back to database code
[01:14:19] *** Joins: Kruppe (user@moz-E150F49F.cpe.net.cable.rogers.com)
[01:18:20] *** Joins: vk_ (chatzilla@F92596F.2DEF7520.EF7679FA.IP)
[01:20:38] *** Quits: maxli (maxli@13F2CEC5.7672369.D8E68FF6.IP) (Quit: Leaving.)
[01:21:34] *** Quits: mihneadb_ (mihneadb@E48845AB.3A9F9BD4.4C2245EF.IP) (Input/output error)
[01:25:23] *** Quits: graydon (Adium@A5087023.2354C43D.D8E68FF6.IP) (Quit: Leaving.)
[01:26:20] *** Joins: ghrust (ghrust@1E8607E8.6A2AE50.F3114085.IP)
[01:26:20] <ghrust> 01[13rust01] 15bors 04force-pushed 06auto from 14a163a49 to 145b4244d: 02http://git.io/N3iJvQ
[01:26:20] *** Parts: ghrust (ghrust@1E8607E8.6A2AE50.F3114085.IP) ()
[01:26:22] *** Joins: ghrust (ghrust@2EE61FCC.6A2AE50.F3114085.IP)
[01:26:23] <ghrust> 01[13rust01] 15bors pushed 2 new commits to 06auto: 02http://git.io/I6TK_A
[01:26:23] <ghrust> 13rust/06auto 1426de4eb 15Alex Crichton: Add some documentation about globals in ffi docs
[01:26:23] <ghrust> 13rust/06auto 14d1d33a1 15bors: auto merge of #8322 : alexcrichton/rust/ffi-dox, r=thestinger...
[01:26:23] *** Parts: ghrust (ghrust@2EE61FCC.6A2AE50.F3114085.IP) ()
[01:26:25] *** Quits: vk_ (chatzilla@F92596F.2DEF7520.EF7679FA.IP) (Quit: ChatZilla 0.9.90.1 [Firefox 23.0/20130729175331])
[01:26:51] <cmr> https://github.com/cmr/rustdoc_ng/blob/wip/passes.rs#L22
[01:26:56] <cmr> 10 leves of awesome!
[01:27:54] *** Quits: q66 (q66@6EE9DE40.46454B5D.33AABD5F.IP) (Quit: Leaving)
[01:27:55] *** Quits: jensnockert (jensnocker@moz-A5E5C224.mobileonline.telia.com) (Input/output error)
[01:29:28] <brson> cmr: that's pretty hot
[01:29:59] *** Quits: thomaslee (thomaslee@moz-6C3931E3.static.twtelecom.net) (Client exited)
[01:32:40] *** Joins: dherman (dherman@moz-6CA476B1.hsd1.ca.comcast.net)
[01:32:40] *** ChanServ sets mode: +o dherman
[01:33:07] *** Quits: strcat (strcat@moz-61B073BC.cpe.net.cable.rogers.com) (Quit: WeeChat 0.4.1)
[01:33:13] *** Quits: rusti (rusti@moz-61B073BC.cpe.net.cable.rogers.com) (Client exited)
[01:38:06] <pcwalton> cmr: you could use a guard to reduce it by 1
[01:38:20] <pcwalton> actually 2
[01:38:27] *** Quits: dherman (dherman@moz-6CA476B1.hsd1.ca.comcast.net) (Quit: dherman)
[01:38:39] <cmr> good idea
[01:38:49] <cmr> Wait where do you see the second one?
[01:39:26] <pcwalton> it'll just remove 2 levels since you don't need to indent for the if or its body
[01:39:36] <cmr> ah
[01:39:48] <cmr> 2 levels of indentation, but not braces
[01:40:02] *** Quits: echristo (echristo@DCF57675.D6CCE4AE.77834EAA.IP) (Quit: echristo)
[01:42:09] <tikue> cmr: don't need to allocate for ~"doc" right? could just use *?
[01:42:18] <tikue> oh nvm
[01:42:18] <tikue> :)
[01:42:21] <cmr> tikue: no, because it's a Word(~str)
[01:42:29] <cmr> Or, rather List(~str, ~[Attribute])
[01:42:32] <cmr> It doesn't autoborrow it
[01:42:34] <cmr> ...I think
[01:42:46] <tikue> could u do "hidden" == s
[01:42:50] <tikue> instead of ~"hidden"
[01:43:10] <cmr> same problem, but haven't even compiled it yet
[01:43:12] <cmr> we'll see
[01:43:23] *** Joins: dherman (dherman@moz-6CA476B1.hsd1.ca.comcast.net)
[01:43:23] *** ChanServ sets mode: +o dherman
[01:43:24] *** Quits: pcwalton (pcwalton@moz-7B0110AD.mv.mozilla.com) (Quit: pcwalton)
[01:43:27] *** Joins: recrack (Mibbit@B4104EBB.3CC170B1.1E14B209.IP)
[01:47:02] <brson> does anybody know why the XorShift default constructor uses a constant seed?
[01:47:13] <cmr> brson: cheapness I imagine
[01:47:18] <brson> seems footgunny
[01:47:19] <bjz> cmr: I'm guessing maikklien would have wanted something more like Ogre
[01:47:22] <cmr> yeah it does
[01:47:23] *** Joins: RMF (RMF@moz-2758EDDD.dsl.telepac.pt)
[01:47:29] <cmr> bjz: isn't Ogre in C++?
[01:47:35] <bjz> cmr: yup
[01:47:40] *** Quits: tcr_ (tcr@moz-EE576D3C.hsd1.ma.comcast.net) (Client exited)
[01:47:44] <bjz> cmr: just an example though
[01:48:49] *** Joins: tcr (tcr@moz-EE576D3C.hsd1.ma.comcast.net)
[01:48:54] <bjz> cmr: SDL isn't really a graphics engine, it's the foundations of one
[01:49:08] <cmr> bjz: I know, I was initially confused by the question but realized that later
[01:49:22] <cmr> but *are* there any rendering engines written in C?
[01:49:25] <cmr> (good ones, at least)
[01:51:15] <bjz> cmr: don't think so. corange is kinda neat just to read (in a 'code as literature' kind of way), but it's more of an experiment
[01:51:18] <cmr> tikue: yeah I can do that
[01:51:23] <tikue> cool :D
[01:51:28] *** Joins: ross (ross@moz-8A84103E.br.br.cox.net)
[01:51:30] <cmr> tikue: thanks for the suggestion!
[01:51:35] <tikue> no prob :)
[01:51:52] <bjz> cmr: https://github.com/l0garhythm/Corange
[01:52:20] *** Quits: eatkinson (eatkinson@moz-BBE3ABD.mv.mozilla.com) (Quit: eatkinson)
[01:52:35] <cmr> bjz: well the *output* is certainly nice!
[01:52:50] <cmr> I can't imagine having to write and maintain a large codebase in C though :\
[01:53:00] <bjz> woops, this is the original: https://github.com/orangeduck/Corange
[01:53:08] <bjz> (bloody github)
[01:53:11] *** Quits: bent (chatzilla@moz-932324BF.hsd1.ca.comcast.net) (Quit: ChatZilla 0.9.90.1-rdmsoft [XULRunner 22.0/20130619132145])
[01:53:56] <cmr> Yeah, it rolls vtables manually
[01:54:09] <cmr> the code looks pretty clean though
[01:54:21] <bjz> aye, that's why I like it
[01:54:41] <bjz> but just from an aesthetic point of view
[01:55:01] <bjz> I would just do the graphics engine in Rust
[01:55:36] <cmr> I'm not sure how well Rust will scale to large codebases. I like it a lot so far, and it seems like it will do well, but experience will tell.
[01:55:38] *** Quits: dherman (dherman@moz-6CA476B1.hsd1.ca.comcast.net) (Quit: dherman)
[01:56:03] <bjz> aye
[01:56:23] *** Quits: Uther (Instantbir@moz-1B244B05.hfc.dyn.abo.bbox.fr) (Ping timeout)
[01:57:00] <bjz> cmr: traits could be difficult
[01:57:40] <brson> xorshift never generates 0
[01:57:53] <bjz> cmr: I have a feeling they might be more a 'library thing'. but we'll see :)
[01:58:12] <cmr> bjz: I've yet to see a large codebase that didn't have a non-significant amount of "library code"
[01:58:37] <bjz> cmr: this is true
[01:59:33] <miloshadzic> coring looks amazing
[01:59:37] <miloshadzic> *corange
[01:59:40] *** Quits: dew (Instantbir@moz-8A63B53.dhcp.stls.mo.charter.com) (Ping timeout)
[01:59:44] *** Joins: dew (Instantbir@moz-8A63B53.dhcp.stls.mo.charter.com)
[02:00:36] <tikue> "Written in Pure C (Because it is beautiful)"
[02:00:36] <bjz> miloshadzic: it's neat huh? especially in contrast to the likes of Ogre
[02:00:37] <tikue> wat
[02:00:45] <bjz> tikue: yes
[02:00:55] <bjz> tikue: C can be beautiful
[02:01:14] <tikue> heh, i suppose I actually do agree
[02:01:28] <bjz> tikue: folks are too religious
[02:01:33] <cmr> The mesa codebase (at least the parts I've seen) are quite nice
[02:01:58] <cmr> meh tenses are hard
[02:02:34] <bjz> I guess the idea from a language design point of view is to make beautiful code easier to write
[02:02:49] <cmr> bjz: and also bad code harder to write
[02:02:50] <miloshadzic> I can't seem to find a function to convert a string to upper/lowercase
[02:02:55] <tikue> well I think rust is beautiful '^'
[02:02:57] <cmr> miloshadzic: One doesn't exist
[02:02:59] <bjz> cmr: yes yes
[02:03:13] <cmr> miloshadzic: we don't do proper unicode handling, so we don't do it at all
[02:03:17] <cmr> miloshadzic: there's stuff in std::ascii though
[02:03:32] <bjz> tikue: there is ugly Rust code, believe me :)
[02:03:42] <tikue> bjz: but I think the language is beautiful ._.
[02:04:05] <miloshadzic> cmr, thanks
[02:04:08] <brson> acrichto: does your llvm patch add no_split_stacks to llvm??
[02:04:48] <acrichto> brson: yes
[02:05:08] <acrichto> brson: https://github.com/alexcrichton/llvm/commit/915a7fb4a19368cf14dc335d60ba2c6e0a5cc70a
[02:05:25] <acrichto> I think that the string-attribute syntax was made to make things super-easy
[02:05:57] *** Joins: curmet (Mibbit@F7BDAFB8.6B56EC2F.AC9CCDD1.IP)
[02:06:08] <brson> acrichto: I think it needs to be no_split_stack to match gcc: http://gcc.gnu.org/wiki/SplitStacks
[02:06:14] <brson> let me check the gcc source to see
[02:06:30] *** Quits: tjc (tjc@moz-BBE3ABD.mv.mozilla.com) (Quit: Places to go, people to annoy)
[02:06:44] <acrichto> oh I was just basing this off other llvm attributes, in rust it's no_split_stack, let me see what other llvm attributes look like
[02:07:06] <brson> ah, I guess the C attribute could be different than the llvm
[02:07:41] <acrichto> brson: no-realign-stack,no-nans-fp-math,mips_16_fp_stub,nvptx-f32ftz -- slight favoring of the hyphen over the underscore?
[02:07:44] <acrichto> those are just in LLVM
[02:08:01] <brson> haha, great
[02:08:05] *** Quits: curmet (Mibbit@F7BDAFB8.6B56EC2F.AC9CCDD1.IP) (Quit: http://www.mibbit.com ajax IRC Client)
[02:08:14] <acrichto> perhaps fixedstacksegment should be fixed-stack-segment
[02:08:19] <brson> it probably should be, yeah
[02:08:33] *** Joins: erickt (etryzelaar@F6368174.6206BE40.7FC6A66E.IP)
[02:08:37] <brson> ok, hyphen is fine. I guess the llvm attr doesn't need to bear relation to the C attr
[02:08:46] *** Quits: jeaye (Jeaye@moz-FD505E54.hsd1.ca.comcast.net) (Ping timeout)
[02:08:48] * acrichto changes fixedstacksegment
[02:10:51] <brson> thanks for tackling this stuff
[02:13:23] <acrichto> no problem, I'm hoping that the ignored assertion can go away soon though
[02:14:05] *** Quits: carllerche (carllerche@6B070D22.7E6A0813.1428D117.IP) (Quit: carllerche)
[02:14:24] *** Joins: carllerche (carllerche@6B070D22.7E6A0813.1428D117.IP)
[02:15:01] <acrichto> brson: just updated with fixed-stack-segment instead of fixedstacksegment
[02:17:14] *** Joins: brson_ (brson@moz-BBE3ABD.mv.mozilla.com)
[02:17:14] *** Quits: brson (brson@moz-BBE3ABD.mv.mozilla.com) (Connection reset by peer)
[02:18:28] *** Quits: erickt (etryzelaar@F6368174.6206BE40.7FC6A66E.IP) (Ping timeout)
[02:18:37] <brson_> acrichto: hm, are you making branches for each of our llvm submodule commits? since we rebase llvm we need to keep all those old commits around in order to not break history. my repo has a dozen rust-XXXX-do-not-delete branches, just to hold on to those historic commits
[02:18:49] <brson_> we should really put llvm and libuv under a mozilla repo
[02:19:16] <brson_> i guess the more time goes by the less likely it is that somebody will try to build old commits
[02:19:52] <acrichto> brson_: once a branch is committed as a revision in rust, I won't delete it, but before it's committed I've been rebasing our few patches on top of llvm's master
[02:19:55] <brson_> but it kind of sucks to think that history could be forever broken
[02:20:49] *** Joins: ChrisMorgan (chris@moz-6AC741CA.static.tpgi.com.au)
[02:20:53] <acrichto> although so far my naming scheme isn't very good, right now my 'llvm-33' branch points at what rust is currently pointing at and that's about it
[02:21:57] <brson_> ok, sure but now our history llvm branches are split between my repo and your repo
[02:22:05] <brson_> we should probably start a mozilla-rust org on github
[02:22:07] *** Joins: snadon (chatzilla@moz-3BC727E8.mc.videotron.ca)
[02:22:12] <brson_> we're going to probably need it for the incubator anyway
[02:22:31] <cmr> A shame http://github.com/rust is taken
[02:22:48] <cmr> https://github.com/rust-lang isn't though
[02:23:02] <cmr> (what's the incubator?)
[02:23:08] <brson_> yeah, maybe we should not use the name mozilla
[02:23:18] <brson_> we generally try to distance rust from mozilla for that kind of thing
[02:23:24] <acrichto> brson_: I'd be fine pushing my branches to mozilla/rust-llvm and pointing rust at that (it definitely makes the most sense)
[02:23:29] <brson_> we do have a mozilla-servo org
[02:23:39] *** Quits: wilmoore (wilmoore@moz-7EE4D9D6.mystrotv.com) (Client exited)
[02:23:47] <acrichto> oh, maybe not
[02:23:57] *** Quits: SiegeLord (sl@moz-CAF07B4C.hsd1.ma.comcast.net) (Connection reset by peer)
[02:24:02] *** Joins: wilmoore (wilmoore@moz-7EE4D9D6.mystrotv.com)
[02:24:21] <brson_> cmr: the package incubator where the modules in extra will probably end up
[02:24:27] <cmr> oh
[02:24:55] <cmr> that doesn't sound like a good idea to me
[02:25:03] <brson_> why?
[02:25:06] <cmr> as python has demonstrated, including a library in the stdlib is a surefire way to let it rot
[02:25:44] *** Quits: wilmoore (wilmoore@moz-7EE4D9D6.mystrotv.com) (Ping timeout)
[02:25:44] <cmr> you can't have two codebases for a crate, one that lives as a module in extra and one that is standalone, not easily
[02:25:53] <brson_> they would all be standalone
[02:25:59] <brson_> extra will die
[02:26:24] <cmr> ah
[02:26:29] <cmr> that is fine to me then
[02:26:59] *** Joins: strcat (strcat@moz-54F7FD49.cpe.net.cable.rogers.com)
[02:27:00] <cmr> Oh I see now
[02:27:12] <cmr> I thought you meant that they would move from the incubator to extra, not from extra to the incubator
[02:27:14] <strcat> acrichto: I don't think that Ord PR is correct for floats
[02:27:40] <strcat> !(a < b) && !(b < a) does not imply a == b
[02:28:51] <brson_> acrichto: is this the last llvm change you expect for a while?
[02:29:19] <engla> oops, the float Ord should stay of course
[02:29:36] <acrichto> brson_: not quite, I'm trying to investigate why llvm fails on 32-bit rusti and I've found one issue but now I'm getting all these relocation errors which may invole a modification or might not, I'm not sure yet
[02:29:53] <acrichto> brson_: also I'd want to drop the commit which ignores an llvm assertion asap
[02:30:15] <brson_> acrichto: ok, can you continue working on that and batch up those changes. llvm rebuilds are disruptive
[02:30:33] *** Quits: diegoyam (quassel@FF9B1514.A4EC3D18.3A1EC144.IP) (Ping timeout)
[02:30:34] <engla> strcat: that means that all the methods have to stay on Ord for ~T as well, to keep ~float correct?
[02:30:36] <acrichto> brson_: yeah sure
[02:31:01] <strcat> engla: yes
[02:31:05] <bjz> strcat: which one?
[02:31:05] <acrichto> strcat: is there something which is derived for Ord?
[02:31:20] * brson_ dinner
[02:31:27] <strcat> acrichto: hm?
[02:31:49] <acrichto> strcat: oh nvmd, nan > nan should be false but this is returning true (I would hope the test suite would catch this)
[02:32:02] <strcat> acrichto: I don't think it will catch all of these
[02:32:08] <strcat> certainly not the ~T case
[02:32:19] <cmr> This is why I really didn't want default methods for Ord
[02:32:22] <acrichto> strcat: yeah, those tests should be added
[02:32:26] <cmr> If you're not careful, you will get the wrong behavior
[02:32:31] *** Joins: jdm (jdm@92FB48CA.8B5E9DF.9A8C35B4.IP)
[02:32:36] *** Quits: jdm (jdm@92FB48CA.8B5E9DF.9A8C35B4.IP) (Quit: jdm)
[02:32:52] *** Joins: jdm (jdm@92FB48CA.8B5E9DF.9A8C35B4.IP)
[02:32:56] <cmr> These should really be using TotalOrd
[02:32:59] <engla> well the Ord docs explicitly say we want special semantics for float
[02:33:06] <engla> this is just an oversight
[02:33:19] <strcat> float isn't an exception to the rule, it's a common case
[02:33:22] <strcat> SQL nulls
[02:33:32] <strcat> lots of types have weaker than total orders
[02:33:38] <cmr> engla: the point of not having the defaults is so that oversights cannot happen, and that they do not cause breakage
[02:33:48] <strcat> the defaults are fine
[02:33:51] <strcat> replacing these impls isn't
[02:35:20] <engla> cmr: not sure if having/not having default methods help. Implementations like Ord for &'self [T], all call back into one implemented method anyway
[02:35:25] <strcat> although defaults that aren't always right are obviously questionable
[02:35:39] <engla> which means, does &[float] compare correctly? (I don't know)
[02:35:55] <strcat> engla: it's incorrect then
[02:35:57] <strcat> should be fixed
[02:36:37] <bjz> doesn't it call back to the Ord impls on float?
[02:37:07] <strcat> bjz: it implements it all with 1 method ;\
[02:37:09] <strcat> some of them do
[02:37:12] <strcat> Option looks like it does
[02:37:18] <bjz> what?!
[02:37:24] <bjz> float does?
[02:37:26] <engla> I have no idea if  &[nan] >= &[nan]  should be true or false
[02:37:31] <engla> bjz: no
[02:37:41] <strcat> bjz: containers have incorrect Ord impls
[02:37:48] <strcat> most of them
[02:38:02] <miloshadzic> rusti: std::ascii::eq_ignore_ascii_case(~"a", ~"A")
[02:38:18] <strcat> bstrie: around?
[02:38:27] <engla> I don't think these semantics scale well if containers are required to have 4 separate methods implemented for Ord
[02:38:32] *** Quits: jdm (jdm@92FB48CA.8B5E9DF.9A8C35B4.IP) (Quit: Lost terminal)
[02:38:48] <strcat> engla: they are the desired semantics
[02:39:00] <strcat> TotalOrd is for total ordering, Ord allows weaker ordering
[02:39:05] <strcat> if you don't want to implement Ord - then don't
[02:39:18] <cmr> Ord should be derived for TotalOrd anyway
[02:39:27] <strcat> well that would be incorrect for containers
[02:39:34] <strcat> unless they also did Ord
[02:39:45] *** Quits: zz_kimundi (kimundi@moz-8A1835DB.dip0.t-ipconnect.de) (Ping timeout)
[02:39:56] <engla> I don't know why containers implement Ord in the first place
[02:40:06] <cmr> hm? I'm just saying you should be able to derive an Ord implementation if you already implement TotalOrd
[02:40:12] <strcat> cmr: ah
[02:41:57] <engla> so, the default methods refactored a recurring pattern.. just implementing lt. even &[] does that. But that pattern is sometimes wrong. Almost everywhere there is a <T> it could be wrong
[02:42:09] <cmr> Correct
[02:42:14] <cmr> Which is why I initially opposed it
[02:42:49] *** Joins: zz_kimundi (kimundi@moz-4F52263A.dip0.t-ipconnect.de)
[02:42:51] *** Joins: Sodel_the_V (user@moz-853663E1.va.shawcable.net)
[02:43:07] *** zz_kimundi is now known as kimundi
[02:43:16] <strcat> https://github.com/mozilla/rust/issues/8360
[02:44:52] <acrichto> cmr: does have a point though in that if we want Ord to be correct for *all* containers then the default methods probably aren't a good idea
[02:45:41] <cmr> If we want it to be correct in general. I know that I'm going to take the past of least resistance when implementing something. If there are default methods and the compiler doesn't complain, I'm never going to implement them until I notice the bugt
[02:47:00] <cmr> I'm pretty sure everything that wants the default methods want to implement TotalOrd anyway
[02:47:26] <cmr> And there can be an impl<T: TotalOrd> Ord for T
[02:47:29] *** Quits: tcr (tcr@moz-EE576D3C.hsd1.ma.comcast.net) (Client exited)
[02:47:33] <strcat> cmr: no
[02:47:36] <cmr> strcat: Why?
[02:47:52] <strcat> because floats have a defined total ordering and a defined weak ordering
[02:47:54] *** Joins: tcr (tcr@moz-EE576D3C.hsd1.ma.comcast.net)
[02:48:20] <cmr> What is the total orderng?
[02:48:44] <strcat> https://en.wikipedia.org/wiki/IEEE_floating_point#Total-ordering_predicate
[02:49:10] <cmr> Our TotalOrd can't express that something is unordered
[02:49:14] <cmr> Does that need to be fixed?
[02:49:30] <strcat> it can
[02:49:36] <strcat> I don't know what you mean
[02:49:41] <strcat> floats have a total ordering defined
[02:50:06] <strcat> it can return Less, Equal or Greater
[02:50:06] <strcat> 'The normal comparison operations however treat NaNs as unordered and compare âˆ’0 and +0 as equal. The totalOrder predicate will order these cases, and it also distinguishes between different representations of NaNs and between the same decimal floating point number encoded in different ways.'
[02:50:07] <cmr> We have Lesser, Equal, and Greater. The wikipedia article says it treats NaN as unordered
[02:50:10] <strcat> no
[02:50:14] <strcat> the regular comparisons do
[02:50:18] <strcat> not the total ordering
[02:50:22] <cmr> ahhh I see
[02:50:24] *** Quits: tcr (tcr@moz-EE576D3C.hsd1.ma.comcast.net) (Ping timeout)
[02:50:24] <cmr> yeah
[02:50:26] <cmr> Ok
[02:50:36] <cmr> So if coherence checking could pick the most specific impl that'd be cool
[02:50:40] <cmr> until then that generic impl is out
[02:50:48] <strcat> Ord/Eq need true|false|unordered if you really want to be correct
[02:50:52] <strcat> but it'd be too painful ;p
[02:51:27] <cmr> well for the unordered case they all just return false, so I wouldn't think you need to express unordered
[02:52:35] <strcat> yeah I guess that's true
[02:52:53] <strcat> as long as people are aware the usual assumptions don't apply
[02:53:05] <cmr> I think that's going to be hard to make people aware of
[02:53:17] <cmr> The comparisons that apply to reals are the ones everyone assumes, IME
[02:55:52] <ChrisMorgan> It's interesting, comparing compiling LLVM with compiling Rust. Memory usage compiling LLVM keeps on jumping up and down and the disk is kept fairly busy, while with compiling Rust memory shoots up at the start and stays there, and there isn't so much I/O after a short time.
[02:56:05] <cmr> ChrisMorgan: You know why that is right?
[02:56:33] <cmr> LLVM runs a new compiler instance for every source file, rust reads them all up front and then does everything
[02:56:48] <ChrisMorgan> That's what I thought.
[02:57:42] <strcat> doing it at all once is actually faster if you are only going to compile once start to finish (and generates better code) - but ridiculously bad when you edit one file and need to rebuild
[02:58:15] <acrichto> nothing like having something which has to wait for a stage2 build
[02:58:35] <cmr> incremental compilation can't save us from bootstrapping
[02:58:53] <cmr> unless there are some serious smarts about when the cache needs to be invalidated
[02:58:53] <acrichto> it could get you to stage1 a lot faster though
[02:58:56] <cmr> yeah
[02:59:10] <strcat> cmr: it's an issue for projects that aren't rustc
[02:59:17] <cmr> yes
[03:01:16] <cmr> I think Rust will end up a *lot* more flexible when it comes to incremental compilation than C or C++, since we don't need to do it at the file level, we can look into every item to see what changes
[03:05:25] *** Joins: maikklein2 (maik@moz-BFE8F4AD.dip0.t-ipconnect.de)
[03:06:09] <jack> cmr: how's that? do we hash the token trees?
[03:06:28] <cmr> jack: could be
[03:06:33] <cmr> dunno how exactly it'd work out
[03:06:38] <cmr> it'd be tricky in the face of generics too
[03:06:45] <Eridius> strcat: hrm, we have range(), but no range_step(). Seems like we could use that too
[03:07:09] <strcat> Eridius: it can't be written without first writing generic checked overflow operations also implemented on big integers
[03:07:45] <Eridius> strcat: why?
[03:07:45] <cmr> strcat: that'd be add_checked(left, right) -> Option<T> right? None in the case of overflow?
[03:07:46] <strcat> the old range_step was just generated from macros, it wasn't generic
[03:07:49] <strcat> cmr: yes
[03:08:11] <strcat> if it's in a single namespace (prelude, or iterator) it *has* to be generic
[03:08:28] *** Joins: jeaye (Jeaye@moz-FD505E54.hsd1.ca.comcast.net)
[03:08:30] <strcat> the old ones were macros generating a version for each int module
[03:08:48] <cmr> It'd be cool if Rust could exploit intel's MPX sometime
[03:09:11] *** Joins: Haxkerl (Mibbit@F7BDAFB8.6B56EC2F.AC9CCDD1.IP)
[03:09:35] <Haxkerl> Are there any girls here? Hello!
[03:10:41] *** Quits: Haxkerl (Mibbit@F7BDAFB8.6B56EC2F.AC9CCDD1.IP) (Quit: http://www.mibbit.com ajax IRC Client)
[03:10:50] *** Joins: Haxkerl (Mibbit@F7BDAFB8.6B56EC2F.AC9CCDD1.IP)
[03:11:09] <Haxkerl> Hello, are there any girls here?
[03:11:17] <strcat> no, only asexual bots in here
[03:11:32] <Haxkerl> What are the bota
[03:11:35] <cmr> *agender
[03:11:39] <cmr> get it right ;p
[03:11:40] <Haxkerl> What are the bots?
[03:12:02] <strcat> cmr: well asexual implies no gender, doesn't it?
[03:12:13] <cmr> strcat: not in the context of human sexuality
[03:12:14] <Eridius> Haxkerl: noone here but us NPCs
[03:12:16] <strcat> biologically, not socially
[03:12:21] <cmr> biologically yes
[03:12:28] <Haxkerl> rusti: println("Hello, world!");
[03:12:45] <strcat> cmr: no humans in here, no need to worry about vile creatures not reproducing by budding
[03:12:52] <cmr> Good point!
[03:13:02] <sp3d> self-hosting is more trouble but it is worth it
[03:13:37] *** Joins: rusti (rusti@moz-54F7FD49.cpe.net.cable.rogers.com)
[03:13:48] <Haxkerl> Can I enter Rust code for interpretation here?
[03:13:53] <cmr> rusti: 5
[03:13:54] -rusti- 5
[03:13:57] <cmr> Haxkerl: can now
[03:15:15] <Haxkerl> rusti: loop {println("Help me, I'm trapped in an infinite loop. Heeelp! HEEEEELLLLPP!");}
[03:15:16] -rusti- pastebinned 9 lines of output: http://sprunge.us/QgZX
[03:16:40] <Haxkerl> Who controls the code interpreter bot?
[03:16:54] <ChrisMorgan> strcat
[03:17:15] <strcat> well, I like to think I control it
[03:17:39] <strcat> I'm not so sure rusti agrees
[03:17:50] <Haxkerl> rusti: Fuck you!
[03:17:50] -rusti- <anon>:5:14: 5:17 error: expected `;` or `}` after expression but found `you`
[03:17:50] -rusti- <anon>:5          Fuck you!
[03:17:50] -rusti-                        ^~~
[03:17:50] -rusti- application terminated with error code 101
[03:18:25] <Haxkerl> Is "fuck" a valid statement/keyword/function?
[03:18:34] <cmr> Identifier, yes.
[03:19:00] <ChrisMorgan> Haxkerl: you know, I at least would appreciate it if you didn't do things like that.
[03:19:13] *** Quits: brson_ (brson@moz-BBE3ABD.mv.mozilla.com) (Quit: leaving)
[03:19:16] *** Joins: brson (brson@moz-BBE3ABD.mv.mozilla.com)
[03:19:16] *** ChanServ sets mode: +o brson
[03:20:01] <cmr> Haxkerl: https://github.com/mozilla/rust/wiki/Note-development-policy#conduct
[03:20:47] <Haxkerl> I have read somewhere that you can use dictionary words with irrelevant connotations as identifiers to obfuscate code.
[03:21:12] <strcat> meh I'm just going to put the Times trait thing in another PR
[03:21:15] <strcat> as an RFC
[03:21:23] * strcat wants to land the vector iterator perf improvements
[03:21:26] <bjz> Haxkerl: As with all languages, formal or natural
[03:22:13] <acrichto> strcat: the ffi dox failed b/c it couldn't link with -lreadline on linux :(
[03:22:21] <strcat> acrichto: ah just xfail them then
[03:22:24] <strcat> I didn't think of that
[03:22:29] <cmr> strcat: did you see https://botbot.me/mozilla/rust/msg/5026255/ btw? :P
[03:22:34] <acrichto> gonna let newrt attempt to land first though
[03:23:13] *** Joins: ghrust (ghrust@FD7BC443.6A2AE50.F3114085.IP)
[03:23:13] <ghrust> 01[13rust01] 15bors 04force-pushed 06auto from 14d1d33a1 to 145b4244d: 02http://git.io/N3iJvQ
[03:23:13] *** Parts: ghrust (ghrust@FD7BC443.6A2AE50.F3114085.IP) ()
[03:23:14] *** Joins: ghrust (ghrust@1E8607E8.6A2AE50.F3114085.IP)
[03:23:14] <ghrust> 01[13rust01] 15bors pushed 12 new commits to 06auto: 02http://git.io/beRpRQ
[03:23:14] <ghrust> 13rust/06auto 1452787e9 15Brian Anderson: std::rt: 2MB stacks again
[03:23:14] <ghrust> 13rust/06auto 14260b444 15Brian Anderson: std::rt: Pull RUST_MIN_STACK from the environment
[03:23:14] <ghrust> 13rust/06auto 141bf5b19 15Brian Anderson: std: Allow spawners to specify stack size
[03:23:16] *** Parts: ghrust (ghrust@1E8607E8.6A2AE50.F3114085.IP) ()
[03:24:17] <acrichto> go newrt, go!
[03:24:42] *** Quits: wting (wting@moz-250C027.csres.utexas.edu) (Client exited)
[03:24:42] <strcat> bjz: I thought we all agreed it was bad ;p
[03:24:58] <bjz> strcat: ?
[03:25:01] <strcat> times
[03:25:05] <strcat> er, cmr
[03:25:08] <ChrisMorgan> Oh? Option.get was removed instead of Option.unwrap?
[03:25:19] <cmr> ChrisMorgan: yes
[03:25:24] <cmr> unwrap is the less misleading name
[03:25:26] <brson> ChrisMorgan: still under debate
[03:25:40] <cmr> Well, it was removed, that is an objective fact
[03:25:48] <ChrisMorgan> But you still have get_ref and get_mut_ref.
[03:25:50] *** Quits: Haxkerl (Mibbit@F7BDAFB8.6B56EC2F.AC9CCDD1.IP) (Quit: http://www.mibbit.com ajax IRC Client)
[03:26:15] <cmr> ChrisMorgan: Those are different, they give you a reference to inside the Option, rather than getting a value from the Option
[03:26:40] <acrichto> strcat: was the discussion about the iterator cleanup other than times?
[03:26:52] <strcat> no it was just about times
[03:27:00] <acrichto> if you include codegen/bench tests I'd r+
[03:27:04] <ChrisMorgan> True. `unwrap` probably makes it more obvious you're dealing with an Option than `get`, too.
[03:27:32] <cmr> ChrisMorgan: thing about get is that it clones the value, which is often not what you want (I've had bugs from it because I didn't know the difference ;( )
[03:27:50] * strcat is disappointed it isn't capable of doing loop-deletion/loop-idiom/loop-vectorize on it like it does for C++
[03:27:58] <strcat> perhaps it has to do with the order
[03:28:02] *** Quits: Kroisse (Kroisse@7CF4064D.E3B51CAE.ECA1BB11.IP) (Ping timeout)
[03:28:10] *** Quits: Azdle (patrick@moz-8C723B60.hsd1.mn.comcast.net) (Ping timeout)
[03:28:23] <ChrisMorgan> Oh, hadn't noticed that unwrap was using self rather than &self. That's good.
[03:28:36] <cmr> ChrisMorgan: Exactly, you didn't notice :p
[03:28:38] <acrichto> strcat: I could try locally with llvm-head once it's merged
[03:28:42] <bjz> cmr: I would now change the name of unwrap to get
[03:28:50] <cmr> bjz: I would disagree with that change
[03:28:59] <strcat> acrichto: I think it's just that their pointer induction pass is designed for C++ iterators
[03:29:08] <strcat> and doesn't handle a very slightly different order of the operations
[03:29:08] <cmr> unwrap implies to me that the thing is destroyed, that a layer of abstraction is eliminated
[03:29:18] <acrichto> strcat: do you know what the difference is?
[03:29:24] <bjz> cmr: ah, I see
[03:29:26] <strcat> acrichto: yes but it's not fixable
[03:29:27] <cmr> bjz: I'd like get_ref to be renamed to get though :p
[03:29:34] <acrichto> strcat: :(
[03:29:38] <bjz> cmr: I guess that makes sense
[03:29:41] <strcat> acrichto: the rust iterator can't be allowed to index off into the void on next() calls after it finishes
[03:29:51] <strcat> it'd be undef behaviour
[03:29:51] <bjz> cmr: to 'ref'?
[03:30:07] <cmr> bjz: no, get_ref -> get, get_ref_mut -> get_mut
[03:30:16] <strcat> acrichto: rust iterator checks end cond, bumps ptr, returns last ptr
[03:30:20] <bjz> ah, yeah
[03:30:26] <strcat> C++ iterator bumps the ptr, returns last ptr
[03:30:38] <acrichto> strcat: oh, that's unfortunate
[03:30:40] <bjz> cmr: yeah, there shouldn't be any copying
[03:30:55] <strcat> acrichto: well it should still optimize to the same code
[03:31:05] <cmr> (should)
[03:31:12] <ChrisMorgan> I think it's important to make it clear that these are comparatively dangerousâ€”proof that it won't be None is left to you, on pain of failure.
[03:31:12] <strcat> acrichto: in C++, you manually write the end cond check
[03:31:25] <strcat> acrichto: in rust, the end cond will result in a null ptr being returned, which is checked
[03:31:29] *** Joins: Kroisse (Kroisse@7CF4064D.E3B51CAE.ECA1BB11.IP)
[03:31:31] <strcat> it is capable of merging the checks now
[03:31:42] <cmr> ChrisMorgan: they are explicitly documented and recommended against
[03:31:43] <acrichto> that's curious...
[03:31:44] <strcat> but it doesn't see that it's the same pattern. despite it being the *same* code in a different order
[03:31:55] <strcat> (and no memory deps between the two parts)
[03:31:56] <cmr> but there are lots of cases where there's just nothing you can do if you have None, it violates an implicit invariant
[03:32:00] <ChrisMorgan> cmr: I know, but still...
[03:32:04] *** Quits: MrFahrenheit (RageOfThou@3FEF494C.29C984D5.783DEDCA.IP) (Ping timeout)
[03:32:09] <ChrisMorgan> unwrap instead of get is good.
[03:32:11] <acrichto> strcat: I would imagine that LLVM has optimizations tailored for LLVM, but they shouldn't be *that* specific
[03:32:16] <strcat> acrichto: yeah I'll investigate more later, got frustrated with it
[03:32:21] <acrichto> *tailored for C++
[03:32:25] <strcat> at the very least it optimizes to good scalar code now
[03:32:28] <strcat> ideal scalar code
[03:32:35] <acrichto> excellent!
[03:32:37] <strcat> as good as C++ without loop-{idiom,deletion,vectorize}
[03:33:13] <acrichto> does the rust IR actually contain the vectorized instructions or is only during object emission that the actual vectorization happens?
[03:33:21] <acrichto> llvm IR*
[03:33:32] <strcat> acrichto: it's not vectorizing the rust code
[03:33:36] <strcat> it vectorizes the C++ code
[03:33:39] <strcat> and yes, the IR contains it
[03:33:42] <strcat> IR is platform specific
[03:34:22] <acrichto> I thought the whole thing of llvm ir was to not be...
[03:34:25] <strcat> nope
[03:34:27] <acrichto> at least mostly
[03:34:30] <strcat> it's not ;p
[03:34:37] <acrichto> what are the platform-specific things?
[03:34:54] <strcat> acrichto: http://llvm.org/docs/FAQ.html#can-i-compile-c-or-c-code-to-platform-independent-llvm-bitcode
[03:35:14] <strcat> acrichto: many things - type sizes, padding, vector instructions, syscalls, platform functions
[03:35:21] <strcat> calling conventions
[03:35:50] <strcat> LLVM IR is *less* portable than C without a preprocessor
[03:36:51] <acrichto> yeah I guess I just consider that differently, for me I think of it more as IR is just normally tailored for an architecture and is probably invalid in most others
[03:37:05] <acrichto> but when I think about it it only really makes sense to call it platform-dependent
[03:37:14] <strcat> acrichto: http://www.chromium.org/nativeclient/pnacl/bitcode-abi
[03:37:21] <acrichto> hehe, nacl
[03:37:21] <strcat> nacl heavily restricts/alters it
[03:37:24] <cmr> Yeah I was just looking at that now
[03:37:29] <cmr> to see what they do to modify it
[03:38:50] <cmr> Besides the intrinsics it appears to be a subset
[03:39:31] * cmr wonders if a pnacl backend could be added to llvm
[03:40:48] <jack> or an emscripten one. then we could run servo in servo.
[03:40:54] <cmr> hah
[03:41:19] <jack> we have the technology. the time is now.
[03:41:35] <ChrisMorgan> brson: this report that you were speaking of mentioning my HTTP server in, is that for Servo or Rust?
[03:41:54] <cmr> ChrisMorgan: Oh someone came in here earlier, it's broken on lastest master
[03:41:57] *** Quits: jgilbert (jgilbert@moz-7B0110AD.mv.mozilla.com) (Ping timeout)
[03:41:58] <cmr> something about IPs
[03:42:07] <cmr> (besides the normal foreach/get->unwrap changes)
[03:42:15] <ChrisMorgan> I know. And get, and foreach.
[03:42:22] <cmr> ok :D
[03:42:43] <strcat> acrichto: there's actually a benchmark already
[03:42:58] <ChrisMorgan> My rust build was on my augmented-assignment branch, which I've only just rebased and am now recompiling. Then I'll update the server for all these changes.
[03:43:34] <strcat> it doesn't make a long enough array
[03:44:23] * ChrisMorgan didn't expect 4GB of RAM to *ever* be insufficient in the life of his laptop when he put the extra 2GB in...
[03:44:30] <acrichto> strcat: was there actually a speedup?
[03:44:36] <strcat> acrichto: yes
[03:44:48] <acrichto> also it looks like the mut_iterator benchmark doesn't have the same "obfuscation" as the iterator one?
[03:45:01] <strcat> there's a sample of the IR in the commit msg
[03:45:44] <brson> ChrisMorgan: Rust
[03:45:50] <acrichto> I wonder why there's that obfuscated stuff then in one and not the other...
[03:45:59] <strcat> acrichto: it's capable of constant-folding both in C++
[03:46:16] <acrichto> and it doesn't in rust?
[03:46:27] <strcat> it doesn't.
[03:46:41] <strcat> loop-{deletion,idiom,vectorize} isn't working with iterator *or* indexes
[03:46:45] <strcat> it works with both in C++
[03:47:06] <strcat> anyway will look into it more later
[03:47:09] <strcat> it's a major perf issue
[03:47:17] <strcat> as is slow pointer arithmetic by default.
[03:47:32] <strcat> I'll have to go over the other uses of offset and fix them, and likely remove non-inbounds offset
[03:47:42] <strcat> kind of pointless to index somewhere you aren't allowed to deref.
[03:47:49] <acrichto> well r+ for now, although I do agree that `for iterator {}` is needed
[03:48:05] *** Joins: eatkinson (eatkinson@moz-5CF47426.dia.static.qwest.net)
[03:48:19] <strcat> existing benchmark
[03:48:21] <strcat> before:
[03:48:25] <strcat> test vec::bench::iterator ... bench: 78 ns/iter (+/- 1)
[03:48:27] <strcat> test vec::bench::mut_iterator ... bench: 77 ns/iter (+/- 1)
[03:48:30] <strcat> after:
[03:48:32] <strcat> test vec::bench::iterator ... bench: 60 ns/iter (+/- 1)
[03:48:34] <strcat> test vec::bench::mut_iterator ... bench: 53 ns/iter (+/- 0)
[03:48:36] <strcat> but it's too short
[03:48:50] <acrichto> still not bad for iteration over every vector ever
[03:48:53] <strcat> it's a bigger difference on long ones, and step towards actually having the loop family of optimizations work ;p
[03:49:04] <acrichto> that's the biggest win imo
[03:49:10] *** Quits: Sodel_the_V (user@moz-853663E1.va.shawcable.net) (Quit: Eaten by a grue)
[03:49:15] * strcat doesn't really understand why it doesn't already work :(
[03:49:26] <strcat> can investigate more later
[03:49:31] *** Quits: brson (brson@moz-BBE3ABD.mv.mozilla.com) (Ping timeout)
[03:50:36] *** Joins: brson (brson@moz-BBE3ABD.mv.mozilla.com)
[03:50:36] *** ChanServ sets mode: +o brson
[03:51:20] <acrichto> strcat: what I find odd is that the loop is 2 basic blocks instead of 1
[03:51:47] <strcat> acrichto: notice how it outputs two main functions too
[03:51:51] <strcat> not sure why we do that
[03:51:56] <strcat> and in one of them, it's a single block
[03:51:58] <strcat> :s
[03:52:10] <acrichto> oh I'm just looking at your commit message
[03:52:14] <acrichto> not sure what you're looking at
[03:52:37] <acrichto> there's a generated main wrapper which calls the actual main function though
[03:52:49] <acrichto> or maybe it calls the #[start] function...
[03:52:52] <acrichto> one of the two
[03:53:03] <strcat> acrichto: no we have 3 of those
[03:53:05] <strcat> like
[03:53:07] <strcat> here
[03:53:17] <strcat> define void @"_ZN4main17_15bec6257b8bff787_0$x2e0E"({ i64, %tydesc*, i8*, i8*, i8 }* nocapture) #2 {
[03:53:19] <strcat> there's main
[03:53:32] <strcat> define void @_rust_main({ i64, %tydesc*, i8*, i8*, i8 }* nocapture) {
[03:53:34] <strcat> rust_main
[03:53:37] <strcat> define i64 @main(i64, i8**) {
[03:53:39] <strcat> actual main
[03:53:56] <strcat> we actually output the body *twice*, once in the mangled one and once in rust_main
[03:54:04] <strcat> and LLVM sometimes optimizes it to one calling the other
[03:54:06] <acrichto> whoa now that's weird
[03:54:38] <strcat> acrichto: sec let me replace the commit msg example with a clearer one
[03:54:47] <acrichto> strcat: you sure it generates twice? with no optimization I'm seeing main => _rust_main => ZNmain
[03:54:52] <strcat> hrm
[03:54:54] <strcat> maybe not then
[03:55:04] <strcat> acrichto: it might be LLVM inlining it sometimes
[03:55:07] <olsonjeffery> brson: ping
[03:55:11] <strcat> it won't remove the mangled one because it's not internal
[03:55:13] <acrichto> strcat: but this is with no optimizations?
[03:55:17] <acrichto> oh
[03:55:24] <strcat> acrichto: I mean maybe LLVM is inlining the mangled one into rust_main
[03:55:34] <acrichto> not sure why _rust_main exists though
[03:55:44] <acrichto> it's used as a definite entry point for the jit, so maybe that's why
[03:55:52] <acrichto> b/c you look up symbols by name
[03:56:11] <acrichto> @main calls #[lang="start"] though so that makes sense
[03:56:15] *** Quits: brson (brson@moz-BBE3ABD.mv.mozilla.com) (Ping timeout)
[03:57:27] <strcat> acrichto: https://github.com/mozilla/rust/pull/8326 more readable examples
[03:58:48] <acrichto> strcat: interesting... now it's back to one basic block
[03:59:01] <strcat> acrichto: yeah it splits it to put that weird lifetime stuff
[03:59:44] <acrichto> how is llvm.lifetime.{start,end} provding more information than liveness anlysis?
[04:00:11] <strcat> well it puts them because it analyzes lifetimes itself
[04:00:22] <strcat> they are a good thing
[04:00:25] <strcat> they just make it unreadable
[04:00:29] <acrichto> yeah but liveness analysis should be abel to see when something goes out of scope
[04:00:42] <strcat> yes and we could output them ourselves
[04:00:53] * strcat has an issue open about it
[04:00:55] *** Joins: brson (brson@moz-BBE3ABD.mv.mozilla.com)
[04:00:55] *** ChanServ sets mode: +o brson
[04:01:00] <acrichto> oh I thought we did
[04:01:10] <strcat> acrichto: LLVM infers them in rare cases
[04:01:19] *** Quits: RMF (RMF@moz-2758EDDD.dsl.telepac.pt) (Quit: Textual IRC Client: www.textualapp.com)
[04:01:20] <acrichto> huh
[04:01:21] *** Quits: boredomist (user@moz-63CF9F31.res-cmts.sesp.ptd.net) (Ping timeout)
[04:01:22] <strcat> but usually, it just shoves them on pointers to temporary stack variables
[04:01:31] <strcat> after it's done with the temporary
[04:01:44] <acrichto> if LLVM does it I guess it makes it useful for later passes
[04:01:46] <strcat> it can't see our 'free' calls
[04:01:51] <strcat> acrichto: yeah
[04:02:07] <strcat> acrichto: anyway there's a bit more weirdness I need to diagnose
[04:02:07] <acrichto> can we tell LLVM "this is a free" and "this is a malloc" ?
[04:02:17] <strcat> acrichto: no, it has to see them itself
[04:02:20] <strcat> it hardcodes symbols
[04:02:23] <acrichto> ah
[04:02:31] <strcat> we could submit a patch making it configurable
[04:02:38] <strcat> or just figure out a clever way of not needing wrappers
[04:02:48] <strcat>   %8 = icmp eq i64 %6, 0
[04:02:50] <strcat>   %9 = icmp eq double* %3, null
[04:02:52] <strcat>   %or.cond6 = or i1 %8, %9
[04:02:54] <strcat> acrichto: see that part?
[04:02:56] <strcat> in the prelude to the loop
[04:02:58] <strcat> it's very weird
[04:03:03] <acrichto> yeah 
[04:03:10] <acrichto> I was thinking the same thing
[04:03:19] <strcat> it's not from mut_iter()
[04:03:19] <acrichto> trying to figure out why there's a shift as well
[04:04:05] <strcat> acrichto: it generates a similar shift when it vectorizes the C++
[04:04:11] <strcat> but the null check is worrying
[04:04:23] <strcat> I think it indicates why it won't vectorize - it's not trusting us somewhere
[04:04:30] * strcat really doesn't get it
[04:05:00] <strcat> acrichto: maybe I could add .offset(0)
[04:05:05] <strcat> to assert "this is in bounds"
[04:05:06] <acrichto> wait whoa
[04:05:12] <acrichto> that lshr
[04:05:13] *** Joins: ghrust (ghrust@2EE61FCC.6A2AE50.F3114085.IP)
[04:05:13] <ghrust> 01[13rust01] 15bors 04force-pushed 06auto from 1431e93c6 to 145b4244d: 02http://git.io/N3iJvQ
[04:05:13] *** Parts: ghrust (ghrust@2EE61FCC.6A2AE50.F3114085.IP) ()
[04:05:14] *** Joins: ghrust (ghrust@F6EE6DE3.6A2AE50.F3114085.IP)
[04:05:14] <ghrust> 01[13rust01] 15bors pushed 7 new commits to 06auto: 02http://git.io/F3jafQ
[04:05:14] <ghrust> 13rust/06auto 142266df5 15Steven Fackler: Added hexadecimal encoding module...
[04:05:14] <ghrust> 13rust/06auto 14463e241 15Steven Fackler: Some minor hex changes
[04:05:14] <ghrust> 13rust/06auto 14ff5fdff 15Steven Fackler: ToBase64 and ToHex perf improvements...
[04:05:15] *** Parts: ghrust (ghrust@F6EE6DE3.6A2AE50.F3114085.IP) ()
[04:05:20] <acrichto> is multiplying the byte length by 8
[04:05:32] <acrichto> and then loading a double out of that
[04:05:45] <strcat> acrichto: a ptr
[04:05:51] <strcat> hm?
[04:05:53] <acrichto> oh wait yes
[04:05:53] <strcat> where
[04:05:57] <acrichto> but why it it multiplied by 8?
[04:06:09] <strcat>   %7 = getelementptr inbounds double* %3, i64 %6
[04:06:12] <strcat> %6 is the offset
[04:06:17] <strcat>   %6 = lshr i64 %5, 3
[04:06:19] <acrichto> oh wait
[04:06:23] <strcat> f64 is 8 bytes
[04:06:24] <acrichto> lshr == shift right
[04:06:25] <acrichto> not shift left
[04:06:26] <strcat> len is in elems
[04:06:36] <strcat> acrichto: yes
[04:06:44] <strcat> acrichto: getelementptr wants # of elems to offset by
[04:06:55] <strcat> so it has to convert
[04:07:02] <acrichto> yeah and it does pointer arithmetic on its own
[04:07:18] <strcat> acrichto: anyway going to try .offset(0)
[04:07:22] <strcat> if that works... it will be sad
[04:07:29] <acrichto> all rusti arch tests just passed!
[04:07:30] <strcat> it means we pretty much need to add it as a prelude to every fn
[04:07:38] <strcat> to assert to llvm that our pointers are non-nullable
[04:07:48] <strcat> I really don't see why it checks for null
[04:07:50] <strcat> :|
[04:08:11] <Eridius> strcat: I'm surprised there's no range_rev() equivalent for range()
[04:08:12] <acrichto> yeah it's bailing if both the base or the length is null
[04:08:32] <strcat> and the ptr is never null
[04:08:45] <strcat> although it should still vectorize
[04:08:47] <strcat> either way
[04:08:54] <strcat> it's a nice tight vectorizable loop.
[04:09:11] <strcat> acrichto: for comparison, let me get C++
[04:09:13] <strcat> sec
[04:09:25] <strcat> __attribute__((noinline)) void foo(double *xs, size_t size) {
[04:09:27] <strcat>     double *end = xs + size;
[04:09:29] <strcat>     for (double *x = xs; x != end; x++) {
[04:09:31] <strcat>         *x += 10.0;
[04:09:33] <strcat>     }
[04:09:35] <strcat> }
[04:09:55] <strcat> acrichto: http://ix.io/76j -O2, look how similar it is to ours
[04:10:11] <strcat> acrichto: http://ix.io/76r -O3, turns to vector ops
[04:10:18] <acrichto> what's weird is the "next" pointer is calculated before the load/store
[04:10:27] <acrichto> whoat that got big
[04:10:36] *** Quits: eatkinson (eatkinson@moz-5CF47426.dia.static.qwest.net) (Quit: eatkinson)
[04:10:36] <acrichto> although lots of 2x appeared
[04:10:45] <acrichto> which I assume is good :P
[04:10:49] <strcat> acrichto: http://ix.io/76t and -march=native, it can use AVX instead of just SSE2
[04:10:55] <doomlord_> is there a one:many map ... ???.insert(key,value)   .. ???.find(key) -> iterator over many values ... whats the best way of doing this
[04:11:07] <acrichto> fancy
[04:11:16] *** Quits: adu (ajr@moz-F1F8E03E.washdc.fios.verizon.net) (Quit: adu)
[04:11:20] <strcat> acrichto: it also vectorizes the array initialization in C++
[04:11:42] <acrichto> strcat: but actually generating the next pointer ahead of time may be messing with things
[04:11:49] <strcat> acrichto: in rust? nope. neither is vectorized
[04:11:56] <strcat> acrichto: well our array init isn't vectorized either
[04:11:59] <acrichto> strcat: yeah, in rust
[04:12:16] <acrichto> strcat: no in your commit message, %10 is calculated at the top of the loop body
[04:12:19] <strcat> oh
[04:12:21] *** Quits: recrack (Mibbit@B4104EBB.3CC170B1.1E14B209.IP) (Quit: http://www.mibbit.com ajax IRC Client)
[04:12:25] <acrichto> but in the C++ code %5 is afterwards
[04:12:42] <strcat> acrichto: well, the rust iterator is "different" ;p
[04:12:48] <acrichto> yeah
[04:12:49] <strcat> but it's essentially the same
[04:12:53] <acrichto> I don't think we could fix that
[04:12:57] <strcat> yeah
[04:13:01] <acrichto> it may be messing with LLVM though?
[04:13:03] <strcat> yeah
[04:13:05] <strcat> I think so.
[04:13:17] <strcat> maybe worth reporting an LLVM issue
[04:13:33] <acrichto> I'd try generating equivalent rust code first
[04:13:38] <acrichto> to what C++ is actually doing
[04:13:44] <acrichto> and make sure that gets vectorized to the extent of C++
[04:13:47] <strcat> with raw ptrs you mean?
[04:13:50] <acrichto> yeah
[04:14:12] <acrichto> then try taking the C++ IR and moving the getelementptr above and see if it can't get optimized at that point
[04:14:43] <ChrisMorgan> OK, HTTP server is running on rust master again.
[04:15:07] <acrichto> brson: just noticed that rusti tests failed for newrt, feel free to disable them and I'll investigate afterwards
[04:15:41] <Eridius> rusti: range(0f, 0.5f).collect::<~[float]>()
[04:15:41] -rusti- ~[0]
[04:16:03] <strcat> acrichto: also if you use -fno-strict-aliasing to disable TBAA, it can still vectorize - so that's no the issue
[04:16:17] <strcat> it's the order
[04:16:23] <acrichto> for sure?
[04:17:33] *** Joins: adu (ajr@moz-F1F8E03E.washdc.fios.verizon.net)
[04:18:11] <brson> acrichto: :(
[04:18:24] <strcat> acrichto: maybe, maybe not
[04:18:26] <strcat> ;]
[04:18:39] <strcat> acrichto: we could also need to remove that null check at the start, I think I know how
[04:18:56] <strcat> .offset(0)
[04:19:01] *** Joins: wilmoore (wilmoore@moz-71431C3A.hsd1.co.comcast.net)
[04:19:04] <strcat> but it seems like a general issue.
[04:19:10] <strcat> I want a way to tell LLVM it's non-nullable
[04:19:24] <strcat> maybe InBoundsGEP is really the way :S
[04:19:53] <cmr> Might ask the LLVM people?
[04:19:53] <acrichto> strcat: .offset(0) where?
[04:19:56] <olsonjeffery> brson: ping
[04:20:00] <strcat> acrichto: iter()
[04:20:05] <strcat> to assert 'p' is non-null
[04:20:12] <strcat> well, .offset_inbounds(0) I mean
[04:20:30] *** Quits: wilmoore (wilmoore@moz-71431C3A.hsd1.co.comcast.net) (Client exited)
[04:20:34] <acrichto> as the returned pointer?
[04:20:42] <strcat> acrichto: yes
[04:20:44] <strcat> acrichto: it might not work
[04:20:52] <strcat> but I think that might be undef behaviour if it's null
[04:20:57] * strcat shrugs
[04:21:06] <strcat> alternatively... deref it and do nothing with the result
[04:21:20] <acrichto> strcat: that may be it, I just moved the getelementptr inbounds to the top of the loop, ran it through llc, and it's still generating vaddsd instructions so I don't think ordering is a problem
[04:21:30] * strcat cries
[04:21:39] *** Joins: recrack (Mibbit@B4104EBB.3CC170B1.1E14B209.IP)
[04:21:50] <strcat> why the hell does it add that null check
[04:22:00] *** Joins: mihneadb (mihneadb@E48845AB.3A9F9BD4.4C2245EF.IP)
[04:22:16] <acrichto> strcat: https://gist.github.com/alexcrichton/6171157
[04:22:44] <brson> olsonjeffery: pong
[04:23:00] <strcat> acrichto: try playing with rust's IR maybe
[04:23:24] <olsonjeffery> brson: running into this frustrating issue w/ aio some stuff.. curious if anything here jumps out at you: https://gist.github.com/olsonjeffery/6171067
[04:23:41] *** Quits: mihneadb (mihneadb@E48845AB.3A9F9BD4.4C2245EF.IP) (Ping timeout)
[04:23:47] *** Joins: lmandel (lmandel@moz-76CE9D51.cable.teksavvy.com)
[04:23:48] <olsonjeffery> it happens when i try to unwrap a future that contains an Option<TcpStreamAsync>
[04:23:49] <acrichto> strcat: adding a null check for %xs in the c++ ir also still generates vmovsd
[04:24:02] <olsonjeffery> the test completes, condition is raised, etc
[04:24:05] <strcat> acrichto: use -fno-strict-aliasing too
[04:24:08] <olsonjeffery> but it looks like the runtime barfs...
[04:24:25] <acrichto> strcat: not an option on llc apparently
[04:24:32] <olsonjeffery> i guess its an assert on exit_status in run_in_newsched_core
[04:24:35] <strcat> acrichto: delete the !tbaa node thing
[04:24:37] *** Quits: carllerche (carllerche@6B070D22.7E6A0813.1428D117.IP) (Quit: carllerche)
[04:25:06] <strcat> !tbaa !0 or whatever it is
[04:25:14] <acrichto> strcat: I already had to delete them
[04:25:19] <strcat> ah
[04:25:20] *** Joins: carllerche (carllerche@6B070D22.7E6A0813.1428D117.IP)
[04:26:07] <acrichto> strcat: wait, I just took that exact IR from rust and it also generates vmovsd and vaddsd
[04:26:14] <Eridius> rusti: 1u.div_floor(2u)
[04:26:15] <strcat> huh.
[04:26:15] -rusti- <anon>:5:22: 5:24 error: mismatched types: expected `&uint` but found `uint` (expected &-ptr but found uint)
[04:26:15] -rusti- <anon>:5          1u.div_floor(2u)
[04:26:15] -rusti-                                ^~
[04:26:15] -rusti- error: aborting due to previous error
[04:26:15] -rusti- application terminated with error code 101
[04:26:19] <Eridius> rusti: 1u.div_floor(&2u)
[04:26:19] -rusti- 0
[04:26:22] <acrichto> strcat: although I'm also using llvm-head
[04:26:23] *** Quits: maikklein2 (maik@moz-BFE8F4AD.dip0.t-ipconnect.de) (Ping timeout)
[04:26:30] <Eridius> rusti: (-1i).div_floor(&2i)
[04:26:31] -rusti- -1
[04:26:31] <strcat> acrichto: ah
[04:26:33] <acrichto> I don't think I have a 3.3 llc lying around
[04:26:35] <strcat> acrichto: maybe we just need to update
[04:26:46] <strcat> acrichto: they have definitely made loop-vectorize better.
[04:26:51] <acrichto> strcat: try compiling https://gist.github.com/alexcrichton/6171172
[04:26:57] <strcat> acrichto: btw use 'opt'
[04:27:03] <strcat> acrichto: you can get it to output IR again
[04:27:07] <Eridius> I wish I had an equivalent to .quot() right now
[04:27:11] <Eridius> err `quot` from haskell
[04:27:11] <acrichto> strcat: -opt ?
[04:27:16] <strcat> acrichto: no, a binary called opt :)
[04:27:24] <strcat> it optimizes LLVM IR and outputs IR
[04:27:43] <acrichto> ah!
[04:28:04] <strcat> acrichto: the switches for it are kind of weird though
[04:28:09] <brson> olsonjeffery: it looks like the failure is happening outside of the unwinder.try block in rt/task.rs
[04:28:23] <brson> yeah, it is
[04:28:30] <acrichto> strcat: what's the 'text output' switch?
[04:28:42] <brson> i would expect to see try_fn in the call stack if it was throwing insideof the the try/catch block
[04:28:44] <strcat> acrichto: -s
[04:29:10] <acrichto> strcat: still doesn't generate <double x 2> things
[04:29:16] <strcat> acrichto: I'm pretty sure you have to enable optimizations yourself
[04:29:26] <acrichto> strcat: yeah passed -O3
[04:29:31] <olsonjeffery> brson: so what does "outside of the unwinder" mean.. scheduler context?
[04:29:35] <strcat> acrichto: ah
[04:30:27] <acrichto> strcat: although neither does the c++ code
[04:30:37] <acrichto> strcat: as in get <double x 2> whatnots
[04:30:43] *** Quits: carllerche (carllerche@6B070D22.7E6A0813.1428D117.IP) (Quit: carllerche)
[04:30:53] <strcat> acrichto: pass -loop-vectorize too
[04:31:02] <brson> olsonjeffery: unwinder.try is the try/catch block that handles failures inside a task. it's the only place where fail! is recoverable. failure is also not recoverable inside scheduler tasks (SchedTask). this failure *looks* like it's in a normal GreenTask but happening outside of the try/catch block
[04:31:12] <acrichto> strcat: no change for either version
[04:31:28] <strcat> acrichto: the C++ IR is the -O2 output - right?
[04:31:34] <strcat> hrm
[04:31:47] <acrichto> strcat: I took the -O2 IR and I'm feeding it back into `opt`
[04:31:52] <strcat> with -O3?
[04:31:54] * strcat shrugs
[04:32:08] <acrichto> yeah
[04:33:12] <strcat> acrichto: it doesn't run vectorize
[04:33:50] <strcat> acrichto: pass it this
[04:33:59] <strcat> acrichto: http://ix.io/76w
[04:34:05] <brson> olsonjeffery: this stack trait indicates that fail! is being called from an anonymous closure inside of build_start_wrapper, which is sort of an odd place for this
[04:34:20] <olsonjeffery> brson: do you want to see the code?
[04:34:34] <brson> olsonjeffery: ok
[04:34:58] <acrichto> strcat: LLVM ERROR: Bad DataLayout ctor used.  Tool did not specify a DataLayout to use?
[04:35:13] <strcat> acrichto: heh, remove the first bit (make -no-aa the first)
[04:35:17] <olsonjeffery> brson: it's on olsonjeffery/rust aio_net_tcp ... make check-stage1-std TESTNAME=aio
[04:35:19] *** Joins: Earnestly (earnest@3F74F9E2.8E6FE497.30311652.IP)
[04:35:36] <strcat> acrichto: anyway might be more productive to investigate from rust's end
[04:35:43] <strcat> and try using raw ptrs like you suggested
[04:35:54] <strcat> we might have messed up target info or something...
[04:35:55] <acrichto> strcat: no luck, just generated the same code
[04:36:14] <acrichto> strcat: as in the -O2 C++ code generated the same IR output
[04:36:14] <olsonjeffery> brson: just wondering if its how im using the TcpWatcher.. i don't deschedule the task, as is done in the sync version in uvio
[04:36:14] * strcat shrugs
[04:36:43] <olsonjeffery> brson: the meat would be tcp_connect_async in uvio.rs
[04:38:01] <acrichto> brson: I just found the problem with 32-bit rusti, and it doesn't require LLVM changes so I think that the ones in #8328 are all that I'm gonna want to do for awhile
[04:38:53] <brson> acrichto: ok, r+
[04:40:57] *** Quits: geomyidae (geomyidae@DD6F7E3A.21468E9A.30200F38.IP) (Quit: Konversation terminated!)
[04:41:02] <acrichto> brson: or wait, I jumped the gun (forgot to actually re-enabled the 32-bit rusti tests)... I deleted the r+ for now
[04:41:10] <acrichto> just in case
[04:41:27] *** Quits: yong (chatzilla@89F941DF.4E87ADC2.263D9828.IP) (Ping timeout)
[04:42:56] *** Joins: carllerche (carllerche@6B070D22.7E6A0813.1428D117.IP)
[04:43:45] <jeaye> rusti: for i in i32::range(0, 10) { }
[04:43:46] -rusti- pastebinned 11 lines of output: http://sprunge.us/hBfN
[04:44:08] <jeaye> rusti: for i in std::i32::range(0, 10) { }
[04:44:08] -rusti- <anon>:5:18: 5:33 error: unresolved name `std::i32::range`.
[04:44:08] -rusti- <anon>:5          for i in std::i32::range(0, 10) { }
[04:44:08] -rusti-                            ^~~~~~~~~~~~~~~
[04:44:09] -rusti- error: aborting due to previous error
[04:44:09] -rusti- application terminated with error code 101
[04:44:12] <Eridius> jeaye: just use range()
[04:44:14] *** Joins: geomyidae (geomyidae@DD6F7E3A.21468E9A.30200F38.IP)
[04:44:20] <strcat> jeaye: they don't exist anymore, they were internal iterators
[04:44:21] <Eridius> it's part of iterator now, but it's in the prelude
[04:44:24] <strcat> there's just a generic range() now
[04:44:28] <strcat> that's an external one
[04:44:43] <Eridius> strcat: I'm working on turning Range into a DoubleEndedIterator, which will mean we can add range_rev() by inverting it
[04:44:48] <jeaye> strcat: Ok. Just trying to port to the new 'for' magic. Thanks for the heads up.
[04:44:55] <jeaye> rusti: for i in range(0, 10) { }
[04:44:56] -rusti- <anon>:5:13: 5:14 warning: unused variable: `i` [-W unused-variable (default)]
[04:44:56] -rusti- <anon>:5          for i in range(0, 10) { }
[04:44:56] -rusti-                       ^
[04:44:56] -rusti- ()
[04:44:58] <Eridius> the problem is I need to add extra bounds because e.g. range(0f, 0.5f) won't behave correctly if I don't
[04:45:03] <strcat> Eridius: I don't think we want range_rev as a shortcut for that
[04:45:08] * Eridius thinks he's not going to be able to allow for reversing range(0f, 0.5f) at all
[04:45:15] <strcat> just range(0, 10).invert()
[04:45:16] <Eridius> strcat: well at the least it will allow you to range().invert()
[04:45:19] <strcat> if it goes 9, 8, 7...
[04:45:22] <Eridius> which is what range_rev() would be a wrapper for
[04:45:33] <Eridius> since range_rev() still exists in the num modules
[04:45:43] <strcat> Eridius: but it's not the semantics you would expect from range_rev imo
[04:45:48] <strcat> so I'd rather just leave it out
[04:45:55] <strcat> and use invert if you really want that
[04:45:57] <Eridius> my feeling is we should export it as range_rev() anyway, just to answer the question of "how do I range from hi-low"
[04:46:03] <Eridius> strcat: the existing range_rev() actually does follow those precise semantics
[04:46:12] <strcat> I know, and I think it's wrong
[04:46:16] <Eridius> it was modified at some point (as a backwards-incompatible change that didn't actually break compilation)
[04:46:31] <strcat> I like .invert() because it's clear what it's going to do
[04:46:43] <jeaye> rusti: let v = ~[1, 2, 3]; for _ in v.iter() { }
[04:46:44] -rusti- ()
[04:46:51] <Eridius> well I'm not going to push for adding range_rev(), as long as I can get .invert() to work
[04:47:09] *** Joins: vk_ (chatzilla@moz-389FEE13.hsd1.ca.comcast.net)
[04:47:23] <strcat> Eridius: you could make it use Int if you need to
[04:47:28] <strcat> floats are dumb
[04:47:33] <Eridius> strcat: I was going to make it use Integer
[04:47:38] <strcat> yeah
[04:48:03] <Eridius> strcat: one of my concerns is that I could construct a type that implements Integer, and yet does not allow for reaching every possible number by adding (or subtracting) One
[04:48:30] <strcat> hm?
[04:48:33] <Eridius> I have a solution that works around that, using div_rem() and Sub, but I'm wondering if maybe I should just assume that this is never going to happen
[04:48:49] <strcat> you could implement an integer that's not an integer but you'd be wrong ;p
[04:49:06] <Eridius> I could implement something that conforms to the Integer trait, but isn't an integer the way math thinks about it
[04:49:13] <Eridius> I suspect I'm being too paranoid though
[04:49:36] *** Joins: gavinb (gavinb@moz-CA19A0CF.vic.adsl.internode.on.net)
[04:49:39] <Eridius> I'd feel better if the Integer trait actually defined some axioms that all integers should conform to (e.g. that every number is reachable by adding or subtracting One)
[04:49:49] <sp3d> in Haskell it's often noted that typeclasses don't enforce guarantees like the monad laws
[04:49:52] <Eridius> (the way Monad defines 3 axioms that all implementations need to obey)
[04:49:58] <sp3d> heh
[04:49:59] <Eridius> sp3d: right but at least they declare the laws
[04:50:03] <Eridius> in documentation
[04:50:25] *** Quits: carllerche (carllerche@6B070D22.7E6A0813.1428D117.IP) (Quit: carllerche)
[04:50:29] <Eridius> so yeah I think I will just assume that every Integer is reachable from every other one by adding/subtracting One enough times, which makes things simpler
[04:51:50] <brson> olsonjeffery: this is the bt in an unoptimized build V
[04:51:51] <brson> https://gist.github.com/brson/6171276
[04:51:51] <sp3d> maybe we could make a simple way for traits to try some simple sanity checks for trait impls, like #[trait_check]
[04:52:13] <brson> terminate_current_task is expecting the current task to contain a scheduler task and it doesn't for some reason
[04:52:22] <brson> i don't know why yet
[04:53:02] <Eridius> strcat: is there no test for range()?
[04:53:30] <strcat> Eridius: there is
[04:53:39] <strcat> I swapped out the old range for the new one in the run-pass tests
[04:53:44] <strcat> don't ask me why they're in run-pass
[04:53:52] <Eridius> ahh ok. I was looking in the tests module in iterator.rs
[04:54:25] <strcat> Eridius: run-pass/num-range.rs
[04:54:36] <Eridius> strcat: is there an easy way to run run-pass tests outside of `make check`?
[04:54:42] <strcat> rustc them
[04:54:44] <strcat> and run them
[04:54:46] <strcat> ;p
[04:54:51] <Eridius> well that requires building and installing rustc :P
[04:55:04] <strcat> you can refer to the stage1 rustc with a path
[04:55:19] <strcat> it works without being installed
[04:55:23] <strcat> that's how I debug compiler issues
[04:55:23] *** Joins: mihneadb (mihneadb@E48845AB.3A9F9BD4.4C2245EF.IP)
[04:55:35] <brson> olsonjeffery: I would guess though that fulfilling the promise from the scheduler task doesn't work correctly
[04:55:39] <Eridius> I suppose so
[04:55:46] <strcat> ~/projects/rust/x86_64-unknown-linux-gnu/stage1/bin/rustc std.rs --test
[04:55:52] <strcat> extra.rs --test, syntax.rs --test and so on
[04:55:52] <brson> olsonjeffery: have you done any tests of sending from a SchedTask to a GreenTask?
[04:55:55] <strcat> is my debug process
[04:56:02] <strcat> I hate the make workflow
[04:56:07] <strcat> it always does too much
[04:56:16] <Eridius> :/
[04:56:21] <olsonjeffery> brson: no.. i just removed the assert in try_send as we discussed the other day
[04:56:55] <strcat> Eridius: especially since you only need to rebuild libstd/rustc if you change a lang item to build the libstd tests
[04:57:01] <olsonjeffery> based on what i can observe from the test run it worked
[04:57:21] <Eridius> strcat: `make check-stage1-std NO_REBUILD=1 NO_BENCH=1` works reasonably well
[04:57:26] *** Joins: kermi (Mibbit@F7BDAFB8.6B56EC2F.AC9CCDD1.IP)
[04:57:32] <strcat> Eridius: still does too much ;p
[04:57:58] <kermi> rusti: let let=12
[04:57:59] -rusti- pastebinned 7 lines of output: http://sprunge.us/TZLi
[04:58:31] <kermi> Why let is not a valid variable name?
[04:58:35] *** Quits: adu (ajr@moz-F1F8E03E.washdc.fios.verizon.net) (Quit: adu)
[04:58:37] <Eridius> it's a keyword
[04:58:47] *** Joins: Jesin (Jessin_@moz-1B1307FF.eecs.lehigh.edu)
[04:58:57] <tikue> Eridius: would it ever be ambiguous?
[04:59:14] <mihneadb> tikue has a point
[04:59:30] <strcat> rust doesn't have contextual keywords
[04:59:40] <strcat> they are either a keyword or not a keyword atm
[04:59:55] <strcat> better error msgs
[05:00:05] <tikue> doesn't seem to be a big loss to me :P
[05:00:10] <tikue> i'd never want a keyword named let anyway
[05:00:14] <tikue> cuz of syntax highlighting 
[05:00:22] <tikue> sry s/keyword/variable
[05:00:40] <strcat> rusti: let
[05:00:41] -rusti- <anon>:6:4: 6:5 error: unexpected token: `}`
[05:00:41] -rusti- <anon>:6     };
[05:00:41] -rusti-              ^
[05:00:41] -rusti- application terminated with error code 101
[05:00:45] <strcat> rusti: let ;
[05:00:45] -rusti- <anon>:5:13: 5:14 error: unexpected token: `;`
[05:00:45] -rusti- <anon>:5          let ;
[05:00:45] -rusti-                       ^
[05:00:45] -rusti- application terminated with error code 101
[05:00:53] <strcat> rusti: for ;
[05:00:53] -rusti- <anon>:5:13: 5:14 error: unexpected token: `;`
[05:00:53] -rusti- <anon>:5          for ;
[05:00:53] -rusti-                       ^
[05:00:53] -rusti- application terminated with error code 101
[05:00:55] <strcat> rusti: for 
[05:00:56] -rusti- <anon>:6:4: 6:5 error: unexpected token: `}`
[05:00:56] -rusti- <anon>:6     };
[05:00:57] -rusti-              ^
[05:00:58] * strcat shrugs
[05:00:59] -rusti- application terminated with error code 101
[05:00:59] *** concrete.mozilla.org sets mode: +M 
[05:00:59] <Eridius> having fun?
[05:01:13] *** brson sets mode: -M 
[05:01:18] <strcat> rustc is not very great at error msgs
[05:01:25] <tikue> lol
[05:01:29] <kermi> Can you enter an entire Rust program with procedure main()?
[05:01:33] <strcat> can probably improve those
[05:01:59] * strcat expected to see "expected identifier, found '}'"
[05:02:04] <kermi> fn main() {println("Hello world!");}
[05:02:17] <tikue> rusti: fn main() { println("hay is for horses"); }
[05:02:17] -rusti- ()
[05:02:24] <tikue> rusti: fn main() { println("hay is for horses"); } main()
[05:02:24] -rusti- hay is for horses
[05:02:25] -rusti- ()
[05:02:44] <strcat> #[main] fn foo() { println("bar") }
[05:02:51] <tikue> how do you sleep
[05:02:57] <tikue> in rust
[05:03:10] *** Joins: jaen (jaen@moz-4169E71F.play-internet.pl)
[05:03:15] <strcat> you'll get tetanus
[05:03:33] <strcat> tikue: I don't know if there's a way anymore without the new scheduler (and maybe not even then)
[05:03:39] <tikue> ah
[05:03:45] *** Joins: tjc (tjc@moz-6EB4E533.dsl.tsoft.com)
[05:03:45] *** ChanServ sets mode: +o tjc
[05:03:48] <strcat> ask brson ;p
[05:04:34] <olsonjeffery> tikue: in newrt there's rt::io::timer::Timer
[05:04:46] <olsonjeffery> which has a sleep method to block the current task
[05:04:50] *** Quits: tjc (tjc@moz-6EB4E533.dsl.tsoft.com) (Quit: Places to go, people to annoy)
[05:04:57] <olsonjeffery> the underlying impl is a uv_timer_t
[05:05:20] <brson> should probably add a standalone sleep function
[05:05:20] * tikue wonders when newrt will land
[05:05:26] <brson> tonight
[05:05:28] <tikue> !
[05:05:29] <tikue> :o
[05:05:30] <brson> god dammit
[05:05:33] <tikue> lol!
[05:05:50] <tikue> brson: it'll completely replace the current runtime _tonight_ ?
[05:05:53] <brson> yes
[05:06:00] <tikue> wow! congrats :) 
[05:06:02] <sp3d> brilliant
[05:06:14] <tikue> so excuse my ignorance, but what will be the immediate benefit to the commoner like me
[05:06:24] <brson> i'm on an xfailing spree to make it work
[05:06:41] <brson> tikue: you'll be able to sleep()
[05:06:43] <kermi> let n=2*n
[05:06:46] <tikue> haha :P
[05:06:52] <brson> but basically nothing
[05:06:58] <kermi> rusti: let n=2*n
[05:06:58] -rusti- <anon>:6:4: 6:5 error: expected `;` but found `}`
[05:06:58] -rusti- <anon>:6     };
[05:06:59] -rusti-              ^
[05:06:59] -rusti- application terminated with error code 101
[05:06:59] <brson> i/o is still a little broken in newrt
[05:07:07] <brson> but soon there will be networking
[05:07:18] <brson> message passing is faster
[05:07:18] <kermi> Why braces are required?
[05:07:21] <brson> like a lot faster
[05:07:26] <mihneadb> kermi: it misses the ";"
[05:07:35] <kermi> In Python, we use indentation
[05:07:44] <mihneadb> kermi: yes. this is not python :)
[05:08:11] <tikue> brson: what's still broken with i/o?
[05:08:15] <mihneadb> but I don't know the reason!
[05:08:20] <mihneadb> don't want to troll :)
[05:08:52] * tikue wants ```let name = input("please enter your name");```
[05:08:55] *** Quits: kermi (Mibbit@F7BDAFB8.6B56EC2F.AC9CCDD1.IP) (Quit: http://www.mibbit.com ajax IRC Client)
[05:09:20] <brson> tikue: it's not threadsafe yet
[05:09:24] <tikue> oh
[05:09:32] <brson> ecr is working on that
[05:09:46] <brson> it does work though if RUST_THREADS=1
[05:09:56] <tikue> mm
[05:10:09] <brson> olsonjeffery: trying to reduce a test case
[05:11:30] <olsonjeffery> thanks
[05:13:18] <olsonjeffery> brson: btw.. i coulda sworn i built w/ --disable-optimize and --disable-optimize-cxx .. is there some other flag or was a mistaken?
[05:13:26] <olsonjeffery> ./configure'd w/, even
[05:15:37] *** Joins: carllerche (carllerche@6B070D22.7E6A0813.1428D117.IP)
[05:15:41] *** Quits: carllerche (carllerche@6B070D22.7E6A0813.1428D117.IP) (Quit: carllerche)
[05:15:52] <brson> olsonjeffery: no, --disable-optimize is it
[05:15:59] <olsonjeffery> ok, must've left it out, then.
[05:16:19] <brson> make says 'cfg: disabling rustc optimization (CFG_DISABLE_OPTIMIZE)' when not optimizig
[05:16:27] *** Joins: yong (chatzilla@89F941DF.4E87ADC2.263D9828.IP)
[05:20:14] *** Quits: strcat (strcat@moz-54F7FD49.cpe.net.cable.rogers.com) (Quit: sleep)
[05:21:01] *** Joins: maikklein2 (maik@moz-BFE8F4AD.dip0.t-ipconnect.de)
[05:22:06] *** Quits: tikue (tkuehn@moz-BBE3ABD.mv.mozilla.com) (Quit: tikue)
[05:24:02] *** Joins: hjr3 (hradtke@moz-E87BDF1F.socal.res.rr.com)
[05:24:08] *** Quits: infynyxx (infynyxx@DB780A29.749BA1D.DCC373F0.IP) (Client exited)
[05:25:19] <ChrisMorgan> See also the config.mk file, it shows what you had.
[05:27:26] *** Joins: Haxkerl (Mibbit@F7BDAFB8.6B56EC2F.AC9CCDD1.IP)
[05:27:29] *** Joins: mihneadb_ (mihneadb@moz-BF4FE20E.tmodns.net)
[05:27:52] <Haxkerl> Python has a very good error:
[05:28:09] <Haxkerl> (continued) from __future__ import braces
[05:28:22] <Haxkerl> (continued) SyntaxError: not a chance
[05:28:43] *** Quits: mihneadb (mihneadb@E48845AB.3A9F9BD4.4C2245EF.IP) (Ping timeout)
[05:29:55] * ChrisMorgan likes that one
[05:31:14] <ChrisMorgan> Haxkerl: a reasonable person will admit that Python's significant whitespace without the possibility of any special end delimiter does mean that things like passing a closure other than a lambda is ugly: define it first, then name it. Sometimes you want that, but normally you don't.
[05:31:54] *** Joins: oldmanstan (glesica@moz-CA910636.net)
[05:32:12] *** Quits: lmandel (lmandel@moz-76CE9D51.cable.teksavvy.com) (Quit: lmandel)
[05:32:37] <mihneadb_> how would I do something like ~[1,2,3].map(|x| do spawn ...) ?
[05:32:45] <vk_> Is there function or string method to convert a string to a char vector?
[05:33:11] <mihneadb_> vk_: so for sure there's to_ascii
[05:33:11] <maikklein2> https://github.com/mozilla/rust/wiki/Meeting-weekly-2013-08-06 what are conditions?
[05:33:29] <mihneadb_> vk_: but that is not *exactly* what you asked for
[05:33:31] <Haxkerl> ChrisMorgan: that's one of the reason I hate whitespace. Another reason is that indentation whitespace is difficult to represent on some systems.
[05:34:06] <sp3d> rusti: "hello".iter().collect::<~[char]>()
[05:34:07] -rusti- ~['h', 'e', 'l', 'l', 'o']
[05:34:18] <ChrisMorgan> Generally, I love Python's significant whitespace; but there are rare times when it becomes a minor nuisance.
[05:34:22] <brson> olsonjeffery: this fails with the same error https://gist.github.com/brson/6171479
[05:34:32] <mihneadb_> ah, right, collect. I was trying consume for some reason
[05:34:47] <vk_> mihneadb_: Apparently there used to be a ... thing, function I guess, str::chars() that took a &str and produced a ~[char], trying to find a modern equivalent. I'll check out to_ascii.
[05:34:57] <mihneadb_> vk_: check out sp3d's reply
[05:35:13] <ChrisMorgan> maikklein2: most useful documentation of conditions is probably in src/libstd/rt/io/mod.rs at present.
[05:35:18] <brson> olsonjeffery: the context switch of the send() from SchedTask to GreenTask is probably not transferring the scheduler across tasks properties. when the context switch happens the Scheduler is basically passed between tasks 
[05:35:21] <vk_> mihneadb_: sp3d: reading is hard, thanks :D
[05:35:24] <brson> *properly
[05:35:27] <mihneadb_> :)
[05:36:08] <brson> the function responsible is probably Sched.change_task_context
[05:36:15] <Haxkerl> ChrisMorgan: In fact, whitespace is significant in most programming languages (in the middle of a string)
[05:36:32] <ChrisMorgan> That's a _little_ different.
[05:36:36] <olsonjeffery> brson: wow, thanks a lot. ill see if i can fix it.
[05:36:59] <sp3d> once we get TBAA working, should Rust be as fast as Fortran? :P
[05:37:03] <sp3d> half-serious
[05:37:06] <mihneadb_> rust-buildbot: ~[1, 2, 3].map(|x| do spawn { printfln!("%?", x) })
[05:37:12] <mihneadb_> rusti: ~[1, 2, 3].map(|x| do spawn { printfln!("%?", x) })
[05:37:13] -rusti- pastebinned 16 lines of output: http://sprunge.us/icCH
[05:37:21] <mihneadb_> how can I properly do that^ ?
[05:37:51] <engla> mihneadb_: something like   (&[1,2,3]).iter().transform(|&x| do spawn { printfln!(x) }).advance(|_|true)
[05:38:02] <mihneadb_> engla: seems rather complicated 
[05:38:27] <engla> sure
[05:38:35] <mihneadb_> is there no easier way? / will there be one?
[05:38:37] <sp3d> rusti: ~[1, 2, 3].map(|&x| do spawn { printfln!("%?", x) })
[05:38:37] -rusti- 1
[05:38:38] -rusti- 2
[05:38:38] -rusti- 3
[05:38:38] -rusti- ~~[(), (), ()]
[05:38:43] <engla> the plan is to make this easier to use
[05:39:06] <mihneadb_> wait so you just dereferenced x basically
[05:39:12] <mihneadb_> and int implements send
[05:39:15] <sp3d> right
[05:39:15] <mihneadb_> is that the whole idea?
[05:39:37] <mihneadb_> nice
[05:39:41] <mihneadb_> thanks sp3d, engla
[05:40:01] <engla> don't thank me :)
[05:40:05] <sp3d> sometime I hope to write more than one line of rust at a time but IRC is good practice at least :)
[05:40:14] <engla> I didn't add anything
[05:40:18] *** Quits: enix (enix@moz-A50569DD.c3-0.slvr-ubr1.lnh-slvr.md.cable.rcn.com) (Quit: Konversation terminated!)
[05:40:32] *** Joins: ab (alex@BC9D99CC.37C1012D.FE617B51.IP)
[05:41:19] *** Quits: Haxkerl (Mibbit@F7BDAFB8.6B56EC2F.AC9CCDD1.IP) (Quit: http://www.mibbit.com ajax IRC Client)
[05:42:14] <mihneadb_> sp3d: sure is
[05:42:19] <mihneadb_> lots of good explanations in here
[05:48:38] *** Quits: gavinb (gavinb@moz-CA19A0CF.vic.adsl.internode.on.net) (Quit: gavinb)
[05:49:57] *** Joins: jensnockert (jensnocker@moz-A5E5C224.mobileonline.telia.com)
[05:51:03] *** Quits: jaen (jaen@moz-4169E71F.play-internet.pl) (Ping timeout)
[05:51:43] *** Joins: ghrust (ghrust@2EE61FCC.6A2AE50.F3114085.IP)
[05:51:44] <ghrust> 01[13rust01] 15brson 04force-pushed 06try from 14bcdde2b to 14ecc01b4: 02http://git.io/k471pw
[05:51:44] <ghrust> 13rust/06try 1452787e9 15Brian Anderson: std::rt: 2MB stacks again
[05:51:44] <ghrust> 13rust/06try 14260b444 15Brian Anderson: std::rt: Pull RUST_MIN_STACK from the environment
[05:51:44] <ghrust> 13rust/06try 141bf5b19 15Brian Anderson: std: Allow spawners to specify stack size
[05:51:45] *** Parts: ghrust (ghrust@2EE61FCC.6A2AE50.F3114085.IP) ()
[05:53:15] *** Joins: ghrust (ghrust@9C8B94D4.6A2AE50.F3114085.IP)
[05:53:15] <ghrust> 01[13rust01] 15bors merged 06auto into 06master: 02http://git.io/F3jafQ
[05:53:15] *** Parts: ghrust (ghrust@9C8B94D4.6A2AE50.F3114085.IP) ()
[05:54:27] *** Quits: engla (engla@moz-DBD1D96E.cust.bredbandsbolaget.se) (Ping timeout)
[05:56:23] *** Joins: ghrust (ghrust@24260B07.6A2AE50.F3114085.IP)
[05:56:23] <ghrust> 01[13rust01] 15bors pushed 0 new commits to 06auto: 02http://git.io/bJgixA
[05:56:23] *** Parts: ghrust (ghrust@24260B07.6A2AE50.F3114085.IP) ()
[05:56:24] *** Joins: ghrust (ghrust@9C8B94D4.6A2AE50.F3114085.IP)
[05:56:24] <ghrust> 01[13rust01] 15bors pushed 1 new commit to 06auto: 02http://git.io/ej305A
[05:56:24] <ghrust> 13rust/06auto 14554c6a4 15bors: auto merge of #8358 : brson/rust/newrt, r=brson
[05:56:24] *** Parts: ghrust (ghrust@9C8B94D4.6A2AE50.F3114085.IP) ()
[05:56:24] <dbaupp> brson: ping
[05:56:39] <brson> hey another branch merged. congrats
[05:56:52] <brson> now my turn to try again ...
[05:56:59] *** Joins: sebcrozet (sebcrozet@moz-A855F6C0.w82-127.abo.wanadoo.fr)
[05:57:06] <brson> attempt 11
[05:57:12] <brson> dbaupp: pong
[05:58:18] <olsonjeffery> keep the faith
[05:58:33] <olsonjeffery> brson: so does this mean the entire rt:: tree is moving to the root of the std crate?
[05:58:51] <olsonjeffery> or just the core sched/task stuff and things directly dependant on it (comm, etc) ?
[05:59:53] <brson> olsonjeffery: only comm and io will move up
[06:00:05] <brson> everything else is implementation detail
[06:00:10] <brson> rt is not public api
[06:00:14] * olsonjeffery nods
[06:00:15] <brson> for the most part
[06:00:24] *** Quits: recrack (Mibbit@B4104EBB.3CC170B1.1E14B209.IP) (Quit: http://www.mibbit.com ajax IRC Client)
[06:00:55] <olsonjeffery> ok.. aio is entangled with rtio and uvio (or the opposite, i should say)
[06:01:15] <olsonjeffery> thinking that IoFactory et al should be broken out into its own thing, separate from rtio
[06:01:30] <olsonjeffery> depending on whether you want to take the io/aio separation to its logical conclusion
[06:03:00] *** Joins: eholk (eholk@moz-CB9F01AA.hfc.comcastbusiness.net)
[06:03:00] *** Joins: dmi3y (dmi3y@9FD26F63.6075981B.B8FD5DE3.IP)
[06:03:04] <olsonjeffery> brson: anyways. a topic for another day. good luck and goodnight.
[06:05:10] <brson> olsonjeffery: seeya
[06:06:53] <dbaupp> brson: you were wondering about XorShift and the constant seed before: the xorshift rng only has good properties for some seed values.
[06:07:27] <dbaupp> (i.e. it's very easy to get very non-random randomness with a bad seed.)
[06:07:50] *** Joins: eatkinson (eatkinson@moz-5CF47426.dia.static.qwest.net)
[06:09:26] <brson> dbaupp: i suspected. the xorshift implementation I see in other libs do take seeds in their ctors. is there some way we can use random but good seeds?
[06:09:38] <maikklein2> ChrisMorgan, thanks
[06:09:53] <dbaupp> brson: possibly; I'm investigating this like that. :)
[06:12:56] *** Quits: geomyidae (geomyidae@DD6F7E3A.21468E9A.30200F38.IP) (Quit: Konversation terminated!)
[06:12:59] *** Quits: eatkinson (eatkinson@moz-5CF47426.dia.static.qwest.net) (Quit: eatkinson)
[06:14:10] *** Joins: infynyxx (infynyxx@moz-E95B370B.nyc.res.rr.com)
[06:15:51] *** Joins: geomyidae (geomyidae@DD6F7E3A.21468E9A.30200F38.IP)
[06:16:01] *** Quits: geomyidae (geomyidae@DD6F7E3A.21468E9A.30200F38.IP) (Quit: Konversation terminated!)
[06:17:08] <dbaupp> Eridius: pong (for ages ago)
[06:18:24] <Eridius> dbaupp: I was gonna ask questions about the splitn_iter(), since I found its behavior unusual
[06:18:30] <Eridius> but I investigated further and it seems to match python
[06:18:48] <Eridius> so while I think it's odd that, e.g. N refers to the number of splits, not the number of returned slices, it's not a big deal
[06:20:02] <brson> oh look another test failure
[06:20:02] <dbaupp> aha, yeah, I just ported the old each_split functions
[06:20:44] <dbaupp> Eridius: (in any case, I actually thing n == number of splits makes more sense: because then you don't have the special/non-sensical case of n == 0 if it was number of returned slices.)
[06:21:05] <Eridius> dbaupp: on the other hand, I think n == number of returned values makes more sense, because that's the way I think about it
[06:21:13] <Eridius> "I want to split this into two slices, so split(2)"
[06:21:38] <Eridius> I also find the behavior odd of emitting one final empty slice under certain circumstances, so e.g. a 5-element vector where it splits on every element gives you 6 slices back
[06:21:45] <Eridius> but that seems to be common across a bunch of languages
[06:21:52] <Eridius> (D has very weird behavior around that btw, very confusing)
[06:22:37] *** Joins: RMF (RMF@moz-2758EDDD.dsl.telepac.pt)
[06:23:16] *** Joins: ghrust (ghrust@C621748.6A2AE50.F3114085.IP)
[06:23:16] <ghrust> 01[13rust01] 15bors 04force-pushed 06auto from 14554c6a4 to 1462dbdc4: 02http://git.io/N3iJvQ
[06:23:16] *** Parts: ghrust (ghrust@C621748.6A2AE50.F3114085.IP) ()
[06:23:16] *** Joins: ghrust (ghrust@FD7BC443.6A2AE50.F3114085.IP)
[06:23:16] <ghrust> 01[13rust01] 15bors pushed 5 new commits to 06auto: 02http://git.io/3JfzcA
[06:23:16] <ghrust> 13rust/06auto 1444acdad 15Huon Wilson: libsyntax/ext/deriving/cmp/* was ignored by the build system.
[06:23:16] <ghrust> 13rust/06auto 148407ec9 15Huon Wilson: syntax: make #[deriving(TotalOrd)] lazy....
[06:23:17] <ghrust> 13rust/06auto 1488620c2 15Huon Wilson: std: implement Total{Ord,Eq} for pointers.
[06:23:19] *** Parts: ghrust (ghrust@FD7BC443.6A2AE50.F3114085.IP) ()
[06:23:20] *** Quits: mark_edward (quassel@981AA104.E81F12CD.76F66111.IP) (Ping timeout)
[06:23:35] <Eridius> anyway, it's not a big deal. I was going to complain, but I didn't realize how many languages actually behave in the way that I thought was odd, and I guess consistency trumps my own preferences
[06:23:48] *** Quits: hjr3 (hradtke@moz-E87BDF1F.socal.res.rr.com) (Quit: My MacBook has gone to sleep. ZZZzzzâ€¦)
[06:23:51] <dbaupp> Eridius: you can use split_options_iter to control whether or not it returns an empty slice at the end or not, btw.
[06:24:04] *** Quits: eholk (eholk@moz-CB9F01AA.hfc.comcastbusiness.net) (Quit: eholk)
[06:24:11] *** Joins: mrordinaire (Mibbit@1A659656.A607747.FD383126.IP)
[06:24:31] <dbaupp> rusti: let s = "foo bar "; s.split_options_iter(' ', 10000, false).to_owned_vec()
[06:24:32] -rusti- ~["foo", "bar"]
[06:24:41] <dbaupp> rusti: let s = "foo bar "; s.split_options_iter(' ', 10000, true).to_owned_vec()
[06:24:41] -rusti- ~["foo", "bar", ""]
[06:24:53] *** Joins: eholk (eholk@moz-CB9F01AA.hfc.comcastbusiness.net)
[06:25:21] <Eridius> dbaupp: wat
[06:25:51] <Eridius> rusti: let s = "foo bar  "; s.split_options_iter(' ', 10000, false).to_owned_vec()
[06:25:51] -rusti- ~["foo", "bar", ""]
[06:26:04] <Eridius> hrm there were two spaces. Shouldn't it have given me two empty slices?
[06:26:13] * Eridius was looking at the vec variants though not the string variants
[06:26:35] <mrordinaire> dbaupp: hi, could you please tell me how to load a source file into rusti?
[06:26:58] <doomlord_> does rust have 'continue' 
[06:27:08] <dbaupp> mrordinaire: nope... I don't think it's possible
[06:27:18] <dbaupp> doomlord_: for a loop? it's just `loop`
[06:27:29] <mrordinaire> dbaupp: so what is :load for?
[06:27:38] <dbaupp> mrordinaire: oh, maybe it does
[06:27:53] <dbaupp> rusti: let s = "foo bar "; s.split_options_iter(' ', 10000, true).to_owned_vec() // Eridius 
[06:27:54] -rusti- ~["foo", "bar", ""]
[06:28:06] * dbaupp is confused too now
[06:28:23] <dbaupp> rusti: let s = "foo bar "; s.split_iter(' ').to_owned_vec()
[06:28:23] -rusti- ~["foo", "bar", ""]
[06:28:31] <dbaupp> rusti: let s = "foo bar  "; s.split_iter(' ').to_owned_vec()
[06:28:32] -rusti- ~["foo", "bar", "", ""]
[06:28:41] <dbaupp> (wait, I forgot to have 2 spaces.)
[06:29:00] <dbaupp> Eridius: `false` == no trailing empty, so one empty slice is the expected behaviour
[06:29:33] <dbaupp> Eridius: but, yeah, for vec, no fanciness like that.
[06:29:38] *** Quits: Kruppe (user@moz-E150F49F.cpe.net.cable.rogers.com) (Client exited)
[06:30:18] *** Quits: jeaye (Jeaye@moz-FD505E54.hsd1.ca.comcast.net) (Quit: zzz)
[06:30:29] *** Joins: hjr3 (hradtke@moz-E87BDF1F.socal.res.rr.com)
[06:30:38] <mrordinaire> dbaupp: I tried that, but after executing `:load mysource.rs` it keeps saying `unable to find crate mysource`
[06:31:10] <dbaupp> mrordinaire: I have no idea... I didn't even know that load existed :P
[06:31:22] <mrordinaire> dbaupp: i see
[06:31:28] <mrordinaire> dbaupp: thanks anyway
[06:32:58] <dbaupp> mrordinaire: ok, i just tested it, and it works for me:
[06:33:55] <dbaupp> lib.rs: `pub fn f() -> int {1}` ... `rusti> :load lib` >>> crate loaded: lib `rusti> lib::f()` >>> 1
[06:35:59] *** Quits: ross (ross@moz-8A84103E.br.br.cox.net) (Quit: )
[06:36:34] *** Joins: jaen (jaen@moz-EB4DB9F.neoplus.adsl.tpnet.pl)
[06:36:38] *** Joins: victorporof (victorporo@B4B1C8EE.73B1E539.9B1E38F4.IP)
[06:37:53] *** Joins: geomyidae (geomyidae@DD6F7E3A.21468E9A.30200F38.IP)
[06:38:29] *** Quits: eholk (eholk@moz-CB9F01AA.hfc.comcastbusiness.net) (Quit: eholk)
[06:39:13] *** Quits: hjr3 (hradtke@moz-E87BDF1F.socal.res.rr.com) (Quit: My MacBook has gone to sleep. ZZZzzzâ€¦)
[06:39:18] *** Joins: eholk (eholk@moz-CB9F01AA.hfc.comcastbusiness.net)
[06:41:10] *** Quits: ab (alex@BC9D99CC.37C1012D.FE617B51.IP) (Quit: Konversation terminated!)
[06:41:25] *** Quits: jensnockert (jensnocker@moz-A5E5C224.mobileonline.telia.com) (Input/output error)
[06:41:27] *** Quits: Jesin (Jessin_@moz-1B1307FF.eecs.lehigh.edu) (Ping timeout)
[06:44:01] *** Joins: dim-an (ermolovd@moz-FE167E47.nationalcablenetworks.ru)
[06:45:27] *** Quits: dmi3y (dmi3y@9FD26F63.6075981B.B8FD5DE3.IP) (Quit: My MacBook Pro has gone to sleep. ZZZzzzâ€¦)
[06:46:14] *** Joins: dmi3y (dmi3y@9FD26F63.6075981B.B8FD5DE3.IP)
[06:46:47] *** Quits: mihneadb_ (mihneadb@moz-BF4FE20E.tmodns.net) (Input/output error)
[06:47:07] *** Quits: eholk (eholk@moz-CB9F01AA.hfc.comcastbusiness.net) (Quit: eholk)
[06:47:09] *** Quits: tiffany (kawaii@moz-EB8B0C08.dhcp.embarqhsd.net) (Ping timeout)
[06:49:16] <bjz> when you send something over a Chan, do the messages queue up?
[06:49:36] *** Joins: eholk (eholk@moz-CB9F01AA.hfc.comcastbusiness.net)
[06:49:53] <bjz> ie. if you can't deal with them all at once with recv, will any get lost?
[06:50:19] <brson> bjz: they queue forever
[06:50:23] <brson> until you oom
[06:50:23] <bjz> awesome
[06:50:28] <bjz> oom?
[06:50:29] <bjz> :P
[06:50:32] <bjz> boom?
[06:50:41] <bjz> :P
[06:50:44] <brson> run out of memory
[06:50:48] <bjz> ahh
[06:50:53] *** Joins: jensnockert (jensnocker@moz-3D772E8D.mobileonline.telia.com)
[06:51:51] *** Quits: eholk (eholk@moz-CB9F01AA.hfc.comcastbusiness.net) (Quit: eholk)
[06:54:15] *** Joins: Uther (Instantbir@moz-1B244B05.hfc.dyn.abo.bbox.fr)
[06:55:33] *** Joins: eholk (eholk@moz-CB9F01AA.hfc.comcastbusiness.net)
[06:56:23] *** Quits: sebcrozet (sebcrozet@moz-A855F6C0.w82-127.abo.wanadoo.fr) (Ping timeout)
[06:56:46] *** Joins: ghrust (ghrust@AC22872E.6A2AE50.F3114085.IP)
[06:56:46] <ghrust> 01[13rust01] 15bors 04force-pushed 06auto from 1456fc72b to 1462dbdc4: 02http://git.io/N3iJvQ
[06:56:46] *** Parts: ghrust (ghrust@AC22872E.6A2AE50.F3114085.IP) ()
[06:56:48] *** Joins: ghrust (ghrust@79968228.6A2AE50.F3114085.IP)
[06:56:48] <ghrust> 01[13rust01] 15bors pushed 4 new commits to 06auto: 02http://git.io/voIxcg
[06:56:48] <ghrust> 13rust/06auto 140114d86 15Brian Anderson: Disable linked failure tests...
[06:56:48] <ghrust> 13rust/06auto 14aa04abc 15Brian Anderson: rusti: Disable tests...
[06:56:48] <ghrust> 13rust/06auto 140c4e9e6 15Brian Anderson: Turn on the new runtime
[06:56:48] *** Parts: ghrust (ghrust@79968228.6A2AE50.F3114085.IP) ()
[06:56:53] *** Joins: sebcrozet (sebcrozet@moz-F96421F3.w80-13.abo.wanadoo.fr)
[06:57:09] *** Quits: infynyxx (infynyxx@moz-E95B370B.nyc.res.rr.com) (Client exited)
[07:00:20] *** Quits: sebcrozet (sebcrozet@moz-F96421F3.w80-13.abo.wanadoo.fr) (Ping timeout)
[07:00:48] *** Joins: sebcrozet (sebcrozet@moz-2517AE39.w80-13.abo.wanadoo.fr)
[07:00:51] *** Quits: ChemicalHarm (Mibbit@moz-A9F37238.hsd1.md.comcast.net) (Quit: http://www.mibbit.com ajax IRC Client)
[07:03:58] *** Joins: fabiand (fabiand@moz-31B43A8F.adsl.alicedsl.de)
[07:05:29] *** Quits: cubic (cubic@moz-FE5AD6C7.mc.videotron.ca) (Connection reset by peer)
[07:06:15] *** Quits: victorporof (victorporo@B4B1C8EE.73B1E539.9B1E38F4.IP) (Ping timeout)
[07:06:47] *** Joins: thomaslee (thomaslee@moz-306D3DF4.hsd1.or.comcast.net)
[07:06:57] *** Joins: BizarreCake (BizarreCak@moz-361FE9B2.dynamic.barak-online.net)
[07:07:48] *** Joins: ghrust (ghrust@E7A4CCE2.6A2AE50.F3114085.IP)
[07:07:49] <ghrust> 01[13rust01] 15brson 04force-pushed 06try from 14ecc01b4 to 148116b64: 02http://git.io/k471pw
[07:07:49] <ghrust> 13rust/06try 148116b64 15Brian Anderson: Remove the C++ runtime. Sayonara
[07:07:49] *** Parts: ghrust (ghrust@E7A4CCE2.6A2AE50.F3114085.IP) ()
[07:07:49] *** Quits: eholk (eholk@moz-CB9F01AA.hfc.comcastbusiness.net) (Quit: eholk)
[07:09:07] <Eridius> wooo
[07:09:18] <Eridius> I wonder if that will fix task failure on OS X Mavericks?
[07:10:09] <bjz> brson: almost there!!!
[07:10:11] <bjz> :D
[07:10:22] * bjz prepares to clap
[07:10:24] <brson> Eridius: probably not. unwinding is the same
[07:10:34] <Eridius> strmpnk: random thought: range() isn't going to work properly with floats when you get to the point that state + one == state (because of lack of precision)
[07:10:37] <Eridius> damn
[07:11:40] <bjz> rusti: extern "C" fn f() { g() } unsafe fn g() {}
[07:11:40] -rusti- <anon>:5:29: 5:34 error: call to unsafe function requires unsafe function or block
[07:11:40] -rusti- <anon>:5          extern "C" fn f() { g() } unsafe fn g() {}
[07:11:40] -rusti-                                       ^~~~~
[07:11:40] -rusti- error: aborting due to previous error
[07:11:41] -rusti- application terminated with error code 101
[07:11:42] * dbaupp cleans up his CheckedAdd patch
[07:13:32] *** Joins: recrack (Mibbit@B4104EBB.3CC170B1.1E14B209.IP)
[07:14:13] <bblum> brson: btw, we could avoid the task/cleanupjob sync dance if the task is unkillable
[07:14:43] <bblum> that would, of course, make the interface have the potential for environment races again in such cases
[07:15:06] <bblum> but would solve the particular case from today
[07:15:25] <maikklein2> what does this mean? 'main : loop {} ?
[07:15:44] <dbaupp> maikklein2: labelled break
[07:16:12] <dbaupp> rusti: 'main: loop { loop { break 'main } println("this won't print"); }
[07:16:12] -rusti- ()
[07:16:14] <maikklein2> dbaupp, ah so I can do sth like break 'main?
[07:16:18] <maikklein2> ah cool
[07:18:15] <Eridius> rusti: (float::max_value, float::max_value.next_after(0))
[07:18:16] -rusti- pastebinned 20 lines of output: http://sprunge.us/KFeA
[07:19:44] <dbaupp> rusti: use std::float; (float::max_value, float::max_value.next_after(0))
[07:19:45] -rusti- pastebinned 8 lines of output: http://sprunge.us/VQNA
[07:19:49] *** Joins: victorporof (victorporo@B4B1C8EE.73B1E539.9B1E38F4.IP)
[07:20:23] <Eridius> guess there isn't a constant for it
[07:20:37] <dbaupp> rusti: use std::f64; (f64::max_value, f64::max_value.next_after(0))
[07:20:38] -rusti- <anon>:5:66: 5:67 error: mismatched types: expected `f64` but found `<VI0>` (expected f64 but found integral variable)
[07:20:38] -rusti- <anon>:5          use std::f64; (f64::max_value, f64::max_value.next_after(0))
[07:20:38] -rusti-                                                                            ^
[07:20:38] -rusti- error: aborting due to previous error
[07:20:40] -rusti- application terminated with error code 101
[07:20:48] <dbaupp> rusti: use std::f64; (f64::max_value, f64::max_value.next_after(0.0))
[07:20:51] -rusti- line longer than 150 columns, pastebinned 1 lines of output: http://sprunge.us/aJPS
[07:20:57] <Eridius> surprised there isn't a float::max_value. Could use bounded I suppose
[07:21:02] <dbaupp> yup
[07:21:27] <Eridius> rusti: use std::f64; range(f64::max_value.next_after(0.0), f64::max_value).to_owned_vec()
[07:21:28] -rusti- application terminated abnormally with signal 9 (Killed)
[07:21:29] *** Joins: busylizzy (lisa@85228838.12D0DC84.211374C4.IP)
[07:21:33] <Eridius> woohoo it repeats infinitely!
[07:21:41] <Eridius> maybe we should slap the Integer bounds on Range in general
[07:21:56] * Eridius submitted a PR that adds DoubleEndedIterator to Range and uses Integer there
[07:22:16] <dbaupp> don't bother yet... range needs to use a checked_add that returns None for nonsensical outputs.
[07:22:31] <Eridius> oh I thought the proposed checked_add was only checking for overflow
[07:22:43] <dbaupp> well, that's overflow too
[07:22:53] <dbaupp> (well, underflow)
[07:23:17] <dbaupp> in any case, it's a bad addition, and I'd think that checked_add would catch things like that.
[07:23:40] <Eridius> perhaps
[07:23:52] <dbaupp> e.g. 1.0e100 + 1.0 -> None, because it didn't change.
[07:25:21] *** Joins: jensnock_ (jensnocker@moz-3D772E8D.mobileonline.telia.com)
[07:25:42] *** Quits: jensnockert (jensnocker@moz-3D772E8D.mobileonline.telia.com) (Ping timeout)
[07:25:43] *** Quits: doomlord (doomlod@moz-13E69BC8.range86-180.btcentralplus.com) (Ping timeout)
[07:28:13] *** Quits: jensnock_ (jensnocker@moz-3D772E8D.mobileonline.telia.com) (Ping timeout)
[07:29:37] *** Quits: Earnestly (earnest@3F74F9E2.8E6FE497.30311652.IP) (Ping timeout)
[07:30:41] *** Quits: dim-an (ermolovd@moz-FE167E47.nationalcablenetworks.ru) (Quit: dim-an)
[07:31:10] <Eridius> dbaupp: I guess checked_add could be something like `let x = self + val; if x < cmp::max(self, val) { None } else { Some(x) }`
[07:32:01] *** Joins: jensnockert (jensnocker@moz-3D772E8D.mobileonline.telia.com)
[07:32:56] *** Joins: justfriend (chatzilla@FF78AC4E.7FC65FC8.D095E309.IP)
[07:33:20] <justfriend> hi
[07:33:35] *** Quits: justfriend (chatzilla@FF78AC4E.7FC65FC8.D095E309.IP) (Quit: ChatZilla 0.9.85 [SeaMonkey 2.0/20091017081335])
[07:33:58] <dbaupp> Eridius: yeah, that seems reasonable.
[07:34:12] <dbaupp> (but only for the integral ones.)
[07:34:55] <Eridius> well that impl assumes two positive values. So supporting 0 and negative would be a bit more complicated
[07:35:06] <Eridius> but it basically just tries to enforce the rule that "if you add two numbers, you get something higher". So that works for floating too
[07:35:17] <Eridius> although it doesn't handle infinity/nan on floating
[07:36:08] <dbaupp> yes
[07:36:25] * dbaupp has spent a little while battling it already :(
[07:37:02] <Eridius> sure would be nice if you could implement something for a generic trait, and then reimplement it for specialized concrete types :/
[07:37:04] *** Joins: pupoque (Adium@moz-D95564BD.ioffe.ru)
[07:37:17] <Eridius> because then you could come up with an impl for numbers, and then special-case floating point to handle inf/nan
[07:38:05] <Eridius> similarly, Range doesn't provide size_hint(), and I can't write one because it's too generic
[07:38:13] <Eridius> wish I could special-case it for the primitive integral types, but I can't
[07:38:44] *** Quits: cdidd (cdidd@moz-9F1ECBB7.broadband.corbina.ru) (Ping timeout)
[07:38:55] *** Quits: pupoque (Adium@moz-D95564BD.ioffe.ru) (Quit: Leaving.)
[07:41:04] <dbaupp> yeah
[07:41:14] <dbaupp> https://github.com/mozilla/rust/issues/7059 btw
[07:41:28] <Eridius> thanks
[07:41:33] <dbaupp> (slightly different to that, but in the same vein.)
[07:41:57] <Eridius> I'll have to read the discussion later, but at least I can hit Watch
[07:47:48] *** Quits: jensnockert (jensnocker@moz-3D772E8D.mobileonline.telia.com) (Ping timeout)
[07:49:03] *** Joins: echristo (echristo@moz-1892C634.hsd1.ca.comcast.net)
[07:52:51] *** Joins: jensnockert (jensnocker@moz-131195AC.mobileonline.telia.com)
[07:56:22] *** Joins: ghrust (ghrust@E7A4CCE2.6A2AE50.F3114085.IP)
[07:56:22] <ghrust> 01[13rust01] 15bors pushed 5 new commits to 06auto: 02http://git.io/alkYxQ
[07:56:22] <ghrust> 13rust/06auto 1444acdad 15Huon Wilson: libsyntax/ext/deriving/cmp/* was ignored by the build system.
[07:56:22] <ghrust> 13rust/06auto 148407ec9 15Huon Wilson: syntax: make #[deriving(TotalOrd)] lazy....
[07:56:22] <ghrust> 13rust/06auto 1488620c2 15Huon Wilson: std: implement Total{Ord,Eq} for pointers.
[07:56:24] *** Parts: ghrust (ghrust@E7A4CCE2.6A2AE50.F3114085.IP) ()
[08:05:02] *** Quits: vk_ (chatzilla@moz-389FEE13.hsd1.ca.comcast.net) (Quit: ChatZilla 0.9.90.1 [Firefox 23.0/20130729175331])
[08:06:36] *** Joins: cdidd (cdidd@moz-C2A8EEFB.broadband.corbina.ru)
[08:09:55] *** Quits: brson (brson@moz-BBE3ABD.mv.mozilla.com) (Ping timeout)
[08:14:56] *** Joins: tikue (tkuehn@moz-CF8BEBEF.dia.static.qwest.net)
[08:15:18] *** Quits: tikue (tkuehn@moz-CF8BEBEF.dia.static.qwest.net) (Quit: tikue)
[08:18:49] *** Quits: snadon (chatzilla@moz-3BC727E8.mc.videotron.ca) (Ping timeout)
[08:19:52] *** Quits: maikklein2 (maik@moz-BFE8F4AD.dip0.t-ipconnect.de) (Ping timeout)
[08:21:29] *** Joins: Ms2ger (Ms2ger@35CC4A24.2B12F798.F15B0BB3.IP)
[08:22:35] *** Joins: orshem (orshem@C5E06B1E.A5B6B765.E3D28531.IP)
[08:27:55] *** Joins: true_droid (true_droid@moz-123FD9B8.beck.volia.net)
[08:30:49] *** Joins: CarpNet (ac@moz-FD24B77.sohonet.co.uk)
[08:33:56] *** Joins: maikklein2 (maik@moz-BFE8F4AD.dip0.t-ipconnect.de)
[08:36:11] *** Quits: maikklein2 (maik@moz-BFE8F4AD.dip0.t-ipconnect.de) (Ping timeout)
[08:37:41] *** Quits: orshem (orshem@C5E06B1E.A5B6B765.E3D28531.IP) (Quit: Leaving)
[08:37:51] *** Joins: dim-an (ermolovd@moz-74FA7782.yandex.net)
[08:39:20] *** Joins: Blub\w (wry@7E3BB9D.71150E1A.237AE2BA.IP)
[08:41:47] *** Quits: dim-an (ermolovd@moz-74FA7782.yandex.net) (Client exited)
[08:42:54] *** Quits: BizarreCake (BizarreCak@moz-361FE9B2.dynamic.barak-online.net) (Connection reset by peer)
[08:42:59] *** Joins: q66 (q66@6EE9DE40.46454B5D.33AABD5F.IP)
[08:43:45] *** Joins: james4k (james@moz-E7990244.consolidated.net)
[08:48:00] *** Joins: robertknight (robertknig@moz-54528EE0.wby.mendeley.com)
[08:48:58] *** Joins: Earnestly (earnest@3F74F9E2.8E6FE497.30311652.IP)
[08:54:39] <sammykim> Isn't there any web irc for servo ? ; ) 
[08:55:18] <klutzy> #servo ?
[08:55:44] <klutzy> for direct mibbit link http://chat.mibbit.com/?server=irc.mozilla.org&channel=%23servo
[08:57:33] <sammykim> Oh tanks
[08:57:43] <sammykim> what's the comman to open new channel?
[08:58:00] <sammykim> I thought it is "/j [chan_name]" but it wasn't
[08:58:03] <klutzy> usually /join #servo
[08:58:12] <klutzy> what client do you use?
[08:58:15] <sammykim> oh I forgot #..
[08:58:25] <klutzy> aha
[08:58:28] <sammykim> haha
[08:58:30] <sammykim> Thanks man
[08:58:46] <klutzy> :)
[09:00:56] *** Joins: davbo (dave@moz-3FFA637C.oucs.ox.ac.uk)
[09:02:06] *** Joins: z0w0 (zack@moz-E12708D5.lns6.woo.bigpond.net.au)
[09:05:19] *** Quits: dmi3y (dmi3y@9FD26F63.6075981B.B8FD5DE3.IP) (Quit: My MacBook Pro has gone to sleep. ZZZzzzâ€¦)
[09:06:47] *** Joins: dmi3y (dmi3y@9FD26F63.6075981B.B8FD5DE3.IP)
[09:16:48] *** Joins: BitPuffin (quassel@moz-8370D1B9.bredband.comhem.se)
[09:18:28] *** Quits: BitPuffin (quassel@moz-8370D1B9.bredband.comhem.se) (Ping timeout)
[09:18:37] *** Quits: KindOne (KindOne@moz-B909808.dynamic.ip.windstream.net) (Ping timeout)
[09:18:57] *** Joins: BitPuffin (quassel@moz-8370D1B9.bredband.comhem.se)
[09:21:39] *** Quits: BitPuffin (quassel@moz-8370D1B9.bredband.comhem.se) (Client exited)
[09:22:44] *** Joins: KindOne (KindOne@moz-99DDEAA6.dynamic.ip.windstream.net)
[09:22:55] *** Quits: ChrisMorgan (chris@moz-6AC741CA.static.tpgi.com.au) (Ping timeout)
[09:23:58] *** Joins: BitPuffin (quassel@moz-8370D1B9.bredband.comhem.se)
[09:24:28] *** Quits: KindOne (KindOne@moz-99DDEAA6.dynamic.ip.windstream.net) (Ping timeout)
[09:24:38] *** Joins: KindTwo (KindOne@moz-983E660C.dynamic.ip.windstream.net)
[09:25:38] *** Quits: BitPuffin (quassel@moz-8370D1B9.bredband.comhem.se) (Ping timeout)
[09:25:51] *** KindTwo is now known as KindOne
[09:26:12] *** Joins: BitPuffin (quassel@moz-8370D1B9.bredband.comhem.se)
[09:26:23] *** Quits: true_droid (true_droid@moz-123FD9B8.beck.volia.net) (Client exited)
[09:27:16] *** Quits: BitPuffin (quassel@moz-8370D1B9.bredband.comhem.se) (Client exited)
[09:28:40] *** Joins: Home (chatzilla@moz-6FB35D32.dynamic.isp.telekom.rs)
[09:29:16] *** Joins: BitPuffin (quassel@moz-8370D1B9.bredband.comhem.se)
[09:30:56] *** Quits: BitPuffin (quassel@moz-8370D1B9.bredband.comhem.se) (Ping timeout)
[09:31:29] *** Joins: BitPuffin (quassel@moz-8370D1B9.bredband.comhem.se)
[09:31:57] *** Quits: BitPuffin (quassel@moz-8370D1B9.bredband.comhem.se) (Client exited)
[09:34:06] *** Joins: BitPuffin (quassel@moz-8370D1B9.bredband.comhem.se)
[09:35:17] *** Joins: ghrust (ghrust@CFE85B59.6A2AE50.F3114085.IP)
[09:35:18] <ghrust> 01[13rust01] 15bors merged 06auto into 06master: 02http://git.io/alkYxQ
[09:35:18] *** Parts: ghrust (ghrust@CFE85B59.6A2AE50.F3114085.IP) ()
[09:38:19] *** Joins: ghrust (ghrust@C8693FCB.6A2AE50.F3114085.IP)
[09:38:19] <ghrust> 01[13rust01] 15bors pushed 0 new commits to 06auto: 02http://git.io/TFjD0Q
[09:38:19] *** Parts: ghrust (ghrust@C8693FCB.6A2AE50.F3114085.IP) ()
[09:38:20] *** Joins: ghrust (ghrust@614D05BD.6A2AE50.F3114085.IP)
[09:38:20] <ghrust> 01[13rust01] 15bors pushed 1 new commit to 06auto: 02http://git.io/iv2OGg
[09:38:20] <ghrust> 13rust/06auto 14de2f128 15bors: auto merge of #8358 : brson/rust/newrt, r=brson
[09:38:20] *** Parts: ghrust (ghrust@614D05BD.6A2AE50.F3114085.IP) ()
[09:39:43] *** Joins: ipc (ipc@moz-76ED5036.lightspeed.cicril.sbcglobal.net)
[09:40:41] <ipc> good morning
[09:40:56] <ipc> may I ask a servo project question?
[09:42:20] <bjz> ipc: might be better to ask on #servo
[09:42:27] <ipc> ah thanks
[09:42:53] <bjz> ipc: we can answer #rust questions though!
[09:42:55] <bjz> :)
[09:43:12] <ipc> :)
[09:43:33] <bjz> ipc: are you new here?
[09:43:41] <bjz> I haven't seen you around
[09:43:47] <ipc> I've dropped in once or twice 
[09:43:54] <ipc> been lurking on the list for a while
[09:44:00] <bjz> nice
[09:44:01] <ipc> only posted recently
[09:44:04] <bjz> well, hello!
[09:44:25] <bjz> I hope you have enjoyed the lurking
[09:44:41] <bjz> feel free to join in though :)
[09:44:45] <ipc> I'm looking forward to when things stabilize enough for me to feel comfortable on a larger project
[09:44:52] <bjz> aye
[09:44:58] <ipc> right now all I've done are little demos/experiments
[09:45:22] <bjz> what kind of ares?
[09:45:25] <bjz> *areas
[09:45:43] <bjz> like, what would you like to use rust for?
[09:46:05] <ipc> porting some Poker hand evaluators and then some zmq code
[09:46:22] <bjz> nice :)
[09:46:50] <bjz> ipc: any feedback so far?
[09:47:42] <ipc> ultimately I would use it to build servers that analyzed/acted upon real-time data (listening to UDP, reading/writing to TCP)
[09:47:58] <ipc> hrm
[09:48:47] <ipc> I was a little annoyed that I couldn't declare top-level array of enums but that got fixed in the very next version after I had that problem (0.5?)
[09:49:31] <ipc> the networking and how effeciently it works with the tasks will be important to me
[09:50:24] <ipc> (latency is more important than throughput for me)
[09:52:26] <smvv> ipc: fwiw: there are zeromq bindings :)
[09:52:27] <bjz> I think the networking/io will be able to worked on more now we have the new runtime/schedualer
[09:53:07] <Seldaek> ipc: the new io (currently in master as std::rt::io, but will be available by default in 0.8) is a lot faster for networking than it used to be
[09:53:09] <ipc> are tasks pinned to OS threads or can they be moved?
[09:53:11] <bjz> ipc: I'm not to knowledgable on that front though
[09:53:22] *** Joins: maikklein2 (maik@moz-BFE8F4AD.dip0.t-ipconnect.de)
[09:53:24] <bjz> Seldaek: oh cool
[09:54:00] <ipc> that's cool Seldaek, I'll have to check that out
[09:54:03] <Seldaek> I upgraded some code and got a decent free speed boost, though I'm not sure how much because I didn't have the old rust to measure anymore
[09:54:30] <Seldaek> but the old one was really bad :)
[09:54:51] * bjz wonders if better io will affect compilation speed
[09:54:55] <Seldaek> hopefully the new one isn't at optimal speed either..
[09:55:30] <Seldaek> bjz: there's still no filesystem io in newrt though, but yeah that'd be nice.
[09:55:37] <ipc> io is slow enough on its own; anything you do to speed it up is greatly appreciated :)
[09:57:01] *** Quits: bjz (brendanzab@B398BE78.F804C29E.D35A31DF.IP) (Ping timeout)
[09:57:09] *** Joins: bjz (brendanzab@B398BE78.F804C29E.D35A31DF.IP)
[09:57:32] <ipc> do you know how the GC is coming along?
[09:57:39] *** Quits: recrack (Mibbit@B4104EBB.3CC170B1.1E14B209.IP) (Quit: http://www.mibbit.com ajax IRC Client)
[09:58:03] <bjz> ipc: I know there are plans of libifying it
[09:58:05] *** Quits: dwhyte (dwhyte@1922756A.EDC594B0.7BF4A4B0.IP) (Quit: Leaving.)
[09:58:32] <ipc> to make it available to C/C++?
[09:58:44] *** Joins: orshem (orshem@C5E06B1E.A5B6B765.E3D28531.IP)
[09:58:50] <bjz> ipc: no, so it's pluggable in rust programs
[09:58:53] <ipc> ah
[09:58:57] <ipc> that makes more sense
[09:59:18] <bjz> ipc: apparently servo is starting to use a few different GC strategies
[10:00:00] <bjz> ipc: It'd be much easier to access them if there was inbuilt support for pluggable GC in the compiler
[10:00:18] <ipc> are you on the BitC mailing list?  There's been a lot of GC discussion over there along with Rust memory management 
[10:00:24] <bjz> no
[10:00:28] <bjz> link?
[10:00:33] <Ms2ger> Pointers are hard
[10:00:41] <bjz> I'd be interested in looking at it
[10:00:47] <Ms2ger> Especially since Rust has about 42 kinds ;)
[10:01:00] <ipc> http://www.bitc-lang.org/ http://www.coyotos.org/pipermail/bitc-dev/
[10:01:01] <bjz> Ms2ger: err, no, noit really
[10:02:04] <bjz> Ms2ger: it's the same concepts that are in C/C++, it's just you can be more explicit about the behaviour
[10:02:20] <ipc> the discussions recently have been on reviving the project and what the new runtime should look like
[10:02:41] <bjz> Ms2ger: and because your giving the compiler more information, it can automate things and throw an error if you're doing something wrong
[10:02:46] <ipc> someone suggested forking Rust so that's how Rust came into the discussion
[10:02:49] <bjz> ipc: cheers
[10:03:02] <bjz> ipc: heh, wut
[10:03:30] <bjz> interesting!
[10:04:20] <bjz> ipc: updates on the home page are from 2010 though :(
[10:04:36] <ipc> BitC shares Rust's "better, type safe, modern systems language" approach but differs in some of the details; Jonathan Shapiro is the principal there and he stopped working on it when he went to work at Microsoft
[10:04:46] *** Joins: ab (alex@BC9D99CC.37C1012D.FE617B51.IP)
[10:04:51] <orshem> from my experience there are only two pointers that matter and they don't overlap and work very well ~ and &
[10:04:53] <ipc> now that he's unencumbered he's looking at picking it back up
[10:05:24] <orshem> * is raw pointer when you need to do terrible things  :) (unsafe)
[10:05:35] <ipc> terribleâ€¦ or awesome!
[10:05:36] <ipc> :)
[10:05:41] <ldunn> terribly awesome
[10:05:45] <ipc> indeed
[10:05:49] <ldunn> (or awesomely terrible, as the case may be)
[10:06:28] <orshem> :)
[10:06:40] <orshem> i really like rust
[10:06:47] <bjz> orshem: which basically gives you a feeling of what it's like to program in C every time you use them
[10:07:47] <bjz> orshem: makes you realise how nice it is to have a type system helping you out on the lifetime front
[10:08:33] *** Quits: KindOne (KindOne@moz-983E660C.dynamic.ip.windstream.net) (Ping timeout)
[10:09:06] <orshem> bjz: sure thing. though i'll own to have no professional experience in c at all 
[10:09:26] <bjz> orshem: not a great deal here either
[10:09:51] <bjz> orshem: but doing rust has certainly helped with my understanding of C pointers
[10:10:01] *** Joins: mike (Mibbit@moz-11F9F15.red-83-37-58.dynamicip.rima-tde.net)
[10:10:03] *** Joins: lucian (lucian@6B2B4644.4304AE1E.CE5E78F6.IP)
[10:10:07] *** Quits: dcolish (dcolish@1DB472A5.BE69FB10.416A0103.IP) (Ping timeout)
[10:10:39] <mike> Hi, I can't install rust-sdl in my windows xp, because the readme says to write make but isn't a command
[10:10:46] <orshem> bjz: you also have loads more experience with rust than i do :) but the funny thing is rust helps me understand c++ more
[10:10:50] *** Joins: KindOne (KindOne@moz-983E660C.dynamic.ip.windstream.net)
[10:10:54] <ipc> Ms2ger: I think the hard part is keeping a whole-program picture of your memory usage in your head.  Where's this memory coming from, how long will it be active?  Should I just pass a copy here or a reference?  I think that's where a lot of 'pointers are hard' thinking comes from and not so much manipulating pointers arithmetically and what not
[10:10:59] <orshem> i took a course on it, looked at boost and such and gave up
[10:11:32] <orshem> but suddenly stuff start to make sense :)
[10:12:03] <mike> any idea?
[10:12:09] <bjz> ipc: hehe: http://www.coyotos.org/pipermail/bitc-dev/2013-July/003737.html
[10:12:11] *** Joins: BizarreCake (BizarreCak@moz-361FE9B2.dynamic.barak-online.net)
[10:13:03] <bjz> orshem: boost will do that to you (as much as I think it's awesome)
[10:13:43] *** Joins: dcolish (dcolish@1DB472A5.BE69FB10.416A0103.IP)
[10:14:04] *** Quits: mike (Mibbit@moz-11F9F15.red-83-37-58.dynamicip.rima-tde.net) (Quit: http://www.mibbit.com ajax IRC Client)
[10:14:25] <ipc> bjz: see?  good stuff there.  Shap is extremely smart and opinionated which is a great combo in someone you want to listen to :)
[10:14:31] <darkf> you can't overload the "getitem" operator ([]), can you? I want a nice way to access say maps like a["b"]
[10:14:40] <orshem> ipc: but not very polite :)
[10:14:50] <ipc> we all have our quirks
[10:15:06] <bjz> ipc: it's almost like C pointers are dynamically typed if you look at them from a linear point of view. though I don't know if that stacks up formally
[10:15:16] <bjz> ipc: I'm not a type theorist
[10:15:26] *** Quits: dcolish (dcolish@1DB472A5.BE69FB10.416A0103.IP) (Ping timeout)
[10:15:30] <bjz> darkf: the Index trait
[10:15:35] <bjz> in std::ops
[10:15:55] <bjz> it's pretty crumy though - there is discussion on how to improve it.
[10:16:14] *** Joins: dcolish (dcolish@1DB472A5.BE69FB10.416A0103.IP)
[10:16:19] *** Quits: maikklein2 (maik@moz-BFE8F4AD.dip0.t-ipconnect.de) (Ping timeout)
[10:17:11] <darkf> bjz: thanks. that _is_ weird though, it takes an &Index as a paremter. heh
[10:17:16] <ipc> mike: did you find what you needed?  I don't know about Windows-support with Rust in particular but if you need make on Windows you need to install cygwin or mingw
[10:17:37] <orshem> cmr: ping
[10:18:14] *** Quits: james4k (james@moz-E7990244.consolidated.net) (Ping timeout)
[10:18:18] <darkf> bjz: would casting it with `index as &str` work, you think?
[10:19:29] <ipc> bjz: for fun with systems programming and types check out http://www.ats-lang.org/EXAMPLE/#FIBONACCIexample
[10:19:49] <ipc> nothing like having a prover built into your compiler :)
[10:20:07] *** Quits: Home (chatzilla@moz-6FB35D32.dynamic.isp.telekom.rs) (Ping timeout)
[10:20:17] *** Joins: ghrust (ghrust@AC22872E.6A2AE50.F3114085.IP)
[10:20:17] <ghrust> 01[13rust01] 15bors 04force-pushed 06auto from 14de2f128 to 144da1cfe: 02http://git.io/N3iJvQ
[10:20:17] *** Parts: ghrust (ghrust@AC22872E.6A2AE50.F3114085.IP) ()
[10:20:17] <bjz> ipc: aye, ATS is known around here
[10:20:19] *** Joins: ghrust (ghrust@AC22872E.6A2AE50.F3114085.IP)
[10:20:19] <ghrust> 01[13rust01] 15bors pushed 2 new commits to 06auto: 02http://git.io/rOywog
[10:20:19] <ghrust> 13rust/06auto 148805baa 15Alex Crichton: Add some documentation about globals in ffi docs
[10:20:19] <ghrust> 13rust/06auto 14c9ec808 15bors: auto merge of #8322 : alexcrichton/rust/ffi-dox, r=thestinger...
[10:20:20] *** Parts: ghrust (ghrust@AC22872E.6A2AE50.F3114085.IP) ()
[10:20:27] *** Quits: jensnockert (jensnocker@moz-131195AC.mobileonline.telia.com) (Input/output error)
[10:20:28] *** Joins: maikklein2 (maik@moz-BFE8F4AD.dip0.t-ipconnect.de)
[10:20:45] <bjz> ipc: apparently it's much more flexible than Rust, but that does come at a price
[10:20:53] *** Quits: dmi3y (dmi3y@9FD26F63.6075981B.B8FD5DE3.IP) (Quit: My MacBook Pro has gone to sleep. ZZZzzzâ€¦)
[10:20:54] *** Joins: jensnockert (jensnocker@moz-131195AC.mobileonline.telia.com)
[10:21:02] *** Quits: thomaslee (thomaslee@moz-306D3DF4.hsd1.or.comcast.net) (Client exited)
[10:21:03] *** Quits: jensnockert (jensnocker@moz-131195AC.mobileonline.telia.com) (Connection reset by peer)
[10:21:53] <ipc> I haven't done anything even demo quality with ATS, just worked through the examples and played around.
[10:23:11] <ipc> Rust, ATS, and BitC are the languages I'm most interested inâ€¦ something that could replace C++ in many cases.  Of those only Rust is near a point I consider usable.
[10:24:58] <Ralith> ipc: you might be interested in Idris once it gets some more work on performance.
[10:25:28] <ipc> Ralith: I'll check it out; I don't know about Idris
[10:26:26] <Ralith> ipc: if ATS is SML, Idris is Haskell
[10:26:31] <Ralith> or something
[10:26:58] <Ralith> they don't actually have any direct connection, mind, just related type theories
[10:28:30] <ipc> Ralith: reading about it now
[10:29:04] <Ralith> (and related motivations)
[10:29:33] <bjz> Ralith: how close do you think you can get idris to C?
[10:29:41] <bjz> Ralith: realisticly?
[10:29:54] <bjz> Ralith: that is, in terms of speed
[10:30:05] <darkf> hrm yeah I don't think Index can take a &'a T
[10:30:24] <bjz> darkf: as I say, it needs to be redone
[10:30:35] <darkf> indeed
[10:30:36] *** Joins: doomlord (doomlod@moz-13E69BC8.range86-180.btcentralplus.com)
[10:31:04] *** Quits: maikklein2 (maik@moz-BFE8F4AD.dip0.t-ipconnect.de) (Ping timeout)
[10:31:29] <Ralith> bjz: my medium-term goal is that Idris code that does not hit memory hard and that is written like C (monomorphic, simple and/or primitive types) should perform close to C. I expect that much is achievable; I don't think anyone knows how easy or hard going beyond that will be precisely.
[10:31:44] <bjz> ipc: Rust certainly isn't perfect, but it has the advantage of momentum
[10:32:00] *** Quits: thesnowdog (doug@94FEF15E.9D0B7490.6F17036B.IP) (Connection reset by peer)
[10:32:14] <bjz> Ralith: yeah, it would be difficult to tell
[10:32:25] <bjz> Ralith: but you think you can beat haskell?
[10:32:37] <Ralith> bjz: in theory, monomorphization a la rust, general unboxing, and partial evaluation will allow us to do very remarkable things.
[10:32:47] *** Joins: thesnowdog (doug@94FEF15E.9D0B7490.6F17036B.IP)
[10:33:04] <Ralith> bjz: beating haskell isn't inherently hard except in that GHC has had extensive work done on it by very smart people.
[10:33:16] <Ralith> so, eventually, sure
[10:33:30] <bjz> Ralith: it's the same as Rust vs C and C++ I guess
[10:33:32] <Ralith> Idris is strict by default so it's much easier to reason about performance, which should help.
[10:33:48] <bjz> Ralith: oh nice, that is a big win
[10:34:20] <bjz> well, ofc a trade off
[10:34:31] *** Joins: Haxkerl (Mibbit@7F47211E.1FC9A5BE.CAD5678C.IP)
[10:34:34] <ipc> Ralith: cool, thanks for pointing out Idris.  its not targeting systems programming but has a usable foreign function interface.  the whole eager Agda+Haskell thing would be cool for some other kinds of applications
[10:34:37] <bjz> but for real time applications, that should be great
[10:34:57] *** Joins: jensnockert (jensnocker@moz-131195AC.mobileonline.telia.com)
[10:35:03] <Ralith> bjz: I've heard tell that even SPJ doesn't think laziness is necessarily the right way to go anymore, so I'm pretty confident in the decision.
[10:35:03] <Haxkerl> rusti:
[10:35:03] -rusti- ()
[10:35:18] <Haxkerl> T
[10:35:27] *** Quits: thesnowdog (doug@94FEF15E.9D0B7490.6F17036B.IP) (Ping timeout)
[10:35:31] <Haxkerl> rusti: null
[10:35:31] -rusti- <anon>:5:9: 5:13 error: unresolved name `null`.
[10:35:31] -rusti- <anon>:5          null
[10:35:31] -rusti-                   ^~~~
[10:35:32] -rusti- error: aborting due to previous error
[10:35:32] -rusti- application terminated with error code 101
[10:35:32] <Ralith> ipc: it is targeting systems programming, actually, just not direct programming of systems where you need precise control over memory.
[10:36:00] <Ralith> ipc: it used to say as much on the homepage until edwinb took it down due to too many semantic arguments :p
[10:36:20] <Haxkerl> rusti: 2**5
[10:36:20] -rusti- <anon>:5:11: 5:13 error: type <VI1> cannot be dereferenced
[10:36:20] -rusti- <anon>:5          2**5
[10:36:20] -rusti-                     ^~
[10:36:20] -rusti- error: aborting due to previous error
[10:36:21] -rusti- application terminated with error code 101
[10:36:35] <Ralith> ipc: it's much less further along than rust, of course.
[10:36:42] <Ralith> less far along*
[10:36:47] <ipc> Ralith:really? they're self-described as 'general purpose' and don't have normal data types that map to registers (or did I miss something in my speed-read?)
[10:36:51] <Haxkerl> What is the exponential notation in Rust?
[10:37:50] <Ralith> ipc: I'm not sure what you mean by "normal data types." Idris has various primitive types which happen to be trivially representable in x86 registers, as well as many other kinds of types.
[10:38:31] <ipc> Ralith: int32 utint32 int64 uint64 etc vs just 'Int'
[10:38:37] <Ralith> ipc: yes.
[10:38:52] <Ralith> perhaps you are not actually looking at a comprehensive list of primitive types?
[10:38:57] <Haxkerl> rusti: let fuck=5; let shit=6; let ass=if fuck+shit<13 {7} else {0};
[10:38:58] -rusti- <anon>:5:37: 5:40 warning: unused variable: `ass` [-W unused-variable (default)]
[10:38:58] -rusti- <anon>:5          let fuck=5; let shit=6; let ass=if fuck+shit<13 {7} else {0};
[10:38:58] -rusti-                                               ^~~
[10:38:59] -rusti- ()
[10:39:09] <ipc> I was looking at: http://eb.host.cs.st-andrews.ac.uk/writings/idris-tutorial.pdf
[10:39:24] <Ralith> that is, as the filename indicates, a tutorial.
[10:39:41] <ipc> Haxkerl, can't you use foo and bar like everyone else? :)
[10:40:04] <doublec> ipc: I've done a fair bit of ATS. It's nice for low level programming.
[10:40:10] *** Joins: maikklein2 (maik@moz-BFE8F4AD.dip0.t-ipconnect.de)
[10:40:17] <Ralith> unfortunately, we don't have comprehensive reference documentation available, but I assure you that we have a wide set of primitive types.
[10:40:44] <Haxkerl> ipc: Python tutorial uses spam and eggs.
[10:40:47] <ipc> Ralith: ok, I'll download and play with it later
[10:40:56] <doublec> Rust, ATS and Idris are the systems languages I'm most interested in
[10:41:23] <Ralith> ipc: don't get your hopes up about perf just yet though; much ground work remains to be done there.
[10:42:00] <ipc> with the new Rust Scheduler can you do something like spin up an OS thread per processor and distribute tasks to particular threads?
[10:42:17] *** Joins: maxli (maxli@B5559308.9C54E60.2FA4EA88.IP)
[10:42:54] *** Joins: thesnowdog (doug@94FEF15E.9D0B7490.6F17036B.IP)
[10:43:19] <Haxkerl> rusti: let fuck=5; let shit=11; let fuck_that_shit=5+11;
[10:43:21] -rusti- pastebinned 10 lines of output: http://sprunge.us/UOfY
[10:43:25] <SimonSapin> Modules within one crate can have dependency cycles, but not crates. Does that sound right?
[10:43:29] <dbaupp> Haxkerl: at least one person has asked that you not swear before, please can you keep the channel friendly :)
[10:43:49] <ipc> doubelc: you get used to the verbose-ness? have you used ATS2 yet?
[10:44:01] <dbaupp> SimonSapin: sounds reasonable
[10:44:18] <doublec> ipc: yes, you get used to it. I have played with ATS2 but nothing real world yet.
[10:44:22] <Haxkerl> dbaupp: I am not cursing anyone, I do that just for fun. It is also a good way to obfuscate your code.
[10:44:25] <doublec> ipc: it uses templates a lot more than ATS1.
[10:44:56] <dbaupp> Haxkerl: doesn't matter, the swearing makes some people unhappy, so if there's no need to do it, please don't
[10:45:23] <dbaupp> Haxkerl: (especially when there's perfectly good things like foo, bar, baz, and span, eggs,... )
[10:45:32] <doublec> ipc: in practice ATS is not a lot more verbose than any other ML language. Not everything requires proofs which does add to the verbosity.
[10:45:48] <bjz> Haxkerl: https://github.com/mozilla/rust/wiki/Note-development-policy#conduct
[10:46:21] <bjz> Haxkerl: I'm pretty sure you have been sent that before either today or yesterday
[10:47:06] * bjz thinks it's cool to see the movement in systems programming
[10:47:07] <doublec> ipc: most of my proof usage is around C FFI definitions to make calling into C safe
[10:47:26] *** Quits: thesnowdog (doug@94FEF15E.9D0B7490.6F17036B.IP) (Ping timeout)
[10:47:27] *** Joins: bheylin (BHeylin@moz-3D24C757.static.chello.nl)
[10:47:33] *** Quits: maikklein2 (maik@moz-BFE8F4AD.dip0.t-ipconnect.de) (Ping timeout)
[10:47:40] <doublec> ipc: and doing memory/pointer manipulation. Everything else looks like normal functional language code.
[10:48:07] <Haxkerl> Hey, how to regex a string
[10:48:13] <bjz> doublec: how does it compare to the Rust. I mean, not in a 'which one is better' kind of way. More towards how does it feel to write/read?
[10:48:23] <bjz> Haxkerl: regex is still in the works
[10:48:48] <bjz> Haxkerl: unfortunatley the best you're going to get at the moment is a wrapped C library
[10:49:08] * bjz is not sure if there is one properly maintained atm
[10:49:27] <Seldaek> not last time I checked, but then I gave up and wrote a mini state machine :)
[10:49:36] <Ralith> doublec: interesting; does ATS contain a presburger arithmetic solver?
[10:49:41] <doublec> bjz: ATS feels more like C programming as it doesn't have typeclasses or similar things. Rust feels more like Haskell style programming.
[10:50:13] <doublec> bjz: so I think Rust has more interesting abstractions, whereas ATS has more interesting ways of interacting safely with C.
[10:50:25] <bjz> doublec: So rust is more OO in a haskell kind of way?
[10:51:06] <doublec> bjz: that's my feeling, yes.
[10:51:12] <bjz> doublec: I guess the idea with Rust is that the ffi is a really good bootstrap
[10:51:19] <doublec> I've done more ATS than Rust though
[10:51:23] <bjz> doublec: but not the be-all and end-all
[10:51:45] <bjz> doublec: no, that's good, it's cool to have your perspective
[10:52:19] <bjz> (bootstrap in terms of getting to interesting projects sooner)
[10:52:29] <doublec> Ralith: yes
[10:52:34] <bjz> (as opposed to re-inventing everything)
[10:52:49] <bjz> Ralith: presburger arithmetic solver?
[10:53:05] <ipc> doublec: I read about that kind of usage at http://bluishcoder.co.nz/tags/ats/  ; seemed cool
[10:53:10] <bjz> http://en.wikipedia.org/wiki/Presburger_arithmetic?
[10:53:19] <Ralith> doublec: awesome
[10:53:44] *** Joins: maikklein2 (maik@moz-BFE8F4AD.dip0.t-ipconnect.de)
[10:53:52] <Ralith> bjz: a useful proof automation tool that helps make the sort of proofs you might see a lot of in ATS be trivially concise.
[10:54:03] <bjz> Ralith: ahh nice
[10:54:24] <bjz> too many interesting languages :( not enough life
[10:54:35] <doublec> I have some posts/examples of ATS usage at my blog: http://bluishcoder.co.nz/tags/ats/
[10:54:48] <bjz> cool, will look
[10:54:49] <doublec> oops, ipc already pointed to it :)
[10:55:04] <Ralith> idris lacks one at the moment, and for that reason writing code involving arithmetic proofs can be somewhat verbose at times
[10:55:10] <ipc> bjz: too true.   I forgot about Julia and Parasail
[10:55:11] <bjz> I think I might have seen your blog before
[10:55:38] <ipc> doublec: that's awesome; didn't know you were the author :)
[10:56:05] <ipc> doublec: thanks for sharing
[10:56:14] *** Parts: bheylin (BHeylin@moz-3D24C757.static.chello.nl) ()
[10:56:18] *** Joins: leonvv (leonvv@moz-7D83A5F1.ip.telfort.nl)
[10:56:20] <doublec> ipc: np, glad it's useful :)
[10:56:31] *** Joins: dmi3y (dmi3y@9FD26F63.6075981B.B8FD5DE3.IP)
[10:57:20] <Ralith> doublec: is "chris double" your actual name?
[10:57:25] <doublec> Ralith: yep
[10:57:26] *** Quits: mrordinaire (Mibbit@1A659656.A607747.FD383126.IP) (Quit: http://www.mibbit.com ajax IRC Client)
[10:57:28] <Ralith> that's awesome
[10:57:44] <doublec> Ralith: my blog name, bluishcoder, is an anagram :)
[10:57:51] *** Quits: Haxkerl (Mibbit@7F47211E.1FC9A5BE.CAD5678C.IP) (Quit: http://www.mibbit.com ajax IRC Client)
[10:57:59] *** Quits: jensnockert (jensnocker@moz-131195AC.mobileonline.telia.com) (Connection reset by peer)
[10:58:07] *** Joins: jensnockert (jensnocker@moz-131195AC.mobileonline.telia.com)
[10:58:22] <Ralith> nice
[10:59:10] *** Joins: sk (sk@61A494B3.BA40E8A.AAC02D62.IP)
[11:01:08] <dbaupp> :( rusti tests are causing spurious bounces again :(
[11:01:12] <dbaupp> acrichto: ^
[11:01:14] *** Joins: clonejo (clonejo@moz-CC9FD036.de)
[11:02:18] *** Joins: ghrust (ghrust@C621748.6A2AE50.F3114085.IP)
[11:02:18] <ghrust> 01[13rust01] 15bors 04force-pushed 06auto from 14c9ec808 to 144da1cfe: 02http://git.io/N3iJvQ
[11:02:18] *** Parts: ghrust (ghrust@C621748.6A2AE50.F3114085.IP) ()
[11:02:19] *** Joins: ghrust (ghrust@79968228.6A2AE50.F3114085.IP)
[11:02:19] <ghrust> 01[13rust01] 15bors pushed 3 new commits to 06auto: 02http://git.io/wREyRw
[11:02:19] <ghrust> 13rust/06auto 145f713da 15Kevin Ballard: Add std::num::Saturating...
[11:02:19] <ghrust> 13rust/06auto 143db3ce2 15Kevin Ballard: Update Iterator impls to use Saturating...
[11:02:20] <ghrust> 13rust/06auto 1454c8c23 15bors: auto merge of #8323 : kballard/rust/saturating, r=thestinger...
[11:02:22] *** Parts: ghrust (ghrust@79968228.6A2AE50.F3114085.IP) ()
[11:04:23] *** Quits: sk (sk@61A494B3.BA40E8A.AAC02D62.IP) (Connection reset by peer)
[11:07:35] *** Joins: sk (sk@61A494B3.BA40E8A.AAC02D62.IP)
[11:11:01] *** Joins: true_droid (true_droid@moz-123FD9B8.beck.volia.net)
[11:12:40] *** Quits: ipc (ipc@moz-76ED5036.lightspeed.cicril.sbcglobal.net) (Quit: ipc)
[11:13:12] *** Joins: ipc (ipc@moz-76ED5036.lightspeed.cicril.sbcglobal.net)
[11:13:33] *** Quits: a__ (a__@moz-250D9B4.nycmny.fios.verizon.net) (Client exited)
[11:14:56] <maikklein2> has anyone here some experience with sdl 1.2?
[11:14:58] <dbaupp> bjz: fwiw, I've been reading the BitC mailing list stuff you linked to, and it seems that jonathan shapiro has got the wrong impression about pcwalton's move-GC-to-libraries post. :(
[11:15:15] <bjz> dbaupp: I posted it as a discussion point
[11:15:23] *** Joins: a__ (a__@moz-250D9B4.nycmny.fios.verizon.net)
[11:15:35] *** Joins: thesnowdog (doug@94FEF15E.9D0B7490.6F17036B.IP)
[11:16:25] <dbaupp> bjz: I know :)
[11:16:34] <bjz> :)
[11:17:19] <dbaupp> it just seems that many of his objections are grounded in misunderstanding (it could also be that I don't understand enough to fully grasp what he's saying.)
[11:17:20] <bjz> is there a way to go directly from a &[u8] to a c string?
[11:17:31] <bjz> dbaupp: mm
[11:17:40] *** Joins: SiegeLord (sl@moz-CAF07B4C.hsd1.ma.comcast.net)
[11:18:08] <dbaupp> bjz: do you know it has a null terminator already?
[11:18:15] *** Quits: thesnowdog (doug@94FEF15E.9D0B7490.6F17036B.IP) (Ping timeout)
[11:18:15] <bjz> dbaupp: anyway, hopefully it will expose people to some discussions on the BitC ML. Apparently they've had a few
[11:18:41] <dbaupp> bjz: because .as_imm_buf (or .as_mut_buf, if you want mutability) gives you a *u8
[11:18:55] <bjz> no, I don't
[11:19:21] *** Quits: a__ (a__@moz-250D9B4.nycmny.fios.verizon.net) (Client exited)
[11:20:16] <dbaupp> oh. then you'll need .to_owned(), and .push(0)
[11:20:27] <dbaupp> I don't think there's a way built in atm
[11:21:02] <bjz> atm I'm doing: from_bytes(xml_data).as_c_str
[11:21:17] <bjz> and the data is relatively large
[11:21:33] *** Joins: thesnowdog (doug@94FEF15E.9D0B7490.6F17036B.IP)
[11:21:38] <bjz> I need to hand it off to a C lib
[11:22:05] <bjz> large = 2.2mb
[11:22:11] <bjz> :P
[11:22:46] <bjz> not massive, but sizable
[11:23:01] <dbaupp> mm, yeah, I imagine just handling [u8] would be faster
[11:23:16] <dbaupp> (assuming that it's actually a valid c string, with no internal nulls, etc.)
[11:23:57] <dbaupp> so let mut xml_data = xml_data.to_owned(); xml_data.push(0); do xml_data.as_imm_buf |p, _| { whatever(p) }
[11:24:13] *** Quits: thesnowdog (doug@94FEF15E.9D0B7490.6F17036B.IP) (Ping timeout)
[11:24:20] <bjz> can you get a str directly from a file reader?
[11:24:38] <bjz> maybe that would be a better way
[11:24:47] <dbaupp> yeah
[11:25:03] <dbaupp> There's presumably a utility method on ReaderUtil
[11:26:35] <bjz> I was using read_whole_stream
[11:27:08] <bjz> there is a read_c_str
[11:27:30] <dbaupp> that just stops at the first null. so not necessarily what you want, but presumably it'd work.
[11:27:35] <bjz> would a .xml be null terminated?
[11:27:45] <bjz> *an
[11:28:20] <dbaupp> the file itself will be EOF-terminated
[11:28:22] *** Joins: thesnowdog (doug@94FEF15E.9D0B7490.6F17036B.IP)
[11:28:22] <dbaupp> :P
[11:28:31] <bjz> ahh, true
[11:28:35] <dbaupp> (and presumably .read_c_str will stop there.)
[11:28:50] <bjz> but EOF != null
[11:29:06] <dbaupp> and, I guess it'll contain no nulls, so that will get you the whole file as a string.
[11:29:30] *** Quits: maxli (maxli@B5559308.9C54E60.2FA4EA88.IP) (Quit: Leaving.)
[11:29:44] *** Quits: SiegeLord (sl@moz-CAF07B4C.hsd1.ma.comcast.net) (Quit: It's a joke, it's all a joke.)
[11:30:00] <bjz> ok, I will use that for now :/
[11:30:12] <dbaupp> yeah, suboptimal :(
[11:30:29] <dbaupp> .read_whole_stream(); .push(0) would work too, though.
[11:31:02] *** Quits: thesnowdog (doug@94FEF15E.9D0B7490.6F17036B.IP) (Ping timeout)
[11:31:04] *** Joins: DoomBoom (DoomBoom@6B14631A.ACEC7723.5D1D3FEF.IP)
[11:31:17] <ipc> dbaupp: re: shape and rust and GC: the impression I was left with was that no one understood the particular motivation in Rust for having managed+unmanaged code and what the Rust principal's thought of GC
[11:32:27] <ipc> dbauppp: more info from pcwalton or graydon would probably be helpful (or whoever knows the Rust GC motivations best)
[11:32:53] <bjz> ipc: hopefully pcwalton will reply on the reddit post
[11:33:03] <ipc> personally, I like GC-as-a-service with plugable collection strategies
[11:33:11] <bjz> http://www.reddit.com/r/rust/comments/1jvhxq/bitcdev_rust_gc_and_language_politics/
[11:33:55] <bjz> ipc: I think it's good preactice in general to make things pluggable, and move them out of the compiler
[11:34:04] <ipc> probably because I've never seen it done before and it hits the sweet spot for me (use it when you need it, choose between soft and hard real-time hopefully)
[11:34:17] *** Joins: thesnowdog (doug@94FEF15E.9D0B7490.6F17036B.IP)
[11:34:42] <dbaupp> ipc: I think the main motivation for unmanaged code is "it's not necessary, so why require it *by default*" (or something along those lines)
[11:34:48] <bjz> yup
[11:35:02] <dbaupp> (and GC is infectious: once a single piece of code uses it, you can't escape it.)
[11:35:03] <bjz> it was more of a thing that emerged through the use of the language
[11:35:08] <bjz> yeah
[11:35:25] <bjz> that lesson was learned with rustc
[11:35:29] <bjz> and the libs
[11:35:59] <ipc> yeah, I think the counter argument is a safety concern: once you allow unmanaged code you open yourself to security and stability issues
[11:36:11] <ipc> but if you permit unsafe to begin with, you kind of have to, right?
[11:36:49] *** Joins: Home (chatzilla@moz-6FB35D32.dynamic.isp.telekom.rs)
[11:36:51] <bjz> ipc: that's the whole point of linear type though, isn't it?
[11:36:55] <bjz> *types
[11:36:59] <dbaupp> except, most of the point of rust is safe unmanaged code
[11:37:03] *** Quits: thesnowdog (doug@94FEF15E.9D0B7490.6F17036B.IP) (Ping timeout)
[11:37:04] <bjz> ipc: and regions
[11:37:16] <bjz> ipc: safe, manual memory management
[11:37:23] <bjz> without GC
[11:39:13] <ipc> agreed.  I have applications where i have to ensure that allocations only happen at certain times (even malloc) so I'm on board with the most helpful unmanaged route
[11:39:45] *** Joins: thesnowdog (doug@94FEF15E.9D0B7490.6F17036B.IP)
[11:40:34] <ipc> shape's explicitly said my use case wasn't a priority (automated trading systems)
[11:40:43] <bjz> hah
[11:40:49] <bjz> games?
[11:41:09] *** Joins: diegoyam (quassel@FF9B1514.A4EC3D18.3A1EC144.IP)
[11:41:23] *** Quits: z0w0 (zack@moz-E12708D5.lns6.woo.bigpond.net.au) (Client exited)
[11:41:42] <ipc> (autocorrect is turning 'shap' into 'shape' all the time *sigh*)
[11:41:43] <bjz> ipc: who is he targeting?
[11:41:49] <bjz> haha
[11:41:50] <ipc> everyone but me :)
[11:41:53] <ipc> jk
[11:42:25] <doomlord_> what is "CStore" in librustc ?
[11:42:42] <dbaupp> doomlord_: in rustc::metadata
[11:42:51] <dbaupp> ?
[11:43:46] *** Quits: thesnowdog (doug@94FEF15E.9D0B7490.6F17036B.IP) (Ping timeout)
[11:43:52] <doomlord_> yes, will i need this for resolving definitions of things outside of the current crate in a session
[11:44:31] <dbaupp> I think cstore == crate store
[11:44:50] <dbaupp> (have you looked at the code in rustdoc_ng that does this sort of stuff?)
[11:45:06] *** Joins: thesnowdog (doug@94FEF15E.9D0B7490.6F17036B.IP)
[11:45:07] <doomlord_> i'll take a look now..
[11:45:17] <dbaupp> ipc: have you had your buildbot question answered, btw?
[11:45:17] *** Joins: donri (dag@moz-9BB61102.tbcn.telia.com)
[11:45:35] *** Quits: jensnockert (jensnocker@moz-131195AC.mobileonline.telia.com) (Input/output error)
[11:46:06] *** Joins: jensnockert (jensnocker@moz-131195AC.mobileonline.telia.com)
[11:46:08] <ipc> bjz: this thread was good for figuring out the target audience: http://www.coyotos.org/pipermail/bitc-dev/2013-July/003740.html
[11:46:29] <ipc> dbaupp: I didn't get a chance to ask it; no one was awake :)
[11:47:07] <bjz> ipc: sounds like the definition the Go fellows were going off
[11:47:28] <dbaupp> ipc: ask it here then, afaict, the rust set up is relatively similar to the servo one :)
[11:47:40] <bjz> ipc: they seem to have moved away from that definition though
[11:47:46] *** Quits: jensnockert (jensnocker@moz-131195AC.mobileonline.telia.com) (Ping timeout)
[11:47:46] *** Quits: thesnowdog (doug@94FEF15E.9D0B7490.6F17036B.IP) (Ping timeout)
[11:47:55] <doomlord_> i've got an html rust source browser working, but it only works within the current crate
[11:47:59] <ipc> I don't know why I don't consider Go more.  there's just something I don't like but can't articulate
[11:48:08] <bjz> ipc: (from reading the first message though, will have to read further)
[11:48:42] * dbaupp doesn't understand how Rust doesn't satisfy shap's systems language definition too
[11:48:52] <ipc> dbaupp: it was about their specific setup: the configs here https://github.com/brson/servo-buildbot don't seem to match the buildbot here: http://servo-buildbot.pub.build.mozilla.org/
[11:49:25] <ipc> I wanted to duplicate the buildbot myself in an effort to learn buildbot and keep some open-source projects always built for myself 
[11:49:42] *** Joins: msingle (Thunderbir@moz-930E5D97.hr.hr.cox.net)
[11:49:44] <bjz> Rust could be seen as a comprehensive DSL for close-to-the metal systems programming
[11:49:47] <dbaupp> ipc: aha, I imagine it's just something that got out of sync
[11:49:55] <bjz> less of a general purpose lang
[11:50:01] *** Joins: gits1225 (gits@5964E44F.18CB2BDE.A2DC32D.IP)
[11:51:00] * dbaupp sees it more as Python-with-more-control+speed
[11:51:13] <dbaupp> (oh, and Haskell too.)
[11:51:44] *** Quits: leonvv (leonvv@moz-7D83A5F1.ip.telfort.nl) (Client exited)
[11:53:21] <bjz> dbaupp: but whilst rust can be declarative at times, that's not it's primary focus. and it kicks you into the 'how' way of thinking quite a lot
[11:55:03] <maikklein2> bjz, <3333333333
[11:55:06] <dbaupp> bjz: true
[11:55:13] <bjz> which is important for systems programming, but can be a detriment at times
[11:55:24] <bjz> depending on what you want to do
[11:55:32] <bjz> maikklein2?
[11:55:39] <maikklein2> bjz, I just started with the bullet c api and you were just 9 hours faster :(
[11:55:45] <bjz> ha
[11:55:51] <bjz> let me know how it goes
[11:56:05] <bjz> if you use it
[11:56:09] <dbaupp> bjz: but, in many ways, that's solvable with libraries (especially given (limited) type-inference and traits, etc.)
[11:56:14] <maikklein2> bjz, we would need to update the c api
[11:56:21] <bjz> maikklein2: aye
[11:56:22] <maikklein2> bjz,  seems a little less feature rich
[11:56:31] <bjz> maikklein2: shockingly so
[11:56:52] <bjz> maikklein2: it's awful that they've let it languish so badly
[11:57:07] <bjz> dbaupp: that's true
[11:57:14] <doomlord_> no demand ? main users are C++ people ?
[11:57:30] <bjz> doomlord_: :D
[11:57:49] *** Quits: ipc (ipc@moz-76ED5036.lightspeed.cicril.sbcglobal.net) (Quit: ipc)
[11:58:22] <maikklein2> yeah and most languages have c++ interop like java ,python and c#
[11:58:27] <dbaupp> bjz: I'm sure you don't need telling, but iterators are a reasonable example of libraries making things more declarative
[11:58:29] <maikklein2> not sure how good that is
[11:58:38] *** Joins: ipc (ipc@moz-76ED5036.lightspeed.cicril.sbcglobal.net)
[11:58:50] <bjz> dbaupp: yep, you are correct
[11:59:35] <bjz> dbaupp: you are kicked down into the "How" whilst implementing them, but once you're done, it allows you to forget about all that
[11:59:57] <dbaupp> bjz: yeah
[12:00:04] *** Joins: Azdle (patrick@moz-8C723B60.hsd1.mn.comcast.net)
[12:00:26] *** Joins: jensnockert (jensnocker@moz-5386F410.mobileonline.telia.com)
[12:00:26] *** Joins: infynyxx (infynyxx@moz-E95B370B.nyc.res.rr.com)
[12:00:36] <ipc> has there ever been any talk about making the implementation of something like Linq to SQL possible in the compiler?
[12:01:28] <bjz> ipc: could be done via syntax extension
[12:03:00] *** Quits: robertknight (robertknig@moz-54528EE0.wby.mendeley.com) (Ping timeout)
[12:03:05] <maikklein2> rusti: 1.5f as i16
[12:03:05] -rusti- 1
[12:03:57] <ipc> bjz: syntax extensions == macros?
[12:04:04] *** Quits: Yurume (yurume@AC58A8CE.8A059B47.E313B915.IP) (Ping timeout)
[12:04:13] *** Joins: Yurume (yurume@AC58A8CE.8A059B47.E313B915.IP)
[12:04:24] <dbaupp> ipc: yeah
[12:04:32] <bjz> ipc: but more flexible
[12:04:49] <dbaupp> ipc: (although, I asume that a more complicated one like that would require  a procedural macro, i.e. written in Rust.)
[12:04:51] <bjz> ipc: they aren't pluggable yet, but that is the plan
[12:05:09] *** Quits: infynyxx (infynyxx@moz-E95B370B.nyc.res.rr.com) (Client exited)
[12:05:24] <bjz> ipc: dbaupp knows much more than me on that front x)
[12:06:41] *** Quits: heftig (heftig@moz-88B5382A.dip0.t-ipconnect.de) (Quit: Quitting)
[12:06:49] *** Quits: jensnockert (jensnocker@moz-5386F410.mobileonline.telia.com) (Input/output error)
[12:07:16] *** Joins: jensnockert (jensnocker@moz-5386F410.mobileonline.telia.com)
[12:07:34] *** Joins: heftig (heftig@moz-88B5382A.dip0.t-ipconnect.de)
[12:08:58] *** Quits: jensnockert (jensnocker@moz-5386F410.mobileonline.telia.com) (Ping timeout)
[12:13:46] *** Joins: maxli (maxli@13F2CEC5.7672369.D8E68FF6.IP)
[12:14:32] <ipc> dbaupp: is there a fragment specifier for a utf8 string?  i.e. something that would allow the whole invocation to be handed off to some internal parser query!( from t select c ) and your input would be "from t select c" or maybe ["from", "t", "select", "c"].  where can I read more beyond http://static.rust-lang.org/doc/tutorial-macros.html ?
[12:15:39] *** Quits: maikklein2 (maik@moz-BFE8F4AD.dip0.t-ipconnect.de) (Ping timeout)
[12:16:17] <dbaupp> ipc: macros get token trees, so `query!(from t select c)` gets passed to macros as [from, t, select, c] (not quite strings)
[12:17:00] <dbaupp> ipc: (and e.g. `from t select (a + 1)` would be essentially, [from, t, select, [a, +, 1]])
[12:17:16] <dbaupp> ipc: there's not really anywhere else to read about macros unfortunately
[12:17:42] <ipc> got it
[12:18:34] *** Joins: pnkfelix (pnkfelix@moz-43495417.fbx.proxad.net)
[12:18:37] <dbaupp> ipc: (also, the macro_rules! macros only support computation-by-pattern-matching & interpolation, to do anyhting more advanced, you have to write a syntax extension, which are currently only allowed in the compiler code itself; there's plans to make them loadable at compile-time, but it's very tricky to actually do properly.)
[12:18:40] *** Quits: pnkfelix (pnkfelix@moz-43495417.fbx.proxad.net) (Input/output error)
[12:19:14] <bjz> ipc: they're still pretty second-class - you can't use them between crates
[12:19:59] *** Quits: jpf (jan@moz-A8C26A15.org) (Ping timeout)
[12:20:17] <dbaupp> (also planned to be removed, probably at the same time as procedural macros are externally loadable.)
[12:20:43] <bjz> ipc: you also don't have access to the type info because they're run before the type-checker, so you can't really use them for templatey kind of stuff
[12:22:09] *** Joins: pnkfelix (pnkfelix@moz-43495417.fbx.proxad.net)
[12:23:08] <doublec> is it possible to create shared libraries in Rust that are callable from C?
[12:23:22] *** Joins: jpf (jan@moz-A8C26A15.org)
[12:23:26] <ipc> not that I have the time to contribute it, but do you think there would be interested in a Linq-style syntax extension?  I've only used it a couple of times but it was SO much nicer than other methods of accessing a database.  http://db.inf.uni-tuebingen.de/research/ferry is something similar for Haskell
[12:24:04] <dbaupp> doublec: yes, not quire sure how.
[12:24:44] <doublec> dbaupp: i'll do some digging, thanks
[12:25:05] *** Joins: Haxkerl (Mibbit@7F47211E.1FC9A5BE.CAD5678C.IP)
[12:25:48] <Haxkerl> What is the license of the Rust compiler source code and documentation?
[12:25:49] <dbaupp> doublec: https://bitbucket.org/devin.jeanpierre/pyrite
[12:26:09] <doublec> dbaupp: thanks!
[12:26:10] *** Joins: lmandel (lmandel@moz-76CE9D51.cable.teksavvy.com)
[12:26:14] <Haxkerl> rusti:
[12:26:15] -rusti- ()
[12:26:24] <Haxkerl> What is () ?
[12:26:35] <bstrie> Haxkerl: license is dual MIT/Apache 2.0
[12:26:36] <dbaupp> Haxkerl: https://github.com/mozilla/rust/blob/master/COPYRIGHT "The Rust Project is dual-licensed under Apache 2.0 and MIT terms."
[12:26:38] <bstrie> () is null
[12:26:45] <bstrie> or rather
[12:26:47] <bstrie> nil
[12:26:55] <dbaupp> doublec: also, http://brson.github.io/2013/03/10/embedding-rust-in-ruby/
[12:26:57] <bstrie> or "unit"
[12:27:07] <bstrie> regardless, it's the type that has only a single value
[12:27:07] *** Quits: lmandel (lmandel@moz-76CE9D51.cable.teksavvy.com) (Quit: lmandel)
[12:27:48] <Haxkerl> In Python, 1 as a boolean value is true and 0 is false. What about in Rust?
[12:29:12] <doomlord_> i think it uses real bool
[12:29:15] <dbaupp> no implicit coercion between types, so there's not a direct/automatic correspondence like that
[12:29:17] <dbaupp> but:
[12:29:18] <bstrie> Haxkerl: rust is more strongly typed than python, it does not coerce ints to bools
[12:29:35] <dbaupp> rusti: (true as uint, false as uint)
[12:29:35] -rusti- (1, 0)
[12:29:51] <bstrie> unless you explicitly cast, of course
[12:30:13] <bstrie> and some of us still don't like that you can do that :P
[12:30:14] <doomlord_> i think a lot of the time one wants coersion to bool its for cases where you use option types... (check null pointer, dummy zero index ..)
[12:30:37] <dbaupp> bstrie: (the best bit is how it causes all sorts of problems! :P )
[12:31:27] <orshem> bstrie doomlord_ : it's also good for wrapping c types
[12:31:38] <orshem> c bools
[12:32:12] *** Quits: Home (chatzilla@moz-6FB35D32.dynamic.isp.telekom.rs) (Quit: ChatZilla 0.9.90.1 [Firefox 25.0a2/20130806004002])
[12:32:52] *** Joins: sw17ch (sw17ch@moz-62998E95.hfc.comcastbusiness.net)
[12:33:09] <Haxkerl> rusti: true && false
[12:33:10] -rusti- false
[12:33:56] <Haxkerl> How to do multiple assignments in one let statement?
[12:34:12] <bstrie> Haxkerl: use a tuple
[12:34:15] *** Joins: engla (engla@moz-DBD1D96E.cust.bredbandsbolaget.se)
[12:34:32] <bstrie> rusti: let (x, y) = (1, 2); y
[12:34:33] -rusti- <anon>:5:14: 5:15 warning: unused variable: `x` [-W unused-variable (default)]
[12:34:33] -rusti- <anon>:5          let (x, y) = (1, 2); y
[12:34:33] -rusti-                        ^
[12:34:33] -rusti- 2
[12:37:41] *** Joins: Florob (Florob@moz-39532932.de)
[12:41:15] <Haxkerl> How to define use-once variables of which names can be reused later?
[12:41:38] <Haxkerl> In F#: let (variables) in (use)
[12:42:08] <dbaupp> `let (variable); (use)`
[12:42:42] <Haxkerl> Can I redefine a variable?
[12:42:54] <dbaupp> yup
[12:43:35] <dbaupp> rusti: let a = "first"; println(a); let a = "second"; println(a); 
[12:43:36] -rusti- first
[12:43:36] -rusti- second
[12:43:37] -rusti- ()
[12:44:00] <dbaupp> rusti: let a = "outer"; println(a); { let a = "inner"; println(a); } println(a);
[12:44:01] -rusti- outer
[12:44:01] -rusti- inner
[12:44:01] -rusti- outer
[12:44:01] -rusti- ()
[12:44:31] *** Quits: Azdle (patrick@moz-8C723B60.hsd1.mn.comcast.net) (Ping timeout)
[12:46:23] <bjz> dbaupp: that's shadowing right?
[12:46:35] <bjz> dbaupp: will llvm optimise that out?
[12:47:09] <bjz> ie. in the first example
[12:47:11] <dbaupp> bjz: in what sense?
[12:47:27] <bjz> ie. it'd just reuse the first var
[12:47:35] <bstrie> you should get a warning if you don't use it
[12:47:35] <bjz> instead of making two
[12:47:38] <dbaupp> bjz: as far as LLVM knows, they're completely different variables, the 'a''s are just human readable convienences. (I think.)
[12:47:43] <bstrie> rusti: let a = 2; let a = 3; a
[12:47:44] -rusti- <anon>:5:13: 5:14 warning: unused variable: `a` [-W unused-variable (default)]
[12:47:44] -rusti- <anon>:5          let a = 2; let a = 3; a
[12:47:44] -rusti-                       ^
[12:47:44] -rusti- 3
[12:47:52] <bstrie> if rust can tell it's not used, llvm definitely can
[12:47:59] <bjz> heh
[12:48:54] <bjz> rusti: let a = "first"; println(a); let a = '2'; println(a.to_str());
[12:48:55] -rusti- <anon>:5:59: 5:70 error: type `char` does not implement any method in scope named `to_str`
[12:48:55] -rusti- <anon>:5          let a = "first"; println(a); let a = '2'; println(a.to_str());
[12:48:55] -rusti-                                                                     ^~~~~~~~~~~
[12:48:55] -rusti- error: aborting due to previous error
[12:48:57] -rusti- application terminated with error code 101
[12:49:03] <bjz> rusti: let a = "first"; println(a); let a = '2'; println(a);
[12:49:03] -rusti- <anon>:5:59: 5:60 error: mismatched types: expected `&str` but found `char` (expected &str but found char)
[12:49:03] -rusti- <anon>:5          let a = "first"; println(a); let a = '2'; println(a);
[12:49:04] -rusti-                                                                     ^
[12:49:05] -rusti- error: aborting due to previous error
[12:49:07] -rusti- application terminated with error code 101
[12:49:24] <bjz> rusti: let a = "first"; println(a); let a = '2'; printlnf!("%?", a);
[12:49:24] -rusti- <anon>:5:51: 5:59 error: macro undefined: 'printlnf'
[12:49:24] -rusti- <anon>:5          let a = "first"; println(a); let a = '2'; printlnf!("%?", a);
[12:49:24] -rusti-                                                             ^~~~~~~~
[12:49:25] -rusti- application terminated with error code 101
[12:49:29] <dbaupp> rusti: let a = "first"; println(a); let a = '2'; printfln!(a);
[12:49:30] -rusti- first
[12:49:30] -rusti- '2'
[12:49:30] -rusti- ()
[12:49:31] <cmr> Since LLVM uses an SSA form anyway it doesn't really matter what the name is
[12:49:35] <bjz> haha
[12:49:43] <bjz> nice
[12:49:43] <cmr> orshem: pong
[12:50:00] <bjz> dbaupp: should char impl to_str?
[12:50:41] <dbaupp> bjz: I guess so
[12:50:53] * dbaupp thought that bug had been fixed before
[12:51:36] <Haxkerl> Can I create code blocks that return values?
[12:51:50] <cmr> rusti: let x = { 123.to_str() }; x
[12:51:52] -rusti- pastebinned 35 lines of output: http://sprunge.us/GCTT
[12:51:57] <cmr> rusti: let x = { 123i.to_str() }; x
[12:51:58] -rusti- ~"123"
[12:52:11] <bstrie> Haxkerl: a block always returns the last thing inside of it, as long as there's no semicolon at the end
[12:52:20] <bstrie> anything in {} is a block
[12:52:27] <cmr> return is a bit misleading, it's just the result of the expression
[12:52:49] *** Joins: MrFahrenheit (RageOfThou@3FEF494C.29C984D5.783DEDCA.IP)
[12:53:02] <bstrie> acrichto: I'm sad that you're enabling strcat to remove .times :P
[12:53:08] <Haxkerl> bstrie: can I use the keyword "return"?
[12:53:15] <cmr> Haxkerl: no
[12:53:19] *** Joins: ghrust (ghrust@F6EE6DE3.6A2AE50.F3114085.IP)
[12:53:19] <ghrust> 01[13rust01] 15bors merged 06auto into 06master: 02http://git.io/wREyRw
[12:53:19] *** Parts: ghrust (ghrust@F6EE6DE3.6A2AE50.F3114085.IP) ()
[12:53:20] <cmr> return is always return from function
[12:53:26] <bstrie> Haxkerl: you can, but that will do an early return from the function itself, which you probably don't want
[12:54:00] <cmr> Well, yes
[12:54:40] <dbaupp> cmr: (eta on new bench data? :) )
[12:54:50] <Haxkerl> rusti: println({return "cmr: Why not?";})
[12:54:52] -rusti- pastebinned 12 lines of output: http://sprunge.us/FfTI
[12:56:18] *** Joins: ghrust (ghrust@79968228.6A2AE50.F3114085.IP)
[12:56:18] <ghrust> 01[13rust01] 15bors pushed 0 new commits to 06auto: 02http://git.io/I15XJw
[12:56:18] *** Parts: ghrust (ghrust@79968228.6A2AE50.F3114085.IP) ()
[12:56:18] *** Joins: ghrust (ghrust@AC22872E.6A2AE50.F3114085.IP)
[12:56:18] <ghrust> 01[13rust01] 15bors pushed 2 new commits to 06auto: 02http://git.io/H_Ukmw
[12:56:18] <ghrust> 13rust/06auto 14135c85e 15Do Nhat Minh: misc help message fix
[12:56:18] <ghrust> 13rust/06auto 14a40e201 15bors: auto merge of #8324 : mrordinaire/rust/misc-fix, r=alexcrichton...
[12:56:18] *** Parts: ghrust (ghrust@AC22872E.6A2AE50.F3114085.IP) ()
[12:56:28] <cmr> dbaupp: well, how can I send https://github.com/cmr/rust-bench/blob/master/task-distributor/distributor.rs#L22 across the wire and get it back from the other side?
[12:56:38] * cmr thinks someone should write extra::serialize documentation
[12:57:18] <cmr> I was using iterbytes but that is not the correct interface
[12:57:19] <bstrie> I don't understand this bitc mailing list
[12:57:22] <Haxkerl> rusti: println({let x=3; let y=5; x*y});
[12:57:23] -rusti- <anon>:5:17: 5:40 error: mismatched types: expected `&str` but found `<VI0>` (expected &str but found integral variable)
[12:57:23] -rusti- <anon>:5          println({let x=3; let y=5; x*y});
[12:57:23] -rusti-                           ^~~~~~~~~~~~~~~~~~~~~~~
[12:57:23] -rusti- error: aborting due to previous error
[12:57:23] -rusti- application terminated with error code 101
[12:57:23] <bstrie> I thought bitc was dead!
[12:57:34] <bstrie> shapiro made a whole stink about it a few years ago
[12:57:36] <dbaupp> cmr: #[deriving(Encodable, Decodable)]
[12:57:48] <Haxkerl> {let x=2; x}
[12:57:49] <dbaupp> cmr: and then black magic
[12:57:50] <dbaupp> :P
[12:58:11] <Haxkerl> rusti: {let x=0; x}
[12:58:11] -rusti- 0
[12:58:13] <dbaupp> cmr: I think it's a little awkward at the moment, because JSON and EBML are the only supported formats
[12:59:35] <dbaupp> cmr: loading https://github.com/huonw/isrustfastyet/blob/gh-pages/mem/process.rs#L77
[12:59:46] <dbaupp> cmr: writing https://github.com/huonw/isrustfastyet/blob/gh-pages/mem/process.rs#L218
[12:59:56] <cmr> dbaupp: alright, cool
[13:00:13] <cmr> dbaupp: what's up with the Encoder/Decoder interface though? It looks really weird
[13:00:22] <dbaupp> cmr: in what way?
[13:00:37] <cmr> dbaupp: it basically looks like the type visitor
[13:00:55] <dbaupp> cmr: right, it essentially is a type visitor
[13:01:05] *** Quits: LimeBurst (me@247D1419.D73964AC.27A8748.IP) (Ping timeout)
[13:01:10] *** Joins: saml (sam@moz-14C16814.cst.lightpath.net)
[13:01:33] *** Joins: jeff (jeff@moz-F81F6C4E.nyc.biz.rr.com)
[13:01:58] <Haxkerl> Can I use "break" and "continue" inside loops?
[13:02:08] <dbaupp> cmr: (I'm not qualified to say much more: I don't understand it other than how to use it at a very highlevel.)
[13:02:11] <engla> Haxkerl: you can use 'break' and 'loop' for that
[13:02:45] <Haxkerl> engla: Why is there no "continue"? What is the work-around?
[13:02:58] <cmr> Haxkerl: the loop keyword *is* "continue"
[13:03:00] <engla> Haxkerl: 'loop' is continue.
[13:03:04] <cmr> just differently-named, reuses the keyword
[13:04:18] <dbaupp> rusti: for i in range(0,3) { if i == 1 { loop } printfln!(i) }
[13:04:18] -rusti- 0
[13:04:18] -rusti- 2
[13:04:19] -rusti- ()
[13:05:39] <Florob> rusti: for i in range(0,3) { if i == 1 { loop {1} } printfln!(i) }
[13:05:39] -rusti- <anon>:5:48: 5:51 error: mismatched types: expected `()` but found `<VI3>` (expected () but found integral variable)
[13:05:39] -rusti- <anon>:5          for i in range(0,3) { if i == 1 { loop {1} } printfln!(i) }
[13:05:39] -rusti-                                                          ^~~
[13:05:40] -rusti- error: aborting due to previous error
[13:05:40] -rusti- application terminated with error code 101
[13:07:11] *** Parts: dmi3y (dmi3y@9FD26F63.6075981B.B8FD5DE3.IP) (Textual IRC Client: www.textualapp.com)
[13:09:01] *** Quits: Haxkerl (Mibbit@7F47211E.1FC9A5BE.CAD5678C.IP) (Quit: http://www.mibbit.com ajax IRC Client)
[13:10:23] *** Quits: kkris (kkris@moz-CB70009.yourvserver.net) (Quit: Coyote finally caught me)
[13:10:26] *** Joins: kkris (kkris@moz-CB70009.yourvserver.net)
[13:11:37] <Florob> Is that me or is there really no sorting function in libstd?
[13:11:56] <orshem> cmr: i want to help rustc, i found your article http://cmr.github.io/blog/2013/06/30/structure-and-organisation-of-rustc and it's great! but kind of stops in cliff hanger.. do you plan on continuing? 
[13:12:26] <cmr> orshem: Yes! I just haven't gotten around to it yet
[13:12:54] <cmr> orshem: I can do that today if you'd like
[13:13:01] * cmr didn't know anyone was using it
[13:13:03] <orshem> would love to!
[13:13:20] *** Joins: Azdle (Azdle@moz-B334B496.hfc.comcastbusiness.net)
[13:14:46] <bstrie> Florob: looks like they're in libextra
[13:15:47] <Florob> bstrie, ah, thank you. I do question that choice though...
[13:16:18] <cmr> Florob: the implementations are also really really slow
[13:19:15] *** Quits: wizeman (quassel@moz-7B7FCA15.dyn.user.ono.com) (Client exited)
[13:20:08] <dbaupp> https://github.com/mozilla/rust/pull/8305 r?
[13:20:47] <cmr> https://github.com/huonw/rust/commit/c57fde2b5f336a2364aaa6246f987adfe179834b
[13:20:49] <cmr> Whoa
[13:20:52] <cmr> Can we expand to multiple items now?
[13:20:54] *** Joins: mitja (mitja@moz-4C1E443F.clients.kiwiirc.com)
[13:21:09] <dbaupp> cmr: nope
[13:21:20] <dbaupp> cmr: it has => { { ... } }
[13:21:28] <cmr> AH
[13:21:32] <cmr> The... original doesnt?
[13:21:34] <cmr> *ah
[13:21:42] <dbaupp> (the old one didn't, so the test was actually testing everything it was supposed to.)
[13:21:47] <dbaupp> yeah
[13:22:08] * dbaupp forgot about macro limitations when he wrote it the first time
[13:22:11] *** Quits: sw17ch (sw17ch@moz-62998E95.hfc.comcastbusiness.net) (Quit: sw17ch)
[13:22:30] <doublec> dbaupp: based on your links I got this simple example working: https://github.com/doublec/rust-from-c-example
[13:23:11] <dbaupp> doublec: neat!
[13:23:23] <dbaupp> doublec: that's really simple :)
[13:23:28] * doublec now wants to use Rust in Gecko :-)
[13:23:42] <dbaupp> (also, #[no_core] doesn't do anything any more; it's just #[no_std].)
[13:23:55] <dbaupp> cmr: (thanks)
[13:24:07] <doublec> ah ok, thanks I'll update
[13:25:52] <Seldaek> doublec: very cool
[13:32:22] *** Joins: lmandel (lmandel@13F2CEC5.7672369.D8E68FF6.IP)
[13:33:44] *** Joins: thesnowdog (doug@94FEF15E.9D0B7490.6F17036B.IP)
[13:34:55] *** Joins: Haxkerl (Mibbit@7F47211E.1FC9A5BE.CAD5678C.IP)
[13:35:47] <Haxkerl> Does functional programming mean that you describe an algorithm by a chain of functions?
[13:35:54] *** Joins: ChrisMorgan (chris@moz-6AC741CA.static.tpgi.com.au)
[13:36:56] <Haxkerl> What is functional programming?
[13:37:24] <ion> I guess it refers to functions being first-class objects.
[13:38:15] <dbaupp> "functional programming is a programming paradigm that treats computation as the evaluation of mathematical functions and avoids state and mutable data"
[13:38:52] <cmr> I like how the call stack isn't considered state
[13:38:54] <dbaupp> (I guess it's a fairly nebulous word that just waves it's hands towards the Haskell, lisp, Scala groups of languages.)
[13:39:25] <Haxkerl> dbaupp: So it means you define an algorithm by a chain of functions instead of a step-by-step instruction?
[13:39:36] <dbaupp> Haxkerl: maybe?
[13:40:28] <dbaupp> Haxkerl: (but a chain of functions is step-by-step instructions too: apply f, and then apply g, and then h.)
[13:40:36] <ipc> Haxkerl: watch your definition of 'function'.  usually they mean 'pure function' which means no side-effects to be a 'purely functional language'
[13:41:23] <bstrie> Haxkerl: usually the given difference between functional and imperative is something like `range(0, 10).fold(0, |sum, n| sum+n)` and `let sum = 0; for n in range(0, 10) { sum += n; }`
[13:41:24] <ipc> but nothing can be entirely pure or you'd never get any output so there's always some (usually) strictly controlled way of achieving side effects
[13:41:29] *** Joins: rob (Mibbit@moz-11F9F15.red-83-37-58.dynamicip.rima-tde.net)
[13:41:43] <dbaupp> engla: ping
[13:41:52] <engla> dbaupp: hi
[13:42:03] <engla> I removed my comment, it was useless
[13:42:05] <engla> in case that's it
[13:42:14] <dbaupp> engla: oh, yes :)
[13:42:22] <rob> Hey guys, I have a problem, I have SDL installed in my Ubuntu, but when I try to install rust sdl doing ./configure and then make I get: rustc --cfg image --cfg mixer src/sdl.rc -o libsdl.dummy src/img.rs:67:4: 67:5 error: type `~str` does not implement any method in scope named `as_imm_buf` src/img.rs:67     }                   ^ error: aborting due to previ
[13:42:27] <rob> Any idea?
[13:42:34] * dbaupp was just going to ask for clarification
[13:42:56] <dbaupp> rob: you probably need to upgrade your rustc. (what's the output of rustc --version?)
[13:43:13] <rob> rustc 0.7 host: i686-unknown-linux-gnu
[13:43:19] <rob> I installed it today
[13:43:29] <cmr> rob: rust-sdl doesn't track rust releases, it tracks (more or less) rust master
[13:43:50] <cmr> rob: you really shouldn't use releases, they're just time-based snapshots
[13:43:52] <rob> Anyway, I installed it today, so is the lastest
[13:44:02] <dbaupp> rob: I guess the .as_imm_buf method was added after 0.7 was released
[13:44:17] <dbaupp> rob: 0.7 = snapshort of the master branch a month or so ago
[13:44:22] <dbaupp> *snapshot
[13:44:53] <rob> My console has been an hour doing a snapshot or whatever
[13:45:13] <rob> how can I fix it?
[13:45:20] <cmr> what?
[13:45:23] <cmr> are you building rustc?
[13:45:46] <rob> When I installed it I did make install and it compiled everything
[13:45:53] *** Joins: LimeBurst (me@247D1419.D73964AC.27A8748.IP)
[13:46:00] <rob> Like the tutorial says
[13:47:02] <rob> Do you understand?
[13:47:03] <Haxkerl> When will Rust reach 1.0?
[13:47:17] <cmr> Haxkerl: when it's ready
[13:47:24] <cmr> https://github.com/mozilla/rust/issues/milestones
[13:47:38] <rob> Bazinga!
[13:47:43] <bstrie> Haxkerl: sooner if you contribute :)
[13:47:46] <cmr> Not before maturity level 2, likely not until maturity level 3
[13:48:07] <rob>  joking apart, any idea?
[13:48:24] <Haxkerl> bstrie: Can I contribute without writing code?
[13:48:29] <rob> about rust-sdl
[13:48:29] <cmr> rob: Did you get the source from the tarball on the website?
[13:48:36] <cmr> (the rust source)
[13:48:44] <rob> No, from the curl url
[13:49:24] <bstrie> Haxkerl: you can write documentation, but that still involves understanding the code :)
[13:49:27] <cmr> I have no idea what you're talking about
[13:49:35] <rob> Me?
[13:49:38] <cmr> Yes
[13:49:44] <rob> curl -O http://static.rust-lang.org/dist/rust-0.7.tar.gz
[13:49:52] <rob> now?
[13:49:57] <cmr> So yes, the the tarball on the website
[13:50:00] <cmr> rob: clone from git and build that
[13:50:16] <Haxkerl> Why is the Rust compiler written in Rust? It makes it hard to compile the compiler.
[13:50:28] <bjz> :P
[13:50:28] <rob> Fuck, I'll have to wait another hour...
[13:50:33] <Seldaek> Haxkerl: but it makes it easy for rust devs to contribute to the compiler
[13:50:37] <rob> thanks anyway
[13:50:39] <Seldaek> which is a big plus
[13:50:49] <bjz> Haxkerl: it's a great test of the language too
[13:51:07] <cmr> Plus, what compiler worth its salt isn't self hosting?
[13:51:14] <bstrie> Haxkerl: because if the developers are forced to use the language, they have incentive to make the language nice to use
[13:51:23] <bjz> yup
[13:51:29] *** Joins: devinus (devinus@moz-B4AF84BC.ptr.us.xo.net)
[13:52:14] <rob> cmr: do I have to unistall the current version of rust?
[13:52:35] <cmr> rob: `make uninstall`, yes
[13:53:00] <cmr> Although I think the build system properly cleans old build artifacts, it might just be internally though
[13:53:31] <Seldaek> cmr: yeah, you have to delete old .so files after a make install if the version changed or something
[13:53:37] <dbaupp> cmr: it warns about `make install` ones, but doesn't remove them itself.
[13:53:37] <ipc> Haxkerl: http://en.wikipedia.org/wiki/Bootstrapping http://en.wikipedia.org/wiki/Eating_your_own_dog_food
[13:53:37] <Seldaek> if you didn't uninstall 
[13:54:20] *** Quits: int3_ (int3_@moz-ABE52D50.hsd1.ca.comcast.net) (Client exited)
[13:55:19] <Haxkerl> Is the Rust compiler written functionally or imperatively?
[13:55:27] *** Joins: jensnockert (jensnocker@moz-5386F410.mobileonline.telia.com)
[13:55:35] <cmr> Haxkerl: it is a large codebase that isn't written in a single style
[13:55:38] <rob> in which folder do I have to write make unistall?
[13:55:50] <cmr> rob: wherever you ran make install
[13:55:56] *** Joins: Kruppe (user@moz-E150F49F.cpe.net.cable.rogers.com)
[13:56:20] *** Joins: ghrust (ghrust@614D05BD.6A2AE50.F3114085.IP)
[13:56:20] <ghrust> 01[13rust01] 15bors 04force-pushed 06auto from 14a40e201 to 1454c8c23: 02http://git.io/N3iJvQ
[13:56:20] *** Parts: ghrust (ghrust@614D05BD.6A2AE50.F3114085.IP) ()
[13:56:21] *** Joins: ghrust (ghrust@DE823A67.6A2AE50.F3114085.IP)
[13:56:21] <ghrust> 01[13rust01] 15bors pushed 5 new commits to 06auto: 02http://git.io/J17y_Q
[13:56:21] <ghrust> 13rust/06auto 14c57fde2 15Huon Wilson: std: adjust str::test_add so that the macro expands to all 3 items (#8012)....
[13:56:21] <ghrust> 13rust/06auto 141016e8b 15Huon Wilson: testsuite: remove 2 very outdated testcases; functionality is tested by other class-*.rs tests....
[13:56:22] <ghrust> 13rust/06auto 14e5fb4c4 15Huon Wilson: testsuite: remove incorrect section of 2 test cases. (Also, &const is disappearing.)...
[13:56:24] *** Parts: ghrust (ghrust@DE823A67.6A2AE50.F3114085.IP) ()
[13:56:41] <rob> I did it but it says that there is not a rule to build the object unistall
[13:57:12] <cmr> you've made that typo twice, are you sure you're not making it in the invokation?
[13:57:22] <Haxkerl> cmr: Which parts are functional, which parts are imperative?
[13:57:34] <cmr> Haxkerl: None of it is written in a single style.
[13:58:05] <rob> robert@robertmac:~/rust-0.7$ make unistall cfg: build triple i686-unknown-linux-gnu cfg: host triples i686-unknown-linux-gnu cfg: target triples i686-unknown-linux-gnu cfg: host for i686-unknown-linux-gnu is i386 cfg: os for i686-unknown-linux-gnu is unknown-linux-gnu cfg: using gcc cfg: no pandoc found, omitting docs cfg: no llnextgen found, omitting grammar
[13:58:12] <cmr> rob: uninstall
[13:58:14] <cmr> with an n
[13:59:01] <ipc> ok folks, I'm outta here. have a good day.
[13:59:38] *** Quits: ipc (ipc@moz-76ED5036.lightspeed.cicril.sbcglobal.net) (Quit: ipc)
[13:59:39] <dbaupp> Haxkerl: most of it is in "imperative style", but it's *not* a good example of idiomatic Rust code.
[13:59:50] <Haxkerl> Is there an interactive interpreter in the tarball?
[14:00:34] <cmr> Haxkerl: not one worth using
[14:01:00] <rob> I get cfg: build triple i686-unknown-linux-gnu cfg: host triples i686-unknown-linux-gnu cfg: target triples i686-unknown-linux-gnu cfg: host for i686-unknown-linux-gnu is i386
[14:01:01] <rob> cfg: os for i686-unknown-linux-gnu is unknown-linux-gnu cfg: using gcc cfg: no pandoc found, omitting docs cfg: no llnextgen found, omitting grammar-verification cfg: no pandoc found, omitting library doc build cfg: including install rules
[14:01:07] *** Joins: jedestep (jedestep@34641662.FB4DE631.66C78B76.IP)
[14:01:19] <dbaupp> rob: and then it quits?
[14:01:34] *** Joins: strcat (strcat@moz-54F7FD49.cpe.net.cable.rogers.com)
[14:01:41] <rob> now rustc doesn't exists, I think is uninstalled
[14:01:44] <rob> isn't it?
[14:01:53] <Haxkerl> So where is the software that rusti uses on this channel?
[14:02:19] <strcat> https://github.com/thestinger/playpen
[14:02:24] *** Joins: hjr3 (hradtke@1A0AE795.28A5F6C3.A2D40ED2.IP)
[14:02:28] <dbaupp> rob: yeah, if `make uninstall` is silent other than the cfg: lines, then it worked
[14:02:38] <cmr> Haxkerl: it just uses rustc and a template that it inserts the entered code into
[14:03:53] *** Quits: Haxkerl (Mibbit@7F47211E.1FC9A5BE.CAD5678C.IP) (Quit: http://www.mibbit.com ajax IRC Client)
[14:05:33] <orshem> does rust have binary literals? something similar to 0000_0100b?
[14:05:42] <cmr> rusti: 0b0000_0100
[14:05:43] -rusti- 4
[14:05:52] <orshem> cool!
[14:05:55] <orshem> thanks
[14:05:59] *** Quits: jeff (jeff@moz-F81F6C4E.nyc.biz.rr.com) (Quit: jeff)
[14:06:54] *** Joins: jeff (jeff@moz-F81F6C4E.nyc.biz.rr.com)
[14:08:38] <rob> I try to install it but it says that doesn't exist the file config.mk
[14:08:49] <cmr> rob: you need to run the configure script
[14:08:49] *** Quits: Florob (Florob@moz-39532932.de) (Client exited)
[14:09:42] <rob> configure: --enable-targets=x86,x86_64,arm,mips --enable-optimized --enable-assertions --disable-docs --enable-bindings=none --build=i686-unknown-linux-gnu                         --host=i686-unknown-linux-gnu --target=i686-unknown-linux-gnu --with-python=/usr/bin/python2.7 ./configure: 923: ./configure: /home/robert/rust-master/src/llvm/configure: not found
[14:09:43] <rob> configure: error: LLVM
[14:09:49] <rob> when I do configure
[14:10:08] *** Joins: Florob (Florob@moz-39532932.de)
[14:11:18] <rob> ideas?
[14:12:35] *** Quits: rob (Mibbit@moz-11F9F15.red-83-37-58.dynamicip.rima-tde.net) (Quit: http://www.mibbit.com ajax IRC Client)
[14:12:49] <orshem> how do i fulfill send?
[14:13:10] <cmr> orshem: no borrowed or managed pointers
[14:13:30] <cmr> only values and owned pointers
[14:13:32] <orshem> and then it fulfills it automatically?
[14:13:36] <dbaupp> yes
[14:13:40] <orshem> how about rcmut?
[14:13:52] <orshem> no good i guess
[14:13:56] <orshem> oof
[14:15:51] <engla> RcMut is explicitly not send
[14:16:39] *** Joins: mudkip (Mibbit@BBE7C46A.B4F11D08.8612FA94.IP)
[14:17:30] <orshem> engla, so i've  now seen :(
[14:17:31] *** Joins: recrack (Mibbit@B4104EBB.3CC170B1.1E14B209.IP)
[14:17:32] <orshem> how can i create cycle in rust? any idea?
[14:17:43] <mudkip> is there any way to send a sigkill to a given pid? i.e. without a process struct to destroy?
[14:17:53] *** Joins: erickt (Adium@49C4075F.3AC15C18.2321E71E.IP)
[14:17:54] <orshem> a tree like structure with cycles
[14:17:56] <cmr> orshem: you need to use managed boxes
[14:18:07] <cmr> they are the only type that allows cycles
[14:18:21] <cmr> mudkip: libc::kill ?
[14:18:26] <orshem> so this is the reason gc type exist?
[14:18:40] <mudkip> cmr oh that sounds promising, I'll check it out, thanks
[14:18:40] <cmr> orshem: one of the reasons, yes.
[14:18:47] <orshem> what will happen when the gc will go away? 
[14:18:52] <cmr> it isn't going away
[14:19:10] <orshem> i thought i read about it here on the channel..
[14:19:13] <dbaupp> orshem: gc isn't disappearing, it's just moving from a compiler-privileged syntax to a library syntax.
[14:19:34] <orshem> dbaupp, ah, ok
[14:19:35] <dbaupp> i.e. @T => Gc<T> or something.
[14:19:45] <orshem> sounds good
[14:20:02] <orshem> thanks cmr engla dbaupp 
[14:20:07] *** Quits: devinus (devinus@moz-B4AF84BC.ptr.us.xo.net) (Quit: Computer has gone to sleep.)
[14:20:21] <Ms2ger> dbaupp, I thought that wasn't certain yet? :)
[14:20:25] <Florob> Though having use-cases that actually require GC is sort of annoying... 
[14:20:26] <mudkip> cmr sorry, I can't seem to find libc::kill... being stupid
[14:20:39] <orshem> though now that i think about it, what is rcmut good for?
[14:20:42] *** Parts: recrack (Mibbit@B4104EBB.3CC170B1.1E14B209.IP) ()
[14:20:58] <orshem> Florob, you can't have cycles without the gc 
[14:21:00] <orshem> safely
[14:21:01] <dbaupp> orshem: you can create a sendable cyclic structure with extra::arc::MutexArc; or ...::RWArc
[14:21:19] <mudkip> cmr nvm, http://static.rust-lang.org/doc/std/libc_funcs_posix88_signal___foreign_mod__.html (DFS fail)
[14:21:24] <dbaupp> Ms2ger: I think it's mostly been agreed on, but I'm not really sure.
[14:21:47] *** Joins: cubic (cubic@moz-FE5AD6C7.mc.videotron.ca)
[14:22:09] *** Joins: devinus (devinus@moz-B4AF84BC.ptr.us.xo.net)
[14:22:18] <dbaupp> mudkip: (unfortunately) the fastest way to find things is grepping the file/source tree, btw. :)
[14:23:17] <Ms2ger> dbaupp, seems sensible enough... Now we just need to librarify * and make ~ * and all the C hackers will be happy :)
[14:24:03] <ChrisMorgan> Whoa, std::io disappeared *altogether*?
[14:24:30] <cmr> ChrisMorgan: no?
[14:24:57] <ChrisMorgan> Whoops, I was looking for a directory named io rather than a file io.rs.
[14:25:11] <ChrisMorgan> :-/
[14:25:13] <dbaupp> Ms2ger: haha... I got the impression that *T -> Unsafe<T> was pushing it a little far, but, again, I don't know.
[14:25:24] *** Quits: devinus (devinus@moz-B4AF84BC.ptr.us.xo.net) (Quit: Computer has gone to sleep.)
[14:26:47] *** Quits: Florob (Florob@moz-39532932.de) (Client exited)
[14:27:20] *** Joins: Florob (Florob@moz-39532932.de)
[14:27:40] <cmr> I don't think Unsafe<T> is a good idea
[14:27:44] <cmr> very bulky
[14:28:33] <SimonSapin> Is it a bug that for â€¦ in borrows the iterator for the whole loop rather than just when calling .next()? http://pastebin.mozilla.org/2802243
[14:29:28] <cmr> SimonSapin: maybe
[14:29:36] <cmr> it's a match on iter.next()
[14:29:55] <SimonSapin> I think re-using the iterator inside the loop should be allowed
[14:30:23] <Ms2ger> Re-using how?
[14:31:05] <orshem> is there a way t oget @mut out of @?
[14:31:06] <SimonSapin> Ms2ger: well, calling next, or in a nested for loop
[14:31:15] <cmr> orshem: no, that'd be unsafe
[14:31:16] <SimonSapin> on the same iterator
[14:31:25] <Ms2ger> Eww
[14:31:26] <cmr> orshem: Multiple things can hold a @ to the same data
[14:31:27] <SimonSapin> in this case, I have an iterator of tokens in a parser
[14:31:27] <dbaupp> orshem: yes, `@mut *foo`
[14:31:34] <cmr> bjz: wut?
[14:31:38] <cmr> erm, @dbaupp
[14:31:41] <bjz> ?
[14:31:43] <bjz> oh
[14:31:44] <dbaupp> cmr: it's a copy.
[14:31:45] <bjz> :)
[14:31:57] <dbaupp> (probably not quite what orshem wanted.)
[14:32:39] <dbaupp> SimonSapin: fwiw, you can do it yourself, `loop { match iter.next() { None => break, Some(x) => { ... iter.next() ... } } }`
[14:33:04] <SimonSapin> dbaupp: yes, thatâ€™s what Iâ€™m doing. I even have a macro for it. But itâ€™s ugly :)
[14:33:13] *** Joins: boredomist (user@moz-63CF9F31.res-cmts.sesp.ptd.net)
[14:33:30] <cmr> SimonSapin: Wait, that works but for-in doesn't?
[14:33:40] <SimonSapin> I think that for â€¦ in should expand to exactly that, but it apperently doesnâ€™t for some reason
[14:33:50] <dbaupp> SimonSapin: but it's unlikely to be possible to do directly with for, because it has to tricky things behind the scenes and so `for ... in iter { ... }` doesn't call .next() on iter, but borrows it to an &mut
[14:34:03] <dbaupp> (run rustc --pretty expanded on a file with a for loop in it.)
[14:34:13] <SimonSapin> I guess that for â€¦ in assigns the iterator expression to a temporary variable, and thatâ€™s a borrow
[14:34:17] <dbaupp> yeah
[14:34:17] <orshem> dbaupp, actually i think it will work
[14:34:23] <dbaupp> exactly. :)
[14:34:35] <SimonSapin> sigh. :)
[14:34:49] <orshem> because otherwise @mut becomes gpl like
[14:34:54] <dbaupp> orshem: oh! it means that anything else looking at the original @ doesn't see any modifications, btw.
[14:35:05] <SimonSapin> could we specialize forâ€¦in when the iterator expression is just the name of a mutable variable?
[14:35:35] <orshem> dbaupp, why? does it perform a copy?
[14:35:50] <cmr> orshem: yes
[14:35:58] <cmr> orshem: it's unsafe to get a @mut from a @
[14:36:08] <dbaupp> SimonSapin: maybe? it's currently the minimal implementation to allow us to use an iterator for loop.
[14:36:10] <cmr> Because you'd be mutating data that there are other references to
[14:36:16] <cmr> Just like you can't get &mut from &
[14:36:23] <SimonSapin> dbaupp: Iâ€™ll file an issue
[14:36:26] <strcat> dbaupp: arc won't let you make a cyclic one
[14:36:40] <strcat> recursive, yes - with immutable arcs
[14:37:09] <dbaupp> SimonSapin: I think it'll have to be pushed deeper into the compiler anyway (it's currently just expanded in the macro phase) to get proper error messages, so that could happen as part of that process.
[14:37:22] <dbaupp> strcat: do you mean the Arc type, or the arc module in general?
[14:37:25] <orshem> cmr: i see, oh well. everybody gets a @mut
[14:37:29] <orshem> thanks
[14:37:32] <strcat> dbaupp: in general
[14:37:49] <dbaupp> strcat: oh, ok. I stand corrected.
[14:37:51] <strcat> you can't make a cycle with Rc/Arc because they aren't mutable
[14:38:06] <dbaupp> yes.
[14:38:28] <strcat> and it would leak
[14:38:29] <orshem> what does rustc does for cycles? doesn't it have any? mutable tree structures?
[14:38:47] <Ms2ger> orshem, @ :)
[14:38:57] <dbaupp> orshem: in theory, it doesn't have any, but there are probably some created by @mut.
[14:38:59] <Ms2ger> Cycles are (still?) broken, though
[14:39:00] <cmr> Pretty sure there are no cyclical data structures
[14:39:06] <dbaupp> *hopefully
[14:39:12] <cmr> Actually that's definitely not true
[14:39:14] *** Joins: tcr (tcr@D26BCFC9.C2203064.EDCE493E.IP)
[14:39:18] <cmr> well, I don't know that it isn't
[14:39:23] <cmr> but lots of memory isn't freed
[14:39:36] <dbaupp> Ms2ger: in broken in these sense that they aren't broken by a GC? :P
[14:39:41] <cmr> dunno if it's from cycles or just poorly structured contexts
[14:39:54] <Ms2ger> dbaupp, I understand that's the case, yes
[14:40:24] <dbaupp> Ms2ger: yeah, they just get cleaned up in one go when the task quits
[14:40:44] <strcat> a gc doesn't necessarily free anything
[14:40:52] *** Joins: devinus (devinus@moz-B4AF84BC.ptr.us.xo.net)
[14:42:34] <orshem> does &@mut helps with gc (less garbage)? is it even meaningful? 
[14:43:19] <strcat> no it's not really going to help to use borrowed pointers rather than passing around @/@mut when it's implemented with a gc
[14:44:38] <dbaupp> strcat: did the remove-headers-from-~[@T] patch land?
[14:44:44] <strcat> no
[14:45:10] <SimonSapin> dbaupp: have for-in not borrow: https://github.com/mozilla/rust/issues/8372
[14:50:44] *** Joins: Usul (anonymous@moz-AB3CA777.w82-125.abo.wanadoo.fr)
[14:51:00] <Usul> yes we still do
[14:51:17] <Usul> ^ wrong channel
[14:51:30] <Usul> is something broken with github : http://usul.pastebin.mozilla.org/2802381
[14:51:47] *** Quits: hjr3 (hradtke@1A0AE795.28A5F6C3.A2D40ED2.IP) (Quit: Textual IRC Client: www.textualapp.com)
[14:52:36] *** Quits: jeff (jeff@moz-F81F6C4E.nyc.biz.rr.com) (Quit: jeff)
[14:55:15] *** Joins: hjr3 (hradtke@1A0AE795.28A5F6C3.A2D40ED2.IP)
[14:57:00] *** Joins: infynyxx (infynyxx@moz-E95B370B.nyc.res.rr.com)
[14:58:22] *** Joins: jeaye (Jeaye@moz-FD505E54.hsd1.ca.comcast.net)
[15:07:14] *** Joins: nano (nano@moz-74CAD1CA.superkabel.de)
[15:09:30] *** Joins: robertknight (robertknig@moz-54528EE0.wby.mendeley.com)
[15:11:35] *** Quits: jensnockert (jensnocker@moz-5386F410.mobileonline.telia.com) (Input/output error)
[15:17:05] *** Quits: devinus (devinus@moz-B4AF84BC.ptr.us.xo.net) (Quit: Computer has gone to sleep.)
[15:17:10] *** Quits: DoomBoom (DoomBoom@6B14631A.ACEC7723.5D1D3FEF.IP) (Ping timeout)
[15:17:22] *** Joins: DoomBoom (DoomBoom@6B14631A.ACEC7723.5D1D3FEF.IP)
[15:19:13] *** Quits: infynyxx (infynyxx@moz-E95B370B.nyc.res.rr.com) (Client exited)
[15:20:22] *** Joins: jorendorff (jorendorff@moz-FAB36621.hsd1.tn.comcast.net)
[15:21:54] *** Quits: gits1225 (gits@5964E44F.18CB2BDE.A2DC32D.IP) (Quit: )
[15:22:05] *** Joins: jeff (jeff@moz-F81F6C4E.nyc.biz.rr.com)
[15:24:46] <dbaupp> nmatsakis: https://github.com/mozilla/rust/issues/5992#issuecomment-22258296
[15:24:49] <dbaupp> ChrisMorgan: ^
[15:25:32] *** Joins: devinus (devinus@moz-B4AF84BC.ptr.us.xo.net)
[15:25:55] *** Joins: leonvv (leonvv@moz-7D83A5F1.ip.telfort.nl)
[15:27:33] <ChrisMorgan> dbaupp: I believe GitHub will have notified him, too.
[15:28:14] <dbaupp> ChrisMorgan: yeah, just the coredevs get a lot of github notifications from rust, and end up ignoring a lot of them.
[15:28:24] <ChrisMorgan> Yeah, I suppose they would.
[15:28:36] <dbaupp> (at least, some of them do; not sure about niko specifically.)
[15:30:04] <doomlord_> (1-based line indices.. grrrr...)
[15:30:47] <acrichto> r? https://github.com/mozilla/rust/pull/8373 (could get a high priority maybe?)
[15:30:48] <ChrisMorgan> Anyway, I'm pleased with how successful I've been with augmented assignment, given how little knowledge I have of how the compiler works... (Still. Probably not a good idea.) I got further than I expected. I certainly didn't expect to get it all working correctly, but I got fairly close.
[15:31:06] <SimonSapin> Are & trait objects reliable nowadays?
[15:33:14] <strcat> SimonSapin: no they don't work
[15:33:21] <strcat> unless you transmute
[15:33:24] <SimonSapin> :(
[15:33:29] <SimonSapin> transmute to what?
[15:33:39] <strcat> well they only compile if you use &'static Trait...
[15:33:58] <SimonSapin> oh
[15:34:17] <SimonSapin> sounds â€¦ not very useful
[15:34:52] <cmr> acrichto: my trepidation was justified
[15:35:10] <acrichto> cmr: it was indeed :) I'll dust off a linux vm and start testing
[15:35:28] *** Joins: ghrust (ghrust@E7A4CCE2.6A2AE50.F3114085.IP)
[15:35:28] <ghrust> 01[13rust01] 15bors merged 06auto into 06master: 02http://git.io/J17y_Q
[15:35:28] *** Parts: ghrust (ghrust@E7A4CCE2.6A2AE50.F3114085.IP) ()
[15:35:34] <cmr> Bors queue: 62
[15:35:40] <cmr> This is huge
[15:36:25] *** Quits: jedestep (jedestep@34641662.FB4DE631.66C78B76.IP) (Ping timeout)
[15:36:33] <acrichto> 63 now
[15:36:42] *** Quits: Mowah (Mowah@moz-436C35C5.cust.bredbandsbolaget.se) (Ping timeout)
[15:37:09] *** Joins: jedestep (jedestep@34641662.FB4DE631.66C78B76.IP)
[15:37:11] <ChrisMorgan> But _only_ 13 ready to process.
[15:37:55] <bstrie> we need a hero to consolidate some items together
[15:38:16] * dbaupp points at strcat, and then runs away to bed.
[15:38:27] <dbaupp> :P
[15:38:33] <strcat> that's not the problem
[15:38:37] <strcat> the problem is all the stale/bad PRs
[15:38:45] <strcat> bors is keeping up with the approved ones
[15:39:09] <acrichto> there's also a log of "discussing" ones
[15:40:08] <acrichto> cmr: is it worth keeping #7687 open?
[15:40:39] <cmr> acrichto: nope
[15:40:48] <acrichto> one down!
[15:41:23] *** Quits: pnkfelix (pnkfelix@moz-43495417.fbx.proxad.net) (Ping timeout)
[15:41:57] *** Joins: pnkfelix (pnkfelix@moz-43495417.fbx.proxad.net)
[15:43:18] *** Joins: Peter (chatzilla@moz-97742234.new.ox.ac.uk)
[15:43:34] *** Joins: lhatsk (Adium@moz-59966846.pool.mediaways.net)
[15:43:56] *** Peter is now known as peterdn
[15:44:09] *** Joins: jdm (jdm@13F2CEC5.7672369.D8E68FF6.IP)
[15:45:21] *** Quits: mudkip (Mibbit@BBE7C46A.B4F11D08.8612FA94.IP) (Quit: http://www.mibbit.com ajax IRC Client)
[15:45:32] *** Joins: mudkip (Mibbit@BBE7C46A.B4F11D08.8612FA94.IP)
[15:47:11] *** Quits: ChrisMorgan (chris@moz-6AC741CA.static.tpgi.com.au) (Ping timeout)
[15:50:24] *** Quits: pnkfelix (pnkfelix@moz-43495417.fbx.proxad.net) (Ping timeout)
[15:50:36] *** Joins: pnkfelix (pnkfelix@moz-43495417.fbx.proxad.net)
[15:53:22] *** Joins: ghrust (ghrust@AD60B2E3.6A2AE50.F3114085.IP)
[15:53:22] <ghrust> 01[13rust01] 15bors pushed 0 new commits to 06auto: 02http://git.io/s7xKLw
[15:53:22] *** Parts: ghrust (ghrust@AD60B2E3.6A2AE50.F3114085.IP) ()
[15:53:23] *** Joins: ghrust (ghrust@CFE85B59.6A2AE50.F3114085.IP)
[15:53:23] <ghrust> 01[13rust01] 15bors pushed 2 new commits to 06auto: 02http://git.io/10B-EQ
[15:53:23] <ghrust> 13rust/06auto 140927d62 15Alex Crichton: Revert "Re-enable rusti tests"...
[15:53:23] <ghrust> 13rust/06auto 1429ffbba 15bors: auto merge of #8373 : alexcrichton/rust/disable-rusti, r=cmr...
[15:53:24] *** Parts: ghrust (ghrust@CFE85B59.6A2AE50.F3114085.IP) ()
[15:53:50] *** Quits: Florob (Florob@moz-39532932.de) (Client exited)
[15:54:11] *** Quits: erickt (Adium@49C4075F.3AC15C18.2321E71E.IP) (Quit: Leaving.)
[15:54:29] *** Joins: pnkfelix1 (pnkfelix@moz-43495417.fbx.proxad.net)
[15:55:14] *** Quits: Kruppe (user@moz-E150F49F.cpe.net.cable.rogers.com) (Client exited)
[15:55:23] *** Quits: DoomBoom (DoomBoom@6B14631A.ACEC7723.5D1D3FEF.IP) (Quit: Leaving)
[15:55:40] *** Quits: pnkfelix (pnkfelix@moz-43495417.fbx.proxad.net) (Ping timeout)
[15:56:02] <sebcrozet> Hi. Is there something like `range` to iterate from e.g. 0 to 10 but with a step of 2 ?
[15:56:29] <bstrie> sebcrozet: haha, I asked just that yesterday
[15:56:43] <sebcrozet> :)
[15:56:43] <bstrie> sebcrozet: it would be trivial to define your own
[15:57:10] <sebcrozet> bstrie: so it does not exist ? weirdâ€¦
[15:57:18] <bstrie> not yet, as far as I know
[15:57:21] <dbaupp> rusti: for i in range(0,5).transform(|x| x*2) { printfln!(i) }
[15:57:25] -rusti- pastebinned 6 lines of output: http://sprunge.us/TEOJ
[15:57:28] <bstrie> I mean, aside from that
[15:57:34] <cmr> there's also Counter
[15:57:43] <bstrie> what's that do?
[15:57:48] <strcat> it's not possible to write a generic range_step
[15:57:57] <strcat> until we impl the checked arithmetic ops
[15:58:08] <sebcrozet> dbaupp: will you solution be as fast as an hand-made range ?
[15:58:10] <cmr> rusti: use std::iterator::Counter; for x in Counter::new(0, 2).take_(5) { printf!("%d ", x) }
[15:58:11] -rusti- 0 2 4 6 8 ()
[15:58:17] <strcat> sebcrozet: yes
[15:58:18] <dbaupp> sebcrozet: probably
[15:58:25] <sebcrozet> great
[15:58:38] <sebcrozet> And what about a decreasing range ?
[15:59:02] <strcat> DoubleEndedIterator for Range has to land
[15:59:05] <strcat> it's an open PR
[15:59:11] <joelteon> how do you read a line from stdin?
[15:59:17] *** Joins: ozten (ozten@moz-DD3B00B4.hsd1.wa.comcast.net)
[15:59:18] <sebcrozet> strcat: ok.
[15:59:26] *** Quits: BizarreCake (BizarreCak@moz-361FE9B2.dynamic.barak-online.net) (Ping timeout)
[15:59:30] <sebcrozet> strcat, dbaupp, cmr: thanks.
[15:59:36] *** Quits: strcat (strcat@moz-54F7FD49.cpe.net.cable.rogers.com) (Quit: WeeChat 0.4.1)
[16:00:34] <dbaupp> joelteon: std::io::stdin().read_line()
[16:00:46] <dbaupp> joelteon: do you want to iterate on the lines?
[16:03:08] *** Quits: jeff (jeff@moz-F81F6C4E.nyc.biz.rr.com) (Quit: jeff)
[16:04:04] *** Quits: bjz (brendanzab@B398BE78.F804C29E.D35A31DF.IP) (Quit: Bye!)
[16:04:10] *** Joins: bjz (brendanzab@B398BE78.F804C29E.D35A31DF.IP)
[16:05:16] <joelteon> no
[16:05:33] <joelteon> i was just trying to find a way to allow the user to end the program manually without using a lot of CPU
[16:05:46] <joelteon> because it appears that rt::select::select() reports erroneous results
[16:06:09] <cmr> Ctrl-C?
[16:06:28] *** Joins: mihneadb (mihneadb@E48845AB.3A9F9BD4.4C2245EF.IP)
[16:07:24] <joelteon> no, it was all my fault
[16:07:28] <joelteon> it's trying to receive from a closed channel
[16:07:43] <joelteon> how do I determine whether an rt Port is closed?
[16:08:38] <jack> in #[cfg()] which way is and and which ir or?
[16:09:06] <cmr> #[cfg(foo, bar)] is and, #[cfg(or(for, bar))] is or, I think
[16:09:18] <jack> what if two are given?
[16:09:28] <jack> #[cfg(foo)] #[cfg(bar)]
[16:09:29] <dbaupp> #[cfg(foo)] #[cfg(bar)] is or
[16:09:40] <jack> thanks
[16:10:03] <dbaupp> cfg(or(foo, bar)) is just checking for `rustc --cfg 'or(foo, bar)' crate.rs`
[16:10:09] <cmr> ah
[16:10:15] <cmr> clearly not right :p
[16:11:29] *** Joins: dherman (dherman@FD49A8D1.18942F00.87193065.IP)
[16:11:29] *** ChanServ sets mode: +o dherman
[16:12:22] *** Joins: pcwalton (pcwalton@moz-7B0110AD.mv.mozilla.com)
[16:12:22] *** ChanServ sets mode: +o pcwalton
[16:15:15] *** Joins: infynyxx (infynyxx@DB780A29.749BA1D.DCC373F0.IP)
[16:15:45] <peterdn> hey, I'm wondering if the following error is intended behavior (and if so, why) :)
[16:16:09] <peterdn> let xs = &mut ~[Some(0)]; f(xs.pop().get_ref());  -- error: borrowed value does not live long enough
[16:16:17] <peterdn> but with a temp variable it works fine:
[16:16:24] <peterdn> let xs = &mut ~[Some(0)]; let temp = xs.pop(); f(temp.get_ref());
[16:16:30] *** Quits: mihneadb (mihneadb@E48845AB.3A9F9BD4.4C2245EF.IP) (Input/output error)
[16:16:37] <sp3d> I think that's a case of "rvalue lifetimes are busted", i.e. a bug
[16:16:40] <cmr> peterdn: it's a bug with rvalue lifetimes I believe
[16:16:47] <peterdn> ahh ok
[16:16:50] *** Quits: dbaupp (Thunderbir@moz-712A1135.lns20.syd6.internode.on.net) (Ping timeout)
[16:17:33] <peterdn> thanks
[16:17:57] <bstrie> pcwalton: http://www.coyotos.org/pipermail/bitc-dev/2013-July/003771.html nobody's responded, now's your chance :)
[16:18:12] *** Quits: devinus (devinus@moz-B4AF84BC.ptr.us.xo.net) (Quit: Computer has gone to sleep.)
[16:18:21] <pcwalton> I did respond to the ML last week but shap hasn't approved my mail
[16:18:26] * pcwalton shrugs
[16:18:46] <bstrie> pcwalton: ipc is on the list, have them tunnel it through for you
[16:18:52] <bstrie> oh wait they've left :(
[16:19:01] *** Quits: jdm (jdm@13F2CEC5.7672369.D8E68FF6.IP) (Quit: Lost terminal)
[16:19:20] <pcwalton> I am honestly not really opposed to anything he is saying, I just think a couple of things
[16:19:43] <pcwalton> (1) BitC-next sounds like it will have a very ambitious, more ambitious than Rust's memory model, which is fine as he's a researcher
[16:20:09] <pcwalton> Rust is pretty C++-like at this point, just made safe and with linearity thrown in
[16:20:27] <pcwalton> it's deliberately all 10 year old stuff with the exception of the borrow checker
[16:20:28] *** Joins: devinus (devinus@moz-B4AF84BC.ptr.us.xo.net)
[16:21:07] <pcwalton> (2) uh... I forget what (2) was
[16:21:34] <bstrie> pcwalton: haha
[16:21:39] *** Joins: mihneadb (mihneadb@E48845AB.3A9F9BD4.4C2245EF.IP)
[16:21:51] <pcwalton> too early in the morning
[16:22:08] <bstrie> pcwalton: mostly I'm just wondering if his allegations that we're link-unsafe because of trait incoherence are true, or if he misunderstands how our trait system works
[16:22:15] <pcwalton> he's misunderstanding
[16:22:29] *** Quits: mudkip (Mibbit@BBE7C46A.B4F11D08.8612FA94.IP) (Quit: http://www.mibbit.com ajax IRC Client)
[16:22:39] <pcwalton> but he would object on grounds of "programming in the large" if he understood
[16:23:00] <pcwalton> I disagree about haskell-style typeclasses being doomed as far as programming in the large is concerned though
[16:23:12] <pcwalton> there are workarounds for the coherence restriction in most cases
[16:23:51] <pcwalton> in practice it's just an annoyance when you need to implement some trait for some type that you didn't define, not "the sky is falling"
[16:24:23] <cmr> How is Servo faring right now, language-use wise?
[16:24:33] <pcwalton> cmr: elaborate?
[16:24:47] <bstrie> perhaps cmr is asking if servo is "in the large" yet
[16:24:49] <cmr> pcwalton: I'm curious what if any language limitations it fights with
[16:24:58] <pcwalton> cmr: mostly the lack of custom smart pointers
[16:25:13] <pcwalton> oh, also I think "nobody has ever built anything big in haskell" is pretty much shap trolling the haskell community :P
[16:25:33] <pcwalton> that's the argument of his I found weakest
[16:25:53] *** Joins: kmsdncjsavab1213 (dasdasd@37410456.5DCE8EFA.521C0519.IP)
[16:25:55] *** Quits: kmsdncjsavab1213 (dasdasd@37410456.5DCE8EFA.521C0519.IP) (User has been banned from Mozilla (no spamming here))
[16:26:00] <bstrie> even if that were true, it doesn't follow that traits would be the cause of that rather than purity, laziness, etc.
[16:26:07] <Ms2ger> pcwalton, has anyone ever built anything big in haskell? ;)
[16:26:22] * Ms2ger wrote a few hundred lines and gouged his eyes outt
[16:26:26] <pcwalton> http://www.haskell.org/haskellwiki/Haskell_in_industry
[16:28:05] <bstrie> Ms2ger: having gouged your eyes out, are you certain that your screen reader isn't written in haskell? :)
[16:28:14] <pcwalton> tim gave me a few names of companies that have large Haskell codebases
[16:28:18] *** Quits: dherman (dherman@FD49A8D1.18942F00.87193065.IP) (Quit: dherman)
[16:28:47] <pcwalton> anyway, I think shap's concern is extra-irrelevant to us at Mozilla, since it is only a concern if you can't modify the source of your dependent libraries
[16:28:59] <pcwalton> and we control or can fork pretty much all the Rust code out there that we depend on
[16:29:29] <pcwalton> if the type you're working with doesn't implement some trait, implement it and send a PR, and if that's ignored, fork the library
[16:29:49] *** Joins: bent (chatzilla@moz-BE33DA21.fw1.sfo1.mozilla.net)
[16:30:10] <bstrie> pcwalton: I see, so you've deliberately designed the language to require open source :)
[16:30:13] <joelteon> I forget why this happens "error: failed to find an implementation of trait std::rand::Rng for extern "Rust" fn() -> std::rand::IsaacRng"
[16:30:23] <pcwalton> not really *deliberately* but it's less researchy that way
[16:30:35] <doomlord> is that the limitation of needing to implement traits in the types' crate?
[16:30:40] <pcwalton> doomlord: yeah
[16:30:48] <pcwalton> I mean, I don't really know how to solve shap's concern in a typeclass system, there are proposals for Haskell but none have gained traction
[16:30:52] <pcwalton> it'd be Research
[16:31:08] <pcwalton> there are alternative systems like Scala implicits or ML modules but both of those are harder to use than traits IMHO
[16:31:17] <pcwalton> the nice thing about traits is that they're relatively easy to use
[16:31:26] <doomlord> hows traditional OOP any better, dont you usually have to make different types to extend things... or are c# extention methods any better
[16:32:07] <pcwalton> doomlord: C# doesn't really have typeclasses I don't think
[16:32:11] <doomlord> the frustrations i've had in the past with traditional OOP were visible at the source file level, with many people needing to change the same headers
[16:32:18] <Ms2ger> Isn't "traditional OOP" a bad word here? :)
[16:32:28] <engla> joelteon: are you calling  random() to return a type that contains extern fn() ?
[16:32:29] <pcwalton> not as far as I'm concerned :)
[16:32:36] <doomlord> probably a bit vague. "what i've encountered with C++"
[16:32:48] <joelteon> engla: I don't think so
[16:32:49] <pcwalton> I do like OOP and I would like to make sure Rust would have a good story for it
[16:32:53] * Ms2ger goes back to cleaning up #includes in his C++
[16:32:58] <joelteon> it's rng().gen_uint_range(0u, 1u)
[16:33:08] *** Quits: jorendorff (jorendorff@moz-FAB36621.hsd1.tn.comcast.net) (Quit: jorendorff)
[16:33:19] <doomlord> as far as i can tell, traits/impls are a step forward in 'open-ness'/decoupling from C++
[16:33:32] <engla> joelteon: looks like an error message if you forget the () in rng() actually
[16:33:35] <joelteon> ok
[16:34:24] <Ms2ger> pcwalton, at the moment, I'm happy as long as you don't have #includes :)
[16:34:37] *** Joins: Mowah (Mowah@moz-436C35C5.cust.bredbandsbolaget.se)
[16:34:41] <pcwalton> well, we did that much anyway :)
[16:35:10] *** Quits: nano (nano@moz-74CAD1CA.superkabel.de) (Connection reset by peer)
[16:36:27] *** Joins: FrozenCow (FrozenCow@moz-B2DF4929.chello.nl)
[16:36:39] <doomlord> the fact you can impl without having to touch the block of source defining the type is what  i like
[16:36:50] <doomlord> (aswell as the lack of #includes)
[16:37:19] <Ms2ger> doomlord, and how will you find the APIs that some object implements? :)
[16:37:41] <doomlord> grep impl.*for\s*typename :)
[16:38:24] *** Quits: lmandel (lmandel@13F2CEC5.7672369.D8E68FF6.IP) (Quit: lmandel)
[16:38:30] *** Joins: tiffany (kawaii@moz-EB8B0C08.dhcp.embarqhsd.net)
[16:38:50] *** Quits: leonvv (leonvv@moz-7D83A5F1.ip.telfort.nl) (Client exited)
[16:39:00] <doomlord> and something like 'rustdoc'(and i'm writing a code-browser tool myself)
[16:39:02] *** Quits: jedestep (jedestep@34641662.FB4DE631.66C78B76.IP) (Ping timeout)
[16:40:07] <cmr> doomlord: It'd be super cool if rustdoc_ng could integrate an HTML viewer that is fully hyperlinked
[16:40:08] *** Quits: devinus (devinus@moz-B4AF84BC.ptr.us.xo.net) (Quit: Computer has gone to sleep.)
[16:40:26] <cmr> Like, seriously awesome
[16:40:35] <pcwalton> rustdoc-ng should be a rendering testcase for servo
[16:40:36] <doomlord> i've just grabbed your source to look over it :)
[16:40:49] <pcwalton> I know it'll fail until we have downloadable fonts though
[16:40:52] <doomlord> cmr, if you're curious i have the linked html working
[16:41:38] *** Joins: james4k (james@moz-E7990244.consolidated.net)
[16:43:22] *** Joins: eholk (eholk@moz-7B0110AD.mv.mozilla.com)
[16:45:04] *** Quits: eholk (eholk@moz-7B0110AD.mv.mozilla.com) (Ping timeout)
[16:45:44] *** Joins: lmandel (lmandel@13F2CEC5.7672369.D8E68FF6.IP)
[16:46:53] *** Joins: eholk (eholk@moz-C8F2917E.tmodns.net)
[16:46:58] *** Joins: graydon (graydon@moz-F14EE0DB.cable.teksavvy.com)
[16:46:58] *** ChanServ sets mode: +qo graydon graydon
[16:47:15] *** Quits: lhatsk (Adium@moz-59966846.pool.mediaways.net) (Quit: Leaving.)
[16:48:03] <orshem> how do i compare two @ pointers if they are the same (as in the pointers are the same not the object)?
[16:48:26] <cmr> std::managed::ptr_eq I believe
[16:48:46] <orshem> cmr, thanks
[16:48:54] *** Joins: eschweic (Adium@moz-BBE3ABD.mv.mozilla.com)
[16:49:19] *** Quits: jaen (jaen@moz-EB4DB9F.neoplus.adsl.tpnet.pl) (Ping timeout)
[16:49:23] <orshem> i thought it would work by default but rust auto deref and tries to compare the objects instead
[16:50:38] *** Quits: eholk (eholk@moz-C8F2917E.tmodns.net) (Quit: eholk)
[16:51:37] <doomlord> rusti: for &x in range(0,2) { print(x.to_str()); }
[16:51:38] -rusti- <anon>:5:13: 5:15 error: mismatched types: expected `int` but found an &-pointer pattern
[16:51:39] -rusti- <anon>:5          for &x in range(0,2) { print(x.to_str()); }
[16:51:39] -rusti-                       ^~
[16:51:39] -rusti- error: aborting due to previous error
[16:51:39] -rusti- application terminated with error code 101
[16:51:47] <doomlord> rusti: for x in range(0,2) { print(x.to_str()); }
[16:51:47] -rusti- 01()
[16:51:48] <cmr> doomlord: range doesn't yield &int
[16:52:40] *** Joins: spider-mario (spidermari@moz-81131DB6.fbx.proxad.net)
[16:53:15] <orshem> cmr, is it possible ptr_eq can't compare @mut?
[16:53:37] <cmr> orshem: mut_ptr_eq
[16:53:40] *** Quits: barosl (barosl@E287D94F.C81E10FB.7544CABF.IP) (Quit: ëžœë¤ì€ ì‡ í‡´í–ˆìŠµë‹ˆë‹¤.)
[16:53:56] *** Joins: barosl (barosl@E287D94F.C81E10FB.7544CABF.IP)
[16:54:38] *** Joins: tchoma (tchoma@moz-BE33DA21.fw1.sfo1.mozilla.net)
[16:55:02] <orshem> cmr, thanks
[16:55:23] *** Joins: erickt (etryzelaar@8C9ECD8F.3A598286.F12515B4.IP)
[16:56:28] *** Joins: jedestep (jedestep@34641662.FB4DE631.66C78B76.IP)
[16:56:36] *** Joins: eholk (eholk@moz-7B0110AD.mv.mozilla.com)
[16:57:28] *** Joins: erickt__ (etryzelaar@8C9ECD8F.3A598286.F12515B4.IP)
[16:57:41] *** Joins: brson (brson@moz-BBE3ABD.mv.mozilla.com)
[16:57:41] *** ChanServ sets mode: +o brson
[16:59:21] *** Parts: erickt__ (etryzelaar@8C9ECD8F.3A598286.F12515B4.IP) ()
[16:59:41] *** Quits: brson (brson@moz-BBE3ABD.mv.mozilla.com) (Ping timeout)
[16:59:57] *** Joins: azakai (alon@moz-BBE3ABD.mv.mozilla.com)
[17:00:30] *** Quits: echristo (echristo@moz-1892C634.hsd1.ca.comcast.net) (Quit: echristo)
[17:00:35] *** Quits: StarLight (StarLight@moz-D04EF820.dynamic.avangarddsl.ru) (Ping timeout)
[17:01:15] *** Joins: echristo (echristo@moz-1892C634.hsd1.ca.comcast.net)
[17:02:58] *** Quits: eholk (eholk@moz-7B0110AD.mv.mozilla.com) (Quit: eholk)
[17:03:18] <orshem> rusti: struct S { x:int } let v = ~[@mut S { x: 5 }]; v[0].x = 42; printfln!(v[0].x);
[17:03:19] -rusti- 42
[17:03:19] -rusti- ()
[17:03:34] *** Joins: brson (brson@moz-BBE3ABD.mv.mozilla.com)
[17:03:34] *** ChanServ sets mode: +o brson
[17:05:01] *** Joins: StarLight (StarLight@moz-B8E3BA82.dynamic.avangarddsl.ru)
[17:07:51] *** Joins: chii (Mibbit@BBE7C46A.B4F11D08.8612FA94.IP)
[17:08:01] *** Joins: Kruppe (user@moz-4DDA8AB8.uwaterloo.ca)
[17:08:47] *** Joins: steven_is_false (user@C5B76363.1FF1EBF8.1ECA502.IP)
[17:08:59] <steven_is_false> bblum: poke?
[17:09:40] *** Quits: sebcrozet (sebcrozet@moz-2517AE39.w80-13.abo.wanadoo.fr) (Client exited)
[17:12:04] *** Joins: thomaslee (thomaslee@moz-6C3931E3.static.twtelecom.net)
[17:12:46] *** Parts: steven_is_false (user@C5B76363.1FF1EBF8.1ECA502.IP) (ERC Version 5.3 (IRC client for Emacs))
[17:17:04] <engla> librustc/middle/graph.rs line 193, .each_edge uses the nodes.len() count to iterate over edges.. is the identical length an invariant or is it a bug?
[17:17:43] *** Quits: pnkfelix1 (pnkfelix@moz-43495417.fbx.proxad.net) (Quit: Leaving.)
[17:19:05] *** Joins: eatkinson (eatkinson@moz-BBE3ABD.mv.mozilla.com)
[17:19:22] *** Joins: Cs (Sohbet@F17B0B42.4A7B1AA7.4FB469B7.IP)
[17:23:36] *** Quits: Cs (Sohbet@F17B0B42.4A7B1AA7.4FB469B7.IP) (User has been banned from Mozilla (abuse))
[17:23:38] *** Joins: devinus (devinus@moz-B4AF84BC.ptr.us.xo.net)
[17:25:02] *** Joins: Cs (Sohbet@EAAE86DA.5B58AE5E.759BFED5.IP)
[17:25:16] <toddaaro> rusti: use std::rand::RngUtil; let r = rng<XorShiftRng>();
[17:25:18] -rusti- pastebinned 8 lines of output: http://sprunge.us/iPQb
[17:26:05] <toddaaro> rusti: use std::rand::XorShiftRng; let r = XorShiftRng::new();
[17:26:06] -rusti- <anon>:5:41: 5:42 warning: unused variable: `r` [-W unused-variable (default)]
[17:26:06] -rusti- <anon>:5          use std::rand::XorShiftRng; let r = XorShiftRng::new();
[17:26:06] -rusti-                                                   ^
[17:26:06] -rusti- ()
[17:26:38] <cmr> toddaaro: be careful to note the default constructor uses a constant seed
[17:27:19] <toddaaro> cmr: ah, so I want new_seeded
[17:27:35] <toddaaro> hm, do we have splittable rngs?
[17:27:56] <toddaaro> in a haskell fork-join library I'm familiar with (meta-par) the trick is to just split the existing rng when you fork
[17:28:04] <toddaaro> so you don't need to deal with seeding and such
[17:28:30] <cmr> don't think so
[17:28:30] *** Quits: acrichto (acrichto@moz-B63D64BD.res.cmu.edu) (Connection reset by peer)
[17:28:49] <toddaaro> ok, I think I can seed a new task's rng with a value generated by the parent task
[17:29:11] <toddaaro> and I guess initializing the scheduler will just grab seeds from urandom
[17:29:23] *** Joins: ghrust (ghrust@9C8B94D4.6A2AE50.F3114085.IP)
[17:29:23] <ghrust> 01[13rust01] 15bors merged 06auto into 06master: 02http://git.io/10B-EQ
[17:29:23] *** Parts: ghrust (ghrust@9C8B94D4.6A2AE50.F3114085.IP) ()
[17:30:37] *** Joins: nano (nano@moz-74CAD1CA.superkabel.de)
[17:30:42] *** Joins: acrichto (acrichto@moz-B63D64BD.res.cmu.edu)
[17:30:52] *** Quits: echristo (echristo@moz-1892C634.hsd1.ca.comcast.net) (Quit: echristo)
[17:31:18] *** Quits: graydon (graydon@moz-F14EE0DB.cable.teksavvy.com) (Quit: Leaving.)
[17:32:21] *** Joins: ghrust (ghrust@DE823A67.6A2AE50.F3114085.IP)
[17:32:21] <ghrust> 01[13rust01] 15bors pushed 0 new commits to 06auto: 02http://git.io/M4EzTQ
[17:32:21] *** Parts: ghrust (ghrust@DE823A67.6A2AE50.F3114085.IP) ()
[17:32:22] *** Joins: ghrust (ghrust@C621748.6A2AE50.F3114085.IP)
[17:32:23] <ghrust> 01[13rust01] 15bors pushed 8 new commits to 06auto: 02http://git.io/lUskHw
[17:32:23] <ghrust> 13rust/06auto 14b3a317c 15Daniel Micay: iterator: simplify the `take` implementation
[17:32:23] <ghrust> 13rust/06auto 14c13f4f3 15Daniel Micay: add Extendable to the prelude
[17:32:23] <ghrust> 13rust/06auto 1440d11a5 15Daniel Micay: iterator: rename `Counter::new` to `count`...
[17:32:25] *** Parts: ghrust (ghrust@C621748.6A2AE50.F3114085.IP) ()
[17:32:59] *** Quits: Kruppe (user@moz-4DDA8AB8.uwaterloo.ca) (Ping timeout)
[17:33:58] *** Quits: jedestep (jedestep@34641662.FB4DE631.66C78B76.IP) (Ping timeout)
[17:35:51] *** Ms2ger is now known as Ms2ger|mtg
[17:36:00] *** Quits: Cs (Sohbet@EAAE86DA.5B58AE5E.759BFED5.IP) (Client exited)
[17:36:08] *** Joins: Cs (Sohbet@EAAE86DA.5B58AE5E.759BFED5.IP)
[17:36:20] <toddaaro> uh oh, so my thought was to have something like Task::rng() to give you a pointer to a task's rng, but this isn't safe at all
[17:36:36] <toddaaro> and requiring someone to do Task::put_rng() is absurd
[17:36:51] *** Joins: jedestep (jedestep@34641662.FB4DE631.66C78B76.IP)
[17:37:35] <cmr> toddaaro: could Task implement Rng itself?
[17:37:36] *** Quits: CarpNet (ac@moz-FD24B77.sohonet.co.uk) (Quit: Leaving)
[17:37:45] <cmr> And it just feeds calls to .next into its internal Rng?
[17:38:04] <toddaaro> cmr: that is what I'm thinking, but since you don'thave access to tasks as a user I'd have to make a "wrapper" of some sort
[17:38:32] <toddaaro> so there would be a TaskRng type implemented such that it does .next by borrowing the task's rng from tls
[17:38:55] <toddaaro> cmr: so to make that work I just do an impl of Rng for TaskRng?
[17:39:13] *** Quits: lucian (lucian@6B2B4644.4304AE1E.CE5E78F6.IP) (Ping timeout)
[17:39:32] *** Joins: mschifer (Adium@moz-BBE3ABD.mv.mozilla.com)
[17:40:02] <cmr> toddaaro: I think so
[17:40:22] <toddaaro> cmr: cool
[17:41:34] *** Joins: mschifer1 (Adium@moz-BBE3ABD.mv.mozilla.com)
[17:41:34] *** Quits: mschifer (Adium@moz-BBE3ABD.mv.mozilla.com) (Connection reset by peer)
[17:42:12] *** Joins: mschifer (Adium@moz-BBE3ABD.mv.mozilla.com)
[17:42:30] *** Quits: Cs (Sohbet@EAAE86DA.5B58AE5E.759BFED5.IP) (Client exited)
[17:42:39] *** Joins: Cs (Sohbet@EAAE86DA.5B58AE5E.759BFED5.IP)
[17:42:39] *** Quits: mschifer1 (Adium@moz-BBE3ABD.mv.mozilla.com) (Connection reset by peer)
[17:43:05] *** Joins: jaen (jaen@moz-5D3845EB.play-internet.pl)
[17:44:49] <toddaaro> rusti: struct Foo { }; impl Foo { fn new() -> Foo { Foo {} } }; let f = Foo::new();
[17:44:50] -rusti- <anon>:5:22: 5:23 error: Unit-like struct should be written as `struct Foo;`
[17:44:50] -rusti- <anon>:5          struct Foo { }; impl Foo { fn new() -> Foo { Foo {} } }; let f = Foo::new();
[17:44:50] -rusti-                                ^
[17:44:50] -rusti- application terminated with error code 101
[17:45:10] <toddaaro> rusti: struct Foo; impl Foo { fn new() -> Foo { Foo {} } }; let f = Foo::new();
[17:45:10] -rusti- <anon>:5:54: 5:55 error: expected `;` or `}` after expression but found `{`
[17:45:10] -rusti- <anon>:5          struct Foo; impl Foo { fn new() -> Foo { Foo {} } }; let f = Foo::new();
[17:45:11] -rusti-                                                                ^
[17:45:11] -rusti- application terminated with error code 101
[17:45:20] <toddaaro> rusti: struct Foo; impl Foo { fn new() -> Foo { Foo } }; let f = Foo::new();
[17:45:21] -rusti- <anon>:5:63: 5:64 warning: unused variable: `f` [-W unused-variable (default)]
[17:45:21] -rusti- <anon>:5          struct Foo; impl Foo { fn new() -> Foo { Foo } }; let f = Foo::new();
[17:45:21] -rusti-                                                                         ^
[17:45:21] -rusti- ()
[17:45:34] *** Quits: heftig (heftig@moz-88B5382A.dip0.t-ipconnect.de) (Quit: Quitting)
[17:45:55] *** Quits: doomlord (doomlod@moz-13E69BC8.range86-180.btcentralplus.com) (Quit: Leaving)
[17:48:06] *** Joins: jdm (jdm@13F2CEC5.7672369.D8E68FF6.IP)
[17:48:40] *** Quits: robertknight (robertknig@moz-54528EE0.wby.mendeley.com) (Ping timeout)
[17:50:09] *** Quits: Cs (Sohbet@EAAE86DA.5B58AE5E.759BFED5.IP) (Quit: )
[17:50:16] *** Joins: heftig (heftig@moz-88B5382A.dip0.t-ipconnect.de)
[17:51:54] *** Quits: fabiand (fabiand@moz-31B43A8F.adsl.alicedsl.de) (Quit: Verlassend)
[17:54:08] *** Quits: brson (brson@moz-BBE3ABD.mv.mozilla.com) (Ping timeout)
[17:54:40] *** Joins: int3_ (int3_@moz-ABE52D50.hsd1.ca.comcast.net)
[17:54:47] *** Joins: vodik (simon@moz-CBE4BB13.cable.teksavvy.com)
[17:56:28] *** Quits: int3_ (int3_@moz-ABE52D50.hsd1.ca.comcast.net) (Ping timeout)
[18:00:07] <sully> ... does anybody know why _match.rs has the underscore?
[18:00:13] <nmatsakis> sully: match is a keyword.
[18:00:35] <cmr> (shouldn't it be match_?)
[18:00:35] <nmatsakis> sully: I'd personally prefer a different naming convention (`matching.rs`? `match_.rs`?)
[18:00:41] * nmatsakis shrugs
[18:01:52] *** Joins: tjc (tjc@moz-BBE3ABD.mv.mozilla.com)
[18:01:52] *** ChanServ sets mode: +o tjc
[18:01:53] <sully> oh, and you can't have a module named the same as a keyword
[18:01:56] <sully> loooooool.
[18:02:05] *** Joins: pnkfelix (pnkfelix@moz-43495417.fbx.proxad.net)
[18:02:09] <cmr> the filename could be match.rs
[18:02:19] <cmr> it'd just need to be #[path="match.rs"] mod match_;
[18:02:22] <cmr> or whatever else
[18:02:38] *** Joins: brson (brson@moz-BBE3ABD.mv.mozilla.com)
[18:02:38] *** ChanServ sets mode: +o brson
[18:02:48] *** Joins: graydon (Adium@A5087023.2354C43D.D8E68FF6.IP)
[18:02:49] *** ChanServ sets mode: +qo graydon graydon
[18:03:07] *** Quits: orshem (orshem@C5E06B1E.A5B6B765.E3D28531.IP) (Quit: Leaving)
[18:03:21] *** Quits: wilsonk-laptop (kvirc@moz-8E86F35A.cg.shawcable.net) (Ping timeout)
[18:03:23] *** Joins: Florob (Florob@moz-39532932.de)
[18:04:18] *** Joins: echristo (echristo@DCF57675.D6CCE4AE.77834EAA.IP)
[18:04:19] <brson> good morning graydon!
[18:04:26] <graydon> hey
[18:04:30] *** Joins: brendan (brendaneic@moz-BBE3ABD.mv.mozilla.com)
[18:04:35] <graydon> you fight onwards with the newrt landing
[18:04:38] <graydon> anything I can do to help?
[18:04:40] *** Joins: strcat (strcat@moz-54F7FD49.cpe.net.cable.rogers.com)
[18:04:41] *** Joins: sebcrozet (sebcrozet@moz-F96421F3.w80-13.abo.wanadoo.fr)
[18:04:48] <graydon> (also: do you want me to try to debug the android bot .. concurrently?)
[18:05:18] *** Quits: jaen (jaen@moz-5D3845EB.play-internet.pl) (Ping timeout)
[18:06:04] *** Joins: wilsonk-laptop (kvirc@moz-8E86F35A.cg.shawcable.net)
[18:07:46] <cmr> graydon: pcwalton: https://github.com/mozilla/rust/issues/8353#issuecomment-22269621
[18:07:54] <cmr> This is RE yesterdays stuff about newtype deriving
[18:09:19] <cmr> Doesn't even need to touch to type system or really anything
[18:09:29] <cmr> So I don't think there are really any special considerations that need to be made?
[18:09:41] <cmr> pcwalton mentioend something about generalizednewtypederiving breaking ghc's type system
[18:10:01] <brson> yeah, if you could finish the bot I guess that would help. firstly, I addad a patch to rust-buildbot to restore force build, but couldn't push to github. can you do that? second, the android commit is in its another branch of rust-buildbot on scl3. i haven't gotten back to it this week. there can't be much more left to do
[18:10:07] <brson> *I know
[18:10:12] <brson> no guesswork involved
[18:10:49] <brson> graydon: newrt is infuriatingly close to landing. some weird issue on the bots with rustitest. I'm going to investigate that now
[18:11:03] <cmr> brson: acrichto disabled the rusti tests
[18:11:08] <cmr> (again)
[18:11:15] <graydon> brson: oh, acrichto landed a re-enable then a revert-re-enable pair on those
[18:11:18] <cmr> janded about an hour ago
[18:11:34] <acrichto> yeah it started being flaky on linux again (I thought it was fixed...)
[18:11:35] <graydon> I am happy to close the tree / disable bors for this landing
[18:11:40] <brson> cmr graydon: disabling the rustitests doesn't even matter. my branch turns them all off but it still crashes
[18:11:43] <graydon> chasing drift is no fun
[18:11:50] <brson> it's very mysterious
[18:11:54] * brson hallucinating
[18:11:54] <cmr> that is mysterious
[18:12:05] <graydon> will it help if bors is off while you try this?
[18:12:46] <brson> graydon: i don't think so, no. other pulls aren't really interfering that much. maybe i'll start cancelling builds though to cut the line
[18:13:00] <graydon> ok
[18:13:11] <cmr> (do canceled builds get put back in the queue?)
[18:13:15] <brson> no
[18:13:30] <graydon> yeah, better to turn it off for a while imo
[18:13:40] <graydon> we should probably do a rollup of the small stuff anyway
[18:13:52] <graydon> strcat: I mean to ask, do you have scripts you use for forming those?
[18:14:03] <cmr> scripts! who needs those
[18:14:05] <bstrie> strcat: you say that a generic range_step is impossible, so what's wrong with https://gist.github.com/bstrie/6175480 ?
[18:14:17] <strcat> bstrie: doesn't handle overflow
[18:14:26] <strcat> (it's possible, but we need to write checked overflow traits)
[18:14:30] <strcat> graydon: no, I just fetch + cherry-pick
[18:14:34] <cmr> graydon: what I do is use `curl https://github.com/mozilla/rust/pull/8371.patch | git am`
[18:14:45] <strcat> that works too ;]
[18:15:00] <strcat> cmr: I don't think you actually need curl, but that's not very important
[18:15:13] <cmr> git will fetch a URL for you?
[18:15:42] <graydon> I know how to integrate branches :)
[18:15:44] <strcat> I think so... I just can't remember how
[18:16:05] <strcat> graydon: yeah but github makes it more convenient than manually figuring out the branch name
[18:16:08] *** Quits: Diamond (dick@moz-C01E1CD1.ks.ks.cox.net) (Ping timeout)
[18:16:17] <cmr> graydon: well, right, but you can easily "script" that with a list of PRs and a shell for loop
[18:16:18] <graydon> I am wondering if it's worth making a script to compress N PRs into 1
[18:16:34] <strcat> graydon: seems worth it
[18:16:37] <graydon> cmr: including adding comments to all, setting the r=... values right, closing them, etc. etc.
[18:16:45] <strcat> the main issue with it is that you're likely going to have to fix 1/3 of the PRs you rollup
[18:16:49] <cmr> graydon: ah, yeah, I suppose there is that
[18:16:54] <graydon> cmr: it's a little bit of scripty work to do. not a ton. might be worthwhile tho.
[18:16:55] <strcat> but it takes 10 mins to run make check locally
[18:17:00] <graydon> bors is "just" a little script too, but helpful :)
[18:18:54] *** Ms2ger|mtg is now known as Ms2ger
[18:20:34] <strcat> bstrie: I think we'll probably want to expose intrinsics for LLVM's overflow checking ops
[18:20:48] <strcat> I'm not sure if it's capable of optimizing manual checks to those
[18:20:52] <strcat> would have to test
[18:21:55] <strcat> the existing range_step is special-cased for each integer type, since it's not generic
[18:21:55] <graydon> can someone change the topic to indicate that the tree's closed for maintenance?
[18:22:02] <graydon> my IRC client is sadly deficient
[18:22:23] <bstrie> strcat: how about adding a Sub<A, A> bound and just checking if (self.stop - self.state) < self.step? does llvm guarantee overflow checks on all platforms?
[18:22:33] <cmr> "PurpleIRC is an IRC to Minecraft bridge plugin"
[18:22:52] <strcat> bstrie: yes, mono uses them with their LLVM backend
[18:22:59] <cmr> This is where we find out... graydon is actually an AI
[18:23:02] *** tjc changes topic to 'Tree is CLOSED for maintenance | http://www.rust-lang.orgÂ | logs at https://botbot.me/mozilla/rust/ and http://irclog.gr/#browse/irc.mozilla.org/rust | http://huonw.github.io/isrustfastyet/mem/ | landings http://buildbot.rust-lang.org/bors/bors.html'
[18:23:03] <cmr> not a mech
[18:23:15] <strcat> they optimize to the overflow checked ops on x86, I guess elsewhere they compile to code similar to manual checks
[18:24:16] *** Quits: davbo (dave@moz-3FFA637C.oucs.ox.ac.uk) (Client exited)
[18:24:34] <strcat> I wouldn't really expect their codegen to be smart enough to turn adds + branch on overflow check into one though
[18:24:40] * strcat would be happy to be surprised
[18:24:55] *** Joins: dherman (dherman@moz-7B0110AD.mv.mozilla.com)
[18:24:55] *** ChanServ sets mode: +o dherman
[18:25:03] <strcat> it's the type of thing gcc knows how to do, but LLVM doesn't have nearly as many special cases or passes yet
[18:26:55] <strcat> bstrie: http://llvm.org/docs/LangRef.html#arithmetic-with-overflow-intrinsics would be easy to turn this into add_checked -> Option<T>
[18:27:08] <strcat> let me try doing that now
[18:27:45] <strcat> and for bigints they'll just always do Some(self.add(other)), it'll get inlined + optimized out
[18:29:27] *** Joins: Diamond (dick@moz-C01E1CD1.ks.ks.cox.net)
[18:30:00] <strcat> no idea where to put them in libstd ;p
[18:31:14] <engla> sounds a bit related to the saturated add/sub
[18:32:54] <strcat> oh right num.rs
[18:33:18] *** Quits: diegoyam (quassel@FF9B1514.A4EC3D18.3A1EC144.IP) (Ping timeout)
[18:33:27] <graydon> newrt hackers: brson toddaaro bblum etc. ponder this question: do you think we'll be able to trap a software interrupt in such a way that we can cause it to deschedule a task? it would be useful for cheap checks of various sorts.
[18:34:00] *** Joins: eschweic1 (Adium@moz-BBE3ABD.mv.mozilla.com)
[18:34:21] *** Quits: eschweic (Adium@moz-BBE3ABD.mv.mozilla.com) (Ping timeout)
[18:34:26] *** Joins: jorendorff (jorendorff@moz-2F32ACA3.hsd1.tn.comcast.net)
[18:34:31] <bblum> graydon: definitely possible; would require some assembly
[18:35:58] <graydon> (similarly: assuming libuv is routing signals to events, which I think it does, what do we do to ensure timely response to them?)
[18:36:11] <bblum> that i do not know
[18:36:45] <cmr> https://gist.github.com/cmr/60af7c6d6b3e7735aa3b
[18:36:55] <cmr> Is this a case of the move checker not being smart enough, or me doing something legitimately bad?
[18:37:02] <brson> i know pretty much nothing about signal handling
[18:37:06] *** Quits: tjc (tjc@moz-BBE3ABD.mv.mozilla.com) (Quit: zzzzzzzzzz)
[18:37:08] <bblum> from the signal handler, you can just return to the address of an 'interrupt handler' instead of returning to where you came from, and the handler would do a pusha, call scheduler, popa, ret
[18:37:14] <mihneadb> partially moved value? :o
[18:37:48] <strcat> I think there are better ways of handling signals, even with just POSIX (than good old signal handlers)
[18:37:59] <bblum> presumably the first part would be accomplished by modifying the state that the kernel pushes onto your stack when it drops you into the handler
[18:38:02] <bblum> strcat: do tell
[18:38:20] <strcat> well I only know about the linux way with signalfd - you just handle signals with epoll/select as fds
[18:38:31] <strcat> but there's a way to mask them and use pselect
[18:38:37] <strcat> with just POSIX
[18:38:41] <strcat> never done that myself though.
[18:39:02] <strcat> maybe libuv abstracts this for us already
[18:39:02] <graydon> http://nikhilm.github.io/uvbook/processes.html#signals fwiw
[18:39:11] <bblum> strcat: wouldn't that require the task to be at an appropriate 'signal reception site' (select or whatever) to be able to receive it
[18:39:37] *** Quits: brendan (brendaneic@moz-BBE3ABD.mv.mozilla.com) (Quit: brendan)
[18:39:39] <strcat> bblum: yeah, if we didn't have a way to preempt them
[18:39:45] <strcat> but we could
[18:40:59] <brson> graydon: what chepa checks do you have in mind?
[18:41:46] <bblum> oh, actually, what i said about having a custom handler is unnecessary; you can just use the signal handler itself for that purpose, and call directly into the scheduler from there
[18:41:49] <graydon> brson: vec overflow, assert!()/fail!(), divide-by-zero, overflow-arithmetic when we're in overflow-trapping mode, 
[18:42:02] <graydon> that sort of thing
[18:42:16] <bblum> of course you want a check that you're not already in the scheduler
[18:42:20] <bblum> ("disable interrupts")
[18:42:21] *** Quits: Axord (xord@moz-1B228827.lsanca.dsl-w.verizon.net) (Quit: I'm sure it's perfectly safe)
[18:44:03] <strcat> fwiw Go just has you ask to receive certain signals over a channel, and the scheduler notifies your task
[18:44:19] *** Joins: jaen (jaen@moz-E0979827.copit.pl)
[18:44:30] <graydon> brson: we generate a fair bit of code for them now; it'd be nice if we could generate the moral equivalent of 'int3' and a static data pointer. maybe an llvm call using the "cold calling" convention would be equally pleasant. http://llvm.org/docs/LangRef.html#calling-conventions
[18:44:46] <bblum> hm, oh, i'm still not sure how signals and pthreads interact
[18:45:01] *** Joins: tjc (tjc@moz-BBE3ABD.mv.mozilla.com)
[18:45:01] *** ChanServ sets mode: +o tjc
[18:45:57] <bblum> also not sure what the equivalent would be on windows
[18:46:13] <strcat> bblum: pretty sure if you really want only what POSIX can do, you have to handle them from 1 thread
[18:46:19] <strcat> and mask the signal in every other thread
[18:47:06] <bblum> strcat: could that thread then shoot other threads as desired?
[18:47:12] <brson> i can't envision how e.g. a divide-by-zero trap could reliably pursuade a task to fail. I assume you can't start unwinding from a signal handler. how do you resume the task then initiate failure?
[18:47:59] <strcat> brson: I don't think you can really handle it for more than 1 thread
[18:48:04] <strcat> the process as a whole gets a signal
[18:48:24] *** Joins: lucian (lucian@moz-22A14C6A.cable.virginmedia.com)
[18:48:28] <graydon> brson: sorry, this was an idle question, not a deep one; I shouldn't have interrupted more pressing things
[18:49:43] <bblum> presumably in the case of divide by zero, this is to optimize out the check for 0 and let the trap do the work
[18:50:04] *** Quits: lucian (lucian@moz-22A14C6A.cable.virginmedia.com) (Ping timeout)
[18:50:16] <graydon> ideally. less-ideally it's just to reduce the amount of code we put in for "if x == 0 { fail!() }"
[18:50:32] <graydon> so I bet coldcc and a noreturn attribute would go a long way there
[18:50:35] <graydon> on fail
[18:51:23] <strcat> I'm not really clear on whether you're allowed to put noreturn on functions that unwind
[18:51:58] *** Quits: rust-buildbot (rust-build@505BFA3.C3CCCE8C.D25A875A.IP) (Quit: buildmaster reconfigured: bot disconnecting)
[18:51:58] *** Joins: rust-buildbot (rust-build@505BFA3.C3CCCE8C.D25A875A.IP)
[18:54:38] <toddaaro> whoa!
[18:54:44] *** Quits: Yurume (yurume@AC58A8CE.8A059B47.E313B915.IP) (Ping timeout)
[18:54:48] *** Quits: dherman (dherman@moz-7B0110AD.mv.mozilla.com) (Quit: dherman)
[18:54:50] <toddaaro> the hung rustc I left overnight appears to be hung in a different place now
[18:55:01] <bblum> sounds like you're swapping
[18:55:04] <toddaaro> nope
[18:55:11] <toddaaro> 62 GB ram free
[18:55:20] *** Joins: Sergio965 (sergiobz@BE9C9272.E63B31F7.3A99D594.IP)
[18:55:43] <toddaaro> and the rustc process is only using ~600 MB
[18:56:01] <toddaaro> something about how the SOIC machines are configured makes building rust not work
[18:56:11] <strcat> graydon: llvm actually considers division by zero to be undef behaviour
[18:56:23] <strcat> not just an undefined result or a trap
[18:56:33] <strcat> and this
[18:56:35] <strcat> Division by zero leads to undefined behavior. Overflow also leads to undefined behavior; this is a rare case, but can occur, for example, by doing a 32-bit division of -2147483648 by -1.
[19:00:06] <engla> don't you think the 'Warning: removing previous ..' lines in the build just add noise?
[19:00:18] *** Quits: rust-buildbot (rust-build@505BFA3.C3CCCE8C.D25A875A.IP) (Quit: buildmaster reconfigured: bot disconnecting)
[19:00:19] *** Joins: rust-buildbot (rust-build@505BFA3.C3CCCE8C.D25A875A.IP)
[19:00:23] <cmr> engla: no
[19:00:29] <cmr> it's definitately signal
[19:00:43] *** Joins: vosen (vosen@moz-266BA656.icpnet.pl)
[19:00:56] <engla> I can't see why
[19:01:22] <engla> overwriting a previous product is a trivial byproduct of building
[19:02:38] *** Joins: dherman (dherman@moz-7B0110AD.mv.mozilla.com)
[19:02:38] *** ChanServ sets mode: +o dherman
[19:02:46] <graydon> brson: you're going to love the reason the android-cross slave wasn't connecting :)
[19:04:40] *** Quits: Usul (anonymous@moz-AB3CA777.w82-125.abo.wanadoo.fr) (Quit: Usul)
[19:04:45] <graydon> brson: I don't know where you got the random password you used, but the ones in the all-slaves list are chosen for (among other things) not containing a single-quote character. the one you picked had a single-quote :)
[19:05:43] * graydon does a manual bors run to finish current build before restarting
[19:06:43] *** Joins: brendan (brendaneic@moz-BBE3ABD.mv.mozilla.com)
[19:07:54] <strcat> bstrie: 12 new intrinsics :S
[19:08:06] <kmc> what language change would have recently introduced "error: value may contain borrowed pointers"  on  @mut HashMap::new()
[19:08:30] <engla> kmc: @T now requires 'static bound on T
[19:08:40] *** Quits: brendan (brendaneic@moz-BBE3ABD.mv.mozilla.com) (Quit: brendan)
[19:08:47] *** Quits: chii (Mibbit@BBE7C46A.B4F11D08.8612FA94.IP) (Quit: http://www.mibbit.com ajax IRC Client)
[19:09:10] <engla> kmc: 9089cf2ec9297a3b558d24352cde6a5206a08444 commit
[19:10:14] <kmc> ah ok
[19:10:40] *** Joins: snadon (chatzilla@moz-3BC727E8.mc.videotron.ca)
[19:11:28] *** Joins: ghrust (ghrust@614D05BD.6A2AE50.F3114085.IP)
[19:11:28] <ghrust> 01[13rust01] 15bors merged 06auto into 06master: 02http://git.io/lUskHw
[19:11:28] *** Parts: ghrust (ghrust@614D05BD.6A2AE50.F3114085.IP) ()
[19:11:45] *** Quits: rust-buildbot (rust-build@505BFA3.C3CCCE8C.D25A875A.IP) (Quit: buildmaster reconfigured: bot disconnecting)
[19:13:16] *** Joins: rust-buildbot (rust-build@505BFA3.C3CCCE8C.D25A875A.IP)
[19:14:35] <graydon> brson: http://buildbot.rust-lang.org/builders/auto-linux-64-x-android/builds/0 
[19:14:47] <graydon> brson: getting lunch now, back to babysit it in a while
[19:16:22] *** Joins: brendan (brendaneic@moz-BBE3ABD.mv.mozilla.com)
[19:16:35] *** Joins: ecr (Thunderbir@moz-BBE3ABD.mv.mozilla.com)
[19:18:28] <bstrie> strcat: I thought we already had every single llvm intrinsic hooked up. do you mean 12 new lang items?
[19:18:38] <bstrie> or are there just untold numbers of llvm intrinsics
[19:18:44] <strcat> infinite numbers
[19:18:48] <bstrie> oh dear
[19:18:51] <strcat> because you can make arbitrarily sized integers
[19:19:03] *** Joins: tikue (tkuehn@moz-BBE3ABD.mv.mozilla.com)
[19:19:28] <strcat> there are a lot we don't have
[19:19:44] <bstrie> "llvm.sadd.with.overflow" I'm sad too, llvm
[19:19:48] <strcat> fmuladd, half precision floats (ick), etc.
[19:19:49] *** Quits: infynyxx (infynyxx@DB780A29.749BA1D.DCC373F0.IP) (Client exited)
[19:20:17] <strcat> I don't really know if these with.overflow ops are available for i8 :S
[19:20:23] <strcat> it does *claim* they work for any integer size
[19:20:26] <strcat> but lists 3 variants
[19:20:38] <bstrie> what if my integer size is itself a half-precise float
[19:21:00] <strcat> they're compile-time only sizes ;p
[19:21:06] <strcat> i2143241
[19:21:23] <bstrie> so no i2.2
[19:21:46] *** Quits: igl (igl@moz-759C7295.adsl.alicedsl.de) (Ping timeout)
[19:22:02] <bstrie> wonder if I should file an issue for i128, or if we just say that you should use bignums for anything above u64
[19:22:11] *** Joins: igl (igl@moz-BB252A1B.adsl.alicedsl.de)
[19:24:07] <cmr> u128 would be useful for ipv6 values
[19:24:12] <cmr> ...a bit
[19:24:34] <strcat> do you really ever do operations like add/shift/mul/div on them?
[19:24:37] <cmr> no
[19:24:41] <cmr> thus a bit :p
[19:25:23] <cmr> half floats would be useful for graphics, a bit
[19:26:16] *** Joins: Usul (anonymous@moz-AB3CA777.w82-125.abo.wanadoo.fr)
[19:26:31] <tikue> strcat: what is the None adaptor for iterators slated to be called?
[19:26:37] <tikue> fuse?
[19:26:42] <strcat> don't know, that's not decided
[19:26:58] *** Quits: pcwalton (pcwalton@moz-7B0110AD.mv.mozilla.com) (Quit: pcwalton)
[19:27:01] *** Quits: eschweic1 (Adium@moz-BBE3ABD.mv.mozilla.com) (Quit: Leaving.)
[19:27:05] *** Joins: Axord (xord@moz-1B228827.lsanca.dsl-w.verizon.net)
[19:28:39] <Eridius> tikue: that's what it is in my current proposal, but we haven't made a decision yet
[19:28:47] <Sergio965> Would anyone be able to give me a short description of what "upcall_reset_stack_limit" does?
[19:28:51] *** Quits: Usul (anonymous@moz-AB3CA777.w82-125.abo.wanadoo.fr) (Quit: Usul)
[19:29:18] *** Joins: jgilbert (jgilbert@moz-BBE3ABD.mv.mozilla.com)
[19:29:23] <tikue> ah ok
[19:30:23] *** Joins: eschweic (Adium@moz-BBE3ABD.mv.mozilla.com)
[19:30:49] *** Joins: infynyxx (infynyxx@DB780A29.749BA1D.DCC373F0.IP)
[19:31:08] *** Quits: mitja (mitja@moz-4C1E443F.clients.kiwiirc.com) (Quit: http://www.kiwiirc.com/ - A hand crafted IRC client)
[19:32:22] <Sergio965> Or is there somewhere I can read about all of these functions written in C++?
[19:32:29] *** Quits: eatkinson (eatkinson@moz-BBE3ABD.mv.mozilla.com) (Ping timeout)
[19:35:59] <strcat> this is a mess, really need to add a special handler like the atomic ones
[19:36:50] <tjc> Is there any documentation about what you're allowed to capture in an @-closure?
[19:41:45] *** Quits: FrozenCow (FrozenCow@moz-B2DF4929.chello.nl) (Ping timeout)
[19:41:51] <brson> awesome, graydon. thanks
[19:41:57] <bstrie> tjc: are @-closures going away?
[19:42:12] <tjc> bstrie: IDK, but they're definitely there now!
[19:42:17] <mcpherrin> strcat: I do shifting, masking, addition on IPv6 addresses all the time ... but I also make networking hardware...
[19:42:40] <mcpherrin> Don't think I've ever multiplied or divided though.
[19:42:53] <strcat> bstrie: LLVM assert \o/
[19:42:55] *** Joins: mib_7jlvzg (Mibbit@moz-E58ADC33.f3.protectedgroup.com)
[19:43:01] <bstrie> rusti: let x = [1,2,3]; x.iter().fuse()
[19:43:02] -rusti- <anon>:5:26: 6:5 error: type `std::vec::VecIterator<,<VI2>>` does not implement any method in scope named `fuse`
[19:43:02] -rusti- <anon>:5          let x = [1,2,3]; x.iter().fuse()
[19:43:02] -rusti- <anon>:6     };
[19:43:02] *** Quits: mib_7jlvzg (Mibbit@moz-E58ADC33.f3.protectedgroup.com) (User has been banned from Mozilla (no spamming here))
[19:43:02] -rusti- error: aborting due to previous error
[19:43:02] -rusti- application terminated with error code 101
[19:43:02] <strcat> I think I'm unpacking the result wrong
[19:43:52] *** Joins: bbnngg (Mibbit@moz-A9208776.dynamic.tstt.net.tt)
[19:44:36] *** Joins: azita (Azita@moz-9997F785.static.cablecom.ch)
[19:44:37] *** Quits: nano (nano@moz-74CAD1CA.superkabel.de) (Connection reset by peer)
[19:44:50] <bstrie> mcpherrin: do you work on ipv6 addresses as raw u128, or is there a struct/object with a field for each, er, octet
[19:44:53] *** Quits: tjc (tjc@moz-BBE3ABD.mv.mozilla.com) (Quit: Places to go, people to annoy)
[19:45:02] <bstrie> whatever the ipv6 equivalent of an octet is
[19:45:55] <mcpherrin> Array of bytes.
[19:46:22] *** Joins: eatkinson (eatkinson@moz-BBE3ABD.mv.mozilla.com)
[19:46:42] <mcpherrin> Though I can see having 'em as a u128 being useful.
[19:47:25] *** Quits: azita (Azita@moz-9997F785.static.cablecom.ch) (Ping timeout)
[19:49:08] <strcat> rusti: concat_idents!(i16, t)
[19:49:08] -rusti- <anon>:5:9: 6:5 error: unresolved name `i16t`.
[19:49:08] -rusti- <anon>:5          concat_idents!(i16, t)
[19:49:08] -rusti- <anon>:6     };
[19:49:08] -rusti- error: aborting due to previous error
[19:49:09] -rusti- application terminated with error code 101
[19:49:21] <strcat> rusti: macro_rules! foo( ($t: ty) => { concat_idents!($t, abc) } ) foo!(i16)
[19:49:21] -rusti- <anon>:5:41: 5:64 error: concat_idents! requires ident args.
[19:49:21] -rusti- <anon>:5          macro_rules! foo( ($t: ty) => { concat_idents!($t, abc) } ) foo!(i16)
[19:49:22] -rusti-                                                   ^~~~~~~~~~~~~~~~~~~~~~~
[19:49:22] -rusti- application terminated with error code 101
[19:49:36] <Eridius> strcat: I just fixed the Range DoubleEndedIter PR
[19:49:46] * strcat is confused
[19:49:57] *** Quits: ecr (Thunderbir@moz-BBE3ABD.mv.mozilla.com) (Ping timeout)
[19:50:08] <pauls> strcat: concat_idents! can't be used in any interesting positions, anyways.
[19:50:28] <strcat> pauls: so, is there no way to generate a method name atm?
[19:50:35] <strcat> type_name + _some_stuff
[19:50:57] <pauls> strcat: nope. macro invocations can't occur in identifier position.
[19:51:09] <strcat> I am thinking about this wrong anyway
[19:51:37] *** Quits: eschweic (Adium@moz-BBE3ABD.mv.mozilla.com) (Quit: Leaving.)
[19:51:37] <strcat> I'll just do it less generically than I wanted ;p
[19:52:44] <pauls> There's a ML discussion about this, if you want to know about ways that `concat_idents!`-like things could work in the future.
[19:53:48] <Eridius> strcat: now that Saturating is in I just tossed a couple more PRs your way
[19:53:59] <Eridius> also, I'm going on vacation starting this evening, so I won't be very responsive for the next week
[19:53:59] <strcat> okay, will look in a bit
[19:54:56] *** Joins: Jesin (Jessin_@moz-1B1307FF.eecs.lehigh.edu)
[19:55:05] *** Joins: mkohler (mkohler@moz-1531EE3.dclient.hispeed.ch)
[19:56:32] *** Joins: dim-an (ermolovd@moz-FE167E47.nationalcablenetworks.ru)
[19:59:04] *** Joins: pcwalton (pcwalton@moz-7B0110AD.mv.mozilla.com)
[19:59:04] *** ChanServ sets mode: +o pcwalton
[19:59:09] *** Quits: robarnold (rob@BD56354E.DB510C09.6E370BFC.IP) (Ping timeout)
[20:00:24] <Sergio965> Is there any way to get straight text substitution with the macros? I'd like to define several functions using a macro.
[20:00:32] *** Joins: azita (Azita@moz-7006857.static.cablecom.ch)
[20:01:09] *** Quits: barosl (barosl@E287D94F.C81E10FB.7544CABF.IP) (Quit: ëžœë¤ì€ ì‡ í‡´í–ˆìŠµë‹ˆë‹¤.)
[20:01:15] <pauls> Sergio965: you can define items (including function definitions) with macros.
[20:01:36] *** Quits: brendan (brendaneic@moz-BBE3ABD.mv.mozilla.com) (Quit: brendan)
[20:01:57] <pauls> You just do the obvious thing; nothing special is required.
[20:01:58] *** Joins: robertknight (robertknig@moz-AB0E96D7.range86-162.btcentralplus.com)
[20:02:07] *** Quits: eatkinson (eatkinson@moz-BBE3ABD.mv.mozilla.com) (Quit: eatkinson)
[20:03:37] *** Joins: brendan (brendaneic@moz-BBE3ABD.mv.mozilla.com)
[20:03:42] <pcwalton> brson: have you seen this?
[20:03:48] <pcwalton> run: x86_64-apple-darwin/stage2/test/rustitest-x86_64-apple-darwin
[20:03:48] <pcwalton> running 16 tests
[20:03:48] <pcwalton> test tests::exit_quits ... ok
[20:03:48] <pcwalton> Assertion failed: (readers > 0 && "Reader lock not acquired before release!"), function reader_release, file /Users/pwalton/Source/rust/master/src/llvm/include/llvm/Support/RWMutex.h, line 109.
[20:04:36] <acrichto> pcwalton: what's the backtrace for that?
[20:04:41] <pcwalton> acrichto: not sure
[20:04:47] <acrichto> pcwalton: rusti tests are re-disabled on master tw
[20:04:48] <pcwalton> haven't thrown gdb at it
[20:04:50] <pcwalton> ok
[20:05:04] *** Joins: chii (Mibbit@BBE7C46A.B4F11D08.8612FA94.IP)
[20:05:52] <Sergio965> pauls: Ah, thanks. I had missed the "ident" fragment specifier.
[20:06:07] <sfackler> acrichto: do you want to let https://github.com/mozilla/rust/pull/8362 go through as is, or should it include huonw's suggestion of env! and option_env!?
[20:06:23] *** Joins: doomlord (doomlod@moz-13E69BC8.range86-180.btcentralplus.com)
[20:07:09] <acrichto> sfackler: yeah I'm not the biggest fan of the name option_env, but from the usage it seems like most of them want a required variable. Maybe it should just be a required environment variable during compilation regardless...
[20:08:19] <acrichto> sfackler: although there's a few ways to go so I'm going to remove the r+ for now once I think about it
[20:08:58] <sfackler> cool.
[20:09:23] *** Joins: mitja (mitja@moz-E7EA111C.clients.kiwiirc.com)
[20:09:40] <miloshadzic> what does the 'a thing mean here https://gist.github.com/miloshadzic/6178081
[20:10:17] <sfackler> fwiw, I think that using an environment variable to override behavior at compile time is a valid enough use case to have some version of env! that doesn't fail
[20:10:17] *** Quits: Florob (Florob@moz-39532932.de) (Client exited)
[20:11:57] <Sergio965> Is there a way to escape a `$` in a macro?
[20:12:19] <doomlord> http://pastebin.com/qHXWPxUT <<<  how is filter supposed to work
[20:12:31] <pauls> Sergio965: not yet, I believe
[20:12:37] <Sergio965> :(
[20:12:48] <Sergio965> So I can't define a macro that defines macros? :'(
[20:13:02] <strcat> doomlord: it's already an iterator
[20:13:11] <strcat> no need to call .iter()
[20:13:34] *** Joins: Marc_ (chatzilla@moz-7CF63585.fbx.proxad.net)
[20:13:36] <doomlord> eliminate the 'collect()', ?
[20:13:47] <sfackler> miloschadzic: It's a lifetime. There's a tutorial on them here: http://static.rust-lang.org/doc/tutorial-borrowed-ptr.html
[20:13:51] <strcat> doomlord: both
[20:13:53] <pauls> Sergio965: not if it needs to have parameters, I'm afraid.
[20:13:53] <doomlord> ^eliminate the colect & for .iter()
[20:14:32] <strcat> rusti: range(0, 10).filter(|x| *x & 1 == 0).to_owned_vec()
[20:14:33] -rusti- ~[0, 2, 4, 6, 8]
[20:14:33] <sfackler> the basic idea is that the funciton returns a pointer to stuff inside of the data structure, so it would be unsafe to use that pointer after the data structure disappears
[20:14:39] <doomlord> ok i'm getting in a twist with mutable vs immutable
[20:14:55] <doomlord> (something else in my context is breaking it when i filter..)
[20:14:59] <sfackler> so you declare that you're returning a pointer that is valid as long as the self object is
[20:15:03] <strcat> rusti: for x in range(0, 6).filter(|x| *x & 1 == 0) { printfln("%d", x) }
[20:15:04] -rusti- <anon>:5:56: 5:64 error: unresolved name `printfln`.
[20:15:04] -rusti- <anon>:5          for x in range(0, 6).filter(|x| *x & 1 == 0) { printfln("%d", x) }
[20:15:04] -rusti-                                                                  ^~~~~~~~
[20:15:04] -rusti- error: aborting due to previous error
[20:15:04] -rusti- application terminated with error code 101
[20:15:07] <strcat> rusti: for x in range(0, 6).filter(|x| *x & 1 == 0) { printfln!("%d", x) }
[20:15:07] -rusti- 0
[20:15:07] -rusti- 2
[20:15:09] -rusti- 4
[20:15:11] -rusti- ()
[20:15:20] <jedestep> apparently, casting arcane sight reveals an overwhelming aura of transmutation magic
[20:15:31] *** Quits: Houm (Houm@moz-25669AA8.fbx.proxad.net) (Ping timeout)
[20:15:31] <jedestep> were it not for the std::local_data docs I would have never known this
[20:16:09] <acrichto> sfackler: how about env! == compile time error if not specified and env_option! == what it currently does?
[20:16:35] <kmc> that would depend on whether people nearby are using transmutation magic!
[20:16:42] <sfackler> that's what I was thinking. env! should take an optional second parameter to have a custom error message
[20:17:08] <acrichto> sfackler: sounds good to me
[20:17:59] <pcwalton> brson: r? https://github.com/mozilla/rust/pull/8378
[20:18:16] <graydon> strcat: http://buildbot.rust-lang.org/builders/doc/builds/504 broken doc build
[20:18:31] <jedestep> kmc: aaah, that explains it. 
[20:18:46] <sfackler> acrichto: is there any infrastructure in the testing framework to define/undefine environment variables to test all of the funcitonality out?
[20:18:54] <strcat> graydon: weird
[20:19:04] *** Joins: diegoyam (quassel@FF9B1514.A4EC3D18.3A1EC144.IP)
[20:19:06] * strcat didn't add those
[20:19:07] <acrichto> sfackler: yeah the compile-fail and run-pass tests have a "// env" option
[20:19:10] <strcat> maybe it needs a forced LLVM clean
[20:19:14] <sfackler> sweet
[20:19:34] <acrichto> sfackler: * // exec-env
[20:22:41] *** Joins: Adam^^ (bgm@3D286504.3FDCAA1F.60148B50.IP)
[20:23:08] *** Joins: ghrust (ghrust@F6EE6DE3.6A2AE50.F3114085.IP)
[20:23:08] <ghrust> 01[13rust01] 15bors pushed 0 new commits to 06auto: 02http://git.io/f0aOfQ
[20:23:08] *** Parts: ghrust (ghrust@F6EE6DE3.6A2AE50.F3114085.IP) ()
[20:23:11] *** Joins: ghrust (ghrust@F6EE6DE3.6A2AE50.F3114085.IP)
[20:23:11] <ghrust> 01[13rust01] 15bors pushed 5 new commits to 06auto: 02http://git.io/7KZ6Yw
[20:23:11] <ghrust> 13rust/06auto 145c08237 15Erick Tryzelaar: option.get -> option.unwrap
[20:23:11] <ghrust> 13rust/06auto 149218aaa 15Erick Tryzelaar: std: add result.map_move, result.map_err_move
[20:23:11] <ghrust> 13rust/06auto 141e49081 15Erick Tryzelaar: core: option.map_consume -> option.map_move
[20:23:13] *** Parts: ghrust (ghrust@F6EE6DE3.6A2AE50.F3114085.IP) ()
[20:25:01] *** Parts: Adam^^ (bgm@3D286504.3FDCAA1F.60148B50.IP) ()
[20:25:03] <mkohler> I may be stupid, but how can I iterate over a vector?
[20:25:50] <engla> mkohler: for &x in v.iter() {  ... }
[20:25:55] <graydon> mkohler: which version of rust? we changed the for loop recently.
[20:26:46] *** Quits: jgilbert (jgilbert@moz-BBE3ABD.mv.mozilla.com) (Ping timeout)
[20:26:54] <strcat> rusti: let xs = [1, 2, 3]; for x in xs { printfln!("%d", *x) }
[20:26:54] -rusti- <anon>:5:29: 6:5 error: type `&mut [<VI2>, .. 3]` does not implement any method in scope named `next`
[20:26:54] -rusti- <anon>:5          let xs = [1, 2, 3]; for x in xs { printfln!("%d", *x) }
[20:26:54] -rusti- <anon>:6     };
[20:26:55] -rusti- error: aborting due to previous error
[20:26:55] -rusti- application terminated with error code 101
[20:26:57] *** Joins: steven_is_false (user@C5B76363.1FF1EBF8.1ECA502.IP)
[20:26:58] *** Joins: jgilbert (jgilbert@moz-7B0110AD.mv.mozilla.com)
[20:27:03] <strcat> rusti: let xs = [1, 2, 3]; for x in xs.iter() { printfln!("%d", *x) }
[20:27:03] -rusti- 1
[20:27:03] -rusti- 2
[20:27:04] -rusti- 3
[20:27:04] -rusti- ()
[20:27:11] <steven_is_false> Is -1 valid to put in a c style enum for Rust?
[20:27:23] <strcat> rusti: let mut xs = [1, 2, 3]; for x in xs.mut_iter() { *x += 2 } xs
[20:27:24] -rusti- [3, 4, 5]
[20:27:35] <steven_is_false> Eg) pub enum Sign { Forward = 1, Zero = 0, Backward = -1 }
[20:27:54] *** Quits: azita (Azita@moz-7006857.static.cablecom.ch) (Quit: azita)
[20:28:01] <engla> steven_is_false: yes. That's what Ordering does at least
[20:28:07] <steven_is_false> engla: Great.
[20:28:12] <engla> rusti: std::cmp::Less as int
[20:28:13] -rusti- -1
[20:28:19] *** Joins: int3_ (int3_@moz-ABE52D50.hsd1.ca.comcast.net)
[20:28:20] <mkohler> graydon: still using 0.6
[20:28:51] <graydon> mkohler: for [1,2,3].each |v| { println(fmt!("%d", *v); }
[20:28:57] <graydon> er
[20:28:58] <graydon> ))
[20:29:21] <elly> hey all
[20:30:18] <mkohler> graydon: does it need to be [1,2,3].each or can I use *foo.each?
[20:30:43] <graydon> mkohler: foo.each will also work
[20:31:00] <shachaf> hi elly
[20:32:03] *** Quits: mschifer (Adium@moz-BBE3ABD.mv.mozilla.com) (Connection reset by peer)
[20:32:03] *** Joins: mschifer (Adium@moz-BBE3ABD.mv.mozilla.com)
[20:32:05] <mkohler> graydon: seems to work, but I got a lot of other errors to fix now :) thanks
[20:32:32] <doomlord> http://pastebin.com/wN3uTpNg  <<<this is weird, seems it doesn't like splitting the expression up. 
[20:33:22] <engla> doomlord: store it in a mutable slot
[20:33:50] <engla> doomlord: let must be 'let mut'
[20:34:02] <doomlord> ok that works.
[20:34:41] <doomlord> i didn't realise it was actually mutable - my context shouldn't need it... and (2) i didn't realise it wouldn't just inherit mutability fromthe expression
[20:34:44] <doomlord> thanks
[20:35:26] <engla> well the iterator is like a loop counter
[20:35:32] <doomlord> i did try 'asking the type' with let refs1:()= ... and the compiler didn't seem to say mutable, maybe i was just getting lost in errors
[20:35:33] <engla> and a loop counter is mutable
[20:35:48] <doomlord> AHHH. of course.
[20:36:02] <doomlord> its an iterator, not a 'lazy collection' 
[20:36:07] <Sergio965> Is there a difference between uint and u32, or does that depend on the hardware? (Ie, 32 bits on 32-bit machines, 64 bits on 64 bit machines)
[20:36:12] *** Parts: steven_is_false (user@C5B76363.1FF1EBF8.1ECA502.IP) (ERC Version 5.3 (IRC client for Emacs))
[20:36:21] <kmc> src/rt/ :)
[20:36:26] <kmc> er whoops was way scrolled up
[20:36:37] <strcat> Sergio965: uint/int is the same size as a ptr
[20:36:45] *** Quits: bbnngg (Mibbit@moz-A9208776.dynamic.tstt.net.tt) (Quit: http://www.mibbit.com ajax IRC Client)
[20:36:57] <Sergio965> Sounds good, thanks.
[20:37:39] *** Joins: bnngg (Mibbit@moz-D1E2A18D.dynamic.tstt.net.tt)
[20:38:23] <kmc> is that strictly guaranteed? what about architectures where the biggest native arithmetic size is smaller than a pointer?
[20:38:44] <doomlord> ok that works , but i still dont know why my first attempt didn'twork either:    let refs1 = refs.iter().filter(|x|true).collect();   for r in refs1.iter() { <<<< "error: the typeof thisvalue (refs1.iter()) must be known in this context" <<<it doesn't appear to infer that right
[20:38:53] <strcat> kmc: rust doesn't run on any, so it hasn't come up
[20:38:57] <kmc> :)
[20:39:13] <doomlord> i'm going for 'collect' because there's a sort to do...
[20:39:15] <strcat> uint/int are the same as uintptr_t/intptr_t though (uintptr_t is a size_t alias)
[20:40:25] <graydon> doomlord: collect() collects into any container. you want to_owned_vec()
[20:40:38] <Sergio965> Is there any way to declare an empty, stack allocated vector?
[20:40:52] <graydon> Sergio965: of what size?
[20:40:52] <jeaye> OS X: make: *** No rule to make target `/Users/jeaye/projects/rust/src/llvm//lib/CodeGen/CodePlacementOpt.cpp
[20:41:00] <Sergio965> graydon: 33.
[20:41:01] <heftig> Sergio965: you couldn't resize it
[20:41:05] <Sergio965> Yeah.
[20:41:09] <Sergio965> I don't need to resize it.
[20:41:10] <graydon> Sergio965: "let mut x = [0,..33];"
[20:41:43] <Sergio965> Huh.
[20:41:51] <Sergio965> Neat. Thanks!
[20:41:58] <doomlord> ok thanks, that works, i can clean up a lot of imperative code now :)
[20:42:00] <Sergio965> (P.S: Stuff like this should be in the tutorial.)
[20:42:05] <Sergio965> (and/or manual)
[20:42:33] *** Quits: yong (chatzilla@89F941DF.4E87ADC2.263D9828.IP) (Quit: ChatZilla 0.9.90.1 [Firefox 22.0/20130618035212])
[20:42:36] <Sergio965> What type of vector is that?
[20:42:50] <Sergio965> Can I do: let x: [u8, ..33] = [0, ..33]?
[20:43:16] <kmc> rusti: let x = [0u8, ..33]; x
[20:43:17] -rusti- [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]
[20:43:31] <Sergio965> Ah, indeed.
[20:43:33] <Ms2ger> <till> can't Rust in theory also consume C++ APIs?
[20:43:37] <Ms2ger> Experts?
[20:43:38] <Sergio965> Thanks again.
[20:43:48] <graydon> Ms2ger: "consume"?
[20:43:51] <doomlord> overloading and templates...
[20:44:06] <bstrie> Ms2ger: in theory, if someone implements it, and only for certain subsets of C++ and C++ compilers :P
[20:44:08] <kmc> Ms2ger: only through extern "C" wrappers on both sides
[20:44:12] <Ms2ger> graydon, use JSAPI
[20:44:24] <graydon> Ms2ger: not directly, no. only through extern "C" stuff.
[20:44:44] <kmc> Ms2ger: are you looking for https://github.com/mozilla-servo/rust-mozjs
[20:45:05] *** Quits: brson (brson@moz-BBE3ABD.mv.mozilla.com) (Ping timeout)
[20:45:05] <Ms2ger> kmc, no, I'm looking for something not a year out of date :)
[20:45:11] <kmc> ah :)
[20:45:24] <kmc> we would be very pleased if you brought it up to date :)
[20:45:38] <Ms2ger> Heh
[20:45:41] <kmc> is writing new bindings from scratch really a more appealing idea?
[20:46:48] *** Quits: maxli (maxli@13F2CEC5.7672369.D8E68FF6.IP) (Quit: Leaving.)
[20:50:48] *** Quits: pnkfelix (pnkfelix@moz-43495417.fbx.proxad.net) (Quit: Leaving.)
[20:51:03] *** Quits: infynyxx (infynyxx@DB780A29.749BA1D.DCC373F0.IP) (Client exited)
[20:53:02] *** Quits: Marc_ (chatzilla@moz-7CF63585.fbx.proxad.net) (Ping timeout)
[20:55:45] <Sergio965> Is there a way to `use` a module for everything in a crate at once?
[20:57:24] *** Joins: Nisstyre (wes@moz-FD86289.netflash.net)
[20:57:35] <graydon> Sergio965: like import all the item names unqualified into the current module?
[20:58:02] <Sergio965> Well, I have a module, `util`, with functions I'd like to be able to use anywhere.
[20:58:15] <Sergio965> Ideally, without having to do: use util::*;
[21:00:18] *** Joins: alex-abreu (alex@moz-7421D6C9.mc.videotron.ca)
[21:01:31] *** Joins: eatkinson (eatkinson@moz-BBE3ABD.mv.mozilla.com)
[21:01:40] *** Joins: ecr (Thunderbir@moz-BBE3ABD.mv.mozilla.com)
[21:01:49] *** Quits: devinus (devinus@moz-B4AF84BC.ptr.us.xo.net) (Quit: Textual IRC Client: www.textualapp.com)
[21:01:52] *** Joins: eschweic (Adium@moz-BBE3ABD.mv.mozilla.com)
[21:08:25] *** Quits: n0v (n0v@moz-690FFF9D.org) (Ping timeout)
[21:08:56] <graydon> Sergio965: oh, you want a module in your crate to be auto-imported-everywhere, like the prelude or such?
[21:08:58] <doomlord> is there anything like sort with a lambda to produce a temporary sort value , or should i implement operator overloads to allow qsort to work?
[21:09:02] <graydon> we don't have support for that.
[21:09:11] *** Joins: n0v (n0v@moz-690FFF9D.org)
[21:09:13] <Sergio965> Yeah.
[21:09:16] <Sergio965> Alrighty then.
[21:09:23] <graydon> doomlord: yeah, there's a sort-with-a-fn
[21:09:31] *** Quits: victorporof (victorporo@B4B1C8EE.73B1E539.9B1E38F4.IP) (Quit: victorporof)
[21:09:46] <graydon> doomlord: sort::qsort<T> takes a compare_func
[21:09:47] <cmr> https://github.com/seliopou/typo
[21:09:53] <graydon> er, quick_sort
[21:09:59] <cmr> "Typo is a programming language that runs in Haskell's type system. All computation happens in Haskell's type system. A Typo program is compiled to a Haskell module that's then typechecked to compute the result. "
[21:10:09] <doomlord> ok i see it
[21:10:17] <cmr> As cool as that is, it is also frightening.
[21:10:40] <graydon> cmr: the turing cliff is very narrow
[21:11:16] <doomlord> fn qsort<T>(arr:&mut [T], left:uint, right:uint, compare_func: Le<T>) ... i guess thats what i want
[21:11:43] *** Joins: brson (brson@moz-BBE3ABD.mv.mozilla.com)
[21:11:43] *** ChanServ sets mode: +o brson
[21:12:27] <mkohler> I got fn foo(bar: ~vector) but this doesn't seem to be right since it says "undeclared  type". what's the correct type for a vector? using 0.6
[21:12:57] <cmr> mkohler: Don't use 0.6, is the easy solution
[21:13:04] <cmr> It's 6 months old
[21:13:10] <cmr> which is, like, forever, in Rust time
[21:13:16] <cmr> (7 months old now, actually)
[21:13:18] <engla> the type is unchanged though, it is  ~[T]  where T is the element type
[21:13:27] <cmr> mkohler: I wouldn't even recommend using 0.7!
[21:13:32] <cmr> But yes, what engla said
[21:13:32] <Ms2ger> graydon, as in, if it's somewhat expressive, it's probably Turing complete?
[21:13:34] <brson> how do you make a type uncopyable?
[21:13:44] <cmr> brson: don't implement Clone, implement Drop
[21:13:59] <strcat> brson: ideally, include util::NonCopyable as a field
[21:14:00] <cmr> Types with destructors are only ever moved
[21:14:18] <graydon> Ms2ger: yes
[21:14:23] <brson> I can't change the size of the struct. So #[unsafe_no_drop_flag] Drop is the only way?
[21:14:27] <cmr> NonCopyable will only work if you're in libstd, but you probably want it for the runtime anyway
[21:14:35] <strcat> brson: well NonCopyable just does that for you
[21:14:42] <brson> NonCopyable has size 0?
[21:14:44] <strcat> brson: yes
[21:14:55] <cmr> brson: it's a unit struct, which is also why it's unusable outside of libstd
[21:15:01] *** Quits: msingle (Thunderbir@moz-930E5D97.hr.hr.cox.net) (Quit: msingle)
[21:15:04] <cmr> https://github.com/mozilla/rust/issues/7634
[21:15:09] <brson> ok, thanks
[21:15:19] <mkohler> engla, cmr: thanks
[21:15:42] <cmr> Holy poop, https://github.com/mozilla/rust/pull/8374
[21:15:46] <cmr> acrichto: you are a hero!
[21:16:11] <acrichto> cmr: :)
[21:16:53] *** Quits: dherman (dherman@moz-7B0110AD.mv.mozilla.com) (Ping timeout)
[21:16:55] *** Quits: echristo (echristo@DCF57675.D6CCE4AE.77834EAA.IP) (Quit: echristo)
[21:17:27] <Sergio965> rusti: let mut x = [0u, ..33]; x[2] = 3; x[2];
[21:17:28] -rusti- ()
[21:17:36] <Sergio965> rusti: let mut x = [0u, ..33]; x[2] = 3; x[2]
[21:17:37] -rusti- 3
[21:18:49] *** Quits: Ms2ger (Ms2ger@35CC4A24.2B12F798.F15B0BB3.IP) (Quit: nn)
[21:19:38] *** Quits: robertknight (robertknig@moz-AB0E96D7.range86-162.btcentralplus.com) (Ping timeout)
[21:21:05] <cmr> graydon: Are you making a rollup?
[21:21:08] *** Quits: jaen (jaen@moz-E0979827.copit.pl) (Ping timeout)
[21:21:24] <cmr> strcat: or you?
[21:21:26] <cmr> If not, I am
[21:21:29] <strcat> no
[21:23:15] *** Joins: maxli (maxli@B5559308.9C54E60.2FA4EA88.IP)
[21:23:36] <jedestep> does the cfg attribute have an 'and' construct?
[21:23:43] <cmr> jedestep: the comma
[21:23:47] <cmr> #[cfg(foo, bar)]
[21:23:51] <jedestep> wonderful
[21:24:58] *** Joins: tjc (tjc@moz-BBE3ABD.mv.mozilla.com)
[21:24:58] *** ChanServ sets mode: +o tjc
[21:27:21] *** cade is now known as LeeroyJenkins
[21:29:20] *** Quits: tikue (tkuehn@moz-BBE3ABD.mv.mozilla.com) (Quit: tikue)
[21:29:50] *** Quits: jdm (jdm@13F2CEC5.7672369.D8E68FF6.IP) (Quit: Lost terminal)
[21:29:53] *** Joins: tikue (tkuehn@moz-BBE3ABD.mv.mozilla.com)
[21:32:31] *** LeeroyJenkins is now known as cade
[21:32:35] <mkohler> rusti: let mut foo = ""; foo = "bar"; foo
[21:32:36] -rusti- <anon>:5:17: 5:20 warning: value assigned to `foo` is never read [-W dead-assignment (default)]
[21:32:36] -rusti- <anon>:5          let mut foo = ""; foo = "bar"; foo
[21:32:36] -rusti-                           ^~~
[21:32:36] -rusti- "bar"
[21:32:58] *** Joins: barosl (barosl@E287D94F.C81E10FB.7544CABF.IP)
[21:33:49] *** Joins: SiegeLord (sl@moz-CAF07B4C.hsd1.ma.comcast.net)
[21:34:29] *** Quits: int3_ (int3_@moz-ABE52D50.hsd1.ca.comcast.net) (Client exited)
[21:35:08] *** Quits: brendan (brendaneic@moz-BBE3ABD.mv.mozilla.com) (Quit: brendan)
[21:36:30] *** Quits: tcr (tcr@D26BCFC9.C2203064.EDCE493E.IP) (Client exited)
[21:41:58] *** Quits: brson (brson@moz-BBE3ABD.mv.mozilla.com) (Ping timeout)
[21:42:39] *** Joins: int3_ (int3_@moz-ABE52D50.hsd1.ca.comcast.net)
[21:43:59] *** Quits: int3_ (int3_@moz-ABE52D50.hsd1.ca.comcast.net) (Client exited)
[21:45:49] <Sergio965> So I have a macro to which I pass a type (say, u8), and the macro then implements a trait for the type. Unfortunately, even though I call the macro (my_macro!(u8)), I get: "type `u8` does not implement any method in scope named trait_func". Any ideas?
[21:46:09] <cmr> Sergio965: the trait isn't in scope?
[21:46:17] <Sergio965> It is.
[21:46:23] <cmr> Sergio965: Also, you can use `rustc --pretty expanded` to see the result of macro expansion
[21:46:28] <cmr> double check it's what you expect
[21:46:44] <strcat> bstrie: https://github.com/thestinger/rust/commit/cfa993d6eaf9cf559955b7108d5d3fed68e27683 needs tests now ;p
[21:47:20] <miloshadzic> I'm trying to add a "get_or_default" method to HashMaps but I'm doing something wrong. https://gist.github.com/miloshadzic/6179055
[21:48:09] <Sergio965> They're gone. :|
[21:48:12] *** Quits: Blub\w (wry@7E3BB9D.71150E1A.237AE2BA.IP) (Quit: night)
[21:48:22] <cmr> miloshadzic: default &'a V, I think
[21:48:26] <Sergio965> The macro's expended to nothing? :|
[21:48:32] *** Joins: dwhyte (dwhyte@1922756A.EDC594B0.7BF4A4B0.IP)
[21:48:57] <toddaaro> I'm looking at the seeded xorshift constructor and noticed I need four seeds, is there a good way to generate four seeds with one seed?
[21:49:04] <toddaaro> are there rules for how the various values should relate?
[21:49:14] <cmr> toddaaro: https://github.com/mozilla/rust/issues/8359
[21:49:36] <strcat> and... it failed
[21:49:43] *** Quits: n0v (n0v@moz-690FFF9D.org) (Connection reset by peer)
[21:49:47] <toddaaro> cmr: hm, oh well
[21:50:10] <toddaaro> cmr: I guess I should use the constant seed for now?
[21:50:24] <cmr> toddaaro: I guess. I don't really know the details
[21:50:33] <miloshadzic> cmr, Thanks
[21:50:34] *** Joins: n0v (n0v@moz-690FFF9D.org)
[21:51:20] *** Quits: heftig (heftig@moz-88B5382A.dip0.t-ipconnect.de) (Ping timeout)
[21:51:37] <Sergio965> Why is my macro invocation disspearing?
[21:51:59] *** Joins: futile (futile@moz-49928B15.hsd1.il.comcast.net)
[21:52:06] <cmr> Sergio965: Are you trying to expand to multiple items?
[21:52:07] <futile> Hi :)
[21:52:16] <Sergio965> cmr: Yes, but I use { }.
[21:52:20] <futile> Anyone looking for a good intermediate-sized toy project in Rust?
[21:52:27] *** Quits: spider-mario (spidermari@moz-81131DB6.fbx.proxad.net) (Input/output error)
[21:52:29] <futile> *intermediate-level, not size
[21:52:34] <cmr> futile: Whatever it is I'd love to feature it on TWiR
[21:52:43] <futile> cmr: what's that?
[21:52:58] <cmr> futile: weekly newsletter about the week's changes and stuff in the community
[21:53:04] <pcwalton> hmm, bors cycle time is kind of out of control
[21:53:06] <cmr> http://cmr.github.io/blog/categories/this-week-in-rust/
[21:53:10] <futile> The task is to write a simple Rust client for Zephyros, the scriptable window manager for OS X: https://github.com/sdegutis/zephyros
[21:53:31] <futile> cmr: oh well I'm not sure this is appropriate for that, but I'll leave that up to you :)
[21:53:45] <cmr> futile: Oh, I thought you already had something to show
[21:53:49] <futile> No
[21:53:53] <futile> sorry, I communicate poorly
[21:54:00] <futile> although I try my hardest to improve that
[21:54:05] *** Quits: vk (chatzilla@3E9D68F2.B1163E0C.2A6693DD.IP) (Quit: ChatZilla 0.9.90.1 [Firefox 24.0a2/20130729004005])
[21:54:14] <futile> cmr: well if I or someone else writes it, I'll let you know :)
[21:54:56] <futile> Does Rust come with TCP and JSON libs built in?
[21:55:03] <erickt> pcwalton: can you review my latest version of the de-trailing-null-ifying of strings PR? https://github.com/mozilla/rust/pull/8296
[21:55:23] <cmr> futile: JSON is in extra::json, TCP is currently in-flux, but it's in std::rt::io::net
[21:55:23] <Sergio965> What's happening to my macrroosss.
[21:55:25] <Sergio965> :'(
[21:56:58] <Sergio965> Here's my code: https://gist.github.com/SergioBenitez/6179161
[21:57:07] <Sergio965> The macro invocations at the bottom just disappear. 
[21:57:43] *** Quits: vodik (simon@moz-CBE4BB13.cable.teksavvy.com) (Quit: kernel update)
[21:57:46] <Eridius> cmr: I re-pushed my .chunk() PR, if you wouldn't mind r+'ing again. I removed an edge-case behavior in size_hint() based on comments strcat made on a separate PR
[21:57:48] <sebcrozet> cmr: interesting this TWiR.
[21:58:14] <sebcrozet> Iâ€™ve been working on a few medium-sized projects if you want to cite them :)
[21:58:22] *** Joins: vodik (simon@moz-CBE4BB13.cable.teksavvy.com)
[21:58:27] <cmr> sebcrozet: nalgebra and kiss3d and such, yes
[21:58:30] <cmr> sebcrozet: sure
[21:58:49] *** Joins: bbouvier (bnjbouv@moz-63AFAFBF.gagahome.fr)
[21:58:55] <sebcrozet> cmr: oh, you know them already :p
[21:59:07] <cmr> sebcrozet: You cannot escape my all-seeing github eyes.
[21:59:13] <cmr> Eridius: sure
[21:59:19] *** Joins: ghrust (ghrust@DE823A67.6A2AE50.F3114085.IP)
[21:59:19] <ghrust> 01[13rust01] 15bors merged 06auto into 06master: 02http://git.io/7KZ6Yw
[21:59:19] *** Parts: ghrust (ghrust@DE823A67.6A2AE50.F3114085.IP) ()
[21:59:26] *** Joins: heftig (heftig@moz-D2368502.dip0.t-ipconnect.de)
[21:59:57] <kmc> what brings the lifetime 'self into scope?
[22:00:14] <cmr> kmc: using <'self>
[22:00:16] <cmr> it's not special
[22:00:17] <bblum> impl <'self> or struct Foo<'self>
[22:00:27] <cmr> it's just treated special by the parser in that it rejects everything else in some contexts :p
[22:00:28] <kmc> then what's with "error: Illegal lifetime 'a: only 'self is allowed as part of a type declaration"
[22:00:31] <kmc> ;P
[22:00:39] <cmr> it's a bug
[22:00:42] <bblum> that's not a problem with self, that's a problem with a
[22:00:51] <bblum> it's not really a bug, more a temporary wart
[22:01:13] <cmr> rejecting valid code is a bug in my books *shrug*
[22:01:34] <Sergio965> Anyone have any ideas why the macro invocations at the bottom of https://gist.github.com/SergioBenitez/6179161 expand to nothing?
[22:02:21] *** Joins: ghrust (ghrust@1E8607E8.6A2AE50.F3114085.IP)
[22:02:21] <ghrust> 01[13rust01] 15bors pushed 0 new commits to 06auto: 02http://git.io/0GuS1A
[22:02:21] *** Parts: ghrust (ghrust@1E8607E8.6A2AE50.F3114085.IP) ()
[22:02:23] *** Joins: ghrust (ghrust@AD60B2E3.6A2AE50.F3114085.IP)
[22:02:23] <ghrust> 01[13rust01] 15bors pushed 2 new commits to 06auto: 02http://git.io/GOPRBw
[22:02:23] <ghrust> 13rust/06auto 1417c12bb 15Mihnea Dobrescu-Balaur: Add frequency count to extra::stat. #8281
[22:02:23] <ghrust> 13rust/06auto 14a85f9ac 15bors: auto merge of #8320 : mihneadb/rust/freq_count, r=cmr
[22:02:23] *** Parts: ghrust (ghrust@AD60B2E3.6A2AE50.F3114085.IP) ()
[22:03:06] *** Quits: mihneadb (mihneadb@E48845AB.3A9F9BD4.4C2245EF.IP) (Connection reset by peer)
[22:03:22] *** Joins: mihneadb (mihneadb@E48845AB.3A9F9BD4.4C2245EF.IP)
[22:03:28] <engla> Eridius: a note, it's not all bad that .chunk() yields ~[A] because with a &[A], you can't move out of a slice, like you can from an owned vec
[22:04:09] <graydon> acrichto: ping
[22:04:25] *** Quits: futile (futile@moz-49928B15.hsd1.il.comcast.net) (Quit: Leaving...)
[22:04:28] <acrichto> graydon: pong
[22:04:43] <graydon> acrichto: can you check on the ifmt! thing to see if it generates substantially more or less code than fmt! on a similar format string (with, say, a couple ints and strs)?
[22:04:53] <graydon> I assume less, but am curious
[22:05:02] <acrichto> graydon: ah yes, will do
[22:05:20] *** Quits: lmandel (lmandel@13F2CEC5.7672369.D8E68FF6.IP) (Quit: lmandel)
[22:05:27] *** Quits: donri (dag@moz-9BB61102.tbcn.telia.com) (Client exited)
[22:05:31] *** Joins: int3_ (int3_@moz-ABE52D50.hsd1.ca.comcast.net)
[22:06:03] *** Joins: int3__ (int3_@moz-ABE52D50.hsd1.ca.comcast.net)
[22:06:04] *** Quits: int3_ (int3_@moz-ABE52D50.hsd1.ca.comcast.net) (Connection reset by peer)
[22:06:07] <Sergio965> Have a discovered a bug with the macro system or am I simply doing something wrong?
[22:06:20] <cmr> pauls: see above ^
[22:06:48] *** Joins: fread2281 (Mibbit@moz-CB181B42.dia.static.qwest.net)
[22:06:58] <cmr> Seeing things like GlobIterator makes me sad Globerator wouldn't be widely accepted
[22:08:30] <Sergio965> cmr: Do you see anything wrong with the way I've declared and invoked the macro?
[22:08:35] <cmr> Sergio965: no, I do not
[22:08:45] <cmr> I admit I barely understand or use the macro system, though
[22:09:40] <graydon> acrichto: I'm a little confused about how this works. it looks like it translates the incoming format string to a pretty rich expression.
[22:09:45] <engla> Sergio965: remove the { }  inside ()  I think?
[22:10:05] <graydon> acrichto: I thought the rt::Piece stuff was all going to be built at runtime
[22:10:22] *** Joins: brendan (brendaneic@moz-BBE3ABD.mv.mozilla.com)
[22:10:35] <Sergio965> engla: Bah. That fixed it. I put them there because there was a bug that said I needed them.
[22:11:26] <engla> well that would be for an expression I think, Sergio965 
[22:11:31] <acrichto> graydon: pcwalton/brson suggested investigating having compile-time format strings, so they generate static arrays of rt::Piece instead of re-parsing at runtime, and it turned out to be a huge speedup. For internationalization I think you could still test equivalence of one string to the original string as well
[22:11:41] <fread2281> how could I get https://gist.github.com/fread2281/6179268 to work? slice_from returns a &str that has no append method
[22:12:07] <erickt> graydon: ping
[22:12:16] <graydon> erickt: pong
[22:12:29] <cmr> fread2281: You can only append to strings you can change the size of. And that is ~str.
[22:12:34] <graydon> acrichto: aha, so is the macro split into a static version and a dynamic version?
[22:12:51] <acrichto> graydon: right now there's only a static version
[22:13:03] <erickt> hey there! If you got a moment, can you review https://github.com/mozilla/rust/pull/8296? it's my remove-trailing-nulls-from-string PR. I'm hoping to get it landed before it becomes unmergable again
[22:13:10] <graydon> acrichto: or one that does static by default and then checks / reparses if the one passed in is non-identical?
[22:13:13] <fread2281> cmr: yes, but how can I do what I want to do in that code (append .build to the last fragment of the atom)
[22:13:43] <graydon> acrichto: is the conversation concerning this in IRC logs somewhere I ought to look up? I'm happy to browse for it.
[22:13:47] *** Joins: infynyxx (infynyxx@DB780A29.749BA1D.DCC373F0.IP)
[22:14:09] <acrichto> graydon: there were some comments about performance, but none about translating the format strings
[22:14:14] <cmr> fread2281: build a new string rather than calling name_append
[22:14:17] <cmr> *name.append
[22:14:23] <cmr> fread2281: Or, build a new string rather than using slice_from
[22:14:54] <graydon> erickt: ok. I've turned off bors. I'll review and set as high priority (though I think brson gets top priority with the newrt changes, if he has another go at it ready)
[22:15:04] <cmr> fread2281: You really shouldn't be using PosixPath. We have `GenericPath` and the `Path` wrapper.
[22:15:10] <erickt> graydon: no problem, thanks!
[22:15:19] <graydon> cmr: that should all get redone now that we have default methods
[22:15:46] <erickt> this is going to be a good TWiR week :)
[22:15:56] <cmr> erickt: only if the rt lands! ;p
[22:16:01] <cmr> then it will be average
[22:16:06] <cmr> *otherwise
[22:16:24] <fread2281> cmr: I know this will only ever be used on posix, should I just use ~[~str] or ~str?
[22:16:29] <acrichto> graydon: would you be opposed once all the dust is settled to have `fmt!` be the "fast" version using compile-time format strings and `ifmt!` being the internationalized version that used something like `extra::i18n` and it would be passed the raw string?
[22:16:30] <erickt> cmr: I dunno, I'm potentially breaking everyone's C bindings. That's pretty exciting :)
[22:17:15] <cmr> fread2281: no, PosixPath is fine for that.
[22:17:53] <toddaaro> brson ecr : http://haskell.cs.yale.edu/wp-content/uploads/2013/08/hask035-voellmy.pdf
[22:18:04] <toddaaro> camera ready on the haskell multicore io manager
[22:18:20] <fread2281> cmr: and...how do I build a new string in this case?
[22:18:29] <cmr> fread2281: call to_owned() on the slice
[22:21:31] <kmc> writing external iterators without coroutines makes me sad :/
[22:22:16] <strcat> a context switch on each iteration wouldn't be a great thing
[22:22:40] *** Joins: mindginative (mindginati@moz-C1729134.dsl.clear.net.nz)
[22:22:52] <graydon> acrichto: yeah, that's what I figured we'd do (re: ifmt / fmt)
[22:23:18] <strcat> is LLVM's aggregate ret a convenience method for returning a struct or... does it do something totally different?
[22:23:21] <strcat> I guess I'll see
[22:23:21] <acrichto> graydon: cool, the current iteration is named `ifmt!` then but only because `fmt!` is already taken, it'll actually drop the `i` eventually
[22:23:30] <graydon> acrichto: although if ifmt has a static fast-path and just does a string-compare on for format string to be sure it was given the right one, it might wind up being lost in the noise.
[22:24:33] <graydon> acrichto: I'm also concerned that the "fast path" formats fast but causes a lot of code bloat. part of the goal here was to make the call sites relatively slim.
[22:24:55] <acrichto> graydon: the code bloat is only in more globals presently, it's not at callsites
[22:25:20] <strcat> but each string will generate specialized code, won't it?
[22:25:27] <acrichto> yes
[22:25:32] <graydon> acrichto: are you sure? it looks like it generates a lot of calls to traits.
[22:25:37] <kmc> strcat: the coroutines I have in mind wouldn't necessarily be separate Rust tasks
[22:26:06] <acrichto> graydon: ifmt! only results in one function call to std::fmt::sprintf, everything else is passed in as parameters
[22:26:10] <kmc> it's just frustrating to take an internal iterator fn with a bunch of local state and have to move that state out into a struct (including a recursive callstack sometimes)
[22:26:17] *** Quits: jedestep (jedestep@34641662.FB4DE631.66C78B76.IP) (Ping timeout)
[22:26:34] <strcat> coroutines have a small stack and do context switches to/from it in general afaik
[22:27:08] <kmc> I just want something like 'yield' in Python
[22:27:14] <kmc> but yeah you do need to store the state somewhere
[22:27:15] *** Quits: sebcrozet (sebcrozet@moz-F96421F3.w80-13.abo.wanadoo.fr) (Quit: Gone)
[22:27:29] *** Quits: mihneadb (mihneadb@E48845AB.3A9F9BD4.4C2245EF.IP) (Connection reset by peer)
[22:27:47] <acrichto> graydon: https://gist.github.com/anonymous/6179446 is an example of what the expansion looks like. It looks huge but it's mostly just path names
[22:28:04] <strcat> there's a proposal for something like yield based on a state machine generator, rather than coroutines
[22:28:18] <graydon> acrichto: does it not pass an array of pieces? it looks to me like those struct constructors would generate a fair bit of code, no?
[22:28:34] <acrichto> graydon: they're statics though
[22:28:51] <graydon> acrichto: do we actually compile them into statics?
[22:28:53] <miloshadzic> is it possible to run tests only from say hashmap.rs?
[22:29:14] <kmc> perhaps I need to learn more of the iterator combinators
[22:29:17] <graydon> acrichto: I don't think we opportunistically find and compile-as-a-static things which are static.
[22:29:22] <cmr> miloshadzic: ./stdtest-... hashmap
[22:29:23] <graydon> acrichto: I mean, we _should_!
[22:29:34] <miloshadzic> cmr, thanks
[22:29:36] <acrichto> graydon: yeah each format string is converted into a 'pub static __static_fmtstr' so it's explicitly listed as a static I thought?
[22:29:38] <graydon> as part of our long standing "need to actually attack static / const" bug-world
[22:29:39] <cmr> miloshadzic: or, make check TESTNAME=hashmap
[22:29:49] <cmr> I think that's the incantation
[22:29:58] <acrichto> graydon: I thought that all static variables were constants at compile-time, but I could be wrong...
[22:30:04] <graydon> oh! I see
[22:30:09] <miloshadzic> bare make check takes ages as far as I can tell
[22:30:09] <graydon> I'm sorry, I misunderstood the translation
[22:30:27] <graydon> I thought those were constant-expressions that were "effectively" static
[22:30:34] <graydon> you're actually putting them in static items, I see.
[22:30:51] <acrichto> oh yeah the current fmt! puts them in "constant" expressions
[22:30:55] <acrichto> I wanted to avoid that
[22:31:25] <kmc> strcat: the state machine thing sounds interesting
[22:31:32] <graydon> yeah. we don't promote constant expressions to implicit statics, which we should (at least if all you do with them is take their address / copy them)
[22:31:47] <graydon> acrichto: ok. this is pretty good looking then.
[22:31:55] <graydon> acrichto: anything else I should be concerned about? :)
[22:32:10] <acrichto> graydon: everything about format specifiers is completely broken
[22:32:21] <graydon> sure
[22:32:23] <acrichto> graydon: if you do something like "{:08x}" it's just ignored right now
[22:32:26] <acrichto> but soon!
[22:32:31] <graydon> I figured there's much to be done there
[22:32:35] <graydon> that's sorta the easy part
[22:32:36] <acrichto> I wanted to land this and then bikeshed what that syntax should be
[22:32:36] <graydon> (ish)
[22:32:38] <acrichto> yeah lol
[22:32:51] <acrichto> although that should be about all that's left
[22:32:52] *** Quits: tikue (tkuehn@moz-BBE3ABD.mv.mozilla.com) (Quit: tikue)
[22:33:04] <acrichto> apart from optimizing all the paths of formatting to perform no allocations
[22:33:07] *** Joins: mihneadb (mihneadb@E48845AB.3A9F9BD4.4C2245EF.IP)
[22:33:09] <graydon> so um, is the parser interface organized such that it can be called at runtime still?
[22:33:14] <acrichto> yes
[22:33:15] <graydon> I think so..
[22:33:28] <graydon> yeah, ok. just checking. I'd like to keep the i18n version working / non-bitrotted
[22:33:32] <acrichto> it's even an iterator! "for piece in Parser::new(string) {}"
[22:33:34] <graydon> part of the point of this, etc. etc.
[22:33:43] <acrichto> of course :)
[22:34:01] <acrichto> oh so one thing I thought of is that these static format strings could be passed to the translator
[22:34:15] <acrichto> so it wouldn't have to re-parse, but there's one piece of information which is lost: named arguments
[22:34:17] <Eridius> engla: if it yielded &[A] you could call .to_owned() on it and then treat it the same as if it yielded ~[A]
[22:34:20] *** Joins: tikue (tkuehn@moz-BBE3ABD.mv.mozilla.com)
[22:34:45] <engla> sure, that's only for A: Clone though
[22:35:10] <acrichto> graydon: basically with named arguments things would have to change a little bit for a translator. The current scheme is that all named arguments are assigned locations at the end of the `args` array, but that loses their name
[22:35:22] <Eridius> engla: good point
[22:35:39] <acrichto> graydon: but that's a pretty minor detail that would be pretty easy to fix (some more static data), so I don't think it's too much of a problem
[22:35:49] <graydon> acrichto: yeah, I noticed the named-args thing, not sure about that. but this is a good rough sketch. it doesn't hurt anything to land it now, I think it's going in the right direction.
[22:36:15] *** Quits: doomlord (doomlod@moz-13E69BC8.range86-180.btcentralplus.com) (Ping timeout)
[22:36:57] <graydon> erickt: ping re CString
[22:37:52] <kmc> "impl<'self> Iterator<(uint, &GlyphInfo<'self>)> for GlyphIndexIterator<'self>"  gives me  "error: Illegal anonymous lifetime: anonymous lifetimes are not permitted here"
[22:37:56] <kmc> on the &GlyphInfo part
[22:38:00] <kmc> and I can't use any lifetime names other than 'self
[22:38:20] <kmc> oh it should be &'self GlyphInfo
[22:38:23] <olsonjeffery> brson: ping
[22:38:37] <kmc> sorry :)
[22:39:30] *** Joins: brson (brson@moz-BBE3ABD.mv.mozilla.com)
[22:39:30] *** ChanServ sets mode: +o brson
[22:39:40] <brson> oops, got distracted for 4 hours
[22:39:52] *** Quits: peterdn (chatzilla@moz-97742234.new.ox.ac.uk) (Ping timeout)
[22:40:13] <tikue> lol
[22:40:38] *** Quits: mihneadb (mihneadb@E48845AB.3A9F9BD4.4C2245EF.IP) (Ping timeout)
[22:40:42] <graydon> erickt: it's not clear to me this guarantees the string is null terminated, either on construction or projection to a vec. it just forms a vec of len+1?
[22:41:03] <olsonjeffery> brson: ping
[22:41:19] <SiegeLord> I'm reading a BitC mailing list thread where Jonathan Shapiro claims that Rust's traits are not "link-safe"... is he correct?
[22:41:31] <cmr> SiegeLord: no
[22:41:33] <SiegeLord> Here's a link to the post: http://www.coyotos.org/pipermail/bitc-dev/2013-July/003580.html
[22:41:52] <brson> olsonjeffery: pong
[22:42:14] <olsonjeffery> brson: so terminate_current_task in sched.rs, where it does 'let stask = this.sched_task.take_unwrap()' is where the failure happens, when the GreenTask is shutting down.. as you predicted
[22:42:30] <olsonjeffery> so im debug printing the contents of the sched at that time and sched_task is, indeed, None
[22:42:41] <olsonjeffery> which i guess happens when switching into the SchedTask ..
[22:42:56] <pcwalton> typecheck check_expr is a 1,500+ line function
[22:43:25] <olsonjeffery> brson: im thinking that maybe its the way that try_send_inner, comm.rs, calls directly to Scheduler::run_task() in the case where a port is blocked and waiting and do_resched = true
[22:43:37] <olsonjeffery> and that that's where the breakdown is..
[22:43:40] *** Quits: Sergio965 (sergiobz@BE9C9272.E63B31F7.3A99D594.IP) (Quit: My MacBook Pro has gone to sleep. ZZZzzzâ€¦)
[22:43:43] <olsonjeffery> so, i guess.. how to fix that.
[22:45:01] *** Joins: mihneadb (mihneadb@E48845AB.3A9F9BD4.4C2245EF.IP)
[22:45:01] <olsonjeffery> i would want to 1) get the current task that the method is running within 2) check the task_type .. 3) if its a SchedTask, then set .sched_task on the running Scheduler to the running task 4) carry on as before..
[22:45:17] <olsonjeffery> is that the wrong approach or even technically feasible?
[22:45:37] <bblum> Instead of the poems I had hoped for, there came only a shuddering crash and ineffable assertion message, and I saw at last a fearful bug that which no one had ever dared to fix before.
[22:45:50] <olsonjeffery> hee.
[22:45:59] *** Quits: chii (Mibbit@BBE7C46A.B4F11D08.8612FA94.IP) (Quit: http://www.mibbit.com ajax IRC Client)
[22:46:30] <brson> olsonjeffery: one sec. sorry
[22:46:47] <strcat> pcwalton: is there a convenient way of taking 2 ValueRef and turning them into a struct? don't really want to reinvent the wheel
[22:47:01] *** Quits: mschifer (Adium@moz-BBE3ABD.mv.mozilla.com) (Quit: Leaving.)
[22:47:15] <pcwalton> there's C_struct in constants and otherwise you have to alloca up a T_struct and do stores
[22:47:28] <pcwalton> to the individual fields, don't store a first class struct value
[22:49:09] *** Quits: RMF (RMF@moz-2758EDDD.dsl.telepac.pt) (Quit: Textual IRC Client: www.textualapp.com)
[22:51:21] <graydon> olsonjeffery: ping
[22:52:16] <olsonjeffery> graydon: pong
[22:53:02] *** Quits: dim-an (ermolovd@moz-FE167E47.nationalcablenetworks.ru) (Quit: dim-an)
[22:53:34] <graydon> olsonjeffery: you did timer, right?
[22:53:42] <graydon> rtio timer
[22:53:44] <olsonjeffery> yes.
[22:53:52] <graydon> mm
[22:54:04] <brson> olsonjeffery: looking at try_send_inner
[22:54:29] <graydon> have you given any thought to doing another of those? I tried the other day and I got pretty overwhelmed. I wanted to get stdio / file descriptor stuff working
[22:54:38] <tjc> wow, I just rebased a branch of mine that was so old it still had structural records
[22:54:45] <olsonjeffery> graydon: im working on flushing out aio, currently.
[22:54:53] <olsonjeffery> but, yeah.. file io would be nifty.
[22:54:58] <graydon> olsonjeffery: aio?
[22:54:59] <brson> olsonjeffery: yeah the comment for `run_task` says 'task context case', so it seems like it could be wrong
[22:55:07] *** Joins: dherman (dherman@moz-6CA476B1.hsd1.ca.comcast.net)
[22:55:07] *** ChanServ sets mode: +o dherman
[22:55:32] <olsonjeffery> graydon: yeah.. bikeshedding aio as a paralell to io.. uses the same underlying primitives in rt::uv .. but returns Futures where aprop..
[22:55:39] <graydon> olsonjeffery: this feels a bit premature. the whole point of the new io interface is it lets us do sync io efficiently on a task, descheduling when we issue the call, no?
[22:55:51] <olsonjeffery> graydon: fair enough.
[22:55:53] <graydon> tjc: !
[22:56:19] <graydon> olsonjeffery: sorry, I guess that's a little blunt; I just keep running into people telling me they read std::io and got very sad :(
[22:56:29] * olsonjeffery nods
[22:57:12] <olsonjeffery> no, it's a fair point. i was working through the list of things in newrt that someone else didn't already have (ecr has a bunch of synch io, already and toddaro is doing the runtime work)
[22:57:24] <graydon> ooh, ecr is looking at files?
[22:57:38] *** Joins: dbaupp (Thunderbir@moz-712A1135.lns20.syd6.internode.on.net)
[22:57:46] <graydon> sorry, I don't mean to be too much of a spoil sport, I am just getting excited about newrt :)
[22:57:55] <olsonjeffery> not sure, i happened to do Timer because that was one piece he wasn't messing with
[22:58:12] <olsonjeffery> anyways.. the aio thing is pretty exploratory.
[22:58:13] <brson> olsonjeffery: from a SchedTask it looks like the correct way to switch to a GreenTask is resume_task_immediately. possibly the right thing is to make `run_task` look at the task type, and if it's a SchedTask, call `resume_task_immediately`.
[22:58:19] <strcat> Eridius: btw I was going to try making an intrinsic for LLVM's checked overflow ops, just to see if it makes better code
[22:58:19] *** Joins: lmandel (lmandel@moz-76CE9D51.cable.teksavvy.com)
[22:58:45] *** Quits: dew (Instantbir@moz-8A63B53.dhcp.stls.mo.charter.com) (Connection reset by peer)
[22:58:59] <olsonjeffery> brson: well its only looking at the target task it's going towards.. right?
[22:59:05] <olsonjeffery> in this case, we're going SchedTask->GreenTask
[22:59:12] <olsonjeffery> or do i have it backwards?
[23:00:49] <toddaaro> olsonjeffery: what exactly is your situation?
[23:01:01] <olsonjeffery> toddaaro: sending over a oneshot chan from a SchedTask
[23:01:10] <toddaaro> olsonjeffery: oh, just use send_deferred
[23:01:15] <toddaaro> olsonjeffery: and then you are done
[23:01:29] <toddaaro> bblum left an assert in it, so remove that
[23:01:33] * olsonjeffery nods
[23:01:35] <graydon> erickt: ping2
[23:01:42] <bblum> what assert
[23:01:51] <toddaaro> ecr mentioned it asserts task context
[23:01:54] <bblum> oh uhhh
[23:01:55] <bblum> well
[23:01:58] <toddaaro> but that isn't a requirement of send deferred
[23:02:08] <toddaaro> no scheduling -> no context requirement
[23:02:14] *** Quits: jgilbert (jgilbert@moz-7B0110AD.mv.mozilla.com) (Quit: Leaving)
[23:02:24] <toddaaro> the main problem with send is that it did the descheduling
[23:02:27] <bblum> this will probably currently work, but i am not sure if brian wants to make the scheduler be inaccessible during the cleanup job
[23:02:32] <bblum> like remove the unsafe borrow
[23:02:43] <olsonjeffery> toddaaro: i already removed that assert
[23:02:48] <olsonjeffery> the send, itself works
[23:02:54] <olsonjeffery> but the GreenTask barfs when its shutting down
[23:02:58] <olsonjeffery> when coming back from a SchedTask
[23:03:01] <toddaaro> which send?
[23:03:09] <olsonjeffery> toddaaro: https://gist.github.com/brson/6171479
[23:03:25] <olsonjeffery> toddaaro: sending data from a SchedTask to a GreenTask .. i can recv and get the data
[23:03:46] <olsonjeffery> but when that GreenTask ends, after being started as part of the send call, i assume, it chokes
[23:04:07] <toddaaro> yea, that send will fail as it is a "normal" send
[23:04:19] *** Joins: dew (Instantbir@moz-8A63B53.dhcp.stls.mo.charter.com)
[23:04:35] <olsonjeffery> well, is SchedTask supposed to be off-limits to users?
[23:04:56] <toddaaro> the problem is that if there is a waiter you resume the waiting task with a context swap to it, which assumes GreenTask->GreenTask. send_deferred just enqueues the waiting task instead of context swapping to it, so you don't have that issue
[23:05:25] <toddaaro> we are trying to avoid context swapping in the cleanup job, as that just ends up in a confusing rabbit hole
[23:05:43] <olsonjeffery> ok. i guess ill just use send_deferred() and move on.
[23:06:05] <toddaaro> this is something I've been thinking about, I might go add a non-deferred send that works somehow
[23:06:05] <olsonjeffery> but, if tehre's a reasonable expectations that user code will be ran in the sched context, this will be a frequent footgun
[23:06:14] <toddaaro> yea, it is right now
[23:06:55] *** Quits: int3__ (int3_@moz-ABE52D50.hsd1.ca.comcast.net) (Client exited)
[23:06:58] <olsonjeffery> brson: so what do you think about graydon's point about whether an "aio" library is even relevant?
[23:07:30] <olsonjeffery> personally i think having it not block the task is a plus.. but maybe its not so important that its worth the effort when i could be doing file io, heh.
[23:07:40] *** mindginative is now known as richard_s
[23:07:53] <Eridius> strcat: an intrinsic for checked overflow ops would be nice
[23:08:12] <strcat> many intrinsics ;[
[23:08:12] <olsonjeffery> that is, i think aio and the semantics of returning a Future stead oflocking the task
[23:08:37] <toddaaro> olsonjeffery: I think aio could be useful still, sometimes you just want to make a request get a future and continue
[23:08:45] <toddaaro> olsonjeffery: or send the future to someone else
[23:11:08] <ecr> olsonjeffery: try doing wrapping that rtassert! in a 'if do_resched { }'
[23:11:27] <ecr> then it should allow you do use send_deferred from the scheduler context
[23:11:36] <ecr> no promises on safety tho
[23:11:57] <olsonjeffery> k
[23:12:26] <ecr> graydon: brson has my on thread safety for IO at the moment. file IO is on the todo list once that's taken care of.
[23:13:12] <ecr> I really need an IRC client that tells me when someone mentions me; I always miss it.
[23:13:17] <kmc> why do I need the address-of operator when initializing a struct field of reference type from another struct field of the same reference type?
[23:13:26] <kmc> seems like it thinks I want to auto-deref and move
[23:13:37] <toddaaro> olsonjeffery: a big thing about aio is that it is hard to tell what we want it to be good at until we have written io code and been unhappy about something
[23:13:41] <strcat> kmc: what's the type?
[23:13:56] <graydon> ecr: I see. 
[23:14:15] <toddaaro> olsonjeffery: file io though, looks super useful and has a clear goal now
[23:14:20] <brson> olsonjeffery: i'm kind of torn about it. there are are a lot of factors to consider, relating to usability, effort, design and performance
[23:14:38] <kmc> uh the field is &' GlyphStore where a struct GlyphStore has an owned vector and some other stuff in it
[23:14:43] <kmc> er &'self GlyphStore i mean
[23:14:57] <ecr> graydon: the current plan is to make IO handles home back to their event loop before doing any IO. we can loosen it up when/if we find a way to move handles between event loops.
[23:15:15] *** Joins: a__ (a__@moz-250D9B4.nycmny.fios.verizon.net)
[23:15:23] *** Joins: maikklein2 (maik@moz-BFE8F4AD.dip0.t-ipconnect.de)
[23:15:49] <brson> olsonjeffery: from a usability standpoint it's fairly trivial to encapsulate sync i/o results in a future - as long as one is willing to pay the task cost
[23:17:41] *** Quits: brendan (brendaneic@moz-BBE3ABD.mv.mozilla.com) (Quit: brendan)
[23:18:04] <brson> olsonjeffery: as far as perf, it's easy to imagine that a dedicated future-based aio implementation will scale better in memory-usage than the sync approach, but hard to guess how the throughput will compare
[23:18:28] <kmc> oh nm adding the operator doesn't fix the lifetime error anyway, it just defers it until a later compilation stage
[23:18:48] <brson> istm that, in cases where the sync io api is insufficient in perf, what one really wants is to do whatever it takes to get the maximum throughput that the OS allows, and that's hard
[23:19:04] <brson> and likely involves fewer abstractions
[23:19:58] *** Joins: echristo (echristo@moz-1892C634.hsd1.ca.comcast.net)
[23:21:18] <graydon> I would just like to get sync io roughed out across the board and the old IO system removed, before we design more things. there are too many places for a newcomer to reach for IO right now.
[23:21:58] <brson> replacing std::io is a high priority
[23:23:42] *** Quits: jorendorff (jorendorff@moz-2F32ACA3.hsd1.tn.comcast.net) (Quit: jorendorff)
[23:26:05] <olsonjeffery> ok, i'm with this.
[23:26:48] *** Quits: bytbox (s@moz-DC83764A.washdc.fios.verizon.net) (Ping timeout)
[23:26:49] <olsonjeffery> ecr: how far are you from starting on file io, do you think?
[23:27:08] <olsonjeffery> im willing to dig in right now, if you think you'll be involved in your current work for a while...
[23:27:54] <jack> graydon: ping
[23:27:57] <olsonjeffery> working on the aio stuff has served to get me up to speed about rt::io and how it works. so it's not a total loss.
[23:28:48] <graydon> jack: pong
[23:29:08] <jack> graydon: servo-bors is stuck in pending a PR
[23:29:14] *** kimundi is now known as zz_kimundi
[23:29:14] *** Joins: bytbox (s@moz-DC83764A.washdc.fios.verizon.net)
[23:29:17] <jack> i'm trying to track it down, but wondered what the common causes of that are
[23:29:45] <olsonjeffery> in any event, im gathering that aio isn't a priority right now, so i'll set it aside.
[23:30:28] <graydon> jack: stuck in pending? hm
[23:30:57] <graydon> olsonjeffery: thanks, sorry to rain on your parade! I am just real excited about not having to call any of the code in std::io again :)
[23:31:14] <jack> the build slaves don't seem to have ever started builds for it.
[23:31:16] <graydon> jack: usually I run bors manually on the command line and/or inspect its logs
[23:31:36] <jack> will @bors retry make it abort and try again?
[23:32:19] <strcat> close it, wait until it drops off the bors queue and reopen
[23:32:28] <strcat> (but don't reopen before, or bors will go mad)
[23:33:12] <graydon> @bors: retry (colon)
[23:33:38] <toddaaro> brson: https://github.com/mozilla/rust/pull/8381 r+?
[23:33:48] <toddaaro> brson: simple rng access for tasks
[23:33:58] <ecr> olsonjeffery: not sure. I'm hoping this basic thread safety plan won't take more than a week to implement, but things could always get nasty.
[23:34:18] <ecr> you could always start on it now 
[23:34:18] *** Joins: brendan (brendaneic@moz-BBE3ABD.mv.mozilla.com)
[23:34:42] <ecr> and I'll add in safety once we figure it out
[23:34:51] <toddaaro> there is plenty of other stuff ecr can do before file io
[23:35:01] *** Quits: snadon (chatzilla@moz-3BC727E8.mc.videotron.ca) (Ping timeout)
[23:35:24] <ecr> yeah, the other runtime interns will start leaving soon and I'll probably end up picking up some other stuff
[23:35:31] <ecr> so go ahead with file IO
[23:36:47] <dbaupp> toddaaro, brson: any particular reason for XorShift rather than ISAAC?
[23:37:23] <jack> graydon: ok. closed the PR that was pending. there is one sitting at approved, but bors doesn't seem to be moving (although the pending one disappeared from its list)
[23:37:53] <dbaupp> toddaaro, brson: (XorShift should be a last resort for when speed is an absolute priority, especially since it currently can't be seeeded randomly, and so generates the same sequence every run.)
[23:37:54] <graydon> jack: what does it say in its logs
[23:37:55] <graydon> ?
[23:38:00] <graydon> jack: the logs are very informative :)
[23:38:10] <graydon> jack: it says what it's seeing and waiting for
[23:38:12] <jack> graydon: you act like i have access to the logs :)
[23:38:16] <graydon> oh
[23:38:18] <graydon> :((((((((((((((
[23:38:26] <toddaaro> dbaupp: right now the only two uses we have require speed above all else, but making it more generic and configurable would be a huge plus
[23:38:30] <graydon> that is my special devops frowny move
[23:38:30] <jack> graydon: trying to access them but waiting on others for that
[23:38:56] <jack> maybe i can log into the master, but i think i can only get to slaves.
[23:39:01] <toddaaro> dbaupp: I'm not very knowledgeable when it comes to comparing rng algorithms, I'm just hacking this in now without too much thought so I can use it
[23:39:16] <dbaupp> toddaaro: ok (can be adjusted later, I'm sure :) )
[23:39:49] <strcat> ugh, silly intrinsics returning i1
[23:39:57] <strcat> if it just returned i8 this would have been done in 3 minutes
[23:40:13] <olsonjeffery> graydon: not at all! im glad i actually had a chance to gauge everyone's opinion. i kind of barreled off in my own direction w/o thinking about the big picture. anyways.
[23:40:24] <kmc> can somebody help me get the lifetimes right with flat_map_?  here's my problem: http://pastebin.mozilla.org/2805061
[23:40:55] <olsonjeffery> ecr: ill doo that. hopefully it'll be nice and rote and i can turn something around quick.
[23:41:18] *** Joins: ghrust (ghrust@F6EE6DE3.6A2AE50.F3114085.IP)
[23:41:18] <ghrust> 01[13rust01] 15bors merged 06auto into 06master: 02http://git.io/GOPRBw
[23:41:18] *** Parts: ghrust (ghrust@F6EE6DE3.6A2AE50.F3114085.IP) ()
[23:41:46] *** Quits: bent (chatzilla@moz-BE33DA21.fw1.sfo1.mozilla.net) (Quit: ChatZilla 0.9.90.1-rdmsoft [XULRunner 22.0/20130619132145])
[23:42:07] <tikue> rusti: let s = "no tilde"; println(s);
[23:42:08] -rusti- no tilde
[23:42:08] -rusti- ()
[23:42:18] <tikue> are tildes completely unnecessary for strings now?
[23:42:18] <jack> graydon: ok. i am looking at logs now
[23:42:52] <dbaupp> kmc: I believe the problem is you can't return a stack closure like that
[23:43:00] <strcat> tikue: "foo" is &'static str, ~"foo" is ~str
[23:43:09] <strcat> different things - ~str is a heap allocated dynamic array
[23:43:27] <strcat> "foo" is just a regular &str slice with a 'static lifetime
[23:43:40] <dbaupp> kmc: (i.e. a stack closure is linked to the stack frame in which it is declared, even if it only closes over things with a longer lifetime.)
[23:43:48] <ecr> olsonjeffery: awesome :)
[23:43:49] <tikue> rusti: let s = "no tilde"; do spawn { printfln!("look mah, no %s!", s); }
[23:43:50] -rusti- ()look mah, no no tilde!
[23:44:09] <tikue> strcat: I know they're different :) I just don't know when you need ~str
[23:44:16] *** Joins: ghrust (ghrust@1E8607E8.6A2AE50.F3114085.IP)
[23:44:16] <ghrust> 01[13rust01] 15bors pushed 0 new commits to 06auto: 02http://git.io/GJ2ohA
[23:44:16] *** Parts: ghrust (ghrust@1E8607E8.6A2AE50.F3114085.IP) ()
[23:44:17] <kmc> hm, that does make sense :)
[23:44:17] *** Joins: ghrust (ghrust@79968228.6A2AE50.F3114085.IP)
[23:44:17] <ghrust> 01[13rust01] 15bors pushed 13 new commits to 06auto: 02http://git.io/pEW98Q
[23:44:17] <ghrust> 13rust/06auto 14eb61432 15Brian Anderson: std::rt: 2MB stacks again
[23:44:17] <ghrust> 13rust/06auto 14f82da81 15Brian Anderson: std::rt: Pull RUST_MIN_STACK from the environment
[23:44:18] <ghrust> 13rust/06auto 14ae1ed4f 15Brian Anderson: std: Allow spawners to specify stack size
[23:44:20] *** Parts: ghrust (ghrust@79968228.6A2AE50.F3114085.IP) ()
[23:44:22] <ecr> ^ I was very confused why rusti seemed to start talking there
[23:44:27] <kmc> how am I supposed to use flat_map_, then? :(
[23:44:30] <strcat> tikue: if you need to resize it dynamically
[23:44:32] <dbaupp> tikue: you need it when the compiler tells you "..." doesn't work. :)
[23:44:40] <tikue> dbaupp: :P that's my typical approach as well
[23:44:46] <kmc> I guess I can make an @fn, bleh
[23:44:52] <tikue> kmc: :(
[23:45:21] <dbaupp> kmc: you might need to pass it into a closure, so iter_graphs_for_char_range(&self, range, &fn(&GlyphIterator) -> T) -> T
[23:45:26] <dbaupp> (well, you could do that.)
[23:45:31] <tikue> rusti: printfln!("\n\ntwo spaced");
[23:45:32] -rusti- "\n\ntwo spaced"
[23:45:33] -rusti- ()
[23:45:35] <tikue> hm
[23:45:40] *** Joins: tcr (tcr@moz-1C4F4144.hsd1.ma.comcast.net)
[23:45:43] <engla> kmc: write 'static for the first lifetime in FlatMap
[23:45:55] <engla> I guess that works?
[23:46:07] <strcat> huh, I don't see how this thinks the return type is void
[23:46:36] <kmc> engla: same error :/
[23:47:05] <kmc> I just want to store my fv's in the struct FlatMap somehow
[23:47:17] *** Joins: ghrust (ghrust@AC22872E.6A2AE50.F3114085.IP)
[23:47:17] <ghrust> 01[13rust01] 15bors 04force-pushed 06auto from 144eda077 to 14a85f9ac: 02http://git.io/N3iJvQ
[23:47:17] *** Parts: ghrust (ghrust@AC22872E.6A2AE50.F3114085.IP) ()
[23:47:19] *** Joins: ghrust (ghrust@C8693FCB.6A2AE50.F3114085.IP)
[23:47:19] <ghrust> 01[13rust01] 15bors pushed 13 new commits to 06auto: 02http://git.io/DgPwWg
[23:47:19] <ghrust> 13rust/06auto 14eb61432 15Brian Anderson: std::rt: 2MB stacks again
[23:47:19] <ghrust> 13rust/06auto 14f82da81 15Brian Anderson: std::rt: Pull RUST_MIN_STACK from the environment
[23:47:20] <ghrust> 13rust/06auto 14ae1ed4f 15Brian Anderson: std: Allow spawners to specify stack size
[23:47:20] <tikue> brson: when will newrt get dynamically sized stacks
[23:47:22] *** Parts: ghrust (ghrust@C8693FCB.6A2AE50.F3114085.IP) ()
[23:47:22] <kmc> but it only stores an &'self fn so I don't think that can be done
[23:47:29] <engla> kmc: ok I don't know this very well but why isn't that using a lifetime parameter like  <'a>(&'a self   etc
[23:48:17] <kmc> I'm not sure, it was like this before? :)
[23:48:37] <erickt> graydon: pong2
[23:48:53] <kmc> engla: doesn't seem to make a difference though
[23:49:07] <graydon> erickt: hey, I did r+ on your string change
[23:49:14] <kmc> so is it the case that flat_map_ basically can't be used with a function that has free variables
[23:49:19] <erickt> graydon: thanks!
[23:49:30] <graydon> erickt: just making some comments on it now. I'm a little surprised that it doesn't ... entirely guarantee what I thought it would
[23:49:40] <graydon> erickt: but thinking about it I'm not sure how it should. so making notes in the bug.
[23:49:48] <engla> kmc: oh right, of course self is a capture
[23:49:48] <graydon> erickt: if you have a moment further I'd appreciate any thoughts
[23:49:56] <engla> kmc: the problem is that you can't return closures with captures
[23:50:07] <erickt> graydon: I figure this is just the first cut of a CString interface, and I'm expecting it's going to have to change
[23:50:18] <engla> kmc: there is a workaround for an explicit capture but it's not super pretty
[23:51:07] <engla> kmc: like this https://github.com/mozilla/rust/blob/master/src/libstd/hashmap.rs#L733
[23:51:15] <engla> kmc: https://github.com/mozilla/rust/blob/master/src/libstd/hashmap.rs#L765
[23:51:51] <kmc> no indeed it is not
[23:51:55] <kmc> but thanks
[23:52:04] <erickt> graydon: Are there any invariants beyond someone calling c.with_mut_ref and setting the null character to a non-null that it's not handling?
[23:52:17] <brson> tikue: I don't know. It's a big project. I do expect segmented stacks to be broken in Rust 0.8
[23:52:26] *** Quits: fread2281 (Mibbit@moz-CB181B42.dia.static.qwest.net) (Quit: http://www.mibbit.com ajax IRC Client)
[23:52:27] <tikue> ah ok
[23:54:02] <erickt> graydon: regarding a CStringOwner as well as a CStringRef, I think that's probably the right way to go.
[23:54:18] <graydon> erickt: the main thing is I worry that `strlen() + 1` isn't actually the string since there's no check that the string has no embedded nulls when constructed from a &[u8]?
[23:54:43] <strcat> graydon: well if it owns the string, construction does already have to be unsafe
[23:54:45] <erickt> graydon: I was thinking about working on that next but I first wanted to get this change landed before it bitrotted
[23:54:51] <graydon> yeah
[23:55:00] <graydon> there are some things to tidy but it looks like it's moving in the right direction
[23:55:05] *** Quits: tcr (tcr@moz-1C4F4144.hsd1.ma.comcast.net) (Client exited)
[23:55:15] <strcat> assuming you pass it a malloc'ed block (haven't looked at it in detail)
[23:55:23] *** Eridius is now known as Eridius|vacation
[23:55:58] <strcat> I'm convinced LLVM is out to get me now ;p
[23:56:11] <strcat> Found return instr that returns non-void in Function of void return type!
[23:56:13] <strcat>   ret { i16, i8 } %9
[23:56:23] <strcat>     pub fn i16_add_with_overflow(x: i16, y: i16) -> (i16, bool);
[23:56:30] * strcat obviously forgot something
[23:57:20] *** Joins: echristo_ (echristo@60A74940.D6CCE4AE.77834EAA.IP)
[23:57:21] <erickt> graydon: what's difficult about nulls in the string is that some C apis actually use nulls as delimiters
[23:57:30] *** Quits: echristo (echristo@moz-1892C634.hsd1.ca.comcast.net) (Ping timeout)
[23:57:30] *** echristo_ is now known as echristo
[23:57:41] <strcat> erickt: but that's not what CString encapsulates - if they use \0 as delimiters, they aren't C strings
[23:57:51] <strcat> they'd have to give you a length
[23:58:34] <erickt> strcat: fair enough
[23:59:20] <erickt> graydon: would you want going from ~str to CString assert that there are no inner nulls?
[23:59:43] <graydon> erickt: assert or raise a condition so we can do something, yeah.
[23:59:57] <graydon> otherwise things just went hinky. it won't round trip.

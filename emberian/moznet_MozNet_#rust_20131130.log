[00:00:01] <strcat> mib_163bmm: they can be done like unit structs or named field structs too
[00:00:22] *** Joins: nsf (nsf@moz-EEF3238A.convex.ru)
[00:00:23] <strcat> they are like structs, except their type is the type of the enum
[00:01:03] <kimundi> ktt3ja: You can define a function with an external API. extern fn "C" foo() { ... }
[00:01:06] <dbaupp> ktt3ja: in an extern {} block no
[00:01:24] <dbaupp> kimundi: (extern "C" fn foo() { ... })
[00:01:39] <kimundi> whoopse, yeah
[00:01:50] <mib_163bmm> strcat: Why not ditch the term variant and just use the term tuple struct?
[00:02:06] <strcat> mib_163bmm: because it's a variant of the enum
[00:02:34] <strcat> enum Foo { A, B(int), C(int, int), D { x: int, y: int } }
[00:02:39] <strcat> what do you suggest those 4 things be called?
[00:02:48] <mib_163bmm> strcat: Variants
[00:03:11] * strcat confused
[00:03:35] *** Joins: jvns (bork@87D98E32.4046EB22.428F94DD.IP)
[00:03:39] <dbaupp> mib_163bmm: are you talking about `struct Foo(int, uint);`?
[00:04:55] <mib_163bmm> mib_163bmm: Yea
[00:05:03] <mib_163bmm> that's what the docs call it
[00:05:09] <strcat> we do call that a tuple struct
[00:05:49] <jvns> I'm having some trouble doing pointer arithmetic in Rust -- I don't understand why two pieces of code I have don't do the same thing. Code here: https://gist.github.com/jvns/42b670c65436d8fb5b26
[00:06:12] <strcat> jvns: you'll want to use the offset intrinsic, not casts
[00:06:14] *** Joins: wilmoore (wilmoore@moz-71431C3A.hsd1.co.comcast.net)
[00:06:37] <jvns> strcat, what is an offset intrinsic?
[00:06:47] <strcat> the offset method on raw pointers
[00:06:47] *** Joins: z0w0 (zack@moz-6264033D.qcl9.cha.bigpond.net.au)
[00:07:23] <mib_163bmm> strcat: Wait. The docs refer to C(int, int) inside an enum as a function
[00:07:33] <mib_163bmm> Is it a function or a tuple struct
[00:07:36] <strcat> jvns: your second example is making 0xb8000 get inferred as i16 and overflowing it
[00:07:45] <jvns> that makes sense!
[00:07:46] <cmr> mib_163bmm: the type is a tuple struct. the constructor is a function.
[00:07:58] <strcat> cmr: the type isn't a tuple struct when it's in an enum
[00:08:10] <strcat> struct Foo(int, int); is a tuple struct
[00:08:18] <strcat> Foo(2, 3) is automatically defined as a ctor to call
[00:08:24] <cmr> rusti: struct C(int, int); let x: extern "Rust" fn(int, int) -> C = C;
[00:08:27] -rusti- <anon>:9:33: 9:34 warning: unused variable: `x` [-W unused-variable (default)]
[00:08:27] -rusti- <anon>:9          struct C(int, int); let x: extern "Rust" fn(int, int) -> C = C;
[00:08:27] -rusti-                                           ^
[00:08:27] -rusti- ()
[00:08:29] <strcat> enum Foo { Bar(int, int), Baz } is an enum
[00:08:31] <jvns> strcat, when I google "offset intrinsic", I find a reference to "std::ptr::offset". If I have "#[no_std];" in my code, can I still use it?
[00:08:39] <cmr> Oh, I only saw the "struct Foo(int, uint)" above.
[00:08:40] <strcat> jvns: if you're using no_std, use rust-core
[00:08:48] <strcat> jvns: https://github.com/thestinger/rust-core
[00:08:52] <strcat> works for freestanding (no libc) use
[00:08:56] <jvns> cool!
[00:09:20] <jvns> could I also just not use a cast? I don't really care if 162 is a u16 or not
[00:09:31] <strcat> jvns: yeah you could use a cast
[00:09:34] *** Joins: mib_qv3jg1 (Mibbit@moz-B2BED322.protectedgroup.com)
[00:09:44] <strcat> the intrinsic is better because it leads to better performance :P
[00:09:44] *** Quits: mib_qv3jg1 (Mibbit@moz-B2BED322.protectedgroup.com) (User has been banned from Mozilla (no spamming here))
[00:10:03] <strcat> and it's usually simpler because it offsets by elements rather than bytes
[00:10:35] <dbaupp> strcat: that code will always need a cast, right? since it's starting with a known/fixed address?
[00:11:04] <strcat> yeah it needs a cast somewhere.
[00:11:12] <jvns> that makes sense! I don't know how to include libraries yet, though. Hmm. 
[00:11:27] * jvns googles
[00:11:28] *** Joins: alonlevy (alon@moz-DCBA91C6.bb.netvision.net.il)
[00:11:33] <strcat> jvns: look at some of the examples in the test dir
[00:11:48] <strcat> jvns: rust-core isn't a proper library, it has to be used a module atm
[00:12:02] <strcat> because rust's crate system doesn't work for #[no_std] use cases yet
[00:12:05] <mib_163bmm> strcat: So if I define enum { A{int} } then what is A defined as if enum { A(int) } is defined as a ctor?
[00:12:28] <strcat> mib_163bmm: I'm not really sure what you're saying
[00:12:34] <jvns> is "#[path = "../core/mod.rs"]" what says where the core library is?
[00:12:50] <strcat> jvns: yeah, you usually wouldn't need that
[00:13:09] <strcat> jvns: 'mod core' will work if there's a 'core' directory in the dir the file including it is
[00:13:16] <jvns> oh okay
[00:13:50] <strcat> jvns: usually (as in not freestanding) you would use 'extern mod core' and it would link to a crate (loading the metadata from the dynamic/static lib)
[00:14:28] <strcat> rust-core needs the crate system to mature a bit more (exporting macros, link-time optimization, fully mature static linking, some lang item funny business sorted out)
[00:14:41] <jvns> should I normally put libraries in the same dir the file including it is in? that seems a bit strange
[00:15:01] <strcat> jvns: well rust-core isn't exactly a normal library.
[00:15:05] <jvns> :)
[00:15:15] <jvns> fair enough!
[00:15:23] <strcat> with the normal crate system, you'd use extern mod core; and it'd find it anywhere in the library path
[00:15:29] <jvns> i see
[00:15:34] <strcat> (anywhere in /usr/lib/ or added with -L)
[00:15:37] <mib_163bmm> strcat: Oh sorry
[00:15:50] <strcat> crates do away with C-like headers by storing metadata in the library itself
[00:15:58] <strcat> but rust-core has to be used as an in-crate module at this point.
[00:16:11] <strcat> just fixable language limitations
[00:16:21] <jvns> hmm, okay
[00:16:37] <jvns> I still don't know what crates are, but I think I'll postpone that until later
[00:16:56] <mib_163bmm> strcat: What do the docs mean by "variant constructor" for enums
[00:17:05] <jvns> thanks so much!
[00:17:07] <dbaupp> jvns: "crate" == compilation unit
[00:17:11] <strcat> jvns: for example a dynamically linked crate is a .so file, but it includes the metadata (ABI) inside a shared object section
[00:17:23] <strcat> (or a dll on windows)
[00:17:29] <jvns> ABI?
[00:17:32] <mib_163bmm>  So if I define enum { A(int) } then why is A a function?
[00:17:33] <strcat> the binary interface
[00:17:36] <strcat> what C puts in headers
[00:18:20] <strcat> (well it's really the source-level function/type signatures too...)
[00:18:30] <strcat> mib_163bmm: because A(2) is parsed as a function
[00:19:10] <strcat> Foo(2, 2) calls a function Foo
[00:19:15] <mib_163bmm> strcat: Does that mean it actually is a function?
[00:19:22] *** Quits: JamesNZ (james@moz-264643C7.bitstream.orcon.net.nz) (Ping timeout)
[00:19:29] <strcat> mib_163bmm: well functions and types are in different namespaces
[00:19:36] <strcat> tuple structs are in both namespaces
[00:19:39] *** Joins: JamesNZ (james@moz-264643C7.bitstream.orcon.net.nz)
[00:19:58] <kimundi> rusti: struct Foo(uint, uint); let f = Foo; f(1, 2)
[00:20:01] -rusti- main::Foo(1u, 2u)
[00:20:10] <cmr> mib_163bmm: see my example above. they're functions.
[00:20:28] <strcat> struct Foo(int); is a) a type called Foo and b) a ctor function called Foo
[00:21:07] * strcat shrugs
[00:21:18] <mib_163bmm> Same goes for enum { A(int) }? A is both a type and a function?
[00:21:24] <strcat> A isn't a type
[00:21:36] <strcat> mib_163bmm: that's not valid without a type name for the enum
[00:21:40] <mib_163bmm> sorry I forgot to name the enum
[00:21:46] <strcat> rusti: enum Foo { A(int) }
[00:21:47] -rusti- ()
[00:21:57] <kimundi> For enum Foo { A(uint) }, Foo is the type, and A the construct function
[00:22:01] <strcat> A is a function returning the type Foo
[00:22:04] <mib_163bmm> strcat: Okay. So enum Foo { A(int) } A is a function and Foo is a type
[00:22:07] <strcat> yeah
[00:22:24] <strcat> and I guess A is probably in the type namespace too... so it can be identified as a variant
[00:22:26] <strcat> I'd hope so
[00:22:30] <strcat> but that might be buggy
[00:22:37] <strcat> (but it's not a type)
[00:22:57] *** Quits: GeneralMaximus (ankur@704E18E2.13A5FC81.D5D59AD9.IP) (Ping timeout)
[00:23:00] <mib_163bmm> strcat: Why would something be in the type namespace but not a type
[00:23:07] <mib_163bmm> That's sounds confusing
[00:23:17] <jvns> hmm, so if I want to use ASCII I guess I could use rust-core too?
[00:23:19] <mib_163bmm> Are traits in the type namespace?
[00:23:23] <strcat> it's not really a 'type namespace' it's just 'the namespace types are in'
[00:23:24] <mib_163bmm> But not a type?
[00:23:29] <dbaupp> jvns: in what sense?
[00:23:31] <strcat> I think modules are also in the 'type' namespace
[00:23:50] <jvns> dbaupp, It seems like strings and chars in Rust are unicode strings 
[00:23:55] <strcat> there's a namespace for values and a namespace for non-values (things that you can use :: on)
[00:23:58] <cmr> Modules should be in both.
[00:24:00] <dbaupp> strcat: why would a variant need to be in the 'type' namespace to identify it as a variant?
[00:24:08] <strcat> dbaupp: because the compiler is dumb
[00:24:13] <strcat> that's why they're functions after all
[00:24:35] <strcat> I wouldn't really call these things defined parts of the language yet
[00:24:41] <strcat> just how certain things happen to be implemented
[00:24:50] <dbaupp> jvns: strings are utf8, which is a superset of ascii (so a &str that contains only characters that are valid ascii will be exactly the same as a "true" ascii string)
[00:25:08] <dbaupp> rusti: enum Foo { A(int) } type A = int;
[00:25:09] -rusti- ()
[00:25:21] <dbaupp> rusti: enum A { A(int) } type A = int;
[00:25:26] -rusti- pastebinned 8 lines of output: http://sprunge.us/jIRg
[00:25:29] <strcat> jvns: &str is &[u8] with a guarantee of being valid UTF-8, nothing else
[00:25:40] <strcat> char is u32 with a guarantee of being a valid code point
[00:25:55] <jvns> oh, hmm
[00:26:01] <strcat> if the guarantees weren't there, the types wouldn't be necessary
[00:26:02] *** Quits: JamesNZ (james@moz-264643C7.bitstream.orcon.net.nz) (Ping timeout)
[00:26:09] *** Joins: Skif (emschwar@moz-4C5BB5A8.beyondbb.com)
[00:26:14] *** Joins: JamesNZ (james@moz-264643C7.bitstream.orcon.net.nz)
[00:26:19] <strcat> for non-UTF8 'strings' you can use [u8] or another strongly typed wrapper around [T]
[00:26:30] <jvns> I forgot that utf8 was a superset of ascii
[00:26:42] <strcat> rusti: let x: &[u8] = &[1, 2, 3]; x
[00:26:43] -rusti- &[1u8, 2u8, 3u8]
[00:26:45] *** Joins: GeneralMaximus (ankur@704E18E2.13A5FC81.D5D59AD9.IP)
[00:26:49] <strcat> rusti: let x: &[u8] = bytes!("foo"); x
[00:26:50] -rusti- &[102u8, 111u8, 111u8]
[00:26:57] *** Joins: earlzlap (earlz@moz-483E1E31.neo.res.rr.com)
[00:27:00] <mib_163bmm> dbaupp: How did that first one compile. I thought strcat said A would be a type
[00:27:23] <jvns> oh serious question! is it easy to get a rusti? Mine segfaults when I try to do anything
[00:27:27] <dbaupp> mib_163bmm: yeah, I don't understand why strcat said that either
[00:27:33] <ChrisMorgan> jvns: rusti is removed
[00:27:40] <strcat> jvns: the rusti here is just a wrapper around rustc
[00:27:44] <jvns> oh okay
[00:27:46] <jvns> =)
[00:27:49] <jvns> =(
[00:27:51] <strcat> we never really had a working REPL
[00:27:53] *** Quits: Skif (emschwar@moz-4C5BB5A8.beyondbb.com) (Ping timeout)
[00:27:58] <kimundi> jvns: The rusti executable got removed in git master, if you still have one, thats legacy that should get removed :P
[00:28:05] <dbaupp> mib_163bmm: (he didn't actually say A would be a type, just that it would be in the same namespace as the types)
[00:28:07] <ChrisMorgan> Hmm, bors is lazy. Better submit a handful of PRs.
[00:28:36] <strcat> jvns: the issue is that it's surprisingly hard to write a good REPL, for a language built on an ahead-of-time compilation model
[00:28:43] <jvns> that makes sense!
[00:28:50] <strcat> ghci for haskell is quite weird, for example
[00:28:58] <strcat> it's a robust tool, but it's not really normal haskell
[00:29:12] <strcat> (it's getting less weird over time)
[00:29:27] <strcat> jvns: we should have one, just not really a priority atm ;p
[00:29:27] <jvns> it would be kind of useful to have something that does the same thing as the rusti bot
[00:29:29] <mib_163bmm> dbaupp: If it's in the namespace for types, then how can you define a type with the same name as it?
[00:29:38] <dbaupp> mib_163bmm: it's not in it
[00:29:55] <Earnestly> strcat: That and everything in ghci runs inside an io monad
[00:30:04] <dbaupp> mib_163bmm: to be even preciser, strcat was saying that it should be in it
[00:30:15] <strcat> maybe should be
[00:30:20] <strcat> ;p
[00:30:54] <mib_163bmm> dbaupp: So then that's one advantage of using struct variants over tuple struct variants... tuple structs don't pollute the type namespace?
[00:31:21] <dbaupp> rusti: enum Foo { A { x: int } } type A = int;
[00:31:23] -rusti- pastebinned 8 lines of output: http://sprunge.us/hQjY
[00:31:40] <o11c> REPLs are easier for a language that requires declarations before use
[00:31:45] <jvns> so do I need to use bytes! to convert a str to a &[u8]?
[00:32:06] <strcat> jvns: no, it's just a 'byte literal' (it's a compile-time constant made from a string literal)
[00:32:07] <dbaupp> mib_163bmm: maybe? but the "type namespace" is heirarchical with modules, so it's not actually that important, unless you feel like having everything in one module.
[00:32:19] <sp3d> rusti: "foo".as_bytes()
[00:32:22] -rusti- &[102u8, 111u8, 111u8]
[00:32:26] <kimundi> jvns: bytes! is just for turning a string literal into a static byte slice at compiletime
[00:32:42] <strcat> jvns: it's only necessary for declaring byte strings in statics
[00:32:45] <strcat> but I'm used to using it now ;p
[00:32:51] <strcat> because I hope we'll get sugar for it as b"foo"
[00:32:53] <dbaupp> mib_163bmm: (and I think you wrote that sentence backwards, maybe?)
[00:32:55] <strcat> like python
[00:33:09] <jvns> right
[00:33:29] <mib_163bmm> dbaupp strcat: It's weird that enums generate functions... Will it always be like that?
[00:33:43] <strcat> mib_163bmm: maybe not
[00:33:46] <dbaupp> mib_163bmm: I hope so
[00:34:03] <mib_163bmm> dbaupp: You hope it will always be like that or not?
[00:34:07] <dbaupp> (or at least, let variant constructors coerce to functions easily)
[00:34:18] <dbaupp> it will always be like that
[00:34:34] <mib_163bmm> But why?
[00:34:34] <dbaupp> foo.map(Some), rather than foo.map(|x| Some(x)), or whatever.
[00:34:45] <mib_163bmm> Why do you need a ctor to create a tuple struct
[00:34:56] <dbaupp> why wouldn't you?
[00:35:06] <dbaupp> how else do you create one?
[00:35:19] <kimundi> You need a ctor for any type :P
[00:35:23] <mib_163bmm> dbaupp: You don't need a ctor to create a struct do you?
[00:35:40] <dbaupp> mib_163bmm: Foo { x: 1 } is the "ctor expresion"
[00:35:43] <kimundi> Foo { x: 5, y: 7 } is a ctor
[00:35:43] <dbaupp> *expression
[00:36:01] <dbaupp> Foo(1, 2) is also a "ctor expression"
[00:36:06] <cmr> mib_163bmm: yes you do
[00:36:13] *** Joins: octurion (octurion@moz-4C1E443F.clients.kiwiirc.com)
[00:36:15] <kimundi> 5u is a ctor expression for the type uint
[00:36:23] *** Quits: earlzlap (earlz@moz-483E1E31.neo.res.rr.com) (Ping timeout)
[00:36:28] <mib_163bmm> Hm I never thought about it that way
[00:36:56] <dbaupp> In theory `Foo(1, 2)` could not be a function call when used directly, but it looks like one, so it'd be nice if `Foo` could be used as a function, for consistency.
[00:37:24] <mib_163bmm> dbaupp kimundi cmr: Then why doesn't Rust make tuples look like Tuple{...} So I can also define functions with the same name
[00:37:40] <kimundi> you already can
[00:38:05] <mib_163bmm> wait wut
[00:38:11] <kimundi> rusti: struct Foo { x: uint } fn Foo(x: uint) -> Foo { Foo { x: x } } Foo(5)
[00:38:12] -rusti- main::Foo{x: 5u}
[00:38:12] *** Quits: canhtak (canhtak@moz-6F820ACE.wl.t.ulaval.ca) (Quit: canhtak)
[00:38:15] <dbaupp> kimundi: really?
[00:38:19] <dbaupp> kimundi: for tuple structs?
[00:38:36] <dbaupp> rusti: struct Foo(uint, uint); fn Foo() {}
[00:38:38] -rusti- pastebinned 8 lines of output: http://sprunge.us/WhUA
[00:38:40] <kimundi> Did I misunderstand?
[00:39:11] *** Quits: santiago (santiago@moz-CF057779.lv.lv.cox.net) (Ping timeout)
[00:39:13] <dbaupp> mib_163bmm: why are you defining a tuple struct with the same name as a function anyway?
[00:39:34] <dbaupp> TypesLookLikeThis and functions_like_this, by convention.
[00:39:40] <mib_163bmm> Well you can define a function with the same name as a struct
[00:39:57] <kimundi> (I persoanaly think that should be forbidden anyway, for consistency.)
[00:40:07] * dbaupp agrees with kimundi
[00:40:18] <dbaupp> (or at least linted.)
[00:40:29] <mib_163bmm> dbaupp: ok lol but what if you are only using one word
[00:40:36] <mib_163bmm> All I want is consistency
[00:40:41] <dbaupp> mib_163bmm: Word, word
[00:40:50] <dbaupp> (type, function)
[00:40:57] <mib_163bmm> Yea
[00:40:58] <cmr> Never once have I wanted a function the same name as a struct.
[00:41:07] <cmr> I don't think it's important in practice.
[00:41:07] <mib_163bmm> keep structs out of the function namespace
[00:41:09] <kimundi> cmr++
[00:41:21] <cmr> mib_163bmm: value, not function
[00:41:39] <cmr> Anyway Foo(1, 2) where Foo is a enum variant/tuple struct is only because that's how it parses.
[00:41:41] <mib_163bmm> cmr: What?
[00:41:55] <jvns> hmm so the rust manual talks about "first class" types, as in "a vector without a fixed size is not a first class type", but it doesn't explain what a first class type is
[00:41:58] <cmr> If it wasn't translated as a function, it would be able to be parsed as a function, since it wouldn't be a function.
[00:42:09] <cmr> *wouldn't
[00:42:12] <strcat> jvns: it's just nonsense ;p
[00:42:16] *** Quits: sprang (sprang@moz-920A95C4.hsd1.ca.comcast.net) (Quit: sprang)
[00:42:23] <jvns> strcat, what do you mean?
[00:42:25] <cmr> mib_163bmm: value namespace, not function namespace.
[00:42:32] <mib_163bmm> cmr: I know. Instead define tuple structs as TupleStruct{int, int}
[00:42:33] *** Joins: derek_c (derek@moz-842C9B2A.cit.cornell.edu)
[00:42:34] <strcat> jvns: the manual/tutorial have a lot of old sections with incorrect info :(
[00:42:50] <jvns> oh
[00:42:55] *** Quits: icebattle (icebattle@8A14A542.EBE2EE2B.C7CEC4ED.IP) (Quit: Leaving)
[00:42:56] <jvns> so is this true: "Since str is of unknown size, it is not a first class type, but can only be instantiated through a pointer type, such as &str, @str or ~str."
[00:42:59] <strcat> obsolete info was mostly deleted but stuff that just changed hasn't been updated much
[00:43:11] <strcat> jvns: well, 'str' isn't a type at all
[00:43:35] <mib_163bmm> Rust is getting popular but everyone rushing to the docs immediately gets incorrect information and are just going to get frustrated down the line
[00:43:37] <jvns> ?!
[00:43:47] <strcat> jvns: there's no such type as [T] or str
[00:43:54] <kimundi> (at the moment)
[00:43:54] <cmr> I would hardly say Rust is getting popular :P Maybe *more* popular.
[00:43:56] <jvns> the manual definitely says 'str' is a type
[00:44:01] <jvns> so that part is wrong?
[00:44:02] <strcat> jvns: yeah, it's wrong :)
[00:44:06] <jvns> cool
[00:44:11] <strcat> jvns: they're just common strings used in the actual types
[00:44:13] <cmr> The manual is more wrong that it is right.
[00:44:27] <jvns> can I make a pull request on the manual to fix this particular part?
[00:44:31] <cmr> jvns: sure, why not
[00:44:36] *** Quits: octurion (octurion@moz-4C1E443F.clients.kiwiirc.com) (Quit: http://www.kiwiirc.com/ - A hand crafted IRC client)
[00:44:41] <cmr> doc/rust.md
[00:45:06] <dbaupp> mib_163bmm: it's a huge known issue, yes; people are working on it (and mozilla is likely to actually throw money directly at fixing the docs at some point pre-1.0)
[00:45:26] <dbaupp> s/is likely to/has been hinting at/
[00:45:30] <jvns> so
[00:45:33] <jvns> " Such a definite-sized vector type is a first-class type, since its size is known statically. "
[00:45:40] <mib_163bmm> dbaupp: Neat. I would help, but I'd probably just screw them up :D
[00:45:42] <mib_163bmm> How can a language with nominal typing support tuples?
[00:45:46] <jvns> "A vector without such a size is said to be of indefinite size, and is therefore not a first-class type."
[00:45:51] <jvns> is this true? should it be deleted?
[00:45:55] <cmr> IMO updating the *manual* isn't important as a focus, since the language isn't quite done baking yet.
[00:46:02] <cmr> mib_163bmm: tuples are structural types.
[00:46:21] <jvns> are there places to learn other than the manual?
[00:46:28] <mib_163bmm> cmr: So then the typing system is structural and nominal?
[00:46:28] <kimundi> mib_163bmm: Well, rust has both nominal typing and structural typing, though the latter is only used for tuples
[00:46:32] <sam113101> the tutorial
[00:46:32] <cmr> mib_163bmm: yes.
[00:46:40] *** Quits: lenstr (lenstr@AF8EB999.6049B16A.85938D85.IP) (Client exited)
[00:46:42] <cmr> jvns: tutorial, rust for rubyists, the source, #rust
[00:46:45] *** Joins: lenstr (lenstr@AF8EB999.6049B16A.85938D85.IP)
[00:46:46] <mib_163bmm> Okay, cause the homepage says type system is nominal
[00:46:54] <cmr> mib_163bmm: it used to have records, too, not just structs.
[00:47:02] <jvns> so the tutorial is better maintained than the manual?
[00:47:04] <cmr> (records were structs, but structural and not nominal)
[00:47:07] <cmr> jvns: yes
[00:47:11] <strcat> jvns: they are both pretty bad.
[00:47:18] <cmr> The manual sometimes gets updated, but...
[00:47:20] <mib_163bmm> cmr: Why were they removed? they dound cool
[00:47:22] <mib_163bmm> sound(
[00:47:23] <mib_163bmm> *
[00:47:29] <strcat> if it didn't take 7 days to merge my tutorial pull requests I would improve it more ;p
[00:47:33] <jvns> =)
[00:47:37] *** Quits: q66 (q66@6EE9DE40.46454B5D.33AABD5F.IP) (Client exited)
[00:47:38] <kimundi> mib_163bmm: To much uneccessary complexity
[00:47:40] <jvns> I'd still like to understand this first-class type thing
[00:47:42] <dbaupp> (tuples are also a nominal type, kinda, `struct Tuple2<A,B>(A,B);` could be a perfectly good desugaring of (,).)
[00:47:49] <strcat> jvns: it doesn't really mean anything
[00:47:50] <jvns> the manual talks about it quite a lot. does it not exist at all?
[00:47:56] <strcat> jvns: it doesn't currently existing
[00:48:00] <jvns> should all the sentences about it be deleted?
[00:48:00] <dbaupp> strcat: it is thanksgiving in the US, so people are away, etc.
[00:48:09] *** Joins: sprang (sprang@moz-920A95C4.hsd1.ca.comcast.net)
[00:48:12] <mib_163bmm> dbaupp: Yea that's how Scala does it
[00:48:16] <strcat> dbaupp: in general, it takes forever to merge anything now ;\
[00:48:21] <strcat> not specifically atm
[00:48:28] <mib_163bmm> strcat: Why?
[00:48:31] <Earnestly> strcat: Do you keep your tutorial changes in your fork?
[00:48:34] <mib_163bmm> docs not priority?
[00:48:38] <mib_163bmm> baking is?
[00:48:41] *** Joins: q66 (q66@6EE9DE40.46454B5D.33AABD5F.IP)
[00:48:44] <strcat> Earnestly: no I write them after the last PR gets merged
[00:48:56] <strcat> I don't like having 5+ PRs open with the chance it's all going to be rejected
[00:49:05] <strcat> my work is paced based on how fast it's accepted
[00:49:13] <strcat> that's how strcat's free time works ;p
[00:49:16] *** Quits: peterdn (chatzilla@moz-E4A450C.as13285.net) (Quit: ChatZilla 0.9.90.1-rdmsoft [XULRunner 22.0/20130619132145])
[00:49:29] <mib_163bmm> dbaupp: Are tuples not part of the type system?
[00:49:29] *** Quits: z0w0 (zack@moz-6264033D.qcl9.cha.bigpond.net.au) (Connection reset by peer)
[00:49:34] <Earnestly> I mean, if you keep an updated version which is more accurate then pulling from that would be better
[00:49:43] <cmr> mib_163bmm: of course they are.
[00:49:47] <strcat> Earnestly: but then I would have to deal with merge conflicts
[00:49:54] <cmr> mib_163bmm: I don't think that table on the homepage has been updated in over a hear.
[00:49:58] <Earnestly> :\
[00:50:19] <strcat> Earnestly: I used to contribute more actively but got very frustrated with spending 90% of my rust contribution time fixing merge conflicts
[00:50:26] <mib_163bmm> cmr: But I don't see a struct Tuple2<A, B>(A, B) as dbaupp said
[00:50:42] <cmr> The type of (5u, 5i) is (uint, int)
[00:50:44] <cmr> No name
[00:50:48] <dbaupp> mib_163bmm: "(tuples are also a nominal type, kinda, `struct Tuple2<A,B>(A,B);` *could be* a perfectly good desugaring of (,).)
[00:50:48] <bjz> mib_163bmm: that's hypothetical
[00:51:12] *** Quits: q66 (q66@6EE9DE40.46454B5D.33AABD5F.IP) (Connection reset by peer)
[00:51:16] *** Joins: q66 (q66@6EE9DE40.46454B5D.33AABD5F.IP)
[00:51:16] <mib_163bmm> ok cool
[00:51:40] <mib_163bmm> Why are black structs denoted struct Foo; not struct Foo {}
[00:51:42] <mib_163bmm> (without the semicolon)
[00:52:00] <bjz> mib_163bmm: ultimately it would be nice if tuples could be desugared to Tuple<T,..>(T,..); - dunno how possible that would be
[00:52:06] <cmr> there's an issue open for that iirc.
[00:52:14] *** Quits: joeatwork (joe@moz-F0C51B49.hsd1.ca.comcast.net) (Ping timeout)
[00:52:16] *** Joins: canhtak (canhtak@moz-6F820ACE.wl.t.ulaval.ca)
[00:52:17] <cmr> bjz: did you see eddyb's variadic typaram issue?
[00:52:25] <bjz> cmr: no
[00:52:31] <bjz> linky?
[00:52:33] <cmr> https://github.com/mozilla/rust/issues/10124
[00:53:12] <jvns> so on string types: what should the type be on `let string = "foobar";`?
[00:53:23] <cmr> jvns: &'static str
[00:53:41] <jvns> I thought someone said str wasn't a type?
[00:53:43] * jvns is confused
[00:53:49] <cmr> THe type is &'static str
[00:53:53] <cmr> &str with the lifetime 'static
[00:54:12] <strcat> jvns: it's not a type, it's a common syntax used to specify a few things that are types
[00:54:21] <jvns> urgh
[00:54:34] <strcat> & isn't a type, [ isn't a type, ~ isn't a type
[00:54:39] <strcat> &int and ~int are types
[00:54:43] <strcat> in the same way, str isn't a type.
[00:55:06] <strcat> ignoring the manual I don't think it's that hard to understand
[00:55:26] <andor> there are no nightly builds of win32 right now, correct?
[00:55:42] *** Joins: infynyxx (infynyxx@moz-8BE8F2CD.hsd1.md.comcast.net)
[00:55:43] *** Joins: eholk (eholk@moz-EA69C7A5.wavecable.com)
[00:55:48] <jvns> so is &'static str the same as something involving u8
[00:55:52] *** Quits: quvarxa (chatzilla@moz-978E4C31.static.tpgi.com.au) (Ping timeout)
[00:56:29] *** Joins: quvarxa (chatzilla@moz-978E4C31.static.tpgi.com.au)
[00:56:30] <mib_163bmm> If T is a type, what is ~T considered?
[00:56:46] *** Quits: aeqwa1 (aeqwa@moz-4064984B.dsl.tropolys.de) (Quit: WeeChat 0.4.3-dev)
[00:56:51] *** Quits: themgt (themgt@moz-83F07CDA.cm.vtr.net) (Ping timeout)
[00:57:00] *** Quits: strcat (strcat@moz-54F7FD49.cpe.net.cable.rogers.com) (Ping timeout)
[00:57:03] <jvns> man there definitely aren't any examples of string types in the tutorial
[00:57:08] <cmr> mib_163bmm: ~T is also a type.
[00:57:11] *** Quits: amro (quassel@D9E34ACF.8AAAF769.FAAB0799.IP) (Connection reset by peer)
[00:57:14] <jvns> or at least not in the "strings" section :)
[00:57:36] *** Quits: lenstr (lenstr@AF8EB999.6049B16A.85938D85.IP) (Client exited)
[00:57:39] <mib_163bmm> cmr: k
[00:58:29] *** Joins: themgt (themgt@moz-83F07CDA.cm.vtr.net)
[00:58:44] <jvns> are there a finite number of types involving strings (just strings, not vectors of strings)?
[00:58:58] *** Joins: maxli (maxli@moz-4D28BA20.student.cs.uwaterloo.ca)
[00:59:31] *** Quits: rusti (rusti@moz-54F7FD49.cpe.net.cable.rogers.com) (Connection reset by peer)
[00:59:38] *** Joins: strcat (strcat@moz-54F7FD49.cpe.net.cable.rogers.com)
[01:00:09] *** Joins: rusti (rusti@moz-54F7FD49.cpe.net.cable.rogers.com)
[01:00:21] <kimundi> jvns: There is the owned string ~str, the string lsice &str, and the deprecated managed string @str
[01:00:40] <kimundi> And that's it
[01:00:42] <jvns> and the static string?
[01:00:47] *** Quits: infynyxx (infynyxx@moz-8BE8F2CD.hsd1.md.comcast.net) (Client exited)
[01:00:48] <strcat> jvns: no
[01:00:50] <kimundi> That is just a special case of &str
[01:01:03] <jvns> but it's not a slice?
[01:01:03] <strcat> jvns: all &T, &str, &[T] have a lifetime
[01:01:08] <strcat> it's just anonymous by default
[01:01:17] <strcat> lifetimes are a form of subtyping
[01:01:20] <kimundi> &'static str is a string slice with static lifetime, which will probably point at a compiletime constant
[01:01:21] <strcat> &'static str is still &str
[01:01:41] <strcat> every &str has a lifetime
[01:01:44] <strcat> it's just not always explicit
[01:02:10] <mib_163bmm> So a lifetime is part of the type
[01:02:21] <strcat> yes, but it's subtyping
[01:02:40] *** Quits: wilmoore (wilmoore@moz-71431C3A.hsd1.co.comcast.net) (Ping timeout)
[01:02:45] <jvns> so if I sliced an owned string, would I get a &~str?
[01:02:55] <strcat> what do you mean 'sliced'?
[01:02:56] <mib_163bmm> Question. Where do closures go in the machine? The text segment?
[01:03:02] <strcat> jvns: &~str isn't a slice
[01:03:07] <strcat> it's a reference to a ~str
[01:03:10] <strcat> it's &T where T is ~str
[01:03:19] <jvns> hmm
[01:03:24] <kimundi> jvns: depending on what you do you can eiter end up with a &Str slice, or with a &~str reference
[01:03:28] <strcat> mib_163bmm: they're normal static functions
[01:03:40] <jvns> so if I do `let bar: ~str = ~"Hello!";`
[01:03:53] <strcat> there's no &str therre
[01:03:55] <strcat> there*
[01:03:56] <jvns> and I take a slice of bar, what is the type of the result?
[01:04:03] <strcat> what do you mean 'take a slice'
[01:04:34] <mib_163bmm> strcat: So then the ~, &, @, doesn't necessarily indicate the location of the closure in the machine, but the location of its closed contents?
[01:04:52] <strcat> mib_163bmm: yes, but that syntax is gone for closures
[01:05:00] <mib_163bmm> strcat: ?
[01:05:08] <strcat> closures no longer have sigils like that
[01:05:14] <mib_163bmm> oh
[01:05:23] <mib_163bmm> Where can I find the latest info?
[01:05:26] <strcat> there are only borrowed closures |u8, u8| -> bool and heap closures you can call once (proc)
[01:05:26] <jvns> strcat, I want to make an example something like this: https://gist.github.com/jvns/6609765d106b0ccce5e2
[01:05:42] <strcat> jvns: slice returns &str, yes
[01:06:19] <mib_163bmm> strcat: But heap closures are in the text segment of the machine though, right?
[01:06:25] <strcat> mib_163bmm: the code is all static
[01:06:29] *** Quits: ktt3ja (Mibbit@moz-54586A12.washdc.fios.verizon.net) (Quit: http://www.mibbit.com ajax IRC Client)
[01:06:29] <strcat> so yes
[01:06:32] <mib_163bmm> k
[01:06:49] <strcat> rust doesn't need an executable stack/heap
[01:06:50] <jvns> oh, huh
[01:07:08] <mib_163bmm> strcat: Do other langs require that?
[01:07:10] <jvns> I thought a slice of a &str and a slice of a ~str would have different types
[01:07:23] <strcat> jvns: slices are a view of a block of memory
[01:07:29] <strcat> string slices are a view of a block of memory that's UTF-8
[01:07:40] <strcat> can be memory anywhere
[01:07:51] *** Joins: ktt3ja (Mibbit@moz-54586A12.washdc.fios.verizon.net)
[01:08:07] <strcat> read-only memory, some memory on the stack, some memory in an arbitrary dynamic allocation
[01:08:18] <strcat> it's just a ptr + len providing a view of some buffer
[01:08:40] *** Quits: nkoep (nik@moz-AF5C1DFE.pool.mediaways.net) (Client exited)
[01:08:57] <strcat> ~str and ~[T] are dynamic arrays
[01:09:27] <strcat> all &~str is a ptr to a dynamic array, which has a ptr to a block of memory (double-indirection)
[01:09:46] <strcat> the only thing it provides over &str is that it knows the capacity, but that's basically irrelevant if you aren't mutating it
[01:10:03] <jvns> wait, but I can also run `let asdf: &str = "hello!"; `
[01:10:10] <jvns> I thought it had to be a &'static str
[01:10:11] *** Joins: twb (textual@moz-5DE8950B.hsd1.ga.comcast.net)
[01:10:35] <strcat> jvns: &'static str is a &str
[01:10:46] <jvns> hmm okay
[01:10:55] <strcat> &str is a slice
[01:10:59] <strcat> all &str have a lifetime
[01:11:13] <strcat> they can't outlive what they point at, and that's part of their type
[01:11:34] <strcat> if they don't have a named lifetime, they have an anonymous (inferred) lifetime
[01:11:50] <jvns> is &str the same as &[u8]?
[01:11:54] <strcat> no
[01:12:01] *** Quits: killerswan (kevincantu@moz-CC0DC654.hsd1.ca.comcast.net) (Quit: killerswan)
[01:12:03] <mib_163bmm> If managed pointers are implemented purely in the type system, how can they not inherit the mutability of their container?
[01:12:06] <ChrisMorgan> jvns: do you mean in representation or in function?
[01:12:06] <jvns> because of the guarantee?
[01:12:24] <strcat> mib_163bmm: inheriting mutability from an owner requires having an owner
[01:12:38] <strcat> a managed box is pointed to by many pointers, and none of them is an owner
[01:12:53] <strcat> there's no static way to give them safe mutability
[01:12:57] <jvns> so they're represented the same, but I can't cast one to the other?
[01:13:13] <ChrisMorgan> jvns: a &str has .as_bytes() which is &[u8].
[01:13:18] <strcat> jvns: you can't safely cast one to the other, they are unrelated types as far as the type system goes
[01:13:22] <jvns> cool
[01:13:28] <strcat> the library provides ways to do it
[01:13:36] <strcat> you can go &str -> &[u8] as a safe no-op
[01:13:48] <ChrisMorgan> But a &[u8] cannot be accessed as a &str, probably mainly due to the UTF-8 requirement.
[01:13:58] <strcat> the other way either requires validating it as utf-8, decoding it from some encoding or unsafety
[01:14:23] <strcat> ChrisMorgan: you can access it as &str, but it checks that it's valid utf-8 first
[01:14:24] <mib_163bmm> strcat: So how does one express ownership in the type system?
[01:14:34] <strcat> mib_163bmm: ownership is the 'default'
[01:14:49] <jvns> that makes sense!
[01:15:01] *** Joins: killerswan (kevincantu@moz-CC0DC654.hsd1.ca.comcast.net)
[01:15:46] <strcat> mib_163bmm: managed pointers (@) are not part of the language definition anymore
[01:15:47] <strcat> the syntax is being removed (it's already disabled by default)
[01:15:47] <strcat> anyway
[01:16:28] <strcat> Rc<T> and Gc<T> are immutable
[01:16:43] <strcat> if you're talking about the box
[01:17:07] <geomyidae> is Rc<T> like Arc?
[01:17:12] <strcat> mib_163bmm: https://github.com/thestinger/rust-core/blob/master/core/rc.rs perhaps it will make more sense if you look at the implementation
[01:17:22] <strcat> geomyidae: like Arc without atomic refcounting
[01:17:31] <strcat> https://github.com/thestinger/rust-core/blob/master/core/arc.rs nearly the same thing.
[01:18:02] <strcat> mib_163bmm: RcBox is the location the object is, and is pointed to by many pointers (Rc), none of which actually owns it
[01:18:09] <strcat> so it can't inherit mutability. there's no one true owner
[01:18:24] <ChrisMorgan> geomyidae: Rc is for use inside one task, Arc is for safe cross-task shared memory usage
[01:18:25] <strcat> it would be memory unsafe to make it mutable if the reference to it was in a mutable slot
[01:18:44] <mib_163bmm> strcat: I understand that
[01:18:48] <mib_163bmm> But that's not my question
[01:19:04] <strcat> well I don't know your question, then
[01:19:14] <mib_163bmm> My question is how do you tell the type system that you are something that is shared
[01:19:26] <strcat> you don't, the type system treats everything as owned
[01:19:29] <mib_163bmm> So any enclosing object's aren't owned
[01:19:53] *** Quits: quvarxa (chatzilla@moz-978E4C31.static.tpgi.com.au) (Ping timeout)
[01:19:56] <strcat> shared ownership is built via owned references, but the box itself isn't owned - how? because the box itself is a private detail
[01:19:58] *** Joins: earlzlap (earlz@moz-483E1E31.neo.res.rr.com)
[01:20:36] <strcat> mib_163bmm: you'll see that there's nothing expressing lack of ownership in that implementation
[01:20:50] <strcat> just #[no_send] to make it non-sendable because it doesn't use atomic refcounting (but Arc doesn't have that)
[01:20:58] *** Joins: quvarxa (chatzilla@moz-978E4C31.static.tpgi.com.au)
[01:21:20] <mib_163bmm> strcat: But how does the compiler know not to give your type the owned trait if it contains owned references
[01:21:21] <strcat> the implementation just can't expose methods providing mutation because they wouldn't be safe
[01:21:21] *** kimundi is now known as zz_kimundi
[01:21:26] <strcat> mib_163bmm: there's no owned trait
[01:21:45] <mib_163bmm> "If an object doesn't contain garbage-collected boxes, it consists of a single ownership tree and is given the Owned trait"
[01:21:51] <strcat> not correct
[01:21:55] <mib_163bmm> ugh
[01:22:09] <strcat> there's a Send trait (can be sent to another task) and a Freeze trait (is immutable or inherits mutability)
[01:22:39] <bjz> strcat: is there something like a move_zip?
[01:22:46] <strcat> bjz: move_iter + zip?
[01:22:56] <andor> i know this isn't entireley rust specific, but i'm trying to set up rust cross-compilation under debain 7.0 for windows, and ./configure is failing
[01:22:57] <bjz> ahh
[01:22:59] <bjz> hahah
[01:23:06] <strcat> bjz: that's the point of iterators :)
[01:23:14] <andor> i use ./configure --mingw32-cross-path=/usr/bin --build=i686-pc-mingw32 for command line and it breaks with:
[01:23:19] <andor> checking for i686-pc-mingw32-clang... gcc -m32
[01:23:20] <andor> checking for C compiler default output file name... configure: error: C compiler cannot create executables
[01:23:24] <andor> it's picking up the wrong compiler
[01:23:25] <strcat> (that vectors can have 20 of them, and yet the adaptors work for any of them)
[01:23:32] <andor> it's supposed to be i586-mingw32msvc-gcc
[01:23:36] <mib_163bmm> strcat: So these traits are part of the language not the type system
[01:23:54] <strcat> mib_163bmm: Send and Freeze? they're defined in the stdlib and the compiler magically assigns them to types they apply to
[01:24:06] <jvns> does "However, there are no mutable string slices." imply that there are no mutable strings at all?
[01:24:13] <jvns> can owned strings be mutable?
[01:24:28] <strcat> jvns: strings that are dynamic arrays (~str) inherit mutability
[01:24:42] <mib_163bmm> strcat: So how do I determine if something is owned or not
[01:24:53] *** Quits: tiffany (kawaii@moz-FC0DB29D.dhcp.embarqhsd.net) (Input/output error)
[01:24:53] <mib_163bmm> Or does that terminology not precise anymore
[01:24:57] <strcat> mib_163bmm: it's precise
[01:25:03] <strcat> it's a semantic thing, not a type system thing
[01:25:09] <strcat> it was never a type system thing
[01:25:18] <mib_163bmm> "If an object doesn't contain garbage-collected boxes, it consists of a single ownership tree and is given the Owned trait"
[01:25:26] <strcat> yeah, that's wrong
[01:25:29] <Luqman> andor: so --build won't work afaik
[01:25:35] <strcat> the Send trait was incorrectly called Send before
[01:25:37] <strcat> er
[01:25:41] <strcat> the Send trait was incorrectly called Owned before
[01:25:47] <strcat> but it didn't mean 'owned'
[01:25:50] <strcat> it meant sendable
[01:26:09] <andor> strcat: well it does seem to respect it though...
[01:26:17] <strcat> andor: hm?
[01:26:23] <mib_163bmm> So to implement gc you need unsafe code
[01:26:36] <strcat> to implement low-level memory management you need unsafe code
[01:26:47] <jvns> oh, so I can do "let mut bar = ~"Hello!"; "
[01:26:54] <jvns> what is its type, though?
[01:26:59] <strcat> ~str
[01:27:11] <strcat> jvns: mutability is inherited from the owner, all the way down
[01:27:16] <geomyidae> ChrisMorgan: you still letting that coin ride? :)
[01:27:21] <strcat> struct Foo { x: int, y: ~str }
[01:27:27] <jvns> oh hmm
[01:27:28] <ChrisMorgan> Yeah, too lazy (?) to do anything about it
[01:27:30] <andor> strcat: i mean in CFG_HOST etc...
[01:27:30] <strcat> let mut x = Foo { ... };
[01:27:39] *** Quits: jdm (jdm@FCCEA34F.7672369.D8E68FF6.IP) (Quit: Lost terminal)
[01:27:42] <strcat> andor: oh I wasn't following that
[01:27:49] <jvns> so I can't tell if a variable is mutable or not from its type?
[01:27:55] <geomyidae> ChrisMorgan: I mostly just curious what its like for someone like you who wound up with one... probably without really intending to :P
[01:27:56] <andor> but CFG_GCC seems to be wrong
[01:28:05] <andor> strcat: is there a way to force CFG_GCC to some value?
[01:28:10] <strcat> jvns: in general, mutability is inherited from the owner, it's not part of the types
[01:28:17] <mib_163bmm> strcat: Okay if it's inherited "all the way down" then how can I own an immutable box? The box is not a type?
[01:28:22] <strcat> jvns: the only exception is for when there's a lack of ownership
[01:28:26] <strcat> mib_163bmm: it is a type
[01:28:30] <jvns> urg
[01:28:42] <strcat> mib_163bmm: again, the type system doesn't know about shared ownership
[01:28:47] <mib_163bmm> strcat: So is it a struct?
[01:28:48] <strcat> it knows about references
[01:28:56] <strcat> mib_163bmm: Gc and Rc are a struct
[01:29:01] <strcat> they don't have public fields
[01:29:01] *** Joins: _Y_ (Mibbit@moz-CAA19CD6.dynamic.isp.telekom.rs)
[01:29:12] <ChrisMorgan> geomyidae: true, I hadn't been going to do so myself.
[01:29:33] <mib_163bmm> strcat: Oh, I didn't realie Rust had private fields
[01:29:35] <mib_163bmm> oops
[01:29:46] <strcat> jvns: if you say 'let mut x = 5', the type is 'int' and it's mutable because it inherited mutability from the owner
[01:30:03] <strcat> if you have a struct with a bunch of fields, the struct and the fields (and anything they contain) are mutable if the struct is somewhere mutable
[01:30:28] <jvns> hmm I think I should postpone understanding mutability to later
[01:30:31] <strcat> now... some types do have private data, and they may represent different semantics
[01:30:34] *** Quits: ricepuddin (graham@moz-7D68765A.cable.virginm.net) (Ping timeout)
[01:30:35] <jvns> still working on strings :)
[01:30:38] *** flaper87 is now known as flaper87|afk
[01:30:41] <mib_163bmm> strcat: And owner's mutability affect priv fields too?
[01:30:44] *** Joins: azita (Azita@moz-C1FB2A8.hsd1.ca.comcast.net)
[01:31:02] <bjz> strcat: would we be able to have a free-standing zip function?
[01:31:03] <_Y_> hiya, guys, does anyone know why I'd get following error:  failed to resolve import `std::io::Reader`?
[01:31:08] <strcat> mib_163bmm: they're private so it doesn't do one thing or the other
[01:31:12] <strcat> you can't read or write to them
[01:31:16] <bjz> strcat: the method is super hard to arrange nicely
[01:31:26] <strcat> bjz: meh
[01:31:29] <mib_163bmm> strcat: But what about implementation methods?
[01:31:34] <strcat> bjz: we'll have Iterator::zip when method reform happens
[01:31:37] <mib_163bmm> They can read and write
[01:31:47] <strcat> mib_163bmm: privacy is on a module basis
[01:31:54] <strcat> and yes, inside the module, it inherits mutability
[01:32:14] <strcat> in general the type system only has ownership
[01:32:18] <strcat> except for references
[01:32:22] <strcat> that's *why* there is & and &mut
[01:32:24] <_Y_> has std::io:Reader been removed?
[01:32:29] <bjz> strcat: so I'm guessing we could do `pub use Iterator::zip;` in std::iter?
[01:32:30] <strcat> because they don't own what they point at, they can only *observe* mutability
[01:32:37] *** Joins: FreeFull_ (freefull@84554989.2217FB91.733134BA.IP)
[01:32:41] <strcat> bjz: I don't think we should add pub use statements like that though
[01:32:47] *** Joins: lfox (lfox@C5428AB8.4C3BA601.ECED8BE3.IP)
[01:32:50] <bjz> why?
[01:32:56] <strcat> bjz: because you can do Iterator::zip
[01:33:01] <strcat> you can 'use' it yourself
[01:33:08] <strcat> we don't need duplicate definitions of everything
[01:33:08] *** Quits: FreeFull (freefull@moz-33375531.skybroadband.com) (Ping timeout)
[01:33:11] <bjz> Iterator::zip is very verbose
[01:33:20] <strcat> bjz: and iterator::zip isn't?
[01:33:38] <strcat> bjz: if we have to re-export every method as a free function, we shouldn't have methods
[01:33:41] <jvns> so if I have a mutable string `hello`, I can't do `hello[1] = 'a'`
[01:33:46] <jvns> it wants a u8 instead
[01:33:53] <bjz> you mean the user would do: `use iter::Iterator::zip;` ?
[01:33:55] <mib_163bmm> strcat: So are mutable and immutable implementations kept separate by Rust?
[01:33:59] <strcat> jvns: you can't mutate a string via u8 mutations, safely
[01:34:16] <strcat> mib_163bmm: methods take a self paramter
[01:34:18] <strcat> parameter*
[01:34:25] <strcat> they can take it by-value, by-reference or by-mutable-reference
[01:34:25] <jvns> strcat, how do I mutate a string?
[01:34:34] <strcat> jvns: via methods defined on ~str
[01:34:38] <jvns> oh!
[01:34:52] <strcat> jvns: UTF-8 is a variable-length encoding so mutating the string may require changing the size
[01:34:57] <mib_163bmm> strcat: What about mutable by value?? :D
[01:35:03] <bjz> bjz: so it would still be able to be imported as a free standing function - just not publicly exported in std::iter?
[01:35:06] <strcat> mib_163bmm: sure... if you have it by-value you can mutate it
[01:35:11] <strcat> let x = 5;
[01:35:12] <bjz> *strcat
[01:35:14] <strcat> let mut x = 5;
[01:35:19] <strcat> fn foo(self)
[01:35:21] <strcat> fn foo(mut self)
[01:35:36] <strcat> although by-value self is still buggy
[01:35:53] <strcat> bjz: yes
[01:36:01] <strcat> bjz: methods would be usable as free functions in a scope
[01:36:04] <strcat> you'd be able to import them
[01:36:08] <strcat> if method reform happened
[01:36:13] <strcat> you could do...
[01:36:28] <mib_163bmm> So if you have an immutable handle on a mutable gc box you cannot access its methods that act on mut &self
[01:36:41] <bjz> strcat: I just wonder why zip needs to be a method at all, seeing as Zip has priv members
[01:36:43] <strcat> mib_163bmm: Gc/Rc only expose &self methods, though
[01:36:59] <strcat> bjz: it's a method because you have to choose between a function and a method and I chose method
[01:37:38] <strcat> methods chain better and you don't need a bunch of names in scope for it to be pretty
[01:37:55] <strcat> they only exist for the method syntax
[01:38:01] <strcat> haskell has type classes, and doesn't have methods.
[01:38:01] <bjz> strcat: oh, I guess if you have multiple zips
[01:38:14] <strcat> bjz: well it will often be in a chain of iterators
[01:38:27] <strcat> a.map(...).zip(b.filter(...)).map(...)
[01:38:28] <bjz> then it might be nicer to have method style
[01:38:33] <bjz> mm
[01:38:38] <strcat> vs
[01:38:47] <_Y_> guys, I have a problem, with latest rust and I don't know if the docs are ok
[01:39:07] <strcat> map(zip(map(a, ...), filter(b, ...)), ...)
[01:39:08] <strcat> or whatever
[01:39:17] <mib_163bmm> Wow I just realized... rust supports multiple dispatch...
[01:39:19] <strcat> bjz: I like that methods read left to right, in the order it happens
[01:39:26] <_Y_> has std::io::reader been moved or something?
[01:39:33] <jvns> oh!
[01:39:45] <jvns> the documentation for std::str is so much more clear than the tutorial
[01:39:46] <strcat> mib_163bmm: traits are entirely static in the common use cases, though
[01:39:46] <bjz> strcat: well I guess what I was saying that 'map' makes sense as a method, because it has an obvious 'self'
[01:39:54] <jvns> it has examples and everything
[01:40:32] <bjz> strcat: but I guess if you have to chain multiple zips it might look better
[01:40:54] *** Quits: Earnestly (earnest@38FE72A5.82423D8F.BFD1ABFD.IP) (Ping timeout)
[01:41:19] <mib_163bmm> strcat: What is meant by a static vs dynamic trait?
[01:41:28] <mib_163bmm> I know of early/late binding
[01:42:33] <_Y_> static means, it's etched into a diamond and launched into space
[01:43:02] <mib_163bmm> -_-
[01:43:14] <_Y_> it's a joke :)
[01:43:42] <_Y_> not sure who said such things about static strings 
[01:44:12] *** oz is now known as petantik
[01:45:32] *** Quits: fiirhok (fiirhok@EEC1213C.4468D718.41AEFB3C.IP) (Client exited)
[01:45:54] <jvns> so are these all the ways to make strings? https://gist.github.com/jvns/7714356
[01:47:39] <mib_163bmm> Is it possible to dynamic dispatch based on self?
[01:47:50] <jvns> (thanks so much for answering all my questions! <3)
[01:48:26] <dbaupp> jvns: (there's also .as_slice, .slice_from and .slice_to as wrappers for .slice, fwiw.)
[01:50:05] <jvns> lindsey kuper is at hacker school this week and pointed out that writing an OS is exactly the kind of thing Rust is intended for, so I'm trying it out =)
[01:50:11] <mib_163bmm> yea strcat dbaupp thanks for answering my questions, too
[01:50:44] <_Y_> silly question, but when you rebuild rust, do you just update master and run configure/make/install
[01:50:54] <mib_163bmm> Everyone knows the next OS is being built in Haskell
[01:50:55] <_Y_> or you delete everything and start from scratch
[01:51:02] *** Quits: eholk (eholk@moz-EA69C7A5.wavecable.com) (Ping timeout)
[01:51:06] <_Y_> Haskell is so last season
[01:51:18] <_Y_> Build it in Scala :P
[01:51:36] *** Joins: eholk (eholk@moz-EA69C7A5.wavecable.com)
[01:51:43] <mib_163bmm> yay a JVM based OS long live JVM
[01:52:06] <_Y_> correction, an overly complex JVM language based OS
[01:52:54] *** Quits: azita (Azita@moz-C1FB2A8.hsd1.ca.comcast.net) (Quit: azita)
[01:53:16] *** Joins: santiago (santiago@moz-CF057779.lv.lv.cox.net)
[01:53:30] <mib_163bmm> Well at least they give free lessons on coursera
[01:55:12] <_Y_> Is anyone here on rust master?
[01:55:41] <_Y_> I need someone to help me with an experiment involving std::io::Reader;
[01:55:52] *** Quits: jst_ (quassel@moz-BBE3ABD.mv.mozilla.com) (Ping timeout)
[01:55:55] *** Joins: jst_ (quassel@moz-BBE3ABD.mv.mozilla.com)
[01:56:41] *** Quits: canhtak (canhtak@moz-6F820ACE.wl.t.ulaval.ca) (Quit: canhtak)
[01:57:18] <dbaupp> _Y_: yes?
[01:57:27] <mib_163bmm> "Is it possible to dynamic dispatch based on self?" -- sorry I realized that wuestion doesn't make sense
[01:57:53] <_Y_> can anyone just take any compiling example and stick 'use std::io::Reader' to top
[01:58:00] <_Y_> sry
[01:58:12] <_Y_> copy pasta
[01:58:49] <_Y_> meant to say just take any compiling file and stick `use std::io::Reader` to top and recompile
[01:58:51] *** Quits: notmatt (notmatt@moz-9FB2565E.vc.shawcable.net) (Client exited)
[01:59:10] <mib_163bmm> Why can't union types be made on the fly? Like let x: T or E = ...;
[01:59:12] <_Y_> if it compiles with an error, then my rust installation is corrupted
[01:59:40] <_Y_> @mib: I assume it's hard to guess the size needed to allocate them?
[02:00:09] <_Y_> unless they are pointers
[02:00:21] <dbaupp> _Y_: I don't understand?
[02:00:45] <_Y_> test.rs:1:4: 1:27 error: failed to resolve import `std::io::mem::BufReader` test.rs:1 use std::io::mem::BufReader;               ^~~~~~~~~~~~~~~~~~~~~~~ error: aborting due to 2 previous errors task 'rustc' failed at 'explicit failure', /home/daniel/dev/rust/src/libsyntax/diagnostic.rs:101 task '<main>' failed at 'explicit failure', /home/daniel/dev/rust/src/
[02:00:47] <mib_163bmm> Nvm I guess I could make let x: (Opetion[T], Option [E]) = ...;
[02:01:00] <_Y_> there is Either enum, no?
[02:01:13] <_Y_> that can be A or B
[02:01:18] <_Y_> but not obth
[02:01:23] *** Quits: eholk (eholk@moz-EA69C7A5.wavecable.com) (Ping timeout)
[02:01:27] <_Y_> both*
[02:01:38] <mib_163bmm> _Y_: In the std?
[02:01:51] <_Y_> std or extra
[02:02:03] <_Y_> std
[02:02:04] <mib_163bmm> Maybe I should just go learn Haskell lol
[02:02:08] <mib_163bmm> Then come back to rust
[02:02:12] <_Y_> heh
[02:02:18] <_Y_> that's pretty much what I did
[02:02:18] <mib_163bmm> Why is Rust necessary?
[02:02:30] <mib_163bmm> _Y_: Worth it?
[02:02:45] <_Y_> Haskell can get pretty mathy at some points
[02:03:08] <_Y_> learning haskell?
[02:03:11] <mib_163bmm> Going to
[02:03:20] <mib_163bmm> brb dinner
[02:03:50] <dbaupp> _Y_: maybe the imports have changed?
[02:04:27] <_Y_> what do you mean by that?
[02:04:52] <_Y_> it was just Rust example program from rust-lang + use
[02:05:03] <_Y_> there was no crates or fancy stuff
[02:05:28] <_Y_> admittedly I'm not too familiar with rust imports
[02:06:02] *** Quits: Yurumechan (23f9939a@B2F514.E4420F21.EEF52F3A.IP) (Client exited)
[02:06:13] <dbaupp> what version of Rust? a very recent master?
[02:06:25] <_Y_> yup, like 1hr ago
[02:06:58] *** Quits: Jesin (Jesin@moz-27916D21.washdc.fios.verizon.net) (Quit: Leaving)
[02:09:14] <dbaupp> hm, weird
[02:09:58] *** Quits: SiegeLord (sl@moz-C606190.bstnma.fios.verizon.net) (Quit: Leaving)
[02:10:03] *** Quits: mib_163bmm (Mibbit@1EEF8F2.50A2C647.5A42B74E.IP) (Quit: http://www.mibbit.com ajax IRC Client)
[02:10:05] *** Joins: eholk (eholk@moz-EA69C7A5.wavecable.com)
[02:10:24] *** Quits: sprang (sprang@moz-920A95C4.hsd1.ca.comcast.net) (Quit: sprang)
[02:10:28] <bjz> mib_163bmm: Rust is necessary for high performance systems programming with better safety guarantees than C or C++
[02:10:44] <bjz> oh, he left :)
[02:11:00] <_Y_> In voice of Arnie "He'll be back"
[02:11:14] <bjz> heh
[02:11:25] <_Y_> bjz I do really really hope Rust lives on
[02:11:37] <_Y_> so far best language I tried
[02:11:59] <_Y_> but I sadly have pechant for weird languages
[02:12:19] *** Joins: Yurumechan (23f9939a@B2F514.E4420F21.EEF52F3A.IP)
[02:12:19] *** Quits: dbaupp (Thunderbir@moz-3BE4086E.lns20.syd6.internode.on.net) (Quit: dbaupp)
[02:13:01] *** Joins: dbaupp (Thunderbir@moz-3BE4086E.lns20.syd6.internode.on.net)
[02:13:45] <bjz> _Y_: even if it doesn't, it's definitely pushed the bar further
[02:14:38] <_Y_> agreed, but I still kind want it and Servo to "win"
[02:14:43] *** Joins: SiegeLord (sl@moz-C606190.bstnma.fios.verizon.net)
[02:14:46] <bjz> _Y_: ie. it's brought regions, linear types, and the possibility of safe, deterministic memory management to a wider audience
[02:14:59] *** Joins: Skif (emschwar@moz-4C5BB5A8.beyondbb.com)
[02:15:23] <_Y_> and mario
[02:15:28] <_Y_> don't forget mario
[02:15:32] <bjz> ?
[02:15:43] <_Y_> SproketNes?
[02:16:08] <bjz> ah. heh. I do believe you're joking :)
[02:16:44] <bjz> _Y_: hypothetically I could see Rust being supersceded by a dependently typed, pure functional language with Rust's unboxed types and regions
[02:16:47] <bstrie> yes, without rust I never would have heard of mario
[02:16:49] *** Quits: Skif (emschwar@moz-4C5BB5A8.beyondbb.com) (Ping timeout)
[02:17:01] <_Y_> yes I am kind sir
[02:17:01] <bstrie> that should be part of our tagline
[02:17:09] <bstrie> but, maybe we will get sued
[02:17:19] <bjz> _Y_: but I don't think people are ready for that yet :P
[02:17:31] <_Y_> jokes?
[02:17:41] <_Y_> or Mario?
[02:18:28] *** Joins: canhtak (canhtak@moz-6F820ACE.wl.t.ulaval.ca)
[02:18:29] <_Y_> I just like how Rust marries best of Haskell and C
[02:19:49] <_Y_> you guys need an XML parser, right?
[02:20:05] <_Y_> it was on list of missing libraries 
[02:20:48] *** zz_kimundi is now known as kimundi
[02:21:52] *** Quits: etw (john@moz-D871A25B.nyc.res.rr.com) (Ping timeout)
[02:24:01] *** Quits: maxli (maxli@moz-4D28BA20.student.cs.uwaterloo.ca) (Quit: Leaving.)
[02:24:03] *** Joins: maxli (maxli@moz-4D28BA20.student.cs.uwaterloo.ca)
[02:28:20] <jstevans1> rustc creates ELF object code when targeting ARM. Is there a way to convert that to PE object code?
[02:28:41] <jstevans1> Or to get rustc to output PE ARM object code*
[02:32:18] *** Joins: ricepuddin (graham@moz-7D68765A.cable.virginm.net)
[02:33:16] *** Quits: DAddYE (DAddYE@moz-98D3933F.hsd1.ca.comcast.net) (Client exited)
[02:34:13] *** Quits: _Y_ (Mibbit@moz-CAA19CD6.dynamic.isp.telekom.rs) (Quit: http://www.mibbit.com ajax IRC Client)
[02:34:58] *** Joins: Sharp (Sharp@moz-39EFDA61.hfc.comcastbusiness.net)
[02:36:52] *** Quits: Ferreus (ferreus@moz-303EBF2B.pools.arcor-ip.net) (Ping timeout)
[02:37:02] <jvns> hmm, which version of rust do I need to have to use rust-core? master?
[02:37:19] <jvns> I tried using 0.8 and got some errors
[02:38:25] <strcat> master
[02:38:59] <jvns> thanks :)
[02:39:35] <jvns> made the mistake of deleting my rust/ directory to free up disk space :(
[02:40:03] <strcat> which OS are you on?
[02:40:19] <strcat> there are pre-built nightly binaries for Arch and Ubuntu
[02:40:33] <strcat> maybe Fedora... dunno
[02:41:06] <jvns> oh!
[02:41:10] <jvns> I'm on Ubuntu
[02:41:16] <jvns> =D =D =D
[02:41:26] *** Quits: lmandel (lmandel@moz-76CE9D51.cable.teksavvy.com) (Ping timeout)
[02:43:07] <jvns> it would be amazing if that were on the rust homepage
[02:43:46] <strcat> jvns: https://github.com/mozilla/rust/wiki/Doc-packages,-editors,-and-other-tools
[02:43:49] <strcat> yeah should be in the tutorial
[02:43:59] <strcat> or the main page, maybe
[02:44:06] <strcat> but for sure in the setup part of the tutorial
[02:44:34] <jvns> yeah for sure
[02:46:01] *** Quits: hjr3 (hradtke@1A0AE795.28A5F6C3.A2D40ED2.IP) (Quit: My MacBook has gone to sleep. ZZZzzz)
[02:46:42] *** Quits: derek_c (derek@moz-842C9B2A.cit.cornell.edu) (Ping timeout)
[02:47:45] *** Joins: lmandel (lmandel@moz-2009B55A.cable.teksavvy.com)
[02:48:21] *** Joins: glennsl (textual@moz-5D7B804F.getinternet.no)
[02:49:32] <jvns> oh no, 'rust run' went away!
[02:49:39] *** Quits: nsf (nsf@moz-EEF3238A.convex.ru) (Quit: WeeChat 0.4.2)
[02:50:21] *** Quits: lfox (lfox@C5428AB8.4C3BA601.ECED8BE3.IP) (Quit: ZZZzzz)
[02:50:24] *** Quits: glennsl (textual@moz-5D7B804F.getinternet.no) (Ping timeout)
[02:50:26] <strcat> jvns: we could add it back as rustc --run, it's just that the `rust` tool was totally removed
[02:51:09] <strcat> it's hard to maintain two frontends to the same functionality (more to document too)
[02:51:34] <jvns> that makes sense
[02:52:05] <jvns> huh now I get a bunch of errors about macros when trying to use rust core http://pastebin.com/SrUGrjry
[02:52:21] <strcat> jvns: need #[feature(macro_rules)]
[02:52:33] <strcat> it *shouldn't* be needed, but atm feature flags only work at crate level
[02:52:42] *** Quits: ricepuddin (graham@moz-7D68765A.cable.virginm.net) (Ping timeout)
[02:52:47] <jvns> I need to put that in my code? or in rust core?
[02:52:50] <strcat> (soon you'll need #[feature(macro_rules, thread_local)])
[02:52:52] <strcat> jvns: in your code
[02:52:56] <strcat> where #[no_std]; is 
[02:53:52] <strcat> basically because it defines these https://github.com/thestinger/rust-core/blob/master/core/macros.rs
[02:53:59] <strcat> and exports them
[02:54:13] <jvns> hmm I added #[feature(macro_rules)] below #[no_std] but I'm still getting the same errors
[02:54:37] <strcat> jvns: needs a semicolon at the end
[02:54:48] <strcat> or it applies to the next item rather than the containing item (the crate)
[02:54:54] <jvns> oh!
[02:55:01] <jvns> sweet
[02:55:09] <jvns> now I just need to deal with the change in closure syntax
[02:55:21] <jvns> but the compiler tells me how! <3
[02:56:07] *** Quits: lmandel (lmandel@moz-2009B55A.cable.teksavvy.com) (Ping timeout)
[02:56:33] <benh> strcat: procs still live in ~ memory, right? are you gonna push for custom allocators for them too?
[02:56:58] <strcat> benh: I don't really care about how procs allocate ;]
[02:56:59] *** Quits: GeneralMaximus (ankur@704E18E2.13A5FC81.D5D59AD9.IP) (Ping timeout)
[02:57:14] <jvns> "main.rs:56:24: 56:37 error: type `&str` does not implement any method in scope named `to_bytes`"
[02:57:16] <strcat> at least, because so far I have only used them for spawning threads
[02:57:19] <jvns> hmm I thought core was going to give me this
[02:57:29] <strcat> jvns: not yet
[02:57:29] *** Joins: lmandel (lmandel@moz-76CE9D51.cable.teksavvy.com)
[02:57:38] *** Joins: GeneralMaximus (ankur@704E18E2.13A5FC81.D5D59AD9.IP)
[02:57:52] <jvns> oh, so I can't convert strings to byte vectors?
[02:58:01] <strcat> well you can use core::mem::transmute
[02:58:38] <strcat> fn to_bytes<'a>(s: &'a str) -> &'a [u8] { unsafe { transmute(x) } }
[02:58:41] <strcat> fn to_bytes<'a>(s: &'a str) -> &'a [u8] { unsafe { transmute(s) } }
[02:58:47] *** Quits: earlzlap (earlz@moz-483E1E31.neo.res.rr.com) (Ping timeout)
[02:58:52] <strcat> anyway core is missing a lot of functionality but it will get added
[03:00:00] *** Quits: lmandel (lmandel@moz-76CE9D51.cable.teksavvy.com) (Ping timeout)
[03:00:50] *** Joins: DAddYE (DAddYE@moz-98D3933F.hsd1.ca.comcast.net)
[03:00:53] *** Quits: DAddYE (DAddYE@moz-98D3933F.hsd1.ca.comcast.net) (Client exited)
[03:04:25] *** Joins: lmandel (lmandel@moz-76CE9D51.cable.teksavvy.com)
[03:05:38] *** Quits: steve (Thunderbir@moz-329E56D.hsd1.fl.comcast.net) (Ping timeout)
[03:05:51] *** Joins: DAddYE (DAddYE@moz-98D3933F.hsd1.ca.comcast.net)
[03:06:23] <jvns> awesome, that to_bytes() function works
[03:06:40] *** Joins: dsantiago (santiago@moz-CF057779.lv.lv.cox.net)
[03:06:45] *** Quits: santiago (santiago@moz-CF057779.lv.lv.cox.net) (Ping timeout)
[03:07:39] *** Joins: earlzlap (earlz@moz-483E1E31.neo.res.rr.com)
[03:08:39] *** Quits: Sharp (Sharp@moz-39EFDA61.hfc.comcastbusiness.net) (Quit: Sharp)
[03:10:23] *** Quits: lmandel (lmandel@moz-76CE9D51.cable.teksavvy.com) (Ping timeout)
[03:10:39] *** Joins: gunther (Mibbit@1EEF8F2.50A2C647.5A42B74E.IP)
[03:11:01] <gunther> If Rust only uses "lightweight tasks with message passing" how is there a global exchange heap?
[03:11:48] *** Quits: fhahn (fhahn@moz-7924DB5C.vie.surfer.at) (Ping timeout)
[03:11:48] <cmr> gunther: "exchange heap" is a super outdated term.
[03:11:49] <strcat> gunther: it doesn't *only* use message passing, but message passing doesn't require copying to a different heap
[03:12:05] *** Joins: wilmoore (wilmoore@moz-71431C3A.hsd1.co.comcast.net)
[03:12:16] <strcat> gunther: if you send ~SomeValue to another task, it will do it by-move
[03:12:22] <strcat> a ptr copy
[03:12:23] <cmr> it's basically just malloc-allocated things
[03:12:54] <strcat> Arc == safe, immutable shared memory, and there's also MutexArc and RWArc
[03:13:19] <strcat> rust-core has a few blocking concurrent queues and hash maps atm, will have more soon enough ;p
[03:15:00] <jvns> hmm how do I iterate over my string now
[03:15:08] *** Quits: killerswan (kevincantu@moz-CC0DC654.hsd1.ca.comcast.net) (Quit: killerswan)
[03:15:33] <strcat> jvns: well rust-core only has vector iterators atm
[03:15:38] <jvns> I tried to use .iter() and got a mystery error: http://pastebin.com/2jJu4iRL
[03:15:46] <strcat> core::slice::iter
[03:15:52] <strcat> can't define methods on built-ins yet
[03:16:26] <strcat> (and you need to 'use core::option::{Some, Option}' for for loops to work iirc because they're a parser hack for now ;\)
[03:16:46] <strcat> freestanding rust is not painless yet ;p
[03:16:53] <jvns> now it says "error: type `&[u8]` does not implement any method in scope named `iter`"
[03:17:08] <jvns> after using core::slice::iter
[03:17:10] <strcat> jvns: core::slice::iter(xs)
[03:17:12] <strcat> er
[03:17:14] <strcat> well
[03:17:28] <strcat> use just imports a name into the current scope
[03:17:35] <jvns> that gives me a syntax error?
[03:17:37] <jvns> oh i see
[03:17:47] <strcat> jvns: shouldn't give a syntax error
[03:18:00] <strcat> either core::slice::iter(xs) or 'use core::slice::iter; iter(xs)' will work
[03:18:08] <jvns> I was just misunderstanding :)
[03:18:13] <jvns> now I get error: type `&mut core::slice::VecIterator<,u8>` does not implement any method in scope named `next`
[03:18:28] <strcat> jvns: yeah need to 'use core::iter::Iterator;' too
[03:18:33] <strcat> the stdlib has a prelude injected by the compiler and it includes a bunch of stuff like this
[03:18:57] <strcat> and it also (ab)uses traits to implement methods on built-ins, even though they're for a specific type and not intended to be generic (and throws all these traits in the prelude)
[03:19:13] <jvns> urg
[03:19:33] <strcat> again all fixable language issues.... the problem is that most people use the stdlib and don't run into these rough spots much
[03:19:38] <jvns> so I got an "error: mismatched types: expected `u8` but found `&u8` (expected u8 but found &-ptr)" on the line putchar(ix, iy, b);
[03:19:47] <strcat> jvns: yeah the iterator will yield references
[03:19:49] <jvns> so I changed it to *b
[03:19:51] <jvns> but now it says
[03:19:56] <jvns> error: unreachable pattern
[03:20:04] *** Joins: fhahn (fhahn@moz-7924DB5C.vie.surfer.at)
[03:20:07] *** Quits: kimundi (kimundi@moz-E2132B33.dip0.t-ipconnect.de) (Ping timeout)
[03:20:13] <strcat> jvns: need 'use core::option::Some;' 
[03:20:16] <strcat> and maybe None
[03:20:27] <strcat> for loops expand to a loop {} with a match on Some/None
[03:20:31] <strcat> it's a temporary hack ;(
[03:20:41] <jvns> IT WORKS
[03:20:44] <strcat> (again with the stdlib there's a prelude so.... this is all there already)
[03:20:46] <jvns> I printed my string =)
[03:20:49] <strcat> \o/
[03:21:26] <jvns> haha this is pretty fun
[03:21:37] <jvns> even though it is programming-via-sending-error-messages-to-strcat
[03:21:42] <jvns> :)
[03:22:02] * strcat should document it all in rust-core's README
[03:22:17] <o11c> reminds me of IRP
[03:23:25] *** Quits: DAddYE (DAddYE@moz-98D3933F.hsd1.ca.comcast.net) (Client exited)
[03:23:33] *** Joins: kimundi (kimundi@moz-6B8BCD77.dip0.t-ipconnect.de)
[03:27:08] *** Quits: maxli (maxli@moz-4D28BA20.student.cs.uwaterloo.ca) (Quit: Leaving.)
[03:27:43] *** Joins: kphelps (kphelps@moz-8F37EAB2.ri.ri.cox.net)
[03:27:51] *** kimundi is now known as zz_kimundi
[03:28:36] <jvns> man debugging when you're trying to implement printing is hard
[03:33:17] *** Joins: lkuper (lkuper@moz-72054E1A.nyc.res.rr.com)
[03:34:38] *** zz_kimundi is now known as kimundi
[03:35:36] <jvns> lkuper: hi! =D
[03:35:48] <lkuper> jvns: hey!
[03:36:05] *** Quits: wilmoore (wilmoore@moz-71431C3A.hsd1.co.comcast.net) (Ping timeout)
[03:36:15] <jvns> lkuper: you infected me with rust
[03:36:28] <lkuper> muahahaha
[03:36:57] <jvns> now I am trying to use freestanding rust and rust-core and having all the problems =D
[03:39:17] *** Joins: lenstr (lenstr@AF8EB999.6049B16A.85938D85.IP)
[03:41:04] *** Quits: lenstr (lenstr@AF8EB999.6049B16A.85938D85.IP) (Ping timeout)
[03:43:11] *** Joins: brianm (brianm@moz-8161EF8D.hsd1.ca.comcast.net)
[03:44:07] *** Joins: wilmoore (wilmoore@moz-71431C3A.hsd1.co.comcast.net)
[03:47:07] *** Quits: refold (gman@moz-42D68426.a258.priv.bahnhof.se) (Quit: leaving)
[03:47:13] *** Joins: erickt1 (Adium@49C4075F.3AC15C18.2321E71E.IP)
[03:48:32] *** Joins: notmatt (notmatt@moz-9FB2565E.vc.shawcable.net)
[03:50:56] *** Quits: sarclops (sarclops@moz-DE5C3EA6.zone8.bethere.co.uk) (Connection reset by peer)
[03:50:57] *** Joins: sarclops (sarclops@moz-DE5C3EA6.zone8.bethere.co.uk)
[03:58:50] *** Quits: eholk (eholk@moz-EA69C7A5.wavecable.com) (Quit: eholk)
[04:03:43] *** Joins: Skif (emschwar@moz-4C5BB5A8.beyondbb.com)
[04:05:26] *** Quits: Skif (emschwar@moz-4C5BB5A8.beyondbb.com) (Ping timeout)
[04:06:05] <ChrisMorgan> unexpected token: `<eof>`
[04:07:01] *** Joins: brson (brson@981AA104.E81F12CD.76F66111.IP)
[04:07:01] *** ChanServ sets mode: +ao brson brson
[04:11:20] *** Joins: eholk (eholk@moz-EA69C7A5.wavecable.com)
[04:11:29] *** Joins: Sharp (Sharp@moz-39EFDA61.hfc.comcastbusiness.net)
[04:13:10] *** Quits: Sharp (Sharp@moz-39EFDA61.hfc.comcastbusiness.net) (Quit: Sharp)
[04:16:46] *** Quits: wilmoore (wilmoore@moz-71431C3A.hsd1.co.comcast.net) (Ping timeout)
[04:28:02] *** Quits: jvns (bork@87D98E32.4046EB22.428F94DD.IP) (Ping timeout)
[04:28:47] <bstrie> "DRY is the highest principle of software engineering." #shitHNsays
[04:30:50] *** Quits: james4k (james@moz-E7990244.consolidated.net) (Ping timeout)
[04:32:23] <sam113101> HN?
[04:34:29] *** Joins: DAddYE (DAddYE@moz-98D3933F.hsd1.ca.comcast.net)
[04:34:36] <ktt3ja> sam113101: news.ycombinator.com
[04:36:14] *** Quits: DAddYE (DAddYE@moz-98D3933F.hsd1.ca.comcast.net) (Ping timeout)
[04:36:29] <klutzy> is there some reason that .read_line() is provided by Buffer, not Reader itself?
[04:37:00] <o11c> klutzy: because you can't read a line at a time efficiently without buffering
[04:38:08] <klutzy> hmm, it would make sense. thanks!
[04:38:28] <SiegeLord> What about a BufReader :P
[04:39:27] <klutzy> I wanted `for line in reader.lines()` then I got this http://pastebin.com/jtkkepPm
[04:40:03] *** Joins: lenstr (lenstr@AF8EB999.6049B16A.85938D85.IP)
[04:41:26] *** Joins: voxpopuli (fanservice@moz-CEF3689A.hsd1.pa.comcast.net)
[04:41:53] *** Quits: lenstr (lenstr@AF8EB999.6049B16A.85938D85.IP) (Ping timeout)
[04:42:38] <ChrisMorgan> klutzy: looks about right to me, except you should be doing it for Buffer
[04:43:04] *** Joins: jlong (jlong@moz-6DFDE846.socal.res.rr.com)
[04:43:23] <klutzy> ChrisMorgan: right, I should've used it
[04:43:45] <klutzy> BufferedReader<T> caused debugging harder :'(
[04:45:09] *** Quits: earlzlap (earlz@moz-483E1E31.neo.res.rr.com) (Ping timeout)
[04:49:12] <ChrisMorgan> klutzy: http://pastebin.com/DsbR9ReF
[04:49:51] <klutzy> ChrisMorgan: oops, I should've paste new version asap :p http://pastebin.com/KizN1N4i
[04:50:19] *** Quits: csherratt (csherratt@moz-CAF331EA.cable.teksavvy.com) (Ping timeout)
[04:50:29] <klutzy> but your `buffer:` naming looks better!
[04:50:56] <ChrisMorgan> klutzy: mine is superior in two ways: the `buffer` field name and the use of Self in LineReader rather than having LineReader<T>
[04:51:26] *** Joins: csherratt (csherratt@moz-CAF331EA.cable.teksavvy.com)
[04:51:59] <klutzy> oh Self, I always forget it. good
[04:54:37] *** Joins: killerswan (kevincantu@moz-CC0DC654.hsd1.ca.comcast.net)
[04:55:19] *** Quits: recrack (Mibbit@B4104EBB.3CC170B1.1E14B209.IP) (Quit: http://www.mibbit.com ajax IRC Client)
[04:55:22] *** Joins: summerlight (summerligh@327FC32B.2C956A45.501EFF44.IP)
[04:59:33] *** Joins: jvns (bork@moz-DE62990.nyc.res.rr.com)
[05:03:45] *** Quits: canhtak (canhtak@moz-6F820ACE.wl.t.ulaval.ca) (Quit: canhtak)
[05:04:58] *** Quits: jvns (bork@moz-DE62990.nyc.res.rr.com) (Ping timeout)
[05:08:55] *** Joins: sprang (sprang@moz-920A95C4.hsd1.ca.comcast.net)
[05:09:11] *** Quits: voxpopuli (fanservice@moz-CEF3689A.hsd1.pa.comcast.net) (Ping timeout)
[05:09:12] *** Quits: sprang (sprang@moz-920A95C4.hsd1.ca.comcast.net) (Quit: sprang)
[05:09:59] *** Joins: sprang (sprang@moz-920A95C4.hsd1.ca.comcast.net)
[05:12:24] *** Joins: pseudoku (quassel@BCD3AE61.3B1029AF.520CDC98.IP)
[05:13:04] *** Quits: eholk (eholk@moz-EA69C7A5.wavecable.com) (Quit: eholk)
[05:16:50] *** Joins: alisdair (textual@28441AAB.AC6E1995.F0AE27BD.IP)
[05:19:47] <pseudoku> what does this error mean "error: last argument in `do` call has non-procedure type" , i recently updated my code to use the new closure syntax but i get this error now
[05:20:25] <cmr> pseudoku: `do` only works with procs now, not all closures.
[05:20:47] <cmr> rather than `do foo |x| { ... }`, use `foo(|x| { .... })`
[05:20:54] <pseudoku> cmr: :( will it work in the future?
[05:21:06] <cmr> unlikely.
[05:22:14] <pseudoku> its ugly to pass it like that. looks like javascript
[05:23:22] <cmr> bug pcwalton about it
[05:24:50] <dbaupp> there's no way to use std::fmt without using a trait object, is there?
[05:24:52] <dbaupp> acrichto: ^
[05:25:41] <acrichto> right now, now
[05:25:44] <pseudoku> it was really pretty to use do with map. any idea why was this necessary. isn't do just a syntax sugar to pass something as a last argument,?
[05:26:46] <dbaupp> :( I have a thing that spends 9% of it's time in MemWriter.write, which I assume would be inlined more without trait objects.
[05:26:49] <acrichto> dbaupp: whoops, right now no*
[05:27:15] <cmr> pseudoku: it was a causualty of the cleanup of closure inference.
[05:28:23] <SiegeLord> I believe you couldn't have both do spawn and do last_argument_is_a_closure without confusing semantics
[05:28:47] <SiegeLord> And apparently do spawn won
[05:29:44] *** Joins: wilmoore (wilmoore@moz-71431C3A.hsd1.co.comcast.net)
[05:30:39] <ChrisMorgan> Well, you could do it thus: proc form: `do spawn proc { }`, `do spawn proc(...) { }`, closure form: `do spawn { }`, `do spawn |...| { }`
[05:31:28] <ChrisMorgan> (Or make `do spawn { }` illegal, must be `do spawn || { }`; or swap it thus with the no-args proc.)
[05:31:41] <pseudoku> ChrisMorgan: that looks good and also more importantly is consistent with the declaration syntax
[05:32:16] <pseudoku> the first proposal i mean, do spawn proc() {}
[05:33:16] * strcat is happy with the consistency of using spawn(proc() { })
[05:34:11] *** Quits: lkuper (lkuper@moz-72054E1A.nyc.res.rr.com) (Quit: lkuper)
[05:34:48] * pseudoku is not going to touch rust till do works with closures
[05:36:26] <SiegeLord> Is the current syntax just do spawn || {} ?
[05:36:31] <SiegeLord> Not do spawn proc?
[05:36:31] <ChrisMorgan> || optional;
[05:36:46] <strcat> pseudoku: how often do you really use closures in rust anyway?
[05:37:00] <strcat> it's moving heavily to destructors for most of what it used to use closures for
[05:37:25] <pseudoku> strcat: a lot actually. usually with list map or option/result map
[05:37:28] *** Joins: enix (enix@moz-A50569DD.c3-0.slvr-ubr1.lnh-slvr.md.cable.rcn.com)
[05:37:37] <strcat> list as in iterator?
[05:37:38] *** Joins: DAddYE (DAddYE@moz-98D3933F.hsd1.ca.comcast.net)
[05:37:51] <pseudoku> strcat: yes
[05:37:57] *** Quits: DAddYE (DAddYE@moz-98D3933F.hsd1.ca.comcast.net) (Client exited)
[05:37:58] *** Joins: DAddYE_ (DAddYE@moz-98D3933F.hsd1.ca.comcast.net)
[05:38:31] <strcat> pseudoku: so you use it on small ones that aren't multi-line?
[05:38:34] <ChrisMorgan> I don't like the way it's `do with |closure, style, args| { }` even though it's a proc rather than a closure.
[05:39:02] <strcat> ChrisMorgan: great, lets remove the whole thing! :)
[05:39:18] <pseudoku> strcat: not really, most of them spawn multiple lines and also nested do are common
[05:39:37] <ChrisMorgan> I wouldn't argue against that (nor would I argue for it, though)
[05:39:59] <strcat> ChrisMorgan: more brainwashing from strcat required then
[05:40:30] <pseudoku> wasn't  any other syntax  considered for proc?
[05:40:32] <ChrisMorgan> I *would* prefer it as `do with proc(and, args) { }`, though. Then once it's like that, you can see clearly to allowing closures to use `do`.
[05:40:47] *** Joins: lenstr (lenstr@AF8EB999.6049B16A.85938D85.IP)
[05:41:00] <cmr> cook up a proposal and send it to pcwalton
[05:41:08] <strcat> I don't like the whole concept of making the last parameter special *at all*
[05:41:13] <strcat> I hate the whole thing
[05:41:20] <strcat> I absolutely despised the old for loops too
[05:41:25] <strcat> for more reasons though ;p
[05:41:46] <ChrisMorgan> Yeah, switching away from internal iteration was a good thing.
[05:42:11] <strcat> obviously `do` should be feature gated if it's controversial and changing all the time ;p
[05:42:29] *** Quits: lenstr (lenstr@AF8EB999.6049B16A.85938D85.IP) (Ping timeout)
[05:42:32] <pseudoku> strcat: i like the way it makes the code look clean and readable without having to parse all the nested (||{})
[05:42:39] * ChrisMorgan wonders whether that would kill it or not
[05:43:17] <strcat> pseudoku: foo(proc() {}) looks much better than foo(|| {}) and it only works with procs now anyway
[05:43:28] *** Quits: kphelps (kphelps@moz-8F37EAB2.ri.ri.cox.net) (Ping timeout)
[05:43:39] <strcat> `do` is basically just sugar for heap allocation now which rust usually avoids
[05:44:06] *** Joins: _alephlambda (alephlambd@moz-3D2CE66D.mycingular.net)
[05:45:03] <pseudoku> strcat: thats where i'm confused, why was do re-purposed to mean heap allocation? the original ruby-esque  'pass the block as last argument' makes more sense
[05:45:23] <sfackler> I'd personally been moving away from using do with iterator chains anyway, since it makes it way more awkward to chain
[05:45:26] <_alephlambda> Hi, I have a quick question about Rust's build process. If the architecture specified is Win64, then rustc produces a PE file. When the architecture is ARM, rustc gives an ELF file. Is choosing between PE/ELF done by rustc? I'm having a little bit of difficulty telling where it happens in the repo code. 
[05:45:30] *** Joins: itdnhr (it@moz-7FAAAB8D.bstnma.fios.verizon.net)
[05:46:09] <strcat> _alephlambda: it's done with a target triple
[05:46:16] <strcat> which target triple are you using?
[05:46:56] <_alephlambda> strcat: Um...Sorry, I'm not certain what you mean. 
[05:47:13] <pseudoku> also whats wrong with &fn() as the declaration syntax? sorry if i'm bringing up something that was settled a long time ago, but i only get to work with rust on weekends and thus miss out on most design discussions
[05:47:38] <strcat> _alephlambda: the target is specified as a target triple like x86_64-anything-linux-gnu
[05:47:41] <cmr> pseudoku: read the meeting notes.
[05:47:59] <strcat> _alephlambda: so I'm unclear exactly how you're specifying just 'ARM'
[05:47:59] <_alephlambda> strcat: Ah, okay. I've been using arm-linux-gnueabi
[05:48:07] <strcat> _alephlambda: well linux-gnu implies ELF
[05:48:24] <strcat> and I think it also implies glibc, but LLVM might not do anything with that
[05:49:15] <_alephlambda> strcat: Okay, let me go check aur again for other toolchains 
[05:49:36] <cmr> pseudoku: actually, http://smallcultfollowing.com/babysteps/blog/2013/10/10/fn-types-in-rust/
[05:50:18] * ChrisMorgan is writing a post to the mailing list about `do`.
[05:51:06] <pseudoku> cmr: thanks
[05:51:29] *** Joins: james4k (james@moz-E7990244.consolidated.net)
[05:51:47] <pseudoku> ChrisMorgan: cool! i'll keep my fingers crossed
[05:52:10] *** Quits: strcat (strcat@moz-54F7FD49.cpe.net.cable.rogers.com) (Quit: WeeChat 0.4.2)
[05:52:23] *** Joins: Skif (emschwar@moz-4C5BB5A8.beyondbb.com)
[05:54:02] <SiegeLord> I wonder if do can then be extended to all expressions... like do call 5;
[05:54:08] *** Quits: Skif (emschwar@moz-4C5BB5A8.beyondbb.com) (Ping timeout)
[05:54:11] <SiegeLord> Maybe that's too silly :P
[05:55:02] * bjz wonders why strcat is so against closure
[05:55:05] <bjz> *closures
[06:00:07] <_alephlambda> strcat: Wait, do I just need to change the triple to arm-win32-eabi? http://llvm.org/docs/doxygen/html/classllvm_1_1Triple.html
[06:01:05] <SiegeLord> rusti: let a: fn() = ||{};
[06:01:06] -rusti- pastebinned 6 lines of output: http://sprunge.us/hHFF
[06:01:31] <SiegeLord> rusti: let a: extern fn() = ||{};
[06:01:32] -rusti- <anon>:9:28: 9:34 error: mismatched types: expected `extern "Rust" fn()` but found `&fn<no-bounds>()` (expected extern fn but found fn)
[06:01:32] -rusti- <anon>:9          let a: extern fn() = ||{};
[06:01:32] -rusti-                                      ^~~~~~
[06:01:32] -rusti- error: aborting due to previous error
[06:01:32] -rusti- application terminated with error code 101
[06:01:48] <SiegeLord> Is there no extern fn literal?
[06:02:03] <pseudoku> SiegeLord: i like the idea of extending do for all expressions. its sort of like a primitive currying mechanism
[06:03:36] <dbaupp> bjz: bceause they're slow
[06:03:42] <dbaupp> bjz: and optimise poorly
[06:03:44] <SiegeLord> Hopefully one day we'll get heap closures and extern fn literals back
[06:03:58] <bjz> dbaupp: :(
[06:04:06] <klutzy> _alephlambda: afaik rustc just creates llvm-ir then llvm translates it to target .o file
[06:04:16] <bjz> dbaupp: so no way around that? how does C++ do it?
[06:04:19] <dbaupp> bjz: (mostly because they are essentially a trait object with the current implementation)
[06:04:27] <dbaupp> bjz: they have unboxed closures, which is better
[06:04:36] <bjz> dbaupp: can we do that?
[06:04:39] <dbaupp> yes
[06:05:03] <dbaupp> but probably post-1.0, aiui
[06:05:11] <bjz> it just seems sad to not have nice functional stuff
[06:05:50] <_alephlambda> klutzy: hmm...I'm not sure what all of that means. I'm new to this stuff. Going to run to Google. In the meantime, it's not true that any valid llvm triple is acceptable? Trying arm-win32-eabi gave 'error: building with `g++` failed with code 1
[06:06:17] <dbaupp> bjz: "to not have nice functional stuff *yet*"
[06:06:27] <bjz> :)
[06:06:32] <_alephlambda> klutzy: ah ok. llvm-ir is a temporary compiler?
[06:07:16] <cmr> _alephlambda: no? it's an intermediate representation which llvm can optimize and translate to native code.
[06:07:17] <bjz> dbaupp: do you think the current design is open to improvement when *yet* comes?
[06:07:34] <bjz> dbaupp: so that we can be competitve with C++11?
[06:07:53] <SiegeLord> Isn't this new design just a Callable/Func trait?
[06:08:13] <_alephlambda> cmr: gotcha, thanks.
[06:08:44] <dbaupp> bjz: yes
[06:09:01] <dbaupp> the hardest part will be making it possible to write the type of an unboxed closure in a type signature
[06:09:05] <dbaupp> (e.g. to return one)
[06:09:37] <bjz> dbaupp: yeah
[06:09:43] <dbaupp> it really requires something like https://github.com/mozilla/rust/issues/10448 to work nicely
[06:09:48] <bjz> dbaupp:  tricky stuff
[06:12:03] <ChrisMorgan> &once fn() is gone just at present, right?
[06:12:16] <cmr> yes
[06:12:27] <SiegeLord> Hopefully that problem is solved without return type inference... there was a nice idea about doing foo<T: Callable>() -> T
[06:13:47] * ChrisMorgan will take care not to mention &once fn in his post entitled "do" as that would dilute the discussion; let that come another time
[06:13:48] <dbaupp> SiegeLord: that would need special syntax, since it's using a trait backwards (and would still need return type inference for the thing to be usuable as an unboxed closure, since the compiler would need to know exactly which `T` it was).
[06:15:06] <SiegeLord> As long as you can't do fn foo() -> please_read_the_whole_function {} I'll be happy
[06:17:36] *** Joins: zl (Mibbit@moz-728AFDEC.central.biz.rr.com)
[06:18:17] *** Quits: DAddYE_ (DAddYE@moz-98D3933F.hsd1.ca.comcast.net) (Client exited)
[06:20:00] *** Joins: hjr3 (hradtke@moz-E87BDF1F.socal.res.rr.com)
[06:21:10] <SiegeLord> I'm sure there can be some way to specify an anonymous type without it just being some variant of 'auto'
[06:21:27] *** Parts: _alephlambda (alephlambd@moz-3D2CE66D.mycingular.net) ()
[06:24:29] *** Quits: zl (Mibbit@moz-728AFDEC.central.biz.rr.com) (Quit: http://www.mibbit.com ajax IRC Client)
[06:26:36] *** Quits: SiegeLord (sl@moz-C606190.bstnma.fios.verizon.net) (Quit: Leaving)
[06:31:21] *** Joins: DAddYE (DAddYE@moz-98D3933F.hsd1.ca.comcast.net)
[06:31:37] *** Quits: DAddYE (DAddYE@moz-98D3933F.hsd1.ca.comcast.net) (Client exited)
[06:31:38] *** Joins: DAddYE (DAddYE@moz-98D3933F.hsd1.ca.comcast.net)
[06:37:57] *** Joins: Pac (textual@moz-80ECDEA6.revip2.asianet.co.th)
[06:41:32] *** Joins: lenstr (lenstr@AF8EB999.6049B16A.85938D85.IP)
[06:42:02] *** Quits: jeaye (Jeaye@moz-34FEF2BB.hsd1.ca.comcast.net) (Quit: zzz)
[06:43:23] *** Quits: lenstr (lenstr@AF8EB999.6049B16A.85938D85.IP) (Ping timeout)
[06:45:20] *** Quits: alisdair (textual@28441AAB.AC6E1995.F0AE27BD.IP) (Quit: My MacBook Pro has gone to sleep. ZZZzzz)
[06:46:34] *** Joins: lmandel1 (uid15702@moz-E77DEB21.irccloud.com)
[06:46:42] *** Joins: alisdair (textual@28441AAB.AC6E1995.F0AE27BD.IP)
[06:46:43] *** Joins: Sharp (Sharp@moz-39EFDA61.hfc.comcastbusiness.net)
[06:47:17] *** Quits: GeneralMaximus (ankur@704E18E2.13A5FC81.D5D59AD9.IP) (Ping timeout)
[06:48:17] *** Quits: Sharp (Sharp@moz-39EFDA61.hfc.comcastbusiness.net) (Quit: Sharp)
[06:52:59] <ChrisMorgan> I'm about to post about ``do`` on the mailing list; anyone want to give it a quick review to ensure I've got everything correct to avoid wasting time in the thread? http://chrismorgan.info/temp/do.txt
[06:54:19] *** Joins: GeneralMaximus (ankur@E80823C7.9D30DD69.CA2C69FA.IP)
[06:55:50] *** Quits: erickt1 (Adium@49C4075F.3AC15C18.2321E71E.IP) (Quit: Leaving.)
[06:56:45] <cmr> ChrisMorgan: "despite it now being a closure" s/closure/procedure/
[06:56:48] *** Quits: enix (enix@moz-A50569DD.c3-0.slvr-ubr1.lnh-slvr.md.cable.rcn.com) (Quit: Konversation terminated!)
[06:57:16] <ChrisMorgan> Thanks, fixed.
[06:58:38] <cmr> lgtm
[06:58:48] <bjz> ChrisMorgan: looks good
[07:00:08] <ChrisMorgan> Thanks. I'll post it now.
[07:00:32] <pseudoku> Re: do
[07:00:48] *** Joins: pradeep (pradeep@5AB4884B.FCC4549.14D5B978.IP)
[07:00:52] <bjz> ChrisMorgan: I can't promise I missed anything, but I'm sure people will point that out
[07:01:07] *** Quits: pradeep (pradeep@5AB4884B.FCC4549.14D5B978.IP) (Quit: leaving)
[07:01:37] <ChrisMorgan> I just want, in any such things, to start with a fairly balanced perspective, and it helps if it lacks technical errors.
[07:03:25] <pseudoku> how about a seperate proc syntax i.e proc task.spawn || {..} ?
[07:06:04] <ChrisMorgan> That reintroduces the closure syntax and I don't think it ends up better than `do task.spawn proc() {}`.
[07:19:23] *** Joins: pradeep (pradeep@5AB4884B.FCC4549.14D5B978.IP)
[07:21:52] <diverse> hmm, it seems that keeping ``do`` will makes things more complicated as changes pile on, is it worth the sugar?
[07:22:04] * ChrisMorgan doesn't know
[07:22:28] <Eridius> I don't understand why we created proc() to begin with
[07:22:32] <cmr> I found only a few uses of `do` in my own code, and they all looked better without `do`.
[07:22:37] <Eridius> if you want to make allocation obvious, just use something like ~|| -> T
[07:22:39] <diverse> Eridius: I agree
[07:22:46] <cmr> Eridius: one can move into a proc, but not into a closoure.
[07:22:54] <cmr> this removes the need for Cell, and makes lots of things nice.
[07:22:55] <Eridius> I also don't understand why once-ness is being restricted to procs
[07:22:56] <cmr> r
[07:22:59] <Eridius> cmr: that's a property of once, not of allocation
[07:23:03] <cmr> sure
[07:23:06] * Eridius wants once stack closures
[07:23:25] <ChrisMorgan> Eridius: me too
[07:23:51] <ChrisMorgan> That's &once fn.
[07:24:09] <cmr> I think part of it is wanting to drastically simplify closures for 1.0
[07:24:17] <ChrisMorgan> Things like x.with_y should be &once fn.
[07:24:27] <Eridius> lots of stuff in the standard libraries should be once
[07:24:36] <pseudoku> cmr: simplify in what sense?
[07:24:42] <cmr> pseudoku: remove complexity.
[07:24:55] <ChrisMorgan> As a closure, they can't move without Cell, which is a pity when something is provably once.
[07:26:13] <pseudoku> cmr: i mean what part of closure was considered complicated? 
[07:26:33] <ChrisMorgan> Personally I think an efficient &once fn (one inlined in most or all cases) is probably more generally useful than &fn, though you can't reasonably do without the latter.
[07:27:30] *** Joins: BizarreCake (BizarreCak@moz-361FE9B2.dynamic.barak-online.net)
[07:27:38] <pseudoku> ChrisMorgan: it seems the old syntax ( ~once fn) solves most of the issues? am i missing something?
[07:28:41] <ChrisMorgan> Bear in mind that the intended changes are not complete; things were going to be getting better in some ways anyway as various things were fixed.
[07:28:52] <ChrisMorgan> We are in an intermediate state.
[07:29:10] *** Quits: james4k (james@moz-E7990244.consolidated.net) (Ping timeout)
[07:29:23] <ChrisMorgan> These changes were necessary in some degree as part of DST, too.
[07:35:12] <diverse> How is the DST doing so far?
[07:35:50] <cmr> it is facing some existential doubt
[07:36:41] *** Quits: arodier74 (Thunderbir@5901C3C8.B6144566.D3B9122.IP) (Ping timeout)
[07:36:48] *** Joins: arodier74 (Thunderbir@5901C3C8.B6144566.D3B9122.IP)
[07:36:59] <Eridius> with Niko's SST proposal, I have to wonder how it works with a struct that has two fields of the same parameterized type
[07:37:39] <Eridius> e.g. struct Foo<T> { one: *T, two: *T }. What is Foo<[T]>? Can the compiler turn it into ((one, two), length1, length2)?
[07:38:07] <Eridius> i.e. is it smart enough to realize it needs to be `exists N, M` instead of just `exists N`?
[07:39:56] *** Quits: dew (Instantbir@moz-E4452B8F.static.stls.mo.charter.com) (Connection reset by peer)
[07:41:00] *** Quits: alisdair (textual@28441AAB.AC6E1995.F0AE27BD.IP) (Quit: Textual IRC Client: www.textualapp.com)
[07:41:08] *** Joins: Skif (emschwar@moz-4C5BB5A8.beyondbb.com)
[07:41:09] *** Joins: victorporof (victorporo@FB8E2A00.483E5FE1.9B1E38F4.IP)
[07:42:19] *** Joins: lenstr (lenstr@AF8EB999.6049B16A.85938D85.IP)
[07:42:56] *** Quits: Skif (emschwar@moz-4C5BB5A8.beyondbb.com) (Ping timeout)
[07:43:25] *** Quits: brson (brson@981AA104.E81F12CD.76F66111.IP) (Quit: leaving)
[07:44:01] *** Quits: lenstr (lenstr@AF8EB999.6049B16A.85938D85.IP) (Ping timeout)
[07:45:24] *** Joins: dew (Instantbir@moz-E4452B8F.static.stls.mo.charter.com)
[07:53:15] *** Joins: ohler (ohler@C7A9365F.7E6A0813.1428D117.IP)
[07:54:02] *** Joins: Jackneill (Jackneill@moz-CEEE36B2.pool.digikabel.hu)
[07:55:52] *** Quits: brianm (brianm@moz-8161EF8D.hsd1.ca.comcast.net) (Quit: Leaving...)
[07:56:01] *** Quits: Jesse (jruderman@moz-5973C6FA.oc.oc.cox.net) (Quit: Jesse)
[07:59:52] *** Quits: victorporof (victorporo@FB8E2A00.483E5FE1.9B1E38F4.IP) (Quit: victorporof)
[08:02:31] *** Quits: cubic (cubic@moz-80241A3A.mc.videotron.ca) (Quit: Leaving)
[08:03:29] *** Joins: jj2baile_ (jon@moz-AB7945E9.csclub.uwaterloo.ca)
[08:04:10] *** Quits: jj2baile_ (jon@moz-AB7945E9.csclub.uwaterloo.ca) (Quit: Lost terminal)
[08:08:41] *** Joins: Ms2ger (Ms2ger@C91975CB.3387515C.187A1082.IP)
[08:13:13] *** Quits: hjr3 (hradtke@moz-E87BDF1F.socal.res.rr.com) (Quit: My MacBook has gone to sleep. ZZZzzz)
[08:16:23] *** Quits: JamesNZ (james@moz-264643C7.bitstream.orcon.net.nz) (Quit: Busying myself...)
[08:24:36] *** Quits: ohler (ohler@C7A9365F.7E6A0813.1428D117.IP) (Quit: ohler)
[08:25:55] *** Quits: rusti (rusti@moz-54F7FD49.cpe.net.cable.rogers.com) (Ping timeout)
[08:26:17] *** Joins: brianm (brianm@moz-8161EF8D.hsd1.ca.comcast.net)
[08:26:37] <diverse> btw, why did they change it to `proc()`?
[08:27:01] <Ms2ger> Because nobody liked 'once fn'
[08:27:05] <cmr> diverse: http://smallcultfollowing.com/babysteps/blog/2013/10/10/fn-types-in-rust/
[08:27:12] <cmr> And the other blog posts.
[08:27:14] *** Joins: g3xzh (g3xzh@moz-85224D43.red.bezeqint.net)
[08:27:15] <cmr> And the ML threads...
[08:27:19] <cmr> And the meeting notes...
[08:27:46] * Ms2ger hears cmr volunteer to write up a post-mortem
[08:27:51] *** Joins: eddyb (eddy@EBE709F3.F7C96DA2.FCAAE698.IP)
[08:28:01] <cmr> gah no
[08:28:03] *** Joins: brianm_ (brianm@moz-8161EF8D.hsd1.ca.comcast.net)
[08:28:05] <cmr> make nmatsakis do it
[08:28:10] <cmr> I barely understand this issue.
[08:28:27] *** Quits: brianm (brianm@moz-8161EF8D.hsd1.ca.comcast.net) (Connection reset by peer)
[08:28:28] <eddyb> lol
[08:28:35] * eddyb reads backlog
[08:29:39] *** Joins: mib_lg3je4 (Mibbit@moz-B6D2878B.cable.telstraclear.net)
[08:29:44] * diverse would rather have cmr write up the next TWiR
[08:30:33] *** Quits: mib_lg3je4 (Mibbit@moz-B6D2878B.cable.telstraclear.net) (Quit: http://www.mibbit.com ajax IRC Client)
[08:30:50] *** Quits: brianm_ (brianm@moz-8161EF8D.hsd1.ca.comcast.net) (Ping timeout)
[08:31:11] *** Joins: oberstet (quassel@moz-B10754C7.dynamic.mnet-online.de)
[08:32:06] <eddyb> oh, too bad my RAM usage reduction PR can't go in TWiR (yet) :(
[08:32:23] <cmr> it still has a good ~12 hours to land :)
[08:32:43] <eddyb> hehe
[08:33:19] <eddyb> I'll get to testing, then
[08:37:05] *** Quits: notmatt (notmatt@moz-9FB2565E.vc.shawcable.net) (Client exited)
[08:38:02] *** Quits: Pac (textual@moz-80ECDEA6.revip2.asianet.co.th) (Quit: Textual IRC Client: www.textualapp.com)
[08:38:43] *** Joins: nkoep (nik@moz-262E6D4E.pool.mediaways.net)
[08:39:10] *** Quits: dforsyth (dforsyth@A677A619.1C765EF.EE6E63A5.IP) (Ping timeout)
[08:40:03] *** Quits: GeneralMaximus (ankur@E80823C7.9D30DD69.CA2C69FA.IP) (Ping timeout)
[08:40:50] *** Joins: mr_trousers (Mibbit@C83F40FA.C3C4EFEF.4BC5EF08.IP)
[08:41:18] *** Quits: mr_trousers (Mibbit@C83F40FA.C3C4EFEF.4BC5EF08.IP) (Quit: http://www.mibbit.com ajax IRC Client)
[08:41:58] *** Quits: gunther (Mibbit@1EEF8F2.50A2C647.5A42B74E.IP) (Quit: http://www.mibbit.com ajax IRC Client)
[08:42:30] *** Joins: dforsyth (dforsyth@A677A619.1C765EF.EE6E63A5.IP)
[08:42:53] *** Joins: rusti (rusti@moz-54F7FD49.cpe.net.cable.rogers.com)
[08:43:01] *** Joins: lenstr (lenstr@AF8EB999.6049B16A.85938D85.IP)
[08:44:51] *** Quits: lenstr (lenstr@AF8EB999.6049B16A.85938D85.IP) (Ping timeout)
[08:45:57] *** Quits: twb (textual@moz-5DE8950B.hsd1.ga.comcast.net) (Quit: My MacBook Pro has gone to sleep. ZZZzzz)
[08:46:20] *** Quits: eddyb (eddy@EBE709F3.F7C96DA2.FCAAE698.IP) (Ping timeout)
[08:47:27] *** Joins: derek_c (derek@moz-E72F174.cit.cornell.edu)
[08:48:16] *** Joins: peterdn (chatzilla@moz-E4A450C.as13285.net)
[08:51:04] <saati> is it possible to return a new proc closing over the same variables from a proc to make it callable more than one time?
[08:51:44] *** Joins: eddyb (eddy@EBE709F3.F7C96DA2.FCAAE698.IP)
[08:54:01] *** Joins: lenstr (lenstr@AF8EB999.6049B16A.85938D85.IP)
[08:57:58] <Ms2ger> A proc is only callable once
[08:58:45] *** Joins: MrOrdinaire (Mibbit@3A7560AE.91E92340.FD383126.IP)
[08:59:05] <saati> yes but can it return a new proc owning the same enviroment and call that?
[08:59:06] *** Quits: dew (Instantbir@moz-E4452B8F.static.stls.mo.charter.com) (Ping timeout)
[08:59:35] *** Joins: dew (Instantbir@moz-E4452B8F.static.stls.mo.charter.com)
[09:00:21] *** Quits: MrOrdinaire (Mibbit@3A7560AE.91E92340.FD383126.IP) (Quit: http://www.mibbit.com ajax IRC Client)
[09:01:31] *** Quits: dew (Instantbir@moz-E4452B8F.static.stls.mo.charter.com) (Ping timeout)
[09:01:45] *** Joins: dew (Instantbir@moz-E4452B8F.static.stls.mo.charter.com)
[09:04:05] *** Quits: eddyb (eddy@EBE709F3.F7C96DA2.FCAAE698.IP) (Ping timeout)
[09:04:52] <Eridius> saati: Apparently not. I just tried and I get `error: capture of moved value` (actually, two of them; one for both procs)
[09:04:57] <Eridius> s/both/each/
[09:06:26] <saati> ah, thanks
[09:06:29] <Eridius> interesting, you can't even return the captured variable from the proc
[09:06:33] <Eridius> not sure why not. This may be a bug
[09:07:26] <Eridius> actually you can't move out of captured outer variable in a heap closure
[09:07:36] <Eridius> which is odd because I thought the point of procs is they move their captured variables into their environment
[09:12:52] *** Quits: wilmoore (wilmoore@moz-71431C3A.hsd1.co.comcast.net) (Ping timeout)
[09:14:16] *** Joins: mikezaby (mikezaby@moz-AA896205.home.otenet.gr)
[09:14:25] *** Parts: mikezaby (mikezaby@moz-AA896205.home.otenet.gr) ()
[09:18:57] *** Quits: killerswan (kevincantu@moz-CC0DC654.hsd1.ca.comcast.net) (Quit: killerswan)
[09:21:32] *** Joins: wilmoore (wilmoore@moz-71431C3A.hsd1.co.comcast.net)
[09:21:39] *** Quits: dew (Instantbir@moz-E4452B8F.static.stls.mo.charter.com) (Ping timeout)
[09:21:55] *** Joins: dew (Instantbir@moz-E4452B8F.static.stls.mo.charter.com)
[09:22:59] *** Quits: ktt3ja (Mibbit@moz-54586A12.washdc.fios.verizon.net) (Quit: http://www.mibbit.com ajax IRC Client)
[09:23:10] *** Quits: tedh (tedh@moz-A5D1CAB7.public.wayport.net) (Ping timeout)
[09:26:26] *** Joins: tedh (tedh@moz-A5D1CAB7.public.wayport.net)
[09:28:04] *** Joins: brianm (brianm@moz-8161EF8D.hsd1.ca.comcast.net)
[09:28:36] *** Quits: dew (Instantbir@moz-E4452B8F.static.stls.mo.charter.com) (Ping timeout)
[09:28:47] *** Joins: dew (Instantbir@moz-E4452B8F.static.stls.mo.charter.com)
[09:28:49] *** Quits: lenstr (lenstr@AF8EB999.6049B16A.85938D85.IP) (Client exited)
[09:29:06] *** Quits: Blub\0 (wry@620605B3.71150E1A.237AE2BA.IP) (Ping timeout)
[09:29:52] *** Joins: Skif (emschwar@moz-4C5BB5A8.beyondbb.com)
[09:30:18] *** Joins: Blub\0 (wry@620605B3.71150E1A.237AE2BA.IP)
[09:30:24] *** Quits: brianm (brianm@moz-8161EF8D.hsd1.ca.comcast.net) (Ping timeout)
[09:31:38] *** Quits: Skif (emschwar@moz-4C5BB5A8.beyondbb.com) (Ping timeout)
[09:32:19] *** Quits: Kxepal (Miranda@moz-62D3C795.pppoe.mtu-net.ru) (Ping timeout)
[09:34:21] *** Joins: eddyb (eddy@EBE709F3.F7C96DA2.FCAAE698.IP)
[09:35:43] *** Quits: g3xzh (g3xzh@moz-85224D43.red.bezeqint.net) (Client exited)
[09:36:20] *** Quits: derek_c (derek@moz-E72F174.cit.cornell.edu) (Quit: Leaving)
[09:42:27] *** Joins: lenstr (lenstr@AF8EB999.6049B16A.85938D85.IP)
[09:43:18] *** Joins: Blei (philipp@moz-B2F9E4BD.cust.bluewin.ch)
[09:45:43] *** Quits: nyux (nyux@moz-1CEE0DD2.aiiane.com) (Ping timeout)
[09:45:53] *** Joins: GeneralMaximus (ankur@704E18E2.13A5FC81.D5D59AD9.IP)
[09:47:16] *** Quits: eddyb (eddy@EBE709F3.F7C96DA2.FCAAE698.IP) (Ping timeout)
[09:50:11] *** Quits: dredozubov (dredozubov@moz-1E374954.nationalcablenetworks.ru) (Quit: Leaving...)
[09:51:38] *** Joins: dredozubov (dredozubov@moz-1E374954.nationalcablenetworks.ru)
[09:57:00] *** Joins: eddyb (eddy@EBE709F3.F7C96DA2.FCAAE698.IP)
[09:57:33] *** Joins: beifeng (Mibbit@B5497CF4.FA7FF645.C7DB8B78.IP)
[09:58:46] *** Quits: lenstr (lenstr@AF8EB999.6049B16A.85938D85.IP) (Quit: Leaving...)
[09:59:03] *** Joins: Sharp (Sharp@moz-39EFDA61.hfc.comcastbusiness.net)
[10:00:27] *** Quits: Sharp (Sharp@moz-39EFDA61.hfc.comcastbusiness.net) (Quit: Sharp)
[10:00:43] *** Quits: eddyb (eddy@EBE709F3.F7C96DA2.FCAAE698.IP) (Ping timeout)
[10:01:05] *** Joins: eddyb (eddy@EBE709F3.F7C96DA2.FCAAE698.IP)
[10:08:28] *** Joins: Sharp (Sharp@moz-39EFDA61.hfc.comcastbusiness.net)
[10:09:46] *** Joins: Axord (xord@moz-C0D5F15A.lsanca.dsl-w.verizon.net)
[10:10:03] *** Quits: pradeep (pradeep@5AB4884B.FCC4549.14D5B978.IP) (Quit: leaving)
[10:11:45] *** Quits: Axord (xord@moz-C0D5F15A.lsanca.dsl-w.verizon.net) (Ping timeout)
[10:11:58] *** Quits: csherratt (csherratt@moz-CAF331EA.cable.teksavvy.com) (Quit: csherratt)
[10:12:33] *** Quits: pseudoku (quassel@BCD3AE61.3B1029AF.520CDC98.IP) (Quit: http://quassel-irc.org - Chat comfortably. Anywhere.)
[10:14:09] *** Quits: Sharp (Sharp@moz-39EFDA61.hfc.comcastbusiness.net) (Quit: Sharp)
[10:14:24] *** Joins: Sharp (Sharp@moz-39EFDA61.hfc.comcastbusiness.net)
[10:16:54] *** Quits: Sharp (Sharp@moz-39EFDA61.hfc.comcastbusiness.net) (Quit: Sharp)
[10:18:11] *** Joins: Ferreus (ferreus@moz-5E3FA94E.pools.arcor-ip.net)
[10:23:21] *** Quits: DAddYE (DAddYE@moz-98D3933F.hsd1.ca.comcast.net) (Client exited)
[10:24:02] *** Quits: eddyb (eddy@EBE709F3.F7C96DA2.FCAAE698.IP) (Ping timeout)
[10:24:58] *** Joins: eddyb (eddy@EBE709F3.F7C96DA2.FCAAE698.IP)
[10:26:52] *** Quits: wilmoore (wilmoore@moz-71431C3A.hsd1.co.comcast.net) (Ping timeout)
[10:28:00] *** Joins: Axord (xord@moz-C0D5F15A.lsanca.dsl-w.verizon.net)
[10:28:04] *** Joins: brianm (brianm@moz-8161EF8D.hsd1.ca.comcast.net)
[10:29:58] *** Quits: brianm (brianm@moz-8161EF8D.hsd1.ca.comcast.net) (Ping timeout)
[10:31:35] *** Joins: james4k (james@moz-E7990244.consolidated.net)
[10:31:39] <TeXitoi> is there a real reason of Reader::bytes(self) and not Reader::bytes(&mut self) ?
[10:32:47] *** Joins: tiffany (kawaii@moz-FC0DB29D.dhcp.embarqhsd.net)
[10:32:55] <bjz> Has there been a change to Path::new? https://travis-ci.org/bjz/gl-rs#L239
[10:33:01] <ChrisMorgan> bjz: Path::init
[10:33:07] <bjz> ook
[10:33:18] <bjz> thanks!
[10:33:21] *** Quits: james4k (james@moz-E7990244.consolidated.net) (Ping timeout)
[10:33:27] <ChrisMorgan> https://github.com/mozilla/rust/pull/10697
[10:35:05] <nielsle> Will all method named new be renamed in to init?
[10:35:23] <diverse> I wonder about that as well
[10:36:03] <ChrisMorgan> nielsle: uncertain; the general trend among the core team is that way, but Eridius started a thread about it on the mailing list just now.
[10:36:28] <nielsle> Thanks
[10:37:00] <diverse> are they planning on adding a `new` keyboard?
[10:37:13] <Blei> yes, placement new
[10:37:27] <diverse> *key
[10:38:06] *** Joins: sankha93 (Instantbir@7061CD01.D6BD0D91.22D41759.IP)
[10:39:05] <diverse> is it for struct construction?
[10:39:48] <ChrisMorgan> No, it's for placement or storage; basically what ~ is and what smart pointers should be, but more flexible.
[10:40:07] <diverse> that's neat
[10:40:23] <Blei> https://github.com/mozilla/rust/wiki/Meeting-weekly-2013-10-29#placement-new
[10:41:13] <ChrisMorgan> Incidentally, Eridius, I'll say I agree with your point of view entirely. I don't like init for creating a new oneit *is* a constructor (like in Python __new__), not an initialiser (like __init__). init is semantically wrong.
[10:43:31] *** Quits: bjz (bjz@moz-DD4A2A91.lnse2.cha.bigpond.net.au) (Ping timeout)
[10:44:40] *** Quits: GeneralMaximus (ankur@704E18E2.13A5FC81.D5D59AD9.IP) (Ping timeout)
[10:47:23] *** Joins: nano (nano@moz-74CAD1CA.superkabel.de)
[10:48:08] *** Joins: mimcpher (uid11663@moz-5F4AA75A.irccloud.com)
[10:51:04] *** Quits: eddyb (eddy@EBE709F3.F7C96DA2.FCAAE698.IP) (Ping timeout)
[10:51:43] *** Joins: jzelinskie_ (uid17772@moz-A42E5B7B.irccloud.com)
[10:51:57] *** Quits: jzelinskie (ubuntu@moz-C69D33B5.compute-1.amazonaws.com) (Quit: WeeChat 0.4.2-dev)
[10:51:58] *** jzelinskie_ is now known as jzelinskie
[10:52:59] *** Joins: GeneralMaximus (ankur@704E18E2.13A5FC81.D5D59AD9.IP)
[10:53:13] <diverse> They don't seem sure about the placement new from that meeting
[10:54:06] *** Quits: BizarreCake (BizarreCak@moz-361FE9B2.dynamic.barak-online.net) (Connection reset by peer)
[10:57:24] <diverse> Blei: are they really concrete about using it?
[10:57:47] <Blei> i don't know, that's the only real discussion i could find
[10:58:16] <Blei> but then there's this as well: https://github.com/mozilla/rust/pull/10727#issuecomment-29532094
[11:04:24] *** Joins: donri (donri@moz-9BB61102.tbcn.telia.com)
[11:05:14] <diverse> I'm starting to agree with ChrisMorgan though. Using `init()` doesn't feel right. For the programmers, they aren't just initializing fields in a struct, they are also returning and creating a struct, right?
[11:05:53] *** Joins: lenstr (lenstr@AF8EB999.6049B16A.85938D85.IP)
[11:06:27] *** Quits: arodier74 (Thunderbir@5901C3C8.B6144566.D3B9122.IP) (Ping timeout)
[11:07:33] <kimundi> righzt
[11:08:30] <diverse> so just my opinion, something like `make()` or `create()` would be more evident for the programmer
[11:09:12] <kimundi> probably
[11:09:52] <diverse> there is probably a ton of words you can pick besides thouse :)
[11:09:54] <diverse> *those
[11:10:54] *** Quits: lenstr (lenstr@AF8EB999.6049B16A.85938D85.IP) (Quit: Leaving...)
[11:12:53] *** Quits: dredozubov (dredozubov@moz-1E374954.nationalcablenetworks.ru) (Input/output error)
[11:15:19] *** Joins: samnardoni (samnardoni@FC9A45BE.3393236F.BFD1ABFD.IP)
[11:17:38] *** Joins: Earnestly (earnest@38FE72A5.82423D8F.BFD1ABFD.IP)
[11:18:28] *** Joins: pseudoku (quassel@BCD3AE61.3B1029AF.520CDC98.IP)
[11:18:37] *** Joins: Skif (emschwar@moz-4C5BB5A8.beyondbb.com)
[11:20:21] *** Quits: Skif (emschwar@moz-4C5BB5A8.beyondbb.com) (Ping timeout)
[11:21:52] <diverse> just looking up for synonyms I came up with: Foo::construct(), Foo::compose(), Foo::generate()
[11:22:03] <dbaupp> too long
[11:22:11] <pseudoku> I have a trait T and two groups of types P and Q. types P already implement trait S which i could use to impl T like "impl<P: S>  T for P";  types Q say Q1, Q2 do not implement S , but i can provide my own impls for them . but when i say "impl T for Q1" , i get a error about conflicting impls for T. how do i  acheive this?
[11:22:28] <dbaupp> pseudoku: you can't
[11:22:34] <diverse> dbaupp: I thought that too, perhaps Foo::create() is better?
[11:22:47] <dbaupp> meh, I'm fine with ::new or ::init
[11:22:54] <dbaupp> with a mild preference for new
[11:23:05] <pseudoku> dbaupp: any way around this?
[11:23:26] <dbaupp> pseudoku: not really
[11:23:40] *** Joins: DAddYE (DAddYE@moz-98D3933F.hsd1.ca.comcast.net)
[11:23:40] <Blei> would trait inheritance + default methods work?
[11:23:45] <dbaupp> pseudoku: a macro would take out the boilerplate of writing the implementations by hand
[11:24:28] <Blei> oh, no, it wouldn't
[11:25:14] <pseudoku> dbaupp: i already do that. i thought i was missing something that would allow me to do this. well, thanks anyway
[11:26:27] *** Quits: DAddYE (DAddYE@moz-98D3933F.hsd1.ca.comcast.net) (Ping timeout)
[11:26:40] <pseudoku> on a related note, what kind of specialization does rust support?
[11:28:05] *** Joins: brianm (brianm@moz-8161EF8D.hsd1.ca.comcast.net)
[11:29:09] <dbaupp> nothing other than traits
[11:29:54] *** Quits: brianm (brianm@moz-8161EF8D.hsd1.ca.comcast.net) (Ping timeout)
[11:32:52] *** Joins: Sharp (Sharp@moz-39EFDA61.hfc.comcastbusiness.net)
[11:34:57] *** Joins: bjz (bjz@moz-DD4A2A91.lnse2.cha.bigpond.net.au)
[11:37:27] <pseudoku> dbaupp: i mean, can i do partial specialization for a generic trait impl?
[11:37:38] *** Quits: samnardoni (samnardoni@FC9A45BE.3393236F.BFD1ABFD.IP) (Client exited)
[11:38:35] <diverse> Blei: maybe they should make 'alloc' the placement instead of 'new'? :P
[11:41:00] <dbaupp> pseudoku: you mean something like `impl<A> Trait<A> for Foo { ... } impl Trait<bool> for Foo { ... }`?
[11:41:09] <Blei> yeah, it would make sense to me. and it would make a change to _all_ rust libraries unnecessary
[11:41:15] <pseudoku> dbaupp: yes
[11:41:15] <nielsle> It the traits allowed it, then it could be nice to write something like  let my_thing = RC(Thing::init("hello"));  or even  let my_thing = RC(Thing("hello"));  instead of   let my_thing = new(RC) Thing::init("hello"); 
[11:42:19] <diverse> Blei: then it could be like this: let my_thing = alloc(GC) Thing::new("hello");
[11:43:05] <diverse> :D
[11:43:53] *** Quits: beifeng (Mibbit@B5497CF4.FA7FF645.C7DB8B78.IP) (Quit: http://www.mibbit.com ajax IRC Client)
[11:44:04] *** Joins: nyux (nyux@moz-1CEE0DD2.aiiane.com)
[11:44:08] <Blei> that's nicer, i agree. but my agreement doesn't matter :)
[11:45:38] <dbaupp> pseudoku: yeah, it's not possible yet; https://github.com/mozilla/rust/issues/7059 is similar
[11:45:48] <pseudoku> dbuapp: thanks
[11:46:03] <dbaupp> nielsle: that would require some magic to make it optimally efficient
[11:46:24] <diverse> Blei: what I say will not matter either, I thought I would brainstorm a bit :)
[11:46:49] *** Quits: ChrisMorgan (chris@moz-6AC741CA.static.tpgi.com.au) (Ping timeout)
[11:48:07] *** Joins: ChrisMorgan (chris@moz-6AC741CA.static.tpgi.com.au)
[11:49:18] *** Joins: arodier74 (Thunderbir@5901C3C8.B6144566.D3B9122.IP)
[11:49:42] *** Joins: dredozubov (dredozubov@moz-1E374954.nationalcablenetworks.ru)
[11:50:57] <nielsle> dpaupp: OK.
[11:55:09] <tiffany> using new to allocate is going to make my parser combinator library an absolute nightmare
[11:55:24] <tiffany> every rule has to be a ~ because you can't have recursive enums for obvious reasons
[11:56:33] <tiffany> okay maybe not that bad, but it still adds to the issue of grammars being extremely ugly
[11:56:54] <diverse> too much sugar syntax?
[11:56:59] *** Joins: Cromulent (Cromulent@moz-C2470BE2.cable.virginm.net)
[11:57:05] <tiffany> new Build((new Rule("alpha") + new Rule("digit") + new Rule("symbol"))[1], make_label));
[11:57:17] *** Joins: lenstr (lenstr@AF8EB999.6049B16A.85938D85.IP)
[11:57:51] <benh> just add a wrapper function that returns ~ and doesn't have new in the name?
[11:58:01] *** Quits: lenstr (lenstr@AF8EB999.6049B16A.85938D85.IP) (Quit: Leaving...)
[11:58:26] *** Quits: nano (nano@moz-74CAD1CA.superkabel.de) (Connection reset by peer)
[11:59:20] <tiffany> I also don't like the proc/closure separation, as pointed out on the mailing list
[12:00:53] <tiffany> https://mail.mozilla.org/pipermail/rust-dev/2013-November/007018.html
[12:01:35] <pseudoku> what profiling tool is supported on linux?
[12:01:54] <diverse> gdb?
[12:02:19] <tiffany> since when does gdb do profiling?
[12:02:34] *** Joins: eddyb (eddy@EBE709F3.F7C96DA2.FCAAE698.IP)
[12:05:13] <diverse> http://readwrite.com/2010/11/01/using-gdb-as-a-poor-mans-profi
[12:05:53] <Blei> perf, callgrind?
[12:05:54] <dbaupp> pseudoku: perf works
[12:06:26] <diverse> there is also gprof
[12:06:50] <dbaupp> tiffany: `new Rule("alpha") + ...` isn't that wasting the allocation, since + takes params by reference
[12:07:03] <Blei> diverse: wouldn't you need compiler support for that one?
[12:07:41] <dbaupp> tiffany: i.e. it should be `Rule("alpha") + Rule("digit")` if at all possible
[12:07:55] *** Joins: samnardoni (samnardoni@FC9A45BE.3393236F.BFD1ABFD.IP)
[12:08:05] <tiffany> I think I had a problem trying to do that but I don't remember what
[12:09:04] <dbaupp> ok
[12:10:11] *** Quits: quvarxa (chatzilla@moz-978E4C31.static.tpgi.com.au) (Quit: ChatZilla 0.9.90.1 [Firefox 26.0/20131125215016])
[12:12:12] <tiffany> I would try changing it but my project currently doesn't compile because of the rustc crash I've had
[12:13:25] *** Quits: nuts (tii@822A8E7E.6AD15BF5.75D3BBDB.IP) (Ping timeout)
[12:13:56] <dbaupp> :(
[12:16:43] <tiffany> my issue is that I'm trying to embed a trait object within a type that derives Clone, and the only way anyone has come up with to fix that involves a solution that crashes because of https://github.com/mozilla/rust/issues/9095
[12:17:25] *** Quits: eddyb (eddy@EBE709F3.F7C96DA2.FCAAE698.IP) (Ping timeout)
[12:18:00] *** Quits: dredozubov (dredozubov@moz-1E374954.nationalcablenetworks.ru) (Input/output error)
[12:21:33] *** Quits: sarclops (sarclops@moz-DE5C3EA6.zone8.bethere.co.uk) (Ping timeout)
[12:23:35] *** Quits: Cromulent (Cromulent@moz-C2470BE2.cable.virginm.net) (Quit: KVIrc 4.2.0 Equilibrium http://www.kvirc.net/)
[12:24:00] *** Joins: sarclops (sarclops@moz-14C9EE3A.zone8.bethere.co.uk)
[12:24:57] *** Joins: BizarreCake (BizarreCak@moz-361FE9B2.dynamic.barak-online.net)
[12:26:06] *** Joins: DAddYE (DAddYE@moz-98D3933F.hsd1.ca.comcast.net)
[12:27:50] *** Quits: DAddYE (DAddYE@moz-98D3933F.hsd1.ca.comcast.net) (Ping timeout)
[12:28:04] *** Joins: brianm (brianm@moz-8161EF8D.hsd1.ca.comcast.net)
[12:28:54] *** Joins: victorporof (victorporo@FB8E2A00.483E5FE1.9B1E38F4.IP)
[12:29:52] *** Quits: brianm (brianm@moz-8161EF8D.hsd1.ca.comcast.net) (Ping timeout)
[12:30:07] *** Joins: Cromulent (Cromulent@moz-C2470BE2.cable.virginm.net)
[12:31:53] <diverse> hmm, `~` as an allocation operator...
[12:33:10] <mrshankly> ls
[12:36:51] <diverse> if they do it that way, then they would also have to make an `Own` or `Unique` smart pointer in the lib
[12:36:54] *** Quits: Cromulent (Cromulent@moz-C2470BE2.cable.virginm.net) (Quit: KVIrc 4.2.0 Equilibrium http://www.kvirc.net/)
[12:37:31] *** Joins: notmatt (notmatt@moz-9FB2565E.vc.shawcable.net)
[12:39:18] *** Joins: lpy (lpy@7360AA58.F09091A8.1348A864.IP)
[12:40:04] *** Quits: notmatt (notmatt@moz-9FB2565E.vc.shawcable.net) (Ping timeout)
[12:40:56] *** Joins: dredozubov (dredozubov@moz-1E374954.nationalcablenetworks.ru)
[12:43:14] *** Joins: beifeng (Mibbit@B5497CF4.FA7FF645.C7DB8B78.IP)
[12:48:57] *** Joins: killerswan (kevincantu@moz-CC0DC654.hsd1.ca.comcast.net)
[12:48:57] *** Quits: killerswan (kevincantu@moz-CC0DC654.hsd1.ca.comcast.net) (Quit: killerswan)
[12:52:34] *** Quits: q66 (q66@6EE9DE40.46454B5D.33AABD5F.IP) (Quit: Leaving)
[12:53:49] *** Joins: q66 (q66@6EE9DE40.46454B5D.33AABD5F.IP)
[12:55:48] *** Joins: q66_ (q66@6EE9DE40.46454B5D.33AABD5F.IP)
[12:56:00] *** Quits: q66 (q66@6EE9DE40.46454B5D.33AABD5F.IP) (Ping timeout)
[12:57:19] *** Joins: ricepuddin (graham@moz-7D68765A.cable.virginm.net)
[13:00:19] *** Joins: mib_miwlsw (Mibbit@moz-A06909E4.glbb.ne.jp)
[13:00:55] *** Quits: q66_ (q66@6EE9DE40.46454B5D.33AABD5F.IP) (Quit: Leaving)
[13:01:04] *** Joins: q66 (q66@6EE9DE40.46454B5D.33AABD5F.IP)
[13:04:05] *** jorendorff_away is now known as jorendorff
[13:07:22] *** Joins: Skif (emschwar@moz-4C5BB5A8.beyondbb.com)
[13:09:05] *** Quits: Skif (emschwar@moz-4C5BB5A8.beyondbb.com) (Ping timeout)
[13:09:51] <pseudoku> is there a way to use a enum with variant constructors also as a 'c enum' , like using the constructor name to get the enum tag value?
[13:10:29] <Blei> i don't think the tag values are defined in the case of non-c-enums
[13:12:00] *** Quits: dredozubov (dredozubov@moz-1E374954.nationalcablenetworks.ru) (Input/output error)
[13:25:04] *** Quits: mib_miwlsw (Mibbit@moz-A06909E4.glbb.ne.jp) (Quit: http://www.mibbit.com ajax IRC Client)
[13:25:40] *** Quits: pseudoku (quassel@BCD3AE61.3B1029AF.520CDC98.IP) (Ping timeout)
[13:25:52] *** Joins: nano (nano@moz-74CAD1CA.superkabel.de)
[13:27:27] *** Joins: DAddYE (DAddYE@moz-98D3933F.hsd1.ca.comcast.net)
[13:27:43] *** Joins: pseudoku (quassel@A2C7F582.85934B53.520CDC98.IP)
[13:28:04] *** Joins: brianm (brianm@moz-8161EF8D.hsd1.ca.comcast.net)
[13:29:09] *** Quits: DAddYE (DAddYE@moz-98D3933F.hsd1.ca.comcast.net) (Ping timeout)
[13:29:20] *** Quits: dju (dju@moz-83BD5EC.dmz.me) (Client exited)
[13:30:01] *** Quits: brianm (brianm@moz-8161EF8D.hsd1.ca.comcast.net) (Ping timeout)
[13:34:09] *** Joins: maxli (maxli@moz-4D28BA20.student.cs.uwaterloo.ca)
[13:34:25] *** Joins: mikezaby (mikezaby@moz-AA896205.home.otenet.gr)
[13:34:38] *** Parts: mikezaby (mikezaby@moz-AA896205.home.otenet.gr) ()
[13:35:26] *** Quits: Sharp (Sharp@moz-39EFDA61.hfc.comcastbusiness.net) (Quit: Sharp)
[13:35:41] *** Quits: peterdn (chatzilla@moz-E4A450C.as13285.net) (Ping timeout)
[13:37:39] *** Quits: summerlight (summerligh@327FC32B.2C956A45.501EFF44.IP) (Ping timeout)
[13:42:19] *** jorendorff is now known as jorendorff_away
[13:43:00] *** Joins: dju (dju@moz-83BD5EC.dmz.me)
[13:44:08] <diverse> anything new about the placement new?
[13:44:19] *** Joins: Cromulent (Cromulent@moz-C2470BE2.cable.virginm.net)
[13:44:48] *** Joins: DasIch (dasich@moz-5EDA591.de)
[13:48:13] *** Quits: dsantiago (santiago@moz-CF057779.lv.lv.cox.net) (Connection reset by peer)
[13:48:34] *** Joins: santiago (santiago@moz-CF057779.lv.lv.cox.net)
[13:50:51] *** Joins: lazyden (lazyden@47A36AC9.35CBBBD0.F246D1AF.IP)
[13:51:08] *** Quits: lazyden (lazyden@47A36AC9.35CBBBD0.F246D1AF.IP) (Quit: lazyden)
[14:03:06] *** Joins: Sharp (Sharp@moz-39EFDA61.hfc.comcastbusiness.net)
[14:04:33] *** Quits: Sharp (Sharp@moz-39EFDA61.hfc.comcastbusiness.net) (Quit: Sharp)
[14:06:00] *** Joins: nsf (nsf@moz-EEF3238A.convex.ru)
[14:06:35] *** Joins: FrozenCow (FrozenCow@moz-B2DF4929.chello.nl)
[14:08:29] *** Joins: james4k (james@moz-E7990244.consolidated.net)
[14:10:16] *** Quits: victorporof (victorporo@FB8E2A00.483E5FE1.9B1E38F4.IP) (Quit: victorporof)
[14:10:18] *** Quits: james4k (james@moz-E7990244.consolidated.net) (Ping timeout)
[14:11:59] *** Joins: jstevans (Instantbir@moz-8DBF3BC4.washdc.fios.verizon.net)
[14:12:48] *** Quits: jstevans1 (Instantbir@moz-8DBF3BC4.washdc.fios.verizon.net) (Ping timeout)
[14:19:17] *** Joins: canhtak (canhtak@moz-6F820ACE.wl.t.ulaval.ca)
[14:20:23] *** Joins: netoarmando (textual@C58B4FAF.E133C284.56644CA2.IP)
[14:21:35] *** Quits: netoarmando (textual@C58B4FAF.E133C284.56644CA2.IP) (Quit: Textual IRC Client: www.textualapp.com)
[14:23:37] *** Joins: summerlight (summerligh@327FC32B.2C956A45.501EFF44.IP)
[14:24:02] *** Joins: Houm (Houm@moz-25669AA8.fbx.proxad.net)
[14:28:03] *** Joins: brianm (brianm@moz-8161EF8D.hsd1.ca.comcast.net)
[14:30:07] *** Quits: brianm (brianm@moz-8161EF8D.hsd1.ca.comcast.net) (Ping timeout)
[14:36:00] *** Quits: sigma (sigma@moz-D4F04D48.range86-174.btcentralplus.com) (Ping timeout)
[14:36:41] *** Quits: Houm (Houm@moz-25669AA8.fbx.proxad.net) (Ping timeout)
[14:39:02] *** Quits: FrozenCow (FrozenCow@moz-B2DF4929.chello.nl) (Client exited)
[14:39:34] *** Joins: eddyb (eddy@EBE709F3.F7C96DA2.FCAAE698.IP)
[14:40:12] *** Joins: SiegeLord (sl@moz-C606190.bstnma.fios.verizon.net)
[14:40:19] *** Quits: lpy (lpy@7360AA58.F09091A8.1348A864.IP) (Ping timeout)
[14:40:51] *** Joins: Sharp (Sharp@moz-39EFDA61.hfc.comcastbusiness.net)
[14:43:39] *** Quits: beifeng (Mibbit@B5497CF4.FA7FF645.C7DB8B78.IP) (Quit: http://www.mibbit.com ajax IRC Client)
[14:43:56] *** Joins: beifeng (Mibbit@B5497CF4.FA7FF645.C7DB8B78.IP)
[14:44:34] *** Joins: moostik (Icedove@5A22E6A1.10715965.BCDF592F.IP)
[14:45:34] *** Quits: Sharp (Sharp@moz-39EFDA61.hfc.comcastbusiness.net) (Quit: Sharp)
[14:45:47] *** Quits: moostik (Icedove@5A22E6A1.10715965.BCDF592F.IP) (Quit: moostik)
[14:46:29] *** Joins: moostik (Icedove@5A22E6A1.10715965.BCDF592F.IP)
[14:51:42] *** Joins: sigma (sigma@moz-A17EB325.range86-184.btcentralplus.com)
[14:52:17] *** Quits: jstevans (Instantbir@moz-8DBF3BC4.washdc.fios.verizon.net) (Ping timeout)
[14:53:08] *** Quits: Cromulent (Cromulent@moz-C2470BE2.cable.virginm.net) (Quit: KVIrc 4.2.0 Equilibrium http://www.kvirc.net/)
[14:53:14] *** Joins: kphelps (kphelps@moz-8F37EAB2.ri.ri.cox.net)
[14:53:42] <SiegeLord> About the 'new' thing... do other languages with both stack and heap allocation use 'new' for the heap allocation?
[14:56:07] *** Joins: Skif (emschwar@moz-4C5BB5A8.beyondbb.com)
[14:56:18] *** Joins: jstevans (Instantbir@moz-8DBF3BC4.washdc.fios.verizon.net)
[14:57:48] *** Quits: Skif (emschwar@moz-4C5BB5A8.beyondbb.com) (Ping timeout)
[14:59:24] <Blei> SiegeLord: c++
[14:59:52] <SiegeLord> Well, obviously except C++ and its descendants :P
[15:00:03] <SiegeLord> Unless only C++ and its descendants have both types of allocation
[15:00:14] *** Quits: Jackneill (Jackneill@moz-CEEE36B2.pool.digikabel.hu) (Ping timeout)
[15:00:21] *** Joins: Jackneill (Jackneill@moz-CEEE36B2.pool.digikabel.hu)
[15:01:06] <Blei> it's the only language i've used that has both and isn't C
[15:02:26] * eddyb really hopes new is put to good use and isn't just an optimization
[15:02:51] <benh> D, I guess
[15:03:04] * diverse really hopes new is renamed to a better keyword
[15:03:05] <benh> Does C# count? I'm not sure it's clear whether structs go on the stack there.
[15:04:19] <eddyb> @Rc 0u was one of the discussed sugars for Rc::new(0u), and pretty much my favorite
[15:04:21] <diverse> in Java/C#/D, doing new is basically doing let foo = new(GC) bar;
[15:04:33] *** Quits: dew (Instantbir@moz-E4452B8F.static.stls.mo.charter.com) (Ping timeout)
[15:05:04] *** Joins: dew (Instantbir@moz-E4452B8F.static.stls.mo.charter.com)
[15:08:18] *** Quits: kphelps (kphelps@moz-8F37EAB2.ri.ri.cox.net) (Ping timeout)
[15:09:14] <bstrie> diverse: suggest a better keyword :P
[15:09:19] <diverse> alloc!
[15:09:27] <eddyb> toolong
[15:09:50] <diverse> 2 extra letters is too long?
[15:10:04] <eddyb> new is too long IMO :/
[15:10:12] <bstrie> anybody wanna write and optimize a rust version of this benchmark? http://www.mit.edu/~mtikekar/posts/stream-fusion.html
[15:10:38] <SiegeLord> Looks like a few other languages use new for heap... Ada does and so does Go of all things (although Go is complicated in that respect)
[15:11:07] <diverse> in the heap which is garbage collected all the time
[15:11:26] *** Joins: dredozubov (dredozubov@moz-1E374954.nationalcablenetworks.ru)
[15:14:41] <benh> eddyb: how'd the @Rc syntax work for the ~ case?
[15:14:46] <benh> just... stick to ~42?
[15:14:51] <benh> or @Unique 42?
[15:15:34] <diverse> eddyb: is `~` too long? :P
[15:15:34] <eddyb> sigil ~ = @Uniq; :P
[15:15:46] <eddyb> diverse: it's just perfect ^_^
[15:16:36] <diverse> eddyb: good news for you, someone on the ML suggested to use `~` as the heap operator
[15:16:59] * eddyb realizes his ML tab is gone
[15:17:48] <eddyb> that explains a lot :/
[15:20:11] * diverse imagines how ugly `let foo = ~(GC) bar;` looks
[15:20:30] <eddyb> who's kevin? he deserves a cookie
[15:21:16] <SiegeLord> Eridius, I think
[15:22:00] <sp3d> a collatz that mirrors the C one's structure is about half as fast here, gcc -O3 and rustc --opt-level=3
[15:23:33] <sp3d> http://pastebin.com/Xf2n4fQJ
[15:23:40] <eddyb> sp3d: sounds like bounds checking or LLVM having a hard time dealing with the bloated codegen in trans
[15:24:19] <sp3d> shouldn't bounds check, I never use arrays aside from os::args and range should be optimized into a simple loop
[15:24:28] <sp3d> I'll peek at disasm
[15:24:34] <benh> sp3d: what about using clang intead of gcc ;)
[15:25:49] <sp3d> I'll have to swap out cling for it, the packages conflict >_>
[15:26:22] *** Joins: victorporof (victorporo@FB8E2A00.483E5FE1.9B1E38F4.IP)
[15:27:53] <sp3d> wow, gcc beats clang handily: 262ms vs. 445ms
[15:28:04] *** Joins: brianm (brianm@moz-8161EF8D.hsd1.ca.comcast.net)
[15:28:59] <benh> So closer to rust then? :D
[15:29:25] <sp3d> I get about 553ms for rust
[15:29:50] *** Quits: brianm (brianm@moz-8161EF8D.hsd1.ca.comcast.net) (Ping timeout)
[15:29:56] *** Quits: sankha93 (Instantbir@7061CD01.D6BD0D91.22D41759.IP) (Quit: Gone to save the world!)
[15:30:05] <sp3d> I should update an asm collatz I have sitting around and see how it fares
[15:30:06] *** Joins: DAddYE (DAddYE@moz-98D3933F.hsd1.ca.comcast.net)
[15:30:48] <benh> for 10000000 i get 3.55s in rust, 2.17 with clang and 2.06 with gcc, your clang must be broken ;)
[15:31:05] <sp3d> interesting
[15:31:55] *** Quits: DAddYE (DAddYE@moz-98D3933F.hsd1.ca.comcast.net) (Ping timeout)
[15:39:31] *** Quits: nkoep (nik@moz-262E6D4E.pool.mediaways.net) (Ping timeout)
[15:39:39] *** Joins: killerswan (kevincantu@moz-CC0DC654.hsd1.ca.comcast.net)
[15:40:13] *** Joins: nkoep (nik@moz-262E6D4E.pool.mediaways.net)
[15:40:57] *** Quits: killerswan (kevincantu@moz-CC0DC654.hsd1.ca.comcast.net) (Quit: killerswan)
[15:40:59] *** jorendorff_away is now known as jorendorff
[15:41:31] *** jorendorff is now known as jorendorff_away
[15:42:29] *** Joins: lpy (lpy@12172131.F09091A8.1348A864.IP)
[15:45:07] *** Joins: ofranja (Mibbit@A8BC9711.30D37A19.EAEB412A.IP)
[15:51:32] *** Joins: voxpopuli (fanservice@moz-CEF3689A.hsd1.pa.comcast.net)
[15:54:43] <TeXitoi> is MutableVector::mut_split() is interesting to add?
[15:57:02] *** Joins: james4k (james@moz-E7990244.consolidated.net)
[15:58:49] *** Quits: james4k (james@moz-E7990244.consolidated.net) (Ping timeout)
[15:59:31] *** Joins: fyolnish (fyolnish@moz-25AA04E6.uqwimax.jp)
[15:59:44] *** Joins: kphelps (kphelps@moz-8F37EAB2.ri.ri.cox.net)
[15:59:46] *** Quits: fyolnish (fyolnish@moz-25AA04E6.uqwimax.jp) (Quit: Bye)
[16:03:24] <kimundi> TeXitoi: What would it do?
[16:05:32] <Blei> task '<main>' failed at 'borrowed'
[16:05:36] <Blei> kill me, kill me now
[16:06:07] <diverse> wait, what?
[16:07:08] <Blei> dynamic borrow checker
[16:07:34] <bstrie> Blei: ??
[16:07:53] <bstrie> are you using @mut or something?
[16:07:59] <Blei> yeah
[16:08:05] <bstrie> then you get no sympathy from me :)
[16:08:07] <Blei> and i think i found the bug *whew*
[16:08:07] *** Quits: moostik (Icedove@5A22E6A1.10715965.BCDF592F.IP) (Ping timeout)
[16:08:12] <Blei> it's bindgen actually
[16:08:12] <diverse> rofl
[16:08:19] <bstrie> oh
[16:08:20] <Blei> and i'm in the process of removing all the @ i can find
[16:08:22] <bstrie> then you do get sympathy
[16:08:27] <bstrie> because bindgen is essential
[16:08:56] <Blei> unfortunately bindgen depends on libsyntax, and that is full of @
[16:08:57] <bstrie> and also removing @ is god's work
[16:09:10] <Blei> but, one @ down in libsyntax today
[16:09:23] <diverse> yay \o/
[16:09:36] <bstrie> a journey of a thousand compiles begins with a single step
[16:10:10] *** Joins: twb (textual@moz-5DE8950B.hsd1.ga.comcast.net)
[16:10:15] <Blei> *with a single deletion of @
[16:10:36] <eddyb> wait wait wait
[16:10:38] <eddyb> Blei: which @?
[16:10:56] <Ms2ger> Light a man a fire and he'll be warm for a day, make a man compile rustc and he'll be warm for a lifetime
[16:11:08] <bstrie> haha
[16:11:11] <tiffany> hah
[16:11:35] <diverse> heh
[16:11:48] <Blei> eddyb: libsyntax/ast.rs: the one in `struct_def`
[16:12:14] <eddyb> Blei: I have started a platform to replace @ in the AST, the P<T> in this PR https://github.com/mozilla/rust/pull/10676
[16:12:33] <Blei> :O
[16:12:43] <eddyb>  ~[@struct_field] => ~[struct_field]?
[16:12:48] <Blei> yeah
[16:13:06] <eddyb> I think I did the opposite on an another array
[16:13:26] <Blei> haha, oh well
[16:13:37] <Blei> most of the changes were in bindgen anyways, they still apply
[16:14:20] <eddyb> the trick with P<T> is that it can be swapped out for another kind of pointer with minimal changes to the code (and they should be generic, not specializing)
[16:14:51] <eddyb> and you can really do a before and after for changing from @T to Rc<T>
[16:15:26] <Blei> true
[16:15:34] <eddyb> and it's easy to automatically replace with the specialized version, if ever required
[16:15:41] <Blei> but in this case, you don't need any Rc or @, so that's even better
[16:16:07] <Ms2ger> bstrie, hey, want to remove all the @mut in Servo? :)
[16:16:25] <eddyb> Blei: sure, just don't remove indirection inside enums or structures that are unboxed in enums
[16:17:28] <benh> Could rustdoc grow a feature to list the size of structs and enum variants?
[16:19:04] <Blei> haha, my changes made bindgen slower! fun
[16:20:44] <tiffany> like, the size in bytes benh?
[16:20:48] <tiffany> that's awfully platform dependant
[16:20:50] <eddyb> benh: it depends on the architecture, and it might need hooking in trans, but it's doable
[16:21:01] *** Joins: erickt1 (Adium@49C4075F.3AC15C18.2321E71E.IP)
[16:21:29] <tiffany> not just architecture, it depends on ABI too
[16:21:43] <sp3d> that would be really handy
[16:21:45] <benh> I was just wondering where a good place to extract info for memshrink-ish efforts would be
[16:22:10] <eddyb> benh: there's... this: https://gist.github.com/eddyb/08fef0dfc6ff54e890bc
[16:22:13] <benh> Guess it would be a separate libsyntax consumer
[16:22:17] <sp3d> "rustc --ls -s" :P
[16:24:48] <eddyb> Blei: can you post your changes somewhere?
[16:24:56] *** Joins: pnkfelix (pnkfelix@moz-43495417.fbx.proxad.net)
[16:24:56] *** ChanServ sets mode: +o pnkfelix
[16:26:41] *** Quits: ofranja (Mibbit@A8BC9711.30D37A19.EAEB412A.IP) (Quit: http://www.mibbit.com ajax IRC Client)
[16:26:51] <Blei> eddyb: https://github.com/Blei/rust/tree/de-gc
[16:27:38] *** Quits: lpy (lpy@12172131.F09091A8.1348A864.IP) (Connection reset by peer)
[16:27:50] *** Joins: lpy (lpy@12172131.F09091A8.1348A864.IP)
[16:28:04] *** Joins: brianm (brianm@moz-8161EF8D.hsd1.ca.comcast.net)
[16:28:23] <eddyb> s/gc/ref-counted-bloated-boxes-with-leaky-cycles/
[16:28:23] *** Quits: arodier74 (Thunderbir@5901C3C8.B6144566.D3B9122.IP) (Quit: arodier74)
[16:29:38] <Blei> haha, hopefully, one day
[16:30:10] <eddyb> Blei: you're lucky struct_field isn't an ast_node
[16:30:28] *** Quits: brianm (brianm@moz-8161EF8D.hsd1.ca.comcast.net) (Ping timeout)
[16:31:02] <Blei> it's an ast, so theoretically it should be changeable to use only ~
[16:31:11] <Blei> but, well, theoretically
[16:31:20] *** Joins: fyolnish (fyolnish@moz-25AA04E6.uqwimax.jp)
[16:31:30] *** Joins: DAddYE (DAddYE@moz-98D3933F.hsd1.ca.comcast.net)
[16:32:45] <eddyb> Blei: Rc<T> is close enough, if only it would work...
[16:33:11] *** Quits: DAddYE (DAddYE@moz-98D3933F.hsd1.ca.comcast.net) (Ping timeout)
[16:33:15] <Blei> why doesn't it?
[16:34:13] <eddyb> Blei: it's not a drop-in replacement because we don't have fancy smart-pointer-related traits in the language - see these comments https://github.com/mozilla/rust/pull/10676#issuecomment-29480131
[16:34:36] <eddyb> well, not yet, it should be coming soon, *hopefully*
[16:35:14] <Blei> ah, right, my_rc.foo() won't work
[16:35:43] <eddyb> few things would work
[16:36:19] *** Joins: cubic (cubic@moz-80241A3A.mc.videotron.ca)
[16:36:25] *** Quits: fyolnish (fyolnish@moz-25AA04E6.uqwimax.jp) (Quit: Bye)
[16:36:40] *** Joins: hjr3 (hradtke@moz-E87BDF1F.socal.res.rr.com)
[16:36:47] *** Quits: hjr3 (hradtke@moz-E87BDF1F.socal.res.rr.com) (Quit: hjr3)
[16:38:13] *** kimundi is now known as zz_kimundi
[16:39:05] *** Joins: killerswan (kevincantu@moz-CC0DC654.hsd1.ca.comcast.net)
[16:39:10] *** Quits: killerswan (kevincantu@moz-CC0DC654.hsd1.ca.comcast.net) (Quit: killerswan)
[16:44:57] *** Joins: Skif (emschwar@moz-4C5BB5A8.beyondbb.com)
[16:44:57] *** Quits: beifeng (Mibbit@B5497CF4.FA7FF645.C7DB8B78.IP) (Quit: http://www.mibbit.com ajax IRC Client)
[16:45:09] *** Joins: beifeng (Mibbit@B5497CF4.FA7FF645.C7DB8B78.IP)
[16:45:16] <erickt1> anyone do a version of http://www.mit.edu/~mtikekar/posts/stream-fusion.html for rust yet?
[16:46:38] *** Joins: jordyd (jordyd@moz-DFB8ED3B.lightspeed.wepbfl.sbcglobal.net)
[16:46:42] *** Quits: Skif (emschwar@moz-4C5BB5A8.beyondbb.com) (Ping timeout)
[16:47:09] *** jorendorff_away is now known as jorendorff
[16:47:24] <sp3d> erickt1: http://pastebin.com/Xf2n4fQJ is not super idiomatic rust and runs a bit slower than C
[16:47:34] <erickt1> thats what I'm finding
[16:48:15] <sp3d> I noticed clang and gcc emitted forms of cmov while rust didn't
[16:48:31] *** jorendorff is now known as jorendorff_away
[16:49:02] <sp3d> but I didn't play around with the generated asm to see what would help rust's perf
[16:49:52] *** Joins: killerswan (kevincantu@moz-CC0DC654.hsd1.ca.comcast.net)
[16:49:58] *** Joins: Sharp (Sharp@moz-39EFDA61.hfc.comcastbusiness.net)
[16:50:28] <eddyb> sp3d: can you compare the output of both rustc and clang with -S --emit-llvm?
[16:52:21] *** Quits: KindOne (KindOne@moz-40255860.dynamic.ip.windstream.net) (Ping timeout)
[16:54:35] <sp3d> http://pastebin.com/wWtw88RB http://pastebin.com/TCdBSz2C
[16:56:03] <eddyb> sp3d: I can tell something is wrong by the file size :P
[16:56:07] *** Joins: KindOne (KindOne@moz-1F6A65EB.dynamic.ip.windstream.net)
[16:56:18] <Earnestly> sp3d: (As an aside, look up "http://sprunge.us" and "http://ix.io" as not everyone can use pastebin.com, mostly blocked)
[16:56:30] <eddyb> or, you know, gist :D
[16:56:43] *** Quits: GeneralMaximus (ankur@704E18E2.13A5FC81.D5D59AD9.IP) (Quit: Computer has gone to sleep.)
[16:56:49] *** Quits: summerlight (summerligh@327FC32B.2C956A45.501EFF44.IP) (Ping timeout)
[16:56:50] <Earnestly> Indeed
[16:56:57] *** Joins: summerlight (summerligh@327FC32B.2C956A45.501EFF44.IP)
[16:57:25] <Earnestly> Anything that isn't pastie.org, pastebin.com/ca, hastebin.com
[16:57:34] <sp3d> sure
[16:57:43] <Earnestly> (pastie's "raw" output is full of html, yay?)
[16:57:44] *** Joins: willingc (willingc@moz-B4760708.san.res.rr.com)
[16:57:53] <eddyb> Earnestly: lol
[16:58:10] *** Quits: willingc (willingc@moz-B4760708.san.res.rr.com) (Quit: Leaving...)
[16:58:16] *** Quits: vadimcn (chatzilla@FB06B64.76F9E272.DA40C4B3.IP) (Ping timeout)
[16:58:21] *** Joins: vadimcn_ (chatzilla@FB06B64.76F9E272.DA40C4B3.IP)
[16:58:26] *** vadimcn_ is now known as vadimcn
[16:58:30] *** Joins: earlzlap (earlz@moz-483E1E31.neo.res.rr.com)
[16:58:35] <eddyb> sp3d: sheesh, can't even tell what's going on in the rust one. maybe you could use #[no_std] and rust-core or just extern "C" fn printf
[16:58:56] *** Quits: summerlight (summerligh@327FC32B.2C956A45.501EFF44.IP) (Ping timeout)
[17:00:12] *** Joins: Savago (Savago@1111ED0B.40BDE760.18DDB669.IP)
[17:00:32] *** Quits: Savago (Savago@1111ED0B.40BDE760.18DDB669.IP) (Quit: Savago)
[17:00:37] <eddyb> sp3d: or this + C-like pub extern fn main https://github.com/pcwalton/sprocketnes/blob/master/nes.rc#L7
[17:00:41] <benh> i just deleted the os::args and println! calls and it still runs in about the same time ;)
[17:01:05] <eddyb> benh: did you go runtime-less?
[17:01:11] <benh> no
[17:01:12] <sp3d> "perf record"/"perf annotate" does a good job of isolating the inner loops if you just want to compare those
[17:01:32] <sp3d> its disasm is a little crude and at&t though
[17:01:49] <eddyb> benh: even if it's not as fast, it might help with reading the ll generated by trans
[17:02:46] <eddyb> sp3d: yay readability https://gist.github.com/eddyb/9335a6fb78f93730d2d0
[17:02:58] <benh> task 'rustc' has overflowed its stack <- i'm not good at making things runtimeless
[17:03:05] *** Quits: Sharp (Sharp@moz-39EFDA61.hfc.comcastbusiness.net) (Quit: Sharp)
[17:03:26] *** Joins: strcat (strcat@moz-54F7FD49.cpe.net.cable.rogers.com)
[17:04:23] *** Joins: GeneralMaximus (ankur@704E18E2.13A5FC81.D5D59AD9.IP)
[17:04:39] <eddyb> still a huge main body https://gist.github.com/eddyb/9335a6fb78f93730d2d0#file-collatz-rs-ll-L115-L613
[17:05:08] <eddyb> sp3d: it has bound checks
[17:05:43] <eddyb> though those might be for from_str
[17:06:39] *** Joins: Cromulent (Cromulent@moz-C2470BE2.cable.virginm.net)
[17:06:58] <sp3d> from os::args()[1]
[17:08:41] <sp3d> "while next": there is the start of the important area
[17:10:13] *** Quits: GeneralMaximus (ankur@704E18E2.13A5FC81.D5D59AD9.IP) (Quit: Computer has gone to sleep.)
[17:11:26] <sp3d> ohhh :|
[17:11:29] <sp3d> I've signed my 'a'
[17:12:53] *** Quits: nano (nano@moz-74CAD1CA.superkabel.de) (Connection reset by peer)
[17:13:17] <sp3d> then we tie clang
[17:13:26] <benh> wow
[17:14:57] <sp3d> I noticed the "a&=-2" earlier but figured it was just getting introduced at a later opt pass than would remove it for being useless because of how rustc did things
[17:15:10] <sp3d> but it's necessary for a signed /=2
[17:16:30] <sp3d> http://sprunge.us/ZBTH
[17:18:27] *** Quits: maxli (maxli@moz-4D28BA20.student.cs.uwaterloo.ca) (Ping timeout)
[17:21:14] *** Joins: sankha93 (Instantbir@7061CD01.D6BD0D91.22D41759.IP)
[17:22:11] <doomlord_> just reading the latest digest mail,  whats this about do ... desugaring to  ...proc() ..
[17:23:20] <doomlord_> ah, ownership..
[17:24:12] <strcat> doomlord_: huh?
[17:24:30] <doomlord_> i'm just reading about this change to the 'do' sugar
[17:24:35] <erickt1> sp3d / eddyb: ugh, cython is faster than us :(
[17:24:36] <doomlord_> fn vs proc
[17:24:55] <doomlord_> i haven't been paying attention to rust for a while.. seems this is new
[17:24:55] <sp3d> erickt1: ?
[17:25:07] <strcat> if you're having trouble writing fast code in rust, you're not writing the same code as you are in other languages
[17:25:08] <erickt1> sp3d: in the collatz benchmarking
[17:25:10] <sp3d> we got to clang-speeds after fixing a dumb mistake >_>
[17:25:13] <benh> doomlord_: ~fn is now spelled proc and &fn(X) is now spelled |X|
[17:25:22] * strcat shrugs
[17:25:27] <strcat> oh and the stdlib. don't use that ;p
[17:26:12] <erickt1> sp3d: ooh, oops, I also was signing my integers
[17:26:23] <eddyb> hehe
[17:26:28] <erickt1> sp3d: I'm surprised that added 10 ms to the run
[17:26:47] <eddyb> division by 2 works differently
[17:27:00] <doomlord_> i see you're considering adding a new keyword..
[17:27:11] <eddyb> a new keyword, 'new'
[17:27:38] <eddyb> erickt1: see http://ridiculousfish.com/blog/posts/will-it-optimize.html
[17:27:57] <diverse> `new` is not really all that new :P
[17:28:04] *** Joins: brianm (brianm@moz-8161EF8D.hsd1.ca.comcast.net)
[17:28:21] <eddyb> #5, you need two operations for optimized signed division by 2, while only one for unsigned
[17:28:52] <Ms2ger> eddyb, I want an 'old' keyword :(
[17:29:53] *** Quits: brianm (brianm@moz-8161EF8D.hsd1.ca.comcast.net) (Ping timeout)
[17:30:20] *** zz_kimundi is now known as kimundi
[17:30:23] *** Quits: pseudoku (quassel@A2C7F582.85934B53.520CDC98.IP) (Ping timeout)
[17:30:28] *** Joins: pseudoku (quassel@A2C7F582.85934B53.520CDC98.IP)
[17:31:30] *** Quits: samnardoni (samnardoni@FC9A45BE.3393236F.BFD1ABFD.IP) (Ping timeout)
[17:31:52] <erickt1> eddyb: oh, they cheat! `max_a0` is int, and `a` is unsigned long. I missed that it was doing some shenanigans with implicit casting
[17:31:55] *** Joins: arodier74 (Thunderbir@5901C3C8.B6144566.D3B9122.IP)
[17:32:06] *** Joins: GeneralMaximus (ankur@704E18E2.13A5FC81.D5D59AD9.IP)
[17:32:51] *** Joins: DAddYE (DAddYE@moz-98D3933F.hsd1.ca.comcast.net)
[17:34:12] *** Joins: logicalparadox (logicalpar@moz-C73156AE.dr01.wlbr.pa.frontiernet.net)
[17:34:36] *** Quits: DAddYE (DAddYE@moz-98D3933F.hsd1.ca.comcast.net) (Ping timeout)
[17:34:42] *** Joins: gokcehan (Mibbit@A06BA29A.55DBA505.232D870F.IP)
[17:35:11] <eddyb> erickt1: max_a0's signedness doesn't matter, except it might cause confusion :P
[17:35:21] <erickt1> it did :)
[17:35:28] *** Joins: azita (Azita@moz-C1FB2A8.hsd1.ca.comcast.net)
[17:35:31] <eddyb> erickt1: err, ignore that, I was thinking of longest >_>
[17:36:09] <erickt1> eddyb: I didn't actually specify any types in my first version of rust
[17:36:16] *** Quits: lpy (lpy@12172131.F09091A8.1348A864.IP) (Client exited)
[17:36:24] <erickt1> I was hurt by auto-inferring `int`
[17:36:25] <diverse> eddyb: advocate for the '~' keyword instead
[17:36:38] <eddyb> "keyword" heh
[17:37:08] *** Joins: maxli (maxli@moz-4D28BA20.student.cs.uwaterloo.ca)
[17:38:20] <diverse> eddyb: 'new' is too long, right?
[17:38:36] <bstrie> honestly, after thinking about it, `new` isn't any harder to type than `~`
[17:38:48] <diverse> hehe
[17:38:55] <bstrie> three lowercase letters vs. a shift-and-reach-to-the-corner
[17:39:30] <benh> clearly rustc ought to have figured out that the collatz conjecture doesn't concern itself with negative numbers :|
[17:39:57] <bstrie> I'm also tempted to say that the ~ symbol might not even exist on a lot of keyboards, but I'm sure that's true of a number of our other symbols as well...
[17:40:28] <bstrie> what I *don't* want is for ~ to be repurposed as bitwise negation. that's an abomination when ! will suffice
[17:41:18] <eddyb> diverse, bstrie: I wouldn't mind if the "new Foo(bar)" style was made the norm, but it would remind me of other languages
[17:41:27] <kimundi> I think having a keyword for allocation is fine, for reasons of making it more verbose to allocate
[17:41:36] *** Quits: azita (Azita@moz-C1FB2A8.hsd1.ca.comcast.net) (Quit: azita)
[17:42:01] <kimundi> But using 'new' is somewhat confusing, because it doesn't construct the object
[17:42:07] <eddyb> (imagine your gf starting to wear the same perfume as your ex, that could be weird. but my metaphors aren't the best)
[17:42:16] <bstrie> eddyb: no, they aren't :P
[17:42:36] <kimundi> Like, let x = new 5;
[17:42:51] <gokcehan> Hello, can someone help me figure out how to read stdin properly? I have been playing with this: http://mibpaste.com/QuJ6Xh 
[17:43:26] <eddyb> I know, Eridius/kevin was right on the ML that ~ made more sense in contexts like that
[17:43:34] <bstrie> all the people saying "I don't like `new` because C++ does it" have an invalid argument. the people saying "I don't like `new` because it has different semantics from `new` in C++" have a very solid argument, if that is indeed the case (I'm not a C++ programmer, I have no idea)
[17:44:01] <eddyb> bstrie: new Path("foo") has C++-like semantics
[17:44:02] <sp3d> it seems like a lot of languages use "new" with language-unique semantics
[17:44:07] <diverse> kimundi: got any ideas though
[17:44:24] <kimundi> diverse: Not use 'new' :P
[17:44:31] <eddyb> bstrie: new (Path("foo") doesn't - i.e. having a value instead of just a constructor
[17:44:38] <diverse> kimundi: meaning keywords
[17:44:56] <eddyb> "new 5" might not work in any other language with that keyword
[17:44:57] <kimundi> let x = alloc 5;  let y = alloc Path::new()
[17:45:17] <diverse> kimundi: I prefer that
[17:45:23] <eddyb> kimundi: but... ~ works for that better than a long keyword
[17:45:32] <bstrie> eddyb: the problem with using `Foo(bar)` as a constructor is that I can't tell if you're calling a constructor function or just creating an enum
[17:46:07] <eddyb> bstrie: the enum variants and tuple-like structs are compiled as functions
[17:46:36] <eddyb> Some is a fn<T>(T) -> Option<T>
[17:46:49] <bstrie> hm, didn't know that
[17:47:06] <eddyb> kimundi: what would the type be? ~int and ~Path? then alloc is nothing more than a weird function
[17:47:13] <kimundi> eddyb: Sure, but the devs like the part where the allocations gets more verbose. It's a serious problem that newcomers to the language often just add uneccessary ~ sigils because they mix it up with ownership semantik and/or are trying to get the code to compile
[17:47:26] <bstrie> eddyb: in any case, I think you're better off dropping the "`new` is hard to type" argument, as it really really isn't any harder to type than the tilde :P
[17:48:30] <bstrie> personally, I agree with pcwalton's observation that people overuse ~
[17:48:39] <o11c> point ... one shifted key is about equal to three normal keys
[17:48:39] <diverse> actually typing the tilde is a bit slower than typing new
[17:48:43] <kimundi> eddyb: It could be a ~int, a Gc<int>, a Rc<int> ... It would be the general "allocate memory for a type with a custom smartpointer and stuff it into it"
[17:48:51] <eddyb> bstrie: it's more verbose than other forms and it kills the ::new pattern
[17:48:55] <bstrie> if moving to a keyword helps make allocation more visually distinctive, then I'm all for it
[17:49:02] <bstrie> that said, I do much prefer ::new to ::init
[17:49:09] <kimundi> bstrie++
[17:49:30] <eddyb> kimundi: oooh, if that were to work with inference, it would be something
[17:49:46] <eddyb> let x: Rc<int> = alloc 5;
[17:50:01] <bstrie> bleh, alloc *is* hard to type :P
[17:50:14] <bstrie> don't make me hit the same key twice in a row
[17:50:16] <kimundi> let (a, b, c) : (~int, Rc<int>, Gc<int>) = (alloc 1, alloc 2, alloc 3);
[17:50:29] <diverse> bstrie: how about 'alc'? :P
[17:50:40] <erickt1> so would an exchanged allocated type still be named `~foo`?
[17:50:42] <eddyb> new has type/constructor semantics, not value semantics
[17:50:42] <bstrie> diverse: gross :)
[17:50:48] <o11c> I like 'alloc' ...
[17:50:48] <diverse> bstrie: totally :D
[17:50:48] <bstrie> erickt1: yes
[17:50:51] <kimundi> erickt1: The type would still be ~
[17:50:54] <eddyb> kimundi: @1, @2, @3?
[17:51:04] <eddyb> @lloc :D
[17:51:17] <diverse> rofl
[17:51:26] <kimundi> eddyb: I also had the idea for using @ as allocation operator months ago :)
[17:51:28] <erickt1> bstrie /kimundi: will ~ be still kept as an operator then? or would that be replaced with `new`?
[17:51:35] <bstrie> erickt1: however, pcwalton wants to change `~T` to `*T` and our current `*T` to a `Ptr<T>` type :)
[17:51:37] <kimundi> erickt1: replaced with new
[17:51:44] *** Quits: killerswan (kevincantu@moz-CC0DC654.hsd1.ca.comcast.net) (Quit: killerswan)
[17:51:48] <erickt1> bstrie: heh
[17:52:09] <eddyb> not having to make the smart ptr explicit (i.e. placement new) is going to be a huge win IMO
[17:52:16] <erickt1> bstrie: I would not be opposed to Ptr<T>. Anything that makes unsafe pointers harder to work with is fine with me :)
[17:52:17] <diverse> or use '@' as the keyword, because as bstrie points out '~' might not be common on other types of keyboards
[17:52:41] <bstrie> I mean, it's still likely a pain to type {} and [] and <> on a lot of international keyboards
[17:52:48] <kimundi> Eh, for me both @ and ~ is equally hard to type
[17:52:52] <bstrie> but getting rid of ~ would probably help a little there, yeah
[17:53:18] <eddyb> a lot of things would be problematic with no unsafe pointers in the language
[17:53:47] <eddyb> but not unmanageable
[17:53:58] <eddyb> #bike-shedding-saturdays
[17:55:34] <Ms2ger> Make that #bike-shedding-days
[17:55:50] *** Quits: BizarreCake (BizarreCak@moz-361FE9B2.dynamic.barak-online.net) (Connection reset by peer)
[17:56:48] <diverse> what's another word for allocate?
[17:57:36] <Blei> woot, now bindgen is faster than before
[17:57:59] <Blei> (but the optimization has probably nothing to do with what i did all afternoon. orz)
[17:58:22] <Blei> only 15s instead of 60s to parse all of gtk and gstreamer
[17:58:50] <Blei> scratch that, i introduced bugs
[17:59:53] *** Quits: JanC (janc@moz-64D6DA10.dsl.scarlet.be) (Ping timeout)
[18:00:01] *** Quits: ricepuddin (graham@moz-7D68765A.cable.virginm.net) (Quit: Leaving)
[18:00:10] *** Joins: samnardoni (samnardoni@FC9A45BE.3393236F.BFD1ABFD.IP)
[18:01:22] *** Joins: mikezaby (mikezaby@moz-AA896205.home.otenet.gr)
[18:01:25] *** Parts: mikezaby (mikezaby@moz-AA896205.home.otenet.gr) ()
[18:01:42] *** Quits: GeneralMaximus (ankur@704E18E2.13A5FC81.D5D59AD9.IP) (Quit: Computer has gone to sleep.)
[18:04:11] *** Joins: Kxepal (Miranda@moz-D6DF9D5B.pppoe.mtu-net.ru)
[18:04:38] <nielsle> let (a, b, c) = (~1, rc(1), gc(1));  // But that would require rust to  be case sensitive :-)
[18:04:47] *** Quits: earlzlap (earlz@moz-483E1E31.neo.res.rr.com) (Ping timeout)
[18:05:00] <eddyb> uhm, rust is case sensitive
[18:05:10] <nielsle> Oh
[18:05:43] <eddyb> diverse: box?
[18:06:23] <diverse> eddyb: yeah I like that!
[18:06:54] <diverse> let foo = box(Rc) bar;
[18:07:27] <diverse> that way we can specify which type of boxing it is
[18:07:32] <eddyb> nielsle: you can have fn Rc<T>(value: T) -> Rc<T> {Rc::new(value)}
[18:08:03] <eddyb> and also mod Rc {...}
[18:08:32] <diverse> kimundi: how about 'box' as a keyword?
[18:08:51] <eddyb> hey, here's a thought: mod Foo<T> {...}. that might solve the associated items problem :D
[18:10:15] *** Joins: eholk (eholk@moz-EA69C7A5.wavecable.com)
[18:10:20] <kimundi> diverse: Not sure, I think it wouldn't be specific enough :P
[18:11:09] <eddyb> lets reinvent terminology. I propose "cage"
[18:11:12] <ssbr> It seems to be even more specific than "new"
[18:11:22] <nielsle> or wrap?
[18:11:30] <ssbr> (well, "new" doesn't even mean the right thing at all, but even so)
[18:11:58] <eddyb> allocations are called cages, making them creepy enough to deter overuse
[18:13:30] <diverse> According to the Rusticon defintion of 'box' it's "An allocated chunk of memory." I think using 'box' is perfect and fits the Rust lingo. https://github.com/mozilla/rust/wiki/The-Rusticon
[18:14:27] *** Joins: JanC (janc@moz-CFBC98AF.dsl.scarlet.be)
[18:14:32] *** Quits: nsf (nsf@moz-EEF3238A.convex.ru) (Quit: WeeChat 0.4.2)
[18:15:09] <eddyb> rusty cage, anyone?
[18:16:28] <diverse> eddyb: "cage" is too long. :P
[18:16:51] <Earnestly> eddyb: I gets it, no worries
[18:17:01] *** Joins: DAddYE (DAddYE@moz-98D3933F.hsd1.ca.comcast.net)
[18:17:21] *** Quits: DAddYE (DAddYE@moz-98D3933F.hsd1.ca.comcast.net) (Client exited)
[18:17:21] *** Joins: DAddYE (DAddYE@moz-98D3933F.hsd1.ca.comcast.net)
[18:17:43] <ssbr> threading is full of all sorts of opportunities. Rusty fence, rusty lock, etc.
[18:18:20] <ssbr> "etc." is of course code for "I can't think of any more, but, hey"
[18:18:29] <eddyb> rustex
[18:18:55] <diverse> eddyb: remove the 't'
[18:19:00] <eddyb> ^ when futex isn't enough
[18:19:01] *** Joins: JamesNZ (james@moz-264643C7.bitstream.orcon.net.nz)
[18:19:30] <eddyb> diverse: lol. fun fact: futex sounds like "fuckex" in Romanian (and probably a couple of other languages)
[18:19:37] <diverse> nice
[18:19:57] *** Joins: lkuper (lkuper@87D98E32.4046EB22.428F94DD.IP)
[18:20:13] <erickt1> eddyb / sp3d / strcat: back on the whole collatz fn thing, porting the high level haskell to our iterators works pretty well, though it is a tad slower than the ghc-with-stream-fusion on my box: https://gist.github.com/erickt/7722520 
[18:20:19] <Blei> hmm, why is a buffered stream not flushed when dropped? this makes it very impractical to use generically
[18:20:26] <diverse> kimundi: what do you think? box == allocation chuck
[18:20:36] <Blei> ie do_something(my_buffered_stream as @Writer)
[18:21:33] <diverse> and 'box' is not hard to type either :P
[18:22:33] <eddyb> erickt1: IterateIterator is some sort of recursive iterator?
[18:22:42] *** Quits: Cromulent (Cromulent@moz-C2470BE2.cable.virginm.net) (Quit: KVIrc 4.2.0 Equilibrium http://www.kvirc.net/)
[18:23:03] <erickt1> eddyb: yeah. It returns a stream of x, f(x), f(f(x)), f(f(f(x))), ...
[18:23:11] <eddyb> erickt1: also, |&a| (if a % 2 == 0 { a } else { 3 * a + 1 }) / 2 // looks a tad better :P
[18:24:01] <erickt1> eddyb: yeah, I was trying to do a straight translation of the haskell :)
[18:24:11] *** Quits: cdidd (cdidd@moz-7E06665B.broadband.corbina.ru) (Ping timeout)
[18:24:32] <Blei> yay, down to 1.5s from 60s
[18:24:44] <Blei> if only the result were still correct XD
[18:27:15] *** Quits: eholk (eholk@moz-EA69C7A5.wavecable.com) (Ping timeout)
[18:27:35] <eddyb> https://mail.mozilla.org/pipermail/rust-dev/2013-November/007029.html win :D
[18:28:03] *** Joins: brianm (brianm@moz-8161EF8D.hsd1.ca.comcast.net)
[18:28:11] *** Joins: eholk (eholk@moz-EA69C7A5.wavecable.com)
[18:28:59] *** Quits: DAddYE (DAddYE@moz-98D3933F.hsd1.ca.comcast.net) (Client exited)
[18:29:03] *** Quits: eholk (eholk@moz-EA69C7A5.wavecable.com) (Quit: eholk)
[18:29:54] *** Quits: brianm (brianm@moz-8161EF8D.hsd1.ca.comcast.net) (Ping timeout)
[18:30:27] *** Quits: strcat (strcat@moz-54F7FD49.cpe.net.cable.rogers.com) (Ping timeout)
[18:30:44] *** Quits: rusti (rusti@moz-54F7FD49.cpe.net.cable.rogers.com) (Ping timeout)
[18:30:54] *** Joins: rusti (rusti@moz-54F7FD49.cpe.net.cable.rogers.com)
[18:33:20] *** Joins: wilmoore (wilmoore@moz-71431C3A.hsd1.co.comcast.net)
[18:33:36] *** Joins: Skif (emschwar@moz-4C5BB5A8.beyondbb.com)
[18:35:03] <Blei> eddyb: btw. about that change to the ast that i made, do you think it's worth it to send a pull request or will it be made obsolete by your changes?
[18:35:17] *** Quits: Skif (emschwar@moz-4C5BB5A8.beyondbb.com) (Ping timeout)
[18:35:23] <eddyb> Blei: they don't overlap
[18:35:37] <Blei> ok, great. thanks
[18:37:05] *** Quits: canhtak (canhtak@moz-6F820ACE.wl.t.ulaval.ca) (Quit: canhtak)
[18:37:10] <bstrie> did someone say rusty cage? http://www.youtube.com/watch?v=pBZs_Py-1_0
[18:37:54] *** Quits: arodier74 (Thunderbir@5901C3C8.B6144566.D3B9122.IP) (Quit: arodier74)
[18:38:30] *** Joins: jeaye (Jeaye@moz-34FEF2BB.hsd1.ca.comcast.net)
[18:40:39] *** Quits: victorporof (victorporo@FB8E2A00.483E5FE1.9B1E38F4.IP) (Quit: victorporof)
[18:41:05] <erickt1> eddyb / sp3d: it appears that if I pass a uint around by value instead of by reference it performs as fast as c: https://gist.github.com/erickt/7722791
[18:41:40] *** Joins: victorporof (victorporo@FB8E2A00.483E5FE1.9B1E38F4.IP)
[18:41:51] *** Quits: pseudoku (quassel@A2C7F582.85934B53.520CDC98.IP) (Client exited)
[18:41:51] <Ms2ger> IterateIterator?
[18:42:09] <eddyb> should renamed to RecursiveIterator IMO
[18:42:10] <erickt1> Ms2ger: yeah, it's a copy of haskell's iterate fn: http://hackage.haskell.org/package/base-4.6.0.1/docs/src/GHC-List.html#iterate
[18:42:15] *** Joins: brianm (brianm@moz-8161EF8D.hsd1.ca.comcast.net)
[18:42:25] *** Joins: strcat (strcat@moz-54F7FD49.cpe.net.cable.rogers.com)
[18:43:24] <erickt1> eddyb: that's a reasonable suggestion
[18:43:33] *** Joins: lenstr (lenstr@16EEB0B4.37215F2D.CAA35E3B.IP)
[18:43:54] <eddyb> s/renamed/rename
[18:44:49] <strcat> erickt1: can you avoid unwrap in that next implementation?
[18:45:06] *** Joins: killerswan (kevincantu@moz-CC0DC654.hsd1.ca.comcast.net)
[18:45:09] <erickt1> strcat: I'm trying that right now :)
[18:46:19] *** Joins: eholk (eholk@moz-EA69C7A5.wavecable.com)
[18:47:39] *** Quits: sp3d (s@moz-41A29595.dhcp.stls.mo.charter.com) (Connection reset by peer)
[18:48:11] <erickt1> strcat: yep, that performs the same. I need to do a nasty double clone though: https://gist.github.com/erickt/7722904
[18:48:22] <erickt1> oops that's wrong
[18:48:54] <erickt1> strcat: updated that gist to be right
[18:49:00] <erickt1> it performs the same though
[18:49:50] <Ms2ger> ... Which unwrap?
[18:50:39] <eddyb> is there no Copyable trait?
[18:51:00] <eddyb> well, good thing Clone is a noop for ints
[18:51:02] <erickt1> Ms2ger: I think he meant this: https://gist.github.com/erickt/7722520#file-collatz-rs-L15
[18:51:16] <Ms2ger> Ah
[18:51:41] <Ms2ger> Sounds like I should look at the right code :)
[18:51:56] <erickt1> strcat: actually I think it's passing around the uints as a reference. This is slower than C: https://gist.github.com/erickt/7722937
[18:52:10] <strcat> erickt1: are you using --opt-level=3?
[18:52:14] <erickt1> yeah
[18:52:30] *** Quits: jlong (jlong@moz-6DFDE846.socal.res.rr.com) (Quit: My MacBook Pro has gone to sleep. ZZZzzz)
[18:52:39] <erickt1> I'll upload the .ll files of with and without the `&`
[18:56:00] <erickt1> strcat: https://gist.github.com/erickt/7722990. collatz3 is with `&` and collatz4 is without `&`
[18:56:16] <erickt1> collatz3 runs at 0.23 for me, collatz4 runs at 0.19
[18:57:01] <eddyb> I'm guessing aliasing analysis doesn't work that well :P
[18:58:03] <strcat> erickt1: still need to avoid unwrap
[18:59:21] *** Quits: gokcehan (Mibbit@A06BA29A.55DBA505.232D870F.IP) (Quit: http://www.mibbit.com ajax IRC Client)
[19:00:32] *** Joins: earlzlap (earlz@moz-483E1E31.neo.res.rr.com)
[19:01:05] <erickt1> strcat: sure, but that's not the real problem, it's why can't llvm optimize away that reference? I thought it could. Is it like eddyb suggests that we aren't providing enough aliasing info to llvm?
[19:01:18] *** Quits: oberstet (quassel@moz-B10754C7.dynamic.mnet-online.de) (Client exited)
[19:02:20] *** Quits: heftig (heftig@moz-FC483BB3.dip0.t-ipconnect.de) (Ping timeout)
[19:03:02] *** Quits: sankha93 (Instantbir@7061CD01.D6BD0D91.22D41759.IP) (Ping timeout)
[19:03:02] *** Quits: wilmoore (wilmoore@moz-71431C3A.hsd1.co.comcast.net) (Ping timeout)
[19:03:40] *** Joins: sankha93 (Instantbir@7061CD01.D6BD0D91.22D41759.IP)
[19:04:43] *** Joins: cdidd (cdidd@moz-D6B46712.broadband.corbina.ru)
[19:05:00] *** Quits: earlzlap (earlz@moz-483E1E31.neo.res.rr.com) (Ping timeout)
[19:06:24] *** Joins: etw (john@moz-D871A25B.nyc.res.rr.com)
[19:08:18] *** Joins: ohler (ohler@C7A9365F.7E6A0813.1428D117.IP)
[19:08:42] *** Joins: heftig (heftig@moz-9BAF7343.dip0.t-ipconnect.de)
[19:10:15] *** Quits: kuuranne (kuuranne@moz-C4357EA7.kapsi.fi) (Ping timeout)
[19:10:15] *** Quits: zokier` (zokier@moz-C4357EA7.kapsi.fi) (Ping timeout)
[19:11:27] *** Joins: zokier` (zokier@moz-C4357EA7.kapsi.fi)
[19:11:32] *** Joins: kuuranne (kuuranne@moz-C4357EA7.kapsi.fi)
[19:13:38] *** Joins: BizarreCake (BizarreCak@moz-361FE9B2.dynamic.barak-online.net)
[19:13:44] <erickt1> strcat: i wonder if llvm's argpromotion optimization isn't working for us: http://llvm.org/docs/Passes.html#argpromotion-promote-by-reference-arguments-to-scalars
[19:14:35] <bstrie> is there an issue filed for making `for` loops not be just a parser hack
[19:14:41] <bstrie> strcat: ^
[19:15:49] <bstrie> github's issue search sadly doesn't like the word "for"...
[19:15:58] *** Quits: brianm (brianm@moz-8161EF8D.hsd1.ca.comcast.net) (Quit: Linkinus - http://linkinus.com)
[19:16:11] <benh> Maybe https://github.com/mozilla/rust/issues/8255 ?
[19:17:38] <bstrie> I'm not sure that's the same thing
[19:17:42] <Blei> oh noez, bindgen, what are you doing? those @mut everywhere apparently where there for a reason
[19:17:51] <bstrie> though it would probably be solved by fixing the parser hack
[19:18:38] <eddyb> rusti: for i in 10 {}
[19:18:38] -rusti- <anon>:9:9: 10:5 error: type `&mut <VI0>` does not implement any method in scope named `next`
[19:18:38] -rusti- <anon>:9          for i in 10 {}
[19:18:38] -rusti- <anon>:10     };
[19:18:39] -rusti- error: aborting due to previous error
[19:18:39] -rusti- application terminated with error code 101
[19:20:48] *** Quits: killerswan (kevincantu@moz-CC0DC654.hsd1.ca.comcast.net) (Quit: killerswan)
[19:21:21] *** Quits: pnkfelix (pnkfelix@moz-43495417.fbx.proxad.net) (Quit: Leaving.)
[19:23:02] *** Quits: etw (john@moz-D871A25B.nyc.res.rr.com) (Ping timeout)
[19:24:41] <FreeFull_> rusti: for i in [1,2,3] { i = i + 1 }
[19:24:42] -rusti- <anon>:9:9: 10:5 error: type `&mut [<VI2>, .. 3]` does not implement any method in scope named `next`
[19:24:42] -rusti- <anon>:9          for i in [1,2,3] { i = i + 1 }
[19:24:42] -rusti- <anon>:10     };
[19:24:42] -rusti- error: aborting due to previous error
[19:24:42] -rusti- application terminated with error code 101
[19:24:48] *** Joins: jlong (jlong@moz-6DFDE846.socal.res.rr.com)
[19:25:52] *** Quits: samnardoni (samnardoni@FC9A45BE.3393236F.BFD1ABFD.IP) (Ping timeout)
[19:25:59] *** Quits: SiegeLord (sl@moz-C606190.bstnma.fios.verizon.net) (Client exited)
[19:28:27] *** Joins: SiegeLord (sl@moz-C606190.bstnma.fios.verizon.net)
[19:29:03] *** Joins: wilmoore (wilmoore@moz-71431C3A.hsd1.co.comcast.net)
[19:29:22] *** Joins: DAddYE (DAddYE@moz-98D3933F.hsd1.ca.comcast.net)
[19:31:58] *** Quits: DAddYE (DAddYE@moz-98D3933F.hsd1.ca.comcast.net) (Ping timeout)
[19:32:48] *** Quits: mcarberry (mcarberry@moz-BE1C9F3F.lightspeed.frokca.sbcglobal.net) (Ping timeout)
[19:32:57] *** Joins: james4k (james@moz-E7990244.consolidated.net)
[19:33:21] *** Quits: eholk (eholk@moz-EA69C7A5.wavecable.com) (Ping timeout)
[19:33:48] *** Joins: GeneralMaximus (ankur@704E18E2.13A5FC81.D5D59AD9.IP)
[19:34:40] *** Quits: james4k (james@moz-E7990244.consolidated.net) (Ping timeout)
[19:36:09] *** Quits: lkuper (lkuper@87D98E32.4046EB22.428F94DD.IP) (Quit: lkuper)
[19:37:55] *** Joins: moostik (Icedove@moz-C2FFB694.w82-121.abo.wanadoo.fr)
[19:40:04] *** Joins: DAddYE (DAddYE@moz-98D3933F.hsd1.ca.comcast.net)
[19:40:25] *** Joins: g3xzh (g3xzh@moz-85224D43.red.bezeqint.net)
[19:41:10] *** Joins: notmatt (notmatt@moz-9FB2565E.vc.shawcable.net)
[19:41:46] *** Quits: DAddYE (DAddYE@moz-98D3933F.hsd1.ca.comcast.net) (Ping timeout)
[19:42:07] *** Joins: noy (user@moz-44A5916A.a146.priv.bahnhof.se)
[19:42:17] *** Quits: heftig (heftig@moz-9BAF7343.dip0.t-ipconnect.de) (Quit: Quitting)
[19:43:05] *** Joins: heftig (heftig@moz-9BAF7343.dip0.t-ipconnect.de)
[19:43:23] *** Joins: canhtak (canhtak@moz-A13A68C3.wl.t.ulaval.ca)
[19:47:38] *** Quits: moostik (Icedove@moz-C2FFB694.w82-121.abo.wanadoo.fr) (Ping timeout)
[19:47:55] *** Quits: erickt1 (Adium@49C4075F.3AC15C18.2321E71E.IP) (Connection reset by peer)
[19:47:56] *** Joins: erickt1 (Adium@49C4075F.3AC15C18.2321E71E.IP)
[19:48:18] *** Joins: mcarberry (mcarberry@moz-BE1C9F3F.lightspeed.frokca.sbcglobal.net)
[19:50:28] *** Quits: BizarreCake (BizarreCak@moz-361FE9B2.dynamic.barak-online.net) (Quit: Leaving)
[19:52:53] *** Quits: victorporof (victorporo@FB8E2A00.483E5FE1.9B1E38F4.IP) (Quit: victorporof)
[19:53:10] *** Quits: erickt1 (Adium@49C4075F.3AC15C18.2321E71E.IP) (Quit: Leaving.)
[19:53:30] *** Joins: enix (enix@moz-A50569DD.c3-0.slvr-ubr1.lnh-slvr.md.cable.rcn.com)
[19:54:35] *** Quits: twb (textual@moz-5DE8950B.hsd1.ga.comcast.net) (Quit: My MacBook Pro has gone to sleep. ZZZzzz)
[19:55:19] *** Quits: ohler (ohler@C7A9365F.7E6A0813.1428D117.IP) (Quit: ohler)
[19:55:36] *** Joins: maxiepoo (Max@moz-63A79E35.sw.biz.rr.com)
[19:55:53] *** Quits: StarLight (StarLight@moz-2F47C036.dynamic.avangarddsl.ru) (Ping timeout)
[19:58:21] *** Joins: moostik (Icedove@moz-C2FFB694.w82-121.abo.wanadoo.fr)
[19:58:50] *** Quits: JamesNZ (james@moz-264643C7.bitstream.orcon.net.nz) (Quit: Busying myself...)
[19:59:35] *** Quits: wilmoore (wilmoore@moz-71431C3A.hsd1.co.comcast.net) (Ping timeout)
[19:59:38] *** Quits: maxiepoo (Max@moz-63A79E35.sw.biz.rr.com) (Quit: maxiepoo)
[19:59:55] *** Quits: GeneralMaximus (ankur@704E18E2.13A5FC81.D5D59AD9.IP) (Quit: Computer has gone to sleep.)
[20:00:10] *** Quits: moostik (Icedove@moz-C2FFB694.w82-121.abo.wanadoo.fr) (Ping timeout)
[20:00:20] *** Quits: g3xzh (g3xzh@moz-85224D43.red.bezeqint.net) (Client exited)
[20:01:01] *** Joins: hjr3 (hradtke@moz-E87BDF1F.socal.res.rr.com)
[20:01:15] *** Joins: nsf (nsf@moz-EEF3238A.convex.ru)
[20:04:21] *** Quits: hjr3 (hradtke@moz-E87BDF1F.socal.res.rr.com) (Quit: My MacBook has gone to sleep. ZZZzzz)
[20:07:15] *** Quits: Ms2ger (Ms2ger@C91975CB.3387515C.187A1082.IP) (Quit: nn)
[20:07:44] *** Joins: erickt1 (Adium@49C4075F.3AC15C18.2321E71E.IP)
[20:11:17] *** Joins: sp3d (s@moz-41A29595.dhcp.stls.mo.charter.com)
[20:12:43] <sp3d> is there a std::cast::copy_lifetime_vec that uses a vec as the destination rather than source?
[20:16:41] *** Joins: twb (textual@moz-5DE8950B.hsd1.ga.comcast.net)
[20:19:55] <Blei> arrg! a borrowed error again!
[20:22:26] *** Joins: Skif (emschwar@moz-4C5BB5A8.beyondbb.com)
[20:22:51] *** Joins: jvns (bork@87D98E32.4046EB22.428F94DD.IP)
[20:24:06] *** Quits: Skif (emschwar@moz-4C5BB5A8.beyondbb.com) (Ping timeout)
[20:24:57] *** Quits: lenstr (lenstr@16EEB0B4.37215F2D.CAA35E3B.IP) (Ping timeout)
[20:25:08] *** Joins: lenstr (lenstr@DA467856.8FE2B31C.CAA35E3B.IP)
[20:26:40] *** Joins: wilmoore (wilmoore@moz-71431C3A.hsd1.co.comcast.net)
[20:28:04] *** Quits: Sgeo (quassel@moz-D0F30617.dyn.optonline.net) (Ping timeout)
[20:28:05] <jvns> if I want to create a vector of length 256 with rust-core, do I need to write a 'from_elem' myself?
[20:28:12] *** Joins: Sgeo (quassel@moz-D0F30617.dyn.optonline.net)
[20:28:42] <strcat> jvns: I would just use with_capacity and push for now
[20:29:07] <strcat> jvns: do you mean a fixed-length vector?
[20:29:13] <jvns> yup
[20:29:22] <strcat> from_elem is for a dynamically sized one
[20:29:26] <cmr> from_elem doesn't work for fixed length vecs
[20:29:30] <jvns> oh okay!
[20:29:38] <strcat> jvns: I need to add a mutable slice iterator
[20:29:47] <strcat> sec
[20:30:14] <Blei> and removing the @mut context doesn't work, because closures can't contain &mut ptrs
[20:30:19] <Blei> why, rust, why??
[20:31:03] <strcat> &mut is an affine type just like a type with a dtor
[20:31:09] <strcat> you would need stack once closures
[20:31:42] *** Joins: DAddYE (DAddYE@moz-98D3933F.hsd1.ca.comcast.net)
[20:32:29] <Blei> yeah, it's just that @mut produces non-understandable dynamic borrow check errors, but rust kind of forces you to actually use @mut
[20:32:49] <eddyb> Blei: ~RefCell<T>, maybe?
[20:33:19] *** Joins: DIONISO (zxcvbnm@moz-12D668EC.telecom.net.ar)
[20:33:23] <strcat> Blei: it doesn't really force you to use @mut
[20:33:23] *** Quits: DAddYE (DAddYE@moz-98D3933F.hsd1.ca.comcast.net) (Ping timeout)
[20:33:24] <eddyb> Rc<RefCell<T>> to get closer
[20:33:38] *** Quits: sankha93 (Instantbir@7061CD01.D6BD0D91.22D41759.IP) (Quit: Gone to save the world!)
[20:33:42] <strcat> people write code just fine in clojure with immutable data structures ;p
[20:33:53] *** Parts: DIONISO (zxcvbnm@moz-12D668EC.telecom.net.ar) ()
[20:34:04] <eddyb> context folding isn't something people are used to :P
[20:34:18] <Blei> eddyb: thanks, i might try that.
[20:34:24] <Blei> first some more debugging
[20:34:27] <eddyb> s/people/people coming from certain languages/
[20:34:28] *** Quits: doomlord_ (servitor@moz-9738D381.range86-160.btcentralplus.com) (Connection reset by peer)
[20:34:48] <Blei> i still don't understand how that dynamic borrow check error could actually arise, i didn't change anything in that area :S
[20:34:53] <jvns> strcat, hmm I got a terrifying error: http://paste.ofcode.org/dj6LHVeaNGYEdRtQwNSSxm
[20:34:54] *** Joins: samnardoni (samnardoni@FC9A45BE.3393236F.BFD1ABFD.IP)
[20:35:22] <eddyb> strcat: doesn't Rust allow you to do let new_context = Context { foo_counter: old_context.foo_counter + 1, ..old_context }?
[20:35:32] <eddyb> though you could say it's inefficient
[20:35:34] <strcat> jvns: missing #[no_std]
[20:35:48] <strcat> jvns: with_capacity is for a dynamically sized vector, not a fixed-size one
[20:35:54] <jvns> oh!
[20:35:58] <strcat> if you want a fixed-size vector you need [value, ..length]
[20:35:59] <jvns> how do I make a fixed-size vector?
[20:36:05] <strcat> rusti: [5, ..10]
[20:36:06] -rusti- [5, 5, 5, 5, 5, 5, 5, 5, 5, 5]
[20:36:30] *** Joins: fabiand (fabiand@moz-A54F5502.adsl.alicedsl.de)
[20:36:39] *** Quits: samnardoni (samnardoni@FC9A45BE.3393236F.BFD1ABFD.IP) (Ping timeout)
[20:36:54] <eddyb> jvns: also, you can't have non-constant expressions in static initializers
[20:37:04] <strcat> rusti: let mut xs = [0, ..10]; for (i, r) in range(0, 10).zip(xs.mut_iter()) { *r = i; } xs
[20:37:05] -rusti- [0, 1, 2, 3, 4, 5, 6, 7, 8, 9]
[20:37:11] <Blei> oh, actually, does &mut also do dynamic borrow checks?
[20:37:17] <cmr> no
[20:37:20] <strcat> Blei: no, & and &mut are static
[20:37:25] <Blei> hrrm
[20:37:25] <jvns> hmm okay
[20:37:33] <Blei> then i understand even less what's going on
[20:37:35] <strcat> there are no dynamic failures at a language level now that @/@mut is feature-gated/deprecated
[20:37:50] <strcat> for those things
[20:37:58] <strcat> (&, &mut)
[20:38:07] <strcat> Blei: well I suggest not using @mut
[20:38:16] <eddyb> I did want to make the IDT implementation in rustic neater :D
[20:38:19] <strcat> it's going to be removed partly because it hides the possibility of dynamic failure
[20:38:21] <Blei> ah, ok, i was looking at the wrong @mut the whole time
[20:38:35] <Blei> strcat: i'm working on code that's not mine
[20:38:36] <strcat> Blei: & points to immutable memory
[20:38:42] <strcat> the compiler has to guarantee that it's immutable
[20:38:45] <strcat> so it 'freezes' it
[20:38:51] <strcat> for anything owned (most things), freezing is static
[20:38:56] <Blei> and i tried to remove all the @mut but ran into trouble
[20:38:59] <strcat> it knows who is the owner is, if it can see the value
[20:39:04] <strcat> if it can't see the value it already has &
[20:39:07] <strcat> so it knows it's frozen
[20:39:31] <strcat> &mut is a unique handle to some memory - it also essentially freezes, and prevents further borrows
[20:39:47] <strcat> so now consider a type that's *not* owned, the compiler doesn't statically know about all the owners
[20:39:56] <strcat> Rc and Gc and immutable, precisely because they can't inherit mutability
[20:40:04] <strcat> RefCell provides dynamic borrow checking
[20:40:14] <strcat> Gc<RefCell<T>> replaces @mut T
[20:40:37] *** Quits: logicalparadox (logicalpar@moz-C73156AE.dr01.wlbr.pa.frontiernet.net) (No route to host)
[20:42:09] <eddyb> bstrie: idea for "for x in y": y needs to implement the Iterable trait, so it works with containers. an Iterator is also Iterable (and it returns itself for Iterator::iter() or whatever it would be)
[20:42:42] <eddyb> I would post a write-up to the mailing list, but I should be working on other things :D
[20:43:57] <strcat> jvns: there, added mutable vector iterator (slice::mut_iter) too
[20:44:07] <strcat> although it's missing all the fancy adaptors and stuff for now.
[20:44:09] *** Quits: strcat (strcat@moz-54F7FD49.cpe.net.cable.rogers.com) (Quit: WeeChat 0.4.2)
[20:44:27] *** Joins: hjr3 (hradtke@moz-E87BDF1F.socal.res.rr.com)
[20:44:31] <Blei> ok, found it.
[20:44:43] <Blei> @mut sucks, so much
[20:45:02] <jvns> strcat: thanks!
[20:45:11] *** Joins: epdtry (stuart@moz-6BEF78C1.hsd1.wa.comcast.net)
[20:46:00] <eddyb> Blei: yupp. I removed the last of it from AST a few days ago, kill it if you can :D
[20:47:42] *** Quits: wilmoore (wilmoore@moz-71431C3A.hsd1.co.comcast.net) (Ping timeout)
[20:48:53] *** Joins: doomlord_ (servitor@moz-9738D381.range86-160.btcentralplus.com)
[20:49:10] <Blei> i would love to, but it'd be quite the rewrite probably
[20:49:33] <Blei> eh, maybe i'll try, now that it at least runs again
[20:50:04] <eddyb> Blei: what did you say you were working on?
[20:50:39] <Blei> bindgen
[20:50:49] <eddyb> riiight.
[20:50:58] <eddyb> Blei: does it needs to be shared?
[20:51:06] <Blei> well, first on my own little project that uses bindgen to generate a huge bindings file for gtk and gstreamer
[20:51:15] <Blei> before my changes: 45s, after: 3s
[20:51:17] <Blei> yay
[20:51:24] *** Joins: mib_rgwgfo (Mibbit@1FAB1223.5011DB02.BFD1ABFD.IP)
[20:51:35] <eddyb> Blei: hehe, I know the feeling
[20:52:02] *** Joins: lkuper (lkuper@87D98E32.4046EB22.428F94DD.IP)
[20:52:06] <eddyb> after I've managed to stop rustc from wanting to allocate hundreds of GBs by wrapping every match case in its own function *ahem*
[20:52:23] <Blei> haha, nice
[20:52:58] <eddyb> Blei: a PR that got through (reducing the size of IDs and Names from uint to u32) and the boxing one that's testing right now make that testcase go from 1.6GB to 1.2GB
[20:53:18] <Blei> even nicer!
[20:53:49] <eddyb> that is, RAM usage during compiling
[20:57:06] *** Quits: themgt (themgt@moz-83F07CDA.cm.vtr.net) (Ping timeout)
[20:57:08] *** Quits: mib_rgwgfo (Mibbit@1FAB1223.5011DB02.BFD1ABFD.IP) (Quit: http://www.mibbit.com ajax IRC Client)
[20:57:43] *** Joins: jfbk (jfbk@moz-EEA9CFB3.nyc.res.rr.com)
[20:58:51] *** Quits: eddyb (eddy@EBE709F3.F7C96DA2.FCAAE698.IP) (Ping timeout)
[21:01:18] *** Joins: pnkfelix (pnkfelix@moz-43495417.fbx.proxad.net)
[21:01:18] *** ChanServ sets mode: +o pnkfelix
[21:02:03] *** Joins: eddyb (eddy@EBE709F3.F7C96DA2.FCAAE698.IP)
[21:02:07] *** Joins: themgt (themgt@moz-83F07CDA.cm.vtr.net)
[21:02:26] *** Joins: pnkfelix1 (pnkfelix@moz-43495417.fbx.proxad.net)
[21:03:18] *** Quits: pnkfelix (pnkfelix@moz-43495417.fbx.proxad.net) (Ping timeout)
[21:03:44] *** Joins: mib_vppvqr (Mibbit@moz-1D2B251E.catv.broadband.hu)
[21:03:53] *** Quits: mib_vppvqr (Mibbit@moz-1D2B251E.catv.broadband.hu) (Quit: http://www.mibbit.com ajax IRC Client)
[21:04:06] *** Joins: mib_0u4qfk (Mibbit@moz-1D2B251E.catv.broadband.hu)
[21:04:12] <Blei> just to make sure, when cloning an @mut pointer, only the pointer is copied, right?
[21:04:20] <cmr> yes
[21:04:29] <Blei> ok, thanks
[21:05:50] *** Quits: eddyb (eddy@EBE709F3.F7C96DA2.FCAAE698.IP) (Ping timeout)
[21:10:52] *** Joins: eddyb (eddy@EBE709F3.F7C96DA2.FCAAE698.IP)
[21:14:24] <bstrie> eddyb: which testcase?
[21:15:36] <eddyb> bstrie: my crazy generated code for a BIOS (x86_16) emulator, it's in a gist if you want to take a look at it
[21:17:34] *** Quits: kphelps (kphelps@moz-8F37EAB2.ri.ri.cox.net) (Ping timeout)
[21:17:53] *** Quits: beifeng (Mibbit@B5497CF4.FA7FF645.C7DB8B78.IP) (Quit: http://www.mibbit.com ajax IRC Client)
[21:18:26] <eddyb> bstrie: https://gist.github.com/eddyb/b802f5bdc4174e0fbf11
[21:19:20] *** Joins: GeneralMaximus (ankur@704E18E2.13A5FC81.D5D59AD9.IP)
[21:20:00] *** Quits: GeneralMaximus (ankur@704E18E2.13A5FC81.D5D59AD9.IP) (Quit: Computer has gone to sleep.)
[21:21:22] *** Joins: ktt3ja (Mibbit@moz-54586A12.washdc.fios.verizon.net)
[21:23:47] *** Quits: themgt (themgt@moz-83F07CDA.cm.vtr.net) (Ping timeout)
[21:25:41] *** Joins: themgt (themgt@moz-83F07CDA.cm.vtr.net)
[21:29:02] *** Joins: ohler (ohler@C7A9365F.7E6A0813.1428D117.IP)
[21:29:21] *** Quits: KindOne (KindOne@moz-1F6A65EB.dynamic.ip.windstream.net) (Ping timeout)
[21:31:02] *** Joins: KindOne (KindOne@moz-1F6A65EB.dynamic.ip.windstream.net)
[21:31:34] <erickt1> this is so weird: https://gist.github.com/erickt/7724731. Somehow in this code calling the closure is *faster* than directly calling the function
[21:32:07] <cmr> erickt1: check the IR?
[21:32:12] <erickt1> what the heck is going on?
[21:32:24] *** Quits: eddyb (eddy@EBE709F3.F7C96DA2.FCAAE698.IP) (Ping timeout)
[21:32:27] <erickt1> cmr: I'm already looking, but I haven't found something obvious yet
[21:32:29] *** Joins: vky (chatzilla@moz-4F2E17BF.dsl.dynamic.sonic.net)
[21:32:53] *** Joins: DAddYE (DAddYE@moz-98D3933F.hsd1.ca.comcast.net)
[21:33:38] *** Joins: etw (john@moz-D871A25B.nyc.res.rr.com)
[21:33:58] *** Joins: Cromulent (Cromulent@moz-C2470BE2.cable.virginm.net)
[21:34:39] *** Quits: DAddYE (DAddYE@moz-98D3933F.hsd1.ca.comcast.net) (Ping timeout)
[21:42:38] *** Quits: fabiand (fabiand@moz-A54F5502.adsl.alicedsl.de) (Quit: Verlassend)
[21:43:33] *** Joins: eddyb (eddy@EBE709F3.F7C96DA2.FCAAE698.IP)
[21:48:53] <mletterle> ugh, I don't like the 'do' changes :( *pouts*
[21:49:06] *** Joins: ofeldt (ofeldt@moz-14998314.dip0.t-ipconnect.de)
[21:49:49] <sp3d> is there something like transmute_region for slices?
[21:49:53] *** Quits: ofeldt- (ofeldt@moz-27DC1338.dip0.t-ipconnect.de) (Ping timeout)
[21:49:58] *** Quits: Blei (philipp@moz-B2F9E4BD.cust.bluewin.ch) (Ping timeout)
[21:50:12] <benh> sp3d: You can just use regular transmute with precise type annotations...
[21:50:22] <erickt1> cmr: this is even more odd. Somehow calling `let a = x.clone()`, where x is a uint (which should be a noop) allows for an optimization, but calling `let a = x` is preventing that optimization
[21:50:43] *** Quits: pnkfelix1 (pnkfelix@moz-43495417.fbx.proxad.net) (Quit: Leaving.)
[21:51:06] *** Joins: Cromulent|2 (Cromulent@moz-C2470BE2.cable.virginm.net)
[21:52:02] *** Quits: Cromulent (Cromulent@moz-C2470BE2.cable.virginm.net) (Ping timeout)
[21:52:34] <cmr> That's odd..
[21:53:27] <erickt1> I must somehow be right on the edge between llvm deciding to inline something or not
[21:56:30] *** Joins: mib_10jlw4 (Mibbit@moz-3213C615.wavecable.com)
[21:57:55] <mib_10jlw4> I'm trying to troubleshoot why travis-ci was able to build this less then an hour ago, but for me it won't compile. https://travis-ci.org/DaGenix/rust-crypto
[21:58:25] <mib_10jlw4> Using  rustc 0.9-pre (cd9069c 2013-11-22 10:06:35 -0800) on x86_64-unknown-linux-gnu
[21:58:51] <erickt1> mib_0u4qfk: travis uses a nightly snapshot, perhaps rust HEAD has already backwards incompatible change?
[21:59:14] <mib_10jlw4> Are they different?
[21:59:46] <cmr> yes?
[21:59:52] <erickt1> mib_10jlw4: the nightly snapshot only happens every 24 hours. a lot can change in between then :)
[21:59:52] *** Joins: Sharp (Sharp@moz-780FECDA.washdc.fios.verizon.net)
[22:00:02] <cmr> You're using a week old rustc
[22:00:24] <mletterle> a lot changed the past week >.>
[22:00:32] <mib_10jlw4> I'm just compiling the new version now.
[22:00:44] <cmr> https://github.com/mozilla/rust/wiki/Doc-packages,-editors,-and-other-tools
[22:00:48] <mib_10jlw4> Anyway, it seems to be type-related problems, so I guess that can happen.
[22:01:42] <mletterle> not sure how I feel about this:
[22:01:43] <mletterle> 76 
[22:01:45] <mletterle> -             do io_error::cond.trap(|_|{}).inside { mkdir_recursive(&cfg_path, 0b111_111_111); }
[22:01:47] <mletterle>  76
[22:01:49] <mletterle> +            io_error::cond.trap(|_|{}).inside(|| mkdir_recursive(&cfg_path, 0b111_111_111));
[22:01:52] <mletterle> :/
[22:02:26] <mib_10jlw4> mletterle: Context?
[22:02:37] <SiegeLord> Both look... awkward imo >.>
[22:02:45] * mib_10jlw4 nods
[22:02:47] <mletterle> change to 'do'
[22:03:17] <cmr> conditions are likely being removed from io anyway
[22:03:43] <eddyb> erickt1: well... it shouldn't matter for uint, but let a = x; is a move while the clone is a copy
[22:03:53] <mletterle> I was using do pretty extensively with closures: https://github.com/mletterle/rust-nss/commit/efd42ae80d174d08c3f471b4f904687bdf910e75
[22:04:11] <SiegeLord> I had to change a whole bunch of uses of do as well :/
[22:06:58] *** Quits: Cromulent|2 (Cromulent@moz-C2470BE2.cable.virginm.net) (Quit: KVIrc 4.2.0 Equilibrium http://www.kvirc.net/)
[22:07:02] *** Joins: Cromulent (Cromulent@moz-C2470BE2.cable.virginm.net)
[22:11:07] *** Joins: Skif (emschwar@moz-4C5BB5A8.beyondbb.com)
[22:12:28] *** Quits: eddyb (eddy@EBE709F3.F7C96DA2.FCAAE698.IP) (Ping timeout)
[22:12:54] *** Quits: Skif (emschwar@moz-4C5BB5A8.beyondbb.com) (Ping timeout)
[22:14:52] <jvns> how do I fix this definition? "static idt: ~[IDTEntry, ..256] = ~[IDTEntry {base_lo: 0, sel: 0, zero: 0, flags: 0, base_hi: 0}, ..256];"
[22:15:30] <jvns> Rust complains "error: mismatched types: expected `~[IDTEntry, .. 256]` but found `~[IDTEntry]`"
[22:15:49] <myname> what is that ~ for in the first place?
[22:16:05] <myname> fixed size vectors are always put on the stack, aren't they?
[22:16:33] <erickt1> cmr / eddyb: here's a slimmed down of this mis-optimized code: https://gist.github.com/erickt/7725346
[22:16:37] <jvns> (I don't really know what I'm doing :))
[22:16:58] <jvns> I tried static idt: &[IDTEntry, ..256] = [IDTEntry {base_lo: 0, sel: 0, zero: 0, flags: 0, base_hi: 0}, ..256];
[22:17:00] <jvns> but that didn't work either
[22:17:26] <jvns> oh
[22:17:28] *** Joins: kzzch (Mibbit@moz-F709F250.sub-174-236-192.myvzw.com)
[22:17:28] <myname> drop that ~s
[22:17:29] <jvns> so this isn't inside a function
[22:17:35] <jvns> this is a global variable
[22:18:01] <jvns> so there's no stack
[22:18:24] <myname> what?
[22:18:34] *** Quits: dcrewi (david@moz-AB8667CE.gyrae.net) (Ping timeout)
[22:18:43] <jvns> I'm defining this variable outside of a function
[22:18:50] *** Joins: vfetwnuncszu (david@moz-AB8667CE.gyrae.net)
[22:18:50] <jvns> I don't know if that makes a difference or not
[22:18:58] <myname> it shouldn't
[22:19:00] *** vfetwnuncszu is now known as dcrewi
[22:19:23] <myname> thing is, ~[T] and [T, ..N] are two different things
[22:19:40] <jvns> sure
[22:19:41] <myname> i don't even know if ~[T, ..N] does make any sense at all
[22:19:44] <jvns> oh I see!
[22:19:51] *** Quits: Ferreus (ferreus@moz-5E3FA94E.pools.arcor-ip.net) (Ping timeout)
[22:20:03] *** Joins: Ferreus (ferreus@moz-5E3FA94E.pools.arcor-ip.net)
[22:20:08] <kimundi> static idt: [IDTEntry, ..256] = ~[IDTEntry {base_lo: 0, sel: 0, zero: 0, flags: 0, base_hi: 0}, ..256]; // should work, probably
[22:20:15] <kimundi> whoops
[22:20:21] <jvns> removing both the ~s fixes it, yeah
[22:20:23] <kimundi> static idt: [IDTEntry, ..256] = [IDTEntry {base_lo: 0, sel: 0, zero: 0, flags: 0, base_hi: 0}, ..256]; 
[22:20:28] <kimundi> yeah
[22:20:46] <Luqman> it's confusing, cause it seems like ~[T, ..N] means ~([T, ..N]) in the context of a type but as an expr, the type of ~[T, ..N] is ~[T]
[22:20:50] *** Joins: pnkfelix (pnkfelix@moz-43495417.fbx.proxad.net)
[22:20:50] *** ChanServ sets mode: +o pnkfelix
[22:20:51] <kimundi> can't put something that uses a heap allocation (~) into a compiletime static
[22:21:43] <jvns> oh right ~ is for heap allocations
[22:21:54] <jvns> hmm so if I wanted a static string
[22:22:15] <jvns> I would do "static &str blah = "abcd"?
[22:22:21] <jvns> er
[22:22:28] <jvns> static blah: &str = "abcd"
[22:22:44] <kimundi> static foo : &'static str = "abc"
[22:22:59] <kimundi> rusti: static foo : &'static str = "abc"; foo
[22:23:00] -rusti- "abc"
[22:23:05] <jvns> I see
[22:23:38] <jvns> I thought that 'str' was like '[u8]', so since 'str' by itself wasn't a type '[u8]' couldn't be either
[22:24:28] <myname> str is more like [char], but not quite
[22:24:41] <myname> note that char and u8 are not the same thing
[22:25:18] <myname> char corresponds to one unicode codepoint
[22:25:29] <jvns> yeah
[22:25:39] <jvns> um
[22:25:50] <jvns> so [u8] is a type.
[22:26:23] <myname> it is a vector of u8
[22:26:26] <jvns> but the tutorial doesn't talk about [T] at all, just ~[T] and &[T] and @[T]
[22:26:33] <o11c> pretty sure [u8] doesn't exist
[22:26:48] <jvns> oh
[22:26:50] <myname> jvns: there is no [T] besides [T, ..N]
[22:26:55] <jvns> ack
[22:27:04] *** Quits: pnkfelix (pnkfelix@moz-43495417.fbx.proxad.net) (Ping timeout)
[22:27:09] <myname> any vector that can grow must not stay on stack
[22:27:16] <jvns> so is [T, ..N] a ~ or @ or &?
[22:27:19] <myname> so you HAVE to point to it in some way
[22:27:23] <myname> it is neither
[22:27:28] <jvns> =(
[22:27:29] <jvns> okay
[22:27:40] <jvns> so there are 4 different kinds of things?
[22:27:46] <jvns> ~, @, &, and fixed-size vectors?
[22:28:07] <TeXitoi> kimundi: is MutableVector::mut_split() is interesting to add? -> it would do as ImmutableVector::split(), i.e. iterating on mut slice separated by a predicate
[22:28:26] *** FreeFull_ is now known as FreeFull
[22:28:41] <myname> basic idea behind ~[T], &[T] and @[T] is that they can grow and therefore aren't suitable for the stack
[22:28:43] <kimundi> TeXitoi: Ah. Hm, no idea. I think for consistency it would be good to also provide i
[22:28:47] <kimundi> it*
[22:29:33] <jvns> myname, I don't understand why [T, ..N] is a type but there's no fixed-length 'str' type
[22:29:42] <myname> jvns: there is
[22:29:46] <jvns> oh!
[22:29:50] <myname> 23:22:59 <kimundi> rusti: static foo : &'static str = "abc"; foo
[22:29:50] <kimundi> jvns: Because for a string a fixed sized type is not useful
[22:30:07] <kimundi> That's not a fixed sized string, thats a static slice to one
[22:30:13] <jvns> hmm okay
[22:30:15] <myname> ah
[22:30:36] <kimundi> ... which means technically there _is_ a fixed sized string, but not inside the rust language, just in form of a array of bytes in static memory :P
[22:30:49] <jvns> the asymmetry is confusing, but I think it makes sense
[22:30:53] <TeXitoi> kimundi: ok, thanks, as I needed it, I've almost done it, so I'll propose it
[22:31:28] <jvns> so is this type right? 
[22:31:29] <jvns> let x :: [uint, ..10] = [5, ..10]
[22:31:41] <kimundi> yeah
[22:31:46] <erickt1> hey all, can anyone run this and tell me if you are getting approximately the same outputs as I am? https://gist.github.com/erickt/7725346
[22:31:53] <kimundi> just one :, but apart from that its correct
[22:32:51] *** Joins: jafoop (Mibbit@moz-B6D2878B.cable.telstraclear.net)
[22:32:51] <jvns> rusti: let x :: ~[uint] = ~[5, ..10]
[22:32:52] -rusti- <anon>:9:18: 9:19 error: expected `;` but found `~`
[22:32:52] -rusti- <anon>:9          let x :: ~[uint] = ~[5, ..10]
[22:32:52] -rusti-                            ^
[22:32:52] -rusti- application terminated with error code 101
[22:33:02] <jvns> rusti: let x : ~[uint] = ~[5, ..10]
[22:33:03] -rusti- <anon>:10:4: 10:5 error: expected `;` but found `}`
[22:33:03] -rusti- <anon>:10     };
[22:33:03] -rusti-               ^
[22:33:03] -rusti- application terminated with error code 101
[22:33:13] <myname> jvns: what's with your obsession about ~?
[22:33:14] *** Quits: ssbr_ (~ssbr@46FE74EC.C60FE7DC.4065847B.IP) (Ping timeout)
[22:33:20] <jvns> hmm?
[22:33:36] <myname> you do not need to point to a fixed size vector
[22:33:44] <jvns> what if I wanted to?
[22:33:48] <jvns> hmm
[22:33:57] <kimundi> jvns is just trying out the differences I assume, nothing wrong with that :P
[22:34:03] <jvns> kimundi: :)
[22:34:07] <myname> i think you may (as stated above) use ~([5, ..10])
[22:34:23] *** Joins: DAddYE (DAddYE@moz-98D3933F.hsd1.ca.comcast.net)
[22:34:36] <jvns> is this how to create a variable sized vector? 
[22:34:36] <jvns> let mut numbers = ~[0, 1, 2];
[22:34:47] *** Quits: sp3d (s@moz-41A29595.dhcp.stls.mo.charter.com) (Ping timeout)
[22:34:54] <myname> because iirc ~[T, ..N] is an operator that creates a dynamic vector with N initialized values
[22:35:10] <kimundi> jvns: yeah
[22:35:13] <myname> jvns: you may also start with ~[], but yes
[22:36:07] <jvns> rusti: let mut numbers : &[uint]= &[0, 1, 2];
[22:36:09] *** Quits: DAddYE (DAddYE@moz-98D3933F.hsd1.ca.comcast.net) (Ping timeout)
[22:36:09] -rusti- pastebinned 7 lines of output: http://sprunge.us/Kegf
[22:36:34] <jvns> rusti: let mut numbers : &[uint]= &[0, 1, 2]; numbers
[22:36:35] -rusti- <anon>:9:17: 9:24 warning: variable does not need to be mutable [-W unused-mut (default)]
[22:36:35] -rusti- <anon>:9          let mut numbers : &[uint]= &[0, 1, 2]; numbers
[22:36:35] -rusti-                           ^~~~~~~
[22:36:35] -rusti- &[0u, 1u, 2u]
[22:37:08] <myname> erickt1: unfortunately i can't test right now, but why is the version with clone faster?
[22:37:22] <erickt1> myname: I have no idea :)
[22:37:26] <jvns> is rusti on github? I'd love to have my own without spamming #rust
[22:37:30] <kimundi> jvns: Btw, the differences between &[T], ~[T] and [T, ..N] and the many edge cases that exists in the language about them are cause for an still-ongoing battle for improving/unifying them more
[22:37:35] <myname> jvns: you can pm him
[22:37:44] <jvns> AMAZING
[22:37:47] <jvns> :)
[22:37:52] <kimundi> jvns: But its also somewhere on github
[22:38:58] <kimundi> jvns: It's basically just a sandbox that wraps the message you send it into a main function and passes it to rustc :P
[22:39:05] *** Quits: nsf (nsf@moz-EEF3238A.convex.ru) (Quit: WeeChat 0.4.2)
[22:39:47] <jvns> it's faster than saving a file myself and compiling it and running it :)
[22:40:01] <myname> now i want to fold collatz :(
[22:40:03] <kimundi> indeed
[22:42:17] <jvns> so there aren't any fixed size strings because the size of the string would be the number of bytes in the string and not the number of Unicode code points and it wouldn't make sense?
[22:44:23] *** Quits: sarclops (sarclops@moz-14C9EE3A.zone8.bethere.co.uk) (Ping timeout)
[22:44:31] *** Joins: ssbr_ (~ssbr@46FE74EC.C60FE7DC.4065847B.IP)
[22:45:03] <o11c> if you ever need to know the number of unicode code points, you're doing it wrong
[22:45:19] *** Joins: sarclops (sarclops@moz-14C9EE3A.zone8.bethere.co.uk)
[22:45:30] <vky> erickt1: tried running the gist, but the tests were ignored. why did that happen?
[22:45:31] <myname> jvns: why is it relevant whether there are fixed size strings or not?
[22:45:44] <erickt1> vky: try running `foo --bench`
[22:45:49] <myname> a string is either a constant or a variable, that should be all you have to know
[22:45:58] <jvns> it's a strange asymmetry in the type system to me
[22:46:05] <jvns> so I'm trying to understand why it's there
[22:46:15] <myname> jvns: it is only if you think of strings as vectors
[22:46:36] <myname> are you confused about not having fixed size integers?
[22:46:44] <jvns> so
[22:47:06] <kimundi> jvns: Yeah, something like that. Becuase the size would correlate with the content of the string, it's not very useful to have, and the other usecase - compiletime constants - is already served by &'static str, so there is no reason to have them
[22:47:31] <jvns> kimundi, thanks <3
[22:48:09] <kimundi> In fact, with how hoblled they still are, I'm wondering right now what the usecase of fixed sized strings even are
[22:48:16] *** Joins: killerswan (kevincantu@moz-CC0DC654.hsd1.ca.comcast.net)
[22:48:18] <kimundi> er, fixed sized vectors
[22:48:19] <vky> erickt1: ah, there we go. put my results in a comment on the gist.
[22:48:25] <erickt1> thanks!
[22:48:28] <jvns> o11c, can you explain  "if you ever need to know the number of unicode code points, you're doing it wrong"?
[22:48:45] <erickt1> vky: btw, did you run it with an opt-level?
[22:48:57] <vky> erickt1: I did not, should I?
[22:49:09] <erickt1> yeah, opt-level=2 or opt-level=3
[22:50:28] <vky> erickt1: okay, comment updated
[22:50:31] <jvns> Is it possible to get rusti to tell me the type of something?
[22:50:42] <jvns> there are a bunch of examples in the documentation that don't have type annotations
[22:51:04] <kimundi> jvns: basically, unicode is complex enough that you can'T really limit it to a fixed size.
[22:51:31] <kimundi> jvns: Like, 14 visible characters can take up a few kilobytes
[22:51:56] <jvns> kimundi, so it sounds like having fixed size strings would just create confusion and bugs despair 
[22:52:04] <kimundi> yeah
[22:52:10] <jvns> :)
[22:52:27] <erickt1> vky: how odd! Either something broke in between your rust HEAD (fb52956) and mine (a7b311a), or something odd is happening on OSX
[22:53:02] <jvns> is there a "typeof" function or something, to see what type is being inferred?
[22:54:02] <vky> erickt1: I've got a second VM that's a clone of the one I just used, I'll update the version of rust I've got there and give it a run once it's ready.
[22:54:10] <jvns> right now my workflow to figure out the type of things is "guess and see if it compiles" and "ask on #rust"
[22:54:30] <SiegeLord> The accepted way is to trigger a compiler error
[22:54:49] <myname> SiegeLord: sound a lot like boost
[22:54:52] <SiegeLord> Like... let _:() = what_you_want_the_type_of();
[22:54:53] <erickt1> vky: thanks for the help!
[22:55:03] <vky> erickt1: np
[22:55:14] *** Quits: mib_0u4qfk (Mibbit@moz-1D2B251E.catv.broadband.hu) (Quit: http://www.mibbit.com ajax IRC Client)
[22:55:15] <o11c> jvns: just that "number of code points" is never a useful metric. It's not useful for allocating memory or counting glyphs ...
[22:55:22] <jvns> SiegeLord, thanks! 
[22:55:34] <o11c> there are cases where you want to *iterate* over code points, but never count them
[22:55:55] <jvns> uh
[22:56:04] <jvns> what if you want to know how long somebody's name is?
[22:56:07] * jvns doesn't understand
[22:56:22] <o11c> *why* do you want to know how long their name is?
[22:56:32] <o11c> chances are you want the number of glyphs in that case
[22:56:51] <jvns> oh, I don't know what a glyph is
[22:57:12] <myname> o11c: or the width to display
[22:57:16] <o11c> a glyph is a sequence of code points that are rendered as one unit
[22:57:30] <jvns> oh by "code point" I meant glyph, I see
[22:57:38] <jvns> thanks!
[22:57:47] <benh> heh
[22:57:48] <o11c> myname: display width is built on top of glyphs even ...
[22:57:59] <jvns> "that word does not mean what I think it does"
[22:58:08] <benh> s/I/anyone/
[22:58:14] <o11c> there are still places where we like monospaced fonts, but it's impossible to do unicode correctly
[22:58:22] *** Quits: Jackneill (Jackneill@moz-CEEE36B2.pool.digikabel.hu) (Input/output error)
[22:58:28] *** Quits: jafoop (Mibbit@moz-B6D2878B.cable.telstraclear.net) (Quit: http://www.mibbit.com ajax IRC Client)
[22:58:31] <myname> jvns:  and a are both codepoints,  is a glyph that may or may not be build of 2 codepoints
[22:59:07] <jvns> myname, thanks! 
[22:59:10] <myname> (the  i just used is also just a single codepoint)
[22:59:30] <kimundi> ... And a codepoint can be encode with up to 4 bytes in utf8, which rusts string types use
[22:59:31] <o11c> hm, I don't remember how to type a combining accent ... I can only type the single-codepoint version of 
[22:59:47] <myname> o11c: dito
[22:59:56] <myname> but you CAN combine them
[23:00:38] <o11c> of course, with nfc, even if you type the two-codepoint version it often turns into the one-codepoint version without asking you
[23:01:21] *** Quits: ssbr_ (~ssbr@46FE74EC.C60FE7DC.4065847B.IP) (Ping timeout)
[23:04:18] *** Quits: twb (textual@moz-5DE8950B.hsd1.ga.comcast.net) (Quit: My MacBook Pro has gone to sleep. ZZZzzz)
[23:04:35] *** Quits: jvns (bork@87D98E32.4046EB22.428F94DD.IP) (Ping timeout)
[23:06:22] *** Joins: ssbr_ (~ssbr@46FE74EC.C60FE7DC.4065847B.IP)
[23:07:19] *** Joins: wilmoore (wilmoore@moz-71431C3A.hsd1.co.comcast.net)
[23:09:31] *** Joins: james4k (james@moz-E7990244.consolidated.net)
[23:09:49] *** Joins: zslayton (Mibbit@moz-4806B979.nyc.res.rr.com)
[23:11:19] *** Quits: james4k (james@moz-E7990244.consolidated.net) (Ping timeout)
[23:18:22] <etw> I'm trying to make a simple tree implementation in rust: https://gist.github.com/excepttheweasel/7725877 how can I return a reference to a node in the tree?
[23:18:52] *** Joins: twb (textual@moz-5DE8950B.hsd1.ga.comcast.net)
[23:18:59] <etw> a borrowed pointer
[23:19:50] <myname> what is your point in returning *first instead of first?
[23:20:06] <kimundi> okay, so your first() is almost there
[23:20:25] <myname> you GET a reference
[23:20:32] <myname> you want to RETURN a reference
[23:20:41] <myname> and yet you still resolve
[23:21:26] *** Joins: pnkfelix (pnkfelix@moz-43495417.fbx.proxad.net)
[23:21:26] *** ChanServ sets mode: +o pnkfelix
[23:21:32] <kimundi> first is a ~Tree, so ref first gets him a &~Tree, which he tries to turn into a &Tree be dereferencing and letting the ~ coerce to a &
[23:22:19] <etw> yep
[23:22:19] <myname> that doesn't sound right to me
[23:22:52] <kimundi> The bigger problem is the &Nil, because that creates a borrowed pointer to the stack frame of the function - either return a &'static str to some Nil constant, or return a reference into the &Tree in all match arms
[23:23:12] <etw> so instead of Cons(ref first - I need Cons(first then to &*first ?
[23:23:48] *** Quits: pnkfelix (pnkfelix@moz-43495417.fbx.proxad.net) (Ping timeout)
[23:23:48] <kimundi> etw: No, that would try to move oft of the Cons variant, which you neither want nor can with a &tree
[23:23:55] <kimundi> out of*
[23:26:17] <zslayton> I'm trying to implement a function that takes a `proc() -> T` and a timeout in milliseconds and returns Some<T> if the proc can be run within the timeout. I'm using std::select::select(...) to implement it, but I'm hitting a type error: https://gist.github.com/anonymous/7725895
[23:27:05] *** Quits: erickt1 (Adium@49C4075F.3AC15C18.2321E71E.IP) (Quit: Leaving.)
[23:27:59] <kimundi> rusti: enum Tree { Cons(~Tree, ~Tree), Nil } let x : &Tree = &Cons(~Nil, ~Nil); let x : &Tree = match *x { Cons(ref a, _) => { let x: &Tree = *a; x } _ => &Nil }; println!("{:?}", x);
[23:27:59] -rusti- &Nil
[23:28:00] -rusti- ()
[23:28:16] <zslayton> It doesn't seem to like the fact that I'm trying to select on a PortOne<T> and a PortOne<()> ... is there a way around that without having to make yet another task to listen for the timeout and provide the unnecessary T result?
[23:28:19] <kimundi> So, that works locally at least
[23:29:03] *** Quits: ohler (ohler@C7A9365F.7E6A0813.1428D117.IP) (Quit: ohler)
[23:30:15] <kimundi> rusti: enum Tree { Cons(~Tree, ~Tree), Nil } let x : &Tree = &Cons(~Nil, ~Nil); fn foo<'a>(x: &'a Tree) -> &'a Tree { match *x { Cons(ref a, _) => { let x: &Tree = *a; x } _ => &Nil } } println!("{:?}", foo(x));
[23:30:16] -rusti- &Nil
[23:30:16] -rusti- ()
[23:30:26] <kimundi> Hum, that actually works directly
[23:31:22] *** Joins: ohler (ohler@C7A9365F.7E6A0813.1428D117.IP)
[23:31:29] <kimundi> etw: I think what your code is missing the ~Tree -> &Tree coercion that I'm forcing in that snippet
[23:32:31] <kimundi> Something like { let tmp: &Tree = *first; tmp }
[23:33:04] <etw> ok yep
[23:35:03] <etw> that's got it, now I have to work on append
[23:35:10] <etw> thanks
[23:35:33] <kimundi> No problem, that solution is non-intuitive anyway :P
[23:36:11] <etw> I feel like I'm starting with some of the harder problems in rust
[23:37:20] *** Parts: noy (user@moz-44A5916A.a146.priv.bahnhof.se) (ERC Version 5.3 (IRC client for Emacs))
[23:37:46] *** Quits: itdnhr (it@moz-7FAAAB8D.bstnma.fios.verizon.net) (Ping timeout)
[23:38:46] <kimundi> Not really, there are just a few rough edges to stumble over ;) Data structures like this are pretty basic stuff
[23:39:25] <benh> maybe we need to be more eager about ~T->&T conversions...
[23:39:45] <etw> sure, but it's forcing me to learn a lot about moving/boxing/borrowing etc. not as intuitive as some of rust's other features
[23:40:21] *** Joins: Kruppe (user@moz-E150F49F.cpe.net.cable.rogers.com)
[23:42:47] <kimundi> benh: Yeah, there is a issue about making them consistent
[23:43:10] <kimundi> benh: Right now coercions like that only happens in let assignments and function calls
[23:43:18] *** Joins: HollyRain (HollyRain@moz-50A83091.dyn.user.ono.com)
[23:43:49] <benh> If only we had some convenient punctuation character left for explicit conversions like that so we don't have to resort to &*
[23:46:36] *** Joins: pcwalton (pcwalton@moz-DA87EE4.hsd1.ca.comcast.net)
[23:46:36] *** ChanServ sets mode: +ao pcwalton pcwalton
[23:46:42] <kimundi> return foo; // ;)
[23:46:52] <FreeFull> The degrees of foo
[23:46:58] <benh> :D
[23:47:02] *** Quits: lenstr (lenstr@DA467856.8FE2B31C.CAA35E3B.IP) (Quit: Leaving...)
[23:47:33] *** Parts: HollyRain (HollyRain@moz-50A83091.dyn.user.ono.com) (bye)
[23:47:58] *** Quits: pcwalton (pcwalton@moz-DA87EE4.hsd1.ca.comcast.net) (Quit: pcwalton)
[23:49:40] *** Joins: lenstr (lenstr@DA467856.8FE2B31C.CAA35E3B.IP)
[23:50:57] *** Quits: ktt3ja (Mibbit@moz-54586A12.washdc.fios.verizon.net) (Quit: http://www.mibbit.com ajax IRC Client)
[23:52:17] *** Quits: lenstr (lenstr@DA467856.8FE2B31C.CAA35E3B.IP) (Quit: Leaving...)
[23:53:37] *** Joins: lenstr (lenstr@DA467856.8FE2B31C.CAA35E3B.IP)
[23:54:56] *** Quits: lenstr (lenstr@DA467856.8FE2B31C.CAA35E3B.IP) (Quit: Leaving...)
[23:56:11] *** Joins: mikezaby (mikezaby@moz-AA896205.home.otenet.gr)
[23:56:27] *** Parts: mikezaby (mikezaby@moz-AA896205.home.otenet.gr) ()
[23:56:40] <zslayton> Should I be using the constructs in std::comm or std::rt::comm if I want the latest?
[23:58:20] <vky> erickt: updated my comment on the gist with a couple more runs. Also not streaming a video on the host machine while running the benches this time.
[23:59:51] *** Joins: Skif (emschwar@moz-4C5BB5A8.beyondbb.com)

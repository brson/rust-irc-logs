[00:00:20] <MaikKlein> tikue, event* based actors
[00:00:46] <MaikKlein> ecr, hm yeah that is essentially what I am doing atm. 
[00:00:48] <graydon> cmr: thanks for asking me to write tests
[00:00:54] <graydon> naturally, they picked a few bugs out :)
[00:01:28] <smvv_> i'm working on a b-tree and i'm having a more theoretical problem: what's the median of a list of keys, when the type of a key is `K'. K uses the Ord and Eq traits for ordering and equality. But should T also use the trait for addition (e.g. median = keys[keys.len() / 2] + ? 
[00:01:31] <ecr> MaikKlein: we've thrown around a few ideas for how to construct actors on top of tasks. haven't come up with the clear answer yet though. good luck!
[00:01:33] <tikue> MaikKlein: correct me if I'm wrong, but what you are trying to do is signal the tasks rather than have them wait to receive messages?
[00:01:40] <graydon> self-admonishment time: I never write enough tests _or_ docs. please everyone remind me, I am trying to improve as a programmer.
[00:01:49] <toddaaro> MaikKlein: getting an actor library working should be pretty straightforward
[00:01:55] <ecr> graydon: write your tests!
[00:01:55] <smvv_> median = (keys[keys.len() / 2] + keys[keys.len() / 2 - 1) / 2
[00:01:57] <graydon> like give me r- unless I add tests and docs etc. someday I will learn :)
[00:02:01] * ecr *cracks whip*
[00:02:08] <toddaaro> MaikKlein: the main construct you want is a channel that allows multiple senders, so you listen on that as your event loop
[00:02:19] <toddaaro> MaikKlein: and hand out references to it as your "address"
[00:03:18] <MaikKlein> toddaaro, give me a moment to process this :)
[00:03:26] *** Quits: mschifer (Adium@moz-BBE3ABD.mv.mozilla.com) (Quit: Leaving.)
[00:04:59] <doomlord_> does .each(||...) exist for vectors
[00:05:07] <strcat> no
[00:05:20] <MaikKlein> doomlord_, .iter().advance
[00:05:23] <tikue> MaikKlein: afaik, what you want to do doesn't currently have a standard library implementation in rust
[00:05:52] *** Quits: eatkinson (eatkinson@moz-BBE3ABD.mv.mozilla.com) (Quit: eatkinson)
[00:05:54] <strcat> doomlord_: http://static.rust-lang.org/doc/tutorial-container.html#iterators
[00:06:04] <MaikKlein> tikue, I know I am trying to do this on my own, but I think I am too stupid.
[00:06:45] * strcat needs to document size_hint and DoubleEndedIterator
[00:07:32] <doomlord_> ok thanks
[00:08:39] <MaikKlein> toddaaro, ok lets say I have an actor doing stuff.,but sth came up and I want it to stop. So I send a message to it like "let chan.send(Stop);" How would it know that it should stop? I mean it can't do sth and listening to a message at the same time or can it?
[00:08:42] <doomlord_> is there a reason for not making a helper function .each   for the simple case iter().advance; did i hear 'workarounds'
[00:08:54] <doomlord_> (iter().advance does what i want though)
[00:08:59] <strcat> doomlord_: the tutorial explains that
[00:09:05] <strcat> the for loop needs to be updated
[00:09:19] *** Quits: santiago (santiago@moz-F2B734D2.c3-0.sbo-ubr1.sbo.ma.cable.rcn.com) (Ping timeout)
[00:09:26] *** Quits: pnathan (Adium@B9840254.2CD8A5F8.477B877D.IP) (Quit: Leaving.)
[00:09:27] <strcat> I removed almost everything using the old for loop to make way for it
[00:09:28] *** Joins: maxli (maxli@F2D29657.F60B0462.67AC9B1.IP)
[00:09:41] <strcat> .advance can become a no-op to transition, if the syntax stays the same
[00:09:52] <doomlord_> ok
[00:10:05] *** Quits: maxli (maxli@F2D29657.F60B0462.67AC9B1.IP) (Quit: Leaving.)
[00:10:16] <tikue> MaikKlein: you're not stupid. I don't think rust currently provides an easy way to do what you're trying to do.
[00:10:22] <toddaaro> MaikKlein: what is sth in this case?
[00:10:35] <MaikKlein> toddaaro, atm I do it like this loop { check_for_messages(); do_stuff();} 
[00:10:45] <toddaaro> MaikKlein: ah ok
[00:10:49] <MaikKlein> toddaaro, for example a long calculation
[00:11:01] <toddaaro> MaikKlein: so this isn't quite the actor model, this is harder
[00:11:22] <tikue> MaikKlein: the problem of course being that if you're doing something time-consuming, you won't hear the message
[00:11:33] <tikue> causing you to do too much work or probably many other potential pitfalls
[00:11:34] <MaikKlein> tikue, yeah
[00:12:17] <glinscott> is there a nice way to dump the unoptimized IR?
[00:12:27] <strcat> glinscott: rustc -S --emit-llvm
[00:12:34] <glinscott> strcat: awesome, thanks
[00:12:39] <strcat> without -S it makes bytecode
[00:13:02] *** Joins: santiago (santiago@moz-F2B734D2.c3-0.sbo-ubr1.sbo.ma.cable.rcn.com)
[00:13:56] *** Joins: erickt (erickt@8C9ECD8F.3A598286.F12515B4.IP)
[00:14:06] <tikue> MaikKlein: there isn't anything in rust that provides that functionality. I bet that will change at some point. There are ways you could implement it yourselfâ€¦perhaps you could research good ways to do this and make a patch :D
[00:14:29] <MaikKlein> tikue, yeah that's essentially what I am trying to do :)
[00:14:46] <strcat> I don't think you can ever safely interrupt arbitrary code
[00:15:05] <MaikKlein> tikue, I think I need sth that controls the task via reference. like ActorController.emergency_stop();
[00:15:32] <tikue> yeah I think you'll have to use unsafe code
[00:15:40] <toddaaro> MaikKlein: you can play a few tricks with sets of tasks and linked failure to get this
[00:15:44] <toddaaro> MaikKlein: but they aren't pretty
[00:15:45] <strcat> glinscott: and clang has -S -emit-llvm if you want to compare
[00:15:58] * pcwalton is sad that https://github.com/mozilla/rust/pull/7677 bounced
[00:16:31] <acrichto> nooo, I'll try to push that through later tonight
[00:16:31] <toddaaro> MaikKlein: basic idea is having your work in one task that is linked to a "listener" task, so you can send a message to the listener killing it (because it is listening) and the linked-failure system will then kill the worker
[00:16:41] *** Quits: erickt (erickt@8C9ECD8F.3A598286.F12515B4.IP) (Ping timeout)
[00:16:43] <MaikKlein> toddaaro, well yeah if I want to kill it. But maybe it should just stop the calculation and do sth different, I think I have to do some brainstorming
[00:17:24] <pcwalton> that and IO look like the remaining unnecessary uses of @ in libstd
[00:17:34] <pcwalton> IO is blocked on disk IO for newsched
[00:17:47] <toddaaro> MaikKlein: I'll warn you that the runtime code is also going to be replaced very soon, but working at your level (above spawn) you should be mostly fine
[00:18:34] *** Joins: tjc (tjc@moz-2FE771F5.tmodns.net)
[00:18:34] *** ChanServ sets mode: +o tjc
[00:18:36] <MaikKlein> toddaaro, yeah I want to try it at a higher level first. I am pretty sure it is possible somehow
[00:18:36] *** Joins: jgilbert_ (jgilbert@moz-7B0110AD.mv.mozilla.com)
[00:19:01] *** Quits: jgilbert (jgilbert@moz-7B0110AD.mv.mozilla.com) (Ping timeout)
[00:19:04] <toddaaro> MaikKlein: good luck with your efforts!
[00:19:14] <MaikKlein> toddaaro, thanks :)
[00:19:39] *** Joins: maxli (maxli@F2D29657.F60B0462.67AC9B1.IP)
[00:19:40] <aatch> toddaaro, you an intern? (Just curious)
[00:19:48] <pcwalton> yes
[00:19:57] *** Joins: bat (jgilbert@moz-BBE3ABD.mv.mozilla.com)
[00:20:13] <bblum> MaikKlein: i think the use case of killing a running child at any point is compelling enough to have a convenience wrapper for it
[00:20:15] *** Quits: tjc (tjc@moz-2FE771F5.tmodns.net) (Ping timeout)
[00:20:19] *** Quits: jgilbert_ (jgilbert@moz-7B0110AD.mv.mozilla.com) (Ping timeout)
[00:20:22] * aatch pays attention sometimes
[00:20:30] <toddaaro> aatch: yea, working on the runtime this summer
[00:20:32] *** Joins: cubic_ (cubic@moz-FE5AD6C7.mc.videotron.ca)
[00:21:09] *** Quits: cubic (cubic@moz-FE5AD6C7.mc.videotron.ca) (Ping timeout)
[00:21:35] *** Joins: vilonis (jared@moz-EE5D17ED.ph.ph.cox.net)
[00:22:06] <ChrisMorgan> What niggles do people still have with anything Rust-related in Vim? Anything they'd like to see?
[00:23:01] <Eridius> ChrisMorgan: I have the surround plugin installed, and whenever I type a lifetime, e.g. 'a, it tries to insert a close quote, e.g. 'a'.
[00:23:05] <acrichto> ChrisMorgan: does it still coalesce => and friends to utf8 characters?
[00:23:10] <Eridius> I don't know if there's a good way to disable that based on context though
[00:23:15] *** Quits: graydon (Adium@A5087023.2354C43D.D8E68FF6.IP) (Quit: Leaving.)
[00:23:15] <Eridius> acrichto: you can turn that on with a var
[00:23:24] <acrichto> yay! just wanted to make sure that was a thing
[00:23:26] <Eridius> let g:rust_conceal=1
[00:23:39] <strcat> ChrisMorgan: makeprg/errorformat
[00:23:43] <Eridius> at least, you could as of the vim syntax from a couple weeks ago. I haven't checked if that's changed
[00:23:50] <ChrisMorgan> No, that hasn't changed
[00:23:50] <tikue> rusti: let o=|o|o;o('o')
[00:23:51] -rusti- 'o'
[00:23:52] <strcat> so you can :make and have it jump to an error with quickfix
[00:23:53] <acrichto> Eridius: thanks!
[00:24:10] <ChrisMorgan> Eridius: I never liked an automatic closing quote thing so I've never done it myself; what're you using for it?
[00:24:19] <strcat> dunno if rust's output is similar enough to gcc for the default errorformat to work
[00:24:22] <strcat> haven't tried :)
[00:24:33] <Eridius> ChrisMorgan: looks like it's called delimitMate
[00:24:42] <tikue> rusti: let o=|o|o;o(o)
[00:24:43] -rusti- more than 5 lines of output, pastebinned: http://sprunge.us/hWIV
[00:24:45] <Eridius> it is syntax-aware, so it won't insert the close in e.g. comments
[00:24:57] *** Joins: eatkinson (eatkinson@moz-BBE3ABD.mv.mozilla.com)
[00:24:59] <Eridius> hopefully you can make use of that somehow
[00:25:06] <ChrisMorgan> strcat: doubt it. I can have at it. Difficulty is that people may not want to use rustc, they may want to use make
[00:25:09] *** Joins: tjc (tjc@51D6B60C.F9DF2FD8.E9463AEB.IP)
[00:25:09] *** ChanServ sets mode: +o tjc
[00:25:27] <strcat> ChrisMorgan: true
[00:25:50] <strcat> I wish make had extensible default rules
[00:25:51] *** Quits: maxli (maxli@F2D29657.F60B0462.67AC9B1.IP) (Quit: Leaving.)
[00:26:00] <ChrisMorgan> But that's not too hard to conquer. Variable check or `Makefile` file check.
[00:26:06] <_Vi> Is "Segmentation fault" from rusti a normal thing (i.e. rusti is too early alpha to expect normal work)?
[00:26:08] <strcat> you can 'make foo' and it will look for foo.c and foo.cc without a Makefile in the dir
[00:26:14] <strcat> if only it could be extended to new files
[00:26:25] <acrichto> _Vi: what caused the segfault?
[00:26:46] <_Vi> acrichto, Typing "let mut a = 4;" into it.
[00:26:51] <ChrisMorgan> strcat: `%: %.rs` \n `	$(RUSTC) $(RUSTFLAGS) $< -o $@`
[00:26:58] <smvv_> ChrisMorgan: is it possible to publish the vim file in a separate git repo from mozilla/rust? that makes it easier to use with Vundle.
[00:27:01] *** Quits: olleharstedt (Thunderbir@moz-80D8890F.ias.bredband.telia.com) (Ping timeout)
[00:27:06] <strcat> ChrisMorgan: yeah but you can't teach actual make about it afaik
[00:27:08] <_Vi> Previously when I tried "rusti" it just "Segmentation faulted" on any input.
[00:27:11] * MaikKlein light bulb exploded
[00:27:14] <acrichto> _Vi: oh dear that isn't good at all, feel fre to open an issue
[00:27:17] <strcat> ChrisMorgan: you'd need Makefiles with that all over ;p
[00:27:48] <acrichto> _Vi: sadly rusti is waiting on an LLVM upgrade to get more stable, there's apparently a lot of JIT fixes in llvm 3.3 which we're not using just yet
[00:27:48] <strcat> oh well
[00:27:56] <Eridius> rusti segfaults when I give it an invalid input, because task::try doesn't work on my system :/
[00:27:58] <_Vi> acrichto, What complicated input "rusti" expected to handle well? Is rusti works bad only for me or for everyone?
[00:27:58] <strcat> acrichto: we're not on 3.3 yet?
[00:28:08] <ChrisMorgan> smvv_: ask others about that; I'm just working with it in its current location. Seems a reasonable request to me, main repository could then have a suprepo if desired.
[00:28:13] <acrichto> strcat: no :( the pull request bounced with stack clobbering that I couldn't track down
[00:28:18] <strcat> acrichto: ah
[00:28:22] <ChrisMorgan> *submodule
[00:28:41] <acrichto> _Vi: rusti should be able to handle pretty much everything other than concurrency (task::spawn would result in badness)
[00:28:52] <_Vi> When I just type garbage into rusti it fails nicely.
[00:29:04] <MaikKlein> one question, using ARC means sharing memory right? (no move)
[00:29:04] <acrichto> _Vi: although it's unstable with LLVM changes
[00:29:21] <_Vi> Opening an issue.
[00:29:22] <bblum> MaikKlein: yes
[00:29:31] <acrichto> _Vi: take a look at the tests in src/librusti/rusti.rs -- they're all supposed to work, but they're disabled because of flakiness across various platforms
[00:29:53] <_Vi> acrichto, How to start the test?
[00:30:12] <smvv_> ChrisMorgan: it is already done by `wting', but not as up-to-date as vim file in the main repo https://github.com/wting/rust.vim
[00:30:20] <MaikKlein> bblum, is it forced to be immutable?
[00:30:22] <strcat> MaikKlein: well they still move, but they have shared ownership and are sendable
[00:30:40] <bblum> MaikKlein: naturally
[00:30:48] <acrichto> _Vi: you'd have to modify the code to run them
[00:30:49] <ChrisMorgan> cmr: "I find that nested match don't work well." â€” Care to give an example?
[00:31:15] <_Vi> acrichto, Can I just quickly run that one test without waiting for lengthy compilations?
[00:31:22] <MaikKlein> strcat, so if I want to share a vector, could I modify the vector?
[00:31:25] <acrichto> _Vi: sadly no
[00:31:36] <strcat> MaikKlein: with the read-write ones, yes
[00:31:46] <acrichto> _Vi: although you could try typing it into rusti. If local declarations aren't working then I doubt anything would work. I'll investigate this tonight
[00:31:49] <strcat> it locks the ARC to read and write, and uses atomic refcounting
[00:31:49] <_Vi> acrichto, "you'd have to modify the code to run them" -> Maybe I can comment out everything else?
[00:32:13] <_Vi> acrichto, Just "2+2" works in rusti.
[00:32:37] <MaikKlein> strcat, thanks!
[00:32:57] *** Quits: true_droid (Adium@moz-123FD9B8.beck.volia.net) (Quit: Leaving.)
[00:33:17] <acrichto> _Vi: local declarations have a *very* different codepath than just normal expressions, so that's why "let a = 3;" would fail while "3" would succeed
[00:33:50] <_Vi> acrichto, Using "fn qqq() {}" and "qqq()" also works.
[00:34:31] <acrichto> _Vi: oh by "local declaration" I mean something via 'let', "fn a() {}" is actually an item and those are also a very different codepath
[00:34:56] <Eridius> cmr: not sure if github notifies you, but I just wrote some replies to your comments on my commits
[00:34:57] <ChrisMorgan> Eridius: as far as delimitMate is concerned, I guess you just want it not to do it inside <>. I'm heading off for half an hour now, I'll tackle it when I get back
[00:35:08] <Eridius> ChrisMorgan: well I also want to not do it after &
[00:36:45] <_Vi> "fn qqq() -> int { let mut q = 3; q}", then "qqq()" also works fine.
[00:37:29] *** Quits: carllerche (carllerche@6B070D22.7E6A0813.1428D117.IP) (Quit: carllerche)
[00:37:37] *** kimundi is now known as zz_kimundi
[00:39:24] <bblum> ecr: http://pastebin.mozilla.org/2622024
[00:39:37] <pcwalton> reddit /r/rust has almost as many members as /r/nodejs
[00:40:21] *** Quits: hjr3 (hradtke@1A0AE795.28A5F6C3.A2D40ED2.IP) (Quit: My MacBook has gone to sleep. ZZZzzzâ€¦)
[00:40:34] <jack> pcwalton: not that anyone's counting :)
[00:40:40] <_Vi> issues/7732
[00:40:41] <Jeaye> heh
[00:40:51] *** Joins: jasom_ (aidenn@moz-5F6FC7B3.sb.sd.cox.net)
[00:42:24] *** Quits: brendan (brendaneic@moz-BBE3ABD.mv.mozilla.com) (Quit: brendan)
[00:42:27] *** Quits: eholk (eholk@moz-ACB08D8D.uconnect.utah.edu) (Quit: eholk)
[00:42:35] <jasom_> so, internally, str is a vector of utf8 codepoints?
[00:42:43] <aatch> jasom_, correct
[00:42:46] <Eridius> jasom_: a null-terminated vector, yes
[00:43:00] * jasom_ is trying to figure out how to efficiently find the first non-matching character between two strings
[00:43:25] <Eridius> get the byte iterators for both and walk them in lockstep?
[00:43:27] <strcat> Eridius: \0 is being removed from the end though
[00:43:40] <Eridius> strcat: yeah, but it's still there atm right?
[00:43:41] *** Joins: mreedell (mreedell@moz-9950CA28.hsd1.pa.comcast.net)
[00:43:44] <strcat> Eridius: yeah
[00:43:52] <jasom_> Eridius: that's what I was thinking, I'd have to use byte iterators and keep track of utf8 character beginning markers
[00:44:01] <tikue> jasom_: for string1.iter().zip(string2.iter()) |char1, char2| { equality check }
[00:44:20] <strcat> and throw in an enumerate to get an index in the loop
[00:44:30] <tikue> ^ right
[00:44:34] <Eridius> rusti: let x = ~[0x68, 0x65, 0x6c, 0x6c, 0x6f, 0]; let s : ~str = unsafe { std::cast::transmute(x) }; s
[00:44:36] -rusti- line longer than 150 columns, pastebinned: http://sprunge.us/cLBD
[00:45:23] <Eridius> rusti: let x : ~[u8] = ~[0x68, 0x65, 0x6c, 0x6c, 0x6f, 0]; let s : ~str = unsafe { std::cast::transmute(x) }; s
[00:45:23] *** Quits: FrozenCow (FrozenCow@moz-B2DF4929.chello.nl) (Connection reset by peer)
[00:45:24] -rusti- ~"hello"
[00:45:26] <Eridius> that's better
[00:45:37] *** Joins: FrozenCow (FrozenCow@moz-B2DF4929.chello.nl)
[00:45:44] <strcat> rusti: let xs = [1, 2, 3, 0, 5]; let ys = [1, 2, 3, 4, 5]; for xs.iter().enumerate().zip(ys.iter()) |((i, &x), &y)| { if x != y { println(i.to_str()); break } }
[00:45:46] -rusti- more than 5 lines of output, pastebinned: http://sprunge.us/GPbJ
[00:45:59] <strcat> rusti: let xs = [1, 2, 3, 0, 5]; let ys = [1, 2, 3, 4, 5]; for xs.iter().enumerate().zip(ys.iter()).advance |((i, &x), &y)| { if x != y { println(i.to_str()); break } }
[00:46:00] -rusti- 3
[00:46:00] -rusti- ()
[00:46:09] * strcat wants the new for loop now ;p
[00:46:12] <Eridius> strcat: why are you enumerating before zip instead of after? That just looks ugly
[00:46:21] <strcat> Eridius: dunno ;]
[00:46:28] <tikue> rusti: let (str1, str2) = ~
[00:46:29] -rusti- <anon>:8:4: 8:5 error: unexpected token: `}`
[00:46:29] -rusti- <anon>:8     };
[00:46:29] -rusti-              ^
[00:46:29] -rusti- application terminated with error code 101
[00:47:47] <Eridius> in an enum definition, if I put a doc comment at the end of a line, does that associate it with the variant on that same line?
[00:47:47] <tikue> rusti: let (str1, str2) = (~"str1", ~"str2"); for str1.iter().zip(str2.iter()).enumerate() |(i, (char1, char2))| {if char1 != char2 { return i; }}
[00:47:49] -rusti- more than 5 lines of output, pastebinned: http://sprunge.us/ECUg
[00:47:58] <Eridius> e.g. Enum Foo {\nBar, /// This is Bar\nBaz, /// This is Baz\n}
[00:48:01] <jasom_> Is there a good introduction to composing iterators somewhere?
[00:48:04] <strcat> Eridius: you have to put it above the variant
[00:48:09] <tikue> rusti: let (str1, str2) = (~"str1", ~"str2"); for str1.iter().zip(str2.iter()).enumerate().advance |(i, (char1, char2))| {if char1 != char2 { return i; }}
[00:48:10] -rusti- line longer than 150 columns, pastebinned: http://sprunge.us/Mjhe
[00:48:11] <Eridius> strcat: what happens if I put it after?
[00:48:16] <strcat> jasom_: http://static.rust-lang.org/doc/tutorial-container.html#iterators there's a bit here
[00:48:22] <Eridius> as in, on the same line
[00:48:27] <strcat> jasom_: I'm actually working on extending the tutorial a bit atm
[00:48:34] <bstrie> jasom_: not particularly... as ever, the best resource is likely to be the official test cases
[00:48:41] *** Joins: bnicholson (bnicholson@moz-E98974C1.hsd1.ca.comcast.net)
[00:48:42] <strcat> Eridius: it'll associate with the next one
[00:48:54] <Eridius> strcat: blah. consider that a bug to fix in the rustdoc rewrite ;)
[00:48:54] <strcat> Eridius: /// goes before an item
[00:48:55] <tikue> rusti: let (str1, str2) = (~"str1", ~"str2"); for str1.iter().zip(str2.iter()).enumerate().advance |(i, (char1, char2))| {if char1 != char2 { println(fmt!("%u", i)); }}
[00:48:55] *** Quits: RMF (RMF@moz-4C4EB011.dsl.telepac.pt) (Ping timeout)
[00:48:56] -rusti- 3
[00:48:56] -rusti- ()
[00:48:59] <strcat> Eridius: I don't ;p
[00:49:28] <strcat> Eridius: it would be weird if putting it after a comma attached to the one before it
[00:49:36] <strcat> when everywhere else it attaches to the one after it
[00:49:44] *** Joins: ghrust (ghrust@1E8607E8.6A2AE50.F3114085.IP)
[00:49:44] <ghrust> 01[13rust01] 15bors merged 06auto into 06master: 02http://git.io/-dqZNQ
[00:49:44] *** Parts: ghrust (ghrust@1E8607E8.6A2AE50.F3114085.IP) ()
[00:49:46] <Eridius> strcat: in no universe is an author going to expect `Foo, /// this is foo` to put "this is foo" on the following variant
[00:49:48] *** Joins: RMF (RMF@moz-4C4EB011.dsl.telepac.pt)
[00:49:58] <strcat> why?
[00:50:02] <Eridius> ok I suppose if I had "Foo, Bar" on the same line then things get more complicated
[00:50:02] <strcat> what else would you expect?
[00:50:10] <Eridius> visually, it's clearly documenting the element that it's on the same line as
[00:50:25] <strcat> the /// syntax is clearly defined as being before the item it documents though
[00:50:37] <Eridius> strcat: but it's also always expected to be the first thing on the line
[00:50:47] <Eridius> if it's _not_ the first thing on the line, it should apply to whatever's on the same line
[00:50:54] <strcat> so maybe it should be forbidden in that position
[00:51:12] <benh> but whitespace invariance :(
[00:51:26] <strcat> rusti: let x = 1; // x
[00:51:27] -rusti- <anon>:7:13: 7:14 warning: unused variable: `x` [-W unused-variable (default)]
[00:51:27] -rusti- <anon>:7          let x = 1; // x
[00:51:27] -rusti-                       ^
[00:51:28] -rusti- ()
[00:51:34] *** Quits: santiago (santiago@moz-F2B734D2.c3-0.sbo-ubr1.sbo.ma.cable.rcn.com) (Ping timeout)
[00:51:36] <strcat> isn't that already making newlines significant?
[00:51:39] <strcat> ;p
[00:52:12] <Eridius> strcat: I feel like Haskell already does what I'm suggesting here, but I don't have any proof
[00:52:44] *** Joins: ghrust (ghrust@FD7BC443.6A2AE50.F3114085.IP)
[00:52:44] <ghrust> 01[13rust01] 15bors pushed 6 new commits to 06auto: 02http://git.io/4W22bw
[00:52:44] <ghrust> 13rust/06auto 147429e7a 15Niko Matsakis: rustc: Add new graph library, based on code from region_infernece
[00:52:44] <ghrust> 13rust/06auto 14e706590 15Niko Matsakis: Port region inference code to use new graph
[00:52:45] <ghrust> 13rust/06auto 14a2fbe4d 15Niko Matsakis: Construct the graph only when it is needed to report errors.
[00:52:47] *** Parts: ghrust (ghrust@FD7BC443.6A2AE50.F3114085.IP) ()
[00:53:01] <Eridius> but I've got an enum with 10 variants, and I don't really want to expand it out to 20 lines just for some short 3-word documentat
[00:53:04] <Eridius> ion
[00:53:13] <jclements> anyone feel like telling me what function returns the size of a HashMap?
[00:53:20] <engla> .len()
[00:53:21] <strcat> .len()
[00:53:21] <Eridius> jclements: len?
[00:53:22] <aatch> We have syntax for "attach to previous thing"
[00:53:29] <aatch> /! This
[00:53:30] <benh> No we don't?
[00:53:32] <jclements> dang! that was awesome!
[00:53:34] <aatch>  //! This
[00:53:38] <benh> //! attaches to enclosing thing, I thought?
[00:53:44] <engla> jclements: trait Container :)
[00:53:53] <aatch> benh, maybe.
[00:54:04] <jclements> engla: I hadn't followed the trait chains up. Nice to see that.
[00:54:29] *** Quits: jensnockert (jensnocker@moz-C5F27039.cust.bredband2.com) (Input/output error)
[00:54:32] <MaikKlein> rusti: [1,2,3,4].iter().advance |x| {x}
[00:54:34] -rusti- more than 5 lines of output, pastebinned: http://sprunge.us/RGDS
[00:54:40] <MaikKlein> rusti: [1,2,3,4].iter().advance |x| {x};
[00:54:41] -rusti- more than 5 lines of output, pastebinned: http://sprunge.us/dGHN
[00:54:44] <Eridius> MaikKlein: you're missing `for`
[00:54:57] <MaikKlein> Eridius, ah right :D
[00:55:03] <MaikKlein> rusti: for [1,2,3,4].iter().advance |x| {x};
[00:55:04] -rusti- <anon>:7:42: 7:45 error: A for-loop body must return (), but it returns <V76> here. Perhaps you meant to write a `do`-block?
[00:55:04] -rusti- <anon>:7          for [1,2,3,4].iter().advance |x| {x};
[00:55:04] -rusti-                                                    ^~~
[00:55:04] -rusti- error: aborting due to previous error
[00:55:04] -rusti- application terminated with error code 101
[00:55:04] <strcat> and an rvalue won't borrowck there yet
[00:56:46] *** Quits: posco (oscarboyki@636AC086.5999CED5.71743E61.IP) (Quit: posco)
[00:57:14] *** Joins: santiago (santiago@moz-F2B734D2.c3-0.sbo-ubr1.sbo.ma.cable.rcn.com)
[01:00:42] *** Quits: smvv_ (sander@moz-BAEA8EB2.dynamic.upc.nl) (Ping timeout)
[01:00:48] *** Quits: jclements (jclements@moz-BBE3ABD.mv.mozilla.com) (Quit: jclements)
[01:01:19] *** Quits: Jesse (jruderman@moz-BBE3ABD.mv.mozilla.com) (Ping timeout)
[01:01:39] *** Joins: smvv_ (sander@moz-BAEA8EB2.dynamic.upc.nl)
[01:01:48] <MaikKlein> hm I think I broke rust https://gist.github.com/MaikKlein/5980608
[01:02:02] <MaikKlein> any idea why this doesn't work?
[01:02:09] <MaikKlein> *it compiles*
[01:03:12] <Eridius> what does it do?
[01:03:27] <MaikKlein> it runs forever
[01:03:34] <Eridius> also, where's stream() come from?
[01:03:45] <Eridius> is that in the prelude?
[01:03:57] <MaikKlein> from task
[01:04:24] <bstrie> Eridius: stream is in the prelude
[01:04:25] <Eridius> looks like it's std::comm::stream()
[01:04:27] <MaikKlein> its basically this example http://static.rust-lang.org/doc/extra/arc.html
[01:04:35] *** bat is now known as jgilbert
[01:04:36] <MaikKlein> just modified
[01:04:40] <Eridius> I've never used comm. I take it they have an infinite buffer?
[01:04:44] <Eridius> so you never block on sending?
[01:04:50] <Eridius> (unlike Go which has a fixed-size buffer)
[01:05:32] <Eridius> hrm the example MaikKlein linked still says `extern mod std`. That should probably be removed
[01:06:35] <MaikKlein> the problem is this line let local_foo_ref=shared_foo_ref.get();
[01:06:38] <MaikKlein> it runs forever
[01:07:02] <Eridius> MaikKlein: I just ran it and it terminated for me. although it never did print "Hello", it just printed the fmts
[01:07:50] <MaikKlein> Eridius, hm
[01:07:54] <MaikKlein> Eridius, do you use linux?
[01:08:01] <Eridius> OS X
[01:08:48] *** Joins: Jesse (jruderman@moz-BBE3ABD.mv.mozilla.com)
[01:08:52] <Eridius> looks like it never iterates naything
[01:08:53] <MaikKlein> does it print sth reasonable?
[01:09:04] <MaikKlein> with the fmt
[01:09:17] <Eridius> it prints &~[{}, {}]
[01:09:35] <Eridius> question: does rust wait for all tasks to finish before exiting, or does it shut down once the "main" task exits?
[01:09:42] *** Joins: pnathan (Adium@B9840254.2CD8A5F8.477B877D.IP)
[01:09:47] <Eridius> I'm wondering if each print yields from the task, and then the main task comes back to life, shuts down, and the child tasks never complete
[01:10:03] <MaikKlein> seems like it waits, at least on my machine
[01:10:20] <MaikKlein> maybe there is sth wrong
[01:10:32] *** Joins: jclements (jclements@moz-BBE3ABD.mv.mozilla.com)
[01:11:03] <Eridius> nope each task does complete
[01:11:17] *** Quits: jgilbert (jgilbert@moz-BBE3ABD.mv.mozilla.com) (Ping timeout)
[01:11:50] <Eridius> ok I can't even iterate foo_ref before the ARC comes into play
[01:12:12] <MaikKlein> its a bug
[01:12:17] <Eridius> theory: a nullary struct has no size, so a vector of nullary structs has no length, and the iterator (which uses pointer math) can't visit the elements
[01:12:22] <MaikKlein> it doesn't work with unit structs 
[01:13:00] <MaikKlein> that seems reasonable
[01:13:28] <Eridius> rusti: struct Foo; std::sys::size_of<Foo>()
[01:13:29] -rusti- <anon>:7:21: 7:42 error: binary operation < cannot be applied to type `extern "Rust" fn() -> uint`
[01:13:29] -rusti- <anon>:7          struct Foo; std::sys::size_of<Foo>()
[01:13:29] -rusti-                               ^~~~~~~~~~~~~~~~~~~~~
[01:13:29] -rusti- error: aborting due to previous error
[01:13:29] -rusti- application terminated with error code 101
[01:13:41] <Eridius> o_O
[01:13:47] <klutzy> rusti: struct Foo; std::sys::size_of::<Foo>()
[01:13:48] -rusti- 0
[01:13:52] <Eridius> yeah right, silly error
[01:13:58] <Eridius> strcat: VecIterator needs to special-case the 0 size
[01:14:00] <jclements> Holy Hashtable, Batman! Memoization reduces time taken by resolve from 500 seconds to â€¦ um â€¦ two.
[01:14:03] <MaikKlein> this works https://gist.github.com/MaikKlein/5980653
[01:14:03] <klutzy> i always make such error twice in a week :)
[01:14:09] <Eridius> jclements: sweet
[01:14:16] <strcat> Eridius: doesn't it already?
[01:14:20] <sp3d> jclements::ooo
[01:14:28] <Eridius> strcat: according to MaikKlein's code, it doesn't. I haven't checked the impl though
[01:14:32] *** Joins: Yurume (yurume@AC58A8CE.8A059B47.E313B915.IP)
[01:14:47] <strcat> what doesn't work about it?
[01:14:58] *** Quits: pnathan (Adium@B9840254.2CD8A5F8.477B877D.IP) (Ping timeout)
[01:14:59] <strcat> rusti: let xs = []; let mut it = xs.iter(); it.next()
[01:15:00] -rusti- <anon>:7:35: 7:37 error: internal compiler error: borrow-vec associated with bad sty: &ty_err
[01:15:00] -rusti- <anon>:7          let xs = []; let mut it = xs.iter(); it.next()
[01:15:00] -rusti-                                             ^~
[01:15:00] -rusti- application terminated with error code 101
[01:15:05] <MaikKlein> strcat, https://gist.github.com/MaikKlein/5980608
[01:15:21] *** Joins: erickt (erickt@8C9ECD8F.3A598286.F12515B4.IP)
[01:15:30] *** Joins: carllerche (carllerche@6B070D22.7E6A0813.1428D117.IP)
[01:15:40] <strcat> so what doesn't work? I can't tell from that
[01:15:42] <engla> it will never reach the end if it increments by size_of::<T>() == 0
[01:15:49] <strcat> ah
[01:16:09] <strcat> won't the end equal though?
[01:16:12] <strcat> be equal*
[01:16:23] <Eridius> rusti: struct Foo; let x = [Foo,Foo]; let p = std::vec::raw:to_ptr(x); println(fmt!("%?, %?", p, p.offset(x.len())))
[01:16:24] -rusti- <anon>:7:61: 7:62 error: expected `;` but found `:`
[01:16:24] -rusti- <anon>:7          struct Foo; let x = [Foo,Foo]; let p = std::vec::raw:to_ptr(x); println(fmt!("%?, %?", p, p.offset(x.len())))
[01:16:24] -rusti-                                                                       ^
[01:16:24] -rusti- application terminated with error code 101
[01:16:34] <Eridius> rusti: struct Foo; let x = [Foo,Foo]; let p = std::vec::raw::to_ptr(x); println(fmt!("%?, %?", p, p.offset(x.len())))
[01:16:35] -rusti- 140000433805840, 140000433805840
[01:16:35] -rusti- ()
[01:16:40] *** Joins: SiegeLord (sl@moz-CAF07B4C.hsd1.ma.comcast.net)
[01:16:40] <Eridius> that's the problem
[01:16:50] <strcat> it's supposed to stop when ptr == end
[01:16:55] *** Joins: infynyxx (infynyxx@DB780A29.749BA1D.DCC373F0.IP)
[01:16:57] <strcat> so it should stop right away?
[01:17:01] <Eridius> strcat: yes and ptr == end at all times for a vector of unit structs
[01:17:04] <Eridius> so it does stop right away
[01:17:06] <Eridius> which is wrong
[01:17:12] <strcat> oh I see what you mean
[01:17:22] <strcat> I should use non-zero size_of like vectors themselves
[01:17:34] *** Quits: etw (john@moz-B2936CAB.nyc.res.rr.com) (Quit: etw)
[01:17:36] <strcat> I'll add it to this PR I'm doing already
[01:17:40] <Eridius> well you don't use size_of, you use ptr.offset
[01:17:41] <engla> it should probably use nonzero_size_of in size_hint too, otherwise it will divide by zero
[01:18:03] <strcat> Eridius: that uses size_of though, I can just reimplement it for vectors
[01:18:04] *** Quits: erickt (erickt@8C9ECD8F.3A598286.F12515B4.IP) (Ping timeout)
[01:18:26] <Eridius> strcat: unless the vector's backing store uses nonzero_size_of, you're going to end up constring pointers that point off the end of the vector's memory
[01:18:36] <strcat> Eridius: it does use nonzero_size_of
[01:18:37] *** Quits: infynyxx (infynyxx@DB780A29.749BA1D.DCC373F0.IP) (Ping timeout)
[01:18:39] <Eridius> ah ok
[01:18:43] <strcat> and pointing off the end of the memory is fine
[01:18:45] *** Joins: Jesse_ (jruderman@moz-BBE3ABD.mv.mozilla.com)
[01:18:46] *** dherman-spec-spec-spec is now known as dherman-family
[01:18:53] *** Quits: Jesse (jruderman@moz-BBE3ABD.mv.mozilla.com) (Connection reset by peer)
[01:19:00] <Eridius> rusti: struct Foo; std::sys::size_of::<[Foo, ..3]>
[01:19:04] <strcat> pointers are bigger than the address space on any platform rust runs on
[01:19:09] <strcat> you can't point 1 *before* an array
[01:19:18] <strcat> but you can point 1 or more after
[01:19:19] <Eridius> rusti: struct Foo; std::sys::size_of::<[Foo, ..3]>()
[01:19:20] -rusti- 0
[01:19:22] <strcat> just can't deref
[01:19:59] <strcat> Eridius: size_of is wrong
[01:20:05] <Eridius> yeah apparently so
[01:20:09] <strcat> for ~[] and @[] at least
[01:20:17] <strcat> maybe [] is really broken
[01:20:42] <Eridius> rusti: let x = [[0, ..3], [0, ..3]]; (std::vec::raw::to_ptr(x[0]), std::vec::raw::to_ptr(x[1]))
[01:20:43] -rusti- ((0x1489f50 as *()), (0x1489f68 as *()))
[01:20:49] <Eridius> oh good, different pointers
[01:21:17] <Eridius> 24 bytes per array
[01:21:22] <Eridius> which is sensible for a 3-element int array
[01:21:35] <strcat> I mean for zero-size things
[01:21:37] <strcat> it's likely broken
[01:21:41] <Eridius> so yeah, size_of is definitely wrong for arrays of zero-size things
[01:21:45] <strcat> everything in vec.rs uses nonzero size
[01:23:06] <strcat> Eridius: well, not everything
[01:23:13] <strcat> lots of it is likely wrong for non-zero size things
[01:23:15] <strcat> it uses offset
[01:23:18] <strcat> in plenty of places
[01:25:15] * strcat shrugs
[01:25:23] <MaikKlein> where can I find the trait Freeze?
[01:25:54] <bblum> std/kind.srs
[01:25:55] *** Quits: Vert (quassel@8A83479C.391ACC8C.CAF63861.IP) (Connection reset by peer)
[01:25:57] <bblum> std/kinds.rs
[01:26:16] <MaikKlein> thanks
[01:27:18] <jclements> awesomeâ€¦ time to begin the make check rebase rebase make check rebase rebase dance!
[01:28:01] *** Quits: q66 (q66@6EE9DE40.46454B5D.33AABD5F.IP) (Quit: Leaving)
[01:28:44] <MaikKlein> what
[01:28:45] <MaikKlein> pub trait Freeze {
[01:28:45] <MaikKlein>     // empty.
[01:28:45] <MaikKlein> }
[01:29:08] <ecr> *magic*
[01:29:18] <strcat> #[lang] being the magic
[01:29:31] <MaikKlein> how do I implement Freeze?
[01:31:25] <MaikKlein> ups
[01:31:27] <MaikKlein> "They cannot be implemented by user code,"
[01:31:30] <MaikKlein> :X
[01:32:21] <ecr> immutable variables implement Freeze
[01:32:27] <ecr> mutable variables don't
[01:32:27] <strcat> not just immutable
[01:32:31] *** Quits: TD-Linux (TD-Linux@E338EB99.2B4F0AE0.A0A36CCE.IP) (Ping timeout)
[01:32:31] <strcat> mutable things implement it
[01:32:36] <ecr> wat
[01:32:47] *** Joins: fabiand_ (fabiand@moz-680BCD95.adsl.alicedsl.de)
[01:32:48] <ecr> clearly I don't fully grok it then
[01:32:48] <strcat> ecr: Freeze means a) immutable or b) inherited mutability
[01:32:58] <ecr> oh
[01:33:00] <strcat> the only things that aren't Freeze are Cell, @mut, RcMut, &mut and &const
[01:33:22] <strcat> and any type you make and put #[no_freeze] on (say, if you implement your own mutable shared memory type with unsafe code)
[01:33:27] *** Quits: fabiand (fabiand@moz-AFE1459A.adsl.alicedsl.de) (Ping timeout)
[01:33:32] <ecr> but anyway, you only use it for bounded generics (I think?)
[01:33:32] <bblum> strcat: RWARC is also not freeze
[01:33:35] <strcat> bblum: right
[01:33:40] * strcat put that annotation on it ;p
[01:34:04] <bblum> yes you did
[01:35:00] <strcat> ugh method resolve
[01:40:23] *** Quits: tjc (tjc@51D6B60C.F9DF2FD8.E9463AEB.IP) (Ping timeout)
[01:40:40] *** Quits: ecr (Thunderbir@moz-BBE3ABD.mv.mozilla.com) (Quit: ecr)
[01:41:07] *** Joins: TD-Linux (TD-Linux@E338EB99.2B4F0AE0.A0A36CCE.IP)
[01:42:12] *** Quits: FrozenCow (FrozenCow@moz-B2DF4929.chello.nl) (Quit: Leaving)
[01:44:11] *** Quits: eschweic (Adium@moz-BBE3ABD.mv.mozilla.com) (Quit: Leaving.)
[01:45:25] <strcat> rusti: struct Foo; let x = ~Foo;
[01:45:29] -rusti- <anon>:7:25: 7:26 warning: unused variable: `x` [-W unused-variable (default)]
[01:45:29] -rusti- <anon>:7          struct Foo; let x = ~Foo;
[01:45:29] -rusti-                                   ^
[01:45:29] -rusti- ()
[01:45:31] *** Quits: MaikKlein (maik@moz-7BAD3439.dip0.t-ipconnect.de) (Ping timeout)
[01:45:32] <strcat> rusti: struct Foo; let x = ~Foo; *x
[01:45:33] -rusti- {}
[01:46:00] <ChrisMorgan> Eridius: yes, I've very quickly decided that delimitMate would drive me absolutely crazy
[01:48:11] *** Joins: MaikKlein (maik@moz-7BAD3439.dip0.t-ipconnect.de)
[01:48:16] *** Joins: etw (john@moz-B2936CAB.nyc.res.rr.com)
[01:48:54] <Eridius> ChrisMorgan: hah. I use it for 2 main reasons: 1) I like how it closes the brace for me, and behaves correctly if I hit return between two braces, and 2) since it auto-closes strings, the syntax coloring of the rest of my file doesn't change constantly as I'm typing
[01:51:36] <doomlord_> hmm. i have a "conflicting implementation of trait" , in a situation where i defined an interface X, another trait Y, and a more concrete thing Z...  the intention was X for Y<T> {}  and X for Z<T> ... i'll paste some fragments to clarify
[01:52:10] <doomlord_> (oh i just had an idea to try to get around it..)
[01:52:25] <Eridius> doomlord_: impl<T, I: Y<T>> X for I
[01:52:40] <strcat> Eridius:             VecIterator{ptr: p, end: p.offset(self.len()),
[01:52:47] <strcat> so wait, what's wrong with this?
[01:53:03] <Eridius> strcat: p.offset(self.len()) == p when size_of::<element>() is 0
[01:53:03] <doomlord_> yes thats exactly what i've got - and it results in conflict with another impl..
[01:53:12] <strcat> Eridius: but that's correct
[01:53:18] <strcat> when ptr == end, it's supposed to return NOne
[01:53:21] <strcat> None *
[01:53:22] <Eridius> strcat: except this means that your iterator will never emit anything
[01:53:23] <doomlord_> i'm going to try and make another intermediate for I:Y<T>
[01:53:26] <Eridius> strcat: that's an implementation detail
[01:53:32] <Eridius> when it's _done iterating_ it should return None
[01:53:32] <strcat> *shrug*
[01:53:35] <Eridius> you're using ptr == end to mean done iterating
[01:53:41] <Eridius> but that's not actually true for unit types
[01:53:51] <strcat> ah I see what you mean now
[01:53:56] <strcat> I didn't really understand the issue
[01:54:26] *** Quits: LimeBurst (me@247D1419.D73964AC.27A8748.IP) (Ping timeout)
[01:54:59] <strcat> rusti: struct Foo; let xs = ~[Foo, Foo, Foo]; xs.slice(0, 1).to_owned()
[01:55:01] -rusti- ~[]
[01:55:05] <strcat> rusti: struct Foo; let xs = ~[Foo, Foo, Foo]; xs.slice(0, 2).to_owned()
[01:55:07] -rusti- ~[]
[01:55:11] <strcat> Eridius: none of it works
[01:55:18] <Eridius> strcat: :/
[01:55:29] <Eridius> I think we need a ptr::offset_nonzero() that uses sizeof_nonzero()
[01:55:42] <strcat> yep
[01:56:16] <Eridius> potential issue: borrowed pointers to distinct unit elements in an array will technically alias
[01:56:33] <Eridius> well, assuming they're based on the real pointer, and not the nonzero one
[01:56:34] <strcat> rusti: struct Foo; let xs = ~[Foo, Foo, Foo]; xs.slice(0, 1).to_owned().to_str()
[01:56:35] -rusti- <anon>:7:48: 8:5 error: failed to find an implementation of trait std::to_str::ToStr for main::Foo
[01:56:35] -rusti- <anon>:7          struct Foo; let xs = ~[Foo, Foo, Foo]; xs.slice(0, 1).to_owned().to_str()
[01:56:35] -rusti- <anon>:8     };
[01:56:35] -rusti- application terminated with error code 101
[01:56:41] <Eridius> because the nonzero version will increment the pointer past the actual data structure
[01:56:58] <MaikKlein> is line 34 concurrent? https://gist.github.com/MaikKlein/5980860
[01:57:09] <Eridius> rusti: struct Foo; let x = [Foo, Foo, Foo]; (&x[0] as *Foo, &x[1] as *Foo)
[01:57:10] -rusti- ((0x15baf78 as *()), (0x15baf78 as *()))
[01:57:14] <strcat> Eridius: aliasing doesn't matter
[01:57:16] <Eridius> yep, aliased pointesr. woo!
[01:57:25] *** Quits: tikue (tkuehn@moz-BBE3ABD.mv.mozilla.com) (Quit: tikue)
[01:57:27] <strcat> TBAA is based on memory dependencies, not actual pointer equality
[01:57:33] <Eridius> TBAA?
[01:57:39] <strcat> type-based alias analysis
[01:57:49] *** Joins: sankha93 (Instantbir@FD84119E.C0D45E01.EFB84E89.IP)
[01:57:53] <strcat> you're allowed to have pointers to invalid things or null
[01:57:56] <strcat> you just can't deref 
[01:58:01] <Eridius> anyway yeah I doubt that alised pointers to zero-size types will matter, but it's still kinda cute that this lets you have aliased pointers
[01:58:15] <Eridius> MaikKlein: what do you mean by "is this concurrent"?
[01:58:16] <aatch> Also, aliasing doesn't matter if their immutable pointers
[01:58:25] <aatch> they're*
[01:58:38] <Eridius> aatch: oh darn, good point. My joy has now been reduced
[01:59:00] <MaikKlein> Eridius, well is it executed on the main thread?
[01:59:16] <Eridius> MaikKlein: I suppose that depends on the scheduler that's being used
[01:59:50] <aatch> And while you can get two `&mut` to alias like that (in theory, not sure about in practice), what do you mutate a unit struct to?
[02:00:26] <Eridius> aatch: well yeah, you should never deref a pointer to a unit struct since there's no actual memory backing it, but w/e
[02:01:16] <Eridius> on a mostly unrelated note: Option is optimized for the case where it holds a pointer (is this limited to Option, or is this applied to any enum { Foo, Bar(T) }?)
[02:01:22] <aatch> Eridius, exactly. Still, it's a nice trick and a vaguely amusing edge case.
[02:01:31] <Eridius> any opinions on trying to optimize it for when it holds a value whose size is less than a word? (e.g. a u8)
[02:01:48] <aatch> Eridius, any enum like Option
[02:02:15] <aatch> rusti: std::sys::size_of::<Result<int,~int>>();
[02:02:16] -rusti- ()
[02:02:16] <Eridius> rusti: std::sys::size_of::<Option<u8>>()
[02:02:17] -rusti- 16
[02:02:22] <aatch> rusti: std::sys::size_of::<Result<int,~int>>()
[02:02:23] -rusti- 16
[02:02:24] *** Quits: carllerche (carllerche@6B070D22.7E6A0813.1428D117.IP) (Quit: carllerche)
[02:02:26] <Eridius> rusti: std::sys::size_of::<u8>()
[02:02:27] -rusti- 1
[02:02:27] <aatch> rusti: std::sys::size_of::<Result<(),~int>>()
[02:02:28] -rusti- 8
[02:02:33] <Eridius> 16 bytes for an Option<u8>. That's kinda nuts
[02:02:41] <Eridius> could make it 8 and just set the high bit
[02:02:48] <aatch> Eridius, because it uses alignment size
[02:03:13] <Eridius> rusti: std::sys::size_of::<[Option<u8>, ..2]>()
[02:03:13] -rusti- 32
[02:03:21] <Eridius> yep, a real 16 bytes per optional u8
[02:03:22] <benh> rusti: std::sys::size_of::<Option<Option<Option<Option<()>>>>>()
[02:03:23] -rusti- 32
[02:03:42] *** Joins: pnathan (vlion@moz-BDC3EE62.tukw.qwest.net)
[02:03:43] <Eridius> heck, could make it just use 2 bytes and set the high bit for u8, 4 bytes for a u16, 8 bytes for a u32 (assuming 64-bit architecture here)
[02:03:54] <strcat> Eridius: it's not a big issue
[02:04:02] <strcat> Eridius: it's because the discriminant is always the same size
[02:04:09] <strcat> it's reported and jld started fixing it
[02:04:16] *** Quits: mreedell (mreedell@moz-9950CA28.hsd1.pa.comcast.net) (Quit: Computer has gone to sleep.)
[02:04:21] <Eridius> strcat: I'm kinda worried about iterators of u8's
[02:04:29] <doomlord_> http://pastebin.com/2r6F5y7i <<< implementing traits over traits... too much abstraction on my part ?
[02:04:30] <strcat> Eridius: 2 bytes?
[02:04:33] <strcat> why?
[02:04:40] <Eridius> if I have a 1MB ~[u8] and I iterate over it, I'm pushing 16MB around
[02:05:00] <strcat> Eridius: first of all you won't be, because the Option is optimized out
[02:05:09] <doomlord_> (i get a conflict). This isn't the only way i could do all this, i'm just trying to see how far traits let me go in abstracting/layering things.
[02:05:10] <aatch> The layout of enums is deliberately left undefined to allow for optimizations
[02:05:15] <Eridius> strcat: it's removed completely?
[02:05:17] <strcat> Eridius: yes
[02:05:22] <Eridius> ok, that makes me feel a lot better
[02:05:24] *** Quits: bjz_ (brendanzab@B398BE78.F804C29E.D35A31DF.IP) (Connection reset by peer)
[02:05:24] *** Joins: bjz (brendanzab@B398BE78.F804C29E.D35A31DF.IP)
[02:05:37] <MaikKlein> someone here said RWARC is non freeze, but rustdocs says "Implementation for RWARC<T> where <T: Freeze + Send>"
[02:05:37] <strcat> Eridius: there are no next() calls or Options unless you do something weird
[02:05:46] *** Quits: zz_kimundi (kimundi@moz-E923C71.dip0.t-ipconnect.de) (Ping timeout)
[02:05:56] <strcat> Eridius: it optimizes to a loop with the end condition of the iterator
[02:05:58] <ChrisMorgan> Eridius: delimitMate is vaguely resisting my efforts to get it to act properly thus far; initial solution is to remove ' from delimitMate_quotes, so that it simply doesn't do single quotation marks: let b:delimitMate_quotes = '" `'
[02:06:03] <jld> strcat: At one point I even had patches that worked.
[02:06:14] <jld> strcat: But that was before type_.rs, and external iterators, and....
[02:06:23] <strcat> Eridius: anyway, it's intended to only make the discriminant as large as needed
[02:06:25] <strcat> jld: heh :)
[02:06:25] <bblum> MaikKlein: that means the T inside an RWARC has to be freeze, but RWARC itself is not freeze
[02:06:28] <Eridius> ChrisMorgan: hmm. I'll probably go down that route if there's no other option, but finding a solution that works in rust's syntax will make it work for everyone, not just me
[02:06:36] <bblum> MaikKlein: just like how if T is freeze, &mut T is not Freeze
[02:06:45] <strcat> Eridius: up to 256 variants -> 1 byte discriminant, is what's intended
[02:06:55] <strcat> and so on
[02:06:57] <ChrisMorgan> Eridius: I've got the idea, but it's just not working yet. Still trying.
[02:07:04] <strcat> it will mostly be 1-byte for everything
[02:07:07] <strcat> or sometimes 2
[02:07:20] <strcat> it does get aligned though
[02:07:27] <strcat> but we can make #[packed] worked on enums
[02:07:53] <aatch> (note that not even the parser has that many variants)
[02:08:13] <MaikKlein> bblum, if T is a vector, with RWARC I can change the vector right?
[02:08:19] <bblum> MaikKlein: that's right
[02:08:25] <MaikKlein> bblum, ok nice thanks
[02:08:47] <jld> I have vague ideas about making enums more interesting.
[02:08:55] <bblum> jld: what's that
[02:09:37] *** Joins: zz_kimundi (kimundi@moz-72E3BB53.dip0.t-ipconnect.de)
[02:10:04] *** zz_kimundi is now known as kimundi
[02:10:22] <strcat> jld: well I want to make char sound, so that means making it always 21-bit
[02:10:40] *** Quits: pnathan (vlion@moz-BDC3EE62.tukw.qwest.net) (Ping timeout)
[02:10:42] <ChrisMorgan> Eridius: eee... *really* don't like it now, it's messing with the undo list in some broken way, such that I can get its notion of the oldest state of a formerly-nonexistent file to have content in it :-/
[02:10:50] <strcat> so as long as you make the char discriminant zero, you could use that space
[02:11:08] <strcat> maybe there are other examples
[02:11:29] <strcat> we're the null ptr one on slices and library pointers
[02:11:31] <MaikKlein> how do I use RWARC? lets say I do "let  a = RWARC(somevec);" now I want to push '5' in the vector 
[02:11:33] <strcat> we're missing*
[02:11:56] <MaikKlein> dont know what blk: &fn(x: &mut T) -> U is :x
[02:11:57] <aatch> Pointer tagging is another possibility, though that varies in effectiveness.
[02:12:02] *** Quits: dsirenko (mitra@8E712A0.54C21BA0.9F317420.IP) (Ping timeout)
[02:12:10] <Eridius> ChrisMorgan: you triggered that? bleh. I'm not sure how to actually trigger that, since the author fixed most of the problems with the undo state
[02:12:12] <aatch> And might interact badly with GC
[02:13:10] <jld> strcat,bblum: I have vague ideas for an interface for finding a type's possible/impossible values.  (Like, such-and-such field must be within this range.)  Which lets Option<Option<Option<...()...>>> be i8.
[02:13:16] <ChrisMorgan> Eridius: open new file, enter (, [it fills in )], press Enter [) gets shifted to the next line], press Escape, press u. The ( you put in disappears, the ) it put in doesn't.
[02:13:28] <strcat> jld: borrows make it complicated though
[02:13:39] <Eridius> ChrisMorgan: you sure you have the latest version? Because that works just fine for me
[02:13:58] <Eridius> ChrisMorgan: commit ce1d05fac5188 back in November of 2011 fixed "Broken undo after <CR> expanded"
[02:14:14] <ChrisMorgan> Eridius: sure do, I just cloned the repository an hour ago.
[02:14:15] <strcat> like, bool has to be 1-bit, but you can't set the other bits to non-zero or a pointer to it will be wrong
[02:14:30] <strcat> so Option<bool> could be an i8, but it has to use a zero-tag for bool
[02:14:38] <jld> strcat: Right, but Option<bool> can have values 0, 1, 2.
[02:14:39] <ChrisMorgan> Vim 7.3.547, Ubuntu 13.04 64-bit
[02:14:47] <Eridius> ChrisMorgan: I'm not actually on the latest version myself, because of issue #133 (which the most recent commit actually claims to have fixed, but I haven't had the inclination to test yet), but I'd be surprised if he reintroduced the bug
[02:14:55] <jld> strcat: However, Either<bool,bool> can't be helped like that.
[02:14:59] <strcat> right
[02:15:08] <Eridius> ChrisMorgan: I'm on VIM 7.3 with patches 1-754
[02:15:21] <strcat> jld: bools are broken atm anyway :P
[02:15:25] <strcat> we should probably fix that
[02:15:37] <strcat> rusti: let b = 5 as bool; (b, b == true)
[02:15:38] -rusti- (true, false)
[02:15:42] <strcat> :D
[02:15:46] <bblum> hey everyone check this out
[02:15:49] <bblum> rusti: use extra::sort; use std::float; let mut vec = ~[float::NaN, 0.0f, 2.0f, float::NaN, 1.0f]; sort::quick_sort3(vec); vec
[02:15:50] -rusti- ~[0, NaN, 1, 2, NaN]
[02:16:13] <Eridius> bblum: NaN violates the total ordering requirement
[02:16:23] <Eridius> at least I assume quick_sort3 requires total order
[02:16:27] <Eridius> although NaN also violates partial order
[02:16:28] <strcat> there shouldn't be one though?
[02:16:46] <jld> strcat: Yeah, I heard about that.  Shades of `typedef uint8_t BOOL; BOOL b = flags & MACRO_THAT_IS_SECRETLY_0x200`.
[02:16:49] *** Joins: erickt (erickt@8C9ECD8F.3A598286.F12515B4.IP)
[02:16:56] <strcat> rusti: use extra::priority_queue::PriorityQueue; use std::float; let mut vec = ~[float::NaN, 0.0f, 2.0f, float::NaN, 1.0f]; PriorityQueue::from_vec(vec).to_sorted_vec()
[02:16:58] -rusti- line longer than 150 columns, pastebinned: http://sprunge.us/MBEJ
[02:17:00] <Eridius> rusti: let (a,b) = (float::NaN, float::NaN); (a < b, b < a)
[02:17:02] -rusti- more than 5 lines of output, pastebinned: http://sprunge.us/NPCO
[02:17:13] <Eridius> rusti: use std::float; let (a,b) = (float::NaN, float::NaN); (a < b, b < a)
[02:17:14] <strcat> rusti: use extra::priority_queue::PriorityQueue; use std::float; let vec = ~[float::NaN, 0.0f, 2.0f, float::NaN, 1.0f]; PriorityQueue::from_vec(vec).to_sorted_vec()
[02:17:15] -rusti- (false, false)
[02:17:15] -rusti- ~[0, NaN, 1, NaN, 2]
[02:17:17] <strcat> heh
[02:17:22] <Eridius> there we go. NaN doesn't support ordering, period
[02:17:25] *** Quits: josh (josh@moz-348C4790.hsd1.mn.comcast.net) (Quit: josh)
[02:17:33] *** Joins: infynyxx (infynyxx@DB780A29.749BA1D.DCC373F0.IP)
[02:17:35] <Eridius> rusti: std::float::Inf
[02:17:35] -rusti- <anon>:7:9: 7:24 error: unresolved name `std::float::Inf`.
[02:17:36] -rusti- <anon>:7          std::float::Inf
[02:17:36] -rusti-                   ^~~~~~~~~~~~~~~
[02:17:36] -rusti- error: aborting due to previous error
[02:17:36] -rusti- application terminated with error code 101
[02:17:38] <Eridius> pfft
[02:18:36] <strcat> 1.cmp(&2)
[02:18:39] <strcat> rusti: 1.cmp(&2)
[02:18:40] -rusti- more than 5 lines of output, pastebinned: http://sprunge.us/DVHc
[02:18:47] <strcat> rusti: 1.cmp(&2i)
[02:18:47] <Eridius> rusti: use std::float; use extra::sort; let mut vec = ~[float::infinity, 0.0f, 2.0f, float::infinity, 1.0f]; sort::quick_sort3(vec); vec
[02:18:48] -rusti- more than 5 lines of output, pastebinned: http://sprunge.us/ThYN
[02:18:48] -rusti- ~[0, 1, 2, inf, inf]
[02:19:15] *** Quits: infynyxx (infynyxx@DB780A29.749BA1D.DCC373F0.IP) (Ping timeout)
[02:19:31] <strcat> ugh floats
[02:19:43] *** Quits: erickt (erickt@8C9ECD8F.3A598286.F12515B4.IP) (Ping timeout)
[02:20:26] <Eridius> rusti: use std::float; use extra::sort; let mut vec = ~[float::infinity, 0.0f, 2.0f, float::neg_infinity, 1.0f]; sort::quick_sort3(vec); vec
[02:20:27] -rusti- ~[-inf, 0, 1, 2, inf]
[02:20:29] <Eridius> at least inf works well
[02:20:47] <Eridius> rusti: use std::float; float::NaN == float::NaN
[02:20:47] -rusti- false
[02:20:50] <Eridius> \o/
[02:21:21] <Eridius> does quick_sort3() use comparators other than <? It just occurred to me that a sort function that only uses < should in theory put all NaNs at the end
[02:21:28] <strcat> Prelude Data.List> sort [nan, 1, 3, 2, nan, 0, -11, nan]
[02:21:31] <strcat> [NaN,-11.0,0.0,NaN,1.0,2.0,3.0,NaN]
[02:21:32] <strcat> haskell
[02:21:34] * strcat shrugs
[02:21:48] <bblum> nice
[02:21:57] <aatch> It also depends on if it's a stable sort or not.
[02:21:58] *** Joins: tikue (tkuehn@moz-BBE3ABD.mv.mozilla.com)
[02:21:59] <strcat> Eridius: at least we have TotalOrd
[02:22:17] <pcwalton> grrrrrr, unused imports on deny
[02:22:20] <strcat> TreeMap won't break from NaNs ;p
[02:22:27] <pcwalton> we're as bad as Go now
[02:22:35] <strcat> pcwalton: it's only on in rustc
[02:22:41] <strcat> it's off by default
[02:22:42] <pcwalton> I know but that's what I work on ;)
[02:22:44] <strcat> heh
[02:24:25] <jclements> waitâ€¦ when did error text turn into nearly-invisible-light-gray?
[02:24:26] <pcwalton> also it's only on in stage1
[02:24:30] <mark_edward> is there a way to do unionn types in Rust?
[02:24:34] <pcwalton> which is awful because when you hit it you've already busted everything
[02:24:37] <bblum> mark_edward: enum
[02:24:44] <pcwalton> you've already built a busted toolchain that is
[02:24:48] <bblum> jclements: recently... i don't like it either
[02:24:54] <bblum> (recently == last day or 2)
[02:24:59] <pcwalton> it's *supposed* to be bright white
[02:25:04] <Eridius> ok my theory that NaN goes to the end is flawed, because if the NaN is on the right-hand side of the comparison then it would want to go left. Which explains why it gets randomly placed
[02:25:06] <doomlord_> from the error i have - conflicting implementation of a trait in my layered situation - is it a case where Rust would need to have both implementations registered, and pick the most specific ? (like with tempalte specializations)
[02:25:06] <pcwalton> but fails on a lot of terminals apparently
[02:25:07] <mark_edward> bblum: but if you wanted to make it out of already existing types, like the numerical ones]
[02:25:10] <Eridius> jclements: I have a fix for that
[02:25:18] <doomlord_> i could rework what i'm doing of course to not need such complex layering.
[02:25:20] <jclements> pcwaltonâ€¦ brightâ€¦ white? butâ€¦ 
[02:25:26] <Eridius> pcwalton: it's actually not
[02:25:31] <Eridius> pcwalton: it's supposed to be bold
[02:25:41] <bblum> mark_edward: such as...?
[02:25:45] <Eridius> which just happens to look like bright white to a lot of people using white-on-black terminals
[02:25:53] <pcwalton> ah
[02:25:59] *** Quits: vilonis (jared@moz-EE5D17ED.ph.ph.cox.net) (Ping timeout)
[02:26:05] <strcat> pcwalton: lots of terminals say they have 8 colors
[02:26:07] <strcat> when they have 256
[02:26:10] <strcat> 'tput colors'
[02:26:13] <Eridius> pcwalton: PR #7716 fixes it, but cmr had a few nits with it that I'm resolving
[02:26:26] *** Quits: bnicholson (bnicholson@moz-E98974C1.hsd1.ca.comcast.net) (Ping timeout)
[02:26:31] <mark_edward> bblum: like a union of all the primitive integer types here https://github.com/Neverlord/libcppa/blob/master/cppa/primitive_variant.hpp#L88-L103
[02:26:44] <strcat> but anyway the real problem is it forcing white
[02:26:46] <SiegeLord> On konsole it uses color 8 (intense), which is white in my case
[02:27:06] <bblum> mark_edward: do you want to be able to access multiple arms at once?
[02:27:16] <bblum> if so, no, that amounts to arbitrary type coercion
[02:27:26] <mark_edward> bblum: i don't think so
[02:27:44] <bblum> then just be like, enum thing { foo(i8), bar(i16), ... }
[02:29:18] <SiegeLord> These color things are really screaming for a configuration file for rustc
[02:31:57] <strcat> or just an env variable like `ls` uses
[02:31:59] <strcat> LS_COLORS
[02:32:04] <strcat> for per-filetype ones
[02:32:57] <strcat> well, per-glob-pattern I guess (+ the actual things from lstat)
[02:33:45] *** Quits: MaikKlein (maik@moz-7BAD3439.dip0.t-ipconnect.de) (Ping timeout)
[02:33:51] *** Quits: _Vi (vi@527C345F.497AA854.B16B3BE6.IP) (Ping timeout)
[02:34:15] *** Quits: dwhyte (dwhyte@ED9190FB.B72E355F.7BF4A4B0.IP) (Quit: Leaving.)
[02:34:29] *** Quits: jclements (jclements@moz-BBE3ABD.mv.mozilla.com) (Quit: jclements)
[02:34:30] *** Joins: alisdair (textual@moz-EBE9F394.bchsia.telus.net)
[02:34:56] <bblum> here's another thing about NaN
[02:34:58] <bblum> http://research.swtch.com/randhash
[02:35:06] <bblum> quadratic time blowup on hashtables using NaN as keys
[02:36:05] <klutzy> it's hilarious that the article is published on april 1
[02:36:07] <klutzy> :D
[02:36:50] *** Joins: scanlonman (scanlonman@moz-169BC238.hsd1.wa.comcast.net)
[02:37:26] <bblum> that is a good point, but i verified the quadratic time thing anyway
[02:37:50] *** Joins: _Vi (vi@527C345F.497AA854.B16B3BE6.IP)
[02:39:21] <Eridius> My updated PR that fixes the error messages is https://github.com/mozilla/rust/pull/7716
[02:39:32] <Eridius> makes them print in bold instead of bright white
[02:39:33] <klutzy> yes, i also think it is real problem. that's the amuzing part
[02:42:55] *** Quits: rusti (rusti@moz-54F7FD49.cpe.net.cable.rogers.com) (Ping timeout)
[02:42:55] *** Quits: strcat (strcat@moz-54F7FD49.cpe.net.cable.rogers.com) (Ping timeout)
[02:44:50] *** Quits: _Vi (vi@527C345F.497AA854.B16B3BE6.IP) (Ping timeout)
[02:47:20] <ChrisMorgan> Eridius: I think I'm giving up on delimitMate, at present at least, with the recommendation of: au FileType rust let b:delimitMate_quotes = '" `'
[02:47:28] *** Joins: _Vi (vi@527C345F.497AA854.B16B3BE6.IP)
[02:49:23] <Eridius> ChrisMorgan: oh well. Thanks for trying
[02:49:43] *** Joins: ghrust (ghrust@DE823A67.6A2AE50.F3114085.IP)
[02:49:43] <ghrust> 01[13rust01] 15bors merged 06auto into 06master: 02http://git.io/4W22bw
[02:49:43] *** Parts: ghrust (ghrust@DE823A67.6A2AE50.F3114085.IP) ()
[02:49:45] <ChrisMorgan> I should share what I tried, though:
[02:49:50] <Eridius> if I was willing to re-learn the vim syntax stuff (which I removed from my brain probably 8 years ago) I'd take a crack at it, but I don't really feel like damaging myself in that fashion
[02:50:12] <ChrisMorgan> syn match rustLifetimeCandidate display "\%(&\|<\s\@!\%(.*,\s*\)\?\)'\?"
[02:50:12] <ChrisMorgan> let b:delimitMate_excluded_regions = 'Comment,String,rustLifetimeCandidate'
[02:50:44] *** Quits: bytewise (bytewise@moz-649C630D.unitymediagroup.de) (Quit: Leaving)
[02:50:49] *** Joins: canin (quassel@moz-EC67E844.cpe.distributel.net)
[02:51:05] <ChrisMorgan> Actually, that's just made me realise two things.
[02:52:11] <Eridius> oh?
[02:52:21] *** Quits: sp3d (a@moz-49806493.dhcp.stls.mo.charter.com) (Ping timeout)
[02:52:38] *** Joins: ghrust (ghrust@1E8607E8.6A2AE50.F3114085.IP)
[02:52:39] <ghrust> 01[13rust01] 15bors pushed 0 new commits to 06auto: 02http://git.io/DVtNCA
[02:52:39] *** Parts: ghrust (ghrust@1E8607E8.6A2AE50.F3114085.IP) ()
[02:52:39] <canin> I'm looking for a 3D graphics engine in rust, or one wrapped pretty well in rust, anyone know of one?
[02:52:40] *** Joins: ghrust (ghrust@AC22872E.6A2AE50.F3114085.IP)
[02:52:40] <ghrust> 01[13rust01] 15bors pushed 9 new commits to 06auto: 02http://git.io/DCKVPg
[02:52:40] <ghrust> 13rust/06auto 14a89af1f 15Alex Crichton: Use purely an owned vector for storing TLS data
[02:52:40] <ghrust> 13rust/06auto 14692a22e 15Alex Crichton: Change the elements in the task-local map to be actual key-value pairs
[02:52:40] <ghrust> 13rust/06auto 145c3a2e7 15Alex Crichton: Change TLS to almost be able to contain owned types
[02:52:42] *** Parts: ghrust (ghrust@AC22872E.6A2AE50.F3114085.IP) ()
[02:52:56] <ChrisMorgan> (a) There is still hope, and something I can tryâ€”rustLifetimeCandidate was there a match rather than a region, and really a region makes more sense; and (b) the docs on the default value for delimitMate_excluded_regions are wrong: it claims it to be Comment,String, whereas in actual fact it's Comment.
[02:52:59] <Eridius> ChrisMorgan: looking through the source, I see where it reads b:_l_delimitMate_excluded_regions. I don't know what the _l_ is though
[02:53:10] <pcwalton> Rust is like the one language in which there are more 3D graphics engines than web frameworks
[02:53:17] <pcwalton> canin: look at Jeaye's q3
[02:53:19] <Eridius> vim
[02:53:20] <Eridius> oops
[02:53:39] <pcwalton> Eridius: thought you meant someone had written a 3D graphics engine in vim
[02:53:41] <pcwalton> that would be impressive
[02:53:53] <Eridius> haha
[02:53:57] <Eridius> bet someone's done it in emacs though
[02:53:58] <Jeaye> q3's written in Vim. <3
[02:54:12] <pcwalton> vimscript :P
[02:54:27] <Jeaye> ^_^
[02:54:47] <ChrisMorgan> Some call it viml. Not sure quite why.
[02:54:48] <Jeaye> pcwalton: It is interesting, the direction Rust is taking.
[02:54:54] <Jeaye> It makes me _very_ happy.
[02:56:09] <pcwalton> http://www.gnu.org/software/emacs/manual/html_node/calc/Three-Dimensional-Graphics.html
[02:56:15] <Eridius> ChrisMorgan: ok yeah, the docs for excluded_regions says it needs to specifically be a "region" and links the group-name docs
[02:57:00] <Jeaye> pcwalton: Of course.
[02:57:55] <Jeaye> Ctrl+x Alt+m Ctrl+Shift+3 enables 3D mode.
[02:58:35] *** Joins: lkuper (lkuper@moz-C0CD33ED.hsd1.in.comcast.net)
[02:58:59] <tikue> hey all, do we have bidirectional hashmaps?!
[02:59:24] <tikue> ._.
[02:59:29] <Eridius> ChrisMorgan: this might help: delimitMate experimentally inserts the character that's being tested for at the current location and then tests the current region again to see if it's forbidden
[02:59:36] <pcwalton> tikue: we do actually sorta, the interner
[02:59:51] <bblum> tikue: ._.
[02:59:56] <Eridius> ChrisMorgan: so if you could make a region that matches &'\w* then you could forbid that
[03:00:22] *** Joins: rusti (rusti@moz-54F7FD49.cpe.net.cable.rogers.com)
[03:00:23] <Eridius> and of course make the <'a, T, U, ...> into a region
[03:00:24] <tikue> pcwalton: is that exposed as a struct usable by end users anywhere in the rust libraries?
[03:00:30] <tikue> bblum: ._____.
[03:00:35] <bblum> tikue: nice one
[03:00:58] <pcwalton> tikue: it's only between strings and ints though
[03:01:03] <pcwalton> and I don't think it's in the rust libraries
[03:01:07] *** Joins: strcat (strcat@moz-54F7FD49.cpe.net.cable.rogers.com)
[03:01:21] <strcat> bblum: well we have TotalEq and hash tables could use it
[03:01:24] <tikue> pcwalton: hmm, I'm looking for int <--> int, but it wouldn't be hard to write myself 
[03:01:40] *** Quits: dimension (dimension@moz-4CCD79C5.dsl.dynamic.simnet.is) (Ping timeout)
[03:02:39] <canin> is there a rust repo for debian/ubuntu? 
[03:02:57] *** Joins: steven_is_false (user@moz-144077DE.bchsia.telus.net)
[03:03:10] <ChrisMorgan> canin: you mean a PPA?
[03:03:24] <Jeaye> package repo, not git repo, he means.
[03:03:31] <engla> strcat: if you have time, r? https://github.com/mozilla/rust/pull/7735
[03:03:32] <canin> ChrisMorgan: that, or a more general repo
[03:03:52] <Jeaye> I know there's one for Arch Linux. I haven't seen one floating around for Debian yet though.
[03:06:07] *** Parts: canin (quassel@moz-EC67E844.cpe.distributel.net) (http://quassel-irc.org - Chat comfortably. Anywhere.)
[03:08:55] <bblum> rusti: error!("%?", true || { true });
[03:08:58] -rusti- rust: ~"true"
[03:08:59] -rusti- ()
[03:09:00] *** Quits: glinscott (garylinsco@789A6618.53EB7C1.FFFE3AA.IP) (Quit: glinscott)
[03:10:46] <ChrisMorgan> Eridius: finally getting somewhere now, will keep trying after lunch
[03:11:13] <Eridius> ChrisMorgan: ok, thank you for doing this
[03:12:16] *** Joins: glinscott (garylinsco@789A6618.53EB7C1.FFFE3AA.IP)
[03:14:14] *** Joins: pnathan (Adium@B9840254.2CD8A5F8.477B877D.IP)
[03:17:53] *** Joins: infynyxx (infynyxx@DB780A29.749BA1D.DCC373F0.IP)
[03:17:54] <tikue> strcat: does hashmap's .each_value() return an iterator yet?
[03:17:54] *** Quits: SiegeLord (sl@moz-CAF07B4C.hsd1.ma.comcast.net) (Quit: It's a joke, it's all a joke.)
[03:18:11] *** Joins: erickt (erickt@8C9ECD8F.3A598286.F12515B4.IP)
[03:18:49] <engla> tikue: no, it's a legacy iterator
[03:18:57] <engla> you can just use the regular iterator and ignore the key
[03:19:01] <bblum> vintage iterator
[03:19:06] <tikue> engla: good idea!
[03:19:35] <steven_is_false> I'm getting failures in the test suite in an unmodified copy of rust.
[03:19:46] *** Quits: infynyxx (infynyxx@DB780A29.749BA1D.DCC373F0.IP) (Ping timeout)
[03:20:01] <engla> tikue: .iter().transform(|(k,v)| v)
[03:20:14] *** Quits: pnathan (Adium@B9840254.2CD8A5F8.477B877D.IP) (Ping timeout)
[03:20:16] <engla> it's what an iter_values() method would do anyway. I'd guess.
[03:20:44] *** Quits: bytbox (s@moz-DC83764A.washdc.fios.verizon.net) (Ping timeout)
[03:20:57] *** Quits: erickt (erickt@8C9ECD8F.3A598286.F12515B4.IP) (Ping timeout)
[03:21:12] <tikue> engla: true
[03:21:36] *** Joins: sp3d (a@moz-49806493.dhcp.stls.mo.charter.com)
[03:22:32] <Eridius> engla: .iter().transform(second)
[03:22:37] *** Parts: steven_is_false (user@moz-144077DE.bchsia.telus.net) (ERC Version 5.3 (IRC client for Emacs))
[03:22:47] <Eridius> no wait, scratch that. second is a method
[03:22:52] * Eridius wants methods-as-functions already
[03:23:22] *** Quits: lkuper (lkuper@moz-C0CD33ED.hsd1.in.comcast.net) (Ping timeout)
[03:23:56] *** Joins: lkuper (lkuper@moz-C0CD33ED.hsd1.in.comcast.net)
[03:24:31] <engla> yeah
[03:25:53] <smvv_> what would be the best way to solve this type match? https://gist.github.com/smvv/5981174 I'm creating a textual representation of a tree. How do I turn the MatIterator in to a ~[~str] ?
[03:26:01] <smvv_> mismatch*
[03:26:39] <Eridius> .collect()
[03:27:05] <smvv_> but that requires a FromIterator, right?
[03:27:11] <Eridius> ~[] implements FromIterator
[03:27:28] <Eridius> also, the type claims you're mapping to ~(), which is curious
[03:27:40] <Eridius> oh it's not curious. you're ending with .push_str(), which doesn't return anything
[03:28:36] <Eridius> smvv_: https://gist.github.com/kballard/5981184
[03:29:33] <Eridius> just updated to be a bit better
[03:30:15] *** Quits: doomlord (doomlod@moz-13E69BC8.range86-180.btcentralplus.com) (Ping timeout)
[03:32:55] *** Quits: roo (jesse@moz-9A53149A.ip.windstream.net) (Ping timeout)
[03:33:03] <smvv_> Eridius: ty. although i've no idea if fmt!("%s%s", ...) is faster than push_str :)
[03:33:14] *** Joins: bytbox (s@moz-DC83764A.washdc.fios.verizon.net)
[03:33:15] <Eridius> smvv_: fmt!() is evaluated at compile-time
[03:33:31] <Eridius> although yeah, I don't know what it actually compiles that down into
[03:33:38] <Eridius> rusti: "3" + "4"
[03:33:39] -rusti- ~"34"
[03:33:42] <Eridius> heck, you could use that
[03:33:44] <Eridius> actually that's even simpler
[03:34:05] <Eridius> smvv_: there, updated to use addition
[03:34:34] <smvv_> rust: ~"tree: Node(key=...)\n\nNode(key=...)\n\nLeaf(key=16)\nLeaf(key=32)\nNone"
[03:34:50] <smvv_> hmm debug!() does not print \n as new lines
[03:35:21] *** Joins: roo (jesse@moz-9A53149A.ip.windstream.net)
[03:35:36] <Eridius> smvv_: it's printing the %? that you gave it. try debug!("%s", foo)
[03:35:52] <Eridius> i.e. it can take args like fmt!(), but if you only give it one arg it prints it with %?
[03:37:28] <engla> hashmap still doesn't impl fromiterator
[03:37:33] <engla> I guess I can try to fix that
[03:37:54] *** Quits: eatkinson (eatkinson@moz-BBE3ABD.mv.mozilla.com) (Quit: eatkinson)
[03:38:13] <Eridius> engla: I suppose you could implement it for a (T, U) iterator
[03:38:18] <Eridius> HashSet should also implement it
[03:38:52] <engla> yeah
[03:39:00] <engla> I agree
[03:39:28] <pcwalton> whee, 5 file conflicts after 3 hours
[03:39:32] <pcwalton> for this patch
[03:39:36] <pcwalton> this is going to be "fun"
[03:41:50] <Eridius> non-trivial conflicts?
[03:42:02] <pcwalton> git did an awful job of merging
[03:42:16] <Eridius> `git mergetool` will let the tool of your choice attempt to re-merge
[03:42:45] <Eridius> git's merge is fairly conservative. If two patches modify adjacent lines, it doesn't like that. But using kdiff3 as my mergetool will typically resolve those automatically
[03:43:04] <Eridius> (of course, sometimes git was right to be cautious, because I've had kdiff3 consider a merge good that actually didn't work because the adjacent lines were important)
[03:46:09] <Jeaye> In my experience (of merging around 40 files at a time, too often), p4merge is far superior to most everything.
[03:46:13] *** Quits: dherman-family (dherman@moz-6CA476B1.hsd1.ca.comcast.net) (Quit: dherman-family)
[03:46:15] <tikue> rusti: struct Foo(uint); *Foo(5)
[03:46:16] -rusti- 5
[03:46:45] *** Joins: pnathan (vlion@moz-BDC3EE62.tukw.qwest.net)
[03:46:49] <strcat> rusti: struct Foo(int); Foo(2)
[03:46:50] -rusti- {__field__: 2}
[03:47:11] *** Joins: jmgrosen (jmgrosen@moz-848F6087.sb.sd.cox.net)
[03:47:15] *** Parts: ChrisMorgan (chris@moz-6AC741CA.static.tpgi.com.au) ()
[03:47:21] *** Joins: ChrisMorgan (chris@moz-6AC741CA.static.tpgi.com.au)
[03:47:31] <Jeaye> Originally part of perforce, it still plays an amazing role in just merging arbitrary files together. Many times git will tell me there's a conflict and it'll open in p4merge, only for p4merge to figure it out and say there are no conflicts at all. Might be worth looking into, pcwalton 
[03:47:34] <jmgrosen> is there any way to return `Self` in a method in a trait, but with a different generic?
[03:47:36] <pcwalton> hmm
[03:47:39] <ChrisMorgan> Accidental <C-W> strikes again... *sigh*
[03:47:53] <pcwalton> jmgrosen: I think you would need higher kinded types for that which rust doesn't support
[03:48:01] <jmgrosen> pcwalton: ok :(
[03:48:33] *** Joins: vk (vk@858480B7.B568D26C.93B001FA.IP)
[03:48:43] <Eridius> Jeaye: maybe it's doing the same thing as kdiff3? The common pattern I've noticed is lines A\nB\nC, if I add a new line D at the end, and someone else modified C, git will complain, but kdiff3 will merge it anyway
[03:48:44] <ChrisMorgan> Eridius: delimitMate is uncanny. After you have a lifetime ', that single quote doesn't behave normally for the rest of the line.
[03:48:52] <Eridius> Jeaye: it's often ok, but sometimes that actaully breaks
[03:48:58] <Eridius> ChrisMorgan: eek
[03:49:07] <engla> git merge resolutions are that way to fit with linux' merge model
[03:49:33] <Eridius> engla: linux has a special merge model?
[03:49:37] <jmgrosen> pcwalton: so, for example, there would be no way to declare `chain` in Option if Option were a trait?
[03:49:41] <Jeaye> Up and the the right.
[03:49:42] <pcwalton> right
[03:49:50] <sp3d> ChrisMorgan: the GtkSourceView language-spec has the same problem, I've been meaning to fix it
[03:49:52] <jmgrosen> :(
[03:50:02] <ChrisMorgan> e.g. typing ' will put only one single quote, pressing it again is equivalent to '<Esc>i
[03:50:09] <pcwalton> there's no opposition to supporting HKT, nobody has implemented it yet though
[03:50:13] <engla> Eridius: just that they merge thousands of commits in a very short time
[03:50:32] <Eridius> '<Esc>i ? wtf
[03:50:41] <mark_edward> how can you make sure a rust function is re-entrant?
[03:50:42] <engla> also no unit tests, so you can't afford silent mismerges
[03:50:45] <Eridius> engla: ah. so yeah, being cautious makes sense
[03:51:06] <ChrisMorgan> Eridius: It's confusing your keystroke with its automatic keystroke, because it's off kilter.
[03:51:06] <strcat> mark_edward: don't use unsafe code?
[03:51:39] <Eridius> ChrisMorgan: that... doesn't actually make much sense. delimitMate rebinds the appropriate keys, so it's not like it's firing this method again on its inserted close
[03:51:44] <mark_edward> strcat: is that  all? so that means Rust code is reentrant by default?
[03:51:54] <ChrisMorgan> *shrug*
[03:52:19] <Eridius> ChrisMorgan: so what you're saying is if you have `&'a foo|` (where | is the cursor) and you type ' again, you get `&'a foo|'`?
[03:52:39] <strcat> mark_edward: really depends on what you mean
[03:52:44] <strcat> rust doesn't have data races
[03:53:01] <strcat> you can still have something like an external file accessed by the function
[03:53:02] <ChrisMorgan> No, you get `&'a foo'|`. But then when you press it again, you get `&'a foo'|'`, and again, `&'a foo''|`.
[03:53:54] <strcat> mark_edward: you can't race on memory though. there's no mutable global state
[03:54:01] <Eridius> ChrisMorgan: ah. this is the exact same behavior I see if I just type `'`, which gives me `'|'`, delete the close so I'm back to `'|`, and press ' again
[03:54:07] <mark_edward> strcat: okay, thanks
[03:54:19] <Eridius> ChrisMorgan: so basically, I don't think this is an issue with your stray '.
[03:54:22] *** Quits: lkuper (lkuper@moz-C0CD33ED.hsd1.in.comcast.net) (Ping timeout)
[03:54:33] <ChrisMorgan> Eridius: yes, but off by one
[03:54:51] *** Joins: lkuper (lkuper@moz-C0CD33ED.hsd1.in.comcast.net)
[03:54:51] <Eridius> off by one? I'm not following
[03:54:55] <ChrisMorgan> In finding matchpairs, it's including the lifetime.
[03:55:03] <Eridius> pressing it again, as you said before, gives you `&'a foo''|` because delimitMate skips the end
[03:55:06] <Eridius> that's intentional behavior
[03:55:22] <ChrisMorgan> Ah, but that's the *third* time you've pressed it after the word foo.
[03:55:24] <Eridius> it lets you type `"foo"` and it skips the end delimiter instead of intering `"foo""`
[03:55:27] <tikue> rusti: let a = ~1; let b = a; a
[03:55:29] -rusti- more than 5 lines of output, pastebinned: http://sprunge.us/PeKW
[03:56:01] <Eridius> ChrisMorgan: oh I see, you're saying it doesn't automatically insert the close when you press ' that second time
[03:56:17] <Eridius> that's the only difference I'm seeing
[03:56:29] <Eridius> but yeah, now I get the "off by one" thing
[03:56:52] <Eridius> basically, the matching pairs calculation needs to ignore chars that are in excluded regions completely
[03:57:02] <ChrisMorgan> Expected: `'|'`, `''|`, `'''|'`. Actual: `'|`, `'|'`, `''|`.
[03:57:07] <ChrisMorgan> Yes.
[03:57:13] *** Joins: infynyxx (infynyxx@moz-E95B370B.nyc.res.rr.com)
[03:57:20] <mark_edward> strcat: are messages sent on channels/ports guaranteed to be received inorder?
[03:59:01] <Eridius> mark_edward: oh boy, I certainly hope so!
[03:59:36] <ChrisMorgan> Actually, I see it makes a mess of the whole ''' thing generally on a normal line, putting `''|'`. On that account, it makes an utter hash of Python's triple-quoted strings.
[04:00:31] *** Quits: pcwalton (pcwalton@moz-BBE3ABD.mv.mozilla.com) (Quit: pcwalton)
[04:00:37] <jmgrosen> ok, now i really want higher kinded types :(
[04:00:41] <Eridius> ChrisMorgan: I would suggest you file an issue about this. The author seems reasonably responsive: https://github.com/Raimondi/delimitMate/issues
[04:00:59] *** Joins: bnicholson (bnicholson@moz-E98974C1.hsd1.ca.comcast.net)
[04:02:00] *** Quits: Sorella (queen@78575561.924F2739.95C8B7C6.IP) (Quit: (quit))
[04:02:28] <Eridius> so I guess there's two issues here. One, the ''' case itself is just weird. And two, smart quotes found in excluded regions should be ignored when balancing
[04:02:39] *** Joins: echristo (echristo@moz-1892C634.hsd1.ca.comcast.net)
[04:02:40] <strcat> ugh, 0-size types ;p
[04:02:50] <strcat> they're nice though
[04:02:59] *** Quits: int3_ (int3_@moz-ABE52D50.hsd1.ca.comcast.net) (Client exited)
[04:03:10] *** Joins: MaikKlein (maik@moz-7BAD3439.dip0.t-ipconnect.de)
[04:03:12] <mark_edward> strcat: how do you initialize a struct liek say `struct Wrapper(uint);`
[04:03:19] <strcat> rusti: Wrapper(2)
[04:03:19] -rusti- <anon>:7:9: 7:16 error: unresolved name `Wrapper`.
[04:03:20] -rusti- <anon>:7          Wrapper(2)
[04:03:20] -rusti-                   ^~~~~~~
[04:03:20] -rusti- error: aborting due to previous error
[04:03:20] -rusti- application terminated with error code 101
[04:03:20] <Eridius> Wrapper(3)
[04:03:34] <strcat> mark_edward: and yeah I assume messages are sent in-order
[04:03:51] <mark_edward> thanks guys!
[04:04:24] <tikue> rusti: struct Wrapper(uint); *Wrapper(2) == 2
[04:04:25] -rusti- true
[04:04:28] <strcat> hm
[04:04:35] *** Quits: smvv_ (sander@moz-BAEA8EB2.dynamic.upc.nl) (Ping timeout)
[04:04:47] <strcat> I don't know if they should use a zero size when stored in vectors though
[04:04:48] <tikue> rusti: struct Wrapper(int): *Wrapper(2) == 2
[04:04:49] -rusti- <anon>:7:28: 7:29 error: expected `;` but found `:`
[04:04:49] -rusti- <anon>:7          struct Wrapper(int): *Wrapper(2) == 2
[04:04:49] -rusti-                                      ^
[04:04:49] -rusti- application terminated with error code 101
[04:04:56] *** Quits: MaikKlein (maik@moz-7BAD3439.dip0.t-ipconnect.de) (Ping timeout)
[04:04:59] <tikue> rusti: struct Wrapper(int); *Wrapper(2) == 2
[04:05:00] -rusti- true
[04:05:03] <tikue> weird
[04:05:12] <tikue> how does it determine 2's type?
[04:05:24] <Eridius> strcat: personally, I like the idea that a [(), ..10000000] doesn't actually take up space ;)
[04:05:27] <tikue> doesn't seem to default to anything
[04:05:29] <strcat> rusti: let x = 5; let y: *int = &x; y
[04:05:29] -rusti- 23969664
[04:05:36] <Eridius> tikue: what do you mean?
[04:05:40] <strcat> Eridius: how do we keep iterators working without overhead though?
[04:05:46] <tikue> Eridius: 
[04:06:01] <klutzy> tikue: http://static.rust-lang.org/doc/rust.html#integer-literals
[04:06:15] <strcat> rusti: let x = 5; let a = (); let y: *int = &x; let b: *() = &a; (y, b)
[04:06:15] -rusti- ((0xefff78 as *()), (0xefff70 as *()))
[04:06:36] <tikue> rusti: let a: uint = 2; println(fmt!("%?", a == 2)); let b: int = 2; println(fmt!("%?", b == 2));
[04:06:37] -rusti- true
[04:06:37] -rusti- true
[04:06:38] -rusti- ()
[04:06:42] <Eridius> strcat: is size_of() inlined? if so, checking if size_of() is 0 should be inlinable and llvm should be able to completely drop one of the two branches
[04:06:44] <tikue> Eridius: ^
[04:06:51] *** Quits: lkuper (lkuper@moz-C0CD33ED.hsd1.in.comcast.net) (Ping timeout)
[04:06:59] <strcat> Eridius: I don't want to write a separate iterator for zero-size ones though
[04:07:05] <Eridius> strcat: tough :P
[04:07:10] <tikue> oh nvm
[04:07:10] <strcat> and slice
[04:07:13] <strcat> and everything else
[04:07:15] *** Quits: tiffany (kawaii@moz-1E0FE6E8.dhcp.embarqhsd.net) (Ping timeout)
[04:07:21] *** Joins: lkuper (lkuper@moz-C0CD33ED.hsd1.in.comcast.net)
[04:07:23] <tikue> rusti: let a: uint = 2; let b: int = 2; a == b
[04:07:24] -rusti- <anon>:7:47: 7:48 error: mismatched types: expected `uint` but found `int` (expected int but found uint)
[04:07:24] -rusti- <anon>:7          let a: uint = 2; let b: int = 2; a == b
[04:07:24] -rusti-                                                         ^
[04:07:24] -rusti- error: aborting due to previous error
[04:07:24] <Eridius> tikue: integral constants can be treated as any integral type if they're constrained appropriately. If not, they default to int
[04:07:25] -rusti- application terminated with error code 101
[04:07:32] <strcat> Eridius: it won't work because the struct fields need to change.
[04:07:43] <strcat> we don't have that kind of type metaprogramming
[04:07:45] <Eridius> strcat: not if you repurpose ptr and end to be integral counters ;)
[04:07:54] <Eridius> just make ptr 0 and end the count you want
[04:07:55] <tikue> Eridius: ah ok. so in equality tests it aims for true
[04:08:05] <Eridius> and increment by nonzero_size_of(), which will do 1
[04:08:11] <Eridius> tikue: no
[04:08:17] <Eridius> tikue: equality tests require the same type on both sides
[04:08:20] <tikue> Eridius: oh, it just tries to be the same type
[04:08:21] <tikue> lol
[04:08:24] <tikue> thank you
[04:08:48] <Eridius> strcat: if ptr is 0 and end is 10 and nonzero_size_of() is used (via a proposed ptr.nonzero_offset), then the existing loop will work
[04:09:06] <Eridius> which I guess means it just needs to use nonzero_size_of() and the .iter() method needs updating, not the actual iterator itself
[04:09:22] <strcat> yeah, I'll try that
[04:09:26] <strcat> but what about slices? ;[
[04:09:31] <strcat> ah
[04:09:34] <strcat> slices use offset too
[04:09:36] <strcat> that's why it's broken
[04:09:57] <strcat> Eridius: slices are likely going to end up represented as (ptr, end_ptr), at least I wanted them to be
[04:10:01] <strcat> that seems to mean they can't be.
[04:10:12] <Eridius> strcat: why not (count, ptr)?
[04:10:19] <strcat> Eridius: because iterators are ptr, end_ptr
[04:10:25] <strcat> and slices should be the iterator impl
[04:10:26] <tikue> rusti: [1, 2, 3].iter().zip([1, 2])
[04:10:27] -rusti- <anon>:7:9: 8:5 error: failed to find an implementation of trait std::iterator::Iterator<<V12>> for [int, .. 2]
[04:10:28] -rusti- <anon>:7          [1, 2, 3].iter().zip([1, 2])
[04:10:28] -rusti- <anon>:8     };
[04:10:28] -rusti- application terminated with error code 101
[04:10:33] <tikue> wat
[04:10:40] <tikue> rusti: [1, 2, 3].iter().zip([1, 2, 3])
[04:10:41] -rusti- <anon>:7:9: 8:5 error: failed to find an implementation of trait std::iterator::Iterator<<V12>> for [int, .. 3]
[04:10:41] -rusti- <anon>:7          [1, 2, 3].iter().zip([1, 2, 3])
[04:10:41] -rusti- <anon>:8     };
[04:10:41] -rusti- application terminated with error code 101
[04:10:43] <Eridius> strcat: well you could always rewrite the iterator to check if count == 0
[04:10:52] <Eridius> which would also fix the unit struct iterators
[04:10:52] <tikue> wot wot wot
[04:11:02] <strcat> Eridius: you can't do that
[04:11:06] <Eridius> no?
[04:11:09] <strcat> that means a pointer addition + subtraction for the len
[04:11:10] <jmgrosen> would holding a generic function in a struct also require higher kinded structs? (that is, a generic function which returns something that can't be part of the struct Foo<> part)
[04:11:11] <strcat> on each iteration
[04:11:18] <strcat> that's like 30% slower
[04:11:23] <strcat> trhy it
[04:11:25] <strcat> try*
[04:11:31] <tikue> rusti: let a = [1, 2, 3]; let b = [1, 2]; a.iter().zip(b.iter())
[04:11:33] -rusti- more than 5 lines of output, pastebinned: http://sprunge.us/chPH
[04:11:36] <strcat> it means it has two variables to update in the loop
[04:11:38] <strcat> instead of 1
[04:11:43] <strcat> ptr += 1
[04:11:45] <strcat> count -= 1
[04:11:53] <Eridius> and that's really that noticeable?
[04:11:56] <strcat> yes
[04:12:02] <strcat> it's the fundamental iteration building block
[04:12:07] <strcat> and it doesn't optimize out
[04:12:07] <tikue> rusti: let a = [1, 2, 3].iter(); let b = [1, 2].iter(); a.zip(b)
[04:12:07] -rusti- <anon>:7:59: 7:60 error: unknown start of token: 29
[04:12:07] -rusti- <anon>:7          let a = [1, 2, 3].iter(); let b = [1, 2].iter(); a.zip(b)
[04:12:07] -rusti-                                                                     ^
[04:12:07] -rusti- application terminated with error code 101
[04:12:17] <tikue> ???
[04:12:30] <strcat> Eridius: it's as noticeable as bounds checks
[04:12:34] <Eridius> grr. special-case .slice() on unit types to return (0, count)? Same hack I proposed for iter
[04:12:38] *** Quits: alisdair (textual@moz-EBE9F394.bchsia.telus.net) (Quit: My MacBook Pro has gone to sleep. ZZZzzzâ€¦)
[04:12:46] <strcat> Eridius: it will make it not vectorize, etc.
[04:12:48] * strcat shrugs
[04:13:00] <strcat> I'll use your proposed hack for iterators
[04:13:05] <strcat> and fix the rest
[04:13:11] <glinscott> does the stage0 compiler build use things built earlier in stage0?  i'm hitting this compiler error after changing some stuff in libstd - http://pastebin.com/tfPEH6mG
[04:13:20] <strcat> Eridius: I won't try making them zero-size yet though
[04:13:25] <strcat> lots will probably break
[04:13:31] <tikue> rusti: let a = [1, 2, 3]; let a = a.iter(); let b = [1, 2]; let b = b.iter(); a.zip(b)
[04:13:31] -rusti- <anon>:7:81: 7:82 error: unknown start of token: 29
[04:13:31] -rusti- <anon>:7          let a = [1, 2, 3]; let a = a.iter(); let b = [1, 2]; let b = b.iter(); a.zip(b)
[04:13:31] -rusti-                                                                                           ^
[04:13:32] -rusti- application terminated with error code 101
[04:13:40] <tikue> what does this even mean
[04:13:56] <sp3d> you have an 0x1d byte in your code; that's not allowed in a rust token
[04:13:56] *** Quits: _Vi (vi@527C345F.497AA854.B16B3BE6.IP) (Ping timeout)
[04:14:07] <sp3d> rusti: let a = [1, 2, 3]; let a = a.iter(); let b = [1, 2]; let b = b.iter(); a.zip(b)
[04:14:08] -rusti- more than 5 lines of output, pastebinned: http://sprunge.us/jZfD
[04:14:23] <ChrisMorgan> Eridius: try this line for craziness:
[04:14:24] <ChrisMorgan> rusti: static a: &'static char = &'a';
[04:14:25] -rusti- error: internal compiler error: unexpected failure
[04:14:25] -rusti- note: the compiler hit an unexpected failure path. this is a bug
[04:14:25] -rusti- note: try running with RUST_LOG=rustc=1,::rt::backtrace to get further details and report the results to github.com/mozilla/rust/issues
[04:14:25] -rusti- application terminated with error code 101
[04:14:30] <Eridius> glinscott: that error you got at the top typically indicates to me that I'm trying to use a crate built with an earlier version of rustc. shouldn't see it when building rust itself though
[04:14:47] <Eridius> ChrisMorgan: hah
[04:15:17] *** Quits: lkuper (lkuper@moz-C0CD33ED.hsd1.in.comcast.net) (Ping timeout)
[04:15:20] <strcat> rusti: let xs = [1, 2, 3]; let ys = ["foo", "bar"]; for xs.iter().zip(ys.iter()).advance |(x, y)| { println(fmt!("%? %?", x, y)) }
[04:15:21] -rusti- &1 &"foo"
[04:15:21] -rusti- &2 &"bar"
[04:15:21] -rusti- ()
[04:15:27] *** Joins: alisdair (textual@moz-EBE9F394.bchsia.telus.net)
[04:15:36] <tikue> rusti: let a = [1, 2, 3]; let a = a.iter(); let b = [1, 2]; let b = b.iter(); println(fmt!("%?", a.zip(b)));
[04:15:38] -rusti- line longer than 150 columns, pastebinned: http://sprunge.us/DYSX
[04:15:54] <glinscott> Eridius: ok, thanks, i've tried a make clean w/o success.  any hints on debugging?
[04:15:57] <ChrisMorgan> I should mention that it doesn't fail for meâ€”perhaps something about how rusti is writing the file?
[04:16:04] <Eridius> strcat: in the end, making vectors of unit types actually allocate 1 byte to each element isn't a dealbreaker. I'm just rather partial to the idea that zero-size types are truly zero-size
[04:16:13] <strcat> Eridius: yeah I think we can do that
[04:16:32] <ChrisMorgan> Ah yes, if I put that line inside the fn main(){} it ICEs.
[04:16:49] <engla> a vector of unit structs is isomorphic to a natural number.
[04:16:49] <Eridius> glinscott: did you get that just by running `make` on rust itself?
[04:17:18] <tikue> what is the justification for zip chopping off to the shortest iterator rather than just having (3, None) etc.
[04:17:36] <Eridius> tikue: (3, None) woudln't typecheck
[04:17:40] <engla> tikue: that would be a different type signature
[04:17:57] *** Joins: bskari (Mibbit@moz-3D0C4FF0.hsd1.ca.comcast.net)
[04:18:00] <tikue> ah yeah, guess it'd have to be like (Some(3), None) etc
[04:18:03] <tikue> and that'd get really annoying
[04:18:05] <ChrisMorgan> "No enclosing scope for id 8". Are you supposed to be allowed to define statics inside a function?
[04:18:17] <glinscott> Eridius: after making some changes to vec.rs - https://github.com/glinscott/rust/compare/vec_reserve
[04:18:17] <Eridius> you could write a theoretical .zipLongest that returns Option<(Option<T>,Option<U>)> if you want, but that's ugly
[04:18:23] <engla> tikue: in general though, there could be a zip_fill or similar method
[04:18:31] <tikue> Eridius: yeah just thinking about it sucks
[04:18:34] <engla> Eridius: better take filler values
[04:18:40] <Eridius> rusti: fn foo() { static x : char = 'x'; }; foo()
[04:18:41] -rusti- <anon>:7:20: 7:42 warning: static constant should have an uppercase identifier [-W non-uppercase-statics (default)]
[04:18:41] -rusti- <anon>:7          fn foo() { static x : char = 'x'; }; foo()
[04:18:41] -rusti-                              ^~~~~~~~~~~~~~~~~~~~~~
[04:18:41] -rusti- ()
[04:18:45] <engla> it's more general and you can still fill with None if you want
[04:18:51] <Eridius> ChrisMorgan: looks like yes it should work
[04:18:59] <strcat> tikue: the main iterator adaptors all do that
[04:19:03] <strcat> take, skip, etc.
[04:19:05] <ChrisMorgan> Works for str, but not for chr or u8
[04:19:07] <Eridius> you can't fill it with none unless you transform both input iterators to Some(x)
[04:19:09] <strcat> take(3) will take *at most* 3
[04:19:10] <Eridius> which is even uglier
[04:19:10] <tikue> strcat: do what?
[04:19:14] <strcat> that's what they do in D, python, haskell
[04:19:23] <strcat> it's usually what you want
[04:19:23] <tikue> strcat: I know. I just wondered why :)
[04:19:37] <Eridius> tikue: Every time I've used zip, the truncation behavior has actually been what I wanted ;)
[04:19:37] *** Joins: erickt (erickt@8C9ECD8F.3A598286.F12515B4.IP)
[04:19:40] <tikue> strcat: right, but why is it usually what they want? I suppose the answer is it's the easiest to reason about
[04:19:41] <engla> Eridius: in some cases you might want to fill with 0 etc.
[04:20:00] *** Joins: snadon (chatzilla@moz-3BC727E8.mc.videotron.ca)
[04:20:03] <strcat> tikue: because infinite iterators exist
[04:20:09] <strcat> you don't know how long iterators are
[04:20:15] <tikue> strcat: why is that a problem?
[04:20:23] <strcat> tikue: zip_longest will loop *forever*
[04:20:30] <tikue> strcat: not if it were lazy
[04:20:31] <Eridius> strcat: it won't loop, it will just never end
[04:20:35] <ChrisMorgan> So why is `copy` being removed? What happens in its place in places where one currently uses copy?
[04:20:36] <sp3d> perhaps rust could get a zipwith where the combiner takes option<t>, option<u>
[04:20:45] <strcat> Eridius: sure, 
[04:20:58] <strcat> that's the point though
[04:21:06] <tikue> strcat: are iterators lazy right now?
[04:21:16] <strcat> tikue: yes, I don't think you're understanding the point though
[04:21:23] <tikue> strcat: so why isn't zip lazy
[04:21:33] <tikue> or is it?
[04:21:37] <strcat> it is lazy
[04:21:41] <tikue> so then what is the problem?
[04:21:51] <strcat> tikue: because it will yield forever and that's different than every other adaptor
[04:22:03] <strcat> take(3) takes up to 3
[04:22:04] <engla> it's lazy. zip longest is just as infinite as the inputs to that function, so nothing changes with .zip_longest
[04:22:06] <strcat> skip(3) skips up to 3
[04:22:21] *** Quits: erickt (erickt@8C9ECD8F.3A598286.F12515B4.IP) (Ping timeout)
[04:22:27] <tikue> strcat: right, but my question could generalize to them as well, couldn't it?
[04:22:42] <strcat> tikue: and how often do you really want that? what's the use case?
[04:22:45] *** Quits: KindOne (KindOne@moz-BD665EC4.dynamic.ip.windstream.net) (Ping timeout)
[04:22:53] <tikue> strcat: I think the real answer is it's the easiest to reason about and probably the most common use case
[04:23:16] <tikue> strcat: no idea. usually when I zip it's with things of the same length
[04:23:44] <strcat> that's not how iterators are used though
[04:23:53] <Eridius> strcat: it occurs to me we have no pre-baked iterator that simply returns clones of an input infinitely
[04:23:54] <tikue> strcat: not sure what you mean by that
[04:23:55] <strcat> you can zip a counter with a container to use arbitrary indices
[04:23:58] <Eridius> which would potentially be useful
[04:24:04] <strcat> you can zip a cycle of a vector with another vector
[04:24:06] <Eridius> or alternatively, one that cycles through a vector repeatedly
[04:24:09] <strcat> [1, 2, 3] against an arbitrarily long one
[04:24:09] <Eridius> oh do we have the cycle one?
[04:24:16] <strcat> to get 1 2 3 1 2 3 1 2 3 until the end
[04:24:21] <strcat> Eridius: it's planned
[04:24:24] <Eridius> ah
[04:24:27] <engla> I thought we had cycle
[04:24:29] *** Quits: pnathan (vlion@moz-BDC3EE62.tukw.qwest.net) (Ping timeout)
[04:24:56] <tikue> strcat: usually I'm zipping iter representations of things of finite length.
[04:25:14] <strcat> tikue: and the current zip handles that fine
[04:25:34] <tikue> strcat: yes. I don't think I said it didn't?
[04:25:37] *** Joins: KindOne (KindOne@moz-BD665EC4.dynamic.ip.windstream.net)
[04:25:52] *** Quits: reyre (reyre@moz-9002CDDA.cpe.net.cable.rogers.com) (Client exited)
[04:25:53] <tikue> strcat: I was simply speculating about the reason that they truncate.
[04:26:03] <tikue> strcat: I don't even have a use case for the situation where they don't; I was just curious
[04:26:16] * strcat thought you were arguing for making zip_longest the default
[04:26:31] <strcat> instead of zip_shortest
[04:26:55] <tikue> no I wasn't arguing for that
[04:27:02] <strcat> ah
[04:27:09] <strcat> totally misunderstood
[04:27:49] <strcat> the problem with zip_longest is when you want finite things of the same length zipped, you'd have to check for that case in each iteration
[04:28:03] <strcat> and if they're finite you can just check length in advance, if they're containers
[04:28:09] <strcat> like
[04:28:24] <strcat> zip_longest would yield (Option<T>, Option<U>)
[04:28:28] <strcat> rather than (T, U)
[04:28:40] <strcat> and in each iteration you'd match the case you wanted
[04:28:47] <tikue> rusti: let a = [1, 2, 3]; let b = [4, 5]; for a.iter().chain(b.iter()) |x| { println(fmt!("%u", *x)); }
[04:28:49] -rusti- more than 5 lines of output, pastebinned: http://sprunge.us/CfjD
[04:28:49] <strcat> and usually you don't want to do that imo
[04:29:14] <tikue> strcat: yeah I can't think of a time when I'd prefer that
[04:29:19] <strcat> and in the opinions of the people who wrote python, haskell and D, but not the people who wrote some other languages
[04:29:29] <strcat> some languages use zip_longest by default, can't remember which though!
[04:29:35] <mark_edward> you know what'd be cool
[04:29:39] <strcat> but they're probably dynamically typed 
[04:29:46] <strcat> so you just ignore the cases you don't care about
[04:29:50] <mark_edward> if you code implement Encodable/Decodable for functions!
[04:29:52] <tikue> strcat: I was thinking the same thing
[04:30:26] <Eridius> strcat: why didn't this work? https://gist.github.com/kballard/cb92537d882262d88211
[04:30:33] <tikue> rusti: let a = [1, 2, 3]; let b = [4, 5]; for a.iter().chain_(b.iter()) |x| { println(fmt!("%u", *x)); }
[04:30:35] -rusti- more than 5 lines of output, pastebinned: http://sprunge.us/AEaO
[04:31:00] <tikue> rusti: let a = [1, 2, 3]; let b = [4, 5]; for a.iter().chain_(b.iter()).advance |x| { println(fmt!("%u", *x)); }
[04:31:01] -rusti- more than 5 lines of output, pastebinned: http://sprunge.us/EbVK
[04:31:04] <tikue> gah
[04:31:13] <strcat> Eridius: it'd be easier to just do it by hand ;p
[04:31:17] <Eridius> strcat: :P
[04:31:20] <tikue> rusti: let a = [1, 2, 3]; let b = [4, 5]; for a.iter().chain_(b.iter()).advance |x| { println(fmt!("%d", *x)); }
[04:31:22] -rusti- more than 5 lines of output, pastebinned: http://sprunge.us/IHSS
[04:31:42] <Eridius> strcat: but no I'm actually confused. Why does rust not want to let me use the type parameter in the return value?
[04:31:55] <Eridius> what does this error actually mean: "expected type parameter but found struct std::iterator::TakeWhileIterator"
[04:32:21] <Eridius> is it trying to say the TakeWhileIterator does not conform to the type bounds on Z? (if so, that's a terrible error message)
[04:32:29] *** Joins: ross (ross@moz-8A84103E.br.br.cox.net)
[04:32:38] <strcat> Eridius: it's too long to reason about
[04:32:40] <Eridius> oh great, I think it is. I used I and J instead of T and U in the bound
[04:32:41] <engla> Eridius: the function is written to have a generic return type
[04:32:41] <strcat> I think it's a type mismatch
[04:32:47] <Eridius> well you can skip the entire struct type
[04:32:48] <mark_edward> strcat: is there anyway you can think of in rust to encode/decode funtions?
[04:32:53] <engla> Eridius: but it doesn't have that, it always returns TakeWhileIterator
[04:32:55] <Eridius> it is indeed a type mismatch, just with a terrible message
[04:33:06] <strcat> mark_edward: nope, and I don't think you can do anything with that
[04:33:07] <tikue> strcat: are you in favor of default supporting this behavior: ['a', 'b', 'c'].zip(1, 2, 3) // default iterable methods or whatnot
[04:33:10] <strcat> because the heap/stack aren't executable
[04:33:11] <Eridius> damn no, fixing the type params to T and U resulted in the same error
[04:33:27] <tikue> woops that should be zip([1, 2, 3])
[04:33:36] <strcat> tikue: yes, but it's going to be hard to get working
[04:33:36] <Eridius> engla: yes, there is only one type that can ever be used to satisfy Z, but that shouldn't matter
[04:33:44] <glinscott> ok, it looks like it's not actually running my new code.  just plain "make" is failing
[04:33:45] <strcat> tikue: need to teach zip to accept *either* an Iterable or Iterator
[04:33:48] <strcat> it's doable
[04:34:02] <tikue> strcat: why can't you just make iterators implement Iterator
[04:34:06] <tikue> wait
[04:34:07] <Eridius> you mean Iterable
[04:34:09] <tikue> yes
[04:34:10] <strcat> iterators are mutable
[04:34:14] <glinscott> i changed fn reserve to be fail!("â€¦");, and it still gives the same error from the pastebin
[04:34:15] <strcat> Iterable will use &self
[04:34:30] *** Joins: posco (oscarboyki@moz-121FFE47.hsd1.ca.comcast.net)
[04:34:32] <strcat> iterators have to mutate
[04:34:39] <tikue> gah
[04:34:41] <strcat> and they can't be Iterable because they are consumed
[04:34:47] <strcat> Iterable means you can grab N iterators
[04:34:57] <strcat> like
[04:34:57] <tikue> oh I did not realize
[04:35:08] <tikue> why not scrap that and add .tee() or something
[04:35:17] <strcat> tikue: how?
[04:35:23] <strcat> let xs = [1, 2, 3]; let mut a = xs.iter(); let mut b = xs.iter();
[04:35:32] <strcat> tikue: it has to work for non-copyable types
[04:35:34] <strcat> and without @
[04:35:43] <tikue> true : \
[04:35:43] <strcat> or expensively copyable types, without needing copies
[04:36:00] <engla> Eridius: it's not how type parameters work though
[04:36:14] <tikue> strcat: I assume there's not a chance in hell of making Iterable take (&mut self) ?
[04:36:18] <tikue> for its impl fns
[04:36:21] <engla> if you have a type parameter as return type, it's "caller's choice", not implementor's
[04:36:24] <strcat> tikue: well, then it wouldn't let you get 2
[04:36:39] <Eridius> engla: there's no way in hell I'm typing out that massive type
[04:36:49] <strcat> tikue: since you can't use &mut when you have an & to it
[04:36:51] <tikue> strcat: right
[04:36:53] <jmgrosen> what's the proper type for accepting a function that will be captured in a new task closure? I thought it was &fn:send() but that doesn't seem to work
[04:37:00] <strcat> tikue: I don't really have a solution yet
[04:37:02] <tikue> strcat: there should be like, an "internally mutable" thing
[04:37:03] <engla> I'm sorry but it's the reality of iterator combinators
[04:37:06] <strcat> I think we'll find one
[04:37:07] <tikue> strcat: where it's immutable from the outside
[04:37:09] <strcat> tikue: well that's not safe
[04:37:16] <tikue> strcat: so :) 
[04:37:22] <strcat> tikue: so, you can already do it with unsafe {}
[04:37:24] <strcat> nothing stops you
[04:37:32] <strcat> but it's really, really, really hard to make it safe externally
[04:37:32] <tikue> strcat: there is a lot of unsafe code in std
[04:37:37] <strcat> tikue: it's safe externally
[04:37:42] <tikue> ahh
[04:37:43] <strcat> if it's not, it will be removed or marked unsafe
[04:37:47] <tikue> why is it hard to make it safe externally?
[04:37:55] <strcat> tikue: because it has to implement dynamic freezing
[04:38:02] <strcat> the restrictions on &mut and & don't exist for fun
[04:38:04] <strcat> they're for memory safety
[04:38:13] *** Quits: Earnestly (earnest@2AB30F53.FB5005.2BCC804A.IP) (Ping timeout)
[04:38:29] <strcat> if you work around them with unsafe, you have to understand completely why those restrictions are there and carefully implement an equivalent strategy to handle the issues
[04:38:31] <strcat> it's *really* hard
[04:38:46] <strcat> @mut only became memory-safe ~0.6
[04:38:47] <tikue> mhm
[04:38:55] <strcat> and it has all kinds of dynamic failures
[04:38:59] <strcat> borrow &mut, borrow &mut, fail
[04:39:02] <strcat> borrow &mut, borrow &, fail
[04:39:08] <strcat> borrow &mut, modify, fail
[04:39:11] <strcat> borrow &, modify, fail
[04:39:17] <strcat> borrow &, borrow &mut, fail
[04:39:19] <strcat> ;p
[04:39:24] <strcat> through different references
[04:39:27] * strcat doesn't like @mut
[04:39:59] <tikue> alrightâ€¦so, sounds like iterators wont be iterable anytime soon :P
[04:40:14] <strcat> tikue: yeah but there are other ways of dealing with it, probably
[04:40:21] <strcat> I haven't thought of one
[04:40:23] <strcat> ;p
[04:40:29] * strcat hasn't spent much time trying to though
[04:40:55] <strcat> tikue: generic iterators couldn't be implemented at all before 0.6 btw
[04:41:37] <tikue> I'm so happy rust's iterators are looking so much like python's
[04:41:47] <tikue> and will only look more and more like them
[04:42:10] <jmgrosen> is there any way to specify that a closure's environment must satisfy Send?
[04:42:26] <tikue> once for pattern in iter landsâ€¦
[04:42:31] *** Joins: pnathan (vlion@moz-BDC3EE62.tukw.qwest.net)
[04:42:32] <strcat> tikue: they're more powerful already thanks to DoubleEndedIterator
[04:42:39] <tikue> strcat: what does that enable?
[04:42:40] <strcat> like D's BidirectionalRange
[04:42:43] *** Joins: eatkinson (eatkinson@moz-AD233F1B.dia.static.qwest.net)
[04:42:48] <engla> yeah it's really nice strcat 
[04:43:06] <tikue> strcat: what kind of things can you do with that? can you show me a demo
[04:43:49] <strcat> tikue: https://github.com/mozilla/rust/pull/7736 I wrote about it here
[04:44:20] <strcat> tikue: but basically, you can yield from either side of a vector/deque/dlist iterator (or other containers)
[04:44:26] <strcat> and you can flip the direction
[04:44:38] <strcat> you could write a generic in-place reverse function, etc.
[04:45:03] <strcat> grab &mut from both ends, swap, and keep going until you have None from either
[04:45:05] <tikue> strcat: ohh that's cool -- what are the methods called?
[04:45:19] <strcat> tikue: it's just next_back()
[04:45:29] <strcat> and there's .invert() for flipping next() and next_back() with a wrapper
[04:45:45] <tikue> why .invert() and not .reversed()
[04:45:52] <strcat> dunno
[04:46:04] * strcat had to pick between flip, invert, reverse, etc.
[04:46:08] *** Quits: bskari (Mibbit@moz-3D0C4FF0.hsd1.ca.comcast.net) (Quit: http://www.mibbit.com ajax IRC Client)
[04:46:14] <strcat> kind of arbitrarily picked one.
[04:46:16] <tikue> ah
[04:46:30] <Eridius> .go_back_the_way_you_came()
[04:46:37] <strcat> I started off using drop and drop_while but had to switch to skip/skip_while anyway :)
[04:46:43] <engla> .other_end_of_stick()
[04:46:46] *** Joins: ghrust (ghrust@AC22872E.6A2AE50.F3114085.IP)
[04:46:46] <ghrust> 01[13rust01] 15bors merged 06auto into 06master: 02http://git.io/DCKVPg
[04:46:46] *** Parts: ghrust (ghrust@AC22872E.6A2AE50.F3114085.IP) ()
[04:46:49] <engla> flip would be a good name
[04:46:50] <glinscott> ok, i tracked it down - it looks like there is a bug with declaring unsafe fn's inside of an if block potentially
[04:46:52] <strcat> tikue: also because of method conflicts odd names are nice ;p
[04:46:54] <Eridius> .devils_advocate()
[04:46:56] <strcat> so I don't need _ at the end
[04:47:01] <strcat> tikue: from method resolve bugs :{
[04:47:01] <tikue> strcat: lol
[04:47:15] <tikue> when can we just get rid of all the internal iterators once and for all!?!
[04:47:21] <strcat> tikue: they're dying off
[04:47:27] <strcat> they can all be replaced already
[04:47:29] <tikue> I know
[04:47:31] <strcat> except .advance :)
[04:47:35] <tikue> but I want them gone, kaput
[04:47:40] <strcat> yeah I want them gone
[04:47:43] <strcat> and a new for, yesterday
[04:47:53] <tikue> and I really want for pattern in iter
[04:47:55] <strcat> but afaik no one has started yet ;p
[04:48:09] <tikue> for pattern in iter is far and away the best option imo
[04:48:12] <strcat> well if we change the for loop syntax we'll need to migrate to a temporary syntax ext
[04:48:19] <strcat> for!()
[04:48:25] <strcat> maybe for_each!() because for is reserved atm ;\
[04:48:27] <strcat> for_
[04:48:29] <tikue> why can't we change it all in one fell swoop
[04:48:35] <strcat> tikue: self-hosting compiler
[04:48:39] <tikue> oh right
[04:48:40] <tikue> lol
[04:48:41] <strcat> stage0 needs to compile the compiler + libs
[04:48:43] <strcat> it's a real pain
[04:48:58] <strcat> so someone needs to migrate every for loop to something else
[04:49:02] <strcat> remove for loops
[04:49:03] <tikue> i would if i had the time
[04:49:05] <strcat> snapshot
[04:49:09] <strcat> add new for loop
[04:49:13] <strcat> snapshot
[04:49:15] <strcat> migrate to it
[04:49:17] <strcat> ;p
[04:49:25] <bjz> tikue: why are you so adimant about for _ in _?
[04:49:32] <tikue> bjz: because it's beautiful O_O
[04:49:43] <tikue> bjz: I'm not adamant about anything though, I know my opinion means nothing :D
[04:49:45] <bjz> seems abit out of place
[04:49:46] *** Joins: ghrust (ghrust@79968228.6A2AE50.F3114085.IP)
[04:49:46] <ghrust> 01[13rust01] 15bors pushed 2 new commits to 06auto: 02http://git.io/8jt51Q
[04:49:46] <ghrust> 13rust/06auto 140af64ae 15Alex Crichton: Add a `consume` method to SmallIntMap
[04:49:46] <ghrust> 13rust/06auto 148fc0da6 15bors: auto merge of #7679 : alexcrichton/rust/consume-smallintmap, r=thestinger...
[04:49:46] *** Parts: ghrust (ghrust@79968228.6A2AE50.F3114085.IP) ()
[04:49:48] <tikue> bjz: but it's by far my preference
[04:49:51] * strcat doesn't really have a strong enough opinion about it to want to do it
[04:49:54] <strcat> as in, do it myself
[04:49:57] <strcat> ;p
[04:49:58] <klutzy> strcat: is it ready to change for syntax? or any steps remaining?
[04:50:08] <engla> the important part is to have closure free for
[04:50:10] <tikue> bjz: out of place how?
[04:50:19] <strcat> klutzy: well there are maybe 150 for loops left using closures
[04:50:28] <strcat> ones that aren't advance
[04:50:37] <bjz> tikue: seems a little out of place, for example with do |_| { }
[04:50:38] <strcat> the vast majority are ported
[04:50:42] <strcat> there are stubborn ones remaining
[04:50:46] <strcat> they could be changed to 'do'
[04:50:52] <tikue> bjz: do actually takes a closure though
[04:51:04] <tikue> bjz: for doesn't technically take a closure
[04:51:16] <strcat> % git grep '\.each' | wc -l
[04:51:18] <strcat> 144
[04:51:33] <engla> strcat: there are a lot more non-advance loops using uint::range
[04:51:47] <strcat> yeah but that's easy to rewrite and port
[04:51:49] <bjz> strcat: going to the `do` syntax might work
[04:52:01] *** Joins: doomlord (doomlod@moz-13E69BC8.range86-180.btcentralplus.com)
[04:52:03] <bjz> strcat: could there maybe be an interim lint?
[04:52:06] <strcat> src/libextra/bitv.rs:793:        self.each_outlier(other, |mine, i, w|
[04:52:10] <strcat> these kind, maybe not so easy
[04:52:13] <strcat> kinds*
[04:52:20] <strcat> src/librustc/middle/borrowck/check_loans.rs:101:        for self.each_issued_loan(scope_id) |loan| {
[04:52:23] <bjz> strcat: that warns when using the `for` syntax?
[04:52:26] <engla> true
[04:52:37] <strcat> bjz: maybe
[04:52:45] <strcat> but I don't know how long it will take to implement
[04:52:52] <bjz> 'use do instead'
[04:52:53] <strcat> I think we should probably have a 'for_' loop first
[04:53:02] <strcat> bjz: yeah but you can't break early from do
[04:53:10] <bjz> ohh
[04:53:12] <bjz> poo
[04:53:14] <strcat> you have to break at the end 
[04:53:16] <strcat> like
[04:53:24] <bjz> ok, for_ would work I guess
[04:53:27] <strcat> do foo.each { /* code */; boolean }
[04:53:37] <strcat> since we don't allow 'return' in do
[04:53:37] <bjz> yeah
[04:53:42] <bjz> didn't think of that
[04:53:51] <strcat> you can work around it but...
[04:53:55] <strcat> it'll be a pain to update them all
[04:53:59] <bjz> yeah
[04:54:05] <bjz> and then to change them back
[04:54:13] <bjz> agreed
[04:54:39] <strcat> anyway bug pcwalton to make a 'for_' loop or something
[04:54:48] <strcat> we need a migration path before we can do the migration
[04:55:08] * strcat doesn't know enough about the compiler to do it without taking 2 months ;p
[04:55:21] *** Joins: BizarreCake (BizarreCak@moz-361FE9B2.dynamic.barak-online.net)
[04:55:28] <strcat> need to update liveness and borrowck afaik
[04:56:20] <bjz> hehe
[04:56:59] <bjz> I think I've used up my 'bugging pcwalton' budget for a lifetime
[04:57:02] <bjz> :)
[04:57:28] <tikue> if I have a function that returns an iterator, what is the type signature?
[04:57:42] *** Quits: enix (enix@moz-A50569DD.c3-0.slvr-ubr1.lnh-slvr.md.cable.rcn.com) (Quit: Konversation terminated!)
[04:58:32] <Eridius> tikue: depends on the iterator you're returning
[04:58:42] <tikue> Eridius: there isn't a generic iterator trait?
[04:58:47] <bjz> strcat: what you have to do is make it really painful for him. get rid of each, zip, map etc.
[04:58:48] <tikue> or something
[04:58:53] <bjz> strcat: :P
[04:58:58] <Eridius> tikue: well you could return a trait object, but that's nasty and breaks inlining
[04:59:06] <tikue> doh
[04:59:15] <strcat> bjz: well that's why I went ahead with making everything use external iterators
[04:59:16] <tikue> wait
[04:59:19] <bjz> strcat: then all the code will look ugly
[04:59:21] <tikue> ah
[04:59:25] <strcat> .advance is supposed to bother everyone so someone does something about it
[04:59:28] *** Joins: steven_is_false (user@moz-144077DE.bchsia.telus.net)
[04:59:30] <strcat> maybe I should give it a longer name
[04:59:33] <strcat> .please_go_forward
[04:59:46] *** Parts: steven_is_false (user@moz-144077DE.bchsia.telus.net) (ERC Version 5.3 (IRC client for Emacs))
[04:59:47] <strcat> oh
[04:59:49] <strcat> wait
[04:59:54] <tikue> what necessitates having different iterator types?
[05:00:04] <bjz> .if_you_dont_like_this_fix_the_compiler
[05:00:05] <Eridius> tikue: they do different things?
[05:00:07] <tikue> why couldn't there be a single Iterator struct that could be in different modes 
[05:00:09] <bjz> :P
[05:00:25] <Eridius> a VecIterator iterates over a vector. an UnfoldrIterator unfolds a state into a potentially-infinite series of outputs
[05:00:35] <Eridius> a Counter emits an infinite stream of incrementing (or decrementing) numbers
[05:00:35] <Eridius> etc.
[05:00:47] <strcat> tikue: do you mean trait or implementation?
[05:00:52] <strcat> vectors have 3 iterators now
[05:00:57] <strcat> immutable, mutable and consume
[05:01:08] <tikue> what is consume?
[05:01:16] <Eridius> presumably it takes self instead of &self
[05:01:18] <strcat> it moves the vector into itself and returns by-value
[05:01:19] <Eridius> and the iterator owns the vector
[05:01:21] <strcat> without copies ofc
[05:01:26] <tikue> ah
[05:01:32] <tikue> that's nice
[05:01:36] <tikue> what is it? consume_iter()
[05:01:39] <tikue> ?
[05:01:41] <bjz> strcat: you know I was actually really annoyed by how ugly you were making rust, before I understood what you were actually doing :P
[05:01:42] * strcat forgets
[05:01:48] <strcat> bjz: :)
[05:01:49] <tikue> bjz: lol
[05:01:57] *** Quits: eatkinson (eatkinson@moz-AD233F1B.dia.static.qwest.net) (Quit: eatkinson)
[05:02:04] <tikue> bjz: the ugliness is only temporary though...right?
[05:02:07] <bjz> strcat: you are a brave man
[05:02:09] <tikue> in theory?
[05:02:16] <strcat> bjz: you know, I always kind of expected to have to remove internal iterators
[05:02:21] <bjz> tikue: yes, that is correct, thankfully
[05:02:22] <strcat> but I said they could stay around to avoid revolt
[05:02:25] <strcat> ;]
[05:02:31] <strcat> well, "have to"
[05:02:32] <bjz> :)
[05:02:52] <strcat> bjz: graydon was in the internal iterator camp originally ;p
[05:03:07] *** Quits: james4k (james@moz-E7990244.consolidated.net) (Ping timeout)
[05:03:16] <bjz> strcat: is he still, or have you won him over?
[05:03:17] <strcat> anyway one day someone should implement yield like C#'s yield
[05:03:22] *** Quits: txdv (quassel@966F3542.3BA477DA.14C26596.IP) (Ping timeout)
[05:03:23] <strcat> bjz: he was won over
[05:03:37] <strcat> well, he might still like internal iterators but I think I convinced him 'for' is a bad way to do them
[05:03:45] <strcat> because break/return are really misleading and give weird errors
[05:03:53] <bjz> mm
[05:04:01] <tikue> is C#'s yield like python's yield?
[05:04:08] <strcat> tikue: yes, but without context switch overhead
[05:04:11] <bjz> are we still going to have things like map?
[05:04:14] <strcat> tikue: C# generates a state machine from it, it's awesome
[05:04:14] *** Joins: james4k (james@moz-E7990244.consolidated.net)
[05:04:17] <tikue> strcat: that's awesome
[05:04:18] <tikue> wow
[05:04:39] <tikue> bjz: what do you mean?
[05:04:55] <tikue> bjz: or rather, why wouldn't we?
[05:05:02] <strcat> tikue: they basically just hoist your state into a struct for you
[05:05:03] <Eridius> bjz: v.iter().transform(|x| foo(x)).collect()
[05:05:08] <bjz> do x.map isn't going away is it?
[05:05:11] <strcat> and if you recurse, they build a call stack for you
[05:05:16] *** Joins: vilonis (jared@moz-EE5D17ED.ph.ph.cox.net)
[05:05:30] <tikue> bjz: well my desire would be to eventually have vec.map() return an iterator
[05:05:32] <strcat> generators can't mutually recurse since if you call another function, that function doesn't know it was called from a generator
[05:05:41] *** Joins: txdv (quassel@966F3542.3BA477DA.14C26596.IP)
[05:05:49] <strcat> so it's easy to identify actual recursion
[05:05:56] <Eridius> tikue: I think the goal is eventually to have IteratorUtil methods be callable on Iterables, so you can just say v.map(foo).collect()
[05:05:57] <tikue> strcat: python's generators can mutually recurse with yield
[05:06:08] <strcat> tikue: it's not really mutual though
[05:06:10] <strcat> tikue: like
[05:06:16] <strcat> lets say foo is a generator
[05:06:21] <strcat> foo calls bar
[05:06:28] <strcat> bar can make a new foo generator, or be a generator itself
[05:06:31] <tikue> Eridius: that'd be sooo nice
[05:06:32] *** sam113101 is now known as sam113101_afk
[05:06:53] <strcat> but it can't really go a level "deeper" into foo
[05:07:14] <tikue> strcat: i see
[05:07:19] *** sam113101_afk is now known as sam113101
[05:07:19] <strcat> since calling foo() gives you a generator with a new state
[05:08:14] <bjz> strcat: would you still be able to do vec.map(|x| x * 2)?
[05:08:30] <tikue> bjz: yea that's the goal -- see Eridius's comment @me
[05:08:37] <bjz> strcat: ie. short succinct stuff?
[05:08:47] <Eridius> bjz: it would return an Iterator, but you could .collect() it back into a vector
[05:09:00] <bjz> ha
[05:09:03] <bjz> *ah
[05:09:04] <Eridius> and it also knows how many elements the Iterator will yield so it can preallocate the resulting vector
[05:09:10] <Eridius> (because Iterator has a .size_hint method)
[05:09:18] <Eridius> which is precise for MapIterator
[05:09:42] <tikue> Eridius: does it always preallocate? isn't one advantage of iterators the fact that they don't preallocate?
[05:09:57] <Eridius> tikue: the iterator doesn't. Vec's implementation of FromIterator (used by collect) will
[05:10:05] <Eridius> since the whole point is to drain the iterator and then return a vector
[05:10:05] <tikue> Eridius: ohhh ok, cool!
[05:10:15] <tikue> that's really awesome
[05:10:25] <bjz> it's a shame to lose the succinctness though - that's the great thing about those list operations
[05:10:37] <tikue> bjz: you will be able to say iter.map()
[05:10:43] <tikue> bjz: without calling iter() first
[05:10:50] <strcat> tikue: basically it's used by collect() for things like hash tables and vectors
[05:10:50] <jmgrosen> is there any way to consume a RWARC and get its value?
[05:10:51] <bjz> but with the collect
[05:11:01] <strcat> tikue: python has it as __length_hint__
[05:11:04] <tikue> bjz: i would argue it's a feature to return an iterator with map instead of a vec
[05:11:13] <tikue> bjz: there will probably be a vec_map() 
[05:11:20] <tikue> bjz: which does the .collect() for you
[05:11:31] <strcat> tikue: http://www.python.org/dev/peps/pep-0424/ python 3.4 feature ;p, it was unofficially there though long before
[05:11:41] <Eridius> jmgrosen: how would that work? Isn't the point of ARC and RWARC that it's shared? If you consume it you're trying to move the wrapped value out
[05:11:50] <Eridius> but that would break the shared aspect
[05:11:50] <bjz> tikue: what about map being a wrapper around some other method and a collect
[05:11:52] <doomlord> http://pastebin.com/4UpRqSDi <<<< here's a minimal test of my 'conflicting trait' problem.
[05:12:04] <tikue> bjz: what do you mean?
[05:12:08] <jmgrosen> Eridius: yes, so it can't be accessed anymore
[05:12:09] <bjz> tikue: seeing as that conforms to what people expect of map
[05:12:26] <Eridius> jmgrosen: you could probably use util::swap() to replace the contained value with another one
[05:12:33] <bjz> tikue: map<->vec_map
[05:12:34] <Eridius> so if it contains a ~[T] you could swap it with ~[]
[05:12:41] <strcat> or use Option<T>
[05:12:52] <strcat> to represent the property of it maybe being there
[05:12:52] <tikue> bjz: ohhh you want map to return vec, and for there to be like a map_iter() which returns an iterator?
[05:12:52] <bjz> map would be used more, so it would be nice if it was smaller
[05:12:57] <Eridius> bjz: once Iterable works, and iterator methods work on Iterables, then I would expect .map() to give me an iterator
[05:12:59] <tikue> bjz: I'm not sure
[05:13:10] <tikue> bjz: iterators are hugely awesome. I'd probably usually want to get an iterator back, not a vec
[05:13:19] *** Joins: int3_ (int3_@moz-ABE52D50.hsd1.ca.comcast.net)
[05:13:20] <Eridius> bjz: I'm not convinced .map -> ~[T] would be more useful than .map -> Iter
[05:13:31] *** Quits: infynyxx (infynyxx@moz-E95B370B.nyc.res.rr.com) (Client exited)
[05:13:31] <tikue> bjz: as a point of comparison, python's map returns a generator in python3
[05:13:39] <tikue> bjz: and you do list(map(foo)) if you want the list
[05:13:46] <bjz> Eridius: is it so that you can chain things easier?
[05:13:52] <tikue> bjz: afaik there wasn't too much controversy regarding the change 
[05:13:55] <strcat> bjz: it's so you don't copy by default
[05:13:57] <bjz> Eridius: and more efficiently?
[05:14:04] <Eridius> bjz: or because laziness is good, or because I want to pass it to something iterator-based, etc
[05:14:06] <bjz> ahh I think I get it
[05:14:08] <strcat> bjz: makes copies painful so you think about them more
[05:14:13] <strcat> the fast look looks nicer
[05:14:19] <strcat> fast thing* 
[05:14:26] <bjz> ok, I think I change my mind :)
[05:14:28] <tikue> bjz: the reason I prefer them is because of chaining
[05:14:30] <strcat> bjz: one of the things C++ and D do is making fast operations look good
[05:14:34] <tikue> bjz: if i only had one reason to give
[05:14:36] <strcat> bjz: and making slow operations look bad
[05:14:41] <strcat> bjz: for example, sets/maps have .find()
[05:14:43] <strcat> vectors don't
[05:14:46] <strcat> you have to use std::find on them
[05:15:03] * strcat likes that property
[05:15:05] <bjz> strcat: I've changed my mind :) about .map -> Iter
[05:15:07] *** Quits: int3_ (int3_@moz-ABE52D50.hsd1.ca.comcast.net) (Ping timeout)
[05:15:10] <tikue> bjz: :D 
[05:15:10] <Eridius> \o/
[05:15:56] <bjz> strcat: I agree about the fast -> slow should also be short -> ugly
[05:16:05] <tikue> strcat: is there any concern about memory usage with lots of chained iter operations?
[05:16:06] <bjz> or I mean short -> long
[05:16:14] <tikue> strcat: because of stack growth
[05:16:16] <Eridius> tikue: iterators should all be inlinable
[05:16:16] <strcat> tikue: the actual structs are compiled out
[05:16:28] <bjz> \o/ llvm
[05:16:32] <strcat> tikue: stack growth won't be the default
[05:16:39] <strcat> well
[05:16:42] <strcat> small stacks at least
[05:16:47] <tikue> strcat: that's great to hear
[05:16:52] <strcat> well I don;t know for sure
[05:17:05] <strcat> but I do know almost everyone seems to agree that the current situation sucks
[05:17:17] <tikue> current meaning?
[05:17:18] <strcat> there's just disagreement about how useful segmented stacks are as an option
[05:17:22] <bjz> strcat Eridius tikue: thanks for changing my mind, it's always awesome when that happens
[05:17:36] <bjz> :)
[05:17:37] <strcat> tikue: slow, for no real gain because FFI means there are always large stacks
[05:17:46] <strcat> and we use FFI "too much"
[05:17:56] <tikue> bjz: I'll leave the credit to the other too :)
[05:17:58] <tikue> two*
[05:18:07] <Eridius> strcat: I still think that ditching segmented stacks makes tasks more heavy than I would like, but I admit I am leaning towards being ok with removing them
[05:18:09] <tikue> strcat: gotcha
[05:18:13] <strcat> at least if we want segmented stacks, we really need our own syscall support + allocator + I/O lib like Go
[05:18:22] <strcat> Eridius: they'd still be an option
[05:18:24] <strcat> just not the default
[05:18:27] <strcat> but...
[05:18:33] <strcat> I want __morestack gone
[05:18:33] *** Joins: infynyxx (infynyxx@DB780A29.749BA1D.DCC373F0.IP)
[05:18:43] <strcat> __morestack means you can have like a 300 byte initial stack
[05:18:57] <strcat> the alternative is guard pages + handling the signals
[05:19:03] <Eridius> strcat: any chance removing __morestack might fix the OS 10.9 issue? Since someone said they had a lot of trouble getting the DWARF stuff right for __morestack on OS X
[05:19:03] <strcat> so the smallest stack would be 8K
[05:19:09] *** Joins: pnathan1 (Adium@B9840254.2CD8A5F8.477B877D.IP)
[05:19:18] <tikue> rusti: let a = [1, 2]; let b = ['three', 'four']; for a.iter().chain_(b.iter()) |foo| { println(fmt!("%?", foo)); }
[05:19:20] -rusti- <anon>:7:34: 7:40 error: unterminated character constant
[05:19:21] -rusti- <anon>:7          let a = [1, 2]; let b = ['three', 'four']; for a.iter().chain_(b.iter()) |foo| { println(fmt!("%?", foo)); }
[05:19:21] -rusti-                                            ^~~~~~
[05:19:21] -rusti- application terminated with error code 101
[05:19:33] <tikue> what does this mean
[05:19:38] <strcat> "foo"
[05:19:39] <tikue> oh wait
[05:19:41] <strcat> 'c' is a char
[05:19:42] <tikue> heh
[05:19:51] * strcat likes not having that choice
[05:20:03] <tikue> rusti: let a = [1, 2]; let b = ["three", "four"]; for a.iter().chain_(b.iter()) |foo| { println(fmt!("%?", foo)); }
[05:20:06] -rusti- more than 5 lines of output, pastebinned: http://sprunge.us/jZTL
[05:20:17] *** Quits: infynyxx (infynyxx@DB780A29.749BA1D.DCC373F0.IP) (Ping timeout)
[05:20:24] <tikue> rusti: let a = [1, 2]; let b = ["three", "four"]; for a.iter().chain_(b.iter()).advance |foo| { println(fmt!("%?", foo)); }
[05:20:25] *** Quits: vk (vk@858480B7.B568D26C.93B001FA.IP) (Quit: vk)
[05:20:26] -rusti- more than 5 lines of output, pastebinned: http://sprunge.us/RYSh
[05:20:46] <strcat> tikue: chain needs the same yielded type for each
[05:20:48] <Eridius> strcat: if I can still explicitly request small segmented (or maybe not even segmented, just small guarded) stacks, that would help
[05:20:54] <tikue> strcat: that's what I was wondering
[05:21:04] *** Joins: erickt (erickt@8C9ECD8F.3A598286.F12515B4.IP)
[05:21:09] <strcat> Eridius: well, imo the ideal situation is...
[05:21:14] *** Quits: jmgrosen (jmgrosen@moz-848F6087.sb.sd.cox.net) (Quit: jmgrosen)
[05:21:18] <Eridius> one pattern I use in Go frequently is creating a goroutine that basically just listens on one or more input channels, does something with them, and writes to an output
[05:21:24] <strcat> large stacks by default, guard page(s) at the end, checks on any stack allocations larger than the guard size
[05:21:34] <Eridius> I don't think that's going to be as prevalent in Rust, but it's still nice to be able to basically treat a task as a data structure
[05:21:39] <strcat> and if you hit the page at the end, it faults and you handle the signal and grow the stack
[05:21:48] <strcat> and then you can add an API to make small stacks
[05:21:50] <strcat> not *as small*
[05:21:56] <strcat> but 8K, or 16K
[05:22:07] <Eridius> bleh, I'd still like the ability to request sub-page stacks
[05:22:16] <strcat> Eridius: well, that means __morestack in every fn
[05:22:24] <Eridius> although again I don't know how much this will matter in Rust
[05:22:37] *** Joins: infynyxx (infynyxx@moz-E95B370B.nyc.res.rr.com)
[05:22:49] <Eridius> strcat: screw __morestack, I want to lock my stack in to a particular small size and just fail if I try to go past ;)
[05:22:59] <strcat> if we have to choose between __morestack in every fn and 500 bytes vs 8K, imo slightly bigger stacks is better
[05:23:06] *** Quits: ilyoan (ilyoan@B4104EBB.3CC170B1.1E14B209.IP) (Quit: leaving)
[05:23:08] <strcat> Eridius: you still need a guard page
[05:23:15] <strcat> the minimum size is 2 pages
[05:23:16] <Eridius> :/
[05:23:18] *** Quits: alisdair (textual@moz-EBE9F394.bchsia.telus.net) (Quit: My MacBook Pro has gone to sleep. ZZZzzzâ€¦)
[05:23:21] <strcat> Eridius: it won't be safe without it
[05:23:47] *** Quits: erickt (erickt@8C9ECD8F.3A598286.F12515B4.IP) (Ping timeout)
[05:23:52] <strcat> you need a page you can PROT_NONE + any allocation bigger than the guard size still needs checks
[05:24:04] <strcat> because you could have a 5K uninitialized block of memory
[05:24:07] <strcat> and overshoot
[05:24:35] <strcat> Eridius: anyway __morestack can stay for now
[05:24:56] <strcat> but if it's more than 2% perf hit I will be complaining about it in a year ;p
[05:25:07] <Eridius> actually now I'm curious. is there any way right now to remove __morestack? i.e. just request huge C threads for everything?
[05:25:13] <strcat> and I'm sure some people won't accept 2%
[05:25:14] <Eridius> I want to see if __morestack is the problem on 10.9
[05:25:25] *** Quits: pnathan1 (Adium@B9840254.2CD8A5F8.477B877D.IP) (Ping timeout)
[05:25:31] <strcat> Eridius: we can remove __morestack if we use guards
[05:25:52] <strcat> Eridius: oh you mean just remove it
[05:25:52] <tikue> if i have an iterator of tuples (T, U), and I'm chaining it, what is the return type?
[05:25:54] <Eridius> strcat: no I mean right now. Any attribute or option I can use?
[05:25:58] <tikue> ChainIterator<(T, U)> ?
[05:26:00] <strcat> Eridius: don't think so
[05:26:04] <strcat> Eridius: the whole stdlib is built with it
[05:26:10] <strcat> so you wouldn't have anything to call even if you could
[05:26:19] <strcat> the runtime would break
[05:26:21] <strcat> ;p
[05:26:39] <Eridius> tikue: probably <I: Iterator<(T,U)>> ChainIterator<(T, U), I>
[05:26:54] <Eridius> but you'd have to look at the signature of chain_() to verify that
[05:27:01] <Eridius> strcat: well I'm willing to rebuild the compiler
[05:27:06] <strcat> tikue: they have extra type parameters to work around type inference bugs
[05:27:17] <strcat> Eridius: I don't think it can be trivially ripped out though
[05:27:21] <Eridius> :/
[05:27:31] <tikue> ^ most inappropriate smiley
[05:27:36] <strcat> Eridius: find where we pass asking for segmented stacks
[05:27:38] <strcat> to LLVM
[05:27:44] <strcat> but...
[05:27:47] <strcat> tasks will break, I'm sure
[05:27:54] <Eridius> bleh
[05:28:16] *** Quits: infynyxx (infynyxx@moz-E95B370B.nyc.res.rr.com) (Client exited)
[05:29:27] <tikue> rusti: fn chain() -> ChainIterator<uint, Iterator<uint>, Iterator<uint>> { let a = [1]; let b = [2]; a.iter().chain_(b.iter()) }
[05:29:28] -rusti- <anon>:7:23: 7:74 error: use of undeclared type name `ChainIterator`
[05:29:29] -rusti- <anon>:7          fn chain() -> ChainIterator<uint, Iterator<uint>, Iterator<uint>> { let a = [1]; let b = [2]; a.iter().chain_(b.iter()) }
[05:29:29] -rusti-                                 ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
[05:29:29] -rusti- error: aborting due to previous error
[05:29:29] -rusti- application terminated with error code 101
[05:29:59] <tikue> rusti: fn chain() -> std::iterator::ChainIterator<uint, std::iterator::Iterator<uint>, std::iterator::Iterator<uint>> { let a = [1]; let b = [2]; a.iter().chain_(b.iter()) }
[05:30:00] -rusti- more than 5 lines of output, pastebinned: http://sprunge.us/RiAY
[05:30:07] *** Quits: posco (oscarboyki@moz-121FFE47.hsd1.ca.comcast.net) (Ping timeout)
[05:30:17] *** Quits: yichoi (yichoi@5AB4884B.FCC4549.14D5B978.IP) (Quit: yichoi)
[05:30:35] <strcat> rusti: 2
[05:30:36] -rusti- 2
[05:30:38] *** Joins: posco (oscarboyki@EFB8C867.BA834BE4.71743E61.IP)
[05:31:05] <strcat> rusti: let xs = [1, 2, 3]; let mut it = xs.iter(); println(fmt!("%?", it.next()))
[05:31:06] -rusti- Some(&1)
[05:31:06] -rusti- ()
[05:31:20] <strcat> rusti: let xs = [1, 2, 3]; let mut it = xs.iter(); println(fmt!("%?", it.next())); println(fmt!("%?", it.next()))
[05:31:21] -rusti- Some(&1)
[05:31:21] -rusti- Some(&2)
[05:31:21] -rusti- ()
[05:31:36] <strcat> rusti: let xs = [1, 2, 3]; let mut it = xs.iter(); println(fmt!("%?", it.next())); println(fmt!("%?", it.next())); println(fmt!("%?", it.next_back()))
[05:31:37] -rusti- more than 5 lines of output, pastebinned: http://sprunge.us/bScI
[05:31:49] <strcat> oh not in prelude yet
[05:32:05] <strcat> rusti: use std::iterator::DoubleEndedIterator; let xs = [1, 2, 3]; let mut it = xs.iter(); println(fmt!("%?", it.next())); println(fmt!("%?", it.next())); println(fmt!("%?", it.next_back()))
[05:32:05] -rusti- Some(&1)
[05:32:06] -rusti- Some(&2)
[05:32:06] -rusti- Some(&3)
[05:32:06] -rusti- ()
[05:32:21] <tikue> rusti: fn chain() -> std::iterator::ChainIterator<uint, @std::iterator::Iterator<uint>, @std::iterator::Iterator<uint>> { let a = [1]; let b = [2]; a.iter().chain_(b.iter()) }
[05:32:22] -rusti- line longer than 150 columns, pastebinned: http://sprunge.us/WdCV
[05:32:26] <Eridius> tikue: stahp
[05:32:32] <strcat> rusti: use std::iterator::DoubleEndedIterator; let xs = [1, 2, 3]; let mut it = xs.iter(); println(fmt!("%?", it.next())); for 2.times { println(fmt!("%?", it.next_back())) }
[05:32:33] -rusti- Some(&1)
[05:32:33] -rusti- Some(&3)
[05:32:33] -rusti- Some(&2)
[05:32:33] -rusti- ()
[05:32:34] <Eridius> tikue: you have to replace the embedded iterators with VecIterator<uint>
[05:32:35] <tikue> Eridius: ?
[05:32:46] <Eridius> tikue: but if you solve this you're just going to run into borrowck errors
[05:32:51] <Eridius> because your vec iterators return &uint
[05:33:06] <Eridius> and you can't return that out from the function
[05:33:07] <tikue> Eridius: so what you're saying is I can't have a function which returns an iterator?
[05:33:20] <strcat> you can
[05:33:20] <Eridius> well you can, but you have to be careful around pointer lifetimes
[05:33:29] <strcat> vector iterators use &
[05:33:31] <Eridius> tikue: in this particular case you probably want to use .consume_iter() on your vectors
[05:33:33] <strcat> so you need lifetime params
[05:33:44] <ChrisMorgan> Eridius: r? https://github.com/mozilla/rust/pull/7742
[05:33:50] <strcat> VecIterator<'self, T> yields &'self T
[05:33:54] <strcat> they don't just have a type param
[05:33:59] <tikue> rusti: fn chain() -> std::iterator::ChainIterator<uint, @std::iterator::Iterator<uint>, @std::iterator::Iterator<uint>> { let a = [1]; let b = [2]; a.iter().chain_(b.iter()) }
[05:34:00] -rusti- line longer than 150 columns, pastebinned: http://sprunge.us/UUWF
[05:34:01] <tikue> woops
[05:34:01] <tikue> sorry
[05:34:03] <Eridius> ChrisMorgan: I'll read your PR, but I can't review
[05:34:05] <tikue> rusti: fn chain() -> std::iterator::ChainIterator<uint, @std::iterator::Iterator<uint>, @std::iterator::Iterator<uint>> { let a = [1]; let b = [2]; a.iter().chain_(b.iter()) }
[05:34:06] -rusti- line longer than 150 columns, pastebinned: http://sprunge.us/ZfMC
[05:34:06] <tikue> wtf
[05:34:09] <tikue> shift enter doesn't work
[05:34:14] <Eridius> tikue:  don't use @Iterator.
[05:34:21] <ChrisMorgan> Eridius: you can try it out
[05:34:23] <tikue> Eridius: I just copypastad twice by accident
[05:34:34] <Eridius> tikue: even if you get the types right, you _cannot_ return a VecIterator unless it has a lifetime tied to one of your input params
[05:34:40] <Eridius> because your vectors are on the stack, and they'll disappear
[05:34:47] <Eridius> hence VecConsumeIterator
[05:34:55] <tikue> Eridius: I heard you the first time, I didn't mean to enter that again. 
[05:35:28] <Eridius> rusti: use std::iterator::ChainIterator; use std::vec::VecConsumeIterator; fn chain() -> ChainIterator<uint, VecConsumeIterator<uint>, VecConsumeIterator<uint>> { let a = [1]; let b = [2]; a.consume_iter().chain_(b.consume_iter()) }
[05:35:29] -rusti- more than 5 lines of output, pastebinned: http://sprunge.us/ajgG
[05:35:52] <Eridius> rusti: use std::iterator::ChainIterator; use std::vec::VecConsumeIterator; fn chain() -> ChainIterator<uint, VecConsumeIterator<uint>, VecConsumeIterator<uint>> { let a = ~[1]; let b = ~[2]; a.consume_iter().chain_(b.consume_iter()) }; chain().collect::<~[uint]>()
[05:35:53] -rusti- line longer than 150 columns, pastebinned: http://sprunge.us/bEaf
[05:36:12] <Eridius> rusti: use std::iterator::ChainIterator; use std::vec::VecConsumeIterator; fn chain() -> ChainIterator<uint, VecConsumeIterator<uint>, VecConsumeIterator<uint>> { let a = ~[1u]; let b = ~[2u]; a.consume_iter().chain_(b.consume_iter()) }; chain().collect::<~[uint]>()
[05:36:12] -rusti- ~[1, 2]
[05:36:16] <Eridius> tikue: ^
[05:37:19] <tikue> Eridius: thank you! I assume the type parameters will improve in the future?
[05:37:30] <Eridius> tikue: I don't know
[05:38:51] <strcat> you can definitely return a VecIterator. you just need to pass a lifetime
[05:39:17] <strcat> fn foo<'r>(xs: &'r [int]) -> VecIterator<'r, int>
[05:40:11] *** Quits: bytbox (s@moz-DC83764A.washdc.fios.verizon.net) (Ping timeout)
[05:40:25] <tikue> strcat: my use case is making a helper method on a struct that chains two vectors that are fields of the struct
[05:40:27] <tikue> so would that be
[05:40:45] <tikue> fn foo<'r>(&'r self) -> VecIterator<'r, int>
[05:40:54] <tikue> wait, why VecIterator and not ChainIterator?
[05:41:03] <strcat> oh you want chain
[05:41:10] <strcat> well something like
[05:41:22] <strcat> fn foo(&self) -> ChainIterator<'self, int>
[05:41:29] <strcat> on an impl with
[05:41:36] <strcat> Foo<'self> as your type
[05:41:45] <strcat> and 'self on the interior VecIterators
[05:42:13] <Eridius> fn foo(&self) -> ChainIterator<&'sef int, VecIterator<'self, int>, VecIterator<'self, int>>
[05:42:17] <Eridius> I believe taht's correct
[05:42:21] <Eridius> err self, not sef
[05:42:29] <Eridius> note of course that the chain returns &int instead of int
[05:43:10] <strcat> sadly that first type param is only around as a workaround
[05:43:18] *** Quits: sankha93 (Instantbir@FD84119E.C0D45E01.EFB84E89.IP) (Quit: He will be back!)
[05:43:24] *** Quits: aatch (aatch@moz-B437F499.pocketrent.com) (Client exited)
[05:43:41] <Eridius> strcat: it may be a workaround but I'm not that broken up about it, because it's a nice reference for what the result type is
[05:45:11] <Eridius> ChrisMorgan: ok just had a chance to look at your PR. And I'm not even going to pretend I bothered to try and understand those region definitions ;)
[05:45:13] <strcat> but it makes you be explicit about lifetimes sometimes, when you wouldn't otherwise have to
[05:45:19] <tikue> https://gist.github.com/tkuehn/57d8d20f806a33b1db2f
[05:45:21] <tikue> does that look right?
[05:45:23] <Eridius> ChrisMorgan: but I'll try it out later. it's raid time for me (WoW) so I can't go experimenting right now
[05:45:51] <strcat> tikue: if it compiles ;p
[05:45:59] <tikue> strcat: I'm no where near a buildable state :(
[05:46:09] <strcat> tikue: it looks right
[05:46:12] <Eridius> tikue: if the types match your parent_pipelines and iframe_pipelines fields, then looks good to me
[05:46:14] <tikue> strcat: thank you
[05:46:18] * strcat isn't a good compiler though ;]
[05:46:20] <tikue> Eridius: thank you :)
[05:46:23] <Eridius> actually no, it's not quite right
[05:46:29] <tikue> Eridius: oh?
[05:46:32] <Eridius> 'self isn't actually defined
[05:46:37] <tikue> ahhh
[05:46:38] <strcat> 'self comes from the impl
[05:47:03] <strcat> he needs to have "impl<'self> Foo<'self>"
[05:47:08] <strcat> in order to have contained VecIterator
[05:47:15] <strcat> because they demand a 'self param when you have them as fields
[05:47:20] <tikue> strcat: right, that makes sense
[05:47:36] <Eridius> strcat: ok so `fn get_all_pipelines<'a>(&'a self) -> ChainIterator<&'a (Pip...` wouldn't work?
[05:47:41] <Eridius> is this part of the magic of 'self?
[05:47:49] <strcat> Eridius: well, "magic"
[05:47:59] <strcat> Eridius: the region on ChainIterator doesn't refer to the lifetime on &self
[05:48:06] <strcat> it could
[05:48:09] <Eridius> I thought the other day I was told that 'self is only magical because trait impls can only accept 'self and 'static
[05:48:10] *** Joins: tehgeekmeister (tehgeekmei@C8D8A256.C7E2E9C1.1A968954.IP)
[05:48:18] <strcat> Eridius: right, but 'self isn't magic
[05:48:24] <Eridius> strcat: ChainIterator doesn't have a region. It has a type, which happens to be a pointer that has a region
[05:48:26] <strcat> Eridius: what you wrote will work in the future
[05:48:29] <Eridius> and that pointer's region comes from the VecIterator
[05:48:39] <Eridius> and the VecIterator's region comes from the vector, which is a field of self
[05:48:43] <strcat> Eridius: sure
[05:48:46] <strcat> it functionally the same
[05:48:48] <Eridius> so it seems like it _should_ work. I just don't know if it does
[05:48:53] <strcat> Eridius: it will
[05:48:55] <strcat> not yet
[05:48:59] <strcat> but 'self is already defined in that scope
[05:49:01] <strcat> on the impl
[05:49:04] <strcat> he *has* to define it there
[05:49:19] <tehgeekmeister> if you have fn foo () { Some(1) }; bar = ~foo;, does the compiler optimize the stack allocation away, or what happens there?
[05:49:20] <strcat> he has
[05:49:37] <strcat> struct Foo<'self> { x: VecIterator<'self, int>, ... }
[05:49:39] <tehgeekmeister> (super simplified example, can give more detail if need be)
[05:49:48] <strcat> and impl<'self> Foo<'self> { }
[05:50:11] <strcat> Eridius: &self isn't actually tied to the inner lifetimes by default
[05:50:26] <strcat> Eridius: a pointer returned from a VecIterator has to be outlived by the vector
[05:50:30] <strcat> the iterator can go out of scope
[05:50:42] <strcat> in fact it views .next() as ending the life of the iterator because it's &mut self
[05:51:08] <strcat> anyway that stuff is very fragile
[05:51:18] <strcat> it forces you to use methods instead of functions for one thing
[05:51:27] <strcat> you can't refer to 'self from a free function
[05:51:45] * strcat shrugs
[05:51:53] <strcat> it used to work "better" when it was broken
[05:53:05] <strcat> rusti: struct Foo; let xs = ~[Foo, Foo, Foo]; println(fmt!("%?", xs.slice(0, 2).to_owned())) // prints `~[]`
[05:53:06] -rusti- ~[]
[05:53:06] -rusti- ()
[05:53:20] <tikue> thanks for your help guys
[05:53:47] *** Quits: tikue (tkuehn@moz-BBE3ABD.mv.mozilla.com) (Quit: tikue)
[05:54:36] *** Quits: Jesse_ (jruderman@moz-BBE3ABD.mv.mozilla.com) (Quit: Jesse_)
[05:55:12] *** Joins: alisdair (textual@moz-EBE9F394.bchsia.telus.net)
[05:58:13] *** Joins: eatkinson (eatkinson@moz-AD233F1B.dia.static.qwest.net)
[05:58:14] <Eridius> strcat: you can't use 'self from a free function? interesting. That explains some things
[05:58:21] *** Quits: fabiand_ (fabiand@moz-680BCD95.adsl.alicedsl.de) (Quit: Verlassend)
[05:58:36] *** Joins: fabiand (fabiand@moz-680BCD95.adsl.alicedsl.de)
[05:58:49] <Eridius> it certainly explains why I was incapable of writing Encoder.encode_chars(), and instead had to write vec.encode_as()
[05:59:02] *** Quits: fabiand (fabiand@moz-680BCD95.adsl.alicedsl.de) (Quit: Verlassend)
[05:59:14] <Eridius> of course a VecCloneIterator (which I still want to make) would have solved that too, because then no lifetime issues
[05:59:30] <Eridius> although that's actually a lie, isn't it? It still has an internal reference to the vector. dammit
[05:59:37] <strcat> yeah
[05:59:45] *** Joins: fabiand (fabiand@moz-680BCD95.adsl.alicedsl.de)
[05:59:49] <strcat> only consume doesn't
[06:00:08] <strcat> iterators hit a lot of rough edges and bugs
[06:00:08] *** Joins: vk (vk@moz-389FEE13.hsd1.ca.comcast.net)
[06:00:28] <strcat> especially considering I put iterators into the stdlib shortly after niko fixed borrowck enough
[06:00:36] <strcat> we had them as soon as we could
[06:00:39] <strcat> ;p
[06:01:05] <strcat> 8bf9fc52f405f2a825cbf2692d872e9e710999b5 was the initial commit of it
[06:01:48] *** Quits: etw (john@moz-B2936CAB.nyc.res.rr.com) (Ping timeout)
[06:01:59] <strcat> 49de82cdca2064a909d3104f4e5eccacb0425fd0 was the commit fixing borrowck
[06:02:42] <strcat> the date is wrong because it doesn't know I wrote it too early (didn't work yet) and amended it :)
[06:02:49] <Eridius> hehe
[06:02:55] <Eridius> committer date ftw
[06:03:03] <ronny> btw, is there anything reason for introducing something like iterable.each again? or each(iterable)?
[06:03:18] <strcat> ronny: there will be a new for loop
[06:03:27] <strcat> the current for loop is obsolete, so it needs .advance
[06:03:31] <ronny> because writing for vec.iter().advance is strange
[06:03:54] <strcat> ronny: it needs to be that way to migrate to a new one
[06:04:07] <ronny> i see, the new one will be in 0.8 i suppose?
[06:04:14] <strcat> hopefully.
[06:04:27] <strcat> I hoped it would be in 0.7 :(
[06:06:22] *** Quits: vk (vk@moz-389FEE13.hsd1.ca.comcast.net) (Quit: vk)
[06:06:50] *** Joins: jaen (jaen@moz-1AF55B54.neoplus.adsl.tpnet.pl)
[06:08:43] *** Joins: vk (vk@moz-389FEE13.hsd1.ca.comcast.net)
[06:11:51] *** Quits: vk (vk@moz-389FEE13.hsd1.ca.comcast.net) (Quit: vk)
[06:13:44] *** Joins: pnkfelix (pnkfelix@moz-43495417.fbx.proxad.net)
[06:14:54] *** Joins: vk (vk@moz-389FEE13.hsd1.ca.comcast.net)
[06:18:52] *** Joins: infynyxx (infynyxx@DB780A29.749BA1D.DCC373F0.IP)
[06:19:28] *** Joins: hjr3 (hradtke@moz-E87BDF1F.socal.res.rr.com)
[06:19:32] *** Quits: Jeaye (Jeaye@moz-FD505E54.hsd1.ca.comcast.net) (Quit: zzz)
[06:19:50] *** Joins: LimeBurst (me@247D1419.D73964AC.27A8748.IP)
[06:20:39] *** Quits: infynyxx (infynyxx@DB780A29.749BA1D.DCC373F0.IP) (Ping timeout)
[06:22:20] <strcat> acrichto: I don't think it's repr's fault btw
[06:22:24] <strcat> I don't really understand why it's broken
[06:22:30] *** Joins: erickt (erickt@8C9ECD8F.3A598286.F12515B4.IP)
[06:22:34] <acrichto> although fmt! is definitely using repr
[06:22:43] *** Quits: mcguire (Mibbit@moz-68F146AD.dyn.centurytel.net) (Quit: http://www.mibbit.com ajax IRC Client)
[06:22:53] <strcat> but assert_eq! fails - does it use the iterator?
[06:22:56] * strcat looks
[06:23:05] <acrichto> it should
[06:23:22] <strcat> ah it does
[06:23:35] <acrichto> oh wait no
[06:23:40] <acrichto> assert_eq on vecs does
[06:23:42] <acrichto> but this is on strings
[06:23:47] <strcat> oh
[06:24:09] <acrichto> rusti: struct Foo; fmt!("%?", ~[Foo, Foo, Foo])
[06:24:10] -rusti- ~"~[{}, {}, {}]"
[06:24:15] <acrichto> ...?
[06:24:32] <strcat> rusti: struct Foo; let xs = ~[Foo, Foo, Foo]; xs.slice(0, 2).to_owned()
[06:24:33] -rusti- ~[]
[06:24:34] *** Quits: cubic_ (cubic@moz-FE5AD6C7.mc.videotron.ca) (Connection reset by peer)
[06:24:58] <acrichto> that's iteration
[06:25:16] *** Quits: erickt (erickt@8C9ECD8F.3A598286.F12515B4.IP) (Ping timeout)
[06:25:20] <acrichto> rusti: struct Foo; let xs = ~[Foo, Foo, Foo]; fmt!("%?", xs.slice(0, 2).to_owned())
[06:25:22] -rusti- ~"~[]"
[06:25:24] <acrichto> or not
[06:25:26] <strcat> to_owned uses from_fn
[06:25:31] <strcat> and that rolls a loop itself
[06:26:10] <acrichto> although the loop is around elements
[06:26:13] <acrichto> not pointers
[06:27:43] <acrichto> rusti: struct Foo; std::vec::from_fn(2, |_| Foo)
[06:27:44] -rusti- ~[{}, {}]
[06:28:17] <acrichto> rusti: struct Foo; (~[Foo, Foo, Foo]).len()
[06:28:22] -rusti- 3
[06:28:40] <acrichto> rusti: struct Foo; (~[Foo, Foo, Foo])[1]
[06:28:41] -rusti- {}
[06:29:10] <acrichto> rusti: struct Foo; (~[Foo, Foo, Foo]).slice(0, 2).len()
[06:29:12] -rusti- more than 5 lines of output, pastebinned: http://sprunge.us/LdcU
[06:29:29] <acrichto> rusti: struct Foo; let xs = ~[Foo, Foo, Foo]; xs.slice(0, 2).len()
[06:29:30] -rusti- 2
[06:29:57] <acrichto> strcat: I'm having trouble seeing where to_owned is going wrong
[06:31:12] *** Joins: etw (john@moz-B2936CAB.nyc.res.rr.com)
[06:31:31] *** Joins: Jesse (jruderman@moz-537BCF9.hsd1.ca.comcast.net)
[06:32:52] <strcat> yeah I haven't really looked into it
[06:33:00] <strcat> I just noticed a few things were broken after being told about iterators
[06:33:08] <acrichto> I'll look into it later, I'll try see if it's hitting an iterator
[06:33:11] <strcat> acrichto: oh
[06:33:14] <strcat> acrichto: there's a *second* to_owned
[06:33:21] <acrichto> ...?
[06:33:28] <acrichto> welp
[06:33:28] <strcat>     from_fn(t.len(), |i| copy t[i])
[06:33:30] <strcat> this is one
[06:33:31] <acrichto> there we go
[06:33:33] <acrichto> that's it
[06:33:33] <strcat> the other does use iterators
[06:33:35] <strcat> ;p
[06:33:41] <strcat> ughhhh duplication
[06:34:41] *** Joins: ilyoan (ilyoan@B4104EBB.3CC170B1.1E14B209.IP)
[06:34:44] <strcat> acrichto: there are ways we can implement it without a counter though, but it requires special-casing zero-size afaict :(
[06:35:05] <acrichto> I'll think on it b/c you're right that iteration should be fast
[06:35:23] <strcat> acrichto: for example if the zero-size one was able to *just* use a counter
[06:35:38] <strcat> it'd suck at --opt-level=0
[06:35:42] <strcat> a branch on sizeof
[06:36:02] <strcat> going 1 or 2 off the end of an array is fine, but not N
[06:36:13] <strcat> it's okay to have * pointers to invalid things but it could wrap
[06:36:48] <strcat> C++ defines 1-past-the-end as valid
[06:36:51] <strcat> but nothing else
[06:37:35] <strcat> zero-sized things are a bit weird
[06:37:41] <acrichto> yeah they are odd
[06:37:48] <acrichto> ~[T] should == int
[06:37:53] <strcat> it means ref_eq is a bit weird
[06:38:12] <strcat> rusti: let x: *() = &(); x
[06:38:13] -rusti- 0
[06:38:24] <strcat> rusti: let x: *() = &(); let y: *() = &(); x
[06:38:25] -rusti- <anon>:7:31: 7:32 warning: unused variable: `y` [-W unused-variable (default)]
[06:38:26] -rusti- <anon>:7          let x: *() = &(); let y: *() = &(); x
[06:38:26] -rusti-                                         ^
[06:38:26] -rusti- 0
[06:38:30] <strcat> rusti: let x: *() = &(); let y: *() = &(); (x, y)
[06:38:31] -rusti- ((0x0 as *()), (0x0 as *()))
[06:38:47] <strcat> rusti: struct Foo; let x: *Foo = &Foo; let y: *Foo = &Foo; (x, y)
[06:38:47] <eevee> hmm i do not know how to deal with borrows and lifetimes here
[06:38:48] -rusti- ((0x1c6ff70 as *()), (0x1c6ff60 as *()))
[06:38:50] *** Joins: paupau (NEAT@moz-C616DA0A.hsd1.ca.comcast.net)
[06:38:54] <strcat> that's really weird
[06:38:55] <acrichto> whoa
[06:39:17] <acrichto> also argh github git clone bounced the current pull req
[06:39:17] <strcat> the point to arbitrary garbage :)
[06:39:58] <eevee> i have a Terminal, and it can spawn Canvases which want to refer to the Terminal, and also the Canvas contains some arbitrary Drop things which also refer to the Terminal
[06:40:01] *** Joins: Cromulent (Cromulent@moz-983B638D.cable.virginmedia.com)
[06:40:21] <eevee> and i was hoping to solve this without slapping @ everywhere, but the only way to do so seems to be to have everything borrow the Terminal, and i don't see how that can work
[06:40:54] *** Joins: ghrust (ghrust@CFE85B59.6A2AE50.F3114085.IP)
[06:40:55] <ghrust> 01[13rust01] 15thestinger pushed 1 new commit to 06master: 02http://git.io/dORjDA
[06:40:55] <ghrust> 13rust/06master 14cc4baac 15Daniel Micay: Merge pull request #7679 from alexcrichton/consume-smallintmap...
[06:40:55] *** Parts: ghrust (ghrust@CFE85B59.6A2AE50.F3114085.IP) ()
[06:41:04] <strcat> acrichto: there, it passed on all the others
[06:41:10] <acrichto> strcat: haha, thanks
[06:41:36] <strcat> silly rustpkg tests
[06:42:06] <strcat> bors might have a panic attack though
[06:43:08] <strcat> acrichto: so, the ptr offset thing won't work because fixed-size arrays are actually 0 size and we might want that for non-fixed too
[06:43:26] <thiez> what are the write barriers that are mentioned in the GC discussions?
[06:43:44] <strcat> acrichto: it's a bit weird that they point at arbitrary memory.
[06:43:47] *** Joins: ghrust (ghrust@E7A4CCE2.6A2AE50.F3114085.IP)
[06:43:47] <ghrust> 01[13rust01] 15bors pushed 3 new commits to 06auto: 02http://git.io/pYWg5w
[06:43:47] <ghrust> 13rust/06auto 148dc6445 15Corey Richardson: Change the assert_eq message to be more verbose....
[06:43:47] <ghrust> 13rust/06auto 1426f0a55 15Corey Richardson: fix test
[06:43:47] <ghrust> 13rust/06auto 140939477 15bors: auto merge of #7695 : cmr/rust/assert_eq_msg, r=pnkfelix...
[06:43:49] *** Parts: ghrust (ghrust@E7A4CCE2.6A2AE50.F3114085.IP) ()
[06:43:49] <acrichto> strcat: yeah the length has to be used somewhow
[06:43:57] <strcat> acrichto: well it could be shoved in a ptr
[06:44:02] <strcat> acrichto: ptr could be 0, end could the length
[06:44:12] <strcat> they'd be arbitrary as they are now ;p, but that might be a bug
[06:44:32] <strcat> also, offset would have to be changed
[06:44:41] * strcat shrugs
[06:46:05] <thiez> because with thread-local GC (which I was under the impression we would use) it would be pointless to have write barriers, would it not? since the GC could run on the same thread that is paused, and each cpu sees its own writes and reads in the order they were executed
[06:46:25] <thiez> or will there be a separate GC thread?
[06:47:03] <strcat> thiez: I think it's to do incremental gc
[06:47:06] *** Quits: vk (vk@moz-389FEE13.hsd1.ca.comcast.net) (Quit: vk)
[06:47:11] *** Quits: eatkinson (eatkinson@moz-AD233F1B.dia.static.qwest.net) (Quit: eatkinson)
[06:47:32] <strcat> so I'm assuming that means it will hand you control, and you might touch something relevant to it?
[06:47:39] * strcat doesn't know much about gc
[06:48:02] <strcat> you can ask pcwalton or nmatsakis tommorow ;]
[06:48:17] *** Joins: vk (vk@moz-389FEE13.hsd1.ca.comcast.net)
[06:48:18] <thiez> I suppose I will
[06:48:21] <thiez> thanks anyway :)
[06:49:19] <pnkfelix> thiez: Yes, its to support either or both of Incremental and/or Generational GC
[06:49:33] <pnkfelix> thiez: I think pcwalton's original message at the outset said that
[06:51:12] *** Quits: slaren (x@moz-5047427A.red-95-120-32.dynamicip.rima-tde.net) (Ping timeout)
[06:54:07] <thiez> neither of those would have to run on a separate thread, would they? Since you can't send @ to another task and the task you are GC'ing has to be stopped anyway, the incremental and/or generational GC could run on the task's thread
[06:54:17] *** Quits: eternaleye (eternaleye@moz-76321711.hsd1.wa.comcast.net) (Ping timeout)
[06:54:22] <pnkfelix> thiez: pcwalton has said that what he really cares about is Incremental GC. Each task would take care of GC'ing its own task-local heap, and that wouldn't be implemented as a concurrent GC; instead the GC and the task/mutator would be coroutines on the same thread.
[06:54:49] <strcat> pnkfelix: any idea how it would actually switch between the gc and the task?
[06:54:58] *** Joins: eternaleye (eternaleye@moz-76321711.hsd1.wa.comcast.net)
[06:55:04] <thiez> with coroutines you wouldn't need a write barrier, unless 'write barrier' means something different in the context of GC
[06:55:15] <strcat> oh maybe just possible yields on allocations/deallocations of @
[06:55:22] * strcat shrugs
[06:55:31] <pnkfelix> strcat: I was imagining it would do it much the same way as most other non-concurrent GC's: the GC coroutine would be attached at allocation points
[06:56:14] <strcat> pnkfelix: yeah that makes sense
[06:56:15] <pnkfelix> strcat: as in, once you pass a certain threshold of live data, the GC gets some work cycles on every alloc 
[06:56:24] <strcat> local_malloc can just possibly yield to gc
[06:56:37] <pnkfelix> thiez: You still need a write-barrier for incremental and generational GC, even when its a coroutine
[06:56:53] <thiez> pnkfelix: could you explain why?
[06:57:03] <strcat> you can have data races with only concurrency and not parallelism
[06:57:07] <pnkfelix> thiez: The write-barrier is how you maintain the GC meta data to support incremental behavior
[06:57:36] <pnkfelix> thiez: e.g., lets consider Generational collection
[06:58:00] <pnkfelix> thiez: In that context, the idea is to focus GC effort on just a subset of the heap, called the nursery, where the young objects are located
[06:58:09] *** Joins: seth (seth@56F14A79.8B5A9B2B.AD6E18E9.IP)
[06:58:42] <pnkfelix> thiez: such a nursery-focused GC is called a "Minor GC"
[06:58:43] <paupau> eevee: rust probably needs weak pointers :)
[06:59:16] <pnkfelix> thiez:  During a Minor GC you need to find all the live references into the nursery.  But you cannot afford to scan the entire heap to look for them: that would defeat the point, because you want to do O(NurserySize) work, not O(HeapSize) work
[06:59:30] <strcat> paupau: extra::rc could offer them but it would add overhead
[06:59:35] <strcat> the box would need a list ptr
[06:59:47] <strcat> or you could do it the weird libstdc++ wa
[06:59:49] <pnkfelix> thiez: So instead of scanning the entire heap during a MinorGC, you maintain meta-data for the GC as the system runs
[06:59:49] <strcat> y
[06:59:50] <thiez> paupau: we have those, just cast to int or uint, then xor themm with -1, the GC won't see the pointer :p
[07:00:17] <strcat> thiez: that's likely undef behaviour, LLVM won't see it either
[07:00:31] <paupau> thiez: hehe
[07:00:32] <thiez> okay so you maintain the meta-data
[07:00:53] <pnkfelix> thiez: this particular meta-data for a Generational GC is often called a "remembered set": It keeps track, conservatively, of the objects outside the nursery (called "tenured objects") that have references to objects inside the nursery
[07:01:22] <paupau> strcat: yeah the referent needs to track its referers
[07:02:09] <pnkfelix> thiez: or rather, tenured objects that *might* have references to objects in the nursery.  (That why i said "conservatively" above)
[07:02:53] <strcat> paupau: and weak pointers add some semantic issues compared with gc
[07:02:54] <pnkfelix> thiez: the typical remembered set invariant is: If tenured(A) and non-tenured(B) and A has-ptr-to B, then A must be in remembered set
[07:03:07] <strcat> because deref has to fail if the object is already gone
[07:03:11] <pnkfelix> thiez: but the implication is not bi-directional
[07:03:13] <strcat> unless you use Option, I guess
[07:03:21] <pnkfelix> thiez: (thats again the conservative aspect of this)
[07:03:33] <paupau> strcat: yeah, dereferencing would return Option
[07:03:46] <pnkfelix> thiez: So: If you maintain that remembered set invariant, then: On every Minor GC, instead of scanning the entire heap for references into the nursery
[07:03:50] <tehgeekmeister> an owned pointer can't point to the stack, can it?
[07:03:56] <strcat> paupau: and it has to hand you an Rc
[07:03:59] <pnkfelix> thiez: you can instead just scan the objects that are tracked in the remembered set
[07:03:59] <strcat> like in C++
[07:04:01] <thiez> you can scan the tenured set
[07:04:03] <thiez> eh, yes
[07:04:04] <thiez> that one
[07:04:08] <strcat> fn get(&self) -> Option<Rc<T>>
[07:04:10] <strcat> I guess
[07:04:20] <pnkfelix> thiez: So then the question is: How do you correctly maintain this remembered set?
[07:04:38] <paupau> strcat: it would be neat if you could borrow out of get() *SOMEHOW* but yeah otherwise it might die in the meantime
[07:04:54] <pnkfelix> thiez: And one answer is: If you always ensure the entire nursery is empty at the end of every Minor GC (e.g. by tenuring every potentially reachable object in the nursery)
[07:05:33] <pnkfelix> thiez: then after every Minor GC, you can clear the remembered set.  (Because that still satisfies the remembered set invariant, trivally.)
[07:05:44] *** Quits: seth (seth@56F14A79.8B5A9B2B.AD6E18E9.IP) (Input/output error)
[07:06:04] <strcat> I hope how useful generational gc would be in rust
[07:06:08] <pnkfelix> thiez: I should have said "immediately after every Minor GC, you can clear the remembered set"; as in, before the mutator coroutine in the tasks gets to do anything
[07:06:14] <strcat> since you have a lot of ways to not use gc
[07:06:17] *** Joins: int3_ (int3_@moz-ABE52D50.hsd1.ca.comcast.net)
[07:06:22] <strcat> like using Rc for long-lived, large objects
[07:06:26] *** Quits: vk (vk@moz-389FEE13.hsd1.ca.comcast.net) (Quit: vk)
[07:06:42] <pnkfelix> thiez: then, as the mutator runs
[07:06:48] *** Quits: eternaleye (eternaleye@moz-76321711.hsd1.wa.comcast.net) (Ping timeout)
[07:06:49] <strcat> I wonder how useful*
[07:06:53] <strcat> ugh, tired :)
[07:06:54] <paupau> strcat: I wouldn't use it in the view stack but I would @ everything in the model layer
[07:06:58] <pnkfelix> thiez: every time there's an object modification A.field = B
[07:07:05] <strcat> pnkfelix: why?
[07:07:07] <strcat> paupau: *
[07:07:26] <strcat> @ is usually more painful to use than ~ because it's immutable
[07:07:34] <pnkfelix> thiez: you use the write barrier to inspect the situation.  If tenured(A) and non-tenured(B), then add &A to the remembered set.
[07:07:36] <strcat> or with @mut it fails dynamically
[07:07:39] <paupau> strcat: model observation is messy
[07:07:43] <strcat> paupau: ah
[07:07:48] <pnkfelix> thiez: and that preserves the remembered set invariant
[07:07:53] *** Quits: alisdair (textual@moz-EBE9F394.bchsia.telus.net) (Quit: My MacBook Pro has gone to sleep. ZZZzzzâ€¦)
[07:08:09] <paupau> strcat: and then there are nice things like undo stacks to worry about
[07:08:20] <thiez> oh, so we're not talking about the 'write all pending writes to memory' cpu-instruction write-barrier xD
[07:08:26] <strcat> paupau: vim/emacs do undo trees ;p
[07:08:28] <pnkfelix> strcat: pcwalton is thinking along similar lines, that Gen GC may not be as vital for Rust as it is for some other language runtimes and/or GC strategies.
[07:08:43] <strcat> paupau: so essentially a persistent n-ary tree
[07:08:52] <paupau> strcat: I gotta one-up that, do undo graphs
[07:08:53] <strcat> of diffs
[07:08:55] <pnkfelix> thiez: no these are typically GC-specific software write-barriers that we are talking about
[07:09:06] <pnkfelix> thiez: I can see the reason for confusion though
[07:09:08] <paupau> strcat: causality can bite it
[07:09:10] <thiez> well that explains :)
[07:09:13] <strcat> paupau: :)
[07:09:19] <thiez> thanks for the detailed explanation
[07:09:20] <strcat> I love undo trees though
[07:09:31] <strcat> I use it once a month to recover from a dumb undo/redo cycle
[07:09:41] <strcat> other than that... not really
[07:09:50] <paupau> strcat: never tried 'em in vim even though I've known about them
[07:10:09] <strcat> paupau: well you can just :undolist and then :undo #
[07:10:14] <strcat> that's all I really do...
[07:10:18] <pnkfelix> strcat: I think the main question will be whether the Weak Generational hypothesis still holds in Rust for the @ objects in a given task.
[07:10:53] *** Joins: eternaleye (eternaleye@moz-76321711.hsd1.wa.comcast.net)
[07:10:59] <paupau> strcat: neat. this list needs more description though.
[07:11:16] <strcat> paupau: yep, I'm sure there are plugins to make it better
[07:11:21] <pnkfelix> strcat: if so, then a good Gen GC will be a win.  But its quite possible that the Weak Gen Hypothesis won't hold here, since we have built-in stack-based memory management for many common cases
[07:11:24] <strcat> there's also a setting to save them persistently
[07:11:31] <paupau> a proof is a proof!
[07:11:34] <strcat> but if you touch even the mtime it breaks
[07:11:40] <strcat> breaks as in discards
[07:11:51] <paupau> strcat: robust!
[07:12:01] <strcat> it would be cool if it was actually like a VCS for every edit you did
[07:12:11] <paupau> strcat: I intend to do something like that
[07:12:38] <strcat> their discard behaviour should be a merge instead lo
[07:12:41] <strcat> ;p
[07:12:46] * strcat shrugs
[07:13:05] *** Joins: azita (Azita@moz-C1FB2A8.hsd1.ca.comcast.net)
[07:13:10] *** Quits: Cromulent (Cromulent@moz-983B638D.cable.virginmedia.com) (Quit: KVIrc 4.2.0 Equilibrium http://www.kvirc.net/)
[07:13:26] <strcat> pnkfelix: and ~, and Rc
[07:13:51] <paupau> here a merge / there a merge / everywhere a merge merge
[07:14:26] <pnkfelix> strcat: yeah, I should have said "explicit mem mgmt" instead of "stack-based"
[07:14:30] <strcat> but that's stack discipline so maybe you include that as stack-based
[07:14:55] <strcat> (until you stick them in @ at least ;p)
[07:16:12] <pnkfelix> strcat: Do people tend to use Rc a lot?
[07:16:23] *** Quits: int3_ (int3_@moz-ABE52D50.hsd1.ca.comcast.net) (Client exited)
[07:16:37] <strcat> pnkfelix: well, it's fairly new
[07:16:41] <strcat> pnkfelix: and we lack sugar for deref, etc.
[07:16:54] <strcat> so I'd guess there are 0 users atm :)
[07:17:24] <strcat> pnkfelix: I think people will use refcounting a lot though, through FFI bindings
[07:17:30] <strcat> like glib
[07:18:06] <strcat> in a gc'ed language you hand 1 ref to the gc, but in rust you can teach a type to do the normal refcounting for you
[07:19:02] <strcat> like http://www.gtkmm.org/en/
[07:19:12] *** Joins: infynyxx (infynyxx@DB780A29.749BA1D.DCC373F0.IP)
[07:19:23] <pnkfelix> strcat: mm.  ref-counting was a real boon-doggle for us in Actionscript/Flash.  But I can see the appeal for interop with examples like that
[07:19:52] <strcat> pnkfelix: well, it's pretty nice if it's all automatic
[07:19:57] <strcat> pnkfelix: and you can take 1 ref and put it in @
[07:20:03] *** Joins: int3_ (int3_@moz-ABE52D50.hsd1.ca.comcast.net)
[07:20:24] <strcat> glib really uses a ton of it, like their regexp is a refcounted object
[07:20:56] *** Quits: infynyxx (infynyxx@DB780A29.749BA1D.DCC373F0.IP) (Ping timeout)
[07:21:00] <strcat> so you'd have to deal with it in Drop, and then you could add Clone to bump the refcount
[07:21:22] <paupau> what's unsafe_no_drop_flag do?
[07:21:38] <strcat> omits the drop flag and calls the destructor N times instead
[07:21:58] <strcat> it makes a move zero the whole struct so you can just reuse a pointer or something as a drop flag
[07:22:07] <strcat> ideally, it'd be fine grained and let you pick the fields to zero
[07:22:19] *** Quits: eternaleye (eternaleye@moz-76321711.hsd1.wa.comcast.net) (Ping timeout)
[07:22:32] <strcat> we needed it for Rc/RcMut and the atomic ptr
[07:22:37] <paupau> so this drop flag indicates that the value needs to be destructed?
[07:23:21] *** Joins: Blub\w (wry@7E3BB9D.71150E1A.237AE2BA.IP)
[07:23:25] <strcat> paupau: yeah, it zeroes it on a move and adds a check on destroys for you
[07:23:40] <strcat> rusti: struct Foo { x: int } std::sys::size_of::<Foo>()
[07:23:41] -rusti- 8
[07:23:50] <strcat> rusti: struct Foo { x: int } impl Drop for Foo { fn drop(&self) {} } std::sys::size_of::<Foo>()
[07:23:51] -rusti- 16
[07:23:53] *** Joins: erickt (erickt@8C9ECD8F.3A598286.F12515B4.IP)
[07:24:01] *** Joins: MrFahrenheit (RageOfThou@3FEF494C.29C984D5.783DEDCA.IP)
[07:24:05] *** Joins: pnathan1 (Adium@B9840254.2CD8A5F8.477B877D.IP)
[07:24:09] <strcat> pcwalton and nmatsakis want to get rid of it and do some analysis instead
[07:24:15] * strcat hopes they succeed
[07:24:32] <paupau> strcat: so currently end-of-scope dynamically checks live header'd vars for that flag?
[07:24:52] <strcat> paupau: basically yeah
[07:25:03] <strcat> paupau: LLVM is clever enough to optimize a lot of it out, but not always
[07:25:07] <paupau> analysis would be cool.
[07:25:10] <strcat> it's similar to C++ atm
[07:25:14] *** Joins: jensnockert (jensnocker@moz-C5F27039.cust.bredband2.com)
[07:25:39] <strcat> a C++ move constructor is responsible for "stealing" resources by doing a shallow copy and setting the other object into a state where it can be destroyed without hurting the new one
[07:25:47] <strcat> so... in practice you zero a pointer
[07:25:52] *** Quits: pnathan1 (Adium@B9840254.2CD8A5F8.477B877D.IP) (Ping timeout)
[07:25:55] <strcat> and if you don't have something convenient to zero, you add a drop flag
[07:26:22] *** Joins: eternaleye (eternaleye@moz-76321711.hsd1.wa.comcast.net)
[07:26:39] *** Quits: erickt (erickt@8C9ECD8F.3A598286.F12515B4.IP) (Ping timeout)
[07:26:39] <paupau> Right.
[07:26:52] *** Quits: azita (Azita@moz-C1FB2A8.hsd1.ca.comcast.net) (Quit: azita)
[07:26:53] <strcat> rust doesn't give you a choice since all objects are movable :)
[07:26:59] <strcat> C++ objects are allowed to depend on their location in memory
[07:27:07] <strcat> really weird if you did that, but you could.
[07:28:03] *** Quits: eternaleye (eternaleye@moz-76321711.hsd1.wa.comcast.net) (Ping timeout)
[07:28:22] <paupau> all objects are movable, hmm
[07:28:27] *** Joins: eternaleye (eternaleye@moz-76321711.hsd1.wa.comcast.net)
[07:28:40] *** Joins: dsirenko (mitra@8E712A0.54C21BA0.9F317420.IP)
[07:28:49] <strcat> but not all are sendable
[07:30:14] *** Quits: int3_ (int3_@moz-ABE52D50.hsd1.ca.comcast.net) (Client exited)
[07:31:15] <ski> what does "sendable" mean ?
[07:32:00] <Eridius> conforms to the Send kind
[07:32:14] <Eridius> IIRC it basically means it doesn't contain any & or @ fields, but I could be misremembering
[07:33:02] <strcat> Eridius: or things with #[no_send], like Rc
[07:33:18] <strcat> ski: it's basically how rust eliminates data races
[07:33:29] <strcat> sendable types have to be owned or thread-safe shared data (like ARC)
[07:36:03] *** Quits: n0vember (n0vember@moz-690FFF9D.org) (Ping timeout)
[07:36:16] *** Quits: michaelgreene (michael@DA820AA2.17CD9887.F12515B4.IP) (Ping timeout)
[07:37:02] <ski> hm
[07:37:51] *** Joins: michaelgreene (michael@DA820AA2.17CD9887.F12515B4.IP)
[07:38:10] *** Joins: n0vember (n0vember@moz-690FFF9D.org)
[07:40:58] *** Joins: bret (bret@moz-671F823A.hsd1.or.comcast.net)
[07:41:07] *** Quits: michaelgreene (michael@DA820AA2.17CD9887.F12515B4.IP) (Ping timeout)
[07:42:21] *** Joins: michaelgreene (michael@DA820AA2.17CD9887.F12515B4.IP)
[07:44:28] *** Quits: hjr3 (hradtke@moz-E87BDF1F.socal.res.rr.com) (Quit: My MacBook has gone to sleep. ZZZzzzâ€¦)
[07:44:59] <shachaf> hi ski
[07:47:15] <fabiand> hey - is rustpkg for building packages in the local fs - or is it intended (in future) to also retrieve pkgs from a remote repository?
[07:49:32] <fabiand> hey - is rustpkg for building packages in the local fs - or is it intended (in future) to also retrieve pkgs from a remote repository?
[07:50:16] <ski> lo shachaf
[07:50:38] *** Quits: strcat (strcat@moz-54F7FD49.cpe.net.cable.rogers.com) (Quit: WeeChat 0.4.1)
[07:54:48] *** Quits: roo (jesse@moz-9A53149A.ip.windstream.net) (Ping timeout)
[07:56:19] *** Joins: roo (jesse@moz-9A53149A.ip.windstream.net)
[07:56:23] *** Joins: pnathan1 (Adium@B9840254.2CD8A5F8.477B877D.IP)
[08:01:44] *** Quits: pnathan1 (Adium@B9840254.2CD8A5F8.477B877D.IP) (Ping timeout)
[08:02:05] <cmr> fabiand: it can retrieve remote packages now
[08:02:08] *** Quits: paupau (NEAT@moz-C616DA0A.hsd1.ca.comcast.net) (Ping timeout)
[08:02:33] <fabiand> cmr hey - how?
[08:02:44] <fabiand> ahh
[08:02:45] <fabiand> okay
[08:02:47] <fabiand> I see it ..
[08:03:27] <fabiand> cmr, but is it planned to have a central repository?
[08:03:30] <fabiand> like npm ..
[08:03:33] <fabiand> like npm has ..
[08:03:59] *** Joins: paupau (NEAT@moz-C616DA0A.hsd1.ca.comcast.net)
[08:05:49] *** Quits: paupau (NEAT@moz-C616DA0A.hsd1.ca.comcast.net) (Quit: out)
[08:06:47] <Eridius> hey cmr, I saw you responded to my comments. Have you taken a look at the updated PR yet?
[08:07:33] <cmr> fabiand: yes, but not built into the rustpkg tool, see http://article.gmane.org/gmane.comp.lang.rust.devel/4541
[08:07:36] <cmr> Eridius: am now
[08:10:56] *** Quits: vilonis (jared@moz-EE5D17ED.ph.ph.cox.net) (Quit: WeeChat 0.3.8)
[08:12:27] <Eridius> cmr: thanks
[08:12:27] <Eridius> ooh p=1? I feel honored ;)
[08:12:44] <cmr> it breaks error readability
[08:12:55] <cmr> well, fixes the already-broken error readability
[08:13:22] *** Quits: ross (ross@moz-8A84103E.br.br.cox.net) (Quit: )
[08:16:37] *** Joins: z0w0 (zack@moz-37A98529.lnse2.woo.bigpond.net.au)
[08:17:50] <fabiand> cmr, thanks for that link
[08:18:01] *** Joins: Ms2ger (Ms2ger@moz-E9883900.access.telenet.be)
[08:19:33] *** Joins: infynyxx (infynyxx@DB780A29.749BA1D.DCC373F0.IP)
[08:21:21] *** Quits: infynyxx (infynyxx@DB780A29.749BA1D.DCC373F0.IP) (Ping timeout)
[08:22:03] *** Joins: tikue (tkuehn@moz-A7CDB794.dia.static.qwest.net)
[08:22:17] <tikue> rusti: [1] || false
[08:22:18] -rusti- <anon>:7:9: 7:21 error: binary operation || cannot be applied to type `[<VI0>, .. 1]`
[08:22:18] -rusti- <anon>:7          [1] || false
[08:22:18] -rusti-                   ^~~~~~~~~~~~
[08:22:18] -rusti- error: aborting due to previous error
[08:22:18] -rusti- application terminated with error code 101
[08:25:17] *** Joins: erickt (erickt@8C9ECD8F.3A598286.F12515B4.IP)
[08:25:42] <tikue> rusti: Some(1).or(Some(2))
[08:25:43] -rusti- Some(1)
[08:25:52] <tikue> rusti: None.or(Some(2))
[08:25:53] -rusti- Some(2)
[08:27:47] *** Joins: CarpNet (ac@moz-FD24B77.sohonet.co.uk)
[08:28:08] *** Quits: erickt (erickt@8C9ECD8F.3A598286.F12515B4.IP) (Ping timeout)
[08:28:39] *** Joins: slaren (x@moz-3303B155.red-83-63-180.staticip.rima-tde.net)
[08:31:19] <fabiand> rusti: None.or(None())
[08:31:20] -rusti- <anon>:7:17: 7:24 error: expected function but found `std::option::Option<<V6>>`
[08:31:20] -rusti- <anon>:7          None.or(None())
[08:31:20] -rusti-                           ^~~~~~~
[08:31:20] -rusti- error: aborting due to previous error
[08:31:20] -rusti- application terminated with error code 101
[08:31:26] <fabiand> rusti: None.or(None)
[08:31:27] -rusti- more than 5 lines of output, pastebinned: http://sprunge.us/fKFM
[08:31:35] <doomlord> http://pastebin.com/4UpRqSDi <<<< does this require Trait Inheritance to do what I was trying
[08:32:27] <tikue> rusti: let a: Option<uint> = None; a.or(None)
[08:32:28] -rusti- None
[08:32:44] *** Joins: _Vi (vi@527C345F.497AA854.B16B3BE6.IP)
[08:32:51] <doomlord> it thinks (ii),(iii) conflict - presumably because i could at some point  impl X for Q - but i wouldn't
[08:33:02] *** Quits: tikue (tkuehn@moz-A7CDB794.dia.static.qwest.net) (Quit: tikue)
[08:33:05] *** Quits: bret (bret@moz-671F823A.hsd1.or.comcast.net) (Input/output error)
[08:33:34] <doomlord> i'd hope the error/ambiguity would come *if* i implemeneted X for Q
[08:34:31] <cmr> doomlord: I think this is a bug/known limitation that is going to be fixed
[08:34:54] <doomlord> ok. fair enough
[08:35:09] <doomlord> i was  going to post an issue... but if its known great
[08:35:11] <cmr> it's very annoying, you can't specialize implementations if you have a generic one :\
[08:35:28] <doomlord> i can workaround for now
[08:35:56] <doomlord> whats the problem/case called...
[08:37:41] <cmr> it's https://github.com/mozilla/rust/issues/7590 and https://github.com/mozilla/rust/issues/3429 I think
[08:37:46] *** Joins: ghrust (ghrust@AD60B2E3.6A2AE50.F3114085.IP)
[08:37:46] <ghrust> 01[13rust01] 15bors merged 06auto into 06master: 02http://git.io/pYWg5w
[08:37:46] *** Parts: ghrust (ghrust@AD60B2E3.6A2AE50.F3114085.IP) ()
[08:38:26] <doomlord> got it 
[08:39:02] <cmr> they both fall under the umbrella of "parameterized impls are broke" ;)
[08:40:03] *** Joins: tikue (tkuehn@moz-A7CDB794.dia.static.qwest.net)
[08:40:25] <tikue> rusti: [1, 2].iter().sum()
[08:40:26] -rusti- <anon>:7:9: 8:5 error: type `std::vec::VecIterator<,<VI1>>` does not implement any method in scope named `sum`
[08:40:26] -rusti- <anon>:7          [1, 2].iter().sum()
[08:40:26] -rusti- <anon>:8     };
[08:40:27] -rusti- error: aborting due to previous error
[08:40:27] -rusti- application terminated with error code 101
[08:40:34] *** Joins: leonvv (leonvv@moz-7D83A5F1.ip.telfort.nl)
[08:40:39] *** Quits: pnkfelix (pnkfelix@moz-43495417.fbx.proxad.net) (Quit: Leaving.)
[08:40:40] <cmr> rusti: let x = [1, 2]; x.iter().sum()
[08:40:41] -rusti- <anon>:7:25: 8:5 error: type `std::vec::VecIterator<,<VI1>>` does not implement any method in scope named `sum`
[08:40:41] -rusti- <anon>:7          let x = [1, 2]; x.iter().sum()
[08:40:41] -rusti- <anon>:8     };
[08:40:41] -rusti- error: aborting due to previous error
[08:40:41] -rusti- application terminated with error code 101
[08:40:47] <cmr> rusti: let x = &[1, 2]; x.iter().sum()
[08:40:48] -rusti- <anon>:7:26: 8:5 error: type `std::vec::VecIterator<,<VI1>>` does not implement any method in scope named `sum`
[08:40:48] -rusti- <anon>:7          let x = &[1, 2]; x.iter().sum()
[08:40:48] -rusti- <anon>:8     };
[08:40:48] *** Joins: ghrust (ghrust@F6EE6DE3.6A2AE50.F3114085.IP)
[08:40:48] <ghrust> 01[13rust01] 15bors pushed 0 new commits to 06auto: 02http://git.io/_YEGIg
[08:40:48] *** concrete.mozilla.org sets mode: +M 
[08:40:48] *** Parts: ghrust (ghrust@F6EE6DE3.6A2AE50.F3114085.IP) ()
[08:40:48] -rusti- error: aborting due to previous error
[08:40:50] -rusti- application terminated with error code 101
[08:40:53] <tikue> [1, 2].iter().transform(|&x| x).sum()
[08:41:07] <tikue> rusti: [1, 2].iter().transform(|&x| x).sum()
[08:41:08] -rusti- <anon>:7:9: 8:5 error: type `std::iterator::MapIterator<,&int,int,std::vec::VecIterator<,int>>` does not implement any method in scope named `sum`
[08:41:08] -rusti- <anon>:7          [1, 2].iter().transform(|&x| x).sum()
[08:41:08] -rusti- <anon>:8     };
[08:41:08] -rusti- error: aborting due to previous error
[08:41:08] -rusti- application terminated with error code 101
[08:41:13] <cmr> I don't think there's a sum method at all, apparently
[08:41:24] *** Quits: Raynes (macro@moz-E5F01CE6.members.linode.com) (Ping timeout)
[08:41:30] <cmr> I don't think there's a sum method at all, apparently
[08:41:46] <tikue> there are in the docs though :\
[08:42:56] *** Quits: katis (katis@40C8AF65.EFDC2270.EE6E63A5.IP) (Ping timeout)
[08:43:08] <tikue> rusti: use std::iterator::AdditiveIterator; [1, 2].iter().sum()
[08:43:09] -rusti- <anon>:7:46: 8:5 error: failed to find an implementation of trait std::ops::Add<&int,&int> for &int
[08:43:09] -rusti- <anon>:7          use std::iterator::AdditiveIterator; [1, 2].iter().sum()
[08:43:09] -rusti- <anon>:8     };
[08:43:09] -rusti- application terminated with error code 101
[08:43:23] <tikue> rusti: use std::iterator::AdditiveIterator; [1, 2].iter().transform(|&x|x).sum()
[08:43:25] -rusti- more than 5 lines of output, pastebinned: http://sprunge.us/DDYY
[08:43:35] <Eridius> tikue: rvalue issue
[08:43:49] <tikue> rusti: use std::iterator::AdditiveIterator; let a = [1, 2]; a.iter().transform(|&x|x).sum()
[08:43:50] <Eridius> rusti: use std::iterator::AdditiveIterator; let x = [1, 2]; x.iter().transform(|x|*x).sum()
[08:44:01] -rusti- 3
[08:44:02] -rusti- 3
[08:44:02] <tikue> lol
[08:44:12] <Eridius> btw, |x|*x is better than |&x|x
[08:44:20] <tikue> why?
[08:44:23] <cmr> Eridius: the unsoundness issues were fixed
[08:44:24] <Eridius> pattern matching in closure args is unsound
[08:44:26] <Eridius> cmr: oh really?
[08:44:27] <tikue> nmatsakis said it was functionally equivalent
[08:44:28] <_Vi> What to use instead of int::range in new code?
[08:44:29] <cmr> yup
[08:44:30] <Eridius> cmr: when did that happen?
[08:44:33] *** Quits: james4k (james@moz-E7990244.consolidated.net) (Ping timeout)
[08:44:39] <cmr> https://github.com/mozilla/rust/pull/7262
[08:45:00] <tikue> is there no way around the need to do .iter().transform() to get to use sum()
[08:45:03] <Eridius> hah, 3 days ago
[08:45:26] <Eridius> rusti: use std::iterator::AdditiveIterator; (~[1, 2]).consume_iter().sum()
[08:45:27] -rusti- 3
[08:45:32] *** Joins: Raynes (macro@moz-E5F01CE6.members.linode.com)
[08:45:35] <tikue> rusti: use std::iterator::AdditiveIterator; let a = [1, 2]; a.consume_iter().sum()
[08:45:36] -rusti- <anon>:7:62: 7:79 error: type `[<VI1>, .. 2]` does not implement any method in scope named `consume_iter`
[08:45:37] -rusti- <anon>:7          use std::iterator::AdditiveIterator; let a = [1, 2]; a.consume_iter().sum()
[08:45:37] -rusti-                                                                        ^~~~~~~~~~~~~~~~~
[08:45:37] -rusti- error: aborting due to previous error
[08:45:37] -rusti- application terminated with error code 101
[08:45:48] <Eridius> tikue: I've been suggesting a .iter_clone() method on vectors, but there hasn't been enough impetus to actually implement that yet
[08:45:49] *** concrete.mozilla.org sets mode: -M 
[08:45:52] <cmr> can't consume slices/fixed-len vecs
[08:46:07] <tikue> rusti: use std::iterator::AdditiveIterator; let a = ~[1, 2]; a.consume_iter().sum()
[08:46:10] -rusti- 3
[08:46:21] *** Joins: Cromulent (Cromulent@moz-983B638D.cable.virginmedia.com)
[08:46:26] <Eridius> ok bedtime
[08:47:26] <tikue> Eridius: so iter_clone() would presumably iterate over the values?
[08:47:40] <cmr> rusti: for std::iterator::Counter::new(2, 8).take(5).advance |x| { print(fmt!("%u ", x)) }
[08:47:41] -rusti- <anon>:7:13: 7:55 error: type `std::iterator::Counter<<VI1>>` does not implement any method in scope named `take`
[08:47:41] -rusti- <anon>:7          for std::iterator::Counter::new(2, 8).take(5).advance |x| { print(fmt!("%u ", x)) }
[08:47:41] -rusti-                       ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
[08:47:41] -rusti- error: aborting due to previous error
[08:47:41] -rusti- application terminated with error code 101
[08:47:49] <cmr> rusti: for std::iterator::Counter::new(2, 8).take_(5).advance |x| { print(fmt!("%u ", x)) }
[08:47:50] -rusti- more than 5 lines of output, pastebinned: http://sprunge.us/OiDX
[08:48:03] <cmr> rusti: for std::iterator::Counter::new(2, 8).take_(5).advance |x| { print(fmt!("%i ", x)) }
[08:48:04] -rusti- 2 10 18 26 34 ()
[08:48:09] <cmr> _Vi: ^
[08:48:29] <tikue> what
[08:48:36] <tikue> what is that doing
[08:48:54] <cmr> new counter, starting at 2, step of 8, only use the first 5 values
[08:48:57] <tikue> oh take(5) is taking every 5th?
[08:49:01] <tikue> oh
[08:49:17] <cmr> otherwise..
[08:49:21] <_Vi> cmr, What is currently idiomatic way to do "for i from 1 to N do this" ?
[08:49:24] <cmr> rusti: for std::iterator::Counter::new(2, 8).advance |x| { print(fmt!("%i ", x)) }
[08:49:30] -rusti- line longer than 10000 characters, bailing out
[08:49:40] *** Joins: katis (katis@40C8AF65.EFDC2270.EE6E63A5.IP)
[08:49:48] *** Joins: ghrust (ghrust@AC22872E.6A2AE50.F3114085.IP)
[08:49:48] <ghrust> 01[13rust01] 15bors 04force-pushed 06auto from 1499ef079 to 140939477: 02http://git.io/N3iJvQ
[08:49:48] *** Parts: ghrust (ghrust@AC22872E.6A2AE50.F3114085.IP) ()
[08:49:51] <tikue> oh I see, counter goes up by 8 for infinite
[08:49:56] <cmr> yup
[08:50:02] <tikue> does python have an equivalent of take() for generators?
[08:50:09] <tikue> it's so useful
[08:50:29] <cmr> dunno, would be easy to implement I imagine
[08:50:56] <tikue> i'd probably do something like, [val for _, val in zip(range(5), count(2, 8))]
[08:51:04] <tikue> which kinda sucks lol
[08:51:23] *** Quits: ChrisMorgan (chris@moz-6AC741CA.static.tpgi.com.au) (Ping timeout)
[08:51:47] <cmr> _Vi: was range removed?
[08:51:55] <tikue> import itertools
[08:51:56] <tikue> top5 = itertools.islice(array, 5)
[08:51:59] <tikue> that's how
[08:52:14] <_Vi> At least it says error: unresolved name `int::range`
[08:52:31] <cmr> rusti: use std::int; for int::range(0, 3) |x| { print(fmt!("%i", x)) }
[08:52:33] -rusti- 012()
[08:55:34] <_Vi> So I expected to write std::int::range (or add additional "use"s) every time I need "for i from x to y"? Will there be a shortcut like for println?
[08:56:03] <tikue> _Vi: I agree that it should be in the prelude
[08:56:19] <cmr> A generic range should be in the prelude
[08:56:34] <tikue> rusti: range(0, 5)
[08:56:35] -rusti- <anon>:7:9: 7:14 error: unresolved name `range`.
[08:56:36] <cmr> bjz: that'd be possible right? std::num::range?
[08:56:36] -rusti- <anon>:7          range(0, 5)
[08:56:36] -rusti-                   ^~~~~
[08:56:36] -rusti- error: aborting due to previous error
[08:56:36] -rusti- application terminated with error code 101
[08:56:38] *** Joins: Palmik (palmik@moz-CC484FDD.tmcz.cz)
[08:57:05] <bjz> yes
[08:57:09] <tikue> what would that mean
[08:57:20] <tikue> you'd have to specify the type you want?
[08:57:33] <_Vi> Can there be something like "for 12..77 |i| { ... }" ?
[08:57:42] <cmr> _Vi: syntax for it? unlikely
[08:57:47] <_Vi> There is already X..Y in Rust (in match)...
[08:57:52] <bjz> I didn't implement it because I thought we we moving to iterators, which we are
[08:58:04] <tikue> bjz: it could be an iterator right?
[08:58:13] <bjz> yes
[08:58:24] <tikue> bjz: what would it mean to be a generic range
[08:58:37] <tikue> bjz: btw don't you live on the east coast lol
[08:58:49] <cmr> tikue: implemented for everything that is Bounded, has Add and Ord...
[08:58:51] <cmr> I think that's it?
[08:59:10] <doomlord> i'd much prefer range(start,end) generating an iterator to special syntax for that
[08:59:19] <bjz> cmr: it would have to be for something enumerable
[08:59:26] *** Quits: BizarreCake (BizarreCak@moz-361FE9B2.dynamic.barak-online.net) (Ping timeout)
[08:59:29] <bjz> cmr: like, not floats
[08:59:31] <doomlord> for range(0,3) |x|{....}  .., fine
[08:59:52] <doomlord> range(0,3).each or whatever it would be
[08:59:54] <cmr> bjz: why? start,stop,step, just add step to start until you're done, default step of 1
[09:00:20] <bjz> that is true
[09:00:38] *** Joins: lucian (lucian@6B2B4644.4304AE1E.CE5E78F6.IP)
[09:00:47] *** Quits: doomlord_ (servitor@moz-13E69BC8.range86-180.btcentralplus.com) (Ping timeout)
[09:00:48] <cmr> iterating over the reals should be left to a robust bignum library ;p
[09:00:57] <bjz> tikue: I live in australia
[09:01:10] <bjz> east coast of australia :)
[09:01:30] <tikue> match 5 { 0..5 => ~"wee", _ =>  ~":D" }
[09:01:37] <tikue> rusti: match 5 { 0..5 => ~"wee", _ =>  ~":D" }
[09:01:38] -rusti- ~"wee"
[09:01:41] <tikue> bjz: oh ok haha
[09:01:48] <tikue> you know, I think I agree with _Vi 
[09:02:03] <tikue> it is a bit curious that n..m syntax can be used in pattern matching but not anything else
[09:02:13] <tikue> does it only work with uints?
[09:02:15] <tikue> or ints?
[09:02:23] <tikue> does it work with newtype structs?
[09:02:29] <tikue> or anything enumerable?
[09:02:40] <fabiand> rusti: match 6 { 0..5 => ~"wee", _ =>  ~":D" }
[09:02:41] -rusti- ~":D"
[09:03:36] <tikue> rusti: struct Foo(uint); match Foo(5) { Foo(0)..Foo(5) => ~"wee", _ => ~"won't work" }
[09:03:37] -rusti- <anon>:7:48: 7:50 error: expected `=>` but found `..`
[09:03:37] -rusti- <anon>:7          struct Foo(uint); match Foo(5) { Foo(0)..Foo(5) => ~"wee", _ => ~"won't work" }
[09:03:37] -rusti-                                                          ^~
[09:03:37] -rusti- application terminated with error code 101
[09:03:55] *** Joins: sankha93 (Instantbir@7106AFAF.328EAA2C.EFB84E89.IP)
[09:03:59] <tikue> What can you use m..n with other than ints?
[09:04:20] <dbaupp> tikue: chars
[09:04:39] <dbaupp> cmr: floods have subsided?
[09:04:53] <tikue> dbaupp: do you know if there are any plans for expanding it to all enumerable types?
[09:05:26] <dbaupp> cmr, bjz: also, re generic range: it's unsigned types/wrap-around makes it non-trivial
[09:05:37] <bjz> dbaupp: yes
[09:05:38] <dbaupp> tikue: I'd guess all orderable types would make more sense
[09:05:47] <dbaupp> s/it's //
[09:05:50] <bjz> dbaupp: that was a concern
[09:05:53] <tikue> dbaupp: orderable and enumerable, right?
[09:05:57] <dbaupp> bjz: yeah
[09:05:58] <cmr> The current range handles over/underflow
[09:06:16] <dbaupp> tikue: not really, low..high => low <= x && x <= high
[09:06:27] <cmr> although... it can fail
[09:06:40] <dbaupp> cmr: yeah, but it's written separately for uints/ints
[09:07:11] <dbaupp> cmr: and it relies on their exact overflow semantics, so it wouldn't necessarily work for arbitrary Add types.
[09:07:21] <tikue> dbaupp: maybe I don't know what orderable implies. surely you wouldn't support -2.5 .. 2.5
[09:07:26] * dbaupp really should implement CheckedAdd
[09:07:28] <cmr> dbaupp: flooding is gone but the ISP haven't replaced whatever it is that is making the school unroutable
[09:07:38] <dbaupp> tikue: that'd be pretty awesome
[09:07:57] <dbaupp> cmr: oh, but I'm seeing new benchmarks?
[09:08:08] <tikue> dbaupp: haha, it seems impossible! the precision would be so arbitrary as to be useless imo
[09:08:10] <cmr> you are? O_o
[09:08:15] <cmr> oh look I can ssh now
[09:08:22] <cmr> I couldn't when I woke up ~1 hour ago :p
[09:08:32] *** Quits: snadon (chatzilla@moz-3BC727E8.mc.videotron.ca) (Client exited)
[09:08:38] <dbaupp> tikue: "so arbitrary"?
[09:08:46] <cmr> I assume he was working that whole time, so he probably did a crapload of historic stuff :p
[09:08:52] <cmr> tikue: default step of 1
[09:08:54] <dbaupp> tikue: it would just be using the defined Ord trait impls
[09:09:04] <dbaupp> cmr: oh, possibly
[09:09:22] *** Joins: davbo (dave@moz-3FFA637C.oucs.ox.ac.uk)
[09:09:31] <dbaupp> tikue: I would assume that match 1.100001 { -2.5 .. 2.5 => true, _ => false } would work
[09:09:41] <dbaupp> tikue: (well, I think it would be neat)
[09:09:43] <tikue> match 2.5 { 0..3 => ~"oh", _ => ~"hm" }
[09:09:52] <tikue> rusti: match 2.5 { 0..3 => ~"oh", _ => ~"hm" }
[09:09:54] -rusti- more than 5 lines of output, pastebinned: http://sprunge.us/XCBU
[09:10:09] <cmr> heh that span is so broken
[09:10:17] <dbaupp> tikue: i.e. it'd literally just be syntactic sugar for writing `low <= x && x <= high`
[09:10:21] <tikue> rusti: match 2.5 { 0.0..3.0 => ~"oh", _ => ~"hm" }
[09:10:22] -rusti- ~"oh"
[09:10:30] <tikue> dbaupp: ^ is it already supported
[09:10:36] * dbaupp celebrates
[09:10:44] <fabiand> rusti: match -2.5 { -3.0..3.0 => ~"oh", _ => ~"hm" }
[09:10:45] -rusti- ~"oh"
[09:10:46] *** Quits: leonvv (leonvv@moz-7D83A5F1.ip.telfort.nl) (Client exited)
[09:10:52] <tikue> rusti: match 2.5 { -1.5..3.0 => ~"oh", _ => ~"hm" }
[09:10:53] -rusti- ~"oh"
[09:10:56] <tikue> haha nice
[09:10:58] <dbaupp> rusti: match "foo" { "aaaaa".."zzzzz" => ~"oh", _ => ~"hm" }
[09:10:59] -rusti- <anon>:7:23: 7:39 error: non-numeric type used in range
[09:10:59] -rusti- <anon>:7          match "foo" { "aaaaa".."zzzzz" => ~"oh", _ => ~"hm" }
[09:10:59] -rusti-                                 ^~~~~~~~~~~~~~~~
[09:10:59] -rusti- error: aborting due to previous error
[09:10:59] -rusti- application terminated with error code 101
[09:11:04] <cmr> aw
[09:11:04] * dbaupp is sad
[09:11:05] <tikue> I aw
[09:11:10] <tikue> ^ hivemind
[09:11:25] <cmr> rusti: "foo" < "zzzzz"
[09:11:27] -rusti- true
[09:11:29] <cmr> heh
[09:11:36] <fabiand> rusti: match 'b' { 'a'..'z' => ~"oh", _ => ~"hm" }
[09:11:37] -rusti- ~"oh"
[09:11:49] <cmr> chars are ty_char, which is a ty_int
[09:11:55] <cmr> mindbogglingly
[09:11:59] <_Vi> Shall there be two ranges: half-inclusive (like std::int::range) and inclusive?
[09:12:01] <tikue> rusti: match 'c' => { 'd'..'a' => ~":O", _ => ~">:(" }
[09:12:01] -rusti- <anon>:7:19: 7:21 error: expected `{` but found `=>`
[09:12:01] -rusti- <anon>:7          match 'c' => { 'd'..'a' => ~":O", _ => ~">:(" }
[09:12:02] -rusti-                             ^~
[09:12:02] -rusti- application terminated with error code 101
[09:12:05] *** Quits: sk (sk@61A494B3.BA40E8A.AAC02D62.IP) (Quit: Leaving)
[09:12:23] <dbaupp> rusti: match 'c' { 'd'..'a' => ~":O", _ => ~">:(" }
[09:12:23] <tikue> rusti: match 'c' { 'd'..'a' => ~":O", _ => ~">:(" }
[09:12:24] -rusti- <anon>:7:21: 7:26 error: lower range bound must be less than upper
[09:12:24] -rusti- <anon>:7          match 'c' { 'd'..'a' => ~":O", _ => ~">:(" }
[09:12:24] -rusti-                               ^~~~~
[09:12:24] -rusti- error: aborting due to previous error
[09:12:25] -rusti- application terminated with error code 101
[09:12:25] -rusti- <anon>:7:21: 7:26 error: lower range bound must be less than upper
[09:12:26] -rusti- <anon>:7          match 'c' { 'd'..'a' => ~":O", _ => ~">:(" }
[09:12:28] -rusti-                               ^~~~~
[09:12:28] <dbaupp> heh
[09:12:28] *** concrete.mozilla.org sets mode: +M 
[09:12:30] -rusti- error: aborting due to previous error
[09:12:31] <cmr> ty_char is an int_ty, sorry
[09:12:32] -rusti- application terminated with error code 101
[09:12:32] * tikue guess who's tired
[09:12:55] *** Quits: slaren (x@moz-3303B155.red-83-63-180.staticip.rima-tde.net) (Ping timeout)
[09:13:02] <tikue> rusti: match 'c' { 'a'..'d' => ~":O", _ => ~">:(" }
[09:13:04] -rusti- ~":O"
[09:13:17] <tikue> so is there a trait that one can implement to use with this
[09:13:20] *** Joins: int3_ (int3_@moz-ABE52D50.hsd1.ca.comcast.net)
[09:13:24] <tikue> it'd be great to use it with newtypes
[09:13:31] *** Joins: mcclurmc (mcclurmc@moz-A19237A1.scouts.catn.com)
[09:13:33] <cmr> it'd be Ord if it were
[09:13:44] <tikue> is it fn ord?
[09:13:56] <cmr> trait Ord {fn eq, fn ne}
[09:14:30] <cmr> wait
[09:14:32] <cmr> that's Eq
[09:14:47] * tikue yawns
[09:14:52] <cmr> herp
[09:14:53] <tikue> I'll look into it tomorrow :)
[09:14:54] <cmr> https://github.com/mozilla/rust/blob/master/src/libstd/cmp.rs#L168
[09:15:41] *** Quits: tikue (tkuehn@moz-A7CDB794.dia.static.qwest.net) (Quit: tikue)
[09:17:29] *** concrete.mozilla.org sets mode: -M 
[09:19:52] *** Joins: infynyxx (infynyxx@DB780A29.749BA1D.DCC373F0.IP)
[09:21:36] *** Quits: infynyxx (infynyxx@DB780A29.749BA1D.DCC373F0.IP) (Ping timeout)
[09:22:01] *** Quits: roo (jesse@moz-9A53149A.ip.windstream.net) (Ping timeout)
[09:22:09] *** Joins: yichoi (yichoi@5AB4884B.FCC4549.14D5B978.IP)
[09:22:58] *** Joins: roo (jesse@moz-9A53149A.ip.windstream.net)
[09:24:05] <cmr> jclements' hygiene PR is heroic
[09:24:25] * cmr is halfway done review
[09:26:45] *** Joins: erickt (erickt@8C9ECD8F.3A598286.F12515B4.IP)
[09:26:59] <dbaupp> rusti: let a: @IterBytes = @(1,2);
[09:27:00] -rusti- line longer than 150 columns, pastebinned: http://sprunge.us/DGVb
[09:27:14] <dbaupp> rusti: let a: @IterBytes = @(1,2) as @IterBytes;
[09:27:15] -rusti- <anon>:7:13: 7:14 warning: unused variable: `a` [-W unused-variable (default)]
[09:27:15] -rusti- <anon>:7          let a: @IterBytes = @(1,2) as @IterBytes;
[09:27:15] -rusti-                       ^
[09:27:16] -rusti- ()
[09:27:50] <dbaupp> cmr: I'm also having a look :)
[09:29:31] *** Quits: erickt (erickt@8C9ECD8F.3A598286.F12515B4.IP) (Ping timeout)
[09:31:30] *** Quits: roo (jesse@moz-9A53149A.ip.windstream.net) (Ping timeout)
[09:31:41] *** Joins: roo (jesse@moz-9A53149A.ip.windstream.net)
[09:32:44] <cmr> "special_idents::clownshoe_abi" wut
[09:32:57] <cmr> what is a clownshoe :S
[09:33:13] <dbaupp> cmr: __something__
[09:33:20] <cmr> ahhh
[09:33:23] <cmr> heh, that makes sense
[09:33:39] <dbaupp> cmr: e.g. clownshoes_extensions `...::__extensions__::...`
[09:37:37] *** Joins: smvv_ (sander@moz-BAEA8EB2.dynamic.upc.nl)
[09:38:40] <_Vi> I compiled a simple Rust program, and it links to libstdc++.so.6... Is it by design?
[09:38:53] *** Quits: Cromulent (Cromulent@moz-983B638D.cable.virginmedia.com) (Quit: KVIrc 4.2.0 Equilibrium http://www.kvirc.net/)
[09:38:54] <cmr> _Vi: we use c++ exception handling
[09:39:15] <cmr> slash unwinding
[09:39:17] <cmr> aiui
[09:39:28] *** Quits: km (quassel@FDBAF0A0.DBF71E41.29C67456.IP) (Ping timeout)
[09:40:13] <_Vi> So runtime for rust-with-exceptions will always be as least as large as C++? Or later it will be revamped?
[09:40:25] <dbaupp> _Vi: it's sort-of "by design", because that was the easiest way to get something that worked (on some platforms), I think a custom solution will eventually be necessary,because unwinding doesn't work on windows.
[09:40:41] <dbaupp> (and also the reliance on a c++ std lib is pretty annoying.)
[09:40:47] <cmr> (very annoying)
[09:40:58] <_Vi> Will Rust v1.0 still depend on C++ (means be unusable where C can work, but C++ can't)?
[09:41:09] <dbaupp> Hopefully not.
[09:41:22] <cmr> we can just use like libcxxrt, which is smaller, but still not great
[09:41:23] <dbaupp> (It'd be even nicer if it didn't even depend on C.)
[09:41:33] <cmr> _Vi: we don't depend on it now.
[09:41:36] <cmr> _Vi: zero.rs
[09:42:27] *** Joins: q66 (q66@6EE9DE40.46454B5D.33AABD5F.IP)
[09:43:20] <_Vi> I mean more or less fully-fledged Rust, with GC, tasks and so on.
[09:43:47] <cmr> if C++ can't work, it's unlikely Rust could either
[09:44:41] <cmr> on *top* of unwinding we need an MMU for efficient GC, and tasks don't come cheaply
[09:45:42] *** Quits: jaen (jaen@moz-1AF55B54.neoplus.adsl.tpnet.pl) (Ping timeout)
[09:46:06] <_Vi> cmr, Can there (eventually) be "pluggable runtime features" for a choices like no_tasks/normal_tasks/simplified_tasks, no_gc/normal_gc/simple_gc, no_exceptions/stub_exceptions...
[09:46:08] *** Joins: jaen (jaen@moz-1AF55B54.neoplus.adsl.tpnet.pl)
[09:46:49] <dbaupp> cmr: it's entirely feasible that GC could be a second-class citizen on such platforms (since presumably they'd be stuff like embedded microprocessors, i.e. avoid GC anyway.)
[09:47:16] <dbaupp> cmr: so it's there, but ridiculously slow; or whatever.
[09:47:24] <_Vi> Can there be configurations like "with tasks, but without GC" or "GC, exceptions, but without tasks"?
[09:47:52] <dbaupp> _Vi: not yet
[09:48:10] <_Vi> Rust seems to be a rare language where GC is available, but not mandatory...
[09:48:23] <cmr> yes, that is the point
[09:48:28] <_Vi> dbaupp, But is it in plans?
[09:48:33] <dbaupp> (well, I guess you might be able to get something to work by hacking around in the source code and building a cross-compiler, since rustc itself needs all those thigns)
[09:48:37] <dbaupp> _Vi: don't know
[09:48:53] <cmr> _Vi: well we kinda have it now.
[09:49:14] <cmr> We have -D managed-heap-memory
[09:49:26] <cmr> You can use an alternate runtime
[09:49:31] <dbaupp> cmr: that essentially just disallows writing `@` in the source
[09:49:34] <cmr> Replace various things with other language items
[09:49:39] <dbaupp> cmr: *in any expression
[09:49:43] <_Vi> cmr, Individual configuration of "how much of Rust would you like to use? Exceptions [Y/N/M]? Tasks [Y/N/M]?... "
[09:49:50] *** Quits: sankha93 (Instantbir@7106AFAF.328EAA2C.EFB84E89.IP) (Ping timeout)
[09:49:55] <cmr> dbaupp: right but it's equivalent to no-gc if you don't have GC in the runtime, no?
[09:50:01] <cmr> or just stubs
[09:50:21] <cmr> _Vi: well it's not that simple yet, but it's quite feasible on top of the existing language I think
[09:50:24] <dbaupp> cmr: it won't complain about `-> @Foo`, or calling functions that return `@`, where you don't actually write an `@` anywhere. (I think.)
[09:50:32] <cmr> dbaupp: yikes
[09:50:42] *** Joins: pnkfelix (pnkfelix@87C1F78E.1DE10CA8.D8E68FF6.IP)
[09:50:43] <dbaupp> cmr: yeah.
[09:50:47] <cmr> it *does* have that information available, so it could.
[09:51:14] <dbaupp> right, I might be wrong, but I believe it was just looking at the AST, not the typeck/resolve info.
[09:51:22] <cmr> you're right
[09:51:35] <cmr> It lets `let x = ~"foo".to_managed();` pass unscathed
[09:51:45] <_Vi> Like in gcc I can use --n ostdlib, I expect (in future) in Rust to be more or less simple to "turn off normal Rust, turn on components individually".
[09:51:56] <dbaupp> cmr: it might even let @[] past
[09:52:07] <dbaupp> (i'm not sure about that)
[09:52:16] <dbaupp> _Vi: well, zero.rs lets you turn off everything
[09:52:26] <cmr> _Vi: we have #[no_std] for that, but you need something like zero.rs to make the language actually.. work
[09:52:45] <dbaupp> _Vi: and there's possibly some trickery that let's you use zero.rs with some other features.
[09:52:54] <_Vi> dbaupp, But not yet to flexibly turn on some things back.
[09:53:03] <cmr> not without a lot of work, no.
[09:53:03] <dbaupp> _Vi: right
[09:53:29] <dbaupp> this is all "far-future" ideas, since that isn't Rust's target space (at the moment)
[09:54:00] <_Vi> Can there be some special "lightweight GC, lighweight tasks, lightweight exceptions" which does not provide all features and as fast as normal, but little and have no external deps?
[09:54:03] <cmr> _Vi: there is someone who wants to / is doing a "Rust for Microcontrollers", targetting small cortex-m0's, which should cover all of this.
[09:54:03] <dbaupp> and so the devs are mainly focusing on features that are useful now (like removing bugs, improving compiler performance)
[09:54:10] *** Joins: sk (sk@DB8893A7.81A8C295.D066974A.IP)
[09:54:17] <cmr> _Vi: for their masters thesis
[09:55:11] <_Vi> So except Rust v1.0 to be usable for "normal" projects hope that in future there will also be mods for "embedded" or "sort of embedded" things, right?
[09:55:25] <_Vi> s/projects hope/projects and hope/
[09:55:32] <cmr> _Vi: unless someone contributes the features themselves, yes.
[09:55:38] *** Joins: sankha93 (Instantbir@FF1E0AEB.3AAA1E63.EFB84E89.IP)
[09:56:42] <cmr> fwiw I'm interested in porting to the arduino using the llvm-avr backend, but that's... months down the road
[09:56:46] <cmr> maybe 0.9
[09:57:34] *** Quits: Mowah (Mowah@moz-7A6BF5A3.cust.bredbandsbolaget.se) (Ping timeout)
[10:00:11] *** Joins: pnathan1 (Adium@B9840254.2CD8A5F8.477B877D.IP)
[10:00:41] *** Joins: rajul (quassel@E0F7EEF0.8F837703.13EFE003.IP)
[10:01:09] *** Joins: ssh (ssh@moz-9F810B0F.yourvserver.net)
[10:01:32] *** Quits: _Vi (vi@527C345F.497AA854.B16B3BE6.IP) (Ping timeout)
[10:02:25] *** Quits: ssh (ssh@moz-9F810B0F.yourvserver.net) (Quit: leaving)
[10:02:32] <jensnockert> cmr: Can LLVM target the Cortex-M3 or the Arduino Due?
[10:02:36] *** Joins: ssh (ssh@moz-9F810B0F.yourvserver.net)
[10:02:43] <jensnockert> *of
[10:03:04] <cmr> jensnockert: afaik yes
[10:03:08] <jensnockert> \o/
[10:03:29] <jensnockert> That could be an easier target to start with I guess.
[10:03:39] *** Quits: ssh (ssh@moz-9F810B0F.yourvserver.net) (Quit: leaving)
[10:03:50] <cmr> I don't have one, so it wouldn't benefit me, so I'm unlikely to do that ;p
[10:04:12] <jensnockert> I would borrow you mine, but I have a feeling shipping would be more expensive than the board :(
[10:05:14] *** Joins: SimonSapin (simon@88F51059.F3BBB17D.144F44FA.IP)
[10:06:08] *** Joins: FrozenCow (FrozenCow@moz-B2DF4929.chello.nl)
[10:06:19] *** Quits: pnathan1 (Adium@B9840254.2CD8A5F8.477B877D.IP) (Ping timeout)
[10:08:31] <doomlord> http://pastebin.com/10CiXt1P << c++ apologist
[10:08:59] <doomlord> name changed to protect the innocent. Here is me trying to explain "fn " is not wasted typing to a C++ apologist
[10:09:03] <cmr> "<anon>// fn is for putting less effort a few people developing tools" wut
[10:09:31] <doomlord> this guy is an absolute nut case
[10:09:50] <cmr> "and i HATE the inconsistency between member-functions and free functions" yeah there's a bug open for that
[10:09:56] <cmr> universal function call semantics or something
[10:10:03] <doomlord> ^ i mean in C++, not rust
[10:10:05] <doomlord> rust fixes it
[10:10:20] <cmr> ah
[10:10:34] <doomlord> in rust you have much more choice in how to arrange code. these 2 issues are my big draws to rust
[10:10:35] <cmr> the rust bug is for calling member functions like regular functions and passing in the `self` argument
[10:10:45] <doomlord> ah like D
[10:10:55] <pnkfelix> cmr: I suspect he's attempting to refer to our goal to make the grammar LL(1), and perhaps twisting ourselves in pretzels trying to do so.  Or maybe you already realized that.
[10:11:19] <doomlord> at the same time this guy hates type inference :)
[10:11:33] *** Quits: rntz (rntz@moz-C76A8D96.sp.cs.cmu.edu) (Ping timeout)
[10:11:33] <doomlord> he doen't want to type "fn ". but he does want to write out iterator names..
[10:11:49] *** Quits: mjrosenb (mjrosenb@moz-B3592BDA.club.cc.cmu.edu) (Ping timeout)
[10:12:30] <pnkfelix> At this point he seems like a troll
[10:12:34] <pnkfelix> probably best not to feed it
[10:12:39] <cmr> quite
[10:13:30] <cmr> jensnockert: confirmed that LLVM supports Cortex-M3 target
[10:13:37] <jensnockert> \o/
[10:13:46] *** Quits: dsirenko (mitra@8E712A0.54C21BA0.9F317420.IP) (Ping timeout)
[10:13:46] <cmr> http://www.llvm.org/svn/llvm-project/llvm/trunk/lib/Target/ARM/ARM.td
[10:14:01] *** Joins: dsirenko (mitra@8E712A0.54C21BA0.9F317420.IP)
[10:14:55] *** Quits: sankha93 (Instantbir@FF1E0AEB.3AAA1E63.EFB84E89.IP) (Ping timeout)
[10:15:13] *** Joins: slaren (x@moz-EBC5E112.red-79-147-85.dynamicip.rima-tde.net)
[10:15:28] <jensnockert> cmr: Hurray, both the M3 and M4 supported \o/
[10:18:35] *** Quits: roo (jesse@moz-9A53149A.ip.windstream.net) (Ping timeout)
[10:18:46] *** Quits: dsirenko (mitra@8E712A0.54C21BA0.9F317420.IP) (Ping timeout)
[10:18:53] *** Joins: roo (jesse@moz-9A53149A.ip.windstream.net)
[10:20:11] *** Joins: infynyxx (infynyxx@DB780A29.749BA1D.DCC373F0.IP)
[10:20:20] *** Joins: dsirenko (mitra@8E712A0.54C21BA0.9F317420.IP)
[10:21:33] *** Joins: rntz (rntz@moz-C76A8D96.sp.cs.cmu.edu)
[10:21:47] *** Joins: BizarreCake (BizarreCak@moz-361FE9B2.dynamic.barak-online.net)
[10:21:54] *** Quits: infynyxx (infynyxx@DB780A29.749BA1D.DCC373F0.IP) (Ping timeout)
[10:21:55] *** Joins: mjrosenb (mjrosenb@moz-B3592BDA.club.cc.cmu.edu)
[10:24:14] *** Quits: mjrosenb (mjrosenb@moz-B3592BDA.club.cc.cmu.edu) (Ping timeout)
[10:24:14] *** Quits: rntz (rntz@moz-C76A8D96.sp.cs.cmu.edu) (Ping timeout)
[10:24:39] *** Joins: jensnock_ (jensnocker@moz-8BE55278.customer.t3.se)
[10:25:56] *** Quits: jensnockert (jensnocker@moz-C5F27039.cust.bredband2.com) (Ping timeout)
[10:27:35] <nmatsakis> cmr: pattern matching in args is fixed now
[10:27:45] <nmatsakis> Eridius: ^
[10:28:09] *** Joins: erickt (erickt@8C9ECD8F.3A598286.F12515B4.IP)
[10:29:38] *** Joins: km (quassel@FDBAF0A0.DBF71E41.29C67456.IP)
[10:30:59] *** Quits: erickt (erickt@8C9ECD8F.3A598286.F12515B4.IP) (Ping timeout)
[10:33:26] *** Joins: rntz (rntz@moz-C76A8D96.sp.cs.cmu.edu)
[10:33:39] *** Joins: mjrosenb (mjrosenb@moz-B3592BDA.club.cc.cmu.edu)
[10:36:12] *** Joins: petermanser (petermanse@moz-9F810B0F.yourvserver.net)
[10:36:19] *** Quits: km (quassel@FDBAF0A0.DBF71E41.29C67456.IP) (Ping timeout)
[10:36:41] *** Joins: sankha93 (Instantbir@89EC16FB.35354309.EFB84E89.IP)
[10:37:10] *** Joins: thpickert (thpickert@moz-BBA4D0C.net.de.o2.com)
[10:42:23] *** Joins: true_droid (Adium@moz-123FD9B8.beck.volia.net)
[10:43:46] *** Joins: ghrust (ghrust@AC22872E.6A2AE50.F3114085.IP)
[10:43:46] <ghrust> 01[13rust01] 15bors merged 06auto into 06master: 02http://git.io/_cBnjA
[10:43:46] *** Parts: ghrust (ghrust@AC22872E.6A2AE50.F3114085.IP) ()
[10:44:11] <thpickert> Say I have: let v = ~[2, 3, 5, 7, 11, 13, 17, 19]â€¦ What's the idiomatic way to copy e.g. the partial, contiguous slice [7, 11, 13, 17] from v to a few w?
[10:44:14] <dbaupp> \o/ SIMD arithmetics
[10:44:31] <thpickert> a new*
[10:44:48] <dbaupp> jensnock_: https://github.com/mozilla/rust/pull/7705
[10:44:51] <thpickert> Do I have to loop?
[10:45:03] *** Quits: Blub\w (wry@7E3BB9D.71150E1A.237AE2BA.IP) (Ping timeout)
[10:45:11] <jensnock_> dbaupp: Yeah, noticed it, nice.
[10:45:14] *** Quits: sankha93 (Instantbir@89EC16FB.35354309.EFB84E89.IP) (Ping timeout)
[10:45:16] <dbaupp> thpickert: v.slice(low, high).to_owned()
[10:45:16] *** Joins: Blub\w (wry@7E3BB9D.71150E1A.237AE2BA.IP)
[10:45:25] <thpickert> Ohhh.
[10:45:41] <thpickert> I thought I had seen slice() before but couldn't find it,
[10:45:44] <thpickert> Thanks so much.
[10:46:25] <thpickert> Well, it's not even hidden. It's on the std::vec doc page
[10:46:33] <thpickert> I must have been selectively blinded.
[10:46:43] *** Joins: ghrust (ghrust@AD60B2E3.6A2AE50.F3114085.IP)
[10:46:43] <ghrust> 01[13rust01] 15bors pushed 0 new commits to 06auto: 02http://git.io/Cs0NaQ
[10:46:43] *** Parts: ghrust (ghrust@AD60B2E3.6A2AE50.F3114085.IP) ()
[10:46:44] *** Joins: ghrust (ghrust@79968228.6A2AE50.F3114085.IP)
[10:46:44] <ghrust> 01[13rust01] 15bors pushed 4 new commits to 06auto: 02http://git.io/Q3aFpg
[10:46:44] <ghrust> 13rust/06auto 141796373 15Gary Linscott: char_range_at perf work...
[10:46:44] <ghrust> 13rust/06auto 145aee5a1 15Gary Linscott: Optimize is_utf8...
[10:46:44] <ghrust> 13rust/06auto 148926b31 15Gary Linscott: Add is_utf8 bench tests...
[10:46:45] *** Parts: ghrust (ghrust@79968228.6A2AE50.F3114085.IP) ()
[10:46:45] *** Joins: km (quassel@FDBAF0A0.DBF71E41.29C67456.IP)
[10:46:49] *** Joins: _Vi (vi@527C345F.497AA854.B16B3BE6.IP)
[10:56:39] *** Joins: novabyte (Instantbir@moz-3E0F9699.cable.virginmedia.com)
[10:57:06] *** Joins: Earnestly (earnest@2AB30F53.FB5005.2BCC804A.IP)
[10:57:17] *** Quits: Palmik (palmik@moz-CC484FDD.tmcz.cz) (Ping timeout)
[10:57:44] *** Joins: Palmik (palmik@moz-CC484FDD.tmcz.cz)
[10:58:07] *** Quits: thpickert (thpickert@moz-BBA4D0C.net.de.o2.com) (Ping timeout)
[11:04:27] *** Joins: krdln (Mibbit@moz-C8708BE3.play-internet.pl)
[11:04:34] *** Joins: dimension (dimension@moz-4CCD79C5.dsl.dynamic.simnet.is)
[11:05:56] *** Quits: sk (sk@DB8893A7.81A8C295.D066974A.IP) (Ping timeout)
[11:08:28] <fabiand> hey
[11:08:34] <fabiand> does someone know of an eclipse plugin for rust?
[11:09:27] *** Quits: krdln (Mibbit@moz-C8708BE3.play-internet.pl) (Quit: http://www.mibbit.com ajax IRC Client)
[11:12:31] <fabiand> yey
[11:12:32] <fabiand> simd
[11:12:42] <cmr> fabiand: I don't think there is one.
[11:13:08] <fabiand> cmr, okay .. I've also just seen the support for vim and friends ..
[11:13:26] <cmr> vim, emacs, kate, geany, gedit, are the ones I know of
[11:13:31] <cmr> oh and... textmate?
[11:13:32] *** Joins: leonvv (leonvv@moz-7D83A5F1.ip.telfort.nl)
[11:15:26] <petermanser> oh and sublime :)
[11:16:29] *** Joins: tav (tav@moz-5ED3AF3C.range86-152.btcentralplus.com)
[11:16:39] <leonvv> How can you make a member of a struct mutable?
[11:16:54] <cmr> leonvv: You cannot. Either the whole struct is mutable, or none of it.
[11:18:01] <leonvv> So you should use "let mut" when you define a new struct?
[11:18:20] <cmr> (construct, not define) yes, if you need it to be mutable.
[11:18:30] *** Joins: olleharstedt (Thunderbir@moz-80D8890F.ias.bredband.telia.com)
[11:18:41] <leonvv> Okay, thanks
[11:18:56] *** Joins: sk (sk@2A567C1F.54A580E3.78DD174B.IP)
[11:19:46] *** Joins: sigma (sigma@51C589B3.EF2694B5.DFAC6AA7.IP)
[11:20:32] *** Joins: infynyxx (infynyxx@DB780A29.749BA1D.DCC373F0.IP)
[11:21:20] *** Quits: alex-abreu (alex@moz-7421D6C9.mc.videotron.ca) (Ping timeout)
[11:22:19] *** Quits: infynyxx (infynyxx@DB780A29.749BA1D.DCC373F0.IP) (Ping timeout)
[11:22:35] *** Joins: alex-abreu (alex@moz-7421D6C9.mc.videotron.ca)
[11:23:59] *** Joins: SiegeLord (sl@moz-CAF07B4C.hsd1.ma.comcast.net)
[11:26:43] <kimundi> In fact there IS a eclipse plugin somewhere. I just don't know if it'S usable
[11:26:43] *** Quits: mcclurmc (mcclurmc@moz-A19237A1.scouts.catn.com) (Ping timeout)
[11:29:35] *** Joins: erickt (erickt@8C9ECD8F.3A598286.F12515B4.IP)
[11:32:21] *** Quits: alex-abreu (alex@moz-7421D6C9.mc.videotron.ca) (Ping timeout)
[11:32:21] *** Quits: erickt (erickt@8C9ECD8F.3A598286.F12515B4.IP) (Ping timeout)
[11:33:16] *** Joins: infynyxx (infynyxx@moz-E95B370B.nyc.res.rr.com)
[11:33:39] *** Joins: alex-abreu (alex@moz-7421D6C9.mc.videotron.ca)
[11:34:54] *** Quits: novabyte (Instantbir@moz-3E0F9699.cable.virginmedia.com) (Ping timeout)
[11:35:50] *** Joins: novabyte (Instantbir@moz-3E0F9699.cable.virginmedia.com)
[11:36:13] <dbaupp> leonvv: you do need a specific member to be mutable you can use Cell (http://static.rust-lang.org/doc/std/cell.html), or @mut, but using the ownership method (i.e. `let mut`) is *much* better.
[11:36:45] <cmr> @mut and Cell cause dynamic failures, though... very bad solution if you can avoid it
[11:37:02] <dbaupp> cmr: yes
[11:38:40] <leonvv> Will keep it in mind dbaupp, tanks
[11:38:43] <leonvv> thanks*
[11:39:01] *** Quits: scanlonman (scanlonman@moz-169BC238.hsd1.wa.comcast.net) (Quit: My MacBook has gone to sleep. ZZZzzzâ€¦)
[11:39:22] <dbaupp> leonvv: (as cmr says, they cause dynamic failures, i.e. errors which can't be caught by the type system, so it is best to avoid if at all possible
[11:39:24] <dbaupp> )
[11:40:54] <leonvv> allright
[11:42:43] *** Joins: elspruto (elspruto@moz-A9EADF4E.bb.online.no)
[11:47:32] *** Joins: msingle (Thunderbir@moz-930E5D97.hr.hr.cox.net)
[11:52:36] *** Joins: tiffany (kawaii@moz-1E0FE6E8.dhcp.embarqhsd.net)
[12:01:59] *** kimundi is now known as zz_kimundi
[12:05:03] *** Joins: pnathan1 (Adium@B9840254.2CD8A5F8.477B877D.IP)
[12:05:32] *** Quits: leonvv (leonvv@moz-7D83A5F1.ip.telfort.nl) (Client exited)
[12:05:43] *** Quits: robertknight (robertknig@moz-54528EE0.wby.mendeley.com) (Quit: Computer has gone to sleep.)
[12:09:44] *** Quits: fabiand (fabiand@moz-680BCD95.adsl.alicedsl.de) (Quit: Verlassend)
[12:11:05] *** Quits: pnathan1 (Adium@B9840254.2CD8A5F8.477B877D.IP) (Ping timeout)
[12:12:06] *** Quits: dimension (dimension@moz-4CCD79C5.dsl.dynamic.simnet.is) (Ping timeout)
[12:31:01] *** Joins: erickt (erickt@8C9ECD8F.3A598286.F12515B4.IP)
[12:31:27] *** Joins: stugol (Mibbit@moz-5F38F85.know.cable.virginmedia.com)
[12:31:37] <stugol> hi
[12:32:17] *** Joins: Cromulent (Cromulent@moz-983B638D.cable.virginmedia.com)
[12:32:17] <dbaupp> hello
[12:33:11] <doomlord> i see libclang has a *c* interface, thats encouraging, anyone know off hand if its up to date/useable
[12:33:15] <doomlord> is that the 'real'interface to it
[12:33:43] <doomlord> have they really been nice enough to make libclang useable from rust :)
[12:33:49] *** Quits: erickt (erickt@8C9ECD8F.3A598286.F12515B4.IP) (Ping timeout)
[12:34:14] <stugol> I'm wondering what kind of IDE support rust has. Visual Studio integration, for instance, or Code::Blocks. I really like the look of the language, but I don't enjoy coding in a basic text editor. It's alright for scripting, I guess.
[12:35:03] <doomlord> heh. i'd like to mention rust is uniquely searchable from the command line, due to syntax choices.. eg grep "fn\sname.."
[12:35:35] <pnkfelix> stugol: there are emacs and vim modes in src/etc/{emacs,vim}
[12:35:37] <doomlord>  i haven't yet tried any IDE support - apparently there is eclipse... but
[12:35:45] <bstrie> stugol: I think we have plugins for sublime text, vim, and emacs. there *might* be an eclipse plugin somewhere. I haven't heard of VS support
[12:35:45] <doomlord> .. eclipse makes my laptop overheat
[12:36:11] <pnkfelix> stugol: others too, like GEdit.  Also in src/etc/*
[12:36:14] <doomlord> stugol using gedit and some python (i;ve put on the web) and grep - i was able to make "jump to definition" in gedit
[12:36:21] <bstrie> stugol: do you know how to make a VS plugin? we'd love to take it as a contribution :)
[12:36:27] <SiegeLord> doomlord: I think rust-bindgen uses it, not sure
[12:37:20] <bstrie> stugol: one problem is that we don't have anyone who really knows their way around windows. basically a chicken and egg problem... poor windows support so we never have windows users, no windows users so we never have windows support...
[12:37:45] *** Quits: Palmik (palmik@moz-CC484FDD.tmcz.cz) (Ping timeout)
[12:37:50] <doomlord> stugol, the traits system also contributes to the source being more searchable:... because their classes are broken up into smaller traits, its easier to keep the few relevant declarations on screen in a simple editor
[12:37:53] <stugol> Haven't the faintest idea, I'm afraid. Never coded one. I'd be up for helping out with one though, if anyone has any experience with it.
[12:38:31] <doomlord> i'll try to stop raving about the commandline if someone is eager to write VS integratiion :)
[12:38:56] <bstrie> actually, dammit. I do technically have VS2010 on my work computer
[12:38:58] <stugol> I know my way around Windows pretty well, and have coded many programs for it; but never developed a VS plugin. Are there any tutorials available, do you know? I haven't seen any. How *do* people learn how to write them?
[12:39:12] <dbaupp> stugol: Rust is designed to be first-class on windows, but what bstrie is true, so it isn't quite there yet.
[12:39:20] <bstrie> stugol: you'll have to ask the internet :)
[12:39:36] <stugol> Yeah, I did that. The Internet replied "fucked if I know"
[12:39:38] <dbaupp> bstrie: (are you kibwen on reddit/hn?)
[12:40:01] *** Quits: Cromulent (Cromulent@moz-983B638D.cable.virginmedia.com) (Quit: KVIrc 4.2.0 Equilibrium http://www.kvirc.net/)
[12:40:21] <dbaupp> stugol: ask it more forcefully? :(
[12:40:32] <stugol> I use Linux as well, but I'm not eager to code in vi or emacs. I understand they're a bugger to learn.
[12:40:36] <bstrie> dbaupp: indeed
[12:40:54] *** Quits: jensnock_ (jensnocker@moz-8BE55278.customer.t3.se) (Input/output error)
[12:40:55] <bstrie> stugol: using vim is like making beautiful music :)
[12:41:35] <dbaupp> bstrie: haha, nice
[12:41:46] <Ms2ger> bstrie, needs years of practice?
[12:41:49] <stugol> Don't think I've ever used it. I tried to install it once, and a vim plugin for something - might've been rust, might've been red - and it didn't work.
[12:41:57] <stugol> I don't mind which platform I use Rust on initially, but decent IDE support is kinda important.
[12:42:30] <bstrie> stugol: http://msdn.microsoft.com/en-us/library/dd885119.aspx ?
[12:42:48] *** Joins: stoyan (stoyan@9F9D4CC6.CFAEAD7C.921A050B.IP)
[12:42:50] <dbaupp> stugol: what do you normally use an IDE for? because, as doomlord says, Rust is very ameniable to tools like grep. (admittedly less slick than a good ide.)
[12:42:57] <stugol> I've read all the Rust documentation, and really like the look of it - especially the different types of pointer - but I kinda like my Intellisense and debugging support...
[12:43:29] <stugol> dbaupp: Autocomplete, watch window, debug stepping mainly
[12:43:41] *** Joins: ghrust (ghrust@E7A4CCE2.6A2AE50.F3114085.IP)
[12:43:41] <ghrust> 01[13rust01] 15bors merged 06auto into 06master: 02http://git.io/Q3aFpg
[12:43:41] *** Parts: ghrust (ghrust@E7A4CCE2.6A2AE50.F3114085.IP) ()
[12:43:45] <stugol> Also I don't know a makefile from my elbow.
[12:43:52] <bstrie> stugol: we hate makefiles too
[12:43:59] <hansjorg_> Here's an eclipse plugin for rust: https://github.com/reidarsollid/RustyCage
[12:44:08] <hansjorg_> not updated in a couple of months though
[12:44:15] <dbaupp> stugol: aha, yeah, Rust's debugging support in general is pretty horrible, so you wont get that even with an IDE :P
[12:44:23] <bstrie> stugol: ideally rust won't really ever need makefiles unless you're doing things with foreign code
[12:44:42] <dbaupp> (it's improving a *lot* though, there is an intern who is making brilliant progress on it right now.)
[12:44:45] <doomlord> the thing about commandline tools is you dont have to load up the whole project... and you can better deal with bits of rust source in isolation as they dont need so much context
[12:45:24] <doomlord> i wanted to write a simple commandline assist to find functions with associated module path..
[12:45:27] <bstrie> stugol: maybe making a codeblocks plugin would be easier :)
[12:45:38] <doomlord> .. i haven't been so motivated to do it because grep just seems good enough :)
[12:45:58] <stugol> The VS extension tutorials you linked me to....think I've seen them before. They're not enough. That's the point: There just isn't enough information out there.
[12:46:10] *** Quits: SiegeLord (sl@moz-CAF07B4C.hsd1.ma.comcast.net) (Quit: It's a joke, it's all a joke.)
[12:46:11] <bstrie> grep is ok... I still really wish I had some way to tell which types implemented which traits, and vice versa
[12:46:14] <stugol> How other people manage it is a mystery to me. Python has a VS plugin. How did they learn? I have no idea.
[12:46:22] <bstrie> *some easier way
[12:46:38] <dbaupp> bstrie: here's hoping for cmr's rustdoc v2
[12:46:40] <stugol> Syntax highlighting is also really helpful
[12:46:44] *** Joins: ghrust (ghrust@F6EE6DE3.6A2AE50.F3114085.IP)
[12:46:44] <ghrust> 01[13rust01] 15bors pushed 0 new commits to 06auto: 02http://git.io/m3j2dA
[12:46:44] *** Parts: ghrust (ghrust@F6EE6DE3.6A2AE50.F3114085.IP) ()
[12:46:45] *** Joins: ghrust (ghrust@DE823A67.6A2AE50.F3114085.IP)
[12:46:45] <ghrust> 01[13rust01] 15bors pushed 3 new commits to 06auto: 02http://git.io/ycy7tw
[12:46:45] <ghrust> 13rust/06auto 14f819860 15Seo Sanghyeon: Add a lint to detect unnecessarily qualified names
[12:46:45] <ghrust> 13rust/06auto 14f20c78c 15Seo Sanghyeon: Add a compile-fail test for qualification lint
[12:46:46] <ghrust> 13rust/06auto 14ad70813 15bors: auto merge of #7706 : sanxiyn/rust/qualification-lint, r=pcwalton...
[12:46:47] <doomlord> also rusts' lack of full overloading can be "less is more"... rust code tends to be halfway between C and C++ in how much overloading there is
[12:46:48] *** Parts: ghrust (ghrust@DE823A67.6A2AE50.F3114085.IP) ()
[12:46:58] <pnkfelix> stugol: a properly configured emacs gives you much of what you listed
[12:46:59] <bstrie> stugol: is there a plugin for D? maybe you can find the source and find/replace "D" with "Rust"
[12:47:07] <pnkfelix> stugol: I know you already said you don't want to attempt to learn it
[12:47:11] <doomlord> there's more in the way of method_name_with_some_variation  as opposed to it all coming from arguments
[12:47:23] <pnkfelix> stugol: but I figure I might as well point out that a lot of us agree with the "pro's" you are listing.
[12:47:33] <stugol> I don't see how that'd work. D and Rust will have radically different syntax.
[12:48:28] <doomlord> is there any go support, go has some similar ideas
[12:48:42] <doomlord> oh but no generics..
[12:48:52] <stugol> Go is shite. And doesn't have any VS support.
[12:49:08] *** Joins: jdm (jdm@92FB48CA.8B5E9DF.9A8C35B4.IP)
[12:49:18] <stugol> I think we need to find someone who's written a VS plugin already. I'd be quite happy to help out, but I just don't have the information I need.
[12:49:23] <bstrie> stugol: no go-bashing in here, please
[12:49:55] *** Parts: stoyan (stoyan@9F9D4CC6.CFAEAD7C.921A050B.IP) ()
[12:50:20] <stugol> Really? I was just about to point out how unfriendly the Go community was. Ah well.
[12:50:28] <doomlord> (i rejected go because : GC-only ; no const; no generics; harder to read without var:type for my C++ brain )
[12:50:35] <stugol> Generics are a *must*
[12:50:49] <bstrie> stugol: we're not interested in a language war :)
[12:50:50] <doomlord> it does have reflection though
[12:51:12] <doomlord> heh should be... rust will win hands down :)
[12:51:13] <dbaupp> stugol: Go v Rust has caused more than one flame war here; it's nice to avoid them :)
[12:51:23] *** Quits: msingle (Thunderbir@moz-930E5D97.hr.hr.cox.net) (Ping timeout)
[12:51:34] <stugol> Fair enough. Besides, Rust looks awesome to me.
[12:51:47] <stugol> It's just the IDE issue holding me back.
[12:51:52] <bstrie> stugol: alternatively, take the language wars to our sister channel, #rust_for_assholes
[12:52:25] <stugol> Uh....is that a real channel?
[12:52:38] <stugol> Seriously, none of the Rust developers have any experience of writing a VS plugin at all?
[12:52:45] <Ms2ger> Quite possibly
[12:52:54] <bstrie> stugol: it's quite a specialized skill
[12:53:02] <Ms2ger> Do you have experience? :):
[12:53:07] <dbaupp> stugol: very few have decent experience on windows, at all... it's a problem :(
[12:53:09] <bstrie> stugol: all the rust developers tend to use vim or emacs :P
[12:53:19] <hoelzro> I get the feeling that most Rust devs avoid Windows =)
[12:53:25] <stugol> Hmm. Any idea how we could bring one on board?
[12:53:40] <stugol> But there's no decent IDE support for it in Linux either, so that's not really an excuse.
[12:53:42] <bstrie> stugol: abduction. blackmail
[12:53:52] <stugol> Sigh
[12:54:02] <stugol> I get the impression you're not taking it seriously
[12:54:03] *** Joins: ChrisMorgan (chris@moz-6AC741CA.static.tpgi.com.au)
[12:54:11] <dbaupp> stugol: IDEs are much less common on Linux
[12:54:24] <bstrie> stugol: the language isn't stable yet, any plugin would need to be updated constantly. cf the fate of the eclipse plugin
[12:54:28] <hoelzro> I think most people interested in Rust are firmly entrenched in the Vim/Emacs crowd
[12:54:28] <pnkfelix> stugol: we have a ctags configure file.  That gets a lot of the job done for source browsing
[12:54:47] <hoelzro> so there's been no incentive to develop tooling for IDEs
[12:54:59] <stugol> You've got a really neat language here, but my only options are Notepad or Nano, essentially. Yeah, I know there's vi and such, but they're all the same really.
[12:55:22] <pnkfelix> stugol: Notepad != vim.  Notepad != emacs.  I'm not going to attempt to elaborate further.
[12:55:27] <bstrie> stugol: someone who cares has to do the work. the devs are all busy doing Extremely Important Things, so it's up to the community
[12:55:33] <stugol> How does anyone get anything done? I seriously couldn't imagine writing a large application in a text editor.
[12:55:36] <StarLight> stugol: or st2
[12:55:54] <bstrie> stugol: to be fair, emacs is basically an operating system :P
[12:56:06] <stugol> Maybe so, but I understand it's a total bastard to learn.
[12:57:00] <hoelzro> I personally feel more productive with Vim than I did when I was using IDEs
[12:57:26] <stugol> I could write a simple IDE myself, but getting the syntax highlighting to work properly would be tricky. How uniform is the syntax? Can it be summarised in a few rules? Are there many exceptions to the rule?
[12:57:35] <hoelzro> I wrote a simple Qt application earlier this week; I used Qt creator to create the UI file and Vim to edit the C++
[12:57:40] <cmr> stugol: there is no debugger, anything to watch, *or* autocomplete daemon. No IDE integration will be useful.
[12:57:51] <bstrie> stugol: we have a grammar defined, but I'm not sure what format VS needs
[12:57:59] <cmr> Also writing VS extensions is awful/black magic
[12:58:03] <stugol> I mean I could write my own.
[12:58:07] <cmr> the PTVS is microsoft employees iirc
[12:58:11] <stugol> Outside of VS
[12:58:23] <stugol> Platform independent, possibly.
[12:58:46] <stugol> Isn't it a pain to switch between multiple source files in vim? I've not used it, but text editors tend to be single-file-at-a-time.
[12:58:57] <stugol> I like to have a dozen code files open and switch between them
[12:59:13] <hoelzro> it's pretty simple
[12:59:25] <dbaupp> stugol: http://stackoverflow.com/questions/53664/how-to-effectively-work-with-multiple-files-in-vim
[12:59:28] <monk> stugol: If you want IDE support then it suggests you're writing something Serious(tm) - in which case I have a suspicion that rust itself is not ready for you in any case
[12:59:31] <doomlord> stugol: i've found gedit is sufficient - and there are better editors like notepad++ i think,sublime text..
[12:59:33] <cmr> I often have 5-6 files open in splits, with a bunch of buffers in the background
[12:59:38] <hoelzro> dbaupp: thanks, saved me some typing =)
[12:59:43] <doomlord> gedit + 2-3 terminal windows
[12:59:49] <bstrie> stugol: nobody's tell you to learn vim, we'll have better IDE support *eventually* once the language calms down. you can try again then :)
[12:59:58] <cmr> stugol: anyway, just use a text editor that has tabs and multiwindow support if you want to use rust now.
[13:00:20] <doomlord> i tried emacs but kept gravitating back to Gedit, because its most simmilar to windows tools with its keys
[13:00:25] <cmr> stugol: there is pygments support for rust, you don't need to write your own syntax highlighting
[13:00:31] <dbaupp> stugol: monk is 100% correct; library breakage is very common (language breakage happens, but it happens every so often).
[13:00:33] <bstrie> doomlord: what do you use for C++?
[13:00:44] <dbaupp> *happens less
[13:00:50] <doomlord> QtCreator, and i've tried eclipse CDT
[13:01:05] <doomlord> i'm most productive with Visual Studio for C++, but have tried to stay of linux,
[13:01:11] *** Joins: MaikKlein (maik@moz-B9C8EE03.dip0.t-ipconnect.de)
[13:01:15] <doomlord> also the most recent C++ i've written has been X-Code mostly
[13:01:21] <stugol> I use VS for C++. I tried Code::Blocks, but it wouldn't compile my source. Strange.
[13:01:25] <cmr> VS is by far the best IDE, just not easy to extend
[13:01:32] <doomlord> crossplatform project OSX/iOS/linux/windows
[13:02:03] <bstrie> cmr: ah, I hear that first you have to embrace it. allegedly it's a three-step process.
[13:02:04] <doomlord> xcode is ok,  i REALLY like the combination of apples' window management and trackpad for navigating lots of text
[13:02:19] <stugol> Where is the grammar defined? And where can I look up how to read the grammar?
[13:02:36] <doomlord> the thing is... despite VS i find going back to commandline appealing - and that contributes to my enjoyment of rust.
[13:02:49] <cmr> stugol: there is no official formal grammar anywhere... there's bits in the manual, and an antlr grammar somewhere
[13:02:51] <doomlord> i can comfortably develop rust with simple tools. With C++, i need the crutch of a complex IDE
[13:02:52] <dbaupp> stugol: that was sort-of a lie, there isn't really a grammar defined (and it is liable to change, just like everything else)
[13:02:55] <cmr> it's LL(1), super simple to parse
[13:03:00] <bstrie> stugol: https://github.com/jbclements/rust-antlr/ , but I have no idea how to read it
[13:03:01] <StarLight> stugol: http://static.rust-lang.org/doc/0.7/rust.html iirc
[13:03:03] *** Joins: reyre (reyre@F2D29657.F60B0462.67AC9B1.IP)
[13:03:08] <pnkfelix> stugol: there's a draft of an antlr4 grammar for rust at: https://github.com/jbclements/rust-antlr
[13:03:24] <doomlord> an IDE falls down when you want a customproject layout... crosplatform code,  lots of testbeds
[13:03:43] <pnkfelix> cmr: I don't think we've actually gotten it down to LL(1).  But its probably safe to assert that its LL(k) for some k.
[13:03:46] <cmr> bstrie: don't get me wrong, I far prefer what I have to an IDE, but VS is the best IDE
[13:03:54] <doomlord> its funny because the syntax should make IDE support superior to C++ .. but no one seems to be bothered doing it beacuse commandline works so well :)
[13:04:01] <cmr> pnkfelix: I thought pcwalton got it down to LL(1), there was ML posting about it..
[13:04:09] <pnkfelix> cmr: oh let me double check
[13:04:20] <dbaupp> pnkfelix: I thought pcwalton got it to LL(2) and then later said a tool claimed some revised version was LL(1)?
[13:04:25] <cmr> it was the thread at https://mail.mozilla.org/pipermail/rust-dev/2013-April/003764.html
[13:04:28] *** zz_kimundi is now known as kimundi
[13:04:47] <pnkfelix> cmr: Ah right
[13:04:50] <bstrie> I think the idea is that theoretically any LL(k) for finite k can be reduced to LL(1) if you do enough bullshit
[13:04:58] <cmr> heh
[13:05:17] <bstrie> I think graydon was happy enough at LL(2)
[13:05:23] <doomlord> what's all the jargon here: what do you need to do r.e gramar,
[13:05:24] <stugol> I would've thought that putting a few man-hours into writing an IDE - or finding someone to do it for you - would increase the accessibility of the language and make it more popular.
[13:05:44] <doomlord> i know what context-free refers to compared to C++ .. but production rules can still create ambiguity ?
[13:05:46] <cmr> stugol: it's a lot more than a few hours.
[13:05:55] <bstrie> stugol: do you know someone with experience writing a VS plugin? we sure don't
[13:05:58] <cmr> stugol: MaikKlein is working on-and-off on an autocompletion daemon
[13:05:58] <stugol> If you don't do any IDE stuff until you're done messing with the language, then nobody will use it.
[13:06:01] <pnkfelix> bstrie: no, not quite, at least for the general case (not human-designed grammars)
[13:06:06] <pnkfelix> bstrie: http://cs.stackexchange.com/questions/43/language-theoretic-comparison-of-ll-and-lr-grammars 
[13:06:07] <doomlord> stugol - i think they are prioritizing correctly
[13:06:11] <cmr> Besides, noone really uses or needs an IDE...
[13:06:16] <stugol> I do
[13:06:21] <cmr> well for rust I mean
[13:06:22] <bstrie> cmr: that's a like :P
[13:06:25] <bstrie> er
[13:06:25] <dbaupp> stugol: writing a whole new IDE seems like it would be counter productive, when the language changes constantly, and the tooling required for proper IDE support doesn't exist
[13:06:25] <bstrie> lie
[13:06:31] <doomlord> IDE will be good. but they have more important fixes
[13:06:41] <bstrie> IDEs are useful to many
[13:06:45] <bstrie> we need to support more
[13:06:49] <bstrie> C++ users will expect it
[13:07:00] <stugol> I just have no idea how I would even begin to code in Rust without an IDE.
[13:07:00] <bstrie> it's not optional
[13:07:14] <tiffany> uh.. with a text editor, and a copy of the manual?
[13:07:21] <monk> use the windows installer. open cmd, run 'rustc hello.rs'
[13:07:28] <AutomatedTester> what IDE do c++ people use on linux/OSX?
[13:07:30] <pnkfelix> stugol: Its true.  You may want to take the first step of learning how to program in C or C++ without an IDE
[13:07:45] <dbaupp> AutomatedTester: XCode on OSX, I guess.
[13:07:47] <bstrie> stugol: that's fair, and a time will come when we have more IDE support. right now nobody's interested in maintaining plugins for a language that's still makes breaking changes every week
[13:07:48] <stugol> My brain doesn't work that way. I like to have a tree of the project files, and tabs open.
[13:07:48] <doomlord> OSX: xcode
[13:07:53] <pnkfelix> stugol: I'm not being facetious; it might help you obtain the mindset necessary for using the language in its current state
[13:08:05] <doomlord> linux: QtCreator, very C++ specific. eclipse CDT, very heavyweight
[13:08:06] <tiffany> many text editors offer both of those stugol
[13:08:06] <dbaupp> stugol: some text editors provide that
[13:08:15] <doomlord> eclipse makes my laptop overheat
[13:08:20] <AutomatedTester> doomlord: ahh cool, thanks
[13:08:40] <doomlord> i can't do C++ with emacs, i tried. its awful :)
[13:08:42] <stugol> It's hard enough to get C++ to compile in VS, let alone on the commandline. Do I look like a masochist? It took me four days this week just to get a simple set of template classes to compile.
[13:08:56] <bstrie> doomlord: so what you're saying is that eclipse can be used as an effective form of birth control
[13:08:57] <tiffany> but we're not asking you to use C++ without an IDE
[13:09:03] *** Parts: thomas_adam (n6tadam@moz-66E7E77B.vm.bytemark.co.uk) ()
[13:09:08] <stugol> And that's not because I suck, it's because C++ is horrible.
[13:09:09] <tiffany> we're asking you to use rust without an IDE, and rust's compilation process is much easier
[13:09:13] <cmr> well that's a C++ and VS problem :p rustc is quite usable
[13:09:17] <pnkfelix> tiffany: (well, I might have, but I need to get out of this rathole of a conversation)
[13:09:39] <cmr> stugol: anyway, a VS extension for basic syntax highlighting, file extension, and compiling would be nice
[13:09:46] <bstrie> stugol: doomlord is a hardcore C++ guy, ask how he manages
[13:09:49] <cmr> But, we don't have debugging on windows (and barely on linux/osx)
[13:09:58] <doomlord> stugol: a lot of what you need VS for is C++'s complexity.. a major point of rust is a redesign that avoids/manages complexity better
[13:09:59] <dbaupp> stugol: it probably sounds a lot like "Rust people hate IDEs", but this is only temporary. There are many many other problems that need solving (1340 of them, in fact)
[13:10:16] <cmr> down 300 from 0.6 I think?
[13:10:27] <doomlord> yes - i've used VS mostly - and i'm genuinely *enjoying* Rust from the commandline + simple editors
[13:10:27] <dbaupp> cmr: really?
[13:10:32] <cmr> dbaupp: iirc
[13:10:38] <dbaupp> cmr: neat
[13:10:42] <doomlord> i used VS for 8+ years i think
[13:10:44] <cmr> I thought it was ~1.6k when I got started, which was shortly after 0.6
[13:10:46] <bstrie> cmr: I don't think so... I think we've been floating around 1300 for months now
[13:11:07] <doomlord> before that i used 'codewrite'+commandline tools for C
[13:11:12] <bstrie> though maybe I've forgotten
[13:11:16] *** Joins: fabiand (fabiand@A5E4BB21.FE11524D.16E13E53.IP)
[13:11:30] <dbaupp> bstrie: wasn't graydon's triage email thing after 0.6?
[13:11:33] <MaikKlein> I think I have something super simple ready this month for autocompletion
[13:11:33] *** Joins: pyrac (pyrac@moz-F2C67F88.w83-114.abo.wanadoo.fr)
[13:11:40] * dbaupp should get added to that
[13:12:04] *** Quits: StarLight (StarLight@moz-D9755DF.dynamic.avangarddsl.ru) (Ping timeout)
[13:12:09] <stugol> I guess I just assumed anyone capable of writing a serious compiler from the ground up would have some vague idea how to find a Windows VS extension developer and entice him on board. I don't know where to find one, but I also don't know how to write a lexer, so...
[13:12:12] <bstrie> dbaupp: you should!
[13:12:27] *** Joins: robertknight (robertknig@moz-54528EE0.wby.mendeley.com)
[13:12:37] <bstrie> dbaupp: the triage mails didn't immediately drop the bug count by 300, it just arrested the exponential growth
[13:12:59] <bstrie> it's actually really great that we've been so steadily around 1300
[13:13:01] <dbaupp> stugol: writing compilers and herding cats are different skills (although graydon seems pretty good at both)
[13:13:16] <cmr> stugol: it's not really important atm though
[13:13:21] <stugol> *shrug*
[13:13:22] <cmr> we need good IDE integration for 1.0
[13:13:27] <cmr> but that's down the road a ways still
[13:13:30] *** Joins: mcclurmc (mcclurmc@moz-A19237A1.scouts.catn.com)
[13:13:33] <doomlord> stugol: points for using rust with simple tools,if your fearing no IDE:  [1] no header files - navigation between definitions/declarations doesn't happen. [2] traits divide definitoins/implemenations up better into more manageble units, easy to keep the ones of interest onscreen [3] traits are referenced in function signatures, easy again to search ; [4] anything is easy to search for - grep (struct|trait|impl|fn|type)\s*name [5
[13:13:33] <doomlord> ] less overloading than C++means more searchable names (midway between C/C++)
[13:13:34] <monk> stugol: I imagine quick wins would be making it easy to get to the point of running some rust code that you can edit in VS, and not worrying about anything involving lexers. E.g. a rust "template" and a way to build/run.
[13:13:52] <stugol> What's a trait, specifically?
[13:13:59] <stugol> And what do you mean "less overloading"?
[13:14:02] <doomlord> its like an interface, but works for staticly linked
[13:14:03] <stugol> I like overloading
[13:14:16] <monk> stugol: you like argument dependent lookup? ;)
[13:14:27] <doomlord> you can overload on the first parameter only, in effect.
[13:14:38] <bstrie> monk: argument dependent lookup isn't that bad :P
[13:14:40] <doomlord> before you panic, you can combine multiple parameters in the first as a tuple
[13:14:56] <cmr> stugol: traits are typeclass, roughly corresponds to java interface + static dispatch for generics
[13:14:57] <dbaupp> doomlord: you can overload on any number of arguments, just need more traits.
[13:15:11] <cmr> don't ask me what a typeclass is, I don't know :p
[13:15:12] <monk> bstrie: it's true. I'm quite used to haskell type classes which provide a similar mechanism, just more constrained.
[13:15:22] * ChrisMorgan is enjoying using Rust with Vim and, encountering shortcomings in its Vim tooling, is improving it bit by bit
[13:15:32] <doomlord> maybe i stillmisunderstood lol, but i thought that adding traits is just for generic coding.. not quite the same as overload
[13:15:40] <bstrie> monk: I bet haskell does something clever enough that it doesn't ever have to worry about variadic functions
[13:15:43] *** Quits: RMF (RMF@moz-4C4EB011.dsl.telepac.pt) (Ping timeout)
[13:15:46] <dbaupp> monk: haskell's type classes are *more* constrained than Rust's traits?
[13:15:50] <bstrie> ChrisMorgan++
[13:16:00] <monk> dbaupp: more constrained than C++ ADL
[13:16:06] <dbaupp> bstrie: you can write variadic functions in Haskell using type-classes
[13:16:10] <dbaupp> monk: oh, right
[13:16:20] <doomlord> a.foo(b)   a.foo(c)   b:B   c:C  can't call 2 different functions?  just 2 generated functions from foo<T>(&self,v) 
[13:16:22] *** Joins: StarLight (StarLight@moz-5E9078D.dynamic.avangarddsl.ru)
[13:16:31] <monk> stugol: one thing about overloading in C++, is that it's quite confusing when combined with implicit conversions
[13:16:48] <doomlord> stugol - compared to C++ the lack of overloading takes getting used to , this is true
[13:16:56] * ChrisMorgan expects to create a PR which adds src/etc/vim/compiler/rustc.vim in the next hour or so
[13:17:04] <monk> from what I can tell rust does a better job at forcing you to explicitly convert between types
[13:17:20] <doomlord> stugol - but with that i find WAY more to like about rust. admitedly i am really a C/C++ person, not a C++ person :)
[13:17:49] <dbaupp> monk: (but it doesn't do a good job of making those conversions sensible yet :/ )
[13:17:53] <doomlord> i dont use c++ in a perfect way always. i drop back to C like habits
[13:18:05] <monk> dbaupp: fair enough. need to try more Â¬_Â¬
[13:18:06] <dbaupp> rusti: let x = 5 as bool; (x, x == true) // monk
[13:18:07] -rusti- (true, false)
[13:18:19] *** Joins: donri (dag@moz-9BB61102.tbcn.telia.com)
[13:18:20] <stugol> I'm still a bit unclear about the overloading and traits. If a trait is a statically-types interface, then surely it's an abstract base class? And why only overload on first argument?
[13:18:38] <dbaupp> monk: the issues are generally just bugs though.
[13:18:52] <cmr> stugol: (well there are also trait objects for dynamic dispatch (vtables))
[13:18:58] <doomlord> its like an abstract base class, except it can work with compile time polymorphsim aswell
[13:19:04] <monk> dbaupp: Is there a (draft) spec for rust?
[13:19:13] <doomlord> stugol it doens't have vtables- it only adds those to 'trait objects' if you ask for them
[13:19:18] <cmr> Why we don't have overloading? Ask graydon or something
[13:19:25] <cmr> *or someone
[13:19:30] <dbaupp> monk: other than rustc's current behaviour + various blog posts/mailing list emails, no
[13:19:37] <cmr> and the manual
[13:19:42] <cmr> which is incomplete and wrong in places
[13:19:43] *** Joins: RMF (RMF@moz-395E4371.dsl.telepac.pt)
[13:19:50] *** Quits: pnkfelix (pnkfelix@87C1F78E.1DE10CA8.D8E68FF6.IP) (Quit: Leaving.)
[13:19:53] *** Joins: pnkfelix (pnkfelix@87C1F78E.1DE10CA8.D8E68FF6.IP)
[13:20:07] <doomlord> the best description i can give is 'half overloading' :) put any parameters you'd overload on the front, in a tuple. the rest is *generic*,not the same as overload.
[13:20:21] <doomlord> you can explain more with a function name; and that contributes to readability
[13:20:31] <doomlord> and searchability
[13:20:36] <bstrie> doomlord: I'm not sure what you mean by saying you can only overload on the first argument
[13:20:43] <stugol> I think I need to read the manual again
[13:20:46] <doomlord> have i misunderstood 
[13:21:00] *** Quits: MaikKlein (maik@moz-B9C8EE03.dip0.t-ipconnect.de) (Ping timeout)
[13:21:12] *** Joins: infynyxx_ (infynyxx@DB780A29.749BA1D.DCC373F0.IP)
[13:21:13] <dbaupp> doomlord: you can easily overload on many arguments, e.g. https://github.com/mozilla/rust/blob/master/src/libstd/rand.rs#L69
[13:21:13] <cmr> stugol: manual is useless; read code examples or the various links on reddit
[13:21:41] *** Quits: mark_edward (quassel@moz-4A9A2F15.dynamic.utc.edu) (Ping timeout)
[13:21:45] <dbaupp> doomlord: (although that's a static method, so it's not exactly a good example, but you could imagine it took a self parameter)
[13:21:54] *** Joins: pczarn (Mibbit@moz-69A55FA.izacom.pl)
[13:21:57] <stugol> Uh....the manual is useless?
[13:22:03] <stugol> For fuck sake....
[13:22:04] <cmr> stugol: it's wrong and incomplete
[13:22:06] <cmr> unmaintained
[13:22:07] <dbaupp> stugol: as a learning tool, yes
[13:22:08] <cmr> rust is pre-alpha
[13:22:09] <ChrisMorgan> I contest that, cmrâ€”the manual is very useful as a starting place, explaining various of the things you need to know. The fact that it's often wrong or incomplete detracts from it, but it's useful.
[13:22:23] <doomlord> all the "fn rand"  i see take one arguemtn :)
[13:22:33] <pnkfelix> cmr: well, the code examples are all automatically run, right?
[13:22:38] <pnkfelix> cmr: so its sort of half-maintained
[13:22:38] <dbaupp> stugol: essentially the best & only way to learn rust is to write code & ask here
[13:22:41] <stugol> Okay, I have a question. I really like the look of Rust, but how the hell do you expect people to pick it up if the documentation is wrong?
[13:22:44] <doomlord> thats what i mean
[13:22:47] <cmr> stugol: we don't
[13:22:48] <bstrie> stugol: I keep trying to tell you not to use rust unless you're adventurous :P
[13:23:00] <stugol> There isn't even a damn forum.
[13:23:02] *** Quits: infynyxx_ (infynyxx@DB780A29.749BA1D.DCC373F0.IP) (Ping timeout)
[13:23:04] <doomlord> the "overload" is the impl  .. for , in my understandin
[13:23:08] <cmr> there's reddit and a mailing list
[13:23:12] <dbaupp> doomlord: you are correct, it wasnt a great example, but there could easily be a &self parameter
[13:23:13] <bstrie> stugol: don't use it. we're not stable. pre-pre-alpha. run away in fear
[13:23:26] <cmr> stugol: the languages syntax doesn't even stay the same from week to week
[13:23:40] <doomlord> ok i might not have realised you can overload on a *function* parameter aswell , thanks for updating my picture of rust
[13:23:49] <cmr> (slight exadgeration, but only slight)
[13:23:49] <stugol> But it looks like an awesome language. If you updated the docs occasionally, and had a Stack Overflow style forum where people could post questions....
[13:24:11] <dbaupp> stugol: at least one person answers questions regularly on SO itself
[13:24:14] <pnkfelix> stugol: StackOverflow itself doesn't suffice ?
[13:24:15] <bstrie> stugol: this channel and the mailing list are where we usually ask questions
[13:24:15] * dbaupp is that person
[13:24:17] <stugol> But IRC is only as useful as the people in it at any given time.
[13:24:22] <stugol> SO has a Rust section?
[13:24:24] <cmr> yes
[13:24:27] <bstrie> dbaupp: damn you and your free karma!
[13:24:40] <dbaupp> stugol: http://stackoverflow.com/questions/tagged/rust
[13:24:48] <doomlord> stugol, r.e. IDE its possible that i have nostalgic memories of commandline development which made me take to rust . My fingers still remember - and miss - brief/codewrite window manipulation
[13:24:49] <bstrie> stugol: you could also skip SO and just ask dbaupp right here!
[13:25:00] <stugol> Yeah, but what if he's not around?
[13:25:04] <dbaupp> bstrie: no! I need the karma! :P
[13:25:12] <doomlord> sugol i've found the community here extremely helpful
[13:25:18] <cmr> stugol: there's *always* someone around, never isn't
[13:25:48] <doomlord> i can't praise rust enough :) its what i've been waiting for for years. salvation from C++
[13:25:48] <dbaupp> stugol: (and they're usually willing to help.) 
[13:26:06] <doomlord> remember the IDE is a crutch
[13:26:16] <cmr> doomlord: not sure I agree with that
[13:26:20] <cmr> they are very useful tools
[13:26:23] <doomlord> heh ok i'm being extremist
[13:26:24] <cmr> autocompletion would be amazing
[13:26:31] <bstrie> stugol: once again, it's possible that rust isn't ready enough yet for your level of comfort. we expect early adopters to be comfortable browsing the source and putting up with shite documentation, because rust Isn't Ready Yet for casual users.
[13:26:36] <stugol> The IDE gives us a way to switch between a dozen or so source files easily. That's kinda useful.
[13:26:40] <doomlord> ok blah.<dropbox of options> is rather good
[13:26:52] *** Joins: bytewise (bytewise@moz-649C630D.unitymediagroup.de)
[13:26:52] <doomlord> stugol: ok - no header files, so you dont need to switch as much
[13:26:55] <monk> stugol: as has been said a number of times, so do most text editors
[13:26:58] <cmr> stugol: well yeah, I wouldn't use anything that didn't provide that, every text editor I've used *does*
[13:27:01] <pnkfelix> stugol: Please re-read bstrie's note
[13:27:05] <doomlord> [2] slightly more expressive with tuples - less custom types needed
[13:27:14] <dbaupp> stugol: fwiw, you've probably only had experience of pretty crappy text editors.
[13:27:16] *** Joins: maxli (maxli@F2D29657.F60B0462.67AC9B1.IP)
[13:27:20] <doomlord> functional style tends to be more concise
[13:27:22] <stugol> It's possible
[13:27:27] *** Quits: maxli (maxli@F2D29657.F60B0462.67AC9B1.IP) (Connection reset by peer)
[13:27:33] <doomlord> less noise/bloat onscreen compared to C++
[13:27:34] <stugol> Is it normal to have one-class-per-file, like in C?
[13:27:45] <cmr> stugol: not really, no.
[13:27:47] <bstrie> stugol: no
[13:27:50] <cmr> we also don't have classes
[13:27:52] <bstrie> stugol: we don't really have "classes" :)
[13:27:58] <doomlord> traits are families of functions
[13:28:05] <dbaupp> cmr: struct + impls
[13:28:10] <doomlord> functions and data are seperated really, and that is much better than classes
[13:28:15] *** Joins: maxli (maxli@F2D29657.F60B0462.67AC9B1.IP)
[13:28:15] <dbaupp> (at a stretch)
[13:28:29] <doomlord> classes are a false concept
[13:28:29] <stugol> Okay....so I'd generally have a file full of hundreds of lines of code?
[13:28:46] <dbaupp> it totally depends on what you want to do
[13:28:56] <cmr> stugol: the longest file in my personal projects is 249 lines
[13:28:58] <stugol> In C++, I tend to have dozens of files with a few lines of code each. Such is the burden of headers.
[13:29:21] <cmr> we don't really do that in rust
[13:29:22] <monk> that /is/ a good idea for incremental compilation.
[13:29:37] <stugol> What kind of Windows API support does it have? Can it natively import DLL functions?
[13:29:49] <cmr> we group things by logical relation, not by class
[13:29:51] <cmr> stugol: yes
[13:29:51] *** Joins: bytbox (s@moz-DC83764A.washdc.fios.verizon.net)
[13:30:09] <dbaupp> cmr (was that fixed on win?)
[13:30:13] *** Quits: maxli (maxli@F2D29657.F60B0462.67AC9B1.IP) (Quit: Leaving.)
[13:30:14] <cmr> Also has an interface to the dynamic linker at runtime
[13:30:18] <cmr> dbaupp: afaik?
[13:30:19] *** Joins: maxli (maxli@F2D29657.F60B0462.67AC9B1.IP)
[13:30:26] <stugol> How would I, for example, import CreateWindow from kernel32.dll?
[13:30:27] <dbaupp> cmr: cool
[13:30:36] <dbaupp> stugol: at runtime or compile time?
[13:30:44] <stugol> Er....both?
[13:31:04] <dbaupp> stugol: as in, you don't want to be calling LoadLibrary (or whatever) yourself?
[13:31:14] <cmr> stugol: https://github.com/mozilla/rust/blob/master/doc/tutorial-ffi.md#foreign-calling-conventions
[13:31:22] <stugol> Usually not, although it can sometimes be necessary.
[13:31:34] <dbaupp> https://github.com/mozilla/rust/blob/master/src/libstd/unstable/dynamic_lib.rs#L205
[13:31:43] <doomlord> stugol - i must rave about the macro system aswell, macros are not hazardous like in C, and they can do some of the things you'd want overloading for,  and they can do many things you try to do with "x-macros" but properly.. and more i haven't mastered yet
[13:31:49] <ChrisMorgan> How do people feel about old Rust questions on SO? My desire is to go through and update both questions and answers where appropriate, e.g. for http://stackoverflow.com/questions/9109872/rust-how-to-access-user-defined-types-instance use `match` rather than `alt`, &c. Does this sound a reasonable course of action? An alternative which I've been contemplating is having rust version tags, rust-0.7 &c.
[13:32:03] <cmr> ChrisMorgan: both sound reasonable
[13:32:06] <doomlord> stugol - with macros you can do something like overloading with named parameters
[13:32:11] <bstrie> ChrisMorgan: I too have the desire to update SO questions, but I'm waiting until 1.0
[13:32:12] <dbaupp> stugol: (that file is actually the implementation of runtime DLL loading, and contains an example of loading things from other headers.)
[13:32:26] *** Joins: erickt (erickt@8C9ECD8F.3A598286.F12515B4.IP)
[13:32:36] <dbaupp> ChrisMorgan: it would be an endless treadmill
[13:32:38] <stugol> These two links are both for static linking?
[13:32:42] <cmr> Yes.
[13:32:44] <cmr> No
[13:32:46] <cmr> Dynamic linking
[13:32:58] <cmr> But not loading the library with the linker
[13:33:08] <bstrie> ChrisMorgan: honestly, I feel like it's better when an answer is obviously super wrong rather than wrong in some subtle way. if I see a question using "alt" then it's easy to tell it's out of date
[13:33:09] <cmr> guh, hard to explain concisely and clearly
[13:33:24] <bstrie> not that it isn't best to have them always be right, mind you...
[13:33:28] <cmr> bstrie: I don't even know what `alt` was..
[13:33:35] <bstrie> but the state of the language right now is such that you can never be sure
[13:33:36] <dbaupp> cmr: s/alt/match/
[13:33:40] <cmr> aha
[13:33:47] <stugol> Ah, perhaps I'm using the wrong terminology. They're both for using a DLL at runtime, but without pissing about with LoadLibrary and such
[13:33:54] <cmr> Right
[13:34:00] <bstrie> cmr: I bet you don't know what ifaces are either :P
[13:34:04] <stugol> Looks simple enough.
[13:34:09] <cmr> It's the correct terminology, there's just... some fuzziness
[13:34:15] <dbaupp> stugol: that was a design goal :)
[13:34:34] <cmr> stugol: there's a tool, rust-bindgen, which generates extern blocks like that from C header files
[13:34:44] <cmr> we don't have c++ ffi yet though
[13:34:54] *** Joins: Jontte (joonas@moz-8B229CD6.la)
[13:34:55] <stugol> I don't suppose we can load stuff from a 32-bit DLL into a 64-bit process? I gather that's completely impossible.
[13:35:04] <doomlord> stugol - compared to C++, i miss overloading a bit, and the template system can't do as much yet -, but struct-trait-impl is a more convinient way of arranging code, the syntax is more elegant with tuples/better inference/cleaner generics, the macro system is better, and most of all ...no headers
[13:35:07] *** Quits: erickt (erickt@8C9ECD8F.3A598286.F12515B4.IP) (Ping timeout)
[13:35:10] <stugol> cmr: "ffi"?
[13:35:15] <cmr> stugol: foreigh function interface
[13:35:23] <stugol> Ah.
[13:35:24] <cmr> stugol: calling into code written in another language
[13:35:31] <cmr> ie, calling into C from Rust (or the other way around)
[13:35:46] <stugol> I never import C++ classes from DLLs in any case. Didn't even know you could. It's all C stuff.
[13:35:49] *** Quits: olleharstedt (Thunderbir@moz-80D8890F.ias.bredband.telia.com) (Ping timeout)
[13:35:55] <dbaupp> (both of which are possible, but Rust calling C is much nicer atm.)
[13:36:14] <cmr> stugol: you don't use C++ libraries which are shipped with a DLL?
[13:36:34] <stugol> Er....not that I recall.
[13:36:37] *** Joins: Azdle (Azdle@moz-B334B496.hfc.comcastbusiness.net)
[13:36:50] <stugol> I just tend to import the API functions and such.
[13:37:15] <stugol> I assume one of the Rust pointer types is equivalent to a standard C pointer?
[13:37:21] <cmr> Yes, *T
[13:37:24] <cmr> exactly identical
[13:37:32] <cmr> you need unsafe code to dereference it though
[13:37:45] <stugol> What about passing a pointer-to-a-function to another function?
[13:37:54] *** Joins: metasyntax (tvenable@moz-63D9B3D.med-web.com)
[13:37:56] <cmr> ~ and & have the same runtime representation (just a pointer, but compiler does static analysis ensuring they are memory safe)
[13:38:17] <cmr> Rust has closures for that, and you can cast an `extern "C" fn` to a *u8 to pass to C
[13:38:21] <stugol> I really like the "owned pointer" and "borrowed pointer" ideas. std::shared_ptr<> is a total arse.
[13:38:27] <doomlord> you'll spend a bit of time fighting the compiler, saves crashes later
[13:38:53] <dbaupp> doomlord: you'll also spend time fighting compiler crashes :(
[13:38:57] <doomlord> :)
[13:38:58] <stugol> Ah, but suppose I have a Rust function, but need to pass a pointer to it to a DLL function? e.g. WindowProc.
[13:39:17] <dbaupp> stugol: extern "C" fn
[13:39:34] <doomlord> yes you can do that, just be warned the type is hacked as *u8 for the minute :)
[13:39:38] <dbaupp> (i.e. you declare your rust function like that, instead of just `fn ...`)
[13:39:42] <stugol> Ah. So it would be a C function, not a true Rust function?
[13:39:45] <cmr> rusti: extern "C" fn foo(a: i32) { 42 }
[13:39:50] <cmr> stugol: it can be
[13:40:01] <cmr> the function body isn't literally written in C
[13:40:04] <cmr> it just exposes a C abi
[13:40:17] <cmr> ie, just like extern "C" { } in C++
[13:40:21] <doomlord> rust side, declare the c function taking the rust function pointer taking a u8* for that function pointer
[13:40:32] <stugol> Is it still a normal Rust function though? As in, the extern bit just *adds* something? Doesn't remove anything?
[13:40:49] *** Quits: bytbox (s@moz-DC83764A.washdc.fios.verizon.net) (Ping timeout)
[13:40:55] <doomlord> there is possibly a shim for stack differnce i think
[13:41:00] <stugol> So a pointer-to-function is treated as a pointer-to-int8?
[13:41:00] *** Quits: Ms2ger (Ms2ger@moz-E9883900.access.telenet.be) (Quit: bbl)
[13:41:02] <dbaupp> stugol: sort of, it's a hack at the moment.
[13:41:12] <cmr> uint8
[13:41:19] <doomlord> rust stacks are growable. rust encourages more use of stack allocation as a faster alternative to heap alocation
[13:41:21] <pnkfelix> stugol: yeah, its a hack but I believe there's an open bug to replace the hack with something better
[13:41:55] <stugol> Does Rust support coroutines? Like "yield" in .NET for example.
[13:41:56] <doomlord> i just typedefed it so i can search replace it later
[13:42:03] <kimundi> stugol: 'extern fn' is a function pointer, '&fn' and '~fn' are closures, wich are basically function pointer + environment pointer
[13:42:10] *** Quits: rusti (rusti@moz-54F7FD49.cpe.net.cable.rogers.com) (Ping timeout)
[13:42:15] <dbaupp> stugol: it's a wishlist item
[13:42:16] <engla> stugol: no yield
[13:42:23] *** Joins: rusti (rusti@moz-54F7FD49.cpe.net.cable.rogers.com)
[13:42:53] <stugol> Any way of voting on wishlist items, to bump them up the list? ;)
[13:42:57] <cmr> They can be implemented by desugaring to iterators, according to strcat
[13:43:00] <cmr> stugol: not really no
[13:43:05] <cmr> besides implementing them yourself
[13:43:11] <kimundi> because a function pointer can be easily upgraded to a closure with a empty environment, the goto-type for functions in rust is &fn()
[13:43:34] <stugol> I don't understand what you said about &fn and ~fn. Could you elaborate? And surely "extern fn" only happens at the declaration of the function?
[13:43:47] <stugol> You've lost me there as well.
[13:43:51] <cmr> nope, extern fn is a genuine type.
[13:44:00] <doomlord> they come through wih an extra pointer for the environment, i found out the hard way lol
[13:44:10] <kimundi> stugol: Do you know what a closure is?
[13:44:13] <stugol> Of course
[13:44:22] <kimundi> okay
[13:44:25] <doomlord> function+data, they have an extra pointer for the data
[13:44:34] <stugol> Yup. Bloody useful things, closures.
[13:44:43] <doomlord> which will confuse the c interface if you dont realise
[13:44:48] <stugol> I mean I don't understand the syntax you're throwing around
[13:44:52] <cmr> Ah
[13:44:56] <kimundi> ah, okay
[13:45:03] <cmr> &fn means you have a borrowed pointer to the environment
[13:45:09] <cmr> ~fn means you have an owned pointer to the environment
[13:45:09] <stugol> (So how would you pass a closure to a C function expecting a raw function pointer?)
[13:45:13] <cmr> (more or less)
[13:45:19] <kimundi> fn foo(f: &fn(bool) -> int) // takes a closure
[13:45:22] <cmr> stugol: you don't, you need to pass an `extern "C" fn`
[13:45:27] <doomlord> stugol , with a bug where the parameters are shifted by one lol
[13:45:30] <cmr> which is another, literal, type
[13:45:36] <kimundi> fn foo(f: extern fn(bool) -> int) // takes just a fn pointer
[13:45:39] <Yoric> Fwiw, js-ctypes _can_ pass a JS closure to a C function expecting a raw function pointer.
[13:45:41] <monk> WRT coroutines, I thought rust tasks were "green" threads anyway?
[13:45:46] <stugol> So it just can't be done? Passing a closure as a raw function?
[13:45:50] <Yoric> I believe that I don't want to know how that works.
[13:45:57] <kimundi> fn foo(f: extern "C" fn(bool) -> int) // takes just a fn pointer using the C abi
[13:46:18] <cmr> stugol: no, closures are always coupled with an environment pointer, they take it as their first argument, burned into the ABI
[13:46:34] <stugol> Environment pointer == this pointer?
[13:46:42] <doomlord> so you need to create a named rust function if you want a raw funciton pointer with no environment
[13:46:49] <kimundi> stugol: Kinda
[13:46:54] <doomlord> pointer to captured state
[13:47:40] <cmr> Closures capture variables outside their scope
[13:47:42] <stugol> So.... let me see if I can wrap my head around this.... to declare a variable of type pointer-to-int, we say something like "let a: *int"?
[13:47:51] <bstrie> stugol: just filed a bug for the `yield` idea (hope I got the description right) https://github.com/mozilla/rust/issues/7746 please leave a comment if you think it's important
[13:47:53] <cmr> those values are stashed into a struct, which is passed by-reference to the closure
[13:47:56] <kimundi> let x = 5; let f: &fn() = || { x + 3 } // f's environment contains a reference to x
[13:48:38] <kimundi> stugol: yes
[13:48:46] <cmr> stugol: (raw pointer, but yes)
[13:50:01] <stugol> bstrie: done
[13:50:48] <stugol> "let a: ~int" is an owned pointer, and &int is a borrowed pointer?
[13:50:55] <stugol> The symbol is part of the type, then?
[13:50:55] <kimundi> yes
[13:51:00] <cmr> Yes
[13:51:01] <doomlord> stugol, another supise compared to C++ is you sometimes have to manually write that something is being copied (Clone .clone() )
[13:51:24] <doomlord> .. when writing generic code.. in places where copy constructors could appear in C++
[13:51:25] <stugol> & makes sense, because it looks like a C++ reference, which is essentially a borrowed pointer. Easy to remember. The ~ isn't so easy.
[13:51:41] <cmr> stugol: ~ is just a malloc'd pointer with an automatic free when it exists scope
[13:51:43] <cmr> *exits
[13:51:50] <kimundi> stugol: Yo can see the symbol as sugar for a hypothetical generic type, eg.: ~T == Uniq<T>
[13:51:53] <monk> I just think of ~ as unique_ptr
[13:52:02] <monk> except with borrow checks.
[13:52:09] <doomlord> ~ one sqiggle  - one owner
[13:52:17] <monk> heh.
[13:52:29] <doomlord> @ makes alot of sense as a pointer. and its many squiggles
[13:52:38] <doomlord> @ makes more sense than * infact :)
[13:52:41] *** Joins: jedestep (jedestep@34641662.FB4DE631.66C78B76.IP)
[13:52:47] <stugol> I guess so
[13:52:49] *** Joins: mark_edward (quassel@moz-4A5B1251.wisolt4.epbfi.com)
[13:53:00] <kimundi> & - the owner has tied it down to himself with a knot, can't take it
[13:53:07] <cmr> heh
[13:53:08] <pczarn> @ means 'at'
[13:53:09] <bstrie> doomlord: it does make sense, but quiet I want to repurpose that glyph for a secret proposal :P
[13:53:25] <ChrisMorgan> ~, just cruisin' along, never worrying about anyone else interfering.
[13:53:45] <bstrie> shared pointers should have # as a sigil
[13:53:47] <doomlord> i dont miss ~ as destructor.
[13:53:47] <stugol> So...."let X: extern "C" fn(int) -> int", where X is a C-callable function pointer?
[13:53:50] <bstrie> because the lines are all over the place
[13:53:56] <cmr> stugol: yup
[13:54:05] <ChrisMorgan> There, Vim users may try `:compiler rustc` with src/etc/vim/compiler/rustc.vim: https://github.com/mozilla/rust/pull/7747
[13:54:18] * dbaupp hopes bstrie's proposal is a short way to automatically get setters/getters for struct fields
[13:54:21] <doomlord> i dont ike C++'s name convention for destructors
[13:54:29] <stugol> What does Rust use as a destructor then?
[13:54:41] <dbaupp> stugol: there is the `Drop` trait
[13:54:46] <doomlord> Drop? destroy? but you don;t need it as much because memory RAII is built in
[13:54:54] <stugol> Does Rust have shared pointers?
[13:54:59] <cmr> @
[13:55:04] <stugol> Ah.
[13:55:07] <doomlord> full GC , to be avoided :)
[13:55:10] * bstrie throws pocket sand at dbaupp
[13:55:16] <dbaupp> stugol: it is "built-in" to the compiler, so implementing it gives you a dtor that is called when appropriate (RAII style)
[13:55:19] <cmr> GC-managed (GC is task-local though, so no stop-the-world)
[13:55:19] <doomlord> Rc refcounting system aswell, implemented as a library feature
[13:55:25] <stugol> So we have raw pointers, owned pointers, borrowed pointers and shared pointers.
[13:55:37] <cmr> That's all of 'em
[13:55:46] <stugol> What happens if you have two objects with shared pointers to each other? Are you screwed?
[13:55:48] <doomlord> raw, owned, borrowed, *refcount*, ARC, shared(GC)
[13:55:51] <dbaupp> all that are built into the compiler at the moment
[13:55:59] <kimundi> @ - many owners have tangled their stuff together, eventually they lose interest in it and the janitor throws it away at the end of the day
[13:56:01] <doomlord> @ is propper GC, allows cycles
[13:56:02] <heftig> stugol: well, cycle collection is planned
[13:56:03] <cmr> doomlord: well smartpointers don't count
[13:56:08] <dbaupp> stugol: at the moment yes, but they are designed to have a proper GC
[13:56:09] <heftig> oh, it works?
[13:56:15] <doomlord> Rc is refcounting library i hear, and ok, doesn't count :)
[13:56:29] <cmr> heftig: no but we pretend it does...
[13:56:31] <dbaupp> stugol: (a proper GC which is mostly implemented, but landing it is proving to be a bother, apparently.)
[13:56:33] <heftig> it's also been proposed to remove @ from the language
[13:56:38] <stugol> Why?
[13:56:48] <dbaupp> heftig: only a syntactic construct
[13:56:51] <dbaupp> *as a
[13:56:58] <stugol> What would replace it?
[13:57:01] <heftig> yes. it would live on as a trait in the standard library
[13:57:02] <dbaupp> it would still exist as Gc<T>
[13:57:02] <cmr> Gc<T>
[13:57:18] <stugol> I think a symbol is helpful
[13:57:23] *** Joins: Sergio965 (sergiobz@moz-BB21156B.dynamic.csail.mit.edu)
[13:57:34] <ChrisMorgan> Things like https://justanapplication.wordpress.com/2013/07/08/programming-with-rust-part-twenty-where-have-the-sockets-gone-changes-between-rust-0-6-and-rust-0-7/ make me sad, where he thinks he has to `use std::io` to be able to `io::println()`, whereas in fact he should just drop the `io::` part.
[13:57:34] <doomlord> i liked the idea of @ being defineable by library code as GC or Refcounting, but you'd have to avoid it 100% in cross project code i suppose
[13:57:39] <stugol> So...does the GC work or not? If I declare a shared pointer, will it work as expected?
[13:57:54] <cmr> stugol: the GC is currently implemented via refcounting with no cycle collection
[13:58:02] <heftig> so, it won't
[13:58:04] <stugol> So it'd leak?
[13:58:08] <cmr> only if you have cycles
[13:58:16] *** Quits: jdm (jdm@92FB48CA.8B5E9DF.9A8C35B4.IP) (Quit: Lost terminal)
[13:58:17] <stugol> Well that's not much use
[13:58:22] <cmr> nope
[13:58:27] <cmr> pre-alpha
[13:58:27] <pnkfelix> and when the task finishes
[13:58:31] <stugol> Cycles are the biggest problem with C++'s shared_ptr<>
[13:58:32] <pnkfelix> won't it get cleaned up then too ?
[13:58:34] <heftig> it's still extensively used in the compiler, but that's not a long-running program
[13:58:35] <cmr> Ah yes
[13:58:40] <doomlord> but coming from C++, you dont want GC anyway
[13:58:42] <cmr> the task annihilator frees all resources the task owns
[13:58:42] <kimundi> stugol: Right now @ is implemented as ref counting, the new tracing collector works, but didn't land yet because rustc consumes to much memory with it under 32bit
[13:58:43] <dbaupp> pnkfelix: yes
[13:58:43] <pnkfelix> otherwise I think rustc would be screwed ...
[13:58:45] <engla> c++ has weak_ptr to break cycles
[13:58:48] <bstrie> stugol: the leaks are a bug, a proper gc is on the way
[13:58:55] <cmr> pnkfelix: well rustc is screwed anyway
[13:59:01] <pnkfelix> cmr: fair enough
[13:59:03] <cmr> pnkfelix: we don't free any of the cycles ever :\
[13:59:03] <stugol> Ahem. I *do* want a GC.
[13:59:14] <stugol> weak_ptr sucks as well
[13:59:15] <dbaupp> stugol: yes, and it will exist
[13:59:24] <heftig> i like weak maps.
[13:59:25] <dbaupp> just... not yet
[13:59:33] <stugol> I had an idea the other day about a GC
[13:59:43] <doomlord> heh . i'm here because i *dont* want a GC, and i *dont* want header files :)
[14:00:00] * dbaupp thinks Rust is going to explode under the weight of expectations
[14:00:05] <stugol> Then don't use it. Personally, I don't like leaked cycles.
[14:00:16] <cmr> stugol: nobody does, they're a bug
[14:00:25] <stugol> Consider the age-old problem: GC or refcounting. With GC, objects aren't deterministically freed; whereas with RC, cycles can leak.
[14:00:48] <stugol> cmr: No, I mean doomlord doesn't want a GC, and therefore, cycles would always leak in any case. That really annoys me in C++
[14:01:01] <cmr> stugol: well you *can't* make cycles without @
[14:01:08] <heftig> or *
[14:01:17] <cmr> * is cheating, it abides by no rules
[14:01:19] <kimundi> stugol: The nice thing about rust is that most things other languages need a gc for you can do either completly with stack values, or with zero-runtime-overhead heap allocations
[14:01:20] <ChrisMorgan> ... with the result that Python has `gc.collect()`, which in refcounting CPython has the sole purpose of collecting cycles.
[14:01:33] <doomlord> one puts up wiht C++ as its the best (mainsteam, non alpha) language with deterministic memory management
[14:01:51] <stugol> M$ decided to use a GC in .NET rather than RC, meaning that objects couldn't be relied upon to be destructed. So resources (file handles, etc) leak.
[14:02:11] <bstrie> stugol: if you're not making cycles, you never need to resort to Gc
[14:02:23] <bstrie> but cycles happen, which is why we have it in the first place
[14:02:26] <stugol> How about a combi pointer? It's allocated on the heap, but it's refcounted as well. Whichever one hits zero first, it dies.
[14:02:30] *** Joins: sankha93 (Instantbir@7A7BDF42.35354309.EFB84E89.IP)
[14:02:42] <stugol> Might sound crazy, but think about it
[14:02:44] <bstrie> stugol: rust should let you implement your own smart pointers eventually
[14:02:55] <bstrie> that's part of the work of moving Gc into a library
[14:03:11] <heftig> stugol: that's the essence of RC + Cycle Collector
[14:03:11] <bstrie> it's to ensure that we have all the mechanisms to make user-provided smart pointers act like first-class pointers
[14:03:15] <stugol> Point is, with a combi pointer you wouldn't get cycles; but keep something on the stack and it would die at the expected time.
[14:03:17] <pnkfelix> stugol: that doesn't sound very different from RC with a backup GC
[14:03:24] <dbaupp> bstrie: I assume you're refering to the syntax?
[14:03:29] <pnkfelix> stugol: Which is what Flash uses, for example
[14:03:38] <dbaupp> bstrie: (since custom smart pointers are netirely possible now)
[14:03:50] <stugol> I've never used a language with a combined GC/RC pointer.
[14:03:56] <stugol> I reckon it'd be a good idea though
[14:04:08] <pnkfelix> stugol: RC is too high overhead
[14:04:18] <doy> stugol: the point though is that if you only use ~ and & (and stack allocation), it's impossible to create cycles in the first place
[14:04:26] <bstrie> dbaupp: even with auto-borrowing?
[14:04:40] <bstrie> and autoderef?
[14:04:43] <dbaupp> bstrie: yeah, that's what I was meaning by syntax
[14:04:49] <doy> and a great deal of code is capable of being written that way
[14:05:06] <kimundi> stugol: Well, tracing and ref counting+cycle collecting ate both just two opposite ways to solve the GC problem
[14:05:08] <bstrie> dbaupp: I consider autoderef and autoborrowing to be semantic changes :P
[14:05:23] <stugol> Still, a combi RC/GC pointer type would be really nice.
[14:05:37] <dbaupp> bstrie: well, I was assuming that you could do non-auto versions of them now, so it's just new syntax to make it magical ;P
[14:05:39] <stugol> Can't have deterministic destruction with a GC
[14:05:47] <pnkfelix> stugol: better to deal with the cleanup issues in some other manner, IMO.  I wrote some thoughts on this on my blog: http://blog.pnkfx.org/blog/2013/01/29/implicit-versus-explicit-finalization/
[14:05:55] <doomlord> is it possible that spawning tasks (things that can sleep, then be woken up with messages) can handle some cases where memory management might not seem possible 'linearly' (tasks all having their own ~'s in own heaps)
[14:05:59] <dbaupp> bstrie: but yeah, it's definitely closer to semantics thatn pure syntax.
[14:06:37] *** Joins: lmandel (lmandel@F2D29657.F60B0462.67AC9B1.IP)
[14:06:42] <doomlord> i.e the tasks can release data at different times cmopared to stack wind/unwind 
[14:07:09] <doomlord> it is not a tool i have thought about using, i have never worked with a language with 'actor model'
[14:08:08] <doomlord> stugol are you tempted enough by rust to overcome the lack of IDE
[14:08:52] <stugol> I'm thinking about installing a decent tabbed editor and having a crack at it. In Linux, possibly. Commandline seems more natural in there than in Windows.
[14:09:19] <heftig> stugol: IIRC gecko has that reference counting + cycle collection for its c++ and xpcom objects
[14:09:35] *** Quits: jaen (jaen@moz-1AF55B54.neoplus.adsl.tpnet.pl) (Ping timeout)
[14:10:02] *** Joins: pnathan1 (Adium@B9840254.2CD8A5F8.477B877D.IP)
[14:10:16] <kimundi> stugol: Linux is definitly recommended for rust work atm moment
[14:10:27] <cmr> or osx, but you can't run that in a vm
[14:10:46] <kimundi> at least windows is a pita with mingw stuff
[14:11:32] <stugol> Don't need a VM. I have Linux systems right here.
[14:11:37] <cmr> ah
[14:11:39] *** Joins: saml (sam@moz-14C16814.cst.lightpath.net)
[14:12:00] <dbaupp> (that said, it'd be neat to have someone who knows their way around windows to poke here and there at the issues affecting it.)
[14:12:31] <cmr> especially process spawning... getting rid of check-fast would be very nice
[14:12:32] <pnkfelix> dbaupp: I was just wondering about that
[14:12:42] <stugol> I'd be happy to help out. Bear in mind however, that while I'm pretty decent at coding, I have no experience writing compilers and such.
[14:12:44] <doomlord> ( i wonder how it is with windows 8)
[14:12:53] <kimundi> stugol: I found coding rust in kate quite nice. Tabbed view, a filesystem tree on the left side, syntax highlining...
[14:12:57] <cmr> doomlord: I use it on win8 about once a week
[14:13:03] <dbaupp> stugol: very many of the contributors don't :)
[14:13:13] <doomlord> i haven't tried win8 yet
[14:13:18] <cmr> stugol: I didn't, before rust
[14:13:45] <kimundi> stugol: Don't worry, the std libs needs all help they can, even if you don't look into tho compiler itself
[14:15:03] <dbaupp> cmr: it's neat to watch the bencher slowly fill the missed section back in
[14:15:10] <cmr> dbaupp: yeah
[14:15:17] <dbaupp> cmr: yay for intelligent programs! :)
[14:15:33] <ChrisMorgan> I've had an idea to reduce lifetime declaration verbosity: where one currently has `pub fn foo<'a>(&'a bar: Bar) -> &'a Baz`, let this work as the same thing, understanding the lifetime to be that of the named argument if not specified explicitly: `pub fn foo(&bar: Bar) -> &'bar Baz`. Now someone can shoot it down and explain why that would be a Bad Ideaâ„¢.
[14:15:38] <dbaupp> well, "intelligent"
[14:15:39] *** Joins: MaikKlein (maik@moz-B9C8EE03.dip0.t-ipconnect.de)
[14:15:59] <cmr> ChrisMorgan: you have your & on the wrong side of t he :
[14:16:07] *** Quits: pnathan1 (Adium@B9840254.2CD8A5F8.477B877D.IP) (Ping timeout)
[14:16:10] <cmr> ChrisMorgan: that seems like a really good idea to me though
[14:16:10] *** Joins: pancake (pancake@moz-80078EF0.dynamic.jazztel.es)
[14:16:22] <nmatsakis> ChrisMorgan: we originally had rules like this,
[14:16:37] <nmatsakis> ChrisMorgan: where every & was considered the same lifetime implicitly
[14:16:46] <cmr> nmatsakis: I don't think that's what he means
[14:16:54] <jedestep> I think what he means is
[14:17:04] <cmr> I think he means you can name a lifetime the same as a ref-arg implicitly, and it's that same lifetime
[14:17:06] <jedestep> if in the argument list you had foo(bar: &Bar, baz: &Baz)
[14:17:21] <jedestep> your return type could be &'bar Qux or &'baz Qux
[14:17:31] <nmatsakis> I see
[14:17:34] <nmatsakis> well,
[14:17:46] <ChrisMorgan> Silly me, writing &foo: Bar when I meant foo: &Bar...
[14:17:56] <cmr> ChrisMorgan: (both are valid, too!)
[14:18:00] <nmatsakis> we could do something like it, but there are a lot of corner cases to consider
[14:18:12] <dbaupp> cmr: (assuming Bar is a type-def for &Something)
[14:18:12] <nmatsakis> fn foo<'a>(bar: Bar<'a>) -> &'a ...
[14:18:20] <nmatsakis> etc
[14:18:39] <cmr> nmatsakis: I don't think it'd replace <'a> etc, it'd just augment it
[14:18:40] *** Quits: pancake (pancake@moz-80078EF0.dynamic.jazztel.es) (Connection reset by peer)
[14:18:42] <ChrisMorgan> I'm by no means convinced that this is a good scheme, just thought I'd throw it out there as "an idea". It certainly wouldn't replace the current system in all cases and would be entirely optional.
[14:18:44] <jedestep> fn foo(&self) -> &'self Foo in particular
[14:18:47] <nmatsakis> goal with current syntax was not to be minimalist but to be relatively comprehensible,
[14:18:49] *** Joins: pancake (pancake@moz-C64A66AE.dynamic.jazztel.es)
[14:18:56] <nmatsakis> basically we were trying to avoid having a lot of special case rules
[14:19:05] <ChrisMorgan> jedestep: ... which, I believe, worked in 0.6 but was removed in 0.7
[14:19:10] <jedestep> yeah
[14:19:11] <nmatsakis> because the feeling was that having special case rules made the system feel more complex
[14:19:16] <jedestep> &self and &'self self are different now
[14:19:17] <nmatsakis> ChrisMorgan: it...kind of worked. 
[14:19:24] <stugol> What does the ' mean?
[14:19:26] <pnkfelix> nmatsakis: It seems once we have a larger body of code, we could evaluate how often a sugar like this applies.
[14:19:32] <jedestep> stugol: it's a lifetime variable
[14:19:32] <ChrisMorgan> stugol: borrowed pointer lifetime
[14:19:39] <pnkfelix> nmatsakis: (or maybe all that matters is whether it applies to servo.  :)
[14:19:39] <stugol> Uh
[14:19:42] *** Joins: jorendorff (jorendorff@moz-2F32ACA3.hsd1.tn.comcast.net)
[14:19:44] <nmatsakis> ChrisMorgan: it didn't necessarily do what you meant for it to do
[14:19:47] <jedestep> pointers with the same lifetime variable must expire at the same time
[14:19:50] <nmatsakis> pnkfelix: yes, more code will help
[14:20:15] <ChrisMorgan> stugol: http://static.rust-lang.org/doc/tutorial-borrowed-ptr.html
[14:21:32] *** Joins: infynyxx_ (infynyxx@DB780A29.749BA1D.DCC373F0.IP)
[14:21:43] <stugol> Ah, I think I get the idea.
[14:21:47] <stugol> See you guys later.
[14:21:54] *** Parts: stugol (Mibbit@moz-5F38F85.know.cable.virginmedia.com) ()
[14:23:14] *** Quits: infynyxx_ (infynyxx@DB780A29.749BA1D.DCC373F0.IP) (Ping timeout)
[14:23:59] <ChrisMorgan> nmatsakis: what exactly did `fn foo(self) -> &'self Bar` do, if not what I intended it to do?
[14:25:13] *** Joins: pancake_ (pancake@moz-1DAF020B.dynamic.jazztel.es)
[14:25:47] *** Joins: bytbox (s@moz-DC83764A.washdc.fios.verizon.net)
[14:25:52] *** Quits: pancake (pancake@moz-C64A66AE.dynamic.jazztel.es) (Ping timeout)
[14:26:13] *** Quits: z0w0 (zack@moz-37A98529.lnse2.woo.bigpond.net.au) (Client exited)
[14:27:17] *** Quits: pancake_ (pancake@moz-1DAF020B.dynamic.jazztel.es) (Ping timeout)
[14:28:19] <ChrisMorgan> Was it equivalent to the sugar in my idea?
[14:29:27] *** Joins: pancake (pancake@moz-4687B925.dynamic.jazztel.es)
[14:30:15] *** Joins: judder (maradukewa@5B9E91E7.2C8A8E2E.78E362FE.IP)
[14:30:15] *** Quits: pancake (pancake@moz-4687B925.dynamic.jazztel.es) (Connection reset by peer)
[14:30:18] *** Joins: pancake (pancake@moz-A2CA09AA.dynamic.jazztel.es)
[14:33:05] <nmatsakis> ChrisMorgan: not really
[14:33:08] <nmatsakis> ChrisMorgan: but sometimes
[14:33:13] <ChrisMorgan> ... uh oh
[14:33:23] <nmatsakis> ChrisMorgan: if you had "impl<'self> Foo<'self> { fn foo(&self) -> &'self Bar }"
[14:33:31] <nmatsakis> that was equivlent to (in today's terms)
[14:33:46] <nmatsakis> ChrisMorgan: if you had "impl<'self> Foo<'self> { fn foo(&'self self) -> &'self Bar }"
[14:33:54] *** Joins: erickt (erickt@8C9ECD8F.3A598286.F12515B4.IP)
[14:33:57] <nmatsakis> oops, well, I changed the example slightly
[14:34:08] <nmatsakis> the main point is that we always linked the Foo<'self> 
[14:34:11] <nmatsakis> to the lifetime of the self parameter
[14:34:19] <nmatsakis> so you always had a self parameter of &'self Foo<'self>
[14:34:22] <nmatsakis> vs today, where you can have
[14:34:25] <nmatsakis> &'a Foo<'self>
[14:34:29] <nmatsakis> this was a significant problem
[14:34:34] <nmatsakis> particularly about mut pointers
[14:34:56] <nmatsakis> basically, 
[14:35:02] <nmatsakis> your object was always borrowed for the same duration,
[14:35:06] <nmatsakis> as any of the borrowed pointers it contained
[14:35:10] <nmatsakis> which was sometimes longer than what you wanted
[14:35:18] <nmatsakis> well, not always, but often.
[14:35:38] <nmatsakis> I think if we were to adopt your proposal, we'd also want to change the convention that we use 'self for the type's lifetime parameter
[14:35:43] *** Quits: erickt (erickt@8C9ECD8F.3A598286.F12515B4.IP) (Ping timeout)
[14:35:50] <nmatsakis> which we may want to change regardless
[14:35:53] *** Parts: pancake (pancake@moz-A2CA09AA.dynamic.jazztel.es) ()
[14:36:57] <nmatsakis> ChrisMorgan: this gets at the most confusing part I see with your proposal...
[14:37:02] <nmatsakis> imagine this:
[14:37:22] <nmatsakis> impl<'a> Foo<'a> { fn bar(&self, a: &A) -> &'a B; }
[14:37:29] <nmatsakis> what does the &'a B refer to?
[14:37:35] *** Quits: int3_ (int3_@moz-ABE52D50.hsd1.ca.comcast.net) (Client exited)
[14:37:39] <nmatsakis> the type's lifetime parameter, or the lifetime of the parameter `a`?
[14:37:43] <nmatsakis> in today's system, it's unambiguous
[14:37:54] <ChrisMorgan> Compile error is probably safer in such cases.
[14:37:56] <cmr> It'd always be the type's lifetime parameter I'd imagine
[14:38:05] <cmr> yeah a warning lint for that would be good
[14:38:09] <nmatsakis> today yes but I'm saying if we adopted ChrisMorgan's proposal
[14:38:16] <nmatsakis> yes, we could report an ambiguity error
[14:38:18] <cmr> I'm saying in ChrisMorgan's proposal
[14:38:18] <ChrisMorgan> Certainly a warning at the least.
[14:38:36] <nmatsakis> oh, I would have guessed it'd be equivalent to the parameter
[14:38:42] <nmatsakis> since I tend to prefer local decls over distant ones
[14:38:55] <nmatsakis> but I think an error would be the right response :)
[14:39:04] <ChrisMorgan> That was my feeling too, after "error"
[14:39:04] <cmr> well I see type parameterization like that as overriding whatever the compiler would otherwise think
[14:39:11] <cmr> but yes, error is sanest
[14:39:29] *** Quits: santiago (santiago@moz-F2B734D2.c3-0.sbo-ubr1.sbo.ma.cable.rcn.com) (Quit: Computer has gone to sleep.)
[14:39:37] *** Joins: hjr3 (hradtke@1A0AE795.28A5F6C3.A2D40ED2.IP)
[14:40:17] <ChrisMorgan> Anyway, there you have an Idea. I'll leave those who actually know about it all to decide what to do with it, and ignoring it is certainly a valid option! Now I'll go to bed.
[14:40:21] *** Joins: msingle (Thunderbir@moz-930E5D97.hr.hr.cox.net)
[14:40:42] *** Joins: ghrust (ghrust@AC22872E.6A2AE50.F3114085.IP)
[14:40:42] <ghrust> 01[13rust01] 15bors merged 06auto into 06master: 02http://git.io/ycy7tw
[14:40:42] *** Parts: ghrust (ghrust@AC22872E.6A2AE50.F3114085.IP) ()
[14:43:03] *** Parts: slaren (x@moz-EBC5E112.red-79-147-85.dynamicip.rima-tde.net) ()
[14:43:40] *** Joins: ghrust (ghrust@AC22872E.6A2AE50.F3114085.IP)
[14:43:40] <ghrust> 01[13rust01] 15bors pushed 0 new commits to 06auto: 02http://git.io/eN7Hsg
[14:43:40] *** Parts: ghrust (ghrust@AC22872E.6A2AE50.F3114085.IP) ()
[14:43:42] *** Quits: ChrisMorgan (chris@moz-6AC741CA.static.tpgi.com.au) (Ping timeout)
[14:43:42] *** Joins: ghrust (ghrust@FD7BC443.6A2AE50.F3114085.IP)
[14:43:42] <ghrust> 01[13rust01] 15bors pushed 2 new commits to 06auto: 02http://git.io/KWF6Ow
[14:43:42] <ghrust> 13rust/06auto 147e97277 15BjÃ¶rn Steinbrink: transmute: Avoid double copy for immediate values...
[14:43:42] <ghrust> 13rust/06auto 1496b3163 15bors: auto merge of #7717 : dotdash/rust/transmute, r=pcwalton...
[14:43:42] *** Parts: ghrust (ghrust@FD7BC443.6A2AE50.F3114085.IP) ()
[14:44:03] <cmr> bors breakages leave me with an irrational elation when something lands
[14:44:18] *** Quits: dbaupp (Thunderbir@moz-712A1135.lns20.syd6.internode.on.net) (Ping timeout)
[14:45:08] *** Joins: slaren (slaren@moz-EBC5E112.red-79-147-85.dynamicip.rima-tde.net)
[14:51:56] <MaikKlein> hm
[14:52:43] <MaikKlein> what do you think of https://gist.github.com/MaikKlein/5985050 to share behavior?
[14:53:49] *** Quits: pnathan (vlion@moz-BDC3EE62.tukw.qwest.net) (Ping timeout)
[14:53:57] <bstrie> MaikKlein: what's the goal here?
[14:54:47] <MaikKlein> bstrie, the goal is go achieve something similar like inheritance http://doc.akka.io/docs/akka/2.2.0/java/hello-world.html
[14:55:05] <jedestep> yeah it looks like it's achieving some pseudo-inheritance
[14:55:29] <cmr> MaikKlein: not really sure why you need inheritance here?
[14:55:39] <cmr> just use an Actor trait for the onReceive and such?
[14:56:09] *** Joins: jdm (jdm@F2D29657.F60B0462.67AC9B1.IP)
[14:56:50] <nmatsakis> MaikKlein: personally I'd not use closures like that
[14:57:00] <nmatsakis> MaikKlein: I'd just make a trait with all the methods you want,
[14:57:16] <MaikKlein> for example traits are good for sharing methods or function but you will always need to write your own members, which will soon get a little bit tedious for the client. so I thought I could achieve this with composition, while still allow the client to use his custom functions 
[14:57:29] <cmr> MaikKlein: default methods?
[14:57:46] <nmatsakis> MaikKlein: then give give default methods a try, I hear they kind of work now (yay sully!)
[14:58:11] *** Quits: novabyte (Instantbir@moz-3E0F9699.cable.virginmedia.com) (Ping timeout)
[14:58:31] <MaikKlein> https://github.com/MaikKlein/RustActors/blob/master/actor.rs
[14:58:46] <MaikKlein> I made a trait with all my stuff that I need
[14:58:49] *** Quits: etw (john@moz-B2936CAB.nyc.res.rr.com) (Quit: etw)
[14:58:54] *** Joins: cowboyd (cowboyd@moz-1BD02A1E.sw.biz.rr.com)
[14:58:57] <MaikKlein> but I still need to implement some members
[14:59:01] <MaikKlein> like the Ports and Chans
[14:59:13] <MaikKlein> so the client has to implement those
[14:59:45] <MaikKlein> I could be confused though..
[14:59:56] <nmatsakis> yes, they do
[15:00:30] <nmatsakis> but it's not clear to me how your sol'n address that
[15:00:46] <nmatsakis> if supertraits etc were fully working, there would be a way to address it,
[15:00:52] <nmatsakis> but absent those I'm not sure if it's possible right now
[15:02:23] *** Joins: novabyte (Instantbir@moz-3E0F9699.cable.virginmedia.com)
[15:02:34] <MaikKlein> well at least I think I could use it like this struct MyCustomActor { actor: BaseActor} .... new(){.... BaseActor::new(on_receive_fn, execute_fn,listen_fn) ... };
[15:02:55] <indutny> hey people
[15:02:58] <indutny> nmatsakis: hi
[15:03:14] <indutny> have you got anywhere with your rewrite-half-of-ty stuff? :)
[15:03:18] *** Joins: wilma (Mibbit@BBE7C46A.B4F11D08.8612FA94.IP)
[15:03:23] <MaikKlein> so he would only need to implement the functions that are important
[15:03:27] <MaikKlein> what are supertraits btw?
[15:03:37] <MaikKlein> trait inheritance?
[15:03:57] <nmatsakis>  indutny: maybe? which stuff are you referring to specifically? :)
[15:04:00] *** Joins: erickt (erickt@8C9ECD8F.3A598286.F12515B4.IP)
[15:04:12] <indutny> nmatsakis: ah, the problem with extensions implementations
[15:04:15] <nmatsakis> MaikKlein: yes, I was thinking you could declare a supertrait for the getters,
[15:04:19] <indutny> actually, with using extensions
[15:04:33] <indutny> where there're similarly named methods
[15:04:38] <indutny> s/where/when/
[15:04:50] <indutny> in different extensions available in the scope
[15:04:56] <nmatsakis> indutny: No. I haven't done any work on that. It's not high on my priority list right now, though maybe I should up it.
[15:05:04] <indutny> well, I can do it
[15:05:18] <indutny> I was really close to it, but you said you're working on major refactoring for this stuff
[15:05:26] <indutny> soâ€¦ I'm asking if it has landed or not
[15:05:28] <nmatsakis> I am, yes.
[15:05:29] <nmatsakis> No
[15:05:34] <indutny> ok :)
[15:05:35] <indutny> that's it
[15:05:36] <indutny> thanks
[15:05:39] <nmatsakis> I'd like to review your patch,
[15:05:49] <nmatsakis> because I'm not sure I want to modify the existing code to handle it
[15:05:57] <nmatsakis> since I think the existing code has some basic flaws
[15:06:05] <indutny> well, its not finished
[15:06:07] <nmatsakis> and also the way we do vtable / method lookup is just...wrong.
[15:06:13] <indutny> and doesn't actually work
[15:06:13] <nmatsakis> well, not WRONG, but insufficient.
[15:06:14] <indutny> :)
[15:06:21] <nmatsakis> and not unified
[15:06:25] <indutny> obviously because of this shit in ty
[15:06:40] *** Quits: erickt (erickt@8C9ECD8F.3A598286.F12515B4.IP) (Ping timeout)
[15:06:42] <indutny> there're no such information at the moment of method candidate selection
[15:06:51] <nmatsakis> this is actually a deep question
[15:06:52] <indutny> it appears later in vtable
[15:06:59] <nmatsakis> it's not just poor organization,
[15:07:12] <nmatsakis> it's fundamentally unclear when we can handle this situation and when we can't,
[15:07:19] <nmatsakis> but I think we can implement some simple rules that will accommodate most cases,
[15:07:23] <doomlord> (lifetimes, i like  the idea mentioned above)
[15:07:30] <nmatsakis> in particular the pattern of "impl<A:Foo> Trait for A"
[15:07:32] <indutny> yes
[15:07:37] <indutny> exactly
[15:07:37] <nmatsakis> but it's effectively special casing that pattern
[15:07:42] <nmatsakis> which I guess is ok
[15:07:50] <nmatsakis> I'm not sure if it's an anti-pattern or not
[15:07:55] *** Quits: mcclurmc (mcclurmc@moz-A19237A1.scouts.catn.com) (Ping timeout)
[15:07:57] <indutny> at least it'll allow me to use `fn push(&mut self, â€¦)`
[15:08:01] <indutny> and others too
[15:08:01] <nmatsakis> most cases where we use it,
[15:08:04] <nmatsakis> I think would be better served with default methods
[15:08:18] <nmatsakis> but there are cases where it makes sense and default methods may not
[15:08:23] *** Quits: tehgeekmeister (tehgeekmei@C8D8A256.C7E2E9C1.1A968954.IP) (Client exited)
[15:08:24] <engla> a user can use it for their own extension methods too
[15:08:28] <nmatsakis> that's the main case
[15:08:31] <indutny> yeah
[15:08:36] *** Quits: fabiand (fabiand@A5E4BB21.FE11524D.16E13E53.IP) (Ping timeout)
[15:08:45] *** Quits: novabyte (Instantbir@moz-3E0F9699.cable.virginmedia.com) (Ping timeout)
[15:09:05] <nmatsakis> so yeah I could imagine a surgical strike for now
[15:09:06] <nmatsakis> to handle that case
[15:09:29] <nmatsakis> grr I wish I had more time to devote to Rust, so many things piling up.
[15:09:33] <indutny> heh
[15:09:47] <wilma> hey, can anyone explain how to deal with "instantiating a type parameter with an incompatible type `Foo`, which does not fulfill `Copy`"?
[15:09:50] <indutny> ok, I'll try to figure out the way to obtain such information at the time of candidate selection
[15:10:10] <indutny> also
[15:10:32] <indutny> somehow rust@0.7 fails to find this method https://github.com/indutny/linearscan.rs/blob/master/test/emulator.rs#L210
[15:10:37] <wilma> that happened when growing an owned vector with +
[15:10:39] <nmatsakis> wilma: probably you need to add a `Copy` bound to your type parameter
[15:10:45] <indutny> and it was working fine with 0.6
[15:10:49] <indutny> and pre 0.7 versions
[15:10:49] <nmatsakis> wilma: but really, you should just not use `+` with owned vectors :)
[15:10:56] *** Joins: fabiand (fabiand@A5E4BB21.FE11524D.16E13E53.IP)
[15:10:58] <nmatsakis> wilma: easiest if you gist the fn
[15:11:01] <cmr> indutny: oh, I meant to tell you
[15:11:03] <indutny> https://github.com/indutny/linearscan.rs/blob/master/src/linearscan/graph.rs#L133
[15:11:08] <indutny> cmr: hi
[15:11:09] <cmr> indutny: did you see LLVM no longer uses LSRA?
[15:11:20] <wilma> nmatsakis oh should I use push instead?
[15:11:20] <indutny> em...
[15:11:25] <indutny> cmr: LSRA?
[15:11:32] <cmr> linear scan register allocation
[15:11:34] <indutny> aaah
[15:11:38] <nmatsakis> wilma: generally speaking yes, it will be more efficient, `+` makes copies
[15:11:42] <indutny> I believe no
[15:11:47] <indutny> orâ€¦ at least its configurable
[15:11:52] *** Joins: pnathan (vlion@moz-BDC3EE62.tukw.qwest.net)
[15:11:53] <cmr> they use http://blog.llvm.org/2011/09/greedy-register-allocation-in-llvm-30.html now
[15:11:55] <indutny> http://blog.llvm.org/2011/09/greedy-register-allocation-in-llvm-30.html
[15:11:56] <indutny> yep
[15:11:57] <cmr> it is configurable
[15:11:57] <indutny> exactly
[15:11:58] <cmr> yeah
[15:12:08] <wilma> nmatsakis aah yes I think that works, thanks! also in that case yes, I don't want the copies
[15:12:09] *** Quits: posco (oscarboyki@EFB8C867.BA834BE4.71743E61.IP) (Ping timeout)
[15:12:30] <cmr> I don't know enough about the subject to know if what they do is better or whatnot for your usecases, just thought it's a pretty big/important project
[15:12:47] *** Joins: novabyte (Instantbir@moz-3E0F9699.cable.virginmedia.com)
[15:15:13] *** Quits: fabiand (fabiand@A5E4BB21.FE11524D.16E13E53.IP) (Ping timeout)
[15:16:52] *** Joins: nano (nano@moz-972880B.superkabel.de)
[15:17:52] *** Joins: fabiand (fabiand@A5E4BB21.FE11524D.16E13E53.IP)
[15:20:28] *** Quits: glinscott (garylinsco@789A6618.53EB7C1.FFFE3AA.IP) (Quit: glinscott)
[15:20:40] *** Joins: glinscott (garylinsco@789A6618.53EB7C1.FFFE3AA.IP)
[15:21:09] *** Quits: fabiand (fabiand@A5E4BB21.FE11524D.16E13E53.IP) (Quit: Verlassend)
[15:23:09] *** Joins: Kruppe (user@moz-EE1E894A.home3.cgocable.net)
[15:23:40] *** Joins: fabiand (fabiand@moz-680BCD95.adsl.alicedsl.de)
[15:26:45] *** Joins: xyproto (alexander@moz-251295DE.members.linode.com)
[15:27:15] <indutny> cmr: so can you try building linearscan.rs?
[15:27:19] <indutny> please
[15:27:51] <xyproto> Hi, just wrote my first rust application, "hello world". Took some time to find a working hello world example online, but now it's running smoothly and greets the world like there's no tomorrow. Thumbs up.
[15:28:31] <cmr> indutny: I don't have a recent build
[15:30:58] <fabiand> xyproto, didn't the hello wowlrd example on rust-lang.org help you ? :)
[15:31:22] <cmr> xyproto: `fn main() { println("hello world") }` :)
[15:31:38] <xyproto> fabiand: haven't tried that example yet, googled "hello world rust" and hit #2 was a blog post that didn't work. The rosetta code version didn't work either.
[15:31:47] *** Quits: pnathan (vlion@moz-BDC3EE62.tukw.qwest.net) (Ping timeout)
[15:31:49] <cmr> xyproto: protip: google is pretty useless
[15:31:57] <cmr> rust changes too fast for it to be of that much use
[15:32:06] <xyproto> fabiand: if you're interested, here are a collection of my failed attempts :D http://ix.io/6Cl
[15:32:21] <xyproto> *is
[15:32:35] <XgF> Had my first play with writing some Rust last night. Must say, writing "&*" to borrow an owned pointer caused some C++-wired portion of my brain to tweak..
[15:32:39] <cmr> yikes, the seventh one is ancient rust syntax
[15:32:46] <xyproto> cmr: yeah, I had a chat at #rust at ircnet before coming here, seems like rust is changing so rapidly that todays syntax may be greek tomorrow
[15:32:52] <fabiand> xyproto, good to know - that the first hit didnt help :)
[15:32:59] <engla> xyproto: nice collection
[15:33:44] <cmr> XgF: I don't think that is necessary, shouldn't the auto-borrower do 90% of the cases?
[15:33:45] <engla> its location is std::io::println now, but println is imported by default
[15:33:57] <xyproto> it works nicely now, though. And they guys at #rust at ircnet are super friendly and nice
[15:34:27] <XgF> cmr: Didn't. Perhaps because I was borrowing with the scope of self?
[15:35:59] <XgF> As an experiment I was playing with implementing something that works along the lines of Qt's QList, i.e. behaves like a normal vector but internally stores pointers to the object
[15:36:41] *** Quits: sankha93 (Instantbir@7A7BDF42.35354309.EFB84E89.IP) (Ping timeout)
[15:36:50] <cmr> hardest thing to do in rust is write safe and efficient containers
[15:37:39] <bstrie> cmr: not that hard, you just need to have strcat do it for you
[15:37:43] <cmr> heh
[15:37:48] <jedestep> ^
[15:38:02] <XgF> I haven't even *tried* reimplementing my inclusive/intrusive maps in Rust yet...
[15:38:10] <MaikKlein> :D
[15:38:18] <engla> the owned dlist seems ok, still there are lots of ways to trip up once you use unsafe code
[15:38:41] <XgF> (Intrusive -> think boost::itrusive; Inclusive -> the key is derived from the value)
[15:39:02] <cmr> check your privilege at the door mister, some of us can barely read c++
[15:39:04] <cmr> ;p
[15:39:28] <doomlord> dammit. i still type "void ... " before i type "fn ...."
[15:40:31] *** Joins: sankha93 (Instantbir@2BA23283.A06F18D1.EFB84E89.IP)
[15:42:17] <bstrie> rusti: [1,2,3].mut_iter()
[15:42:19] -rusti- more than 5 lines of output, pastebinned: http://sprunge.us/idSE
[15:42:35] <cmr> rvalue bug
[15:42:44] <bstrie> rusti: let x = [1,2,3]; x.mut_iter()
[15:42:45] -rusti- more than 5 lines of output, pastebinned: http://sprunge.us/Cfid
[15:42:51] <cmr> missing mu
[15:42:53] <cmr> t
[15:42:54] <MaikKlein> btw is it std do write headline in upper camel case in English?
[15:42:55] <cmr> IRP is fun!
[15:43:01] <bstrie> rusti: let mut x = [1,2,3]; x.mut_iter()
[15:43:02] <MaikKlein> headlines*
[15:43:03] -rusti- more than 5 lines of output, pastebinned: http://sprunge.us/EHVS
[15:43:15] <cmr> can't return & from scope!
[15:43:31] <bstrie> cmr: god damn it I just wanted to know if mut_iter was the right method name :P
[15:43:36] <cmr> :P
[15:43:38] <MaikKlein> like "I Am So Hard To Read - Headline"
[15:43:39] <bstrie> I couldn't remember if it was iter_mut()
[15:43:46] <cmr> MaikKlein: yes
[15:44:02] <engla> it's always mut_iter(), rev_iter()
[15:44:21] <engla> then the combination.. mut_rev_iter()
[15:44:46] <bstrie> engla: could there exist a .reverse() method on iter for reverse?
[15:44:49] <engla> strcat's new double ended iterator is nice
[15:44:51] <bstrie> not sure if that makes sense
[15:44:53] <engla> yeah it's what it does
[15:44:56] <bstrie> oh cool
[15:45:04] <engla> since yesterday or so
[15:45:05] <cmr> it's .invert() though
[15:45:35] <engla> I implemented it on dlist, it was straightforward, actually cleaner than before
[15:45:58] <pnkfelix> doomlord: On void/fn confusion: that should have been your response to that c++ fan/troll: "`fn` is not more characters, its fewer.  At least if most of your functions return void."
[15:46:29] *** Joins: bnicholson_ (bnicholson@moz-E98974C1.hsd1.ca.comcast.net)
[15:46:36] *** Quits: bnicholson_ (bnicholson@moz-E98974C1.hsd1.ca.comcast.net) (Input/output error)
[15:46:36] *** Quits: bnicholson (bnicholson@moz-E98974C1.hsd1.ca.comcast.net) (Input/output error)
[15:46:44] *** Joins: bnicholson (bnicholson@moz-E98974C1.hsd1.ca.comcast.net)
[15:47:09] <doomlord> oh i tried.. i gave him many examples of rust syntax being more concise :)
[15:47:54] <doomlord> my fingers should remember fn somewhere, from the BBC micro .. def fn
[15:47:59] *** Joins: int3_ (int3_@moz-ABE52D50.hsd1.ca.comcast.net)
[15:49:00] <doomlord> i've done #define fn auto and #define let auto  in my c++ source to assist transitioning too :)
[15:49:08] <bstrie> haha
[15:49:14] <bstrie> wonderful
[15:49:19] *** Quits: nano (nano@moz-972880B.superkabel.de) (Connection reset by peer)
[15:49:22] <doomlord> C++ can get the same wonderful grep benefit :)
[15:49:22] <XgF> I dunno why "fn" annoys me yet Python's "def" doesn't. Brain needs rewiring
[15:49:45] <bstrie> XgF: how would you feel about "defn" ?
[15:49:45] *** Quits: int3_ (int3_@moz-ABE52D50.hsd1.ca.comcast.net) (Ping timeout)
[15:49:51] <MaikKlein> I am totally in love with fn
[15:49:51] <engla> the only way to rewire it is to use it
[15:49:56] <doomlord> fn    def    def fn     def proc    func   defn   defun   function   ... 
[15:50:12] <engla> macro_rules!
[15:50:28] <doomlord> i like it. I like the choice of uber short for the most common keyword.
[15:50:30] *** Joins: Jeaye (Jeaye@moz-FD505E54.hsd1.ca.comcast.net)
[15:50:44] <engla> hehe, very confusing name for those not used to scala or where that was from
[15:50:47] <XgF> bstrie: Twitch due to inconsistent shortening I think
[15:50:47] <cmr> well let is the most common I'd think
[15:50:49] *** Quits: novabyte (Instantbir@moz-3E0F9699.cable.virginmedia.com) (Quit: bye bye)
[15:51:07] <doomlord> ah yes i'd object to lt  as that is "less than"
[15:51:08] <cmr> XgF: trust me you would not have liked rust before the keyword limit was lifted from 3...
[15:51:30] <XgF> Hah
[15:51:47] <engla> ret was cool
[15:51:52] <MaikKlein> limit?
[15:51:57] <doomlord> ; is cooler than ret :)
[15:52:15] <engla> yeah no ret at all is better
[15:52:18] <XgF> "ret" would probably cause me to start following it up with "mov eax, ..."
[15:52:23] <engla> MaikKlein: all keywords were max 3 characters
[15:52:26] <doomlord> rts :)
[15:52:26] <cmr> XgF: heh
[15:52:57] <XgF> Though "bx lr" is better :)
[15:53:06] <pnkfelix> Could have used "be" instead of "let"
[15:53:07] <MaikKlein> engla, haha what? how did you write trait in the past?
[15:53:18] <pnkfelix> be x = 3;
[15:53:22] <cmr> MaikKlein: didn't have traits
[15:53:23] <doomlord> iface ?
[15:53:25] <cmr> pnkfelix: wrong way around!
[15:53:28] <cmr> `x be 3`
[15:53:33] <MaikKlein> iface is also > 3 :D
[15:53:43] <doomlord> that is interesting in go, go has := ?
[15:53:46] <bstrie> engla: no, max was 5. and "ret" does sound better than "return" :P
[15:53:49] <pnkfelix> cmr: better still: "x 3 be"
[15:53:50] <doomlord> create and assign
[15:53:53] <bstrie> engla: no wait
[15:53:56] <bstrie> engla: I like "return"
[15:54:05] <bstrie> engla: I meant that "ret" sounds better than "retur"
[15:54:10] <engla> yeah since you don't use it that often return is good
[15:54:17] <engla> match was alt, so it was shorter
[15:54:18] <MaikKlein> ret is always retrieve in my brain
[15:54:34] <doomlord> ret is the variable i make to return
[16:00:34] <glinscott> ooh, shiny!  "let i32x4(e2, _, _, _) = v * v + v - v;"  that is awesome
[16:00:47] *** Quits: MaikKlein (maik@moz-B9C8EE03.dip0.t-ipconnect.de) (Ping timeout)
[16:01:33] <XgF> I always ponder whether languages should support Unicode operators. Proper dot/cross products?
[16:01:40] <XgF> (IDE support could be used to make this typable :P)
[16:02:15] <cmr> XgF: we have macros for that though...
[16:02:45] <XgF> hmm?
[16:03:39] *** Joins: MaikKlein (maik@moz-B9C8EE03.dip0.t-ipconnect.de)
[16:03:55] <cmr> you can implement all the fancy unicode operatos you want with a u!(...) macro or somesuch
[16:04:08] <XgF> Ooh
[16:04:32] <MaikKlein> why do traits only have methods and functions? what is the counter argument of not allowing traits to have members?
[16:05:06] <engla> associated items such as types are proposed
[16:05:34] *** Quits: jdm (jdm@F2D29657.F60B0462.67AC9B1.IP) (Ping timeout)
[16:05:41] <MaikKlein> isn't everything a type in Rust?
[16:06:19] *** Joins: jdm (jdm@F2D29657.F60B0462.67AC9B1.IP)
[16:06:53] <bstrie> MaikKlein: not everything is a type in rust
[16:07:26] *** Joins: leonvv (leonvv@moz-7D83A5F1.ip.telfort.nl)
[16:08:01] *** Quits: robertknight (robertknig@moz-54528EE0.wby.mendeley.com) (Quit: Computer has gone to sleep.)
[16:08:07] <MaikKlein> bstrie, what woudn't be a type for example?
[16:08:12] <cmr> `5`
[16:08:32] *** Joins: pnathan (Adium@B9840254.2CD8A5F8.477B877D.IP)
[16:08:34] <MaikKlein> ok
[16:08:35] <pnkfelix> MaikKlein: str
[16:09:03] <MaikKlein> pnkfelix, what is str if it is not a type?
[16:09:11] <cmr> it's a weird thing
[16:09:15] <cmr> special case, along with []
[16:09:20] <pnkfelix> MaikKlein: I don't know, I would call it a "pre-type" or something along those lines
[16:09:30] <pnkfelix> MaikKlein: but until you put a sigil on it, its not a type
[16:10:59] <MaikKlein> engla, but it's not a written proposal yet? https://github.com/mozilla/rust/wiki/Proposals
[16:11:15] <cmr> MaikKlein: it's on nmatsakis's blog
[16:11:36] *** Joins: jclements (jclements@moz-20AD2EFB.dsl.static.sonic.net)
[16:11:57] <MaikKlein> cmr, do you have a link?
[16:12:13] <pnkfelix> MaikKlein: see also here: http://blog.pnkfx.org/blog/2013/04/22/designing-syntax-for-associated-items-in-rust/
[16:12:16] *** Joins: jaen (jaen@moz-E0979827.copit.pl)
[16:12:24] <engla> MaikKlein: values are not types
[16:12:43] <engla> MaikKlein: everything from a trait must be invoked with `()`
[16:13:11] *** Quits: jclements (jclements@moz-20AD2EFB.dsl.static.sonic.net) (Quit: jclements)
[16:13:12] <pnkfelix> MaikKlein: though nmatsakis has pointed out that this proposal may not gel as nicely as I had hoped, due to potential namespace conflicts (in terms of the namespaces for modules vs types + traits vs the funny type*trait pairs that I talk about in that post)
[16:13:21] *** Joins: jclements (jclements@moz-20AD2EFB.dsl.static.sonic.net)
[16:13:30] <engla> a type in a trait would be like "let n: G::NodeType = graph.next_node()"  where graph is type G
[16:14:10] <Phlogistique> kricilodu'ugusni
[16:15:32] <MaikKlein> pnkfelix, thanks for the link, I am currently reading it
[16:16:59] *** Joins: mcclurmc (mcclurmc@moz-FF454CE2.threembb.co.uk)
[16:18:23] *** Quits: xyproto (alexander@moz-251295DE.members.linode.com) (Quit: WeeChat 0.4.1)
[16:18:56] <MaikKlein> pnkfelix, I had a small glimpse at it and it seems that I have done sth similar in rust http://www.reddit.com/r/rust/comments/1i5oha/an_alternative_way_to_achieve_inheritance/
[16:19:22] *** Quits: bytbox (s@moz-DC83764A.washdc.fios.verizon.net) (Ping timeout)
[16:19:51] <XgF> Hmm... any thought to permitting pointers to be given LLVM addres space tags? In some OS and low level (TLS) work making GS/FS relative pointers on x86 is *very* useful
[16:20:49] <cmr> XgF: address spaces were removed like 1-2 months ago, because they wre a mess (were there for potential GC use)
[16:21:09] <pnkfelix> MaikKlein: hmm, not sure if its quite the same: Your example, IIUC, is going to have have to resolve those closures dynamically
[16:21:31] <pnkfelix> MaikKlein: but maybe I missed something, I'll have to look at it later (must jet now)
[16:21:38] *** Joins: brendan (brendaneic@moz-BBE3ABD.mv.mozilla.com)
[16:22:02] <XgF> cmr: I'm thinking something along the lines of CLang's "ThreadInfo __attribute__((addressspace(256)))*" 
[16:22:05] *** Joins: dherman (dherman@moz-6CA476B1.hsd1.ca.comcast.net)
[16:22:05] *** ChanServ sets mode: +o dherman
[16:22:10] *** Joins: infynyxx_ (infynyxx@DB780A29.749BA1D.DCC373F0.IP)
[16:22:12] <cmr> XgF: oh
[16:22:21] *** Quits: dherman (dherman@moz-6CA476B1.hsd1.ca.comcast.net) (Quit: dherman)
[16:22:27] <cmr> could easily be added via attribute I think
[16:22:37] <cmr> would of course need codegen support, but I don't see what would prevent it
[16:22:40] <XgF> That passes down to LLVM's address space attribute, which causes the backend to emit GS segment overrides on accesses
[16:23:00] <MaikKlein> pnkfelix, yes it would be dynamic I think
[16:23:11] *** Quits: pnkfelix (pnkfelix@87C1F78E.1DE10CA8.D8E68FF6.IP) (Quit: Leaving.)
[16:23:51] *** Quits: infynyxx_ (infynyxx@DB780A29.749BA1D.DCC373F0.IP) (Ping timeout)
[16:24:03] *** Quits: jedestep (jedestep@34641662.FB4DE631.66C78B76.IP) (Ping timeout)
[16:24:15] *** Joins: vk (chatzilla@3E9D68F2.B1163E0C.2A6693DD.IP)
[16:24:19] <jasom_> So, lets say I have a search tree; in a garbage collected language, I might have an internal function to find a node that returns a reference to that node that allows mutating of the node.  With the concept of owned references, this isn't possible (since I don't want to change ownership).  The solution that makes sense to me is to instead pass a function to the "find" function that can do the mutating.  Am I missing a better way of doing this?
[16:24:42] <cmr> jasom_: that's a good way
[16:24:50] <cmr> jasom_: could also return a &mut
[16:25:03] *** Joins: pnkfelix (pnkfelix@87C1F78E.1DE10CA8.D8E68FF6.IP)
[16:25:04] <jasom_> cmr: how does that work with ownership though; 
[16:25:18] <monk> well, you can return a pointer which has the same lifetime as the tree itself
[16:25:29] <cmr> jasom_: &mut doesn't take ownership, but it does ensure that it's the only mutable reference to the item
[16:25:31] <jasom_> monk: that doesn't work if the tree supports removal
[16:25:41] <monk> true
[16:25:47] <cmr> the best way is probably passing in a closure
[16:25:49] *** Quits: jaen (jaen@moz-E0979827.copit.pl) (Ping timeout)
[16:26:03] <jasom_> cmr: okay, that's what made the most sense to me too
[16:27:01] <monk> I don't see how that's any better
[16:27:08] <cmr> monk: than what?
[16:27:19] *** Quits: Ralith (ralith@moz-50F3C77.vc.shawcable.net) (Ping timeout)
[16:27:25] <monk> than just returning a borrowed pointer
[16:27:32] <cmr> borrowed pointer with what lifetime?
[16:27:39] *** Joins: robertknight (robertknig@moz-54528EE0.wby.mendeley.com)
[16:27:42] <monk> what would you pass into the function?
[16:28:03] <cmr> a &mut
[16:28:09] <monk> with what lifetime?
[16:28:17] *** Quits: wilma (Mibbit@BBE7C46A.B4F11D08.8612FA94.IP) (Quit: http://www.mibbit.com ajax IRC Client)
[16:28:38] <cmr> implicit wouldn't work? it just needs to survive as long as the .find function
[16:28:42] <monk> sorry, generally curious but perhaps had too many beers.
[16:29:09] *** Joins: santiago (santiago@moz-656C5B51.hsd1.ma.comcast.net)
[16:29:44] <monk> I guess I'd like to see an example where returning a borrowed pointer means you can't do something that you can do with the mutation function passing form.
[16:30:06] <monk> unless you can't return the borrowed pointer at all...
[16:30:23] * monk needs to spend more time writing rust code -_-
[16:30:35] <cmr> if there's a way to limit the lifetime of the returned reference granularly, it'd work, but I dunno how you'd do that
[16:30:49] <jasom_> cmr: exactly why I wasn't returning an &mut
[16:30:58] <cmr> you need to make sure the caller doesn't stash that reference somewhere and prevent you from reborrowing/removing the object
[16:30:59] *** Quits: pnkfelix (pnkfelix@87C1F78E.1DE10CA8.D8E68FF6.IP) (Quit: Leaving.)
[16:31:31] <monk> hmm okay, I guess there's no way to "unborrow"
[16:31:33] <jasom_> the implicit lifetimes of the borrowed references when passing a closure to call are exactly the lifetimes I want; the code might look a little cleaner if there were a simple way to borrow and return references
[16:31:40] <jasom_> but it would be a tiny difference
[16:31:45] <monk> so the caller can't say "I'm done with this reference" ?
[16:31:52] <monk> uh, done with this borrowed pointer*
[16:31:55] <cmr> not afaik
[16:31:58] <bstrie> monk: if you know that you only need a borrow to live for a certain scope, you can wrap the whole scope in braces
[16:32:11] <monk> okay :)
[16:32:13] <cmr> hm, well, that might work maybe?
[16:32:22] <cmr> if the borrow "locks" the whole data structure..
[16:32:36] <bstrie> I wasn't really reading, not sure exactly what you're trying to do
[16:33:34] <monk> modify a part of a tree without shared ownership of it
[16:33:41] * jasom_ supposes you could have .find return the reference, plus a closure that would give the reference back, but that seems round-about and more error prone than what I'm doing now
[16:33:58] <jasom_> since the caller of find could unintentionally forget to give it back
[16:34:31] <jasom_> and the whole point of implicit ownership is to reduce the number of things you can forget about that will cause bugs
[16:34:58] <cmr> jasom_: this seems like a good question to ask the ML
[16:35:50] <jasom_> cmr: I think I will; I was pretty happy with my solution, but when coding in a new language in a vacuum it's easy to end up with highly non-idiomatic code
[16:35:52] <monk> both returning the borrowed pointer or passing it into a function seem to introduce braces :P so not sure I would mind either way...
[16:35:57] *** Quits: MaikKlein (maik@moz-B9C8EE03.dip0.t-ipconnect.de) (Ping timeout)
[16:36:17] <cmr> Well the reason to avoid a closure is that it doesn't perform as well
[16:36:23] <cmr> introduces indirection and a function call
[16:36:31] <monk> true
[16:36:32] <cmr> (if it isn't inlined)
[16:36:46] <cmr> (which it probably won't be, our codegen for closures isn't very ideal)
[16:36:49] * jasom_ can't think of a way to do it without a closure
[16:37:39] *** Joins: ghrust (ghrust@E7A4CCE2.6A2AE50.F3114085.IP)
[16:37:39] <ghrust> 01[13rust01] 15bors merged 06auto into 06master: 02http://git.io/KWF6Ow
[16:37:39] *** Parts: ghrust (ghrust@E7A4CCE2.6A2AE50.F3114085.IP) ()
[16:37:43] <monk> jasom_: the suggestion seems to be return a borrowed pointer, but use {} to isolate where you need the borrowed pointer
[16:38:08] <monk> I would write a code sample but I'd probably get it wrong!
[16:38:15] *** Quits: infynyxx (infynyxx@moz-E95B370B.nyc.res.rr.com) (Client exited)
[16:38:39] <monk> like in C++, I gather you can introduce new scopes at any time with {}?
[16:40:38] *** Joins: ghrust (ghrust@F6EE6DE3.6A2AE50.F3114085.IP)
[16:40:38] <ghrust> 01[13rust01] 15bors pushed 0 new commits to 06auto: 02http://git.io/v3_1bA
[16:40:38] *** Parts: ghrust (ghrust@F6EE6DE3.6A2AE50.F3114085.IP) ()
[16:40:39] *** Joins: ghrust (ghrust@2EE61FCC.6A2AE50.F3114085.IP)
[16:40:39] <ghrust> 01[13rust01] 15bors pushed 2 new commits to 06auto: 02http://git.io/bAZ9qg
[16:40:39] <ghrust> 13rust/06auto 147910c72 15Brendan Cully: Enable large stacks on 64-bit architectures
[16:40:39] <ghrust> 13rust/06auto 144e1292a 15bors: auto merge of #7728 : bcully/rust/largestack64, r=cmr...
[16:40:39] *** Parts: ghrust (ghrust@2EE61FCC.6A2AE50.F3114085.IP) ()
[16:41:00] <cmr> monk: yup
[16:42:51] *** Quits: sk (sk@2A567C1F.54A580E3.78DD174B.IP) (Quit: Leaving)
[16:42:54] *** Joins: doener (doener@moz-121949B3.unitymediagroup.de)
[16:47:09] *** Joins: MaikKlein (maik@moz-B9C8EE03.dip0.t-ipconnect.de)
[16:47:37] <engla> will TotalOrd disappear with default methods?
[16:47:47] <cmr> engla: why would it?
[16:48:09] <engla> it can be inconvenient to have both Ord and TotalOrd
[16:48:17] <cmr> well yes, but they're different concepts
[16:48:21] *** Joins: froystig (froystig@4AB93A85.352137A1.BCED17D.IP)
[16:49:08] <engla> they seem to have the same capabilities from the traits
[16:49:25] *** Quits: mcclurmc (mcclurmc@moz-FF454CE2.threembb.co.uk) (Ping timeout)
[16:49:44] *** Joins: mcclurmc (mcclurmc@moz-FF454CE2.threembb.co.uk)
[16:50:04] <engla> the whole difference is in TotalEq and not in TotalOrd "itself"
[16:50:09] <engla> ?
[16:51:32] *** Joins: Ralith (ralith@moz-71FF9C0.wireless.sfu.ca)
[16:51:44] *** Quits: Sergio965 (sergiobz@moz-BB21156B.dynamic.csail.mit.edu) (Ping timeout)
[16:52:06] <cmr> for TotalOrd you can compare any two values of the type and get a definitive result, not true for Ord
[16:52:13] <cmr> at least, that's how I understand it should be
[16:52:16] <cmr> total order vs partial order
[16:52:17] *** Quits: robertknight (robertknig@moz-54528EE0.wby.mendeley.com) (Quit: Computer has gone to sleep.)
[16:52:19] *** Joins: jedestep (jedestep@34641662.FB4DE631.66C78B76.IP)
[16:52:42] <engla> yeah, I'm just missing something
[16:52:45] <cmr> ie, lt and gt could both return true
[16:52:52] <cmr> bjz: could you answer this maybe?
[16:53:04] <engla> I think it's possible to express either partial or total order with the same functions. But it can make sense to separate the two
[16:53:16] <engla> just for the total ordering guarantee
[16:55:10] <engla> I conclude I was confused
[16:55:26] *** Quits: leonvv (leonvv@moz-7D83A5F1.ip.telfort.nl) (Client exited)
[16:55:34] <engla> anyway Ord itself with its four methods could use default methods to reduce the required methods to just one
[16:55:43] <cmr> yes, it could
[16:55:47] <engla> and Eq could implement ne by default
[16:55:55] <cmr> erm actually
[16:56:16] <engla> there's a lot of fruit to pick there and in the num method
[16:56:20] <engla> num module
[16:56:27] <cmr> I think the whole point of Eq and Ord is that the result of one doesn't imply the result of the others
[16:56:40] <cmr> and default implementations would be incorrect if they used that assumption...
[16:56:40] <engla> sure, but the default case isn't NaN
[16:57:01] <cmr> I'm looking at the Ord trait here, not specifically anything in num
[16:57:02] <engla> no but strangely ordered types have to implement it specifically
[16:57:03] <cmr> and Eq
[16:57:27] <engla> default methods can be overridden
[16:57:34] *** Quits: elspruto (elspruto@moz-A9EADF4E.bb.online.no) (Quit: )
[16:57:40] <cmr> yes but the default behavior shouldn't be incorrect
[16:57:59] <engla> there is no default behavior unless you implement at least one method
[16:58:14] <engla> not sure how it can be incorrect even
[16:58:18] *** Quits: vk (chatzilla@3E9D68F2.B1163E0C.2A6693DD.IP) (Client exited)
[16:58:36] *** Quits: MaikKlein (maik@moz-B9C8EE03.dip0.t-ipconnect.de) (Ping timeout)
[16:58:47] <cmr> what would the defaults be?
[16:59:47] *** Joins: dwhyte (dwhyte@ED9190FB.B72E355F.7BF4A4B0.IP)
[16:59:52] <Eridius> I don't think Eq can necessarily be expressed in terms of Ord, but Ord should be able to only require .lt
[17:00:00] <cmr> Eridius: why?
[17:00:03] <Eridius> why what?
[17:00:11] *** Joins: MaikKlein (maik@moz-B9C8EE03.dip0.t-ipconnect.de)
[17:00:13] <engla> I'll paste one
[17:00:13] <cmr> Should Ord only require lt?
[17:00:22] <cmr> !lt doesn't imply gt
[17:00:31] <Eridius> cmr: because in the vast majority of cases, the default implementation for the others built on top of .lt would be correct
[17:00:50] <engla> cmr: the default implementation should reuse one of the four methods, like this http://paste.debian.net/plain/15766
[17:01:04] <Eridius> cmr: !lt implies ge
[17:01:06] <engla> in this case all of them are expressed using lt
[17:01:11] <cmr> Eridius: not for partial order?
[17:01:25] <Eridius> cmr: partial order just means that a < b and b < c does not imply a < c, IIRC
[17:01:25] <cmr> the result could be indeterminate (which Ord doesn't really express well)
[17:01:35] <Eridius> partial order still requires the 4 comparison operators to be internally consistent
[17:01:46] <engla> if the result is indeterminate, just put fail!() in your Ord implementation :-)
[17:01:52] <cmr> Eridius: partial order aiui means that you can be given two values of a type and not have any meaningful order at all
[17:02:45] <Eridius> cmr: a quick wikipedia suggests that the phrase we actually want is "complete partial order"
[17:02:51] <ski> Eridius : no, partial orders still have `a < b' and `b < c' implying `a < c' (transitivity)
[17:03:35] <engla> this can not be expressed with Ord. The logical default impl is like the link I pasted
[17:03:47] <engla> and you can still override any method to have a more inconsistent ordering
[17:04:00] <Eridius> partial order means every two elements of the set (i.e. type) has an upper bound that they're both <= of
[17:04:09] *** Quits: pyrac (pyrac@moz-F2C67F88.w83-114.abo.wanadoo.fr) (Quit: pyrac)
[17:04:28] <ski> sorry, no
[17:04:40] <Eridius> sorry, that's "directed set", not "partially ordered set". still reading
[17:04:42] <cmr> we need a mathematician :p
[17:05:10] *** Joins: pcwalton (pcwalton@moz-7B0110AD.mv.mozilla.com)
[17:05:10] *** ChanServ sets mode: +o pcwalton
[17:05:13] *** Quits: donri (dag@moz-9BB61102.tbcn.telia.com) (Client exited)
[17:05:43] <ski> partial orders only have irrreflexivity, asymmetry and transitivity (for the `<' formulation); alt. reflexivity, antisymmetry, and transitivity (for the `â‰¤' formulation)
[17:05:44] *** Joins: eholk (eholk@moz-A6B67E64.uconnect.utah.edu)
[17:05:45] <Eridius> hmm, I think cmr is right. a partially ordered set only means that certain pairs have a defined order. It does not mean that every possible pair has a defined order
[17:05:56] <ski> yes
[17:06:54] *** Quits: echristo (echristo@moz-1892C634.hsd1.ca.comcast.net) (Quit: echristo)
[17:07:02] <engla> well that's not expressible with Ord
[17:07:10] <cmr> nope, Ord is pretty broken it seems
[17:07:19] <cmr> run a git blame on it :p
[17:07:36] <Eridius> engla: it is expressible by making all 4 operators return false
[17:07:40] <ski> a lattice is a partial order where every two elements have a least upper bound, and a greatest lower bound
[17:07:41] *** Quits: lmandel (lmandel@F2D29657.F60B0462.67AC9B1.IP) (Ping timeout)
[17:07:48] <Eridius> which you can still do even if you redefine Ord to only require a definition of .lt (because you can still override the others)
[17:08:16] <ski> (e.g. pairs of integers naturally form a lattice)
[17:08:36] <cmr> Eridius: hell you don't need *any* impl for that, just impl Ord for T and have them all return false
[17:08:46] <engla> Eridius: if you think that's an ok expression then Ord is fine
[17:08:48] <cmr> but that would probably break every piece of code that has <T: Ord>
[17:09:02] <engla> but Option<bool> would be more the gist of it?
[17:09:23] <sp3d> isn't this kind of like Haskell where you have the Monad typeclass but it can't guarantee that your implementation is actually a monad?
[17:09:48] <cmr> sp3d: it's more of having a Monad typeclass that makes it impossible to express a monad
[17:09:49] <Eridius> engla: I think returning false from all is a reasonable expression of this, because each operator says "is object A less than object B?" and if they're not comparable then the answer is obviously "no"
[17:09:56] *** Joins: azakai (alon@moz-BBE3ABD.mv.mozilla.com)
[17:09:59] <Eridius> cmr: why would providing default implementations break every T: Ord?
[17:10:03] <sp3d> cmr: ah
[17:10:25] <Eridius> every implementation of Ord today already implements all 4 methods, so default methods wouldn't affect that
[17:10:27] <cmr> Eridius: think of a sort, if it can never compare something, I imagine it'd get stuck in an iloop
[17:10:37] <cmr> (maybe not)
[17:10:42] <engla> Eridius: yeah, I can agree
[17:10:44] <Eridius> cmr: we already tested sorting with NaN earlier
[17:10:46] *** Joins: spider-mario (spidermari@moz-81131DB6.fbx.proxad.net)
[17:10:53] <Eridius> sorts behave badly, but they have a worst-case time built into the algorithm
[17:10:56] <sp3d> what is Ord suposed to do, then? imply an ordering or a partial ordering?
[17:11:02] <cmr> anyway everything that uses Ord probably wants TotalOrd, and Ord should be impl'd <T: TotalOrd>
[17:11:05] <engla> bogosort would be stuck in a loop
[17:11:07] <cmr> sp3d: partial ordering
[17:11:15] <sp3d> ohhh.
[17:11:24] <Eridius> cmr: if you impl Ord for all TotalOrd, can a TotalOrd implementer re-implement Ord themselves and not conflict?
[17:11:29] <Eridius> (if that even makes sense to do)
[17:11:34] <cmr> Eridius: doesn't make sense to do
[17:11:43] <engla> I think it's wrong to say Ord is a partial order. Ord is there to cope with floats
[17:11:49] <engla> that's all
[17:11:53] <Eridius> engla: just floats?
[17:12:03] <Eridius> engla: if I impl<T: Ord> Ord for Option<T> I also have a partial order
[17:12:07] <Eridius> since None can't compare with any some
[17:12:09] <Eridius> *Some
[17:12:17] <Eridius> I mean, I could define None as less than any Some I suppose
[17:12:23] <Eridius> but it's also reasonable to say it's non-comparable
[17:12:34] <Eridius> (practically speaking, I'd probably define it as less than any Some just to allow for a total ordering)
[17:12:36] <engla> no, less than some is much better
[17:12:41] *** Joins: peeves (Mibbit@283DF7AB.5B0086C8.A3D1B221.IP)
[17:12:42] *** Joins: olleharstedt (Thunderbir@moz-80D8890F.ias.bredband.telia.com)
[17:12:44] <Eridius> semantically speaking it's uncomparable
[17:13:10] *** Joins: jensnockert (jensnocker@moz-C5F27039.cust.bredband2.com)
[17:13:13] <engla> not sure about that
[17:13:24] <pcwalton> I'm interested in coming up with a list of things that C++/D templates can do that Rust typeclasses + macros cannot
[17:13:31] <Eridius> engla: bogosort would not be stuck in a loop if your test is_sorted() checks if each subsequent value is not less than the previous
[17:13:35] <pcwalton> and then consulting the literature for ideas on how to add it
[17:13:58] <Eridius> pcwalton: meta-template-programming by allowing for data (e.g. ints) in template params
[17:14:09] <Eridius> that ability would let us implement traits on arrays, for example
[17:14:23] <ski> Eridius : "partial order still requires the 4 comparison operators to be internally consistent" -- yes, but this means that, firstly `a < b' and `b > a' means the same, and `a â‰¤ b' and `b â‰¥ a' means the same, and secondly that `a â‰¤ b' means the same as `a < b âˆ¨ a = b', and `a < b' means the same as `a â‰¤ b âˆ§ a â‰  b' (or, if you prefer, `a â‰¤ b âˆ§ Â¬ b â‰¤ a')
[17:14:25] <pcwalton> yeah, that's type-level numeric literals
[17:14:29] <pcwalton> GHC has those
[17:14:31] <Eridius> impl<T, N: int> Foo for [T, ..N]
[17:14:46] <doomlord> pcwalton i ran into a bug , where the constraint was over-constraining compared to c++ template specialization 
[17:14:57] <doomlord> ... but i think it is , admitedly a bug and not a design flaw
[17:14:59] <monk> the thing that C++ has that I've felt a bit lacking in haskell typeclasses - variadics. but maybe macros are the answer there.
[17:15:06] <Eridius> ski: and that means that you can define the other methods in terms of .lt if you want
[17:15:17] <pcwalton> there's also CTFE, which dherman, jclements, and I had an idea on how to do, but Template Haskell has another solution, and I'd be interested to see how they compare
[17:15:29] <Eridius> monk: template variadics are a PITA to work with in C++ though
[17:15:47] <ski> Eridius : yes, but not as <http://paste.debian.net/plain/15766> did it
[17:15:51] <engla> visiting the Ord trait in the source reveals a comment that remarks three of the four methods should have default implementations in the future
[17:16:01] <doomlord> default parameters are nice , i think
[17:16:03] <engla> is it time to implement that?
[17:16:12] <pcwalton> engla: might need a snapshot
[17:16:45] <doomlord> but if you fixed multi-item macros, there would be more that rust can do that would help cases i use
[17:16:45] <cmr> engla: if it makes sense to do that, I think so, but I think it's very wrong to have Ord only for float-like semantics
[17:16:47] <monk> Eridius: maybe, though it seems like it's easier to generalise over tuples for example in C++. But maybe that's just because I'm not including template haskell.
[17:17:11] <pcwalton> the fundamental difference is that we don't really have a full metaprogrammable system that runs *at typeck time*
[17:17:11] *** Joins: bent (chatzilla@CB3EC984.A5F785DE.396E4C6D.IP)
[17:17:21] <Eridius> monk: having to use a dummy template class just to help you with extracting the parameters from your template pack? That's horrible
[17:17:29] <engla> pcwalton: I'll see if just going for it will compile and pass
[17:17:31] <pcwalton> because that can result in typechecking failures in templated code, which typeclasses are designed to avoid
[17:17:38] <pcwalton> engla: sure
[17:17:46] <pcwalton> which I guess is just a fundamental disagreement
[17:18:04] <ski> "semantically speaking it's uncomparable" -- depends on what you want
[17:18:14] <pcwalton> C++/D programmers will say that doesn't matter, haskell programmers will say it's very important... oh well :)
[17:18:28] *** Quits: rajul (quassel@E0F7EEF0.8F837703.13EFE003.IP) (Client exited)
[17:18:53] <pcwalton> geez, 6 merge conflicts in 3 commits' worth of changes
[17:19:03] <doomlord> haskellers are proud of the fact they can pass a template to a template, effectively, which c++ can't
[17:19:13] <pcwalton> yeah, haskell's system allows more flexibility
[17:19:14] <pcwalton> in some ways
[17:19:16] <pcwalton> and less in others
[17:19:17] <Eridius> pcwalton: I want a way to not have to explicitly write out my return value
[17:19:31] <pcwalton> Eridius: not sure what you mean
[17:19:37] <cmr> Eridius: Return type inference?
[17:19:39] <Eridius> pcwalton: gimme a sec, pulling up the motivating code
[17:20:20] <Eridius> pcwalton: https://github.com/kballard/rust/commit/7d12e494a97b72bab35a1c17a3c514a67f292ea1, getting the return types right for .encode_as was really annoying
[17:20:29] <doomlord> i dont think rust can overload on multiple types, can it; eg in c++ you can say mul(matrix, vector) .. mul(quaternion, point) etc
[17:20:40] <Eridius> and that's a tame example. I had one floating around that used several iterator adaptrs together, but I didn't keep it
[17:20:41] <pcwalton> doomlord: you can
[17:20:47] <cmr> Eridius: Return type inference is bad bad bad, makes it super trivial to break ABI without ever noticing
[17:20:51] <doomlord> whats the syntax, interesting
[17:20:52] *** Quits: jclements (jclements@moz-20AD2EFB.dsl.static.sonic.net) (Quit: jclements)
[17:21:09] <pcwalton> Eridius: hmm. would associated types help?
[17:21:12] <doomlord> and i meant function overload not operator overload
[17:21:17] <pcwalton> associated types are designed to avoid generic type parameter explosion
[17:21:18] <Eridius> cmr: I don't think it should be used often. But especially with iterator adaptors it can become really hard to get the return type correct
[17:21:27] <Eridius> pcwalton: not sure what you mean by associated types
[17:21:35] *** Joins: eschweic (Adium@moz-BBE3ABD.mv.mozilla.com)
[17:21:58] <cmr> Eridius: I agree it's useful but it's just too easy to abuse
[17:21:59] <pcwalton> so associated types mean you can write trait Foo { type T; ... } and then impl Foo for MyType { type T = MyOtherType; ... }
[17:22:07] <doomlord> i got the impression it was "overload" for the thing you "impl" for, the rest is "generic type parameters" .. which is not the same thing as overloading
[17:22:18] <pcwalton> and then say MyType::MyOtherType inside type signatures
[17:22:24] <doomlord> ahhhh
[17:22:25] <Eridius> pcwalton: ah. That's a reasonable thing to have, but I'm not sure it would help at all in my encoding case
[17:22:27] <pcwalton> today you have to write
[17:22:31] <pcwalton> trait Foo<T> { ... }
[17:22:32] *** Joins: infynyxx (infynyxx@DB780A29.749BA1D.DCC373F0.IP)
[17:22:36] <doomlord> interesting 
[17:22:40] <pcwalton> and then you get generic type parameter explosion
[17:22:42] <pcwalton> ok
[17:22:50] *** Quits: Ralith (ralith@moz-71FF9C0.wireless.sfu.ca) (Ping timeout)
[17:23:20] <pcwalton> well, maybe you could move some of the type parameters on VecEncoder to be associated types?
[17:23:22] *** Quits: eschweic (Adium@moz-BBE3ABD.mv.mozilla.com) (Ping timeout)
[17:23:24] *** Quits: bnicholson (bnicholson@moz-E98974C1.hsd1.ca.comcast.net) (Ping timeout)
[17:23:31] <pcwalton> that would reduce type parameter explosion
[17:23:34] <doomlord> in some ways i wondered if the lack of overloading was actually a virtue, it contributes to source searchability
[17:23:39] <Eridius> I guess what I just want to be able to say is "hey, this method's going to return some Iterator<T>, compiler please figure out exactly which one based on my code"
[17:23:40] *** Joins: eschweic (Adium@moz-BBE3ABD.mv.mozilla.com)
[17:24:01] *** Joins: leonvv (leonvv@moz-7D83A5F1.ip.telfort.nl)
[17:24:04] <cmr> If your return type is unbounded that's going to be quite difficult to debug
[17:24:09] <doomlord> it means having to do a sort of 'double dispatch' for multiple overload
[17:24:13] <cmr> especially in a complex case like that
[17:24:16] *** Quits: infynyxx (infynyxx@DB780A29.749BA1D.DCC373F0.IP) (Ping timeout)
[17:24:23] <pcwalton> well, with associated types you could say -> E::Iterator
[17:24:23] <engla> Eridius: you also want that in traits. The trait should specify a method required to return an iterator, but not the concrete type
[17:24:26] <pcwalton> and not have the type parameter
[17:24:27] *** Quits: peeves (Mibbit@283DF7AB.5B0086C8.A3D1B221.IP) (Quit: http://www.mibbit.com ajax IRC Client)
[17:24:34] <Eridius> cmr: the compiler can already tell me if I wrote the wrong return type. Which menas it knows what the right oen is
[17:24:38] <pcwalton> you could get rid of U
[17:25:01] <doomlord> i wondered if you could just allow c++ style free function overloading..
[17:25:06] <cmr> Eridius: only because you write out what the correct return type is..
[17:25:07] <Eridius> wow two typos in one sentance. bad keyboard
[17:25:08] <doomlord> outside of traits
[17:25:25] <Eridius> cmr: huh? I just said if I write the wrong one, it tells me
[17:25:35] <cmr> Eridius: Because it knows what the right one is, and can compare
[17:25:45] <pcwalton> so you mean not having to write the type signature again on impls if it can infer it from the trait?
[17:26:12] *** Quits: MaikKlein (maik@moz-B9C8EE03.dip0.t-ipconnect.de) (Ping timeout)
[17:26:13] *** Joins: azita (Azita@moz-C1FB2A8.hsd1.ca.comcast.net)
[17:26:19] <doomlord> a multiple overload example:  render(bitmap, square)   render(vectordrawing,  circe)  render(bitmap, circle) ...
[17:27:09] <Eridius> pcwalton: I'm basically just asking to be able to provide a type parameter that can only actually ever have one valid type, because the code returns a concrete type
[17:27:28] <Eridius> so I could write fn encode_as<X>(self, enc: E) -> X {}
[17:27:34] <pcwalton> I *think* associated types allow you to do that
[17:27:37] <pcwalton> you would just write
[17:27:46] <pcwalton> fn encode_as(self, enc: E) -> E::X { ... }
[17:27:52] <doomlord> render(a:T, b:someComplexThing)  { for each square s in b render(a,s); for each circle s in b render(a,s); .../* no use of vtables*/}
[17:28:08] <Eridius> pcwalton: I'd need higher-order types
[17:28:15] <Eridius> because E::X would hvae to be parameterized itself
[17:28:23] <pcwalton> ah yes, we should have higher kinded types too :)
[17:28:36] <Eridius> no wait, I'm being silly
[17:28:43] <Eridius> my E is already parameterized in the template list
[17:28:47] <Eridius> so E::X would work
[17:28:55] <Eridius> ok so yeah, associated types would be great
[17:28:56] *** Joins: jclements (jclements@moz-20AD2EFB.dsl.static.sonic.net)
[17:29:15] <pcwalton> we had a discussion on how they should work in vancouver a couple of months ago
[17:29:37] <Eridius> that won't save me from having to write out the iterator adaptor types in my type param list, but I could at least drop the U
[17:29:39] <pcwalton> we probably won't block 1.0 on them but I'm totally ok with them
[17:29:48] *** Joins: bytbox (s@moz-75D4B5A8.wireless.umd.edu)
[17:30:03] <Eridius> pcwalton: I also want the ability to have lifetimes on traits that aren't 'self or 'static
[17:30:18] <pcwalton> yeah, I think niko has that planned
[17:30:21] <Eridius> at the moment it's impossible to write the .encode_chars(&self, &[u8]) method that I wanted to put on Encoder
[17:30:31] <doomlord> did it used to be better at assuming a default lifetime, i was sometimes surprised where i had to annotate
[17:30:45] <cmr> doomlord: it used to be worse and rejecting invalid code
[17:30:48] <cmr> *at
[17:30:53] <Eridius> I'd also need to be able to use the lifetime specified in the impl on the parameters to my method, which I think currently complaints about using a bound lifetime (if I try it with 'self)
[17:31:17] *** Quits: azita (Azita@moz-C1FB2A8.hsd1.ca.comcast.net) (Quit: azita)
[17:31:35] <Eridius> impl<'a, U: Foo<VecIterator<'a, u8>>> EncoderUtil for Encoder { fn encode_chars(&self, &'a [u8]) -> U }
[17:31:43] *** Joins: azita (Azita@moz-C1FB2A8.hsd1.ca.comcast.net)
[17:32:05] *** Quits: CarpNet (ac@moz-FD24B77.sohonet.co.uk) (Quit: Leaving)
[17:32:15] <ski> cmr : elaborate on "Return type inference is bad bad bad, makes it super trivial to break ABI without ever noticing" ?
[17:32:55] <Eridius> ski: same reason why letting Haskell deduce your entire function type is bad
[17:33:07] <Eridius> change code in the function, the function signature changes and breaks all your callers
[17:33:29] <cmr> ski: By changing the return type of a private, internal function that's return type is used in public functions' infered return type, you break public ABI, without every actually touching a line of public code.
[17:33:49] <cmr> I think I did my apostrophes wrong
[17:33:55] <cmr> that was an awkward sentence
[17:34:01] <jedestep> :I
[17:34:08] <Eridius> s/that's/whose/
[17:34:20] <doomlord> maybe you could allow full type inference for priv :)
[17:34:22] <jasom_> I have temporarily given up on for loops
[17:34:40] <cmr> doomlord: that's just be inconsistent and weird
[17:34:44] <doomlord> ok
[17:35:05] <cmr> nothing wrong with it besides that though, afaict
[17:35:27] <doomlord> the case where i'd find myself wanting return type inference - i'm not sure how to do in rust off hand,
[17:35:39] <doomlord> something like mul (fixedpoint,fixedpoint) -> different fixed point
[17:35:54] <cmr> It'd be hugely useful to reduce typing
[17:36:06] <cmr> https://github.com/cmr/rustdoc_ng/blob/master/clean.rs#L85
[17:36:08] <Eridius> how did this build fail? http://buildbot.rust-lang.org/builders/auto-linux-64-nopt/builds/391 it builds on my machine, and I have a `use std::local_data` at the top of the file
[17:36:08] <ski> Eridius : do you mean hard to track down "real" source of type error ?
[17:36:09] <doomlord> eg 8.8bit x 8.8bit -> 16.16bit
[17:36:16] <cmr> pub fn clean(&self) -> T ... gets old after a while
[17:36:31] <Eridius> ski: not sure what you mean
[17:36:33] <cmr> clean() { ... } would be great
[17:36:42] <cmr> everything infered from the trait you are implementing
[17:37:24] <doomlord> i was surprised you can't use 'Self' in trait impls'
[17:37:37] <cmr> doomlord: in impls you have to use the concrete type aiui
[17:37:39] *** Joins: Cs (Sohbet@C929B15.A8EA7FF1.E9B01DC7.IP)
[17:37:41] <ski> cmr : well, public functions should have explicit types specified for parameters and return value
[17:37:55] <cmr> ski: I agree
[17:38:20] <doomlord> well whats there is nice as its leveraged with the excellent inference within the function
[17:38:24] <cmr> And we can prevent an entire class of future errors by enforcing that
[17:38:35] <ski> cmr : so, would there be anything wrong with some internal private functions not explicitly specifying return type, then ?
[17:38:47] <cmr> ski: no, as I said to doomlord, it'd just feel weird and inconsistent
[17:38:58] <ski> ok, ty
[17:39:19] <cmr> (at least, afaict... I haven't put a ton of thought into that problem, but that seems to be a fine solution)
[17:39:20] <ski> (btw, for some reason i was first thinking you were talking about overloading on return type)
[17:39:20] <doomlord> does it help compile times too, the amount of infering going on
[17:39:34] <cmr> doomlord: makes it worse!
[17:39:46] <cmr> you have to run inference algorithms where before you'd just compare types
[17:39:49] *** Quits: bytbox (s@moz-75D4B5A8.wireless.umd.edu) (Ping timeout)
[17:40:05] <doomlord> right thats what i mean, is it better for compile times the current way
[17:40:28] <cmr> oh. a bit, probably. no data.
[17:40:40] <ski> Eridius,(cmr) : if you leave out type signatures on (some) functions, then a type checker could detect a typing mismatch in one place in the code, but the actual logical error (according to what the programmer intended, or ought to have intended) may be in another location
[17:40:41] <doomlord> the tim sweeney wishlist did say "full type inference doesn't scale for maintainability", in agreement with the current policy
[17:40:49] *** Joins: bnicholson (bnicholson@moz-BBE3ABD.mv.mozilla.com)
[17:41:13] *** Joins: infynyxx (infynyxx@DB780A29.749BA1D.DCC373F0.IP)
[17:41:15] <ski> adding type signatures can then help in telling the type checker what the expected types are in some places, so that it can narrow down where the real error came from
[17:41:25] *** Quits: jclements (jclements@moz-20AD2EFB.dsl.static.sonic.net) (Quit: jclements)
[17:43:13] <leonvv> What is an Option, which is returned by some methods in the stdlib?
[17:43:15] <cmr> IMO the current inference balance is very good, and changing it would be backwards compatible, so not really worth putting much effort into until later
[17:43:25] <cmr> leonvv: it is an enum
[17:43:32] <cmr> literally, enum Option<T> { None, Some(T) }
[17:43:32] <pcwalton> try reading the type inference code sometime if you want your brain to explode :)
[17:43:40] <pcwalton> I really wish we didn't have to have subtyping
[17:43:43] <cmr> That is, there is either nothing there, or something
[17:43:46] <pcwalton> we almost don't
[17:43:55] <ski> a type error slicer is a (possible) part of a type checker which determines all and only the exact places in the code which contribute to a type error (rather than just semi-randomly flagging one of them, the one where the mismatch was detected)
[17:44:16] *** Joins: mr_trousers (Mibbit@BBE7C46A.B4F11D08.8612FA94.IP)
[17:44:27] <leonvv> Why not just use a boolean?
[17:45:00] <engla> leonvv: it denotes both the presence of a value and carries the value
[17:45:21] <ski> at least one of the places found must be changes to fix the type error, and (assuming only these places contribute to the type error) either of them could be the place that has to be changed, for all the type error slicer can infer from the information given in the program
[17:45:25] <engla> leonvv: for example .pop_opt() on a vector. It will return Some(1) if 1 was the last value in the vec, or None if the vec is empty.
[17:45:37] <leonvv> That makes sense!
[17:45:38] <doomlord> whole program type inference would be hard for IDEs aswell i guess
[17:45:40] *** Quits: davbo (dave@moz-3FFA637C.oucs.ox.ac.uk) (Client exited)
[17:45:53] <cmr> doomlord: not so bad if they're tying into rustc, just run typeck
[17:46:07] <ski> an example of a type error slicer is "Skalpel: A Type Error Slicer for SML" at <http://www.macs.hw.ac.uk/ultra/skalpel/>
[17:46:36] *** Joins: Ralith (ralith@moz-71FF9C0.wireless.sfu.ca)
[17:46:52] <pcwalton> ski: sadly I suspect a lot of these algorithms are going to be harder because we have (limited) subtyping in Rust
[17:46:59] <ski> cmr : ok, ty
[17:46:59] <pcwalton> and our type inference is undecidable as a result
[17:47:21] <ski> pcwalton : subtyping for regions ?
[17:47:28] <pcwalton> ski: yeah
[17:47:47] <doomlord> ints in the type system is the other big one
[17:47:56] <pcwalton> well, that's not subtyping
[17:47:59] <pcwalton> that's just a typeclass basically
[17:48:12] *** Joins: dherman (dherman@moz-BBE3ABD.mv.mozilla.com)
[17:48:12] *** ChanServ sets mode: +o dherman
[17:48:15] <cmr> the only subtypable thing is bottom isn't it?
[17:48:25] <pcwalton> it's regions with &T
[17:48:37] <pcwalton> outer blocks are subtypes of inner blocks
[17:48:53] <bstrie> ski: if you don't want to explicitly type function signatures, use closures!
[17:48:53] *** Quits: fabiand (fabiand@moz-680BCD95.adsl.alicedsl.de) (Quit: Verlassend)
[17:48:57] * ski . o O ( "Retrospective Thoughts on BitC" by Jonathan S. Shapiro in 2012-03-23 at <http://lambda-the-ultimate.org/node/4490> )
[17:49:00] <pcwalton> and &'static is a subtype of everything
[17:49:32] *** Quits: brendanc (brendan@moz-CA4BEC19.cs.ubc.ca) (Ping timeout)
[17:50:04] *** Joins: fabiand (fabiand@moz-680BCD95.adsl.alicedsl.de)
[17:50:13] <engla> is there a bound on &fn that will require it to effectively have no environment? So it will be convertible to just a function pointer
[17:50:30] <pcwalton> one problem is that this subtyping makes us implement variance and so it has the invariant/covariant mutability thing and also contravariance on function signatures and blahhh
[17:50:36] <cmr> engla: isn't that `extern "Rust" fn`?
[17:51:01] <engla> well yes, but extern fn doesn't support closure syntax yet
[17:51:02] <bblum> engla: &fn:'static will enforce that, but it will not change the representation to just a function  pointer
[17:51:11] <engla> while &fn does
[17:51:15] <cmr> ah
[17:51:17] <engla> hm ok
[17:51:17] <cmr> right
[17:51:48] <doomlord> could it distinguish based on |x| vs fn(x) .. or does that mean something else
[17:52:10] <pcwalton> fn(x) hasn't existed for a year now I think :)
[17:52:13] <cmr> doomlord: function declarations aren't expressions afaik
[17:52:18] <doomlord> ok
[17:52:32] <bblum> leonvv: regarding Option, welcome to the wonderful world of algebraic datatypes -- Option<T> represents the same thing that a nullable pointer to a T would represent in unsafe languages like C++, 
[17:52:42] <engla> bblum: it does enforce that indeed
[17:52:54] <ski> leonvv : re "Why not just use a boolean?", "Boolean Blindness" at <http://existentialtype.wordpress.com/2011/03/15/boolean-blindness/> might perhaps be interesting
[17:53:08] <leonvv> Thanks all
[17:53:13] *** Joins: brendanc (brendan@moz-CA4BEC19.cs.ubc.ca)
[17:53:14] <leonvv> ski: Will look at that now
[17:54:06] *** Joins: tjc (tjc@moz-BBE3ABD.mv.mozilla.com)
[17:54:06] *** ChanServ sets mode: +o tjc
[17:54:08] <bblum> leonvv: but with Option<T> the compiler forces you to check both possibilities for the option when you use it, instead of just unsafely dereferencing it, which leads to null pointer bugs that every programmer has wasted time debugging at some point or another
[17:54:18] <bblum> ok, sorry, had to evangelize for a minute there :)
[17:54:32] *** Quits: bent (chatzilla@CB3EC984.A5F785DE.396E4C6D.IP) (Quit: ChatZilla 0.9.90-rdmsoft [XULRunner 18.0.2/20130201065344])
[17:54:48] <ski> pcwalton : *nod*, sounds messy
[17:56:42] *** Joins: jaen (jaen@moz-E0979827.copit.pl)
[17:56:49] <engla> cmr: with that in place you can assert! that the environment pointer is NULL when you transmute from &'static fn:'static  to extern fn ^^
[17:56:50] *** Joins: echristo (echristo@D423593A.D6CCE4AE.77834EAA.IP)
[17:56:52] *** Quits: lucian (lucian@6B2B4644.4304AE1E.CE5E78F6.IP) (Input/output error)
[17:57:39] <cmr> engla: can't you leave *out* the assert since the compiler does it for you?
[17:58:33] <engla> the assert is only there to catch changes in rust that invalidate the assumption that the transmute is valid
[17:58:40] <cmr> ah
[17:58:46] *** Joins: ecr (Thunderbir@moz-BBE3ABD.mv.mozilla.com)
[17:59:00] <leonvv> bblum: So if I get it correctly, instead of returning a nullable pointer, it would return None from Option?
[17:59:07] <doomlord> https://github.com/mozilla/rust/issues/7590  <<< this sort of thing is intended to work, its a bug not a design issue ? 
[17:59:13] *** Joins: eatkinson (eatkinson@moz-BBE3ABD.mv.mozilla.com)
[17:59:13] *** Quits: jedestep (jedestep@34641662.FB4DE631.66C78B76.IP) (Ping timeout)
[18:00:05] <engla> aside from the Index trait not working at all at the moment
[18:00:15] *** Quits: echristo (echristo@D423593A.D6CCE4AE.77834EAA.IP) (Ping timeout)
[18:00:24] <bblum> leonvv: exactly
[18:00:48] *** Quits: brendanc (brendan@moz-CA4BEC19.cs.ubc.ca) (Ping timeout)
[18:00:52] <bblum> well, a "none" is a null pointer; the type Option itself is a nullable pointer, as it were
[18:00:54] <engla> oy lots of pm spam
[18:01:23] <leonvv> bblum: Great, thanks again for your explanation :) 
[18:01:29] *** Joins: echristo (echristo@D423593A.D6CCE4AE.77834EAA.IP)
[18:02:16] *** Joins: jedestep (jedestep@34641662.FB4DE631.66C78B76.IP)
[18:02:26] *** Joins: MaikKlein (maik@moz-B9C8EE03.dip0.t-ipconnect.de)
[18:02:56] *** Quits: mcclurmc (mcclurmc@moz-FF454CE2.threembb.co.uk) (Ping timeout)
[18:03:44] *** Joins: sigma_android (androirc@moz-C60D8190.dab.02.net)
[18:04:13] *** Joins: brendanc (brendan@moz-CA4BEC19.cs.ubc.ca)
[18:04:26] <brendanc> hmm, large stacks didn't have any perceivable effect on buildbot build time
[18:04:49] *** Joins: doomlord_ (servitor@moz-13E69BC8.range86-180.btcentralplus.com)
[18:05:12] *** Joins: n00b6502 (kwr5y54@moz-13E69BC8.range86-180.btcentralplus.com)
[18:05:30] *** Joins: Efe (.@AAEEDD24.3EC76B6B.337157C8.IP)
[18:05:33] <MaikKlein> can I create a struct via macro? like gen_struct!("foo"); would expand to "struct foo";
[18:05:51] <cmr> MaikKlein: you don't need the quotes
[18:05:53] <kimundi> sure
[18:05:57] <leonvv> Does anyone know where "Some" is defined in the source? I would like to check out its properties
[18:06:00] <cmr> Macros can expand to any Rust code
[18:06:03] <Efe> insan warmý amk
[18:06:07] <bblum> leonvv: libstd/option.rs
[18:06:07] <bstrie> leonvv: src/libstd/option.rs
[18:06:10] <Cs> varda olm bunlar
[18:06:12] <bblum> bstrie: c.c
[18:06:14] <Cs> bizden deðil
[18:06:18] <Efe> Hiii
[18:06:18] <MaikKlein> could you give me an example how this macro would look like?
[18:06:27] *** Joins: erickt (erickt@8C9ECD8F.3A598286.F12515B4.IP)
[18:06:27] <Cs> saldýrak az
[18:06:32] *** Joins: jclements (jclements@moz-BBE3ABD.mv.mozilla.com)
[18:07:00] <bstrie> MaikKlein: macro_rules! gen_struct(($foo:ident) => (struct $foo));
[18:07:03] <bstrie> MaikKlein: something like that
[18:07:07] <Efe> 4bstrie Hello
[18:07:08] <leonvv> Thanks!
[18:07:12] <bstrie> Efe: hello
[18:07:19] <Efe> How are you
[18:07:20] *** Quits: brendanc (brendan@moz-CA4BEC19.cs.ubc.ca) (Ping timeout)
[18:07:21] <Efe> 4?
[18:07:34] <bstrie> Efe: doing well, how are you?
[18:07:40] <Efe> Fine4.
[18:07:42] *** Joins: buse_chatte (arkdax@moz-3CDE9A5A.static.twtelecom.net)
[18:07:42] *** Joins: diIaI (Zurnafinal@moz-53F8D8A9.hsd1.il.comcast.net)
[18:07:42] *** Joins: ataman (trSohbet@moz-49E1D549.hsd1.il.comcast.net)
[18:07:42] *** Joins: sekerGirl (mlRCPro@moz-47E4D054.hsd1.nj.comcast.net)
[18:07:42] *** Joins: bebek33 (esChat@moz-8165B072.sip.sdf.bellsouth.net)
[18:07:42] *** Joins: Bombakiz (Klavye.Org@moz-53F8D8A9.hsd1.il.comcast.net)
[18:07:42] *** Joins: Naciyye (trSohbet@moz-47E4D054.hsd1.nj.comcast.net)
[18:07:42] *** Joins: SeDa45 (mlRCPro@moz-49E1D549.hsd1.il.comcast.net)
[18:07:42] *** concrete.mozilla.org sets mode: +R 
[18:07:43] *** Quits: sekerGirl (mlRCPro@moz-47E4D054.hsd1.nj.comcast.net) (User has been banned from Mozilla (no spamming here))
[18:07:43] *** Quits: ataman (trSohbet@moz-49E1D549.hsd1.il.comcast.net) (User has been banned from Mozilla (no spamming here))
[18:07:43] *** Quits: Naciyye (trSohbet@moz-47E4D054.hsd1.nj.comcast.net) (User has been banned from Mozilla (no spamming here))
[18:07:43] *** Quits: SeDa45 (mlRCPro@moz-49E1D549.hsd1.il.comcast.net) (User has been banned from Mozilla (no spamming here))
[18:07:43] *** Quits: Bombakiz (Klavye.Org@moz-53F8D8A9.hsd1.il.comcast.net) (User has been banned from Mozilla (no spamming here))
[18:07:43] *** Quits: bebek33 (esChat@moz-8165B072.sip.sdf.bellsouth.net) (User has been banned from Mozilla (no spamming here))
[18:07:43] *** Quits: diIaI (Zurnafinal@moz-53F8D8A9.hsd1.il.comcast.net) (User has been banned from Mozilla (no spamming here))
[18:07:43] *** Quits: buse_chatte (arkdax@moz-3CDE9A5A.static.twtelecom.net) (User has been banned from Mozilla (no spamming here))
[18:07:46] <engla> new friends Efe and Cs talk just like the massive pm spam I got
[18:07:47] <bstrie> your text is very colorful
[18:08:07] <Efe> 4:)
[18:08:08] <Cs> Efe la
[18:08:09] *** Joins: lmandel (lmandel@F2D29657.F60B0462.67AC9B1.IP)
[18:08:11] <Cs> ilk okuldamý
[18:08:15] <Cs> oðrendin ingiliceyi
[18:08:16] <Efe> hea
[18:08:17] <Efe> 4:D
[18:08:19] <Efe> ßaska nerde
[18:08:21] <Efe> ogrencem
[18:08:22] <Efe> mk
[18:08:27] <Cs> belki turst
[18:08:30] <Cs> sýkcemeye gotdýnde 
[18:08:33] <Cs> oðrenmiþindir
[18:08:42] <Cs> :D
[18:08:51] <Cs> abi adamlar bakýyor bunlaer nediyo diye
[18:08:56] <Cs> yok boyle makara
[18:09:04] <thiez> could we stick to english please?
[18:09:07] *** Quits: erickt (erickt@8C9ECD8F.3A598286.F12515B4.IP) (Ping timeout)
[18:09:14] <Cs> ingilice konusun lütfen diyor
[18:09:16] <Efe> 4:DD
[18:09:20] <Cs> why
[18:09:27] * MaikKlein just realized how awesome macros are
[18:09:29] <MaikKlein> bstrie, thanks!
[18:09:39] <engla> cs, please stick to a non-made up language
[18:09:40] <jclements> MaikKlein: +1!
[18:09:52] <Eridius> well crud, local_data::local_data_get is now breaking for me as well. did that just change on master or something?
[18:09:53] <bblum> engla: all languages are made up
[18:10:00] <cmr> engla: that's turkish if google translate is correct
[18:10:01] <engla> I just don't approve of the method
[18:10:06] <cmr> Eridius: yes, the API changed
[18:10:12] <Eridius> sigh. bad timing
[18:10:17] <doomlord_> if i want to make a suggestion re struct constructors, where's the best place to put it
[18:10:19] <bstrie> bblum: no, I think lisp was "discovered"
[18:10:24] <engla> cmr: hm maybe, except turkish doesn't use icelandic alphabet or ÃŸ
[18:10:24] <bblum> bstrie: haha :P
[18:10:25] <Cs> I'm free to use their own zone engla
[18:10:26] <cmr> doomlord_: mailing list probably
[18:10:28] <Efe> Do you know the list of proxy ip
[18:10:33] <Efe> 4:D
[18:10:54] <Cs> sen nediyosun olm
[18:10:56] <glinscott> looking at the implementation of swap in libstd, is there a way to make this faster for primitive types w/o losing genericity?  https://github.com/glinscott/rust/blob/master/src/libstd/util.rs#L57
[18:11:03] <Efe> Proxy ip listesý ýstýorm
[18:11:04] <Efe> 4:D
[18:11:08] <Cs> olm
[18:11:11] <Efe> ßilýormsnýz dýom
[18:11:12] <engla> memmove can compile down to register moves
[18:11:12] <Efe> 4:D4:D
[18:11:12] <bblum> pcwalton: kick these guys please
[18:11:14] <Cs> amarikalý varsa onlarýnkini iste
[18:11:25] *** pcwalton sets mode: +b *!*@C929B15.A8EA7FF1.E9B01DC7.IP
[18:11:25] *** Cs was kicked by pcwalton (pcwalton)
[18:11:29] <cmr> glinscott: you can't provide concrete "implementations" of functions afaik
[18:11:31] <engla> seriously, I just got around 1000 pm spam in the same "language"
[18:11:31] *** pcwalton sets mode: +b *!*@AAEEDD24.3EC76B6B.337157C8.IP
[18:11:32] *** Efe was kicked by pcwalton (pcwalton)
[18:11:32] <Eridius> hmm so local_data now only provides its value to a closure?
[18:11:52] <bblum> thank you
[18:12:05] <glinscott> cmr/engla: ok, so maybe these should be memmove in copy_nonoverlapping_memory?
[18:12:20] <jclements> pcwalton: colloquy makes a very funny sound when someone gets booted. you should do that more often :)
[18:12:34] <cmr> copy_nonoverlapping_memory is a memmove I thought
[18:12:35] *** jclements was kicked by pcwalton (pcwalton)
[18:12:37] <cmr> the llvm intrinsic
[18:12:39] *** concrete.mozilla.org sets mode: -R 
[18:12:39] <cmr> pcwalton: heh
[18:13:01] <glinscott> cmr: https://github.com/glinscott/rust/blob/master/src/libstd/ptr.rs#L108
[18:13:26] <glinscott> memcpy32.  llvm doesn't seem to figure out that can be converted to a register move
[18:13:59] <thiez> glinscott: not even with -O ?
[18:14:11] <Eridius> hrm, local_data is different for stage0. So I still need my local data keys to be wrapped in @ for the time being?
[18:14:13] <cmr> engla: hm, ah you sure memmove compiles down to register moves?
[18:14:21] *** Joins: jclements (jclements@moz-BBE3ABD.mv.mozilla.com)
[18:14:24] <cmr> it can't be overlapping
[18:14:29] *** Joins: donri (dag@moz-9BB61102.tbcn.telia.com)
[18:14:33] <cmr> Eridius: or #[cfg(stage0)] it
[18:15:15] *** Joins: brendanc (brendan@moz-CA4BEC19.cs.ubc.ca)
[18:15:43] <glinscott> thiez: yup, it gets with with -O on.  but it makes the optimizer work hard to get it :)
[18:15:45] <Eridius> cmr: Well I could implement print_maybe_styled twice, but that's nasty. And a function that returns the Terminal would require copying it (as I have no lifetime to use to return a &Terminal)
[18:15:50] <thiez> perhaps we could do LLVM a favour and actually optimize the IR we output... :p
[18:16:00] <Eridius> so keeping the @ seems like the best solution for the time being
[18:16:32] <cmr> glinscott: we don't do *any* optimization without -O, at all.
[18:16:44] *** Quits: paulproteus (quassel@rose.makesad.us) (Ping timeout)
[18:17:05] <thiez> which is why it's *really* horrible without -O ^^
[18:17:08] *** Joins: paulproteus (quassel@moz-E86A3B42.makesad.us)
[18:17:08] <cmr> (besides alwaysinline I think?)
[18:17:19] <jedestep> i can see why -O is off by default though
[18:17:23] *** Joins: mschifer (Adium@moz-BBE3ABD.mv.mozilla.com)
[18:17:28] <jedestep> the compile time :(
[18:17:45] <glinscott> cmr: sure, i get that - but that being said, it would make llvm's life easier to not have to optimize those into register moves, when it's for int, or another primitive move
[18:19:12] <thiez> would be nice if we could special-case generic stufff
[18:19:51] <glinscott> not sure what the best way of doing that would be though.  maybe if copy_nonoverlapping was understood by the compiler as an intrinsic?  then it could just emit load/store
[18:20:20] *** Quits: froystig (froystig@4AB93A85.352137A1.BCED17D.IP) (Quit: leaving)
[18:20:21] *** Joins: froystig (froystig@4AB93A85.352137A1.BCED17D.IP)
[18:20:27] <glinscott> thiez: yes, but really, you'd want a specialization for primitive types
[18:20:30] <cmr> glinscott: emitting non-llvm intrinsic "intrinsics" is a surefire way to miss potential optimizations
[18:20:35] <thiez> fn swap<T: NotASmallThingy>(x: &mut T, y: &mut T) { current impl } fn swap<T: ASmallThingy>(x: &mut T, y: &mut T) { normal moves }
[18:20:51] <cmr> Anyway, it's going to have to work equally as hard for primitive types
[18:20:58] <cmr> the only thing with less work is the... monomorphizer?
[18:21:49] *** Quits: jclements (jclements@moz-BBE3ABD.mv.mozilla.com) (Quit: jclements)
[18:22:41] *** Joins: pyrac (pyrac@moz-F2C67F88.w83-114.abo.wanadoo.fr)
[18:23:02] *** Quits: MrFahrenheit (RageOfThou@3FEF494C.29C984D5.783DEDCA.IP) (Quit: Leaving)
[18:23:09] <glinscott> cmr: well, memmove for int copies is a bit overkill :).  clang just uses load/store for the same example
[18:23:19] <cmr> oh right
[18:23:32] <cmr> yeah, probably
[18:24:03] <kimundi> jedestep: Actually, emitting tons and tons of unoptimized IR makes the compiler slower then outputting short, optimized ir :P
[18:24:32] <thiez> ah yes, the optimized valgrind builds are faster than the unoptimized builds :D
[18:25:06] *** Quits: pcwalton (pcwalton@moz-7B0110AD.mv.mozilla.com) (Quit: .)
[18:25:32] <glinscott> cmr: i'm happy to take a peek, but not really sure where to start.  hm..  maybe if the compiler sees a memcpy intrinsic for a primitive type, it can do better
[18:25:33] *** Joins: pcwalton (pcwalton@moz-7B0110AD.mv.mozilla.com)
[18:25:33] *** ChanServ sets mode: +o pcwalton
[18:25:40] *** dherman is now known as dherman-lunch-at-the-goog
[18:26:07] <jedestep> kimundi: my rustsc was certainly slower with optimizations turned on
[18:26:09] <jedestep> rustc*
[18:26:54] *** Quits: untothebreach (paul@15A17709.47300931.30F15291.IP) (Quit: leaving)
[18:27:31] <Eridius> why is local_data::get parameterized with <T: 'static>. What does that bound mean in this context?
[18:27:44] <thiez> glinscott: that sounds nice, but I wonder how much of a difference it would make
[18:27:55] *** Joins: graydon (Adium@A5087023.2354C43D.D8E68FF6.IP)
[18:27:55] *** ChanServ sets mode: +qo graydon graydon
[18:27:59] *** Quits: mark_edward (quassel@moz-4A5B1251.wisolt4.epbfi.com) (Ping timeout)
[18:28:03] <cmr> probably little to none, and adding complexity to trans without cleanup is a bad idea
[18:28:08] <MaikKlein> does anyone see a syntax error in the macro? https://gist.github.com/MaikKlein/5986673
[18:28:24] <MaikKlein> it tells me 
[18:28:25] <MaikKlein> /home/maik/hello1.rs:3:4: 3:10 error: found `struct` in ident position
[18:28:27] <MaikKlein> /home/maik/hello1.rs:3     struct $foo {
[18:28:27] <MaikKlein>                            ^~~~~~
[18:28:28] <cmr> MaikKlein: macros can't expand to multiple items
[18:28:34] *** Joins: SiegeLord (sl@moz-CAF07B4C.hsd1.ma.comcast.net)
[18:28:37] <Eridius> I really wish `make` wouldn't pass absolute paths to rustc. That makes error messages much harder to read
[18:28:42] <bstrie> cmr: oyu have to wrap the entire thing in a module
[18:28:48] <bstrie> er, MaikKlein ^
[18:28:49] <cmr> bstrie: that's a single item
[18:29:14] *** Joins: carllerche (carllerche@moz-BF6CB667.hsd1.ca.comcast.net)
[18:29:17] *** Quits: engla (engla@moz-DBD1D96E.cust.bredbandsbolaget.se) (Ping timeout)
[18:29:24] <MaikKlein> so like pub mod bla { my code } ?
[18:29:33] *** Quits: brendan (brendaneic@moz-BBE3ABD.mv.mozilla.com) (Quit: brendan)
[18:29:44] <thiez> glinscott: if you want to hack on the compiler perhaps you could have a look at the order the glue is emitted?
[18:29:59] <thiez> rusti: let mut x = ~3; x = x; *x;
[18:30:01] -rusti- ()
[18:30:05] <cmr> whoa
[18:30:09] <thiez> eh, I thought that didn't work
[18:30:14] <cmr> it didn't this morning
[18:30:31] <glinscott> thiez: by itself, probably not much at all, but, it's one more thing that is easier for llvm :)
[18:30:35] *** Joins: bytbox (s@moz-DC83764A.washdc.fios.verizon.net)
[18:30:37] <glinscott> cmr: valid point, don't want to add too much complexity.  what is the cleanup you mean though?
[18:30:41] *** Joins: mark_edward (quassel@moz-4A5B1251.wisolt4.epbfi.com)
[18:30:48] <thiez> because trans is a bit of a mess :p
[18:31:10] <thiez> cleaning it up is more valuable than making the compiler marginally faster :)
[18:31:22] <MaikKlein> bstrie, like this? https://gist.github.com/MaikKlein/5986690
[18:31:41] <cmr> glinscott: basically the entire thing needs to be refactored/rewritten to output less IR
[18:31:57] <thiez> how is vector-ir these days?
[18:32:14] <thiez> does [0, ..1000] still generate a thousand individual moves? :D
[18:32:23] <glinscott> thiez: well, all software is a bit of a mess! :)  don't underestimate the power of small speedups though, perf. is an ongoing war
[18:32:24] *** Joins: james4k (james@moz-E7990244.consolidated.net)
[18:32:41] <cmr> glinscott: it's not a bit of a mess though
[18:32:48] <cmr> it's a huge pile of spaghetti
[18:32:49] <thiez> glinscott: I usually compile with --opt-level 3 so it wouldn't make a diff for me ;)
[18:33:17] <cmr> glinscott: doener often gets 10% speedups with a ~60 line patch
[18:33:22] <cmr> just by making us output less iR
[18:33:24] *** Joins: MrFahrenheit (RageOfThou@3FEF494C.29C984D5.783DEDCA.IP)
[18:33:24] <cmr> *IR
[18:33:41] <cmr> (rustc speedups, that is)
[18:33:49] <cmr> (which is what that optimization would be; less work for LLVM)
[18:33:51] <sully> pcwalton: hm, bors doesn't seem to have picked up your r+?
[18:34:10] <glinscott> cmr: well, a rewrite of the compiler is a bit out of scope for most folks :)
[18:34:35] <bblum> rewriting rustc can't be that hard
[18:34:40] *** Joins: ghrust (ghrust@C8693FCB.6A2AE50.F3114085.IP)
[18:34:40] <ghrust> 01[13rust01] 15bors merged 06auto into 06master: 02http://git.io/bAZ9qg
[18:34:40] *** Parts: ghrust (ghrust@C8693FCB.6A2AE50.F3114085.IP) ()
[18:35:17] <thiez> oh, did the large stacks on x64 just land?
[18:35:54] *** Quits: cowboyd (cowboyd@moz-1BD02A1E.sw.biz.rr.com) (Ping timeout)
[18:36:33] <cmr> glinscott: something that I think would be *very* useful is an AST visualization tool, to see what the various stages of rustc do, and to help compare AST->IR
[18:36:53] <pcwalton> sully: it bitrotted
[18:37:17] <sully> bors says it is still "Discussing"
[18:37:27] <pcwalton> hmm
[18:37:30] <pcwalton> well, I'm about to push an update
[18:37:32] <cmr> sully: bors is very bad at marking things stale
[18:37:32] <sully> and it still merged clean for me
[18:37:37] *** Joins: ghrust (ghrust@5FEF1C87.6A2AE50.F3114085.IP)
[18:37:37] <ghrust> 01[13rust01] 15bors pushed 0 new commits to 06auto: 02http://git.io/jvjXyg
[18:37:37] *** Parts: ghrust (ghrust@5FEF1C87.6A2AE50.F3114085.IP) ()
[18:37:38] *** Joins: ghrust (ghrust@9C8B94D4.6A2AE50.F3114085.IP)
[18:37:39] <ghrust> 01[13rust01] 15bors pushed 3 new commits to 06auto: 02http://git.io/hD5XAg
[18:37:39] <ghrust> 13rust/06auto 14b8e95c4 15Chris Morgan: Make Bitv::eq_vec take ~[bool] rather than ~[uint]...
[18:37:39] <ghrust> 13rust/06auto 145b656cf 15Chris Morgan: Replace owned with borrowed pointer....
[18:37:39] <ghrust> 13rust/06auto 145cc4e51 15bors: auto merge of #7730 : chris-morgan/rust/bitv-eq_vec-bool, r=cmr...
[18:37:41] *** Parts: ghrust (ghrust@9C8B94D4.6A2AE50.F3114085.IP) ()
[18:37:50] <cmr> but it does say it's mergable for me
[18:38:29] *** Joins: cowboyd (cowboyd@moz-1BD02A1E.sw.biz.rr.com)
[18:38:37] <sully> hm, actually
[18:38:57] <sully> how does bors decide what the last commit is
[18:39:12] <sully> because github orders them by timestamp (argh! argh! bad! wrong!)
[18:39:38] <sully> and the latest timestamped one isn't the last in the repo
[18:40:14] <sully> the head for that branch is 3fa5203, but the last displayed is 186f6fa
[18:40:25] <sully> so does the r+ need to be on 3fa5203, instead?
[18:41:17] <bblum> bors decides by parent
[18:41:39] <bblum> sully: i complained to github about that; they gave me a form response and a link to a FAQ page on why they decided to do it that way (which is totally bogus)
[18:41:47] <sully> grrrrrrrrum.
[18:41:52] <bblum> if you do it too
[18:41:56] <bblum> maybe more people will make them listen
[18:42:09] <sully> pcwalton: could you comment on 3fa5203?
[18:42:18] *** Quits: sigma_android (androirc@moz-C60D8190.dab.02.net) (Ping timeout)
[18:42:23] <bblum> sully: you can just say r=pcwalton
[18:42:24] <bblum> yourself
[18:42:58] <bblum> https://help.github.com/articles/why-are-my-commits-in-the-wrong-order this is really stupid; i want to punch whoever wrote this
[18:43:06] <bblum> "we recommend not using git rebase" assholes
[18:43:14] *** Quits: cowboyd (cowboyd@moz-1BD02A1E.sw.biz.rr.com) (Ping timeout)
[18:43:19] <bblum> sorry, i probably shouldn't be so inflammatory in this channel
[18:43:24] *** Quits: olleharstedt (Thunderbir@moz-80D8890F.ias.bredband.telia.com) (Ping timeout)
[18:43:37] *** Quits: barosl (barosl@E287D94F.C81E10FB.7544CABF.IP) (Quit: ëžœë¤ì€ ì‡ í‡´í–ˆìŠµë‹ˆë‹¤.)
[18:43:53] <Yoric> bblum: Yeah, go to #firefox for trolling :)
[18:43:54] *** Joins: brendan (brendaneic@moz-BBE3ABD.mv.mozilla.com)
[18:44:01] <bblum> this isn't really trolling
[18:44:25] <Yoric> No, just aggressive phrasing.
[18:44:33] <bblum> yeah
[18:45:11] *** Joins: barosl (barosl@E287D94F.C81E10FB.7544CABF.IP)
[18:46:03] <Eridius> cmr: I just fixed the build failure on https://github.com/mozilla/rust/pull/7716
[18:46:42] <cmr> Eridius: for all stages?
[18:46:49] <Eridius> yeah, I left the type of my key the same
[18:46:55] <Eridius> since it already is wrapped in @, that works in stage0
[18:47:04] <Eridius> same reason rand's task_rng didn't change either
[18:47:10] <Eridius> a complete `make` works on my system
[18:47:41] *** Joins: int3_ (int3_@moz-ABE52D50.hsd1.ca.comcast.net)
[18:48:09] *** Joins: nano (nano@moz-972880B.superkabel.de)
[18:51:57] <MaikKlein> hm was there a change to the mod system?
[18:52:06] <MaikKlein> or why doesn't this work? https://gist.github.com/MaikKlein/5986817
[18:52:53] <MaikKlein> oh
[18:53:00] <MaikKlein> it is private by default
[18:53:02] *** Quits: eschweic (Adium@moz-BBE3ABD.mv.mozilla.com) (Quit: Leaving.)
[18:53:10] <Eridius> pub struct Bar;
[18:53:36] <cmr> Hm
[18:53:50] <cmr> I wonder why that doesn't get caught by the "found a Bar in Foo but it was private" error
[18:54:29] <jedestep> I've had problems with visibility checks as well
[18:54:56] <jedestep> sometimes methods which do not have a declared visibility will cause a linker error when they're not found
[18:56:28] <nmatsakis> jedestep: this might be because the system used to implement privacy by excluding information from the linker and name resolution tables,
[18:56:30] <MaikKlein> doe default methods work in different modules?
[18:56:34] <nmatsakis> jedestep: though we've been changing that
[18:56:42] <cmr> MaikKlein: *modules*? yes, they should
[18:57:02] *** Quits: _Vi (vi@527C345F.497AA854.B16B3BE6.IP) (Ping timeout)
[18:57:26] *** Joins: krdln (Mibbit@moz-6F8A8560.dynamic.chello.pl)
[18:58:24] <MaikKlein> cmr, https://gist.github.com/MaikKlein/5986850
[18:59:02] <cmr> MaikKlein: trait isn't in scope
[18:59:06] *** Quits: int3_ (int3_@moz-ABE52D50.hsd1.ca.comcast.net) (Client exited)
[19:00:14] <MaikKlein> hm
[19:00:19] *** Quits: leonvv (leonvv@moz-7D83A5F1.ip.telfort.nl) (Client exited)
[19:04:48] *** Quits: Ralith (ralith@moz-71FF9C0.wireless.sfu.ca) (Ping timeout)
[19:05:08] *** Quits: eatkinson (eatkinson@moz-BBE3ABD.mv.mozilla.com) (Quit: eatkinson)
[19:06:25] *** Quits: MaikKlein (maik@moz-B9C8EE03.dip0.t-ipconnect.de) (Ping timeout)
[19:07:39] *** Quits: BizarreCake (BizarreCak@moz-361FE9B2.dynamic.barak-online.net) (Ping timeout)
[19:07:56] *** Joins: erickt (erickt@8C9ECD8F.3A598286.F12515B4.IP)
[19:09:55] *** Quits: pnathan (Adium@B9840254.2CD8A5F8.477B877D.IP) (Quit: Leaving.)
[19:13:15] *** Quits: erickt (erickt@8C9ECD8F.3A598286.F12515B4.IP) (Ping timeout)
[19:13:15] <sully> https://github.com/mozilla/rust/issues/6656 has this happened to anyone else? getting an intermittent error page on rust-lang.org?
[19:13:44] <cmr> sully: it was widely reported for a few days around that time..
[19:14:02] <cmr> I think it was an S3 misconfiguration or something?
[19:14:04] <cmr> not sure
[19:14:08] <cmr> probably safe to close
[19:15:01] *** Quits: carllerche (carllerche@moz-BF6CB667.hsd1.ca.comcast.net) (Quit: carllerche)
[19:15:27] *** Quits: mark_edward (quassel@moz-4A5B1251.wisolt4.epbfi.com) (Ping timeout)
[19:16:54] *** Quits: brendan (brendaneic@moz-BBE3ABD.mv.mozilla.com) (Quit: brendan)
[19:18:13] *** Joins: MaikKlein (maik@moz-B9C8EE03.dip0.t-ipconnect.de)
[19:19:33] *** Quits: Kruppe (user@moz-EE1E894A.home3.cgocable.net) (Ping timeout)
[19:21:41] *** Joins: mark_edward (quassel@moz-4A5B1251.wisolt4.epbfi.com)
[19:22:05] *** Joins: mcclurmc (mcclurmc@moz-8D61EFD1.cable.virginmedia.com)
[19:22:25] *** Parts: judder (maradukewa@5B9E91E7.2C8A8E2E.78E362FE.IP) ()
[19:22:25] *** Joins: carllerche (carllerche@moz-BF6CB667.hsd1.ca.comcast.net)
[19:22:52] <cmr> https://github.com/cmr/rustdoc_ng/pull/1
[19:22:55] <cmr> jedestep: you are a hero <3
[19:23:05] *** Joins: eschweic (Adium@moz-BBE3ABD.mv.mozilla.com)
[19:23:10] <cmr> that was a very silly error :(
[19:23:13] <jedestep> :) I hope it's right, it worked for me
[19:23:24] <jedestep> it's ok, a second pair of eyes really helps a ton
[19:23:34] <jedestep> this happens to me all the time
[19:23:34] *** Joins: eschweic1 (Adium@moz-BBE3ABD.mv.mozilla.com)
[19:23:39] *** Quits: eschweic (Adium@moz-BBE3ABD.mv.mozilla.com) (Connection reset by peer)
[19:24:48] <cmr> jedestep: Do you want me to open a bunch of issues on the repo of various workitems? all I have right now is basically a todo list in my head :p
[19:25:17] <jedestep> cmr: sure, I'll do what I can
[19:25:26] <cmr> alright, I'll do that when I'm done triage
[19:25:34] *** Quits: MaikKlein (maik@moz-B9C8EE03.dip0.t-ipconnect.de) (Ping timeout)
[19:25:46] *** Joins: cowboyd (cowboyd@moz-5476415B.sw.biz.rr.com)
[19:25:59] *** Quits: lmandel (lmandel@F2D29657.F60B0462.67AC9B1.IP) (Quit: lmandel)
[19:27:12] <cmr> graydon: jack and I both got https://github.com/mozilla/rust/issues/3902 this week.
[19:27:27] *** Quits: dherman-lunch-at-the-goog (dherman@moz-BBE3ABD.mv.mozilla.com) (Quit: dherman-lunch-at-the-goog)
[19:28:48] *** Quits: eschweic1 (Adium@moz-BBE3ABD.mv.mozilla.com) (Ping timeout)
[19:29:14] <bstrie> cmr: maybe we're out of bugs! are there less than 19 left?
[19:29:29] <cmr> I'd certainly hope not
[19:29:37] <cmr> otherwise I'd have a lot more conflicts within my set of 100
[19:29:46] <bstrie> you're insane
[19:29:49] <cmr> (singlehandedly doing half the triage: bamf)
[19:30:00] <cmr> bstrie: you mean I have no life :p
[19:30:35] *** Joins: brendan (brendaneic@moz-BBE3ABD.mv.mozilla.com)
[19:31:19] <bstrie> cmr: are you in college? if so, you should make an effort at a life, even if rust suffers :P
[19:31:24] <cmr> bstrie: not yet!
[19:31:36] <bstrie> ah right, it's summertime
[19:31:42] <bstrie> once out of college you lose track of seasons
[19:31:52] <bstrie> let my story be a warning
[19:31:57] <bstrie> work in an office that has windows!!
[19:32:00] <cmr> heh
[19:32:21] <jedestep> at my school, CS majors specifically requested a lab with no windows. so they can't see the passage of time outside
[19:32:28] <cmr> heh
[19:32:45] <cmr> I can't stand artificial lighting ;(
[19:32:59] *** Quits: nano (nano@moz-972880B.superkabel.de) (Connection reset by peer)
[19:33:03] <bstrie> at some point in the year the radio starts playing christmas music. that's how I know that years have passed
[19:33:51] <bstrie> oh btw is anyone up for RUSTCON OUTSKIRTS-OF-PHILADELPHIA '012 this weekend
[19:34:02] <cmr> it's 2013
[19:34:12] <bstrie> just roll with it
[19:34:18] <jedestep> rustcon feat. time travel
[19:37:03] *** Quits: SiegeLord (sl@moz-CAF07B4C.hsd1.ma.comcast.net) (Quit: It's a joke, it's all a joke.)
[19:37:19] <sp3d> feat 1969 Rust band
[19:38:24] *** Quits: SimonSapin (simon@88F51059.F3BBB17D.144F44FA.IP) (Ping timeout)
[19:40:02] <bstrie> let i32x4(e2, _, _, _) = v * v + v - v;
[19:40:06] <bstrie> ^ how does this even work
[19:40:10] <bstrie> like, wha
[19:40:27] <bstrie> i dont understan
[19:42:20] <thiez> that works?
[19:42:39] <thiez> rusti: let v = 0; let i32x4(e2, _, _, _) = v * v + v - v;
[19:42:39] <ecr> rusti: let i32x4(e2, _, _, _) = 2 * 2 + 2 - 2;
[19:42:40] -rusti- <anon>:7:24: 7:29 error: unresolved enum variant, struct or const
[19:42:40] -rusti- <anon>:7          let v = 0; let i32x4(e2, _, _, _) = v * v + v - v;
[19:42:40] -rusti-                                  ^~~~~
[19:42:40] -rusti- error: aborting due to previous error
[19:42:41] -rusti- application terminated with error code 101
[19:42:41] -rusti- <anon>:7:13: 7:18 error: unresolved enum variant, struct or const
[19:42:41] -rusti- <anon>:7          let i32x4(e2, _, _, _) = 2 * 2 + 2 - 2;
[19:42:43] -rusti-                       ^~~~~
[19:42:45] -rusti- error: aborting due to previous error
[19:42:45] *** concrete.mozilla.org sets mode: +M 
[19:42:46] *** Joins: seth (seth@moz-42C5FAA8.nc.res.rr.com)
[19:42:47] -rusti- application terminated with error code 101
[19:43:04] <thiez> I guess it doesn't work.
[19:43:14] <cmr> or rusti is out of date
[19:43:17] <bstrie> thiez: it's from the test suite
[19:43:18] <bstrie> https://github.com/mozilla/rust/blob/master/src/test/run-pass/simd-binop.rs
[19:43:43] <thiez> oh, then it suddenly makes sense :)
[19:43:47] <cmr> https://github.com/mozilla/rust/blob/master/src/libstd/unstable/simd.rs#L22
[19:43:50] <bstrie> not to me!
[19:43:57] <cmr> bstrie: tuple struct!
[19:44:10] <bstrie> cmr: what does that even mean?!
[19:44:16] <cmr> bstrie: tuple struct?
[19:44:20] <cmr> it's basically a named tuple
[19:44:24] <bstrie> wait
[19:44:25] *** Quits: reyre (reyre@F2D29657.F60B0462.67AC9B1.IP) (Client exited)
[19:44:26] <bstrie> so you're saying
[19:44:29] <bstrie> that isn't a function call
[19:44:35] <cmr> well it is, sorta
[19:44:38] *** Quits: krdln (Mibbit@moz-6F8A8560.dynamic.chello.pl) (Quit: http://www.mibbit.com ajax IRC Client)
[19:44:43] <cmr> unit struct constructors are implemented as function call
[19:44:48] <cmr> erm, tuple struct
[19:44:57] <cmr> but yeah basically that's what I'm saying
[19:44:57] <bstrie> so we have function calls as lvalues?
[19:44:58] <thiez> rusti: use std::unstable::simd::*; i32x4(0,0,0,0) // rusti is up to date :)
[19:44:59] -rusti- {__field__: 0, __field__: 0, __field__: 0, __field__: 0}
[19:45:20] <thiez> it's not a function call, it's a typed tuple of sorts
[19:45:26] <kmc> it's pattern matching
[19:45:32] *** Joins: tikue (tkuehn@moz-BBE3ABD.mv.mozilla.com)
[19:45:49] *** Quits: FrozenCow (FrozenCow@moz-B2DF4929.chello.nl) (Connection reset by peer)
[19:45:54] <cmr> bstrie: it's just like constructing an enum variant
[19:46:07] <cmr> (literally; it's 98% the same code in trans)
[19:46:24] <bstrie> cmr: can you say `let Some(2) = foo;` ?
[19:47:17] <tikue> bstrie: isn't Some(2) an rval
[19:47:25] <bstrie> that's what I'm asking
[19:47:33] <cmr> wait what
[19:47:36] <cmr> what the hell is that doing
[19:47:38] <cmr> oh wait
[19:47:44] <bstrie> how about `let Some(foo) = bar;` ?
[19:47:47] <cmr> bstrie: no, literals aren't allowed in patterns
[19:47:49] *** concrete.mozilla.org sets mode: -M 
[19:47:49] <cmr> that, yes.
[19:48:00] <bstrie> mind blown
[19:48:03] <bstrie> what does that even do
[19:48:05] <tikue> cmr: what?!!
[19:48:22] <bstrie> rusti: let bar = Some(2); let Some(foo) = bar; foo
[19:48:23] -rusti- <anon>:7:32: 7:41 error: refutable pattern in local binding
[19:48:23] -rusti- <anon>:7          let bar = Some(2); let Some(foo) = bar; foo
[19:48:23] -rusti-                                          ^~~~~~~~~
[19:48:23] -rusti- error: aborting due to previous error
[19:48:23] -rusti- application terminated with error code 101
[19:48:28] <cmr> rusti: let  v: Option<int> = Some(2; let Some(foo) = v; foo
[19:48:32] -rusti- <anon>:8:4: 8:5 error: incorrect close delimiter: `}`
[19:48:34] -rusti- <anon>:8     };
[19:48:34] <cmr> rusti: let  v: Option<int> = Some(2); let Some(foo) = v; foo
[19:48:36] -rusti-              ^
[19:48:38] -rusti- application terminated with error code 101
[19:48:39] <bstrie> ok, so it's refutable
[19:48:39] -rusti- <anon>:7:44: 7:53 error: refutable pattern in local binding
[19:48:41] -rusti- <anon>:7          let  v: Option<int> = Some(2); let Some(foo) = v; foo
[19:48:43] -rusti-                                                      ^~~~~~~~~
[19:48:44] <shachaf> bstrie: No, because foo might be None.
[19:48:45] -rusti- error: aborting due to previous error
[19:48:47] -rusti- application terminated with error code 101
[19:48:55] *** Quits: mark_edward (quassel@moz-4A5B1251.wisolt4.epbfi.com) (Ping timeout)
[19:48:56] <cmr> I think it's only refutable because it's an enum and not  a tuple struct though
[19:49:12] <bstrie> I don't like that name
[19:49:17] <cmr> neither do I
[19:49:17] <shachaf> Yes, it would be fine if there was only one variant.
[19:49:34] <shachaf> "irrefutable pattern" means something very different from what it does in Haskell...
[19:49:35] *** Quits: pyrac (pyrac@moz-F2C67F88.w83-114.abo.wanadoo.fr) (Quit: pyrac)
[19:49:35] <cmr> https://github.com/mozilla/rust/issues/7288
[19:49:58] <bstrie> rusti: enum { Foo(int) } let foo = Foo(2); let Foo(bar) = foo; bar
[19:49:59] -rusti- <anon>:7:14: 7:15 error: expected ident, found `{`
[19:49:59] -rusti- <anon>:7          enum { Foo(int) } let foo = Foo(2); let Foo(bar) = foo; bar
[19:49:59] -rusti-                        ^
[19:49:59] -rusti- application terminated with error code 101
[19:50:01] <smvv_> `named tuple', like in python?
[19:50:08] <bstrie> rusti: enum Qux { Foo(int) } let foo = Foo(2); let Foo(bar) = foo; bar
[19:50:08] <thiez> struct Tup(int); let foo = Tup(8); let Tup(bar) = foo; bar
[19:50:08] -rusti- 2
[19:50:22] <cmr> rusti: struct Foo(int); let x = Foo(4); let Foo(foo) = x; foo
[19:50:23] -rusti- 4
[19:50:25] <bblum> refutable pattern is a fine name
[19:50:53] <bstrie> to clarify, I don't like the name tuple struct
[19:51:01] <bstrie> refutable vs irrefutable is ok
[19:51:02] <cmr> to clarify, neither do I
[19:51:07] <bblum> newtype struct is a better name
[19:51:19] <thiez> why? it's a tuple of sorts
[19:51:35] <cmr> it's a named tuple
[19:51:38] <cmr> that's literally what it is
[19:51:41] <bblum> shachaf: what are you talking about? it means the same thing
[19:51:43] <cmr> you take a tuple, and give it a name
[19:51:55] *** Joins: jgilbert (jgilbert@moz-BBE3ABD.mv.mozilla.com)
[19:52:04] <thiez> not truly
[19:52:29] *** Joins: reyre (reyre@F2D29657.F60B0462.67AC9B1.IP)
[19:52:33] <cmr> (also it's a newtype for that tuple)
[19:53:05] <thiez> rusti: struct Tup(int); fn acceptTup(t: Tup)->int{ let Tup(x) = t; x } acceptTup( (8) )
[19:53:06] -rusti- <anon>:7:84: 7:89 error: mismatched types: expected `main::Tup` but found `<VI0>` (expected struct main::Tup but found integral variable)
[19:53:06] -rusti- <anon>:7          struct Tup(int); fn acceptTup(t: Tup)->int{ let Tup(x) = t; x } acceptTup( (8) )
[19:53:07] -rusti-                                                                                              ^~~~~
[19:53:10] -rusti- error: aborting due to previous error
[19:53:12] -rusti- application terminated with error code 101
[19:53:28] <thiez> rusti: struct Tup(int); fn acceptTup(t: Tup)->int{ let Tup(x) = t; x } acceptTup( Tup(8) ) // but this one works :)
[19:53:29] -rusti- 8
[19:54:27] *** Joins: bent (chatzilla@86E64821.D11AB332.CE55B2D2.IP)
[19:54:48] <thiez> I think I'll port rustray to SIMD
[19:54:53] <thiez> might be fun.
[19:54:55] <cmr> thiez: you construct things with a name, with their named constructor
[19:55:23] <thiez> is our simd actually operational, or is it just the datatypes at this point?
[19:55:23] <cmr> 'tuples' are really 'anonymous tuple structs' :p
[19:55:25] <shachaf> bblum: Hmm, I suppose you're right, actually. It's just that things are a bit different with a strict language.
[19:55:31] <cmr> thiez: supposedly operational
[19:55:40] <cmr> https://github.com/mozilla/rust/pull/7705
[19:55:43] <thiez> good, let's give them a nice workout
[19:55:53] *** Joins: mark_edward (quassel@moz-4A5B1251.wisolt4.epbfi.com)
[19:56:39] <bstrie> rusti: let âˆš2 = 1; âˆš2
[19:56:40] -rusti- <anon>:7:13: 7:13 error: unknown start of token: 8730
[19:56:40] -rusti- <anon>:7          let âˆš2 = 1; âˆš2
[19:56:40] -rusti-                       ^
[19:56:40] -rusti- application terminated with error code 101
[19:57:30] *** Joins: LU324 (stuff@moz-A17E9A7B.dyn.embarqhsd.net)
[19:58:13] <kmc> bblum, shachaf: the big difference is that Haskell has the pattern operator ~, which makes any pattern irrefutable
[19:58:30] <bblum> kmc: what does that do...? o_O
[19:58:38] *** Quits: bent (chatzilla@86E64821.D11AB332.CE55B2D2.IP) (Ping timeout)
[19:58:50] <tjc> bblum: it's like "match check" was in Rust
[19:59:01] <bblum> that's not really "forcing it to be irrefutable"
[19:59:04] <cmr> so runtime check?
[19:59:07] <bblum> that's like
[19:59:09] <tjc> Yeah, runtime check
[19:59:09] <ski> bblum : delay matching until the value of variable(s) bound by it are required
[19:59:16] <kmc> the pattern always matches; if any of the bound variables are later forced, the pattern match happens and throws a runtime error if failure
[19:59:16] *** Quits: hjr3 (hradtke@1A0AE795.28A5F6C3.A2D40ED2.IP) (Quit: My MacBook has gone to sleep. ZZZzzzâ€¦)
[19:59:17] <doomlord_> simd, yum!!
[19:59:18] <cmr> isn't that the very essense of a refutable pattern?
[19:59:26] <bblum> ok, that's not really irrefutable
[19:59:31] <bblum> that's the same as it is in SML
[19:59:35] <bblum> which has "raise Match"
[20:00:28] <doomlord_> is there anything like intrinsics , orwill the compiler rely on recognizing patterns of basic operators to generate things like dot-product instructions 
[20:00:31] <kmc> in Haskell you need it sometimes even for things with only one constructor
[20:00:33] <shachaf> kmc: Right, I was thinking of that.
[20:00:46] <doomlord_> (sometime the can have different precision fused)
[20:00:48] <shachaf> E.g. the pattern (x, y) is refutable, because âŠ¥.
[20:01:02] <cmr> doomlord_: intrinsics will be available aiui afaik
[20:01:09] *** Joins: hjr3 (hradtke@1A0AE795.28A5F6C3.A2D40ED2.IP)
[20:01:13] <cmr> erm
[20:01:16] <cmr> cut off one of those
[20:01:19] <cmr> doesn't matter which :p
[20:01:25] <kmc> e.g. fix (let f ~(x,y) = (..., ...) in f)
[20:01:26] <ski> (.. because `âŠ¥' is distinct from `(âŠ¥,âŠ¥)')
[20:01:38] <kmc> oh hey ski is here *waves*
[20:01:48] <ski> hi kmc
[20:02:09] *** Joins: bent (chatzilla@86E64821.D11AB332.CE55B2D2.IP)
[20:02:24] <bblum> ok wait, so, if you supply undefined to the pattern (x,y), you will get a Prelude.undefined error
[20:02:31] <bblum> how is that different with ~?
[20:02:43] <kmc> it's different because the error is put off until you force one of x or y
[20:02:45] <shachaf> let f ~(x,y) = () in f undefined is ()
[20:02:48] <shachaf> let f (x,y) = () in f undefined is undefined
[20:02:51] <cmr> graydon: and https://github.com/mozilla/rust/issues/4573
[20:03:20] *** Joins: eschweic (Adium@moz-BBE3ABD.mv.mozilla.com)
[20:03:22] <kmc> bblum: the 'fix' I gave above needs the ~ or else it will loop forever trying to produce a (,) constructor rather than producing things in x and y
[20:03:25] <thiez> cmr: for very permissive values of 'operational' it seems :p
[20:03:36] *** Joins: eatkinson (eatkinson@moz-BBE3ABD.mv.mozilla.com)
[20:03:50] *** Quits: cowboyd (cowboyd@moz-5476415B.sw.biz.rr.com) (Client exited)
[20:03:51] *** Quits: eschweic (Adium@moz-BBE3ABD.mv.mozilla.com) (Connection reset by peer)
[20:03:52] *** Joins: eschweic (Adium@moz-BBE3ABD.mv.mozilla.com)
[20:03:56] <thiez> just changing vec3 to #[simd] causes the program to crash
[20:03:57] <ski> bblum : the difference appears in recursive knots .. also there's performance differences when e.g. traversing long lists, incrementally computing a tuple result
[20:04:25] <thiez> index out of bounds xD
[20:04:29] <cmr> jensnockert: ^^^^
[20:04:40] <cmr> jensnockert: do you know about how simd actually works/needs to be used?
[20:04:40] <ski> (and what shachaf said, in case you don't force any variable bound by the pattern)
[20:04:58] <kmc> anyway in a strict language you could have this pattern operator too but it probably defeats the purpose of distinguishing refutable from irrefutable patterns in the first place
[20:05:06] *** Joins: cowboyd (cowboyd@moz-5476415B.sw.biz.rr.com)
[20:05:12] <shachaf> Sometimes people specifically call ~-patterns irrefutable -- even the Report does in one place -- which I suppose is what mixed me up.
[20:05:15] <kmc> it would just be a way to tell the compiler "shut up, I don't want to handle None here"
[20:05:28] <kmc> which seems bad for Rust, and anyway you can write a function for it if you really want to
[20:05:31] <kmc> shachaf: yeah
[20:05:33] <shachaf> Anyway the only irrefutable patterns in Haskell are @-patterns, ~-patterns, variables, and newtype matches.
[20:05:44] <kmc> and _
[20:05:45] <ski> (hm, i suppose the performance differences turn into difference between termination and nontermination, when handling (potentially) infinite lists/streams)
[20:05:56] <kmc> presumably an @-pattern is refutable iff the rhs is
[20:06:02] <shachaf> Right.
[20:06:16] *** Joins: Ralith (ralith@moz-50F3C77.vc.shawcable.net)
[20:06:24] <shachaf> I guess _ isn't a variable.
[20:06:29] <kmc> nope
[20:06:43] *** Quits: fabiand (fabiand@moz-680BCD95.adsl.alicedsl.de) (Quit: Verlassend)
[20:06:47] <kmc> I wish Haskell had or-patterns, like Rust (and SML?)
[20:07:28] <nmatsakis> Rust does not have or patterns, actually. It's just that an arm can have multiple patterns.
[20:07:29] <ski> kmc : OCaml, and SML/NJ
[20:07:43] <nmatsakis> e.g., Some(a|b) doesn't work
[20:07:53] <nmatsakis> Some(a) | Some(b) is ok tho
[20:08:29] <bblum> huh.
[20:08:54] <bblum> i guess Some(a|b) could be convenient in some cases ("in Some cases")
[20:09:03] <cmr> hurr hurr
[20:09:09] <shachaf> Newtype matches being irrefutable has to do with why newtype existentials aren't allowed, I think.
[20:09:14] <shachaf> But that's off-topic here. :-)
[20:09:20] <bblum> but it doesn't really grant extra magic code deduplication powers on top of what Some(a) | Some(b) already gives us
[20:09:32] <bblum> it only lets you dedup your patterns
[20:09:33] <doomlord_> would rust be likely to get either default parameters or haskell style partial application .. ( i think the former is more useful for  APIs like opengl ) .. the python thing of being able to have defaults anywhere would be nice as a step over c++
[20:09:35] <nmatsakis> just more convenient sometimes
[20:09:35] <bblum> as opposed to your logic
[20:09:53] <cmr> doomlord_: I would very much like default parameters
[20:09:53] <nmatsakis> doomlord_: I'd say defaults are more likely than currying
[20:09:53] *** Quits: bent (chatzilla@86E64821.D11AB332.CE55B2D2.IP) (Ping timeout)
[20:09:55] *** Quits: lerc (quassel@moz-598ED764.telstraclear.net) (Connection reset by peer)
[20:10:11] <cmr> I don't think they're out of reach either.. entirelly backwards compatible, just function call sugar.
[20:10:12] *** Joins: pnathan (Adium@B9840254.2CD8A5F8.477B877D.IP)
[20:10:12] <bblum> doomlord_, to curry in rust you have to write it out manually, e.g. |y| f(x,y)
[20:10:14] <kmc> nmatsakis: ah, interesting; is there a specific reason for that?
[20:10:21] <bblum> doomlord_: but it's the rare case where simply doing that isn't sufficient
[20:10:24] *** Quits: victorporof (victorporo@74A9C5E8.1745F5FA.9B1E38F4.IP) (Quit: victorporof)
[20:10:30] <bblum> we have plenty of places where we curry by hand like that
[20:10:45] <shachaf> Currying isn't the same thing as partial application. :-(
[20:10:57] <kmc> Boost has a terrifying library for keyword args with defaults in C++...
[20:11:00] <bblum> shachaf: huh?
[20:11:01] *** Quits: ssbr (ssbr@moz-141F89C6.block0.gvtc.com) (Ping timeout)
[20:11:01] <doomlord_> yeah as soon as you curry and compose you might as well write a lambda
[20:11:12] <kmc> right if your functions are all curried then there's no "partial" application
[20:11:17] <bblum> oh
[20:11:27] <bblum> well, sure
[20:11:29] <shachaf> Currying is e.g. turning a function :: (a,b) -> c to a function :: a -> b -> c
[20:11:31] <doomlord_> curry/partial .. whats the precise term,
[20:11:32] <bblum> you can't write "f(x,)"
[20:11:33] *** Joins: SimonSapin (simon@moz-D0C2F181.zone2.bethere.co.uk)
[20:11:37] <bblum> and have that be a function that takes y
[20:11:40] <bblum> but that's just syntax sugar
[20:11:46] <shachaf> Partial application is something like what you wrote.
[20:12:00] <nmatsakis> shachaf: so far as I know, what Haskell offers is currying, which is why I said currying. Am I mistaken?
[20:12:06] *** Joins: erickt (erickt@8C9ECD8F.3A598286.F12515B4.IP)
[20:12:13] *** Joins: strcat (strcat@moz-54F7FD49.cpe.net.cable.rogers.com)
[20:12:32] <doomlord_> currying alongside overloading would start to get really messy
[20:12:47] <nmatsakis> oh, I see the distinction you are making.
[20:13:47] <bblum> do you mean, like... currying is about definition-site, and partial app is about call-site?
[20:14:10] *** Quits: SimonSapin (simon@moz-D0C2F181.zone2.bethere.co.uk) (Ping timeout)
[20:14:21] <ecr> I would say that partial application is just syntactic sugar for making curried functions behave like uncurried functions.
[20:14:30] *** Quits: bnicholson (bnicholson@moz-BBE3ABD.mv.mozilla.com) (Quit: Ex-Chat)
[20:14:48] <strcat> rusti: let xs = [1, 2, 3, 4, 5]; let mut it = xs.iter(); println(fmt!("%?", it.next())); for it.invert().advance |x| { println(x.to_str()) }
[20:14:49] -rusti- more than 5 lines of output, pastebinned: http://sprunge.us/LcEW
[20:14:52] *** Quits: erickt (erickt@8C9ECD8F.3A598286.F12515B4.IP) (Ping timeout)
[20:15:05] <strcat> ugh, silly out of scope traits
[20:15:09] * strcat always forgets
[20:15:20] <shachaf> bblum: Currying is just a transformation of a function.
[20:15:49] <bblum> sure
[20:15:53] <bblum> in that case, i mean, to curry in rust you have to return a heap closure
[20:16:02] <bblum> which is often disadvantageous if you can instead create a stack closure at call-site
[20:16:05] <shachaf> Right.
[20:16:09] <nmatsakis> kmc: in answer to your question, my opinion is that currying is...occasionally useful, but leads to obscure type errors most of the time (i.e., you usually want to supply the full set of arguments). I am basically satisfied with our closures for this purpose, and I suspect the rest of the team shares this opinion (though I don't claim to speak for them)
[20:16:20] *** Quits: pnathan (Adium@B9840254.2CD8A5F8.477B877D.IP) (Ping timeout)
[20:16:27] <shachaf> So it's unlikely that people will actually do much currying.
[20:16:31] <bblum> shachaf: right.
[20:16:39] <bblum> partial application is the preferred idiom
[20:16:45] <bblum> because it makes more sense with our memory model
[20:17:02] <shachaf> Partial application is a concept that almost doesn't exist in Haskell, since there are only 1-argument functions. Though ddarius gave a nice definition for it once.
[20:17:13] *** Joins: pnathan (Adium@B9840254.2CD8A5F8.477B877D.IP)
[20:17:15] * strcat still kind of wants a syntax like "foo(1, _)"
[20:17:22] <nmatsakis> I wouldn't mind that,
[20:17:35] <cmr> strcat: what would that do?
[20:17:35] <nmatsakis> though when I tried to add it, it was hard to find the right boundary,
[20:17:40] <shachaf> strcat: Where does the lambda go?
[20:17:45] <shachaf> Right.
[20:17:50] <strcat> shachaf: it's the same as using ||
[20:17:53] <nmatsakis> and there were concerns about it being unclear what was evaluated when
[20:17:56] <strcat> you'd need a type hint to get ~fn or @fn
[20:17:58] <ski> (partial application with labelled arguments as in OCaml <http://caml.inria.fr/pub/docs/manual-ocaml-4.00/manual006.html#toc35> can be useful)
[20:18:02] <nmatsakis> Scala has a syntax like that and I always found it nice
[20:18:10] <bblum> patrick has just pointed out that we used to have syntax sugar for partial-app, "f(expr1, _, _, expr4)" for example
[20:18:11] <shachaf> strcat: I'm not sure what you mean.
[20:18:22] <nmatsakis> it wasn't syntactic sugar,
[20:18:25] <bblum> but we took it out because it was confusing whether expr1 and expr4 get evaluated at creation time or call time
[20:18:25] <shachaf> strcat: When I write foo(1, bar(2, _)), what does that get turned into?
[20:18:27] <nmatsakis> it had a distinct semantics
[20:18:28] <nmatsakis> bblum: ^
[20:18:36] *** Joins: jclements (jclements@moz-BBE3ABD.mv.mozilla.com)
[20:18:44] <bblum> nmatsakis: anything... special? or was it just another case that did basically the same thing
[20:18:48] <doomlord_> pythons mix of default and named params is intersting
[20:18:54] *** Quits: barosl (barosl@E287D94F.C81E10FB.7544CABF.IP) (Quit: ëžœë¤ì€ ì‡ í‡´í–ˆìŠµë‹ˆë‹¤.)
[20:18:55] <thiez> oh amazing, 'make' removes the conflicting old library files these days?
[20:18:58] *** Quits: Yurume (yurume@AC58A8CE.8A059B47.E313B915.IP) (Ping timeout)
[20:19:00] <strcat> shachaf: the same as foo(1, |x| bar(2, x))
[20:19:03] <cmr> thiez: thank acrichto for that
[20:19:04] <nmatsakis> bblum: in particular, f(expr1, _, expr4) was equivalent to { let x = expr1; let y = expr4; |z| f(x, z, y) }
[20:19:05] <cmr> wait
[20:19:07] <cmr> no
[20:19:09] <cmr> pnkfelix
[20:19:16] <nmatsakis> bblum: in other words, the evaluation of the arguments was "eager"
[20:19:20] <strcat> shachaf: closures default to stack closures, but will become ~fn/@fn from type inference
[20:19:27] <strcat> it'd be the same, just sugar for it
[20:19:29] <thiez> I think I will when he gets back here :)
[20:19:31] <kmc> nmatsakis: and is there a specific reason for the lack of first-class or-patterns?
[20:19:41] <shachaf> strcat: OK, then it's only for one function call, not for an expression.
[20:19:46] <sully> oof, I just found a brutal cross crate default methods bug
[20:19:52] *** Joins: _Vi (vi@527C345F.497AA854.B16B3BE6.IP)
[20:19:59] <nmatsakis> kmc: I don't know, just to make things simpler for us poor compiler hackers I guess
[20:20:07] <strcat> shachaf: hm?
[20:20:13] <sully> I am happy that I found it by thinking about xc and not by somebody actually tripping it
[20:20:19] <strcat> let f = |x, y| foo(1, x, y);
[20:20:19] <sully> because it would probably have taken like a day to track down
[20:20:22] <strcat> would be equivalent to
[20:20:26] <strcat> let f = foo(1, _, _);
[20:20:31] <bblum> nmatsakis: right, sure
[20:20:39] <doy> strcat: there's ambiguity whether it should be foo(1, |x| bar(2, x)) or |x| foo(1, bar(2, x))
[20:20:58] <shachaf> strcat: E.g. there's no meaning to "1 + _", and no way to write "|x| foo(1, bar(2, x))".
[20:21:08] <shachaf> hi doy
[20:21:12] <strcat> shachaf: right, it's just sugar for a common case
[20:21:23] <strcat> doy: well it'd always be the first
[20:21:24] *** Joins: bnicholson (bnicholson@moz-BBE3ABD.mv.mozilla.com)
[20:21:37] <doy> right, that's just something i run into all the time in scala
[20:21:38] <shachaf> OK, then that seems like too much of special case to me.
[20:21:53] <doy> it makes sense when you think about it, but you end up writing the wrong thing quite a lot if you don't
[20:21:53] * strcat shrugs
[20:22:18] <strcat> I don't really care about it strongly enough to champion it ;)
[20:22:22] <doy> (:
[20:23:06] <strcat> on the other hand... I really want to be able to specify partial type hints
[20:24:11] <cmr> Whoa
[20:24:13] <cmr> foo.rs:2:21: 2:22 error: int literal is too large
[20:24:15] <cmr> when was that added?
[20:24:23] <cmr> rusti: let x: int = 100000000000000000000
[20:24:24] -rusti- <anon>:7:20: 7:21 error: int literal is too large
[20:24:24] -rusti- <anon>:7          let x: int = 100000000000000000000
[20:24:24] -rusti-                              ^
[20:24:24] -rusti- application terminated with error code 101
[20:24:28] <strcat> iter.collect::<HashSet<Foo<int, uint>>]>() -> iter.collect::<HashSet<_>>()
[20:24:32] * strcat dreams
[20:24:33] <cmr> rusti: let x: int = -1;
[20:24:35] -rusti- <anon>:7:13: 7:14 warning: unused variable: `x` [-W unused-variable (default)]
[20:24:35] -rusti- <anon>:7          let x: int = -1;
[20:24:35] -rusti-                       ^
[20:24:35] -rusti- ()
[20:24:52] <strcat> rusti: let x = 5; x = 5; x
[20:24:54] -rusti- more than 5 lines of output, pastebinned: http://sprunge.us/dAQN
[20:25:04] <strcat> rusti: let mut x = 5; x = 5; x
[20:25:05] -rusti- <anon>:7:17: 7:18 warning: value assigned to `x` is never read [-W dead-assignment (default)]
[20:25:05] -rusti- <anon>:7          let mut x = 5; x = 5; x
[20:25:05] -rusti-                           ^
[20:25:05] -rusti- 5
[20:25:44] <strcat> rusti: use std::iterator::*; let xs = [1, 2, 3, 4, 5]; let mut it = xs.iter(); println(fmt!("%?", it.next())); for it.invert().advance |x| { println(x.to_str()) }
[20:25:46] -rusti- more than 5 lines of output, pastebinned: http://sprunge.us/dcMG
[20:26:36] *** Joins: ssbr (ssbr@moz-141F89C6.block0.gvtc.com)
[20:27:07] *** Joins: SimonSapin (simon@moz-D0C2F181.zone2.bethere.co.uk)
[20:27:26] *** Joins: marijn (user@moz-BB01ACFA.dip0.t-ipconnect.de)
[20:28:19] <jensnockert> cmr: Yes, I know.
[20:28:38] <cmr> jensnockert: can you share with thiez? :p
[20:28:55] <jensnockert> cmr: You cannot index / get a field from a #[simd] right now.
[20:29:07] <jensnockert> thiez: Sorry, pinging you too.
[20:29:16] <jensnockert> thiez: You can destructure them using match.
[20:29:29] <thiez> jensnockert: ah, that might explain
[20:29:58] <jensnockert> The compiler is slightly buggy with them, because it believes they are structures.
[20:30:01] <thiez> I'm rewriting a 3d-math file now and I think I can do that without indexing :)
[20:30:07] <marijn> do I understand correclty that it is not allowed to have multiple methods with the same name on a type? (even when implementing different interfaces that happen to contain identically-named methods)
[20:31:12] <strcat> marijn: it's okay if the trait impls are in different crates
[20:31:28] <strcat> marijn: because you can bring the one you want into scope
[20:31:33] *** Joins: ghrust (ghrust@AD60B2E3.6A2AE50.F3114085.IP)
[20:31:33] <ghrust> 01[13rust01] 15bors merged 06auto into 06master: 02http://git.io/hD5XAg
[20:31:33] *** Parts: ghrust (ghrust@AD60B2E3.6A2AE50.F3114085.IP) ()
[20:31:35] <strcat> not ideal though :)
[20:31:41] <nmatsakis> strcat: huh? I think you mean modules?
[20:31:42] <marijn> strcat: crates, or modules?
[20:31:42] <pcwalton> err
[20:31:53] <nmatsakis> strcat: and I think you can bring them into scope locally...
[20:31:54] <pcwalton> it should be possible to have multiple methods with the same name on a type when implement different interfaces
[20:31:57] <strcat> nmatsakis: right, modules
[20:32:00] <pcwalton> I don't know why you wouldn't
[20:32:04] <nmatsakis> marijn: there are some limitations when calling,
[20:32:14] <pcwalton> the uniform method call syntax should fix the remaining limitations
[20:32:18] <marijn> i thought with the consistency rules you no longer had to import modules to use methods defined in them?
[20:32:20] <nmatsakis> marijn: some of which are bugs, but... yes, what pcwalton said
[20:32:27] <nmatsakis> marijn: you have to import the *trait*
[20:32:28] <pcwalton> not for traits
[20:32:29] <bstrie> oh hi marijn :)
[20:32:37] <strcat> marijn: we have a bunch of traits imported in the prelude
[20:32:45] <strcat> that's why for the stdlib it's not entirely that way
[20:32:52] <marijn> pcwalton: right, trait, not interface ;) okay, so only 'trait-less' methods are available by default?
[20:34:32] *** Joins: ghrust (ghrust@DE823A67.6A2AE50.F3114085.IP)
[20:34:32] <ghrust> 01[13rust01] 15bors pushed 0 new commits to 06auto: 02http://git.io/3K0Tig
[20:34:32] *** Parts: ghrust (ghrust@DE823A67.6A2AE50.F3114085.IP) ()
[20:34:34] *** Joins: ghrust (ghrust@24260B07.6A2AE50.F3114085.IP)
[20:34:34] <ghrust> 01[13rust01] 15bors pushed 4 new commits to 06auto: 02http://git.io/sjsviw
[20:34:34] <ghrust> 13rust/06auto 142b96408 15Daniel Micay: extend the iterator tutorial...
[20:34:34] <ghrust> 13rust/06auto 141ec06e0 15Alex Crichton: Remove the global 'vec::to_owned' function
[20:34:34] <ghrust> 13rust/06auto 149b21bf4 15Alex Crichton: Account for possible 0-sized elements in vector iterators...
[20:34:36] *** Parts: ghrust (ghrust@24260B07.6A2AE50.F3114085.IP) ()
[20:35:24] <jasom_> stupid question, how do I unbox a value (e.g. I have &u8 and I want a u8)
[20:35:30] <nmatsakis> jasom_: *x
[20:35:39] <jasom_> of course
[20:36:02] <strcat> or with a pattern, sometimes more convenient
[20:36:03] <bstrie> marijn: we do have methods provided by traits in the prelude, but right now we have problems with method resolution on generic types so e.g. we have .take() on Option and .take_() on iterators
[20:36:16] <strcat> rusti: let x = &5; let &y = x; y
[20:36:17] -rusti- 5
[20:36:28] <strcat> in closure params, that's nice
[20:36:37] *** Joins: fabiand (fabiand@moz-680BCD95.adsl.alicedsl.de)
[20:36:56] *** Quits: brendan (brendaneic@moz-BBE3ABD.mv.mozilla.com) (Quit: brendan)
[20:37:14] *** Joins: barosl (barosl@E287D94F.C81E10FB.7544CABF.IP)
[20:37:58] <marijn> bstrie: but what I'm curious about are the scoping rules for methods (ideally, ignoring compiler bugs). can you call trait-less methods without importing anything?
[20:38:09] *** Joins: pyrac (pyrac@moz-F2C67F88.w83-114.abo.wanadoo.fr)
[20:39:26] <bstrie> I'm honestly not sure :) always been fuzzy on those rules
[20:40:13] <nmatsakis> marijn: Yes.
[20:40:24] <nmatsakis> marijn: Trait-less methods are associated with the type, no import necessary.
[20:40:29] <bblum> can we generated uniquely named symbols with macros?
[20:40:42] <bblum> https://github.com/mozilla/rust/issues/7748
[20:40:46] <nmatsakis> marijn: Trait methods are associated with the trait. You must import the trait.
[20:40:50] *** Quits: fabiand (fabiand@moz-680BCD95.adsl.alicedsl.de) (Quit: Verlassend)
[20:40:54] <bstrie> bblum: is that hygiene?
[20:41:11] <nmatsakis> jclements: ^
[20:41:20] * nmatsakis would answer but is afraid of being wrong :)
[20:41:25] <bblum> i think so
[20:41:36] <nmatsakis> I think hygiene would essentially do that for you
[20:41:45] <nmatsakis> is my layman's understanding
[20:41:48] <bblum> good, that would be brilliant
[20:41:50] <bstrie> bblum: https://github.com/mozilla/rust/pull/7745 ?
[20:42:03] *** Quits: echristo (echristo@D423593A.D6CCE4AE.77834EAA.IP) (Quit: echristo)
[20:42:06] <graydon> hmm
[20:42:49] *** Joins: echristo (echristo@D423593A.D6CCE4AE.77834EAA.IP)
[20:44:03] <graydon> marijn: the change was that impls don't have names and don't need to be imported. traits do, and if you haven't imported a trait you can't see it. but you can't have a disagreement about type<->trait implementation anymore. you can only have at most 1 of those per pair.
[20:44:04] <marijn> nmatsakis: thanks. that's a nice compromise
[20:45:10] <brendanc> strcat: btw I ran across this http://msdn.microsoft.com/en-us/library/windows/desktop/ms686774%28v=vs.85%29.aspx?ppud=4 it seems windows can distinguish between reserved address space and committed memory (and even committed memory is faulted in lazily)
[20:45:26] <graydon> I have run into method name collisions a couple times already, but not a ton
[20:45:44] <cmr> graydon: strcat hit them a ton with iterators
[20:45:49] <graydon> yeah
[20:46:26] <graydon> I wonder what I should do about perf ratchets
[20:46:55] <bstrie> graydon: make them automatically decay on a regular basis! 1% perf wins per month or bust
[20:46:58] <jclements> bblum: sorry, afk.  Yes. With hygienic macro, *every* binding name introduced in a macro is unique.  Two caveats: 1) this currently applies only to "let" bindings, though it shouldn't be hard to extend this. 2) if you want to cheat, it's easy to write a syntax extension that paws through the expanded code to evilly extract the identifier and do bad things with it.
[20:47:04] <graydon> one possibility: turn them on by default (run --bench with a ratchet) as part of the normal unit testsuite, so you don't regress.
[20:47:29] <graydon> another: make it a separate target you have to run to get measured. your patches will bounce off bors more often, but make check locally might finish sooner.
[20:47:29] <bblum> jclements: good, let bindings is all i need in this case. how would caveat 2 work, out of curiosity?
[20:47:38] *** Quits: jensnockert (jensnocker@moz-C5F27039.cust.bredband2.com) (Input/output error)
[20:47:47] <brendanc> don't want a spurious perf increase to block the fix that reverts it either :)
[20:48:05] <graydon> if I make it part of the normal 'make check' run, we'll need to make the ratchet percentage pretty high to tolerate noise on the test bots
[20:48:14] <graydon> --bench can only compensate for so much  noise
[20:48:48] <bblum> since we removed "alt check", we should probably remove "make check" too
[20:48:52] <cmr> graydon: I don't think an automated ratchet is the right thing atm.. but ship the metric data to dbaupp :p
[20:48:58] <brendanc> probably want to collect some data and see how noisy it is before deciding on the clamps
[20:49:11] <cmr> right
[20:49:27] <graydon> well, there's one that's quite deterministic, the codegen metrics
[20:49:32] <jclements> bblum: a syntax extension -- well, a syntax extension could just remove the check, for one thing. More hygiene-related, it can also pull apart its arguments and extract the macro-generated identifiers.  
[20:49:40] <cmr> graydon: that'd be a good one to turn on
[20:49:41] <graydon> those are "clang LLVM IR instructions / rustc IR instructions"
[20:49:50] <graydon> cmr: as part of 'make check'?
[20:50:05] <bblum> oh, a syntax extension, as in, not just a normal macro
[20:50:07] <cmr> graydon: yeah
[20:50:08] <graydon> I guess we can turn more of these on one by one
[20:50:13] <jclements> bblum: correct.
[20:50:20] *** Joins: devinus (devinus@DAEC7122.372FE49C.29F95E0F.IP)
[20:50:45] <graydon> maybe a configure flag to turn on / off perf checking as part of 'make check'
[20:50:49] <graydon> so it can stick in your workspace
[20:51:02] <cmr> graydon: with like `r+ perf-ok` to allow it to be turned off..
[20:51:08] <graydon> you don't want to forget it
[20:51:11] <tjc> graydon: r? https://github.com/mozilla/rust/pull/7749
[20:51:13] <graydon> yeah, maybe
[20:51:58] *** Joins: fabiand (fabiand@moz-680BCD95.adsl.alicedsl.de)
[20:52:00] *** Joins: vk (chatzilla@3E9D68F2.B1163E0C.2A6693DD.IP)
[20:52:21] <cmr> graydon: Blei and I both got https://github.com/mozilla/rust/issues/4865
[20:53:00] *** Quits: sankha93 (Instantbir@2BA23283.A06F18D1.EFB84E89.IP) (Quit: He will be back!)
[20:53:01] *** Joins: siege (siege@moz-CAF07B4C.hsd1.ma.comcast.net)
[20:53:29] <graydon> cmr: not sure what to say. possibly github is not being very precise about its pagination of the result set. I'll try .. sketching a variant that uniquifies the bugs returned before proceeding
[20:53:50] <cmr> graydon: just pointing out that it's not all smoke and hearsay :p
[20:54:11] <graydon> sure sure! I .. think I've seen it myself, just .. the algorithm's real simple
[20:54:21] <cmr> yeah
[20:54:22] <graydon> it gets the bugs, puts them in an array, shuffles the array, then pops bugs off assigning them to people
[20:54:33] <graydon> there's not much room for duplicates in there. I guess I need to uniquify the array first.
[20:55:15] *** Quits: Earnestly (earnest@2AB30F53.FB5005.2BCC804A.IP) (Ping timeout)
[20:55:53] *** Quits: spider-mario (spidermari@moz-81131DB6.fbx.proxad.net) (Input/output error)
[20:56:09] *** Quits: pczarn (Mibbit@moz-69A55FA.izacom.pl) (Quit: http://www.mibbit.com ajax IRC Client)
[20:56:11] *** Joins: Earnestly (earnest@2AB30F53.FB5005.2BCC804A.IP)
[20:57:46] *** Quits: bnicholson (bnicholson@moz-BBE3ABD.mv.mozilla.com) (Quit: Ex-Chat)
[20:57:56] *** Joins: bnicholson_ (bnicholson@moz-BBE3ABD.mv.mozilla.com)
[20:58:25] <bstrie> graydon: python has a built-in Set type that will uniquify for you
[20:59:15] <graydon> bstrie: I know :)
[20:59:21] <graydon> it's not _quite_ that easy here, but close
[20:59:44] *** Quits: azita (Azita@moz-C1FB2A8.hsd1.ca.comcast.net) (Quit: azita)
[21:01:22] <cmr> It's weird triaging my own bugs
[21:01:28] <cmr> feels like it hasn't been that long
[21:01:50] *** Quits: Azdle (Azdle@moz-B334B496.hfc.comcastbusiness.net) (Quit: Leaving)
[21:03:23] *** Joins: RageOfThou (RageOfThou@3FEF494C.29C984D5.783DEDCA.IP)
[21:03:45] *** Quits: MrFahrenheit (RageOfThou@3FEF494C.29C984D5.783DEDCA.IP) (Ping timeout)
[21:04:05] * tjc triages every triager who does not triage themself
[21:04:40] *** Quits: seth (seth@moz-42C5FAA8.nc.res.rr.com) (Input/output error)
[21:05:08] <bstrie> the metatriager
[21:05:10] <bblum> ??? deriving iterbytes doesn't work in libstd?
[21:05:36] <graydon> cmr: what's weird is I cannot reproduce the phenomenon at all
[21:05:45] <graydon> cmr: like, it never gives me dupes no matter how often I run it here
[21:05:54] <cmr> graydon: that is really weird :\
[21:06:13] <doener> is there a reason for bool being i8 instead of i1?
[21:06:20] <cmr> llvm has i1?
[21:06:29] <cmr> What is _Bool in clang?
[21:06:54] <doomlord> i think i8's are more likely to pack into memory with good size-speed tradeoff
[21:07:06] <doener> cmr: currently e.g. while conditions are converted from i1 to i8 and back again
[21:07:44] <doener> cmr: icmp gives us an i1 which is converted to rust bool (i8) and then icmp'd against 0 to get an i1 again that we can use in the conditional branch
[21:08:00] <doomlord> as in load/store bytes (which can happen independantly), vs bit-extraction/insertion .. that might be why compilers make them i8 in datastructures 
[21:08:17] *** Joins: jensnockert (jensnocker@moz-C5F27039.cust.bredband2.com)
[21:08:18] <doomlord> ... or does it.. is it just c standard
[21:08:24] *** Joins: daniel-kun (daniel-kun@moz-75090EF.dip0.t-ipconnect.de)
[21:08:59] <cmr> we should probably do whatever it is clang does with c99 _Bool
[21:09:02] <doomlord> if you want to update a bool in mem - if its an i8, a cpu can store that. but if its a bit.. it has to read-modify-write
[21:09:47] <jack> what is the current way to find test data for unit tests relative to the crate or source files, etc?
[21:09:55] *** Quits: slaren (slaren@moz-EBC5E112.red-79-147-85.dynamicip.rima-tde.net) (Ping timeout)
[21:10:46] <doener> cmr: _Bool is i8, but clang doesn't do the round trip in while conditions
[21:11:42] <Ralith> doener: does the optimizer really not fold a truncated extended i1?
[21:11:47] <Ralith> the LLVM optimizer, that is
[21:12:15] <doener> Ralith: I'm looking at the pre-optimization IR
[21:12:17] <Ralith> oh
[21:12:38] <Ralith> does it really matter if rust generates some trivially optimized redundancies?
[21:12:53] <cmr> Ralith: yes
[21:13:09] <jclements> are weâ€¦ the biggest channel at mozilla?
[21:13:11] *** Quits: roo (jesse@moz-9A53149A.ip.windstream.net) (Quit: Leaving)
[21:13:11] <cmr> it's the result of crappy code in trans, and makes compilation slow
[21:13:17] <graydon> cmr: are you sure you didn't get the assignments in different weeks?
[21:13:21] *** Quits: eschweic (Adium@moz-BBE3ABD.mv.mozilla.com) (Quit: Leaving.)
[21:13:29] <graydon> cmr: as in, one assigned one week, the other the next (and possibly due to not being visited)?
[21:13:32] *** Joins: erickt (erickt@8C9ECD8F.3A598286.F12515B4.IP)
[21:13:35] <cmr> graydon: no, actually...
[21:13:38] <doener> Ralith: a) IR becomes easier to read, b) better compile times (to some degree), c) the unoptimized integration builds are currently slower than the valgrind ones
[21:13:41] <graydon> jclements: surely not. #developers is huge
[21:13:56] <Ralith> oh geez
[21:14:06] <thiez> jensnockert: do the simd types have any operators besides +, -, *, and / ?
[21:14:17] <jclements> graydon: ah! there it is. It's not on the list of "commonly used mozilla IRC channels".
[21:14:23] <doener> Ralith: especially c) makes pre-opt IR improvements worthwhile atm
[21:14:23] <jensnockert> thiez: I don't think that is merged yet.
[21:14:34] *** Joins: eschweic (Adium@moz-BBE3ABD.mv.mozilla.com)
[21:14:37] <thiez> jensnockert: but they're in the queue somewhere? :)
[21:14:48] <jensnockert> thiez: There is a PR for it.
[21:14:56] <cmr> jensnockert: sanxiyn's arithmetic patch landed, if that's what you mean.
[21:14:59] *** Joins: eschweic1 (Adium@moz-BBE3ABD.mv.mozilla.com)
[21:14:59] *** Quits: eschweic (Adium@moz-BBE3ABD.mv.mozilla.com) (Connection reset by peer)
[21:15:05] <graydon> doener: have you seen the codegen compiletest I added? I'm doing a bit more on it today..
[21:15:07] <jensnockert> Oh, it did, then they should work.
[21:15:08] <graydon> thought you might be interested
[21:15:28] <thiez> I was asking for operators besides those I mentioned :p
[21:16:08] <jensnockert> thiez: But if you're benchmarking, make sure to do it with -O, because they are <n * t>* instead of <n * t> right now.
[21:16:20] *** Quits: erickt (erickt@8C9ECD8F.3A598286.F12515B4.IP) (Ping timeout)
[21:16:23] <jensnockert> (And no function calls etc.)
[21:16:35] <doener> graydon: not yet, holiday's over, so my rust time is rather limited during the week
[21:16:48] <thiez> I'm almost ready for a benchmark :)
[21:16:57] *** Quits: reyre (reyre@F2D29657.F60B0462.67AC9B1.IP) (Client exited)
[21:16:59] *** Joins: slaren (slaren@moz-3DE99314.red-95-120-34.dynamicip.rima-tde.net)
[21:17:14] <strcat> Ralith: doener: well our bools are wrong
[21:17:20] <strcat> because of us using i8
[21:17:22] <thiez> I was just hoping I could write some things nicer, but so far it is disappointing :)
[21:17:32] <thiez> I wish I could shift values around ^^
[21:17:32] <strcat> as in they are unsound
[21:17:44] <strcat> we should really be doing bools properly like clang
[21:17:48] *** Quits: eevee (eevee@moz-58058235.evrt.wa.frontiernet.net) (Ping timeout)
[21:17:59] <Ralith> strcat: I'm confused. Clang uses i8, no?
[21:18:08] <strcat> Ralith: it *stores* them as i9
[21:18:10] <strcat> i8 *
[21:18:10] <cmr> Ralith: we have non-canonical bools
[21:18:13] <doener> Ralith: we're not doing casts to bool properly
[21:18:16] <Ralith> ah.
[21:18:20] <cmr> rusti: let x = 5 as bool; (x, x == true)
[21:18:24] -rusti- (true, false)
[21:18:27] <strcat> Ralith: as soon as it loads a bool, it truncates to i1
[21:18:28] <Ralith> ahh.
[21:18:32] <strcat> and it stores them by extending to i8
[21:18:37] <strcat> it passes them as i1 zeroext
[21:18:54] <strcat> and that's what the range asserts on loads are good for - they make loading a no-op
[21:19:24] <strcat> assuming you're doing it properly and truncating that is
[21:19:39] *** Quits: slaren (slaren@moz-3DE99314.red-95-120-34.dynamicip.rima-tde.net) (Ping timeout)
[21:20:16] *** Quits: msingle (Thunderbir@moz-930E5D97.hr.hr.cox.net) (Quit: msingle)
[21:20:53] <graydon> shall I always run and save benchmark numbers? they are pretty harmless and someone might enjoy graphing them (and it will keep those loops building and passing)
[21:21:04] <graydon> (and just ratchet them on some hosts, say a quiet perf host)
[21:21:13] <cmr> graydon: yes, please do
[21:21:18] <cmr> would be good data for irfy
[21:21:23] <graydon> yeah, ok
[21:21:40] *** Quits: dan_johnsin (dan_johnsi@6902762D.11B071D.FB9A45AF.IP) (Client exited)
[21:22:31] <cmr> bstrie: triaging 100 bugs only takes 2 hours
[21:22:50] <bblum> oh crap i still have this week's triage to do
[21:23:19] <bblum> graydon: i liked seeing the benchmark graphs on the old rustbot; i would like to have it back
[21:23:25] *** Quits: siege (siege@moz-CAF07B4C.hsd1.ma.comcast.net) (Quit: Leaving)
[21:24:08] <graydon> bblum: these are the #[bench] things I'm talking about, not the perf/ testsuite
[21:24:22] <graydon> but I will try to get the latter into a more useful reporting format as well, sometime
[21:24:22] <bblum> oh, well, ideally we could have both?
[21:24:32] <cmr> bblum: https://github.com/mozilla/rust/issues/7532
[21:24:35] <graydon> the latter is somewhat more work and not work I've been doing, but  I'll try.
[21:24:43] <bblum> no pressure or anything
[21:24:47] <tjc> What is the secret location where the expected types for intrinsics live?
[21:24:51] *** Quits: tikue (tkuehn@moz-BBE3ABD.mv.mozilla.com) (Quit: tikue)
[21:24:59] *** Joins: lkuper (lkuper@moz-C0CD33ED.hsd1.in.comcast.net)
[21:25:21] <Ralith> tjc: .td files
[21:25:23] <tjc> never mind, found it
[21:25:25] <jensnockert> tjc: typecheck/check.mod ?
[21:25:33] <tjc> jensnockert: Yep, that's the one I was looking for
[21:25:38] <Ralith> oh, rust intrinsics >_>
[21:25:51] *** Quits: cr (anonymous@moz-57073FC6.dip0.t-ipconnect.de) (Ping timeout)
[21:25:52] *** Joins: eevee (eevee@moz-58058235.evrt.wa.frontiernet.net)
[21:25:55] * jensnockert currently hates that file, no idea what is failing :(
[21:26:25] <graydon> bblum: the old graphs used perf(1), linux-only, measured hardware counters, didn't do microbenchmarks, didn't aim for statistical stability, and reported their results pretty awkwardly
[21:26:44] *** Quits: lkuper (lkuper@moz-C0CD33ED.hsd1.in.comcast.net) (Ping timeout)
[21:26:59] <graydon> bblum: the #[bench] ones are a lot more portable and mechanically comparable, so I'm focusing on them for now
[21:27:09] <graydon> even though they're time-based, arguably much worse than hardware counters
[21:27:18] *** Joins: slaren (slaren@moz-C41F155E.red-95-120-43.dynamicip.rima-tde.net)
[21:27:29] <graydon> there's not a real great API for access to hardware counters from in-process. or if there is, I don't know it (I would love if someone knows of one!)
[21:27:35] <cmr> that could easily be changed by the #[bench] runner though, right?
[21:27:53] <graydon> we could use the test runner to run the stuff in perf/, yes
[21:28:00] <graydon> I intend to (if it's not already)
[21:28:14] <graydon> the test runner is more of a reporting framework than anything
[21:28:14] <cmr> where is this mythical perf/ dir?
[21:28:19] *** Joins: zslayton (Mibbit@1D191528.269AFE30.6A3AF4D7.IP)
[21:28:28] <graydon> sorry, test/bench
[21:28:41] <cmr> well I mean the bench runner could use hardware counters
[21:28:42] <cmr> ok
[21:29:13] <graydon> the thing is, those benchmarks are not ... designed to be run multiple times to locate a statistically meaningful signature & minimal runtime. they pick their own magnitude and then just go.
[21:29:38] <cmr> I don't think most of them are appropriate for the bench runner
[21:30:14] <graydon> https://github.com/theonewolf/libperf SWOOOOOON
[21:30:28] <graydon> gplv2
[21:30:29] <graydon> :(
[21:31:18] <cmr> that's a *really* tiny library though
[21:31:33] *** Quits: pnathan (Adium@B9840254.2CD8A5F8.477B877D.IP) (Connection reset by peer)
[21:31:37] *** Quits: slaren (slaren@moz-C41F155E.red-95-120-43.dynamicip.rima-tde.net) (Ping timeout)
[21:31:41] <cmr> like, wicked tiny
[21:31:56] <daniel-kun> graydon: you mean something like QueryPerformanceCounter on windows, regarding hardware counters?
[21:32:05] <graydon> daniel-kun: yeah
[21:32:34] <cmr> https://github.com/mozilla/rr/pull/174
[21:32:35] <jensnockert> graydon: Just call the LLVM intrinsic for querying the cycle counter?
[21:32:45] <graydon> except queryperformancecounter is ... not terribly good
[21:32:50] <graydon> RDTSC isn't stable
[21:33:48] *** Quits: cdidd (cdidd@moz-E31431FA.broadband.corbina.ru) (Input/output error)
[21:34:20] *** Joins: tikue (tkuehn@moz-BBE3ABD.mv.mozilla.com)
[21:34:40] *** Quits: Ralith (ralith@moz-50F3C77.vc.shawcable.net) (Ping timeout)
[21:35:25] *** Quits: daniel-kun (daniel-kun@moz-75090EF.dip0.t-ipconnect.de) (Ping timeout)
[21:36:57] *** Joins: cdidd (cdidd@moz-C5BF34D.broadband.corbina.ru)
[21:37:17] *** Joins: daniel-kun (daniel-kun@moz-E02964AC.dip0.t-ipconnect.de)
[21:38:15] *** Joins: olleharstedt (Thunderbir@moz-80D8890F.ias.bredband.telia.com)
[21:38:32] *** Joins: slaren (slaren@moz-14DF61FB.red-95-120-34.dynamicip.rima-tde.net)
[21:38:40] *** Quits: mark_edward (quassel@moz-4A5B1251.wisolt4.epbfi.com) (Ping timeout)
[21:39:57] *** Quits: txdv (quassel@966F3542.3BA477DA.14C26596.IP) (Ping timeout)
[21:41:03] <jensnockert> rusti: extern { #[inline(always)] #[rust_stack] #[link_name="llvm.readcyclecounter"] fn read_cycle_counter() -> i64; }; unsafe { read_cycle_counter() }
[21:41:05] -rusti- 255114929151200
[21:41:05] <jensnockert> rusti: extern { #[inline(always)] #[rust_stack] #[link_name="llvm.readcyclecounter"] fn read_cycle_counter() -> i64; }; unsafe { read_cycle_counter() }
[21:41:06] *** Joins: txdv (quassel@966F3542.3BA477DA.14C26596.IP)
[21:41:06] -rusti- 255118740766194
[21:41:23] <bblum> hehe, i found a staticant
[21:41:30] <bblum> in a comment "we must send Something on the notify channel"
[21:41:37] <jensnockert> I wonder if you could detect rustis clock frequency that wayâ€¦
[21:42:09] <graydon> jensnockert: yeah, it works but the cycle counter will not tell you about dynamic frequency scaling or cpu migrations or other weirdness, it's generally considered not-useful for perf measurement
[21:43:02] <kmc> it depends on the exact platform. newer chips have a cycle counter that doesn't scale with the frequency, and the OS may set up the MSR state for RDTSCP such that you can detect CPU migration
[21:43:03] <glinscott> looking at https://github.com/mozilla/rust/issues/7298, i've been reading through the source a bit, going through trans_closure, which gets the result of the block from control flow::trans_block, and stores it into fcx.llretptr (i believe)
[21:43:07] <kmc> still it's tricky to get right
[21:43:34] <graydon> kmc: yeah? I mean .. I'm using clock_gettime(CLOCK_REALTIME) here; happy to use something better
[21:43:45] <graydon> basically the crudest mechanism possible for profiling :(
[21:44:11] *** Joins: dherman (dherman@moz-BBE3ABD.mv.mozilla.com)
[21:44:12] *** ChanServ sets mode: +o dherman
[21:45:04] <glinscott> it seems the compiler would need to recognize the value returned from the block, and instead use the llretptr to store that?  or am i off in left field? :)
[21:45:33] <kmc> on x86 Linux clock_gettime(CLOCK_REALTIME) will execute entirely in userspace, so that's good
[21:45:44] *** Joins: lkuper (lkuper@moz-C0CD33ED.hsd1.in.comcast.net)
[21:45:45] <tjc> graydon: something seems to be weird with bors -- I self-approved #7750 an hour ago and it doesn't seem to show up on the queue page
[21:47:57] <graydon> kmc: looks like I can pin to one CPU using taskset, and rdtsc frequency slew is corrected in newer chips, yeah. huh. maybe I should try it.
[21:48:18] <Eridius> tjc: I see it on the queue page
[21:48:21] <Eridius> showing up as UNREVIEWED
[21:48:39] <tjc> Eridius: I mis-spoke, yeah; it should show up as APPROVED since I r+'ed it
[21:49:10] <graydon> tjc: you rebased, it's out of order
[21:49:21] *** Quits: heftig (heftig@moz-3958C10A.dip0.t-ipconnect.de) (Ping timeout)
[21:49:21] <kmc> the Linux userspace implementation of clock_gettime(CLOCK_REALTIME) can avoid races with CPU context switching because it cooperates heavily with the kernel -- indeed, it's code built as part of the kernel, mapped into every process and running in user mode
[21:49:27] <Eridius> tjc: you need to put the r+ on https://github.com/catamorphism/rust/commit/5fecdfa7b3f141348f77cc6f0a775a0e3f7debb1
[21:49:38] <tjc> graydon: does github not show them in the right order? *headache*
[21:49:45] <graydon> not when you rebase
[21:49:53] <Eridius> tjc: it shows them in author timestamp order, not in topographical order
[21:50:05] <tjc> that must be what someone was saying earlier in re: their documentation page that suggested "just don't rebase" as a solution
[21:50:10] <cmr> yes
[21:50:19] <Eridius> tjc: github engineers admit this is a problem, but the solution is apparently non-trivial
[21:50:33] <cmr> https://help.github.com/articles/why-are-my-commits-in-the-wrong-order
[21:50:35] <Eridius> apparently the code that generates the list has to sort it in Ruby, and they've lost the topographical information at that point. not sure why though
[21:50:49] <cmr> nothing non-trivial about it, just a tradeoff, afaict
[21:50:57] <bblum> pcwalton: if you have a pub struct and a priv fn of the same name, you can't import even the struct name from somewhere else; is this a bug or intentional?
[21:51:10] <tikue> what do the style guidelines say about multi-line function calls? where do you line up the arguments?
[21:51:16] <Eridius> cmr: I got the impression the problem is they'd have to plumb the topographical data through a number of different components and that it would be a lot of work
[21:51:16] <tjc> it's only non-trivial if it's my job to do it ;-)
[21:51:30] <Eridius> we have style guidelines?
[21:51:38] <cmr> https://github.com/mozilla/rust/wiki/Note-style-guide
[21:51:38] <Eridius> I always line up the subsequent lines with the first argument
[21:51:42] *** Joins: pnathan (Adium@B9840254.2CD8A5F8.477B877D.IP)
[21:51:46] <cmr> that's what I do too
[21:51:53] *** Joins: heftig (heftig@moz-9E6A235D.dip0.t-ipconnect.de)
[21:52:44] *** Quits: cowboyd (cowboyd@moz-5476415B.sw.biz.rr.com) (Client exited)
[21:57:33] <cmr> hrm
[21:57:42] <cmr> "unexpected sort of item in get_item_ty(): Some(&node_expr(@{id: 25, node: expr_lit(@{node: lit_str(@"Newtype"), span: {lo: {__field__: 4263}, hi: {__field__: 4268}, expn_info: None}}), span: {lo: {__field__: 4263}, hi: {__field__: 4268}, expn_info: None}}))"
[21:58:41] *** Quits: vk (chatzilla@3E9D68F2.B1163E0C.2A6693DD.IP) (Ping timeout)
[22:00:06] *** Quits: maxli (maxli@F2D29657.F60B0462.67AC9B1.IP) (Quit: Leaving.)
[22:00:16] *** Quits: pcwalton (pcwalton@moz-7B0110AD.mv.mozilla.com) (Quit: pcwalton)
[22:00:39] *** Quits: eatkinson (eatkinson@moz-BBE3ABD.mv.mozilla.com) (Quit: eatkinson)
[22:00:48] *** Quits: eschweic1 (Adium@moz-BBE3ABD.mv.mozilla.com) (Quit: Leaving.)
[22:01:12] *** Joins: maxli (maxli@F2D29657.F60B0462.67AC9B1.IP)
[22:01:18] *** Quits: maxli (maxli@F2D29657.F60B0462.67AC9B1.IP) (Input/output error)
[22:01:50] *** Quits: daniel-kun (daniel-kun@moz-E02964AC.dip0.t-ipconnect.de) (Ping timeout)
[22:02:13] *** Joins: pcwalton (pcwalton@moz-7B0110AD.mv.mozilla.com)
[22:02:13] *** ChanServ sets mode: +o pcwalton
[22:02:30] <kmc> if I encounter an ICE that is probably caused by rustc reading metadata generated by an older version of rustc, is that bug worth filing or no?
[22:02:42] <cmr> Wait why am I even running typeck
[22:02:42] <pcwalton> kmc: there's a bug on that I think
[22:02:51] *** Joins: eschweic (Adium@moz-BBE3ABD.mv.mozilla.com)
[22:02:52] *** Joins: eatkinson (eatkinson@moz-BBE3ABD.mv.mozilla.com)
[22:03:49] *** Quits: pyrac (pyrac@moz-F2C67F88.w83-114.abo.wanadoo.fr) (Quit: pyrac)
[22:03:52] <kmc> yeah seems to be https://github.com/mozilla/rust/issues/5862
[22:03:58] <cmr> pcwalton: is the def_map completely populated after resolve?
[22:04:31] <pcwalton> yes I believe so
[22:07:27] *** Parts: marijn (user@moz-BB01ACFA.dip0.t-ipconnect.de) (ERC Version 5.3 (IRC client for Emacs))
[22:08:56] *** Quits: jedestep (jedestep@34641662.FB4DE631.66C78B76.IP) (Quit: leaving)
[22:08:56] *** Joins: daniel-kun (daniel-kun@moz-C320BB58.dip0.t-ipconnect.de)
[22:09:13] *** Quits: hjr3 (hradtke@1A0AE795.28A5F6C3.A2D40ED2.IP) (Quit: My MacBook has gone to sleep. ZZZzzzâ€¦)
[22:09:35] *** Quits: saml (sam@moz-14C16814.cst.lightpath.net) (Quit: Leaving)
[22:13:01] *** Quits: devinus (devinus@DAEC7122.372FE49C.29F95E0F.IP) (Quit: Computer has gone to sleep.)
[22:14:56] *** Joins: erickt (erickt@8C9ECD8F.3A598286.F12515B4.IP)
[22:15:25] *** Quits: tjc (tjc@moz-BBE3ABD.mv.mozilla.com) (Quit: zzzzzzzzzz)
[22:16:04] *** Joins: hjr3 (hradtke@1A0AE795.28A5F6C3.A2D40ED2.IP)
[22:16:24] *** Quits: fabiand (fabiand@moz-680BCD95.adsl.alicedsl.de) (Client exited)
[22:17:08] *** Joins: MaikKlein (maik@moz-B9C8EE03.dip0.t-ipconnect.de)
[22:17:14] *** Quits: eatkinson (eatkinson@moz-BBE3ABD.mv.mozilla.com) (Quit: eatkinson)
[22:17:18] *** Quits: Blub\w (wry@7E3BB9D.71150E1A.237AE2BA.IP) (Quit: bb2m)
[22:17:49] *** Quits: erickt (erickt@8C9ECD8F.3A598286.F12515B4.IP) (Ping timeout)
[22:18:11] *** Joins: eatkinson (eatkinson@moz-BBE3ABD.mv.mozilla.com)
[22:20:25] *** Joins: mark_edward (quassel@moz-4A9A2F15.dynamic.utc.edu)
[22:22:28] *** Quits: hjr3 (hradtke@1A0AE795.28A5F6C3.A2D40ED2.IP) (Quit: My MacBook has gone to sleep. ZZZzzzâ€¦)
[22:22:48] *** Quits: lkuper (lkuper@moz-C0CD33ED.hsd1.in.comcast.net) (Ping timeout)
[22:27:04] *** Joins: valentin (valentin@moz-CD698F5E.red-80-27-103.dynamicip.rima-tde.net)
[22:27:14] <valentin> Hi guys
[22:27:19] <pcwalton> for some reason bors isn't picking up my change
[22:27:49] <valentin> I'm new here, just starting to look into rust lang.
[22:28:10] <valentin> May I ask a question regarding Path?
[22:28:15] <strcat> valentin: sure
[22:28:22] <strcat> graydon: btw the doc builder doesn't seem to be working automatically anymore
[22:28:30] <cmr> pcwalton: did you comment on the correct commit?
[22:28:37] <pcwalton> I think so!
[22:28:41] *** Joins: ghrust (ghrust@79968228.6A2AE50.F3114085.IP)
[22:28:41] <ghrust> 01[13rust01] 15bors merged 06auto into 06master: 02http://git.io/sjsviw
[22:28:41] *** Parts: ghrust (ghrust@79968228.6A2AE50.F3114085.IP) ()
[22:28:44] <graydon> strcat: checking
[22:28:52] <strcat> graydon: the last build was 2 days ago when I forced it
[22:29:54] <valentin> strcat, I'm getting current path via os::cwd(); Then I call path#dirname(); and this function returns a string that is one level up, for example: /home/projects/rustapp#dirname() will return "/home/projects"
[22:30:02] *** Quits: eatkinson (eatkinson@moz-BBE3ABD.mv.mozilla.com) (Quit: eatkinson)
[22:30:27] <pcwalton> grrrr, pull request bitrotted again again
[22:30:31] <pcwalton> 3rd time?
[22:30:37] <cmr> close the tree!
[22:30:42] <cmr> quickly, before bors does more damange
[22:30:58] <strcat> or p=1 something you know doesn't conflict
[22:31:05] <valentin> strcat, the doc says that "Returns the directory component of self, as a string" but in this case "/home/projects/rustapp" is already a directory so no need to go one level up.
[22:31:14] *** Quits: dherman (dherman@moz-BBE3ABD.mv.mozilla.com) (Quit: dherman)
[22:31:25] *** Quits: MaikKlein (maik@moz-B9C8EE03.dip0.t-ipconnect.de) (Ping timeout)
[22:31:30] <strcat> valentin: I think that's what it does in other languages too
[22:31:35] <strcat> it doesn't actually look at the fs
[22:31:39] *** Joins: ghrust (ghrust@F6EE6DE3.6A2AE50.F3114085.IP)
[22:31:39] <ghrust> 01[13rust01] 15bors pushed 5 new commits to 06auto: 02http://git.io/21QgBw
[22:31:39] <ghrust> 13rust/06auto 144290869 15Kevin Ballard: Give term.fg() and term.bg() a bool return value
[22:31:39] <ghrust> 13rust/06auto 1409e2b04 15Kevin Ballard: term: Add new function .attr() to toggle terminal attributes...
[22:31:40] <ghrust> 13rust/06auto 145f40c27 15Kevin Ballard: Highlight rustc's warnings/errors in bold instead of bright white...
[22:31:41] <strcat> % dirname /home/projects/rustapp
[22:31:43] *** Parts: ghrust (ghrust@F6EE6DE3.6A2AE50.F3114085.IP) ()
[22:31:43] <strcat> /home/projects
[22:31:45] <strcat> the POSIX utility
[22:31:52] <valentin> strcat, the doc says that 'returns the directory component of self, as a string' but in this case '/home/projects/rustapp' is already a directory so no need to go one level up.
[22:32:08] <cmr> valentin: path manipulation doesn't care about the actual structure of the filesystem
[22:32:10] <cmr> it is correct
[22:32:22] <valentin> cmr, strcat thatnks for clarification
[22:32:34] *** Joins: ozten (ozten@moz-DD3B00B4.hsd1.wa.comcast.net)
[22:32:38] <graydon> strcat: ah, yeah, I disabled it a while ago, I think to make sure enough machines were in the auto pool
[22:33:19] <graydon> shall I turn it on again?
[22:33:34] <strcat> graydon: yeah, assuming it's not a mac one :)
[22:33:39] <strcat> I think there are enough
[22:33:50] *** Quits: mr_trousers (Mibbit@BBE7C46A.B4F11D08.8612FA94.IP) (Quit: http://www.mibbit.com ajax IRC Client)
[22:33:51] <graydon> want try machines too? I turned them off also
[22:34:09] * strcat shrugs
[22:34:29] <strcat> I've just been forcing a build on the try bot I care about (mac/windows)
[22:34:50] <strcat> but I guess it might as well do it automatically
[22:35:25] <graydon> I'd prefer to keep load low for now
[22:35:41] <graydon> cycle time still to bad
[22:35:50] <graydon> doc is back on
[22:35:57] *** Joins: paupau (textual@moz-D6583788.hsd1.ca.comcast.net)
[22:36:17] *** Joins: bent (chatzilla@moz-2CD73AA6.triad.res.rr.com)
[22:37:36] <cmr> pcwalton: resolve doesn't populate the defmap at all, it seems that is the job of typeck
[22:37:40] <tikue> rusti: struct Foo { Option<Foo> };
[22:37:41] -rusti- <anon>:7:28: 7:29 error: expected `:` but found `<`
[22:37:41] -rusti- <anon>:7          struct Foo { Option<Foo> };
[22:37:41] -rusti-                                      ^
[22:37:41] -rusti- application terminated with error code 101
[22:37:56] <pcwalton> the def map?
[22:38:01] <pcwalton> it should have the *def* map
[22:38:04] <pcwalton> typeck
[22:38:17] <tikue> rusti: struct Foo { foos: ~[Foo] }
[22:38:19] -rusti- ()
[22:38:26] <jasom_> grr, I hate that I can't assign a borrowed reference to a variable with scope that is one block out, even when there are no expressions between the ends of the two blocks
[22:38:26] <pcwalton> populates tcx
[22:39:04] <strcat> jasom_: you can if the lifetime of the borrowed ptr is long enough
[22:39:12] <cmr> oh wait logic bug, sorry :(
[22:39:36] <jasom_> strcat: I see a few references to "named lifetimes" but all with the caveat of "There is a forthcoming tutorial"
[22:39:46] <cmr> jasom_: http://static.rust-lang.org/doc/tutorial-borrowed-ptr.html#named-lifetimes
[22:39:57] <strcat> you don't really need named lifetimes if it's all local
[22:40:05] *** Joins: leonvv (leonvv@moz-7D83A5F1.ip.telfort.nl)
[22:40:12] <strcat> named lifetimes are just for declaring signatures, if nothing goes wrong with inference
[22:40:18] <jasom_> strcat: so how do I set the lifetime of a borrowed ptr?
[22:40:28] <cmr> jasom_: you shouldn't have to
[22:40:31] <strcat> jasom_: the lifetime of the borrowed pointer comes from what it points at
[22:40:49] <strcat> a borrowed pointer doesn't have runtime machinery - it's just a reference to something, and can live as long as what it points at
[22:41:20] *** Quits: zslayton (Mibbit@1D191528.269AFE30.6A3AF4D7.IP) (Quit: http://www.mibbit.com ajax IRC Client)
[22:41:34] <jasom_> ah, so is it possible to fiddle with the lifetime of variables introduced via match expressions?
[22:41:40] <strcat> so if it points inside an 'x' variable, it can't live beyond where 'x' goes out of scope
[22:41:50] <strcat> jasom_: you can match by-reference
[22:42:00] <strcat> you can use 'ref mut' and 'ref' in patterns
[22:42:01] <strcat> like
[22:42:11] <strcat> rusti: let x = (1, 2); let (a, _) = x; a
[22:42:12] -rusti- 1
[22:42:14] <jasom_> ohhh
[22:42:14] <strcat> rusti: let x = (1, 2); let (ref a, _) = x; a
[22:42:15] -rusti- more than 5 lines of output, pastebinned: http://sprunge.us/EKeR
[22:42:16] <strcat> rusti: let x = (1, 2); let (ref a, _) = x; *a
[22:42:17] -rusti- 1
[22:42:26] <strcat> (works in match too)
[22:42:58] <strcat> jasom_: it will let the reference live beyond the match expression that way, as long as it can see the variable you matched on does
[22:43:47] <jasom_> yeah, I get it now; I'm just a bit slow
[22:43:57] <sully> wait, can structs and enums have static methods?
[22:44:32] <cmr> rusti: struct Foo; impl Foo { fn foo() -> int { 42 } } Foo::foo()
[22:44:33] -rusti- 42
[22:44:36] <cmr> sully: seems so
[22:44:56] <sully> I suppose that is useful for namespacing, maybe?
[22:45:22] <cmr> it's used all the time, especially constructors (Foo::new())
[22:45:28] <sully> ah, ok
[22:45:56] *** Quits: RageOfThou (RageOfThou@3FEF494C.29C984D5.783DEDCA.IP) (Ping timeout)
[22:46:36] *** Quits: glinscott (garylinsco@789A6618.53EB7C1.FFFE3AA.IP) (Quit: glinscott)
[22:47:15] <pcwalton> graydon: do you know why bors isn't picking up https://github.com/mozilla/rust/pull/7753 as APPROVED?
[22:47:31] <graydon> did you rebase?
[22:47:41] <strcat> is c7f9a3f actually the child commit?
[22:47:48] <strcat> github sorts them wrong
[22:48:04] *** Joins: Ralith (ralith@moz-2E408D26.wireless.sfu.ca)
[22:48:30] <graydon> yeah, this happens to everyone, every day or two
[22:48:35] <graydon> 3 times today?
[22:48:47] *** Joins: eatkinson (eatkinson@moz-BBE3ABD.mv.mozilla.com)
[22:48:54] <brendanc> maybe bors could post why it isn't approving?
[22:49:06] *** Quits: paupau (textual@moz-D6583788.hsd1.ca.comcast.net) (Ping timeout)
[22:49:16] <cmr> brendanc: every time he runs (every 5 min afaik), for every PR?
[22:49:28] <graydon> it isn't approving because there's no review on the head commit
[22:49:32] <graydon> it's pretty straightforward
[22:49:35] *** Parts: benbangert (bbangert@moz-B1FEE9C0.org) (Linkinus - http://linkinus.com)
[22:49:37] <graydon> you have to approve the head commit
[22:49:39] <graydon> github sorts them wrong
[22:49:46] <graydon> look in your workspace and figure out which one is the head commit
[22:49:49] <graydon> and approve that one
[22:49:55] * strcat isn't sure if that's the case here, haven't checked
[22:49:56] <brendanc> yes, I understand that but it's hard to tell from the pull request
[22:50:35] <brendanc> "ignoring review of non-head commit" or something might be helpful
[22:50:35] <graydon> brendanc: so .. should it look up the chain of all commit parents (to what depth?) of each PR looking for an r+ it's ignoring?
[22:50:52] * strcat thinks github should stop being stubborn and fix it ;p
[22:51:00] <graydon> it has limited API calls, and crashes any time the API fails
[22:51:10] <graydon> which it does about every 50-100 calls
[22:51:31] *** Joins: aatch (aatch@moz-2BB0AC01.cable.telstraclear.net)
[22:51:41] <brendanc> well, it would be nice :)
[22:52:04] <valentin> strcat, I've read that 0.7 release deals with external iterators, I can't anything about this on rust manual. Where could I read more about the difference between internal vs external iterators and their specific implementation in Rust?
[22:52:09] *** Quits: mark_edward (quassel@moz-4A9A2F15.dynamic.utc.edu) (Ping timeout)
[22:52:19] <graydon> ok, yeah, sorry. I am just crabby because everyone stubs their toes on it
[22:52:44] <cmr> valentin: mailing list, reddit. not in the manual
[22:52:51] *** Quits: jclements (jclements@moz-BBE3ABD.mv.mozilla.com) (Quit: jclements)
[22:52:52] <strcat> well there's an iterator tutorial
[22:52:52] <cmr> source code
[22:53:04] <valentin> ah, ok thanks
[22:53:06] <strcat> I just updated it though and the doc bot is building it atm
[22:53:11] <brendanc> yes, thus the warning request. maybe I'll look at it if I ever get a bors test harness together
[22:54:00] <brendanc> can crash on API failure not be worked around with a retry loop, out of curiosity?
[22:54:21] *** Quits: eatkinson (eatkinson@moz-BBE3ABD.mv.mozilla.com) (Quit: eatkinson)
[22:54:21] <kimundi> graydon: How about including a link to the head commit on the bors status page?
[22:54:24] *** Quits: eschweic (Adium@moz-BBE3ABD.mv.mozilla.com) (Quit: Leaving.)
[22:54:55] <graydon> kimundi: that would be easy, yes.
[22:55:46] <brendanc> bors could perhaps also post something like "awaiting review of <hash>" on the PR
[22:55:57] <brendanc> might be less expensive
[22:56:34] <pcwalton> graydon: oops sorry
[22:56:36] *** Joins: jclements (jclements@moz-BBE3ABD.mv.mozilla.com)
[22:56:51] *** Joins: tjc (tjc@moz-BBE3ABD.mv.mozilla.com)
[22:56:51] *** ChanServ sets mode: +o tjc
[22:56:54] <strcat> anyway I don't understand why they sort them differently on PRs than *everywhere* else
[22:57:00] <graydon> pcwalton: np, sorry it's such a pain :(
[22:57:11] <brendanc> yeah, it's github's problem
[22:57:52] <strcat> brendanc: they refused to fix it though
[22:58:03] *** Quits: yichoi (yichoi@5AB4884B.FCC4549.14D5B978.IP) (Connection reset by peer)
[22:58:08] *** Joins: eschweic (Adium@moz-BBE3ABD.mv.mozilla.com)
[22:58:10] <strcat> they don't consider it a bug ;\
[22:58:10] *** Joins: eatkinson (eatkinson@moz-BBE3ABD.mv.mozilla.com)
[22:58:22] *** Quits: tikue (tkuehn@moz-BBE3ABD.mv.mozilla.com) (Quit: tikue)
[22:58:30] *** Quits: valentin (valentin@moz-CD698F5E.red-80-27-103.dynamicip.rima-tde.net) (Ping timeout)
[22:58:33] *** Joins: eschweic1 (Adium@moz-BBE3ABD.mv.mozilla.com)
[22:58:34] *** Quits: eschweic (Adium@moz-BBE3ABD.mv.mozilla.com) (Connection reset by peer)
[22:58:35] <jclements> strcat: maybe we should just start making a habit of including the head's SHA1 in the pull request?
[22:58:47] *** Quits: tiffany (kawaii@moz-1E0FE6E8.dhcp.embarqhsd.net) (No route to host)
[22:58:50] *** Joins: tikue (tkuehn@moz-BBE3ABD.mv.mozilla.com)
[22:59:00] <jensnockert> Urghâ€¦
[22:59:03] <jensnockert> Silly me.
[22:59:10] *** Quits: barosl (barosl@E287D94F.C81E10FB.7544CABF.IP) (Quit: ëžœë¤ì€ ì‡ í‡´í–ˆìŠµë‹ˆë‹¤.)
[22:59:11] *** Joins: maxli (maxli@B5559308.9C54E60.2FA4EA88.IP)
[22:59:33] <jensnockert> I have been debugging a SIMD error for 4 hours now, and I didn't notice that the error was actually in the fixed-length vector implementation.
[22:59:33] <aatch> I tend to just make sure that the commit I r+ has the parent I expect.
[22:59:59] <cmr> aatch: that's not foolproof though
[23:00:14] *** Joins: tiffany (kawaii@moz-1E0FE6E8.dhcp.embarqhsd.net)
[23:00:15] <cmr> it was the case with pcwalton's PR that the parent of the last commit in the list was correct
[23:00:31] *** Quits: ecr (Thunderbir@moz-BBE3ABD.mv.mozilla.com) (Quit: ecr)
[23:00:52] <strcat> https://help.github.com/articles/why-are-my-commits-in-the-wrong-order
[23:01:04] *** Quits: SimonSapin (simon@moz-D0C2F181.zone2.bethere.co.uk) (Ping timeout)
[23:01:22] <strcat> it's really weird though, don't understand the logic :(
[23:01:45] <strcat> they don't reorder comments when you edit them...
[23:01:54] <brendanc> GitHub emphasizes Pull Requests as a space for discussion. All aspects of it--comments, references, and commits--are represented in a chronological order.
[23:02:07] <brendanc> those two sentences are arranged as if one logically follows from the other
[23:02:17] *** Quits: tiffany (kawaii@moz-1E0FE6E8.dhcp.embarqhsd.net) (Input/output error)
[23:02:24] *** Joins: tiffany (kawaii@moz-1E0FE6E8.dhcp.embarqhsd.net)
[23:02:44] *** Joins: yichoi (yichoi@5AB4884B.FCC4549.14D5B978.IP)
[23:03:46] <kimundi> pcwalton: I think you have stray mergemarkers in the Decop2 PR
[23:04:50] *** Joins: paupau (textual@moz-D6583788.hsd1.ca.comcast.net)
[23:05:59] <strcat> PSA: in /usr/share/git-core/templates/hooks, you can rename pre-commit.sample to pre-commit and it will verify that you have no whitespace errors or merge markers left before it commits
[23:06:10] <strcat> (you have to also do it in any existing .git/hooks dir)
[23:06:12] <pcwalton> kimundi: hmm, but it's bootstrapping
[23:06:36] <pcwalton> in the tests?
[23:06:41] <kimundi> pcwalton: Maybe I'm wrong, but: https://github.com/mozilla/rust/pull/7753/files#L3L41
[23:07:32] <cmr> strcat: that's very useful
[23:08:03] * strcat wishes it was a default
[23:08:23] <paupau> holy enormous PR
[23:08:27] <strcat> the sample just does this
[23:08:29] <strcat> # If there are whitespace errors, print the offending file names and fail.
[23:08:31] <strcat> exec git diff-index --check --cached $against --
[23:08:54] <strcat> since no one will ever remember to run that themselves ;p
[23:09:21] <strcat> imo commit should just do that itself...
[23:09:44] <strcat> easier to add exceptions to gitattributes than remember to check everything
[23:09:52] *** Joins: lerc (quassel@moz-598ED764.telstraclear.net)
[23:09:59] *** Joins: Sorella (queen@78575561.924F2739.95C8B7C6.IP)
[23:11:00] *** Quits: tiffany (kawaii@moz-1E0FE6E8.dhcp.embarqhsd.net) (Ping timeout)
[23:12:03] *** Quits: daniel-kun (daniel-kun@moz-C320BB58.dip0.t-ipconnect.de) (Quit: Verlassend)
[23:12:58] <doomlord> lol. fired up eclipse and my c++ source again. Eclipse is making my laptop overheat
[23:13:31] *** Joins: ChrisMorgan (chris@moz-6AC741CA.static.tpgi.com.au)
[23:14:02] *** Quits: eatkinson (eatkinson@moz-BBE3ABD.mv.mozilla.com) (Quit: eatkinson)
[23:14:12] *** Quits: tikue (tkuehn@moz-BBE3ABD.mv.mozilla.com) (Quit: tikue)
[23:15:27] *** Quits: eschweic1 (Adium@moz-BBE3ABD.mv.mozilla.com) (Quit: Leaving.)
[23:15:39] <aatch> ls
[23:15:42] <aatch> dammit
[23:15:49] <paupau> every time
[23:16:00] <cmr> aatch: oi, land the new visitor so I can start using master rather than a local fork for rustdoc
[23:16:06] <cmr> </lazy>
[23:16:12] <cmr> it needs to be rebased because of your desharing
[23:16:21] *** Joins: erickt (erickt@8C9ECD8F.3A598286.F12515B4.IP)
[23:16:24] <cmr> and it seems non-trivial, my 15-minute attempt at it was unsuccessful
[23:16:49] <aatch> cmr, but I need a new snapshot to land it, and I don't want to snapshot the memory regression.
[23:17:00] <aatch> cmr, and I have no idea why it fails on windows.
[23:17:02] <cmr> aatch: why do you need a snapshot to land it?
[23:17:05] <aatch> (The fix)
[23:17:10] <aatch> cmr, default method bugs
[23:17:15] <cmr> oh, sadtimes
[23:17:50] *** Joins: azita (Azita@moz-BBE3ABD.mv.mozilla.com)
[23:18:08] <cmr> can you just... #[cfg(not(stage0))] mod visit_new?
[23:18:18] <aatch> cmr, I could.
[23:18:37] *** Quits: azita (Azita@moz-BBE3ABD.mv.mozilla.com) (Quit: azita)
[23:19:06] *** Quits: erickt (erickt@8C9ECD8F.3A598286.F12515B4.IP) (Ping timeout)
[23:19:08] <aatch> cmr, but my attempt at removing far more `@` from the compiler resulted in me realizing that a we need more from a new visitor.
[23:19:25] *** Quits: paupau (textual@moz-D6583788.hsd1.ca.comcast.net) (Ping timeout)
[23:19:44] <kimundi> pcwalton: also here: https://github.com/mozilla/rust/pull/7753/files#L266L26
[23:19:52] <pcwalton> kimundi: found one, fixed
[23:21:00] <graydon> bleh
[23:21:09] <acrichto> pcwalton: you should submit a dummy pull request which sits behind the de-copy one to ensure that nothing jumps in front of it in the queue. If de-copy fails you can just manually cancel the dummy one?
[23:21:09] <graydon> our symbols are now named ending in 0$x2e8$x2dpre
[23:21:17] <graydon> (0.8-pre, mangled)
[23:22:16] <kmc> is rustc name mangling meant to be compatible with g++'s?
[23:22:34] <cmr> kmc: yeah
[23:22:38] <kimundi> pcwalton: There still seems to be a merge marker in compiletest.rs
[23:22:41] <cmr> afiact
[23:22:48] <cmr> it passes through c++filt, at the very least
[23:23:03] *** Joins: tikue (tkuehn@moz-BBE3ABD.mv.mozilla.com)
[23:23:12] *** Joins: eschweic (Adium@moz-BBE3ABD.mv.mozilla.com)
[23:23:40] *** Joins: eschweic1 (Adium@moz-BBE3ABD.mv.mozilla.com)
[23:23:41] *** Quits: eschweic (Adium@moz-BBE3ABD.mv.mozilla.com) (Connection reset by peer)
[23:24:33] *** Joins: eatkinson (eatkinson@moz-BBE3ABD.mv.mozilla.com)
[23:24:33] <bblum> is there an approved style for having a bunch of static methods?
[23:24:41] *** Quits: olleharstedt (Thunderbir@moz-80D8890F.ias.bredband.telia.com) (Ping timeout)
[23:24:48] <bblum> i have done something like, struct RuntimeGlue; impl RuntimeGlue { ... bunch of static methods ... }
[23:25:00] <bblum> i was gonna do mod RuntimeGlue but that requires writing a lot of annoying import statements
[23:26:25] <kmc> cmr: that's really handy :)
[23:26:34] <kimundi> bblum: Where's the difference import_wise?
[23:27:10] <kimundi> Don't you have to do the same steps to import those names in both cases?
[23:27:16] <pcwalton> kimundi: yeah, found it
[23:27:21] <bblum> kimundi: no, i just want to call it in the same file
[23:27:39] <bblum> difference is you have to be like "mod RuntimeGlue { import super::*; ... and a lot of other stuff .... }
[23:27:42] <bblum> "
[23:28:04] *** Joins: Jesin (Jessin_@moz-48B48C95.eecs.lehigh.edu)
[23:28:16] <thiez> there is no real reason to avoid static methods, is there?
[23:29:59] <thiez> in unrelated news, using simd in rustray is initially a disappointment
[23:31:27] <kmc> is there something I can call to print a backtrace of the current stack and then continue normal execution?
[23:31:31] <thiez> some of the disappointment might be explained by the fact that the output image has very little resemblance to the original, I screwed up somewhere :p
[23:31:42] <ziad> Hi all. I just installed the version of the compiler I pulled from github on July 10
[23:31:43] <ziad> rust 0.8-pre (90db862 2013-07-10 11:46:41 -0700)
[23:32:02] <ziad> when I try to compile a simple hello world program, I get the following error
[23:32:06] <ziad> test.rs:1:0: 1:0 error: can't find crate for `std`
[23:32:13] <ziad> $ rustc test.rs
[23:32:19] <leonvv> How can one make a range in rust?
[23:32:24] <thiez> how did you install?
[23:32:27] <cmr> leonvv: what sort of range?
[23:32:34] <cmr> python-style range?
[23:32:37] <aatch> leonvv, can you be more specific?
[23:32:42] <ziad> ./configure, make, make install
[23:32:54] <thiez> odd, that should have worked
[23:33:01] <aatch> ziad, is your PATH setup properly?
[23:33:09] <kimundi> pcwalton: Urgh, I just realized that Chromes fulltext search is slow and doesn't show all matches directly... I'm afraid there are still markers left in test/compile-fail/kindck-owned.rs and src/test/bench/graph500-bfs.rs :(
[23:33:13] <cmr> also your LD_LIBRARY_PATH / /etc/ld.so.conf
[23:33:15] <ziad> aatch: What should I make it oint to
[23:33:17] <ziad> point*
[23:33:18] <thiez> ziad: what OS are you running?
[23:33:25] <leonvv> Just a range of integers, which can be looped, I'm following this tutorial but "int::range(1, 101)" seems outdated: http://www.rustforrubyists.com/book/book.html
[23:33:38] <ziad> ubuUbuntu 10.04.4 LTS
[23:33:42] <cmr> leonvv: std::int::range
[23:33:53] <cmr> leonvv: rust for rubyists is only 0.6 atm
[23:34:02] <cmr> leonvv: (also it's a book, not a tutorial :p)
[23:34:16] * ziad away
[23:34:17] <cmr> leonvv: I'll make updating it my #1 priority this weekend.
[23:34:24] <leonvv> It's yours?
[23:34:34] <cmr> Steve Klabnik's, but I'm a contributor/maintainer
[23:34:44] <cmr> I just update syntax, removed old bits, etc
[23:34:47] <cmr> he wrote all the prose
[23:35:23] <leonvv> Awesome man, it's like the only documentation on rust atm, together with the official tutorial.
[23:35:53] *** Joins: hjr3 (hradtke@1A0AE795.28A5F6C3.A2D40ED2.IP)
[23:35:53] <cmr> #rustdoc-wg for those interested
[23:35:56] <cmr> http://rustlog.octayn.net/post/55295716244/status-update, good night
[23:36:06] <aatch> leonvv, theres #rust, the best documentation on the interwebs
[23:36:18] <leonvv> Agree :)
[23:36:31] *** Joins: dherman (dherman@moz-6CA476B1.hsd1.ca.comcast.net)
[23:36:31] *** ChanServ sets mode: +o dherman
[23:36:33] <thiez> it's only the best documentation by virtue of being the only documentation
[23:36:40] <strcat> we really need a better index to make the other tutorials easier to find
[23:37:39] *** Quits: aatch (aatch@moz-2BB0AC01.cable.telstraclear.net) (Client exited)
[23:38:34] <tjc> strcat: they can be linked to on the wiki :-)
[23:39:11] * jensnockert hugs cmr.
[23:40:43] *** Quits: leonvv (leonvv@moz-7D83A5F1.ip.telfort.nl) (Client exited)
[23:41:40] <strcat> graydon: hrm. the doc bot didn't update the container tutorial
[23:41:54] <strcat> http://buildbot.rust-lang.org/builders/doc/builds/257/steps/MasterShellCommand/logs/stdio *shrug*
[23:44:51] *** Joins: dbaupp (Thunderbir@moz-712A1135.lns20.syd6.internode.on.net)
[23:45:05] *** Joins: SiegeLord (sl@moz-CAF07B4C.hsd1.ma.comcast.net)
[23:46:36] *** Quits: jaen (jaen@moz-E0979827.copit.pl) (Ping timeout)
[23:46:58] *** Joins: jaen (jaen@moz-E0979827.copit.pl)
[23:47:22] *** Joins: enix (enix@moz-A50569DD.c3-0.slvr-ubr1.lnh-slvr.md.cable.rcn.com)
[23:48:46] *** Quits: hjr3 (hradtke@1A0AE795.28A5F6C3.A2D40ED2.IP) (Quit: My MacBook has gone to sleep. ZZZzzzâ€¦)
[23:50:23] *** Quits: eholk (eholk@moz-A6B67E64.uconnect.utah.edu) (Quit: eholk)
[23:50:44] *** Quits: infynyxx (infynyxx@DB780A29.749BA1D.DCC373F0.IP) (Client exited)
[23:50:53] *** Quits: DasIch (dasich@moz-5EDA591.de) (Client exited)
[23:58:57] *** Quits: bnicholson_ (bnicholson@moz-BBE3ABD.mv.mozilla.com) (Ping timeout)

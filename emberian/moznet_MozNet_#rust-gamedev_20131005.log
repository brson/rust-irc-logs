[00:05:41] *** Joins: Yeri (jasonjasmi@41C91A8A.CE609BA5.E39FBF79.IP)
[00:18:27] *** Quits: canhtak (jeremy@moz-7FADA491.wl.t.ulaval.ca) (Quit: canhtak)
[00:35:51] *** Joins: Axord (xord@moz-1B228827.lsanca.dsl-w.verizon.net)
[00:37:43] *** Quits: Axord (xord@moz-1B228827.lsanca.dsl-w.verizon.net) (Ping timeout)
[00:41:40] *** kimundi is now known as zz_kimundi
[00:46:00] *** Joins: jennylove (jenny1986@moz-9675A4DB.dsl.bell.ca)
[00:46:02] <jennylove> http://Fun4Days.com/sms/sms.php?share=178616
[00:46:03] *** Parts: jennylove (jenny1986@moz-9675A4DB.dsl.bell.ca) ()
[00:52:25] *** Joins: Axord (xord@moz-1B228827.lsanca.dsl-w.verizon.net)
[01:00:18] *** Quits: mark_edward (quassel@moz-DCB0B750.lightspeed.cicril.sbcglobal.net) (Client exited)
[01:46:27] *** Quits: FrozenCow (FrozenCow@moz-B2DF4929.chello.nl) (Client exited)
[02:05:34] *** Quits: sp3d (a@moz-41A29595.dhcp.stls.mo.charter.com) (Ping timeout)
[02:07:15] *** Joins: sp3d (a@moz-41A29595.dhcp.stls.mo.charter.com)
[02:38:00] *** Quits: zz_kimundi (kimundi@moz-C29F3EBA.dip0.t-ipconnect.de) (Ping timeout)
[02:41:56] *** Joins: zz_kimundi (kimundi@moz-4F2ED33.dip0.t-ipconnect.de)
[02:41:58] *** zz_kimundi is now known as kimundi
[03:03:59] *** Quits: Amaranth (travis@moz-F81BB56A.cpe.cableone.net) (Ping timeout)
[03:06:21] *** Joins: Amaranth (travis@moz-F81BB56A.cpe.cableone.net)
[03:21:12] *** Joins: nielsle (nielsle@moz-5CE8ECCD.boa.fiberby.dk)
[03:48:19] *** Joins: StarLight (StarLight@moz-BC57337C.dynamic.avangarddsl.ru)
[03:50:36] *** Quits: Yeri (jasonjasmi@41C91A8A.CE609BA5.E39FBF79.IP) (Quit: Yeri)
[03:57:17] <jxv> Are there glm bindings or is there (a better) alternative?
[03:57:36] <cmr> jxv: it's not possible to bind glm, it's pure templates.
[03:57:49] <tiffany> it is possible to write a glm for rust
[03:57:57] <jxv> cmr, ah right. oops
[03:58:03] <tiffany> it's 50% C++ templates and 50% math, so
[03:58:32] <jxv> both which rust excels
[03:58:52] <cmr> jxv: if you just want vectors and matrices, there's bjz's cgmath
[03:59:07] <cmr> and rust doesn't really excel in templates, we're far, far more limited in what we can do.
[03:59:25] <cmr> we only get type parameters, and they're supposedly not turing complete
[04:05:55] <jeaye> Something like glm in Rust would likely be done via macros.
[04:06:08] <jeaye> In order to have the flexibility of C++ templates.
[04:07:02] *** Joins: Yurume (yurume@AC58A8CE.8A059B47.E313B915.IP)
[04:07:26] *** Quits: tiffany (kawaii@moz-28A8742A.dhcp.embarqhsd.net) (Ping timeout)
[04:10:47] *** Quits: mcpherrin (mimcpher@moz-345B5EBA.csclub.uwaterloo.ca) (Ping timeout)
[04:11:19] *** Joins: mcpherrin (mimcpher@moz-345B5EBA.csclub.uwaterloo.ca)
[04:21:11] *** Quits: jeaye (Jeaye@moz-34FEF2BB.hsd1.ca.comcast.net) (Quit: brb)
[04:25:08] *** Joins: jeaye (Jeaye@moz-34FEF2BB.hsd1.ca.comcast.net)
[04:28:18] *** Quits: fmtq (fmt@moz-5769BD38.static.tpgi.com.au) (Ping timeout)
[04:28:23] *** Joins: fmt (fmt@moz-5769BD38.static.tpgi.com.au)
[04:30:37] *** Quits: fmt (fmt@moz-5769BD38.static.tpgi.com.au) (Ping timeout)
[04:30:50] *** Joins: fmt (fmt@moz-5769BD38.static.tpgi.com.au)
[04:37:27] *** Quits: Ferreus (ferreus@moz-5B6BD6A2.pools.arcor-ip.net) (Quit: WeeChat 0.4.1)
[07:59:08] *** Quits: SiegeLord (sl@moz-CAF07B4C.hsd1.ma.comcast.net) (Quit: It's a joke, it's all a joke.)
[08:01:51] *** Joins: pnkfelix (pnkfelix@7AF98CCC.7F57627B.81A53753.IP)
[08:04:34] *** Quits: jeaye (Jeaye@moz-34FEF2BB.hsd1.ca.comcast.net) (Quit: zzz)
[08:12:20] *** Quits: pnkfelix (pnkfelix@7AF98CCC.7F57627B.81A53753.IP) (Quit: Leaving.)
[08:21:31] *** Joins: brson (brson@72B1AFF8.AD1E507F.3688B332.IP)
[08:29:00] *** Quits: brson (brson@72B1AFF8.AD1E507F.3688B332.IP) (Ping timeout)
[08:30:58] *** Joins: schubidu25 (schubidu25@moz-FAE37203.superkabel.de)
[08:37:13] *** Joins: pnkfelix (pnkfelix@7AF98CCC.7F57627B.81A53753.IP)
[08:47:19] *** Quits: pnkfelix (pnkfelix@7AF98CCC.7F57627B.81A53753.IP) (Ping timeout)
[08:56:27] *** Quits: jxv (jxv@moz-8FB92450.lightspeed.irvnca.sbcglobal.net) (Client exited)
[09:27:23] *** Joins: maik (maik@moz-8782792E.dip0.t-ipconnect.de)
[09:50:59] *** Joins: pnkfelix (pnkfelix@7AF98CCC.7F57627B.81A53753.IP)
[10:01:08] *** Quits: pnkfelix (pnkfelix@7AF98CCC.7F57627B.81A53753.IP) (Quit: Leaving.)
[10:13:22] *** Joins: pnkfelix (pnkfelix@7AF98CCC.7F57627B.81A53753.IP)
[10:32:44] *** Joins: brson (brson@7AF98CCC.7F57627B.81A53753.IP)
[11:11:09] *** Quits: brson (brson@7AF98CCC.7F57627B.81A53753.IP) (Ping timeout)
[11:16:07] *** Joins: glennsl (textual@moz-5D7B804F.getinternet.no)
[11:33:24] *** Joins: dbaupp (Thunderbir@moz-5E75FF5.pa.nsw.optusnet.com.au)
[11:36:57] *** Quits: pnkfelix (pnkfelix@7AF98CCC.7F57627B.81A53753.IP) (Quit: Leaving.)
[11:36:58] *** Quits: dbaupp (Thunderbir@moz-5E75FF5.pa.nsw.optusnet.com.au) (Ping timeout)
[11:41:35] *** Joins: dbaupp (Thunderbir@moz-5E75FF5.pa.nsw.optusnet.com.au)
[11:49:47] *** Quits: maik (maik@moz-8782792E.dip0.t-ipconnect.de) (Ping timeout)
[11:55:09] *** Joins: maik (maik@moz-A3335658.dip0.t-ipconnect.de)
[11:58:42] *** Quits: maik (maik@moz-A3335658.dip0.t-ipconnect.de) (Ping timeout)
[12:06:32] *** Quits: dbaupp (Thunderbir@moz-5E75FF5.pa.nsw.optusnet.com.au) (Ping timeout)
[12:13:55] *** Joins: canhtak (jeremy@moz-13BC3BC0.wl.t.ulaval.ca)
[12:26:10] *** Quits: nielsle (nielsle@moz-5CE8ECCD.boa.fiberby.dk) (Quit: Ex-Chat)
[12:54:54] *** Quits: timot (timot@moz-9EF21B1.cust.tele2.se) (Ping timeout)
[12:55:13] *** Joins: timot (timot@moz-9EF21B1.cust.tele2.se)
[13:03:23] *** Joins: pnkfelix (pnkfelix@7AF98CCC.7F57627B.81A53753.IP)
[13:03:31] *** Quits: pnkfelix (pnkfelix@7AF98CCC.7F57627B.81A53753.IP) (Input/output error)
[13:32:02] *** Joins: pnkfelix (pnkfelix@7AF98CCC.7F57627B.81A53753.IP)
[13:33:08] *** Quits: pnkfelix (pnkfelix@7AF98CCC.7F57627B.81A53753.IP) (Quit: Leaving.)
[13:47:54] *** Joins: mib_1ermwc (Mibbit@moz-FCF1ABDB.icpnet.pl)
[13:55:18] *** Quits: mib_1ermwc (Mibbit@moz-FCF1ABDB.icpnet.pl) (Quit: http://www.mibbit.com ajax IRC Client)
[13:58:18] *** Joins: tiffany (kawaii@moz-28A8742A.dhcp.embarqhsd.net)
[14:02:06] *** Joins: brson (brson@7AF98CCC.7F57627B.81A53753.IP)
[14:05:50] *** Quits: brson (brson@7AF98CCC.7F57627B.81A53753.IP) (Ping timeout)
[14:09:00] *** Joins: brson (brson@7AF98CCC.7F57627B.81A53753.IP)
[14:21:49] *** Joins: maik (maik@moz-A3335658.dip0.t-ipconnect.de)
[14:31:40] *** Quits: canhtak (jeremy@moz-13BC3BC0.wl.t.ulaval.ca) (Quit: canhtak)
[14:37:18] *** Quits: brson (brson@7AF98CCC.7F57627B.81A53753.IP) (Ping timeout)
[14:58:53] *** Quits: maik (maik@moz-A3335658.dip0.t-ipconnect.de) (Ping timeout)
[15:08:36] *** Joins: Ferreus (ferreus@moz-6DE70CF8.pools.arcor-ip.net)
[15:11:00] *** Joins: pnkfelix (pnkfelix@7AF98CCC.7F57627B.81A53753.IP)
[15:14:18] *** Quits: pnkfelix (pnkfelix@7AF98CCC.7F57627B.81A53753.IP) (Quit: Leaving.)
[15:20:50] *** Joins: FrozenCow (FrozenCow@moz-B2DF4929.chello.nl)
[16:08:41] *** Joins: pcwalton (pcwalton@79611EE9.A51CB73B.6FBF6D51.IP)
[16:08:41] *** ChanServ sets mode: +qo pcwalton pcwalton
[16:23:04] *** Quits: pcwalton (pcwalton@79611EE9.A51CB73B.6FBF6D51.IP) (Ping timeout)
[16:30:41] *** Joins: nielsle (nielsle@moz-5CE8ECCD.boa.fiberby.dk)
[16:59:54] *** Quits: tiffany (kawaii@moz-28A8742A.dhcp.embarqhsd.net) (Ping timeout)
[17:01:40] *** Joins: tiffany (kawaii@moz-EB8B0C08.dhcp.embarqhsd.net)
[17:33:41] *** Joins: CarpNet (Alasdair@moz-EF831A5E.cable.virginmedia.com)
[17:38:00] *** Joins: rusti (rusti@7EA5F9ED.C1499D0.396E4C6D.IP)
[17:39:27] *** Joins: dandy (Dandy@moz-84CC8377.hsd1.co.comcast.net)
[17:40:18] *** Joins: Luqman (laden@moz-AB7945E9.csclub.uwaterloo.ca)
[17:41:57] *** Joins: doomlord_ (servitor@moz-728E30A7.range109-151.btcentralplus.com)
[17:42:02] <doomlord_> hi
[17:42:11] <dandy> howdy
[17:42:35] <doomlord_> so my suggestion of a common set of geometry types comes from bitter workplace experience :)
[17:42:35] <dandy> bjz_, what to you think of some common ground?
[17:42:50] <doomlord_> and it is one of the  biggest factors that drove me to find rust
[17:43:38] *** Joins: Toussa (Mibbit@moz-3717830C.adsl.alicedsl.de)
[17:43:48] <bjz_> the difficulty is there are lots of ways to do things like extents, with different plusses or minusses
[17:43:49] <dandy> kimundi, inlining is also a nice bonus, makes converting much easier ... if only somebody tested it to verify the ASM looks good :)
[17:43:51] <doomlord_> i could imagine a sliding scale of standardization.. just like everyone accepts some features from the language like float maths
[17:44:15] <dandy> bjz_, what about just common traits?
[17:44:17] <doomlord_> true, you can represnt an AABB as centre+size instead of min and max
[17:45:12] <kimundi> dandy: Inlining is kinda guaranteed in-crate, and between crates if you slap a #[inline] onj it. llvm has unit tests that make sure that a lot of these cases are getting inlines afaik
[17:45:41] <dandy> kimundi, I'm lazy enough to accept that as is
[17:45:58] <bjz_> also some people might want Vec3([T,..3])
[17:46:15] <bjz_> (which would be amazing if we had properties
[17:46:17] <bjz_> )
[17:46:48] <bjz_> common traits would be nice
[17:47:11] <bjz_> it's a super difficult problem (not saying it isn't solvable though)
[17:47:14] <kimundi> struct Foo{ a: f32, b: f32 } struct Bar { x: f32, y: f32 }; impl Foo { to_bar(&self) -> Bar { Bar { x: self.a, y: self.b } } } // This will be inlined to neither use a function call nor a memory reference if called on a value
[17:47:55] <doomlord_> i bet many people have an equivalent struct Vec3<T> { x:T,y:T,z:T} already though
[17:48:17] <doomlord_> i'd bet thats the one most people go for
[17:48:22] <dandy> doomlord_, yeah but the point kimundi is making is that x86 has no idea what a Vec3 is
[17:48:29] <bjz_> I mean, it would be great if this kind of thing could be founded in mathematics, ie. abstract algebra. that stuff doesn't change
[17:48:35] <kimundi> Is that the point I'm making?
[17:48:45] <dandy> yes
[17:49:03] <dandy> its just some f32s in ram
[17:49:09] <kimundi> Ah, my point is that it's just a pair of f32 once llvm runs a few optimization passes over it. :)
[17:49:12] <dandy> its all about how the compiler views it
[17:49:22] <kimundi> right
[17:49:53] <dandy> doomlord_, you are right though, we are supper redundant
[17:50:11] <doomlord_> i like the fact rust allows this to be decoupled
[17:50:22] <kimundi> llvm will inle the function call, remove pointer indirection if unneccessary, cut up structures into their composite parts, reorder/remove code that'S unused etc
[17:50:35] <doomlord_> in C++ you're stuck with it, if you build classes, they're much harder to decouple
[17:51:04] <doomlord_> if3 people all make a slightly different class Vec3 { ... } .. much harder to make their code interop
[17:51:21] *** Joins: SiegeLord (sl@moz-CAF07B4C.hsd1.ma.comcast.net)
[17:51:48] <kimundi> Just the fact that you can declare an entirely fresh type that wraps another one without it meaning pointer indirection or any other kind of overhead gives you a lot of flexibility.
[17:52:05] <doomlord_> early on, personally i'm tempted to use named functions prefixed with 'v' (easy autocomplete) for vector maths .. but i wouldn't expect everyone else to want to use those
[17:52:23] <dandy> doomlord_, nope :)
[17:52:25] <doomlord_> habitts that go back to my C days
[17:52:27] <bjz_> nope
[17:52:53] <bjz_> I see folks around usin m_ on structy fields -_-
[17:53:08] <bjz_> heh, 'structy'
[17:53:10] <doomlord_> but right now working without an IDE , those old techniques are handy (eg i definitely prefer a gl binding that has the identical names as in C for the same reason)
[17:53:22] <doomlord_> not a fan of m_ myself
[17:53:52] <dandy> doomlord_, there should be something soon
[17:54:06] <dandy> would be so neat to get something jetbrains
[17:54:13] <doomlord_> but with a shared geomtypes ... i can still use my obscure vmadd or whatever and make my code interoperate with others
[17:54:44] <doomlord_> an IDE is difficult, the AST isn't up to it yet from what i understand
[17:54:45] <dandy> I guess this conversation is does doomlord_ make wrappers or do we all make some common traits?
[17:55:17] <doomlord_> how about both :) the common structs and traits for accessing them.. its just a module of common declarations i'm proposing - 
[17:55:18] <dandy> if we do make common traits is that a shared repository? What kind of fights will result?
[17:55:31] <doomlord_> how those declarations interact is left to other modules
[17:55:55] <doomlord_> would they resist this ending up in libextra
[17:56:05] <doomlord_> would this have utility for servo (it must have point2 etc for layout)
[17:56:14] <bjz_> it does
[17:56:19] <dandy> doomlord_, that would make sense
[17:56:26] <dandy> libextra
[17:56:44] <dandy> at least for coordinate types and matricies
[17:56:45] <kimundi> doomlord_: Yes and No. extra is planned to turn into just a reexport of a lot of externally managed git repositories that are officially blessed as a useful part of the rust distribution :)
[17:57:31] <kimundi> And I bet having a common vector/matrix math library is exactly what it would get used for
[17:57:42] <doomlord_> ok nice
[17:57:57] <doomlord_> is there anywhere its worth recording this suggestion
[17:58:02] <doomlord_> mailing list..
[17:58:07] <doomlord_> open an issue..
[17:58:28] <dandy> I don't know... reddit too?
[17:58:43] <dandy> this is not the  sort of thing that would be worked out in issue comments though
[17:59:00] <dandy> I would love to have somebody else make Mat4<T> for me
[17:59:02] <doomlord_> in my last workplace, we got through at least 4 vector incompatible maths classes :) ...all compiling to the same underlying type in hardware
[17:59:31] <dandy> especially Mat4<T>::invert()
[17:59:56] <doomlord_> even if the final names are slightly different, i would probably use the
[17:59:59] <doomlord_> them^
[18:00:12] <dandy> I would probably use them too!
[18:00:12] <doomlord_> Mat4<T> could be a struct of axis vectors
[18:00:28] <bjz_> That's what I have
[18:00:29] <doomlord_> thats the one i'd use - but you'd have to cater for those who like it as an array aswell
[18:00:47] <doomlord_> this is definitely a case where a trait would be nice aswell
[18:00:59] <dandy> doomlord_, not if we do things based on trait 
[18:01:00] <doomlord_> a trait of axis vector acessors
[18:01:08] <dandy> have a blessed struct that implements the traits
[18:01:21] <dandy> and if I don't like your struct I can make my own and implement the same traits
[18:01:22] <doomlord_> right, a simple default
[18:01:36] <dandy> so I can hate you and still work with you
[18:01:36] <bjz_> but you have to consider that what we want is GameDev related, but other folks want Mathematics/Simulation/Science types
[18:01:51] <dandy> bjz_ but Mat4 is Mat4
[18:02:24] <dandy> why would I care about it so long as it work (and well)
[18:02:55] <bjz_> depends on the optimisations you want, and the API you want to design
[18:03:14] <dandy> any examples that would split hairs?
[18:03:47] <bjz_> Well sebcrozet is going heavily n-dimensional
[18:04:07] <doomlord_> one potential refinement is different precision for axes and position in a matrix that is an objects orientation
[18:04:09] <dandy> so they don't care about Mat4 then right?
[18:04:12] <dandy> at all
[18:04:35] <bjz_> for science stuff Mat4 really isn't useful
[18:04:37] <doomlord_> i think n-dimentional is a different library
[18:04:43] <dandy> bjz_, sure it is
[18:04:58] <doomlord_> i'd be surprised if any graphics programmers would object to special casing 2,3,4 elems
[18:05:14] <doomlord_> although some like to derive them from an N-d base
[18:05:29] <bjz_> you want [[T,..n],..n] right? Now if we could specialise trait impls, that would be fine
[18:05:39] <dandy> https://github.com/aarondandy/pigeoid/blob/master/src/Pigeoid.Core/CoordinateOperation/Transformation/Helmert7Transformation.cs#L159
[18:05:40] <bjz_> and could parameterise over consts
[18:06:15] <doomlord_> when you start seeing all the permuations that could open up with operations returning 'Option' ...
[18:06:15] <dandy> https://github.com/aarondandy/pigeoid/blob/96438b0ba75867f65f553db6453c514be2d7a4b5/src/Pigeoid.Core/CoordinateOperation/Transformation/MolodenskyBadekasTransformation.cs#L28
[18:06:22] <doomlord_> .. i think thats harder to standardize..
[18:06:28] <bjz_> but at the moment we are facing difficulties with Rust's generic capabilities
[18:06:29] <dandy> I can use them for GIS projections
[18:06:33] <doomlord_> but the underlying types are easy
[18:07:23] <doomlord_> what wold you call a trait to acess x,y,z 
[18:07:36] <doomlord_> IVec3 .. TVec3 ... Vec3Able ... Xyz ...
[18:07:54] <dandy> CoordinateTriple
[18:09:12] <doomlord_> bjz_ i see you have AABB as centre and size :)
[18:09:18] <dandy> bjz_, what difficulties
[18:09:52] <doomlord_> i'd be happy to change whatever name i use for either case, i would suggest both structs (min/max and centre/size) be available
[18:10:29] <bjz_> dandy: trait overloading/specialisation. inability to parameterise over consts.
[18:10:39] <dandy> you could do Aabb3 -> Aabb and Aabb2 -> Aabr ... thats where stuff gets tricky
[18:11:04] <bjz_> doomlord_: that's not set in stone - re my aabb struct
[18:11:21] <doomlord_> there's definite arguments for both to exist
[18:11:21] <bjz_> doomlord_: haven't got around to it yet
[18:12:18] <bjz_> Hpw would geometric algebra fit in, if at all?
[18:12:36] <doomlord_> another module entirely i think :)
[18:13:14] <dandy> sounds like doomlord_ is talking about a cgcore crate
[18:13:35] <bjz_> dandy: yep
[18:13:53] <dandy> and I think that would be cool, I would referene that in my crate for sure
[18:13:58] <bjz_> (geometric algebra being a generalisation of linear algebra)
[18:14:26] <bjz_> dandy: cgcore would be cool
[18:14:41] <dandy> bjz_, smei-serious question why Vec and not Vector and why Point and not Pnt?
[18:14:42] <bjz_> dandy: cgcore that would give a definite focus on computer graphics
[18:14:50] <doomlord_> beween 'vector maths' and 'physics engine' .. i see a 'geometry library'
[18:14:58] <bjz_> dandy: good point :P
[18:15:16] <dandy> bjz_, if you become the core of my lib I want to talk about this :)
[18:15:29] <doomlord_>  geometry types -->   vector maths --> geometry library -->  physics engine
[18:15:31] <dandy> and here is where this common stuff gets hairy...
[18:15:48] * bjz_ finds putting things in boxes really tricky
[18:15:57] <doomlord_> 'geometry library' - planes, lines ,spheres etc
[18:15:58] <dandy> I have to go take care of personal hygiene, I'll be back later
[18:16:15] <bjz_> sorry for the apparent hosility :(
[18:16:25] <dandy> none seen
[18:17:05] <doomlord_> do we clash with Vec for dynamic arrays in rust..
[18:17:07] <dandy> I think this would be really cool, ... just naming things is hard
[18:17:17] <bjz_> I've been debating this whole thing in my head for a while. look over the history of cgmath
[18:17:35] <bjz_> it's tumultuous
[18:17:53] <doomlord_> in some ways i'd like maths that just uses [T,..3] as the underlying type, but i'm not sure how that works out in rust
[18:18:08] <doomlord_> avoid naming :) its just square brackets :)
[18:18:29] <bjz_> from 'dumb' traits to macrofied horror, to an attempt at mathematical purity, then back to dumb traits
[18:19:14] <bjz_> I've tried seperating my lib into 'pure' linear algebra and cg stuff
[18:19:25] <bjz_> but found it easier just to bundle it
[18:20:00] <bjz_> because the stuff I was doing in linear algebra wasn't generic enough to be useful for folks in machine learning for example
[18:20:41] <doomlord_> i definitely see cgmaths and n-d linear algebra as seperate libraries
[18:21:10] <doomlord_> cg.. anything spatial really
[18:21:49] <bjz_> I went back to 'dumb' traits because of the difficulties with Rust's generic capabilities. ultimitley I would prefer some super high level, abstract represntation based in mathematics, specialising down into concrete types
[18:22:15] <doomlord_> picking the right level of abstraction seems to be an art
[18:22:16] <bjz_> but at the moment I have trouble seeing how you can do that with Rust as it stands
[18:22:31] <bjz_> aye
[18:23:10] <doomlord_> sometimes you can actually end up with abstracted code being largeer than the output assembly, in the case whree you have decent SIMD instructions :)
[18:23:30] <bjz_> doomlord_: if we wanted something super beautiful we woulf have to end go to idris or agda
[18:25:38] <bjz_> doomlord_ dandy: one thing that is important to look at is the journey with Concepts that the C++ guys have taken. They've gone from hundreds of concepts specified in the c++0x proposal, to a dozen
[18:26:06] <doomlord_> i haven't seen any of that, any links?
[18:26:25] <bjz_> http://www.youtube.com/watch?v=0avh39CI_ls
[18:26:32] <bjz_> http://www.youtube.com/watch?v=WmxhlPXJ-OM
[18:26:41] <bjz_> long watch, but worth it
[18:27:25] <bjz_> also: http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2013/n3701.pdf
[18:27:32] <bjz_> that's their proposal
[18:28:36] <doomlord_> do you prefer to do colours as a different struct again  r,g,b,a instead of x,y,z,w .. or no preference
[18:29:14] <doomlord_> re-using the same implementations for arithmetic on colour values is a big use of Vec<T>
[18:29:36] <bjz_> doomlord_: different struct
[18:29:49] <doomlord_> (i suppose numeric indices might be nice there .. )
[18:30:08] <doomlord_> i've enjoyed the ability to use Vec4<u8> for 32bit RGBA
[18:30:14] <kimundi> I guess that's something where "abstract with traits" would do well
[18:30:29] <doomlord_> definitely . and of course thers' 565 .. 
[18:30:29] <cmr> bjz_: Do you think Rust's current type system is sufficiently expressive?
[18:30:40] <bjz_> cmr: no
[18:30:50] <kimundi> trait RGBAColor { fn get_r(); fn set_r(...) ... }
[18:30:59] <cmr> good :D
[18:31:05] * cmr is glad he isn't the only one
[18:31:36] <bjz_> cmr: at least not for beutiful generic APIs. it is very expressive in some ways, but extremely awkward in others
[18:31:45] <cmr> It's great for simple things but once you try to do anything complex it falls apart.
[18:32:03] <kimundi> Vec4<u8> <-> u32 could be done with extension traits that provide conversions using transmute
[18:32:20] <bjz_> cmr: it falls apart when you want to do something the language designers hadn't thought of
[18:32:34] <kimundi> Isn't that always the case? :P
[18:32:42] <bjz_> cmr: that's the amzing quality of C++
[18:33:23] <bjz_> kimundi: lisp doesn't
[18:33:43] <bjz_> kimundi: but then again, that is also its undoing
[18:33:49] <cmr> bjz_: I call bull
[18:33:58] <kimundi> well, I guess it depends on how you define "not having thought of"
[18:33:59] <cmr> their designers clearly thought of *everything* :p
[18:34:04] <bjz_> cmr: haha
[18:34:28] <kimundi> If the design is to be able to do whatever you want, then in a way it has been thought of :D
[18:34:45] *** Joins: jeaye (Jeaye@moz-34FEF2BB.hsd1.ca.comcast.net)
[18:36:47] <bjz_> cmr: the great fear I have is that it will be hard to 'grow' rust. In the sense of Guy Steele's talk at that Java conference.
[18:37:03] <cmr> Which talk?
[18:37:13] <bjz_> 'Growing a Language'
[18:38:04] <bjz_> but maybe we need to think of Rust in terms of a DSL, as opposed to something ultra expressive
[18:40:20] <bjz_> cmr: http://www.youtube.com/watch?v=_ahvzDzKdB0
[18:44:04] <bjz_> but yeah, I am very naive and want this stuff to be proved wrong.
[18:44:47] <dandy> back, I'm catching up on the conversation
[18:45:09] <bjz_> dandy: I kind of derailed stuff. sorry :(
[18:46:20] <dandy> ifwe had a num.rs or ops.rs for basiccg stuff I think that would be neat-o
[18:46:47] <dandy> typical geometry stuff*
[18:47:28] <bjz_> one thing that must be considered is how fine-grained you want your traits to be
[18:47:53] <dandy> less is better there I think
[18:47:57] <dandy> the basics of what you need
[18:48:12] <dandy> i think a vector needs x,y,z (xy  xyzw)
[18:48:33] <dandy> the implementation of Vec2<T> needs some perp_ stuff
[18:48:43] <dandy> weather that is standard or not... dunno
[18:48:52] <dandy> but a default implementation of the traits could have that
[18:48:55] <doomlord_> part of this idea is there is no THE implementation :) 
[18:49:27] <dandy> doomlord_, but people are lazy and the ones that strike out on their own will reinvent that wheel nomatter what you do
[18:49:30] <bjz_> do you want to do it in terms of algebraic spaces, or in terms of the machine types
[18:49:47] <bjz_> like: IntVec, FloatVec
[18:49:50] <dandy> bjz_, human friendly but if the machine likes it thats cool too
[18:50:03] <dandy> I'm really liking the generics
[18:50:15] <dandy> but it would be nice if we could do something like "when T is int we implement this way"
[18:50:16] <bjz_> or VectorSpace, InnerProductSpace, EuclideanSpace
[18:50:24] <doomlord_> i see it as algebraic,but the ones you want to use a lot happen to be machine types
[18:50:37] <bjz_> doomlord_: I want algebraic traits
[18:50:55] *** Quits: rusti (rusti@7EA5F9ED.C1499D0.396E4C6D.IP) (Ping timeout)
[18:51:28] <dandy> what are the pros n cons?
[18:51:41] <doomlord_> There's a potential difference between Vec3 *unaligned* and 'something with Vec3 semantics, but padded out to fill a 128bit vector register '
[18:52:02] <doomlord_> you needed both on the previous generation of consoles
[18:52:19] *** Joins: rusti (rusti@7EA5F9ED.C1499D0.396E4C6D.IP)
[18:52:32] <bjz_> doomlord_: then you might have two base types right?
[18:52:35] <doomlord_> (float x,y,z was actually faster in some situations than the vectorized x,y,z,pad)
[18:52:43] <doomlord_> yes; can't see a way around that
[18:53:19] <dandy> bjz_ whats wrong with impl Vec3<f64> for FloatVec3 and impl<T:...> Vec3<T> for Vec3
[18:53:39] <doomlord_> you certainly need to be able to precisely specify an in memory representation , including knowledge of alignment
[18:53:56] <doomlord_> values used for intermediate calcualations might be different
[18:54:37] <doomlord_> perhaps if you want the padded aligned version you should just use Vec4 , and set w=0 or 1
[18:54:38] <dandy> impl<T:...> Vec3Trait<T> for Vec3<T> I guess...
[18:54:40] <bjz_> dandy: you have Vec3 twice
[18:55:11] <doomlord_> but the hardware had a different 'dot3', 'dot4' instruction, and you wanted to be able to call either
[18:55:27] <doomlord_> so you had something that was semantically a vec3, but in a 128bit register..
[18:55:49] <doomlord_> and of course that interacted with matrices differentlky
[18:57:59] <dandy> in .NET I would have IVector<T> but the I prefix isn't a rust thing of course, what would you name such a trait?
[18:58:06] * bjz_ has a headache
[18:58:15] <bjz_> no
[18:58:26] <doomlord_> i like the 'I' prefix for interface, i would like to know the answer to this too :)
[18:59:40] <doomlord_> my first instinct is to suggest struct Vec3<T> {} and trait IVec3 { ..accessors for x,y,z }
[18:59:49] <dandy> imp<T:...> cgcore::Vec3<T> for mycrap::Vec3<T> { ?
[19:00:06] *** Joins: lbergstrom (Adium@moz-7DDD1300.ifiber.telenet-ops.be)
[19:00:20] <dandy> I don't think IVec3 would be well received
[19:01:09] <dandy> otherwise I think we would have IAdd<RHS,Result> in num.rs
[19:01:12] <dandy> err... ops.rs
[19:01:51] <doomlord_> i'd be happy to search replace change it later when a better name appears
[19:02:06] <bjz_> no, I* is not a rust convention
[19:02:34] <bjz_> for better or for worse
[19:02:56] <doomlord_> would Vec3 be better as the trait name, and rename the struct something else ?
[19:03:10] <bjz_> if you want to look for inspiration, I'd reccomend venturing into haskell land as opposed to C# land
[19:03:13] <dandy> i would totally have a pub struct Vec3<T>
[19:04:00] <doomlord_> what would this trait contain- beyond accessors for x,y,z
[19:04:14] <dandy> very good question
[19:04:14] <doomlord_> perhaps permutes implemented as defaults
[19:04:20] <bjz_> so Vec3 describes a concrete, coordinate based representation?
[19:04:32] <dandy> bjz_, maybe?
[19:04:40] <bjz_> Vector is coordinate free
[19:05:48] <doomlord_> in bits of code i've started i've started using the I Prefix for things that are just a series of accessors for a very similar struct
[19:06:07] <doomlord_> if there's a better convention for this id be happy to switch
[19:06:21] <dandy> i don't think there is but it seems I is already rejected
[19:06:37] <doomlord_> if its rejected does that mean someone has a better idea already :)
[19:06:42] <dandy> there just isnt any of that in rust
[19:07:15] <doomlord_> struct Mesh {  [Vertex], [Polygon] }     trait IMesh { get_vertex() , get_polygon()  }    .. i have a lot of pairings like this
[19:07:23] <bjz_> dandy: rust naming conventions probably follow the Haskell style
[19:07:24] *** Parts: Toussa (Mibbit@moz-3717830C.adsl.alicedsl.de) ()
[19:07:40] <dandy> I'll have to look at that after minecraft
[19:07:51] <bjz_> doomlord_: but that would be a direct impl on the Mesh type
[19:08:25] <doomlord_> it would - but making it IMesh gave me some leeway to use other representations
[19:08:26] <bjz_> but that wouldn't satisfy your desire for interop
[19:08:35] <doomlord_> its just the 'Mesh' is the simplest
[19:08:54] *** Quits: lbergstrom (Adium@moz-7DDD1300.ifiber.telenet-ops.be) (Quit: Leaving.)
[19:09:01] <doomlord_> ok the suggestion for interop is on the parts we can definitely easily agree on :)
[19:09:20] <bjz_> well then you'd have struct MeshA; struct MeshB; trait Mesh;
[19:09:25] <doomlord_> i'd certainly switch to a different name for IVec3 in the name of interop - its just what was easiest for me to start with
[19:10:38] <dandy> impl<T:> Vec3<T> for VecGen3<T> {
[19:10:57] <doomlord_> trait Vec3 {} .... struct SVec3 {}  /*struct-vec3 */   ... or struct CVec3 {} /*concrete vector */??
[19:11:15] *** Quits: glennsl (textual@moz-5D7B804F.getinternet.no) (Ping timeout)
[19:11:35] <doomlord_> Vec3_s (probably not..)
[19:11:44] <bjz_> trait VectorSpace; struct Vector3;
[19:12:28] <bjz_> Vector3 being the concrete representation of a VectorSpace
[19:12:51] <doomlord_> what would you see VectorSpace having
[19:12:53] <dandy> does vectorspace have a fn magnitude() -> T or is that a trait HasMagnitude
[19:13:12] <doomlord_> would we need VectorSpace3 , VectorSpace2  .. or would it be abstract dimention..
[19:13:15] <dandy> segments and line strings have magnitude too
[19:13:26] <bjz_> no, that would probably be the property of a EuclideanSpace
[19:14:06] *** Quits: rusti (rusti@7EA5F9ED.C1499D0.396E4C6D.IP) (Ping timeout)
[19:14:10] <bjz_> VectorSpace, as I had it, was just a set of constraints defining things like Zero and ScalarMul etc.
[19:14:12] <doomlord_> woudl you suggest Vector2 implementing VectorSpace with z=0
[19:14:24] *** Joins: Turmin (Mibbit@moz-207894D2.dhcp.mdsn.wi.charter.com)
[19:14:28] <dandy> feels dirty
[19:14:37] <dandy> why not just assume 0?
[19:14:46] <dandy> if you know you are dealing with a vector2?
[19:15:00] *** Joins: glennsl (textual@moz-5D7B804F.getinternet.no)
[19:15:01] <bjz_> dandy: http://en.wikipedia.org/wiki/Euclidean_space
[19:15:26] *** Quits: Turmin (Mibbit@moz-207894D2.dhcp.mdsn.wi.charter.com) (Quit: http://www.mibbit.com ajax IRC Client)
[19:16:32] <doomlord_> my starting point would have been (open to rename)   trait IVec3 { x(),y(),z() /* accessors*/} ;    struct Vec3 {x,y,z} ... then you are at liberty to impl IVec3 for Vec2 aswell , with z=0, if you like..
[19:16:49] <doomlord_> trait IVec3  -> implement accessors for packed 32bit normals ... whatever
[19:17:11] <bjz_> doomlord_: what about EuclideanArray?
[19:17:36] <doomlord_> is there a way of collecting a vote on such a thing
[19:17:57] <bjz_> we're not really at the voting stage
[19:18:10] <bjz_> still working through the problem :P
[19:19:00] <bjz_> dandy: see as you know, I have Array as defining something with an index
[19:19:12] <doomlord_> ok one question here still seems to be, does the trait specific the dimention .. i think we do want 2d,3d,4d traits
[19:19:32] <dandy> I think that is important
[19:19:40] <dandy> and perp_dot means what for a 3D vector?
[19:19:54] <bjz_> doomlord_: from an abstract algebra point of view, they should not be specified
[19:20:17] * bjz_ excuse the imprecise language
[19:20:54] <doomlord_> i definitely see utility for an accessor for an x,y,z (or 3 component value) that can be implemented for a plain struct, or a packed d3d normal or 565 color value
[19:21:31] <dandy> what about trait Vec; trait Vec3 : Vec
[19:21:51] <dandy> obviously Vec is terrible though
[19:21:51] <doomlord_> Vec { get_dimention(), get_compoentn(i) ; ?
[19:22:08] <dandy> because what about confusion with [1,2,3]
[19:22:19] <doomlord_> yeah sure
[19:22:23] <dandy> bjz_, what do you mean by " I have Array as defining something with an index"
[19:22:25] <tiffany> what about the Index trait?
[19:22:44] <doomlord_> hehe. always frustrated by the conflicting use of 'vector' for 2 very common things :)
[19:22:55] <tiffany> also, are there plans for rust to have getter/setter  syntax inside of traits, so you can do .x on a Vec trait?
[19:23:06] <bjz_> dandy: https://github.com/bjz/cgmath-rs/blob/master/src/cgmath/array.rs#L20
[19:23:18] <bjz_> tiffany: I don't think so :(
[19:23:45] <bjz_> dandy: Slice is a hack around the fact we can't parameterise over constants
[19:25:38] <bjz_> dandy: so in this, a Vector3<T> would implement Array<3, T> and VectorSpace<T> (if we could parameterise over consts)
[19:25:41] <dandy> I'm so confused by all this
[19:25:56] <dandy> bjz_, yeah thats cool
[19:26:01] <dandy> but... what about v.x
[19:26:25] <dandy> really v.x is just an alias for index 0 but I like thinking in terms of xyz
[19:26:37] <bjz_> Well, that describes a value along an axis in euclidean space
[19:27:18] <dandy> yeah, I just want to call it x instad of index 0\
[19:27:22] <doomlord_> sorry to repeat but do you see VectorSpace being x,y,z always .. or would we need VectorSpace2, VectorSpace3
[19:27:31] <bjz_> doomlord_: no
[19:27:46] <bjz_> doomlord_: VectorSpace would be representation independant
[19:28:22] <doomlord_> oh so it does not expose accesors , just the operations that a space needs
[19:28:37] <doomlord_> ok and thats why you suggest 'impl Array<3,T>', fair enough
[19:28:53] <doomlord_> id' go with that
[19:29:30] <doomlord_> it wouldn't have been my first suggestion but i'd use that
[19:29:40] <bjz_> doomlord_: this is the advantage of attempting to go withe mathematical concepts
[19:30:50] <bjz_> but the disadvantage is there are times where Rust has trouble expressing them
[19:31:00] <doomlord_> trait Array3 
[19:31:01] <doomlord_> perhaps
[19:31:05] <bjz_> yep
[19:31:09] <doomlord_> until rust can do Array<T,N>
[19:31:10] <bjz_> that is a possibility
[19:31:22] <dandy> also I would rarely want a VectorSpace and would most often want a Array<3,T>
[19:31:39] <doomlord_> Perhaps those traits Array3 etc would ahve utility elsewhere
[19:32:11] <doomlord_> its sounding like VectorSpace is some operations, and ArrayN is accessors
[19:32:50] <bjz_> doomlord_: well a matrix is a Array<N, Array<M, T>>
[19:33:24] <doomlord_> yes; 
[19:33:26] <bjz_> doomlord_: A Point3 is an Array<3, T>, but not a VectorSpace
[19:34:06] <doomlord_> i guess even if we make Vec3 { x,y,z}   Matrix3 { ax,ay,az} .. and they both impl Array3 .. you get Array3<Array3<T>> aswell
[19:34:18] <bjz_> yep
[19:34:55] <bjz_> it falls out if you design it right
[19:35:15] <doomlord_> i suppose  Array3 {} have .len() =3,  and alot of other thigns in common with vector collections..
[19:35:37] <doomlord_>                 ^has
[19:35:53] *** Joins: maik (maik@moz-A3335658.dip0.t-ipconnect.de)
[19:35:56] <bjz_> yep, it's a shame they chose to call [T] vectors
[19:36:05] <doomlord_> DynamicArrays :)
[19:36:27] <doomlord_> i guesss they're way more common in programming so deserve a short name
[19:36:33] <dandy> what does Array3 have that a [..3] does not?
[19:37:01] <doomlord_> i dont think anything, but its a trait so can be used for generic code
[19:37:09] <dandy> right...
[19:38:05] <bjz_> Well, Array should probably have an index accessor, and a length. probably that's it. but you'd want other things for conveniance
[19:38:05] <doomlord_> Array is nicer for exposing whats common between x,y,z or r,g,b 
[19:39:05] *** Quits: schubidu25 (schubidu25@moz-FAE37203.superkabel.de) (Client exited)
[19:39:35] <doomlord_> heh. do you have a vector of arrays, or an array of vectors ... arrghhhh
[19:40:01] <bjz_> ?
[19:40:13] <bjz_> what do you mean?
[19:40:14] <dandy> yeah I didn't think about that, I may want to multiply a color by a matrix
[19:40:17] <dandy> thats a thing...
[19:40:35] <doomlord_> just pointing out the conflicting naming possible.
[19:40:40] <dandy> in that case a color with x,y,z,w makes no sense
[19:40:49] <dandy> I guess the x,y,z stuff needs to be its own trait entirely
[19:40:58] <doomlord_> 'vector'<->'array' .... x,y,z<->[...]
[19:41:09] <dandy> or a wrapper around indices
[19:41:46] <doomlord_> i woudl still be tempted to specify colours as Vec4<u8> , but if that just impl's Array4 .. any generic code knows no different
[19:42:01] <dandy> x,y,z<->'array'
[19:42:08] <dandy> x is just an alias for the first index
[19:42:15] <dandy> but its an alias I really like and use often
[19:42:36] <dandy> my brain does not do well when there is [1] [0] [2] [1] [2] [2] [0] [1] all over the place
[19:43:16] <doomlord_> seems to me a trait Array3 {} is something that would be universally useful, that few could argue with
[19:43:34] <bjz_> that's why I suggested EuclideanArray
[19:44:21] <dandy>  EuclideanArray has len() ?
[19:44:41] <doomlord_> are you saying Euclidean Array would ahve those aliases  .x() = [0] etc
[19:44:59] <bjz_> doomlord_: yah
[19:45:14] <bjz_> x, y, z
[19:45:22] <tiffany> you'd hate my code to draw voxels, dandy
[19:45:37] <bjz_> Array2 would just have z = 0
[19:45:45] <bjz_> woops
[19:45:50] <bjz_> Vector2
[19:45:50] <tiffany> it's in C, and my vector code uses float pointers, and there's a lot of vector indexing
[19:46:09] <dandy> wouldnt Vector2 have anything that is not x,y as 0 (not just z)
[19:46:35] <doomlord_> ARray2 or Vector2.. would  trait Vector2{} and struct Vec2 {} would be confusing, or is that the compromise to get around 'IVec2' ..
[19:46:38] <dandy> soif it implemented EuclideanArray [0] [1] would return a value but [_] would return 0
[19:46:44] <dandy> Zero::zero()   *
[19:46:57] <doomlord_> oh sorry i misread
[19:47:20] <doomlord_> struct Vector2 ; impl<T> EuclidianArray<T> for Vector2<T> { etc..}
[19:47:55] <bjz_> tiffany: what are your thoughts on this
[19:48:08] <dandy> we need more opinions
[19:48:12] <doomlord_> trait EuclideanArray :  VectorSpace, Array {} ??
[19:48:17] <dandy> and I am confused/playing minecraft
[19:48:43] <tiffany> so a builtin trait that gets .x/.y/.z syntax sugar?
[19:48:46] <bjz_> I think it would be good to have us go off and draw up some ideas, then compare
[19:48:50] <tiffany> if you're going to go that far you should probably add swizzling too
[19:49:01] <bjz_> tiffany: not built in at all
[19:49:09] <dandy> doomlord_,  I thnik it would be more like struct Vec3 {} implementing EuclideanArray and VectorSpace
[19:49:11] <bjz_> tiffany: unfortunately
[19:49:45] <tiffany> oh
[19:49:46] <tiffany> .x()
[19:49:50] <doomlord_> i almost saw this as identifying the common patterns between peoples vector maths libraries and making a module that holds some very simple common ground, if there are some names we can agree on
[19:49:50] <tiffany> that's much less useful
[19:49:53] <dandy> doomlord_, Point (Pnt :) ) would no implement VectorSpace
[19:50:16] <bjz_> tiffany: we are looking at this as a way of bridging between libs
[19:50:34] <bjz_> dandy: correct
[19:50:36] <tiffany> I suppose
[19:50:45] <doomlord_>  i'd agree, if you have .x() .y() .z() , swizzle accessors would be nice there
[19:50:55] <doomlord_> .xy() and so on
[19:51:13] <dandy> .XY() ... sorry but WTF is this?
[19:51:27] <doomlord_> returns [[0],[1]]
[19:51:40] <tiffany> it's a feature of glsl
[19:51:50] <dandy> okay so I can make a 2d vector from 3d ... v2 = v3.xz()? 
[19:52:06] <tiffany> yeah
[19:52:26] <doomlord_> very handy in shader code
[19:52:45] <tiffany> you can do the same effect using matrices
[19:52:46] <bjz_> I think it would be good to have something concrete now, something written down. So that we can have room to think a little deeply. Would you guys like to come back to this in a day or two?
[19:53:10] <doomlord_> is this logged
[19:53:15] <bjz_> yup
[19:53:33] <bjz_> https://botbot.me/mozilla/rust-gamedev/
[19:53:53] *** Quits: glennsl (textual@moz-5D7B804F.getinternet.no) (Ping timeout)
[19:54:00] <dandy> bjz_, yeah, thats good
[19:54:07] <bjz_> https://botbot.me/mozilla/rust-gamedev/msg/6644876/
[19:54:11] <dandy> im going to keep porting my stuff over, practice at least
[19:54:14] <tiffany> I'm always weary of having my irc chat publicly logged
[19:54:17] <tiffany> it shows up in google searches
[19:54:18] <bjz_> cool
[19:54:33] <bjz_> tiffany: heh
[19:54:53] <tiffany> sure it's like on the 47th page behind mountains of irrelevance but still
[19:55:38] <doomlord_> whats more common,, struct Vec3<T> or struct Vector3<T>
[19:55:43] <doomlord_> i like the former
[19:55:53] <bjz_> doomlord_: we don't need to specify that
[19:56:08] <doomlord_> i wouldnt' object to the latter;   i *did* see this appearing in this common module
[19:56:41] <doomlord_> simply because so many people write it :)
[19:56:50] <doomlord_> (but then might diverge on other details)
[19:59:03] <dandy> doomlord_, thats only if we do a default implementation which I think should come after the traits, if at all
[19:59:36] *** Joins: glennsl (textual@moz-5D7B804F.getinternet.no)
[19:59:59] <dandy> but if I have a fn with T:Mul<T,T>,V:VectorSpace+Array3<T> I don't care about the implementation
[20:00:04] <doomlord_> you'd have 2 paths to interoperability
[20:00:18] <dandy> and especially if I can alias for x,y :)
[20:00:37] <doomlord_> if you can re-factor your code to use either the common traits, or the comon concrete struct, then you have increased how interoperable it is
[20:01:06] <dandy> yeah, I just thing traits should come first
[20:01:07] <doomlord_> of coruse the common trait is more versatile, but the common struct is simple
[20:01:30] <dandy> we already have 5+ implementations, if the traits we make fit them all I would say that is a good indicator
[20:01:31] <doomlord_> how many rust vector maths libraries *dont* use a Vec3<T> :)
[20:01:43] <dandy> Mine uses Vector3<T>
[20:01:48] <doomlord_> (or rename to Vector3)
[20:03:22] <dandy> I guess all of them
[20:03:42] <dandy> I think a common impl would be good, im just saying starting with traits is probably a good first step at interop
[20:04:47] <doomlord_> ok i can see that
[20:05:23] <dandy> and given we have multiple opinions and implementations if we can come up with traits that make everybody 90% happy a default impl should "just fall out"
[20:05:30] <doomlord_> i think my point is for the sake of a couple of renames and a common struct we also create a differnt kind of interop for less work, although the trait is way more versatile
[20:05:46] <dandy> yeah both are good
[20:06:03] <dandy> if there was a common vec2-4 and mat2-4 I would totally use that
[20:06:28] <dandy> especially because writing a GOOD mat4::inverse() is not simple
[20:06:33] <doomlord_> does anyon ehere look at the servo code
[20:07:06] <doomlord_> and what does jeaye's q3 look like
[20:07:35] <cmr> codewise or graphicswise?
[20:07:47] <doomlord_> codewise
[20:08:51] <doomlord_> all this makes me think it would be nice to have a trait graph again :)
[20:09:53] <maik> what is a trait graph?
[20:10:09] <doomlord_> just something to generate a graph of trait relationships as part of documentation
[20:12:24] *** Joins: rusti (rusti@7EA5F9ED.C1499D0.396E4C6D.IP)
[20:20:23] *** Quits: maik (maik@moz-A3335658.dip0.t-ipconnect.de) (Ping timeout)
[20:23:21] <doomlord_> https://github.com/mozilla-servo/rust-geom/blob/a23cb0bc99a933efa9104c2471ccd14638744ea4/point.rs#L10-L14
[20:23:42] <dandy> 2D makes me thing double
[20:23:55] <doomlord_> yeah i prefer Point2 aswell
[20:24:04] <doomlord_> Point2i Point2f ...
[20:24:22] <dandy> opengl mental baggage
[20:24:29] <dandy> the d to me is the T
[20:25:03] <doomlord_> type Point2i = Point2<int>; etc.
[20:26:04] <doomlord_> well the last time i did all this in c++ it was TVec3<T> , and Vec3 = TVec3<float>  (small common name for the common case) 
[20:26:44] <doomlord_> but i suspect here Vec3f = Vec3<f32>  would be more logical 
[20:26:52] <dandy> maybe?
[20:27:02] <dandy> I'm more of a f64 person
[20:30:32] <bjz_> https://gist.github.com/bjz/bc7f44dca4826202daf4
[20:30:33] <doomlord_> happy with the prefixes f=f32, d=f64/double and would definitely default to f32 for realtime code, but maybe f64 for offline tools
[20:31:13] *** Joins: erickt (Adium@79611EE9.A51CB73B.6FBF6D51.IP)
[20:31:35] <dandy> why is is trait Array<T> not already STD?
[20:31:53] <bjz_> dandy: it's called 'Vector' -_-#
[20:32:04] <dandy> oh I see...
[20:32:04] <doomlord_> Vec is collections and the language has [T,..N] ?
[20:32:11] <bjz_> yep
[20:32:24] <dandy> List<T> Collection<T> is there not anything like that already?
[20:32:26] <bjz_> Array should have a N, I guess
[20:32:48] <dandy> VectorSpace::Identity() ?
[20:33:00] *** Quits: Yurume (yurume@AC58A8CE.8A059B47.E313B915.IP) (Ping timeout)
[20:33:10] <dandy> ::one()
[20:33:15] <doomlord_> ok just to check , does trait Array<T> correspond to anything already defined in the Vec related collections
[20:33:38] <bjz_> no
[20:33:41] <dandy> doomlord_, I do want to look into that, there are random access iterators
[20:34:15] <dandy> for EuclideanSpace what about w?
[20:34:19] <doomlord_> cut paste this as a question in #rust perhaps
[20:34:31] <dandy> and what about Point, point isnt a vector
[20:34:41] *** Quits: erickt (Adium@79611EE9.A51CB73B.6FBF6D51.IP) (Ping timeout)
[20:35:12] *** Quits: rusti (rusti@7EA5F9ED.C1499D0.396E4C6D.IP) (Ping timeout)
[20:35:22] <doomlord_> i see servo has origin/size aswell for rects instead of min/max
[20:35:33] <bjz_> doomlord_: point is an AffineSpace
[20:35:41] <bjz_> *dandy
[20:35:58] *** Joins: erickt (Adium@79611EE9.A51CB73B.6FBF6D51.IP)
[20:36:27] <bjz_> dandy: w would be something in ProjectiveSpace
[20:36:49] <dandy> yeah, I guess this is cgcore and not *core
[20:36:51] <bjz_> ore might be Homogeneous
[20:38:22] <dandy> what is Field ?
[20:38:37] <bjz_> http://en.wikipedia.org/wiki/Field_%28mathematics%29
[20:39:18] <dandy> uhhh... so numbers we care about?
[20:39:23] <bjz_> yup
[20:39:43] <bjz_> it would be impled for all the builtin numerics
[20:39:55] <bjz_> in cgcore
[20:41:13] <dandy> what about F: Neg<F> + Add<F,F> + ...
[20:41:21] *** Joins: maik (maik@moz-A3335658.dip0.t-ipconnect.de)
[20:41:42] *** Joins: steveklabnik (steveklabn@90E4D93F.93EC364C.1C63AAF3.IP)
[20:42:05] <dandy> what if struct SymbolicMathThing {} does not implement Field ?
[20:42:07] <bjz_> dandy: it's easier for generics if you have collective traits. saves all the writing
[20:42:17] <bjz_> ahh
[20:42:20] <bjz_> yeah :(
[20:42:38] <dandy> it is a huge PITA though
[20:42:56] <bjz_> this is the issue with Rust traits vs C++14 concepts
[20:42:58] <dandy> wonder if that could be a job of macros?
[20:43:35] <bjz_> hey
[20:43:44] *** Quits: steveklabnik (steveklabn@90E4D93F.93EC364C.1C63AAF3.IP) (Ping timeout)
[20:43:58] <bjz_> Field could just be impled globally. like VectorSpace
[20:44:08] <dandy> what do you mean?
[20:44:34] <bjz_> Like impl<F: ...> Field for F {}
[20:44:58] <bjz_> then any type that meets those requirements F: ... would be valid
[20:45:18] <dandy> but what if there is a type that supports +-/ but not sqrt
[20:45:31] <dandy> thats why I have so many different impls https://github.com/aarondandy/vertesaur-rust/blob/master/src/vertesaur/vector.rs
[20:46:15] <bjz_> Fields do not require sqrt.
[20:46:30] <doomlord_> https://github.com/mozilla-servo/rust-geom/blob/master/point.rs
[20:47:04] <doomlord_> ^^^ didn't realise that, you can have fn Point2D and struct Point2D {} ,
[20:47:14] <dandy> Fields sounds like pub trait Num:
[20:47:15] <bjz_> The implementor would have to impl on Real, but that is not a concern of the global traits
[20:47:29] <bjz_> *cgcore traits
[20:47:40] <bjz_> if they needed sqrt
[20:47:43] <dandy> doomlord_, oh neat
[20:48:15] <dandy> Algebraic
[20:48:22] <doomlord_> Point2D::new() is what i'd have expected from other rust code i've seen..
[20:48:23] <dandy> has sqrt and pow
[20:48:36] <dandy> doomlord_, me too, I wonder what is better...
[20:48:42] <cmr> doomlord_: yup. types and values (functions are values) are in their own namespace.
[20:48:47] <cmr> That's a really old style though
[20:48:51] <cmr> All new code uses ::new
[20:48:55] <dandy> with a fn you can say Point2D::<int>(1,2) I think
[20:49:12] <bjz_> dandy: it's old style
[20:49:34] <dandy> cmr mentioned that "new style" will get <int> as well
[20:49:47] <bjz_> dandy: does that makes sense, re. sqrt
[20:50:11] <cmr> Yeah, that code last changed significantly in Sep 10 2012 :p
[20:50:17] <dandy> bjz_ sort of but why not just Algebraic
[20:50:19] <bjz_> dandy: the implementor might have to implement EuclideanSpace on a more constrained type than Field
[20:50:47] <bjz_> dandy: But to keep cgcore open, it would just be on Field
[20:51:01] <dandy> let me read this again I think I missed something
[20:51:38] <dandy> okay... Like impl<F: ...> Field for F {} this explodes my head
[20:51:53] <dandy> can you make an impl for generic not-yet-defined types?
[20:52:40] *** Quits: erickt (Adium@79611EE9.A51CB73B.6FBF6D51.IP) (Ping timeout)
[20:52:49] <cmr> Yes
[20:52:54] <dandy> WOW
[20:53:07] <bjz_> yep
[20:53:07] <cmr> It's not very useful though
[20:53:16] <cmr> Because then you can't implement Field for any other type manually.
[20:53:28] <dandy> so then for magnitude we could say it has to be Field + Algebraic
[20:53:38] <cmr> We need a significant overhaul in that area, I think specificity a la CSS would be useful.
[20:53:48] <dandy> cmr if we just use it as an alias for existing traits though?
[20:53:48] <bjz_> cmr: but if it's just a 'bag' trait, then it's not really an issue
[20:53:54] *** Joins: erickt (Adium@79611EE9.A51CB73B.6FBF6D51.IP)
[20:54:09] <bjz_> cmr: it's doing it C++ concepts style
[20:55:50] <cmr> I'm not that hot with C++ and I know nothing of their concepts.
[20:55:55] <cmr> but yes, useful for "bag" traits.
[20:55:56] <dandy> bjz_, i have to watch those videos yet, I havn't been keeping up with mdoern c++
[20:56:32] <bjz_> dandy: it's not yet released - but it's locked into C++14
[20:56:34] <bjz_> https://gist.github.com/bjz/bc7f44dca4826202daf4#file-cgcore-rs-L22
[20:56:36] *** Quits: maik (maik@moz-A3335658.dip0.t-ipconnect.de) (Ping timeout)
[20:56:58] <bjz_> ugh, laying out comple traits/impls is so difficult
[20:57:05] <bjz_> *complex
[20:57:41] <dandy> so Field is the bare minimum to play well with this common system
[20:57:47] <dandy> anything else is icing
[20:57:51] <bjz_> aye
[20:58:02] <dandy> I think that is a good compromize over what I do in my code
[20:58:02] <bjz_> is it starting to make sense?
[20:58:26] <dandy> while my method is more fine grained its pretty crazy and I havn't ventured past vector yet
[20:58:45] <dandy> bjz_, oh I get it, I just didn't know that was possible
[20:59:04] <bjz_> yeah
[20:59:11] <dandy> now I'm trying to decide if I like it... so far I think its a good practical solution
[20:59:32] <bjz_> I only got my head around the global impls for 'bag' traits today
[21:00:05] <bjz_> dandy: to be honest, I'm trying to figure out if I like it too
[21:00:38] <dandy> I don't think -+-*/ is too much to ask for
[21:00:58] *** Joins: steveklabnik (steveklabn@90E4D93F.93EC364C.1C63AAF3.IP)
[21:01:00] <dandy> if it is ... that type is too needy and I don't want to deal with it
[21:01:02] *** Joins: stevekla1nik (steveklabn@90E4D93F.93EC364C.1C63AAF3.IP)
[21:03:22] <bjz_> dandy: basically what I want is traits that aren't too fine grained. Like 'Normailizeable' is too fine grained
[21:03:58] <dandy> yeah, and Vec1 can be normalized without sqrt,mul,add
[21:04:39] *** Quits: erickt (Adium@79611EE9.A51CB73B.6FBF6D51.IP) (Ping timeout)
[21:05:03] <bjz_> the other thing is, if you want to do normalize in your own trait heirachy, you can. you just don't have to bring cgmath::EuclideanSpace into scope, and you won't get a conflict
[21:06:55] <dandy> thats a loss of compatibility though
[21:07:18] <dandy> what if I want to offer up the xyz but don't have a sqrt impl
[21:07:31] <bjz_> ?
[21:07:50] <dandy> some types will need sqrt to implement normalize
[21:08:30] <dandy> I guess that is their business to require T:Fiend+Algebraic?
[21:08:37] <dandy> Field*
[21:08:50] <bjz_> you could do: impl<F: Float> EuclideanSpace<F> for Vector3<F> { ... }
[21:09:06] <bjz_> (Float being from std::num
[21:09:07] <bjz_> )
[21:09:26] <dandy> either way though I could get what I need
[21:09:28] <doomlord_> reading this makes me think +1 for a general purpose struct Vec3<T> that doesn't say much about what operations are supported
[21:09:39] <doomlord_> just pure data layour
[21:09:41] <doomlord_> just pure data layout^^
[21:10:12] <bjz_> doomlord_: you can't impl extern traits on extern types
[21:10:44] <dandy> so impl<T:Float> EuclideanSpace<T> for lib1::Vector3<T>  impl<T:Field+Algebraic+What+Have+You> EuclideanSpace<T> for lib2::Vector3<T>
[21:10:46] *** Joins: rusti (rusti@7EA5F9ED.C1499D0.396E4C6D.IP)
[21:10:57] <doomlord_> are cross crate issues still going to incentivize divergance
[21:11:09] <doomlord_> ^divergance of types and trait support
[21:11:55] <bjz_> dandy: you can't do that :(
[21:12:06] <dandy> why?
[21:12:35] *** Quits: rusti (rusti@7EA5F9ED.C1499D0.396E4C6D.IP) (Ping timeout)
[21:12:36] <dandy> lib1::Vector3 and lib2::Vector3 are different
[21:12:36] <bjz_> dandy: you can only impl once on a generic impl of a struct :(
[21:12:44] <bjz_> ohhh
[21:12:46] <bjz_> ok
[21:12:48] <dandy> sorry, bad example
[21:13:02] <bjz_> sorry, didn't see the lib1, lib2
[21:13:02] <dandy> so that way we can have the divergance doomlord_ fears :)
[21:13:14] <bjz_> so if you had that, then yeah
[21:13:18] <bjz_> that is one issue
[21:13:26] <doomlord_> so perhaps the common Array<> accessors are as good as it will get
[21:13:31] <bjz_> I can't see a way around that unfortunately
[21:13:40] <bjz_> sorry doomlord_
[21:13:50] <dandy> well I think phase 2 should look at some common struct/impl
[21:14:18] <doomlord_> it is quite possible cross-trait issues shoot the idea down and you do  indeed need a fully featured vector maths 'crate'
[21:14:56] <bjz_> dandy: you did hear me say "you can't impl extern traits on extern types"
[21:15:04] <bjz_> dandy
[21:15:07] <bjz_> dandy: ?
[21:15:10] <dandy> umm?
[21:15:36] <dandy> it would be impl for my own type, if I made lib2 and you made lib1 you would impl for lib1 and I would impl for lib2
[21:15:44] *** Joins: maik (maik@moz-A3335658.dip0.t-ipconnect.de)
[21:16:04] <dandy> so each struct Vec2 will need to depend on cgcore and impl for it
[21:16:22] <bjz_> dandy: so if I had a 'common struct' in an extern lib, say 'cgtypes', I would not be able to impl on the common struct using the exten traits in 'cgcore'
[21:16:40] *** Joins: canhtak (jeremy@moz-13BC3BC0.wl.t.ulaval.ca)
[21:16:50] <dandy> just like I can impl for my own Vector<T> .. Mul<T,Vector<T>> for Vector<T>
[21:17:08] <bjz_> ?
[21:17:10] *** Joins: brson (brson@72B1AFF8.AD1E507F.3688B332.IP)
[21:17:16] <dandy> bjz_, oh, thought we were still talking about commin traits
[21:17:31] <dandy> yeah
[21:17:42] <bjz_> sorry, I'm on the common struct thing. I don't understand the need
[21:17:45] <dandy> so cgtypes would have to impl the cgcore or whatever its called
[21:18:26] <dandy> yeah thats another reason for it to be a part 2 thing
[21:18:29] <doomlord_> so it seems like restrictions on cross-crate impls render a common struct useless
[21:18:35] <bjz_> yes
[21:18:38] <dandy> there is not much argument over common traits being useful
[21:18:43] <bjz_> well, impossible
[21:18:59] <dandy> impossible forver or just before 2.0.0?
[21:19:14] <bjz_> dandy: 'not much argument' meaning, we agree that they are useful?
[21:19:22] <dandy> yes
[21:19:26] <bjz_> ok
[21:19:35] <doomlord_> i'm happy with the ideas i've seen here on making Vec3's impl Array .. and trait EuclideanSpace or whatever
[21:19:41] <doomlord_> and having those common
[21:19:45] <dandy> names...
[21:20:11] <bjz_> dandy: you would have to talk to the devs, but I doubt extern impls on extern types will be allowed in the future
[21:20:31] <dandy> there is a name for it... I saw it when I encountered that as an error
[21:20:49] <cmr> extension implementations are different
[21:20:51] <dandy> I tried to implement Mul<Vector<T>,Vector<T>> for T ... where T was f64
[21:20:59] <bjz_> doomlord_: ok, cool
[21:21:00] <dandy> yes that, why cant that apply?
[21:21:14] <cmr> Because of coherence: the ability to link any two crates together.
[21:21:18] <bjz_> doomlord_: I mean, I don't expect to finalise it today
[21:21:20] <cmr> If one crate impls Mul for T
[21:21:30] <cmr> and another crate has a different impl of Mul for that same T
[21:21:34] <cmr> And you link them together: what happens?
[21:21:39] <dandy> fail I hope
[21:21:44] <dandy> but what if there arent 2 impls?
[21:21:46] <cmr> And what happens when a third crate tries to use Mul?
[21:21:54] <bjz_> doomlord_: but yeah, good to hear there is a feeling that we are going the right direction
[21:21:57] <dandy> error #2?
[21:22:08] <cmr> dandy: It's universal quantification. If there *can* be 2 impls, Rust won't let it happen.
[21:22:27] *** Joins: rusti (rusti@7EA5F9ED.C1499D0.396E4C6D.IP)
[21:22:35] <cmr> So, the rules of coherence are thus: you can only implement a trait for a type if either the trait or the type are from your own crate.
[21:22:36] <bjz_> does anybody object to me setting up a cgcore lib?
[21:22:45] <bjz_> *repo
[21:22:47] <dandy> no sir
[21:22:57] <cmr> This makes it so any crate can link with any other crates.
[21:23:04] <cmr> haskell doesn't have coherence, and it really sucks
[21:23:13] <bjz_> cmr: really?
[21:23:26] <cmr> You can't mix programs or libraries together without obscure, hard-to-debug, unhelpful errors.
[21:23:28] <cmr> bjz_: yeah
[21:23:34] <bjz_> yoiks
[21:24:11] * bjz_ was skeptical we could find some sort of common ground this morning
[21:24:21] <dandy> can extension implementations be module specific, so if there are two Mul< ... impls for f64 I can just bring the one I want into scope?
[21:24:27] * bjz_ was wrong :)
[21:24:30] <cmr> dandy: no
[21:24:38] <cmr> you can't bring an impl into scope, only traits.
[21:24:54] *** Joins: tikue3 (tikue_star@moz-424BC304.hsd1.pa.comcast.net)
[21:25:14] <cmr> dandy: http://pcwalton.github.io/blog/2012/05/28/coherence/ explains things quite well I think
[21:25:18] *** Quits: tikue3 (tikue_star@moz-424BC304.hsd1.pa.comcast.net) (Client exited)
[21:25:18] <dandy> is that a firm stance forever or a for now thing?
[21:25:33] *** Joins: tikue_ (tikue_star@moz-424BC304.hsd1.pa.comcast.net)
[21:25:54] <doomlord_> i suppose you can always still have source that you include directly in your project
[21:26:04] <doomlord_> as an alternative to crates
[21:27:12] *** Quits: rusti (rusti@7EA5F9ED.C1499D0.396E4C6D.IP) (Connection reset by peer)
[21:27:26] *** Quits: Amaranth (travis@moz-F81BB56A.cpe.cableone.net) (Quit: Linkinus - http://linkinus.com)
[21:27:48] <cmr> dandy: no idea, I don't even know how it'd work or make sense. Do you always have to bring an impl into scope?
[21:27:48] *** Quits: maik (maik@moz-A3335658.dip0.t-ipconnect.de) (Ping timeout)
[21:28:16] <dandy> maybe just for extension imp?
[21:29:12] <cmr> So if you say "fn foo<T: Bar>"
[21:29:19] <cmr> And some other crate gives you a random T
[21:29:27] <cmr> that fn needs to decide which impl it wants, somehow.
[21:29:33] <cmr> How would that happen?
[21:30:03] <dandy> I would think whoever fed the random T in would have to also signal which impl to use
[21:30:22] <doomlord_> wait.. is a common struct really useless
[21:30:39] <dandy> I don't think its useless but it is troublesome
[21:31:33] <doomlord_> if cgcore has trait VectorSpace..  and struct Vec3<T>;     then  myvecmath defines trait VectorMathsOps{...} , impl VectorMathsOps for Vec3<T> ....     that should work ?
[21:32:05] <cmr> doomlord_: yes
[21:34:09] <doomlord_> for this to work VectorSpace wants to be minimal IMO
[21:35:14] <dandy> yes
[21:36:19] <doomlord_> and the desired end result is .. i could bring in one person's Animation library (that might use whatever maths crate), anothers' Physics library (that might use another maths crate..) ... but i can then exchange data from one to the other via cgcore traits
[21:36:32] <dandy> yes
[21:36:52] <dandy> without a crap ton of Vec3{x:x,y:y,z:y}
[21:37:06] <bjz_> heh
[21:37:10] <dandy> and the interop could go further too
[21:37:16] <dandy> you brought up the half type example
[21:37:19] <doomlord_> yes without an n^2 set of conversion operators :)
[21:39:15] <bjz_> doomlord_: you know, you might be right
[21:40:51] <doomlord_> on that note someones' written a physics library of some sort in rust already, right?
[21:40:53] <bjz_> doomlord_: cgcore::vec::convert<T, U>(v: T) -> U
[21:41:41] <cmr> doomlord_: nphysics yeah
[21:42:01] <doomlord_> i suppose what rust gives over c++ is the greater ease of writing large amounts of generic code... not implementing the whole program in headers
[21:42:30] <doomlord_> and communicating/checking interfaces better^ (until concepts arrive)
[21:42:33] <bjz_> doomlord_: the cgcore::vec::Vec{1,2,3,4} types would be the intermediaries
[21:42:45] <doomlord_> right
[21:43:19] <doomlord_> i hope this would help a rust CG ecosystem grow quickly ..
[21:43:24] <bjz_> so one could implement a conversion to/from a cgcore vec, and then you would get cross-lib conversions
[21:44:08] <bjz_> nice!
[21:44:22] <bjz_> I can implement that if you like
[21:44:30] <dandy> yes please
[21:44:45] <dandy> so from lib1 -> cgcore -> lib2 and llvm sorts out the garbage?
[21:44:55] <bjz_> yeah, all inlined
[21:45:06] <dandy> or you could even just use cgcore if your needs were met
[21:45:06] <bjz_> if you use transmutes
[21:45:18] <dandy> ill add transmutes to my reading list...
[21:45:37] <bjz_> basically just an unsfe cast
[21:45:46] <bjz_> a big sledgehammer
[21:46:11] <bjz_> if you know the layout of your data is the same, then it's fine
[21:46:52] *** Quits: steveklabnik (steveklabn@90E4D93F.93EC364C.1C63AAF3.IP) (Ping timeout)
[21:46:52] *** Quits: stevekla1nik (steveklabn@90E4D93F.93EC364C.1C63AAF3.IP) (Ping timeout)
[21:47:06] <bjz_> rusti: unsafe { std::cast::transmute::<f32, i32>(123.56) }
[21:47:17] <bjz_> eh, offline
[21:47:19] <dandy> what if one is padded and yours is not? or does it know about that stuff?
[21:47:39] <bjz_> well, you'd have to handle that
[21:47:45] <bjz_> it'd be more ugly
[21:47:58] <bjz_> probably need to copy
[21:50:06] <dandy> hehe ...  std::cast::transmute! ... one minute later probably need to copy
[21:53:04] <doomlord_> one question, i'm not sure EuclideanSpace would want to expose x_mut() -> &'a mut F;
[21:53:20] <doomlord_> maybe setters would be more versatile
[21:53:50] <doomlord_> (eg in the cases where it is a packed bitfield);   
[21:54:20] <doomlord_> also might we want seperate  immutable and mutable traits , like there are with the vec collection interfaces
[21:54:44] <doomlord_> (maybe thats overkill)
[21:55:13] <dandy> well if your vector isn't in a mutable slot you cant call x_mut
[21:56:37] *** Joins: maik (maik@moz-A3335658.dip0.t-ipconnect.de)
[21:57:52] <dandy> is x_mut a rustic name or a bjz name?
[21:58:29] <tiffany> was this the channel where someone linked that talk by guy steele?
[21:58:31] <tiffany> it was a great talk
[22:03:33] *** Joins: Amaranth (travis@moz-F81BB56A.cpe.cableone.net)
[22:03:45] <dandy> whats the link?
[22:06:08] <tiffany> https://www.youtube.com/watch?feature=player_detailpage&v=_ahvzDzKdB0
[22:09:54] <dandy> thanks
[22:14:25] *** Quits: maik (maik@moz-A3335658.dip0.t-ipconnect.de) (Ping timeout)
[22:20:32] *** Quits: brson (brson@72B1AFF8.AD1E507F.3688B332.IP) (Quit: leaving)
[22:25:11] *** Joins: jxv (jxv@moz-8FB92450.lightspeed.irvnca.sbcglobal.net)
[22:28:38] *** Joins: steveklabnik (steveklabn@moz-5EF6C37C.socal.res.rr.com)
[22:33:49] *** Joins: stevekla1nik (steveklabn@moz-5EF6C37C.socal.res.rr.com)
[22:44:56] *** Joins: maik (maik@moz-A3335658.dip0.t-ipconnect.de)
[22:48:52] <bjz_> dandy: re: bjz name, I'm not sure
[22:49:38] <dandy> ?
[22:50:09] <bjz_> "is x_mut a rustic name or a bjz name?	"
[22:50:15] <dandy> oh
[22:50:24] <bjz_> I'll just make them setters
[22:50:55] <dandy> overloading would be kind of neat for that, maybe
[22:51:48] *** Quits: maik (maik@moz-A3335658.dip0.t-ipconnect.de) (Ping timeout)
[23:15:01] *** Quits: tiffany (kawaii@moz-EB8B0C08.dhcp.embarqhsd.net) (Ping timeout)
[23:18:07] *** Joins: tiffany (kawaii@moz-28A8742A.dhcp.embarqhsd.net)
[23:29:19] *** Quits: CarpNet (Alasdair@moz-EF831A5E.cable.virginmedia.com) (Quit: Leaving)
[23:30:11] *** Joins: Yeri (jasonjasmi@41C91A8A.CE609BA5.E39FBF79.IP)
[23:31:33] *** Joins: rusti (rusti@moz-54F7FD49.cpe.net.cable.rogers.com)
[23:52:09] *** Quits: timot (timot@moz-9EF21B1.cust.tele2.se) (Ping timeout)
[23:54:04] *** Quits: steveklabnik (steveklabn@moz-5EF6C37C.socal.res.rr.com) (Ping timeout)
[23:54:14] *** Quits: stevekla1nik (steveklabn@moz-5EF6C37C.socal.res.rr.com) (Ping timeout)
[23:58:32] *** Joins: jdm (jdm@37A83DB4.49EECAFD.30BE9F17.IP)

[00:00:29] *** Joins: alisdair (textual@28441AAB.AC6E1995.F0AE27BD.IP)
[00:01:12] *** Quits: dew (Instantbir@moz-9D36B7B6.static.stls.mo.charter.com) (Ping timeout)
[00:02:24] *** Joins: dew (Instantbir@moz-9D36B7B6.static.stls.mo.charter.com)
[00:02:30] *** Quits: AvianFlu (AvianFlu@moz-51534E77.c3-0.43d-ubr2.qens-43d.ny.cable.rcn.com) (Input/output error)
[00:06:55] *** Quits: voxpopuli (fanservice@moz-CEF3689A.hsd1.pa.comcast.net) (Ping timeout)
[00:07:14] *** Quits: tiffany (kawaii@moz-FC0DB29D.dhcp.embarqhsd.net) (Input/output error)
[00:11:39] *** Quits: Dessimat0r (Dessimat0r@3258E608.E588CE06.9A579328.IP) (Quit: ZNC - http://znc.in)
[00:12:16] *** Joins: jviereck (Adium@moz-F95C0666.dip0.t-ipconnect.de)
[00:13:12] *** Quits: erickt1 (Adium@moz-4B000CB7.dyn.optonline.net) (Quit: Leaving.)
[00:13:35] *** Quits: spider-mario (spidermari@moz-81131DB6.fbx.proxad.net) (Input/output error)
[00:14:39] *** Joins: voxpopuli (fanservice@moz-CEF3689A.hsd1.pa.comcast.net)
[00:14:45] *** Joins: jviereck1 (Adium@moz-F95C0666.dip0.t-ipconnect.de)
[00:14:46] *** Quits: jviereck (Adium@moz-F95C0666.dip0.t-ipconnect.de) (No route to host)
[00:16:28] *** Quits: dew (Instantbir@moz-9D36B7B6.static.stls.mo.charter.com) (Ping timeout)
[00:17:14] *** Joins: dew (Instantbir@moz-9D36B7B6.static.stls.mo.charter.com)
[00:17:15] *** Quits: jviereck1 (Adium@moz-F95C0666.dip0.t-ipconnect.de) (Quit: Leaving.)
[00:17:18] *** Quits: dbaupp (Thunderbir@moz-506BECCA.pa.nsw.optusnet.com.au) (Ping timeout)
[00:17:43] *** Joins: canhtak (canhtak@moz-59105D0.wl.t.ulaval.ca)
[00:17:59] <elux> hey guys
[00:18:11] <elux> does anyone know how can i install rust head via homebrew..?
[00:18:33] <cmr> elux: brew install rust --HEAD, iirc
[00:18:54] *** Quits: ercxx (ercan@moz-5B55241D.dyn.optonline.net) (Quit: WeeChat 0.4.2)
[00:21:03] <elux> thanks dude, that works
[00:22:30] *** Quits: nano (nano@moz-ED77243C.superkabel.de) (Connection reset by peer)
[00:22:30] *** Joins: erickt1 (Adium@moz-4B000CB7.dyn.optonline.net)
[00:22:37] *** Quits: lenstr (lenstr@66C0DC19.121853A2.28B5BA55.IP) (Client exited)
[00:23:22] *** Joins: ercxx (ercan@moz-5B55241D.dyn.optonline.net)
[00:24:21] <ercxx> anybody having hard time updating daily rust package on archlinux?
[00:24:55] <strcat> ercxx: what do you mean?
[00:25:44] <ercxx> strcat: `sudo pacman -S thestinger/rust-git  5.26s user 0.48s system 7% cpu 1:19.11 total`
[00:26:04] <ercxx> It never took that long before.
[00:26:10] <cmr> slow internet?
[00:26:12] <strcat> well it works here
[00:26:12] <cmr> slow disk?
[00:26:16] <ercxx> I have the package.
[00:26:17] <cmr> works here too
[00:26:20] <ercxx> hmm
[00:26:40] <strcat> ercxx: do you have deltas enabled?
[00:26:42] <ercxx> I'll see how my hard drive is doing soon then.
[00:26:49] <ercxx> I did, before
[00:26:54] <ercxx> lemme see
[00:27:08] <strcat> doesn't look like it succeeded at making one lately anyway
[00:27:13] <ercxx> yeah 0.7
[00:27:14] <geomyidae_> Wait, pacman supports deltas? o_0
[00:27:23] <ercxx> geomyidae_: It does.
[00:27:33] <ercxx> since like forever :)
[00:27:39] *** Joins: vodik (simon@moz-51845A17.range86-179.btcentralplus.com)
[00:27:56] * geomyidae_ is giddy, I learn something new every single day here :)
[00:29:18] <strcat> geomyidae_: we just don't bother generating them for the official repos
[00:30:00] *** Joins: andreypopp (andreypopp@moz-31BA715C.pools.arcor-ip.net)
[00:30:04] *** Quits: andreypopp (andreypopp@moz-31BA715C.pools.arcor-ip.net) (Quit: andreypopp)
[00:31:23] *** Joins: JamesNZ (james@moz-264643C7.bitstream.orcon.net.nz)
[00:32:08] *** Joins: andreypopp (andreypopp@moz-31BA715C.pools.arcor-ip.net)
[00:32:10] *** Quits: andreypopp (andreypopp@moz-31BA715C.pools.arcor-ip.net) (Quit: andreypopp)
[00:32:17] *** Joins: andreypopp (andreypopp@moz-31BA715C.pools.arcor-ip.net)
[00:32:20] *** Quits: andreypopp (andreypopp@moz-31BA715C.pools.arcor-ip.net) (Quit: andreypopp)
[00:34:19] *** Joins: earlzlap (earlz@moz-483E1E31.neo.res.rr.com)
[00:34:29] *** Quits: mentero (mentero@moz-D61C6F02.proxnet.pl) (Quit: WeeChat 0.4.2)
[00:34:30] *** Joins: enix (enix@moz-A50569DD.c3-0.slvr-ubr1.lnh-slvr.md.cable.rcn.com)
[00:35:37] *** Quits: dew (Instantbir@moz-9D36B7B6.static.stls.mo.charter.com) (Ping timeout)
[00:36:24] *** Joins: dew (Instantbir@moz-9D36B7B6.static.stls.mo.charter.com)
[00:37:24] *** Joins: wilmoore (wilmoore@moz-71431C3A.hsd1.co.comcast.net)
[00:38:50] *** Joins: bheylin (brianheyli@moz-8255E94E.adsl.online.nl)
[00:41:11] *** Joins: ziad (ziad@moz-5729CEA7.hsd1.ca.comcast.net)
[00:45:23] *** Quits: dew (Instantbir@moz-9D36B7B6.static.stls.mo.charter.com) (Ping timeout)
[00:45:28] *** Quits: enix (enix@moz-A50569DD.c3-0.slvr-ubr1.lnh-slvr.md.cable.rcn.com) (Quit: Konversation terminated!)
[00:45:51] *** Joins: dew (Instantbir@moz-9D36B7B6.static.stls.mo.charter.com)
[00:48:51] *** Quits: alisdair (textual@28441AAB.AC6E1995.F0AE27BD.IP) (Quit: My MacBook Pro has gone to sleep. ZZZzzz…)
[00:48:54] *** Joins: alisdair (textual@28441AAB.AC6E1995.F0AE27BD.IP)
[00:49:43] *** Quits: wilmoore (wilmoore@moz-71431C3A.hsd1.co.comcast.net) (Ping timeout)
[00:53:05] *** Quits: erickt1 (Adium@moz-4B000CB7.dyn.optonline.net) (Quit: Leaving.)
[00:54:16] *** Quits: canhtak (canhtak@moz-59105D0.wl.t.ulaval.ca) (Quit: canhtak)
[00:57:11] *** Joins: yichoi (yichoi@5AB4884B.FCC4549.14D5B978.IP)
[00:57:50] *** Joins: canhtak (canhtak@moz-59105D0.wl.t.ulaval.ca)
[00:58:54] *** Quits: yichoi (yichoi@5AB4884B.FCC4549.14D5B978.IP) (Ping timeout)
[01:04:22] *** Joins: adridu59 (Mibbit@moz-E1FF077C.rev.numericable.fr)
[01:06:19] *** Quits: heftig (heftig@moz-73861826.dip0.t-ipconnect.de) (Ping timeout)
[01:07:17] *** Quits: alisdair (textual@28441AAB.AC6E1995.F0AE27BD.IP) (Quit: My MacBook Pro has gone to sleep. ZZZzzz…)
[01:07:36] *** Quits: dew (Instantbir@moz-9D36B7B6.static.stls.mo.charter.com) (Ping timeout)
[01:08:18] *** Joins: dew (Instantbir@moz-9D36B7B6.static.stls.mo.charter.com)
[01:09:02] *** Joins: heftig (heftig@moz-62CD741C.dip0.t-ipconnect.de)
[01:09:56] *** Quits: alex-abreu (alex@moz-5AD1ECCF.rev.sfr.net) (Ping timeout)
[01:10:30] *** Quits: pcdummy (pcdummy@moz-CF4CA865.page4me.ch) (Ping timeout)
[01:11:02] *** Quits: _Vi (vi@D7277DB6.6FF508C1.10C239DF.IP) (Ping timeout)
[01:11:47] *** Quits: dumitru (dgherman@moz-7C253BEB.getcadre.com) (Ping timeout)
[01:11:54] *** Joins: _Vi (vi@D7277DB6.6FF508C1.10C239DF.IP)
[01:12:11] *** Quits: adridu59 (Mibbit@moz-E1FF077C.rev.numericable.fr) (Quit: http://www.mibbit.com ajax IRC Client)
[01:12:13] *** Joins: pcdummy (pcdummy@moz-CF4CA865.page4me.ch)
[01:13:00] *** Quits: dew (Instantbir@moz-9D36B7B6.static.stls.mo.charter.com) (Connection reset by peer)
[01:14:45] *** Joins: dew (Instantbir@moz-9D36B7B6.static.stls.mo.charter.com)
[01:15:09] *** Joins: dumitru (dgherman@moz-7C253BEB.getcadre.com)
[01:16:39] <benh> What's the difference between #[start] and #[lang="start"]?
[01:16:42] * benh hasn't really kept up
[01:17:06] *** Quits: hoverbear (hoverbear@moz-86FCBF4B.gv.shawcable.net) (Quit: Taking a nap.)
[01:17:25] *** Quits: bheylin (brianheyli@moz-8255E94E.adsl.online.nl) (Quit: bheylin)
[01:19:14] <brson> benh: #[lang="start"] is for the runtime itself to define its entrypoint (which then sets up the runtime and calls main). #[start] lets user code override that and do its own runtime setup
[01:19:31] <brson> only std and freestand programs should use lang start
[01:19:45] <benh> I see! thanks!
[01:20:05] *** Joins: csherratt (csherratt@moz-CAF331EA.cable.teksavvy.com)
[01:21:29] <FreeFull> So a kernel would use #[lang="start"]?
[01:21:59] <cmr> No, the start lang item has a specific signature, it expects argv etc.
[01:22:17] <cmr> A kernel would be using a linker script and a custom entry point, likely in pure asm
[01:23:13] *** Quits: vodik (simon@moz-51845A17.range86-179.btcentralplus.com) (Ping timeout)
[01:26:09] *** Quits: dew (Instantbir@moz-9D36B7B6.static.stls.mo.charter.com) (Ping timeout)
[01:27:06] *** Joins: dew (Instantbir@moz-9D36B7B6.static.stls.mo.charter.com)
[01:27:21] <brson> yeah, freestanding programs probably shouldn't use lang start either. it's really just for the standard library
[01:27:28] *** Quits: dumitru (dgherman@moz-7C253BEB.getcadre.com) (Ping timeout)
[01:28:08] *** Joins: erickt1 (Adium@moz-4B000CB7.dyn.optonline.net)
[01:29:43] *** Quits: dew (Instantbir@moz-9D36B7B6.static.stls.mo.charter.com) (Ping timeout)
[01:30:09] *** Quits: sigma1 (sigma@moz-BFB7A653.range86-143.btcentralplus.com) (Ping timeout)
[01:30:18] *** Joins: dew (Instantbir@moz-9D36B7B6.static.stls.mo.charter.com)
[01:30:56] *** Joins: dumitru (dgherman@moz-7C253BEB.getcadre.com)
[01:32:45] *** Quits: SiegeLord (sl@moz-CAF07B4C.hsd1.ma.comcast.net) (Connection reset by peer)
[01:33:16] *** Joins: samx (sami@moz-D9DA5773.dyn.optonline.net)
[01:33:24] *** Quits: twi (Adium@moz-24C5D6D4.cust.dsl.vodafone.it) (Quit: Leaving.)
[01:35:47] *** Joins: SiegeLord (sl@moz-CAF07B4C.hsd1.ma.comcast.net)
[01:36:27] *** Quits: dew (Instantbir@moz-9D36B7B6.static.stls.mo.charter.com) (Ping timeout)
[01:36:46] *** Joins: dew (Instantbir@moz-9D36B7B6.static.stls.mo.charter.com)
[01:37:05] *** Quits: Ferreus (ferreus@moz-F34A0B9A.pools.arcor-ip.net) (Quit: WeeChat 0.4.2)
[01:40:05] *** Quits: dwrensha (chatzilla@moz-DE44EA45.hsd1.pa.comcast.net) (Ping timeout)
[01:46:32] *** Quits: csherratt (csherratt@moz-CAF331EA.cable.teksavvy.com) (Ping timeout)
[01:46:55] *** Joins: hoverbear (hoverbear@moz-86FCBF4B.gv.shawcable.net)
[01:48:32] *** Joins: sigma1 (sigma@C91C7F36.70518F41.9D18269F.IP)
[01:49:16] *** Joins: csherratt (csherratt@moz-CAF331EA.cable.teksavvy.com)
[01:52:49] *** Joins: RageOfThou (RageOfThou@3FEF494C.29C984D5.783DEDCA.IP)
[01:53:02] *** Quits: MrFahrenheit (RageOfThou@3FEF494C.29C984D5.783DEDCA.IP) (Ping timeout)
[01:55:04] *** Joins: z0w0 (zack@moz-356923D4.lnse4.woo.bigpond.net.au)
[01:55:16] *** Quits: smodo (tadnr@moz-6398EFDF.dclient.hispeed.ch) (Input/output error)
[01:56:23] *** Quits: jhasse (jhass_000@moz-CB1587EE.ewe-ip-backbone.de) (Connection reset by peer)
[01:57:44] *** Joins: yichoi (yichoi@5AB4884B.FCC4549.14D5B978.IP)
[01:58:11] <FreeFull> cmr: So if you are writing your own standard library?
[01:59:31] *** Quits: yichoi (yichoi@5AB4884B.FCC4549.14D5B978.IP) (Ping timeout)
[01:59:35] <cmr> FreeFull: yes, that is a usecase.
[02:01:00] *** Quits: erickt1 (Adium@moz-4B000CB7.dyn.optonline.net) (Quit: Leaving.)
[02:05:13] *** Quits: z0w0 (zack@moz-356923D4.lnse4.woo.bigpond.net.au) (Connection reset by peer)
[02:05:35] *** Joins: twi (Adium@moz-24C5D6D4.cust.dsl.vodafone.it)
[02:05:48] *** Joins: z0w0 (zack@moz-356923D4.lnse4.woo.bigpond.net.au)
[02:07:26] *** Quits: twi (Adium@moz-24C5D6D4.cust.dsl.vodafone.it) (Ping timeout)
[02:10:01] * geomyidae_ kicks rustpkg in the side, work dammit
[02:12:23] *** Joins: sockmister (Mibbit@moz-A06909E4.glbb.ne.jp)
[02:12:44] *** Quits: maxiepoo (Max@moz-D66F3D4E.atvci.net) (Quit: maxiepoo)
[02:13:33] <sockmister> I see under io::net there are modules for TCP and UDP, is there a roadmap for adding support for raw sockets / other protocols?
[02:13:43] *** Joins: maxiepoo (Max@moz-D66F3D4E.atvci.net)
[02:15:06] <cmr> sockmister: not that I've seen, but libuv supports them.
[02:15:18] <cmr> I'm not sure if such esoterica belongs in std::io
[02:17:02] <sfackler> someone had a PR for raw socket support iirc
[02:17:09] <sfackler> I don't know what happened to it
[02:17:39] <sfackler> I think there were issues testing it since you normally need to have root to open a raw socket
[02:17:46] <cmr> oh yes I remember that PR
[02:20:07] <sockmister> I don't do much with open source, if I wanted to do the legwork to get raw socket support (whether it is in libstd or not) and find out if it is even desired, what is the process for that?
[02:22:17] <cmr> sockmister: so you need to create a pull request, which involves forking the repository on github, cloning it, making your changes, and clicking a button in the web interface (or using the command line tool)
[02:22:30] <sfackler> hansjorg: is there any way to remove a project from rust-ci?
[02:22:38] *** Quits: maxiepoo (Max@moz-D66F3D4E.atvci.net) (Quit: maxiepoo)
[02:23:06] <cmr> then someone on the review team reviews it and if it's accepted our integration bot runs the tests and merges the branch.
[02:23:27] <sockmister> cmr: I understand that part, I guess what I'm asking is how can I make sure the work I'm going to do fits in with the devs' vision 
[02:25:38] *** Joins: maxiepoo (Max@moz-D66F3D4E.atvci.net)
[02:25:59] <cmr> sockmister: open an issue, cc @brson and @alexcrichton, mention it in IRC, ask on the mailing list.
[02:27:01] *** Joins: josh (josh@moz-348C4790.hsd1.mn.comcast.net)
[02:28:00] <sockmister> cmr: thanks
[02:31:42] *** Joins: erickt1 (Adium@moz-4B000CB7.dyn.optonline.net)
[02:32:36] *** Quits: erickt1 (Adium@moz-4B000CB7.dyn.optonline.net) (Quit: Leaving.)
[02:32:42] <ercxx>  what's the rule with importing enums from a mod? I have an enum Status{ UP, DOWN} in device.rs and in service.rs I have use upnp::device::Status; It says 'unresolved name UP'
[02:33:11] <cmr> ercxx: the types and variants are in the same namespace
[02:33:19] <cmr> so you also need use upnp::device::UP
[02:33:47] <ercxx> I didn't understand the first line but it complains about upnp::device::UP too
[02:33:50] <cmr> (Idiomatic Rust doesn't use all-caps names)
[02:34:38] *** Joins: erickt1 (Adium@moz-4B000CB7.dyn.optonline.net)
[02:35:04] <ercxx> cmr: what did you mean with `the types and variants are in the same namespace` ?
[02:35:42] *** Quits: canhtak (canhtak@moz-59105D0.wl.t.ulaval.ca) (Quit: canhtak)
[02:37:07] *** Quits: KindOne (KindOne@F926EE6.8E36DE4.EC6A1518.IP) (Ping timeout)
[02:39:56] <cmr> ercxx: the variants are not imported with the type, they need to be imported individually, and they're in the same namespace as the enum that defines them.
[02:41:08] *** Joins: KindOne (KindOne@moz-698007C0.dynamic.ip.windstream.net)
[02:42:25] *** Quits: echristo (echristo@60A74940.D6CCE4AE.77834EAA.IP) (Quit: echristo)
[02:42:55] *** Joins: alisdair (textual@BB0336C3.D2943E17.C579BC3E.IP)
[02:42:58] <ercxx> cmr: Thank you.
[02:44:47] *** Joins: mib_teubhy (Mibbit@21AB71AC.25429A2D.FC69BED9.IP)
[02:44:50] *** Quits: mib_teubhy (Mibbit@21AB71AC.25429A2D.FC69BED9.IP) (Quit: mib_teubhy)
[02:45:50] *** Quits: z0w0 (zack@moz-356923D4.lnse4.woo.bigpond.net.au) (Client exited)
[02:49:04] *** Joins: z0w0 (zack@moz-356923D4.lnse4.woo.bigpond.net.au)
[02:51:07] <jdavis> I am trying to install the latest version of rust-postgres and compile something that uses it. I use rustpkg for that, right?
[02:51:38] *** Quits: Yurumechan (23f9939a@B2F514.E4420F21.EEF52F3A.IP) (Ping timeout)
[02:52:49] <SiegeLord> Strictly speaking, you never need rustpkg
[02:53:12] <jdavis> I think I might be running into a problem with a previously installed version.
[02:53:46] <jdavis> Or something. I have up-to-date rust-postgres, and I have up-to-date rust-nightly package
[02:54:38] <jdavis> and I am doing "rustpkg install rust-postgres" and I get an error about 'self not being a special lifetime.
[02:56:48] <cmr> jdavis: are you sure your rust-postgres is up to date?
[02:57:11] *** kimundi is now known as zz_kimundi
[02:57:14] <jdavis> There's a commit from today. 
[02:58:03] <cmr> it builds fine for me.
[02:58:12] <jdavis> I must be using rustpkg wrong
[02:58:18] *** Joins: yichoi (yichoi@5AB4884B.FCC4549.14D5B978.IP)
[02:58:33] <SiegeLord> Do you have a previously installed version of postgres?
[02:58:34] * geomyidae_ is still having problems with rustpkg if we're having a rustpkg debug session
[02:58:59] <sfackler> jdavis: you may need do blow away your .rust directory
[02:59:04] <jdavis> SiegeLord: I think so. I think that's the problem, but I'm not sure how rustpkg is finding it or how to make it find the new one.
[02:59:08] <cmr> jdavis: are you sure it's building your local copy of rust-postgres and not a copy rustpkg cloned?
[02:59:11] <jdavis> Oh, OK
[02:59:35] <sfackler> btw, does --dep-info work for anyone?
[02:59:39] *** Joins: lpy (lpy@7360AA58.F09091A8.1348A864.IP)
[02:59:40] <sfackler> it seems to not for me
[02:59:50] <ercxx> jdavis: I just tried and it compiled here.
[02:59:51] <SiegeLord> How are you using it?
[03:00:00] *** Quits: yichoi (yichoi@5AB4884B.FCC4549.14D5B978.IP) (Ping timeout)
[03:00:03] <sfackler> SiegeLord: "rustc --dep-info lib.rs"
[03:00:14] <sfackler> it then complains about no input file given
[03:00:22] <SiegeLord> --dep-info takes an argument
[03:00:30] <SiegeLord> Try rustc lib.rs --dep-info
[03:00:40] <SiegeLord> Or rustc --dep-info file.d lib.rs
[03:00:40] <sfackler> oh
[03:00:42] <sfackler> ha
[03:00:46] <sfackler> that makes more sense
[03:01:55] <sfackler> it does seem to compile the binary along with generating the depinfo file
[03:02:06] <SiegeLord> Yep. I have a PR that changes that
[03:02:09] <sfackler> cool
[03:02:16] <SiegeLord> Dunno if it'll get accepted though :P
[03:02:37] <sfackler> I would hope so, since the entire point of depinfo is to avoid recompiling when you don't need to, right?
[03:03:14] *** Quits: josh (josh@moz-348C4790.hsd1.mn.comcast.net) (Quit: josh)
[03:03:18] <SiegeLord> It makes sense in the context of recursive make and redo
[03:03:21] <SiegeLord> But that's about it
[03:03:46] <SiegeLord> Those do in fact not mind if you build first
[03:03:48] *** Joins: josh (josh@moz-348C4790.hsd1.mn.comcast.net)
[03:05:08] <jdavis> I installed rust-openssl successfully, but it still says it can't find it when I try to install rust-postgres
[03:06:13] *** Joins: twi (Adium@moz-24C5D6D4.cust.dsl.vodafone.it)
[03:06:19] *** Quits: josh (josh@moz-348C4790.hsd1.mn.comcast.net) (Quit: josh)
[03:06:37] *** Quits: erickt1 (Adium@moz-4B000CB7.dyn.optonline.net) (Quit: Leaving.)
[03:07:21] <sfackler> jdavis: you should just be able to do "rustpkg install github.com/sfackler/rust-postgres" and rustpkg will grab rust-openssl for you
[03:07:31] <sfackler> alternatively, just build them manually
[03:07:39] <sfackler> since rustpkg is kind of glitchy
[03:08:01] *** Quits: twi (Adium@moz-24C5D6D4.cust.dsl.vodafone.it) (Ping timeout)
[03:08:04] <cmr> I also recommend not using rustpkg, as sad as it is
[03:08:15] <cmr> sfackler: also your various libs should have #[crate_type="lib"];
[03:08:53] <sfackler> ah yeah, I always just add on a --lib when compiling :P
[03:09:06] <sfackler> and rustpkg infers from the filename
[03:09:58] <jdavis> what is the standard way to build these outside of rustpkg?
[03:10:08] <geomyidae_> Ugh, how do I have examples in a lib folder though?
[03:10:16] <geomyidae_> It's hoisting out my example and naming it like the lib
[03:10:59] <SiegeLord> jdavis: rustc <crate_root>
[03:11:20] <SiegeLord> Maybe add an --out-dir . so it's easier to find the artifact
[03:11:40] <SiegeLord> Crate root will likely be called lib.rs or main.rs
[03:11:45] *** Quits: phil_ (phil@684D2576.37BA1B1C.20F09BA6.IP) (Quit: ())
[03:11:51] *** Joins: phil_ (phil@684D2576.37BA1B1C.20F09BA6.IP)
[03:12:55] <jdavis> SiegeLord: I am a complete novice. I cloned rust-postgres on my local machine... how do I build it from there? I don't know exactly what a crate is.
[03:12:57] <ercxx> jdavis: for rust-openssl in the main dir 'rustc --lib lib.rs'. Find where the compiled librust-opensslxxxxxx file is generated and for rust-postgres in main dir rustc --lib -LPATH_TO_THE_LIB_FILE lib.rs.
[03:15:28] <jdavis> ercxx, thank you, I think I got it.
[03:15:35] <ercxx> no problem
[03:16:33] <jdavis> (1) do "rustc --lib lib.rs" in each library I need to use (2) rustc -L/path/to/thelibrary myprogram.rs
[03:17:05] <cmr> well, I just copy every library into the directory myprogram.rs is in and -L .
[03:19:33] <jdavis> OK. Is there some documentation for this stuff? How are libraries found and how to use rustc, rustpkg, etc?
[03:20:03] <cmr> most of it's in the manual
[03:20:10] <jdavis> OK.
[03:20:29] <cmr> http://static.rust-lang.org/doc/master/tutorial.html#what-next
[03:21:05] *** Joins: naq (naq@D5C2D2DF.E4265FCD.E481B5B.IP)
[03:21:09] <jdavis> Thank you.
[03:21:58] *** Joins: Yurumechan (23f9939a@B2F514.E4420F21.EEF52F3A.IP)
[03:23:05] *** Joins: rustsicle (Mibbit@moz-51D22A60.dsl.teksavvy.com)
[03:24:59] *** Joins: josh (josh@moz-348C4790.hsd1.mn.comcast.net)
[03:28:17] *** Quits: rustsicle (Mibbit@moz-51D22A60.dsl.teksavvy.com) (Quit: http://www.mibbit.com ajax IRC Client)
[03:28:36] *** Quits: Yurumechan (23f9939a@B2F514.E4420F21.EEF52F3A.IP) (Ping timeout)
[03:29:48] *** Joins: Yurumechan (23f9939a@B2F514.E4420F21.EEF52F3A.IP)
[03:38:47] <ziad> is Mut<> and Rc<> equivalent besides mutability?
[03:38:59] <ziad> s/is/are
[03:39:28] <ercxx> If I want to end multiple tasks using messages, how do I send the same message to many tasks?
[03:41:01] <cmr> ziad: does Mut<T> exist?
[03:41:05] <sfackler> ziad: I don't think Mut<> exists do you mean RcMut<>?
[03:41:06] <cmr> ziad: do you mean RefCell<T>?
[03:41:20] <cmr> sfackler: RcMut doesn't exist now either.
[03:41:22] <ziad> car sfackler: that's what I'm currently trying to search for
[03:41:26] <ziad> RcMut is gone
[03:41:33] <ziad> so what do I use? RefCell?
[03:41:37] <ziad> why were they taken out?
[03:42:00] <sfackler> Rc<RefCell<T>>
[03:42:11] <cmr> ziad: Rc<T> is a reference counted box, RefCell<T> lets you subvert the ownership rules with dynamic checks
[03:42:28] <cmr> not ownership
[03:42:31] <cmr> mutability
[03:42:31] <ziad> cmr: so I lose the compile time safety?
[03:42:35] <ziad> ah okay
[03:42:53] <ziad> why was RcMut taken out then? it seemed the logical dual
[03:42:57] *** Quits: zz_kimundi (kimundi@moz-6E87DD93.dip0.t-ipconnect.de) (Ping timeout)
[03:43:46] <cmr> because Rc<RefCell<T>> is equivalent and simpler.
[03:43:49] <sfackler> RcMut is essentially identical to Rc<RefCell<T>> with some api differences
[03:44:01] <sfackler> they both use dynamic checks
[03:44:05] <cmr> Now instead of every type having dynamic mutability checks, only one does.
[03:44:09] <cmr> (RefCell)
[03:44:28] <cmr> ziad: not safety, it's still safe, but it can introduce runtime failures, rather than compiletime.
[03:44:49] <ziad> cmr sfackler: what do you mean by dynamic checks
[03:45:49] <cmr> ziad: https://github.com/mozilla/rust/blob/master/src/libstd/cell.rs#L76, and specifically https://github.com/mozilla/rust/blob/master/src/libstd/cell.rs#L135
[03:45:56] <sfackler> If you do "let x = RcMut::new(10); let a = x.borrow_mut(); let b = x.borrow_mut()" the task will fail at the second call to borrow_mut
[03:46:45] *** Joins: zz_kimundi (kimundi@moz-DB1AF90B.dip0.t-ipconnect.de)
[03:46:45] <ziad> why can't we have compile time borrow checks like we do with Rc?
[03:46:56] <ziad> I guess that's not a straightforward answer :P
[03:47:15] *** zz_kimundi is now known as kimundi
[03:47:39] <cmr> Because the whole point of them is for when the borrow checker won't let you.
[03:47:47] <cmr> Don't use them if you don't want them :)
[03:48:00] *** Joins: hacker_sam (hacker_sam@moz-D8700BD6.dsl.bngr.epix.net)
[03:48:04] <ziad> I need Rc<> but one that allows me to mutate the content
[03:48:17] <cmr> Ok, then you want Rc<RefCell<T>>
[03:48:40] <cmr> It *needs* runtime checks because Rc has shared ownership - it can never be safely mutable without them.
[03:48:49] *** Quits: Earnestly (earnest@88884C6.A3735F9C.39C00A7A.IP) (Ping timeout)
[03:50:01] *** Quits: nattofriends (tsutsumi@moz-A9E340E1.fuqu.jp) (Ping timeout)
[03:50:10] <ziad> car sflackler: thanks :)
[03:50:19] <ziad> cmr* ugh silly spellcheck
[03:50:37] *** Quits: Krymise (Nietzsche@moz-CA789EF5.nwrknj.fios.verizon.net) (Quit: My MacBook Pro has gone to sleep. ZZZzzz…)
[03:50:41] *** Joins: Krymise (Nietzsche@moz-CA789EF5.nwrknj.fios.verizon.net)
[03:51:02] <sfackler> cmr: are you familiar with the metadata setup at all?
[03:51:11] *** Quits: Yurumechan (23f9939a@B2F514.E4420F21.EEF52F3A.IP) (Ping timeout)
[03:51:19] <cmr> sfackler: what metadata setup?
[03:51:23] <cmr> Maybe, but not under that name
[03:51:29] <sfackler> librustc::metadata
[03:51:46] <cmr> nope, it's a black box to me
[03:51:59] <sfackler> cool
[03:52:23] *** Joins: Yurumechan (23f9939a@B2F514.E4420F21.EEF52F3A.IP)
[03:52:27] <sfackler> I'm trying to figure out how to check if a crate has a certain symbol with a certain type without reading through all of metadata and middle :P
[03:52:50] <ziad> just to confirm: with Rc<RefCell<T>>, I still get the compile time safety (assuming I only deal with the RefCell only via Rc) right?
[03:53:34] <cmr> ziad: which safety are you refering to? memory safety? type safety? failure safety?
[03:53:49] <ziad> cmr: borrow safety
[03:54:01] <ziad> which falls under memory safety I guess?
[03:54:03] *** Joins: nattofriends (tsutsumi@moz-A9E340E1.fuqu.jp)
[03:54:05] <cmr> the borrow checker exists to enforce memory safety
[03:54:09] <sfackler> you're guaranteed memory safety at the cost of possible failures at runtime if you try to borrow in the wrong way
[03:54:10] <ziad> yeah, I don't want runtime failures
[03:54:14] <cmr> you still get memory safety, but not through the borrow checker
[03:54:43] <cmr> the compiler won't help you avoiding runtime failures with RefCell, though you can use try_borrow and friends to do your own handling when the borrow fails
[03:54:53] <cmr> The borrow will only fail if you write your code in such a way that it can fail.
[03:55:01] <ziad> so there's still a possibility that it would fail at runtime, even if I only deal with the content of Rc<> via Rc::borrow()?
[03:55:13] <cmr> no, not like that.
[03:55:29] <cmr> you'd need use RefCell's methods to induce failure
[03:55:49] <ziad> let's say I have  let  x: Rc<RefCell<int>> = Rc::new(RefCell::new(1))
[03:55:56] <ziad> that's how to use it, correct?
[03:56:06] <cmr> Yes
[03:56:15] <ziad> then I would do something like x.borrow().borrow_mut(|x| *x += 1))
[03:56:28] <cmr> yup
[03:57:08] <ziad> I'm trying to think of a scenario that would invoke a runtime failure in this case
[03:57:35] <cmr> only if there already exists a borrow higher up in the call stack
[03:57:59] <ziad> wouldn't the borrow check of the outer Rc type prevent that?
[03:58:00] *** Quits: johnrkd (johnrkd@857D8B0A.C6F4759.B05A4819.IP) (Quit: )
[03:58:14] <ziad> since you would still have to go through that one
[03:58:50] <cmr> rusti: use std::rc::Rc; let x = Rc::new(5i); let y = x.borrow(); let z = x.borrow(); println!("{:?} {:?} {:?}", x, y, z);
[03:58:51] *** Joins: yichoi (yichoi@5AB4884B.FCC4549.14D5B978.IP)
[03:58:52] -rusti- std::rc::Rc<int>{ptr: (0x7f4bd0000f50 as *mut ())} &5 &5
[03:58:52] -rusti- ()
[03:59:04] <cmr> since Rc assumes its contents are immutable, it can have multiple borrows.
[03:59:57] <ziad> cmr: ah, makes sense
[04:00:36] *** Quits: yichoi (yichoi@5AB4884B.FCC4549.14D5B978.IP) (Ping timeout)
[04:01:44] *** Quits: josh (josh@moz-348C4790.hsd1.mn.comcast.net) (Quit: josh)
[04:01:53] <ziad> would I be able to interchange ("cast") between Rc<RefCell<>> and Rc<> if I still want to pass the variable to a function that does not need to mutate?
[04:03:23] <cmr> No, not without creating a new Rc
[04:03:29] <cmr> (since that'd require the inner type to change)
[04:03:42] <cmr> But of course, if the function has traditional ownership it could take &T
[04:03:48] <cmr> rather than Rc<T>
[04:05:20] *** Quits: alisdair (textual@BB0336C3.D2943E17.C579BC3E.IP) (Quit: My MacBook Pro has gone to sleep. ZZZzzz…)
[04:05:23] <ziad> yeah, that's true
[04:05:46] *** Quits: jmgrosen (jmgrosen@moz-AB3ADE2D.sb.sd.cox.net) (Input/output error)
[04:06:34] <elux> is there anything for package management with rust..?
[04:06:49] <cmr> elux: rustpkg exists but isn't ready for widespread use yet.
[04:06:58] *** Joins: twi (Adium@moz-24C5D6D4.cust.dsl.vodafone.it)
[04:07:01] <elux> gotcha
[04:08:47] *** Quits: twi (Adium@moz-24C5D6D4.cust.dsl.vodafone.it) (Ping timeout)
[04:09:06] *** Quits: maxli (maxli@moz-4D28BA20.student.cs.uwaterloo.ca) (Quit: Leaving.)
[04:09:45] *** Quits: vosen (vosen@moz-266BA656.icpnet.pl) (Connection reset by peer)
[04:10:43] *** Joins: brianm (brianm@moz-8161EF8D.hsd1.ca.comcast.net)
[04:11:17] <brianm> messing about with traits, trying to do a stringification trait as a learning exercise
[04:11:56] <elux> i know its a bad question to ask.. but when are you guys planning for 0.9 release? :/
[04:12:00] <brianm>         return fmt!("foo %d", *self);
[04:12:03] <brianm> explodes bdly
[04:12:12] <brianm>     fn foo(&self) -> &str {
[04:12:12] <brianm>         return fmt!("foo %d", *self);
[04:12:12] <brianm>     }
[04:12:14] <elux> if you do have something in mind anyway.. ie. on some schedule ..
[04:12:17] <cmr> elux: first or second week of june.
[04:12:20] <cmr> june? january
[04:12:23] <brianm> help?
[04:12:23] <cmr> we release every 3 months
[04:12:28] <brianm> hello.rs:9:15: 9:37 error: mismatched types: expected `&str` but found `~str` (str storage differs: expected & but found ~)
[04:12:32] <elux> june or jan..?
[04:12:41] <cmr> brianm: so, what version of Rust are you using?
[04:12:41] <sfackler> brianm: foo needs to return a ~str, not a &str
[04:12:42] <brianm> isn't a ~foo an &foo automagically?
[04:12:43] <cmr> elux: january
[04:12:44] <brianm> 0.8
[04:12:49] <elux> thats sweet!
[04:13:12] *** Quits: earlzlap (earlz@moz-483E1E31.neo.res.rr.com) (Ping timeout)
[04:13:13] <brianm> cmr, okay, cool... now... why?
[04:13:31] <brianm> must be owned because ... ?
[04:13:40] <wycats_> why doesn't Char implement IterBytes or Hash?
[04:13:56] <cmr> brianm: because otherwise it will get free'd before it gets returned, in that function.
[04:14:01] <wycats_> it's trolling my attempt to derive IterBytes from a struct that has a HashSet<~Char>
[04:14:02] <brianm> ah\
[04:14:06] <brianm> that'd be a problem
[04:14:22] <sfackler> brianm: If you're familiar with C, it's the same reason that this is a bad idea: "int* foo() { int i = 0; return &i; }"
[04:14:28] <brianm> right
[04:14:35] <brianm> sfackler: that makes complete sense now
[04:14:42] <cmr> wycats_: good question, silly oversight. PR? :)
[04:14:56] <cmr> wait, Char? Not char?
[04:14:57] <brianm> making it owned basically puts it in the realm of the thread-local gc?
[04:15:11] <cmr> brianm: owned is malloc/free, not GC
[04:15:17] <brianm> (first day on rust, so excuse ignorance please!)
[04:15:20] <brianm> ah
[04:15:24] <brianm> so what frees it?
[04:15:30] <cmr> Destructor, when it goes out of scope.
[04:15:44] <sfackler> the compiler inserts a call when it's no longer acessible
[04:16:07] <brianm> okay, so precise GC
[04:16:13] <brianm> well, no
[04:16:16] <brianm> I see what you mean though
[04:16:24] <cmr> as much as calling malloc and free in C is a precise GC
[04:16:30] <brianm> compiler can detect when it is no longer used, so can be done deterministically
[04:16:49] <brianm> cmr but i never call free, so I don't like the analogy
[04:17:02] <cmr> Well it's not really an analogy, it's literally calls to malloc and free :p
[04:17:02] <brianm> this sounds like "make the compiler determine when it can be freed"
[04:17:04] <brianm> which is *awesome*
[04:17:13] <cmr> but yes, it is done automatically.
[04:17:23] <brianm> automagic malloc and free
[04:17:28] <cmr> When a value is no longer accessible, it is destroyed.
[04:17:49] <brianm> yep
[04:17:55] <brianm> I think I will like rust
[04:18:00] <cmr> :)
[04:18:25] <wycats_> ah I should be using char not Char
[04:19:35] <brianm> how far is rust from being stable (ie, no backwards incompat changes) ?
[04:19:44] <cmr> About a year or so
[04:19:47] <wycats_> very far
[04:19:51] <cmr> brson hopes 1.0 before 2014 is out
[04:19:51] <brianm> bummer
[04:20:00] <brianm> year isn't so bad
[04:20:02] <cmr> language changes are settlings though
[04:20:06] <cmr> *settling
[04:20:37] <cmr> only ones on the horizon afaik are the smart-pointer changes, which are landing, *maybe* DST, which shouldn't be disruptive, and ... I can't think of any others.
[04:21:01] <cmr> Oh, some silly syntax changes around `extern mod`
[04:21:03] <elux> so what wouldnt be stable about it then..? it could be then that people could write production apps with 0.9
[04:21:26] <cmr> elux: stability means no breaking changes
[04:21:34] * geomyidae_ and the semicolors for #[stuff];
[04:21:44] <cmr> people can write production code now, or five months ago.
[04:21:50] <cmr> Just means your maintenance burden is higher.
[04:21:54] <wycats_> library changes are still coming fast
[04:22:02] <wycats_> yeah I write production code in Rust ;)
[04:22:06] <cmr> wycats_: crazy! :P
[04:22:34] <geomyidae_> really? I saw the OpenDNS bits, do you have a blag post about it or anything?
[04:23:01] <elux> yea.. those syntax changes sound managable to me :)
[04:23:01] <geomyidae_> Oh I'm dumb, your stuff was right after the OpenDNS guy, haha.
[04:23:28] <wycats_> :P
[04:23:47] *** Quits: SiegeLord (sl@moz-CAF07B4C.hsd1.ma.comcast.net) (Quit: It's a joke, it's all a joke.)
[04:23:52] <cmr> elux: just because the *language* doesn't change much doesn't mean libraries won't, as wycats_ said.
[04:23:57] <cmr> Library isn't going to stop changing for a while.
[04:24:04] <elux> yes of course.. the libraries are my biggest concern
[04:24:18] <wycats_> confirm
[04:24:23] <wycats_> you have to stay close to master
[04:24:35] <wycats_> the compiler helps of course
[04:24:38] <wycats_> you get static failures
[04:25:46] *** Quits: brianm (brianm@moz-8161EF8D.hsd1.ca.comcast.net) (Quit: Leaving...)
[04:26:44] <elux> another bad question.. as im sure its planned.. but do you guys see a path for improving compiler speed a lot on the way to 1.0?
[04:26:52] <brson> we may be able to get 1.0 done next summer. that's when some on the team want it done, and it could be possible
[04:27:02] <cmr> elux: llvm has some nice parallelization in the works.
[04:27:07] <cmr> elux: the compiler isn't that slow, though.
[04:27:42] <cmr> pcwalton claims removing landing pads / failure from rustc will grab 20-30% performance.
[04:27:49] <cmr> I'm doubtful, but if it's true that'd be fantastic.
[04:28:10] <elux> nice
[04:28:31] <elux> and how come it takes so long to compile rustc?  and requires a shit ton of memory..?
[04:28:33] <cmr> Anyone have macro-fu? I have two idents, $name and $field, and want to join them with an '.'... `$name.$field` doesn't seem to do it
[04:28:43] <cmr> elux: because it's 300k lines of code.
[04:28:44] <elux> im just curious, as all of this stuff is above my head,
[04:29:04] <elux> gotcha
[04:30:30] <cmr> (that's not strictly accurate, but with monomorphization and soforth it's not far from the truth)
[04:30:43] <ecl3ctic> are there benchmarks of the compiler speed anywhere? I'm curious as to how Rust compile times currently compare to C++ or D
[04:31:13] <cmr> ecl3ctic: not formally. I did some tests of empty-main and hello-world the other day and we're competitive with C and C++ for both clang and gcc
[04:31:19] <ChrisMorgan> cmr: that should work
[04:31:58] <cmr> ecl3ctic: if you are willing to write some interesting benchmark programs and get them merged into master, I can start benching them as part of the thing that drives http://huonw.github.io/isrustfastyet/mem/
[04:32:05] * cmr notices he needs to start the bencher back up
[04:32:20] <ecl3ctic> cmr: Being as fast as gcc is not a big achievement :P
[04:32:44] <cmr> ecl3ctic: considering how slow we were 6 months ago, I think it is :)
[04:32:45] <ChrisMorgan> cmr: $name.$field works fine for me
[04:32:52] <cmr> ChrisMorgan: hm, must be something else, one sec.
[04:34:15] <cmr> ChrisMorgan: https://gist.github.com/cmr/d04e7130f550214ce77b
[04:35:45] <sfackler> cmr: macros can't currently expand to multiple statements
[04:35:57] <cmr> ah poo
[04:36:03] <cmr> well this just plain can't work then
[04:36:13] <cmr> I'll try another time
[04:37:23] <ChrisMorgan> cmr: but because everything is an expression…
[04:37:24] <sfackler> there aren't really any technical reasons that it can't be fixed, but I only really cared about the multiple item case when I made that PR :P
[04:37:50] <ChrisMorgan> cmr: i.e. surround the statements with { } and you're fine.
[04:37:50] <cmr> ChrisMorgan: inb4 if true { field1; if true { field2; } }
[04:37:59] <cmr> hm
[04:38:20] <cmr> HAH!
[04:38:23] * cmr hugs ChrisMorgan
[04:38:38] <cmr> My #1 favorite feature from VB, 8 lines of Rust.
[04:39:25] <ChrisMorgan> cmr: those field names—are they going to be changed to snake_case?
[04:39:49] <cmr> ChrisMorgan: no, it's a straight up port of some VB.NET code for a project I'm working on.
[04:39:56] <cmr> with some fields omitted
[04:41:56] *** Joins: joelteon_test (bzzt@moz-6FBA2F45.cinci.res.rr.com)
[04:42:54] *** Quits: joelteon_test (bzzt@moz-6FBA2F45.cinci.res.rr.com) (Quit: goodbye)
[04:43:31] *** Joins: joelteon_test (bzzt@moz-6FBA2F45.cinci.res.rr.com)
[04:43:33] <ziad> help! error: instantiating a type parameter with an incompatible type `Block`, which does not fulfill `Freeze`
[04:43:43] <ziad> I'm trying to instantiate a Rc<Block>
[04:43:46] <ziad> where
[04:43:52] <ziad> struct Block {
[04:43:53] <ziad>     name: int,
[04:43:54] <ziad>     inn: ~[Rc<RefCell<Block>>],
[04:43:55] <ziad>     out: ~[Rc<RefCell<Block>>]
[04:43:56] <ziad> }
[04:44:32] <cmr> ziad: Not possible, sorry. Rc<T> cannot have cycles.
[04:44:38] <cmr> You can use Gc<T> though
[04:44:45] <ziad> hmm, I see
[04:45:09] *** Joins: alan_andrade (alan_andra@9267EE86.1B9BB716.7B097AAD.IP)
[04:45:22] *** Joins: ptc (Adium@moz-70022D61.hsd1.ma.comcast.net)
[04:45:23] *** Joins: killerswan (kevincantu@moz-CC0DC654.hsd1.ca.comcast.net)
[04:45:39] <ziad> cmr: Gc<RefCell> I presume correct?
[04:45:44] <cmr> yup
[04:45:52] <ziad> thanks!
[04:45:58] *** Quits: brson (brson@moz-BBE3ABD.mv.mozilla.com) (Ping timeout)
[04:46:02] <alan_andrade> Rustaceans, Is there a way to run only the libstd test suite ?
[04:46:05] <cmr> (Gc is just @ under the hood atm)
[04:46:16] <cmr> alan_andrade: make check-stageN-std
[04:46:19] <sfackler> alan_andrade: make_check_stageN-std
[04:46:19] <sfackler> efb
[04:46:50] *** Quits: joelteon_test (bzzt@moz-6FBA2F45.cinci.res.rr.com) (Quit: goodbye)
[04:47:00] <alan_andrade> appreciated :)
[04:47:04] <cmr> ziad: (for the record, http://static.rust-lang.org/doc/master/rust.html#type-kinds)
[04:47:40] <ziad> thanks
[04:47:42] *** Joins: joelteon_test (bzzt@moz-6FBA2F45.cinci.res.rr.com)
[04:47:45] *** Quits: joelteon_test (bzzt@moz-6FBA2F45.cinci.res.rr.com) (Quit: goodbye)
[04:50:11] *** Joins: joelteon_test (bzzt@moz-6FBA2F45.cinci.res.rr.com)
[04:50:12] *** Quits: joelteon_test (bzzt@moz-6FBA2F45.cinci.res.rr.com) (Quit: goodbye)
[04:53:33] *** Quits: JamesNZ (james@moz-264643C7.bitstream.orcon.net.nz) (Quit: Busying myself...)
[04:56:05] *** Quits: ptc (Adium@moz-70022D61.hsd1.ma.comcast.net) (Quit: Leaving.)
[04:59:25] *** Joins: yichoi (yichoi@5AB4884B.FCC4549.14D5B978.IP)
[05:00:23] *** Joins: dbaupp_ (dbaupp@moz-513A8D69.pa.nsw.optusnet.com.au)
[05:01:06] *** Quits: yichoi (yichoi@5AB4884B.FCC4549.14D5B978.IP) (Ping timeout)
[05:03:20] *** Joins: STaguer (textual@moz-51E8CECC.lightspeed.snfcca.sbcglobal.net)
[05:04:07] *** STaguer is now known as staguer
[05:05:22] *** Quits: dbaupp_ (dbaupp@moz-513A8D69.pa.nsw.optusnet.com.au) (Client exited)
[05:07:43] *** Joins: twi (Adium@moz-24C5D6D4.cust.dsl.vodafone.it)
[05:08:07] *** Joins: alisdair (textual@28441AAB.AC6E1995.F0AE27BD.IP)
[05:09:30] *** Quits: twi (Adium@moz-24C5D6D4.cust.dsl.vodafone.it) (Ping timeout)
[05:17:39] *** Quits: elux (peter@moz-6B45ADE5.dsl.bell.ca) (Quit: Leaving...)
[05:18:09] <ercxx> I have a loop where I check a port for a kill signal. Normally it works. If I println() in the loop it doesn't work. If i add some delay with Timer::sleep(even 1ms), it works.
[05:18:12] *** Joins: constexpr (constexpr@moz-3BB74508.bstnma.east.verizon.net)
[05:18:18] <ercxx> What could I be doing wrong?
[05:18:44] <ercxx> works meaning I can read the signal and end the task.
[05:19:48] <sfackler> and doesn't work meaning it blocks on the port forever?
[05:20:27] <ercxx> no, it doesn't block. It just keeps looping.
[05:21:04] <ercxx> I'm using try_recv() 
[05:22:30] <ercxx> does it lose the message, so the next loop never sees it?
[05:25:32] *** Joins: brianm (brianm@moz-8161EF8D.hsd1.ca.comcast.net)
[05:27:23] *** Quits: sockmister (Mibbit@moz-A06909E4.glbb.ne.jp) (Quit: http://www.mibbit.com ajax IRC Client)
[05:28:24] *** Joins: lilybet (Mibbit@moz-2B2BE86F.hsd1.pa.comcast.net)
[05:28:48] *** Quits: lilybet (Mibbit@moz-2B2BE86F.hsd1.pa.comcast.net) (Quit: http://www.mibbit.com ajax IRC Client)
[05:31:04] *** Quits: brianm (brianm@moz-8161EF8D.hsd1.ca.comcast.net) (Ping timeout)
[05:32:06] *** Quits: constexpr (constexpr@moz-3BB74508.bstnma.east.verizon.net) (Quit: constexpr)
[05:33:13] <acrichto> ercxx: could I take a look at the code?
[05:33:42] <acrichto> ercxx: although if you check it in a loop then there may never be a rescheduling
[05:33:47] <acrichto> which is a bug sadly
[05:33:56] <acrichto> and if you inject a sleep then you force scheduling to happen
[05:33:57] *** Quits: killerswan (kevincantu@moz-CC0DC654.hsd1.ca.comcast.net) (Quit: killerswan)
[05:34:18] <acrichto> if you call task::deschedule() periodically you'll probably see the kill signal at some point
[05:36:04] *** Quits: silotis (quassel@moz-4B8C4631.oc.oc.cox.net) (Client exited)
[05:36:58] *** Quits: csherratt (csherratt@moz-CAF331EA.cable.teksavvy.com) (Ping timeout)
[05:37:59] *** Joins: csherratt (csherratt@moz-CAF331EA.cable.teksavvy.com)
[05:38:08] <pyon> Why are Difference, Intersection, SymDifference and Union only availabe for TreeSets but not for TreeMaps?
[05:38:16] *** Joins: silotis (quassel@moz-4B8C4631.oc.oc.cox.net)
[05:39:40] <pyon> I think it makes more sense to make them available for TreeMaps, and make TreeSet<T> a type synonym (rather than a wrapper) for TreeMap<T, ()>.
[05:40:57] <sfackler> pyon: type synonyms make the API more confusing as you have to do stuff like "let set: TreeSet<T> = TreeMap::new()"
[05:42:57] <ercxx> acrichto: http://pastebin.mozilla.org/3887738
[05:45:11] <ercxx> acrichto: task::deschedule() works as you said.
[05:45:27] <pyon> sfackler: Well, in any case, TreeSet may be a wrapper rather than a synonym, but that does not detract from the fact that it would be useful to have Difference, Intersection, SymDifference and Union for TreeMaps as well.
[05:46:05] <acrichto> ercxx: ah  yeah, that's sadly a known bug, I think it's most closely related to #9396
[05:46:25] <acrichto> ercxx: the deschedule should not be needed, although I have yet to rewrite more things to make that possible
[05:47:27] <ercxx> In my use case it doesn't matter at all. I can easily live with a 1ms delay per loop cycle. I am happy I don't have to report a bug though, it's late :)
[05:47:42] <sfackler> pyon: what's the difference between {"a": "b"} and {"a": "c"}?
[05:48:25] <acrichto> ercxx: it's ok, I think we have enough bugs open on that, but feel free to comment on that one I linked with your code
[05:48:37] <sfackler> or the union of them?
[05:48:40] *** Joins: azita (Azita@moz-C1FB2A8.hsd1.ca.comcast.net)
[05:48:41] <ercxx> ok.
[05:50:08] <pyon> sfackler: Presently, the difference/intersection/etc. is an iterator, not a TreeSet in itself. That should stay that way. The difference would be {"a": "b"}. The intersection would be empty.
[05:51:06] <pyon> sfackler: Or I guess you could explicitly supply a policy for handling entries that have the same key but different values.
[05:51:43] *** Quits: ziad (ziad@moz-5729CEA7.hsd1.ca.comcast.net) (Ping timeout)
[05:52:07] *** Joins: james4k (james@moz-1FE2B9B1.tyrdcmta03.hnsntx.tl.dh.suddenlink.net)
[05:53:01] *** Joins: ziad (ziad@moz-5729CEA7.hsd1.ca.comcast.net)
[05:55:05] *** Joins: dwrensha (chatzilla@moz-DE44EA45.hsd1.pa.comcast.net)
[05:55:57] *** Quits: samx (sami@moz-D9DA5773.dyn.optonline.net) (Quit: This computer has gone to sleep)
[05:59:53] *** Joins: yichoi (yichoi@5AB4884B.FCC4549.14D5B978.IP)
[06:00:45] *** Joins: mib_5n57n5 (Mibbit@moz-C90A1BC7.hfc.comcastbusiness.net)
[06:00:48] *** Quits: mib_5n57n5 (Mibbit@moz-C90A1BC7.hfc.comcastbusiness.net) (Quit: mib_5n57n5)
[06:01:43] *** Quits: yichoi (yichoi@5AB4884B.FCC4549.14D5B978.IP) (Ping timeout)
[06:01:59] *** Quits: azita (Azita@moz-C1FB2A8.hsd1.ca.comcast.net) (Quit: azita)
[06:02:08] *** Joins: brianm (brianm@moz-8161EF8D.hsd1.ca.comcast.net)
[06:04:36] *** Joins: a (Mibbit@moz-A244680D.washdc.fios.verizon.net)
[06:06:11] *** Quits: a (Mibbit@moz-A244680D.washdc.fios.verizon.net) (Quit: http://www.mibbit.com ajax IRC Client)
[06:08:28] *** Joins: twi (Adium@moz-24C5D6D4.cust.dsl.vodafone.it)
[06:10:10] *** Quits: twi (Adium@moz-24C5D6D4.cust.dsl.vodafone.it) (Ping timeout)
[06:13:03] *** Quits: ziad (ziad@moz-5729CEA7.hsd1.ca.comcast.net) (Ping timeout)
[06:13:53] *** Joins: ziad (ziad@moz-5729CEA7.hsd1.ca.comcast.net)
[06:16:45] *** Joins: summerlight (summerligh@327FC32B.2C956A45.501EFF44.IP)
[06:16:50] *** Quits: Krymise (Nietzsche@moz-CA789EF5.nwrknj.fios.verizon.net) (Quit: My MacBook Pro has gone to sleep. ZZZzzz…)
[06:18:02] *** Joins: ptc (Adium@moz-70022D61.hsd1.ma.comcast.net)
[06:19:47] *** Quits: ptc (Adium@moz-70022D61.hsd1.ma.comcast.net) (Ping timeout)
[06:27:09] <bstrie_mojitos> I literally drank a mojito today
[06:27:31] <bstrie_mojitos> I can thus say with confidence that this vacation has been a resounding success
[06:28:52] <ChrisMorgan> bstrie_mojitos: … but despite all that, you didn’t manage to stay off #rust.
[06:38:46] *** Quits: csherratt (csherratt@moz-CAF331EA.cable.teksavvy.com) (Ping timeout)
[06:39:19] *** Joins: csherratt (csherratt@moz-CAF331EA.cable.teksavvy.com)
[06:39:54] *** Quits: ecl3ctic (Mibbit@578C64B6.F0F44EFA.76AE55C1.IP) (Quit: http://www.mibbit.com ajax IRC Client)
[06:46:45] *** Joins: killerswan (kevincantu@moz-CC0DC654.hsd1.ca.comcast.net)
[06:47:48] *** Joins: wilmoore (wilmoore@moz-71431C3A.hsd1.co.comcast.net)
[06:49:49] *** Quits: dwrensha (chatzilla@moz-DE44EA45.hsd1.pa.comcast.net) (Ping timeout)
[06:55:41] *** Quits: voxpopuli (fanservice@moz-CEF3689A.hsd1.pa.comcast.net) (Ping timeout)
[06:59:25] <bstrie_mojitos> ChrisMorgan: I only check it like six times a day!!
[06:59:35] <bstrie_mojitos> look at how long it took me to reply to that
[06:59:40] <bstrie_mojitos> that's because I am living the life
[06:59:43] <ChrisMorgan> bstrie_mojitos: I guess you just used two of them in the last half hour.
[06:59:46] <alan_andrade> ?
[07:00:06] <bstrie_mojitos> listening to space music in a darkened room with my best friends
[07:00:16] <bstrie_mojitos> best vacation
[07:00:25] *** Joins: yichoi (yichoi@5AB4884B.FCC4549.14D5B978.IP)
[07:00:48] *** Quits: hoverbear (hoverbear@moz-86FCBF4B.gv.shawcable.net) (Quit: Taking a nap.)
[07:02:10] *** Quits: yichoi (yichoi@5AB4884B.FCC4549.14D5B978.IP) (Ping timeout)
[07:09:13] *** Joins: twi (Adium@moz-24C5D6D4.cust.dsl.vodafone.it)
[07:10:59] *** Quits: twi (Adium@moz-24C5D6D4.cust.dsl.vodafone.it) (Ping timeout)
[07:12:10] *** Quits: klaus (koz@moz-E49E7C4B.hsd1.wa.comcast.net) (Quit: klaus)
[07:12:22] *** Quits: alan_andrade (alan_andra@9267EE86.1B9BB716.7B097AAD.IP) (Input/output error)
[07:12:33] *** Quits: ziad (ziad@moz-5729CEA7.hsd1.ca.comcast.net) (Ping timeout)
[07:14:01] *** Joins: ziad (ziad@moz-5729CEA7.hsd1.ca.comcast.net)
[07:18:25] *** Joins: ptc (Adium@moz-70022D61.hsd1.ma.comcast.net)
[07:19:49] <whitequark> hm, does rust not have global (mutable) variables?
[07:20:03] <whitequark> seems like you could only emulate one with a raw pointer
[07:20:12] *** Quits: ptc (Adium@moz-70022D61.hsd1.ma.comcast.net) (Ping timeout)
[07:20:14] <ChrisMorgan> whitequark: it has task-global mutable variables, which are unsafe.
[07:21:25] <whitequark> ChrisMorgan: can you elaborate?
[07:22:08] <ChrisMorgan> whitequark: http://static.rust-lang.org/doc/master/rust.html#mutable-statics
[07:22:41] <whitequark> missed that, thanks
[07:23:03] *** Quits: ercxx (ercan@moz-5B55241D.dyn.optonline.net) (Ping timeout)
[07:28:08] *** Joins: nrc (ncameron@moz-AD2938E.hari.cable.virginm.net)
[07:29:35] *** Quits: csherratt (csherratt@moz-CAF331EA.cable.teksavvy.com) (Ping timeout)
[07:34:07] <naq> I have a quick stupid question. Will rust be ever able to statically link like go does? a ldd on a rust binary shows that it doesn't depend on rust std and it's size confirms it, but it depends on other system libraries where go doesn't. Are there any limitations to rust's ability to statically link? or is it something that will change in the future?
[07:34:45] <ChrisMorgan> naq: Rust master can statically link.
[07:36:08] <naq> ChrisMorgan: how do you statically link?
[07:36:41] <ChrisMorgan> naq: http://static.rust-lang.org/doc/master/rust.html#linkage
[07:36:44] <whitequark> naq: --link-args -static does it for me
[07:37:24] <whitequark> if you mean you want to get a statically linked executable, as opposed to statically linking other Rust libraries into this Rust executable
[07:37:54] <naq> whitequark: yes, I meant a statically linked binary
[07:38:16] * ChrisMorgan hasn't actually tried producing a statically linked binary
[07:38:56] <naq> ChrisMorgan: yes but I was wondering if there are limitations that prevent this and if it's possible or if it will be possible in the future
[07:39:13] <ChrisMorgan> naq: it's possible now, as demonstrated
[07:39:36] *** Quits: james4k (james@moz-1FE2B9B1.tyrdcmta03.hnsntx.tl.dh.suddenlink.net) (Ping timeout)
[07:40:03] <whitequark> side note: I really like the way Rust packs metadata in dylibs and rlibs
[07:40:17] <naq> ChrisMorgan: I'm sorry I'm not very skilled with rust, can you explain to me which crate I have to use if any to create a static binary?
[07:40:25] <naq> whitequark: --link-args -static gives me some errors
[07:40:27] <ChrisMorgan> acrichto: is `--link-args -static` for producing a statically linked binary correct? Why can't I find instructions on that part in the manual?
[07:40:45] <whitequark> naq: can you post them to gist.github.com ?
[07:41:26] <ChrisMorgan> naq: largely, I just know it's possible. I haven't had the need to actually do it myself yet, so I haven't committed it to memory. And it doesn't seem especially well documented yet.
[07:42:49] <acrichto> ChrisMorgan: no, a static binary is always produced if all dependent libraries are found as rlibs
[07:43:10] <ChrisMorgan> Oh, OK.
[07:43:49] <naq> whitequark: I've put it on pastebin http://pastebin.com/nDfySzNX
[07:44:59] <whitequark> oh, right, rust tries to read the crate metadata from itself with dlsym 
[07:45:07] <ChrisMorgan> acrichto: so `--link-args -static` would be completely unnecessary?
[07:45:17] <whitequark> I wonder why it worked for me
[07:46:07] <acrichto> ChrisMorgan: correct, anything using --link-args should be unnecessary for normal use
[07:47:03] <naq> acrichto: so which crate_type I should use then?
[07:47:18] <ChrisMorgan> naq: OK, so what are the system libraries you're saying a rust executable is depending on?
[07:47:39] <acrichto> naq: if you're just building an executable you don't need a crate_type, by default it's "bin"
[07:48:10] <naq> acrichto: yes but it still has system lib dependencies
[07:48:39] <acrichto> naq: correct, but that is an inevitability right now
[07:48:41] <naq> ChrisMorgan: http://pastebin.com/fA6LpWLz
[07:48:55] <whitequark> naq: incidentally, --link-args -static works for your code with HEAD rust
[07:49:00] <whitequark> it appears that you have some earlier version
[07:49:03] <acrichto> naq: right now a static rust executable means no dynamic *rust* dependencies, dynamic native dependencies are a whole separate problem
[07:49:04] <naq> acrichto: I understand, that's what I wanted to know and if that will change in the future
[07:49:22] <acrichto> naq: in the near future no, I doubt we'll ever drop the dependency on libc
[07:49:44] <naq> acrichto: understood, thanks
[07:49:49] <acrichto> naq: some dependencies like libm and librt should get removed though in LTO, right now they sadly stick around for various reasons
[07:53:32] <whitequark> naq: note that the usual problems with static linking apply, such as inability to load libnss
[07:53:33] <naq> I'm eagerly waiting for 1.0 so I can invest time diving into it without being afraid that what I learn can become obsolete, for now I'm lost when it comes to rust
[07:53:44] *** Quits: RageOfThou (RageOfThou@3FEF494C.29C984D5.783DEDCA.IP) (Ping timeout)
[07:53:54] *** Joins: MrFahrenheit (RageOfThou@3FEF494C.29C984D5.783DEDCA.IP)
[07:54:38] <whitequark> if you want to distribute precompiled binaries, afaik it's generally recommended to distribute dynamically built binaries with your own libc.
[08:01:00] *** Joins: yichoi (yichoi@5AB4884B.FCC4549.14D5B978.IP)
[08:01:57] *** Quits: Jesin (Jesin@moz-4B662E55.washdc.fios.verizon.net) (Quit: Leaving)
[08:02:43] *** Quits: yichoi (yichoi@5AB4884B.FCC4549.14D5B978.IP) (Ping timeout)
[08:04:30] *** Quits: exobit (foo@moz-90D1B547.nycmny.fios.verizon.net) (Quit: My MacBook Pro has gone to sleep. ZZZzzz…)
[08:09:57] *** Joins: twi (Adium@moz-24C5D6D4.cust.dsl.vodafone.it)
[08:11:46] *** Quits: twi (Adium@moz-24C5D6D4.cust.dsl.vodafone.it) (Ping timeout)
[08:15:27] *** Quits: staguer (textual@moz-51E8CECC.lightspeed.snfcca.sbcglobal.net) (Quit: Textual IRC Client: www.textualapp.com)
[08:18:03] *** Joins: eddyb (eddy@EE946B63.921A1753.FCAAE698.IP)
[08:18:47] *** Joins: ptc (Adium@moz-70022D61.hsd1.ma.comcast.net)
[08:22:49] *** Joins: alan_andrade (alan_andra@9267EE86.1B9BB716.7B097AAD.IP)
[08:24:34] *** Quits: alan_andrade (alan_andra@9267EE86.1B9BB716.7B097AAD.IP) (Ping timeout)
[08:24:50] *** Quits: ptc (Adium@moz-70022D61.hsd1.ma.comcast.net) (Ping timeout)
[08:25:05] *** Joins: victorporof (victorporo@AFD25FB8.16D3B2F1.79933D60.IP)
[08:37:38] *** Joins: jmgrosen (jmgrosen@moz-AB3ADE2D.sb.sd.cox.net)
[08:48:50] *** Joins: rca (rcatolino@moz-2346035D.adsl.proxad.net)
[08:53:52] *** Joins: Ms2ger (Ms2ger@moz-268A540A.access.telenet.be)
[09:01:32] *** Joins: yichoi (yichoi@5AB4884B.FCC4549.14D5B978.IP)
[09:03:22] *** Quits: yichoi (yichoi@5AB4884B.FCC4549.14D5B978.IP) (Ping timeout)
[09:04:24] *** Joins: derek_c (derek@A0D3D752.80543B4A.7E5576EA.IP)
[09:09:02] *** Quits: eddyb (eddy@EE946B63.921A1753.FCAAE698.IP) (Ping timeout)
[09:10:42] *** Joins: twi (Adium@moz-24C5D6D4.cust.dsl.vodafone.it)
[09:11:44] *** Joins: eddyb (eddy@EE946B63.921A1753.FCAAE698.IP)
[09:12:28] *** Quits: twi (Adium@moz-24C5D6D4.cust.dsl.vodafone.it) (Ping timeout)
[09:17:33] *** Quits: wilmoore (wilmoore@moz-71431C3A.hsd1.co.comcast.net) (Quit: wilmoore)
[09:18:27] *** Joins: Blei (philipp@moz-B2F9E4BD.cust.bluewin.ch)
[09:22:03] *** Joins: tiffany (kawaii@moz-FC0DB29D.dhcp.embarqhsd.net)
[09:23:16] *** Quits: tiffany (kawaii@moz-FC0DB29D.dhcp.embarqhsd.net) (Quit: tiffany)
[09:23:25] *** Joins: tiffany (kawaii@moz-FC0DB29D.dhcp.embarqhsd.net)
[09:23:47] *** Joins: ptc (Adium@moz-70022D61.hsd1.ma.comcast.net)
[09:25:28] *** Quits: ptc (Adium@moz-70022D61.hsd1.ma.comcast.net) (Ping timeout)
[09:26:51] *** Quits: jmgrosen (jmgrosen@moz-AB3ADE2D.sb.sd.cox.net) (Quit: jmgrosen)
[09:36:51] *** Joins: jackneill (jackneill@moz-1F43710.pool.digikabel.hu)
[09:38:33] *** Joins: Ms2ger` (Ms2ger@moz-93E75EFC.ugent.be)
[09:39:26] *** Quits: Ms2ger (Ms2ger@moz-268A540A.access.telenet.be) (Ping timeout)
[09:41:16] *** Joins: andreypopp (andreypopp@moz-31BA715C.pools.arcor-ip.net)
[09:41:19] *** Quits: andreypopp (andreypopp@moz-31BA715C.pools.arcor-ip.net) (Quit: andreypopp)
[09:43:47] *** Joins: mentero (mentero@moz-D61C6F02.proxnet.pl)
[09:47:13] *** Joins: nkoep (nik@moz-86B3FBAD.pool.mediaways.net)
[09:50:58] *** Joins: moostik (Icedove@moz-40E6ACEF.w2-2.abo.wanadoo.fr)
[09:51:42] *** Quits: dcrewi (david@moz-AB8667CE.gyrae.net) (Ping timeout)
[09:52:31] *** Joins: vfetwnuncszu (david@moz-AB8667CE.gyrae.net)
[09:52:41] *** vfetwnuncszu is now known as dcrewi
[09:57:20] *** Joins: mib_zaxc1c (Mibbit@moz-461D2277.retail.telecomitalia.it)
[10:01:51] *** Joins: yichoi (yichoi@5AB4884B.FCC4549.14D5B978.IP)
[10:02:39] *** Joins: pyrac (pyrac@moz-7D67191A.w90-5.abo.wanadoo.fr)
[10:03:40] *** Quits: yichoi (yichoi@5AB4884B.FCC4549.14D5B978.IP) (Ping timeout)
[10:05:15] *** Quits: maxiepoo (Max@moz-D66F3D4E.atvci.net) (Quit: maxiepoo)
[10:10:18] *** Joins: andreypopp (andreypopp@moz-31BA715C.pools.arcor-ip.net)
[10:10:21] *** Quits: andreypopp (andreypopp@moz-31BA715C.pools.arcor-ip.net) (Quit: andreypopp)
[10:11:27] *** Joins: twi (Adium@moz-24C5D6D4.cust.dsl.vodafone.it)
[10:11:54] *** Quits: pyrac (pyrac@moz-7D67191A.w90-5.abo.wanadoo.fr) (Quit: pyrac)
[10:12:16] *** Joins: fyolnish (fyolnish@moz-E1A87389.uqwimax.jp)
[10:13:14] *** Quits: twi (Adium@moz-24C5D6D4.cust.dsl.vodafone.it) (Ping timeout)
[10:13:44] *** Quits: MrFahrenheit (RageOfThou@3FEF494C.29C984D5.783DEDCA.IP) (Ping timeout)
[10:13:58] *** Joins: MrFahrenheit (RageOfThou@3FEF494C.29C984D5.783DEDCA.IP)
[10:14:19] *** Quits: nkoep (nik@moz-86B3FBAD.pool.mediaways.net) (Quit: Leaving)
[10:14:33] *** Joins: jaen (jaen@moz-E0979827.copit.pl)
[10:19:27] <bjz> https://news.ycombinator.com/item?id=6979053
[10:22:05] <ChrisMorgan> bjz: I'd remove the "Lars Bergstrom: " part
[10:22:36] <bjz> done
[10:23:00] <bjz> nice post too
[10:23:21] * bjz is forever in awe of lars' domain
[10:23:33] <bjz> :)
[10:24:09] *** Joins: ptc (Adium@moz-70022D61.hsd1.ma.comcast.net)
[10:25:53] *** Quits: ptc (Adium@moz-70022D61.hsd1.ma.comcast.net) (Ping timeout)
[10:27:18] <zxcdw> So much Rust in HN recently!
[10:28:48] * ChrisMorgan needs to make some
[10:29:02] *** Joins: io2 (io2@moz-34E8FDD4.home.otenet.gr)
[10:31:05] *** Joins: bheylin (brianheyli@moz-8255E94E.adsl.online.nl)
[10:33:10] <derek_c> zxcdw: haha I came here just to say this
[10:33:21] <bjz> zxcdw: yay, three posts on the HN front page
[10:33:29] <bjz> (for Rust)
[10:34:10] *** Joins: smodo (tadnr@moz-6398EFDF.dclient.hispeed.ch)
[10:40:08] *** Joins: mpasierbski (Mibbit@moz-B9B0EEB7.wroclaw.vectranet.pl)
[10:40:39] *** Quits: mpasierbski (Mibbit@moz-B9B0EEB7.wroclaw.vectranet.pl) (Quit: http://www.mibbit.com ajax IRC Client)
[10:47:10] *** Joins: lenstr (lenstr@155BEC05.9636F313.7A27613B.IP)
[10:47:17] *** Joins: twi (Adium@moz-24C5D6D4.cust.dsl.vodafone.it)
[10:50:22] *** Quits: mib_zaxc1c (Mibbit@moz-461D2277.retail.telecomitalia.it) (Quit: http://www.mibbit.com ajax IRC Client)
[10:50:38] *** Joins: vodik (simon@moz-51845A17.range86-179.btcentralplus.com)
[10:52:05] *** Joins: bkircher (bkircher@moz-5C9284AB.dip0.t-ipconnect.de)
[10:55:14] *** Joins: c-a (c-a@380CCB84.6116A87C.3B6D96BA.IP)
[10:58:26] *** Quits: lenstr (lenstr@155BEC05.9636F313.7A27613B.IP) (Ping timeout)
[10:59:43] *** Quits: alisdair (textual@28441AAB.AC6E1995.F0AE27BD.IP) (Quit: My MacBook Pro has gone to sleep. ZZZzzz…)
[11:00:02] *** Quits: bjz (bjz@B398BE78.F804C29E.D35A31DF.IP) (Ping timeout)
[11:00:43] <derek_c> does Rust make use of all CPUs by default?
[11:00:52] *** Quits: smodo (tadnr@moz-6398EFDF.dclient.hispeed.ch) (Quit: Leaving)
[11:00:58] <derek_c> and can we adjust the number of CPUs it uses?
[11:00:59] *** Joins: smodo (tadnr@moz-FF0B8E6D.ipredator.se)
[11:01:30] <ChrisMorgan> derek_c: in the M:N scheduler (libgreen), I believe the default number of threads is the number of cores reported by the OS (plus a separate scheduler thread).
[11:01:48] <ChrisMorgan> derek_c: if you want control, create your own scheduler; in it you can specify how many threads you want.
[11:02:24] *** Joins: yichoi (yichoi@5AB4884B.FCC4549.14D5B978.IP)
[11:02:41] *** Joins: andreypopp (andreypopp@moz-31BA715C.pools.arcor-ip.net)
[11:02:41] *** Quits: andreypopp (andreypopp@moz-31BA715C.pools.arcor-ip.net) (Quit: andreypopp)
[11:03:18] *** Quits: nrc (ncameron@moz-AD2938E.hari.cable.virginm.net) (Ping timeout)
[11:04:11] *** Quits: yichoi (yichoi@5AB4884B.FCC4549.14D5B978.IP) (Ping timeout)
[11:04:49] <derek_c> ChrisMorgan: I see. thanks!
[11:05:55] <ChrisMorgan> ("Create your own scheduler" is just words, from me—it's been said it can be done, but I haven't looked into how to do it at all.)
[11:07:15] *** Joins: Earnestly (earnest@88884C6.A3735F9C.39C00A7A.IP)
[11:08:34] <ChrisMorgan> derek_c: I believe it'd be `let mut config = PoolConfig::new(); config.threads = N; let pool = SchedPool::new(config)` (http://static.rust-lang.org/doc/master/green/struct.SchedPool.html, http://static.rust-lang.org/doc/master/green/struct.PoolConfig.html)
[11:09:21] <ChrisMorgan> (Not sure if that's complete, though; SchedPool::new(config: PoolConfig) speaks of running the main function.)
[11:10:07] *** Joins: nano (nano@moz-ED77243C.superkabel.de)
[11:10:56] *** Joins: andreypopp (andreypopp@moz-31BA715C.pools.arcor-ip.net)
[11:10:57] *** Quits: andreypopp (andreypopp@moz-31BA715C.pools.arcor-ip.net) (Quit: andreypopp)
[11:11:30] * ChrisMorgan is impressed by the number of people that ignore all hints that /r/rust is not /r/playrust
[11:12:05] *** Quits: bheylin (brianheyli@moz-8255E94E.adsl.online.nl) (Quit: bheylin)
[11:16:33] *** Joins: ninechars (glaebhoerl@moz-B5B88D72.catv.broadband.hu)
[11:16:33] *** Quits: glaebhoer1 (glaebhoerl@moz-B5B88D72.catv.broadband.hu) (Connection reset by peer)
[11:18:27] *** Quits: Earnestly (earnest@88884C6.A3735F9C.39C00A7A.IP) (Quit: WeeChat 0.4.3-dev)
[11:18:30] <luisbg> ChrisMorgan, the Rust game is very popular
[11:18:44] <luisbg> I know of some Rust devs that are playing it, and not because of the name
[11:20:02] <luisbg> wow! Rust (this one) also very popular, mentioned a lot in HackerNews
[11:20:46] <ChrisMorgan> bstrie_mojitos: is it possible to put a honkin’ big banner on http://www.reddit.com/r/rust/submit saying “THIS IS NOT ABOUT THE GAME RUST. THIS IS ABOUT THE PROGRAMMING LANGUAGE RUST. (If you want the game, try /r/playrust.)”
[11:23:09] *** Joins: awidegreen (awidegreen@7976C423.20F08EA3.7B8A71D0.IP)
[11:24:05] <kimundi> Just open a dialog requiring the submitter to write a >println("The Rust Language")< program :P
[11:24:32] *** Joins: ptc (Adium@moz-70022D61.hsd1.ma.comcast.net)
[11:24:33] <Ms2ger`> printfln!("{}", "The Rust Language")?
[11:25:04] * ChrisMorgan doesn't know how much control you get in Reddit
[11:25:56] <luisbg> I think you can add a banner below the submission form
[11:26:11] <luisbg> normally it is used to display the rules of the subreddit
[11:26:25] *** Quits: ptc (Adium@moz-70022D61.hsd1.ma.comcast.net) (Ping timeout)
[11:26:29] <Ms2ger`> Rule 1: this is no game.
[11:26:41] <luisbg> Rule 2. read rule 1
[11:27:30] <Ms2ger`> RULE 20: GOTO 10
[11:28:48] *** Quits: hacker_sam (hacker_sam@moz-D8700BD6.dsl.bngr.epix.net) (Ping timeout)
[11:31:57] <whitequark> hm, https://github.com/mozilla/rust/issues/8345 says segmented stacks have been removed, but rust still attempts to link with -lmorestack
[11:32:12] <whitequark> master rust, that is
[11:32:19] *** Joins: lenstr (lenstr@8A35E972.9636F313.7A27613B.IP)
[11:32:22] *** Quits: ofeldt (ofeldt@moz-880F3FAE.dip0.t-ipconnect.de) (Ping timeout)
[11:35:17] <ChrisMorgan> whitequark: morestack is still there but now only serves the purpose of handling stack overflow nicely.
[11:35:24] <ChrisMorgan> It's basically just a stub.
[11:35:55] <whitequark> ChrisMorgan: ah, I see: so that memory safety would be preserved even in case of stack overflow.
[11:35:56] *** Joins: ofeldt (ofeldt@moz-B7E2366D.dip0.t-ipconnect.de)
[11:35:59] <whitequark> that's very nice.
[11:36:45] <ChrisMorgan> I think that can be done by other means anyway; I think it's largely there just to make a nice abort.
[11:37:05] *** Quits: awidegreen (awidegreen@7976C423.20F08EA3.7B8A71D0.IP) (Ping timeout)
[11:37:16] *** Joins: jviereck (Adium@moz-F95C0666.dip0.t-ipconnect.de)
[11:37:17] <whitequark> that would be the only way for targets without MMU/MPU.
[11:38:22] <ChrisMorgan> whitequark: yeah, I don't know about that. Anyway, https://github.com/mozilla/rust/blob/master/src/rt/arch/i386/morestack.S
[11:38:29] *** Quits: killerswan (kevincantu@moz-CC0DC654.hsd1.ca.comcast.net) (Quit: killerswan)
[11:38:31] * whitequark nods
[11:38:37] <whitequark> already found that..
[11:39:00] <ChrisMorgan> Good :-)
[11:40:02] *** Joins: canhtak (canhtak@moz-59105D0.wl.t.ulaval.ca)
[11:41:19] *** Quits: vodik (simon@moz-51845A17.range86-179.btcentralplus.com) (Ping timeout)
[11:41:32] *** Joins: awidegreen (awidegreen@moz-3FE0A1F.a357.priv.bahnhof.se)
[11:43:17] *** Joins: bheylin (brianheyli@moz-8255E94E.adsl.online.nl)
[11:43:44] *** Ms2ger` is now known as Ms2ger
[11:43:59] *** Joins: hacker_sam (hacker_sam@moz-5BCED09E.dsl.bngr.epix.net)
[11:44:11] *** Joins: FrozenCow (FrozenCow@moz-B2DF4929.chello.nl)
[11:44:16] *** Quits: hacker_sam (hacker_sam@moz-5BCED09E.dsl.bngr.epix.net) (Client exited)
[11:44:36] *** Joins: hacker_sam (hacker_sam@moz-5BCED09E.dsl.bngr.epix.net)
[11:50:23] *** Joins: adridu59 (Mibbit@moz-E1FF077C.rev.numericable.fr)
[11:52:52] *** Quits: jviereck (Adium@moz-F95C0666.dip0.t-ipconnect.de) (Quit: Leaving.)
[11:53:43] *** Joins: Earnestly (earnest@88884C6.A3735F9C.39C00A7A.IP)
[11:53:46] *** Quits: derek_c (derek@A0D3D752.80543B4A.7E5576EA.IP) (Quit: Leaving)
[11:54:01] *** Quits: bheylin (brianheyli@moz-8255E94E.adsl.online.nl) (Quit: bheylin)
[11:54:10] *** Quits: hacker_sam (hacker_sam@moz-5BCED09E.dsl.bngr.epix.net) (Ping timeout)
[11:54:31] *** Quits: awidegreen (awidegreen@moz-3FE0A1F.a357.priv.bahnhof.se) (Ping timeout)
[11:55:21] *** Joins: hacker_sam (hacker_sam@moz-202D2FFF.dsl.bngr.epix.net)
[11:58:56] *** Joins: awidegreen (awidegreen@7976C423.20F08EA3.7B8A71D0.IP)
[11:59:34] *** Quits: yusukesuzuki (yusukesuzu@moz-FEE44B6.net220148245.t-com.ne.jp) (Ping timeout)
[12:02:57] *** Joins: yichoi (yichoi@5AB4884B.FCC4549.14D5B978.IP)
[12:04:43] *** Quits: yichoi (yichoi@5AB4884B.FCC4549.14D5B978.IP) (Ping timeout)
[12:05:00] *** Joins: jviereck (Adium@moz-F95C0666.dip0.t-ipconnect.de)
[12:05:43] *** Quits: awidegreen (awidegreen@7976C423.20F08EA3.7B8A71D0.IP) (Ping timeout)
[12:06:05] *** Quits: canhtak (canhtak@moz-59105D0.wl.t.ulaval.ca) (Quit: canhtak)
[12:09:09] *** Joins: zmthy (zmthy@moz-56779DBC.dsl.dyn.ihug.co.nz)
[12:10:52] *** Quits: zmthy (zmthy@moz-56779DBC.dsl.dyn.ihug.co.nz) (Quit: Textual IRC Client: www.textualapp.com)
[12:10:59] *** Joins: RageOfThou (RageOfThou@3FEF494C.29C984D5.783DEDCA.IP)
[12:11:41] *** Quits: MrFahrenheit (RageOfThou@3FEF494C.29C984D5.783DEDCA.IP) (Ping timeout)
[12:16:07] *** Quits: Ms2ger (Ms2ger@moz-93E75EFC.ugent.be) (Quit: bbl)
[12:17:59] *** Joins: spider-mario (spidermari@moz-81131DB6.fbx.proxad.net)
[12:18:39] *** Quits: spider-mario (spidermari@moz-81131DB6.fbx.proxad.net) (Input/output error)
[12:20:06] *** Joins: spider-mario (spidermari@moz-81131DB6.fbx.proxad.net)
[12:21:18] *** Joins: bheylin (brianheyli@moz-8255E94E.adsl.online.nl)
[12:21:20] *** Quits: RageOfThou (RageOfThou@3FEF494C.29C984D5.783DEDCA.IP) (Ping timeout)
[12:21:51] *** Joins: MrFahrenheit (RageOfThou@3FEF494C.29C984D5.783DEDCA.IP)
[12:22:46] *** Quits: lenstr (lenstr@8A35E972.9636F313.7A27613B.IP) (Ping timeout)
[12:24:55] *** Joins: ptc (Adium@moz-70022D61.hsd1.ma.comcast.net)
[12:25:01] *** Quits: smodo (tadnr@moz-FF0B8E6D.ipredator.se) (Quit: Leaving)
[12:26:46] *** Quits: ptc (Adium@moz-70022D61.hsd1.ma.comcast.net) (Ping timeout)
[12:26:51] *** Joins: rauh (tadnr@moz-8292F118.tor-exit.calyxinstitute.org)
[12:29:57] *** Joins: mindcat (mindcat@C3748B18.E45688C6.F21FCE99.IP)
[12:31:14] *** Joins: vosen (vosen@moz-266BA656.icpnet.pl)
[12:36:50] *** Joins: awidegreen (awidegreen@7976C423.20F08EA3.7B8A71D0.IP)
[12:37:37] *** Quits: bkircher (bkircher@moz-5C9284AB.dip0.t-ipconnect.de) (Connection reset by peer)
[12:37:56] *** Joins: bkircher (bkircher@moz-5C9284AB.dip0.t-ipconnect.de)
[12:38:09] *** Joins: derek_c (derek@moz-38BB4F01.tmlgb.datafoundry.com)
[12:38:52] *** Quits: bkircher (bkircher@moz-5C9284AB.dip0.t-ipconnect.de) (Connection reset by peer)
[12:39:15] *** Joins: bkircher (bkircher@moz-5C9284AB.dip0.t-ipconnect.de)
[12:41:47] *** Joins: bkircher_ (bkircher@moz-5C9284AB.dip0.t-ipconnect.de)
[12:41:47] *** Quits: bkircher (bkircher@moz-5C9284AB.dip0.t-ipconnect.de) (Connection reset by peer)
[12:42:23] *** Quits: jviereck (Adium@moz-F95C0666.dip0.t-ipconnect.de) (Quit: Leaving.)
[12:44:57] *** Joins: jviereck (Adium@moz-F95C0666.dip0.t-ipconnect.de)
[12:46:44] <adridu59> rusti: for i in range(3) { print(i); }
[12:46:45] *** Quits: ninechars (glaebhoerl@moz-B5B88D72.catv.broadband.hu) (Connection reset by peer)
[12:46:46] -rusti- pastebinned 15 lines of output: http://ix.io/9yG
[12:46:52] *** Joins: ninechars (glaebhoerl@moz-B5B88D72.catv.broadband.hu)
[12:47:08] *** Joins: Ferreus (ferreus@moz-E3F12432.customers.d1-online.com)
[12:48:50] *** Quits: awidegreen (awidegreen@7976C423.20F08EA3.7B8A71D0.IP) (Ping timeout)
[12:53:23] *** Joins: bjz (bjz@B398BE78.F804C29E.D35A31DF.IP)
[12:55:28] *** Joins: maxli (maxli@moz-4D28BA20.student.cs.uwaterloo.ca)
[12:56:55] *** Quits: jviereck (Adium@moz-F95C0666.dip0.t-ipconnect.de) (Quit: Leaving.)
[12:57:23] <adridu59> Hi people, does spawning threads have some performance cost? Has it been measured?
[12:59:36] *** Quits: bkircher_ (bkircher@moz-5C9284AB.dip0.t-ipconnect.de) (Connection reset by peer)
[12:59:52] *** Joins: bkircher (bkircher@moz-5C9284AB.dip0.t-ipconnect.de)
[13:01:37] *** Quits: bkircher (bkircher@moz-5C9284AB.dip0.t-ipconnect.de) (Connection reset by peer)
[13:01:51] *** Joins: bkircher (bkircher@moz-5C9284AB.dip0.t-ipconnect.de)
[13:02:48] *** Quits: bkircher (bkircher@moz-5C9284AB.dip0.t-ipconnect.de) (Connection reset by peer)
[13:03:12] *** Joins: bkircher (bkircher@moz-5C9284AB.dip0.t-ipconnect.de)
[13:03:31] *** Joins: yichoi (yichoi@5AB4884B.FCC4549.14D5B978.IP)
[13:03:43] *** Quits: derek_c (derek@moz-38BB4F01.tmlgb.datafoundry.com) (Ping timeout)
[13:04:13] *** Quits: bkircher (bkircher@moz-5C9284AB.dip0.t-ipconnect.de) (Connection reset by peer)
[13:04:42] *** Joins: bkircher (bkircher@moz-5C9284AB.dip0.t-ipconnect.de)
[13:05:12] *** Quits: yichoi (yichoi@5AB4884B.FCC4549.14D5B978.IP) (Ping timeout)
[13:05:12] *** Quits: bkircher (bkircher@moz-5C9284AB.dip0.t-ipconnect.de) (Connection reset by peer)
[13:05:41] *** Joins: bkircher (bkircher@moz-5C9284AB.dip0.t-ipconnect.de)
[13:08:06] *** Joins: bkircher_ (bkircher@moz-5C9284AB.dip0.t-ipconnect.de)
[13:08:06] *** Quits: bkircher (bkircher@moz-5C9284AB.dip0.t-ipconnect.de) (Connection reset by peer)
[13:09:51] *** Quits: bkircher_ (bkircher@moz-5C9284AB.dip0.t-ipconnect.de) (Connection reset by peer)
[13:10:06] *** Joins: bkircher (bkircher@moz-5C9284AB.dip0.t-ipconnect.de)
[13:11:12] *** Quits: Ferreus (ferreus@moz-E3F12432.customers.d1-online.com) (Ping timeout)
[13:11:16] *** Quits: naq (naq@D5C2D2DF.E4265FCD.E481B5B.IP) (Ping timeout)
[13:11:56] *** Quits: bkircher (bkircher@moz-5C9284AB.dip0.t-ipconnect.de) (Connection reset by peer)
[13:12:27] *** Joins: bkircher (bkircher@moz-5C9284AB.dip0.t-ipconnect.de)
[13:14:09] *** Quits: bkircher (bkircher@moz-5C9284AB.dip0.t-ipconnect.de) (Connection reset by peer)
[13:14:37] *** Joins: bkircher (bkircher@moz-5C9284AB.dip0.t-ipconnect.de)
[13:14:37] *** Joins: Ferreus (ferreus@moz-E3F12432.customers.d1-online.com)
[13:14:49] <ChrisMorgan> adridu59: spawning tasks does have cost, but it's largely cheap enough that you don't need to worry about spawning lots and lots and lots and lots of tasks.
[13:15:12] *** Joins: nuts (tii@822A8E7E.6AD15BF5.75D3BBDB.IP)
[13:15:18] *** Quits: hacker_sam (hacker_sam@moz-202D2FFF.dsl.bngr.epix.net) (Ping timeout)
[13:15:29] *** Quits: bkircher (bkircher@moz-5C9284AB.dip0.t-ipconnect.de) (Connection reset by peer)
[13:15:51] *** Joins: bkircher (bkircher@moz-5C9284AB.dip0.t-ipconnect.de)
[13:17:22] *** Joins: bkircher_ (bkircher@moz-5C9284AB.dip0.t-ipconnect.de)
[13:17:23] *** Quits: bkircher (bkircher@moz-5C9284AB.dip0.t-ipconnect.de) (Connection reset by peer)
[13:18:25] *** Quits: bkircher_ (bkircher@moz-5C9284AB.dip0.t-ipconnect.de) (Connection reset by peer)
[13:18:46] *** Joins: bkircher (bkircher@moz-5C9284AB.dip0.t-ipconnect.de)
[13:20:20] *** Quits: Ferreus (ferreus@moz-E3F12432.customers.d1-online.com) (Ping timeout)
[13:20:21] *** Quits: mentero (mentero@moz-D61C6F02.proxnet.pl) (Connection reset by peer)
[13:20:38] *** Joins: mentero (mentero@moz-D61C6F02.proxnet.pl)
[13:21:24] *** Quits: bkircher (bkircher@moz-5C9284AB.dip0.t-ipconnect.de) (Connection reset by peer)
[13:21:47] *** Joins: bkircher (bkircher@moz-5C9284AB.dip0.t-ipconnect.de)
[13:23:38] *** Quits: bkircher (bkircher@moz-5C9284AB.dip0.t-ipconnect.de) (Connection reset by peer)
[13:24:04] *** Joins: bkircher (bkircher@moz-5C9284AB.dip0.t-ipconnect.de)
[13:24:23] *** Joins: derek_c (derek@D59BEC1A.E9B0596F.C34016C.IP)
[13:25:18] *** Joins: ptc (Adium@moz-70022D61.hsd1.ma.comcast.net)
[13:26:58] *** Quits: ptc (Adium@moz-70022D61.hsd1.ma.comcast.net) (Ping timeout)
[13:28:14] *** Joins: erickt1 (Adium@moz-4B000CB7.dyn.optonline.net)
[13:29:53] *** Quits: engla (engla@moz-F64E1B0F.cust.bredbandsbolaget.se) (Ping timeout)
[13:32:40] <adridu59> ChrisMorgan: but when pandoc was being used to process through librustdoc, we found out that it had a non-insignificant cost, no?
[13:33:18] <ChrisMorgan> adridu59: I do not know the details of the case. I strongly suspect that the slow part there was pandoc, not task spawning.
[13:35:19] <adridu59> oh okay. I think cmr or alex know the details
[13:35:52] <adridu59> but we haven't tried pandoc without spawns afaik so we can't really compare
[13:39:39] *** Joins: dwrensha (chatzilla@moz-DE44EA45.hsd1.pa.comcast.net)
[13:41:16] <ChrisMorgan> Well, it's *known* that spawning pandoc is slow—and doing that for every single doc comment, at that. It is reasonable to posit that the task spawning was a trivial cost in comparison—if indeed it was done that way.
[13:43:39] *** Joins: canhtak (canhtak@moz-59105D0.wl.t.ulaval.ca)
[13:45:09] *** Joins: bkircher_ (bkircher@moz-5C9284AB.dip0.t-ipconnect.de)
[13:45:09] *** Quits: bkircher (bkircher@moz-5C9284AB.dip0.t-ipconnect.de) (Connection reset by peer)
[13:46:33] <adridu59> I see, so it wouldn't be the spawning process but all the concurrent workers
[13:47:45] *** Quits: moostik (Icedove@moz-40E6ACEF.w2-2.abo.wanadoo.fr) (Ping timeout)
[13:49:46] <ChrisMorgan> There are the two types of spawning: spawning processes (external applications, like pandoc) and spawning tasks (Rust code from the same process). When you speak of spawning threads, you mean spawning tasks, which is a very cheap operation. In the case of pandoc execution, it *may* have spawned a separate task for each block comment, though I doubt it. What it *did* do was spawn a process per block, which is unavoidably slow.
[13:49:46] *** Quits: erickt1 (Adium@moz-4B000CB7.dyn.optonline.net) (Quit: Leaving.)
[13:50:16] *** Quits: heftig (heftig@moz-62CD741C.dip0.t-ipconnect.de) (Quit: Quitting)
[13:50:30] <adridu59> do you mean that it used 1:1 MT?
[13:50:41] <ChrisMorgan> I do not know.
[13:51:13] <ChrisMorgan> But for each doc comment, a new instance of pandoc was spawned to convert it to HTML. That was rather slow.
[13:51:19] * ChrisMorgan is now off to bed
[13:51:40] <adridu59> good night
[13:52:02] <adridu59> it's about 3PM here
[13:52:04] <eddyb> o_O a process per comment? that's ridiculous
[13:52:07] *** Joins: Ferreus (ferreus@E7BEF92C.A4B602B4.7B8A71D0.IP)
[13:52:14] <eddyb> adridu59: central europe?
[13:52:17] <ChrisMorgan> eddyb: that, I have been told, is what it did.
[13:52:25] * ChrisMorgan wasn't paying attention to it back then
[13:52:32] <eddyb> but... who would write such a thing?
[13:52:41] * eddyb shouldn't be asking :P
[13:52:42] <ChrisMorgan> eddyb: someone who wanted to get it working quickly.
[13:52:57] <ChrisMorgan> Seriously, it's not so bad. Especially when the language is poorly documented :P
[13:53:12] <eddyb> *was
[13:53:22] *** Joins: heftig (heftig@moz-62CD741C.dip0.t-ipconnect.de)
[13:53:28] <eddyb> well, I don't know
[13:54:08] <adridu59> eddyb: yes, well I don't consider France as central Europe but yes it's CET
[13:54:29] <ChrisMorgan> I certainly don't see anything wrong with that stratagem for the time when it was used. I'm certain it was known to be terribly inefficient and that it would need replacing in some manner, but it would have been much simpler to implement than to do it "properly" (for some undefined value of "properly").
[13:54:58] *** Quits: rauh (tadnr@moz-8292F118.tor-exit.calyxinstitute.org) (Input/output error)
[13:55:08] <adridu59> then I don't understand why we ripped it off instead of writing something proper when we realized it was slow
[13:55:27] <adridu59> oh well
[13:55:33] *** Joins: rauh (tadnr@moz-CB33CA6D.is.a.tor.exit.server.torland.is)
[13:55:42] <ChrisMorgan> adridu59: I don't understand your comment there. Elucidate?
[13:56:38] *** Joins: maikklein (maik@moz-2F166E55.dip0.t-ipconnect.de)
[13:57:36] <ChrisMorgan> We used pandoc, knowing it was slow. Then we replaced it with an in-process Markdown translation later (at the time of rustdoc_ng, I believe). And now I'm hoping to get us to shift to Sphinx and reStructuredText. But just now, I'm going to bed. Yes, really. :P
[13:57:49] * ChrisMorgan is terrible at departing from #rust and going to bed
[13:57:51] <adridu59> I mean, we removed pandoc in favor of sundown
[13:58:05] <adridu59> instead of changing implementation, that is without process spawning
[13:58:28] <eddyb> (I actually did something similar for mimetypes - I had to use the kde impl of xdg-mime because anything else was inconsistent. I didn't manage to find a programmatic way of querying a mime database)
[13:58:57] <maikklein> has the closure/function reform already landed?
[13:58:59] <ChrisMorgan> adridu59: sundown is used as a library, to the best of my knowledge
[13:59:09] <ChrisMorgan> maikklein: mostly
[13:59:22] <ChrisMorgan> HEY, I'M GOING TO BED! Stop asking questions! :P
[14:01:03] *** Quits: ChrisMorgan (chris@moz-6AC741CA.static.tpgi.com.au) (Ping timeout)
[14:01:03] *** Quits: maxli (maxli@moz-4D28BA20.student.cs.uwaterloo.ca) (Ping timeout)
[14:01:04] *** Quits: bkircher_ (bkircher@moz-5C9284AB.dip0.t-ipconnect.de) (Connection reset by peer)
[14:01:13] *** Joins: bkircher (bkircher@moz-5C9284AB.dip0.t-ipconnect.de)
[14:01:13] *** Quits: rauh (tadnr@moz-CB33CA6D.is.a.tor.exit.server.torland.is) (Input/output error)
[14:01:34] *** Joins: maxli (maxli@moz-4D28BA20.student.cs.uwaterloo.ca)
[14:01:38] <maikklein> okay so basically it is now proc instead of ~fn?
[14:02:06] <adridu59> proc() yes
[14:03:55] <maikklein> is this up to date? http://smallcultfollowing.com/babysteps/blog/2013/10/10/fn-types-in-rust/
[14:04:05] *** Joins: yichoi (yichoi@5AB4884B.FCC4549.14D5B978.IP)
[14:05:46] *** Quits: yichoi (yichoi@5AB4884B.FCC4549.14D5B978.IP) (Ping timeout)
[14:06:10] *** Joins: ricepuddin (graham@A584E1EF.E6D957F2.39C00A7A.IP)
[14:07:08] *** Joins: rauh (tadnr@moz-6398EFDF.dclient.hispeed.ch)
[14:10:05] *** Joins: lenstr (lenstr@F41BC4F7.4946E43A.B22A75D.IP)
[14:13:58] *** Quits: ricepuddin (graham@A584E1EF.E6D957F2.39C00A7A.IP) (Client exited)
[14:14:53] <maikklein> ok so to be clean "fn foo<A> (f: |A| -> A);" is f now a normal function? and proc() is only used for once functions?
[14:15:16] *** Quits: io2 (io2@moz-34E8FDD4.home.otenet.gr) (Ping timeout)
[14:16:45] *** Joins: exobit (foo@moz-90D1B547.nycmny.fios.verizon.net)
[14:17:23] *** Quits: lpy (lpy@7360AA58.F09091A8.1348A864.IP) (Ping timeout)
[14:19:05] *** Quits: bheylin (brianheyli@moz-8255E94E.adsl.online.nl) (Quit: bheylin)
[14:19:55] *** Joins: jhasse (jhass_000@moz-F3702E2C.ewe-ip-backbone.de)
[14:20:33] *** Joins: morton (Mibbit@1EEF8F2.50A2C647.5A42B74E.IP)
[14:20:46] <morton> Why are explicit lifetimes necessary in Rust?
[14:20:49] <eddyb> maikklein: |A| -> A is a stack closure. proc(A) -> A would be a once fn with its captures on the heap
[14:22:11] <eddyb> morton: because methods and functions need to have a complete type known without looking within their bodies
[14:22:26] <maikklein> rusti: 1
[14:22:27] -rusti- 1
[14:23:13] <eddyb> rusti: version /*fwiw - it's the latest version of rust that doesn't break its IO/sandboxing*/
[14:23:14] -rusti- "rustc 0.9-pre (61f8c05 2013-10-24 13:01:18 -0700)"
[14:24:05] <maikklein> rusti: fn plus_one(x:i32){x+1}; fn foo(x:i32, f: |i32| -> i32) { f(x)}; foo(10,plus_one);
[14:24:07] -rusti- pastebinned 6 lines of output: http://ix.io/9yJ
[14:25:11] <maikklein> rusti: 1:i32
[14:25:13] -rusti- pastebinned 6 lines of output: http://ix.io/9yK
[14:25:13] <eddyb> maikklein: it's too old for the new closure type syntax. also, your plus_one doesn't have a return type
[14:25:32] <eddyb> rusti: 1i32
[14:25:32] -rusti- 1i32
[14:25:41] *** Joins: ptc (Adium@moz-70022D61.hsd1.ma.comcast.net)
[14:26:28] *** Joins: tulloch (tulloch@moz-F362C074.lnse2.pie.bigpond.net.au)
[14:27:08] *** Quits: nano (nano@moz-ED77243C.superkabel.de) (Connection reset by peer)
[14:27:21] *** Quits: ptc (Adium@moz-70022D61.hsd1.ma.comcast.net) (Ping timeout)
[14:27:22] <maikklein> rusti: fn plus_one(x:i32) -> i32 {x+1}; fn foo(x:i32, f: |i32| -> i32) -> i32 { f(x)}; foo(10,plus_one);
[14:27:24] -rusti- pastebinned 6 lines of output: http://ix.io/9yL
[14:27:32] <maikklein> okay how does the new syntax look like?
[14:27:38] *** Joins: voxpopuli (fanservice@moz-CEF3689A.hsd1.pa.comcast.net)
[14:28:14] *** Joins: Ferio (Mibbit@moz-E7D1C548.pools.arcor-ip.net)
[14:28:47] <maikklein> it looks fine here https://github.com/mozilla/rust/blob/master/src/test/run-pass/monad.rs#L14
[14:29:20] <morton> eddyb: Can you explain what you mean by that?
[14:29:35] *** Quits: jhasse (jhass_000@moz-F3702E2C.ewe-ip-backbone.de) (Quit: Verlassend)
[14:29:38] <kimundi> morton: explicit lifetimes are basically there because you need some way to express that two things have the same or distinct lifetimes. 
[14:29:47] *** Joins: jhasse (jhass_000@moz-F3702E2C.ewe-ip-backbone.de)
[14:30:10] <kimundi> morton: In all other cases, they are explicit for consistency and clarity
[14:30:24] <eddyb> maikklein: rusti is too old, that's what I'm saying
[14:30:39] <maikklein> eddyb, oh, didn't know that
[14:30:43] <maikklein> thanks
[14:31:02] <eddyb> told you twice >_>
[14:31:32] <kimundi> example: fn foo<'x>(a: &'x A, b: &'x B) -> &'x C   vs   fn foo<'x, 'y>(a: &'x A, b: &'y B) -> &'y C
[14:31:35] <eddyb> morton: I was assumming you thought they could be inferred
[14:31:43] *** Quits: jhasse (jhass_000@moz-F3702E2C.ewe-ip-backbone.de) (Quit: Verlassend)
[14:32:13] <kimundi> without explicity/ with inferred lifetimes, both method signatures would be identical - with them, they express different things
[14:33:52] *** Joins: jhasse (jhasse@moz-F3702E2C.ewe-ip-backbone.de)
[14:34:19] *** Quits: lenstr (lenstr@F41BC4F7.4946E43A.B22A75D.IP) (Client exited)
[14:34:59] <morton> Thanks
[14:35:02] *** Quits: morton (Mibbit@1EEF8F2.50A2C647.5A42B74E.IP) (Quit: http://www.mibbit.com ajax IRC Client)
[14:36:14] *** Joins: pseudoku (quassel@F3474739.32C4AD94.520CDC98.IP)
[14:37:30] *** Joins: erickt1 (Adium@moz-4B000CB7.dyn.optonline.net)
[14:37:51] <pseudoku> In an structure initialization expr " structname { field1: read1(), field2: read2() }" , what is the order of evaluation of read1() and read2(), is it the same as the order of the fields in the structure definition?
[14:41:13] *** Quits: dcrewi (david@moz-AB8667CE.gyrae.net) (Ping timeout)
[14:42:19] *** Joins: vfetwnuncszu (david@moz-AB8667CE.gyrae.net)
[14:42:30] *** vfetwnuncszu is now known as dcrewi
[14:44:20] <eddyb> is RefCell copiable? I somewhat hope not :S
[14:45:03] *** Quits: ofeldt (ofeldt@moz-B7E2366D.dip0.t-ipconnect.de) (Ping timeout)
[14:45:41] <eddyb> rusti: struct A {a: (), b: ()} (A { a: print("a"), b: print("b") }, A { b: print("b"), a: print("a") })
[14:45:42] -rusti- abba(main::A{a: (), b: ()}, main::A{a: (), b: ()})
[14:45:48] <eddyb> pseudoku: ^^
[14:46:10] <rca> eddyb: i think it is
[14:46:33] <eddyb> then I hope HashMap isn't :P
[14:47:20] *** Joins: jviereck (Adium@moz-A42B7BD5.dip0.t-ipconnect.de)
[14:47:30] <pseudoku> eddyb: so is the *defined* behavior to follow the order in the initialization expression?
[14:47:41] <eddyb> pseudoku: I think so
[14:48:41] *** Joins: ofeldt (ofeldt@moz-B7E2366D.dip0.t-ipconnect.de)
[14:48:53] <pseudoku> eddyb: i just wanted to be sure coz i use it to read & initialize structs corresponding to udp packets
[14:49:03] <pseudoku> thanks
[14:49:07] <rca> so if you copy a ref cell that contains a borrowed pointer, then get do borrow_mut() on both, do you get two mut ref to the same memory location ?
[14:49:24] <rca> wait no it won't work.
[14:49:32] <eddyb> rusti: let a = HashMap::new(); let b = a; (a, b)
[14:49:35] -rusti- pastebinned 13 lines of output: http://ix.io/9yM
[14:50:23] <Ferio> I begin to think I'm to stupid for rust, what am I doing wrong? http://pastebin.com/DbjLhTy9 
[14:50:23] <eddyb> rusti: let a = ::std::hashmap::HashMap::<int, int>::new(); let b = a; (a, b)
[14:50:26] -rusti- pastebinned 10 lines of output: http://ix.io/9yN
[14:51:07] <eddyb> Ferio: where does teh error point to?
[14:51:14] *** Quits: ofeldt (ofeldt@moz-B7E2366D.dip0.t-ipconnect.de) (Ping timeout)
[14:51:21] <Ferio> eddyb: oh sry, at the as-cast
[14:51:49] <eddyb> Ferio: make process generic on a Reader
[14:52:31] <eddyb> fn process<R: io::Reader>(reader: &R) {let rdr: &io::ReaderUtil = reader;}
[14:53:01] <eddyb> though you shouldn't need the cast if you do this, reader would have ReaderUtil methods available. or, wait
[14:53:22] <eddyb> fn process<R: io::ReaderUtil>(reader: &R) {...} should also work
[14:54:13] <eddyb> Ferio: as a rule of thumb, never use trait objects if you can do the same thing with generics
[14:54:21] *** Joins: hacker_sam (hacker_sam@moz-6547E589.dsl.bngr.epix.net)
[14:54:37] *** Quits: fyolnish (fyolnish@moz-E1A87389.uqwimax.jp) (Quit: Bye)
[14:54:41] *** Joins: ofeldt (ofeldt@moz-B7E2366D.dip0.t-ipconnect.de)
[14:55:31] <eddyb> LOL@ty::mk_ctxt
[14:55:53] <eddyb> 40 lines of RefCell::new(HashMap::new())
[14:57:34] <Ferio> eddyb: thx…somehow I permanently stumble over these type errors and I don't know why they happen… :(
[14:58:12] <eddyb> the error came from you trying to cast &&io::Reader to &io::ReaderUtil, which is just ridiculous
[14:58:25] *** Quits: dcrewi (david@moz-AB8667CE.gyrae.net) (Ping timeout)
[14:58:50] *** Joins: vfetwnuncszu (david@moz-AB8667CE.gyrae.net)
[14:58:52] <eddyb> &io::Reader to &io::ReaderUtil wouldn't work because traits aren't types (see DST)
[14:58:57] *** Quits: ofeldt (ofeldt@moz-B7E2366D.dip0.t-ipconnect.de) (Ping timeout)
[14:59:05] *** vfetwnuncszu is now known as dcrewi
[14:59:25] <Ferio> eddyb: http://pastebin.com/rYDSvM5P (using your 2nd suggestion)
[14:59:47] <eddyb> Ferio: what version are you using?
[14:59:52] <Ferio> 0.8
[15:00:03] <eddyb> unsupported, switch to master
[15:01:33] <Ferio> eddyb: ok, but thanks now I understand the error messages I was already wondering why I needed the second & and though it somehow got automatically dereferenced at some point…
[15:01:54] *** Joins: bheylin (brianheyli@moz-8255E94E.adsl.online.nl)
[15:02:42] *** Joins: ofeldt (ofeldt@moz-B7E2366D.dip0.t-ipconnect.de)
[15:02:48] *** Quits: bkircher (bkircher@moz-5C9284AB.dip0.t-ipconnect.de) (Client exited)
[15:03:29] *** Quits: derek_c (derek@D59BEC1A.E9B0596F.C34016C.IP) (Quit: Leaving)
[15:04:40] *** Joins: yichoi (yichoi@5AB4884B.FCC4549.14D5B978.IP)
[15:06:20] *** Quits: yichoi (yichoi@5AB4884B.FCC4549.14D5B978.IP) (Ping timeout)
[15:07:43] *** Quits: ofeldt (ofeldt@moz-B7E2366D.dip0.t-ipconnect.de) (Ping timeout)
[15:08:06] *** Quits: z0w0 (zack@moz-356923D4.lnse4.woo.bigpond.net.au) (Ping timeout)
[15:09:12] *** Joins: guacamole (Mibbit@7FD88CD2.6A0A1420.39C00A7A.IP)
[15:10:24] *** Joins: io2 (io2@moz-34E8FDD4.home.otenet.gr)
[15:11:09] <io2> hi guys, should I be using rustycage, or is there another, better ide?
[15:11:13] *** Quits: guacamole (Mibbit@7FD88CD2.6A0A1420.39C00A7A.IP) (Quit: http://www.mibbit.com ajax IRC Client)
[15:11:21] *** Joins: mib_ony321 (Mibbit@7FD88CD2.6A0A1420.39C00A7A.IP)
[15:11:43] *** Joins: ofeldt (ofeldt@moz-B7E2366D.dip0.t-ipconnect.de)
[15:12:04] <mib_ony321> Is there a way to generate a DLL from rust code ?
[15:13:47] *** Quits: canhtak (canhtak@moz-59105D0.wl.t.ulaval.ca) (Quit: canhtak)
[15:15:05] *** Quits: ofeldt (ofeldt@moz-B7E2366D.dip0.t-ipconnect.de) (Ping timeout)
[15:16:34] <eddyb> io2: there's no (other?) IDE support that I know of, just syntax highlighting
[15:16:58] *** Joins: SiegeLord (sl@moz-CAF07B4C.hsd1.ma.comcast.net)
[15:17:00] <io2> eddyb: ok, thanks
[15:17:08] <io2> I am just using emacs for the time being
[15:17:08] <tiffany> I think most of the people here just use a text editor like vim
[15:17:23] *** Joins: Jesin (Jesin@moz-4B662E55.washdc.fios.verizon.net)
[15:17:43] <sfackler> mib_ony321: just compile as a library
[15:17:59] <tiffany> speaking of which, has anyone tried getting vim plugins like youcompleteme working with rust?
[15:18:11] *** Joins: canhtak (canhtak@moz-59105D0.wl.t.ulaval.ca)
[15:19:13] *** Joins: ofeldt (ofeldt@moz-B7E2366D.dip0.t-ipconnect.de)
[15:20:44] *** Joins: rca_ (rcatolino@moz-5C646728.adsl.proxad.net)
[15:20:54] <adridu59> I just use a text editor personally
[15:20:57] <cmr> tiffany: there's an etags file, and someone could definitely write something intelligent for already-compiled crates using the rustdoc json
[15:21:10] <Ferio> I wonder when cloud9/ace will work with rust ;)
[15:21:13] *** Joins: RageOfThou (RageOfThou@3FEF494C.29C984D5.783DEDCA.IP)
[15:21:14] *** Quits: MrFahrenheit (RageOfThou@3FEF494C.29C984D5.783DEDCA.IP) (Ping timeout)
[15:21:20] *** Quits: rca (rcatolino@moz-2346035D.adsl.proxad.net) (Ping timeout)
[15:21:29] <tiffany> youcompleteme uses libclang for semantic completion, does the etags file plug into that?
[15:21:50] <cmr> Ferio: there was syntax highlighting for ace, but it's super old now.
[15:21:56] <mib_ony321> Think sublime has a plugin for rust
[15:22:33] <adridu59> I tried it someday and it was pretty bad
[15:22:34] <Ferio> cmr: yes that's just a textmate port unfortunately
[15:22:35] *** Quits: ofeldt (ofeldt@moz-B7E2366D.dip0.t-ipconnect.de) (Ping timeout)
[15:22:54] <adridu59> I mean no offence to the developers but all block syntax like curlies were pink
[15:23:14] *** Quits: RageOfThou (RageOfThou@3FEF494C.29C984D5.783DEDCA.IP) (Ping timeout)
[15:23:28] *** Joins: MrFahrenheit (RageOfThou@3FEF494C.29C984D5.783DEDCA.IP)
[15:23:52] <cmr> tiffany: YCM can use many completion engines, and etags ties into omnicomplete.
[15:24:14] <tiffany> I think I only have the libclang support in my install
[15:24:48] <adridu59> speaking of text editors, I've been impressed by vim in pcwalton's presentation of SProcketNES
[15:24:59] <adridu59> but console based thingy kinda scares me
[15:25:13] *** Quits: tulloch (tulloch@moz-F362C074.lnse2.pie.bigpond.net.au) (Ping timeout)
[15:25:14] *** Joins: AvianFlu (AvianFlu@974D245D.130DDD13.67CD788C.IP)
[15:25:15] <adridu59> :p
[15:26:01] <mitsuhiko> if i have a fn foo<T> that calls a function bar<T>, is that supposed to work?
[15:26:08] <cmr> tiffany: that's pretty hard to do since it's not configurable :P
[15:26:09] <mitsuhiko> because right now i always get failed to find an implementation of trait std::from_str::FromStr for T
[15:26:14] *** Joins: ofeldt (ofeldt@moz-B7E2366D.dip0.t-ipconnect.de)
[15:26:19] <mitsuhiko> (foo<T> calls from_str<T>)
[15:26:27] <tiffany> oh
[15:26:31] <tiffany> well I don't have omnicomplete installed
[15:26:37] <cmr> it's built in to vim
[15:26:42] <cmr> that's vim's built-in system
[15:26:44] *** Quits: MrFahrenheit (RageOfThou@3FEF494C.29C984D5.783DEDCA.IP) (Ping timeout)
[15:26:51] <tiffany> oh
[15:26:55] <tiffany> I've never even used it
[15:26:58] *** Joins: MrFahrenheit (RageOfThou@3FEF494C.29C984D5.783DEDCA.IP)
[15:27:05] *** Quits: mib_ony321 (Mibbit@7FD88CD2.6A0A1420.39C00A7A.IP) (Quit: http://www.mibbit.com ajax IRC Client)
[15:27:18] <cmr> mitsuhiko: from_str<T> isn't the signature, it's from_str<T: FromStr>
[15:27:32] <cmr> mitsuhiko: you need to bound the type by FromStr
[15:27:54] <mitsuhiko> cmr: \o/
[15:28:02] <mitsuhiko> too much c++ :)
[15:29:21] <tiffany> how do you use/get the etags file?
[15:29:37] *** Quits: ofeldt (ofeldt@moz-B7E2366D.dip0.t-ipconnect.de) (Ping timeout)
[15:30:48] *** Joins: nkoep (nik@moz-86B3FBAD.pool.mediaways.net)
[15:31:15] *** Joins: tulloch (tulloch@moz-F362C074.lnse2.pie.bigpond.net.au)
[15:31:24] <cmr> make tags
[15:31:45] <cmr> it's src/etc/ctags.rust
[15:32:19] <cmr> tiffany: http://www.reddit.com/r/rust/comments/1rlv79/did_you_know_you_can_generate_tags_for_rust/
[15:33:03] *** Quits: tulloch (tulloch@moz-F362C074.lnse2.pie.bigpond.net.au) (Ping timeout)
[15:33:14] *** Joins: Krymise (Nietzsche@moz-CA789EF5.nwrknj.fios.verizon.net)
[15:33:14] *** Joins: ofeldt (ofeldt@moz-B7E2366D.dip0.t-ipconnect.de)
[15:35:20] *** Joins: elux (peter@moz-6B45ADE5.dsl.bell.ca)
[15:36:00] *** Joins: moostik (Icedove@moz-40E6ACEF.w2-2.abo.wanadoo.fr)
[15:37:10] <mitsuhiko> so a ~[u8] does not automatically become a &[u8]?
[15:37:20] *** Joins: awidegreen (awidegreen@F5604489.EC0D9A3.7B8A71D0.IP)
[15:37:26] <cmr> mitsuhiko: it will be coerced in certain situations
[15:37:52] <cmr> but, in particular, Foo<~[u8]> will not coerce to Foo<&[u8]>
[15:38:19] <mitsuhiko> in this case it does not coerce: https://gist.github.com/mitsuhiko/7f9cc87667a2c0ce43e4
[15:38:48] <mitsuhiko> the IntArg arm complains that buf (~[u8]) is not &[u8]
[15:38:53] <mitsuhiko> not sure if i'm even on the right track here
[15:39:06] *** Quits: pseudoku (quassel@F3474739.32C4AD94.520CDC98.IP) (Client exited)
[15:39:15] <cmr> try buf.as_slice()
[15:39:29] <mitsuhiko> indeed, that works \o/
[15:39:39] <cmr> I would have expected that to coerce :(
[15:39:48] <tiffany> I don't think this does what I was looking for
[15:40:01] <tiffany> I wanted semantic completion for rust, like what YCM can do for C/C++
[15:40:12] <KokaKiwi> Hi, anyone know if something like that can work? https://gist.github.com/8171581 If yes, how? Rust reply with an error :(
[15:40:37] <KokaKiwi> (I talk about mod.rs:14)
[15:41:20] <cmr> KokaKiwi: T::hash isn't how it's done, it's Hasher::hash(self)
[15:41:41] <KokaKiwi> "cannot determine a type for this bounded type parameter: unconstrained type" :/
[15:41:47] <KokaKiwi> Already tried this
[15:42:29] *** Quits: jaen (jaen@moz-E0979827.copit.pl) (Ping timeout)
[15:43:22] <eddyb> KokaKiwi: it says it's unconstrained. constrain it then :)
[15:43:29] <KokaKiwi> Î've tried to implement this by passing an instance of Hasher (and it's works), but I want to have this "form" which seems to me to be more...expressive
[15:43:39] <KokaKiwi> eddyb: I don't know how to do that :(
[15:43:57] <cmr> KokaKiwi: the problem is the generic return value of U
[15:43:58] <KokaKiwi> I don't know where the the type is nconstrained
[15:44:14] <eddyb> KokaKiwi: it should tell you :P
[15:44:29] <Blei> where do you even use T in to_hash? none of the arguments or return types depend on it
[15:45:10] *** Quits: brianm (brianm@moz-8161EF8D.hsd1.ca.comcast.net) (Ping timeout)
[15:45:12] <KokaKiwi> Blei: Look the test_dummy
[15:45:17] <KokaKiwi> +function
[15:46:33] <KokaKiwi> My previous implementation (which works): https://gist.github.com/8171651
[15:46:54] <eddyb> why can't I use catch throw in gdb to catch this failure?
[15:46:56] <eddyb> task 'rustc' failed at 'RefCell<T> already borrowed', /home/eddy/Projects/rust/src/libstd/cell.rs:167
[15:47:20] <cmr> eddyb: we don't depend on C++ anymore, catch throw hooks into the C++ symbols
[15:47:32] <eddyb> cmr: great :(
[15:47:40] <cmr> break rust_begin_unwind
[15:48:06] *** Quits: jhasse (jhasse@moz-F3702E2C.ewe-ip-backbone.de) (Quit: Verlassend)
[15:48:21] *** Quits: ofeldt (ofeldt@moz-B7E2366D.dip0.t-ipconnect.de) (Ping timeout)
[15:48:22] <eddyb> cmr: doesn't work either
[15:48:29] <cmr> whu
[15:48:41] <eddyb> it also doesn't seem to be present
[15:48:44] *** Quits: erickt1 (Adium@moz-4B000CB7.dyn.optonline.net) (Quit: Leaving.)
[15:49:11] <cmr> hm
[15:49:29] <cmr> probably because it's statically linked, and the symbol is disapearing?
[15:49:34] <cmr> that's a problem.
[15:49:43] <cmr> acrichto: ^
[15:49:58] *** Joins: mib_t635yp (Mibbit@moz-367C3D5.dip0.t-ipconnect.de)
[15:50:34] <mitsuhiko> i still don't know what the best plan for error handling in rust is
[15:50:40] <eddyb> Result
[15:50:42] <mitsuhiko> especially for things like connecting to databases and things
[15:50:47] <mitsuhiko> eddyb: Result is super annoying
[15:50:58] <mitsuhiko> it's even worse in my case where the result is an option
[15:51:43] <cmr> Well either you use one of those, or you simply fail! on error, and kill the task.
[15:51:46] *** Joins: ofeldt (ofeldt@moz-B7E2366D.dip0.t-ipconnect.de)
[15:52:07] *** Joins: erickt1 (Adium@moz-4B000CB7.dyn.optonline.net)
[15:52:31] <mib_t635yp> hi, I'm new to rust and just fiddling around with basic stuff: let vals = [1, 2, 3, 4, 5]; let mut res = vals.iter().filter( |&x| *x > 3);
[15:52:45] <eddyb> cmr: there's like 12 exported functions. this is bad
[15:52:49] <mib_t635yp> two questions: why does filter somehow use "double" pointers
[15:53:02] *** Joins: tulloch (tulloch@moz-F362C074.lnse2.pie.bigpond.net.au)
[15:53:05] <eddyb> cmr: probably good for performance, but bad for me :(
[15:53:07] <cmr> mib_t635yp: is there actually two layers of indirection? it should definitely only be one.
[15:53:13] <mib_t635yp> and why is rust unable to infer the type of collect()?
[15:53:29] <mib_t635yp> maybe I'm completely off, but
[15:53:53] <eddyb> really depends on the code using the result of collect()
[15:53:58] <bjz> mib_t635yp: use .to_owned_vec()
[15:53:58] <mib_t635yp> collect() yiels an array of [~1, ~2] etc
[15:54:00] <cmr> eddyb: -Z prefer-dynamic
[15:54:16] <eddyb> mib_t635yp: that shouldn't happen
[15:54:26] <eddyb> bjz: I thought that was to be avoided
[15:54:35] <eddyb> cmr: but how do I inject that into the build process?
[15:54:37] <bjz> mib_t635yp: collect is how you can 'collect' into a FromIterator thing
[15:54:45] <mib_t635yp> just a second, i'll paste my code
[15:54:51] *** Quits: tulloch (tulloch@moz-F362C074.lnse2.pie.bigpond.net.au) (Ping timeout)
[15:54:55] <eddyb> cmr: or how do I build stage1-rustc (the executable) myself?
[15:54:57] <cmr> eddyb: RUSTFLAGS="-Z prefer-dynamic"
[15:55:11] <cmr> eddyb: the makefiles use that
[15:55:33] <bjz> eddyb: well you have to store the stuff generated from a map or filter somewhere
[15:55:50] <strcat> mitsuhiko: no point of using Result if you don't have more than 1 error to return
[15:55:56] <strcat> anyway, in my opinion Result makes no sense
[15:56:07] <strcat> Either<int, ErrorEnum> is saner
[15:56:23] <eddyb> bjz: I meant to_owned_vec vs collect
[15:56:25] <mitsuhiko> for connecting and other things i'm currently using Result<Obj, ErrorEnum>
[15:56:25] <strcat> the error is the important part
[15:56:35] <mitsuhiko> but i don't want to do this for every single db operation
[15:56:44] <mitsuhiko> i was thinking of having a callback for errors
[15:57:10] <strcat> mitsuhiko: but then you have to pass a callback every time
[15:57:21] <strcat> mitsuhiko: .get() doesn't seem like much to ask when you want to ignore the error case
[15:57:22] <bjz> eddyb: to_owned_vec is just collect, but with the type constrained to a ~[T], I think. I'll have to check though - strcat would know
[15:57:29] <cmr> it is
[15:57:41] <strcat> to_owned_vec is an anti-pattern to make up for lack of a language feature
[15:57:45] <eddyb> ^^
[15:57:45] <mib_t635yp> this is my collect code: http://mibpaste.com/puJ58C 
[15:57:48] <mitsuhiko> i wish there was an operator for unwrap
[15:57:56] <bjz> strcat: yeah?
[15:57:59] <mitsuhiko> and options would work like c#'s nullables
[15:58:06] <strcat> the stdlib has good examples of anti-patterns
[15:58:15] <bjz> :P
[15:58:16] <strcat> such as using traits instead of generic functions
[15:58:23] <strcat> when you are implementing the trait for 1 type
[15:58:33] <strcat> so you have 10000 useless traits making the docs unreadable
[15:58:45] *** Quits: rauh (tadnr@moz-6398EFDF.dclient.hispeed.ch) (Quit: Leaving)
[15:58:50] <mib_t635yp> and the result is "filter=~[&4, &5]"
[15:58:51] <strcat> luckily, there's that prelude anti-pattern, so you can hide that you've done it for people not reading the docs
[15:58:59] <strcat> with the side effect of using up a bunch more common names
[15:59:16] *** Joins: rauh (tadnr@moz-24DEE44B.snydernet.net)
[15:59:30] <strcat> want to call a type Char? too bad, the stdlib abused it to implement methods on char
[15:59:43] *** Quits: erickt1 (Adium@moz-4B000CB7.dyn.optonline.net) (Quit: Leaving.)
[15:59:56] <cmr> mib_t635yp: yes, that's what it should be.
[15:59:58] <eddyb> strcat: about that, I wanted to fix built-in types
[16:00:11] <strcat> although atm it lets you shadow everything
[16:00:15] <eddyb> strcat: #[lang="char"] struct char;
[16:00:20] *** Quits: maikklein (maik@moz-2F166E55.dip0.t-ipconnect.de) (Ping timeout)
[16:00:22] <strcat> rusti: let int = "foo"; int
[16:00:23] -rusti- "foo"
[16:00:30] *** Quits: rauh (tadnr@moz-24DEE44B.snydernet.net) (Quit: Leaving)
[16:00:37] *** Joins: quer (tadnre@moz-38369F9F.noisetor.net)
[16:00:46] <strcat> eddyb: sure
[16:00:47] <eddyb> strcat: that's actually not shadowing :P - it's just in a different namespace
[16:00:50] <strcat> I have a bug open about it
[16:00:57] <mib_t635yp> why can't the type of foo be inferred in my example?
[16:00:58] <eddyb> item: @item all over the AST
[16:01:03] <strcat> rusti: struct Char;
[16:01:04] -rusti- ()
[16:01:06] <strcat> eddyb: nope
[16:01:07] <cmr> mib_t635yp: because it's never constrained.
[16:01:09] <strcat> that's in the prelude
[16:01:25] <cmr> mib_t635yp: .collect() has a generic return type
[16:01:27] <mib_t635yp> so i'd have to define vals as int or so
[16:01:31] <mib_t635yp> ?
[16:01:32] <strcat> rusti: use foo::Foo; mod foo { pub trait Foo {} }
[16:01:35] -rusti- pastebinned 10 lines of output: http://ix.io/9yR
[16:01:37] <cmr> no, unrelated.
[16:01:42] <mib_t635yp> ok
[16:01:43] <eddyb> strcat: link to the issue?
[16:01:46] <cmr> collect can return any collection that implements FromIterator
[16:02:00] <strcat> rusti: use foo::Foo; pub mod foo { pub trait Foo {} }
[16:02:02] -rusti- pastebinned 10 lines of output: http://ix.io/9yS
[16:02:14] * strcat shrugs
[16:03:26] <eddyb> strcat: it's inside main
[16:03:27] *** Quits: awidegreen (awidegreen@F5604489.EC0D9A3.7B8A71D0.IP) (Ping timeout)
[16:03:28] <mib_t635yp> cmr: so 'the information' is 'lost' if you will? is there another possibility without losing it?
[16:03:28] <eddyb> cmr: where is rust_begin_unwind?
[16:03:40] <eddyb> rusti: use self::foo::Foo; pub mod foo { pub trait Foo {} }
[16:03:42] -rusti- pastebinned 10 lines of output: http://ix.io/9yU
[16:03:58] *** Quits: quer (tadnre@moz-38369F9F.noisetor.net) (Quit: Leaving)
[16:04:12] <eddyb> rusti: struct int;
[16:04:13] -rusti- ()
[16:04:17] <strcat> since when can you not define modules inside main? ;\
[16:04:21] <eddyb> strcat: I think that's what you meant ^^
[16:04:29] <cmr> mib_t635yp: that metaphor doesn't really make sense.. there's no information to begin with. collect could return anything at all. you need to tell it which one you want.
[16:04:30] <strcat> eddyb: yeah
[16:04:33] <eddyb> and you can define modules, but not use them as easily
[16:05:15] *** Joins: yichoi (yichoi@5AB4884B.FCC4549.14D5B978.IP)
[16:05:23] *** Joins: jaen (jaen@moz-E7986949.play-internet.pl)
[16:05:33] *** Joins: derby (dirby@moz-59B50D76.torservers.net)
[16:05:38] <cmr> eddyb: hm, it's now std::rt::unwind::Unwinder::begin_unwind
[16:05:45] <eddyb> hahaha
[16:06:05] <cmr> it uses to be a func in rustrt
[16:06:19] <eddyb> cmr: can we please make a gdb script for that?
[16:06:26] <mib_t635yp> cmr: ok, what I have in mind is the haskell 'approach' where I can directly output the result of filter like "filter (>5) [1,2,3,4,5,6,7,8]"
[16:06:39] <eddyb> mib_t635yp: but that's an iterator
[16:06:41] <strcat> mib_t635yp: rust doesn't have lazy lists, not going to work
[16:06:42] <eddyb> without .collect()
[16:06:57] *** Quits: yichoi (yichoi@5AB4884B.FCC4549.14D5B978.IP) (Ping timeout)
[16:07:17] <eddyb> strcat: you can still pass iterators around
[16:07:26] <strcat> sure, iterators are the closest thing to a lazy list
[16:07:37] <strcat> not the same though
[16:08:02] <mib_t635yp> ok, I realize still have to catch up on some concepts and wich ones are available ;) the syntax looked so nice, that I figured something like this must be possible ;D
[16:08:28] <strcat> mib_t635yp: possible sure, incredibly inefficient too
[16:08:31] <eddyb> cmr: _Unwind_RaiseException is an import
[16:08:37] <strcat> you want every chained method to allocate a whole new container?
[16:08:52] <eddyb> cmr: and breaking on it works :D
[16:08:52] <strcat> even in python, that's looked down on
[16:09:18] *** Quits: AvianFlu (AvianFlu@974D245D.130DDD13.67CD788C.IP) (Input/output error)
[16:09:27] <mib_t635yp> in my current knowledge state of rust, I don't yet care about efficiency :)
[16:09:42] <mib_t635yp> but I can see the problem
[16:09:43] *** Quits: bheylin (brianheyli@moz-8255E94E.adsl.online.nl) (Quit: bheylin)
[16:09:44] <strcat> if you don't care about efficiency, rust is a strange language to use
[16:09:53] <eddyb> was going to say something similar :D
[16:10:01] <mib_t635yp> I didn't say I don't care, just not yet
[16:10:10] <mib_t635yp> I don't even know the syntax/semantic
[16:10:15] *** Joins: bheylin (brianheyli@moz-8255E94E.adsl.online.nl)
[16:10:28] <mib_t635yp> I'm usually an assembly guy for what it's worth...
[16:10:37] *** Quits: derby (dirby@moz-59B50D76.torservers.net) (Quit: Leaving)
[16:11:07] *** Quits: jaen (jaen@moz-E7986949.play-internet.pl) (Ping timeout)
[16:11:34] *** Joins: derby (dirby@moz-D5AEE09B.torservers.net)
[16:13:00] *** Joins: erickt1 (Adium@moz-4B000CB7.dyn.optonline.net)
[16:13:04] *** Joins: nano (nano@moz-ED77243C.superkabel.de)
[16:13:16] *** Quits: jviereck (Adium@moz-A42B7BD5.dip0.t-ipconnect.de) (Quit: Leaving.)
[16:13:28] *** Joins: jmgrosen (jmgrosen@moz-AB3ADE2D.sb.sd.cox.net)
[16:13:37] *** Quits: SiegeLord (sl@moz-CAF07B4C.hsd1.ma.comcast.net) (Quit: It's a joke, it's all a joke.)
[16:15:43] *** Quits: dwrensha (chatzilla@moz-DE44EA45.hsd1.pa.comcast.net) (Ping timeout)
[16:16:47] <mitsuhiko> if someone has some api feedback for this redis library, please give: https://github.com/mitsuhiko/redis-rs/blob/master/src/
[16:17:52] <eddyb> mitsuhiko: this doesn't need to be a separate file https://github.com/mitsuhiko/redis-rs/blob/master/src/redis/enums.rs
[16:18:18] <mitsuhiko> not at the moment, because i do use * on those
[16:18:34] <mitsuhiko> but the plan was to use enums::Nil etc.
[16:18:39] <mitsuhiko> to avoid naming conflicts
[16:19:01] <mitsuhiko> kinda wish enums would be scoped below their type
[16:19:06] <eddyb> enum values?
[16:19:07] <mitsuhiko> unless you use them to a higher level
[16:19:16] <mitsuhiko> eg: Value::Int instead if enum Value { Int }
[16:19:22] <mitsuhiko> s/instead/
[16:19:46] <eddyb> didn't the enum mod PR go through?
[16:19:57] <Blei> no, it got rejected
[16:19:57] <sfackler> nope
[16:21:50] <eddyb> mitsuhiko: if I were you, I would rewrite this into a state machine :P https://github.com/mitsuhiko/redis-rs/blob/master/src/redis/parser.rs
[16:22:07] <eddyb> though it should work the way you're using it if Reader is sync
[16:22:29] <mitsuhiko> it's super annoying to write it as state machine
[16:24:37] <eddyb> and beatiful :)
[16:24:56] <mitsuhiko> i might have to do it anyways because right now i just eat up read errors
[16:25:04] <eddyb> oh, so that happens
[16:28:13] *** Quits: mib_t635yp (Mibbit@moz-367C3D5.dip0.t-ipconnect.de) (Quit: http://www.mibbit.com ajax IRC Client)
[16:31:11] *** Joins: kiko (Mibbit@moz-818475B1.bredband.comhem.se)
[16:31:40] *** Quits: Kxepal (Miranda@moz-D3669ABE.pppoe.mtu-net.ru) (Ping timeout)
[16:32:22] *** Parts: kiko (Mibbit@moz-818475B1.bredband.comhem.se) ()
[16:35:35] <erickt1> mitsuhiko: I'm starting to have second thoughts about writing parsers using iterators. I think Readers can be a bit more versatile because you can read a whole bunch of bytes at once
[16:35:40] *** Joins: Kxepal (Miranda@moz-2C828513.pppoe.mtu-net.ru)
[16:36:07] <mitsuhiko> erickt1: same
[16:36:21] <mitsuhiko> also it works on char iterators quite well, but on u8 iterators it's madness
[16:36:29] <eddyb> erickt1: but.... state machines...
[16:36:56] <erickt1> eddyb: oh I've been fighting with state machines for a while with my serialize.rs rewrite :)
[16:37:11] *** Joins: jaen (jaen@moz-E0979827.copit.pl)
[16:37:16] <erickt1> I got to run now though
[16:37:18] * eddyb doesn't like sync Reader - doesn't model networking properly
[16:38:04] *** Quits: erickt1 (Adium@moz-4B000CB7.dyn.optonline.net) (Quit: Leaving.)
[16:39:49] *** Quits: jaen (jaen@moz-E0979827.copit.pl) (Ping timeout)
[16:40:02] *** Joins: josh (josh@moz-348C4790.hsd1.mn.comcast.net)
[16:43:15] *** Quits: bheylin (brianheyli@moz-8255E94E.adsl.online.nl) (Quit: bheylin)
[16:44:57] *** Quits: canhtak (canhtak@moz-59105D0.wl.t.ulaval.ca) (Quit: canhtak)
[16:46:11] *** Joins: canhtak (canhtak@moz-59105D0.wl.t.ulaval.ca)
[16:47:34] <adridu59> why is `char` 32-bits long?
[16:47:47] <strcat> adridu59: because it's a Unicode code point (UCS4 character)
[16:48:04] <strcat> if you want a byte, you can use i8/u8
[16:48:27] <strcat> adridu59: it's really 21-bits long, but has to be padded to 4 bytes
[16:48:32] <adridu59> yea I know about u8, just wondering the point of char.. 32bits seems like a lot
[16:49:04] <strcat> adridu59: it's what a Unicode code point needs
[16:49:09] <strcat> can't be any smaller
[16:49:19] <adridu59> UTF-8 is not codepoints?
[16:49:33] <strcat> UTF-8 is a variable length encoding of code points
[16:49:38] <strcat> into a byte sequence
[16:49:52] <adridu59> I don't understand
[16:49:53] <strcat> adridu59: UTF-8 encodes code points as 1 to 4 bytes
[16:50:03] <strcat> some end up as 1 byte, some end up as 4 bytes
[16:50:23] *** Quits: josh (josh@moz-348C4790.hsd1.mn.comcast.net) (Quit: josh)
[16:50:24] <strcat> since it's a byte encoding, it's endian independent - a string is represented the same way in-memory in UTF-8 on little endian and big endian archs
[16:50:47] <adridu59> that's why it's so popular?
[16:50:53] <strcat> part of it
[16:51:01] <cmr> backwards compat with ascii is also big
[16:51:02] <strcat> adridu59: ASCII is a subset of UTF-8, that's a big part
[16:51:20] <adridu59> ascii's one byte?
[16:51:22] <strcat> ASCII is 7-bit
[16:51:37] <strcat> so yes, 1 byte, but there's space for UTF-8 to use to extend it
[16:51:50] <adridu59> ASCII has 1 unused bit?
[16:51:57] <strcat> ASCII is 7-bit
[16:52:07] <strcat> there's not an 'unused' bit, it's just not 8-bit
[16:52:07] <adridu59> but one byte is eight bits?
[16:52:18] <strcat> adridu59: on modern architectures
[16:52:39] <adridu59> so is it clamped to eight bits on modern arch?
[16:52:49] *** kimundi is now known as zz_kimundi
[16:53:00] <strcat> yes, plenty of stuff is padded
[16:53:06] <strcat> a bool is represented as a byte too
[16:53:13] *** Joins: tulloch (tulloch@moz-F362C074.lnse2.pie.bigpond.net.au)
[16:53:22] <strcat> struct Foo { x: u64, y: u32 } is 16 bytes
[16:54:03] <adridu59> sucky
[16:54:05] *** Joins: tautologico (uid22285@moz-A42E5B7B.irccloud.com)
[16:54:10] <strcat> why?
[16:54:21] <adridu59> because it's wasting memory
[16:54:28] <Ferio> adridu59: it's faster
[16:54:37] <strcat> on x86, it's faster
[16:54:47] <adridu59> because of higher word size
[16:54:50] <strcat> elsewhere, not padding would cause a bus error
[16:54:55] <strcat> adridu59: no
[16:55:00] <strcat> because of aligned memory access
[16:55:01] *** Quits: tulloch (tulloch@moz-F362C074.lnse2.pie.bigpond.net.au) (Ping timeout)
[16:55:04] <Ferio> adridu59: if you need to save memory you can pack a structs…
[16:55:05] <adridu59> I see
[16:55:07] <strcat> and not overlapping cache lines as much
[16:55:12] <strcat> Ferio: on x86 ;]
[16:55:32] <strcat> adridu59: so, lets say you have an array
[16:55:34] <adridu59> can you have a largus bus and do unaligned accesses?
[16:55:37] <strcat> an array is a contiguous block of memory
[16:55:37] <adridu59> larger
[16:55:39] <Ferio> strcat: not arm?
[16:55:49] <strcat> Ferio: on ARM you'll get a bus error (and most archs)
[16:55:54] <strcat> anyway lets say you have
[16:55:57] <strcat> [Foo, ..4]
[16:56:03] <strcat> it's a contiguous array of Foo
[16:56:14] <strcat> now lets say Foo is 'struct Foo { x: u64, y: u32 }'
[16:56:30] *** Joins: hoverbear (hoverbear@moz-86FCBF4B.gv.shawcable.net)
[16:56:42] <strcat> the native alignment of u64 is 8 bytes, accessing one with a 4 byte alignment (address is not a multiple of 8) is invalid on most archs
[16:56:49] <strcat> on x86 it's valid, but slower
[16:56:54] <strcat> (until very recent CPUs)
[16:57:00] <strcat> anyway
[16:57:03] <eddyb> wait, so, the struct is bigger, instead of having a special case for vectors?
[16:57:21] <eddyb> it makes sense, I just didn't know
[16:57:33] <strcat> eddyb: arrays, any kind of pointer arithmetic
[16:57:37] <eddyb> strcat: still haven't linked me to libify builtin types :)
[16:57:39] <strcat> you couldn't 'special-case' an array
[16:57:49] <adridu59> I see
[16:58:12] <strcat> anyway you have to keep that u64 on an 8 byte multiple
[16:58:23] <strcat> so in order to keep that true in an array, structs inherit the alignment of the largest field
[16:58:32] <strcat> and have to be padded to a multiple that alignment
[16:58:35] <eddyb> bleah
[16:58:41] <strcat> so that the *next* struct in an array starts at the right place
[16:58:50] <eddyb> yet another reason we're wasting memory like crazy
[16:58:58] <strcat> C and C++ do this too
[16:59:04] <strcat> eddyb: if you don't align memory, you'll get bus errors....
[16:59:09] <adridu59> seems logical
[16:59:09] <strcat> on x86 you won't, but it'll be slow
[16:59:19] <adridu59> nice waste anyways
[16:59:19] <eddyb> strcat: I was thinking of the nesting in the AST
[16:59:44] <adridu59> strcat: could you explain me why I would want to use char instead of u8 somewhere?
[16:59:48] *** ninechars is now known as glaebhoerl
[16:59:56] <strcat> adridu59: if you need a unicode code point
[17:00:02] <strcat> that's what it's for
[17:00:04] *** Quits: dredozubov (dredozubov@moz-1E374954.nationalcablenetworks.ru) (Input/output error)
[17:00:45] <strcat> you should rarely be doing manipulation of strings beyond concatenation so needing it isn't going to be frequent beyond for appending code points to a string
[17:01:20] * eddyb stares at front::config in vain
[17:01:36] <eddyb> where does the extra memory usage come from?
[17:01:46] <strcat> eddyb: what do you mean?
[17:01:53] <eddyb> configuration leaks
[17:02:03] <Ferio> strcat: so no memcpy on arm to read structs from files…nice to know :)
[17:02:05] <adridu59> strcat: but why would I need that? I don't know what a codepoint is
[17:02:16] *** Joins: jhasse (jhasse@moz-F3702E2C.ewe-ip-backbone.de)
[17:02:17] <Ferio> cast I mean…
[17:02:23] <eddyb> strcat: and I don't (yet) understand what's it doing that makes it worse than a noop folder
[17:02:23] <strcat> adridu59: well, it's too complex to explain here
[17:02:24] <cmr> adridu59: http://www.joelonsoftware.com/articles/Unicode.html
[17:02:31] <glaebhoerl> strcat: "struct Foo { x: u64, y: u32 } is 16 bytes" it's 12 here
[17:02:41] <glaebhoerl> I'm on x86-32, is it different on -64?
[17:02:55] <adridu59> sounds cool, thanks for the link
[17:03:00] <eddyb> glaebhoerl: ia32 doesn't have native u64
[17:03:00] <strcat> glaebhoerl: yes
[17:03:08] <strcat> glaebhoerl: x86 doesn't have 64-bit so u64 is emulation
[17:03:15] <glaebhoerl> ok then
[17:03:19] <eddyb> glaebhoerl: so what you have is basically (u32, u32, u32)
[17:03:35] * glaebhoerl sees
[17:04:17] *** Joins: maxiepoo (Max@moz-D66F3D4E.atvci.net)
[17:04:30] <glaebhoerl> is it the law that sizeof must always be a multiple of alignof?
[17:04:51] <strcat> glaebhoerl: no
[17:04:57] <strcat> but it's the case that you can't define a type that's not
[17:05:01] <strcat> without #[packed]
[17:05:07] *** Quits: Axord (xord@moz-C0D5F15A.lsanca.dsl-w.verizon.net) (Ping timeout)
[17:05:28] <strcat> glaebhoerl: since in an array, the next element needs to start at the alignment boundary
[17:05:35] <strcat> and arrays are contiguous
[17:05:40] *** Parts: photex (photex@399640B9.24E301D6.9510F13D.IP) (WeeChat 0.3.8)
[17:05:47] *** Joins: yichoi (yichoi@5AB4884B.FCC4549.14D5B978.IP)
[17:06:13] *** Joins: awidegreen (awidegreen@F5604489.EC0D9A3.7B8A71D0.IP)
[17:06:13] <glaebhoerl> yeah I know about arrays. I was just forgetting about #[packed] :)
[17:06:17] <glaebhoerl> distinctions, distinctions
[17:06:37] <strcat> on most architectures, #[packed] + arrays will give you bus errors
[17:06:50] *** Joins: jaen (jaen@moz-E7986949.play-internet.pl)
[17:06:53] <glaebhoerl> (btw I checked: there's no one in #[packed])
[17:07:29] *** Quits: yichoi (yichoi@5AB4884B.FCC4549.14D5B978.IP) (Ping timeout)
[17:07:31] <strcat> glaebhoerl: on x86, struct Foo { x: u32, x: u16 } would show it
[17:08:33] <mitsuhiko> what's the best way currently to reuse macros between modules?
[17:08:33] <glaebhoerl> indeed
[17:09:33] *** Joins: wilmoore (wilmoore@moz-71431C3A.hsd1.co.comcast.net)
[17:10:05] <strcat> mitsuhiko: put them in a macro module with #[macro_escape] and import it in each
[17:10:15] <strcat> mitsuhiko: and don't include it as a public module in the crate hierarchy at all
[17:10:30] <mitsuhiko> strcat: import with "use macros"?
[17:10:34] <strcat> mitsuhiko: mod macros
[17:10:39] <mitsuhiko> strcat: import with "use macros"?
[17:10:43] <mitsuhiko> wrong window
[17:10:45] <mitsuhiko> thanks, that works
[17:10:47] *** Joins: hjr3 (hradtke@moz-E87BDF1F.socal.res.rr.com)
[17:10:50] <mitsuhiko> much better than include!
[17:11:02] <strcat> it should get better
[17:11:07] <strcat> atm there's no way to export from a crate
[17:11:24] <strcat> the stdlib works around this by having the compiler hard-wired with the macros
[17:11:32] <eddyb> bleah
[17:11:34] <strcat> it includes them in every crate at the top
[17:11:51] <strcat> rust likes papering over problems instead of fixing them ;p
[17:11:55] <eddyb> strcat: mkay. so look here: http://huonw.github.io/isrustfastyet/mem/ - enable passes
[17:12:10] <mitsuhiko> strcat: i only use them internally anyways
[17:12:11] <eddyb> std injection and assigning node ids are flat lines
[17:12:36] <mitsuhiko> is there a macro like the first one here in the stdlib already somewhere? https://github.com/mitsuhiko/redis-rs/blob/master/src/redis/macros.rs
[17:12:51] <eddyb> strcat: configuration 1 and configuration 2 use almost more than expansion *each*
[17:13:36] <strcat> mitsuhiko: ah, for lazy evaluation? I don't think so.
[17:14:02] <mitsuhiko> found it very useful for making things less nested
[17:14:09] <eddyb> not just lazy, but early return
[17:14:12] <strcat> from_some/from_left are better names than unwrap imo
[17:14:12] <mitsuhiko> eg: https://github.com/mitsuhiko/redis-rs/blob/master/src/redis/client.rs#L60
[17:14:18] <strcat> unwrap/get are too common so it's hard to tell what's going on
[17:14:36] <glaebhoerl> +1
[17:14:37] *** Joins: maikklein (maik@moz-2F166E55.dip0.t-ipconnect.de)
[17:14:49] <strcat> anyway not going to change in the stdlib
[17:15:14] *** Quits: MrFahrenheit (RageOfThou@3FEF494C.29C984D5.783DEDCA.IP) (Ping timeout)
[17:15:58] *** Joins: MrFahrenheit (RageOfThou@3FEF494C.29C984D5.783DEDCA.IP)
[17:16:14] <mitsuhiko> strcat: are you using Either much?
[17:16:27] <mitsuhiko> also, why is there either and reuslt
[17:16:40] <strcat> mitsuhiko: Either is the stdlib is going away
[17:16:42] <strcat> but anyway
[17:16:45] <strcat> I'd prefer just having Either
[17:16:53] <strcat> which is what I plan on doing in rust-core
[17:17:06] <strcat> I don't see any benefit in Result
[17:17:08] <mitsuhiko> why either over result?
[17:17:16] <strcat> because Result is a terrible name
[17:17:19] <strcat> all return values are results
[17:17:21] <mitsuhiko> or where are you using either if not for error handling
[17:17:29] <strcat> mitsuhiko: as an anonymous sum type
[17:17:33] <strcat> same reason you use tuples
[17:17:33] *** Joins: tsvia (tsvia@moz-B0C164A1.bb.netvision.net.il)
[17:17:51] <mitsuhiko> just that result gives a clear indication that it could be an error
[17:17:56] *** Quits: awidegreen (awidegreen@F5604489.EC0D9A3.7B8A71D0.IP) (Ping timeout)
[17:17:59] <mitsuhiko> and you could compiler enforce that people don't ignore that return value
[17:18:10] <mitsuhiko> eg: it would not be permissible to ignore a Result return value
[17:18:19] <mitsuhiko> as right now you can easily swallow errors
[17:18:52] <strcat> mitsuhiko: gcc has a warn_unused_result attribute
[17:19:07] <mitsuhiko> yeah, but that warns on all
[17:19:09] <eddyb> strcat: libstd needs pluggable allocators
[17:19:10] <mitsuhiko> which is super annoying
[17:19:12] <strcat> mitsuhiko: anyway, lets say a function doesn't have a value it returns if there's no error
[17:19:17] <strcat> Result<(), Err> is really weird
[17:19:21] <strcat> why not just Option<Err>?
[17:19:23] <eddyb> meh. I'll have to use massif :(
[17:19:33] * cmr uses Option<Err> for those
[17:19:40] <mitsuhiko> i use Option<Err> too
[17:19:53] <mitsuhiko> To be honest: i only ever use Option
[17:20:05] <mitsuhiko> i just started using Result because i saw someone else using it
[17:20:08] <mitsuhiko> and i don't enjoy the experience much
[17:20:21] *** Joins: Axord (xord@moz-C0D5F15A.lsanca.dsl-w.verizon.net)
[17:20:32] *** Joins: alan_andrade (alan_andra@9267EE86.1B9BB716.7B097AAD.IP)
[17:20:50] <tautologico> Result only makes sense if you need to return either one or other thing
[17:20:53] *** Joins: awidegreen (awidegreen@F5604489.EC0D9A3.7B8A71D0.IP)
[17:21:02] <tsvia> hi
[17:21:04] <strcat> tautologico: Either works fine for that too ;p
[17:21:14] <mitsuhiko> just that either does not indicate which side is success
[17:21:15] <tsvia> where's the actual documentation for borrowed pointers
[17:21:26] <tautologico> strcat: I forgot there's Either in rust too
[17:21:29] <strcat> mitsuhiko: that's indicated by the type
[17:21:29] <tsvia> up-to-date documentation for borrowed pointers and the rust type system
[17:21:29] <tsvia> ?
[17:21:35] <strcat> tautologico: not for long in the stdlib
[17:21:45] <strcat> mitsuhiko: errors should always be an error type imo
[17:21:49] <cmr> tsvia: manual, borrowed pointer tutorial, tutorial.
[17:21:56] <mitsuhiko> I hate that there are Result<X, ~str> around
[17:22:00] <mitsuhiko> stringly typed api are the devil
[17:22:03] <cmr> mitsuhiko++
[17:22:11] <tsvia> It feels a bit sparse on details
[17:22:16] <tautologico> in Haskell it's only Either
[17:22:16] <tsvia> on lifetimes
[17:22:20] <cmr> it is.
[17:22:29] <cmr> but it's all there is
[17:22:34] <strcat> anyway I don't care about the stdlib so I'm not going to fight over issues like this
[17:22:41] <strcat> just language issues, which this is not
[17:22:53] <mitsuhiko> strcat: the language comes with the stdlib though
[17:23:02] <mitsuhiko> and disagreements between stdlib and what everybody else does is what made the python stdlib absolute shitty
[17:23:13] <strcat> mitsuhiko: but it's optional
[17:23:19] *** Quits: nuts (tii@822A8E7E.6AD15BF5.75D3BBDB.IP) (Connection reset by peer)
[17:23:19] *** Joins: anshin (anshin@CD85F10D.F21429E2.354459FA.IP)
[17:23:19] <strcat> #[no_std]
[17:23:27] <mitsuhiko> writing an stdlib alternative is what killed d
[17:23:28] <mitsuhiko> so ...
[17:23:40] <strcat> too late, it exists, the stdlib doesn't work in freestanding use cases
[17:23:58] *** Quits: maikklein (maik@moz-2F166E55.dip0.t-ipconnect.de) (Ping timeout)
[17:24:03] <mitsuhiko> no_std is useful, but it should not be actively encouraged i think
[17:24:06] <strcat> and there is opposition to including useful stuff like https://github.com/mozilla/rust/pull/10926
[17:24:32] <strcat> mitsuhiko: at some point I plan on devoting a lot of time to making a better stdlib, I disagree with a lot of choices made in the stdlib
[17:24:47] <mitsuhiko> hmm :(
[17:24:47] <strcat> unless I decide I don't like rust
[17:24:51] *** Quits: alan_andrade (alan_andra@9267EE86.1B9BB716.7B097AAD.IP) (Ping timeout)
[17:24:53] <strcat> which is totally possible
[17:25:07] <Siyo> say you've got a large immutable struct that you pass into a function. can rust/llvm optimize out the copy?
[17:25:12] <glaebhoerl> strcat, what would you like better?
[17:25:26] <anshin> quick question. is my (narrow) understanding of this accurate, and where can I read more about it? my understanding is that the Rust runtime is being moved out of libstd so that it will be effectively optional, allowing for things like kernel development
[17:25:42] <strcat> anshin: libstd *is* the runtime
[17:25:49] <anshin> ... oh
[17:25:55] <anshin> I don't think I understand what a runtime is
[17:26:24] <mitsuhiko> well, maybe you are referring to the move of the concurrency bits into libnative and libgreen?
[17:26:26] <strcat> anshin: it isn't really a thing. it's the standard library + a hook used to replace the entry point (your main is not the real entry point without #[no_std])
[17:26:27] <tsvia> is there any documentation for lifetimes? the reference is silent and the borrowed pointer tutorial isn't particularly clear (or deep)
[17:26:27] <adridu59> cmr: about UTF-8, if codepoint size varies, how does the system figure out the codepoint length?
[17:26:54] <cmr> adridu59: read the utf-8 spec. it uses the high bits of the bytes to check if it should continue, essentially.
[17:26:54] <strcat> adridu59: look up how UTF-8 encoding works
[17:27:13] *** Joins: dogurness (dogurness@moz-1BF32EBD.pitbpa.fios.verizon.net)
[17:27:51] <strcat> glaebhoerl: well, rust isn't a strict improvement over C++
[17:28:00] <strcat> it makes a lot of subjective decisions
[17:28:05] <strcat> and I'm not sure I agree with a lot of them
[17:28:13] <mitsuhiko> strcat: which ones in particular?
[17:28:37] <tautologico> language design has to be partly subjective
[17:28:37] <strcat> for example, rust disallows initialization code and destructors for static global/thread-local data
[17:28:47] *** Quits: elux (peter@moz-6B45ADE5.dsl.bell.ca) (Quit: Leaving...)
[17:28:50] <adridu59> smart
[17:28:50] <strcat> entirely for subjective reasons
[17:28:57] <anshin> if that's the case, what are obstacles to something like kernel development?
[17:29:07] <anshin> in rust, that is
[17:29:09] <mitsuhiko> anshin: not sure there are any?
[17:29:14] <strcat> mitsuhiko: there are a lot
[17:29:18] <strcat> rust isn't a great systems language yet
[17:29:26] <strcat> in fact rustc itself can't compile freestanding code
[17:29:38] *** Joins: valenting (Thunderbir@9A1975C1.39CE2EE.E400A05F.IP)
[17:29:39] <mitsuhiko> afaik the only thing that's missing is malloc
[17:29:39] <strcat> you have to work around it by compiling to bytecode and compiling that with clang, which means having a clang close to rust's LLVM
[17:29:43] <anshin> I believe I read that Rust isn't currently (this was several releases back) suitable for kernel development
[17:29:46] <strcat> mitsuhiko: not missing
[17:29:53] <whitequark> strcat: you can do that with just llc...
[17:30:07] <whitequark> (from Rust's LLVM presumably)
[17:30:07] <strcat> whitequark: rust doesn't install those tools
[17:30:07] <mitsuhiko> strcat: required symbol from outside
[17:30:18] <strcat> whitequark: if you keep around the build, sure
[17:30:22] <mitsuhiko> (i thought the person wants to write a kernel module)
[17:30:37] <strcat> whitequark: llc is different than clang in weird ways though...
[17:30:52] *** Quits: wilmoore (wilmoore@moz-71431C3A.hsd1.co.comcast.net) (Ping timeout)
[17:30:55] <whitequark> anshin: I'm working right now on packing together everything one would need to write freestanding software
[17:30:59] <mitsuhiko> strcat: to be honest: i find initializers/destructors for global objects a terrible, terrible idea
[17:31:07] *** Quits: canhtak (canhtak@moz-59105D0.wl.t.ulaval.ca) (Quit: canhtak)
[17:31:08] <whitequark> with the particular aim at microcontrollers, so that may not quite fit your use case
[17:31:10] <mitsuhiko> i hated them in c++
[17:31:26] <strcat> mitsuhiko: ok, so you know what rust does instead?
[17:31:38] <strcat> mitsuhiko: it does a branch every single time you need to use it with an atomic op
[17:31:38] <eddyb> the task local storage?
[17:31:45] <eddyb> oh nvm
[17:31:50] <mitsuhiko> strcat: use what?
[17:32:19] <strcat> static initialization is often necessary
[17:32:24] *** Joins: samx (sami@moz-D9DA5773.dyn.optonline.net)
[17:32:25] <mitsuhiko> not sure i agree
[17:32:42] <mitsuhiko> maybe if you write an allocator
[17:32:49] <mitsuhiko> but aside from that ...
[17:32:53] *** Quits: awidegreen (awidegreen@F5604489.EC0D9A3.7B8A71D0.IP) (Ping timeout)
[17:33:02] <strcat> mitsuhiko: lets say you want a global that's thread-safe
[17:33:02] <tsvia> it isn't particularly good for allocators
[17:33:06] <tsvia> for more complicated stuff
[17:33:10] <strcat> mitsuhiko: can't do it sanely in rust
[17:33:24] <tsvia> thread-safe vs. what?
[17:33:28] <strcat> instead you have to allocate some atomically reference counted thing and pass it around
[17:33:42] <strcat> plenty of other things like this though
[17:34:00] *** Joins: maikklein (maik@moz-2F166E55.dip0.t-ipconnect.de)
[17:34:06] <mitsuhiko> well, i think that whole concept of having a shared global object is not a good idea
[17:34:11] <eddyb> strcat: what do you mean by "static initialization"? something dynamic obtained by running a function in .init?
[17:34:29] <mitsuhiko> allocate it in your main, make a context object, attach it there, pass that around
[17:34:46] <strcat> mitsuhiko: doesn't sound like much of a systems language, pointless overhead for what reason?
[17:34:47] <tsvia> rust doesn't support safe multi-thread access anyway
[17:34:52] <strcat> tsvia: yes it does
[17:34:56] <tsvia> however it lacks proper atomics
[17:35:01] <strcat> no it doesn't
[17:35:04] <eddyb> we have atomics
[17:35:13] <mitsuhiko> strcat: debatable
[17:35:14] *** Joins: JamesNZ (james@moz-264643C7.bitstream.orcon.net.nz)
[17:35:16] <strcat> rust has atomics and safe shared data protected by rwlocks and mutexes
[17:35:29] <mitsuhiko> c is still used for kernel development and has no destructors
[17:35:32] <strcat> mitsuhiko: it's not debatable that shared data is faster and easier to use than message passing in many cases
[17:35:34] * eddyb wrote a thread-safe static global mutable allocator
[17:35:37] <strcat> mitsuhiko: GNU C has dtors
[17:35:43] <strcat> ;p
[17:35:57] <strcat> mitsuhiko: anyway, rust doesn't expose the same alternatives C exposes
[17:36:05] <eddyb> but it requires no initialization
[17:36:16] <glaebhoerl> the problem with static initializers afair was things like what order do they run in, mutual recursion between them, etc.
[17:36:29] *** Quits: dogurness (dogurness@moz-1BF32EBD.pitbpa.fios.verizon.net) (Quit: dogurness)
[17:36:32] <eddyb> glaebhoerl: yeah, they cause a lot of ugly nonsense
[17:36:40] <mitsuhiko> i absolutely despise static initializers
[17:36:48] <mitsuhiko> i can see that they are useful for kernel development
[17:36:51] <eddyb> pedigree had initialize methods on singletons
[17:37:00] <strcat> mitsuhiko: they're useful for more than that
[17:37:01] <mitsuhiko> but for what besides allocators is that really necessary?
[17:37:02] <tsvia> strcat: linux doesn't use them anyway
[17:37:04] <eddyb> because using constructors would've ruined everythhing
[17:37:06] <strcat> mitsuhiko: lots of libraries need to be statically initialized
[17:37:06] <glaebhoerl> maybe you could allow it, just require putting it behind `unsafe`?
[17:37:10] <eddyb> mitsuhiko: what do you mean "allocators"?
[17:37:17] <mitsuhiko> eddyb: memory allocators?
[17:37:21] <strcat> tsvia: sure, and it's totally not relevant to this discussion - rust has destructors
[17:37:34] <eddyb> mitsuhiko: dynamically initializing a global allocator?
[17:37:43] <mitsuhiko> eddyb: not sure what you mean
[17:37:55] <strcat> mitsuhiko: initializing shared data, there are *plenty* of use cases
[17:38:07] <strcat> mitsuhiko: in a language where you are allowed to leave a global uninitialized, then it's not necessary
[17:38:10] <eddyb> mitsuhiko: I'm asking because I'm not sure what *you* mean by allocators, in this context :P
[17:38:10] <mitsuhiko> a library that needs initialization is an antipattern to begin with
[17:38:15] <strcat> mitsuhiko: but plenty of libraries do
[17:38:17] <strcat> NSS does
[17:38:26] <mitsuhiko> strcat: yeah, the init them in main() before other stuff
[17:38:31] <strcat> if you wrap NSS for rust, every single call needs a branch on an atomic
[17:38:47] <strcat> mitsuhiko: can't, doesn't work in rust
[17:38:51] <strcat> mitsuhiko: rust enforces safety.
[17:38:54] <strcat> works in C or C++
[17:39:02] <mitsuhiko> strcat: auto initializing libraries is a stupid idea
[17:39:15] <tsvia> can't you pass a context around?
[17:39:17] <eddyb> if NSS would have a context, there would be no branching required
[17:39:22] <cmr> My prefered pattern for libs which need initialization, whether or not they need a context, is returning a struct that the functions from the lib are methods on
[17:39:25] <strcat> tsvia: with atomic reference counting
[17:39:27] <strcat> sure
[17:39:30] <mitsuhiko> i can't tell you how many network bugs i had to debug because some shitty library called WAStartup
[17:39:39] <cmr> so one needs to go through a function that does init to call them at all
[17:39:40] <tsvia> init it once and pass it around
[17:39:48] <adridu59> is there a documentation for macros?
[17:39:55] <cmr> adridu59: the macro tutorial. otherwise, no.
[17:39:56] <strcat> tsvia: rust makes that quite painful
[17:39:57] <strcat> so have fun with that
[17:40:02] <adridu59> :(
[17:40:03] <glaebhoerl> cmr: that's what I was about to suggest
[17:40:24] <strcat> tsvia: you have to put it in a MutexArc and now every time you want to access it you need a closure
[17:40:30] *** Joins: jdm (jdm@moz-AC9499B2.cable.teksavvy.com)
[17:40:30] *** ChanServ sets mode: +o jdm
[17:40:46] <mitsuhiko> i don't mind passing things around
[17:40:55] <eddyb> strcat: but would it be safe otherwise?
[17:40:56] <tsvia> can't you hide the mutex?
[17:40:59] <mitsuhiko> and ideally you could put references to that into task local storage
[17:41:05] <strcat> tsvia: the mutex is 'hidden', that's why you need closures to access it
[17:41:06] <mitsuhiko> and have some syntax support to fetch the active object of a type from there
[17:41:09] <tsvia> via cas
[17:41:18] <mitsuhiko> eg: give me the current web request object, current database connection, current opengl context etc.
[17:41:23] <eddyb> mitsuhiko: we already have task-local storage AFAIK
[17:41:29] <glaebhoerl> have some kind of `pub struct NssHasBeenInitedEvidence { priv foo: () }` which you can only get by calling init_nss(), and then every nss function requires as an argument
[17:41:30] <mitsuhiko> eddyb: yeah, just no nice syntax support
[17:41:33] <strcat> mitsuhiko: rust doesn't have static task-local storage
[17:41:37] <glaebhoerl> *it
[17:41:37] <cmr> I don't find that needs of crappily-written C libs particularly compelling personally.
[17:41:52] <cmr> And almost all of them are crappily written :(
[17:41:56] <strcat> mitsuhiko: there's #[thread_local] (note that it's not for tasks) but it is *crippled*
[17:42:04] <strcat> mitsuhiko: you can't put anything with a memory allocation in it
[17:42:10] <strcat> mitsuhiko: because again, there's no dtor support for statics
[17:42:14] <strcat> it will leak when the thread ends
[17:42:17] <anshin> whitequark: I've almost no experience at all with systems programming, but I'd like to use Rust in that capacity. I'd like to think of Rust as being capable as a C++ alternative, but I don't think I'm asking the right questions. is this something I can expect from Rust?
[17:42:22] *** Joins: rajul (quassel@B8CA905D.BE0B8B49.C5C1B1F7.IP)
[17:42:25] <eddyb> mitsuhiko: it involves static byte-sized structs or so used and pointers to said structs as keys in a HashMap
[17:42:26] <mitsuhiko> strcat: not sure i understand the problem
[17:42:43] <strcat> mitsuhiko: static thread-local storage where you have syntax support
[17:42:44] <strcat> as in
[17:42:48] <strcat> thread_local int i = 5; in C11
[17:42:55] *** Quits: jmgrosen (jmgrosen@moz-AB3ADE2D.sb.sd.cox.net) (Input/output error)
[17:43:04] <mitsuhiko> strcat: actually no :)
[17:43:05] <strcat> mitsuhiko: rust can have that, but it can't allow you to put anything allocated in it
[17:43:06] <strcat> it'll leak
[17:43:08] <mitsuhiko> i want them as a stack
[17:43:13] *** Joins: jmgrosen (jmgrosen@moz-AB3ADE2D.sb.sd.cox.net)
[17:43:26] <mitsuhiko> task_var uint foo; with foo = 42 { set to something here }
[17:43:31] *** Quits: rajul (quassel@B8CA905D.BE0B8B49.C5C1B1F7.IP) (Client exited)
[17:43:44] <mitsuhiko> but other than that, yes, like a thread_local :)
[17:43:55] *** Quits: Ferio (Mibbit@moz-E7D1C548.pools.arcor-ip.net) (Quit: http://www.mibbit.com ajax IRC Client)
[17:44:20] <strcat> mitsuhiko: anyway I think it's unlikely we'll get that
[17:44:25] <strcat> highly unlikely.
[17:44:30] <eddyb> erm.... we can have TLS-like task storage
[17:44:34] <glaebhoerl> mitsuhiko: https://github.com/mozilla/rust/issues/10602 ?
[17:44:47] <strcat> eddyb: yes, there is dynamic TLS
[17:44:52] <strcat> talking about static TLS + sugar
[17:45:03] <eddyb> we just need Task parametrized by a structure created by rustc from task-local statics
[17:45:25] <strcat> eddyb: you dlopen a new library, it needs to load the new statics into every task
[17:45:33] <eddyb> dammit
[17:45:42] <eddyb> strcat: how does that even work with TLS?
[17:45:54] <strcat> eddyb: thread-local storage is part of ELF and the linker
[17:45:59] <eddyb> does it expand like the stack?
[17:46:04] <strcat> eddyb: it's magic
[17:46:14] <mitsuhiko> glaebhoerl: yeah, i had an implementation of that a while ago
[17:46:17] <eddyb> I'm talking about the "segment" now
[17:46:21] <strcat> eddyb: http://www.akkadia.org/drepper/tls.pdf
[17:46:48] *** Joins: derek_c (derek@CD53E126.E9B0596F.C34016C.IP)
[17:46:55] <strcat> anyway I highly doubt rust is going to get an M:N version of that addressing all of the caveats you need to address
[17:47:08] <derek_c> rusti: static bytes: &'static mut [u8] = &mut [0u8];
[17:47:11] -rusti- pastebinned 7 lines of output: http://ix.io/9z1
[17:47:24] <strcat> sure, it could get it
[17:47:27] <strcat> but you have to be realistic
[17:47:29] *** Joins: canhtak (canhtak@moz-59105D0.wl.t.ulaval.ca)
[17:47:41] <derek_c> can someone tell me what's wrong with this?
[17:47:53] <whitequark> anshin: yes, from what I understand, this is a long-term goal
[17:48:00] <derek_c> rusti: static bytes: &'static mut [u8] = &mut [0u8];
[17:48:02] -rusti- pastebinned 7 lines of output: http://ix.io/9z1
[17:48:04] <anshin> whitequark: thanks
[17:48:18] *** Joins: gwty (gwtypc@90BFEAA9.8A45D967.F44414AF.IP)
[17:48:36] <strcat> mitsuhiko: anyway overall I've just become a lot less interested in rust
[17:48:42] <mitsuhiko> strcat: do you have to consider that for task local data though?
[17:48:45] <strcat> I find the safety model doesn't actually work well
[17:48:48] <strcat> mitsuhiko: yes
[17:48:58] <strcat> mitsuhiko: if you support declaring it as a global
[17:49:12] <strcat> if you just support it dynamically where access can fail to find a key, then no
[17:49:26] <mitsuhiko> just make the task fail if not initialized
[17:49:48] <strcat> mitsuhiko: but now it's quite a lot slower than actual thread-local storage
[17:49:50] <strcat> which is a ptr offset
[17:49:55] *** Joins: enix (enix@moz-A50569DD.c3-0.slvr-ubr1.lnh-slvr.md.cable.rcn.com)
[17:50:15] <strcat> anyway, you don't have unwinding in a kernel
[17:50:17] <strcat> failure == abort
[17:50:20] <eddyb> strcat: that PDF is too big, couldn't find how TLS blocks are added to the "segment"
[17:50:37] <eddyb> strcat: hah, so you think
[17:50:37] <strcat> eddyb: in a statically linked executable it's a ptr offset
[17:50:49] <strcat> in a dynamically linked one there's a __tls_get_addr call
[17:51:18] <eddyb> though I'm not sure if pedigree had unwinding
[17:51:22] <mitsuhiko> strcat: there are no alternatives to rust at the moment
[17:51:27] <strcat> mitsuhiko: how so?
[17:51:30] <strcat> C++ and D work fine
[17:51:41] <mitsuhiko> D is not an alternative to rust
[17:51:42] <mitsuhiko> at all
[17:51:50] <strcat> why?
[17:52:05] <mitsuhiko> all the complaints you brought about rust are ones you can bring to D too
[17:52:19] <strcat> I haven't actually brought up much about rust yet ;p
[17:52:21] <mitsuhiko> well, except for the static init
[17:52:35] <mitsuhiko> your main argument against rust right now seems to be: not system language enough
[17:53:04] <samx> is there a doc somewhere describing the current rust closures / procs / whatevers?
[17:53:06] <tsvia> what are the advantages of tls over context-passing?
[17:53:12] *** Joins: tulloch (tulloch@moz-F362C074.lnse2.pie.bigpond.net.au)
[17:53:26] <mitsuhiko> tsvia: with __thread it's faster i think
[17:53:35] <strcat> mitsuhiko: s/__thread/thread_local/
[17:53:36] <mitsuhiko> at least it should make calls cheaper
[17:53:45] <strcat> it's not really about speed
[17:53:51] <tsvia> if the argument is always the first the optimizer should leave it there
[17:54:21] <strcat> C++ has generic container literals, compile-time function execution, user-defined literals, and a more powerful type system allowing you to encode stuff like units with dimensions
[17:54:43] <eddyb> context passing is bad if you are sharing the context across threads
[17:54:51] <eddyb> s/threads/tasks/
[17:54:54] <strcat> C++ also has better closures than rust
[17:55:00] *** Quits: tulloch (tulloch@moz-F362C074.lnse2.pie.bigpond.net.au) (Ping timeout)
[17:55:01] <strcat> a typeof operator (decltype) and return type inference
[17:55:12] <tsvia> strcat: [closures] why?
[17:55:14] <pyon> Are (immutable) iterators not cloneable, in general? :-O
[17:55:30] <Edwards> strcat: "Better" is pretty subjective.
[17:55:35] *** Parts: anshin (anshin@CD85F10D.F21429E2.354459FA.IP) (WeeChat 0.4.2)
[17:55:43] <eddyb> but if you want task-local storage - there's no point in sharing that context
[17:55:44] <strcat> Edwards: no, when it comes to closures it's really not very subjective that C++ does it better.
[17:55:55] <strcat> a C++ closure can be returned from a scope
[17:55:57] <strcat> you can move them around
[17:56:02] <eddyb> C++11/14 has finer grained controlled over captures
[17:56:08] <eddyb> *control
[17:56:09] <strcat> the captures part isn't very important
[17:56:17] <cmr> pyon: immutable iterators? if you can't mutate an iterator you can't do anything with it
[17:56:24] <Edwards> strcat: And there's no static guarantee that doing so is safe at all.
[17:56:32] <Edwards> It's a tradeoff.
[17:56:36] <pyon> cmr: I mean, the iterator is itself mutable, but it is not a move iterator.
[17:56:36] <strcat> Edwards: and? there's no static guarantee that your rust program is bug-free either
[17:56:45] *** Joins: AvianFlu (AvianFlu@moz-C85C7DB7.dyn.optonline.net)
[17:56:46] <pyon> cmr: So the underlying collection is immutable.
[17:57:05] <cmr> pyon: ok. many are, but not all. more could probably use a clone.
[17:57:16] <strcat> rust's closures aren't currently memory safe fyi anyway, they'll end up more restricted to get them there
[17:57:27] *** Quits: FrozenCow (FrozenCow@moz-B2DF4929.chello.nl) (Client exited)
[17:57:29] <pyon> cmr: Ah, okay, makes sense!
[17:57:32] <pyon> ty
[17:57:51] <tsvia> strcat: they are changing them ~weekly. what's the latest bug?
[17:58:05] <strcat> there are dozens of closure bugs ;p
[17:58:06] *** Quits: DasIch (dasich@moz-5EDA591.de) (Ping timeout)
[17:58:10] <strcat> they aren't really changing weekly
[17:58:18] <tsvia> it just seems so
[17:58:19] <strcat> they haven't changed much for a while
[17:58:22] <cmr> closures haven't changed beyond syntax really
[17:58:22] <strcat> they were renamed
[17:58:26] <cmr> once fn were already a thing
[17:58:34] <strcat> proc was ~once fn
[17:58:42] <strcat> |a| -> b was &fn(a) -> b
[17:58:44] *** Quits: _Vi (vi@D7277DB6.6FF508C1.10C239DF.IP) (Ping timeout)
[17:58:56] *** Quits: MrFahrenheit (RageOfThou@3FEF494C.29C984D5.783DEDCA.IP) (Ping timeout)
[17:58:58] <strcat> so there are less features than before, but it's the same thing
[17:59:12] <jaen> Quick question - a friend sent me tetris game written in 0.8 so I'm trying to make it compile on the HEAD I have on my and I noticed that he transmutes a random int to an Enum variant, which blows up in HEAD as Enums now choose the smallest possible underlying size and not uint.
[17:59:22] <jaen> The funny thing is the error is not on the line the transmute is
[17:59:22] *** Quits: msch (msch@moz-DA0E34D4.clients.your-server.de) (Ping timeout)
[17:59:22] *** Joins: FrozenCow (FrozenCow@moz-B2DF4929.chello.nl)
[17:59:25] <strcat> Edwards: unboxed closures could exist in rust... they just don't
[17:59:26] <jaen> But on the feature gate
[17:59:29] <strcat> the tradeoff isn't safety.
[17:59:30] <jaen> Is this a known bug?
[17:59:54] *** Joins: msch (msch@moz-DA0E34D4.clients.your-server.de)
[17:59:55] <eddyb> jaen: "feature gate"? for what?
[17:59:58] <achin> jaen: you probably want your enum to derive FromPrimative in order to convert an int to an Enum
[17:59:59] <glaebhoerl> the tradeoff is implementation effort, I think
[18:00:02] *** Quits: toshok (toshok@moz-43741342.cat) (Ping timeout)
[18:00:07] <glaebhoerl> can't do everything all at the same time
[18:00:32] <strcat> it doesn't fit well into rust's type system
[18:00:37] *** Joins: toshok (toshok@moz-43741342.cat)
[18:00:39] *** Joins: MrFahrenheit (RageOfThou@3FEF494C.29C984D5.783DEDCA.IP)
[18:00:45] <eddyb> strcat: unboxed closures?
[18:00:55] <eddyb> hmm, do we have anonymous types at all?
[18:00:56] <strcat> no variadic functions/generics and so on
[18:00:59] <strcat> eddyb: nope
[18:01:08] <cmr> jaen: transmute errors are always spanned to the first lline of the crate root.
[18:01:08] <tsvia> the problem is that you can't have multiple &mut fns on the same context
[18:01:15] <cmr> jaen: known bug, not easy to fix.
[18:01:17] <jaen> eddyb: The code he wrote uses Enum variants which are now behind a feature gate, am I right? That is, you need to have a module-level attribute #[feature(struct_variant)];
[18:01:22] *** Joins: _Vi (vi@D7277DB6.6FF508C1.10C239DF.IP)
[18:01:25] <jaen> cmr: ok, gotcha
[18:01:36] <eddyb> jaen: ah, those are *struct*-like variants
[18:01:44] <jaen> So not gonna litter the github with this then
[18:01:45] <cmr> jaen: there's ToPrimitive and FromPrimitive now though, soyoudon't needtransmute.
[18:01:48] <cmr> eddyb: no, it'sunrelated.
[18:02:31] <eddyb> cmr: I just wanted to point out that enum variants aren't behind a feature gate
[18:02:49] <cmr> ok
[18:03:09] <apoelstra> can you do bitwise operations with enums? is there a idiomatic way to do c-like bitmask enums in rust?
[18:03:09] *** Joins: DasIch (dasich@moz-5EDA591.de)
[18:03:15] *** Quits: samx (sami@moz-D9DA5773.dyn.optonline.net) (Quit: This computer has gone to sleep)
[18:03:29] <eddyb> strcat: ah, variadics. I wanted to fix that. need to get back to my first PR and handle nmatsakis' points :/
[18:03:46] <mitsuhiko> strcat: i much rather see a stable version of rust with fewer features first and then go from there
[18:03:58] <strcat> apoelstra: no, enums can't be used that way - storing a value that's not listed as a variant would be memory unsafe
[18:04:02] <jaen> cmr: sure there are, I just wanted to get his code running with least modifications on my machine and ran into the bug; just wanted to make sure I don't report a duplicate
[18:04:10] <mitsuhiko> i definitely don't need static initializers at all in c++ and i don't miss them in rust either as a result of that
[18:04:15] <apoelstra> oh, ofc strcat, thanks
[18:04:24] <strcat> mitsuhiko: that's one minor issue among many
[18:04:36] <Edwards> apoelstra: http://static.rust-lang.org/doc/0.8/extra/bitv/struct.Bitv.html might help
[18:04:41] <mitsuhiko> to be honest, i don't think i share any of the problems you mentioned so far
[18:04:50] <eddyb> Edwards: outdated docs
[18:04:55] *** Quits: FrozenCow (FrozenCow@moz-B2DF4929.chello.nl) (Client exited)
[18:05:00] <Edwards> Sorry. apoelstra: http://static.rust-lang.org/doc/master/extra/bitv/struct.Bitv.html
[18:05:00] *** Quits: DasIch (dasich@moz-5EDA591.de) (Ping timeout)
[18:05:06] <strcat> mitsuhiko: you've never wanted to return an iterator doing map?
[18:05:09] <mitsuhiko> my only problem with rust is that the type system comes in the way of the error handling
[18:05:09] <eddyb> (we need a bot to do that. and a few other things :)))
[18:05:11] <strcat> works in C++, not in rust
[18:05:17] *** Joins: FrozenCow (FrozenCow@moz-B2DF4929.chello.nl)
[18:05:23] <mitsuhiko> strcat: well, i wish there was decltype
[18:05:30] <mitsuhiko> if that's what you mean
[18:05:31] <strcat> mitsuhiko: well, the issue there isn't decltype
[18:05:33] <eddyb> typeof is reserved
[18:05:37] <strcat> mitsuhiko: rust closures are always boxed
[18:05:42] <apoelstra> Edwards: thanks much
[18:05:43] <strcat> so you can't return them because they're a ptr to a stack frame
[18:05:43] *** Quits: _Vi (vi@D7277DB6.6FF508C1.10C239DF.IP) (Ping timeout)
[18:05:48] *** Joins: ptc (Adium@moz-70022D61.hsd1.ma.comcast.net)
[18:05:53] *** Quits: pcdummy (pcdummy@moz-CF4CA865.page4me.ch) (Ping timeout)
[18:05:55] <mitsuhiko> i thought there are closures you can send?
[18:06:00] <eddyb> procs
[18:06:02] <strcat> mitsuhiko: proc, you can only run them once
[18:06:05] <strcat> and they are heap allocated
[18:06:07] <mitsuhiko> is that new?
[18:06:08] <eddyb> but they just have the captures on the heap
[18:06:13] <strcat> mitsuhiko: before, proc was ~once fn
[18:06:17] *** Joins: yichoi (yichoi@5AB4884B.FCC4549.14D5B978.IP)
[18:06:17] <strcat> mitsuhiko: ~fn/@fn/&fn are gone
[18:06:20] <mitsuhiko> :(
[18:06:35] <mitsuhiko> what's the reason for that?
[18:06:38] <strcat> mitsuhiko: there are borrowed stack closures (boxed, can't return them) and heap-allocated once closures
[18:06:47] <tsvia> why aren't closures lifetimed?
[18:06:48] <strcat> mitsuhiko: well, the closure system we had was awful
[18:06:54] <strcat> tsvia: they are
[18:07:07] <strcat> mitsuhiko: I don't think the new system is good, but at least it's smaller
[18:07:13] <eddyb> strcat: you couldn't return the iterator though. its closure type would be anonymous
[18:07:19] <mitsuhiko> well, i would assume it's a start
[18:07:24] <strcat> eddyb: that's why C++14 has return type inference.
[18:07:34] <strcat> clang fully implements C++14 (based on the drafts) so you can use it today
[18:07:38] <eddyb> yeah, I figured... but isn't that against rust policy?
[18:07:48] *** Quits: msch (msch@moz-DA0E34D4.clients.your-server.de) (Ping timeout)
[18:07:50] <strcat> eddyb: dunno, rust policy is different than it used to be.
[18:07:54] <cmr> "policy"
[18:07:58] *** Quits: yichoi (yichoi@5AB4884B.FCC4549.14D5B978.IP) (Ping timeout)
[18:08:01] <strcat> graydon was against type inference at the API level
[18:08:07] <strcat> the current team isn't necessarily
[18:08:12] <eddyb> cmr: give me a better world :/
[18:08:20] *** Quits: hjr3 (hradtke@moz-E87BDF1F.socal.res.rr.com) (Quit: My MacBook has gone to sleep. ZZZzzz…)
[18:08:25] <eddyb> strcat: it helps a lot with type checking AFAIK
[18:08:40] <mitsuhiko> c++ looks disgusting with decltype anyways
[18:08:44] <strcat> eddyb: C++ return type inference is only from the function body
[18:08:45] <strcat> not elsewhere
[18:08:49] *** Quits: AvianFlu (AvianFlu@moz-C85C7DB7.dyn.optonline.net) (Input/output error)
[18:08:51] <mitsuhiko> especially because you have two ways to annotate return values now
[18:09:00] <mitsuhiko> not sure if rust should copy that
[18:09:07] <strcat> mitsuhiko: more than 2 ways now
[18:09:13] <eddyb> strcat: yes, but you don't know the return type before you typecheck the function
[18:09:13] <glaebhoerl> || is also kinda inappropriate for things like sort_by(). makes no sense to allow mutating things on the stack every time the cmp closure is called. ideally you'd want a pure function... but a closure with an immutable environment would at least be an improvement.
[18:09:14] <Edwards> mitsuhiko: The syntax is funky, but it's so very handy.
[18:09:35] <strcat> mitsuhiko: you can now write
[18:09:38] <tsvia> strcat: if closures are lifetimed - why can't you return them
[18:09:40] <strcat> auto foo() { return 5; }
[18:09:45] *** Joins: msch (msch@moz-DA0E34D4.clients.your-server.de)
[18:09:52] *** Quits: mixi (mixi@moz-DBD8904A.org) (Ping timeout)
[18:09:57] <strcat> in addition to auto foo() -> decltype(expr)
[18:10:01] <eddyb> tsvia: because they're just pointers
[18:10:03] <tsvia> strcat: the docs are pretty silent about this
[18:10:07] <strcat> tsvia: because their lifetime is the stack frame
[18:10:13] <cmr> tsvia: you can returnthem if they're passed in
[18:10:18] <cmr> but not closures you create yourself.
[18:10:18] <strcat> closures are allocated on the stack and are a pointer to it
[18:10:26] <strcat> because closures in rust are *always* boxed
[18:10:35] <mitsuhiko> strcat: i liked decltype initially but it makes for shitty apis
[18:10:52] *** Joins: dredozubov (dredozubov@moz-1E374954.nationalcablenetworks.ru)
[18:11:00] <strcat> mitsuhiko: in some cases
[18:11:10] *** Joins: mixi (mixi@moz-DBD8904A.org)
[18:11:21] <strcat> it's nice to be able to derive the type from the return value of an unboxed closure for example
[18:11:31] <strcat> well, just any function-like thing
[18:11:34] *** Joins: pcdummy (pcdummy@moz-CF4CA865.page4me.ch)
[18:11:42] <tsvia> well from the articles I read they seemed quite similar to traits
[18:11:50] <tsvia> with a single function
[18:12:03] <mitsuhiko> well, i was wishing for decltype before in rust
[18:12:13] <mitsuhiko> even without closures
[18:12:22] <mitsuhiko> returning constructs of iterators from factory functions makes for ugly return types
[18:12:33] <tsvia> strcat: can't you sneak a closure into a passed-in parameter
[18:12:33] *** Quits: dredozubov (dredozubov@moz-1E374954.nationalcablenetworks.ru) (Ping timeout)
[18:12:34] <tsvia> ?
[18:12:41] <tsvia> with it being responsible for deallocation?
[18:12:52] <mitsuhiko> but i wish you could just say -> Iterator<T> there intead of decltype(whatever_expr_created_that_thing)
[18:12:52] <strcat> tsvia: doesn't really make sense
[18:12:54] *** Quits: msch (msch@moz-DA0E34D4.clients.your-server.de) (Ping timeout)
[18:13:15] <tsvia> the classic sneaking-past-final trick 
[18:13:20] *** Joins: klaus (koz@moz-E49E7C4B.hsd1.wa.comcast.net)
[18:13:22] <eddyb> tsvia: closures are &Trait basically. nothing else you can do with them
[18:13:25] <strcat> tsvia: it's not about deallocation
[18:13:26] <tsvia> fn ([Iterator<T>..1])
[18:13:31] <tsvia> fn (&mut [Iterator<T>..1])
[18:13:41] <tsvia> rather then fn() -> Iterator<T>
[18:13:51] *** Joins: DasIch (dasich@moz-5EDA591.de)
[18:13:52] *** Quits: decoder (quassel@moz-D7023D7D.own-hero.net) (Ping timeout)
[18:14:14] *** Quits: dumitru (dgherman@moz-7C253BEB.getcadre.com) (Ping timeout)
[18:14:16] <strcat> tsvia: you can't return a closure/iterator like that either
[18:14:24] *** Joins: dumitru (dgherman@moz-7C253BEB.getcadre.com)
[18:14:41] <strcat> doesn't fit the issue
[18:14:45] <strcat> fix*
[18:14:58] *** Joins: decoder (quassel@moz-D7023D7D.own-hero.net)
[18:14:59] <strcat> tsvia: |A| -> B describes a closure on the stack
[18:15:11] <strcat> it refers to it via a pointer to the captured data and a pointer to the code
[18:15:15] *** Joins: earlzlap (earlz@moz-483E1E31.neo.res.rr.com)
[18:15:19] *** Joins: dwrensha (chatzilla@moz-DE44EA45.hsd1.pa.comcast.net)
[18:15:30] *** Joins: msch (msch@moz-DA0E34D4.clients.your-server.de)
[18:15:36] <strcat> closures have varying amounts of captured data
[18:15:40] <strcat> the necessary space on the stack varies
[18:15:49] *** Joins: _Vi (vi@D7277DB6.6FF508C1.10C239DF.IP)
[18:15:49] <tsvia> can't you put the data inside a ~ref within a struct
[18:15:58] <strcat> no
[18:16:05] <strcat> closures are allocated on the stack
[18:16:14] <strcat> you can't move the data elsewhere
[18:16:16] *** Joins: awidegreen (awidegreen@F5604489.EC0D9A3.7B8A71D0.IP)
[18:16:17] <strcat> they are always boxed
[18:16:23] <strcat> you can never access the unboxed representation
[18:16:32] *** Quits: MrFahrenheit (RageOfThou@3FEF494C.29C984D5.783DEDCA.IP) (Ping timeout)
[18:16:32] <tsvia> I meant fn<'A>([~Iterator<'A,T>..1]) -> () rather then fn<'A>() -> Iterator<'A,T>
[18:16:49] *** Quits: glaebhoerl (glaebhoerl@moz-B5B88D72.catv.broadband.hu) (Quit: )
[18:16:52] <strcat> sure, but only stack closures exist
[18:16:59] <tsvia> what are the soundness problems?
[18:17:05] <strcat> what soundness problems?
[18:17:18] <tsvia> in returning closures - is it simply an implementation issue?
[18:17:26] <strcat> tsvia: no, it's not an implementation issue
[18:17:30] <strcat> closures are allocated on the stack
[18:17:38] <strcat> the variable you have is only a reference to it
[18:17:40] <strcat> it is boxed
[18:17:47] <strcat> there is no such thing as ~fn anymore
[18:17:56] <strcat> they are *always* bound to a stack frame
[18:18:02] *** Quits: ptc (Adium@moz-70022D61.hsd1.ma.comcast.net) (Quit: Leaving.)
[18:18:04] *** Joins: MrFahrenheit (RageOfThou@3FEF494C.29C984D5.783DEDCA.IP)
[18:18:14] <mitsuhiko> strcat: is ~fn coming back?
[18:18:19] <strcat> mitsuhiko: doubt it
[18:18:20] <eddyb> tsvia: unboxed closures are a missing feature
[18:18:32] <eddyb> with a Fn trait, you could implement it on a structure and return that
[18:18:34] <mitsuhiko> strcat: why?
[18:18:38] <diverse> strcat: what about proc()?
[18:18:42] <strcat> mitsuhiko: ideally we'd have unboxed closures by default and they could coerce to a Fn trait
[18:18:47] <strcat> diverse: it's a once closure, not the same
[18:18:51] <strcat> can only call it once
[18:18:52] <diverse> aj
[18:18:54] <diverse> *ah
[18:18:56] <eddyb> with return type inferrence, you could return the unboxed closure
[18:19:06] <strcat> the start of this conversation was pointing out that rust is unable to return a Map/Filter iterator
[18:19:10] <strcat> but C++ can
[18:19:20] <mitsuhiko> the comparison with c++ is not particularly fair thogh
[18:19:30] <strcat> it is fair. rust could have unboxed closures in the same way as C++
[18:19:32] <mitsuhiko> because a) that's a very recent thing and b) it comes with it's own share set of problems
[18:19:41] <mitsuhiko> strcat: was that discussed?
[18:19:43] <strcat> mitsuhiko: C++14 is more stable/supported than rust ;p
[18:19:49] <strcat> mitsuhiko: yes, I opened an issue
[18:19:52] <mitsuhiko> strcat: link?
[18:20:44] <strcat> mitsuhiko: https://github.com/mozilla/rust/issues/8622 although that was a while ago and the idea is fleshed out more now
[18:20:56] *** Quits: Ferreus (ferreus@E7BEF92C.A4B602B4.7B8A71D0.IP) (Ping timeout)
[18:20:59] *** Quits: valenting (Thunderbir@9A1975C1.39CE2EE.E400A05F.IP) (Ping timeout)
[18:21:20] <strcat> mitsuhiko: so... basically traits already implement this concept
[18:21:32] <strcat> you can have various types implementing a trait, they're unboxed, you can return them
[18:21:44] <strcat> trait objects box them, to make them all have the same size
[18:22:01] <strcat> problem with rust's closures is that we *only* had the boxed form, and not the unique type per closure by default like C++
[18:22:03] <tsvia> I missed the bound-lifetimes issue
[18:22:22] <strcat> and now we only have stack closures and heap once closures... which is just a smaller set of features
[18:22:45] <tsvia> for some reason I thought that rust had bound-lifetimes in structs
[18:22:51] <strcat> it's no better than it was before, and not having non-once ~fn is a bit of a step back (you have to use trait objects now)
[18:22:56] *** Quits: derek_c (derek@CD53E126.E9B0596F.C34016C.IP) (Ping timeout)
[18:23:06] <strcat> tsvia: structs/enums can have named lifetimes
[18:23:16] <adridu59> how do I run tests since rust tool is gone?
[18:23:19] <strcat> trait objects can't
[18:23:32] <strcat> adridu59: rustc --test to build the test harness
[18:23:56] <mitsuhiko> strcat: c++ survived 20 years without closures, so i would not say that rust becomes unusable with limited closures *at the moment*
[18:24:07] <mitsuhiko> i doubt that rust will stop there
[18:24:07] <strcat> mitsuhiko: C++ lambdas are just sugar
[18:24:09] <adridu59> thanks! sorry for the silly question, it ain't easy to find that in the doc
[18:24:16] *** Joins: alan_andrade (alan_andra@9267EE86.1B9BB716.7B097AAD.IP)
[18:24:17] <strcat> mitsuhiko: C++ always had operator() overloading
[18:24:18] <mitsuhiko> sugar is all that's needed
[18:24:25] <strcat> mitsuhiko: rust doesn't have the unsugared form
[18:24:45] <mitsuhiko> what do you mean?
[18:24:49] <strcat> mitsuhiko: unsugared form is a Fn trait, which you can't implement for rust
[18:25:02] <mitsuhiko> not sure i follow
[18:25:10] <mitsuhiko> in c++ you could only do that with templates too
[18:25:15] <strcat> in rust you can't
[18:25:30] <strcat> mitsuhiko: C++ had closures before it had lambda sugar for them, you'd specify a function-like parameter and call it
[18:25:33] <strcat> rust can't do that
[18:25:52] <strcat> there's no trait that functions and closures implement that another type can implement too
[18:25:56] *** Quits: alan_andrade (alan_andra@9267EE86.1B9BB716.7B097AAD.IP) (Ping timeout)
[18:26:04] <strcat> we don't have variadic generics so you can't specify one.
[18:26:11] <strcat> you could do all of the special cases
[18:26:25] <strcat> Fn, Fn1, Fn2, Fn3, Fn4, Fn5, Fn6, Fn7, Fn8, Fn9, Fn10 probably covers most cases
[18:26:36] <strcat> and you'll need to do .call()
[18:26:49] <adridu59> what is `unwrap_or()` called these days?
[18:26:51] <Edwards> That's what Scala does, actually: http://www.scala-lang.org/api/current/index.html#scala.Function1
[18:26:58] <tsvia> there's still the bound-lifetime issue
[18:27:02] <mitsuhiko> adridu59: unwrap_or?
[18:27:03] <strcat> and now the real problem occurs
[18:27:10] <mitsuhiko> i still use that name
[18:27:15] <strcat> you need to rewrite nearly every function/method taking a closure to use this trait
[18:27:26] <strcat> map, filter, fold, etc.
[18:27:36] <Edwards> Not necessarily
[18:27:48] <strcat> once you do that, you can pass a bare function, closure, or unboxed function-like object
[18:27:52] <eddyb> strcat: ew. so C++03
[18:28:02] *** Joins: pao (pao@moz-AF905E87.fbx.proxad.net)
[18:28:02] <adridu59> my bad, I thought it was part of the great renaming from a few weeks ago
[18:28:04] <Edwards> |T1| -> T2 could just be an alias for Fn1<T2, T1> or whatever
[18:28:15] <mitsuhiko> strcat: fair enough
[18:28:17] <strcat> Edwards: it's too late for that, |A| -> B is a boxed stack closure
[18:28:18] <eddyb> or we could just have variadics
[18:28:26] <eddyb> blame my leg, really. it could already be here
[18:28:30] <strcat> Edwards: it's highly unlikely to change now
[18:28:34] *** Joins: samx (sami@moz-D9DA5773.dyn.optonline.net)
[18:28:36] <Edwards> Ah
[18:28:42] <tsvia> what's the ABI of (|A| -> B) that makes it a boxed stack closure
[18:28:47] <strcat> tsvia: a pair of pointers
[18:28:50] <tsvia> as distinct from a reference-to-closure
[18:28:59] <tsvia> allocated somewhere
[18:29:13] <strcat> tsvia: because closures with different sizes have the same type
[18:29:17] <strcat> they are type-erased
[18:29:20] <mitsuhiko> strcat: the frustrating thing about this situation is that there seems to be already thick air in the room
[18:29:27] <mitsuhiko> which is a bad situation to be hin
[18:29:28] <adridu59> cmr: is there a way I can get a link to a search page from the doc?
[18:29:41] <mitsuhiko> c++ might work for you, but it definitely does not work for me :P
[18:29:47] <cmr> adridu59: pretty sureit justuses the query strong
[18:29:47] *** Quits: jaen (jaen@moz-E7986949.play-internet.pl) (Ping timeout)
[18:30:06] <cmr> *string
[18:30:10] <strcat> mitsuhiko: I'm not talking about C++ being a better language than rust though, just that it does some things better
[18:30:19] <adridu59> cmr: can I make an URL out of this?
[18:30:24] <strcat> I don't like C++ as a language, I like some of the language features more than rust's
[18:30:25] <mitsuhiko> strcat: well, that is obvious from using rust for 5 minutes
[18:30:29] <mitsuhiko> rust is not very composable yet
[18:30:32] *** Joins: jaen (jaen@moz-E0979827.copit.pl)
[18:30:33] <mitsuhiko> but it's a hell of a lot better than it was before
[18:30:39] *** Quits: tsvia (tsvia@moz-B0C164A1.bb.netvision.net.il) (Ping timeout)
[18:30:45] <tautologico> rust is very new also
[18:30:46] <strcat> mitsuhiko: yeah, but there's more and more resistance to any change
[18:30:50] <pyon> Does Rust support implicitly concatenating string literals in the source?
[18:30:50] <mitsuhiko> before iterators rust was a very different langauge
[18:30:53] *** Quits: summerlight (summerligh@327FC32B.2C956A45.501EFF44.IP) (Ping timeout)
[18:31:06] <strcat> mitsuhiko: I remember trying to convince people that external iterators were better
[18:31:11] <cmr> adridu59: hm, no, not afaik
[18:31:15] <strcat> if I had waited until now, we wouldn't be getting them
[18:31:16] <tautologico> C++ has had decades to evolve... the new standards added nifty stuff
[18:31:19] <strcat> there is extreme resistance to any change now
[18:31:29] <mitsuhiko> strcat: where is that coming from?
[18:31:40] <strcat> I'm scared to work on any implementation of features for rust now because the PR probably won't be accepted
[18:31:44] <strcat> and they all sit there for 30 days
[18:32:37] <strcat> mitsuhiko: dunno. I just feel it has changed drastically in that regard
[18:32:44] <eddyb> strcat: can I restrict massif to a single rustc pass?
[18:32:54] <strcat> mitsuhiko: the core team wants to release 1.0 soon
[18:32:56] <eddyb> though it finished already
[18:33:05] <mitsuhiko> bbl, lunch
[18:33:12] <diverse> strcat: I sense that rush too
[18:34:01] <strcat> rust switched from the mindset of taking the time to get things right to sticking to what is pragmatically possible to implement for a 1.0 this year
[18:34:10] *** Quits: awidegreen (awidegreen@F5604489.EC0D9A3.7B8A71D0.IP) (Ping timeout)
[18:34:15] <strcat> that's why closures are now the way they are
[18:34:36] <cmr> They're also the way they are because they can be desugared post 1.0
[18:34:47] <strcat> I don't really expect that to be true
[18:34:56] <strcat> |A| -> B has to be a borrowed closure forever
[18:35:05] <strcat> it can even have a lifetime attached
[18:35:21] <cmr> sure, but it can be &'a Fn<A, B> if that were callable, no?
[18:35:24] <eddyb> strcat: I have a massif report. can I slice it?
[18:35:45] <strcat> eddyb: dunno.
[18:35:53] *** Quits: hacker_sam (hacker_sam@moz-6547E589.dsl.bngr.epix.net) (Client exited)
[18:35:55] <eddyb> ms_print doesn't have such options
[18:36:04] <strcat> cmr: no
[18:36:14] *** Joins: hacker_sam (hacker_sam@moz-6547E589.dsl.bngr.epix.net)
[18:36:26] <strcat> cmr: |A| -> B is more like &mut
[18:36:33] <cmr> ah, &'a mut, yeah.
[18:36:44] <strcat> cmr: not exactly
[18:36:47] <strcat> the environment has a lifetime
[18:36:56] <strcat> &'a Fn<'b, A, B> maybe
[18:37:03] <strcat> but trait objects can't have lifetimes like that atm
[18:37:38] <cmr> well the point isn't what's possible now, the point is that it's possible to decompose later.
[18:37:59] *** Joins: derek_c (derek@451CF15E.74FA9A9F.EB673A25.IP)
[18:38:05] <Earnestly> cmr: That works out well for other languages, right
[18:38:17] <strcat> cmr: and what about all of the APIs?
[18:39:03] <cmr> strcat: that use ||? Either it'd be a backwards compatible change, or if any changes are necessary it'd be 2.0
[18:39:35] *** Quits: rca_ (rcatolino@moz-5C646728.adsl.proxad.net) (Quit: leaving)
[18:40:00] <strcat> cmr: can't be backwards compatible because it adds type parameters to iterators
[18:40:08] *** Joins: elux (peter@moz-6B45ADE5.dsl.bell.ca)
[18:41:49] <adridu59> is there immutable vec types in Rust besides tuples?
[18:42:03] <strcat> tuples aren't sequence types
[18:42:10] <strcat> and they're not immutable
[18:42:13] <cmr> adridu59: slices?
[18:42:18] <cmr> strcat: that's true.
[18:42:28] <cmr> strcat: needs to be more thought out, then.
[18:42:30] <strcat> adridu59: tuples are anonymous structs
[18:42:44] <strcat> cmr: too late imo, rust went down this strange path ;\
[18:42:50] <adridu59> so what's the difference between tuples, slices and arrays?
[18:43:01] <strcat> not going to convince anyone that it's not acceptable for 1.0
[18:43:16] <cmr> adridu59: rust doesn't have arrays, tuples aren't sequences, and slices are views of memory.
[18:43:26] <strcat> adridu59: tuples are like structs, you can have any types in them and there's no sequence semantics
[18:43:32] <strcat> (int, char, &'static str)
[18:43:46] <adridu59> right
[18:43:46] <strcat> it's like 'struct Foo(int, char, &'static str)' without a specific type name
[18:43:55] <adridu59> you just say a vec instead of array
[18:44:02] <adridu59> I see
[18:44:24] <strcat> slices are a view of memory, fixed-size arrays are a block of memory, vectors are a dynamic array
[18:45:02] <eddyb> strcat, cmr: this is madness :D http://i.imgur.com/DTNmoT5.png
[18:45:07] <adridu59> are slices like some sort of pointers (well, an array/vec is made of pointers already)
[18:45:19] <eddyb> adridu59: pointer to first element and length
[18:45:30] <strcat> fixed-size arrays are an unboxed block of memory
[18:45:35] <strcat> slices are ptr and length
[18:45:35] <cmr> eddyb: why don't you use kcachegrind?
[18:45:37] *** Quits: hoverbear (hoverbear@moz-86FCBF4B.gv.shawcable.net) (Quit: This bear's gotta fly.)
[18:45:47] <eddyb> cmr: can it read massif files?
[18:45:52] <cmr> eddyb: yes
[18:45:57] <strcat> vectors are an implementation-defined dynamic array implementation (length, capacity, block of memory in some representation)
[18:46:10] <eddyb> cmr: worst name ever then :/
[18:46:12] <adridu59> so slices are called so because they don't list/enumerate their innards?
[18:46:22] <eddyb> cmr: it should be "kalgrind"
[18:46:22] <strcat> adridu59: hm?
[18:46:26] *** Joins: hoverbear (hoverbear@moz-86FCBF4B.gv.shawcable.net)
[18:46:30] *** Quits: twi (Adium@moz-24C5D6D4.cust.dsl.vodafone.it) (Ping timeout)
[18:46:33] <strcat> adridu59: slices don't own their contents, they certainly have sequence semantics
[18:46:39] <adridu59> oh
[18:47:08] <adridu59> so the difference between a vec and slice is: slice is not mutable and doesn't own its content?
[18:47:11] <strcat> [T, ..n] (fixed-size array), &[T]/&mut [T] are slices (ptr + len, acting as a non-owning view), ~[T] is a dynamic array
[18:47:20] <strcat> adridu59: so... what do you mean vector? do you mean ~[T]?
[18:47:28] <eddyb> cmr: I wish you could provide such detailed memory usage graphs, but it would mean running rustc 5 times slower or something
[18:47:29] <adridu59> yes
[18:47:32] <strcat> adridu59: there are mutable slices (&mut [T])
[18:47:33] <cmr> eddyb: actually it might not, but I remember it doing so: there's http://gitorious.org/massif-visualizer though
[18:47:42] <strcat> adridu59: they are a view of elements, they don't own them
[18:47:44] *** Quits: hoverbear (hoverbear@moz-86FCBF4B.gv.shawcable.net) (Quit: Taking a nap.)
[18:47:50] <cmr> eddyb: I can provide detalied memory graphs, it samples as fast as it can.
[18:47:54] <strcat> adridu59: fixed-size arrays own the elements, and are an unboxed block of memory
[18:48:00] <cmr> eddyb: cgroups don't impose much of a perf hit
[18:48:06] <adridu59> I don't get the concept, since you say you can mutate them
[18:48:10] <eddyb> cmr: it looks like the parser is wasting memory
[18:48:11] *** Joins: valenting (Thunderbir@9A1975C1.39CE2EE.E400A05F.IP)
[18:48:33] <strcat> adridu59: they don't own the elements. therefore they have a lifetime and can't outlive what they were borrowed from
[18:48:34] <cmr> adridu59: you  can mutate the contents, but you can't make the slice larger, only smaller.
[18:48:41] <strcat> and they don't destroy the elements when they go out of scope
[18:48:45] <strcat> since they don't own them
[18:48:51] <eddyb> cmr: unless those are files that it parses and then the ~str is discarded
[18:48:52] <adridu59> what's the use case of a slice then?
[18:48:54] <cmr> (for &mut[T])
[18:49:16] <strcat> adridu59: anything that doesn't involve changing the length/capacity of a dynamic array
[18:49:24] *** Joins: twi (Adium@moz-DFF60452.cust.dsl.vodafone.it)
[18:49:28] *** Quits: derek_c (derek@451CF15E.74FA9A9F.EB673A25.IP) (Quit: Leaving)
[18:49:31] <strcat> iteration, indexing, all of that stuff is implemented on slices
[18:49:36] <adridu59> do they exist because of performance?
[18:49:41] <strcat> adridu59: no
[18:49:54] <strcat> adridu59: they are the analogy to a borrowed pointer for sequences of elements
[18:50:09] <strcat> there are performance reasons to use them but they're a fundamental part of rust
[18:50:15] <strcat> they're required to express many concepts
[18:50:18] <strcat> ignoring perf
[18:50:20] <adridu59> so you couldn't do what you do on a slice on a dynamic array?
[18:50:31] <strcat> you can take a slice of a dynamic array
[18:50:41] <benh> I thought we were on track for getting decent closure abstractions, what happened :(
[18:50:44] <strcat> slices are a view, they don't care if they're pointing at a fixed-size array or a dynamic array
[18:50:54] <strcat> benh: I don't think we've ever been on track for that.
[18:51:00] *** Quits: maikklein (maik@moz-2F166E55.dip0.t-ipconnect.de) (Ping timeout)
[18:51:06] <benh> have you ever thought we were tho?
[18:51:12] <strcat> benh: pcwalton just vastly simplified it by dropping everything but &fn()/~once fn
[18:51:24] <strcat> I've never thought we had good closures or were going to have them
[18:51:38] <strcat> I had to be convinced to open that bug because I didn't expect it to be implemented
[18:51:48] <adridu59> strcat: I don't get why we need slices on top of dyn arrays tbh
[18:52:00] *** Joins: ercxx (ercan@moz-5B55241D.dyn.optonline.net)
[18:52:03] <strcat> adridu59: pass a dynamic array by-value somewhere, you can no longer access it from the source
[18:52:06] <eddyb> cmr: hah, thanks http://software.opensuse.org/package/massif-visualizer?search_term=massif
[18:52:09] <whitequark> strcat: what was the reason for dropping ~fn?
[18:52:25] <adridu59> strcat: I see. Is that the sole reason why they exist?
[18:52:27] <strcat> whitequark: simplifying the language by scaling back parts that are viewed as poorly done
[18:53:03] <strcat> whitequark: the proper way to do closures is accepted as making them more trait-like, as in having unboxed ones and being able to put them behind any ptr type
[18:53:11] *** Joins: tulloch (tulloch@moz-F362C074.lnse2.pie.bigpond.net.au)
[18:53:17] <strcat> &fn/~fn/@fn was really, really weird
[18:53:28] <whitequark> I think I understand
[18:53:37] <ercxx> Is there a way of reading from a network stream without blocking? like std::comm::Port::try_recv() does
[18:54:52] <strcat> whitequark: so... it's not better after those changes, but at least there will be fewer legacy things to deal with
[18:55:03] *** Quits: tulloch (tulloch@moz-F362C074.lnse2.pie.bigpond.net.au) (Ping timeout)
[18:55:10] *** Joins: johnrkd (johnrkd@3A09C2F6.815752B7.B05A4819.IP)
[18:55:21] <eddyb> ercxx: put the stream in a task, communicate with it via a channel and use try_recv then :P
[18:55:28] <strcat> but imo reserving the nice syntax for what might become a legacy feature isn't great (|A| -> B)
[18:55:45] <ercxx> eddyb: :)
[18:56:03] <eddyb> strcat: I was thinking of shadow generics in arguments at one point
[18:56:26] *** Quits: elux (peter@moz-6B45ADE5.dsl.bell.ca) (Quit: Bye!)
[18:56:37] <eddyb> fn stringify(x: ToStr) -> ~str {x.to_str()}
[18:56:53] *** Quits: nathan7 (nathan@moz-60FC7746.nathan7.eu) (Ping timeout)
[18:56:54] <strcat> that'd be nice
[18:57:17] <eddyb> and it doesn't require DST
[18:57:21] <strcat> I don't like how the more rarely used, usually less efficient way often looks better
[18:57:30] <strcat> eddyb: please open an issue asking for that ;p
[18:59:49] *** Quits: twi (Adium@moz-DFF60452.cust.dsl.vodafone.it) (Connection reset by peer)
[18:59:50] *** Joins: twi1 (Adium@moz-DFF60452.cust.dsl.vodafone.it)
[18:59:57] *** Joins: rca (rcatolino@moz-5C646728.adsl.proxad.net)
[19:00:09] <diverse> eddyb: that's very clever
[19:00:12] *** Joins: nathan7 (nathan@moz-60FC7746.nathan7.eu)
[19:01:23] *** Joins: ptc (Adium@moz-70022D61.hsd1.ma.comcast.net)
[19:01:23] *** Quits: twi1 (Adium@moz-DFF60452.cust.dsl.vodafone.it) (Connection reset by peer)
[19:02:03] * strcat is quite happy about being able to use fwrite_unlocked, fread_unlocked, etc. in the default file API
[19:02:19] <strcat> just not for stdout/stdin/stderr
[19:02:27] *** Joins: lenstr (lenstr@CD7D5ABA.83A99F98.85938D85.IP)
[19:02:38] *** Joins: twi (Adium@moz-DFF60452.cust.dsl.vodafone.it)
[19:03:07] <adridu59> does someone know why we don't allow `range(n)`?
[19:03:16] *** Quits: jmgrosen (jmgrosen@moz-AB3ADE2D.sb.sd.cox.net) (Quit: jmgrosen)
[19:03:27] <strcat> adridu59: because rust doesn't have optional/default arguments
[19:03:29] *** Quits: jhasse (jhasse@moz-F3702E2C.ewe-ip-backbone.de) (Client exited)
[19:03:55] <strcat> so there's range(start, stop) and range_step(start, stop, step)
[19:04:15] <strcat> and an _inclusive version of both for including the stop without overflow issues
[19:04:32] <eddyb> I should also add an issue for "a..b" sugar :P
[19:04:47] <eddyb> strcat: link me to libify builtin types. please :)
[19:05:06] <cmr> eddyb: github has a search, and google can search by site.
[19:05:27] <adridu59> strcat: has there been plans already to have optional arguments? an Option type would evaluate at runtime
[19:05:32] *** Joins: jlong (jlong@moz-6DFDE846.socal.res.rr.com)
[19:05:33] <eddyb> cmr: I have no idea how it would be called. I had to sift through pages of github issues before :/
[19:05:39] <strcat> adridu59: no official plans
[19:05:50] <strcat> lots of incomplete proposals for them
[19:06:11] <adridu59> core team thinks this is not required for 1.0?
[19:06:27] <strcat> definitely not going to make it for 1.0
[19:06:34] *** Joins: yichoi (yichoi@5AB4884B.FCC4549.14D5B978.IP)
[19:06:38] <strcat> it's not agreed upon if it's even a good idea
[19:06:40] <adridu59> is it like something big to implement?
[19:06:43] <cmr> eddyb: https://github.com/mozilla/rust/issues/6065
[19:06:50] <strcat> adridu59: there are many ways to do it
[19:06:56] <strcat> and it has drawbacks, it makes code harder to read
[19:07:05] <strcat> and it encourages 'overloading' instead of naming things well
[19:07:31] <adridu59> well `range(n)` didn't sound nasty to me
[19:07:49] <adridu59> what do you mean by naming things?
[19:07:52] <eddyb> 0..n is truly the best solution :)
[19:08:07] <eddyb> 0..n.step(m).inclusive()
[19:08:17] *** Quits: yichoi (yichoi@5AB4884B.FCC4549.14D5B978.IP) (Ping timeout)
[19:08:18] <eddyb> it composes!
[19:08:28] * eddyb ducks and runs
[19:09:20] <dwrensha> hey, linking question: If I need to link against an external C library in /usr/local/lib, should I be able to do "rustc hello.rs -L/usr/local/lib"?
[19:09:27] <dwrensha> currently that gives me this error: 'assertion failed: lib.dylib.is_none()'
[19:09:42] <dwrensha> I guess because all of the rust libraries are also in that directory
[19:10:26] <whitequark> strcat: any proposals for keyword arguments?
[19:10:26] <cmr> dwrensha: if it's in your ld.so.conf you don't need to add the path.
[19:10:44] <strcat> whitequark: hm, maybe, there's an issue open with dozens of proposals about this stuff
[19:10:55] <whitequark> in ocaml, positional ones can't be optional but keyword ones can, with rather clean semantics (once you get past currying)
[19:10:56] <cmr> and an etherpad somewhere
[19:11:03] <strcat> whitequark: it really went nowhere. nothing was fleshed out fully, but iirc there was some serious work on coming up with a full solution in an etherpad
[19:11:28] <whitequark> https://github.com/mozilla/rust/issues/6973 apparently
[19:11:39] <strcat> but I definitely don't think it will make 1.0, and I find it doubtful that a feature changing the idioms of the language would be able to land later
[19:11:56] <eddyb> strcat, cmr: my thoughts on it: https://github.com/mozilla/rust/issues/6065#issuecomment-31322996
[19:12:08] <strcat> I don't miss default/keyword arguments much tbh, although I understand why people want them
[19:12:23] *** Joins: AvianFlu (AvianFlu@moz-51534E77.c3-0.43d-ubr2.qens-43d.ny.cable.rcn.com)
[19:12:30] <eddyb> strcat: oh, oh, I had another idea!
[19:12:50] <strcat> I miss variadic functions (as in passing various different types) but rust doesn't really have the metaprogramming bits to support them atm
[19:13:03] <strcat> and at least we have unsafe C vararg support now ;)
[19:13:08] <eddyb> struct Foo {a: a, ..} should be struct Foo {a: a, ..::__lang_items::Default::default()}
[19:13:46] *** Joins: short (Mibbit@moz-DEF859BF.hsd1.wa.comcast.net)
[19:13:48] <whitequark> I wonder whether 1.0 is too early...
[19:15:02] <strcat> whitequark: at least if it's going to be backwards compatible, yeah
[19:15:12] <pyon> Is there any way to manually set the size of a vector, at least when the element type implements Default?
[19:15:13] <eddyb> cmr, strcat: I want this for "is rust slim yet" :D:D:D http://i.imgur.com/wZdego1.png
[19:15:21] *** Joins: wilmoore (wilmoore@moz-71431C3A.hsd1.co.comcast.net)
[19:15:30] <eddyb> it is truly beautiful
[19:15:41] <adridu59> why doesn't std::num::abs return an uint?
[19:15:44] <cmr> eddyb: https://github.com/huonw/isrustfastyet get cracking
[19:15:46] <adridu59> (on an int)
[19:15:48] <strcat> eddyb: which frontend is that?
[19:15:58] *** Quits: exobit (foo@moz-90D1B547.nycmny.fios.verizon.net) (Quit: My MacBook Pro has gone to sleep. ZZZzzz…)
[19:16:09] <eddyb> strcat: massif-visualizer (for kde4), cmr linked it earlier
[19:16:13] <strcat> ah
[19:16:13] *** Quits: twi (Adium@moz-DFF60452.cust.dsl.vodafone.it) (Connection reset by peer)
[19:16:26] <strcat> kcachegrind is really nice too
[19:16:31] <strcat> <3 kcachegrind.
[19:16:36] <cmr> yup
[19:16:44] <strcat> it doesn't like userspace threads though
[19:16:51] <eddyb> yeah, that's what I use for callgrind output
[19:17:03] *** Joins: hoverbear (hoverbear@moz-86FCBF4B.gv.shawcable.net)
[19:17:39] *** Joins: twi (Adium@moz-DFF60452.cust.dsl.vodafone.it)
[19:18:37] <eddyb> cmr: hmm, it still doesn't allow me to diff. I guess I want to run massif only for a rustc pass and I have no idea how
[19:19:03] <cmr> eddyb: --parse-only ?
[19:19:15] *** Quits: hacker_sam (hacker_sam@moz-6547E589.dsl.bngr.epix.net) (Client exited)
[19:19:16] *** Joins: hacker_sam (hacker_sam@moz-6547E589.dsl.bngr.epix.net)
[19:19:38] <eddyb> cmr: fail! immediately after configure 1. the problem is that I don't want parsing in the massif dump
[19:19:54] <cmr> ah
[19:20:36] *** Joins: azita (Azita@moz-C1FB2A8.hsd1.ca.comcast.net)
[19:20:40] *** Quits: jaen (jaen@moz-E0979827.copit.pl) (Ping timeout)
[19:21:29] *** Joins: jaen (jaen@moz-220744F0.play-internet.pl)
[19:21:30] *** Joins: echristo (echristo@60A74940.D6CCE4AE.77834EAA.IP)
[19:23:19] *** Joins: tsvia (tsvia@moz-DDA0CF97.red.bezeqint.net)
[19:23:56] *** Joins: nrc (ncameron@moz-A76F1825.cable.virginm.net)
[19:24:07] <tsvia>  /whois tsvia
[19:24:37] *** Quits: StarLight (StarLight@moz-EA5BC33E.dynamic.avangarddsl.ru) (Ping timeout)
[19:24:45] *** Joins: alan_andrade (alan_andra@9267EE86.1B9BB716.7B097AAD.IP)
[19:26:29] *** Quits: alan_andrade (alan_andra@9267EE86.1B9BB716.7B097AAD.IP) (Ping timeout)
[19:28:10] <tautologico> deep philosophical questions
[19:28:16] *** Quits: ptc (Adium@moz-70022D61.hsd1.ma.comcast.net) (Connection reset by peer)
[19:28:17] *** Quits: jaen (jaen@moz-220744F0.play-internet.pl) (Ping timeout)
[19:28:23] *** Joins: ptc (Adium@6C906E9F.9ECAA4DB.BCDD830B.IP)
[19:28:49] *** Quits: azita (Azita@moz-C1FB2A8.hsd1.ca.comcast.net) (Quit: azita)
[19:28:50] *** Joins: StarLight (StarLight@moz-B7C96095.dynamic.avangarddsl.ru)
[19:29:44] *** Joins: ptc1 (Adium@moz-70022D61.hsd1.ma.comcast.net)
[19:30:55] *** Quits: ptc (Adium@6C906E9F.9ECAA4DB.BCDD830B.IP) (Ping timeout)
[19:31:25] *** Quits: ptc1 (Adium@moz-70022D61.hsd1.ma.comcast.net) (Ping timeout)
[19:31:44] *** Quits: lenstr (lenstr@CD7D5ABA.83A99F98.85938D85.IP) (Client exited)
[19:32:38] *** Joins: kngl (Adium@E5907D90.770DEA4D.7C797F8E.IP)
[19:33:06] *** Quits: pao (pao@moz-AF905E87.fbx.proxad.net) (Quit: pao)
[19:35:58] *** Quits: twi (Adium@moz-DFF60452.cust.dsl.vodafone.it) (Connection reset by peer)
[19:36:11] <eddyb> strcat, cmr: did I complain about my formal writing skills enough? https://github.com/mozilla/rust/issues/11196
[19:37:25] *** Joins: twi (Adium@moz-DFF60452.cust.dsl.vodafone.it)
[19:38:46] *** Quits: KindOne (KindOne@moz-698007C0.dynamic.ip.windstream.net) (Ping timeout)
[19:39:05] *** Joins: jaen (jaen@moz-D3C934E0.play-internet.pl)
[19:39:24] <ercxx> I have a problem reading from a udpsocket. I split it into two programs. First one just sends an http message over udp to an address. I can't grab anything from the receiver.
[19:39:43] <ercxx> here it is: http://pastebin.com/f6M2BfMc
[19:40:18] <ercxx> I can see the activity from udp_send using wireshark.
[19:40:45] <eddyb> rusti: fn foo<T: ToStr>(x: &T) -> ~str {x.to_str()} foo(&5)
[19:40:46] -rusti- ~"5"
[19:40:51] <eddyb> rusti: fn foo<T: ToStr>(x: &T) -> ~str {x.to_str()} foo(&5 as &ToStr)
[19:40:53] -rusti- pastebinned 9 lines of output: http://ix.io/9z5
[19:40:57] <eddyb> :(
[19:41:04] <ercxx> in udp_recv it blocks at the line with recvfrom().
[19:41:10] <eddyb> rusti: fn foo<T: ToStr>(x: &T) -> ~str {x.to_str()} foo(&5u as &ToStr)
[19:41:12] -rusti- pastebinned 9 lines of output: http://ix.io/9z6
[19:41:21] *** Quits: adridu59 (Mibbit@moz-E1FF077C.rev.numericable.fr) (Quit: http://www.mibbit.com ajax IRC Client)
[19:41:58] <eddyb> rusti: fn foo<T: ToStr>(x: &T) -> ~str {x.to_str()} foo((&5) as &ToStr)
[19:42:00] -rusti- pastebinned 9 lines of output: http://ix.io/9z7
[19:42:17] <eddyb> oh nvm I see what's going on
[19:42:23] *** Joins: awidegreen (awidegreen@F5604489.EC0D9A3.7B8A71D0.IP)
[19:42:26] <eddyb> rusti: fn foo<T: ToStr>(x: &T) -> ~str {x.to_str()} foo(&(&5u as &ToStr))
[19:42:28] -rusti- pastebinned 6 lines of output: http://ix.io/9z8
[19:42:40] *** Joins: KindOne (KindOne@543C9E64.D40F8E6E.EC6A1518.IP)
[19:42:40] *** Quits: mentero (mentero@moz-D61C6F02.proxnet.pl) (Ping timeout)
[19:42:42] *** Quits: diverse (diverse@moz-ED94B8D.oc.oc.cox.net) (Quit: WeeChat 0.4.2)
[19:43:00] <eddyb> strcat: hmpf. for that to work we need DST, don't we?
[19:43:18] <eddyb> rusti: fn foo(x: &ToStr) -> ~str {x.to_str()} foo(&5 as &ToStr)
[19:43:19] -rusti- ~"5"
[19:44:03] <eddyb> strcat: ^^ I basically figured it would make sense to make that a generic. especially with the newly added coercion
[19:44:28] <eddyb> hehe, that would actually make the coercion useless. hah
[19:45:04] *** Joins: maikklein (maik@moz-2F166E55.dip0.t-ipconnect.de)
[19:45:05] <eddyb> (since you'd use "as" to opt-in "slow-mode")
[19:45:21] *** Quits: awidegreen (awidegreen@F5604489.EC0D9A3.7B8A71D0.IP) (Ping timeout)
[19:45:29] *** Quits: twi (Adium@moz-DFF60452.cust.dsl.vodafone.it) (Connection reset by peer)
[19:45:35] *** Joins: twi (Adium@moz-DFF60452.cust.dsl.vodafone.it)
[19:46:18] *** Quits: io2 (io2@moz-34E8FDD4.home.otenet.gr) (Ping timeout)
[19:47:26] *** Joins: Ferreus (ferreus@E7BEF92C.A4B602B4.7B8A71D0.IP)
[19:47:56] *** Quits: hacker_sam (hacker_sam@moz-6547E589.dsl.bngr.epix.net) (Client exited)
[19:48:16] *** Joins: hacker_sam (hacker_sam@moz-6547E589.dsl.bngr.epix.net)
[19:48:17] *** Quits: jaen (jaen@moz-D3C934E0.play-internet.pl) (Quit: WeeChat 0.4.2)
[19:48:53] <eddyb> strcat, cmr: what's the easiest way to "concentrate" on the pass I want to know more about? s/on//. concentrate. run the pass 10 times :)
[19:49:38] *** Joins: awidegreen (awidegreen@moz-3FE0A1F.a357.priv.bahnhof.se)
[19:51:06] *** Quits: jlong (jlong@moz-6DFDE846.socal.res.rr.com) (Quit: My MacBook Pro has gone to sleep. ZZZzzz…)
[19:51:57] *** Joins: jviereck (Adium@moz-A42B7BD5.dip0.t-ipconnect.de)
[19:53:15] *** Joins: tulloch (tulloch@moz-F362C074.lnse2.pie.bigpond.net.au)
[19:53:48] <ercxx> should I use std::rt::rtio::RtioUdpSocket?
[19:54:20] <cmr> ercxx: std::rt is an unstable implementation detail (moreso than the rest of the game)
[19:54:21] <Luqman> ercxx: no
[19:54:30] <cmr> game? stdlib
[19:54:40] *** Joins: killerswan (kevincantu@moz-CC0DC654.hsd1.ca.comcast.net)
[19:54:41] <eddyb> heh
[19:54:55] <ercxx> ok. anybody familiar with what's going on with udp stuff?
[19:54:58] <Luqman> ercxx: std::io::net::udp::UdpSocket
[19:55:00] *** Quits: echristo (echristo@60A74940.D6CCE4AE.77834EAA.IP) (Quit: echristo)
[19:55:03] *** Quits: tulloch (tulloch@moz-F362C074.lnse2.pie.bigpond.net.au) (Ping timeout)
[19:55:35] <ercxx> Luqman: http://pastebin.com/f6M2BfMc I can't read anything from the socket.
[19:55:48] <ercxx> I'm probably doing something wrong but I don't know what it is.
[19:55:57] *** Joins: azita (Azita@moz-C1FB2A8.hsd1.ca.comcast.net)
[19:56:25] *** Joins: erszcz (Mibbit@moz-5D8503E6.dynamic.chello.pl)
[19:56:33] <acrichto> cmr: rust_begin_unwind no longer exists either, the new function to catch on is _Unwind_Raise_Exception
[19:56:48] <cmr> acrichto: yeah, we got there eventuall.
[19:56:51] <cmr> y
[19:56:57] *** Joins: jmgrosen (jmgrosen@moz-848F6087.sb.sd.cox.net)
[19:57:46] <Luqman> ercxx: i think it's because you're telling it to read in 0 bytes (i.e buf.len() == 0)
[19:59:30] *** Quits: maxiepoo (Max@moz-D66F3D4E.atvci.net) (Quit: maxiepoo)
[19:59:36] *** Quits: awidegreen (awidegreen@moz-3FE0A1F.a357.priv.bahnhof.se) (Ping timeout)
[19:59:43] *** Joins: jaen (jaen@moz-63F3CF13.play-internet.pl)
[19:59:43] *** Quits: jaen (jaen@moz-63F3CF13.play-internet.pl) (Quit: jaen)
[20:00:09] *** Quits: wilmoore (wilmoore@moz-71431C3A.hsd1.co.comcast.net) (Ping timeout)
[20:01:15] <eddyb> cmr: since when are llvm passes split into three?
[20:01:32] <eddyb> or... 4
[20:01:44] *** Joins: mentero (mentero@moz-D61C6F02.proxnet.pl)
[20:02:19] <erszcz> hi. how would I approach writing a rust wrapper for posix regcomp/regexec? to be precise, the functions take a regex_t*, with regex_t typedefed in regex.h - how to access that definition from rust or how to get its size from within rust?
[20:03:51] <erszcz> I assume that given just the size I could just allocate a big enough buffer of u8 and pass a pointer to regcomp which would initialize the memory appropriately...
[20:03:55] <ercxx> Luqman: I'll take a look..
[20:04:11] <cmr> ercxx: see rust-bindgen. you need to define the struct in Rust.
[20:04:29] <olsonjeffery> acrichto: ping
[20:04:33] <acrichto> olsonjeffery: pong
[20:04:44] <ercxx> erszcz: see rust-bindgen. you need to define the struct in Rust.
[20:04:53] <olsonjeffery> acrichto: do you have any tickets to divy up native io work? id be interested in pitching in..
[20:05:06] <eddyb> cmr: looks like at the same time as LTO http://huonw.github.io/isrustfastyet/mem/#29ca435,f817ed3
[20:05:20] <acrichto> olsonjeffery: sadly no tickets, I'm just kinda doing things as I go along, but if you want unix pipes or signal handling, those are up for grabs
[20:05:25] <acrichto> I'm working on UDP/timers right now
[20:05:28] * olsonjeffery nods
[20:05:31] *** Joins: io2 (io2@moz-34E8FDD4.home.otenet.gr)
[20:06:19] *** Joins: alisdair (textual@28441AAB.AC6E1995.F0AE27BD.IP)
[20:06:40] <erszcz> cmr, ercxx: thanks, it seems to be just what i've been looking for
[20:07:07] *** Joins: yichoi (yichoi@5AB4884B.FCC4549.14D5B978.IP)
[20:07:23] <acrichto> olsonjeffery: signal handling is tricky because it basically dictates a worker thread, and unix pipes are tricky because they need some different stuff on windows (named pipe stuff I think)
[20:07:38] <acrichto> I took the easy ones already with files/tcp/udp :P
[20:07:57] <ercxx> Luqman: couldn't make it work.
[20:08:02] <acrichto> olsonjeffery: oh DNS as well
[20:08:08] <acrichto> get_host_addresses, that should be easy enogh
[20:08:53] *** Quits: yichoi (yichoi@5AB4884B.FCC4549.14D5B978.IP) (Ping timeout)
[20:08:56] <ercxx> acrichto: I was playing with udp. Is there a problem with UdpSocket::recv_from() ?
[20:09:01] <strcat> acrichto: why not just expose sigwait?
[20:09:19] <olsonjeffery> acrichto: yeah, that was my immediate question.. how far down the win32 rabbithold are you going?
[20:09:25] <acrichto> ercxx: https://github.com/mozilla/rust/pull/11186 is a pull request starting with libuv
[20:09:26] <olsonjeffery> trying to just shunt it to mingw32 where possible?
[20:09:32] <olsonjeffery> all of the IO in mingw32 is horrible
[20:09:32] <acrichto> olsonjeffery: pretty far
[20:09:46] <cmr> olsonjeffery: we don't use mingw32 except for the toolchain
[20:09:50] <cmr> we use win32
[20:09:55] <acrichto> strcat: it needs to have the same interface as M:N signal handling, which is essentially a channel
[20:10:13] <strcat> acrichto: can't it just be a blocking/quasi-blocking call in both cases?
[20:10:15] <acrichto> olsonjeffery: I would like to avoid using any mingw-specific things, but I have no idea where that line is drawn
[20:10:39] <olsonjeffery> well thats not what i meant.. more the use of mingw32 to keep it POSIX'ish as it in on *nix.
[20:10:44] <acrichto> strcat: you need to return immediately from the function call that says "signal this channel with this signal"
[20:10:46] <olsonjeffery> are you using a lot of CF/NS stuff on OSX?
[20:10:50] <olsonjeffery> for native io
[20:10:54] <acrichto> oh lord no
[20:10:55] <eddyb> strcat, cmr: it looks really weird running it 10 times. there appears to be a net gain, but that doesn't show up on is-rust-slim-yet graphs. I guess I should've tried something simpler first
[20:11:02] <strcat> sigwait(SIGTERM | SIGINT)
[20:11:16] <strcat> acrichto: why is the interface a channel though? there's synchronous signal handling
[20:11:16] *** Quits: Mindless` (mindless@moz-9C38D3B4.net) (Ping timeout)
[20:11:23] *** Joins: Mindless` (mindless@moz-9C38D3B4.net)
[20:11:29] <strcat> the M:N version can expose a sync interface based on signalfd
[20:11:49] <acrichto> strcat: there is *one* interface to signal handling, not multiple
[20:11:53] <acrichto> from the rust perspective
[20:12:06] <strcat> so why isn't the interface a synchronous one?
[20:12:13] <strcat> like other I/O
[20:12:18] <olsonjeffery> yeah, id have to agree there.
[20:12:19] <acrichto> olsonjeffery: I'd take a look at tcp/file/udp stuff to see how much I dove down the windows hole, I'm kinda unsure how far I went
[20:12:25] <acrichto> strcat: select() over a signal channel
[20:12:36] <strcat> acrichto: seems unnecessary
[20:12:36] <acrichto> basically selection over blocking events
[20:12:38] *** Quits: jviereck (Adium@moz-A42B7BD5.dip0.t-ipconnect.de) (Quit: Leaving.)
[20:12:47] <acrichto> seems premature to say it's unnecessary
[20:12:49] <strcat> just block a task, handling signals is rare and inherently racy
[20:13:06] <olsonjeffery> acrichto: btw, did you see that your slidedeck from the december rust meetup is on HN?
[20:13:10] <strcat> you don't want to actually write anything depending on it, you might just want to make SIGINT shut down relatively cleanly
[20:13:12] <olsonjeffery> pretty funny because all of those PRs landed..
[20:13:32] <acrichto> olsonjeffery: argh I need to put more thought into these things!
[20:13:45] <strcat> SIGTERM and SIGINT are both things you might want to do a relatively clean exit for
[20:13:56] <strcat> but other than that, what signals are you going to actually handle? ;p
[20:14:08] <acrichto> strcat: SIGUSRX to do things like reconfiguring
[20:14:13] <strcat> acrichto: anti-pattern
[20:14:19] <strcat> that's not how stuff is done anymore
[20:14:22] <acrichto> and all of this fits much more naturally with everything else if you have channels to do the blocking etc
[20:14:22] <strcat> it's racy.
[20:14:30] <strcat> control sockets
[20:14:31] *** Joins: engla (engla@moz-F64E1B0F.cust.bredbandsbolaget.se)
[20:14:39] <o11c> SIGWINCH is absolutely essential
[20:14:53] <strcat> o11c: sure, but we don't expose termios stuff anyway
[20:14:59] <o11c> though it's sole purpose is usually to set a "dirty" flag
[20:15:16] <acrichto> strcat: I recommend opening an issue on changing the API of signal handling
[20:15:29] <acrichto> it would certainly make native I/O easier if we decided to make a synchronous interface
[20:15:33] <acrichto> no need for a worker thread...
[20:15:55] <strcat> well you end up needing a worker task to make the call, and then dealing with it however you want
[20:16:03] <strcat> which could mean sending a message to several tasks to tell them to stop
[20:16:13] <strcat> and then after a synchronous sleep, exit()
[20:16:32] <strcat> imo that's how you'll handle 99% of signals (SIGINT/SIGTERM)
[20:16:54] <strcat> SIGWINCH is a good point, but I think you'd want an async handler + atomic flag
[20:17:15] <strcat> hm
[20:17:25] <strcat> missing a signal is a worrying prospect
[20:17:41] <strcat> if you aren't just going to exit...
[20:17:52] *** Joins: maxiepoo (Max@moz-D66F3D4E.atvci.net)
[20:18:04] <acrichto> you don't "just exit" most of the time though, you may need to shut down things like databases and whatnot
[20:18:21] <strcat> acrichto: you need to exit after a timeout
[20:18:24] <acrichto> at least when I've caught sigint/term I've done more clean shutdown stuff
[20:18:33] <strcat> you may not have time to cleanly shut down
[20:18:39] <olsonjeffery> kind of tricky for "one API", as well.. do all of the POSIX signals have clear mappings in windows?
[20:18:42] <strcat> you're probably going to get a SIGKILL after a timeout from the OS
[20:18:46] <olsonjeffery> i found a candidate for SIGINT on windows
[20:18:47] <strcat> for example during reboot
[20:18:52] <olsonjeffery> but its a direct handler for catching ctrl+c
[20:19:02] <olsonjeffery> iirc, SIGINT is usually that, but it can be other things too
[20:19:37] <acrichto> olsonjeffery: I'd just do what libuv does for reconciling "signals" on windows/unix
[20:19:51] <eddyb> cmr: my guess now is that massif uses a cleaner allocator than the default one, which tends to leave apparent leaks that get filled later with new allocations
[20:20:00] <olsonjeffery> acrichto: true, true.
[20:20:11] *** Quits: FrozenCow (FrozenCow@moz-B2DF4929.chello.nl) (Client exited)
[20:20:12] *** Joins: nejucomo (Adium@B6CADF01.3778D849.1D6E592A.IP)
[20:20:15] <strcat> eddyb: use tcmalloc/jemalloc instead of glibc
[20:20:21] <olsonjeffery> when in doubt, converge on libuv.
[20:20:22] <cmr> yes, was about to say that.
[20:20:26] <cmr> jemalloc actually munmaps.
[20:20:40] <eddyb> cmr: so you can't look at the irsy graph and get a clue what's screwy
[20:20:43] <strcat> cmr: well it's unlikely it will be able to in most cases
[20:20:45] <nejucomo> How can I build rustc without building any documentation targets?  (-or better yet, how can I get GNU make to tell me which build targets are defined?)
[20:20:54] <strcat> cmr: unless you manually specify arenas
[20:20:54] <nejucomo> When I try "make" I get: make: *** No rule to make target `/rustdoc', needed by `doc/std/index.html'.  Stop.
[20:21:00] *** Joins: FrozenCow (FrozenCow@moz-B2DF4929.chello.nl)
[20:21:01] <strcat> because you'll get short and long lived objects intermingled
[20:21:12] <strcat> but the point is that tcmalloc/jemalloc have size classes
[20:21:19] <strcat> so they have very little fragmentation + unused space
[20:21:19] <eddyb> cmr: would it be too much to ask to run rustc with jemalloc? :S
[20:21:27] *** Quits: erszcz (Mibbit@moz-5D8503E6.dynamic.chello.pl) (Quit: http://www.mibbit.com ajax IRC Client)
[20:21:31] <cmr> eddyb: on irsy?
[20:21:35] <eddyb> cmr: better put: do you have the entire setup on github? so I can clone and run it myself
[20:21:50] <cmr> eddyb: it's... complicated.
[20:21:50] * nejucomo tries "make rustc" with apparent progress...
[20:21:57] <strcat> eddyb: it's pretty easy to get the memory usage if that's all you want
[20:22:02] <cmr> I used to, but it has grown pretty heavily.
[20:22:09] <strcat> eddyb: especially if you are okay with graphing it yourself
[20:22:14] <strcat> like with matplotlib
[20:22:25] <eddyb> strcat: paired with time-passes?
[20:22:27] <cmr> I still have my matplotlib and R scripts kicking around.
[20:22:28] *** Quits: hacker_sam (hacker_sam@moz-6547E589.dsl.bngr.epix.net) (Client exited)
[20:22:29] *** Joins: hacker_sam (hacker_sam@moz-6547E589.dsl.bngr.epix.net)
[20:22:31] *** Quits: FrozenCow (FrozenCow@moz-B2DF4929.chello.nl) (Client exited)
[20:22:36] *** Joins: FrozenCow (FrozenCow@moz-B2DF4929.chello.nl)
[20:22:46] <eddyb> yay for a day wasted chasing rabbits
[20:23:08] *** Quits: FrozenCow (FrozenCow@moz-B2DF4929.chello.nl) (Client exited)
[20:23:13] *** Joins: FrozenCow (FrozenCow@moz-B2DF4929.chello.nl)
[20:23:35] <cmr> eddyb: https://github.com/cmr/rust-bench/tree/3d0c7ac78d95da0bdb3921f4ee8e8aee72b6bbb2 is basically it.
[20:23:47] <cmr> I want to rewrite all of it in rust, and using rust-gnuplot
[20:23:50] <cmr> just haven't gotten around to it.
[20:24:10] *** Quits: nejucomo (Adium@B6CADF01.3778D849.1D6E592A.IP) (Quit: Leaving.)
[20:24:42] *** Quits: FrozenCow (FrozenCow@moz-B2DF4929.chello.nl) (Client exited)
[20:24:47] *** Joins: FrozenCow (FrozenCow@moz-B2DF4929.chello.nl)
[20:25:04] *** Quits: tedh (tedh@moz-F3B34318.hsd1.il.comcast.net) (Ping timeout)
[20:25:07] *** Joins: erszcz (Mibbit@moz-5D8503E6.dynamic.chello.pl)
[20:25:15] *** Joins: alan_andrade (alan_andra@9267EE86.1B9BB716.7B097AAD.IP)
[20:25:31] *** Joins: jlong (jlong@moz-6DFDE846.socal.res.rr.com)
[20:25:52] *** Joins: twi1 (Adium@moz-DFF60452.cust.dsl.vodafone.it)
[20:26:03] *** Quits: twi (Adium@moz-DFF60452.cust.dsl.vodafone.it) (Ping timeout)
[20:26:54] *** Quits: mindcat (mindcat@C3748B18.E45688C6.F21FCE99.IP) (Quit: leaving)
[20:27:01] *** Quits: alan_andrade (alan_andra@9267EE86.1B9BB716.7B097AAD.IP) (Ping timeout)
[20:27:33] <erszcz> I get the following when building rust-bindgen with rust 0.8. any ideas?
[20:27:36] <erszcz> $ rustc bindgen.rs clang.rs:12:29: 12:31 error: expected type, found token LIFETIME(ast::Ident{name: 1188u, ctxt: 0u})clang.rs:12 pub type CursorVisitor<'s> = 's |c: &Cursor, p: &Cursor| -> Enum_CXChildVisitResult;
[20:27:59] <cmr> erszcz: bindgen doesn't support 0.8
[20:28:32] *** Quits: samx (sami@moz-D9DA5773.dyn.optonline.net) (Quit: This computer has gone to sleep)
[20:28:38] <erszcz> cmr: well, I figured that out already ;) just hoped that might be a quick fix
[20:29:03] <cmr> might be able to find a commit that worked around 0.8, check git log.
[20:29:19] <strcat> looping on syscalls to deal with EINTR is such a PITA
[20:29:24] <erszcz> ok, I'll try
[20:30:08] *** Quits: twi1 (Adium@moz-DFF60452.cust.dsl.vodafone.it) (Connection reset by peer)
[20:30:08] *** Joins: tedh (tedh@moz-F3B34318.hsd1.il.comcast.net)
[20:30:47] *** Quits: canhtak (canhtak@moz-59105D0.wl.t.ulaval.ca) (Quit: canhtak)
[20:31:00] *** Joins: twi (Adium@moz-DFF60452.cust.dsl.vodafone.it)
[20:31:03] *** Quits: maikklein (maik@moz-2F166E55.dip0.t-ipconnect.de) (Ping timeout)
[20:33:44] *** Quits: azita (Azita@moz-C1FB2A8.hsd1.ca.comcast.net) (Quit: azita)
[20:36:48] *** Joins: bheylin (brianheyli@moz-8255E94E.adsl.online.nl)
[20:36:50] *** Quits: bheylin (brianheyli@moz-8255E94E.adsl.online.nl) (Quit: bheylin)
[20:36:53] *** Quits: twi (Adium@moz-DFF60452.cust.dsl.vodafone.it) (Ping timeout)
[20:36:53] *** Quits: Jesin (Jesin@moz-4B662E55.washdc.fios.verizon.net) (Ping timeout)
[20:37:08] *** Joins: twi (Adium@moz-DFF60452.cust.dsl.vodafone.it)
[20:37:11] *** Quits: jlong (jlong@moz-6DFDE846.socal.res.rr.com) (Quit: My MacBook Pro has gone to sleep. ZZZzzz…)
[20:37:19] *** Joins: Jesin (Jesin@moz-4B662E55.washdc.fios.verizon.net)
[20:37:33] *** Joins: canhtak (canhtak@moz-59105D0.wl.t.ulaval.ca)
[20:37:40] *** Joins: jlong (jlong@moz-6DFDE846.socal.res.rr.com)
[20:39:10] *** Joins: alan_andrade (alan_andra@9267EE86.1B9BB716.7B097AAD.IP)
[20:39:55] *** Quits: jmgrosen (jmgrosen@moz-848F6087.sb.sd.cox.net) (Quit: jmgrosen)
[20:41:12] *** Joins: bheylin (brianheyli@moz-8255E94E.adsl.online.nl)
[20:41:18] <eddyb> https://www.youtube.com/user/CCCen/videos any chance Rust will show up, in any way?
[20:41:21] *** Quits: twi (Adium@moz-DFF60452.cust.dsl.vodafone.it) (Ping timeout)
[20:41:45] *** Joins: twi (Adium@moz-DFF60452.cust.dsl.vodafone.it)
[20:42:09] <cmr> eddyb: I don't think any of the rust team is in attendence
[20:42:15] <cmr> it could happen anyway though :)
[20:42:34] <eddyb> there's the lightning talks
[20:43:22] *** Quits: alan_andrade (alan_andra@9267EE86.1B9BB716.7B097AAD.IP) (Quit: Leaving...)
[20:46:43] *** Quits: earlzlap (earlz@moz-483E1E31.neo.res.rr.com) (Ping timeout)
[20:49:53] *** Joins: jviereck (Adium@moz-A42B7BD5.dip0.t-ipconnect.de)
[20:51:21] *** Quits: twi (Adium@moz-DFF60452.cust.dsl.vodafone.it) (Connection reset by peer)
[20:52:17] *** Joins: twi (Adium@moz-DFF60452.cust.dsl.vodafone.it)
[20:52:37] *** Quits: nielsle (nielsle@moz-C46DA772.boa.fiberby.dk) (Quit: Ex-Chat)
[20:53:10] *** Joins: tulloch (tulloch@moz-F362C074.lnse2.pie.bigpond.net.au)
[20:53:34] *** Quits: canhtak (canhtak@moz-59105D0.wl.t.ulaval.ca) (Quit: canhtak)
[20:54:37] <johnrkd> note: gcc: fatal error: -fuse-linker-plugin, but libtlo_plugin-0.dll not found
[20:54:40] *** Quits: jackneill (jackneill@moz-1F43710.pool.digikabel.hu) (Ping timeout)
[20:54:59] *** Quits: tulloch (tulloch@moz-F362C074.lnse2.pie.bigpond.net.au) (Ping timeout)
[20:55:07] <johnrkd> there's no libtlo anywhere, but under msys it compiles without errors
[20:56:05] <strcat> you mean liblto?
[20:56:20] <johnrkd> jesus..
[20:56:47] <johnrkd> yeah i hadn't seen that
[20:57:05] <strcat> are you actually compiling with -Z lto? hm
[20:57:33] <johnrkd> my code? not explicitly at least
[20:57:55] <strcat> acrichto: any idea? ^
[20:58:05] *** Quits: twi (Adium@moz-DFF60452.cust.dsl.vodafone.it) (Ping timeout)
[20:58:06] <strcat> seems his gcc doesn't support LTO, but I didn't think it was done by default...
[20:58:14] <johnrkd> oh, it's my fault
[20:58:17] <johnrkd> it's the names
[20:58:39] <johnrkd> the name actually, i just have to include liblto in path, but can't read properly i guess
[20:59:58] *** Joins: twi (Adium@moz-A61BD2D7.cust.dsl.vodafone.it)
[21:00:20] *** Quits: twi (Adium@moz-A61BD2D7.cust.dsl.vodafone.it) (Connection reset by peer)
[21:01:48] *** Joins: twi (Adium@moz-A61BD2D7.cust.dsl.vodafone.it)
[21:02:48] *** Joins: jaen (jaen@moz-D3C934E0.play-internet.pl)
[21:02:51] *** Joins: Diamond (dick@moz-80556682.ks.ks.cox.net)
[21:02:56] *** Quits: jaen (jaen@moz-D3C934E0.play-internet.pl) (Quit: WeeChat 0.4.2)
[21:02:56] *** Quits: alisdair (textual@28441AAB.AC6E1995.F0AE27BD.IP) (Quit: My MacBook Pro has gone to sleep. ZZZzzz…)
[21:04:09] *** Joins: dredozubov (dredozubov@moz-1E374954.nationalcablenetworks.ru)
[21:04:29] *** Joins: sanxiyn (tinuviel@B4104EBB.3CC170B1.1E14B209.IP)
[21:05:43] *** Quits: twi (Adium@moz-A61BD2D7.cust.dsl.vodafone.it) (Connection reset by peer)
[21:06:02] *** Joins: twi (Adium@moz-A61BD2D7.cust.dsl.vodafone.it)
[21:07:41] *** Joins: yichoi (yichoi@5AB4884B.FCC4549.14D5B978.IP)
[21:08:10] *** Quits: blank_name (blank_name@78B04CD2.66204B68.6D228269.IP) (Connection reset by peer)
[21:09:00] *** Joins: blank_name (blank_name@78B04CD2.66204B68.6D228269.IP)
[21:09:26] *** Quits: yichoi (yichoi@5AB4884B.FCC4549.14D5B978.IP) (Ping timeout)
[21:11:19] *** Quits: jlong (jlong@moz-6DFDE846.socal.res.rr.com) (Quit: My MacBook Pro has gone to sleep. ZZZzzz…)
[21:13:33] *** Quits: hacker_sam (hacker_sam@moz-6547E589.dsl.bngr.epix.net) (Ping timeout)
[21:13:34] *** Joins: hacker_sam (hacker_sam@moz-64791626.dsl.bngr.epix.net)
[21:18:05] *** Joins: hacker_s_ (hacker_sam@moz-64791626.dsl.bngr.epix.net)
[21:18:45] *** Quits: hacker_sam (hacker_sam@moz-64791626.dsl.bngr.epix.net) (Ping timeout)
[21:21:25] *** Quits: dew (Instantbir@moz-9D36B7B6.static.stls.mo.charter.com) (Ping timeout)
[21:22:22] *** Joins: dew (Instantbir@moz-9D36B7B6.static.stls.mo.charter.com)
[21:23:53] *** Quits: twi (Adium@moz-A61BD2D7.cust.dsl.vodafone.it) (Ping timeout)
[21:25:17] *** Joins: twi (Adium@moz-A61BD2D7.cust.dsl.vodafone.it)
[21:26:25] *** Quits: sanxiyn (tinuviel@B4104EBB.3CC170B1.1E14B209.IP) (Quit: Leaving)
[21:27:04] *** Joins: adridu59 (Mibbit@moz-E1FF077C.rev.numericable.fr)
[21:27:15] <adridu59> is from_str yet another cast way?
[21:27:40] *** Quits: hacker_s_ (hacker_sam@moz-64791626.dsl.bngr.epix.net) (Client exited)
[21:27:43] <adridu59> well from_*
[21:27:56] *** Joins: canhtak (canhtak@moz-59105D0.wl.t.ulaval.ca)
[21:27:58] <adridu59> I mean, there's as, to_* and into_*
[21:28:00] *** Joins: hacker_sam (hacker_sam@moz-64791626.dsl.bngr.epix.net)
[21:28:04] <cmr> adridu59: it's not a cast.
[21:28:09] <cmr> it's conversion
[21:28:18] *** Quits: bheylin (brianheyli@moz-8255E94E.adsl.online.nl) (Quit: bheylin)
[21:28:18] *** Quits: twi (Adium@moz-A61BD2D7.cust.dsl.vodafone.it) (Ping timeout)
[21:28:24] <adridu59> what's different?
[21:28:30] <cmr> casts are with `as`
[21:28:32] *** Joins: twi (Adium@moz-A61BD2D7.cust.dsl.vodafone.it)
[21:29:02] <adridu59> conversion is you change the in-memory repr
[21:29:09] <adridu59> while cast is you change the ref?
[21:29:28] *** Quits: maxiepoo (Max@moz-D66F3D4E.atvci.net) (Quit: maxiepoo)
[21:29:36] <cmr> not necessarily. eg f64 -> i64 does some form of rounding.
[21:29:36] *** Quits: rca (rcatolino@moz-5C646728.adsl.proxad.net) (Ping timeout)
[21:29:48] *** Quits: sfackler (sfackler@moz-AEECCEBA.com) (Ping timeout)
[21:30:00] <adridu59> sur
[21:30:02] <adridu59> e
[21:30:03] *** Joins: sfackler (sfackler@moz-AEECCEBA.com)
[21:30:18] <cmr> and eg from_i32 (in FromPrimitive) implemented on i32 doesn't do anything.
[21:30:20] <adridu59> I've seen that to_* is to be preferred, is that true?
[21:30:40] <adridu59> how do I know between from/to/into
[21:30:43] <eddyb> adridu59: in general (when dealing with strings/vectors, for example), as_* are the cheapest (like a transmute), to_* allocates new memory and into_* reuses the allocation space
[21:31:06] *** Joins: azita (Azita@moz-C1FB2A8.hsd1.ca.comcast.net)
[21:31:26] <adridu59> so would I prefer as if I want to consume my originating variable?
[21:31:33] <cmr> no, as never consumes.
[21:31:49] <eddyb> adridu59: no, that's "into" if you're dealing with an allocation
[21:31:50] *** Joins: bheylin (brianheyli@moz-8255E94E.adsl.online.nl)
[21:32:05] <eddyb> if not... it can be just "to"
[21:32:25] <adridu59> if to_ allocates new memory, does that mean that it makes a clone?
[21:32:27] <cmr> into_* is in-place, to_* isn't.
[21:32:35] <cmr> adridu59: it doesn't have to clone, but it can.
[21:32:47] *** Joins: dbaupp (Thunderbir@moz-FB344509.pa.nsw.optusnet.com.au)
[21:32:49] *** Joins: jlong (jlong@moz-6DFDE846.socal.res.rr.com)
[21:32:54] *** Quits: Ferreus (ferreus@E7BEF92C.A4B602B4.7B8A71D0.IP) (Ping timeout)
[21:32:57] <adridu59> why does to_ exist alongside into_ ?
[21:33:02] <cmr> efficiency.
[21:33:18] <adridu59> allocating new memory is more efficient?
[21:33:18] <cmr> into_foo will allocate less when you don't need the original value, and if such a conversion is possible.
[21:33:37] <cmr> not everything can use into_.
[21:33:40] <adridu59> okay
[21:33:46] <adridu59> so into_ consumes, to_ does not
[21:33:51] <cmr> yes
[21:33:57] <adridu59> as_ does not either
[21:34:11] <cmr> correct
[21:34:15] <eddyb> as_ doesn't consume and it doesn't touch the original
[21:34:21] <cmr> these are all just convention though
[21:34:33] <adridu59> is as_ a copy on write thing then?
[21:34:59] <cmr> no, entirely unrelated.
[21:35:09] <eddyb> as: &'a T -> &'a U, to: &T -> ~U, into: ~T -> ~U
[21:35:39] <eddyb> that's when you're dealing with something that has a reasonable/dynamic size (a vector or a string, for example)
[21:35:42] <cmr> into is T -> U
[21:35:43] <adridu59> from my understanding: as_ just changes the calculated type, doesn't change in-memory so how can it not touch the original?
[21:35:49] <cmr> and to is &T -> U
[21:35:52] <eddyb> adridu59: most of the time, yes
[21:36:13] <eddyb> cmr: well, yeah, but not for vectors. I was trying to explicitate the allocation
[21:36:37] <eddyb> adridu59: if you are doing conversion on *values* (no heap allocated big nonsense), it's just to_*
[21:37:10] <adridu59> but speaking of as_, cmr said it doesn't touch the original so how is this possible since it doesn't allocate new memory?
[21:37:38] <cmr> adridu59: it's not possible on all types. For sample as_str on &[u8] will check if it's utf-8, and if so, return &str
[21:37:57] *** Quits: dew (Instantbir@moz-9D36B7B6.static.stls.mo.charter.com) (Ping timeout)
[21:37:57] <cmr> the &str and &[u8] reference the same memory.
[21:38:02] <eddyb> cmr: do we have as_str? I thought it was just str::from_utf8 (which does what you said)
[21:38:34] <cmr> oops, that's on c_str
[21:38:37] <eddyb> but .as_slice() on ~[T] and .as_bytes() on &str have zero cost
[21:38:39] <adridu59> ok so it does touch the original (in my own representation of it)
[21:38:47] *** Quits: twi (Adium@moz-A61BD2D7.cust.dsl.vodafone.it) (Ping timeout)
[21:38:50] <eddyb> adridu59: read-only
[21:38:54] <cmr> adridu59: it does not modify the original in any way.
[21:39:16] <adridu59> ok so as_ is just for things like printing etc.
[21:39:51] *** Joins: twi (Adium@moz-A61BD2D7.cust.dsl.vodafone.it)
[21:40:18] <adridu59> I think I'll make a table in the tutorial to explain that concisely
[21:40:21] <eddyb> not just. ~[T] coerces to &[T], but .as_slice() does it explicitly
[21:40:21] <adridu59> thanks
[21:40:29] <eddyb> I thought this was explained somewhere
[21:40:44] <eddyb> since that's how I know about as/to/into :)
[21:40:51] <dbaupp> https://github.com/mozilla/rust/wiki/Doc-detailed-release-notes#cast-naming-conventions
[21:41:15] *** Quits: Cork (Cork@moz-352B7E7B.a370.priv.bahnhof.se) (Ping timeout)
[21:42:18] <adridu59> yea I had that link but I didn't get it all from just reading it
[21:43:00] <dbaupp> as_ is essentially just for changing the "view" of a piece of data, e.g. treating a string as a vector of bytes.
[21:43:26] * eddyb finally found a community where his microoptimization obsession can be useful :D
[21:43:26] *** Quits: hoverbear (hoverbear@moz-86FCBF4B.gv.shawcable.net) (Client exited)
[21:43:27] *** Quits: twi (Adium@moz-A61BD2D7.cust.dsl.vodafone.it) (Ping timeout)
[21:43:35] *** Joins: twi (Adium@moz-A61BD2D7.cust.dsl.vodafone.it)
[21:43:49] <adridu59> yep, I think I've gotten it right now :)
[21:44:25] *** Joins: hoverbear (hoverbear@moz-86FCBF4B.gv.shawcable.net)
[21:44:33] <pyon> How do I construct a vector containing x times the same element? :-O
[21:44:57] <eddyb> vec::from_elem
[21:44:58] <dbaupp> std::from_elem(count, element)
[21:44:59] <cmr> pyon: std::vec::from_elem(x, val)
[21:45:00] <dbaupp> *std::vec::from_elem
[21:45:04] <pyon> ty
[21:45:25] <eddyb> !doc from_elem pls
[21:45:43] <bjz> cmr: is the crate_id format like this? github.com/bjz/glfw-rs#glfw:0.1
[21:45:59] <cmr> bjz: yuip
[21:46:00] *** Joins: Cork (Cork@moz-352B7E7B.a370.priv.bahnhof.se)
[21:46:03] <dbaupp> eddyb: you implement it :P
[21:46:12] * eddyb should just stop hoping and get a node.js IRC bot going
[21:46:16] <eddyb> myeah
[21:46:25] <eddyb> dbaupp: you back home yet :D?
[21:46:40] <adridu59> [element ..count] can't work?
[21:46:41] <dbaupp> eddyb: nope
[21:46:55] *** zz_kimundi is now known as kimundi
[21:46:55] <dbaupp> eddyb: extraneous circumstances delayed it
[21:46:58] <cmr> adridu59: that's only for fixed-size vectors.
[21:47:03] <dbaupp> adridu59: if count is a constant, ye
[21:47:03] <dbaupp> s
[21:47:14] <adridu59> hmm I see
[21:47:21] <dbaupp> adridu59: (it'd have to be a ~[element, .. count] though)
[21:47:36] <adridu59> yea, I wonder why this pattern isn't allowed
[21:47:45] *** Joins: ChrisMorgan (chris@moz-6AC741CA.static.tpgi.com.au)
[21:47:52] <adridu59> since ~[] is dynamic
[21:47:53] <dbaupp> which pattern?
[21:47:59] <eddyb> adridu59: because it's checked like [element, ..count]
[21:48:32] <adridu59> eddyb: checked?
[21:49:07] <eddyb> yeah. "count" has to be a const-type value *because* it's checked to be so
[21:49:27] <adridu59> ChrisMorgan: you were right, it was spawning processes, not tasks
[21:49:36] <dbaupp> eddyb: that doesn't answer the actual question (which is "why is it checked like that") at all
[21:49:55] <eddyb> dbaupp: because it's checked like [element, ..count]
[21:50:05] <eddyb> because the latter is a fixvec type
[21:50:14] <adridu59> I don't see why you couldn't allow initialization of dynamic vec as long as it start with a tilde
[21:50:19] <dbaupp> eddyb: yes, that's answering "why is it checked like X when circumstance Y" with "it is checked like X"
[21:50:36] <dbaupp> eddyb: i.e. completely useless
[21:50:37] * eddyb blinks. maybe it's a little too late
[21:51:05] *** Quits: jviereck (Adium@moz-A42B7BD5.dip0.t-ipconnect.de) (Quit: Leaving.)
[21:51:16] <dbaupp> eddyb: you aren't saying anything new, adridu59 is questioning why the dynamic one has to be checked the same as the static one
[21:51:36] <dbaupp> the only connection between them is they are both vectors and the syntax is the same
[21:51:54] * dbaupp kinda just wants to remove ~[] entirely
[21:52:08] <eddyb> too late as in I'm tired
[21:52:10] <adridu59> really?
[21:52:21] <cmr> I also would like to see ~[] gone
[21:52:31] <adridu59> in favor of what?
[21:52:35] *** Joins: dew (Instantbir@moz-9D36B7B6.static.stls.mo.charter.com)
[21:52:37] <cmr> Vec<T>
[21:52:41] <dbaupp> a library defined vector
[21:52:43] <cmr> Not a built-in type, a real library type.
[21:52:48] <adridu59> eddyb: I feel that too, being in Europe
[21:52:50] <dbaupp> like https://github.com/thestinger/rust-core/blob/master/core/vec.rs
[21:53:08] <eddyb> cmr: but... the idea that me and nmatsakis liked...
[21:53:10] *** Joins: tulloch (tulloch@moz-F362C074.lnse2.pie.bigpond.net.au)
[21:53:10] <whitequark> cmr: it's somewhat sad to see the syntax for ~[] and @ gone, though
[21:53:30] <eddyb> ~[T] being just (*T, len) on the heap
[21:53:36] <adridu59> but that would leave out the ~ pointee
[21:53:38] <dbaupp> whitequark: in theory we'd get generic container literals too
[21:53:47] <adridu59> also what would be the big deal of such an implementation?
[21:53:56] <dbaupp> eddyb: I personally don't see that as being super useful
[21:54:00] <whitequark> dbaupp: that sounds nice.
[21:54:14] *** Quits: hacker_sam (hacker_sam@moz-64791626.dsl.bngr.epix.net) (Client exited)
[21:54:15] *** Joins: hacker_sam (hacker_sam@moz-64791626.dsl.bngr.epix.net)
[21:54:25] <eddyb> dbaupp: it makes sense with DST, I guess
[21:54:28] <dbaupp> eddyb: and it can just be a library type too
[21:54:44] <whitequark> unrelated: is there any plans to make format! (and by proxy, fail!, assert! and friends) emit less horrible code?
[21:54:54] *** Quits: jdm (jdm@moz-AC9499B2.cable.teksavvy.com) (Quit: Lost terminal)
[21:55:03] *** Quits: tulloch (tulloch@moz-F362C074.lnse2.pie.bigpond.net.au) (Ping timeout)
[21:55:08] <dbaupp> eddyb: same with &[T] and so on (although &[T] is far more fundamental in that it has no dtor or ownership implications)
[21:55:13] <eddyb> dbaupp: but it makes it nothing more than an allocated slice, and anything growable would use a vector
[21:55:29] <dbaupp> eddyb: yeah, but how useful is an allocated slice?
[21:55:57] <dbaupp> eddyb: compared to just spending a single extra word on a capacity
[21:56:00] <cmr> eddyb: why is ~[T] with that repr any different than &[T]? Why does allocation detail matter in any way? I know youve explained it before but I've since forgotten.
[21:56:06] <dbaupp> eddyb: or defining the allocated slice as a library type too
[21:56:12] <dbaupp> cmr: dtor
[21:56:15] <dbaupp> cmr: to free the *T
[21:56:22] <eddyb> and it moves
[21:56:36] <dbaupp> eddyb: ~[T] also lacks a sensible way to get allocator support
[21:56:39] <cmr> Right, but what's the advantage?
[21:56:42] <dbaupp> eddyb: (dtor == moves ;) )
[21:56:48] <eddyb> so does ~T
[21:56:54] *** Quits: twi (Adium@moz-A61BD2D7.cust.dsl.vodafone.it) (Ping timeout)
[21:57:13] *** Joins: twi (Adium@moz-A61BD2D7.cust.dsl.vodafone.it)
[21:57:19] <eddyb> ~<A=DefaultHeap>T => Uniq<T, A=DefaultHeap>
[21:57:24] * dbaupp thinks Uniq<T> wouldn't be ok with pointer traits
[21:57:29] <dbaupp> *would be
[21:57:30] *** Joins: samx (sami@moz-D9DA5773.dyn.optonline.net)
[21:57:35] <dbaupp> and just remove ~T too
[21:57:43] *** Joins: maxiepoo (Max@moz-D66F3D4E.atvci.net)
[21:57:45] <dbaupp> it gets way overused anyway
[21:57:58] <eddyb> but then Uniq is a bit heavy
[21:58:00] <cmr> I'd be fine keeping ~Trait, too.
[21:58:05] *** Joins: earlzlap (earlz@moz-483E1E31.neo.res.rr.com)
[21:58:08] <cmr> But removing ~T in general.
[21:58:09] *** Quits: samx (sami@moz-D9DA5773.dyn.optonline.net) (Quit: This computer has gone to sleep)
[21:58:18] <dbaupp> eddyb: see "way overused"
[21:58:45] <dbaupp> eddyb: the most common time you'd see Uniq is in recursive datastructures
[21:58:47] <eddyb> I guess Uniq<[T]> could be the frozen version of Vec<T>
[21:59:03] <eddyb> and everyone would use the latter
[21:59:14] <dbaupp> rather than everywhere like we currently see in library code
[21:59:49] * eddyb really liked the possibility of freezing and thawing the length of a ~[T]
[22:00:17] *** Joins: pao (pao@moz-AF905E87.fbx.proxad.net)
[22:00:40] <eddyb> default generic arguments should be easy. heck, I might try it tomorrow if I don't find anything better to hack on
[22:00:55] <eddyb> ~<A>T should be doable
[22:00:58] <dbaupp> eddyb: it's pretty neat, but I don't see why it needs to be a special compiler built-in rather than just FrozenVec<T> { dat: *T, len: uint } in lib::std... putting things in libraries is far more flexible
[22:01:04] <dbaupp> eddyb: yes please!
[22:01:26] <dbaupp> eddyb: but focus on normal generics to begin with... that'll be far easy to get to land
[22:01:59] *** Quits: adridu59 (Mibbit@moz-E1FF077C.rev.numericable.fr) (Quit: http://www.mibbit.com ajax IRC Client)
[22:02:19] *** Quits: canhtak (canhtak@moz-59105D0.wl.t.ulaval.ca) (Quit: canhtak)
[22:02:31] <eddyb> dbaupp: it wouldn't be more "built-in" than slices at that point
[22:02:50] <eddyb> but it might need DST to be truly non-specific
[22:03:07] *** Quits: pao (pao@moz-AF905E87.fbx.proxad.net) (Quit: pao)
[22:03:19] <dbaupp> eddyb: except for the implicit dtor
[22:03:20] <dbaupp> eddyb: (e.g. ~[] currently doesn't actually implement Drop)
[22:03:31] <dbaupp> rusti: fn drop<D: Drop>(_ :T) {} drop(~[1])
[22:03:33] -rusti- pastebinned 7 lines of output: http://ix.io/9ze
[22:03:51] *** Quits: hacker_sam (hacker_sam@moz-64791626.dsl.bngr.epix.net) (Client exited)
[22:04:03] <dbaupp> whoops
[22:04:11] <dbaupp> rusti: fn drop<D: Drop>(_ :D) {} drop(~[1])
[22:04:13] -rusti- pastebinned 6 lines of output: http://ix.io/9zf
[22:04:24] *** Joins: hacker_sam (hacker_sam@moz-64791626.dsl.bngr.epix.net)
[22:05:34] *** Joins: SiegeLord (sl@moz-CAF07B4C.hsd1.ma.comcast.net)
[22:05:39] <eddyb> dbaupp: hmm. yeah. it would need an implicit dtor on [T, ..N]
[22:05:46] *** Quits: bobthenameless (bobthename@moz-6069EE20.dhcp.leds.al.charter.com) (Ping timeout)
[22:05:54] <eddyb> which makes [DS]ST confusing for me
[22:07:51] <eddyb> dbaupp: 1496 lines with ~, while 2070 lines with @, in librustc
[22:08:13] *** Joins: yichoi (yichoi@5AB4884B.FCC4549.14D5B978.IP)
[22:08:16] <eddyb> and @T would be eventually replaced with Rc<T>
[22:09:08] <dbaupp> eddyb: how many of the ~ lines are ~" or ~[ ?
[22:09:22] <eddyb> dbaupp: I don't know.... I hate things that add a burden to the language, mostly because it's hard to predict how bad the resulting language will be
[22:09:45] <eddyb> dbaupp: 1111
[22:09:54] *** Quits: yichoi (yichoi@5AB4884B.FCC4549.14D5B978.IP) (Ping timeout)
[22:10:25] <dbaupp> eddyb: I'm not following... which thing do you think will add a burden?
[22:10:36] *** Quits: azita (Azita@moz-C1FB2A8.hsd1.ca.comcast.net) (Quit: azita)
[22:10:37] <eddyb> Uniq<T>
[22:11:01] <eddyb> Vec<T> is actually not that bad, but I'm afraid of Slice<T>
[22:11:05] <dbaupp> we could have ~T desugar to Uniq<T, A=std::os::Heap> or something
[22:11:19] * dbaupp isn't keen on Slice<T> either
[22:12:04] <eddyb> ~<A>T so strcat doesn't complain :P
[22:12:24] <eddyb> dbaupp: 1392 including ~str
[22:12:47] *** Quits: sigma1 (sigma@C91C7F36.70518F41.9D18269F.IP) (Ping timeout)
[22:13:37] *** Joins: alisdair (textual@28441AAB.AC6E1995.F0AE27BD.IP)
[22:13:41] *** Joins: elux (peter@moz-6B45ADE5.dsl.bell.ca)
[22:14:03] <eddyb> dbaupp: there's barely anything at all using ~T for indirection in librustc
[22:14:17] <dbaupp> yup
[22:14:37] <dbaupp> although that's possibly just because it was written when only @ existed
[22:14:44] <eddyb> hah
[22:14:51] <dbaupp> is anyone else getting "undefined reference to `__cxa_begin_catch'" etc when compiling things?
[22:14:58] <eddyb> dbaupp: make clean
[22:14:59] <cmr> dbaupp: make clean
[22:15:00] <dbaupp> (bootstrap works but anything else doesn't.)
[22:15:22] <dbaupp> bleh, I just spent 20 minutes compiling :'(
[22:15:37] <eddyb> dbaupp: I would tell you to clean x86_64-unknown-linux-gnu/rt, but I found out "make clean" doesn't nuke llvm :P
[22:15:37] <dbaupp> and don't have 20 minutes of hacking time left this morning...
[22:15:42] <elux> have you guys thought about adding task syntax for communicating to a port / channel? .. ie. like Go ..
[22:15:48] * dbaupp postpones his work
[22:16:11] <eddyb> elux: how does Go look like for this?
[22:16:22] <dbaupp> elux: i.e. chan <- x instead of chan.send(x)?
[22:16:27] <dbaupp> or whatever the syntax is 
[22:16:28] <elux> c <- data <-c
[22:16:34] <eddyb> chan << x should be doable
[22:16:51] <eddyb> (but some people hate C++'s choice of << and >> for streams)
[22:16:51] <dbaupp> yay C++ iostreams ;P
[22:16:53] <elux> even to initialize the channel..
[22:17:07] *** Quits: decoder (quassel@moz-D7023D7D.own-hero.net) (Ping timeout)
[22:17:34] <cmr> elux: Why would we add syntax to a purely-library type?
[22:17:38] *** Quits: _Vi (vi@D7277DB6.6FF508C1.10C239DF.IP) (Ping timeout)
[22:17:39] <strcat> iostreams/fstreams are the *worst* thing ever
[22:17:41] <strcat> seriously
[22:17:44] *** Joins: decoder (quassel@moz-D7023D7D.own-hero.net)
[22:17:50] <strcat> ifstream if("foo");
[22:17:56] <strcat> now try to find out why it failed
[22:17:59] <cmr> I agree
[22:17:59] <strcat> it won't tell you.
[22:18:18] <eddyb> strcat: it failed because "if" is a keyword :P
[22:18:29] <eddyb> gcc and clang will tell you
[22:18:31] <strcat> s/if/is/
[22:18:34] <elux> fair enough
[22:18:48] <strcat> C++ fstreams don't have error reporting ;p, just 'there was an error, derp'
[22:18:58] <eddyb> yeah, they're awkward
[22:19:06] <strcat> and they clobber errno too! at least libstdc++ does, and you have no guarantees they won't
[22:19:46] <eddyb> << and >> are cool only for highschool students. and that only after they wrap their minds around those operators. and they never find out their true meaning :P
[22:20:54] <strcat> C++ formatted I/O is especially awful.
[22:21:03] *** Joins: jhasse (jhasse@moz-F3702E2C.ewe-ip-backbone.de)
[22:21:20] <strcat> it's so fun how int8_t prints as a character because it's a typedef too
[22:21:23] <eddyb> strcat: I was lucky to learn C++ in a kernel. that's why I like it slightly more than people who touch STL and go "eww"
[22:21:33] <strcat> well, a lot of C++ is nice
[22:21:33] <eddyb> ah, lol, yes
[22:21:38] <strcat> the language I mean
[22:21:42] <strcat> but there's a lot of horrors there too.
[22:21:49] <eddyb> strcat: and bool prints like an i8. which is a char
[22:21:54] <strcat> eddyb: you can fix bool
[22:22:05] <eddyb> but it needs extra code
[22:22:09] <dbaupp> strcat: there was someone complaining that [u8] doesn't get printed as an ascii buffer by {:?} yesterday :P
[22:22:16] <strcat> eddyb: there's a boolalpha formatter thing ;p
[22:22:39] *** Joins: canhtak (canhtak@moz-59105D0.wl.t.ulaval.ca)
[22:22:48] <eddyb> strcat: I remember how pointers for which I couldn't properly specialize a template, were printing as bools. hehe
[22:23:09] <eddyb> the joys of duck typing
[22:23:22] <cmr> (mitsuhiko)
[22:23:29] <strcat> eddyb: well that's why they added nullptr
[22:23:47] <strcat> -Wzero-as-null-pointer-constant
[22:23:53] <eddyb> strcat: you actually made laugh out loud after midnight
[22:24:53] <acrichto> dbaupp: I wonder if there should be "impl fmt::String for &[u8]"
[22:25:09] <eddyb> oooh, that would work
[22:25:16] <cmr> acrichto: well the specific complaint was in {:?} anyway
[22:25:24] <strcat> acrichto: and how do you escape stuff? like python?
[22:25:41] <acrichto> whoa relax guys just thinking out loud
[22:25:52] <eddyb> > python
[22:26:02] *** Quits: hacker_sam (hacker_sam@moz-64791626.dsl.bngr.epix.net) (Client exited)
[22:26:19] <strcat> acrichto: I don't mean as a bad thing
[22:26:23] <olsonjeffery> > greentext
[22:26:27] <strcat> just wondering how we are going to escape it
[22:26:49] *** Joins: gareth0 (gareth0@moz-1C2D7BA0.dynamic.dsl.as9105.com)
[22:26:52] <acrichto> strcat: what do you mean escaping? I was just thinking you'd write the &[u8] directly into the Writer
[22:27:08] <acrichto> it's just one method to format a &[u8], not *the* method
[22:27:14] <strcat> acrichto: ah that's what I was wondering
[22:27:21] <strcat> if you'd print it directly or escape non-ascii stuff
[22:28:15] <gareth0> how do I catch failure inside gdb? "catch throw" used to work but does no more...
[22:28:30] <eddyb> gareth0: _Unwind_Start I think
[22:28:33] <acrichto> gareth0: break _Unwind_Raise_Exception
[22:28:41] <acrichto> oh man _Unwind_Start is a much easier thing to remember
[22:28:44] <acrichto> do that
[22:28:46] <cmr> gareth0: break _Unwind_Raise_Exception
[22:28:53] <cmr> hrup
[22:28:53] *** Joins: _Vi (vi@D7277DB6.6FF508C1.10C239DF.IP)
[22:28:53] <eddyb> acrichto: I'm not sure it's a thing
[22:28:55] <cmr> *hurp
[22:28:57] * cmr sits on his hands
[22:29:01] <cmr> eddyb: it is
[22:29:08] * eddyb checks
[22:29:20] <acrichto> does 'catch throw' break on __cxa_something_or_other?
[22:29:24] <cmr> acrichto: yeah
[22:29:29] <eddyb> rabin2 -s ./x*/stage1/lib/libstd-*.so | grep FUNC | grep Unwind
[22:29:29] <acrichto> oh well
[22:29:40] <eddyb> no, just _Unwind_RaiseException
[22:29:52] <eddyb> (no _ between Raise and Exception)
[22:29:52] <KokaKiwi> Aaaah :( I lost the pad about default args in the MoPad D:
[22:30:02] <acrichto> eddyb: it may be in libgcc, not necessarily referenced from libstd
[22:30:04] *** Quits: victorporof (victorporo@AFD25FB8.16D3B2F1.79933D60.IP) (Ping timeout)
[22:30:14] <ChrisMorgan> Aww, "catch throw" doesn't work any more? :-(
[22:30:56] <cmr> hrm
[22:31:14] *** Quits: twi (Adium@moz-A61BD2D7.cust.dsl.vodafone.it) (Connection timed out)
[22:31:58] <eddyb> rabin2 -s /usr/lib64/gcc/x86_64-suse-linux/4.8/libgcc_s.so | grep FUNC | grep Unwind_
[22:32:01] *** Joins: twi (Adium@moz-A61BD2D7.cust.dsl.vodafone.it)
[22:32:08] <eddyb> no Unwind_Start. it was just my bad memory
[22:32:30] *** Quits: gareth0 (gareth0@moz-1C2D7BA0.dynamic.dsl.as9105.com) (Ping timeout)
[22:32:52] <cmr> oh, the question was _Unwind_Start, not _Unwind_RaiseException
[22:33:22] <eddyb> acrichto: sorry for getting you excited :-<
[22:33:32] *** Joins: Ferreus (ferreus@moz-559CD583.pools.arcor-ip.net)
[22:33:50] <acrichto> hehe oh well
[22:34:08] <eddyb> we need "catch unwind"
[22:34:25] *** Joins: ecl3ctic1 (Mibbit@578C64B6.F0F44EFA.76AE55C1.IP)
[22:34:42] *** Quits: twi (Adium@moz-A61BD2D7.cust.dsl.vodafone.it) (Ping timeout)
[22:34:49] *** Joins: twi (Adium@moz-A61BD2D7.cust.dsl.vodafone.it)
[22:35:44] <ChrisMorgan> rustc needs something like a --help-debug flag which reminds you "use `break _Unwind_RaiseException` in GDB"
[22:37:22] <johnrkd> i wonder if it's correct to attribute go's "explosion" to docker
[22:39:38] *** Quits: dbaupp (Thunderbir@moz-FB344509.pa.nsw.optusnet.com.au) (Ping timeout)
[22:40:03] *** Joins: erickt1 (Adium@moz-4B000CB7.dyn.optonline.net)
[22:41:37] *** Quits: pcdummy (pcdummy@moz-CF4CA865.page4me.ch) (Ping timeout)
[22:41:53] *** Joins: pcdummy (pcdummy@moz-CF4CA865.page4me.ch)
[22:43:20] <kimundi> oh, trait object coercion landed? nice
[22:44:31] *** Joins: zslayton (Mibbit@moz-4806B979.nyc.res.rr.com)
[22:45:55] *** Quits: Jesin (Jesin@moz-4B662E55.washdc.fios.verizon.net) (Quit: Leaving)
[22:46:04] *** Joins: brianm (brianm@moz-8161EF8D.hsd1.ca.comcast.net)
[22:48:10] *** Joins: Jesin (Jesin@moz-4B662E55.washdc.fios.verizon.net)
[22:50:20] *** Quits: twi (Adium@moz-A61BD2D7.cust.dsl.vodafone.it) (Connection reset by peer)
[22:50:22] *** Joins: tulloch (tulloch@moz-F362C074.lnse2.pie.bigpond.net.au)
[22:51:30] *** Joins: twi (Adium@moz-A61BD2D7.cust.dsl.vodafone.it)
[22:51:59] *** Joins: alexanderkyte (alexanderk@moz-95DBFBC5.csh.rit.edu)
[22:53:04] <alexanderkyte> I'm having an issue building rust on my archlinux arm installation on my exynos chromebook. The triplet isn't recognised, arch just shows it as arm-unknown-gnu. 
[22:54:08] <ChrisMorgan> alexanderkyte: that should be arm-unknown-gnueabi or arm-unknown-gnueabihf
[22:54:28] <strcat> arm-linux-gnueabi/arm-linux-gnueabihf
[22:54:37] <strcat> the unknown would only be in the 4 part "triple" with vendor
[22:54:52] <strcat> and it's ignored, can be 'none', 'pc', 'unknown', or 'applepie'
[22:55:02] <ChrisMorgan> Sorry, I meant arm-unknown-linux-gnueabi{,hf}
[22:55:04] *** Quits: twi (Adium@moz-A61BD2D7.cust.dsl.vodafone.it) (Connection reset by peer)
[22:55:05] <cmr> hmm that's tempting.
[22:55:24] * strcat doesn't get the point of having the vendor
[22:55:27] <ChrisMorgan> Those are the ones that are recognised—thus using the embedded ABI. I don't know about any other.
[22:55:31] *** Joins: hacker_sam (hacker_sam@moz-64791626.dsl.bngr.epix.net)
[22:55:43] <strcat> ChrisMorgan: there's non-gnu eabi
[22:55:45] <whitequark> strcat: afaik it activates several specific workarounds in LLVM, take a look at Triple.cpp
[22:55:45] *** Quits: hacker_sam (hacker_sam@moz-64791626.dsl.bngr.epix.net) (Connection reset by peer)
[22:55:54] *** Joins: hacker_sam (hacker_sam@moz-64791626.dsl.bngr.epix.net)
[22:55:58] *** Quits: tulloch (tulloch@moz-F362C074.lnse2.pie.bigpond.net.au) (Ping timeout)
[22:56:07] *** Joins: twi (Adium@moz-A61BD2D7.cust.dsl.vodafone.it)
[22:56:08] <strcat> ChrisMorgan: I *think*... it might change enums
[22:56:12] <strcat> forget
[22:56:14] <eddyb> cmr: what is?
[22:56:24] <ChrisMorgan> alexanderkyte: are you able to use builds from http://luqman.ca/rust-builds/?
[22:56:26] <cmr> eddyb: changing my vendor to something amusing
[22:56:32] <eddyb> hehehe
[22:56:36] <strcat> iirc, eabi has short enums and gnueabi starts as C int size
[22:56:41] <alexanderkyte> Also, the cpu type isn't recognised. The configure file expects 'arm' but my system reports armv7l
[22:56:53] <alexanderkyte> Let me check
[22:57:38] *** Joins: samx (sami@moz-D9DA5773.dyn.optonline.net)
[22:57:53] <ChrisMorgan> RFC: rustc --help-debug flag which, to begin with, reminds you about `break _Unwind_RaiseException` for GDB. (acrichto?)
[22:58:15] <ChrisMorgan> (I know how to implement it and am ready to do so.)
[22:58:18] <acrichto> ChrisMorgan: I think we need a better FAQ/guide page
[22:58:21] <eddyb> whe not a tutorial or something?
[22:58:23] <eddyb> *why
[22:58:27] <whitequark> strcat: I was curious and checked. apparently the only thing it does in LLVM is disambuguates several subtarget features in PPC.
[22:59:08] <ChrisMorgan> eddyb, acrichto: online pages which you'll need (with difficulty) to find where you can have it baked into the tool that you're actually *using*? (The two are not mutually exclusive.)
[22:59:23] *** Quits: bheylin (brianheyli@moz-8255E94E.adsl.online.nl) (Quit: bheylin)
[22:59:42] <ChrisMorgan> I believe including information in rustc itself for these sorts of things is a good idea.
[22:59:57] <eddyb> maybe if it's easy to reach from --help
[23:00:02] *** Quits: erszcz (Mibbit@moz-5D8503E6.dynamic.chello.pl) (Quit: http://www.mibbit.com ajax IRC Client)
[23:00:13] <ChrisMorgan> We should generate man pages for rust tools, too.
[23:00:26] <acrichto> ChrisMorgan: I'd open an issue/discuss on ML first, I'd be hesitant about adding flags like that to the compiler
[23:00:27] <cmr> generate? they're hand written! with love!
[23:00:27] *** Quits: dbussink (dbussink@moz-E0A5568C.bussink.me) (Ping timeout)
[23:00:30] <ChrisMorgan> eddyb: sure, you'd say "for more info about specific topics, --help-debug, &c." at the bottom of it.
[23:00:34] *** Joins: dbussink (dbussink@moz-E0A5568C.bussink.me)
[23:00:36] *** Quits: DasIch (dasich@moz-5EDA591.de) (Ping timeout)
[23:01:17] *** Quits: LRN (LRN@moz-50DF30B.nationalcablenetworks.ru) (Ping timeout)
[23:01:19] <ChrisMorgan> cmr: although "generate" suggests automatic work, it doesn't require it.
[23:01:29] *** Quits: decoder (quassel@moz-D7023D7D.own-hero.net) (Ping timeout)
[23:01:30] <cmr> what I mean is we already have t hem
[23:01:32] *** Quits: jlong (jlong@moz-6DFDE846.socal.res.rr.com) (Quit: My MacBook Pro has gone to sleep. ZZZzzz…)
[23:01:41] <ChrisMorgan> Where?
[23:01:51] *** Quits: FrozenCow (FrozenCow@moz-B2DF4929.chello.nl) (Client exited)
[23:01:58] *** Joins: FrozenCow (FrozenCow@moz-B2DF4929.chello.nl)
[23:01:59] <ChrisMorgan> Ah, man/.
[23:02:04] *** Quits: pcdummy (pcdummy@moz-CF4CA865.page4me.ch) (Ping timeout)
[23:02:07] *** Joins: LRN (LRN@moz-50DF30B.nationalcablenetworks.ru)
[23:02:23] * ChrisMorgan now goes to check how far out of date they are, to prove a point
[23:02:24] *** Quits: mrshankly (mrshankly@3EE34383.CE0EEBAE.806C54C8.IP) (Ping timeout)
[23:02:32] *** Quits: dredozubov (dredozubov@moz-1E374954.nationalcablenetworks.ru) (Ping timeout)
[23:02:32] *** Quits: msch (msch@moz-DA0E34D4.clients.your-server.de) (Ping timeout)
[23:02:36] *** Joins: mrshankly (mrshankly@3EE34383.CE0EEBAE.806C54C8.IP)
[23:02:55] *** Quits: brianm (brianm@moz-8161EF8D.hsd1.ca.comcast.net) (Quit: Leaving...)
[23:03:09] <cmr> they're updated at least every release
[23:03:23] *** Quits: _Vi (vi@D7277DB6.6FF508C1.10C239DF.IP) (Ping timeout)
[23:03:33] <ChrisMorgan> … which would explain "rustc 0.7"
[23:03:47] <eddyb> heh
[23:03:55] <cmr> heh
[23:04:11] *** Quits: FrozenCow (FrozenCow@moz-B2DF4929.chello.nl) (Client exited)
[23:04:13] *** Joins: FrozenCow (FrozenCow@moz-B2DF4929.chello.nl)
[23:04:24] *** Joins: dredozubov (dredozubov@moz-1E374954.nationalcablenetworks.ru)
[23:04:30] <cmr> that part is probably an oversight :p
[23:04:43] *** Quits: smvv (smvv@moz-A397289C.xlshosting.net) (Ping timeout)
[23:04:55] *** Quits: terje (terje@F5FDF11B.1D1EB2D6.85889BB1.IP) (Ping timeout)
[23:04:55] *** Joins: smvv (smvv@moz-A397289C.xlshosting.net)
[23:05:19] *** Quits: LRN (LRN@moz-50DF30B.nationalcablenetworks.ru) (Ping timeout)
[23:05:23] *** Joins: terje (terje@F5FDF11B.1D1EB2D6.85889BB1.IP)
[23:05:28] *** Quits: mrshankly (mrshankly@3EE34383.CE0EEBAE.806C54C8.IP) (Ping timeout)
[23:05:33] *** Quits: Amanieu (amanieu@10FEE2FD.ECEF57A4.2CFD4520.IP) (Ping timeout)
[23:06:14] *** Joins: DasIch (dasich@moz-5EDA591.de)
[23:06:17] *** Quits: FrozenCow (FrozenCow@moz-B2DF4929.chello.nl) (Client exited)
[23:06:19] *** Joins: FrozenCow (FrozenCow@moz-B2DF4929.chello.nl)
[23:06:46] *** Quits: smvv (smvv@moz-A397289C.xlshosting.net) (Ping timeout)
[23:07:05] *** Quits: terje (terje@F5FDF11B.1D1EB2D6.85889BB1.IP) (Ping timeout)
[23:07:24] <ChrisMorgan> So, the state of the man pages we have: rustc is missing things. rustdoc has errors (e.g. --input-format may be html or json—should be rust or json) and may be old. rustpkg is enormously out of date.
[23:07:37] *** Joins: Amanieu (amanieu@10FEE2FD.ECEF57A4.2CFD4520.IP)
[23:07:47] *** Joins: mrshankly (mrshankly@3EE34383.CE0EEBAE.806C54C8.IP)
[23:07:47] *** Joins: msch (msch@moz-DA0E34D4.clients.your-server.de)
[23:07:49] *** Joins: LRN (LRN@moz-50DF30B.nationalcablenetworks.ru)
[23:07:50] *** Quits: Amanieu (amanieu@10FEE2FD.ECEF57A4.2CFD4520.IP) (Broken pipe)
[23:07:53] *** Joins: pcdummy (pcdummy@moz-CF4CA865.page4me.ch)
[23:07:55] *** Quits: katis (katis@40C8AF65.EFDC2270.EE6E63A5.IP) (Ping timeout)
[23:08:00] *** Joins: Amanieu (amanieu@10FEE2FD.ECEF57A4.2CFD4520.IP)
[23:08:05] *** Quits: DasIch (dasich@moz-5EDA591.de) (Ping timeout)
[23:08:05] *** Joins: katis (katis@40C8AF65.EFDC2270.EE6E63A5.IP)
[23:08:06] *** Joins: _Vi (vi@D7277DB6.6FF508C1.10C239DF.IP)
[23:08:08] *** Quits: twi (Adium@moz-A61BD2D7.cust.dsl.vodafone.it) (Ping timeout)
[23:08:21] *** Joins: twi (Adium@moz-A61BD2D7.cust.dsl.vodafone.it)
[23:08:32] *** Joins: yichoi (yichoi@5AB4884B.FCC4549.14D5B978.IP)
[23:09:07] <KokaKiwi> Hey, is there a way to find a pad in MoPad? :/
[23:09:10] *** Quits: hacker_sam (hacker_sam@moz-64791626.dsl.bngr.epix.net) (Client exited)
[23:09:26] <cmr> KokaKiwi: not afaik..
[23:09:29] <cmr> ChrisMorgan: sounds about right!
[23:09:31] *** Joins: hacker_sam (hacker_sam@moz-64791626.dsl.bngr.epix.net)
[23:09:39] <eddyb> KokaKiwi: your browser history :P?
[23:09:49] *** Joins: smvv (smvv@moz-A397289C.xlshosting.net)
[23:10:15] *** Quits: yichoi (yichoi@5AB4884B.FCC4549.14D5B978.IP) (Ping timeout)
[23:10:15] *** Quits: b (b@moz-55CA322E.org) (Ping timeout)
[23:10:21] *** Joins: terje (terje@F5FDF11B.1D1EB2D6.85889BB1.IP)
[23:11:03] *** Joins: frau (frau@A432E5CC.191304CB.C579BC3E.IP)
[23:11:16] *** Quits: LRN (LRN@moz-50DF30B.nationalcablenetworks.ru) (Ping timeout)
[23:11:49] *** Quits: enix (enix@moz-A50569DD.c3-0.slvr-ubr1.lnh-slvr.md.cable.rcn.com) (Quit: Konversation terminated!)
[23:12:07] *** Quits: terje (terje@F5FDF11B.1D1EB2D6.85889BB1.IP) (Ping timeout)
[23:12:33] *** Quits: pcdummy (pcdummy@moz-CF4CA865.page4me.ch) (Ping timeout)
[23:12:47] *** Joins: jmgrosen (jmgrosen@moz-848F6087.sb.sd.cox.net)
[23:12:54] *** Quits: _Vi (vi@D7277DB6.6FF508C1.10C239DF.IP) (Ping timeout)
[23:13:06] *** Joins: pcdummy (pcdummy@moz-CF4CA865.page4me.ch)
[23:13:33] *** Quits: mrshankly (mrshankly@3EE34383.CE0EEBAE.806C54C8.IP) (Ping timeout)
[23:13:36] *** Quits: dsirenko (mitra@8E712A0.54C21BA0.9F317420.IP) (Ping timeout)
[23:13:37] *** Joins: b (b@moz-55CA322E.org)
[23:14:44] *** Joins: mrshankly (mrshankly@3EE34383.CE0EEBAE.806C54C8.IP)
[23:14:50] *** Quits: tsvia (tsvia@moz-DDA0CF97.red.bezeqint.net) (Ping timeout)
[23:15:03] *** Quits: dredozubov (dredozubov@moz-1E374954.nationalcablenetworks.ru) (Ping timeout)
[23:15:10] *** Joins: terje (terje@F5FDF11B.1D1EB2D6.85889BB1.IP)
[23:15:10] *** Joins: dsirenko (mitra@8E712A0.54C21BA0.9F317420.IP)
[23:15:16] *** Quits: b (b@moz-55CA322E.org) (Ping timeout)
[23:15:22] *** Quits: Mindless` (mindless@moz-9C38D3B4.net) (Ping timeout)
[23:15:23] *** Joins: Mindless` (mindless@moz-9C38D3B4.net)
[23:15:29] *** Joins: LRN (LRN@moz-50DF30B.nationalcablenetworks.ru)
[23:15:37] *** Joins: dredozubov (dredozubov@moz-1E374954.nationalcablenetworks.ru)
[23:16:07] <ercxx> does anybody know any udp stuff done in rust that I can look at?
[23:16:08] *** Joins: b (b@moz-55CA322E.org)
[23:16:17] <cmr> ercxx: there's the tests..
[23:16:27] *** Joins: decoder (quassel@moz-D7023D7D.own-hero.net)
[23:16:40] <ercxx> cmr: thank you.
[23:16:50] *** Joins: maikklein (maik@moz-2F166E55.dip0.t-ipconnect.de)
[23:16:53] *** Quits: twi (Adium@moz-A61BD2D7.cust.dsl.vodafone.it) (Ping timeout)
[23:17:04] *** Joins: twi (Adium@moz-A61BD2D7.cust.dsl.vodafone.it)
[23:17:26] *** Quits: c-a (c-a@380CCB84.6116A87C.3B6D96BA.IP) (Ping timeout)
[23:17:50] *** Joins: DasIch (dasich@moz-5EDA591.de)
[23:18:10] <pyon> Is there any way to make a field of a struct immutable, even if the struct itself is mutable?
[23:18:18] <cmr> pyon: no
[23:18:32] <alexanderkyte> The builds linked earlier work
[23:18:33] <pyon> Oh, well, then I guess I will have to provide getters. :-P
[23:18:43] <cmr> yeah, it's a bit unfortunate :(
[23:18:46] <alexanderkyte> And generate working executables
[23:18:51] <ChrisMorgan> alexanderkyte: hf?
[23:19:00] <alexanderkyte> armv7hf
[23:19:32] *** Joins: _Vi (vi@D7277DB6.6FF508C1.10C239DF.IP)
[23:19:40] <ChrisMorgan> alexanderkyte: OK, sounds like you get to tweak the makefiles (Makefile.in, mk/*) to support your architecture as the same as gnueabihf.
[23:20:04] *** Quits: twi (Adium@moz-A61BD2D7.cust.dsl.vodafone.it) (Connection reset by peer)
[23:20:13] <alexanderkyte> Maybe the build system needs some wildcards for triplets, since I've only ever seen the triplets that are enumerated on debian
[23:20:16] <ChrisMorgan> (Or, if you're lazy, you could just continue to use Luqman's builds.)
[23:20:22] <alexanderkyte> besides the darwin stuff
[23:20:55] <ChrisMorgan> mk/platform.mk is where most or all of the changes will need to be made.
[23:20:58] *** Joins: twi (Adium@moz-A61BD2D7.cust.dsl.vodafone.it)
[23:21:11] <ChrisMorgan> Copy the arm-unknown-linux-gnueabihf block, I guess.
[23:21:34] <alexanderkyte> I'll probably just be lazy. I'm not gonna be hacking on the compiler. And I had done that initially, but then it complained about llvm
[23:22:17] <alexanderkyte> Just said that the compiler could not produce executables, mentioned llvm without details. Also no errors were seen beforehand.
[23:23:20] *** Joins: wtw (wtw@moz-D8FB7390.org)
[23:23:56] * ChrisMorgan uses an arm-unknown-linux-gnueabihf build on his tablet which certainly doesn't have enough memory to build rustc
[23:25:24] *** Quits: hacker_sam (hacker_sam@moz-64791626.dsl.bngr.epix.net) (Client exited)
[23:25:25] *** Joins: hacker_sam (hacker_sam@moz-64791626.dsl.bngr.epix.net)
[23:25:25] <ChrisMorgan> alexanderkyte: did you have LLVM installed?
[23:25:35] *** Quits: _Vi (vi@D7277DB6.6FF508C1.10C239DF.IP) (Ping timeout)
[23:25:36] <alexanderkyte> The samsung chromebook is, as far as I've seen, one of the better arm models. It's snappy. And yeah, I've got llvm installed. 
[23:25:46] *** Quits: b (b@moz-55CA322E.org) (Ping timeout)
[23:25:51] *** Joins: _Vi (vi@D7277DB6.6FF508C1.10C239DF.IP)
[23:28:19] * ChrisMorgan doesn't know what the problem would be, then.
[23:28:59] *** Joins: wilmoore (wilmoore@moz-71431C3A.hsd1.co.comcast.net)
[23:29:07] *** Quits: twi (Adium@moz-A61BD2D7.cust.dsl.vodafone.it) (Ping timeout)
[23:29:08] *** Joins: b (b@moz-55CA322E.org)
[23:29:24] *** Quits: KindOne (KindOne@543C9E64.D40F8E6E.EC6A1518.IP) (Ping timeout)
[23:29:36] *** Joins: twi (Adium@moz-A61BD2D7.cust.dsl.vodafone.it)
[23:29:47] *** Quits: twi (Adium@moz-A61BD2D7.cust.dsl.vodafone.it) (Max SendQ exceeded)
[23:30:14] *** Quits: nattofriends (tsutsumi@moz-A9E340E1.fuqu.jp) (Ping timeout)
[23:30:44] *** Joins: twi (Adium@moz-A61BD2D7.cust.dsl.vodafone.it)
[23:31:47] <alexanderkyte> I got configure: exit 77 as the only thing that looks fishy in config.log
[23:33:03] *** Joins: KindOne (KindOne@moz-F09DDAAC.dynamic.ip.windstream.net)
[23:33:38] *** Joins: nattofriends (tsutsumi@moz-A9E340E1.fuqu.jp)
[23:35:46] *** Quits: nrc (ncameron@moz-A76F1825.cable.virginm.net) (Ping timeout)
[23:35:59] *** Quits: twi (Adium@moz-A61BD2D7.cust.dsl.vodafone.it) (Connection reset by peer)
[23:36:26] *** Joins: twi (Adium@moz-A61BD2D7.cust.dsl.vodafone.it)
[23:39:33] *** Quits: Blei (philipp@moz-B2F9E4BD.cust.bluewin.ch) (Quit: WeeChat 0.4.2)
[23:40:10] *** Quits: io2 (io2@moz-34E8FDD4.home.otenet.gr) (Ping timeout)
[23:40:22] *** Quits: mentero (mentero@moz-D61C6F02.proxnet.pl) (Quit: WeeChat 0.4.2)
[23:43:26] <ercxx> acrichto: Did you just add multicast stuff to udp?
[23:43:38] <cmr> ercxx: yeah it's in the native PR
[23:43:59] *** Joins: brianm (brianm@moz-8161EF8D.hsd1.ca.comcast.net)
[23:44:05] *** Joins: kori (kori@277F74F6.F9CCD00F.EF49E5F2.IP)
[23:44:21] <ercxx> So that's why I can't read from 239.255.255.250:1900 yet right?
[23:44:39] <acrichto> ercxx: native UDP doesn't work at all right now
[23:44:49] <acrichto> ercxx: if it doesn't work with green UDP then that's a bug we should fix
[23:45:02] <ercxx> I'm using strcat's version
[23:45:19] <acrichto> dunno what that is
[23:45:23] <ercxx> So I don't have the latest stuff you added.
[23:45:29] <cmr> the arch package
[23:45:33] <cmr> ercxx: it hasn't landed yet.
[23:45:50] <ercxx> I see.
[23:46:17] *** Quits: FrozenCow (FrozenCow@moz-B2DF4929.chello.nl) (Client exited)
[23:47:00] <ercxx> what is green btw?
[23:47:14] <acrichto> M:N vs 1:1 (green == M:N, native == 1:1)
[23:47:27] <acrichto> or at least that's what I've been calling it, not sure if that's an official thing or not
[23:47:40] <acrichto> if you're using a working UDP today you're probably using the libuv implementation
[23:47:46] <acrichto> which *should* be working correctly
[23:48:21] <ercxx>  I  can't find a way to read from that ip:port
[23:48:35] <acrichto> my udp knowledge is pretty lacking :(
[23:48:40] <ercxx> so is mine :)
[23:49:11] <ercxx> but I am starting to believe there's bunch of functionality missing in the current version.
[23:49:31] <strcat> acrichto: UDP is just the networking version of throwing stuff at a wall and seeing what sticks ;p
[23:49:41] *** Quits: spider-mario (spidermari@moz-81131DB6.fbx.proxad.net) (Input/output error)
[23:49:52] <acrichto> strcat: what does it mean to enter/leave a multicast IP though?
[23:49:57] *** Quits: brianm (brianm@moz-8161EF8D.hsd1.ca.comcast.net) (Ping timeout)
[23:50:15] *** Quits: twi (Adium@moz-A61BD2D7.cust.dsl.vodafone.it) (Ping timeout)
[23:50:34] *** Joins: twi (Adium@moz-A61BD2D7.cust.dsl.vodafone.it)
[23:50:40] <ercxx> for udp I thought of a dog trying to catch million frisbees.
[23:50:51] <strcat> acrichto: *shrug*, I thought that was just like pub/sub streaming stuff
[23:50:59] <strcat> never used it, just normal UDP
[23:51:03] *** Quits: nano (nano@moz-ED77243C.superkabel.de) (Connection reset by peer)
[23:51:12] <acrichto> yeah that's the parts that I'm fuzzy about
[23:53:13] *** Joins: tulloch (tulloch@moz-F362C074.lnse2.pie.bigpond.net.au)
[23:53:18] *** Quits: samx (sami@moz-D9DA5773.dyn.optonline.net) (Quit: This computer has gone to sleep)
[23:55:08] *** Quits: tulloch (tulloch@moz-F362C074.lnse2.pie.bigpond.net.au) (Ping timeout)
[23:56:59] <eddyb> https://www.youtube.com/watch?v=CQbXevkR4us
[23:57:39] *** Quits: msch (msch@moz-DA0E34D4.clients.your-server.de) (Ping timeout)
[23:57:50] <eddyb> ^^ slightly relevant 30c3 talk
[23:57:50] *** Joins: msch (msch@moz-DA0E34D4.clients.your-server.de)
[23:58:12] <frau> any news on that 1:1 threading Linux perf work Google presented awhile ago?
[23:59:25] <eddyb> actually, more relevant than I thought. might want to mention on reddit :D

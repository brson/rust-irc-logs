[00:52:28] *** Quits: blank_name (blank_name@moz-mteiba.mi.frontiernet.net) (Quit: leaving)
[00:53:48] *** Joins: blank_name (blank_name@moz-mteiba.mi.frontiernet.net)
[01:15:49] *** Quits: reem (reem@moz-2icmmi.ca.comcast.net) (Connection closed)
[01:15:53] *** Joins: reem (reem@moz-2icmmi.ca.comcast.net)
[01:19:20] *** Quits: gleb (gleb@moz-3u1drv.rusanovka-net.kiev.ua) (Ping timeout: 121 seconds)
[01:32:14] *** Joins: brson (brson@moz-4s9.mg6.56.172.IP)
[01:32:14] *** ChanServ sets mode: +qo brson brson
[01:35:22] *** Quits: reem (reem@moz-2icmmi.ca.comcast.net) (Connection closed)
[01:37:25] *** Joins: reem (reem@moz-2icmmi.ca.comcast.net)
[02:08:09] <huon> aturon: acrichto: https://github.com/rust-lang/rust/pull/23539/files#r26814351
[02:08:55] <aturon> huon: hmmm, i do see your point
[02:09:02] <aturon> tbh it's hard to imagine this ever mattering :)
[02:09:45] <aturon> (i'm fine with either, personally; it's borderline)
[02:10:06] <huon> yeah, although people also thought 32-bit pointers were enough :P
[02:11:00] * reem agrees with huon
[02:21:44] <aturon> i mean, maybe i'm suffering from a lack of imagination, but isn't the width largely used for things that are in the end proportional to screen size, basically?
[02:23:32] *** Quits: reem (reem@moz-2icmmi.ca.comcast.net) (Connection closed)
[02:36:49] *** Joins: reem (reem@moz-2icmmi.ca.comcast.net)
[03:05:24] *** Quits: reem (reem@moz-2icmmi.ca.comcast.net) (Connection closed)
[03:21:55] *** Joins: reem (reem@moz-taob6g.coob.q2h1.0009.2601.IP)
[03:28:46] *** Joins: kimundi_ (kimundi@moz-vfagn5.dip0.t-ipconnect.de)
[03:31:49] *** Quits: kimundi (kimundi@moz-51c9op.dip0.t-ipconnect.de) (Ping timeout: 121 seconds)
[03:31:49] *** kimundi_ is now known as kimundi
[03:37:45] *** kimundi is now known as zz_kimundi
[03:44:36] *** zz_kimundi is now known as kimundi
[03:56:58] *** Quits: acharles (acharles@moz-nemm4b.fosshotel.is) (Client exited)
[03:57:36] *** Joins: acharles (acharles@moz-1pof4d.fosshotel.is)
[04:06:09] *** Quits: reem (reem@moz-taob6g.coob.q2h1.0009.2601.IP) (Connection closed)
[04:07:46] *** Joins: reem (reem@moz-2icmmi.ca.comcast.net)
[04:24:41] *** Quits: reem (reem@moz-2icmmi.ca.comcast.net) (Connection closed)
[04:37:11] *** Joins: reem (reem@moz-2icmmi.ca.comcast.net)
[04:40:03] *** Quits: reem (reem@moz-2icmmi.ca.comcast.net) (Connection closed)
[04:45:12] *** Joins: reem (reem@moz-2icmmi.ca.comcast.net)
[04:56:23] *** Quits: brson (brson@moz-4s9.mg6.56.172.IP) (Ping timeout: 121 seconds)
[05:00:05] *** Quits: reem (reem@moz-2icmmi.ca.comcast.net) (Connection closed)
[05:00:47] *** Joins: reem (reem@moz-2icmmi.ca.comcast.net)
[05:00:47] *** Quits: reem (reem@moz-2icmmi.ca.comcast.net) (Connection closed)
[05:00:48] *** Joins: reem (reem@moz-2icmmi.ca.comcast.net)
[06:28:33] *** Quits: Gankro (uid71432@moz-sc2bd6.charlton.irccloud.com) (Quit: Connection closed for inactivity)
[07:46:25] *** Joins: pnkfelix (pnkfelix@moz-eljppb.fbx.proxad.net)
[07:46:25] *** ChanServ sets mode: +o pnkfelix
[09:00:38] *** Joins: mw (mw@moz-f1s7jp.vie.surfer.at)
[09:50:37] *** Parts: mw (mw@moz-f1s7jp.vie.surfer.at) ("")
[09:59:19] *** Quits: nrc (nrc@moz-4bhi2i.xtra.co.nz) (Ping timeout: 121 seconds)
[09:59:44] *** Quits: reem (reem@moz-2icmmi.ca.comcast.net) (Connection closed)
[11:27:18] *** Joins: simukis (nagisa@moz-8t068g.static.zebra.lt)
[12:06:33] *** Joins: mw (mw@moz-f1s7jp.vie.surfer.at)
[12:22:32] *** Quits: mw (mw@moz-f1s7jp.vie.surfer.at) (Ping timeout: 121 seconds)
[12:31:38] *** Joins: mw (mw@moz-f1s7jp.vie.surfer.at)
[13:00:09] *** Joins: reem (reem@moz-2icmmi.ca.comcast.net)
[13:04:31] *** Quits: reem (reem@moz-2icmmi.ca.comcast.net) (Ping timeout: 121 seconds)
[13:20:36] *** Joins: gleb (gleb@moz-3u1drv.rusanovka-net.kiev.ua)
[13:55:20] *** Joins: joel2 (joel@moz-6ampnk.gtri.gatech.edu)
[14:05:43] *** Joins: sigma (sigma@moz-ohog4c.range86-135.btcentralplus.com)
[14:12:39] *** Quits: pnkfelix (pnkfelix@moz-eljppb.fbx.proxad.net) (Quit: rcirc on GNU Emacs 24.3.92.1)
[14:45:14] *** Joins: pnkfelix (pnkfelix@moz-je0.a5j.80.81.IP)
[14:45:14] *** ChanServ sets mode: +o pnkfelix
[15:03:32] *** Parts: mw (mw@moz-f1s7jp.vie.surfer.at) ("")
[16:51:54] *** Joins: brson (brson@moz-cfhap5.mtv2.mozilla.com)
[16:51:54] *** ChanServ sets mode: +qo brson brson
[17:48:17] *** Quits: pnkfelix (pnkfelix@moz-je0.a5j.80.81.IP) (Connection closed)
[17:48:28] *** Joins: pnkfelix (pnkfelix@moz-je0.a5j.80.81.IP)
[17:48:28] *** ChanServ sets mode: +o pnkfelix
[18:29:08] *** Quits: pnkfelix (pnkfelix@moz-je0.a5j.80.81.IP) (Ping timeout: 121 seconds)
[18:39:33] *** Quits: freebroccolo (sid51271@moz-pof.lg2.184.192.IP) (Ping timeout: 121 seconds)
[18:47:26] *** Joins: Rym (y@moz-cfe.mso.205.31.IP)
[18:53:57] *** Quits: sigma (sigma@moz-ohog4c.range86-135.btcentralplus.com) (Ping timeout: 121 seconds)
[19:10:32] *** Joins: Gankro (uid71432@moz-sc2bd6.charlton.irccloud.com)
[19:43:42] *** Joins: reem (reem@moz-uaj066.coob.q2h1.0009.2601.IP)
[19:46:34] <nmatsakis> aturon: oh, that reminds me. I made this branch that just has the compielr abort when an overflow occurs (today, we propagate it using Result<>); I was afraid it might be getting dropped...
[19:46:57] <nmatsakis> ...and sure enough, I found that kimundi's impl pattern for &T where T : Deref impl triggered a hidden overflow
[19:47:07] <aturon> ha!
[19:47:08] <nmatsakis> so I'm going to prepare a PR to remove it, I think it's a hazard in various ways 
[19:47:13] <aturon> yep
[19:47:17] <nmatsakis> also to fix that overflow handling
[19:47:20] <aturon> concrete impls for it seems fine
[19:47:28] <nmatsakis> anyway, yeah I added an impl for &String and &&str I think ;)
[19:47:33] <nmatsakis> kind of hokey but it seems to cover the cases that actually occur
[19:47:45] <nmatsakis> annoyingly both the concrete impls
[19:47:48] <nmatsakis> and the blanket impl
[19:47:58] <nmatsakis> all violate the proposed stricter coherence rules i was investigating for #23086
[19:48:02] <nmatsakis> ;)
[19:48:08] <aturon> ha you just can't win
[19:48:12] <nmatsakis> yes
[19:49:33] <sfackler> nmatsakis: the iteratorext removal seems to be good to go with that last fix, thanks!
[19:50:16] <nmatsakis> sfackler: great:)
[19:53:57] *** Quits: reem (reem@moz-uaj066.coob.q2h1.0009.2601.IP) (Connection closed)
[19:58:25] *** Joins: reem (reem@moz-2icmmi.ca.comcast.net)
[20:20:55] <nmatsakis> aturon: so if make idnexing by value
[20:21:08] <nmatsakis> aturon: should we adjust the impl for HashMap etc to be implemented on &K, or just consume the K
[20:21:24] <nmatsakis> the latter would be more convenient in some way but...
[20:21:41] <nmatsakis> ...maybe not what we want?
[20:23:18] <aturon> nmatsakis: is it feasible to provide both?
[20:23:19] *** Joins: freebroccolo (sid51271@moz-ealde0.ealing.irccloud.com)
[20:23:39] <aturon> we definitely want &K to at least be an option
[20:23:45] <nmatsakis> I guess it is, yes
[20:23:46] <aturon> so that you can look up with string literals, for example
[20:23:58] <aturon> (even if your hashmap owns Strings)
[20:28:29] <nmatsakis> aturon: same for VecMap I guess? (both usize and &usize?)
[20:28:53] <aturon> for ones that take fixed, Copy types i think by-value only is fine
[20:29:04] <aturon> (in the future we may want to add by-ref for some Map trait, but we don't have that yet)
[20:29:12] <aturon> nmatsakis: ^
[20:29:22] <nmatsakis> k
[20:29:26] <nmatsakis> it's hard to imagine anyone wanting to write
[20:29:28] <nmatsakis> x[&22]
[20:30:05] <aturon> indeed
[20:33:01] <nmatsakis> aturon: hmm, impl both could be hard with (you guessed it) coherence
[20:33:29] <nmatsakis> in particular, you wind up with IndexMut<K> and IndexMut<&Q>
[20:33:44] <aturon> ok, in that case,
[20:33:50] <aturon> use by-ref for generic maps,
[20:33:52] <nmatsakis> where K: Borrow<Q>
[20:33:55] <aturon> by-val for concrete + Copy
[20:33:59] <aturon> (imo)
[20:34:34] <aturon> (this would be one place where some negative impl decls woudl be nice)
[20:34:49] <nmatsakis> aturon: on the plus side,
[20:35:00] <nmatsakis> this means that foo[k] and foo.get(k) will be consistent
[20:35:12] <nmatsakis> though I know that would have been true before
[20:35:18] <nmatsakis> though not for concrete+Copy maps
[20:35:22] <nmatsakis> it seems
[20:35:33] <nmatsakis> in that particular case we could support both I guess
[20:35:42] <aturon> yeah, and having to write my_vec[&3] seems like a bad regression :)
[20:40:01] *** Joins: nrc (nrc@moz-4bhi2i.xtra.co.nz)
[20:40:01] *** ChanServ sets mode: +qo nrc nrc
[21:00:15] *** Quits: joel2 (joel@moz-6ampnk.gtri.gatech.edu) (Ping timeout: 121 seconds)
[21:01:42] <Gankro> nmatsakis: It seems like auto-ref could just be taught to "only run if necessary"?
[21:02:23] <nmatsakis> Gankro: context?
[21:02:44] <Gankro> foo[x] vs foo[ref_to_x]
[21:03:20] <Gankro> Seems plausible to just do "does foo[y] check? If so, good; if not, add a ref (do not recurse)"
[21:03:24] <nmatsakis> Gankro: maybe; it can be hard with all the inference going on, particularly given that there are multiple Index impls for many types
[21:03:56] <nmatsakis> sometimes we don't know what the type of `y` is
[21:04:01] <nmatsakis> so we can't say if it checks or not
[21:04:01] <Gankro> nmatsakis: It doubt it would cause a problem in practice, but maybe I lack imagination
[21:04:07] <Gankro> ah
[21:04:11] <nmatsakis> oh, it will
[21:04:27] <nmatsakis> well, I don't know that for sure, I don't know how often
[21:04:39] <nmatsakis> I just know i'm spending a lot of time right now trying to cleanup a+b
[21:04:43] *** Joins: japaric (japaric@moz-67j.bii.230.201.IP)
[21:04:49] <nmatsakis> which had too much hardcoded logic in it from the old days when it was not overridable
[21:04:54] <nmatsakis> and dealing with weird inference failures aplenty
[21:04:59] <nmatsakis> involving things like foo[sub-1]
[21:05:05] *** Quits: acharles (acharles@moz-1pof4d.fosshotel.is) (Client exited)
[21:05:06] <nmatsakis> where we don't what type 1 has (yet)
[21:05:10] <nmatsakis> and have to trace all the interactions
[21:05:13] <nmatsakis> and it's a royal pain :)
[21:05:22] <nmatsakis> so you might be surprised how little the compiler knows sometimes...
[21:05:37] <nmatsakis> in any case, I'd say we can consider "optional-autoref" for index later, 
[21:05:42] <Gankro> nmatsakis: I think indexing is different. It's reasonable to have a custom impl for self + &self vs &self + &self; but [&T] and [T] seems odd
[21:05:43] <nmatsakis> despite what I just said,
[21:05:47] <nmatsakis> I'd like to do it :)
[21:05:49] <nmatsakis> also for + and -
[21:06:27] <nmatsakis> Gankro: (there are often range impls too, but yes that may be)
[21:06:34] <Gankro> But this is purely from a user perspective. I'm sure the compiler details are a nightmarish hellscape :)
[21:07:12] * Gankro rues the day he becomes confident/motivated enough to try to earnestly fix compiler bugs
[21:07:20] <Gankro> So much comeupance will be had that day
[21:09:39] *** Joins: acharles (acharles@moz-1pof4d.fosshotel.is)
[21:10:36] <Gankro> nmatsakis: Just need to implement unary `+` and `-` as valid integer literals and you can hack in ++ and -- :P
[21:10:51] <nmatsakis> :) I'd be happy with 4.inc()
[22:03:31] *** Quits: brson (brson@moz-cfhap5.mtv2.mozilla.com) (Quit: leaving)
[22:12:43] *** Quits: reem (reem@moz-2icmmi.ca.comcast.net) (Connection closed)
[22:13:13] *** Joins: reem (reem@moz-2icmmi.ca.comcast.net)
[22:35:52] *** japaric is now known as japaric|afk
[23:59:06] *** Joins: brson (brson@moz-prn.c9m.56.172.IP)
[23:59:06] *** ChanServ sets mode: +qo brson brson

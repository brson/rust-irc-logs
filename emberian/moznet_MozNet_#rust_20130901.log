[00:00:34] <engla> more hard questions, should it apply to &str? because using the wrong indices is an error
[00:00:51] <cmr> hm
[00:01:06] <engla> and it's ok to index the str at any index but not to slice it from or to any index
[00:01:36] <kimundi> I think it would be okay
[00:01:51] <kimundi> index converts to an u8, slice keeps it as an &str
[00:02:11] <kimundi> so of course it must hold the utf8 invariant
[00:05:59] <engla> I guess it's ok
[00:06:52] <tikue_> rusti: true ? 1:0
[00:06:52] -rusti- <anon>:5:14: 5:15 error: unknown start of token: ?
[00:06:52] -rusti- <anon>:5          true ? 1:0
[00:06:53] -rusti-                        ^
[00:06:53] -rusti- application terminated with error code 101
[00:07:02] *** Quits: stepancheg (Mibbit@moz-678E3090.yandex.net) (Quit: http://www.mibbit.com ajax IRC Client)
[00:07:19] <tikue_> rusti: 1 if true else 0
[00:07:20] -rusti- <anon>:5:11: 5:13 error: expected one of `; }` but found `if`
[00:07:20] -rusti- <anon>:5          1 if true else 0
[00:07:20] -rusti-                     ^~
[00:07:20] -rusti- application terminated with error code 101
[00:07:29] <cmr> rusti: if true { 1 } else { 0 }
[00:07:30] -rusti- 1
[00:07:44] <tikue_> braces :P
[00:08:09] * tikue_ can't get enough syntactic sugar
[00:08:31] <bblum> make sure you brush your syntactic teeth after all that sugar
[00:09:56] <tikue_> do go tasks silently fail?
[00:10:22] * tikue_ is trying to figure out how http://play.golang.org/p/cVYOLm12mw works without causing task failure when main() exits
[00:11:31] *** Quits: pepper_chico (pepper_chi@EF476D4E.D3DE4871.E4090502.IP) (Quit: My MacBook Pro has gone to sleep. ZZZzzzâ€¦)
[00:18:27] *** Joins: z0w0 (zack@moz-30F36A45.qld.bigpond.net.au)
[00:20:48] *** Quits: robarnold (rob@BD56354E.DB510C09.6E370BFC.IP) (Ping timeout)
[00:21:18] <tikue_> oh. duh.
[00:21:32] <tikue_> it's because a channel sends and receives with the same object
[00:21:38] <tikue_> so it doesn't go out of scope until the sender exits
[00:21:42] *** Joins: pepper_chico (pepper_chi@EF476D4E.D3DE4871.E4090502.IP)
[00:23:41] <maik> do we have a rust text parsing lib?
[00:23:57] <cmr> not a recent one no
[00:24:52] <tikue_> if the closure to spawn is a single function, what's the most idiomatic way to write it?
[00:24:56] <tikue_> do spawn { fun() }
[00:25:01] <tikue_> spawn(|| fun())
[00:25:07] <cmr> spawn(fun) ?
[00:25:15] <tikue_> cmr: â€¦oh yeah :)
[00:25:15] <cmr> Although I think spawn takes a ~fn
[00:25:27] <cmr> So you might need || fun()
[00:25:29] <tikue_> cmr: sorry there's an argument to fun
[00:25:51] <tikue_> you like spawn(|| fun(foo)) better than do spawn { fun(foo) } ?
[00:26:03] <cmr> I prefer the second but it's quite subjective.
[00:26:16] <tikue_> i dunno
[00:26:24] <tikue_> this should be in the style guide :P 
[00:26:50] <tikue_> or what about the third option
[00:26:52] <tikue_> do spawn {
[00:26:55] <tikue_> 	fun(foo)
[00:26:55] <tikue_> }
[00:29:04] <tikue_> bblum: https://gist.github.com/tikue/669b69e167d449550554 thoughts?
[00:29:30] *** Joins: kgriffs (Adium@moz-7E0D846A.aus1.rackspace.com)
[00:30:08] <engla> what about iterators for IO/Reader, was someone working on that? I have some ideas but mostly questions
[00:30:21] <cmr> engla: I don't think so
[00:30:43] *** Joins: ghrust (ghrust@24260B07.6A2AE50.F3114085.IP)
[00:30:43] <ghrust> 01[13rust01] 15bors merged 06auto into 06master: 02http://git.io/XWV1ag
[00:30:43] *** Parts: ghrust (ghrust@24260B07.6A2AE50.F3114085.IP) ()
[00:31:10] *** Quits: kgriffs (Adium@moz-7E0D846A.aus1.rackspace.com) (Ping timeout)
[00:31:44] <engla> we can make a line iterator that yields lines as string slices, but we have to put the buffer on the stack and give it to the iterator
[00:31:47] <engla> that's inelegant
[00:33:26] *** Joins: samx (sami@moz-D9DA5773.dyn.optonline.net)
[00:34:58] *** Quits: gavinb (gavinb@moz-9EC182F0.lowrp3.vic.optusnet.com.au) (Quit: gavinb)
[00:35:40] *** Joins: ghrust (ghrust@2EE61FCC.6A2AE50.F3114085.IP)
[00:35:40] <ghrust> 01[13rust01] 15bors pushed 0 new commits to 06auto: 02http://git.io/tm5Yyg
[00:35:40] *** Parts: ghrust (ghrust@2EE61FCC.6A2AE50.F3114085.IP) ()
[00:35:43] *** Joins: ghrust (ghrust@1E8607E8.6A2AE50.F3114085.IP)
[00:35:43] <ghrust> 01[13rust01] 15bors pushed 3 new commits to 06auto: 02http://git.io/BrEiFw
[00:35:43] <ghrust> 13rust/06auto 14f61713a 15Felix S. Klock II: hypothetical fix for #8865.
[00:35:44] <ghrust> 13rust/06auto 14b1a2251 15Felix S. Klock II: small cleanup of previous commit with mucho comments.
[00:35:44] <ghrust> 13rust/06auto 146178501 15bors: auto merge of #8907 : pnkfelix/rust/fsk-fix-makefile-8865, r=thestinger...
[00:35:46] *** Parts: ghrust (ghrust@1E8607E8.6A2AE50.F3114085.IP) ()
[00:41:07] *** Quits: samx (sami@moz-D9DA5773.dyn.optonline.net) (Quit: This computer has gone to sleep)
[00:42:40] *** Quits: maik (maik___@moz-A7524DA9.dip0.t-ipconnect.de) (Ping timeout)
[00:45:45] *** Joins: tavoe (Mibbit@moz-F85B6108.student.rit.edu)
[00:46:02] <cmr> "hypothetical fix" nice
[00:46:14] <myname> :D
[00:46:31] *** Joins: mihneadb (mihneadb@moz-329F29A3.lightspeed.sntcca.sbcglobal.net)
[00:47:16] *** Quits: mihneadb (mihneadb@moz-329F29A3.lightspeed.sntcca.sbcglobal.net) (Input/output error)
[00:48:06] <cmr> ttp://cmr.github.io/blog/2013/08/31/this-week-in-rust/
[00:48:08] <cmr> http://cmr.github.io/blog/2013/08/31/this-week-in-rust/
[00:48:21] <cmr> Someone mind posting that to reddit for me?
[00:49:03] <engla> I can do it
[00:49:15] *** Joins: youknowone (youknowone@A826BD81.8A0DEF81.38747683.IP)
[00:49:15] *** Quits: youknowone (youknowone@A826BD81.8A0DEF81.38747683.IP) (Z:lined (Open Proxy found on your host. Please visit www.blitzed.org/proxy?ip=115.68.131.49 for more information.))
[00:49:24] <engla> http://www.reddit.com/r/rust/comments/1lhq2k/this_week_in_rust_13/
[00:49:30] <cmr> thanks
[00:50:10] <tikue_> why is `be` reserved
[00:50:21] *** Quits: heftig (heftig@moz-84F5B0FB.dip0.t-ipconnect.de) (Ping timeout)
[00:50:29] <cmr> tikue_: for tail calls.
[00:50:37] <tikue_> cmr: how would it look?
[00:50:41] <cmr> Makes the stack frame `be`come something else
[00:50:43] <cmr> tikue_: be foo()
[00:50:58] <tikue_> oo
[00:51:14] <cmr> Hypothetical of course.
[00:51:15] <myname> huh?
[00:51:17] <toqueteos> uuhh keywords strike back...
[00:51:23] <cmr> I think it was once implemented
[00:51:30] <cmr> And might be again post-1.0
[00:51:35] <toqueteos> https://github.com/mozilla/rust/blob/master/doc/rust.md#keywords <- #3228 forgot something there
[00:51:35] <cmr> But it's still reserved just in case
[00:51:52] *** Joins: heftig (heftig@moz-1731F2A.dip0.t-ipconnect.de)
[00:52:04] <jmgrosen> rusti: 'h'.to_str()
[00:52:04] -rusti- <anon>:5:9: 6:5 error: type `char` does not implement any method in scope named `to_str`
[00:52:04] <cmr> I'm off to sleep, 'night all
[00:52:04] -rusti- <anon>:5          'h'.to_str()
[00:52:04] -rusti- <anon>:6     };
[00:52:04] -rusti- error: aborting due to previous error
[00:52:04] -rusti- application terminated with error code 101
[00:52:10] <tikue_> fn Fib(n: uint, total: uint) -> uint { if n == 0 { total } else {be Fib(n - 1, n * total)}
[00:52:12] <tikue_> like that?
[00:52:12] <toqueteos> by cmr, same here
[00:52:20] <cmr> tikue_: something like that yeah.
[00:52:47] <myname> that's not fib
[00:52:52] <myname> that's fac
[00:52:53] <jmgrosen> no ToStr for char? :(
[00:52:54] <tikue_> i named it wrong
[00:52:54] <tikue_> :)
[00:53:02] *** Joins: samx (sami@moz-D9DA5773.dyn.optonline.net)
[00:53:05] <tikue_> just to test you myname  :P
[00:53:05] <tiffany> how do you disambiguate enum values?
[00:53:07] *** Parts: toqueteos (Mibbit@moz-8FE22E20.dynamic.jazztel.es) ()
[00:53:25] <engla> cmr: I think this PR was reverted   std::run has been reimplemented on top of libuv.
[00:53:38] <engla> in PR #8866
[00:53:50] <tikue_> rusti: enum Foo { Bar, Baz } match Bar { Bar =>"it's bar", Baz => "it's baz", }
[00:53:51] -rusti- "it\'s bar"
[00:53:55] <bblum> tikue_: looks right; your send and recv should just be implemented in terms of try_send and try_recv; you're missing an assertion in your recv on the try_send call that will always succeed; and the constructor should be called new() as a static method
[00:54:12] <bblum> tikue_: oh, also, i might personally prefer to call it 'Rendezvous'
[00:54:49] <tikue_> bblum: thanks bblum. some questions
[00:54:55] <tikue_> bblum: new() would be a static method of what?
[00:55:24] <tiffany> that doesn't work if I have two enums providing the same name, tikue
[00:55:26] <bblum> oh, my mistake
[00:55:28] <bblum> it wouldn't
[00:55:32] *** Joins: maik (maik___@moz-A7524DA9.dip0.t-ipconnect.de)
[00:55:33] <bblum> it's just the same as stream()
[00:55:35] * bblum dum
[00:55:42] <tikue_> bblum: and when you say implemented in terms of try_send and try_recv, do you mean like match try_send() { None => fail!() }
[00:55:45] <tikue_> or something to that effect?
[00:56:17] <bblum> yea
[00:56:22] <bblum> use option::expect() of course
[00:56:31] <tikue_> ah yeah
[00:56:40] <tikue_> and where would the assertion go?
[00:57:23] <tikue_> bblum: and for send(), would it be assert!(try_send())
[00:57:58] <bblum> i mean in the recv implementation
[00:58:04] <bblum> there is a send that is guaranteed to succeed
[00:58:15] <tikue_> it's not though, is it?
[00:58:20] <bblum> why not?
[00:58:21] <bblum> for send, i mean, just compare against the same implementation in rt:comm
[00:58:29] <jmgrosen> why can't I "provide an extension implementation for a trait not defined in this crate"? is that just a design decision?
[00:58:47] *** Joins: mib_9uybip (mib_9uybip@moz-9B8221B3.rivrw1.nsw.optusnet.com.au)
[00:59:14] <tikue_> bblum: send is just try_send
[00:59:20] <tikue_> in rt::comm
[00:59:22] <engla> it's so you know you don't create two conflicting trait implementations for the same type jmgrosen 
[00:59:35] <tikue_> and it can fail if the message is sent, and then the task with the chan fails before the port sends its ack
[00:59:49] <engla> jmgrosen: and it's a locally checkable property
[00:59:59] <jmgrosen> engla: oh, I guess that makes sense; so there's no way to get around it?
[01:00:06] <bblum> tikue_: oh that's right
[01:00:15] <bblum> send ignores, it doesn't assert, on trysend
[01:00:40] <tikue_> bblum: oh i see. why is that? that's not what chan does in std::comm
[01:00:57] <tikue_> oh wait
[01:01:17] *** Quits: mib_9uybip (mib_9uybip@moz-9B8221B3.rivrw1.nsw.optusnet.com.au) (Ping timeout)
[01:01:46] <tikue_> i see. ok. but wouldn't the duplex stream's send already ignore it?
[01:01:50] <engla> jmgrosen: I don't think there is a way to disable that check. You can implement the trait on a wrapper type
[01:03:14] <bblum> tikue_: what you currently have there is wrong; what happens if the  self.duplex_stream.send(val); on line 31 "would have" returned false?
[01:03:41] <tikue_> bblum: it fails
[01:03:55] <bblum> hmm
[01:04:00] <bblum> actually that is right
[01:04:02] <bblum> it should fail :P
[01:04:21] <bblum> but it will fail with an error message that your library doesn't control
[01:04:25] <tikue_> right
[01:04:26] <tikue_> so how about
[01:04:41] <tikue_> assert!(self.try_send, "we failed :-(")
[01:04:45] <bblum> yep
[01:04:46] <tikue_> (with a better msg)
[01:05:21] <tikue_> rusti: assert!(false, ":-("); 0u
[01:05:22] -rusti- task <unnamed> failed at ':-(', <anon>:5
[01:05:22] -rusti- application terminated with error code 101
[01:05:37] <jmgrosen> engla: ugly, but works -- thanks
[01:06:12] <bblum> hey, i didn't even know our assert macro could do that
[01:06:28] <bblum> rusti: assert!(false, "%s", "hello"); 0u
[01:06:29] -rusti- task <unnamed> failed at 'hello', <anon>:5
[01:06:29] -rusti- application terminated with error code 101
[01:06:35] <bblum> nice it even formats
[01:06:49] <engla> nice
[01:06:54] *** Quits: jmgrosen (jmgrosen@moz-848F6087.sb.sd.cox.net) (Quit: jmgrosen)
[01:08:04] <bblum> 10 internet points to whoever did that
[01:08:14] *** Joins: ajl (Mibbit@moz-F85B6108.student.rit.edu)
[01:08:26] *** Quits: ajl (Mibbit@moz-F85B6108.student.rit.edu) (Quit: http://www.mibbit.com ajax IRC Client)
[01:08:43] <tikue_> bblum: thanks a lot for your help. https://gist.github.com/tikue/669b69e167d449550554 does this look right? also do you think this is something worthy of inclusion in extra::comm
[01:08:55] <tiffany> is there no way to do this, and I'm going to have to prefix all my enum types, then?
[01:09:40] <tikue_> tiffany: mmm
[01:09:45] *** Joins: miza (miza@moz-4DD51325.home.otenet.gr)
[01:09:56] <tikue_> rusti: enum Foo { Bar, Baz } enum Foo2 { Bar, Baz }
[01:09:58] -rusti- pastebinned 14 lines of output: http://ix.io/7K3
[01:10:11] <bblum> tikue_: definitely it could be in extra::comm
[01:10:49] <tiffany> ah
[01:10:52] <tiffany> I figured it out
[01:10:58] <bblum> tikue_: your failure messages should say the name of the method, "SyncPort recv(): sending channel closed" e.g.
[01:10:58] <tikue_> bblum: what is rust's PR process? do i just fork and put in the pr?
[01:11:04] <tikue_> bblum: ok cool thanks
[01:11:06] <bblum> and your test cases are noncomprehensive :P
[01:11:08] <tiffany> the values declared inside of an enum are in the scope of the module
[01:11:12] <tikue_> bblum: :P true
[01:11:17] <bblum> but yeah, just github fork and make a pr
[01:12:17] <tikue_> bblum: how do I know when my test cases are comprehensive lol
[01:12:25] *** Joins: carleastlund (cce@moz-C8071335.c3-0.smr-ubr1.sbo-smr.ma.cable.rcn.com)
[01:13:00] <bblum> tikue_: well, you think of every corner case we discussed, and then come up with a program that will exerecise the associated code path
[01:13:35] <tikue_> hmmm
[01:14:07] <tikue_> bblum: why are there no test cases in std::comm
[01:14:12] <bblum> obviously making sure your tests are *truly* comprehensive of every important behaviour is... an open research project
[01:14:16] <tikue_> lol
[01:14:22] <bblum> tikue_: good question, are they in std::rt::comm?
[01:14:27] <tikue_> bblum: yes they are
[01:15:08] <engla> tikue_: your current test doesn't compile right?
[01:15:29] <tikue_> engla: i don't know. how do i make tests compile or run?
[01:15:36] <engla> rust --test  filename.rs
[01:15:44] <engla> no. rust test filename.rs
[01:17:00] *** Quits: pepper_chico (pepper_chi@EF476D4E.D3DE4871.E4090502.IP) (Quit: My MacBook Pro has gone to sleep. ZZZzzzâ€¦)
[01:17:01] <tikue_> engla: you are correct. it doesn't compile
[01:17:11] <tikue_> also, what do i do about ::extra?
[01:17:20] <tikue_> i don't put extern mod extra in this file right?
[01:17:49] <engla> you can do that while you are testing
[01:17:53] <tikue_> ok
[01:19:08] <tikue_> engla: how did you know it wouldn't compile
[01:19:32] <tikue_> rusti: ~"123" == "123"
[01:19:32] -rusti- <anon>:5:19: 5:24 error: mismatched types: expected `~str` but found `&'static str` (str storage differs: expected ~ but found &'static )
[01:19:33] -rusti- <anon>:5          ~"123" == "123"
[01:19:33] -rusti-                             ^~~~~
[01:19:33] -rusti- error: aborting due to previous error
[01:19:33] -rusti- application terminated with error code 101
[01:19:44] <tikue_> rusti: "123" == ~"123"
[01:19:45] -rusti- <anon>:5:18: 5:24 warning: unnecessary allocation, the sigil can be removed [-W unnecessary-allocation (default)]
[01:19:45] -rusti- <anon>:5          "123" == ~"123"
[01:19:45] -rusti-                            ^~~~~~
[01:19:45] -rusti- true
[01:20:42] *** Quits: saati (bjb@moz-11469F61.harmless.hu) (Ping timeout)
[01:20:51] <tikue_> i'm very confused about "extern mod extra"
[01:21:21] *** Joins: strcat (strcat@moz-54F7FD49.cpe.net.cable.rogers.com)
[01:21:34] <Eridius> tikue_: `extern mod extra` is basically the Rust equivalent to -lextra
[01:21:36] *** Quits: q66 (q66@6EE9DE40.46454B5D.33AABD5F.IP) (Quit: Leaving)
[01:21:57] <tikue_> Eridius: where do I put it though? in the library module that uses it?
[01:22:07] <Eridius> tikue_: in the root module of your crate
[01:22:08] <tikue_> Eridius: or do I leave it out and require the user to put that line in their file to use my module?
[01:24:08] <Eridius> I wish our macro_rules allowed for matching against a literal instead of just an expr
[01:26:43] <Eridius> rusti: fmt!("%#s", "foo")
[01:26:43] -rusti- <anon>:5:14: 5:19 error: internal compiler error: unimplemented conversion not supported in fmt! string
[01:26:43] -rusti- <anon>:5          fmt!("%#s", "foo")
[01:26:43] -rusti-                        ^~~~~
[01:26:43] -rusti- application terminated with error code 101
[01:26:50] *** Joins: inf-groupoid (user@580120F5.8ED93E28.1C8C8CE9.IP)
[01:28:37] *** Joins: jmgrosen (jmgrosen@moz-848F6087.sb.sd.cox.net)
[01:29:56] *** Joins: kgriffs (Adium@moz-7E0D846A.aus1.rackspace.com)
[01:30:01] <tikue_> how does SharedPort work
[01:30:10] <tikue_> is the msg received on each SharedPort
[01:30:14] <tikue_> or is it first come first served
[01:30:26] *** Joins: mib_9uybip (mib_9uybip@moz-9B8221B3.rivrw1.nsw.optusnet.com.au)
[01:30:36] <engla> tikue_: your test module has to import (with "use") the functions from the parent mod
[01:30:40] *** Joins: maxli (maxli@moz-6EADA619.cpe.net.cable.rogers.com)
[01:30:45] <engla> that was how
[01:30:52] *** Quits: maik (maik___@moz-A7524DA9.dip0.t-ipconnect.de) (Ping timeout)
[01:31:17] <tikue_> ooh ok
[01:31:36] *** Quits: kgriffs (Adium@moz-7E0D846A.aus1.rackspace.com) (Ping timeout)
[01:31:47] <tikue_> bblum: megapipe ==> ScatterStream?
[01:31:57] <tikue_> unless i misunderstand what SharedPort does
[01:34:36] *** Quits: mib_9uybip (mib_9uybip@moz-9B8221B3.rivrw1.nsw.optusnet.com.au) (Ping timeout)
[01:35:00] *** Joins: cubic (cubic@moz-FE5AD6C7.mc.videotron.ca)
[01:35:48] <tikue_> rusti: do spawn_unlinked { () }
[01:35:48] -rusti- <anon>:5:12: 5:26 error: unresolved name `spawn_unlinked`.
[01:35:48] -rusti- <anon>:5          do spawn_unlinked { () }
[01:35:48] -rusti-                      ^~~~~~~~~~~~~~
[01:35:48] -rusti- error: aborting due to previous error
[01:35:49] -rusti- application terminated with error code 101
[01:36:04] <tikue_> rusti: do ::std::comm::spawn_unlinked { () }
[01:36:04] -rusti- <anon>:5:12: 5:39 error: unresolved name `std::comm::spawn_unlinked`.
[01:36:04] -rusti- <anon>:5          do ::std::comm::spawn_unlinked { () }
[01:36:04] -rusti-                      ^~~~~~~~~~~~~~~~~~~~~~~~~~~
[01:36:04] -rusti- error: aborting due to previous error
[01:36:05] -rusti- application terminated with error code 101
[01:36:12] <tikue_> wat
[01:36:13] <tikue_> oh
[01:36:19] <tikue_> rusti: do ::std::task::spawn_unlinked { () }
[01:36:19] *** Joins: pepper_chico (pepper_chi@EF476D4E.D3DE4871.E4090502.IP)
[01:36:19] -rusti- ()
[01:37:03] *** Quits: maxli (maxli@moz-6EADA619.cpe.net.cable.rogers.com) (Quit: Leaving.)
[01:37:13] *** Joins: drumond19 (drumond19@261AEED1.7D019E6E.8DF84892.IP)
[01:38:13] *** Joins: dew1 (Instantbir@moz-D2FA52B6.static.stls.mo.charter.com)
[01:39:22] *** Quits: dew (Instantbir@moz-D2FA52B6.static.stls.mo.charter.com) (Ping timeout)
[01:40:41] *** Joins: ghrust (ghrust@F6EE6DE3.6A2AE50.F3114085.IP)
[01:40:41] <ghrust> 01[13rust01] 15bors merged 06auto into 06master: 02http://git.io/BrEiFw
[01:40:41] *** Parts: ghrust (ghrust@F6EE6DE3.6A2AE50.F3114085.IP) ()
[01:41:38] <Eridius> does #[inline] affect how likely a function is to be inlined into other functions in the same crate?
[01:41:48] <Eridius> or is it purely for cross-crate inlining?
[01:43:18] <tikue_> bblum: how do you indicate #[test(should_fail)]
[01:43:22] <Eridius> #[should_fail]
[01:43:39] <tikue_> thx :)
[01:43:54] <tikue_> so #[test] #[should_fail] ?
[01:43:56] <Eridius> yes
[01:43:59] <tikue_> great thank you
[01:46:15] <zalzane> you know what i really look forward to with rust
[01:46:26] <zalzane> naming projects after materials science tidbits that have to do with oxidation
[01:46:39] <zalzane> i hope im not  the only person who feels this way
[01:46:44] *** Quits: miza (miza@moz-4DD51325.home.otenet.gr) (Input/output error)
[01:47:07] *** Joins: maik (maik___@moz-A7524DA9.dip0.t-ipconnect.de)
[01:48:20] <tikue_> bblum: you mentioned calling it Rendezvous, what were you referring to? just my documentation? or instead of sync_stream?
[01:48:30] <tikue_> like let (port, chan) = rendezvous()
[01:51:36] <bblum> #[test] #[should_fail] #[ignore(cfg(windows))]
[01:51:39] <bblum> yeah instead of sync_stream
[01:52:04] <tikue_> what's that third one?
[01:52:12] <bblum> it disables the test on windows
[01:52:18] <bblum> because windows can't fail or it aborts
[01:52:20] <tikue_> ah ok
[01:52:20] <Eridius> bblum: what's the difference between that and #[cfg(not(windows))]?
[01:52:28] <Eridius> also I thought windows now had stack unwinding
[01:52:29] <bblum> Eridius: none i think
[01:52:33] <bblum> i think it does have unwinding
[01:52:34] <bblum> but
[01:52:38] <bblum> not sure if that means the tests are safe
[01:52:44] <bblum> tikue_: rendezvous is the name of basically this exact same sync primitive, from plan 9
[01:52:45] <Eridius> I know the #[test] #[should_fail] tests I looked at before didn't exclude windows
[01:52:46] *** Joins: hellmage (luyun@BA8B278D.4627311A.77EF871E.IP)
[01:53:23] <bblum> well, that means it's probably fine!
[01:53:50] *** Quits: KindOne (KindOne@EC51CE2D.E114B4AE.EC6A1518.IP) (Ping timeout)
[01:54:10] <tikue_> haha ok 
[01:54:15] <tikue_> i'm gonna go with rendezvous then, cuz it's more badass
[01:54:34] *** Joins: KindOne (KindOne@EC51CE2D.E114B4AE.EC6A1518.IP)
[01:54:53] <bblum> exactly :D
[01:55:10] <bblum> i applaud your style
[01:55:15] <tikue_> : D
[01:57:10] *** Quits: jeaye (Jeaye@moz-FD505E54.hsd1.ca.comcast.net) (Quit: Don't tell them I was here...)
[02:00:04] *** Quits: vosen (vosen@moz-266BA656.icpnet.pl) (Connection reset by peer)
[02:01:24] *** Quits: int3_ (int3_@moz-ABE52D50.hsd1.ca.comcast.net) (Client exited)
[02:01:45] *** Joins: int3_ (int3_@moz-ABE52D50.hsd1.ca.comcast.net)
[02:03:22] *** Joins: Yurume (yurume@AC58A8CE.8A059B47.E313B915.IP)
[02:03:32] *** Quits: int3_ (int3_@moz-ABE52D50.hsd1.ca.comcast.net) (Ping timeout)
[02:05:48] <SiegeLord> rusti: enum A { B = 1, C = 2 } let a: A = std::cast::transmute(2); a
[02:05:49] -rusti- <anon>:5:44: 5:68 error: call to unsafe function requires unsafe function or block
[02:05:49] -rusti- <anon>:5          enum A { B = 1, C = 2 } let a: A = std::cast::transmute(2); a
[02:05:49] -rusti-                                                      ^~~~~~~~~~~~~~~~~~~~~~~~
[02:05:49] -rusti- error: aborting due to previous error
[02:05:51] -rusti- application terminated with error code 101
[02:06:01] <SiegeLord> rusti: enum A { B = 1, C = 2 } unsafe { let a: A = std::cast::transmute(2); a }
[02:06:01] -rusti- C
[02:08:07] *** Joins: steven_is_false (user@C5B76363.1FF1EBF8.1ECA502.IP)
[02:08:37] *** Quits: Earnestly (earnest@moz-F387F877.dyn.plus.net) (Ping timeout)
[02:10:24] *** Quits: FrozenCow (FrozenCow@moz-B2DF4929.chello.nl) (Ping timeout)
[02:11:37] *** Quits: maik (maik___@moz-A7524DA9.dip0.t-ipconnect.de) (Ping timeout)
[02:11:44] <steven_is_false> Hello. I was thinking these types of benchmarks https://github.com/mozilla/rust/blob/master/src/test/bench/msgsend-pipes.rs might be more accurate if we did something like http://gitorious.org/helioblastocyst/helioblastocyst/source/569f01689559e8bd1ac644d021fd64cf4a8f7686:src/benchmark/gamelib/MethodMessagePassing.java#L91 where all the threads are spawned beforehand, and then signaled to start to ensure the maximum amount of threads
[02:11:44] <steven_is_false> contending at once. I'm not sure if that would be faithful to the original benchmark but I think it might make more sense.
[02:12:52] <steven_is_false> I guess one could go even further, and have extra synchronization to deliberately make sure that the threads are fighting with each other.
[02:12:59] *** Joins: maik (maik___@moz-A7524DA9.dip0.t-ipconnect.de)
[02:19:43] *** Parts: steven_is_false (user@C5B76363.1FF1EBF8.1ECA502.IP) (ERC Version 5.3 (IRC client for Emacs))
[02:26:13] *** Quits: MrFahrenheit (RageOfThou@3FEF494C.29C984D5.783DEDCA.IP) (Ping timeout)
[02:27:18] *** Joins: steven_is_false (user@C5B76363.1FF1EBF8.1ECA502.IP)
[02:28:20] *** Parts: steven_is_false (user@C5B76363.1FF1EBF8.1ECA502.IP) (ERC Version 5.3 (IRC client for Emacs))
[02:29:05] *** Quits: bytewise (bytewise@moz-4A801D04.unitymediagroup.de) (Quit: Leaving)
[02:30:26] *** Joins: kgriffs (Adium@moz-7E0D846A.aus1.rackspace.com)
[02:30:46] *** Quits: paulproteus (quassel@rose.makesad.us) (Ping timeout)
[02:31:02] *** Joins: sruggier (sruggier@moz-F1ED47A9.cpe.teksavvy.com)
[02:31:35] *** Joins: paulproteus (quassel@moz-E86A3B42.makesad.us)
[02:32:06] *** Quits: kgriffs (Adium@moz-7E0D846A.aus1.rackspace.com) (Ping timeout)
[02:32:20] *** Joins: mark_edward (quassel@moz-97E995A.hsd1.in.comcast.net)
[02:32:37] *** Joins: int3_ (int3_@moz-ABE52D50.hsd1.ca.comcast.net)
[02:33:29] *** Quits: int3_ (int3_@moz-ABE52D50.hsd1.ca.comcast.net) (Client exited)
[02:33:50] *** Joins: int3_ (int3_@moz-ABE52D50.hsd1.ca.comcast.net)
[02:34:02] *** Quits: mark_edward (quassel@moz-97E995A.hsd1.in.comcast.net) (Quit: http://quassel-irc.org - Chat comfortably. Anywhere.)
[02:35:38] *** Quits: int3_ (int3_@moz-ABE52D50.hsd1.ca.comcast.net) (Ping timeout)
[02:36:10] *** Quits: maik (maik___@moz-A7524DA9.dip0.t-ipconnect.de) (Ping timeout)
[02:36:36] *** Quits: dforsyth (dforsyth@A677A619.1C765EF.EE6E63A5.IP) (Client exited)
[02:40:13] <tikue_> does make check work?
[02:40:19] <Eridius> yes
[02:40:33] <tikue_> any idea what this means Eridius ?
[02:40:34] <tikue_> make: *** [tmp/check-stage2-T-x86_64-apple-darwin-H-x86_64-apple-darwin-rpass.ok] Error 134
[02:40:56] <Eridius> it means the run-pass runner for stage2 exited with error code 134. It probably said something immediately prior to that
[02:41:19] *** Joins: lkuper (lkuper@moz-C0CD33ED.hsd1.in.comcast.net)
[02:41:21] <tikue_> ah yeah -- /bin/sh: line 1: 64477 Abort trap: 6
[02:41:28] <tikue_> and then a long command
[02:41:52] <strcat> maybe out of memory
[02:42:04] <sruggier> I was wondering about running rustc in a debugger, to help me gain context quickly, but it looks like there's no explicit support in the build system for that?
[02:42:46] *** Joins: kimundi_ (kimundi@moz-E44663F3.dip0.t-ipconnect.de)
[02:43:20] *** Joins: lbergstrom (Adium@moz-5D8E4B14.lightspeed.cicril.sbcglobal.net)
[02:44:01] <tikue_> usr/local/lib/rustc/x86_64-apple-darwin/lib/ builds up with a lot of old files
[02:44:09] *** Quits: kimundi (kimundi@moz-9C96D30A.dip0.t-ipconnect.de) (Ping timeout)
[02:44:09] *** kimundi_ is now known as kimundi
[02:44:13] <tikue_> is there a process for removing those before a make install?
[02:44:40] <tikue_> or rather, a best practice
[02:45:00] *** Joins: jeaye (Jeaye@moz-FD505E54.hsd1.ca.comcast.net)
[02:46:38] *** Quits: hellmage (luyun@BA8B278D.4627311A.77EF871E.IP) (Quit: Leaving.)
[02:48:41] *** Joins: ChrisMorgan (chris@moz-D7F2B7D6.static.tpgi.com.au)
[02:49:01] *** Joins: mark_edward (quassel@moz-97E995A.hsd1.in.comcast.net)
[02:49:47] *** Quits: SiegeLord (sl@moz-CAF07B4C.hsd1.ma.comcast.net) (Quit: It's a joke, it's all a joke.)
[02:52:01] *** kimundi is now known as zz_kimundi
[02:52:40] *** Quits: vodik (simon@moz-CBE4BB13.cable.teksavvy.com) (Ping timeout)
[02:55:19] *** Quits: Nisstyre (wes@moz-FD86289.netflash.net) (Quit: Leaving)
[02:55:25] <jmgrosen> rusti: range(0, 26).to_owned_array()
[02:55:25] -rusti- <anon>:5:9: 6:5 error: type `std::iterator::Range<int>` does not implement any method in scope named `to_owned_array`
[02:55:25] -rusti- <anon>:5          range(0, 26).to_owned_array()
[02:55:25] -rusti- <anon>:6     };
[02:55:26] -rusti- error: aborting due to previous error
[02:55:26] -rusti- application terminated with error code 101
[02:55:34] <jmgrosen> rusti: range(0, 26).to_owned_vec()
[02:55:35] -rusti- ~[0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25]
[02:55:54] *** Joins: alisdair (textual@1697D94C.7742FB18.FBC8476D.IP)
[02:58:54] *** zz_kimundi is now known as kimundi
[03:03:03] <Eridius> rusti: let x = 3u8; bytes!(x)
[03:03:03] -rusti- <anon>:5:22: 6:5 error: Non-literal in bytes!
[03:03:03] -rusti- <anon>:5          let x = 3u8; bytes!(x)
[03:03:04] -rusti- <anon>:6     };
[03:03:04] -rusti- error: aborting due to previous error
[03:03:04] -rusti- application terminated with error code 101
[03:03:32] *** Quits: james4k (james@moz-E7990244.consolidated.net) (Ping timeout)
[03:04:05] *** Joins: sankha93 (Instantbir@7061CD01.D6BD0D91.22D41759.IP)
[03:05:51] <Eridius> rusti: match Some(3i) { None | Some(3i) if false => { true }, _ => { false } }
[03:05:51] -rusti- false
[03:05:57] <Eridius> rusti: match Some(3i) { None | Some(3i) if true => { true }, _ => { false } }
[03:05:58] -rusti- true
[03:06:04] <Eridius> rusti: match Some(3i) { None | Some(x) if x > 1 => { true }, _ => { false } }
[03:06:05] -rusti- <anon>:5:38: 5:39 error: variable `x` from pattern #2 is not bound in pattern #1
[03:06:05] -rusti- <anon>:5          match Some(3i) { None | Some(x) if x > 1 => { true }, _ => { false } }
[03:06:05] -rusti-                                                ^
[03:06:05] -rusti- error: aborting due to previous error
[03:06:06] -rusti- application terminated with error code 101
[03:06:47] <Eridius> rusti: match Some(3i) { Some(3i) | None if false => { true }, _ => { false } }
[03:06:48] -rusti- false
[03:08:49] *** Quits: jmgrosen (jmgrosen@moz-848F6087.sb.sd.cox.net) (Quit: jmgrosen)
[03:08:50] <sruggier> rusti: trait A<'self, T> { fn f(&mut self) -> &'self mut T; fn p() -> T; }
[03:08:53] -rusti- pastebinned 2 lines of output: http://ix.io/7Kf
[03:11:34] *** Quits: samx (sami@moz-D9DA5773.dyn.optonline.net) (Quit: This computer has gone to sleep)
[03:12:24] *** Quits: lbergstrom (Adium@moz-5D8E4B14.lightspeed.cicril.sbcglobal.net) (Quit: Leaving.)
[03:13:00] *** Joins: dforsyth (dforsyth@A677A619.1C765EF.EE6E63A5.IP)
[03:17:08] <engla> Eridius: I found you did the iterator to decode utf-16. I wrote the yet simpler iterators for utf-8 and ascii https://gist.github.com/anonymous/a9889479308948f4071f
[03:17:24] <engla> we need something like this to provide char iterators in IO
[03:17:39] <Eridius> engla: are you talking about my encodings branch?
[03:17:49] <engla> yes
[03:17:50] *** Quits: tiffany (kawaii@moz-EB8B0C08.dhcp.embarqhsd.net) (Ping timeout)
[03:17:55] <engla> just found the discussion on r/rust
[03:18:12] <Eridius> I need to revisit that at some point and see if it can be easily extended to machine-generated iterators for other encodings
[03:18:19] <Eridius> and I also need to benchmark it against the other proposed approaches
[03:18:24] <engla> ok
[03:18:36] <Eridius> unless someone else wants to do that.. ;)
[03:18:36] <engla> do you know if encodings are going to be in libstd? Probably not?
[03:19:07] <Eridius> engla: it's possible. They certainly are useful, but I wouldn't be surprised if libstd only handled, say, utf-8/16/32 and let other encodings go somewhere else
[03:19:21] <Eridius> keeping around the tables for the other encodings is a wee bit of bloat
[03:19:40] *** Quits: tikue_ (tkuehn@moz-FEADCD38.hsd1.pa.comcast.net) (Quit: tikue_)
[03:19:50] <engla> I suppose libstd can provide the interfaces and maybe even only utf-8
[03:20:03] <Eridius> utf-16/32 is probably useful enough to provide as well
[03:20:06] *** Joins: tikue_ (tkuehn@moz-FEADCD38.hsd1.pa.comcast.net)
[03:20:45] <Eridius> anyway, thanks for the code. I just starred the gist, and I'll try to revisit it at some point soon to add it to my encodings branch
[03:20:50] *** Quits: tikue_ (tkuehn@moz-FEADCD38.hsd1.pa.comcast.net) (Quit: tikue_)
[03:20:58] <Eridius> right now I'm still working on my path rewrite, and I'm about to go on vacation for a week, so I'm not sure when that will be
[03:21:05] <engla> aha ok
[03:21:11] <Eridius> Windows paths suck :/
[03:22:09] <engla> that really needs to be rewritten though so that's great
[03:22:19] *** Joins: maik (maik___@moz-A7524DA9.dip0.t-ipconnect.de)
[03:22:22] <Eridius> have you seen my current progress?
[03:22:31] <pepper_chico> man, how many concepts about pointersâ€¦ (reading tutorial)
[03:22:34] <engla> no
[03:22:35] <Eridius> PosixPath is done, with a test suite. working on WindowsPath now, then I have to re-add the stat-based methods too that I haven't done yet
[03:22:47] <Eridius> engla: https://github.com/kballard/rust/commits/path-rewrite
[03:22:53] <Eridius> (branch is subject to rebase, naturally)
[03:23:24] <Eridius> I'm keeping everything in a module called path2 at the moment. When I have it API-complete I'm going to start looking to see just how much code will need to be updated to use path2. I'm afraid the answer will be "a lot"
[03:26:34] <engla> such amazing complexity
[03:26:38] <engla> "amazing"
[03:27:00] <Eridius> paths are more complicated than I expected :/
[03:27:17] *** mcpherrin is now known as mm
[03:27:28] <Eridius> especially when you want to avoid unnecessary allocation
[03:27:42] *** Quits: Jesin (Jessin_@moz-A680C20B.cc.lehigh.edu) (Ping timeout)
[03:28:30] *** Joins: Jesin (Jessin_@moz-A680C20B.cc.lehigh.edu)
[03:30:26] *** Joins: ghrust (ghrust@79968228.6A2AE50.F3114085.IP)
[03:30:26] <ghrust> 01[13rust01] 15thestinger merged 06auto into 06snap-stage3: 02http://git.io/mt-jkA
[03:30:26] *** Parts: ghrust (ghrust@79968228.6A2AE50.F3114085.IP) ()
[03:30:47] *** Joins: kgriffs (Adium@moz-7E0D846A.aus1.rackspace.com)
[03:31:18] *** Quits: alisdair (textual@1697D94C.7742FB18.FBC8476D.IP) (Quit: My MacBook Pro has gone to sleep. ZZZzzzâ€¦)
[03:32:27] *** Quits: kgriffs (Adium@moz-7E0D846A.aus1.rackspace.com) (Ping timeout)
[03:38:30] <Eridius> rusti: struct Foo { a: int, b: int } let mut foo = Foo{a: 1, b: 2}; (f.a, f.b) = (3, 4); f
[03:38:33] -rusti- pastebinned 11 lines of output: http://ix.io/7Kj
[03:38:44] <Eridius> rusti: struct Foo { a: int, b: int } let mut f = Foo{a: 1, b: 2}; (f.a, f.b) = (3, 4); f
[03:38:47] -rusti- pastebinned 7 lines of output: http://ix.io/7Kk
[03:38:55] <Eridius> sweet, ICE
[03:39:13] <Eridius> not that I expected that to work anyway, but it shouldn't crash
[03:39:36] <Eridius> rusti: let mut x = Some(3i); *x = 4i; x
[03:39:40] -rusti- pastebinned 8 lines of output: http://ix.io/7Kl
[03:40:00] <Eridius> rusti: struct Foo(int); let mut x = Foo(3); *x = 4; x
[03:40:02] -rusti- {__field__: 4}
[03:40:34] <Eridius> rusti: let mut a = 3; let mut b = 4; (a,b) = (5, 6); (a,b)
[03:40:40] -rusti- pastebinned 10 lines of output: http://ix.io/7Km
[03:40:45] <Eridius> oh excellent, same ICE
[03:41:23] <Eridius> rusti: 1 = 2
[03:41:26] -rusti- pastebinned 4 lines of output: http://ix.io/7Kn
[03:41:31] <Eridius> hah
[03:44:40] <lkuper> Eridius: oh, hey, I was just plowing through https://github.com/mozilla/rust/issues/3227.  Is there a big path refactor about to land and if so, should I not do that?
[03:45:22] <Eridius> lkuper: I'm not actually modifying the path module at all. I'm writing a brand new module. So refactoring path probably won't affect me
[03:45:28] <Eridius> I assume you're not changing API, just implementation?
[03:45:35] <lkuper> Eridius: right
[03:45:54] <Eridius> ok then, refactor away. I hope I finish my path rewrite soon, but I'm not guaranteeing anything
[03:47:13] *** Joins: int3_ (int3_@moz-ABE52D50.hsd1.ca.comcast.net)
[03:47:17] *** Joins: glyc (Mibbit@moz-AB71E29F.hsd1.ca.comcast.net)
[03:49:03] <glyc> hello. I'm new to rust. seems like the most sane approach to memory I've seen.  Very nice design.  What's the equivalent of gcc -g for rustc?  to generate debug symbols
[03:49:21] <strcat> glyc: -Z debug-info
[03:49:55] <glyc> nice, thank you srcat. is there an equivalent for -O0, -O2, -O3 ?
[03:50:08] <strcat> glyc: yeah, --opt-level=2 (or 1, or 3)
[03:50:18] <glyc> excellent. thank you.
[03:50:20] <strcat> we use identical LLVM passes to clang now in master
[03:50:29] <glyc> ah perfect
[03:52:44] *** Quits: boredomist (user@moz-63CF9F31.res-cmts.sesp.ptd.net) (Ping timeout)
[03:54:08] *** Joins: tikue_ (tkuehn@moz-424BC304.hsd1.pa.comcast.net)
[03:58:16] *** Quits: Shaladdle (Shaladdle@moz-424BC304.hsd1.pa.comcast.net) (Quit: Leaving)
[03:58:16] *** Joins: Nisstyre (wes@moz-FD86289.netflash.net)
[04:00:09] *** Quits: glyc (Mibbit@moz-AB71E29F.hsd1.ca.comcast.net) (Quit: http://www.mibbit.com ajax IRC Client)
[04:03:43] <Eridius> hrm, I wonder if I should refactor this a bit to rename PosixPath to posix::Path and WindowsPath to windows::Path
[04:04:07] *** Joins: jmgrosen (jmgrosen@moz-848F6087.sb.sd.cox.net)
[04:04:22] *** Joins: alisdair (textual@1697D94C.7742FB18.FBC8476D.IP)
[04:06:06] *** Quits: StarLight (StarLight@moz-A1F19695.dynamic.avangarddsl.ru) (Ping timeout)
[04:09:10] *** Quits: DAddYE (DAddYE@moz-98D3933F.hsd1.ca.comcast.net) (Client exited)
[04:09:45] *** Joins: DAddYE (DAddYE@moz-98D3933F.hsd1.ca.comcast.net)
[04:10:32] *** Joins: StarLight (StarLight@moz-4851C66E.dynamic.avangarddsl.ru)
[04:11:25] *** Quits: DAddYE (DAddYE@moz-98D3933F.hsd1.ca.comcast.net) (Ping timeout)
[04:12:37] *** Quits: tikue_ (tkuehn@moz-424BC304.hsd1.pa.comcast.net) (Quit: tikue_)
[04:14:24] *** Quits: mark_edward (quassel@moz-97E995A.hsd1.in.comcast.net) (Client exited)
[04:14:54] *** Joins: tikue_ (tkuehn@moz-424BC304.hsd1.pa.comcast.net)
[04:15:53] *** Quits: tikue_ (tkuehn@moz-424BC304.hsd1.pa.comcast.net) (Quit: tikue_)
[04:17:05] *** Joins: mib_9uybip (mib_9uybip@moz-9B8221B3.rivrw1.nsw.optusnet.com.au)
[04:17:37] *** Joins: mib_9uyb_ (mib_9uybip@moz-9B8221B3.rivrw1.nsw.optusnet.com.au)
[04:17:37] *** Quits: mib_9uybip (mib_9uybip@moz-9B8221B3.rivrw1.nsw.optusnet.com.au) (Connection reset by peer)
[04:17:45] *** Quits: mib_9uyb_ (mib_9uybip@moz-9B8221B3.rivrw1.nsw.optusnet.com.au) (Client exited)
[04:18:48] *** Joins: tikue_ (tkuehn@moz-424BC304.hsd1.pa.comcast.net)
[04:19:44] <tikue_> i'm trying to run make test before putting a PR in, but it keeps aborting without any useful error message
[04:19:45] <tikue_> :(
[04:19:53] <tikue_> is make check ever borked for anyone else?
[04:25:14] <carleastlund> tikue_: there was a thread on the mailing list about make check failing, don't know if what you're seeing is related
[04:26:05] <tikue_> carleastlund: oh yes! i have the same exact issue
[04:27:30] <carleastlund> tikue_: looks like the issue is here: https://github.com/mozilla/rust/issues/8904 and the thread is here: https://mail.mozilla.org/pipermail/rust-dev/2013-August/005433.html
[04:31:12] *** Joins: kgriffs (Adium@moz-7E0D846A.aus1.rackspace.com)
[04:32:52] *** Quits: kgriffs (Adium@moz-7E0D846A.aus1.rackspace.com) (Ping timeout)
[04:37:21] <tikue_> carleastlund: looks like there isn't a solution though :\
[04:38:15] <carleastlund> tikue_: bummer.  Well, at least you can sign up for notifications on the issue to find out when it does get fixed.
[04:38:23] <tikue_> yea
[04:38:36] <tikue_> i'm subscribed to the mailing list
[04:39:52] *** Quits: jmgrosen (jmgrosen@moz-848F6087.sb.sd.cox.net) (Quit: jmgrosen)
[04:40:08] *** Joins: DAddYE (DAddYE@moz-98D3933F.hsd1.ca.comcast.net)
[04:41:20] *** Quits: tikue_ (tkuehn@moz-424BC304.hsd1.pa.comcast.net) (Quit: tikue_)
[04:46:01] *** Joins: robarnold (rob@BD56354E.DB510C09.6E370BFC.IP)
[04:47:19] *** Quits: Jesin (Jessin_@moz-A680C20B.cc.lehigh.edu) (Ping timeout)
[04:47:58] *** Joins: jmgrosen (jmgrosen@moz-848F6087.sb.sd.cox.net)
[04:48:26] *** Quits: maik (maik___@moz-A7524DA9.dip0.t-ipconnect.de) (Ping timeout)
[04:48:53] *** Joins: tikue_ (tkuehn@moz-424BC304.hsd1.pa.comcast.net)
[05:00:05] *** Quits: jmgrosen (jmgrosen@moz-848F6087.sb.sd.cox.net) (Quit: jmgrosen)
[05:00:56] *** Joins: james4k (james@moz-E7990244.consolidated.net)
[05:01:10] *** Quits: DAddYE (DAddYE@moz-98D3933F.hsd1.ca.comcast.net) (Client exited)
[05:01:10] *** Joins: DAddYE (DAddYE@moz-98D3933F.hsd1.ca.comcast.net)
[05:01:50] *** Joins: jmgrosen (jmgrosen@moz-848F6087.sb.sd.cox.net)
[05:03:30] *** Quits: jmgrosen (jmgrosen@moz-848F6087.sb.sd.cox.net) (Ping timeout)
[05:05:07] *** Quits: james4k (james@moz-E7990244.consolidated.net) (Quit: WeeChat 0.4.1)
[05:05:36] *** Joins: Jesin (Jessin_@moz-A680C20B.cc.lehigh.edu)
[05:06:33] *** Joins: carllerche (carllerche@moz-A5D7B4BD.bvtn.or.frontiernet.net)
[05:06:43] *** Quits: carllerche (carllerche@moz-A5D7B4BD.bvtn.or.frontiernet.net) (Quit: carllerche)
[05:07:14] <bjz_> rusti: struct Vec([float,..3]); struct Mat([Vec,..3]); let
[05:07:15] -rusti- <anon>:6:4: 6:5 error: unexpected token: `}`
[05:07:15] -rusti- <anon>:6     };
[05:07:15] -rusti-              ^
[05:07:15] -rusti- application terminated with error code 101
[05:07:52] *** Quits: Jesin (Jessin_@moz-A680C20B.cc.lehigh.edu) (Ping timeout)
[05:08:32] <bjz_> rusti: struct Vec([int,..3]); struct Mat([Vec,..3]); let m = Mat([Vec([1, 2, 3]), Vec([4, 5, 6]), Vec([7, 8, 9])]); m[1][2]
[05:08:32] -rusti- 6
[05:08:39] *** Quits: voxpopuli (fanservice@moz-CEF3689A.hsd1.pa.comcast.net) (Ping timeout)
[05:08:55] <bjz_> rusti: struct Vec([int,..3]); struct Mat([Vec,..3]); let mut m = Mat([Vec([1, 2, 3]), Vec([4, 5, 6]), Vec([7, 8, 9])]); m[1][2] = 3; m[1][2]
[05:08:56] -rusti- 3
[05:09:33] *** Joins: drrb (drrb@4D561226.896EE5A.377B9828.IP)
[05:12:58] <drrb> hello! does anyone know of any examples of projects calling rust from java?
[05:14:07] *** Quits: cubic (cubic@moz-FE5AD6C7.mc.videotron.ca) (Connection reset by peer)
[05:14:07] <tikue_> rusti: type Vec3 = [float, ..3]; type Mat = [Vec3, ..3]; let mat: Mat = [[1, 2, 3], [1, 2, 3], [1, 2, 3]];
[05:14:17] -rusti- pastebinned 5 lines of output: http://ix.io/7Ku
[05:14:48] <tikue_> rusti: type Vec3 = [int, ..3]; type Mat = [Vec3, ..3]; let mat: Mat = [[1, 2, 3], [1, 2, 3], [1, 2, 3]];
[05:14:49] -rusti- <anon>:5:61: 5:64 warning: unused variable: `mat` [-W unused-variable (default)]
[05:14:49] -rusti- <anon>:5          type Vec3 = [int, ..3]; type Mat = [Vec3, ..3]; let mat: Mat = [[1, 2, 3], [1, 2, 3], [1, 2, 3]];
[05:14:49] -rusti-                                                                       ^~~
[05:14:49] -rusti- ()
[05:15:00] <bjz_> rusti: type Vec3 = [float, ..3]; type Mat = [Vec3, ..3]; let mat: Mat = [[1f, 2f, 3f], [1f, 2f, 3f], [1f, 2f, 3f]]; mat
[05:15:01] -rusti- [[1, 2, 3], [1, 2, 3], [1, 2, 3]]
[05:15:12] <tikue_> rusti: type Vec3 = [int, ..3]; type Mat = [Vec3, ..3]; let mat: Mat = [[1, 2, 3], [1, 2, 3], [1, 2, 3]]; mat
[05:15:13] -rusti- <anon>:1:0: 1:0 error: can't find crate for `std`
[05:15:13] -rusti- <anon>:1 extern mod extra;
[05:15:13] -rusti-          ^
[05:15:13] -rusti- application terminated with error code 101
[05:15:16] <tikue_> lol wat
[05:15:19] <strcat> it upgraded
[05:15:22] <tikue_> oh
[05:15:25] <bjz_> tikue_: int literals don't coerce
[05:15:26] <strcat> you caught it in the middle
[05:15:28] <strcat> rusti: 2
[05:15:30] -rusti- 2
[05:15:32] *** Quits: DAddYE (DAddYE@moz-98D3933F.hsd1.ca.comcast.net) (Client exited)
[05:15:33] <tikue_> rusti: type Vec3 = [int, ..3]; type Mat = [Vec3, ..3]; let mat: Mat = [[1, 2, 3], [1, 2, 3], [1, 2, 3]]; mat
[05:15:34] -rusti- [[1, 2, 3], [1, 2, 3], [1, 2, 3]]
[05:15:36] <tikue_> there
[05:15:43] <strcat> rusti: range(3, 5)
[05:15:44] -rusti- std::iterator::Range<int>{state: 3, stop: 5, one: 1}
[05:15:52] <strcat> rusti: range(3, 5).skip(2)
[05:15:53] -rusti- std::iterator::Skip<std::iterator::Range<int>>{iter: std::iterator::Range<int>{state: 3, stop: 5, one: 1}, n: 2u}
[05:15:54] *** Joins: DAddYE (DAddYE@moz-98D3933F.hsd1.ca.comcast.net)
[05:16:24] <strcat> rusti: struct Foo; Foo
[05:16:24] -rusti- main::Foo
[05:16:32] <tikue_> ooo
[05:16:37] <bjz_> interesting!
[05:16:38] <tikue_> your change landed?
[05:16:42] <strcat> yes ;p
[05:16:45] <tikue_> great
[05:16:47] <strcat> no more {}
[05:16:53] <tikue_> rusti: struct Foo(uint); Foo(1u)
[05:16:54] -rusti- main::Foo{__field__: 1u}
[05:17:01] <strcat> I should fix tuple struct printing
[05:17:07] <tikue_> :)
[05:17:09] <strcat> at least unit structs print sanely now
[05:17:13] <bjz_> aye
[05:17:24] <strcat> and integers/floats
[05:17:27] <strcat> rusti: 5u8
[05:17:27] -rusti- 5u8
[05:17:29] <strcat> rusti: 5f64
[05:17:29] <tikue_> rusti: struct Foo { bar: uint }; Foo { bar: 1u }
[05:17:31] -rusti- 5f64
[05:17:31] -rusti- main::Foo{bar: 1u}
[05:17:33] <bjz_> nice
[05:17:38] *** Quits: DAddYE (DAddYE@moz-98D3933F.hsd1.ca.comcast.net) (Ping timeout)
[05:17:42] <strcat> it used to print 5f64 as 5 ;p
[05:17:50] <bjz_> yeah, icky
[05:18:01] <bjz_> rusti: type Vec3 = [float, ..3]; type Mat = [Vec3, ..3]; let mat: Mat = [[1f, 2f, 3f], [1f, 2f, 3f], [1f, 2f, 3f]]; mat
[05:18:02] -rusti- [[1, 2, 3], [1, 2, 3], [1, 2, 3]]
[05:18:07] <bjz_> :/
[05:18:11] <bjz_> strcat: ^
[05:18:17] <strcat> yeah I know
[05:18:23] <tikue_> what should it be?
[05:18:24] <bjz_> ahhok
[05:18:25] <strcat> it's because I only added a suffix for f32/f64
[05:18:26] <tikue_> 1f, 2f, etc?
[05:18:35] <strcat> or put .0
[05:18:49] <strcat> but I think we're going to remove float
[05:18:55] <bjz_> rusti: type Vec3 = [f64, ..3]; type Mat = [Vec3, ..3]; let mat: Mat = [[1f64, 2f64, 3f64], [1f64, 2f64, 3f64], [1f64, 2f64, 3f64]]; mat
[05:18:56] -rusti- [[1f64, 2f64, 3f64], [1f64, 2f64, 3f64], [1f64, 2f64, 3f64]]
[05:18:58] <tikue_> strcat: what??
[05:19:03] <tikue_> why
[05:19:07] <achin> halp, i need to be de-noobed.  why doesn't this work:   for i in std::os::args().iter() { println(*i); }
[05:19:14] <strcat> because f32/f64 are enough and match what other languages do
[05:19:16] <bjz_> strcat: orly, nice
[05:19:21] <strcat> bjz_: there's an open RFC
[05:19:32] <tikue_> float is nice though
[05:19:36] <strcat> tikue_: why?
[05:19:53] <strcat> you'd still have generic literals
[05:19:54] <tikue_> it always gives you the largest size possible right?
[05:20:06] <strcat> tikue_: no
[05:20:09] <bjz_> tikue_: it always gives f64
[05:20:21] <strcat> there is 'long double' in C
[05:20:26] <tikue_> rusti: for i in ::std::os::args().iter() { println(i); }
[05:20:27] -rusti- <anon>:5:53: 5:54 error: mismatched types: expected `&str` but found `&~str` (expected &str but found &-ptr)
[05:20:27] -rusti- <anon>:5          for i in ::std::os::args().iter() { println(i); }
[05:20:27] -rusti-                                                               ^
[05:20:27] -rusti- error: aborting due to previous error
[05:20:27] -rusti- application terminated with error code 101
[05:20:32] <strcat> and the IEEE standards specify larger sizes
[05:20:38] <tikue_> rusti: for i in ::std::os::args().iter() { printfln!(i); }
[05:20:42] -rusti- pastebinned 11 lines of output: http://ix.io/7Kv
[05:20:51] <strcat> 16-bit, 32-bit, 64-bit, 128-bit
[05:20:54] <strcat> are the standards
[05:20:56] *** Joins: nsf (nsf@moz-EEF3238A.convex.ru)
[05:21:07] <tikue_> rusti: let args = ::std::os::args(); for i in args.iter() { printfln!(i); }
[05:21:08] -rusti- &~"./out"
[05:21:08] -rusti- ()
[05:21:09] <bjz_> strcat: will we have those in the future?
[05:21:23] <strcat> bjz_: don't know!
[05:21:26] <bjz_> hehe
[05:21:40] <strcat> bjz_: http://llvm.org/docs/LangRef.html#floating-point-types
[05:21:54] <bjz_> ye
[05:22:08] *** Quits: drrb (drrb@4D561226.896EE5A.377B9828.IP) (Ping timeout)
[05:22:18] <achin> tikue_: hrm.. how is that different?
[05:22:24] <bjz_> heh, 80bit fp?
[05:22:31] <strcat> bjz_: that's what x86 had before SSE
[05:22:36] <bjz_> ahh
[05:22:40] <achin> (assigning to args before getting the .iter())
[05:22:40] <bjz_> legacy?
[05:22:50] <strcat> bjz_: yep, x87 floating point support is 80-bit registers
[05:23:01] <strcat> bjz_: so if you compile for 32-bit without enabling SSE, you're using those
[05:23:17] <strcat> x86_64 has SSE2 as a baseline
[05:23:32] * bjz_ kinda wishes we had properties
[05:23:39] *** Joins: Jesin (Jessin_@moz-DD8D71FB.cc.lehigh.edu)
[05:23:53] <strcat> but anyway x87 is evil
[05:23:57] <bjz_> :P
[05:24:09] <strcat> rust should absolutely never expose anything supporting it ;p
[05:25:16] <strcat> bjz_: it has weird rounding quirks
[05:25:44] <strcat> you have to set it to 64-bit rounding to get normal (ish?) results
[05:25:53] <achin> ooh, i think i see.  the thing returned by os::args() is stored in a temporary that is immeditally destructed
[05:25:56] <achin> tikue_: thanks!
[05:25:57] * strcat doesn't want to think about floats
[05:26:36] <bjz_> strcat: leave that to jensnockert ;)
[05:27:08] *** Quits: Sorella (queen@9D963F5D.DF5D8AE7.54BCAB54.IP) (Quit: G'night everynyan~!)
[05:27:25] <strcat> my foray into numbers will just be range_step/range_step_inclusive + the checked arithmetic stuff I already added for them ;p
[05:27:40] <bjz_> rusti: [1, 2, 3].iter().collect()
[05:27:41] -rusti- <anon>:5:9: 6:5 error: cannot determine a type for this bounded type parameter: unconstrained type
[05:27:41] -rusti- <anon>:5          [1, 2, 3].iter().collect()
[05:27:41] -rusti- <anon>:6     };
[05:27:41] -rusti- application terminated with error code 101
[05:27:51] <bjz_> ahh, that bug
[05:27:56] <bjz_> #-_-
[05:27:57] <strcat> not a bug
[05:28:01] <strcat> there's also the rvalue bug
[05:28:04] <strcat> but you didn't hit it yet ;p
[05:28:15] <bjz_> not a bug?
[05:28:22] <strcat> it's mad because collect needs a way to infer the container type
[05:28:31] <strcat> if you fixed that it'd yell about the rvalue bug
[05:29:12] <andrew-d> rusti: let x: ~[int] = [1,2,3].iter().collect()
[05:29:12] -rusti- <anon>:6:4: 6:5 error: expected `;` but found `}`
[05:29:12] -rusti- <anon>:6     };
[05:29:12] -rusti-              ^
[05:29:13] -rusti- application terminated with error code 101
[05:29:23] <andrew-d> rusti: let x: ~[int] = [1,2,3].iter().collect(); x
[05:29:26] -rusti- pastebinned 8 lines of output: http://ix.io/7Kw
[05:29:39] <strcat> iter() yields &int
[05:30:33] <strcat> rusti: let xs = [1, 2]; xs.iter()
[05:30:38] -rusti- pastebinned 16 lines of output: http://ix.io/7Kx
[05:30:50] <strcat> rusti: let xs = [1, 2]; println!("{:?}", xs.iter())
[05:30:51] -rusti- std::vec::VecIterator<,int>{ptr: (0x7f9a8c2170e8 as *()), end: (0x7f9a8c2170f8 as *()), lifetime: &1}
[05:30:51] -rusti- ()
[05:30:57] *** Joins: ssutch (samuelsutc@moz-DFB7649C.hsd1.ca.comcast.net)
[05:31:08] <bjz_> lolwut
[05:31:13] <bjz_> <,int>
[05:31:23] <strcat> bjz_: lifetimes/functions print as nothing
[05:31:24] <strcat> and traits
[05:31:37] *** Joins: kgriffs (Adium@moz-7E0D846A.aus1.rackspace.com)
[05:31:50] <strcat> I could probably teach it about lifetimes pretty easily
[05:31:53] <strcat> functions.... no.
[05:31:59] <bjz_> why?
[05:32:10] <strcat> because it expects to be able to recursively walk the type, and visit values
[05:32:23] <strcat> so the function one would need some horrific hack to get the types of params I guess
[05:32:28] <bjz_> haha
[05:32:31] <strcat> maybe just ty_to_str in reflect
[05:32:59] <strcat> bjz_: it might just be a lack of knowledge on how to print them ;p
[05:33:07] <strcat> repr is crufty
[05:33:17] *** Quits: kgriffs (Adium@moz-7E0D846A.aus1.rackspace.com) (Ping timeout)
[05:33:30] <strcat> it has bugs like this:
[05:33:31] *** Quits: engla (engla@moz-DBD1D96E.cust.bredbandsbolaget.se) (Ping timeout)
[05:33:39] <strcat> rusti: struct Foo; ~[Foo, Foo, Foo] /* this is fine */
[05:33:40] -rusti- ~[main::Foo, main::Foo, main::Foo]
[05:33:47] <strcat> rusti: struct Foo; [Foo, Foo, Foo] /* wtf? */
[05:33:47] -rusti- []
[05:33:57] <bjz_> haw haw
[05:34:00] <strcat> rusti: struct Foo(int); ~[Foo(5), Foo(2), Foo(3)] /* this is fine */
[05:34:01] -rusti- ~[main::Foo{__field__: 5}, main::Foo{__field__: 2}, main::Foo{__field__: 3}]
[05:34:10] <strcat> rusti: struct Foo(int); [Foo(5), Foo(2), Foo(3)] /* this is fine too! */
[05:34:11] -rusti- [main::Foo{__field__: 5}, main::Foo{__field__: 2}, main::Foo{__field__: 3}]
[05:34:14] <strcat> so yeah.
[05:34:25] <strcat> (it can't deal with zero-size types in fixed-size vecs)
[05:35:21] <strcat> other random issues are that it doesn't print the whole path for enums, and thinks all raw pointers point to ()
[05:35:40] <strcat> and that __field__ thing on tuple structs.
[05:35:50] <ssutch> has anyone tried rust<->objective-c?
[05:36:25] <ssutch> using the FFI
[05:36:26] <bjz_> strcat: seen this? https://github.com/mozilla/rust/issues/7981
[05:37:35] <strcat> no
[05:38:27] <strcat> bjz_: I think they all make sense though (as in, I can see a use case for each one)
[05:38:34] <bjz_> yeah
[05:38:52] <strcat> extern, just as a place to stick link_args ;p
[05:39:01] <bjz_> enum Foo; // phantom type
[05:39:09] <andrew-d> strcat: Is there a reason for all * pointers being treated as *()?
[05:39:14] <strcat> and impls of traits with all default methods
[05:39:32] <strcat> andrew-d: no, just not implemented
[05:39:43] <andrew-d> Huh, fair enough
[05:39:45] <andrew-d> Might take a stab at it
[05:39:45] <bjz_> strcat: trait F: Bar + Baz; // collection of traits
[05:40:06] <strcat> bjz_: yeah but you could do a generic impl of that
[05:40:17] <strcat> impl<T: Bar + Baz> F for T
[05:40:28] <strcat> bjz_: oh I see what you mean
[05:40:41] <strcat> I though you meant as a reason for 'impl X for T' :)
[05:40:52] <bjz_> strcat: yeah, like Num is right now
[05:42:13] *** Quits: Yurumechan (23f9939a@B2F514.E4420F21.EEF52F3A.IP) (Ping timeout)
[05:42:23] <bjz_> strcat: I'm not so sure about the fn though
[05:42:37] <bjz_> strcat: kinda looks like a prototype
[05:42:51] <bjz_> strcat: not as something that returns ()
[05:43:13] <strcat> bjz_: meh, seems fine to me :)
[05:43:29] *** Joins: Yurumechan (23f9939a@B2F514.E4420F21.EEF52F3A.IP)
[05:43:43] <strcat> fn ignore<T>(_: T);
[05:43:49] <bjz_> strcat: anyway, was kinda sad that it got forgotten
[05:44:08] <strcat> the scary thing about repr is that it visits priv fields
[05:44:10] <strcat> ;[
[05:44:14] <bjz_> :P
[05:44:54] <bjz_> rusti: struct A { priv hi: () } A { hi: () }
[05:44:55] -rusti- main::A{hi: ()}
[05:44:59] <bjz_> heh
[05:44:59] <strcat> well I mean cross-crate
[05:45:05] <bjz_> yeah
[05:45:09] <bjz_> that's ugly
[05:45:45] <strcat> once the new format stuff becomes the default, I think my argument for making repr unsafe will be more persuasive
[05:45:51] <strcat> since you'd have to write {:?}
[05:45:56] <strcat> so it's clearly a debugging feature
[05:46:12] <strcat> {} is just the default trait-based format
[05:46:23] *** Joins: DAddYE (DAddYE@moz-98D3933F.hsd1.ca.comcast.net)
[05:47:47] *** Quits: inf-groupoid (user@580120F5.8ED93E28.1C8C8CE9.IP) (Client exited)
[05:49:17] *** Quits: KindOne (KindOne@EC51CE2D.E114B4AE.EC6A1518.IP) (Ping timeout)
[05:49:26] *** Quits: Jesin (Jessin_@moz-DD8D71FB.cc.lehigh.edu) (Ping timeout)
[05:50:19] *** Joins: mark_edward (quassel@moz-97E995A.hsd1.in.comcast.net)
[05:51:54] <mark_edward> do you guys know what makes STM usefull as oppossed to locks or Message passing?
[05:53:34] *** Quits: ChrisMorgan (chris@moz-D7F2B7D6.static.tpgi.com.au) (Ping timeout)
[05:53:59] *** Joins: KindOne (KindOne@moz-2EFADB6F.dynamic.ip.windstream.net)
[05:54:20] *** Quits: jeaye (Jeaye@moz-FD505E54.hsd1.ca.comcast.net) (Quit: zzz)
[06:01:39] <klutzy> my understanding is STM is a language-level support which hides lock stuff from programmer
[06:02:08] <klutzy> like tasks hides explicit thread stuff. but maybe I'm wrong :p
[06:03:06] <strcat> rusti: fmt!("%?", 2)
[06:03:07] -rusti- ~"2"
[06:03:08] <strcat> rusti: fmt!("%?", 2, 2)
[06:03:08] -rusti- <anon>:5:9: 6:5 error: too many arguments to fmt!. found 3, expected 2
[06:03:08] -rusti- <anon>:5          fmt!("%?", 2, 2)
[06:03:08] -rusti- <anon>:6     };
[06:03:08] -rusti- application terminated with error code 101
[06:03:23] <strcat> rusti: fmt!("%?", 2, ())
[06:03:23] -rusti- <anon>:5:9: 6:5 error: too many arguments to fmt!. found 3, expected 2
[06:03:23] -rusti- <anon>:5          fmt!("%?", 2, ())
[06:03:23] -rusti- <anon>:6     };
[06:03:24] -rusti- application terminated with error code 101
[06:03:33] <strcat> rusti: fmt!("", println("foo"))
[06:03:34] -rusti- ~""
[06:03:37] <strcat> hehe
[06:03:40] <strcat> rusti: fmt!("", 5)
[06:03:41] -rusti- ~""
[06:03:47] <strcat> rusti: format!("", 5)
[06:03:47] -rusti- <anon>:5:21: 5:22 error: argument never used
[06:03:47] -rusti- <anon>:5          format!("", 5)
[06:03:48] -rusti-                               ^
[06:03:48] -rusti- error: aborting due to previous error
[06:03:48] -rusti- application terminated with error code 101
[06:04:48] *** Joins: lenstr (lenstr@CD7D5ABA.83A99F98.85938D85.IP)
[06:05:54] *** Quits: lenstr (lenstr@CD7D5ABA.83A99F98.85938D85.IP) (Client exited)
[06:07:10] *** Joins: dranov (dranov@F5E1B4B2.15B0D01D.D731B824.IP)
[06:08:11] *** Joins: Jesin (Jessin_@moz-A680C20B.cc.lehigh.edu)
[06:10:30] <bjz_> dbaupp: so you can't deriving(Eq) structs with fixed length vectors?
[06:11:19] <strcat> fixed-length vectors have no methods
[06:11:31] <strcat> :s
[06:11:42] <strcat> you'd have to impl them on specific sizes
[06:12:20] * strcat thinks we should throw a lang item on Clone, and lazily output the clone implementations necessary for fixed-size vecs of T: Clone per-crate
[06:12:46] <strcat> even with simple numbers in the type system, you would need a "wildcard" number
[06:13:47] *** Joins: dymk (dymk@moz-775F067F.client.dyn.strong-sf34.as22781.net)
[06:14:11] <dymk> hello!
[06:14:12] <bjz_> dymk: hoy
[06:14:17] <dymk> ahoy
[06:14:37] <dymk> Fistly, great job on Rust, I'm always impressed to see the number of PRs coming from you
[06:14:43] <bjz_> dymk: notice we have ~270 folks online ;)
[06:15:08] <dymk> bjz_, indeed. What about it? 
[06:15:32] <bjz_> dymk: just fun to see the community growing
[06:15:46] <dymk> bjz_, oh no doubt :) 
[06:15:51] <bjz_> it was around 200 for a while there
[06:16:09] <bjz_> dymk: anyway, you had a question?
[06:16:11] * dymk gears up to dust off the old rust repo
[06:16:33] <dymk> bjz_, right, what's performance looking like in release mode in comparison with C++ for iterators? 
[06:16:34] <bjz_> we don't have incoming anymore, all the latest stuff is on master
[06:16:47] <dymk> Eg, is LLVM generating equivalent code for simple loops? 
[06:16:49] <bjz_> dymk: strcat is the wizard behind the iterators
[06:16:57] <strcat> dymk: it's equivalent in performance except for one issue
[06:17:03] <bjz_> dymk: I believe it vectorises
[06:17:11] *** Quits: DAddYE (DAddYE@moz-98D3933F.hsd1.ca.comcast.net) (Connection reset by peer)
[06:17:17] <dymk> bjz_, can you clarify what you mean by that, and how it would affect performance? 
[06:17:21] <strcat> LLVM's loop vectorization has special cased pointer induction for the C++ iterator pattern, and it doesn't pick up most of rust's iterators
[06:17:29] <strcat> it's an LLVM issue
[06:17:31] <bjz_> dymk: the iterator struct falls away at compile time
[06:17:34] *** Joins: DAddYE (DAddYE@moz-98D3933F.hsd1.ca.comcast.net)
[06:17:38] <bjz_> strcat: ahh
[06:17:51] <strcat> vectorization is about making it use SSE, AVX, etc.
[06:17:51] <dymk> strcat, Okay, but a fix is in the pipeline for LLVM though? 
[06:17:53] <strcat> automatically
[06:18:16] <bjz_> dymk: seems to be something that will be fixable
[06:18:19] <strcat> dymk: well it's not exactly in the pipeline but it would be accepted if someone were to implement it
[06:18:28] <strcat> it's not incredibly hard, but not exactly easy either
[06:18:45] <strcat> anyway that's just an issue for vectorization
[06:18:46] <dymk> strcat, oh, well, perhaps a good project for me to dig into before college starts then
[06:19:08] <bjz_> dymk: would be cool to have a helping hand!
[06:19:23] * bjz_ doesn't know much about iterators
[06:19:37] <dymk> Are there any particular resources I should look at to get introduced to these things? 
[06:20:57] <dymk> I've used Rust in the past, but that was at 0.6
[06:20:58] *** Joins: Infiltrator (Infiltrato@4669028E.25A9890C.4B4F1E7A.IP)
[06:21:09] <dymk> Ah, another one comes to the dark side
[06:21:20] <Infiltrator> You wish.  :)
[06:21:31] <dymk> > implying I've already ported DIQS to Rust
[06:21:38] *** Joins: bjz (brendanzab@B398BE78.F804C29E.D35A31DF.IP)
[06:21:42] *** Quits: bjz_ (brendanzab@B398BE78.F804C29E.D35A31DF.IP) (Connection reset by peer)
[06:21:50] <strcat> dymk: it's *possible* that fiddling with the iterator impl from the rust side would fix the issue anyway
[06:21:54] <bjz> dymk: the cool thing is that rustc knows lots more about lifetimes than C or C++ compilers will ever be able to. There is lots of scope for potential optimisations that *could* see us beat C and C++ in some circumstances.
[06:21:55] <Infiltrator> I'm just here to spy...  >>.>>
[06:21:55] <strcat> I haven't looked too hard into it
[06:22:04] <bjz> Infiltrator: heh, the name suits
[06:22:12] <Infiltrator> It does.  :P
[06:22:15] <bjz> Infiltrator: welcome!
[06:22:17] <strcat> dymk: but basically, the rust iterator does a current == end check *first*, since it has to remain memory safe when it's finished
[06:22:23] <strcat> and LLVM is just unhappy about the order, afaict
[06:22:27] *** Joins: lenstr (lenstr@CD7D5ABA.83A99F98.85938D85.IP)
[06:22:29] <strcat> since it's so special-cased for C++ iterators
[06:22:35] <Infiltrator> I've put too much effort into D, though, to consider another switch.
[06:22:38] <dymk> bjz, Infiltrator is my main man for keeping me from going on a shooting spree when DIQS doens't work
[06:22:49] *** Joins: doomlord (doomlod@moz-13E69BC8.range86-180.btcentralplus.com)
[06:23:01] <bjz> dymk: the tutorial is a good place to start to get up to date: http://static.rust-lang.org/doc/tutorial.html
[06:23:16] <bjz> dymk: it doesn't have evereything in this cycle though
[06:23:22] <Infiltrator> dymk: Wait, I'm stopping you from doing that?  I didn't know that I was so uncool.  :(
[06:23:36] <dymk> three in a row, I feel so popular
[06:23:40] <bjz> Infiltrator: yeah it's tough when you have a lot of code invested in a lang
[06:23:44] <dymk> strcat, Alright, that basically makes sense
[06:24:15] <strcat> dymk: on the positive side, when comparing loops it can't vectorize (most loops), it's equivalent in perf
[06:24:21] <dymk> bjz, Has file I/O been implemented yet with the new RT? 
[06:24:28] <strcat> std::rt::io
[06:24:34] <dymk> but it actually works? 
[06:24:34] <bjz> Infiltrator: There's also the mental shift. It was hard for me moving from D, accepting the lack of CTFE etc
[06:24:37] <strcat> dymk: yes
[06:24:43] <strcat> dymk: it has a pretty immature API
[06:24:44] <dymk> strcat, yay! 
[06:24:45] <strcat> but it works :)
[06:24:49] <dymk> good enough for me
[06:25:05] <dymk> bjz, CTFE has spoiled me like no other
[06:25:13] <strcat> bjz: the temporary lack of user-defined syntax exts ;P
[06:25:58] <bjz> strcat: but the ability to call *any* pure function at compile time is mighty beutiful
[06:26:08] <strcat> we don't have purity atm though
[06:26:15] <bjz> yeah
[06:26:16] <strcat> so you'd have to start there
[06:26:38] <bjz> dymk: there's still much to do, D is still much more mature
[06:26:52] <strcat> we could have a nice `pure`, it wouldn't have to forbid mutation through &mut since that's part of the signature
[06:27:04] <dymk> bjz, While that's true, I think Rust has more promise for being an eventually more performant and safe language
[06:27:16] <bjz> dymk: but Rust is fun to work with, in that it is improving quickly
[06:27:31] <dymk> bjz, you were origintally a D dev? 
[06:27:37] <dymk> *originally
[06:27:48] <bjz> dymk: not too deep into it
[06:29:09] <bjz> dymk: I was using it to learn GL and then Rust eventually won me over. The first time I looked at rust, at 0.3, I recoiled in horror
[06:29:28] <bjz> dymk: it has improved a ton in terms of complexity
[06:29:29] <dymk> ha!
[06:29:35] <dymk> well that's good to hear
[06:29:41] <dymk> best resource for becoming aquainted with rustc internals? 
[06:29:55] <strcat> the codebase ;p
[06:29:57] <bjz> dymk: killing argument modes and class based OO won me over
[06:30:19] <dymk> bjz, argument modes? 
[06:30:27] <dymk> strcat, hm, I'll take a look, hopefully it's not like dmd :P
[06:30:31] <bjz> dymk: don't even ask
[06:30:38] <strcat> dymk: well it's written in a nice language, rust
[06:30:41] * dymk backs away slowly 
[06:30:44] <strcat> ;p
[06:31:06] <dymk> strcat, ha! don't think I don't remember the mailing list rants about how terrible rustc internals are! 
[06:31:10] <strcat> the LLVM C bindings are pretty awful, so there's some ugliness in the low-level codegen from that
[06:31:25] <strcat> dymk: well, it depends on when the specific part was (re)written
[06:31:35] <dymk> :P was just kidding
[06:31:36] <bjz> dymk: I still don't fully understand what they were about. just imagine &, &&, +, ++, @ sigils on all arguments
[06:31:45] <strcat> dymk: there are beautiful parts and horrific parts :P
[06:32:01] <dymk> bjz, oh that's totally different from what I was thinking of; I'm gonna not touch that hornets nest
[06:32:02] <bjz> dymk: thankfully things are far simpler now
[06:32:04] <strcat> dymk: https://github.com/mozilla/rust/issues/4707 incomplete list of removed features in the past 7 months
[06:32:04] *** Joins: kgriffs (Adium@moz-7E0D846A.aus1.rackspace.com)
[06:32:14] <strcat> lots.
[06:32:22] <strcat> bjz: modes were really awful :P
[06:32:43] <strcat> they were on the way out when I started using rust though
[06:32:53] <bjz> strcat: same, thankfully
[06:33:08] <dymk> 1.0 is poised for what, Q1 2014? 
[06:33:31] <dymk> also, that's a long list of language features
[06:33:44] *** Quits: kgriffs (Adium@moz-7E0D846A.aus1.rackspace.com) (Ping timeout)
[06:33:45] <dymk> "nested enums" I wonder how that would even work
[06:34:25] <bjz> dymk: no idea
[06:34:33] <strcat> dymk: well rust enums aren't like C enums, they're ADTs
[06:34:48] <bjz> dymk: the name is kinda confusing
[06:34:49] <strcat> so I imagine it means you could define internally used sub-enums
[06:34:53] <dymk> strcat, that's what I'm saying, matching on them would be a nightmare
[06:34:56] <Infiltrator> What is "class based OO" defined as?
[06:35:02] <strcat> dymk: ah, yeah
[06:35:19] <bjz> Infiltrator: you could have fields and methods mixed together
[06:35:28] <dymk> Infiltrator, structs are POD, and you define methods on them as "implementations" of groups of methods called traits
[06:35:44] *** Quits: lenstr (lenstr@CD7D5ABA.83A99F98.85938D85.IP) (Client exited)
[06:36:21] <Infiltrator> I might look into it.
[06:36:47] *** Quits: lkuper (lkuper@moz-C0CD33ED.hsd1.in.comcast.net) (Quit: lkuper)
[06:37:49] <dymk> I'm a little confused as to what Graydon's role is now that he's stepped down
[06:38:00] <dymk> is he still part of the Rust project? 
[06:38:37] <bjz> rusti: struct Vec2 { x: float, y: float } impl Vec { fn dot(&self, other: Vec2) -> float { self.x * other.x + self.y * other.y } let a = Vec { x: 1f, y: 2f }; let b = Vec { x: 3f, y: 4f }; a.dot(&b)
[06:38:37] -rusti- <anon>:8:0: 8:1 error: file ended with unbalanced delimiters
[06:38:37] -rusti- <anon>:8 }
[06:38:37] -rusti-          ^
[06:38:38] -rusti- application terminated with error code 101
[06:38:47] <bjz> rusti: struct Vec2 { x: float, y: float } impl Vec { fn dot(&self, other: Vec2) -> float { self.x * other.x + self.y * other.y } } let a = Vec { x: 1f, y: 2f }; let b = Vec { x: 3f, y: 4f }; a.dot(&b)
[06:39:03] -rusti- pastebinned 8 lines of output: http://ix.io/7KA
[06:39:15] <bjz> rusti: struct Vec2 { x: float, y: float } impl Vec { fn dot(&self, other: Vec2) -> float { self.x * other.x + self.y * other.y } } let a = Vec2 { x: 1f, y: 2f }; let b = Vec2 { x: 3f, y: 4f }; a.dot(&b)
[06:39:35] -rusti- pastebinned 4 lines of output: http://ix.io/7KB
[06:39:35] <dymk> Shouldn't that be impl Vec2?
[06:39:41] <bjz> hah
[06:39:43] <bjz> woops
[06:39:50] <bjz> rusti: struct Vec2 { x: float, y: float } impl Vec2 { fn dot(&self, other: Vec2) -> float { self.x * other.x + self.y * other.y } } let a = Vec2 { x: 1f, y: 2f }; let b = Vec2 { x: 3f, y: 4f }; a.dot(&b)
[06:39:51] <dymk> :P
[06:39:55] -rusti- pastebinned 5 lines of output: http://ix.io/7KC
[06:40:25] <bjz> rusti: struct Vec2 { x: float, y: float } impl Vec2 { fn dot(&self, other: &Vec2) -> float { self.x * other.x + self.y * other.y } } let a = Vec2 { x: 1f, y: 2f }; let b = Vec2 { x: 3f, y: 4f }; a.dot(&b)
[06:40:26] -rusti- 11
[06:40:30] <bjz> phew
[06:40:33] <dymk> lol
[06:40:36] <bjz> Infiltrator: ^
[06:40:52] <bjz> so basically it keeps the data and implementation separate
[06:40:58] *** Joins: glyc (Mibbit@moz-20CEEF38.hsd1.ca.comcast.net)
[06:41:37] <bjz> Infiltrator: you can impl on a new type directly in the module that it is declared in, or you can impl traits on it from anywhere
[06:41:57] <bjz> Infiltrator: like Haskell's type classes
[06:42:27] <bjz> Infiltrator: once they implemented traits, they realised classes were no longer neccesary
[06:43:01] <strcat> and traits are usable as both static/dynamic dispatch
[06:43:14] <strcat> no need for two separate generics systems
[06:43:15] <dymk> strcat, ah that clears up some questions
[06:43:27] <strcat> if you use type bounds + generic parameters, it's all static specialization
[06:43:58] <strcat> if you use a trait *as an object itself*, it's runtime dispatch (a trait object is a ptr to the object, and the trait stuff - virtual fn(s), type descriptor)
[06:44:12] <strcat> (they're a double-ptr)
[06:44:37] *** Joins: lenstr (lenstr@CD7D5ABA.83A99F98.85938D85.IP)
[06:44:41] <dymk> I lost you there
[06:44:48] <strcat> better through example
[06:44:57] <dymk> I think there was a set of slides on this
[06:45:01] <strcat> fn foo<T, U>(a: T, b: T, c: U) -> int
[06:45:50] <bjz> Infiltrator: D allows you to add 'methods' to type using uniform function call syntax. Rust lets you do it via traits.
[06:45:51] <strcat> simple generic fn, valid for any types
[06:46:03] <strcat> fn foo<T: TraitA + TraitB, U>(a: T, b: T, c: U) -> int
[06:46:14] <strcat> that requires that T impl TraitA and TraitB, and you can use their methods
[06:46:27] <strcat> that's just via specialization, no runtime stuff
[06:46:35] <strcat> but... say you actually used
[06:46:37] <strcat> ~TraitA
[06:46:43] *** Quits: lenstr (lenstr@CD7D5ABA.83A99F98.85938D85.IP) (Client exited)
[06:46:48] <strcat> the type isn't statically known
[06:46:57] <dymk> strcat, Lets say TraitA and TraitB both implement foo(&self). What happens when I call a.foo()? 
[06:47:16] <strcat> dymk: you wouldn't be able to call it, if both were in scope
[06:47:16] <dymk> Given a: T where T: TraitA + TraitB
[06:47:19] <dymk> oh
[06:47:39] <carleastlund> Presumably you'd have to write something like TraitA::foo(a)
[06:47:43] <strcat> dymk: trait methods will resolve if the trait is in scope, so they can exist and be used with the same names, but not at the same time
[06:47:52] <bjz> carleastlund: that is the plan
[06:48:01] <bjz> carleastlund: it's not implemented yet thoughj
[06:48:09] <dymk> strcat, Would one be able to do an (a as TraitB) type of thing? 
[06:48:22] <strcat> dymk: yeah, that's for getting a trait object (runtime dispatch)
[06:48:32] <strcat> requires that it be boxed behind a ptr, since the size will not be known
[06:48:38] <strcat> unboxed trait objects don't exist
[06:48:43] <strcat> rusti: ~5 as ~ToStr
[06:48:44] <dymk> Trait object? 
[06:48:54] <strcat> dymk: the trait itself can be used as an object, like that
[06:49:05] <bjz> @/~/&Trait
[06:49:16] <dymk> Is this Niko's "Kinds" thing? 
[06:49:26] <dymk> types of types that is
[06:49:38] * strcat shrugs
[06:49:45] <dymk> mh
[06:49:54] <dymk> rusti never responded back
[06:49:55] <strcat> dymk: it's basically just a Java interface if you use it that way
[06:50:04] <strcat> dymk: yeah because trait objects have no repr representation :)
[06:50:06] <strcat> rusti: 2
[06:50:07] -rusti- 2
[06:50:27] <strcat> it does reflection-based printing
[06:50:29] <dymk> repr? 
[06:50:38] <strcat> rusti: 2.repr()
[06:50:38] -rusti- <anon>:5:9: 6:5 error: type `<VI0>` does not implement any method in scope named `repr`
[06:50:39] -rusti- <anon>:5          2.repr()
[06:50:39] -rusti- <anon>:6     };
[06:50:39] -rusti- error: aborting due to previous error
[06:50:39] -rusti- application terminated with error code 101
[06:50:41] <strcat> er
[06:50:45] <bjz> rusti: let foo = ~5 as ~ToStr; foo.to_str()
[06:50:46] -rusti- ~"5"
[06:50:49] <strcat> not that
[06:50:52] <strcat> oh
[06:50:57] <strcat> you were just continuing from before
[06:51:12] <bjz> yeh
[06:51:15] <strcat> dymk: the std::repr module uses reflection to walk a type + print out the underlying primitive representation
[06:51:22] <strcat> and that's what the bot uses to print types
[06:51:35] <strcat> some things haven't been given an actual print representation there yet
[06:51:38] <bjz> still needs work
[06:51:45] <strcat> lifetimes, functions/closures, trait objects
[06:51:57] <dymk> oh man the seld.be documentation is higher in google search results than doc.rust-lang.org
[06:51:57] <bjz> dymk: there's lots that still needs doing!
[06:52:16] <strcat> dymk: it's going to replace the old rustdoc ;p
[06:52:31] <dymk> haha I hope so :P looks really nice
[06:52:46] <bjz> dymk: rustdoc has been around since before traits were introduced
[06:52:54] <dymk> haven't seen a whole lot of updates on it in the ML
[06:53:07] <dymk> bjz, that sure dates it
[06:53:18] <bjz> dymk: traits need a different approach to documentation
[06:53:38] <bjz> dymk: so far it's pretty difficult to find what type impls what
[06:53:48] <dymk> bjz, very true, yes
[06:54:08] <bjz> dymk: we have a channel #rustdoc-wg for the doc dev
[06:54:13] <dymk> and if D has been any indication, difficult documentation is a productivity killer
[06:54:22] <bjz> yeah
[06:54:54] <dymk> gotta pass out now, thanks for the tour :) will have more questions later I'm sure
[06:55:01] <bjz> I barely use the docs - I just head straight to the source. but we can't expect users to do that
[06:55:03] <bjz> ok
[06:55:04] <dymk> have a good one bjz and strcat 
[06:55:09] <bjz> you to!
[06:55:13] <strcat> \o
[06:55:16] <bjz> thatnks for dropping by
[06:55:20] <dymk> o/ any time
[06:55:32] *** Quits: dymk (dymk@moz-775F067F.client.dyn.strong-sf34.as22781.net) (Quit: Leaving)
[06:56:03] * bjz poached dymk from #d
[06:56:10] <bjz> :P
[06:56:56] <Eridius> rusti: mod foo { fn foo() -> ~str { ~"foo" } } foo:foo()
[06:56:57] -rusti- <anon>:5:52: 5:53 error: expected one of `; }` but found `:`
[06:56:57] -rusti- <anon>:5          mod foo { fn foo() -> ~str { ~"foo" } } foo:foo()
[06:56:57] -rusti-                                                              ^
[06:56:57] -rusti- application terminated with error code 101
[06:57:00] <Eridius> rusti: mod foo { fn foo() -> ~str { ~"foo" } } foo::foo()
[06:57:00] * strcat just brainwashes people in the few private channels he's in
[06:57:00] -rusti- <anon>:5:49: 5:57 error: unresolved name `foo::foo`.
[06:57:01] -rusti- <anon>:5          mod foo { fn foo() -> ~str { ~"foo" } } foo::foo()
[06:57:01] -rusti-                                                           ^~~~~~~~
[06:57:01] -rusti- error: aborting due to previous error
[06:57:03] -rusti- application terminated with error code 101
[06:57:20] <Eridius> hrm, I thought parents were supposed to be able to see their children's private items. Is that wrong, or just buggy?
[06:57:23] <strcat> rusti: range(0, 5).skip(1).map(|x| x * 2)
[06:57:30] <strcat> stupid ix.io
[06:57:39] -rusti- pastebinned 1 lines of output: http://ix.io/7KD
[06:57:56] *** Joins: lenstr (lenstr@CD7D5ABA.83A99F98.85938D85.IP)
[06:58:40] <strcat> would be nice to make sure repr always outputs valid rust and then run it through a *working* pretty printer
[06:58:41] <strcat> ;p
[07:01:16] <Eridius> strcat: I'm thinking I should move path2::PosixPath into path2::posix::Path and path2::WindowsPath into path2::windows::Path. My only concern is that this will make the documentation a bit harder to go through. Any thoughts?
[07:01:20] <Eridius> (this is for my path rewrite)
[07:02:35] *** Quits: tikue_ (tkuehn@moz-424BC304.hsd1.pa.comcast.net) (Quit: tikue_)
[07:02:49] * strcat doesn't know
[07:03:11] <Eridius> rusti: fn foo() -> ~str { ~"yay" } mod bar { pub fn bar() -> ~str { super::foo() } } bar::bar()
[07:03:11] -rusti- <anon>:5:70: 5:80 error: unresolved name `super::foo`.
[07:03:11] -rusti- <anon>:5          fn foo() -> ~str { ~"yay" } mod bar { pub fn bar() -> ~str { super::foo() } } bar::bar()
[07:03:12] -rusti-                                                                                ^~~~~~~~~~
[07:03:12] -rusti- error: aborting due to previous error
[07:03:12] -rusti- application terminated with error code 101
[07:03:17] <Eridius> rusti: fn foo() -> ~str { ~"yay" } mod bar { pub fn bar() -> ~str { ::foo() } } bar::bar()
[07:03:17] -rusti- <anon>:5:70: 5:75 error: unresolved name `foo`.
[07:03:18] -rusti- <anon>:5          fn foo() -> ~str { ~"yay" } mod bar { pub fn bar() -> ~str { ::foo() } } bar::bar()
[07:03:18] -rusti-                                                                                ^~~~~
[07:03:21] -rusti- error: aborting due to previous error
[07:03:23] -rusti- application terminated with error code 101
[07:03:23] <strcat> Eridius: how about having a single path::Path thing, and putting those in submodules
[07:03:32] <strcat> as essentially implementation details
[07:03:41] <Eridius> strcat: path::Path is a pub type that's equal to either PosixPath or WindowsPath depending on platform
[07:03:59] *** Quits: glyc (Mibbit@moz-20CEEF38.hsd1.ca.comcast.net) (Quit: http://www.mibbit.com ajax IRC Client)
[07:04:01] <strcat> well that's perfect then ;p
[07:04:21] <Eridius> however, the actual impls of PosixPath and WindowsPath are useful because it's easier to say Path::new() than using GenericPath::from_str()
[07:07:28] <bjz> Eridius: agreed. that GenericPath::from_str should be FromStr::from_str, but who wants to type that?
[07:07:35] *** Joins: txdv (quassel@966F3542.3BA477DA.14C26596.IP)
[07:07:35] <Eridius> bjz: well that's also implemented
[07:07:51] <Eridius> but FromStr::from_str() returns an Option, and GenericPath::from_str() uses a condition
[07:08:01] <bjz> ahh, interesting
[07:08:13] <bjz> didn't know that
[07:08:27] <strcat> Eridius: why a condition? how does it actually let you handle it?
[07:08:38] <Eridius> also PosixPaths are backed by [u8], so PosixPath::new() actually takes a &[u8], and GenericPath has ::from_vec()
[07:08:50] <Eridius> strcat: the only failure case for PosixPath is if there's a null byte
[07:08:56] *** Quits: carleastlund (cce@moz-C8071335.c3-0.smr-ubr1.sbo-smr.ma.cable.rcn.com) (Quit: carleastlund)
[07:08:58] <Eridius> for Windows, it's no null byte and must be valid UTF-8
[07:09:14] <strcat> just kind of sucks that runtime-less rust would need a new path library
[07:09:45] <Eridius> oh hrm, didn't think about that. Although conversion of vecs to strs already has condition stuff (because str uses a condition)
[07:09:49] <bjz> Eridius: could you have a Path newtype struct?
[07:09:56] <Eridius> why a newtype struct?
[07:10:15] <strcat> Eridius: yeah, but str has alternatives to that
[07:10:18] <bjz> that way you could get Path::new
[07:10:22] <strcat> as long as you provide a FromStr impl it's fine
[07:10:43] <Eridius> bjz: I'm going to define the same ::new() method on both PosixPath and WindowsPath, as well as the same ::from_str(), so you can still say Path::new()
[07:10:47] <strcat> although it also needs conversion from bytes
[07:10:54] <strcat> in fact that's probably the primary one you want
[07:11:06] <Eridius> strcat: PosixPath is backed by ~[u8], so the byte methods are the primary ones
[07:11:24] <Eridius> and e.g. .filename_str() returns an Option<&str>
[07:11:42] <strcat> but what if I need to handle any filenames, on both windows/posix?
[07:12:03] <Eridius> there's a trait GenericPath (just like path has) that defines the full set of methods. It's got vec and str variants for everything
[07:12:10] <strcat> ah
[07:12:14] <strcat> perfect then
[07:12:20] <Eridius> returning a vec always succeeds, returning a str uses Option<> (but on WindowsPath it will always be Some)
[07:13:15] <Eridius> I'm still not 100% convinced that backing WindowsPath with a ~str is a good idea, but Windows paths apparently need to be valid unicode
[07:13:17] *** Joins: azita (Azita@moz-C1FB2A8.hsd1.ca.comcast.net)
[07:13:26] <Eridius> (since the Windows APIs apparently take *WCHARs)
[07:14:23] <Eridius> strcat: presumably a runtime-less rust would just turn conditions into immediate failure, right?
[07:14:34] *** Quits: anri (solancile@moz-E49E7C4B.hsd1.wa.comcast.net) (Quit: anri)
[07:14:39] <strcat> Eridius: well into abort()
[07:15:00] *** Joins: mindcat (mindcat@CFDC42C8.DC005319.857BDFA9.IP)
[07:15:03] <strcat> it would bring down the whole process, even if you were using threads
[07:15:03] <Eridius> right. So you can always check for the failure condition manually if you want before calling something that could fail
[07:15:41] <Eridius> only the methods that create a Path, or that modify one, can fail. The getters never will (because they use Option)
[07:16:12] <Eridius> for converting a &str to a Path safely, FromStr::from_str() can be used to get an Option. However there's no current way to transform a &[u8] into an Option<Path>; the relevant methods use conditions
[07:16:17] * strcat doesn't have a very strong opinion on it for this case
[07:16:32] <Eridius> I'm not sure if it's worth adding some sort of ::from_vec_opt() just for the case of a runtimeless rust
[07:16:51] <strcat> Eridius: or the case where you actually want to handle the error conveniently
[07:16:54] <Eridius> that can always be added later anyway, if it's determined to be worthwhile
[07:17:24] <Eridius> hrm, maybe I should add the opt variants then
[07:17:48] * strcat shrugs
[07:19:51] *** Quits: jaen (jaen@moz-E0979827.copit.pl) (Ping timeout)
[07:22:36] *** Quits: strcat (strcat@moz-54F7FD49.cpe.net.cable.rogers.com) (Quit: sleep)
[07:30:32] *** Joins: Palmik (palmik@moz-CC484FDD.tmcz.cz)
[07:32:25] *** Joins: kgriffs (Adium@moz-7E0D846A.aus1.rackspace.com)
[07:32:27] *** Quits: thesnowdog (doug@15B51297.CDB23781.6F17036B.IP) (Connection reset by peer)
[07:36:47] *** Joins: thesnowdog (doug@15B51297.CDB23781.6F17036B.IP)
[07:36:59] *** Quits: azita (Azita@moz-C1FB2A8.hsd1.ca.comcast.net) (Quit: azita)
[07:37:23] *** Quits: int3_ (int3_@moz-ABE52D50.hsd1.ca.comcast.net) (Client exited)
[07:37:43] *** Joins: int3_ (int3_@moz-ABE52D50.hsd1.ca.comcast.net)
[07:38:15] *** Quits: kgriffs (Adium@moz-7E0D846A.aus1.rackspace.com) (Ping timeout)
[07:39:31] *** Quits: int3_ (int3_@moz-ABE52D50.hsd1.ca.comcast.net) (Ping timeout)
[07:41:17] <Eridius> wow, somehow I keep typing my type signature as Some<foo> instead of Option<foo>
[07:42:09] *** Joins: int3_ (int3_@moz-ABE52D50.hsd1.ca.comcast.net)
[07:44:10] <bjz> rusti: static F: @fn() = f; fn f() {}
[07:44:11] -rusti- <anon>:5:27: 5:28 error: mismatched types: expected `@fn:'static()` but found `extern "Rust" fn()` (expected fn but found extern fn)
[07:44:11] -rusti- <anon>:5          static F: @fn() = f; fn f() {}
[07:44:11] -rusti-                                     ^
[07:44:11] -rusti- error: aborting due to previous error
[07:44:12] -rusti- application terminated with error code 101
[07:44:19] <bjz> rusti: static F: @fn() = @f; fn f() {}
[07:44:21] -rusti- <anon>:5:27: 5:29 error: mismatched types: expected `@fn:'static()` but found `@extern "Rust" fn()` (expected fn but found @-ptr)
[07:44:21] -rusti- <anon>:5          static F: @fn() = @f; fn f() {}
[07:44:21] -rusti-                                     ^~
[07:44:21] -rusti- error: aborting due to previous error
[07:44:21] -rusti- application terminated with error code 101
[07:44:40] <bjz> rusti: static F: extern fn() = f; fn f() {}
[07:44:42] -rusti- ()
[07:45:29] <bjz> rusti: static mut F: extern fn() = f; fn f() {}; F = || println("hi"); unsafe { F() }
[07:45:30] -rusti- <anon>:5:53: 5:72 error: mismatched types: expected `extern "Rust" fn()` but found `&fn<no-bounds>()` (expected extern fn but found fn)
[07:45:30] -rusti- <anon>:5          static mut F: extern fn() = f; fn f() {}; F = || println("hi"); unsafe { F() }
[07:45:30] -rusti-                                                               ^~~~~~~~~~~~~~~~~~~
[07:45:30] -rusti- error: aborting due to previous error
[07:45:32] -rusti- application terminated with error code 101
[07:45:38] <bjz> :/
[07:52:32] *** Joins: squiddy (squiddy@moz-B76B072D.adsl.alicedsl.de)
[07:52:35] *** Joins: sebcrozet (sebcrozet@moz-6DA639AF.w80-13.abo.wanadoo.fr)
[07:53:01] *** Joins: jviereck (Adium@moz-1B04BEE6.dip0.t-ipconnect.de)
[07:56:16] <Eridius> rusti: fn foo(&c: char) -> bool { c == 'a' } let x = 'a'; foo(&x)
[07:56:30] -rusti- pastebinned 8 lines of output: http://ix.io/7KE
[07:56:40] <Eridius> rusti: fn foo(&c: &char) -> bool { c == 'a' } let x = 'a'; foo(&x)
[07:56:42] -rusti- true
[07:57:03] <Eridius> rusti: let c = 'a'; printfln!(&(c as u8))
[07:57:04] -rusti- &97u8
[07:57:04] -rusti- ()
[07:57:26] <bjz> rusti: static F: &fn() = f; fn f() {}
[07:57:27] -rusti- <anon>:5:19: 5:24 error: Illegal anonymous lifetime: only 'static is allowed here
[07:57:27] -rusti- <anon>:5          static F: &fn() = f; fn f() {}
[07:57:27] -rusti-                             ^~~~~
[07:57:27] -rusti- error: aborting due to previous error
[07:57:27] -rusti- application terminated with error code 101
[07:57:36] <bjz> rusti: static F: &'static fn() = f; fn f() {}
[07:57:37] -rusti- <anon>:5:35: 5:36 error: mismatched types: expected `&'static fn<no-bounds>()` but found `extern "Rust" fn()` (expected fn but found extern fn)
[07:57:37] -rusti- <anon>:5          static F: &'static fn() = f; fn f() {}
[07:57:37] -rusti-                                             ^
[07:57:37] -rusti- error: aborting due to previous error
[07:57:37] -rusti- application terminated with error code 101
[07:57:55] <bjz> rusti: static F: &'static fn() = || println("hoy"); fn f() {}
[07:57:55] -rusti- <anon>:5:33: 5:53 error: constant contains unimplemented expression type
[07:57:55] -rusti- <anon>:5          static F: &'static fn() = || println("hoy"); fn f() {}
[07:57:55] -rusti-                                           ^~~~~~~~~~~~~~~~~~~~
[07:57:55] -rusti- error: aborting due to previous error
[07:57:56] -rusti- application terminated with error code 101
[07:58:05] <bjz> :P
[07:58:12] <Eridius> o_O
[07:58:59] *** Quits: nsf (nsf@moz-EEF3238A.convex.ru) (Quit: WeeChat 0.4.1)
[08:00:20] <Eridius> rusti: 0x80 as char
[08:00:21] -rusti- '\x80'
[08:00:43] *** Joins: squiddy_ (squiddy@moz-CB1FFF0E.adsl.alicedsl.de)
[08:01:40] *** Quits: squiddy (squiddy@moz-B76B072D.adsl.alicedsl.de) (Ping timeout)
[08:03:28] <unfoldl> Will Rust make a copy of both the Wrap objects whenever add() is called in this? https://gist.github.com/c50beba3eaddbb237693
[08:04:47] <Eridius> unfoldl: other needs to be &Wrap
[08:04:59] <Eridius> and self needs to be &self
[08:05:06] <Eridius> which means you want **self + **other
[08:05:18] <unfoldl> Eridius: yes.. but the current code _will_ make a copy, yes?
[08:05:35] <Eridius> actually let me take that back. This isn't an impl of Add, it's your own function named add(). So do whatever you want
[08:05:40] <Eridius> and no, it won't copy. It will consume
[08:05:53] <Eridius> it will move both the receiver and the argument in, and return an int. You can't re-use the Wraps after
[08:06:27] <Eridius> rusti: struct Wrap(int); impl Wrap { fn add(self, other: Wrap) -> int { *self + *other } } let (a,b) = (Wrap(10), Wrap(20)); (a+b, a, b)
[08:06:27] -rusti- <anon>:5:128: 5:131 error: binary operation + cannot be applied to type `main::Wrap`
[08:06:28] -rusti- <anon>:5          struct Wrap(int); impl Wrap { fn add(self, other: Wrap) -> int { *self + *other } } let (a,b) = (Wrap(10), Wrap(20)); (a+b, a, b)
[08:06:28] -rusti-                                                                                                                                          ^~~
[08:06:28] -rusti- error: aborting due to previous error
[08:06:29] -rusti- application terminated with error code 101
[08:06:37] <Eridius> rusti: struct Wrap(int); impl Wrap { fn add(self, other: Wrap) -> int { *self + *other } } let (a,b) = (Wrap(10), Wrap(20)); (a.add(b(, a, b)
[08:06:38] -rusti- <anon>:6:4: 6:5 error: incorrect close delimiter: `}`
[08:06:38] -rusti- <anon>:6     };
[08:06:38] -rusti-              ^
[08:06:38] -rusti- application terminated with error code 101
[08:06:40] <Eridius> rusti: struct Wrap(int); impl Wrap { fn add(self, other: Wrap) -> int { *self + *other } } let (a,b) = (Wrap(10), Wrap(20)); (a.add(b), a, b)
[08:06:41] -rusti- (30, main::Wrap{__field__: 10}, main::Wrap{__field__: 20})
[08:06:47] <Eridius> well huh, that should have moved
[08:07:00] <Eridius> maybe newtype structs around primitives copies after all, just like it copies primitives?
[08:07:42] <Eridius> unfoldl: I guess that works, but only because int is implicitly copied. It would presumably fail if you wrapped, say, ~int
[08:08:01] <Eridius> rusti: struct Wrap(~int); impl Wrap { fn add(self, other: Wrap) -> int { **self + **other } } let (a,b) = (Wrap(~10), Wrap(~20)); (a.add(b), a, b)
[08:08:07] -rusti- pastebinned 14 lines of output: http://ix.io/7KF
[08:08:17] <Eridius> yep, there's the "use of moved value" error
[08:08:27] <unfoldl> ah, got it
[08:09:04] <Eridius> unfoldl: your newtype struct has no runtime overhead, it's in-memory representation is literally just the int. Assuming you really are newtyping an int, then that's fine
[08:09:16] <Eridius> but if you're wrapping anything else, you should impl the Add trait instead of making your own .add() method
[08:09:38] <Eridius> you can even return an int like you are there, by impling Add<Wrap,int>
[08:10:55] *** Quits: sebcrozet (sebcrozet@moz-6DA639AF.w80-13.abo.wanadoo.fr) (Ping timeout)
[08:11:49] *** Quits: alisdair (textual@1697D94C.7742FB18.FBC8476D.IP) (Quit: My MacBook Pro has gone to sleep. ZZZzzzâ€¦)
[08:17:20] *** Quits: KindOne (KindOne@moz-2EFADB6F.dynamic.ip.windstream.net) (Ping timeout)
[08:19:53] *** Joins: maik (maik___@moz-A7524DA9.dip0.t-ipconnect.de)
[08:21:18] *** Joins: KindOne (KindOne@moz-5BB37AD7.dynamic.ip.windstream.net)
[08:24:04] *** Joins: SingingBoyo (brandon@4DF3381A.51F4D838.4F048BDC.IP)
[08:27:41] *** Quits: maik (maik___@moz-A7524DA9.dip0.t-ipconnect.de) (Ping timeout)
[08:28:31] *** Joins: sebcrozet (sebcrozet@moz-C27D92D8.w193-252.abo.wanadoo.fr)
[08:33:26] *** Joins: HollyRain (HollyRain@moz-50A83091.dyn.user.ono.com)
[08:35:22] *** Quits: lenstr (lenstr@CD7D5ABA.83A99F98.85938D85.IP) (Client exited)
[08:35:38] *** Quits: int3_ (int3_@moz-ABE52D50.hsd1.ca.comcast.net) (Client exited)
[08:35:58] *** Joins: int3_ (int3_@moz-ABE52D50.hsd1.ca.comcast.net)
[08:36:57] *** Joins: lenstr (lenstr@CD7D5ABA.83A99F98.85938D85.IP)
[08:37:22] *** Joins: kgriffs (Adium@moz-7E0D846A.aus1.rackspace.com)
[08:37:46] *** Quits: int3_ (int3_@moz-ABE52D50.hsd1.ca.comcast.net) (Ping timeout)
[08:38:24] *** Joins: spider-mario (spidermari@moz-81131DB6.fbx.proxad.net)
[08:38:59] *** Joins: Ms2ger (Ms2ger@F84917BA.3387515C.187A1082.IP)
[08:39:02] *** Quits: kgriffs (Adium@moz-7E0D846A.aus1.rackspace.com) (Ping timeout)
[08:39:28] *** Quits: lenstr (lenstr@CD7D5ABA.83A99F98.85938D85.IP) (Client exited)
[08:44:33] *** Quits: SingingBoyo (brandon@4DF3381A.51F4D838.4F048BDC.IP) (Ping timeout)
[08:47:44] *** Quits: ssutch (samuelsutc@moz-DFB7649C.hsd1.ca.comcast.net) (Quit: ssutch)
[08:49:47] *** Quits: HollyRain (HollyRain@moz-50A83091.dyn.user.ono.com) (Quit: bye, bye)
[09:11:17] *** Joins: hellmage (luyun@30A616F7.3444EAD3.75B241AF.IP)
[09:12:58] <zol> How do you use the std::ToStr ?
[09:14:18] *** Joins: drrb (drrb@4D561226.896EE5A.377B9828.IP)
[09:15:53] <nielsle> When I try to build glfw-rs, I get a linking problem. I just reinstalled Debian, so I guess that I am missing a package or something http://kib2.free.fr/pastebin/view_paste.php?id=119
[09:16:19] <nielsle> error: linking with `cc` failed with code 1
[09:16:48] *** Quits: drrb (drrb@4D561226.896EE5A.377B9828.IP) (Ping timeout)
[09:17:01] <Eridius> zol: it should be included in the prelude, so just call .to_str()
[09:17:07] <Eridius> rusti: 3i.to_str()
[09:17:08] -rusti- ~"3"
[09:17:43] <zol> rusti: enum GoalType{GoalThink}; GoalThink.to_str()
[09:17:44] -rusti- <anon>:5:35: 6:5 error: type `main::GoalType` does not implement any method in scope named `to_str`
[09:17:44] -rusti- <anon>:5          enum GoalType{GoalThink}; GoalThink.to_str()
[09:17:44] -rusti- <anon>:6     };
[09:17:44] -rusti- error: aborting due to previous error
[09:17:44] -rusti- application terminated with error code 101
[09:17:52] <Eridius> zol: you didn't implement it
[09:18:10] <Eridius> you can derive it though, which is easy
[09:18:18] <Eridius> rusti: #[deriving(ToStr)] enum GoalType{GoalThink}; GoalThink.to_str()
[09:18:19] -rusti- <anon>:5:54: 6:5 error: type `main::GoalType` does not implement any method in scope named `to_str`
[09:18:19] -rusti- <anon>:5          #[deriving(ToStr)] enum GoalType{GoalThink}; GoalThink.to_str()
[09:18:19] -rusti- <anon>:6     };
[09:18:19] -rusti- error: aborting due to previous error
[09:18:20] -rusti- application terminated with error code 101
[09:18:22] <Eridius> o_O
[09:20:17] *** Joins: Cromulent (Cromulent@moz-983B638D.cable.virginmedia.com)
[09:20:20] <Eridius> I don't know why deriving didn't work, but you could always implement it manually
[09:22:02] <zol> Eridius: You mean, impl GoalType { fn to_str(&self) -> ~str { match *self { GoalThink => ~"GoalThink" }}} ?
[09:22:50] <Eridius> no I don't. I mean impl ToStr for GoalType
[09:23:15] <nielsle> rusti: #[deriving(ToStr)] enum GoalType{GoalThink}; let x = GoalThink; x.to_str() // Just testing
[09:23:16] -rusti- <anon>:5:73: 6:5 error: type `main::GoalType` does not implement any method in scope named `to_str`
[09:23:16] -rusti- <anon>:5          #[deriving(ToStr)] enum GoalType{GoalThink}; let x = GoalThink; x.to_str() // Just testing
[09:23:16] -rusti- <anon>:6     };
[09:23:16] -rusti- error: aborting due to previous error
[09:23:17] -rusti- application terminated with error code 101
[09:23:43] <Eridius> rusti: #[deriving(ToStr)] struct Foo; Foo.to_str()
[09:23:43] -rusti- <anon>:5:40: 6:5 error: type `main::Foo` does not implement any method in scope named `to_str`
[09:23:43] -rusti- <anon>:5          #[deriving(ToStr)] struct Foo; Foo.to_str()
[09:23:44] -rusti- <anon>:6     };
[09:23:44] -rusti- error: aborting due to previous error
[09:23:44] -rusti- application terminated with error code 101
[09:25:10] <nielsle> rusti: #[deriving(Eq)] struct A{x:int}; let foo=A{x:2};let bar =A{x:2}; foo==bar
[09:25:11] -rusti- <anon>:5:74: 5:82 error: binary operation == cannot be applied to type `main::A`
[09:25:11] -rusti- <anon>:5          #[deriving(Eq)] struct A{x:int}; let foo=A{x:2};let bar =A{x:2}; foo==bar
[09:25:11] -rusti-                                                                                    ^~~~~~~~
[09:25:11] -rusti- error: aborting due to previous error
[09:25:13] -rusti- application terminated with error code 101
[09:25:29] <Eridius> sure looks like deriving is broken for rusti
[09:25:49] <Eridius> rusti: (); #[deriving(Eq)] struct A{x:int}; let foo=A{x:2}; let bar=A{x:2}; foo==bar
[09:25:49] -rusti- <anon>:5:78: 5:86 error: binary operation == cannot be applied to type `main::A`
[09:25:49] -rusti- <anon>:5          (); #[deriving(Eq)] struct A{x:int}; let foo=A{x:2}; let bar=A{x:2}; foo==bar
[09:25:50] -rusti-                                                                                        ^~~~~~~~
[09:25:50] -rusti- error: aborting due to previous error
[09:25:51] -rusti- application terminated with error code 101
[09:26:09] *** Quits: hellmage (luyun@30A616F7.3444EAD3.75B241AF.IP) (Quit: Leaving.)
[09:26:12] <Eridius> maybe deriving only works at the top level? which would be odd, but plausible
[09:26:29] <nielsle> I don't even  know if macros work on rusti 
[09:26:49] <Eridius> printfln!() works and that's a macro
[09:26:56] <nielsle> Ah
[09:27:31] <Eridius> yep, #[deriving(...)] is broken when used on a type that's defined inside a function
[09:29:35] <Eridius> oh look, issue #4913, filed 7 months ago
[09:32:39] <zol> Another question, if I have struct GoalThink { some_field: SomeType }, and a trait that I want to have a default implementation for a method on some_field for my struct, trait Goal { fn is_someField(&self) -> bool { &self.some_field == some_val} }, how can I accomplish this since I need to make an implementation specifically for my struct? 
[09:33:07] <bjz> nielsle: sorry for the late reply
[09:33:20] <bjz> nielsle: are you using glfw3?
[09:33:20] <zol> Is it possible to make a struct that GoalThink is derived from which Goal has an implementation for?
[09:34:02] <bjz> nielsle: Debian might still have the 2.7 package
[09:34:19] <bjz> just a thought
[09:37:49] *** Joins: kgriffs (Adium@moz-7E0D846A.aus1.rackspace.com)
[09:37:55] *** Joins: nsf (nsf@moz-EEF3238A.convex.ru)
[09:39:29] *** Quits: kgriffs (Adium@moz-7E0D846A.aus1.rackspace.com) (Ping timeout)
[09:44:50] <Infiltrator> I must say, I haven't really been convinced to use rust.  :P
[09:46:00] <zol> Infiltrator: Why not? 
[09:46:32] *** Joins: int3_ (int3_@moz-ABE52D50.hsd1.ca.comcast.net)
[09:47:27] *** Joins: gavinb (gavinb@moz-9EC182F0.lowrp3.vic.optusnet.com.au)
[09:48:13] *** Joins: inf-groupoid (user@580120F5.8ED93E28.1C8C8CE9.IP)
[09:48:20] *** Quits: int3_ (int3_@moz-ABE52D50.hsd1.ca.comcast.net) (Ping timeout)
[09:48:31] *** Quits: Cromulent (Cromulent@moz-983B638D.cable.virginmedia.com) (Quit: KVIrc 4.2.0 Equilibrium http://www.kvirc.net/)
[09:49:33] *** Joins: vodik (simon@moz-CBE4BB13.cable.teksavvy.com)
[09:50:18] <zol> How do you compare a variable with an enumeration element?
[09:50:46] <zol> rusti: enum GoalType { GoalThink, GoalExplore}; let a = GoalThink; a == GoalThink
[09:50:46] -rusti- <anon>:5:69: 5:83 error: binary operation == cannot be applied to type `main::GoalType`
[09:50:47] -rusti- <anon>:5          enum GoalType { GoalThink, GoalExplore}; let a = GoalThink; a == GoalThink
[09:50:47] -rusti-                                                                               ^~~~~~~~~~~~~~
[09:50:47] -rusti- error: aborting due to previous error
[09:50:48] -rusti- application terminated with error code 101
[09:51:13] *** Joins: lenstr (lenstr@CD7D5ABA.83A99F98.85938D85.IP)
[09:52:53] *** Quits: lenstr (lenstr@CD7D5ABA.83A99F98.85938D85.IP) (Ping timeout)
[09:52:56] <sebcrozet> zol: you have to implement Eq for GoalType.
[09:53:10] <sebcrozet> zol: or use #[deriving(Eq)] enum GoalType { ... }
[09:53:42] <doomlord> Infiltrator, you're (a) happy with the mess of header files in C++, happy with code that is hard to debug.. or (b) dont need high performance, happy with GC,
[09:57:13] <bjz> Infiltrator: why?
[09:57:35] <bjz> Infiltrator: at least back up that statement. :)
[10:03:29] <doomlord> many people move from C++ to slower langauges for safety and convinience.rust is trying to combine safety and convinience with high performance, its a very worthwhile project, IMO
[10:04:17] <doomlord> (^ or rather, many people choose other languages and never bother with c++...)
[10:07:11] *** Quits: sully (sully@moz-45967CBE.emarhavil.com) (Ping timeout)
[10:07:21] *** Joins: sully (sully@moz-45967CBE.emarhavil.com)
[10:08:13] *** Joins: fabiand (fabiand@moz-8A783D5B.adsl.alicedsl.de)
[10:10:18] *** Quits: gavinb (gavinb@moz-9EC182F0.lowrp3.vic.optusnet.com.au) (Quit: gavinb)
[10:14:45] <doomlord> heh nothing to back it up what a surprise
[10:16:37] *** Joins: jensnockert (jensnocker@moz-8BE55278.customer.t3.se)
[10:17:27] *** Quits: dranov (dranov@F5E1B4B2.15B0D01D.D731B824.IP) (Client exited)
[10:18:35] *** Joins: HollyRain (HollyRain@moz-50A83091.dyn.user.ono.com)
[10:18:41] *** Parts: HollyRain (HollyRain@moz-50A83091.dyn.user.ono.com) (bye)
[10:19:10] *** Joins: HollyRain (HollyRain@moz-50A83091.dyn.user.ono.com)
[10:20:23] <bjz> doomlord: :)
[10:20:30] *** Quits: eternaleye (eternaleye@moz-76321711.hsd1.wa.comcast.net) (Ping timeout)
[10:21:25] *** Joins: eternaleye (eternaleye@moz-76321711.hsd1.wa.comcast.net)
[10:22:15] *** Joins: q66 (q66@6EE9DE40.46454B5D.33AABD5F.IP)
[10:23:05] *** Quits: eternaleye (eternaleye@moz-76321711.hsd1.wa.comcast.net) (Ping timeout)
[10:24:35] *** Joins: eternaleye (eternaleye@moz-76321711.hsd1.wa.comcast.net)
[10:25:35] <bjz> nielsle: how did you go?
[10:25:41] *** Joins: sigma (sigma@51C589B3.EF2694B5.DFAC6AA7.IP)
[10:31:08] <nielsle> I am back now. 
[10:31:42] <nielsle> I can compile the library, but when I try to compile the examples are not found  by rustpkg. 
[10:32:13] <nielsle> Perhaps I am missing an environment variable or something.
[10:32:38] <nielsle> I had the same problem, when I tried the same directory structure with my own code
[10:33:22] <bjz> nielsle: ok, so you can compile the library now, where as you couldn't before?
[10:34:27] <nielsle> Hmm, sorry I was unclear. I could compile the library all the time, but had problems with examples)
[10:35:48] <bjz> ahh
[10:36:10] <bjz> ok, so did you work out what version of the glfw library you had?
[10:36:22] <bjz> (glfw, not the glfw-rs wrapper)
[10:37:57] <bjz> eh, I'm having trouble building the examples too: task <unnamed> failed at 'index out of bounds: the len is 320986 but the index is 320986', /Users/brendan/dev/rust/rust/src/libextra/ebml.rs:119
[10:38:03] <bjz> (with rustpkg)
[10:38:19] *** Joins: kgriffs (Adium@moz-7E0D846A.aus1.rackspace.com)
[10:38:29] <nielsle>  2.7.2-1 
[10:38:33] <bjz> yep
[10:38:37] <bjz> you need 3
[10:38:40] <bjz> glfw 3
[10:38:44] <nielsle> Ah
[10:38:49] <nielsle> Thanks
[10:38:52] <bjz> np
[10:39:31] <bjz> dang, but rustpkg is giving me a task failure when I try to build the examples :[
[10:39:59] *** Quits: kgriffs (Adium@moz-7E0D846A.aus1.rackspace.com) (Ping timeout)
[10:40:56] <nielsle> Hmm, I think that I saw the rustpkg-error before encountering the glwf-error. 
[10:42:10] <bjz> when I do rustpkg build examples
[10:43:20] *** Joins: donri (dag@moz-9BB61102.tbcn.telia.com)
[10:43:26] <nielsle> I had the same problem in another project: I was hoping that you could help me with rustpkg, but it seems that we have found a bug instead :-)
[10:43:59] *** Joins: Earnestly (earnest@moz-F387F877.dyn.plus.net)
[10:44:36] <bjz> yeah something must have broked
[10:44:48] <bjz> it was working recently
[10:44:55] <bjz> I just updated my rust
[10:46:06] <nielsle> Thanks, for the help.
[10:46:20] <bjz> np, let me know if you have any more issues
[10:46:32] <bjz> shame rustpkg has broken
[10:46:45] <bjz> I'm looking through the current issues list
[10:47:38] <nielsle> It am trying to create a simple example for a bug report.
[10:50:46] <bjz> nielsle: there must be a hole in the rustpkg unit tests somwhere
[10:52:29] <bjz> nielsle: ie. somebody broke something without realising it
[10:53:05] <bjz> nielsle: tjc is the main dude behind rustpkg, but I don't know if he will be on untile the next eork week
[10:53:09] <bjz> *work
[10:54:37] <nielsle> I am not on a tight schedule. So far I write my examples as tests. That seems to work
[10:55:45] <nielsle> But rustpkg will be  nice to have when it is done :-)
[10:57:57] <bjz> aye, it's super nice when it works :P
[11:03:25] *** Quits: sebcrozet (sebcrozet@moz-C27D92D8.w193-252.abo.wanadoo.fr) (Quit: Gone)
[11:03:54] *** Quits: Jesin (Jessin_@moz-A680C20B.cc.lehigh.edu) (Ping timeout)
[11:06:12] <kimundi> r? https://github.com/mozilla/rust/pull/8911
[11:06:17] *** Parts: HollyRain (HollyRain@moz-50A83091.dyn.user.ono.com) (bye)
[11:09:53] *** Joins: BizarreCake (BizarreCak@moz-361FE9B2.dynamic.barak-online.net)
[11:13:46] <klutzy> is newrt fileio supposed to work on windows?
[11:15:08] *** Quits: doomlord (doomlod@moz-13E69BC8.range86-180.btcentralplus.com) (Quit: Leaving)
[11:17:15] *** Joins: doomlord (doomlod@moz-13E69BC8.range86-180.btcentralplus.com)
[11:18:29] *** Quits: fabiand (fabiand@moz-8A783D5B.adsl.alicedsl.de) (Ping timeout)
[11:25:26] *** Quits: sankha93 (Instantbir@7061CD01.D6BD0D91.22D41759.IP) (Quit: Gone to save the world!)
[11:33:23] *** Joins: miza (miza@moz-4DD51325.home.otenet.gr)
[11:38:47] *** Quits: z0w0 (zack@moz-30F36A45.qld.bigpond.net.au) (Client exited)
[11:44:24] * kimundi collects the 10 internet points bblum offered 10h ago
[11:50:11] *** Quits: KindOne (KindOne@moz-5BB37AD7.dynamic.ip.windstream.net) (Ping timeout)
[11:54:07] *** Joins: KindOne (KindOne@moz-70E25CC0.dynamic.ip.windstream.net)
[11:54:53] *** Joins: samx (sami@moz-D9DA5773.dyn.optonline.net)
[11:55:33] *** Quits: samx (sami@moz-D9DA5773.dyn.optonline.net) (Quit: This computer has gone to sleep)
[11:56:59] *** Quits: KindOne (KindOne@moz-70E25CC0.dynamic.ip.windstream.net) (Ping timeout)
[11:59:30] *** Joins: samx (sami@moz-D9DA5773.dyn.optonline.net)
[12:00:12] *** Quits: samx (sami@moz-D9DA5773.dyn.optonline.net) (Quit: This computer has gone to sleep)
[12:01:01] *** Joins: samx (sami@moz-D9DA5773.dyn.optonline.net)
[12:01:07] *** Joins: KindOne (KindOne@moz-8F777F23.dynamic.ip.windstream.net)
[12:01:09] *** Quits: samx (sami@moz-D9DA5773.dyn.optonline.net) (Quit: samx)
[12:02:54] *** Quits: goffrie (goffrie@moz-A24EEB46.dsl.ncf.ca) (Quit: Lost terminal)
[12:04:48] *** Joins: jorendorff (jorendorff@moz-2F32ACA3.hsd1.tn.comcast.net)
[12:06:11] *** Joins: Blub\w (wry@7E3BB9D.71150E1A.237AE2BA.IP)
[12:11:10] *** Joins: nano (nano@moz-74CAD1CA.superkabel.de)
[12:11:38] *** Quits: jviereck (Adium@moz-1B04BEE6.dip0.t-ipconnect.de) (Quit: Leaving.)
[12:13:27] <Palmik> Hi guys. How can I use things from module B in module A considering they are siblings (the A.rs and B.rs are in the same directory)?
[12:14:48] *** Quits: KindOne (KindOne@moz-8F777F23.dynamic.ip.windstream.net) (Ping timeout)
[12:15:04] <dbaupp> kimundi: 1 point per hour, perfect!
[12:16:49] *** Joins: FrozenCow (FrozenCow@moz-B2DF4929.chello.nl)
[12:18:36] *** Joins: KindOne (KindOne@moz-5F9D99F8.dynamic.ip.windstream.net)
[12:19:39] <doomlord> does super::B do it.
[12:19:46] *** Joins: gavinb (gavinb@moz-9EC182F0.lowrp3.vic.optusnet.com.au)
[12:19:48] <kimundi> hehe
[12:20:38] <kimundi> Palmik: Depends on hwo your module heirachy looks like. Files are kind irrelevant for that :) I recommend reading the module tutorial.
[12:21:28] *** Quits: KindOne (KindOne@moz-5F9D99F8.dynamic.ip.windstream.net) (Ping timeout)
[12:21:31] <Palmik> doomlord, kimundi: super:: is indeed what I was looking for.
[12:21:52] <Palmik> I kind of missed the section "Importing names into the local scope"
[12:22:17] <kimundi> He, alright :)
[12:25:03] <dbaupp> kimundi: was https://github.com/mozilla/rust/pull/8911 fun to do?
[12:25:06] * dbaupp hates that work
[12:25:41] *** Joins: KindOne (KindOne@moz-84D9D535.dynamic.ip.windstream.net)
[12:25:54] *** Joins: samx (sami@moz-D9DA5773.dyn.optonline.net)
[12:25:55] <kimundi> dbaupp: The first 400 errors were annoying, then I wrote a ruby script that parses and autocorrects rustc error messages xD
[12:26:47] <dbaupp> kimundi: oh; that's much nicer
[12:27:12] * dbaupp normally just uses `git ls-files -z | xargs -0 sed -i s///`
[12:27:42] <kimundi> It basically just extracts all error spans, and in this case replaced 'span' with 'Span'
[12:28:00] *** Quits: samx (sami@moz-D9DA5773.dyn.optonline.net) (Quit: This computer has gone to sleep)
[12:28:05] <kimundi> I'm thinking about how to make it more generically useful
[12:28:37] <dbaupp> heh, the ultimate dog food: use the spans to correct span to Span
[12:28:45] *** Quits: bjz (brendanzab@B398BE78.F804C29E.D35A31DF.IP) (Quit: Leaving...)
[12:28:46] *** Joins: fabiand (fabiand@moz-8A783D5B.adsl.alicedsl.de)
[12:28:59] <kimundi> The sad thing is that that connection occured far to late to me xD
[12:29:17] *** Joins: Florob (Florob@moz-39532932.de)
[12:29:26] * dbaupp gives that lazy old bors some work to do
[12:29:53] *** Joins: engla (engla@moz-DBD1D96E.cust.bredbandsbolaget.se)
[12:30:29] *** Joins: bjz (brendanzab@B398BE78.F804C29E.D35A31DF.IP)
[12:30:49] *** Joins: ghrust (ghrust@2EE61FCC.6A2AE50.F3114085.IP)
[12:30:49] <ghrust> 01[13rust01] 15bors pushed 0 new commits to 06auto: 02http://git.io/57Nl-g
[12:30:49] *** Parts: ghrust (ghrust@2EE61FCC.6A2AE50.F3114085.IP) ()
[12:30:51] *** Joins: ghrust (ghrust@9C8B94D4.6A2AE50.F3114085.IP)
[12:30:51] <ghrust> 01[13rust01] 15bors pushed 2 new commits to 06auto: 02http://git.io/2ll-LA
[12:30:51] <ghrust> 13rust/06auto 14539f379 15Marvin LÃ¶bel: Modernized a few type names in rustc and syntax
[12:30:51] <ghrust> 13rust/06auto 1466593a7 15bors: auto merge of #8911 : Kimundi/rust/master, r=huonw...
[12:30:52] *** Parts: ghrust (ghrust@9C8B94D4.6A2AE50.F3114085.IP) ()
[12:31:00] *** Quits: KindOne (KindOne@moz-84D9D535.dynamic.ip.windstream.net) (Ping timeout)
[12:31:13] <kimundi> Whew, the bors queue is empty. Fixing rebase conflicts would not be fun with that patch :)
[12:31:41] *** Quits: vodik (simon@moz-CBE4BB13.cable.teksavvy.com) (Ping timeout)
[12:31:53] *** Joins: vodik (simon@moz-CBE4BB13.cable.teksavvy.com)
[12:32:21] *** Joins: maik (maik___@moz-7490859E.dip0.t-ipconnect.de)
[12:32:29] *** Quits: fabiand (fabiand@moz-8A783D5B.adsl.alicedsl.de) (Quit: Verlassend)
[12:33:02] *** Joins: fabiand (fabiand@moz-8A783D5B.adsl.alicedsl.de)
[12:34:30] *** Quits: fabiand (fabiand@moz-8A783D5B.adsl.alicedsl.de) (Client exited)
[12:35:35] *** Joins: samx (sami@moz-D9DA5773.dyn.optonline.net)
[12:36:26] *** Quits: maik (maik___@moz-7490859E.dip0.t-ipconnect.de) (Ping timeout)
[12:36:32] *** Joins: fabiand (fabiand@moz-8A783D5B.adsl.alicedsl.de)
[12:38:56] *** Joins: kgriffs (Adium@moz-7E0D846A.aus1.rackspace.com)
[12:40:37] *** Quits: kgriffs (Adium@moz-7E0D846A.aus1.rackspace.com) (Ping timeout)
[12:43:44] <nielsle> bjz: I didn't end up with a simple example. I think that I will leave to others to file the bug against rustpkg
[12:45:24] *** Quits: samx (sami@moz-D9DA5773.dyn.optonline.net) (Ping timeout)
[12:45:36] *** Joins: samx (sami@moz-D9DA5773.dyn.optonline.net)
[12:46:32] *** Quits: jensnockert (jensnocker@moz-8BE55278.customer.t3.se) (Input/output error)
[12:52:01] <doomlord> heh. just tried to move something arodun and it all falls apart :(
[12:52:31] *** Quits: samx (sami@moz-D9DA5773.dyn.optonline.net) (Quit: This computer has gone to sleep)
[12:52:36] <kimundi> what falls apart?
[12:53:54] <doomlord> i've tried to re-organize my code.. split into more modules - this always seems difficult;
[12:54:02] <doomlord> if i get the modules right first its ok
[12:54:48] *** Joins: Jesin (Jessin_@moz-A680C20B.cc.lehigh.edu)
[12:55:01] <doomlord> i'll hack around a bit more before asking a concrete question.. 
[12:55:04] <kimundi> yeah, than can get complicated fast
[12:55:30] <doomlord> i thought the recent 'super::' might help me clean up / make it easier
[12:56:25] <doomlord> whats happened is i've got too much in my crate root ... main program, a load of utilities, and of course the module imports; so i'm trying to seperate out a root that is just the mod statements, etc...
[12:56:52] <doomlord> but all of a sudden nothing can find anything else
[12:59:53] <doomlord> heh i wondered if 'mod.rs' also worked as a special case for the crate root
[13:00:24] <doomlord> .. such that you could make the modules literally mimick the directory structure
[13:01:34] *** Joins: jaen (jaen@moz-E0979827.copit.pl)
[13:01:37] *** Joins: MrFahrenheit (RageOfThou@3FEF494C.29C984D5.783DEDCA.IP)
[13:02:36] *** Quits: jorendorff (jorendorff@moz-2F32ACA3.hsd1.tn.comcast.net) (Quit: My MacBook Pro has gone to sleep. ZZZzzzâ€¦)
[13:02:56] *** Joins: gavin (gavin@moz-DB4A9C19.scl3.mozilla.com)
[13:03:18] <doomlord> i'll try another approach, moving a small amount out at a time
[13:03:50] <Ms2ger> Modularizing after the fact is always hard :/
[13:04:34] <doomlord> ifyou can't .. you have to correctly estimate sizes before you start coding.. instead of letting modules split as they grow
[13:05:08] <doomlord> intuitively i always throught a generatlized graph of imports would suit that process
[13:05:43] *** Quits: pepper_chico (pepper_chi@EF476D4E.D3DE4871.E4090502.IP) (Quit: My MacBook Pro has gone to sleep. ZZZzzzâ€¦)
[13:08:42] *** Joins: pyrac (pyrac@moz-30AD8801.w90-60.abo.wanadoo.fr)
[13:11:04] <Palmik> Hmm, for some reason this does not work: https://gist.github.com/Palmik/0fbdd72aee76e2af2b2e (replace the '_' in file names by '/').
[13:11:18] <Palmik> Does anyone know what am I doing wrong?
[13:13:19] <engla> Palmik: I think you need to give it an explicit path to have modules in subdirs
[13:13:40] <engla> #[path="interface/a.rs"] pub mod a
[13:13:42] <kimundi> engla: Not really
[13:14:06] <engla> aha
[13:14:16] <kimundi> engla: I tested it, mod a{ mod b { mod c}} will look for a/b/c.rs and a/b/c/mod.rs
[13:14:59] <kimundi> Palmik: what's wrong is the explcict mod a and mod common in their files
[13:15:15] <Palmik> engla: When I do not try to use the CommonType (or import it in a), it compiles fine.
[13:15:18] <kimundi> what you have here results in interface::a::a and interface::common::common
[13:15:29] <Palmik> Aah.
[13:15:36] <kimundi> the content of a .rs file is allways the body of a module
[13:15:53] <engla> and each 'mod' statement creates a new module
[13:16:06] <kimundi> if you do mod a; rustc will look for a.rs and use the content of that file as body for mod a
[13:16:41] <Palmik> You are right... I kind of did not notice that even the tutorial does not include the 'mod ...'
[13:16:46] <Palmik> In the submodules.
[13:16:53] *** Joins: sankha93 (Instantbir@7061CD01.D6BD0D91.22D41759.IP)
[13:17:22] <Palmik> Thanks.
[13:17:23] *** Joins: bytewise (bytewise@moz-4A801D04.unitymediagroup.de)
[13:17:53] <kimundi> That of course also goes for interface.rs itself
[13:18:47] <kimundi> right now you have a crate 'interface' that only contains the public module 'interface' - extern mod interface would give you 'interface::interface' too
[13:19:41] <doomlord> (ok this is going better, moving things out one function at a time..)
[13:20:31] *** Quits: FrozenCow (FrozenCow@moz-B2DF4929.chello.nl) (Ping timeout)
[13:20:38] *** Joins: ajl_ (ajl@moz-F85B6108.student.rit.edu)
[13:21:02] <dbaupp> doomlord: (if you didn't get an answer, mod foo; looks for foo.rs and foo/mod.rs automatically.)
[13:21:23] *** Quits: tavoe (Mibbit@moz-F85B6108.student.rit.edu) (Quit: http://www.mibbit.com ajax IRC Client)
[13:21:26] *** Parts: ajl_ (ajl@moz-F85B6108.student.rit.edu) (Leaving)
[13:21:27] *** Joins: sprocket (Mibbit@moz-D7455E46.skybroadband.com)
[13:21:32] *** Joins: ajl_ (ajl@moz-F85B6108.student.rit.edu)
[13:21:53] *** Quits: mark_edward (quassel@moz-97E995A.hsd1.in.comcast.net) (Ping timeout)
[13:22:09] *** Joins: mark_edward (quassel@moz-97E995A.hsd1.in.comcast.net)
[13:22:55] *** Quits: ajl_ (ajl@moz-F85B6108.student.rit.edu) (Quit: Leaving)
[13:23:03] *** Joins: pepper_chico (pepper_chi@EF476D4E.D3DE4871.E4090502.IP)
[13:23:11] <kimundi> Hm, that's a good question... will 'rustc foo' look for both foo.rs and foo/mod.rs ? Should it? Afaik there was also talks about making the convention for crates lib.rs and main.rs or so
[13:23:23] *** Joins: tavoe (tavoe@moz-F85B6108.student.rit.edu)
[13:24:13] <dbaupp> that convention is what rustpkg looks for
[13:24:22] <dbaupp> so it's already in existence
[13:24:25] <doomlord> if i understood right...  foo/mod.rs lets you mimick the directory structure, which is nice
[13:24:33] <sprocket> Hey guys.  I'm trying to return a list of integer factors from a recursive function, and get the length of that list.  What I'm doing is: enum TupledInt { Nil, int, Cons(int, @TupledInt) }.  Wrote a function which returns the list as expected.  Then wrote extern mod extra; use extra::list::*; let res_len = len(res)
[13:24:43] <sprocket> But TupledInt isn't compatible with list::len.
[13:24:43] <doomlord> so i wondered if you could do the same thing from the crate root
[13:24:46] <sprocket> As I'd hoped.
[13:24:56] <sprocket> Do I need to write this, or is there an easier way?
[13:25:34] <dbaupp> sprocket: what's `res`?
[13:25:44] <sprocket> dbaupp: res is a TupledInt
[13:25:47] <kimundi> sprocket: Well you're defining a completly new type, no wonder an existing library function dosn't know what to do with it :)
[13:25:54] *** Joins: lkuper (lkuper@moz-C0CD33ED.hsd1.in.comcast.net)
[13:26:05] <sprocket> kimundi: right, but I thought Cons was all about creating lists.
[13:26:21] <kimundi> Cons is nothing special
[13:26:22] <sprocket> So I need to impl len for TupledInt, or something like that?
[13:26:27] <dbaupp> yes
[13:26:27] <kimundi> yeah
[13:27:13] *** Joins: jviereck (Adium@moz-1B04BEE6.dip0.t-ipconnect.de)
[13:27:23] <kimundi> sprocket: btw, that enum definition doesn't look right
[13:27:45] <sprocket> kimundi: ahh,OK.  What's wrong with it?
[13:29:06] <kimundi> enum TupledInt { Nil, int, Cons(int, @TupledInt) } - creates three variants of type 'TupleInt': 1. variant 'Nil', 2. variant 'int', 3. variant 'Cons(int, @TupledInt)', where int and @TupledInd are types
[13:29:38] <kimundi> In short, the two 'int' you have there are totoally different things
[13:30:01] <sprocket> kimundi: So I just want two: { Cons(int, @TupledInt), Cons(int, @Nil) } ?
[13:30:05] <kimundi> Of course, that might be intentional, dunno
[13:30:20] <kimundi> No, that would be an error :P
[13:30:27] <kimundi> two identical named enum variants
[13:30:31] <kimundi> you want:
[13:30:42] <kimundi> enum Foo { Nil, Cons(int, @Foo) }
[13:30:58] <sprocket> Ah, that makes sense.
[13:31:07] <kimundi> "either the list is empty, or it contains data and a reference to the next element"
[13:31:19] *** Quits: pepper_chico (pepper_chi@EF476D4E.D3DE4871.E4090502.IP) (Quit: My MacBook Pro has gone to sleep. ZZZzzzâ€¦)
[13:31:33] <sprocket> Another question: how fast is this: returning recursive... tuples, I guess? Compared to returning a single tuple of the right size?
[13:32:07] <sprocket> Or is this actually a singly-linked list, like in lisp?
[13:32:12] <kimundi> In this case, because you go through garbage collected pointers and need to use recursive function calls: quite a bit slower
[13:32:31] <kimundi> It would also be an single linked list, yeah
[13:38:53] *** Joins: lenstr (lenstr@CD7D5ABA.83A99F98.85938D85.IP)
[13:39:14] *** Joins: kgriffs (Adium@moz-7E0D846A.aus1.rackspace.com)
[13:40:45] *** Joins: ghrust (ghrust@79968228.6A2AE50.F3114085.IP)
[13:40:45] <ghrust> 01[13rust01] 15bors merged 06auto into 06master: 02http://git.io/2ll-LA
[13:40:45] *** Parts: ghrust (ghrust@79968228.6A2AE50.F3114085.IP) ()
[13:40:48] <sprocket> Kimundi, dbaupp: Thanks :)
[13:40:54] *** Quits: kgriffs (Adium@moz-7E0D846A.aus1.rackspace.com) (Ping timeout)
[13:41:16] *** Quits: sprocket (Mibbit@moz-D7455E46.skybroadband.com) (Quit: http://www.mibbit.com ajax IRC Client)
[13:42:55] <dbaupp> kimundi: it landed without bouncing at all; nice work :)
[13:42:56] *** Joins: gr00v (asdasdfsda@moz-4892F148.hsd1.il.comcast.net)
[13:43:41] *** Parts: gr00v (asdasdfsda@moz-4892F148.hsd1.il.comcast.net) ()
[13:44:20] <kimundi> woho!
[13:44:30] * kimundi prepares next mass rename
[13:46:03] *** Quits: pyrac (pyrac@moz-30AD8801.w90-60.abo.wanadoo.fr) (Quit: pyrac)
[13:46:09] <doomlord> was there a bug with glob imports
[13:46:35] <kimundi> doomlord: what do you mean?
[13:46:51] <dbaupp> doomlord: there's a few of 'em
[13:46:51] <doomlord> i seem to remember last time i was moving things around i might have run into something that was a  known bug
[13:47:14] *** Joins: lbergstrom (Adium@moz-5D8E4B14.lightspeed.cicril.sbcglobal.net)
[13:47:26] <doomlord> (ok manually qualifying some things might fix some imports i guess..)
[13:47:39] <dbaupp> having `mod a { use b::* } mod b { use a::*; }` is liable to cause explosions
[13:47:50] <dbaupp> *is one of the things
[13:49:50] *** Quits: gavinb (gavinb@moz-9EC182F0.lowrp3.vic.optusnet.com.au) (Quit: gavinb)
[13:52:40] <cmr> *is one of the many things
[13:52:42] <cmr> :p
[13:53:19] <cmr> I find any non-trivial use of glob imports to be hairy
[13:54:03] <doomlord> withotu glob  imports.. you need to manually qualify lots of names.. or manually import lots of individual functions
[13:54:20] <doomlord> i suppose you can make aliases for the module names
[13:54:40] <doomlord> use blah_blah_blah=bl ?
[13:56:46] <doomlord> this is all inspired by the  "ML" module system ?
[13:57:06] *** Joins: victorporof (victorporo@9D964D4D.36D485C.2B3D3D4.IP)
[13:57:29] *** Quits: jviereck (Adium@moz-1B04BEE6.dip0.t-ipconnect.de) (Quit: Leaving.)
[14:00:48] *** Joins: ghrust (ghrust@C8693FCB.6A2AE50.F3114085.IP)
[14:00:48] <ghrust> 01[13rust01] 15bors pushed 0 new commits to 06auto: 02http://git.io/-bm8fg
[14:00:48] *** Parts: ghrust (ghrust@C8693FCB.6A2AE50.F3114085.IP) ()
[14:05:11] *** Joins: jorendorff (jorendorff@moz-2F32ACA3.hsd1.tn.comcast.net)
[14:10:15] *** Joins: adridu59 (Mibbit@moz-6C393FDD.rev.numericable.fr)
[14:10:29] <adridu59> dbaupp: ping
[14:11:18] *** Quits: adridu59 (Mibbit@moz-6C393FDD.rev.numericable.fr) (Quit: http://www.mibbit.com ajax IRC Client)
[14:11:43] *** Joins: mib_kwk0eh (Mibbit@moz-6C393FDD.rev.numericable.fr)
[14:11:50] *** Quits: mib_kwk0eh (Mibbit@moz-6C393FDD.rev.numericable.fr) (Quit: http://www.mibbit.com ajax IRC Client)
[14:12:29] *** Joins: voxpopuli (fanservice@moz-CEF3689A.hsd1.pa.comcast.net)
[14:12:44] <doomlord> grrr all blown up again
[14:13:53] <doomlord> its the fact moving something changes its name, effectively
[14:14:06] *** Joins: reyre|away (reyre@moz-9002CDDA.cpe.net.cable.rogers.com)
[14:14:13] <doomlord> i think this module system might actually be harder to use than headerfiles :(
[14:14:54] <doomlord> its funny because my situation is everything is unambiguous.. everything originated in the same module
[14:15:14] <doomlord> (well not evverything, but too much .. hence the need to split)
[14:16:33] <doomlord> if you leet headers include eachother, they can manage eachother
[14:20:07] <bjz> doomlord: yeah, rust's modules constantly give me headaches. hopefully something can be done about them :(
[14:20:13] <doomlord> i wonder what the best way to deal with this is...   i've got one sourcefile thats too large, and its the thing that does the mod importss. First i thought i could make a sepereate file that does the mod imports then includes this... but that just didn't seem to work  at all ; now i'm keeping this as the root and trying to move things out pretty much one function at  a time..
[14:20:21] *** Joins: jensnockert (jensnocker@moz-C5F27039.cust.bredband2.com)
[14:20:48] <doomlord> hopefully its fixable bug (which might make the errors confusing?), not the design
[14:21:18] <doomlord> ^fixable bugs.. or things that can be clarified with error messages (like the circual glob import)
[14:21:30] *** Quits: spider-mario (spidermari@moz-81131DB6.fbx.proxad.net) (Input/output error)
[14:22:19] <doomlord> the problem with moving things out 'sone function at a time' is i'm effectively having to visit a huge number of function calls to relable them (eitther as an individual import , or qualitfy them )
[14:22:36] <doomlord> but there's no ambiguity in the namespaces .. since it was all in one mod to start with
[14:27:09] <kimundi> I'm kinda confused by the troubles you're having
[14:27:22] <kimundi> As in: I can't imagine what problems you have :)
[14:28:13] <kimundi> In my mind everything uses a name that has been imported by 'use', so with moving around you should only need to adjust the use statements
[14:28:39] <kimundi> But you obviosly have problems, so I'm missing something...
[14:29:10] *** Joins: jviereck (Adium@moz-1B04BEE6.dip0.t-ipconnect.de)
[14:29:28] <bjz> if you do one to many globs everything explodes into a whole bunch of 'unresolved name's with no clue as to where the problem stems from
[14:29:28] <kimundi> The only problem I imagine is if you're using global paths, those of course need to be adjusted
[14:29:48] <kimundi> globs == ?
[14:29:57] <kimundi> wildcard import?
[14:30:09] <bjz> aye
[14:30:20] *** Quits: lkuper (lkuper@moz-C0CD33ED.hsd1.in.comcast.net) (Quit: lkuper)
[14:30:47] *** Quits: jorendorff (jorendorff@moz-2F32ACA3.hsd1.tn.comcast.net) (Quit: My MacBook Pro has gone to sleep. ZZZzzzâ€¦)
[14:31:10] <kimundi> minus bugs, isn't that the same as normal imports, you just have to consider the whole set at a time?
[14:32:00] <bjz> it gets trickier when you have pub uses
[14:33:32] *** Quits: Yurume (yurume@AC58A8CE.8A059B47.E313B915.IP) (Ping timeout)
[14:34:01] <kimundi> Just adjust the 'pub use' path then, no? If you have 'pub use' in a module that you're moving, you need to adjust the 'pub use' so that it finds the source, and all users of the names made public by 'pub use'
[14:34:21] <doomlord> well next time i know not to make the mistake of putting the mods in the same plaece as sourcecode
[14:34:44] <doomlord> i get the impression that has made life much harder for me
[14:34:48] <kimundi> doomlord: what do you mean?
[14:35:28] <doomlord> well i've got too much functionality in what is effectively my 'main', but its proving very hard to move things out
[14:35:52] <doomlord> i think elsewhere i've seen a simple crate root that is mostly mod statements
[14:35:58] <kimundi> do you mean only 'mod's in the crate root vs 'mod' spread over the whole hierachy?
[14:36:26] <doomlord> kind of, my problem is my largest sourcefile has both the mods and most of the functionality
[14:36:28] *** Joins: pyrac (pyrac@moz-30AD8801.w90-60.abo.wanadoo.fr)
[14:36:41] <doomlord> so i can't seperate my functionality from my whole project structure
[14:36:55] *** Joins: Yurume (yurume@AC58A8CE.8A059B47.E313B915.IP)
[14:37:07] <doomlord> i've improved it a   little today
[14:38:32] <doomlord> heh i should make a callgraph tool
[14:39:43] *** Joins: kgriffs (Adium@moz-7E0D846A.aus1.rackspace.com)
[14:41:23] *** Quits: kgriffs (Adium@moz-7E0D846A.aus1.rackspace.com) (Ping timeout)
[14:41:35] <doomlord> ok i've used lots of glob imports to start with, perhaps if i remove all my glob imports before i try to split it up , then it will be easier
[14:51:19] *** Quits: nano (nano@moz-74CAD1CA.superkabel.de) (Connection reset by peer)
[14:52:02] <doomlord> heh yikes! that was unexpected.. "use"ing an enum doesn't seem to import its variants ...
[14:52:48] <kimundi> yeah, they need to be imported seperately
[14:53:57] <doomlord> i suppose at least with individual symbol importing, you dont have to update parameter lists when they change
[14:58:53] *** Joins: gareth0 (gareth0@moz-4EB68080.dynamic.dsl.as9105.com)
[14:58:53] <cmr> doomlord: yes, your main crate file should be only/mostly mod's, everything else in separate files.
[14:59:56] <kimundi> well, there is no need to put the mods exclusivly in the crate root
[15:00:12] <kimundi> it's just the easiest to reason about import-wise
[15:00:13] <doomlord> if you dont i get the impression paths will be confusing
[15:00:43] <cmr> correct, and it's the structure that gets the most testing (because rustc and servo use it)
[15:01:03] <kimundi> well, to me it makes more sense to have a submodule of a module actually be it'S submodule :P
[15:01:23] <kimundi> unless you're talking about only having modfoo; that load a file in the crate root
[15:01:48] <cmr> I'm talking about like https://github.com/mozilla/rust/blob/master/src/libstd/std.rs
[15:01:59] <doomlord> the foo/mod.rs thng would keep it looking like the filesystem, that seems to make sense
[15:02:01] *** Joins: oBex (darryl@moz-DDDD2CB8.nyc.res.rr.com)
[15:02:25] <kimundi> then I guess it makes most sense to either have all at the crate root to have the files next to each other, or to have all be in a nested folder that correspond to their module
[15:02:36] <doomlord> but if you have a mix of it sometimes looking like the filesystem and other times not.. yikes..
[15:02:57] <kimundi> yeah that would be confusing
[15:03:52] <doomlord> it would be ironic if i actually gave up on rust because of the module system :(
[15:04:37] <doomlord> i probably need to just have set up a couple of things wrongly to find the right way of using it..
[15:05:07] *** Joins: SiegeLord (sl@moz-CAF07B4C.hsd1.ma.comcast.net)
[15:05:27] *** Joins: tiffany (kawaii@moz-EB8B0C08.dhcp.embarqhsd.net)
[15:05:46] *** Joins: ghrust (ghrust@C8693FCB.6A2AE50.F3114085.IP)
[15:05:46] <ghrust> 01[13rust01] 15bors merged 06auto into 06master: 02http://git.io/U1_7dA
[15:05:46] *** Parts: ghrust (ghrust@C8693FCB.6A2AE50.F3114085.IP) ()
[15:05:47] <cmr> The only structure that has worked well for me is the structure rustc uses.
[15:06:53] *** Joins: astrix (Mibbit@6168498C.58489E08.520CDC98.IP)
[15:06:57] *** Quits: squiddy_ (squiddy@moz-CB1FFF0E.adsl.alicedsl.de) (Input/output error)
[15:09:53] *** Quits: BizarreCake (BizarreCak@moz-361FE9B2.dynamic.barak-online.net) (Ping timeout)
[15:10:28] *** Joins: cubic (cubic@moz-FE5AD6C7.mc.videotron.ca)
[15:10:46] *** Joins: ghrust (ghrust@2EE61FCC.6A2AE50.F3114085.IP)
[15:10:46] <ghrust> 01[13rust01] 15bors pushed 0 new commits to 06auto: 02http://git.io/drmf0w
[15:10:46] *** Parts: ghrust (ghrust@2EE61FCC.6A2AE50.F3114085.IP) ()
[15:10:47] *** Joins: ghrust (ghrust@C8693FCB.6A2AE50.F3114085.IP)
[15:10:48] <ghrust> 01[13rust01] 15bors pushed 4 new commits to 06auto: 02http://git.io/SabyUQ
[15:10:48] <ghrust> 13rust/06auto 1468960a8 15Alex Crichton: Fix inner statics having the same symbol name...
[15:10:48] <ghrust> 13rust/06auto 141d0b78b 15Alex Crichton: Remove __extensions__ in names for a "pretty name"...
[15:10:48] <ghrust> 13rust/06auto 145547f61 15Alex Crichton: Improve name mangling for gdb...
[15:10:50] *** Parts: ghrust (ghrust@C8693FCB.6A2AE50.F3114085.IP) ()
[15:11:27] *** Joins: jmgrosen (jmgrosen@moz-848F6087.sb.sd.cox.net)
[15:13:08] *** Quits: jmgrosen (jmgrosen@moz-848F6087.sb.sd.cox.net) (Ping timeout)
[15:13:50] *** Quits: mark_edward (quassel@moz-97E995A.hsd1.in.comcast.net) (Ping timeout)
[15:14:05] *** Joins: mark_edward (quassel@moz-97E995A.hsd1.in.comcast.net)
[15:16:57] *** Joins: FrozenCow (FrozenCow@moz-B2DF4929.chello.nl)
[15:18:48] *** Joins: obk (Mibbit@moz-B0F26027.red.bezeqint.net)
[15:19:30] <Thiez> okay so it seems Type::function::<specializations>() is no longer valid syntax? Could anyone tell me what it got replaced by?
[15:19:53] <cmr> Thiez: it is valid, you just can't explicitly specify the Self type.
[15:19:59] <engla> either matching the return type Thiez 
[15:20:05] <cmr> Also type parameters go next to the type they apply to
[15:20:16] *** Joins: samx (sami@moz-D9DA5773.dyn.optonline.net)
[15:20:22] <cmr> ie if it's Type<K, V> and function<U>, it'd be Type::<K, V>::function::<U>()
[15:21:20] <Thiez> so if it's Node<T> with fn new()->Node<T>, would it be Node::<T>::new::<T> or Node::<T>::new() or Node::new::<T>() ? :p
[15:21:56] <kimundi> Node::<T>::new()
[15:22:09] <kimundi> fn new() has to type paramter, but the type
[15:22:14] <kimundi> has no*
[15:22:18] <Thiez> okay
[15:23:03] <cmr> Does anyone know what the make target(s) for benchmarking are?
[15:23:40] <kimundi> In the future you will also be able to specify the self type again like this: SomeTrait::<for X, T, U>::method::<V, W>()
[15:23:48] *** Joins: bjz_ (brendanzab@B398BE78.F804C29E.D35A31DF.IP)
[15:23:59] <engla> acrichto: ExactSizeHint... I tend to livelock when facing multiple alternatives. Adding a method in that trait seems ok, but it's also redundant and confusing. Now there's a different place to define the size, that still has to be consistent with the .size_hint()
[15:24:26] *** Quits: bjz (brendanzab@B398BE78.F804C29E.D35A31DF.IP) (Ping timeout)
[15:24:42] *** Quits: fabiand (fabiand@moz-8A783D5B.adsl.alicedsl.de) (Quit: Verlassend)
[15:24:47] <kimundi> What's wrong with making ExactSizeHint meaning 'The size hint is exact' ?
[15:24:56] <kimundi> eg, no new method
[15:25:04] <engla> right that's the #1 proposal
[15:25:17] <engla> it's easy to impl it without it being exact
[15:25:22] <acrichto> engla: yeah that is unfortunate...
[15:25:23] <engla> but the name should make it clear
[15:25:26] <engla> :-)
[15:25:29] *** Quits: nsf (nsf@moz-EEF3238A.convex.ru) (Quit: WeeChat 0.4.1)
[15:25:56] <kimundi> You can give a size hint, and if you also impl ExactSizeHint you have to make sure that that hint is allways exact
[15:26:09] <engla> kimundi: https://github.com/mozilla/rust/pull/8884
[15:26:11] <engla> yeah
[15:26:28] <acrichto> engla: I'm mostly ok with it not having a default method, but I think that it should assert in at least one place where it's used about the return value of size_hint
[15:26:34] *** Joins: ghrust (ghrust@C8693FCB.6A2AE50.F3114085.IP)
[15:26:34] <ghrust> 01[13rust01] 15bors 04force-pushed 06auto from 141756401 to 147c5398b: 02http://git.io/N3iJvQ
[15:26:34] *** Parts: ghrust (ghrust@C8693FCB.6A2AE50.F3114085.IP) ()
[15:26:38] <engla> since it's all really about getting the index (from the front) when picking elements from the back
[15:26:53] <kimundi> which means you can'T just generically impl ExactSizeHint on types which use an Iterator that doesn't have it
[15:26:54] <engla> maybe the trait can be about implementing exactly that
[15:27:07] *** Joins: ghrust (ghrust@79968228.6A2AE50.F3114085.IP)
[15:27:07] <ghrust> 01[13rust01] 15bors pushed 2 new commits to 06auto: 02http://git.io/C_YE9w
[15:27:07] <ghrust> 13rust/06auto 14b2eba6b 15adridu59: libstd/os: set tmp dir to /data/tmp on Android...
[15:27:07] <ghrust> 13rust/06auto 14fdad4ed 15bors: auto merge of #8901 : adridu59/rust/issue-8511, r=cmr...
[15:27:07] *** Parts: ghrust (ghrust@79968228.6A2AE50.F3114085.IP) ()
[15:28:18] <acrichto> engla: what if this were somehow an extension of the random index inderator?
[15:28:59] <engla> it could be
[15:29:24] <engla> no
[15:29:47] <engla> the doubly-linked list is exact size but not random access
[15:29:50] <acrichto> the main reason for this is to have enumerate().invert(), right?
[15:30:10] <engla> yes
[15:30:16] *** Joins: jorendorff (jorendorff@moz-2F32ACA3.hsd1.tn.comcast.net)
[15:32:29] *** Quits: jorendorff (jorendorff@moz-2F32ACA3.hsd1.tn.comcast.net) (Ping timeout)
[15:33:47] <acrichto> engla: what about the idea of 'fn exact_size' as a default method which asserted sanity about size_hint?
[15:34:28] *** Quits: donri (dag@moz-9BB61102.tbcn.telia.com) (Client exited)
[15:34:35] <engla> I've implemented it and it compiles, but that's what my initial comment above was directed against
[15:34:50] <engla> it's a second method where implementors can define the size
[15:35:20] <acrichto> yeah that's a good point
[15:36:44] <engla> it could inherit DoubleEndedIterator since that's where it is used
[15:37:21] <obk> struct Foo<T> { bar: ~T }; fn new<T>(bar: ~T) ->@Foo<T> { @Foo { bar: bar } }; "value may contain burrowed pointers". What's the trait I need to put on T to calm the compiler?
[15:37:32] <engla> T: 'static
[15:38:24] <obk> engla: That's somewhat extreme, no? I mean, T could also contained plain old owned pointers, no?
[15:38:40] <obk> Or doesn't 'static mean what I fear it means?
[15:39:29] <engla> it's fine
[15:39:36] <obk> Sounds magical...
[15:39:43] <engla> I guess it is
[15:40:03] *** Joins: kgriffs (Adium@moz-7E0D846A.aus1.rackspace.com)
[15:40:09] <engla> 'static is a supertrait of Send.. is that correct?
[15:40:31] <kimundi> obk: 'static means "IF it contains borrowed pointers, they have lifetime 'static"
[15:40:40] <kimundi> afaik at least
[15:41:06] <kimundi> rusti: fn foo<T: 'static>() {}; foo::<~uint>(); "foo"
[15:41:07] -rusti- "foo"
[15:41:13] <kimundi> yeah, seems to work that way
[15:41:20] <engla> obk: not if the owned pointer contains a borrowed pointer
[15:41:31] <acrichto> engla: I am convinced, if you add the test back in I'll r+, I think that it's a pretty useful trait (especially with vectors) and we can revise pretty easily if we come up with something better
[15:41:43] *** Quits: kgriffs (Adium@moz-7E0D846A.aus1.rackspace.com) (Ping timeout)
[15:41:55] <kimundi> rusti: fn foo<T: 'static>() {}; foo::<~&'static uint>(); "foo"
[15:41:56] -rusti- "foo"
[15:42:00] <kimundi> rusti: fn foo<T: 'static>() {}; foo::<~&uint>(); "foo"
[15:42:01] -rusti- <anon>:5:34: 5:47 error: instantiating a type parameter with an incompatible type `~&'<empty> uint`, which does not fulfill `'static`
[15:42:01] -rusti- <anon>:5          fn foo<T: 'static>() {}; foo::<~&uint>(); "foo"
[15:42:01] -rusti-                                            ^~~~~~~~~~~~~
[15:42:01] -rusti- error: aborting due to previous error
[15:42:01] -rusti- application terminated with error code 101
[15:42:04] <engla> ok. do you have an opinion about the DoubleEndedIterator thing?
[15:42:27] <engla> rusti: let x = 1; let y = ~&x; let z = @y;
[15:42:27] -rusti- <anon>:5:42: 5:43 error: value may contain borrowed pointers
[15:42:28] -rusti- <anon>:5          let x = 1; let y = ~&x; let z = @y;
[15:42:28] -rusti-                                                    ^
[15:42:28] -rusti- error: aborting due to previous error
[15:42:28] -rusti- application terminated with error code 101
[15:42:34] <acrichto> engla: how so with doubleended?
[15:42:43] *** Joins: threecreepio (jdp@moz-71E164C9.cust.bredbandsbolaget.se)
[15:43:00] <engla> I'm a fan of simplicity, and the trait needs no supertrait without any methods
[15:43:15] <engla> but dbaupp suggested it could be "filed" under D-E-iterator by inheriting it
[15:43:24] <obk> 'static means "IF it contains borrowed pointers, they have lifetime 'static" -> Ok, that makes sense. Thanks!
[15:43:36] <acrichto> as in "trait Exact<T>: DoubleEndedItreator<T> {}" ?
[15:43:40] <engla> yes
[15:44:17] <acrichto> that seems proper
[15:44:29] *** Joins: Sorella (queen@9D963F5D.DF5D8AE7.54BCAB54.IP)
[15:44:41] <acrichto> I'd also be ok with ExactSizeHint => ExactSize
[15:44:49] <engla> hm in that case .rposition could be a default method
[15:44:51] <acrichto> less typing
[15:44:57] <acrichto> hurrah!
[15:45:11] <engla> ok
[15:45:12] <acrichto> then that is definitely the best way to go
[15:45:21] <acrichto> more impls, less traits
[15:50:05] <Palmik> Hmm, does anyone know why fields in structs (and constructors in enums) are separated by comma, but functions in taits are separated with semicolon (or rather the method declaration needs semicolon after it).
[15:50:44] <Palmik> I guess it makes parsing a little bit easier (because of commas separating function arguments).
[15:50:46] *** Joins: ghrust (ghrust@9C8B94D4.6A2AE50.F3114085.IP)
[15:50:46] <ghrust> 01[13rust01] 15bors 04force-pushed 06auto from 14fdad4ed to 147c5398b: 02http://git.io/N3iJvQ
[15:50:46] *** Parts: ghrust (ghrust@9C8B94D4.6A2AE50.F3114085.IP) ()
[15:50:55] <kimundi> no specific reason, there is an issue about maybe making it consistent
[15:53:27] *** Quits: miza (miza@moz-4DD51325.home.otenet.gr) (Input/output error)
[15:53:57] <Palmik> OK
[15:55:26] <SiegeLord> I kind of like the current breakdown... but maybe that's just me
[15:55:35] <SiegeLord> fn's and ;'s just go together for me
[15:56:18] <kimundi> yeah
[15:56:57] <kimundi> struct should also use ',' because it's a list of fields
[15:57:08] <kimundi> enums variants are tricky though...
[15:57:42] <kimundi> On the one hand they list a number of possibilities, so ',' fits.
[15:58:32] <kimundi> On the other hand You never list them anywhere else, they are standalone, so declaring each with a ';' terminated makes sense too
[16:01:28] *** Joins: onr (uid5726@moz-31ABA2C0.irccloud.com)
[16:01:55] *** Quits: lenstr (lenstr@CD7D5ABA.83A99F98.85938D85.IP) (Client exited)
[16:02:57] *** Joins: nano (nano@moz-74CAD1CA.superkabel.de)
[16:04:50] *** Quits: Jesin (Jessin_@moz-A680C20B.cc.lehigh.edu) (Ping timeout)
[16:08:52] *** Quits: jensnockert (jensnocker@moz-C5F27039.cust.bredband2.com) (Connection reset by peer)
[16:09:38] *** Joins: jensnockert (jensnocker@moz-C5F27039.cust.bredband2.com)
[16:12:39] *** Joins: lenstr (lenstr@CD7D5ABA.83A99F98.85938D85.IP)
[16:21:10] *** Joins: nsf (nsf@moz-EEF3238A.convex.ru)
[16:21:20] *** Joins: Blei (philipp@moz-A8EE15D9.cust.bluewin.ch)
[16:23:26] *** Quits: cubic (cubic@moz-FE5AD6C7.mc.videotron.ca) (Client exited)
[16:24:13] <doomlord> i saw the 'pub use' example, but is there a way to import a module directly into the current 'scope' and have its symbols automatically visible to any other imported submodules. The closest i can see to that is if main 'pub used' everything, and each module referenced symbols from others  with "super::<symbolname>", playing around that seemed to work...
[16:24:55] <doomlord> (i have eliminated my glob imports in my project now, at least..)
[16:28:57] *** Joins: donri (dag@moz-9BB61102.tbcn.telia.com)
[16:35:40] *** Joins: cubic (cubic@moz-FE5AD6C7.mc.videotron.ca)
[16:38:39] <kimundi> doomlord: The ' have its symbols automatically visible to any other imported submodules' is incompatible with how the module system is designed
[16:39:36] <kimundi> imports only affect what is visible in the module where the import is written
[16:40:22] <doomlord> seems like the closest one can get is prefixing with 'super::'
[16:40:33] *** Joins: kgriffs (Adium@moz-7E0D846A.aus1.rackspace.com)
[16:40:57] <kimundi> if you want to the other submodule to see something specific, the closes you can do is 'use super::foo::*' in the submodules
[16:41:16] <kimundi> and then make foo either an module or a reexport in the parent module
[16:41:21] *** Quits: SiegeLord (sl@moz-CAF07B4C.hsd1.ma.comcast.net) (Quit: It's a joke, it's all a joke.)
[16:41:25] <kimundi> anyway... pizza!
[16:41:41] <doomlord> ok i think i need a break from this..
[16:41:43] <doomlord> .. this is depressing
[16:42:13] *** Quits: kgriffs (Adium@moz-7E0D846A.aus1.rackspace.com) (Ping timeout)
[16:45:02] <doomlord> maybe i need to just write a refactoring tool :)
[16:46:18] <kimundi> "...is there a way to import a module directly into the current 'scope' and have its symbols automatically visible to any other imported submodules." - using my idea: https://gist.github.com/Kimundi/6405626
[16:47:58] <doomlord> ok i think its just a particularly bad corner i've reversed into with my mod's in the same file.  i'll try to have faith that  next time it wouldn't go so badly
[16:48:21] <doomlord> (^mods in the same file as most of the functionality plus main stuf..)
[16:48:28] <kimundi> he, yeah, sometimes the best course of action is to start fronm scratch :)
[16:49:16] <doomlord> well this particular program is too big for that too. ive found potetnial collaborators to help working toward IDE support... so i was trying to improve my module structure... lol
[16:52:24] <doomlord> heh. cat *.rs >> all.rs && rustc all.rs .. how about that :)
[16:52:40] <doomlord> (well and delete it every time too)
[16:55:24] <engla> acrichto: I pushed it
[16:55:47] *** Joins: ghrust (ghrust@79968228.6A2AE50.F3114085.IP)
[16:55:47] <ghrust> 01[13rust01] 15bors merged 06auto into 06master: 02http://git.io/BeIMVQ
[16:55:47] *** Parts: ghrust (ghrust@79968228.6A2AE50.F3114085.IP) ()
[16:59:56] *** Joins: dymk (dymk@E913D3B5.A6E21E6E.5E500FC7.IP)
[17:05:07] *** Joins: jmgrosen (jmgrosen@moz-848F6087.sb.sd.cox.net)
[17:05:26] <jmgrosen> has anyone gotten static compilation of rust code that uses libstd working?
[17:06:01] <cmr> static linking? not recently that I know of.
[17:06:55] <jmgrosen> alright
[17:09:55] *** Quits: Blei (philipp@moz-A8EE15D9.cust.bluewin.ch) (Quit: WeeChat 0.4.1)
[17:11:13] *** Joins: GommaRosa (GommaRosa@moz-DC20D413.cust.dsl.teletu.it)
[17:12:59] *** Parts: GommaRosa (GommaRosa@moz-DC20D413.cust.dsl.teletu.it) ()
[17:20:59] *** Joins: lkuper (lkuper@moz-C0CD33ED.hsd1.in.comcast.net)
[17:24:02] *** Joins: ofeldt (ofeldt@moz-21267FEC.dip0.t-ipconnect.de)
[17:24:17] *** Joins: ssutch (samuelsutc@moz-DFB7649C.hsd1.ca.comcast.net)
[17:25:05] *** Quits: ofeldt- (ofeldt@moz-7C0866DD.dip0.t-ipconnect.de) (Ping timeout)
[17:26:37] *** Quits: jmgrosen (jmgrosen@moz-848F6087.sb.sd.cox.net) (Quit: jmgrosen)
[17:28:08] <sruggier> yesterday I thought it might be helpful for me to run rustc in a debugger, but I couldn't find documentation to support that, nor did I find any mention of debug-info in the build system when I grepped for it
[17:28:38] <cmr> sruggier: --enable-debug to configure enables debug logging.
[17:28:51] <cmr> You need to pass -Z debug-info to rustc during the build somehow
[17:29:01] <cmr> but rustc can't actually be built with debug info yet, not mature enough
[17:29:18] <sruggier> ah, there are bugs?
[17:29:23] <cmr> many.
[17:29:36] <Luqman> well less so than before
[17:29:50] <sruggier> is there an issue or tag to track them?
[17:29:52] *** Quits: jaen (jaen@moz-E0979827.copit.pl) (Quit: WeeChat 0.4.1)
[17:30:31] *** Quits: lenstr (lenstr@CD7D5ABA.83A99F98.85938D85.IP) (Client exited)
[17:30:41] <sruggier> I did enable debug logs yesterday and today, and so far it's been helpful
[17:31:05] <cmr> Not that I know of.
[17:32:57] *** Joins: maik (maik___@moz-7490859E.dip0.t-ipconnect.de)
[17:33:00] *** Quits: threecreepio (jdp@moz-71E164C9.cust.bredbandsbolaget.se) (Quit: threecreepio)
[17:33:35] *** Joins: Jesin (Jessin_@moz-A680C20B.cc.lehigh.edu)
[17:36:55] <dymk> on PRS such as https://github.com/mozilla/rust/pull/8907, shouldn't they say "merged" instead of "closed"? 
[17:37:04] *** Quits: Jesin (Jessin_@moz-A680C20B.cc.lehigh.edu) (Ping timeout)
[17:37:17] <engla> I have the simplest possible byte, char and line iterators for Reader implemented but I'm unsure what we want in libstd
[17:37:24] *** Joins: threecreepio (jdp@moz-71E164C9.cust.bredbandsbolaget.se)
[17:37:33] <engla> dymk: don't know why that is, but that's how bors works right now
[17:37:47] <dymk> bummer, it messes up github stats
[17:37:50] *** Joins: Jesin (Jessin_@moz-A680C20B.cc.lehigh.edu)
[17:40:54] *** Joins: kgriffs (Adium@moz-7E0D846A.aus1.rackspace.com)
[17:42:34] *** Quits: kgriffs (Adium@moz-7E0D846A.aus1.rackspace.com) (Ping timeout)
[17:45:27] *** Joins: lenstr (lenstr@CD7D5ABA.83A99F98.85938D85.IP)
[17:47:06] *** Quits: inf-groupoid (user@580120F5.8ED93E28.1C8C8CE9.IP) (Quit: ERC Version 5.3 (IRC client for Emacs))
[17:47:35] *** Quits: obk (Mibbit@moz-B0F26027.red.bezeqint.net) (Quit: http://www.mibbit.com ajax IRC Client)
[17:47:50] *** Joins: Sergio965 (sergiobz@moz-CD77CA9E.tamiu.edu)
[17:48:09] *** Quits: samx (sami@moz-D9DA5773.dyn.optonline.net) (Quit: This computer has gone to sleep)
[17:48:25] <Sergio965> Is it possible to overload the [] operator?
[17:49:03] <engla> not at the moment, the Index trait will be redesigned
[17:49:31] <Sergio965> So if I implement Index for a given type, it won't work in 0.7?
[17:49:49] <engla> I think it works in 0.7
[17:50:06] <engla> I don't know if it's just for access by copy or so
[17:52:42] *** Quits: jviereck (Adium@moz-1B04BEE6.dip0.t-ipconnect.de) (Quit: Leaving.)
[18:01:34] <zol> rusti: use core::vec; remove([0,1,2,3],0)
[18:01:37] -rusti- pastebinned 8 lines of output: http://ix.io/7Lc
[18:02:34] <engla> core was renamed to std
[18:02:44] <engla> and a lot moved around in there :)
[18:02:50] <zol> rusti: use std::vec; remove([0,1,2,3],0)
[18:02:51] -rusti- <anon>:5:23: 5:29 error: unresolved name `remove`.
[18:02:51] -rusti- <anon>:5          use std::vec; remove([0,1,2,3],0)
[18:02:51] -rusti-                                 ^~~~~~
[18:02:51] -rusti- error: aborting due to previous error
[18:02:51] -rusti- application terminated with error code 101
[18:03:08] <zol> engla: Hmm.. The docs haven't been updated? 
[18:03:21] <zol> engla: http://static.rust-lang.org/doc/core/vec.html#function-remove ?
[18:03:21] <engla> they are automatically updated
[18:03:30] <engla> those docs are old
[18:03:35] <zol> oh
[18:03:39] <engla> use the link on the front page
[18:03:59] <engla> http://www.rust-lang.org/
[18:04:04] <engla> rusti here uses Trunk
[18:04:21] *** Joins: jeaye (Jeaye@moz-FD505E54.hsd1.ca.comcast.net)
[18:04:30] <engla> also if you want to import a function called remove, it would be
[18:04:36] <engla> rusti: use std::vec::remove;
[18:04:39] -rusti- pastebinned 8 lines of output: http://ix.io/7Ld
[18:04:43] <engla> (but it doesn't exist)
[18:10:59] *** Joins: jviereck (Adium@moz-1B04BEE6.dip0.t-ipconnect.de)
[18:13:06] *** Quits: threecreepio (jdp@moz-71E164C9.cust.bredbandsbolaget.se) (Quit: threecreepio)
[18:13:25] <zol> rusti: ~[0,1,2,3].remove(0)
[18:13:25] -rusti- <anon>:5:10: 6:5 error: type `[<VI3>, .. 4]` does not implement any method in scope named `remove`
[18:13:25] -rusti- <anon>:5          ~[0,1,2,3].remove(0)
[18:13:26] -rusti- <anon>:6     };
[18:13:26] -rusti- error: aborting due to previous error
[18:13:26] -rusti- application terminated with error code 101
[18:14:20] <zol> rusti: let a = ~[]; a.push(1)
[18:14:20] -rusti- <anon>:5:22: 5:23 error: cannot borrow immutable local variable as mutable
[18:14:20] -rusti- <anon>:5          let a = ~[]; a.push(1)
[18:14:21] -rusti-                                ^
[18:14:23] -rusti- error: aborting due to previous error
[18:14:25] -rusti- application terminated with error code 101
[18:14:29] <zol> rusti: let mut a = ~[]; a.push(1)
[18:14:30] -rusti- ()
[18:14:36] <zol> rusti: let mut a = ~[]; a.push(1); a
[18:14:36] -rusti- ~[1]
[18:16:01] *** Joins: mr_evil (Mibbit@85052D9C.5B1B62E6.670EEFD.IP)
[18:16:24] * mr_evil who am I?
[18:16:35] *** Quits: mr_evil (Mibbit@85052D9C.5B1B62E6.670EEFD.IP) (Quit: http://www.mibbit.com ajax IRC Client)
[18:17:24] <Sergio965> Hmm, but there's no way to overload []= is there?
[18:19:31] *** Quits: pyrac (pyrac@moz-30AD8801.w90-60.abo.wanadoo.fr) (Quit: pyrac)
[18:20:30] <engla> right, but it's planned
[18:20:45] <Sergio965> Ah I see. Sounds good.
[18:20:46] <engla> I'd search the issue tracker for IndexAssign
[18:21:48] <tiffany> how do I put a closure inside of a struct?
[18:22:31] *** Quits: Yurume (yurume@AC58A8CE.8A059B47.E313B915.IP) (Ping timeout)
[18:22:45] *** Quits: gareth0 (gareth0@moz-4EB68080.dynamic.dsl.as9105.com) (Ping timeout)
[18:22:51] <engla> just give it a field with the closure type  either  struct X<'self> { f: &'self fn(A) -> B }   or struct X { f: ~fn(A) -> B }   or the same for @fn
[18:23:12] <engla> and ~fn and @fn coerce to &fn if they can
[18:23:23] <engla> and extern fn coerces to &fn too
[18:24:17] <tiffany> 'sef gives context.rs:3:11: 3:16 error: failed to find an implementation of trait std::clone::Clone for &'self fn<no-bounds>(~[context::FRValue<'self>]) -> context::FRValue<'self>
[18:24:39] <tiffany> oh, ~ seems to work
[18:24:49] <engla> yes you can't clone &fn  so deriving clone fails
[18:24:53] <engla> aha
[18:25:26] *** Joins: threecreepio (jdp@moz-71E164C9.cust.bredbandsbolaget.se)
[18:25:35] <tiffany> hm.. do I only need 'self when I put borrowed pointers in my structs?
[18:26:07] <tiffany> context.rs:3:11: 3:16 error: mismatched types: expected `~fn:Send(~[context::FRValue]) -> context::FRValue` but found `&~fn:Send(~[context::FRValue]) -> context::FRValue` (expected fn but found &-ptr)
[18:26:08] <engla> the 'self parameter yes
[18:26:08] <tiffany> uhhh
[18:26:21] *** Quits: astrix (Mibbit@6168498C.58489E08.520CDC98.IP) (Quit: http://www.mibbit.com ajax IRC Client)
[18:26:47] <engla> tiffany: do you have #[deriving(Clone)] on that struct?
[18:26:51] <tiffany> yeah
[18:26:53] <zol> rusti: if !false { println("test") }
[18:26:54] -rusti- test
[18:26:54] -rusti- ()
[18:27:13] <engla> it probably expands to something that doesn't compile for the ~fn member
[18:27:15] <engla> it's a bug really
[18:27:34] <engla> you can't clone it with a closure in it (at the moment at least)
[18:28:20] <tiffany> well that's annoying
[18:29:12] <engla> wait surely you can clone @fn
[18:29:44] <engla> it's just not used because it will disappear in closure reform
[18:34:05] <tiffany> context.rs:17:8: 18:5 error: mismatched types: expected `std::option::Option<context::FRValue>` but found `std::option::Option<&context::FRValue>` (expected enum context::FRValue but found &-ptr)
[18:34:08] <tiffany> why am I getting this error?
[18:34:26] <engla> don't know
[18:34:38] <tiffany> I have an Option<&context::FRValue> from find(), but it should be converted to an Option<context::FRValue> from the .map(|x| x.clone())
[18:34:43] <tiffany> but it's not
[18:36:38] <tiffany> ah, using .chain() worked
[18:37:11] <engla> yeah the option methods aren't consistent yet
[18:37:15] <engla> :| sorry about that
[18:37:26] <engla> in their naming vs calling convention
[18:37:37] *** Quits: Axord (xord@moz-1B228827.lsanca.dsl-w.verizon.net) (Quit: I'm sure it's perfectly safe)
[18:37:55] <engla> .map, .map_mut, .map_move  and .chain, .chain_ref, .chain_mut_ref....
[18:37:55] *** Joins: strcat (strcat@moz-54F7FD49.cpe.net.cable.rogers.com)
[18:38:46] *** Joins: Axord (xord@moz-1B228827.lsanca.dsl-w.verizon.net)
[18:38:47] *** Joins: glyc (Mibbit@moz-20CEEF38.hsd1.ca.comcast.net)
[18:38:57] *** Quits: lenstr (lenstr@CD7D5ABA.83A99F98.85938D85.IP) (Client exited)
[18:41:21] *** Joins: kgriffs (Adium@moz-7E0D846A.aus1.rackspace.com)
[18:42:37] *** Quits: Jesin (Jessin_@moz-A680C20B.cc.lehigh.edu) (Ping timeout)
[18:43:01] *** Quits: kgriffs (Adium@moz-7E0D846A.aus1.rackspace.com) (Ping timeout)
[18:45:10] *** btm_work is now known as btm_away
[18:45:38] *** Joins: lenstr (lenstr@CD7D5ABA.83A99F98.85938D85.IP)
[18:46:08] *** Quits: lenstr (lenstr@CD7D5ABA.83A99F98.85938D85.IP) (Client exited)
[18:49:58] *** Joins: squiddy (squiddy@moz-CB1FFF0E.adsl.alicedsl.de)
[18:50:24] *** Joins: Diamond (dick@moz-D7E07B36.ks.ks.cox.net)
[18:51:14] *** Quits: victorporof (victorporo@9D964D4D.36D485C.2B3D3D4.IP) (Quit: victorporof)
[18:52:45] *** Joins: miza (miza@moz-4DD51325.home.otenet.gr)
[18:53:32] *** Joins: pyrac (pyrac@moz-30AD8801.w90-60.abo.wanadoo.fr)
[18:54:02] *** Quits: pyrac (pyrac@moz-30AD8801.w90-60.abo.wanadoo.fr) (Quit: pyrac)
[18:54:40] *** Joins: tgummerer (tgummerer@moz-5DC8FA44.tbcn.telia.com)
[18:56:02] <tiffany> is there a reason why 'self is explicit?
[18:56:45] <strcat> 'self is a misnomer
[18:56:59] <strcat> it's unrelated to the self parameter
[18:57:17] <strcat> it's explicit because you will be able to have multiple lifetime parameters, and in an impl you already need it to be explicit
[18:57:51] <tiffany> can borrowed pointers in a struct not default to living as long as the struct?
[18:58:17] <tiffany> it seems kind of verbose to add so many <'self> parameters just to add a borrowed pointer somewhere
[18:59:03] *** Joins: robertknight (robertknig@moz-53D8EF63.range81-151.btcentralplus.com)
[19:00:03] <engla> you can't return a struct by value without the lifetime parameter
[19:00:43] *** Joins: eholk (eholk@moz-F70D5031.hsd1.in.comcast.net)
[19:02:03] *** Quits: vodik (simon@moz-CBE4BB13.cable.teksavvy.com) (Ping timeout)
[19:02:35] *** Joins: Jesin (Jessin_@moz-DD8D71FB.cc.lehigh.edu)
[19:02:57] <lkuper> acrichto: ping
[19:03:51] *** Joins: ghrust (ghrust@1E8607E8.6A2AE50.F3114085.IP)
[19:03:51] <ghrust> 01[13rust01] 15thestinger pushed 1 new commit to 06master: 02http://git.io/1hTEIw
[19:03:51] <ghrust> 13rust/06master 141f4aba8 15Daniel Micay: touch llvm clean trigger
[19:03:51] *** Parts: ghrust (ghrust@1E8607E8.6A2AE50.F3114085.IP) ()
[19:04:08] *** Joins: ghrust (ghrust@1E8607E8.6A2AE50.F3114085.IP)
[19:04:08] <ghrust> 01[13rust01] 15thestinger merged 06master into 06snap-stage3: 02http://git.io/jbCdDg
[19:04:08] *** Parts: ghrust (ghrust@1E8607E8.6A2AE50.F3114085.IP) ()
[19:06:52] *** Joins: int3_ (int3_@moz-ABE52D50.hsd1.ca.comcast.net)
[19:07:36] *** Joins: mihneadb (mihneadb@moz-329F29A3.lightspeed.sntcca.sbcglobal.net)
[19:07:37] *** Joins: igl1 (igl@moz-AA42D59E.adsl.alicedsl.de)
[19:07:57] *** Quits: igl (igl@moz-B71893B2.adsl.alicedsl.de) (Ping timeout)
[19:08:48] *** Joins: enix (enix@moz-A50569DD.c3-0.slvr-ubr1.lnh-slvr.md.cable.rcn.com)
[19:10:14] <kimundi> tiffany: The number of <'self> is the same as the number of <T> if instead of a lifetime it where a generic type parameter
[19:12:18] *** Parts: lbergstrom (Adium@moz-5D8E4B14.lightspeed.cicril.sbcglobal.net) ()
[19:17:09] *** Quits: mindcat (mindcat@CFDC42C8.DC005319.857BDFA9.IP) (Client exited)
[19:17:46] <doomlord> (ok my  panic is over, i've  managed to re-arrange my project now.. bulk of the work happens in sub-modules, not in the crate root along with main and mods..)
[19:18:21] <doomlord> (i think it was so diffficult because i was ending up with circular use ...::* 's in the intermediate state.. )
[19:18:40] *** Quits: Jesin (Jessin_@moz-DD8D71FB.cc.lehigh.edu) (Ping timeout)
[19:19:59] <doomlord> am i right in thinking use ...::* is going to be ok when its in a dag ?
[19:22:52] *** Quits: maik (maik___@moz-7490859E.dip0.t-ipconnect.de) (Ping timeout)
[19:23:06] *** Joins: pyrac (pyrac@moz-30AD8801.w90-60.abo.wanadoo.fr)
[19:24:33] *** Quits: jensnockert (jensnocker@moz-C5F27039.cust.bredband2.com) (Connection reset by peer)
[19:26:37] *** Joins: jmgrosen (jmgrosen@moz-848F6087.sb.sd.cox.net)
[19:27:30] *** Joins: jensnockert (jensnocker@moz-C5F27039.cust.bredband2.com)
[19:28:01] *** Quits: int3_ (int3_@moz-ABE52D50.hsd1.ca.comcast.net) (Client exited)
[19:28:22] *** Joins: int3_ (int3_@moz-ABE52D50.hsd1.ca.comcast.net)
[19:29:03] *** Joins: jfbk (textual@moz-EEA9CFB3.nyc.res.rr.com)
[19:29:10] *** Quits: pyrac (pyrac@moz-30AD8801.w90-60.abo.wanadoo.fr) (Quit: pyrac)
[19:29:36] *** Joins: inf-groupoid (user@580120F5.8ED93E28.1C8C8CE9.IP)
[19:30:09] *** Quits: int3_ (int3_@moz-ABE52D50.hsd1.ca.comcast.net) (Ping timeout)
[19:30:15] *** Quits: jviereck (Adium@moz-1B04BEE6.dip0.t-ipconnect.de) (Quit: Leaving.)
[19:31:24] *** Joins: adridu59 (Mibbit@moz-6C393FDD.rev.numericable.fr)
[19:33:42] *** Joins: int3_ (int3_@moz-ABE52D50.hsd1.ca.comcast.net)
[19:34:18] *** Quits: adridu59 (Mibbit@moz-6C393FDD.rev.numericable.fr) (Quit: http://www.mibbit.com ajax IRC Client)
[19:36:06] <zol> println!("...", ...) is macro for println(fmt!("..."), ...)? 
[19:41:46] *** Joins: kgriffs (Adium@moz-7E0D846A.aus1.rackspace.com)
[19:43:11] *** Joins: valenting (Thunderbir@8758046C.84D5EFD5.FB866788.IP)
[19:43:21] <Eridius> printfln!()
[19:43:22] <Eridius> zol: ^
[19:43:26] *** Quits: kgriffs (Adium@moz-7E0D846A.aus1.rackspace.com) (Ping timeout)
[19:43:33] <Eridius> also, if you only pass 1 arg, it's equivalent to println(fmt!("%?", arg))
[19:44:58] <strcat> they're obsolete though
[19:45:06] <strcat> format!, print! and println! are the replacement ones
[19:47:21] *** Joins: pyrac (pyrac@moz-30AD8801.w90-60.abo.wanadoo.fr)
[19:48:13] *** Joins: adu (ajr@moz-F930C5C9.washdc.fios.verizon.net)
[19:48:19] *** Quits: tgummerer (tgummerer@moz-5DC8FA44.tbcn.telia.com) (Ping timeout)
[19:48:24] *** Joins: sebcrozet (sebcrozet@moz-F96421F3.w80-13.abo.wanadoo.fr)
[19:48:49] *** Joins: lenstr (lenstr@CD7D5ABA.83A99F98.85938D85.IP)
[19:48:54] *** Quits: pyrac (pyrac@moz-30AD8801.w90-60.abo.wanadoo.fr) (Quit: pyrac)
[19:51:00] <kimundi> hehe, my adhoc refactoring tools is getting better... Now it interactivly asks how to fix errors
[19:51:27] *** Joins: victorporof (victorporo@9D964D4D.36D485C.2B3D3D4.IP)
[19:53:36] *** Joins: sevvie (sevvierose@moz-8BC5868E.hfc.comcastbusiness.net)
[19:53:54] *** Quits: eholk (eholk@moz-F70D5031.hsd1.in.comcast.net) (Quit: eholk)
[19:54:24] <Eridius> hrm, unused-imports lint isn't catching my `use vec::{..., VectorVector};`
[19:54:46] <Eridius> maybe it only catches module imports, not trait imports?
[19:57:20] *** Quits: victorporof (victorporo@9D964D4D.36D485C.2B3D3D4.IP) (Ping timeout)
[19:57:20] *** Quits: valenting (Thunderbir@8758046C.84D5EFD5.FB866788.IP) (Ping timeout)
[19:58:22] *** Quits: jensnockert (jensnocker@moz-C5F27039.cust.bredband2.com) (Input/output error)
[19:59:32] *** Quits: nano (nano@moz-74CAD1CA.superkabel.de) (Connection reset by peer)
[20:00:43] *** Quits: Sergio965 (sergiobz@moz-CD77CA9E.tamiu.edu) (Quit: My MacBook Pro has gone to sleep. ZZZzzzâ€¦)
[20:01:30] <strcat> Eridius: right
[20:04:15] *** Joins: jensnockert (jensnocker@moz-8BE55278.customer.t3.se)
[20:04:54] *** Quits: jmgrosen (jmgrosen@moz-848F6087.sb.sd.cox.net) (Connection reset by peer)
[20:05:57] *** Joins: jmgrosen (jmgrosen@moz-848F6087.sb.sd.cox.net)
[20:09:12] *** Joins: pnkfelix (pnkfelix@moz-43495417.fbx.proxad.net)
[20:09:12] *** ChanServ sets mode: +o pnkfelix
[20:09:48] *** Joins: eatkinson (eatkinson@moz-261EDE03.hsd1.ca.comcast.net)
[20:12:53] *** Quits: sk (sk@61A494B3.BA40E8A.AAC02D62.IP) (Input/output error)
[20:12:58] <cmr> pnkfelix: thanks for the rustdoc makefile stuff!
[20:14:55] *** Quits: jpf (jan@moz-A8C26A15.org) (Ping timeout)
[20:16:48] *** Quits: enix (enix@moz-A50569DD.c3-0.slvr-ubr1.lnh-slvr.md.cable.rcn.com) (Quit: Konversation terminated!)
[20:20:39] *** Joins: jviereck (Adium@moz-1B04BEE6.dip0.t-ipconnect.de)
[20:21:08] *** Quits: nsf (nsf@moz-EEF3238A.convex.ru) (Quit: WeeChat 0.4.1)
[20:21:15] *** Joins: Jesin (Jessin_@moz-DD8D71FB.cc.lehigh.edu)
[20:25:01] *** Joins: jpf (jan@moz-A8C26A15.org)
[20:28:35] <strcat> meh
[20:28:45] <strcat> snapshot failed even after touching the llvm clean trigger
[20:29:01] *** Quits: jviereck (Adium@moz-1B04BEE6.dip0.t-ipconnect.de) (Quit: Leaving.)
[20:29:36] *** Quits: austincheney (quassel@8276C73B.985A737F.603BFF2.IP) (Ping timeout)
[20:30:48] *** Joins: five (five@B112EA23.C4AAC3ED.10BB00EE.IP)
[20:32:29] *** Quits: five (five@B112EA23.C4AAC3ED.10BB00EE.IP) (Connection reset by peer)
[20:33:54] *** Joins: mib_le3ef5 (Mibbit@moz-E841EA3A.hsd1.wa.comcast.net)
[20:34:22] *** Quits: mib_le3ef5 (Mibbit@moz-E841EA3A.hsd1.wa.comcast.net) (Quit: http://www.mibbit.com ajax IRC Client)
[20:37:45] *** Quits: dan_johnsin (dan_johnsi@6902762D.11B071D.FB9A45AF.IP) (Quit: Leaving)
[20:42:13] *** Joins: SiegeLord (sl@moz-CAF07B4C.hsd1.ma.comcast.net)
[20:42:26] *** Joins: kgriffs (Adium@moz-7E0D846A.aus1.rackspace.com)
[20:42:55] <tiffany> I have my small language evaluating simple S-exprs now
[20:44:06] *** Quits: kgriffs (Adium@moz-7E0D846A.aus1.rackspace.com) (Ping timeout)
[20:45:51] *** Quits: int3_ (int3_@moz-ABE52D50.hsd1.ca.comcast.net) (Client exited)
[20:46:12] *** Joins: int3_ (int3_@moz-ABE52D50.hsd1.ca.comcast.net)
[20:46:37] <glyc> Hi tiffany, that's interesting, is your language on github?
[20:46:48] <tiffany> https://github.com/tiffany352/frscript
[20:46:52] *** Quits: int3_ (int3_@moz-ABE52D50.hsd1.ca.comcast.net) (Connection reset by peer)
[20:47:06] *** Joins: int3_ (int3_@moz-ABE52D50.hsd1.ca.comcast.net)
[20:47:48] *** Quits: int3_ (int3_@moz-ABE52D50.hsd1.ca.comcast.net) (Client exited)
[20:47:59] <glyc> tiffany: very interesting. In case it is useful, I would mention that there is a high-performance s-expression parser library in C available (http://sourceforge.net/p/sexpr/code/ci/master/tree/)
[20:48:08] *** Joins: int3_ (int3_@moz-ABE52D50.hsd1.ca.comcast.net)
[20:49:56] *** Quits: int3_ (int3_@moz-ABE52D50.hsd1.ca.comcast.net) (Ping timeout)
[20:50:09] *** Quits: adu (ajr@moz-F930C5C9.washdc.fios.verizon.net) (Quit: adu)
[20:54:11] *** Quits: threecreepio (jdp@moz-71E164C9.cust.bredbandsbolaget.se) (Client exited)
[20:55:08] *** Joins: threecreepio (jdp@moz-71E164C9.cust.bredbandsbolaget.se)
[20:56:08] *** Joins: victorporof (victorporo@9D964D4D.36D485C.2B3D3D4.IP)
[20:56:43] <dcrewi> I see you're using vectors instead of cons cells
[20:57:12] *** Quits: eatkinson (eatkinson@moz-261EDE03.hsd1.ca.comcast.net) (Quit: eatkinson)
[20:58:56] *** Quits: jmgrosen (jmgrosen@moz-848F6087.sb.sd.cox.net) (Quit: jmgrosen)
[20:58:57] <tiffany> I'm sure that is some kind of horrible sin in the lisp world
[20:59:54] *** Joins: jmgrosen (jmgrosen@moz-848F6087.sb.sd.cox.net)
[21:00:29] <dcrewi> I only mention it because I tried to write a simple owned linked-list module the other day and failed horribly
[21:00:41] *** Joins: vodik (simon@moz-CBE4BB13.cable.teksavvy.com)
[21:00:54] <dcrewi> and I was hoping to study one that worked
[21:01:15] <tiffany> I have a doubly linked list implementation in C preprocessor
[21:01:16] <strcat> well there are more complex owned data structures in the stdlib
[21:01:36] <strcat> std::trie and extra::treemap don't use copies or managed pointers
[21:01:58] <tiffany> I don't really use them very often because of their undesirable index performance
[21:02:33] <strcat> can usually just use a ring buffer
[21:02:43] <strcat> deletion/inserts in the middle? pfft, use a map ;p
[21:02:46] *** Quits: victorporof (victorporo@9D964D4D.36D485C.2B3D3D4.IP) (Ping timeout)
[21:03:26] <dcrewi> there's also a double linked-list in extra
[21:03:32] <cmr> dcrewi: DList and List in extra iirc
[21:03:48] <strcat> the list is a really ancient persistent list
[21:04:01] <cmr> dlist also cheats with unsafe code.
[21:04:16] <strcat> a doubly-linked list has to be written with managed pointers (or a refcounted ptr with weak pointers) or unsafe code
[21:04:30] <dcrewi> I think cheating with unsafe code is the only way to do it. I just don't know how to cheat very well
[21:04:48] <strcat> dcrewi: it's not the only way
[21:05:12] <strcat> an owned singly-linked list has no need for unsafe code, a safe doubly-linked list can use @
[21:06:17] <glyc> I'm looking an example of how to use the Rust serialize system to write struct instances to disk. Does anyone have sample code?
[21:06:21] <jmgrosen> are there any at least semi-working HTTP client libraries? or bindings?
[21:06:25] <strcat> jmgrosen: yes
[21:06:35] *** Joins: maik (maik___@moz-7490859E.dip0.t-ipconnect.de)
[21:06:39] <strcat> jmgrosen: https://github.com/chris-morgan/rust-http
[21:06:58] <dcrewi> strcat: maybe
[21:07:01] <Eridius> strcat: I have to say, HTTP support isn't very impressive when rust can't resolve DNS yet ;)
[21:07:21] <strcat> dcrewi: not 'maybe', it's a fact that you don't need unsafe code for it
[21:07:35] <dcrewi> strcat: I'll believe it when I see it
[21:07:37] <Eridius> as long as you don't need to support circular lists..
[21:07:40] <strcat> a self-balancing binary tree and a radix trie are more complex than a list, and there are impls in the stdlib without unsafe code
[21:07:47] <strcat> dcrewi: why not look at those? ^
[21:08:04] <jmgrosen> strcat: doesn't seem to be particularly high-level yet -- it's more like "write your request, and then i'll send it for you"
[21:08:23] <cmr> rusti: struct LinkedList<T> { node: T, next: Option<~LinkedList<T>> }
[21:08:26] -rusti- ()
[21:08:33] <cmr> dcrewi: believe it now?
[21:09:17] *** Joins: jgilbert (jgilbert@moz-4C088FCE.hsd1.ca.comcast.net)
[21:09:37] <dcrewi> cmr: yeah, but I wanted it to be enum LinkedList<T> { Nil, Cons(T, ~ConsCell<T>) }
[21:09:57] *** Joins: nrc (nrc@7BE24E90.A5032A01.3CFC199D.IP)
[21:10:14] <dcrewi> cmr: because yours can't be empty (unless you wrap it again in an Option)
[21:10:20] <strcat> rusti: enum List<T> { Nil, Cons(T, ~List<T>) }
[21:10:21] -rusti- ()
[21:10:30] <strcat> rusti: enum List<T> { Nil, Cons(T, ~List<T>) } Cons(5, Nil)
[21:10:31] -rusti- <anon>:5:57: 5:60 error: mismatched types: expected `~main::List<<VI0>>` but found `main::List<<V5>>` (expected ~-ptr but found enum main::List)
[21:10:31] -rusti- <anon>:5          enum List<T> { Nil, Cons(T, ~List<T>) } Cons(5, Nil)
[21:10:31] -rusti-                                                                   ^~~
[21:10:31] -rusti- error: aborting due to previous error
[21:10:31] -rusti- application terminated with error code 101
[21:10:35] <strcat> rusti: enum List<T> { Nil, Cons(T, ~List<T>) } Cons(5, ~Nil)
[21:10:36] -rusti- Cons(5, ~Nil)
[21:10:38] <Eridius> enum List<T> { Nil, Cons(T, Option<~List<T>>) }
[21:10:46] <Eridius> no wait, I'm silly
[21:10:51] * Eridius needs more caffeine
[21:11:02] <strcat> rusti: enum List<T> { Nil, ~Cons(T, List<T>) } Cons(5, Nil)
[21:11:03] -rusti- <anon>:5:29: 5:30 error: expected ident, found `~`
[21:11:03] -rusti- <anon>:5          enum List<T> { Nil, ~Cons(T, List<T>) } Cons(5, Nil)
[21:11:03] -rusti-                                       ^
[21:11:03] -rusti- application terminated with error code 101
[21:11:04] <onr> dude, whose idea is this?
[21:11:21] <strcat> was what?
[21:11:31] *** Quits: sruggier (sruggier@moz-F1ED47A9.cpe.teksavvy.com) (Ping timeout)
[21:11:35] <onr> the bot sends notice to channel
[21:11:42] <Eridius> that's what bots are supposed to do
[21:11:42] <cmr> The IRC spec mandates it.
[21:11:45] <strcat> that's what notice is for
[21:11:55] <Eridius> NOTICE is explicitly defined in the IRC RFCs as the alternative to PRIVMSG that bots use
[21:12:04] <strcat> The NOTICE command is used similarly to PRIVMSG.  The difference
[21:12:06] <strcat>    between NOTICE and PRIVMSG is that automatic replies MUST NEVER be
[21:12:08] <strcat>    sent in response to a NOTICE message.
[21:12:09] <Eridius> and the reason is because bots are supposed to ignore incoming NOTICEs, so this avoids bot loops
[21:13:02] <onr> that's horrifying
[21:13:20] <strcat> onr: why?
[21:13:21] <cmr> ...why?
[21:13:21] <Tad> The IRC spec is old
[21:13:23] <onr> thankfully most bot maintainers ignore IRC specs
[21:13:25] <strcat> it's what it's for
[21:13:33] <strcat> onr: why exactly?
[21:13:33] <cmr> onr: everyone who uses irc ignores the spec
[21:13:42] <strcat> your client is not supposed to do anything weird with notice
[21:13:46] <Tad> I don't know any bots which dont respond in the channel
[21:13:47] <cmr> that's why it blows so hard 98% of the time
[21:13:57] <cmr> Tad: it does respond in the channel. with a notice.
[21:13:59] <jmgrosen> so are we waiting for a pure rust implementation of a DNS client, or bindings?
[21:14:12] <Tad> cmr: That's the point
[21:14:23] *** Quits: dymk (dymk@E913D3B5.A6E21E6E.5E500FC7.IP) (Ping timeout)
[21:14:31] <strcat> Tad: that's what notice is for, nothing else
[21:14:39] <strcat> it's for sending a message that should not be automatically replied to
[21:14:39] <Eridius> onr: what's wrong with notices? The only issue I know if is some stupid IRC clients try to do funny things with them (such as making an audible alert), but that's the client's fault
[21:14:42] <cmr> jmgrosen: libuv already does it, so just bindings.
[21:14:48] <strcat> that's why freenode's services use notice
[21:14:51] <jmgrosen> cmr: ah, ok
[21:14:52] <strcat> to avoid looping with a bot
[21:15:34] <tiffany> ignoring the spec is bad for everyone
[21:15:46] <tiffany> irc is old, but the spec is not that flawed
[21:16:07] <strcat> every irc client I've used simply marks notices slightly different than privmsgs
[21:16:12] <tiffany> it annoys me to no end when people try to parse irc with regex, and ignoring the spec is no different
[21:16:22] <Eridius> biggest flaw is the fact that it doesn't standardize an encoding, but I think everybody seems to have settled on utf-8 these days
[21:16:47] <tiffany> except xchat, which defaults to latin-1
[21:16:51] <strcat> Eridius: if it didn't standardize an encoding it wouldn't have been UTF-8, so we should be thankful it didn't ;p
[21:17:02] <tiffany> and probably some of those android/iphone clients
[21:17:08] <strcat> tiffany: xchat is dead though - does hexchat still use latin-1?
[21:17:10] <cmr> kvirc uses utf-16 on windows.
[21:17:14] <tiffany> hexchat defaults to utf-8
[21:17:24] <Eridius> strcat: yeah yeah, but it would have been nice to put out an updated RFC that recommends utf-8 or somesuch
[21:17:34] <Eridius> cmr: NUL isn't allowed in IRC messages IIRC. So it can't possibly use UTF-16
[21:17:53] <sebcrozet> Hi. If i need a shared pointer without cycles, should I use RCmut<T> or @mut T ?
[21:18:12] <onr> Eridius: fair point. all gui clients i use make noise when they see channel notice
[21:18:36] <Eridius> onr: hopefully they have a way to turn that off
[21:18:38] <strcat> sebcrozet: depends on the performance characteristics you want
[21:18:40] *** Joins: int3_ (int3_@moz-ABE52D50.hsd1.ca.comcast.net)
[21:19:03] <strcat> @mut *will* use a tracing gc
[21:19:38] <SiegeLord> What's happening with that, without graydon?
[21:20:13] <strcat> sebcrozet: but right now, RcMut is significantly faster than @mut, so you might as well use it if you can
[21:20:26] <strcat> (since both use refcounting, but extra::rc has move semantics and smaller headers)
[21:20:59] <sebcrozet> strcat: and in which situations a tracing gc can be faster than reference counting?
[21:21:14] <strcat> sebcrozet: lots and lots of short-lived small objects
[21:21:17] <strcat> a gc will perform better
[21:21:19] *** Quits: maik (maik___@moz-7490859E.dip0.t-ipconnect.de) (Client exited)
[21:21:35] <strcat> sebcrozet: if they are large + long-lived, or you don't need to copy them frequently, then refcounting will do better
[21:22:29] <strcat> refcounting also has the advantage of using significantly less memory
[21:22:47] <strcat> and resource cleanup is still based on stack discipline - it always happens as soon as possible
[21:22:58] <doomlord> is that due to freeing more deterministically or bookkeeping overhead
[21:23:09] <cmr> doomlord: refcounting isn't free
[21:23:11] <Eridius> relevant factoid: obj-c's ref-counting implementation doesn't actually store the refcount anywhere when it's at 1, so short-lived objects that never get retained have zero memory overhead
[21:23:15] *** Joins: pepper_chico (pepper_chi@EF476D4E.D3DE4871.E4090502.IP)
[21:23:29] <strcat> Eridius: well the memory overhead is smaller than gc even with the 1-word header used by Rc
[21:23:41] <Eridius> although in OS X 10.9 / iOS 7, small refcounts (<32 I think) are being stuffed into the isa pointer directly, which means most objects won't have extra memory overhead for the refcount
[21:23:43] <sebcrozet> strcat: sounds like refcounting is better for real-time uses?
[21:23:43] <strcat> a GC has to use 2-3x as much memory, to provide performance
[21:23:48] <strcat> sebcrozet: yes, definitely
[21:23:49] *** Quits: Ms2ger (Ms2ger@F84917BA.3387515C.187A1082.IP) (Quit: nn)
[21:23:58] <strcat> sebcrozet: garbage collection can have better throughput, is the point
[21:24:09] <Eridius> but isn't as predictable
[21:24:17] <strcat> and much use a lot of memory to provide speed
[21:24:19] *** Quits: sankha93 (Instantbir@7061CD01.D6BD0D91.22D41759.IP) (Quit: Gone to save the world!)
[21:24:25] <strcat> you can have a GC without a huge amount of memory overhead, but it will be slow
[21:24:37] <strcat> and must*
[21:24:38] *** Quits: int3_ (int3_@moz-ABE52D50.hsd1.ca.comcast.net) (Ping timeout)
[21:24:46] <Eridius> there is in fact a garbage-collection implementation designed for real-time, but in general, GC isn't appropriate for real-time because it doesn't make any guarantees about its collection pauses
[21:25:02] <sebcrozet> I see.
[21:25:02] <cmr> some GC algorithms don't.
[21:25:29] <Eridius> this real-time GC impl (I forget its name) makes hard guarantees about how often and how long its pauses are, but the downside is if you create too much garbage it won't be able to keep up and you'll exhaust memory
[21:25:53] <strcat> Eridius: well and if it's real-time/incremental it will have lower throughput
[21:25:59] <Eridius> also true
[21:26:26] <sebcrozet> and is there a way to have a RCmut trait object? (just like I can to `someimpl as @mut SomeTrait`)
[21:26:40] <strcat> sebcrozet: no, not atm
[21:26:58] <pnkfelix> Eridius: Metronome is the research name for one relevant real-time GC tech done at IBM
[21:27:23] <pnkfelix> Eridius: though there were other follow-on projects with different names (e.g. one to add Generational Collection support)
[21:27:48] <Tad> Metronome is also BUB bum bum bum BUB bum bum bum
[21:28:10] *** Joins: KindOne (KindOne@moz-749DF21A.dynamic.ip.windstream.net)
[21:28:26] <cmr> 5/4 superiority
[21:28:27] <Eridius> pnkfelix: that's probably what I was thinking of
[21:28:48] <Eridius> strcat: btw, I assume you saw that cmr went ahead and r+'d my iterator PR that documents approach #3?
[21:28:57] <strcat> Eridius: yes that's fine
[21:29:20] <pnkfelix> (There are lots of other technologies with different names.  E.g. Azul's pauseless GC, though that had hardware support in the first iteration, â€¦ most recently uses OS support rather than specialized hardware stuff)
[21:29:20] <strcat> I am not enthusiastic about it, but I agree that it's likely the least bad decision
[21:29:21] <Eridius> ok good
[21:29:22] <cmr> It can always be changed, and it's easier to change if we standardize on one, is my stance on it.
[21:29:25] <sebcrozet> strcat: ok. Thanks everybody.
[21:29:38] <Eridius> cmr: yeah I agree. And I think it's easier to go from #3 to #2/#1, than to go the other way
[21:29:47] <strcat> Eridius: agreed
[21:30:03] <strcat> it's backwards compatible with changing to the others
[21:30:28] <strcat> at least if you view the guarantee as a per-iterator thing
[21:31:34] <glyc> how to I use stuff in libextra?  use serialize::Encoder;    is complaining:  error: unresolved import. maybe a missing `extern mod serialize`?
[21:31:51] <cmr> glyc: `extern mode extra; use extra::serialize::Encoder`
[21:31:58] <strcat> s/mode/mod/
[21:32:08] <cmr> yes, thanks
[21:32:16] *** Joins: austincheney (quassel@8276C73B.985A737F.603BFF2.IP)
[21:32:21] <strcat> rusti: struct Foo(int, int); Foo(2, 3)
[21:32:22] -rusti- main::Foo{__field__: 2, __field__: 3}
[21:32:38] <glyc> srcat: thanks.
[21:32:53] * strcat wishes it did that properly
[21:33:26] *** Quits: vodik (simon@moz-CBE4BB13.cable.teksavvy.com) (Ping timeout)
[21:35:28] <pnkfelix> strcat: is there an issue files for that?
[21:35:46] <strcat> pnkfelix: likely not but I'll probably fix it today
[21:36:09] <strcat> pnkfelix: I made it print the struct name + print unit structs properly yesterday
[21:36:25] <strcat> been poking at repr a fair bit lately when it annoys me
[21:36:41] <strcat> there are a lot of problems
[21:36:52] <strcat> enough that it could have a tag ;p
[21:36:55] <SiegeLord> Is it better to return static arrays or tuples?
[21:37:00] * strcat files a few more
[21:37:15] <cmr> SiegeLord: static arrays being fixed-length vectors?
[21:37:16] <SiegeLord> Or just arrays, I guess...
[21:37:23] <SiegeLord> Yeah...
[21:37:23] <kimundi> SiegeLord: I assume you mean fixed sized arrays or tuples?
[21:37:34] <cmr> tuples don't need to be homogenous
[21:37:53] <kimundi> Right, and I think tuples get padded, while vectors don't ?
[21:38:19] <kimundi> not sure baout that though
[21:38:27] <engla> well both are packed as structs if you lay them out
[21:38:34] <engla> but vectors can't have padding
[21:38:43] *** Quits: robertknight (robertknig@moz-53D8EF63.range81-151.btcentralplus.com) (Ping timeout)
[21:38:56] <kimundi> rusti: sys::size_of::<uint>()
[21:38:59] -rusti- pastebinned 11 lines of output: http://ix.io/7Lq
[21:39:28] <kimundi> rusti: ::std::sys::size_of::<uint>()
[21:39:29] -rusti- 8u
[21:39:35] *** Quits: DAddYE (DAddYE@moz-98D3933F.hsd1.ca.comcast.net) (Connection reset by peer)
[21:39:38] <kimundi> rusti: ::std::sys::size_of::<(u8,)>()
[21:39:39] -rusti- 1u
[21:39:43] <kimundi> rusti: ::std::sys::size_of::<(u8,u8,)>()
[21:39:43] *** Joins: alisdair (textual@CD255AEF.6ECAE21.F39A8AA1.IP)
[21:39:44] -rusti- 2u
[21:39:47] <kimundi> rusti: ::std::sys::size_of::<(u8,u8,u8)>()
[21:39:48] -rusti- 3u
[21:39:53] *** Joins: DAddYE (DAddYE@moz-98D3933F.hsd1.ca.comcast.net)
[21:39:58] <strcat> pnkfelix: filed a bunch! ;p
[21:40:04] <kimundi> rusti: ::std::sys::size_of::<(u8,u8,u8,u64)>()
[21:40:04] -rusti- 16u
[21:40:16] <strcat> pnkfelix: https://github.com/mozilla/rust/issues?direction=desc&labels=A-repr&page=1&sort=created&state=open
[21:40:23] <strcat> oh I know another
[21:40:29] <strcat> but meh
[21:40:31] <pnkfelix> strcat: :)
[21:40:37] <kimundi> rusti: ::std::sys::size_of::<(u8,u8,u8,u64>()
[21:40:37] -rusti- <anon>:6:4: 6:5 error: incorrect close delimiter: `}`
[21:40:37] -rusti- <anon>:6     };
[21:40:38] -rusti-              ^
[21:40:38] -rusti- application terminated with error code 101
[21:41:01] <kimundi> why do 15 bytes get padded to 16, but 3 remain at 3?
[21:41:15] <strcat> it's based on alignment
[21:41:20] <Eridius> kimundi: the u64 is aligned I believe
[21:41:22] <strcat> a u64 is aligned to 8-byte boundaries
[21:41:28] <Eridius> rusti: ::std::sys::size_of::<(u64,u8,u8,u8)>()
[21:41:28] -rusti- 16u
[21:41:31] <strcat> forcing the struct as a whole to have 8-byte alignment
[21:41:33] <strcat> because
[21:41:36] <strcat> think about an array of structs
[21:41:39] <strcat> [Foo, Foo, Foo]
[21:41:45] <strcat> where Foo has a type requiring 8-byte alignment
[21:41:50] <strcat> if you don't pad the struct, it will not align that field right
[21:42:03] <Eridius> rusti: ::std::sys::size_of::<(u8,u64,u8,u8)>()
[21:42:04] -rusti- 24u
[21:42:19] <strcat> alignment of a struct is just the alignment of the type with the highest alignment
[21:42:29] <strcat> + then it gets padded to a multiple of the alignment
[21:42:40] *** Joins: kgriffs (Adium@moz-7E0D846A.aus1.rackspace.com)
[21:42:54] <Eridius> rusti: ::std::sys::size_of::<(u8,u16,u8)>()
[21:42:54] <strcat> x86 allows unaligned memory accesses. but before sandy/ivy bridge, they were slow
[21:42:55] -rusti- 6u
[21:42:57] *** Quits: lenstr (lenstr@CD7D5ABA.83A99F98.85938D85.IP) (Client exited)
[21:42:58] <kimundi> rusti: ::std::sys::size_of::<(u8,u64, u8)>()
[21:42:59] -rusti- 24u
[21:44:05] <strcat> it has to align the u64 on an 8-byte boundary and the struct has to have an 8-byte alignment
[21:44:08] <strcat> it's the same as other languages
[21:44:20] *** Quits: kgriffs (Adium@moz-7E0D846A.aus1.rackspace.com) (Ping timeout)
[21:44:28] <strcat> so you have
[21:44:44] <strcat> |1|7|8|1|7|
[21:44:47] <SiegeLord> I guess I'll use static arrays and wait for somebody with an argument to come up...
[21:44:52] <strcat> where the 7s are padding
[21:44:54] *** Quits: sigma (sigma@51C589B3.EF2694B5.DFAC6AA7.IP) (Ping timeout)
[21:45:01] <SiegeLord> Damn, I should start using the correct terminology...
[21:45:34] <cmr> fixed-length vectors
[21:45:40] <cmr> Rust has arrays nowhere in the language.
[21:46:12] <engla> SiegeLord: you don't have a feeling about if it's a tuple or an array?
[21:46:15] <kimundi> SiegeLord: Does it make sense to iterate over the elements and are they all the same type: use a vector. If iterating over them doesn't make sense and/or they have different types: use a tuple
[21:46:20] <SiegeLord> cmr: Except in the manual :P
[21:46:44] <SiegeLord> kimundi, engla: it's 2D coordinates
[21:46:50] <cmr> SiegeLord: well the manual is known to be out of date in many ways.
[21:47:00] <strcat> SiegeLord: a tuple then
[21:47:03] <kimundi> SiegeLord: The manual worse than the tutorial
[21:47:18] <kimundi> Only the wiki is more out of date :P
[21:47:24] <strcat> SiegeLord: they are not an array of elements with semantically the same meaning
[21:47:37] <strcat> iterating over it doesn't make sense
[21:47:49] <SiegeLord> Well, I don't know that
[21:47:58] <SiegeLord> Somebody might want to compute a dot product
[21:48:01] *** Quits: mihneadb (mihneadb@moz-329F29A3.lightspeed.sntcca.sbcglobal.net) (Input/output error)
[21:48:03] <SiegeLord> And then it makes sense to iterate
[21:48:28] *** Joins: mihneadb (mihneadb@moz-329F29A3.lightspeed.sntcca.sbcglobal.net)
[21:49:53] *** Quits: pnkfelix (pnkfelix@moz-43495417.fbx.proxad.net) (Quit: Leaving.)
[21:50:12] *** Quits: mihneadb (mihneadb@moz-329F29A3.lightspeed.sntcca.sbcglobal.net) (Ping timeout)
[21:51:18] *** Quits: Palmik (palmik@moz-CC484FDD.tmcz.cz) (Quit: Lost terminal)
[21:51:30] * strcat shrugs
[21:52:09] <kimundi> I would propably use option 3: struct Vec2D<T>{ x: T, y: T}
[21:52:31] <kimundi> And then vector methods
[21:52:44] <kimundi> can change between all three fast anyway
[21:53:26] <kimundi> let Vec2D{x,y} = Vec2D::new(); let t = (x,y); let v = [x, y];
[21:54:08] <kimundi> Damn, I fell victim to automation
[21:54:21] <kimundi> Now I'm bored and waiting for my script to finish
[21:54:40] <SiegeLord> Hmm... how do I get the C string out out a CString?
[21:54:50] <SiegeLord> with_c_str I guess?
[21:54:51] *** Quits: pepper_chico (pepper_chi@EF476D4E.D3DE4871.E4090502.IP) (Quit: My MacBook Pro has gone to sleep. ZZZzzzâ€¦)
[21:55:08] <SiegeLord> No, that's something else...
[21:57:11] *** Joins: pnkfelix (pnkfelix@moz-43495417.fbx.proxad.net)
[21:57:11] *** ChanServ sets mode: +o pnkfelix
[21:57:19] *** Joins: pepper_chico (pepper_chi@EF476D4E.D3DE4871.E4090502.IP)
[21:57:59] *** Quits: jgilbert (jgilbert@moz-4C088FCE.hsd1.ca.comcast.net) (Ping timeout)
[22:00:12] <strcat> rusti: std::hashmap::HashSet::<int>::new()
[22:00:20] -rusti- pastebinned 1 lines of output: http://ix.io/7Lr
[22:01:12] *** Joins: victorporof (victorporo@9D964D4D.36D485C.2B3D3D4.IP)
[22:01:26] *** Joins: sigma (sigma@moz-B8E78D5.range86-136.btcentralplus.com)
[22:02:44] *** Quits: squiddy (squiddy@moz-CB1FFF0E.adsl.alicedsl.de) (Quit: Leaving)
[22:02:56] *** Quits: victorporof (victorporo@9D964D4D.36D485C.2B3D3D4.IP) (Ping timeout)
[22:05:26] *** Quits: Ralith (ralith@114DA04D.CD83ED0A.BCDF04A6.IP) (Ping timeout)
[22:07:13] *** Joins: jaen (jaen@moz-E0979827.copit.pl)
[22:07:22] *** Quits: Blub\w (wry@7E3BB9D.71150E1A.237AE2BA.IP) (Quit: night)
[22:08:45] *** Quits: pepper_chico (pepper_chi@EF476D4E.D3DE4871.E4090502.IP) (Quit: My MacBook Pro has gone to sleep. ZZZzzzâ€¦)
[22:09:28] *** Joins: pepper_chico (pepper_chi@EF476D4E.D3DE4871.E4090502.IP)
[22:10:11] *** Quits: DAddYE (DAddYE@moz-98D3933F.hsd1.ca.comcast.net) (Client exited)
[22:10:28] *** Joins: sprog (Mibbit@moz-F4801425.ee.protectedgroup.com)
[22:10:34] *** Quits: sprog (Mibbit@moz-F4801425.ee.protectedgroup.com) (User has been banned from Mozilla (no spamming here))
[22:10:44] *** Joins: DAddYE (DAddYE@moz-98D3933F.hsd1.ca.comcast.net)
[22:11:32] <engla> std::hashmap::HashSet<int>{   this should have :: there too I think
[22:12:07] <strcat> problem is it passes it the struct name
[22:12:15] <strcat> not an expr you would use to create one
[22:12:25] *** Quits: DAddYE (DAddYE@moz-98D3933F.hsd1.ca.comcast.net) (Ping timeout)
[22:12:26] <engla> rusti: struct X<T> { v: T }; X::<int> {v: 1}
[22:12:27] -rusti- main::X<int>{v: 1}
[22:12:38] <engla> aha
[22:13:00] <engla> so it passes 'X<int>'?
[22:13:15] <strcat> no it passes main::X<int>
[22:13:25] <strcat> that's the real name
[22:13:37] <strcat> you just happen to be in the main scope so you don't need to refer to it that way
[22:14:06] <strcat> rusti: struct Foo; main::Foo
[22:14:11] -rusti- pastebinned 11 lines of output: http://ix.io/7Ls
[22:14:12] * strcat shrugs
[22:14:15] <engla> the path there is no problem
[22:14:20] <strcat> it's how the compiler views it internally
[22:14:32] <strcat> rusti: struct Foo; ::main::Foo
[22:14:35] *** Quits: Florob (Florob@moz-39532932.de) (Client exited)
[22:14:40] -rusti- failed to pastebin 11 lines of output
[22:14:43] <strcat> rusti: struct Foo; ::main::Foo
[22:14:45] -rusti- pastebinned 11 lines of output: http://ix.io/7Lt
[22:15:48] <strcat> it will never be able to represent shared structures of @ in a way that can just be read in as valid rust
[22:18:58] <strcat> rusti: fn foo() {} mod foo {}
[22:18:59] -rusti- ()
[22:19:03] <strcat> shouldn't allow stuff like that
[22:19:14] <strcat> rusti: fn foo() {} mod foo {} struct foo {}
[22:19:14] -rusti- <anon>:5:44: 5:45 error: Unit-like struct definition should be written as `struct foo;`
[22:19:14] -rusti- <anon>:5          fn foo() {} mod foo {} struct foo {}
[22:19:14] -rusti-                                                      ^
[22:19:15] -rusti- application terminated with error code 101
[22:19:18] <strcat> rusti: fn foo() {} mod foo {} struct foo;
[22:19:21] -rusti- pastebinned 8 lines of output: http://ix.io/7Lv
[22:19:46] *** Joins: indirect (indirect_m@moz-22FDA25B.hsd1.ca.comcast.net)
[22:20:24] <pnkfelix> strcat: relevant ticket: #6187
[22:20:37] *** Quits: pepper_chico (pepper_chi@EF476D4E.D3DE4871.E4090502.IP) (Quit: My MacBook Pro has gone to sleep. ZZZzzzâ€¦)
[22:22:59] *** Joins: bytbox (s@moz-DC83764A.washdc.fios.verizon.net)
[22:25:36] *** Joins: pepper_chico (pepper_chi@EF476D4E.D3DE4871.E4090502.IP)
[22:28:23] *** Joins: mihneadb (mihneadb@moz-329F29A3.lightspeed.sntcca.sbcglobal.net)
[22:31:16] *** Joins: victorporof (victorporo@9D964D4D.36D485C.2B3D3D4.IP)
[22:33:23] *** Quits: victorporof (victorporo@9D964D4D.36D485C.2B3D3D4.IP) (Ping timeout)
[22:33:23] *** Quits: MrFahrenheit (RageOfThou@3FEF494C.29C984D5.783DEDCA.IP) (Connection reset by peer)
[22:33:48] *** Joins: MrFahrenheit (RageOfThou@3FEF494C.29C984D5.783DEDCA.IP)
[22:36:53] *** Quits: jaen (jaen@moz-E0979827.copit.pl) (Ping timeout)
[22:42:04] *** Quits: Diamond (dick@moz-D7E07B36.ks.ks.cox.net) (Ping timeout)
[22:42:54] *** Joins: Diamond (dick@moz-D7E07B36.ks.ks.cox.net)
[22:43:03] *** Joins: kgriffs (Adium@moz-7E0D846A.aus1.rackspace.com)
[22:44:43] *** Quits: kgriffs (Adium@moz-7E0D846A.aus1.rackspace.com) (Ping timeout)
[22:48:23] <Eridius> rusti: struct Foo{a: int} impl Foo { pub fn a(&self) { self.a } } let f = Foo{a: 3}; f.a()
[22:48:24] -rusti- <anon>:5:57: 5:63 error: mismatched types: expected `()` but found `int` (expected () but found int)
[22:48:24] -rusti- <anon>:5          struct Foo{a: int} impl Foo { pub fn a(&self) { self.a } } let f = Foo{a: 3}; f.a()
[22:48:24] -rusti-                                                                   ^~~~~~
[22:48:24] -rusti- error: aborting due to previous error
[22:48:25] -rusti- application terminated with error code 101
[22:48:32] <Eridius> rusti: struct Foo{a: int} impl Foo { pub fn a(&self) -> int { self.a } } let f = Foo{a: 3}; f.a()
[22:48:33] -rusti- 3
[22:48:35] <Eridius> rusti: struct Foo{a: int} impl Foo { pub fn a(&self) -> int { self.a } } let f = Foo{a: 3}; f.a
[22:48:36] -rusti- 3
[22:49:02] <Eridius> rusti: struct Foo{b: int} impl Foo { pub fn a(&self) -> int { self.b } } let f = Foo{b: 3}; f.a
[22:49:03] -rusti- <anon>:5:94: 5:97 error: attempted to take value of method `a` on type `main::Foo` (try writing an anonymous function)
[22:49:03] -rusti- <anon>:5          struct Foo{b: int} impl Foo { pub fn a(&self) -> int { self.b } } let f = Foo{b: 3}; f.a
[22:49:03] -rusti-                                                                                                        ^~~
[22:49:03] -rusti- error: aborting due to previous error
[22:49:05] -rusti- application terminated with error code 101
[22:49:36] *** Joins: Ralith (ralith@moz-B932C54E.hsd1.wa.comcast.net)
[22:49:55] <strcat> Eridius: you have to do (f.a)()
[22:50:11] *** Joins: enix (enix@moz-A50569DD.c3-0.slvr-ubr1.lnh-slvr.md.cable.rcn.com)
[22:50:35] <Eridius> strcat: interesting. The current behavior is actually what I was hoping for
[22:50:38] *** Quits: sigma (sigma@moz-B8E78D5.range86-136.btcentralplus.com) (Ping timeout)
[22:50:58] <Eridius> I want to have a priv field foo and a pub method .foo() { self.foo }
[22:52:36] <Infiltrator> doomlord: I'm not on C++, though.  I'm using D (which, yes is a mess of its own; but comparable to rust, I'm sure.)
[22:52:53] <Infiltrator> bjz_: Mostly because so far I haven't seen anything to make me want to move.  :P
[22:53:00] *** Quits: FrozenCow (FrozenCow@moz-B2DF4929.chello.nl) (Ping timeout)
[22:53:08] <Infiltrator> bjz_: I'm not saying that I won't look at it, of course.
[22:53:21] <kimundi> bors has nothing to do... r? - https://github.com/mozilla/rust/pull/8920
[22:54:00] <Eridius> kimundi: you don't think bors deserves a break? It's been working hard for so long!
[22:54:23] <kimundi> Pff, tincans don't deserve breaks!
[22:54:45] *** Quits: donri (dag@moz-9BB61102.tbcn.telia.com) (Client exited)
[22:55:12] <doomlord> i haven't tried D so can't honestly compare, but from what I know the features that attract me to rust are : more functional flavour (immutable by default, expression blocks),  greater emphasis on safety with C++style memory management (owned/borrowed pointers). i suppose d might be similar to the open-world stuff with 'uniform call syntax', that does look neat
[22:55:20] <strcat> kimundi: the correct derogatory term is toaster
[22:55:30] *** Quits: pepper_chico (pepper_chi@EF476D4E.D3DE4871.E4090502.IP) (Quit: My MacBook Pro has gone to sleep. ZZZzzzâ€¦)
[22:55:54] <kimundi> pff, whatever >:D
[22:56:12] <engla> yay for ccache
[22:56:33] <kimundi> ccache... I thjink I need to enable that too
[22:56:46] <kimundi> How do you do that on arch? :P
[22:56:48] <engla> should have done it before you needed llvm rebuild
[22:57:13] <strcat> llvm rebuilds quickly anyway ;p
[22:57:30] <kimundi> strcat: Keep telling yourself that...
[22:57:45] <strcat> it's a parallel build, unlike rust
[22:57:57] <Eridius> if I was still building on my 24-core Mac Pro I might agree with you
[22:58:28] <strcat> goes pretty fast on just a quad core with hyperthreading...
[22:58:33] <kimundi> I never pass -j to make because the rust part of the makefile tends to be broken with that sometimes... and when llvvm builds I'm scared of breaking it :P
[22:58:46] *** Joins: pepper_chico (pepper_chi@EF476D4E.D3DE4871.E4090502.IP)
[22:58:59] *** Quits: pepper_chico (pepper_chi@EF476D4E.D3DE4871.E4090502.IP) (Quit: Textual IRC Client: www.textualapp.com)
[22:59:29] <pnkfelix> kimundi: I've been working hard to fix the -j handling
[22:59:45] <Eridius> pnkfelix: \o/
[22:59:48] <pnkfelix> kimundi: AFAIK it works now
[22:59:49] <kimundi> great! :D
[23:00:07] *** Quits: lkuper (lkuper@moz-C0CD33ED.hsd1.in.comcast.net) (Ping timeout)
[23:00:26] <Infiltrator> doomlord: Well, this is completely prejudiced as I haven't actually tried it yet, but I don't see myself being thrilled at having to type `mutable` (or @mut or whatever it is) for most of my variables.  And D is similar in safety and UFCS, yes.
[23:01:03] <Eridius> Infiltrator: in practice, most of my variables remain happily immutable
[23:01:30] <Infiltrator> Quick scan of my code tells me that I don't do things the rust way.  :P
[23:02:03] <strcat> Infiltrator: using @ at all is rare
[23:02:04] <Eridius> Infiltrator: if I'm calling functions/methods that return a new value based on the old, without actually mutating the old, I often do something like `let x = do_something_with(x)` to "update" the variable without making it mutable
[23:02:22] <Eridius> of course you have to be careful of scopes when doing that
[23:02:26] <Eridius> I've still never used @
[23:02:42] <tiffany> .. since when does D have memory safety?
[23:03:03] <strcat> it has @safe annotations but you can't use most of the language
[23:03:04] <Infiltrator> Wait, hang on... so x is immutable, but you can change it?
[23:03:07] <strcat> it doesn't have memory safe references
[23:03:14] <strcat> Infiltrator: no, you can't change it, you can shadow it
[23:03:20] *** Quits: sp3d (a@moz-6F12212B.fidnet.com) (Ping timeout)
[23:03:29] <strcat> just normal lexical scoping
[23:03:30] <Eridius> Infiltrator: I'm creating a new variable with the same name as the old
[23:03:31] <pnkfelix> Infiltrator: each use of `let` introduces a new nested scope.  thus the shadowing
[23:03:32] <Infiltrator> Ah, okay.
[23:03:46] *** Quits: indirect (indirect_m@moz-22FDA25B.hsd1.ca.comcast.net) (Connection reset by peer)
[23:04:00] <Infiltrator> So where does the scope end, then?
[23:04:08] <tiffany> where the parent scope ends
[23:04:15] <Infiltrator> Right.
[23:04:42] <SiegeLord> tiffany: D has an opt-in safe subset
[23:05:31] *** Joins: aatch (aatch@moz-B437F499.pocketrent.com)
[23:05:31] <Infiltrator> In such a case, though, I think that a different variable name would probably be more descriptive anyway.
[23:05:49] <Eridius> Infiltrator: depends on what you're doing
[23:06:03] <Eridius> if I have an optional value taht I want to unwrap, I might say something like `let x = x.unwrap_or_default(0);`
[23:06:07] <strcat> Infiltrator: shadowing will likely be controlled by a lint switch
[23:06:10] *** Joins: indirect (indirect_m@moz-22FDA25B.hsd1.ca.comcast.net)
[23:06:29] <Infiltrator> I've found that shadowing leads to more problems than it fixes, though, when you move things around and what-not.
[23:06:33] *** Joins: erickt (Adium@49C4075F.3AC15C18.2321E71E.IP)
[23:08:42] *** Quits: drumond19 (drumond19@261AEED1.7D019E6E.8DF84892.IP) (Client exited)
[23:09:26] *** Joins: sigma (sigma@2AE71BC1.DC5B0862.37339E3A.IP)
[23:09:29] <doomlord>  but I don't see myself being thrilled at having to type `mutable` (or @mut or whatever it is) for most of my variables.<<<
[23:10:10] <doomlord> Infiltrator, you're doing it wrong if thats the case. with functional style, most mutable variables are abstracted away in maps, folds etc. you dont need to manually manipulate  accumulators, iterators
[23:10:13] *** Joins: hjr3 (hradtke@moz-E87BDF1F.socal.res.rr.com)
[23:10:15] *** Quits: hjr3 (hradtke@moz-E87BDF1F.socal.res.rr.com) (Client exited)
[23:10:36] <doomlord> its definitely a saving - i write "mut" in rust way less than i write "const" in c++
[23:10:46] <Infiltrator> True.  In functional style.  What happens when I don't want functional style?
[23:11:01] <strcat> I wouldn't call it "functional style"
[23:11:05] *** Joins: DAddYE (DAddYE@moz-98D3933F.hsd1.ca.comcast.net)
[23:11:09] <strcat> in idiomatic C++, Rust or D you reuse code
[23:11:17] <strcat> that leads to only a tiny fraction of variables being mutated
[23:12:03] <strcat> containers are usually mutable, but they aren't the majority of variables
[23:12:31] * strcat doesn't really see range iterators as being functional
[23:13:50] <kimundi> strcat: Mind giving a r+? https://github.com/mozilla/rust/pull/8920
[23:15:19] *** Quits: DAddYE (DAddYE@moz-98D3933F.hsd1.ca.comcast.net) (Ping timeout)
[23:15:29] <strcat> function parameters are already a large portion of variables, and they're rarely ever mutated
[23:15:43] *** Joins: ghrust (ghrust@79968228.6A2AE50.F3114085.IP)
[23:15:43] <ghrust> 01[13rust01] 15bors merged 06master into 06auto: 02http://git.io/3QPrnw
[23:15:43] *** Parts: ghrust (ghrust@79968228.6A2AE50.F3114085.IP) ()
[23:15:44] *** Joins: ghrust (ghrust@79968228.6A2AE50.F3114085.IP)
[23:15:44] <ghrust> 01[13rust01] 15bors pushed 2 new commits to 06auto: 02http://git.io/172RWg
[23:15:44] <ghrust> 13rust/06auto 14857f867 15Marvin LÃ¶bel: Renamed syntax::ast::ident -> Ident
[23:15:44] <ghrust> 13rust/06auto 1473a28e5 15bors: auto merge of #8920 : Kimundi/rust/master, r=thestinger
[23:15:44] *** Parts: ghrust (ghrust@79968228.6A2AE50.F3114085.IP) ()
[23:16:47] <mark_edward> hey if im making a data structure that needs parent pointers, is therer any way to keep those pointers without lifetime parameters infection all of my code...
[23:17:47] <strcat> use a different data structure?
[23:18:07] <tiffany> you can use @
[23:18:12] <kimundi> pnkfelix: Does -j now actually result in rust libraries building in parallel?
[23:18:25] <strcat> mark_edward: just stop viewing them as parent pointers
[23:18:29] <kimundi> pnkfelix: I'm seein stage0 and stage1 build happen at the same time
[23:18:29] <strcat> flip it around
[23:18:31] <pnkfelix> kimundi: no, not really
[23:18:38] <pnkfelix> kimundi: by "working", I just meant that it wouldn't die
[23:19:03] <strcat> kimundi: only a few things can happen in parallel
[23:19:09] <pnkfelix> kimundi: unlike before, where it would happily copy LLVM build products into directories that would later be cleaned out
[23:19:10] <strcat> they're insignificant
[23:19:19] <kimundi> I know, that's why I'm confused by my console output
[23:19:33] <pnkfelix> kimundi: (sorry, not LLVM build products;  I meant rt build products, like libmorestack)
[23:19:35] <strcat> kimundi: stuff *does* happen in parallel now, it's just not a significant amount
[23:19:54] <mark_edward> strcat: what do you mean?
[23:20:07] <strcat> mark_edward: I mean you only have pointers going one way, or you wouldn't be able to compile it
[23:20:10] <strcat> so they aren't parent pointers
[23:20:45] <mark_edward> how is a parent pointer in a BST not a parent pointer?
[23:20:58] <strcat> if it's a binary search tree it wouldn't be compiling with borrowed pointers to the parent
[23:21:07] * strcat shrugs
[23:21:56] <tiffany> in rust, the only way to represent bi-directional graphs is with @, unsafe code, borrowed pointer hacks (maybe), and possibly a couple other things
[23:21:58] <tiffany> you can't use ~
[23:22:08] <tiffany> ~ is one-way
[23:22:31] <strcat> well you can't use & either
[23:22:42] <strcat> you can use ~ for the child relationship
[23:22:48] <mark_edward> strcat: struct Node<'self, K> { k: K, left: Option<~Node<K>>, right: Option<~Node<K>>, parent: Option<&'self Node<K>>, } wouldn't compile?
[23:22:59] <strcat> that will compile alone
[23:23:12] <strcat> you *cannot* have a parent owning a child, with a borrow of the parent by a child
[23:23:19] <strcat> it doesn't make sense in ownership terms
[23:23:44] <strcat> your type definition doesn't actually say "this is a pointer to the parent", so the type is valid
[23:23:52] <mark_edward> so what to do? certain tree algorithms don't work without easy parent access?
[23:23:52] <pnkfelix> tiffany: (and a vector + numeric indices, of course)
[23:23:54] <strcat> it won't ever actually let you *put* a pointer to the parent in there
[23:24:14] <strcat> mark_edward: you can't represent it with owned + borrowed pointers, just not something they semantically correspond to
[23:24:38] <strcat> borrowing & will freeze the node, and then you can't store it in the child
[23:24:57] <mark_edward> didn't you write extra::TreeMap?
[23:25:03] <strcat> it doesn't use parent pointers
[23:25:06] <strcat> rbtrees don't need them
[23:25:41] <mark_edward> that's not what my C++ data structures book says...
[23:25:43] <engla> you can have either parent pointers or keep them on the stack during traversal
[23:25:46] <strcat> if it needed parent pointers, it would have to use @, a refcounted type with weak pointers, or *very carefully* use raw pointers
[23:25:57] <pnkfelix> tiffany: e.g. nmatsakis used numeric indices for librustc/middle/graph.rs
[23:26:05] <strcat> mark_edward: your C++ data structures book likely uses an ancient form of rbtrees then ;P
[23:26:12] <strcat> aatrees and llrb trees don't use parent ptrs
[23:26:40] <mark_edward> what about "pure" rbtrees?
[23:26:45] *** Quits: jensnockert (jensnocker@moz-8BE55278.customer.t3.se) (Input/output error)
[23:26:52] <strcat> mark_edward: "pure" as in what?
[23:26:59] <strcat> there's no "standard" rbtree implementation
[23:27:20] <mark_edward> well like, OG rbtrees
[23:27:23] <strcat> nodes have to track what color they are
[23:27:39] <strcat> you'd never use a parent pointer with an rbtree in a functional language, for one thing
[23:27:54] <doomlord> the rust compiler itself uses wrapped raw pointers doesn't it :)
[23:28:04] <strcat> doomlord: what do you mean?
[23:28:05] *** Quits: mihneadb (mihneadb@moz-329F29A3.lightspeed.sntcca.sbcglobal.net) (Input/output error)
[23:28:05] <engla> I don't think there is an algorithms book called OG
[23:28:07] *** Quits: alisdair (textual@CD255AEF.6ECAE21.F39A8AA1.IP) (Quit: My MacBook Pro has gone to sleep. ZZZzzzâ€¦)
[23:28:11] * engla hides
[23:28:31] *** Joins: mihneadb (mihneadb@moz-329F29A3.lightspeed.sntcca.sbcglobal.net)
[23:28:38] <mark_edward> i meant OG as in Original Gangsta as in like back before all the named variants and stuff
[23:28:58] <doomlord>  ty::t or something like that, wrapped acess to types implemented as raw pointers
[23:28:59] <strcat> a canonical rbtree doesn't need a parent pointer - it is a totally optional thing you would add to allow traversal from some node
[23:29:06] <strcat> but a rust rbtree won't be exposing the nodes anyway
[23:29:17] <strcat> unless you use @
[23:29:47] <mark_edward> i see.
[23:29:49] <strcat> and you can still add a function to find some node and iterate from it, without a parent ptr
[23:30:01] <strcat> all the parent ptr does is make a *lone node* more useful
[23:30:15] *** Quits: mihneadb (mihneadb@moz-329F29A3.lightspeed.sntcca.sbcglobal.net) (Ping timeout)
[23:30:21] <mark_edward> i've been looking around at rbtree implementations but all of thems eem to sue parent pointers. do you know where i could find some that dont?
[23:31:14] <strcat> http://www.cs.princeton.edu/~rs/talks/LLRB/LLRB.pdf
[23:31:22] *** Quits: cdidd (cdidd@moz-4D3C4159.broadband.corbina.ru) (Input/output error)
[23:31:52] *** Joins: victorporof (victorporo@9D964D4D.36D485C.2B3D3D4.IP)
[23:33:53] *** Quits: victorporof (victorporo@9D964D4D.36D485C.2B3D3D4.IP) (Ping timeout)
[23:34:38] <strcat> the rust tree should probably be rewritten based on the simpler llrb algorithms
[23:34:46] * strcat didn't know about them when he made it
[23:34:57] <strcat> assuming it's faster, at least
[23:35:25] <mark_edward> strcat: if i gave it a shot, would you give it a look when you have the tiime?
[23:35:26] <engla> the main this is just that it has less cases to consider I think
[23:35:43] <strcat> engla: yeah but an AA tree is similar, except it's right-leaning
[23:35:56] <strcat> but the algorithms in the paper are a simpler way of looking at it
[23:36:09] *** Joins: cdidd (cdidd@moz-A88D4C43.broadband.corbina.ru)
[23:36:39] <strcat> an AA tree (what the rust tree is) only has 2 cases to worry about too
[23:36:48] <strcat> the skew and split functions handle them
[23:38:26] <Eridius> rusti: true.to_int()
[23:38:27] -rusti- <anon>:5:9: 6:5 error: type `bool` does not implement any method in scope named `to_int`
[23:38:27] -rusti- <anon>:5          true.to_int()
[23:38:27] -rusti- <anon>:6     };
[23:38:27] -rusti- error: aborting due to previous error
[23:38:27] -rusti- application terminated with error code 101
[23:39:05] <engla> I want to add char and line iterators to libstd. but eventually those will need to be integrated into a bigger picture of multiple encodings
[23:39:08] <Eridius> rusti true as uint
[23:39:12] <Eridius> rusti: true as uint
[23:39:13] -rusti- 1u
[23:39:16] <Eridius> rusti: false as uint
[23:39:17] -rusti- 0u
[23:39:26] <strcat> rusti: true.to_bit()
[23:39:26] -rusti- <anon>:5:9: 6:5 error: type `bool` does not implement any method in scope named `to_bit`
[23:39:26] -rusti- <anon>:5          true.to_bit()
[23:39:26] -rusti- <anon>:6     };
[23:39:27] -rusti- error: aborting due to previous error
[23:39:27] -rusti- application terminated with error code 101
[23:39:33] * strcat thought it had some method like that
[23:39:51] <dbaupp> rusti: ( 5 as bool, 5 as bool == true)
[23:39:52] -rusti- (true, false)
[23:39:54] <Eridius> what the heck is the point of std::bool::is_true()?
[23:39:59] <engla> rusti: true.to_bytes()
[23:39:59] -rusti- <anon>:5:9: 6:5 error: type `bool` does not implement any method in scope named `to_bytes`
[23:40:00] -rusti- <anon>:5          true.to_bytes()
[23:40:00] -rusti- <anon>:6     };
[23:40:00] -rusti- error: aborting due to previous error
[23:40:00] -rusti- application terminated with error code 101
[23:40:05] <Eridius> rusti: 5 as bool as uint
[23:40:06] -rusti- 5u
[23:40:08] <Eridius> oh fun
[23:40:10] <dbaupp> Eridius: to double chceck?
[23:40:14] <strcat> Eridius: don't know, I remember one time I wanted to remove all of those
[23:40:20] <Eridius> rusti: std::bool::to_bit(true)
[23:40:21] -rusti- 1u8
[23:40:25] <Eridius> rusti: std::bool::to_bit(5 as bool)
[23:40:26] -rusti- 1u8
[23:40:31] <strcat> Eridius: it's a trans bug
[23:40:37] <Eridius> yeah I know the `5 as bool` is a bug
[23:40:59] <engla> Eridius: clean it up to re-use the impementation in std::util::id :)
[23:41:14] <Eridius> I assume it's safe to actually rely on `true as uint` to give 1u though, because the only way to trigger the bug is via casting and I'm not casting to create my bool?
[23:41:27] <Eridius> rusti: ((5 as bool) && true) as uint
[23:41:27] <strcat> Eridius: yes that's safe
[23:41:28] -rusti- 1u
[23:41:35] <Eridius> rusti: (true && (5 as bool)) as uint
[23:41:36] <strcat> Eridius: don't cast ints as bool though
[23:41:37] -rusti- 5u
[23:41:43] <Eridius> strcat: yeah, not planning on doing that
[23:41:43] *** Joins: dymk (dymk@E913D3B5.A6E21E6E.5E500FC7.IP)
[23:43:03] *** Quits: Jesin (Jessin_@moz-DD8D71FB.cc.lehigh.edu) (Ping timeout)
[23:43:29] *** Joins: kgriffs (Adium@moz-7E0D846A.aus1.rackspace.com)
[23:44:49] <MrByte> rusti: trait Test<T: Test> { fn get_test(&self) -> &T; }
[23:44:50] -rusti- Segmentation fault
[23:44:50] -rusti- application terminated with error code 139
[23:45:09] *** Quits: kgriffs (Adium@moz-7E0D846A.aus1.rackspace.com) (Ping timeout)
[23:45:24] <strcat> rustc is currently in transition to a new runtime and doesn't protect against a stack overflow
[23:45:32] <strcat> s/rustc/rust/
[23:45:48] <strcat> anyway it also doesn't detect infinite recursion in types yet
[23:46:15] <MrByte> Yeah, it was bad code anyway.  Just wanted to verify, since it just crashes silently on windows for me right now.
[23:46:17] *** Quits: Ralith (ralith@moz-B932C54E.hsd1.wa.comcast.net) (Ping timeout)
[23:46:41] <dbaupp> does anyone feel like helping fix my metadata: https://github.com/mozilla/rust/pull/8921 ?
[23:47:12] <dbaupp> rusti: (true & (5 as bool)) as uint
[23:47:14] -rusti- 1u
[23:47:38] <Eridius> rusti: (true & (6 as bool)) as uint
[23:47:39] -rusti- 0u
[23:47:42] <Eridius> dbaupp: ^
[23:48:03] <strcat> Eridius: it's undefined behaviour though
[23:48:08] <strcat> it just happens to do that right now
[23:48:09] <dbaupp> Eridius: neat
[23:48:19] <Eridius> strcat: hopefully that will become defined once (6 as bool) is fixed, yeah?
[23:48:22] <strcat> because bools have range assert metadata on them
[23:48:30] <strcat> Eridius: it's not '6 as bool' that needs to be fixed
[23:48:31] <dbaupp> rusti: 6 as bool
[23:48:32] -rusti- true
[23:48:32] <strcat> it's bools in general
[23:48:45] <strcat> they are represented as i8 instead of i1 like they should be
[23:48:49] <strcat> they should only be *stored* as i8
[23:49:13] <strcat> and 'as' is naive and just uses truncation/extension, which is correct, if bool was implemented right
[23:49:14] <Eridius> strcat: right, but `(6 as bool)` should still produce a true value
[23:49:19] <strcat> Eridius: no it doesn't
[23:49:22] <Eridius> no?
[23:49:23] <strcat> it produces undefined behaviour
[23:49:37] <strcat> Eridius: oh you mean what *will* it do
[23:49:42] <Eridius> right I mean when trans is fixed
[23:49:47] <Eridius> I would hope (6 as bool) is still considered true
[23:49:52] <strcat> yes it will truncate down to i1, so anything other than 0 will be 1
[23:50:00] <strcat> don't know what would happen to a negative int
[23:50:02] <engla> why not use (6 != 0) instead of a cast
[23:50:04] <strcat> off the top of my head
[23:50:25] <Eridius> engla: well I don't think anyone _should_ write `6 as bool`, but it should still do the obvious thing
[23:50:34] <Eridius> rusti: 300 as u8
[23:50:34] -rusti- 44u8
[23:50:45] <Eridius> strcat: yeah, truncation behavior will turn `6 as bool` into `false`
[23:51:07] <dbaupp> Eridius: we could just remove `as bool` too
[23:51:08] * Eridius thinks `as` should be special-cased for converting to bool. Either that, or disallow it
[23:51:16] <dbaupp> rusti: 1f as bool
[23:51:17] -rusti- true
[23:51:29] <dbaupp> rusti: (1f as bool) as u8
[23:51:29] -rusti- 1u8
[23:51:38] <dbaupp> rusti: (1e100 as bool) as u8
[23:51:39] -rusti- 255u8
[23:51:44] <Eridius> rusti: (2f as bool) as u8
[23:51:44] -rusti- 2u8
[23:51:53] <strcat> Eridius: I don't think it will
[23:52:06] <dbaupp> rusti: (300 as bool) as u8
[23:52:06] -rusti- 44u8
[23:52:07] <strcat> rusti: u32::max_value as uint
[23:52:10] -rusti- pastebinned 11 lines of output: http://ix.io/7LC
[23:52:12] <strcat> rusti: std::u32::max_value as uint
[23:52:13] -rusti- 4294967295u
[23:52:15] <strcat> rusti: std::u32::max_value as uint + 1
[23:52:16] -rusti- 4294967296u
[23:52:22] <strcat> rusti: (std::u32::max_value as uint + 1) as u32
[23:52:23] -rusti- 0u32
[23:52:31] <strcat> meh I guess it will
[23:52:36] <strcat> anyway we could just remove 'as' for bools
[23:52:40] <strcat> that's just what 'as' does
[23:52:44] <Eridius> converting from bool to integral type is nice
[23:52:59] <Eridius> strcat: converting from floating-point to integral does a meaningful conversion rather than bitwise truncation
[23:53:10] <Eridius> I don't see why converting to bool couldn't do a meaningful conversion as well
[23:54:49] *** Quits: a__ (a__@moz-25043B93.nycmny.fios.verizon.net) (Ping timeout)
[23:55:52] *** Quits: threecreepio (jdp@moz-71E164C9.cust.bredbandsbolaget.se) (Quit: threecreepio)
[23:59:08] *** Quits: andor (andor@moz-708868D.neferty.me) (Client exited)

[00:00:23] <bjz> dbaupp: would it be easier just to have a separate 'Macro' Value varient?
[00:00:45] <dbaupp> bjz: maybe, but you'd need a RustMacro variant
[00:00:47] *** Joins: tav (tav@moz-F64BC922.range86-145.btcentralplus.com)
[00:00:51] <bjz> Ahh ok
[00:01:36] <dbaupp> but having extra variants isn't that different to having a bool on some of them, so either is probably fine
[00:02:36] <dbaupp> bjz: I just realised that scoping doesn't work, so the @Rusp pointer in the Lambda and Rust variants is needed
[00:04:40] <bjz> dbaupp: I just get concerned about flags :)
[00:05:18] <dbaupp> bjz: flags?
[00:05:27] <dbaupp> oh, for macros vs fn
[00:05:32] <bjz> yah
[00:05:45] <dbaupp> it's your lisp :) I'm not fussed either way
[00:06:30] <bjz> dbaupp: yay, dynamic scoping ftw!
[00:06:44] <bjz> (re @Rusp)
[00:07:58] <dbaupp> bjz: (I've not got time to implement dynamic scoping, just to be clear :) )
[00:08:48] <dbaupp> (at least, not today)
[00:08:54] *** Joins: bent (chatzilla@moz-932324BF.hsd1.ca.comcast.net)
[00:09:35] <bblum> what. Rusp.
[00:09:58] <dbaupp> bblum: https://github.com/bjz/rusp
[00:11:06] <nmatsakis> graydon: brson: tjc: we have...agreed to remove copy keyword eventually, right?
[00:11:14] <graydon> I believe so
[00:11:21] <tjc> nmatsakis: I thought we agreed, yeah
[00:11:31] <nmatsakis> ok, I hvae a PR that removes `copy` bindings from patterns,
[00:11:33] <nmatsakis> so I wanted to check.
[00:11:39] <bblum> ah, it will be turned into clone?
[00:11:47] <nmatsakis> some refactorings for my bigger patch that fixes `let` bindings
[00:12:04] <nmatsakis> that doesn't quite bootstrap yet, though it gets fairlyfar
[00:12:07] *** Quits: steven_is_false (user@moz-144077DE.bchsia.telus.net) (Ping timeout)
[00:13:41] <nmatsakis> is there a bug for "debug info doesn't work"?
[00:14:04] <bstrie> I thought there was
[00:14:11] <aatch> Hmm, so there was a speed regression at some point.
[00:15:44] <bstrie> nmatsakis: https://github.com/mozilla/rust/issues/6814?source=cc
[00:16:25] <nmatsakis> bstrie: good enough, I just wanted an issue # to label a fixme with :)
[00:16:41] <dbaupp> aatch: yesterday theiz (I think?) noticed that his ray tracer ran 2x slower with a current rustc than one a week ago
[00:16:41] <nmatsakis> bstrie: thanks, I search around but didn't uncover that one
[00:16:58] *** Quits: reyre_ (reyre@moz-9002CDDA.cpe.net.cable.rogers.com) (Client exited)
[00:16:59] <aatch> it /ran/ slower?
[00:17:03] <aatch> Or compiled slower?
[00:17:07] <dbaupp> aatch: ran
[00:17:39] <dbaupp> presumably compiled slower too, but the measurement went 4.2 -> 9.something seconds
[00:17:54] <strcat> dbaupp: well we reverted the noalias on &mut for now... if it was vectorizing a loop that would make sense
[00:17:57] *** Joins: krig (krig@A2A7CF2C.5AB9C4E2.B1C414DA.IP)
[00:17:59] <bstrie> graydon: how often do the buildbots purge their logs? that's twice today that I've gone to look at a past log to find it missing
[00:18:15] *** Quits: kemurphy (kemurphy@moz-7332FD74.hsd1.pa.comcast.net) (Ping timeout)
[00:18:28] <graydon> bstrie: umm, sec
[00:18:33] <dbaupp> strcat: I'm not sure the &mut noalias was in a compiler that  old?
[00:19:03] <strcat> well I don't know what else changed beyond the recent compiler pass stuff (since yesterday?)
[00:19:22] <bstrie> graydon: really we only care about saving logs that record errors, if that's feasible to configure
[00:19:27] <bstrie> so as to save a lot of space
[00:19:43] <bstrie> if space is indeed a concern
[00:19:44] <dbaupp> thiez_: ping
[00:19:49] <aatch> Hmm, odd. I'm getting a speed regression that's pretty much entirely from the LLVM passes (as in, more time spent optimizing)
[00:19:55] *** Joins: Boreeas (Boreeas@84BE3A7D.944229DB.95550721.IP)
[00:19:55] *** Joins: Luqman (laden@moz-DCEF6040.csclub.uwaterloo.ca)
[00:19:55] *** Joins: Sorella (queen@B12A78F5.BA14766C.95C8B7C6.IP)
[00:20:14] *** Joins: santiago (santiago@moz-8ADE82B4.socal.res.rr.com)
[00:20:27] <dbaupp> thiez_: it's your ray-tracer that runs slower, right?
[00:20:56] <strcat> rusti: 5 + 2
[00:20:57] -rusti- 7
[00:21:01] *** Joins: Diamond (Mibbit@moz-625C0DAF.ks.ok.cox.net)
[00:21:27] *** Joins: arete (arete@moz-CE1DC602.xen.prgmr.com)
[00:21:30] *** Joins: pcwalton (pcwalton@2557E599.66715431.D25A875A.IP)
[00:21:30] *** ChanServ sets mode: +o pcwalton
[00:21:31] *** Joins: yosemite (sam@moz-8CEAB1B0.dasbistro.com)
[00:22:24] *** Joins: maxli (maxli@C03F2759.C70D537E.2FA4EA88.IP)
[00:22:25] <graydon> bjz: I just bumped the limits way up. was last 40 builds, now 1000 builds
[00:22:47] <graydon> bjz: apologies, lazy copy-paste from the docs, I should not have set it so low
[00:22:55] *** Joins: sfackler (sfackler@moz-316FE70F.compute-1.amazonaws.com)
[00:22:57] <strcat> rusti: 5
[00:22:58] -rusti- 5
[00:22:58] -rusti- peak memory usage: 64921600
[00:23:06] <bjz> graydon: ?
[00:23:18] *** Quits: tjc (tjc@A5087023.2354C43D.D8E68FF6.IP) (Quit: Places to go, people to annoy)
[00:23:22] *** Quits: Diamond (Mibbit@moz-625C0DAF.ks.ok.cox.net) (concrete.mozilla.org gravel.mozilla.org)
[00:23:22] *** Quits: Boreeas (Boreeas@84BE3A7D.944229DB.95550721.IP) (concrete.mozilla.org gravel.mozilla.org)
[00:23:22] *** Quits: Luqman (laden@moz-DCEF6040.csclub.uwaterloo.ca) (concrete.mozilla.org gravel.mozilla.org)
[00:23:22] *** Quits: Sorella (queen@B12A78F5.BA14766C.95C8B7C6.IP) (concrete.mozilla.org gravel.mozilla.org)
[00:23:27] <dbaupp> graydon probably means bstrie?
[00:23:28] <strcat> rusti: 5
[00:23:29] -rusti- 5
[00:23:29] -rusti- peak memory usage: 61316KiB
[00:23:36] <graydon> oh, yes, I do! sorry, bstrie ^^
[00:23:44] *** Joins: terje (terje@moz-C0F75C5F.san.res.rr.com)
[00:23:45] <bjz> aww
[00:23:47] <nmatsakis> graydon: r? https://github.com/mozilla/rust/pull/6818
[00:23:47] <graydon> eyes crossed. end of day. heading out momentarily
[00:23:51] <nmatsakis> oh, nm :)
[00:23:56] * bjz , forever alone
[00:24:11] <strcat> rusti: let mut xs = std::hashmap::HashMap::new(); xs.insert(5, 5); xs.len()
[00:24:12] -rusti- 1
[00:24:12] -rusti- peak memory usage: 73600KiB
[00:24:21] <strcat> heh it's closer to the limit than I though
[00:24:36] <dbaupp> bjz: :(
[00:24:44] <dbaupp> strcat: is that rustc memory usage?
[00:24:51] <strcat> dbaupp: peak memory usage of the container
[00:24:52] <bjz> bblum: rusp is me, dbaupp, and aatch's little scripting language thingy that we're hacking together
[00:24:59] <graydon> nmatsakis: r+
[00:25:05] <strcat> dbaupp: so... rustc + whatever rustc spawns (ld) if that's the peak
[00:25:14] <aatch> Well, it's those two atm, I'm working on other things atm.
[00:25:20] <brson> aatch: how is your deque looking?
[00:25:22] <strcat> I have the limit at 128MiB
[00:25:23] *** Quits: graydon (Adium@A5087023.2354C43D.D8E68FF6.IP) (Quit: Leaving.)
[00:25:28] <dbaupp> aatch: you've got at least 2 commits ;)
[00:25:37] <strcat> anyway a web interface would be spawning them concurrently so it matters more
[00:25:46] <bjz> aatch: which means you are 'committed'
[00:25:46] <dbaupp> strcat: ah, I see
[00:26:00] <bjz> aatch: heh, jk
[00:26:10] <aatch> brson, Well I'm not sure. What I have seems to work though
[00:26:11] <dbaupp> strcat: oooh, something like play.rust-lang.org ?
[00:26:54] <bjz> paste.rust-lang.org?
[00:27:12] <bjz> http://dpaste.dzfl.pl/ ?
[00:27:22] *** Joins: Sorella (queen@B12A78F5.BA14766C.95C8B7C6.IP)
[00:27:22] *** Joins: Luqman (laden@moz-DCEF6040.csclub.uwaterloo.ca)
[00:27:25] <strcat> dbaupp: yeah
[00:27:29] *** Joins: kemurphy (kemurphy@moz-7332FD74.hsd1.pa.comcast.net)
[00:27:42] <strcat> dbaupp: it also counts usage of kernel resources like the tmpfs mounts it makes
[00:27:54] <strcat> so just, whatever the actual peak usage is
[00:28:36] <strcat> kernel memory is a separate limit. I should probably enable that
[00:28:50] *** Joins: jrfeenst (jrfeenst@moz-3265BD65.cpe.norwoodlight.com)
[00:29:25] <aatch> Hmm, so removing basic-block vectorization (which wasn't on before) drops compilation time down to something similar to before
[00:30:02] <strcat> aatch: I think that's still very in-progress
[00:30:34] *** robn` is now known as robn
[00:30:36] <aatch> It's annoying, because everything seems to affect the DAG-DAG Instruction Selection pass
[00:32:27] *** Joins: jyyou (jyyou@moz-47B052FA.cs.nctu.edu.tw)
[00:33:16] *** Joins: Diamond (Mibbit@moz-625C0DAF.ks.ok.cox.net)
[00:33:20] <aatch> strcat, would bb-vectorize also cause a general slow-down if it was incomplete?
[00:33:45] *** Joins: Boreeas (Boreeas@moz-F35C832D.boreeas.net)
[00:33:51] <strcat> aatch: well I think they need to work on the cost model more
[00:33:52] <cmr> bb-vectorize is documented as being slow
[00:33:55] <strcat> atm it probably makes stupid decisions
[00:34:12] <strcat> as in vectorizing when it would be a bad idea
[00:34:26] <strcat> iirc they want it enabled by default by 3.4?
[00:34:43] <strcat> at -O3 I guess
[00:35:08] <aatch> Ok, because loop-vectorization is only at Aggressive, but bb-vectorize is currently Less & Default
[00:35:23] *** Joins: z0w0 (zack@moz-3E4BFDF8.qld.bigpond.net.au)
[00:35:32] <cmr> that's definitely backwards, if anytyhing
[00:35:41] <aatch> Though I'm building a compiler with it disabled completely
[00:36:18] *** Quits: SimonSapin (simon@5AAE35B2.5EFFC0B8.24454B25.IP) (Quit: Leaving.)
[00:36:23] <aatch> since it's possible that it might be responsible for the other 4-5 seconds not attributed to the BB-Vectorize pass itself
[00:37:28] <aatch> Also, we really need to improve our codegen. I have no idea where to start though...
[00:37:39] *** Joins: SimonSapin (simon@5AAE35B2.5EFFC0B8.24454B25.IP)
[00:38:01] *** Joins: deepdog (deepdog@moz-490E834C.client.mchsi.com)
[00:38:46] * aatch probably shouldn't have copied from the doxygen docs on LLVM
[00:39:19] *** Quits: SimonSapin (simon@5AAE35B2.5EFFC0B8.24454B25.IP) (Quit: Leaving.)
[00:39:48] *** Quits: Diamond (Mibbit@moz-625C0DAF.ks.ok.cox.net) (Quit: http://www.mibbit.com ajax IRC Client)
[00:43:26] *** Joins: diamond (Richard@moz-625C0DAF.ks.ok.cox.net)
[00:43:33] <aatch> strcat, is there an issue open about IR generation quality?
[00:44:01] *** Joins: steven_is_false (user@moz-144077DE.bchsia.telus.net)
[00:44:03] <steven_is_false> ls -al
[00:44:11] *** Quits: erickt (erickt@8C9ECD8F.3A598286.F12515B4.IP) (Quit: Leaving.)
[00:45:52] <Eridius> btw strcat, based on our earlier discussion about my hashmap issue, I implemented a method HashMap.insert_or_modify_with() as https://github.com/mozilla/rust/pull/6815
[00:46:31] <strcat> aatch: there was one that I closed because it was specific at all
[00:46:36] <strcat> it's a bunch of issues
[00:46:45] *** Quits: dew (Instantbir@moz-66796D51.dhcp.stls.mo.charter.com) (Ping timeout)
[00:46:57] <strcat> wasn't specific*
[00:47:20] <strcat> aatch: should just compare samples to clang and deal with the little issues one at a time
[00:47:34] <aatch> strcat, if I make a metabug, could you maybe open more specific issues?
[00:47:48] <aatch> Since you seem to have some idea of what is wrong
[00:49:16] *** Joins: erickt (erickt@8C9ECD8F.3A598286.F12515B4.IP)
[00:52:47] *** Joins: heftig (heftig@moz-9E352B4E.dip0.t-ipconnect.de)
[00:53:38] <aatch> strcat, https://github.com/mozilla/rust/issues/6819
[00:53:49] *** Joins: bnicholson (bnicholson@moz-E98974C1.hsd1.ca.comcast.net)
[00:54:30] *** Quits: hjr3 (hradtke@1A0AE795.28A5F6C3.A2D40ED2.IP) (Quit: My MacBook has gone to sleep. ZZZzzzâ€¦)
[00:59:53] *** Quits: brson (brson@2557E599.66715431.D25A875A.IP) (Ping timeout)
[01:00:51] *** Quits: Sorella (queen@B12A78F5.BA14766C.95C8B7C6.IP) (Quit: (quit))
[01:01:03] *** Joins: brson (brson@2557E599.66715431.D25A875A.IP)
[01:01:03] *** ChanServ sets mode: +o brson
[01:04:28] <MaikKlein> hm
[01:05:15] <MaikKlein> why does rust get installed in usr/local/lib and usr/local/lib/rustc/gnu/ ?
[01:06:38] <strcat> one set of the libs is for the compiler binary itself and one set for compiling to the target
[01:06:43] <strcat> they are fairly redundant...
[01:06:56] <strcat> for the target that's the same as the host
[01:07:56] *** Quits: erickt (erickt@8C9ECD8F.3A598286.F12515B4.IP) (Quit: Leaving.)
[01:09:07] *** Quits: carllerche (carllerche@moz-BF6CB667.hsd1.ca.comcast.net) (Quit: carllerche)
[01:12:44] *** Quits: Earnestly (earnest@6A917A59.5E1FD793.39C00A7A.IP) (Ping timeout)
[01:13:16] <aatch> strcat, weep: https://github.com/mozilla/rust/issues/6820
[01:14:41] <dbaupp> aatch: "Loop Invariant Code Motion"?
[01:14:46] <dbaupp> moving constants out of loops?
[01:14:49] <aatch> yep
[01:15:16] <dbaupp> do you have any idea why it's so slow/happening so much?
[01:15:44] *** Joins: Jesin (Jessin_@moz-3AD6F09F.res.lehigh.edu)
[01:15:59] <aatch> Nope, I plan to investigate though.
[01:16:24] <aatch> for comparison, compiling libstd, LICM takes 0.8% of the time.
[01:16:35] <dbaupp> woah
[01:17:09] <aatch> More woah: turning it off makes the LLVM passes take 81s instead of 600s
[01:17:32] <pcwalton> wat.
[01:17:52] <pcwalton> LICM should be like
[01:18:02] <pcwalton> proportional to the depth of the CFG, no?
[01:18:47] <strcat> aatch: well I guess we're generating something really terrible...
[01:20:41] <aatch> I assume so
[01:22:17] <aatch> dropping the build time of libextra to something like 1-2mins would be incredibly awesome.
[01:23:13] <cmr> rusti: use std::{hashmap::HashMap, int::range};
[01:23:13] -rusti- foo.rs:8:26: 8:28 error: expected `,` but found `::`
[01:23:13] -rusti- foo.rs:8          use std::{hashmap::HashMap, int::range};
[01:23:14] -rusti-                                    ^~
[01:23:17] <strcat> aatch: so are you just disabling modules until you find the one?
[01:23:27] *** Parts: ssn (ssn@moz-FB2CDEE1.lightspeed.snjsca.sbcglobal.net) (Leaving)
[01:24:24] <aatch> not yet. I'm gonna look at the different LLVM outputs first.
[01:24:40] <dbaupp> cmr: you can't nest imports like that
[01:25:01] <cmr> dbaupp: it'd be really nice
[01:25:18] <dbaupp> cmr: it would be (implement it! ;) )
[01:25:27] <aatch> One advantage of being able to provide a custom pipeline is being able to provide the instnamer pass
[01:27:59] *** Parts: judder (maradukewa@385DDD8F.206937E4.78E362FE.IP) ()
[01:28:11] <aatch> which names all of the `%x` vars, because otherwise they get re-numbered during transformation
[01:31:20] *** Joins: carllerche (carllerche@moz-BF6CB667.hsd1.ca.comcast.net)
[01:31:37] *** Quits: carllerche (carllerche@moz-BF6CB667.hsd1.ca.comcast.net) (Quit: carllerche)
[01:33:15] *** Quits: MaikKlein (maik@moz-340073FA.dip0.t-ipconnect.de) (Quit: Leaving)
[01:33:23] *** Quits: a__ (a__@moz-250D9B4.nycmny.fios.verizon.net) (Client exited)
[01:33:59] *** Joins: a_m0d (a_m0d@moz-9F925EFA.hm.shawcable.net)
[01:34:28] *** Joins: a__ (a__@moz-250D9B4.nycmny.fios.verizon.net)
[01:34:55] *** Quits: mschifer1 (Adium@2557E599.66715431.D25A875A.IP) (Quit: Leaving.)
[01:37:38] *** Quits: thomaslee (thomaslee@moz-6C3931E3.static.twtelecom.net) (Client exited)
[01:39:47] *** Joins: engla (engla@moz-DBD1D96E.cust.bredbandsbolaget.se)
[01:40:31] *** Joins: wycats_ (uid79@moz-C944F5EC.irccloud.com)
[01:40:49] *** Joins: sawrubh (uid6719@moz-D8B63698.irccloud.com)
[01:49:02] *** Joins: ysuzuki (ysuzuki@moz-A563888C.ics.keio.ac.jp)
[01:49:04] *** Joins: Guest_ (textual@moz-E64A54F3.nyc.res.rr.com)
[01:52:53] *** Joins: SimonSapin (simon@moz-99690620.hinet-ip.hinet.net)
[01:57:03] <bjz> dbaupp: https://github.com/bjz/rusp/pull/6
[01:57:08] *** Joins: mcpherrin (mimcpher@moz-345B5EBA.csclub.uwaterloo.ca)
[01:57:47] <bjz> dbaupp: you were saying that we need an environment for lambdas?
[01:59:45] <dbaupp> bjz: well, currently a function uses the environment in which it is called, not the one in which it was defined
[02:00:36] *** Joins: ghrust (ghrust@moz-4EF5B6E5.rs.github.com)
[02:00:36] <ghrust> 01[13rust01] 15bors merged 06auto into 06incoming: 02http://git.io/6nI_jw
[02:00:36] *** Parts: ghrust (ghrust@moz-4EF5B6E5.rs.github.com) ()
[02:00:50] *** Quits: ssbr (scorchsabe@A9D9D38C.B6F034AC.72A31D6.IP) (Connection reset by peer)
[02:00:56] <bjz> so rustfns already have their own environments
[02:01:08] <dbaupp> do they?
[02:01:21] <bjz> pub struct RustFn(@fn(params: &[@Value], env: @mut Rusp) -> EvalResult);
[02:01:27] <dbaupp> (that pr looks good, except for the line comment)
[02:01:48] <dbaupp> isn't that just passing the "evaluation environment" to the function? i.e. it can change?
[02:02:08] <aatch> I think I might have found the culprit.
[02:02:08] <bjz> hmm
[02:02:16] <dbaupp> (or, not, if we are going to have lexical(?) scope.)
[02:02:25] <bjz> ahh, you're right
[02:02:35] <dbaupp> aatch: ?
[02:02:40] <Yurumechan> regarding graydon's recent comments on pub by default: I guess we should compile a list of design choices from graydon and others' comments ;)
[02:02:54] <Yurumechan> preferably in a wiki page.
[02:03:06] <aatch> dbaupp, the LICM pathological case
[02:03:07] <bjz> Yurumechan: I would say no
[02:03:17] <aatch> I think it might be bigint
[02:03:28] *** Joins: hjr3 (hradtke@moz-E87BDF1F.socal.res.rr.com)
[02:03:38] *** Joins: ghrust (ghrust@moz-4EF5B6E5.rs.github.com)
[02:03:38] <ghrust> 01[13rust01] 15bors pushed 0 new commits to 06auto: 02http://git.io/s8Ng9w
[02:03:38] *** Parts: ghrust (ghrust@moz-4EF5B6E5.rs.github.com) ()
[02:03:40] *** Joins: ghrust (ghrust@moz-4EF5B6E5.rs.github.com)
[02:03:40] <ghrust> 01[13rust01] 15bors pushed 5 new commits to 06auto: 02http://git.io/1MRrow
[02:03:40] <ghrust> 13rust/06auto 14da71b0c 15Patrick Walton: librustc: Redo the unsafe checker and make unsafe methods not callable from safe code
[02:03:40] <ghrust> 13rust/06auto 14a6e2b97 15Patrick Walton: libsyntax: Make `drop` no longer a keyword
[02:03:41] <ghrust> 13rust/06auto 14cd91fb2 15Patrick Walton: libsyntax: Stop parsing mutable fields
[02:03:41] <bjz> Yurumechan: Rust seems to be about 'safe as default'
[02:03:43] *** Parts: ghrust (ghrust@moz-4EF5B6E5.rs.github.com) ()
[02:03:56] *** Quits: brson (brson@2557E599.66715431.D25A875A.IP) (Ping timeout)
[02:04:30] <bjz> Yurumechan: Where as 'pub as default' seems to be wierd
[02:04:46] <dbaupp> aatch: has it got loops with huge constant vectors, or something?
[02:05:31] <aatch> not sure, it's just that I've been turning the modules on one by one, and bigint seems to be taking a lot longer.
[02:06:48] * pcwalton would be in favor of removing bigint, btw
[02:06:58] *** Quits: maxli (maxli@C03F2759.C70D537E.2FA4EA88.IP) (Quit: Leaving.)
[02:07:01] <pcwalton> it's probably not performance competitive with GMP and until it is I doubt people will want to use it
[02:07:13] <pcwalton> I know servo is not interested until it's competitive with GMP
[02:07:19] *** Quits: lkuper (lkuper@290F781E.FFCF2A3B.51B6877.IP) (Ping timeout)
[02:07:20] *** Joins: maxli (maxli@C03F2759.C70D537E.2FA4EA88.IP)
[02:07:40] <pcwalton> well, here goes nothing
[02:08:08] *** Joins: ghrust (ghrust@moz-4EF5B6E5.rs.github.com)
[02:08:08] <ghrust> 01[13rust01] 15pcwalton pushed 4 new commits to 06incoming: 02http://git.io/p_TYmw
[02:08:08] <ghrust> 13rust/06incoming 14aeda178 15Patrick Walton: librustc: Redo the unsafe checker and make unsafe methods not callable from safe code
[02:08:08] <ghrust> 13rust/06incoming 14481d4ca 15Patrick Walton: libsyntax: Make `drop` no longer a keyword
[02:08:08] <ghrust> 13rust/06incoming 144e3d4b3 15Patrick Walton: libsyntax: Stop parsing mutable fields
[02:08:10] <pcwalton> I'll fix any breakage tonight ASAP
[02:08:10] *** Parts: ghrust (ghrust@moz-4EF5B6E5.rs.github.com) ()
[02:08:14] <pcwalton> promise :)
[02:08:22] *** Quits: pcwalton (pcwalton@2557E599.66715431.D25A875A.IP) (Quit: pcwalton)
[02:09:09] *** Quits: eatkinson (eatkinson@2557E599.66715431.D25A875A.IP) (Quit: eatkinson)
[02:09:35] *** Joins: ghrust (ghrust@moz-4EF5B6E5.rs.github.com)
[02:09:35] <ghrust> 01[13rust01] 15bors 04force-pushed 06auto from 14238db55 to 14206ab89: 02http://git.io/N3iJvQ
[02:09:35] *** Parts: ghrust (ghrust@moz-4EF5B6E5.rs.github.com) ()
[02:12:35] *** Joins: ghrust (ghrust@moz-4EF5B6E5.rs.github.com)
[02:12:35] <ghrust> 01[13rust01] 15bors pushed 0 new commits to 06auto: 02http://git.io/IwP0WA
[02:12:35] *** Parts: ghrust (ghrust@moz-4EF5B6E5.rs.github.com) ()
[02:12:38] <a_m0d> What does "stop parsing mutable fields" mean?
[02:12:41] *** Joins: ghrust (ghrust@moz-4EF5B6E5.rs.github.com)
[02:12:41] <ghrust> 01[13rust01] 15bors pushed 8 new commits to 06auto: 02http://git.io/R-6XNA
[02:12:41] <ghrust> 13rust/06auto 14cab77d0 15Niko Matsakis: Remove TrByImplicitRef and source field on datums
[02:12:41] <ghrust> 13rust/06auto 14c8df600 15Niko Matsakis: Refactor helper routines to be less tied to match syntax
[02:12:41] <ghrust> 13rust/06auto 144089885 15Niko Matsakis: Remove local_imm/local_mem since all variables are now by reference
[02:12:43] *** Parts: ghrust (ghrust@moz-4EF5B6E5.rs.github.com) ()
[02:13:28] <a_m0d> Is that just that struct Test {mut field1: uint} no longer works
[02:13:35] <cmr> rusti: struct foo {mut foo: int}
[02:13:37] * rusti produced no output
[02:13:38] <cmr> yes
[02:14:01] <a_m0d> but the whole struct has to be mutable
[02:14:19] <cmr> to mutate any of its fields, yes
[02:14:26] <a_m0d> rusti: struct foo {foo: int}; let mut fooOne = foo; foo
[02:14:29] -rusti- more than 5 lines of output, pastebinned: http://sprunge.us/XXHc
[02:14:35] <cmr> it doesnt work now
[02:14:42] <cmr> it just is still parsed
[02:14:42] <a_m0d> rusti: struct foo {foo: int}; let mut fooOne = foo; fooOne
[02:14:50] <a_m0d> Oh, right
[02:15:04] -rusti- more than 5 lines of output, pastebinned: http://sprunge.us/XDGc
[02:15:20] *** Quits: ssbr_ (ssbr@A9D9D38C.B6F034AC.72A31D6.IP) (Ping timeout)
[02:16:25] <cmr> Why would pcwalton push commits that don't build :(
[02:16:54] <a_m0d> Because he'll fix the breakage tonight?
[02:16:59] *** Joins: ssbr (ssbr@A9D9D38C.B6F034AC.72A31D6.IP)
[02:17:02] *** Joins: eatkinson (eatkinson@2557E599.66715431.D25A875A.IP)
[02:17:10] <dbaupp> cmr: because they keep bouncing
[02:17:11] <a_m0d> That should make it ok :-/
[02:17:18] <dbaupp> i.e. not merging cleanly
[02:17:28] *** Quits: tikue (tkuehn@2557E599.66715431.D25A875A.IP) (Quit: tikue)
[02:18:01] <dbaupp> (at least, that was the reason the renaming commits were pushed)
[02:18:22] *** Quits: Guest_ (textual@moz-E64A54F3.nyc.res.rr.com) (Quit: Textual IRC Client: www.textualapp.com)
[02:18:36] *** Joins: Guest_ (textual@moz-E64A54F3.nyc.res.rr.com)
[02:18:46] *** Quits: ssbr (ssbr@A9D9D38C.B6F034AC.72A31D6.IP) (Ping timeout)
[02:19:03] *** Joins: ssbr (ssbr@A9D9D38C.B6F034AC.72A31D6.IP)
[02:20:06] *** Quits: Guest_ (textual@moz-E64A54F3.nyc.res.rr.com) (Quit: Textual IRC Client: www.textualapp.com)
[02:20:22] *** Joins: caitp (caitp@moz-9FE842F.cpe.net.cable.rogers.com)
[02:20:50] *** Quits: maxli (maxli@C03F2759.C70D537E.2FA4EA88.IP) (Quit: Leaving.)
[02:20:52] <caitp> is there any way to like, file a bug on the documentation on rust-lang.org?
[02:21:09] <cmr> caitp: open an issue or a pull request
[02:21:17] <cmr> caitp: the docs are out of date though
[02:21:34] <cmr> they're generated from 0.6 and master, not incoming
[02:22:41] <caitp> so the docs are in the tree?
[02:22:45] <cmr> yes
[02:23:01] <cmr> doc/ and doc comments in the various source files
[02:23:15] *** Quits: eatkinson (eatkinson@2557E599.66715431.D25A875A.IP) (Quit: eatkinson)
[02:23:52] <caitp> alright cool, thanks
[02:24:15] *** Quits: steven_is_false (user@moz-144077DE.bchsia.telus.net) (Ping timeout)
[02:25:56] *** Quits: bent (chatzilla@moz-932324BF.hsd1.ca.comcast.net) (Ping timeout)
[02:28:06] *** Quits: jrfeenst (jrfeenst@moz-3265BD65.cpe.norwoodlight.com) (Quit: jrfeenst)
[02:28:24] *** Joins: erickt (Adium@49C4075F.3AC15C18.2321E71E.IP)
[02:28:57] <bblum> oh god lang_items.rs what is this
[02:29:26] <aatch> bblum, it's where nightmares go
[02:30:44] *** Joins: thomaslee (thomaslee@moz-306D3DF4.hsd1.or.comcast.net)
[02:31:44] <bblum> where they go to die more like
[02:34:01] *** Quits: strcat (strcat@moz-54F7FD49.cpe.net.cable.rogers.com) (Quit: WeeChat 0.4.1)
[02:34:23] *** Joins: MaikKlein (maik@moz-340073FA.dip0.t-ipconnect.de)
[02:35:13] <aatch> Well it's definitely BigInt that's causing all the issues
[02:35:21] <cmr> kill bigint
[02:35:21] *** Joins: devbug (quassel@moz-E1DE087C.bchsia.telus.net)
[02:35:30] <aatch> I'm curious to know why though.
[02:35:46] *** Joins: steven_is_false (user@moz-144077DE.bchsia.telus.net)
[02:36:46] *** Quits: jorendorff (jorendorff@moz-2F32ACA3.hsd1.tn.comcast.net) (Quit: jorendorff)
[02:38:52] *** Quits: kimundi (kimundi@moz-21E92379.dip0.t-ipconnect.de) (Ping timeout)
[02:38:59] <a_m0d> rusti: struct Tree<T> {left: Option<T>}; impl Tree { fn new<T> () -> Tree<T> { Tree<T> {left: None} } }
[02:39:00] -rusti- foo.rs:8:94: 8:95 error: expected `;` or `}` after expression but found `:`
[02:39:00] -rusti- foo.rs:8          struct Tree<T> {left: Option<T>}; impl Tree { fn new<T> () -> Tree<T> { Tree<T> {left: None} } }
[02:39:00] -rusti-                                                                                                        ^
[02:39:28] <cmr> rusti: struct Tree<T> {left: Option<T>}; impl Tree { fn new<T> () -> Tree<T> { Tree {left: None} } }
[02:39:30] -rusti- foo.rs:8:48: 8:53 error: wrong number of type arguments: expected 1 but found 0
[02:39:30] -rusti- foo.rs:8          struct Tree<T> {left: Option<T>}; impl Tree { fn new<T> () -> Tree<T> { Tree {left: None} } }
[02:39:30] -rusti-                                                          ^~~~~
[02:39:30] -rusti- note: in expansion of fmt!
[02:39:31] -rusti- foo.rs:7:12: 9:7 note: expansion site
[02:39:35] <a_m0d> Any idea why that doesn't work?
[02:39:51] <cmr> rusti: struct Tree<T> {left: Option<T>}; impl<T> Tree { fn new<T> () -> Tree<T> { Tree {left: None} } }
[02:39:53] -rusti- foo.rs:8:51: 8:56 error: wrong number of type arguments: expected 1 but found 0
[02:39:53] -rusti- foo.rs:8          struct Tree<T> {left: Option<T>}; impl<T> Tree { fn new<T> () -> Tree<T> { Tree {left: None} } }
[02:39:53] -rusti-                                                             ^~~~~
[02:39:53] -rusti- note: in expansion of fmt!
[02:39:53] -rusti- foo.rs:7:12: 9:7 note: expansion site
[02:39:58] *** Joins: carllerche (carllerche@6B070D22.7E6A0813.1428D117.IP)
[02:40:02] <cmr> rusti: struct Tree<T> {left: Option<T>}; impl Tree<T> { fn new<T> () -> Tree<T> { Tree {left: None} } }
[02:40:03] -rusti- more than 5 lines of output, pastebinned: http://sprunge.us/MXNe
[02:40:18] <a_m0d> It does need the type arg when initializing it with None for the left field
[02:40:27] <dbaupp> rusti: struct Tree<T> {left: Option<T>}; impl<T> Tree<T> { fn new<T> () -> Tree<T> { Tree {left: None} } }
[02:40:32] * rusti produced no output
[02:40:35] <cmr> ah
[02:40:42] <a_m0d> Ah
[02:40:46] <a_m0d> I see
[02:40:49] <a_m0d> Thanks dbaupp!
[02:41:37] <dbaupp> a_m0d: type inference works for the None (although, sometimes it doesn't and you end up writing None::<T>, which looks a bit silly)
[02:41:56] <a_m0d> Interesting - I would not have expected that
[02:41:56] *** Joins: zz_kimundi (kimundi@moz-3E75C1CD.dip0.t-ipconnect.de)
[02:42:22] *** zz_kimundi is now known as kimundi
[02:44:17] <a_m0d> rusti: struct Tree<T> {left: Option<T>}; impl<T> Tree<T> { fn new<T> () -> Tree<T> { Tree {left: None} } }; let tree: Tree<int> = Tree<int>::new();
[02:44:21] -rusti- more than 5 lines of output, pastebinned: http://sprunge.us/WLAb
[02:45:19] <a_m0d> Any idea why the compiler can't see the definition of Tree?
[02:45:34] <cmr> rusti:  struct Tree<T> {left: Option<T>}; impl<T> Tree<T> { fn new<T> () -> Tree<T> { Tree {left: None} } }; let tree: Tree<int> = Tree::new();
[02:45:41] -rusti- more than 5 lines of output, pastebinned: http://sprunge.us/deCY
[02:45:58] <cmr> rusti:  struct Tree<T> {left: Option<T>}; impl<T> Tree<T> { fn new<T> () -> Tree<T> { Tree {left: None} } }; let tree: Tree<int> = Tree::<int>::new();
[02:46:06] -rusti- line longer than 150 columns, pastebinned: http://sprunge.us/DgGg
[02:46:17] <cmr> rusti:  struct Tree<T> {left: Option<T>}; impl<T> Tree<T> { fn new<T> () -> Tree<T> { Tree {left: None} } }; let tree: Tree<int> = Tree::<int>new();
[02:46:19] <dbaupp> rusti: struct Tree<T> {left: Option<T>}; impl<T> Tree<T> { fn new<T> () -> Tree<T> { Tree {left: None} } }; let tree: Tree<int> = Tree::new::<int>();
[02:46:20] -rusti- line longer than 150 columns, pastebinned: http://sprunge.us/iGFb
[02:46:20] -rusti- more than 5 lines of output, pastebinned: http://sprunge.us/DIFe
[02:46:37] <dbaupp> rusti: struct Tree<T> {left: Option<T>}; impl<T> Tree<T> { fn new<T> () -> Tree<T> { Tree {left: None} } }; let tree: Tree<int> = Tree::new::<int, int>();
[02:46:37] <aatch> BigInt fails because there are inline(always)-es everywhere
[02:46:41] * rusti produced no output
[02:46:44] <dbaupp> aatch: ah
[02:47:00] <a_m0d> I'm glad to see I'm not the only one who just throws things at the compiler until it passes
[02:47:03] <dbaupp> so every function is absolutely huge?
[02:47:15] <dbaupp> rusti: struct Tree<T> {left: Option<T>}; impl<T> Tree<T> { fn new() -> Tree<T> { Tree {left: None} } }; let tree: Tree<int> = Tree::new();
[02:47:37] <aatch> dbaupp, the LLVM assembly is 100x bigger.
[02:47:45] <cmr> rusti:  struct Tree<T> {left: Option<T>}; impl<T> Tree<T> { fn new() -> Tree<T> { Tree {left: None} } }; let tree = Tree::new::<int>();
[02:47:47] * rusti produced no output
[02:47:48] * rusti produced no output
[02:48:18] <dbaupp> a_m0d: by putting a parameter on new, you are double-parameterising it. You can just use the <T> from the impl.
[02:48:31] <a_m0d> dbaupp: That line you entered above, with Tree::new::<int, int>() causes the compiler to abort itself
[02:48:40] *** Quits: jack (jack@2557E599.66715431.D25A875A.IP) (Ping timeout)
[02:48:54] <dbaupp> aatch: that seems like it would cause performance problems
[02:48:58] <dbaupp> aatch: nice work tracking it down :)
[02:49:06] <dbaupp> a_m0d: hehe :D
[02:49:12] <dbaupp> a_m0d: bugs are so much fun
[02:49:32] <a_m0d> So does the better version with the single parameter
[02:49:48] <dbaupp> there's possibly something else going on...
[02:50:33] <dbaupp> a_m0d: it doesn't crash for me
[02:50:44] *** Quits: a__ (a__@moz-250D9B4.nycmny.fios.verizon.net) (Client exited)
[02:51:38] <dbaupp> a_m0d: neither of them crash for me. What version of rust are you using?
[02:51:41] <erickt> is rust HEAD compiling for anyone else? I'm getting some unresolved names compiling stage0's librustc
[02:51:54] *** Quits: rusti (rusti@moz-54F7FD49.cpe.net.cable.rogers.com) (Ping timeout)
[02:51:56] *** Joins: rusti (rusti@moz-54F7FD49.cpe.net.cable.rogers.com)
[02:52:07] <dbaupp> erickt: pcwalton just manually pushed a big patch
[02:52:27] <a_m0d> dbaupp: I'm using a build from incoming from the 24th of May
[02:52:27] <erickt> dbaupp: I see, it seems we're getting failures from it too: http://buildbot.rust-lang.org/console?refresh=15
[02:52:34] <dbaupp> the bots are broken with something about io::println in rustc?
[02:52:39] <cmr> yes
[02:52:55] <erickt> anyone else fixing this? If not, I'll work on it
[02:53:00] <dbaupp> a_m0d: well, I've got one from the 25th
[02:53:04] <dbaupp> so I don't know
[02:53:07] <cmr> erickt: pcwalton said he'd ifx it asap
[02:53:16] <dbaupp> a_m0d: (is there anything else in the file?)
[02:53:58] <a_m0d> Only a main() function, where I have the let tree = ... line - nothing else
[02:54:20] <a_m0d> Was incoming good until pcwalton's 3 commits?  If so, I might pull everything up to that point and build that
[02:54:27] <cmr> 4 commits, yes
[02:54:42] <a_m0d> 4, right
[02:54:50] <cmr> b5da389d36ec9108f82bb7025eabb7ce4f26b103 is the latest working commit
[02:55:06] <a_m0d> dbaupp: This is the file I'm using: https://gist.github.com/am0d/5675469
[02:55:44] *** Quits: rusti (rusti@moz-54F7FD49.cpe.net.cable.rogers.com) (Ping timeout)
[02:55:57] *** Joins: rusti (rusti@moz-54F7FD49.cpe.net.cable.rogers.com)
[02:56:08] <dbaupp> a_m0d: well that file make my rust abort too
[02:56:22] <dbaupp> a_m0d: oh, right
[02:56:30] <dbaupp> it's the Option<Tree<T>>
[02:56:37] *** Quits: bytbox (s@moz-D83E9B31.wireless.umd.edu) (Ping timeout)
[02:56:45] <dbaupp> you need either Option<~Tree<T>> or Option<@Tree<T>>
[02:56:55] <a_m0d> Oh, oops, I missed that in my earlier code
[02:56:56] <dbaupp> otherwise the type is infinitely large
[02:57:02] <a_m0d> Thanks for catching that one.
[02:57:44] <a_m0d> Strangely enough, it does still build a runnable file with that code
[02:57:57] *** Joins: a__ (a__@moz-250D9B4.nycmny.fios.verizon.net)
[02:58:36] <dbaupp> a_m0d: without the pointer?
[02:59:03] <a_m0d> dbaupp: Yup.  It somehow still creates the binary, and the binary can actually be run
[02:59:23] <dbaupp> are you sure it's not just left over from a previous compile?
[03:00:25] <a_m0d> dbaupp: Never mind, I have my Makefile messed up again :-/
[03:00:27] <a_m0d> sorry
[03:00:36] <dbaupp> heh, np :)
[03:01:01] <cmr> a_m0d: you should consider using rust run/rust build instead of a makefile
[03:02:51] <dbaupp> cmr: 'make check' is still shorter than 'rust test filename.rs'
[03:03:23] <dbaupp> and especially if you've got options to pass to rustc (since they don't work with 'rust' at all)
[03:03:35] <cmr> that's true
[03:04:08] <a_m0d> Also, I have multiple executables to build at once, which all depend on the same libraries
[03:04:18] <a_m0d> rust build can only do one file at a time
[03:05:03] <dbaupp> I'm looking forward to rustpkg
[03:05:20] <Yurumechan> bjz : ah, I meant a reply on a proposal making an item without pub/priv default to pub (to which graydon answers no)
[03:05:28] * erickt fixes incoming because pcwalton is taking too longâ€¦ :)
[03:05:30] *** Joins: ghrust (ghrust@moz-4EF5B6E5.rs.github.com)
[03:05:30] <ghrust> 01[13rust01] 15erickt pushed 1 new commit to 06incoming: 02http://git.io/1F8oMw
[03:05:30] <ghrust> 13rust/06incoming 14b916e65 15Erick Tryzelaar: librustc: add some imports to back/passes.rs rs=burningtree
[03:05:30] *** Parts: ghrust (ghrust@moz-4EF5B6E5.rs.github.com) ()
[03:06:13] *** Quits: MaikKlein (maik@moz-340073FA.dip0.t-ipconnect.de) (Client exited)
[03:06:44] <Yurumechan> that said, a core design choice is clear but there are smaller choices that have been decided somehow but which details are elusive to newcomers
[03:07:07] *** Joins: brson (brson@51C589B3.EF2694B5.DFAC6AA7.IP)
[03:07:07] *** ChanServ sets mode: +o brson
[03:07:22] <Yurumechan> so I thought a record of such decisions is valuable both for educational purposes and for historic reason
[03:07:50] <cmr> Someone needs to write the zen of rust ;)
[03:08:25] *** Quits: SimonSapin (simon@moz-99690620.hinet-ip.hinet.net) (Ping timeout)
[03:09:31] *** Joins: SimonSapin (simon@moz-99690620.hinet-ip.hinet.net)
[03:11:17] <Eridius> hmm, `RUST_LOG=myprog ./myprog` is spitting out debug!() lines from std::hashmap
[03:11:38] <Eridius> ok apparently I have a myprog::hashmap mod according to ::help
[03:11:51] <cmr> Eridius: yeah, it's because it sucks it in from inlining
[03:11:56] <Eridius> argh
[03:12:08] <Eridius> I don't want debug lines from std
[03:12:25] <cmr> it's a bug, I think there's an issue for it somewhere
[03:13:00] <Eridius> oh good, I can say myprog,myprog::hashmap=0
[03:14:05] *** Quits: dbaupp (Thunderbir@moz-C6B1454A.lns20.syd7.internode.on.net) (Quit: dbaupp)
[03:14:39] <Eridius> hrm, don't see any open issues matching RUST_LOG about this
[03:16:51] *** Quits: sam1 (sam@moz-ADDDDFB1.mc.videotron.ca) (Ping timeout)
[03:17:03] *** Joins: MaikKlein (maik@moz-340073FA.dip0.t-ipconnect.de)
[03:17:13] *** Quits: SiegeLord (sl@moz-CAF07B4C.hsd1.ma.comcast.net) (Quit: It's a joke. It's all a joke.)
[03:17:24] *** Quits: engla (engla@moz-DBD1D96E.cust.bredbandsbolaget.se) (Ping timeout)
[03:17:43] *** Quits: kemurphy (kemurphy@moz-7332FD74.hsd1.pa.comcast.net) (Ping timeout)
[03:18:36] *** Joins: bytbox (s@moz-D83E9B31.wireless.umd.edu)
[03:19:53] *** Joins: sam1 (sam@moz-ADDDDFB1.mc.videotron.ca)
[03:20:44] *** Joins: dbaupp (Thunderbir@moz-C6B1454A.lns20.syd7.internode.on.net)
[03:20:47] <Eridius> can I get a full backtrace on a task failure?
[03:21:17] <cmr> gdb is the best option but RUST_LOG=::rt::backtrace will get you a basic one
[03:22:21] <SimonSapin> what is the name of a syntaxic construct like #[inline]? Marker, decorator?
[03:22:28] <cmr> SimonSapin: Attribute
[03:22:30] <aatch> SimonSapin, attribute
[03:22:34] *** Quits: thomaslee (thomaslee@moz-306D3DF4.hsd1.or.comcast.net) (Client exited)
[03:23:13] <Eridius> cmr: I'm surprised that doesn't show up with ::help
[03:23:27] <cmr> Eridius: What is :help, exactly?
[03:23:35] <Eridius> cmr: RUST_LOG=::help
[03:23:51] <Eridius> also, ::rt::backtrace isn't working for me
[03:25:33] <cmr> Eridius: well the rt isn't a crate, so it makes sense.
[03:25:57] <SimonSapin> ok, I found this doc: https://github.com/mozilla/rust/wiki/Doc-attributes
[03:25:58] <SimonSapin> #[inline(always)] and #[inline(never)] are pretty self-explanatory, but what does #[inline] do compared to no attribute?
[03:26:08] <aatch> SimonSapin, hints
[03:26:16] <dbaupp> SimonSapin: it's slightly weaker than #[inline(always)]
[03:26:18] <aatch> makes it more likely to inline, but not certain
[03:26:21] <Eridius> cmr: so why is `RUST_LOG=myprog,myprog::hashmap=0,::rt::backtrace ./myprog` not spitting out a backtrace?
[03:26:38] <aatch> Eridius, what's the failure?
[03:27:00] <Eridius> in the case I just tested, it was Option.expect() failing, but in the case that prompted this, it was an assert!() in vec
[03:27:20] <dbaupp> SimonSapin: also, cross-crate inlining requires metadata to be written to the compiled crate file
[03:27:33] <dbaupp> SimonSapin: which only happens with #[inline] or #[inline(always)]
[03:28:02] <SimonSapin> but within the same crate and without attribute, the compiler might still decide to inline?
[03:28:13] <cmr> yes
[03:28:19] <SimonSapin> ok, cool
[03:31:18] <Eridius> cmr: ok I just tried running my program with lldb (don't have gdb) and it didn't do anything
[03:31:21] <aatch> brson, nmatsakis, can I get a r+ for this: https://github.com/mozilla/rust/pull/6822 Preferably with a higher priority?
[03:31:25] <Eridius> (besides complain about the empty .dSYMs that rust likes to generate)
[03:32:04] <dbaupp> aatch: 95%!
[03:32:16] <aatch> dbaupp, yep
[03:33:53] <Eridius> erickt: btw I'm kballard on github
[03:34:07] <erickt> Eridius: hey there
[03:34:20] *** Quits: MaikKlein (maik@moz-340073FA.dip0.t-ipconnect.de) (Ping timeout)
[03:34:38] <Eridius> find_or_insert_with() (and find_or_insert()) return the found/inserted value, which is why I chose to do that in insert_or_modify_with()
[03:35:08] <Eridius> but I'm not married to the idea, since find_or_insert_with() is presumably trying to be similar to find() but without the Option
[03:35:15] <Eridius> and insert_or_modify_with() is obviously not finding anything
[03:36:38] *** Joins: ghrust (ghrust@moz-4EF5B6E5.rs.github.com)
[03:36:38] <ghrust> 01[13rust01] 15bors 04force-pushed 06auto from 14b0fa4c2 to 14b916e65: 02http://git.io/N3iJvQ
[03:36:38] *** Parts: ghrust (ghrust@moz-4EF5B6E5.rs.github.com) ()
[03:36:39] *** Joins: ghrust (ghrust@moz-4EF5B6E5.rs.github.com)
[03:36:39] <ghrust> 01[13rust01] 15bors pushed 2 new commits to 06auto: 02http://git.io/c3vlEQ
[03:36:39] <ghrust> 13rust/06auto 1428eb7a2 15James Miller: Remove all of the `#[inline(always)]` attributes from bigint
[03:36:39] <ghrust> 13rust/06auto 14769f665 15bors: auto merge of #6822 : Aatch/rust/bigint-make-sane, r=brson...
[03:36:39] *** Parts: ghrust (ghrust@moz-4EF5B6E5.rs.github.com) ()
[03:38:17] <aatch> brson, I'm thinking of possibly making an LLVM pass that looks at the size of always_inline functions to ensure that they are actually sane to be marked like that
[03:38:20] *** Quits: solancile (solancile@moz-A1CFFAE5.hsd1.wa.comcast.net) (Ping timeout)
[03:38:49] *** Quits: SimonSapin (simon@moz-99690620.hinet-ip.hinet.net) (Ping timeout)
[03:40:38] *** Joins: lmandel (lmandel@FE1F74.86ED00A7.971E19F6.IP)
[03:40:49] <cmr> aatch: Mind trying a mass find-and-replace of inline(always) with inline and see what happens?
[03:42:28] <erickt> Eridius: here's how haskell does it's insert functions: http://www.haskell.org/ghc/docs/6.12.1/html/libraries/containers-0.3.0.0/Data-Map.html#5
[03:43:02] *** Joins: dylukes (dylukes@moz-E4DF3FED.pitbpa.fios.verizon.net)
[03:43:16] <Eridius> erickt: is rust using haskell's Data.Map as inspiration?
[03:43:18] *** Quits: lmandel (lmandel@FE1F74.86ED00A7.971E19F6.IP) (Quit: lmandel)
[03:43:28] <erickt> Eridius:  I think insertLookupWithKey is the closest
[03:43:56] <aatch> cmr, good idea, I'll try that. There are a lot of instances in the codebase
[03:44:02] <Eridius> erickt: insertWith is actually what I'm going for, and is equivalent to my insert_or_modify_with() if there was no return value
[03:44:45] <Eridius> well actually no, it says it combines new and old values. Not quite what I wanted
[03:45:11] <Eridius> but it's close enough
[03:45:34] <cmr> erickt: your attempt to put the tree out bounced
[03:45:46] <erickt> Eridius: I personally have been looking at Data.Map for inspiration
[03:45:55] <cmr> or, did it?
[03:46:16] <erickt> cmr: I see it's still compiling
[03:46:22] <cmr> nvm, I think it's still running. you went behind bors' back, I got confused
[03:46:36] <erickt> yeah, I cheated to get things fixed
[03:46:50] <Eridius> erickt: honestly, I don't care about the return value for my own usage, which makes it quite similar to insertWith (only difference being the passed function in rust only gets the old value, not the new value)
[03:46:56] <Eridius> but it seems like we may as well return some value, since we can
[03:47:07] <Eridius> at this point, I'm inclined to change it to `bool` just for parity with `insert()`
[03:47:13] <Luqman> erickt: ping
[03:47:17] <dbaupp> Eridius: there are platform specific differences, so you should put that info in your bug about ::rt::backtrace
[03:47:25] <Eridius> dbaupp: good point
[03:47:49] *** Joins: infynyxx (infynyxx@moz-E95B370B.nyc.res.rr.com)
[03:47:54] *** Joins: alisdair (textual@moz-EBE9F394.bchsia.telus.net)
[03:48:07] <Eridius> dbaupp: for the record, there's existing bugs in the bugtracker that show the output of a `RUST_LOG=::rt::backtrace ./foo` run that don't have backtraces, so it's not just me
[03:48:21] <erickt> Eridius: Okay. We could add a insert_find_or_modify_with that returns a value
[03:48:24] <Eridius> for example https://github.com/mozilla/rust/issues/6304
[03:48:26] <erickt> Luqman: pong
[03:48:28] <Eridius> erickt: that seems excessive
[03:48:39] <Eridius> especially because "modify" already implies finding
[03:48:51] <erickt> I agree the name is
[03:49:02] <Eridius> I guess the real question is, is a &'a V return value or a bool return value more useful?
[03:49:03] <erickt> Are you returning the current value, or the old value?
[03:49:08] <Eridius> the new value
[03:49:22] <Eridius> although I guess returning an Option<V> is another idea
[03:49:30] <erickt> I can see justification for both
[03:49:44] <Luqman> erickt: you had ping'd me earlier but didn't respond to my pong
[03:50:26] <erickt> Luqman: sorry, I've been in and out. I was wondering if you made any progress on the by-value self test failure
[03:51:10] <Eridius> erickt: I'm rather tempted to go ahead and make it return Option<V> at this point. That's like returning bool, but with additional info
[03:51:14] <erickt> Eridius: or another option is to add an insert_with fn
[03:51:26] <erickt> err, rename insert_or_modify_with
[03:51:45] <Eridius> and what, have the function take an Option<V>?
[03:51:53] <Eridius> that's awkward. I want to be able to pass something simple like |x| x+1
[03:52:15] <Luqman> erickt: no :( haven't had the chance to work on it
[03:52:30] <Eridius> if it returns Option<V> then this becomes equivalent to insertLookupWithKey, except the function only gets the old value, not the key, old value, new value
[03:52:33] <Luqman> i need to make a smaller testcase that can reproduce it
[03:52:45] <erickt> Eridius: naw, it'd follow Data.Map, so `fn insert_with(&mut self, key: K, value: V, f: fn(V, V) -> V)`
[03:53:14] <erickt> Eridius: in your case, you'd just write `|x, _| x + 1` to ignore the new value
[03:53:37] <cmr> Luqman: https://github.com/mozilla/rust/issues/5321 isn't small enough?
[03:53:38] <erickt> or `map.insert_with(key, 0, |x, _| *x + 1)`
[03:53:42] <cmr> Luqman: or is it a different bug?
[03:54:06] *** Joins: SimonSapin (simon@moz-99690620.hinet-ip.hinet.net)
[03:54:31] <Eridius> erickt: I'm not convinced it makes sense for us to pass the new value into the lambda, since rust isn't a functional language, it's a lot easier to make a let-binding for the new value if you need to reference it in the fn
[03:54:38] <Luqman> cmr: some different as a result of fixing that :P
[03:54:45] <Luqman> something*
[03:54:51] <cmr> Ah, heh
[03:55:16] <erickt> Eridius: unfortunately not really. You need to account for moves in this case
[03:56:03] <erickt> so unless you make a copy, you can't use a let-binding here
[03:56:04] <Eridius> erickt: bah, stupid ownership.
[03:56:10] <erickt> heh
[03:56:46] <Eridius> so what, fn insert_with(&self, k: K, v: V, f: &fn(V, &V) -> V)
[03:57:15] <Eridius> and then are we going to create an insert_lookup_with_key() variant too?
[03:57:35] <Eridius> I'm not convinced we really need to be mirroring Data.Map's functions exactly, especially since our existing functions don't
[03:58:07] <erickt> How about `fn insert_with(&self, k: K, v: V, f: &fn(&V, &V) -> V) -> Option<V>`, where the return value is the old value
[03:58:38] <Eridius> erickt: I'm surprised you aren't suggesting we pass the key to the fn as well
[03:58:56] <erickt> Well, we could add a insert_with_key for that :)
[03:59:03] <Eridius> sigh
[03:59:46] <erickt> Eridius: how about I add a comment on the ticket, and we see what other people think?
[03:59:52] <Eridius> erickt: ok
[04:01:16] <Eridius> I don't have gdb on this machine. If I were to run a rust program with gdb, would it automatically break on task failure? If so, why doesn't lldb do this?
[04:02:09] <cmr> Eridius: no
[04:02:23] <cmr> Eridius: set a breakpoint for...
[04:02:46] <cmr> rust_task_fail
[04:02:56] <Eridius> cmr: thanks
[04:02:58] *** Quits: wizeman (quassel@moz-9C343656.dyn.user.ono.com) (Connection reset by peer)
[04:03:05] <Eridius> how did you find that?
[04:03:24] <Eridius> hmm, the backtrace here isn't particularly useful
[04:03:38] <cmr> "cd src/rt; ag fail" ;)
[04:03:47] *** Joins: wizeman (quassel@moz-9C343656.dyn.user.ono.com)
[04:04:06] *** Joins: tikue (tkuehn@moz-CF8BEBEF.dia.static.qwest.net)
[04:04:12] <Eridius> ok so ::rt::backtrace does nothing, and lldb's stack trace on task failure isn't very useful either. This sucks
[04:04:20] <cmr> yeah :(
[04:04:44] <cmr> for a simple main with a fail!(), I get https://gist.github.com/cmr/85b0ed741802eeb6e60d in gdb
[04:05:11] <cmr> which is pretty much what I get with ::rt::backtrace, minus demangling
[04:05:29] <dbaupp> Eridius: what's the problem? can you just add more debug!/println statements?
[04:05:32] <Eridius> cmr: cmr this is what my program gives me: https://gist.github.com/kballard/41bca562faef9eee750b
[04:05:55] <Eridius> dbaupp: in this particular case, I actually know where the failure is. I'm just thinking ahead to cases where I won't know that
[04:06:22] <dbaupp> Eridius: ah, ok.
[04:06:29] <dbaupp> I guess https://mail.mozilla.org/pipermail/rust-dev/2013-May/004240.html will probably help
[04:06:35] <cmr> yeah I can't wait! :)
[04:06:55] *** Quits: aruniiird (arun@moz-3DB73AA5.azulsystems.com) (Ping timeout)
[04:07:01] <Eridius> woo
[04:11:17] *** Quits: a_m0d (a_m0d@moz-9F925EFA.hm.shawcable.net) (Quit: Leaving.)
[04:14:13] <aatch> Well according the build-bot times, removing all those always-inlines cut ~30 mins off of the build time.
[04:14:41] <Eridius> wow
[04:14:42] <cmr> just from bigint or everywhere?
[04:15:08] <aatch> cmr, just bigint
[04:15:19] <cmr> fantastic!
[04:16:54] *** Quits: erickt (Adium@49C4075F.3AC15C18.2321E71E.IP) (Quit: Leaving.)
[04:17:45] <aatch> is there some sort of sed equivalent to git grep?
[04:18:13] <Eridius> don't believe so
[04:18:21] <cmr> https://gist.github.com/jcamenisch/1671995
[04:18:42] <Eridius> if you want to operate on the working trepo you can use the output of `git ls-files` as the list of files to run sed on
[04:18:52] *** Quits: steven_is_false (user@moz-144077DE.bchsia.telus.net) (Connection reset by peer)
[04:18:59] <Eridius> git ls-files -z | xargs -0 sed -e 'whatever'
[04:19:33] <dbaupp> (you possible should filter to .rs files, to avoid hurting the documentation)
[04:19:55] <Eridius> git ls-files -z '*.rs' | xargs -0 sed -e 'whatever'
[04:20:33] <dbaupp> that's possible? cool!
[04:20:50] <Eridius> yeah git takes something called a 'pathspec' for a lot of commands, and a pathspec can have glob chars
[04:20:54] <Eridius> just make sure you escape them from the shell
[04:22:13] *** Quits: thou (thou@moz-1C1CA9F7.fasttrackcomm.net) (Input/output error)
[04:23:40] *** Joins: dew (Instantbir@moz-66796D51.dhcp.stls.mo.charter.com)
[04:23:48] *** Quits: brson (brson@51C589B3.EF2694B5.DFAC6AA7.IP) (Ping timeout)
[04:24:00] *** Joins: ghrust (ghrust@moz-4EF5B6E5.rs.github.com)
[04:24:00] <ghrust> 01[13rust01] 15pcwalton pushed 1 new commit to 06incoming: 02http://git.io/boTbyQ
[04:24:00] <ghrust> 13rust/06incoming 145fa7884 15Patrick Walton: test: Fix problem with check-fast. rs=burningtree
[04:24:00] *** Parts: ghrust (ghrust@moz-4EF5B6E5.rs.github.com) ()
[04:24:38] *** Joins: brson (brson@51C589B3.EF2694B5.DFAC6AA7.IP)
[04:24:38] *** ChanServ sets mode: +o brson
[04:26:25] <brendanc> emacs wgrep is pretty nice too
[04:27:15] <brendanc> https://github.com/mhayashi1120/Emacs-wgrep
[04:27:15] *** Quits: dylukes (dylukes@moz-E4DF3FED.pitbpa.fios.verizon.net) (Quit: ["Textual IRC Client: www.textualapp.com"])
[04:30:53] <cmr> /home/cmr/hacking/rust/src/libextra/term.rs:46:0: 50:1 error: trait bounds are not allowed in structure definitions
[04:31:12] <cmr> How do I work around this?
[04:31:20] *** Quits: deepdog (deepdog@moz-490E834C.client.mchsi.com) (Quit: Leaving)
[04:31:43] <aatch> Goddammit, bors says my commit is bad now.
[04:32:22] *** Quits: bjz (brendanzab@B398BE78.F804C29E.D35A31DF.IP) (Ping timeout)
[04:32:23] *** Quits: wizeman (quassel@moz-9C343656.dyn.user.ono.com) (Connection reset by peer)
[04:32:28] <dbaupp> cmr: put the trait bounds on any impls/functions for the struct
[04:32:56] *** Joins: wizeman (quassel@moz-9C343656.dyn.user.ono.com)
[04:33:53] <cmr> dbaupp: seems unideal, but works. thanks
[04:34:11] <sfackler> aatch: it looks like pcwalton just pushed a fix to the problem that bors was complaining about
[04:34:11] <aatch> goddamit patrick.
[04:35:27] *** Joins: bjz (brendanzab@B398BE78.F804C29E.D35A31DF.IP)
[04:35:28] *** Joins: youknowone (youknowone@A826BD81.8A0DEF81.38747683.IP)
[04:35:28] *** Quits: youknowone (youknowone@A826BD81.8A0DEF81.38747683.IP) (Z:lined (Open Proxy found on your host. Please visit www.blitzed.org/proxy?ip=115.68.131.49 for more information.))
[04:35:54] <dbaupp> cmr: yeah, Haskell does the same thing, and there are good reasons for it... I think... but I can't remember them
[04:38:00] *** Joins: wuwei`lab (wuwei@1A513F49.818D7924.FAA9ED67.IP)
[04:39:21] *** Joins: jack (jack@2557E599.66715431.D25A875A.IP)
[04:41:42] <aatch> Grr, I really want that pull to go through, because it undoes the damage I caused here: http://huonw.github.io/isrustfastyet/
[04:42:07] *** Joins: thomaslee (thomaslee@moz-306D3DF4.hsd1.or.comcast.net)
[04:42:38] *** Joins: ghrust (ghrust@moz-4EF5B6E5.rs.github.com)
[04:42:38] <ghrust> 01[13rust01] 15bors 04force-pushed 06auto from 14769f665 to 145fa7884: 02http://git.io/N3iJvQ
[04:42:38] *** Parts: ghrust (ghrust@moz-4EF5B6E5.rs.github.com) ()
[04:42:40] *** Joins: ghrust (ghrust@moz-4EF5B6E5.rs.github.com)
[04:42:40] <ghrust> 01[13rust01] 15bors pushed 2 new commits to 06auto: 02http://git.io/XgqYhQ
[04:42:40] <ghrust> 13rust/06auto 14b7633f3 15James Miller: Remove all of the `#[inline(always)]` attributes from bigint
[04:42:40] <ghrust> 13rust/06auto 146c4fced 15bors: auto merge of #6822 : Aatch/rust/bigint-make-sane, r=brson...
[04:42:41] *** Parts: ghrust (ghrust@moz-4EF5B6E5.rs.github.com) ()
[04:43:51] <dbaupp> aatch: I think that's possibly the first time that a performance regression with a clear cause has shown up
[04:44:22] <aatch> I think it's because I'm using a slightly different order to what was there before.
[04:44:33] <aatch> That said, I am also using a newer ordering.
[04:44:44] *** Quits: blitter (blitter@moz-E761A52F.dyn.centurytel.net) (Ping timeout)
[04:45:01] *** Quits: ysuzuki (ysuzuki@moz-A563888C.ics.keio.ac.jp) (Client exited)
[04:45:26] <dbaupp> of the LLVM passes?
[04:45:34] <aatch> dbaupp, yep
[04:47:03] <cmr> rusti: use std::hashmap::HashMap; let x = HashMap::new(); x.insert(~"foo", 15); x.find("foo")
[04:47:04] -rusti- more than 5 lines of output, pastebinned: http://sprunge.us/DdXT
[04:47:20] <cmr> rusti: use std::hashmap::HashMap; let x = HashMap::new(); x.insert(~"foo", 15); x.find(~"foo")
[04:47:22] *** Joins: snadon (chatzilla@moz-3BC727E8.mc.videotron.ca)
[04:47:23] -rusti- more than 5 lines of output, pastebinned: http://sprunge.us/DTeE
[04:47:33] <cmr> rusti: use std::hashmap::HashMap; let x = HashMap::new(); x.insert(~"foo", 15); x.find(&~"foo")
[04:47:40] -rusti- more than 5 lines of output, pastebinned: http://sprunge.us/HEeb
[04:47:59] <cmr> So, what do I do here?
[04:48:21] <dbaupp> rusti: use std::hashmap::HashMap; let mut x = HashMap::new(); x.insert(~"foo", 15); fmt!("%?", x.find(&~"foo"))
[04:48:23] -rusti- ~"Some(&15)"
[04:49:18] <cmr> Sigil soup :(
[04:49:19] <aatch> cmr, the stuff you give to rusti is inside a block expression
[04:50:36] <dbaupp> cmr: there's possibly a 'find_equiv' method
[04:50:44] <aatch> so trying to pass a borrowed value up doesn't work.
[04:50:45] <dbaupp> rusti: use std::hashmap::HashMap; let mut x = HashMap::new(); x.insert(~"foo", 15); fmt!("%?", x.find_equiv("foo"))
[04:50:47] -rusti- more than 5 lines of output, pastebinned: http://sprunge.us/YdZM
[04:50:57] *** Joins: thou (thou@moz-1C1CA9F7.fasttrackcomm.net)
[04:51:09] <dbaupp> rusti: use std::hashmap::HashMap; let mut x = HashMap::new(); x.insert(~"foo", 15); fmt!("%?", x.find_equiv(& "foo"))
[04:51:10] -rusti- more than 5 lines of output, pastebinned: http://sprunge.us/BYEU
[04:51:24] <dbaupp> rusti: use std::hashmap::HashMap; let mut x = HashMap::new(); x.insert(~"foo", 15); fmt!("%?", x.find_equiv(& & "foo"))
[04:51:26] -rusti- ~"Some(&15)"
[04:51:44] <aatch> Uh huh.
[04:52:07] <dbaupp> cmr: that doesn't help with the sigils, though :(
[04:52:43] *** Joins: pyrac (pyrac@moz-285C535.w92-156.abo.wanadoo.fr)
[04:53:17] *** Quits: pyrac (pyrac@moz-285C535.w92-156.abo.wanadoo.fr) (Quit: pyrac)
[04:53:40] <aatch> Actually, it looks like I don't have a much different set of passes from the original
[04:54:58] <dbaupp> rusti: use std::hashmap::HashMap; let mut x = HashMap::new(); x.insert(~"foo", 15); fmt!("%?", x.find_equiv(&("foo")))
[04:54:59] -rusti- ~"Some(&15)"
[04:55:33] *** Quits: tiffnya (kawaii@moz-1E0FE6E8.dhcp.embarqhsd.net) (Ping timeout)
[04:57:00] *** Quits: Jesin (Jessin_@moz-3AD6F09F.res.lehigh.edu) (Connection reset by peer)
[04:57:42] *** Quits: KindOne (KindOne@moz-3E4620C6.dynamic.ip.windstream.net) (Ping timeout)
[05:02:08] *** Joins: KindOne (KindOne@moz-3A6BC460.dynamic.ip.windstream.net)
[05:03:15] *** Quits: z0w0 (zack@moz-3E4BFDF8.qld.bigpond.net.au) (Quit: Leaving.)
[05:13:04] *** Joins: pcwalton (pcwalton@moz-481A040C.hsd1.ca.comcast.net)
[05:13:04] *** ChanServ sets mode: +o pcwalton
[05:14:43] *** Quits: carllerche (carllerche@6B070D22.7E6A0813.1428D117.IP) (Quit: carllerche)
[05:16:07] *** Quits: devbug (quassel@moz-E1DE087C.bchsia.telus.net) (Ping timeout)
[05:18:42] *** Quits: infynyxx (infynyxx@moz-E95B370B.nyc.res.rr.com) (Client exited)
[05:19:38] *** Joins: ghrust (ghrust@moz-4EF5B6E5.rs.github.com)
[05:19:38] <ghrust> 01[13rust01] 15pcwalton pushed 1 new commit to 06incoming: 02http://git.io/-5IpeQ
[05:19:38] <ghrust> 13rust/06incoming 14e67bfab 15Patrick Walton: etc: Fix more check-fast breakage. rs=burningtree
[05:19:38] *** Parts: ghrust (ghrust@moz-4EF5B6E5.rs.github.com) ()
[05:19:48] *** Joins: haard (fredrik@moz-6A86987C.dynamic.se.alltele.net)
[05:20:00] *** Quits: thomaslee (thomaslee@moz-306D3DF4.hsd1.or.comcast.net) (Client exited)
[05:20:44] <aatch> Sigh...
[05:21:01] <aatch> pcwalton, anyway to speed this process up?
[05:21:25] <cmr> aatch: your build speedup should just be pushed to incoming
[05:21:34] <pcwalton> yeah, I'll do that
[05:21:36] <cmr> it will also make this build-test cycle way faster
[05:21:39] *** Joins: ghrust (ghrust@moz-4EF5B6E5.rs.github.com)
[05:21:39] <ghrust> 01[13rust01] 15bors 04force-pushed 06auto from 146c4fced to 14e67bfab: 02http://git.io/N3iJvQ
[05:21:39] *** Parts: ghrust (ghrust@moz-4EF5B6E5.rs.github.com) ()
[05:21:45] *** Joins: ghrust (ghrust@moz-4EF5B6E5.rs.github.com)
[05:21:45] <ghrust> 01[13rust01] 15bors pushed 8 new commits to 06auto: 02http://git.io/FeUvZg
[05:21:45] <ghrust> 13rust/06auto 14cab77d0 15Niko Matsakis: Remove TrByImplicitRef and source field on datums
[05:21:45] <ghrust> 13rust/06auto 14c8df600 15Niko Matsakis: Refactor helper routines to be less tied to match syntax
[05:21:46] <ghrust> 13rust/06auto 144089885 15Niko Matsakis: Remove local_imm/local_mem since all variables are now by reference
[05:21:46] <pcwalton> sorry the tree is in such a state of chaos
[05:21:47] *** Parts: ghrust (ghrust@moz-4EF5B6E5.rs.github.com) ()
[05:22:24] <aatch> I'm not sure how my changes exposed it though, it's really quite strange...
[05:22:26] <pcwalton> this always happens when a big resolve change goes in
[05:22:49] <cmr> it'd help if bors was off
[05:24:00] *** Joins: ghrust (ghrust@moz-4EF5B6E5.rs.github.com)
[05:24:00] <ghrust> 01[13rust01] 15pcwalton pushed 1 new commit to 06incoming: 02http://git.io/kOvTKA
[05:24:00] <ghrust> 13rust/06incoming 143a3bf8b 15James Miller: Remove all of the `#[inline(always)]` attributes from bigint
[05:24:00] *** Parts: ghrust (ghrust@moz-4EF5B6E5.rs.github.com) ()
[05:24:14] <aatch> pcwalton, thank you.
[05:24:22] <pcwalton> no problem
[05:24:27] <pcwalton> that's a very nice fix
[05:24:43] *** Joins: ghrust (ghrust@moz-4EF5B6E5.rs.github.com)
[05:24:43] <ghrust> 01[13rust01] 15bors 04force-pushed 06auto from 148cf685d to 143a3bf8b: 02http://git.io/N3iJvQ
[05:24:43] *** Parts: ghrust (ghrust@moz-4EF5B6E5.rs.github.com) ()
[05:24:46] *** Joins: ghrust (ghrust@moz-4EF5B6E5.rs.github.com)
[05:24:46] <ghrust> 01[13rust01] 15bors pushed 8 new commits to 06auto: 02http://git.io/xEHhbA
[05:24:46] <ghrust> 13rust/06auto 14cab77d0 15Niko Matsakis: Remove TrByImplicitRef and source field on datums
[05:24:46] <ghrust> 13rust/06auto 14c8df600 15Niko Matsakis: Refactor helper routines to be less tied to match syntax
[05:24:46] <ghrust> 13rust/06auto 144089885 15Niko Matsakis: Remove local_imm/local_mem since all variables are now by reference
[05:24:48] *** Parts: ghrust (ghrust@moz-4EF5B6E5.rs.github.com) ()
[05:25:05] <aatch> I was just amazed at some of the stuff that had been marked
[05:25:21] <pcwalton> inline(always) culture was because of vec::each
[05:25:33] <pcwalton> LLVM inline heuristics don't always inline the closure
[05:25:47] <pcwalton> with disastrous results
[05:26:00] <pcwalton> but then everyone became overzealous
[05:27:02] <pcwalton> LLVM passes are still too slow on libextra
[05:27:09] <pcwalton> but they're better
[05:27:26] <aatch> BigInt::cmp, was marked with it. It's ~10 lines long and called by a lot of methods
[05:28:20] *** Joins: devbug (quassel@moz-E1DE087C.bchsia.telus.net)
[05:28:20] <pcwalton> the ratio of trans-to-llvm time on libstd is 1:5.3 but on libextra it's 1:8.5
[05:28:24] <aatch> pcwalton, I have a fix that gets rid of some of the slower passes that don't seem to do much anyway
[05:28:34] <pcwalton> the slower LLVM passes?
[05:28:41] <aatch> pcwalton, yep
[05:28:44] <pcwalton> oh, awesome
[05:28:51] <pcwalton> maybe we should have different levels of -O
[05:28:56] <cmr> We... do
[05:29:00] <aatch> pcwalton, we do.
[05:29:01] <cmr> they are just underused
[05:29:03] <pcwalton> well, I mean
[05:29:03] <aatch> --opt-level
[05:29:05] <pcwalton> actually use them
[05:29:08] <cmr> slash not useful
[05:29:16] <pcwalton> 1:11.8 for libsyntax
[05:29:27] <pcwalton> maybe we should set a target, say 1:5
[05:30:10] <pcwalton> I would be curious how much time in translation (not LLVM passes, translation) is spent in LLVM vs. Rust code
[05:30:11] <cmr> pcwalton: Is the new unsafe linter correct? A lot of new unnecessary unsafe blocks are reported
[05:30:27] <pcwalton> there might be some bugs
[05:30:53] <pcwalton> there should not be too much time spent in Rust code in translation
[05:30:58] <pcwalton> our codegen is very simple
[05:31:02] <Eridius> hmm, current incoming just failed to build for me
[05:31:15] <pcwalton> I'm building now
[05:31:16] <aatch> Eridius, how current?
[05:31:21] <Eridius> aatch: I literally just pulled
[05:31:29] <Eridius> I'm doing a full clean right now to see if it reproduces
[05:31:30] <aatch> Hmm, weird, I just built
[05:33:15] <cmr> pcwalton: is vec, str, char, int, etc no longer in the prelude?
[05:34:56] *** Quits: oyiptong (oyiptong@CD2A94.29EC3FEB.F9E1BAE1.IP) (Ping timeout)
[05:34:56] *** Joins: oyiptong (oyiptong@CD2A94.29EC3FEB.F9E1BAE1.IP)
[05:35:09] *** Joins: cmr (moznet@F468AD76.B3752F1D.93D630DC.IP)
[05:36:25] <cmr> pcwalton: is vec, str, char, int, etc no longer in the prelude?
[05:36:32] <pcwalton> they're gone
[05:36:48] <cmr> (sorry if that sent twice, connection problems)
[05:36:51] *** Joins: Cromulent (Cromulent@moz-983B638D.cable.virginmedia.com)
[05:36:53] <pcwalton> the reason is that people were confused as to why "use vec::foo;" didn't work but "vec::foo()" did
[05:37:50] <bblum> oh good, i never figured that out
[05:38:37] <aatch> pcwalton, I got libstd down to a 1:5 ration
[05:38:40] <aatch> ratio*
[05:38:47] <cmr> a bit annoying considering how common they are
[05:38:51] <pcwalton> you mean libextra?
[05:39:01] <aatch> pcwalton, no, I'm doing that one now
[05:39:05] <pcwalton> oh, ok
[05:39:14] <aatch> you said it was 5.3
[05:39:21] <aatch> I got 4.97 (so 5)
[05:39:23] <pcwalton> right
[05:39:41] <pcwalton> cmr: in general I would like to make uint::, int::, str:: rarely used
[05:39:44] <pcwalton> and switch to methods
[05:40:00] <pcwalton> for example, uint::range() is kind of superfluous when we could just put range() in the prelude and make it work on all Nums
[05:40:10] <cmr> Yes, that's true.
[05:40:14] <pcwalton> then you could write for range(0u, 10) |i| { ... }
[05:40:16] <pcwalton> which looks nicer
[05:40:24] <pcwalton> or just for range(0, 10) |i| { ... } for uints
[05:42:36] <pcwalton> vec:: and str:: functions should basically all be methods, except for, say, vec::from_fn and vec::from_elem, the former of which could go into the prelude and the latter of which has syntax already
[05:42:40] <pcwalton> (~[0, ..n])
[05:42:43] <Eridius> for 0u.upto(10) |i| { ... }
[05:43:12] <Eridius> pcwalton: from_elem has syntax already?
[05:43:14] <Eridius> huh
[05:43:21] <pcwalton> ~[my_element, ..n]
[05:43:24] *** Joins: mcomella (mcomella@moz-F9E82323.nwrknj.fios.verizon.net)
[05:43:30] <pcwalton> I think I made that work
[05:43:43] <Eridius> I should update my code to use that
[05:44:04] *** Joins: dylukes (dylukes@moz-E4DF3FED.pitbpa.fios.verizon.net)
[05:44:09] *** Quits: dylukes (dylukes@moz-E4DF3FED.pitbpa.fios.verizon.net) (Quit: dylukes)
[05:44:35] <dbaupp> pcwalton: for non-constant n?
[05:44:47] <pcwalton> oh yeah, it doesn't work for non-constant n
[05:44:53] <pcwalton> in that case vec::from_elem is still what you want
[05:45:10] <Eridius> oh it doesn't? darn, I need non-constant n
[05:45:21] <pcwalton> (although maybe repeat() or repeated() would be a better name? what do other languages use for this?)
[05:45:21] <Eridius> I thought that's what you were referring to when you said "I think I made that work"
[05:45:38] <pcwalton> oh no, I was just referring to making the syntax work for ~[vectors]
[05:46:00] <Eridius> Go just zero-initializes. Other languages may not necessarily even require an initializing element
[05:46:03] <dbaupp> python uses [thing]*n, haskell uses `replicate n thing`
[05:46:10] *** Joins: dylukes (dylukes@moz-E4DF3FED.pitbpa.fios.verizon.net)
[05:46:21] <dbaupp> R uses `rep(thing, n)`
[05:46:51] <cmr> I think non-constant n would be useful
[05:47:11] <cmr> it's nice syntax, shame not to reuse it
[05:47:17] <Eridius> I kind of like keeping vec::from_fn(), etc, instead of trying to rename from_fn to make it something suitable for the prelude
[05:47:25] <pcwalton> there should probably be a zero-replicator
[05:47:50] <cmr> pcwalton: erm, with_capacity?
[05:47:52] <pcwalton> vec::zeroes<T:Zero>(count: uint) -> ~[T]
[05:47:53] <Eridius> I think the solution for `use vec::foo` not working shoudl just be a better error message saying "did you mean std::vec::foo?"
[05:48:09] <Eridius> either that, or just make it work
[05:48:17] <Eridius> cmr: with_capacity leaves the length at 0
[05:48:24] <cmr> ah
[05:48:27] <aatch> pcwalton, between tweaking some passes and changing most #[inline(always)] to #[inline], I've got libextra down to 1:6.7
[05:48:29] <cmr> right
[05:48:41] <pcwalton> nice!
[05:48:56] <cmr> Better codegen in trans would probably bring that down too
[05:49:46] *** Quits: alisdair (textual@moz-EBE9F394.bchsia.telus.net) (Quit: My MacBook Pro has gone to sleep. ZZZzzzâ€¦)
[05:51:08] *** Quits: KindOne (KindOne@moz-3A6BC460.dynamic.ip.windstream.net) (Ping timeout)
[05:51:36] *** Joins: blitter (blitter@moz-E761A52F.dyn.centurytel.net)
[05:54:20] <aatch> 1:5.88
[05:54:43] <pcwalton> for which?
[05:54:48] <aatch> extra
[05:54:58] <pcwalton> nice
[05:55:08] <pcwalton> have to make sure it doesn't regress the compiler performance in later stages too much of course
[05:55:11] <cmr> aatch: if you're removing passes I hope they aren't affecting codegen
[05:55:22] <pcwalton> I remember when I tried -O1 last year had really bad effects on later stages
[05:55:23] <cmr> (much)
[05:55:25] *** Joins: KindOne (KindOne@moz-42F3D0F3.dynamic.ip.windstream.net)
[05:55:33] <aatch> I'm not actually removing passes, which is the nice thing
[05:55:42] <pcwalton> oh?
[05:56:02] *** Joins: infynyxx (infynyxx@moz-E95B370B.nyc.res.rr.com)
[05:56:09] <aatch> No, by adding in some extra passes in the right places, it makes other passes more efficient
[05:56:16] <pcwalton> oh, neat
[05:56:18] <cmr> handy
[05:56:57] <aatch> like adding scev-aa (scalar evolution alias analysis) dropped it by like 10%
[05:57:51] *** Quits: infynyxx (infynyxx@moz-E95B370B.nyc.res.rr.com) (Client exited)
[05:57:57] <pcwalton> the biggest thing that will reduce cycle time, I think, is to remove each_path from coherence and then from resolve
[05:58:13] <pcwalton> coherence is easier, we just need to write out all the impls into a separate section in metadata
[05:58:31] <pcwalton> resolve is a bit more annoying because we need to lazily populate external Modules as they're "use"d from
[05:58:53] <pcwalton> but those two changes should make small programs like the tests compile much faster
[05:59:07] <pcwalton> then removing intrinsic_inject should make them instantaneous
[05:59:20] <cmr> Is there a target date for 0.7?
[05:59:27] <pcwalton> end of june
[05:59:33] <cmr> and is that hard or soft?
[05:59:35] <aatch> libsyntax might be harder to get down. There are a lot of constants
[05:59:52] <dbaupp> aatch: are constants bad for LLVM?
[06:00:26] *** Quits: caitp (caitp@moz-9FE842F.cpe.net.cable.rogers.com) (Quit: caitp)
[06:00:29] *** Joins: ghrust (ghrust@moz-4EF5B6E5.rs.github.com)
[06:00:30] <ghrust> 01[13rust01] 15bors 04force-pushed 06auto from 142bcc8a7 to 143a3bf8b: 02http://git.io/N3iJvQ
[06:00:30] *** Parts: ghrust (ghrust@moz-4EF5B6E5.rs.github.com) ()
[06:00:33] *** Joins: ghrust (ghrust@moz-4EF5B6E5.rs.github.com)
[06:00:33] <ghrust> 01[13rust01] 15bors pushed 2 new commits to 06auto: 02http://git.io/vO30lg
[06:00:33] <ghrust> 13rust/06auto 14bfe141c 15Caitlin Potter: Fixes #6824 - Correct scan_number() grammar...
[06:00:33] <ghrust> 13rust/06auto 1431b2804 15bors: auto merge of #6825 : caitp/rust/issue-6824, r=Aatch...
[06:00:33] *** Parts: ghrust (ghrust@moz-4EF5B6E5.rs.github.com) ()
[06:00:49] <aatch> Just means that global value numbering, which helps to avoid redundant instructions, takes a while
[06:01:43] <pcwalton> cmr: we do time based releases, not feature based releases
[06:02:03] <pcwalton> so it's designed to be hard although we usually slip a little bit for various release engineering reasons
[06:02:05] <dbaupp> aatch: ah, so there's no way to avoid it
[06:02:50] <aatch> dbaupp, not directly. I'm going to see if I can find some passes that make it more efficient.
[06:03:37] <pcwalton> incoming-quick-win is green again
[06:05:15] <aatch> quick, break it
[06:05:59] <acrichto> pcwalton: r? https://github.com/mozilla/rust/pull/6798
[06:06:20] *** Quits: bytbox (s@moz-D83E9B31.wireless.umd.edu) (Ping timeout)
[06:06:41] <pcwalton> acrichto: r+, yay!
[06:06:51] * acrichto crosses fingers
[06:08:47] <pcwalton> 1:15 ratio for librustc
[06:08:50] <pcwalton> there's something weird going on there
[06:09:15] <cmr> I'm not sure it's a valid ratio to be using tbh
[06:09:33] *** Quits: jaen (jaen@moz-E0979827.copit.pl) (Ping timeout)
[06:09:33] <cmr> I'm not sure they both grow by the same factor (trans and llvm, that is)
[06:10:02] <cmr> Certainly good to bring it down though
[06:10:05] <pcwalton> well, hopefully llvm scales linearly with many functions
[06:10:07] <pcwalton> since we don't really LTO
[06:10:17] <pcwalton> modulo inlining of course
[06:10:29] <Eridius> ok clean build finished building. I don't know why a non-clean build failed
[06:10:47] <aatch> cmr, actually, they are related. If it takes longer to generate the initial IR, it should take longer optimize
[06:10:53] <Eridius> also, the removal of vec from prelude makes me very sad :(
[06:11:04] <Eridius> every single file I've ever written in rust will need an update
[06:11:07] <aatch> libsyntax, 1:7.9
[06:11:28] <pcwalton> &fn -> fn and ~fn/@fn -> proc will also break all rust code
[06:11:51] <aatch> The joys of working with an alpha programming language
[06:11:53] <pcwalton> also pub impl/pub extern removal and let x = 1, y = 2
[06:12:00] <pcwalton> those two are my next target for tomorrow
[06:12:08] <pcwalton> I do front load all of the breaking changes in my work
[06:12:18] <Eridius> let x = 1, y = 2?
[06:12:20] <pcwalton> to try to minimize the pain down the road
[06:12:29] <pcwalton> let x = 1, y = 2 becomes let (x, y) = (1, 2);
[06:12:34] <pcwalton> the latter of which already works
[06:12:42] <Eridius> pcwalton: I get that breakage is to be expected, but I really liked being able to easily say vec::foo without having to throw a `use std::vec` in every file
[06:12:59] <Eridius> pcwalton: ah. That shouldn't break anything then, should it? It's syntax that formerly wasn't valid?
[06:13:07] <pcwalton> no, "let x = 1, y = 2" is valid
[06:13:19] <dbaupp> rusti: let x = 1, y = 2; (x, y)
[06:13:20] -rusti- (1, 2)
[06:13:29] <pcwalton> but it won't be for much longer :)
[06:13:39] <pcwalton> well, like I said hopefully you won't need to use vec:: much. it is possible that it'll be too painful and we'll have to bring it back
[06:13:47] <pcwalton> but hopefully we won't need to reexport *everything* in the prelude
[06:14:05] *** Joins: jaen (jaen@moz-E0979827.copit.pl)
[06:14:30] <Eridius> pcwalton: oh it is? and you're removing it? Heh, I thought it wasn't valid at all
[06:14:42] <pcwalton> yeah, it was a little used duplicate feature
[06:14:45] <pcwalton> and duplicate features are bad
[06:14:46] <Eridius> so my existing code already uses let (x, y) = (foo, bar)
[06:15:11] <pcwalton> dates back to the time before patterns were legal after let :)
[06:15:49] <dbaupp> rusti: let mut (x, y) = (1, 2); x += 1; y += 1; (x, y)
[06:15:50] -rusti- (2, 3)
[06:15:58] <aatch> dbaupp, doing an extra constmerge pass earlier cuts down the number of constants and makes gvn faster
[06:16:09] <pcwalton> and also it eliminates the question of whether "mut" distributes
[06:16:14] <pcwalton> let mut x = 1, y = 2;
[06:16:17] <pcwalton> is y mut or not?
[06:16:25] <pcwalton> easiest to just eliminate the question :)
[06:16:38] *** Quits: Cromulent (Cromulent@moz-983B638D.cable.virginmedia.com) (Quit: KVIrc 4.2.0 Equilibrium http://www.kvirc.net/)
[06:16:42] <cmr> r? https://github.com/mozilla/rust/pull/6826
[06:16:52] <dbaupp> aatch: yay! :) (are you going through the entire list of LLVM passes?)
[06:16:58] <Eridius> argh, io isn't exported either? is io::println going to be moved into prelude?
[06:17:16] <cmr> Eridius: println is already in the prelude
[06:17:23] <cmr> as println, not io::println
[06:17:30] <Eridius> ...bah
[06:17:33] <cmr> has been since 0.6
[06:18:11] <aatch> dbaupp, not really. I'm just looking at the passes that take the most time and am trying to find what I can change to make them more efficient
[06:18:24] <dbaupp> that sounds more reasonable
[06:18:49] <dbaupp> how much faster does gvn get?
[06:19:26] <pcwalton> haskell has a much larger prelude than we do and ocaml even larger still, I'm personally in favor of it growing a little more
[06:19:49] <pcwalton> especially since we have methods unlike both of them, which are nicely tucked away under the type's namespaces
[06:19:57] <pcwalton> so the namespace pollution ought to be minimal
[06:20:01] <aatch> dbaupp, 9.4% -> 7.7%
[06:20:06] <Eridius> perhaps
[06:20:27] <aatch> thats of the total time taken
[06:20:50] <dbaupp> does the total time decrease?
[06:20:57] <aatch> dbaupp, yep
[06:21:02] <cmr> pcwalton: updated the PR
[06:21:15] <aatch> 27s -> 23s
[06:21:45] <cmr> The whole thing is a lot more inefficient than before... terminfo entries are parsed for every diagnostic message printed :\
[06:22:06] <aatch> pcwalton, you will be pleased to hear that librustc is at 1:10
[06:22:18] <pcwalton> cool!
[06:22:26] *** Quits: geomyidae (geomyidae@DD6F7E3A.21468E9A.30200F38.IP) (Quit: Tschuss!)
[06:22:29] <pcwalton> that's, like, 30+ seconds off
[06:22:43] <aatch> pcwalton, do you have the --passes flag?
[06:22:43] *** Joins: doomlord (doomlod@moz-3CF8202D.range81-159.btcentralplus.com)
[06:22:58] <pcwalton> --passes?
[06:23:04] <pcwalton> I know about -Z time-llvm-passes...
[06:23:11] <pcwalton> (as I added that flag) :)
[06:23:20] <aatch> in the compiler. I added a flag so you can provide your own pipeline
[06:23:32] <pcwalton> oh, I see
[06:23:32] <pcwalton> cool
[06:23:43] <Jeaye> Rah, ~str + char?
[06:23:53] <aatch> I'll send you the current pipeline.
[06:24:11] <Jeaye> ~str += char, rather. What's an equivalent that works?
[06:24:18] <cmr> Jeaye: push_char
[06:24:38] <Jeaye> Ahh, see it in the docs now. Thanks, cmr.
[06:24:52] <dbaupp> Jeaye: btw, apparently += is broken for non-primitive types
[06:25:07] <Jeaye> ah, snap
[06:27:42] <pcwalton> heading to bed now since it looks like things will pass
[06:27:46] <pcwalton> g'night everyone
[06:27:48] <cmr> pcwalton: re https://github.com/mozilla/rust/pull/6826#discussion_r4451195 I allocate because I want to return an Option<~path>, not an Option<path>
[06:27:54] <cmr> Should I change it?
[06:27:59] <pcwalton> cmr: ah, OK, that's fine
[06:28:06] <pcwalton> as long as you have a reason to
[06:30:32] <pcwalton> cmr: I'll r+ in the morning with changes if nobody else gets to it
[06:30:44] <cmr> pcwalton: ok, thanks. sleep well :)
[06:30:54] <pcwalton> no problem
[06:30:55] *** Quits: pcwalton (pcwalton@moz-481A040C.hsd1.ca.comcast.net) (Quit: pcwalton)
[06:32:03] *** Joins: xazax (Mibbit@6655692F.3B222813.3F580572.IP)
[06:34:43] <Eridius> woot, error: internal compiler error: unexpected failure
[06:35:17] <Eridius> lookup_item: id not found: 118091', /Users/kevin/Dev/rust/rust/src/librustc/metadata/decoder.rs:92
[06:35:38] <cmr> Eridius: Do you get a useful backtrace at all?
[06:35:46] <dbaupp> those are always so fun! :(
[06:35:52] <Eridius> cmr: nope, no backtrace at all. See my previous bug about backtrace not working
[06:36:12] <cmr> Link?
[06:36:16] <aatch> Huh, mergefuncs actually makes inlining faster
[06:36:18] <cmr> There's already https://github.com/mozilla/rust/issues/1650 btw
[06:36:30] <Eridius> cmr: https://github.com/mozilla/rust/issues/6823
[06:36:40] <Eridius> it's not that it's not useful. It's that it doesn't exist, period.
[06:37:28] <cmr> Meh, semantics ;)
[06:39:26] *** Quits: brson (brson@51C589B3.EF2694B5.DFAC6AA7.IP) (Quit: leaving)
[06:39:51] *** Quits: blitter (blitter@moz-E761A52F.dyn.centurytel.net) (Ping timeout)
[06:40:16] *** Joins: sp3d (a@moz-49806493.dhcp.stls.mo.charter.com)
[06:40:20] *** Quits: hjr3 (hradtke@moz-E87BDF1F.socal.res.rr.com) (Quit: My MacBook has gone to sleep. ZZZzzzâ€¦)
[06:41:18] *** Quits: diamond (Richard@moz-625C0DAF.ks.ok.cox.net) (Ping timeout)
[06:41:35] *** Joins: Voomer_ (Voomer@moz-E97E8EB7.br.br.cox.net)
[06:41:44] *** Quits: Voomer (Voomer@moz-E97E8EB7.br.br.cox.net) (Ping timeout)
[06:41:57] *** Quits: tikue (tkuehn@moz-CF8BEBEF.dia.static.qwest.net) (Quit: tikue)
[06:42:27] <Jeaye> Why can I say my_str.push_char(c), but I have to say str::pop_char(&my_str)? (Well, that doesn't even work -- haven't madeit work yet)
[06:42:45] *** Joins: diamond (Richard@moz-625C0DAF.ks.ok.cox.net)
[06:42:55] <cmr> Jeaye: oversight/half-done refactor, I imagine
[06:42:59] <Jeaye> let input: &mut ~str = &self.console.input;
[06:43:02] <Jeaye>         str::pop_char(input);
[06:43:21] <Jeaye> Doesn't seem to like this much. ( error: cannot borrow immutable dereference of & pointer as mutable )
[06:43:58] <cmr> I think you want = &mut self....
[06:44:08] <Jeaye> ohh
[06:45:01] <Jeaye> I get lost with a couple things in Rust. Namely the explicit lifetimes and where the hell to put mut.
[06:45:20] <Eridius> Jeaye: you add mut when the compiler yells at you ;)
[06:45:25] <Jeaye> haha
[06:45:33] <Jeaye> Noted. Thanks, cmr 
[06:46:38] *** Joins: geomyidae (geomyidae@DD6F7E3A.21468E9A.30200F38.IP)
[06:46:57] <Eridius> hmm, after rebuilding the dependent library, the internal error disappeared
[06:47:46] <dbaupp> Eridius: well, the compilation does load metadata from the crates a file depends on, so it's possibly something about that, if you changed rustc versions
[06:48:07] <Eridius> I changed from a few-days-old incoming to latest incoming
[06:48:55] <Jeaye> I've filed an ICE that happens when dependencies are compiled with a different version of rust.
[06:49:06] <Jeaye> Happens every time for me. Could be what you're seeing.
[06:49:15] <dbaupp> Jeaye: link?
[06:49:24] * Jeaye looks
[06:49:58] *** Quits: dylukes (dylukes@moz-E4DF3FED.pitbpa.fios.verizon.net) (Quit: Computer has gone to sleep.)
[06:54:24] <Jeaye> dbaupp: I'm having the hardest time finding it right now, and Github doesn't show more than a month's worth of my activity.
[06:54:26] <Jeaye> Stand by
[06:54:53] <dbaupp> haha, you can filter the issues created by you in the rust issue tracker, I think?
[06:54:54] *** Joins: engla (engla@moz-DBD1D96E.cust.bredbandsbolaget.se)
[06:55:50] <Jeaye> dbaupp: Nah, it turns out it's not created by me.
[06:55:58] <Jeaye> Just had to do with my code. >.<
[06:56:00] <Jeaye> https://github.com/mozilla/rust/issues/5862#issuecomment-17770347
[06:57:16] <dbaupp> ah cool! that does look like it might be Eridius's bug
[06:57:36] <dbaupp> (I guess the title of that issue could be more descriptive...)
[06:57:47] <Jeaye> Agreed.
[06:58:04] <Eridius> yeah I suspect it is
[07:00:14] *** Quits: devbug (quassel@moz-E1DE087C.bchsia.telus.net) (Connection reset by peer)
[07:02:24] *** Quits: thou (thou@moz-1C1CA9F7.fasttrackcomm.net) (Input/output error)
[07:05:24] *** Joins: thou (thou@moz-1C1CA9F7.fasttrackcomm.net)
[07:08:10] *** Joins: sk (sk@61A494B3.BA40E8A.AAC02D62.IP)
[07:09:11] *** Quits: geomyidae (geomyidae@DD6F7E3A.21468E9A.30200F38.IP) (Quit: Tschuss!)
[07:10:19] *** Joins: geomyidae (geomyidae@DD6F7E3A.21468E9A.30200F38.IP)
[07:11:30] *** Quits: KindOne (KindOne@moz-42F3D0F3.dynamic.ip.windstream.net) (Ping timeout)
[07:11:53] *** Joins: Earnestly (earnest@6A917A59.5E1FD793.39C00A7A.IP)
[07:15:37] *** Joins: KindOne (KindOne@moz-20C408CA.dynamic.ip.windstream.net)
[07:17:04] *** Quits: Jeaye (Jeaye@moz-FD505E54.hsd1.ca.comcast.net) (Quit: zzzZZZzzz)
[07:18:01] *** Joins: indirect (indirect@moz-350C7BE0.ap-northeast-1.compute.amazonaws.com)
[07:19:19] *** Quits: thou (thou@moz-1C1CA9F7.fasttrackcomm.net) (Input/output error)
[07:22:51] <aatch> ah, so it turns out that the optimization flags have some extra meaning after all, not just the passes done.
[07:23:27] <aatch> that makes my improvements a little less impressive, but there is still some improvement.
[07:23:40] *** Quits: jack (jack@2557E599.66715431.D25A875A.IP) (Quit: Leaving.)
[07:24:05] <doomlord> theoretically, could a subset of rust (i've seen the runtime-less patch..) do the same job as this:- http://www.csse.monash.edu.au/~damian/papers/HTML/ModestProposal.html
[07:25:27] <doomlord> ^^^(that proposal was for an alternative syntax for c++ language) - traits are largely controlled overloading, although i realise the vtable stuff is quite different, and i think in this hypothetical subset you'd want @T to map to shared_ptr<T>
[07:34:23] *** Joins: berak (chatzilla@874889A6.4742BCFA.1A5CC7E5.IP)
[07:34:27] *** Quits: engla (engla@moz-DBD1D96E.cust.bredbandsbolaget.se) (Ping timeout)
[07:36:31] *** Joins: ghrust (ghrust@moz-4EF5B6E5.rs.github.com)
[07:36:31] <ghrust> 01[13rust01] 15bors merged 06auto into 06incoming: 02http://git.io/vO30lg
[07:36:31] *** Parts: ghrust (ghrust@moz-4EF5B6E5.rs.github.com) ()
[07:39:29] *** Joins: ghrust (ghrust@moz-4EF5B6E5.rs.github.com)
[07:39:29] <ghrust> 01[13rust01] 15bors pushed 0 new commits to 06auto: 02http://git.io/zL-22g
[07:39:29] *** Parts: ghrust (ghrust@moz-4EF5B6E5.rs.github.com) ()
[07:39:31] *** Joins: ghrust (ghrust@moz-4EF5B6E5.rs.github.com)
[07:39:31] <ghrust> 01[13rust01] 15bors pushed 5 new commits to 06auto: 02http://git.io/xXoZ0Q
[07:39:31] <ghrust> 13rust/06auto 14af995ce 15Alex Crichton: Make missing documentation linting more robust...
[07:39:31] <ghrust> 13rust/06auto 144a5d887 15Alex Crichton: Allow doc(hidden) and --test to disable doc linting
[07:39:31] <ghrust> 13rust/06auto 14007651c 15Alex Crichton: Require documentation by default for libstd...
[07:39:33] *** Parts: ghrust (ghrust@moz-4EF5B6E5.rs.github.com) ()
[07:42:06] <aatch> dbaupp, hey, how often does isrustfastyet run?
[07:42:21] <dbaupp> aatch: every 15 minutes
[07:42:26] <aatch> kk
[07:42:28] <dbaupp> but I manually updated it a few minutes ago
[07:42:36] <dbaupp> not sure why it's not showing up
[07:42:45] <aatch> it just showed up for me
[07:42:47] *** Joins: jack (jack@2557E599.66715431.D25A875A.IP)
[07:42:50] <dbaupp> same
[07:42:56] <dbaupp> you fixed it! :D
[07:43:34] <aatch> Hurrah! regression fixed! Now to submit a pr that fixes it more
[07:43:54] <dbaupp> :D
[07:44:38] *** Parts: berak (chatzilla@874889A6.4742BCFA.1A5CC7E5.IP) ()
[07:44:45] <Eridius> what's the isrustfastyet url again?
[07:44:52] <dbaupp> http://huonw.github.io/isrustfastyet/
[07:44:54] <aatch> http://huonw.github.io/isrustfastyet/
[07:45:11] <Eridius> wooo nice slope there
[07:45:18] <aatch> Eridius, that massive spike is my fault
[07:45:37] <dbaupp> according to it, the number grammar in the manual was causing a huge slowdown
[07:45:38] <aatch> fortunately the drop back down is also my doing.
[07:45:48] <dbaupp> hehe
[07:46:29] <aatch> it's wierd how little windows was affected though, relative to the other builds
[07:48:00] *** Quits: snadon (chatzilla@moz-3BC727E8.mc.videotron.ca) (Quit: ChatZilla 0.9.90 [Firefox 22.0/20130521223249])
[07:48:54] <indirect> I just recompiled from master to try to get rid of "error: type `&str` does not implement any method in scope named `from_base64`", but it didn't work :(
[07:49:14] <xazax> well at least we know now how important the accurate documentation is
[07:49:28] <indirect> am I misunderstanding the base64 doc page somehow? it seems to say that str::from_base64 is actually there
[07:49:30] <xazax> it also have huge impact on performance :D
[07:49:59] <aatch> indirect, try building from the incoming branch
[07:50:27] <indirect> aatch: there are methods documented on static.rust-lang.org that are in incoming but not master?
[07:50:33] <indirect> damn :P
[07:50:53] <xazax> dbaupp: what about monitoring the memory usage peak of rustc while building?
[07:51:18] *** Joins: hansjorg (hansjorg@moz-EECB5F79.static.cust.telenor.com)
[07:52:59] *** Quits: jack (jack@2557E599.66715431.D25A875A.IP) (Quit: Leaving.)
[07:53:05] <aatch> indirect, which link exactly are you looking at? 0.6 or, well, not?
[07:53:35] <aatch> xazax, isrustfastyet gets its info from the buildbots
[07:53:36] <indirect> aatch: http://static.rust-lang.org/doc/std/base64.html#implementation-of-frombase64-for-str
[07:54:03] <aatch> Ah right. I have no idea what that page relates to
[07:54:10] <indirect> aatch: it's also in the 0.6 docs: http://static.rust-lang.org/doc/0.6/std/base64.html#implementation-of-frombase64-for-str
[07:54:26] <indirect> but I get that error ^ on both 0.6 and master
[07:54:40] <indirect> so either the docs are wrong or I don't understand how to use the method :)
[07:54:51] <aatch> that said, have you tried putting "use str::FromBase64"
[07:55:14] <Eridius> indirect: `use extra::base64::*`
[07:55:24] <Eridius> if you haven't pulled the trait in, you can't call the method
[07:55:31] <Eridius> (extra on incoming, or std on 0.6)
[07:55:33] <aatch> indirect, ah, also. It's not defined on &str
[07:55:55] <aatch> it's defined on ~str.
[07:56:04] <indirect> aatch: same error on ~"foo".from_base64(), thoughâ€¦
[07:56:05] <aatch> there is a PR to fix this though.
[07:56:22] <aatch> indirect, you need to `use` the trait into scope too.
[07:56:52] <indirect> aatch: so I have "use std::base64::FromBase64;", and from_base64 works on ~[u8]
[07:57:03] <indirect> it's just on ~str that it doesn't work, and that's why I'm confused
[07:57:30] <aatch> indirect, you need to do (~"foo").from_base64()
[07:57:50] <aatch> rusti: ~"foo".from_base64()
[07:57:51] -rusti- more than 5 lines of output, pastebinned: http://sprunge.us/XVAQ
[07:57:57] <aatch> rusti: (~"foo").from_base64()
[07:57:58] -rusti- more than 5 lines of output, pastebinned: http://sprunge.us/eVGU
[07:58:18] <Eridius> rusti: use extra::base64::FromBase64; (~"foo").from_base64()
[07:58:19] -rusti- rust: task failed at 'invalid base64 length', /build/rust-incoming-git/src/rust/src/libextra/base64.rs:137
[07:58:19] -rusti- rust: domain main @0x64b1b0 root task failed
[07:58:43] <aatch> rusti: use extra::base64::FromBase64; (~"fooa").from_base64()
[07:58:44] -rusti- ~[126, 138, 26]
[07:58:47] <indirect> aatch: uhhhhhh what? yeah that doesn't work. heh
[07:58:49] <aatch> rusti: use extra::base64::FromBase64; ~"fooa".from_base64()
[07:58:50] -rusti- ~~[126, 138, 26]
[07:58:56] <indirect> extra?
[07:58:59] <indirect> not std?
[07:59:03] <Eridius> indirect: in incoming, core is std, and std is extra
[07:59:05] <Eridius> they were renamed
[07:59:07] <aatch> indirect, depends on the build you have
[07:59:09] <indirect> oh
[07:59:33] <indirect> and yeah, as you can see, parens not needed
[07:59:34] <Eridius> aatch: hmm, the last rusti you tried suggests it works on &str now. Was the PR accepted?
[07:59:42] <Eridius> indirect: well it produced a ~~[u8] instead of a ~[u8]
[07:59:46] <aatch> Eridius, seems so
[07:59:49] <indirect> I guess it was documented in 0.6 but not implemented in master yet?
[07:59:53] <Eridius> so it called from_base64 on a &str and then wrapped up the resulting ~[u8] in another ~
[07:59:53] <indirect> oh true
[07:59:57] <aatch> Or it might be the other way round.
[08:00:03] <Eridius> indirect: base64 exists in 0.6.
[08:00:08] <indirect> hah I'm so confused now
[08:00:20] <indirect> Eridius: yes it does, but (afaict) it only works on ~[u8], not ~str
[08:00:42] <indirect> so I'm trying to compile incoming now, because it doesn't seem to work on master either...
[08:01:06] <indirect> I'd be super happy to be told I'm just doing it wrong though :)
[08:01:46] *** Quits: ion (ion@heh.fi) (Quit: Moving the server)
[08:02:30] *** Quits: xazax (Mibbit@6655692F.3B222813.3F580572.IP) (Quit: http://www.mibbit.com ajax IRC Client)
[08:02:33] <Eridius> indirect: show code?
[08:04:51] <indirect> Eridius: ~"foo".from_base64()
[08:04:57] <indirect> oops
[08:05:06] *** Joins: EXetoC (ex@moz-C741B177.customer.t3.se)
[08:05:07] *** Joins: donri (dag@moz-9BB61102.tbcn.telia.com)
[08:05:25] <indirect> Eridius: extern mod std; use std::base64::FromBase64; ~"foo".from_base64();
[08:05:41] <Eridius> indirect: (~"foo").from_base64()
[08:05:47] <indirect> doesn't help
[08:05:49] <indirect> tried that though
[08:05:59] <indirect> aatch suggested it a minute ago
[08:06:11] *** Joins: nielsle (nielsle@moz-5CE8ECCD.boa.fiberby.dk)
[08:06:35] *** aatch is now known as aatch|gone
[08:06:37] <indirect> I just accidentally deleted my rustc so I can't paste you the error until it recompiles :(
[08:07:02] *** Joins: xazax (Mibbit@6655692F.3B222813.3F580572.IP)
[08:07:13] <Eridius> indirect: I just checked the source of 0.6, FromBase64 is definitely implemented on ~str
[08:07:16] <Earnestly> How does one "accidentally" delete rustc? :o (you can ignore this)
[08:07:26] <Eridius> haha
[08:07:40] <indirect> Eridius: hmmmm no idea why it keeps telling me there's no method then :(
[08:07:56] <indirect> Earnestly: brew reinstall rust --HEAD, without realizing that does an rm -rf on my entire rust installation :(
[08:08:03] <Eridius> indirect: show the real code, not the boiled-down snippet that you think is representative?
[08:08:13] <Eridius> indirect: yeah just use `install` and then purge the old installations when you're done
[08:08:16] *** Quits: sawrubh (uid6719@moz-D8B63698.irccloud.com) (Ping timeout)
[08:08:30] <indirect> Eridius: sure, one sec
[08:08:44] <indirect> yeah, it complained it was already installed because I switched from master to incoming
[08:08:51] <indirect> so I thought it would compile and then install over
[08:08:54] <indirect> not delete and then install again
[08:08:55] <indirect> blah
[08:08:59] <Eridius> if you want to use incoming, why are you installing from brew?
[08:09:24] <indirect> well, until now, because I was lazy, and it's convenient to have things siloed
[08:09:33] <indirect> I am rethinking that strategy due to having my rust installation deleted :P
[08:09:37] *** Joins: aruniiird (arun@92D70115.B332A52C.E3D0A897.IP)
[08:09:57] <indirect> I mean, it's really easy to switch brew to use incoming
[08:10:43] <indirect> and I'm familiar and comfortable with managing packages installed into my cellar, and installing directly into /usr/local is a pain in the ass in comparison
[08:11:20] <dbaupp> xazax: as aatch said, isrustfastyet gets info from the buildbots and they only give start and ends times for each phase, no more info :(
[08:12:46] <xazax> I see =( 
[08:14:01] <indirect> Eridius: https://gist.github.com/indirect/74c0974cb28eeb09f5d8
[08:15:01] *** Joins: robertknight (robertknig@moz-54528EE0.wby.mendeley.com)
[08:15:33] <indirect> Eridius: in the first function, ~[u8].to_base64() is clearly working, but I can't figure out how to compile anything that calls from_base64() on a &str or ~str :\
[08:15:37] <Eridius> indirect: you still have ~"foo".from_base64() in there.
[08:15:56] <Eridius> indirect: btw, matasano challenges in rust is fun :)
[08:15:58] <indirect> yesâ€¦ that was my last attempt, after (~"foo").from_base64() failed
[08:16:05] <indirect> yes :)
[08:16:45] *** Quits: robertknight (robertknig@moz-54528EE0.wby.mendeley.com) (Quit: ["Textual IRC Client: www.textualapp.com"])
[08:16:47] <indirect> I managed to iterate on hex_to_base64 a few times to something that actually makes me fairly happy considering how much of a rust n00b I am
[08:17:02] <Eridius> indirect: I would recommend just making a tohex(&str)->~[u8] and fromhex(&[u8])->~str, and having base64 be a separate step on ~[u8]
[08:17:06] <indirect> I'd love an iterator that gave me two bytes at a time though
[08:17:47] <Eridius> indirect: ditch that while loop and use a for uint::range(0,len) |i| instead
[08:17:50] <indirect> Eridius: sure, that's a perfectly fine workaround, but the docs say that from_base64 is defined on str, and the compiler says it's notâ€¦ which is why I'm asking in here :)
[08:18:14] <indirect> Eridius: but I need pairs of bytes?
[08:18:20] <dbaupp> indirect: or even for str::each_char(decoded) |c| { hex.push_char(c); }
[08:18:38] <dbaupp> indirect: your slicing is only retrieving a single byte
[08:18:45] <Eridius> indirect: I'm looking at your existing code, a for uint::range(0,len) |i| loop will behave the same as your while, it'll just look nicer
[08:18:48] <indirect> oh, the one inside base64_to_hex
[08:18:51] <indirect> which does not work
[08:18:58] <Eridius> I'm looking at hex_to_base64
[08:19:08] <Eridius> oh dbaupp was looking at base64_to_hex I see
[08:19:09] <dbaupp> you can use uint::range_step(0, len, 2)
[08:19:09] <indirect> Eridius: i+=2 ?
[08:19:12] <indirect> OH
[08:19:16] <indirect> there we go
[08:19:22] <Eridius> oh sorry, yeah I probably needed the step
[08:19:27] <indirect> didn't know range_step existed
[08:19:29] <indirect> excellent
[08:19:31] <Eridius> what can I say, it's after 1am
[08:19:35] <indirect> haha no worries
[08:20:23] <indirect> at least it's an iterator
[08:20:47] <indirect> any chance of an each_slice(2)? or should I go implement it? :P
[08:21:46] <indirect> dbaupp: way, way better. thank you!
[08:22:57] <dbaupp> :)
[08:23:19] *** Joins: samnardoni (samnardoni@moz-7C6DD1E2.dab.02.net)
[08:24:06] <heftig> Eridius: what is tohex supposed to be?
[08:24:09] *** Joins: robertknight (robertknig@moz-54528EE0.wby.mendeley.com)
[08:26:05] *** Quits: samnardoni (samnardoni@moz-7C6DD1E2.dab.02.net) (Ping timeout)
[08:30:46] *** Parts: mcpherrin (mimcpher@moz-345B5EBA.csclub.uwaterloo.ca) ()
[08:31:07] *** Joins: mcpherrin (mimcpher@moz-345B5EBA.csclub.uwaterloo.ca)
[08:31:30] *** Joins: CarpNet (ac@moz-FD24B77.sohonet.co.uk)
[08:32:46] *** Joins: doener (doener@moz-121949B3.unitymediagroup.de)
[08:32:48] *** Joins: samnardoni (samnardoni@moz-7C6DD1E2.dab.02.net)
[08:32:54] <fdr>  hey peeps.  There is a big pile of warnings when I build incoming (that have been there for some time).  Are these false positives?
[08:33:11] <fdr> because I mean, it seems like one can clean them all in like, half an hour, and I'll do that, but I can't believe they are being left there without another story behind it.
[08:35:04] *** Quits: indirect (indirect@moz-350C7BE0.ap-northeast-1.compute.amazonaws.com) (Ping timeout)
[08:35:53] <dbaupp> fdr: about unnecessary unsafe blocks?
[08:36:12] <dbaupp> (the warnings, that is)
[08:37:03] <fdr> well, all sorts of junk. unused modules, unsafe blocks yeah, extra allocations
[08:37:21] <fdr> I count 691 lines of output to do a full build
[08:37:32] <fdr> some duplicitious from stages I'm sure
[08:37:36] <dbaupp> the unsafe blocks shouldn't be removed
[08:37:42] <dbaupp> but I think the other ones are fine
[08:38:11] <dbaupp> (the unsafe checker was rewritten a few hours ago, so it possibly has bugs)
[08:38:13] <fdr> I think may be platform specific dependencies
[08:38:17] <fdr> *some
[08:38:37] <fdr> which may require a platforms-specific 'use', if that's even a thing (is it?)
[08:39:09] <fdr> okay, I'm going to exorcise not-the-unsafe-block ones and chance my luck
[08:40:39] <fdr> yeah, test dependencies are one sort of thing..
[08:40:53] <fdr> aha, they are a thing..will insert..
[08:42:28] <Jesse> the extra-allocations warning is new too, but i thought it landed with a gigantic "fix all the warnings generated by the first commit" commit
[08:43:00] <fdr> I'll just handle all this. It shouldn't take long and then people can complain.  I'll divide the commits.
[08:43:09] <doomlord> LOC to acheive a certain task, C++ vs rust ... i think rust would generally be about the same or maybe about 2/3rds ?
[08:43:19] *** Joins: EarlGray (mitra@8E712A0.54C21BA0.9F317420.IP)
[08:43:22] <doomlord> 3/4 maybe
[08:44:46] *** Joins: indirect (indirect@moz-350C7BE0.ap-northeast-1.compute.amazonaws.com)
[08:45:21] <dbaupp> doomlord: depends what you're doing, because the standard libraries lack important things
[08:45:53] <doomlord> i forgive any library ommisions since we can write the libraries, library source should be counted in my comparison
[08:46:19] *** Quits: sk (sk@61A494B3.BA40E8A.AAC02D62.IP) (Quit: Leaving)
[08:46:39] <mcpherrin> std::do_what_i_want(); // stdlib oracle function
[08:46:54] <mcpherrin> one line, any task!
[08:47:02] *** Quits: Amanieu (amanieu@moz-D5D10CA8.halls.manchester.ac.uk) (Connection reset by peer)
[08:47:52] <dbaupp> rusti: std::do_what_i_want()
[08:47:54] -rusti- more than 5 lines of output, pastebinned: http://sprunge.us/ISVZ
[08:48:07] <dbaupp> mcpherrin: doesn't seem to work :(
[08:48:27] <dbaupp> haha :P
[08:48:59] *** Quits: samnardoni (samnardoni@moz-7C6DD1E2.dab.02.net) (Ping timeout)
[08:52:30] *** Joins: davbo (dave@moz-3FFA637C.oucs.ox.ac.uk)
[08:52:33] *** Joins: Amanieu (amanieu@moz-D5D10CA8.halls.manchester.ac.uk)
[08:52:56] <indirect> still waiting for compiling to finish, but is clone() the way to get a ~str from a @mut ~str?
[08:53:07] <dbaupp> indirect: *foo
[08:53:09] *** Joins: lucian (lucian@6B2B4644.4304AE1E.CE5E78F6.IP)
[08:53:14] <indirect> oh
[08:53:21] <indirect> yeah, that makes sense
[08:53:32] <indirect> thank you
[08:53:49] <dbaupp> probably with a copy... so yes, either, foo.clone() (using auto-deref) or (*foo).clone()
[08:53:54] <Jesse> doomlord: gecko c++ code would benefit from functions being able to return multiple values and having shorthands for common smart pointer types. and maybe rust's task-failure model would allow large parts of it to not have error checks after other call.
[08:54:02] *** Joins: samnardoni (samnardoni@moz-A981D997.dab.02.net)
[08:54:33] <Jesse> dbaupp: hmm, does that give you a ~str that you can't consume? (because doing so would leave you with an empty @mut cell)
[08:54:33] <dbaupp> Jesse: does C++ not have a tuple type in the stl?
[08:54:42] *** Quits: EarlGray (mitra@8E712A0.54C21BA0.9F317420.IP) (Quit: Konversation terminated!)
[08:54:51] <dbaupp> Jesse: yes, I think *foo does
[08:55:18] <dbaupp> (that is fine if you just need a &str, i think)
[08:55:36] <dbaupp> rusti: let x = @mut (~"foo"); *x
[08:55:37] *** Quits: xazax (Mibbit@6655692F.3B222813.3F580572.IP) (Quit: http://www.mibbit.com ajax IRC Client)
[08:55:38] -rusti- more than 5 lines of output, pastebinned: http://sprunge.us/iDgg
[08:55:38] <indirect> dbaupp: since I'm returning a ~str from a function, I think I need to return an immutable copy?
[08:55:49] <indirect> I'm basically just guessing that though :P
[08:55:52] <dbaupp> rusti: let x = @mut (~"foo"); x.clone()
[08:55:54] -rusti- @~"foo"
[08:56:00] <dbaupp> rusti: let x = @mut (~"foo"); (*x).clone()
[08:56:01] -rusti- ~"foo"
[08:56:27] <dbaupp> indirect: yes, if you're extracting it from a @ then you will need to copy
[08:56:43] <indirect> yep, sounds good. thank you, that was super helpful :)
[08:56:53] *** Joins: dsirenko (mitra@8E712A0.54C21BA0.9F317420.IP)
[08:56:55] *** Joins: xazax (Mibbit@6655692F.3B222813.3F580572.IP)
[08:58:27] <Jesse> dbaupp: i don't think there was much of an stl when gecko was written. i'm guessing modern c++ has something verbose (e.g. ugly type declarations and no destructuring) ?
[08:59:11] <dbaupp> Jesse: no idea, I'm not much of a C++-er... but I'd imagine it'd be verbose
[08:59:48] *** Quits: xazax (Mibbit@6655692F.3B222813.3F580572.IP) (Quit: http://www.mibbit.com ajax IRC Client)
[08:59:51] <dbaupp> seems so, http://www.cplusplus.com/reference/tuple/tuple/
[09:01:07] *** Joins: xazax (Mibbit@6655692F.3B222813.3F580572.IP)
[09:01:14] *** Quits: indirect (indirect@moz-350C7BE0.ap-northeast-1.compute.amazonaws.com) (Ping timeout)
[09:01:55] *** Joins: indirect (indirect@moz-350C7BE0.ap-northeast-1.compute.amazonaws.com)
[09:02:17] *** Quits: aruniiird (arun@92D70115.B332A52C.E3D0A897.IP) (Ping timeout)
[09:04:18] *** Joins: fabiand (fabiand@moz-9283D66.adsl.alicedsl.de)
[09:09:30] *** Joins: ghrust (ghrust@moz-4EF5B6E5.rs.github.com)
[09:09:30] <ghrust> 01[13rust01] 15bors merged 06auto into 06incoming: 02http://git.io/xXoZ0Q
[09:09:30] *** Parts: ghrust (ghrust@moz-4EF5B6E5.rs.github.com) ()
[09:10:14] <indirect> sorry to be turning into that annoying guy, but how do I get to core::uint from a function inside impl FromHex for ~str?
[09:10:31] *** Joins: z0w0 (zack@moz-3E4BFDF8.qld.bigpond.net.au)
[09:10:56] <dbaupp> indirect: are you trying to convert to a uint?
[09:11:00] <indirect> "error: unresolved name" at ^core::uint::range_step
[09:11:13] <EXetoC> std?
[09:12:01] <indirect> EXetoC: oh. yup.
[09:12:09] <indirect> dbaupp: you even told me it got renamed. sigh, sorry :(
[09:12:16] <EXetoC> c(:)
[09:16:47] *** Quits: indirect (indirect@moz-350C7BE0.ap-northeast-1.compute.amazonaws.com) (Quit: indirect)
[09:19:20] *** Quits: rfw (rfw@moz-C65A114.rfw.name) (Ping timeout)
[09:19:46] *** Quits: samnardoni (samnardoni@moz-A981D997.dab.02.net) (Client exited)
[09:21:24] *** Joins: aruniiird (arun@92D70115.B332A52C.E3D0A897.IP)
[09:22:11] *** Quits: bjz (brendanzab@B398BE78.F804C29E.D35A31DF.IP) (Connection reset by peer)
[09:22:12] *** Joins: bjz (brendanzab@B398BE78.F804C29E.D35A31DF.IP)
[09:26:18] *** Joins: spider-mario (spidermari@moz-2F72F6FF.dsl.quantic-telecom.net)
[09:26:19] *** Joins: rfw (rfw@moz-C65A114.rfw.name)
[09:31:24] *** Joins: tgt (tgt@moz-D59EE478.aztw.cable.virginmedia.com)
[09:35:49] *** Quits: aruniiird (arun@92D70115.B332A52C.E3D0A897.IP) (Ping timeout)
[09:45:53] <doener> use super::sched::Scheduler; -- sounds promising :-)
[09:51:55] *** Joins: jensnockert (jensnocker@moz-8BE55278.customer.t3.se)
[09:54:00] *** Joins: aruniiird (arun@92D70115.B332A52C.E3D0A897.IP)
[10:05:06] *** Joins: kornholi (kornholi@otland.net)
[10:09:16] *** Joins: sawrubh (uid6719@moz-D8B63698.irccloud.com)
[10:12:26] *** Joins: judder (maradukewa@385DDD8F.206937E4.78E362FE.IP)
[10:22:41] *** Quits: donri (dag@moz-9BB61102.tbcn.telia.com) (Client exited)
[10:22:47] *** Joins: donri (dag@moz-9BB61102.tbcn.telia.com)
[10:32:35] *** Joins: infynyxx (infynyxx@moz-E95B370B.nyc.res.rr.com)
[10:38:18] *** Joins: q66 (q66@6EE9DE40.46454B5D.33AABD5F.IP)
[10:45:48] *** Quits: infynyxx (infynyxx@moz-E95B370B.nyc.res.rr.com) (Client exited)
[10:46:26] *** Quits: SimonSapin (simon@moz-99690620.hinet-ip.hinet.net) (Ping timeout)
[10:48:09] *** Quits: zxcdw (r-a@moz-C7C5467B.cust.bredband2.com) (Ping timeout)
[10:48:43] *** Joins: SiegeLord (sl@moz-CAF07B4C.hsd1.ma.comcast.net)
[10:53:49] *** Joins: trapni (trapni@moz-6A0EA166.dawanda.com)
[10:53:52] *** Joins: zxcdw (r-a@moz-C7C5467B.cust.bredband2.com)
[11:05:17] *** Joins: RMF (RMF@C168F480.14CBA568.1D9D5961.IP)
[11:10:35] *** Quits: nielsle (nielsle@moz-5CE8ECCD.boa.fiberby.dk) (Ping timeout)
[11:10:39] <thiez_> dbaupp: it's not truly 'my' ray-tracer, but yes, it runs slower
[11:10:50] *** Joins: nielsle (nielsle@moz-5CE8ECCD.boa.fiberby.dk)
[11:11:24] *** thiez_ is now known as thiez
[11:12:00] <thiez> I've merely been keeping it a little up-to-date and used it to experiment with tasks
[11:13:39] <thiez> to be more specific, the ray-tracing takes about twice as long as a week ago :(
[11:21:26] *** Quits: jpf (jan@moz-A8C26A15.org) (Quit: leaving)
[11:22:33] *** thiez is now known as Thiez
[11:24:00] *** Quits: jensnockert (jensnocker@moz-8BE55278.customer.t3.se) (Input/output error)
[11:24:38] *** Quits: geomyidae__ (uid214@moz-C944F5EC.irccloud.com) (Ping timeout)
[11:25:23] <bjz> dbaupp: I added some type predicates and arithmetic operations
[11:29:25] *** Quits: zxcdw (r-a@moz-C7C5467B.cust.bredband2.com) (Ping timeout)
[11:29:26] *** Joins: zxcdw (r-a@moz-C7C5467B.cust.bredband2.com)
[11:31:48] *** Joins: MaikKlein (maik@moz-340073FA.dip0.t-ipconnect.de)
[11:34:53] *** glandium` is now known as glandium
[11:36:11] *** Joins: infynyxx (infynyxx@moz-E95B370B.nyc.res.rr.com)
[11:36:19] *** Quits: zxcdw (r-a@moz-C7C5467B.cust.bredband2.com) (Ping timeout)
[11:36:20] *** Joins: zxcdw (r-a@moz-C7C5467B.cust.bredband2.com)
[11:37:08] *** Joins: Flibo (Flibo@moz-40397852.org.aalto.fi)
[11:38:04] *** Joins: pnkfelix (pnkfelix@moz-801E009D.vlan502.asr1.cdg2.gblx.net)
[11:39:19] *** Joins: igl1 (igl@moz-D0EA0289.adsl.alicedsl.de)
[11:40:59] *** Quits: haard (fredrik@moz-6A86987C.dynamic.se.alltele.net) (Connection reset by peer)
[11:41:21] *** Joins: igl (igl@moz-40109B93.adsl.alicedsl.de)
[11:41:52] *** Quits: igl1 (igl@moz-D0EA0289.adsl.alicedsl.de) (Ping timeout)
[11:43:14] *** Quits: MaikKlein (maik@moz-340073FA.dip0.t-ipconnect.de) (Client exited)
[11:43:51] *** Joins: vmx (vmx@moz-7818230A.pools.arcor-ip.net)
[11:45:29] *** Joins: igl1 (igl@moz-D1E26EB9.adsl.alicedsl.de)
[11:45:42] *** Quits: igl (igl@moz-40109B93.adsl.alicedsl.de) (Ping timeout)
[11:46:18] <dbaupp> wow, I'm popular, hehe
[11:46:25] <dbaupp> Thiez: I see
[11:46:47] <dbaupp> aatch has been working on better LLVM passes, so they might help something
[11:46:51] <dbaupp> maybe...
[11:46:57] <dbaupp> (hopefully!)
[11:47:15] <dbaupp> bjz: cool... looking at the code, they look good!
[11:47:16] *** Quits: igl1 (igl@moz-D1E26EB9.adsl.alicedsl.de) (Ping timeout)
[11:47:24] *** Joins: igl (igl@moz-CBBBE61D.adsl.alicedsl.de)
[11:48:08] *** Quits: Benvie_ (brandon@5FD20F9A.53D07D95.EFF8B7BF.IP) (Ping timeout)
[11:48:27] *** Joins: lmandel (lmandel@FE1F74.86ED00A7.971E19F6.IP)
[11:48:32] <dbaupp> bjz: clojure does `(def x 1) (symbol? x)` == false, `(symbol? (quote x))` == true
[11:48:50] <dbaupp> (for the test that's commented out)
[11:48:53] <bjz> ahh
[11:48:56] *** Joins: Benvie_ (brandon@5FD20F9A.53D07D95.EFF8B7BF.IP)
[11:48:58] <bjz> nice
[11:49:07] *** Quits: igl (igl@moz-CBBBE61D.adsl.alicedsl.de) (Ping timeout)
[11:49:16] <bjz> yeah that would make sense
[11:49:35] <bjz> I'll force push that
[11:49:45] *** Joins: igl (igl@moz-6C91DB7B.adsl.alicedsl.de)
[11:50:07] *** Quits: igl (igl@moz-6C91DB7B.adsl.alicedsl.de) (Connection reset by peer)
[11:50:39] <dbaupp> bjz: it would be nice to have var-args
[11:50:42] *** Joins: MaikKlein (maik@moz-340073FA.dip0.t-ipconnect.de)
[11:50:44] <dbaupp> bjz: or at least an apply function
[11:50:44] *** Joins: igl (igl@moz-6C91DB7B.adsl.alicedsl.de)
[11:50:53] <bjz> indeed
[11:50:55] *** wuwei`lab is now known as wuwei
[11:51:06] <dbaupp> since the only way to do that is via a RustFn
[11:51:15] <dbaupp> er, ExternFn
[11:51:20] <bjz> yeah
[11:51:31] *** Joins: ghrust (ghrust@moz-4EF5B6E5.rs.github.com)
[11:51:32] <ghrust> 01[13rust01] 15bors pushed 0 new commits to 06auto: 02http://git.io/FOjrZQ
[11:51:32] *** Parts: ghrust (ghrust@moz-4EF5B6E5.rs.github.com) ()
[11:51:32] <bjz> like with the arithmetic ops
[11:51:34] *** Joins: ghrust (ghrust@moz-4EF5B6E5.rs.github.com)
[11:51:34] <ghrust> 01[13rust01] 15bors pushed 2 new commits to 06auto: 02http://git.io/U2A8jQ
[11:51:34] <ghrust> 13rust/06auto 141720d9f 15BjÃ¶rn Steinbrink: Remove a bunch of unnecessary allocations and copies
[11:51:34] <ghrust> 13rust/06auto 14682afca 15bors: auto merge of #6829 : dotdash/rust/allocs, r=sanxiyn
[11:51:35] *** Parts: ghrust (ghrust@moz-4EF5B6E5.rs.github.com) ()
[11:51:37] <dbaupp> not sure the best way to do it syntatically though
[11:51:50] *** Joins: strcat (strcat@moz-54F7FD49.cpe.net.cable.rogers.com)
[11:52:02] <bjz> might have to do some research :)
[11:52:04] <dbaupp> (fn (a b c...) <c is a list here>) ?
[11:52:15] <bjz> yeah
[11:52:21] <dbaupp> or (a b ..c) to mirror rust vector pattern matches?
[11:53:03] <bjz> clojure also has (fn () ... (a) ... (a b c) ...)
[11:54:03] <dbaupp> oh, yeah, that's nice
[11:55:32] *** Joins: Sorella (queen@B12A78F5.BA14766C.95C8B7C6.IP)
[11:55:44] *** Joins: pnkfelix|rcirc (pnkfelix@moz-801E009D.vlan502.asr1.cdg2.gblx.net)
[11:56:03] *** Joins: igl1 (igl@moz-546AB34A.adsl.alicedsl.de)
[11:56:12] *** Quits: igl (igl@moz-6C91DB7B.adsl.alicedsl.de) (Ping timeout)
[11:56:26] <bjz> (a b .. c) is nice
[11:57:57] <MaikKlein> hm is noalias alreay in incoming?
[11:58:17] <MaikKlein> already*
[11:58:47] <dbaupp> bjz: let's have both!
[11:59:30] <dbaupp> MaikKlein: there is some in incoming
[12:00:04] *** Joins: bytbox (s@moz-D83E9B31.wireless.umd.edu)
[12:00:06] <strcat> MaikKlein: noalias on ~ parameters is in incoming
[12:00:13] <strcat> &mut noalias isn't on yet
[12:00:17] <strcat> needs to be done a bit differently
[12:01:23] <MaikKlein> ok but in the future a method that changes a member would have to look like this right? fn set(noalias self, i: int)
[12:01:59] *** samebcha1e is now known as samebchase
[12:02:42] <bjz> what does noalias mean?
[12:03:21] <MaikKlein> &mut
[12:03:50] <dbaupp> MaikKlein: the noalias is all underlying information that Rust knows given the current semantics (no extra annotations required) but is only just no passing to LLVM
[12:03:51] <MaikKlein> https://github.com/mozilla/rust/wiki/Meeting-weekly-2013-05-28
[12:04:02] <strcat> MaikKlein: no it's not an explicit annotation
[12:04:20] <strcat> the compiler knows a ~ parameter never aliases with anything
[12:04:25] <dbaupp> bjz: it's when two pointers are guaranteed not to write into memory that the other can read
[12:04:31] <strcat> and it knows &mut can only alias with &const and @mut, not another &mut or &
[12:04:31] <dbaupp> (at least, that's the LLVM definition)
[12:04:55] <dbaupp> s/just no/just now/
[12:04:56] *** Quits: infynyxx (infynyxx@moz-E95B370B.nyc.res.rr.com) (Client exited)
[12:05:00] <bjz> ah nice
[12:05:18] <bjz> so it is a backend thing - folks won't notice it?
[12:05:44] <dbaupp> until it starts doing invalid optimisations, yes
[12:06:12] <strcat> they'll always be valid on valid code ;p
[12:06:15] <dbaupp> (the &mut noalias was invalid, but the current one, which is just ~ noalias, isn't.)
[12:06:24] <strcat> dbaupp: yeah
[12:06:46] <strcat> bjz: if you break the aliasing rules with unsafe blocks you could notice it
[12:07:10] <strcat> use unsafe {} to make two &mut ptrs to the same thing and pass them to a function
[12:07:18] <bjz> strcat: does it tell you?
[12:07:20] <strcat> or one & ptr and one &mut ptr
[12:07:25] <strcat> bjz: no, it can't tell you.
[12:07:32] <bjz> strcat: ahh ok
[12:07:39] <strcat> it's not any harder than writing correct C/C++ though
[12:07:46] <bjz> sure
[12:07:50] <strcat> they have type punning rules too. you can't cast *float to *double
[12:08:06] *** Joins: FrozenCow (FrozenCow@moz-9DF5D010.dynamic.upc.nl)
[12:08:08] <bjz> it would be nice if you could be more explicit with unsafe blocks
[12:08:18] <bjz> as to what yo'ure allowing
[12:08:21] <strcat> you can go *float -> *char -> *double though
[12:08:23] <strcat> in C
[12:08:25] <strcat> but not directly
[12:08:30] <strcat> something like that is what I remember at least ;p
[12:08:30] <bjz> but I don't know how you'd do that
[12:08:37] <bjz> ah
[12:09:13] <strcat> bjz: anyway the "worst-case" for incorrect unsafe blocks isn't that bad
[12:09:33] <strcat> the noalias annotation will just mean it won't necessarily make a write through one ptr observable through another invalid alias
[12:09:55] <strcat> so you could write to the &mut and then read from an invalid & ptr to the same thing and it *might* have the pre-update version
[12:10:09] <strcat> bjz: if you want an example of what it allows LLVM to do...
[12:10:23] *** Joins: infynyxx (infynyxx@moz-E95B370B.nyc.res.rr.com)
[12:10:49] <strcat> bjz: fn foo(output: &mut [f64], input: &[f64]) { /* read from input, multiply-n-stuff and write to output */ }
[12:11:01] <strcat> bjz: rust knows the &mut [] can't alias with the &[]
[12:11:08] <strcat> if it tells LLVM, LLVM can vectorize the loop.
[12:12:20] *** Joins: haard (fredrik@moz-6A86987C.dynamic.se.alltele.net)
[12:12:44] <strcat> anyway atm it's just on ~ params...
[12:12:56] <strcat> and I'm not sure if it happens on vectors.
[12:13:23] <bjz> oooh
[12:13:28] <bjz> neateo
[12:13:36] <dbaupp> is it possible to say that specific arguments don't alias? (rather than just "this doesn't alias with anything")
[12:13:44] <strcat> dbaupp: with a TBAA pass
[12:13:58] <strcat> TBAA basically queries you about pairs of pointers
[12:14:00] <strcat> any pointers.
[12:14:51] <strcat> and you have to response NoAlias, MayAlias, MustAlias or PartialAlias
[12:14:58] <strcat> so for example....
[12:15:17] <strcat> if it passes you two pointers to memory you know is constant, you can respond *either* NoAlias or MustAlias :)
[12:15:48] <strcat> noalias implies that the parameter is disjoint from any other state the function starts with.
[12:15:52] <strcat> (on a param)
[12:18:11] <dbaupp> ah cool, so it is possible to get fine-grained aliasing info
[12:18:31] <dbaupp> but we'd have to write a Rust specific pass, presumably
[12:18:49] <strcat> dbaupp: yes, but it doesn't look very hard
[12:19:13] <strcat> dbaupp: the actual part that responds could be a stub in C++, all that happens is you get passes the TBAA metadata you attached to stuff and have to respond based on it
[12:19:38] <dbaupp> ooh, so we could write the logic in Rust. very nice
[12:19:38] <strcat> ~ never aliases ~, ~ never aliases @, &mut never aliases &mut, &mut never aliases & and so on.
[12:20:12] <strcat> dbaupp: I have a few bugs open about this stuff
[12:20:34] <dbaupp> yeah, it could basically be match (ptr1,ptr2) { (~, ~) => .. , (&,&mut) => .., ... }, right?
[12:20:34] <strcat> dbaupp: http://www.reddit.com/r/rust/comments/1f3ekz/a_tiny_step_towards_alias_analysis/ some linked there
[12:20:40] <strcat> dbaupp: yep.
[12:20:49] <dbaupp> strcat: yeah, been following that stuff :)
[12:21:08] <strcat> it will be easy to get it back on &mut params anyway
[12:21:19] <strcat> just need to scan all arguments for &const and @mut and bail out if there are any
[12:25:35] <strcat> bjz: anyway this is how we make rust faster than C for lots of stuff :)
[12:26:22] <strcat> bjz: http://benchmarksgame.alioth.debian.org/u64/fortran.php it's the main reason fortran beats C here afaik. pointers don't alias by default
[12:26:52] <strcat> the benchmarks obviously had more work in C so it's impressive that it still wins on some
[12:26:55] <bjz> yesss
[12:26:55] *** Joins: victorporof (victorporo@DE2B5DEF.67CDC207.79933D60.IP)
[12:27:09] <bjz> go rust
[12:27:13] <bjz> you can do it
[12:27:16] <bjz> :)
[12:27:43] <strcat> bjz: one LLVM gets their basic block vectorizer stuff working properly it should be really, really awesome...
[12:27:57] <dbaupp> strcat: we can put noalias on all immutable pointers, right?
[12:28:03] <dbaupp> (i.e. pointers to immutable data)
[12:28:05] <strcat> dbaupp: if non-Const things didn't exist
[12:28:20] <dbaupp> well, pointers to Const things, then
[12:28:21] <strcat> and if we correctly marked stuff as #[mutable] and finalize took &mut self or self by-value
[12:28:24] <strcat> so that's a long term thing
[12:28:27] <strcat> dbaupp: but yeah
[12:28:29] <strcat> we can.
[12:28:44] <dbaupp> so much static information
[12:28:47] <strcat> dbaupp: we could add an attribute to disable it and slowly audit + enable it module-by-module or something
[12:29:02] <bjz> strcat: so basically because rust can provide more static guarantees to llvm, it means it could be faster?
[12:29:06] <strcat> bjz: yep
[12:29:07] <xazax> is it already done that pointers to unrelated types can not alias?
[12:29:15] <strcat> xazax: no
[12:29:22] <strcat> xazax: we don't actually have a TBAA pass yet :(
[12:29:34] <xazax> oh I see
[12:29:37] <strcat> just noalias on some params which is like restrict in C (but automatic)
[12:30:19] <xazax> is there an explicit noalias attribute or something like that?
[12:30:28] <strcat> xazax: yeah there's a noalias attribute for parameters
[12:30:34] <xazax> woot
[12:30:46] <strcat> afaik it exists for clang to map restrict to even when someone does -fno-strict-aliasing
[12:32:26] *** Joins: engla (engla@moz-DBD1D96E.cust.bredbandsbolaget.se)
[12:33:04] *** Quits: aruniiird (arun@92D70115.B332A52C.E3D0A897.IP) (Ping timeout)
[12:33:14] <strcat> aha abort calls gettid and tgkill
[12:33:16] <strcat> that makes sense.
[12:33:45] <strcat> rusti: unsafe fn segfault() { libc::abort() } unsafe { segfault() }
[12:33:50] -rusti- timeout triggered!
[12:33:52] * strcat whitelists those
[12:34:23] <strcat> rusti: unsafe fn segfault() { libc::abort() } unsafe { segfault() }
[12:34:24] * rusti produced no output
[12:37:44] <xazax> rusti spawns a new tasks for each input?
[12:38:08] <strcat> xazax: it runs in a sandbox, a fresh one for each input
[12:38:13] <strcat> rusti: unsafe fn segfault() { libc::abort() } unsafe { segfault() }
[12:38:14] * rusti produced no output
[12:38:15] <strcat> hm
[12:38:23] <xazax> oh, nice
[12:38:35] <strcat> rusti: unsafe fn segfault() { libc::abort() } unsafe { segfault() }
[12:38:37] * rusti produced no output
[12:38:57] *** Joins: sk (sk@EA324BFE.54A580E3.78DD174B.IP)
[12:39:08] <strcat> rusti: unsafe fn segfault() { libc::abort() } unsafe { segfault() }
[12:39:09] -rusti- caught signal: 11
[12:39:27] <strcat> oh python just doesn't care enough to bubble that up
[12:39:31] <strcat> rusti: 5
[12:39:32] -rusti- 5
[12:39:32] -rusti- exit status: 0
[12:42:26] <xazax> python? what a pity :D I tought it was implemented in rust
[12:42:32] <strcat> it's not in either
[12:42:39] <strcat> the bot is in python, but that's just a shim
[12:42:45] *** Joins: maxli (maxli@F2D29657.F60B0462.67AC9B1.IP)
[12:42:52] <strcat> https://github.com/thestinger/playpen it's this
[12:43:41] <strcat> writing it in rust is possible but too much trouble because I'd have to make bindings for system calls, seccomp, and I doubt we even have support for signal handling let alone proper signalfd style
[12:54:32] <strcat> rusti: 5
[12:54:33] * rusti produced no output
[12:57:33] *** Joins: ghrust (ghrust@moz-4EF5B6E5.rs.github.com)
[12:57:33] <ghrust> 01[13rust01] 15bors merged 06auto into 06incoming: 02http://git.io/U2A8jQ
[12:57:33] *** Parts: ghrust (ghrust@moz-4EF5B6E5.rs.github.com) ()
[12:59:17] *** Quits: pnkfelix|rcirc (pnkfelix@moz-801E009D.vlan502.asr1.cdg2.gblx.net) (Ping timeout)
[12:59:21] *** Joins: pnkfelix1 (pnkfelix@moz-801E009D.vlan502.asr1.cdg2.gblx.net)
[12:59:30] *** Quits: pnkfelix (pnkfelix@moz-801E009D.vlan502.asr1.cdg2.gblx.net) (Ping timeout)
[13:00:30] *** Joins: ghrust (ghrust@moz-4EF5B6E5.rs.github.com)
[13:00:30] <ghrust> 01[13rust01] 15bors pushed 0 new commits to 06auto: 02http://git.io/zcxIxQ
[13:00:31] *** Parts: ghrust (ghrust@moz-4EF5B6E5.rs.github.com) ()
[13:00:31] *** Joins: ghrust (ghrust@moz-4EF5B6E5.rs.github.com)
[13:00:32] <ghrust> 01[13rust01] 15bors pushed 4 new commits to 06auto: 02http://git.io/g5uN2w
[13:00:32] <ghrust> 13rust/06auto 14a828a12 15Corey Richardson: extra::term overhaul
[13:00:32] <ghrust> 13rust/06auto 14fbd5927 15Corey Richardson: Use find_equiv in term
[13:00:32] <ghrust> 13rust/06auto 145116be1 15Corey Richardson: rustpkg borrowed pointers
[13:00:32] *** Parts: ghrust (ghrust@moz-4EF5B6E5.rs.github.com) ()
[13:01:27] *** Joins: dylukes (dylukes@moz-E4DF3FED.pitbpa.fios.verizon.net)
[13:03:32] *** Joins: berak (chatzilla@9F3EFF9A.4742BCFA.1A5CC7E5.IP)
[13:05:47] *** Joins: jensnockert (jensnocker@moz-8BE55278.customer.t3.se)
[13:05:56] *** Quits: sk (sk@EA324BFE.54A580E3.78DD174B.IP) (Input/output error)
[13:06:17] *** Joins: sk (sk@EA324BFE.54A580E3.78DD174B.IP)
[13:06:24] <xazax> I checked the parser and concluded all of the unary operators have the same precedence and it is higher than any of the binary operators. Is it correct?
[13:06:29] *** Joins: sk_ (sk@EA324BFE.54A580E3.78DD174B.IP)
[13:07:00] *** Quits: sk_ (sk@EA324BFE.54A580E3.78DD174B.IP) (Quit: Leaving)
[13:07:11] <xazax> if it is correct I'll extend the docs: https://github.com/mozilla/rust/issues/4543
[13:11:03] *** Quits: tupshin (quassel@moz-E7B03838.c3-0.nyr-ubr1.nyr.ny.cable.rcn.com) (Ping timeout)
[13:12:31] *** Joins: ghrust (ghrust@moz-4EF5B6E5.rs.github.com)
[13:12:31] <ghrust> 01[13rust01] 15bors 04force-pushed 06auto from 14a7a5d7a to 14682afca: 02http://git.io/N3iJvQ
[13:12:31] *** Parts: ghrust (ghrust@moz-4EF5B6E5.rs.github.com) ()
[13:12:34] *** Joins: ghrust (ghrust@moz-4EF5B6E5.rs.github.com)
[13:12:34] <ghrust> 01[13rust01] 15bors pushed 3 new commits to 06auto: 02http://git.io/EuMWhA
[13:12:34] <ghrust> 13rust/06auto 14c857eb4 15James Miller: Remove the slow bb-vectorize pass
[13:12:34] <ghrust> 13rust/06auto 14e78c2ee 15James Miller: Improve optmization pipeline
[13:12:35] <ghrust> 13rust/06auto 14b7ae0e2 15bors: auto merge of #6828 : Aatch/rust/pass-refactor, r=thestinger...
[13:12:37] *** Parts: ghrust (ghrust@moz-4EF5B6E5.rs.github.com) ()
[13:15:28] *** Joins: jorendorff (jorendorff@moz-2F32ACA3.hsd1.tn.comcast.net)
[13:17:18] *** Quits: dylukes (dylukes@moz-E4DF3FED.pitbpa.fios.verizon.net) (Quit: Computer has gone to sleep.)
[13:18:33] *** Joins: dylukes (dylukes@moz-E4DF3FED.pitbpa.fios.verizon.net)
[13:19:00] *** Quits: dylukes (dylukes@moz-E4DF3FED.pitbpa.fios.verizon.net) (Quit: Computer has gone to sleep.)
[13:19:34] *** Parts: berak (chatzilla@9F3EFF9A.4742BCFA.1A5CC7E5.IP) ()
[13:20:00] *** Joins: jdm (jdm@CAB30FBD.8F96AEA7.2D179A7D.IP)
[13:20:40] *** Quits: Amanieu (amanieu@moz-D5D10CA8.halls.manchester.ac.uk) (Quit: Lost terminal)
[13:21:34] *** Joins: azita (Azita@moz-C1FB2A8.hsd1.ca.comcast.net)
[13:21:35] *** Quits: MaikKlein (maik@moz-340073FA.dip0.t-ipconnect.de) (Ping timeout)
[13:24:11] *** Joins: hjr3 (hradtke@moz-E87BDF1F.socal.res.rr.com)
[13:25:02] *** Joins: geomyidae__ (uid214@moz-C944F5EC.irccloud.com)
[13:25:59] *** Joins: dylukes (dylukes@moz-E4DF3FED.pitbpa.fios.verizon.net)
[13:27:38] *** Joins: jrfeenst (jrfeenst@moz-3265BD65.cpe.norwoodlight.com)
[13:27:59] *** Quits: dsirenko (mitra@8E712A0.54C21BA0.9F317420.IP) (Client exited)
[13:29:23] *** Quits: dylukes (dylukes@moz-E4DF3FED.pitbpa.fios.verizon.net) (Quit: Computer has gone to sleep.)
[13:29:30] *** Joins: dsirenko (mitra@8E712A0.54C21BA0.9F317420.IP)
[13:30:12] *** Joins: dylukes (dylukes@moz-E4DF3FED.pitbpa.fios.verizon.net)
[13:31:41] *** Quits: dylukes (dylukes@moz-E4DF3FED.pitbpa.fios.verizon.net) (Quit: Computer has gone to sleep.)
[13:35:13] <Thiez> rusti: unsafe{ let x: *int = unstable::intrinsics::transmute(10); *x }
[13:35:15] * rusti produced no output
[13:35:39] <strcat> rusti: unsafe { *(0 as *int) }
[13:35:40] * rusti produced no output
[13:35:49] <strcat> it doesn't do anything with raised signals right now
[13:35:56] <Thiez> I noticed :D
[13:36:12] <strcat> it should but...
[13:37:44] *** Quits: victorporof (victorporo@DE2B5DEF.67CDC207.79933D60.IP) (Quit: victorporof)
[13:37:56] <Thiez> no matter, rusti is awesome regardless
[13:38:08] * Thiez gives rusti a cookie.
[13:38:22] <dbaupp> rusti: eat cookie
[13:38:29] <strcat> Thiez: it's tricky because re-raising a signal isn't very correct
[13:38:30] -rusti- foo.rs:8:13: 8:19 error: expected `;` or `}` after expression but found `cookie`
[13:38:30] -rusti- foo.rs:8          eat cookie
[13:38:30] -rusti-                       ^~~~~~
[13:38:38] <strcat> for example if the sandboxed process raises 11 (segfault)
[13:38:46] <dbaupp> it doesn't appear to like cookies :(
[13:38:46] *** Joins: lkuper (lkuper@moz-D862222C.dhcp-bl.indiana.edu)
[13:38:52] <strcat> if you re-raise, and the user has core-dumps enabled, you core dump yourself.
[13:39:12] <Thiez> dbaupp: what surprised me was the huge regression. I intend to track it down at some point, but compiling takes a long long time on my machine so it'll have to wait for the weekend
[13:39:24] <strcat> so... the sandbox could print a line if there was a signal raised
[13:39:34] <strcat> but then you couldn't distinguish it from the child printing that line :)
[13:39:35] *** Joins: ghrust (ghrust@moz-4EF5B6E5.rs.github.com)
[13:39:36] <ghrust> 01[13rust01] 15bors 04force-pushed 06auto from 14b7ae0e2 to 14682afca: 02http://git.io/N3iJvQ
[13:39:36] *** Parts: ghrust (ghrust@moz-4EF5B6E5.rs.github.com) ()
[13:39:36] <strcat> fun!
[13:39:37] *** Joins: ghrust (ghrust@moz-4EF5B6E5.rs.github.com)
[13:39:37] <ghrust> 01[13rust01] 15bors pushed 3 new commits to 06auto: 02http://git.io/dCcsxg
[13:39:37] <ghrust> 13rust/06auto 14c857eb4 15James Miller: Remove the slow bb-vectorize pass
[13:39:37] <ghrust> 13rust/06auto 14e78c2ee 15James Miller: Improve optmization pipeline
[13:39:37] <ghrust> 13rust/06auto 144de5c0d 15bors: auto merge of #6828 : Aatch/rust/pass-refactor, r=thestinger...
[13:39:38] *** Parts: ghrust (ghrust@moz-4EF5B6E5.rs.github.com) ()
[13:39:41] <Thiez> none of the commits between then and now look particularly suspicious
[13:39:42] <strcat> I guess it should always print either
[13:39:47] <strcat> "exit status: %d"
[13:40:01] <strcat> or "signal raised: %d"
[13:40:15] <Thiez> perhaps only print exit status when it's not equal to zero?
[13:40:19] *** Quits: hjr3 (hradtke@moz-E87BDF1F.socal.res.rr.com) (Quit: My MacBook has gone to sleep. ZZZzzzâ€¦)
[13:40:26] *** Joins: pnkfelix (pnkfelix@moz-801E009D.vlan502.asr1.cdg2.gblx.net)
[13:40:30] *** Quits: pnkfelix1 (pnkfelix@moz-801E009D.vlan502.asr1.cdg2.gblx.net) (Connection reset by peer)
[13:40:43] <Thiez> that should limit the 'exit status:' spam
[13:40:45] <strcat> Thiez: but then the child can print "exit status: 1" and you don't know if it exited with 1 or is just a dirty liar
[13:40:47] <strcat> ;p
[13:40:57] *** Quits: ssbr (ssbr@A9D9D38C.B6F034AC.72A31D6.IP) (Ping timeout)
[13:41:32] <Thiez> strcat: in that case I would expect there to be a 'println("exit status: 1")' in the line just above rusti's output :p
[13:41:33] *** Joins: erickt (Adium@49C4075F.3AC15C18.2321E71E.IP)
[13:41:33] <dbaupp> strcat: you could set something (e.g. env variable) that the child doesn't have access to
[13:41:51] <xazax> is there a way to make rustc dump IR?
[13:42:03] <strcat> xazax: yes, --emit-llvm
[13:42:04] <dbaupp> xazax: 'rustc --emit-llvm -S'
[13:42:14] <strcat> if you use -S it pollutes it with ASM comments
[13:42:18] <strcat> and it affects codegen
[13:42:22] <dbaupp> (the -S gives you text rather than bitcode)
[13:42:22] <Thiez> it emits quite a lot
[13:42:26] <strcat> really sucks :(
[13:42:28] <dbaupp> strcat: not true any more
[13:42:36] <dbaupp> that only happens with -Z asm-comments
[13:42:42] <strcat> dbaupp: ah didn't realize :)
[13:43:01] <xazax> if I try to emit llvm of this snippet: https://github.com/mozilla/rust/issues/5280
[13:43:26] <xazax> I get the coredump before it emits the llvm IR :D
[13:43:33] *** Quits: erickt (Adium@49C4075F.3AC15C18.2321E71E.IP) (Quit: Leaving.)
[13:44:16] *** Joins: pnkfelix|rcirc (pnkfelix@moz-801E009D.vlan502.asr1.cdg2.gblx.net)
[13:46:17] <xazax> oh the assert is from IR generation.. 
[13:46:26] <xazax> not from compilation/assembling
[13:46:39] <strcat> xazax: LLVM aborts if the IR is bad
[13:46:45] <strcat> because we have asserts enabled
[13:46:47] <strcat> it's rustc's fault
[13:46:59] <strcat> if we didn't have asserts enabled it would crash or generated bad code
[13:47:03] <strcat> generate*
[13:47:16] <xazax> I think it is better that way, at least those errors do not remain hidden
[13:47:34] <strcat> xazax: well it's not, it makes LLVM 30% bigger and slower
[13:47:42] <strcat> you're not supposed to actually use it with asserts on
[13:47:54] <strcat> our FFI binding should prevent generating bad IR
[13:47:54] *** Quits: mcomella (mcomella@moz-F9E82323.nwrknj.fios.verizon.net) (Broken pipe)
[13:47:59] <dbaupp> strcat: presumably it's good while rustc is still generating crappy IR
[13:48:06] <strcat> dbaupp: yeah.
[13:48:09] <xazax> oh I see
[13:48:24] *** Joins: aruniiird (arun@84E199D6.DCDBCF8E.83D0DF30.IP)
[13:48:24] <strcat> a system LLVM won't have asserts
[13:48:34] <strcat> since a regular release build doesn't
[13:48:53] <strcat> so if we ever do use the system LLVM... we can't count on that being around to catch bugs in rustc
[13:49:00] <xazax> maybe debug/release target in makefiles?
[13:49:28] <strcat> xazax: yes rust builds it as optimized + with asserts
[13:49:51] <strcat> regular builds (like the packages in arch, fedora, debian, ubuntu, etc.) don't have asserts
[13:50:24] <Thiez> a shame it can't be configured at runtime to enable/disable assertions
[13:50:57] <strcat> Thiez: well either way they make it much more bloated and it'd add a bunch of branches
[13:51:11] <strcat> you're really just not supposed to use asserts in releases, only for debugging a problem
[13:51:43] <strcat> triggering asserts means the IR isn't even well-formed - it's much more likely that it's well-formed but compiles to bad code
[13:51:46] <Thiez> it does surprise me that it's 30% bigger, seems like a lot
[13:52:28] *** Joins: MaikKlein (maik@moz-340073FA.dip0.t-ipconnect.de)
[13:52:37] *** Quits: infynyxx (infynyxx@moz-E95B370B.nyc.res.rr.com) (Client exited)
[13:53:28] <Thiez> perhaps they should put the assertions in a pass like the optimizations
[13:53:36] *** Joins: novabyte (Instantbir@BD538790.5DF93767.B8C0F609.IP)
[13:53:45] <strcat> Thiez: IR verification is a pass
[13:53:53] <strcat> the asserts are just if you call APIs totally wrong
[13:54:23] <Thiez> heh, when I made that atomic fuckup a while ago they didn't even catch it
[13:54:50] <Thiez> I was calling stuff with the wrong number of arguments and on several systems all the tests passed :D
[13:57:18] *** Quits: igl1 (igl@moz-546AB34A.adsl.alicedsl.de) (Ping timeout)
[13:57:50] *** Quits: dbaupp (Thunderbir@moz-C6B1454A.lns20.syd7.internode.on.net) (Ping timeout)
[13:59:05] *** Quits: novabyte (Instantbir@BD538790.5DF93767.B8C0F609.IP) (Ping timeout)
[13:59:23] *** Quits: aruniiird (arun@84E199D6.DCDBCF8E.83D0DF30.IP) (Ping timeout)
[14:00:03] *** Quits: pnkfelix (pnkfelix@moz-801E009D.vlan502.asr1.cdg2.gblx.net) (Quit: Leaving.)
[14:00:36] *** Quits: pnkfelix|rcirc (pnkfelix@moz-801E009D.vlan502.asr1.cdg2.gblx.net) (Quit: rcirc on GNU Emacs 24.2.1)
[14:05:48] <cmr> oh bah
[14:06:47] <cmr> What's the windows cfg, win32?
[14:06:57] <strcat> I think so
[14:07:26] <strcat> why does this keep failing ;\
[14:07:29] *** Joins: pnkfelix (pnkfelix@moz-801E009D.vlan502.asr1.cdg2.gblx.net)
[14:07:34] <strcat> https://github.com/mozilla/rust/pull/6828
[14:07:39] <strcat> makes... no sense why it would fail like that
[14:08:03] *** Joins: saml (sam@moz-14C16814.cst.lightpath.net)
[14:09:54] <cmr> uh oh
[14:10:03] <cmr> /src/rust-buildbot/slave/auto-linux/build/src/libstd/repr.rs:22:35: 22:47 error: unresolved import (maybe you meant `visit_tydes::*`?)
[14:10:04] <cmr> /home/rustbuild/src/rust-buildbot/slave/auto-linux/build/src/libstd/repr.rs:22 use intrinsic::{TyDesc, TyVisitor, visit_tydesc};
[14:10:11] <cmr> Didn't realize I had an off-by-one in that code!
[14:10:45] <strcat> cmr: which?
[14:10:51] <EXetoC> "[21607.476157] main[10608]: segfault at 20 ip 000000000044d9e5 sp 00007fe758c57a10 error 4 in main[400000+8b000]" d'oh
[14:10:53] <strcat> it seems like the buildbots are broken
[14:11:09] <cmr> strcat: visit_tydes from visit_tydesc
[14:12:27] <Thiez> I sometimes yield to the temptation of runinng 'make check' before submitting a pr :p
[14:12:50] *** Joins: ghrust (ghrust@moz-4EF5B6E5.rs.github.com)
[14:12:50] <ghrust> 01[13rust01] 15bors 04force-pushed 06auto from 144de5c0d to 14682afca: 02http://git.io/N3iJvQ
[14:12:50] *** Parts: ghrust (ghrust@moz-4EF5B6E5.rs.github.com) ()
[14:12:51] *** Joins: ghrust (ghrust@moz-4EF5B6E5.rs.github.com)
[14:12:52] <ghrust> 01[13rust01] 15bors pushed 3 new commits to 06auto: 02http://git.io/FleHow
[14:12:52] <ghrust> 13rust/06auto 14c857eb4 15James Miller: Remove the slow bb-vectorize pass
[14:12:52] <ghrust> 13rust/06auto 14e78c2ee 15James Miller: Improve optmization pipeline
[14:12:52] <ghrust> 13rust/06auto 1498b9062 15bors: auto merge of #6828 : Aatch/rust/pass-refactor, r=thestinger...
[14:12:54] *** Parts: ghrust (ghrust@moz-4EF5B6E5.rs.github.com) ()
[14:12:59] *** Joins: solancile (solancile@moz-A1CFFAE5.hsd1.wa.comcast.net)
[14:13:10] <friggle> wow, I'm really liking http://smallcultfollowing.com/babysteps/blog/2013/05/30/removing-procs/
[14:13:49] <Thiez> nice, I didn't much like proc either
[14:13:52] *** Joins: aruniiird (arun@moz-3DB73AA5.azulsystems.com)
[14:15:13] <strcat> well that's not good
[14:15:17] <strcat> http://buildbot.rust-lang.org/builders/incoming-full-linux/builds/1382/steps/compile/logs/stdio
[14:16:01] <strcat> and fails on OS X too
[14:16:02] <strcat> same place
[14:16:19] <Thiez> I guess you broke it?
[14:16:29] <strcat> that's incoming
[14:16:39] <friggle> I agreed with the reasoning and felt ultimately it was better than the current situation, but this new proposal is even better
[14:16:45] *** Quits: azita (Azita@moz-C1FB2A8.hsd1.ca.comcast.net) (Quit: azita)
[14:16:53] <Thiez> oh, that is inconvenient, I'm trying to compile incoming right now
[14:16:59] <cmr> friggle: I agree
[14:17:07] <strcat> Thiez: it might only be broken on 32-bit
[14:17:11] <strcat> but it's definitely broken
[14:19:04] <Thiez> excellent, I don't run 32-bit :p
[14:19:20] *** Joins: novabyte (Instantbir@BD538790.5DF93767.B8C0F609.IP)
[14:20:47] *** Quits: Jesse (jruderman@moz-537BCF9.hsd1.ca.comcast.net) (Ping timeout)
[14:21:04] <bstrie> nmatsakis: I think graydon has agreed in the past that macros ought to be able to be defined to use {} in addition to ()
[14:21:49] <bstrie> it definitely looks much nicer when you're imitating control flow
[14:22:40] <nmatsakis> bstrie: yeah. 
[14:22:41] <strcat> rusti: 5
[14:22:41] -rusti- 5
[14:22:42] -rusti- application terminated with error code 0
[14:22:44] <nmatsakis> bstrie: I presume you saw my post? :)
[14:22:45] <strcat> hm
[14:22:46] <benh_> (nmatsakis: [already been requested for other reasons][request] <- broken link/markdown)
[14:22:50] <bstrie> nmatsakis: reading it now
[14:22:54] <strcat> rusti: 5
[14:22:54] -rusti- 5
[14:22:55] <nmatsakis> benh_: argh! I'll fix it. I always do that.
[14:23:01] <strcat> rusti: os::set_exit_status(1)
[14:23:02] -rusti- application terminated with error code 1
[14:23:25] <strcat> rusti: unsafe fn segfault() { libc::abort() } unsafe { segfault() }
[14:23:27] -rusti- application terminated with signal 11
[14:23:44] *** Quits: novabyte (Instantbir@BD538790.5DF93767.B8C0F609.IP) (Quit: bye bye)
[14:23:49] <bstrie> nmatsakis: I'm very slightly saddened at the loss of `do spawn`, but I think that a macro here is worth it (and likely would have emerged anyway to save us from `do spawn proc`)
[14:24:02] *** Quits: dsirenko (mitra@8E712A0.54C21BA0.9F317420.IP) (Client exited)
[14:24:10] <bstrie> I'm yet not sold on the idea of `spawn(task!())`, though :)
[14:24:28] <strcat> rusti: std::run::create_process("sh", [~"-c", ~"yes > /tmp/oom"]);
[14:24:29] -rusti- more than 5 lines of output, pastebinned: http://sprunge.us/aGDg
[14:24:41] <strcat> rusti: std::run::process_output("sh", [~"-c", ~"yes > /tmp/oom"]);
[14:24:43] * rusti produced no output
[14:24:54] * strcat thought that gave a signal
[14:25:19] * benh_ writes a bot that responds to /me messages by telling rusti to produce no output
[14:25:36] <strcat> ;p
[14:25:37] *** Joins: dsirenko (mitra@8E712A0.54C21BA0.9F317420.IP)
[14:25:53] <strcat> benh_: I could just disable PMs...
[14:25:55] *** Quits: aruniiird (arun@moz-3DB73AA5.azulsystems.com) (Ping timeout)
[14:26:19] <bstrie> nmatsakis: really, you think you can remove once fns with these? I thought part of the idea behind those was some conceptual parity with linear types
[14:26:21] <cmr> compile_and_link: x86_64-unknown-linux-gnu/stage1/lib/rustc/x86_64-unknown-linux-gnu/lib/libstd.so
[14:26:22] <cmr> /home/cmr/hacking/rust/src/libstd/iterator.rs:23:4: 23:7 make: *** [x86_64-unknown-linux-gnu/stage1/lib/rustc/x86_64-unknown-linux-gnu/lib/libstd.so] Error 101
[14:26:26] <cmr> wonderful error :)
[14:26:58] <benh_> Where I come from, we just ad-hoc-ishly extended the protocol to be that bots don't respond to users whose nick ends in bot, and didn't worry about notices/privmsgs ;)
[14:27:17] *** Quits: engla (engla@moz-DBD1D96E.cust.bredbandsbolaget.se) (Ping timeout)
[14:27:20] <nmatsakis> bstrie: they are still 'nice to have', but you don't really need them. you can work-around it by passing the values that would need to be moved as an argument
[14:27:30] <bstrie> benh_: kind of sucks if your last name is "abbot", though :P
[14:28:02] <benh_> true. it was a silly place where people didn't use their real names in nicknames :)
[14:29:06] <cmr> Anyone have a warning cleanup in progress?
[14:29:09] <jdm> nmatsakis: wow, I like the new proposal quite a bit
[14:30:08] <nmatsakis> jdm: cool, me too, I feel like it's the first thing that feels right, in that the end result seems simpler than the starting point :)
[14:30:27] <jdm> yeah, it appears quite unintimidating
[14:30:30] <nmatsakis> plus I never liked writing &fn(), and I love me some sigils.
[14:30:49] <nmatsakis> ;)
[14:30:51] <benh_> I'm surprised we're so eager to throw out copying closures
[14:31:01] <nmatsakis> benh_: well, *I* am :)
[14:31:09] <nmatsakis> I'm not sure if others will share my enthusiasm.
[14:31:14] <nmatsakis> but why are you surprised? they don't get much use.
[14:31:30] <benh_> your blog seems to tend to be a portent of things to come though :)
[14:31:41] <nmatsakis> sometimes, not always :)
[14:31:57] *** Quits: KindOne (KindOne@moz-20C408CA.dynamic.ip.windstream.net) (Ping timeout)
[14:32:27] <friggle> benh_: I guess it will be discussed at the meeting next week, and it will rather depend what the others think
[14:32:53] <benh_> I got the impression that lambdas that outlive the scope of where they're created are a common case outside of rust to the point where it's a pattern to use them for lightweight objects with only one method, so to speak
[14:32:57] *** Quits: sp3d (a@moz-49806493.dhcp.stls.mo.charter.com) (Ping timeout)
[14:34:01] *** Joins: KindOne (KindOne@moz-49F58A04.dynamic.ip.windstream.net)
[14:34:06] <nmatsakis> benh_: it's not like we can't accommodate that fairly easily. the task! pattern I showed is quite generic.
[14:34:17] <nmatsakis> benh_: all it means is that you have to name the things you use
[14:34:53] <nmatsakis> benh_: that said, Rust tends towards less runtime abstraction
[14:35:07] <nmatsakis> benh_: so I imagine we'd rather return a concrete struct, and define an impl on it,
[14:35:11] <nmatsakis> benh_: than return a closure
[14:35:17] <nmatsakis> benh_: then when you call the methods, you get static dispatch, etc
[14:35:33] <benh_> (... I suppose it's not too weird to use that pattern to emulate the full spectrum of C++'s lamba by-value/by-ref specifiers...)
[14:35:48] <nmatsakis> yes, you can use that same pattern to capture by ref,
[14:35:53] <nmatsakis> if you don't plan to send the task anywhere else
[14:36:05] <nmatsakis> well, we'd have to beef up the macro a bit I guess
[14:36:16] <bstrie> nmatsakis: is the `spawn(task!())` approach more expensive than the `spawn!()` approach because you're casting to a trait object?
[14:36:23] <cmr> So https://github.com/cmr/rust/commit/6d25254d5c241d4ce3da409a5b2ccfba60c113fd doesn't do platform detection correctly it seems: on non-win32, the win32 modules are being picked. Am I doing it wrong?
[14:36:24] <nmatsakis> bstrie: no, those casts are super cheap. 
[14:36:27] *** Quits: MaikKlein (maik@moz-340073FA.dip0.t-ipconnect.de) (Ping timeout)
[14:36:30] <bstrie> ok, good to know
[14:36:30] <nmatsakis> bstrie: in fact, it's the same cost.
[14:36:51] <nmatsakis> bstrie: either way you are allocating the "environment" on the ~ heap (in this case, the environment is made explicit, in the struct) and then adding a static pointer
[14:37:07] <nmatsakis> bstrie: the only part that's a hair more expensive (right now) is that the vtable adds an extra layer of indirection when calling the run method
[14:37:18] <nmatsakis> bstrie: but we could represent vtables with a single method differently, if we wanted,
[14:37:23] <nmatsakis> bstrie: and anyway I think this is really not a significant cost.
[14:37:54] <nmatsakis> well, we might not be able to represent the vtables differently, since they also carry a type descriptor I think.
[14:38:00] <nmatsakis> anyway, it's trivial.
[14:38:12] *** Joins: Blub\w (wry@moz-E93CF12B.wireless.dyn.drei.com)
[14:38:58] <benh_> This proposal means that by-ref closures still can't move out of things they close over, right?
[14:38:59] <bstrie> nmatsakis: I think it's a really good proposal, and I'm torn between the more-general feeling of `spawn(task!())` and the more concise feeling of `spawn!()`. though I'd want to write up some examples first
[14:39:48] *** Joins: erickt (erickt@8C9ECD8F.3A598286.F12515B4.IP)
[14:40:08] *** Joins: caitp (caitp@moz-2E2F18CB.senecacollege.ca)
[14:40:43] <nmatsakis> bstrie: yeah, I imagine we might keep spawn! and task!. Task could be used for less common cases.
[14:40:54] <nmatsakis> benh_: that's right, BUT...
[14:40:57] <bstrie> you mean spawn! and future! ?
[14:41:08] <nmatsakis> bstrie: yeah, probably
[14:41:16] <nmatsakis> benh_: (1) we can allow you to move out, so long as you replace it
[14:41:30] <nmatsakis> benh_: (I'm working on a post about the precise rules for borrowed closures right now)
[14:41:31] <bstrie> oh, you mean we would have both
[14:41:42] <nmatsakis> bstrie: I meant we'd have spawn!, future!, and task!
[14:41:47] <bstrie> yeah :)
[14:41:59] <nmatsakis> benh_: (2) You can workaround it by passing arguments, as I showed, OR
[14:42:04] <benh_> bstrie: can't stop you from making more macros to make common cases you find short as well :)
[14:42:38] <nmatsakis> benh_: you can use the task! pattern I showed you but capture a borrowed pointer too
[14:42:51] *** Joins: novabyte (Instantbir@91FFDEC6.3F2319E2.EFEA2F8E.IP)
[14:43:05] *** Quits: KindOne (KindOne@moz-49F58A04.dynamic.ip.windstream.net) (Ping timeout)
[14:43:50] <benh_> It certainly seems to me like making the moves into a closure more explicit makes the whole contruction easier to understand at a glance
[14:43:53] <nmatsakis> benh_: but I think in practice (1) and (2) will be most common.
[14:43:59] *** Joins: pyrac (pyrac@moz-285C535.w92-156.abo.wanadoo.fr)
[14:44:01] <nmatsakis> yeah, I like it.
[14:44:06] <nmatsakis> for that reason.
[14:44:16] <benh_> and the (2) bit makes it very explicit whose responsibility is how often the closure gets called
[14:44:50] *** Joins: KindOne (KindOne@moz-8CE6B5D8.dynamic.ip.windstream.net)
[14:44:52] <bstrie> hm, why does rust require that my future results be mutable in this gist? https://gist.github.com/bstrie/5678380
[14:44:59] *** Quits: caitp (caitp@moz-2E2F18CB.senecacollege.ca) (Quit: caitp)
[14:45:11] <bstrie> if I leave it off, I get "cannot borrow immutable local variable as mutable" at the site of the .get()
[14:45:24] *** Joins: aruniiird (arun@84E199D6.DCDBCF8E.83D0DF30.IP)
[14:45:41] <bstrie> this only happens when we close over the v# values, if I embed them directly in the task body I don't need the mut
[14:45:45] <strcat> does get use &mut self?
[14:46:48] *** Joins: igl (igl@moz-EA8DFE94.adsl.alicedsl.de)
[14:47:25] <bstrie> strcat: it does, though I don't quite understand why, or why this error only happens if we close over something
[14:48:41] *** Quits: KindOne (KindOne@moz-8CE6B5D8.dynamic.ip.windstream.net) (Ping timeout)
[14:51:36] *** Joins: KindOne (KindOne@moz-16B21875.dynamic.ip.windstream.net)
[14:52:17] <strcat> rusti: unsafe fn segfault() { libc::abort() } unsafe { segfault() }
[14:52:18] -rusti- application terminated with signal 11 (Segmentation fault)
[14:52:27] *** Quits: teratorn (teratorn@moz-5363C32C.teratorn.org) (Quit: Absum!)
[14:52:54] *** Joins: infynyxx (infynyxx@moz-E95B370B.nyc.res.rr.com)
[14:53:02] *** Joins: teratorn (teratorn@moz-5363C32C.teratorn.org)
[14:53:34] *** Joins: cowboyd (cowboyd@1D8844A7.1B729417.CEE440B6.IP)
[14:53:57] <bstrie> nmatsakis: at least in the case of future!(), this does require either making macros importable or moving that module into libstd
[14:53:58] *** Joins: Yurume (yurume@AC58A8CE.8A059B47.E313B915.IP)
[14:54:13] <bstrie> the former would be dreamy
[14:54:14] <benh_> (oh no, i just saw an explicit destructor call in C++ and it looked like someone was constructing an object into a unique box for a moment...)
[14:54:37] *** Quits: infynyxx (infynyxx@moz-E95B370B.nyc.res.rr.com) (Ping timeout)
[14:55:03] <strcat> benh_: :)
[14:55:24] <nmatsakis> bstrie: oh yes, I am just assuming that will happen
[14:55:37] <nmatsakis> bstrie: I...can't imagine that anybody doesn't want that? I don't know what makes it hard though :)
[14:56:03] <bstrie> nmatsakis: so basically the ideal result would be used like https://gist.github.com/bstrie/5678380 ?
[14:56:11] <benh_> What does it mean that macros aren't importable right now?
[14:56:49] <bstrie> benh_: if you define a macro in a module, nothing outside that module can reference it
[14:57:06] <nmatsakis> bstrie: right.
[14:57:14] *** Joins: azita (Azita@moz-C1FB2A8.hsd1.ca.comcast.net)
[14:57:14] <nmatsakis> bstrie: not half bad, I think.
[14:57:20] <bstrie> benh_: there's currently a terrible hack where every "built-in" macro is actually appended to every source file :\
[14:57:33] * nmatsakis weeps
[14:57:34] <bstrie> at least as far as I remember
[14:58:11] *** Joins: dylukes (dylukes@moz-B5418F79.hsd1.pa.comcast.net)
[14:58:14] <benh_> Is this about syntax extensions versus user-defined macros, or does built-in mean "in libstd"?
[14:58:29] <bstrie> benh_: both
[14:59:33] <friggle> bstrie: the 'prelude'?
[15:00:16] <bstrie> at some point both the questions and answers became ambiguous, please clarify :)
[15:00:43] <bstrie> I don't actually know if the "append macro definition to every source file" applies to syntax extensions like fmt!(), because those aren't normal macro definitions anyway
[15:00:59] <SiegeLord> So how does one define a closure that copies a variable under this proposal?
[15:01:00] *** Quits: KindOne (KindOne@moz-16B21875.dynamic.ip.windstream.net) (Ping timeout)
[15:01:12] <bstrie> I do know that if you currently want to expose any "true" macro like `condition!()`, it must be hardcoded into the compiler itself
[15:01:18] <SiegeLord> Outside of the ideas behind spawn etc
[15:01:23] *** Quits: azita (Azita@moz-C1FB2A8.hsd1.ca.comcast.net) (Quit: azita)
[15:02:01] <nmatsakis> SiegeLord: you can just use task!
[15:02:05] <nmatsakis> SiegeLord: that's actually generic
[15:02:11] <nmatsakis> SiegeLord: might want a better name fo rit
[15:02:30] <benh_> I heard "copy" is free now
[15:02:46] <nmatsakis> SiegeLord: I guess it's not entirely generic in that it's a closure that can only be called once, the way I defined it,
[15:02:53] <nmatsakis> SiegeLord: but we could have a similar version for closures that can be called multiple times,
[15:03:04] <SiegeLord> What is the type of task! ?
[15:03:15] *** Quits: jdm (jdm@CAB30FBD.8F96AEA7.2D179A7D.IP) (Quit: Lost terminal)
[15:03:17] <benh_> "macro"
[15:03:20] <nmatsakis> it yields a TaskStruct<A,R> where R is the return type and A is the type of the arguments
[15:03:21] <SiegeLord> And how would I write it in the return type?
[15:03:27] <bstrie> nmatsakis: `spawn!(x.clone() => x)` would work, right?
[15:03:35] <nmatsakis> SiegeLord: the macro is setup in such a way as to infer the return type.
[15:03:50] <nmatsakis> bstrie: well... we could make it work :)
[15:03:50] <SiegeLord> I mean like I can do this now: fn test()->~fn()->int
[15:03:58] <SiegeLord> What would I write as the return type there?
[15:04:04] <nmatsakis> SiegeLord: in that case, you would probably do : fn test() -> ~Task<int>
[15:04:21] <SiegeLord> But I don't see A there...
[15:04:21] *** Quits: dylukes (dylukes@moz-B5418F79.hsd1.pa.comcast.net) (Quit: ["Textual IRC Client: www.textualapp.com"])
[15:04:23] <nmatsakis> SiegeLord: Task being the trait that I was using to gene
[15:04:26] <nmatsakis> sorry
[15:04:29] <nmatsakis> SiegeLord: yes, exactly
[15:04:37] <nmatsakis> SiegeLord: that's because Task<R> is the generic  trait for a closure,
[15:04:38] <bstrie> nmatsakis: it looks like it would expand to `spawn((x.clone()), |x| { x })` which looks sane to me
[15:04:44] <nmatsakis> SiegeLord: it hides the environment, which is what A represents,
[15:04:50] <nmatsakis> SiegeLord: TaskStruct<A,R> is the actual implementation
[15:05:09] <nmatsakis> bstrie: yes, that's how you would handle it
[15:05:10] <bstrie> but I'm not taking into account the Task stuff
[15:05:21] <nmatsakis> bstrie:  you might do something similar to permit borrowed pointers (not for tasks, but for other cases)
[15:05:34] <nmatsakis> bstrie: basically expanding to (&x, &y), |x, y| { ... }
[15:05:38] *** Quits: erickt (erickt@8C9ECD8F.3A598286.F12515B4.IP) (Quit: Leaving.)
[15:05:53] <SiegeLord> I see... huh
[15:06:39] <nmatsakis> SiegeLord: closure types and object types are very similar, that's what I'm taking advantage of here
[15:06:48] <nmatsakis> SiegeLord: I see objects as a generalization of closure types, but others see the relation differently :)
[15:07:16] *** Joins: thou (thou@moz-1C1CA9F7.fasttrackcomm.net)
[15:07:29] <nmatsakis> I think we'd probably not want to call it task
[15:07:30] <nmatsakis> but rather RunOnce
[15:07:33] <nmatsakis> and RunMany
[15:07:34] <nmatsakis> or something like that
[15:07:46] <nmatsakis> so @fn() would be translated to @RunMany
[15:07:56] <nmatsakis> ~fn() in a task is best translated to ~RunOnce:Send
[15:08:22] <nmatsakis> if you did it like that, then you can model a once fn that borrows as
[15:08:27] <nmatsakis> `&RunOnce`
[15:08:33] <nmatsakis> benh_: ^
[15:08:48] <benh_> Right :)
[15:08:48] <nmatsakis> oh, wait
[15:08:53] <nmatsakis> that almost works but not quite :)
[15:09:02] <nmatsakis> it'd have to be ~RunOnce
[15:09:06] <nmatsakis> but you can still borrow variables
[15:09:18] <nmatsakis> the problem is that the run function on run once consumes the receiver
[15:09:23] <nmatsakis> so & and &mut won't work
[15:09:40] <nmatsakis> I knew there was a problem I ran into when I tried to model it before
[15:10:51] <SiegeLord> Can you have ~RunMany?
[15:11:24] <nmatsakis> sure
[15:11:43] <nmatsakis> the key difference is that RunMany defines `fn run(&self)` or perhaps `fn run(&mut self)`
[15:11:53] <nmatsakis> whereas RunOnce defines `fn run(self)`
[15:12:06] <nmatsakis> probably you want `&mut self`, so that RunMany can modify its environment,
[15:12:12] <nmatsakis> but that is a capability we don't grant today
[15:12:24] <nmatsakis> but that leads to hacks like cell
[15:12:42] <nmatsakis> hmm, there is one complication with RunMany
[15:12:55] <nmatsakis> I guess that to make a macro version, the translation would be a bit trickier,
[15:13:04] <nmatsakis> though not impossible,
[15:13:11] <nmatsakis> you'd want to convert a reference to `x` to `self.x`
[15:13:22] *** Quits: ksev (DrunkenPan@745B767B.989A61DC.CA5B6332.IP) (Ping timeout)
[15:13:25] <nmatsakis> I have to discuss this with a macrologist
[15:13:28] <nmatsakis> pauls: !
[15:13:37] <nmatsakis> you could always do it as a syntax extension though
[15:13:41] *** Joins: deepdog (deepdog@moz-490E834C.client.mchsi.com)
[15:13:43] <benh_> Is "!" the summoning spell for macrologists? ;)
[15:13:54] <nmatsakis> :)
[15:15:57] *** Joins: jeff (jeff@4231C034.745B261B.F12515B4.IP)
[15:16:04] *** Quits: jeff (jeff@4231C034.745B261B.F12515B4.IP) (Quit: jeff)
[15:16:44] <deepdog> Hey guys. I'm trying to build rust/incoming but my laptop overheats and shutsdown during the process. Any recommendations to build it?
[15:17:08] <deepdog> I'm thinking of building it on a VPS and then downloading it since Make shouldn't recompile source files that haven't changed. Would that be viable?
[15:17:55] *** Quits: FrozenCow (FrozenCow@moz-9DF5D010.dynamic.upc.nl) (Ping timeout)
[15:21:28] *** Quits: aruniiird (arun@84E199D6.DCDBCF8E.83D0DF30.IP) (Ping timeout)
[15:21:33] *** Quits: bjz (brendanzab@B398BE78.F804C29E.D35A31DF.IP) (Connection reset by peer)
[15:21:38] *** Joins: bjz (brendanzab@B398BE78.F804C29E.D35A31DF.IP)
[15:21:41] <spider-mario> deepdog: what OS do you use?
[15:21:43] <pnkfelix> deepdog: silly question: have you tried avoiding the overheating by e.g. using "make -j1" instead of "make -jN" for K > 1?  (Or are you already doing that?
[15:21:48] <SiegeLord> I'd try fixing the laptop first... (or reduce the maximum CPU frequency as a workabout)
[15:22:06] <strcat> yes, clean out the fan/heatsink
[15:22:52] <benh_> used to be that nice'ing a process made the cpu not spin up on its account, but I guess that doesn't work anymore
[15:23:01] *** Joins: erickt (erickt@8C9ECD8F.3A598286.F12515B4.IP)
[15:23:04] <deepdog> spider-mario: I use Arch Linux (x86_64)
[15:23:07] *** Joins: MaikKlein (maik@moz-340073FA.dip0.t-ipconnect.de)
[15:23:16] <deepdog> pnkfelix: No. I haven't tried that yet.
[15:23:16] <spider-mario> ok
[15:23:27] <deepdog> strcat: I did that last week as part of regular maintenance.
[15:23:29] <spider-mario> do you really want incoming? there is 0.6 in the official repos.
[15:23:48] <benh_> you tend to really want incoming though :(
[15:23:53] <pnkfelix> deepdog: to be honest if you're already not using the '-j' flag then the build might already be doing sequentially.  Not sure.
[15:23:57] *** Joins: ksev (DrunkenPan@745B767B.989A61DC.CA5B6332.IP)
[15:23:58] <strcat> spider-mario: there are daily builds of incoming
[15:24:00] <strcat> deepdog: ^
[15:24:04] <spider-mario> oh
[15:24:06] <strcat> [thestinger]
[15:24:08] <strcat> SigLevel = Optional
[15:24:10] <strcat> Server = http://pkgbuild.com/~thestinger/repo/$arch
[15:24:22] * strcat added a cronjob on arch's build server
[15:24:45] <deepdog> strcat: Thanks for sharing that. But I was interested in helping contribute to Rust.
[15:25:02] <strcat> deepdog: ah
[15:25:09] *** Joins: Jesin (Jessin_@moz-3AD6F09F.res.lehigh.edu)
[15:25:29] <deepdog> I'm going to see how far I can get with -n1. Thanks guys.
[15:25:55] *** Quits: MaikKlein (maik@moz-340073FA.dip0.t-ipconnect.de) (Ping timeout)
[15:26:17] <spider-mario> you could monitor your laptopâ€™s temperature, and ^Z when it gets too high, to let it cool down
[15:26:23] <spider-mario> and then resume with `fg`
[15:26:41] <xazax> well
[15:27:08] <deepdog> spider-mario: That's a good suggestion. Thanks.
[15:27:15] <bstrie> this is a very amusing conversation
[15:27:46] <benh_> I've done that ^Z/fg thing a few times :)
[15:27:51] <xazax> sounds very cumbersome, trying to limit your cpu freq sounds more reasonable to me
[15:28:38] <benh_> Other embarassing concessions to the limitations of laptops include a laptop stand with usb powered external fans
[15:28:57] <strcat> new-ish generations of cpus know how to throttle themselves down if they start reaching high temps so I don't think they should actually be shutting down unless something horrific like the fan dying happens
[15:29:05] <jaen> Wait, arch packages for incoming?
[15:29:09] <strcat> jaen: yes
[15:29:11] <strcat> daily build
[15:29:18] <jaen> That's sooo nice, I won't have to build it on my own anymore <3
[15:29:20] <strcat> at ~8pm EST or something
[15:29:47] <benh_> There's bots building every single merge commit to incoming anyway, isn't it
[15:29:47] <jaen> at least for now
[15:30:12] <strcat> benh_: yes but on the ubuntu LTS against an old glibc/libgcc/libstdc++
[15:30:16] *** Joins: snearch (snearch@moz-1D5B13B7.pool.mediaways.net)
[15:30:47] <benh_> ah
[15:30:51] <benh_> gosh, why is software so hard
[15:30:59] *** benh_ is now known as benh
[15:31:01] <bstrie> deepdog: the fact that your laptop shuts off because of heat is quite worrying in its own right :) that hasn't happened to me since I tried playing halo on my first-gen XPS (which was a PC in a hulking laptop case) on a desk with no ventilation
[15:31:59] <benh> Even if it wasn't literally shutting off, there's something to be said for working on a keyboard that doesn't boil the sweat on your fingers
[15:32:00] <strcat> jaen: and in theory it even uses delta updates but.... it rarely succeeds in making a delta smaller than the pkg size :(
[15:32:10] <strcat> rustc randomizes too much stuff
[15:32:26] <deepdog> bstrie: It's an older laptop. Dell, not very good quality sadly. =(
[15:32:46] <bstrie> benh: I don't know about fingers, but my XPS maybe have permanently sterilized me :)
[15:32:52] <jaen> I don't mind as long as I can stave off frequent compiling until I get around to contributing ; p
[15:34:00] <benh> do as I do and only contribute to rustdoc, the end of the dependency chain that doesn't require recompilations of anything else ;)
[15:34:31] *** Joins: ssbr (ssbr@A9D9D38C.B6F034AC.72A31D6.IP)
[15:35:05] <jaen> benh: this is one way to go about it ; D
[15:35:16] *** Joins: MaikKlein (maik@moz-340073FA.dip0.t-ipconnect.de)
[15:35:35] <deepdog> benh: That's my backup plan. =P
[15:35:54] *** Joins: aruniiird (arun@moz-3DB73AA5.azulsystems.com)
[15:36:00] *** Joins: tiffnya (kawaii@moz-1E0FE6E8.dhcp.embarqhsd.net)
[15:36:03] <benh> bstrie: I do hope we don't end up throwing out line doc comments by the way :(
[15:37:45] *** Joins: BigEndian (hurp@moz-1B6DD81E.members.linode.com)
[15:38:21] <bstrie> benh: we'll have to throw out normal line comments too, for feature parity
[15:39:43] <benh> maybe the cleanest way here is to require the explicit #[comment=""] form for all comments
[15:40:10] <bstrie> I agree. though comments should be attached to the module rather than to any given item, so it would be #[comment=""];
[15:40:19] <benh> true
[15:41:15] <benh> anyway, one step on the road towards making rust homoiconic
[15:41:21] <nmatsakis> strcat: I think with some minor changes to the borrow checker rules (which I want for other reasons) we can guarantee that the only alias to an `&mut` comes via an `@mut` or an `&const`
[15:41:33] <nmatsakis> strcat: no other weird aliases, e.g. via closures etc
[15:41:47] <strcat> nmatsakis: it would be too hard to check for closures in the meantime anyway
[15:41:51] <benh> &const isn't going away?
[15:41:59] <strcat> wouldn't be*
[15:42:01] * strcat sighs
[15:42:10] <nmatsakis> benh: it probably is
[15:42:14] <strcat> the worst typos are the ones reversing the meaning of the whole sentence ;p
[15:42:21] <nmatsakis> strcat: well, I should amend that: closures can hide &const aliases,
[15:42:27] <nmatsakis> strcat: unless they have a bound that says otherwise
[15:42:32] <nmatsakis> strcat: also objects
[15:42:47] <nmatsakis> strcat: (and of course @mut as well)
[15:42:51] <strcat> nmatsakis: hm, you can go &const to an object somehow?
[15:43:06] <nmatsakis> strcat: in both cases, I mean that the &const/@mut can occur in the environment
[15:43:11] <strcat> nmatsakis: an actual TBAA pass would make this much saner
[15:43:12] <nmatsakis> strcat: or the Self type
[15:43:18] <strcat> since we only have to reply for 2 specific pointers
[15:43:20] <nmatsakis> strcat: whose types you don't know
[15:43:24] <nmatsakis> yes.
[15:43:40] <nmatsakis> then we could of course even try to get smarter later and consider things like &Foo and &Bar
[15:43:46] <nmatsakis> since we are you know type safe and all
[15:44:05] <strcat> I looked into why noalias exists at all, and it seems to be so -fno-strict-aliasing can exist without making 'restrict' useless
[15:44:14] <strcat> but it's still a nice easy way to do it in some cases
[15:45:30] <strcat> nmatsakis: we could say &T has to point at memory with the size/alignment of T
[15:46:01] <strcat> so &T and &U can only alias if their size/alignment is the same
[15:46:08] <strcat> anyway you'd have to use unsafe code to make them but...
[15:46:15] <strcat> it seems like a sort of valid use case? dunno
[15:46:29] *** Joins: jdm (jdm@F2D29657.F60B0462.67AC9B1.IP)
[15:48:24] <strcat> nmatsakis: &T and &U are NoAlias in LLVM terms even if they point to the same thing anyway, if they actually can't be used to write (so non-Const)
[15:48:45] <strcat> not non-Const*
[15:49:36] <nmatsakis> strcat: hmm maybe it's a moot-point 
[15:49:43] <nmatsakis> strcat: since &mut gives stronger guarantees on its own
[15:49:46] <nmatsakis> strcat: interesting.
[15:49:51] <bstrie> it's a mut point
[15:50:18] <bstrie> alternatively, it's a moot-pointer
[15:50:52] *** Joins: devinus (devinus@moz-B4AF84BC.ptr.us.xo.net)
[15:51:24] *** Quits: devinus (devinus@moz-B4AF84BC.ptr.us.xo.net) (Quit: Textual IRC Client: www.textualapp.com)
[15:51:43] <pauls> nmatsakis: it took a while for the spell to summon me, but here I am
[15:51:44] *** Joins: devinus (devinus@moz-B4AF84BC.ptr.us.xo.net)
[15:52:53] <nmatsakis> pauls: is it possible to write a macro like `foo(x => ...)` where instances of `x` are replaced in `...` with `self.x`?
[15:52:58] <nmatsakis> pauls: or would this require a syntax extension?
[15:53:05] <nmatsakis> pauls: I presume it is not possible
[15:53:18] <nmatsakis> pauls: but my grasp of what can and can't be done with macros is pretty...sketchy.
[15:53:58] <nmatsakis> pauls: that is, imagine I want to write "foo!(x, y => (a, x, y))" and get back "(a, this.x, this.y)"
[15:54:08] <pauls> nmatsakis: you mean, like `($(self.$x),*)` to produce `(self.a, self.b, self.c)`, if `x` got those idents?
[15:54:30] <nmatsakis> I don't know, I don't think that's what I mean
[15:54:37] <pauls> Oh, I see, a list of idents to hunt down and replace?
[15:54:41] <nmatsakis> basically yes
[15:55:08] <pauls> So you'd call it something like `selfize_these!`
[15:55:41] <nmatsakis> sure.
[15:55:47] <pauls> Yeah, I think that you'd need a syntax extension.
[15:55:48] *** Quits: erickt (erickt@8C9ECD8F.3A598286.F12515B4.IP) (Quit: Leaving.)
[15:55:50] <nmatsakis> ok
[15:56:05] <nmatsakis> I figured so :)
[15:56:26] <pauls> You could possibly *technically* do it in `macro_rules!`, but I think you'd need to rewrite the whole Rust grammar in pattern-matching rules to do it.
[15:57:40] *** Joins: erickt (erickt@8C9ECD8F.3A598286.F12515B4.IP)
[15:58:09] *** Quits: xazax (Mibbit@6655692F.3B222813.3F580572.IP) (Quit: http://www.mibbit.com ajax IRC Client)
[15:58:44] <nmatsakis> pauls: yeah, probably a non-starter, especially given the limited lookahead of our parser ;)
[15:58:48] <nmatsakis> pauls: our macro parser I mean
[15:58:57] <pauls> The technique of hunting down innocent names and replacing them is sometimes considered sketchy. (in part, because the Dybvig hygiene algorithm doesn't help you when you have a lambda that rebinds `x`) But that doesn't mean it's not the thing to do here.
[15:59:43] *** Joins: jack (jack@2557E599.66715431.D25A875A.IP)
[15:59:48] <nmatsakis> pauls: yeah, I know it's kind of sketchy. I was just thinking about what you would need to make a macro that generates a trait that acts like a 're-invokable' closure.
[16:00:16] <nmatsakis> pauls: that is, in a closure, when you refer to an upvar `x`, you are in fact doing something like "environment.x"
[16:00:28] <nmatsakis> pauls: so here the `self` that i'd be inserting would be the environment
[16:00:31] <strcat> nmatsakis: that sounds like what lambdas are in C++ ;p
[16:01:28] <strcat> [capture1, capture2](int x, int y) { ... } essentially just becomes a struct with operator() overloaded for (int, int) and fields for the captures
[16:02:04] <strcat> and each lambda has a unique type (with no common type, arguments have to box them in std::function on the heap or take a generic param)
[16:02:58] <strcat> nmatsakis: could have a Callable trait for overloading the foo() syntax ;p
[16:04:31] <strcat> I guess you still have the problem of how to define it...
[16:05:45] <strcat> nmatsakis: so right now, &fn vs extern "Rust" fn is essentially the same thing with and without an env ptr?
[16:06:12] <nmatsakis> strcat: yes, the C++ syntax is very similar to what I talked about.
[16:06:30] <nmatsakis> strcat: yes, they are the same thing.
[16:06:34] <nmatsakis> strcat: but for the env poitner
[16:06:37] <nmatsakis> *pointer
[16:08:53] *** Joins: indirect (indirect@moz-7E1FC85.ppp.asahi-net.or.jp)
[16:10:55] *** Joins: eholk (eholk@moz-3D703D55.uconnect.utah.edu)
[16:11:35] <pnkfelix> nmatsakis: ping
[16:12:23] <pnkfelix> nmatsakis: nm.  (your blog post answered my Q.  Specifically, second paragraph of "Just write &mut fn()" in "Mutable fn alternatives"
[16:12:59] *** Joins: infynyxx (infynyxx@moz-E95B370B.nyc.res.rr.com)
[16:14:12] <nmatsakis> pnkfelix: glad to be of service.
[16:14:46] *** Quits: z0w0 (zack@moz-3E4BFDF8.qld.bigpond.net.au) (Quit: Leaving.)
[16:15:26] <pnkfelix> nmatsakis: I'm trying to play catch up with the flurry of proposals that you made while I was gone.  (Part of my mind is reeling, saying "Wait, what was the problem again?  Why can't we just differentiate closures that mutate their env from ones that dont...)
[16:15:53] <pnkfelix> nmatsakis: thus the second paragraph I mentioned above.  (But part of me still wonders if then the mistake is somewhere in the DST proposal)
[16:16:26] <nmatsakis> pnkfelix: I...think there is no mistake, really, it's just that the syntax for things that mutate is tedious.
[16:16:38] <nmatsakis> pnkfelix: so another fix would be to add another sigil, say %, and write %fn instead of &mut fn
[16:17:13] <nmatsakis> pnkfelix: or just bite the bullet and write &mut fn I guess
[16:17:20] <nmatsakis> pnkfelix: but honestly I think the closure types are a mess
[16:17:35] *** Joins: victorporof (victorporo@4BF3ADAA.4D5984FA.4A6B528C.IP)
[16:17:42] <nmatsakis> pnkfelix: overly complicated, too many bells and whistles and different options
[16:17:46] <pnkfelix> nmatsakis: â€¦ part of my issue is that half of the posts make it sound like this is a syntactic problem (e.g. "oh we'll just move the sigil") , and the other half make it sound like its a semantic one ("need to change the static semantics rules")
[16:17:50] <pnkfelix> nmatsakis: so I'm still digesting
[16:18:00] *** Joins: graydon (graydon@3853DDD.39EEDBB3.D758B1AA.IP)
[16:18:00] *** ChanServ sets mode: +qo graydon graydon
[16:18:00] <nmatsakis> pnkfelix: yes, it's...complicated
[16:18:14] <friggle> pnkfelix: aren't those really just two different ways of dealing with complexity?
[16:18:16] <nmatsakis> pnkfelix: but 'just move the sigil' hides a very big semantic change
[16:18:28] <pnkfelix> nmatsakis: it could well be that the problem is indeed both, in the sense that the same syntax is being used to denote very different semantic entities
[16:18:28] <friggle> either simplify semantics or hide it in syntax
[16:18:32] <nmatsakis> pnkfelix: that is, ~fn and fn~ look similar but are not all equivalent, which is precisely what DST is trying to solve
[16:18:37] <pnkfelix> nmatsakis: and thus the confusion
[16:19:27] <nmatsakis> pnkfelix: but you got to admit, getting down to 2 relatively simple fn types seems like progress
[16:19:50] <strcat> nmatsakis: btw extern fn really needs a lifetime
[16:19:51] <nmatsakis> pnkfelix: one "with environment" (and some bounds on that environment), one "without environment"
[16:19:53] <strcat> I forget if I reported that
[16:19:55] <nmatsakis> strcat: why?
[16:19:55] <pnkfelix> nmatsakis: maybe.  I'm not too thrilled about having to list out an explicit environment
[16:19:59] <strcat> nmatsakis: for dlopen
[16:20:13] <pnkfelix> nmatsakis: but maybe one of the proposals gets rid of that.
[16:20:14] <strcat> nmatsakis: the symbols can go out of scope
[16:20:14] <nmatsakis> pnkfelix: oh, I actually see that as a bonus
[16:20:33] <strcat> nmatsakis: so everything right now would just be &'static extern fn? I guess
[16:20:39] <nmatsakis> pnkfelix: but you could work around it with a sufficiently intelligent macro
[16:20:45] <nmatsakis> strcat: maybe I don't understand how dlopen works
[16:20:50] <nmatsakis> strcat: I've never actually used it myself :)
[16:21:02] <nmatsakis> strcat: so once you open a DLL, it can get closed too?
[16:21:06] <strcat> nmatsakis: yeah
[16:21:08] <strcat> there's dlclose
[16:21:21] <nmatsakis> strcat: Hmm, well, it's not hard to add a lifetime that defaults to 'static
[16:21:23] <strcat> I'm not sure what happens with conflicting symbols
[16:21:37] <strcat> it would be nice if we could have a safe dlopen though
[16:21:49] <strcat> I'll have to look into it more
[16:21:51] *** Joins: cscottnet (cscott@moz-2577C94A.net)
[16:21:58] <pnkfelix> strcat: what do you mean conflicting symbols?  Doesn't dlsym take the handle returned by dlopen ?
[16:22:00] *** cscottnet is now known as cscott
[16:22:03] *** Quits: robertknight (robertknig@moz-54528EE0.wby.mendeley.com) (Quit: Computer has gone to sleep.)
[16:22:05] *** Joins: jclements (jclements@2557E599.66715431.D25A875A.IP)
[16:22:11] <strcat> pnkfelix: ah, right
[16:22:32] <strcat> nmatsakis: so yeah I think it just gives you function pointers tied to the lifetime of the dynamically loaded dll
[16:22:43] <nmatsakis> strcat: sigh. ok. :)
[16:23:14] *** Quits: bytbox (s@moz-D83E9B31.wireless.umd.edu) (Ping timeout)
[16:23:23] <nmatsakis> I'm wondering if we could/should solve that with a wrapper type, but probably not.
[16:23:26] <cscott> pnkfelix is here ;)
[16:23:43] <pnkfelix> cscott: hey there scott!  long time.
[16:24:07] <nmatsakis> graydon: is the triage meeting at 13 or 12:30?
[16:24:11] <nmatsakis> graydon: (my time)
[16:24:16] <graydon> 12:30 your time
[16:24:18] <cscott> your ears should have been burning last friday; it seems everyone i met at mozilla mentioned you ;)
[16:24:19] <strcat> nmatsakis: it's vaguely related to the PR adding dynamically loadable syntax exts
[16:24:19] <graydon> 8 minutes from now
[16:24:26] <pnkfelix> cscott: if you can give me an inside source for the XO 1.75 replacement boards, I'd be psyched.  :)
[16:24:32] <heftig> nmatsakis: I dislike the name of "extern fn" for raw function pointers.
[16:24:34] <nmatsakis> graydon: ok, that's what I thought.
[16:24:54] <cscott> pnfelix: i can probably do that.  i might even be able to hook you up with an XO-4.
[16:25:05] <strcat> nmatsakis: I'm not sure if there's a subset of the functionality that could be considered safe though. since you're loading an arbitrary lib
[16:25:15] <graydon> strcat: you may also want some mechanism for reflecting on the type-mangled name of a typed symbol. otherwise this "safe" dlopen is not typesafe.
[16:25:16] <strcat> but the load call could be considered unsafe
[16:25:28] <graydon> but honestly one can only go so far with this dlopen game. it will always offer potential for havoc.
[16:25:30] <pnkfelix> cscott: cool, I'll drop you a line about it.  (The G1G1 XO-1's unfortunately cannot run the snapshot rustc)
[16:25:35] <strcat> graydon: well basically I see it as being an unsafe bit under the hood
[16:25:36] <heftig> nmatsakis: is it possible to make proc(S) -> T closures and fn(S) -> T raw function pointers?
[16:25:44] <strcat> graydon: and passing you a known type extern fn
[16:25:51] <strcat> the loading part could be unsafe
[16:25:54] <strcat> atm you can't draw a boundary
[16:25:55] *** Joins: Jeaye (Jeaye@moz-FD505E54.hsd1.ca.comcast.net)
[16:25:57] <graydon> including the type?
[16:26:03] <strcat> graydon: yes, I guess so
[16:26:06] <nmatsakis> heftig: sure, or perhaps just `closure(S) -> T`
[16:26:33] <nmatsakis> heftig: that's actually...kind of nice, in that you could say that you write `extern "ABI" fn` if you want to specify ABI, or `fn` for Rust
[16:26:49] <strcat> graydon: if you're loading from a trusted location it seems fine (in the same way you don't bother worrying about someone swapping out libstd)
[16:27:09] <cscott> pnkfelix: XO-1.75 and XO-4 are all arm.  XO-1.5 was the best x86-compatible XO.  but i look forward to your email.  @mit still works, among other options.
[16:27:24] <heftig> nmatsakis: that does seem nicer
[16:28:00] <nmatsakis> heftig: yeah, I think I'd prefer it
[16:28:11] *** Quits: pnkfelix (pnkfelix@moz-801E009D.vlan502.asr1.cdg2.gblx.net) (Ping timeout)
[16:29:34] *** Joins: pnkfelix (pnkfelix@moz-801E009D.vlan502.asr1.cdg2.gblx.net)
[16:29:38] *** Quits: deepdog (deepdog@moz-490E834C.client.mchsi.com) (Ping timeout)
[16:30:14] <benh> (... and @mit looked like a @mut typo for a bit. argh!)
[16:30:27] *** Quits: novabyte (Instantbir@91FFDEC6.3F2319E2.EFEA2F8E.IP) (Quit: bye bye)
[16:31:10] <nmatsakis> heftig: maybe I'll write it up as a "addendum" post. only downside is that `closure(T)` is what you *normally* want, and it's the longer of the two...
[16:32:13] *** Quits: erickt (erickt@8C9ECD8F.3A598286.F12515B4.IP) (Quit: Leaving.)
[16:32:42] *** Joins: tjc (tjc@moz-E0677B46.vc.shawcable.net)
[16:32:42] *** ChanServ sets mode: +o tjc
[16:32:53] <pnkfelix> nmatsakis: I think my distaste for explicitly listing the closed-over environment stems from a philosophy of "if you want object (record+method), why didn't you make one?"  But its probably just Lisp bigotry
[16:33:38] *** Quits: devinus (devinus@moz-B4AF84BC.ptr.us.xo.net) (Quit: Computer has gone to sleep.)
[16:33:58] *** Joins: devinus (devinus@moz-B4AF84BC.ptr.us.xo.net)
[16:34:05] <heftig> nmatsakis: "proc" isn't that bad
[16:34:13] *** Joins: erickt (erickt@8C9ECD8F.3A598286.F12515B4.IP)
[16:35:06] *** Joins: erickt1 (erickt@8C9ECD8F.3A598286.F12515B4.IP)
[16:35:55] *** Quits: erickt (erickt@8C9ECD8F.3A598286.F12515B4.IP) (Ping timeout)
[16:36:20] *** Quits: devinus (devinus@moz-B4AF84BC.ptr.us.xo.net) (Quit: Computer has gone to sleep.)
[16:36:41] <strcat> graydon: looks like incoming is broken on 32-bit from the bots :(
[16:37:05] *** Joins: dmart (Mibbit@moz-A103DCA.cg.shawcable.net)
[16:37:09] <pnkfelix> triagers: join #rust-triage
[16:37:18] <strcat> and I can't figure out why aatch's latest iteration on the optimization pass stuff won't land... hits some weird resolve stuff
[16:37:19] *** Joins: Jesse (jruderman@moz-537BCF9.hsd1.ca.comcast.net)
[16:37:27] <bstrie> nmatsakis: http://www.reddit.com/r/rust/comments/1fc4d9/removing_procs/ca8uunw
[16:37:30] <heftig> or maybe "fn%" for closures
[16:39:53] <bblum> fn% o_O
[16:40:02] <bblum> huh, % isn't a used sigil in rust yet, is it?
[16:41:49] *** Joins: pcwalton (pcwalton@43CB6079.66715431.D25A875A.IP)
[16:41:49] *** ChanServ sets mode: +o pcwalton
[16:42:25] <strcat> bblum: rem
[16:42:56] *** Joins: bytbox (s@moz-D83E9B31.wireless.umd.edu)
[16:42:59] <bblum> oh yeah.
[16:43:15] <strcat> bblum: backticks.
[16:43:18] <strcat> ;p
[16:43:30] <bblum> backticks aren't used you mean?
[16:43:33] <strcat> bblum: yeah
[16:43:36] <bblum> c.c
[16:43:57] <strcat> and I guess backslash isn't used
[16:44:08] <strcat> and question marks
[16:44:09] <bblum> well, \ is used, but \\ is not used
[16:44:28] <bblum> haha i remember someone suggested using question marks during the macro sigil debate last summer
[16:44:37] <bblum> assert?(...)
[16:45:17] *** Joins: eatkinson (eatkinson@2557E599.66715431.D25A875A.IP)
[16:45:35] *** Joins: brson (brson@2557E599.66715431.D25A875A.IP)
[16:45:35] *** ChanServ sets mode: +o brson
[16:45:37] <strcat> or we could just allow them in identifiers. and have cute foo.empty? and !foo.empty? like ruby ;p
[16:46:11] *** Joins: azita (Azita@2557E599.66715431.D25A875A.IP)
[16:46:42] *** Joins: bent (chatzilla@moz-932324BF.hsd1.ca.comcast.net)
[16:47:13] <strcat> rusti: foo`
[16:47:13] -rusti- foo.rs:8:9: 8:12 error: unknown start of token: 96
[16:47:13] -rusti- foo.rs:8          foo`
[16:47:13] -rusti-                   ^~~
[16:47:13] -rusti- application terminated with error code 101
[16:47:37] <strcat> acrichto: ^ related to that thing you reported
[16:48:07] <acrichto> strcat: oh maybe this is just a general lexer/parser bug about locations of errors in general
[16:49:41] <heftig> how are stack closures represented internally?
[16:51:38] <strcat> heftig: well they are 2 ptrs but I'm not sure how the env works
[16:51:45] <strcat> rusti: let x: &fn() -> int = |a, b| 2; let y: (*(), *()) = unsafe { cast::transmute(x) }; y
[16:51:46] -rusti- more than 5 lines of output, pastebinned: http://sprunge.us/VMTa
[16:51:52] <heftig> pointer to the stack frame used, i guess
[16:52:02] <strcat> rusti: let x: &fn(int, int) -> int = |a, b| a + b; let y: (*(), *()) = unsafe { cast::transmute(x) }; y
[16:52:03] -rusti- ((0x40eb70 as *()), (0x7f22082017f0 as *()))
[16:52:18] *** Quits: erickt1 (erickt@8C9ECD8F.3A598286.F12515B4.IP) (Ping timeout)
[16:52:45] <strcat> rusti: let a = 5; let x: &fn(int, int) -> int = |a, b| a + b; let y: (*(), *()) = unsafe { cast::transmute(x) }; (y, &a as *int)
[16:52:46] -rusti- (((0x40ee00 as *()), (0x7fdfc02017e0 as *())), (0x7fdfc0201820 as *()))
[16:53:19] <strcat> heftig: looks that way
[16:53:25] *** Quits: MaikKlein (maik@moz-340073FA.dip0.t-ipconnect.de) (Ping timeout)
[16:54:04] *** Joins: erickt (erickt@8C9ECD8F.3A598286.F12515B4.IP)
[16:57:15] *** Quits: eholk (eholk@moz-3D703D55.uconnect.utah.edu) (Quit: eholk)
[17:00:17] *** Joins: zakora (NC@moz-8EAF945F.fbx.proxad.net)
[17:01:02] *** Joins: hjr3 (hradtke@374E545A.3A8E9B0C.F9D9C60E.IP)
[17:02:31] *** Quits: azita (Azita@2557E599.66715431.D25A875A.IP) (Quit: azita)
[17:02:42] <kimundi> nmatsakis: There is also still the option of 'env fn' for a closure. ;)
[17:04:24] *** Joins: eholk (eholk@moz-3D703D55.uconnect.utah.edu)
[17:04:24] *** Joins: azita (Azita@2557E599.66715431.D25A875A.IP)
[17:05:27] *** Quits: ksev (DrunkenPan@745B767B.989A61DC.CA5B6332.IP) (Ping timeout)
[17:06:07] <jaen> strcat: I second a cute ?
[17:06:22] *** Quits: cowboyd (cowboyd@1D8844A7.1B729417.CEE440B6.IP) (Client exited)
[17:06:24] *** Quits: bnicholson (bnicholson@moz-E98974C1.hsd1.ca.comcast.net) (Ping timeout)
[17:07:15] <kimundi> if is_this_really_happening?!() { ... }
[17:08:13] *** Joins: steven_is_false (user@moz-144077DE.bchsia.telus.net)
[17:08:46] *** Joins: Cromulent (Cromulent@moz-983B638D.cable.virginmedia.com)
[17:08:50] *** Joins: cowboyd (cowboyd@1D8844A7.1B729417.CEE440B6.IP)
[17:09:36] *** Quits: azita (Azita@2557E599.66715431.D25A875A.IP) (Quit: azita)
[17:10:59] <jaen> that's a questionable macro, if you pardon me pun
[17:14:05] *** Joins: azita (Azita@2557E599.66715431.D25A875A.IP)
[17:14:19] *** Joins: devinus (devinus@moz-B4AF84BC.ptr.us.xo.net)
[17:14:51] <SiegeLord> rusti: let mut i = 0; i++
[17:14:52] -rusti- foo.rs:8:26: 8:27 error: unexpected token: `+`
[17:14:52] -rusti- foo.rs:8          let mut i = 0; i++
[17:14:52] -rusti-                                    ^
[17:14:52] -rusti- application terminated with error code 101
[17:15:05] *** Joins: BitPuffin (quassel@moz-8370D1B9.bredband.comhem.se)
[17:16:00] *** Joins: thomaslee (thomaslee@moz-6C3931E3.static.twtelecom.net)
[17:16:30] *** Quits: bent (chatzilla@moz-932324BF.hsd1.ca.comcast.net) (Quit: ChatZilla 0.9.90-rdmsoft [XULRunner 18.0.2/20130201065344])
[17:16:45] *** Quits: BitPuffin (quassel@moz-8370D1B9.bredband.comhem.se) (Ping timeout)
[17:18:14] <steven_is_false> I was thinking, instead of having ~fn : Once Const (etc... it could be better to have fn <Environment> (etc..), and just have fn types implement traits.
[17:18:21] *** Quits: trapni (trapni@moz-6A0EA166.dawanda.com) (Quit: Leaving)
[17:18:25] *** Joins: carllerche (carllerche@6B070D22.7E6A0813.1428D117.IP)
[17:18:36] *** Quits: erickt (erickt@8C9ECD8F.3A598286.F12515B4.IP) (Quit: Leaving.)
[17:18:55] *** Joins: BitPuffin (quassel@moz-8370D1B9.bredband.comhem.se)
[17:19:27] <steven_is_false> spawn would become fn spawn <Env : Send> (~fn <Env> (etc..
[17:19:53] *** Joins: mschifer (Adium@2557E599.66715431.D25A875A.IP)
[17:20:20] <steven_is_false> So what does anybody think of that?
[17:20:44] *** Quits: BitPuffin (quassel@moz-8370D1B9.bredband.comhem.se) (Ping timeout)
[17:20:54] <cmr> steven_is_false: And how would that be implemented?
[17:21:16] <steven_is_false> cmr: Which part is unclear?
[17:21:33] *** Joins: BitPuffin (quassel@moz-8370D1B9.bredband.comhem.se)
[17:21:47] <cmr> steven_is_false: closures implementing traits. traits are vtables. are you suggesting closures be fattened?
[17:23:18] <steven_is_false> cmr: What I meant by that was, impl <Env : Send> Task for ~fn <Env> () { to existentially quantify over the environment variable.
[17:23:23] <kimundi> cmr: Well traits are not vtables...
[17:23:49] <cmr> kimundi: No?
[17:24:07] <kimundi> steven_is_false: The problem, I think is that it's even more verbose than the current syntax
[17:24:08] <steven_is_false> Although, that does gives me the interesting idea of functions automatically implementing one function traits like with C# delegates.
[17:24:27] *** Joins: MaikKlein (maik@moz-340073FA.dip0.t-ipconnect.de)
[17:24:48] <steven_is_false> kimundi: Okay, I thought the main problem was just that there were a bunch of different function types.
[17:24:52] <kimundi> cmr: a @Trait and ~Trait involves a vtable, but that's it
[17:25:01] <strcat> and &Trait
[17:25:07] <strcat> trait bounds are static dispatch
[17:25:32] <kimundi> steven_is_false: Well yeah, but the trait bounds would be there one way or another
[17:25:36] <steven_is_false> kimundi: Right but in the specific case that we're talking about where there is an existential quantification there would be a vtable.
[17:25:37] *** Joins: blitter (blitter@moz-E761A52F.dyn.centurytel.net)
[17:26:22] <steven_is_false> kimundi: Right but fn : Const Send is a special case. fn <Environment> is generic.
[17:26:47] <kimundi> They are both the same
[17:26:54] <kimundi> no?
[17:27:33] <steven_is_false> kimundi: Yes they are only slightly different but I feel one is conceptually cleaner.
[17:27:41] *** Joins: bnicholson (bnicholson@2557E599.66715431.D25A875A.IP)
[17:27:41] *** Quits: azita (Azita@2557E599.66715431.D25A875A.IP) (Quit: azita)
[17:28:02] <kimundi> I mean the only  allowed traits there are going to be Send, Const etc. Don't really neet genericity for that and even then both syntaxes would allow the same expressions
[17:28:32] *** Joins: deepdog (deepdog@moz-490E834C.client.mchsi.com)
[17:29:06] <cmr> Is incoming building for anyone?
[17:29:59] *** Joins: mib_uarodh (Mibbit@CBCAE93A.F5F53E8A.2D6DB75E.IP)
[17:30:13] <steven_is_false> kimundi: Fair enough.
[17:30:14] <doener> 682afcac5200019b363310f56cfabb78edea9397 sucessfully built for me
[17:30:15] *** Quits: mib_uarodh (Mibbit@CBCAE93A.F5F53E8A.2D6DB75E.IP) (Quit: http://www.mibbit.com ajax IRC Client)
[17:30:53] <doener> on Linux x86_64
[17:31:11] <cmr> Weird, it's *not* building for me, on linux x86_64
[17:31:20] <cmr> Trying a clean build..
[17:31:55] <cmr> It's dying on the buildbots too
[17:32:28] *** Quits: tjc (tjc@moz-E0677B46.vc.shawcable.net) (Quit: Places to go, people to annoy)
[17:32:55] *** Joins: pnkfelix1 (pnkfelix@moz-801E009D.vlan502.asr1.cdg2.gblx.net)
[17:33:00] *** Joins: FrozenCow (FrozenCow@moz-9DF5D010.dynamic.upc.nl)
[17:33:35] *** Joins: pnkfelix2 (pnkfelix@moz-801E009D.vlan502.asr1.cdg2.gblx.net)
[17:33:57] *** Quits: pnkfelix1 (pnkfelix@moz-801E009D.vlan502.asr1.cdg2.gblx.net) (Connection reset by peer)
[17:34:09] *** Quits: pnkfelix (pnkfelix@moz-801E009D.vlan502.asr1.cdg2.gblx.net) (Ping timeout)
[17:34:40] *** Joins: caitp (caitp@moz-2E2F18CB.senecacollege.ca)
[17:36:51] <cmr> r? https://github.com/mozilla/rust/pull/6835
[17:39:41] *** Joins: ghrust (ghrust@moz-4EF5B6E5.rs.github.com)
[17:39:41] <ghrust> 01[13rust01] 15bors 04force-pushed 06auto from 1498b9062 to 14682afca: 02http://git.io/N3iJvQ
[17:39:41] *** Parts: ghrust (ghrust@moz-4EF5B6E5.rs.github.com) ()
[17:39:43] *** Joins: ghrust (ghrust@moz-4EF5B6E5.rs.github.com)
[17:39:43] <ghrust> 01[13rust01] 15bors pushed 4 new commits to 06auto: 02http://git.io/-LoMsQ
[17:39:43] <ghrust> 13rust/06auto 14e583d5a 15GÃ¡bor HorvÃ¡th: Minor documentation addition.
[17:39:43] <ghrust> 13rust/06auto 149fd18a9 15GÃ¡bor HorvÃ¡th: Minor style fix.
[17:39:43] <ghrust> 13rust/06auto 140d9ea4e 15GÃ¡bor HorvÃ¡th: Minor grammar fix.
[17:39:44] *** Parts: ghrust (ghrust@moz-4EF5B6E5.rs.github.com) ()
[17:39:49] <EXetoC> https://gist.github.com/EXetoC/c4f10b2b6c9bfc56ff79 am I doing something wrong here? it works if I execute line 7 in the scope where the parameters are declared
[17:40:55] *** Joins: azita (Azita@2557E599.66715431.D25A875A.IP)
[17:41:49] <EXetoC> I encountered this before, also when using RenderData, which is pretty much the only struct that has a lifetime parameter
[17:42:13] <cmr> graydon: can you give the buildbots a kick? they seem to be failing for no good reason
[17:42:20] <cmr> (incoming-full, at least)
[17:42:28] *** Joins: xazax (xazax@moz-D7592A2A.csoma.elte.hu)
[17:42:43] *** Quits: jclements (jclements@2557E599.66715431.D25A875A.IP) (Quit: jclements)
[17:42:44] <strcat> cmr: seems to be legitimately segfaulting
[17:42:58] <strcat> on 32-bit
[17:43:09] <cmr> ah 32-bit
[17:43:30] *** Quits: brson (brson@2557E599.66715431.D25A875A.IP) (Ping timeout)
[17:43:36] *** Joins: brson (brson@2557E599.66715431.D25A875A.IP)
[17:43:36] *** ChanServ sets mode: +o brson
[17:43:49] *** Quits: jrfeenst (jrfeenst@moz-3265BD65.cpe.norwoodlight.com) (Quit: jrfeenst)
[17:44:25] <jaen> Oh, that arch package doesn't come with docs ; /
[17:45:00] <strcat> jaen: I could start building them
[17:45:09] <strcat> needs node.js and haskell-pandoc as makedeps
[17:45:30] <jaen> If that's not a bother it would be awesome, if it is I can still live with that
[17:45:42] <strcat> jaen: yeah it's easy
[17:45:49] <strcat> jaen: I'll just enable it and the build tonight will have them
[17:46:07] *** Joins: jclements (jclements@2557E599.66715431.D25A875A.IP)
[17:46:17] <brson> have a great day, #rust
[17:46:32] <jaen> Nice. It doesn't build the advanced tutorials though, right? At least the aur package didn't by default.
[17:46:44] <strcat> jaen: don't know what it builds
[17:46:50] *** Quits: davbo (dave@moz-3FFA637C.oucs.ox.ac.uk) (Client exited)
[17:47:09] *** Quits: EXetoC (ex@moz-C741B177.customer.t3.se) (Quit: WeeChat 0.4.1)
[17:47:47] *** Quits: victorporof (victorporo@4BF3ADAA.4D5984FA.4A6B528C.IP) (Connection reset by peer)
[17:48:03] *** Quits: azita (Azita@2557E599.66715431.D25A875A.IP) (Quit: azita)
[17:48:22] *** Joins: EXetoC (ex@moz-C741B177.customer.t3.se)
[17:49:25] <bblum> brson: okay
[17:52:12] *** Quits: pnkfelix2 (pnkfelix@moz-801E009D.vlan502.asr1.cdg2.gblx.net) (Ping timeout)
[17:52:12] *** Joins: tikue (tkuehn@2557E599.66715431.D25A875A.IP)
[17:52:32] *** Joins: pnkfelix (pnkfelix@moz-801E009D.vlan502.asr1.cdg2.gblx.net)
[17:53:02] *** Quits: lucian (lucian@6B2B4644.4304AE1E.CE5E78F6.IP) (Ping timeout)
[17:54:44] *** Joins: bent (chatzilla@moz-C03D0C61.vlan426.asr1.sfo1.gblx.net)
[17:55:38] <doener> EXetoC: results in an ICE for me
[17:56:57] <EXetoC> hm ok
[17:59:05] *** Quits: bytbox (s@moz-D83E9B31.wireless.umd.edu) (Ping timeout)
[17:59:28] *** Joins: dherman (dherman@moz-6CA476B1.hsd1.ca.comcast.net)
[17:59:28] *** ChanServ sets mode: +o dherman
[18:03:47] *** Quits: pnkfelix (pnkfelix@moz-801E009D.vlan502.asr1.cdg2.gblx.net) (Quit: Leaving.)
[18:05:39] <cmr> xazax: I agree that that probably shouldn't be allowed, or at the very least is a default-to-deny lint pass
[18:05:44] <cmr> (re: your ML post)
[18:05:59] *** Quits: Yurume (yurume@AC58A8CE.8A059B47.E313B915.IP) (Connection reset by peer)
[18:08:44] <graydon> nmatsakis: \o/ extremely happy at the 'removing procs' proposal. takes out once functions as well? bravo
[18:08:59] <Eridius> rusti: let x = @mut (~"foo"); let y = ~""; std::utl::swap(*x, &mut y);
[18:09:02] -rusti- more than 5 lines of output, pastebinned: http://sprunge.us/SeWW
[18:09:06] <bblum> wait, how does it take out once functions?
[18:09:23] <Eridius> rusti: let x = @mut (~"foo"); let y = ~""; std::util::swap(*x, &mut y);
[18:09:25] -rusti- more than 5 lines of output, pastebinned: http://sprunge.us/hWeG
[18:09:43] <Eridius> rusti: let x = @mut (~"foo"); let y = ~""; std::util::swap(x, &mut y);
[18:09:51] -rusti- more than 5 lines of output, pastebinned: http://sprunge.us/CPNH
[18:09:51] <bblum> i think we need once functions in places that are not just task bodies
[18:09:55] <graydon> bblum: doesn't strictly require taking them out, just removes one of the main motives for 'em. and suggests macro+struct pairs are equally plausible replacements for remaining cases, that don't intrude into the type system.
[18:09:56] <nmatsakis> graydon: yes, that pleased me. I like that the types at the end don't look...that crazy :)
[18:10:05] <Eridius> rusti: let x = @mut (~"foo"); let mut y = ~""; std::util::swap(x, &mut y); y
[18:10:06] -rusti- ~"foo"
[18:10:08] *** Quits: dherman (dherman@moz-6CA476B1.hsd1.ca.comcast.net) (Quit: dherman)
[18:10:22] <Eridius> indirect: from your conversation last night, the above should let you return the contents of @mut ~str without having to actually copy the string
[18:10:28] <nmatsakis> bblum: anytime you would write "fn foo(f: once fn())' you can write "fn foo<A>(a: A, f: fn(A))"
[18:10:43] <nmatsakis> in short.
[18:10:48] <graydon> destructuring a struct by move, and moving its values as args to a closed-over function, seem pretty similar to 'once', just a question of whether the majority cases are convenient to write.
[18:11:04] <graydon> er, a non-closed-over (extern) function
[18:11:22] <Eridius> what are once functions?
[18:11:27] <bblum> nmatsakis: do option.iter |x| { pipe.send(captured_arc_handle) }
[18:12:11] <nmatsakis> bblum: 'match option { Some(x) => { ... } }'
[18:12:37] <bblum> :|
[18:13:11] <nmatsakis> that's basically the only case I could think of
[18:13:18] <nmatsakis> where it arose that you had a fn that was used in a generic way (`each`)
[18:13:22] <nmatsakis> that was a once fn for some types
[18:13:28] <nmatsakis> but not others
[18:13:50] <nmatsakis> it's non-ideal, but I think it's a fair trade.
[18:13:55] <cmr> A new snapshot after aatch|gone's pass rejiggering would be nice, especially since pcwalton landed a few big changes
[18:14:08] <bblum> 
[18:14:11] <bblum> oops
[18:14:36] <bblum> nmatsakis: task::unkillable
[18:14:46] <bblum> RWARC::read, RWARC::write
[18:14:48] <nmatsakis> bblum: thread an argument?
[18:14:50] <nmatsakis> for all of them
[18:14:52] <kimundi> nmatsakis: So we're back at explicit by-move captures that way? ;)
[18:15:08] <nmatsakis> task::unkillable((a, b, c)) |(a, b, c)| { ... }
[18:15:22] <nmatsakis> doesn't strike me as terrible.
[18:15:23] <bblum> and then anybody who doesn't need the once fn functionality will be writing do rwarc.write(()) |(), state| { ... }
[18:15:29] <nmatsakis> yes.
[18:15:40] <nmatsakis> probably you would have "write_move" vs write"
[18:16:05] <nmatsakis> we can keep once fns too, it's not the end of the world either way.
[18:16:23] <heftig> nmatsakis: 
[18:16:24] <kimundi> do spawn |move foo| { ... } -> do spawn(task!{ foo => ... })
[18:16:26] <heftig> nmatsakis: 
[18:16:28] <heftig> oops
[18:16:33] <bblum> i don't think that doubling the number of library functions or the number of parentheses users have to write is worth avoiding once
[18:16:33] <nmatsakis> kimundi: yes :)
[18:17:00] <heftig> nmatsakis: |x| { ... } will still be a closure or a function, depending on the argument type?
[18:17:08] <heftig> i.e. inferred?
[18:17:14] <nmatsakis> heftig: yeah, it'd be a closure or an environment-less fn...
[18:17:42] <bblum> i feel like once is a very natural part of the type system that is missing otherwise
[18:17:43] <joelteon> man this got completely overlooked https://github.com/mozilla/rust/issues/6274
[18:17:56] <bblum> rather than something we should incur library bloat to avoid having as an "extra"
[18:18:07] <nmatsakis> bblum: well, that's the judgement call. it'd be worth tallying up the list of how many fns we're talking about exactly
[18:18:24] <nmatsakis> bblum: but whether or not we keep once is pretty orthogonal to the main point of the post.
[18:18:27] *** Parts: caitp (caitp@moz-2E2F18CB.senecacollege.ca) ()
[18:18:28] <bblum> yeah, i agree
[18:18:39] <bblum> i certainly like this main point better than the proc thing
[18:19:25] *** Quits: brson (brson@2557E599.66715431.D25A875A.IP) (Quit: leaving)
[18:22:07] <heftig> hmm, could you make fn foobar1(fn(S) -> T) a function taking a function arg and fn foobar2(|S| -> T) a closure arg? and then call it like foobar1(fn(x) { ... }) and foobar2(|x| { ... })?
[18:22:25] <bblum> also i mean, the option::map_default, etc functions are too convenient for saving lines of code to tell people to write match statements instead
[18:22:26] <kimundi> nmatsakis: It's just... The nice thing about the current {~, @}fn is that it's a lightwight basic building block. Defining them a explicit structures/trait etc might be more clear, but also more verbose, even with macros
[18:22:54] *** Quits: jensnockert (jensnocker@moz-8BE55278.customer.t3.se) (Input/output error)
[18:25:06] *** Quits: pcwalton (pcwalton@43CB6079.66715431.D25A875A.IP) (Quit: pcwalton)
[18:26:41] *** Quits: snearch (snearch@moz-1D5B13B7.pool.mediaways.net) (Quit: Verlassend)
[18:27:30] *** Joins: pcwalton (pcwalton@2557E599.66715431.D25A875A.IP)
[18:27:30] *** ChanServ sets mode: +o pcwalton
[18:27:30] <bblum> haha, i love finally()
[18:27:34] *** Joins: ksev (DrunkenPan@745B767B.989A61DC.CA5B6332.IP)
[18:27:35] <bblum> why is it in unstable?
[18:28:25] *** Joins: erickt (erickt@8C9ECD8F.3A598286.F12515B4.IP)
[18:28:41] <bblum> oh yeah, the borrowing destructor thing
[18:31:03] *** Joins: tjc (tjc@A5087023.2354C43D.D8E68FF6.IP)
[18:31:03] *** ChanServ sets mode: +o tjc
[18:31:16] <xazax> cmr, yeah, however after some response I'm aware there are some valid pattern that is abusing this behavior, so maybe it is better to have a warning heuristic that warns about shadowing variables that are too far from each other
[18:31:28] *** Joins: reyre_ (reyre@86C3727C.33EE9F8A.1139E686.IP)
[18:32:02] *** Joins: bytbox (s@moz-D83E9B31.wireless.umd.edu)
[18:35:56] *** Quits: bytbox (s@moz-D83E9B31.wireless.umd.edu) (Ping timeout)
[18:36:02] *** Joins: azita (Azita@2557E599.66715431.D25A875A.IP)
[18:37:05] <bblum> oh, btw, i have to point out
[18:37:17] <bblum> if we go with the "removing heap closures" route, we have to add a macro called lambda!
[18:37:32] <bblum> for being able to return closures out of functions :P
[18:38:11] *** Quits: bjz (brendanzab@B398BE78.F804C29E.D35A31DF.IP) (Quit: Bye!)
[18:38:11] <bblum> (and then pcwalton will write a vim conceal rule to turn it into the lambda character)
[18:38:17] *** Joins: bjz (brendanzab@B398BE78.F804C29E.D35A31DF.IP)
[18:38:35] *** Quits: eholk (eholk@moz-3D703D55.uconnect.utah.edu) (Quit: eholk)
[18:38:47] *** Quits: jack (jack@2557E599.66715431.D25A875A.IP) (Ping timeout)
[18:39:24] *** Quits: cowboyd (cowboyd@1D8844A7.1B729417.CEE440B6.IP) (Client exited)
[18:42:10] <nmatsakis> bblum: it's a bit trickier if you want to return a close that can be called many times, I realized, because you have to rewrite "x" to "self.x"
[18:42:26] <nmatsakis> *return a closure
[18:45:39] *** Quits: Jesse (jruderman@moz-537BCF9.hsd1.ca.comcast.net) (Quit: Jesse)
[18:47:45] *** Quits: sk (sk@EA324BFE.54A580E3.78DD174B.IP) (Quit: Leaving)
[18:48:17] *** Joins: victorporof (victorporo@DE2B5DEF.67CDC207.79933D60.IP)
[18:49:37] *** Quits: Cromulent (Cromulent@moz-983B638D.cable.virginmedia.com) (Quit: KVIrc 4.2.0 Equilibrium http://www.kvirc.net/)
[18:50:07] <nmatsakis> bblum: interestingly, I think once fns are kind of...incompatible with &mut as well. they would really want to be passed by-value, so they can be "consumed"
[18:50:22] <nmatsakis> bblum: whereas an `&mut` pointer can be re-borrowed
[18:50:48] <nmatsakis> bblum: so the version of closures described in my most recent blog post can support once fns,
[18:50:55] <kimundi> rusti: let Î» = |x| print(x); Î»("foo")
[18:50:56] -rusti- foo
[18:50:59] <nmatsakis> bblum: but I think that even if we accepted `&mut fn`, it wouldn't work out.
[18:51:05] <kimundi> bblum: ^
[18:53:05] *** Quits: erickt (erickt@8C9ECD8F.3A598286.F12515B4.IP) (Quit: Leaving.)
[18:54:34] *** Joins: ghrust (ghrust@moz-4EF5B6E5.rs.github.com)
[18:54:34] <ghrust> 01[13rust01] 15bors merged 06auto into 06incoming: 02http://git.io/-LoMsQ
[18:54:34] *** Parts: ghrust (ghrust@moz-4EF5B6E5.rs.github.com) ()
[18:57:03] <cmr> joelteon: can you reproduce on incoming?
[18:57:30] <cmr> joelteon: generally if you want something fixxed you have to do it yourself :)
[18:57:35] *** Joins: ghrust (ghrust@moz-4EF5B6E5.rs.github.com)
[18:57:35] <ghrust> 01[13rust01] 15bors pushed 0 new commits to 06auto: 02http://git.io/SXgN9g
[18:57:35] *** Parts: ghrust (ghrust@moz-4EF5B6E5.rs.github.com) ()
[18:57:36] *** Joins: ghrust (ghrust@moz-4EF5B6E5.rs.github.com)
[18:57:36] <ghrust> 01[13rust01] 15bors pushed 2 new commits to 06auto: 02http://git.io/0QXYbA
[18:57:36] <ghrust> 13rust/06auto 14a4d50ee 15Daniel Farina: Remove unnecessary 'use' forms...
[18:57:36] <ghrust> 13rust/06auto 148472ab4 15bors: auto merge of #6833 : fdr/rust/fix-warnings, r=graydon...
[18:57:37] *** Parts: ghrust (ghrust@moz-4EF5B6E5.rs.github.com) ()
[18:58:45] <cmr> fdr: those are needed in the later stages I thought
[18:59:07] <cmr> I'm almost certian
[19:00:02] <cmr> The prelude changed
[19:01:02] *** Quits: ksev (DrunkenPan@745B767B.989A61DC.CA5B6332.IP) (Ping timeout)
[19:02:10] *** Joins: webber46 (webber46@moz-27A3779B.cust.bredband2.com)
[19:02:52] *** Joins: cowboyd (cowboyd@moz-1BD02A1E.sw.biz.rr.com)
[19:03:31] *** Quits: bjz (brendanzab@B398BE78.F804C29E.D35A31DF.IP) (Ping timeout)
[19:04:01] *** Quits: FrozenCow (FrozenCow@moz-9DF5D010.dynamic.upc.nl) (Quit: Leaving)
[19:04:42] *** Joins: caitp (caitp@moz-2E2F18CB.senecacollege.ca)
[19:04:53] *** Joins: bjz (brendanzab@B398BE78.F804C29E.D35A31DF.IP)
[19:04:53] <caitp> "Borrowed pointers arise by (automatic) conversion from owning pointers," is this still actually true?
[19:06:12] <doener> rusti: fn foo(i: &int) { println(i.to_str()); } foo(~5);
[19:06:14] -rusti- 5
[19:06:23] <cmr> rusti: fn foo(x: ~int) { println(fmt!("%?", x)); } foo(~42)
[19:06:25] -rusti- ~42
[19:06:29] <nmatsakis> caitp: they can.
[19:06:31] <cmr> rusti: fn foo(x: &int) { println(fmt!("%?", x)); } foo(~42)
[19:06:32] -rusti- &42
[19:06:47] *** Quits: fabiand (fabiand@moz-9283D66.adsl.alicedsl.de) (Quit: Verlassend)
[19:07:41] *** Joins: engla (engla@moz-DBD1D96E.cust.bredbandsbolaget.se)
[19:07:50] *** Quits: aruniiird (arun@moz-3DB73AA5.azulsystems.com) (Ping timeout)
[19:08:08] *** Joins: erickt (erickt@8C9ECD8F.3A598286.F12515B4.IP)
[19:08:55] <bblum> nmatsakis: ahh, if you could call a &mut once fn, you could pass it to a &mut T and get back a second one, yes
[19:09:37] <bblum> I didn't like &mut fn either anyway :P
[19:11:24] <bblum> by the way, is there a design reason why we don't have cross-function type/trait inference? or is it just because it's hard?
[19:11:37] *** Joins: jrfeenst (jrfeenst@moz-3265BD65.cpe.norwoodlight.com)
[19:11:49] <cmr> bblum: example?
[19:12:57] *** Quits: steven_is_false (user@moz-144077DE.bchsia.telus.net) (Ping timeout)
[19:13:18] <bblum> cmr: fn with_mut_reborrow<T>(x: &mut T, blk: fn(&mut T)) { let y = &mut *x; blk(y); }
[19:13:54] <bblum> cmr: fn cheat(blk: &mut once fn()) { do with_mut_reborrow(blk) |blk| { blk(); } blk(); }
[19:14:45] <nmatsakis> bblum: type inference across fns starts to hit some pretty severe restrictions.
[19:14:48] <bblum> no... hmmm... more like, "let y = &mut *x; blk(y); /* x unfrozen here */ let z = &mut *x; blk(z);
[19:14:50] <bblum> "
[19:15:01] <caitp> if I want to return an immutable array of strings from a function, what would be a sensible way to write it? No matter what combination of pointer types I use the compiler complains.
[19:15:08] <bblum> nmatsakis: such as?
[19:15:22] <nmatsakis> undecidable with recursive functions, for example.
[19:15:25] <tjc> caitp: usually you want to return a ~[~str]
[19:15:27] <nmatsakis> er, polymorphic recursive functions.
[19:15:54] <nmatsakis> it wouldn't be especially compatible with the rust rule that "order of fn declarations doesn't matter"
[19:16:19] <nmatsakis> this is why groups of recursive fns in ML have to be declared specially,
[19:16:25] <nmatsakis> and some things won't type check at all without annotation
[19:16:27] *** Joins: Jesse (jruderman@2557E599.66715431.D25A875A.IP)
[19:16:28] <bblum> ah... how does haskell deal with it? polymorphic recursion can't re-instantiate at a different type?
[19:16:30] <caitp> but then the individual strings inside the array end up being passed to something expecting an immutable borrowed pointer, and the compiler chokes (found &~str expected &str, etc)
[19:16:47] <bblum> oh i thought ML had that too
[19:16:51] <cmr> caitp: *foo
[19:17:09] *** Joins: ciferkey (ciferkey@moz-37B1CA4E.prvdri.fios.verizon.net)
[19:17:10] <nmatsakis> bblum: well, I don't remember what restrictions are in ML vs Ocaml etc, but if you require the user to annotate the polymorphic fn, then of course you can handle recursion
[19:17:23] *** Joins: sankha93 (Instantbir@17806EDC.4198D8F2.8B6C1D65.IP)
[19:17:42] <nmatsakis> bblum: I'm not sure exactly what haskell does, but for sure it is subject to the same limitation.
[19:18:42] *** Joins: ksev (DrunkenPan@745B767B.989A61DC.CA5B6332.IP)
[19:18:43] <nmatsakis> bblum: by which I mean, if you have recursive fns, you have to assume the fn is not re-instantiated with a different type, unless user gave you the full type
[19:18:58] <bblum> ok, yeah
[19:19:13] <bblum> that doesn't seem like an unreasonable restriction though
[19:19:22] * nmatsakis shrugs
[19:19:25] <nmatsakis> it's not
[19:19:27] *** Quits: MaikKlein (maik@moz-340073FA.dip0.t-ipconnect.de) (Ping timeout)
[19:19:28] <nmatsakis> I like types at fn boundaries though
[19:19:32] <nmatsakis> code gets unreadable otherwise, I think
[19:19:43] <nmatsakis> but this rule predated me :)
[19:19:46] *** Quits: devinus (devinus@moz-B4AF84BC.ptr.us.xo.net) (Quit: Computer has gone to sleep.)
[19:19:55] <bblum> yeah, i'm not trying to say we should overthrow it or something
[19:19:55] <nmatsakis> also, type inference is hard enough, without making it inter-procedural
[19:20:10] <nmatsakis> particularly when interacting with subtyping and other rules
[19:20:25] <bblum> i was explaining the T:Static thing to another PL friend and he was like "idgi, why can't you just infer T:Static whenever you need it?"
[19:21:59] <bblum> and i didn't have a good answer :P
[19:22:14] <bblum> in what way would reordering functions change things with cross-function inference?
[19:24:20] *** Joins: steven_is_false (user@moz-144077DE.bchsia.telus.net)
[19:26:12] *** Joins: devinus (devinus@moz-B4AF84BC.ptr.us.xo.net)
[19:26:21] *** Quits: erickt (erickt@8C9ECD8F.3A598286.F12515B4.IP) (Quit: Leaving.)
[19:29:07] <nmatsakis> well, we have to deduce the dependencies between them, is a more accurate summary
[19:29:18] <nmatsakis> that is, to type check function F, you must know the types of its callees
[19:29:32] <nmatsakis> and when there is a cycle, you have to deal with the strongly connected component as a unit
[19:29:52] *** Joins: aruniiird (arun@84E199D6.DCDBCF8E.83D0DF30.IP)
[19:30:13] <bblum> that's approximately my plan for effect inference too >_>
[19:30:23] <nmatsakis> yes, it shows up in all inter-procedural inference scenarios
[19:31:38] <bblum> (with effect inference i expect it to be easier though; "all these functions have the aggregate effect of all of them, plus all the polymorphic effects of all their inputs")
[19:31:53] <bblum> (but this is before reading the paper)
[19:34:28] *** Joins: kendle (Mibbit@84E199D6.DCDBCF8E.83D0DF30.IP)
[19:35:12] <bblum> wouldn't it be nice if all closures could just desugar to traits
[19:36:48] *** Quits: eternaleye (eternaleye@moz-76321711.hsd1.wa.comcast.net) (Connection reset by peer)
[19:36:57] <bblum> (that wouldn't solve the main problem, but it would be cute)
[19:37:53] *** Joins: eholk (eholk@moz-3D703D55.uconnect.utah.edu)
[19:41:06] *** Joins: eternaleye (eternaleye@moz-76321711.hsd1.wa.comcast.net)
[19:41:44] <strcat> nmatsakis: if you use #[inline], how does LLVM know to link against the library if it decides not to inline?
[19:41:50] *** Joins: bytbox (s@moz-D83E9B31.wireless.umd.edu)
[19:41:55] <strcat> or does it get output in the crate no matter what, but not necessarily inlined?
[19:42:23] <strcat> or maybe pcwalton knows
[19:43:04] *** Joins: ghrust (ghrust@moz-4EF5B6E5.rs.github.com)
[19:43:04] <ghrust> 01[13rust01] 15bors 04force-pushed 06auto from 148472ab4 to 14a394298: 02http://git.io/N3iJvQ
[19:43:04] *** Parts: ghrust (ghrust@moz-4EF5B6E5.rs.github.com) ()
[19:43:06] *** Joins: ghrust (ghrust@moz-4EF5B6E5.rs.github.com)
[19:43:07] <ghrust> 01[13rust01] 15bors pushed 2 new commits to 06auto: 02http://git.io/Bhx6Dw
[19:43:07] <ghrust> 13rust/06auto 14594f40e 15Corey Richardson: bump clang version
[19:43:07] <ghrust> 13rust/06auto 14784a849 15bors: auto merge of #6835 : cmr/rust/clang, r=thestinger...
[19:43:07] *** Parts: ghrust (ghrust@moz-4EF5B6E5.rs.github.com) ()
[19:44:34] <nmatsakis> strcat: yes.
[19:44:42] <nmatsakis> strcat: we inline to the crate no matter what,
[19:44:47] <nmatsakis> strcat: LLVM does what it likes.
[19:45:15] <strcat> nmatsakis: okay that makes sense.
[19:46:16] *** Quits: nielsle (nielsle@moz-5CE8ECCD.boa.fiberby.dk) (Ping timeout)
[19:46:31] *** Joins: nielsle (nielsle@moz-5CE8ECCD.boa.fiberby.dk)
[19:49:07] *** Quits: eternaleye (eternaleye@moz-76321711.hsd1.wa.comcast.net) (Connection reset by peer)
[19:51:08] <caitp> ok, so this kind of thing http://pastebin.mozilla.org/2462923 is still sort of killing me, I think the the borrowed strings or arrays is dying unexpectedly or something
[19:51:19] <caitp> it seems to get further than that, but it doesn't last long
[19:52:10] <cmr> caitp: you can't return a slice like that in get_last_resort_font_families without an explicit lifetime, I thought?
[19:52:41] *** Joins: vcl (chatzilla@741D4FEA.76F9E272.DA40C4B3.IP)
[19:52:56] *** Joins: eternaleye (eternaleye@moz-76321711.hsd1.wa.comcast.net)
[19:52:58] <caitp> compiler doesn't complain at any rate -- it probably makes sense for it to be static life'd, but that seems to cause nothing but problems in rust
[19:53:33] *** Quits: echristo (echristo@D423593A.D6CCE4AE.77834EAA.IP) (Quit: echristo)
[19:54:50] *** Quits: heftig (heftig@moz-9E352B4E.dip0.t-ipconnect.de) (Ping timeout)
[19:55:12] *** Quits: chadz (uid979@moz-A588D045.irccloud.com) (Ping timeout)
[19:55:15] *** Joins: pnkfelix (pnkfelix@moz-43495417.fbx.proxad.net)
[19:56:04] <nmatsakis> graydon: you converted the type table from a smallintmap?
[19:56:07] <steven_is_false> The latest patches implement some Scheduler multithreading improvements. Can one finally use the SingleTaskPerThread scheduling mode?
[19:56:09] <nmatsakis> graydon: iirc?
[19:56:30] *** Joins: erickt (erickt@8C9ECD8F.3A598286.F12515B4.IP)
[19:56:41] <nmatsakis> graydon: I'm wondering if this is responsible for the 10x slowdown in type checker perf that I see locally...
[19:57:48] *** Quits: igl (igl@moz-EA8DFE94.adsl.alicedsl.de) (Ping timeout)
[19:57:48] *** Parts: steven_is_false (user@moz-144077DE.bchsia.telus.net) (ERC Version 5.3 (IRC client for Emacs))
[19:58:02] *** Joins: igl (igl@moz-D8850789.adsl.alicedsl.de)
[19:58:16] *** Quits: erickt (erickt@8C9ECD8F.3A598286.F12515B4.IP) (Ping timeout)
[19:58:43] <caitp> not using borrowed pointers seems to work
[19:58:54] <caitp> but it seems like borrowed pointers would be a better idea
[19:58:58] <caitp> they just need to live somewhere first
[19:59:00] <caitp> I guess
[19:59:13] <caitp> but static functions, so yeah
[19:59:27] <caitp> nowhere for it to live :u
[19:59:45] <cmr> You can use &'static
[20:00:10] <nmatsakis> caitp: looking at your patch, I don't see any borrowed pointers? unclear to me what you are referring to
[20:00:12] *** Quits: devinus (devinus@moz-B4AF84BC.ptr.us.xo.net) (Quit: Textual IRC Client: www.textualapp.com)
[20:00:20] *** Quits: tgt (tgt@moz-D59EE478.aztw.cable.virginmedia.com) (Ping timeout)
[20:00:29] <caitp> which patch?
[20:00:38] <nmatsakis> caitp: sorry, gist.
[20:00:46] <nmatsakis> pastebin, I guess.
[20:00:49] <nmatsakis> http://pastebin.mozilla.org/2462923
[20:01:17] *** Quits: geomyidae__ (uid214@moz-C944F5EC.irccloud.com) (Ping timeout)
[20:01:17] *** Joins: heftig (heftig@moz-9DDB7EFC.dip0.t-ipconnect.de)
[20:01:25] *** Quits: igl (igl@moz-D8850789.adsl.alicedsl.de) (Ping timeout)
[20:01:27] <caitp>  find_font_in_family expects a borrowed string, so passing 'family' alone doesn't work, needed to be dereferenced I guess
[20:01:34] *** Joins: igl (igl@moz-55F925C8.adsl.alicedsl.de)
[20:02:02] <caitp> returning ~[~str] from get_last_resort_font_families() rather than &[~str] seems to help, but this might be problematic too
[20:02:21] *** Joins: geomyidae__ (uid214@moz-C944F5EC.irccloud.com)
[20:02:25] <nmatsakis> caitp: you should definitely not be returning &[~str], the fact that this type checks is ... broken.
[20:02:36] <nmatsakis> there's a bug on it
[20:02:42] <nmatsakis> you are returning stack allocated data, I have to investigate / fix that
[20:02:47] <bblum> hmm... i wonder if fn:Copy-versus-fn could be used instead of fn-versus-once-fn
[20:02:59] <caitp> can ~[] be allocated on the stack?
[20:03:03] <nmatsakis> caitp: you probably want to just use a static constant
[20:03:05] <caitp> it doesn't look like it from the docs
[20:03:15] <cmr> caitp: No, that's what &[] is
[20:03:30] <nmatsakis> caitp: static last_resort_font_families: &'static [&'static str] = ["Arial Unicode MS", "Arial"];
[20:03:31] <caitp> well I think eventually this will all be user-pref driven, so at some point an actual living variable will have to be introduced
[20:03:45] *** Joins: jensnockert (jensnocker@moz-8BE55278.customer.t3.se)
[20:03:46] <caitp> but for now I guess ~[~str] is ok
[20:03:47] <nmatsakis> caitp: but if you dont' want it hardcoded, then the right type is probably ~[~str], as you have.
[20:04:06] *** Joins: echristo (echristo@D423593A.D6CCE4AE.77834EAA.IP)
[20:04:20] <bblum> ok, i timed a make last night, and it took 82m2.244s
[20:04:28] <bblum> is it this bad for everybody else
[20:04:43] <bblum> (all stages)
[20:04:44] *** Joins: igl1 (igl@moz-FB96D27F.adsl.alicedsl.de)
[20:04:55] *** Quits: igl (igl@moz-55F925C8.adsl.alicedsl.de) (Ping timeout)
[20:05:07] *** Joins: tgt (tgt@moz-D59EE478.aztw.cable.virginmedia.com)
[20:05:18] <strcat> bblum: no, not nearly that bad for me
[20:05:27] <cmr> bblum: what harware do you have? tehre's severe perf regressions right now
[20:05:44] <strcat> 20min before the bbvectorize pass was enabled (it shouldn't be)
[20:05:52] <strcat> haven't actually built since
[20:05:58] <bblum> cmr: Intel(R) Core(TM) i7-2860QM CPU @ 2.50GHz
[20:06:13] *** Quits: tikue (tkuehn@2557E599.66715431.D25A875A.IP) (Quit: tikue)
[20:06:16] <bblum> although hm... all but one of my cpus are at 800mhz even when on wall power... why is that
[20:06:33] <bblum> (8 cores; not that that matters for a rustc build)
[20:06:55] *** Quits: pcwalton (pcwalton@2557E599.66715431.D25A875A.IP) (Quit: pcwalton)
[20:06:55] *** Quits: eatkinson (eatkinson@2557E599.66715431.D25A875A.IP) (Quit: eatkinson)
[20:06:56] *** Quits: ciferkey (ciferkey@moz-37B1CA4E.prvdri.fios.verizon.net) (Quit: ciferkey)
[20:07:16] <strcat> bblum: the build is essentially single-threaded
[20:07:28] <bblum> right
[20:07:37] <bblum> hence 'not that that matters' :P
[20:08:09] <strcat> bblum: https://plus.google.com/117091380454742934025/posts/2vEekAsG2QT related though ;p
[20:08:15] <strcat> frequency scaling sucks
[20:08:36] *** Joins: pcwalton (pcwalton@2557E599.66715431.D25A875A.IP)
[20:08:36] *** ChanServ sets mode: +o pcwalton
[20:09:06] *** Joins: brson (brson@2557E599.66715431.D25A875A.IP)
[20:09:06] *** ChanServ sets mode: +o brson
[20:09:35] <bblum> strcat: good grief
[20:09:36] <bblum> c.c
[20:09:37] * bblum reads
[20:10:08] *** Joins: jack (jack@2557E599.66715431.D25A875A.IP)
[20:10:48] *** Joins: nofear (Mibbit@moz-331647E5.jax.bellsouth.net)
[20:10:50] <bblum> huh, i should get to 3.9 then
[20:11:04] <strcat> tl;dr is that when the cpu is idle the frequency is essentially 0 and it can even turn off cores
[20:11:22] <strcat> so freq scaling just adds a bunch of polling + reduces time at idle
[20:11:31] *** Quits: nofear (Mibbit@moz-331647E5.jax.bellsouth.net) (Z:lined (no thanks))
[20:12:07] <bblum> yeah
[20:12:08] <Jesse> lol https://bugzilla.mozilla.org/show_bug.cgi?id=872416#c0
[20:12:30] <cmr> bblum: http://huonw.github.io/isrustfastyet/ if you haven't seen it
[20:12:44] <bblum> cmr: what's the y axis unit
[20:12:50] <cmr> seconds
[20:12:56] <bblum> hm.
[20:13:04] <cmr> click the nodes for links and stuff
[20:14:52] *** Quits: kendle (Mibbit@84E199D6.DCDBCF8E.83D0DF30.IP) (Quit: http://www.mibbit.com ajax IRC Client)
[20:16:04] <graydon> nmatsakis: 10x? gosh
[20:16:30] <graydon> nmatsakis: yes, I did; it was deserializing node ids from metadata that were sparse, which allocates a whole lot of smallintmap
[20:16:35] <graydon> like several hundred megs
[20:18:11] <xazax> strcat, do you know about some measurement what is the difference?
[20:18:39] <strcat> xazax: the power usage thing? you can use powertop to watch estimated consumption from a battery (or better, a watt meter)
[20:18:48] *** Quits: jaen (jaen@moz-E0979827.copit.pl) (Ping timeout)
[20:18:49] <xazax> yes the power usage
[20:18:57] <strcat> cpu freq makes absolutely no difference on modern cpus if it's not at 100% usage
[20:19:07] <strcat> scaling actually reduces efficiency a bit
[20:19:09] <cmr> xazax: my simple non-scientific benchmarking gave me 6% more idle time when on the performance governor as compared to ondemand, but I don't have a killawatt on me
[20:19:19] *** Joins: jaen (jaen@moz-E0979827.copit.pl)
[20:19:25] <strcat> the biggest thing is making sure power saving on the GPU is enabled (rc6)
[20:20:25] <engla> xazax: cool, which processor?
[20:20:50] <strcat> (this is only really true without a doubt since sandy bridge by the way)
[20:21:11] <engla> ok.
[20:21:35] <xazax> it is a pity that my laptop lasts about 1~1,5 hour longer on windows than on linux
[20:21:44] <strcat> xazax: well seems like it's set up wrong then
[20:21:55] <xazax> however yes, I guess cinnamon is not the most battery friendly desktop environment
[20:21:56] <strcat> unless you have an nvidia/amd discrete gpu, in which case it's because their drivers suck
[20:22:21] <strcat> I get better battery life on linux compared to windows with this thinkpad
[20:22:26] <xazax> I have a dedicated nvidia cpu and have bumblebee installed which I guess turns it off by default
[20:22:34] <strcat> xazax: I don't think it can turn it off
[20:22:41] <strcat> it can only disable it but it still eats power
[20:22:50] <xazax> oh I see, that is a pity
[20:23:18] <xazax> than this can be the real source of my power issues
[20:23:43] <xazax> and what is your desktop environment?
[20:23:50] * strcat doesn't use a DE ;p
[20:23:59] <xazax> window manager? :D
[20:24:06] <strcat> i3
[20:24:18] <brson> nmatsakis: r? https://github.com/mozilla/rust/pull/6839
[20:25:07] <xazax> oh, I always wanted to try a tiling wm but never had time to get used to it
[20:25:27] <jclements> I just started using xmonadâ€¦ I like it so far.
[20:25:32] <strcat> I mostly just split my screen in two and stack things on either side
[20:26:30] <xazax> do you find it more productive to use a tiling wm?
[20:26:30] *** Quits: eternaleye (eternaleye@moz-76321711.hsd1.wa.comcast.net) (Connection reset by peer)
[20:26:40] <strcat> xazax: yes, I can be much lazier ;p
[20:27:11] *** Quits: pyrac (pyrac@moz-285C535.w92-156.abo.wanadoo.fr) (Quit: pyrac)
[20:28:21] <strcat> xazax: http://i.imgur.com/FVzaBrH.png essentially all I do... except sometimes I make tabbed containers
[20:28:54] <cmr> I don't necesarrily find it more productive cmopared to a well-configured openbox or such, but it's a lot more painless to use
[20:29:12] * strcat loves stacking/tabbing windows ;p
[20:29:13] *** Joins: erick (erick@E1304535.2A7189BF.BE19388.IP)
[20:29:45] <xazax> I will give them a test drive I guess
[20:29:52] <xazax> once I'm done with my finals :D
[20:30:26] *** Quits: tjc (tjc@A5087023.2354C43D.D8E68FF6.IP) (Quit: Places to go, people to annoy)
[20:30:45] <strcat> anyway github doesn't feel like working for me anymore.
[20:31:34] *** Joins: eternaleye (eternaleye@moz-76321711.hsd1.wa.comcast.net)
[20:32:01] *** Quits: carllerche (carllerche@6B070D22.7E6A0813.1428D117.IP) (Quit: carllerche)
[20:33:11] *** Joins: tjc (tjc@A5087023.2354C43D.D8E68FF6.IP)
[20:33:11] *** ChanServ sets mode: +o tjc
[20:33:24] *** Quits: eternaleye (eternaleye@moz-76321711.hsd1.wa.comcast.net) (Ping timeout)
[20:33:48] *** Joins: eternaleye (eternaleye@moz-76321711.hsd1.wa.comcast.net)
[20:34:40] *** Quits: eternaleye (eternaleye@moz-76321711.hsd1.wa.comcast.net) (Connection reset by peer)
[20:38:17] *** Joins: igl (igl@moz-1BD7E1A7.adsl.alicedsl.de)
[20:38:25] *** Quits: igl1 (igl@moz-FB96D27F.adsl.alicedsl.de) (Ping timeout)
[20:39:04] *** Joins: eternaleye (eternaleye@moz-76321711.hsd1.wa.comcast.net)
[20:40:59] *** Joins: igl1 (igl@moz-78695EA2.adsl.alicedsl.de)
[20:42:10] *** Quits: igl (igl@moz-1BD7E1A7.adsl.alicedsl.de) (Ping timeout)
[20:43:43] *** Quits: eternaleye (eternaleye@moz-76321711.hsd1.wa.comcast.net) (Connection reset by peer)
[20:43:45] *** Quits: igl1 (igl@moz-78695EA2.adsl.alicedsl.de) (Ping timeout)
[20:44:17] *** kimundi is now known as zz_kimundi
[20:44:30] *** Joins: eatkinson (eatkinson@2557E599.66715431.D25A875A.IP)
[20:44:53] *** Joins: tikue (tkuehn@2557E599.66715431.D25A875A.IP)
[20:45:22] *** Quits: webber46 (webber46@moz-27A3779B.cust.bredband2.com) (Ping timeout)
[20:46:14] *** Joins: ghrust (ghrust@moz-4EF5B6E5.rs.github.com)
[20:46:14] <ghrust> 01[13rust01] 15bors merged 06auto into 06incoming: 02http://git.io/Bhx6Dw
[20:46:14] *** Parts: ghrust (ghrust@moz-4EF5B6E5.rs.github.com) ()
[20:47:35] *** Quits: reyre_ (reyre@86C3727C.33EE9F8A.1139E686.IP) (Client exited)
[20:48:07] *** Joins: eternaleye (eternaleye@moz-76321711.hsd1.wa.comcast.net)
[20:51:44] *** Quits: maxli (maxli@F2D29657.F60B0462.67AC9B1.IP) (Quit: Leaving.)
[20:51:49] *** Joins: carllerche (carllerche@6B070D22.7E6A0813.1428D117.IP)
[20:52:16] <nmatsakis> brson: cool, I'll take a look
[20:52:28] *** Joins: steve (steve@moz-5EF6C37C.socal.res.rr.com)
[20:52:33] *** steve is now known as steveklabnik
[20:54:40] *** Quits: brson (brson@2557E599.66715431.D25A875A.IP) (Ping timeout)
[20:55:07] *** Joins: brson (brson@2557E599.66715431.D25A875A.IP)
[20:55:07] *** ChanServ sets mode: +o brson
[20:57:04] *** Joins: erickt (erickt@8C9ECD8F.3A598286.F12515B4.IP)
[20:58:23] *** Quits: deepdog (deepdog@moz-490E834C.client.mchsi.com) (Ping timeout)
[20:58:48] *** Quits: erickt (erickt@8C9ECD8F.3A598286.F12515B4.IP) (Ping timeout)
[20:59:30] <graydon> brson: ping
[21:01:25] <graydon> brson: nm, found it
[21:01:30] *** Quits: xazax (xazax@moz-D7592A2A.csoma.elte.hu) (Quit: Ex-Chat)
[21:01:56] <steveklabnik> https://gist.github.com/steveklabnik/6b6447d8b5a2b9618c24 <- any feedback on this? is there an easier idiom for the looping?
[21:02:17] <cmr> steveklabnik: there's uint::range_step
[21:02:29] <steveklabnik> hmmmmm
[21:02:37] *** Quits: azita (Azita@2557E599.66715431.D25A875A.IP) (Quit: azita)
[21:02:55] *** Quits: echristo (echristo@D423593A.D6CCE4AE.77834EAA.IP) (Quit: echristo)
[21:03:00] <steveklabnik> i wonder how i missed that....
[21:03:04] *** Quits: pcwalton (pcwalton@2557E599.66715431.D25A875A.IP) (Quit: pcwalton)
[21:03:12] * steveklabnik furiously writes code
[21:04:01] *** Joins: erickt (erickt@8C9ECD8F.3A598286.F12515B4.IP)
[21:04:36] *** Joins: mschifer1 (Adium@2557E599.66715431.D25A875A.IP)
[21:04:39] *** Quits: jack (jack@2557E599.66715431.D25A875A.IP) (Ping timeout)
[21:04:49] <bblum> pong
[21:04:55] *** Joins: pcwalton (pcwalton@2557E599.66715431.D25A875A.IP)
[21:04:55] *** ChanServ sets mode: +o pcwalton
[21:04:57] *** Quits: mschifer (Adium@2557E599.66715431.D25A875A.IP) (Connection reset by peer)
[21:05:17] *** Joins: azita (Azita@2557E599.66715431.D25A875A.IP)
[21:07:04] *** Quits: caitp (caitp@moz-2E2F18CB.senecacollege.ca) (Quit: caitp)
[21:10:19] <steveklabnik> cmr: thank you, that's way nicer
[21:10:26] *** Joins: echristo (echristo@D423593A.D6CCE4AE.77834EAA.IP)
[21:11:55] *** Quits: victorporof (victorporo@DE2B5DEF.67CDC207.79933D60.IP) (Quit: victorporof)
[21:12:21] *** Quits: Ralith (ralith@moz-50F3C77.vc.shawcable.net) (Ping timeout)
[21:14:12] <cmr> steveklabnik: np. I ran into the exact same question when writing my own base64 stuff :)
[21:14:12] *** Quits: pnkfelix (pnkfelix@moz-43495417.fbx.proxad.net) (Quit: Leaving.)
[21:16:11] <cmr> r? https://github.com/mozilla/rust/pull/6840
[21:16:18] *** Quits: Raynes (macro@moz-E5F01CE6.members.linode.com) (Ping timeout)
[21:16:18] *** Quits: joelteon (joel@moz-82AAB099.rs) (Ping timeout)
[21:16:38] <tjc> cmr: r+'ed
[21:16:44] <cmr> tjc: thanks
[21:17:04] <tjc> thanks for fixing the warnings!
[21:17:53] <Boreeas> Re: The "same variable name in same scope" discussion - shouldn't those rebindings only work when the variable is declared mutable? 
[21:18:05] <strcat> it's not mutating it
[21:18:25] <steveklabnik> cmr: matasano challenge?
[21:18:37] *** Joins: joelteon (joel@moz-82AAB099.rs)
[21:18:38] <cmr> steveklabnik: mhm
[21:18:55] <strcat> rusti: let x = 5; { let x = 10 }; x
[21:18:56] -rusti- foo.rs:8:33: 8:34 error: expected `;` but found `}`
[21:18:56] -rusti- foo.rs:8          let x = 5; { let x = 10 }; x
[21:18:56] -rusti-                                           ^
[21:18:56] -rusti- application terminated with error code 101
[21:19:02] <strcat> rusti: let x = 5; { let x = 10; }; x
[21:19:03] <cmr> (which I gave up to work on rust itself. I was using it mostly as an excuse to learn rust)
[21:19:04] -rusti- 5
[21:19:09] *** Joins: ghrust (ghrust@moz-4EF5B6E5.rs.github.com)
[21:19:09] <ghrust> 01[13rust01] 15bors pushed 0 new commits to 06auto: 02http://git.io/SuN_nQ
[21:19:09] *** Parts: ghrust (ghrust@moz-4EF5B6E5.rs.github.com) ()
[21:19:11] *** Joins: ghrust (ghrust@moz-4EF5B6E5.rs.github.com)
[21:19:11] <ghrust> 01[13rust01] 15bors pushed 2 new commits to 06auto: 02http://git.io/qsA2dQ
[21:19:11] <ghrust> 13rust/06auto 1497550c5 15Corey Richardson: light warning cleanup
[21:19:11] <ghrust> 13rust/06auto 14518a8d1 15bors: auto merge of #6840 : cmr/rust/warns, r=catamorphism
[21:19:11] *** Parts: ghrust (ghrust@moz-4EF5B6E5.rs.github.com) ()
[21:19:22] <steveklabnik> cmr: nice, just started. i am also using it as an excuse to learn
[21:20:17] <Boreeas> rusti: let x = 1; let x = 2;
[21:20:19] * rusti produced no output
[21:20:29] <Boreeas> rusti: let x = 1; let x = ~"";
[21:20:30] * rusti produced no output
[21:20:41] <Boreeas> rusti: let x: int = 1; let x = ~"";
[21:20:42] * rusti produced no output
[21:20:45] <strcat> Boreeas: it doesn't mutate the variable, it just makes another variable in the inner scope
[21:20:54] <Boreeas> Yeah, I get that
[21:20:55] <steveklabnik> hmm, looks like that may have been removed on incoming?
[21:21:05] <Boreeas> I just find it counterintuitive
[21:21:38] <Boreeas> I always assumed that a variable that's not declared mut would never change
[21:21:49] <strcat> Boreeas: it doesn't change
[21:21:50] <cmr> it won't change. new variable, same name
[21:21:52] *** Quits: infynyxx (infynyxx@moz-E95B370B.nyc.res.rr.com) (Client exited)
[21:21:59] <strcat> that's what this was supposed to show
[21:22:01] <strcat> rusti: let x = 5; { let x = 10 }; x
[21:22:01] -rusti- foo.rs:8:33: 8:34 error: expected `;` but found `}`
[21:22:01] -rusti- foo.rs:8          let x = 5; { let x = 10 }; x
[21:22:01] -rusti-                                           ^
[21:22:01] -rusti- application terminated with error code 101
[21:22:03] <strcat> rusti: let x = 5; { let x = 10; }; x
[21:22:04] -rusti- 5
[21:22:05] <tjc> Boreeas: imagine writing let x = 1 in let x = 2 in â€¦ in a functional language
[21:22:07] <tjc> this is like that
[21:22:17] *** Quits: zakora (NC@moz-8EAF945F.fbx.proxad.net) (Quit: Textual IRC Client: www.textualapp.com)
[21:23:03] <Boreeas> rusti: let x = 1; let x = 2; x
[21:23:04] -rusti- 2
[21:23:19] <Boreeas> So if I can change the variable in the same scope, how does it differ from mutating it
[21:23:32] <Boreeas> For all intents and purposes, I can't access the old value anymore
[21:23:33] <jclements> for one thing, it can be of a totally different type. 
[21:23:50] <jclements> rusti: let x = 1; let x = None; x
[21:23:52] -rusti- error: internal compiler error: unexpected failure
[21:23:52] -rusti- note: the compiler hit an unexpected failure path. this is a bug
[21:23:52] -rusti- note: try running with RUST_LOG=rustc=1,::rt::backtrace to get further details and report the results to github.com/mozilla/rust/issues
[21:23:52] -rusti- application terminated with error code 101
[21:23:57] <strcat> that's good
[21:23:59] <strcat> ;p
[21:24:07] <strcat> jclements: because None needs a type hint
[21:24:10] <jclements> now class, what did we learn today?
[21:24:25] <strcat> rusti: let x = None;
[21:24:26] -rusti- more than 5 lines of output, pastebinned: http://sprunge.us/cLbf
[21:24:32] <strcat> weird
[21:24:37] <strcat> rusti: let x = None; let x = None;
[21:24:38] -rusti- more than 5 lines of output, pastebinned: http://sprunge.us/jahc
[21:24:47] <strcat> rusti: let x = None; x
[21:24:48] -rusti- error: internal compiler error: unexpected failure
[21:24:48] -rusti- note: the compiler hit an unexpected failure path. this is a bug
[21:24:48] -rusti- note: try running with RUST_LOG=rustc=1,::rt::backtrace to get further details and report the results to github.com/mozilla/rust/issues
[21:24:48] -rusti- application terminated with error code 101
[21:24:48] <Boreeas> rusti: let x = None<uint>
[21:24:49] -rusti- foo.rs:9:4: 9:5 error: unexpected token: `}`
[21:24:49] -rusti- foo.rs:9     });
[21:24:49] -rusti-              ^
[21:24:49] -rusti- application terminated with error code 101
[21:24:52] <jclements> Boreeas: sigh.
[21:24:52] *** concrete.mozilla.org sets mode: +M 
[21:24:57] <strcat> rusti: None
[21:24:58] -rusti- error: internal compiler error: unexpected failure
[21:24:58] -rusti- note: the compiler hit an unexpected failure path. this is a bug
[21:24:58] -rusti- note: try running with RUST_LOG=rustc=1,::rt::backtrace to get further details and report the results to github.com/mozilla/rust/issues
[21:24:58] -rusti- application terminated with error code 101
[21:25:00] <strcat> :D
[21:25:18] <strcat> I wonder if that's just the specific weird setup that rusti has though.
[21:25:29] <strcat> fmt("%?", { None } }
[21:25:33] <strcat> fmt("%?", { None } ) *
[21:26:02] <jclements> Boreeas: among other things, the difference between mutation and rebinding is that all of the "nice" properties of not-having-mutation hold.  So, for instance, an optimizer can replace all uses of 'x' with the given value, and a closure doesn't need to worry about mutations of that variable.
[21:26:12] <strcat> (the server probably shouldn't bother doing +M when it was an identified person spamming ;p)
[21:26:35] <strcat> qwll
[21:26:37] <strcat> well*
[21:26:51] <strcat> rusti: let x = 5; let y = &x; let x = 10; *y
[21:26:52] -rusti- 5
[21:26:57] <strcat> the data isn't mutated
[21:27:40] *** Quits: SiegeLord (sl@moz-CAF07B4C.hsd1.ma.comcast.net) (Client exited)
[21:29:52] *** concrete.mozilla.org sets mode: -M 
[21:31:03] *** Joins: Ralith (ralith@moz-77D578BD.wireless.sfu.ca)
[21:31:05] <steveklabnik> woot
[21:31:32] <Boreeas> Hmm, alright. It still strikes me as kinda weird, but I'll get used to it
[21:32:01] <rntz> the second x is just a different variable than the first x, that happens to have the same name
[21:32:05] <strcat> if only I knew what that mode setting did
[21:32:12] <rntz> although, I don't know why rust permits variable shadowing
[21:32:14] <strcat> +ntrf [5c#C5,7j#R5,3k#K5,10m#M5,5n#N5]:10
[21:32:26] <strcat> I guess we could make the spam thing not kick in so soon if someone could decipher that...
[21:33:02] <strcat> rntz: well most languages do afaik
[21:33:03] *** Quits: tikue (tkuehn@2557E599.66715431.D25A875A.IP) (Quit: tikue)
[21:33:06] *** Quits: spider-mario (spidermari@moz-2F72F6FF.dsl.quantic-telecom.net) (Input/output error)
[21:33:07] *** Joins: SiegeLord (siege@moz-CAF07B4C.hsd1.ma.comcast.net)
[21:33:15] <strcat> I know haskell does
[21:33:22] *** Quits: haard (fredrik@moz-6A86987C.dynamic.se.alltele.net) (Ping timeout)
[21:33:55] <rntz> strcat: "most languages do it" isn't a rationale :P
[21:34:07] <steveklabnik> ~~~ {.rust} <- this is the right thing, cmr ?
[21:34:16] <pcwalton> I like it because used well it can prevent bugs
[21:34:23] <cmr> steveklabnik: in docs? yes
[21:34:23] <strcat> rntz: we can stop shadowing with a lint warning
[21:34:24] *** Joins: tikue (tkuehn@2557E599.66715431.D25A875A.IP)
[21:34:30] <pcwalton> by shadowing you can prevent yourself from referring to something unwanted
[21:34:32] <rntz> pcwalton: you mean, by preventing access to a variable by shadowing it?
[21:34:37] <pcwalton> right
[21:34:42] <steveklabnik> cmr: thanks
[21:35:02] <rntz> that's true, but I think it sacrifices more in clarity of code than it's worth
[21:35:07] <pcwalton> some people find that distasteful, I'd be fine with a lint mode
[21:35:39] <santiago> Are let bindings mutable in rust? 
[21:35:44] <rntz> santiago: not by default
[21:35:47] <rntz> "let mut" for a mutable binding
[21:35:47] *** Quits: tikue (tkuehn@2557E599.66715431.D25A875A.IP) (Quit: tikue)
[21:35:49] <rntz> "let" for immutable
[21:36:05] *** Quits: tjc (tjc@A5087023.2354C43D.D8E68FF6.IP) (Quit: Places to go, people to annoy)
[21:38:24] <steveklabnik> r? https://github.com/mozilla/rust/pull/6841
[21:39:05] *** Joins: tikue (tkuehn@2557E599.66715431.D25A875A.IP)
[21:39:35] *** Quits: tikue (tkuehn@2557E599.66715431.D25A875A.IP) (Quit: tikue)
[21:39:49] *** Joins: tikue (tkuehn@2557E599.66715431.D25A875A.IP)
[21:40:01] *** Quits: azita (Azita@2557E599.66715431.D25A875A.IP) (Quit: azita)
[21:40:30] *** Quits: tikue (tkuehn@2557E599.66715431.D25A875A.IP) (Quit: tikue)
[21:40:57] *** Quits: jclements (jclements@2557E599.66715431.D25A875A.IP) (Quit: jclements)
[21:41:06] <strcat> rusti: 5
[21:41:07] -rusti- 5
[21:41:08] <fdr> r? https://github.com/mozilla/rust/pull/6833
[21:41:18] *** Joins: tikue (tkuehn@2557E599.66715431.D25A875A.IP)
[21:41:43] <steveklabnik> fdr: nice
[21:41:51] <fdr> well, the first one didn't work: flate complained
[21:41:56] *** Quits: ksev (DrunkenPan@745B767B.989A61DC.CA5B6332.IP) (Ping timeout)
[21:42:04] <fdr> so I surmise there's a dependency tracking problem with prelude:*
[21:42:08] *** Quits: doener (doener@moz-121949B3.unitymediagroup.de) (Quit: leaving)
[21:42:12] <cmr> fdr: the prelde changed
[21:42:28] <cmr> fdr: I already landed a cleanup, sorry!
[21:42:34] <fdr> how recently? I did some of this last night.
[21:42:43] <brson> erickt: ping
[21:42:59] <cmr> yesterday, but those changes only show up in stage1/2
[21:43:07] <cmr> stage0 still sees the old prelude
[21:43:57] <fdr> ah, I see, that was the reason for that conditional compilation.
[21:43:58] *** Joins: jclements (jclements@2557E599.66715431.D25A875A.IP)
[21:44:27] *** Quits: tikue (tkuehn@2557E599.66715431.D25A875A.IP) (Quit: tikue)
[21:45:20] *** Joins: tjc (tjc@A5087023.2354C43D.D8E68FF6.IP)
[21:45:20] *** ChanServ sets mode: +o tjc
[21:47:06] *** Quits: sankha93 (Instantbir@17806EDC.4198D8F2.8B6C1D65.IP) (Quit: Instantbird 1.4 -- http://www.instantbird.com)
[21:47:46] <fdr> cmr: I'm probably going to keep slugging at the warnings, you?
[21:48:03] <fdr> going over some of the unsafe ones that apparently may or may not be totally accurate.
[21:48:11] <cmr> they are also innaccurate
[21:48:20] <cmr> unsafe linter got more strict (safe code can't call unsafe methods)
[21:48:26] *** Quits: eatkinson (eatkinson@2557E599.66715431.D25A875A.IP) (Ping timeout)
[21:48:47] <cmr> I'm done with warning cleanup for now though
[21:49:35] <fdr> so, I don't quite understand the issue there, although I heard the whole thing was just redone.  What is inaccurate about the warnings?
[21:49:51] <fdr> also, cmr, I don't think you bumped the copyright numbers.
[21:50:13] *** Joins: ciferkey (ciferkey@moz-37B1CA4E.prvdri.fios.verizon.net)
[21:50:34] <cmr> fdr: they aren't unnecessary unsafes, they are needed because the code is calling unsafe methods
[21:50:42] *** Joins: snearch (snearch@moz-1D5B13B7.pool.mediaways.net)
[21:50:50] <cmr> yeah, I always forget copyright...
[21:50:54] *** Quits: ciferkey (ciferkey@moz-37B1CA4E.prvdri.fios.verizon.net) (Quit: ciferkey)
[21:51:17] <fdr> it's easy to forget...Postgres just bumps the entire thing with a script in one shot, FWIW
[21:51:22] *** Joins: eatkinson (eatkinson@2557E599.66715431.D25A875A.IP)
[21:51:27] <fdr> you can probably rebase my commit which has many of the same things to save a bit of time.
[21:51:34] *** Quits: tjc (tjc@A5087023.2354C43D.D8E68FF6.IP) (Quit: Places to go, people to annoy)
[21:51:47] <cmr> it's already running on the buildbot
[21:52:05] <fdr> well, one could just submit the copyright updates after the fact, as pedantic as it may seem.
[21:53:44] *** Joins: chadz (uid979@moz-A588D045.irccloud.com)
[21:54:02] <cmr> rusti: str::from_bytes([27, 91, 37, 63, 37, 112, 49, 37, 123, 56, 125, 37, 60, 37, 116, 51, 37, 112, 49, 37, 100, 37, 101, 37, 112, 49, 37, 123, 49, 54, 125, 37, 60, 37, 116, 57, 37, 112, 49, 37, 123, 56, 125, 37, 45, 37, 100, 37, 101, 51, 56, 59, 53, 59, 37, 112, 49, 37, 100, 37, 59, 109])
[21:54:04] -rusti- ~"\x1b[%?%p1%{8}%<%t3%p1%d%e%p1%{16}%<%t9%p1%{8}%-%d%e38;5;%p1%d%;m"
[21:54:06] <brson> I'm going to start bisecting the segfault on linux
[21:55:46] *** Quits: cowboyd (cowboyd@moz-1BD02A1E.sw.biz.rr.com) (Client exited)
[21:56:00] <cmr> brson: could it be an OOM?
[21:57:14] <strcat> cmr: no
[21:58:02] <strcat> really unlikely at least...
[21:58:15] *** Quits: Blub\w (wry@moz-E93CF12B.wireless.dyn.drei.com) (Quit: nn)
[21:59:38] <brson> cmr: I don't know
[22:00:19] <strcat> you just get a SIGKILL on OOM with the default settings
[22:00:43] *** Joins: ghrust (ghrust@moz-4EF5B6E5.rs.github.com)
[22:00:43] <ghrust> 01[13rust01] 15bors 04force-pushed 06auto from 14518a8d1 to 14784a849: 02http://git.io/N3iJvQ
[22:00:43] *** Parts: ghrust (ghrust@moz-4EF5B6E5.rs.github.com) ()
[22:00:43] *** Joins: ghrust (ghrust@moz-4EF5B6E5.rs.github.com)
[22:00:43] <ghrust> 01[13rust01] 15bors pushed 2 new commits to 06auto: 02http://git.io/9zna5g
[22:00:43] <ghrust> 13rust/06auto 147f410b3 15Felix S. Klock II: Attempt to get reuse of common code from multiple clones in different directories.
[22:00:43] <ghrust> 13rust/06auto 149bfe296 15bors: auto merge of #6836 : pnkfelix/rust/fsk-issue6805-ccache-rewrite-basedir, r=catamorphism...
[22:00:44] *** Parts: ghrust (ghrust@moz-4EF5B6E5.rs.github.com) ()
[22:00:48] <cmr> well when is OOM triggered? I'm thinking it's just running out of VM, malloc returns 0
[22:01:23] <cmr> fdr: see http://buildbot.rust-lang.org/builders/auto-linux/builds/1498/steps/test/logs/stdio
[22:01:26] <bblum> graydon: nmatsakis: https://github.com/mozilla/rust/wiki/Proposal-for-closure-reform
[22:01:38] <cmr> fdr: should probably submit your patch instead :)
[22:01:40] <strcat> cmr: we have asserts in most places though
[22:01:46] <strcat> there's a missing check on a few forks
[22:02:46] <strcat> rusti: 5
[22:02:52] -rusti- timeout triggered!
[22:02:57] <strcat> rusti: 5
[22:03:00] -rusti- 5
[22:03:16] <strcat> rusti: 5
[22:03:17] -rusti- Killed
[22:03:17] -rusti- application terminated with error code 137
[22:03:37] *** Quits: saml (sam@moz-14C16814.cst.lightpath.net) (Quit: Leaving)
[22:04:32] <strcat> cmr: not sure what it does on running out of VM ;\
[22:05:44] <bblum> graydon: nmatsakis: i realize there's a lot of stuff there; the main thing that's my "counterproposal" is ideas IV-4 and IV-7, which I prefer to the "remove ~fn entirely" idea.
[22:05:53] <graydon> bblum: "In all of these cases (except 5)"
[22:05:57] <graydon> there's nothing that says "5"
[22:06:21] <bblum> oops, dammit
[22:06:34] <bblum> it renumbered my list after the break :P
[22:06:39] <bblum> 5 is IV-B-1
[22:07:43] <bblum> fixed
[22:07:47] <graydon> I believe both Trait and fn would be not-copyable
[22:07:56] <graydon> in the dynamic-sized types proposal
[22:08:03] <graydon> (perhaps all dynamic sized types?)
[22:08:28] <bblum> it might also be nice to have trait bounds
[22:08:41] *** Joins: tikue (tkuehn@2557E599.66715431.D25A875A.IP)
[22:08:57] <fdr> (wal-e)fdr@sputnik:~/codes/shogun$ ./specs
[22:08:57] <fdr> ./specs
[22:08:57] <fdr> Run options: exclude {:vagrant=>true}
[22:08:57] <fdr> ...............................................................F..............****...........................................................................***FF.....................................................................................................................................................................................................................................................................................................
[22:09:00] <fdr> Pending:
[22:09:03] <fdr>   Shogun::Admin POST to servers/:id/{stop,terminate} forbids terminating servers with bad/absent CSRF tokens
[22:09:06] <fdr>     # Rack::Test::Methods fails to read gzipped response (?)
[22:09:09] <fdr>     # ./spec/web/admin_spec.rb:178
[22:09:10] *** Quits: fdr (user@B280A391.27376607.189F3E15.IP) (Client exited)
[22:09:17] <strcat> huh
[22:09:21] *** Joins: azita (Azita@2557E599.66715431.D25A875A.IP)
[22:09:25] <rntz> ... well that was strange
[22:09:50] <strcat> probably an accident
[22:10:10] <bblum> graydon: so you could copy a "&Trait:Clone" or whatever, but yes, a trait can also have a noncopyable inside that you wouldn't know about
[22:10:16] <strcat> some silly irc clients don't warn when you try to paste 1000 lines :)
[22:10:38] <bblum> graydon: however, niko pointed out that with traits, the "&self" type prevents you from using &Trait to exploit the same bug as with &fn
[22:10:46] <graydon> in any case, this will take a while to digest, but off the cuff: we're _super late_ in the design cycle to be doing anything experimental; cutting is better than adding; and I'm most comfortable with niko's suggestion that we just axe "closures that own their environment" altogether and move to a model with by-ref-env and no-env, and use traits and macros to fill in other cases.
[22:10:50] *** Joins: fdr (user@B280A391.27376607.189F3E15.IP)
[22:10:58] <steveklabnik> what is the apostrophe in 'self ?
[22:10:59] <fdr> yeah, poor erc.
[22:11:04] <fdr> sorry about that
[22:11:18] <graydon> if that's possible while still fixing the unsoundness bug (I'm not sure if they're related), then that's my preference
[22:11:18] <cmr> steveklabnik: lifetime notation
[22:11:46] <steveklabnik> ah
[22:12:00] <steveklabnik> i haven't done too much research into when lifetimes are needed explicitly
[22:12:39] *** Quits: donri (dag@moz-9BB61102.tbcn.telia.com) (Client exited)
[22:12:42] <rntz> graydon: it's late in the design cycle to be experimenting, but aren't you close to 1.0? if you choose something bad now, it seems likely that you're stuck with it for 1.0.
[22:13:02] <cmr> rntz: no, not really
[22:13:09] <bblum> yeah, i also don't think of this as experimental
[22:13:13] <rntz> cmr: ?
[22:13:16] <bblum> i think of it as "fixing the closure problem once and for all"
[22:13:24] <bblum> "and doing it right while we're at it"
[22:13:25] <fdr> cmr: yeah, I had to deal with some of the fallout of the test cycle too...
[22:13:29] <fdr> I don't understand how amended patches work though
[22:13:32] <bblum> but, to be more diplomatic,
[22:13:34] <fdr> will the buildfarm try again?
[22:13:42] <bblum> graydon: yes, that will fix the bug (and i like it too; you'll note it made top 3 on my preference list), although i think that once fns and kind bounds are also important (and orthogonal)
[22:13:47] <cmr> fdr: no, unfortunately not. needs to be re-r+'d
[22:14:08] <cmr> rntz: not all that close to 1.0. need to hit at least the backwards-compat milestone for that I think
[22:14:43] <cmr> fdr: what I think happened is the unused-import lint doesn't look into tests because they aren't compiled because they're behind a #[cfg(test)]
[22:14:56] <bblum> cmr: well, either way, we are trying to wind down the amount of feature fluctuation
[22:14:56] *** Joins: caitp (caitp@moz-9FE842F.cpe.net.cable.rogers.com)
[22:14:59] <bblum> all of us want this
[22:15:04] <fdr> cmr: some of these I caught. The only one that seemed to bust things up was prelude::* in flate.
[22:15:09] <steveklabnik> is there _any_ official docs on lifetimes?
[22:15:10] <bblum> we just sometimes conflict on which featureset we want to converge on ;)
[22:15:23] <fdr> cmr: I was going to do a conservative one first to thin the field.
[22:15:32] <cmr> steveklabnik: just http://static.rust-lang.org/doc/tutorial-borrowed-ptr.html afaik
[22:15:36] <fdr> as-is there are so many warnings that the odds of me seeing if I introduce a new one are very close to zero.
[22:15:48] <bblum> steveklabnik: http://smallcultfollowing.com/babysteps/blog/2012/07/19/yet-another-tutorial-on-borrowed-pointers/
[22:15:52] <cmr> fdr: yeah... it might be wroth just waiting for a new snapshot
[22:16:26] <cmr> fdr: otoh, test-only imports should be in the test module
[22:16:29] <steveklabnik> cmr: thanks.
[22:16:38] <steveklabnik> bblum: yeah, blog posts are nice, but official docs are nicer :)
[22:16:40] <fdr> heh, I just stuffed in the conditional compilation in some spots.
[22:16:47] *** Quits: jaen (jaen@moz-E0979827.copit.pl) (Ping timeout)
[22:16:49] <cmr> steveklabnik: the official tutorial was adapted from the blog
[22:17:00] <steveklabnik> totally
[22:17:06] <steveklabnik> i'm just thinking about the 'i'm new to Rust' experience
[22:17:08] <bblum> steveklabnik: http://static.rust-lang.org/doc/tutorial-borrowed-ptr.html largely the same content
[22:17:11] <graydon> rntz: I'm not saying "don't fix", I'm saying that when looking at N fixes, I am much more sympathetic to fixes that take the form of deletions-of-concepts, even if they lose a couple lesser-used features along the way, than fixes that add more rules or concepts.
[22:17:20] <steveklabnik> there is no mention of lifetimes in the reference manual
[22:17:27] <steveklabnik> seems like something to fix....
[22:18:18] *** Joins: jaen (jaen@moz-E0979827.copit.pl)
[22:18:36] <bblum> graydon: in the proposal i tried to analyse pros/cons based on how many new concepts/type-rules each idea introduced... although for the most part, i think all of these are mostly minor tweaks to existing rules (and representations)
[22:18:54] <bblum> with the exception of kind bounds on closures, which is a new feature, but i think one that we really need
[22:19:00] <SiegeLord> What's the maximum MinGW version Rust supports?
[22:19:21] <graydon> bblum: do we need them if there are no closures-that-own-environments?
[22:19:32] <bblum> yeah, :Const and :Clone
[22:19:39] *** Joins: jaen1 (jaen@moz-AEEB3C04.play-internet.pl)
[22:19:52] <bblum> both let you do nice stuff like putting functions in ARCs and spawning a bunch of tasks with them
[22:20:05] *** Quits: jaen (jaen@moz-E0979827.copit.pl) (Ping timeout)
[22:20:07] <bblum> i mean, "need"; we could get by without; it could well be a post-1.0 feature
[22:20:27] <bblum> oneshot functions should not be a post-1.0 feature though
[22:20:35] <graydon> wait, :Const means you-can-freeze-it, no?
[22:20:40] <bblum> yeah
[22:20:47] <bblum> "won't mutate its environment"
[22:21:07] <bblum> it also indicates a stack closure that you can copy (w.r.t the recursion bug)
[22:21:13] <strcat> graydon: yeah, means it respects mutability rules (can't mutate it through &)
[22:21:43] <strcat> so, not Cell, @mut, RcMut, RW ARCs
[22:21:47] <bblum> ah, i will annotate the proposal with which stuff can be post-1.0 :)
[22:22:12] <graydon> wait, why would you ever have a closure with a by-ref environment (one it does not own) that you wanted to freeze?
[22:22:17] <graydon> what would that mean?
[22:22:44] <bblum> that might mean it won't attempt to mutate any of its upvars
[22:23:15] <graydon> where would you put one?
[22:23:33] <graydon> (where this fact would matter)
[22:23:43] *** Quits: azita (Azita@2557E599.66715431.D25A875A.IP) (Quit: azita)
[22:23:49] <bblum> it would matter if you try to copy a stack closure, as in the recursion thing niko made
[22:23:57] <graydon> I very rarely, if ever, store a &fn into a structure at all. they move through variables, mostly
[22:24:01] <SiegeLord> Also... if there's a maximum, why does it exist?
[22:24:04] <bblum> it would not be legal to copy a stack closure if it didn't have :Const
[22:24:35] <graydon> why?
[22:24:40] <strcat> SiegeLord: well I don't think there are many people testing new versions or working on support
[22:25:05] <bblum> graydon: because that's what let niko break soundness in "the case of the recurring closure"
[22:25:30] <SiegeLord> Hmm... well, I guess I probably won't be testing it on Windows just yet, so I'll just install 4.7 for now
[22:25:38] <SiegeLord> Maybe somebody will fix it by year's end
[22:25:41] <bblum> (well, it could have :Clone instead of :Const, somehow, and that would be fine, but i mean if it had neither)
[22:25:51] <strcat> graydon: you could make it capture @mut Option<fn> and then set it to itself externally?
[22:25:56] <strcat> I don't really know if that's the problem.
[22:26:33] <bblum> graydon: think of it like this: currently, &fn() with a mutable environment is an exploit that lets you mutate through "&&mut T", which you cannot do without closures
[22:26:45] <bblum> saying &fn:Const() means that there will be no "implicit &mut" inside
[22:26:54] *** Quits: Ralith (ralith@moz-77D578BD.wireless.sfu.ca) (Ping timeout)
[22:27:49] <graydon> bblum: ok .. I thought the copying-a-closure stuff proposed in that blog post was sort of hypothetical anyways; the main solution was just to make the problematic closures non-copyable
[22:28:21] *** Quits: BitPuffin (quassel@moz-8370D1B9.bredband.comhem.se) (Connection reset by peer)
[22:28:21] *** Joins: infynyxx (infynyxx@DB780A29.749BA1D.DCC373F0.IP)
[22:28:32] <bblum> right; the thing is, without kind bounds, identifying which closures are "problematic" is pretty much "all of them"
[22:28:47] *** Quits: jdm (jdm@F2D29657.F60B0462.67AC9B1.IP) (Quit: Lost terminal)
[22:28:51] <graydon> I don't know that we need a copyable by-ref closure, any more than a once closure; I am not clear on which patterns need them and whether they can't be emulated well enough with a trait that owns a no-env pointer and a data value to pass in.
[22:29:09] *** Joins: BitPuffin (quassel@moz-8370D1B9.bredband.comhem.se)
[22:30:03] <bblum> hmm
[22:30:06] <graydon> look at this from a scheduling perspective. suppose your number 1 and number 2 priorities were "close all soundness bugs" and "stop making changes as soon as possible".
[22:30:17] *** jaen1 is now known as jaen
[22:30:23] <bblum> right, yes
[22:30:27] *** Quits: jensnockert (jensnocker@moz-8BE55278.customer.t3.se) (Input/output error)
[22:30:30] <graydon> (by "maing changes" I literally mean "having patches you're editing and landing", not just thinking about)
[22:30:34] <graydon> *making
[22:31:01] *** Quits: BitPuffin (quassel@moz-8370D1B9.bredband.comhem.se) (Connection reset by peer)
[22:31:26] <bblum> yeah, i am about to write a section of the proposal which thinks about this
[22:31:29] <graydon> k
[22:31:42] <graydon> I don't mean to push back _too_ hard, just to make clear: those are my current #1 and #2 priorities :)
[22:31:44] <pcwalton> I edited the proposal
[22:31:45] *** Quits: eholk (eholk@moz-3D703D55.uconnect.utah.edu) (Quit: eholk)
[22:31:48] <pcwalton> to talk about custom smart pointers
[22:31:49] *** Quits: passcod (passcod@moz-5BCF5019.passcod.name) (Ping timeout)
[22:31:58] <pcwalton> which to me is much of the reason I like niko's proposal
[22:32:05] <pcwalton> it makes ~ and @ not special in any way
[22:32:25] <mark_edward> would anyone like to look at some code I wrote on Github?
[22:32:32] *** Quits: cantsin (cantsin@moz-F99612CC.members.linode.com) (Ping timeout)
[22:32:36] <pcwalton> they both have exactly the same ability to create environments (none)
[22:32:39] <mark_edward> I'm trying to learn Rust and would like a few pointers
[22:32:44] *** Joins: BitPuffin (quassel@moz-8370D1B9.bredband.comhem.se)
[22:32:50] *** Quits: ziad (ziad@moz-5003F925.members.linode.com) (Ping timeout)
[22:32:50] *** Quits: yardena (yardena@moz-A95F12B1.members.linode.com) (Ping timeout)
[22:32:54] <pcwalton> no pun intended? :)
[22:32:59] *** Quits: jld (jld@moz-B94C75AD.xlerb.net) (Ping timeout)
[22:32:59] <mark_edward> or point me to a place where i could get such criticism, if this isn't the right place
[22:33:02] * graydon was resisting the urge
[22:33:06] <bblum> rust will give you a few pointers for sure
[22:33:10] *** Quits: olsonjeffery (pf@moz-9E9CF15C.members.linode.com) (Ping timeout)
[22:33:14] <mark_edward> at least 3 right
[22:33:21] *** Quits: BigEndian (hurp@moz-1B6DD81E.members.linode.com) (Ping timeout)
[22:33:21] *** Quits: Eridius (kevin@moz-533B0DB4.us) (Ping timeout)
[22:33:25] <graydon> mark_edward: do you have code you want us to look at, or are you looking for docs?
[22:33:29] <EXetoC> but only if you ask nicely
[22:33:45] <mark_edward> I have the code; here it is on github https://github.com/MarkJr94/rusty_feds
[22:33:46] <bstrie> mark_edward: let's see it!
[22:34:11] <bblum> graydon: yeah, i am trying to be conscious of these important concerns
[22:34:46] <bblum> like rntz says though, it is important not to commit to a "weird" solution for 1.0 that will make things clunky forever
[22:34:51] <graydon> k, thanks. I know most reasonable languages with affine types have one-shot closures. but I bet few of them have no-env closures.
[22:34:55] *** Quits: BitPuffin (quassel@moz-8370D1B9.bredband.comhem.se) (Ping timeout)
[22:35:00] <strcat> http://i.imgur.com/MWDwoIQ.png if only this could be auto-generated.
[22:35:15] *** Joins: BitPuffin (quassel@moz-8370D1B9.bredband.comhem.se)
[22:35:24] *** Joins: ziad (ziad@moz-5003F925.members.linode.com)
[22:35:29] <bblum> fortunately, with niko's latest idea (IV-A-3), i think it is pretty easy to have a sane 1.0
[22:35:30] *** Quits: BitPuffin (quassel@moz-8370D1B9.bredband.comhem.se) (Client exited)
[22:35:46] <bblum> and if we want then we can add safe ~fn()s and @fn()s back post-1.0 or something
[22:35:56] *** Joins: olsonjeffery (pf@moz-9E9CF15C.members.linode.com)
[22:36:02] *** Joins: BigEndian (hurp@54D39ED9.6E5734F0.12D11A7A.IP)
[22:36:43] <bstrie> mark_edward: what version of rust are you using?
[22:37:02] *** Joins: Eridius (kevin@moz-533B0DB4.us)
[22:37:37] <mark_edward> 0.6
[22:37:41] *** Joins: passcod (passcod@moz-5BCF5019.passcod.name)
[22:37:51] <mark_edward> i compiled from the static snapshot like the tutorial said
[22:38:07] *** Joins: barosl (barosl@1E71221E.C81E10FB.7544CABF.IP)
[22:38:09] *** Joins: cantsin (cantsin@moz-F99612CC.members.linode.com)
[22:38:13] <bstrie> mark_edward: a lot of the stuff that you're importing like task::spawn and comm::stream are imported by default now, so you don't need those `use` statements
[22:38:18] *** Joins: yardena (yardena@moz-A95F12B1.members.linode.com)
[22:38:22] *** Quits: olsonjeffery (pf@moz-9E9CF15C.members.linode.com) (Ping timeout)
[22:38:45] <bstrie> mark_edward: also congratulations on figuring out how to do file i/o with our current io lib :P
[22:38:59] <mark_edward> yeah it was pretty confusing...
[22:39:05] *** Quits: eatkinson (eatkinson@2557E599.66715431.D25A875A.IP) (Quit: eatkinson)
[22:39:07] <bstrie> it's getting a revamp in the future
[22:39:49] *** Joins: BitPuffin (quassel@moz-8370D1B9.bredband.comhem.se)
[22:39:56] *** Quits: cantsin (cantsin@moz-F99612CC.members.linode.com) (Ping timeout)
[22:39:59] *** Joins: eatkinson (eatkinson@2557E599.66715431.D25A875A.IP)
[22:40:14] *** Quits: ziad (ziad@moz-5003F925.members.linode.com) (Ping timeout)
[22:40:28] <mark_edward> will there ever be any sort of stream-like functionality? in every language I miss C++ iostreams...
[22:41:05] *** Joins: cantsin (cantsin@moz-F99612CC.members.linode.com)
[22:41:34] <strcat> mark_edward: what do you mean by streams?
[22:41:40] *** Quits: Eridius (kevin@moz-533B0DB4.us) (Ping timeout)
[22:41:46] <strcat> iostreams aren't much different than the file objects in other languages
[22:42:01] <strcat> stringstreams exist in other languages too in different forms (io.StringIO and io.BytesIO in python)
[22:42:40] <engla> there's going to be IO interfaces so different kinds of abstractions can implement Reader and Writer at least
[22:42:56] <mark_edward> the automatic type interpretation and chaining is what i miss, i guess
[22:42:58] *** Quits: BigEndian (hurp@54D39ED9.6E5734F0.12D11A7A.IP) (Ping timeout)
[22:43:09] <mark_edward> cout << int << str << float << custom_struct << endl
[22:43:24] <strcat> mark_edward: but in reality you'll have spaces or newlines between them
[22:43:38] <strcat> so it's uglier than a type-safe format string with type inference imo
[22:43:57] *** Joins: jack (jack@2557E599.66715431.D25A875A.IP)
[22:44:05] <mark_edward> you might be right about that. i fell back on printf for some complex things.
[22:44:20] <mark_edward> and rust's fmt! is cool. did you get the idea from Go or the other way around
[22:44:23] *** Quits: cantsin (cantsin@moz-F99612CC.members.linode.com) (Ping timeout)
[22:44:25] *** Quits: passcod (passcod@moz-5BCF5019.passcod.name) (Ping timeout)
[22:44:34] <steveklabnik> if a pre-condition in my fn is violated, what should I do? fail!?
[22:44:46] <strcat> mark_edward: there are other languages with that feature predating go/rust
[22:44:49] <erickt> brson: ping
[22:45:00] <steveklabnik> as in, "this function takes two strings, they must be the same length"
[22:45:09] <benh> I'd say fail
[22:45:17] <mark_edward> oh ok
[22:45:29] <mark_edward> bstrie: did you have any other pointers?
[22:45:52] <strcat> rust needs a printf! for Writers not forcing an allocation of an intermediate string
[22:45:53] *** Quits: dmart (Mibbit@moz-A103DCA.cg.shawcable.net) (Quit: http://www.mibbit.com ajax IRC Client)
[22:45:59] <benh> is fmt! pretty much sprintf plus %? which prints the thing like a literal would look?
[22:46:07] <steveklabnik> mark_edward: i wrote something about that in D a while back: http://wiki.xomb.org/index.php?title=Start_to_Finish:_Printing_to_the_Screen
[22:46:11] <strcat> benh: well, asprintf
[22:46:12] *** Joins: passcod (passcod@moz-5BCF5019.passcod.name)
[22:46:15] *** Joins: BigEndian (hurp@moz-1B6DD81E.members.linode.com)
[22:46:15] <benh> yeah
[22:46:19] <steveklabnik> kprintf! is kinda like printf(fmt!
[22:46:26] *** Joins: ion (ion@heh.fi)
[22:46:37] *** Joins: Eridius (kevin@moz-533B0DB4.us)
[22:46:38] <steveklabnik> strcat: +1 on some sort of printf!
[22:46:42] <strcat> benh: but yeah, clang/gcc can type-check format strings so... they are just missing inference of some sort and genericity
[22:46:43] <benh> I mean, ideally there ought to be some way to ask the value to prettyprint itself, optionally passing along some of the bits between the % and the ?
[22:46:45] <brson> erickt: does your llvm pull request depend on updating llvm to trunk, or can I just take the .ll parsing patch? I've got several llvm updates queued but the upgrade isn't working on windows. Can I just apply the patches without doing the upgrade to trunk?
[22:46:48] <bstrie> mark_edward: sorry, had to let the dog out. are you aware of `do` notation?
[22:46:58] <strcat> benh: %s should work for anything with ToStr
[22:47:00] <strcat> but...
[22:47:04] <strcat> really we need to stop allocating so many strings.
[22:47:10] *** Joins: cantsin (cantsin@moz-F99612CC.members.linode.com)
[22:47:12] *** Quits: vmx (vmx@moz-7818230A.pools.arcor-ip.net) (Quit: Leaving)
[22:47:14] *** Joins: jld (jld@moz-B94C75AD.xlerb.net)
[22:47:21] <strcat> conversion to printable form shouldn't have to allocate unless you use a str as a Writer
[22:47:22] <mark_edward> I've seen it, but I really have no idea how to use it
[22:47:28] <mark_edward> is it for spawning?
[22:47:42] <strcat> mark_edward: it passes a closure as the last argument but lets you write it as a block
[22:47:44] <bstrie> mark_edward: it's really simply
[22:47:52] *** Joins: olsonjeffery (pf@moz-9E9CF15C.members.linode.com)
[22:48:17] <erickt> brson: If I remember correctly, it compiled fine against the llvm version rust is pinned against.
[22:48:57] <erickt> brson: However, I believe there will be a merge conflict when we update llvm
[22:49:08] *** Quits: BigEndian (hurp@moz-1B6DD81E.members.linode.com) (Ping timeout)
[22:49:13] <bstrie> mark_edward: https://gist.github.com/bstrie/5681872
[22:49:35] <bstrie> mark_edward: it's really just a way to make using closures look more like using a typical control structure
[22:49:35] *** Quits: yardena (yardena@moz-A95F12B1.members.linode.com) (Ping timeout)
[22:49:42] *** Quits: passcod (passcod@moz-5BCF5019.passcod.name) (Ping timeout)
[22:49:42] *** Quits: cantsin (cantsin@moz-F99612CC.members.linode.com) (Ping timeout)
[22:49:52] *** Joins: yardena (yardena@moz-A95F12B1.members.linode.com)
[22:49:55] *** Quits: jld (jld@moz-B94C75AD.xlerb.net) (Ping timeout)
[22:50:07] <bstrie> mark_edward: really it's a matter of style, you don't have to use it. just wanted you to be aware of it :)
[22:50:11] *** Joins: cantsin (cantsin@moz-F99612CC.members.linode.com)
[22:50:44] *** Joins: Ralith (ralith@moz-50F3C77.vc.shawcable.net)
[22:50:48] <mark_edward> Ah okay, thanks! So it basically lets you take the closures out of the argument list
[22:51:05] <bstrie> yes, but only if the closure is the last argument to the function
[22:51:15] *** Joins: BigEndian (hurp@moz-1B6DD81E.members.linode.com)
[22:51:17] <bstrie> which is why any function in rust that takes a closure makes it the last argument
[22:51:25] <enticeing> i've been dreaming up a programming language
[22:51:29] <bstrie> at least, idiomatically
[22:51:41] *** Parts: enticeing (user@B2F7F54B.E4834407.EAAB5301.IP) (ERC Version 5.3 (IRC client for Emacs))
[22:51:42] <mark_edward> Makes sense
[22:52:12] <bstrie> and nesting {{}} looks a bit nicer than javascript's ({({});});
[22:52:14] *** Joins: jld (jld@moz-B94C75AD.xlerb.net)
[22:52:22] *** Quits: judder (maradukewa@385DDD8F.206937E4.78E362FE.IP) (Ping timeout)
[22:52:24] <mark_edward> how fixed is the standard library? It seems really big (in terms of # of functions)
[22:52:32] <mark_edward> but missing a lot of things
[22:52:50] <mark_edward> like the weirdness I had to do to get natural log of machine dependent float
[22:52:57] <bstrie> mark_edward: if you have ideas for libraries that should be in the stdlib, feel free to file a bug
[22:53:05] <strcat> mark_edward: it's in a very early state
[22:53:07] <cmr> mark_edward: not fixed at all right now
[22:53:10] *** Quits: fdr (user@B280A391.27376607.189F3E15.IP) (Client exited)
[22:53:13] *** Joins: passcod (passcod@moz-5BCF5019.passcod.name)
[22:53:41] <caitp> question, if an attribute/annotation is applied to a module, does that also apply it to every item within that module?
[22:53:47] <cmr> caitp: no
[22:53:58] *** Quits: infynyxx (infynyxx@DB780A29.749BA1D.DCC373F0.IP) (Client exited)
[22:54:10] <caitp> mmk
[22:54:33] *** Quits: SiegeLord (siege@moz-CAF07B4C.hsd1.ma.comcast.net) (Connection reset by peer)
[22:54:39] <mark_edward> the float thing i mentioned seems to be fixed in master
[22:54:48] *** Quits: jld (jld@moz-B94C75AD.xlerb.net) (Ping timeout)
[22:54:53] <mark_edward> but i used this as a workaround:
[22:54:53] <mark_edward> let ln = |f: float| -> float { f64::ln(f as f64) as float };
[22:54:58] <cmr> mark_edward: protip: development happens on the incoming branch
[22:55:06] <cmr> (for now)
[22:55:07] <bstrie> mark_edward: `for` notation is almost the same as `do`, and in this line: `for upaths.each() |path| {` you can omit the empty () in the special case where the closure is the only argument to the function
[22:55:12] <bblum> tikue: https://github.com/mozilla/rust/wiki/Proposal-for-closure-reform
[22:55:50] <mark_edward> cool.
[22:56:06] <mark_edward> i like anything that saves keystrokes
[22:57:15] *** Joins: jld (jld@moz-B94C75AD.xlerb.net)
[22:58:07] *** Joins: SiegeLord (siege@moz-CAF07B4C.hsd1.ma.comcast.net)
[22:58:15] *** Joins: devbug (quassel@moz-E1DE087C.bchsia.telus.net)
[22:59:32] <bstrie> mark_edward: are you aware of pattern matching?
[22:59:39] <mark_edward> yes
[22:59:44] <mark_edward> i use it in a few places
[22:59:50] <strcat> graydon: https://github.com/mozilla/rust/pull/6845 r?
[23:00:10] <bstrie> mark_edward: there's one case where you're checking a Result type where you could be using it: https://gist.github.com/bstrie/5681931
[23:00:21] *** Quits: bent (chatzilla@moz-C03D0C61.vlan426.asr1.sfo1.gblx.net) (Quit: ChatZilla 0.9.90-rdmsoft [XULRunner 18.0.2/20130201065344])
[23:01:34] <mark_edward> that does seem more convenient
[23:01:47] <graydon> nice, thanks
[23:01:58] <mark_edward> is there a reason why the file flags don't use the bitwise or trait
[23:02:06] <mark_edward> and are passed as a vector?
[23:02:15] <bstrie> mark_edward: there's no good reason for anything in the io module :)
[23:02:23] <erickt> haha
[23:02:34] <graydon> strcat: bonus points, modify getopt to emit completion tables. double-bonus: zsh and bash both.
[23:02:37] <bstrie> libs are messy while the language stabilizes, we can only endure
[23:02:50] <cmr> io is particularly bad though
[23:03:02] <mark_edward> cool . is there an estimated timetable for rust reaching 1.0?
[23:03:04] <cmr> I think a vector of flags is a good idea though
[23:03:09] <bstrie> mark_edward: "before the end of the year"
[23:03:11] *** Joins: eholk (eholk@moz-3D703D55.uconnect.utah.edu)
[23:03:11] <mark_edward> i plan to keep using it in the meantime
[23:03:21] <cmr> bstrie: which year? :)
[23:03:24] <mark_edward> Cool! didn't think it be so soon
[23:03:30] <bstrie> cmr: good question, hopefully this one!
[23:03:33] <strcat> graydon: heh, it's a pain though because zsh ones usually have single-line descriptions and the --help has multi-line
[23:03:47] *** Joins: ghrust (ghrust@moz-4EF5B6E5.rs.github.com)
[23:03:47] <ghrust> 01[13rust01] 15bors merged 06auto into 06incoming: 02http://git.io/9zna5g
[23:03:47] *** Parts: ghrust (ghrust@moz-4EF5B6E5.rs.github.com) ()
[23:03:54] <mark_edward> cmr: why is it better? it seems like allocating more than is needed
[23:04:03] <steveklabnik> super noob questions today from me :)
[23:04:04] <steveklabnik> http://static.rust-lang.org/doc/core/u8.html#implementation-of-bitxort-t-for-t
[23:04:05] <mark_edward> *more memory
[23:04:06] <cmr> mark_edward: more flexible, especially for windows
[23:04:10] <steveklabnik> what import do i write to get that? on 0.6
[23:04:16] <strcat> graydon: I guess at least the switches should be automated though
[23:04:32] <strcat> hard to teach it "this switch takes urls" generically
[23:04:33] <steveklabnik> i tried core::u8::BitXor but that doenst work
[23:05:00] <bstrie> steveklabnik: I'd think it's one of those impls that just appears on all types, perhaps it just isn't public?
[23:05:29] <steveklabnik> oh, no, it's because i'm an idiot and in THAT tab those docs are for incoming
[23:05:37] <bstrie> haha
[23:05:37] <steveklabnik> that doesn't exist on 0.6
[23:05:42] <bblum> man, i really like the idea that fn:Clone() and fn() could be used instead of adding the 'once' keyword
[23:05:58] <steveklabnik> bstrie: thanks though :)
[23:06:00] <bstrie> if we can actually get away with not having once, that would be sweet
[23:06:00] <bblum> it's so theoretically pretty, but it's less future-proof than the 'once' keyword (it can't be added post-1.0)
[23:06:21] <bstrie> bblum: we can still reserve it! along with "be"!
[23:06:35] <bstrie> trust me, TCE will be ready in time for rust 17
[23:06:42] *** Joins: ghrust (ghrust@moz-4EF5B6E5.rs.github.com)
[23:06:42] <ghrust> 01[13rust01] 15bors pushed 0 new commits to 06auto: 02http://git.io/f0Exkg
[23:06:42] *** Parts: ghrust (ghrust@moz-4EF5B6E5.rs.github.com) ()
[23:06:43] *** Joins: ghrust (ghrust@moz-4EF5B6E5.rs.github.com)
[23:06:43] <ghrust> 01[13rust01] 15bors pushed 2 new commits to 06auto: 02http://git.io/Y7_9GA
[23:06:43] <ghrust> 13rust/06auto 142bed5dc 15Graydon Hoare: rustc: change 'use' to 'add' in error message, fix #2994
[23:06:43] <ghrust> 13rust/06auto 14308774e 15bors: auto merge of #6340 : graydon/rust/issue-2994, r=graydon
[23:06:44] *** Parts: ghrust (ghrust@moz-4EF5B6E5.rs.github.com) ()
[23:07:36] <lkuper> good ol `be`
[23:07:44] <bstrie> mark_edward: otherwise your code seems superficially good and idiomatic, you really seem to be a fan of implicit returns :P
[23:07:50] <cmr> What is be and TCE?
[23:08:00] <bblum> bstrie: yeah, we can reserve 'once', but we can't reserve "fn:Clone()"
[23:08:03] <lkuper> cmr: tail-call elimination
[23:08:12] <cmr> ah
[23:08:17] <bstrie> cmr: `be` is like `return` if you want tail-call-elimination. theoretically.
[23:08:23] <bstrie> past-theoretically
[23:08:37] <lkuper> cmr: `be` is a dearly-departed keyword.  it was supposed to mean "this is in tail position", or something.
[23:08:55] <mark_edward> bstrie: implicit returns are really useful in if expressions and matches and stuff though
[23:08:56] <bblum> fn foo() { ... be bar(); }
[23:08:58] <strcat> lkuper: it's still reserved though
[23:09:03] <benh> it's basically static_assert!("tail call optimization happens here");
[23:09:16] <cmr> heh
[23:09:36] <strcat> rusti: let be = 5; let bee = "bzzz";
[23:09:37] -rusti- foo.rs:8:13: 8:15 error: `be` is a reserved keyword
[23:09:37] -rusti- foo.rs:8          let be = 5; let bee = "bzzz";
[23:09:37] -rusti-                       ^~
[23:09:37] -rusti- application terminated with error code 101
[23:09:38] <bstrie> mark_edward: right, I just don't remember seeing you use an explicit return anywhere at all :)
[23:10:14] *** Joins: judder (maradukewa@385DDD8F.206937E4.78E362FE.IP)
[23:10:32] <bstrie> mark_edward: what languages are you familiar with?
[23:10:53] <Boreeas> I try to use implicit returns whenever possible. Explicit returns in my code are usually warning signs that I might need to restructure it.
[23:11:07] <mark_edward> in order of familiarity C++,Java,C,Python,Haskell,Rust
[23:11:27] <mark_edward> C# is somewhere there too, but i don't use windows or mono
[23:11:36] <jclements> Boreeas: +1
[23:11:39] <mark_edward> so i basically just know syntax and stuff like that
[23:11:39] <bstrie> mark_edward: congratulations, you're now one of the world's foremost rust experts!
[23:11:45] *** Joins: jgilbert (jgilbert@2557E599.66715431.D25A875A.IP)
[23:11:48] <cmr> hah
[23:11:56] <benh> :D
[23:12:02] <strcat> bstrie: no one will beat bors.
[23:12:07] <bstrie> bors is unstoppable
[23:12:08] <cmr> yeah that bors guy
[23:12:10] <mark_edward> i'm going to create a little award certificate and make it my wallpaper
[23:12:10] <Eridius> bstrie: do we have a sekrit club with a handshake?
[23:12:11] <cmr> crazy good
[23:12:18] *** Joins: MaikKlein (maik@moz-AC9459D8.dip0.t-ipconnect.de)
[23:12:23] <bstrie> Eridius: yes but you're not invited! you are a ragamuffin
[23:12:27] <Eridius> :'(
[23:12:44] <jclements> Eridius: no, we just all share a password.
[23:12:49] <jclements> Actually, that's icky. sorry.
[23:12:59] <Eridius> practice clean password hygene
[23:13:07] <Eridius> always use latex when handling someone else's password
[23:13:13] <bstrie> every time you share a password, you're logging in as everyone that person has ever logged in as
[23:13:16] <strcat> http://osrc.dfm.io/bors
[23:13:23] <strcat> bors is a heavy hitting Rust expert (one of the top 1% most active Rust users) who would rather be commenting on your commits instead of pushing code. bors is a nine-to-fiver who seems to work best in the mid-afternoon. 
[23:13:32] <bstrie> yes, was very amused by that
[23:13:34] <benh> "It seemsâ€”from their activity streamsâ€”that bors and mozilla are probably friends or at least virtual friends." is my favorite bit
[23:14:00] <bstrie> I like how it compares bors to bjz
[23:14:17] <Eridius> I am highly amused how that site thinks I'm a Lua programmer
[23:14:30] <cmr> it calls me a C export
[23:14:40] <lkuper> strcat: huh! I hadn't seen this site.
[23:14:47] <bstrie> "Ben's behavior is quite similar to metajack's but metajack spends less time working for the man." :(
[23:14:57] <cmr> hahah
[23:14:57] <lkuper> http://osrc.dfm.io/lkuper <-- heh.
[23:15:29] <lkuper> I am amused that it says that my research lab has a less consistent weekly schedule than I do.
[23:15:33] <strcat> it also counts # of swear words in commits, etc.
[23:15:44] <strcat> I wish it had more data ;p
[23:15:49] <strcat> only has 3 months from this year iirc
[23:16:10] <strcat> or maybe it got updated since then...
[23:16:34] <MaikKlein> any news on "external function pointer"?
[23:16:42] <ion> I use return just like all the other exceptional control flow breaking statements such as break. With languages that have implicit return values, using return just to return a value in the end would be like making every loop infinite and using a conditional break to end the loop.
[23:17:19] <bstrie> I'm with ion, I use `return` to end my functions and implicit only if it's a one-liner
[23:17:30] <steveklabnik> the original junit had assertEquals being expected, actual, which Ruby follows suit with. Rust has assert_eq! as actual, expected. any chance we could flip it around?
[23:17:30] <cmr> MaikKlein: It is broken on windows but the debugging experience is really painful and nmatsakis hasn't looked at it yet afaik
[23:17:49] <bstrie> steveklabnik: if there's precedent, go for it
[23:17:57] <MaikKlein> cmr: thanks
[23:18:02] <steveklabnik> bstrie: word. because that's really freaking confusing :)
[23:18:03] <benh> I didn't realize it wasn't symmetric, whoops
[23:18:09] <steveklabnik> bstrie: i'll try to check out some other stuff too.
[23:18:17] <bstrie> steveklabnik: at least file a bug if you're not planning on tackling it soon
[23:18:28] *** Quits: carllerche (carllerche@6B070D22.7E6A0813.1428D117.IP) (Quit: carllerche)
[23:18:30] <steveklabnik> will do
[23:18:35] *** Joins: carllerche (carllerche@6B070D22.7E6A0813.1428D117.IP)
[23:18:36] <MaikKlein> cmr: wait it is only broken on windows?
[23:18:37] <steveklabnik> i'm just trying to figure out where it's defined right now
[23:18:37] <steveklabnik> heh
[23:18:44] <cmr> MaikKlein: afaik yes
[23:19:02] <MaikKlein> cmr: okay then I give it a try on linux
[23:19:11] <cmr> MaikKlein: you're talking about #6661 right?
[23:19:15] * lkuper doesn't understand why order matters for assert_eq!
[23:19:16] *** aatch|gone is now known as aatch
[23:19:17] <cmr> r? https://github.com/mozilla/rust/pull/6826
[23:19:27] <steveklabnik> lkuper: when i run a test, I get an 'expected' and 'actual' output
[23:19:27] <benh> rusti: assert_eq!(1, 2);
[23:19:29] -rusti- rust: task failed at 'left: 1 does not equal right: 2', foo.rs:7
[23:19:29] -rusti- rust: domain main @0x1b601b0 root task failed
[23:19:29] -rusti- application terminated with error code 101
[23:19:45] <lkuper> steveklabnik: oh, yeah, I guess it matters for the printed result
[23:19:55] <steveklabnik> lkuper: yup
[23:19:56] <cmr> not on incoming
[23:19:58] <bstrie> btw this is the new soundtrack for #rust http://theophany-rmx.bandcamp.com/track/clocktown
[23:20:01] * strcat ponders prefixing rust's stdout/stderr with out: and err:
[23:20:09] <strcat> rusti's*
[23:20:19] <bstrie> strcat: need separate bots for each
[23:20:22] <benh> strcat: use mirc colors to make stderr red >:D
[23:20:23] <strcat> heh
[23:20:32] <bstrie> actually, do that
[23:20:32] <strcat> benh: oh good point
[23:20:47] <benh> it makes interleaved stderr/out more(?) readable too i suppose
[23:21:17] *** zz_kimundi is now known as kimundi
[23:21:40] <MaikKlein> cmr: probably , I am interested in https://github.com/bjz/gl-rs and I couldn't find the post on github
[23:21:58] <mark_edward> are the increment/decrement operators (++/--)?
[23:22:04] <mark_edward> *are there
[23:22:06] <strcat> benh: well I actually set stderr to stdout atm
[23:22:07] <strcat> mark_edward: no
[23:22:17] *** Quits: erickt (erickt@8C9ECD8F.3A598286.F12515B4.IP) (Quit: Leaving.)
[23:22:24] <strcat> benh: so... I'm not sure how to deal with interleaving if I don't
[23:22:29] <mark_edward> is that a design decision or will it change in the future?
[23:22:54] <strcat> mark_edward: well a = b isn't an expression, so a++ likely wouldn't be if it *did* exist
[23:23:02] <strcat> so it wouldn't be much different than += 1
[23:23:15] <benh> strcat: but red is really... bright
[23:23:26] <bblum> graydon: updated proposal with a scheduling plan at the bottom
[23:23:34] <mark_edward> ok
[23:23:36] <benh> and the tendency is probably that error output is gonna be longer than successful prints
[23:25:08] <bstrie> mark_edward: in the absence of c-style for loops, I've never once cared about the lack of `++`
[23:25:34] <bstrie> +=1 is only one character shorter, for when you do need it
[23:25:51] <steveklabnik> ruby doesn't have ++, it's no biggie
[23:26:04] <benh> But writing i++; is justifiable, i+=1; is pushing it with regards to whitespace ;)
[23:26:05] <mark_edward> yeah you're right about that. the main purpose of it is index incrememnting i guess
[23:26:17] <pcwalton> plusplus!(i);
[23:26:21] <steveklabnik> ahahah
[23:26:24] <lkuper> heh
[23:26:25] <Eridius> ++ is primarily useful because it's an expression, not a statement
[23:26:28] <bstrie> pcwalton: idiomatically I think you need an underscore there
[23:26:34] <Eridius> but that's only appropriate in languages where (a = b) is an expression
[23:26:36] <benh> Eridius: += makes an expression too
[23:26:46] <Eridius> benh: += is the more general form of ++
[23:27:01] <mark_edward> while(increment_in_place!(x) < 20)
[23:27:16] <Eridius> rusti: let mut x = 3; let y = (x = 4); y
[23:27:17] * rusti produced no output
[23:27:27] <benh> while(increment_in_place_returning_previous_value(&mut x) < 20)
[23:27:37] <bstrie> so assignment is an expression that evaluates to null?
[23:27:47] <benh> that doesn't seem right
[23:27:55] <strcat> bstrie: it evaluates to ()
[23:27:56] <Eridius> let mut x : int = 3; let y : int = (x = 4); y
[23:28:04] <Eridius> rusti: let mut x : int = 3; let y : int = (x = 4); y
[23:28:05] <bstrie> kinda weird
[23:28:06] -rusti- more than 5 lines of output, pastebinned: http://sprunge.us/WcUL
[23:28:19] <Eridius> so ++ would only make sense if assignment returned the new lvalue
[23:28:30] <benh> ... I thought it did :(
[23:28:33] <benh> Is that by design too?
[23:28:39] <Eridius> benh: wouldn't play very nicely with owned pointers
[23:29:02] <benh> I defended pythonish x < y < z by analogy to x = y = z last night, I'll have to backpedal on that!
[23:29:08] *** Joins: maxli (maxli@C03F2759.C70D537E.2FA4EA88.IP)
[23:29:44] *** Joins: yichoi (yichoi@5AB4884B.FCC4549.14D5B978.IP)
[23:30:14] <Eridius> benh: x < y < z hurts my brain
[23:30:18] <Eridius> that makes sense nowhere outside of math
[23:30:32] <mark_edward> but programming is exactly like math in everyway!
[23:30:39] <bblum> x < y < z  is terrible
[23:30:51] <Eridius> math makes assertions. It does not evaluate statements
[23:31:00] *** Quits: tgt (tgt@moz-D59EE478.aztw.cable.virginmedia.com) (Quit: Computer has gone to sleep.)
[23:31:03] <mark_edward> i know. i kid
[23:31:06] <Eridius> programming evaluates statements. It does not make assertions
[23:31:12] <Eridius> well, I suppoe prolog does
[23:31:14] <Eridius> *suppose
[23:31:28] <mark_edward> but i feel like x < y < z < w should be evaluatable
[23:31:32] <ski> `x < y < z' is more like a variadic thing
[23:31:34] <kimundi> pcwalton: re let shadowing: Being able to explicit deinitialise a local var with 'let foo = _;' would be nice
[23:31:46] <mark_edward> it boils down to x < y && y < z && z < w
[23:31:49] <bstrie> kimundi: yes, I enjoy that pattern
[23:31:53] <benh> less_than!(x, y, z), anyone?
[23:31:58] <mark_edward> could be syntactic sugar
[23:32:16] <pcwalton> you can deinitialize with "let _ = foo;" if foo is noncopyable
[23:32:20] <Eridius> mark_edward: I suppose you could create some sort of syntactical rule that lets you duplicate the same comparison operator multiple times in a row, and translate it all into basically an s-exp (< a b c)
[23:32:21] <bstrie> oh right
[23:32:23] *** Quits: q66 (q66@6EE9DE40.46454B5D.33AABD5F.IP) (Client exited)
[23:32:25] <bstrie> that's the pattern I enjoy :)
[23:32:38] *** Quits: MaikKlein (maik@moz-AC9459D8.dip0.t-ipconnect.de) (Ping timeout)
[23:33:09] <bstrie> you can use macros to do something like `pre!(< a b c d e)`
[23:33:19] <Eridius> chain!(< a b c d)
[23:33:25] <Eridius> == a < b && b < c && c < d
[23:33:41] <Eridius> lisp!(<a b c d)
[23:33:42] <benh> I really liked fn discard<T>(_: T) {} more than let _ = foo;
[23:34:11] <Eridius> benh: write it
[23:34:12] <bstrie> you're really going to instantiate a function for every type rather than just use the shorter form :P
[23:34:12] <ski> .. if you think of it as operating on a sequence `s', it's basically `forall i,j. i < j => s_i < s_j'
[23:34:23] <Eridius> bstrie: pfft, inline that sucker
[23:34:24] *** Joins: q66 (q66@6EE9DE40.46454B5D.33AABD5F.IP)
[23:34:39] <benh> #[inline(come on, now)]
[23:34:40] <bstrie> Eridius: it still writes the ast to the crate metadata! precious binary size
[23:34:42] <bstrie> wasted
[23:34:57] <Eridius> ski: only if < is transitive for your type ;)
[23:34:58] <benh> bstrie: that's why it ought to go into libstd, so it's only wasted once!
[23:35:30] <rntz> bblum: how is x < y < z terrible?
[23:35:40] *** Quits: lkuper (lkuper@moz-D862222C.dhcp-bl.indiana.edu) (Ping timeout)
[23:35:43] *** Quits: jorendorff (jorendorff@moz-2F32ACA3.hsd1.tn.comcast.net) (Quit: jorendorff)
[23:35:44] <bstrie> I don't think it's terrible, I like it in python
[23:35:52] <ski> Eridius : true (depending on what you want `x < y < z' to mean exactly)
[23:35:55] <benh> It makes < not a binary operator :(
[23:35:56] <bstrie> but I think it's weird in a language where a < b is sugar for a.lt(b)
[23:36:07] <rntz> benh: well, it's an n-ary operator for n >= 2
[23:36:17] <strcat> bstrie: it's sugar in python too.
[23:36:17] * ski . o O ( `a xor b xor c' )
[23:36:18] <bblum> rntz: i think it was j4cbo who had a really dumb python "what does this do" puzzle that depended on multi-comparison conditions
[23:36:25] <rntz> bstrie: the same is true in Python
[23:36:28] <bstrie> strcat: really? I must have known that once
[23:36:30] <strcat> bstrie: for __lt__
[23:36:37] <rntz> bblum: that's probably because python has stupid rules for how these things chain
[23:36:42] <bstrie> well not it just seems weird in python :)
[23:36:44] <bblum> rntz: hmm
[23:36:44] <bstrie> *now
[23:37:04] <strcat> a < b < c < d is just a < b && b < c && c < d
[23:37:05] <rntz> bblum: do you have the puzzle on hand?
[23:37:14] <bblum> looking for it
[23:37:37] <strcat> in rust it's ((a < b) < c) < d
[23:37:49] <steveklabnik> still better than Ruby's flip flops
[23:37:49] <steveklabnik> heh
[23:37:54] <bblum> strcat: that doesn't typecheck
[23:38:02] <strcat> bblum: why not? bools define Ord
[23:38:12] <bblum> well, only if c and d are bools
[23:38:17] <bblum> which would be weird.
[23:38:24] <bblum> c.c
[23:38:35] <Eridius> why do bools define Ord?
[23:38:41] <strcat> Eridius: so you can derive Ord easily
[23:38:47] <Eridius> ah
[23:39:01] <ski> (it's common to use the `false < true' ordering on booleans)
[23:39:11] <strcat> () defines it too :)
[23:39:29] <strcat> rusti: (() < (), () > (), () == (), () <= ())
[23:39:30] -rusti- (false, false, true, true)
[23:39:48] <mark_edward> cool!
[23:40:06] <Eridius> oh dear god
[23:40:13] <mark_edward> how do you make multiline string literals in rust?
[23:40:15] * ski idly wonders whether there is an "zero-element type" in Rust (and whether it then defines `Ord')
[23:40:22] *** Quits: jack (jack@2557E599.66715431.D25A875A.IP) (Ping timeout)
[23:40:24] <rntz> strcat: what are ruby's flip flops?
[23:40:24] <strcat> mark_edward: I think you just don't put a closing " until the end
[23:40:32] <strcat> rntz: steveklabnik said it ;p
[23:40:38] <mark_edward> does it incorporate the whitespace
[23:40:39] <rntz> arg autocomplete
[23:40:44] <rntz> steveklabnik: what are ruby's flip flops?
[23:40:52] * strcat has written ~7 lines of ruby
[23:40:56] <steveklabnik> rntz: oh man.
[23:41:00] <steveklabnik> flip flops... are fun. 
[23:41:01] <benh> regexp literals have wacky coercions to bool
[23:41:03] <steveklabnik> let me dig  up the ml thread
[23:41:09] <strcat> python2 tried to define a total ordering on all types
[23:41:12] <bblum> ski: you can define one but i don't think our library has one
[23:41:14] <steveklabnik> http://www.ruby-forum.com/topic/2713360
[23:41:14] <strcat> it was dropped
[23:41:16] <strcat> it was horrible
[23:41:38] <rntz> hrm, (x < true) is just !x. (x < false) is just false. (x > false) is just x. x > true is just false.
[23:41:38] <steveklabnik> specifically this code: http://www.ruby-forum.com/topic/2713360#1024936
[23:41:38] <brendanc> would be nice if rusti privmsged back when privmsged :)
[23:41:42] <rntz> comparisons with bools are boring
[23:41:50] <mark_edward> strcat: do you know if a multiline literal will incorporate the newline into the string
[23:41:52] <strcat> steveklabnik: http://ix.io/5Sf (gone in py3) ;p
[23:41:53] <ski> bblum : it could perhaps be useful for non-returning functions
[23:41:57] <bblum> rntz: ah, print("foo" in ["bar"] == false)
[23:42:03] <strcat> mark_edward: not sure, but I think it will
[23:42:03] <bblum> rntz: true, false, or type error?
[23:42:10] <strcat> mark_edward: you can put a \ at the end if you don't want it I guess
[23:42:11] <mark_edward> ok
[23:42:17] <mark_edward> thanks
[23:42:27] <steveklabnik> strcat: nice
[23:42:30] <bblum> ski: we have a type "!" for that, but it's only legal to use in the return type position of functions (for some reason)
[23:42:40] <rntz> bblum: right, python has silly rules for doing this trick when there are multiple different operators involved
[23:42:48] <bstrie> mark_edward: if a \ is the last character on a line when inside of a multi-line string literal, it eats all the whitespace from the \ to the start of the next non-whitespace character
[23:42:57] <ski> bblum : mhm. i wonder why ..
[23:43:03] <steveklabnik> question: I have two Option(u8)'s, and i want to do something if both of them are Some, and nothing when None. what's the easiest way?
[23:43:10] <bblum> rusti: fn foo() -> ! { fail!("oops"); }; let _x: ! = foo();
[23:43:10] -rusti- foo.rs:8:51: 8:52 error: expected type, found token NOT
[23:43:10] -rusti- foo.rs:8          fn foo() -> ! { fail!("oops"); }; let _x: ! = foo();
[23:43:10] -rusti-                                                             ^
[23:43:10] -rusti- application terminated with error code 101
[23:43:20] <strcat> steveklabnik: chain?
[23:43:23] <rntz> that should clearly be either a SyntaxError or True.
[23:43:25] <strcat> hm
[23:43:35] <rntz> I suppose it could also be TypeError if it associates as "foo" in (["bar"] == False).
[23:43:45] <mark_edward> thanks for the info bstrie
[23:43:49] <strcat> steveklabnik: no not chain ;p
[23:43:55] <rntz> but actually it's False. blech.
[23:44:05] <bblum> rntz: what if i told you it expanded to ("foo" in ["bar"]) && (["bar"] == False)
[23:44:14] <rntz> yeah, yeah, that's obviously why it does that
[23:44:16] <rntz> it's silly
[23:44:19] <steveklabnik> strcat: right? it's kinda awkward
[23:44:26] <rntz> the fact that Python does it wrong doesn't mean it's impossible to do it right
[23:44:27] <steveklabnik> i mean, this is why the Maybe monad exists.... heh
[23:44:33] <bblum> sure, that's ture
[23:44:33] <bblum> true
[23:45:24] <benh> rusti: match (Some(1u8), Some(2u8)) { (Some(a), Some(b)) => println((a, b).to_str()), _ => () }
[23:45:26] -rusti- (1, 2)
[23:45:38] <steveklabnik> benh: ahhhhhh, nice
[23:45:39] <steveklabnik> thank you
[23:45:53] <bstrie> you also don't need the parentheses around the matched thing
[23:45:58] <bstrie> silly C influences!
[23:46:00] <mark_edward> rust could use a fmap type thingy i think. make dealing with option and such nicer
[23:46:06] <benh> it's a tuple!
[23:46:11] <bstrie> oh right you do!
[23:46:28] <Eridius> mark_edward: we need a Functor trait
[23:46:31] <Eridius> and a Monad trait
[23:46:33] <Eridius> and an Applicative
[23:46:36] <Eridius> and.. and.. and...
[23:46:44] <benh> rusti: Some(42u8).map(|x|x+1)
[23:46:46] -rusti- Some(43)
[23:46:53] <Eridius> and heck, lets add deriving(Functor) for enum variants
[23:47:00] <rntz> the trouble with these haskellish traits is that they involve higher-order functions
[23:47:01] <mark_edward> Eridius: weren't you trying to do that yourself?
[23:47:09] <rntz> and since rust has N flavors of higher-order functions
[23:47:25] <mark_edward> rust should do currying like haskell
[23:47:30] <rntz> you get a combinatorial explosion in the different possible kinds of Functor, Applicative, Monad, etc. traits that you can define
[23:47:31] <mark_edward> it'd be really cool
[23:47:37] *** Quits: blitter (blitter@moz-E761A52F.dyn.centurytel.net) (Ping timeout)
[23:48:14] <Eridius> mark_edward: not I
[23:48:19] <mark_edward> would that mess up function overloading?
[23:49:32] *** Joins: bent (chatzilla@moz-932324BF.hsd1.ca.comcast.net)
[23:49:41] <rntz> mark_edward: I'm not sure what you mean by "like haskell" in this context. rust already can return functions from functions.
[23:49:50] <Eridius> rntz: he means implicit currying
[23:49:56] <mark_edward> yeah that ^^
[23:50:03] <rntz> right, implicit currying wouldn't mesh well with the rest of rust
[23:50:14] <rntz> for one thing, rust has many different flavors of functions
[23:50:25] <Eridius> rusti: let f = ~fn(a: int, b: int) { a + b }; f(3)(5);
[23:50:26] -rusti- more than 5 lines of output, pastebinned: http://sprunge.us/OKZY
[23:50:32] <ski> (hm .. wonder if a Mercury-like static mode system thing could be useful in something like Rust)
[23:50:52] <Eridius> rusti: let f : ~fn(a: int, b: int) = |a, b| a + b; f(3)(5)
[23:50:53] -rusti- more than 5 lines of output, pastebinned: http://sprunge.us/YWCF
[23:50:55] *** Joins: Raynes (macro@moz-E5F01CE6.members.linode.com)
[23:50:57] <rntz> rusti: let f = ~fn(a: int) { ~fn(b: int) { a + b } }; f (3)(5);
[23:50:58] -rusti- more than 5 lines of output, pastebinned: http://sprunge.us/bfid
[23:51:14] <rntz> "found `fn` in ident position"
[23:51:25] <steveklabnik> strcat: i do need parens around that
[23:51:26] <rntz> either that's a misleading error message or I no longer understand rust syntax. well, whatever.
[23:51:27] <steveklabnik> personally
[23:51:43] *** Joins: indirect_ (indirect_m@moz-770AB053.hsd1.ca.comcast.net)
[23:51:47] <mark_edward> rusti: Some(~[1,2,3]).map(|v| v.reversed() )
[23:51:49] -rusti- more than 5 lines of output, pastebinned: http://sprunge.us/cTMD
[23:52:01] <Eridius> rusti: let f : ~fn(a: int) -> int = |a| { let f : ~fn(b: int) -> int = |b| a + b; f }; f(3)(5)
[23:52:02] -rusti- more than 5 lines of output, pastebinned: http://sprunge.us/faBZ
[23:52:18] <Eridius> rusti: let f : ~fn(a: int) -> ~fn(int)->int = |a| { let f : ~fn(b: int) -> int = |b| a + b; f }; f(3)(5)
[23:52:19] -rusti- 8
[23:52:27] <rntz> rusti: let f = |a| { |b| { a + b } }; f(3)(5)
[23:52:29] -rusti- more than 5 lines of output, pastebinned: http://sprunge.us/VDjj
[23:52:45] <rntz> oh, is + polymorphic in rust?
[23:52:47] <Eridius> rusti: let f = |a: int| { |b: int| { a + b } }; f(3)(5)
[23:52:49] -rusti- more than 5 lines of output, pastebinned: http://sprunge.us/SKSj
[23:53:07] <rntz> "note: in expansion of fmt!"
[23:53:11] <rntz> what the hell, that code doesn't use fmt!
[23:53:18] <strcat> it does
[23:53:21] <Eridius> rntz: rusti presumably wraps the final expression in fmt!("%?", expr)
[23:53:30] *** Quits: indirect (indirect@moz-7E1FC85.ppp.asahi-net.or.jp) (Quit: indirect)
[23:53:30] *** indirect_ is now known as indirect
[23:53:35] <rntz> oh. okay. well, the code still doesn't use fmt, but the code being compiled does.
[23:53:43] <strcat> rusti: print(str::from_bytes(std::run::process_output("foo.rs", []).output))
[23:53:44] * rusti produced no output
[23:53:56] <strcat> rusti: print(str::from_bytes(std::run::process_output("cat", [~"foo.rs"]).output))
[23:53:57] -rusti- more than 5 lines of output, pastebinned: http://sprunge.us/SCfM
[23:54:04] <mark_edward> why does this work:
[23:54:08] <mark_edward> rusti: Some(~[1,2,3]).map(|v| vec::reversed(*v) )
[23:54:10] -rusti- Some(~[3, 2, 1])
[23:54:15] <mark_edward> but this doesn't:
[23:54:22] <mark_edward> Some(~[1,2,3]).map(|v| (*v).reversed() )
[23:54:26] <mark_edward> rusti: Some(~[1,2,3]).map(|v| (*v).reversed() )
[23:54:28] -rusti- more than 5 lines of output, pastebinned: http://sprunge.us/OVLW
[23:54:40] <strcat> mark_edward: because it's not implemented as a method
[23:54:44] <Eridius> mark_edward: because reversed isn't a method of ~[T]
[23:54:46] <rntz> strcat: uh, that that program works seems problematic.
[23:54:53] <rntz> somebody's sandbox is screwed.
[23:54:59] <strcat> rntz: why?
[23:55:07] <rntz> it let you access the filesystem?!
[23:55:10] <benh> It's just a bigger sandbox than you expect
[23:55:14] <strcat> rntz: sure, it's a read-only fs
[23:55:18] <rntz> blech. okay, sure.
[23:55:19] <strcat> rntz: it's not the same fs as the host
[23:55:35] <strcat> rntz: you can use ps too
[23:55:48] <strcat> rusti: print(str::from_bytes(std::run::process_output("ps", [~"ax"]).output))
[23:55:50] -rusti-   PID TTY      STAT   TIME COMMAND
[23:55:50] -rusti-     1 ?        Ssl    0:00 ./foo
[23:55:50] -rusti-    14 ?        R      0:00 ps ax
[23:55:57] <Eridius> rusti: print(str::from_bytes(std::run::process_output("whoaim", []).output))
[23:55:58] * rusti produced no output
[23:56:05] <Eridius> rusti: print(str::from_bytes(std::run::process_output("whoami", []).output))
[23:56:07] * rusti produced no output
[23:56:11] <rntz> rusti: print(str::from_bytes(std::run::process_output("whoami", []).output))
[23:56:12] * rusti produced no output
[23:56:20] <rntz> hah, e:f;b
[23:56:21] <Eridius> rusti: print(str::from_bytes(std::run::process_output("id", []).output))
[23:56:22] * rusti produced no output
[23:56:25] <Eridius> rusti: print(str::from_bytes(std::run::process_output("id", []).error))
[23:56:26] * rusti produced no output
[23:56:28] <strcat> whoami needs socket syscalls
[23:56:28] <Eridius> bah
[23:56:30] <strcat> that aren't whitelisted
[23:56:37] <bblum> c.c
[23:56:37] <strcat> it talks to nscd
[23:56:37] <Eridius> re-raise signals dammit!
[23:56:41] *** Quits: snearch (snearch@moz-1D5B13B7.pool.mediaways.net) (Quit: Verlassend)
[23:56:45] <rntz> rusti: print(str::from_bytes(std::run::process_output("env", []).output))
[23:56:46] -rusti- OLDPWD=/
[23:56:47] -rusti- PATH=/usr/local/bin:/usr/bin:/bin
[23:56:47] -rusti- PWD=/home/rust
[23:56:49] <strcat> Eridius: I do but... there isn't a signal
[23:57:01] <mark_edward> what if you could read ssh keys
[23:57:03] <Eridius> bah
[23:57:06] <strcat> Eridius: rust is silencing it
[23:57:10] <rntz> rusti: print(str::from_bytes(std::run::process_output("mount", []).output))
[23:57:11] -rusti- /dev/sda4 on / type ext4 (ro,relatime,commit=15,data=ordered)
[23:57:11] -rusti- none on /proc type proc (rw,nosuid,nodev,noexec,relatime)
[23:57:11] -rusti- none on /tmp type tmpfs (rw,nosuid,nodev,relatime)
[23:57:11] -rusti- none on /home/rust type tmpfs (rw,nosuid,nodev,relatime)
[23:57:17] *** Quits: steveklabnik (steve@moz-5EF6C37C.socal.res.rr.com) (Connection reset by peer)
[23:57:27] *** Joins: steveklabnik (steve@moz-5EF6C37C.socal.res.rr.com)
[23:57:33] <rntz> so /home/rust is rw.
[23:57:37] <Eridius> rusti: print(str::from_bytes(std::run::process_output("cat", [~"/etc/passwd"]).error))
[23:57:37] <rntz> as is /tmp.
[23:57:38] * rusti produced no output
[23:57:39] <strcat> rntz: yeah it's in tmpfs though
[23:57:44] *** Joins: jack (jack@2557E599.66715431.D25A875A.IP)
[23:57:53] <bblum> Eridius: you need
[23:57:55] <strcat> and the cgroup memory limit includes tmpfs memory usage
[23:58:00] <Eridius> oops I left it on error
[23:58:00] <rntz> okay.
[23:58:02] <Eridius> rusti: print(str::from_bytes(std::run::process_output("cat", [~"/etc/passwd"]).output))
[23:58:04] -rusti- more than 5 lines of output, pastebinned: http://sprunge.us/RSDA
[23:58:09] <strcat> rntz: it's a per-process mount table
[23:58:21] <strcat> so I could be running them concurrency and they wouldn't see each other
[23:58:34] <bblum> oh, i guess you don't need "cat" in the argument list too
[23:58:37] *** Joins: erickt (erickt@8C9ECD8F.3A598286.F12515B4.IP)
[23:58:37] <joshua_> ha.  I like the '/me produced no output'
[23:58:50] <rntz> rusti: print(str::from_bytes(std::run::process_output("cat", [~"/etc/shadow"]).output))
[23:58:51] <mark_edward> do you think we can read authorizzed_keys?
[23:58:52] * rusti produced no output
[23:58:52] <strcat> I think I should really not be using CTCP ACTION :(
[23:58:59] <rntz> rusti: print(str::from_bytes(std::run::process_output("cat", [~"/etc/shadow"]).error))
[23:58:59] <Eridius> strcat: why?
[23:59:00] -rusti- cat: /etc/shadow: Permission denied
[23:59:10] <strcat> rntz: even if it could read it there's nothing in it
[23:59:16] <joshua_> rntz: you can /msg the bot to talk to it
[23:59:18] <mark_edward> rusti: print(str::from_bytes(std::run::process_output("cat", [~"~/.ssh/authorized_keys"]).output))
[23:59:19] * rusti produced no output
[23:59:20] <rntz> joshua_: ah, thanks.
[23:59:21] <strcat> I could make it root if I used CLONE_NEWUSER
[23:59:34] <strcat> but CLONE_NEWUSER isn't done so...
[23:59:39] *** Quits: eholk (eholk@moz-3D703D55.uconnect.utah.edu) (Quit: eholk)
[23:59:39] *** Quits: doomlord (doomlod@moz-3CF8202D.range81-159.btcentralplus.com) (Ping timeout)
[23:59:48] <strcat> mark_edward: it has a / all to itself

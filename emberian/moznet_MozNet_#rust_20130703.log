[00:00:02] <graydon> nmatsakis: ping
[00:03:55] * graydon confused. I thought we could have non-'self lifetimes in structs. no?
[00:04:01] <cmr> graydon: nope
[00:04:06] <graydon> huh
[00:04:11] <cmr> and I think it's actually 'static?
[00:04:12] *** Quits: Jesse (jruderman@2557E599.66715431.D25A875A.IP) (Broken pipe)
[00:04:23] <cmr> the pretty printer always uses 'static for struct lifetimes
[00:04:25] <graydon> no, surely not
[00:04:45] <graydon> pcwalton: does this come as a surprise to you?
[00:05:12] <pcwalton> graydon: I wouldn't be surprised if there is only one lifetime parameter permitted still, bleh
[00:05:31] <graydon> only one is fine. but does it have to be 'self?
[00:05:44] *** Joins: duckinator (nick@moz-74B346B5.mostlyincorrect.info)
[00:05:45] <pcwalton> it was at one point. I don't know if it got fixed.
[00:05:50] <strcat> *** Error in `x86_64-unknown-linux-gnu/stage2/bin/rustc': malloc(): memory corruption: 0x00007fafc42009e0 ***
[00:05:53] <strcat> heh
[00:05:58] <graydon> pcwalton: error: Illegal lifetime 'a: only 'self is allowed as part of a type declaration
[00:06:04] <graydon> looks like no
[00:06:21] <pcwalton> then yeah
[00:06:28] <graydon> will that expand if I pass in a longer-lived thing?
[00:06:29] <pcwalton> niko needs to do it
[00:06:31] <graydon> or intersect?
[00:06:34] <pcwalton> yes due to subtyping
[00:06:35] <pcwalton> in general
[00:06:38] <graydon> ok
[00:06:38] <pcwalton> but beware of variance
[00:06:44] <graydon> sure. this is a simple case.
[00:07:22] <dbaupp> strcat: ship it! ;P
[00:07:48] *** Joins: paupau (paul@moz-D6583788.hsd1.ca.comcast.net)
[00:08:00] *** Joins: jpochyla (jpochyla@moz-8D99AE5D.broadband18.iol.cz)
[00:08:13] *** Quits: mschifer (Adium@2557E599.66715431.D25A875A.IP) (Quit: Leaving.)
[00:08:24] *** Quits: tjc (tjc@2557E599.66715431.D25A875A.IP) (Quit: Places to go, people to annoy)
[00:09:15] <engla> hm with some changes deque add_back goes from 4000 ns to 17 ns..
[00:09:36] *** Joins: Jesse (jruderman@2557E599.66715431.D25A875A.IP)
[00:09:50] *** Quits: jpochyla (jpochyla@moz-8D99AE5D.broadband18.iol.cz) (Ping timeout)
[00:09:52] <brson> I updated the example on rust-lang.org
[00:09:59] *** Quits: hjr3 (hradtke@374E545A.3A8E9B0C.F9D9C60E.IP) (Ping timeout)
[00:10:15] <cmr> I don't see it updated
[00:10:28] <dbaupp> cmr: clear your cache
[00:10:55] <dbaupp> cmr: (or just use shift+f5)
[00:10:59] <cmr> dbaupp: done, and still... nothing
[00:11:39] <roo> same
[00:11:50] <dbaupp> I see it :)
[00:12:08] <graydon> engla: those sound like good changes
[00:12:57] <dbaupp> roo, cmr: https://gist.github.com/huonw/80904ba2fb62aa83908b
[00:13:10] <MaikKlein> hm
[00:13:25] *** Joins: hjr3 (hradtke@374E545A.3A8E9B0C.F9D9C60E.IP)
[00:13:26] *** Parts: judder (maradukewa@5B9E91E7.2C8A8E2E.78E362FE.IP) ()
[00:13:29] <MaikKlein> can we also spawn threads?
[00:13:47] <Eridius> I see the new example
[00:14:24] <cmr> updated for me now too
[00:14:42] <roo> yeah i see it now
[00:14:54] <graydon> so .. can I not have a dtor on a thing containing &-ptrs, today?
[00:15:04] <graydon> pcwalton: ^ I assume this is what we were discussing today?
[00:15:15] <pcwalton> graydon: yeah
[00:15:16] <graydon> compiler thinks it's not Owned
[00:15:17] <pcwalton> it should be changed
[00:15:25] <pcwalton> you can mark the impl with #[unsafe_destructor]
[00:15:27] <pcwalton> to override
[00:15:28] <graydon> ok. time being I just turn on unsafe_dtor
[00:15:29] <graydon> ok
[00:17:23] *** aatch_ is now known as aatch
[00:19:28] <engla> yes graydon I'm working on changing some decisions in the deque module.. like keeping around the ~[], not making a new one on grow
[00:21:07] <brson> merging io into master is a nightmare now
[00:21:15] *** Quits: dherman (dherman@2557E599.66715431.D25A875A.IP) (Quit: dherman)
[00:21:27] <graydon> brson: what changed?
[00:21:56] <brson> graydon: strcat and I have both been making changes to the allocators
[00:22:15] <graydon> aha
[00:22:34] <pnathan> Any insight into: "Error: Eq is not a trait"  I've performed "use std::cmp::{Eq, Ord};"
[00:22:47] <cmr> pnathan: gist your code
[00:23:06] <strcat> pub unsafe fn exchange_malloc(_align: u32, size: uintptr_t) -> *c_char {
[00:23:09] <strcat>     malloc_raw(size as uint) as *c_char
[00:23:10] <strcat> }
[00:23:12] <strcat> it will be this soon
[00:23:14] <strcat> no header :)
[00:23:36] <cmr> pnathan: Eq and Ord are in the prelude btw
[00:23:38] *** Quits: reyre_ (reyre@moz-9002CDDA.cpe.net.cable.rogers.com) (Connection reset by peer)
[00:23:43] <strcat> I guess I can fix the signature in base.rs and put the lang item right on malloc_raw
[00:23:55] <paupau> I'm curious about the memory layout of ~[Option<MyStruct>]
[00:24:07] <strcat> first all this box body stuff needs to be fixed
[00:24:13] <strcat> paupau: Option<Foo> is just a tagged union
[00:24:20] <strcat> 1 word for the tag
[00:24:26] <paupau> ah so lots of overhead eh
[00:24:28] <strcat> the only current exception is non-nullable ptrs
[00:24:38] <graydon> paupau: yes
[00:24:39] <strcat> Option<~T>, Option<&T> etc. turn to a nullable ptr
[00:24:40] <dbaupp> strcat: alignment is ignored for now?
[00:24:48] <strcat> dbaupp: well I'm not counting the alignment at the end
[00:24:52] <strcat> it is padded
[00:24:55] <graydon> deque should be rewritten unsafely to use a buffer that it drops members from the middle of.
[00:25:03] <graydon> like a real circular buffer
[00:25:05] <dbaupp> strcat: (I mean in the new exchange_malloc)
[00:25:34] <pnathan> cmr:  updating old code from last fall to 0.7 - https://gist.github.com/pnathan/1f4ade404d0f25c802eb
[00:25:38] <strcat> dbaupp: doesn't need to
[00:25:42] <strcat> malloc already aligns for every valid C type
[00:25:45] <strcat> and that means long double
[00:25:54] <strcat> we don't have anything needing more than 16 align
[00:26:02] <strcat> and malloc gives us that
[00:26:18] <dbaupp> ah, ok. cool
[00:26:35] <strcat> the align param was probably useless
[00:26:40] <dbaupp> pnathan: you need impl<T: Ord + Eq>
[00:26:43] <strcat> it used it to do a calculation with the header size
[00:26:50] <strcat> but we didn't do the calculation in the C++ vector realloc
[00:27:00] <engla> graydon: I wrote it like that today (not related to the changes I talked about now)
[00:27:03] <strcat> and that's now rust (still without that calculation, because I don't think it does anything)
[00:27:03] <dbaupp> pnathan: that code currently creates a 2nd generic with the name "Eq"
[00:27:07] <engla> but only on top of malloc
[00:27:22] <pnathan> dbaupp: so when requiring multiple traits, use + now?
[00:27:29] <dbaupp> pnathan: right
[00:27:31] <cmr> pnathan: yes
[00:27:44] <dbaupp> strcat: cool
[00:28:08] <kmc> strcat: is that optimization special cased for Option?
[00:28:16] <strcat> kmc: no, for any Option-like enum
[00:28:26] *** Joins: Yurume (yurume@AC58A8CE.8A059B47.E313B915.IP)
[00:28:29] <pnathan> thanks. on to the next obselete syntax. :)
[00:28:33] <strcat> kmc: anything that's { Empty, NonNullablePointerType }
[00:28:38] <kmc> ok
[00:28:39] <dbaupp> kmc: anything isomorphic to Option, including Result<~T, ()>
[00:28:42] *** Quits: tedh (tedh@moz-F0B37C08.hsd1.il.comcast.net) (Client exited)
[00:28:45] <kmc> oh that's cool
[00:28:50] <engla> strcat: does rust require 16-align on all platforms?
[00:28:51] *** Quits: roo (jesse.rudo@moz-FB1A29EA.dynamic.ip.windstream.net) (Ping timeout)
[00:29:14] *** Joins: roo (jesse.rudo@moz-FB1A29EA.dynamic.ip.windstream.net)
[00:29:30] <cmr> pnathan: you can omit braces from single-expression, so like (&Empty, &Empty) => true
[00:29:58] <dbaupp> cmr, pnathan: (although that requires a ,)
[00:30:08] <cmr> pnathan: you can use &Node(*) instead of &Node(_, _, _)
[00:30:08] *** Joins: reyre_ (reyre@moz-9002CDDA.cpe.net.cable.rogers.com)
[00:30:09] <cmr> right
[00:30:31] <strcat> engla: dunno, it's whatever C/malloc requires
[00:31:10] <strcat> SSE requires 16-byte align so you want malloc to be 16-byte aligned on x86_64 anyway
[00:31:15] <pnathan> cmr: That's shiny. it's now complaining that I havn't  implemented Eq for maybenode - I'm in the middle of defining it where it complains. :-/
[00:31:30] *** Joins: dwrensha (chatzilla@moz-DE44EA45.hsd1.pa.comcast.net)
[00:31:36] <dbaupp> pnathan: also, if you put #[deriving(Eq)] on the struct definition, you automatically get an impl for Eq
[00:32:05] <dbaupp> pnathan: you should be able to recurse, what's the error message?
[00:32:08] <engla> I don't think it's guaranteed that malloc aligns correctly for SIMD types
[00:32:44] <dwrensha> How do I invoke a macro defined in another file?
[00:32:48] <pnathan> dbaupp: bst.rs:36:28: 36:49 error: failed to find an implementation of trait std::cmp::Eq for MaybeNode<T>   - deriving_eq does compile, but I don't know how guaranteed to be correct is is.
[00:33:15] <dbaupp> pnathan: "guaranteed to be correct"?
[00:33:32] <pnathan> how is equality defined? 
[00:33:33] <dbaupp> pnathan: the #[deriving] impl just perform their task structurally
[00:33:37] <dbaupp> *impls
[00:33:54] <aatch> dwrensha, you need `#[macro_escape];` in the file with the macros.
[00:34:09] <engla> pnathan: either you impl Eq manually or use deriving
[00:34:20] <dbaupp> pnathan: so, the same enum variant and every field equal (using their Eq impl)
[00:34:22] <aatch> and then import the module into the modules you are using it in.
[00:34:40] *** Joins: RMF (RMF@6152834E.A3AF135E.823A4631.IP)
[00:34:43] <pnathan> All right, so it recurses structurally until it finds an Eq impl and then uses that for that slot. /me gets it
[00:34:49] <dbaupp> pnathan: but that error seems peculiar
[00:34:59] <dbaupp> pnathan: not really
[00:35:25] <aatch> pnathan, it just uses the Eq impl for each field.
[00:35:30] <pnathan> where's deriving_eq defined? I'll just look up the source. :)
[00:35:30] <aatch> if there is one, it complains.
[00:35:31] <dwrensha> aatch: ah, thanks
[00:35:44] <aatch> pnathan, there is no deriving_eq anymore
[00:35:55] <aatch> it's #[deriving(Eq)]
[00:35:57] <MaikKlein> can we create our own "derives"?
[00:36:03] <pnathan> Ah, but where's deriving() defined?
[00:36:06] <aatch> since we have a whole family of them.
[00:36:16] <dbaupp> pnathan: syntax/ext/deriving/
[00:36:22] <pnathan> ty
[00:36:26] <dbaupp> pnathan: (cmp/eq.rs for Eq)
[00:36:33] <dbaupp> pnathan: it's fairly non-obvious what's going on
[00:36:37] <aatch> pnathan, in libsyntax, but unless you're familiar with the code, I'm not sure how helpful it'll be.
[00:36:45] * dbaupp wrote most of it
[00:36:58] <aatch> MaikKlein, not at the moment.
[00:37:50] <aatch> MaikKlein, probably when we get compiler extensions that load at compile time.
[00:38:01] *** Parts: ecr1 (ereed@2557E599.66715431.D25A875A.IP) ()
[00:38:09] <MaikKlein> aatch, k
[00:38:32] <dbaupp> pnathan: https://github.com/mozilla/rust/blob/master/src/libsyntax/ext/deriving/generic.rs#L643
[00:38:43] *** Quits: Jesin (Jessin_@moz-1B1307FF.eecs.lehigh.edu) (Ping timeout)
[00:39:35] *** Quits: erickt (erickt@8C9ECD8F.3A598286.F12515B4.IP) (Quit: Leaving.)
[00:39:47] <aatch> I'm guessing nobody uses asm! enough to care if I make some significant changes to it, right?
[00:40:07] <dbaupp> aatch: if they're improvements, nobody will care that they're program breaks
[00:40:19] <dbaupp> aatch: (at least, if they do, wtf are they using Rust for)
[00:40:37] <kmc> is there a deep difference between kinds and traits? or are kinds just traits where the compiler writes instances and you can't?
[00:40:52] <MaikKlein> what are kinds?
[00:40:59] <cmr> MaikKlein: Send, Freeze, etc
[00:41:03] <brson> we should probably purge the 'kind' terminology
[00:41:05] <MaikKlein> cmr, ah
[00:41:05] <dbaupp> kmc: yes, kinds are things that are directly computed from the types and can't be overwritten
[00:41:14] <aatch> dbaupp, yeah, it's basically just to bring it closer to what clang/gcc has
[00:41:19] *** Quits: bnicholson (bnicholson@2557E599.66715431.D25A875A.IP) (Ping timeout)
[00:41:37] <dbaupp> aatch: yeah, that'd be nice. I've tried using it, and it was... difficult
[00:41:40] <MaikKlein> cmr, hm aren't they called trait bounds?
[00:41:45] *** Quits: brendan (brendaneic@2557E599.66715431.D25A875A.IP) (Quit: brendan)
[00:41:53] <cmr> MaikKlein: they are traits, and they are called kinds.
[00:41:55] <cmr> http://static.rust-lang.org/doc/std/kinds.html
[00:42:52] *** Joins: enix (enix@moz-A50569DD.c3-0.slvr-ubr1.lnh-slvr.md.cable.rcn.com)
[00:43:10] <aatch> dbaupp, yeah, well I found that if you want a specific register constraint (which I did) you have to put the exact register name in curly braces.
[00:43:32] <aatch> so "={rax}" for an output register
[00:43:32] <brson> "The 4 kinds are" ... lists 3 kinds
[00:43:35] *** Quits: eholk (eholk@77910EB7.BEBDB225.ABD5273E.IP) (Quit: eholk)
[00:43:45] <dbaupp> aatch: oh! no wonder it didn't work for me
[00:44:24] <aatch> dbaupp, I found that out after noticing that the generated ASM was honoring my "ra" constraint
[00:44:45] <aatch> since that's actually 2 alternative constraints, 'r' and 'a'
[00:45:45] <aatch> it doesn't like the 'a' constraint, but the 'r' just means "register" and it's fine with that.
[00:45:50] <aatch> so it uses that.
[00:45:50] <brson> this doesn't seem to work now: let mut (p, ch1) = stream(); 
[00:45:58] <aatch> brson, correct.
[00:46:00] <brson> it says it's a 'mut with multiple bindings'
[00:46:10] <cmr> brson: right, it is, was removed over the weekend
[00:46:17] <brson> why?
[00:46:21] <dbaupp> aatch: oh... that does require improvement
[00:46:28] <dbaupp> pcwalton: ping ^
[00:46:28] <aatch> pcwalton removed distributed mut over bindings because it wasn't clear
[00:46:46] * brson grumble
[00:46:54] <aatch> ideally you should be able to do let (mut p, mut ch1) = stream();
[00:46:56] <dbaupp> aatch: but for tuples?
[00:47:05] <cmr> dbaupp: that's not a tuple
[00:47:15] <dbaupp> cmr: sure it is (?)
[00:47:20] <cmr> dbaupp: no, it's a pattern
[00:47:23] <aatch> dbaupp, it's a pattern, that matches a tuple.
[00:47:33] *** Joins: brendan (brendaneic@2557E599.66715431.D25A875A.IP)
[00:47:34] <dbaupp> right
[00:47:37] <cmr> it introduces two separate bindings
[00:47:51] <Eridius> I still don't get why `let mut (a, b) = foo` was considered bad
[00:48:20] <aatch> Eridius, because it's inconsistent with match patterns
[00:48:52] <aatch> it's also not actually that obvious.
[00:49:04] <Eridius> aatch: I thought in match patterns you could only use mut if you also used ref, which means `let (mut a, mut b)` won't be the same as match patterns anyway
[00:49:07] <aatch> I first tried (mut a, mut b) when doing it.
[00:49:18] *** Quits: q66 (q66@6EE9DE40.46454B5D.33AABD5F.IP) (Quit: Leaving)
[00:49:30] <aatch> which is the "proper" way.
[00:49:40] <bblum> aatch: ping
[00:49:44] <aatch> bblum, pong
[00:50:00] <bblum> aatch: i wanna add AtomicOption::is_empty() for use in arc try_unwrap()
[00:50:02] <bblum> is that cool?
[00:50:16] <cmr> Eridius: nope, it is the same. you see it in function arguments too. fn foo<T>(mut bar: T) for example.
[00:50:23] <aatch> bblum, sure, can't see any reason why not.
[00:50:25] <bblum> i have a comment on top of it that says "be careful: you have to have some external way of guaranteeing it stays valid"
[00:50:45] <aatch> bblum, there are atomic cmp operators now btw.
[00:51:02] <bblum> compare and swap? or just compare?
[00:51:12] <aatch> bblum, like atomic versions of '=='
[00:51:18] <bblum> hmm
[00:51:34] <bblum> is it implemented on atomic option?
[00:51:40] <aatch> bblum, wait, no there isn
[00:51:41] <aatch> 't
[00:52:00] <aatch> I was thinking of something else.
[00:52:07] <cmr> mnemonic is working with atomics a lot
[00:52:38] <aatch> cmr, I know. I suggested he pick up finishing the unstable::atomics stuff
[00:52:48] <aatch> mostly because I'm too lazy to.
[00:53:07] *** Quits: MaikKlein (maik@moz-3925DFD2.dip0.t-ipconnect.de) (Ping timeout)
[00:53:41] *** Quits: reyre_ (reyre@moz-9002CDDA.cpe.net.cable.rogers.com) (Ping timeout)
[00:54:00] <pnathan> I have a puzzle now. I have a thing that looks a lot like this: trait Thing<T> { fn foo(&self, Thing<T> a) -> Thing<T>; } ..    Essentially, I want the fn to take a couple objects conforming to trait, then return an object conforming to trait. When I impl this, there will be a type signature mismatch, since I want the fn impl to return the implementing type, not the trait. Looking at some of the source in libstd and libext I don't see anyt
[00:54:31] <dbaupp> pnathan: fn foo(&self, a: Self) -> Self
[00:54:49] *** Joins: Jesin (Jessin_@moz-1B1307FF.eecs.lehigh.edu)
[00:54:55] <pnathan> Ah, Self (capitalized) is the name for the thing now. Thangs.
[00:54:57] <pnathan> *thanks.
[00:55:26] <dbaupp> pnathan: and then, in the impls, you put the actual concrete type that you're implementing the trait on (i.e. the thing on the right hand side of the `for`)
[00:56:10] *** Quits: vcl (chatzilla@741D4FEA.76F9E272.DA40C4B3.IP) (Quit: ChatZilla 0.9.90 [Firefox 21.0/20130511120803])
[00:56:53] <pnathan> dbaupp:  Thanks. I should get my code set up in a CI system and fix the breaks as they occur. Much appreciate your help.
[00:57:14] <mark_edward> rusti: trait A { fn foo(&self); } trait B: A { fn bar(&self) { self.foo() } } impl A for uint { fn foo(&self) {} } impl B for uint {} (~1u as ~B).bar()
[00:57:15] -rusti- ()
[00:57:36] <mark_edward> rusti: trait A { fn foo(&self); } trait B: A { fn bar(&self) { self.foo() } } impl A for uint { fn foo(&self) {} } impl B for uint {} 1u.foo()
[00:57:37] -rusti- ()
[00:57:45] <mark_edward> rusti: trait A { fn foo(&self); } trait B: A { fn bar(&self) { self.foo() } } impl A for uint { fn foo(&self) {} } impl B for uint {} 1u.bar()
[00:57:45] -rusti- ()
[00:57:55] <mark_edward> rusti: trait A { fn foo(&self); } trait B: A { fn bar(&self) { self.foo() } } impl A for uint { fn foo(&self) {} } impl B for uint {} (~1u as ~B).foo()
[00:57:56] -rusti- line longer than 150 columns, pastebinned: http://sprunge.us/hKeV
[00:59:08] <dbaupp> mark_edward: trait inheritance is broken for trait objects atm
[00:59:30] <mark_edward> yup. everyday i awaken with a new hope though.
[00:59:49] <cmr> mark_edward: would you like someone to ping you when it's fixed? :P
[01:00:00] <bblum> brson: ping
[01:00:19] <brson> bblum: pong
[01:00:21] <mark_edward> lol, yeah. but is it even something that'd on the roadmap to fiixx soon
[01:01:17] <bblum> brson: so, last week, when i changed join latch to use the no-longer-broken release(), and it made a bunch of the runtime tests fail -- any idea why?
[01:01:36] *** Quits: jclements (jclements@2557E599.66715431.D25A875A.IP) (Quit: jclements)
[01:01:56] *** Quits: hjr3 (hradtke@374E545A.3A8E9B0C.F9D9C60E.IP) (Quit: My MacBook has gone to sleep. ZZZzzzâ€¦)
[01:02:07] <bblum> (all the join latch tests succeeded, so i know it wasn't that it was actually still broken)
[01:02:14] <bblum> (i mean it made a bunch of task and sched tests fail)
[01:03:05] <strcat> ugh
[01:03:18] <strcat> stupid headers
[01:03:50] <nmatsakis> graydon: pong
[01:04:14] <brson> bblum: no, I expected the semantics not to change once release worked
[01:04:28] <bblum> hmm, time to look into it
[01:04:41] <bblum> in theory i have a pull request for you; in practice i have failing tests <_<
[01:05:13] *** Joins: bnicholson (bnicholson@moz-E98974C1.hsd1.ca.comcast.net)
[01:05:25] <graydon> nmatsakis: nbd, I asked patrick. structs with non-'self lifetime &-ptr members
[01:05:30] <graydon> nmatsakis: don't seem to support 'em yet
[01:06:05] <nmatsakis> graydon: no, there's a bug on that...
[01:06:22] *** Quits: BitPuffin (quassel@moz-49828767.cust.tele2.se) (Ping timeout)
[01:06:34] <cmr> strcat: is the OptVec iterator broken?
[01:06:35] <cmr> visit.rs:44:29: 44:84 error: expected std::iterator::FromIterator<&syntax::ast::TyParam,syntax::opt_vec::OptVecIterator<,syntax::ast::TyParam>>, but found std::iterator::FromIterator<syntax::ast::TyParam,<V171>> (expected &-ptr but found struct syntax::ast::TyParam)
[01:06:37] <cmr> visit.rs:44                 type_params: generics.ty_params.iter().collect::<~[ast::TyParam]>(),
[01:06:53] <strcat> no
[01:07:01] <mark_edward> aatch: did you ever make that writeup that you said you would on reeddit?
[01:07:02] <strcat> I don't think it is
[01:07:05] <strcat> cmr: what's the code
[01:07:09] <cmr> strcat: sec
[01:07:17] <aatch> mark_edward, no. I tried, but it's too nebulous
[01:07:19] <strcat> .iter().transform(|&x| x).collect()
[01:07:25] <strcat> cmr: you're missing the derefd
[01:07:33] <mark_edward> okey dokey then
[01:07:39] <aatch> I can point to specific things, but I can't really go "there, that's the problem"
[01:08:09] <mark_edward> i think it'd still be useful to list and describe specific things, perhaps in order of what you feel is important
[01:08:18] <aatch> I have been thinking about a more general "why trans is bad" article though.
[01:08:32] <graydon> aatch: many many reasons!
[01:08:42] <graydon> it's the fixing that's the hard part
[01:08:47] <aatch> graydon, I know...
[01:08:56] <nmatsakis> graydon: does the try branch still confuse bors?
[01:09:02] <graydon> I don't _think_ so
[01:09:08] <strcat> bors ignores try
[01:09:15] <strcat> buildbot does too now
[01:09:25] <Eridius> strcat: random idea: add a default method to Iterator that represents an estimated upper bound on the size of the stream, with 0 meaning no bound
[01:09:33] <strcat> Eridius: it exists
[01:09:35] <Eridius> strcat: this would allow .collect() to grab the right capacity
[01:09:35] <strcat> size_hint
[01:09:37] <Eridius> it does?
[01:09:47] <strcat> -> (Option<uint>, Option<uint>)
[01:09:53] <strcat> lower bound and upper bound
[01:09:58] <Eridius> dammit, when did that get added?
[01:10:00] <bblum> brson: gonna separate my stuff out into a separate file from task.rs; should i call it failure.rs or kill.rs?
[01:10:00] <strcat> must be exact though, not an estimate
[01:10:01] <aatch> Eridius, with None, being "no bound"
[01:10:26] <strcat> you usually only want to preallocate a lower bound
[01:10:36] <bblum> leaning towards kill.rs
[01:10:42] <Eridius> bah, a couple of weeks ago
[01:10:55] <aatch> Eridius, don't worry, it wasn't useful until recently.
[01:11:13] <aatch> since it didn't /actually/ work on FromIterator
[01:11:18] <Eridius> hah
[01:11:26] *** Quits: Kruppe (user@moz-E150F49F.cpe.net.cable.rogers.com) (Client exited)
[01:11:28] <dbaupp> Eridius: (exact in the sense that the bounds have to be definitely <= and => respectively)
[01:11:34] *** Joins: Kruppe (user@moz-E150F49F.cpe.net.cable.rogers.com)
[01:11:42] <strcat> aatch: it could have if it wasn't a default method though
[01:11:48] <aatch> strcat, true.
[01:12:04] <mark_edward> graydon: aatch: it'd still be valuable to members of the community not as versed in compilers and rustc code to see your analysis and judgement on what's wrong
[01:12:21] <Eridius> ok so FilterIterator provides no lower bound
[01:12:35] <Eridius> which means if collect() reserves only the lower bound, and I filter out a single element from my 10000-elt vector, I don't benefit
[01:12:37] <mark_edward> it helps form expectations, bot current and future, and leaves us (and me) better informed on where Rust is and where it's going in this regard
[01:12:38] <dbaupp> Eridius: doesn't it provide Some(0)?
[01:12:46] <Eridius> dbaupp: nope
[01:12:52] <Eridius> (None, upper) // can't know a lower bound, due to the predicate
[01:13:03] <aatch> Eridius, that's because it doesn't know the lower bound.
[01:13:03] <Eridius> not that Some(0) is any more useful than None
[01:13:11] <dbaupp> right
[01:13:34] <strcat> Eridius: you really don't want it to prealloc the upper bound
[01:13:37] <strcat> it could be millions
[01:13:41] <strcat> there's no common sense way to deal with it
[01:13:51] <Eridius> strcat: well what's the upper bound used for?
[01:14:02] <strcat> Eridius: so you don't round higher
[01:14:08] <strcat> and there are other things you can use it for
[01:14:12] <strcat> you can use it to give a time estimate
[01:14:17] <aatch> for completeness.
[01:14:30] <Eridius> what iterators do we have that will generate an upper bound that's different than the lower bound?
[01:14:49] <cmr> strcat: https://github.com/cmr/rustdoc_ng/blob/wip/visit.rs#L44 is the code
[01:14:50] <strcat> filtering, skipping
[01:14:58] <graydon> does anyone run compile_upto with anything other than starting-from-cu_parse?
[01:15:16] <strcat> there are many times you have an upper bound
[01:15:17] <cmr> strcat: and I get https://gist.github.com/cmr/cded122190eb3ff585d7
[01:15:26] <strcat> you might know an upper bound when parsing something
[01:15:28] <strcat> before your parse
[01:15:36] <Eridius> strcat: ok let me rephrase: when will you ever have an upper bound that differs from the lower, and you still have a non-None lower?
[01:15:51] <graydon> urg. rustpkg does.
[01:15:56] <strcat> deserializing some file format
[01:15:56] <Eridius> does this exist in the libraries today or is it just a theoretical "someone could do this"?
[01:16:06] <aatch> Eridius, theoretical.
[01:16:07] <strcat> converting utf-8 to ucs4 chars
[01:16:13] <strcat> it's not theoretical
[01:16:24] <Eridius> strcat: ah, now that's a good example
[01:16:25] <strcat> utf-8 -> ucs4, you have a lower and upper bound from the len of the utf-8
[01:16:27] <strcat> and they are different
[01:16:27] <aatch> strcat, oh, there is a char iterator, right.
[01:16:43] <strcat> but like any deserialization thing
[01:16:43] <Eridius> incidenetally SkipIterator doesn't implement size_hint
[01:16:50] <strcat> Eridius: yep I was lazy and didn't do them all
[01:16:52] <strcat> ;p
[01:16:56] <strcat> some require more thought than others
[01:16:59] <Eridius> that's a shame, that's one where it has exact knowledge
[01:17:06] *** Quits: RMF (RMF@6152834E.A3AF135E.823A4631.IP) (Quit: Textual IRC Client: www.textualapp.com)
[01:17:28] <aatch> Eridius, feel free to implement it :D
[01:17:32] <Eridius> aatch: maybe I will
[01:17:35] <dbaupp> graydon: you can possibly ignore rustpkg for the moment, given cmr's work
[01:17:44] <aatch> dbaupp, rustpkg, not rustdoc
[01:17:49] <dbaupp> oh, oops
[01:18:00] * dbaupp stops embarrassing himself
[01:18:06] <cmr> strcat: do I need an extra transform in there? .iter().transform(|&x| x).collect...
[01:18:08] <strcat> Eridius: it's less trivial than it seems because you
[01:18:19] <strcat> you're reducing both bounds* but you can't go below 0
[01:18:25] <Eridius> strcat: yeah, but that's a simple if
[01:18:31] <strcat> cmr: what do you mean?
[01:19:00] <aatch> Eridius, yeah, but when strcat was implementing it on like 10 different iterators...
[01:19:04] <cmr> strcat: https://gist.github.com/cmr/cded122190eb3ff585d7 (https://github.com/cmr/rustdoc_ng/blob/wip/visit.rs#L44 )
[01:19:43] <strcat> visit.rs:44 type_params: generics.ty_params.iter().collect::<~[ast::TyParam]>(),
[01:19:50] <strcat> iter() gives you &
[01:19:51] *** Quits: kini (kini@moz-92AA953A.members.linode.com) (Ping timeout)
[01:20:07] <strcat> so collect ~[&ast::TyParam] would work
[01:20:10] <strcat> but not that
[01:20:28] *** Joins: bent (chatzilla@moz-932324BF.hsd1.ca.comcast.net)
[01:20:46] <cmr> ah
[01:21:45] <strcat> http://ix.io/6tG/diff my incomplete attempt so far...
[01:21:56] <strcat> I probably need to update the take glue
[01:21:58] <strcat> and drop glue
[01:22:00] <strcat> and everything.
[01:22:29] <Eridius> I count 3 ways to take the minimum of two uints: cmp::min, uint::min, or 3u.min(4u). Is there a recommended approach, or are we just living with this mishmash?
[01:22:32] *** Joins: kini (kini@moz-92AA953A.members.linode.com)
[01:22:42] <Eridius> make that 3u.min(&4u)
[01:22:46] <Eridius> because that one just has to be different
[01:23:14] <dbaupp> Eridius: I'd guess cmp::min
[01:23:17] *** Quits: int3__ (int3_@moz-ABE52D50.hsd1.ca.comcast.net) (Client exited)
[01:23:29] <Eridius> dbaupp: ok good, because that's what I generally use
[01:23:30] <aatch> Eridius, well the last one is because it's a generic approach.
[01:23:42] <dbaupp> Eridius: (or, the method, but not uint::cmp)
[01:24:04] <cmr> aatch: cmp::min is generic
[01:24:20] <aatch> cmr, ... good point.
[01:24:36] <cmr> *more* generic, isn't it?
[01:24:59] <aatch> cmr, I dunno...
[01:25:28] <dbaupp> Well, they *should* be strictly equally generic
[01:25:46] <dbaupp> but that requires robust default methods
[01:25:59] *** Joins: jorendorff (jorendorff@moz-2F32ACA3.hsd1.tn.comcast.net)
[01:26:47] <strcat>     let ty = type_of(ccx, body_t);
[01:26:49] <strcat>     let ty = Type::box(ccx, &ty);
[01:26:51] <strcat>     let boxptr = Po
[01:26:53] <strcat> this is in base.rs
[01:26:55] <strcat> wat??
[01:26:58] <strcat>     let boxptr = PointerCast(bcx, boxptr, ty.ptr_to());
[01:27:22] * strcat shrugs
[01:29:16] <aatch> strcat, don't question base.rs
[01:29:34] *** Quits: paupau (paul@moz-D6583788.hsd1.ca.comcast.net) (Quit: out)
[01:29:57] <strcat> what exactly does the GEPi function do?
[01:30:11] *** Quits: jorendorff (jorendorff@moz-2F32ACA3.hsd1.tn.comcast.net) (Quit: jorendorff)
[01:30:14] *** Joins: reyre_ (reyre@moz-9002CDDA.cpe.net.cable.rogers.com)
[01:30:15] <dbaupp> GetElementPointerIndex?
[01:30:32] <strcat> yeah but...
[01:30:50] <strcat> the types
[01:30:50] <Luqman> strcat: this page is helpful http://llvm.org/docs/GetElementPtr.html
[01:31:32] <strcat> Luqman: I mean our function though, it takes a ValueRef and returns a different type of ValueRef
[01:31:40] <strcat> the actual LLVM API has strong typing, makes a lot more sense
[01:32:20] <enix> are there any samples of using the asm! macro? I can't find any place where its actually being used.
[01:32:25] <aatch> strcat, it's get element pointer, in bounds.
[01:32:36] <aatch> enix, there is in the release notes.
[01:32:42] <strcat> aatch: so the input pointer is the same type as the output?
[01:32:56] <aatch> I am planning on changing it though.
[01:33:05] <aatch> I will write docs at the same too.
[01:33:08] <enix> ah, ok, thanks!
[01:33:16] <cmr> aatch: now you're getting ambitious!
[01:33:36] <strcat> aatch: http://ix.io/6tI I need to do this same type conversion but without the offset
[01:33:50] <strcat> I took all but the last line and used boxptr but that doesn't work
[01:34:10] <nmatsakis> strcat: you probably want GEPi(0, 0)
[01:34:14] <aatch> strcat, no, GEP is a generic facility for getting struct fields, array elements and pointers-to-elements
[01:34:27] <nmatsakis> strcat: though I can't fathom quite what you're trying to do
[01:34:55] <Eridius> strcat: is it worth distinguishing None from Some(x) in lower bounds? I could imagine the latter means "I know this could very well be 0, or it could be larger", and the former means "I have no knowledge whatsoever"
[01:35:01] <dbaupp> rusti: let v = &[1i,2,3]; v.rev_iter().transform(|x| x.to_str()).collect::<~[~str]>()
[01:35:05] <nmatsakis> strcat: so I guess I should say, you *may* want that? it would yield the same pointer, but with a different type.
[01:35:07] -rusti- timeout triggered!
[01:35:08] *** Quits: pnathan (Adium@moz-E3C3FAF2.hfc.comcastbusiness.net) (Quit: Leaving.)
[01:35:23] <aatch> strcat, you can change the [0, box_field_body] to [0, 0]
[01:35:26] <Eridius> strcat: the motivation here is if I .skip(3), and my lower bound is 2, should it become None or Some(0)
[01:35:57] <Eridius> I think I'm going to go with Some(0), because it carries just a tiny bit more meaning to me than None in this case
[01:36:22] <strcat> maybe the lower bound shouldn't be an Option, I dunno
[01:36:34] <Eridius> strcat: hmm, maybe not
[01:36:49] <Eridius> making it (uint, Option<uint>) does make some sense
[01:37:50] <aatch> strcat, the boxptr is a { refcount, tydesc*, box*, box* }*
[01:37:58] <strcat> aatch: okay nvm
[01:38:19] <strcat> okay this is really a mess then
[01:38:38] <cmr> I think it makes sense for the lower bound to be an Option, conceptually, but in practice, the onyl thing I see it useful for is preallocationg, and none is equivalent to 0 in that case.
[01:38:38] *** Joins: snadon (chatzilla@moz-3BC727E8.mc.videotron.ca)
[01:39:14] <strcat> is a lower bound of Some(0) ever not equivalent to None?
[01:39:36] <Eridius> the only reason I can think of is if you want to have some allocation strategy that says split the difference between upper and lower, then you might care about None vs Some(0)
[01:39:41] <Eridius> because with None you might use a different strategy
[01:39:51] <strcat> lets not talk about allocation strategy here, it's not all it's for
[01:39:53] <Eridius> but I don't know if that's worth complicating size_hint for this one theoretical case
[01:39:56] *** Joins: bjz (brendanzab@B398BE78.F804C29E.D35A31DF.IP)
[01:39:58] <strcat> is Some(0) ever semantically different from None?
[01:40:16] <Eridius> strcat: probably not. There's a lower bound of 0 regardless
[01:40:27] <Eridius> the lower bound here just restricts it further. None places no restrictions. Some(x) places a restrction of x
[01:40:35] <Eridius> so Some(0) places the restriction of 0, which we already had
[01:40:36] <strcat> yeah so I don't think it should be an Option
[01:41:00] <Eridius> strcat: ok. do you want to tackle this or shall I go ahead and make the change myself
[01:41:07] <strcat> Eridius: you can do it
[01:41:44] <bblum> aatch: https://github.com/bblum/rust/commit/edb79f1 quick confirm/deny
[01:42:42] *** Quits: snadon (chatzilla@moz-3BC727E8.mc.videotron.ca) (Client exited)
[01:42:54] <strcat>             let ty = type_of(ccx, content_ty);
[01:42:55] <strcat>             let body = PointerCast(bcx, ptr, ty.ptr_to());
[01:42:57] <strcat> I think that's all I want
[01:43:00] <strcat> no Type::box
[01:43:08] * strcat tries
[01:43:42] <strcat> nmatsakis: trying to remove the headers from non-managed ~ allocs
[01:43:43] <strcat> which is fun
[01:43:46] <strcat> so much depends on the header
[01:43:54] <aatch> bblum, looks fine to me.
[01:43:55] <strcat> as in the offset - nothing reads/writes to it anymore
[01:44:00] <bblum> thanks
[01:44:35] <aatch> strcat, yes, it is.
[01:45:45] <nmatsakis> strcat: ah, I see.
[01:45:45] <strcat> aatch: http://ix.io/6tK/diff attempt 2
[01:45:49] <strcat> I at least want a segfault this time
[01:45:51] <strcat> not an LLVM assert
[01:46:17] <strcat> nmatsakis: I already fixed anything that *used* it but that's just half the work ;p
[01:46:35] *** Joins: Axord (xord@moz-C3CCF156.lsanca.dsl-w.verizon.net)
[01:46:41] <strcat> anyway it looks like uniq.rs is copying too much
[01:47:01] <strcat> so hopefully I get a segfault leading back to that and magically nothing else will be a problem...
[01:47:47] <aatch> strcat, nothing jumps out at me.
[01:48:10] *** Joins: RMF (RMF@6152834E.A3AF135E.823A4631.IP)
[01:48:24] <dbaupp> well, this is hilarious :/ it seems that `let v = &[1i]; v.rev_iter().collect::<~[&int]>()` causes memory corruption, even though calling .next() repeatedly on the rev_iter works perfectly fine
[01:48:45] <strcat> ugh
[01:48:50] <strcat> the entire malloc stack in base.rs is wrong
[01:49:00] <strcat> pub struct MallocResult {
[01:49:01] <strcat>     bcx: block,
[01:49:03] <strcat>     box: ValueRef,
[01:49:05] <strcat>     body: ValueRef
[01:49:07] <strcat> }
[01:49:09] <strcat> :(
[01:49:26] <strcat> that's going to be fun to deal with
[01:49:39] <dbaupp> and manually inlining .collect works fine too :/
[01:49:45] *** Joins: ghrust (ghrust@1E8607E8.6A2AE50.F3114085.IP)
[01:49:46] <ghrust> 01[13rust01] 15brson pushed 7 new commits to 06try: 02http://git.io/uX7w-g
[01:49:46] <ghrust> 13rust/06try 145cfad4b 15toddaaro: Refactored the runtime to view coroutines as a component of tasks, instead of tasks as a component of coroutines.
[01:49:46] <ghrust> 13rust/06try 14062bfd3 15toddaaro: merging task/coroutine refactoring back into upstream
[01:49:46] <ghrust> 13rust/06try 1427818ea 15toddaaro: removed unnecessary import that slipped in during merge
[01:49:48] *** Parts: ghrust (ghrust@1E8607E8.6A2AE50.F3114085.IP) ()
[01:49:49] *** Joins: hjr3 (hradtke@moz-E87BDF1F.socal.res.rr.com)
[01:50:14] <aatch> strcat, you could cheat for the moment and make it so box == body
[01:50:29] <sp3d> .collect() seems weird; almost every time I've tried to use it, it's required a type annotation
[01:50:29] <strcat> aatch: I don't want more undef behaviour
[01:50:44] <strcat> aatch: anyway it's easier to try fixing it all
[01:50:46] <aatch> strcat, what would be undef?
[01:50:57] <sp3d> one can't annotate /expressions/ with types, right? :/
[01:50:59] <cmr> sully: "internal compiler error: method not found in AST map?!" that sound familiar?
[01:51:14] <dbaupp> cmr: yeah
[01:51:22] <aatch> cmr, that's from cross-crate inlining of default methods.
[01:51:31] <strcat> aatch: actually from privacy
[01:51:32] <strcat> it turns out
[01:51:37] <aatch> strcat, oh, ok
[01:51:37] <strcat> make: *** [doc/std/index.html] Segmentation fault
[01:51:40] <strcat> that's good
[01:51:43] <cmr> aatch: visit_new isn't inlined.
[01:51:43] <sully> cmr: I've got a fix pending
[01:51:49] <sully> cmr: I'll probably PR it tomorrow
[01:51:56] <dbaupp> cmr: https://github.com/mozilla/rust/issues/7481
[01:51:57] <cmr> sully: awesome. expiditing that would be nice, it's blocking my work on rustdoc2
[01:52:02] *** Joins: alisdair (textual@moz-EBE9F394.bchsia.telus.net)
[01:52:04] *** Joins: snadon (chatzilla@moz-3BC727E8.mc.videotron.ca)
[01:52:38] *** Quits: eschweic1 (Adium@2557E599.66715431.D25A875A.IP) (Quit: Leaving.)
[01:52:39] *** Joins: eholk (eholk@moz-9AB4D52F.hsd1.ut.comcast.net)
[01:52:47] <strcat> malloc_unique is used in one place
[01:52:50] <strcat> I'll just delete it
[01:53:11] *** Joins: fabiand_ (fabiand@moz-1751D893.adsl.alicedsl.de)
[01:53:40] <bblum> aatch: can i get your eyes on this
[01:53:52] <aatch> bblum, sure.
[01:54:00] <dbaupp> sp3d: sort of, you can go `let tmp: type = whatever`
[01:54:01] *** Quits: fabiand (fabiand@moz-DA383042.adsl.alicedsl.de) (Ping timeout)
[01:54:20] <cmr> sp3d: there's also ....collect::<type>()
[01:54:44] <bblum> aatch: say i have one thread doing a cmpxchg(A, Acquire), xadd(B, Release), and another thread doing xadd(B, Release), xchg(A, Acquire)
[01:54:56] <aatch> bblum, ok.
[01:55:01] <sp3d> dbaupp: that's what I've been doing
[01:55:05] <sp3d> cmr: :oooo
[01:55:14] <bblum> aatch: i'm trying to verify that if thread 2 sees thread 1's xchg(B), then they will also see its cmpxchg(A)
[01:55:22] <bblum> or if i should use SeqCst on that cmpxchg
[01:56:01] <bblum> though, i have a hunch that the cmpxchg does not actually need the barrier
[01:56:28] <bblum> or maybe T2's xadd(B) needs to be SeqCst...
[01:56:37] <aatch> bblum, hang on, sorry, can you try that again, I think you mixed some things up... since the xchg and cmpxchg are on different threads
[01:57:01] <bblum> aatch: both of them have an xadd(B, Release). B is a reference count.
[01:58:26] <aatch> bblum, you probably want to make the xadd AcqRel
[01:59:15] <aatch> so it syncs with the xadds in the other threads.
[01:59:45] <bblum> i'd prefer to put the barrier on the cmpxchg if possible; the cmpxchg is the uncommon case
[02:00:01] <aatch> bblum, I'm guessing that's a lock?
[02:00:06] <cmr> http://rustlog.octayn.net/post/54477362712/status-update, good night all
[02:00:18] <bblum> it's not really a lock
[02:00:33] <bblum> it's a flag that tells the last person to drop the refcount how to behave
[02:01:30] *** Joins: erickt (erickt@FF97958E.6FD7DBF2.66399531.IP)
[02:02:35] *** Quits: tikue (tkuehn@2557E599.66715431.D25A875A.IP) (Quit: tikue)
[02:02:57] * strcat is just going to give up soon ;[
[02:03:00] <aatch> hmm, do you have the current code somewhere?
[02:03:08] <dbaupp> strcat: nooo :(
[02:03:13] * dbaupp wants small mallocs
[02:03:14] *** Joins: james4k (james@moz-E7990244.consolidated.net)
[02:03:17] <engla> strcat: it's faster without grow_fn. I haven't tried inlining grow_fn, skipped using it instead..
[02:03:36] *** Quits: carllerche (carllerche@6B070D22.7E6A0813.1428D117.IP) (Quit: carllerche)
[02:03:54] <strcat> everything assumes the header is there
[02:05:07] <bblum> aatch: https://github.com/bblum/rust/commit/f55671e#L1L61
[02:05:23] <bblum> compare against the fn finalize() below it
[02:05:28] <bblum> fill is the cmpxchg
[02:05:33] *** Joins: carllerche (carllerche@6B070D22.7E6A0813.1428D117.IP)
[02:05:43] *** Quits: carllerche (carllerche@6B070D22.7E6A0813.1428D117.IP) (Quit: carllerche)
[02:06:28] <aatch> bblum, this is in .get?
[02:06:42] *** Joins: steven_is_false (user@moz-144077DE.bchsia.telus.net)
[02:06:42] <bblum> no, unwrap()
[02:06:55] *** Joins: azita (Azita@moz-C1FB2A8.hsd1.ca.comcast.net)
[02:09:09] <strcat> yay
[02:09:11] <strcat> rustc: /home/strcat/projects/rust/src/llvm/lib/IR/Instructions.cpp:1084: void llvm::StoreInst::AssertOK(): Assertion `getOperand(0)->getType() == cast<PointerType>(getOperand(1)->getType())->getElementType() && "Ptr must be a pointer to Val type!"' failed.
[02:10:06] <Luqman> yay PointerCast assertion fails :P
[02:10:38] <strcat> anyway I don't understand trans enough to do this
[02:10:56] *** Joins: Jesse_ (jruderman@2557E599.66715431.D25A875A.IP)
[02:10:58] *** Quits: Jesse (jruderman@2557E599.66715431.D25A875A.IP) (Connection reset by peer)
[02:11:09] <strcat> so our 8 byte allocations will continue to be 64-byte and fill cache lines ;p
[02:11:34] *** Quits: brendan (brendaneic@2557E599.66715431.D25A875A.IP) (Quit: brendan)
[02:12:37] *** Quits: azita (Azita@moz-C1FB2A8.hsd1.ca.comcast.net) (Quit: azita)
[02:14:04] *** Joins: Nisstyre (wes@moz-FD86289.netflash.net)
[02:14:12] <aatch> bblum, ok, I think that if you make the fill a release, it will work.
[02:14:32] <bblum> aatch: mind explaining the reasoning? (i want to get better at this)
[02:15:21] <bblum> also: now consider that multiple threads can be doing the fill, and only one of them can succeed. is release still appropriate?
[02:16:04] <aatch> bblum, actually, other way around sorry.
[02:16:18] <bblum> why?
[02:16:33] <aatch> it's the same logic as a lock.
[02:17:09] <aatch> Ugh, memory ordering is hard.
[02:18:54] <bblum> what parts are analogous to what parts of the lock?
[02:19:01] <bblum> the both-releasing-refcount thing makes it weird
[02:19:30] *** Quits: pcwalton (pcwalton@2557E599.66715431.D25A875A.IP) (Quit: pcwalton)
[02:20:01] <aatch> bblum, yeah
[02:20:22] <aatch> everytime I think I have a handle on it, I find a detail that screws it up.
[02:22:10] <strcat> aatch: how do I turn a value type into the type of the pointer to that value again?
[02:22:32] <aatch> strcat, you have a ValueRef?
[02:22:34] <strcat> i8 -> *i8
[02:22:36] <strcat> yes
[02:22:54] <aatch> val_ty(val).ptr_to()
[02:22:58] <strcat> ah
[02:23:23] <aatch> that gets you a Type
[02:24:32] <strcat> alright maybe it'll get a bit further now
[02:25:01] <strcat> was accidentally still using the box ptr type
[02:25:06] <strcat> instead of the actual direct ptr
[02:25:35] <strcat> so it wasn't happy about trying to deref that into the actual type
[02:25:48] * strcat is sure it will still fail for another reason :D
[02:26:28] <strcat> http://ix.io/6tP/diff *shrug*
[02:27:12] <strcat> I guess I should drop the unused align param too
[02:27:19] <strcat> but I'd rather have it working first... ;p
[02:27:24] <aatch> bblum, ok, so Acquire/Release means that there is a happens-before relationship seen by all threads.
[02:28:04] *** Quits: dwrensha (chatzilla@moz-DE44EA45.hsd1.pa.comcast.net) (Ping timeout)
[02:28:18] * strcat really hates these headers
[02:28:24] <strcat> rustc: /home/strcat/projects/rust/src/llvm/include/llvm/IR/Instructions.h:704: llvm::Type* llvm::checkGEPType(llvm::Type*): Assertion `Ty && "Invalid GetElementPtrInst indices for type!"' failed.
[02:28:26] *** Quits: echristo (echristo@D423593A.D6CCE4AE.77834EAA.IP) (Quit: echristo)
[02:28:27] <strcat> meh
[02:28:54] <brson> omg we've got an rc
[02:29:02] <strcat> brson: hm?
[02:29:09] <aatch> bblum, agh, no read the wrong one.
[02:29:48] <bblum> aatch: a friend points out that no matter what T1 does, T2's load-acq can be reordered to before its xadd-rel, unless xadd is acq+rel
[02:30:40] <aatch> bblum, I give up. I have a reference manual for this, but not with me.
[02:30:45] <bblum> heh
[02:30:45] <strcat> http://ix.io/6tQ yet another issue
[02:31:31] <aatch> acq/rel semantics are probably the hardest
[02:32:10] <bblum> aatch: he puts it this way: barriers always need to be paired
[02:32:26] <aatch> bblum, that's what I was thinking.
[02:32:57] <brson> release candidate: https://gist.github.com/brson/5914999
[02:33:01] <brson> graydon^
[02:33:14] *** Quits: alisdair (textual@moz-EBE9F394.bchsia.telus.net) (Quit: My MacBook Pro has gone to sleep. ZZZzzzâ€¦)
[02:33:14] <graydon> \o/
[02:33:26] *** Quits: paulproteus (quassel@rose.makesad.us) (Ping timeout)
[02:33:32] <graydon> want me to run some tests?
[02:33:38] <brson> graydon: sure!
[02:33:38] *** Joins: int3_ (int3_@moz-ABE52D50.hsd1.ca.comcast.net)
[02:33:38] *** Joins: paulproteus (quassel@moz-E86A3B42.makesad.us)
[02:34:46] <aatch> graydon, am I right in thinking that the current state of the asm! syntax extension is just because it was the simplest way?
[02:35:11] <Luqman> aatch: it was mostly copying gcc/clang style inline asm
[02:35:24] *** Joins: pnathan (Adium@moz-E3C3FAF2.hfc.comcastbusiness.net)
[02:35:35] *** Quits: int3_ (int3_@moz-ABE52D50.hsd1.ca.comcast.net) (Ping timeout)
[02:35:37] <brson> I'll do a smoke test here
[02:35:43] <brson> should we ask for testing on rust-dev?
[02:35:49] <graydon> aatch: I don't remember much about its design. someone showed up and said "here, have an asm! syntax" and that was that
[02:36:04] <brson> I'm not totally opposed but it would be great if nobody posted the rc to hn
[02:37:14] <strcat> ^[2rust: task failed at 'assertion failed: heap != heap_exchange', /home/strcat/projects/rust/src/librustc/middle/trans/base.rs:345
[02:37:17] <strcat> well that's a positive
[02:37:20] <strcat> it hit *my* assertion ;p
[02:37:27] <strcat> so at least I know why it's wrong now...
[02:38:05] *** Joins: cowboyd (cowboyd@moz-5476415B.sw.biz.rr.com)
[02:38:10] <aatch> Luqman, except that it really doesn't except for superficial syntax
[02:38:27] <bblum> aatch: do we have a relaxed (non)barrier yet
[02:38:31] <aatch> bblum, yep
[02:38:58] <aatch> we have every combination of barrier and operation that LLVM supports now.
[02:39:12] <Luqman> aatch: yea, more or less. it needs more work
[02:39:40] <brson> I think we know that this rust doesn't work on mac os 10.9. does anybody know what the status on win 8 is?
[02:40:03] <dbaupp> would writing vec::with_capacity() as `let mut vec = init(); vec.reserve(capacity); vec` break things?
[02:40:15] <Luqman> brson: it seemed to worked with my limited testing in a win8 vm
[02:40:21] <brson> Luqman: awesome
[02:40:22] <dbaupp> (where init is the intrinsics one)
[02:40:25] <aatch> Luqman, its the same as in it has (template : inputs : outputs : clobbers : flags), though the flags aren't actually in gcc
[02:40:57] *** Quits: pnathan (Adium@moz-E3C3FAF2.hfc.comcastbusiness.net) (Ping timeout)
[02:41:04] <Luqman> aatch: yes, the last bit was for things you couldn't really do equivalently like select intel or __volatile__
[02:41:19] <aatch> but the actual format for the input and output constraits is completely different.
[02:41:23] *** Joins: alisdair (textual@moz-EBE9F394.bchsia.telus.net)
[02:41:50] <Luqman> aatch: as in the constraints you can specify?
[02:42:01] <aatch> Luqman, no, the way you do it.
[02:42:16] <aatch> LLVM has a really simple version, presumably to make it easier for them.
[02:42:39] <Luqman> oh, $1 vs %1 ?
[02:43:12] <aatch> but it means that a constraint like "a"(n) is 'make sure n is in register a, whatever register a is' on gcc
[02:43:55] *** Quits: eholk (eholk@moz-9AB4D52F.hsd1.ut.comcast.net) (Quit: eholk)
[02:44:04] <aatch> whereas in rust it's 'make sure n is in register a', and if there is no register named a (which there isn't on x86) it fails.
[02:44:48] <aatch> clang/gcc looks at it and goes "that's for ax/eax/rcx"
[02:45:17] <Luqman> yes, cause clang has a bunch of logic before it passes things onto llvm
[02:45:39] <aatch> Luqman, I know, I'm looking at copying it.
[02:46:09] <aatch> I was just making sure there wasn't any reason other than "this is the easiest" for the current setup
[02:47:23] <Luqman> aatch: no, it was basically what's the simplest way to get this to work :P
[02:47:43] *** Quits: Jesse_ (jruderman@2557E599.66715431.D25A875A.IP) (Ping timeout)
[02:48:50] <aatch> Luqman, thought so.
[02:49:07] <aatch> I can make sure I handle all the platforms at once too.
[02:49:43] <aatch> Luqman, but this is what I really want: http://llvm.org/viewvc/llvm-project/cfe/trunk/lib/Basic/Targets.cpp?view=markup#l2830
[02:49:44] *** Quits: zz_kimundi (kimundi@moz-D2CF7906.dip0.t-ipconnect.de) (Ping timeout)
[02:49:46] <brson> graydon: niether RELEASES.txt or CONTRTIBUTING.md is included in the tarball
[02:49:59] *** Joins: sanxiyn (tinuviel@858F408C.B797260D.EF43EC08.IP)
[02:50:00] <graydon> yeah, I noticed those :(
[02:50:32] <strcat> brson: does windows have all the binaries now
[02:50:34] <strcat> ?
[02:50:39] <strcat> before it was missing rustdoc, etc.
[02:50:49] * strcat remembers a lot of complaints ;p
[02:50:52] <graydon> it has rustpkg
[02:51:03] <graydon> and rustdoc, yeah
[02:51:05] <graydon> just checked
[02:51:18] <Luqman> aatch: ya, i had started on bits of it like the default clobbers but haven't worked on it as of late
[02:51:22] <graydon> rustdoc, rustpkg, rusti, rustc, rust
[02:51:27] <graydon> (.exe)
[02:51:35] <strcat> oh good
[02:51:39] <strcat> I have to mess with the free glue
[02:51:42] <graydon> still has the dummy .dlls though
[02:52:06] <strcat> I bet I broke ~Trait too
[02:52:37] * strcat has no idea what goes wrong now though
[02:52:39] <sanxiyn> What is the plan on rustc AST visitor?
[02:52:45] <sanxiyn> Should it be rewritten?
[02:52:50] <aatch> Luqman, I'm interested in trying to drastically improve our low-level runtime code.
[02:52:52] *** Joins: zz_kimundi (kimundi@moz-C54951C.dip0.t-ipconnect.de)
[02:53:05] <aatch> sanxiyn, I have one done, as does... somebody else.
[02:53:09] <sanxiyn> aatch: You mentioned using syscall bypassing libc?
[02:53:09] *** zz_kimundi is now known as kimundi
[02:53:14] <strcat> aatch: you should do this for me ;p, I'm close to clueless
[02:53:16] *** Quits: jensnock_ (jensnocker@moz-8BE55278.customer.t3.se) (Input/output error)
[02:53:19] <aatch> the new visitor is the easiest bit.
[02:53:31] <aatch> it's converting the rest of the codebase to use it.
[02:53:38] <aatch> without making it _worse_
[02:53:44] <sanxiyn> Yeah sure
[02:53:44] <aatch> sanxiyn, yes.
[02:53:55] <graydon> aatch: you have one that uses &Visitor?
[02:54:05] <graydon> er, a &Trait form
[02:54:13] <Luqman> sanxiyn: thanks for rebasing the newtype immediates! 
[02:54:18] <graydon> (not piles-of-@fns)
[02:54:22] <aatch> graydon, not quite, it's a Trait, with default methods
[02:54:22] <sanxiyn> Luqman: No problem. I needed it too.
[02:54:26] <sanxiyn> Luqman: (re: SIMD)
[02:54:32] <aatch> so a new visitor is an implementation of the types.
[02:54:41] <graydon> aatch: that's fine
[02:54:46] <sanxiyn> aatch: Is it available somewhere?
[02:55:00] <aatch> sanxiyn, sure, I have a new_visitor branch open.
[02:55:02] <Luqman> sanxiyn: i had actually rebased it but needed to find that bug :P
[02:55:03] <sanxiyn> (Also, one by "somebody else")
[02:55:15] *** Quits: bent (chatzilla@moz-932324BF.hsd1.ca.comcast.net) (Quit: ChatZilla 0.9.90-rdmsoft [XULRunner 18.0.2/20130201065344])
[02:55:17] <sanxiyn> Luqman: Ah yes, one test fails after rebase...
[02:55:21] <aatch> sanxiyn, I can't remember who though. pnkfelix, I think...
[02:55:58] <aatch> sanxiyn, and yes, using syscalls instead of calling out to ffi.
[02:56:07] <graydon> unfortunately the rc is also not warning-free on stage1/2, but *shrug* we'll live
[02:56:20] <graydon> brson: do you care especially if RELEASES or CONTRIBUTING isn't in the tarball?
[02:56:28] <bblum> alright, now that i figured out my write barriers, the day is done, and i can do two weeks worth of bug triage tomorrow
[02:56:30] <aatch> it makes a significant difference when we aren't allocating big stacks.
[02:56:31] <bblum> <_<
[02:56:44] <graydon> I am not too torn up over it. I mean, we should fix it in the repo but I wouldn't bother with a full rebuild for those. they're easy to find.
[02:56:47] *** Joins: doomlord (doomlod@moz-6651F8D4.range86-145.btcentralplus.com)
[02:56:55] <brson> graydon: no, I just want it to be over!
[02:57:01] <graydon> likewise
[02:57:05] <brson> I'll make a bug for the missing files
[02:57:27] <strcat> stupid pointer cast asserts
[02:57:29] <aatch> for a wrapper that just does the syscall *that doesn't even run on the stack*
[02:57:35] <strcat> it must be derefing a box somewhere
[02:58:15] <sanxiyn> aatch: Yes, seems to be pnkfelix
[02:59:07] <sanxiyn> aatch: Ah, so that's why it is profitable (syscall)
[02:59:20] *** Joins: jdm (jdm@92FB48CA.8B5E9DF.9A8C35B4.IP)
[02:59:23] <aatch> sanxiyn, yes. Go does the same thing for similar reasons.
[02:59:29] <sanxiyn> That's interesting.
[02:59:40] <aatch> I'm also tempted to copy a ton of other stuff off of them...
[02:59:40] <steven_is_false> So, I'm unsure of how to go further with the refactor_arc branch on https://github.com/sstewartgallus/rust.git . I have a ConditionLock trait that's used with the Condition variable but I'm not really sure that's the way to go.
[02:59:51] <steven_is_false> What does everybody else think?
[03:00:04] <strcat> aatch: means we have to write our own allocator and replace libuv though, like Go
[03:00:06] <strcat> if FFI is slow
[03:00:15] <strcat> do we really want to do that?
[03:00:43] <aatch> strcat, well I'm not strictly against it.
[03:00:49] <strcat> lot of work though
[03:00:57] <dbaupp> strcat: does Go have it's own allocator?
[03:00:59] <strcat> and we'll have a whole lot more buggy code
[03:01:02] <strcat> dbaupp: yeah, they use gc
[03:01:06] <strcat> they have their own event loop
[03:01:15] <strcat> they don't use libc and there aren't external deps
[03:01:36] <strcat> and ffi is slow
[03:01:43] <aatch> I'm not saying yes, but there will always be a cost for ffi while we have segmented stacks.
[03:01:46] <strcat> our ffi is slow too, but we use it for everything
[03:01:56] <strcat> so rust is slow
[03:02:06] <strcat> unless all you do is numerics in loops
[03:02:32] <graydon> we're very likely to eliminate segmented stacks in x64, if that's any help
[03:02:47] *** Quits: erickt (erickt@FF97958E.6FD7DBF2.66399531.IP) (Quit: Leaving.)
[03:02:57] <graydon> they don't really make much sense. address space is very very cheap.
[03:03:09] <graydon> they make the most sense on 32bit
[03:03:37] <strcat> the segmented stacks are theoretically smaller than a page though
[03:03:45] *** Quits: snadon (chatzilla@moz-3BC727E8.mc.videotron.ca) (Ping timeout)
[03:03:54] <graydon> sure. what's your point?
[03:04:00] * strcat doesn't really have one
[03:04:07] <strcat> it's just why Go still uses them on 64-bit
[03:04:16] <graydon> really? that .. seems surprising
[03:04:17] <graydon> ok
[03:04:22] *** Joins: ghrust (ghrust@2EE61FCC.6A2AE50.F3114085.IP)
[03:04:22] <ghrust> 01[13rust01] 15bors 04force-pushed 06auto from 14ec06fc8 to 14ab34864: 02http://git.io/N3iJvQ
[03:04:22] *** Parts: ghrust (ghrust@2EE61FCC.6A2AE50.F3114085.IP) ()
[03:04:24] *** Joins: ghrust (ghrust@5FEF1C87.6A2AE50.F3114085.IP)
[03:04:25] <ghrust> 01[13rust01] 15bors pushed 3 new commits to 06auto: 02http://git.io/IUbw7w
[03:04:25] <ghrust> 13rust/06auto 140fc99f1 15Jordi Boggiano: Add an EnumSetIterator and EnumSet::iter
[03:04:25] <ghrust> 13rust/06auto 143fe05a9 15Jordi Boggiano: Move most iter functionality to extra, fixes #7343
[03:04:26] <ghrust> 13rust/06auto 14ef530bb 15bors: auto merge of #7474 : Seldaek/rust/clean-iter, r=thestinger...
[03:04:27] *** Parts: ghrust (ghrust@5FEF1C87.6A2AE50.F3114085.IP) ()
[03:05:09] <aatch> Also, I don't know much about windows support, what's the reason we have a dependency on MingW?
[03:05:09] <steven_is_false> I have a small contribution. If one has lazily allocated memory (the address space is allocated but there's a flag so that actual memory is only used if the memory is used) how fast is it?
[03:05:31] <graydon> aatch: linker
[03:05:34] *** Joins: ghrust (ghrust@2EE61FCC.6A2AE50.F3114085.IP)
[03:05:34] <ghrust> 01[13rust01] 15thestinger 04deleted 06rollup at 14052f28a: 02http://git.io/yYLteg
[03:05:34] *** Parts: ghrust (ghrust@2EE61FCC.6A2AE50.F3114085.IP) ()
[03:05:45] * strcat forgot he made that
[03:06:08] <graydon> aatch: also to some extent "make" (for those of us actually developing it)
[03:06:26] <strcat> libstdc++
[03:06:43] <strcat> we depend on the g++ exception ABI
[03:06:47] <graydon> yeah, we use that too
[03:06:47] <aatch> steven_is_false, that's pretty much how linux's overcommit works.
[03:07:06] <strcat> steven_is_false: pages are lazily allocated
[03:07:11] <graydon> 8pm, guh, I think I am going home
[03:07:15] <graydon> too late to be at office
[03:07:17] <steven_is_false> aatch: Right, so is it faster than segmented stacks?
[03:07:24] <strcat> steven_is_false: a lot faster
[03:07:33] <strcat> steven_is_false: all normal stacks/allocations on linux use lazy allocation
[03:07:34] <graydon> steven_is_false: the problem is contiguity
[03:07:38] <strcat> it faults on a write
[03:07:49] <strcat> and hands you a zeroed page without you seeing it
[03:07:58] <graydon> steven_is_false: you have to guess how many contiguous pages you need for a thread. too few => thread rams into the next thread. too many => you wasted address space.
[03:08:14] <aatch> strcat, or "re-throws" the fault if you haven't been allocated a page there.
[03:08:14] <graydon> but on x64, you have bazillions of pages of address space
[03:08:18] <graydon> not so bad to spend it
[03:08:55] *** Joins: tikue (tkuehn@2557E599.66715431.D25A875A.IP)
[03:08:59] <strcat> aatch: https://github.com/thestinger/rust/commit/8c21e7db97cf6aab57509abab2da4397d5e36c61 closer
[03:09:17] <graydon> brson: installer runs on wine. don't have windows machine here to check. tarball builds on linux.
[03:09:29] <graydon> I'll run windows tests when I get home. thanks for all this.
[03:09:29] <strcat> hopelessly frustrating to track down the source of trans problems though
[03:10:01] <aatch> strcat, I know...
[03:10:08] <strcat> there's yet another place where it tries to store the box type directly to a non-ptr type
[03:10:09] *** Quits: Sorella (queen@B12A78F5.BA14766C.95C8B7C6.IP) (Quit: (quit))
[03:10:14] <strcat> no idea where it does that
[03:11:03] *** Joins: paupau (textual@moz-D6583788.hsd1.ca.comcast.net)
[03:12:40] <brson> graydon: thanks for testing
[03:13:16] *** Quits: brson (brson@2557E599.66715431.D25A875A.IP) (Quit: leaving)
[03:14:04] *** Quits: james4k (james@moz-E7990244.consolidated.net) (Ping timeout)
[03:15:17] *** Quits: tikue (tkuehn@2557E599.66715431.D25A875A.IP) (Quit: tikue)
[03:15:47] <Eridius> strcat: if an iterator returns None, it's safe to assume it should continue to return None forever, right?
[03:15:52] <Eridius> because ScanIterator doesn't make any such guarantee
[03:16:03] <strcat> it should keep returning None
[03:16:28] <Eridius> strcat: ScanIterator doesn't bother keeping track of whether it's ever returned None, so the state function could return None, then Some, etc
[03:16:39] <strcat> it's a requirement on the state function
[03:16:41] <strcat> to be correct
[03:17:08] <Eridius> strcat: that's not a requirement that can be checked
[03:17:35] <strcat> if the state function is incorrect the state function is incorrect, there's no point of double guessing it
[03:17:40] *** Joins: tikue (tkuehn@2557E599.66715431.D25A875A.IP)
[03:18:06] <strcat> each adaptor could not trust the adaptor it's built on
[03:18:10] <strcat> but they all do
[03:18:23] *** Parts: barosl (barosl@E287D94F.C81E10FB.7544CABF.IP) (Left all channels)
[03:18:30] <strcat> if someone writes a buggy iterator (or a buggy state fn), the adaptors won't fix it
[03:18:45] <Eridius> I suppose so
[03:19:04] *** Quits: Earnestly (earnest@2A2BF8F5.321FA5E6.BFD1ABFD.IP) (Ping timeout)
[03:19:06] <strcat> the problem is in almost every single one
[03:19:15] <strcat> if you view it as a problem
[03:19:18] <aatch> Having each adaptor insert a check would kill performance in the common case.
[03:19:35] <strcat> and silently fixing the issue doesn't help anyone
[03:19:42] <strcat> there's still a buggy iterator or state fn
[03:20:20] <strcat> for example, zip assumes they are sane too
[03:20:25] <strcat>         match (self.a.next(), self.b.next()) {
[03:20:26] <strcat>             (Some(x), Some(y)) => Some((x, y)),
[03:20:31] <strcat> if they both return Some, it does
[03:20:38] <Eridius> oh I guess it does
[03:21:45] <Eridius> I dunno, I just feel like the state function isn't really part of the iterator per se, so shouldn't need to have any extra requirements on it in order for the iterator to conform to the iterator protocol, but maybe I'm just being silly
[03:21:50] <graydon> ok heading out for real. ttyl.
[03:21:54] *** Quits: graydon (Adium@A5087023.2354C43D.D8E68FF6.IP) (Quit: Leaving.)
[03:23:11] *** Joins: james4k (james@moz-E7990244.consolidated.net)
[03:23:34] <aatch> Eridius, I don't think it's a significant requirement, no more than the current for-loop protocol.
[03:24:46] *** Quits: alisdair (textual@moz-EBE9F394.bchsia.telus.net) (Quit: My MacBook Pro has gone to sleep. ZZZzzzâ€¦)
[03:25:38] *** Quits: cowboyd (cowboyd@moz-5476415B.sw.biz.rr.com) (Client exited)
[03:26:58] *** Joins: snadon (chatzilla@moz-3BC727E8.mc.videotron.ca)
[03:28:26] <Eridius> strcat: hrm, I'm tempted to give Counter a size_hint of (-1u, None), because (0, None) is clearly wrong. The motivation here is this will allow other iterator adaptors to behave correctly. Thoughts?
[03:28:54] <Eridius> my only concern is if some other code that's not an iterator adaptor sees -1u it might do something silly, but that's probably not a real issue
[03:29:05] <strcat> oh so there's a place where Some(0) and None aren't the same
[03:29:09] <strcat> when it's infinite
[03:29:21] <Eridius> strcat: well 0 is still a valid lower bound. it's just not a very useful one here
[03:29:21] <strcat> it could be cleared up with an enum
[03:29:29] <engla> Eridius: containers will try to reserve space for -1u elements..
[03:29:30] <Eridius> strcat: the problem is None has to be treated the same as 0 if we use Option
[03:29:31] * aatch vaguely remembers going through all this at the time.
[03:29:44] <Eridius> engla: any container that does that will then proceed to try and push infinite elements
[03:29:52] <Eridius> engla: since the push will fail, I'm not concerned about reserving
[03:30:02] <engla> hm ok
[03:30:04] <strcat> Eridius: anyway yes it's fine to use int max there
[03:30:19] <strcat> uint max*
[03:30:43] <Eridius> strcat: ok. I don't expect it to cause a problem, it's just a weird quirk here
[03:31:15] <paupau> no way to borrow two elements of an owned vector simultaneously eh
[03:31:29] <strcat> paupau: you can
[03:31:38] <strcat> you can have any numbers of & borrows
[03:31:42] <dbaupp> paupau: are you trying to borrow them as &mut ?
[03:31:46] <Eridius> strcat: did we ever land somewhere on uint::max_value vs -1u in the standard libraries?
[03:31:59] <strcat> don't know/care ;p
[03:32:03] <Eridius> hah ok
[03:32:38] * strcat officially gives up on ~
[03:32:46] <engla> noo
[03:33:00] *** Quits: paupau (textual@moz-D6583788.hsd1.ca.comcast.net) (Quit: Textual IRC Client: www.textualapp.com)
[03:33:19] <sp3d> ^
[03:33:20] *** Joins: paupau (paul@moz-D6583788.hsd1.ca.comcast.net)
[03:35:54] *** Quits: james4k (james@moz-E7990244.consolidated.net) (Ping timeout)
[03:39:16] <aatch> strcat, how far did you get?
[03:40:05] <strcat> aatch: https://github.com/mozilla/rust/issues/5026#issuecomment-20393558
[03:40:17] <strcat> aatch: I had it compiling at least, but segfaulting
[03:40:26] <strcat> but now it just hits an assert after I tried to fix expression trans
[03:40:47] <strcat> well I don't remember exactly when it started hitting the assert because I had to fix something else leading up to it
[03:41:26] <aatch> strcat, heh. I might take over if you don't get back to it.
[03:41:29] <strcat> in theory box_body now returns a *T instead of a *Box<T> (approximated types ;p)
[03:41:36] <strcat> aatch: well I won't atm, I need a break from it :)
[03:42:18] <aatch> Right now though, I'm making our handling of target information better.
[03:42:36] * strcat probably made a stupid mistake
[03:42:42] <strcat> don't see it though
[03:42:44] <strcat> ;p
[03:43:52] *** Quits: heftig (heftig@moz-AA4684.dip0.t-ipconnect.de) (Ping timeout)
[03:46:07] *** Quits: paupau (paul@moz-D6583788.hsd1.ca.comcast.net) (Ping timeout)
[03:46:39] <strcat> oh
[03:46:45] <strcat> hrm
[03:46:54] * strcat tries something
[03:47:50] <bblum> go strcat, try that something, try it hard
[03:47:59] *** Quits: Kruppe (user@moz-E150F49F.cpe.net.cable.rogers.com) (Client exited)
[03:48:04] <strcat> :D
[03:48:23] * strcat waits for a PointerCast assert
[03:48:52] <sanxiyn> aatch: Target information?
[03:49:42] <strcat> aatch: at least the IR we make for 'let x = ~5' is enormously saner
[03:49:50] <strcat> from my other two pulls
[03:50:01] *** Joins: heftig (heftig@moz-A3FE237F.dip0.t-ipconnect.de)
[03:50:16] <strcat> an alloca, a call to exchange_malloc with align/size and a store
[03:50:17] <aatch> sanxiyn, so the way we store and handle stuff like the data layout, type widths, string triples.
[03:50:52] <aatch> it's all spread out and somewhat incomplete at the moment.
[03:51:48] <sanxiyn> aatch: Aren't they mostly in librustc/back?
[03:52:00] <aatch> sanxiyn, some of it, yes.
[03:52:23] <dbaupp> sanxiyn: a lot is in librustc/driver too
[03:52:25] *** Joins: mnemotic (niko@8FFD1BD2.9D81E74C.53DF0002.IP)
[03:52:35] <aatch> but I also want to extend it to stuff like register information
[03:53:11] <sanxiyn> aatch: Why? (registers)
[03:53:21] <aatch> sanxiyn, for better asm! support
[03:53:29] <sanxiyn> Hm
[03:53:53] <strcat> aatch: how about ty::t -> ptr to that type
[03:53:55] <strcat> ?
[03:54:09] <aatch> strcat, type_of(ty).ptr_to()?
[03:54:15] <strcat> I mean not llvm
[03:54:19] <strcat> rust ptr to that type
[03:54:30] <strcat> int -> *int (both as ty::t)
[03:54:32] <aatch> strcat, oh, uh, there is a way.
[03:54:42] <sanxiyn> strcat: *int as in unsafe pointer?
[03:55:04] <strcat> sanxiyn: hm
[03:55:08] <aatch> strcat, there probably isn't a specific function though.
[03:55:13] <sanxiyn> strcat: ty::mk_ptr etc
[03:55:27] <strcat> this actually isn't the issue anyways
[03:55:36] <aatch> sanxiyn, so there is.
[03:56:07] <strcat> aatch: I think somewhere I need to teach it to teach ~ for non-managed to the proper LLVM type
[03:56:10] <strcat> instead of a box pointer
[03:56:12] *** Joins: barosl (barosl@E287D94F.C81E10FB.7544CABF.IP)
[03:56:29] <strcat> I'm sure there are other things too
[03:56:47] <sanxiyn> type_of_non_gc_box?
[03:57:26] <aatch> strcat, well the proper llvm type should just be a pointer to the type, right?
[03:57:30] <strcat> aatch: yes
[03:57:46] <strcat> I guess it's type_of_non_gc_box that needs updating
[03:57:54] <strcat> Type::unique too
[03:57:57] <sanxiyn> aatch: Oh, type_of now returns Type instead of TypeRef?
[03:57:59] <sanxiyn> That's great
[03:58:05] <aatch> sanxiyn, yep
[03:58:10] <strcat> it's such a pain because managed-unique and unique are now totally different
[03:58:25] <strcat> and all this code treats them the same
[03:58:26] <aatch> strcat, yeah, I just copied the existing code.
[03:58:34] *** Quits: SiegeLord (sl@moz-CAF07B4C.hsd1.ma.comcast.net) (Quit: Leaving)
[03:58:59] <strcat> I thought ty_box was @
[03:59:06] <strcat> and ty_uniq was ~
[03:59:24] <strcat> why is type_of_non_gc_box translating ty_box?
[03:59:26] <strcat> :|
[03:59:57] <aatch> strcat, what do you mean?
[04:00:00] <strcat> anyway
[04:00:08] <strcat> type_of_non_gc_box is unused
[04:00:15] <sanxiyn> Yeah indeed... :(
[04:00:20] <strcat> the only thing that calls it is type_of_non_gc_box recursively
[04:00:23] <aatch> oh, heh. just realized...
[04:00:51] <sanxiyn> strcat: It seems that you need to edit type_of (and sizing_type_of) directly
[04:00:55] <sanxiyn> on relevant match arms
[04:01:22] *** Joins: ghrust (ghrust@C8693FCB.6A2AE50.F3114085.IP)
[04:01:22] <ghrust> 01[13rust01] 15bors 04force-pushed 06auto from 14ef530bb to 14ab34864: 02http://git.io/N3iJvQ
[04:01:22] *** Parts: ghrust (ghrust@C8693FCB.6A2AE50.F3114085.IP) ()
[04:01:23] *** Joins: ghrust (ghrust@5FEF1C87.6A2AE50.F3114085.IP)
[04:01:23] <ghrust> 01[13rust01] 15bors pushed 2 new commits to 06auto: 02http://git.io/XfFVHA
[04:01:23] <ghrust> 13rust/06auto 149c3ef89 15Luqman Aden: configure: Require one of wget or curl.
[04:01:23] <ghrust> 13rust/06auto 14fc02d69 15bors: auto merge of #7498 : luqmana/rust/cow, r=catamorphism...
[04:01:24] *** Parts: ghrust (ghrust@5FEF1C87.6A2AE50.F3114085.IP) ()
[04:01:38] <strcat> ahhhhhh I hate ~
[04:01:45] <strcat> and I hate @ even more
[04:01:50] <strcat> and especially ~ with @ in it
[04:01:51] <strcat> ;p
[04:02:40] *** Joins: sankha93 (Instantbir@73CCD62.549EE3E8.8B6C1D65.IP)
[04:02:58] <bjz> :)
[04:03:55] <dbaupp> strcat: just remove @ entirely? :P
[04:04:01] <sanxiyn> strcat: How does one know type does not contain @?
[04:04:04] <sanxiyn> TC_MANAGED?
[04:04:09] <strcat> sanxiyn: yes but
[04:04:19] <strcat> ty::type_contents(type_context, type).contains_managed()
[04:04:29] <strcat> it checks for TC_MANAGED
[04:04:44] <strcat> anyway figured this minor thing out
[04:06:15] <strcat> I probably did half of these changes wrong
[04:06:24] <strcat> but at least I found most of the places that have to be changed
[04:06:26] <strcat> :p
[04:06:51] <strcat> someone who knows trans well could probably look at the commit and find what I did wrong...
[04:07:15] <strcat> https://github.com/thestinger/rust/commit/1eba1acc595c3440108a2214b4e21cc4a1001183 >;)
[04:07:17] <sanxiyn> Ugh bors failed on something ARM-related...
[04:07:23] <strcat> anyway this is only for ~T without @ inside it
[04:07:28] <strcat> I separately ~[]
[04:07:39] <strcat> ~Trait is probably broken by this change
[04:07:43] <strcat> hopefully nothing uses it? ;p
[04:08:32] <sanxiyn> strcat: So... that works?
[04:09:44] <bblum> strcat: there should be a type_has_managed wrapper which calls even that
[04:09:51] <strcat> sanxiyn: probably not
[04:09:52] <strcat> compiling now
[04:09:54] <sanxiyn> rustc: for the -arm-enable-ehabi option: may only occur zero or one times!
[04:09:54] <sanxiyn> rustc: for the -arm-enable-ehabi-descriptors option: may only occur zero or one times!
[04:09:57] <sanxiyn> (From rustpkg test)
[04:10:15] <strcat> 50% chance it will hit an LLVM assert
[04:10:26] <strcat> 49% chance it will die from memory corruption, SIGILL, a segfault, etc.
[04:10:57] <sanxiyn> Eh... but there actually is a check to ensure those are not set more than once... Check must be inadequate :(
[04:11:20] *** Quits: tikue (tkuehn@2557E599.66715431.D25A875A.IP) (Quit: tikue)
[04:11:42] <strcat> llvm assert
[04:11:44] <strcat> yay
[04:11:49] <strcat> rustc: /home/strcat/projects/rust/src/llvm/include/llvm/IR/Instructions.h:704: llvm::Type* llvm::checkGEPType(llvm::Type*): Assertion `Ty && "Invalid GetElementPtrInst indices for type!"' failed.
[04:11:50] <strcat> ;[
[04:11:59] <strcat> glue is probably all broken
[04:12:19] <Eridius> I don't know who Jed Estep is, but the reverse iterators in extra::deque are bad
[04:12:31] <Eridius> (he apparently wrote the current impl)
[04:12:36] <strcat> Eridius: why?
[04:12:53] <Eridius> strcat: because it subtracts 1 from a uint, and then uses % on the vec len, but underflow will break it
[04:13:02] <strcat> ah
[04:13:05] <Eridius> rather, since it's a circular buffer, it uses vec[idx % len]
[04:13:11] <Eridius> and idx is a uint that is decremented in the reverse iterators
[04:13:32] <engla> I have a branch for a few deque changes but I haven't seen that
[04:13:37] <Eridius> the impl of pop_back correctly checks if hi is 0 and wraps it around manually, but the iterator doesn't
[04:13:38] <strcat> the tests probably just push stuff and make a contiguous buffer
[04:14:15] * jld is a different Jed, for reference.
[04:14:30] <Eridius> yeah his test doesn't actually involve the circularity of the buffer
[04:14:46] <Eridius> well no I lie, it actually does. hmm
[04:15:00] <Eridius> rusti: -1u % 13
[04:15:01] -rusti- 2
[04:15:15] <sanxiyn> ?!
[04:15:16] <Eridius> oh maybe reallocation busts this
[04:15:40] <sanxiyn> Is that 2^64-1 % 13 == 2?
[04:15:46] <engla> deque changes, I'll submit these tomorrow https://github.com/blake2-ppc/rust/commits/deque
[04:15:55] <strcat> sanxiyn: yep
[04:16:04] <engla> Eridius: it should be simple to just make the iterator count from 0 to nelt
[04:16:06] *** Quits: lmandel (lmandel@moz-BBE1EA67.dsl.bell.ca) (Quit: lmandel)
[04:16:10] <aatch> rusti: -2u % 13
[04:16:10] -rusti- 1
[04:16:16] <aatch> rusti: -3u % 13
[04:16:17] -rusti- 0
[04:16:17] *** Joins: paupau (paul@moz-D6583788.hsd1.ca.comcast.net)
[04:16:19] <engla> Eridius: and the reverse for reverse.
[04:16:20] <strcat> engla: and just index it?
[04:16:24] <engla> yeah
[04:16:32] <strcat> yep it should probably just do that
[04:16:49] <engla> graydon said today he wanted a new impl of deque that was unsafe
[04:16:56] <Eridius> the iterator will have to gain a new field corresponding to deque.lo, but that's certainly doable
[04:17:09] <klutzy> rusti: (0u - 1u) % 13
[04:17:10] -rusti- 2
[04:17:16] <strcat> engla: yeah but it's non-trivial
[04:17:19] <strcat> it can't use malloc/realloc
[04:17:21] *** Quits: lkuper (lkuper@moz-C0CD33ED.hsd1.in.comcast.net) (Ping timeout)
[04:17:31] <engla> it has to involve the runtime
[04:17:33] <strcat> it has to have contains_managed checks everywhere
[04:17:38] <strcat> and use the runtime memory region crap
[04:17:49] <engla> but.. if @ goes away?
[04:17:58] <strcat> we will still need contains_managed checks
[04:18:02] <strcat> gc isn't going to go away
[04:18:07] <strcat> the syntax might
[04:18:09] <strcat> not the concept
[04:19:42] *** Quits: robn (robn@moz-76B0302C.static.internode.on.net) (Ping timeout)
[04:20:09] *** Quits: paupau (paul@moz-D6583788.hsd1.ca.comcast.net) (Ping timeout)
[04:22:13] <Eridius> I'm surprised DequeIterator keeps a &-ptr and uses transmute(), instead of keeping a &mut-ptr and just borrowing as & for the immutable variants
[04:22:21] *** Joins: robn (robn@moz-76B0302C.static.internode.on.net)
[04:22:51] <strcat> Eridius: it should just generate both kinds
[04:22:54] <strcat> and not convert at all
[04:23:05] <strcat> shouldn't be unsafe :s
[04:23:07] <Eridius> it uses a macro to generate the actual impl
[04:23:19] <strcat> Eridius: so it should take &'self T as a param to the macro
[04:23:24] <strcat> or &'self mut T
[04:23:31] <Eridius> yeah I guess
[04:23:52] *** Quits: kini (kini@moz-92AA953A.members.linode.com) (Ping timeout)
[04:23:54] *** Joins: pnathan (Adium@moz-E3C3FAF2.hfc.comcastbusiness.net)
[04:24:08] <strcat> or rather, ref vs ref mut
[04:24:32] <Eridius> rusti: -1u % 8
[04:24:33] -rusti- 7
[04:24:39] <Eridius> ..well that's why the test passes. goddammit
[04:24:50] <Eridius> that tricky Jed, he constructed a test that passed coincidentally
[04:25:15] *** Quits: mnemotic (niko@8FFD1BD2.9D81E74C.53DF0002.IP) (Ping timeout)
[04:25:17] <Eridius> rusti: -1u % 9
[04:25:19] -rusti- 6
[04:25:28] <sanxiyn> That's pretty funny
[04:25:57] <aatch> should work for any power-of-two, I think
[04:26:06] <Eridius> aatch: good point
[04:26:07] <aatch> rusti: -1u % 16
[04:26:07] -rusti- 15
[04:26:11] <aatch> rusti: -1u % 32
[04:26:11] <jld> So, I'm unfamiliar with this code -- is the size of the buffer... uh, or what aatch said while I was typing.
[04:26:12] -rusti- 31
[04:26:18] *** Joins: kini (kini@moz-92AA953A.members.linode.com)
[04:26:37] <jld> rusti: -3u & 31
[04:26:38] -rusti- 29
[04:26:39] *** Joins: doener (doener@moz-121949B3.unitymediagroup.de)
[04:26:42] <jld> rusti: -3u % 32
[04:26:42] -rusti- 29
[04:26:54] <aatch> rusti: fmt!("%t", -1u)
[04:26:55] -rusti- ~"1111111111111111111111111111111111111111111111111111111111111111"
[04:26:58] <Eridius> ..waa? I just bumped it up to 9 elements, and it still passed. This doesn't make sense
[04:28:36] *** Quits: sanxiyn (tinuviel@858F408C.B797260D.EF43EC08.IP) (Quit: Leaving)
[04:29:53] *** Quits: pnathan (Adium@moz-E3C3FAF2.hfc.comcastbusiness.net) (Ping timeout)
[04:29:57] <Eridius> oh durrrr, the length isn't 9. It's actually 32
[04:30:03] <Eridius> so yeah, tricksy again.
[04:30:09] <Eridius> rather the capacity is 32, and that's what matters
[04:30:24] <engla> hehe
[04:31:39] <engla> I'd like to change deque to use method names push_back instead of add_back
[04:31:44] <Eridius> makes sense
[04:31:58] <engla> you can't have add/pop pairs.. add/remove and push/pop should be together
[04:32:19] <Eridius> push_back is already used elsewhere, so it would be more consistent to use that here
[04:32:50] <Eridius> might also make sense to change add_front/pop_front to unshift/shift, since I think we're using that on vectors
[04:33:02] <engla> true
[04:33:13] <engla> I'm not used to those names but it would be consistent
[04:33:17] <Eridius> hrm, deque never shrinks, even if you call clear()
[04:33:47] <Eridius> engla: hrm, there's peek_front() as well which has no analogue with shift/unshift, so maybe keep push/pop after all
[04:34:04] <engla> not sure
[04:34:04] <Eridius> rusti: -1u % 33
[04:34:05] -rusti- 15
[04:35:02] *** Joins: echristo (echristo@moz-1892C634.hsd1.ca.comcast.net)
[04:36:45] *** Quits: echristo (echristo@moz-1892C634.hsd1.ca.comcast.net) (Ping timeout)
[04:37:20] <Eridius> hmm deque.reserve() is completely useless, since deque never consults the capacity of the vector, only the length
[04:37:24] <Eridius> so if I reserve extra space, it will never use it
[04:37:59] <Eridius> this deque test _really_ wants to pass the wrong way
[04:38:56] <engla> Eridius: if you want to see something wrong, see this https://github.com/blake2-ppc/rust/commit/d7dec5d55f97cc9d74bcf048feae595b39572c23
[04:39:14] <Eridius> hmm, I'm pretty sure that once a deque passes 32 elements it's going to start growing on every single push
[04:39:23] <Eridius> because, again, it doesn't use the vector's capacity, just its length
[04:39:35] <engla> no
[04:39:45] *** Joins: echristo (echristo@60A74940.D6CCE4AE.77834EAA.IP)
[04:39:45] <engla> it fills up with None
[04:39:45] <Eridius> no?
[04:39:54] <engla> yes no
[04:39:57] <Eridius> engla: it grows to nelts+1
[04:40:14] <engla> I just worked on this code, see the commit linked. It adds nelts+1 elements
[04:40:15] <Eridius> the backing vector will have a capacity equal to the next power of 2, due to implementation details of grow(), but the deque wont' care
[04:40:20] <engla> which is a strange choice in itself
[04:40:29] <Eridius> ooh grow _adds_ that many, not grows to that many?
[04:40:43] <Eridius> ok, I take it back. I think whomever wrote deque's grow had no idea what they were doing
[04:40:58] <engla> yes
[04:41:15] <engla> well it's going to be fixed
[04:41:19] <Eridius> although this does present the opportunity to create a 65-element backing vector, which should break the test
[04:41:33] <Eridius> although I'm not sure I want to write a test that makes so many assumptions about broken implementation details, especially if you're about to fix it
[04:41:48] <dbaupp> engla: 400000ns -> 1500ns o_O
[04:41:49] <Eridius> anyway the point remains that reserve() doesn't do anything remotely useful for deque
[04:42:24] <engla> yeah
[04:43:12] <engla> dbaupp: that's a lot of nanoseconds for just a 65-element deque
[04:43:41] <dbaupp> engla: lucky you removed most of them :D
[04:44:26] *** Quits: enix (enix@moz-A50569DD.c3-0.slvr-ubr1.lnh-slvr.md.cable.rcn.com) (Quit: Konversation terminated!)
[04:46:00] <strcat> still really slow
[04:46:26] <strcat> engla: so reserve doesn't work? :\
[04:46:36] <engla> I didn't look at reserve
[04:46:38] <strcat> I thought it was just calling grow
[04:46:41] <strcat> or something like that
[04:46:45] <engla> it just calls it through to the vec
[04:47:11] <strcat> ah so the issue was grow
[04:47:15] <engla> yeah
[04:47:21] <Eridius> deque defines reserve() which calls to the vec, but deque never actually consults the vec's capacity, only its length, so reserve is wholly pointless
[04:47:24] <engla> look at the old version of grow using grow_fn
[04:47:37] <engla> and creating a new vec, moving everything
[04:48:54] <engla> Eridius: maybe it can be removed
[04:49:24] <Eridius> well it would be nice to support a sensible reserve()
[04:49:49] <Eridius> although I'm not sure if there's any reasonable implementation once you've done any prepending except for basically growing
[04:50:08] <Eridius> actaully yeah, I think deque's reserve needs to just grow the vector.
[04:50:09] <engla> you can do the same as the new grow code, just push a None until it's full
[04:50:14] <strcat> engla just made one
[04:51:31] *** Joins: paupau (paul@moz-D6583788.hsd1.ca.comcast.net)
[04:54:23] *** Quits: paupau (paul@moz-D6583788.hsd1.ca.comcast.net) (Ping timeout)
[05:01:20] *** Joins: paupau (paul@moz-D6583788.hsd1.ca.comcast.net)
[05:01:43] *** Quits: kini (kini@moz-92AA953A.members.linode.com) (Client exited)
[05:03:07] *** Quits: paupau (paul@moz-D6583788.hsd1.ca.comcast.net) (Quit: out)
[05:05:14] *** Quits: echristo (echristo@60A74940.D6CCE4AE.77834EAA.IP) (Quit: echristo)
[05:07:00] <aatch> huh, for some reason the mac description string is different to the others on 64-bit
[05:08:51] <strcat> aatch: anyway if you want to take a look at fixing that branch, that'd be great
[05:08:53] <strcat> going to sleep \o
[05:08:56] *** Quits: strcat (strcat@moz-54F7FD49.cpe.net.cable.rogers.com) (Quit: WeeChat 0.4.1)
[05:09:41] <Luqman> aatch: how so?
[05:09:59] <aatch> Luqman, it's missing the "-S128" at the end.
[05:10:11] <aatch> I don't know why
[05:10:14] <aatch> or what it means
[05:10:27] <aatch> but it's not like that in Clang
[05:10:37] <Luqman> odd. though i've never noticed anything weird with rust on x64 mac
[05:11:00] <aatch> Luqman, I doubt it makes a difference
[05:11:29] *** Joins: kini (kini@moz-92AA953A.members.linode.com)
[05:13:42] *** Joins: tedh (tedh@moz-190F9C83.static.mdsn.wi.charter.com)
[05:16:04] <sp3d> bg; disown; unset HISTFILE; exit
[05:16:17] <aatch> sp3d, bye
[05:16:52] *** Quits: bytbox (s@moz-D4F26CEB.hsd1.md.comcast.net) (Ping timeout)
[05:16:54] *** Joins: bytbox (s@moz-D4F26CEB.hsd1.md.comcast.net)
[05:17:45] *** Joins: brson (brson@E9CDE21E.991753BB.CA4D1600.IP)
[05:17:45] *** ChanServ sets mode: +o brson
[05:20:35] *** Quits: Amanieu (amanieu@moz-D5D10CA8.halls.manchester.ac.uk) (Connection reset by peer)
[05:21:26] *** Joins: Amanieu (amanieu@moz-D5D10CA8.halls.manchester.ac.uk)
[05:29:21] *** Quits: bytbox (s@moz-D4F26CEB.hsd1.md.comcast.net) (Ping timeout)
[05:29:48] *** Joins: sk (sk@1696E5A5.E92B26F8.78DD174B.IP)
[05:40:22] *** Joins: ghrust (ghrust@79968228.6A2AE50.F3114085.IP)
[05:40:22] <ghrust> 01[13rust01] 15bors merged 06auto into 06master: 02http://git.io/XfFVHA
[05:40:22] *** Parts: ghrust (ghrust@79968228.6A2AE50.F3114085.IP) ()
[05:41:15] *** Quits: reyre_ (reyre@moz-9002CDDA.cpe.net.cable.rogers.com) (Client exited)
[05:43:21] *** Joins: ghrust (ghrust@AD60B2E3.6A2AE50.F3114085.IP)
[05:43:21] <ghrust> 01[13rust01] 15bors pushed 0 new commits to 06auto: 02http://git.io/u6Lz1Q
[05:43:21] *** Parts: ghrust (ghrust@AD60B2E3.6A2AE50.F3114085.IP) ()
[05:43:23] *** Joins: ghrust (ghrust@5FEF1C87.6A2AE50.F3114085.IP)
[05:43:23] <ghrust> 01[13rust01] 15bors pushed 2 new commits to 06auto: 02http://git.io/1ZizRg
[05:43:23] <ghrust> 13rust/06auto 143100483 15gareth: When an impl references an unknown trait, mention what...
[05:43:23] <ghrust> 13rust/06auto 14025dc6e 15bors: auto merge of #7510 : Dretch/rust/missing-trait-message, r=catamorphism
[05:43:23] *** Parts: ghrust (ghrust@5FEF1C87.6A2AE50.F3114085.IP) ()
[05:49:05] <bblum> oh wait geez hold on with the release candidate
[05:49:16] <bblum> does the release candidate have my change to make stack closures noncopyable,
[05:49:35] <bblum> but NOT my change to emit a better error message when you move one away?
[05:49:46] <acrichto> bblum: it's got master up to about an hour ago I think
[05:49:51] <bblum> then yes :X
[05:50:19] <bblum> i don't wanna be a troublemaker or anything but it would be a real disaster to make a release without the good error message for that obscure case
[05:50:34] <bblum> we'll have bricks through our windows
[05:51:03] <dbaupp> (Rust's "releases" aren't really releases, so it's not *entirely* the end of the world.)
[05:51:10] <bblum> yeah i know but
[05:51:26] <bblum> (the error message says, "capture it in a new closure, e.g. |x| f(x), to override")
[05:52:25] <bblum> we're gonna be answering questions about this a lot, is all i'm saying
[05:53:04] <aatch> bblum, just add it to the list
[05:53:09] <bblum> what list?
[05:53:18] <aatch> of things we keep having to explain
[05:53:24] <aatch> but plan to change
[05:53:25] <dbaupp> Add a page to the wiki with an explanation, that we can link people to?
[05:53:30] <bblum> well, where is this
[05:53:39] <aatch> bblum, in my head, mostly
[05:53:46] <bblum> aatch: i see how it is
[05:53:48] <dbaupp> (maybe make an actual page, and put the list on that page)
[05:54:02] <bblum> alright
[05:54:31] <dbaupp> "Features that are currently broken and/or with poor error messages"
[05:54:34] <dbaupp> or something
[05:54:37] <engla> bblum: that error is going to appear a lot inside for loops. But when closure loops disappear, it's less of an issue
[05:55:03] <aatch> dbaupp, that is a very good idea for an early language like Rust.
[05:55:31] <dbaupp> (should it be relative to the latest release or the "current" master?)
[05:55:51] <aatch> it's the "We know it's bad, we are trying to/in the middle of/want to fix it" list
[05:55:59] <bblum> aatch: dbaupp: we appear to have https://github.com/mozilla/rust/wiki/Doc-usage-FAQ
[05:56:04] <bblum> we should use this page maybe
[05:56:38] <dbaupp> that looks slightly different, i.e. those features are (mostly) working as expected?
[05:56:44] <bblum> i see
[05:56:44] <aatch> bblum, nah, we need a partner for this: https://github.com/mozilla/rust/wiki/Doc-language-FAQ
[05:56:56] <aatch> it's evil twin.
[05:57:08] *** Joins: james4k (james@moz-E7990244.consolidated.net)
[05:57:13] <dbaupp> (well, I guess 2 of them are working as expected, and 2 aren't)
[05:58:01] <bblum> aatch: "Doc-warts-FAQ"?
[05:58:19] <aatch> bblum, yeah. that makes sense
[06:02:12] <engla> aren't warts generally hard to remove
[06:02:20] <engla> say things in the language that it's too late to change
[06:02:59] *** Quits: brson (brson@E9CDE21E.991753BB.CA4D1600.IP) (Quit: leaving)
[06:02:59] <bblum> "Doc-under-construction-FAQ"?
[06:04:30] <yichoi> some path seems not call back::link::sanitize
[06:05:45] *** Quits: jdm (jdm@92FB48CA.8B5E9DF.9A8C35B4.IP) (Ping timeout)
[06:08:25] *** Quits: sankha93 (Instantbir@73CCD62.549EE3E8.8B6C1D65.IP) (Quit: Instantbird 1.4 -- http://www.instantbird.com)
[06:08:41] *** Quits: tedh (tedh@moz-190F9C83.static.mdsn.wi.charter.com) (Client exited)
[06:11:20] *** Joins: quvarxa (chatzilla@moz-978E4C31.static.tpgi.com.au)
[06:11:36] *** Joins: reyre_ (reyre@moz-9002CDDA.cpe.net.cable.rogers.com)
[06:12:27] *** Joins: pnathan (Adium@moz-E3C3FAF2.hfc.comcastbusiness.net)
[06:14:29] *** Quits: reyre_ (reyre@moz-9002CDDA.cpe.net.cable.rogers.com) (Ping timeout)
[06:15:32] *** Quits: duckinator (nick@moz-74B346B5.mostlyincorrect.info) (Quit: Nickname collision due to Services enforced nickname change, your nick was overruled)
[06:17:17] *** Joins: paupau (NEAT@moz-C616DA0A.hsd1.ca.comcast.net)
[06:18:24] *** Quits: pnathan (Adium@moz-E3C3FAF2.hfc.comcastbusiness.net) (Ping timeout)
[06:23:05] *** Joins: duckinator (nick@moz-74B346B5.mostlyincorrect.info)
[06:23:14] *** Joins: tikue (tkuehn@moz-A7CDB794.dia.static.qwest.net)
[06:27:54] *** Quits: steven_is_false (user@moz-144077DE.bchsia.telus.net) (Client exited)
[06:29:55] <aatch> Why on earth is there ABI stuff in libsyntax?
[06:31:26] <bblum> aatch: https://github.com/mozilla/rust/wiki/Doc-under-construction-FAQ
[06:31:28] <bblum> please add your stuff
[06:31:42] <dbaupp> aatch: isn't it mostly parsing?
[06:31:55] <aatch> dbaupp, in what way?
[06:32:13] <dbaupp> aatch: `extern "some abi" fn`
[06:32:17] <dbaupp> but no, I just looked
[06:32:23] <dbaupp> I agree with you
[06:32:37] <aatch> dbaupp, that's fine, but libsyntax shouldn't care about the contents fo "some abi"
[06:32:46] <dbaupp> aatch: yeah
[06:32:53] <aatch> sigh... well looks like I should add that to my current work.
[06:32:54] <dbaupp> I think nmatsakis wrote most of that stuff
[06:33:05] <dbaupp> (so you could ask him)
[06:37:27] *** Joins: jviereck (Adium@moz-4DAE78CD.dynamic.eduroam.mwn.de)
[06:37:55] *** Joins: sankha93 (Instantbir@9276287F.8CAC2DA9.D2D1FAF0.IP)
[06:39:13] *** Quits: jviereck (Adium@moz-4DAE78CD.dynamic.eduroam.mwn.de) (Ping timeout)
[06:40:22] *** Joins: jviereck (Adium@moz-4DAE78CD.dynamic.eduroam.mwn.de)
[06:41:36] *** Quits: fabiand_ (fabiand@moz-1751D893.adsl.alicedsl.de) (Quit: Verlassend)
[06:41:51] *** Joins: fabiand (fabiand@moz-1751D893.adsl.alicedsl.de)
[06:41:56] *** Quits: fabiand (fabiand@moz-1751D893.adsl.alicedsl.de) (Quit: fabiand)
[06:42:02] *** Quits: jviereck (Adium@moz-4DAE78CD.dynamic.eduroam.mwn.de) (Ping timeout)
[06:42:29] *** Joins: fabiand (fabiand@moz-1751D893.adsl.alicedsl.de)
[06:42:40] *** Joins: jviereck (Adium@moz-F3534DB6.dynamic.eduroam.mwn.de)
[06:43:44] *** Joins: vk (chatzilla@moz-389FEE13.hsd1.ca.comcast.net)
[06:45:00] <dbaupp> cmr: ping
[06:46:18] *** Joins: pnkfelix (pnkfelix@87C1F78E.1DE10CA8.D8E68FF6.IP)
[06:46:52] <aatch> dbaupp, it appears to only be for the purpose of setting a default in some cases, but has grown a little...  
[06:47:03] <dbaupp> aatch: I see
[06:47:48] *** Quits: james4k (james@moz-E7990244.consolidated.net) (Ping timeout)
[06:48:08] <dbaupp> aatch: has the next snapshot landed yet?
[06:48:12] <aatch> where really, there should just be an Option<~str> for the abi
[06:48:41] <aatch> dbaupp, no, it kept bouncing so I decided to leave it for this week.
[06:49:04] <dbaupp> aatch: yeah... are you gonna make that change?
[06:49:08] <dbaupp> (Oh, ok.)
[06:49:55] <aatch> dbaupp, probably. I'm trying to consolidate all the target stuff right now.
[06:50:01] <vk> Are there instructions somewhere on how to help with prerelease testing on Windows? 
[06:50:02] <aatch> taking cues from Clang/LLVM
[06:50:20] *** Joins: james4k (james@moz-E7990244.consolidated.net)
[06:50:41] <vk> oh. nevermind, just found the --test option from the help. >_>
[06:50:52] <aatch> vk, just install it, try it out on something, then see if the breakage is supposed to have been fixed.
[06:51:05] <aatch> vk, that's for building a test binary for a crate.
[06:51:07] <dbaupp> vk: at the very least, downloading it and seeing if it installs & compiles some things :)
[06:52:01] <yichoi> aatch: I want to make back to your patch like https://gist.github.com/yichoi/5915928
[06:52:25] <aatch> yichoi, ok.
[06:52:31] <yichoi> aatch: even back::link::sanitize can handle '@'
[06:53:10] <yichoi> aatch: rustc emits some assem code starts with '@'
[06:53:20] <aatch> dbaupp, from_str returns an Option<Self> right?
[06:53:29] <dbaupp> aatch: I guess so?
[06:53:33] * dbaupp checks
[06:53:43] <dbaupp> aatch: yes
[06:54:01] <yichoi> aatch: @reflect_3A__3A_MovePtrAdaptor_3C_repr_3A__3A_ReprVisitor_3E__vtable_10842(GOTOFF)
[06:54:20] <vk> dbaupp: aatch: in that case, after the installation, running rustc in cmd.exe resulted in the error found here https://github.com/mozilla/rust/wiki/Note-getting-started-developing-Rust under the 'Troubleshooting Windows environment setups' (powershell threw no errors, it just did nothing); dumping libpthread-2.dll into the install directory seemed to fix it.
[06:54:26] *** Joins: azita (Azita@moz-C1FB2A8.hsd1.ca.comcast.net)
[06:55:01] <aatch> yichoi, no idea then. maybe something else is emitting that symbol?
[06:55:02] *** Quits: cubic_ (cubic@moz-FE5AD6C7.mc.videotron.ca) (Quit: Leaving)
[06:55:22] <dbaupp> vk: I see (I'm not sure whether that counts as "expected breakage" or not)
[06:56:50] <vk> dbaupp: kay'o. Also, https://github.com/mozilla/rust/issues/7499 is happening for me as well.
[06:57:11] <dbaupp> vk: :(
[06:57:18] <vk> yep.
[06:57:37] <yichoi> aatch: ok any other things do i need to check ?
[06:57:57] <dbaupp> vk: maybe you could reply to the mailing list with those two? (and any other things you come across)
[06:58:22] <aatch> yichoi, dunno. The fix you made should have stopped the problem.
[06:59:20] <yichoi> aatch: currently woks ok but I like your approach to add some debug symbol so I want to reflect your previous patch
[06:59:48] <vk> dbaupp: just need the same title for my email to be part of the thread, correct? Haven't really buggered with mailing lists before, and was subscribed to the digest version.
[07:00:07] <aatch> vk, if you reply, it should work
[07:00:11] <dbaupp> vk: yeah, I guess so (I'm not really sure)
[07:00:19] <dbaupp> aatch: even for the digest version?
[07:00:28] <aatch> dbaupp, hmm, maybe not then
[07:01:02] <aatch> yichoi, is it only that patch that causes the problem to come back?
[07:03:13] <yichoi> aatch: yes
[07:04:26] <aatch> yichoi, I'm pretty sure you have to run it through 'sanitize' right there.
[07:05:20] *** Joins: mib_gx01iz (Mibbit@moz-FF25E973.dhcp.aldl.mi.charter.com)
[07:05:24] <yichoi> watch, yes I agree, sanitize can handle '@'
[07:05:50] <yichoi> aatch, yes  I agree however sanitize can handle '@'
[07:06:18] <aatch> yichoi, then I don't know what the issue is.
[07:06:18] *** Quits: mib_gx01iz (Mibbit@moz-FF25E973.dhcp.aldl.mi.charter.com) (Quit: http://www.mibbit.com ajax IRC Client)
[07:07:27] <yichoi> aatch: is it some path does not call sanitize ?
[07:08:07] <aatch> yichoi, possibly. but if you are running it through sanitize before handing the string to LLVM the issue is elsewhere.
[07:09:32] <yichoi> aatch: ok
[07:10:27] *** Quits: azita (Azita@moz-C1FB2A8.hsd1.ca.comcast.net) (Quit: azita)
[07:11:18] *** Quits: jviereck (Adium@moz-F3534DB6.dynamic.eduroam.mwn.de) (Quit: Leaving.)
[07:11:39] <bjz> doomlord: ping
[07:12:31] <yichoi> aatch: anyway thanks for your kind advice
[07:12:36] *** Quits: illissius (illissius@moz-19397A63.catv.broadband.hu) (Quit: )
[07:13:33] *** Quits: yichoi (yichoi@5AB4884B.FCC4549.14D5B978.IP) (Quit: yichoi)
[07:14:09] *** Joins: yichoi (yichoi@5AB4884B.FCC4549.14D5B978.IP)
[07:16:22] *** Quits: tikue (tkuehn@moz-A7CDB794.dia.static.qwest.net) (Quit: tikue)
[07:18:03] *** Joins: jviereck (Adium@moz-F3534DB6.dynamic.eduroam.mwn.de)
[07:18:38] *** Joins: azita (Azita@moz-C1FB2A8.hsd1.ca.comcast.net)
[07:22:20] *** Joins: ghrust (ghrust@CFE85B59.6A2AE50.F3114085.IP)
[07:22:20] <ghrust> 01[13rust01] 15bors merged 06auto into 06master: 02http://git.io/1ZizRg
[07:22:20] *** Parts: ghrust (ghrust@CFE85B59.6A2AE50.F3114085.IP) ()
[07:23:25] <dbaupp> vk: that seemed to work :) https://mail.mozilla.org/pipermail/rust-dev/2013-July/thread.html
[07:23:59] *** Quits: azita (Azita@moz-C1FB2A8.hsd1.ca.comcast.net) (Quit: azita)
[07:24:01] <vk> dbaupp: yep :D
[07:25:10] *** Quits: jviereck (Adium@moz-F3534DB6.dynamic.eduroam.mwn.de) (Quit: Leaving.)
[07:25:18] *** Joins: ghrust (ghrust@5FEF1C87.6A2AE50.F3114085.IP)
[07:25:18] <ghrust> 01[13rust01] 15bors pushed 0 new commits to 06auto: 02http://git.io/Jjeouw
[07:25:18] *** Parts: ghrust (ghrust@5FEF1C87.6A2AE50.F3114085.IP) ()
[07:25:20] *** Joins: ghrust (ghrust@E7A4CCE2.6A2AE50.F3114085.IP)
[07:25:20] <ghrust> 01[13rust01] 15bors pushed 3 new commits to 06auto: 02http://git.io/F3SbFA
[07:25:20] <ghrust> 13rust/06auto 147f69654 15Steven Fackler: Added functionality to Base64 package...
[07:25:20] <ghrust> 13rust/06auto 1453b74d9 15Steven Fackler: Base64 API changes...
[07:25:20] <ghrust> 13rust/06auto 14c2bb065 15bors: auto merge of #7513 : sfackler/rust/master, r=cmr...
[07:25:23] *** Parts: ghrust (ghrust@E7A4CCE2.6A2AE50.F3114085.IP) ()
[07:25:35] *** Joins: Voomer_ (Voomer@moz-E97E8EB7.br.br.cox.net)
[07:25:35] *** Quits: Voomer__ (Voomer@moz-E97E8EB7.br.br.cox.net) (Connection reset by peer)
[07:26:46] * dbaupp sighs
[07:26:54] <dbaupp> the queue is so long again
[07:30:10] <yichoi> no rollback branch today ?
[07:30:16] <yichoi> rollup
[07:30:26] <doener> thinking about dynamic borrows makes my brain hurt
[07:32:19] *** Joins: tikue (tkuehn@moz-A7CDB794.dia.static.qwest.net)
[07:33:09] <aatch> doener, yup
[07:33:47] *** Joins: indirect_ (indirect_m@moz-22FDA25B.hsd1.ca.comcast.net)
[07:33:48] <aatch> imagine my torment when I made CrateContext be passed as @mut everywhere, but changed it to &(mut) where I could
[07:34:01] *** Quits: indirect (indirect_m@moz-22FDA25B.hsd1.ca.comcast.net) (Ping timeout)
[07:34:01] *** indirect_ is now known as indirect
[07:34:11] *** Joins: geomyidae (geomyidae@DD6F7E3A.21468E9A.30200F38.IP)
[07:34:15] <geomyidae> http://static.rust-lang.org/doc/tutorial-borrowed-ptr.html#named-lifetimes
[07:34:19] <geomyidae> I'm still so lost ^
[07:34:48] <geomyidae> oh wait, I just realized what I was misunderstanding, or part of it, :D
[07:34:54] <doener> aatch: worst thing currently is that I have to look at which stage I get the "borrowed" message. Stage 1 => real failure, stage 2 => I just messed up the cleanup handling
[07:35:03] <aatch> doener, ugh
[07:35:41] <aatch> I pick option C
[07:35:48] <aatch> Beer
[07:37:30] <geomyidae> "The caller will infer the intersection of these two lifetimes as the lifetime of the returned value,"
[07:37:37] <geomyidae> can someone restatte that line or clarify it?
[07:39:37] *** Joins: Blub\w (wry@7E3BB9D.71150E1A.237AE2BA.IP)
[07:41:49] <dbaupp> geomyidae: if you're passing two parameters that have the same named lifetime, e.g. fn foo<'a>(x: &'a int, y: &'a int), then Rust needs to make sure that both parameters are valid for that lifetime
[07:42:33] <dbaupp> geomyidae: that is, in `foo(some_ptr, another_ptr)`, the lifetime 'a has to be restricted to a period when both some_ptr and another_ptr is valid
[07:42:49] <dbaupp> geomyidae: and the largest such period is the intersection of their lifetimes
[07:43:03] *** Joins: pyrac (pyrac@moz-18D74BD0.w90-60.abo.wanadoo.fr)
[07:43:19] *** Quits: bjz (brendanzab@B398BE78.F804C29E.D35A31DF.IP) (Client exited)
[07:44:08] *** Joins: bjz (brendanzab@B398BE78.F804C29E.D35A31DF.IP)
[07:44:22] <doener> thing is, 'a isn't the lifetime _of_ x and y, but just _some_ lifetime during which both x and y are valid
[07:44:33] <geomyidae> dbaupp: and the problem is disjoint lifetimes among things named to be the same?
[07:45:12] *** Joins: echristo (echristo@moz-1892C634.hsd1.ca.comcast.net)
[07:45:17] <geomyidae> Hm, I'm going to read what dbaupp wrote 3 more times and then the example 3 more times.
[07:45:34] *** Quits: vk (chatzilla@moz-389FEE13.hsd1.ca.comcast.net) (Quit: ChatZilla 0.9.90 [Firefox 23.0/20130625125232])
[07:45:53] <dbaupp> geomyidae: yes, if you have disjoint lifetimes, and try to call `foo` then that will be an error
[07:46:24] <geomyidae> okay, I think I grok that sentence now
[07:46:49] <geomyidae> wait, no
[07:46:57] *** Joins: ghrust (ghrust@CFE85B59.6A2AE50.F3114085.IP)
[07:46:57] <ghrust> 01[13rust01] 15alexcrichton 04force-pushed 06try from 145d9ddb0 to 14873af13: 02http://git.io/k471pw
[07:46:57] <ghrust> 13rust/06try 149da0b5a 15Brian Anderson: Try to fix a periodic windows build failure due to broken rwildcard macro
[07:46:57] <ghrust> 13rust/06try 1434d8e67 15Alex Crichton: Update LLVM
[07:46:57] <ghrust> 13rust/06try 148a7b169 15Alex Crichton: Fix build issues once LLVM has been upgraded...
[07:46:57] *** Parts: ghrust (ghrust@CFE85B59.6A2AE50.F3114085.IP) ()
[07:47:03] *** Quits: echristo (echristo@moz-1892C634.hsd1.ca.comcast.net) (Ping timeout)
[07:47:05] <geomyidae> okay, that sentence is talking about 'r and B
[07:47:14] <geomyidae> and the intersection of them being the return value
[07:47:33] <geomyidae> I don't see where that comes from, why is it the intersectio of 'r and B in that example (sorry to spam)
[07:48:44] <geomyidae> nope, just got it.
[07:49:13] <geomyidae> hm, it would be cool to animate between the first code snip and the third
[07:49:39] <geomyidae> with a short clip of audio, I think I could explain it super fast/succinctly now. anyway, thanks for letting me spam, I'll shuddup now
[07:50:08] <bblum> alright, i've got it
[07:50:31] <bblum> instead of "once", i think people might like it better if the keyword was "yolo"
[07:50:34] *** Joins: echristo (echristo@60A74940.D6CCE4AE.77834EAA.IP)
[07:50:50] <bblum> fn spawn(f: ~yolo fn:Send())
[07:50:52] <doener> o.O
[07:51:22] <dbaupp> bblum: ship it!
[07:51:51] <rpearl> bblum: i have inspired you!
[07:51:58] <bblum> rpearl: >_>
[07:51:59] <geomyidae> bblum: conversely, "yolo" might be more appropriate in place of (certainly at least non-local) "goto".
[07:55:52] *** Joins: jpochyla (jpochyla@moz-8D99AE5D.broadband18.iol.cz)
[07:57:42] <echristo> heh
[07:58:46] <mcpherrin> hmm, I think I will call singletons YOLOs from now on.
[07:59:30] *** Joins: victorporof (victorporo@74A9C5E8.1745F5FA.9B1E38F4.IP)
[08:01:01] *** Joins: pnathan (Adium@moz-E3C3FAF2.hfc.comcastbusiness.net)
[08:01:07] *** Joins: true_droid (Adium@moz-123FD9B8.beck.volia.net)
[08:01:53] <Seldaek> I'm not sure what to make of http://buildbot.rust-lang.org/builders/auto-linux-32-nopt/builds/230/steps/test/logs/stdio - it failed my PR https://github.com/mozilla/rust/pull/7474
[08:02:05] <Seldaek> but I don't quite get what failed, nor what it has to do with my PR
[08:02:45] *** Quits: pnathan (Adium@moz-E3C3FAF2.hfc.comcastbusiness.net) (Ping timeout)
[08:03:29] <aatch> Seldaek, nothing, looks like it was interrupted
[08:04:01] <Seldaek> ok so what next will it retry later or do I have to do anything? :)
[08:04:33] <aatch> Seldaek, it'll need a retry. you got an (unrelated) failure on the mac builder
[08:04:50] <aatch> from a rustpkg test, I think.
[08:05:28] <aatch> Seldaek, I just told bors to retry
[08:06:33] <Seldaek> thanks
[08:09:30] <dbaupp> oh yeah, Rust is 10x slower than Python to read a 4MB json file
[08:10:10] *** Joins: sdh_ (sdh@8557E3E0.AAC4A127.9105FBCF.IP)
[08:10:19] <aatch> dbaupp, oh wow...
[08:10:19] *** Joins: ghrust (ghrust@24260B07.6A2AE50.F3114085.IP)
[08:10:19] <ghrust> 01[13rust01] 15bors 04force-pushed 06auto from 14c2bb065 to 14025dc6e: 02http://git.io/N3iJvQ
[08:10:19] *** Parts: ghrust (ghrust@24260B07.6A2AE50.F3114085.IP) ()
[08:10:22] *** Joins: ghrust (ghrust@C8693FCB.6A2AE50.F3114085.IP)
[08:10:22] <ghrust> 01[13rust01] 15bors pushed 3 new commits to 06auto: 02http://git.io/86cBoA
[08:10:22] <ghrust> 13rust/06auto 140fc99f1 15Jordi Boggiano: Add an EnumSetIterator and EnumSet::iter
[08:10:22] <ghrust> 13rust/06auto 143fe05a9 15Jordi Boggiano: Move most iter functionality to extra, fixes #7343
[08:10:22] <ghrust> 13rust/06auto 14ea31b9c 15bors: auto merge of #7474 : Seldaek/rust/clean-iter, r=thestinger...
[08:10:24] *** Parts: ghrust (ghrust@C8693FCB.6A2AE50.F3114085.IP) ()
[08:11:17] <dbaupp> aatch: http://ix.io/6tV
[08:12:29] <Seldaek> bors is quite chatty
[08:13:16] <aatch> dbaupp, is that time mostly allocating and freeing!
[08:13:18] <Seldaek> couldn't it group the 3 initial messages in one? I guess it's needed because it's posting on commits etc?
[08:13:32] <dbaupp> aatch: of course!
[08:13:38] <aatch> dbaupp, ugh.
[08:13:44] <dbaupp> Seldaek: it's github's IRC hook
[08:13:45] <aatch> it that /just/ reading?
[08:13:57] <dbaupp> Seldaek: (or are you talking about the comments on PRs?)
[08:13:59] *** Joins: novabyte (Instantbir@91FFDEC6.3F2319E2.EFEA2F8E.IP)
[08:14:00] <Seldaek> dbaupp: nah I meant more the comments on github that spams me by email :)
[08:14:12] <Seldaek> I don't mind the irc noise so much
[08:14:14] *** Joins: Blei (philipp@moz-4E4B9A0A.ethz.ch)
[08:14:17] <dbaupp> aatch: yeah
[08:14:32] <dbaupp> aatch: `let json = do io::file_reader(&mem_path).map |rdr| { json::from_reader(*rdr).unwrap() }.unwrap();`
[08:14:48] <aatch> Oh, so it does the parsing too.
[08:15:18] *** Joins: z0w0 (zack@moz-C7366B37.lns11.cha.bigpond.net.au)
[08:16:18] <dbaupp> oh, right, yeah
[08:16:33] *** Joins: novabyte1 (Instantbir@91FFDEC6.3F2319E2.EFEA2F8E.IP)
[08:16:33] *** Quits: novabyte (Instantbir@91FFDEC6.3F2319E2.EFEA2F8E.IP) (Connection reset by peer)
[08:16:34] <aatch> Ok, I don't trust anything in libextra
[08:16:54] <aatch> Well, maybe rc and arc
[08:16:55] <dbaupp> "libextra" = "extra allocations"
[08:16:59] *** Quits: Jesin (Jessin_@moz-1B1307FF.eecs.lehigh.edu) (Quit: Leaving)
[08:17:01] <doener> heh
[08:17:10] <dbaupp> (and the new sha1/sha2 stuff is pretty good)
[08:17:27] <dbaupp> (from a code standpoint, not 100% sure if they're actually correct.)
[08:17:54] <aatch> sigh, testing my target triple handler, forgot that x86 is not, itself, a valid architecture.
[08:18:13] <aatch> it's i[3-9]86
[08:18:21] *** Quits: novabyte1 (Instantbir@91FFDEC6.3F2319E2.EFEA2F8E.IP) (Ping timeout)
[08:18:44] <dbaupp> however, it's really nice to be able to define a struct that mirrors the json structure, and just call `Decodable::decode(&mut json);`, and get the struct automagically
[08:19:09] *** Joins: novabyte (Instantbir@91FFDEC6.3F2319E2.EFEA2F8E.IP)
[08:23:10] *** Quits: novabyte (Instantbir@91FFDEC6.3F2319E2.EFEA2F8E.IP) (Ping timeout)
[08:27:47] *** Joins: novabyte (Instantbir@91FFDEC6.3F2319E2.EFEA2F8E.IP)
[08:29:39] *** Quits: novabyte (Instantbir@91FFDEC6.3F2319E2.EFEA2F8E.IP) (Ping timeout)
[08:30:35] *** Joins: CarpNet (ac@moz-FD24B77.sohonet.co.uk)
[08:31:08] *** Joins: pnathan (Adium@moz-E3C3FAF2.hfc.comcastbusiness.net)
[08:34:26] *** Joins: webber46 (webber46@moz-98D2F3C5.cust.bredband2.com)
[08:37:18] *** Quits: pnathan (Adium@moz-E3C3FAF2.hfc.comcastbusiness.net) (Ping timeout)
[08:39:27] *** Joins: lucian (lucian@6B2B4644.4304AE1E.CE5E78F6.IP)
[08:40:48] *** Joins: lucian_ (lucian@6B2B4644.4304AE1E.CE5E78F6.IP)
[08:40:48] <doener> awesome, I think the error message I just got had the whole ast for libstd in it
[08:41:07] *** Quits: lucian (lucian@6B2B4644.4304AE1E.CE5E78F6.IP) (Connection reset by peer)
[08:41:15] <dbaupp> doener: that's pretty good
[08:41:28] <doener> is it?
[08:41:49] <dbaupp> surely it was very informative. (It contains all the information! :P )
[08:42:24] <doener> too bad that the actual problem is in librustc
[08:43:36] <dbaupp> ah, right :(
[08:45:03] *** Quits: pyrac (pyrac@moz-18D74BD0.w90-60.abo.wanadoo.fr) (Quit: pyrac)
[08:47:51] <doomlord> how much of the concurency is intrinsic to the lanuage vs library code... 
[08:48:20] *** Joins: pyrac (pyrac@moz-18D74BD0.w90-60.abo.wanadoo.fr)
[08:48:21] <doomlord> ... i'm guessing the per-task heaps is the biggest thing,  but what about the message passing syntax
[08:51:43] *** Quits: tikue (tkuehn@moz-A7CDB794.dia.static.qwest.net) (Quit: tikue)
[08:55:10] <aatch> doomlord, the per-task heap and related semantics are the only think inherent to the language
[08:55:23] <aatch> there is, as far as I know, no message passing syntax.
[08:57:43] *** Quits: sankha93 (Instantbir@9276287F.8CAC2DA9.D2D1FAF0.IP) (Client exited)
[09:03:56] <aatch> Wow, clang can target the PSP
[09:04:26] <echristo> sorta. not well tested really.
[09:04:27] *** Joins: SimonSapin (simon@88F51059.F3BBB17D.144F44FA.IP)
[09:04:28] *** Joins: davbo (dave@moz-3FFA637C.oucs.ox.ac.uk)
[09:05:36] <aatch> echristo, it can still target it, it just might not work :P
[09:05:41] <echristo> right
[09:06:53] <aatch> echristo, nah, I'm currently looking through the clang source to crib off of their target-handling stuff.
[09:06:56] *** Quits: jpochyla (jpochyla@moz-8D99AE5D.broadband18.iol.cz) (Ping timeout)
[09:07:09] <echristo> aha
[09:07:47] *** Quits: ski (md9slj@moz-4BB5E0FF.studat.chalmers.se) (Ping timeout)
[09:08:41] <aatch> since rustc's stuff sucks
[09:10:56] *** Joins: q66 (q66@6EE9DE40.46454B5D.33AABD5F.IP)
[09:11:58] *** Joins: penna (angelo@moz-918A5E12.superkabel.de)
[09:12:51] *** Parts: penna (angelo@moz-918A5E12.superkabel.de) ()
[09:20:28] <doener> https://github.com/mozilla/rust/pull/7513 -- should be retried, the test failure should be unrelated is just "happens sometimes"
[09:23:36] *** Quits: bjz (brendanzab@B398BE78.F804C29E.D35A31DF.IP) (Ping timeout)
[09:30:27] *** Joins: bjz (brendanzab@B398BE78.F804C29E.D35A31DF.IP)
[09:31:17] *** Joins: Ms2ger (Ms2ger@moz-12E1F766.adsl-dyn.isp.belgacom.be)
[09:33:33] <nmatsakis> aatch: probably you are right that it'd be better to resolve ABIs in typeck rather than libsyntax.
[09:34:05] <nmatsakis> aatch: though I'd say that the legal ABI names are actually part of the grammar, it's not that we accept arbitrary string constants there.
[09:34:26] <aatch> nmatsakis, is there any reason for that?
[09:34:38] <nmatsakis> aatch: for what?
[09:35:06] <nmatsakis> aatch: for not accepting arbitrary string constants?
[09:35:13] <nmatsakis> aatch: or for doing the ABI processing in libsyntax?
[09:35:37] <aatch> I mean, sure, semantically any old abi doesn't make sense, but if I want to write extern "foo" fn func(), I think it should be syntatically correct.
[09:35:41] <nmatsakis> aatch: the latter is just because I wanted to include AbiSet's in the AST rather than a string 
[09:36:42] <aatch> nmatsakis, not accepting arbitrary string constants. (btw)
[09:36:53] *** Joins: jpochyla (jpochyla@E1DB45DB.1AFA5C43.5DC06702.IP)
[09:37:10] <nmatsakis> I don't really have a strong opinion about where the error is reported for an illegal ABI.
[09:37:59] <nmatsakis> but I do tend to agree libsyntax shouldn't have knowledge of ABIs
[09:38:07] <nmatsakis> so it seems better to move that AbiSet module into librustc,
[09:38:18] <nmatsakis> and then have typeck/astconv do the parsing itself.
[09:38:25] <nmatsakis> (the parsing of the ABI string)
[09:38:47] <nmatsakis> sigh, I cannot reproduce these valgrind errors that bors seemed to find on my branch 
[09:38:54] <aatch> It should make it easier to extend later too.
[09:39:06] <aatch> (if we happen to want to)
[09:39:16] *** Joins: ghrust (ghrust@614D05BD.6A2AE50.F3114085.IP)
[09:39:16] <ghrust> 01[13rust01] 15nikomatsakis 04force-pushed 06try from 14873af13 to 14a14a330: 02http://git.io/k471pw
[09:39:16] <ghrust> 13rust/06try 1476858cd 15Niko Matsakis: Update existing tests to account for stricter, more correct handling of irrefutable patterns
[09:39:16] <ghrust> 13rust/06try 14ce138ed 15Niko Matsakis: Add new tests for irrefutable patterns used in various tricky ways
[09:39:16] <ghrust> 13rust/06try 14f3a7f44 15Niko Matsakis: update ptr intrinsics and rewrite vec routines to be more correct....
[09:39:17] *** Parts: ghrust (ghrust@614D05BD.6A2AE50.F3114085.IP) ()
[09:39:28] <nmatsakis> I don't know why it would make any difference with regard to extensibility
[09:40:48] *** Quits: paupau (NEAT@moz-C616DA0A.hsd1.ca.comcast.net) (Quit: out)
[09:40:49] *** Quits: jaen (jaen@moz-E0979827.copit.pl) (Connection reset by peer)
[09:40:58] *** Joins: jaen (jaen@moz-E0979827.copit.pl)
[09:41:09] <aatch> nmatsakis, hmm, I guess not. Maybe 'maintainability' is a better word.
[09:41:40] *** Joins: reyre_ (reyre@moz-9002CDDA.cpe.net.cable.rogers.com)
[09:41:46] <nmatsakis> yes, I agree there. keep concerns as local as possible.
[09:42:29] *** Quits: pyrac (pyrac@moz-18D74BD0.w90-60.abo.wanadoo.fr) (Quit: pyrac)
[09:43:32] *** Quits: reyre_ (reyre@moz-9002CDDA.cpe.net.cable.rogers.com) (Ping timeout)
[09:45:05] *** Quits: sdh_ (sdh@8557E3E0.AAC4A127.9105FBCF.IP) (Ping timeout)
[09:48:25] *** Quits: Blei (philipp@moz-4E4B9A0A.ethz.ch) (Quit: WeeChat 0.4.1)
[09:49:19] *** Joins: ghrust (ghrust@2EE61FCC.6A2AE50.F3114085.IP)
[09:49:19] <ghrust> 01[13rust01] 15bors merged 06auto into 06master: 02http://git.io/86cBoA
[09:49:19] *** Parts: ghrust (ghrust@2EE61FCC.6A2AE50.F3114085.IP) ()
[09:50:47] *** Joins: sdh_ (sdh@8557E3E0.AAC4A127.9105FBCF.IP)
[09:52:13] *** Joins: Blei (philipp@moz-4E4B9A0A.ethz.ch)
[09:52:16] *** Joins: ghrust (ghrust@E7A4CCE2.6A2AE50.F3114085.IP)
[09:52:16] <ghrust> 01[13rust01] 15bors pushed 0 new commits to 06auto: 02http://git.io/Yy7cSw
[09:52:16] *** Parts: ghrust (ghrust@E7A4CCE2.6A2AE50.F3114085.IP) ()
[09:52:18] *** Joins: ghrust (ghrust@DE823A67.6A2AE50.F3114085.IP)
[09:52:18] <ghrust> 01[13rust01] 15bors pushed 2 new commits to 06auto: 02http://git.io/UdcwZg
[09:52:18] <ghrust> 13rust/06auto 14652dc73 15Graydon Hoare: extra: docs, tests and new functionality for the extra::stats module
[09:52:18] <ghrust> 13rust/06auto 146caaa34 15bors: auto merge of #7518 : graydon/rust/stats-improvements, r=catamorphism
[09:52:18] *** Parts: ghrust (ghrust@DE823A67.6A2AE50.F3114085.IP) ()
[09:52:34] *** Joins: pyrac (pyrac@moz-18D74BD0.w90-60.abo.wanadoo.fr)
[09:53:16] <doener> hrm, that test again :-/
[09:55:21] *** Quits: snadon (chatzilla@moz-3BC727E8.mc.videotron.ca) (Ping timeout)
[09:55:40] *** Quits: hjr3 (hradtke@moz-E87BDF1F.socal.res.rr.com) (Quit: My MacBook has gone to sleep. ZZZzzzâ€¦)
[10:01:49] *** Quits: pnkfelix (pnkfelix@87C1F78E.1DE10CA8.D8E68FF6.IP) (Quit: Leaving.)
[10:02:33] *** Joins: pnkfelix (pnkfelix@87C1F78E.1DE10CA8.D8E68FF6.IP)
[10:04:28] <doomlord> module imports dont seem as straightforward as they could be
[10:04:46] *** Joins: ross (ross@moz-8A84103E.br.br.cox.net)
[10:05:10] <doener> I wonder if that fails because concurrent test run left that port in TIME_WAIT state
[10:08:19] *** Quits: robertknight (robertknig@moz-54528EE0.wby.mendeley.com) (Quit: Computer has gone to sleep.)
[10:08:34] *** Quits: jpochyla (jpochyla@E1DB45DB.1AFA5C43.5DC06702.IP) (Ping timeout)
[10:11:43] *** Joins: sankha93 (Instantbir@9276287F.8CAC2DA9.D2D1FAF0.IP)
[10:12:03] *** Joins: donri (dag@moz-9BB61102.tbcn.telia.com)
[10:17:24] *** Quits: CarpNet (ac@moz-FD24B77.sohonet.co.uk) (Ping timeout)
[10:17:34] <doomlord> a source file is implicitely a module?
[10:18:28] <doomlord> i've moved some code/functions into a module.. marked everything up with pub...  in my main i have "use ...::*" and "mod ..." ... it can see the types in main, but gives me this error when trying to call any methods:-
[10:18:49] <doomlord> "error: internal compiler error: method notfound in AST map?!"
[10:18:58] <doomlord> the code worked when it was all one sourcefile ;
[10:19:10] <doomlord> have i confused it by setting up the modules incorrectly?
[10:19:40] *** Joins: pnathan (Adium@moz-E3C3FAF2.hfc.comcastbusiness.net)
[10:21:34] *** Quits: busylizzy (lisa@85228838.12D0DC84.211374C4.IP) (Ping timeout)
[10:21:44] *** Quits: sdh_ (sdh@8557E3E0.AAC4A127.9105FBCF.IP) (Ping timeout)
[10:24:14] <aatch> doomlord, you using default methods?
[10:24:31] <doomlord> ahhh. yes . experiemental.
[10:24:47] <doomlord> these are indeed default methods
[10:24:55] <doomlord> (that it is failing on)
[10:24:56] <aatch> doomlord, it's just that theres an issue about privacy relating to that message
[10:25:04] *** Quits: true_droid (Adium@moz-123FD9B8.beck.volia.net) (Quit: Leaving.)
[10:25:14] <aatch> try adding `pub` to things until it works :P
[10:25:21] *** aatch is now known as aatch|gone
[10:25:26] *** Joins: true_droid (Adium@moz-123FD9B8.beck.volia.net)
[10:25:27] <doomlord> i've put pub everywhere i can think of
[10:25:35] <doomlord> the trait & individual methods all have pub
[10:25:54] *** Quits: pnathan (Adium@moz-E3C3FAF2.hfc.comcastbusiness.net) (Ping timeout)
[10:27:32] <doomlord> it does work for non-default methods
[10:27:32] *** Quits: quvarxa (chatzilla@moz-978E4C31.static.tpgi.com.au) (Quit: ChatZilla 0.9.90 [Firefox 23.0/20130625125232])
[10:28:08] *** Quits: Blei (philipp@moz-4E4B9A0A.ethz.ch) (Quit: WeeChat 0.4.1)
[10:28:08] <doomlord> ... so its either a teething problem with default methods or somethign i'm unaware of.. extra visibility specifier or something
[10:33:38] *** Joins: CarpNet (ac@moz-FD24B77.sohonet.co.uk)
[10:34:09] *** kimundi is now known as zz_kimundi
[10:35:13] <doener> https://gist.github.com/dotdash/5916924 -- why?
[10:35:43] *** Joins: busylizzy (lisa@85228838.12D0DC84.211374C4.IP)
[10:37:01] *** Joins: jpochyla (jpochyla@E1DB45DB.1AFA5C43.5DC06702.IP)
[10:40:14] *** Quits: CarpNet (ac@moz-FD24B77.sohonet.co.uk) (Ping timeout)
[10:40:33] <doomlord> so its possible that default methods dont go across module boundaries?
[10:41:14] <doener> doomlord: https://github.com/mozilla/rust/issues/7339
[10:41:58] <doener> doomlord: oops, I meant to link the linked one... https://github.com/mozilla/rust/issues/7481
[10:42:38] *** Quits: pyrac (pyrac@moz-18D74BD0.w90-60.abo.wanadoo.fr) (Quit: pyrac)
[10:43:02] *** Quits: jpochyla (jpochyla@E1DB45DB.1AFA5C43.5DC06702.IP) (Ping timeout)
[10:43:18] <doomlord> the first one seems to be what i'm getting; i've marked more with pub than they did; i'm not using multiple crates.  well for the time being i can go back to one big sourcefile :)
[10:48:47] *** Quits: jaen (jaen@moz-E0979827.copit.pl) (Ping timeout)
[10:49:32] *** Joins: sdh_ (sdh@8557E3E0.AAC4A127.9105FBCF.IP)
[10:49:52] *** Joins: wilsonk-laptop (kvirc@moz-39EFBFC2.cg.shawcable.net)
[10:50:27] *** Quits: wilsonk|2 (kvirc@moz-39EFBFC2.cg.shawcable.net) (Ping timeout)
[10:55:13] *** Joins: pyrac (pyrac@moz-18D74BD0.w90-60.abo.wanadoo.fr)
[10:55:26] *** Quits: james4k (james@moz-E7990244.consolidated.net) (Ping timeout)
[10:56:28] *** Quits: sdh_ (sdh@8557E3E0.AAC4A127.9105FBCF.IP) (Ping timeout)
[10:56:38] *** Joins: CarpNet (ac@moz-FD24B77.sohonet.co.uk)
[11:00:20] *** Joins: robertknight (robertknig@moz-54528EE0.wby.mendeley.com)
[11:08:51] *** Quits: pyrac (pyrac@moz-18D74BD0.w90-60.abo.wanadoo.fr) (Quit: pyrac)
[11:12:12] *** Joins: MaikKlein (maik@moz-7F4AE15A.dip0.t-ipconnect.de)
[11:13:02] *** Joins: jpochyla (jpochyla@E1DB45DB.1AFA5C43.5DC06702.IP)
[11:18:19] *** Joins: Blei (philipp@moz-4E4B9A0A.ethz.ch)
[11:19:21] *** Parts: z0w0 (zack@moz-C7366B37.lns11.cha.bigpond.net.au) ()
[11:20:38] *** Joins: z0w0 (zack@moz-C7366B37.lns11.cha.bigpond.net.au)
[11:22:01] *** Joins: dsirenko (mitra@8E712A0.54C21BA0.9F317420.IP)
[11:23:22] *** Joins: jensnockert (jensnocker@moz-C5F27039.cust.bredband2.com)
[11:30:10] *** Quits: pnkfelix (pnkfelix@87C1F78E.1DE10CA8.D8E68FF6.IP) (Quit: Leaving.)
[11:31:15] *** Joins: ghrust (ghrust@AC22872E.6A2AE50.F3114085.IP)
[11:31:15] <ghrust> 01[13rust01] 15bors merged 06auto into 06master: 02http://git.io/UdcwZg
[11:31:15] *** Parts: ghrust (ghrust@AC22872E.6A2AE50.F3114085.IP) ()
[11:32:15] *** Joins: pnkfelix (pnkfelix@87C1F78E.1DE10CA8.D8E68FF6.IP)
[11:33:10] *** Joins: Earnestly (earnest@2A2BF8F5.321FA5E6.BFD1ABFD.IP)
[11:34:14] *** Joins: ghrust (ghrust@DE823A67.6A2AE50.F3114085.IP)
[11:34:15] <ghrust> 01[13rust01] 15bors pushed 0 new commits to 06auto: 02http://git.io/Q9SDVg
[11:34:15] *** Parts: ghrust (ghrust@DE823A67.6A2AE50.F3114085.IP) ()
[11:34:18] *** Joins: ghrust (ghrust@9C8B94D4.6A2AE50.F3114085.IP)
[11:34:18] <ghrust> 01[13rust01] 15bors pushed 3 new commits to 06auto: 02http://git.io/Xhio_Q
[11:34:18] <ghrust> 13rust/06auto 14da43845 15Huon Wilson: lint: make the non_camel_case_types lint work with scripts without a upper/lowercase distinction.
[11:34:18] <ghrust> 13rust/06auto 14c437a16 15Huon Wilson: rustc: add a lint to enforce uppercase statics.
[11:34:18] <ghrust> 13rust/06auto 1455f1555 15bors: auto merge of #7523 : huonw/rust/uppercase-statics-lint, r=cmr...
[11:34:19] *** Parts: ghrust (ghrust@9C8B94D4.6A2AE50.F3114085.IP) ()
[11:35:40] *** Quits: Earnestly (earnest@2A2BF8F5.321FA5E6.BFD1ABFD.IP) (Connection reset by peer)
[11:36:19] *** Joins: Earnestly (earnest@2A2BF8F5.321FA5E6.BFD1ABFD.IP)
[11:36:47] *** Joins: jdm (jdm@92FB48CA.8B5E9DF.9A8C35B4.IP)
[11:40:36] *** Joins: judder (maradukewa@5B9E91E7.2C8A8E2E.78E362FE.IP)
[11:42:20] *** Quits: jpochyla (jpochyla@E1DB45DB.1AFA5C43.5DC06702.IP) (Ping timeout)
[11:46:20] *** Joins: msingle (Thunderbir@moz-930E5D97.hr.hr.cox.net)
[11:46:55] *** Quits: jensnockert (jensnocker@moz-C5F27039.cust.bredband2.com) (Input/output error)
[11:50:09] *** Joins: rsaarelm (rsaarelm@moz-D1CB7158.dhcp.inet.fi)
[11:56:37] *** Quits: rsaarelm (rsaarelm@moz-D1CB7158.dhcp.inet.fi) (Quit: leaving)
[11:57:24] *** Joins: jensnockert (jensnocker@moz-C5F27039.cust.bredband2.com)
[12:00:18] *** Joins: pyrac (pyrac@moz-C9A2635A.infra.univ-bordeaux.fr)
[12:08:15] *** Joins: pnathan (Adium@moz-E3C3FAF2.hfc.comcastbusiness.net)
[12:08:20] *** Joins: SiegeLord (sl@moz-CAF07B4C.hsd1.ma.comcast.net)
[12:11:11] *** zz_kimundi is now known as kimundi
[12:14:27] *** Quits: pnathan (Adium@moz-E3C3FAF2.hfc.comcastbusiness.net) (Ping timeout)
[12:14:32] *** Joins: jensnock_ (jensnocker@moz-8BE55278.customer.t3.se)
[12:15:06] *** Quits: jensnockert (jensnocker@moz-C5F27039.cust.bredband2.com) (Ping timeout)
[12:15:42] *** Joins: maxli (maxli@F2D29657.F60B0462.67AC9B1.IP)
[12:20:10] <bstrie> what's the git hash of the release candidate?
[12:24:42] *** Joins: jpochyla (jpochyla@E1DB45DB.1AFA5C43.5DC06702.IP)
[12:24:50] *** Joins: Kruppe (user@moz-E150F49F.cpe.net.cable.rogers.com)
[12:25:40] <dbaupp> bstrie: the dist-snap branch is a2db7c15ce9f586164cabb15d83fb3f6bbeb3cf5, no idea if that's actually the RC though
[12:27:00] <MaikKlein> when would I use once functions?
[12:27:13] <dbaupp> MaikKlein: Option.map
[12:27:19] <dbaupp> (is one example)
[12:27:24] <dbaupp> task::spawn, maybe
[12:27:41] <engla> MaikKlein: once functions can take full ownership of owned values, and pass them on
[12:29:51] <SiegeLord> Let's say I have a resource manager and I want to use its resources (that I get via a method) to be usable in different tasks... what type of pointer would I use to store the resources?
[12:30:08] <bstrie> owned
[12:30:12] *** Quits: roo (jesse.rudo@moz-FB1A29EA.dynamic.ip.windstream.net) (Ping timeout)
[12:30:40] <MaikKlein> hm I think I understood sth wrong. I thought once functions can only be called once in a program.
[12:30:51] <bstrie> they can
[12:30:56] <bstrie> that's the idea :)
[12:31:15] *** Joins: nielsle (nielsle@moz-5CE8ECCD.boa.fiberby.dk)
[12:31:20] <MaikKlein> ok but Option.map "Maps a some value from one type to another by reference" why is a once function useful for this?
[12:31:26] <SiegeLord> I'm not sure how it can be owned... won't I have to transfer the ownership to the task?
[12:31:35] *** Quits: nielsle (nielsle@moz-5CE8ECCD.boa.fiberby.dk) (Quit: Ex-Chat)
[12:31:53] <engla> rusti: let v = ~[0]; do spawn { let mut u = v; u.push(4); } 
[12:31:53] -rusti- <anon>:9:46: 9:47 error: cannot move out of captured outer variable in a heap closure
[12:31:53] -rusti- <anon>:9          let v = ~[0]; do spawn { let mut u = v; u.push(4); } 
[12:31:53] -rusti-                                                        ^
[12:31:54] -rusti- error: aborting due to previous error
[12:31:54] -rusti- application terminated with error code 101
[12:32:02] <dbaupp> SiegeLord: you probably want ARC (or something else in extra::arc)
[12:32:13] <bstrie> SiegeLord: you can also try using ARC if you want to be able to access it from multiple tasks at once
[12:32:15] <engla> MaikKlein: ^  the function to spawn is not once, so you can't modify the v / u variable as you wish
[12:32:29] <dbaupp> MaikKlein: because it only gets called (at most) once, since there is only one value in the optoin
[12:32:32] <dbaupp> *option
[12:33:16] *** Quits: msingle (Thunderbir@moz-930E5D97.hr.hr.cox.net) (Quit: msingle)
[12:33:30] *** Joins: msingle (Thunderbir@moz-930E5D97.hr.hr.cox.net)
[12:33:34] <MaikKlein> ahhhhh ok 
[12:34:54] <MaikKlein> that makes sense
[12:35:14] <MaikKlein> I thought that once I call .map it would be visible anymore
[12:35:33] <MaikKlein> wouldn't*
[12:38:53] *** Quits: jpochyla (jpochyla@E1DB45DB.1AFA5C43.5DC06702.IP) (Ping timeout)
[12:40:06] *** Joins: nielsle (nielsle@moz-5CE8ECCD.boa.fiberby.dk)
[12:41:17] <indutny> cmr: hi!
[12:41:19] <indutny> how are you?
[12:41:22] <indutny> mind r? https://github.com/mozilla/rust/pull/7528
[12:47:29] *** Joins: sw17ch (sw17ch@moz-39D8564F.wndsny.tds.net)
[12:55:05] *** Quits: jack (jack@moz-F1B36F9F.hsd1.nm.comcast.net) (Quit: Leaving.)
[12:55:12] *** Joins: jack (jack@moz-F1B36F9F.hsd1.nm.comcast.net)
[12:55:14] *** Joins: bytbox (s@moz-D4F26CEB.hsd1.md.comcast.net)
[12:56:19] <SimonSapin> Can I use vec::map with a "classic" function?
[12:56:33] <SimonSapin> or do I need to make a closure that just calls it?
[12:56:51] *** Quits: msingle (Thunderbir@moz-930E5D97.hr.hr.cox.net) (Quit: msingle)
[12:57:02] *** Joins: msingle (Thunderbir@moz-930E5D97.hr.hr.cox.net)
[12:58:03] *** Quits: bytbox (s@moz-D4F26CEB.hsd1.md.comcast.net) (Ping timeout)
[12:59:19] <bstrie> SimonSapin: I think you can call it with a normal function, yes
[12:59:42] <bstrie> any function that takes &fn as a parameter (presumbably map does this) can take either a closure or a normal function
[13:00:38] <SimonSapin> bstrie: just using it naively gives me "mismatched types [â€¦] (expected fn but found &-ptr)", I was wondering if I was missing some trick
[13:00:45] <SimonSapin> btw the error message seems backwards
[13:00:56] <bstrie> right
[13:01:01] <bstrie> it does seem backwards
[13:01:08] <SimonSapin> error: mismatched types: expected `&fn(&extra::json::Json) -> <V58>` but found `&extern "Rust" fn(extra::json::Json) -> ast::ComponentValue` (expected fn but found &-ptr)
[13:01:11] <SimonSapin> in full
[13:01:23] <Blei> your problem is probably the argument
[13:01:27] <Blei> &Json vs Json
[13:01:33] <bstrie> haha, good catch
[13:01:47] <Blei> bad error message, bad! *shakes fist*
[13:01:52] <SimonSapin> ah, thatâ€™s when I tried &my_function
[13:01:53] *** Joins: bytbox (s@moz-D4F26CEB.hsd1.md.comcast.net)
[13:02:01] <SimonSapin> error: mismatched types: expected `&fn(&extra::json::Json) -> <V58>` but found `extern "Rust" fn(extra::json::Json) -> ast::ComponentValue` (expected &-ptr but found enum extra::json::Json)
[13:02:27] <SimonSapin> oh, thatâ€™s because map gives a pointer
[13:02:54] <SimonSapin> map_consume (which I needed anyway) works
[13:05:58] *** Quits: MaikKlein (maik@moz-7F4AE15A.dip0.t-ipconnect.de) (Ping timeout)
[13:08:32] *** Quits: sw17ch (sw17ch@moz-39D8564F.wndsny.tds.net) (Ping timeout)
[13:09:10] *** Joins: sw17ch (sw17ch@moz-39D8564F.wndsny.tds.net)
[13:11:23] <indutny> oh how I like V% types :)
[13:11:25] *** Joins: int3_ (int3_@moz-ABE52D50.hsd1.ca.comcast.net)
[13:11:38] <SimonSapin> Can I pattern-match inside ~[T]? Trying it gives "mismatched types: expected `~[extra::json::Json]` but found a ~-box pattern"
[13:11:40] <indutny> I think type inference engine is really probabalistic
[13:12:26] *** Quits: igl (igl@moz-FB10C277.adsl.alicedsl.de) (Ping timeout)
[13:13:04] *** Joins: igl (igl@moz-8249BD2A.adsl.alicedsl.de)
[13:13:19] *** Joins: ghrust (ghrust@24260B07.6A2AE50.F3114085.IP)
[13:13:19] <ghrust> 01[13rust01] 15bors merged 06auto into 06master: 02http://git.io/Xhio_Q
[13:13:19] *** Parts: ghrust (ghrust@24260B07.6A2AE50.F3114085.IP) ()
[13:15:58] *** Joins: cowboyd (cowboyd@1D8844A7.1B729417.CEE440B6.IP)
[13:16:15] *** Joins: ghrust (ghrust@C621748.6A2AE50.F3114085.IP)
[13:16:15] <ghrust> 01[13rust01] 15bors pushed 0 new commits to 06auto: 02http://git.io/b6BJ0A
[13:16:15] *** Parts: ghrust (ghrust@C621748.6A2AE50.F3114085.IP) ()
[13:16:18] *** Joins: ghrust (ghrust@1E8607E8.6A2AE50.F3114085.IP)
[13:16:18] <ghrust> 01[13rust01] 15bors pushed 3 new commits to 06auto: 02http://git.io/SQd5wQ
[13:16:18] <ghrust> 13rust/06auto 14d31d8e3 15Felix S. Klock II: Refactored int/uint range code in preparation for change to range_rev semantics....
[13:16:18] <ghrust> 13rust/06auto 140b639c8 15Felix S. Klock II: Switch over to new range_rev semantics; fix #5270.
[13:16:18] <ghrust> 13rust/06auto 1462ccd3e 15bors: auto merge of #7524 : pnkfelix/rust/fsk-invert-range-rev-halfclosedness-issue5270, r=cmr...
[13:16:21] *** Parts: ghrust (ghrust@1E8607E8.6A2AE50.F3114085.IP) ()
[13:16:44] <cmr> indutny: left some comments
[13:16:46] <cmr> so close! :)
[13:16:50] <indutny> cmr: thanks :)
[13:17:01] <indutny> yeah, but I'm not sure about MemError
[13:17:02] <cmr> dbaupp: pong
[13:17:14] <indutny> its completely unclear how it could work with just error code
[13:17:27] <indutny> â€¦only if I would use negative values for context sensitive errors...
[13:18:02] <dbaupp> cmr: is http://hnn.mrsd.org/~cmr/e482856d76fba8d31ee114d4fb74f8c18f63e73c/time.txt meant to be formatted like that? (it looks like it's missing newlines or something?)
[13:18:07] <indutny> cmr: thoughts?
[13:18:16] <cmr> dbaupp: that is correct.
[13:18:23] <dbaupp> cmr: ok
[13:18:30] <cmr> dbaupp: gnu time's default formatting is quite weird, I agree.
[13:18:43] <indutny> oh gosh
[13:18:43] <indutny> http://hnn.mrsd.org/home.html
[13:18:58] <indutny> is this your school?
[13:19:04] <cmr> recently graduated
[13:19:23] <cmr> the design was going to be far worse before I intervened ;P
[13:19:29] <indutny> haha :)
[13:19:31] <indutny> ok
[13:19:45] <Ms2ger> It could be worse? ;)
[13:20:08] <Ms2ger> Animated flames and site-in-construction gifs?
[13:20:39] <doomlord> (default mehods not going across modules.. for the minute i suppose i can stick to using helper functoins built around methods in trait behaviour)
[13:21:00] *** Joins: jorendorff (jorendorff@moz-2F32ACA3.hsd1.tn.comcast.net)
[13:21:23] <cmr> indutny: Is there something I'm missing about the error codes? Does the int not unambiguously decide the string value?
[13:21:36] <indutny> take a look at windows implementation
[13:21:44] <indutny> sometimes it just fails without error code
[13:21:46] <indutny> :)
[13:22:21] <indutny> I think I can introduce my own error codes
[13:22:29] <cmr> I don't see a problem with that
[13:22:48] <cmr> Maybe use an enum?
[13:23:03] <indutny> right
[13:23:09] <indutny> that's what I want to do :)
[13:23:11] <cmr> Bubbling up the OS error code isn't that important, it's a high level interface
[13:24:17] *** Quits: pyrac (pyrac@moz-C9A2635A.infra.univ-bordeaux.fr) (Ping timeout)
[13:26:13] *** Joins: BitPuffin (quassel@moz-49828767.cust.tele2.se)
[13:28:22] <SimonSapin> So http://static.rust-lang.org/doc/rust.html#match-expressions defines `match_pat : pat [ ".." pat ] ? [ "if" expr ] ;`, but there is no definition of `pat`?
[13:28:40] <cmr> SimonSapin: the grammar in the manual is incomplete and, I'm guessing, sometimes incorrect
[13:28:51] <SimonSapin> Can I pattern-match inside ~[T]? Trying it gives "mismatched types: expected `~[extra::json::Json]` but found a ~-box pattern"
[13:29:19] <dbaupp> you don't need the sigil
[13:29:42] <SimonSapin> oh, nice
[13:29:46] <dbaupp> rusti: match ~[1,2,3] { [x, y, z] => x + y + z, _ => fail!("error") }
[13:29:46] <SimonSapin> thanks dbaupp
[13:29:47] -rusti- 6
[13:30:11] * dbaupp doesn't like that it is inconsistent with str patterns
[13:30:44] *** Joins: pyrac (pyrac@moz-C6037E0A.ghst.net)
[13:31:16] <engla> there is no syntax for prefix/tail match for str either (what I know)
[13:32:02] <engla> rusti: match ~[1,2,3] { [x, .._] => x, _ => 0 }
[13:32:03] -rusti- 1
[13:33:28] <doomlord> how do you propogate dependancies/imports ... lets say a.rs does use b.rs, b.rs uses c.rs, but you want importing b.rs to a to also bring in everything from c.rs
[13:33:59] <cmr> doomlord: `pub use c::*;` in b.rs, I believe
[13:34:14] *** Quits: bytbox (s@moz-D4F26CEB.hsd1.md.comcast.net) (Ping timeout)
[13:34:57] <doomlord> let me try.. (lol i did pub mod) but i seem to remember something about self::
[13:36:20] *** Joins: sam_ (sam@moz-14C16814.cst.lightpath.net)
[13:37:05] <doomlord> i always find the module imports seem to be harder than they should be
[13:37:18] *** Quits: jorendorff (jorendorff@moz-2F32ACA3.hsd1.tn.comcast.net) (Quit: jorendorff)
[13:37:21] *** Joins: ghrust (ghrust@5FEF1C87.6A2AE50.F3114085.IP)
[13:37:21] <ghrust> 01[13rust01] 15bors 04force-pushed 06auto from 1462ccd3e to 1455f1555: 02http://git.io/N3iJvQ
[13:37:21] *** Parts: ghrust (ghrust@5FEF1C87.6A2AE50.F3114085.IP) ()
[13:37:24] *** Joins: ghrust (ghrust@5FEF1C87.6A2AE50.F3114085.IP)
[13:37:24] <ghrust> 01[13rust01] 15bors pushed 2 new commits to 06auto: 02http://git.io/NU0UYg
[13:37:24] <ghrust> 13rust/06auto 14af30fe2 15Sankha Narayan Guria: Improve the attempted dynamic environment-capture error message
[13:37:24] <ghrust> 13rust/06auto 141cee9d4 15bors: auto merge of #7531 : sankha93/rust/master, r=bblum...
[13:37:24] *** Parts: ghrust (ghrust@5FEF1C87.6A2AE50.F3114085.IP) ()
[13:37:27] *** Quits: Nisstyre (wes@moz-FD86289.netflash.net) (Ping timeout)
[13:37:37] <doomlord> more seems to go wrong... 'use before mod'etc.. 
[13:37:42] <cmr> I don't quite understand the module/import system yet... it often confuses me.
[13:38:00] <dbaupp> doomlord: you probably need 'pub use self::c::*; pub mod c;`
[13:38:05] <kimundi> doomlord: 'use' has to go befor 'mod', even if the former referneces the latter
[13:38:10] <dbaupp> (the use's always have to go at the top of the file)
[13:38:49] <doomlord> one thing i just got to work surprised me ... a uses b,   b uses c,    but b could only see c if *a* uses/mods c aswell
[13:39:04] <dbaupp> cmr: I'm experimenting with that IRFY data now, btw (in Rust \o/ )
[13:39:15] <cmr> dbaupp: cool :)
[13:39:16] <dbaupp> doomlord: does "uses" mean 'use x;'?
[13:39:25] <cmr> doomlord: did you see https://github.com/SiegeLord/RustGnuplot ?
[13:39:28] <cmr> ermm... @dbaupp
[13:39:29] <doomlord> i'd hope you could just write..  a import b;   b import c;    the compiler figures out importing b and c
[13:39:50] <dbaupp> cmr: yeah, I did
[13:39:59] <kimundi> doomlord: Could you clarify? Sounds strange what your describing.
[13:40:03] <dbaupp> cmr: (not using it though, going to have the plots done in pure JS)
[13:40:15] <doomlord> 3 modules / rust source files.
[13:40:33] <doomlord> a,b,c;    a is main..      a wants to import 'b'.    b wants to import 'c'
[13:40:44] <doomlord> but this only works if i manually say a imports 'b', and 'c'
[13:41:09] *** Quits: ross (ross@moz-8A84103E.br.br.cox.net) (Quit: )
[13:41:10] <kimundi> something that results in 'mod a { mod b { mod c{}}}' should work
[13:41:14] <doomlord> instead of it propogating ...  a fetches b fetches c ... this surprisees me ; 
[13:41:27] *** Quits: KindOne (KindOne@moz-913DB376.dynamic.ip.windstream.net) (Ping timeout)
[13:42:00] <doomlord> ok the 'pub use self::c' is the detail i was missing.. i never get this instinctively
[13:42:13] *** Quits: parcha (quassel@moz-A9A9F340.hsd1.ma.comcast.net) (Client exited)
[13:42:13] <kimundi> doomlord: wait, do you mean that a 'use foo' in a child module does not find 'doo' unless it's an item in the root module?
[13:42:24] <doomlord> yes it didnt' seem to
[13:42:27] *** Quits: pnkfelix (pnkfelix@87C1F78E.1DE10CA8.D8E68FF6.IP) (Ping timeout)
[13:42:31] <cmr> oh right
[13:42:34] <doomlord> but i didn't have the "self:: " business going on
[13:42:37] <cmr> all paths are relative to the root of the crate
[13:42:42] <doomlord> its the need for self which is confusing
[13:42:45] <cmr> so if you want to reference things in your own module you need self::
[13:42:53] <kimundi> that's because 'use' paths are allways relative to crate roots
[13:43:08] *** Joins: pnkfelix (pnkfelix@87C1F78E.1DE10CA8.D8E68FF6.IP)
[13:43:16] <kimundi> unless you introduce relative paths withe the self or super keyword
[13:43:27] *** Quits: Blei (philipp@moz-4E4B9A0A.ethz.ch) (Quit: WeeChat 0.4.1)
[13:43:28] <doomlord> ok let me try again with self
[13:43:28] *** Joins: jpochyla (jpochyla@E1DB45DB.1AFA5C43.5DC06702.IP)
[13:43:53] <cmr> Someone should write up how and why the module system works.
[13:44:11] <dbaupp> doomlord: https://gist.github.com/huonw/5917942
[13:44:17] <doomlord> right. pub use self::  ... fixes my issues
[13:44:21] <doomlord> thanks
[13:44:52] *** Joins: jorendorff (jorendorff@moz-2F32ACA3.hsd1.tn.comcast.net)
[13:45:04] <kimundi> So, just to reiterate, a can import b, and b can import c, but the import in b has to be written with the knowledge that it is inside a OR with an explicit 'self' root.
[13:45:39] *** Joins: KindOne (KindOne@moz-25E78F3.dynamic.ip.windstream.net)
[13:46:31] *** Quits: Kruppe (user@moz-E150F49F.cpe.net.cable.rogers.com) (Ping timeout)
[13:46:37] <doomlord> pub use self:: ...   thats the detail that always escapes me when i sit down and try writing something in rust
[13:47:21] *** Quits: jpochyla (jpochyla@E1DB45DB.1AFA5C43.5DC06702.IP) (Ping timeout)
[13:47:28] <kimundi> doomlord: You mean what it does, or how to use it?
[13:47:46] <kimundi> Or _that_ you have to use it? :P
[13:47:59] <cmr> I often forget it exists too
[13:48:14] *** Joins: parcha (quassel@moz-A9A9F340.hsd1.ma.comcast.net)
[13:48:33] <cmr> I would rather have all paths be mod-relative unless you prepend a ::
[13:48:56] * kimundi thinks it's funny that he only learned how the module system works by explaining it to others, not by using it.
[13:49:23] <kimundi> Hm... now I'm wondering why the defaults can't be set in a way so that 'relative to self' is the default, and 'relative to root' needs a keyword/:: instead
[13:50:20] <kimundi> I mean whatever implemntation problems caused the current system, a simple swap of defaults shouldn't change it.
[13:50:32] <doomlord> yes i forget that i have to do that. Once its brought to my attention .. fine :) i think its a counter intuitive detail, but perhaps there are other problems it solves
[13:50:33] *** Quits: sankha93 (Instantbir@9276287F.8CAC2DA9.D2D1FAF0.IP) (Quit: Instantbird 1.4 -- http://www.instantbird.com)
[13:50:58] <doomlord> cmr - +1
[13:52:17] *** Quits: pyrac (pyrac@moz-C6037E0A.ghst.net) (Ping timeout)
[13:52:29] *** Joins: reyre_ (reyre@moz-9002CDDA.cpe.net.cable.rogers.com)
[13:52:54] <doomlord> a single 'import' keyword would be nice, import x  ==  use x::*    mod x.   still. None of this has caused the level of pain of headers :)
[13:53:23] <doomlord> i just moved some code between units and it was a relaxing experience comparatively speaking
[13:53:32] <SiegeLord> Wouldn't this 'import' cause dubplicate modules?
[13:53:46] *** Joins: pyrac (pyrac@moz-C9A2635A.infra.univ-bordeaux.fr)
[13:53:52] <doomlord> i would expect a system to be able to figure that out :)
[13:54:12] <dbaupp> doomlord: a macro `reexport!(x)` would work
[13:54:28] <dbaupp> (if/when macros can expand to multiple items.)
[13:54:34] <cmr> dbaupp: I don't think so? You wouldn't be able to use it more than once
[13:54:34] <doomlord> interesting
[13:54:38] <cmr> because of the mod/use ordering
[13:54:44] <dbaupp> cmr: oh
[13:54:47] <dbaupp> cmr: yes
[13:55:03] <doomlord> i would expect it just builds a dependancy graph and just brings in what it needs to , once per item
[13:55:04] *** Quits: jorendorff (jorendorff@moz-2F32ACA3.hsd1.tn.comcast.net) (Ping timeout)
[13:55:08] <dbaupp> cmr: but that'd be fine with `reexport!(x, y, z)`
[13:55:16] <cmr> yeah
[13:55:33] <SiegeLord> Fwiw, I never use relative includes in C++... I don't think I've ever used any relative imports in languages that I've used
[13:55:57] <doomlord> c++ of course is where its as bad as it possibly can be
[13:56:04] <doomlord> anything is an improvement coming from that
[13:56:48] *** Joins: pnathan (Adium@moz-E3C3FAF2.hfc.comcastbusiness.net)
[13:56:58] <doomlord> but in C++ i found myself recently surprised by trying the idea of "one class per source file/header file pair", and source.cpp includes source.h, and source.h includes its depednancies... and thats the cleanest i've ever seen C++
[13:57:12] <kimundi> I think having mod and use is fine, people just need to be more educated about where the difference is and how to use them
[13:57:20] <doomlord> of course that breaks down when you need to break classes up or when you dont have a clear mapping to classes
[13:57:55] *** Joins: dan_johnsin (dan_johnsi@6902762D.11B071D.FB9A45AF.IP)
[13:57:56] <cmr> doomlord: that's a javaism
[13:58:19] <doomlord> yeah. i didn't like having to do it.. but it surprised me as the best way to manage headers i've found
[13:58:22] <kimundi> mod == once per actual file, use to build the logical module tree of your crate. use == just a helper to bring names form your module tree in scope without needing to fully qualify it.
[13:58:36] <SiegeLord> I like keeping all my "file" mods located in the base module
[13:59:33] <cmr> SiegeLord: yeah, it seems like that is what the system was designed for
[13:59:37] <doomlord> i would definitely vote for the use being module-relative, with the opposite of 'self::' ... '::...' or some keyword like "root::" "crate::" as sugested
[13:59:55] <cmr> the main crate file has all the "mods", and you `use` to bring that stuff into your current mod when you need it
[14:00:49] *** Quits: pyrac (pyrac@moz-C9A2635A.infra.univ-bordeaux.fr) (Ping timeout)
[14:00:56] <SimonSapin> Can I return early from a do-block?
[14:01:10] <doomlord> perhaps you could non-destructively move the language over to that by introducing a root:: keyword :) then self:: and root:: code can co-exist.. and later you can move to the most popular default
[14:01:13] <SimonSapin> "error: `return` in block function"
[14:01:29] *** Quits: sam_ (sam@moz-14C16814.cst.lightpath.net) (Client exited)
[14:01:29] *** Quits: saml (sam@moz-14C16814.cst.lightpath.net) (Client exited)
[14:01:34] <cmr> SimonSapin: No, you cannot.
[14:01:43] <SimonSapin> :(
[14:01:43] <dbaupp> doomlord: how often do you import something from within a mod itself, though?
[14:01:54] <dbaupp> doomlord: (other than reexporting things.)
[14:01:58] <doomlord> i see imports as a generalized dependancy graph
[14:02:05] *** Joins: Nisstyre (wes@moz-FD86289.netflash.net)
[14:02:33] <doomlord> and when refactoring things get moved around alot..  the management is simplified when every unit can specify more itself, IMO
[14:02:37] <dbaupp> I would think that by *far* the most common thing to do is to import things from extern mods which are imported in the top-of-crate file
[14:02:55] <dbaupp> and having to write `use crate::std::uint;` would be horrible
[14:03:09] *** Quits: pnathan (Adium@moz-E3C3FAF2.hfc.comcastbusiness.net) (Ping timeout)
[14:03:46] <doomlord> for example i just started with "vecmath". but now i'm splitting it into "matrix" and "vector" .. instead of manually saying everything needs "matrix" and "vector", if "matrix" brings in "vector", anthing that brings in matrix gets it. similarly anything built on that exposes that inner componnet..
[14:04:01] <doomlord> import "mesh".. (i get mesh, matrix, vector too... )
[14:04:06] *** Joins: saml (sam@moz-14C16814.cst.lightpath.net)
[14:04:27] *** Joins: dualhbridge (dad@moz-9FEE6D3B.maine.res.rr.com)
[14:04:35] <cmr> doomlord: use mathlib::{mesh, matrix, vector}; solves that, and is what I see in most rust code
[14:04:43] <doomlord> or import "scene" ..  (scene->mesh  scene->matrix)  (mesh->vector)   (matrix->vector) 
[14:04:56] <cmr> but those are just reexports.. works fine in the current system
[14:05:02] <doomlord> import "scene" gets me (scene, mesh, matrix, vector) without having to manually think about all that
[14:05:08] *** Parts: dualhbridge (dad@moz-9FEE6D3B.maine.res.rr.com) ()
[14:05:39] <doomlord> "re-export", is that what "pub use" is
[14:05:43] <dbaupp> yes
[14:05:48] <doomlord> that is definitely making it easier sure.
[14:06:14] *** Quits: KindOne (KindOne@moz-25E78F3.dynamic.ip.windstream.net) (Ping timeout)
[14:06:36] <doomlord> <dbaupp> and having to write `use crate::std::uint;` would be horrible   <<< how about if it was ::std::uint
[14:06:49] <dbaupp> yeah, that's not so bad
[14:07:05] <doomlord> also this might sound like a terrible hack, but how about if it started the search from self:: , then if it doesn't find it , tries again from root ...
[14:07:27] <cmr> IMO the current system is fine when you use the "sanctioned" crate structure
[14:07:35] <cmr> but if you stray from it you get weirdness
[14:07:53] <doy> "try multiple search paths" sounds like it would end up being incredibly confusing
[14:07:55] <dbaupp> however, just grepping through rust/src: 55 occurrences of `use self`, 5950 of `use <something other than self>~
[14:08:07] <doomlord> its fine for me when i have someone around to remind me to do pub use self:: :)
[14:08:36] <doomlord> ok i'll get back to enjoying the new toys here :)
[14:08:54] <doomlord> moving functions around without having to mess with headers.. so relaxing
[14:09:01] <dbaupp> (actually, make that 42 of `use self`, 154 of `use super` and 5796 of `use <not super or self>`)
[14:09:27] <doomlord> whats super
[14:09:34] <dbaupp> the parent mod
[14:09:58] <dbaupp> mod a { mod b { use super::foo; } pubf fn foo() {} } imports `foo` into b
[14:10:06] <dbaupp> s/pubf/pub/
[14:10:24] <doomlord> maybe you can just put an error message in to remind people
[14:10:25] *** Joins: KindOne (KindOne@7D0DB6F0.E114B4AE.EC6A1518.IP)
[14:10:41] <cmr> Yeah that could work
[14:10:42] <SimonSapin> Can I match "A variable-length vector that starts with X"?
[14:10:42] <doomlord> "cant find foo ... (maybe you need use self::foo?)
[14:10:49] <dbaupp> also, I believe the system used to have (something like) the multiple search paths thing, but it was found to be too complicated (and fragile?) so it was removed.
[14:10:57] <cmr> If the import isn't found, but it's in self::, have the error message say that
[14:11:08] <dbaupp> SimonSapin: match foo { [X, .. _ ] => .. }
[14:11:34] <cmr> Resolve is already incredibly complicated, any major changes should be simplifications IMO
[14:12:11] <dbaupp> SimonSapin: (the `..` actually just matches the remainder as a slice, and it can be bound to any old name, including _)
[14:12:24] <SimonSapin> dbaupp: got it, thanks
[14:12:59] <dbaupp> SimonSapin: it even works in the middle of a match: `match foo { [X, Y, .. middle, Z] => .. }
[14:13:34] *** Joins: lkuper (lkuper@moz-C0CD33ED.hsd1.in.comcast.net)
[14:13:40] <SimonSapin> now to turn that &remainder into a ~[] that can be consume by the recursion â€¦ I suppose I have to copy? (Thatâ€™s fine, this is testing code.)
[14:13:56] <Ms2ger> dbaupp, not just head/tail? Clearly not a real functional language :)
[14:14:17] <dbaupp> SimonSapin: right, .to_owned() should work
[14:14:30] <dbaupp> Ms2ger: well these are vectors, not linked lists...
[14:14:59] <doomlord> is it even possible to have a 'real' functional language with good control over memory like rust is going for (like c/c++ delivers)
[14:15:26] <cmr> doomlord: don't think so, but I'm not all that familiar with it
[14:15:29] <Ms2ger> Sounds unlikely
[14:15:38] <cmr> definitely not a pure language
[14:16:03] <doomlord> i'm sure there are functional fanatics who think its posible :)
[14:17:13] <Ms2ger> Isn't "functional fanatics" saying the same thing twice? ;)
[14:17:37] *** Quits: cowboyd (cowboyd@1D8844A7.1B729417.CEE440B6.IP) (Client exited)
[14:17:55] <doomlord> fanatics are the ones who disagree with me :)  be they OOP fanatics, C++ over C fanatics, or functional fanatics :)
[14:18:55] <doomlord> in a C++ room, i'm a C or functoinal fanatic. in a haskell room, i'm a c++ fanatic..
[14:18:58] <kimundi> I wonder if it would be possible to change the vector destructuring to work on Iterators instead
[14:19:24] <kimundi> Or at least a generic trait based on itertors
[14:20:12] <Ms2ger> kimundi, iterators wouldn't play well with [X, Y, .. middle, Z], would they?
[14:20:19] <kimundi> 'match treeset.iter() { [1, 5, .._] => ... }'
[14:20:34] <Ms2ger> The Z in particular
[14:20:37] <kimundi> Ms2ger: Not as is, no
[14:23:19] *** Joins: illissius (illissius@moz-19397A63.catv.broadband.hu)
[14:23:54] *** Quits: mark_edward (quassel@moz-4A9A2F15.dynamic.utc.edu) (Ping timeout)
[14:25:16] *** Joins: cubic (cubic@moz-FE5AD6C7.mc.videotron.ca)
[14:29:30] *** Quits: jack (jack@moz-F1B36F9F.hsd1.nm.comcast.net) (Quit: Leaving.)
[14:33:42] <cmr> I'm assigning rustdoc bugs to myself, does anyone have a problem with that?
[14:34:24] * Ms2ger promotes cmr to Documentation Lead
[14:35:56] <doener> cmr: https://github.com/mozilla/rust/pull/7513 -- that failed because of the TCP test that just "randomly" fails, might want to retry that.
[14:36:33] <cmr> doener: thanks
[14:37:04] <dbaupp> cmr: yes
[14:37:12] <dbaupp> cmr: you should be closing them already! :P
[14:37:26] * dbaupp wants rustdoc2 to be here
[14:37:38] <cmr> It is here! https://github.com/cmr/rustdoc_ng
[14:37:57] <dbaupp> oooh! what stage of working is it?
[14:38:04] <cmr> "Doesn't run" :p
[14:38:08] <cmr> default method bug
[14:38:18] <dbaupp> right, those are pretty common ;)
[14:38:33] <cmr> waiting for sully to open a PR with fixes so I can cherry-pick them locally
[14:39:38] <cmr> What's the make target for testing the code snippets in the tutorials?
[14:40:42] <dbaupp> check-stage2-doc iirc
[14:40:58] <dbaupp> (or just check-doc, maybe)
[14:41:29] *** Joins: jedestep (jedestep@34641662.FB4DE631.66C78B76.IP)
[14:41:48] <cmr> make-stage2-doc it is
[14:41:52] <cmr> erm, check-..
[14:42:18] *** Joins: cowboyd (cowboyd@1D8844A7.1B729417.CEE440B6.IP)
[14:42:46] *** Quits: jedestep (jedestep@34641662.FB4DE631.66C78B76.IP) (Quit: leaving)
[14:42:49] *** Joins: jedestep (jedestep@34641662.FB4DE631.66C78B76.IP)
[14:42:53] *** Joins: tedh (tedh@moz-190F9C83.static.mdsn.wi.charter.com)
[14:46:35] *** Joins: mr_pants (Mibbit@BBE7C46A.B4F11D08.8612FA94.IP)
[14:48:02] *** Quits: tiffany (kawaii@moz-1E0FE6E8.dhcp.embarqhsd.net) (Ping timeout)
[14:51:03] *** Joins: jorendorff (jorendorff@moz-1747FB68.hsd1.tn.comcast.net)
[14:54:13] <dbaupp> https://github.com/mozilla/rust/pull/7566 r?
[14:55:36] *** Quits: jdm (jdm@92FB48CA.8B5E9DF.9A8C35B4.IP) (Quit: Lost terminal)
[14:58:51] <dbaupp> cmr: thanks
[14:59:23] <indutny> cmr: yt?
[14:59:25] <indutny> cmr: can you r? it for one more time, please :)
[14:59:34] <cmr> indutny: sure
[14:59:37] <indutny> thanks
[15:00:06] *** Quits: int3_ (int3_@moz-ABE52D50.hsd1.ca.comcast.net) (Client exited)
[15:02:20] <dbaupp> cmr: are you passing -Z time-passes in the bench runner?
[15:02:36] <cmr> dbaupp: no
[15:02:45] <cmr> dbaupp: want me to?
[15:02:49] *** Quits: jensnock_ (jensnocker@moz-8BE55278.customer.t3.se) (Input/output error)
[15:02:50] <dbaupp> it'd be neat :)
[15:02:56] <cmr> sure, I'll do that later today
[15:03:06] *** Joins: jack (jack@moz-F1B36F9F.hsd1.nm.comcast.net)
[15:03:59] *** Joins: jensnockert (jensnocker@moz-C5F27039.cust.bredband2.com)
[15:04:46] <dbaupp> cmr: do you happen to know the units of the hz and usage fields of cpuacct?
[15:05:51] <cmr> dbaupp: hz is the unit of usage and so forth
[15:06:06] <cmr> and hz is in seconds
[15:06:28] <dbaupp> hz = sampling rate?
[15:06:40] <cmr> no, it's sysconf(_SC_CLK_TCK)
[15:06:46] <cmr> 1/ sysconf(_SC_CLK_TCK), that is
[15:07:08] <cmr> usage and so forth is how many clock ticks it was scheduled for I think
[15:07:57] *** Joins: Jesse (jruderman@moz-537BCF9.hsd1.ca.comcast.net)
[15:08:41] <dbaupp> hm, I see hz = 0.01, and usage = 359744310261, so apparently it was scheduled for more than a century (?!?)
[15:09:04] <cmr> what is the value of 'user'?
[15:09:40] <dbaupp> user: 357.16, system: 2.58
[15:09:45] <dbaupp> (they look like seconds)
[15:10:16] <dbaupp> I'd guess usage is in nanoseconds
[15:10:22] <cmr> Oh right
[15:10:31] <cmr> I multiply what I get from cpuacct by the hz
[15:10:37] <cmr> I included it for precision
[15:10:48] <dbaupp> and usage?
[15:11:18] <dbaupp> "/sys/fs/cgroup/cpuacct.usage gives the CPU time (in nanoseconds)"
[15:11:20] <cmr> "cpuacct.usage gives the CPU time (in nanoseconds) obtained
[15:11:23] <cmr> by this group
[15:11:25] <dbaupp> heh
[15:11:25] <cmr> Yeah
[15:11:36] <dbaupp> cool
[15:11:43] * dbaupp understands what's going on now
[15:12:45] <dbaupp> cmr: that computer is x64, right?
[15:12:49] <cmr> dbaupp: yes
[15:12:57] <cmr> Want the cpuinfo and meminfo?
[15:13:04] <dbaupp> don't need it
[15:13:06] <cmr> ok
[15:15:11] *** Quits: sp3d (a@moz-49806493.dhcp.stls.mo.charter.com) (Ping timeout)
[15:16:23] *** Joins: ghrust (ghrust@614D05BD.6A2AE50.F3114085.IP)
[15:16:23] <ghrust> 01[13rust01] 15bors merged 06auto into 06master: 02http://git.io/NU0UYg
[15:16:23] *** Parts: ghrust (ghrust@614D05BD.6A2AE50.F3114085.IP) ()

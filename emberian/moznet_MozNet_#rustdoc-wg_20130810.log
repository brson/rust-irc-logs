[01:46:32] <Seldaek> cmr: ah nice you did the enum json change
[01:46:40] <cmr> Seldaek: I did?
[01:46:53] <cmr> I *tried*
[01:46:58] <cmr> didn't send a PR though
[01:47:00] <cmr> couldn't get it to wor
[01:47:02] <cmr> k
[01:49:03] <Seldaek> ah
[01:49:09] <Seldaek> I don't know I just got an email from github
[01:49:18] <Seldaek> didn't click, because I'm about to fall asleep:p
[01:49:20] <cmr> oh yeah, I mentioned you in the text
[08:33:46] *** Quits: jga (asdf@F1D12213.30CD33A1.B5524284.IP) (Connection reset by peer)
[08:51:52] *** Joins: jga (asdf@F4D37E8.6535B9EF.B5524284.IP)
[13:03:09] <cmr> Seldaek: I got new JSON with properly stripped comments and the new enum encoding if you want it
[13:06:12] <Seldaek> sure
[13:06:21] <Seldaek> well, unless you still have big changes planned :)
[13:06:26] <cmr> nope
[13:06:35] <cmr> this should be the mostly-final form
[13:06:38] <Seldaek> then go for it
[13:06:40] <cmr> minus bugs...
[13:06:52] <Seldaek> obviously ;)
[13:08:29] <cmr> std.json.gz has been updated
[13:09:49] <cmr> Hm it seems enum encoding of nested enums in the json is still broken
[13:13:27] <cmr> On the plus side, typedefs are fixed I think
[13:15:05] <Seldaek> nested enums? 
[13:15:14] <Seldaek> how does that look now?
[13:15:33] <cmr> https://gist.github.com/cmr/dd357320ee2026c200d0
[13:15:59] <cmr> you can see the inner field is still the old encoding
[13:16:05] <cmr> how, I have no idea, because that code is completely gone
[13:16:58] * cmr updates rustc
[13:17:25] <dbaupp> cmr: that looks correct to me
[13:17:37] <cmr> dbaupp: the content of fields is an enum
[13:17:53] <dbaupp> cmr: are you sure?
[13:18:01] <cmr> it should be "fields" [ {"variant": "deriving", "fields": [...]} ]
[13:18:01] <dbaupp> cmr: isn't it a vector of the fields of the enum?
[13:18:03] <cmr> ...I think
[13:18:19] <cmr> uOHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHh
[13:18:21] <cmr> I'm dumb
[13:18:51] <cmr> I still need ot update rustc to get s/type/variant though
[14:05:02] <cmr> Seldaek: already, both std and extra updated this time
[14:48:45] <Seldaek> cmr: ok thanks
[14:49:06] <Seldaek> I went shopping so I have enough food to not leave this place for 5days, now I can update the json :p
[14:49:22] <cmr> hah
[15:22:50] <Seldaek> cmr: so crate.module is the main module
[15:22:58] <Seldaek> and crate.module.inner contains all the submodules?
[15:23:25] <Seldaek> it's extremely hard to scroll through to find the info at this point given the size of the json  :)
[15:23:57] <cmr> Correct
[15:24:12] <cmr> The structure exactly mirrors https://github.com/cmr/rustdoc_ng/blob/master/clean.rs now
[15:24:29] <cmr> https://github.com/cmr/rustdoc_ng/blob/master/clean.rs#L49
[15:24:42] <Seldaek> yeah, not that I'm very familiar with this though :)
[15:24:43] <Seldaek> but thanks
[15:25:16] <cmr> .inner actually contains everything
[15:25:18] <cmr> not just modules
[15:25:23] <Seldaek> ah so inner can contain anything yeah I see 
[15:25:27] <cmr> so all the structs are in there too
[15:25:35] <Seldaek> it's just an array of variant/fields
[15:25:37] <cmr> really really annoying, but it was the only way to make the code work
[15:25:52] <Seldaek> eh well, I'll cope :)
[15:26:10] <cmr> I hope to split it back out to separate arrays eventually, but it's a simple filter operation
[15:26:34] <Seldaek> I anyway do a two-pass thing where I index everything the first time and then render
[15:26:48] <Seldaek> so I can loop over all of it just once instead of looping on all the sub-types 
[15:26:51] <Seldaek> not a huge deal
[15:26:57] <cmr> cool
[15:28:02] <Seldaek> so you aggregate docs into one single doc attr now right?
[15:28:13] <Seldaek> well, comment it seems
[15:28:33] <cmr> yes
[15:28:35] <Seldaek> or doc.. wut
[15:28:40] <Seldaek> I see both on the crate attrs
[15:28:44] * cmr looks
[15:28:47] <Seldaek> which is what? :)
[15:28:56] <cmr> Comment is something different
[15:29:06] <cmr> the crate attrs ... shouldn't have a doc
[15:29:11] <cmr> that should be on the submodule
[15:29:17] <Seldaek> yes yes it is
[15:29:20] <cmr> ok
[15:29:23] <Seldaek> there are no crate attrs
[15:29:27] <cmr> ok good
[15:29:35] <cmr> #[comment="The Rust standard library"]
[15:29:40] <cmr> I dunno what that is used for
[15:29:49] <cmr> library title/summary I guess
[15:29:54] <Seldaek> mkay, I shall forget about it :)
[15:30:09] <Seldaek> this should be the first line of the docblock IMO
[15:30:24] <Seldaek> (and it seems it is just duplicated now)
[15:30:24] <cmr> It is :p
[15:41:45] <Seldaek> ok let's open 13MB of json in chrome see how it copes
[15:41:53] <Seldaek> because I can't scroll through this mess :)
[15:42:07] <cmr> I usually use http://chris.photobooks.com/json/default.htm
[15:42:16] <cmr> but... it's so big that it now pretty much hangs
[15:42:32] <Seldaek> yeah, I have a jsonview or whatever it's called ext for chrome 
[15:42:38] <Seldaek> that usually works well
[15:42:52] <Seldaek> but it seems like it didn't even try to render this one
[15:43:02] <cmr> heh
[15:43:03] <Seldaek> maybe because it lacks headers
[15:43:23] <Seldaek> let's try and kill firefox instead, that one doesn't read headers
[15:43:51] <Seldaek> wooh
[15:43:57] <Seldaek> it works ;)
[15:44:12] <cmr> What extensions is this? Because I need one too :p
[15:45:45] <Seldaek> for ffx http://jsonview.com/ is awesome
[15:46:11] <Seldaek> it's also the only one that allows you to copy from the browser and does not put garbage in your clipboard 
[15:46:20] <cmr> cool
[15:47:16] <Seldaek> for chrome/opera I have https://chrome.google.com/webstore/detail/jsonview/chklaanhfefbnpoihckbnefhakgolnmc but it's not as good really
[15:53:58] <cmr> this is very nice indeed
[15:54:40] <Seldaek> and yet it is still is confusing as hell to mentally parse this recursive enum wreck :)
[16:04:00] <Seldaek> cmr: uhh.. where did the ids go?
[16:04:20] * cmr panics
[16:04:57] <Seldaek> there are a few on enum variants 
[16:04:59] <cmr> they should all be there?
[16:04:59] <Seldaek> but that's all I find
[16:05:05] <cmr> that is troubling
[16:05:07] <cmr> let me fix that
[16:05:31] <Seldaek> modules and structs at least don't have them as far as I can see
[16:05:34] <Seldaek> maybe other stuff
[16:09:17] <cmr> it should be on the inner for everything that had an Id before
[16:09:24] <cmr> or, somewhere in the inner..
[16:09:31] <cmr> fixing it so that it's part of the item itself
[16:09:57] <Seldaek> that'd be a lot nicer
[17:35:25] <Seldaek> cmr: any chance of getting those ids soon or should I work around for now?
[17:35:31] <cmr> Hi!
[17:35:34] <cmr> Sorry, got distracted
[17:35:38] <Seldaek> hehe
[17:35:52] <Seldaek> no worries
[17:58:57] <cmr> gr this refactor is frustrating.
[17:59:04] <Seldaek> leave it otherwise
[17:59:14] <Seldaek> it's a one liner refactor for me
[18:08:56] <Seldaek> cmr: what's the equivalent of the "unit" output now?
[18:09:18] <cmr> sec
[18:11:24] <cmr> significantly longer than a sec
[18:11:28] <cmr> few minutes :p
[18:16:30] <Seldaek> what the.. what
[18:16:44] <Seldaek> I see a StructFieldItem
[18:17:15] <Seldaek> it has fields: [ { "type_": { ... }, "visibility": "inherited" } ]
[18:17:20] <Seldaek> why the heck type_ ? :)
[18:17:28] <Seldaek> shouldn't it be ty like the others?
[18:17:36] <cmr> probably
[18:17:41] <cmr> have-done renaming
[18:17:45] <cmr> sorry 'bout the mess
[18:17:50] <Seldaek> :)
[18:18:08] <Seldaek> it is a mess though :p
[18:18:13] <Seldaek> I hope it really helped on your end
[18:18:22] <Seldaek> because it's clearly not making things prettier her
[18:18:37] <cmr> it did
[18:20:59] <Seldaek> what's a RawPointer?
[18:21:10] <cmr> *Foo
[18:21:13] <Seldaek> k
[18:22:29] <Seldaek> crap, invalid generic reference id
[18:22:54] <Seldaek> ah I  know why
[18:23:49] <cmr> I have to go
[18:23:54] <Seldaek> alright
[18:24:02] <cmr> I'll fix it up this evening
[18:24:04] <cmr> sorry!
[18:24:10] <Seldaek> no worries, I'm progressing
[18:24:19] <Seldaek> probably will get stuck at some point but whatever
[18:24:24] <Seldaek> we'll see later
[19:32:22] <Seldaek> cmr: it builds!
[19:32:33] <Seldaek> some stuff is still broken, but at least it goes through ;)
[19:33:33] <Seldaek> and I only have 4 invalid ids left
[19:33:46] <Seldaek> hopefully they're my fault
[19:35:04] <Seldaek> cmr: and typedefs are still incomplete as far as I can see, I don't see enough info to rebuild the "target" type completely
[20:53:23] <Seldaek> alright uploaded the latest version
[20:53:28] <Seldaek> not much new though, but it all works again I think
[20:54:08] <Seldaek> cmr: and next time you say you'll help on the frontend because you're done with rustdoc_ng, remind me to check my TODOs for stuff you still have to fix ;)
[21:10:07] <cmr> Seldaek: :P
[21:17:14] <Seldaek> cmr: I'll try to do the impls after eating something
[21:17:48] <cmr> Seldaek: cool!
[21:18:02] <cmr> Seldaek: once we have that, and I get these issues fixed, I'll open a PR to add it to mainline.
[21:18:23] <Seldaek> but do note that tyedefs and also some generic typarams do not contain enough info for me to rebuild them accurately
[21:18:31] <cmr> ok
[21:18:34] <cmr> I'll look into it
[21:18:41] <Seldaek> those two are the main problems I think
[21:18:53] <Seldaek> probably I'm forgetting tons though
[21:19:31] <Seldaek> but e.g. http://seld.be/rustdoc/master/std/iterator/trait.FromIterator.html
[21:19:46] <Seldaek> if you check the source, T has actually a type using A
[21:19:57] <Seldaek> without this info, it just looks messed up because it seems A is unused
[21:20:03] <cmr> Ahhh
[21:20:06] <cmr> I see
[21:20:13] <cmr> that should be <A, T: Iterator<A>>
[21:20:28] <cmr> that will hopefully be a simple fix, probably just forgot to load a field from the ast
[21:20:44] <Seldaek> and well the typedefs have the same sort of problem, I know that type foo = bar but not Bar<Zomg<T>> 
[21:20:55] <cmr> is that the only problem with typarams?
[21:21:03] <Seldaek> I think so
[21:21:09] <Seldaek> they look good otherwise
[21:21:32] <Seldaek> from what I can tell anyway
[21:21:46] <Seldaek> it's kinda hard to review the whole docs, especially since I don't know the code so well :)
[21:22:03] <cmr> yeah
[21:22:17] <Seldaek> hm ok the lifetime here is a bit messed up http://seld.be/rustdoc/master/std/iterator/struct.TakeWhile.html
[21:22:21] <Seldaek> if you check the source
[21:22:26] <Seldaek> it should be on predicate too
[21:22:37] <cmr> from what I can tell, as soon as you have even the absolute dumbest impls, it'll be better than official rustdoc
[21:22:49] <Seldaek> yup
[21:23:13] <Seldaek> still have to enable markdown & syntax highlighting stuff 
[21:23:25] <Seldaek> oh and.. there are ///'s all over the place
[21:23:29] <Seldaek> that's another one for you
[21:23:31] <cmr> also, having a list of "things that implement this trait" and "traits this type implements" at all, would be super cool to release
[21:23:37] <Seldaek> yup
[21:23:46] <Seldaek> it's planned, just don't know yet how I'll do it :)
[21:24:18] <Seldaek> but it's just a two-way index I have to build, not rocket science
[21:25:14] <Seldaek> cmr: ah yes another sort of bad issue if you want a full list now.. parent ids on traits are still invalid
[21:25:23] <Seldaek> so I can't link to the parent
[21:25:32] <cmr> alright
[21:26:14] <Seldaek> and I have a dozen invalid ids in Resolved params too
[21:26:23] <Seldaek> but that's not the worst issue right now
[21:27:42] <Seldaek> ah I see why
[21:27:50] <Seldaek> http://seld.be/rustdoc/master/extra/arc/struct.RWWriteMode.html
[21:27:51] <Seldaek> there is one
[21:28:10] <Seldaek> it should be PoisonOnFail, but that one has #[doc(hidden)]
[21:28:20] <cmr> Ahhh
[21:28:20] <Seldaek> so the id refers to something you stripped I guess
[21:28:23] <cmr> yeah
[21:28:34] <cmr> I can turn off that pass
[21:28:54] <cmr> you just need to exclude doc(hidden) items from the index pages
[21:29:03] <Seldaek> yup
[21:29:16] <Seldaek> shouldn't be too hard
[21:29:30] <Seldaek> build time is now  9sec btw, still quite alright
[21:29:42] <Seldaek> given the scale of the two libs..
[21:30:34] <cmr> I looked a bit into searching stuff
[21:30:37] <cmr> holy shit is it complex
[21:30:54] <Seldaek> you mean the search engine replacement?
[21:31:05] <cmr> yes
[21:31:10] <Seldaek> heh
[21:31:21] <Seldaek> well fulltext search with random text is hard for sure
[21:31:26] <Seldaek> but I think we have a very limited scope here
[21:31:38] <Seldaek> so we should be able to get away with simpler stuff
[21:31:56] <Seldaek> anyway off to cook something before I pass out :p
[21:32:03] <cmr> heh
[21:32:07] <cmr> do that :p
[21:46:17] <Seldaek> omnom :p
[21:55:26] <cmr> woo it builds again
[22:00:25] <cmr> Seldaek: it is going to be type_ everywhere rather than ty
[22:00:30] <cmr> it'd be type, but that's a rust keyword
[22:00:39] <Seldaek> ok
[22:00:46] <Seldaek> that's fine with me
[22:00:52] <cmr> every item will have an id, and it will be on the item, not the inner
[22:01:07] <cmr> let me just post the new json while I work on the one-line comment stripping :p
[22:01:26] <Seldaek> k
[22:05:15] <cmr> Seldaek: extra and standard updated
[22:05:43] <Seldaek> thanks
[22:07:45] <Seldaek> cmr:  ok it builds again
[22:07:56] <Seldaek> all good :)
[22:24:42] <cmr> Seldaek: json updated with proper comments
[22:24:56] <cmr> So, outstanding bugs: typarams, and trait parent ids?
[22:25:45] <Seldaek> and type defs missing data too
[22:25:52] <cmr> ok
[22:26:31] <Seldaek> ok cool http://seld.be/rustdoc/master/extra/arc/struct.RWWriteMode.html
[22:26:35] <Seldaek> nice comments
[22:26:52] <Seldaek> still have to deal with the doc(hidden) though
[22:27:25] <cmr> well, it should probably always work when linking to a type
[22:27:36] <cmr> Hm, is poison a `priv` field?
[22:27:42] <cmr> I've updated everything with visibilities as well
[22:27:45] <cmr> all items that is.
[22:28:00] <Seldaek> well, it doesn't have a visibility
[22:28:08] <cmr> it should
[22:28:11] <Seldaek> so that means it's priv I think now?
[22:28:12] * cmr checks json
[22:28:14] <Seldaek> no I mean in the code
[22:28:18] <cmr> oh
[22:28:20] <cmr> no, pub
[22:28:27] <Seldaek> hu ok
[22:28:27] <cmr> Weird that it'd be using a doc(hidden) in a public api
[22:29:11] <Seldaek> well, there is a PoisonOnFail() function 
[22:29:17] <Seldaek> I think that's why the struct is hidden
[22:29:32] <Seldaek> though that's arguably bad, but that's none of my business right now :)
[22:32:46] <cmr> "visibility": "inherited"
[22:33:01] <cmr> do you want me to add a pass that changes all inherited visibilities to the proper public/private?
[22:33:09] <Seldaek> that'd be nice :)
[22:33:12] <cmr> k
[22:33:19] <Seldaek> should I display pub/priv though?
[22:33:22] <cmr> yes
[22:33:35] <cmr> most important is priv of struct fields
[22:33:37] <Seldaek> only on the fields of structs though?
[22:33:38] <cmr> the others aren't quite as important
[22:33:44] <cmr> yeah
[22:33:49] <Seldaek> yeah the rest is pub or it wouldn't be in the docs I guess
[22:33:54] <cmr> they're the only place where priv isn't default right now
[22:34:26] <Seldaek> so a priv field, you can set it when initializing a struct but not access it after?
[22:34:29] <Seldaek> or is it priv to the module?
[22:34:36] <Seldaek> i.e. you'd need a constructor function
[22:34:44] <cmr> you always need a constructor function
[22:34:55] <Seldaek> do you
[22:34:57] <cmr> you can reference the struct, but you can't construct it or access the priv field in any way
[22:35:07] <cmr> for structs with priv fields that is :p
[22:35:09] <cmr> not in general
[22:35:10] <Seldaek> ah yes ok
[22:35:13] <Seldaek> good good
[22:36:29] <Seldaek> so {% if field.visibility == "private" %}priv {% endif %}
[22:36:38] <cmr> looks right to me
[22:36:38] <Seldaek> and I don't display pub?
[22:36:42] <cmr> right
[22:36:45] <Seldaek> alright
[22:36:46] <cmr> ... for now
[22:36:49] <Seldaek> ;)
[22:37:20] <cmr> the documentation of visibility stuff is non-obvious to me, I'm sure the details will be ironed out once there are more users
[22:47:47] <Seldaek> ok so I still render the doc(hidden) things, just not in listings, but you can still access them and find them in search, I think that's good
[22:48:05] <cmr> yep
[22:52:33] <cmr> erm
[22:52:35] <cmr> http://seld.be/rustdoc/master/index.html
[22:52:37] <cmr> master disappeared?
[22:52:39] <cmr> *std
[22:59:00] <Seldaek> uh
[22:59:15] <Seldaek> oh wtf
[22:59:16] <Seldaek> :)
[22:59:36] <Seldaek> now *when* did that break:/
[23:00:05] <Seldaek> cmr: anyway question, can one struct have more than one impl (not counting impl of traits)?
[23:00:13] <cmr> Seldaek: yes
[23:00:27] <cmr> sometimes it's split up by private/public methods
[23:00:37] <Seldaek> ok
[23:00:39] <cmr> sometimes there is an implt<T: SomeBound> Struct<T>
[23:00:44] <cmr> and also for T: OtherBound
[23:00:50] <Seldaek> oh of course
[23:01:22] <Seldaek> damn generics mess hurt my head :)
[23:05:27] <cmr> oh uh
[23:05:38] <cmr> I might have accidentlly piped the output from extra to std.json
[23:05:41] <cmr> would that cause it? :)
[23:05:55] <Seldaek> probably :p
[23:06:18] <Seldaek> indeed std has extra in it
[23:06:25] <Seldaek> and it reads the name from within the file
[23:06:46] <Seldaek> you should script this :P
[23:06:54] <cmr> yeah yeah..
[23:07:12] <cmr> both of the jsons have been updated
[23:07:14] <cmr> I have removed Resolved
[23:07:18] <cmr> and replaced it with ResolvedPath
[23:07:34] <Seldaek> uhh ok
[23:07:37] <cmr> also changed the structure of Path significantly
[23:07:40] <cmr> ResolvedPath(Path, Option<~[TyParamBound]>, ast::NodeId),
[23:08:45] <Seldaek> oh crap :)
[23:08:57] <Seldaek> my yet-unsaved code is already invalidated
[23:09:48] <Seldaek> cmr: don't you want to make that ResolvedPath a proper struct with field names?
[23:10:08] <Seldaek> because fetching the third item from the fields to get the id really doesn't make me feel safe :)
[23:13:57] <Seldaek> cmr: yes|no? :)
[23:14:18] <Seldaek> just wanna know if I go with the current json or not
[23:34:44] <Seldaek> well, timeout ;)
[23:41:53] <cmr> Seldaek: sorry, back now
[23:42:00] <cmr> I can use a struct variant, sure.
[23:42:00] <Seldaek> no worries
[23:42:20] <Seldaek> well as you wish, I updated already but it's not a big deal to change agai
[23:42:22] <Seldaek> n
[23:44:21] <Seldaek> OwnedSigil = ~ right?
[23:44:41] <cmr> yes
[23:44:50] <Seldaek> do you know if there is always a region when there is a sigil?
[23:44:53] <Seldaek> or is this not related
[23:46:06] <cmr> it is related
[23:46:11] <cmr> there is sometimes a region when it's a..
[23:46:24] <cmr> hm
[23:47:01] <Seldaek> ok awesome thanks for the type-stuff updates, I can reproduce structs 1:1 now :)
[23:47:07] <Seldaek> cmr: leave that question :) 
[23:47:19] <Seldaek> if it's not clear cut I make sure both work
[23:47:37] <cmr> I thought I had my own enum for sigils but I apparently use the one from the AST
[23:48:54] <Seldaek> cmr: http://seld.be/rustdoc/master/std/iterator/struct.TakeWhile.html
[23:48:56] <Seldaek> win
[23:49:10] <cmr> T is still wrong, isn't it?
[23:49:14] <cmr> It should be T: ...
[23:49:23] <cmr> Did I not actually have enough information? :\
[23:49:29] <Seldaek> no in this case it's correct
[23:49:58] <Seldaek> I'll check the other issue now with T: ..
[23:51:26] <cmr> http://seld.be/rustdoc/master/std/iterator/index.html
[23:51:33] <cmr> Is that correct / up to date?
[23:51:38] <Seldaek> should be yes
[23:51:47] <Seldaek> why not?
[23:51:48] <cmr> The summary line is wrong
[23:52:01] * cmr checks the json
[23:52:11] <cmr> Well I'll be damned
[23:52:11] <Seldaek> I don't do any transforms anymore I think
[23:52:20] <Seldaek> apart from splitting at the first \n\n
[23:52:43] <cmr> Oh I didn't see that the documentation continued below
[23:52:45] <cmr> my bad
[23:52:56] <Seldaek> still the /*! shouldn't be there:)
[23:52:58] <cmr> it's also an example of incorrect commenmt stripping though :p
[23:53:09] <Seldaek> yeah I thought that's why you freaked out
[23:53:17] <cmr> no :p
[23:53:37] <Seldaek> I do the split because on some modules there is extensive docs and it just pushes all the module members down 
[23:53:49] <Seldaek> and apart from the first time when you discover a module, generally you don't care about those docs
[23:55:03] <Seldaek> in "fn from_iterator(iterator: &mut T) -> Self;" - I know we discussed this already, but I'm not quite sure it's a good idea to skip the mut
[23:55:09] <Seldaek> right now I show &T
[23:55:25] <Seldaek> if it really doesn't matter and you can implement it either way then ok
[23:55:31] <Seldaek> otherwise we need to show it like it is
[23:55:42] <cmr> Yes, it should be &mut there
[23:55:45] <Seldaek> ok
[23:55:53] <cmr> like, (mut iterator: &mut T)
[23:55:58] <cmr> the first mut, on the variable would be skipped
[23:56:01] <Seldaek> I want to be able to copy paste a trait from the docs and then fill in function bodies
[23:56:34] <cmr> I don't think the mutability of the argument binding is part of the signature, but I could be wrong about that
[23:56:38] <cmr> "argument binding"
[23:56:44] <cmr> fancy words..
[23:56:51] <Seldaek> I think I had problems with this
[23:57:00] <Seldaek> but not sure anymore
[23:57:15] <Seldaek> I always have so many problems with the compiler when I write rust:p
[23:57:27] <Seldaek> I'm used to runtime errors, compilers traumatize me
[23:57:44] <cmr> trading one kind of abuse for another :)
[23:57:50] <Seldaek> indeed
[23:58:40] <Seldaek> ok so let's see about those typarams bounds

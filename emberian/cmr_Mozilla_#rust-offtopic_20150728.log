[00:00:07] <scott> If `ref` was renamed to `*` like is sometimes suggested, we could do something akin to C pointer declarations in Rust...
[00:00:18] <scott> let *x: i32 = 42;
[00:00:44] <mbrubeck> `pointer variable declaration syntax` is not one of the features I'm most eager to copy from C.  ;)
[00:01:15] <scott> I actually think "let ref x: i32 = 42" should be an error today.
[00:01:35] <scott> Top-level ref/ref mut is just confusing.
[00:02:23] <aatch> scott, meh, it's just a consequence of the syntax. Sure it's a bit redundant, but making it an actual error seems pedantic. I could get behind a style lint for it though.
[00:02:23] <scott> Same with |ref x| closures... I think it's just an obfuscation.
[00:02:34] <scott> Sure, a style lint would be less controversial.
[00:02:40] <mbrubeck> scott: The syntax, or the functionality?  (i.e. should `let x = &42;` give the same error?)
[00:02:52] <scott> mbrubeck: Just the syntax of using ref on a top-level binding.
[00:02:53] *** Quits: erickt (erickt@moz-1mb.0ej.162.69.IP) (Ping timeout: 121 seconds)
[00:03:14] <aatch> mbrubeck, I get the impression that `let ref foo = <anything>` would be disallowed.
[00:03:43] <mbrubeck> Yeah, makes sense... I wasn't sure if it was that, or "reference to a temporary"
[00:04:34] <scott> I actually love the fact that &42 works in Rust. :)
[00:05:11] <aatch> scott, from a compiler-implementor pov, it's such an annoying feature.
[00:05:36] <scott> heh
[00:05:42] <aatch> scott, I definitely think we should have it, but man would my life be easier if it wasn't valid.
[00:07:03] <scott> aatch: What specifically makes it complicated?
[00:07:30] <scott> Is it hard to shove a new temporary in the right place with the current infrastructure?
[00:08:41] <aatch> scott, more that certain change I want to make are harder because of it. It's not actually that big of a deal, it's just an extra complication.
[00:09:25] <scott> So it's not transparent enough to other parts of the compiler?
[00:09:53] <scott> (i.e. not just a simple desugaring into something that would look normal to the rest of the compiler)
[00:11:49] <aatch> scott, more that if you could only take the address of lvalues (so things that can be on the LHS of an assignment), there'd be a couple less fiddly parts in codegen.
[00:20:21] <Peach> playbot: let ref x: i32 = 42; x
[00:20:21] -playbot- <anon>:9:13: 9:18 error: borrowed value does not live long enough
[00:20:22] -playbot- <anon>:9         let ref x: i32 = 42; x
[00:20:22] -playbot- output truncated; full output at: http://bit.ly/1Iq2FtX
[00:20:26] *** Joins: swgillespie (swgillespie@moz-qb3.04d.220.167.IP)
[00:20:50] <scott> That's a consequence of how playbot structures the code you pass it.
[00:20:58] <scott> playbot: let ref x: i32 = 42; show(x);
[00:20:59] -playbot- 42
[00:20:59] -playbot- ()
[00:21:35] <saml_> playbot, asl
[00:21:36] -playbot- <anon>:9:9: 9:12 error: unresolved name `asl`
[00:21:36] -playbot- <anon>:9         asl
[00:21:36] -playbot- output truncated; full output at: http://bit.ly/1Iq2IGj
[00:25:18] <swgillespie> so android got pwned today?
[00:25:33] <Elainemo> a few months ago :P
[00:25:51] <Peach> show?
[00:26:04] <swgillespie> how about, "Google issues a statement about Android getting pwned?"
[00:26:07] <swgillespie> Peach: http://www.npr.org/sections/alltechconsidered/2015/07/27/426613020/major-flaw-in-android-phones-would-let-hackers-in-with-just-a-text
[00:26:10] <Elainemo> Peach: if you look at the template that playbot uses,
[00:26:12] <Elainemo> https://play.rust-lang.org/?code=%23![allow%28dead_code,+unused_variables%29]%0A%0Astatic+VERSION:+%26%27static+str+%3D+%22rustc+1.1.0+%2835ceea399+2015-06-19%29%22;%0A%0Afn+show%3CT:+std::fmt::Debug%3E%28e:+T%29+{+println!%28%22{:%3F}%22,+e%29+}%0A%0Afn+main%28%29+{%0A++++show%28{%0A++++++++let+ref+x:+i32+%3D+42;+x%0A++++}%29;%0A}&run=1
[00:26:14] <Elainemo> ugh link
[00:26:19] <XMPPwocky> fun
[00:26:21] <Elainemo> http://is.gd/qjX477
[00:26:33] <Elainemo> I thought we were gzip+base64'ing the query parameter :(
[00:26:45] <Elainemo> guess that never went through
[00:26:51] <XMPPwocky> i just use the gist thing
[00:26:56] <swgillespie> as far as vulns go that one sounds like a doozy
[00:26:56] <Elainemo> yeah I forgot
[00:27:06] <Peach> Also everyone, how can you talk about consistency in syntax when Rust has
[00:27:07] <Elainemo> swgillespie: yeah it's a bad one.
[00:27:08] <Peach> playbot: println!("hi"); println!["hi"]; println!{"hi"};
[00:27:09] -playbot- hi
[00:27:09] -playbot- hi
[00:27:09] -playbot- output truncated; full output at: http://bit.ly/1JMwQIq
[00:27:15] <swgillespie> haha
[00:27:27] <swgillespie> Peach: it's a macro, you can do whatever you want
[00:27:29] <Elainemo> Peach: it's only on macros, and it's consistent with the macro definition.
[00:27:30] <XMPPwocky> swgillespie: yeah, luckily there's loads of infrastructure for rapidly rolling out patches to Android devices!
[00:27:33] <XMPPwocky> right?
[00:27:37] <swgillespie> lololol
[00:27:38] <Elainemo> What would be inconsistent is only allowing one...
[00:27:42] <niconii> macros are consistently inconsistent >_>
[00:27:48] <Elainemo> It's *complex*, not inconsistent.
[00:28:18] <swgillespie> XMPPwocky: I doubt my phone has been patched recently
[00:28:38] <Elainemo> Was a PoC actually published?
[00:28:45] <Elainemo> I didn't see one.
[00:28:57] <scott> I can't say I'm a fan of macros being callable with every bracket type.
[00:29:05] <scott> Is there a situation where you want both for one macro?
[00:29:10] <scott> s/both/more than one/
[00:29:16] <XMPPwocky> Elainemo: not yet, it's going for a con apparently
[00:29:18] <XMPPwocky> defcon iirc
[00:29:22] <Elainemo> mm
[00:29:32] <XMPPwocky> now, for Weird Rustc Errors:
[00:29:45] <XMPPwocky> playbot: let x = 0u32; let y: &u32 = &x;
[00:29:46] -playbot- ()
[00:29:47] <XMPPwocky> ok
[00:29:50] <XMPPwocky> playbot: let x = 0u32; let y: &u32 = &x as &_;
[00:29:51] -playbot- ()
[00:29:52] <XMPPwocky> ok
[00:29:55] <XMPPwocky> playbot: let x = 0u32; let y: &u32 = &x as &_ as &_;
[00:29:56] -playbot- <anon>:9:37: 9:45 error: cast to fat pointer: `&u32` as `&_`
[00:29:56] -playbot- <anon>:9         let x = 0u32; let y: &u32 = &x as &_ as &_;
[00:29:56] -playbot- output truncated; full output at: http://bit.ly/1Iq2XkF
[00:29:57] <XMPPwocky> wat
[00:30:03] <Elainemo> scott: so you want to look at the macro definition to know how you can invoke it?
[00:30:22] <Elainemo> XMPPwocky: yeah, the unconstrainted _ in the middle there goes wild.
[00:30:42] * swgillespie turns off MMS loading
[00:30:48] <Elainemo> oh, how do?
[00:30:52] <XMPPwocky> i was hoping to see how long i could chain "as &_" before type inference died horribly
[00:32:00] <swgillespie> Elainemo: dunno if you're talking to me, but https://www.twilio.com/blog/2015/07/how-to-protect-your-android-device-from-stagefright-exploit.html
[00:32:07] <swgillespie> apparently
[00:32:20] <Elainemo> nice, thanks.
[00:32:23] <scott> Elainemo: I want every macro invocation to use the same brackets, so I guess yeah.
[00:32:23] <Elainemo> (I was)
[00:32:40] <XMPPwocky> https://play.rust-lang.org/?gist=116a300bc863d9196c58&version=stable ooh, stack overflow
[00:32:46] <Elainemo> scott: ah, but some macros are used for control-flow like things, which makes {} ultra convenient.
[00:32:51] <Peach> Oh my
[00:32:52] <XMPPwocky> looks sort of beautiful, really
[00:33:12] <Peach> I just saw the most ridiculous programming language idea ever
[00:33:49] <scott> Elainemo: I meant within a single macro. So, I'm happy for println to use () and vec to use [] and something else to use {}, but every println should be (), every vec should be [], etc.
[00:33:58] <Elainemo> scott: ah, yes, sure.
[00:34:13] <Elainemo> but to actually do that... knowing which one to use is annoying.
[00:34:15] <scott> Still, this is working out as a convention anyway. As long as I don't have to read a silly person's code.
[00:34:23] <Peach> " if the keyword "PLEASE" does not appear often enough, the program is considered "insufficiently polite", and the compiler will generate an error message; if the "PLEASE" keyword is used too often, the program could be rejected as excessively polite. "
[00:34:32] <aatch> INTERCAL!
[00:35:44] <scott> It wouldn't take long to add that to rustc.
[00:36:03] <swgillespie> we could ask the compiler's permission for unsafe blocks
[00:36:30] <scott> Really, the long part is to write up the RFC, have it rejected, and then fork Rust as "Polite Rust".
[00:37:32] <saml_> is there abstraction or model for resource/memory management?
[00:37:48] <Elainemo> saml_: in rust or in general?
[00:37:55] <saml_> in general
[00:37:56] <Elainemo> "yes" to both, but what specifically are you looking for?
[00:38:07] <saml_> like, Actor model for concurrency and parallelism
[00:38:09] <Elainemo> in general linear logic corresponds incredibly well to how people want resource management to work.
[00:38:21] <aatch> saml_, well RAII is probably the most well-known one for "manual" management.
[00:38:22] <saml_> but why isn't linear language popular?
[00:38:51] <saml_> https://en.wikipedia.org/wiki/Resource_management_%28computing%29
[00:39:00] <saml_> with block (in python) works well for simple resources
[00:39:06] <saml_> but memory allocation is not simple
[00:39:16] <scott> Rust has affine types which are really similar to linear types.
[00:39:17] <aatch> saml_, not a valid question, to my understanding there aren't any serious languages that use a true linear type system.
[00:39:18] <Elainemo> Memory usually handled automatically by the runtime.
[00:39:29] <saml_> because allocated memory can contain pointers to other allocation.. it can embed
[00:39:38] <Peach> Wow I just got a sassy compiler error message
[00:39:41] <Peach> "Can't cast a void type to type void (because the ANSI spec. says so, that's why)"
[00:39:51] <scott> Linear types would be just like Rust types where you have to call drop manually, as I understand it.
[00:39:57] <niconii> Peach: which compiler is that?
[00:40:18] <aatch> (To my knowledge there aren't *any* languages with linear type systems, but I'm confident that somebody has made at least a toy)
[00:40:23] <aatch> scott, more or less, yeah.
[00:40:40] <saml_> there's linearml and linear lisp . but toy languages
[00:41:02] <aatch> saml_, see!
[00:41:12] <Peach> niconii: it's an ancient C compiler for Mac OS 9
[00:41:32] <niconii> Peach: ...why the heck are you using that
[00:41:42] <Peach> For learning purposes
[00:41:43] <saml_> in rust, you don't have to close file handle,right?
[00:41:48] <zwarich> ATS has linear types
[00:41:49] <Peach> ACADEMICS :D
[00:42:14] <Elainemo> saml_: right, we have ownership-based resource management, and destructors are called when a value exits scope without being otherwise moved.
[00:42:25] <scott> saml_: Right, the destructor will be called automatically at the end of scope if the value isn't moved.
[00:42:31] <zwarich> you can apparently encode linear types in Idris?
[00:42:39] <Peach> Actual compiler error: "Symbol table full - fatal heap error; please go buy a RAM upgrade from your local Apple dealer"
[00:42:50] <Elainemo> zwarich: in coq as well.
[00:43:17] <scott> Idris added them in part because of Rust, iirc.
[00:44:02] <Peach> I'm learning how to add sass to my compiler error messages by studying old compilers :D
[00:44:26] <Peach> Here's another real error message from an old C compiler:  "This function has an explicit return type and deserves a return value"
[00:46:21] <zwarich> actual guarantees of deallocation would be really helpful
[00:46:44] <Elainemo> yeah
[00:46:51] <Elainemo> it's unfortunate the way that one rolled
[00:50:44] <zofrex> c74d: the "do not merge" thing is nothing to worry about, that's normal
[00:50:57] <c74d> ... 'k.
[00:51:12] <Peach> Hey anyone know if I can test Vulkan?
[00:51:25] <Peach> As in OpenGL's successor Vulkan
[00:51:30] <Elainemo> Peach: no, you can't.
[00:51:35] <Peach> :(
[00:51:40] <Elainemo> no public drivers for it.
[00:51:46] <Peach> But but
[00:51:57] <Peach> how is everyone making Vulkan apps?
[00:51:59] <Elainemo> you can test Mantle if you have a new enough AMD card (GCN) and Windows
[00:52:03] <Elainemo> no one is making Vulkan apps.
[00:52:12] <Elainemo> unless they are in the Khronos group and have access to the drafts
[00:55:28] <zofrex> c74d: I remember that from my android days, but I found a reference 'cos it is weird: https://groups.google.com/forum/#!msg/android-building/oJxZ92kC70E/IP9UlsoFoWgJ
[00:56:21] <c74d> zofrex: oh, thanks.
[00:56:27] <zofrex> np
[00:56:28] <Peach> Elainemo: http://vulkan-tutorial.com/
[00:56:59] <Elainemo> Peach: there's no actual information there.
[00:57:07] <Peach> :(
[00:57:11] <Peach> Wait
[00:57:21] <Peach> how on earth do you parse a web page that fast Elainemo ?
[00:57:29] <Peach> Are you even human?
[00:57:31] <Elainemo> with my eyes
[00:57:45] <Elainemo> I knew what I was looking for
[00:57:58] <Elainemo> and the page hasn't changed since I looked at it last :P
[00:58:06] <Elainemo> (when it was released by the guy, on reddit.com/r/vulkan)
[00:58:18] <Peach> At least we know: vkCmdBindDescriptorSet(cmdBuffer, VK_PIPELINE_BIND_POINT_GRAPHICS, textureDescriptorSet[0], 0); vkQueueSubmit(graphicsQueue, 1, &cmdBuffer, 0, 0, fence);
[00:58:37] <Peach> looks like OpenGL meets OpenCL
[00:58:44] <Elainemo> kinda not really.
[00:58:47] <Elainemo> look at the Mantle reference.
[00:58:55] <Elainemo> Vulkan is based on it, ought to be very similar.
[00:59:13] <Elainemo> tomaka has some stuff for it in Rust, Overv lead the main reverse-engineering effort for the AMD drivers
[00:59:22] <Elainemo> (the guy who has vulkan-tutorial.com)
[00:59:26] <Peach> Ok cool Rust vulkan
[00:59:33] <Peach> Vulkan scares me though
[00:59:39] <Elainemo> too low level for you?
[00:59:43] <Peach> It's gonna make graphics programming harder :(
[00:59:49] <Elainemo> It's going to make it easier.
[00:59:55] <Elainemo> Less crap.
[01:00:04] <Elainemo> Easier to cut to what you actually need to do to program the GPU.
[01:00:08] <Peach> Really?
[01:00:17] <Elainemo> Better drivers quicker.
[01:00:20] <Peach> Is it easier if I don't know how a GPU works?
[01:00:20] <Elainemo> Faster, less overhead.
[01:00:25] <Elainemo> Of course it isn't.
[01:00:31] <Elainemo> But you shouldn't be using low-level GPU programming interfaces then.
[01:00:39] <Elainemo> (unless you want to learn, obviously)
[01:00:57] <Peach> Is Vulkan going to replace OpenGL?
[01:00:59] <aatch> Vulkan sounds like my kind of API then.
[01:01:03] <Elainemo> No.
[01:01:19] <Elainemo> It's unlikely, even just for the amount of "legacy" OpenGL applications
[01:01:30] <Elainemo> I doubt there will be many if any new GL versions though.
[01:02:18] <Peach> I don't get "liking" Low Level, I mean performance sure but if your job isn't just focused on low level stuff : (
[01:02:19] <Elainemo> And Vulkan isn't easily supported by older or cheaper mobile GPUs.
[01:02:32] <Elainemo> Peach: if your job isn't focused on low level stuff, use high level libraries.
[01:02:43] <Elainemo> I mean, that's the way it is now!
[01:02:53] <Elainemo> You either use OpenGL naively, or you use it efficiently.
[01:03:27] <Elainemo> Or higher level libraries (like glium in Rust)
[01:03:32] <aatch> Peach, well for some people working on the low-level stuff *is* their job.
[01:03:35] <Elainemo> or even higher level.
[01:03:44] *** Quits: swgillespie (swgillespie@moz-qb3.04d.220.167.IP) (Quit: My MacBook Pro has gone to sleep. ZZZzzzâ€¦)
[01:03:47] <scott> The issue with how high-level OpenGL is is that it's the lowest level we have access to. With something lower level, you can write a new OpenGL-level kind of thing on top that's better than OpenGL.
[01:03:53] <scott> At least that's how I naively see it.
[01:04:20] <aatch> And plenty of people enjoy working at a low-level, I know I do.
[01:04:44] <Elainemo> indeed, I always push as low as I can go when trying to understand something
[01:05:20] <Peach> aatch: I bet those people *aren't* the ones that are building an entire high level end-user consumer product; cause that's where my perspective is
[01:05:32] <scott> I feel like GPUs should just have ISAs like CPUs that people can target with whatever kind of higher level APIs they want to design.
[01:05:45] <Peach> Probably the lucky ones that just get assigned a job within a larger team
[01:05:47] <scott> And no drivers...
[01:05:47] <Elainemo> scott: they do, but the OS usually doesn't let you use them.
[01:05:49] <aatch> Peach, sure, I'm not saying *you* have to like working at that level.
[01:06:27] <Elainemo> scott: you need drivers for privelege isolation and device sharing...
[01:06:43] <Peach> aatch: I know, it's just that most programmers I meet *encourage* working at that level for every perspective
[01:07:24] <Elainemo> Peach: the rust community in particular is obviously full of low-level systems type people.
[01:07:28] <scott> Elainemo: No kernel-mode drivers, then, if that's possible. Drivers just really shouldn't be capable of causing a kernel panic.
[01:07:37] <scott> Maybe that's more of a kernel issue than a GPU issue.
[01:08:14] <Peach> Elainemo: yup. Sadly for me I have found no community that is good with computers *and* also work with high level stuff
[01:08:30] <Peach> *good with low level and prefer high level stuff
[01:08:46] <scott> Generally the best high level programmers have a good understanding of the lower levels they rely on.
[01:09:08] <Peach> yeah scott that's what I mean
[01:09:34] <aatch> Peach, well there's several factors here. People that spend more time at a higher-level aren't going to talk as much about low-level details *because* they don't focus on them.
[01:10:01] <aatch> Peach, unless you're interrogating every programmer you come across, you're just getting what they're interested in.
[01:10:26] <Peach> I like to understand low level when I need to go in there, but I definitely like to see more people who understand low level and make quality user-friendly high level APIs
[01:10:38] <scott> One thing people enjoy about low-level work is the level of control available to them. If something isn't quite right, you can most likely make it right. At a higher level, you might be at the mercy of someone else's decisions (e.g. a particular garbage collection algorithm or whatever).
[01:10:47] <Peach> Often there's a lack of communication between low level and high level user friendly stuff
[01:11:30] <Elainemo> Peach: turns out building libraries is less fun than building products or just experimenting.
[01:11:52] <Peach> ?
[01:11:53] <Peach> Oh
[01:11:56] <Elainemo> none of my software jobs (except for my rust internship) involved doing anything another programmer would build upon.
[01:12:13] <aatch> Peach, it's not a lack of communication, it's a difficult balance to strike. "User friendly" isn't exactly universal, one person's "user friendly" is another's "overly restrictive".
[01:12:37] <zwarich> Elainemo: once you have clients you have to worry about their needs, backcompat, etc.
[01:12:58] <Peach> yeah, that's how it is - bare bones API and then programmers have to tediously work their way up to make an end product
[01:13:18] <Elainemo> Peach: would you call Qt bare bones?
[01:13:26] <Elainemo> Web development? Ember.js? Flask?
[01:13:30] <Elainemo> Scrapy?
[01:14:09] <Elainemo> Thee *HUGE* package ecosystems don't really confirm that point.
[01:14:17] <Peach> Qt is pretty bloated but Qt isn't bare bones (though I don't like how Qt apps are designed and the way stuff looks with it)
[01:14:44] <Elainemo> Have you seem Quick/QML?
[01:14:48] <Peach> I like programming to be so high level I don't even need to know what library or API I'm using underneath, but I *can* access the underlying components if I need to
[01:14:54] <Elainemo> wat
[01:14:59] <Peach> (unintended underline)
[01:15:12] <Elainemo> that doesn't even make sense, at that level of abstraction can you even do anything?
[01:15:42] <c74d> Peach: would you be willing to need to know what library the underlying components are in if you want to access them?
[01:15:49] <Peach> Elainemo: Yeah, think of a graphics API that lets you define 3D geometry and render it fast to screen
[01:16:01] <Peach> and underneath it uses OpenGL/Metal/Mantle
[01:16:15] <Elainemo> Ok, that's what you mean, you don't care how it interfaces with the rest of the platform.
[01:16:28] <aatch> Don't plenty of systems do that already?
[01:17:25] <Elainemo> In graphics in particular, unless you're looking at Unity or Unreal Engine or something massive, the renderer probably isn't going to be flexible enough to meet many teams' demands...
[01:18:47] <aatch> Hence why even small game-devs build their own graphics engines a lot of the time.
[01:19:31] <Peach> Elainemo: it's an entire unknown art of building flexible high level systems that scale well and are underlying API independent
[01:19:39] <Peach> but it's possible
[01:19:52] <Peach> It's just that it takes a lot of effort and most people don't do it
[01:20:54] <wrl> apis are better extracted from working code than developed on their own imo
[01:21:07] <Peach> wrl I'm doing that now actually
[01:21:17] <wrl> nice
[01:21:17] <Peach> I develop working code for myself,
[01:21:22] <Peach> notice patterns,
[01:21:33] <Peach> and then simplify and reduce without losing any speed
[01:21:51] <Peach> organize and reduce
[01:22:52] <Peach> My goal is to accomplish things using the *least* lines of code possible (but still have good spacing and naming for everything of course)
[01:24:21] <wrl> yes, of course.
[01:24:24] <wrl> are you really doing a 3d engine?
[01:25:43] *** Quits: pcwalton (pcwalton@moz-l8ebtf.sfo1.mozilla.com) (Client exited)
[01:25:54] <Peach> wrl yep
[01:27:09] *** Joins: bjz (bjz@moz-puppgq.tpgi.com.au)
[01:27:37] <aatch> Peach, speaking from experience, what you *think* is a nice re-usable API may very well not be. I spent hours building a system that was perfect for the project at the time, made sure it was independent and re-usable and promptly found it completely useless for the next project.
[01:27:58] <Peach> wanna say more detail aatch 
[01:27:59] <Peach> ?
[01:29:42] <aatch> Peach, not really, there aren't really any more details, without going into boring stuff about my day job. Its just that predicting future needs is hard.
[01:32:03] <Peach> aatch: well the scope of what you were building is probably different; the area I'm targeting is a set of high level concepts that don't change between the projects I make
[01:32:36] <Peach> I think it's difficult to extrapolate your experiences for the project I'm talking about, because I know they must be very different
[01:33:29] <Peach> different domains, different subcultures, and even difference of job vs for fun 
[01:34:21] <aatch> Peach, I was referring more to the idea of a "flexible high level system independent of the underlying API", you've basically just said that you don't need flexibility.
[01:34:41] <Peach> .....?
[01:35:00] <Peach> "flexibility" in this context, I don't understand
[01:35:13] <niconii> Peach: if you're targeting concepts that don't change, you don't need flexibility
[01:35:32] *** Joins: pcwalton (pcwalton@moz-l8ebtf.sfo1.mozilla.com)
[01:35:45] <scott> `a + b as T` parses as `a + (b as T)`, right?
[01:35:49] *** Quits: pcwalton (pcwalton@moz-l8ebtf.sfo1.mozilla.com) (Client exited)
[01:36:10] <niconii> scott: i think so... i'd probably add parens anyway though
[01:36:13] <aatch> scott, I believe so, yes. I tend to just put parens around casts anyway though because it's never that clear.
[01:36:21] <Elainemo> no one can ever remember the precedence of `as
[01:36:29] <Elainemo> :P
[01:36:30] <scott> I actually want (a + b) as T, so the parens are required anyway.
[01:36:41] <aatch> (except for obvious `let x = y as Foo`
[01:36:43] <aatch> )
[01:36:50] <niconii> playbot: 1i32 + 1u8 as i32
[01:36:51] -playbot- 2
[01:37:10] <niconii> so yeah, it's a + (b as T)
[01:40:54] *** Joins: swgillespie (swgillespie@moz-rn1.vmq.232.104.IP)
[01:42:59] <Peach> In Rust you cast with as?
[01:43:07] <Elainemo> yes
[01:43:14] <Peach> So I was thinking
[01:43:26] <Peach> for language design, to cast with  a  . syntax
[01:43:39] <Peach> (1.0).i32
[01:44:05] <Peach> or function syntax (but that could get ambigous)    i32(1.0)
[01:45:08] *** Quits: Tobba (Tobba@moz-o13d22.bredband.telia.com) (Ping timeout: 121 seconds)
[01:45:35] <Peach>    1i32 + (1u8).i32
[01:45:52] <Peach> or  1i32 + i32(1u8)
[01:46:10] <aatch> Peach, the function-call version makes more sense.
[01:46:22] <aatch> Peach, and doesn't conflict with field syntax.
[01:46:42] <Peach> would function call be ambigous with "construct an object" ?
[01:47:00] <Peach> because in C++  int(3.0)  - does it cast or construct
[01:47:14] <scott> C++ definitely makes it confusing.
[01:47:29] <aatch> Peach, "construct" probably, but I don't think it actually makes a difference.
[01:47:41] <scott> afaik int(3.0) is just the same as ((int)1.0), which is a C-style cast, which is usually discouraged.
[01:49:29] <scott> s/1.0/3.0/ heh
[01:50:41] *** Joins: mrx_ (mrx@moz-4ca0vq.dip0.t-ipconnect.de)
[01:51:24] <niconii> int(3.0) being the same as ((int)1.0) *would* make it confusing ;)
[01:52:44] <Peach> int(3.0); hmmm
[01:52:53] <Peach> but what about casting pointers?
[01:53:01] <Peach> char* to unsigned char* ?
[01:53:30] <Peach> the syntax char*(x) would be bad
[01:53:59] <Peach> But I guess in my case I can still use the syntax because my pointers use a different syntax
[01:53:59] *** Quits: mrx__ (mrx@moz-b3etcn.dip0.t-ipconnect.de) (Ping timeout: 121 seconds)
[01:54:00] <Elainemo> isn't your syntax ref[char](expr)?
[01:54:06] <whipsch> perhaps do reinterpretations very explicitly, like c++ with reinterpret_cast<foo *>(bar)
[01:54:18] <Peach> Yes Elainemo how do you remember O.o
[01:54:30] <Elainemo> why wouldn't I? you mentioned it like two days ago
[01:54:50] <Peach> Yeah so the cast would be   ref[int](x);
[01:55:03] <Peach> I can't really think of a better pointer syntax
[01:55:08] <Elainemo> I prefer casts to be rare and not have special syntax.
[01:55:20] <Peach> Yeah casts won't have special syntax
[01:55:26] <Peach> it'll look like a constructor
[01:55:44] <Elainemo> Widening casts should be done implicitly, narrowing casts should be explicit (since they lose information), reinterpretation should be a magic intrinsic, and all other conversions should be defined by the individual types.
[01:55:50] <Elainemo> imo
[01:56:22] <Elainemo> In my language I never implemented, "Kale", type conversion was global and didn't "belong" to particular types
[01:56:34] <Elainemo> And in particular some conversions could have multiple inputs and multiple outputs
[01:57:04] <Elainemo> the syntax looked like: input input |-> output output, with just input|-> for inference.
[01:57:28] <Elainemo> most operations could be cast in the light of "data conversion"
[01:57:45] <Peach> int x = 0; int *y = &x; *y = 5;     int x = 0; ref[int] y = ref x;  deref y = 5;
[01:57:47] <Peach> I can't think of a better syntax for dereference
[01:58:05] <Elainemo> pascal used ^y = 5
[01:58:08] <Peach> but in my language pointer and derefs are very rare
[01:58:19] <Peach> so I don't know if I need a terser symbol
[01:58:27] <Peach> I COULD use @ because it's free
[01:58:37] <Peach> and not taken like * and ^ are
[01:59:38] <scott> I've used a language that used postfix @ for deref.
[01:59:46] <Peach> Ooooh I could use type inference  so you can just type     ref y = ref x;   instead of    ref[int] y = ref x;
[01:59:53] *** Joins: Tobba (Tobba@moz-o13d22.bredband.telia.com)
[01:59:59] <Elainemo> Peach: y = ref x ought to be sufficient
[02:00:03] <scott> `foo->bar->baz.quux` became `foo@ bar@ baz quux`
[02:00:14] <Peach> Hey, should I have a distinct keyword for get address of?
[02:00:21] <scott> I like Rust's version: foo.bar.baz.quux
[02:00:50] <Peach> "ref" means pointer, and it also means "get address of" in my language
[02:00:55] <c74d> Peach: how often are your programmers expected to be dealing in memory addresses?
[02:01:16] <Peach> c74d: very rare and often unneeded
[02:01:46] <c74d> I'd say no, have it be a normal function (if you're having a distinction between functions and operators)
[02:01:49] <c74d> oh, keyword, not operator
[02:02:00] <c74d> well, still no, I dislike keywords :p
[02:02:02] <Peach> high level Lists(Vecs) are often used instead - smart ranged checked pointers; and Optionals are often use too
[02:02:13] <Elainemo> c74d: address-of as a function?
[02:02:24] <Elainemo> or just syntax you mean.
[02:02:31] <Peach> int *x = &y;    vs   ref[int] x = ref y;
[02:02:34] <c74d> well, something that looks like a function
[02:02:44] <Peach> "ref" is a type in my language and also a keyword for "get address of"
[02:02:50] <c74d> in my language concept it'd actually be one, in most not
[02:03:40] <Peach> @ could be adresss of because it's a pun that looks like email address :P
[02:03:52] <Peach> ref[int] x = @y;
[02:04:34] <Peach> Oh syntax decisions  decisions decisions
[02:05:30] <Peach> I want deref to be keyword operator, any suggestions?
[02:05:38] <niconii> hmm
[02:05:41] <Peach> int x = *y;    vs  int x = deref y;
[02:05:59] <niconii> in forth, @ actually derefernces
[02:06:03] <niconii> though uh
[02:06:09] <c74d> `deref` seems fine to me; natural opposite of `ref`
[02:06:35] <niconii> you don't really need to worry about that, there's not many forth programmers out there, and they're used to weird syntax >_>
[02:07:21] <scott> @ for rvalue derefences, ! for lvalue dereferences :P
[02:07:44] <scott> I like the excitement of mutating memory with !
[02:07:59] * Peach agress with c74d , knocks sense into scott
[02:08:13] <scott> Peach: I'm just talking about forth
[02:08:23] <c74d> ? I said nothing about scott.
[02:08:26] * Peach knocks sense into Forth
[02:08:47] <Elainemo> Peach: hey, just because it's different doesn't mean it's wrong.
[02:08:55] <niconii> forth sense knock
[02:08:58] <Peach> I'm totally joking
[02:08:59] <Peach> :P
[02:09:08] <scott> sense forth !
[02:09:17] <niconii> heh
[02:09:19] <Peach> c74d: oops meant to put that , on a new line
[02:09:34] <Elainemo> Peach: an essay you might appreciate, though not in context: http://www.jsoftware.com/jwiki/Vocabulary/Unreadability
[02:09:36] <niconii> : knock swap ! ;
[02:09:45] *** Quits: brson (brson@moz-cfhap5.mtv2.mozilla.com) (Connection closed)
[02:10:02] <Elainemo> *though maybe not in context
[02:11:37] <aatch> Elainemo, that basically sums up my feelings on syntax in languages.
[02:12:00] <Elainemo> aatch: it's very level-headed, yes.
[02:12:32] <Peach> Ok, so we have   ref  to get adress of , and deref to dereference
[02:12:46] <Peach> now should the "pointer" type get its own name
[02:12:54] <Peach> because it currently just uses "ref" too
[02:13:02] <Elainemo> this is why syntax ought to be described as "familiar" rather than "natural", "straightforward", or "readable"
[02:13:39] <Peach> ref[int]   is    int*      pointer to an int
[02:13:55] <Peach> should I name it    ptr or   even  pointer[int]  ?
[02:14:57] <Peach> pointer[int] = ref y;
[02:15:14] <Peach> pointer[int] x = ref y;
[02:15:29] <Peach> int value = deref x;
[02:15:38] <aatch> Elainemo, seems about right. As long as the syntax is reasonably consistent and not actively hostile, it's not really that important.
[02:16:46] <Peach> ref[int] = ref y;   is that confusing because ref keyword is a type AND the "address of " operator?
[02:17:03] <Elainemo> imo, no.
[02:17:09] <Peach> really? :O
[02:17:36] <Elainemo> it's pretty clear in context, and the type matches how it's created, like other constructors.
[02:17:39] <aatch> It's basically just an alias of `&` in Rust
[02:17:40] <Elainemo> it should perhaps be ref(y)
[02:18:39] <aatch> As long as it's clear which is the type and which is the expression, then it's fine. If it's not clear, then you have a separate problem.
[02:23:58] <Peach> ref x = ref y;   // < Is this a problem ?
[02:24:18] <Peach> because since the language has type inference you can omit    [type] in the declaration
[02:25:00] <Peach> ref[int] x = ref y;   and   ref x = ref y; are allowed
[02:25:19] <Peach> The compiler can always figure it out
[02:25:32] <Peach> but I'm just thinking about Human programmer user friendliness
[02:25:54] <c74d> Do people here have difficulty typing "->"?
[02:26:12] <Elainemo> not really.
[02:26:16] <niconii> nah
[02:26:25] <Elainemo> simple up-down motion of my middle finger.
[02:26:36] <Peach> pointer x = ref y;   would make the type pointer more distinct from the ref keyword of getting address of
[02:26:51] <Peach> hmm
[02:26:57] <Peach> decisions decisions decisions
[02:26:57] <c74d> I found myself often (even usually) mistyping it as "_>" or "-." or "_." in Haskell. I guess I was doing something wrong (other than mistyping it).
[02:27:20] <Elainemo> mistiming the shift-key!
[02:27:27] <c74d> well, yes
[02:27:56] <aatch> I have a habit of missing the '>' and doing '-?' instead
[02:28:02] *** Joins: Quxxy (chatzilla@moz-efh10q.internode.on.net)
[02:28:34] <scott> I'm kind of bad with the right side of my right hand in general...
[02:29:15] <scott> I start reteaching myself to type parens and such more properly.
[02:30:31] <c74d> this is why my programming language uses ':' instead in function signatures :p
[02:31:48] <c74d> But I agree with this channel about '->' being clearer, and ':' is becoming syntactically inconvenient, and feel I ought to change it.
[02:33:56] <zwarich> c74d: pray that you use { a : T } for record types and { a = T } for record values
[02:33:59] <Peach> : is syntax inconvenient?
[02:35:03] <Peach> durn it I still can't decide
[02:35:41] <Peach> function acos(float) returns float     or    function acos(float) : float  or function acos(float) -> float or   acos(float) float
[02:35:44] <c74d> zwarich: hm, I had ':' for both, but I'm thinking I might change the latter to '='
[02:35:56] <c74d> Peach: in my syntax, yes
[02:36:07] <zwarich> c74d: what kind of language is your language?
[02:36:19] <niconii> Peach: challenge conventions! function acos float(float)
[02:36:26] <scott> One of my least favourite things about JS is the long keyword "function" used for closures.
[02:36:27] <zwarich> I had the really stupid idea the other day after a Reddit discussion to try implementing something like Cyclone / Rust with whole-program type inference
[02:36:41] <scott> arr.map(function(x) { return x * x; }); // arghhhhhh
[02:36:44] <zwarich> the types would be pretty absurd
[02:36:46] <Peach> niconii: WHA
[02:36:49] <scott> arr.map(|x| x * x); // yay
[02:37:30] <scott> Or even Java 7, arr.map((x) -> x * x) or whatever it is.
[02:37:39] <Elainemo> array.map(*)
[02:38:16] <c74d> zwarich: a programming language, strongly and statically typed, but non-existent (or what you mean particularly?)
[02:38:17] <scott> array.map(square) maybe
[02:38:48] <zwarich> c74d: I guess I mean functional, OO, procedural, etc.
[02:38:49] <c74d> *what do you
[02:38:55] <zwarich> any distinguishing features?
[02:39:24] <aatch> Yeah, "Not existing" is a pretty common
[02:39:42] *** Quits: kimundi (kimundi@moz-upm4u8.3d6k.qdkt.57bc.2002.IP) (Ping timeout: 121 seconds)
[02:40:05] <c74d> zwarich: ah, mishmash, maybe 40-70% functional, 20-40% OO
[02:40:19] <zwarich> c74d: subtyping or row polymorphism on the OO part?
[02:41:58] <c74d> at this point, I don't know, which I'd like to fix lest I actually implement it and it turns out to have both, but not in a way that makes sense
[02:42:25] <c74d> but likely subtyping
[02:45:48] <Peach> You know
[02:45:51] *** Joins: kimundi (kimundi@moz-d29tad.dip0.t-ipconnect.de)
[02:46:07] <Peach> Why are programming language never categorized by what they're used for?
[02:46:28] <Elainemo> because successful languages get used for lots of things.
[02:46:32] <Peach> For example with Go - I'd rather know the domain it was intended to be used than know if it's functional duck typed etc.
[02:46:46] <Elainemo> what if it's not useful in the domain it was intended for?
[02:46:47] <aatch> Peach, because most programming languages are general-purpose.
[02:46:54] <Elainemo> what if it's better in other domains the designers didn't think of?
[02:47:06] <Elainemo> what if it's good enough in the obvious domains implied by its implementation?
[02:47:13] <aatch> It's like categorizing cars by where they're driven.
[02:47:20] <Peach> I think intended use should at least be mentioned in a language's page
[02:47:42] <aatch> Peach, well obviously.
[02:47:55] <Peach> aatch: Wrong sense. Applied to cars it would be "intended for ground travel"
[02:48:06] <Peach> You could rig a car for the water, but it's not meant for that
[02:48:39] <Peach> You could rig Javascript for System level kernerl/OS programming, but it's not meant for that
[02:49:02] <niconii> hmm... how the heck would i represent a forth word definition in rust? it usually involves multiple dynamic-sized parts...
[02:49:12] <aatch> Peach, and a sports car isn't meant to haul cargo across the the country.
[02:49:14] <Elainemo> niconii: multiple vec's.
[02:49:40] <Elainemo> Peach: I feel like "this language is good for: x y z" is pretty obvious given a cursory look at a language's design decisions and common implementations.
[02:49:46] <niconii> hmm, that does add a bit of indirection though
[02:50:18] <Elainemo> niconii: well, you could embed the entire thing in a vec<u8> and interpret it manually :P
[02:50:29] <scott> niconii: Why multiple parts?
[02:50:54] <niconii> Elainemo: eesh... maybe, though i'd like to avoid that if possible
[02:51:02] <niconii> typically it's something like
[02:51:05] <Elainemo> :P
[02:51:13] <Elainemo> I mean it's obviously possible.
[02:51:16] <scott> Don't most forths compile words to really simple bytecode?
[02:51:21] <Peach> aatch: my point is still that I wish programming languages gave more of an official "here's where the language has been used and what it was intended to be used for"
[02:51:37] <niconii> scott: nope
[02:52:51] <niconii> it's usually compiled to a series of pointers to other words...
[02:53:24] <niconii> rather... it's actually a little more complicated than that actually
[02:53:43] <aatch> Peach, why? What would that gain? At best it'll be ignored, at worst it'll limit what people use it for to whatever you can come up with.
[02:53:49] <niconii> well... okay so basically a word definition would be like
[02:55:05] <niconii> struct Word { prev: *const Word, name_len: u8, name: str, interpreter_ptr: fn(), data: [u8] }
[02:55:19] <Peach> aatch: Ok, well for example, Ruby
[02:55:25] <niconii> (this would be allocated on the heap)
[02:55:28] <Peach> I have no idea what Ruby's use domain is
[02:55:32] <Peach> No idea at all
[02:55:41] <Peach> Looked at a few pages of ruby
[02:55:43] <niconii> (or just in memory somewhere if you have no heap)
[02:55:44] <aatch> Peach, that's because it doesn't have one. Most languages don't.
[02:55:54] <Peach> and it's wiki
[02:56:15] <Peach> Surely programming languages have a domain
[02:56:28] <niconii> basically, interpreter_ptr points to a function that interprets the data
[02:56:51] <aatch> Peach, not really, they can be more or less suitable for a given domain, but most of the time you can use them more-or-less anywhere
[02:57:00] <Peach> : (
[02:57:07] <aatch> Peach, a domain-specific language is, by-definition, an exception.
[02:57:32] <Peach> aatch: you can't use Ruby to make an OS kernel can you?
[02:57:41] <niconii> for the vast majority of words, it interprets the data as pointers to other words, and just calls each in turn until it hits EXIT
[02:57:46] <aatch> Peach, not really, no.
[02:58:05] <scott> niconii: Words can have different interpreters? Is that how stuff like popping out of compile mode into interpreted mode works?
[02:58:19] <Peach> languages in practice don't get used for *everything* I don't know why you can't see that it can be helpful to have *some* kind of guide of what a language has been best suited for
[02:58:21] <niconii> but for some, interpreter could be just actual assembly code; this is how primitives work
[02:58:26] <aatch> Peach, but that's not the point. The fact that it's unsuitable in a few niche domains doesn't warrant a list of "target domains".
[02:58:40] <Elainemo> Peach: this is why I said "and look at a few implementations", in particular Ruby always has a garbage collected relatively slow runtime...
[02:58:45] <niconii> or it could be an interpreter for a completely different language
[02:58:53] <niconii> this is one of the ways forth can be very powerful
[02:59:00] <aatch> Peach, because it's normally obvious which domains it won't work for, and which it will.
[02:59:14] <Peach> aatch so languages shouldn't even have a "not particially suited for" list?
[02:59:33] <Elainemo> It's obvious.
[02:59:38] <niconii> scott: hmm, not sure off the top of my head
[02:59:41] <aatch> Peach, why should they? What advantage does that provide?
[02:59:56] <niconii> scott: i think that's something separate though? it's been a while
[03:00:08] <scott> niconii: It's been a while for me, too
[03:00:48] <niconii> ah, see, i left out something in Word though; flags
[03:01:17] <niconii> flags like "should this word always be executed immediately"
[03:01:26] <scott> ahh
[03:01:32] <niconii> i think this is how it gets from compile to interpret
[03:01:40] <scott> yep
[03:01:40] <aatch> I mean, I know that an interpreted language isn't likely to work well in a high-performance computing setting, I don't need the language documentation to tell me.
[03:01:49] <Peach> aatch: there's gonna be a lot of new programming languages that emerge, and I personally would like to know at a glance what areas the author intended a language to be used for as I browse google for "new programming languages"
[03:03:30] <Peach> example: angelscript - it page says at a glance - interpreted, application controlled, includes features useful for game consoles
[03:03:32] <aatch> Peach, but that doesn't mean stating specific domains. "High availablity applications" isn't a domain into itself.
[03:03:47] <niconii> anyway, i've really gotta reread jonesforth
[03:03:59] <Peach> aatch: you know what my point is right?
[03:04:08] <aatch> Peach, no, I really don't.
[03:04:16] <niconii> also, i think i might just resort to struct Word(Vec<u8>); after all...
[03:05:09] <Peach> Then how is this even a conversation :P    aatch - I'd like to have an idea at a glance what areas a programming language is made for.
[03:05:48] <niconii> guess it kinda hinges on what's less messy; having a single Vec<u8>, or adding extra indirection by having String and Vec<u8> inside a Word struct (which would itself be boxed)
[03:06:09] <Peach> Because surely when people make a serious programming language, it's to improve or simplify *some* task
[03:06:21] <aatch> Peach, not necessarily.
[03:06:23] <Elainemo> niconii: oh if Word is always boxed then you can just use Box<[u8]> ;)
[03:06:32] <Peach> aatch: what is *your* point?
[03:06:33] <scott> What do people think of `use std::{mem, ptr};`? I don't usually see {} used for modules.
[03:06:49] <Elainemo> scott: I like + use it.
[03:07:03] <scott> Good enough for me. :P
[03:07:17] <aatch> Peach, that you seem to be assuming that languages are designed to solve a specific application-level problem.
[03:07:41] <Peach> nope aatch 
[03:07:52] <aatch> Peach, that's not true. Rust for example was designed to make writing systems software easier and safer.
[03:08:17] <aatch> Peach, it wasn't designed with a specific domain in mind. Just "systems programming".
[03:08:21] <niconii> scott: i personally do `use std::mem; use std::ptr;` for that case
[03:08:43] <Peach> But aatch , I never *said* what you're saying
[03:08:51] <niconii> just to add a dissenting opinion :D
[03:08:55] <scott> This OpenGL function requires me to get the value 2*sizeof(GLfloat) as a void* type...
[03:09:16] <scott> I came up with this mess: ptr::null().offset(2 * mem::size_of::<GLfloat>() as isize))
[03:09:19] <Elainemo> scott: why aren't you using glium ;_;
[03:09:21] <scott> I should just use a cast...
[03:09:31] <scott> Elainemo: Learning the low level stuff this time around.
[03:09:33] *** Quits: saml_ (saml@moz-rkfmct.res.rr.com) (Quit: Leaving)
[03:09:50] <Elainemo> scott: you can't use offset, since that turns into a inbounds-GEP
[03:10:01] <Peach> Rust was built for the domain of low level programming, coming from the desire to replace C/C++ , it's intended use is to be able to access hardware directly and provide low level programming aatch 
[03:10:11] <scott> Elainemo: "can't use" in what sense? UB?
[03:10:15] <Elainemo> scott: UB, yes.
[03:10:23] <scott> Hmm, good to know.
[03:10:39] <Peach> to me that's an important description, it doesn't mean a language can ONLY be used for one purpose
[03:10:40] <aatch> Peach, yeah, aka "Systems Programming".
[03:10:43] <scott> Why is it UB to use .offset but not to just cast a random number to pointer type?
[03:10:44] <Peach> but it gives me an idea
[03:10:58] <Elainemo> scott: because of the LLVM intrinsic that offset maps down to.
[03:11:36] <Havvy> Who runs @rust ?
[03:11:51] <niconii> @rust?
[03:12:00] <Havvy> On Twitter.
[03:12:06] <niconii> oh
[03:12:07] <Elainemo> you mean @rustlang?
[03:12:14] <Havvy> Elainemo:  Probably
[03:12:19] <Havvy> (Not a garbaged collected pointer to the language)
[03:12:21] <Elainemo> steveklabnik has access, at least.
[03:12:27] <Peach> and I do not understand why aatch went cat and mouse with me just because I said I want programming language pages to give a vague idea of the category the language was built around @_@
[03:13:03] <niconii> i wondered if it was a typo of #rust at first, then thought that seemed strange, so i wondered if it was some other sort of discussion forum/chat...
[03:13:11] <niconii> twitter never occurred to me for some reason
[03:13:44] <aatch> Peach, both me and Elainemo said it was obvious most of the time. Ruby says it's "dynamic", that tells me a lot about it.
[03:13:50] <niconii> (seemed a strange question for you to ask, rather)
[03:14:03] <Havvy> niconii:  @Twitter-user #IRC-channel irc-user /u/reddit-user /r/subreddit
[03:14:13] * Havvy thinks https://twitter.com/havvy/status/625866044595286016 would be good for @rustlang to retweet.
[03:15:00] <niconii> yeah, but there's some lesser used ones too, like slack, or to a greater extent matrix
[03:15:58] <Peach> "obvious"? you people act like everyone who wants to program is a compsci major person that knows the environment implications of interpreted / dynamic languages
[03:16:56] <Elainemo> Peach: it's true, I expect people who want to program to be programmers, or willing to become programmers, and that's one of the skills important for being a programmer...
[03:18:17] <Peach> Is there no room for people who program without in-depth knowledge of CS theory and everything that comes with being a full programmer, I mean don't forget about the "little people" :P
[03:18:30] <Havvy> Oh, and github-user/repo
[03:20:11] <Peach> Stuff is often so implicit/hidden around computer stuff, that's all I have to say :P
[03:20:30] <Havvy> Peach:  Overall, we need better terminology.
[03:20:42] <Peach> ^
[03:20:44] <aatch> and yet how many people here are self-taught to some degree?
[03:20:47] <Havvy> I think the phases "Object oriented", "procedural", and "functional" are all terrible.
[03:21:09] <Havvy> aatch:  I took two years of undergrad, but 80% of what I know is self-taught.
[03:21:37] <Peach> Havvy: CS people are notorious for being uncreative with naming things intuitively or straightforward
[03:21:40] <Peach> "RAII"
[03:21:54] <scott> RAII is one of the worst named things ever.
[03:21:59] <Peach> worst name ever - it should be "Scoped Destructors" or something
[03:22:13] <scott> I blame C++ programmers. :p
[03:22:24] <Havvy> TODO: Check to see what the Rust book calls it.
[03:22:28] <Peach> Or "Scoped Cleanup" even
[03:22:34] <Elainemo> Havvy: ownership-oriented resource management
[03:22:41] <aatch> Isn't that actually a historical quirk though?
[03:22:53] <scott> I've seen scope-based resource management which seems ok.
[03:23:00] <Elainemo> that's an earlier term.
[03:23:07] <Elainemo> https://github.com/rust-lang/rust/pull/27032
[03:23:18] <scott> I don't like the -oriented in ownership-oriented
[03:23:18] <Elainemo> the problem with scope-based is that it's not scope-based.
[03:23:26] <Peach> Ok, so I don't know how many of you can go back into "newbie simulation mode"
[03:23:28] <scott> Yeah, it's a bit inaccurate
[03:23:50] <Peach> can you roll back to a time where you knew nothing about a computer other than how to use it as a consumer?
[03:23:51] <Elainemo> the problem with using -based instead of -oriented is that there are alternatives in unsafe code.
[03:23:59] <Elainemo> Peach: no, I can't.
[03:24:05] <Peach> :O
[03:24:06] <Peach> :'(
[03:24:08] <Elainemo> I don't know what it means to use a computer as a consumer anymore.
[03:24:17] <Elainemo> I can watch my mother use her mac, but it's pathetic.
[03:24:22] <niconii> i can't really either
[03:24:23] <Elainemo> compared to what I use my computer for
[03:24:34] <Elainemo> almost entirely disjoint sets of things we do
[03:24:47] <aatch> That means having to remember how I used a computer a decade and a half ago.
[03:24:49] <Elainemo> only thing in common is probably facebook and email.
[03:25:08] <Elainemo> even when I was a kid I didn't use a computer "normally", I was always tinkering with settings and the command line in win95
[03:25:23] <niconii> it's kind of hard to understand what people think when using computers, when they have no concept of how it works
[03:25:50] <Elainemo> I don't spend much time caring about design, though I am trying to improve in that regar.d
[03:26:10] <scott> Even as a kid I spent lots of time messing with computers and figuring out how stuff worked. I can barely empathize with people who don't know how to figure stuff out on their own.
[03:26:17] <Elainemo> (design of everyday things etc)
[03:26:22] <scott> e.g. to figure out Microsoft Word as a kid I just tried every button.
[03:26:51] <aatch> I can imagine what a non-technical person *might* do when approaching my software, but I still start with my own perceptions.
[03:27:24] <Elainemo> I'm not paid to do UX, and I have no interest in being paid to do so, and it's not one of my interests, so I'm going to stick to software :P
[03:27:26] <aatch> "I wouldn't want to see an interface with 60+ poorly-named checkboxes, so I doubt the user does to"
[03:27:34] <Peach> I think that says a lot - there's a massive disjunction among developers understanding what intuitive design is, because I guess most of you can't remember what it was like to just *not know* things about a computer
[03:27:38] <scott> I'm not terribly interested in designing for people who aren't programmer-level computer literate, but that's just my personality (I like to work on programmer tools, not user applications).
[03:27:50] <niconii> i don't even know, does the average person think computers can think, or that they can basically do anything? i don't really understand using a computer regularly but never learning about how it works
[03:28:16] <aatch> niconii, my experience, "computers are magic" is surprisingly common.
[03:28:19] * Peach is genuinely shocked that people can't roll back
[03:28:29] <Elainemo> Peach: how do you "roll back"? what do you assume people know?
[03:28:36] <niconii> to me, if you use a tool as a daily part of life, you learn a basic understanding of how it works, period
[03:28:40] <niconii> see, the issue is
[03:28:43] <Elainemo> I'd need to do actual user studies and experiments to figure out how users interact with the software.
[03:28:47] <Elainemo> I don't want to assume.
[03:28:50] <niconii> rolling back for me means rolling back to when i was like
[03:28:51] <Peach> You guys don't remember your first hello world and all the questions you had?
[03:28:53] <scott> Peach: There's almost nothing to roll back to - my initial experience with computers was "how does this work?" and then I figured it out.
[03:28:55] <niconii> five or six years old
[03:28:58] <Elainemo> I do.
[03:29:05] <niconii> that's way too far back for me to roll back to
[03:29:14] <niconii> i personally do not remember that, it was too far back
[03:29:17] * Havvy remembers getting in trouble with his parents for writing an infinite loop on purpose once.
[03:29:23] <Elainemo> It was some turtle game
[03:29:38] <Peach> Elainemo: roll back is actually recalling the specific naive thoughts you had about a computer, and retrospectively understanding how it was wrong yet still a reasonable assumption
[03:29:39] <Elainemo> that my dad introduced me to because I "wanted to make games"
[03:29:41] <scott> I'm currently at the "how does this work?" stage with OpenGL, so maybe I can use that for comparison?
[03:31:01] <scott> I started my programming life with PHP, which is actively anti-programmer... not sure how much I want to get back in that mindset. :p
[03:31:23] <Peach> Before I used to think that video games had to be store pictures of every possible state the game could possibly be in and play it back as you controlled it
[03:31:44] <niconii> Peach: o_O
[03:31:44] <Peach> *video games had to store and image and a sound for every possible state the game could be in
[03:31:56] <Peach> niconii: that's roll back to when I was 9
[03:31:59] <Elainemo> Peach: I guess I think that programming is already super approachable given the amount and quality of information on the internet, and that doing magic is worth some sweat and struggle as sacrifice.
[03:32:21] <niconii> ehh, well, i guess it's understandable if you're young
[03:32:37] <niconii> back when i was like four or five, i thought that like
[03:32:55] <niconii> what was on a video tape or cassette or cartridge or whatever
[03:32:59] <scott> Oh, I have a great naive example. When I was 5 or so, we had just got Age of Empires and I tried to play it but I had no idea how to make units move. I had to wait for my older brother to come home and teach me right-click.
[03:33:00] <niconii> was determined by its label
[03:33:08] <Elainemo> I've been coaching local elementary school students programming in javascript and codecombat and most of them pick it up pretty easy.
[03:33:35] <Elainemo> I work as a mentor for http://thinkful.com/ and my initial thoughts about what people would struggle with was completely wrong.
[03:33:38] <aatch> Elainemo, on the flip side, some people just don't get it.
[03:33:40] <niconii> as in, like, if you wrote "mario" on a cartridge, it'd become a mario game
[03:34:02] <Peach> Oh Elainemo tell me
[03:34:05] <Elainemo> They don't fight with concepts or syntax or how to accomplish specific tasks, they struggle with understanding how things glue together, how systems interact, and how patterns extrapolate.
[03:34:14] <nathan7> niconii: clearly you'd have to have it professionally printed
[03:35:09] <niconii> nathan7: didn't stop me from writing on all sorts of labels in a vain attempt to make new video games and movies >_>
[03:35:18] <Elainemo> It's a mindset that needs acclimation to.
[03:35:30] <nathan7> heh
[03:35:34] <aatch> Elainemo, heh, it's kinda the opposite for older students. I've tutored some people at university level and the common theme is that they reject the simple interpretation.
[03:36:20] <Elainemo> aatch: I've had some of that with my thinkful students but they're usually highly self-motivated (they're paying for the course after all) and do plenty of reading/experimenting.
[03:36:23] <aatch> Elainemo, they *expect* magic that just isn't there.
[03:36:28] <scott> niconii: You attempted piracy before you knew what it was
[03:36:43] <Elainemo> I've hit that a lot with some maths students at my school.
[03:36:43] <niconii> scott: pffft, guess so
[03:36:57] <Elainemo> "Can you make a computer do :incredibly abstract and likely undecidable mathematical problem:?"
[03:37:31] <niconii> scott: thing is i totally was emulating ROMs and shit by second grade
[03:37:33] <Peach> Yeah age changes intuition because students get introduced to more complex things like advanced math notation, which can effect how they guess at programming languages
[03:37:51] <aatch> Elainemo, the correct answer is obviously "yes".
[03:38:00] <Elainemo> aatch: my favorite answer is, "Can you?"
[03:38:02] <Elainemo> :P
[03:38:12] <nathan7> scott: writing names on video game cartridges is stealing, stealing is against the law, PIRACY, IT'S A CRIME
[03:38:32] <scott> I always felt like lots of math notation was weird and imprecise... I was really happy with the pedantry of compilers.
[03:38:35] <Elainemo> It seems the computational theory class at my school is one of the only maths classes that is actually constructive.
[03:38:47] <Elainemo> (in the constructive logic sense)
[03:38:49] <aatch> Elainemo, when they complain that the program is broken inform them that if there is a solution, it will terminate, eventually, assuming they're running it on a turing machine.
[03:39:16] <aatch> (And thus have infinite memory).
[03:39:27] <Elainemo> aatch: that's only true of semi-decidable problems :P
[03:39:28] <niconii> scott: like dude, /infinite video games for free/, a second-grader ain't gonna pass that shit up if she catches wind of that
[03:39:33] <scott> nathan7: Pirating trademarks!
[03:39:49] <Elainemo> I'm off to bed though, a bit over an hour past my bedtime :(
[03:40:09] <scott> niconii: Yeah, I got into that stuff well before I had the ability to pay for things online...
[03:42:01] <niconii> not like i had money anyway in second grade
[03:42:58] <scott> I pirated some games in childhood that I've since bought multiple times (gog/steam) as well as buying every new release from the developers.
[03:44:02] <Peach> So uh
[03:44:14] <Peach> Anyone here ever did a symbol table before?
[03:44:15] <scott> Piracy is interesting when it *causes* sales. I'm sure it's a net negative overall, though.
[03:44:44] <niconii> back in the day rom sites were typically all "by the way this is totes illegal unless you own a copy of this game", and that worried me at first
[03:44:53] <Havvy> scott:  I eventually go back and pay for games I pirate.
[03:44:57] <niconii> but then i remembered
[03:44:59] <niconii> video games
[03:45:00] <Peach> I'm doing all kinds of informal things with my AST to do symbol table lookup
[03:46:13] <Peach> Static type checking is more complex than I thought
[03:46:22] <scott> Dealing with warez and malware sites taught me safe web surfing.
[03:47:50] <Peach> Man
[03:48:03] <Peach> I shudder to think what C's AST must look like
[03:48:08] <Peach> in a compiler written in C
[03:48:38] <scott> Clang's AST is fun because it's designed to support C, C++ and Objective-C (and Objective-C++).
[03:49:35] <niconii> scott: is that "fun" in the dwarf fortress sense
[03:50:02] <c74d> Peach: there are plenty of rustc developers here, so I'd be surprised if none of them had worked on some kind of symbol table
[03:50:31] <aatch> Peach, anything specific you want to know?
[03:50:32] <scott> niconii: It's complicated, big, and messy, so maybe yeah?
[03:51:21] <niconii> well, i meant more in the "everyone dies horribly in a horrible, fiery death" sense
[03:51:23] <scott> niconii: I even noticed a "Typo" AST node which I believe is for making guesses at a typo correction and doing the rest of the compile as if the thing were corrected (to make later errors possibly more accurate).
[03:51:36] <Peach> aatch: Yes - I'm doing all sorts of "no-nos" I'm storing a vector of symbols in each AST node so I can easily do symbol lookup by checking root AST node until I get to a matching symbol name
[03:51:49] <niconii> (so horrible i used the word twice...)
[03:52:11] <niconii> scott: eesh
[03:52:14] <scott> http://clang.llvm.org/doxygen/classclang_1_1TypoExpr.html
[03:52:26] <nathan7> everyone hates that feature though
[03:52:43] <Peach> so I do   currentnode->parent.astsymbols  and if not found I do   parent->parent .astsymbols
[03:52:50] <Peach> and I keep going up
[03:53:52] <aatch> Peach, that's close to a common symbol table implementation. except that normally you have linked tables for names in scopes.
[03:54:22] <aatch> Peach, though shadowing makes it not really work.
[03:54:57] <aatch> shadowing within a scope, rather.
[03:56:48] <aatch> Peach, the Rust compiler associates an ID with each node (that actually needs one) in the AST and then uses that ID to link names to definitions.
[04:00:55] <aatch> Peach, if you're struggling with type-checking though, it might help to know that Rust uses a two-pass process, first is "type collection" where we collect all the types in the program, then we do "type checking" that makes sure everything matches up fine, this is also where inference happens.
[04:05:44] *** Joins: pcwalton (pcwalton@moz-6kjabm.ca.comcast.net)
[04:05:53] *** Quits: pcwalton (pcwalton@moz-6kjabm.ca.comcast.net) (A TLS packet with unexpected length was received.)
[04:14:30] *** Quits: bjz (bjz@moz-puppgq.tpgi.com.au) (Quit: My Mac has gone to sleep. ZZZzzzâ€¦)
[04:17:58] *** Quits: niconii (nicole@moz-tnrd7m.frgo.qwest.net) (Quit: leaving)
[04:31:20] <Peach> How bad is Tiny C compiler?
[04:31:42] <scott> I've heard it's pretty good considering its tinyness.
[04:32:06] <Peach> I was thinking
[04:32:18] <Peach> If I can make a full high level language that compiles to C
[04:32:52] *** Joins: erickt (erickt@moz-pqs.0ej.162.69.IP)
[04:32:52] *** ChanServ sets mode: +o erickt
[04:33:05] <Peach> then I can literally have a COMPLETE toolkit, about as advance as C++ (for my needs) - Using a code base waaay smaller than clang or gcc!
[04:33:29] <Peach> with a code base that takes less than a minute to compile from scratch
[04:33:30] <Peach> !
[04:34:48] *** Joins: bjz (bjz@moz-puppgq.tpgi.com.au)
[04:36:45] <swgillespie> you could write your own backend :P
[04:39:44] *** Joins: psd (psd@moz-1r6g79.mtnl.net.in)
[04:41:26] *** Quits: RCIX (RCIX@moz-ncp.dfa.8.198.IP) (Ping timeout: 121 seconds)
[04:42:34] *** Quits: bjz (bjz@moz-puppgq.tpgi.com.au) (Quit: My Mac has gone to sleep. ZZZzzzâ€¦)
[04:42:37] *** Quits: Tobba (Tobba@moz-o13d22.bredband.telia.com) (Ping timeout: 121 seconds)
[04:42:44] <Peach> swgillespie: but that's difficult
[04:42:50] <Peach> I'd rather compile to C
[04:43:08] <Peach> because optimizers are better with it than I'd probably do manually with LLVM
[04:43:29] <swgillespie> I made a language that targets LLVM recently and I emit really terrible IR
[04:43:46] <swgillespie> but LLVM shreds it with optimizations
[04:43:50] <swgillespie> without me doing muc
[04:43:51] <swgillespie> h
[04:44:53] *** Joins: bjz (bjz@moz-puppgq.tpgi.com.au)
[04:45:15] <scott> I wrote a crappy stack language which compiled to LLRM IR that allocated a data stack with malloc and then just called each function with a mutable pointer to the stack like push(stack, 1); push(stack, 2); add(stack); print(stack);
[04:45:30] <scott> In many cases LLVM would inline everything and remove all traces of the malloc and the stack itself...
[04:45:33] <Peach> but think about this guys - what about programming on something that has no C++ compiler?
[04:45:53] <Peach> ALL you need is to implement C, and you get this full C++ replacement language to work with
[04:46:00] <swgillespie> that's true
[04:46:17] <swgillespie> but if you want cross-platform you can target the JVM :P
[04:46:34] <Havvy> swgillespie:  Or JavaScript. ;)
[04:46:49] <Peach> EW EW EW EW EW EW EW
[04:46:51] <Peach> Java is no
[04:46:56] <Havvy> I'm pretty sure you can't use Java on iOS.
[04:47:04] <Peach> lightweight native speed is where it's at
[04:47:06] <swgillespie> let's write a JVM in swift
[04:47:17] <swgillespie> Peach: hotspot is really impressive
[04:47:29] <Peach> No, I want 0 overhead
[04:47:40] <Havvy> swgillespie:  Still wouldn't be allowed on iOS. It's about politics, not feasability.
[04:47:44] <swgillespie> :(
[04:48:23] <Peach> I want a simple language that's much cleaner than C and lets you do zero cost abstractions - and ALL you need is to have a C compiler and you get a full C++ replacement
[04:49:54] <aatch> Isn't gcc written just in C?
[04:50:00] <swgillespie> gcc needs a C++ compiler now
[04:50:51] <aatch> Still, I can't think of a realistic situation where I'd have access to a C compiler, but not gcc.
[04:52:04] <eddyb> are we talking bootstrapping? :P
[04:52:35] <eddyb> cross-compilers are a wonderful thing
[04:53:27] <eddyb> any rustc binary can generate ARM or MIPS code, even if it has no matching libraries
[04:54:45] <scott> Compiling for NDS was surprisingly easy.
[04:55:35] <scott> The main problem is needing to use the cross-compilation toolchain's linker.
[04:58:06] <Peach> If I wanted to make an ENTIRE OS
[04:58:20] <Peach> I can feasibly build with a high level language
[04:58:30] <Peach> because the high level language compiles to C
[04:59:03] <Peach> so I'd have a nice ABI, and a nice high level language that's easy to program
[04:59:21] <Peach> So it'd be the ultimate high level toolkit if I wanted to make my own computer and everything from scratch
[05:00:14] <Peach> WOW IMAGINE how much more efficient an OS could be if it was built from the ground up with a statically analyzed programming language?
[05:01:02] <swgillespie> C can be statically analyzed :P
[05:01:13] <aatch> I seriously doubt it would make a difference.
[05:02:02] <Peach> swgillespie: no I mean built from the ground up
[05:02:22] <Peach> Unix etc didn't have quality static analyzers in the 70s :P
[05:02:38] <swgillespie> how would you build your language from the ground up to be statically analyzed?
[05:03:17] <swgillespie> or, I guess i mean
[05:03:17] <Peach> swgillespie -  That's a vague question that I can only really answer knowing how specific you want me to answer :P
[05:03:24] <Peach> you mean...?
[05:03:25] <swgillespie> what is the quality of "statically analyzable"
[05:03:40] <Peach> 1) No undefined behavior
[05:03:42] <swgillespie> because it sounds like it's straying dangerously close to the halting problem
[05:04:09] <swgillespie> if you have no UB, what happens when you dereference a null pointer?
[05:04:23] <Peach> the language wouldn't let you
[05:04:27] <Peach> Wait swgillespie 
[05:04:38] <aatch> Peach, Undefined behaviour actually increases performance by allowing compilers to assume that certain things can't happen.
[05:04:38] <Peach> why are you asking , you should know about Rust :P
[05:04:39] <c74d> Preceding question: does the language permit null pointers?
[05:05:09] <swgillespie> Peach: because it is still UB to dereference a null pointer in Rust
[05:05:47] <Peach> What actually happens when you deref a null pointer anyway?
[05:05:52] <swgillespie> Peach: undefined!
[05:05:56] <swgillespie> that's the point
[05:05:57] <Peach> It's "undefined" but in practice what happens
[05:06:05] <Peach> what *can* happen?
[05:06:10] <aatch> Peach, depends on the platform.
[05:06:33] <Peach> Does anyone ever need to null dereference a pointer?
[05:06:35] <aatch> Peach, normally the zero-page is unmapped/unmappable so you juse segfault.
[05:06:44] <aatch> just*
[05:07:09] <Peach> Oh, well in that case I don't see why the language should ever let you do that if the compiler knows better
[05:07:25] <swgillespie> there are some cases where the compiler can't know better
[05:07:44] <XMPPwocky> iirc early on in the x86 boot process there's something important mapped at 0x00000000
[05:09:25] <Mutabah> Yeah, the IVT
[05:09:32] <Mutabah> (Interrupt Vector Table)
[05:24:14] *** Quits: Astraea (uid97426@moz-g14hd0.ealing.irccloud.com) (Quit: Connection closed for inactivity)
[05:40:26] *** Joins: rootnode (rootnode@moz-go1ut4.ip1.george24.com)
[05:43:45] *** Quits: stl (stl@moz-al5.8pf.15.176.IP) (Ping timeout: 121 seconds)
[05:45:25] <Peach> In IRC, can you join channels that don't begin with #   ?
[05:45:29] <Peach> like   @rust  ?
[05:45:43] *** Joins: stl (stl@moz-al5.8pf.15.176.IP)
[05:45:46] <Peach>  /join @rust
[05:45:52] <Peach> Is that even possible?
[05:45:56] <Peach> in IRC?
[05:46:13] <scott> Short answer, no. Long answer, some IRC servers might have special channels with different prefixes.
[05:46:37] <Peach> but I'm in @rust right now
[05:46:57] <aatch> Peach, no you're not.
[05:47:18] <scott> (it went to #@rust)
[05:47:21] <Yurume> Peach: in this particular network, # is the only possible channel type.
[05:47:31] <Peach> Oh haha
[05:47:49] <Peach> So I guess my IRC client just adds # to it
[05:48:25] <Peach> I was all excited :P HAHAHAH
[05:48:54] <aatch> In the IRC protocol, there's no distinction between private messages and channel messages.
[05:49:03] <aatch> It's just based on the target of the message.
[05:50:31] <scott> Yeah, we're actually constantly "PRIVMSG"ing the channel... IRC makes a lot of sense...
[05:51:04] * Yurume is seriously proposing a proper binary (yet self-describing) protocol directly derived from IRC
[05:51:33] <Yurume> seriously, the symbol-whitespace-letter confusion in IRC protocol is just lame
[05:52:05] <scott> A simple binary protocol would be nice. I don't buy IRC being easier to hack because it's text.
[05:52:18] <scott> Parsing well-designed binary formats can be much easier.
[05:53:45] <Yurume> scott: I think the argument may work for HTTP because, conceptually, both HTTP request and response is a simple preamble plus almost-free-form key-value dictionary plus unconstrained binary. IRC somehow tried to follow that format (e.g. :-prefixed "long" argument) but it didn't work well..
[05:54:34] <Yurume> in the other words, HTTP format is almost free-form in terms of type and IRC message is not.
[05:55:36] <scott> I'm going to try my hand at some server and client stuff in Rust soonish. It seems like the kind of thing Rust should be good at.
[05:55:52] <scott> If it's not, I might switch to contributing to libraries until it is...
[05:57:28] <aatch> scott, contribute to libraries trying to make Rust good at it!
[05:57:41] <scott> Yeah, that's the plan
[05:58:06] <aatch> scott, good man
[05:58:59] <scott> I'm really interested in working on Rust professionally once I'm through with my current internship and my final year of uni. So I'm going to be looking for ways to be useful...
[06:02:17] *** Quits: aatch (james@moz-i1k1ks.tlms.2o1v.e006.2406.IP) (Quit: Leaving)
[06:18:09] *** Quits: Diggsey (diggsey@moz-honmm4.dsl.pipex.com) (Ping timeout: 121 seconds)
[06:25:10] *** Quits: genbattle (genbattle@moz-4v0.gkd.16.182.IP) (Ping timeout: 121 seconds)
[06:47:54] <Peach> There needs to be a new IRC
[06:48:07] <Peach> it should support unicode
[06:48:18] <Peach> and rich content
[06:48:33] <Peach> like markup!
[06:48:50] *** Joins: neals (neals@moz-4ljbok.austtx.sbcglobal.net)
[06:50:54] <Mutabah> 2 Like this?
[06:51:54] <XMPPwocky> 11N10Ì0212Ì1306Ì0405Ì0708Ì0903Ì1011Ì1202Ì0613Ì0504Ì0807o03Ì0911Ì1002Ì1213Ì0604Ì0507Ì0809Ì0310Ì1112Ì0206Ì1305,,04Ì0807Ì0309Ì1110Ì0212Ì1306Ì0405Ì0708Ì0903Ì1011Ì1202Ì0613Ì0504Ì0807Ì0309Ì1110Ì0212Ì1306Ì0405Ì0708Ì09 10Ì1112Ì0206Ì1305Ì0408Ì0703Ì0911Ì1002Ì1213Ì0604Ì0507l08Ì0903Ì1011Ì1202Ì0613Ì0
[06:52:01] <XMPPwocky> oh god
[06:52:04] <XMPPwocky> that didn't work
[06:52:08] <XMPPwocky> ansi control characters break up utf-8
[06:52:17] <XMPPwocky> poorly coded irssi scripts don't know about utf-8
[06:52:18] <XMPPwocky> :(
[06:53:32] <Peach> Maybe IRC as it is is fine
[06:53:44] <Peach> Not enough people can be trusted with power :P
[06:53:51] <leftylink> 11,11I12,08 04,12h08,04e12,08a04,11r13,12d00,11 12,00w09,08e04,04 08,00w13,09e11,04r12,08e13,00 12,04u13,08s09,13i00,09n11,13g09,08 04,09c12,04o00,09l04,11o00,04r11,08s
[06:54:12] * XMPPwocky 04t05h07i08n09k03s 11s12c02i06e13n05c04e 07h03a09s 10g02o12n13e 04t05o07o 09f03a10r
[06:54:34] <XMPPwocky> there's somebody out there with a misconfigured xterm without colors, and they're very confused right now
[06:58:32] <Peach> So
[06:58:37] <Peach> linux has problems
[06:58:43] <Peach> User experience problems
[06:58:46] <Peach> http://cdn.intertech.com/Blog/wp-content/uploads/2014/01/7_printer-problems.jpg
[07:03:38] *** Quits: blue_deref (blue_deref@moz-eqnijv.res.rr.com) (Quit: bbn)
[07:13:55] <Peach> WAHOOOOOOO
[07:14:31] *** Quits: Peach (Fancy3D@moz-500.6lb.246.96.IP) (Client exited)
[07:18:05] *** Quits: swgillespie (swgillespie@moz-rn1.vmq.232.104.IP) (Quit: My MacBook Pro has gone to sleep. ZZZzzzâ€¦)
[07:23:58] *** Joins: Astraea (uid97426@moz-g14hd0.ealing.irccloud.com)
[07:26:39] *** Quits: erickt (erickt@moz-pqs.0ej.162.69.IP) (Ping timeout: 121 seconds)
[07:33:00] *** Quits: neals (neals@moz-4ljbok.austtx.sbcglobal.net) (Ping timeout: 121 seconds)
[07:35:22] <Murarth> Made the mistake of getting of them non-printing printers, eh?
[07:35:28] <Murarth> Always gotta read the fine print, you know.
[07:37:44] *** Joins: neals (neals@moz-4ljbok.austtx.sbcglobal.net)
[07:38:01] *** Joins: tyoverby (tyoverby@moz-022d0n.5757.jufb.0602.2601.IP)
[07:40:24] *** Joins: red75prime (Mibbit@moz-1ek.rmk.186.188.IP)
[07:55:18] *** Joins: genbattle (genbattle@moz-v5t52g.xtra.co.nz)
[07:59:43] <Manishearth> I think I've gotten a similar error once, but that's because I had been messing with my drivers and I think it was trying to print to my keyboard
[08:05:32] *** Joins: nukep (nukep@moz-13k.mbs.64.184.IP)
[08:26:24] *** Quits: eddyb (eddyb@moz-4eq.0ja.26.188.IP) (Connection closed)
[08:39:51] *** Joins: erickt (erickt@moz-1mb.0ej.162.69.IP)
[08:39:51] *** ChanServ sets mode: +o erickt
[08:44:51] *** Quits: erickt (erickt@moz-1mb.0ej.162.69.IP) (Ping timeout: 121 seconds)
[08:50:02] *** Joins: Lilly (Lilly@moz-pfkvo9.bredband.comhem.se)
[08:50:58] *** Joins: eddyb (eddyb@moz-qfi.dmj.25.188.IP)
[08:51:13] <eddyb> nmtui-connect is a thing now, apparently
[08:55:06] *** Quits: genbattle (genbattle@moz-v5t52g.xtra.co.nz) (Ping timeout: 121 seconds)
[09:13:19] <eddyb> http://carlcheo.com/wp-content/uploads/2014/12/which-programming-language-should-i-learn-first-infographic.png
[09:13:33] <eddyb> it's missing Rust
[09:13:38] <eddyb> to round it a bit :D
[09:22:45] *** Quits: neals (neals@moz-4ljbok.austtx.sbcglobal.net) (Ping timeout: 121 seconds)
[09:27:03] <fkaa> "JavaScript â€“ frequently underestimated"
[09:27:08] <fkaa> ;_;
[09:27:35] <fkaa> and java is as hard to learn as c?
[09:33:41] <eddyb> lol
[09:40:32] <Mutabah> "Play-Doh -> Ruby"
[10:01:54] *** Joins: psd_ (psd@moz-fe0qhk.mtnl.net.in)
[10:05:10] *** Quits: psd (psd@moz-1r6g79.mtnl.net.in) (Ping timeout: 121 seconds)
[10:14:27] <ChrisMorgan> mitsuhiko: I was just going over my open PRs on GitHub, the oldest one remaining is on a repository of yours: https://github.com/mitsuhiko/classy/pull/4
[10:34:14] *** Quits: Astraea (uid97426@moz-g14hd0.ealing.irccloud.com) (Quit: Connection closed for inactivity)
[10:40:59] *** Joins: erickt (erickt@moz-1mb.0ej.162.69.IP)
[10:40:59] *** ChanServ sets mode: +o erickt
[10:45:42] *** Quits: erickt (erickt@moz-1mb.0ej.162.69.IP) (Ping timeout: 121 seconds)
[10:49:10] *** Quits: tyoverby (tyoverby@moz-022d0n.5757.jufb.0602.2601.IP) (Ping timeout: 121 seconds)
[10:58:17] * Zoxc wonders why networkmanager decided to stop using eth0...
[11:12:25] * Manishearth is cloning PCs
[11:12:40] <Manishearth> I have like twenty laptops all enatly arranged in front of me
[11:12:50] <Manishearth> and they're all doing networky disky stuff
[11:12:52] <Manishearth> glorious
[11:13:30] <Manishearth> look on my laptops, and dispair
[11:13:52] <eddyb> despair?
[11:13:55] <mrmonday> sounds like fun
[11:15:35] <mrmonday> also, I just encountered what I think is my favourite rust newbie problem - https://gist.github.com/silvio/7830760f627eb28ba2d8
[11:15:48] <mrmonday> "why does it print 0, but it calculates it right?"
[11:16:11] <mrmonday> took me a few minutes to spot the missing &'s on the self parameters
[11:18:24] <Manishearth> eddyb: despair, yes
[11:38:39] *** Joins: Tobba (Tobba@moz-o13d22.bredband.telia.com)
[11:44:30] * ChrisMorgan wonders what type of mystical arrangement an enat arrangement is
[11:57:43] <eddyb> ChrisMorgan: extreme NAT?
[11:57:59] <eddyb> a binary tree of routers
[11:58:12] <ChrisMorgan> eddyb: nah, you canâ€™t make an extreme NAT with only twenty laptops.
[11:58:28] <ChrisMorgan> I figure you need at least a few hundred thousand before itâ€™d be extreme.
[11:59:04] *** Joins: Sho (sho@moz-kkt.lcj.28.5.IP)
[12:03:06] <mrmonday> this is what makes it extreme: http://www.fiftythree.org/etherkiller/img/etherkiller.jpg
[12:03:18] <mrmonday> turbocharged
[12:07:57] *** Quits: Lilly (Lilly@moz-pfkvo9.bredband.comhem.se) (Quit: bajs)
[12:21:30] *** Quits: Romster (Romster@moz-4g83e8.rev.eftel.com) (Ping timeout: 121 seconds)
[12:24:15] *** Joins: Romster (Romster@moz-4g83e8.rev.eftel.com)
[12:41:44] *** Joins: erickt (erickt@moz-pqs.0ej.162.69.IP)
[12:41:45] *** ChanServ sets mode: +o erickt
[12:43:03] *** Quits: CarlColglazier (carlcolglaz@moz-d077lm.res.rr.com) (Connection closed)
[12:46:27] *** Quits: erickt (erickt@moz-pqs.0ej.162.69.IP) (Ping timeout: 121 seconds)
[12:47:58] *** Joins: CarlColglazier (carlcolglaz@moz-d077lm.res.rr.com)
[12:48:57] <Quxxy> mrmonday: Oh, that's this "ethernet over power" thing I've heard about, right?
[12:52:47] <mrmonday> it's next gen
[12:52:59] <mrmonday> even better than power over ethernet or powerline ethernet
[12:53:20] <mrmonday> just puts the power directly into the ethernet and vice versa
[12:59:21] *** Joins: pczarn (piotr@moz-9un7t9.izacom.pl)
[13:01:05] *** Quits: nukep (nukep@moz-13k.mbs.64.184.IP) (Quit: Leaving)
[13:36:42] <Tobba> and cargo is down, again
[13:36:44] <Tobba> I fucking give up
[13:36:58] <Tobba> crates.io*
[13:37:56] <Tobba> *every* single time I've come back to this project and tried to compile it I've had to fight cargo for hours
[13:38:28] <Havvy> !crate serde
[13:38:29] <rustbot> serde (0.4.3) - A generic serialization/deserialization framework -> https://crates.io/crates/serde
[13:38:37] <Havvy> ^^ That's a lookup to crates.io
[13:40:34] <Tobba> I'm getting TLS failures when actually trying to download stuff
[13:56:26] *** Joins: erickt (erickt@moz-pqs.0ej.162.69.IP)
[13:56:26] *** ChanServ sets mode: +o erickt
[14:01:06] *** Quits: erickt (erickt@moz-pqs.0ej.162.69.IP) (Ping timeout: 121 seconds)
[14:01:14] *** Joins: RCIX (RCIX@moz-7omm6s.ph.cox.net)
[14:18:03] *** Quits: det (chris@moz-q2ed1r.lv.cox.net) (Connection closed)
[14:18:23] *** Joins: det (chris@moz-q2ed1r.lv.cox.net)
[14:29:28] <Tiffany> huh
[14:29:45] <Tiffany> Carmack said that WiFi retransmits and acks packets at the link layer
[14:30:00] <Tiffany> is that why my latency varies so much when I try ICMP pings?
[14:30:04] <Tiffany> instead of just dropping
[14:30:24] * Elainemo doesn't know anything about 802.11
[14:32:50] <mrmonday> looks likely, based on a quick skim of the headers
[14:33:36] <mrmonday> given that ICMP sits on top of it, any retrying at the lower level would introduce variable latency for the pings
[14:34:11] <mrmonday> I wonder if anyone's written a L2 ping tool for wifi
[14:34:34] <Tiffany> I do have variable latency in pings
[14:34:56] <Tiffany> I guess the reason it does that is because packet loss has such a huge effect on TCP's congestion algorithm?
[14:35:06] <Tiffany> TCP is built on the assumption that packet loss means congestion...
[14:35:46] <Tiffany> I ran ping for a minute
[14:35:48] <Tiffany> rtt min/avg/max/mdev = 1.562/6.653/86.949/14.756 ms
[14:36:46] <Elainemo> rtt min/avg/max/mdev = 38.109/43.362/50.766/4.080 ms
[14:37:14] <Tiffany> well, that is to my router
[14:37:24] <Tiffany> internet is usually between 100 and 300...
[14:37:40] <Elainemo> sure but the deviation should be comparable
[14:37:55] <Elainemo> my laptop and my phone are the only devices on the network right now, and it's a rural area so the channel is probably pretty clear besides my wap
[14:38:09] <Tiffany> I'm in a rural area but there's something like 20 devices on this network
[14:38:52] <mrmonday> I doubt TCP is the reason for it, I think it's more likely due to the huge amount of interference you get with wifi
[14:39:11] <mrmonday> TCP has only recently started running well over wifi, and it still has problems
[14:39:49] <mrmonday> you got me curious, so I'm skimming the spec :L
[14:41:44] <mrmonday> so not all frames need an ACK
[14:43:20] <mrmonday> and most of the retransmission stuff seems to be when different APs have collided, so doing a CDMA kinda thing
[14:43:52] <mrmonday> so my guess is most L2 retransmission would occur due to the channel being congested, rather than anything else
[14:51:45] *** Joins: erickt (erickt@moz-1mb.0ej.162.69.IP)
[14:51:45] *** ChanServ sets mode: +o erickt
[14:52:17] *** Joins: eddyb_ (eddyb@moz-kh3.eg8.166.109.IP)
[14:57:40] *** Quits: eddyb_ (eddyb@moz-kh3.eg8.166.109.IP) (Ping timeout: 121 seconds)
[14:59:59] *** Joins: niconii (nicole@moz-944tjf.frgo.qwest.net)
[15:15:42] <Tiffany> http://blogs.msdn.com/b/oldnewthing/archive/2015/07/28/10631038.aspx
[15:16:23] <Tiffany> mrmonday: maybe the reason for it is that detecting and retransmitting a dropped packet over a wifi link is far faster than having to wait for the endpoint on the other end of the internet
[15:17:03] <Tiffany> I mean, the numbers I have average out at a couple milliseconds between resends
[15:17:05] <Tiffany> as opposed to 100
[15:26:51] <Quxxy> http://www.news.com.au/lifestyle/real-life/sausage-addicted-kookaburra-too-fat-to-fly/story-e6frflri-1225872729208
[15:27:07] <Elainemo> lol?
[15:34:18] *** Joins: blue_deref (blue_deref@moz-eqnijv.res.rr.com)
[15:41:04] *** Joins: Diggsey (diggsey@moz-ulabqt.dsl.pipex.com)
[15:50:08] *** Joins: dfockler (dfockler@moz-etoj16.hfc.comcastbusiness.net)
[17:00:34] *** Joins: tyoverby (tyoverby@moz-6j5btl.5757.jufb.0602.2601.IP)
[17:02:05] *** Quits: FreeFull (freefull@moz-ebnh10.range109-153.btcentralplus.com) (Quit: BBS)
[17:17:46] *** Joins: duncan (pwoolcock@moz-09nfgc.static.qwest.net)
[17:18:01] *** Quits: blue_deref (blue_deref@moz-eqnijv.res.rr.com) (Quit: bbn)
[17:24:19] *** Joins: FreeFull (freefull@moz-ebnh10.range109-153.btcentralplus.com)
[17:24:56] *** Joins: brson (brson@moz-cfhap5.mtv2.mozilla.com)
[17:24:57] *** ChanServ sets mode: +o brson
[17:27:19] *** Joins: Astraea (uid97426@moz-g14hd0.ealing.irccloud.com)
[17:28:20] <niconii> hrmmmm
[17:28:43] <niconii> the more i think abuot how to go about implementing a forth in rust, the less confident i am about how to go about it
[17:30:41] <niconii> my first thought was to allocate everything on the heap, but i'm not sure how to go about freeing it afterward
[17:31:04] <niconii> the other thing is, not having contiguous memory raises some problems
[17:32:37] <niconii> but i can't just have a giant Vec<u8> because i can't have it move on me; reallocs would be bad because i'll have a *lot* of pointers in that Vec which are pointing to other parts of the same Vec...
[17:32:43] <fkaa> niconii: what is forth implemented in?
[17:32:50] <fkaa> reference implementation or similar
[17:33:03] <niconii> there's several forths out there, but traditionally, bare-metal asm
[17:33:04] <huon> niconii: one can store indices instead of actual pointers
[17:35:06] <niconii> huon: that is true, but i also need pointers to actual asm functions; i could just not allow making new asm functions on runtime, but that does stunt it a little
[17:36:33] *** Joins: neals (neals@moz-4ljbok.austtx.sbcglobal.net)
[17:37:12] <niconii> ...though i kinda doubt the OS would even let me execute functions on the heap anyway, so i guess that might be a moot point >_>
[17:37:33] <Astraea> not with that attitude it won't
[17:37:35] <Elainemo> niconii: oh it sure will.
[17:37:48] <Elainemo> at least on most OS's, stock.
[17:39:10] <niconii> hmmm
[17:39:23] <Elainemo> you need to use mmap directly though
[17:39:26] <Elainemo> or the equiv. on window
[17:39:27] <Elainemo> s
[17:39:44] *** Quits: psd_ (psd@moz-fe0qhk.mtnl.net.in) (Quit: Leaving)
[17:40:23] <huon> niconii: something something tagged pointers
[17:40:25] <huon> maybe
[17:41:37] <niconii> well... i think i'll just go with indices and take the flexibility hit, i don't think i'll be doing anything that crazy anyway
[17:41:53] <huon> but crazy stuff is the best stuff
[17:47:34] *** Joins: killercup (killercup@moz-f6o3r9.dip0.t-ipconnect.de)
[17:49:10] <niconii> ...especially because it just dawned on me that it'll be a *little* difficult to have an assembler inside forth when i have no idea what registers rust might be using :D
[17:49:55] <niconii> yeah i suppose this is another reason you usually write these in asm
[17:55:45] *** Quits: santiago (santiago@moz-ro2mm9.res.rr.com) (Ping timeout: 121 seconds)
[17:56:07] <niconii> that is, write forths in asm
[17:56:27] *** Quits: Quxxy (chatzilla@moz-efh10q.internode.on.net) (Ping timeout: 121 seconds)
[17:56:35] <Tiffany> http://newsroom.intel.com/community/intel_newsroom/blog/2015/07/28/intel-and-micron-produce-breakthrough-memory-technology
[17:57:09] <Tiffany> there is extremely little concrete information available, but it looks like intel is currently in production of fancy new storage that's almost as fast as DRAM
[17:57:25] <Tiffany> they might beat HP to the mark
[17:57:28] <Tiffany> on viable NVRAM
[17:58:53] *** Joins: santiago (santiago@moz-ro2mm9.res.rr.com)
[17:59:18] <Tobba> Tiffany: I like the "Posted by IntelPR"
[17:59:48] <Tiffany> yeah...
[17:59:53] <Tiffany> it is 100% PR
[18:00:19] <Tiffany> they give exactly zero useful information, just saying it's 1000x faster than flash and the infographic says it's slower than DRAM but not by how much
[18:00:55] <Tobba> it's pretty hard to max out current SSDs anyways, I just want the density
[18:01:07] <Tiffany> I want NVRAM
[18:01:36] <Tiffany> I want to build a capability-based transactional persistent OS using NVRAM
[18:02:54] <Tiffany> it's kind of sad how you don't typically want to run a database off an SSD because of the relatively low write endurance
[18:03:04] <Tiffany> so this has that other benefit
[18:03:14] <Tiffany> they say it's a thousand times more durable
[18:03:31] <Tiffany> you could run a ridiculously fast database off it, if it's real
[18:03:45] <Tiffany> I feel like something about it is too good to be true, since they aren't giving out any data sheets
[18:03:45] <Tobba> I'd guess those numbers are the absolute peak
[18:05:21] <Tobba> Tiffany: don't modern SSDs last like ~1 year of being written as fast as possible all day?
[18:05:37] <Elainemo> no, way more.
[18:05:40] <Tiffany> it varies based on the brand, iirc
[18:05:46] <Tiffany> I saw some article torture testing SSDs...
[18:05:48] <Elainemo> http://techreport.com/review/27909/the-ssd-endurance-experiment-theyre-all-dead
[18:05:52] <Tobba> yeah iirc that was on samsung disks
[18:06:02] <Tobba> let's see then
[18:08:15] <Tiffany> it looks like the last drive died after 18 months?
[18:08:23] <Tiffany> of perpetual torture testing
[18:08:37] <Tiffany> 2.5 PB of writes..
[18:08:43] <Tobba> I thought the samsung drive would do the worst, considering they do some slightly questionable stuff to get the costs down iirc
[18:10:03] *** Quits: erickt (erickt@moz-1mb.0ej.162.69.IP) (Ping timeout: 121 seconds)
[18:10:20] *** Joins: pcwalton (pcwalton@moz-l8ebtf.sfo1.mozilla.com)
[18:12:30] <Elainemo> oh hey my republic wireless plan went down to $10/mo.
[18:12:31] <Elainemo> swag
[18:12:49] <Elainemo> I guess it's $13.43/mo with taxes and stuff.
[18:14:21] <niconii> hrmmm, yeah, writing a forth that isn't self-hosting, especially when not writing it in asm, just feels incredibly messy
[18:15:30] <niconii> rather than writing this in rust, maybe i'll just write it in asm
[18:15:48] <niconii> but rather than doing it for x86, it'd be interesting to write it for something else
[18:16:01] <Tobba> Tiffany: I think having an SSD in a DB server would probably pay off if it can handle 2PB
[18:16:10] <Tiffany> yeah
[18:16:13] <Tobba> even if it fails after a few years it'd reduce other HW costs
[18:16:14] <Tiffany> there's a lot of FUD around it
[18:16:29] <Tobba> although samsung drives in servers tend to be a bad idea due to the horrific firmware
[18:16:56] *** Joins: erickt (erickt@moz-1mb.0ej.162.69.IP)
[18:16:56] *** ChanServ sets mode: +o erickt
[18:17:41] <Tobba> (I think most famously is various bad interactions with RAID controllers)
[18:18:05] <Tobba> oh and the fact that they would corrupt data on linux because samsung are fools
[18:18:48] <niconii> hmm, so, anyone have some hardware suggestions it'd be interesting to write a forth for?
[18:19:22] <niconii> the amiga comes to mind since i did download an emulator for that recently...
[18:19:48] <niconii> the snes also comes to mind... it has no keyboard peripherals or anything though
[18:20:33] <Elainemo> niconii: RISC-V!
[18:24:35] <niconii> Elainemo: hmm, what about the hardware that goes around that, though?
[18:25:34] <Elainemo> niconii: the software emulator in qemu is completish.
[18:25:44] <Elainemo> in terms of, "it can boot linux and has a serial console"
[18:26:05] <Tiffany> tobba: also, what do you mean HW costs?
[18:26:25] <Tiffany> afaik you can't run most SQL servers across multiple machines
[18:26:27] <niconii> hrmmm, well, the goal would be to run bare-metal, so linux's gotta go
[18:26:42] <Tiffany> except FoundationDB, which is now dead, and possibly Apache Cassandra
[18:26:47] <Tiffany> and some others I don't know about
[18:26:58] <niconii> feels kinda finicky...
[18:27:16] <Tiffany> I wonder how you scale SQL
[18:27:57] <Astraea> I'm still waiting for m.2 storage servers
[18:27:57] <dfockler> hadoop
[18:28:14] <Tiffany> apparently MSSQL does scaling
[18:28:23] <dfockler> what does that mean?
[18:28:26] <Astraea> incredibly tiny form factor, only limit is PCIe lanes
[18:28:29] <Tiffany> shared SAN database, peer to peer replication
[18:28:38] <Elainemo> niconii: right but it *does* have a serial port
[18:28:55] <Astraea> actually, I'm incredibly surprised it isn't a thing yet
[18:31:04] *** Quits: neals (neals@moz-4ljbok.austtx.sbcglobal.net) (Ping timeout: 121 seconds)
[18:31:28] <Elainemo> Tiffany: wait, what? postgres and mysql both have clustering and replication.
[18:31:36] <Elainemo> sharding is like, super old.
[18:31:42] <Tiffany> I didn't know about it
[18:31:51] <Tiffany> does it hurt performance? it seems like it would
[18:32:05] <Elainemo> depends on the access pattern
[18:32:17] <Elainemo> but if you know the access pattern you can usually make it fast.
[18:33:12] <Tiffany> M.2 SSDs are tiny
[18:33:27] <Astraea> yup
[18:34:02] <Astraea> aside from the PSU and fans, everything can be on the motherboard
[18:34:45] *** Quits: dfockler (dfockler@moz-etoj16.hfc.comcastbusiness.net) (Connection closed)
[18:35:26] <Astraea> though... I doubt they're very hot swappable
[18:37:10] <Tiffany> huh, these can be used for more than just SSDs?
[18:37:27] <Astraea> m.2? yeah
[18:37:32] <Tiffany> PCIe, USB, audio, and other stuff
[18:38:19] <Tobba> Tiffany: MySQL supports some form of replication system
[18:38:24] <Tobba> (afaik, never used it)
[18:38:40] <Tiffany> I've only really ever used sqlite
[18:38:49] <Tiffany> which has none of this
[18:39:11] <Tiffany> well, you can link databases together, but you have to partition your data across them
[18:39:21] <Elainemo> sqlite isn't a database server :P
[18:39:21] <Tiffany> and it's kind of tricky to use
[18:39:34] <Elainemo> it's excellent in its space, but that isn't its space.
[18:40:40] <Tiffany> yeah
[18:44:08] *** Quits: FreeFull (freefull@moz-ebnh10.range109-153.btcentralplus.com) (Quit: BBS)
[18:54:51] *** Joins: FreeFull (freefull@moz-ebnh10.range109-153.btcentralplus.com)
[18:57:50] *** Joins: Peach (Fancy3D@moz-500.6lb.246.96.IP)
[18:59:41] *** Quits: erickt (erickt@moz-1mb.0ej.162.69.IP) (Ping timeout: 121 seconds)
[19:01:25] *** Joins: eerie (eerie@moz-23apr7.red.bezeqint.net)
[19:01:29] <Peach> How come computers couldn't lie and say      x/0  equals 0?
[19:01:37] <Peach> so there's no arithmetic crashes :P
[19:02:10] <Elainemo> they could.
[19:02:23] <Elainemo> turns out writing numerical code prefers the crash.
[19:03:13] <Elainemo> in your implementation you could return zero instead of crashing.
[19:04:49] *** Joins: neals (neals@moz-4ljbok.austtx.sbcglobal.net)
[19:05:36] *** Quits: eerie (eerie@moz-23apr7.red.bezeqint.net) (Ping timeout: 121 seconds)
[19:07:19] <Astraea> Peach: the same reason they don't lie and say true && false == true
[19:07:47] <Peach> Astraea: no that's a different comparison, I'm talking about preventing crashes
[19:07:59] <Peach> an if statement like that wouldn't crash
[19:08:03] <Peach> but x/0 would
[19:08:22] <Astraea> right, but x/0 being equal to zero would be very surprising and make about as much sense as true && false == true
[19:09:16] <Peach> Astraea: crash semantics is the only thing I'm talking about here :P
[19:09:41] <Peach> 0.0/0 doesn't crash for example
[19:10:02] <Astraea> I'd be more worried about the principle of least astonishment
[19:10:03] <Elainemo> it can if you set the floating point environment to generate signaling NaNs.
[19:10:14] <Elainemo> otherwise it makes a quiet NaN that propagates.
[19:10:24] <Elainemo> has the same purpose as crashing: signal a logic eror.
[19:10:26] *** Joins: Lilly (Lilly@moz-pfkvo9.bredband.comhem.se)
[19:11:44] <Elainemo> or rather, to generate exceptions on signaling nans
[19:11:58] <Elainemo> the worst part about NaN is that it reminds me of naan
[19:12:08] * Peach STILL can't get floating point Nans to be a hard run time error in C++ :(
[19:12:35] <Peach> int/0 crashes reliably but I can't *easily* make  float/0 do the same
[19:12:39] <Elainemo> added in c++11: http://en.cppreference.com/w/cpp/numeric/fenv
[19:14:34] <Elainemo> what is "easily"? you just need to call one function (feenableexcept with glibc, or using the C++11 extension)
[19:15:26] <Astraea> And really if you're only worried about crash semantics then you can justify other weird things. Like printing hello kitty ascii art to the console rather than crashing when you use a null ptr
[19:15:53] <Peach> Oh wow it's only 1 function to enable it?
[19:16:06] <Elainemo> I gave you code that worked last time you brought it up :(
[19:16:21] <Peach> @_@
[19:17:17] <Peach> I still wish the C99/CPU designers/whoever  would have made numerical division:    int/0 and float/0  have the same crash behavior by default
[19:17:31] * Peach attempts to enable floating point exceptions
[19:19:34] <Peach> Astraea: I'd actually prefer a consistent crash about languages, I prefer a language that either enforces no undefined behavior or just crashes up front
[19:20:04] <c74d> Peach: you were wanting to change integer division by zero to not crash, now you're changing floating-point division by zero to crash?
[19:21:00] <Peach> c74d: oh boy, no it was an idle thought only because I was wondering why floats don't hard crash by default 
[19:21:15] <Peach> All I want is consistency
[19:22:47] <Astraea> floats don't hard crash because they can handle division by zero
[19:22:51] <Astraea> integers can't
[19:23:02] <c74d> my preferred solution would be only allowing division by numbers that the language knows can't be zero
[19:23:40] <Peach> ^
[19:23:49] <Peach> That's how I'm doing it
[19:24:12] <Tiffany> dependent types
[19:24:14] <Elainemo> Peach: by default the hardware *does* trap, it's the OS that disables it by default.
[19:24:29] <Peach> OH wow @_@
[19:24:37] <c74d> Peach: using dependent types in the compiler, or tag types in the library?
[19:24:42] <fkaa> http://puu.sh/jgnDu/145f7406b7.png
[19:24:45] <Astraea> Tiffany: how does dependent types work for user input?
[19:25:13] <Tiffany> astraea: you start out with no guarantees on the user input, and then as you perform checks (pattern matching), you slowly build values with proofs of their contents
[19:25:19] <Astraea> s/does/do/
[19:25:24] *** Joins: dfockler (dfockler@moz-etoj16.hfc.comcastbusiness.net)
[19:25:27] <Astraea> hmmm...
[19:25:34] <Tiffany> for example, if you want user input that never contains the letter 'A', you could pattern match against it and build a string which you can prove does not contain the letter A, and error otherwise
[19:25:35] <lahwran> dependt tdypes
[19:25:50] <lahwran> strongly dyped
[19:25:55] <lahwran> my dose is bleedig
[19:26:02] <Tiffany> sort of like how rust guarantees str will always be valid utf-8
[19:26:08] <c74d> lahwran: stuff it with tissue paper
[19:26:13] <lahwran> my irc nose
[19:26:15] <Tiffany> by either returning a utf-8 string or an error (or lossily converting)
[19:26:19] <Tiffany> but encoded into the type system
[19:26:23] <Tiffany> and more general
[19:26:24] * lahwran stuffs it with tissue messages
[19:26:47] <Tiffany> the guarantees you can make with str are limited by the implementation of str (it guarantees they will be utf-8, and not really anything else)
[19:26:51] <lahwran> fkaa: https://mnky.es/d/IETcpBCdEslFRuB64DFF8g/papers/mendeley%20library
[19:26:56] <Tiffany> whereas with dependant types, you can add arbitrary guarantees
[19:26:58] <WindowsBunny> lahwran: may I drink your IRC nose blood
[19:27:17] <Tiffany> I'm not entirely familiar with how it works though
[19:27:21] <fkaa> lahwran: what is this?
[19:27:28] <lahwran> my reading queue
[19:27:37] <Peach> c74d:  Oh I don't know if I'm using "dependent types" I just analyze control flow of the program and check if variables are effected by non pure input and don't have a definite range. In the case where range can't be determined, the compiler will request that the programmer adds a condition before using an integer with a possible invalid bounds
[19:27:45] <lahwran> ie, papers that I went "OOH SOUNDS FANCY" on
[19:28:46] <c74d> Peach: hm, 'k. I think that's more or less what I'd do.
[19:29:09] <c74d> (if I were actually implementing a programming language and not just talking about it)
[19:29:55] <Elainemo> Peach: https://gist.github.com/cmr/4c1f8dbf2d11b7fb55f4
[19:30:23] <Peach> YAAAAY
[19:30:41] <Peach> I'm gonna point floating point exceptions in my language by default now!
[19:31:05] <fkaa> lahwran: i have a folder for all my goodie litterature 
[19:31:33] <c74d> though in my case, most of the "compiler" is shunted into the standard library, and for this, the numeric types include their range of possible values
[19:32:22] <Peach> can anyone explain to me what dependent types are better than wikipedia can? :P
[19:32:26] <c74d> which I believe is dependent typing, just a restricted form, "numbers in the type system"
[19:33:52] <Elainemo> Peach: http://www.andres-loeh.de/LambdaPi/
[19:34:44] <Elainemo> the wikipedia description, "a dependent type is a type that depends on a value" is basically all there is to it.
[19:35:39] <lahwran> http://neverworkintheory.org/
[19:35:47] <lahwran> ^ more interesting cs stuff, more about programming than ml
[19:36:07] <scott> It lets you have things like a pair where the first item is a number n and the second is a proof that that specific number n is not zero.
[19:36:16] <scott> The type of the proof is dependent on the value n.
[19:37:00] <fkaa> lahwran: have you done any neural stuff so far?
[19:40:30] <Peach> Elainemo: depends on a value could mean anything though!      int value = 5; var x;  if (value==5) x = 0.0; else x = "text";     - The type of x "depends" on a value
[19:41:09] <scott> That's dynamic typing. x's type is either totally vague or something like "float OR stirng"
[19:41:33] <Tiffany> there's a reason people call "dynamic" typing unityping
[19:41:39] <c74d> Peach: one application might be having things like: template(x_min: number, x_max: number, [etc.]) fn multiply(x: number(x_min .. x_max), y: number(y_min .. y_max)) -> number(/* compute possible output range from input ranges */)
[19:41:45] <scott> In dependent types, a value is actually used in a type.
[19:41:48] <Tiffany> there is only one type, and it is the union of all primitives
[19:42:16] <lahwran> fkaa: yeah working on this https://github.com/lahwran/music_ml_stuff
[19:42:19] <c74d> letting you know the possible range of each number
[19:42:20] <lahwran> every morning right now
[19:42:30] <scott> fn make_array(n: usize) -> [u8; n] // This is not valid Rust, but would be an example of dependent types.
[19:42:41] <lahwran> I'm trying just plain convolutions on an audio stream, it's gonna be awful :D
[19:42:53] <lahwran> it won't even be able to learn to detect frequency
[19:42:56] <lahwran> it's gonna be great
[19:43:08] <Peach> @_@
[19:43:14] <Peach> Elainemo: you'll never guess what
[19:43:26] <Peach> My OS doesn't have feenableexcept
[19:43:28] *** Joins: eerie (eerie@moz-23apr7.red.bezeqint.net)
[19:43:34] <Elainemo> What OS?
[19:43:42] <c74d> Mac OS 10.6.
[19:43:45] <Elainemo> (I did say it was glibc specific, and the _GNU_SOURCE makes that explicit :P)
[19:43:49] <Elainemo> c74d: it lies.
[19:43:58] <Elainemo> at least Peach has said that is spoofed in the past.
[19:44:00] <lahwran> fkaa: go any cool games I can do ml with? any 3d games that I can make really badass-level-difficult mobs for?
[19:44:16] <c74d> spoofed?
[19:44:16] *** Quits: lu324 (lu324___@moz-gogein.dhcp.embarqhsd.net) (Connection closed)
[19:44:20] <fkaa> how do you mean?
[19:44:29] <lahwran> I want to do reinforcement learning for mobs
[19:45:02] <fkaa> try minecraft :)?
[19:45:08] <lahwran> but it's minecraft :(
[19:45:11] <lahwran> I was hoping you had something more fun
[19:45:16] <lahwran> 'cause you're you
[19:45:32] <lahwran> minecraft is so slow
[19:45:39] *** Parts: duncan (pwoolcock@moz-09nfgc.static.qwest.net) ()
[19:46:01] <fkaa> i'm me
[19:46:05] <niconii> Elainemo: i thought it was the reverse, Peach using 10.6 but spoofing it to look newer for some stuff
[19:46:09] <fkaa> maker of unfinished projects
[19:46:16] <Elainemo> Peach: you might just need to write some assembly.
[19:46:31] <Elainemo> the registers are easy to frob
[19:46:58] <niconii> (don't really recall the details though, and a quick grep in my logs isn't turning it up)
[19:47:10] <Elainemo> https://www.youtube.com/watch?v=FVVlkgym5cE
[19:47:13] <Elainemo> I love beats antique so much
[19:48:19] <lahwran> fkaa: it's kind of just plugging things together at this point. an ntm for dispatch, a convnet for input (pretrained on imagenet so it can see initially), drql to make it all go, and each mob would get its own reward section of the vision system
[19:48:34] *** Quits: pcwalton (pcwalton@moz-l8ebtf.sfo1.mozilla.com) (Client exited)
[19:48:47] <Peach> AAAAAAAAAAA
[19:49:00] <Peach> Elainemo: I need assembly to enable floating point exceptions? ;-;
[19:49:15] <Peach> Yeah, this definitely isn't easy ;-;
[19:49:21] <lahwran> like, the hard part there would be stability, if you can get that to be stable you'd get like cat-level intelligence or so
[19:49:39] <Tiffany> peach: the code elainemo just linked doesn't need assembly...
[19:49:56] <Peach> Tiffany: who said it worked on my OS :(
[19:50:12] <Peach> My OS doesn't have a function the code uses 
[19:50:16] <Tiffany> oh you're using the unrevealed embedded platform
[19:50:31] <lahwran> fkaa: do you know how to render minecraft from a different perspective?
[19:50:53] <lahwran> oh alternately do you know of any other minecraft implementations that could be used
[19:51:17] <fkaa> uh, change the perspective..?
[19:51:22] <fkaa> >.>
[19:51:29] <lahwran> I mean like render a mob's perspective to an offscreen buffer
[19:51:32] *** Joins: bluss (bluss@moz-rip51k.cust.bredbandsbolaget.se)
[19:51:39] <lahwran> and then move that offscreen buffer over to cuda
[19:51:54] <fkaa> yeah sure
[19:52:15] <c74d> Elainemo: Mac OS X 10.6 was what Peach told me when I was recommending them a Git GUI.
[19:52:23] *** Joins: swgillespie (swgillespie@moz-qb3.04d.220.167.IP)
[19:52:33] *** Joins: pcwalton (pcwalton@moz-l8ebtf.sfo1.mozilla.com)
[19:52:42] <Peach> I am quite secretive c74d 
[19:53:04] <Peach> I'm using an unofficial manually hacked OS build :P
[19:53:19] <c74d> ...
[19:53:26] <c74d> I'm not surprised it doesn't work then.
[19:53:38] <Peach> I'm on a legit Mac though
[19:53:41] <Peach> so it should work
[19:53:57] <c74d> The hardware doesn't define that function.
[19:54:49] <eddyb> halp
[19:54:59] <eddyb> I've just watched my first anime movies
[19:55:09] <eddyb> someone somehow convinced me
[19:55:16] <Tiffany> lahwran: spectator mode!
[19:55:34] <scott> eddyb: and?
[19:55:39] <Peach> oh no...................
[19:55:45] <niconii> eddyb: oho
[19:55:51] <niconii> eddyb: which ones?
[19:55:53] <mbrubeck> was it "Grave of the Fireflies"?
[19:56:00] <eddyb> https://en.wikipedia.org/wiki/Spirited_Away and https://en.wikipedia.org/wiki/Howl%27s_Moving_Castle
[19:56:00] <Peach> " if you do this then you'll receive the signal SIGFPE when an exception occurs which you can then catch in your debugger. Watch out though as sometimes the signal gets thrown on the floating point instruction after the one that's actually causing the problem"
[19:56:09] <scott> eddyb: Good choices.
[19:56:09] <mbrubeck> Oh, Spirited Away is awesome.
[19:56:18] <eddyb> I guess I know how they tricked me
[19:56:25] <scott> I think everything by Miyazaki is great.
[19:56:28] <niconii> ah, both ghibli
[19:56:35] <eddyb> by suggesting Contact first
[19:56:35] <Peach> Elainemo: wai
[19:56:38] <Peach> y why
[19:56:41] <scott> I haven't really watched any non-ghibli anime.
[19:56:51] <eddyb> which I liked (it wasn't anime, ofc)
[19:57:13] <Elainemo> Peach: because flags don't always get set immediately.
[19:57:17] <eddyb> I figured they had good taste. yupp. almost crying
[19:57:21] <Elainemo> I don't think it's a problem on recent hardware?
[19:57:24] <eddyb> Elainemo: you're red now q_q
[19:57:29] <Elainemo> sorryyyy
[19:57:40] <eddyb> actually, that might have been your original color
[19:57:46] <eddyb> Elaine was yellow
[19:58:10] <Peach> Does anyone even understand how difficult programing stuff is because of cross system differences :(
[19:58:15] <eddyb> what is this, each facet gets its own color :P?
[19:58:22] <Elainemo> Peach: oh believe me, we're intimately aware.
[19:58:45] *** Joins: peacememories (peacememori@moz-03ni57.dynamic.surfer.at)
[19:58:49] <Tiffany> elainemo: what's the added mo supposed to be, anyway?
[19:58:59] <Elainemo> it's a contration of "elaine nemo"
[19:59:01] <fkaa> went from yellow to green to pink for me
[19:59:03] <Tiffany> oh
[19:59:08] <c74d> Peach: people who write the libraries to abstract away those differences?
[19:59:48] <mbrubeck> Is it pronounced "ee-lay-nee-moh" then?
[19:59:53] <eddyb> Elainemo: but what does it *mean*?!
[19:59:53] <Peach> C header library is a pretty disorganized mess, and doing things like enabling floating point exceptions runs into nebulous teriory
[19:59:55] <Peach> Hey
[20:00:01] <eddyb> mbrubeck: nee-moh?
[20:00:04] <Peach> Does RUST have floating point exceptions by default?
[20:00:05] <eddyb> don't make me cry
[20:00:10] <eddyb> not Finding Nemo
[20:00:12] <Elainemo> Peach: of course not, we don't modify what the OS sets up.
[20:00:16] <eddyb> ;_;
[20:00:19] <Peach> playbot:  let x = 0/0.0; x
[20:00:20] -playbot- <anon>:9:18: 9:23 error: the trait `core::ops::Div<_>` is not implemented for the type `_` [E0277]
[20:00:20] -playbot- <anon>:9          let x = 0/0.0; x
[20:00:20] -playbot- output truncated; full output at: http://bit.ly/1SLxx9B
[20:00:26] <Tiffany> I have seen that movie so many times eddyb
[20:00:32] <Elainemo> eddyb: nemo is latin for "nobody" :3
[20:00:35] <eddyb> Peach: you tried to divide an integer 0 by a float 0
[20:00:35] <Peach> playbot: let x = 0.0/0.0; x
[20:00:36] -playbot- NaN
[20:00:42] <Peach> OH GAH
[20:00:44] <Peach> noooooooooooooooooooooooooooooo
[20:00:47] <Tiffany> it got to the point where I couldn't stand it anymore
[20:00:50] <eddyb> Peach: it's a standard
[20:00:59] <eddyb> NaN is not something JS invented or anything like that
[20:01:03] <eddyb> it's part of the hardware
[20:01:09] <Peach> It's an inconvenient standard :'(
[20:01:14] <scott> <Peach> Does anyone even understand how difficult programing stuff is because of cross system differences :(
[20:01:15] <Tiffany> it's part of the IEEE 754 floating point standard
[20:01:15] <Elainemo> No, it's really not.
[20:01:21] <delma> blame IEEE
[20:01:25] <scott> Peach: Standardized floating point helps with having less diffferences.
[20:01:28] <Peach> silent nans are the cause of many issues I'm sure
[20:01:29] <mbrubeck> Remember that a floating point value is *not* a real number. It's a range of real numbers.
[20:02:04] <Peach> I sure there are very few cases where the programmer says: Wow, I'm glad it Nans, I definitely wanted it to do that
[20:02:06] *** Quits: eerie (eerie@moz-23apr7.red.bezeqint.net) (Connection closed)
[20:02:09] <Peach> Very few cases
[20:02:13] <c74d> Peach: perhaps you'd prefer rational numbers rather than floating-point?
[20:02:18] <Astraea> just like captain nemo, Elainemo 
[20:02:20] <eddyb> mbrubeck: a finite subset, containing a number of arithmetic progressions
[20:02:53] <Peach> c74d: I just want my arthemetic to not silently generate a bad number and instead just crash upfront
[20:03:05] <eddyb> Peach: maybe the Mill will have that
[20:03:14] <eddyb> maybe x86 flags allow it already (not that I know of)
[20:03:32] <eddyb> but right now it's going to be rather expensive to check for edge cases
[20:03:42] <Tiffany> there was a lot of discussion about this in rust
[20:03:47] <Tiffany> especially integers
[20:03:58] <eddyb> integers are a different discussion entirely
[20:04:04] <Tiffany> no, it's realted
[20:04:05] <Tiffany> related
[20:04:48] <eddyb> integers aren't somewhat strictly defined in an IEEE standard, there's more design space
[20:05:06] <Astraea> integers aren't really integers as in zahlen
[20:05:10] <eddyb> Peach: most NaNs in dynamic languages come from strings anyway
[20:05:17] <Tiffany> buffer overflow, integer overflow, and floating point NaN/exceptions are all things that we want to catch quickly, but they all need expensive checks (or in the latter case, feenableexcept(3)), so there's a constant bikeshed over keeping vs losing the checks
[20:05:26] <Astraea> and floats aren't reals
[20:05:30] <Tiffany> dependent typing fixes the problem, but adds way too much overhead to using the language for most people
[20:05:47] *** Joins: erickt (erickt@moz-1mb.0ej.162.69.IP)
[20:05:47] *** ChanServ sets mode: +o erickt
[20:06:10] <eddyb> Tiffany: what's the hardware support for exceptions?
[20:06:12] <Astraea> so our intuition ends up being different from what actually is
[20:06:32] <Tiffany> I'm not sure, eddyb
[20:06:53] <eddyb> Tiffany: also, LLVM doesn't have a notion of may-modify-floating-point-flags effects
[20:07:03] <Tiffany> ugh
[20:07:08] <Elainemo> yeah the problem with floating point exceptions is that llvm is unsound.
[20:07:08] <Tiffany> floating point state flags are so dumb
[20:07:13] <Tiffany> the spec mandates that they be global variables
[20:07:14] <eddyb> which makes any flag fiddling impossible
[20:07:30] <Elainemo> I'm not sure if there is any performance inpact.
[20:07:32] <Elainemo> impact
[20:07:39] <Elainemo> it generates an interrupt on error
[20:08:07] <eddyb> I wish we used div0 instead of checking for 0 manually, but...
[20:08:17] <eddyb> actually, did I have a solution for this?
[20:09:12] <eddyb> generate landing pads as if "INTerrupt-on-Overflow" instructions (and integer DIVision) can create panics
[20:09:22] <eddyb> then the signal handler should be able to trigger unwinding
[20:10:03] <eddyb> there might have been a reason why this is stupid and pointless and will definitely not work, but if there is, I can't remember it
[20:10:15] <Peach> dependent types seem like a bad idea
[20:10:24] <Peach> they complicate compiler analysis
[20:10:44] <Elainemo> somewhat.
[20:10:50] <eddyb> the only benefit is you remove a branch that's already correctly predicted in case of success
[20:10:53] <Elainemo> they're well understood though.
[20:11:10] <Elainemo> eddyb: what's the benefit to codesize though?
[20:11:21] <Elainemo> especially if all traps go to the same landing block
[20:11:59] <eddyb> well, you're removing some tranpoline for initiating a panic, but that's about it
[20:12:11] <Elainemo> for every operation.
[20:12:12] <eddyb> they could be adding up if LLVM doesn't do cross-function BB deduplication
[20:12:42] <eddyb> well, they can't be deduplicated due to the custom location string
[20:12:48] <eddyb> (even if LLVM had the capability)
[20:12:52] <eddyb> Peach: that's... not what I expected to hear
[20:14:15] <eddyb> Peach: Rust lifetimes are a very simple form of dependent-like typing, and they have a burden on the programmer (nothing too difficult, I would say, but YMMV)
[20:14:36] <eddyb> Peach: but imagine you had to annotate everything
[20:17:43] <RCIX> wheee
[20:17:49] <RCIX> windows 10 download finished early
[20:17:53] <RCIX> banzaiiii
[20:18:56] <eddyb> I wonder if someone mentioned Contact in here a few days ago, or if it's just deja-vu
[20:20:00] <eddyb> nope, I'm imagining things
[20:21:14] <Peach> How expensive is iterating through a tree? Does the CPU not like have such random pointer memory access?
[20:22:22] <Tiffany> a cache miss costs 100-600 nanoseconds peach
[20:22:29] <scott> There's multiple ways to store a tree, so that really depends
[20:22:32] <Tiffany> and yeah
[20:22:35] <Tiffany> multiple ways to store a tree
[20:22:47] <Peach> If I just access a bunch of pointer data randomly
[20:22:48] <Tiffany> sometimes you can store all the leaf nodes in a contiguous array
[20:22:53] <Tiffany> and then iteration will be extremely fast
[20:23:07] <Peach> complete random access though?
[20:23:15] <eddyb> IIRC heaps are usually stored like that
[20:23:28] <Tobba> if they're continiguous, sure
[20:23:37] <Peach> and yeah I store leafs in contigous array, but if I call node->parent->parent->etc.  won't that be slow?
[20:23:44] <eddyb> used for priority queues, right?
[20:23:48] <Tiffany> why are you doing that?
[20:23:51] <scott> Peach: Accessing things close in memory to things you accessed recently is faster because of the cache.
[20:23:51] <Tiffany> I thought you said you were iterating?
[20:23:58] *** Quits: red75prime (Mibbit@moz-1ek.rmk.186.188.IP) (Quit: http://www.mibbit.com ajax IRC Client)
[20:24:12] <Tiffany> yeah eddyb
[20:24:25] <Peach> I don't just iterate,
[20:24:33] <Peach> to be specific I'm doing an AST
[20:24:34] <Elainemo> vam emde boas trees are cache oblivious and machine sympathetic.
[20:24:48] <Peach> and using parent-> parent-> etc  to do symbol lookup
[20:24:57] <eddyb> insert with any key, pop smallest/largest key?
[20:25:06] <eddyb> Peach: what are you storing in those trees?
[20:25:13] <Tiffany> that's what a heap is for, eddyb
[20:25:24] <eddyb> Tiffany: that's what I was trying to figure out
[20:25:33] <eddyb> I haven't used one for anything yet
[20:25:35] <Tiffany> O(log N) insert/find-min
[20:25:48] <eddyb> and cache-friendly
[20:26:06] <eddyb> (which probably counts more than the logarithm :P)
[20:26:09] <scott> And compact. You don't need pointers.
[20:26:21] <Elainemo> eddyb: there's std::collections::BinaryHeap, look at its implementation.
[20:26:49] <eddyb> Elainemo: does anything use it?
[20:26:50] <Elainemo> Peach: don't worry about the efficiency of AST traversal yet.
[20:26:57] <Elainemo> eddyb: I use it, at least :P
[20:27:26] <eddyb> Peach: what's the node and what's the parent?
[20:27:41] <Tiffany> eddyb: iirc you need about 10000 elements before log N becomes more worthwhile than cache-efficient N
[20:27:48] <eddyb> wow
[20:27:55] <Tiffany> this depends massively on what you're doing
[20:28:19] <Tiffany> like, this assumes that a cache miss is a hundred times longer than a not-cache-miss, that you do nothing in between loads, and that for the log N approach every single load is a cache miss
[20:28:20] <eddyb> so the "big" in big-O is half-way to big-Data :P
[20:28:47] <Tiffany> er
[20:28:50] <Tiffany> I screwed that up
[20:28:51] <eddyb> there should be a D(...) notation which accounts for very large amounts of data :P
[20:29:08] <huon> that's called O
[20:29:31] <eddyb> huon: O is not disruptive enough
[20:29:31] <Tiffany> log2(x) * cache-miss-time = x is the point you want to look for
[20:29:36] *** Quits: pczarn (piotr@moz-9un7t9.izacom.pl) (Ping timeout: 121 seconds)
[20:29:44] <Tiffany> well
[20:29:55] <eddyb> Tiffany: the cache miss time is not a multiplier
[20:29:56] <Tiffany> you probably want to include the cache-hit-time and add the processing time while you're at it
[20:30:01] <eddyb> you also need some unit of work
[20:30:07] <Tiffany> yeah
[20:30:35] <Tiffany> okay
[20:30:49] <fkaa> do cache misses (concept) exist in real life?
[20:30:59] <scott> In what sense?
[20:31:12] <huon> https://www.wolframalpha.com/input/?i=solve+log2%28x%29+*+100+%3D+x
[20:31:18] <Tiffany> so for a log N algorithm that is a hundred times slower than an N algorithm, you have to have a hundred elements before the log N algorithm becomes worth it
[20:31:21] <Tiffany> unless my math is wrong
[20:31:28] <c74d> fkaa: they allegedly incur major performance costs on Java
[20:31:30] <Tiffany> a thousand elements*
[20:31:50] <fkaa> scott: eg. kick a ball against a wall for an hour, suddenly ball comes after your head! reaction time and such
[20:31:50] <Astraea> big-O isn't the end-all of performance characterization
[20:31:50] <Tiffany> fkaa: they are a major factor in the performance of high-data-throughput applications like games
[20:32:02] <fkaa> yeah, i was talking about real life :p
[20:32:06] <Tiffany> aha
[20:32:10] <Tiffany> so I was right then
[20:32:15] <Tiffany> you need about a thousand elements
[20:32:25] <Tiffany> well, my second result was right
[20:32:36] <eddyb> below one element or above a thousand?
[20:32:42] <Astraea> tbh just profile
[20:32:51] <Tiffany> yeah
[20:32:53] <eddyb> Astraea: profiling doesn't always work
[20:33:01] <Tiffany> optimization without profiling is masturbation
[20:33:08] <eddyb> Tiffany: but... but....
[20:33:28] <eddyb> I like my code with no unnecessary allocations
[20:33:56] <Astraea> eddyb: it's the best tool we have when talking about performance
[20:34:50] <eddyb> well, profiling could be better, I guess
[20:35:11] <eddyb> OoO execution doesn't help it get accurate results in some cases
[20:35:22] <Elainemo> eddyb: if you use VTune it does :)
[20:35:29] <Astraea> oh yeah, and CPUs do strange things
[20:35:34] <Astraea> oh yeah, and CPUs do strange things
[20:35:39] *** Quits: swgillespie (swgillespie@moz-qb3.04d.220.167.IP) (Quit: My MacBook Pro has gone to sleep. ZZZzzzâ€¦)
[20:35:47] <Astraea> I've linked a talk about it before
[20:35:54] <eddyb> I'm pretty sure I was getting useless shit once I optimized the usual stuff in my PNG and inflate code. you know, the one that was never published (although the inflate part is in nwin's image-png crate)
[20:36:09] <eddyb> Elainemo: that thing!
[20:36:13] <fkaa> VTune?
[20:36:28] <Astraea> but still
[20:36:30] <eddyb> so many things to play with. so many things to do
[20:36:50] <scott> ^
[20:36:58] <scott> There isn't enough time in a day.
[20:37:25] <Peach> Elainemo: when should I worry about AST traversal efficiency ?
[20:38:18] <Elainemo> Peach: when you have a working product.
[20:38:30] <Elainemo> correctness *then* efficiency.
[20:38:56] <Elainemo> No one optimizes a prototype.
[20:39:50] <eddyb> Peach: can't you just use the visitor pattern?
[20:40:07] <eddyb> where functions get called for each node
[20:40:55] <Astraea> Elainemo: where does maintainability go then? =P
[20:40:59] <eddyb> internal iteration (.foreach(closure) style) as opposed to external iteration (the latter concept is what C++, D and Rust iterators are)
[20:41:38] <Peach> visitor pattern? Functions get called on each node?
[20:41:45] <Peach> How I currently do it is, I don't use virtual
[20:42:00] <Peach> I have one class that does everything a node could do
[20:42:08] <Peach> and I have integer for the type of the node
[20:42:26] <Peach> So I can put all the nodes in one list without needing casting or anything
[20:43:46] <mrmonday> eddyb: for completeness, D has both internal and external iteration
[20:44:07] <mrmonday> though there aren't many who use internal any more, it's still there
[20:44:32] <eddyb> well, the Rust compiler does internal iteration on the AST, if that counts
[20:44:43] <eddyb> and you can turn external into internal really easy
[20:45:00] <eddyb> and there *might* have been a collection with a special internal iterator method
[20:45:15] <eddyb> but it's nothing like D, I guess
[20:45:19] <Peach> Ok so now I'm doing complex "type expression" handling
[20:45:32] <c74d> plenty of people optimize prototypes
[20:45:37] <Peach> currently I handle types like:   int x;   vec3 v;
[20:45:47] <Peach> so the compiler sees   ident ident  as a type declaration
[20:46:09] <Peach> Now I have generics too, so the type can be    List[int] x;  etc.
[20:46:30] <Peach> and I also have typeof which is like C++'s decltype,   so you can   typeof(a *b) x;
[20:46:53] <Peach> I don't think there are any other expressions I'd need to handle for type declaration
[20:46:58] <Peach> so I think I'm good
[20:47:53] <mrmonday> so in D you can either have an opApply() method for your types, which is passed a delegate (function pointer + context), which you call, or you can do it range style and have front/popFront/empty methods
[20:48:22] <mrmonday> there's also reverse versions of both, in case you wanna go backwards
[20:54:52] *** Joins: Lurkin (Lurkin@moz-l7lsic.mpls.qwest.net)
[20:54:55] <Lurkin> Hey all.
[20:55:31] <Lurkin> Spent nearly all day compiling and forgot to run as super user. Lol
[20:56:01] <mrmonday> I feel like I spend more time talking about D here than I do Rust :3
[20:56:19] <Astraea> mrmonday: tell me why I should learn D
[20:56:21] <Astraea> convince me
[20:56:44] <Astraea> proselytize me
[20:57:22] <mrmonday> Astraea: I'm gonna need to know more about you to do that
[20:57:31] <mrmonday> there are very few good reasons to learn D imo
[20:58:04] <mrmonday> learning C++ and Rust is likely a better course of action
[20:58:10] <Astraea> well I like long walks on the beach
[20:58:25] <Astraea> and candlelit dinners
[20:58:31] <Lurkin> They're also a Virgo.
[20:58:51] <mrmonday> if you're a language enthusiast, you don't need a reason to learn D, otherwise the only reason to learn it is some existing code you want to understand/use/extend really
[20:58:59] <Zoxc> Astraea: What about LED-lit dinners?
[20:59:15] <Astraea> Zoxc: I'm old fashioned, so no!
[20:59:15] <mrmonday> it offers some compelling features over C++, but ultimately you've got a far more stable language with C++, with far better tooling and support
[20:59:37] <mrmonday> D is like a cleaned up C++21
[20:59:42] *** Quits: erickt (erickt@moz-1mb.0ej.162.69.IP) (Ping timeout: 121 seconds)
[20:59:42] <Astraea> I already know C++ and am semi-comfortable with rust
[20:59:44] <mrmonday> so you may as well just use C++
[21:00:15] <mrmonday> Astraea: in which case, I guess the only reason I'd say to learn D is to see how template meta-programming *should* be done
[21:00:33] <mrmonday> far cleaner syntax, far easier to use
[21:00:39] <mrmonday> far more powerful
[21:00:52] <mrmonday> still covered in warts, but still :3
[21:01:16] <Astraea> yeah
[21:01:21] <Astraea> well I was tempted to learn D ages ago
[21:01:27] <mrmonday> otherwise you get lots of nice safety features built in, but Rust does that kind of thing far better
[21:01:39] <Astraea> when there was phobos and tango
[21:01:55] <Astraea> but meh, never got around to it
[21:02:12] *** Joins: swgillespie (swgillespie@moz-qb3.04d.220.167.IP)
[21:02:20] *** Joins: patrickjm (patrickjm@moz-5h92b3.lecg.ltgp.0306.2602.IP)
[21:10:35] *** Joins: genbattle (genbattle@moz-4v0.gkd.16.182.IP)
[21:11:20] *** Joins: lu324 (lu324___@moz-gogein.dhcp.embarqhsd.net)
[21:12:04] *** Joins: ijks (ijks@moz-5rif0h.dynamic.ziggo.nl)
[21:14:14] *** Joins: erickt (erickt@moz-1mb.0ej.162.69.IP)
[21:14:14] *** ChanServ sets mode: +o erickt
[21:18:36] <Elainemo> wtf firefox: http://imgur.com/coehgJX
[21:20:11] <Elainemo> The first doesn't even have a "preview in firefox" option.
[21:20:38] <Elainemo> So about half of the PDFs I find need to get downloaded then opened in firefox.
[21:20:58] <Elainemo> because if you specify /usr/bin/firefox for the binary to open pdfs with, it iloops openining a new tab to handle the document.
[21:21:50] <Elainemo> all because a mime type goes wrong somewhere
[21:25:43] <mrmonday> there's a plugin you can get which fixes it
[21:26:10] <mrmonday> ...which I don't seem to have installed for some reason :S
[21:28:32] <Peach> Someone tell me how D's template meta programming is better than C++'s
[21:29:06] <Elainemo> Peach: it wasn't an accident, is a good start :P
[21:29:33] <mrmonday> Peach: cleaner syntax, a lot more powerful
[21:30:09] <mrmonday> it's hard for me to give proper examples, I can only read C++ meta-programming, not write it
[21:31:20] <Peach> :'(
[21:31:37] <Peach> Hey, what do you guys think of first class types meta programming?
[21:32:00] <mrmonday> but in D you can do things like auto someFunction(alias someFunc, T)(T someValue) if ( is(typeof({ someFunc("hello") }())) ) { /* whatever */  }, eg. you can pass arbitrary functions at compile time, check if they compile with certain parameters, and specialise based on that
[21:32:17] <Peach> as in, you can inspect everything about your code, like  iterating through the function parameters for example
[21:32:22] <mrmonday> yes
[21:32:36] <Peach> ?
[21:32:45] <mrmonday> and you can generate code in the same way
[21:32:49] <Peach> in D?
[21:32:58] <mrmonday> and then specialise based on whether that compiles, and all sorts of crazy things
[21:33:01] <mrmonday> yes, in 
[21:33:01] <mrmonday> D
[21:33:36] <Peach> Can you do things like     type x = typeof(this function); ?
[21:33:43] <mrmonday> you can check if a struct has given methods or variables at compile time, and generate different code based on that
[21:33:54] <mrmonday> at compile time, yes
[21:34:09] <mrmonday> it's not as powerful as, say, Idris in that regard
[21:34:14] <mrmonday> but you can still do a lot of cool things
[21:34:46] <Peach> Can you give a link or example of how D lets you inspect the code syntax tree?
[21:36:53] <mrmonday> ah, you can't do that, unless you write a full D frontend in D (which has been done)
[21:37:11] <mrmonday> but you can get access to types, as well as the source code, which is often enough
[21:37:19] <Astraea> I will give D one thing
[21:37:31] <mrmonday> I believe Nim will give you an AST to work with, but I'm not sure, I haven't used it
[21:37:36] <Astraea> Jacob Carlborg has been working on objc support in D
[21:37:47] <Astraea> and I think it's starting to trickle into master
[21:38:03] <fkaa> how does it look
[21:38:07] <mrmonday> Astraea: has it?
[21:38:13] <mrmonday> only took a decade to happen...
[21:38:25] <Astraea> it definitely hasn't been a decade =P
[21:38:28] <mrmonday> work on that started before I started using D, which was nearly a decade ago
[21:38:37] <Astraea> his post about it on the D list was only a few years ago
[21:38:40] <mrmonday> it might have been through a few rewrites in that time
[21:38:48] <Astraea> this is a different project
[21:39:04] <Astraea> there has been several different attempts, each with their own unique strategy
[21:39:13] <mrmonday> https://michelf.ca/blog/2007/d-objc-bridge/ 2007 was when it first started by the looks of things
[21:39:40] <mrmonday> Jacob possibly started from scratch, I know he extended that for a while though
[21:39:50] <Astraea> yeah
[21:39:59] <Astraea> they decided to do things differently
[21:40:09] <mrmonday> I guess that's the other thing D has actually, it's far better at interop with other languages than Rust
[21:40:14] <Astraea> at some point I'd like to do the same (or similar) in rust
[21:40:20] <mrmonday> better direct C++ interop for example
[21:40:28] <Astraea> https://github.com/D-Programming-Language/dmd/pull/4321
[21:40:51] <Astraea> he has a branch that is a lot more complete than that pull request
[21:40:52] <mrmonday> which is probably infeasible with Rust, since there are far greater differences between Rust and C++ than D and C++
[21:41:04] <Astraea> yeah I dunno
[21:41:09] <Astraea> objc should be doable
[21:41:17] <mrmonday> ooh, that's pretty cool
[21:41:19] <Astraea> since objc is just C with a runtime
[21:41:28] <mrmonday> looks like ddmd hasn't been merged yet
[21:41:30] <Astraea> and a bit of syntactic sugar
[21:41:39] <mrmonday> wonder when that'll happen
[21:41:52] <mrmonday> they said it was ready in dconf 2014 if I recall
[21:42:31] *** Quits: Lilly (Lilly@moz-pfkvo9.bredband.comhem.se) (Quit: bajs)
[21:42:33] <Astraea> also, the d-objc-bridge you linked to is more akin to what rust is doing right now
[21:42:38] <Astraea> than what carlborg is doing
[21:43:55] <mrmonday> if you look at that pull actually it has some of michelf's orginal work in one of the commits
[21:44:56] <Astraea> I'm sure
[21:46:07] *** Quits: dustinm` (dustinm@moz-1c1j82.fu2o.sj0n.5300.2607.IP) (Ping timeout: 121 seconds)
[21:49:19] <Peach> Tee hee, I'm allowing a programming language with 2 ways to specify a function
[21:49:36] <Peach> function float (acos) -> float      and   function float acos(float)
[21:50:28] *** Quits: killercup (killercup@moz-f6o3r9.dip0.t-ipconnect.de) (Ping timeout: 121 seconds)
[21:51:51] *** Quits: Lurkin (Lurkin@moz-l7lsic.mpls.qwest.net) (Quit: Leaving)
[21:52:02] <niconii> i'm already confused by that syntax...
[21:52:29] <mbrubeck> Is the first supposed to be `function acos (float) -> float`?
[21:52:31] <fkaa> first looks almost like objc
[21:52:42] <mrmonday> o.o
[21:52:46] <mrmonday> it looks nothing like objc
[21:52:53] <Astraea> ^
[21:52:58] <fkaa> :(
[21:53:12] <niconii> i second mbrubeck's question, because if not... o_O
[21:53:37] <mrmonday> - (float) acos: float; // would be objc... I think... I'm not sure, it's been 5+ years since I wrote any...
[21:53:47] <Peach> Ooops
[21:54:02] <scott> Why have two ways to do the same trivial thing?
[21:54:08] <Peach> function acos(float) -> float         and    function float acos(float)
[21:54:41] <Peach> because.... I have a lot of C/C++ code to convert     #badreason
[21:55:06] <mrmonday> terrible reason
[21:55:13] *** Quits: patrickjm (patrickjm@moz-5h92b3.lecg.ltgp.0306.2602.IP) (Connection closed)
[21:55:27] <mrmonday> if you're doing automated conversion (which you should be) then it makes no difference
[21:55:50] <mrmonday> I say should be, but designing a language to move your C/C++ code to sounds like a terrible idea :3
[21:56:02] <niconii> your /language parser/ isn't the right place to deal with the problem of converting C/C++ functions
[21:56:05] <WindowsBunny> C++ already uses auto acos(float) -> float
[21:56:13] <Peach> C++ has a trailing return type syntax, so it's not that bad - it 
[21:56:14] <niconii> that problem should be dealt with in /your converter/
[21:56:15] <Peach> Yeah
[21:56:33] <WindowsBunny> niconii: Implying the converter and parser aren't the same?
[21:56:33] <Peach> niconii: It's an ease of C/C++ programmer transition thing
[21:56:41] <Peach> not just a converter thing
[21:56:51] <scott> Having two ways to do the same thing does not ease anything.
[21:56:57] <scott> It adds to the confusion for everyone.
[21:57:02] <WindowsBunny> Peach: Multiple ways to do syntax is never easier
[21:57:06] <WindowsBunny> It just adds confusion
[21:57:30] <Peach> playbot: println!["hi"]; println!("hi"); println!{"orly?"};
[21:57:31] -playbot- hi
[21:57:31] -playbot- hi
[21:57:31] -playbot- output truncated; full output at: http://bit.ly/1MwEn4f
[21:57:40] <niconii> WindowsBunny: ...if they were the same, that'd mean Peach's custom language reads and converts C/C++ itself o_O
[21:57:51] <WindowsBunny> niconii: Is there something wrong with that?
[21:58:14] <mbrubeck> Just make your language a superset of C++.  It worked for C++ vis-a-vis C...
[21:58:23] <scott> Peach: Yes, that part of Rust also adds confusion.
[21:58:37] <WindowsBunny> Inherit all the problems of C AND C++, and then strap on even more syntax
[21:58:37] <scott> Rust is definitely not perfect.
[21:58:53] <niconii> WindowsBunny: should we add a C++ parser to rust too then
[21:58:54] <Peach> C++ superset would be awful
[21:59:05] <niconii> WindowsBunny: just to cover all our bases? :D
[21:59:11] <Peach> The language is like not even a subset of C++ or C
[21:59:28] <WindowsBunny> niconii:  It means we'd have full C++ interop!
[21:59:40] <WindowsBunny> niconii: People can just recompile their C/C++ libraries as rust, it'll be amazing
[22:00:35] <Peach> But really
[22:00:45] <Peach> 2 ways to define a function
[22:00:56] <Peach> both familiar ways
[22:01:26] <WindowsBunny> in game maker you can use both = and := to assign to a variable
[22:01:33] <WindowsBunny> and you can use both = and == for comparison
[22:01:35] <scott> WindowsBunny: Is there a difference?
[22:01:38] <niconii> Peach: both familiar ways? wasn't this aimed at non-programmers or something?
[22:01:42] <Peach> How did Rust handle ITS declaration syntax transition?
[22:01:50] <Peach> in the early days of Rust
[22:01:55] <scott> If stuff looks different, it should act different.
[22:01:59] <Elainemo> Peach: By rewriting all the code.
[22:02:08] <WindowsBunny> scott: You can use a variety of styles for conditionals, including {}, begin/end or no delimeters at all
[22:02:18] <Elainemo> probably with some regexps, I don't recall a "rustfix" tool every actually implemented.
[22:02:36] <niconii> Peach: probably by just breaking everything, that's what happened when we switched from [T, ..N] to [T; N] for arrays >_>
[22:02:45] <WindowsBunny> scott: semicolons are optional, and there is no way to pass arrays to/from functions.
[22:02:55] <scott> WindowsBunny: Sounds like a wonderful language.
[22:03:20] <WindowsBunny> scott: Although I wouldn't put it quite on par with PHP, it certainly was a horrifying language
[22:03:38] <WindowsBunny> scott: I spent several years learning game dev with game maker
[22:04:00] <Peach> yeah so,
[22:04:14] <Peach> which function return syntax(es) should I use?
[22:04:37] <Peach> I totally like using "returns" instead of "->"
[22:04:38] <Elainemo> why are you asking us? it is your language.
[22:04:47] <Elainemo> go design your language and come back when you're done :P
[22:04:55] <scott> Having more than one is almost objectively terrible. Whichever one you pick is a lot more subjective.
[22:05:06] <Peach> :'(
[22:05:25] <Peach> Hmmm
[22:05:53] <scott> I used to focus a lot on syntax, but learning new syntaxes is really easy.
[22:06:08] <Zoxc> Require each function to have a new syntax
[22:06:25] <Zoxc> That way, it's easy to identify a function
[22:08:05] <Peach> What language first used   ->  for return syntax?
[22:08:38] <scott> Probably something very old we've never heard of.
[22:08:46] <dfockler> C?
[22:08:54] <dfockler> oh return syntax
[22:09:15] <mrmonday> Haskell uses it, so I assume one of the old functional languages that influenced it also did
[22:09:28] <scott> Yep, Haskell isn't first
[22:09:53] <scott> Haskell also doesn't have "return syntax"
[22:10:15] <scott> It's just "name :: type"
[22:10:20] <mrmonday> I suppose
[22:10:46] <Elainemo> well, it wasn't ISWIM, so it's probably not *that* old.
[22:10:55] <scott> But it is related as a function syntax thing
[22:11:09] <niconii> yeah, not quite the same thing, though it's close enough in meaning that i'd probably count haskell as using it
[22:11:10] <Elainemo> ISWIM used it for logical implication.
[22:11:15] <mrmonday> but then name :: t1 -> t2, t2 is the return type, much like fn name() -> t2 in Rust
[22:11:28] <mrmonday> so you could probably argue it
[22:11:35] <scott> Elainemo: I think the type theorists would argue that's what Haskell uses it for, too
[22:11:55] <Elainemo> scott: I mean that was its conditional syntax, but yes, you could say that.
[22:13:28] <c74d> <https://www.atlantic.net/cloud-hosting/apps/lemp/>
[22:14:01] <Elainemo> olwut
[22:14:09] <c74d> I'm thinking, somewhere along the IT -> [...] -> PR path, someone communicated in speech when they should have in writing.
[22:14:21] <Elainemo> Even later on though, it says "LEMP is solution stack for building dynamic websites and applications powered by Linux, Nginx, MySQL, and PHP"
[22:14:27] <Elainemo> (nginx occurs correctly)
[22:14:31] <Peach> Google's Go  with generics, optional types, no garbage collection, and zero cost abstractions would be a cool language me thinks
[22:14:50] <Elainemo> Peach: what about it would be recognizable as "go"?
[22:14:58] <Elainemo> I mean seriously
[22:15:10] <Elainemo> When you butcher a language that much, you can't really even cite it as inspiration
[22:15:12] <Peach> I wasn't refering to my language 
[22:15:27] <Peach> .....?
[22:15:33] <Elainemo> "Go with ..."
[22:15:36] <Elainemo> That's not Go anymore
[22:15:47] <Elainemo> Not even recognizable as Go
[22:15:55] <mbrubeck> Mathematicians have been using "f: A â†’ B" to mean "f is a function from A to B" for quite a while...
[22:16:12] <Elainemo> mbrubeck: sure, but what was the first language that used that syntax as well?
[22:16:39] <Peach> Elainemo: would go with no garbage collection still be Go ? :P
[22:16:39] *** Joins: dustinm` (dustinm@moz-1c1j82.fu2o.sj0n.5300.2607.IP)
[22:16:52] <mrmonday> PHP with better syntax, a type system, no VM, inline assembly, and no GC would be a cool language me thinks
[22:16:55] <mrmonday> :<
[22:17:00] <Elainemo> Peach: No, you'd have to change so much of everything else to work with non-uniform representation.
[22:17:19] *** Quits: erickt (erickt@moz-1mb.0ej.162.69.IP) (Ping timeout: 121 seconds)
[22:17:42] <Elainemo> Aha! Hope used arrow syntax.
[22:18:44] <scott> Peach: You may be interested in this page: http://rigaux.org/language-study/syntax-across-languages/Fnctn.html#FnctnFnctDfnt
[22:18:46] <Peach> mrmonday: I think so too
[22:18:48] <Peach> :P
[22:18:55] <scott> http://rigaux.org/language-study/syntax-across-languages/ for the top level
[22:19:31] <Elainemo> I forgot about that page
[22:20:11] <mrmonday> :L
[22:20:17] *** Joins: erickt (erickt@moz-1mb.0ej.162.69.IP)
[22:20:17] *** ChanServ sets mode: +o erickt
[22:21:07] <Elainemo> I think Hope may have been earliest 
[22:21:14] <Elainemo> I'm not finding papers about anything earlier
[22:21:31] <Peach> Ideas are ideas, you can take an existing language and add / remove concepts from it to make it an entirely new thing
[22:21:45] <Peach> and it think that's cool
[22:21:47] <Peach> me thinks
[22:21:50] <Peach> :P
[22:21:57] <Elainemo> yeah but like
[22:24:27] *** Quits: fkaa (fkaa@moz-501od2.business.telia.com) (Ping timeout: 121 seconds)
[22:26:31] *** Quits: santiago (santiago@moz-ro2mm9.res.rr.com) (Quit: Computer has gone to sleep.)
[22:29:46] *** Joins: woboats (tatterdemal@moz-fef.k92.228.169.IP)
[22:30:09] <mbrubeck> Elainemo: I was just doing the same search and got the same result (nothing earlier than Hope, though I haven't started chasing references from the Hope paper)
[22:30:49] *** Joins: santiago (santiago@moz-ro2mm9.res.rr.com)
[22:40:30] *** Quits: ijks (ijks@moz-5rif0h.dynamic.ziggo.nl) (Connection closed)
[22:43:16] <niconii> ahaha, old hardware is great
[22:44:27] <niconii> in the amiga, the speed at which its sound chip can modulate audio is limited by /the screen's horizontal scan rate/ 
[22:45:00] <Elainemo> seems legit.
[22:45:19] <Elainemo> I bet that's intimately tied to the clock used to drive both
[22:46:05] *** Quits: bjz (bjz@moz-puppgq.tpgi.com.au) (Quit: My Mac has gone to sleep. ZZZzzzâ€¦)
[22:48:20] *** Quits: swgillespie (swgillespie@moz-qb3.04d.220.167.IP) (Quit: My MacBook Pro has gone to sleep. ZZZzzzâ€¦)
[22:53:58] *** Joins: swgillespie (swgillespie@moz-qb3.04d.220.167.IP)
[22:59:10] *** Quits: swgillespie (swgillespie@moz-qb3.04d.220.167.IP) (Quit: My MacBook Pro has gone to sleep. ZZZzzzâ€¦)
[23:00:53] <Peach> :D
[23:01:03] <Peach> How do you do typedefs in Rust?
[23:01:29] <niconii> type MyAlias = MyType;
[23:01:43] *** Joins: swgillespie (swgillespie@moz-qb3.04d.220.167.IP)
[23:02:02] <niconii> also: type MyAlias<T> = MyComplicatedType<'a, 'b, T, U, V>;
[23:02:36] <niconii> ...actually i'm not sure about the lifetimes, come to think of it
[23:02:43] <Peach> playbot: type float = i32;  let x : float = 5.0; x
[23:02:43] -playbot- <anon>:9:44: 9:47 error: mismatched types:
[23:02:44] -playbot-  expected `i32`,
[23:02:44] -playbot- output truncated; full output at: http://bit.ly/1IqRLnJ
[23:02:57] <Peach> playbot: type float = f32;  let x : float = 5.0; x
[23:02:58] -playbot- <anon>:9:9: 9:26 warning: type `float` should have a camel case name such as `Float`, #[warn(non_camel_case_types)] on by default
[23:02:59] -playbot- <anon>:9         type float = f32;  let x : float = 5.0; x
[23:02:59] -playbot- output truncated; full output at: http://bit.ly/1Kxs0Sb
[23:03:12] <Peach> cam case name?
[23:03:16] <Peach> *camel case
[23:03:31] <niconii> ThisIsCamelCase
[23:03:44] <niconii> camel case is the convention for type/trait names in rust
[23:03:49] <niconii> unless they're primitives
[23:04:19] <niconii> whereas snake_case is used for variable/function names
[23:04:55] <niconii> so you'd name a struct MyStruct, never my_struct, or rust will complain
[23:05:16] <niconii> you can disable the warning, but... that just makes your code inconsistent with everyone else's :(
[23:05:43] <Peach> for terseness,     let x : i32 = 0; is way more verbose than  i32 x = 0;   I wonder why rust doesn't let you do that :'(
[23:06:07] <niconii> anyway, the idea is that you can easily tell at a glance whether something is a type or variable
[23:06:37] <niconii> Peach: 1) parsing that would be hell, and 2) rust allows arbitrary patterns after the `let` keyword
[23:07:14] <niconii> playbot: let (x, y, z) = (1, 2, 3); x
[23:07:15] -playbot- 1
[23:07:53] <niconii> playbot: struct MyStruct { x: i32 }   let MyStruct { x: a } = MyStruct { x: 1234 }; a
[23:07:53] -playbot- 1234
[23:08:50] <niconii> playbot: struct MyStruct { x: i32 }   let (MyStruct { x: a }, b, c) = (MyStruct { x: 1234 }, 567, 890); (a, b, c)
[23:08:51] -playbot- (1234, 567, 890)
[23:09:40] <niconii> also, you can leave off the type in most cases
[23:14:11] <niconii> oh, and 3) that'd be inconsistent with every other place you declare something's type
[23:14:25] *** Quits: swgillespie (swgillespie@moz-qb3.04d.220.167.IP) (Quit: My MacBook Pro has gone to sleep. ZZZzzzâ€¦)
[23:14:37] <niconii> (like function defs, struct defs, etc.)
[23:14:41] <Peach> Does rust have first class  type reflection
[23:15:11] <Peach> like can I iterate over an abritary function's parameters for example?
[23:15:35] <niconii> no
[23:16:16] <Peach> can I find the type of a symbol at compile time?  like       type t = typeof(sqrt);    t's type is now   fn float -> float
[23:16:33] *** Joins: swgillespie (swgillespie@moz-qb3.04d.220.167.IP)
[23:16:50] <niconii> no
[23:20:59] *** Quits: RCIX (RCIX@moz-7omm6s.ph.cox.net) (Ping timeout: 121 seconds)
[23:22:00] <Tiffany> https://twitter.com/jamesmacaulay/status/626163452822687745/photo/1
[23:24:03] <XMPPwocky> When do we want it? Consistency! What do we want? Eventually!
[23:24:10] <XMPPwocky> (shamelessly stolen from twitter)
[23:24:22] <Tiffany> hah
[23:24:46] <Peach> anyone here use C pointers as an ad-hoc optional type in C/C++ :P
[23:25:14] <XMPPwocky> boost::optional apparently is sorta ok
[23:25:33] <niconii> Tiffany: nice
[23:25:40] <Tiffany> peach: I use std::experimental::optional
[23:25:41] * c74d read that as "functions in @elmlang" and was confused
[23:25:53] <c74d> er
[23:25:57] <XMPPwocky> c74d: isn't that what it says
[23:25:57] * c74d read that as "functions in @erlang" and was confused
[23:26:08] <XMPPwocky> aha
[23:26:13] <Peach> I totally use if NULL for optionals
[23:26:15] <Peach> actually
[23:26:26] <Peach> Isn't using raw pointers faster than optionals?
[23:26:30] <Peach> *real optionals
[23:26:40] <Tiffany> uh
[23:26:45] <XMPPwocky> i figured they'd have some template specialization to do what Rust does if there are references in 
[23:26:50] <XMPPwocky> since they're non-null
[23:26:54] <Tiffany> if you're storing a pointer in an optional, yes
[23:27:06] <Tiffany> if you're storing a reference in an optional, maybe but probably not
[23:27:11] <Tiffany> if you're storing a value in an optional, no
[23:27:27] <niconii> in rust, references are always non-null, so rust optimizes None as a null pointer
[23:27:31] <Tiffany> ^
[23:27:33] <niconii> for Option<&T>
[23:27:37] <c74d> (except safe)
[23:27:39] <Tiffany> references in C++ are also non-null, so you can do the same
[23:28:14] <niconii> yeah, there's safety in rust, you can't use the Option without checking whether it's Some(T) or None
[23:28:29] <Tiffany> unless you use .unwrap()
[23:28:41] <niconii> yep, in which case it panics
[23:28:44] <niconii> if it's None
[23:28:57] <Tiffany> accessing an uninitalized optional causes an exception
[23:30:07] <Tiffany> they don't have pattern matching though
[23:30:14] <Tiffany> so you might get exceptions a little bit more often
[23:30:27] <Peach> wait so
[23:30:43] <Peach> say I have an optional for a huge data type
[23:30:46] <Peach> in C++
[23:31:09] <Peach> wouldn't passing it as a pointer that could be NULL and derefing it be faster than an Optional type?
[23:31:24] <Tiffany> solution: don't pass huge objects by value
[23:31:42] <Peach> uh?
[23:31:47] <Tiffany> use an optional<ReallyBig&> or optional<ReallyBig>&
[23:32:18] <Peach> I don't think anyone is actually answering my question :(
[23:32:38] <Tiffany> optional<ReallyBig&> can trivially be optimized to a nullable pointer
[23:32:40] <Tiffany> but it's safer
[23:32:47] <Tiffany> there is no reason for it to be slower
[23:33:01] <Tiffany> unless you are compiling without optimizations
[23:34:53] <swgillespie> Peach: having an optional for a huge data type is not a good idea
[23:34:57] <swgillespie> so that's a bad example
[23:34:59] *** Joins: saml_ (saml@moz-rkfmct.res.rr.com)
[23:35:11] <swgillespie> passing huge things by value will naturally be slower
[23:35:17] <Tiffany> ^
[23:35:24] <Peach> I know
[23:35:29] <Peach> so my question is
[23:35:43] <Peach> Is it faster to pass by raw nullable pointer vs optional?
[23:35:50] <Peach> in C++
[23:35:57] <Tiffany> an optional of what?
[23:36:01] <Tiffany> of a by-value, or of a reference?
[23:36:12] <Tiffany> the answer should be obvious when you disambiguate the question
[23:36:27] <Peach> something non referencable and can only be copied
[23:36:41] <Tiffany> "non referencable"
[23:36:53] <Tiffany> I do not know of anything in C++ which can be passed by pointer and not by reference
[23:37:17] <FreeFull> Does C++'s optional have an equivalent of Rust's null pointer optimisation?
[23:37:36] <Tiffany> that's implementation dependent and I don't know what the implementations do
[23:37:43] <Tiffany> it's possible, but I can't assure you that it does happen
[23:38:15] <swgillespie> i doubt it
[23:38:38] * Peach adds 3 ways to define a function return type
[23:38:55] <Tiffany> let me check boost's source
[23:39:05] <Tiffany> boost's site uses an expired cert, nice
[23:39:12] <FreeFull> I can think of two ways in C++, what's the third?
[23:39:40] <Peach> 3rd way is syntax sugar: allowing returns instead of ->
[23:39:49] <swgillespie> Tiffany: all I see is this http://www.boost.org/doc/libs/1_38_0/libs/optional/doc/html/boost_optional/implementation_notes.html
[23:40:19] <FreeFull> Peach: As in?
[23:40:43] <Peach> FreeFull:    function sqrt(float) returns float
[23:42:23] <Tiffany> okay
[23:42:31] <Tiffany> this is a lot of code
[23:42:32] <Tiffany> wow
[23:42:36] <Tiffany> https://github.com/boostorg/optional/blob/master/include/boost/optional/optional.hpp
[23:45:04] <Tiffany> it looks like it doesn't do the null pointer optimization
[23:45:16] <Tiffany> all you'd have to do is specialize optional for reference types, though
[23:45:33] <FreeFull> Peach: I still don't understand, I need to see an actual source file that uses the syntax
[23:46:20] <Peach> FreeFull:   fn sqrt(float) -> float {code}   same as  fn sqrt(float) returns float { code}
[23:46:40] <mbrubeck> FreeFull: Peach is working on a programming language that allows `function f() returns bool` as sugar / alternate syntax for `function f() -> bool`
[23:46:48] <FreeFull> mbrubeck: Ah
[23:46:56] <FreeFull> That's where the confusion is coming from
[23:47:02] <FreeFull> I thought we were talking about C++
[23:47:10] <XMPPwocky> Peach: what's the benefit of that?
[23:47:33] <FreeFull> Which has     sometype name(...) { ... }   and    auto name(...) -> sometype { ... }
[23:48:36] <Peach> XMPPwocky I have this thing where I read code and I understand things better when they're more obviously typed out. For some reason terseness is very hard for me to process sometimes
[23:48:53] <Peach> I like returns because it makes it read more like pseudocode for me
[23:49:59] <XMPPwocky> that's fine, but why have multiple ways of doing the exact same thing
[23:52:10] <mbrubeck> I do find it important to be able to read a language out loud
[23:52:22] <mbrubeck> Not just for communicating with others, but even when reading silently
[23:52:52] <mbrubeck> There's research on reading human languages (e.g. English, not programming languages) that shows that internal vocalization is important for comprehension
[23:53:22] <XMPPwocky> yeah, i read "symbols" to myself
[23:53:39] <mbrubeck> So it's nice if a programming language community has a standard way of pronouncing things like `fn f() -> bool` as "function f returning bool"
[23:54:19] <Tiffany> function f of bool
[23:54:28] <Tiffany> oh, I guess of is the wrong word there
[23:54:31] <Tiffany> math uses of to denote arguments
[23:54:35] <Tiffany> f of x -> f(x)

[00:00:12] *** Quits: brson (brson@moz-cfhap5.mtv2.mozilla.com) (Quit: leaving)
[00:00:38] *** Joins: brson (brson@moz-fm2.eev.48.37.IP)
[00:31:28] *** Quits: brson (brson@moz-fm2.eev.48.37.IP) (Quit: leaving)
[02:14:28] *** Joins: gsingh93 (gulshan@moz-3fu4am.mi.comcast.net)
[02:42:28] *** Quits: gsingh93 (gulshan@moz-3fu4am.mi.comcast.net) (Ping timeout: 121 seconds)
[02:53:24] *** Quits: Tobba (Tobba@moz-o13d22.bredband.telia.com) (Ping timeout: 121 seconds)
[02:56:55] *** Joins: gsingh93 (gulshan@moz-3fu4am.mi.comcast.net)
[03:31:50] *** Quits: tan (tan@moz-rrp3h1.fios.verizon.net) (Connection closed)
[03:45:55] *** Quits: adu (ajr@moz-bqtbbn.fios.verizon.net) (Client exited)
[04:09:32] *** Joins: adu (ajr@moz-0foa9t.md.comcast.net)
[04:13:55] *** Quits: gsingh93 (gulshan@moz-3fu4am.mi.comcast.net) (Ping timeout: 121 seconds)
[04:19:14] *** Quits: adu (ajr@moz-0foa9t.md.comcast.net) (Client exited)
[04:20:43] *** Joins: adu (ajr@moz-0foa9t.md.comcast.net)
[04:26:50] *** Quits: adu (ajr@moz-0foa9t.md.comcast.net) (Client exited)
[04:30:08] *** Joins: adu (adu@moz-melbkr.ms5a.74ae.000a.2601.IP)
[04:32:50] *** Joins: tan (tan@moz-rrp3h1.fios.verizon.net)
[04:36:17] <Ilari> Hmm... No more messages on curve endian?
[04:36:52] *** Quits: tan (tan@moz-rrp3h1.fios.verizon.net) (Ping timeout: 121 seconds)
[05:09:43] *** Joins: gsingh93 (gulshan@moz-3fu4am.mi.comcast.net)
[05:39:46] *** Joins: BigE (BigE@moz-b53.i7b.98.79.IP)
[05:55:03] *** Joins: jhelwig (jhelwig@moz-jge49m.fkdv.ulf6.3c01.2600.IP)
[06:02:02] *** Quits: adu (adu@moz-melbkr.ms5a.74ae.000a.2601.IP) (Ping timeout: 121 seconds)
[06:18:40] *** Joins: tan (tan@moz-rrp3h1.fios.verizon.net)
[06:22:51] *** Quits: tan (tan@moz-rrp3h1.fios.verizon.net) (Ping timeout: 121 seconds)
[06:26:44] *** Quits: gsingh93 (gulshan@moz-3fu4am.mi.comcast.net) (Ping timeout: 121 seconds)
[07:19:20] *** Joins: tan (tan@moz-rrp3h1.fios.verizon.net)
[07:23:34] *** Quits: tan (tan@moz-rrp3h1.fios.verizon.net) (Ping timeout: 121 seconds)
[07:56:43] <klutzy> Dcoder: for Wrapping<T>? afaik there's no concrete issue/rfc yet, other than https://github.com/rust-lang/rust/issues/22020#issuecomment-83701177
[08:20:05] *** Joins: tan (tan@moz-rrp3h1.fios.verizon.net)
[08:24:31] *** Quits: tan (tan@moz-rrp3h1.fios.verizon.net) (Ping timeout: 121 seconds)
[09:36:15] *** Joins: tan (tan@moz-rrp3h1.fios.verizon.net)
[12:15:25] *** Joins: Tobba (Tobba@moz-o13d22.bredband.telia.com)
[16:37:28] *** Joins: gleb (gleb@moz-3u1drv.rusanovka-net.kiev.ua)
[17:56:40] *** Joins: erickt (erickt@moz-njt.vqi.14.76.IP)
[18:28:52] *** Joins: gsingh93 (gulshan@moz-3fu4am.mi.comcast.net)
[18:52:38] *** Joins: brson (brson@moz-kq1.7vl.56.172.IP)
[19:44:24] <bascule> https://datatracker.ietf.org/meeting/92/agenda/cfrg/
[19:45:28] <Ilari> Looking at that EC-SRP: No mention of cofactor restrictions (if any) and certain operations appear to be very nasty to implement in constant time.
[19:46:36] <bascule> heh
[19:47:41] <bascule> SRP feels like one of those things where people are trying to get too fancy for their own good
[19:47:51] <bascule> especially ECSRP schemes
[19:48:01] <bascule> some guy at the DEFCON Crypto Village presented one
[19:48:16] <bascule> and didn't really put it in the context of "I made this for fun. It's probably broken. Don't actually use this"
[19:51:39] <Ilari> OTOH, a good augmented elliptic-curve PAKE scheme (easily implementable in constant-time!) would probably be good.
[19:55:06] <Ilari> BTW, one part of  proposed modifcations to TLS 1.3 to make it "hardware-friendly" looks almost totally like SSL v3 handling of export ciphers (but not non-export ciphers).
[19:55:22] <bascule> wtf
[19:58:57] <Ilari> Just the hash functions used are different.
[20:05:51] <eternaleye> ...the way to make it hardware-friendly is to separate KEX and AEAD enough for them to be offloaded independently.
[20:06:40] <eternaleye> Then you can have a nice, "feed me public keys and I'll derive a secret" HSM and a "Give me a secret and I'll encapsulate/decapsulate data for you" HSM
[20:07:30] <eternaleye> Add something like DMA-BUF for GPUs, to allow transferring the secret between them without unsealing it, and you have an architecture for offload that works for any _sane_ protocol, and even has uses outside of it!
[20:09:19] <Ilari> Then there was proposal from one of the GnuTLS authors for making TLS 1.3 privsep-friendly (that one looked a lot more reasonable, essentially just adding randoms into TBS).
[20:18:15] <eternaleye> It was basically channel-bindings without channel-bindings.
[20:19:19] <eternaleye> Or rather, channel-binding behavior without the channel-binding extension
[20:25:40] <Ilari> Also, there is currently reserved space in TBS for where the randoms were in 1.2
[20:34:16] *** Quits: brson (brson@moz-kq1.7vl.56.172.IP) (Ping timeout: 121 seconds)
[20:40:48] <bascule> http://www.leonmergen.com/haskell/crypto/2015/03/21/on-the-state-of-cryptography-in-haskell.html
[20:40:51] <bascule> :o
[20:40:56] <bascule> wtf Haskell
[20:42:12] <eternaleye> Haskell, IMO, is a language far more concerned with ideological purity than pragmatism.
[20:42:59] <eternaleye> And "This instruction is explicitly intended to generate random bits" beats out "this OS platform provides a file you open to read randomness" certainly ticks that box
[20:43:44] <eternaleye> Moreover, mixing sources of randomness would be a "Why? It's defined as a random source."
[20:44:21] <eternaleye> I am rather surprised by the modulo mistake
[20:44:30] <cmr> me too, that one surprised me the most
[20:44:35] <eternaleye> I'd have expected them to use infinite-precision rationals as a bit extractor
[20:44:43] <eternaleye> Since they're unafraid of bignums
[20:45:13] <eternaleye> Retry-if-over also works, but that'd poke them in the ideological purety
[20:45:17] <eternaleye> *purity
[20:46:33] <eternaleye> The AES bit I find wholly unsurprising, as Haskell culture is to ignore the impure machine as much as possible.
[20:47:16] <bascule> the AES bit is exactly how rust-crypto also (terrifyingly) works
[20:47:29] <eternaleye> bascule: Ugh.
[20:47:47] <bascule> use AES-NI if available, fall back to code that claims to be constant time, we swear! (but didn't measure)
[20:47:48] <eternaleye> bascule: Honestly, that should just use TARS for the round-key value anyway.
[20:47:58] <eternaleye> bascule: In the AES-NI one
[20:48:01] <bascule> or verify the assembly
[20:48:18] <eternaleye> Sure, but I mean about AES-NI leaving the round-key behind
[20:48:23] <bascule> yeah def
[20:48:31] <cmr> rust-crypto is at least up front about it
[20:48:39] <eternaleye> ehhh
[20:48:43] <bascule> rust-crypto claims the fallback implementation is constant time
[20:49:03] <cmr> "any use where security is important is not recommended at this time"
[20:49:10] <eternaleye> Oh, sure.
[20:49:12] <bascule> haha, yes, there is that
[20:49:14] <bascule> seems good
[20:49:25] * bascule using sodiumoxide for everything
[20:49:27] <cmr> that warning has been there forever, and I sincerely hope nobody uses this crate to secure their communications
[20:49:32] <eternaleye> But the reaction to people bringing up issues has not been encouraging either, from what I remember
[20:50:01] <bascule> I found a typo in the AES-NI implementation after looking at it for like a few minutes
[20:50:04] <bascule> that wasn't encouraging
[20:50:05] <eternaleye> I mean, if it's not ready, then pointing out what needs improved and how is kind of important.
[20:51:02] <eternaleye> Who is DaGenix on IRC, anyway?
[20:51:20] <eternaleye> Or rather, Github(DaGenix) == IRC(?)
[20:51:40] <cmr> enix
[20:51:52] <cmr> they're not around very often
[20:51:57] <eternaleye> ...mm.
[20:53:09] *** Quits: gsingh93 (gulshan@moz-3fu4am.mi.comcast.net) (Ping timeout: 121 seconds)
[21:07:43] <Ilari> Also, the Intel SYSRET. On AMD, returning from system call to invalid address faults in userspace. On Intel, it faults in kernelspace, in a way that can be exploited for privilege escalation.
[21:33:01] <eternaleye> I wonder how RISC-V compares on this kind of thing
[21:33:19] <eternaleye> The supervisor spec is still being finalized, so might be worth getting security folks looking at it
[21:33:48] <eternaleye> This is the most recent version I've seen around: https://groups.google.com/group/chisel-users/attach/7265b0e900ef870f/riscv-privileged.pdf?part=0.1
[21:41:12] <tiffany> what was intel thinking when they made it use that behaviour, ilari?
[21:43:15] <Ilari> tiffany: No idea.
[21:53:29] *** Quits: erickt (erickt@moz-njt.vqi.14.76.IP) (Ping timeout: 121 seconds)
[22:29:31] <frewsxcv> so the servo project seems to use an external getopts crate, but doesn't explicitly specify it anywhere in a Cargo.toml, how does that work? https://github.com/servo/servo/search?utf8=%E2%9C%93&q=getopts
[22:29:36] <frewsxcv> implicit dependency?
[22:30:03] <frewsxcv> oh shoot
[22:30:06] <frewsxcv> this is not #servo
[22:49:58] *** Joins: erickt (erickt@moz-njt.vqi.14.76.IP)
[22:53:34] <eternaleye> frewsxcv: crates.io
[22:53:51] <frewsxcv> eternaleye: what about it?
[22:53:53] <eternaleye> Oh, wait
[22:53:58] <eternaleye> I misread your question
[22:59:02] *** Quits: erickt (erickt@moz-njt.vqi.14.76.IP) (Ping timeout: 121 seconds)
[22:59:17] <eternaleye> frewsxcv: Ah, http://doc.rust-lang.org/getopts/getopts/index.html
[22:59:37] <eternaleye> frewsxcv: It seems that this was (relatively) recently split out
[23:00:54] <eternaleye> frewsxcv: Looks like it was in the stdlib until about three months ago? https://github.com/rust-lang/getopts
[23:02:03] <bascule> I really like the rust stdlib diaspora
[23:02:08] <bascule> stdlib is where code goes to die ;)
[23:03:52] *** Quits: BigE (BigE@moz-b53.i7b.98.79.IP) (Connection closed)
[23:04:18] *** Joins: BigE (BigE@moz-kc79oc.fsa-bg.org)
[23:17:26] <Ilari> Oh yay, The TLS folks hit some pretty fundamential limits with 0-RTT.
[23:45:06] <bascule> and TLS, or 0-RTT in general?
[23:45:37] <Tobba> Ilari: SYSRET was misdesigned so that that canonicality of the return address was checked in the middle of the return
[23:45:49] <Tobba> *after* the stack pointer had been changed, but before it had left kernel mode
[23:46:01] <Ilari> 0-RTT in general in two-party setting.
[23:46:02] <Tobba> so the SYSCALL side had full control over the stack pointer
[23:46:23] <bascule> Ilari: aah, on the Noise list they're discussing 0-RTT in a 3 party setting o_O
[23:46:25] <Ilari> Tobba: Don't AMD CPUs check it after dropping privileges?
[23:47:33] <Tobba> yeah
[23:47:45] <Tobba> AMDs sysleave works fine
[23:47:54] <Tobba> their sysenter is also faster for some reason I can't remember
[23:48:07] <Ilari> The problem is, they need to drop at least one of: 1) Loose serverside consistency. 2) Non-replayability. 3) Reliability.
[23:48:36] <Ilari> The proposed resolution was to drop reliability.
[23:52:10] <Ilari> ... And then DKG points out that dropping reliability doesn't really help.
[23:54:36] <Ilari> And since dropping loose serverside consistency is pretty bad, that leaves dropping non-replayability.
[23:55:06] <Ilari> That would still leave it to be useful for protocol banners.

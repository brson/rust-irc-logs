[03:07:21] *** Joins: c74d3 (c74d3a4ebb6@moz-u3bdim.mggc.hibn.4404.2002.IP)
[03:08:17] *** Quits: c74d (c74d3a4ebb6@moz-0ersgu.oc.cox.net) (Ping timeout: 121 seconds)
[03:08:39] *** c74d3 is now known as c74d
[04:03:38] *** Quits: Tobba (Tobba@moz-o13d22.bredband.telia.com) (Ping timeout: 121 seconds)
[07:18:48] *** Quits: c74d (c74d3a4ebb6@moz-u3bdim.mggc.hibn.4404.2002.IP) (Ping timeout: 121 seconds)
[07:20:19] *** Joins: c74d (c74d3a4ebb6@moz-0ersgu.oc.cox.net)
[13:24:57] *** Joins: Tobba (Tobba@moz-o13d22.bredband.telia.com)
[16:16:17] *** Joins: nmatsakis (nmatsakis@moz-no0.93r.245.63.IP)
[16:16:44] <nmatsakis> aturon pnkfelix nrc : should I move https://github.com/rust-lang/rfcs/pull/756 to FCP? not clear what add'l comments are needed...
[16:16:47] <nmatsakis> huon: ^
[16:17:25] <nmatsakis> pnkfelix: also, do you feel https://github.com/rust-lang/rfcs/pull/873 is ready for FCP?
[16:17:43] <nmatsakis> I think so :)
[17:37:12] <pnkfelix> nmatsakis: i think shifting to FCP for both of those is fine
[17:38:48] <pnkfelix> nmatsakis: though the hygiene Q for RFC PR 873 is ... potentially worrisome ...?
[17:39:04] <nmatsakis> pnkfelix: tbh I've not read in depth
[17:39:23] <nmatsakis> outcome of FCP may well be "need to solve hygiene" I guess...
[17:39:35] <nmatsakis> I do know that I've felt the pain of not being able to use macros in ty position 
[17:52:49] <aturon> nmatsakis: ooh, i'd forgotten about #756
[17:52:56] <aturon> FCP seems good
[17:53:02] <aturon> i'd very much like to do it
[17:53:30] <aturon> what's the overall sentiment on #873?
[17:54:41] <nmatsakis> aturon: I'm positive on the intent, ignorant of the details
[17:55:24] <aturon> ok. i felt a bit uneasy on the intent (just because i know the crazy things people will do with this), but basically OK going along with it
[17:55:28] <nmatsakis> e.g. i've not thought about hygiene here, but I think in the end it will have the same (crappy) hygiene story we have elsewhere for items
[17:55:43] <nmatsakis> I mean, if you buy into macros for expressions...
[17:55:48] <aturon> right
[17:55:50] <nmatsakis> ...it's totally plausible to want macros for types.
[17:56:00] <nmatsakis> an example I liked was this session type work 
[17:56:22] <nmatsakis> I've personally wanted it when writing macros like rusty_peg! or rusty_regex!
[17:56:26] <nmatsakis> because I want to *compute* the type of something
[17:56:31] <nmatsakis> using a helper macro
[17:56:33] <nmatsakis> but that's super hard right now
[17:56:40] <nmatsakis> you can sort of do it with a higher-order macro
[17:56:40] <aturon> hm, i see
[17:56:42] <nmatsakis> but it's awkward
[17:56:47] <nmatsakis> and you wind up convering everything to CPS style in the end :)
[17:56:51] <nmatsakis> (which I did...)
[17:57:02] <nmatsakis> well, mostly I just avoided needing to specify a type by hook or by crook
[17:57:03] <aturon> ok, so i do agree that this is a natural consequence of having macros at all
[18:30:25] <pnkfelix> nmatsakis: there was a thought I had about the switch to defaulting to 'static for Box<Trait>`
[18:30:42] <pnkfelix> nmatsakis: namely: If i as a developer wanted to prepare for such a switch ahead of time
[18:31:13] <pnkfelix> nmatsakis: I might have to add explicit lifetime bindings where I previously did not, right?
[18:43:45] *** Quits: Tobba (Tobba@moz-o13d22.bredband.telia.com) (Connection closed)
[18:44:31] *** Joins: Tobba (Tobba@moz-o13d22.bredband.telia.com)
[19:00:04] *** Quits: Tobba (Tobba@moz-o13d22.bredband.telia.com) (Ping timeout: 121 seconds)
[19:00:27] *** Joins: Tobba (Tobba@moz-o13d22.bredband.telia.com)
[19:14:59] <nmatsakis> pnkfelix: yes, you might, in particular:
[19:15:09] <nmatsakis> fn foo<'a>(x: &Box<Trait+'a>)
[19:26:17] *** Quits: blank_na1e (blank_name@moz-p4egrb.mi.frontiernet.net) (Quit: leaving)
[19:30:12] *** Joins: blank_name (blank_name@moz-p4egrb.mi.frontiernet.net)
[19:47:32] <pnkfelix> nmatsakis: okay, that was what I was worried about.  (Though I was assuming the more accurate desugaring might be `fn foo<'a>(x: &'a Box<Trait+'a>)`, in terms of reproducing our current behavior, right)
[19:47:42] <nmatsakis> pnkfelix: c
[19:48:11] <pnkfelix> nmatsakis: namely, I was just wondering whether that's the sort of desugaring that is ... a "reasonable" onus to expect of someone trying to future proof their code
[19:48:38] <pnkfelix> nmatsakis: Obviously an *automatic* desugaring tool much like the one hypothesized for future proofing of libs can do it
[19:49:05] <nmatsakis> by "future proofing" you mean: someone who wants code to compile with both 1.0 and 1.1 (presuming we backported this change)?
[19:49:18] *** Quits: Tobba (Tobba@moz-o13d22.bredband.telia.com) (Connection closed)
[19:49:24] <nmatsakis> note though that
[19:49:28] <nmatsakis> there's at least a good chance that
[19:49:32] <nmatsakis> &Box<Trait+'static> would work for them ;)
[19:49:50] <nmatsakis> and that
[19:50:00] <nmatsakis> if you have &mut Box<Trait>, i.e., if you trait has `&mut` methods,
[19:50:09] <pnkfelix> Right, I'm only concerned about the case where `&Box<Trait+'static>` didn't work
[19:50:11] <nmatsakis> then the current syntax effectively forces you to write explicit bounds anyway
[19:50:30] <nmatsakis> (because of the dropck interaction)
[19:50:41] *** Joins: Tobba (Tobba@moz-o13d22.bredband.telia.com)
[19:50:42] <nmatsakis> well, I guess I think it's "reasonable" only in that I thikn the change is better
[19:51:02] <pnkfelix> I'm basically trying to apply a litmus test of "if someone, upon hearing about this coming change, wants to ensure their code is not affected by it, what do they need to do"
[19:51:07] <nmatsakis> I see
[19:51:30] <pnkfelix> A global code transformation like CPS is an example of a change that sounds obviously too onerous
[19:51:52] <pnkfelix> but this is a pretty local code transformation, I think, depending on one's definition of "local"
[19:51:52] <nmatsakis> I suspect the other option would be
[19:51:57] <nmatsakis> download the nightly build
[19:52:00] <nmatsakis> and see if your code works :)
[19:52:06] <nmatsakis> but yes that is the sort of annotation
[19:52:10] <nmatsakis> one would have to add
[19:52:11] <nmatsakis> if it does not
[19:52:29] <nmatsakis> (or rather, the beta build I guess)
[19:52:30] <nmatsakis> or anyway
[19:59:17] *** Joins: Tuba (Tobba@moz-o13d22.bredband.telia.com)
[19:59:49] <pnkfelix> nmatsakis: different subject, RFC PR 1052
[20:00:09] <nmatsakis> yep
[20:00:16] <pnkfelix> nmatsakis: are the cast rules recursive, e.g. if `S as T` is legal, then is `X<S> as X<T>` ?
[20:00:22] <pnkfelix> nmatsakis: wait, that's bad
[20:00:26] <pnkfelix> nmatsakis: bad example, what I mean
[20:00:34] <nmatsakis> do you mean transitive?
[20:00:41] <nmatsakis> pnkfelix: ^
[20:00:43] <pnkfelix> nmatsakis: is the specific case where e.g. `struct X<Y>(Y)`
[20:00:54] <pnkfelix> nmatsakis: no, not transitive
[20:01:10] <pnkfelix> nmatsakis: what I mean is do we do structural decomposition to determine the legality of a cast
[20:01:45] <pnkfelix> and thus `X<S> as X<T>` in the above (where we have `struct X<Y>(Y)`) is legal if `S as T` is legal
[20:02:13] *** Quits: Tobba (Tobba@moz-o13d22.bredband.telia.com) (Ping timeout: 121 seconds)
[20:02:47] <nmatsakis> pnkfelix: I see. No, we don't. Some of the DST Take 5 rules included some logic kind of like that,
[20:03:05] <nmatsakis> pnkfelix: but we excised it in favor of explicit opt-in. (Though you can't opt-in unless the compiler can find a match-up...)
[20:03:40] <pnkfelix> nmatsakis: okay.  I was briefly worried about `[S] as [T]` screwing up the length causing GC tracers to become unsound
[20:04:05] <pnkfelix> or rather `*[S] as *[T]`
[20:04:56] <pnkfelix> basically, I am worried there's this running assumption of "Its okay to do crazy things with native pointers without needing an `unsafe` block, because the actual deref will have to be put into an `unsafe` block
[20:05:10] <pnkfelix> and whether that sort of reasoning actually holds up in practice
[20:05:37] <pnkfelix> (then again, why are we allowing this without a motivating example...)
[20:06:43] <nmatsakis> pnkfelix: yes, I considered that too;
[20:06:54] <nmatsakis> pnkfelix: however, could it be worse than *S -> *T?
[20:07:50] <pnkfelix> with `*[S]` there's more compiler-injected machinery involved
[20:08:05] <nmatsakis> oh?
[20:08:07] *** Tuba is now known as Tobba
[20:08:22] <pnkfelix> I don't know, you don't consider the extra word to be extra magic?
[20:08:42] <nmatsakis> pnkfelix: maybe sort of, but I don't know how it's relevant to the question
[20:08:58] <nmatsakis> basically the problem is:
[20:09:03] <pnkfelix> I mean, I expect someone who's an ace systems hacker to be able to wield the `*S -> *T` sword without too much damage
[20:09:06] <nmatsakis> people can produce bogus `*` pointers
[20:09:25] <nmatsakis> so GC tracing or whatever must not go deref'ing * pointers  
[20:09:31] <nmatsakis> without "permission" of some kind :)
[20:09:39] <nmatsakis> which I figured we'd address by
[20:09:50] <nmatsakis> disallowing GC roots from living in memory that was not allocated with rust allocator
[20:09:56] <pnkfelix> right
[20:10:00] <nmatsakis> and being able to ask rust allocator whether the memory was indeed allocated
[20:10:05] <nmatsakis> but maybe it's not enough
[20:10:10] <nmatsakis> now tha tI think a bit more :)
[20:10:15] <nmatsakis> unless the allocator tracks the type of the memory, too
[20:10:23] <nmatsakis> but I think this is equally bad with *S -> *T
[20:10:29] <nmatsakis> and with usize -> *T
[20:10:38] <nmatsakis> as with *[S] -> *[T]
[20:10:43] <nmatsakis> at least in principle, if not in practice
[20:10:50] <nmatsakis> (that is, you seem to suggest that people will screw this up more)
[20:10:53] <nmatsakis> (which is plausible)
[20:10:58] <nmatsakis> (but not relevant to soundness per se)
[20:11:19] <nmatsakis> in particular, we just cna't rely on the types of `*` pointers
[20:11:29] <nmatsakis> if people can create them in safe code so easily
[20:11:32] <nmatsakis> which is a shame
[20:12:08] <nmatsakis> this seems to fit in with the rust 2.0 discussions
[20:12:43] <nmatsakis> that is, I've been suggesting we should be planning to move through major versions,
[20:12:54] <nmatsakis> it might be plausible that we think of GC as a rust 2.0 faeture, even if we lay a lot of groundwork in short term.
[20:13:04] <nmatsakis> particularly if it involves some minor changes like that one
[20:13:16] <nmatsakis> and we just plan on a 2.0 release next year
[20:13:40] <nmatsakis> not to say we shouldn't dig a deeper hole than we already have :) but at least on this point, the hole is already prety deep, no?
[20:14:58] <nmatsakis> pnkfelix: do you agree with assessment that hole is already plenty deep, or am I missing something? 
[20:30:12] <pnkfelix> nmatsakis: no I guess the hole is deep enough
[20:30:20] <pnkfelix> nmatsakis: to fit in a lot of other sutff
[20:30:50] <pnkfelix> (maybe I'm mixing the metaphor, but the point is, I'm not going to block the RFC on this.  I continue to not see the motivation, but maybe I'm short sighted.)
[20:31:39] <nmatsakis> pnkfelix: I think I actually feel roughly the same as you, except maybe that I don't see casting a fat pointer in crazy ways as so different from casting a thin pointer 
[20:31:46] <nmatsakis> i.e., in terms of how much "compiler magic" is involved
[20:32:16] <nmatsakis> I guess it's a bit...more magic in that there is this component that is being transplanted
[20:32:22] <nmatsakis> whereas with a thin ptr the user is supplying both sides
[20:32:31] <nmatsakis> but as we said, it's plenty ... rope to hang oneself either way
[20:32:40] <pnkfelix> nmatsakis: yes, maybe that's part of it.  I.e. why is `*T -> *S` not requiring a mem::transmute you mean?
[20:32:50] <pnkfelix> but whatever
[20:32:55] <nmatsakis> right, but it doesn't, and it's been that way for al ong time...
[20:33:03] <pnkfelix> probably becasue of const expressions
[20:33:07] <nmatsakis> ...it might have been wise to remove it, or make it unsafe, but -- yes, that.
[20:33:35] <nmatsakis> and to some extent, water under the bridge. 

[00:01:25] <gavinb> Trying to do a simple filter on a string to remove hyphens, getting an error. The code:
[00:01:27] <gavinb> s = s.iter().filter(|&c| c != '-').collect();
[00:01:40] <gavinb> The error:  error: failed to find an implementation of trait std::iterator::FromIterator<char,std::iterator::FilterIterator<,char,std::str::StrCharIterator<>>> for ~str
[00:01:59] <engla> yeah unfortunately there is no collect for ~str
[00:02:04] <gavinb> The prelude seems to include the relevant types
[00:02:05] <gavinb> Oh!
[00:02:39] <engla> I can submit a PR for that
[00:02:53] <engla> I had a complicated WIP for that but I think the simple one (chars) will be fine
[00:03:19] <gavinb> engla: that would certainly be useful...
[00:03:33] <gavinb> I'm having to do a lot of string mania due to lack of regexp support
[00:03:48] <gavinb> ^mania^manip :/
[00:04:31] <cmr> rusti: fn foo(_: int) {}
[00:04:32] -rusti- <anon>:1:8: 1:23 warning: unknown `allow` attribute: `default_methods` [-W unrecognized-lint (default)]
[00:04:32] -rusti- <anon>:1 #[allow(default_methods)];
[00:04:32] -rusti-                  ^~~~~~~~~~~~~~~
[00:04:32] -rusti- ()
[00:04:53] <strcat> heh
[00:04:59] *** Joins: Kruppe (user@moz-E150F49F.cpe.net.cable.rogers.com)
[00:05:18] <strcat> rusti: 5
[00:05:18] -rusti- 5
[00:05:32] <cmr> https://github.com/mozilla/rust/blob/master/src/libsyntax/ast.rs#L276
[00:05:42] <cmr> I can not make heads or tails of what variant represents what
[00:05:48] <cmr> Can anyone lend a hand?
[00:06:27] <strcat> cmr: isn't it just an ident?
[00:06:54] <cmr> strcat: function args? nope
[00:07:04] <strcat> I mean the _
[00:07:08] <strcat> cmr: it's not? :|
[00:07:11] <cmr> oh, no, I think it's pat_wild
[00:07:24] <cmr> strcat: no, it's a pat (struct pat, all the good stuff is enum pat_)
[00:07:28] <aatch> cmr, pat_wild is '*' and '_' i believe
[00:07:42] <cmr> rusti: fn foo(*: int) {}
[00:07:43] -rusti- <anon>:5:16: 5:17 error: unexpected token: `*`
[00:07:43] -rusti- <anon>:5          fn foo(*: int) {}
[00:07:43] -rusti-                          ^
[00:07:43] -rusti- application terminated with error code 101
[00:07:57] <aatch> No, wait, '*' is in the enum pattern
[00:08:14] *** Joins: erickt (Adium@49C4075F.3AC15C18.2321E71E.IP)
[00:08:34] <aatch> So Enum(*) is pat_enum('Enum', None) (where 'Enum' is the path)
[00:08:59] <cmr> ohhhh right, yeah
[00:10:08] <cmr> Ok, so pat_region is probably &Enum
[00:10:16] <cmr> I don't think all of these are valid in funciton args?
[00:10:22] <cmr> rusti: fn foo(~a: ~int) {}
[00:10:23] -rusti- <anon>:5:17: 5:18 warning: unused variable: `a` [-W unused-variable (default)]
[00:10:23] -rusti- <anon>:5          fn foo(~a: ~int) {}
[00:10:23] -rusti-                           ^
[00:10:24] -rusti- ()
[00:10:26] <cmr> rusti: fn foo(~a: int) {}
[00:10:27] -rusti- <anon>:5:16: 5:18 error: mismatched types: expected `int` but found a ~-box pattern
[00:10:27] -rusti- <anon>:5          fn foo(~a: int) {}
[00:10:27] -rusti-                          ^~
[00:10:29] -rusti- error: aborting due to previous error
[00:10:31] -rusti- application terminated with error code 101
[00:10:31] *** concrete.mozilla.org sets mode: +M 
[00:10:35] <cmr> huh
[00:10:45] <aatch> cmr, in theory, irrefutable patterns are all valid in func args
[00:11:09] <cmr> rusti: fn foo((a, b): int) {}
[00:11:10] -rusti- <anon>:5:16: 5:22 error: mismatched types: expected `int` but found tuple (types differ)
[00:11:10] -rusti- <anon>:5          fn foo((a, b): int) {}
[00:11:10] -rusti-                          ^~~~~~
[00:11:10] -rusti- error: aborting due to previous error
[00:11:10] -rusti- application terminated with error code 101
[00:11:14] <aatch> Basically, anything except an enum pattern.
[00:11:16] <cmr> rusti: fn foo((a, b): (int, uint)) {}
[00:11:18] -rusti- more than 5 lines of output, pastebinned: http://sprunge.us/jNJi
[00:12:36] <cmr> rusti: fn foo([a, b, c]: ~[int]) {}
[00:12:37] -rusti- <anon>:5:16: 5:25 error: refutable pattern in function argument
[00:12:37] -rusti- <anon>:5          fn foo([a, b, c]: ~[int]) {}
[00:12:37] -rusti-                          ^~~~~~~~~
[00:12:37] -rusti- error: aborting due to previous error
[00:12:37] -rusti- application terminated with error code 101
[00:12:52] <cmr> rusti: fn foo(a..b: int) {}
[00:12:54] -rusti- more than 5 lines of output, pastebinned: http://sprunge.us/EZHQ
[00:13:04] <cmr> I'm surprised I haven't hit an ICE yet :p
[00:13:13] <cmr> jclements (and any other parser people): good job!
[00:14:39] <cmr> rusti: struct Foo {a: int, b: uint}; fn foo({c, d}: Foo) {}
[00:14:41] -rusti- more than 5 lines of output, pastebinned: http://sprunge.us/ZULY
[00:14:55] <cmr> rusti: struct Foo {a: int, b: uint}; fn foo({c: int, d: uint}: Foo) {}
[00:14:57] -rusti- more than 5 lines of output, pastebinned: http://sprunge.us/chAR
[00:15:30] *** concrete.mozilla.org sets mode: -M 
[00:17:13] <cmr> rusti: fn foo(5: int) {}
[00:17:14] -rusti- <anon>:5:16: 5:17 error: refutable pattern in function argument
[00:17:14] -rusti- <anon>:5          fn foo(5: int) {}
[00:17:14] -rusti-                          ^
[00:17:15] -rusti- error: aborting due to previous error
[00:17:15] -rusti- application terminated with error code 101
[00:19:13] <cmr> "A pat_ident may either be a new bound variable, or a nullary enum"
[00:19:16] <cmr> What is a nullary enum?
[00:21:00] <aatch> cmr, enum Foo {}
[00:21:10] <aatch> cmr, no, wait
[00:21:36] <aatch> cmr, Just enum Foo { Bar } I think it means nullary variant (so Bar)
[00:21:54] <aatch> cmr, it's probably an outdated comment. Since it can also be a static variable
[00:21:56] <cmr> aatch: what does that make a pat_ident then?
[00:22:11] <aatch> cmr, well it's parsed *as* an ident.
[00:22:45] <aatch> Since there's no syntactic difference between `a => ...` and `Foo => ...`
[00:23:16] <cmr> aha
[00:23:22] *** Quits: bjz (brendanzab@B398BE78.F804C29E.D35A31DF.IP) (Ping timeout)
[00:23:57] <aatch> cmr, yeah. remember that the AST is is what's parsed. So it doesn't know what's an enum or anything.
[00:29:38] <miloshadzic> strcat: thanks again for the links and the explanation, I have a better understanding now that I've read everything.
[00:30:09] *** Joins: brson (brson@moz-BBE3ABD.mv.mozilla.com)
[00:30:09] *** ChanServ sets mode: +o brson
[00:30:18] *** Quits: eatkinson (eatkinson@moz-BBE3ABD.mv.mozilla.com) (Quit: eatkinson)
[00:31:30] *** Joins: ghrust (ghrust@CFE85B59.6A2AE50.F3114085.IP)
[00:31:30] <ghrust> 01[13rust01] 15bors merged 06auto into 06master: 02http://git.io/-XRdRA
[00:31:30] *** Parts: ghrust (ghrust@CFE85B59.6A2AE50.F3114085.IP) ()
[00:34:02] <cmr> rusti: fn foo(std::str: uint) {}
[00:34:03] -rusti- <anon>:5:16: 5:24 error: unresolved enum variant, struct or const
[00:34:03] -rusti- <anon>:5          fn foo(std::str: uint) {}
[00:34:03] -rusti-                          ^~~~~~~~
[00:34:03] -rusti- error: aborting due to previous error
[00:34:03] -rusti- application terminated with error code 101
[00:34:08] <cmr> heh
[00:34:13] <cmr> rusti: fn foo(std::option::None: uint) {}
[00:34:14] -rusti- <anon>:5:16: 5:33 error: mismatched types: expected `uint` but found an enum or structure pattern
[00:34:14] -rusti- <anon>:5          fn foo(std::option::None: uint) {}
[00:34:14] -rusti-                          ^~~~~~~~~~~~~~~~~
[00:34:14] -rusti- error: aborting due to previous error
[00:34:14] -rusti- application terminated with error code 101
[00:34:17] <cmr> hahah
[00:34:25] *** Joins: ghrust (ghrust@DE823A67.6A2AE50.F3114085.IP)
[00:34:25] <ghrust> 01[13rust01] 15bors pushed 0 new commits to 06auto: 02http://git.io/LUwN7A
[00:34:25] *** Parts: ghrust (ghrust@DE823A67.6A2AE50.F3114085.IP) ()
[00:34:26] *** Joins: ghrust (ghrust@9C8B94D4.6A2AE50.F3114085.IP)
[00:34:26] <ghrust> 01[13rust01] 15bors pushed 2 new commits to 06auto: 02http://git.io/hLZZiw
[00:34:26] <ghrust> 13rust/06auto 14be51051 15Jens Nockert: Temporary fix for seek, until replaced...
[00:34:26] <ghrust> 13rust/06auto 14570ecc3 15bors: auto merge of #8098 : jensnockert/rust/fix-fd-seek, r=pcwalton...
[00:34:27] *** Parts: ghrust (ghrust@9C8B94D4.6A2AE50.F3114085.IP) ()
[00:34:37] <cmr> rusti: let x = 5u; fn foo(x: uint) {}
[00:34:39] -rusti- more than 5 lines of output, pastebinned: http://sprunge.us/NCAC
[00:34:55] <cmr> rusti: let x = 5u; fn foo(x: uint) { println(x.to_str()) } foo(6u)
[00:34:57] -rusti- <anon>:5:13: 5:14 warning: unused variable: `x` [-W unused-variable (default)]
[00:34:57] -rusti- <anon>:5          let x = 5u; fn foo(x: uint) { println(x.to_str()) } foo(6u)
[00:34:57] -rusti-                       ^
[00:34:57] -rusti- 6
[00:34:57] -rusti- ()
[00:35:31] *** Quits: jclements (jclements@moz-D8739642.ngn.east.myfairpoint.net) (Ping timeout)
[00:35:32] <brson> olsonjeffery: do you have a design in mind for async i/o. maybe you can sketch out the api for feedback?
[00:37:02] *** Joins: jclements (jclements@moz-EF88AD6.ptldme.east.myfairpoint.net)
[00:37:15] *** Quits: alisdair (textual@1697D94C.7742FB18.FBC8476D.IP) (Quit: My MacBook Pro has gone to sleep. ZZZzzzâ€¦)
[00:40:37] *** Joins: sk (sk@61A494B3.BA40E8A.AAC02D62.IP)
[00:42:15] *** Joins: dwhyte1 (dwhyte@1922756A.EDC594B0.7BF4A4B0.IP)
[00:42:15] *** Quits: dwhyte (dwhyte@1922756A.EDC594B0.7BF4A4B0.IP) (Connection reset by peer)
[00:50:02] <mark_edward> is it common for C #include directories to create seemingly circular dependencies?
[00:50:23] <mark_edward> this library I'm trying to port seems to be doing that, and it's making it hard to understand...
[00:50:35] <mark_edward> *#include directives
[00:50:58] *** Quits: jaen (jaen@moz-E0979827.copit.pl) (Ping timeout)
[00:51:07] <engla> no mark_edward, that sounds bad
[00:51:22] <aatch> mark_edward, there's probably header guards
[00:51:38] <mark_edward> engla: do you mean the regular #ifdef stuff?
[00:51:46] <aatch> so #ifndef SOMETHING\n#define SOMETHING
[00:53:01] <engla> sure, so that includes only have an effect once
[00:53:07] <engla> quite the hack actually
[00:54:01] <aatch> most modern C compilers have a #pragma once, but it's still not standard...
[00:54:12] *** Quits: jclements (jclements@moz-EF88AD6.ptldme.east.myfairpoint.net) (Quit: jclements)
[00:55:36] *** Quits: erickt (Adium@49C4075F.3AC15C18.2321E71E.IP) (Quit: Leaving.)
[00:55:45] <doomlord> why oh why dont they just do #import , i think objc does that?
[00:56:18] <doomlord> (#import = include once.. i think?)
[00:56:30] *** Quits: rusti (rusti@moz-54F7FD49.cpe.net.cable.rogers.com) (Ping timeout)
[00:56:35] <aatch> doomlord, because C is older than you
[00:57:08] *** Quits: strcat (strcat@moz-54F7FD49.cpe.net.cable.rogers.com) (Ping timeout)
[00:57:16] *** Joins: strcat (strcat@moz-54F7FD49.cpe.net.cable.rogers.com)
[00:58:04] *** Quits: kimundi (kimundi@moz-28396413.dip0.t-ipconnect.de) (Ping timeout)
[00:58:13] *** Joins: kimundi (kimundi@moz-28396413.dip0.t-ipconnect.de)
[00:59:01] *** Quits: wilsonk|2 (kvirc@moz-8E86F35A.cg.shawcable.net) (Ping timeout)
[00:59:08] <engla> I implemented clone for extern fn and &'static fn but I think it's too hacky to go in https://gist.github.com/anonymous/0d5ce2cdfc789a09cb85
[00:59:52] <engla> something like that is needed to clone Map and Filter iterators
[01:01:42] *** Quits: jmgrosen (jmgrosen@moz-848F6087.sb.sd.cox.net) (Quit: jmgrosen)
[01:02:00] *** Quits: vosen (vosen@moz-266BA656.icpnet.pl) (Connection reset by peer)
[01:06:35] *** Joins: Yurume_ (yurume@AC58A8CE.8A059B47.E313B915.IP)
[01:10:01] *** Joins: erickt (Adium@49C4075F.3AC15C18.2321E71E.IP)
[01:10:48] *** Quits: geomyidae (cole@DD6F7E3A.21468E9A.30200F38.IP) (Quit: Konversation terminated!)
[01:15:49] *** Joins: rusti (rusti@moz-54F7FD49.cpe.net.cable.rogers.com)
[01:16:33] <doomlord> if i have a &[u8], can get it as a &str
[01:16:40] <doomlord> cast it..
[01:16:43] *** Quits: int3_ (int3_@moz-ABE52D50.hsd1.ca.comcast.net) (Client exited)
[01:17:25] <mark_edward> doomlord: std::str::from_bytes?
[01:17:46] <doomlord> looks like thats right
[01:17:57] <mark_edward> doomlord: http://static.rust-lang.org/doc/std/str.html#function-from_bytes_slice for no allocations
[01:19:32] <mark_edward> engla: i'm familiar with C/C++ but I've never encountered seemingly circular include statements. if i try and find a "root" I get sent somewhere back in the chain
[01:19:38] *** Joins: bjz (brendanzab@B398BE78.F804C29E.D35A31DF.IP)
[01:19:45] <mark_edward> i am personally a firm believer in DAG dependencies
[01:19:51] <mark_edward> does Rust enforce that?
[01:19:58] *** Quits: brson (brson@moz-BBE3ABD.mv.mozilla.com) (Quit: leaving)
[01:20:05] <bjz> slaren: ok, I made an AlphaColor type
[01:20:15] <cmr> mark_edward: only for crates
[01:20:18] *** Quits: MrFahrenheit (RageOfThou@3FEF494C.29C984D5.783DEDCA.IP) (Ping timeout)
[01:20:25] <cmr> modules can include each other no problem iirc
[01:20:35] <cmr> actually maybe not
[01:20:42] <cmr> I recall seeing an error for recursive modules
[01:20:55] <mark_edward> cmr: okay. but it confuses me, this C library is hard to get to the bottom of
[01:21:03] *** Quits: maxli1 (maxli@B5559308.9C54E60.2FA4EA88.IP) (Quit: Leaving.)
[01:21:21] <cmr> mark_edward: if it has ifdef guards it shouldn't need a bottom, right?
[01:21:56] <mark_edward> cmr: i guess. but it hides what depends on what. i have two .c files that include each others .h files, respectively
[01:22:03] <mark_edward> maybe i should regard them as one unit
[01:22:47] *** Joins: MrFahrenheit (RageOfThou@3FEF494C.29C984D5.783DEDCA.IP)
[01:23:12] *** Joins: bjz_ (brendanzab@B398BE78.F804C29E.D35A31DF.IP)
[01:23:34] *** Quits: bjz (brendanzab@B398BE78.F804C29E.D35A31DF.IP) (Connection reset by peer)
[01:33:42] *** Joins: wilsonk-laptop (kvirc@moz-8E86F35A.cg.shawcable.net)
[01:34:23] *** Quits: erickt (Adium@49C4075F.3AC15C18.2321E71E.IP) (Quit: Leaving.)
[01:44:17] *** Quits: gavinb (gavinb@moz-CA19A0CF.vic.adsl.internode.on.net) (Quit: gavinb)
[01:44:49] *** Joins: hjr3 (hradtke@moz-E87BDF1F.socal.res.rr.com)
[01:46:13] *** Joins: bjz (brendanzab@B398BE78.F804C29E.D35A31DF.IP)
[01:46:19] *** Quits: bjz_ (brendanzab@B398BE78.F804C29E.D35A31DF.IP) (Connection reset by peer)
[01:47:29] *** Quits: heftig (heftig@327C8F30.EBDCAFC6.FEC4A986.IP) (Quit: Quitting)
[01:49:24] *** Joins: gavinb (gavinb@moz-CA19A0CF.vic.adsl.internode.on.net)
[01:49:26] *** Joins: ghrust (ghrust@9C8B94D4.6A2AE50.F3114085.IP)
[01:49:26] <ghrust> 01[13rust01] 15bors 04force-pushed 06auto from 14570ecc3 to 144cc3bbb: 02http://git.io/N3iJvQ
[01:49:26] *** Parts: ghrust (ghrust@9C8B94D4.6A2AE50.F3114085.IP) ()
[01:49:29] *** Joins: ghrust (ghrust@614D05BD.6A2AE50.F3114085.IP)
[01:49:30] <ghrust> 01[13rust01] 15bors pushed 2 new commits to 06auto: 02http://git.io/XivPbA
[01:49:30] <ghrust> 13rust/06auto 144849a42 15blake2-ppc: std: Implement FromIterator for ~str...
[01:49:30] <ghrust> 13rust/06auto 1452dbe13 15bors: auto merge of #8100 : blake2-ppc/rust/str-collect, r=pcwalton...
[01:49:30] *** Parts: ghrust (ghrust@614D05BD.6A2AE50.F3114085.IP) ()
[01:52:20] <kemurphy> what differentiates a pat_struct from a pat_enum?
[01:52:52] <cmr> kemurphy: pat_struct is for destructuring enums I think
[01:53:41] <cmr> rusti: struct Foo { a: uint, b: int } let f = Foo { a: 15u, b: -1i }; match f { {a, b} => printfln!("%?, %?", a, b), _ => fail!("foo!") }
[01:53:43] -rusti- more than 5 lines of output, pastebinned: http://sprunge.us/jiLa
[01:53:48] <cmr> hrmph
[01:54:32] <kemurphy> cmr: oh, so one of them is obsolete basically
[01:54:50] <cmr> kemurphy: I *swore* struct destructuring was a thing though ;(
[01:55:14] <kemurphy> rusti: struct Foo { a: uint, b: int } let f = Foo { a: 15u, b: -1i }; match f { Foo {a, b} => printfln!("%?, %?", a, b), _ => fail!("foo!") }
[01:55:15] -rusti- line longer than 150 columns, pastebinned: http://sprunge.us/aNMT
[01:55:24] <cmr> ohhhh
[01:55:35] <cmr> rusti: struct Foo { a: uint, b: int } let f = Foo { a: 15u, b: -1i }; match f { Foo {a, b} => printfln!("%?, %?", a, b)}
[01:55:37] -rusti- 15, -1
[01:55:37] -rusti- ()
[01:55:38] <doomlord> some progress on this find definition thing.. finally managed to get some definition link for a node, in certain cases..
[01:55:41] <cmr> that makes sense.
[01:55:45] <kemurphy> pat_enum handles the struct case as well
[01:55:48] <kemurphy> which is why i was confused
[01:55:51] <cmr> ok
[01:55:53] <cmr> that is confusing
[01:56:00] * kemurphy gets out the machete
[01:56:45] *** Quits: Jeaye (Jeaye@moz-FD505E54.hsd1.ca.comcast.net) (Ping timeout)
[01:57:22] <kemurphy> oh, wait
[01:57:47] <kemurphy> rusti: struct Foo { a: uint, b: int } let f = Foo { a: 15u, b: -1i }; match f { Foo {a: b, b: a} => printfln!("%?, %?", a, b)}
[01:57:48] -rusti- -1, 15
[01:57:48] -rusti- ()
[01:57:50] <kemurphy> lol
[01:57:55] <kemurphy> that's the difference
[01:58:09] <kemurphy> what if...
[01:58:11] <cmr> pat_struct handles that case differently?
[01:58:14] <kemurphy> rusti: struct Foo { a: uint, b: int } let f = Foo { a: 15u, b: -1i }; match f { Foo {a: b, b} => printfln!("%?, %?", a, b)}
[01:58:15] -rusti- more than 5 lines of output, pastebinned: http://sprunge.us/aegX
[01:58:25] *** Joins: tautologico (shung@5249C163.AFE3D52.7B974E06.IP)
[01:58:41] <kemurphy> maybe not
[01:58:48] <doomlord> it seems to reference the definitions of local variables and 'raw' struct references fine, (going from a node-id->defmap->def node->source text..)
[01:59:11] *** Quits: enix (enix@moz-A50569DD.c3-0.slvr-ubr1.lnh-slvr.md.cable.rcn.com) (Ping timeout)
[01:59:11] <kemurphy> ugh, this pattern code is... a maze of twisty passages, all alike
[01:59:50] <doomlord> but it seems i have more to do to get the definition from other types of node. eg even a qualified name shows up as something different, (a 'path', whcih itself doesn't have an entry in the def_map)
[02:00:11] *** Quits: hjr3 (hradtke@moz-E87BDF1F.socal.res.rr.com) (Quit: My MacBook has gone to sleep. ZZZzzzâ€¦)
[02:02:05] <kemurphy> doomlord: if it involves structs or enum variants, i'm probably fixing it
[02:02:43] <kemurphy> there was some buggy node code i came across yesterday related to struct definitions
[02:02:44] *** Joins: dew (Instantbir@moz-8A63B53.dhcp.stls.mo.charter.com)
[02:04:02] <doomlord> ok i'll see how far i can get with what i have
[02:04:05] *** Quits: q66 (q66@6EE9DE40.46454B5D.33AABD5F.IP) (Quit: Leaving)
[02:04:07] *** Joins: enix (enix@moz-A50569DD.c3-0.slvr-ubr1.lnh-slvr.md.cable.rcn.com)
[02:04:34] *** Joins: Jeaye (Jeaye@moz-FD505E54.hsd1.ca.comcast.net)
[02:07:37] <mark_edward> is std::iterator::* exporrted in the prelude now?
[02:08:51] <strcat> only some traits are
[02:09:17] <mark_edward> so Counter wouldn't be imported
[02:09:46] <engla> right mark_edward it's not
[02:10:13] <mark_edward> how would you most simply translate C style for loops where the indexes are used for calculation?
[02:10:37] <mark_edward> engla: thanks
[02:11:18] <engla> mark_edward: use .enumerate() on an iterator
[02:11:35] <mark_edward> engla: thanks
[02:11:44] <engla> for v.iter().enumerate().advance |(i, elt)| { .. }
[02:11:55] <mark_edward> engla: ah, makes sense!
[02:11:55] *** Quits: henrikhodne (henrikhodn@moz-F3A92B1C.hsd1.ca.comcast.net) (Ping timeout)
[02:12:09] <mark_edward> this is my favorite IRC channel
[02:12:39] <mark_edward> will everyone be so nice when there are Rust graybeards and RustEE and millions of newbs?
[02:13:26] <doomlord> http://pastebin.com/bBys8MJZ <<< current debug output of find-tool .. 
[02:14:15] <cmr> doomlord: what are you doing with Paths and what id are you trying to use?
[02:14:29] <doomlord> good question
[02:14:37] *** Joins: tikue (tkuehn@moz-A7CDB794.dia.static.qwest.net)
[02:16:56] *** Quits: sebcrozet (sebcrozet@moz-A855F6C0.w82-127.abo.wanadoo.fr) (Ping timeout)
[02:17:57] <doomlord> i'm just trying to find exactly where my code handles 'paths'. it definitely gets them somewhere
[02:19:59] *** Joins: jensnockert (jensnocker@moz-C5F27039.cust.bredband2.com)
[02:20:56] <doomlord> ok: "paths" are part of "expr" - and in my code to find the node from a source location, it doesn't have any handling of individual expr_ types - it just returns the expr's node_id
[02:21:28] <doomlord> struct expr { id:node_id <<< thats the node i'm "looking for",    node: expr_, span:span }
[02:21:42] <engla> mark_edward: hard to tell people to rtfm when there is none
[02:22:15] <mark_edward> engla: true. do you think you get an annoying amount of questions here?
[02:22:45] <engla> I don't think so
[02:22:57] <Mindless`> is util::replace/swap the only way to update an owned member of a borrowed struct?  e.g. http://codepad.org/06oGNxI6
[02:23:08] <engla> I'm just some guy and I like talking about Rust
[02:23:15] <engla> so I'll answer if I can..
[02:24:20] <doomlord> cmr i see "Path" containts 'types', should i be consulting that to get 'the node' ... i thought Path::types was template parameters
[02:24:46] <cmr> doomlord: those are the type parameterizations
[02:25:04] <cmr> the node_id for a type is given from the item
[02:25:18] <doomlord> eg    foo::bar<x,y>      expr.nodeid= id of "foo::bar"  .. and expr.node::expr_path.types=[id of x, id of y]
[02:25:21] <cmr> wait no, I'm confusing that with something els.e
[02:25:30] <engla> Mindless`: yes basically
[02:25:53] <cmr> Ah here it is
[02:25:55] <cmr> ty_path(Path, Option<OptVec<TyParamBound>>, node_id),
[02:26:58] <mark_edward> engla: how would you pull off something like this in RUst ? for(x=0; x<5; x++) { for(y=0; y<5; y++) { A[index(x, y)] ^= D[x]; } }
[02:27:01] <engla> Mindless`: bc could take a &mut ~[Foo] parameter instead
[02:27:01] *** Joins: int3_ (int3_@moz-ABE52D50.hsd1.ca.comcast.net)
[02:27:35] <engla> is that Keccak?
[02:27:49] <engla> you can use nested loops the same way if you want
[02:27:55] <cmr> doomlord: so you get the id from the ty_path
[02:28:19] <doomlord> at the minute i have a expr node for the path..
[02:28:36] *** Joins: henrikhodne (henrikhodn@moz-F3A92B1C.hsd1.ca.comcast.net)
[02:28:41] <doomlord> do i get this "ty_path" from somewher elese,  ctxt_..
[02:28:49] *** Quits: int3_ (int3_@moz-ABE52D50.hsd1.ca.comcast.net) (Ping timeout)
[02:29:03] <doomlord> ctxt:node_types ?
[02:29:06] <mark_edward> engla: wtf how did you reccognize that like that!!!
[02:29:25] <engla> the variables are named the same way in their paper or something
[02:29:43] <mark_edward> engla: ah, i see
[02:29:58] <doomlord> this could be where i've been going wrong, i'm looking for the def_map entry of the node "under the cursor"
[02:29:59] <engla> gl :)
[02:30:40] <Mindless`> engla: ah, thanks, I hadn't thought of that
[02:30:45] <doomlord> should i be first getting a "type node" ??? from ctxt_.node_type_table .. then look *that* up in def_map.
[02:32:39] <mark_edward> strcat: we need an upto method on numbers to spawn an iterator such that num.upto().advance |n| {}  covers [0,num) 
[02:33:04] <mark_edward> that would be useful in covering a lot of the use case for C style for-loops
[02:33:22] *** Quits: Jeaye (Jeaye@moz-FD505E54.hsd1.ca.comcast.net) (Ping timeout)
[02:37:07] <mark_edward> doomlord: engla: what do you guys think?
[02:37:39] <cmr> mark_edward: isn't that what range does, just with internal iterators?
[02:37:54] <mark_edward> cmr: what's range?
[02:37:55] <engla> I think an iterator version of range(lo, hi) would be fine
[02:37:59] <doomlord> range(0,num) .advance() ?
[02:38:06] <cmr> Also, that iterator version is Counter
[02:38:25] <mark_edward> you know i completely forgot about that. haven't used it since the new external iterators!
[02:38:29] <engla> mark_edward: std::num::uint::range  does the numerical loop. Sorry, I assumed you knew
[02:38:34] <Luqman> rusti: use std::iterator::Counter; for Counter::new(0, 1).take_(5).advance |n| { printfln!("%?", n); }
[02:38:39] -rusti- more than 5 lines of output, pastebinned: http://sprunge.us/eRYS
[02:38:53] <Luqman> mark_edward: ^ there's that
[02:39:04] <cmr> rusti: Counter::new(15, 1).take(30).advance |x| { print(x.to_str()) }
[02:39:05] -rusti- more than 5 lines of output, pastebinned: http://sprunge.us/ZNJR
[02:39:11] <cmr> feh
[02:39:16] <mark_edward> so longwinded though. this is a really common usage, i'd think, it sould be short
[02:39:50] <engla> yes. just do  use range = std::uint::range; at the top
[02:40:30] <engla> don't know why I assign a name there but that's in my code. wonder what I was thinking
[02:43:00] <mark_edward> engla: range is [lo, hi)
[02:43:22] <mark_edward> right?
[02:43:23] <engla> yeah
[02:43:25] <mark_edward> cool
[02:44:40] <engla> it's a good question on how to iterate though.. iterators save you array bounds checks so a linear iteration is going to be faster than nested ranges for this case
[02:44:56] <engla> not sure what the best way is to do it since you access  D[x] too
[02:45:54] *** Quits: SiegeLord (sl@moz-CAF07B4C.hsd1.ma.comcast.net) (Quit: It's a joke, it's all a joke.)
[02:48:04] *** Joins: jmgrosen (jmgrosen@moz-848F6087.sb.sd.cox.net)
[02:50:36] *** Quits: kimundi (kimundi@moz-28396413.dip0.t-ipconnect.de) (Ping timeout)
[02:52:33] *** Joins: samx (sami@moz-48EC0983.dyn.optonline.net)
[02:53:51] *** Joins: kimundi (kimundi@moz-99C29C81.dip0.t-ipconnect.de)
[02:53:58] <samx> Trying to get some of my old rust code to compile.. Haven't played since 0.5 or so..  I used to be able to do:   let x = float::pow(3., 4.);   but that doesn't seem to work anymore.. and seems i'm too dumb to make sense of the library docs :-(
[02:54:13] <cmr> rusti: std::float::pow
[02:54:14] -rusti- <anon>:5:9: 5:24 error: unresolved name `std::float::pow`.
[02:54:14] -rusti- <anon>:5          std::float::pow
[02:54:15] -rusti-                   ^~~~~~~~~~~~~~~
[02:54:15] -rusti- error: aborting due to previous error
[02:54:15] -rusti- application terminated with error code 101
[02:54:23] <cmr> rusti: 3.0 ^ 4.0
[02:54:24] -rusti- <anon>:5:9: 5:18 error: binary operation ^ cannot be applied to type `<VF0>`
[02:54:24] -rusti- <anon>:5          3.0 ^ 4.0
[02:54:24] -rusti-                   ^~~~~~~~~
[02:54:24] -rusti- error: aborting due to previous error
[02:54:24] -rusti- application terminated with error code 101
[02:56:10] *** kimundi is now known as zz_kimundi
[02:58:30] <mark_edward> rusti: 2f.pow(3)
[02:58:31] -rusti- <anon>:5:16: 5:17 error: mismatched types: expected `&float` but found `<VI0>` (expected &-ptr but found integral variable)
[02:58:31] -rusti- <anon>:5          2f.pow(3)
[02:58:31] -rusti-                          ^
[02:58:31] -rusti- error: aborting due to previous error
[02:58:31] -rusti- application terminated with error code 101
[02:58:35] <bjz> rusti: 4f.pow(&4f)
[02:58:37] -rusti- 256
[02:59:02] <samx> ahh.. & is what i'm missing.. thanks
[02:59:04] <bjz> rusti: num::pow(4.0, 4.0)
[02:59:06] -rusti- more than 5 lines of output, pastebinned: http://sprunge.us/UWEc
[02:59:12] <mark_edward> rusti: 3f.pow(&3f.pow(&3))
[02:59:12] -rusti- <anon>:5:24: 5:26 error: mismatched types: expected `&float` but found `&<VI0>` (expected float but found integral variable)
[02:59:13] -rusti- <anon>:5          3f.pow(&3f.pow(&3))
[02:59:13] -rusti-                                  ^~
[02:59:13] -rusti- error: aborting due to previous error
[02:59:13] -rusti- application terminated with error code 101
[02:59:24] <bjz> hmm, we need one for that
[02:59:26] <mark_edward> rusti: 3f.pow(&(3f.pow(&3)))
[02:59:26] -rusti- <anon>:5:25: 5:27 error: mismatched types: expected `&float` but found `&<VI0>` (expected float but found integral variable)
[02:59:27] -rusti- <anon>:5          3f.pow(&(3f.pow(&3)))
[02:59:27] -rusti-                                   ^~
[02:59:27] -rusti- error: aborting due to previous error
[02:59:27] -rusti- application terminated with error code 101
[02:59:37] <mark_edward> i don't get it
[02:59:41] <bjz> rusti: 3f.pow(&3f.pow(&3f))
[02:59:42] -rusti- 7625597484987
[02:59:42] *** Quits: carllerche (carllerche@6B070D22.7E6A0813.1428D117.IP) (Quit: carllerche)
[02:59:51] <mark_edward> oh ok
[03:00:06] *** Joins: carllerche (carllerche@6B070D22.7E6A0813.1428D117.IP)
[03:00:10] <bjz> we need a num::pow(x,y)
[03:00:12] *** Quits: carllerche (carllerche@6B070D22.7E6A0813.1428D117.IP) (Quit: carllerche)
[03:00:14] <engla> there is a function not using libc pow
[03:00:16] <engla> yeah we do
[03:00:26] <engla> rusti: std::num::pow_with_uint(3.0, 3)
[03:00:27] -rusti- more than 5 lines of output, pastebinned: http://sprunge.us/NfUW
[03:00:39] <bjz> also num::clamp(x,a,b)
[03:01:40] <engla> hm ok pow_with_uint wasn't what I thought
[03:01:50] <bjz> engla: ultimitely we shouldn't be relying on libc
[03:02:05] <bjz> we should have our own implementation of the maths functions
[03:02:20] <engla> I misspoke I think anyway
[03:02:29] <Ralith> relying on libc has many advantages
[03:02:34] <Ralith> wide availability, maturity
[03:02:37] <engla> those are llvm-supplied math functions
[03:02:53] <engla> I just think of them as libc
[03:03:49] <engla> hm ok it's a mix
[03:03:57] <bjz> yah
[03:04:11] <cmr> Ralith: even if we bundle newlib or something, system dependencies aren't that great (libc isn't always the best)
[03:04:14] <samx> Is there some specific reason why e.g. pow is taking a pointer as the exponent parameter instead of just a direct float ?
[03:04:40] <bjz> sam
[03:04:43] <bjz> woops
[03:04:43] *** Joins: geomyidae (cole@DD6F7E3A.21468E9A.30200F38.IP)
[03:05:00] <bjz> samx: because it's a generic impl
[03:05:11] <bjz> samx: trait I mean
[03:05:15] <engla> I think it's to be fully useful also for bignum etc
[03:05:18] <samx> i see
[03:05:24] <bjz> samx: personally I prefer we didn't
[03:05:35] <cmr> bjz: don't you basically own the numeric code? :P
[03:05:49] <bjz> cmr: we all own the numeric code
[03:05:53] <mark_edward> engla do we have bitwise complement (~ in C) ?
[03:06:00] <bjz> !
[03:06:01] <cmr> rusti: !10u8
[03:06:02] -rusti- 245
[03:06:09] <mark_edward> bjz: thanks!
[03:06:24] <Jesse> rusti: !1
[03:06:25] -rusti- -2
[03:06:30] <mark_edward> rusti: !255u8
[03:06:31] -rusti- 0
[03:06:39] <bjz> I don't know if we could use (self) instead of &self, then impl the numerics for bignum on &BigInt
[03:06:51] <bjz> just an idea
[03:07:06] <kemurphy> how would we feel about changing the "etc" syntax for struct patterns from Foo { field: a, _ } to Foo { field: a, * }
[03:07:09] <bjz> jensnockert: ^?
[03:07:17] <kemurphy> for consistency's sake with Foo(*)
[03:07:22] <cmr> kemurphy: yes please!
[03:07:26] <cmr> there's a bug filed about it somewhere
[03:07:29] *** Joins: erickt (Adium@49C4075F.3AC15C18.2321E71E.IP)
[03:07:34] <doomlord> is there a function corresponding to the operaator ! aswell
[03:07:42] <engla> bjz: the generic std::num::sin functions are by value, at least
[03:07:43] <cmr> doomlord: BitNot I think
[03:07:43] <bjz> doomlord: Not
[03:07:46] <cmr> or just Not
[03:07:47] <jensnockert> bjz: I think so.
[03:07:48] <cmr> heh :p
[03:07:52] <bjz> engla: they are
[03:08:04] <jensnockert> engla: That's probably because I wrote them.
[03:08:12] <kemurphy> cmr: think you can dig up the issue number for me?
[03:08:25] <engla> jensnockert: because you want it that way you mean?
[03:08:25] <bjz> jensnockert: do you think that might be a good idea?
[03:08:37] <bjz> jensnockert: the &s a bloody ugly
[03:08:40] <bjz> *are
[03:08:44] <jensnockert> engla: Yes, but my point is that it doesn't prove anything either way.
[03:08:58] <jensnockert> bjz: Yes, and not being able to call them on a constant is fugly.
[03:09:20] <engla> jensnockert: I don't think you had any choice!  1.sin()  autoborrows, but num::sin(&1) would be..
[03:09:22] <jensnockert> I think most numeric types will be really small.
[03:09:22] <bjz> wow, really?
[03:09:31] <engla> (needs a float but you get it)
[03:09:57] <jensnockert> engla: Yeah, but that is essentially what we are discussing, some of the other ones take arguments just like that.
[03:10:02] <bjz> rusti: static X: float: 3.0; X.sin()
[03:10:03] -rusti- <anon>:5:26: 5:29 error: expected `=` but found `3.0`
[03:10:03] -rusti- <anon>:5          static X: float: 3.0; X.sin()
[03:10:03] -rusti-                                    ^~~
[03:10:03] -rusti- application terminated with error code 101
[03:10:10] <bjz> rusti: static X: float = 3.0; X.sin()
[03:10:11] -rusti- 0.14112001
[03:10:17] <bjz> :S
[03:10:26] <bjz> jensnockert: ^?
[03:10:36] <jensnockert> bjz: I meant constants such asâ€¦
[03:10:58] <jensnockert> rusti: 0.5.clamp(0.0, 1.0)
[03:10:59] -rusti- more than 5 lines of output, pastebinned: http://sprunge.us/GUaB
[03:11:16] <jensnockert> rusti: 0.5f32.clamp(0.0, 1.0)
[03:11:18] -rusti- more than 5 lines of output, pastebinned: http://sprunge.us/NCZE
[03:11:29] <engla> clamp takes &Self, &Self
[03:11:36] <jensnockert> engla: My point exactly.
[03:11:57] <jensnockert> engla: But taking Self, Self would make the interface much nicer.
[03:12:11] <strcat> jensnockert: except there are big integers
[03:12:14] <strcat> and that's a big no-no
[03:12:24] <strcat> it will be optimized properly for all kinds of integers as it is right now
[03:12:52] <engla> can the literals be autoborrowed?
[03:13:04] <strcat> we don't have auto-borrow except for methods
[03:13:14] <strcat> as in the self param
[03:13:15] <jensnockert> strcat: Yeah, but we take a performance hit on non-pointer types now :S
[03:13:16] <bjz> strcat: we impl them on &BigInt
[03:13:22] <strcat> jensnockert: no, we don't
[03:13:25] <strcat> there's no performance hit
[03:13:28] <strcat> it optimizes out
[03:13:42] <strcat> a copy of a big integer won't
[03:13:59] <bjz> strcat: is what I was saying beofre
[03:14:12] <bjz> impl Integer for &BigInt
[03:14:25] <strcat> bjz: and now the ones return Self don't work
[03:14:37] <bjz> ugh true
[03:14:40] <strcat> also you can't do that anymore afaik
[03:14:53] <engla> associated types? :)
[03:15:07] <strcat> rusti: struct Foo; impl TotalEq for Foo { fn equals(&self) -> bool { true } }
[03:15:08] -rusti- <anon>:5:44: 5:77 error: method `equals` has 0 parameters but the trait has 1
[03:15:08] -rusti- <anon>:5          struct Foo; impl TotalEq for Foo { fn equals(&self) -> bool { true } }
[03:15:09] -rusti-                                                      ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
[03:15:09] -rusti- error: aborting due to previous error
[03:15:10] -rusti- application terminated with error code 101
[03:15:31] <strcat> rusti: struct Foo; impl TotalEq for Foo { fn equals(&self, _: &Foo) -> bool { true } }
[03:15:32] -rusti- ()
[03:15:36] <doomlord> paths: i dont seem to get typeinfo for those
[03:15:40] <strcat> rusti: struct Foo; impl TotalEq for &Foo { fn equals(&self, _: & &Foo) -> bool { true } }
[03:15:40] -rusti- <anon>:5:38: 5:42 error: Illegal anonymous lifetime: anonymous lifetimes are not permitted here
[03:15:40] -rusti- <anon>:5          struct Foo; impl TotalEq for &Foo { fn equals(&self, _: & &Foo) -> bool { true } }
[03:15:40] -rusti-                                                ^~~~
[03:15:40] -rusti- error: aborting due to previous error
[03:15:41] -rusti- application terminated with error code 101
[03:15:51] <strcat> rusti: struct Foo; impl<'self> TotalEq for &'self Foo { fn equals(&self, _: & &Foo) -> bool { true } }
[03:15:52] -rusti- ()
[03:15:59] * strcat forgets what it is that's forbidden now
[03:16:01] <jensnockert> strcat: How can we optimise away the copy-to-memory without inlining?
[03:16:18] *** Quits: LU324 (stuff@moz-A17E9A7B.dyn.embarqhsd.net) (Ping timeout)
[03:16:24] <strcat> jensnockert: small functions are inlined automatically by LLVM
[03:16:32] <strcat> large functions aren't going to be slower because you pass by-ref
[03:17:03] <strcat> anyway it does have an argpromotion pass for internal functions
[03:17:10] <strcat> and all generic things are internal atm
[03:17:26] <strcat> there's no performance hit
[03:17:26] <bjz> jensnockert: we could have sin_ref(&T) :P
[03:17:42] <strcat> you don't need double the number of APIs to deal with an imaginary perf hit
[03:17:46] <doomlord> ctxt.node_types.find(&my_node_id) ... that  should get the type data? ... for paths I seem to get 'none'
[03:18:07] <jensnockert> I think we should just allow for auto-borrowâ€¦
[03:18:21] <kemurphy> how would we also feel about allowing things like match foo { (fst, snd, *) => {} }
[03:18:25] <jensnockert> strcat: And interface hit, the current is really surprising.
[03:18:26] <kemurphy> currently only (*) is allowed
[03:18:35] <strcat> jensnockert: it is not surprising, it's the same as C++
[03:18:42] <bjz> kemurphy: would be nice
[03:18:50] <strcat> it would be surprising if it asked for ownership when it didn't need it
[03:19:32] <strcat> jensnockert: http://en.cppreference.com/w/cpp/algorithm/min by-ref, along with all copy constructors and so on
[03:19:40] <strcat> anything generic is by-ref in C++ unless it needs ownership
[03:19:42] <strcat> same as rust
[03:19:43] <doomlord> aha
[03:19:54] <strcat> by-ref means you don't need ownership, by-value means you do
[03:20:11] <jensnockert> strcat: std::min(1, 2) works in C++
[03:20:16] <strcat> jensnockert: yes, it's by-ref
[03:20:25] <strcat> C++ auto-refs parameters
[03:20:30] <jensnockert> Yes, but the important thing is interface /o\
[03:20:35] <jensnockert> I wouldn't mind autoborrowing.
[03:20:42] <strcat> jensnockert: so you see a language flaw and want to make a library flaw too ;p
[03:20:52] <jensnockert> Yes!
[03:21:14] <cmr> lol
[03:21:15] <bjz> :P
[03:21:19] <bjz> fight!
[03:21:57] <strcat> auto-ref for &T with T: Freeze is fine with me ;p
[03:22:09] <doomlord> (it seems there is anther node id for paths which i should be extracting)
[03:22:21] <strcat> don't like the idea of mutable auto-ref
[03:22:22] <bjz> in the red corner, we have Mr Floating Point, jensnockert - in the blue corner, The Iterator, strcat
[03:22:46] <kemurphy> one last proposal: allowing match foo { (2: snd, *) => {} }
[03:22:51] <jensnockert> You should make up more menacing names bjz, like "The Iteratorix"
[03:23:04] <kemurphy> (basically, indexing tuples as if they're a struct with int literals as field names)
[03:23:06] <bjz> :")
[03:24:00] <doomlord> i lost track of which node "path" was burried in..
[03:24:04] <doomlord> i have it wrapped
[03:24:33] <bjz> kemurphy: sounds reasonable
[03:24:49] <strcat> iterators are pretty solid now
[03:24:58] <bjz> kemurphy: you might have to ask a dev though
[03:25:00] <strcat> Extendable is essentially the useful part of an OutputIterator
[03:25:06] *** Quits: tikue (tkuehn@moz-A7CDB794.dia.static.qwest.net) (Quit: tikue)
[03:25:26] <bjz> kemurphy: { a: _, * } is more likely
[03:25:30] <strcat> D itself actually uses InputRanges of mutable refs for the mutation algorithms... no one uses actual OutputRange
[03:25:35] <bjz> kemurphy: not sure about the others
[03:25:35] <strcat> they're silly
[03:25:41] *** Joins: carllerche (carllerche@6B070D22.7E6A0813.1428D117.IP)
[03:27:33] <doomlord> Ty{id:node_id, node: ty_, span}  --->   node: ty_path(Path_,node_id) .... unlike all the other nodes, it has another node id burried inside it,
[03:31:31] *** Joins: ghrust (ghrust@CFE85B59.6A2AE50.F3114085.IP)
[03:31:32] <ghrust> 01[13rust01] 15bors merged 06auto into 06master: 02http://git.io/XivPbA
[03:31:32] *** Parts: ghrust (ghrust@CFE85B59.6A2AE50.F3114085.IP) ()
[03:32:06] <strcat> engla: everything needs an extend impl now too ;p
[03:32:09] <strcat> that should be it though...
[03:32:18] <cmr> Oh poo, I forgot to write up TWiR
[03:32:31] <cmr> AND it's sunday..
[03:32:35] <cmr> oops
[03:32:58] <strcat> last week in rust
[03:33:08] <cmr> heheh
[03:33:23] <strcat> convenient time to change the blog name
[03:33:25] <strcat> :D
[03:33:35] <strcat> and then you can procrastinate for a *whole* other week
[03:33:44] <strcat> then we'll have "two weeks ago in rust"
[03:34:32] *** Joins: ghrust (ghrust@614D05BD.6A2AE50.F3114085.IP)
[03:34:32] <ghrust> 01[13rust01] 15bors pushed 0 new commits to 06auto: 02http://git.io/QMa_9g
[03:34:32] *** Parts: ghrust (ghrust@614D05BD.6A2AE50.F3114085.IP) ()
[03:34:57] <engla> strcat: not possible to refactor that into "with_capacity" + extend and remove FromIterator?
[03:35:19] <engla> not sure if that's general enough
[03:35:39] <strcat> engla: things can only implement Extendable if they're mutable
[03:36:20] *** Quits: jfbk (textual@moz-EEA9CFB3.nyc.res.rr.com) (Quit: My MacBook has gone to sleep. ZZZzzzâ€¦)
[03:36:22] <engla> ok
[03:37:10] <engla> strcat: do you really think that's enough?
[03:37:29] <strcat> well there will be mutable random access iterators and a bunch of default methods to override for some things ;p
[03:37:44] <strcat> but I mean for conversion-from-iterator
[03:37:46] <strcat> that's enough
[03:38:05] <engla> allright
[03:38:43] <engla> what do you think about clonable iterators? It's confusing as it is now since only some are clonable
[03:39:20] <engla> I mean, we can make capture-free closures clonable and solve half the problem while still having a confusing divide of which iterators are clonable
[03:39:29] <engla> but at least all the trivial filters and maps will be
[03:39:31] <strcat> well I think it's important to be able to clone as many as possible
[03:39:40] <strcat> engla: I think the closure thing will get worked out
[03:39:42] <strcat> because of closure reform
[03:39:48] <strcat> closures as they are now as really awful
[03:39:53] <engla> yeah. I wrote some hacky code to clone &'static fn
[03:39:57] <strcat> they're close to unusable in many cases
[03:40:05] <strcat> because there's no actual type for a stack closure
[03:40:12] <strcat> it has to be borrowed immediately
[03:40:18] <engla> right, no value type
[03:40:30] <strcat> depends on dynamically sized types landing I guess
[03:43:07] *** Quits: erickt (Adium@49C4075F.3AC15C18.2321E71E.IP) (Quit: Leaving.)
[03:47:56] *** Quits: carllerche (carllerche@6B070D22.7E6A0813.1428D117.IP) (Quit: carllerche)
[03:49:48] *** Joins: jensnock_ (jensnocker@moz-C5F27039.cust.bredband2.com)
[03:50:20] *** Quits: jensnockert (jensnocker@moz-C5F27039.cust.bredband2.com) (Ping timeout)
[03:51:30] <doomlord> a bit more progress on my find tool, it seems to be finding definitons of structs, functions, locals fine :)
[03:52:18] <doomlord> (but i'm only trying it out within one file at the minute, now i have to figure out how to get other source .. from the crate..)
[03:53:24] <doomlord> my implementation feels rather messy, i dont know if i'm replicating functionality from elsewhere in the compiler. i seem to be wrapping OOP style abstract interfaces over the enum-based ast nodes  a lot.
[03:55:12] <cmr> doomlord: the compiler is by no means perfect
[03:55:32] <cmr> it only implements what was needed within the compikler, in an ad-hoc, organic way
[03:55:42] <doomlord> fair enough :)
[03:56:15] *** zz_kimundi is now known as kimundi
[03:56:52] *** Quits: samx (sami@moz-48EC0983.dyn.optonline.net) (Quit: Leaving)
[04:03:36] <doomlord> any hints on how to get definitoin nodes outside of the compilation unit (i.e: i gave libsyntax a test source file, if i look for a definition of a standard library funcction, can i find the source for the crates it brings in... my 'find-tool' isn't much use if it only works within one sourcefile :):)
[04:04:25] <cmr> doomlord: you can only compile a crate at a time
[04:04:30] <cmr> the compilation unit is a crate
[04:04:59] <cmr> that said, resolve DOES map use of a type to the definition outside of the crate
[04:05:09] <cmr> and I *think* crates include spans  in their mnetadata...
[04:05:12] <doomlord> i certainly see node references
[04:05:14] <cmr> in theory it should all work?
[04:05:25] <doomlord> i'll pastebin my debug output
[04:05:35] <cmr> probably best ask graydon or pcwalton tomorrow
[04:05:49] <doomlord> ok.  I wonder if i'll end up having to write an indexer
[04:06:08] *** Joins: alisdair (textual@1697D94C.7742FB18.FBC8476D.IP)
[04:06:29] *** Quits: Nefzaoui (chatzilla@5F4647F0.8844F160.7D0E51E.IP) (Quit: ChatZilla 0.9.90.1 [Firefox 22.0/20130618035212])
[04:09:38] *** Joins: Diamond (dick@moz-C01E1CD1.ks.ks.cox.net)
[04:10:24] <doomlord> http://pastebin.com/8CsfyQ2Z <<< it seems to find something in the def_map
[04:11:36] <strcat> could remove push_all...
[04:11:58] <strcat> xs.push_all(vector) -> xs.extend(any_iterator)
[04:12:11] <strcat> some cases would need a .map(clone) though
[04:13:14] <strcat> most use cases of push_all are code smell
[04:13:20] <strcat> they're copies when they don't need to be
[04:14:27] <Luqman> doomlord: i think you'd have to use librustc to do that
[04:16:13] <strcat> you need librustc to resolve
[04:16:17] <strcat> libsyntax just parses
[04:16:42] <doomlord> i think the code i copied from rustdoc_ng is compiling something
[04:16:52] <doomlord> https://github.com/dobkeratops/rustfind/blob/master/main.rs
[04:17:24] <Luqman> doomlord: so looking in def_map would give you a def_id and ast_util::is_local would tell you whether you might need to search other crattes with something like csearch::maybe_get_item_ast
[04:17:28] <doomlord> 'get_ast_and_resolve { ...   let (crate,tycx)=driver::driver::compile_upto(...)
[04:17:31] *** Joins: carllerche (carllerche@6B070D22.7E6A0813.1428D117.IP)
[04:18:24] <strcat> Luqman: how did your attempt at fixing that method resolve issue go? ;p
[04:19:23] <Luqman> strcat: not very well sadly, hit lots of resolve errors while trying to build libstd with the patch
[04:22:00] *** Quits: Nisstyre (wes@moz-FD86289.netflash.net) (Quit: Leaving)
[04:22:01] <Luqman> doomlord: also, re: your comment above AstNode there is syntax::ast_map::ast_node
[04:22:24] *** Quits: Kruppe (user@moz-E150F49F.cpe.net.cable.rogers.com) (Client exited)
[04:22:56] <doomlord> trait ast_node , ... has some of the accessors i was after?
[04:23:10] <doomlord> ah, enum ast_node aswell
[04:25:11] <doomlord> it has fewer cases- will that still suit me, since not all the cases seemed to have the ability to get a node_id/span .... i looked at what the visitor stepped through
[04:25:52] *** Joins: maikklein (maik@moz-EDC31EF0.dip0.t-ipconnect.de)
[04:27:44] <Luqman> doomlord: i think it's just that your's kinda duplicates a bit
[04:28:21] <doomlord> trait ast_node also looks like its solving problems i had, abstract accessors for node_id, span
[04:29:15] *** Joins: paupau (textual@417F0514.289B9BF9.F20F0C5A.IP)
[04:30:05] <bjz> dbaupp: is this correct - work out if all elements are zero? self.iter().transform(|x| x.is_zero()).fold(true, |a, b| a && b)
[04:30:21] <bjz> rusti: [0, 0, 0].iter().transform(|x| x.is_zero()).fold(true, |a, b| a && b)
[04:30:23] -rusti- <anon>:5:40: 5:52 error: type `&int` does not implement any method in scope named `is_zero`
[04:30:23] -rusti- <anon>:5          [0, 0, 0].iter().transform(|x| x.is_zero()).fold(true, |a, b| a && b)
[04:30:23] -rusti-                                                  ^~~~~~~~~~~~
[04:30:23] -rusti- error: aborting due to previous error
[04:30:24] -rusti- application terminated with error code 101
[04:30:31] *** Joins: snadon (chatzilla@moz-3BC727E8.mc.videotron.ca)
[04:30:35] <bjz> rusti: [0, 0, 0].iter().transform(|&x| x.is_zero()).fold(true, |a, b| a && b)
[04:30:36] -rusti- <anon>:5:41: 5:53 error: type `int` does not implement any method in scope named `is_zero`
[04:30:37] -rusti- <anon>:5          [0, 0, 0].iter().transform(|&x| x.is_zero()).fold(true, |a, b| a && b)
[04:30:37] -rusti-                                                   ^~~~~~~~~~~~
[04:30:37] -rusti- error: aborting due to previous error
[04:30:37] -rusti- application terminated with error code 101
[04:30:48] <geomyidae> wah wah
[04:30:56] <bjz> rusti: use std::num::Zero; [0, 0, 0].iter().transform(|x| x.is_zero()).fold(true, |a, b| a && b)
[04:31:00] -rusti- more than 5 lines of output, pastebinned: http://sprunge.us/PhKS
[04:31:18] <bjz> :S
[04:31:27] <bjz> strcat: ^
[04:31:31] <geomyidae> is that a bug?
[04:31:52] <strcat> it's a lack of a feature
[04:31:54] *** Joins: lucian (lucian@moz-22A14C6A.cable.virginmedia.com)
[04:31:56] <strcat> bjz: need a temporary for [0, 0, 0]
[04:32:00] <bjz> rusti: use std::num::Zero; let v = [0, 0, 0]; v.iter().transform(|x| x.is_zero()).fold(true, |a, b| a && b)
[04:32:01] -rusti- true
[04:32:03] <strcat> bjz: because rvalue lifetimes aren't extended
[04:32:09] <bjz> rusti: use std::num::Zero; let v = []; v.iter().transform(|x| x.is_zero()).fold(true, |a, b| a && b)
[04:32:11] -rusti- more than 5 lines of output, pastebinned: http://sprunge.us/TCSf
[04:32:25] <bjz> rusti: use std::num::Zero; let v: ~[int] = ~[]; v.iter().transform(|x| x.is_zero()).fold(true, |a, b| a && b)
[04:32:26] -rusti- true
[04:32:32] <strcat> bjz: btw there are any/all
[04:32:42] <Luqman> use std::num::Zero; let x = [0, 0, 1]; x.iter().all(|&x| x.is_zero())
[04:32:47] <Luqman> rusti: use std::num::Zero; let x = [0, 0, 1]; x.iter().all(|&x| x.is_zero())
[04:32:47] -rusti- false
[04:32:53] <Luqman> rusti: use std::num::Zero; let x = [0, 0, 0]; x.iter().all(|&x| x.is_zero())
[04:32:54] -rusti- true
[04:32:57] <doomlord> does  "ast_node" encompass the case Ty  (i have AstNode::astnode_yt(@Ty) - i was confused exactly how the visitor works, does it optionally drill down into some nodes? are the " Ty" nodes i see also held within 'node_item/node-expr' or omething
[04:33:15] <bjz> use std::num::Zero; let x: ~[int] = ~[]; x.iter().all(|&x| x.is_zero())
[04:33:26] <strcat> and any/all will stop iterating ASAP
[04:33:28] <bjz> rusti: use std::num::Zero; let x: ~[int] = ~[]; x.iter().all(|&x| x.is_zero())
[04:33:29] -rusti- true
[04:33:34] <bjz> oh cool
[04:33:35] *** Quits: lucian (lucian@moz-22A14C6A.cable.virginmedia.com) (Ping timeout)
[04:33:54] <bjz> strcat: yeah, I thought it would return false on a non-empty list
[04:34:04] <bjz> sorry, an empty list
[04:34:19] <bjz> rusti: use std::num::Zero; let x: ~[int] = ~[]; x.iter().all(|x| x.is_zero())
[04:34:19] -rusti- true
[04:34:27] <strcat> well, 'all' is true for an empty list and 'any' is false ;]
[04:34:32] <sp3d> :D
[04:34:33] <Luqman> doomlord: yes
[04:34:49] <klutzy> I'm getting "error: unresolved name" error for std::ptr::null() if the code is in other crate and imported (mod other)
[04:35:06] <klutzy> is it known and/or issued?
[04:35:08] <Luqman> doomlord: there is node_item(@item, @path) and one variant of item is item_ty(Ty, Generics)
[04:35:18] <strcat> klutzy: known issue, need 'use std;'
[04:35:49] <bjz> rusti: use std::num::Zero; let x: ~[int] = ~[]; x.iter().all(|x| x.is_zero())
[04:35:49] -rusti- true
[04:35:52] <bjz> woops
[04:35:54] <klutzy> strcat: ah, i forgot to try it. thanks!
[04:36:10] <Luqman> bjz: vacuous truths :P
[04:36:17] <maikklein> does Rust already work on ARM?
[04:36:21] <bjz> Luqman: ?
[04:36:29] <geomyidae> I thought it didn't initialize to zeros by default?
[04:36:51] <Luqman> bjz: all would always be true if the input is empty
[04:36:51] <geomyidae> I thought this came up the other day on hn or reddit
[04:37:21] <Luqman> maikklein: there is arm support yes
[04:37:41] <strcat> geomyidae: it's not initializing anything to zero by default there
[04:37:41] <Luqman> maikklein: though just android and linux right now
[04:38:07] <bjz> Luqman: I'm redoing the vectors (again) https://gist.github.com/bjz/f46dbbb0397d5e443754
[04:38:29] <maikklein> Luqman, okay nice, I get my raspberry Pi tomrrow. 
[04:38:51] <aatch> all bails out early, so assumes true until see's false.
[04:38:57] <maikklein> then I can have some rustypi fun
[04:39:09] <klutzy> strcat: it works if I only use "mod other", but I'm getting more curious errors if I put "use other::*;" at main.rs
[04:39:26] <maikklein> has chrismorgan made his tcp server public?
[04:39:30] <aatch> rusti: use std::num::Zero; let x: ~[int] = ~[]; x.iter().any(|x| x.is_zero()) // Returns false
[04:39:31] -rusti- false
[04:39:33] <Luqman> maikklein: cool, so you'd need to setup rust so it can cross compile for it. the target would be arm-unknown-linux-gnueabihf
[04:40:01] <maikklein> Luqman, okay thanks
[04:40:31] <bjz> Luqman: hah http://en.wikipedia.org/wiki/Vacuous_truth
[04:40:55] <strcat> bjz: if only I could actually write Iterable ;p
[04:41:01] <strcat> hits all kinds of 'self bugs
[04:41:03] <strcat> and other issues
[04:41:08] <bjz> strcat?
[04:41:25] <strcat> could have any, all, foldl, etc. as default methods on all containers
[04:41:41] <strcat> by reusing the iterator impl
[04:41:45] <geomyidae> strcat: I don't understand then, why is it true?
[04:42:01] <strcat> geomyidae: don't know where you're seeing zeroing
[04:42:05] <maikklein> rusti: use std::num::Zero; let x: ~[int] = ~[]; x.iter().any(|x| x.is_zero())
[04:42:05] -rusti- false
[04:42:06] <geomyidae> oh, it's just empty, sorry
[04:42:07] <engla> geomyidae: it's an empty vector
[04:42:30] <geomyidae> use std::num::Zero; let x: ~[int] = ~[0,0,0]; x.iter().any(|x| x.is_zero())
[04:42:49] * geomyidae opens rusti locally
[04:43:20] <bjz> geomyidae: you need to put `rusti:` before
[04:43:42] <bjz> rusti is the bot
[04:44:19] <doomlord> damn i must sleep now
[04:45:27] <bjz> doomlord: sleeping is for quitters
[04:45:49] <maikklein> :D
[04:46:05] *** Joins: ross (ross@moz-8A84103E.br.br.cox.net)
[04:46:13] <bjz> doomlord: who needs the dream world to help process stuff subconciously
[04:46:29] <bjz> just power through the delerium
[04:46:30] *** Quits: doomlord (doomlod@moz-13E69BC8.range86-180.btcentralplus.com) (Ping timeout)
[04:46:33] <bjz> x)
[04:47:09] <bjz> (gotta love reverse psychology)
[04:47:22] <maikklein> we don't need to sleep because we can't seqfault
[04:47:34] <geomyidae> bjz: I just didn't want to spam since I'm going to make 10,000 mistakes :)
[04:47:41] <bjz> heh
[04:47:53] <aatch> geomyidae, you can also send rusti private messages
[04:48:02] <maikklein> rusti: use std::num::Zero; let x: ~[int] = ~[0,0,0]; x.iter().any(|x| x.is_zero())
[04:48:04] -rusti- true
[04:48:17] <maikklein> rusti: use std::num::Zero; let x: ~[int] = ~[0,1,0]; x.iter().any(|x| x.is_zero())
[04:48:18] -rusti- true
[04:48:42] <geomyidae> :/
[04:48:46] *** Quits: carllerche (carllerche@6B070D22.7E6A0813.1428D117.IP) (Quit: carllerche)
[04:48:49] <maikklein> ?
[04:49:34] <strcat> the implementation of those is pretty trivial, they're just 2 lines ;p
[04:50:27] <aatch> the second one is still any
[04:50:40] <aatch> it has at least one zero, therefore, true
[04:51:11] <aatch> rusti: use std::num::Zero; let x: ~[int] = ~[0,1,0]; x.iter().any(|x| { println(x.to_str()); x.is_zero())
[04:51:12] -rusti- <anon>:5:106: 5:107 error: incorrect close delimiter: `)`
[04:51:12] -rusti- <anon>:5          use std::num::Zero; let x: ~[int] = ~[0,1,0]; x.iter().any(|x| { println(x.to_str()); x.is_zero())
[04:51:12] -rusti-                                                                                                                    ^
[04:51:12] -rusti- application terminated with error code 101
[04:51:16] <maikklein> so any basically translates to "it exists at least one thing that ..."
[04:51:17] <aatch> rusti: use std::num::Zero; let x: ~[int] = ~[0,1,0]; x.iter().any(|x| { println(x.to_str()); x.is_zero()})
[04:51:19] -rusti- 0
[04:51:19] -rusti- true
[04:51:30] <aatch> rusti: use std::num::Zero; let x: ~[int] = ~[0,1,0]; x.iter().all(|x| { println(x.to_str()); x.is_zero()})
[04:51:32] -rusti- 0
[04:51:32] -rusti- 1
[04:51:32] -rusti- false
[04:51:54] <maikklein> oO
[04:51:58] <strcat> just look at the implementation
[04:52:03] <strcat>     fn all(&mut self, f: &fn(A) -> bool) -> bool {
[04:52:05] <strcat>         for self.advance |x| { if !f(x) { return false; } }
[04:52:07] <strcat>         true
[04:52:09] <strcat>     }
[04:52:19] *** Quits: enix (enix@moz-A50569DD.c3-0.slvr-ubr1.lnh-slvr.md.cable.rcn.com) (Quit: Konversation terminated!)
[04:52:21] <strcat>     fn any(&mut self, f: &fn(A) -> bool) -> bool {
[04:52:21] <aatch> it short circuits.
[04:52:23] <strcat>         for self.advance |x| { if f(x) { return true; } }
[04:52:25] <strcat>         false
[04:52:27] <strcat>     }
[04:52:33] <aatch> no point checking all of them if you already know the answer.
[04:53:01] <geomyidae> jesus, I literally just can't read, or I'll blame dyslexia
[04:53:03] <geomyidae> or something
[04:53:09] <geomyidae> dear brain, s/any/all
[04:55:45] <bjz> strcat: is it possible to do a zip that rather than truncating, uses a default value?
[04:56:17] <strcat> bjz: chain one iterator with an infinite iterator returning a default
[04:56:25] <strcat> but... we don't have a repeat iterator yet
[04:56:51] <strcat> zip(xs.chain(repeat(5)), ys)
[04:56:54] <strcat> or something similar to that
[04:56:59] <bjz> strcat: I mean, say I have ~[1, 2, 4] and ~[1]
[04:58:31] *** Quits: Jesse (jruderman@moz-537BCF9.hsd1.ca.comcast.net) (Quit: Jesse)
[04:59:36] <strcat> bjz: not really an easy way without repeat
[04:59:42] <strcat> or writing an adaptor yourself
[05:01:06] <strcat> bjz: well
[05:01:10] <strcat> bjz: repeat is easy to write actually
[05:01:25] <engla> by the way, maybe the .zip method on 2-tuples (pairs) should be removed
[05:01:30] <strcat> let x = [5]; x.cycle()
[05:02:52] <strcat> rusti: let xs = [1, 2, 3]; let ys = [4]; let z = [5]; for xs.iter().zip(ys.iter().chain(z.iter().cycle())).advance |(x, y)| { printfln("%? %?", x, y) }
[05:02:54] -rusti- line longer than 150 columns, pastebinned: http://sprunge.us/MFMK
[05:03:02] <strcat> rusti: let xs = [1, 2, 3]; let ys = [4]; let z = [5]; for xs.iter().zip(ys.iter().chain(z.iter().cycle())).advance |(x, y)| { printfln!("%? %?", x, y) }
[05:03:04] -rusti- more than 5 lines of output, pastebinned: http://sprunge.us/TEja
[05:03:14] <strcat> rusti: let xs = [1, 2, 3]; let ys = [4]; let z = [5]; for xs.iter().zip(ys.iter().chain_(z.iter().cycle())).advance |(x, y)| { printfln!("%? %?", x, y) }
[05:03:15] -rusti- more than 5 lines of output, pastebinned: http://sprunge.us/OjTi
[05:03:25] * strcat sighs
[05:03:34] <geomyidae> can I make a  bot that translates "more than 5 lines" and "line longer than 150 columns" to just emit "FAIL" and nothing ele.
[05:03:40] <strcat> rusti: use std::iterator::*; let xs = [1, 2, 3]; let ys = [4]; let z = [5]; for xs.iter().zip(ys.iter().chain_(z.iter().cycle())).advance |(x, y)| { printfln!("%? %?", x, y) }
[05:03:42] -rusti- &1 &4
[05:03:42] -rusti- &2 &5
[05:03:42] -rusti- &3 &5
[05:03:42] -rusti- ()
[05:03:56] <strcat> anyway we need repeat(x)
[05:04:06] <strcat> repeat(5) -> &5 &5 &5 &5
[05:04:13] <engla> this pattern requires you to know which of the iterators is shorter
[05:04:25] <strcat> engla: you can chain both, if you want a default for both
[05:04:31] <maikklein> rusti: 5.repeat(5)
[05:04:32] -rusti- <anon>:5:9: 6:5 error: type `<VI0>` does not implement any method in scope named `repeat`
[05:04:32] -rusti- <anon>:5          5.repeat(5)
[05:04:32] -rusti- <anon>:6     };
[05:04:32] -rusti- error: aborting due to previous error
[05:04:32] -rusti- application terminated with error code 101
[05:04:36] <strcat> but they could be different types
[05:04:46] <engla> strcat: chain with a cycle and you get... an infinite iterator
[05:04:49] <engla> that's not good
[05:04:50] *** Quits: bytbox (s@moz-DC83764A.washdc.fios.verizon.net) (Quit: Lost terminal)
[05:04:59] <engla> if you do it on both sides
[05:05:07] <strcat> engla: true ;]
[05:05:16] <strcat> I guess you'd have to pass 2 defaults to a zip fn
[05:05:20] *** Joins: jensnockert (jensnocker@moz-8BE55278.customer.t3.se)
[05:05:27] <strcat> or just... make an ad-hoc adaptor
[05:05:42] *** Quits: jensnock_ (jensnocker@moz-C5F27039.cust.bredband2.com) (Ping timeout)
[05:06:44] *** Quits: maikklein (maik@moz-EDC31EF0.dip0.t-ipconnect.de) (Ping timeout)
[05:08:01] <Mindless`> is there a way to get a stack trace for a failed test in the test runner?
[05:08:59] *** Joins: carllerche (carllerche@6B070D22.7E6A0813.1428D117.IP)
[05:11:56] *** Joins: dherman (dherman@moz-6CA476B1.hsd1.ca.comcast.net)
[05:11:56] *** ChanServ sets mode: +o dherman
[05:12:24] *** Joins: thpickert (thpickert@moz-34341F25.dynamic.dsl.tng.de)
[05:19:25] *** Quits: carllerche (carllerche@6B070D22.7E6A0813.1428D117.IP) (Quit: carllerche)
[05:19:31] *** Joins: ghrust (ghrust@614D05BD.6A2AE50.F3114085.IP)
[05:19:31] <ghrust> 01[13rust01] 15bors merged 06auto into 06master: 02http://git.io/de9nGg
[05:19:31] *** Parts: ghrust (ghrust@614D05BD.6A2AE50.F3114085.IP) ()
[05:22:37] *** Joins: ghrust (ghrust@F6EE6DE3.6A2AE50.F3114085.IP)
[05:22:37] <ghrust> 01[13rust01] 15bors pushed 0 new commits to 06auto: 02http://git.io/z_0hoQ
[05:22:37] *** Parts: ghrust (ghrust@F6EE6DE3.6A2AE50.F3114085.IP) ()
[05:26:52] *** Joins: carllerche (carllerche@6B070D22.7E6A0813.1428D117.IP)
[05:28:04] *** Quits: paupau (textual@417F0514.289B9BF9.F20F0C5A.IP) (Ping timeout)
[05:28:43] *** Joins: Jeaye (Jeaye@moz-FD505E54.hsd1.ca.comcast.net)
[05:28:53] *** Quits: thpickert (thpickert@moz-34341F25.dynamic.dsl.tng.de) (Quit: thpickert)
[05:34:17] *** Quits: strcat (strcat@moz-54F7FD49.cpe.net.cable.rogers.com) (Quit: sleep)
[05:35:21] *** Quits: tautologico (shung@5249C163.AFE3D52.7B974E06.IP) (Ping timeout)
[05:40:28] <mark_edward> how would initialize a struct with a member of type [0u8, ..24]?
[05:43:07] <mark_edward> engla: do you now?
[05:43:11] <mark_edward> *know
[05:44:28] *** Quits: ross (ross@moz-8A84103E.br.br.cox.net) (Quit: )
[05:44:29] *** kimundi is now known as zz_kimundi
[05:47:26] *** Joins: sebcrozet (sebcrozet@moz-2517AE39.w80-13.abo.wanadoo.fr)
[05:51:08] *** Joins: recrack (Mibbit@B4104EBB.3CC170B1.1E14B209.IP)
[05:53:48] *** Quits: Diamond (dick@moz-C01E1CD1.ks.ks.cox.net) (Ping timeout)
[05:57:12] *** Joins: thpickert (thpickert@moz-24816453.tng.de)
[05:59:21] *** Quits: Jeaye (Jeaye@moz-FD505E54.hsd1.ca.comcast.net) (Ping timeout)
[06:00:48] <Luqman> mark_edward: that's not a type though :P
[06:00:55] *** Quits: ab (alex@BC9D99CC.37C1012D.FE617B51.IP) (Ping timeout)
[06:00:58] <mark_edward> Luqman: it isn't?
[06:01:15] <geomyidae> I know someone's working on an http server, is anyone working on a new client?
[06:01:16] <Luqman> [u8, ..24] would be the type
[06:01:45] <mark_edward> Luqman: oh right! well i figured it out, my first guess worked
[06:04:24] *** Quits: reyre (reyre@moz-9002CDDA.cpe.net.cable.rogers.com) (Ping timeout)
[06:11:58] *** Quits: noj (jon@moz-D51AE9DE.swym.se) (Ping timeout)
[06:12:16] <olsonjeffery> geomyidae: this is the server: https://github.com/fread2281/rust-http/ <-- the owner is ChrisMorgan in the irc channel
[06:12:59] *** Quits: carllerche (carllerche@6B070D22.7E6A0813.1428D117.IP) (Quit: carllerche)
[06:13:11] <olsonjeffery> no one's really talked about a client, but they said that a client could be built out of the basic components there
[06:13:16] <geomyidae> wait, is that master or doesn't he have a repo somewhere else?
[06:13:33] <geomyidae> I'm trying to learn rust and work on a pam/gorilla-mux sorta thing
[06:13:40] <aatch> olsonjeffery, I don't think that's Chris
[06:13:45] <geomyidae> client was just a curiosity.
[06:13:52] <olsonjeffery> aatch: oh, really? well, my mistake then.
[06:14:01] <olsonjeffery> ah, you're right.
[06:14:05] <olsonjeffery> that's right, that's right.
[06:14:07] <aatch> olsonjeffery, I think Chris has his stuff hosted on his own server.
[06:14:08] <olsonjeffery> it was an mercurial server
[06:14:10] <olsonjeffery> yes, yes.
[06:14:18] <olsonjeffery> http://hg.chrismorgan.info/rusthttpserver
[06:14:39] <aatch> Last Commit: 18 Hours Ago
[06:14:57] *** Joins: noj (jon@moz-D51AE9DE.swym.se)
[06:15:59] *** Joins: jaen (jaen@moz-E0979827.copit.pl)
[06:16:02] <sp3d> bg; disown; unset HISTFILE; exit
[06:16:09] <aatch> sp3d, heh
[06:16:26] <aatch> you do that frequently...
[06:16:32] <sp3d> ugh
[06:16:34] <sp3d> damnit.
[06:16:41] <aatch> You need this: ^Z
[06:16:56] <sp3d> I need to fix a stupid keybind that shouldn't've existed in the first place
[06:18:10] <sp3d> there, shouldn't happen anymore :/
[06:19:40] *** Joins: reyre (reyre@moz-9002CDDA.cpe.net.cable.rogers.com)
[06:28:18] *** Quits: tiffany (kawaii@moz-EB8B0C08.dhcp.embarqhsd.net) (Ping timeout)
[06:34:21] *** Joins: doomrobo (doomrobo@EC9C662A.161AAEB2.58B1C2DD.IP)
[06:34:22] <doomrobo> hiya
[06:34:55] *** Joins: webber46 (webber46@moz-98D2F3C5.cust.bredband2.com)
[06:35:09] *** Quits: webber46 (webber46@moz-98D2F3C5.cust.bredband2.com) (Quit: webber46)
[06:37:17] *** Quits: alisdair (textual@1697D94C.7742FB18.FBC8476D.IP) (Quit: My MacBook Pro has gone to sleep. ZZZzzzâ€¦)
[06:40:49] <geomyidae> when is the rt::io::file stuff going to be worked on, is that known?
[06:47:29] <geomyidae> even brson's io branch is https://github.com/brson/rust/blob/io/src/libstd/rt/io/file.rs fail!()!
[06:48:00] <olsonjeffery> yeah.
[06:48:09] <olsonjeffery> it needs to be wired up to what's in rt::uv::file
[06:57:29] *** Quits: rusti (rusti@moz-54F7FD49.cpe.net.cable.rogers.com) (Ping timeout)
[06:57:37] *** Quits: engla (engla@moz-DBD1D96E.cust.bredbandsbolaget.se) (Ping timeout)
[06:57:51] *** Joins: rusti (rusti@moz-54F7FD49.cpe.net.cable.rogers.com)
[06:58:32] <mark_edward> the range covered by vec.slice(begin, end) is [begin, end) right?
[07:00:18] *** Quits: doomrobo (doomrobo@EC9C662A.161AAEB2.58B1C2DD.IP) (Quit: This computer has gone to sleep)
[07:00:26] <dbaupp> mark_edward: yes
[07:00:32] <mark_edward> dbaupp: thanks!
[07:06:12] *** Joins: Ms2ger (Ms2ger@E39D6ADF.6D359A20.187A1082.IP)
[07:07:36] *** Quits: victorporof (victorporo@AF497F7E.60E0D239.9B1E38F4.IP) (Quit: victorporof)
[07:13:44] *** Joins: ghrust (ghrust@C8693FCB.6A2AE50.F3114085.IP)
[07:13:44] <ghrust> 01[13rust01] 15bors pushed 0 new commits to 06auto: 02http://git.io/z_0hoQ
[07:13:44] *** Parts: ghrust (ghrust@C8693FCB.6A2AE50.F3114085.IP) ()
[07:13:46] *** Joins: ghrust (ghrust@1E8607E8.6A2AE50.F3114085.IP)
[07:13:46] <ghrust> 01[13rust01] 15bors pushed 68 new commits to 06auto: 02http://git.io/y1899w
[07:13:46] <ghrust> 13rust/06auto 148b8e801 15John Clements: disallow ident equality checks when contexts are not equal
[07:13:46] <ghrust> 13rust/06auto 14acad959 15John Clements: rename resolve to mtwt_resolve
[07:13:46] <ghrust> 13rust/06auto 14457048f 15John Clements: ident->name
[07:13:47] *** Parts: ghrust (ghrust@1E8607E8.6A2AE50.F3114085.IP) ()
[07:24:29] <dbaupp> cmr: ping
[07:25:39] *** Quits: jaen (jaen@moz-E0979827.copit.pl) (Ping timeout)
[07:33:59] *** Joins: mcclurmc (mcclurmc@moz-8D61EFD1.cable.virginmedia.com)
[07:36:28] *** Quits: gavinb (gavinb@moz-CA19A0CF.vic.adsl.internode.on.net) (Quit: gavinb)
[07:37:00] *** Joins: doomlord (doomlod@moz-13E69BC8.range86-180.btcentralplus.com)
[07:43:11] *** Quits: jmgrosen (jmgrosen@moz-848F6087.sb.sd.cox.net) (Quit: jmgrosen)
[07:43:28] *** Quits: jensnockert (jensnocker@moz-8BE55278.customer.t3.se) (Input/output error)
[07:43:56] *** Joins: heftig (heftig@6835D69C.6FC4DE2F.FEC4A986.IP)
[07:44:49] *** Joins: Diamond (dick@moz-C01E1CD1.ks.ks.cox.net)
[07:46:48] *** Joins: doener (bs@moz-AA189A5A.unitymedia.biz)
[07:47:57] *** Joins: orshem (orshem@C5E06B1E.A5B6B765.E3D28531.IP)
[07:49:53] *** Joins: xraycat (Adium@moz-4F58939A.pool.mediaways.net)
[07:50:27] *** Joins: jensnockert (jensnocker@moz-C5F27039.cust.bredband2.com)
[07:51:29] *** Quits: StarLight (StarLight@moz-49A655B2.dynamic.avangarddsl.ru) (Ping timeout)
[07:52:56] *** Joins: doomrobo (doomrobo@EC9C662A.161AAEB2.58B1C2DD.IP)
[07:53:00] *** Quits: dherman (dherman@moz-6CA476B1.hsd1.ca.comcast.net) (Quit: dherman)
[07:53:55] <doomrobo> hey, I have a function that returns either a uniquely owned value or a shared identifier. Is there any way to make the return type show that?
[07:55:45] <shachaf> Hmm, does Either not work for that?
[07:59:43] <doomrobo> what's Either?
[08:00:18] <doomrobo> do you mean Option?
[08:00:50] <doomlord> Either<T,U> {Left(T),Right(U)} 
[08:01:19] <doomlord> seems to be in the spirit of option 
[08:01:50] <dbaupp> rusti: fn x_or_y() -> Either<~[int], @str> { Left(~[1,2]) } x_or_y()
[08:01:51] -rusti- Left(~[1, 2])
[08:02:02] <dbaupp> rusti: fn x_or_y() -> Either<~[int], @str> { Right(@"foo") } x_or_y()
[08:02:03] -rusti- Right(@"foo")
[08:02:35] <doomrobo> cool, that should work
[08:03:20] <doomrobo> There is a *lot* missing from the Rust Tutorial
[08:03:34] *** Joins: dherman (dherman@moz-6CA476B1.hsd1.ca.comcast.net)
[08:03:35] *** ChanServ sets mode: +o dherman
[08:04:30] <yuriks> it took me a good while to figure out how to do a range for loop :)
[08:05:18] <doomrobo> is there any way to `typedef` something? Suppose I want to make    CustomType = Either<int, ~str>
[08:05:56] *** Joins: BizarreCake (BizarreCak@moz-361FE9B2.dynamic.barak-online.net)
[08:06:48] <doomrobo> also, is there a way to ensure certain values are precomputed at compile time? I see that you can define a static global variable as something like 1+2, is that guaranteed to be calculated at compile time or runtime?
[08:06:49] *** Joins: pnkfelix (pnkfelix@87C1F78E.1DE10CA8.D8E68FF6.IP)
[08:07:52] <aatch> doomrobo, static variables are always constant
[08:08:07] <aatch> There's no static initialization in Rust
[08:08:08] *** Quits: jensnockert (jensnocker@moz-C5F27039.cust.bredband2.com) (Input/output error)
[08:08:31] <aatch> (As in no before-main initialization, not that the User can really control)
[08:10:54] <doomrobo> rusti: static x: int = 1+2; println(fmt!("%?", x));
[08:10:55] -rusti- 3
[08:10:56] -rusti- ()
[08:11:14] <doomrobo> so is + not a function?
[08:11:19] <aatch> doomrobo, nope.
[08:11:27] <aatch> doomrobo, Rust is not a lisp
[08:11:39] <aatch> the only things that are functions are, well, functions
[08:11:59] <doomrobo> you can't overload operators in Rust?
[08:12:18] <dbaupp> doomrobo: operators in static initialisers are a pattern-match-and-evaluate-the-ast hack.
[08:12:26] <dbaupp> doomrobo: https://github.com/mozilla/rust/wiki/Note-operator-overloading
[08:12:28] <aatch> doomrobo, you can, and those will cause that to fail
[08:12:46] *** Joins: Blub\w (wry@moz-A2D8849A.vps.tuwien.ac.at)
[08:13:45] <doomrobo> dbaupp do you know if there are plans to declare certain functions as constant so that they can run at compile time a-la D?
[08:16:39] *** Joins: lucian (lucian@moz-22A14C6A.cable.virginmedia.com)
[08:17:32] *** Joins: jensnockert (jensnocker@moz-C5F27039.cust.bredband2.com)
[08:17:34] *** Quits: orshem (orshem@C5E06B1E.A5B6B765.E3D28531.IP) (Ping timeout)
[08:18:06] <Luqman> doomrobo: you can do `type CustomType = Either<int, ~str>`
[08:18:19] *** Quits: lucian (lucian@moz-22A14C6A.cable.virginmedia.com) (Ping timeout)
[08:18:39] <Luqman> doomrobo: as for compile tie function evaluation, not any time soon as I understand it
[08:18:40] <doomrobo> Luqman thanks!
[08:18:46] <Luqman> time*
[08:18:56] <doomrobo> alright
[08:19:06] <doomrobo> (maybe I can contribute once I get the hang of this)
[08:21:53] *** Joins: z0w0 (zack@moz-E12708D5.lns6.woo.bigpond.net.au)
[08:22:24] <mark_edward> how do you make an iterator do all of it's stuff? like if i call transform on a mut_iterator and mutate the elems, and i want all of thos emutations applied
[08:23:46] *** Joins: StarLight (StarLight@moz-A04C614E.dynamic.avangarddsl.ru)
[08:23:51] *** Joins: alisdair (textual@1697D94C.7742FB18.FBC8476D.IP)
[08:23:54] <doomrobo> mark_edward perhaps you're looking for a map?
[08:24:00] <mark_edward> doomrobo: yeah!
[08:24:59] <mark_edward> how do i do that?
[08:25:56] <aatch> mark_edward, if you do mut_iter, then what you get inside `advance` is a mutable reference to the data.
[08:26:27] <mark_edward> i see
[08:26:44] *** Joins: CarpNet (ac@moz-FD24B77.sohonet.co.uk)
[08:27:32] <aatch> Other options are (if you own the original data) using consume_iter, transform and collect, it technically still allocates, but allows you to change the type of the elements
[08:27:56] *** Quits: km (quassel@FDBAF0A0.DBF71E41.29C67456.IP) (Ping timeout)
[08:28:04] <aatch> (By technically still allocates, it will allocate a new collection then drop the old one)
[08:28:11] *** Joins: km (quassel@FDBAF0A0.DBF71E41.29C67456.IP)
[08:30:28] <aatch> dbaupp, wow that graph...
[08:30:35] <doomlord> heh. maybe i will prefer this_identifier_style if i swap - and _. woulnd't be hard, i dont mind pressing shift for addition
[08:32:37] *** Quits: jensnockert (jensnocker@moz-C5F27039.cust.bredband2.com) (Input/output error)
[08:32:54] <doener> ah, IRSY updated, nice :-)
[08:36:03] *** Quits: pnkfelix (pnkfelix@87C1F78E.1DE10CA8.D8E68FF6.IP) (Ping timeout)
[08:36:18] *** Joins: orshem (orshem@C5E06B1E.A5B6B765.E3D28531.IP)
[08:39:37] *** Quits: dherman (dherman@moz-6CA476B1.hsd1.ca.comcast.net) (Ping timeout)
[08:40:06] *** Joins: pnkfelix (pnkfelix@87C1F78E.1DE10CA8.D8E68FF6.IP)
[08:41:41] *** Quits: james4k (james@moz-E7990244.consolidated.net) (Quit: WeeChat 0.4.1)
[08:41:53] *** Joins: james4k (james@moz-E7990244.consolidated.net)
[08:44:05] <mark_edward> error: &mut [u8, .. 192]` does not implement any method in scope named `mut_slice_from
[08:44:10] <mark_edward> damn fixed size vectors
[08:45:54] *** Quits: snadon (chatzilla@moz-3BC727E8.mc.videotron.ca) (Ping timeout)
[08:49:23] *** Joins: true_droid (Adium@moz-123FD9B8.beck.volia.net)
[08:49:27] <aatch> http://huonw.github.io/isrustfastyet/mem/#293ec2c,6dc5e2c,32622ce
[08:50:30] *** Joins: libertas (libertas@moz-AF094932.rev.vodafone.pt)
[08:51:36] <aatch> YES!!!!! IT ONLY TOOK 2 DAYS BUT I FINALLY FIXED MY RANDOM MEMORY CORRUPTION
[08:51:40] <aatch> (probably)
[08:51:43] *** Joins: jensnockert (jensnocker@moz-C5F27039.cust.bredband2.com)
[08:52:10] <mark_edward> aatch: congrats
[08:52:15] <doener> aatch: nice
[08:52:20] * mark_edward throws aatch a party
[08:52:21] <aatch> This is in C++
[08:52:39] <doomrobo> aatch I'll bet you have a great appreciation for Rust right now
[08:52:42] <mark_edward> aatch: how would i get a mutable slice from a fixed size vector?
[08:52:43] <aatch> Using HipHop VM, where it would work the first time, but not the second time.
[08:53:08] * dbaupp hugs aatch
[08:53:11] <mark_edward> (said vector is a member of a struct with &mut self)
[08:53:29] <aatch> mark_edward, you can use auto-borrowing to convert it, so `let foo : &mut [T] = fixed_v`
[08:53:39] <dbaupp> aatch: it's strange how the LLVM shape is so different now
[08:53:46] <mark_edward> aatch: okay, i'll try it
[08:53:56] <aatch> dbaupp, yeah
[08:54:06] <dbaupp> mark_edward: what do you need the slice for? for passing to a function that takes &mut []?
[08:54:15] <aatch> dbaupp, iterator
[08:54:23] <mark_edward> dbaupp: yes
[08:54:37] <doomlord> is there a macro like thiis http://pastebin.com/nxi8bNTU
[08:54:39] <doener> dbaupp: probably refcounted stuff that was meant to be replaced, but we kept the original alive
[08:54:41] <dbaupp> mark_edward: f(fixed_v) should auto borrow to &mut []
[08:55:14] <mark_edward> certainly isn't working here. and i'm in a method were the reference to self i smutable, and it's a member, so i dunno what's going on
[08:55:15] <dbaupp> doomlord: for option.iter().advance |x| { ... }
[08:55:34] <aatch> rusti: let a = [1,2,3]; a.iter().advance(|x| {})
[08:55:34] -rusti- <anon>:5:47: 5:49 error: mismatched types: expected `bool` but found `()` (expected bool but found ())
[08:55:34] -rusti- <anon>:5          let a = [1,2,3]; a.iter().advance(|x| {})
[08:55:35] -rusti-                                                         ^~
[08:55:35] -rusti- error: aborting due to previous error
[08:55:35] -rusti- application terminated with error code 101
[08:55:51] <aatch> rusti: let a = [1,2,3]; a.iter().advance(|x| {true})
[08:55:51] -rusti- <anon>:5:44: 5:45 warning: unused variable: `x` [-W unused-variable (default)]
[08:55:51] -rusti- <anon>:5          let a = [1,2,3]; a.iter().advance(|x| {true})
[08:55:52] -rusti-                                                      ^
[08:55:52] -rusti- true
[08:56:02] <dbaupp> rusti: struct Foo { v: [int, .. 4] } fn foo(_: &mut [int]) {} let mut f = Foo { v: [0, .. 4] }; foo(f.v)
[08:56:03] -rusti- ()
[08:56:07] <dbaupp> mark_edward: ^
[08:56:08] <aatch> rusti: let a = [1,2,3]; a.mut_iter().advance(|x| {true})
[08:56:09] -rusti- <anon>:5:26: 5:27 error: cannot borrow immutable vec content as mutable
[08:56:09] -rusti- <anon>:5          let a = [1,2,3]; a.mut_iter().advance(|x| {true})
[08:56:09] -rusti-                                    ^
[08:56:09] -rusti- error: aborting due to previous error
[08:56:09] -rusti- application terminated with error code 101
[08:56:14] <aatch> rusti: let mut a = [1,2,3]; a.mut_iter().advance(|x| {true})
[08:56:14] -rusti- <anon>:5:52: 5:53 warning: unused variable: `x` [-W unused-variable (default)]
[08:56:15] -rusti- <anon>:5          let mut a = [1,2,3]; a.mut_iter().advance(|x| {true})
[08:56:15] -rusti-                                                              ^
[08:56:15] -rusti- true
[08:56:31] <mark_edward> dbaupp: type `&mut [u8]` does not implement any method in scope named `mut_slice_from`
[08:56:32] <doomlord> interesting, so i guess  option's iterator traverses 1 element, its 'Some', neat
[08:56:50] <mark_edward> that doesn't make anysense!
[08:57:12] <mark_edward> dbaupp: http://static.rust-lang.org/doc/std/vec.html#trait-mutablevector docs say it should work....
[08:57:46] <dbaupp> mark_edward: that was only added recently, so your rust may be too old
[08:57:52] <mark_edward> i see
[08:59:32] <doener> that was merged about a day ago
[09:02:05] *** Quits: nyx114 (nyx114@337D90A6.170C4318.709ED47B.IP) (Ping timeout)
[09:02:13] *** Joins: lucian (lucian@6B2B4644.4304AE1E.CE5E78F6.IP)
[09:02:15] *** Joins: nyx114 (nyx114@337D90A6.170C4318.709ED47B.IP)
[09:04:29] *** Quits: Blub\w (wry@moz-A2D8849A.vps.tuwien.ac.at) (Quit: bbl)
[09:05:11] *** Joins: donri (dag@moz-9BB61102.tbcn.telia.com)
[09:06:48] *** Quits: jensnockert (jensnocker@moz-C5F27039.cust.bredband2.com) (Connection reset by peer)
[09:06:55] *** Quits: alisdair (textual@1697D94C.7742FB18.FBC8476D.IP) (Quit: My MacBook Pro has gone to sleep. ZZZzzzâ€¦)
[09:07:43] *** Joins: jaen (jaen@moz-EAD29AF1.play-internet.pl)
[09:08:30] *** Joins: jensnockert (jensnocker@moz-C5F27039.cust.bredband2.com)
[09:08:54] *** Quits: aatch (aatch@moz-B437F499.pocketrent.com) (Quit: Leaving)
[09:11:23] *** Quits: jaen (jaen@moz-EAD29AF1.play-internet.pl) (Ping timeout)
[09:12:29] *** Joins: jaen (jaen@moz-EAD29AF1.play-internet.pl)
[09:15:39] *** Quits: mcclurmc (mcclurmc@moz-8D61EFD1.cable.virginmedia.com) (Ping timeout)
[09:17:16] <mark_edward> why aren't my debug!() macros doing anything?
[09:18:54] <doomrobo> god, I'm having one of those nights where every error I try to fix gives me more errors
[09:19:17] <dbaupp> mark_edward: you need to compile with `--cfg debug`
[09:19:44] <mark_edward> dbaupp: thanks
[09:19:48] <dbaupp> mark_edward: and RUST_LOG=my_module=4
[09:19:56] <dbaupp> (run with that)
[09:21:46] <mark_edward> dbaupp: ah i see... 
[09:23:26] *** Joins: robertknight (robertknig@moz-54528EE0.wby.mendeley.com)
[09:24:32] <robertknight> Looking at the fmt! proposal and Graydon's comment about avoiding unsafety, do I understand correctly that the only reason for the unsafety is the void* -> T transmute, but the compiler knows the type T at the time the &T -> void* conversion happens?
[09:25:45] *** Joins: josh (josh@moz-EC7A63FD.meeting.ietf.org)
[09:26:28] *** Quits: jensnockert (jensnocker@moz-C5F27039.cust.bredband2.com) (Input/output error)
[09:32:59] *** Quits: josh (josh@moz-EC7A63FD.meeting.ietf.org) (Quit: josh)
[09:33:55] *** Quits: sebcrozet (sebcrozet@moz-2517AE39.w80-13.abo.wanadoo.fr) (Client exited)
[09:38:13] *** Quits: jaen (jaen@moz-EAD29AF1.play-internet.pl) (Ping timeout)
[09:43:44] *** Joins: sankha93 (Instantbir@7061CD01.D6BD0D91.22D41759.IP)
[09:43:53] <doomrobo> hey, can someone tell me how to fix this? static mut special: HashMap<~str, SpecialFunction> = HashMap::new(); // "function calls in constants are limited to struct and enum constructors"
[09:44:30] *** Quits: km (quassel@FDBAF0A0.DBF71E41.29C67456.IP) (Ping timeout)
[09:47:34] *** Joins: jensnockert (jensnocker@moz-C5F27039.cust.bredband2.com)
[09:50:11] *** Joins: pyrac (pyrac@moz-C9A4FCEC.w90-55.abo.wanadoo.fr)
[09:52:49] *** Quits: pyrac (pyrac@moz-C9A4FCEC.w90-55.abo.wanadoo.fr) (Quit: pyrac)
[09:52:56] *** Joins: pyrac (pyrac@moz-C9A4FCEC.w90-55.abo.wanadoo.fr)
[09:57:30] *** Joins: binarybug (Mibbit@moz-30196228.connectel.com.pk)
[09:57:59] *** Quits: doomrobo (doomrobo@EC9C662A.161AAEB2.58B1C2DD.IP) (Quit: nighty night)
[10:00:28] *** zz_kimundi is now known as kimundi
[10:09:36] <doener> dbaupp: in http://huonw.github.io/isrustfastyet/mem/#85b5513 the memory usage graph from the beginning of "configuration 2" to the end of "std injection" seems to be perfectly straight. Is that because of low sampling rate in that area or because it truly is like that?
[10:10:56] <doener> dbaupp: it doesn't really look like the sampling rate is that low when looking at other parts of the graph, but that part just looks "too straight" to me
[10:13:09] *** Joins: sebcrozet (sebcrozet@moz-87D51607.w80-13.abo.wanadoo.fr)
[10:13:40] *** Quits: binarybug (Mibbit@moz-30196228.connectel.com.pk) (Quit: http://www.mibbit.com ajax IRC Client)
[10:16:20] *** Quits: jensnockert (jensnocker@moz-C5F27039.cust.bredband2.com) (Input/output error)
[10:16:40] *** Quits: sk (sk@61A494B3.BA40E8A.AAC02D62.IP) (Input/output error)
[10:24:42] *** Quits: geomyidae (cole@DD6F7E3A.21468E9A.30200F38.IP) (Quit: Konversation terminated!)
[10:26:57] *** Joins: geomyidae (cole@DD6F7E3A.21468E9A.30200F38.IP)
[10:32:15] <cmr> dbaupp: pong
[10:34:36] *** Quits: sankha93 (Instantbir@7061CD01.D6BD0D91.22D41759.IP) (Ping timeout)
[10:35:00] *** Joins: sankha93 (Instantbir@7061CD01.D6BD0D91.22D41759.IP)
[10:35:43] <doener> cmr: maybe you can answer my question above?
[10:35:43] *** Joins: vosen (vosen@moz-266BA656.icpnet.pl)
[10:36:18] <cmr> doener: that graph looks very very wrong to me
[10:36:47] *** Quits: sebcrozet (sebcrozet@moz-87D51607.w80-13.abo.wanadoo.fr) (Client exited)
[10:37:16] <cmr> sec, lemme toss my matplotlib script at it
[10:37:27] <doener> cmr: in which way?
[10:38:11] <cmr> doener: I've never seen the graph shaped like that, with that plateau
[10:39:54] <doener> cmr: that commit changed the code to free some stuff earlier. So a different shape is expected. Agrees with what I see with top
[10:40:13] <cmr> ah ok
[10:41:23] *** Joins: jaen (jaen@moz-53FB61BE.neoplus.adsl.tpnet.pl)
[10:42:02] <doener> I'm just wondering why it's still taking a whole GB, when the expanded crate only accounts for about 300M
[10:44:05] <cmr> doener: the graph is accurate
[10:44:21] *** Joins: sebcrozet (sebcrozet@moz-C27D92D8.w193-252.abo.wanadoo.fr)
[10:44:35] <cmr> (wrt the collected data, ie line simplficiation isn't skewing it)
[10:45:09] <cmr> Want me to schedule that commit for re-benchmarking?
[10:45:14] *** Joins: ysuzuki (ysuzuki@moz-FEE44B6.net220148245.t-com.ne.jp)
[10:45:27] *** Quits: ysuzuki (ysuzuki@moz-FEE44B6.net220148245.t-com.ne.jp) (Quit: Tiarra 0.1+svn-39209: SIGINT received; exit)
[10:45:37] *** Joins: ysuzuki (ysuzuki@moz-FEE44B6.net220148245.t-com.ne.jp)
[10:47:31] <doener> cmr: no. IIRC the graphs have all been like that (pretty straight line in that area). I just wondered whether that's due to a low sampling rate. If it's not, that's fine. Now I just need to understand why it is like that :-)
[10:47:52] <cmr> Good luck! :)
[10:48:39] *** Joins: gavinb (gavinb@moz-9EC182F0.lowrp3.vic.optusnet.com.au)
[10:49:48] *** Quits: BizarreCake (BizarreCak@moz-361FE9B2.dynamic.barak-online.net) (Ping timeout)
[10:51:22] *** Quits: pnkfelix (pnkfelix@87C1F78E.1DE10CA8.D8E68FF6.IP) (Quit: Leaving.)
[10:53:33] *** Quits: james4k (james@moz-E7990244.consolidated.net) (Ping timeout)
[10:53:45] *** Joins: km (quassel@FDBAF0A0.DBF71E41.29C67456.IP)
[10:58:16] *** Joins: kertap (kertap@moz-D50677C9.b-ras3.mvw.galway.eircom.net)
[11:00:14] <kertap> what's the best way to convert a u8 to a char?
[11:00:26] *** Quits: sebcrozet (sebcrozet@moz-C27D92D8.w193-252.abo.wanadoo.fr) (Client exited)
[11:01:50] <benh> What oes the u8 represent?
[11:01:53] <benh> ddoes
[11:02:25] *** Joins: Jesse (jruderman@moz-537BCF9.hsd1.ca.comcast.net)
[11:02:28] *** Joins: sebcrozet (sebcrozet@moz-87D51607.w80-13.abo.wanadoo.fr)
[11:02:36] *** Joins: q66 (q66@6EE9DE40.46454B5D.33AABD5F.IP)
[11:03:13] <kertap> The u8 should be the binary representation of the char. I was going to use str::from_bytes but I wanted to be sure that's the correct way to do it
[11:03:33] <cmr> char can't be represented in one byte
[11:03:34] *** Quits: sankha93 (Instantbir@7061CD01.D6BD0D91.22D41759.IP) (Quit: Gone to save the world!)
[11:03:39] <cmr> it's a UCS-4 codepoint
[11:03:59] <mark_edward> any of you have experience padding bits?
[11:04:16] <dbaupp> mark_edward: what do you mean by that?
[11:04:27] <benh> Does from_bytes do utf8 decoding?
[11:04:51] <dbaupp> doener: the underlying data is simplified (to make it a few kb rather than a few mb), so it might be eliminating stuff.
[11:05:03] *** Joins: sk (sk@4D49710A.1FD35C61.78DD174B.IP)
[11:05:25] <kertap> benh: It does. I think it's an ascii character if that makes a difference.
[11:05:45] <mark_edward> dbaupp: i'm getting input blocks of various sizes. if the the size % $magic_num != 0, then i ahve to pad the last block to $magic_num using te pattern 10*1
[11:05:51] <benh> "your_u8 as char" should be okay then I think
[11:06:37] <dbaupp> mark_edward: 10*1 ? could you give an example, e.g. if magic_num = 8 and size = 2?
[11:07:04] <kertap> benh: That works! I must have missed 'as'. Thanks!
[11:07:05] <mark_edward> dbaupp: (all sizes are in bits)
[11:07:08] *** Quits: sebcrozet (sebcrozet@moz-87D51607.w80-13.abo.wanadoo.fr) (Client exited)
[11:07:24] <dbaupp> mark_edward: yes, but what's the output?
[11:07:50] <dbaupp> benh: from_bytes takes a utf8 encoded [u8]
[11:08:08] <mark_edward> dbaupp: either 11100000 or 01100000
[11:08:12] <mark_edward> oops
[11:08:18] <mark_edward> dbaupp: either 11100001 or 01100001
[11:08:33] <dbaupp> rusti: std::str::from_bytes(&[0xff, 0xff]) // not utf8
[11:08:36] -rusti- line longer than 150 columns, pastebinned: http://sprunge.us/cLWL
[11:08:44] <dbaupp> benh: ^
[11:08:48] <dbaupp> mark_edward: ah, right.
[11:09:53] <dbaupp> rusti: use std::num::ToStrRadix; (1u << (8 - (2 % 8) - 1) | 1).to_str_radix(2)
[11:09:54] -rusti- ~"100001"
[11:10:17] <dbaupp> mark_edward: that's how you can make the trailing bit pattern, you just need to or it into your block
[11:11:08] *** Quits: sk (sk@4D49710A.1FD35C61.78DD174B.IP) (Ping timeout)
[11:12:03] <mark_edward> dbaupp: thinals
[11:12:09] <mark_edward> *thanks
[11:12:49] <mark_edward> but what how do i get it from str back into bits?
[11:14:52] *** Joins: SiegeLord (sl@moz-CAF07B4C.hsd1.ma.comcast.net)
[11:15:24] <dbaupp> just skip the string bit
[11:15:33] <dbaupp> that was just to show you that it worked.
[11:18:13] <mark_edward> ah, okay
[11:19:03] <dbaupp> cmr: my ping was another idea I had: you could have several clones of Rust, and run multiple builds concurrently (but still do the benchmarks serially)
[11:26:25] *** Quits: orshem (orshem@C5E06B1E.A5B6B765.E3D28531.IP) (Quit: Leaving)
[11:27:03] <dbaupp> doener: the raw data for your memory-drop commit each * is a recorded datapoint (in the big gaps: there were samples, but they were identical to the previous one, so are dropped by cmr's script.) http://i.imgur.com/utG7KaE.png
[11:28:02] <dbaupp> doener: (just eliminating the possibility that my post-processing program is breaking things.)
[11:31:43] *** Joins: jensnockert (jensnocker@moz-C5F27039.cust.bredband2.com)
[11:34:13] <cmr> dbaupp: That is possible but I think it would be very racy with last_auto.txt
[11:34:31] <cmr> solution: make the builds a celery task
[11:34:46] <dbaupp> cmr: I was thinking one controller, that just distributes builds to multiple git checkouts
[11:34:50] <cmr> yes
[11:35:12] <cmr> That would also be a good excuse to make benchit.py not a blight on humanity
[11:35:17] <dbaupp> heh :)
[11:35:19] <cmr> and also switch to aatch's benchmarker
[11:35:33] <dbaupp> (no rush :) )
[11:35:44] <dbaupp> although, using aatch's one will be awesome!
[11:36:01] <dbaupp> (is it parsing .stat yet? or still mem_usage_in_bytes?)
[11:40:16] <cmr> (still mem_usage_in_bytes)
[11:41:03] <dbaupp> cmr: http://huonw.github.io/isrustfastyet/mem/#b4e674f this is confusing
[11:41:15] <dbaupp> cmr: that commit was authored then, but commited much later.
[11:41:39] <cmr> heh, yikes
[11:41:57] <cmr> That probably means the commits are all out of order then :\
[11:42:35] *** Joins: LU324 (stuff@moz-A17E9A7B.dyn.embarqhsd.net)
[11:42:52] <dbaupp> the bors ones aren't
[11:43:05] <dbaupp> the non-bors ones probably are.
[11:44:28] *** Quits: jensnockert (jensnocker@moz-C5F27039.cust.bredband2.com) (Input/output error)
[11:44:55] *** Joins: azita (Azita@F9435EB3.4DC28F20.FAF22AF7.IP)
[11:48:35] *** Quits: azita (Azita@F9435EB3.4DC28F20.FAF22AF7.IP) (Quit: azita)
[11:49:16] <cmr> FIrefox doesn't like it very much when I open ever PR that was merged in the past week
[11:49:27] <cmr> (for pr in $(cat prs.txt); do firefox http://github.com/mozilla/rust/pull/$pr; done)
[11:50:31] <dbaupp> ahahaha
[11:50:36] <dbaupp> nice.
[11:50:36] <Seldaek> cmr: maybe you should wget the https://github.com/mozilla/rust/pull/$pr.patch instead :)
[11:50:54] <cmr> Seldaek: nah, I'm looking at the PRs for TWiR
[11:51:10] <Seldaek> well that shows you stuff still, but not as readable I suppose
[11:51:32] <kimundi> Grammar question: "External iterator for a strings characters" or "External iterator for a string's characters"
[11:51:42] <cmr> string's
[11:51:48] <kimundi> really?
[11:51:51] <Seldaek> yes
[11:52:00] <dbaupp> cmr: `git log --author bors 'master@{one week ago}'..master` gives you the body of the pull request text.
[11:52:13] <Seldaek> kimundi: the string owns the characters, and there is only one
[11:52:33] <Seldaek> kimundi: if there were many strings, maybe those strings' characters would be best but I'm not sure how legit that is
[11:52:42] <kimundi> Non native speaker here... I thought that allways stands for "string is"
[11:53:00] <cmr> nope, that's only very rarely, in terms of 's usage
[11:53:06] <kimundi> hu
[11:53:12] <cmr> it's possessive, or something like that
[11:54:17] <dbaupp> yeah; `<general noun>'s` is almost always possessive, it's (heh) most commonly `... is` for only a few nouns/pronouns
[11:54:25] <dbaupp> (e.g. `it`)
[11:54:27] *** Joins: msingle (Thunderbir@moz-930E5D97.hr.hr.cox.net)
[11:55:25] <dbaupp> cmr: in any case, the old data and the new data now have ~4 commits of overlap... the memory usage lines up pretty perfectly
[11:55:35] <Seldaek> dbaupp: sometimes I regret this text based chat stuff, I'm sure this would be even more confusing with an aussie accent :p
[11:55:55] <cmr> dbaupp: good!
[11:55:56] * dbaupp thinks his accent's perfectly fine
[11:56:15] <Seldaek> :)
[11:56:19] <dbaupp> cmr: http://huonw.github.io/isrustfastyet/mem/#0cb1ac0,4f33302 http://huonw.github.io/isrustfastyet/mem/old/#0cb1ac0,4f33302 (if you wanna compare)
[11:56:32] <cmr> Almost twice as fast
[11:56:35] *** Joins: davbo (dave@moz-3FFA637C.oucs.ox.ac.uk)
[11:56:37] * cmr caresses his desktop
[11:57:56] *** Joins: alex-abreu (alex@moz-7421D6C9.mc.videotron.ca)
[11:58:57] *** Joins: engla (engla@moz-DBD1D96E.cust.bredbandsbolaget.se)
[11:59:18] <doener> dbaupp: the line going up at the start is a connection between two asterisks?
[11:59:32] <dbaupp> doener: just a pile of *'s overlaid
[11:59:58] <doener> wow, tons of them :-)
[12:01:02] <dbaupp> doener: yeah, there's 47489 points in that graph
[12:01:46] <dbaupp> (which gets simplified to 109, with essentially no loss of useful information)
[12:03:43] <kimundi> What is the style guide for {} placement?
[12:04:11] <cmr> kimundi: look through any of the libstd code
[12:04:13] <cmr> foo {
[12:04:14] <cmr> }
[12:04:52] <kimundi> Ah, sorry, I meant 'else' specifically
[12:04:59] <kimundi> }
[12:05:01] <kimundi> else {
[12:05:04] <kimundi> or
[12:05:07] <kimundi> } else {
[12:05:10] <cmr> ah
[12:05:15] <cmr> I do } else {
[12:05:52] <dbaupp> yeah, it seems rust-style is } else {
[12:07:24] *** Quits: robertknight (robertknig@moz-54528EE0.wby.mendeley.com) (Quit: Computer has gone to sleep.)
[12:07:59] *** Quits: km (quassel@FDBAF0A0.DBF71E41.29C67456.IP) (Ping timeout)
[12:08:07] *** Joins: maikklein (maik@moz-EDC31EF0.dip0.t-ipconnect.de)
[12:08:52] *** Joins: km (quassel@FDBAF0A0.DBF71E41.29C67456.IP)
[12:15:49] <cmr> 5 breaking changes this week
[12:15:54] <cmr> And all but one were library improvements
[12:16:35] <heftig> dbaupp: confusingly, the possessive for "it" is "its", while "it's" is the contraction
[12:16:49] <dbaupp> heftig: English is so much fun :P
[12:16:52] *** Quits: maikklein (maik@moz-EDC31EF0.dip0.t-ipconnect.de) (Ping timeout)
[12:17:02] <heftig> dbaupp: homophones!
[12:18:56] <cmr> rusti: fn foo(mut x: ~int) { *x = 10 } let x = ~5; foo(x); x
[12:18:58] -rusti- more than 5 lines of output, pastebinned: http://sprunge.us/PRBR
[12:19:17] <cmr> rusti: fn foo(mut x: ~int) -> ~int { *x = 10; x } let x = ~5; foo(x)
[12:19:18] -rusti- ~10
[12:20:56] *** Joins: ab (alex@BC9D99CC.37C1012D.FE617B51.IP)
[12:21:41] <cmr> I take it back, 4 breaking changes
[12:24:11] *** Quits: z0w0 (zack@moz-E12708D5.lns6.woo.bigpond.net.au) (Client exited)
[12:24:47] *** Joins: maxli (maxli@F2D29657.F60B0462.67AC9B1.IP)
[12:28:04] *** Quits: km (quassel@FDBAF0A0.DBF71E41.29C67456.IP) (Ping timeout)
[12:28:19] *** Joins: km (quassel@FDBAF0A0.DBF71E41.29C67456.IP)
[12:32:02] *** Quits: tupshin (quassel@moz-E7B03838.c3-0.nyr-ubr1.nyr.ny.cable.rcn.com) (Ping timeout)
[12:32:14] *** Quits: huhlig-work (huhlig@moz-62A47D90.aoltw.net) (Ping timeout)
[12:34:01] *** Quits: true_droid (Adium@moz-123FD9B8.beck.volia.net) (Quit: Leaving.)
[12:34:11] *** Joins: huhlig-work (huhlig@moz-62A47D90.aoltw.net)
[12:39:24] <bstrie> oh nice, so we're finally back to where we were before the memory regression?
[12:39:48] <dbaupp> bstrie: which memory regression?
[12:39:54] <cmr> heh
[12:39:58] *** Quits: gavinb (gavinb@moz-9EC182F0.lowrp3.vic.optusnet.com.au) (Quit: gavinb)
[12:40:02] <dbaupp> because we're past the most recent one
[12:40:29] *** Joins: ghrust (ghrust@1E8607E8.6A2AE50.F3114085.IP)
[12:40:29] <ghrust> 01[13rust01] 15bors 04force-pushed 06auto from 14cd38e84 to 1427812ea: 02http://git.io/N3iJvQ
[12:40:29] *** Parts: ghrust (ghrust@1E8607E8.6A2AE50.F3114085.IP) ()
[12:40:51] <dbaupp> but still ~150MB behind where we were a month or so ago.
[12:42:01] *** Joins: Kruppe (user@moz-E150F49F.cpe.net.cable.rogers.com)
[12:44:24] <bstrie> dbaupp: looks to me more like cmr's new box just uses more memory in general
[12:45:04] *** Joins: pnkfelix (pnkfelix@87C1F78E.1DE10CA8.D8E68FF6.IP)
[12:45:41] <dbaupp> bstrie: not sure about that, http://huonw.github.io/isrustfastyet/mem/old/#68a32aa (1572 MB) vs http://huonw.github.io/isrustfastyet/mem/#68a32aa (1525 MB)
[12:46:12] <bstrie> I'm looking at http://huonw.github.io/isrustfastyet/mem/#060de10,85b5513
[12:46:42] <dbaupp> oh... they're both with the new box
[12:49:05] <engla> the old peak was below 1200
[12:49:40] <dbaupp> kimundi: your adjustments to std::str a very nice, using just the one iterator is pretty cool!
[12:49:43] <dbaupp> *are
[12:49:52] <kimundi> dbaupp: Thx :)
[12:50:38] <dbaupp> kimundi: (although there were a few tiny nitpicks :) )
[12:51:47] <kimundi> dbaupp: Ah, yeah
[12:51:49] *** Quits: xraycat (Adium@moz-4F58939A.pool.mediaways.net) (Quit: Leaving.)
[12:53:42] <engla> kimundi: shouldn't the offset iterator be (uint, char). The index is in front in .enumerate() and it was in .eachi
[12:54:54] <doener> dbaupp, bstrie: There's something weird going on in the early phases. I tried to convert the first @Crate to ~Crate to have it freed early. That lowered the peak, but raised the large plateau that is at 1GB now
[12:55:15] <doener> peak down by ~80MB, plateau up by 150MB
[12:55:41] <dbaupp> doener: which peak? the one just before the plateau?
[12:56:01] <doener> dbaupp: max usage
[12:56:10] <dbaupp> doener: oh
[12:56:26] <cmr> peak usage is a somewhat meaningless metric
[12:56:26] <doener> dbaupp: I only watched top and time output
[12:56:33] <cmr> because the peak is usually in the linker
[12:56:37] <dbaupp> doener: that still sounds like a handy gain.
[12:56:42] <dbaupp> cmr: not any more
[12:56:51] <cmr> no?
[12:57:01] <dbaupp> cmr: http://huonw.github.io/isrustfastyet/mem/#4cc3bbb
[12:57:05] <doener> not by 200MB ;-)
[12:57:11] <cmr> huh
[12:57:37] <dbaupp> and the big flat LLVM plateau is apparently perfectly flat
[12:57:40] <doener> initial part got worse, llvm part got better, so the peak is early on now
[12:57:57] <dbaupp> cmr: (i.e. your script is eliminating all the data points in there, so they are presumably equal.)
[12:58:12] <cmr> I vouch for the adjacent merging code; it is 100% correct
[12:58:14] <kimundi> engla: Both is kinda strange. enumerate is (uint, char), but the Iteraoor is called CharOffsetIterator, not OffsetCharIterator
[12:59:00] <dbaupp> kimundi: (fwiw, I agree with engla.)
[12:59:07] <kimundi> I can change it, of course, but I'm not sure wich one would be more correct
[12:59:41] <dbaupp> cmr: yeah, I'm sure it is; it's just strange that it's so perfectly flat
[13:00:13] <cmr> dbaupp: iirc memory accounting with glibc is somewhat fuzzy
[13:00:21] <kimundi> Should I rename it to OffsetCharIteraor then and change the order?
[13:00:23] <cmr> because glibc doesn't mark free()'d pages as free
[13:00:23] <dbaupp> cmr: http://i.imgur.com/utG7KaE.png each * is a pre-simplification datapoint (and the lines are just solid blocks of *s)
[13:00:35] <dbaupp> cmr: yup, that'd explain it.
[13:00:57] <cmr> It's much more accurate with jemalloc
[13:00:58] <engla> kimundi: I didn't think that way about the iterator name
[13:01:14] <cmr> (and tcmalloc for that matter)
[13:01:38] <engla> kimundi: I mean, it's not CharAndOffset iterator
[13:02:23] *** Joins: mug896 (Mibbit@615BFFBF.E6043972.FA8FD2DE.IP)
[13:03:55] <kimundi> hm... Ah, whatever, gonna switch the order of the tuple to match enumerate and that's it :P (Though I think someone told me to switch it to the current one yesterday...)
[13:05:18] *** Quits: msingle (Thunderbir@moz-930E5D97.hr.hr.cox.net) (Ping timeout)
[13:06:31] *** Parts: mug896 (Mibbit@615BFFBF.E6043972.FA8FD2DE.IP) ()
[13:07:11] <engla> I like it
[13:08:02] *** Joins: jfbk (textual@moz-EEA9CFB3.nyc.res.rr.com)
[13:08:27] <cmr> dbaupp: do you collect metrics from the buildbots?
[13:08:36] <dbaupp> cmr: not yet
[13:08:51] *** Joins: msingle (Thunderbir@moz-930E5D97.hr.hr.cox.net)
[13:08:59] <cmr> Do you know where I can *find* the metrics?
[13:09:08] <dbaupp> (I'm having trouble thinking of a good way to present the data, and also uni just started again.)
[13:09:23] <dbaupp> cmr: static.rust-lang.org/build-metrics/<git-sha1>/<builder>/<slave>/<metricsfile>.json
[13:09:28] <Ms2ger> Damn uni, distracting from real work
[13:09:30] <cmr> Ah ok
[13:09:49] *** Joins: Houm (Houm@moz-25669AA8.fbx.proxad.net)
[13:10:07] <dbaupp> Ms2ger: pretty much :'(
[13:10:21] <dbaupp> that said, this semester is looking to be more interesting than the last one.
[13:10:45] <Ms2ger> That's good, then :)
[13:11:21] <Seldaek> is everyone a student here? I'd almost feel old
[13:11:55] *** Quits: mark_edward (quassel@moz-4A9A2F15.dynamic.utc.edu) (Ping timeout)
[13:17:30] *** Joins: jdm (jdm@92FB48CA.8B5E9DF.9A8C35B4.IP)
[13:17:38] *** Joins: saml (sam@moz-14C16814.cst.lightpath.net)
[13:17:39] *** Joins: jensnockert (jensnocker@moz-C5F27039.cust.bredband2.com)
[13:17:39] *** Joins: dbp (user@moz-72A193C2.ri.ri.cox.net)
[13:22:10] *** Quits: saml (sam@moz-14C16814.cst.lightpath.net) (Client exited)
[13:25:00] *** Joins: saml (sam@moz-14C16814.cst.lightpath.net)
[13:25:43] *** Joins: xraycat (Adium@moz-4F58939A.pool.mediaways.net)
[13:29:23] *** Quits: jfbk (textual@moz-EEA9CFB3.nyc.res.rr.com) (Quit: My MacBook has gone to sleep. ZZZzzzâ€¦)
[13:30:11] *** Joins: BizarreCake (BizarreCak@moz-361FE9B2.dynamic.barak-online.net)
[13:31:29] *** Quits: jensnockert (jensnocker@moz-C5F27039.cust.bredband2.com) (Input/output error)
[13:32:06] <kimundi> dbaupp: I think I'm done with the Pr now (Unless I still find compile breakage)
[13:32:35] <kimundi> Should maybe squash it now...
[13:35:16] *** Quits: dbp (user@moz-72A193C2.ri.ri.cox.net) (Ping timeout)
[13:36:09] *** Quits: jaen (jaen@moz-53FB61BE.neoplus.adsl.tpnet.pl) (Ping timeout)
[13:36:57] *** Joins: mark_edward (quassel@moz-4A5B1251.wisolt4.epbfi.com)
[13:37:15] *** Quits: mark_edward (quassel@moz-4A5B1251.wisolt4.epbfi.com) (Client exited)
[13:37:55] *** Joins: mark_edward (quassel@moz-4A5B1251.wisolt4.epbfi.com)
[13:42:27] <engla> kimundi: you'll hate me, but I think I found a thing
[13:42:31] <engla> I want this to go in asap
[13:42:43] <kimundi> engla: Na, shoot
[13:42:58] <kimundi> Any bug is welcome \._./
[13:43:03] <engla> the double-ended iterators need to shrink like a range, so .next_back() picks off from the end
[13:43:15] <engla> I think .next() should check the back index for the limit, not .len()
[13:43:21] <engla> and .next_back() conversely
[13:43:35] <kimundi> ah, I forgot to actually have them collide -_-
[13:43:48] <engla> collide is fine, as long as the collision returns None
[13:43:52] <engla> it's passing they can't :)
[13:44:06] <kimundi> yeah, that's what I meant :)
[13:44:38] <engla> anyway, I think it kind of turns out nice, because you'll remove the call to .len()
[13:45:05] <engla> it's not really more complex
[13:45:17] <kimundi> yeah
[13:47:41] *** Joins: azita (Azita@5D39B82F.793D065B.FAF22AF7.IP)
[13:47:47] <kimundi> engla: Pushed a fix
[13:47:51] *** Joins: jorendorff (jorendorff@moz-2F32ACA3.hsd1.tn.comcast.net)
[13:47:52] <engla> I'll read it
[13:47:58] *** Quits: recrack (Mibbit@B4104EBB.3CC170B1.1E14B209.IP) (Quit: http://www.mibbit.com ajax IRC Client)
[13:48:06] *** Quits: km (quassel@FDBAF0A0.DBF71E41.29C67456.IP) (Ping timeout)
[13:49:33] *** Joins: km (quassel@FDBAF0A0.DBF71E41.29C67456.IP)
[13:50:41] *** Joins: jensnockert (jensnocker@moz-C5F27039.cust.bredband2.com)
[13:50:50] <engla> looks good
[13:51:24] <kimundi> great :)
[13:51:29] <mark_edward> rusti: use std::num::ToStrRadix; (1u << (8 - (2 % 8) - 1) | 1).to_str_radix(2)
[13:51:30] -rusti- ~"100001"
[13:52:11] <mark_edward> hey guys I have a random question. I have a typing speed of about 66 wpm. Do you think this is a good enough speed or do I need some typing excercises.
[13:52:29] *** Joins: Florob (florian@E4BCD297.B50A917B.CD80E335.IP)
[13:52:47] <cmr> Is it slower than your thinking speed? :)
[13:53:05] <engla> as long as you can type faster than rustc compiles it
[13:53:26] <kimundi> Don't ask me, I still haven't matured beyond two-finger halfautomatic :P
[13:54:03] <bstrie> mark_edward: do wt i do and typ shrtr wrds
[13:54:28] <mark_edward> bstrie: gd ida
[13:54:41] <bstrie> prfctly undrstndbl
[13:54:43] <kimundi> (Even I can't decipher that second-to last word)
[13:54:49] <mark_edward> cmr: i think that's a good thing in my taste
[13:54:52] <mark_edward> kimundi: idea
[13:55:03] <mark_edward> *case not taste
[13:55:22] <bstrie> kimundi: shorter?
[13:55:49] <bstrie> kimundi: feel free to type vowel-less german words to show us up :)
[13:56:02] *** Joins: orshem (orshem@C5E06B1E.A5B6B765.E3D28531.IP)
[13:56:10] <kimundi> yes yes :P You two write faster than I could formulate a joke about mispelling "idea" as "shrtr"
[13:56:21] <SimonSapin> Hi. If I want bit fields with a nicer interface than u32, do I need to build it?
[13:56:23] <bstrie> then I'd say our wpm is fast enought!
[13:56:37] <bstrie> SimonSapin: I think we have a "bitvector" module somewhere
[13:57:06] <engla> yes, extra::bitv
[13:57:44] *** Quits: thpickert (thpickert@moz-24816453.tng.de) (Quit: thpickert)
[13:58:35] <kimundi> Vklls dtsch Wrtr? ch bn mr ncht schr b ds n gt d st.
[13:59:36] *** Joins: jedestep (jedestep@34641662.FB4DE631.66C78B76.IP)
[13:59:40] <bstrie> if only maikklein were here to translate :P
[13:59:49] <kimundi> (Hm, does Ã¶ count as a vowel in german?)
[13:59:57] * kimundi heads to wikipedia
[14:00:00] <Seldaek> I'd say yes
[14:00:05] <Seldaek> but my german is only worth so much
[14:00:12] <bstrie> maybe it's two vowels!
[14:00:23] <Seldaek> double score at scrabble for sure
[14:00:23] <kimundi> bstrie: Acutally xD
[14:00:33] <bstrie> since the umlaut is just an "e"
[14:00:34] <kimundi> bstrie: One way to write Ã¶ is oe
[14:00:45] <bstrie> Å“
[14:01:07] <bstrie> fÅ“tus, as the english would say
[14:01:08] *** Joins: bnicholson (bnicholson@moz-3492C575.rcmdva.fios.verizon.net)
[14:01:16] <engla> silly germans, why don't you use Ã¦ and Å“
[14:01:21] <bstrie> I can't think of any other word that uses Å“ rather than Ã¦
[14:01:41] <Seldaek> bstrie: oeuf, but that's french :p
[14:02:44] <bstrie> Å“uvre
[14:02:46] <Seldaek> bstrie: here http://en.wikipedia.org/wiki/List_of_words_that_may_be_spelled_with_a_ligature
[14:02:54] <SimonSapin> bstrie, engla: thatâ€™s good, but I was thinking of a fixed set on named bit values. Semantically a struct with bool fields, but with a more compact memory representation.
[14:02:55] <bstrie> I've gone mad with the power of the compose key
[14:03:03] *** Joins: lmandel (lmandel@2B5B5FD9.7ECD71DF.ADB88A9.IP)
[14:03:18] <Florob> compose keyâ„¢
[14:03:55] <bstrie> SimonSapin: well, eventually we'll have some sort of optimization that treats bools as i1 rather than i8
[14:04:01] *** Quits: joone (joone@3CCE8CB5.2160464A.A34EC3BB.IP) (Ping timeout)
[14:04:12] <bstrie> ...in some contexts. I'm fuzzy on the details
[14:04:26] <cmr> Not possible;.
[14:04:34] <cmr> You need to be able to take the address of a struct field
[14:04:35] <kimundi> Pff, compose is something for wimps who are scared of changing their layout to something with 6 layers
[14:04:38] <cmr> You can't do that if it's a single bit.
[14:04:54] <kimundi> âœ”âœ˜â€ â€£â™£â™¦â™¥â™  - I only had to hold shift!
[14:05:01] <SimonSapin> bstrie: isnâ€™t there a guarantee that structs have the same memory representation than in C that makes this harder?
[14:05:18] <Seldaek> kimundi: I can see how this would come in handy quite often, at least to win irc arguments :p
[14:05:25] <kimundi> xD
[14:05:28] <SimonSapin> cmr: how does C get away with bit fields?
[14:05:40] <cmr> SimonSapin: it doesn't
[14:05:53] <cmr> that's not a requirement in C I don't think
[14:05:53] * kimundi enjos the freedom bejond ascii to much
[14:05:54] *** Joins: infynyxx (infynyxx@moz-E95B370B.nyc.res.rr.com)
[14:06:02] <cmr> (being able to take the address of a field)
[14:06:04] <cmr> dunno thouh
[14:06:08] <cmr> test it out and see?
[14:06:34] *** Quits: azita (Azita@5D39B82F.793D065B.FAF22AF7.IP) (Quit: azita)
[14:06:41] <kimundi> there is #[packed] to force a struct to an non_padded layout
[14:07:28] <cmr> Hm, I wonder how that would work on archs where you can't have unaligned access
[14:07:35] <cmr> I imagine #[packed] just wouldn't do anything
[14:07:53] *** Quits: km (quassel@FDBAF0A0.DBF71E41.29C67456.IP) (Ping timeout)
[14:08:20] <dbaupp> kimundi: yes
[14:08:26] *** Joins: km (quassel@FDBAF0A0.DBF71E41.29C67456.IP)
[14:08:49] * dbaupp shouldn't jump into conversations without reading more than the last 3 messages
[14:08:55] <Florob> cmr, SimonSapin: Indeed the operand of the &-operator may not be a bit-field, according to C99
[14:09:08] * dbaupp should also learn to identify questions
[14:09:12] <kimundi> dbaupp: Hm?
[14:09:15] <cmr> heh
[14:09:20] <dbaupp> kimundi: doesn't matter :P
[14:09:22] <cmr> dbaupp: We have punctuation for that!
[14:09:24] <cmr> '?'
[14:09:33] <cmr> U+003F
[14:09:49] <dbaupp> cmr: oh, that's the thing I'd forgotten about! thanks.
[14:10:06] *** Joins: joone (joone@moz-D3B2E195.jf.intel.com)
[14:10:46] <orshem> how do i drive clone for a simple struct?
[14:10:58] <cmr> #[deriving(Clone)] struct Foo { ... }
[14:11:09] <Seldaek> dbaupp: this is a questionÂ¿
[14:11:10] <orshem> cmr: thanks!
[14:11:45] <dbaupp> Seldaek: I'm not sure I'm up to such advanced question-identification yet; I need to practice a little more.
[14:12:14] *** Joins: tupshin (quassel@moz-E7B03838.c3-0.nyr-ubr1.nyr.ny.cable.rcn.com)
[14:13:18] <Seldaek> Oh wow. did you know there is an irony punctuation? that is awesome https://en.wikipedia.org/wiki/Irony_punctuation
[14:13:42] <Seldaek> the things one can learn searching for random crap on wikipedia.
[14:14:00] <orshem> when initiating a struct how can i leave some field uninit (i have a function which will fill them latter)?
[14:14:08] <cmr> orshem: you can't
[14:14:11] <bstrie> Seldaek: see also https://en.wikipedia.org/wiki/Interrobang
[14:14:28] <cmr> orshem: Rust does not allow uninitialized values in safe code.
[14:14:33] <cmr> But, there is intrinsics::uninit()
[14:14:44] <kimundi> â€½
[14:14:46] <jedestep> â€½â€½â€½â€½â€½â€½â€½â€½
[14:14:47] <orshem> cmr: thanks. I guess Option<> will come to the rescue :) 
[14:14:50] <Seldaek> haha
[14:14:57] <bstrie> orshem: if you derive the Zero trait, you can say `let foo: MyStruct = Zero::zero();`
[14:15:25] <kimundi> Urg, I still hate that
[14:15:27] <bstrie> not quite the same as leaving it uninitialized, but it saves some boilerplate
[14:15:37] <kimundi> why nod Default::default() :P
[14:15:45] <cmr> kimundi: because you haven't sent a PR for it yet!
[14:15:46] <orshem> bstrie: i didn't create it it's a ~[~[SomeType]]
[14:15:49] * cmr cracks the whip
[14:16:00] <Seldaek> bstrie: so Zero is like a value for nil?
[14:16:09] <kimundi> cmr: Yeah I know... But people seem to converge to Zero
[14:16:17] <cmr> Seldaek: Zero is for generic numerics
[14:16:21] <Seldaek> (I try to learn about rust too in between the typography classes)
[14:16:28] <bstrie> Seldaek: Zero::zero() basically just fills structs with the "default" value for each type. 0 for numbers, false for bools, etc
[14:16:37] <Seldaek> ah ok
[14:16:41] <cmr> It's supposed to be the additive identity I think
[14:16:43] <kimundi> rusti: Zero::zero::<uint>()
[14:16:44] -rusti- more than 5 lines of output, pastebinned: http://sprunge.us/YGQW
[14:16:46] <orshem> bstrie: null for ptr?
[14:16:59] <bstrie> orshem: possibly, I'm not an expert on it
[14:16:59] <kimundi> rusti: ::std::Zero::zero::<uint>()
[14:17:00] -rusti- more than 5 lines of output, pastebinned: http://sprunge.us/ASVI
[14:17:18] <kimundi> rusti: ::std::num::Zero::zero::<uint>()
[14:17:19] -rusti- 0
[14:17:25] <kimundi> rusti: ::std::num::Zero::zero::<float>()
[14:17:26] -rusti- 0
[14:17:36] <kimundi> rusti: ::std::num::Zero::zero::<~str>()
[14:17:37] -rusti- ~""
[14:17:40] <bstrie> rusti: #[deriving(Zero)] struct Foo { bar: int, foo: bool } let f: Foo = Zero::zero(); f
[14:17:41] -rusti- more than 5 lines of output, pastebinned: http://sprunge.us/cSGi
[14:17:42] <kimundi> uuurk
[14:17:51] <engla> we are still looking for a better name for Zero I think
[14:17:58] <orshem> rusti: ::std::num::Zero::zero::<~[]>()
[14:17:59] -rusti- <anon>:5:36: 5:37 error: expected type, found token RBRACKET
[14:17:59] -rusti- <anon>:5          ::std::num::Zero::zero::<~[]>()
[14:17:59] -rusti-                                              ^
[14:17:59] -rusti- application terminated with error code 101
[14:18:00] <cmr> https://github.com/mozilla/rust/issues/7312
[14:18:08] <bstrie> I think "default" does make more sense
[14:18:09] <orshem> rusti: ::std::num::Zero::zero::<~[int]>()
[14:18:09] -rusti- ~[]
[14:18:44] <orshem> bstrie: +1 for default
[14:18:51] <bstrie> instead of "Default::default" maybe "Default::new()", to save on redundancy :)
[14:18:54] <dbaupp> (#[deriving] doesn't work in functions (and hence doesn't work in rusti).)
[14:18:58] <bstrie> aha
[14:18:59] <engla> I'd love to have  trait Make { fn new() -> Self }
[14:19:04] <cmr> bstrie: No, new cannot be reserved for Default.
[14:19:17] <cmr> bstrie: for when you want a nice usable constructor and a meaningful default value
[14:19:28] <bstrie> cmr: static methods named new are already how we handle constructors
[14:19:29] <engla> ah right
[14:19:44] <cmr> bstrie: It's the name, not the method
[14:19:55] <cmr> We have new() with arguments everywherre
[14:19:59] <cmr> default doesn't take arguments
[14:20:04] <bstrie> I'm not sure what you're saying
[14:20:04] <cmr> (otherwise it wouldn't be very default)
[14:20:12] <bstrie> there's no name collision
[14:20:17] <orshem> rust is really a cool language when you finally get something to work :)
[14:20:19] <cmr> There is if you want to implement the trait
[14:20:20] <bstrie> Default::new() vs Foo::new()
[14:21:00] <orshem> vec::from_elem is a great little function
[14:21:19] <kimundi> I think a lot of people want Foo::new() to also look fer Default::<Foo>::new()
[14:21:19] <cmr> rusti: trait Newable { pub fn new() -> Self; } struct Foo; impl Newable for Foo { pub fn new() -> Foo { Foo } } impl Foo { pub fn new(x: uint) -> Foo { Foo } } Foo::new()
[14:21:21] -rusti- line longer than 150 columns, pastebinned: http://sprunge.us/dYPW
[14:21:31] <cmr> rusti: trait Newable { pub fn new() -> Self; } struct Foo; impl Newable for Foo { pub fn new() -> Foo { Foo } } impl Foo { pub fn new(x: uint) -> Foo { Foo } } Foo::new(5)
[14:21:33] -rusti- line longer than 150 columns, pastebinned: http://sprunge.us/LePQ
[14:21:45] <cmr> rusti: trait Newable { pub fn new() -> Self; } struct Foo; impl Newable for Foo { pub fn new() -> Foo { Foo } } impl Foo { pub fn new(x: uint) -> Foo { Foo } } Newable::new::<Foo>()
[14:21:47] -rusti- line longer than 150 columns, pastebinned: http://sprunge.us/bOWB
[14:21:54] <cmr> bstrie: nevermind :)
[14:22:10] <orshem> rust iterators+ these sort of little function really cut down on my loop usage
[14:22:29] <bstrie> ok phew, I thought I was misunderstanding the namespacing of static methods :P
[14:22:36] <cmr> me too :p (and I was)
[14:24:00] <engla> but it's confusing if some types have to be created with Default::new() and some with Type::new()
[14:24:25] <bstrie> then how about we hedge our bets with "Default::zero()" :)
[14:24:35] * cmr smacks bstrie
[14:24:51] * kimundi throws old Office 95 handbooks at bstrie
[14:25:03] <engla> generally the api should be filled with lots of alias methods
[14:25:07] <engla> just in case you forget one name
[14:25:15] <bstrie> alias methods?
[14:25:21] *** Joins: jaen (jaen@moz-D3683703.play-internet.pl)
[14:25:25] *** Joins: ghrust (ghrust@C621748.6A2AE50.F3114085.IP)
[14:25:25] <ghrust> 01[13rust01] 15bors merged 06auto into 06master: 02http://git.io/mMCxMQ
[14:25:25] *** Parts: ghrust (ghrust@C621748.6A2AE50.F3114085.IP) ()
[14:25:32] <engla> nah
[14:25:58] <bstrie> uh oh
[14:26:02] <bstrie> bors is almost empty
[14:26:09] * kimundi adds a Pt that besides str::slice, also adds str::snice, str::splice, str::skis and str::rice
[14:26:11] * cmr cracks the whip
[14:26:12] <bstrie> someone review something!
[14:26:12] <Ms2ger> Quick, write some code
[14:27:03] * kimundi 's PR would be mergable... but he wants to make sure the testsuite passes first (any then sqash the commits)
[14:27:53] <kimundi> (In other words: Now would be the perfect moment to troll me with a r+)
[14:28:37] <bstrie> râ€½
[14:29:02] <bstrie> I'm amused that my font contains the interrobang
[14:29:07] <bstrie> I wonder if it's used in APL
[14:29:13] *** Joins: bytbox (s@moz-DC83764A.washdc.fios.verizon.net)
[14:30:17] <orshem> quick question: do privacy modifiers matter on impl/struct? or only on fields/fns?
[14:30:19] <cmr> Ugh mw and his "naming consistency" madness is breaking all my code constantly
[14:30:43] <dbaupp> cmr: occupational hazard
[14:31:27] *** Joins: ghrust (ghrust@1E8607E8.6A2AE50.F3114085.IP)
[14:31:27] <ghrust> 01[13rust01] 15bors pushed 0 new commits to 06auto: 02http://git.io/MQI5Rw
[14:31:27] *** Parts: ghrust (ghrust@1E8607E8.6A2AE50.F3114085.IP) ()
[14:31:29] <kimundi> orshem: struct, field, type impl fns, not trait impl fns
[14:31:29] *** Joins: ghrust (ghrust@C621748.6A2AE50.F3114085.IP)
[14:31:29] <ghrust> 01[13rust01] 15bors pushed 2 new commits to 06auto: 02http://git.io/HF9fRg
[14:31:29] <ghrust> 13rust/06auto 146f4e2b2 15crnobog: Compare file:line prefix case-insensitively on win32...
[14:31:29] <ghrust> 13rust/06auto 1463c9b11 15bors: auto merge of #8003 : crnobog/rust/case-insensitive-error-prefix, r=cmr...
[14:31:30] *** Parts: ghrust (ghrust@C621748.6A2AE50.F3114085.IP) ()
[14:31:30] *** Joins: metasyntax (tvenable@moz-63D9B3D.med-web.com)
[14:32:35] <orshem> kimundi: thanks! they only take effect outside the module?
[14:32:43] <kimundi> yes
[14:33:06] *** Quits: jaen (jaen@moz-D3683703.play-internet.pl) (Ping timeout)
[14:33:19] <kimundi> (but outside the module also means submodules here :P)
[14:33:55] <orshem> good to know.
[14:37:58] <SimonSapin> I think I could have "bit fields" with a macro that expands to a [u8 ..$N] with get_foo() and set_foo() methods ... Or is there a better way?
[14:39:41] <SimonSapin> (methods that do actual bit manipulation, could be inlined and hopefully mostly constant-folded)
[14:39:57] <SiegeLord> Can macros support a syntax like this: var.foo!(a, b, c); ?
[14:40:14] <SimonSapin> I think not
[14:40:15] <cmr> SiegeLord: don't think so, no
[14:40:28] *** Joins: thpickert (thpickert@moz-34341F25.dynamic.dsl.tng.de)
[14:40:37] <kimundi> Would be nice if they could.. But afaik that's impossible
[14:41:30] <kimundi> Unless we invent associated macros :P
[14:44:09] <SimonSapin> "Macros, as currently implemented, are not for the faint of heart." Hum, indeed.
[14:44:25] <SiegeLord> rusti: macro_rules! test( () => {;} ) test!()
[14:44:26] -rusti- <anon>:5:35: 5:36 error: unexpected token: `;`
[14:44:26] -rusti- <anon>:5          macro_rules! test( () => {;} ) test!()
[14:44:26] -rusti-                                             ^
[14:44:27] -rusti- application terminated with error code 101
[14:44:45] <SiegeLord> What exactly do macros expand to?
[14:44:47] <bstrie> I don't think macros are ever intended to be for the faint of heart :) just like in lisp, macros should be used sparingly
[14:44:50] <cmr> SiegeLord: AST
[14:44:53] <SiegeLord> expressions? items?
[14:45:01] <SiegeLord> statements?
[14:45:03] <cmr> AST
[14:45:08] <cmr> all of those and more
[14:45:19] <cmr> it sucks in a token tree and spits out an AST
[14:45:27] <SimonSapin> Are macros turing-complete (or close enough)? Or is fmt!() implemented with magic?
[14:45:40] <SiegeLord> So why does that not work?
[14:45:59] <cmr> SimonSapin: fmt!() is magic. implemented with pure rust, isn't a macro, is a syntax extension
[14:46:13] <cmr> rusti: macro_rules! test( () => {} ) test!()
[14:46:14] -rusti- <anon>:1:0: 1:0 error: unexpected token: `<eof>`
[14:46:14] -rusti- <anon>:1 extern mod extra;
[14:46:14] -rusti-          ^
[14:46:14] -rusti- application terminated with error code 101
[14:46:18] <bstrie> macros themselves aren't powerful enough to peek inside of strings
[14:46:19] <SiegeLord> rusti: macro_rules! test( () => (;) ) test!()
[14:46:19] -rusti- <anon>:5:35: 5:36 error: unexpected token: `;`
[14:46:19] -rusti- <anon>:5          macro_rules! test( () => (;) ) test!()
[14:46:19] -rusti-                                             ^
[14:46:19] -rusti- application terminated with error code 101
[14:46:19] *** concrete.mozilla.org sets mode: +M 
[14:46:26] <SimonSapin> cmr: I suppose syntax extensions have to be in the compiler?
[14:46:30] <cmr> SimonSapin: for now yes
[14:46:39] <cmr> pauls: ^ why doesn't that work ?
[14:47:25] <SimonSapin> rusti: macro_rules! test( () => {()} ) test!()
[14:47:26] -rusti- ()
[14:47:45] <SimonSapin> cmr: I suppose you need something inside {}
[14:48:11] <bstrie> rusti: let foo = ;
[14:48:12] -rusti- <anon>:5:19: 5:20 error: unexpected token: `;`
[14:48:12] -rusti- <anon>:5          let foo = ;
[14:48:12] -rusti-                             ^
[14:48:12] -rusti- application terminated with error code 101
[14:48:26] *** Quits: infynyxx (infynyxx@moz-E95B370B.nyc.res.rr.com) (Client exited)
[14:48:27] <bstrie> rusti: let;
[14:48:27] -rusti- <anon>:5:12: 5:13 error: unexpected token: `;`
[14:48:27] -rusti- <anon>:5          let;
[14:48:27] -rusti-                      ^
[14:48:27] -rusti- application terminated with error code 101
[14:48:56] <SiegeLord> rusti: ;
[14:48:57] -rusti- ()
[14:49:02] <SiegeLord> rusti: ;;
[14:49:03] -rusti- ()
[14:49:21] *** Joins: novabyte (Instantbir@8543404.615B56E6.43362C16.IP)
[14:49:47] <bstrie> rusti: let foo = {};
[14:49:47] -rusti- <anon>:5:13: 5:16 warning: unused variable: `foo` [-W unused-variable (default)]
[14:49:48] -rusti- <anon>:5          let foo = {};
[14:49:48] -rusti-                       ^~~
[14:49:48] -rusti- ()
[14:49:49] *** Quits: cyndis (cyndis@moz-FA10A1CD.fi) (Ping timeout)
[14:49:57] <bstrie> rusti: let foo = {};;;;;
[14:49:58] -rusti- <anon>:5:13: 5:16 warning: unused variable: `foo` [-W unused-variable (default)]
[14:49:58] -rusti- <anon>:5          let foo = {};;;;;
[14:49:58] -rusti-                       ^~~
[14:49:58] -rusti- ()
[14:50:09] <SimonSapin> rusti: macro_rules! test( () => {{}} ) test!()
[14:50:09] -rusti- ()
[14:50:16] *** Joins: sankha93 (Instantbir@7061CD01.D6BD0D91.22D41759.IP)
[14:50:28] *** Joins: cyndis (cyndis@moz-FA10A1CD.fi)
[14:51:20] *** concrete.mozilla.org sets mode: -M 
[14:51:23] *** Quits: joelteon (joel@moz-317E8D0C.io) (Ping timeout)
[14:52:14] *** Joins: joelteon (joel@moz-317E8D0C.io)
[14:52:39] <kimundi> rusti: ;_;
[14:52:40] -rusti- <anon>:5:10: 5:11 error: unexpected token: `_`
[14:52:40] -rusti- <anon>:5          ;_;
[14:52:40] -rusti-                    ^
[14:52:40] -rusti- application terminated with error code 101
[14:55:33] <SiegeLord> rusti: +1
[14:55:33] -rusti- <anon>:5:9: 5:10 error: unexpected token: `+`
[14:55:34] -rusti- <anon>:5          +1
[14:55:34] -rusti-                   ^
[14:55:34] -rusti- application terminated with error code 101
[14:55:39] <SiegeLord> rusti: -1
[14:55:40] -rusti- -1
[14:56:04] <bstrie> rusti: --1
[14:56:05] -rusti- 1
[14:57:32] <SimonSapin> Can a macro expand to macro definitions?
[14:57:42] <engla> yes
[14:57:47] <engla> wait, no
[14:57:51] <cmr> are you sure they can't?
[14:57:58] <engla> I'm not sure
[14:58:03] <cmr> macro definitions are just macro invokation
[14:58:07] <cmr> which is allowed in macros
[14:58:12] <cmr> (I think)
[14:58:14] <jedestep> I think it will trip up when you define macro variables
[14:58:15] *** Quits: jensnockert (jensnocker@moz-C5F27039.cust.bredband2.com) (Input/output error)
[14:58:55] <bstrie> rusti: macro_rules fmt2!(() => fmt!("%?", 1))
[14:58:55] -rusti- <anon>:5:21: 5:25 error: expected `;` or `}` after expression but found `fmt2`
[14:58:55] -rusti- <anon>:5          macro_rules fmt2!(() => fmt!("%?", 1))
[14:58:55] -rusti-                               ^~~~
[14:58:56] -rusti- application terminated with error code 101
[14:59:12] <cmr> rusti: macro_rules! fmt2 (() => fmt!("%?", 1))
[14:59:13] -rusti- <anon>:5:37: 5:38 error: No rules expected the token: !
[14:59:13] -rusti- <anon>:5          macro_rules! fmt2 (() => fmt!("%?", 1))
[14:59:13] -rusti-                                               ^
[14:59:13] -rusti- application terminated with error code 101
[14:59:35] <engla> more () needed
[14:59:44] <cmr> rusti: macro_rules! fmt2 (() => (fmt!("%?", 1)))
[14:59:45] -rusti- ()
[14:59:47] <engla> nested invocations are ok
[14:59:53] <cmr> rusti: macro_rules! fmt2 (() => (fmt!("%?", 1))) fmt2!("yolo")
[14:59:54] -rusti- <anon>:5:57: 5:63 error: No rules expected the token: "yolo"
[14:59:54] -rusti- <anon>:5          macro_rules! fmt2 (() => (fmt!("%?", 1))) fmt2!("yolo")
[14:59:54] -rusti-                                                                   ^~~~~~
[14:59:54] -rusti- application terminated with error code 101
[14:59:57] *** Parts: monk (monk@moz-17CD0811.sunion.warwick.ac.uk) ()
[15:00:00] <cmr> rusti: macro_rules! fmt2 (() => (fmt!("%?", 1))) fmt2!()
[15:00:02] -rusti- ~"1"
[15:01:08] <klutzy> is there a way to easily link .o file which is generated by rustc -c?
[15:01:28] <klutzy> I am doing link by hands since I'm trying to create win32 WinMain binary
[15:01:41] <jedestep> rusti: macro_rules! outer(($t:expr) => macro_rules! inner(($u:expr) => println("%s %s", $t.to_str(), $u.to_str()))) outer!(5)
[15:01:41] -rusti- <anon>:5:52: 5:53 error: No rules expected the token: !
[15:01:41] -rusti- <anon>:5          macro_rules! outer(($t:expr) => macro_rules! inner(($u:expr) => println("%s %s", $t.to_str(), $u.to_str()))) outer!(5)
[15:01:41] -rusti-                                                              ^
[15:01:42] -rusti- application terminated with error code 101
[15:02:11] <cmr> klutzy: you can use -Z print-link-args to see what rustc uses to link
[15:02:29] <dbaupp> macros can't expand to macro definitions, https://github.com/mozilla/rust/issues/6994
[15:02:37] <jedestep> aww :( no curried macros
[15:03:05] *** Joins: infynyxx (infynyxx@moz-E95B370B.nyc.res.rr.com)
[15:03:34] *** Quits: pyrac (pyrac@moz-C9A4FCEC.w90-55.abo.wanadoo.fr) (Connection reset by peer)
[15:03:37] <klutzy> cmr: should I put -Z at Makefile to get them? :o
[15:03:48] *** Joins: pyrac (pyrac@moz-C9A4FCEC.w90-55.abo.wanadoo.fr)
[15:04:03] <cmr> klutzy: put it wherever you invoke rustc
[15:04:45] *** Quits: infynyxx (infynyxx@moz-E95B370B.nyc.res.rr.com) (Ping timeout)
[15:04:45] <jedestep> is github being extremely slow for anyone else
[15:04:49] <cmr> yes
[15:04:49] <klutzy> cmr: thanks! I'll try that now.
[15:04:58] <jedestep> it is making me sad
[15:04:59] <cmr> https://status.github.com/
[15:07:24] *** Joins: yonran (yonran@moz-962F33EB.acuitus.com)
[15:08:37] <bstrie> I wonder who actually bothers to ddos github
[15:09:27] <cmr> me too
[15:09:45] <bstrie> maybe it's a ransom thing
[15:09:48] <cmr> I'd like to phyiscally harm them :p
[15:10:00] <bstrie> I'd just like to psychically harm them
[15:10:06] <bstrie> that way I don't have to stand up
[15:10:26] *** Quits: barosl (barosl@E287D94F.C81E10FB.7544CABF.IP) (Quit: ëžœë¤ì€ ì‡ í‡´í–ˆìŠµë‹ˆë‹¤.)
[15:14:08] *** Quits: dbaupp (Thunderbir@moz-712A1135.lns20.syd6.internode.on.net) (Ping timeout)
[15:14:51] *** Joins: hjr3 (hradtke@1A0AE795.28A5F6C3.A2D40ED2.IP)
[15:15:17] *** Quits: novabyte (Instantbir@8543404.615B56E6.43362C16.IP) (Quit: bye bye)
[15:17:07] *** Joins: LU324_ (stuff@moz-A17E9A7B.dyn.embarqhsd.net)
[15:17:24] <thpickert> Again? Weren't they DDoSed just last week?
[15:17:25] *** Quits: LU324_ (stuff@moz-A17E9A7B.dyn.embarqhsd.net) (Connection reset by peer)
[15:17:39] *** Joins: LU324_ (stuff@moz-A17E9A7B.dyn.embarqhsd.net)
[15:17:44] *** Quits: LU324 (stuff@moz-A17E9A7B.dyn.embarqhsd.net) (Connection reset by peer)
[15:17:46] <cmr> it's a farirly frequent occurence
[15:18:09] *** Quits: heftig (heftig@6835D69C.6FC4DE2F.FEC4A986.IP) (Ping timeout)
[15:18:17] <thpickert> It's a silly occurence.
[15:18:20] <Seldaek> thpickert: from running cron jobs every 3mins against github for the last two years given the amount of email notifications I get I can tell you it's not rare that they're down or somewhat unstable 
[15:18:41] *** Joins: robertknight (robertknig@moz-54528EE0.wby.mendeley.com)
[15:18:42] <Seldaek> then again, they do have a crapton of traffic to deal with I suppose
[15:18:50] *** Joins: devinus (devinus@moz-B4AF84BC.ptr.us.xo.net)
[15:19:07] <thpickert> Yeah, most attacks probably just get absorbed in day-to-day traffic. :D
[15:26:07] *** Quits: henrikhodne (henrikhodn@moz-F3A92B1C.hsd1.ca.comcast.net) (Ping timeout)
[15:29:51] <orshem> why do i have to qualify sibling fn name inside an implementation?
[15:29:57] *** sankha93 is now known as sankha93|afk
[15:30:06] *** Joins: heftig (heftig@8D5076D2.6FC4DE2F.FEC4A986.IP)
[15:31:00] *** Joins: erickt (erickt@8C9ECD8F.3A598286.F12515B4.IP)
[15:31:39] <bstrie> orshem: what do you mean? is it a static method?
[15:32:26] *** Joins: The_third_man (ripault@moz-3CE49532.lrde.epita.fr)
[15:33:07] <The_third_man> Hi, does anyone know how I can look at the current iterator value, without advancing it ?
[15:33:22] <bstrie> is there a .peek() method, perhaps?
[15:33:24] <orshem> yep. I'm calling new from a more specialized constructor 
[15:33:31] <orshem> bstrie: ^
[15:33:35] <orshem> and thanks
[15:34:10] <bstrie> orshem: you always have to qualify static methods with either a trait or type on the front. I'm not sure if there's a reason beyond readability
[15:34:46] <bstrie> rusti: [1,2,3].iter().peek()
[15:34:46] <The_third_man> bstrie: there is peek_, but it returns a PeekIterator
[15:34:46] -rusti- <anon>:5:9: 6:5 error: type `std::vec::VecIterator<,<VI2>>` does not implement any method in scope named `peek`
[15:34:46] -rusti- <anon>:5          [1,2,3].iter().peek()
[15:34:46] -rusti- <anon>:6     };
[15:34:47] -rusti- error: aborting due to previous error
[15:34:47] -rusti- application terminated with error code 101
[15:34:47] <orshem> but inside the trait/type implementation? it's a bit ridiculous
[15:35:10] <bstrie> orshem: what would you propose?
[15:35:37] <jedestep> perhaps something like Self::static_function()?
[15:36:07] <jedestep> it makes a difference if my struct is called InternalFrameInternalFrameWindowNotFocusedButtonMaximizedState
[15:36:15] *** Joins: int3_ (int3_@moz-ABE52D50.hsd1.ca.comcast.net)
[15:36:16] <orshem> bstrie: like in c++/java
[15:36:32] *** Quits: pnkfelix (pnkfelix@87C1F78E.1DE10CA8.D8E68FF6.IP) (Quit: Leaving.)
[15:36:35] <orshem> iirc you don't need to qualify method inside the same class
[15:37:13] <cmr> The_third_man: No, it's not possible
[15:37:21] <cmr> The_third_man: There *is* no current value, until you advance it
[15:37:24] <jedestep> you could run into an issue though
[15:37:29] <orshem> so in Rust you won't need to qualify method names inside the 'impl' itself
[15:37:59] <orshem> same for trait's default fns
[15:38:03] <jedestep> fn foo() { println("hi") } impl SomeTrait for SomeStruct { fn foo() { println("sup") } }
[15:38:06] <bstrie> orshem: java doesn't require you to qualify static methods?
[15:38:10] <bstrie> that's news to me
[15:38:31] <orshem> while calling from another static method, i think not. but let me look it up
[15:38:35] *** Quits: sankha93|afk (Instantbir@7061CD01.D6BD0D91.22D41759.IP) (Ping timeout)
[15:38:39] <jedestep> java requires you to qualify static methods unless you static import them
[15:38:42] <bstrie> I though the only difference between the invocation of static and non-static was that the latter involves a `new` somewhere
[15:38:48] *** Joins: pnkfelix (pnkfelix@87C1F78E.1DE10CA8.D8E68FF6.IP)
[15:38:52] <jedestep> while normally you would do Math.random
[15:38:57] <jedestep> or whatever
[15:39:08] *** Joins: Jeaye (Jeaye@moz-FD505E54.hsd1.ca.comcast.net)
[15:39:12] <jedestep> you can do `import static java.util.Math.*;` and then just call random
[15:39:21] <orshem> jedestep: not in the same scope
[15:39:44] *** Joins: sankha93|afk (Instantbir@7061CD01.D6BD0D91.22D41759.IP)
[15:39:49] *** Quits: pnkfelix (pnkfelix@87C1F78E.1DE10CA8.D8E68FF6.IP) (Quit: Leaving.)
[15:40:20] <orshem> jedestep, bstrie: see here: http://introcs.cs.princeton.edu/java/21function/ (first link from google :))
[15:40:35] <bstrie> orshem: if there's precedence from other languages then I think it would be fair to consider it. would you mind bringing it up on the mailing list?
[15:40:48] <The_third_man> ok, thanks cmr 
[15:40:52] <bstrie> either that, or at least make an issue for it
[15:41:07] <orshem> i don't have a github account
[15:41:29] <jedestep> i knew this -_- it's been too long since i've done any java
[15:41:49] <orshem> and i feel unqualified to bother people on the ml
[15:42:03] <bstrie> orshem: bah, I'm unqualified and I bother people all the time :)
[15:42:08] <cmr> (truth!)
[15:42:12] <cmr> ;)
[15:42:16] <bstrie> trust me, nobody here is more unqualified than me
[15:42:17] <jedestep> lol
[15:43:35] <orshem> bstrie: i doubt that
[15:43:50] <orshem> :)
[15:44:27] *** Joins: nano (nano@moz-972880B.superkabel.de)
[15:45:30] *** Joins: ozten (ozten@moz-DD3B00B4.hsd1.wa.comcast.net)
[15:46:18] <cmr> Does anyone have a library, project, demoware, or anything else they would like featured in TWiR?
[15:48:22] <bstrie> cmr: mongodb driver!
[15:48:44] <cmr> OI! https://togototo.wordpress.com/2013/07/23/benchmarking-level-generation-go-rust-haskell-and-d/
[15:48:52] <cmr> We beat go, gcc, and haskell!
[15:49:10] <bstrie> cmr: I'm working on a version that stack-allocates like the D implementation
[15:49:21] <bstrie> wondering if that might close the gap with D
[15:50:10] <erickt> cmr: there's been a lively discussion about unsafe pointers on the mailing list
[15:50:21] <cmr> erickt: yes, I've included that
[15:50:35] <erickt> cmr: although the decision on what to do hasn't happened yet
[15:50:42] <erickt> cmr: righto :)
[15:50:51] *** Quits: mark_edward (quassel@moz-4A5B1251.wisolt4.epbfi.com) (Ping timeout)
[15:51:40] *** Joins: pnkfelix (pnkfelix@moz-A474E5FD.w80-12.abo.wanadoo.fr)
[15:52:27] *** Joins: tiffany (kawaii@moz-EB8B0C08.dhcp.embarqhsd.net)
[15:53:02] *** Joins: mihneadb (mihneadb@moz-BE33DA21.fw1.sfo1.mozilla.net)
[15:53:10] <erickt> cmr: you know what would be a nice to include at some point in time? A mini-tutorial on how to use rustpkg. I don't think we have one yet. I keep meaning to talk to tjc about it, but I haven't had the time yet
[15:53:23] *** Joins: mark_edward (quassel@moz-4A5B1251.wisolt4.epbfi.com)
[15:53:45] <cmr> erickt: Sure, if someone writes one I'd definitely love to include it as a feature
[15:55:30] <cmr> Florob: How about RustyXML?
[15:55:54] *** Yurume_ is now known as Yurume
[15:56:53] <Florob> cmr: How did you even see that?
[15:57:13] <cmr> Florob: https://github.com/languages/Rust/created and https://github.com/languages/Rust/updated :)
[15:57:55] <bstrie> haha
[15:58:01] <bstrie> you cannot hide from cmr's all-seeing eye
[15:58:05] <Florob> cmr: I would not mind per-se. But I'm self-concious enough the code is crappy right now (and the first thing I ever wrote in rust)
[15:58:05] <cmr> NOPE
[15:58:13] <bstrie> I mean, unless you include 200 python files in your project to fool github
[15:58:25] <Yurume> rusti: trait A{fn f(&self)->int;} struct a; impl A for a{fn f(&self)->int{42}} let x=~a as ~A; println(fmt!("%d",x.f()));
[15:58:25] <cmr> bstrie: Even that won't work
[15:58:25] -rusti- 42
[15:58:25] -rusti- ()
[15:58:26] <bstrie> which is basically why servo is listed as a python project ;_;
[15:58:34] *** Joins: carllerche (carllerche@6B070D22.7E6A0813.1428D117.IP)
[15:58:35] <Yurume> ha, that is strange...
[15:58:38] <cmr> I saw two projects listed in there that were obj-c
[15:58:48] <cmr> With binary blobs with a .rs extension
[15:59:14] *** Joins: infynyxx (infynyxx@DB780A29.749BA1D.DCC373F0.IP)
[15:59:28] <jdm> heh
[15:59:32] *** Quits: mark_edward (quassel@moz-4A5B1251.wisolt4.epbfi.com) (Ping timeout)
[15:59:34] <bstrie> for a long time github was convinced that rustc was about 3% obj-c
[15:59:35] <Yurume> rusti: trait A{fn f(&self)->int;} struct a; impl A for a{fn f(&self)->int{42}} let x=Some(~a as ~A); println(fmt!("%d",x.unwrap().f()));
[15:59:36] -rusti- 42
[15:59:36] -rusti- ()
[15:59:40] <Yurume> hmm..
[16:00:00] <bstrie> also we told github to stop counting .rc files as rust files in january of 2012
[16:00:05] <bstrie> so 18 months ago
[16:00:23] <bstrie> they're still counting them for like two big projects ;_;
[16:00:38] <cmr> https://github.com/sebcrozet/rs2cl
[16:00:40] <bblum> rusti: trait A{fn f(~self)->int;} struct a; impl A for a{fn f(~self)->int{42}} let x=Some(~a as ~A); println(fmt!("%d",x.unwrap().f()));
[16:00:40] <bstrie> hence why there are cyanogenmod things on the rust projects page
[16:00:41] -rusti- 42
[16:00:41] -rusti- ()
[16:00:47] <cmr> Can't wait till that solidifies!
[16:00:49] <bblum> huh,i thought that crashed
[16:00:54] <Yurume> rusti: trait A{fn f(&self)->int;} struct a; impl A for a{fn f(&self)->int{42}} let x=Some(~a.clone() as ~A); println(fmt!("%d",x.unwrap().f()));
[16:00:56] -rusti- line longer than 150 columns, pastebinned: http://sprunge.us/AIeU
[16:00:57] <Seldaek> bstrie: might be worth emailing support@github about that
[16:01:20] <Yurume> rusti: trait A{fn f(&self)->int;} #[deriving(Clone)]struct a; impl A for a{fn f(&self)->int{42}} let x=Some(~a.clone() as ~A); println(fmt!("%d",x.unwrap().f()))
[16:01:21] -rusti- line longer than 150 columns, pastebinned: http://sprunge.us/XVVY
[16:01:21] <bstrie> we actually used to be really, really high up in the github language popularity chart because of the .rc thing
[16:01:26] <bstrie> we were like 22nd most popular language
[16:02:03] <bstrie> now we're somewhere in the 40s, which seems more accurate :)
[16:02:06] *** Joins: etw (john@5ADED2BB.8145FF59.D8D886B.IP)
[16:02:35] <bstrie> we're doing better than a lot of other "not done yet" languages, but probably only because the compiler itself is such a popular project
[16:03:13] <bstrie> like, julia and dart are waay up there
[16:03:45] <Yurume> okay, so I have a trait `Encoding` and lots of impls. some function returns `Option<~Encoding>` and it seems that it is attached an implicit kind `Send`. and when I try to call a method of unwrapped `~Encoding` the compiler complains..
[16:03:49] *** Joins: ecr (Thunderbir@moz-F724119C.uoregon.edu)
[16:03:55] <orshem> bstrie: i think i figure out why it is explicit. since this pointer is explicit as well in Rust (as self) and you can't reference other non static methods implicitly it would be out of place to make the static case implicit
[16:03:55] <Yurume> something like this: encoding.rs:64:12: 64:51 error: failed to find an implementation of trait types::Encoding for ~types::Encoding:Send
[16:04:16] <Yurume> is it a normal behavior?
[16:04:59] <bstrie> orshem: like I said, there may well be a good reason why we require it to be qualified. perhaps that's it! you'd have to ask pcwalton
[16:05:08] <Yurume> I thought that an owned box of a trait X implicitly implements X...
[16:05:11] *** Joins: alisdair (textual@1697D94C.7742FB18.FBC8476D.IP)
[16:05:17] <engla> Yurume: it doesn't impl X
[16:05:20] <engla> unfortunately
[16:05:42] *** Joins: lkuper (lkuper@5188CCE.A402E718.C082B7DC.IP)
[16:05:51] <Yurume> engla, woah
[16:05:59] <Yurume> but I don't see any workaround then...
[16:06:07] <cmr> impl X for ~X
[16:06:29] <engla> yes you can implement it
[16:06:48] <engla> if not for the ~Encoding then for a wrapper type like   struct Wrap(~Encoding)
[16:06:51] <Yurume> ah, I accidentally put one more deference to the impl...
[16:07:10] <Yurume> thank you
[16:07:21] *** Quits: jorendorff (jorendorff@moz-2F32ACA3.hsd1.tn.comcast.net) (Quit: jorendorff)
[16:07:35] *** Quits: doener (bs@moz-AA189A5A.unitymedia.biz) (Quit: leaving)
[16:07:42] <Yurume> (yes, that was the first thing I attempted, and I've got it incorrect :S)
[16:08:20] *** Quits: km (quassel@FDBAF0A0.DBF71E41.29C67456.IP) (Ping timeout)
[16:08:48] *** Quits: Florob (florian@E4BCD297.B50A917B.CD80E335.IP) (Quit: leaving)
[16:08:53] *** Joins: Florob (florob@moz-39532932.de)
[16:08:55] *** Joins: bent (chatzilla@moz-BE33DA21.fw1.sfo1.mozilla.net)
[16:09:02] *** Joins: jorendorff (jorendorff@moz-2F32ACA3.hsd1.tn.comcast.net)
[16:09:29] *** Joins: km (quassel@FDBAF0A0.DBF71E41.29C67456.IP)
[16:10:59] *** Joins: azita (Azita@8BB81540.E2EA453A.FAF22AF7.IP)
[16:13:29] *** Joins: ghrust (ghrust@9C8B94D4.6A2AE50.F3114085.IP)
[16:13:29] <ghrust> 01[13rust01] 15bors merged 06auto into 06master: 02http://git.io/HF9fRg
[16:13:29] *** Parts: ghrust (ghrust@9C8B94D4.6A2AE50.F3114085.IP) ()
[16:15:57] *** Quits: libertas (libertas@moz-AF094932.rev.vodafone.pt) (Quit: Lost terminal)
[16:16:23] *** Joins: ghrust (ghrust@5FEF1C87.6A2AE50.F3114085.IP)
[16:16:24] <ghrust> 01[13rust01] 15bors pushed 0 new commits to 06auto: 02http://git.io/cdpaHg
[16:16:24] *** Parts: ghrust (ghrust@5FEF1C87.6A2AE50.F3114085.IP) ()
[16:16:26] *** Joins: ghrust (ghrust@1E8607E8.6A2AE50.F3114085.IP)
[16:16:26] <ghrust> 01[13rust01] 15bors pushed 4 new commits to 06auto: 02http://git.io/qjCKmw
[16:16:26] <ghrust> 13rust/06auto 148fb77c7 15gifnksm: tutorial: Repair broken links
[16:16:26] <ghrust> 13rust/06auto 149aab7e5 15gifnksm: tutorial: Fix obsolete names
[16:16:26] <ghrust> 13rust/06auto 14e68697b 15gifnksm: tutorial: Remove the sentence about mutable fields.
[16:16:27] *** Parts: ghrust (ghrust@1E8607E8.6A2AE50.F3114085.IP) ()
[16:18:12] *** Joins: BitPuffin (quassel@moz-49828767.cust.tele2.se)
[16:18:58] *** Joins: graydon (graydon@moz-F14EE0DB.cable.teksavvy.com)
[16:18:58] *** ChanServ sets mode: +qo graydon graydon
[16:19:13] *** Quits: azita (Azita@8BB81540.E2EA453A.FAF22AF7.IP) (Quit: azita)
[16:19:36] *** Joins: jeff (jeff@moz-F81F6C4E.nyc.biz.rr.com)
[16:20:06] *** Quits: jeff (jeff@moz-F81F6C4E.nyc.biz.rr.com) (Quit: jeff)
[16:20:13] *** Quits: graydon (graydon@moz-F14EE0DB.cable.teksavvy.com) (Connection reset by peer)
[16:20:18] *** Quits: pyrac (pyrac@moz-C9A4FCEC.w90-55.abo.wanadoo.fr) (Quit: pyrac)
[16:21:04] *** Joins: pyrac (pyrac@moz-C9A4FCEC.w90-55.abo.wanadoo.fr)
[16:21:14] *** Joins: jaen (jaen@moz-E0979827.copit.pl)
[16:21:17] *** Joins: Uther (Instantbir@moz-1B244B05.hfc.dyn.abo.bbox.fr)
[16:23:25] *** Quits: devinus (devinus@moz-B4AF84BC.ptr.us.xo.net) (Quit: Computer has gone to sleep.)
[16:25:54] *** Quits: jaen (jaen@moz-E0979827.copit.pl) (Ping timeout)
[16:28:48] <cmr> https://gist.github.com/cmr/d9c080f2ae5a811ae508
[16:29:00] <cmr> It's the tiny things that rust does right that endear it to me
[16:29:12] <cmr> (pretend that's a valid sentence)
[16:29:28] *** Joins: graydon (graydon@moz-F14EE0DB.cable.teksavvy.com)
[16:29:28] *** ChanServ sets mode: +qo graydon graydon
[16:29:54] <bstrie> cmr: that looks more like c++ to me :P
[16:30:00] <cmr> bstrie: it is C
[16:30:11] <cmr> And specifically it is omitting the braces on the `else if`
[16:30:19] <cmr> Which... ugh
[16:30:26] <bstrie> yeah, I saw :P
[16:30:41] *** Quits: igl1 (igl@moz-299512C5.adsl.alicedsl.de) (Ping timeout)
[16:30:52] <bstrie> well at least it seems like bors is still chugging through the github downtime
[16:31:29] <bstrie> oh maybe they're back up
[16:32:23] *** Joins: igl (igl@moz-59805477.adsl.alicedsl.de)
[16:34:44] *** Joins: maikklein (maik@moz-EDC31EF0.dip0.t-ipconnect.de)
[16:35:49] *** Quits: ipc (ipc@moz-76ED5036.lightspeed.cicril.sbcglobal.net) (Ping timeout)
[16:36:00] *** Joins: henrikhodne (henrikhodn@moz-87E975F1.dsl.static.sonic.net)
[16:37:03] *** Joins: eholk (eholk@moz-94A2F911.uconnect.utah.edu)
[16:38:57] *** Quits: Kruppe (user@moz-E150F49F.cpe.net.cable.rogers.com) (Client exited)
[16:39:05] *** Quits: jedestep (jedestep@34641662.FB4DE631.66C78B76.IP) (Ping timeout)
[16:40:57] *** Joins: eschweic (Adium@moz-BBE3ABD.mv.mozilla.com)
[16:40:58] *** Parts: homa_rano (edre@moz-223EA699.csail.mit.edu) ()
[16:41:23] *** Joins: tchoma (tchoma@moz-BBE3ABD.mv.mozilla.com)
[16:42:17] *** Joins: spider-mario (spidermari@moz-81131DB6.fbx.proxad.net)
[16:42:41] *** Joins: bheylin (brianheyli@moz-8255E94E.adsl.online.nl)
[16:42:56] *** Quits: etw (john@5ADED2BB.8145FF59.D8D886B.IP) (Ping timeout)
[16:43:05] <cmr> http://cmr.github.io/blog/2013/07/29/last-week-in-rust/ feedback before I embarass myself on the ML/reddit?
[16:44:05] <kimundi> r? https://github.com/mozilla/rust/pull/8082
[16:44:24] *** Joins: Houm_ (Houm@moz-25669AA8.fbx.proxad.net)
[16:44:28] *** Quits: Houm (Houm@moz-25669AA8.fbx.proxad.net) (Ping timeout)
[16:44:54] *** Quits: igl (igl@moz-59805477.adsl.alicedsl.de) (Ping timeout)
[16:44:54] *** Joins: igl1 (igl@moz-E735AC88.adsl.alicedsl.de)
[16:46:22] *** cade is now known as cade_bbiab
[16:46:27] *** Joins: jaen (jaen@moz-E0979827.copit.pl)
[16:46:55] *** Joins: jyasskin_w (jyasskin@DAF66858.C60FE7DC.4065847B.IP)
[16:47:27] *** sankha93|afk is now known as sankha93
[16:48:14] *** Quits: igl1 (igl@moz-E735AC88.adsl.alicedsl.de) (Ping timeout)
[16:48:53] *** Joins: doener (doener@moz-121949B3.unitymediagroup.de)
[16:51:53] *** Quits: xraycat (Adium@moz-4F58939A.pool.mediaways.net) (Quit: Leaving.)
[16:52:24] <carllerche> has the tcp libraries been removed from rust for now? (it's been a while since I looked)
[16:52:27] *** Quits: mihneadb (mihneadb@moz-BE33DA21.fw1.sfo1.mozilla.net) (Ping timeout)
[16:52:29] *** Joins: mihneadb_ (mihneadb@moz-BE33DA21.fw1.sfo1.mozilla.net)
[16:53:52] *** Joins: engla_ (engla@moz-DBD1D96E.cust.bredbandsbolaget.se)
[16:54:07] *** Quits: bheylin (brianheyli@moz-8255E94E.adsl.online.nl) (Quit: bheylin)
[16:54:39] *** Quits: engla (engla@moz-DBD1D96E.cust.bredbandsbolaget.se) (Ping timeout)
[16:55:15] *** Quits: erickt (erickt@8C9ECD8F.3A598286.F12515B4.IP) (Quit: Leaving.)
[16:57:10] <jdm> carllerche: it was, but newer ones may have landed too
[16:57:16] * jdm isn't sure of the status of that PR
[16:57:26] <jdm> carllerche: oh, they're listed in http://cmr.github.io/blog/2013/07/29/last-week-in-rust/
[16:57:31] <carllerche> jdm: ahâ€¦ I see the io package, but there didn't seem to be anything around tcp
[16:57:32] <carllerche> thx
[16:57:57] <cmr> There is experimental networking in std::rt::io::net, I believe
[16:58:01] *** Joins: maikklein2 (maik@moz-42794001.dip0.t-ipconnect.de)
[16:58:16] *** Quits: davbo (dave@moz-3FFA637C.oucs.ox.ac.uk) (Client exited)
[16:58:55] *** Quits: maikklein (maik@moz-EDC31EF0.dip0.t-ipconnect.de) (Ping timeout)
[16:59:02] *** Joins: erickt (erickt@8C9ECD8F.3A598286.F12515B4.IP)
[16:59:46] *** Quits: jaen (jaen@moz-E0979827.copit.pl) (Connection reset by peer)
[16:59:47] <carllerche> cmr: this? https://github.com/mozilla/rust/blob/master/src/libstd/rt/uv/net.rs
[17:00:02] <cmr> carllerche: https://github.com/mozilla/rust/tree/master/src/libstd/rt/io/net that
[17:00:14] <carllerche> ah, nice
[17:00:16] *** Quits: hjr3 (hradtke@1A0AE795.28A5F6C3.A2D40ED2.IP) (Quit: My MacBook has gone to sleep. ZZZzzzâ€¦)
[17:00:35] <cmr> http://hg.chrismorgan.info/rusthttpserver/ as an example of something using it
[17:00:43] *** Quits: nano (nano@moz-972880B.superkabel.de) (Connection reset by peer)
[17:00:51] <carllerche> very cool, gives me a starting point
[17:01:51] <toddaaro> what does the annotation "#[cfg(not(stage0))]" and what is it for?
[17:02:13] <cmr> toddaaro: conditonal compilation for staging
[17:02:22] <cmr> only uses that item on non-stage0 builds (ie, not the snapshot)
[17:02:31] <toddaaro> aatch added the atomic_fence intrinsic for me over the weekend, but I'm trying to use it in the runtime which and failing during stage0 with "unresolved_name" on the fence
[17:02:43] <toddaaro> I'm not sure what is going on there
[17:02:58] <toddaaro> is there some bootstrapping that needs to happen before I can use it or something?
[17:03:05] <doener> toddaaro: the first build (stage0) is done with a snapshot (== old) compiler
[17:03:12] <doener> toddaaro: that doesn't know the fence yet
[17:03:15] <cmr> If you want to use it in stage0, you'll need to make a snapshot
[17:03:20] <toddaaro> how do I do that?
[17:03:32] *** Joins: eschweic1 (Adium@moz-BBE3ABD.mv.mozilla.com)
[17:03:57] *** Quits: eschweic (Adium@moz-BBE3ABD.mv.mozilla.com) (Connection reset by peer)
[17:04:03] <cmr> https://github.com/mozilla/rust/wiki/Note-compiler-snapshots
[17:04:24] <cmr> Basically push to snap-stage3, if it succeeds, add the commit in snapshots.txt and open a PR
[17:04:26] *** Joins: hjr3 (hradtke@1A0AE795.28A5F6C3.A2D40ED2.IP)
[17:04:50] <toddaaro> ok, thanks
[17:04:52] <toddaaro> I'll look into this
[17:05:34] <cmr> Or, just copy the function you're working on, slap a #[cfg(stage0)] on it, and add a #[cfg(not(stage0))] version of it that uses the fence
[17:05:41] *** Joins: igl (igl@moz-1438006E.adsl.alicedsl.de)
[17:05:57] *** Quits: miloshadzic (miloshadzi@5E9C7FE4.FA4D0618.449B8A48.IP) (Quit: Textual IRC Client: www.textualapp.com)
[17:06:24] *** Joins: etw (john@5ADED2BB.8145FF59.D8D886B.IP)
[17:07:35] *** Joins: jedestep (jedestep@34641662.FB4DE631.66C78B76.IP)
[17:08:19] *** Joins: webber46 (webber46@moz-98D2F3C5.cust.bredband2.com)
[17:09:06] *** Quits: graydon (graydon@moz-F14EE0DB.cable.teksavvy.com) (Ping timeout)
[17:09:22] *** Quits: The_third_man (ripault@moz-3CE49532.lrde.epita.fr) (Quit: leaving)
[17:09:25] <toddaaro> looking at the snapshot documentation, it mentions incoming a lot
[17:09:32] <toddaaro> do I just s/incoming/master ?
[17:09:41] <kimundi> yes
[17:10:05] <kimundi> incoming is gone, long live master
[17:10:10] *** Joins: brson (brson@E9CDE21E.991753BB.CA4D1600.IP)
[17:10:10] *** ChanServ sets mode: +o brson
[17:10:18] *** Quits: pnkfelix (pnkfelix@moz-A474E5FD.w80-12.abo.wanadoo.fr) (Quit: Leaving.)
[17:10:58] <toddaaro> this seems pretty easy
[17:11:07] *** Quits: dan_johnsin (dan_johnsi@6902762D.11B071D.FB9A45AF.IP) (Client exited)
[17:11:11] *** Quits: CarpNet (ac@moz-FD24B77.sohonet.co.uk) (Quit: Leaving)
[17:11:11] <toddaaro> I'll start following the steps now
[17:11:44] *** Joins: tikue (tkuehn@moz-BBE3ABD.mv.mozilla.com)
[17:11:57] *** Joins: eatkinson (eatkinson@moz-BBE3ABD.mv.mozilla.com)
[17:12:10] *** Joins: dan_johnsin (dan_johnsi@6902762D.11B071D.FB9A45AF.IP)
[17:13:24] *** Joins: devinus (devinus@moz-B4AF84BC.ptr.us.xo.net)
[17:13:35] *** Quits: jedestep (jedestep@34641662.FB4DE631.66C78B76.IP) (Ping timeout)
[17:14:34] *** Quits: kertap (kertap@moz-D50677C9.b-ras3.mvw.galway.eircom.net) (Quit: kertap)
[17:14:46] *** Joins: graydon (graydon@moz-F14EE0DB.cable.teksavvy.com)
[17:14:46] *** ChanServ sets mode: +qo graydon graydon
[17:17:57] <toddaaro> oh, and the cfg(not(stage0)), do I remove that at some point during the snapshot process?
[17:18:27] <cmr> when you make the PR adding the snapshot to snapshots.txt
[17:18:32] *** Joins: azakai (alon@moz-BBE3ABD.mv.mozilla.com)
[17:18:34] <toddaaro> k
[17:18:35] <cmr> you get to go through the whole codebase and remove the staging :)
[17:18:50] <cmr> (shouldn't be bad, there was a recent snapshot)
[17:18:56] <toddaaro> yea, 7 days ago I think
[17:19:19] *** Joins: pnkfelix (pnkfelix@87C1F78E.1DE10CA8.D8E68FF6.IP)
[17:20:48] *** Joins: tjc (tjc@moz-BBE3ABD.mv.mozilla.com)
[17:20:48] *** ChanServ sets mode: +o tjc
[17:21:45] *** Joins: echristo (echristo@DCF57675.D6CCE4AE.77834EAA.IP)
[17:23:10] *** Joins: Blub\w (wry@moz-C20DF5E.vps.tuwien.ac.at)
[17:25:51] *** Joins: snadon (chatzilla@moz-3BC727E8.mc.videotron.ca)
[17:27:00] <toddaaro> anyone know what would make the test suite hang? but not inside a test, the last output printed was an "ok" and a print statement for the next test never started
[17:27:40] <bstrie> toddaaro: are you running the test suite in parallel?
[17:27:42] <cmr> toddaaro: are you looking in the buildbot lgos?
[17:27:48] *** Quits: pnkfelix (pnkfelix@87C1F78E.1DE10CA8.D8E68FF6.IP) (Quit: Leaving.)
[17:27:50] <cmr> *logs
[17:28:05] <toddaaro> bstrie: I don't think so
[17:28:09] <toddaaro> cmr: what logs should I look at?
[17:28:36] <doener> toddaaro: which tests are you at?
[17:28:53] <cmr> toddaaro: I'm asking if you are (the buildbots like to pretend they are hung; I think it's a flushing problem)
[17:28:54] <doener> toddaaro: On one box, I experienced random deadlocks in the rustpkg tests
[17:29:01] *** Quits: alisdair (textual@1697D94C.7742FB18.FBC8476D.IP) (Quit: My MacBook Pro has gone to sleep. ZZZzzzâ€¦)
[17:29:27] <toddaaro> cmr: ah, no, local machine
[17:29:37] <toddaaro> doener: weird, random deadlocks seems to describe it
[17:29:43] <toddaaro> what test I'm at seems to be random
[17:30:10] <doener> toddaaro: is there a hung rustc around? Try to attach to it using gdb and get a backtrace
[17:30:17] <doener> rustc or rustpkg
[17:30:34] *** Joins: infynyxx_ (infynyxx@DB780A29.749BA1D.DCC373F0.IP)
[17:30:37] <toddaaro> I'm getting this with make check-stage1-std
[17:30:54] *** Quits: infynyxx (infynyxx@DB780A29.749BA1D.DCC373F0.IP) (Ping timeout)
[17:31:03] <toddaaro> though it looks like one of the old runtime tests "test_spawn_sched_blocking" seems to be the last one showing more often than not
[17:31:35] <tjc> graydon: you probably know, but I didn't get a bug triage email
[17:31:50] *** Quits: Blub\w (wry@moz-C20DF5E.vps.tuwien.ac.at) (Ping timeout)
[17:32:25] *** Joins: jedestep (jedestep@34641662.FB4DE631.66C78B76.IP)
[17:32:50] <graydon> gr
[17:33:31] <graydon> gnrrr
[17:33:34] <graydon> github again
[17:34:38] <toddaaro> ok, it looks like the testcase test_spawn_sched_blocking is deadlocking with a bunch of threads stuck in "lock_and_signal::wait"
[17:34:51] <brson> toddaaro: setting RUST_THREADS=1 will run the tests serially and show which one is deadlocking
[17:35:01] *** Joins: jeff (jeff@moz-F81F6C4E.nyc.biz.rr.com)
[17:35:35] <toddaaro> oh, so it runs in parallel unless you explicitly tell it not to
[17:35:37] *** Quits: Jesse (jruderman@moz-537BCF9.hsd1.ca.comcast.net) (Quit: Jesse)
[17:35:59] <brson> toddaaro: yes
[17:36:02] <toddaaro> ah, ok
[17:36:09] <toddaaro> now I'm getting the behavior I was expecting, thanks
[17:37:46] *** Joins: mschifer (Adium@moz-BBE3ABD.mv.mozilla.com)
[17:38:51] <tjc> graydon: Got it now, thanks
[17:40:05] <Yurume> https://github.com/lifthrasiir/rust-encoding yeah, I've got this working.
[17:41:49] *** Quits: erickt (erickt@8C9ECD8F.3A598286.F12515B4.IP) (Quit: Leaving.)
[17:42:06] <toddaaro> I'm trying a fresh build of master and I'm stuck on this llvm compile error, anyone have ideas? http://pastebin.mozilla.org/2738633 
[17:42:29] <toddaaro> working on three workspaces at once I can generate build questions so much faster than usual
[17:43:54] *** Quits: lucian (lucian@6B2B4644.4304AE1E.CE5E78F6.IP) (Ping timeout)
[17:44:40] <sully> what is pnkfelix's name on IRC?
[17:44:51] <tjc> sully: pnkfelix, he's just not online rn
[17:44:58] <sully> ok
[17:45:43] <toddaaro> I guess this llvm error is related to the "first-build" path, that doesn't exist and shouldn't
[17:45:49] <toddaaro> it isn't in my path
[17:45:52] *** Joins: nano (nano@moz-972880B.superkabel.de)
[17:46:57] <tjc> brson graydon nmatsakis : any strong feelings about https://github.com/mozilla/rust/issues/6965 ? (return inside a lambda)
[17:46:58] *** Quits: mihneadb_ (mihneadb@moz-BE33DA21.fw1.sfo1.mozilla.net) (Connection reset by peer)
[17:47:05] <tjc> I believe it's working as intended, but any strong feelings about changing it?
[17:47:06] *** Joins: mihneadb (mihneadb@moz-BE33DA21.fw1.sfo1.mozilla.net)
[17:47:34] *** Quits: mihneadb (mihneadb@moz-BE33DA21.fw1.sfo1.mozilla.net) (Connection reset by peer)
[17:47:41] <graydon> tjc: working as intended
[17:47:44] <brson> agree
[17:47:57] *** Joins: mihneadb (mihneadb@moz-BE33DA21.fw1.sfo1.mozilla.net)
[17:47:57] <tjc> graydon brson : Ok cool, that's what I thought. I'mm close.
[17:48:11] *** Quits: km (quassel@FDBAF0A0.DBF71E41.29C67456.IP) (Ping timeout)
[17:50:18] *** cade_bbiab is now known as cade
[17:50:41] <kmc> what is &const for anyway
[17:51:11] *** Joins: xazax (xazax@moz-D7592A2A.csoma.elte.hu)
[17:51:45] <cmr> like &, except it can alias &mut
[17:51:53] <cmr> "can be mutable, just not through this reference"
[17:52:06] *** Quits: xazax (xazax@moz-D7592A2A.csoma.elte.hu) (Quit: Leaving)
[17:52:32] <kmc> huh, strange name for that
[17:52:59] <engla_> it's like a C const *
[17:53:06] *** Joins: erickt (erickt@8C9ECD8F.3A598286.F12515B4.IP)
[17:54:24] <kimundi> Yurume: Nice
[17:54:26] *** Quits: jeff (jeff@moz-F81F6C4E.nyc.biz.rr.com) (Quit: jeff)
[17:54:46] *** Quits: erickt (erickt@8C9ECD8F.3A598286.F12515B4.IP) (Ping timeout)
[17:54:50] <Yurume> kimundi, I wanted to get a proper CJK support, but that is naturally a big task so I saved it for later ;)
[17:55:19] <Yurume> I think the interface is reasonable, but not sure how it will work in practice
[17:55:38] <kimundi> Yurume: Did you look into integrating it with std::ascii yet?
[17:55:56] <Yurume> it seems reasonable, but not yet.
[17:56:11] *** Joins: km (quassel@FDBAF0A0.DBF71E41.29C67456.IP)
[17:57:02] *** Joins: jeff (jeff@moz-F81F6C4E.nyc.biz.rr.com)
[17:57:22] *** Joins: rustyPipe (Mibbit@moz-5949C51B.dllstx.fios.verizon.net)
[17:58:14] *** Quits: tchoma (tchoma@moz-BBE3ABD.mv.mozilla.com) (Ping timeout)
[17:58:24] *** Joins: mib_0r7huf (Mibbit@moz-30F458FF.cust.bredbandsbolaget.se)
[17:58:31] <tjc> graydon: in case it slipped through the cracks, I respectfully request another r+ on https://github.com/mozilla/rust/pull/8032 (just for some docs I added)
[17:59:37] <graydon> r+
[17:59:41] <tjc> thx
[17:59:57] <graydon> tjc: we keep getting rustpkg test hangs on mac; have you time to look into those?
[18:00:13] <tjc> graydon: sure, I thought I fixed that, though
[18:01:33] *** Joins: ghrust (ghrust@614D05BD.6A2AE50.F3114085.IP)
[18:01:33] <ghrust> 01[13rust01] 15bors merged 06auto into 06master: 02http://git.io/qjCKmw
[18:01:33] *** Parts: ghrust (ghrust@614D05BD.6A2AE50.F3114085.IP) ()
[18:02:12] *** Joins: tchoma (tchoma@moz-BBE3ABD.mv.mozilla.com)
[18:02:30] <rustyPipe> I'm sorry if this question has been asked before, but when reading from standard input, why can you only use stdin by prefixing it with std:: and io:: (std::io::stdin())?
[18:02:52] <kimundi> rustyPipe: Their just not imported in the prelude
[18:02:55] *** Quits: robertknight (robertknig@moz-54528EE0.wby.mendeley.com) (Quit: Computer has gone to sleep.)
[18:03:15] <graydon> tjc: https://github.com/mozilla/rust/issues/7956 https://github.com/mozilla/rust/issues/8102
[18:03:30] <kimundi> rustyPipe: a 'use std::io::stdin;' will fix that for your file
[18:03:47] <brson> graydon: I've been implored to set up some android automation, so at some point this week I'm going to start on that, and also configure the new mini
[18:04:12] <graydon> brson: ok
[18:04:12] <kimundi> Maybe we should add them to the prelude in general?
[18:04:21] <cmr> kimundi: no, it's old :\
[18:04:26] *** Joins: ghrust (ghrust@DE823A67.6A2AE50.F3114085.IP)
[18:04:27] <ghrust> 01[13rust01] 15bors pushed 0 new commits to 06auto: 02http://git.io/wO8yDw
[18:04:27] *** Parts: ghrust (ghrust@DE823A67.6A2AE50.F3114085.IP) ()
[18:04:28] *** Joins: ghrust (ghrust@614D05BD.6A2AE50.F3114085.IP)
[18:04:28] <ghrust> 01[13rust01] 15bors pushed 5 new commits to 06auto: 02http://git.io/DwtJhQ
[18:04:28] <ghrust> 13rust/06auto 14d7c4a10 15Tim Chevalier: rustpkg: Clean up usage messages for install
[18:04:28] <ghrust> 13rust/06auto 14bfac584 15Tim Chevalier: rustpkg: Handle non-numeric versions; some cleanup...
[18:04:29] <ghrust> 13rust/06auto 14c878051 15Tim Chevalier: rustpkg: Don't assume a non-numeric refspec is a tag...
[18:04:31] *** Parts: ghrust (ghrust@614D05BD.6A2AE50.F3114085.IP) ()
[18:04:31] <rustyPipe> Why do we have to import in stdin? I thought you can just import in the io module by itself and gain access to everything included within it.
[18:04:35] <graydon> brson: want help with that? I'm trying to look into windows failures (specifically the one blocking john's hygenic macros)
[18:05:04] <tjc> rustyPipe: you can do: use std::io::* if you like
[18:05:10] <tjc> or rather, use std::io::*;
[18:06:27] <brson> graydon: nah, I should be able to manage it, but I'll probably have to ask some questions about configuring ec2. figure we'll create a new linux ami for android
[18:06:35] <brson> right now i'm desperately trying to kill the old runtime
[18:06:35] <graydon> yes
[18:06:54] *** Joins: zslayton (Mibbit@81EB2473.5F4BC84E.66C78B76.IP)
[18:07:01] <rustyPipe> So in order to gain access to everything within a module, you can attach a * to the end of a use statement, right?
[18:07:03] <graydon> brson: understood. is it arm or android they want?
[18:07:11] <graydon> there are ubuntu-on-arm AMIs already
[18:07:15] <graydon> (emulated ARM)
[18:07:44] *** Quits: pyrac (pyrac@moz-C9A4FCEC.w90-55.abo.wanadoo.fr) (Quit: pyrac)
[18:07:48] *** Quits: km (quassel@FDBAF0A0.DBF71E41.29C67456.IP) (Ping timeout)
[18:07:54] <graydon> or are we just talking about keeping it building in an android-cross environment, no test execution?
[18:08:45] *** Joins: km (quassel@FDBAF0A0.DBF71E41.29C67456.IP)
[18:09:41] <rustyPipe> So the asterisk at the end of a use statement import everything within a module?
[18:09:54] <tjc> rustyPipe: yes
[18:10:00] *** Joins: thomaslee (thomaslee@moz-6C3931E3.static.twtelecom.net)
[18:10:23] <tjc> sometimes you can get unexpected behavior using * with your own modules -- because you can create cyclic imports, which the compiler doesn't handle too well -- but using it with library modules should be OK
[18:10:42] <rustyPipe> Ok
[18:11:33] <brson> graydon: android. yes, all we really need for now is to stop breaking the build
[18:11:47] <rustyPipe> Wait, why would there be a problem with cyclic imports?
[18:12:00] <cmr> rustyPipe: because the compiler isn't done yet :p
[18:12:27] <toddaaro> different people are around now, so I'll ask about this again: is there any documentation on how to write destructors and what the best practices are?
[18:12:31] <graydon> I think cyclic imports via globs actually wind up breaking the import algorithm. you can break them by making one of them explicit.
[18:12:46] *** Quits: jedestep (jedestep@34641662.FB4DE631.66C78B76.IP) (Ping timeout)
[18:12:50] <graydon> toddaaro: impl Drop for Foo { fn drop(&self) { ... } }
[18:12:54] <toddaaro> in particular, what do you have to do and what code is generated, and how do you avoid infinite loops
[18:13:08] <graydon> toddaaro: it'll run when instances of Foo are dropped
[18:13:23] <toddaaro> graydon: but what do you do in ... ?
[18:13:31] <graydon> toddaaro: what do you want to do in the dtor?
[18:13:32] *** Quits: mib_0r7huf (Mibbit@moz-30F458FF.cust.bredbandsbolaget.se) (Quit: http://www.mibbit.com ajax IRC Client)
[18:13:34] *** Quits: jeff (jeff@moz-F81F6C4E.nyc.biz.rr.com) (Quit: jeff)
[18:13:58] <toddaaro> I have a deque end, I'd like to drop the refcount by one and if at zero free memory for it and the enclosed array
[18:14:20] <toddaaro> I spend a fair bit of time on this and couldn't figure out how to get anything other than infinite loop, double free, or leak
[18:14:42] *** Joins: kertap (kertap@moz-D50677C9.b-ras3.mvw.galway.eircom.net)
[18:14:46] <toddaaro> I'm sure it is something obvious I'm missing, so I'd like to read words telling me these things
[18:14:48] <graydon> is the refcount somehow increased every time you make a copy of your Foo object?
[18:14:58] *** Quits: tikue (tkuehn@moz-BBE3ABD.mv.mozilla.com) (Quit: tikue)
[18:15:02] <toddaaro> that is the plan, the clone operation increases it
[18:15:04] <graydon> (IOW do you have an explicit clone method that bumps the refcount?)
[18:15:10] <graydon> ok. what's the form of the infinite loop then?
[18:15:14] *** Quits: quasisphere (btw@DC685DC2.94302614.1D0D91FF.IP) (Ping timeout)
[18:15:21] <toddaaro> I never tried calling clone though, couldn't get single-destruction to work
[18:15:33] <graydon> iloops are not a general feature of dtors
[18:15:41] <toddaaro> I have a "let mut this = transmute(self)" so I can mutate it internally
[18:15:52] <toddaaro> and I think it calls the dtor on this in every case, so it loops
[18:15:55] <graydon> oh. don't do that.
[18:16:05] *** Joins: jedestep (jedestep@34641662.FB4DE631.66C78B76.IP)
[18:16:23] <graydon> well, wait, it depends what you're doing. paste the code.
[18:16:24] <cmr> I also have a problem with destructors
[18:16:24] <toddaaro> should I just be transmuting an pointer to the inside?
[18:16:26] <cmr> https://github.com/cmr/rustdoc_ng/blob/master/plugins.rs#L37
[18:16:29] <graydon> debugging by guesswork is not helpful
[18:16:36] <tjc> graydon: oh, I think I know what the problem with the rustpkg tests -- I fixed it in a branch that I haven't checked in yet
[18:16:40] <cmr> It calls the destructor either on that line or after the previous one
[18:16:41] <tjc> I thought I'd checked it in already, but I didn't
[18:16:50] <toddaaro> graydon: I'll curate a paste with a few attemps
[18:16:51] <cmr> And then I try to use it, but the destructor calls dlclose
[18:16:54] <cmr> So I get a segfault
[18:17:08] *** Joins: tikue (tkuehn@moz-BBE3ABD.mv.mozilla.com)
[18:17:21] <graydon> cmr: the dtor for what, lib?
[18:17:44] <cmr> graydon: the DynamicLibrary object yeah
[18:18:51] <graydon> cmr: huh. not sure.
[18:18:58] <graydon> cmr: you might want to ask nmatsakis
[18:19:03] <cmr> nmatsakis: ping
[18:19:41] *** Joins: quasisphere (btw@DC685DC2.94302614.1D0D91FF.IP)
[18:20:42] *** Joins: Sergio965 (sergiobz@moz-BB21156B.dynamic.csail.mit.edu)
[18:21:48] <toddaaro> graydon: rustc is working hard, can paste when it finishes
[18:21:54] *** Joins: infynyxx (infynyxx@DB780A29.749BA1D.DCC373F0.IP)
[18:21:56] <graydon> sure
[18:21:59] <kmc> what's extern "Rust"?
[18:22:14] *** Quits: infynyxx_ (infynyxx@DB780A29.749BA1D.DCC373F0.IP) (Ping timeout)
[18:24:16] <Eridius> kmc: "Rust" is the ABI here, in this case it's the default ABI for functions written in rust
[18:24:42] <Eridius> kmc: so I guess you'd use this if you were linking a library that had exported functions written in rust
[18:25:37] <Eridius> rusti: fn foo() -> ~str { ~"yes" } fn bar(f: extern "Rust" fn() -> ~str) { println(f()) } bar(foo)
[18:25:37] <engla_> kmc: extern "Rust" fn(A,..) -> R  is the type of a regular function
[18:25:38] -rusti- yes
[18:25:38] -rusti- ()
[18:25:40] <Eridius> that also works
[18:25:52] *** Quits: robn (robn@moz-76B0302C.static.internode.on.net) (Ping timeout)
[18:25:52] <graydon> (one with no environment capture)
[18:26:40] *** Joins: robn (robn@moz-76B0302C.static.internode.on.net)
[18:26:45] <engla_> rusti: fn f()  f.nosuch
[18:26:46] -rusti- <anon>:5:17: 5:18 error: expected `{` but found `f`
[18:26:46] -rusti- <anon>:5          fn f()  f.nosuch
[18:26:46] -rusti-                           ^
[18:26:46] -rusti- application terminated with error code 101
[18:26:52] <engla_> rusti: fn f() {} f.nosuch
[18:26:52] -rusti- <anon>:5:19: 5:27 error: attempted access of field `nosuch` on type `extern "Rust" fn()`, but no field with that name was found
[18:26:53] -rusti- <anon>:5          fn f() {} f.nosuch
[18:26:53] -rusti-                             ^~~~~~~~
[18:26:53] -rusti- error: aborting due to previous error
[18:26:53] -rusti- application terminated with error code 101
[18:26:53] *** concrete.mozilla.org sets mode: +M 
[18:28:21] *** Joins: jeff (jeff@moz-F81F6C4E.nyc.biz.rr.com)
[18:28:39] *** Quits: maikklein2 (maik@moz-42794001.dip0.t-ipconnect.de) (Quit: Leaving)
[18:28:57] *** brson sets mode: -M 
[18:31:05] <toddaaro> brson bblum : ok, I fixed that race that came up in the merge
[18:31:17] <toddaaro> brson bblum : I'll do some cleaning and put up the final PR
[18:31:36] <brson> toddaaro: thanks
[18:31:48] *** Quits: int3_ (int3_@moz-ABE52D50.hsd1.ca.comcast.net) (Client exited)
[18:32:30] <toddaaro> brson bblum : it ended up being the race that brson suspected would exist where a task bounces between the queue and running, whatever bblum did made it actually happen so I just gave schedulers that are "special" "friend scheduler" handles so they can forward tasks, as per the original suggestion
[18:33:29] *** Quits: mihneadb (mihneadb@moz-BE33DA21.fw1.sfo1.mozilla.net) (Ping timeout)
[18:33:31] <graydon> how do I turn debug! on again?
[18:33:35] *** Joins: mihneadb (mihneadb@moz-BE33DA21.fw1.sfo1.mozilla.net)
[18:33:36] <graydon> (via the makefiles)
[18:35:09] <brson> toddaaro: interesting! I may be hitting a similar bug just now trying to implement spawn_sched(SingleThreaded)
[18:36:49] *** Quits: Yurume (yurume@AC58A8CE.8A059B47.E313B915.IP) (Ping timeout)
[18:36:58] *** Quits: jeff (jeff@moz-F81F6C4E.nyc.biz.rr.com) (Quit: jeff)
[18:38:11] *** Joins: doomrobo (doomrobo@424CFC39.4C7E3E47.E4D621DB.IP)
[18:38:12] <tjc> graydon: ./configure --enable-debug
[18:41:28] *** ozten is now known as ozten|afk
[18:42:06] <toddaaro> graydon: pastebin.mozilla.org/2738923 is my code
[18:42:41] <toddaaro> graydon: I have two attemps at the dtor in there, there have been a variety of others, but I no longer have them
[18:44:17] *** sam113101 is now known as sam113101_afk
[18:44:51] *** sam113101_afk is now known as sam113101
[18:45:02] *** Quits: infynyxx (infynyxx@DB780A29.749BA1D.DCC373F0.IP) (Client exited)
[18:45:09] <graydon> toddaaro: off hand I can't tell what's going on. but a few things stand out.
[18:45:17] <graydon> first, & is non-owning, so forget()'ing it does nothing
[18:45:41] <toddaaro> forget is on the transmuted ~ though
[18:45:42] <graydon> second, the compiler will drop ~ values on its own, after your dtor finishes.
[18:46:29] *** Quits: webber46 (webber46@moz-98D2F3C5.cust.bredband2.com) (Quit: webber46)
[18:46:30] <graydon> third, self is being passed by & there, and transmuting a &-ptr to a ~-ptr probably just means you're scribbling over memory
[18:46:37] <graydon> they have completely different structure
[18:46:43] <toddaaro> oh really?
[18:46:49] <toddaaro> I assumed they were the same thing
[18:47:15] <Ms2ger> Sounds like a weird thing to do in the first place :)
[18:47:42] <graydon> &T is a pointer-to-T. ~T is a malloc of something T-shaped
[18:47:53] <graydon> specifically a malloc of it. it has padding around it and comes from the malloc heap and such.
[18:48:12] <graydon> and in any case, you're being passed self by & but not being passed ownership
[18:48:20] <graydon> the compiler thinks it still has a box to free
[18:48:58] <graydon> and the fact that the WorkStealingQueue has a ~[] inside it means the compiler will also try to take that inner ~[] box apart
[18:49:02] <graydon> top down, running dtors
[18:49:26] <graydon> ownership is not presently passed to dtors on destruction. at all.
[18:49:54] <graydon> we hope to do that someday, but it's not now. ownership remains with the owner pre-drop, and the compiler sequences the destruction outside-in
[18:50:05] <graydon> it just gives the dtors a chance to look at the dropping-thing as it's being destroyed
[18:50:34] <graydon> does that help?
[18:50:52] *** Joins: webber46 (webber46@moz-98D2F3C5.cust.bredband2.com)
[18:50:59] *** Joins: Jesse (jruderman@moz-BBE3ABD.mv.mozilla.com)
[18:51:18] <doomlord> i'm trying to write some code-navigation tools (jump to definitoin etc.. ) - some seems to work,
[18:51:33] <toddaaro> graydon: yea, that helps
[18:51:51] <toddaaro> graydon: when you say "~T is a malloc of something T-shaped", it is a pointer to this malloc-created memory
[18:51:57] <graydon> yes
[18:52:00] <toddaaro> while &T could be a stackpointer or something
[18:52:06] <graydon> or the inside of another value
[18:52:11] <toddaaro> ok
[18:52:18] <doomlord> does anyone know how i'd go about getting source references (filename/position) for node definitons outside of the recently compiled crate 
[18:52:40] *** Joins: jensnockert (jensnocker@moz-C5F27039.cust.bredband2.com)
[18:52:43] <doomlord> Will i have to write an indexer, or is the information there already
[18:53:01] <Luqman> doomlord: rustc::csearch::maybe_get_item_ast
[18:53:28] *** Joins: lucian (lucian@moz-22A14C6A.cable.virginmedia.com)
[18:53:28] <doomlord> heh. there's another question , "have you already written all of this.."
[18:53:36] <doomrobo> does anyone have the link to the Rust ARC example? dbaupp gave it the other day
[18:53:38] <toddaaro> graydon: so a more correct structure here is to only do a transmute_mut on the internal refcount? And then once I'm doing that, how do I "abort" the destructing if it isn't the final reference?
[18:53:54] <doomrobo> not tutorial-tasks
[18:54:41] *** Quits: busylizzy (lisa@85228838.12D0DC84.211374C4.IP) (Ping timeout)
[18:54:50] *** Joins: busylizzy (lisa@85228838.12D0DC84.211374C4.IP)
[18:55:08] *** Quits: lucian (lucian@moz-22A14C6A.cable.virginmedia.com) (Ping timeout)
[18:55:51] <Luqman> doomlord: you could check out rustc::middle::const_eval for an example
[18:56:58] <bblum> toddaaro: excellent, good work
[18:57:14] <doener> what is LP in mangled names?
[18:57:24] <sp3d> left-paren?
[18:57:34] <doomlord> "csearch" .. 'code-search' ?
[18:57:43] <doener> hm, would match the RP that's also there
[18:58:07] *** ozten|afk is now known as ozten
[18:58:16] *** Quits: BizarreCake (BizarreCak@moz-361FE9B2.dynamic.barak-online.net) (Ping timeout)
[18:58:18] <Ms2ger> Left-pinky?
[18:58:47] <kmc> doener: here's the mangling algorithm: https://github.com/mozilla/rust/blob/master/src/librustc/back/link.rs#L663
[18:59:38] <kmc> it's a bit confusing because @~*& are translated after their meaning while <>(), are named after the symbol itself
[18:59:41] <kmc> reminds me of LaTeX :)
[18:59:45] <doomlord> catch 22, comprehending code without navigation tools is much harder, but i'm trying to fix that :)  thanks for the pointer where to look
[19:00:27] *** Joins: jeff (jeff@moz-F81F6C4E.nyc.biz.rr.com)
[19:01:08] <doener> kmc: yeah, I just couldn't figure out why () would show up there, but it's just tuple glue I'm seeing
[19:02:19] *** Joins: true_droid (Adium@moz-123FD9B8.beck.volia.net)
[19:02:35] <kimundi> r? https://github.com/mozilla/rust/pull/8082
[19:02:50] <doener> single element tuple glue looks a bit weird. Guess it could be simplified to be equal to the glue of the contained element?
[19:03:06] *** Quits: jeff (jeff@moz-F81F6C4E.nyc.biz.rr.com) (Quit: jeff)
[19:04:19] <bblum> brson: do you want an r+ for https://github.com/mozilla/rust/pull/8110 ?
[19:04:24] *** Quits: huhlig-work (huhlig@moz-62A47D90.aoltw.net) (Connection reset by peer)
[19:04:41] <bblum> brson: i have no clue what it's actually doing but i have a high interest in being able to run check-stage1-std
[19:04:51] <Eridius> kimundi: is there no desire to make CharOffsetIterator provide the length of the character too, not just the byte offset?
[19:05:20] <brson> bblum: yes, thanks
[19:05:34] *** Joins: jmgrosen (jmgrosen@moz-848F6087.sb.sd.cox.net)
[19:05:52] <kimundi> Eridius: Hu. Interesting idea, but based on the unicode codepoint you can already calculate the utf8 len anyway
[19:06:12] <Eridius> kimundi: well, kinda. It's technically possible to have a utf-8 sequence that's too many bytes that still maps to the same codepoint
[19:06:24] <kmc> Seldaek: ooh I like the styling on the new rustdoc :)
[19:06:26] <Eridius> this is typically considered an error, but not all utf-8 consumers detect it
[19:06:34] <kimundi> Eridius: Tat would be an invalid str though
[19:06:34] *** Quits: eatkinson (eatkinson@moz-BBE3ABD.mv.mozilla.com) (Quit: eatkinson)
[19:06:39] <Eridius> last I checked I don't think Rust's str detects that case, although I've been meaning to check up on that
[19:06:44] <engla_> Eridius: we have an issue for that, it should be invalid
[19:06:50] <engla_> but isn't yet
[19:06:52] *** Joins: vodik (simon@moz-CBE4BB13.cable.teksavvy.com)
[19:07:07] <engla_> Eridius: https://github.com/mozilla/rust/issues/3787
[19:07:22] <Eridius> engla_: yeah
[19:08:06] <Eridius> kimundi: IIRC strcat wanted to add a Range type to std, which would be a sensible thing to use in an iterator like this
[19:08:17] <brson> the new runtime will have two scheduler spawn modes: Default and SingleThreaded, down from 7, which I think is a good development. I do think we'll need to add one new mode later that basically allocates a new scheduler for the duration of a task that the user knows is going to block. servo, e.g. will use this every time it creates a JS task, which will allow it to migrate blocking tasks while still ensuring that the runtime as a whole doesn't dead
[19:08:25] <Eridius> I don't know if he ever did anythinga bout it though
[19:08:28] <kimundi> Eridius: Isn't a Range a DoublEndedIterator?
[19:08:31] <brson> this mode may be sufficient to replace the current behavior of SingleThreaded though
[19:08:39] <doomrobo> How would I use a static mut ARC to wrap a HashMap?
[19:08:44] <Eridius> kimundi: did it turn into that? I haven't paid much attention for the past few weeks
[19:08:49] *** Joins: infynyxx (infynyxx@DB780A29.749BA1D.DCC373F0.IP)
[19:09:05] <kimundi> Eridius: advanceable from both ends, logically repersents a range of values.
[19:09:12] <Seldaek> kmc: glad to hear :)
[19:09:12] <Eridius> ah
[19:09:32] *** Quits: Florob (florob@moz-39532932.de) (Quit: leaving)
[19:09:56] <kimundi> Eridius: Part of this PR was to actually implemnet DoubleEnedIterator for strings :) Before it where just normal ones
[19:10:10] *** Joins: Florob (Florob@moz-39532932.de)
[19:10:10] *** Quits: brson (brson@E9CDE21E.991753BB.CA4D1600.IP) (Ping timeout)
[19:10:19] <engla_> it's awesome
[19:10:25] <Eridius> kimundi: anyway, I'm just slightly leery about the idea that users should have to try and calculate the length of the bytes when you already had it and just didn't hand it to them. But maybe it doesn't matter
[19:10:28] *** Quits: infynyxx (infynyxx@DB780A29.749BA1D.DCC373F0.IP) (Client exited)
[19:10:35] <engla_> kimundi: I'm working on Random access iter for MapIterator, so that part will go in later
[19:10:46] *** Quits: Jesin (Jessin_@moz-3AD6F09F.res.lehigh.edu) (Ping timeout)
[19:10:53] <engla_> (for the str.byte_iter())
[19:12:17] *** Quits: jensnockert (jensnocker@moz-C5F27039.cust.bredband2.com) (Input/output error)
[19:12:25] *** Joins: brson (brson@moz-BBE3ABD.mv.mozilla.com)
[19:12:26] *** ChanServ sets mode: +o brson
[19:12:51] <rhodesd> is there a rust CRC-32 implementation?
[19:13:02] *** Quits: mihneadb (mihneadb@moz-BE33DA21.fw1.sfo1.mozilla.net) (Input/output error)
[19:13:10] *** Joins: jeff (jeff@moz-F81F6C4E.nyc.biz.rr.com)
[19:13:29] <Seldaek> rhodesd: there's a thread in the ml about it, someone's on it I think
[19:13:30] *** Joins: pyrac (pyrac@moz-C9A4FCEC.w90-55.abo.wanadoo.fr)
[19:13:43] <rhodesd> ok, thank Seldaek I'll take a look
[19:13:47] *** Joins: infynyxx (infynyxx@DB780A29.749BA1D.DCC373F0.IP)
[19:13:50] <rhodesd> \^thanks
[19:14:06] <Luqman> doomlord: maybe something like this https://gist.github.com/luqmana/6106904
[19:14:16] <kimundi> Eridius: No, I get what you mean, but minus bugs both are identical, and adding an additional uint just makes me wanna refactor the whole thing once again xD
[19:14:36] <Eridius> kimundi: yeah, complicating the API may not be worth it
[19:16:39] <doomlord> ok that helps alot , thanks. I was as far as the first part, i can nodeId from source:pos, and span from nodeId
[19:17:19] <bblum> brson: by the way, do you know what is wrong with making check-stage0-std? we used to be able to do it last summer
[19:18:01] <doomlord> Is an  "inlined_item" === "imported crate", or rather 'inlined source' within the compilation of one crate (even that is a step forward)
[19:18:20] <brson> bblum: looking
[19:19:08] *** Quits: doomrobo (doomrobo@424CFC39.4C7E3E47.E4D621DB.IP) (Quit: Leaving)
[19:20:37] <kimundi> Eridius: Hm, thinking about it, I think the most versatil would be upgrading the CharOffsetIterator to a CharContextIterator: instead of a o (uint, char), have a context: struct { chr, byte_offset, char_index, byte_len }
[19:22:13] <nmatsakis> cmr: pong
[19:22:42] *** Quits: ecr (Thunderbir@moz-F724119C.uoregon.edu) (Quit: ecr)
[19:23:12] *** Quits: lkuper (lkuper@5188CCE.A402E718.C082B7DC.IP) (Quit: lkuper)
[19:23:17] *** Joins: jgilbert (jgilbert@moz-BBE3ABD.mv.mozilla.com)
[19:23:44] *** Joins: FrozenCow (FrozenCow@moz-B2DF4929.chello.nl)
[19:23:57] *** Joins: dherman (dherman@moz-6CA476B1.hsd1.ca.comcast.net)
[19:23:57] *** ChanServ sets mode: +o dherman
[19:24:35] *** Quits: kertap (kertap@moz-D50677C9.b-ras3.mvw.galway.eircom.net) (Quit: kertap)
[19:24:43] <doener> to inspect @Foo's box I should transmute to &Box<Foo>, right?
[19:25:16] <brson> bblum: make check-stage0-std works here
[19:25:44] <brson> bblum: oh, probably because of that patch you just r+ed
[19:26:23] <doener> yeah, works
[19:26:44] <Sergio965> Is the asm! macro built in or is it part of the standard library?
[19:27:05] <bstrie> built in
[19:27:14] <bstrie> at least I'm pretty syre
[19:27:22] <bstrie> would be very impressed if it was just a lib :P
[19:27:27] *** Quits: brson (brson@moz-BBE3ABD.mv.mozilla.com) (Ping timeout)
[19:28:06] <nmatsakis> can anyone point me at any examples of declaring item macros?
[19:28:13] <nmatsakis> can we export item mcaros cross-crate yet?
[19:28:49] *** Quits: nano (nano@moz-972880B.superkabel.de) (Connection reset by peer)
[19:28:55] *** Quits: jeff (jeff@moz-F81F6C4E.nyc.biz.rr.com) (Quit: jeff)
[19:28:58] *** Quits: zslayton (Mibbit@81EB2473.5F4BC84E.66C78B76.IP) (Quit: http://www.mibbit.com ajax IRC Client)
[19:30:12] <Uther> This piece of code seem to crash rustc on my mac https://gist.github.com/UtherII/6860b53b4e3dfd748035
[19:30:42] <Uther> can anyone reproduce it?
[19:30:52] <doomlord> (hmm, even if i dont get jump to def working, I suppose the AST has enough to pretty print useful info eg parameters, struct members.. )
[19:31:45] *** Quits: carllerche (carllerche@6B070D22.7E6A0813.1428D117.IP) (Quit: carllerche)
[19:32:19] *** Joins: kertap (kertap@moz-D50677C9.b-ras3.mvw.galway.eircom.net)
[19:33:05] *** Joins: brson (brson@moz-BBE3ABD.mv.mozilla.com)
[19:33:05] *** ChanServ sets mode: +o brson
[19:34:00] <brson> bblum: make check-stage0-std works for me on master too
[19:34:12] <Eridius> Uther: yep, SIGABRT here
[19:34:13] <brson> graydon: is there a way to run the test suite without the benchmarks?
[19:34:25] <graydon> heh
[19:34:30] *** Joins: eatkinson (eatkinson@moz-BBE3ABD.mv.mozilla.com)
[19:34:30] <Seldaek> graydon: thanks for the rustdoc feedback, but indeed those are all mostly known issues, as for the colors I agree but I'd like to give it a shot, I think in time it can be pretty neat to know what is what instantly, it just needs to reach the subconscious 
[19:34:35] <graydon> brson: apparently a popular request after all
[19:34:57] <graydon> I don't remember who was asking about it the other day; I didn't add in a make var but I suggested one could be added easily if it mattered that much
[19:35:08] <graydon> look in tests.mk, the thing that disables them when on valgrind
[19:35:18] <graydon> you can add a NO_BENCH var if you like
[19:35:29] <graydon> (I guess they are not fast enough?)
[19:36:29] <brson> ok, I'll probably add one at some point. yeah, too slow for tdd
[19:36:54] <doener> hrm, the refcounts on "crate" in phase_2_... seems too high
[19:37:14] <doener> s/seems/seem/
[19:37:21] *** Joins: alisdair (textual@1697D94C.7742FB18.FBC8476D.IP)
[19:38:05] <doener> I'd expect them to be 1, but they're at 2
[19:39:45] <olsonjeffery> brson: so are one-shot ports and chans both sendable in newsched?
[19:40:24] <brson> olsonjeffery: yes
[19:42:09] *** Joins: int3_ (int3_@moz-ABE52D50.hsd1.ca.comcast.net)
[19:43:55] *** Quits: int3_ (int3_@moz-ABE52D50.hsd1.ca.comcast.net) (Ping timeout)
[19:44:00] <kmc> I need to write a tree iterator where the callback can decide to skip any subtree, without aborting the whole tree iteration; is this a good fit for the 'for' sugar or an abuse of same?
[19:44:37] <kmc> (from my understanding it's the latter; very confusing to continue iterating after a 'break')
[19:44:37] *** Joins: mihneadb (mihneadb@moz-BE33DA21.fw1.sfo1.mozilla.net)
[19:44:52] <Eridius> kmc: if you want to fit that into `for` sugar, only reasonable approach I can think of is to provide a &mut bool param that you modify to say "skip"
[19:45:04] <Eridius> kmc: if you wanted to use `break`, that's not even going to work when we switch to the new `for` sugar
[19:45:05] *** Quits: mihneadb (mihneadb@moz-BE33DA21.fw1.sfo1.mozilla.net) (Input/output error)
[19:45:21] <kmc> how does the new for sugar work, by the way? do you have a link?
[19:45:52] *** Quits: jorendorff (jorendorff@moz-2F32ACA3.hsd1.tn.comcast.net) (Quit: jorendorff)
[19:46:08] *** Quits: KindOne (KindOne@moz-9A5BAA92.dynamic.ip.windstream.net) (Ping timeout)
[19:46:13] *** Joins: mihneadb (mihneadb@moz-BE33DA21.fw1.sfo1.mozilla.net)
[19:46:13] <Eridius> kmc: no link, but it's going to just spin the iterator for you (by calling .next repeatedly) and stopping when it gets a None.
[19:46:16] <kimundi> kmc: It will just call .next() on an Iterator until it returns None
[19:46:20] <kmc> ok
[19:46:33] <Eridius> which is nice because things like `return` will be able to work without magic
[19:46:44] <Eridius> and borrowck can rely on `return` and `break` actually working
[19:46:44] <kmc> so I guess I will ignore 'for' here and just write a HOF intended for use with 'do'
[19:46:53] <Eridius> HOF?
[19:46:56] <kmc> higher-order function
[19:47:00] <engla_> kmc: you can implement an iterator with custom methods for skipping
[19:47:31] *** Joins: strcat (strcat@moz-54F7FD49.cpe.net.cable.rogers.com)
[19:47:52] <engla_> with the new for loop it should even be possible to modify the iterator during iteration, without problem
[19:48:01] <Eridius> ok yeah, you can do that, which will require having a handle on the iterator within the loop, or you can return a closure from the iterator that does that, or you can return a &mut bool from the iterator that modifies state on it to mean "skip the next subtree"
[19:48:21] <olsonjeffery> brson: so im imaginging a single, non-copyable, but sendable Promise<T>.. and the ability to create copyable/sendable Future<T> objects that're tied back to it.. what sort of internal data structure does that imply? some kind of arc?
[19:48:40] <olsonjeffery> im putting together an API pitch for the async stuff and, in my mind, it starts with futures/promises.. so just trying to understand implications before proceeding
[19:49:07] <bstrie> olsonjeffery: would this replace our current futures library?
[19:49:17] <brson> olsonjeffery: I think it is a oneshot closure plus some additional logic
[19:49:22] <brson> *pipe
[19:49:24] <olsonjeffery> bstrie: it's implied that extra::future will move into std::rt::io
[19:49:37] *** Joins: ghrust (ghrust@79968228.6A2AE50.F3114085.IP)
[19:49:38] <ghrust> 01[13rust01] 15bors merged 06auto into 06master: 02http://git.io/DwtJhQ
[19:49:38] *** Parts: ghrust (ghrust@79968228.6A2AE50.F3114085.IP) ()
[19:49:42] <bstrie> and std::rt::io will just become std::io one day?
[19:49:57] <bstrie> also that seems like a strange place for futures to live
[19:49:59] *** Joins: KindOne (KindOne@F65A5124.5D2364C3.EC6A1518.IP)
[19:50:00] <brson> std::rt::io will become std::io
[19:50:03] <olsonjeffery> bstrie: they integrate with the scheduler
[19:50:05] <brson> agree futures shouldn't live in io
[19:50:09] <engla_> kmc: I think it's going to be just like this macro https://gist.github.com/anonymous/9f0ee5dc5c9aa6121a9e
[19:50:11] <olsonjeffery> fair enough
[19:50:15] <bstrie> just for the sake of discoverability
[19:50:17] <brson> std::future
[19:50:23] <bblum> brson: oh really, well, maybe we can bump the priority too :P
[19:50:51] <brson> bblum: of moving rt::io to std::io?
[19:50:53] *** Joins: sebcrozet (sebcrozet@moz-6DA639AF.w80-13.abo.wanadoo.fr)
[19:51:02] <bblum> brson: no, of fixing the make-check-stage0
[19:51:08] *** Quits: rustyPipe (Mibbit@moz-5949C51B.dllstx.fios.verizon.net) (Quit: http://www.mibbit.com ajax IRC Client)
[19:51:29] *** Quits: sankha93 (Instantbir@7061CD01.D6BD0D91.22D41759.IP) (Quit: Gone to save the world!)
[19:51:33] <brson> bblum: afaict make check-stage0-std works
[19:51:41] <brson> doesn't require that patch
[19:51:44] <bblum> brson: for me it says can't find crate for extra
[19:51:48] <bblum> or at least, i haven't pulled yet today
[19:51:53] <bblum> so, one sec
[19:52:05] <brson> so much of std::task is unused. silly
[19:52:26] *** Joins: ghrust (ghrust@79968228.6A2AE50.F3114085.IP)
[19:52:26] <ghrust> 01[13rust01] 15bors pushed 0 new commits to 06auto: 02http://git.io/N7WfcQ
[19:52:26] *** Parts: ghrust (ghrust@79968228.6A2AE50.F3114085.IP) ()
[19:52:26] *** Joins: naq (naq@D5C2D2DF.E4265FCD.E481B5B.IP)
[19:52:26] *** Joins: ghrust (ghrust@AC22872E.6A2AE50.F3114085.IP)
[19:52:26] <ghrust> 01[13rust01] 15bors pushed 2 new commits to 06auto: 02http://git.io/8nP7Ag
[19:52:26] <ghrust> 13rust/06auto 148a32977 15Michael Woerister: New naming convention for ast::{node_id, local_crate, crate_node_id, blk_check_mode, ty_field, ty_method}
[19:52:26] <ghrust> 13rust/06auto 14cd288e5 15bors: auto merge of #8107 : michaelwoerister/rust/end_of_spanned, r=cmr...
[19:52:27] *** Parts: ghrust (ghrust@AC22872E.6A2AE50.F3114085.IP) ()
[19:52:47] *** Quits: sebcrozet (sebcrozet@moz-6DA639AF.w80-13.abo.wanadoo.fr) (Client exited)
[19:53:14] <brson> it's filled with ideas we had, wrote api's for, then never did anything with
[19:53:30] *** Joins: simon (simon@moz-CBE4BB13.cable.teksavvy.com)
[19:53:32] *** Quits: vodik (simon@moz-CBE4BB13.cable.teksavvy.com) (Quit: WeeChat 0.4.2-dev)
[19:53:32] <bblum> such as?
[19:54:37] <brson> bblum: CurrentScheduler, ExistingScheduler, ThreadPerTask, ManualThreads, Task, get_task
[19:54:47] *** Quits: kertap (kertap@moz-D50677C9.b-ras3.mvw.galway.eircom.net) (Quit: kertap)
[19:54:49] <bblum> oh yeah, all those
[19:54:52] <olsonjeffery> ah, i love all of those!
[19:54:54] <brson> i see this as a good indication that the previous scheduler model was wrong
[19:55:02] <bblum> the other day i was wondering if we could remove get_task
[19:55:26] <brson> i'm deleting it all in the transition to the new scheduler
[19:55:34] <olsonjeffery> brson: are things just settling on all schedulers being single-threaded, then?
[19:55:49] *** Joins: steven_is_false (user@C5B76363.1FF1EBF8.1ECA502.IP)
[19:56:04] <bblum> brson: there's no model for ThreadPerTask in the new scheduler?
[19:56:06] *** Joins: carllerche (carllerche@moz-BF6CB667.hsd1.ca.comcast.net)
[19:56:37] <olsonjeffery> heh. i didn't realize that all of that was part of oldsched
[19:56:42] <olsonjeffery> (the scheduler modes)
[19:57:06] <steven_is_false> Hi. I think I'm running into a known bug with sharing std::comm::SharedChan values where sometimes a clone of the SharedChan value will refuse to work. Does anyone remember the specific issue so I can monitor it for progress, and get more information about the problem?
[19:57:26] *** Joins: jorendorff (jorendorff@moz-2F32ACA3.hsd1.tn.comcast.net)
[19:57:28] <steven_is_false> * Sometimes the cloned SharedChan value will not be able to send.
[19:57:40] <brson> olsonjeffery: yes, in the new model a Scheduler is just a thread, and a runtime instance is a federation of schedulers that work together. there's no way to segregate a set of threads to run a specific set of tasks like in the old system, but there is still a way to assign a single task to a single thread, since that's a use case we actually have
[19:57:44] <bblum> steven_is_false: i am not aware of such a problem; can you pastebin code
[19:57:57] <bblum> a federation of schedulers :P
[19:58:10] <bblum> is that the group noun for scheduler now
[19:58:16] <olsonjeffery> sometimes you have to go to production with the use cases you have, not the use cases you want :)
[19:58:18] <brson> bblum: no, and there wasn't in oldsched either. in the new scheduler we have the idea that Tasks can be subclassed as a type that isn't a green thread and doesn't use the green thread scheduler, but it isn't implemented
[19:58:31] <bblum> nod
[19:58:44] <olsonjeffery> a confederacy of schedulers
[19:58:45] <steven_is_false> bblum: I have quite a large codebase, and have not reduced it to a small testcase yet. I can push a branch to my repository, and I'll send you a link.
[19:58:55] <bblum> steven_is_false: prefer if you could minimize
[19:59:41] <steven_is_false> bblum: Fair enough. I'll try to work on a small example.
[20:00:09] <bblum> steven_is_false: or, could you describe in what way it 'refuses to send'?
[20:01:17] <olsonjeffery> brson: heh. i suppose that should be self-evident, given the underlying libuv impl.
[20:02:13] <bblum> brson: oh, brilliant, check-stage0-std does work
[20:02:24] <bblum> o frabjous day
[20:02:55] <jedestep> callooh, callay
[20:03:00] <steven_is_false> bblum: I have a callback (which I know runs), and a receiver which does not receive the sent message like in http://pastebin.mozilla.org/2739359
[20:03:17] <olsonjeffery> brson: so, i guess getting back to what i was talking about earlier w/ future: if we were willing to suppose a ClonableFuture<T: Copy> or somesuch.. how would we support receipt of the value via a oneshot port?
[20:03:44] <bblum> steven_is_false: by 'does not receive' do you mean it blocks forever on recv?
[20:03:45] <steven_is_false> bblum: Also to get render_loop_inbox_writer I do: let render_loop_inbox_writer = inbox_writer.clone();
[20:04:20] <olsonjeffery> probably a lot of values in a future would be sendable/unique and not copyable.. but what about ones that are? could we synchronize in that case where it's basically a "fan-out", pub/sub sort of messaging relationship?
[20:04:47] <steven_is_false> bblum: It receives other messages like my simulator messages, and my window messages but it does not receive my render loop messages (I have an enum: enum Message { WindowMessage(WindowOutput), SimulatorMessage(SimulatorOutput), RenderLoopMessage(RenderLoopOutput) })
[20:04:47] <steven_is_false>  
[20:05:00] <olsonjeffery> or is it T: Clone? apologies if i misspoke.
[20:05:13] *** Joins: rlbaker (rlbaker@moz-C8EE266C.hfc.comcastbusiness.net)
[20:05:26] <bblum> steven_is_false: is it continuously receiving other messages?
[20:05:36] <steven_is_false> bblum: Yes.
[20:05:43] <bblum> olsonjeffery: that sounds like a clone issue
[20:05:48] <steven_is_false> Let me double check though.
[20:06:09] <bblum> sounds like the one sender is getting starved
[20:06:20] <bblum> does it print 'Sent!'?
[20:06:40] <steven_is_false> bblum: Yep.
[20:07:27] *** Joins: james4k (james@moz-E7990244.consolidated.net)
[20:08:18] <steven_is_false> bblum: So, it receives the messages only until the simulator message is sent.
[20:09:09] *** Joins: jeff (jeff@moz-F81F6C4E.nyc.biz.rr.com)
[20:10:34] <brson> olsonjeffery: I guess there are a few options. Off hand, if I were to do something like that I would make the ClonableFuture function that retrieves a value 'unwrap' it, destroying the future, then implement it like rt::comm::SharedChan, where the first caller gets to wait, and then forwards it to an atomic linked-list of other waiters. a RWArc based solution would be more efficient, but require moving a bunch of stuff into std
[20:11:08] * olsonjeffery nods.
[20:11:20] *** Joins: sebcrozet (sebcrozet@moz-6DA639AF.w80-13.abo.wanadoo.fr)
[20:11:23] <olsonjeffery> yeah, i saw that all of arc is in extra after i mentioned it
[20:12:01] <bblum> couldn't cloneable future just be in extra if it wanted to use rwarc?
[20:12:21] *** Joins: bheylin (brianheyli@moz-8255E94E.adsl.online.nl)
[20:13:40] <olsonjeffery> i guess its not a huge issue right now for async io
[20:13:51] <toddaaro> I'm going to push to snap-stage3 in a few minutes, any objections?
[20:13:53] <olsonjeffery> you can just distribute the value of the future until its forced
[20:14:02] <olsonjeffery> assumable the value is clonable
[20:14:06] <olsonjeffery> assuming, even
[20:14:30] <bblum> toddaaro: "I don't know."
[20:14:49] <brson> toddaaro: what's the eta on landing your refactoring? I need that fix you mentioned this morning
[20:15:22] <nmatsakis> can anyone point me at examples of item mcaros?
[20:15:23] <toddaaro> brson: I finally have it compiling on my development VM instead of testing, so ~30-45m to make the cleaning pass and then I can PR
[20:15:33] <nmatsakis> *macros
[20:15:40] <nmatsakis> and can they be exported across crates?
[20:15:49] * brson lunch
[20:15:53] <graydon> toddaaro: what's the snap?
[20:16:20] <olsonjeffery> brson: one last question.. do you have any preferences about where the async impls are done at? should rt::io::net::tcp have TcpStream that impls Reader,ReaderAsync, etc or should there be a new TcpStreamAsync struct that impls ReaderAsync ?
[20:16:28] <toddaaro> graydon: need to get the new memory fence intrinsic Aatch implemented over the weekend
[20:16:29] <steven_is_false> bblum: So I think this a problem with my code, and not a bug.
[20:16:46] <bblum> steven_is_false: oh, what were you doing?
[20:17:07] <graydon> toddaaro: you can't just #[cfg(not(stage0))] it?
[20:17:18] <steven_is_false> bblum: Still haven't figured it out.
[20:17:22] <steven_is_false> Just a hunch.
[20:17:24] <toddaaro> graydon: it already is, so I can't use it where I need it
[20:17:27] <graydon> ok
[20:17:49] <brson> olsonjeffery: i prefer to keep async io work seperate from sync io for now, maybe in rt::aio. rt::io is on the critical path and needs to be done yesterday, aio is much more experimental
[20:18:05] <olsonjeffery> gotcha.
[20:18:40] <strcat> rusti: 2
[20:18:41] -rusti- 2
[20:18:41] <brson> why are we using fences??
[20:18:48] <brson> scary
[20:18:53] <bblum> brson: for transliterating the deque code
[20:19:13] *** Quits: rlbaker (rlbaker@moz-C8EE266C.hfc.comcastbusiness.net) (Input/output error)
[20:19:22] <toddaaro> there is a PPOPP paper from this year with exact code, and they use the C11 relaxed memory model heavily
[20:19:30] <toddaaro> it does supposedly go way faster at least
[20:19:40] *** Quits: sebcrozet (sebcrozet@moz-6DA639AF.w80-13.abo.wanadoo.fr) (Client exited)
[20:19:40] <bblum> almost certainly it could be done with our existing acq/rel barriers but figuring out how to translate might be bug-prone
[20:19:47] <toddaaro> exactly
[20:19:52] <toddaaro> no need to think when we don't have to
[20:20:08] <bblum> well, we should do it in the future when we have better concurrency primitive verification ;) ;)
[20:20:14] <brson> can you link me the paper?
[20:20:43] <toddaaro> maybe, it is linked in the issue for trhe deque
[20:20:53] <toddaaro> I think this vm might be swapping so I'm not sure I can open firefox
[20:20:56] *** Quits: Sergio965 (sergiobz@moz-BB21156B.dynamic.csail.mit.edu) (Ping timeout)
[20:21:04] <jdm> does break inside match do anything?
[20:21:23] <bstrie> if you're inside a loop, it should
[20:22:23] <toddaaro> brson: http://www.di.ens.fr/%7Ezappa/readings/ppopp13.pdf
[20:22:27] <brson> thanks
[20:22:37] <graydon> guh this is infuriating
[20:22:43] <Ms2ger> How about when you just haven't realized you aren't writing a C++ switch?
[20:22:52] *** Joins: erickt (erickt@8C9ECD8F.3A598286.F12515B4.IP)
[20:22:53] *** Joins: jviereck (Adium@moz-A034D4DA.dclient.hispeed.ch)
[20:23:09] *** Joins: askalski (akuda@2BA4E5A7.CC7751E8.6712E96B.IP)
[20:23:14] <graydon> john's hygenic macro stuff crashes in windows. windows only. cloning an expression in expand. it doesn't crash in 32bit config on any other platform. it's not out of memory. there's no unsafe code.
[20:23:15] *** Quits: fzzzy (Donovan@moz-40919DA0.us-west-2.compute.amazonaws.com) (Quit: ZNC - http://znc.in)
[20:23:16] <graydon> grrr
[20:23:23] <sam113101> how do IÂ install the rust syntax for vim?
[20:23:27] *** Quits: Ms2ger (Ms2ger@E39D6ADF.6D359A20.187A1082.IP) (Quit: nn)
[20:23:28] <graydon> I have no valgrind here, only a rudimentary debugger
[20:23:32] <bblum> graydon: o_o;
[20:23:42] <strcat> graydon: does it crash in wine?
[20:23:49] <bstrie> sam113101: drag the files into the corresponding folders in ~/.vim
[20:23:59] <bblum> sam113101: cp rust/src/etc/vim/syntax/rust.vim ~/.vim/syntax/rust.vim
[20:23:59] <bstrie> make the folders if necessary
[20:24:01] *** Quits: brson (brson@moz-BBE3ABD.mv.mozilla.com) (Quit: leaving)
[20:24:11] <bblum> same for ftdetect instead of syntax
[20:24:16] <bblum> optionally for after/syntax/
[20:24:43] *** Joins: sebcrozet (sebcrozet@moz-C27D92D8.w193-252.abo.wanadoo.fr)
[20:24:48] <sam113101> IÂ did that (put the syntax file in ~/.vim/syntax) but it doesn't seem to work
[20:24:51] <graydon> strcat: I guess I will try transporting the build tree there and valgrind it there
[20:24:57] <bstrie> sam113101: you might also need a few lines in your vimrc
[20:25:01] <bstrie> sam113101: this is what I have:
[20:25:04] <doener> hrm. "let x = @5; x = @5;". First x has a refcount of 1, second one has a refcount of 2 because the assigment adds one on top of the one from local_malloc...
[20:25:07] <bstrie> au BufRead,BufNewFile *.rs set filetype=rust
[20:25:08] <sam113101> to tell .rs is rust?
[20:25:11] <bstrie> au! Syntax rust source ~/.vim/syntax/rust.vim
[20:25:19] *** Joins: alelos (alelos@moz-639D733A.adsl.online.nl)
[20:25:43] <doener> add a few more "x = ..." (like in phase_2_... in rustc) and you needlessly keep a bunch of stuff alive till the end of scope
[20:25:47] <strcat> bstrie: rust comes with a ftdetect file
[20:25:48] *** Quits: geomyidae (cole@DD6F7E3A.21468E9A.30200F38.IP) (Client exited)
[20:25:55] <strcat> don't need it in vimrc
[20:25:58] <bstrie> right, I'm not sure how much of that is necessary
[20:26:10] <strcat> http://ix.io/6VH comes with those atm
[20:26:14] <bstrie> back when I installed it we didn't have ftdetect, I don't think :P
[20:26:33] <sam113101> what's a ftdetect file?
[20:26:34] <strcat> or maybe you didn't have ft plugins enabled
[20:26:42] <strcat> sam113101: tells it how to detect the file type
[20:26:46] <bstrie> entirely possible
[20:27:08] <strcat> we even have a mime db file for making .rs get detected as rust
[20:27:17] <engla_> do the vim files set up indentation mode for rust?
[20:27:22] <strcat> engla_: yes
[20:27:34] <strcat> it's actually a good indent mode now
[20:27:45] <engla_> I don't think I have the newest vim files
[20:28:22] <sam113101> alright it's working now
[20:28:23] * strcat just gets them as part of the package he has set to build daily
[20:28:25] <bblum> oh my goodness this is so great to be able to check-stage0-std again, turnaround time is like 3 minutes; this is great
[20:28:46] <strcat> bblum: or just rustc std.rs --test ;p
[20:28:48] *** Joins: geomyidae (cole@DD6F7E3A.21468E9A.30200F38.IP)
[20:28:54] <strcat> with a rustc that's not too old
[20:29:30] <bblum> strcat: does not work half the time if you are changing stuff around in libstd
[20:29:33] *** Quits: devinus (devinus@moz-B4AF84BC.ptr.us.xo.net) (Quit: Computer has gone to sleep.)
[20:30:15] *** Quits: jgilbert (jgilbert@moz-BBE3ABD.mv.mozilla.com) (Quit: Leaving)
[20:30:35] <sam113101> why do IÂ have to indent things manually in my .rs files? it works with other file types
[20:30:45] <strcat> because you're missing the indent file
[20:30:55] <engla_> strcat: btw, I'm implementing rand access iterators now. Ringbuf can't have an instance for its mut_iter because .idx takes &self. Cheat like in vec, or change it?
[20:31:00] <sam113101> aww shit
[20:31:08] <sam113101> how many of these files do IÂ need ;p
[20:31:23] <strcat> engla_: I don't think it needs &mut self
[20:31:28] <strcat> it's not modifying the iterator
[20:31:47] <strcat> sam113101: just copy them all
[20:32:04] <sam113101> ok everything seems fine
[20:32:12] <sam113101> I download them from github
[20:32:14] <strcat> src/etc/vim goes in ~/.vim or /usr/share/vim/vimfiles/ (if a package manager is doing it)
[20:32:16] <sam113101> one by one
[20:32:23] <engla_> strcat: not sure how I can implement the mut rand access iterator. The mut iter holds a  &'self mut [Option<T>]  that needs to be converted to &'self mut T
[20:32:35] <bstrie> once again, this javascript only works in firefox because I used `let` instead of `var`... dammit rust!
[20:32:40] <engla_> but the mut slice is accessed through &self
[20:33:31] <strcat> bstrie: works in chromium too if you flip on ES6 support in about:flags afaik
[20:33:45] <strcat> although I don't use chromium so I'm only going by half-remembered anecdotes
[20:33:51] <bstrie> right, but that's not acceptable for the corporate users :P
[20:33:56] *** Quits: FrozenCow (FrozenCow@moz-B2DF4929.chello.nl) (Ping timeout)
[20:34:12] <bstrie> we recently switched their default browser from ie6 to chrome, I don't know how many even noticed...
[20:34:22] <bstrie> er, not ie6
[20:34:26] <bstrie> ie8
[20:34:34] <bstrie> close enough though :P
[20:34:41] *** Joins: Sergio965 (sergiobz@moz-BB21156B.dynamic.csail.mit.edu)
[20:35:01] *** Joins: paupau (textual@417F0514.289B9BF9.F20F0C5A.IP)
[20:35:29] <Sergio965> Is there a guide on how to use the inline assembly macro? I'm trying to put some data in a particular register and I keep getting: "error: couldn't allocate input reg for constraint 'a'".
[20:35:46] <bstrie> I think Luqman wrote asm!
[20:36:09] <strcat> bstrie: you can thank macros for making you seem overly excited about that :)
[20:36:14] <bstrie> talking about macros is always so exciting
[20:38:21] *** Joins: seth (seth@moz-BE33DA21.fw1.sfo1.mozilla.net)
[20:39:34] <sully> every time more code with warnings gets added to the compiler
[20:39:36] <sully> I get sad
[20:39:39] <sully> we are so close to zero warnings
[20:39:54] *** Joins: devinus (devinus@moz-B4AF84BC.ptr.us.xo.net)
[20:39:55] <bstrie> well we keep adding new warnings :P
[20:39:55] <strcat> sully: flip on deny(warnings) in librustc
[20:40:12] <Thiez> bstrie: I make that mistake all the time as well, 'let' just seems so natural once you get used to it
[20:40:24] <sully> bstrie: most of the time the warnings are unused variables
[20:40:25] <graydon> I thought we _had_ deny(warnings) on at at least one of the stages?
[20:40:34] <strcat> graydon: yeah but not for librustc afaik
[20:40:38] <strcat> just libstd, libextra
[20:40:50] <graydon> oh. turn it on for librustc as well.
[20:40:58] *** Joins: ghrust (ghrust@C621748.6A2AE50.F3114085.IP)
[20:40:58] <ghrust> 01[13rust01] 15toddaaro fast-forwarded 06snap-stage3 from 144cf3072 to 1463c9b11: 02http://git.io/MUzq-A
[20:40:58] *** Parts: ghrust (ghrust@C621748.6A2AE50.F3114085.IP) ()
[20:41:06] <strcat> vec::from_elem just becomes such bad code
[20:41:23] <graydon> why?
[20:41:38] <doener> strcat: still not inlining the for body?
[20:41:42] <graydon> or, oh, you mean that it generates lousy code?
[20:41:57] <graydon> I was thinking .. have you compared the pre-opt codegen of an external vs. internal iterator?
[20:42:05] <graydon> what kind of a win are we in for if we move to external?
[20:42:20] *** Quits: robarnold (rob@BD56354E.DB510C09.6E370BFC.IP) (Ping timeout)
[20:42:28] <Sergio965> So there's no information on the asm! macro beyond the changelog?
[20:42:46] <bstrie> Sergio965: sorry, quite possibly not :( you might just need to infer from usage
[20:42:49] <bstrie> or ask luqman
[20:43:06] <strcat> graydon: it's not much different, instead of a loop calling a function (your loop body), you have a loop calling a function (next)
[20:43:11] <Sergio965> bstrie: Where is it used?
[20:43:12] <strcat> graydon: it optimizes better though
[20:43:12] *** Joins: ecr (Thunderbir@moz-F724119C.uoregon.edu)
[20:43:21] <bstrie> Sergio965: grep for "asm!"
[20:43:23] <strcat> LLVm is really bad at dealing with our closures
[20:43:25] <graydon> strcat: doesn't it avoid building up the env?
[20:43:43] *** Quits: maxli (maxli@F2D29657.F60B0462.67AC9B1.IP) (Quit: Leaving.)
[20:43:44] <strcat> graydon: yeah, but that's not inside the loop body
[20:43:49] <graydon> I'm talking total code volume
[20:43:52] <bstrie> Sergio965: oh it gets used nowhere XD
[20:43:53] <graydon> # of instructions
[20:43:54] <strcat> oh, yeah - it's a *lot* smaller
[20:44:02] <Sergio965> bstrie: Yup.
[20:44:05] <strcat> I thought you meant perf
[20:44:14] <graydon> no no, like are we dumping much-less-IR on LLVM
[20:44:34] <bstrie> Sergio965: I'd consider that a bug that we don't even have test cases for it, but that sounds non-trivial to achieve for assembly...
[20:45:01] <strcat> graydon: yeah, if you compare 'loop { match it.next() { ... } }' like a new for loop would do, it's 1/10 the code size
[20:45:12] <graydon> ok
[20:45:13] <strcat> with .advance it's not better since it ends up an internal iterator anyway
[20:45:22] <graydon> yes, I know. but we're going to remove that.
[20:45:32] *** Quits: jviereck (Adium@moz-A034D4DA.dclient.hispeed.ch) (Ping timeout)
[20:45:32] <graydon> I'm trying to figure how much I should prioritize implementing 'for .. in ..'
[20:45:36] <graydon> sounds like "a lot"
[20:45:37] <strcat> doener: it seems to inline everything
[20:45:45] <strcat> doener: it just doesn't identify it as a memset idiom loop
[20:45:49] <strcat> or vectorize it
[20:45:53] <graydon> since there is seldom a function in rustc that doesn't call iterators. usually several.
[20:46:14] <graydon> this is annoying. i was going to do that today but got side tracked into hygenic macros.
[20:46:15] <graydon> grrrrr
[20:46:30] <strcat> our pointer arithmetic is really slow
[20:46:34] <Sergio965> bstrie: Why? You'd just write simple thing, like addition and such, and make sure things like constraints are working.
[20:46:35] <strcat> that could be the issue
[20:46:36] <doener> strcat: memset would only work for 0 anyway, right? And do we have vectorization enabled again?
[20:46:37] <strcat> inttoptr
[20:46:40] <graydon> if anyone _else_ wants to start on the translation of for .. in .., feel free
[20:46:46] <strcat> doener: it works for any byte pattern
[20:46:51] <strcat> loop-vectorize is enabled at -O3
[20:47:08] <strcat> likely by LLVM 3.4 we will have slp vectorization and loop vectorization at --opt-level=2 and above
[20:47:14] <strcat> because we'll just follow clang
[20:47:17] <kmc> I can have a type and a value of the same name in scope at the same time, right?
[20:47:31] <strcat> they already enabled loop-vectorize at -O2 in svn
[20:47:33] *** Quits: webber46 (webber46@moz-98D2F3C5.cust.bredband2.com) (Quit: webber46)
[20:47:42] <strcat> they might even use slp at -O1
[20:48:05] <doener> strcat: ah, right, I was only thinking of types > i8, for which 0 is probably the only "usual" value for which it would work. And I'm probably not aware of vectorization because I usually just use -O
[20:48:37] <strcat> doener: you really want --opt-level=3 now ;p
[20:49:09] *** Quits: jeff (jeff@moz-F81F6C4E.nyc.biz.rr.com) (Quit: jeff)
[20:49:13] <doener> heck, most of the time I'm just looking at non-optimized code :p
[20:49:16] <graydon> (incidentally, so I know whose feet not to step on: _is_ anyone actually working on implementing for .. in ..?)
[20:49:18] *** Joins: brson (brson@moz-BBE3ABD.mv.mozilla.com)
[20:49:18] *** ChanServ sets mode: +o brson
[20:49:22] * doener is clearly working on the wrong stuff
[20:49:33] <strcat> graydon: don't think so.
[20:50:09] <strcat> doener: https://github.com/mozilla/rust/blob/master/src/librustc/back/passes.rs#L61 same as clang, except for some details I commented on
[20:50:40] *** Joins: jeff (jeff@moz-F81F6C4E.nyc.biz.rr.com)
[20:51:02] <strcat> so with --opt-level=3 you get argpromotion, loop-vectorize + other loop fun and more aggressive inlining
[20:51:27] <Sergio965> Yeah, I think asm! is broken.
[20:51:54] <Sergio965> Doing "outb %al, %dx" results in "outb %al, (%dx).
[20:52:03] *** Joins: jaen (jaen@moz-E0979827.copit.pl)
[20:52:28] <doener> strcat: yeah, dug through that when I tried adding a function pass manager like clang. Didn't change enough for me to bother analyzing and PR'ing it
[20:52:42] <orshem> why  do inner modules not have access to their upper level module's private elements? 
[20:52:46] <strcat> we might actually have a function pass simply by default, I'm not sure how to ask LLVM to print out what we're doing
[20:53:01] * doener wishes he had more of a clue of this whole compiler optimization business
[20:53:13] <strcat> like clang -O3 -mllvm -debug-pass=Arguments
[20:53:24] <strcat> or debug-pass=Structure for a verbose tree-like printout
[20:53:57] <doener> strcat: I at least compared -Z time-llvm-passes with and without the FP-Manager, made a difference
[20:54:22] <strcat> doener: how much did it cut down the time?
[20:55:25] <doener> in total, not at all. Just moved it around a bit. By "made a difference" I just meant that there were new passes in the output.
[20:55:32] <strcat> ah
[20:55:42] <strcat> doener: which passes were you running there?
[20:55:49] <strcat> clang only runs a few
[20:55:56] <doener> same as clang, don't remember off-hand
[20:57:08] <strcat> at optimization on it does simplifycfg, domtree, sroa, early-cse, lower-expect
[20:57:11] <strcat> with*
[20:57:39] <doener> yeah, sounds about right. At least I remember lower-expect being in there
[20:57:52] *** Quits: paupau (textual@417F0514.289B9BF9.F20F0C5A.IP) (Ping timeout)
[20:57:53] *** Joins: jensnockert (jensnocker@moz-C5F27039.cust.bredband2.com)
[20:58:55] <strcat> doener: as long as it's not slower it's probably worth doing
[20:59:01] <strcat> since it will be optimizing a bit more
[21:01:03] <bblum> oof, this is getting more and more complicated
[21:01:06] <doener> I have it on a stash somewhere. I'll try to revive it when I'm done with the "memleak" phase_2_...
[21:01:12] *** Joins: jclements (jclements@moz-7782C71D.ngn.east.myfairpoint.net)
[21:01:18] *** Quits: jclements (jclements@moz-7782C71D.ngn.east.myfairpoint.net) (Quit: jclements)
[21:01:19] *** Joins: kaveh (Own3R@1D63B4A8.3E508F2A.4F4F77A2.IP)
[21:01:21] <kaveh> www.vipspeak.com new free chat program with voice chat in room and pm .. public rooms , u can make your own room and control it with admin power...
[21:01:24] *** Parts: kaveh (Own3R@1D63B4A8.3E508F2A.4F4F77A2.IP) ()
[21:01:26] *** Joins: ghrust (ghrust@DE823A67.6A2AE50.F3114085.IP)
[21:01:26] <ghrust> 01[13rust01] 15bors 04force-pushed 06auto from 14cd288e5 to 142830d7d: 02http://git.io/N3iJvQ
[21:01:26] *** Parts: ghrust (ghrust@DE823A67.6A2AE50.F3114085.IP) ()
[21:01:28] *** Joins: ghrust (ghrust@FD7BC443.6A2AE50.F3114085.IP)
[21:01:28] <ghrust> 01[13rust01] 15bors pushed 2 new commits to 06auto: 02http://git.io/KdUy8Q
[21:01:28] <ghrust> 13rust/06auto 1411aad20 15blake2-ppc: std: Implement Clone and DeepClone for extern "Rust" fn...
[21:01:28] <ghrust> 13rust/06auto 14d34016d 15bors: auto merge of #8109 : blake2-ppc/rust/extern-fn-clone, r=thestinger...
[21:01:29] *** Parts: ghrust (ghrust@FD7BC443.6A2AE50.F3114085.IP) ()
[21:02:21] <strcat> doener: it actually vectorizes this at -O3
[21:02:23] <strcat> from_elem
[21:02:25] <strcat> but it's slower
[21:02:27] <strcat> ;p
[21:02:29] <doener> haah
[21:02:35] <doener> err, haha
[21:02:42] <strcat> the loop-idiom pass should be picking this up
[21:02:43] <strcat> ;[
[21:04:03] *** Joins: jgilbert (jgilbert@moz-BBE3ABD.mv.mozilla.com)
[21:05:11] *** Joins: robertknight (robertknig@moz-AB0E96D7.range86-162.btcentralplus.com)
[21:05:27] *** Joins: pnkfelix (pnkfelix@moz-43495417.fbx.proxad.net)
[21:08:42] <orshem> it's really not that good that vec takes everything by & ref when I'm using primitives and small structs.
[21:09:09] <orshem> it also means that i run into reborrow errors when i shouldn't
[21:09:14] <toddaaro> anyone know git able to save this branch? http://pastebin.mozilla.org/2739690
[21:09:35] <strcat> orshem: there won't be any overhead from that
[21:09:43] <toddaaro> this is the output of bblum's work and my work, but it looks totally messed up in terms of history
[21:09:58] <orshem> strcat: how?
[21:10:05] <strcat> if they're inlined it won't matter, and if they're not inlined argpromotion will take care of it
[21:10:09] <orshem> also the second point is sadder :(
[21:10:11] <toddaaro> somehow in the forking/rebasing a branch name of bblum ended up as owning "every" commit since the start of time?
[21:10:34] <strcat> orshem: I don't know why you would be hitting the 2nd point, you can always copy
[21:11:07] *** Joins: eckzow (eckzow@moz-506D8496.members.linode.com)
[21:11:07] <orshem> strcat: is there an equivalent fn to last() that return a copy
[21:11:09] <orshem> ?
[21:11:27] <strcat> that won't matter
[21:11:32] *** Parts: graydon (graydon@moz-F14EE0DB.cable.teksavvy.com) ()
[21:11:39] <brson> toddaaro: can you link to the branch?
[21:11:43] <strcat> whether or not it returns a copy it has to borrow the vector
[21:11:58] <strcat> you can dereference it if you don't want a reference longer than the context of the call
[21:12:18] <brson> toddaaro: or just tell me the name of it
[21:12:19] <strcat> copying from a vector still borrows the vector
[21:12:49] <brson> orshem: do you have an example of the reborrow error that you shouldn't run into?
[21:12:52] <orshem> strcat: but it shouldn't keep the reference longer than the call because it is an rvalue
[21:13:14] <strcat> it won't
[21:13:16] <toddaaro> brson: I'm going to get coffee with a few people, my branch is tls-tk-pr-pre on my fork
[21:13:23] <strcat> it will only keep it if you store it somewhere
[21:13:23] <orshem> brson: i'm too new to blame the compiler. human error (mine!) is much more likely
[21:13:28] <toddaaro> brson: if you want to look at it feel free, I'll be back at it in ~30m or so
[21:13:43] <strcat> *xs.last()
[21:13:58] <Thiez> orshem: perhaps you could put your code somewhere and say where the error occurs?
[21:14:29] <strcat> LLVM really doesn't want to vectorize this sanely
[21:14:29] <Thiez> let x = &5; let y = &*x; (*x,*y) // Or use rusti when it's a nice one-liner
[21:14:42] <Thiez> darn I always forget to prepend 'rusti:' :D
[21:15:13] *** Quits: askalski (akuda@2BA4E5A7.CC7751E8.6712E96B.IP) (Quit: Wychodzi)
[21:16:02] *** Quits: msingle (Thunderbir@moz-930E5D97.hr.hr.cox.net) (Ping timeout)
[21:17:26] <orshem>  Thiez: it's a bit long: https://gist.github.com/anonymous/6107925
[21:18:30] <strcat> I think move_val_init is the problem
[21:19:30] <strcat> obviously not helping that each time we offset a ptr, it converts to and from an int
[21:19:44] <Thiez> ah, Cell everywhere
[21:19:54] <strcat> think we need to make the + and - for pointers compiler features to fix that
[21:20:06] <Thiez> Cell should really get shot or something :p
[21:20:28] *** Quits: jeff (jeff@moz-F81F6C4E.nyc.biz.rr.com) (Quit: jeff)
[21:21:09] <strcat> doener: afaict inttoptr is the cause ;[
[21:21:25] <brson> toddaaro: I don't see anything specifically wrong with that branch. Does the problem occur when rebasing it onto master (it does look like a difficult rebase)? If so then maybe it would be easier to do a merge instead of rebase
[21:21:36] <bblum> Thiez: i would love to
[21:22:13] *** Joins: jeff (jeff@moz-F81F6C4E.nyc.biz.rr.com)
[21:22:32] <doener> strcat: uhm, for what?
[21:22:42] <Thiez> bblum: I almost killed it way back along with Mut, but I think it was required in servo or something?
[21:22:58] <strcat> doener: from_elem being 5x slower than a memset
[21:23:02] <doener> ah
[21:23:12] <strcat> it's an overall loop problem though
[21:23:16] <bblum> Thiez: it's required just about everywhere because we don't have one-shot stack closures
[21:23:44] <bblum> Thiez: unless you're willing to duplicate all higher-order library functions to have a *_with variant that threads an argument through
[21:24:27] <bblum> ARGH, the stupid removing previous libraries thing
[21:24:35] <bblum> this is like the 5th time i've lost 5 minutes of time to it today
[21:24:42] <bblum> ;asldkjfa;ldskjfasdf
[21:24:58] <strcat> doener: I could just try making them intrinsics...
[21:25:01] <strcat> offset and mut_offset
[21:25:53] *** Quits: pnkfelix (pnkfelix@moz-43495417.fbx.proxad.net) (Quit: Leaving.)
[21:26:14] <orshem> i love rust
[21:26:16] <SiegeLord> Can you initialize a variable at runtime and move it into a static variable?
[21:26:18] <strcat> we have such weird performance issues ;p
[21:26:18] <orshem> (every time i figure out a borrow error's reason)
[21:26:21] *** Quits: BitPuffin (quassel@moz-49828767.cust.tele2.se) (Ping timeout)
[21:27:12] <doener> strcat: I'd be happy if I understood half of why we have them
[21:27:28] <strcat> this one is especially weird
[21:27:45] <strcat> who'd have thought pointer arithmetic could be something we implemented in a slow way
[21:28:13] <doener> strcat: 90% of the time, I don't understand why certain change have no effect at all when I expected a major gain and huge savings when I think that it's just a minor cleanup
[21:28:14] <bblum> orshem: the best part about it is each time you do it, you get better at avoiding them in advance later
[21:28:27] *** Joins: lkuper (lkuper@3AE931C6.A402E718.C082B7DC.IP)
[21:28:30] <strcat> doener: yeah I was surprised that removing headers from exchange allocs didn't help rustc
[21:28:34] <strcat> but it's because it's all @ :(
[21:29:15] *** Quits: spider-mario (spidermari@moz-81131DB6.fbx.proxad.net) (Input/output error)
[21:29:32] *** Quits: thomaslee (thomaslee@moz-6C3931E3.static.twtelecom.net) (Client exited)
[21:30:04] *** Quits: jgilbert (jgilbert@moz-BBE3ABD.mv.mozilla.com) (Ping timeout)
[21:30:40] *** Joins: thomaslee (thomaslee@moz-6C3931E3.static.twtelecom.net)
[21:32:28] *** Quits: Sergio965 (sergiobz@moz-BB21156B.dynamic.csail.mit.edu) (Ping timeout)
[21:33:02] <doener> hm, 1353068maxresident => 912024maxresident
[21:33:08] <doener> but the change is soooo damn ugly
[21:33:10] <orshem> bblum: hopefully :)
[21:33:13] <Thiez> orshem: have you figured it out yet? I've got it fixed
[21:33:43] <orshem> Thiez: yep!! thank you
[21:34:11] <orshem> the problem was that last() return a pointer to part of the vector freezing the whole of it
[21:34:36] <doener> strcat: have an idea how to get a prettier version of this? https://gist.github.com/dotdash/56d33f814000626afff5
[21:34:51] *** Quits: robertknight (robertknig@moz-AB0E96D7.range86-162.btcentralplus.com) (Ping timeout)
[21:35:33] <strcat> doener: hm, what exactly does that do?
[21:35:44] <strcat> can you just make it use Rc instead of @?
[21:36:05] <doener> strcat: not sure if that would help, or how hard that is
[21:36:07] <strcat> @ isn't useful, if you're strictly talking about performance
[21:36:18] <orshem> Thiez: i'd still like to see your version.
[21:36:26] <doener> strcat: I tried to get it to use ~, but that's more pain than I'm willing to take atm
[21:36:29] *** Joins: robarnold (rob@BD56354E.DB510C09.6E370BFC.IP)
[21:36:32] <strcat> doener: well it's a drop-in replacement for @T if the type is T: Const or T: Send
[21:36:41] <strcat> but there's no borrow/deref sugar
[21:36:51] <strcat> so you need x.borrow() or *x.borrow()
[21:37:08] <doener> strcat: basically, x = @5; gets you a value with refcount = 2. Thus it's not freed on reassignment, but only when the scope ends
[21:37:26] <Thiez> orshem: I think it was like strcat, dereferencing the .last() and then removing the derefs for 'current' later in that function
[21:37:27] <doener> strcat: the nested scopes make the scope for each crate end early
[21:37:41] *** Joins: xorcon (Mibbit@moz-15A0B334.customer.t3.se)
[21:38:02] <strcat> doener: well, Rc has move semantics
[21:38:06] <strcat> x = y won't refcount++
[21:38:06] <doener> strcat: thus peak mem usage is reduced significantly (~440MB ~ 33%)
[21:38:12] *** Joins: aatch (aatch@moz-B437F499.pocketrent.com)
[21:38:16] <strcat> every single @ should really be Rc right now
[21:38:24] <strcat> we really need a pointer trait with sugar
[21:38:33] <strcat> (well, almost every @ - some are cyclic)
[21:38:47] <doener> *shivers*
[21:39:02] <strcat> or at least not provably acyclic with the inaccurate requirement currently used
[21:39:10] * doener had lots of fun with @-cycles in CrateContext(?)
[21:39:26] *** Joins: jgilbert (jgilbert@moz-7B0110AD.mv.mozilla.com)
[21:39:38] *** Quits: xorcon (Mibbit@moz-15A0B334.customer.t3.se) (Quit: http://www.mibbit.com ajax IRC Client)
[21:39:41] <strcat> doener: Rc moves, so you avoid almost all the refcounts
[21:39:50] <strcat> only need a refcount on a place where ownership actually splits down two paths
[21:40:11] <strcat> @ just isn't a good fit for refcounting
[21:41:04] <aatch> We need lazy refcounting instead of eager refcounting
[21:41:22] <doener> strcat: ok. Guess I'll try that tomorrow evening, now that I know it's worth it (considering both memory usage and aesthetics)
[21:42:03] <strcat> doener: I think before the gc lands we need to migrate most @ to Rc anyway
[21:42:12] <strcat> because we really depend on it being refcounting to keep mem usage sane
[21:42:30] <kmc> Rc uses less memory because it doesn't link onto the managed object list?
[21:42:48] <strcat> kmc: it has a 1-word header instead of 4, and is much more efficient because of move semantics
[21:43:07] <kimundi> strcat: r? https://github.com/mozilla/rust/pull/8082
[21:43:09] <strcat> passing it by-value is a move, all reference counts are explicit clones
[21:43:19] *** Quits: jeff (jeff@moz-F81F6C4E.nyc.biz.rr.com) (Quit: jeff)
[21:43:26] <kmc> i see
[21:43:27] <Thiez> move semantics are great
[21:43:47] <doener> aatch: in this case, it's really about move semantics or whatever "let x = @5" does that "x = @5" doesn't.
[21:44:16] <doener> aatch: if they'd behave the same, that would solve this problem right away (until GC lands)
[21:44:38] <strcat> doener: when gc lands the memory usage will go way up
[21:44:46] <doener> to say the least ;-)
[21:45:11] <strcat> easiest way to land gc -> add sugar for Rc, port away from @ ;p
[21:45:21] <strcat> then the gc can start off being horrible, it won't matter
[21:45:25] <strcat> (much)
[21:45:50] <doener> IIRC most papers I've read had GC at 5 times the peak memory usage of refcounted or manually managed code
[21:46:08] <doener> means about 6.5GB to compile librustc :-D
[21:46:33] * doener doesn't read that many papers on that topic though
[21:46:56] *** Quits: donri (dag@moz-9BB61102.tbcn.telia.com) (Client exited)
[21:47:02] <strcat> doener: they have to have much higher memory usage to be fast
[21:47:24] <doomlord> maybe i should try and write one of those source->hyperlinked HTML translators for rust, maybe that would be easier than delving into IDEs
[21:47:33] <strcat> but I really think Rc will be faster than a non-generational gc 90% of the time
[21:47:37] <strcat> even for short-lived, small objects
[21:47:40] *** Quits: hjr3 (hradtke@1A0AE795.28A5F6C3.A2D40ED2.IP) (Quit: My MacBook has gone to sleep. ZZZzzzâ€¦)
[21:47:44] <doomlord> (pretty print rust source from the ast, with links..)
[21:48:07] <strcat> C++'s shared_ptr is only slow because of supporting weak pointers + doing atomic refcounting
[21:48:18] <strcat> and C++ doesn't move-by-default so you end up reference counting too much
[21:50:42] <Thiez> the compiler could eliminate some of those, right?
[21:51:06] <steven_is_false> How can I guarantee that a spawned task runs on a different OS thread?
[21:51:23] <Thiez> if it sees (x++) < some code > (x--) it could eliminate that refcount inc/dec
[21:51:41] <strcat> Thiez: it won't though because of aliasing
[21:51:49] <strcat> Thiez: any store/load between the ++ and the -- could alias it
[21:52:19] <strcat> when pointers are involved, LLVM doesn't really do any optimizations like that without TBAA
[21:52:41] <strcat> + you couldn't have any non-inlined function calls, because rustc doesn't output readnone/readonly attributes
[21:53:30] <Thiez> that aliasing is really annoying.
[21:54:04] <strcat> if we gave LLVM aliasing guarantees it could do it...
[21:54:35] <Thiez> that will be tricky though.
[21:55:59] *** Quits: mihneadb (mihneadb@moz-BE33DA21.fw1.sfo1.mozilla.net) (Input/output error)
[21:55:59] *** Quits: orshem (orshem@C5E06B1E.A5B6B765.E3D28531.IP) (Quit: Leaving)
[21:56:23] <toddaaro> brson: hm, ok
[21:56:37] <toddaaro> brson: I tried some sanitizing of my local master and now I'm starting the rebase again
[21:57:17] <toddaaro> brson: the original issue is that it started "at the beggining of time" and had me resolving merge conflicts from 2011, 2012, etc.
[21:57:18] *** Quits: acrichto (acrichto@moz-B63D64BD.res.cmu.edu) (Quit: leaving)
[21:57:25] <toddaaro> brson: and it looks like another rebase also has me doing that
[21:57:31] *** Joins: acrichto (acrichto@moz-B63D64BD.res.cmu.edu)
[21:59:32] *** Joins: hjr3 (hradtke@1A0AE795.28A5F6C3.A2D40ED2.IP)
[21:59:46] *** Joins: mihneadb (mihneadb@moz-BE33DA21.fw1.sfo1.mozilla.net)
[22:00:03] <toddaaro> yea, this rebase --interactive gave me 11051 commits to deal with
[22:00:15] *** Quits: bheylin (brianheyli@moz-8255E94E.adsl.online.nl) (Quit: bheylin)
[22:00:21] *** Quits: bnicholson (bnicholson@moz-3492C575.rcmdva.fios.verizon.net) (Ping timeout)
[22:01:29] *** Quits: acrichto (acrichto@moz-B63D64BD.res.cmu.edu) (Quit: leaving)
[22:01:58] <brson> toddaaro: when I do 'git rebase mozilla/master -i' I see your 4 commits
[22:02:08] <toddaaro> from inside the branch?
[22:02:21] <brson> yes
[22:02:55] <SiegeLord> Hmm, I'd like an option to spawn a new OS thread for a task too
[22:02:59] *** Joins: maxli (maxli@B5559308.9C54E60.2FA4EA88.IP)
[22:03:06] <toddaaro> if I try that command I get "fatal: Needed a single revision \n invalid upstream mozilla/master"
[22:03:09] <SiegeLord> Makes it easier to deal with APIs that already have TLS
[22:03:15] <SiegeLord> Where T is thread
[22:03:21] *** Quits: maxli (maxli@B5559308.9C54E60.2FA4EA88.IP) (Max SendQ exceeded)
[22:03:28] <brson> toddaaro: which command are you using? maybe yours is upstream/master?
[22:03:38] *** Joins: maxli (maxli@B5559308.9C54E60.2FA4EA88.IP)
[22:03:50] *** Quits: erickt (erickt@8C9ECD8F.3A598286.F12515B4.IP) (Quit: Leaving.)
[22:04:03] <toddaaro> brson: http://pastebin.mozilla.org/2739945
[22:04:55] <toddaaro> my git version is 1.8.1.2 if that matter
[22:04:56] <toddaaro> s
[22:05:21] <brson> toddaaro: maybe 'git fetch mozilla' first
[22:05:43] *** Joins: azita (Azita@B2097C45.E2EA453A.FAF22AF7.IP)
[22:06:14] <toddaaro> brson: ah! that seems to have worked
[22:06:22] <toddaaro> what was the problem exactly?
[22:09:01] <brson> toddaaro: i'm not sure what the original problem was, but you didn't have any branches for the 'mozilla' remote (which usually means you 'get remote add'ed it but never fetched)
[22:09:08] *** Quits: km (quassel@FDBAF0A0.DBF71E41.29C67456.IP) (Ping timeout)
[22:09:11] <bblum> almost done making select tests, just the hardest bug (segfault) remains...
[22:09:46] <toddaaro> brson: hm, ok. maybe someday I'll understand why it failed the way it did
[22:09:47] <bblum> making select tests work i mean
[22:11:27] <brson> toddaaro: what command were you using?
[22:11:58] <toddaaro> "git rebase master" from inside my branch, with "master" being 'git fetch mozilla master'
[22:12:08] <toddaaro> after deleting my local master
[22:12:09] *** Joins: km (quassel@FDBAF0A0.DBF71E41.29C67456.IP)
[22:12:52] <brson> toddaaro: if your original clone was from my fork, then i imagine you were accidentally rebasing onto brson/master, which is from jan 2012
[22:12:59] *** Joins: graydon (graydon@moz-F14EE0DB.cable.teksavvy.com)
[22:12:59] *** ChanServ sets mode: +qo graydon graydon
[22:13:07] <toddaaro> ah, maybe that did it
[22:13:13] <brson> graydon: i need a buildbot password for rust-mac6
[22:14:53] *** Joins: mark_edward (quassel@moz-4A9A2F15.dynamic.utc.edu)
[22:15:51] *** Quits: SiegeLord (sl@moz-CAF07B4C.hsd1.ma.comcast.net) (Quit: It's a joke, it's all a joke.)
[22:16:34] <toddaaro> brson: looks like I just need to do some work in the mod.rs startup function to merge your main_thread stuff and the new sched.boostrap(task) startup. When I'm done the PR will go up
[22:18:03] *** Quits: infynyxx (infynyxx@DB780A29.749BA1D.DCC373F0.IP) (Client exited)
[22:18:06] *** Joins: acrichto (acrichto@moz-B63D64BD.res.cmu.edu)
[22:18:22] *** Joins: pnkfelix (pnkfelix@moz-43495417.fbx.proxad.net)
[22:19:15] <strcat> hm
[22:20:07] *** Quits: jedestep (jedestep@34641662.FB4DE631.66C78B76.IP) (Ping timeout)
[22:21:03] <engla_> rusti:  use std::iterator::*; let mut v = ~[1,2,3,4]; { let it = v.mut_iter(); let x = it.idx(2).unwrap(); let y = it.idx(2).unwrap(); *x = 0; *y = 0;  std::borrow::ref_eq(x, y)} 
[22:21:04] -rusti- true
[22:21:09] <engla_> strcat: ^ this is bad.
[22:21:28] *** Quits: azita (Azita@B2097C45.E2EA453A.FAF22AF7.IP) (Quit: azita)
[22:21:40] <engla_> I told you VecMutIterator was cheating :-)
[22:23:01] <tikue> engla_: what should be the appropriate behavior? that you can only access index 2 once?
[22:23:16] *** Joins: Jesse_ (jruderman@moz-BBE3ABD.mv.mozilla.com)
[22:23:25] *** Quits: Jesse (jruderman@moz-BBE3ABD.mv.mozilla.com) (Connection reset by peer)
[22:23:26] <engla_> yes, two &mut pointers to the same place should not occur
[22:23:38] <engla_> well I could misunderstand something here but I don't think so
[22:24:20] <strcat> engla_: just remove the implementation for mutable iterators
[22:24:31] *** Joins: infynyxx (infynyxx@DB780A29.749BA1D.DCC373F0.IP)
[22:25:09] <engla_> I even went through the trouble of wrapping VecMutIterator for Ringbuf before this
[22:25:28] <engla_> can't RandomAccessIterator use &mut self just like the other iterator methods?
[22:25:34] <strcat> returning &'self mut isn't possible through either &mut self or &self in safe code
[22:25:42] <strcat> &mut is non-copyable
[22:25:48] <strcat> you would need 'self'
[22:26:13] <strcat> I don't think it would be correct
[22:26:16] <bblum> does GDB have good reverse execution these days?
[22:26:36] <strcat> the mutability and lifetime of the pointers it returns are totally unrelated from the iterator's mutability
[22:26:44] *** Quits: Jesse_ (jruderman@moz-BBE3ABD.mv.mozilla.com) (Ping timeout)
[22:26:57] <strcat> and the iterator's lifetime is disconnected from the elements it yields
[22:26:59] <engla_> yes and no. in this case you need to freeze the iterator
[22:27:12] <strcat> engla_: only until it returns it
[22:27:22] <strcat> &mut self doesn't somehow tie the lifetime of what it returns to itself
[22:27:29] <strcat> the pointers it returns are unrelated
[22:27:37] <engla_> hm I guess that's true
[22:27:41] <strcat> you would need &'self mut self
[22:27:48] <engla_> yes
[22:27:49] <strcat> and it'd be much more unusable for &
[22:27:59] <strcat> we just need a separate trait for mutable random access
[22:28:13] <engla_> yeah
[22:28:14] *** Quits: jaen (jaen@moz-E0979827.copit.pl) (Ping timeout)
[22:28:16] <strcat> can't be implemented by safe code anyway
[22:28:25] <engla_> I have a branch for this, I'll remove the impl for vecmutiter
[22:28:25] <strcat> foo.rs:7:8: 7:14 error: cannot move out of dereference of & pointer
[22:28:27] <strcat> foo.rs:7         self.x
[22:28:48] <strcat> (self x is &'self mut int)
[22:28:53] <strcat> self.x
[22:29:10] *** Quits: thpickert (thpickert@moz-34341F25.dynamic.dsl.tng.de) (Quit: thpickert)
[22:29:14] *** Quits: jensnockert (jensnocker@moz-C5F27039.cust.bredband2.com) (Input/output error)
[22:29:47] *** Quits: jmgrosen (jmgrosen@moz-848F6087.sb.sd.cox.net) (Ping timeout)
[22:29:54] *** Joins: froystig (froystig@4AB93A85.352137A1.BCED17D.IP)
[22:30:06] *** Quits: froystig (froystig@4AB93A85.352137A1.BCED17D.IP) (Quit: leaving)
[22:30:34] *** Joins: froystig (froystig@4AB93A85.352137A1.BCED17D.IP)
[22:30:55] *** Joins: Jesse (jruderman@moz-BBE3ABD.mv.mozilla.com)
[22:31:07] *** kimundi is now known as zz_kimundi
[22:31:19] *** Joins: jmgrosen (jmgrosen@moz-848F6087.sb.sd.cox.net)
[22:31:26] *** Quits: froystig (froystig@4AB93A85.352137A1.BCED17D.IP) (Quit: leaving)
[22:37:21] <brson> graydon: ping
[22:37:28] <graydon> brson: pong
[22:37:41] <brson> graydon: i need a slave pw for rust-mac6
[22:38:12] *** Quits: alisdair (textual@1697D94C.7742FB18.FBC8476D.IP) (Quit: My MacBook Pro has gone to sleep. ZZZzzzâ€¦)
[22:38:22] *** Joins: alisdair (textual@1697D94C.7742FB18.FBC8476D.IP)
[22:38:33] *** Quits: alisdair (textual@1697D94C.7742FB18.FBC8476D.IP) (Quit: My MacBook Pro has gone to sleep. ZZZzzzâ€¦)
[22:39:33] *** Joins: zatnosk (zatnosk@31AE4F7A.F285E7E8.9E52235C.IP)
[22:41:18] <sam113101> guys
[22:41:28] *** Quits: rust-buildbot (rust-build@505BFA3.C3CCCE8C.D25A875A.IP) (Quit: buildmaster reconfigured: bot disconnecting)
[22:41:29] *** Joins: rust-buildbot (rust-build@505BFA3.C3CCCE8C.D25A875A.IP)
[22:41:31] <sam113101> are normal variables in CÂ in the stack or in the heap?
[22:41:36] <bblum> stack
[22:42:06] <sam113101> if you want to use the heap you must use malloc?
[22:42:07] <brson> ok rust-mac6 is online
[22:43:25] <bblum> sam113101: or 'new', in the case of c++
[22:43:51] *** Quits: mihneadb (mihneadb@moz-BE33DA21.fw1.sfo1.mozilla.net) (Ping timeout)
[22:43:56] <bblum> ugh, i am spending a week longer than anticipated on select
[22:44:02] <strcat> per the language spec C/C++ don't have a stack/heap though
[22:44:02] <zxcdw> sam113101: strictly C has no concept of stack or the heap, but pretty much all relevant implementations use heap for malloc and stack for local/automatic variables
[22:44:03] *** Quits: pyrac (pyrac@moz-C9A4FCEC.w90-55.abo.wanadoo.fr) (Quit: pyrac)
[22:44:05] <strcat> that's an implementation detail
[22:44:16] <sam113101> bblum: and ~ is how you do it with rust?
[22:44:17] <bblum> strcat: STACK AND HEAP ARE ERRORS IN YOUR BRAIN
[22:44:21] <bblum> sam113101: yes
[22:44:25] <sam113101> ok
[22:44:25] <zxcdw> C++ has "free store" for heap though
[22:44:28] *** Joins: mihneadb (mihneadb@moz-BE33DA21.fw1.sfo1.mozilla.net)
[22:45:19] <strcat> bblum: they are ;p
[22:45:22] <kmc> sam113101: local variables in C typically end up on the stack; global / file-static / function-static variables will typically end up in memory that's neither stack nor heap
[22:46:21] *** Joins: ghrust (ghrust@2EE61FCC.6A2AE50.F3114085.IP)
[22:46:21] <ghrust> 01[13rust01] 15bors merged 06auto into 06master: 02http://git.io/KdUy8Q
[22:46:21] *** Parts: ghrust (ghrust@2EE61FCC.6A2AE50.F3114085.IP) ()
[22:46:27] <aatch> kmc, like the .bss segment
[22:46:47] <strcat> there's really no such thing as a stack, thread, process or heap on linux
[22:46:54] <strcat> only tasks and address space
[22:47:32] <kmc> not entirely true; if you cat /proc/self/maps you will see [stack] and [heap]
[22:48:00] <kmc> the stack mapping is special because it grows on page faults, although you can establish your own mappings of this form with mmap(MAP_GROWSDOWN)
[22:48:02] *** Quits: infynyxx (infynyxx@DB780A29.749BA1D.DCC373F0.IP) (Client exited)
[22:48:11] <strcat> kmc: that's not true
[22:48:13] *** Quits: zatnosk (zatnosk@31AE4F7A.F285E7E8.9E52235C.IP) (Quit: Have a great life!)
[22:48:27] <kmc> i don't know if there's anything special about the heap mapping, other than it's presumably where brk(2) grows from
[22:48:30] <kmc> strcat: oh?
[22:48:54] <sully> hm, so, looking at https://github.com/mozilla/rust/issues/2401
[22:49:13] <sully> I could change the behavior of -o so that it doesn't work if building a library?
[22:49:19] *** Joins: ghrust (ghrust@C621748.6A2AE50.F3114085.IP)
[22:49:19] <ghrust> 01[13rust01] 15bors pushed 0 new commits to 06auto: 02http://git.io/m5nceg
[22:49:19] *** Parts: ghrust (ghrust@C621748.6A2AE50.F3114085.IP) ()
[22:49:21] *** Joins: ghrust (ghrust@614D05BD.6A2AE50.F3114085.IP)
[22:49:21] <ghrust> 01[13rust01] 15bors pushed 2 new commits to 06auto: 02http://git.io/JtqMBw
[22:49:21] <ghrust> 13rust/06auto 144b45f47 15blake2-ppc: std: Rename Iterator adaptor types to drop the -Iterator suffix...
[22:49:21] <ghrust> 13rust/06auto 14bb996bf 15bors: auto merge of #8090 : blake2-ppc/rust/iterator-adaptor-names, r=pcwalton...
[22:49:22] *** Parts: ghrust (ghrust@614D05BD.6A2AE50.F3114085.IP) ()
[22:49:22] <sully> and add a new flag to specify a library directory?
[22:49:37] <aatch> sully, I think there is an output directory flag already
[22:49:39] <toddaaro> I pushed to the snapshotting branch a bit ago, but what are the "tinderboxes"?
[22:49:43] <strcat> kmc: all memory is allocated on page faults
[22:49:43] <toddaaro> I assumed that was bors in some way
[22:49:49] <toddaaro> but I do not see anything on the bors page
[22:49:53] <aatch> toddaaro, I think it's a mozilla thing
[22:50:07] <kmc> strcat: sure but for the stack the mapping itself also grows
[22:50:13] <toddaaro> aatch: oh really?
[22:50:15] <strcat> kmc: it's no different though
[22:50:18] <aatch> toddaaro, as in, what the rest of mozilla uses instead of buildbot
[22:50:19] <strcat> kmc: it's entirely the same semantics
[22:50:22] *** Joins: scanlonman (scanlonman@moz-3DC38006.dhcp.trcy.mi.charter.com)
[22:50:23] <aatch> I'm just guessing though
[22:50:27] <kmc> then why does MAP_GROWSDOWN exist?
[22:50:27] <strcat> kmc: MAP_GROWSDOWN is a no-op beyond debugging ability
[22:50:29] <sully> aatch: ah, it does, but it doesn't have a short name
[22:50:36] <strcat> kmc: why do old syscalls like tuxcall exist?
[22:50:43] <strcat> the kernel<->userland ABI is stable
[22:50:45] <strcat> it never changes
[22:50:45] <aatch> heh, `tuxcall`
[22:51:03] <aatch> I still want to know what that is supposed to do.
[22:51:09] <toddaaro> aatch: ok, I have started trying to snapshot to get your new intrinsic in (thanks for that) but the documentation seems somewhat lacking
[22:51:17] <strcat> aatch: I think it was a filesystem
[22:51:20] <strcat> tuxfs or something
[22:51:21] <sully> what is tuxcall?
[22:51:24] <strcat> it predated /sys
[22:51:28] <strcat> and probably /proc
[22:51:44] <toddaaro> graydon: what are the tinderboxes for snapshotting?
[22:52:00] <graydon> toddaaro: you mean the buildbot builders?
[22:52:03] <graydon> or the branch? or .. ?
[22:52:04] <kmc> strcat: I think the semantics are different, because if you made a 2GB mapping for the stack (to be allocated on faults) then mmap(NULL,...) would never put another mapping in that 2GB of virtual address space.  whereas with the grows-down mapping, if you use only a little stack and a lot of other mappings, it will fill in around the stack
[22:52:14] <toddaaro> graydon: I guess? whatever I'm supposed to look at to snapshot stuff
[22:52:16] <kmc> strcat: I'm not positive, though
[22:52:22] <graydon> toddaaro: did you push a snap already?
[22:52:31] <bblum> graydon: he means the literal tinderboxes
[22:52:35] <toddaaro> graydon: yea, an hour or so ago to the snap-stage3
[22:52:35] <aatch> toddaaro, just push to snap-stage3, update the snapshots file when they're done and fix any errors
[22:52:44] <graydon> we don't have tinderboxes. tinderbox is a dead script nobody runs anymore.
[22:52:46] <bblum> he needs to light the boilers for the steam engines that run the computers that make our snapshots
[22:52:53] <toddaaro> bblum: :=|
[22:52:53] <strcat> kmc: that's probably part of the semantics, but I don't think it's part of the implementation
[22:53:00] <bblum> toddaaro: :=|
[22:53:01] <kmc> aatch, strcat: http://en.wikipedia.org/wiki/TUX_web_server "The TUX web server is an in-kernel web server for Linux licensed under the GNU General Public License (GPL). It was maintained by Ingo MolnÃ¡r."
[22:53:06] <strcat> kmc: as in, per the API it would be undefined behaviour to do that, but I don't think it takes advantage of it
[22:53:11] <graydon> http://buildbot.rust-lang.org/builders is the list of builders
[22:53:13] <toddaaro> graydon: so what builds the snapshots if the tinderstuff is gone?
[22:53:14] <bblum> toddaaro: or rather, (:3) :: (Num [a]) => a -> [a]
[22:53:20] <graydon> toddaaro: buildbot
[22:53:21] <kmc> strcat: to do what?
[22:53:21] <strcat> kmc: don't think that's what tuxcall is for
[22:53:30] <Thiez> good news! the (badly written) simd version of rustray is now faster that the normal version
[22:53:39] <strcat> kmc: http://www.tutorialspoint.com/unix_system_calls/tux.htm
[22:53:47] *** simon is now known as IRCMonkey42159
[22:53:55] <graydon> toddaaro: the builders named snap3-{linux,win,mac,bsd} are the builders that build snapshots
[22:53:58] <brson> toddaaro: are you seeing some out of date docs related to snapshotting? can you link it?
[22:53:59] <strcat> some really ancient thing that no longer makes sense
[22:54:00] <Thiez> faster than*
[22:54:04] <strcat> but it will still let binaries make that syscall
[22:54:05] <kmc> strcat: that mentions a lot of stuff about HTTP servers
[22:54:08] <graydon> toddaaro: http://buildbot.rust-lang.org/builders/snap3-bsd for example
[22:54:19] <toddaaro> https://github.com/mozilla/rust/wiki/Note-compiler-snapshots
[22:54:22] <bblum> Thank you for flying rterrln()s.
[22:54:25] <kmc> anyway you are correct that the TUX in kernel web server is some really ancient thing that no longer makes sense and also never made sense
[22:54:28] <strcat> kmc: yeah but I think the purpose was also what /sys is today
[22:54:41] <kmc> what are you basing that on
[22:54:48] <strcat> based on reading about it before
[22:54:51] <kmc> ok
[22:55:19] <brson> the wiki page on snapshotting looks pretty out of date, mentions tinderboxes
[22:55:22] <aatch> brson, the docs are out of date
[22:55:38] <kmc> btw http://livegrep.com/search/linux is really nice
[22:55:54] <toddaaro> bleh, the linux snapshot failed tests
[22:55:56] <graydon> toddaaro: oh, true. well, the procedure's mostly the same, you just look in the build logs of the builders I mentioned
[22:56:00] <brson> i'll try to clean up the snapshot wiki page a bit
[22:56:09] <toddaaro> graydon: ok
[22:56:14] <graydon> toddaaro: are you sure?
[22:56:19] <graydon> it looks like one is still running
[22:56:22] <toddaaro> http://buildbot.rust-lang.org/builders/snap3-linux/builds/488
[22:56:23] <graydon> which rev did you push?
[22:56:37] <toddaaro> I pulled from master, make check'd, then pushed
[22:56:37] <graydon> that's from thursday
[22:56:40] <bblum> brson: uhhhh, i think rterrln!() does not actually do as promised (re not borrowing scheduler) when you are using format specifiers
[22:56:40] <toddaaro> oh
[22:56:40] <brson> does anybody do stage1 snapshots ever? can we remove the code and info about it?
[22:56:45] <graydon> look at the date
[22:56:55] <graydon> http://buildbot.rust-lang.org/tgrid?branch=snap-stage3&refresh=15 shows linux is still building
[22:57:09] <graydon> (see the yellow linux builder in the far right?)
[22:57:18] <toddaaro> ah cool
[22:57:19] <graydon> http://buildbot.rust-lang.org/builders/snap3-linux/builds/491 is your build
[22:57:40] <strcat> kmc: http://lwn.net/Articles/294001/
[22:57:45] <graydon> brson: we can remove stage1 snapshot code. we never did it.
[22:57:58] <graydon> turns out that careful use of cfg(stageN) removes the need
[22:58:16] <strcat> kmc: but I think they ended up doing something else
[22:58:50] <toddaaro> graydon: ok great, thanks for the info
[22:58:55] *** Quits: ecr (Thunderbir@moz-F724119C.uoregon.edu) (Quit: ecr)
[22:58:59] <toddaaro> I'll watch that grid and I should be set
[22:59:04] <kmc> i'm not trying to claim that auto-growing stack mappings are a good idea, just that they exist :)
[22:59:10] <brson> bblum: I believe it should only hit the GC when using %?
[22:59:15] <strcat> kmc: all mappings are auto-growing though
[22:59:16] <brson> but things may have changed
[22:59:23] <bblum> brson: oh, i see, i was using %?
[22:59:30] <bblum> when i could have used %u
[22:59:37] <bblum> sigh, but i like %?.
[22:59:45] *** Joins: infynyxx (infynyxx@DB780A29.749BA1D.DCC373F0.IP)
[22:59:59] *** Quits: devinus (devinus@moz-B4AF84BC.ptr.us.xo.net) (Quit: Textual IRC Client: www.textualapp.com)
[23:00:43] *** Quits: scanlonman (scanlonman@moz-3DC38006.dhcp.trcy.mi.charter.com) (Quit: My MacBook has gone to sleep. ZZZzzzâ€¦)
[23:01:08] <strcat> mmap(NULL, 8392704, PROT_READ|PROT_WRITE, MAP_PRIVATE|MAP_ANONYMOUS|MAP_STACK, -1, 0) = 0x7f9c1b70d000
[23:01:13] <strcat> mprotect(0x7f9c1b70d000, 4096, PROT_NONE) = 0
[23:01:15] <strcat> clone(Process 2517 attached
[23:01:19] <strcat> kmc: that's what glibc does when you spawn a thread
[23:01:46] <strcat> kmc: I thought MAP_GROWSDOWN was what MAP_STACK is
[23:01:51] <strcat> MAP_STACK is the no-op one that tags it as a stack
[23:02:07] <strcat> MAP_GROWSDOWN is what you said, but is deprecated/undefined
[23:02:12] <toddaaro> graydon: looks like my snapshot attempt failed a test too
[23:02:28] <bjz> r? https://github.com/mozilla/rust/pull/8115
[23:02:48] * strcat shrugs
[23:02:55] <toddaaro> graydon: timeout after a hanf on run-pass/path.rs it looks like?
[23:03:28] <graydon> yeah. that happens on that machine with some frequency. really annoying.
[23:03:33] <graydon> re-run just that build
[23:03:41] <graydon> (there's a "rebuild" button)
[23:04:45] <bblum> FOUND IT.
[23:04:50] *** Quits: doener (doener@moz-121949B3.unitymediagroup.de) (Quit: zZzZ)
[23:04:54] <toddaaro> graydon: what page? the grid and the build page both don't have the string rebuild
[23:04:59] <bblum> dammit, it was a stupid thing, too. i was hoping it would be something that makes me feel like a complete champ
[23:05:04] <graydon> toddaaro: the build page
[23:05:08] <bblum> but instead i want my two hours back :P
[23:05:09] <graydon> http://buildbot.rust-lang.org/builders/snap3-linux/builds/491
[23:05:11] *** Joins: jclements (jclements@moz-7782C71D.ngn.east.myfairpoint.net)
[23:05:26] <graydon> toddaaro: ^^
[23:05:28] <sully> ok, so, what is the --lib flag actually for
[23:05:38] <graydon> sully: building a library
[23:05:38] <sully> libraries are supposed to have a directive in them that says they are libraries, right?
[23:06:00] <bblum> sully: i believe it can be missing
[23:06:07] <bblum> no, wait
[23:06:16] <bblum> i think you do need crate_type = lib
[23:06:20] <graydon> yes, but --lib forces it. it's equivalent to turning on that directive.
[23:06:21] <strcat> so I think we're implementing raw pointers quite wrong
[23:06:33] <strcat> by making offsets a safe operation, we've made them very slow
[23:06:41] <strcat> since they can't use inbounds GEP
[23:06:52] <graydon> hm?
[23:07:01] <graydon> "safe" in what sense?
[23:07:08] <graydon> it's just an arithmetic operation
[23:07:12] <graydon> how would it be unsafe?
[23:07:14] <strcat> GEP that overflows is undef behaviour if it's inbounds
[23:07:27] <strcat> graydon: dereferencing a pointer that ever wrapped or was derived from 0 is undef behaviour
[23:07:39] <sully> (I ask because I want to make the compiler warn or error or something -o is used on a library, but I'm not sure the best place to do t his)
[23:07:41] <toddaaro> graydon: ohhh, there is a log in button
[23:07:45] <strcat> unless you use inttoptr, because inttoptr throws away all aliasing info
[23:07:47] <toddaaro> graydon: what does one do to log in?
[23:07:48] <strcat> *all* aliasing info
[23:07:59] <strcat> therefore LLVM cannot optimize our loops
[23:07:59] <graydon> toddaaro: give 'rust' / 'rust' as name/pw
[23:08:17] *** Quits: Jesse (jruderman@moz-BBE3ABD.mv.mozilla.com) (Ping timeout)
[23:08:24] <graydon> sully: in the driver and/or the link phase
[23:08:28] <strcat> if you have a really simple loop starting at an index, and zeroing a certain length
[23:08:31] <graydon> sully: -o and libraries is an old, old bug
[23:08:37] <strcat> it will optimize to a memset if you use pointer arithmetic
[23:08:39] <brson> ok I updated the snapshot wiki page to closer reflect reality
[23:08:42] <strcat> but we use inttoptr so it's 5x slower
[23:08:55] <strcat> we actually *don't have* pointer arithmetic
[23:09:07] <toddaaro> graydon: ok great, rebuilding now
[23:09:16] <graydon> strcat: I'm sorry, I'm .. not clear on what you mean by undef behavior. in C or in LLVM?
[23:09:19] <sully> graydon: yeah, I got triaged it this week, and it seems easy
[23:09:20] <strcat> graydon: LLVM
[23:09:40] <toddaaro> graydon: how many snapshots am I waiting on? all 25 in the grid or is it a subset?
[23:09:42] <graydon> strcat: so what happens to LLVM if you do inboundsgep and it overflows?
[23:09:55] <strcat> graydon: undef behaviour to actually overflow
[23:09:55] *** Parts: steven_is_false (user@C5B76363.1FF1EBF8.1ECA502.IP) (ERC Version 5.3 (IRC client for Emacs))
[23:09:59] <graydon> toddaaro: you're waiting on one snapshot. the rebuild of the one that timed out.
[23:10:09] <strcat> it's always undef behaviour to deref after overflow, but without inbounds GEP the overflow itself isn't undefined
[23:10:09] <graydon> toddaaro: the linux one
[23:10:23] <toddaaro> graydon: that is the one rebuilding, but how many do I need to put in the snapshots text file
[23:10:51] <graydon> toddaaro: one for each platform. 6. same as every other stanza in snapshots.txt.
[23:11:05] <graydon> 2 OSX, 2 linux, 1 bsd and 1 windows
[23:11:09] <strcat> graydon: there are aliasing rules for LLVM pointers, they aren't just addresses
[23:11:21] <strcat> graydon: http://llvm.org/docs/LangRef.html#pointer-aliasing-rules
[23:11:32] <strcat> but when we use inttoptr, it discards all aliasing information
[23:11:35] <graydon> strcat: I am not understanding the problem because I don't get what we do.
[23:11:44] <graydon> we do inttoptr, +, ptrtoint?
[23:11:48] <strcat> graydon: yes
[23:11:54] <graydon> and we should be doing gep, or inboundsgep?
[23:12:07] <strcat> graydon: well, I will switch to GEP, but I think we should be using inboundsgep
[23:12:15] <strcat> which would mean + and - on raw ptrs would be unsafe ops
[23:12:17] <graydon> why not switch to inboundsgep then?
[23:12:29] <sam113101> IÂ don't understand boxes ;_;
[23:12:44] <strcat> graydon: there's no real negative except that we can't keep treating raw pointers as integers
[23:12:54] <strcat> you could still cast as uint, + and cast back
[23:12:55] <strcat> in safe code
[23:13:12] <graydon> I'm afraid I don't get how _arithmetic_ ever becomes an unsafe operation
[23:13:23] <graydon> you aren't loading anything from memory
[23:13:24] <jdm> is there any kind of iterator that shows you the current element and the next one
[23:13:27] *** Joins: Kruppe (user@moz-E150F49F.cpe.net.cable.rogers.com)
[23:13:30] <jdm> or the optional next one?
[23:13:36] <strcat> graydon: yeah but it's the LLVM/C undefined concept
[23:13:49] <strcat> graydon: it uses the fact that it knows overflow cannot happen (due to being undefined) to optimize
[23:14:13] <strcat> if it sees...
[23:14:31] <strcat> if foo() { INT_MAX + 1 } else { bar() } in C
[23:14:39] <strcat> it could optimize that to foo(); bar()
[23:14:50] <strcat> this is a similar situation
[23:14:59] <strcat> LLVM pointers aren't really just addresses, they have semantics
[23:15:06] <strcat> graydon: http://llvm.org/docs/LangRef.html#pointer-aliasing-rules
[23:15:20] <strcat> A pointer value formed by an inttoptr is based on all pointer values that contribute (directly or indirectly) to the computation of the pointerâ€™s value.
[23:15:24] <strcat> this is what we're being hit by
[23:15:30] <strcat> it ruins alias analysis
[23:15:34] <graydon> I am reading and re-reading that. I do not get it at all.
[23:15:49] <toddaaro> brson: https://github.com/mozilla/rust/pull/8116 PR finally up!
[23:16:16] <strcat> graydon: well they don't actually implement analysis for inttoptr atm, so basically inttoptr means "treat this integer as an address, disregard all aliasing restrictions and any information you know about"
[23:16:41] <strcat> graydon: one example is that if you have a pointer to object A, you can't use GEP to set it to a pointer to object B and deref it
[23:17:08] <strcat> unless object B is inside object A
[23:17:35] <strcat> for example...
[23:17:40] <strcat> [[1, 2, 3], [4, 5, 6]]
[23:17:47] <strcat> in-memory, that's laid out as [1, 2, 3, 4, 5, 6]
[23:17:48] <graydon> but if it has no idea what a thing points to..
[23:17:56] <strcat> but it's undefined behaviour to index past the end of the first array into the second
[23:18:02] <strcat> due to aliasing rules
[23:18:16] <graydon> does it only become undefined if it can prove, via aliasing rules, knowledge that a pointer has gone past the end of an object?
[23:18:20] <jdm> ok, is there an iterator that also provides an index?
[23:18:25] <graydon> (like do I have the information dependence backwards?)
[23:18:28] <strcat> jdm: .enumerate() ?
[23:18:30] <aatch> jdm, enumerate
[23:18:38] <graydon> *T tells you nothing about what object it's pointing into
[23:18:48] <strcat> graydon: it does, LLVM has rules placed on it
[23:18:49] <jdm> thanks
[23:19:10] <strcat> graydon: it sees you take an address, and from then on the pointer can only be used to look into the object you took an address from
[23:19:23] <graydon> right but what if you pass this address through 17 function calls
[23:19:33] <graydon> what if you got it from the outside world, from C?
[23:19:40] <graydon> we don't always get pointers from convenient places
[23:19:43] *** Quits: bytbox (s@moz-DC83764A.washdc.fios.verizon.net) (Input/output error)
[23:19:44] <strcat> graydon: if it can't see where it comes from, it aliases with all pointers
[23:19:52] <strcat> but often it sees where it comes from
[23:19:56] <graydon> ok. so then is any increment undefined?
[23:19:57] <graydon> or ..
[23:20:09] * graydon scratches head
[23:20:17] <strcat> graydon: with inbounds, increment past the end is undef
[23:20:19] <cmr> nmatsakis: ping
[23:20:20] <strcat> without it, only deref is
[23:20:24] *** Joins: Jesse (jruderman@moz-BBE3ABD.mv.mozilla.com)
[23:20:40] <graydon> nope. can't follow the logic.
[23:20:44] <strcat> graydon: :)
[23:20:45] <graydon> it's too complicated for me
[23:20:58] <strcat> graydon: you're just thinking about it wrong ;p
[23:21:27] <graydon> ok
[23:21:31] <strcat> [[1, 2, 3], [4, 5, 6]] is typed as an array of arrays in LLVM
[23:22:23] <strcat> so if you index into one, it considers that pointer *based* on the array
[23:22:23] *** Quits: engla_ (engla@moz-DBD1D96E.cust.bredbandsbolaget.se) (Connection reset by peer)
[23:22:30] <kmc> strcat: http://pastebin.mozilla.org/2740393 this is what I mean when I say that the [stack] mapping auto-grows in a way different from other mappings
[23:22:34] <strcat> and it can't be used to look into anything not based on the array
[23:23:59] <strcat> kmc: but look at where the stack mapping comes from - it's just mmap
[23:24:33] <kmc> not that one
[23:24:52] <strcat> the first stack is given to you by your parent task
[23:25:10] <strcat> it passes you a pointer to where your stack ends
[23:25:29] <strcat> but if you're a thread, your parent mmap'ed a block and passed you a pointer to the end
[23:25:59] *** Quits: infynyxx (infynyxx@DB780A29.749BA1D.DCC373F0.IP) (Client exited)
[23:26:01] <strcat> otherwise I think you get the same address as the parent
[23:26:20] <kmc> sure, new threads may be different, I am talking specifically about the mapping listed as "[stack]" in /proc/self/maps
[23:26:53] <strcat> kmc: it's just not reporting it to you in the same way as the others
[23:28:12] <strcat> spawn thread (parent calls mmap, your stack is the ptr to the end of the block) -> fork from that thread (inherit address space + start of stack from parent, but it's copy-on-write)
[23:29:13] <strcat> I don't have any idea what it does with that address space on exec
[23:29:22] <strcat> as in where the new address space comes form
[23:29:24] <strcat> from*
[23:30:02] *** Joins: dbaupp (Thunderbir@moz-712A1135.lns20.syd6.internode.on.net)
[23:30:21] <sam113101> I don't understand ~ and @ and &
[23:30:46] <strcat> kmc: afaik the [stack] address is just from the stack parameter to clone
[23:31:02] *** Quits: alelos (alelos@moz-639D733A.adsl.online.nl) (Quit: WeeChat 0.4.1)
[23:31:06] <strcat> from when you spawn a thread, pointing to the end of the block
[23:31:17] <strcat> and if it's from forking instead, it's just inherited
[23:31:44] *** Joins: infynyxx (infynyxx@DB780A29.749BA1D.DCC373F0.IP)
[23:32:05] <strcat> although I think you can pass a stack address *and* CLONE_VM
[23:32:57] *** Joins: paupau (textual@FFAF02D4.F5573215.F20F0C5A.IP)
[23:33:19] *** Quits: strcat (strcat@moz-54F7FD49.cpe.net.cable.rogers.com) (Quit: brb)
[23:34:50] *** Joins: steven_is_false (user@C5B76363.1FF1EBF8.1ECA502.IP)
[23:35:11] <steven_is_false> Hi! Suppose I want to set a break point on the task failure function behind the fail! macro. How would I do that?
[23:36:12] *** Quits: jmgrosen (jmgrosen@moz-848F6087.sb.sd.cox.net) (Quit: jmgrosen)
[23:37:07] <mcpherrin> steven_is_false: a few days ago, Luqman asked the same thing, and log grep indicates:
[23:37:10] <mcpherrin> dbaupp
[23:37:11] <mcpherrin> Luqman: if you dump the symbols out of libstd, you should be able to break on `_ZN2rt4task14__extensions__10meth_...12begin_unwind16_...` (you'll have to fill in the dots with the appropriate thing for your build.
[23:38:03] <steven_is_false> Uggh, that's awful.
[23:38:07] <steven_is_false> Thanks though.
[23:38:22] <dbaupp> mcpherrin, steven_is_false: that's only for newrt
[23:38:33] <dbaupp> steven_is_false: if you're using the old rt, then breaking on `upcall_fail` should work.
[23:38:35] <Luqman> steven_is_false: mcpherrin i was asking for the new runtime. if you're not using it breaking on upcall_fail is good enough
[23:38:45] <bblum> brson: THIS IS SO WEIRD, can i get your eyes for a sec
[23:38:50] <steven_is_false> Oh that's great then!
[23:39:33] <mcpherrin> Luqman: dbaupp: ah I haven't been following new/old rt; I thought people were generally using newrt now
[23:39:42] * mcpherrin has a real job now ;(
[23:39:58] <dbaupp> mcpherrin: not quite yet, it still doesn't support file-io
[23:40:02] *** Joins: enix (enix@moz-A50569DD.c3-0.slvr-ubr1.lnh-slvr.md.cable.rcn.com)
[23:40:02] <brson> steven_is_false: rust_task_fail for oldrt rust_begin_unwind for newrt
[23:40:12] * brson should probably just name them both the same
[23:40:24] <dbaupp> brson: doesn't the former get mangled?
[23:40:28] <mark_edward> how would you guys debug rust
[23:40:32] <brson> dbaupp: no, those are both C functions
[23:40:41] <mcpherrin> mark_edward: gdb and prints :)
[23:40:58] <paupau> woo jobs
[23:41:13] *** Joins: SiegeLord (sl@moz-CAF07B4C.hsd1.ma.comcast.net)
[23:41:14] <brson> bblum: ok i'll be up in a bit
[23:41:22] <mark_edward> gdb is useless. it doesn't catch failure like it does with C/C++ so when there's an assert error everything dies and i can't see what caused it
[23:42:02] *** Quits: steven_is_false (user@C5B76363.1FF1EBF8.1ECA502.IP) (Client exited)
[23:42:09] <bblum> brson: oh, don't need you in person
[23:42:17] <bblum> also have one more compile to run before i'm sure it's weird
[23:42:31] <dbaupp> mark_edward: put a breakpoint on the appropriate function that brson mentioned ^
[23:42:37] <brson> bblum: ok, well my eyes are at your disposal
[23:43:03] <mark_edward> dbaupp: what function is that?
[23:43:18] <olsonjeffery> does breaking on upcall_fail not work, still?
[23:43:29] <olsonjeffery> no longer work, i should say
[23:43:53] <bblum> brson: so i am looking into the weird crashes i got when adding that invariant store()/assert in block_on and recv_ready
[23:44:18] <bblum> brson: i discovered that the place that i put the (*self.packet()).state.store(STATE_ONE) matters whether or not it segfaults in the shared_port tests
[23:44:21] <bblum> http://pastebin.mozilla.org/2740480
[23:44:50] <bblum> any reason why that would matter occur to you offhand?
[23:45:11] <brson> olsonjeffery: upcall_fail works too
[23:45:38] *** Quits: henrikhodne (henrikhodn@moz-87E975F1.dsl.static.sonic.net) (Ping timeout)
[23:45:41] <dbaupp> mark_edward: "rust_task_fail for oldrt rust_begin_unwind for newrt"
[23:46:14] <bblum> brson: rather, more precise info -- after the enqueue_blocked_task(), the return value of self.packet() can nondeterministically be NULL
[23:46:25] *** Quits: Florob (Florob@moz-39532932.de) (Client exited)
[23:46:46] <mark_edward> dbaupp: gdb says neither of those functions exist
[23:46:57] *** Quits: jorendorff (jorendorff@moz-2F32ACA3.hsd1.tn.comcast.net) (Quit: jorendorff)
[23:47:00] <bblum> brson: other than not knowing yet why that happens, i've got the assertion issue apparently solved
[23:47:25] <dbaupp> mark_edward: they only exist after the shared libraries get loaded
[23:47:32] <brson> bblum: the first one looks like it's giving up control over the task so another thread can immediately pick it up and run it, possibly deleting that state buffer, at a guess
[23:47:46] <dbaupp> mark_edward: so either say 'y' to the prompt it gives you, or run the program once and then do it.
[23:48:00] <mark_edward> dbaupp: ah i see. thanks for the help
[23:48:00] <bblum> it's also occasionally 4 instead of NULL
[23:48:12] <bblum> suggests to me i am seeing heap metadata
[23:48:45] *** Joins: engla (engla@moz-DBD1D96E.cust.bredbandsbolaget.se)
[23:49:25] <bblum> oh, hmmm
[23:49:26] <bblum> hm
[23:50:01] *** Quits: true_droid (Adium@moz-123FD9B8.beck.volia.net) (Quit: Leaving.)
[23:50:14] *** Joins: int3_ (int3_@92E1D5A1.C6888CE2.F82A4608.IP)
[23:50:15] * brson deleting the wiki page on intrinsics since they are better documented in std now
[23:51:04] * brson looking for more old wiki cruft to delete
[23:52:16] *** Joins: strcat (strcat@moz-54F7FD49.cpe.net.cable.rogers.com)
[23:53:32] *** Joins: alisdair (textual@moz-EA60A466.dedicated.allstream.net)
[23:58:15] <sam113101> what's ..3 in let numbers: [int, ..3] = [1, 2, 3];?
[23:58:33] <sp3d> notation for a fixed-length (3 here) vector type
[23:59:01] *** Quits: int3_ (int3_@92E1D5A1.C6888CE2.F82A4608.IP) (Client exited)
[23:59:05] <sam113101> wouldn't [int] do the same?
[23:59:05] <sp3d> also notation for repeated values:
[23:59:12] <cmr> sam113101: [int] isn't a type.
[23:59:13] <sp3d> rusti: [0, ..5]
[23:59:14] -rusti- [0, 0, 0, 0, 0]
[23:59:49] <cmr> sam113101: &[int] is a slice of arbitrary length (non-owned, non-growable), ~[int] is growable

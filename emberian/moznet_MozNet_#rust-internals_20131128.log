[00:00:58] <jack> pcwalton: ^
[00:01:08] <jack> perhaps i should punt on gcc compatibility and just use --dep-info
[00:01:12] <pcwalton> jack: yeah, just do that
[00:01:15] <pcwalton> punt on gcc compat
[00:01:56] <ChrisMorgan> Is that intended to be interpreted as multiple short options, equivalent to -M -M -D; an option with argument, -M MD, or a long option as though it were --MMD?
[00:02:10] <jack> it's a single option with no arguments.
[00:02:16] <jack> (in gcc anyway)
[00:04:31] <pcwalton> GCC violates the GNU option standards a lot
[00:05:13] <strcat> not as much as tar
[00:05:28] <strcat> or ps :)
[00:05:37] <strcat> that's not gnu though
[00:07:44] *** Joins: pnkfelix (pnkfelix@moz-43495417.fbx.proxad.net)
[00:09:32] *** Quits: pnkfelix (pnkfelix@moz-43495417.fbx.proxad.net) (Ping timeout)
[00:15:34] *** Quits: jdm (jdm@CAB30FBD.8F96AEA7.2D179A7D.IP) (Quit: Lost terminal)
[00:17:47] <jack> gcc probably predates the standards :)
[00:18:12] *** Joins: Sharp (Sharp@moz-780FECDA.washdc.fios.verizon.net)
[00:18:38] *** Quits: Sharp (Sharp@moz-780FECDA.washdc.fios.verizon.net) (Quit: Sharp)
[00:18:52] *** Joins: Sharp (Sharp@moz-780FECDA.washdc.fios.verizon.net)
[00:25:14] <aatch> BUT IT'S THE GNU C COMPILER ARGGHABNIVWEVA
[00:27:02] <tjc> aatch: i'm sure they will accept patches if you want to make gcc standards-compliant ;-)
[00:27:18] <tjc> If you have better things to do, though, it's understandable. (Like having a root canal)
[00:27:50] *** Quits: Sharp (Sharp@moz-780FECDA.washdc.fios.verizon.net) (Quit: Sharp)
[00:28:04] *** Joins: Sharp (Sharp@moz-780FECDA.washdc.fios.verizon.net)
[00:29:29] *** Quits: Sharp (Sharp@moz-780FECDA.washdc.fios.verizon.net) (Quit: Sharp)
[00:31:22] *** Quits: Jesse (jruderman@moz-5973C6FA.oc.oc.cox.net) (Quit: Jesse)
[00:34:26] *** Quits: Axord (xord@moz-C0D5F15A.lsanca.dsl-w.verizon.net) (Quit: I'm sure it's perfectly safe)
[00:35:37] *** Quits: pcwalton (pcwalton@moz-C07D5168.p2p.sfo1.mozilla.com) (Quit: pcwalton)
[00:40:04] *** Joins: ghrust (ghrust@1E8607E8.6A2AE50.F3114085.IP)
[00:40:05] <ghrust> 01[13rust01] 15bors merged 06auto into 06master: 02http://git.io/cOzevQ
[00:40:05] *** Parts: ghrust (ghrust@1E8607E8.6A2AE50.F3114085.IP) ()
[00:40:23] *** Joins: Jesse (jruderman@moz-5973C6FA.oc.oc.cox.net)
[00:47:15] *** Joins: ghrust (ghrust@2EE61FCC.6A2AE50.F3114085.IP)
[00:47:15] <ghrust> 01[13rust01] 15bors pushed 0 new commits to 06auto: 02http://git.io/8pZQzw
[00:47:15] *** Parts: ghrust (ghrust@2EE61FCC.6A2AE50.F3114085.IP) ()
[00:47:19] *** Joins: ghrust (ghrust@C8693FCB.6A2AE50.F3114085.IP)
[00:47:19] <ghrust> 01[13rust01] 15bors pushed 4 new commits to 06auto: 02http://git.io/WjSV3g
[00:47:19] <ghrust> 13rust/06auto 14e9ab9bf 15Florian Zeitz: Update unicode.py to reflect language changes
[00:47:19] <ghrust> 13rust/06auto 14c234614 15Florian Zeitz: Update Unicode data to version 6.3
[00:47:20] <ghrust> 13rust/06auto 14dfe38db 15Florian Zeitz: Fix handling of upper/lowercase, and whitespace
[00:47:22] *** Parts: ghrust (ghrust@C8693FCB.6A2AE50.F3114085.IP) ()
[00:56:16] *** kimundi is now known as zz_kimundi
[00:59:19] *** Quits: tjc (tjc@moz-7EE2AFFC.hfc.comcastbusiness.net) (Quit: My MacBook Pro has gone to sleep. ZZZzzz‚Ä¶)
[00:59:42] <cmr> Or shaving yaks!
[01:01:56] <aatch> cmr, my yaks are not merely shavved, they are exquisitely styled.
[01:02:02] <aatch> shaved*
[01:05:14] <ktt3ja> if I have `impl Bar for Foo { fn bar() {} }` for some Bar trait, when I encounter `bar`, would `bar` be a node_method or node_trait_method?
[01:07:25] <aatch> ktt3ja, I'm not sure, but I'd say probably node_method.
[01:12:39] <aatch> ktt3ja, so from the looks of it node_trait_method is only for "required" trait methods.
[01:17:08] <ktt3ja> aatch: I think it can be for both required and provided
[01:17:18] <ktt3ja> node_trait_method holds a trait_method: https://github.com/mozilla/rust/blob/master/src/libsyntax/ast_map.rs#L111
[01:17:26] <ktt3ja> and trait_method is an enum for both: https://github.com/mozilla/rust/blob/master/src/libsyntax/ast.rs#L757-L760
[01:18:07] <aatch> ktt3ja, hmm, well at any rate, a method in an impl is node_method
[01:18:27] <ktt3ja> ok
[01:18:43] * aatch hasn't looked at that code in a while
[01:21:29] *** Quits: dbaupp (Thunderbir@898216D2.D5A1DCF.37681C44.IP) (Ping timeout)
[01:24:04] *** Joins: dbaupp (Thunderbir@898216D2.D5A1DCF.37681C44.IP)
[01:35:01] <ktt3ja> what's the difference between method_static, method_param, and method_object? https://github.com/mozilla/rust/blob/master/src/librustc/middle/typeck/mod.rs#L94-L104
[01:51:39] <aatch> ktt3ja, well the first one is when we know the exact method to call at compile time, and the last one is a method call on a trait object.
[01:52:06] <aatch> The middle suggests something like `T::method` where `T` is a bounded type param, but I didn't think you could do that...
[01:55:34] <aatch> Hmm, I think it might be for the case `fn foo<T:Foo>(a:T) { a.method() }`
[01:56:08] <ktt3ja> what would a method call on a trait object look like?
[01:56:56] <aatch> Which would mean it would be these three cases: `fn foo(a: T) { a.method() }`, `fn foo<T:Foo>(a:T) { a.method() }` and `fn foo(a: ~Foo) { a.method() }`
[01:57:06] *** Joins: tjc (tjc@moz-6EB4E533.dsl.tsoft.com)
[01:57:06] *** ChanServ sets mode: +o tjc
[01:57:08] <aatch> respectively.
[01:58:14] *** Joins: brson (brson@63DCD950.E4213B29.318DADF5.IP)
[01:58:14] *** ChanServ sets mode: +qo brson brson
[02:02:21] *** Quits: tjc (tjc@moz-6EB4E533.dsl.tsoft.com) (Quit: Textual IRC Client: www.textualapp.com)
[02:04:13] <ktt3ja> aatch: thanks
[02:04:16] <aatch> I don't know enough about the type checker to know the reasoning behind having `method_static` and `method_param` (assuming I've even got them right), but I do know that some `method_object` calls aren't allowed.
[02:04:55] <aatch> Specifically, ones that use the `Self` type (since that is unknown at compile time by definition)
[02:06:26] <aatch> Looks like method_param is mostly a convenience (so we can produce better error messages)
[02:11:05] *** nrc is now known as nrc|afk
[02:21:09] <ktt3ja> for the following code snippet: http://kib2.free.fr/pastebin/view_paste.php?id=141 ... when I encounter the ExprMethodCall `foo.bar2()` on a typeck::method_map, does it give me the def id of some "fake" method?
[02:21:24] <ktt3ja> because this suggests that there's a "fake" method somewhere: https://github.com/mozilla/rust/blob/master/src/librustc/middle/ty.rs#L319
[02:24:00] <aatch> ktt3ja, I'm not sure, however if I had to guess, I'd say you're right.
[02:25:23] <ktt3ja> oh well, this is the only lead I have, so worth a try
[02:27:00] *** Joins: ghrust (ghrust@24260B07.6A2AE50.F3114085.IP)
[02:27:00] <ghrust> 01[13rust01] 15bors merged 06auto into 06master: 02http://git.io/WjSV3g
[02:27:00] *** Parts: ghrust (ghrust@24260B07.6A2AE50.F3114085.IP) ()
[02:32:31] *** Joins: ghrust (ghrust@24260B07.6A2AE50.F3114085.IP)
[02:32:31] <ghrust> 01[13rust01] 15bors pushed 0 new commits to 06auto: 02http://git.io/ld3T6Q
[02:32:31] *** Parts: ghrust (ghrust@24260B07.6A2AE50.F3114085.IP) ()
[02:32:33] *** Joins: ghrust (ghrust@2EE61FCC.6A2AE50.F3114085.IP)
[02:32:33] <ghrust> 01[13rust01] 15bors pushed 2 new commits to 06auto: 02http://git.io/mO7Neg
[02:32:33] <ghrust> 13rust/06auto 141686bfa 15Alex Crichton: Use the native tls implementation on android...
[02:32:33] <ghrust> 13rust/06auto 14db5b51a 15bors: auto merge of #10687 : alexcrichton/rust/issue-10686, r=thestinger...
[02:32:34] *** Parts: ghrust (ghrust@2EE61FCC.6A2AE50.F3114085.IP) ()
[02:53:03] *** Quits: andrew-__ (andrew-d_w@moz-9A2674DF.dsl.static.sonic.net) (Quit: Leaving...)
[02:55:14] *** Quits: dbaupp (Thunderbir@898216D2.D5A1DCF.37681C44.IP) (Ping timeout)
[02:57:49] *** Joins: Sharp (Sharp@moz-780FECDA.washdc.fios.verizon.net)
[03:04:53] *** Joins: dbaupp (Thunderbir@898216D2.D5A1DCF.37681C44.IP)
[03:09:18] <jack> ok, makefile deps now work, but out of tree builds don't
[03:09:48] <jack> apparently all the filenames are relative to something and i need to prepend that path
[03:10:43] <jack> oh, it's just my include_str! fix that's wrong.
[03:11:59] <jack> is rustc's working dir the output dir?
[03:14:16] <jack> nm. res_rel_filename() seems to be what i need
[03:14:20] <Luqman> jack: they're not necessarily the same no?
[03:14:30] <Luqman> since you can pass out-dir
[03:14:41] <cmr> jack: the working dir is the dir the crate root is in I thought
[03:15:23] *** Joins: summerlight (summerligh@327FC32B.2C956A45.501EFF44.IP)
[03:22:02] *** Quits: zz_kimundi (kimundi@moz-BF21A096.dip0.t-ipconnect.de) (Ping timeout)
[03:25:39] *** Joins: zz_kimundi (kimundi@moz-8CF1B152.dip0.t-ipconnect.de)
[03:25:40] *** zz_kimundi is now known as kimundi
[03:29:57] <jack> there we go: https://github.com/mozilla/rust/pull/10698
[03:39:30] *** Quits: ktt3ja (Mibbit@moz-54586A12.washdc.fios.verizon.net) (Quit: http://www.mibbit.com ajax IRC Client)
[03:40:50] *** Quits: notmatt (notmatt@moz-9FB2565E.vc.shawcable.net) (Client exited)
[03:42:13] *** Joins: ghrust (ghrust@1E8607E8.6A2AE50.F3114085.IP)
[03:42:14] <ghrust> 01[13rust01] 15bors merged 06auto into 06master: 02http://git.io/mO7Neg
[03:42:14] *** Parts: ghrust (ghrust@1E8607E8.6A2AE50.F3114085.IP) ()
[03:47:15] *** Joins: ghrust (ghrust@79968228.6A2AE50.F3114085.IP)
[03:47:15] <ghrust> 01[13rust01] 15bors pushed 0 new commits to 06auto: 02http://git.io/Hmkf1g
[03:47:15] *** Parts: ghrust (ghrust@79968228.6A2AE50.F3114085.IP) ()
[03:47:20] *** Joins: ghrust (ghrust@C8693FCB.6A2AE50.F3114085.IP)
[03:47:20] <ghrust> 01[13rust01] 15bors pushed 2 new commits to 06auto: 02http://git.io/DWt17g
[03:47:20] <ghrust> 13rust/06auto 1426ba64d 15g3xzh: Add benchmark tests to path/posix...
[03:47:20] <ghrust> 13rust/06auto 1468e3292 15bors: auto merge of #10691 : g3xzh/rust/benchm, r=cmr...
[03:47:20] *** Parts: ghrust (ghrust@C8693FCB.6A2AE50.F3114085.IP) ()
[03:54:40] *** Quits: brson (brson@63DCD950.E4213B29.318DADF5.IP) (Quit: leaving)
[04:18:54] *** Quits: Jesse (jruderman@moz-5973C6FA.oc.oc.cox.net) (Ping timeout)
[04:23:40] *** Joins: ktt3ja (Mibbit@moz-54586A12.washdc.fios.verizon.net)
[04:24:25] *** Quits: Sharp (Sharp@moz-780FECDA.washdc.fios.verizon.net) (Quit: Sharp)
[04:33:40] *** Joins: Sharp (Sharp@moz-780FECDA.washdc.fios.verizon.net)
[04:51:12] *** Joins: notmatt (notmatt@moz-9FB2565E.vc.shawcable.net)
[04:53:49] *** Quits: notmatt (notmatt@moz-9FB2565E.vc.shawcable.net) (Ping timeout)
[04:55:59] *** Joins: eddyb (eddy@EBE709F3.F7C96DA2.FCAAE698.IP)
[04:57:03] *** Joins: ghrust (ghrust@1E8607E8.6A2AE50.F3114085.IP)
[04:57:04] <ghrust> 01[13rust01] 15bors merged 06auto into 06master: 02http://git.io/DWt17g
[04:57:04] *** Parts: ghrust (ghrust@1E8607E8.6A2AE50.F3114085.IP) ()
[04:57:17] *** Joins: notmatt (notmatt@moz-9FB2565E.vc.shawcable.net)
[04:57:18] *** Quits: notmatt (notmatt@moz-9FB2565E.vc.shawcable.net) (Client exited)
[04:57:59] *** Joins: ghrust (ghrust@C8693FCB.6A2AE50.F3114085.IP)
[04:57:59] <ghrust> 01[13rust01] 15alexcrichton fast-forwarded 06snap-stage3 from 1401b5381 to 14db5b51a: 02http://git.io/QB_6yw
[04:57:59] *** Parts: ghrust (ghrust@C8693FCB.6A2AE50.F3114085.IP) ()
[05:02:56] *** Joins: ghrust (ghrust@24260B07.6A2AE50.F3114085.IP)
[05:02:56] <ghrust> 01[13rust01] 15bors pushed 0 new commits to 06auto: 02http://git.io/dbm2uw
[05:02:56] *** Parts: ghrust (ghrust@24260B07.6A2AE50.F3114085.IP) ()
[05:02:56] *** Joins: ghrust (ghrust@2EE61FCC.6A2AE50.F3114085.IP)
[05:02:57] <ghrust> 01[13rust01] 15bors pushed 2 new commits to 06auto: 02http://git.io/gTrqtA
[05:02:57] <ghrust> 13rust/06auto 1479ed898 15klutzy: rustdoc: Use new ||/proc syntax
[05:02:57] <ghrust> 13rust/06auto 1442ea44b 15bors: auto merge of #10694 : klutzy/rust/rustdoc-closure, r=alexcrichton
[05:02:57] *** Parts: ghrust (ghrust@2EE61FCC.6A2AE50.F3114085.IP) ()
[05:23:33] <cmr> /home/cmr/hacking/rust/src/librustc/middle/typeck/check/mod.rs:4015:66: 4015:69 error: mismatched types: expected `syntax::ast::DefId` but found `BUG[0u]` (expected struct syntax::ast::DefId but found type parameter)
[05:23:36] <cmr> That's a new one for me
[05:25:58] <Eridius> nice
[05:27:46] <cmr> I'm using a macbook (air) for the first time... with iterm2 and a few hours to acclimate, it's pretty nice; though I'm just using it to SSH into my beefier desktop and browse the web...
[05:27:55] <Eridius> why are you using iTerm2?
[05:29:17] <cmr> it wasn't page upping correctly through ssh + tmux
[05:29:24] <cmr> It was scrolling up my terminal rather than my irc chatlog
[05:29:39] <Eridius> shift-pgup
[05:29:49] <cmr> so shift-fn-uparrow?
[05:29:58] <Eridius> ..sure
[05:31:54] <cmr> that worked! thanks :)
[05:32:12] <Eridius> :D
[05:34:31] *** Joins: jdm (jdm@moz-78156D60.dsl.teksavvy.com)
[05:36:50] *** Quits: strcat (strcat@moz-54F7FD49.cpe.net.cable.rogers.com) (Quit: WeeChat 0.4.2)
[05:41:57] <cmr> acrichto: ping
[05:43:39] <cmr> Or, anyone: how do I construct a struct in trans? https://github.com/cmr/rust/commit/96498ca5af95ded17a80b6bdeb86f8dc1eab12ca#diff-d1609daffc6be5b1e5e7158c0f8109deR293 specifically
[05:57:24] *** Quits: dbaupp (Thunderbir@898216D2.D5A1DCF.37681C44.IP) (Ping timeout)
[06:07:45] *** Joins: notmatt (notmatt@moz-9FB2565E.vc.shawcable.net)
[06:11:15] *** Quits: notmatt (notmatt@moz-9FB2565E.vc.shawcable.net) (Ping timeout)
[06:37:54] *** Joins: Jesse (jruderman@moz-5973C6FA.oc.oc.cox.net)
[06:39:50] *** Quits: Jesse (jruderman@moz-5973C6FA.oc.oc.cox.net) (Quit: Jesse)
[06:46:31] <jack> who is DaGenix in IRC?
[06:51:02] <cmr> jack: enix
[07:02:23] *** Joins: dbaupp (Thunderbir@moz-3BE4086E.lns20.syd6.internode.on.net)
[07:13:03] *** Joins: notmatt (notmatt@moz-9FB2565E.vc.shawcable.net)
[07:17:47] *** Joins: pnkfelix (pnkfelix@moz-43495417.fbx.proxad.net)
[07:21:40] *** Quits: pnkfelix (pnkfelix@moz-43495417.fbx.proxad.net) (Quit: Leaving.)
[07:26:46] *** Joins: ghrust (ghrust@DE823A67.6A2AE50.F3114085.IP)
[07:26:46] <ghrust> 01[13rust01] 15bors merged 06auto into 06master: 02http://git.io/gTrqtA
[07:26:46] *** Parts: ghrust (ghrust@DE823A67.6A2AE50.F3114085.IP) ()
[07:31:14] *** Quits: notmatt (notmatt@moz-9FB2565E.vc.shawcable.net) (Client exited)
[07:32:32] *** Joins: ghrust (ghrust@79968228.6A2AE50.F3114085.IP)
[07:32:32] <ghrust> 01[13rust01] 15bors pushed 0 new commits to 06auto: 02http://git.io/2ZS1Cg
[07:32:33] *** Parts: ghrust (ghrust@79968228.6A2AE50.F3114085.IP) ()
[07:32:40] *** Joins: ghrust (ghrust@C8693FCB.6A2AE50.F3114085.IP)
[07:32:40] <ghrust> 01[13rust01] 15bors pushed 2 new commits to 06auto: 02http://git.io/qTWsYA
[07:32:40] <ghrust> 13rust/06auto 144837d00 15Patrick Walton: libstd: Change `Path::new` to `Path::init`.
[07:32:40] <ghrust> 13rust/06auto 144a4f563 15bors: auto merge of #10697 : pcwalton/rust/path-new, r=pcwalton...
[07:32:40] *** Parts: ghrust (ghrust@C8693FCB.6A2AE50.F3114085.IP) ()
[07:34:33] <cmr> jld: ping
[07:38:30] <cmr> jld: unping
[07:39:33] *** Quits: eddyb (eddy@EBE709F3.F7C96DA2.FCAAE698.IP) (Ping timeout)
[07:39:51] <cmr> ktt3ja: ping
[07:39:53] *** Joins: vky (chatzilla@moz-4F2E17BF.dsl.dynamic.sonic.net)
[07:40:04] *** Joins: eddyb (eddy@EBE709F3.F7C96DA2.FCAAE698.IP)
[07:44:43] <eddyb> cmr: http://huonw.github.io/isrustfastyet/mem/#faf4c93,82d9033 looks similar to my own tests, but it's in the limits of normal variation
[07:44:48] <eddyb> nmatsakis: ping
[07:45:53] <cmr> eddyb: there's not too much variation in the memory data; only source of noise is the code changes to librustc itself.
[07:46:04] <cmr> eddyb: I'd love to expand my tests to more stable code
[07:46:20] <cmr> I think dbaupp would hate me forever for making him do more frontend work right now though :P
[07:46:25] <cmr> dbaupp: when are you on break?
[07:47:32] <dbaupp> cmr: now
[07:47:36] <dbaupp> cmr: what do you want?
[07:47:45] <dbaupp> (and yes, I'll hate you forever :P )
[07:48:09] <cmr> ohh! yay :)
[07:48:15] <cmr> dbaupp: multiple testcases in the memory graph
[07:49:03] <eddyb> cmr: oh. but do you keep stage1 binaries around?
[07:49:06] <dbaupp> cmr: "testcases"
[07:49:07] <dbaupp> ?
[07:49:19] <cmr> dbaupp: like, memory profiles of compiling various different crates
[07:49:24] <cmr> eddyb: I keep stage2 binaries
[07:49:29] <eddyb> cmr: so you can measure differences on the last ten commits or so?
[07:49:31] <cmr> I currently have 1777
[07:49:37] <eddyb> well, stage2 is pretty good for this, too
[07:50:22] <eddyb> I have a monster which type checks and everything, it just has almost nothing to translate
[07:50:38] <eddyb> (because the trait with the humongous default method isn't instantiated)
[07:50:41] <dbaupp> cmr: hm, that may be tricky
[07:50:59] <cmr> going to be a ux nightmare too
[07:51:13] <dbaupp> yup
[07:51:21] <dbaupp> can I punt on that for a while? :P
[07:51:30] <eddyb> cmr: well, can you provide raw data for me to look at, in the meanwhile?
[07:51:32] <cmr> yes
[07:51:37] <cmr> eddyb: certainly
[07:51:40] <cmr> I can even provide graphs!
[07:51:51] <cmr> not nice interactive graohs, though
[07:52:04] <cmr> or, even better, I can give you the script I use to make the graphs and you can do it :P
[07:52:05] * dbaupp can't provide nice interactive graophs either
[07:53:11] <cmr> I've been meaning to overhaul that side of things for a while, just haven't got around to it.
[07:53:40] <cmr> and with the cgroup changes around the corner I can't put it off much longer...
[07:55:33] <eddyb> cmr: https://gist.github.com/eddyb/b802f5bdc4174e0fbf11/raw/98bbbc4b685e58125c455be294b688232adedfdb/arch-x86_16.rs
[07:56:02] <eddyb> I promise it won't use more than 1.6GB of RAM :P
[07:56:08] <cmr> I have plenty
[07:56:16] <cmr> So, do you have any particular commits in mind?
[07:56:35] <dbaupp> eddyb: do you need some more RAM? http://downloadmoreram.com/
[07:56:45] <eddyb> dbaupp: seen that way too many times :P
[07:56:54] <eddyb> idling in #minecraft and whatnot
[07:57:01] <eddyb> cmr: http://huonw.github.io/isrustfastyet/mem/#faf4c93,82d9033 these would be a start
[07:57:21] <eddyb> i.e. my first size-related commit and the one before it
[08:00:58] <eddyb> cmr: if it's not too much trouble, this (for rustc-stage2 and my testcase) would be useful https://github.com/mozilla/rust/pull/10676 - as some kind of proof that my changes are doing something :P
[08:01:19] <cmr> eddyb: sure
[08:01:31] <eddyb> cmr: thanks a lot :D
[08:01:42] <cmr> sorry I haven't been able to do it before now :(
[08:01:48] <cmr> finally on thanksgiving break and can breath
[08:02:07] <eddyb> heh
[08:02:09] <cmr> oaaa
[08:02:13] <cmr> *whoaaa
[08:02:16] <eddyb> what?
[08:02:19] <cmr> 32 bytes for ast_node is great!
[08:03:09] <eddyb> it might be possible to shrink it to 24, but it won't be worth it
[08:03:24] <eddyb> (i.e. there's bigger monsters to kill)
[08:03:44] <cmr> you are aware of the 700MB leak, right?
[08:03:58] <cmr> (well, it's probably a bit more tame with your changes)
[08:04:18] <eddyb> after trans?
[08:04:26] <cmr> yeah
[08:04:43] <cmr> http://i.imgur.com/arm3Xbu.png
[08:05:38] <eddyb> nmatsakis said that arenas would easily solve that
[08:05:45] <cmr> once we have them, yea.
[08:06:19] <cmr> well...
[08:06:21] <cmr> not really, no.
[08:06:38] <eddyb> you can just drop everything right after trans, can't you?
[08:06:41] <cmr> because the work still needs to go into separating post-trans from the rest of the compiler at a task boundary
[08:06:43] <cmr> no, you can't
[08:06:56] <cmr> the Session and Context keep a *lot* of things around.
[08:07:11] <eddyb> why would you need a task boundary? I mean, that's for @, isn't it?
[08:07:24] <eddyb> cmr: drop them from there ;)
[08:09:19] <eddyb> I thought about borrowed pointers with explicit lifetime, but I think you would need to annotate *every* function in libsyntax and librustc (which deals with any part of the AST) with a generic lifetime
[08:09:24] <cmr> for sanity reasons. it's far easier to just send the few things we need than to track down every single las tthing keeping data alive.
[08:09:50] <eddyb> only then you get something out of it, otherwise it's much easier to go with &'static :P
[08:10:16] <eddyb> that is, without custom borrow and deref for smart pointers
[08:10:31] <eddyb> cmr: that's Rc, not arenas, AFAIK
[08:10:45] <cmr> eddyb: hm?
[08:11:02] <cmr> we can't safely drop the arena when there are still references to it
[08:11:13] <eddyb> you explicitly drop an arena and any pointers to it become invalid
[08:11:27] <cmr> So.. what do those pointers point to?
[08:12:09] <eddyb> unallocated memory, hopefully
[08:12:40] <cmr> I'm confused what how it'd be implemented. Would it be like a weakref, where the arena holds ptrs to the refs to zero on drop?
[08:13:36] <cmr> (and the weakref obj would require explicit borrows or what have you that lock the arena; they check that they haven't been nulled before that lock)
[08:13:42] <eddyb> I don't think tracking down arena references would be hard, unless there's some nested container, but I doubt it
[08:13:56] <eddyb> cmr: nah, none of that madness
[08:14:31] <cmr> Eugh, this is taking too long
[08:14:45] <cmr> eddyb: I'm going to go to bed. I'll have your data for you in ~12hrs though
[08:14:52] <cmr> This python script is so horrifically slow
[08:14:54] <eddyb> if you want to be safe, you can probably munmap and then mmap with NORESERVE and no read/write perms
[08:14:55] <eddyb> hehe
[08:15:05] <eddyb> I have a sugary idea on how to deal with refactoring away from @. P<T> for pointers an P(T{...}) to construct a new "smart pointer". can we use the same name for a type alias and a function?
[08:15:24] <cmr> yes
[08:15:34] <cmr> functions live in the value namespace, typedefs the type namespace
[08:15:41] <eddyb> rusti: type P<T> = &'static T; fn P<T>(x: T) -> P<T> {fail!()}
[08:15:41] -rusti- <anon>:9:41: 9:42 warning: unused variable: `x` [-W unused-variable (default)]
[08:15:42] -rusti- <anon>:9          type P<T> = &'static T; fn P<T>(x: T) -> P<T> {fail!()}
[08:15:42] -rusti-                                                   ^
[08:15:42] -rusti- ()
[08:15:45] <cmr> but sleeptime
[08:15:47] <cmr> nini
[08:15:47] <eddyb> <3
[08:15:50] <eddyb> night
[08:25:58] *** Quits: rusti (rusti@moz-54F7FD49.cpe.net.cable.rogers.com) (Ping timeout)
[08:28:15] *** nrc|afk is now known as nrc
[08:32:39] <eddyb> rusti: use Arena::P; mod Arena {type P<T> = &'static T; fn P<T>(_x: T) -> P<T> {fail!()}}; let x: P<int> = P(0);
[08:32:49] <eddyb> oh, right, it left. dammit :(
[08:34:39] *** Quits: ktt3ja (Mibbit@moz-54586A12.washdc.fios.verizon.net) (Quit: http://www.mibbit.com ajax IRC Client)
[08:42:58] *** Joins: rusti (rusti@moz-54F7FD49.cpe.net.cable.rogers.com)
[08:43:05] <eddyb> rusti: use Arena::P; mod Arena {type P<T> = &'static T; fn P<T>(_x: T) -> P<T> {fail!()}}; let x: P<int> = P(0);
[08:43:10] -rusti- pastebinned 8 lines of output: http://sprunge.us/bRAG
[08:43:58] <eddyb> rusti: use self::Arena::P; mod Arena {type P<T> = &'static T; fn P<T>(_x: T) -> P<T> {fail!()}}; let x: P<int> = P(0);
[08:44:00] -rusti- pastebinned 8 lines of output: http://sprunge.us/iGiJ
[08:44:18] <eddyb> rusti: mod Arena {type P<T> = &'static T; fn P<T>(_x: T) -> P<T> {fail!()}}; use self::Arena::P;  let x: P<int> = P(0);
[08:44:19] -rusti- <anon>:9:79: 9:98 error: view items must be declared at the top of the block
[08:44:19] -rusti- <anon>:9          mod Arena {type P<T> = &'static T; fn P<T>(_x: T) -> P<T> {fail!()}}; use self::Arena::P;  let x: P<int> = P(0);
[08:44:19] -rusti-                                                                                         ^~~~~~~~~~~~~~~~~~~
[08:44:19] -rusti- application terminated with error code 101
[08:44:26] <eddyb> eeeh
[08:54:50] *** Joins: whitglint (uid15486@moz-31ABA2C0.irccloud.com)
[09:00:38] *** Quits: rusti (rusti@moz-54F7FD49.cpe.net.cable.rogers.com) (Ping timeout)
[09:05:28] *** Quits: vky (chatzilla@moz-4F2E17BF.dsl.dynamic.sonic.net) (Ping timeout)
[09:14:28] *** Joins: nielsle (nielsle@moz-C46DA772.boa.fiberby.dk)
[09:22:44] <eddyb> where is strcat when I need to discuss an arena idea with him :P?
[09:27:13] *** Quits: Sharp (Sharp@moz-780FECDA.washdc.fios.verizon.net) (Quit: Sharp)
[09:31:42] *** Quits: Kxepal (Miranda@moz-636B9006.pppoe.mtu-net.ru) (Ping timeout)
[09:33:43] *** Quits: jdm (jdm@moz-78156D60.dsl.teksavvy.com) (Quit: Lost terminal)
[09:35:15] *** Joins: Kxepal (Miranda@moz-4306BDB7.pppoe.mtu-net.ru)
[09:36:33] <eddyb> s/@(Block|fn_decl|variant|Ty)\b/P<\1>/ :P
[09:45:21] <eddyb> <quote expansion>:10:33: 10:70 error: failed to find an implementation of trait extra::serialize::Decodable<__D> for &'static ast::Block
[09:45:32] <eddyb> oh, great, deriving on type aliases doesn't work ^_^
[09:45:43] *** Quits: bjz (bjz@moz-DD4A2A91.lnse2.cha.bigpond.net.au) (Ping timeout)
[09:50:28] <eddyb> /home/eddy/Projects/rust/src/libsyntax/ast.rs:34:0: 38:1 error: cannot provide an extension implementation where both trait and type are not defined in this crate
[09:50:29] <eddyb> :(
[09:52:26] *** Quits: quvarxa (chatzilla@moz-978E4C31.static.tpgi.com.au) (Ping timeout)
[09:53:03] *** Joins: quvarxa (chatzilla@moz-978E4C31.static.tpgi.com.au)
[10:15:31] <eddyb> wooo, using &'static T means clone fails =))))
[10:15:39] <eddyb> so I *have* to remove useless cloning
[10:17:23] <dbaupp> how on earth do you have a &'static in the AST?
[10:17:46] <eddyb> dbaupp: arena ptr trick
[10:17:55] <eddyb> error: cannot root managed value long enough // whaa
[10:19:14] <dbaupp> so you're unsafe-transmuting an arena ptr to a &'static?
[10:19:39] <eddyb> myeah, something like that
[10:21:19] <eddyb> I kinda know how to make dropping an arena safe-ish (or rather, deterministic in that you always fail if you access an arena ptr after dropping)
[10:21:30] <eddyb> "you can probably munmap and then mmap with NORESERVE and no read/write perms"
[10:23:04] <eddyb> dbaupp: the errors about rooting are things like @p.clone() which can now be replaced with p :P
[10:23:32] <dbaupp> eddyb: well, fix them :P
[10:23:55] <eddyb> I should name my PR "the clone wars"
[10:24:26] *** flaper87|afk is now known as flaper87
[10:24:54] *** Quits: TimAbraldes (quassel@moz-7FD19BDC.hsd1.or.comcast.net) (Connection reset by peer)
[10:25:05] <eddyb> dbaupp: I'm actually transmuting a @ ptr right now, it should work for testing, implementing an arena can be done later
[10:28:02] <dbaupp> you're transmuting a @ ptr?
[10:28:05] <dbaupp> that won't work...
[10:28:14] <dbaupp> @T points to Box<T>, not just T
[10:28:20] <eddyb> oh, hehe
[10:29:17] <eddyb> http://static.rust-lang.org/doc/master/std/managed/index.html O_O
[10:31:14] <eddyb> dbaupp: would &* work?
[10:31:24] *** Quits: tedh (tedh@moz-A5D1CAB7.public.wayport.net) (Ping timeout)
[10:31:36] <dbaupp> yes
[10:32:54] <eddyb> ::std::cast::transmute(&*@value)
[10:33:01] <eddyb> I'm only missing ~!
[10:33:32] <eddyb> dbaupp: this code is so old, it still has things like this: use std::option::Option;
[10:34:55] *** Joins: tedh (tedh@moz-A5D1CAB7.public.wayport.net)
[10:37:08] <dbaupp> transmute_region would be better if you just want to add 'static
[10:37:30] <dbaupp> also, why can't you just allocate with ~?
[10:38:37] <eddyb> dbaupp: because ~ is on the exchange_heap, it's farther from an arena than @ is (in its current leaking impl)
[10:38:51] <eddyb> but ~ would work for now, I guess
[10:39:19] <eddyb> is Option<&'static T> one word?
[10:41:38] *** Joins: bjz (bjz@moz-DD4A2A91.lnse2.cha.bigpond.net.au)
[10:41:51] <KokaKiwi> Bug with std::to_bytes::Cb? https://gist.github.com/KokaKiwi/b20f58b67cf7e2922bca
[10:42:21] <eddyb> dbaupp: haha, this might improve compile time of syntax/rustc by a tiny fraction, because I'm removing a ton of borrowing
[10:51:23] <KokaKiwi> I don't know how to name corresponding issue D:
[10:52:54] <dbaupp> eddyb: yes Option<&T> is one word if T isn't [] or str
[10:52:59] <dbaupp> (or a Trait0
[10:53:00] <dbaupp> )
[10:53:07] <eddyb> wooo :D
[10:53:16] <eddyb> much better than Option<T> :P
[10:53:48] <dbaupp> if T is u8, then Option<T> is 2 bytes, which is even better :P
[10:55:40] *** Quits: nrc (nrc@7BE24E90.A5032A01.3CFC199D.IP) (Ping timeout)
[10:56:34] <eddyb> dbaupp: T is usually a few words here
[10:58:55] <eddyb> I will love it when none of the AST structures can be cloned
[11:00:36] <dbaupp> KokaKiwi: https://github.com/mozilla/rust/issues/10700 fwiw, `do` changed recently to not work with stack closures, only with `proc`s, so the equivalent is `bug(|s| true)`
[11:01:20] *** Quits: quvarxa (chatzilla@moz-978E4C31.static.tpgi.com.au) (Ping timeout)
[11:01:52] *** Joins: quvarxa (chatzilla@moz-978E4C31.static.tpgi.com.au)
[11:08:41] <eddyb> dbaupp: oh, and... with this P(T) thing allows counting the number of allocated objects of each type :D
[11:10:29] <dbaupp> `P(T)`?
[11:14:55] <KokaKiwi> dbaupp: Yep I know, when I change Cb type or when I do 'bug(|...|)' it works, but, the fact is the compiler crash :p
[11:15:05] <eddyb> dbaupp: my "smart"/arena pointer constructor
[11:15:14] <dbaupp> KokaKiwi: yep
[11:20:43] <eddyb> / types can't be copied automatically because of the owned ptr in ty_tup...
[11:20:50] <eddyb> *//
[11:29:44] *** Quits: quvarxa (chatzilla@moz-978E4C31.static.tpgi.com.au) (Quit: ChatZilla 0.9.90.1 [Firefox 26.0/20131122094025])
[11:31:40] *** Joins: notmatt (notmatt@moz-9FB2565E.vc.shawcable.net)
[11:35:10] *** Quits: notmatt (notmatt@moz-9FB2565E.vc.shawcable.net) (Ping timeout)
[11:51:34] *** Joins: ghrust (ghrust@9C8B94D4.6A2AE50.F3114085.IP)
[11:51:34] <ghrust> 01[13rust01] 15bors pushed 4 new commits to 06auto: 02http://git.io/HIFQhQ
[11:51:34] <ghrust> 13rust/06auto 14ce44094 15Niko Matsakis: Add [mut_]shift_ref/[mut_]pop_ref functions, which return a pointer to the first/last item in the slice and modify the slice to exclude the returned item. Useful when writing iterators over mutable references.
[11:51:35] <ghrust> 13rust/06auto 14bc4164d 15Niko Matsakis: Modify iterators to make them safe with the new rules.
[11:51:38] <ghrust> 13rust/06auto 1409e12fa 15Niko Matsakis: Test that reborrowing contents of an `&'a mut &'b mut` pointer can only...
[11:51:39] *** Parts: ghrust (ghrust@9C8B94D4.6A2AE50.F3114085.IP) ()
[11:52:25] <eddyb> ooooh, neat
[11:56:36] <eddyb> dbaupp: I'm left with one rooting problem and I have no idea what it means
[11:57:38] <eddyb> silly incomplete GC
[12:03:36] <eddyb> item_enum(enum_def, Generics); // apparently there's something wrong with taking enum_def by reference
[12:10:01] <dbaupp> eddyb: rooting problem is letting a inner pointer to a @ "escape", so the unborrowing doesn't work; or something.
[12:16:11] <eddyb> I so wish type aliases were shown in errors
[12:16:22] <eddyb> it's hard to read all this expanded stuff
[12:20:26] <dbaupp> use a new type struct rather than a `type`?
[12:20:50] <eddyb> doesn't work because we don't have smart ptr traits yet
[12:21:29] <dbaupp> struct P<T>(&'static T) can be dereferenced like a ptr
[12:21:46] <dbaupp> and I think that method look ups work through the struct too.
[12:23:40] <eddyb> is it automatically borrowed?
[12:23:52] <eddyb> i.e. pass a P<T> to a function expecting a &T
[12:24:07] <dbaupp> you may have to dereference
[12:24:32] <dbaupp> rusti: struct P<T>(&'static T); fn foo(_: &int) {} foo(P(&1))
[12:24:40] <eddyb> I want to change as little code as possible
[12:26:48] <eddyb> mostly types and value construction, removing clones, etc
[12:54:44] <dbaupp> r? https://github.com/mozilla/rust/pull/10701
[13:01:44] *** Joins: ghrust (ghrust@9C8B94D4.6A2AE50.F3114085.IP)
[13:01:44] <ghrust> 01[13rust01] 15bors merged 06auto into 06master: 02http://git.io/HIFQhQ
[13:01:44] *** Parts: ghrust (ghrust@9C8B94D4.6A2AE50.F3114085.IP) ()
[13:15:57] *** Quits: bjz (bjz@moz-DD4A2A91.lnse2.cha.bigpond.net.au) (Ping timeout)
[13:21:01] *** Joins: bjz (bjz@moz-DD4A2A91.lnse2.cha.bigpond.net.au)
[13:30:53] * eddyb wants an import optimized for rust
[13:31:12] <eddyb> there is barely any logic in the imports I see
[13:36:02] <eddyb> dbaupp: trans::callee::body_contains_ret is unused
[13:44:00] <ChrisMorgan> dbaupp: I think it'd be handy if pull requests which will break other people's code explained explicitly what will need to be changed (not that most people will ever look at it). It's not as good as detecting and fixing changes, but it's better than nothing.
[13:45:55] *** Quits: eddyb (eddy@EBE709F3.F7C96DA2.FCAAE698.IP) (Ping timeout)
[13:50:36] *** Joins: eddyb (eddy@EBE709F3.F7C96DA2.FCAAE698.IP)
[13:50:54] *** Joins: vky (chatzilla@moz-4F2E17BF.dsl.dynamic.sonic.net)
[13:54:10] *** Quits: vky (chatzilla@moz-4F2E17BF.dsl.dynamic.sonic.net) (Ping timeout)
[13:58:24] <eddyb> dbaupp: haha, segfault
[14:01:19] *** Quits: summerlight (summerligh@327FC32B.2C956A45.501EFF44.IP) (Quit: Ï†Ñ Ïù¥Îßå Í∞ëÎãàÎã§.)
[14:17:14] *** Quits: dcrewi (david@moz-AB8667CE.gyrae.net) (Ping timeout)
[14:17:25] *** Joins: vfetwnuncszu (david@moz-AB8667CE.gyrae.net)
[14:17:36] *** vfetwnuncszu is now known as dcrewi
[14:20:33] *** Joins: summerlight (summerligh@327FC32B.2C956A45.501EFF44.IP)
[14:20:36] *** Joins: jdm (jdm@CAB30FBD.8F96AEA7.2D179A7D.IP)
[14:31:48] <eddyb> nmatsakis: can you take a look at this craziness? https://github.com/eddyb/rust/commit/193997662199dcede4016aae8fa4a279e101dd86#diff-ec44cc548fa68e8ba86fe669de5aa7bdL108
[14:32:10] <eddyb> I may attempt to write the arena myself, but I can't be sure I'm doing everything right
[14:35:53] <ChrisMorgan> Wow, ::std::cast::transmute(&*@value)!
[14:36:17] <eddyb> it doesn't even work!
[14:37:39] <eddyb> not sure why, it's just a temporary hack
[14:43:50] <eddyb> how can I do that properly?
[15:03:45] *** Quits: eddyb (eddy@EBE709F3.F7C96DA2.FCAAE698.IP) (Ping timeout)
[15:09:35] *** Joins: eddyb (eddy@EBE709F3.F7C96DA2.FCAAE698.IP)
[15:15:38] <eddyb> okay, this is really weird. it's not working with ::std::cast::transmute(~value)
[15:15:48] <eddyb> but that's exactly what Rc does
[15:33:43] <eddyb> pub static RC_MANAGED_UNIQUE : uint = (-2) as uint;
[15:40:54] <eddyb> this is baaad :(
[15:41:26] <eddyb> so ~(@T, U) is allocated as @(@T, U)? or what?
[15:43:40] <eddyb> where is everyone?
[15:48:30] *** Quits: eddyb (eddy@EBE709F3.F7C96DA2.FCAAE698.IP) (Ping timeout)
[15:50:43] *** Joins: eddyb (eddy@EBE709F3.F7C96DA2.FCAAE698.IP)
[15:56:17] <eddyb> dbaupp: any chance you could check Rc::new(@0).borrow() for me?
[15:56:36] <eddyb> nvm, it segfaulted again, I can check myself
[15:59:01] <eddyb> dbaupp: this segfaults: fn main() {use std::rc::Rc; let r = Rc::new(@0); println!("{}", **r.borrow());}
[16:03:47] *** Quits: acrichto (acrichto@moz-B63D64BD.res.cmu.edu) (Ping timeout)
[16:11:31] <eddyb> (*repr).ref_count = ::std::managed::RC_IMMORTAL; // this better work
[16:13:45] <cmr> eddyb: your thing didn't build
[16:13:53] <eddyb> cmr: which one?
[16:14:02] <eddyb> if you've tried since a few hours ago, I've updated
[16:14:13] <eddyb> is it a segfault :P?
[16:15:06] <cmr> yes
[16:15:20] <cmr> actually
[16:15:22] <cmr> Idon'tremember
[16:15:42] <eddyb> running the result of stage1 results in a segfault, that's what I'm fixing right now
[16:16:21] <eddyb> cmr: see my Rc testcase above, it's a similar problem (simple transmutes from allocations don't work)
[16:16:21] <cmr> do you have a link to the gist? you linked to a commit in a gist
[16:17:05] <eddyb> cmr: are you talking about my arch-x86_16.rs gist? or my rustc PR?
[16:17:14] <eddyb> s/rustc/rust
[16:17:22] <cmr> arch-x86_16.rs
[16:17:36] *** Joins: pnkfelix (pnkfelix@87C1F78E.1DE10CA8.D8E68FF6.IP)
[16:17:51] <eddyb> cmr: ah, that. https://gist.github.com/eddyb/b802f5bdc4174e0fbf11/raw/98bbbc4b685e58125c455be294b688232adedfdb/arch-x86_16.rs
[16:17:56] <eddyb> it should still work
[16:19:56] *** Quits: jdm (jdm@CAB30FBD.8F96AEA7.2D179A7D.IP) (Ping timeout)
[16:20:07] <cmr> oh it does build
[16:20:13] <cmr> wonder why the bench failed
[16:20:19] <cmr> guess I'll babysit it
[16:21:29] *** Quits: eddyb (eddy@EBE709F3.F7C96DA2.FCAAE698.IP) (Ping timeout)
[16:23:05] *** Quits: ChrisMorgan (chris@moz-6AC741CA.static.tpgi.com.au) (Ping timeout)
[16:25:19] *** Joins: eddyb (eddy@EBE709F3.F7C96DA2.FCAAE698.IP)
[16:28:32] <cmr> eddyb: heh,it's actually python that's segfaulting!
[16:30:16] <eddyb> so you're not trying to compile my broken PR :P
[16:30:43] <eddyb> I would replace python with node.js and enjoy the speed ;)
[16:30:52] <eddyb> GAAAH
[16:31:05] <cmr> yeah no
[16:31:08] <cmr> it's being replaced with rust
[16:31:23] <eddyb> segfault. again. this time in _int_malloc
[16:31:23] <cmr> I already went down the JS rabbit hole a year or so ago, I'm not doing that again
[16:31:33] <eddyb> wtf is wrong with this?
[16:33:56] <eddyb> it's... dropping the @
[16:34:07] <eddyb> after I've made it immortal
[16:41:42] *** Quits: eddyb (eddy@EBE709F3.F7C96DA2.FCAAE698.IP) (Ping timeout)
[16:45:29] *** Joins: eddyb (eddy@EBE709F3.F7C96DA2.FCAAE698.IP)
[16:48:28] <eddyb> cmr: did you get a chance to build the PR I linked before I made a mess out of it?
[16:49:00] <cmr> eddyb: no
[16:49:07] *** Joins: jdm (jdm@13F2CEC5.7672369.D8E68FF6.IP)
[16:49:48] <eddyb> I hate how the simple allocation trick just doesn't want to work. and the arena I want to write has some design details to discuss first, I can't just drop it in
[16:50:05] <eddyb> strcat isn't around, he would know enough to get me started
[16:50:53] <eddyb> wooo it works now :D
[16:52:54] <eddyb> cmr: current code works: https://github.com/mozilla/rust/pull/10676
[16:53:13] <eddyb> now, I thought @ doesn't free before a task ends
[16:53:39] <cmr> no, that's only when there are cycles.
[16:53:50] <cmr> (the task annihilator frees cycles)
[16:55:27] <eddyb> ouch, then arenas might not be best here
[16:56:19] <eddyb> building stage2 right now, let's see how bad this is
[16:58:02] *** Quits: eddyb (eddy@EBE709F3.F7C96DA2.FCAAE698.IP) (Ping timeout)
[17:08:56] *** Joins: eddyb (eddyb@EBE709F3.F7C96DA2.FCAAE698.IP)
[17:09:47] <eddyb> cmr: it's bad. I'd be curious to see *exactly* how high it peaks, it might go over 2GB
[17:10:14] <eddyb> so, my assumptions were wrong. that's what I get for working alone on this
[17:10:29] <eddyb> does that mean removing clones does... nothing?
[17:10:40] <cmr> On @-boxes? Yup.
[17:10:59] <cmr> @-box clone is just a refcount bump
[17:11:11] <eddyb> uhm, no?
[17:11:11] *** Joins: _eddyb_ (eddy@EBE709F3.F7C96DA2.FCAAE698.IP)
[17:11:56] <eddyb> cmr: are you sure? or it's just for @T:Freeze?
[17:12:56] <eddyb> a clone on Rc is a refcount bump, I thought @T::clone was @self.clone()
[17:13:33] <pnkfelix> eddyb: "/// Return a shallow copy of the managed box."
[17:13:43] <pnkfelix> eddyb: in clone.rs
[17:13:51] <eddyb> so @self?
[17:14:02] <cmr> fn clone(&self) -> @T { *self 
[17:14:05] <cmr> that's the impl for @T
[17:15:15] <cmr> so yes, just a refcount bump.
[17:15:22] <eddyb> I was asking if it does nothing because either the original or the clone will be freed, eventually
[17:15:40] <cmr> the original and the clone point to the same object
[17:15:40] <eddyb> but that clone thing makes me even more of a fool
[17:16:03] <pnkfelix> eddyb: are you confusing reference with object?
[17:16:12] *** eddyb is now known as eddyb[pc]
[17:16:14] <pnkfelix> eddyb: (if so, its an easy mistake, I think nmatsakis did the same in a recent blog post...)
[17:16:44] *** _eddyb_ is now known as eddyb
[17:17:01] <eddyb> I had a completely wrong view of @
[17:17:07] <eddyb> I blame strcat
[17:17:33] <eddyb> that means my work to move away from @ in the parser is... pointless
[17:18:20] <pnkfelix> eddyb: well, less rc-/gc- allocation is good if you put in something that matches the phase behavior of the program better.
[17:18:28] *** flaper87 is now known as flaper87|afk
[17:18:51] <eddyb> how would arenas even work? it shot up to 1.3GB in half a minute or so, and that's with just 4 structures ported to an "arena" pointer
[17:19:59] <pnkfelix> eddyb: do you mean how do arenas improve things when they are applied correctly in general?  Or are you asking how to apply them here?
[17:20:10] <eddyb> I was talking about short-circuiting folding on all levels (no change => return original pointer), *thinking* all the @ boxes weren't getting freed
[17:21:51] <eddyb> pnkfelix: well, here. they would only provide a marginal speed improvement compared to @, the way I see it now
[17:22:42] <cmr> eddyb: have  you profiled it?
[17:22:48] *** Joins: Sharp (Sharp@moz-780FECDA.washdc.fios.verizon.net)
[17:22:58] <eddyb> cmr: I really want to see how bad rustc-stage2 is on that PR right now. once you have the data I hope I can easily move P<T> back to @T and test again
[17:23:07] <cmr> ok
[17:23:08] <pnkfelix> eddyb: yeah I'm not sure you'll see much improvement with memory usage, unless there are a lot of distinct @-nodes (as opposed to relatively few @-nodes each with a large payload)
[17:23:13] <cmr> it's building
[17:23:24] <eddyb> thanks :)
[17:23:55] <eddyb> pnkfelix: I'm seeing a memory explosion with 4 structures moved to naive arena pointers
[17:24:00] <pnkfelix> eddyb: the benefit I would expect from arenas in that case would be from more efficient allocation and reclamation.  But strcat has said the extra::arena library is slower than malloc so I don't know what's up with that.
[17:24:14] <eddyb> extra::arena is weird
[17:24:15] <pnkfelix> eddyb: ("more efficient" with respect to time, not space.)
[17:25:17] *** Joins: strcat (strcat@moz-54F7FD49.cpe.net.cable.rogers.com)
[17:25:24] <eddyb> strcat wants a move away from @ because GC would triple memory usage, he says
[17:25:51] *** Joins: rusti (rusti@moz-54F7FD49.cpe.net.cable.rogers.com)
[17:26:14] <pnkfelix> eddyb: yeah, that's assuming an inverse load factor of 3x.  (i.e. if your live set of data is N bytes, then the target-heap size from the GC is 3N bytes.)
[17:26:40] <pnkfelix> eddyb: most GC's I've worked with have had to assume an inverse load factor along those lines to perform acceptably.
[17:27:29] <pnkfelix> eddyb: but there's a lot of different things going on in Rust, e.g. the weak generational hypothesis might not hold for well written code using @-ptrs, since temporary data will be stack allocated, not @-allocated.
[17:27:49] <pnkfelix> eddyb: so I don't know if we'd end up using an inverse load factor of 3x.
[17:28:15] <eddyb> pnkfelix: hmm. well, here's an idea: the AST has no unsafe pointers, some ~T and all indirections will be P<T>. under those assumptions, couldn't we have a specialized GC?
[17:28:39] <cmr> iirc nmatsakis or pcwalton had thoughts on redesigning the AST
[17:28:42] <eddyb> with manual reclaiming cycles
[17:29:39] *** Joins: notmatt (notmatt@moz-9FB2565E.vc.shawcable.net)
[17:30:14] <eddyb> for the arenas, I was thinking of separating the chunks by type, and just allocating a multiple of the page size, with mmap
[17:31:13] <strcat> malloc/free are already using pools/arenas
[17:31:29] <eddyb> strcat: oh, I didn't see you come in
[17:31:45] <eddyb> strcat: basically, I fucked up
[17:31:50] <strcat> hm?
[17:32:03] <eddyb> how bad, we'll see when cmr finishes profiling my PR
[17:33:03] <strcat> as in memory usage is increased?
[17:33:28] <strcat> just replace all the @ with Rc and memory usage will drop + it will be faster ;p
[17:33:34] <eddyb> by a lot :P. and there's only 4 types that I put behind my P<T>
[17:33:50] <strcat> so I guess those variants were actually come?
[17:33:52] <strcat> common*
[17:34:07] <cmr> doesn't matter how common the variants are if they bloat the whole enum?
[17:34:18] <strcat> replacing Foo with Box<Foo> increases the memory consumption for that variant
[17:34:20] <eddyb> my P<T> doesn't get freed
[17:34:35] <cmr> oh I see what you're saying
[17:34:35] *** Quits: Sharp (Sharp@moz-780FECDA.washdc.fios.verizon.net) (Quit: Sharp)
[17:34:45] <strcat> eddyb: well, that's how @ is, it doesn't get freed until you climb back up the call stack
[17:34:56] <strcat> because it doesn't have move semantics like a refcounting box should
[17:35:09] <eddyb> strcat: I thought @ never gets freed before the task ends
[17:35:15] <strcat> when there are cycles
[17:35:22] <strcat> let x = @5; by_value(x)
[17:35:30] <strcat> refcount is 1 due to x, passing it by-value makes it 2
[17:35:41] <strcat> it won't get freed until it climbs back up and `x` goes out of scope
[17:35:47] <strcat> unlike Rc, which would move into by_value
[17:36:00] <strcat> we 'leak' a lot of memory this way
[17:36:02] <eddyb> and that Clone for @T is recursive
[17:36:14] <eddyb> those are both wrong assumptions
[17:36:23] <strcat> Clone for @T/Rc is shallow
[17:36:29] <strcat> DeepClone is deep ;p
[17:37:18] <eddyb> I thought we were leaking by cloning. a lot of // XXX(pcwalton) bad clone // reinforced that
[17:37:26] <eddyb> this would be easy to experiment with if we could have some of the semantics of @T for a custom Ptr<T>
[17:37:51] <cmr> eddyb: you.. you realize that is what the smartptr stuff pnkfelix and nmatsakis have been working on is, right?
[17:38:17] <eddyb> yes. but it's not here yet and I'm wasting time on things that don't work :(
[17:38:35] <pnkfelix> strcat: that is an interesting point.  The only way to force move semantics currently is, what, to do something like `let mut x = Some(@5); by_value(let tmp = x.unwrap(); x = None; tmp}); ‚Ä¶`  ?
[17:38:38] <cmr> eddyb: you broke rustdoc
[17:38:59] <eddyb> cmr: oh, lol. I don't build that
[17:39:03] <pnkfelix> strcat: (ugh I left out a pair of { ‚Ä¶ } around the argument expr to by_value)
[17:39:21] <cmr> eddyb: do you want the full graph for building librustc?
[17:40:10] <eddyb> cmr: if it's not too much, yeah. but the maximum is enough otherwise
[17:40:17] <strcat> pnkfelix: I think it would still leave a refcount on the stack of the caller
[17:40:25] <eddyb> could Rc<T> clone itself if necessary?
[17:40:42] <eddyb> (in a smart pointer future)
[17:41:09] <eddyb> all the other operations I've seen mentioned
[17:41:35] <cmr> I don't think that would be good.
[17:41:38] <pnkfelix> strcat: hmm.  I can see why one might expect it to have copy semantics, but it seems a shame to not be able to express move properly.
[17:41:38] <strcat> I think it's fine for splits of Rc ownership to be explicit
[17:41:52] <strcat> pnkfelix: well, if it was gc'ed, it wouldn't matter
[17:41:59] <strcat> or would it?
[17:42:01] <strcat> hm
[17:42:20] <strcat> I guess the gc would still not be able to free it until moving up the call stack ;\
[17:42:35] <pnkfelix> strcat: if there's an old stack reference lying around that is not cleared, a conservative stack scan will make it keep the data alive
[17:42:42] <strcat> yeah
[17:42:48] <eddyb> strcat: couldn't it to the best thing?
[17:43:20] <strcat> pnkfelix: imo this is one of rust's major improvements over C++ though, because in C++ copies are implicit and moves are explicit
[17:43:25] <strcat> + moves are hard to get right in C++
[17:43:46] <strcat> so it leads to writing code without heap allocations and without excessive refcounting (if you pretend @ doesn't exist! :P)
[17:44:05] <strcat> and we have #[no_send].... so we don't need atomic refcounting by default
[17:44:56] <eddyb> a couple thousand .clone() calls that you can barely differentiate from bad clones (although it doesn't seem like there too many bad clones in libsyntax) won't help any kind of refactoring
[17:45:05] <strcat> pnkfelix: it's something C programmers hate about C++ :)
[17:45:11] <strcat> they'd like rust more.
[17:46:11] <eddyb> strcat: look at my mess https://github.com/mozilla/rust/pull/10676/files#diff-0de6e63ecfba5c83fb06c9e981f292a6L20
[17:46:20] <pnkfelix> strcat: So was it some deliberate choice from the team's past to make @T use copy semantics always, rather than move semantics for the last reference in variable's scope?
[17:46:56] <pnkfelix> strcat: I suppose it is more consistent with the general philosophy of how Drop is handled...
[17:47:54] *** Quits: eddyb[pc] (eddyb@EBE709F3.F7C96DA2.FCAAE698.IP) (Quit: Konversation terminated!)
[17:48:11] <pnkfelix> strcat: I guess my real question is: Do you know if this was indeed deliberate design choice (which I could believe), or a collective oversight (which I could also believe) ?
[17:48:18] <eddyb> so what did nmatsakis say about arenas?
[17:48:36] <eddyb> I may have misunderstood that, too
[17:48:49] <eddyb> strcat: so much wasted time :(
[17:50:44] *** Joins: Sharp (Sharp@moz-780FECDA.washdc.fios.verizon.net)
[17:55:09] *** jdm is now known as jdm|f00ding
[17:55:58] <eddyb> yay, libsyntax is actually generic over P<T> = &'static T and P<T> = @T
[17:58:32] <eddyb> you can actually replace @T with P<T> in the AST, when P<T> = @T
[17:58:51] <eddyb> and then Rc<T>
[17:59:09] <cmr> eddyb: bad news
[17:59:25] <eddyb> cmr: come on, I just want a number :P
[17:59:30] <cmr> http://i.imgur.com/9DZ31io.png
[17:59:57] <eddyb> strcat: thus, I can give you a number of errors
[18:00:00] <eddyb> cmr: AHAHAHA
[18:00:20] <eddyb> that is monumentally bad
[18:00:40] <eddyb> it's probably folding which was getting freed before
[18:03:48] <strcat> pnkfelix: well, @ is why we have 'take glue'
[18:04:01] <strcat> so I'm sure it was deliberate because it was hard to implement ;p
[18:05:30] <pnkfelix> strcat: hah.  "hard-to-implement" is a different reason than "bad for our Drop model."
[18:06:25] <strcat> pnkfelix: and rust had @ before it had borrowed pointers and unique pointers afaik
[18:06:45] <strcat> which is why a lot of things use that weird box layout
[18:07:21] <pnkfelix> strcat: Well, maybe I'll look at this later.  It seems like an interesting detail that would be cool to toggle, see what happens.
[18:07:41] <strcat> pnkfelix: and copies used to be the default rather than moves
[18:07:46] <pnkfelix> strcat: happy t-day.   /me doesn't know whose american in the room.
[18:08:17] <pnkfelix> strcat: yeah I was just going back through all the old meeting minutes from when we removed explicit `move` and `copy` operators
[18:08:26] <strcat> canada thanksgiving is in october ;p
[18:08:28] <pnkfelix> strcat: trying to find any record of whether this detail of @T was discussed.
[18:08:37] <pnkfelix> strcat: ah okay, Oh Canada.
[18:09:36] <strcat> last use analysis and those horrific argument modes
[18:10:29] * strcat wasn't around when generics weren't monomorphized though
[18:10:46] *** Quits: eddyb (eddy@EBE709F3.F7C96DA2.FCAAE698.IP) (Ping timeout)
[18:12:12] <pnkfelix> strcat: okay, "last use analysis" is getting me more useful hits in my searches
[18:12:38] <pnkfelix> strcat: such as in this document: https://github.com/mozilla/rust/wiki/Proposal-for-constructor-expr
[18:12:41] <strcat> pnkfelix: I think rust just copied by default and then figured out if it could do a move for the last use
[18:12:56] <strcat> and there was no story for custom copying (as in Clone)
[18:13:17] <pnkfelix> strcat: but now that we have Clone, we got rid of the last use analysis?
[18:13:30] <strcat> pnkfelix: look up 'moves based on type'
[18:13:46] <strcat> now we just do moves of ownership for types with dtors (or &mut, or closures)
[18:13:53] <strcat> no more last use analysis
[18:14:01] <strcat> one of niko's changes
[18:14:26] *** Joins: eddyb (eddy@EBE709F3.F7C96DA2.FCAAE698.IP)
[18:14:29] <pnkfelix> strcat: yes, I think I did know this
[18:14:43] <pnkfelix> strcat: okay.  so to achieve what we're talking about
[18:15:34] <pnkfelix> strcat: The "natural" approach from my POV would be to make @T a type that implies move, and make people call .clone() everywhere before the last-use.
[18:15:50] <pnkfelix> strcat: which would probably make some people scream (perhaps including me).
[18:15:53] <strcat> pnkfelix: yeah, and that's what Rc will do, so it would be more symmetric for Gc to do it too
[18:15:59] <strcat> well, it's noisier
[18:16:03] <strcat> but it's more systems-y
[18:16:13] *** Quits: eddyb (eddy@EBE709F3.F7C96DA2.FCAAE698.IP) (Ping timeout)
[18:16:19] *** Joins: Jesse (jruderman@moz-5973C6FA.oc.oc.cox.net)
[18:16:49] <strcat> pnkfelix: although it would rely on moves zeroing the source to be helpful, and afaik nmatsakis/pcwalton want to replace that with analysis
[18:17:09] <pnkfelix> strcat: yes that sounds familliar too
[18:17:28] * strcat is not really sure if making moves not zero the source is a good idea
[18:17:55] <pnkfelix> its this ticket, right: https://github.com/mozilla/rust/issues/5016 ?
[18:18:03] <strcat> yeah
[18:18:10] <strcat> the title is different than my original one ;]
[18:18:57] <pnkfelix> okay I do recall a number of discussions of this change
[18:19:03] <pnkfelix> I just failed to see the connection to @T
[18:20:27] <strcat> pnkfelix: if you look in trans you'll see a lot of stuff about take glue, which is *entirely* to do refcounts for @
[18:20:37] *** Joins: eddyb (eddy@EBE709F3.F7C96DA2.FCAAE698.IP)
[18:20:37] <strcat> for example [@int, ...5] has take glue
[18:20:40] <strcat> and any struct containing that
[18:20:42] <strcat> etc.
[18:20:44] <strcat> it's a mess ;]
[18:21:14] <pnkfelix> strcat: right.  My understanding is that a tracing GC will remove the need to emit take-glue.
[18:21:24] <strcat> once upon a time, ~T, ~[T] and ~str had take glue and it copied them like Clone does now
[18:21:33] <pnkfelix> strcat: but I now realize that that understanding may be a little naive
[18:21:33] <eddyb> so both libsyntax and librustc work with P<T> \in {@T, &'static} now, for those 4 types I boxed
[18:22:05] <pnkfelix> okay, really going now.  night all.
[18:22:43] <eddyb> with the smart pointer traits, Rc would also work. and I might have a P::split_ownership kind of thing that's noop except for Rc, to solve the .clone() problem
[18:22:59] *** Quits: pnkfelix (pnkfelix@87C1F78E.1DE10CA8.D8E68FF6.IP) (Quit: Leaving.)
[18:25:21] <eddyb> cmr: updated my PR to use @T, now it should show a 130MB reduction or so (from what I remember)
[18:26:48] <cmr> protip: force pushes make it hell for people trying to pull your changes
[18:28:33] <strcat> cmr: but that's fun
[18:28:41] <strcat> http://i.imgur.com/2A3ihEW.gif
[18:29:12] <eddyb> cmr: oops. but the diff would look a lot worse without them >_>
[18:29:27] <cmr> can always squash later
[18:29:30] <eddyb> since I've basically rewritten my PR once
[18:29:31] <cmr> jus' sayin'
[18:30:11] <eddyb> git reset --hard HEAD~1; git pull --rebase ...
[18:31:21] <eddyb> strcat: aahh, too bad, can't get a count of Rc-related errors
[18:32:32] <eddyb> for some reason it stops after type errors in macro expansions and it doesn't give an error count (but it's only like 6)
[18:37:48] <jack> task 'rustc' failed at 'index out of bounds: the len is 3 but the index is 18446744073709551615', /Users/jack/src/rust/src/libsyntax/lib.rs:1
[18:37:51] <jack> that seems bad
[18:38:20] <eddyb> first thing to do is turn that number into hex :P
[18:38:40] <eddyb> rusti: format!("{:x}", 18446744073709551615)
[18:38:43] -rusti- ~"ffffffffffffffff"
[18:38:55] <strcat> jack: well I fixed indexing, before it would have overflowed ;p
[18:38:56] <jack> oh, i know exactly where that is :)
[18:39:14] <eddyb> rusti: 18446744073709551615 as int
[18:39:15] -rusti- -1
[18:39:17] <strcat> rusti: 18446744073709551615 * 8
[18:39:18] -rusti- -8
[18:39:32] <strcat> rusti: (18446744073709551615 * 8) as uint
[18:39:32] -rusti- 18446744073709551608u
[18:40:06] <jack> eddyb: that was enormously helpful :)
[18:40:18] <jack> i was indeed calling slice_to(-1)
[18:40:33] <jack> wy we can't give a nice error message about that seems a bit dubious
[18:40:42] <jack> even breaking on rust_begin_unwind didn't give me a stack trace
[18:40:56] <strcat> jack: the trick would be removing the negation operator from unsigned ints
[18:41:01] <strcat> and that wouldn't compile
[18:41:08] <eddyb> hehe
[18:41:18] <eddyb> rusti: fn foo(_x: uint) {} foo(1)
[18:41:19] -rusti- ()
[18:41:26] <eddyb> aaah, it's the coercion >_<
[18:41:26] <strcat> rusti: let x = 5u; -x
[18:41:27] -rusti- 18446744073709551611u
[18:41:31] <strcat> when it sees
[18:41:33] <strcat> -1
[18:41:43] <strcat> it's really parsed as -(1)
[18:41:46] <strcat> and it infers the type later
[18:41:57] <eddyb> s/coercion/inference/
[18:42:08] <jack> strcat: you don't want negative indexing like python? :)
[18:42:15] *** jdm|f00ding is now known as jdm
[18:42:39] <strcat> jack: not by default
[18:42:42] <eddyb> rusti: fn foo(_x: uint) {} foo(-1i)
[18:42:43] -rusti- <anon>:9:33: 9:36 error: mismatched types: expected `uint` but found `int` (expected uint but found int)
[18:42:43] -rusti- <anon>:9          fn foo(_x: uint) {} foo(-1i)
[18:42:43] -rusti-                                           ^~~
[18:42:43] -rusti- error: aborting due to previous error
[18:42:43] -rusti- application terminated with error code 101
[18:42:51] <strcat> jack: alternate methods for it, sure ;p
[18:43:11] <eddyb> or, you know, choosing the right type
[18:44:01] <strcat> jack: D ranges have InputRange (like our Iterator), bidirectional ranges (like DoubleEndedIterator) and also random access
[18:44:03] <strcat> so
[18:44:08] <strcat> you can grab a range
[18:44:13] <strcat> and 'pop' 5 elements off the end
[18:44:20] <strcat> or whatever
[18:44:41] <strcat> anyway I think if we had more composable random access it would cover stuff like that
[18:44:42] <eddyb> strcat: about that, did you see my silly v[a..b] => v[range(a, b)] idea?
[18:45:20] <eddyb> i.e. desugaring instead of special-casing. for i in a..b, maybe :D
[18:46:22] <eddyb> I've thought of so many things, I should start a blog or something. "baby rants" to go with "baby steps" or something. I don't know
[18:46:23] <jack> ok. i still have a similar bug somewhere. how can i get a backtrace for this error?
[18:46:39] <eddyb> grep -- -1 :P
[18:47:22] <eddyb> jack: I think you would have to break in gdb on the lang item implementation for fail_out_of_bounds
[18:47:42] <eddyb> strcat might know more
[18:48:00] <strcat> jack: gdb, catch throw, will catch a failure
[18:48:11] <strcat> since they're just C++ exceptions
[18:48:59] * strcat is glad -Z extra-debug-info works well now
[18:49:14] <strcat> 'bt full' on abort <3
[18:49:22] <strcat> who needs stepping or breakpoints anyway ;p
[18:49:27] <eddyb> haha, catch throw
[18:49:54] <eddyb> cmr: how's the build going?
[18:50:23] * eddyb is not sure what to do now. pfft, wasted time... you could say I'm "leaking" time
[18:53:04] <eddyb> oh, I just noticed there's a small peak inside the LLVM passes
[18:54:13] <jack> strcat: https://gist.github.com/metajack/7696656
[19:09:34] *** Joins: nrc (nrc@7BE24E90.A5032A01.3CFC199D.IP)
[19:14:00] <eddyb> dbaupp: http://huonw.github.io/isrustfastyet/mem/old oh, I see what you mean
[19:15:35] <eddyb> apparently, it was 1.2GB before https://github.com/mozilla/rust/pull/7615
[19:16:02] <eddyb> not sure why cmr didn't catch it
[19:16:39] <eddyb> eh, nvm, didn't read it all. known problem
[19:19:37] *** Quits: summerlight (summerligh@327FC32B.2C956A45.501EFF44.IP) (Ping timeout)
[19:20:01] *** Joins: ghrust (ghrust@F6EE6DE3.6A2AE50.F3114085.IP)
[19:20:01] <ghrust> 01[13rust01] 15alexcrichton merged 06auto into 06snap-stage3: 02http://git.io/4WtDxQ
[19:20:01] *** Parts: ghrust (ghrust@F6EE6DE3.6A2AE50.F3114085.IP) ()
[19:30:43] *** Joins: acrichto (acrichto@moz-69F2E428.ugrad.cs.cmu.edu)
[19:30:43] *** ChanServ sets mode: +o acrichto
[19:32:47] *** Quits: Sharp (Sharp@moz-780FECDA.washdc.fios.verizon.net) (Quit: Sharp)
[19:40:53] *** Joins: Sharp (Sharp@moz-780FECDA.washdc.fios.verizon.net)
[19:41:04] <jack> how does rustc find crates to link?
[19:41:35] <jack> i have a file called libfoo-XXXX-Y.Y.dylib and an extern mod foo;
[19:41:45] <jack> does it search through all files called libfoo?
[19:42:24] <jack> where does it do this search?
[19:44:59] <jack> read_crates it appears
[19:47:51] *** Joins: _eddyb_ (eddy@EBE709F3.F7C96DA2.FCAAE698.IP)
[19:48:21] *** Quits: eddyb (eddy@EBE709F3.F7C96DA2.FCAAE698.IP) (Ping timeout)
[19:51:38] *** Quits: _eddyb_ (eddy@EBE709F3.F7C96DA2.FCAAE698.IP) (Ping timeout)
[19:52:14] *** Joins: twb (textual@moz-5DE8950B.hsd1.ga.comcast.net)
[19:54:58] *** Joins: _eddyb_ (eddy@EBE709F3.F7C96DA2.FCAAE698.IP)
[19:57:03] <acrichto> jack: it's part of metadata::filesearch
[19:57:19] <acrichto> it looks for all files looking like "libfoo*.dylib" and then inspects the metadata
[19:57:53] *** Joins: |eddyb| (eddy@EBE709F3.F7C96DA2.FCAAE698.IP)
[19:58:11] *** Quits: _eddyb_ (eddy@EBE709F3.F7C96DA2.FCAAE698.IP) (No route to host)
[20:00:09] *** Quits: twb (textual@moz-5DE8950B.hsd1.ga.comcast.net) (Quit: My MacBook Pro has gone to sleep. ZZZzzz‚Ä¶)
[20:04:35] *** Quits: |eddyb| (eddy@EBE709F3.F7C96DA2.FCAAE698.IP) (Ping timeout)
[20:10:27] *** Quits: notmatt (notmatt@moz-9FB2565E.vc.shawcable.net) (Client exited)
[20:12:20] *** Joins: |eddyb| (eddy@EBE709F3.F7C96DA2.FCAAE698.IP)
[20:14:36] *** Joins: ktt3ja (Mibbit@moz-54586A12.washdc.fios.verizon.net)
[20:18:21] *** Joins: bytewise (bytewise@moz-AD6B53F3.adsl.alicedsl.de)
[20:19:48] *** Joins: vky (chatzilla@moz-4F2E17BF.dsl.dynamic.sonic.net)
[20:25:38] *** |eddyb| is now known as eddyb
[20:25:56] <eddyb> cmr: second build over yet :P?
[20:26:04] <eddyb> I'm only asking because I should be sleeping already
[20:26:24] <eddyb> and I want to know I didn't waste a week chasing RAM ghosts
[20:26:35] *** Joins: ghrust (ghrust@79968228.6A2AE50.F3114085.IP)
[20:26:35] <ghrust> 01[13rust01] 15bors pushed 0 new commits to 06auto: 02http://git.io/0Ab-VA
[20:26:35] *** Parts: ghrust (ghrust@79968228.6A2AE50.F3114085.IP) ()
[20:26:36] *** Joins: ghrust (ghrust@79968228.6A2AE50.F3114085.IP)
[20:26:36] <ghrust> 01[13rust01] 15bors pushed 2 new commits to 06auto: 02http://git.io/emgNlA
[20:26:36] <ghrust> 13rust/06auto 146bd2249 15Guillaume Pinot: shootout-spectralnorm resurection with parallelization
[20:26:36] <ghrust> 13rust/06auto 1490d06ec 15bors: auto merge of #10704 : TeXitoi/rust/spectralnorm-resurected, r=alexcrichton
[20:26:36] *** Parts: ghrust (ghrust@79968228.6A2AE50.F3114085.IP) ()
[20:27:43] *** Quits: vky (chatzilla@moz-4F2E17BF.dsl.dynamic.sonic.net) (Client exited)
[20:30:02] <jack> ok. i see the problem. i removed link metas and replaced them with pkgid but didn't update the crate_matches stuff in loader
[20:33:01] *** Joins: jmbto (jmbto@moz-FE174E29.fbx.proxad.net)
[20:35:36] <jack> hmm. the crate seems to have no metadata at all
[20:53:37] *** Quits: Sharp (Sharp@moz-780FECDA.washdc.fios.verizon.net) (Quit: Sharp)
[21:36:22] <eddyb> cmr: good night, I expect the report on my desk by tomorrow
[21:36:32] <eddyb> err, who do you think you are, eddyb?
[21:36:33] *** Joins: ghrust (ghrust@2EE61FCC.6A2AE50.F3114085.IP)
[21:36:33] <ghrust> 01[13rust01] 15bors merged 06auto into 06master: 02http://git.io/emgNlA
[21:36:33] *** Parts: ghrust (ghrust@2EE61FCC.6A2AE50.F3114085.IP) ()
[21:38:17] *** Quits: eddyb (eddy@EBE709F3.F7C96DA2.FCAAE698.IP) (Ping timeout)
[21:46:12] *** Quits: nrc (nrc@7BE24E90.A5032A01.3CFC199D.IP) (Ping timeout)
[21:46:32] *** Quits: dbaupp (Thunderbir@moz-3BE4086E.lns20.syd6.internode.on.net) (Ping timeout)
[22:14:23] *** Joins: notmatt (notmatt@CC62CF7E.1E7FDFDB.A82DBDDB.IP)
[22:23:11] *** Joins: Sharp (Sharp@moz-780FECDA.washdc.fios.verizon.net)
[22:24:56] *** Quits: jmbto (jmbto@moz-FE174E29.fbx.proxad.net) (Quit: Leaving)
[22:28:32] *** Joins: quvarxa (chatzilla@moz-978E4C31.static.tpgi.com.au)
[22:36:30] *** Joins: ghrust (ghrust@C8693FCB.6A2AE50.F3114085.IP)
[22:36:30] <ghrust> 01[13rust01] 15bors pushed 0 new commits to 06auto: 02http://git.io/gCG7cA
[22:36:30] *** Parts: ghrust (ghrust@C8693FCB.6A2AE50.F3114085.IP) ()
[22:36:31] *** Joins: ghrust (ghrust@F6EE6DE3.6A2AE50.F3114085.IP)
[22:36:31] <ghrust> 01[13rust01] 15bors pushed 2 new commits to 06auto: 02http://git.io/OJzgXg
[22:36:31] <ghrust> 13rust/06auto 14ed268b5 15Alex Crichton: Implement a lock-free work-stealing deque...
[22:36:31] <ghrust> 13rust/06auto 149c387bb 15bors: auto merge of #10678 : alexcrichton/rust/issue-4877, r=pcwalton...
[22:36:32] *** Parts: ghrust (ghrust@F6EE6DE3.6A2AE50.F3114085.IP) ()
[22:38:00] *** Quits: jdm (jdm@13F2CEC5.7672369.D8E68FF6.IP) (Ping timeout)
[22:46:31] *** Joins: ghrust (ghrust@F6EE6DE3.6A2AE50.F3114085.IP)
[22:46:31] <ghrust> 01[13rust01] 15bors 04force-pushed 06auto from 149c387bb to 1490d06ec: 02http://git.io/N3iJvQ
[22:46:31] *** Parts: ghrust (ghrust@F6EE6DE3.6A2AE50.F3114085.IP) ()
[22:52:40] *** Quits: Sharp (Sharp@moz-780FECDA.washdc.fios.verizon.net) (Quit: Sharp)
[23:05:18] *** Joins: dbaupp (Thunderbir@A192CB9D.D5A1DCF.37681C44.IP)
[23:08:53] *** Quits: dbaupp (Thunderbir@A192CB9D.D5A1DCF.37681C44.IP) (Ping timeout)
[23:21:34] *** Joins: ghrust (ghrust@79968228.6A2AE50.F3114085.IP)
[23:21:34] <ghrust> 01[13rust01] 15bors 04force-pushed 06auto from 14916ec7a to 1490d06ec: 02http://git.io/N3iJvQ
[23:21:34] *** Parts: ghrust (ghrust@79968228.6A2AE50.F3114085.IP) ()
[23:21:36] *** Joins: ghrust (ghrust@79968228.6A2AE50.F3114085.IP)
[23:21:36] <ghrust> 01[13rust01] 15bors pushed 2 new commits to 06auto: 02http://git.io/n8Q93A
[23:21:36] <ghrust> 13rust/06auto 14fa509e3 15Alex Crichton: Implement a lock-free work-stealing deque...
[23:21:36] <ghrust> 13rust/06auto 14274402f 15bors: auto merge of #10678 : alexcrichton/rust/issue-4877, r=pcwalton...
[23:21:37] *** Parts: ghrust (ghrust@79968228.6A2AE50.F3114085.IP) ()
[23:27:40] *** Joins: dbaupp (Thunderbir@A192CB9D.D5A1DCF.37681C44.IP)
[23:53:27] <cmr> So... where did trans_expr go / what did it become?
[23:53:30] <cmr> Alternatively:
[23:53:32] <cmr> acrichto: ping
[23:56:34] <Luqman> cmr: hmm i think it's just middle::trans::expr::trans_into
[23:56:35] *** Joins: ghrust (ghrust@DE823A67.6A2AE50.F3114085.IP)
[23:56:35] <ghrust> 01[13rust01] 15bors 04force-pushed 06auto from 14274402f to 1490d06ec: 02http://git.io/N3iJvQ
[23:56:35] *** Parts: ghrust (ghrust@DE823A67.6A2AE50.F3114085.IP) ()
[23:58:06] <cmr> Luqman: Do you know how to construct and set the contents of a struct?
[23:58:46] <cmr> (Context: https://github.com/cmr/rust/commit/96498ca5af95ded17a80b6bdeb86f8dc1eab12ca#diff-d1609daffc6be5b1e5e7158c0f8109deR291)
[23:59:56] <dbaupp> cmr: something in adt.rs?

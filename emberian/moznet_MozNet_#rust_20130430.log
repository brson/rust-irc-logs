[00:00:01] <strcat> can be hoisted out without relying on the compiler
[00:00:23] <nmatsakis> Sodel_the_V: ping
[00:00:49] <strcat> for xs.range(2, 10) |x| {} (something like that)
[00:01:12] <Sodel_the_V> nmatsakis: pong
[00:01:16] <strcat> each/each_reverse seem to cover most cases though
[00:01:32] *** Quits: int3_ (int3_@moz-4F9BAFA5.subnet-248.amherst.edu) (Ping timeout)
[00:03:01] *** Quits: azita (Azita@2557E599.66715431.D25A875A.IP) (Quit: azita)
[00:03:17] <nmatsakis> Sodel_the_V: want to talk about the object method stuff?
[00:03:53] <Sodel_the_V> nmatsakis: Sure :-)
[00:04:20] *** Joins: alisdair (textual@moz-EBE9F394.bchsia.telus.net)
[00:05:05] <nmatsakis> Sodel_the_V: so, did you get a chance to look into the adjustments table?
[00:05:35] <EXetoC> will there be plenty of different range types a la D?
[00:05:39] *** Quits: dbaupp (Thunderbir@moz-5F6D4A2B.lns20.syd6.internode.on.net) (Ping timeout)
[00:05:47] *** Joins: Thad (chatzilla@moz-C35F90AE.tx.res.rr.com)
[00:06:39] <strcat> EXetoC: unlikely
[00:06:48] <strcat> output iterators don't make much sense
[00:07:08] <Luqman> pcwalton: any thoughts regarding 6086
[00:07:09] <strcat> at least I can't see a way that they could be safe for most cases
[00:07:19] <EXetoC> ok
[00:07:39] <pcwalton> Luqman: yeah, the def types are a bit weird cross-crate
[00:07:42] <pcwalton> I'd just land the patch
[00:07:50] <strcat> EXetoC: there's the Iterator trait and there can be another extending it with prev, and another for random seeks
[00:07:51] <pcwalton> file a followup bug on making these consistent
[00:07:52] <strcat> but no output
[00:08:21] <strcat> EXetoC: https://github.com/mozilla/rust/blob/incoming/src/libcore/iterator.rs current state of things
[00:08:53] <Luqman> pcwalton: ok. but newtype structs in general seem to be treated a bit weirdly
[00:09:11] *** Quits: Jesse (jruderman@2557E599.66715431.D25A875A.IP) (Quit: Jesse)
[00:09:17] <pcwalton> how so?
[00:09:26] <EXetoC> neat
[00:11:02] <strcat> still a lot of adaptors missing.
[00:11:16] *** Quits: bent (chatzilla@moz-BE33DA21.fw1.sfo1.mozilla.net) (Quit: ChatZilla 0.9.90-rdmsoft [XULRunner 18.0.2/20130201065344])
[00:11:26] <strcat> cycle, repeat, accumulate, etc.
[00:12:14] *** Quits: tgt (tgt@moz-D59EE478.aztw.cable.virginmedia.com) (Quit: Computer has gone to sleep.)
[00:12:23] *** Quits: lerc (quassel@121-74-236-56.telstraclear.net) (Client exited)
[00:13:15] *** Quits: mschifer1 (Adium@2557E599.66715431.D25A875A.IP) (Quit: Leaving.)
[00:13:25] <Luqman> pcwalton: in `struct Foo(int); let a = Foo(21);` Foo(21) is treated as `expr_call` rather than expr_struct
[00:13:29] *** Joins: lkuper (lkuper@99483B11.2FC96E37.51B6877.IP)
[00:13:43] <pcwalton> Luqman: ew, that's bad
[00:13:50] <pcwalton> maybe we should just fix it at the resolve layer
[00:13:57] <pcwalton> wait
[00:14:01] <pcwalton> it always is expr_call
[00:14:02] <pcwalton> in AST
[00:15:40] <Luqman> sure but it's just a bit weird since it's not exactly calling a function
[00:16:05] <aatch> But there's not syntactic difference
[00:16:07] <pcwalton> Luqman: well, the parser can't figure it out
[00:16:40] <strcat> pcwalton: could you just change it to struct Foo{int, int int}; Foo{1, 2, 3}
[00:16:49] <strcat> missing a comma ;p
[00:17:49] <strcat> or just forbid functions with an uppercase first character and structs with a lowercase first character like haskell :)
[00:18:29] <strcat> would make it easier for humans/editors to parse too. Type and function
[00:20:56] <benh> Finally, an excuse to excise all the TypeName()-style constructor functions
[00:22:17] *** Quits: devinus (devinus@moz-BED25650.austincc.edu) (Quit: Textual IRC Client: www.textualapp.com)
[00:23:38] <pcwalton> let x = Some { 1 };
[00:23:39] <pcwalton> ?
[00:23:55] <pcwalton> that's a big change
[00:24:46] <strcat> pcwalton: I don't think I really like it anyway
[00:25:07] <strcat> enforcing the case would be nice for other reasons...
[00:26:43] *** Joins: intothev01d (Mibbit@9BD0C1B8.C0E26624.D1FAD30E.IP)
[00:27:06] <intothev01d> anyone install Rust through Homebrew?
[00:34:39] <aatch> brson, I was wondering about the android code too when I was poking around there
[00:34:45] <aatch> It doesn't seem to have any use
[00:34:55] *** Quits: lmandel (lmandel@2557E599.66715431.D25A875A.IP) (Quit: lmandel)
[00:35:40] *** Joins: lmandel (lmandel@2557E599.66715431.D25A875A.IP)
[00:36:23] *** Quits: lmandel (lmandel@2557E599.66715431.D25A875A.IP) (Quit: lmandel)
[00:36:27] *** Joins: int3_ (int3_@moz-4F9BAFA5.subnet-248.amherst.edu)
[00:36:34] *** Quits: tcsc (tcsc@moz-A838B260.dhcp.nwtn.ct.charter.com) (Quit: computer sleeping)
[00:38:22] *** Joins: jfredett (jfredett@moz-C01C350.bstnma.fios.verizon.net)
[00:38:51] <brson> I bisected the commit that breaks incoming!
[00:39:00] <brson> "Made fail! and assert! accept both &'static str and ~str, as well as a fmt! like format list."
[00:40:05] *** Quits: Yurume (yurume@AC58A8CE.8A059B47.E313B915.IP) (Ping timeout)
[00:41:02] <brson> I don't think I want to revert that ...
[00:41:30] *** Quits: intothev01d (Mibbit@9BD0C1B8.C0E26624.D1FAD30E.IP) (Quit: http://www.mibbit.com ajax IRC Client)
[00:44:32] *** Joins: cuemin_ (Quemin@8913410.8F293D07.59A90BC7.IP)
[00:44:37] *** Quits: FrozenCow (FrozenCow@moz-9DF5D010.dynamic.upc.nl) (Quit: Leaving)
[00:45:09] *** Quits: cuemin (Quemin@44EEE21C.A6E21E6E.5E500FC7.IP) (Ping timeout)
[00:46:19] *** Quits: seth (seth@moz-BE33DA21.fw1.sfo1.mozilla.net) (Input/output error)
[00:47:02] *** Joins: ghrust (ghrust@moz-4EF5B6E5.rs.github.com)
[00:47:02] <ghrust> 01[13rust01] 15bors merged 06auto into 06incoming: 02http://git.io/W0Fvow
[00:47:02] *** Parts: ghrust (ghrust@moz-4EF5B6E5.rs.github.com) ()
[00:47:33] <pcwalton> yay, modes are dead!
[00:47:42] *** Joins: infynyxx (infynyxx@DB780A29.749BA1D.DCC373F0.IP)
[00:48:13] <strcat> :)
[00:48:18] * Sodel_the_V sings https://www.youtube.com/watch?v=PHQLQ1Rc_Js
[00:48:22] *** Joins: a_make (a__@moz-9BBD1F27.nycmny.fios.verizon.net)
[00:48:25] <Sodel_the_V> Ding-dong, the witch is dead!
[00:48:31] *** Quits: a__ (a__@moz-9BBD1F27.nycmny.fios.verizon.net) (Ping timeout)
[00:48:55] *** Joins: ghrust (ghrust@moz-4EF5B6E5.rs.github.com)
[00:48:55] <ghrust> 01[13rust01] 15bors pushed 0 new commits to 06auto: 02http://git.io/-xd-oQ
[00:48:55] *** Parts: ghrust (ghrust@moz-4EF5B6E5.rs.github.com) ()
[00:48:56] *** Joins: ghrust (ghrust@moz-4EF5B6E5.rs.github.com)
[00:48:56] <ghrust> 01[13rust01] 15bors pushed 3 new commits to 06auto: 02http://git.io/qV3cmA
[00:48:56] <ghrust> 13rust/06auto 140623fb5 15Niko Matsakis: Add debug printouts to malloc/annihilation. These should get compiled...
[00:48:56] <ghrust> 13rust/06auto 14f12766a 15Niko Matsakis: Be more careful about the order in which we read the next field...
[00:48:57] <ghrust> 13rust/06auto 14a77c411 15bors: auto merge of #6114 : nikomatsakis/rust/issue-6112-box-annihilator, r=graydon...
[00:48:59] *** Parts: ghrust (ghrust@moz-4EF5B6E5.rs.github.com) ()
[00:49:14] *** Quits: cuemin_ (Quemin@8913410.8F293D07.59A90BC7.IP) (Ping timeout)
[00:49:47] *** Joins: cuemin (Quemin@2BE45A91.8F293D07.59A90BC7.IP)
[00:50:07] <pcwalton> down to 146 borrow check errors
[00:50:21] <graydon> surely something more chipper
[00:50:25] <graydon> https://www.youtube.com/watch?v=1e8TGVMYfxk perhaps
[00:50:35] <pcwalton> hey, I'm just happy modes are dead
[00:50:39] <pcwalton> well, they still parse
[00:50:44] <pcwalton> need a snapshot to totally remove
[00:50:50] <pcwalton> but they are dropped on the floor
[00:50:52] *** Joins: mib_sp6bg6 (Mibbit@85A7FA2D.365B062.64990CF8.IP)
[00:51:01] <pcwalton> don't even exist in the AST anymore
[00:51:26] <graydon> then "undead" is indeed the appropriate term
[00:51:59] *** Joins: Jesse (jruderman@moz-537BCF9.hsd1.ca.comcast.net)
[00:53:20] *** Quits: mib_sp6bg6 (Mibbit@85A7FA2D.365B062.64990CF8.IP) (Quit: http://www.mibbit.com ajax IRC Client)
[00:53:41] <strcat> nmatsakis: why does the annihilator read the headers on exchange allocs? I thought managed ~ used a different allocator call now
[00:55:34] *** Quits: bnicholson (bnicholson@2557E599.66715431.D25A875A.IP) (Ping timeout)
[00:55:35] <nmatsakis> strcat: maybe in graydon's branch?
[00:56:12] <graydon> strcat: ~ or exchange-heap allocs?
[00:56:21] <graydon> those are (perhaps surprisingly) not the same thing
[00:56:25] <strcat> graydon: exchange heap allocs (Owned ~)
[00:56:35] <strcat> or do non-Owned ~ boxes still use exchange_alloc?
[00:56:42] <graydon> yeah
[00:56:43] <graydon> no
[00:56:44] <graydon> sorry
[00:56:48] <graydon> ~ (@ 10)
[00:56:55] <graydon> is called "shared-unique"
[00:56:59] <graydon> is allocated from the local heap
[00:57:07] <nmatsakis> managed-unique
[00:57:12] <graydon> er, managed-unique, yes
[00:57:16] <graydon> sorry (old habits die hard)
[00:57:20] <strcat> graydon: well I'm wondering why the headers on exchange_alloc/exchange_free things get read
[00:57:36] <nmatsakis> strcat: I think there are only headers if the ~ contains an @
[00:57:40] <graydon> they shouldn't be read very often. where are you observing it?
[00:57:43] <strcat> nmatsakis: there are always headers
[00:57:53] <nmatsakis> strcat: well, I mean ultimately there will only be haders.
[00:57:54] <nmatsakis> *headers
[00:57:56] <graydon> what I'm saying is ~ headers will be read if they're managed-unique
[00:57:58] <nmatsakis> sorry, i'm getting myself confused
[00:58:05] <strcat> graydon: pretty much everywhere, I tried not initializing the header in exchange_alloc
[00:58:08] <nmatsakis> strcat: but anyway, the point of the header is to walk the list of live allocations
[00:58:28] <nmatsakis> so they do get read
[00:58:30] <graydon> strcat: hm. can you give a backtrace of such a read? I don't think we are supposed to look in them often
[00:58:37] <graydon> the live allocs list is only kept for the local heap
[00:58:47] <strcat> graydon: seems like something inlined or in codegen because it's from *everywhere*
[00:58:48] <graydon> I might be forgetting a case
[00:58:59] * nmatsakis realizes he has nothing useful to contribute here
[00:59:01] <graydon> you're sure they're Owned
[00:59:02] <graydon> ?
[00:59:12] <strcat> graydon: well, assuming exchange_alloc is only used for Owned - yes
[00:59:34] <strcat> is that merged already?
[00:59:43] <graydon> which?
[01:00:32] <graydon> managed-unique in general? that is, ~ boxes allocated in the local heap?
[01:00:36] <strcat> using local_malloc/local_free for managed-unique
[01:00:38] <graydon> that's merged presently
[01:00:38] <graydon> yes
[01:01:12] <graydon> oh, probably that then
[01:01:25] <graydon> we _mark_ managed-uniques dynamically with a special header field
[01:01:28] <graydon> so we can tell when we have one
[01:01:31] <graydon> in some ~ paths
[01:01:46] <graydon> so they read the field to check to see if they have one, or an Owned unique
[01:01:50] *** Quits: infynyxx (infynyxx@DB780A29.749BA1D.DCC373F0.IP) (Client exited)
[01:01:50] <strcat> ah
[01:02:11] <graydon> is this a problem?
[01:02:19] <graydon> we can keep the information out-of-band too (eventually)
[01:02:22] <strcat> graydon: well I wanted to remove the headers from non-managed ~
[01:02:29] <graydon> ah
[01:02:31] <strcat> but it didn't turn out well ;p
[01:02:32] <graydon> we're not there yet, sadly
[01:02:47] *** Quits: cuemin (Quemin@2BE45A91.8F293D07.59A90BC7.IP) (Ping timeout)
[01:03:05] *** Joins: cuemin (Quemin@8133B13A.8F293D07.59A90BC7.IP)
[01:03:47] <graydon> heading out now
[01:03:49] <graydon> ttyl
[01:03:51] <strcat> \o
[01:04:02] <graydon> o/
[01:04:05] <graydon> (I suppose?)
[01:04:18] *** Quits: graydon (Adium@A5087023.2354C43D.D8E68FF6.IP) (Quit: Leaving.)
[01:08:15] *** Quits: pcwalton (pcwalton@43CB6079.66715431.D25A875A.IP) (Quit: pcwalton)
[01:12:46] *** Joins: RageOfThou (RageOfThou@moz-CF7139ED.dynamic.telemach.ba)
[01:13:52] *** Quits: MrFahrenheit (RageOfThou@moz-CF7139ED.dynamic.telemach.ba) (Ping timeout)
[01:18:26] *** Joins: bnicholson (bnicholson@moz-E98974C1.hsd1.ca.comcast.net)
[01:19:21] *** Joins: a_m0d|home (a_m0d@moz-9F925EFA.hm.shawcable.net)
[01:23:03] *** Joins: ghrust (ghrust@moz-4EF5B6E5.rs.github.com)
[01:23:03] <ghrust> 01[13rust01] 15bors 04force-pushed 06auto from 14a77c411 to 14f1ddb8d: 02http://git.io/N3iJvQ
[01:23:03] *** Parts: ghrust (ghrust@moz-4EF5B6E5.rs.github.com) ()
[01:23:07] *** Joins: erickt (Adium@49C4075F.3AC15C18.2321E71E.IP)
[01:26:03] *** Joins: ghrust (ghrust@moz-4EF5B6E5.rs.github.com)
[01:26:03] <ghrust> 01[13rust01] 15bors pushed 0 new commits to 06auto: 02http://git.io/-xd-oQ
[01:26:03] *** Parts: ghrust (ghrust@moz-4EF5B6E5.rs.github.com) ()
[01:26:41] <a_m0d|home> Anyone able to help me debug a program with an infinite loop?
[01:26:49] <nmatsakis> a_m0d|home: sure...
[01:26:55] <a_m0d|home> https://gist.github.com/am0d/5486064 somehow runs out of stack space
[01:27:16] <a_m0d|home> no matter how small a vector I try to create
[01:28:06] <tjc> am0d|home: are you on a Mac, by any chance?
[01:28:12] <tjc> a_m0d|home ^
[01:28:18] <a_m0d|home> tjc: No, I'm on Linux
[01:28:29] <a_m0d|home> This is running the incoming branch, pulled a few days ago
[01:28:30] <tjc> ok -- there was a recent bug involving the random number generator on Macs
[01:28:32] <tjc> hmm
[01:28:36] <tjc> it may have affected Linux too
[01:28:40] <nmatsakis> a_m0d|home: there was definitely a bug involving random number generation
[01:28:44] <nmatsakis> that could cause infinite loops
[01:28:53] <nmatsakis> it was only seen on macs, but there is no reason for it to be platform specific
[01:28:59] <tjc> yeah
[01:29:01] <nmatsakis> (in fact, I'm still wondering why that was the case)
[01:29:03] <a_m0d|home> Yes, you're right
[01:29:15] <a_m0d|home> I just replaced that random part with a static int, and it worked
[01:29:21] *** Joins: snowmantw (snowmantw@moz-C707A5F2.dynamic.hinet.net)
[01:29:29] <a_m0d|home> I would not have guessed that that's where the loop was coming from.
[01:30:18] <a_m0d|home> Thanks a lot.  Is there a fix for the random() bug coming soon?
[01:31:12] <tjc> a_m0d|home: it may have been fixed already (today or over the weekend)â€¦ I'm not sure
[01:31:13] <tjc> brson might know
[01:32:20] <a_m0d|home> tjc: Thanks - I'll pull incoming again and see if that fixes it.  I just took a quick look in the issues list, but couldn't see it there.
[01:32:26] <nmatsakis> a_m0d|home: I thought it was fixed
[01:32:29] <nmatsakis> *think
[01:32:35] <nmatsakis> or at least worked around
[01:32:36] <a_m0d|home> Must be filed under something other than "random"
[01:32:49] <a_m0d|home> nmatsakis: I'll let you know in a few minutes
[01:34:23] *** Quits: Diablo-D3 (diablo@moz-52AA8794.port.east.myfairpoint.net) (Quit: This computer has gone to sleep)
[01:40:08] *** Quits: dherman (dherman@moz-6CA476B1.hsd1.ca.comcast.net) (Quit: dherman)
[01:43:12] *** Quits: flipcoder (flipcoder@moz-EE3A28B2.dhcp.rvsd.ca.charter.com) (Quit: Leaving)
[01:48:08] *** Joins: josh (josh@moz-6FB23C25.hvc.res.rr.com)
[01:48:59] *** Quits: disjukr (disjukr@3C1D3822.A5F7C7E2.84F431B6.IP) (Ping timeout)
[01:49:56] *** Joins: disjukr (disjukr@3C1D3822.A5F7C7E2.84F431B6.IP)
[01:51:56] *** Quits: Jesse (jruderman@moz-537BCF9.hsd1.ca.comcast.net) (Quit: Jesse)
[01:52:40] *** Joins: dherman (dherman@moz-6CA476B1.hsd1.ca.comcast.net)
[01:52:40] *** ChanServ sets mode: +o dherman
[01:56:12] *** Quits: dherman (dherman@moz-6CA476B1.hsd1.ca.comcast.net) (Quit: dherman)
[01:56:26] *** Quits: catpig (catpig@moz-1F81F1A7.dip0.t-ipconnect.de) (Quit: Verlassend)
[01:58:54] *** Quits: Jesin (Jessin_@moz-1866A4CC.cc.lehigh.edu) (Ping timeout)
[02:00:05] *** Quits: disjukr (disjukr@3C1D3822.A5F7C7E2.84F431B6.IP) (Connection reset by peer)
[02:00:11] <Thad> brson: grrrrr !  why is it trying to clone here ???  http://pastebin.mozilla.org/2361123
[02:00:41] *** Joins: disjukr (disjukr@3C1D3822.A5F7C7E2.84F431B6.IP)
[02:00:42] *** Quits: EXetoC (ex@moz-2DBEB1E4.customer.t3.se) (Quit: WeeChat 0.4.0)
[02:01:07] <brson> Thad: the configure script tries to automatically keep the submodules up to date
[02:01:11] *** Joins: Jesin (Jessin_@moz-1866A4CC.cc.lehigh.edu)
[02:01:25] <brson> Thad: you can configure with --disable-manage-submodules to keep configure from doing that
[02:01:29] <Thad> brson: ok, so that will continue, or we want that even with Cygwin...right ?
[02:01:46] <brson> yes, is that a problem for cygwin?
[02:02:06] <Thad> trying to see WHAT is the problem... folder location for certs ?
[02:02:51] <Thad> CAfile is there... /usr/ssl/certs is good path
[02:03:15] <Thad> looks like https url is what failed.
[02:03:31] <brson> Thad: maybe http://codeforthesoul.blogspot.com/2012/09/git-error-about-missing-certificates-on.html
[02:04:18] <brson> at one point we were using the git:// protocol for submodules, but it was changed to https I think to get around corporate firewalls
[02:04:45] <brson> bbl
[02:04:46] *** Quits: brson (brson@2557E599.66715431.D25A875A.IP) (Quit: leaving)
[02:05:09] <a_m0d|home> nmatsakis: looks like that random() loop is fixed for me as well.  Thanks
[02:05:27] <Thad> yeap, that is it... git: works and https: doesn't
[02:09:59] *** Quits: disjukr (disjukr@3C1D3822.A5F7C7E2.84F431B6.IP) (Ping timeout)
[02:10:00] <Thad> so... added "ca-certs" to the Cygwin requirements for install.... that works now !
[02:10:10] *** Joins: disjukr (disjukr@3C1D3822.A5F7C7E2.84F431B6.IP)
[02:11:52] *** Quits: disjukr (disjukr@3C1D3822.A5F7C7E2.84F431B6.IP) (Ping timeout)
[02:12:55] *** Joins: disjukr (disjukr@3C1D3822.A5F7C7E2.84F431B6.IP)
[02:13:53] *** Quits: disjukr (disjukr@3C1D3822.A5F7C7E2.84F431B6.IP) (Quit: Leaving)
[02:14:36] <aatch> So I'm just starting to get a handle on date/time stuff, what do people think of my super-early draft: https://gist.github.com/Aatch/0bdc7ceb857a87389eb1 ?
[02:17:02] *** Joins: ghrust (ghrust@moz-4EF5B6E5.rs.github.com)
[02:17:02] <ghrust> 01[13rust01] 15bors merged 06auto into 06incoming: 02http://git.io/igrNPA
[02:17:02] *** Parts: ghrust (ghrust@moz-4EF5B6E5.rs.github.com) ()
[02:18:34] *** Joins: mschifer (Adium@moz-42254FB1.hfc.comcastbusiness.net)
[02:19:12] *** Joins: dherman (dherman@moz-6CA476B1.hsd1.ca.comcast.net)
[02:19:12] *** ChanServ sets mode: +o dherman
[02:20:01] *** Joins: ghrust (ghrust@moz-4EF5B6E5.rs.github.com)
[02:20:01] <ghrust> 01[13rust01] 15bors pushed 0 new commits to 06auto: 02http://git.io/rz0WRg
[02:20:01] *** Parts: ghrust (ghrust@moz-4EF5B6E5.rs.github.com) ()
[02:20:03] *** Joins: ghrust (ghrust@moz-4EF5B6E5.rs.github.com)
[02:20:03] <ghrust> 01[13rust01] 15bors pushed 41 new commits to 06auto: 02http://git.io/01b4DA
[02:20:03] <ghrust> 13rust/06auto 14e47ee77 15Brian Anderson: wip
[02:20:03] <ghrust> 13rust/06auto 146a5c4f6 15Brian Anderson: core::rt: Just some poking at the I/O docs
[02:20:03] <ghrust> 13rust/06auto 141f97e6d 15Brian Anderson: rt: Add rust_dbg_next_port for generating test port numbers
[02:20:05] *** Parts: ghrust (ghrust@moz-4EF5B6E5.rs.github.com) ()
[02:21:50] *** Joins: sonwow (sonwow@5AB4884B.FCC4549.14D5B978.IP)
[02:22:25] *** Quits: Jesin (Jessin_@moz-1866A4CC.cc.lehigh.edu) (Ping timeout)
[02:23:27] *** Joins: Jesin (Jessin_@moz-1866A4CC.cc.lehigh.edu)
[02:24:27] *** Quits: engla (engla@moz-BFD53D48.selucle.dyn.perspektivbredband.net) (Ping timeout)
[02:27:34] *** Quits: cdidd (cdidd@moz-D8ED51E6.broadband.corbina.ru) (Input/output error)
[02:29:26] *** Quits: Jesin (Jessin_@moz-1866A4CC.cc.lehigh.edu) (Ping timeout)
[02:29:55] *** Quits: dherman (dherman@moz-6CA476B1.hsd1.ca.comcast.net) (Quit: dherman)
[02:31:02] *** Joins: Jesin (Jessin_@moz-1866A4CC.cc.lehigh.edu)
[02:31:33] <doomlord> from rustc.rs - pub fn monitor(+f: ....)    ... what does the + mean
[02:32:50] *** Joins: infynyxx (infynyxx@moz-E95B370B.nyc.res.rr.com)
[02:33:17] <tjc> doomlord: it means "pass f by value"
[02:33:18] <erickt> doomlord: ignore it :)
[02:33:21] <tjc> it's out-of-date though
[02:33:27] <tjc> and the code would mean the same thing if you removed the +
[02:33:32] <erickt> it's a mode that's going to be removed soon
[02:33:40] <aatch> pcwalton is working on it
[02:34:05] <aatch> As in, he removed the mode code completely and then got the compiler working again.
[02:34:27] <doomlord> almost like the inverse of void foo(SomeType &f)  in c++ (turning a value from the caller into a reference)
[02:35:09] *** Joins: brson (brson@2557E599.66715431.D25A875A.IP)
[02:35:09] *** ChanServ sets mode: +o brson
[02:38:17] <bjz> strcat doomlord: https://github.com/mozilla/rust/issues/4819#issuecomment-17206675
[02:42:10] <doomlord> i like the div_rem returning a tuple
[02:42:47] <bjz> doomlord: thankyou haskell
[02:43:20] *** Quits: alisdair (textual@moz-EBE9F394.bchsia.telus.net) (Quit: My MacBook Pro has gone to sleep. ZZZzzzâ€¦)
[02:43:35] *** Quits: Benvie (brandon@155E3330.3C2A3393.D4A9B473.IP) (Ping timeout)
[02:44:14] *** Joins: Benvie (brandon@5FD20F9A.53D07D95.EFF8B7BF.IP)
[02:45:00] *** Quits: solancile (solancile@moz-A1CFFAE5.hsd1.wa.comcast.net) (Quit: Leaving)
[02:47:38] *** Quits: an0nymous (an0nymous@moz-A6B0CE4.tx.res.rr.com) (Quit: Leaving)
[02:48:23] <bjz> doomlord: no other feedback? Are you ok with the naming? Again it's bikeshedding, but I do think it's important
[02:49:33] <doomlord> let me see... i'm not as opinionated on int math
[02:50:07] <bjz> heh
[02:50:17] <bjz> floating-point man at heart?
[02:50:29] <doomlord> been using it predominantly for so long
[02:50:38] <bjz> paha, to discrete math
[02:50:49] <doomlord> i was going to ask why there isn't a method "mod", then i realised...
[02:51:41] <doomlord> you'll find the relevant functions from autocomplete mod... so its ok
[02:51:53] *** Joins: an0nymous (an0nymous@CBF46C52.A02070AB.72768D0E.IP)
[02:52:27] <doomlord> does rust have the C % operator
[02:53:00] *** Quits: zz_kimundi (kimundi@moz-30199C65.dip0.t-ipconnect.de) (Ping timeout)
[02:54:13] <erickt> nmatsakis: ping!
[02:54:39] <doomlord> (i guess i use bitwise stuff much more often than modulo)
[02:55:59] <doomlord> perhaps you could add mod_trunc for completeness r.e. the wikipedia page    mod_trunc  mod_floor mod_euclid
[02:56:25] *** Joins: zz_kimundi (kimundi@moz-904E250B.dip0.t-ipconnect.de)
[02:56:45] *** zz_kimundi is now known as kimundi
[02:58:18] <erickt> or brson / tjc, if either of you are much familiar with type checking methods
[03:00:15] *** Quits: a_m0d|home (a_m0d@moz-9F925EFA.hm.shawcable.net) (Quit: Leaving.)
[03:01:01] <tjc> erickt: I'm somewhat familiar; I have to run in a couple minutes, but if it's quick, go ahead :-)
[03:01:10] <erickt> well it depends :)
[03:01:38] <erickt> I'm trying to move the method self_ty into ty::FnSig
[03:02:04] <erickt> I thought it'd be a useful first step for getting &self to be promoted to a real argument
[03:02:38] <tjc> hmm, maybe you're running into what I ran into when I tried to do the same thing
[03:02:41] <tjc> go on, though
[03:02:42] <erickt> but now I'm looking at typeck::check::method, and I can see a couple different potential duplication of things
[03:02:50] <erickt> maybe :)
[03:03:26] <erickt> so first off, typeck::check::method::Candidate has a rcvr_ty, but also has a method, which has a transformed_self_ty
[03:04:30] <tjc> is the rcvr_ty the actual type of the receiver, with the method being the declared type? 
[03:04:32] <erickt> typeck::check::method::confirm_candidate needs to get a FnSig, but it doesn't use candidate.method.sig, but instead calls fn_ty_from_origin to look up the signature
[03:04:32] <tjc> I half-remember this
[03:04:40] *** Parts: mschifer (Adium@moz-42254FB1.hfc.comcastbusiness.net) ()
[03:04:55] <Thad> aatch: Perhaps also make sure that your trait concepts can be extended to help the scientific community.  2 areas that come to mind are Space and Paleontology.  For Space, perhaps look at http://spacepy.lanl.gov/doc/quickstart.html  and for Paleontology , there was a Python package that was ideal for this, but forgot it's name...check PyPi perhaps.
[03:04:55] <erickt> I'm not sure yet, I just discovered the rcvr_ty
[03:06:03] <ILyoan> @pcwalton looks like llvm changed. Is that intended?
[03:06:20] <tjc> erickt: yeah, this is exactly the territory where I got confused. nmatsakis is probably your best bet; he might be around a little later, but certainly tomorrow
[03:06:39] <erickt> ok, i'll ping him if he shows up tonight
[03:06:48] *** Joins: Erik (Erik@moz-252DBA2.hsd1.co.comcast.net)
[03:07:10] <tjc> a "do as I say, not as I do" plea: document as you go along, so that the next person to touch that code won't be as confused as I was :-)
[03:07:20] *** Quits: KindOne (KindOne@moz-B56B503.dynamic.ip.windstream.net) (Quit: killed (ChanServ (Quit Message Spam is off topic.)))
[03:07:42] <erickt> hehe :)
[03:08:07] <erickt> oh, here's one difference. method::fty is a BareFnTy, but fn_ty_from_origin returns a proper ty::t
[03:08:29] <erickt> maybe I'm just getting confused by the same name being used for two separate types
[03:08:39] <tjc> is a BareFnTy an AST type or a ty::t type?
[03:08:52] <erickt> it's a proper first class struct
[03:08:59] <tjc> I mean...
[03:09:29] <tjc> does it represent a type at the AST level (parsed only) or the typechecked level (fully elaborated types as represented by ty::t)?
[03:09:31] *** Quits: brson (brson@2557E599.66715431.D25A875A.IP) (Quit: leaving)
[03:09:36] <erickt> typechecked
[03:09:45] <tjc> ok
[03:10:10] <erickt> there's a ty::sty variant called ty_bare_fn for BareFnTy 
[03:10:28] <tjc> ah ok
[03:10:40] <tjc> so fn_ty_from_origin just "promotes" a BareFnTy to a ty::t?
[03:10:43] <bjz> Erik: https://github.com/mozilla/rust/issues/4819
[03:11:05] <cuemin> So, what's the difference between the vers attribute in pkg.rs and vers in the crate's link attribute?
[03:11:05] *** Joins: ghrust (ghrust@moz-4EF5B6E5.rs.github.com)
[03:11:05] <ghrust> 01[13rust01] 15bors 04force-pushed 06auto from 14ac158ea to 14868b7c1: 02http://git.io/N3iJvQ
[03:11:05] *** Parts: ghrust (ghrust@moz-4EF5B6E5.rs.github.com) ()
[03:11:10] <bjz> Erik: sorry to bring up the bikeshed again
[03:11:23] <bjz> Erik: I'd like to get it sorted though
[03:11:28] <erickt> tjc: no, it takes the candidate.origin and looks up the fn type through a variety of methods
[03:11:46] <tjc> cuemin: the vers attribute in pkg.rs is going to go away and rustpkg will infer the version from the filename
[03:11:54] <tjc> and use that to fill in the vers in the crate's link attribute
[03:12:25] <bjz> Erik: If you have anything to add, could you comment on the issue? that way it's documented
[03:12:32] <cuemin> why use the file's name? shouldn't that stay the same regardless of version?
[03:13:02] <tjc> cuemin: Sorry, not the file name. The directory name: so, foo-0.2 would be the directory for a package called foo, version 0.2
[03:13:18] *** Quits: lkuper (lkuper@99483B11.2FC96E37.51B6877.IP) (Ping timeout)
[03:13:24] <tjc> optionally, you can put an explicit version in the crate file itself -- not pkg.rs anymore -- using the link attribute
[03:13:30] <tjc> but we want to infer defaults as much as possible
[03:13:41] <tjc> most of what I'm talking about isn't implemented yet btw
[03:14:55] <cuemin> no problems. I can see that being difficult to maintain later on, when you're on version 2.0 with a bunch of 1.X's. Has there been any consideration of using git tags to checkout the correct version in a git repository?
[03:15:14] <tjc> cuemin: yes, absolutely...
[03:15:14] <cuemin> or even just check out a branch of a repository, a-la Ruby's Bundler
[03:15:24] <tjc> I mean, yes to inferring the version from the git repository
[03:15:31] <tjc> I think that's even on my list of tasks for rustpkg
[03:15:46] <ssbr> Uhhh, will anything horrifying happen if I compile two rust crates to object files with "rustc -c" and then link them together into one library?
[03:15:46] <tjc> yup -- item 7 at https://github.com/mozilla/rust/wiki/Bikeshed-rustpkg
[03:16:10] <ssbr> I don't know if I should explicitly forbid this in my rust support for distutils (python module build system)
[03:16:20] <tjc> ssbr: if they both have a main() function, I can see where it wouldn't work
[03:16:59] <ssbr> tjc: might it conceivably work if the author of both crates tries to make it work?
[03:17:02] <ssbr> if so, I'll allow it
[03:17:12] <ssbr> (not with two main() functions, obviously, but in general, for libraries...)
[03:17:31] <tjc> ssbr: Yeah. I don't know if we've ever really thought about that, but I guess I don't see a particular reason to disallow it
[03:17:32] *** Joins: KindOne (KindOne@moz-B56B503.dynamic.ip.windstream.net)
[03:17:47] <ssbr> tjc: That sounds pretty reasonable. Thanks :)
[03:17:51] <tjc> np
[03:18:04] <cuemin> tjc: what are your thoughts on a central repository of packages, like rubygems.org? 
[03:18:54] <tjc> cuemin: I don't know if other people on the team have stronger opinions, but it seems like we're trying to avoid a centralized model
[03:19:06] <tjc> like, rustpkg will eventually be able to install from an arbitrary URL that points to a repo
[03:19:21] <tjc> everybody could have their own package database if they want and keep it in their own github repo, and you could pick your own database
[03:19:39] <tjc> it's possible graydon / brson / etc. have thought about this more than me, though
[03:19:39] *** Joins: brendan (brendaneic@35E90EE3.B8B12C49.396B22AD.IP)
[03:20:09] <cuemin> yeah, it's a double edged sword 
[03:20:39] <cuemin> makes getting the correct version of a package easier I'd think, but not nearly as flexable
[03:20:50] <bjz> tjc: when will stage0 be updated again?
[03:20:54] <strcat> tjc: an official repository doesn't make it centralized though - it just has to support adding/removing repos, much like other package managers
[03:21:09] <tjc> strcat: Fair enough
[03:21:25] <tjc> doubtless we'll have a mailing list discussion about this when the time comes
[03:21:38] <cuemin> also, something to think about: if person X's repo goes down for whatever reason, you'd have to find another copy of it somewhere and upate all the packages that point to it
[03:21:46] <doomlord> are rust variables and types in seperate namespaces
[03:22:02] <tjc> doomlord: yes
[03:22:14] <tjc> bjz: once the build is green on all the platforms :-)
[03:22:26] <bjz> tjc: ahh
[03:22:49] <tjc> bjz: there's some linux breakage that brson, I think, was looking at
[03:23:00] <tjc> (new breakage as of today, replacing the longstanding valgrind breakage -- very exciting)
[03:23:06] <bjz> tjc: we're considering a rename of the Operator traits again, would be nice to get it in
[03:23:18] <tjc> cuemin: that's a good point; Graydon and I talked about ways to handle transfer of ownership, though now I can't remember what he said 
[03:23:27] <bjz> tjc: anything to add? https://github.com/mozilla/rust/issues/4819#issuecomment-17206675
[03:23:55] *** Quits: brendan (brendaneic@35E90EE3.B8B12C49.396B22AD.IP) (Ping timeout)
[03:24:48] <tjc> bjz: I'm afraid I didn't read all the comments in that discussion and I'm on my way out (though I know I said a few minutes ago that I was leaving in a few minutes :-)
[03:25:00] *** Joins: Diablo-D3 (diablo@moz-52AA8794.port.east.myfairpoint.net)
[03:25:07] <bjz> tjc: sure np
[03:25:07] <bjz> bye!
[03:25:29] * tjc will get offline so as not to get into another interesting conversation ;-)
[03:25:32] *** Quits: tjc (tjc@A5087023.2354C43D.D8E68FF6.IP) (Quit: Places to go, people to annoy)
[03:25:33] *** cuemin is now known as dymk
[03:25:40] <dymk> might as go by github username
[03:32:58] *** Quits: RageOfThou (RageOfThou@moz-CF7139ED.dynamic.telemach.ba) (Ping timeout)
[03:44:22] *** Joins: brson (brson@51C589B3.EF2694B5.DFAC6AA7.IP)
[03:44:22] *** ChanServ sets mode: +o brson
[03:46:15] <Thad> brson: still plugging away at it guy...
[03:49:16] *** Quits: Jesin (Jessin_@moz-1866A4CC.cc.lehigh.edu) (Ping timeout)
[03:50:04] *** Joins: ghrust (ghrust@moz-4EF5B6E5.rs.github.com)
[03:50:04] <ghrust> 01[13rust01] 15bors 04force-pushed 06auto from 144e0444b to 14868b7c1: 02http://git.io/N3iJvQ
[03:50:04] *** Parts: ghrust (ghrust@moz-4EF5B6E5.rs.github.com) ()
[03:53:32] <doomlord> just discovered "occur" in emacs, i'll take that over header files any day..
[03:53:50] *** Quits: Thad (chatzilla@moz-C35F90AE.tx.res.rr.com) (Quit: ChatZilla 0.9.90 [Firefox 21.0/20130425162858])
[03:53:58] <doomlord> automatically generate a clickable sumary of all declarations in a buffer
[03:57:46] <Diablo-D3> so, uh, taglist in vim?
[03:58:17] *** Joins: erickt1 (Adium@49C4075F.3AC15C18.2321E71E.IP)
[03:58:17] *** Quits: erickt (Adium@49C4075F.3AC15C18.2321E71E.IP) (Connection reset by peer)
[03:58:37] <doomlord> not used vim myself
[04:00:14] *** Quits: jgilbert (jgilbert@2557E599.66715431.D25A875A.IP) (Ping timeout)
[04:01:05] *** Quits: bleibig (bleibig@moz-58EF3B3A.rochester.res.rr.com) (Ping timeout)
[04:01:51] <bjz> Erik: I added doomlord's suggestion: https://github.com/mozilla/rust/issues/4819#issuecomment-17208397
[04:02:00] <bjz> strcat^
[04:02:34] <strcat> bjz: I don't think you should have them if div is already defined that way
[04:02:35] <Erik> bjz: which suggestion?
[04:02:58] <bjz> Erik: look at the comment
[04:03:14] <strcat> just makes the API confusing
[04:03:21] <strcat> will make people think div is something different than div_trunc
[04:03:30] *** Joins: ysuzuki (ysuzuki@moz-A563888C.ics.keio.ac.jp)
[04:03:37] <bjz> strcat: could you comment that on the issue?
[04:03:48] <strcat> ok
[04:03:59] <Erik> bjz: No strong feeling from my side
[04:04:05] <bjz> Erik: sure
[04:04:26] <doomlord> ah so break the  symetry between cases... but make the default clearer, fair enough
[04:04:27] <Erik> I do still wish that "div" and "mod" could become operators instead of functions :-)
[04:04:43] <bjz> Erik: yup
[04:04:46] <bjz> :(
[04:05:17] *** Quits: josh (josh@moz-6FB23C25.hvc.res.rr.com) (Quit: josh)
[04:05:30] *** Joins: snadon (chatzilla@moz-EFE8FD29.mc.videotron.ca)
[04:05:37] <bjz> All I'm looking for is something that's not too confusing
[04:06:12] <strcat> if you have div and div_trunc, that's confusing ;p
[04:06:13] <bjz> I think Quot at least is confusing as it stands
[04:06:24] <bjz> strcat: point taken
[04:06:39] <Erik> I'm honestly not convinced we need more than div_trunc and div_floor
[04:06:40] <strcat> the docstrings should have examples showing what they do
[04:06:48] <bjz> Erik: yup
[04:06:56] <Erik> Euclidian, etc are pretty rare
[04:06:59] <bjz> Erik: euclidean would be excessive
[04:07:03] <Erik> And can be part of a library or something instead
[04:07:07] <bjz> yup
[04:07:20] <bjz> Erik: could you add that to the comments?
[04:07:26] <Erik> Sure
[04:07:30] <bjz> sorry, I'd like it to be documented
[04:07:38] <Erik> np
[04:09:22] *** Quits: bnicholson (bnicholson@moz-E98974C1.hsd1.ca.comcast.net) (Ping timeout)
[04:10:03] <doomlord> i seem to frequently remember writing workarounds to get mod_euclid
[04:10:11] <doomlord> in other languages/contexts
[04:10:18] <Erik> You sure it was euclidian, and not floor?
[04:10:32] <Erik> They're only different when the denominator is negative (i think)
[04:10:44] <doomlord> oh ok
[04:10:52] <doomlord> yes you are right it seems
[04:10:56] *** Joins: mzabaluev (mzabaluev@moz-F3BF265C.dhcp.inet.fi)
[04:11:05] <doomlord> fair enough. mov_floor then
[04:11:07] <strcat> gmp includes ceil division too for some reason ;p
[04:14:48] <bjz> Ok: https://github.com/mozilla/rust/issues/4819#issuecomment-17208698
[04:15:15] <bjz> Sorry, I know this is painful
[04:17:58] *** Quits: jfredett (jfredett@moz-C01C350.bstnma.fios.verizon.net) (Ping timeout)
[04:18:51] *** Quits: PeterSP (peter@moz-4DAF5777.bstnma.fios.verizon.net) (Ping timeout)
[04:18:54] <doomlord> under "arm.rs" in the rust sourcecode i see "arm-apple-darwin" .. but is that anything to do with iOS support (macos!=ios..?)
[04:18:57] *** Joins: PeterSP (peter@moz-4DAF5777.bstnma.fios.verizon.net)
[04:21:41] <bjz> Ok. I'm deciding to make the executive decision to go with `Quot` -> `Div`. I get the feeling we agree on that. Right?
[04:22:11] <doomlord> i'm happy
[04:22:31] <Erik> Fine with me
[04:28:38] *** Joins: youknowone (youknowone@A826BD81.8A0DEF81.38747683.IP)
[04:28:38] *** Quits: youknowone (youknowone@A826BD81.8A0DEF81.38747683.IP) (Z:lined (Open Proxy found on your host. Please visit www.blitzed.org/proxy?ip=115.68.131.49 for more information.))
[04:33:41] *** Quits: mzabaluev (mzabaluev@moz-F3BF265C.dhcp.inet.fi) (Ping timeout)
[04:35:49] *** Joins: dbaupp (Thunderbir@99439820.D5A1DCF.37681C44.IP)
[04:38:26] *** Quits: burntsushi (burntsushi@moz-27A1B1D8.dhcp.oxfr.ma.charter.com) (Ping timeout)
[04:42:07] <bjz> dbaupp: hoy
[04:42:25] *** Quits: Sodel_the_V (user@moz-853663E1.va.shawcable.net) (Quit: off for the night)
[04:43:37] <dbaupp> bjz: not right now, sorry. I'll be around properly in a few hours. :)
[04:43:44] <bjz> sure
[04:44:01] *** Joins: ghrust (ghrust@moz-4EF5B6E5.rs.github.com)
[04:44:01] <ghrust> 01[13rust01] 15bors merged 06auto into 06incoming: 02http://git.io/6LhFfA
[04:44:01] *** Parts: ghrust (ghrust@moz-4EF5B6E5.rs.github.com) ()
[04:46:31] <doomlord> what does it mean blah.rc  says "pub mod other;" in referencing 'other', as opposed to "mod other;" - that will be exposedto users of the 'crate'?
[04:50:28] *** Joins: bnicholson (bnicholson@moz-E98974C1.hsd1.ca.comcast.net)
[04:50:58] *** Joins: burntsushi (burntsushi@moz-27A1B1D8.dhcp.oxfr.ma.charter.com)
[04:55:50] <dymk> hm, is there much of a difference in the use of u32 and uint?
[04:56:03] *** Joins: ghrust (ghrust@moz-4EF5B6E5.rs.github.com)
[04:56:03] <ghrust> 01[13rust01] 15bors pushed 0 new commits to 06auto: 02http://git.io/k9Na1Q
[04:56:03] *** Parts: ghrust (ghrust@moz-4EF5B6E5.rs.github.com) ()
[04:56:05] *** Joins: ghrust (ghrust@moz-4EF5B6E5.rs.github.com)
[04:56:05] <ghrust> 01[13rust01] 15bors pushed 4 new commits to 06auto: 02http://git.io/0XH8SA
[04:56:05] <ghrust> 13rust/06auto 14edc11a9 15Tim Chevalier: rustc: Suppress derived pattern-match-checking errors...
[04:56:05] <ghrust> 13rust/06auto 14d8024e2 15Tim Chevalier: rustc: Change At to Managed and Uniq to Owned
[04:56:07] <ghrust> 13rust/06auto 14849f814 15Tim Chevalier: rustc / test: Fix error message
[04:56:08] *** Parts: ghrust (ghrust@moz-4EF5B6E5.rs.github.com) ()
[04:56:11] <doomlord> uint could be 32,64bit i think
[04:56:24] <doomlord> u32 is always 32bit
[04:56:28] <dymk> oh, I see
[04:57:06] *** Quits: dbaupp (Thunderbir@99439820.D5A1DCF.37681C44.IP) (Ping timeout)
[04:57:31] *** Joins: ysuzuki_ (ysuzuki@moz-A563888C.ics.keio.ac.jp)
[04:57:51] *** Quits: RMF (RMF@moz-FE77A4BA.dsl.telepac.pt) (Ping timeout)
[04:58:03] *** Quits: ysuzuki_ (ysuzuki@moz-A563888C.ics.keio.ac.jp) (Client exited)
[04:58:25] *** Quits: ysuzuki (ysuzuki@moz-A563888C.ics.keio.ac.jp) (Ping timeout)
[04:58:25] *** Joins: ysuzuki_ (ysuzuki@moz-A563888C.ics.keio.ac.jp)
[05:00:07] <dymk> so, in that case, shouldn't libc::size_t be of type uint regardless of platform?
[05:00:39] <doomlord> size_t is the pointer, int is the natural int type (machine register or alu size related) -
[05:00:48] <doomlord> these needn't be the same
[05:01:02] *** Joins: dbaupp (Thunderbir@99439820.D5A1DCF.37681C44.IP)
[05:01:08] <dymk> yeah, but when writing FFIs, size_t changes with the word size of the machine it's being compiled on
[05:01:09] <doomlord> i have seen 32bit adressing plus 64bit int 
[05:01:15] <dymk> hmm
[05:01:27] <Diablo-D3> You know, b-heaps are delicious.
[05:01:28] <doomlord> its not common of course - but its possible
[05:01:31] *** Joins: Heather (Heather@19663F6.F53BAACC.9C17E900.IP)
[05:01:40] <Heather> Good morning
[05:01:47] <Heather> how to concat lists? )
[05:01:48] *** Joins: RMF (RMF@moz-FD7F97AA.dsl.telepac.pt)
[05:01:55] <dymk> is there a rust type that mirrors what libc::size_t does then, and doesn't require explicit casting?
[05:02:39] <dymk> I guess I could just cast all the uints as size_t and call it a day
[05:03:06] <doomlord> i see rust seems to support local functions (functions defined inside another functions scope) -  do these get acess to the parent functions variables?
[05:03:48] <Erik> dmyk: what are you trying to do?
[05:04:24] <dymk> Erik: writing a wrapper around imagemagick, and there's all sorts of functions which take size_t parameters
[05:04:24] <Erik> dymk: size_t is explicitly a pointer concept - are you trying to interface with C code that uses pointers?
[05:04:30] <Erik> Ahhh
[05:04:38] <Jeaye> doomlord: They can capture variables, yeah.
[05:04:53] <dymk> It's strange that it takes size_t, because it is a pointer type, and it's using them for numeric size values
[05:05:08] <dymk> size_t cols, size_t rows, etc
[05:05:12] <Erik> dymk: It's standard practice in C
[05:05:33] <dymk> So, in C, it's not just a pointer type then?
[05:05:33] <Erik> in case you want to have arrays with > 4 billion items on a 64-bit machine
[05:05:38] <doomlord> are these basically just lambdas that are named. same as if you did let someFunc=|x|{ ...}   or let someFunc=fn(x){ ....}
[05:05:51] <Jeaye> Aye.
[05:06:00] <dymk> Erik: yeah, that was what I figured, and I was hoping that rust had some type that did the same as that
[05:06:13] <dymk> uint seems to do that in most cases, but it requires explicit casting
[05:06:18] <Heather> args + [from, to] fails where args is args: &[~str]
[05:06:26] <Erik> dymk: It's related to pointers - it's a type that can hold any pointer - but it's also useful as a type that can index the whole memory, even on a uint8 array
[05:06:36] <Jeaye> doomlord: See https://github.com/Jeaye/q3/blob/master/src/main.rs#L58
[05:06:49] *** Joins: alisdair (textual@moz-EBE9F394.bchsia.telus.net)
[05:07:25] <Erik> Hmm, I wonder if uint in Rust is guaranteed to be no smaller than C's size_t
[05:07:57] <Erik> It seems like uint would have to be as big as size_t to be a useful index type on 64-bit machines.
[05:08:02] *** Quits: brson (brson@51C589B3.EF2694B5.DFAC6AA7.IP) (Quit: leaving)
[05:08:50] <strcat> dymk: uint and size_t are the same on all platforms rust runs on, if that means anything
[05:09:07] *** Quits: dadinck (chatzilla@moz-53C6F830.lightspeed.cicril.sbcglobal.net) (Quit: ChatZilla 0.9.90 [Firefox 19.0.2/20130307122853])
[05:09:07] <erickt1> Erik: if you need size_t, you should use libc::size_t
[05:09:24] <Erik> erickt1: Not me, I'm talking to dymk
[05:09:34] <dymk> strcat: it does, it's just unfortunite that libc::size_t isn't just an alias for uint, as that'd alleviate a lot of casting
[05:09:39] <erickt1> oops, joining in late :)
[05:09:43] <doomlord> i seem to remember the Playstation2 had 64bit int and 32bit adressing- it does happen..   
[05:10:09] <doomlord> you could find some phone os doign something crazy some day
[05:10:22] <erickt1> dymk: i believe we're reserving the right to take a bit or two from a uint if we need to for GC
[05:10:36] <Jeaye> Fucking Github. Can anyone read this text? >.> http://i.imgur.com/BEuWcoO.png
[05:11:08] <erickt1> dymk: although we aren't doing it at the moment
[05:11:15] <doomlord> yikes, that scares me to hear
[05:11:19] <ion> It looks more like a problem with your fontconfig configuration or something.
[05:11:20] <dymk> Jeaye: seems like your browser's default monospace text is wonkey. Reads just fine on win32 chrome. 
[05:11:32] <Erik> erickt1: So is there a Rust type that represents "a good type to use as an array index"
[05:11:33] <Jeaye> hmm
[05:11:40] *** Quits: ysuzuki_ (ysuzuki@moz-A563888C.ics.keio.ac.jp) (Client exited)
[05:11:56] <dymk> erickt1, fair enough, I'll cast for now.
[05:11:56] <erickt1> Erik: uint
[05:12:11] *** Quits: Benvie (brandon@5FD20F9A.53D07D95.EFF8B7BF.IP) (Ping timeout)
[05:12:16] <dymk> erickt1, but what if you've got 32 bit addressing and 64 bit int?
[05:12:22] <ion> jeaye: http://imm.io/14sfu
[05:12:24] <Erik> OK. 32-bit is dying anyhow, and that's the only place a few bits matter
[05:12:26] <doomlord> anyone here enocunterd 'x32' (64bit x86 mode -  16registers,but with 32bit pointers...)
[05:12:33] <doomlord> ^^^^
[05:12:51] <strcat> doomlord: yes but atm it's entirely a userland arch for an x86_64 linux kernel
[05:12:58] <Jeaye> ion: Ahh, that's still pretty shitty. The color for comments is terrible.
[05:13:00] <doomlord> before claiming 32bit is dying- its used in phones, which are really important, andthere's the x32 optimization
[05:13:05] *** Joins: Benvie (brandon@5FD20F9A.53D07D95.EFF8B7BF.IP)
[05:13:16] <Erik> doomlord: Phones are going 64-bit next year
[05:13:25] <Erik> Rust will not be big by next year
[05:13:36] <ion> jeaye: True, their choice of colors could be better. But at least this font rendering is readable.
[05:13:37] <doomlord> 64bit pointers everywhere is wasteful
[05:13:43] <Jeaye> Aye.
[05:13:54] <Jeaye> Must be a problem in my font rendering.
[05:13:55] <doomlord> you should be praying for something like x32 mode
[05:14:03] <Erik> doomlord: That's why we code everything in hex. Then you don't have to use constants.
[05:14:05] <bjz> Jeaye: your OS needs better font rendering :P
[05:14:17] <Erik> http://catb.org/jargon/html/story-of-mel.html
[05:14:30] <Jeaye> bjz: Hey now! :P
[05:14:37] <bjz> :)
[05:15:05] <erickt1> dymk: shouldn't be a problem. rust should handle all the machinery to make sure vecs work with uints
[05:15:17] <Erik> doomlord: Or is Mozilla just sensitive about it's 32-bit single-process browser? :-)
[05:15:25] <erickt1> it's only when you're communicating with C that it's an issue
[05:15:29] <strcat> Erik: firefox isn't '32-bit'
[05:15:46] <Diablo-D3> er, my firefox build right here is 64 bit
[05:15:49] <doomlord> an array of 32bit processes on a 64bit machine
[05:15:54] <doomlord> 32bit is a sweetspot IMO
[05:16:05] <Erik> Shows up as Firefox *32 for me - if you're not shipping 64-bit on Windows, it doesn't much matter
[05:16:48] <strcat> they make 64-bit builds on linux and OS X, but everyone uses distro builds on linux anyway
[05:17:04] <doomlord> a setup that would make sense IMO is a machine with 32bit cpu memory adressing,and 64bit adressing for graphics resources
[05:17:08] <Erik> doomlord: It's a standard ease-of-use vs efficiency issue. 64-bit is easier to program, so it will win out.
[05:17:27] <Erik> (easier than several cooperating 32-bit procecesses, that is)
[05:17:48] <doomlord> but isn't rust good at co-ordinating multiple processes :)
[05:17:56] <Erik> Is it?
[05:18:07] <Erik> I'm pretty sure it's still single-process at the OS level
[05:18:12] <doomlord> and who knows what the future holds
[05:18:22] <Erik> 64-bit is what it holds :-)
[05:18:28] <strcat> afaik it doesn't have multiprocessing at all right now...
[05:18:30] <erickt1> rust doesn't do multiprocess yet.
[05:18:52] <erickt1> you can fork a process, but there's no special machinery built up on it yet
[05:19:05] <strcat> erickt1: probably not as simple as forking
[05:19:08] <Erik> Yeah, I'm just ragging on Doomlord
[05:19:18] <strcat> you only get the current thread context when you fork so the locks will be all wrong
[05:19:30] <strcat> is there a libuv fork function that's exposed?
[05:19:45] <erickt1> strcat: ah right, it's more of a fork-exec or spawn syscall
[05:19:48] *** Joins: SimonSapin (simon@moz-C4A83ED9.net-89-2-126.rev.numericable.fr)
[05:21:22] <dymk> so I guess that fail!() won't also come with a stack trace any time soon then, eh?
[05:21:43] <erickt1> dymk: no, but you can use gdb and break on upcall_fail
[05:21:50] <erickt1> then do bt to get a stack trace
[05:22:09] <dymk> ah, gdb
[05:22:21] <dymk> my liver can take the continued abuse, alright
[05:22:29] <dymk> ;)
[05:27:34] <dymk> well, it crashes, but at least most of the tests run
[05:29:52] *** kimundi is now known as zz_kimundi
[05:31:06] *** Joins: lucian (lucian@moz-22A14C6A.cable.virginmedia.com)
[05:32:01] *** Joins: ghrust (ghrust@moz-4EF5B6E5.rs.github.com)
[05:32:02] <ghrust> 01[13rust01] 15bors 04force-pushed 06auto from 143034f2a to 1448f50ac: 02http://git.io/N3iJvQ
[05:32:02] *** Parts: ghrust (ghrust@moz-4EF5B6E5.rs.github.com) ()
[05:32:03] *** Joins: ghrust (ghrust@moz-4EF5B6E5.rs.github.com)
[05:32:03] <ghrust> 01[13rust01] 15bors pushed 3 new commits to 06auto: 02http://git.io/ueBV8A
[05:32:03] <ghrust> 13rust/06auto 14e4ca2da 15gifnksm: libstd: remove implicit copying of BigInt/BigUint
[05:32:03] <ghrust> 13rust/06auto 14ffa31d2 15gifnksm: libstd: modify wrong shift width....
[05:32:04] <ghrust> 13rust/06auto 1484e22f2 15bors: auto merge of #6108 : gifnksm/rust/bigint-shift-bug, r=brson...
[05:32:07] *** Parts: ghrust (ghrust@moz-4EF5B6E5.rs.github.com) ()
[05:32:59] *** Quits: lucian (lucian@moz-22A14C6A.cable.virginmedia.com) (Ping timeout)
[05:34:12] *** Joins: Cromulent (Cromulent@moz-5EAC0C2F.cable.virginmedia.com)
[05:34:26] *** Quits: int3_ (int3_@moz-4F9BAFA5.subnet-248.amherst.edu) (Client exited)
[05:35:39] *** Quits: erickt1 (Adium@49C4075F.3AC15C18.2321E71E.IP) (Quit: Leaving.)
[05:36:48] <doomlord> wahts the likelyhood you will end up losing a bit for GC - this is scary to hear its being considered, for someone basically looking for a C++ replacement
[05:38:10] *** Parts: Heather (Heather@19663F6.F53BAACC.9C17E900.IP) ()
[05:38:37] <aatch> doomlord, Rust has always had a garbage collector
[05:39:03] <aatch> It's used for `@`-ptrs
[05:39:44] <aatch> It's just that it's a ref-counted system that doesn't actually work very well.
[05:41:07] <doomlord> i realise it has GC - which you can avoid with ~  .. but the concept that the data-layout might *always* need space for some sort of tagging (even if you;'re not using it ) is what causes fear for me. 
[05:41:34] *** zz_kimundi is now known as kimundi
[05:41:39] <aatch> I don't see why that would happen
[05:42:15] <aatch> @'s are boxes
[05:42:36] <doomlord> yeah if all the tracing info is overhead inthe @ptrs themselves, that is fine
[05:42:46] *** Joins: Axord (xord@moz-C3CCF156.lsanca.dsl-w.verizon.net)
[05:43:28] <aatch> I'm pretty sure that Rust uses a shadow stack, or at least something similar
[05:43:50] <Erik> this was just posted: 07<erickt1> 01dymk: i believe we're reserving the right to take a bit or two from a uint if we need to for GC01
[05:43:53] <aatch> All I know is that there is a crate-map used to start the garbage collector
[05:44:26] <Erik> so they are reserving the possibility of adding overhead
[05:46:11] <aatch> by tagging pointers.
[05:47:07] *** Joins: ysuzuki (ysuzuki@moz-F333A8C8.st.keio.ac.jp)
[05:47:47] <aatch> And again, it's likely only to be on @-pointers
[05:48:10] *** Joins: Kingsley (Kingsley@moz-2C05952E.bchsia.telus.net)
[05:48:12] <aatch> ~-ptrs are freed deterministically
[05:48:28] <Erik> I doubt that @int would be a different size than ~int
[05:48:50] <Erik> that's just too confusing
[05:49:01] <aatch> Well currently they are
[05:49:15] <aatch> at runtime, ~ & and * are identical
[05:49:32] <aatch> @ is the odd one out.
[05:50:11] <Erik> Wait, @int is different than the other ints? It will take up more RAM, of course, but it should have the same programmer-visible behavior
[05:50:30] <aatch> What?
[05:50:38] <aatch> I'm getting confused here.
[05:50:44] <Erik> me too
[05:50:48] <aatch> I thought we were talking size?
[05:51:14] <Erik> By my reading, erickt1 said that a few user-visible bits might be taken away at some point in the future
[05:51:32] <aatch> Erik, that would be mad. It's tagging the pointers themselves
[05:51:39] <Erik> which would be a programmer/user-visible overhead of garbage collection
[05:51:51] <Erik> Read erickt1's post. Isn't that what is says?
[05:52:09] <aatch> but how would that change how you use the pointers?
[05:52:20] <Erik> I doubt that something like that would happen - it'd be to hard to program and slow to run
[05:52:43] <Erik> ... wait, pointers? Rust doesn't have pointers
[05:53:01] <Erik> Well, not C-like pointers - it has managed pointers of various kinds
[05:53:03] <aatch> Yes it does, it just doesn't always call them pointers
[05:53:18] <Erik> right, which it can choose to manage in any way it wants - including tag bits
[05:53:22] <aatch> And `*` which is a raw pointer
[05:53:38] <Erik> Yes, I haven't needed unsafe pointers in anything I've done.
[05:53:51] <Erik> Anyhow, I think we agree.
[05:54:22] <Erik> Or at least are talking past each other
[05:55:05] <aatch> I think so
[05:55:17] <tiffany> *, ~, &, and @ are all pointers from a computer science perspective, being unsafe or not, having additional information stored alongside them, and how their usage denotes the lifespan of objects they contain doesn't change what they are
[05:57:02] *** Quits: Cromulent (Cromulent@moz-5EAC0C2F.cable.virginmedia.com) (Quit: KVIrc 4.2.0 Equilibrium http://www.kvirc.net/)
[05:57:49] <Erik> Right. I was just keying off erickt1's comment about "taking bits" from a uint. That may have been what doomlord was referencing 15 minutes ago in terms of GC overhead.
[05:58:01] <Erik> I agree that it would be crazy to have uint not be 32/64 bits
[06:04:24] *** Joins: int3_ (int3_@moz-4F9BAFA5.subnet-248.amherst.edu)
[06:04:26] *** Quits: int3_ (int3_@moz-4F9BAFA5.subnet-248.amherst.edu) (Client exited)
[06:04:27] *** Joins: int3_ (int3_@moz-4F9BAFA5.subnet-248.amherst.edu)
[06:06:45] <ssbr> Mmmmf. So my Rust function is callable from C whether or not I define the function as `extern "C"`, what seems to matter is #[no_mangle]
[06:07:19] <ssbr> are `extern "C"` functions only for passing function pointers into C code?
[06:08:52] *** Joins: robertknight (robertknig@moz-54528EE0.wby.mendeley.com)
[06:11:12] *** Quits: Erik (Erik@moz-252DBA2.hsd1.co.comcast.net) (Quit: ~ Trillian - www.trillian.im ~)
[06:13:13] <bjz> ssbr: we can't call extern function pointers from Rust code yet :(
[06:13:25] <bjz> it's currently in progress
[06:13:30] <ssbr> That's not what I mean :(
[06:13:49] <bjz> ahh
[06:13:50] <ssbr> I mean I can't seem to tell the difference between extern and non-extern functions, except that non-extern functions can't be passed to things that expect *u8
[06:13:59] <ssbr> (which apparently is how I pass function pointers to C)
[06:14:00] <bjz> yeah I'm not sure
[06:14:11] <bjz> sorry
[06:14:16] <ssbr> but C seems to be able to call non-externed functions just fine. Maybe that's a quirk of my particular setup?
[06:14:21] <bjz> might be a question for nmatsakis
[06:14:42] <ssbr> nmatsakis: If you get a chance...!
[06:14:50] <bjz> (not sure if he's afk right now)
[06:17:02] <ssbr> That's fine, I can wait. :)
[06:18:34] *** Joins: jgilbert (jgilbert@moz-E7782931.hsd1.ca.comcast.net)
[06:19:45] *** Quits: SimonSapin (simon@moz-C4A83ED9.net-89-2-126.rev.numericable.fr) (Ping timeout)
[06:20:28] *** Quits: alisdair (textual@moz-EBE9F394.bchsia.telus.net) (Quit: My MacBook Pro has gone to sleep. ZZZzzzâ€¦)
[06:21:32] * bjz sometimes gets annoyed with operator overloading.
[06:22:33] *** Quits: rusti (rusti@moz-54F7FD49.cpe.net.cable.rogers.com) (Ping timeout)
[06:22:49] *** Joins: rusti (rusti@moz-54F7FD49.cpe.net.cable.rogers.com)
[06:23:49] *** Quits: dymk (Quemin@8133B13A.8F293D07.59A90BC7.IP) (Ping timeout)
[06:24:24] <bjz> rusti: println("rusti: println(\"hi\")");
[06:24:32] *** Quits: rusti (rusti@moz-54F7FD49.cpe.net.cable.rogers.com) (Ping timeout)
[06:24:48] * bjz feels snubbed
[06:24:56] *** Joins: rusti (rusti@moz-54F7FD49.cpe.net.cable.rogers.com)
[06:24:58] <xenocons> rusti: 
[06:25:06] <xenocons> rusti, noooooooooooooooooooooooooooooooo
[06:25:08] <bjz> rusti: println("rusti: println(\"hi\")");
[06:25:44] * bjz wonders what would happen if he gave rusti a quine
[06:26:01] *** Joins: ghrust (ghrust@moz-4EF5B6E5.rs.github.com)
[06:26:01] <ghrust> 01[13rust01] 15bors merged 06auto into 06incoming: 02http://git.io/ueBV8A
[06:26:01] *** Parts: ghrust (ghrust@moz-4EF5B6E5.rs.github.com) ()
[06:26:07] <bjz> I'm guessing rusti can't compile its own programs
[06:26:32] <bjz> rusti: "rusti: \"hi\""
[06:26:38] *** Quits: rusti (rusti@moz-54F7FD49.cpe.net.cable.rogers.com) (Ping timeout)
[06:26:47] <bjz> ha
[06:26:52] <dbaupp> bjz: I tried it a while ago... it ignores itself :(
[06:26:57] *** Joins: rusti (rusti@moz-54F7FD49.cpe.net.cable.rogers.com)
[06:26:58] <bjz> strcat: your bot hates me
[06:28:49] *** Joins: berak (chatzilla@F62FEE4.6062171A.1A5CC7E5.IP)
[06:29:03] *** Joins: ghrust (ghrust@moz-4EF5B6E5.rs.github.com)
[06:29:03] <ghrust> 01[13rust01] 15bors pushed 0 new commits to 06auto: 02http://git.io/Wfwjxw
[06:29:03] *** Parts: ghrust (ghrust@moz-4EF5B6E5.rs.github.com) ()
[06:29:22] *** Quits: strcat (strcat@moz-54F7FD49.cpe.net.cable.rogers.com) (Ping timeout)
[06:31:16] *** Quits: dbaupp (Thunderbir@99439820.D5A1DCF.37681C44.IP) (Ping timeout)
[06:31:57] *** Parts: berak (chatzilla@F62FEE4.6062171A.1A5CC7E5.IP) ()
[06:33:51] <Jeaye> bjz: Doesn't accept them.
[06:34:32] *** Quits: infynyxx (infynyxx@moz-E95B370B.nyc.res.rr.com) (Client exited)
[06:34:43] <pascal> I'm trying to build bindings for libexpat and getting an error about linking alloca(). Is there something I can do about that?  http://pastebin.com/9iyQyx9a
[06:35:19] *** Joins: haard (fredrik@18E6EC45.6A26450D.BE04C429.IP)
[06:41:24] <aatch> pascal, it cant find '_alloca'
[06:42:15] <aatch> is that the right function name?
[06:45:39] *** Quits: jgilbert (jgilbert@moz-E7782931.hsd1.ca.comcast.net) (Ping timeout)
[06:46:41] *** Joins: BitPuffin (quassel@moz-8370D1B9.bredband.comhem.se)
[06:47:42] <kimundi> doomlord: actually I think local functions can not use outer values, only closures can
[06:47:57] *** Joins: BizarreCake (BizarreCak@32C9829A.151E84E7.561471F8.IP)
[06:49:08] <doomlord> ok. so they're more about not poluting the namespace?
[06:51:04] *** Joins: xazax (Mibbit@6655692F.3B222813.3F580572.IP)
[06:51:35] *** Joins: infynyxx (infynyxx@moz-E95B370B.nyc.res.rr.com)
[06:52:27] *** Quits: snowmantw (snowmantw@moz-C707A5F2.dynamic.hinet.net) (Ping timeout)
[06:54:13] *** Quits: sp3d (a@moz-17CB39F1.fidnet.com) (Ping timeout)
[06:57:38] *** Joins: tcsc (tcsc@moz-A838B260.dhcp.nwtn.ct.charter.com)
[06:58:22] <pascal> aatch: Okay, I removed it (bindgen somehow added it) and it compiles now - thanks
[07:04:14] <kimundi> doo
[07:04:24] <kimundi> doomlord: yeah
[07:05:12] *** Joins: SimonSapin (simon@moz-58CD503D.fbx.proxad.net)
[07:05:48] <kimundi> Hm, interesting failure my patch uncovered...
[07:06:06] <kimundi> or caused...
[07:06:47] <Jeaye> Why is the Div trait only stage0?
[07:08:03] *** Joins: ghrust (ghrust@moz-4EF5B6E5.rs.github.com)
[07:08:03] <ghrust> 01[13rust01] 15bors 04force-pushed 06auto from 1483f6733 to 1484e22f2: 02http://git.io/N3iJvQ
[07:08:03] *** Parts: ghrust (ghrust@moz-4EF5B6E5.rs.github.com) ()
[07:08:07] *** Joins: ghrust (ghrust@moz-4EF5B6E5.rs.github.com)
[07:08:07] <ghrust> 01[13rust01] 15bors pushed 2 new commits to 06auto: 02http://git.io/lNTseA
[07:08:07] <ghrust> 13rust/06auto 14c1fdace 15Brian Anderson: core: Replace uses of 'drop' in task module with 'finally'. #5379
[07:08:07] <ghrust> 13rust/06auto 145917873 15bors: auto merge of #6113 : brson/rust/task-drop, r=graydon
[07:08:07] *** Parts: ghrust (ghrust@moz-4EF5B6E5.rs.github.com) ()
[07:09:16] <kimundi> Jeaye: It got renamed to Quot
[07:09:24] <Jeaye> Ahh
[07:09:42] <kimundi> Jeaye: But will ptomably changed back
[07:09:55] <Jeaye> Why's that?
[07:11:17] <kimundi> It got changed so that / and % is connistently named with the mathematical functions they model
[07:12:27] <kimundi> But then someone noticed that those operations are exactly oposite for floats
[07:14:37] <kimundi> so, both the names div/mod and quot/rem are either wrong if talking about integer division or if talking about float division
[07:14:40] *** Quits: snadon (chatzilla@moz-EFE8FD29.mc.videotron.ca) (Quit: ChatZilla 0.9.90 [Firefox 21.0/20130423212553])
[07:15:30] <kimundi> So, the least confusing is to keep the old behavior
[07:17:47] *** Joins: hmax (hmax@moz-15514FA1.yandex.net)
[07:22:52] *** Quits: KindOne (KindOne@moz-B56B503.dynamic.ip.windstream.net) (Ping timeout)
[07:23:30] *** Quits: devbug (quassel@moz-E1DE087C.bchsia.telus.net) (Client exited)
[07:34:16] *** Quits: heftig (heftig@moz-14CE70B0.dip0.t-ipconnect.de) (Ping timeout)
[07:34:43] *** Quits: bheylin (bheylin@moz-3D24C757.static.chello.nl) (Ping timeout)
[07:35:09] *** Quits: ysuzuki (ysuzuki@moz-F333A8C8.st.keio.ac.jp) (Client exited)
[07:35:12] <bjz> Jeaye: lets just say it's been a bit of an ordeal.
[07:35:37] <bjz> Jeaye: but it's good to have the discussion now
[07:35:46] <bjz> Jeaye: as opposed to later
[07:36:22] *** Joins: boggle (boggle@moz-5FB508BE.dip0.t-ipconnect.de)
[07:36:35] *** Joins: bheylin (bheylin@moz-3D24C757.static.chello.nl)
[07:36:51] *** Quits: thou (thou@moz-1C1CA9F7.fasttrackcomm.net) (Input/output error)
[07:39:44] *** Joins: KindOne (KindOne@786EFC2.E114B4AE.EC6A1518.IP)
[07:40:11] *** Joins: heftig (heftig@moz-2073F5D0.dip0.t-ipconnect.de)
[07:44:29] *** Joins: lucian (lucian@moz-22A14C6A.cable.virginmedia.com)
[07:45:38] <joshua_> well, that wasn't too bad
[07:46:04] <joshua_> I decided to try to teach myself rust 0.6 by writing an assignment for a Coursera class I'm taking in it; the results were pretty good
[07:46:15] *** Quits: lucian (lucian@moz-22A14C6A.cable.virginmedia.com) (Ping timeout)
[07:46:59] <joshua_> performance was excellent, with more-or-less obvious implementations (i.e., call vec::reserve in advance if you have to, and don't do *totally* stupid things), but it seems to have trounced other people posting on the forums for this class
[07:47:11] <joshua_> (the result was about 230 lines of Rust for a more-or-less functional ASIC router)
[07:53:02] *** Joins: ghrust (ghrust@moz-4EF5B6E5.rs.github.com)
[07:53:02] <ghrust> 01[13rust01] 15bors 04force-pushed 06auto from 145917873 to 1484e22f2: 02http://git.io/N3iJvQ
[07:53:02] *** Parts: ghrust (ghrust@moz-4EF5B6E5.rs.github.com) ()
[07:53:11] <aatch> joshua_, you should post the code as an example.
[07:53:29] <joshua_> I'm not sure I can (at least, until the class ends).
[07:53:36] <aatch> fair enough
[07:53:51] <ssbr> aatch: by the way, thanks again for all your help
[07:53:59] <ssbr> I have put my code up ( https://bitbucket.org/devin.jeanpierre/pyrite )
[07:54:33] <joshua_> aha, their solution is 500 lines of C++, of which 100 is the core algorithm
[07:54:35] <ssbr> (it doesn't use your additions to rustc yet, but, still :>)
[07:54:39] <ssbr> joshua_: Ouch
[07:54:42] <ssbr> joshua_: nicely done! :)
[07:54:47] *** Joins: fabiand (fabiand@moz-A27A2041.adsl.alicedsl.de)
[07:55:21] <aatch> ssbr, that reminds me, I need to update my pull req
[07:55:45] <joshua_> I would say the most painful thing was I/O (I found myself *really* wishing I had, say, fscanf!(); when I did a previous assignment in Lua, the I/O bits were basically effortless)
[07:56:03] *** Joins: ghrust (ghrust@moz-4EF5B6E5.rs.github.com)
[07:56:03] <ghrust> 01[13rust01] 15bors pushed 0 new commits to 06auto: 02http://git.io/Wfwjxw
[07:56:03] *** Parts: ghrust (ghrust@moz-4EF5B6E5.rs.github.com) ()
[07:56:04] *** Joins: ghrust (ghrust@moz-4EF5B6E5.rs.github.com)
[07:56:04] <ghrust> 01[13rust01] 15bors pushed 2 new commits to 06auto: 02http://git.io/pMU-wg
[07:56:04] <ghrust> 13rust/06auto 149ddcf1c 15Brian Anderson: test: Remove run-pass/too-much-recursion.rs...
[07:56:04] <ghrust> 13rust/06auto 14bc65ae4 15bors: auto merge of #6118 : brson/rust/too-much-recursion, r=thestinger...
[07:56:04] *** Parts: ghrust (ghrust@moz-4EF5B6E5.rs.github.com) ()
[07:56:15] <aatch> joshua_, yeah, hence why the IO layer is being re-written
[07:56:59] <joshua_> nod
[07:57:01] *** Joins: dbaupp (Thunderbir@moz-8651256C.lns20.syd6.internode.on.net)
[07:57:04] *** Quits: Jeaye (Jeaye@moz-FD505E54.hsd1.ca.comcast.net) (Quit: zzzZZZzzz)
[07:57:17] *** Quits: dbaupp (Thunderbir@moz-8651256C.lns20.syd6.internode.on.net) (Quit: dbaupp)
[07:57:21] *** Joins: dbaupp (Thunderbir@moz-8651256C.lns20.syd6.internode.on.net)
[07:57:29] <dbaupp> bjz: ping
[07:57:30] <joshua_> aha, okay, the official solution did 'bench5' in 1.14sec, whereas mine did it in 1.00sec (though I am also running on a basically top-of-the-line Ivy Bridge mobile processor, and I have no idea what they ran their reference on)
[07:57:53] <ssbr> If I wanted to get C header files with prototypes for extern'd Rust functions, should I try to extend the rust compiler to spit those out, or should I parse the rust files separately (maybe with the help of rustc --pretty)?
[07:58:35] <joshua_> other annoyances were having to manually implement Eq for things for which it had an 'obvious' implementation (basically the only word of Haskell I know is 'deriving Eq', and I felt like I really wanted that here); in particular, Eq *really* should be automatic for enums that store no data
[07:58:56] <aatch> joshua_, we have deriving eq
[07:59:02] <aatch> #[deriving(Eq)]
[07:59:10] <aatch> If not, then we should
[07:59:22] <ssbr> joshua_: the different machines ruin the comparison :(
[07:59:35] <ssbr> you should run their solution on your machine to compare
[07:59:52] <joshua_> yeah, their machine is not accessible :-)
[08:00:12] <joshua_> the course is actually set up very nicely -- they give you benchmarks to execute, and then you upload your output, so they never have to execute your code
[08:00:40] <aatch> ssbr, you should be able to extract the extern information from the crate metadata
[08:00:59] <ssbr> aatch: I'm not familiar with crate metadata.
[08:01:08] <joshua_> aatch, well, then.   1 file changed, 2 insertions(+), 12 deletions(-)
[08:01:12] <aatch> https://github.com/mozilla/rust/wiki/Note-metadata-format
[08:01:14] <joshua_> thanks :-)
[08:01:37] <aatch> So #[deriving(Eq)] exists? Good.
[08:02:15] <dbaupp> aatch: and deriving(Ord,TotalOrd,TotalEq) as of about 2 weeks ago :)
[08:02:21] <joshua_> Not only that, but you can derive Ord, too!  But not in any documented way.
[08:02:44] <ssbr> aatch: This is data that's put in the compiler output?
[08:02:46] <aatch> pcwalton is keen on making sure that boilerplate impl's can just be derived
[08:03:01] <joshua_> there was discussion of #[deriving_ord(field1, ...)] ... how does that fit in with the deriving(Ord) syntax?
[08:03:08] <aatch> ssbr, it's inserted into one of the sections of the crate
[08:03:29] <dbaupp> joshua_: I was thinking of doing deriving(Ord(field1,...))
[08:03:29] <aatch> The '.note.rustc' section to be precise
[08:03:42] <joshua_> hmm --
[08:03:42] <joshua_> router.rs:102:11: 102:25 error: unknown `deriving` trait: `Ord`
[08:03:42] <joshua_> router.rs:102 #[deriving(Ord(pathcost))] struct Wavefront {
[08:03:42] <joshua_>                          ^~~~~~~~~~~~~~
[08:03:48] <ssbr> aatch: I don't know what a crate is, other than a .rc file
[08:03:48] <aatch> ssbr, it's how rust gets away without header files
[08:03:50] <dbaupp> That doesn't work
[08:03:59] <dbaupp> (yet)
[08:04:02] <ssbr> do you mean the .dll file that results? (What about the .o file from rustc -c?)
[08:04:07] <aatch> A crate is the actual output
[08:04:11] <ssbr> Okay.
[08:04:14] <aatch> So a .dll or .so
[08:04:20] <joshua_> I get the same result for 'deriving(Ord)'.
[08:04:32] <joshua_> Oh, wait, 'as of about 2 weeks ago'.  I'm running 0.6, so I probably don't ahve that.
[08:04:33] <dbaupp> joshua_: yeah, it's not in 0.6 yet
[08:04:42] <ssbr> aatch: ah, that would be useful.
[08:04:53] <joshua_> Well.  Hopefully it never will be in 0.6 ;-)
[08:05:07] <dbaupp> true
[08:05:08] <ssbr> aatch: Thanks. :)
[08:05:22] <aatch> You can also poke around in rustc::metadata to get some ideas
[08:05:55] <ssbr> I really hope this is generated in the object file, but I'm going to guess not.
[08:06:07] <joshua_> I'll upload my code to Pastebin with an hour or so timebomb, for the interested, which should at least keep it out of truly opportunistic cheaters.
[08:06:17] <ssbr> Maybe I should just settle on extension modules being multiple shared libraries -- one for the crate, one for the extension module that wraps the crate
[08:06:20] <ssbr> that'd resolve a lot of issues
[08:06:27] <ssbr> I'm not sure if it adds any.
[08:06:57] <joshua_> Ha.  pastebin.m.o hasn't Rust highlighting.
[08:08:04] *** Joins: ikashkuta (Mibbit@moz-97F6F4D9.com)
[08:08:11] <ssbr> Thanks again :)
[08:08:19] <aatch> ssbr, the .o file has .note.rustc
[08:08:32] *** Joins: ysuzuki (ysuzuki@moz-F333A8C8.st.keio.ac.jp)
[08:08:46] <ssbr> aatch: That is so cool. Thank you :)
[08:08:59] <aatch> objdump to the rescue!
[08:09:24] <ssbr> Man, this is going to be so cool.
[08:09:48] <joshua_> aatch (and, perhaps, others interested) -- https://gist.github.com/jwise/7a138e4418babbc0333c is the code in question.  Not beautiful, but certainly functional.
[08:10:00] *** Joins: tgt (tgt@moz-2F277517.nomadic.bris.ac.uk)
[08:10:21] <ikashkuta> hi all. A little question - is there any possibilities to compile rust for iOS? :)
[08:10:32] <joshua_> It is, of course, completely uncommented.
[08:10:55] <dbaupp> joshua_: would you like suggestions? :)
[08:11:43] <joshua_> dbaupp, If there are things that stick out to you, I'm happy to hear them, though I'm certainly not asking for anyone to spend time with this monstrosity :-)
[08:12:43] <dbaupp> joshua_: you can do `for foo.times{ .. }` instead of for range(..) |_| {..} and for vec.each |_| { .. }
[08:13:00] *** Quits: infynyxx (infynyxx@moz-E95B370B.nyc.res.rr.com) (Client exited)
[08:13:25] <joshua_> (This is written more or less like I would write it in C, without any of the scrubbing for function naming, variable naming, or any other such that I might normally do before unleashing it on the world.)
[08:13:37] <joshua_> ah, the ruby-style 3.times, alright
[08:14:15] <joshua_> [1, 2].each actually has positive meaning; '2.times' would be okay, but the layers are defined as "layer 1" and "layer 2"
[08:14:40] <dbaupp> ah, cool. I wondered why you'd used that instead of range like in other places
[08:17:08] <bjz> dbaupp: hoya
[08:17:19] *** Joins: engla (engla@moz-BFD53D48.selucle.dyn.perspektivbredband.net)
[08:17:43] <dbaupp> bjz: what were you wanting before? :)
[08:18:05] <joshua_> hmm, that's unexpected -- router.rs:52:2: 52:3 error: type `int` does not implement any method in scope named `times`
[08:18:20] <bjz> dbaupp: will PM you
[08:18:33] <joshua_> ha, and then it ICEd shortly afterwards, with a rust: task failed at 'ty_closure_sigil() called on non-closure type: &ty_err', /Users/joshua/rust/rust-0.6/src/librustc/middle/ty.rs:2744
[08:18:42] <dbaupp> joshua_: times only works on uint's
[08:19:30] *** Quits: ikashkuta (Mibbit@moz-97F6F4D9.com) (Quit: http://www.mibbit.com ajax IRC Client)
[08:20:22] <joshua_> aha.
[08:21:03] *** Joins: echristo (echristo@91BA60CD.BE529D01.5EFB9497.IP)
[08:21:31] <joshua_> Thanks!
[08:21:59] <joshua_> I kind of wish there were a more friendly way to use those big vectors with my Coords.
[08:22:23] <joshua_> For instance,  usage[net.pin1.layer][net.pin1.y][net.pin1.x] = Empty;, and having to work around that with let cost = |c: Coord| grid.costs[c.layer][c.y][c.x]; -- I wish I had a nicer way to do that.
[08:23:20] <dbaupp> the problem being the many layers of indices?
[08:23:35] <aatch> joshua_, try implementing the Index trait on a wrapper struct
[08:23:45] <joshua_> right.  I wish I could have a [coord] implementation
[08:23:54] <joshua_> huh, okay.  does that allow me to produce a lvalue, too?
[08:24:03] <aatch> http://static.rust-lang.org/doc/core/ops.html#trait-index
[08:24:31] <joshua_> hmm.
[08:24:51] <kimundi> joshua_: if you mean assignmet, no
[08:25:07] <joshua_> nod.  that's a shame.
[08:25:28] <kimundi> but its planned
[08:26:07] <aatch> kimundi, will assignment ops be overridable(?) at some point?
[08:26:49] <kimundi> as far as i know yes
[08:26:57] <aatch> That will be nice
[08:27:07] <aatch> especially for implementing Atomic types
[08:27:30] <aatch> so you can have += being an atomic add
[08:27:36] <aatch> s/being/be
[08:27:54] *** Joins: CarpNet (ac@moz-FD24B77.sohonet.co.uk)
[08:27:57] <joshua_> hmm, who else could mutate it?
[08:28:55] <aatch> Well the point of atomic types is that they would be easier to share
[08:29:38] <joshua_> hmmm...
[08:29:42] <kimundi> joshua_: It would be a special type that allows shared access, Id assume
[08:30:20] <joshua_> hmm.  bblum's work on hiding shared access in linear types seemed more Rust-like.
[08:30:47] <aatch> I started work on it, but there's quite a bit of compiler stuff to do in order to do it properly
[08:31:01] <joshua_> I would believe that.
[08:31:17] <aatch> Also, atomic types would be a low-level construct
[08:31:41] *** Joins: pyrac (pyrac@moz-2FEC2239.w92-149.abo.wanadoo.fr)
[08:31:44] <aatch> intended more for people writing concurrent libraries
[08:31:56] <aatch> similar to atomic types in C++
[08:32:22] <aatch> lock/wait free data structures are hard to write
[08:32:32] <joshua_> nod.  I think some of the true beauty of Rust, in my mind, is that it forces you to write within the synchronization primitives provided (channels, and messages), which more or less eliminate whole classes of race conditions
[08:34:18] <aatch> I agree.
[08:34:34] *** Joins: q66 (q66@6EE9DE40.46454B5D.33AABD5F.IP)
[08:34:39] <aatch> I've got a C project at work, I use ZMQ for internal message passing
[08:35:02] *** Joins: ghrust (ghrust@moz-4EF5B6E5.rs.github.com)
[08:35:02] <ghrust> 01[13rust01] 15bors 04force-pushed 06auto from 14bc65ae4 to 1484e22f2: 02http://git.io/N3iJvQ
[08:35:02] *** Parts: ghrust (ghrust@moz-4EF5B6E5.rs.github.com) ()
[08:35:03] *** Joins: ghrust (ghrust@moz-4EF5B6E5.rs.github.com)
[08:35:03] <ghrust> 01[13rust01] 15bors pushed 3 new commits to 06auto: 02http://git.io/-VtfiQ
[08:35:03] <ghrust> 13rust/06auto 14b50aa82 15Luqman Aden: librustc: Fix pattern matching on cross crate newtype structs.
[08:35:03] <ghrust> 13rust/06auto 1410f290e 15Luqman Aden: Add test for cross crate newtype struct in match pattern.
[08:35:03] <ghrust> 13rust/06auto 1409d66ba 15bors: auto merge of #6121 : luqmana/rust/newtype-cc, r=graydon...
[08:35:05] *** Parts: ghrust (ghrust@moz-4EF5B6E5.rs.github.com) ()
[08:35:05] <aatch> Except for a single central data structure that is atomic.
[08:37:17] <joshua_> (message-passing concurrency is particularly interesting to me; I have always had a soft spot for massive manycore with asymmetric memory access, for which shared memory simply won't scale.  The example that I did research on was the Tilera machine, but I suspect it's only a matter of time before Intel integrates Knight's Corner-style machines in with their mainstream CPUs.)
[08:38:06] <aatch> cool
[08:39:01] <aatch> I do quite like some of the patterns in lock/wait-free code though. quite a bit of "do this, if it works, great! Otherwise we don't care"
[08:39:32] <joshua_> yes, though of course great care is needed with such :-)
[08:39:42] *** Quits: ysuzuki (ysuzuki@moz-F333A8C8.st.keio.ac.jp) (Client exited)
[08:40:04] <aatch> Well it was complicated enough to justify buying a book on the subject so I can learn about it.
[08:40:20] * aatch doesn't normally need to read books on computer science topics
[08:40:32] <joshua_> Yeah.
[08:40:38] *** Quits: tgt (tgt@moz-2F277517.nomadic.bris.ac.uk) (Quit: Computer has gone to sleep.)
[08:41:01] <joshua_> Lots of people write lock-free code.  bblum and I were TAs for our undergrad OS course.  Many of our students wrote lock-free code.
[08:41:05] *** Joins: strcat (strcat@moz-54F7FD49.cpe.net.cable.rogers.com)
[08:41:15] *** Joins: tgt (tgt@moz-2F277517.nomadic.bris.ac.uk)
[08:41:21] <dbaupp> joshua_: ;D
[08:43:10] <joshua_> sully as well, actually.
[08:45:32] *** Quits: tgt (tgt@moz-2F277517.nomadic.bris.ac.uk) (Quit: Computer has gone to sleep.)
[08:49:04] <joshua_> alright, off to bed for me.  thanks for everyone's help
[08:52:59] *** Joins: lucian (lucian@moz-D82F7974.zone16.bethere.co.uk)
[09:02:08] *** Joins: jensnockert (Jens@moz-ECD727C.cust.bredband2.com)
[09:02:50] *** Joins: lucian_ (lucian@6B2B4644.4304AE1E.CE5E78F6.IP)
[09:03:27] *** Quits: lucian (lucian@moz-D82F7974.zone16.bethere.co.uk) (Ping timeout)
[09:04:56] *** Joins: davbo (dave@moz-3FFA637C.oucs.ox.ac.uk)
[09:06:21] *** Joins: RagingDave (RagingDave@moz-3F31ACEF.pools.arcor-ip.net)
[09:07:35] *** Quits: jensnockert (Jens@moz-ECD727C.cust.bredband2.com) (Ping timeout)
[09:11:02] *** Joins: sammykim (sammy.kim@5AB4884B.FCC4549.14D5B978.IP)
[09:11:19] *** Quits: pyrac (pyrac@moz-2FEC2239.w92-149.abo.wanadoo.fr) (Quit: pyrac)
[09:11:54] *** Joins: jensnockert (Jens@moz-ECD727C.cust.bredband2.com)
[09:15:38] *** Quits: jensnockert (Jens@moz-ECD727C.cust.bredband2.com) (Quit: jensnockert)
[09:15:58] *** Joins: donri (dag@moz-9BB61102.tbcn.telia.com)
[09:16:55] *** Joins: tgt (tgt@moz-D59EE478.aztw.cable.virginmedia.com)
[09:18:50] *** Quits: sonwow (sonwow@5AB4884B.FCC4549.14D5B978.IP) (Quit: leaving)
[09:21:27] *** Joins: trapni (trapni@moz-7C7C1909.dawanda.com)
[09:23:03] *** Joins: ghrust (ghrust@moz-4EF5B6E5.rs.github.com)
[09:23:03] <ghrust> 01[13rust01] 15bors 04force-pushed 06auto from 1409d66ba to 1484e22f2: 02http://git.io/N3iJvQ
[09:23:03] *** Parts: ghrust (ghrust@moz-4EF5B6E5.rs.github.com) ()
[09:23:04] *** Joins: ghrust (ghrust@moz-4EF5B6E5.rs.github.com)
[09:23:04] <ghrust> 01[13rust01] 15bors pushed 3 new commits to 06auto: 02http://git.io/Cdlf1Q
[09:23:04] <ghrust> 13rust/06auto 14b50aa82 15Luqman Aden: librustc: Fix pattern matching on cross crate newtype structs.
[09:23:04] <ghrust> 13rust/06auto 1410f290e 15Luqman Aden: Add test for cross crate newtype struct in match pattern.
[09:23:04] <ghrust> 13rust/06auto 14c081ffb 15bors: auto merge of #6121 : luqmana/rust/newtype-cc, r=graydon...
[09:23:07] *** Parts: ghrust (ghrust@moz-4EF5B6E5.rs.github.com) ()
[09:32:39] *** Joins: z0w0 (zack@moz-FB99406A.lnse4.cha.bigpond.net.au)
[09:33:58] <nmatsakis> bjz: ssbr: erickt: pong
[09:34:43] <ssbr> nmatsakis: I was wondering why I didn't have to declare my functions 'extern "C"' and they still were callable from C.
[09:34:50] <ssbr> Is that just coincidence?
[09:35:18] <ssbr> (i.e. does it just so happen that the Rust calling convention is the same as the C calling convention on my system, despite this not being guaranteed?)
[09:35:18] <nmatsakis> I think it defaults to `"C"` right now, for backwards compat --- and possibly because that's the right default?
[09:35:32] <nmatsakis> oh, you mean you just wrote "fn foo() { ... }"
[09:35:37] <nmatsakis> or you wrote `extern fo foo() { ... }`
[09:35:52] <ssbr> Just #[no_mangle] pub fn foo() {...}
[09:36:13] <nmatsakis> I see. The Rust calling convention is not the same as C.
[09:36:16] <nmatsakis> However.
[09:36:35] <nmatsakis> The differences are in the form of extra arguments....
[09:36:42] <nmatsakis> and a few other things
[09:36:47] <nmatsakis> so you may get lucky
[09:36:59] <ssbr> I see. Thanks. :)
[09:45:40] *** Joins: ysuzuki (ysuzuki@moz-F333A8C8.st.keio.ac.jp)
[09:48:52] <aatch> ((secs/31556952i64)+1i64) as int magic numbers!
[09:51:27] <dbaupp> aatch: years?
[09:51:35] <aatch> Yes
[09:51:39] <aatch> Well done
[09:52:04] <dbaupp> I definitely didn't use a calculator ;P
[09:52:05] <aatch> I've been working out the various conversion numbers I need
[09:52:51] *** Quits: echristo (echristo@91BA60CD.BE529D01.5EFB9497.IP) (Quit: echristo)
[09:52:57] <aatch> So I have '62135596800' which is the UNIX Epoch relative to the epoch I'm using
[09:53:29] <aatch> (I'm using 0001-01-01 in the proleptic gregorian calendar)
[09:54:12] <dbaupp> Everything 64-bit?
[09:54:34] <aatch> 64bit for the seconds, 32bit for nanoseconds on top of that
[09:55:39] <dbaupp> Is everything represented in seconds, and then converted from that?
[09:55:46] <aatch> Yep.
[09:56:10] <aatch> I figure that the operations people do the most are comparison and adjustment
[09:56:24] <aatch> construction and representation are at the ends
[09:56:33] <dbaupp> yeah
[09:57:20] <aatch> There is a hit if you adjust by a non-absolute duration
[09:57:37] <aatch> Since they are dependent on the date you are adjusting
[09:58:23] <dbaupp> months etc?
[09:58:31] <aatch> Yep
[09:58:39] <aatch> months and courser
[09:58:47] <aatch> There are leapseconds
[09:59:11] <aatch> but they are infrequent enough that they can be handled as special cases
[09:59:57] <dbaupp> Are you planning provide a way to say "this represents `april 2013`, not `2013-04-01 00:00:00.00000000`"?
[10:00:14] <aatch> Not sure yet.
[10:00:31] <dbaupp> good luck with this project... time is a horrible thing to deal with
[10:00:45] <aatch> I'm trying to make everything defined primarily by traits
[10:01:08] <aatch> so representation should be somewhat independent most of the time.
[10:02:30] <dbaupp> nice
[10:02:48] <dbaupp> traits will be really populous in core/std
[10:03:06] <dbaupp> hundreds of numeric ones
[10:03:11] <aatch> I'm guessing static methods in traits don't work properly yet?
[10:03:28] <dbaupp> I think they do?
[10:03:41] <dbaupp> default methods don't
[10:03:51] <aatch> I know default methods don't
[10:04:31] <dbaupp> if you just mean fn foo() -> Self; then it does
[10:04:38] <nmatsakis> aatch: static methods typically work?
[10:05:07] <aatch> nmatsakis, for some reason the impl I had wasn't working
[10:05:48] <aatch> I'm trying to call it on the concrete type though
[10:05:56] <nmatsakis> aatch: how are you trying to call it?
[10:06:14] <nmatsakis> aatch: static methods work but only if you use them in a specific way, the more general feature of associtaed items is not yet impl
[10:06:26] <nmatsakis> in particular, the static method must include the Self type somewhere
[10:06:27] <kimundi> aatch: You have to call TRAIT::static_fun(...)
[10:06:29] <dbaupp> aatch: it's One::one() rather than float::one()
[10:06:31] <nmatsakis> and Rust must be able to infer it
[10:06:54] <aatch> Ahh, so calling it on the concrete type doesn't work
[10:07:08] <dbaupp> nmatsakis: does TRAIT::fun::<T>() work for with static functions that don't include Self?
[10:07:16] <aatch> but let now : DateTime = Instant::now() would?
[10:07:22] <kimundi> dbaupp: It should
[10:07:25] <nmatsakis> dbaupp: it might
[10:07:31] <nmatsakis> dbaupp: but it's not "supported"
[10:07:45] <nmatsakis> by which I mean we reserve the right to make it not work
[10:07:53] <kimundi> aatch: if DateTime implements Instant, Instatnt is a trait, and has the static function now(), then yes
[10:08:10] <kimundi> rusti: "test"
[10:08:12] <rusti> "test"
[10:08:27] <aatch> cool, both versions work
[10:08:34] <kimundi> rusti: let one: int = One::one(); one
[10:08:35] <rusti> more than 5 lines of output, pastebinned: http://sprunge.us/HMZg
[10:08:45] <aatch> I haven't done much with traits yet
[10:08:51] <dbaupp> rusti: let one: int = num::One::one(); one
[10:08:52] <rusti> 1
[10:08:57] <kimundi> what?
[10:09:05] <kimundi> oh
[10:09:06] <kimundi> yeah
[10:09:09] <kimundi> imports
[10:09:37] <aatch> rusti: num::One::one::<int>()
[10:09:38] <rusti> 1
[10:09:39] <dbaupp> nmatsakis: ah, thanks
[10:10:01] <nmatsakis> dbaupp: let me go further, we plan to make that not work :)
[10:10:06] <nmatsakis> but it could be a while
[10:10:21] <nmatsakis> the 'official' correct way to handle that case (where inference doesn't work)
[10:10:26] <nmatsakis> will be to use the syntax pnkfelix proposed
[10:10:36] <aatch> nmatsakis, will it still work for functions that use Self?
[10:10:50] <nmatsakis> aatch: what is "it" here?
[10:10:55] <dbaupp> oh, so pnkfelix's syntax is the current goal? cool
[10:11:19] <aatch> Oh, the TRAIT::fun::<T>() usage
[10:11:22] <nmatsakis> aatch: I am referring specifically to supplying Self as an explicit type parameter
[10:11:26] <nmatsakis> ok. No, it won't.
[10:11:42] <nmatsakis> right now the type parameters for trait + Self + fun  are all concatenated together (in that order)
[10:11:54] <nmatsakis> but that's more of an impl detail that is "leaking"
[10:12:02] <aatch> Ok, makes sense
[10:12:14] <engla> is this a correct way to make a macro to put println and fmt together into a printf! macro?   macro_rules! printf( ($fmt:expr, $($e:expr),+) => (println(fmt!($fmt, $($e),+)));)
[10:12:37] <dbaupp> engla: does it work?
[10:12:38] <nmatsakis> engla: looks...about right to me. Does it work? :)
[10:12:52] <engla> it seems to work
[10:12:54] <aatch> engla, change println to core::io::println, but otherwise, yeah
[10:13:15] <engla> except for the case when there is only the fmt string
[10:13:23] <aatch> (means you don't have to worry about what modules exist)
[10:13:23] <dbaupp> rusti: macro_rules! printf( ($fmt:expr, $($e:expr),+) => (println(fmt!($fmt, $($e),+)))); printf!("%d", 1)
[10:13:25] <rusti> 1
[10:13:35] <dbaupp> engla: change the + to a *
[10:13:52] <kimundi> engla: Mgh as well just capture  $($e:expr),+ and pass that to fmt!()
[10:13:54] <aatch> rusti: fmt!()
[10:13:55] <rusti> foo.rs:5:9: 6:5 error: fmt! takes at least 1 argument.
[10:13:55] <rusti> foo.rs:5          fmt!()
[10:13:55] <rusti> foo.rs:6     });
[10:13:58] <dbaupp> rusti: macro_rules! printf( ($fmt:expr, $($e:expr),*) => (println(fmt!($fmt, $($e),*)))); printf!("just fmt")
[10:13:59] <rusti> line longer than 100 columns, pastebinned: http://sprunge.us/MMjh
[10:14:02] *** Joins: ghrust (ghrust@moz-4EF5B6E5.rs.github.com)
[10:14:02] <ghrust> 01[13rust01] 15bors merged 06auto into 06incoming: 02http://git.io/Cdlf1Q
[10:14:02] *** Parts: ghrust (ghrust@moz-4EF5B6E5.rs.github.com) ()
[10:14:12] *** Quits: tiffany (kawaii@moz-1E0FE6E8.dhcp.embarqhsd.net) (Ping timeout)
[10:14:17] <aatch> you'll need a second matching
[10:14:17] <dbaupp> rusti: macro_rules! printf( ($fmt:expr, $($e:expr),*) => (println(fmt!($fmt, $($e),*)))); printf!("just fmt",)
[10:14:18] <rusti> line longer than 100 columns, pastebinned: http://sprunge.us/gPFA
[10:14:39] *** Joins: pyrac (pyrac@moz-2FEC2239.w92-149.abo.wanadoo.fr)
[10:14:39] <kimundi>  rusti: macro_rules! printf( ($($e:expr),+) => (println(fmt!($($e),+)))); printf!("just fmt");
[10:14:41] <aatch> Oh, actually, no you won't.
[10:14:44] <aatch> Ignore me!
[10:14:50] <kimundi> rusti: macro_rules! printf( ($($e:expr),+) => (println(fmt!($($e),+)))); printf!("just fmt");
[10:14:51] <rusti> just fmt
[10:14:51] <dbaupp> what? <eof>
[10:15:56] <kimundi> nmatsakis, I wonder if I should just make a pullrequest that adds printf! and printlnf! macros
[10:16:25] <engla> kimundi: that's better!
[10:16:51] <nmatsakis> kimundi: I'd not be opposed, though I don't mind println(fmt!())
[10:17:36] <aatch> kimundi, if you do, make the single-argument form skip using fmt! though
[10:17:38] <kimundi> maybe it would be better not to, so that people use ther loggin statements instead.
[10:17:53] <aatch> since otherwise it'll do an allocation
[10:18:07] <kimundi> aatch: sure
[10:18:16] *** Quits: tgt (tgt@moz-D59EE478.aztw.cable.virginmedia.com) (Quit: Computer has gone to sleep.)
[10:18:56] *** Joins: tgt (tgt@moz-D59EE478.aztw.cable.virginmedia.com)
[10:24:22] <aatch> Hmm, date/time objects mutable or immutable in the default (easy to use) case?
[10:25:26] <dbaupp> aatch: as in, @mut boxes?
[10:26:45] <aatch> I was thinking more that doing something like set_day() would return a new date
[10:26:46] <dbaupp> strcat: ping
[10:26:51] <aatch> but I'm still not sure
[10:26:56] <dbaupp> aatch: oh
[10:27:10] <aatch> as opposed to modifying the date
[10:27:16] <dbaupp> yeah
[10:27:27] <dbaupp> either behaviour seems reasonable
[10:27:33] <aatch> That's the problem
[10:27:51] <dbaupp> I would guess performance => mutable
[10:28:12] <dbaupp> but performance isn't necessarily the first concern of a datetime library (?)
[10:29:17] <aatch> Hmm, I guess the fact that Rust has an easy way to distinguish mutable and immutable makes it a little easier though
[10:29:37] <aatch> Is there a way to implement a trait /only/ on an immutable type?
[10:30:00] <dbaupp> aatch: only take non-mutable self?
[10:30:58] <aatch> Yeah, and how do you express that? I thought you could pass mutable types to immutable arguments
[10:32:03] <dbaupp> can you give an example of why that's useful?
[10:32:23] <dbaupp> (I don't understand why the callee would need to know about the mutability in the caller?)
[10:32:39] <aatch> I don't know.
[10:32:46] <aatch> Things keep popping into my head
[10:33:29] <kimundi> aatch: If all methods and functions that can mdofiy the object only take self or &self, instead of &mut self, then its pretty much immutable
[10:33:53] <dbaupp> kimundi: (or ~/@self)
[10:33:58] <kimundi> Need to make the struct fields private too, of course
[10:34:08] <kimundi> dbaupp: Yeah, or that
[10:34:53] <kimundi> I think immutablily is desirable for a date libary, it doesn't hold much data.
[10:35:29] <aatch> Yeah, there's a lot of static data, but that doesn't count.
[10:35:37] <aatch> (Timezone information mostly)
[10:35:45] <kimundi> Hm, I wished there would be a good way to abstract away "method that takes immutable self and returns new value" and "method that takes mutable self and chnages it"
[10:35:58] <aatch> kimundi, that's kinda what I want
[10:36:09] <kimundi> People get tripped up by stuff like vec::filter and vec::fileterd
[10:36:25] <aatch> but I keep flip-flopping between convenience and predictability
[10:38:32] <kimundi> I wonder if some kind of "MethodCallAssign" operator would make sense.... 'foo.filter()' returns new value, 'foo.=filter()' changes self by assigning a new value per default, and wich would allow overwriting to make it more perfomant
[10:38:51] <kimundi> But that would go against the type system... No way to overwrite a specific method
[10:40:50] <kimundi> Also, the ship has probably long sailed for those changes
[10:41:25] *** Joins: pnkfelix (pnkfelix@moz-801E009D.vlan502.asr1.cdg2.gblx.net)
[10:43:10] <kimundi> Wait, it would be possble otherway round with overwritable assign operator.
[10:43:33] <kimundi> foo = foo.filterd()... No wait thats not what I want, hmm...
[10:43:37] <dbaupp> kimundi: as in, you can overload =?
[10:44:14] <kimundi> dbaupp: Some way to optimze 'create new value' to 'modfiy exitsing one'
[10:44:30] <dbaupp> kimundi: sufficiently smart compiler?
[10:44:39] <kimundi> God beware no
[10:44:47] <kimundi> It shoulb be explicit
[10:45:05] <dbaupp> I would vote against overloadable = as explicit
[10:45:25] <kimundi> But a way to abstract it in a way that doesn't mean 'implement all methods twice'
[10:46:36] <aatch> actually, it might be feasible automatically. Since foo must be mut, you are calling on foo and assigning to foo.
[10:47:15] <aatch> On second though, nope
[10:47:18] <aatch> thought*
[10:47:29] <kimundi> aatch: Well you want it overridable. Because either operation might be more perfomant than the other
[10:47:57] <kimundi> SO you'd want the option to implement both explicit, but get either one for free otherwise
[10:48:34] <aatch> Well picking a method based on the self argument could work
[10:49:00] *** Joins: pnkfelix|rcirc (pnkfelix@moz-801E009D.vlan502.asr1.cdg2.gblx.net)
[10:49:03] <kimundi> Hm... Thats also a posibility
[10:49:11] <kimundi> Allow overloading just for the self argument
[10:49:17] <dbaupp> aatch: seems reasonable, you'd want a way to force the use of the immutable one
[10:49:35] <kimundi> But then again they would have differnt signatures oterwise
[10:50:27] *** Joins: RageOfThou (RageOfThou@moz-CF7139ED.dynamic.telemach.ba)
[10:50:47] *** Quits: tgt (tgt@moz-D59EE478.aztw.cable.virginmedia.com) (Quit: Computer has gone to sleep.)
[10:51:33] <kimundi> foo = foo.mutate() ... Maybe a macro: immutcopy!(foo.mutate()), which expands to 'let tmp = foo.clone(); foo.mutate()'
[10:51:38] <aatch> well if you are doing let mut foo = SomeVal; foo = foo.change_field(); then it would be the mutator version, since you are changing the variable either way
[10:52:25] <aatch> let foo = SomeVal; foo = foo.change_field() doesn't work at all since foo isn't mutable
[10:53:13] <kimundi>  'let mut tmp = foo.clone(); foo.mutate(); let tmp = tmp; tmp'
[10:53:42] <aatch> anything else would use the immutable version.
[10:53:56] <aatch> like that 
[10:54:50] <aatch> I was thinking of it as a Copy-On-Write optimization
[10:55:08] <kimundi> aatch: What if there are more than two variable, both immutable, but one not yet initialized, and you want to init it from the other like that?
[10:56:13] <aatch> Well you'd copy. 
[10:56:37] *** Joins: solancile (solancile@moz-A1CFFAE5.hsd1.wa.comcast.net)
[10:56:48] <aatch> so in the case you posted, tmp would have the value of foo pre-mutation
[10:57:12] *** Quits: ysuzuki (ysuzuki@moz-F333A8C8.st.keio.ac.jp) (Client exited)
[10:57:51] *** Joins: victorporof (victorporo@9310F178.477C3F8E.79933D60.IP)
[10:58:12] <kimundi> Ghah, still a typo in my psydomacro...  'let mut tmp = foo.clone(); tmp.mutate(); let tmp = tmp; tmp'
[10:59:01] <aatch> I'm thinking about a case we have at work, we use PHP for some projects, and made an ImmutableDateTime object because by default they are mutable and it interfered with our ORM.
[10:59:13] <aatch> But a lot code consisted of $date = $date-
[10:59:16] <kimundi> let v = mutcopy!(foo.mutate()) => let v = {let mut tmp = foo.clone(); tmp.mutate(); let tmp = tmp; tmp}
[10:59:17] *** Joins: infynyxx (infynyxx@moz-E95B370B.nyc.res.rr.com)
[10:59:24] <aatch> stupid enter key
[10:59:34] <aatch> $date = $date->modify("+1 day");
[11:00:30] *** Joins: EXetoC (ex@moz-2DBEB1E4.customer.t3.se)
[11:01:04] *** Joins: jfredett (jfredett@moz-C01C350.bstnma.fios.verizon.net)
[11:01:44] <kimundi> I wonder if you can generally say that a modifying method will at most be as bad as a constructing one
[11:02:32] <kimundi> One case which I could think of is if modifying involves locking... Then a fresh construction without going through the modfiy path would be faster
[11:02:56] *** Quits: jfredett (jfredett@moz-C01C350.bstnma.fios.verizon.net) (Ping timeout)
[11:03:14] <kimundi> (talking about the case of immutable update -> mutable update optmisation)
[11:04:25] <dbaupp> rusti: macro_rules! mutcopy(($obj:ident . $method:ident ($($a:expr),*)) => { { let mut tmp = $obj . clone(); tmp. $method ( $($a),*); tmp } }); let v = mutcopy!( 1 .to_str()); v
[11:04:25] <rusti> line longer than 100 columns, pastebinned: http://sprunge.us/hWHC
[11:04:37] *** Joins: khady1 (khady@B2CE14A5.FC3B8B76.BA2F4534.IP)
[11:04:51] <dbaupp> rusti: macro_rules! mutcopy(($obj:ident . $method:ident ($($a:expr),*)) => { { let mut tmp = $obj . clone(); tmp. $method ( $($a),*); tmp } }); let x = 1; let v = mutcopy!(x.to_str()); v
[11:04:52] <rusti> line longer than 100 columns, pastebinned: http://sprunge.us/iEGI
[11:05:18] *** Quits: khady1 (khady@B2CE14A5.FC3B8B76.BA2F4534.IP) (Quit: WeeChat 0.3.8)
[11:06:02] <kimundi> rusti: macro_rules! mutcopy(($obj:ident : $method:ident ($($a:expr),*)) => { { let mut tmp = $obj . clone(); tmp. $method ( $($a),*); tmp } }); let x = 1; let v = mutcopy!(x:to_str()); v
[11:06:02] <rusti> line longer than 100 columns, pastebinned: http://sprunge.us/FGic
[11:06:40] <dbaupp> rusti: macro_rules! mutcopy(($obj:ident . $method:ident => $($a:expr),*) => { { let mut tmp = $obj . clone(); tmp. $method ( $($a),*); tmp } }); let x = 1; let v = mutcopy!(x.to_str => ); v
[11:06:41] <rusti> more than 5 lines of output, pastebinned: http://sprunge.us/ZeaV
[11:07:05] <dbaupp> rusti: macro_rules! mutcopy(($obj:ident . $method:ident => $($a:expr),*) => { { let mut tmp = $obj . clone(); tmp. $method ( $($a),*); tmp } }); let x = 1u; let v = mutcopy!(x.to_str => ); v
[11:07:06] <rusti> 1
[11:07:34] *** Joins: a_m0d|home (a_m0d@moz-9F925EFA.hm.shawcable.net)
[11:07:43] <dbaupp> rusti: macro_rules! mutcopy(($obj:ident . $method:ident => $($a:expr),*) => { { let mut tmp = $obj . clone(); tmp. $method ( $($a),*); tmp } }); let x = ~[]; let v = mutcopy!(x.push => 1u); v
[11:07:44] <rusti> ~[1]
[11:07:48] <dbaupp> yay!
[11:07:58] <dbaupp> rusti: macro_rules! mutcopy(($obj:ident . $method:ident => $($a:expr),*) => { { let mut tmp = $obj . clone(); tmp. $method ( $($a),*); tmp } }); let x = ~[]; let v = mutcopy!(x.push => 1u); (x, v)
[11:07:59] <rusti> (~[], ~[1])
[11:08:23] *** Joins: cdidd (cdidd@moz-70981FCD.broadband.corbina.ru)
[11:09:05] <kimundi> That seems like it works?
[11:09:37] <dbaupp> yeah, except for the `=>` to get around the ambiguity thing
[11:09:45] <kimundi> yeah
[11:11:04] *** Joins: ghrust (ghrust@moz-4EF5B6E5.rs.github.com)
[11:11:04] <ghrust> 01[13rust01] 15bors pushed 0 new commits to 06auto: 02http://git.io/RbBBSQ
[11:11:04] *** Parts: ghrust (ghrust@moz-4EF5B6E5.rs.github.com) ()
[11:12:02] <kimundi> let v = x.push.mutcopy!(...args...)
[11:12:13] <kimundi> To bad that field macros can'7 work
[11:12:24] *** Joins: vosen (vosen@moz-266BA656.icpnet.pl)
[11:12:56] <kimundi> hmm.... macros as assoziated item in a trait?
[11:13:11] <kimundi> Wonder if that would work
[11:14:00] <dbaupp> macros can't even be exported yet :(
[11:14:17] *** Quits: jaen (jaen@moz-E0979827.copit.pl) (Ping timeout)
[11:14:19] <kimundi> Yeah, but someday they will, someday...
[11:14:27] <dbaupp> :D
[11:14:34] * kimundi stares in the sunset
[11:16:38] *** Quits: pyrac (pyrac@moz-2FEC2239.w92-149.abo.wanadoo.fr) (Quit: pyrac)
[11:17:27] <kimundi> Assuming the macro gets used... let v = mutcopy!(x.(imut).foo(...)) to make it more clear at which point it inserts the clone?
[11:18:04] <kimundi> or let v = mutcopy!(x.<imut>.foo(...))
[11:18:18] *** Joins: snearch (snearch@moz-572768F1.pool.mediaways.net)
[11:19:09] <kimundi> let v = mutcopy!(x<imut>.foo(...)) ? Just the one dot...
[11:19:41] * kimundi wished there would be more free symbols left in rust
[11:20:14] <dbaupp> kimundi: there's `, which should be all you need! :P
[11:20:34] * aatch thinks of a use for `
[11:20:42] <kimundi> let v = mutcopy!(x`foo(...)) ... Nah xD
[11:21:02] <dbaupp> rusti: macro_rules! foo( ($a:expr ` $b:expr) => { $a + $b } ); foo!(1 ` 2)
[11:21:03] <rusti> foo.rs:5:31: 5:35 error: unknown start of token: 96
[11:21:03] <rusti> foo.rs:5          macro_rules! foo( ($a:expr ` $b:expr) => { $a + $b } ); foo!(1 ` 2)
[11:21:03] <rusti>                                         ^~~~
[11:21:10] <kimundi> aatch: well, infix call syntax.  let value = 15 `div` 4;
[11:21:22] <dbaupp> rusti: macro_rules! foo( ($a:expr ? $b:expr) => { $a + $b } ); foo!(1 ? 2)
[11:21:24] <rusti> foo.rs:5:31: 5:35 error: unknown start of token: 63
[11:21:24] <rusti> foo.rs:5          macro_rules! foo( ($a:expr ? $b:expr) => { $a + $b } ); foo!(1 ? 2)
[11:21:24] <rusti>                                         ^~~~
[11:21:33] <dbaupp> :( macros don't like them
[11:21:49] <kimundi> It seems those symbols need to be tokens rustc saccepts
[11:21:50] *** Joins: pyrac (pyrac@moz-2FEC2239.w92-149.abo.wanadoo.fr)
[11:22:22] <aatch> interesting that it doesn't tokenize them though
[11:22:30] <kimundi> hmm... 15`method`14 as sugar for 15.method(14) ?
[11:23:00] *** Quits: twm (twm@moz-13417AD3.dsl.static.sonic.net) (Ping timeout)
[11:23:06] <kimundi> might silence alot of the people who think the method chaning syntax is ugly or unsymmetric
[11:24:13] <aatch> I don't mind method chaining.
[11:24:27] <aatch> Then again I "grew up" on Java, PHP and C
[11:25:26] <aatch> I generally don't care about syntax though
[11:25:47] <aatch> as long as it is understandable and mostly consistent
[11:25:52] <kimundi> Maybe I should stop thinking of such changes... People will always complain, and rust tries not to be bloated. But sometimes I wonder 'why not allow both ways'
[11:25:54] <aatch> it's semantics that I care about.
[11:26:32] <kimundi> yeah, but If the semantic is right, I don't think more sugar hurts in theory
[11:26:44] <aatch> I don't care if it's written 1 + 1, + 1 1 or 1 1 +, as long as I know exactly what it does
[11:27:12] <aatch> kimundi, true, but people tend to ignore semantics in order to spend more time bitching over syntax
[11:28:14] <kimundi> I know :( I'm almost one of them... (Not bitching, but overthinking possible suagrs to make it nicer too much)
[11:28:19] *** Joins: Khady1 (khady@1A3345B6.FC3B8B76.BA2F4534.IP)
[11:28:57] *** Quits: cantsin (cantsin@moz-F99612CC.members.linode.com) (Ping timeout)
[11:29:24] *** Joins: cantsin (cantsin@moz-F99612CC.members.linode.com)
[11:29:31] <kimundi> Meh, that infix sugar wouldn't work anyway... a `foo` b `bar` c => a.foo(b).bar(c)  ? or ?  a.foo(b.bar(c))
[11:29:56] *** Joins: echristo (echristo@91BA60CD.BE529D01.5EFB9497.IP)
[11:30:38] <aatch> Hmm, would anybody here know what the availability of clock_gettime is on non-linux platforms?
[11:31:20] <pnkfelix|rcirc> aatch: clock_gettime is not present on Mac OS X.  don't know about Windows.
[11:31:45] <pnkfelix|rcirc> aatch: http://stackoverflow.com/questions/5167269/clock-gettime-alternative-in-mac-os-x
[11:33:10] <aatch> hmm, ok
[11:33:34] <kimundi> hmm... let v = ifx!( 15 rem 14 ) maybe? Meh, I'm getting sidetracked, that wasn't even what the disussion is about.
[11:35:34] <aatch> Ah, gettimeofday should work
[11:35:38] *** Quits: a_m0d|home (a_m0d@moz-9F925EFA.hm.shawcable.net) (Quit: Leaving.)
[11:37:45] <EXetoC> kimundi: would there be issues regarding using '.' for the chaining sugar as well? I don't want to have to use shift even more, but I guess '`' wouldn't be end of the world
[11:38:01] <EXetoC> if it's unused then maybe it's a good idea
[11:38:35] <aatch> EXetoC, that's odd, '`' doesn't require shift on my keyboard
[11:39:03] <kimundi> EXetoC: Hm? Not getting what you asking. The trouble with my hypothetical `infix` syntax is that its confusing how it would call the methods
[11:39:42] <EXetoC> ok. it's 'Â´' without shift, and '`' with shift for me
[11:39:52] <kimundi> AH, shift as in keyboard shift. Hm, what do mean uses '.' instead?
[11:40:47] <kimundi> Or did you mistype '`' or 'Â´' ?
[11:40:50] <aatch> kimundi, I think he might mean like foo . method . 15?
[11:41:00] *** Quits: lucian_ (lucian@6B2B4644.4304AE1E.CE5E78F6.IP) (Connection reset by peer)
[11:41:05] *** Quits: Benvie (brandon@5FD20F9A.53D07D95.EFF8B7BF.IP) (Connection reset by peer)
[11:41:08] <aatch> I don't have ´ on my keyboard!
[11:41:09] *** Joins: Benvie (brandon@5FD20F9A.53D07D95.EFF8B7BF.IP)
[11:41:20] *** Joins: lucian (lucian@6B2B4644.4304AE1E.CE5E78F6.IP)
[11:41:37] <kimundi> That would only possibly work with an literal on the right side, and even then rustc would probably have trouble with tha
[11:41:38] <EXetoC> nvm. I'm probably missing a couple of details anyway
[11:43:18] <dbaupp> aatch: presumably EXetoC is on a non-US keyboard (e.g. on a swedish keyboard the key that's "normally" = becomes Â´ and ` with shift)
[11:43:33] <aatch> I figured
[11:43:34] <kimundi> Hehe. Would it be possible to abuse operator overloading and enums?  'enum MathOps { add, sub, div }; ....    let v = 15 << add << 13'
[11:44:06] *** Joins: judder (maradukewa@DABDEEA3.F2C0D0AC.78E362FE.IP)
[11:44:17] <aatch> kimundi, that is horrible and amazing
[11:44:22] <dbaupp> kimundi: what about 16 << add >> 13 to give it some symmetry?
[11:44:26] <kimundi> Pro: works in current syntax. Con: everyone who knows how it works will try to kill me.
[11:44:40] <kimundi> brb in an hour or so
[11:44:57] <aatch> I don't think an hour counts as "right back"
[11:45:19] <kimundi> depends on slow you are. till later :P
[11:48:07] *** Parts: echristo (echristo@91BA60CD.BE529D01.5EFB9497.IP) ()
[11:48:58] *** Quits: int3_ (int3_@moz-4F9BAFA5.subnet-248.amherst.edu) (Client exited)
[11:55:52] *** kimundi is now known as zz_kimundi
[11:58:02] *** Quits: pyrac (pyrac@moz-2FEC2239.w92-149.abo.wanadoo.fr) (Quit: pyrac)
[11:58:12] *** Joins: berak (chatzilla@9C06657A.3A27401E.16E13E53.IP)
[11:59:25] *** Joins: jaen (jaen@moz-E0979827.copit.pl)
[12:02:02] <EXetoC> dbaupp: '0' -> '=', 'Â´' -> '`'
[12:02:05] <EXetoC> :>
[12:03:19] <EXetoC> but w/e
[12:04:30] <dbaupp> EXetoC: I meant the key marked = on a US keyboard, but, as you say, w/e
[12:04:48] <EXetoC> oh
[12:06:09] <aatch> Is calling windows api functions directly a good idea?
[12:09:04] *** Quits: boggle (boggle@moz-5FB508BE.dip0.t-ipconnect.de) (Quit: boggle)
[12:09:04] *** Joins: pyrac (pyrac@moz-2FEC2239.w92-149.abo.wanadoo.fr)
[12:09:48] *** zz_kimundi is now known as kimundi
[12:11:16] *** Quits: Khady1 (khady@1A3345B6.FC3B8B76.BA2F4534.IP) (Ping timeout)
[12:12:36] <kimundi> aatch: depends on wether you want to be crossplatform compatible
[12:12:50] <EXetoC> I wonder if this 256+ byte function is going to be efficient on any existing architecture :>
[12:13:40] <aatch> Well it's actually in order to be cross-platform compatible.
[12:14:15] *** Quits: snearch (snearch@moz-572768F1.pool.mediaways.net) (Quit: Verlassend)
[12:14:19] <aatch> So using conditional compilation to pick the right function(s) to call
[12:14:34] <kimundi> well then I'd say yes
[12:14:46] <aatch> no linking issues or anything?
[12:14:46] <EXetoC> I wonder how well the optimizer tries to re-use no longer used stack chunks. shouldn't be too hard to figure out
[12:15:58] *** Parts: berak (chatzilla@9C06657A.3A27401E.16E13E53.IP) ()
[12:16:30] <kimundi> But youd probably want to factor out those things in an own module, to make porting easier
[12:16:54] <aatch> kimundi, I'd probably throw the functions themselves into core::os
[12:17:23] <aatch> but the I just want to get the local time + related
[12:17:51] <kimundi> yeah
[12:19:32] <aatch> interestingly, it looks like I might need to add a built-in to the runtime to get at the timezone info on linux and mac
[12:19:54] <aatch> stupid extern variables
[12:22:52] *** Quits: infynyxx (infynyxx@moz-E95B370B.nyc.res.rr.com) (Client exited)
[12:26:47] *** Joins: Khady1 (khady@E3F192BB.FC3B8B76.BA2F4534.IP)
[12:29:09] *** Quits: jaen (jaen@moz-E0979827.copit.pl) (Ping timeout)
[12:31:40] *** bhearsum|afk is now known as bhearsum
[12:33:09] *** Parts: z0w0 (zack@moz-FB99406A.lnse4.cha.bigpond.net.au) ()
[12:34:34] *** Quits: BigEndian (hurp@moz-1B6DD81E.members.linode.com) (Ping timeout)
[12:34:44] *** Quits: jld (jld@moz-B94C75AD.xlerb.net) (Ping timeout)
[12:37:55] *** Joins: BigEndian (hurp@moz-1B6DD81E.members.linode.com)
[12:38:03] *** Joins: jld (jld@moz-B94C75AD.xlerb.net)
[12:39:06] *** Quits: tcsc (tcsc@moz-A838B260.dhcp.nwtn.ct.charter.com) (Quit: computer sleeping)
[12:41:02] *** Joins: ghrust (ghrust@moz-4EF5B6E5.rs.github.com)
[12:41:02] <ghrust> 01[13rust01] 15bors 04force-pushed 06auto from 14797e59d to 14c081ffb: 02http://git.io/N3iJvQ
[12:41:02] *** Parts: ghrust (ghrust@moz-4EF5B6E5.rs.github.com) ()
[12:41:02] *** Joins: ghrust (ghrust@moz-4EF5B6E5.rs.github.com)
[12:41:02] <ghrust> 01[13rust01] 15bors pushed 4 new commits to 06auto: 02http://git.io/fGeNrw
[12:41:02] <ghrust> 13rust/06auto 140ef9abd 15Felix S. Klock II: Issue 4391: rustc should not silently skip tests with erroneous signature.
[12:41:02] <ghrust> 13rust/06auto 141123cdc 15Felix S. Klock II: mod items need to be marked with `cfg(test)` not `test`.
[12:41:04] <ghrust> 13rust/06auto 14e6c5084 15Felix S. Klock II: mod items need to be marked with `cfg(test)` not `test`.
[12:41:05] *** Parts: ghrust (ghrust@moz-4EF5B6E5.rs.github.com) ()
[12:46:05] *** Quits: EXetoC (ex@moz-2DBEB1E4.customer.t3.se) (Quit: WeeChat 0.4.0)
[12:59:58] *** Joins: snowmantw (Mibbit@moz-69896760.cs.nccu.edu.tw)
[13:05:29] *** Joins: jaen (jaen@E6617AFE.C79D1C03.43DC2829.IP)
[13:08:39] *** Quits: Kingsley (Kingsley@moz-2C05952E.bchsia.telus.net) (Connection reset by peer)
[13:11:05] <haard> I'm trying to create and return a ~[&u8]; I declare it with "fn xxx() -> ~[&u8]", then create the vector as "let mut out = ~[];" and try to add &u8 values (and then return it), but when adding I get "expected `& const <V7>` but found `&u8`". Anyone care to give me a hint?
[13:11:39] <haard> *declare it -> declare the function 
[13:12:10] *** Joins: tgt (tgt@moz-D59EE478.aztw.cable.virginmedia.com)
[13:12:18] *** Quits: jaen (jaen@E6617AFE.C79D1C03.43DC2829.IP) (Ping timeout)
[13:12:32] <dbaupp> haard: how are you adding things to the vector? (with append?)
[13:12:52] *** Joins: jaen (jaen@E6617AFE.C79D1C03.43DC2829.IP)
[13:16:39] <nmatsakis> haard: the key question is the lifetime of what you are returning
[13:16:48] <nmatsakis> haard: that signature is definitely invalid
[13:16:57] <nmatsakis> haard: but what's not clear to me is what exactly you are trying to do
[13:17:01] <haard> dbaupp: +=
[13:17:03] <nmatsakis> (like, the big picture)
[13:17:19] <haard> just a sec, creating a gist
[13:17:21] <nmatsakis> haard: also, prefer `out.push()` to `out += `
[13:17:26] <nmatsakis> (for efficiency)
[13:17:34] <nmatsakis> though that may change someday :)
[13:17:44] *** Joins: wilsonk-laptop (kvirc@moz-39EFBFC2.cg.shawcable.net)
[13:17:48] <nmatsakis> when we fix the bug about adding special methods for `+=`
[13:18:01] <bjz> :)
[13:18:11] *** Joins: bheylin_ (brianheyli@1083AED6.51FADFE6.DE877FF9.IP)
[13:18:19] *** Quits: wilsonk|2 (kvirc@moz-39EFBFC2.cg.shawcable.net) (Ping timeout)
[13:18:22] <haard> ah, ok
[13:18:37] <dbaupp> haard: also += is for appending a vector onto a vector, not an individual element (I think)
[13:18:51] <haard> oo
[13:19:00] <haard> shoul've guessed
[13:19:07] <haard> +d
[13:19:08] <haard> https://gist.github.com/haard/b966500c89a4a7d81631
[13:20:11] <nmatsakis> haard: so what I mean is, why are you putting pointers to characters into this vector?
[13:20:15] <nmatsakis> haard: and not just the characters themselves?
[13:20:20] <nmatsakis> haard: that's what is causing you trouble
[13:20:24] <haard> ah, with push() I hit the lifetime issue, which is more what I expected
[13:20:33] <nmatsakis> haard: you are trying to create and return a vector of pointers that point into your stack
[13:20:50] <nmatsakis> oh, I see
[13:20:53] <nmatsakis> the pointers point into the LinearMap
[13:20:54] <haard> nmatsakis: I did put char first and the current iteration is from frustration
[13:20:54] <nmatsakis> my mistake
[13:21:05] <nmatsakis> haard: ok, well, I think what you *want* is ~[u8]
[13:21:11] <haard> yes! =)
[13:21:12] <nmatsakis> not ~[&u8]
[13:21:15] <nmatsakis> and you can write:
[13:21:19] <nmatsakis> out.push(*reverse_charmap.get(&char))
[13:21:30] <nmatsakis> the * is necessary because reverse_charmap.get() returns a pointer into the map
[13:21:37] <nmatsakis> (which is useful when the value is very large, not so much here)
[13:21:43] *** Quits: Khady1 (khady@E3F192BB.FC3B8B76.BA2F4534.IP) (Ping timeout)
[13:21:59] <haard> works like a charm, thank you
[13:22:02] <nmatsakis> np
[13:22:16] <nmatsakis> if you *really* wanted the pointers, there would be a way to express that...
[13:22:28] <nmatsakis> ...but as we said, you don't. :)
[13:26:56] *** Joins: dymk (dymk@44EEE21C.A6E21E6E.5E500FC7.IP)
[13:30:59] *** Joins: EXetoC (ex@moz-2DBEB1E4.customer.t3.se)
[13:31:25] <just_bstrie> wasn't LinearMap renamed to HashMap? is there a difference?
[13:32:53] <nmatsakis> just_bstrie: renamed, no difference.
[13:32:59] <nmatsakis> presumably haard is on 0.6
[13:33:29] <just_bstrie> ok, thanks. I'd just never heard the term "linear map" used anywhere but here :)
[13:34:05] <haard> yes, on 0.6
[13:34:37] <haard> probably shouln't be
[13:35:45] <haard> what is the ref of the latest mostly unbroken version anyway?
[13:36:14] <just_bstrie> incoming is almost always unbroken
[13:37:17] *** Joins: Khady1 (khady@8DA4C5E7.8979521E.BA2F4534.IP)
[13:37:37] *** Joins: erickt (Adium@49C4075F.3AC15C18.2321E71E.IP)
[13:38:43] <haard> thanks 
[13:38:59] *** Quits: dbaupp (Thunderbir@moz-8651256C.lns20.syd6.internode.on.net) (Ping timeout)
[13:39:17] <nmatsakis> haard: just_bstrie: except right now as I understand it :)
[13:39:34] <nmatsakis> unless it's been fixed
[13:41:05] *** just_bstrie is now known as bstrie
[13:42:13] <erickt> good morning nmatsakis! got some time for some questions about typeck::check::method?
[13:43:58] * kimundi is a bit emarrased because he caused the current breakage. But not much because it doesn't seem like he did something obviously wrong. :P
[13:45:22] <kimundi> That multi do proposal on the mailing list seems interesting
[13:45:35] <bstrie> ooh, a multi-do proposal
[13:45:42] <bstrie> I've been thinking about this for a long time
[13:48:26] *** Quits: an0nymous (an0nymous@CBF46C52.A02070AB.72768D0E.IP) (Client exited)
[13:48:34] <nmatsakis> there have been requests. I don't think that proposal is quite...it yet.
[13:48:41] <pnkfelix> nmatsakis: if `make check TESTNAME=foo` runs a non-empty set of tests, will `make check` run a superset of them?  Or does the default domain of `make check` filter out some cases that TESTNAME=â€¦ would include?
[13:48:50] *** Joins: an0nymous (an0nymous@moz-FF0B8E6D.ipredator.se)
[13:49:00] <nmatsakis> pnkfelix: TESTNAME= just filters what would otherwise run
[13:49:02] <nmatsakis> pnkfelix: BUT....
[13:49:11] <nmatsakis> pnkfelix: there is some logic to prevent running test suites that have already passed if the sources don't pass
[13:49:16] <nmatsakis> pnkfelix: and that logic doesn't take TESTNAME into account
[13:49:24] <nmatsakis> pnkfelix: so if you do "make check TESTNAME=foo; make check"
[13:49:25] <pnkfelix> nmatsakis: I've been trying to understand why bors is catching test failures that my local runs of `make check` were not catching.
[13:49:26] <nmatsakis> and the first run passes
[13:49:28] <nmatsakis> the second run tests nothing
[13:49:48] <nmatsakis> pnkfelix: that I don't know, could be related to the above^?
[13:50:04] <nmatsakis> that's basically a makefile bug, the workaround is to do `find . -name '*.ok' -delete` in your build directory
[13:50:12] <pnkfelix> i don't know.  what do I run to clean up the intermediate state that is presumably being â€¦ okay that's my answer
[13:50:12] *** Quits: igl (igl@moz-7B6AAEAC.adsl.alicedsl.de) (Ping timeout)
[13:50:13] *** Joins: igl (igl@moz-56C8DB9C.adsl.alicedsl.de)
[13:50:15] <nmatsakis> to clear out the intermediate results
[13:51:33] <pnkfelix> nmatsakis: to be fair, my `make check` run is not clean, because too-much-recursion.rs is failing for me locally.
[13:51:39] <pnkfelix> (not sure what's up with that.)
[13:54:05] *** Quits: judder (maradukewa@DABDEEA3.F2C0D0AC.78E362FE.IP) (Client exited)
[13:54:14] <kimundi> do some::function(a,b,c) for <'succ, 'err> 'succ |...| { ... } 'err |...| { ... } maybe?
[13:54:22] *** Joins: judder (maradukewa@DABDEEA3.F2C0D0AC.78E362FE.IP)
[13:54:44] *** Joins: blitter (blitter@moz-7C98731E.dyn.centurytel.net)
[13:54:54] <nmatsakis> I don't really get the idea of tagging things with names
[13:55:04] <nmatsakis> though as a wannabe smalltalker I like it
[13:55:12] <nmatsakis> (in principle, anyhow)
[13:55:22] <kimundi> nmatsakis: well, just for readability and to allow reordering I'd guess
[13:55:32] <nmatsakis> it seems like something we don't allow anywhere else in the syntax 
[13:55:37] <nmatsakis> (abitrary reordering)
[13:55:45] <kimundi> labels?
[13:55:48] <nmatsakis> right
[13:55:53] <nmatsakis> except for top-level fn items or something
[13:56:02] <nmatsakis> but otherwise, when can you reorder expressions arbitrarily?
[13:56:15] <nmatsakis> you could argue match arms, but even there the ordering is sometimes significant
[13:56:33] <nmatsakis> in any case, I think my feeling is YAGNI---this is what syntax extensions are for
[13:56:54] <nmatsakis> but I'm open to persuasion
[13:57:09] <nmatsakis> I shouldn't say YAGNI, as there are legitimate use cases. I guess I don't mind writing: foo(|| { ...}, || { ... })
[13:57:15] <erickt> if we had named arguments, we could do this pretty simply: if_fun(my_condition, then_: || { â€¦ }, else_: || { â€¦ })
[13:57:25] <nmatsakis> erickt: ah I wanted to talk to you :)
[13:57:31] * erickt waves
[13:57:51] <nmatsakis> also, yes, I'm not opposed to adding named arguments as a general feature (though I am opposed to that idea pre-1.0)
[13:58:18] <kimundi> I think at least the ability to call do with more than one closure should be part of the standart syntax if possible. Restricting it to one seems a bit arbitrary imo. Of course there needs to be a nice way to chain the closures
[13:58:19] <erickt> me too
[13:58:20] <nmatsakis> until then, if_fun(my_condition, || { ... }, /*else:*/ || { ... }) :)
[13:58:50] <nmatsakis> erickt: so ... whatever happened to your branch? =)
[13:59:09] <erickt> all sorts of stuff
[13:59:19] <nmatsakis> I am kind of blocked right now on various pre-existing bugs in default methods
[13:59:21] <nmatsakis> and debating what to do about it
[13:59:24] <erickt> it's been a crazy tour through the compiler
[13:59:29] <nmatsakis> yeah, no doubt.
[14:00:04] <erickt> I think I'm starting to grasp how methods are done :)
[14:00:26] <nmatsakis> erickt: making you a member of a select elite
[14:00:30] <erickt> so what I've been working on is what I thought would be a simple thing. move the self_ty into FnSig
[14:00:32] <erickt> haha
[14:00:45] <nmatsakis> erickt: funny :) I did that on a branch at one point and backed it out
[14:00:52] <erickt> haha
[14:00:54] <nmatsakis> erickt: I wasn't sure if it was semantically right
[14:01:01] <nmatsakis> though in some way it clearly is
[14:01:08] <nmatsakis> anyway, carry on.
[14:01:35] <nmatsakis> erickt: so, here's something that's bugging me (which is related)
[14:01:44] <nmatsakis> erickt: right now when there is a function call or method call
[14:01:49] <erickt> I figure it's a stopgap until &self can be promoted into sugar for the first argument
[14:02:09] <nmatsakis> erickt: we associate the type of the callee with an id
[14:02:16] <nmatsakis> erickt: in my branch, we always associate the type with the callee_id
[14:02:24] <nmatsakis> erickt: on the trunk, we are less consistent
[14:02:45] <nmatsakis> anyhow, I think this is kind of the wrong thing to be doing
[14:02:52] <nmatsakis> rather we should have a separate table that maps the callee_id -> FnSig
[14:02:59] <nmatsakis> (not a general type)
[14:03:11] <nmatsakis> this would kind of fit into your changes
[14:03:19] <nmatsakis> basically I was thinking we could merge the "method map" and this table
[14:03:26] <nmatsakis> so it would be sort of a "callee info" table
[14:03:36] *** Joins: saml (sam@moz-14C16814.cst.lightpath.net)
[14:03:38] <nmatsakis> and it would list the function signature and whatever other metadata we want relating to this call
[14:03:58] <nmatsakis> in that case, it would be perfectly reasonable to have the "self_ty" in there, whether it's part of the FnSig or not
[14:04:09] <nmatsakis> but it probably makes sense for it to be 
[14:04:14] <nmatsakis> since as you say it will eventually be "an argument"
[14:04:23] *** Quits: dymk (dymk@44EEE21C.A6E21E6E.5E500FC7.IP) (Connection reset by peer)
[14:04:25] <erickt> interesting. i like the idea of this table
[14:04:38] <nmatsakis> erickt: anyway, I was thinking of writing up a blog post on how I think we ought to do default methods
[14:04:49] <nmatsakis> and floating it around
[14:04:51] <nmatsakis> to see if others agree
[14:04:55] <nmatsakis> since it's a bit different from what we are doing now
[14:05:00] <nmatsakis> but I think it will work out much cleaner
[14:05:03] <nmatsakis> the tricky part is what to do in the meantime
[14:05:18] <nmatsakis> so, I guess the question is, if I hack around in there, will I be stepping on your toes?
[14:05:25] <nmatsakis> probably a bit. 
[14:05:32] <erickt> it doesn't seem semantically correct to associate a callee id to a regular old ty
[14:05:39] <nmatsakis> it's not really
[14:05:45] <nmatsakis> we often use ty::t as a stand-in
[14:05:48] <nmatsakis> but we ought to use something more narrow
[14:06:11] <erickt> I don't think you'll step on my toes, I'm still unfortunately in the learning stage
[14:06:12] <nmatsakis> this leads to confusing code and also a lot of "span_bug" calls (if you're lucky, otherwise just fail!)
[14:06:33] <nmatsakis> another example was that we used to ty::t for all references to traits, even though those aren't really *types*
[14:06:40] <nmatsakis> i.e., here: "impl Trait for Type"
[14:06:47] <nmatsakis> the reference to `Trait` is not a type...
[14:06:53] <nmatsakis> (what is the value?)
[14:07:07] <nmatsakis> (that's been fixed)
[14:07:39] <nmatsakis> so I'm trying whenever possible to disambiguate these things, so that the types tell you more narrowly what to expect at each point
[14:07:46] <kimundi> bstrie, nmatsakis: How would you like this multi-do syntax? https://gist.github.com/Kimundi/6403a2d10afdc0ed2bba
[14:08:23] <pnkfelix> nmatsakis: yeah the use of ty::t to mean a trait was a head-scratcher for me when I was skimming through the grammar.
[14:08:28] <pnkfelix> or the parser, rather.
[14:08:49] <erickt> kimundi: I have to say I don't see that buying too much over just passing closures to a regular function call
[14:08:51] <nmatsakis> pnkfelix: like many things, it kind of made sense at the time... :)
[14:09:08] <nmatsakis> kimundi: likewise. I guess I'm just not...upset that `do` takes only one argument.
[14:09:22] <nmatsakis> we could almost remove do altogether
[14:09:29] <nmatsakis> though it is nic sometimes :)
[14:10:03] <pnkfelix> clearly the problem here is the parenthesis-around the arguments syntax
[14:10:13] <nmatsakis> we should go to smalltalk I tell you
[14:10:23] <nmatsakis> smalltalk-like syntax I mean
[14:10:24] <pnkfelix> (ha ha, was that a secret promotion for Haskell/ML â€¦ or smalltalk â€¦ or for Lisp?  I'll never tell)
[14:10:45] <nmatsakis> pnkfelix: if it was meant as a promotion for LISP, it failed
[14:10:52] <nmatsakis> claiming that the problem is the parenthese does not suggest LISP to me
[14:10:57] <kimundi> Hm, it would buy the same thing as the first do closure: the ability to call closures in a more block like control-structury-way without needing enclosing brakets.
[14:11:58] <erickt> nmatsakis: yeah, that would be nice. I feel like the same information is stored in a couple different places. One specifically I wanted to ask you is regarding https://github.com/mozilla/rust/blob/master/src/librustc/middle/typeck/check/method.rs#L935
[14:12:12] <bstrie> kimundi: in my head I was always thinking something like https://gist.github.com/bstrie/56770cf2d57a151d3866 ... but now that I write it out it seems kind of ugly :P
[14:12:23] <nmatsakis> erickt: about confirm_candidate() in particular?
[14:12:33] <erickt> nmatsakis: there's a self_ty argument, and there's a transformed_self_ty in candidate.method_ty
[14:12:35] <erickt> yeah
[14:12:55] <erickt> what's the difference between the two?
[14:13:25] <nmatsakis> erickt: yes, there is a bit of duplication in method in general. I did a lot of refactoring (for example, introducing transformed_self_ty) and I didn't always get around to removing the old stuff
[14:13:31] <nmatsakis> erickt: let me look a sec to tell you :)
[14:13:41] <erickt> ok :)
[14:13:51] <nmatsakis> erickt: in some cases, *particularly* around object calls, the current paths are kind of bogus-y as well---or just don't quite feel clean yet, I don't know
[14:14:10] <bstrie> kimundi: in particular, I think all that I want from an expanded `do` syntax is the ability to call methods on the return type of the original function call, and that those methods can take paren-less closures just like the original function call
[14:14:30] <erickt> nmatsakis: I *think* the self_ty argument is the ty of the expression, whereas the transformed_self_ty may be a supertype of method receiver
[14:14:54] <nmatsakis> erickt: there are a lot of self_ty's floating around, to be sure, with different meanings
[14:15:05] <nmatsakis> erickt: you've reminded me that I had a plan to go inand try to purge some
[14:15:15] <nmatsakis> erickt: also some of these data structures in resolve that are kind of the same thing as ty::method
[14:15:18] <kimundi> bstrie: That would also be nice, but I think harder than building it in to the do block. because the do block ends as an expression once you chain from its end
[14:15:36] <nmatsakis> erickt: but yes, I think you have it right
[14:15:39] * erickt is not ready for resolve yet
[14:15:50] <bstrie> kimundi: I edited it a few times without realizing it would change the link that you saw :P look again
[14:15:50] * erickt has no resolve for resolve yet
[14:15:51] <kimundi> bstrie: I think this wouldn't be to bad: https://gist.github.com/Kimundi/6403a2d10afdc0ed2bba
[14:16:07] <bstrie> kimundi: I have a double-dot syntax for "extending" the scope of the do expression
[14:16:07] <nmatsakis> erickt: we should develop a convention that distinguishes the various cases. e.g., formal_self_ty for the version declared on the method, etc
[14:16:18] <nmatsakis> erickt: I was trying to introduce transformed and untransformed but I didn't get too far :)
[14:16:22] *** Joins: Erik (Erik@moz-252DBA2.hsd1.co.comcast.net)
[14:17:37] <erickt> yeah that took me a little bit to resolve those names as well :)
[14:18:30] <erickt> and how about rcvr_ty for when dealing with the type of the expression that's getting a method called on it?
[14:18:32] <bstrie> kimundi: I think that my proposal is the easiest to implement and the easiest to understand, but it's also nothing more than a little bit of sugar. the one on the ML seems much more wide-ranging
[14:19:00] <erickt> nmatsakis: I also saw explicit_self being used for ast::self_ty
[14:19:18] <kimundi> bstrie: Added a comment there, I think both our proposals are somewhat comparable in complexity.
[14:19:52] <nmatsakis> erickt: yes, I started doing a mass rename and stopp that too... sorry, I feel like I keep saying that :)
[14:20:00] <erickt> s'ok :)
[14:20:02] <nmatsakis> erickt: this was part of #5656 which was taking me forever (as you probably can understand)
[14:20:05] <nmatsakis> erickt: so I had to cut myself off
[14:20:19] <nmatsakis> erickt: (that is, the current treatment for &self)
[14:20:31] *** Quits: [o__o] (~o__o@moz-24EBFAC7.me) (Input/output error)
[14:20:32] *** Joins: [o__o] (~o__o@moz-24EBFAC7.me)
[14:20:35] <nmatsakis> I have to figure out what I'm going to do about default methods :/
[14:20:53] <nmatsakis> I think it's definitely out of scope for this branch to try and do anything real there...
[14:20:58] <nmatsakis> ...maybe I will just xfail
[14:21:02] <bstrie> kimundi: hm, I do like the colon as opposed to the doubledot. looks like ruby :) my only concern is that the colon is already used in a million places
[14:21:46] <bstrie> also the colon doesn't really evoke "call this as a method", whereas the doubledot is slightly more reasonble there
[14:21:55] <kimundi> bstrie: Your proposal would probably be more flexible and look more like a control structure because the names are inline. Mine on the other hand is simpler in the sense of 'n closures passed as last arguments'
[14:23:45] *** Quits: pyrac (pyrac@moz-2FEC2239.w92-149.abo.wanadoo.fr) (Quit: pyrac)
[14:23:49] <bstrie> kimundi: I think we should think of real use cases and compare how the implementations would look. I can imagine trap/in would love this, what else?
[14:24:14] <bstrie> I mean, it would be cool to be able to implement if statements nicely, but that's basically just an academic exercise here
[14:24:59] <bstrie> it might also be the case that it's just not worth avoiding typing four extra characters :)
[14:25:24] <kimundi> The mailing list example: io error handling. simd each_simd which needs to take two closures.
[14:26:45] <kimundi> bstrie: Well its not just the characters. It also means not intending all closures an additional level to the right if you want the ( ... {...} ... {...}) to nest probably
[14:27:03] *** Quits: jaen (jaen@E6617AFE.C79D1C03.43DC2829.IP) (Ping timeout)
[14:27:16] <kimundi> rust code creeps further to the right than other langueges as is
[14:27:36] <bstrie> kimundi: well also consider that you can define closures out-of-line as well :)
[14:27:49] <bstrie> let foo = || {...}
[14:28:07] <bstrie> so that could help avoiding indent-creep
[14:29:05] <kimundi> at the cost of needing to find n names for temporaries, having n temporaries till the end of the scope lying around, and typing much more boilerplate.
[14:29:38] <engla> why does Rust still use `+` for list concatenation? We need a separate operator. It would in fact be nice to have `++` and trait Monoid in the language..
[14:30:25] <kimundi> engla: imo + as concat is fine in a statically typed language
[14:31:39] <engla> I think it's wrong in many ways. + belongs to the num types
[14:32:03] <engla> a + b == b + a  doesn't hold etc.
[14:32:12] <kimundi> engla: concat ops make sense in a language that can implicitly convert values to fit the operations, so that you have better control about whats going to happen.
[14:32:33] <engla> why conflate two things into one operator?
[14:32:42] <kimundi> engla: that depends on wether you have assoziative addition ;)
[14:33:11] <engla> addition is commutative, period
[14:33:17] <bstrie> engla: the + operator isn't necessarily commutative in rust, even on numeric types
[14:33:43] <kimundi> engla: Only in specific cases, even though those are the majority of them
[14:34:01] <engla> why would you call it addition if it's not commutative?
[14:34:08] <bstrie> we don't
[14:34:13] <bstrie> it's the + operator :P
[14:34:16] <engla> ..
[14:34:25] <engla> (that's the concat operator in Lua :)
[14:34:33] <kimundi> engla: mathematical addition is just the main use case
[14:34:50] <engla> I think it's a mistake to conflate two different things into one
[14:34:57] <kimundi> engla: and there it makes sense because lua is dynamically typed
[14:35:04] *** Quits: Khady1 (khady@8DA4C5E7.8979521E.BA2F4534.IP) (Ping timeout)
[14:35:14] <engla> especially since mappend/concat is a very useful concept as haskell as shown
[14:35:22] <engla> so the trait makes a lot of sense on its own
[14:35:30] *** Joins: Scriptor (historium@moz-E06F46F0.corp.bitshelter.com)
[14:35:34] <engla> *as haskell has shown
[14:36:34] <kimundi> engla: Personally I wouldn't mind an extra concat operator. It's just that that is'nt really necessary.
[14:36:34] *** Quits: bheylin_ (brianheyli@1083AED6.51FADFE6.DE877FF9.IP) (Quit: bheylin_)
[14:36:57] <engla> I think it's necessary since it's been decided that lists can be joined with an operator
[14:37:04] <engla> so there needs to be a concat operator for that
[14:37:13] <engla> *vec
[14:39:04] *** Quits: Scriptor (historium@moz-E06F46F0.corp.bitshelter.com) (Quit: Scriptor)
[14:39:40] <kimundi> Most things you want to concatenate addition doesn't make sense on, and most things you want to add to each other concat doesn't make sense on. It would be clearer to seperate them from the get-go, but in a world where the most used languages with a c-like syntax conflate the two it might not be worth the trouble
[14:40:49] *** Joins: Yurume (yurume@AC58A8CE.8A059B47.E313B915.IP)
[14:41:35] <kimundi> then again a concat operator might allow bstrie - style multi do: 'do foo |a|  { ... } .. do bar(b,c) { ... }'
[14:41:47] <engla> the intention of the code is clearer. In some languages, [1,2,3] + [1,2,3] will be a sum of vectors
[14:42:28] <bstrie> honestly, I don't really feel the need to even have an operator to concat lists
[14:45:43] *** Joins: hmax_ (hmax@moz-53A94453.yandex.net)
[14:45:51] *** Quits: hmax (hmax@moz-15514FA1.yandex.net) (Ping timeout)
[14:47:10] <bstrie> it feels like an inherently inefficient operation, no reason to really encourage it :)
[14:47:15] *** Joins: youknowone (youknowone@A826BD81.8A0DEF81.38747683.IP)
[14:47:15] *** Quits: youknowone (youknowone@A826BD81.8A0DEF81.38747683.IP) (Z:lined (Open Proxy found on your host. Please visit www.blitzed.org/proxy?ip=115.68.131.49 for more information.))
[14:47:54] *** Quits: hmax_ (hmax@moz-53A94453.yandex.net) (Quit: This computer has gone to sleep)
[14:50:14] <nmatsakis> pnkfelix: did you say too-much-recursion was failing for you?
[14:50:21] <pnkfelix> nmatsakis: yeah
[14:50:26] <nmatsakis> me too (on linux i686)
[14:50:32] <pnkfelix> this is x86_64
[14:50:34] <pnkfelix> os x
[14:50:34] *** Joins: Khady1 (khady@96C5E894.872D636A.BA2F4534.IP)
[14:50:50] <doy> it fails for me too, x86_64 linux
[14:55:28] <EXetoC> engla: euclidean vectors?
[14:55:42] *** Joins: infynyxx (infynyxx@moz-E95B370B.nyc.res.rr.com)
[14:57:05] <Erik> EXetoC: Pointwise addition. [1,2] + [3,4] = [4,6]  This is how Matlab works. Very handy for linear algebra
[14:57:15] <kimundi> Hm, as often as I proposed some kind of of syntactic sugar recently, I should probably start looking into how the compiler works. Making proposals of how it could look like is pointless if it doesn't work...
[14:57:39] *** Quits: haard (fredrik@18E6EC45.6A26450D.BE04C429.IP) (Ping timeout)
[14:58:42] <EXetoC> Erik: ok, same thing
[15:00:16] *** Joins: Scriptor (historium@moz-37C6BBB2.corp.bitshelter.com)
[15:02:14] <EXetoC> bstrie: I don't like the idea of making something harder to do just because inexperienced users might abuse it. I think you need to have a little bit of experience anyway if you want to know how to speed things up
[15:02:36] *** Joins: thou (thou@moz-1C1CA9F7.fasttrackcomm.net)
[15:02:46] <EXetoC> but yeah, D for example uses a separate operator for this, and I think it's a good approach
[15:03:56] <bstrie> EXetoC: I'm not worried about inexperienced users abusing it, this is from the standpoint that the language should encourage good practices implicitly and for all I know (I ain't a systems programmer) list concatenation isn't a good practice
[15:07:35] <EXetoC> but it's not that uncommon, is it? though, is '+' supposed to do exactly what push_all does? because I used it once, and it was horribly slow, because the capacity of the vector on the left side wasn't preserved
[15:08:21] <bstrie> EXetoC: like I said, IANASP, so I can't say if it's uncommon. but even in my career of web programming I honestly can't think of a time when I've ever concatted a list
[15:08:24] <bstrie> strings, yeah, all the time
[15:08:31] <kimundi> EXetoC: That might've simply  been a implementation bug
[15:09:17] <EXetoC> kimundi: yeah I'm sure it was
[15:09:43] <bstrie> I also extend objects all the time. but list concatenation... who even does that?
[15:10:11] * nmatsakis does it (rarely, admittedly)
[15:10:17] <bstrie> at most, I append elements onto a list as I need to
[15:10:58] <bstrie> and if you're building up a list for the sole purpose of catting it into another list, I think you're just better off using vec::reserve on the first list and appending one at a time
[15:11:56] *** Quits: SimonSapin (simon@moz-58CD503D.fbx.proxad.net) (Quit: Leaving.)
[15:12:08] <EXetoC> the vec on the right side consisted of only 4 elements though [r, g, b, a], so it was just for the sake of convenience I guess
[15:12:15] <bstrie> but I still wouldn't be too worried about having a separate operator for concatenation, e.g. for strings and such
[15:12:22] <bstrie> but we're just running out of symbols...
[15:13:19] *** Joins: lkuper (lkuper@moz-C0CD33ED.hsd1.in.comcast.net)
[15:13:58] <EXetoC> there needs to be a programming-oriented layout for easy access to things like lambda, gamma, beta and what have you :>
[15:14:39] <EXetoC> let's design such a layout and then convince some keyboard manufacturer do start using it. who's with me?
[15:14:47] <kimundi> EXetoC: No problem, as long as you change to any other layout
[15:14:48] <bstrie> however, in a systems programming language, even string concatenation might be an anti-pattern
[15:14:51] <kimundi> Î»Ï‡Ï‰Ï‡Ï‰ÎºÎºÏˆÎºÏˆÏƒÎ½
[15:15:25] <bstrie> though it might be the best we have, since we don't have dynamic interpolation
[15:15:39] <nmatsakis> just get an APL keyboard off of ebay
[15:15:58] <kimundi> let f â† Î»x x + 2; l â† [1, 2, 3] Î¿ [4, 5, 6];
[15:16:50] <bstrie> erickt: is https://github.com/mozilla/rust/issues/3714 still relevant?
[15:17:19] <EXetoC> bstrie: but you don't have any issues with [1, 2, 3] + 42? or some other operator
[15:17:22] <kimundi> if âˆ€e âˆˆxs e < 5 { ... }
[15:17:33] <EXetoC> kimundi: awesome
[15:17:57] *** Joins: burntsushi__ (burntsushi@moz-A046EF37.eecs.tufts.edu)
[15:18:04] *** Quits: Scriptor (historium@moz-37C6BBB2.corp.bitshelter.com) (Ping timeout)
[15:18:22] <erickt> bstrie: I don't think so anymore
[15:18:22] <bstrie> EXetoC: I might, only because I agree with engla that mathematicians like to have custom ops for matrix things
[15:18:30] <kimundi> Funny thing is, I can type those symbols with my layout, but Ychat doesn't echo them back correctly
[15:18:34] <bstrie> and I have no idea if that would conflict with a matrix lib or something
[15:18:50] *** Joins: Scriptor (historium@moz-E06F46F0.corp.bitshelter.com)
[15:18:59] <engla> they look fine here kimundi. I also have Î» and âˆ€ in my keyboard layout
[15:19:42] <EXetoC> bstrie: ok. my linalg types are typed though, so it's just a matter of implementing the operator traits
[15:19:51] <Erik> This is why we need those OLED-keycap keyboards. Change layout and the keys change with it.
[15:20:05] <engla> you don't need to look at your keyboard
[15:20:06] <engla> :)
[15:20:24] *** Joins: akashj87 (akash@D6A139E0.CC3AFE9E.35E3DDC8.IP)
[15:21:52] *** Quits: rusti (rusti@moz-54F7FD49.cpe.net.cable.rogers.com) (Client exited)
[15:22:37] <bstrie> EXetoC: the way I see it, infix operators are great for avoiding nesting. but how often do you see `foo.push(bar.push(baz.push(qux)))`, which is what you'd be avoiding by writing `foo + bar + baz + qux` (assuming these are vectors)
[15:23:13] *** Joins: jaen (jaen@moz-E0979827.copit.pl)
[15:23:49] <bstrie> contrast this with string concatenation, which happens all the time, but usually only in the absence of suitable interpolation
[15:24:10] <bstrie> e.g. I'd kill for a standard interpolation mechanic in javascript
[15:24:23] <bstrie> where's dherman when you need him
[15:25:37] *** Quits: aatch (aatch@moz-2BB0AC01.cable.telstraclear.net) (Connection reset by peer)
[15:26:40] *** Joins: aatch (aatch@moz-2BB0AC01.cable.telstraclear.net)
[15:29:06] *** Joins: ghrust (ghrust@moz-4EF5B6E5.rs.github.com)
[15:29:06] <ghrust> 01[13rust01] 15bors 04force-pushed 06auto from 140d00821 to 14c081ffb: 02http://git.io/N3iJvQ
[15:29:06] *** Parts: ghrust (ghrust@moz-4EF5B6E5.rs.github.com) ()
[15:29:09] *** Joins: ghrust (ghrust@moz-4EF5B6E5.rs.github.com)
[15:29:09] <ghrust> 01[13rust01] 15bors pushed 2 new commits to 06auto: 02http://git.io/riOcQg
[15:29:09] <ghrust> 13rust/06auto 14869e0d9 15gifnksm: libstd: impl Clone for BigUint/BigInt and replace `copy` with `.clone()`
[15:29:09] <ghrust> 13rust/06auto 14704ebe5 15bors: auto merge of #6127 : gifnksm/rust/impl-clone-for-bigint, r=thestinger...
[15:29:09] *** Parts: ghrust (ghrust@moz-4EF5B6E5.rs.github.com) ()
[15:31:01] *** Joins: rusti (rusti@moz-54F7FD49.cpe.net.cable.rogers.com)
[15:40:06] *** Quits: pnkfelix (pnkfelix@moz-801E009D.vlan502.asr1.cdg2.gblx.net) (Quit: Leaving.)
[15:40:41] *** Joins: graydon (graydon@3853DDD.39EEDBB3.D758B1AA.IP)
[15:40:42] *** ChanServ sets mode: +qo graydon graydon
[15:41:57] *** Joins: devinus (devinus@moz-B4AF84BC.ptr.us.xo.net)
[15:42:02] *** Quits: erickt (Adium@49C4075F.3AC15C18.2321E71E.IP) (Quit: Leaving.)
[15:44:09] *** Quits: pnkfelix|rcirc (pnkfelix@moz-801E009D.vlan502.asr1.cdg2.gblx.net) (Input/output error)
[15:46:47] *** Joins: graham_king (graham_kin@moz-61791D81.vc.shawcable.net)
[15:49:56] *** Joins: jclements (jclements@2557E599.66715431.D25A875A.IP)
[15:52:12] *** Quits: xazax (Mibbit@6655692F.3B222813.3F580572.IP) (Quit: http://www.mibbit.com ajax IRC Client)
[15:52:14] *** Quits: Erik (Erik@moz-252DBA2.hsd1.co.comcast.net) (Ping timeout)
[15:53:43] *** Quits: lkuper (lkuper@moz-C0CD33ED.hsd1.in.comcast.net) (Quit: lkuper)
[15:55:05] *** Quits: infynyxx (infynyxx@moz-E95B370B.nyc.res.rr.com) (Client exited)
[15:56:13] *** Quits: tgt (tgt@moz-D59EE478.aztw.cable.virginmedia.com) (Quit: Textual IRC Client: www.textualapp.com)
[15:56:48] <snowmantw> will a enum variable store which variant it instanced ?
[15:57:09] <bstrie> snowmantw: can you give an example?
[15:57:22] <snowmantw> let s = Red;
[15:57:30] <snowmantw> I'm reading rustc's code
[15:57:39] <strcat> snowmantw: it's a tagged union, yes
[15:57:47] <bstrie> rusti: enum Color { Red, Blue }; let s = Red; s
[15:57:52] <rusti> Red
[15:58:04] <bstrie> snowmantw: ^
[15:58:07] <snowmantw> can't find which unit store such information..
[15:58:24] *** Joins: tgt (tgt@moz-D59EE478.aztw.cable.virginmedia.com)
[15:58:32] <strcat> enums have a discriminant to hold the current variant id
[15:58:43] <strcat> enums without data stored in them are *only* a discriminant
[15:59:20] <snowmantw> i've seen discriminat in CrateContext.. ( unrelated ? )
[16:00:08] <bstrie> snowmantw: are you trying to make a modification to the compiler itself?
[16:00:40] <snowmantw> yes, I send my proposal of GSoC 2013 and prepare to implement debuginfo
[16:00:46] <snowmantw> patch it
[16:00:53] <bstrie> ah
[16:00:53] <snowmantw> and try to get understand enum
[16:01:06] <bstrie> snowmantw: what proposal is this?
[16:01:23] <bstrie> rather, is there a bug already open for it?
[16:01:33] <snowmantw> jdm listed in ideas page of mozilla
[16:01:42] *** Joins: tjc (tjc@moz-E0677B46.vc.shawcable.net)
[16:01:42] *** ChanServ sets mode: +o tjc
[16:02:10] *** Quits: Khady1 (khady@96C5E894.872D636A.BA2F4534.IP) (Quit: WeeChat 0.3.8)
[16:02:16] *** Joins: azita (Azita@2557E599.66715431.D25A875A.IP)
[16:02:21] <bstrie> snowmantw: did you already send your proposal? because there are some other interesting projects here: https://github.com/mozilla/rust/issues?labels=A-an-interesting-project&page=1&state=open
[16:02:28] <snowmantw> https://wiki.mozilla.org/Community:SummerOfCode13#Rust
[16:02:40] <bstrie> ah, I haven't seen that page
[16:03:01] <graydon> https://etherpad.mozilla.org/Meeting-weekly-2013-04-30
[16:03:30] <snowmantw> that's only one "official" page I can found, so I submit my proposal to apply that
[16:03:35] *** Quits: trapni (trapni@moz-7C7C1909.dawanda.com) (Client exited)
[16:03:47] *** Quits: fzzzy (Donovan@moz-40919DA0.us-west-2.compute.amazonaws.com) (Ping timeout)
[16:03:55] *** Joins: fzzzy (Donovan@moz-40919DA0.us-west-2.compute.amazonaws.com)
[16:03:59] *** Joins: trapni (trapni@moz-7C7C1909.dawanda.com)
[16:04:52] <bstrie> snowmantw: that's fine, it's good to have a mentor :) jdm is in this channel sometimes
[16:05:00] <bstrie> at least, I think he is...
[16:05:06] *** Joins: ghrust (ghrust@moz-4EF5B6E5.rs.github.com)
[16:05:06] <ghrust> 01[13rust01] 15bors 04force-pushed 06auto from 14704ebe5 to 14c081ffb: 02http://git.io/N3iJvQ
[16:05:06] *** Parts: ghrust (ghrust@moz-4EF5B6E5.rs.github.com) ()
[16:05:09] *** Joins: ghrust (ghrust@moz-4EF5B6E5.rs.github.com)
[16:05:09] <ghrust> 01[13rust01] 15bors pushed 2 new commits to 06auto: 02http://git.io/WKt94g
[16:05:09] <ghrust> 13rust/06auto 14869e0d9 15gifnksm: libstd: impl Clone for BigUint/BigInt and replace `copy` with `.clone()`
[16:05:09] <ghrust> 13rust/06auto 14a55229d 15bors: auto merge of #6127 : gifnksm/rust/impl-clone-for-bigint, r=thestinger...
[16:05:09] *** Parts: ghrust (ghrust@moz-4EF5B6E5.rs.github.com) ()
[16:05:29] <snowmantw> I think I just can't find where to handle variable instancing...
[16:05:46] <snowmantw> because enum_def is just [variant]
[16:06:00] <snowmantw> and variant contains no such information
[16:06:08] <nmatsakis> snowmantw: what do you mean by variable instancing?
[16:06:21] <snowmantw> like `a = Red`
[16:06:29] <nmatsakis> snowmantw: the compiler doesn't know that information
[16:06:29] <bstrie> snowmantw: have you subscribed to the mailing list? https://mail.mozilla.org/listinfo/rust-dev
[16:06:38] <snowmantw> bstrie: yes
[16:06:40] <nmatsakis> snowmantw: that's kind of the point of an enum :)
[16:06:44] *** Quits: trapni (trapni@moz-7C7C1909.dawanda.com) (Ping timeout)
[16:06:48] <nmatsakis> that it could be any one of those variants and you won't know until runtime
[16:07:15] *** Quits: busylizzy (lisa@85228838.12D0DC84.211374C4.IP) (Ping timeout)
[16:07:19] *** Joins: busylizzy (lisa@85228838.12D0DC84.211374C4.IP)
[16:07:24] <snowmantw> I've looked into _match.rs, and there're many code about pattern
[16:07:43] *** Joins: brson (brson@2557E599.66715431.D25A875A.IP)
[16:07:43] *** ChanServ sets mode: +o brson
[16:07:52] <bstrie> I hear that the pattern matching code is scary :)
[16:08:13] <nmatsakis> snowmantw: you shouldn't need to deal with that code for this purpose, I don't think
[16:08:16] <snowmantw> "I will endeavor to explain the code as best I can." ...
[16:08:31] <nmatsakis> snowmantw: the code that is probably most relevant to you is the adt code
[16:08:51] *** Quits: Benvie (brandon@5FD20F9A.53D07D95.EFF8B7BF.IP) (Ping timeout)
[16:08:54] *** Joins: erickt (erickt@8C9ECD8F.3A598286.F12515B4.IP)
[16:09:11] *** Quits: busylizzy (lisa@85228838.12D0DC84.211374C4.IP) (Ping timeout)
[16:09:17] <snowmantw> I looked such info because structure can reveal it's inner structure by members at gdb
[16:09:18] *** Joins: pcwalton (pcwalton@43CB6079.66715431.D25A875A.IP)
[16:09:18] *** ChanServ sets mode: +o pcwalton
[16:09:25] <snowmantw> like {x: 3, y:4}
[16:09:47] *** Joins: Benvie (brandon@5FD20F9A.53D07D95.EFF8B7BF.IP)
[16:09:59] <snowmantw> but for an enum, I can't print useful info if I don't know which variant it pick up
[16:09:59] <nmatsakis> snowmantw: sorry, in a meeting, let's discuss later.
[16:10:10] <snowmantw> ok, thanks
[16:10:11] *** Joins: busylizzy (lisa@85228838.12D0DC84.211374C4.IP)
[16:11:37] *** Joins: pnkfelix (pnkfelix@moz-43495417.fbx.proxad.net)
[16:11:43] *** Joins: brendan (brendaneic@6BC3D9FF.179B5C1A.50A7E6A6.IP)
[16:11:50] *** Joins: bent (chatzilla@moz-BE33DA21.fw1.sfo1.mozilla.net)
[16:11:54] *** Quits: busylizzy (lisa@85228838.12D0DC84.211374C4.IP) (Ping timeout)
[16:12:18] *** Joins: busylizzy (lisa@85228838.12D0DC84.211374C4.IP)
[16:13:30] *** Quits: brendan (brendaneic@6BC3D9FF.179B5C1A.50A7E6A6.IP) (Quit: brendan)
[16:14:47] *** Quits: devinus (devinus@moz-B4AF84BC.ptr.us.xo.net) (Quit: Computer has gone to sleep.)
[16:15:36] *** Quits: hansjorg (hansjorg@moz-EECB5F79.static.cust.telenor.com) (Ping timeout)
[16:17:27] *** Joins: Blei (philipp@moz-96D25F7A.cust.bluewin.ch)
[16:17:51] *** Joins: hansjorg (hansjorg@moz-EECB5F79.static.cust.telenor.com)
[16:18:12] *** Joins: pnathan (pnathan@moz-F1EB55E5.pools.spcsdns.net)
[16:18:35] *** Quits: hansjorg (hansjorg@moz-EECB5F79.static.cust.telenor.com) (Quit: Leaving.)
[16:23:03] *** Joins: devinus (devinus@moz-B4AF84BC.ptr.us.xo.net)
[16:23:11] *** Joins: Jesse (jruderman@moz-537BCF9.hsd1.ca.comcast.net)
[16:25:15] *** Quits: bnicholson (bnicholson@moz-E98974C1.hsd1.ca.comcast.net) (Ping timeout)
[16:26:37] *** Joins: bnicholson (bnicholson@moz-E98974C1.hsd1.ca.comcast.net)
[16:27:28] <pcwalton> can someone link the meeting agenda?
[16:27:28] *** Quits: busylizzy (lisa@85228838.12D0DC84.211374C4.IP) (Ping timeout)
[16:27:59] <nmatsakis> pcwalton: https://etherpad.mozilla.org/Meeting-weekly-2013-04-30
[16:28:10] *** Joins: busylizzy (lisa@85228838.12D0DC84.211374C4.IP)
[16:29:01] *** Quits: Nisstyre (wes@moz-FD86289.netflash.net) (Quit: Leaving)
[16:31:09] *** Quits: devinus (devinus@moz-B4AF84BC.ptr.us.xo.net) (Quit: Computer has gone to sleep.)
[16:31:54] *** Quits: igl (igl@moz-56C8DB9C.adsl.alicedsl.de) (Ping timeout)
[16:31:54] *** Quits: engla (engla@moz-BFD53D48.selucle.dyn.perspektivbredband.net) (Ping timeout)
[16:31:54] *** Joins: igl (igl@moz-4977F47.adsl.alicedsl.de)
[16:32:32] *** Parts: judder (maradukewa@DABDEEA3.F2C0D0AC.78E362FE.IP) ()
[16:33:06] <nmatsakis> graydon: for after the meeting, I wanted to ask you about the difference between M-1 and M-2
[16:35:08] *** Quits: akashj87 (akash@D6A139E0.CC3AFE9E.35E3DDC8.IP) (Quit: Leaving)
[16:38:25] <graydon> nmatsakis: M?
[16:38:26] *** Quits: fabiand (fabiand@moz-A27A2041.adsl.alicedsl.de) (Quit: Verlassend)
[16:38:36] <Diablo-D3> okay so
[16:38:44] <nmatsakis> graydon: (milestone)
[16:38:47] <Diablo-D3> rust is meant to deal with large scale concurrency, right?
[16:38:58] *** Joins: SimonSapin (simon@moz-C4A83ED9.net-89-2-126.rev.numericable.fr)
[16:38:59] <graydon> ok
[16:39:42] <graydon> Diablo-D3: more or less
[16:40:01] <Diablo-D3> someone please kill hadoop
[16:40:07] <Diablo-D3> use rust, kill hadoop.
[16:40:09] <Diablo-D3> just do it.
[16:40:43] <snowmantw> hadoop won because it
[16:40:58] <snowmantw> JVM based, and java fans like it LOL
[16:41:22] <Diablo-D3> hadoop will never win
[16:41:22] <Diablo-D3> because its java
[16:42:05] <snowmantw> I realized a fact that Java can always attract some programmers and enterprises.....
[16:42:39] <Diablo-D3> I coded 1 program in Java
[16:42:41] *** Joins: jfredett (jfredett@moz-C01C350.bstnma.fios.verizon.net)
[16:42:42] <Diablo-D3> I am sorry I ever did that
[16:44:55] <snowmantw> in my country, CS dept almost only teach Java as students' major language
[16:45:10] <snowmantw> so it's never gone/
[16:45:36] <Diablo-D3> and not lisp?
[16:45:42] <Diablo-D3> your country is now illegal
[16:45:42] <snowmantw> no..
[16:45:49] <snowmantw> :D
[16:45:53] <Diablo-D3> its been banned, the bombing will commence in 15 minutes
[16:46:10] <snowmantw> you can learn another language of course... C#..
[16:46:35] <Diablo-D3> I tried that
[16:46:37] <Diablo-D3> c# is even worse
[16:46:44] <snowmantw> and no JS, Lisp, Ruby, Python..
[16:47:34] <Diablo-D3> you only said 1 real language out of those four
[16:47:51] <Blei> huh, did this ever work? implementing a function on a trait instead of a type, like `impl MyTrait { fn foo() { ... } }`
[16:47:58] *** Joins: infynyxx (infynyxx@DB780A29.749BA1D.DCC373F0.IP)
[16:49:06] *** Joins: indutny (indutny@moz-49D42D15.c.ircrelay.com)
[16:49:16] <indutny> hi!
[16:49:18] <strcat> Diablo-D3: "real" language?
[16:49:35] <Diablo-D3> strcat: one that isn't utter shit
[16:49:36] <kimundi> Blei: Idk, I just now about impl TRAIT for TYPE and impl TYPE
[16:49:51] <strcat> Diablo-D3: and which do you think that is?
[16:49:57] <indutny> just curious, what's the purpose of rustc's --lib option if one can't link *.o files using gcc?
[16:50:04] <doy> Diablo-D3: this doesn't really seem to be a very useful line of conversation
[16:50:12] <strcat> indutny: --lib makes a .so
[16:50:12] <indutny> and would it be possible to invoke rust functions from C?
[16:50:17] <indutny> ah, right
[16:50:18] <strcat> indutny: yes
[16:50:20] <indutny> well
[16:50:26] <indutny> its not
[16:50:29] <indutny> if -c is present
[16:50:45] <indutny> so, if I use -c --lib - I get .o file
[16:50:55] <indutny> but its unlinkable with gcc, because of missing rust functions
[16:50:58] <kimundi> indutny: Invoking from c will be possible once you can compile a lib without runtime
[16:51:33] <strcat> indutny: afaik -c and -c --lib are the same thing
[16:51:34] <indutny> ok, and how is it possible?
[16:51:45] <Diablo-D3> strcat: C is okay, perl is okay, c++ is not, ruby is not, python is not, lisp probably depending on the variant
[16:51:48] <indutny> strcat: well, it fails to build if there're no fn main()
[16:51:50] <Diablo-D3> erlang I think might be okay
[16:51:55] <kimundi> how is what possible?
[16:51:57] <indutny> strcat: --lib
[16:52:00] <Diablo-D3> Ive seen interesting shit done in erlang, I do not understand the syntax at all
[16:52:01] <indutny> oi
[16:52:03] <indutny> sorry, -c fails
[16:52:05] <indutny> without --lib
[16:52:30] *** Joins: engla (engla@moz-BFD53D48.selucle.dyn.perspektivbredband.net)
[16:52:37] <strcat> Diablo-D3: so how have you decided which languages are 'okay' and which aren't?
[16:52:49] <strcat> why is perl okay, but ruby/python aren't?
[16:52:55] *** Joins: ghrust (ghrust@moz-4EF5B6E5.rs.github.com)
[16:52:55] <ghrust> 01[13rust01] 15brson merged 06incoming into 06master: 02http://git.io/8q8THg
[16:52:55] *** Parts: ghrust (ghrust@moz-4EF5B6E5.rs.github.com) ()
[16:53:19] <Diablo-D3> strcat: depends entirely how much it pisses me off with how poorly planned the language is
[16:53:30] * indutny thought that there'll be language development discussion here
[16:53:44] <indutny> is there any other channel for it?
[16:53:44] <strcat> indutny: usually is
[16:53:44] <kimundi> indutny: There should be...
[16:53:47] <indutny> ah
[16:54:21] <Blei> kimundi: yeah, i found this github repo that doesn't compile anymore, so i guess it was allowed once. thanks
[16:54:29] <Diablo-D3> strcat: I dunno, I think I like rust from what Ive seen of the syntax
[16:54:29] <kimundi> indutny: You can discuss the rust language and ask for help here :)
[16:54:52] <indutny> haha
[16:54:53] <indutny> thanks
[16:55:05] <indutny> so far I'm just configuring build
[16:55:40] *** Joins: Jesin (Jessin_@moz-1866A4CC.cc.lehigh.edu)
[16:56:04] <kimundi> indutny: Why do you need the -c option?
[16:56:05] <Diablo-D3> no one has answered my question the other day though
[16:56:29] <indutny> kimundi: well, I was thinking about creating a static library
[16:56:32] <indutny> to use it later from C
[16:56:46] <indutny> something like this
[16:56:56] <kimundi> Diablo-D3: Well, there are no guarantees about who is how helpful on which days, that should be obvios...
[16:57:15] <Diablo-D3> well, I want to do the "async message to a dequeue and have a loop process the dequeue" model
[16:57:23] <Diablo-D3> ie, pipe -> select loop
[16:58:04] <kimundi> indutny: Well, static compilation is not yet possible with rust, and it would also not be callable from C because it needs a runtime at the moment, so... For now you're out of luck :(
[16:58:20] <indutny> I see
[16:58:29] <indutny> would be good if it'd be possible to "export" some functions
[16:58:45] <indutny> but anyway, that's not that important
[16:58:47] <indutny> I can live without it
[16:58:53] <indutny> considering that I'm writing a binary anyway
[16:59:20] *** Quits: jclements (jclements@2557E599.66715431.D25A875A.IP) (Quit: jclements)
[16:59:33] *** Quits: pnkfelix (pnkfelix@moz-43495417.fbx.proxad.net) (Quit: Leaving.)
[16:59:56] <Diablo-D3> so can rust do what I want?
[17:00:00] <kimundi> Diablo-D3, just for referenc, I saw that question yesterday and didn't answer because I don't know enough of the terminology and how it relates to the current rewrite of the io and task sheduler to give a useful answer.
[17:00:32] <kimundi> indutny: static linking and standalone callability is definitly planned, though
[17:00:48] <kimundi> indutny: It just... "needs work" ;)
[17:00:48] <pcwalton> there's a HN post about Rust and separation logic of all things on the front page
[17:01:10] <indutny> I can probably help you, but after I'll create that erlang jit compiler prototype in rust
[17:01:17] <indutny> just want to get feel of the language
[17:01:56] *** Quits: pcwalton (pcwalton@43CB6079.66715431.D25A875A.IP) (Quit: pcwalton)
[17:01:57] <nmatsakis> pcwalton: &mut has strong connections to sep logic
[17:02:17] * nmatsakis goes to read HN for the first time in....forever
[17:03:35] *** Joins: pcwalton (pcwalton@43CB6079.66715431.D25A875A.IP)
[17:03:35] *** ChanServ sets mode: +o pcwalton
[17:03:49] <bblum> speaking of separation logic, you all heard that john reynolds died?
[17:03:50] <bblum> RIP
[17:03:56] <nmatsakis> indeed
[17:04:28] <Blei> ice!
[17:04:40] <Blei> hmm, that was ill timed
[17:04:50] <kimundi> Diablo-D3: Again, I'm not sure what exactly you want, but it _sounds_ like something that should be possible, and might even be how rusts message passing works internally
[17:05:13] <snowmantw> nmatsakis: I'm reading the `adt.rs` and find a `trans_get_discr`, seems I can use it to get enum variable's variant 
[17:05:26] <nmatsakis> snowmantw: great
[17:05:31] <nmatsakis> snowmantw: that's what I wanted to point you at, basically
[17:05:35] *** Joins: spider-mario (spidermari@moz-2F72F6FF.dsl.quantic-telecom.net)
[17:05:51] <snowmantw> I will continue to study, thanks !
[17:06:39] *** Joins: jclements (jclements@2557E599.66715431.D25A875A.IP)
[17:07:43] *** Quits: tjc (tjc@moz-E0677B46.vc.shawcable.net) (Quit: Places to go, people to annoy)
[17:09:22] *** Quits: bnicholson (bnicholson@moz-E98974C1.hsd1.ca.comcast.net) (Ping timeout)
[17:10:03] *** Joins: mschifer (Adium@2557E599.66715431.D25A875A.IP)
[17:10:17] *** Joins: pyrac (pyrac@moz-2FEC2239.w92-149.abo.wanadoo.fr)
[17:11:08] <nmatsakis> brson: so are you working on a snapshot now that tree is green?
[17:12:22] *** Joins: ysuzuki (ysuzuki@moz-60FA9D06.net119083145.t-com.ne.jp)
[17:12:38] *** Quits: ysuzuki (ysuzuki@moz-60FA9D06.net119083145.t-com.ne.jp) (Client exited)
[17:12:59] *** Joins: ysuzuki (ysuzuki@moz-60FA9D06.net119083145.t-com.ne.jp)
[17:13:04] <kimundi> brson: Btw, any Idea why the fail!() change might've caused that test failure?
[17:13:21] <kimundi> Doesn't seem directly related
[17:14:57] *** Quits: snowmantw (Mibbit@moz-69896760.cs.nccu.edu.tw) (Quit: http://www.mibbit.com ajax IRC Client)
[17:15:21] <strcat> ahhh, silly old borrowck
[17:15:29] * strcat always hits the flow sensitivity bug ;p
[17:16:03] *** Joins: tjc (tjc@moz-E0677B46.vc.shawcable.net)
[17:16:03] *** ChanServ sets mode: +o tjc
[17:16:26] <friggle> well from the meeting notes  it's looking like it's becoming fairly high priority now
[17:17:30] <strcat> I don't think I can write min/max for iterators without copies, unsafe or a bunch of swaps
[17:18:11] <strcat> swaps it is.
[17:19:24] <strcat> iter.rs:134:16: 134:22 error: swapping to and from captured outer immutable variable in a stack closure
[17:19:26] <brson> nmatsakis: yes
[17:19:27] <strcat> iter.rs:134         tmp <-> result;
[17:19:29] <strcat> :(
[17:19:31] *** Joins: Khady1 (Khady@2B4E7F10.FC3B8B76.BA2F4534.IP)
[17:19:56] <nmatsakis> strcat: declare the variables as mutable?
[17:20:09] <brson> kimundi: no I don't know. I doubt it's directly related, but just stirred up a codegen bug
[17:20:22] *** Quits: pnathan (pnathan@moz-F1EB55E5.pools.spcsdns.net) (Quit: Colloquy for iPhone - http://colloquy.mobi)
[17:20:39] <strcat> nmatsakis: http://ix.io/5pM well, that works
[17:20:43] <strcat> but...
[17:20:51] *** Joins: sammykim_ (Mibbit@48AEBDE2.ACF655DA.97B9B372.IP)
[17:20:55] <indutny> sorry guys, it might sounds stupid
[17:21:03] <indutny> but can I open and read a file in rust? :)
[17:21:06] <sammykim_> Hi, guys
[17:21:07] <strcat> http://ix.io/5pN should be like that ;p
[17:21:23] <sammykim_> indutny: Ofcourse, you can.
[17:21:24] <strcat> (mut result)
[17:21:41] <indutny> ok, how? :)
[17:21:47] <strcat> heh it actually works
[17:21:50] * strcat is silly
[17:21:52] <indutny> using std::uv?
[17:22:03] <kimundi> indutny: Sure you can :) But the wholi io system is basically horrible at the moment and in the process of being rewritten, so don't worry if it seems strange.
[17:22:13] <indutny> hahaha
[17:22:17] *** Quits: infynyxx (infynyxx@DB780A29.749BA1D.DCC373F0.IP) (Client exited)
[17:22:20] *** Quits: davbo (dave@moz-3FFA637C.oucs.ox.ac.uk) (Client exited)
[17:22:23] <sammykim_> I think you need to look into core::io
[17:22:25] *** Joins: devinus (devinus@moz-B4AF84BC.ptr.us.xo.net)
[17:22:40] <sammykim_> might be there are some APIs you need to look up :)
[17:22:53] <sammykim_> I am also newer as like u :) 
[17:23:18] <indutny> haha
[17:23:23] <sammykim_> haha
[17:23:28] <indutny> it seems that it'd be better to stick to C++
[17:23:33] <indutny> which is quite sad
[17:23:48] <indutny> this APIs are totally horrible
[17:23:56] <indutny> ah
[17:23:56] <indutny> anyway
[17:23:58] <indutny> that won't stop me
[17:23:59] <indutny> :)
[17:24:07] <kimundi> indutny: Well they hopefully won't remain that way :)
[17:24:31] *** Joins: bnicholson (bnicholson@2557E599.66715431.D25A875A.IP)
[17:24:48] <sammykim_> I think it's really horrible to reference the document.. someitmes it's better look in code to reference :)
[17:24:53] <kimundi> indutny: There is a discussion on the mailing list atm about how to structure the new apis
[17:25:42] *** Joins: twm (twm@moz-13417AD3.dsl.static.sonic.net)
[17:25:53] <indutny> oh gosh
[17:25:54] <indutny>         while !self.eof() { bytes.push_all(self.read_bytes(2048u)); }
[17:25:54] <indutny> :)
[17:26:00] <indutny> that's pretty serious
[17:26:43] <EXetoC> io::read_whole_file
[17:26:51] <indutny> yes, that's it
[17:26:54] <indutny> actually
[17:26:55] <EXetoC> or read_whole_file_str
[17:26:57] <indutny> its read_whole_stream
[17:27:21] *** Khady1 is now known as list
[17:27:54] <EXetoC> yes if you're using readers
[17:28:03] <benh> how about read_whole_file_in_chunks_that_are_then_passed_to_this_writer(w)
[17:28:33] <indutny> indeed :)
[17:29:28] <sammykim_> indutny: https://github.com/mozilla/rust/blob/master/src/libcore/io.rs
[17:29:38] <indutny> I'm looking at it right now
[17:29:41] <indutny> thanks
[17:29:47] <sammykim_> oh really.?
[17:29:58] <sammykim_> then find the code you want to use API..
[17:30:24] *** Joins: dherman (dherman@moz-B31C6965.dsl.pltn13.sbcglobal.net)
[17:30:24] *** ChanServ sets mode: +o dherman
[17:34:45] <nmatsakis> graydon: yeah so graydon I don't quite get the distinction between "well-defined" and "backwards compat"
[17:34:52] <nmatsakis> (even though I've read the text)
[17:34:59] *** Quits: engla (engla@moz-BFD53D48.selucle.dyn.perspektivbredband.net) (Ping timeout)
[17:35:09] *** Quits: CarpNet (ac@moz-FD24B77.sohonet.co.uk) (Quit: Leaving)
[17:36:09] <graydon> oh, ok
[17:36:28] <graydon> nmatsakis: well defined means we have the ability to measure backwards compat
[17:36:33] *** Joins: haard (fredrik@moz-6A86987C.dynamic.se.alltele.net)
[17:37:02] <nmatsakis> graydon: so, if there is a question of what the language ought to do that is as yet unresolved,
[17:37:05] <graydon> that is, a bug belongs on there if it substantially effects our ability to catch backwards-compat breakage
[17:37:10] <nmatsakis> graydon: is that "well-defined" or "backwards compat"?
[17:37:15] <nmatsakis> ah
[17:37:17] <graydon> backwards compat
[17:37:29] <nmatsakis> can you give me an example of a well-defined bug?
[17:37:31] <Diablo-D3> [01:03:26] <kimundi> Diablo-D3: Again, I'm not sure what exactly you want, but it _sounds_ like something that should be possible, and might even be how rusts message passing works internally
[17:37:33] <nmatsakis> I guess I can see what's in there
[17:37:36] <graydon> nmatsakis: "have a testsuite"
[17:37:55] <sammykim_> Issue 5531 , I removed the code of "Reexported core operators" and "Reexported types and traits" but when I compiled the code after removed it, I could just got error.. [I commented https://github.com/mozilla/rust/issues/5531 here.]
[17:37:58] <graydon> nmatsakis: "have a testsuite that checks the grammar", "have a thing that enumerates APIs and checks that they are present"
[17:38:20] <nmatsakis> graydon: ok.
[17:38:28] <bstrie> Diablo-D3: there are probably a lot of programming models that haven't yet been tried in rust, it's possible that yours is one of them. if you have some C code maybe someone can produce the equivalent rust code
[17:39:12] <graydon> nmatsakis: "have a documented semantics for each production such that when we change it we'll know it's likely we're breaking backwards compat"
[17:39:12] <Diablo-D3> well, can I do unix pipes and select() in rust?
[17:39:30] <Diablo-D3> also, I havent read enough about rust to understand the message passing system yet
[17:39:52] *** Quits: list (Khady@2B4E7F10.FC3B8B76.BA2F4534.IP) (Quit: WeeChat 0.3.8)
[17:39:53] *** Parts: mschifer (Adium@2557E599.66715431.D25A875A.IP) ()
[17:39:59] <graydon> nmatsakis: these don't have to be bullet-proof / complete mechanisms, but even spending time setting up such mechanisms is work. measurable work that, when not-done, makes it difficult to proceed to establishing claims of backwards compatibility.
[17:40:01] <nmatsakis> graydon: that last one seems... similar to a bug that decides what action we should take
[17:40:30] <graydon> nmatsakis: clarify? I'm not sure I understand what you just said
[17:40:40] <nmatsakis> graydon: having a defined semantics for each production
[17:40:41] *** Quits: Jesin (Jessin_@moz-1866A4CC.cc.lehigh.edu) (Ping timeout)
[17:40:58] <nmatsakis> my first example was "if I don't know whether X or Y should happen in some situation"
[17:41:04] <nmatsakis> and you said that would be backwards compat
[17:41:12] <nmatsakis> but it seems like that's the same thing as having a well-defined semantics
[17:41:17] *** Joins: int3_ (int3_@moz-359A42F6.subnet-248.amherst.edu)
[17:41:24] <Diablo-D3> so are rust messages the kind you put in a dequeue?
[17:41:35] <Diablo-D3> or are they the kind that are just another name for methods
[17:42:02] <nmatsakis> graydon: anyway, it's not super imp't, but I get the idea of a category for bugs that relate to tools for establishing backwards compat, vs backwards compatibility itself
[17:42:17] <graydon> nmatsakis: a change from X to Y, or from Y to X, is a backwards-compat-affecting bug
[17:42:29] *** Quits: Khady (khady@moz-31F9D77E.khady.info) (Quit: FFFFFFFFFFUUUUUUUUUU-)
[17:42:34] *** Joins: Khady (Khady@moz-31F9D77E.khady.info)
[17:42:34] <strcat> Diablo-D3: do you just want a FIFO channel?
[17:42:35] <graydon> nmatsakis: the bug called "have a place where you've written down whether it's X or Y" is a well-definedness bug
[17:42:38] *** Joins: Jesin (Jessin_@moz-1866A4CC.cc.lehigh.edu)
[17:42:50] <graydon> nmatsakis: does that clarify?
[17:42:52] <bstrie> Diablo-D3: they're messages. to communicate you create a port/channel pair between tasks, where the port is the receiving end. you can receive from the port whenever you want in the task that has it
[17:42:53] <Diablo-D3> strcat: basically.
[17:43:00] <strcat> Diablo-D3: core::comm has that stuff
[17:43:11] <nmatsakis> graydon: yes, that's sort of what I thought. I think the confusion arises because in practice those two are often joined at the hip
[17:43:12] <Diablo-D3> can I fork() in rust?
[17:43:18] <nmatsakis> graydon: i.e., "decide what we should do and make it do it"
[17:43:23] <strcat> Diablo-D3: no there isn't multiprocessing yet
[17:43:28] <Diablo-D3> hrm
[17:43:33] <sammykim_> Anyone can advise me to solve this issue number #5531?
[17:43:33] <strcat> Diablo-D3: you can use tasks and core::comm for communication
[17:43:45] <Diablo-D3> does rust contain any thread safe code?
[17:43:46] <bstrie> strcat: you can't set up a scheduler to use multiple processes yet?
[17:44:14] <kimundi> Diablo-D3: They are not another name for methods. each task (which generally is a green thread) can send messages to each other (generally owned values) using the pipes apt (something that creates a send and receive endpoint, of which either can be moved into a new task and then used from there)
[17:44:35] <strcat> Diablo-D3: everything is thread-safe
[17:44:46] <Diablo-D3> strcat: damn =/
[17:44:55] *** Joins: sammykim__ (Administra@48AEBDE2.ACF655DA.97B9B372.IP)
[17:44:59] * Diablo-D3 wishes more people would just reject threads and never look back
[17:45:00] *** Quits: sammykim_ (Mibbit@48AEBDE2.ACF655DA.97B9B372.IP) (Quit: http://www.mibbit.com ajax IRC Client)
[17:45:00] <graydon> nmatsakis: hm. maybe? I guess my point was that the effort of merely writing down what the language does today, in well-enough-specified form that you could notice changes to its behavior by watching diffs against that doc, is itself a lot of work.
[17:45:07] <strcat> Diablo-D3: why?
[17:45:10] <strcat> tasks map to threads
[17:45:14] <graydon> nmatsakis: that work -- the writing-down part -- needs to get scheduled, scoped, done-by-someone
[17:45:20] <Diablo-D3> they serve no purpose
[17:45:21] <nmatsakis> graydon: yeah makes sense. and perhaps it makes sense to create distinct bugs in any case. 
[17:45:22] <graydon> nmatsakis: even absent _any_ changes to the behavior
[17:45:27] *** Quits: Khady (Khady@moz-31F9D77E.khady.info) (Quit: WeeChat 0.3.8)
[17:45:30] *** Joins: Khady (Khady@moz-31F9D77E.khady.info)
[17:45:34] <nmatsakis> graydon: this gets back to the fact that it'd be great if github issues had dependencies
[17:45:37] <graydon> yeah
[17:45:42] <strcat> Diablo-D3: so why do you want multiprocessing instead of tasks?
[17:45:51] <jld> Diablo-D3: Things in Rust are "thread safe" in that shared mutable state isn't possible (without using an unsafe block).
[17:46:03] <strcat> with tasks you can do copy-free communication with ~
[17:46:39] <Diablo-D3> strcat: non-unified memory, no wasted time on locks, mutexes, STM, etc, no hard to debug situations, no accidental NUMA fuckage due to poorly designed memory pools, etc
[17:47:15] <strcat> Diablo-D3: locks/mutexes/STM aren't used anywhere that equivalent sync wouldn't have to be used for multiprocessing
[17:47:19] <eevee> Diablo-D3: i understand where you're coming from (and would also like strong async+multiprocessing in rust) but tasks really /aren't/ threads; they just happen to use threads as an implementation detail, much like ~ may use malloc or brk or whatever as an implementation detail
[17:47:31] <strcat> Diablo-D3: rust's memory model doesn't have shared memory between tasks
[17:47:45] <Diablo-D3> strcat: it doesnt matter, the OS forces you to have it
[17:47:49] <Diablo-D3> even if you choose not to use it
[17:48:00] <strcat> Diablo-D3: it's not a choice, the compiler won't let you use shared memory
[17:48:15] <jld> pcwalton: It looks like 876483dcf4bdcd0001cc25812060bc04cf367f60 reverted my change to the src/llvm submodule pointer.  Was that intentional?
[17:48:17] <Diablo-D3> and no, I dont use explicit syncing in concurrent apps
[17:48:21] <Diablo-D3> everything is a message
[17:48:23] <pcwalton> jld: unintentional, sorry
[17:48:31] <strcat> Diablo-D3: ok, and the kernel is doing sync for the message queues
[17:48:39] <bstrie> Diablo-D3: https://gist.github.com/bstrie/5490454 for a tiny example
[17:48:40] <strcat> Diablo-D3: have you looked at how rust's tasks work?
[17:48:43] <strcat> Diablo-D3: you use message passing
[17:48:47] <strcat> there isn't shared memory
[17:49:06] <strcat> Owned things can be sent without a copy by virtue of having a unique owner
[17:49:10] <Diablo-D3> strcat: the kernel is doing zero copy on the memory page that contains the write buffer for the pipe
[17:49:24] <Diablo-D3> which is a little different than syncing
[17:49:41] <jld> pcwalton: Okay.  But that change should have set the tests on fire....
[17:49:44] <Diablo-D3> its also the fastest method available for this
[17:50:06] *** Parts: Blei (philipp@moz-96D25F7A.cust.bluewin.ch) (WeeChat 0.4.0)
[17:50:15] <strcat> Diablo-D3: copying a pointer between threads for message passing is pretty much as fast as it gets
[17:50:20] <strcat> that's what sending ~ does
[17:50:27] <jld> pcwalton: Oh.  2c6dae081b72d33a2c51b5f46436e6350bb3682f disabled it.
[17:50:31] <strcat> you're moving ownership - there isn't shared memory
[17:50:34] <strcat> but all it does is copy a ptr
[17:50:52] <Diablo-D3> strcat: erm
[17:50:58] <Diablo-D3> but the memory IS shared then
[17:51:04] <strcat> Diablo-D3: no
[17:51:08] <strcat> it's owned by one task at a time
[17:51:14] <strcat> it can never be shared
[17:51:18] <bstrie> the compiler enforces this
[17:51:20] <Diablo-D3> both threads can see it, you're just doing erlang ownership on it to try to defeat the locks problem
[17:51:33] <strcat> Diablo-D3: both threads can't see it, and erlang doesn't have ownership
[17:51:33] <bstrie> Diablo-D3: all the magic is at compile time. no locks
[17:51:40] <Diablo-D3> your compiler is enforcing a model instead of just making it impossible to begin with
[17:51:40] <strcat> erlang copies between tasks
[17:51:47] *** Quits: int3_ (int3_@moz-359A42F6.subnet-248.amherst.edu) (Client exited)
[17:51:54] *** Quits: SimonSapin (simon@moz-C4A83ED9.net-89-2-126.rev.numericable.fr) (Ping timeout)
[17:52:03] <Diablo-D3> I thought erlang used an ownership model internally to do concurrent processing?
[17:52:23] <strcat> Diablo-D3: it just doesn't allow shared memory and every message is a copy
[17:52:27] <kimundi> Diablo-D3: It is shared in the sense that there is a common address space, whic allows cheap pointer copies. It's seperated in the sense that rust forbids you to share memory between tasks in a way that race conditions can appear
[17:52:39] <strcat> erlang's tasks act just like processes
[17:52:52] <strcat> no shared memory and the only way to send a message is to copy
[17:53:11] <strcat> rust's tasks are the same, but it has ownership and move semantics so you can send Owned things without a copy
[17:53:38] <benh> How is blocking on receiving a message implemented by the way?
[17:53:56] <benh> Do you give a list of ports you're waiting on to the scheduler and the scheduler reschedules you once either has received a message?
[17:54:05] <bstrie> benh: you'll have to ask brson
[17:54:20] <Diablo-D3> strcat: wtf, it explicitly copies everything?
[17:54:25] <Diablo-D3> holy crap, no wonder its so slow
[17:54:38] <strcat> Diablo-D3: in the same way that sending messages between processes copies
[17:54:43] <strcat> you have to copy into the message queue
[17:54:52] <Diablo-D3> yeah, but you cant zero copy from userspace unless you use a socket or a pipe
[17:55:01] *** Joins: Jeaye (Jeaye@moz-FD505E54.hsd1.ca.comcast.net)
[17:55:09] <strcat> you still have to copy into the socket/pipe
[17:55:18] <strcat> you have data, you copy it into the message queue
[17:55:27] <strcat> that's where the copy happens
[17:55:45] <kimundi> Diablo-D3: erlang does deep copies on send afaik. rusts ownership and move semantics allow to optimise thet to just a pointer copy because of the internally shared address space
[17:56:04] *** Joins: engla (engla@moz-BFD53D48.selucle.dyn.perspektivbredband.net)
[17:56:19] <strcat> erlang/rust have to pass by-value into the message queue
[17:56:26] <strcat> the same way you would for multiprocessing
[17:56:38] <strcat> passing by-value in rust doesn't have to be a copy though. that's the only difference
[17:57:23] <strcat> if tasks mapped to processes, ~ wouldn't be able to be passed by-pointer
[17:57:36] <Diablo-D3> hrm.
[17:57:48] <Diablo-D3> but then you have to deal with NUMA if you're just doing that
[17:58:03] <kimundi> NUMA?
[17:58:14] <Diablo-D3> NUMA will move the page to the new domain that the other thread belongs to and start doing very retarded things trying to sync the two
[17:58:35] *** Joins: steven_is_false (quassel@moz-9001998F.bchsia.telus.net)
[17:58:42] <sammykim__> what's NUMA?
[17:58:57] *** Parts: graham_king (graham_kin@moz-61791D81.vc.shawcable.net) ()
[17:59:02] <steven_is_false> Nonuniform memory architecture, GPUs etc..
[17:59:03] <sammykim__> sorry for interrupt.
[17:59:06] <Diablo-D3> non-uniform memory architecture
[17:59:09] <sammykim__> Thkanks steven :)
[17:59:12] <Diablo-D3> its not about gpus
[17:59:17] <sammykim__> thanks D3
[17:59:20] <steven_is_false> Rather, GPU + CPU
[17:59:20] <Diablo-D3> its how every large scale intel and amd machine is
[17:59:21] *** Quits: brson (brson@2557E599.66715431.D25A875A.IP) (Ping timeout)
[17:59:27] <Diablo-D3> and its what POWER has been for years
[17:59:37] <Diablo-D3> if you have more than one socket, its probably numa
[17:59:53] <steven_is_false> Diablo-D3: I only know the basics, so I'd like to hear a deeper explanation.
[17:59:57] <strcat> Diablo-D3: doesn't seem like that would be any different with multiprocessing
[18:00:02] <sammykim__> Oh,, I see . that's good answer for me to understand:)
[18:00:14] <Diablo-D3> strcat: in multiprocessing I can control where pages are
[18:00:32] <Diablo-D3> strcat: by virtue of just sending a message to another process
[18:00:35] <steven_is_false> As I understand it, one consequence of NUMA is that one has to copy data back and forth between the GPU, and the CPU instead of sharing it.
[18:00:57] <Diablo-D3> strcat: I can have processes whos sole purpose is to maintain a pool of data and nothing else.
[18:01:07] <Diablo-D3> strcat: not an an efficient use of resources, but I can do it
[18:01:19] <Diablo-D3> steven_is_false: has nothing to do with the GPU
[18:01:21] <steven_is_false> rusti: let x : &fn once ()  = || { }
[18:01:22] <rusti> foo.rs:5:21: 5:25 error: expected `(` but found `once`
[18:01:22] <rusti> foo.rs:5          let x : &fn once ()  = || { }
[18:01:22] <rusti>                               ^~~~
[18:01:29] <Diablo-D3> steven_is_false: and I can GPU-side DMA from system memory
[18:01:32] *** Joins: brson (brson@2557E599.66715431.D25A875A.IP)
[18:01:32] *** ChanServ sets mode: +o brson
[18:01:57] *** Joins: lmandel (lmandel@2557E599.66715431.D25A875A.IP)
[18:01:59] <Diablo-D3> steven_is_false: and most likely I'd be async copying buffers back and forth because the memory controller isnt tied up when the gpu is running 
[18:02:06] <kimundi> steven_is_false: Once functions don't work yet afaik
[18:02:06] *** Joins: ghrust (ghrust@moz-4EF5B6E5.rs.github.com)
[18:02:06] <ghrust> 01[13rust01] 15bors 04force-pushed 06auto from 14a55229d to 14c081ffb: 02http://git.io/N3iJvQ
[18:02:06] *** Parts: ghrust (ghrust@moz-4EF5B6E5.rs.github.com) ()
[18:02:09] *** Joins: ghrust (ghrust@moz-4EF5B6E5.rs.github.com)
[18:02:09] <ghrust> 01[13rust01] 15bors pushed 20 new commits to 06auto: 02http://git.io/jNDb6g
[18:02:09] <ghrust> 13rust/06auto 14229ebf0 15John Clements: deleted two tests intended to test RUST_CC_ZEAL, an apparently defunct flag for the cycle collector
[18:02:09] <ghrust> 13rust/06auto 145d8db6f 15John Clements: remove (non-parsing) test related to impl d for d feature
[18:02:11] <ghrust> 13rust/06auto 1478942a2 15John Clements: this issue is a dup of another one that has a correct test case...
[18:02:12] *** Parts: ghrust (ghrust@moz-4EF5B6E5.rs.github.com) ()
[18:02:13] <steven_is_false> Diablo-D3: Is it a cacheing thing then?
[18:02:29] <strcat> Diablo-D3: tasks have a local heap too
[18:02:30] <Diablo-D3> steven_is_false: depends entirely on what you need.
[18:02:41] <strcat> not exactly configurable in any way yet though
[18:02:51] <Diablo-D3> strcat: yeah, but every time you migrate a task to a different thread, you run the risk of pissing off numa
[18:03:05] <strcat> Diablo-D3: you can map them 1:1 with threads
[18:03:09] *** Joins: infynyxx (infynyxx@DB780A29.749BA1D.DCC373F0.IP)
[18:03:14] <strcat> the API gives you the option
[18:03:16] <Diablo-D3> yeah but that becomes ugly too
[18:03:25] <strcat> threads are scheduled the same way as processes
[18:03:28] <kimundi> Diablo-D3: Well, you'd be able to pin tasks to specific threads
[18:03:34] <strcat> on Linux at least, the scheduler doesn't differentiate
[18:03:45] <Diablo-D3> not quite
[18:03:52] <Diablo-D3> schedulers on numa machines must be numa aware
[18:04:00] <Diablo-D3> and thus participate in migration across numa domains
[18:04:10] <Diablo-D3> and try to avoid doing so at all costs due to the expense
[18:04:47] <Diablo-D3> so threads that are in one domain are only scheduled to run on cpu cores in that domain
[18:05:46] <Diablo-D3> btw, what happens when I free a page in rust?
[18:05:50] <kimundi> Diablo-D3: That sounds lika an reasonable additional control option to build in once the whole sheduler works in general
[18:05:57] <Diablo-D3> can another task allocate it before its returned to the OS?
[18:06:21] <kimundi> Diablo-D3: Allocations go through malloc and free atm, so... 
[18:06:25] *** Joins: gareth0 (gareth0@moz-C04F7018.dynamic.dsl.as9105.com)
[18:06:30] <Diablo-D3> so no internal memory pool?
[18:06:31] *** Quits: gareth0 (gareth0@moz-C04F7018.dynamic.dsl.as9105.com) (Connection reset by peer)
[18:06:38] <strcat> Diablo-D3: malloc/free use a memory pool
[18:06:42] <kimundi> Not yet anyway
[18:06:44] <Diablo-D3> strcat: yes/no
[18:06:54] <Diablo-D3> they use it in a way that is appropriate for the OS (which is why they're so slow)
[18:07:03] <Diablo-D3> thread safe, numa safe, etc
[18:07:18] <strcat> glibc/tcmalloc/jemalloc use a thread-local memory pool
[18:07:24] <strcat> there isn't much locking
[18:07:33] <strcat> they migrate to and from the thread-local pool as-needed
[18:07:35] <Diablo-D3> strcat: glibc SORT of does
[18:07:42] *** Quits: Jesin (Jessin_@moz-1866A4CC.cc.lehigh.edu) (Ping timeout)
[18:07:42] <Diablo-D3> Im not sure why the hell its so slow compared to jemalloc
[18:07:47] <Diablo-D3> it shouldnt be
[18:07:49] <strcat> it does, it has a cache per thread
[18:07:54] <strcat> it's not really much slower
[18:07:54] <nmatsakis> brson et al: so, this too-much-recursion test failure...
[18:07:56] <nmatsakis> is it fixed?
[18:08:04] <strcat> 10-15% slower but it uses less memory and returns it to the OS faster
[18:08:25] <Diablo-D3> and jemalloc is still slower than, say, a really dumb impl that uses a free linked list per size bucket, and a unbalanced binary search tree for used pages
[18:08:33] <Diablo-D3> er, said dumb impl is not thread safe
[18:08:41] <strcat> Diablo-D3: rust tasks have a local heap
[18:08:47] <strcat> the local heap won't need locking/sync at all
[18:08:52] <Diablo-D3> hrm.
[18:09:06] <strcat> Owned ~ uses the exchange allocator
[18:09:15] <strcat> ~ containing @ and @ use the local allocator
[18:09:24] *** Joins: int3_ (int3_@moz-359A42F6.subnet-248.amherst.edu)
[18:10:01] <kimundi> Diablo-D3: Anyway, it sounds like you have specific needs that are compatible enough with rusts memory modell that you could bring it up and work out a solution/extension to rusts sheduler in the future if the language is mature enough
[18:10:06] <strcat> tcmalloc allocates the thread-local pools as-needed and only migrates between them with a gc
[18:10:16] <strcat> a lock-free allocator wouldn't be faster
[18:10:17] *** Joins: steven_is_false_ (quassel@moz-9001998F.bchsia.telus.net)
[18:10:32] <strcat> the gc is just there to reduce memory usage by migrating
[18:10:41] *** Quits: steven_is_false_ (quassel@moz-9001998F.bchsia.telus.net) (Quit: http://quassel-irc.org - Chat comfortably. Anywhere.)
[18:11:10] *** Quits: int3_ (int3_@moz-359A42F6.subnet-248.amherst.edu) (Ping timeout)
[18:12:26] *** Joins: int3_ (int3_@moz-359A42F6.subnet-248.amherst.edu)
[18:13:07] <strcat> it *could* just not consolidate stuff
[18:13:18] <strcat> which is what you'd get with multiple processes or completely local heaps
[18:13:20] *** Quits: BizarreCake (BizarreCak@32C9829A.151E84E7.561471F8.IP) (Client exited)
[18:13:26] <strcat> it only does it to reduce memory usage
[18:14:31] <strcat> graydon: https://github.com/mozilla/rust/pull/6131 r?
[18:15:37] <strcat> ugh typo
[18:16:39] <graydon> strcat: & &x: ?
[18:16:50] <strcat> graydon: &&x won't parse
[18:16:58] <strcat> it's because the vec iterator returns & and that uses & too
[18:17:05] <graydon> no I mean, why is it & &?
[18:17:05] <strcat> had to change Npne -> None ;p
[18:17:14] <graydon> hmm
[18:17:24] <Diablo-D3> so wait
[18:17:24] <strcat> graydon: [].each uses & and then that uses & to avoid copying
[18:17:34] <Diablo-D3> rust DOESNT have a gc, right?
[18:17:39] <strcat> because iterators can yiled by-value
[18:17:46] <strcat> Diablo-D3: @ uses a gc, or at least it will
[18:17:51] <strcat> yield*
[18:17:54] <Diablo-D3> @ is what?
[18:17:57] * Diablo-D3 still doesnt know rust
[18:18:03] *** Joins: josh (josh@moz-6FB23C25.hvc.res.rr.com)
[18:18:08] <doy> @ is pointers that use a garbage collector
[18:18:19] <Diablo-D3> Im not required to use those, right?
[18:18:23] <bstrie> Diablo-D3: nope
[18:18:24] <doy> right
[18:18:24] <graydon> correct
[18:18:27] <Diablo-D3> good, I wont
[18:18:39] <bstrie> Diablo-D3: well, you might be if you want to make circular data structures
[18:18:49] <bstrie> but maybe you can hack together a weak pointer
[18:18:50] <strcat> graydon: for example an iterator can return chunks of ~[T], so it would be passing &~[T] to the predicate
[18:18:56] <strcat> it's just annoying with ones that already use &
[18:18:58] <Diablo-D3> oh right, rust doesnt have real pointers
[18:19:11] <bstrie> Diablo-D3: it does, if you use unsafe blocks
[18:19:22] <bstrie> strcat: why doesn't &&x parse? is it just because of modes?
[18:19:24] <Diablo-D3> yeah, but doesnt that tell the compiler to make your code slower?
[18:19:28] <kimundi> Diablo-D3: It has unsafe pointers, which is probably what you mean with 'real'
[18:19:28] <strcat> bstrie: I guess
[18:19:34] <strcat> bstrie: don't know why :)
[18:19:38] <strcat> modes are fully gone now though
[18:19:43] <bstrie> Diablo-D3: it actually makes your code faster, sometimes, because it turns off array bounds checks
[18:19:44] <Diablo-D3> kimundi: I mean real as in C honest to god it will eat your soul pointers
[18:19:50] <strcat> pcwalton: is it possible to make &&&&&&x parse now? instead of needing spaces
[18:19:58] <Diablo-D3> bstrie: so what stops me from unsafing all my code?
[18:20:01] <pcwalton> strcat: once we remove modes ;)
[18:20:03] <pcwalton> need a snapshot
[18:20:03] <bstrie> Diablo-D3: nothing
[18:20:04] <kimundi> Diablo-D3: And safe borrowed pointer, which are just as well normal pointers, just judged safe at compile time
[18:20:06] <pcwalton> they currently parse but do nothing
[18:20:09] <strcat> pcwalton: oh right they're in the parser still :(
[18:20:10] <pcwalton> but parsing is needed to bootstrap.
[18:20:20] <Diablo-D3> bstrie: hrm
[18:20:23] <Diablo-D3> I think rust might be worth using
[18:20:32] <Diablo-D3> how does one build a rust app? please say makefile
[18:20:39] <benh> &&&&&&x feels weird, taking the address of rvalue is clearly evil
[18:21:02] <ssbr> Diablo-D3: rust has a package system. You define a .rc file that specifies modules and dependencies.
[18:21:02] <Diablo-D3> btw, does rust have futures/promises?
[18:21:14] <Diablo-D3> ssbr: oh man =/
[18:21:15] <bstrie> Diablo-D3: there's a futures library. core::future I think
[18:21:17] <kimundi> Diablo-D3: Well3, if you WANT to usa a maefile noone stops you. call rustc and have fun
[18:21:20] <strcat> ssbr: .rc isn't used anymore
[18:21:25] <ssbr> std::future
[18:21:27] <strcat> at least it has no meaning now
[18:21:28] <bstrie> Diablo-D3: feel free to use makefiles, nobody can stop you
[18:21:35] <ssbr> strcat: The docs say that it's a convention
[18:21:43] <Diablo-D3> the only make system Ive ever managed to always make it do what I want is make
[18:21:48] <strcat> ssbr: well the docs are out of date ;p
[18:21:59] <Diablo-D3> mvn? sucks. ant? sucks. anything in an ide? extra sucks.
[18:22:02] <strcat> pkg.rs is how packages are defined now
[18:22:04] <ssbr> strcat: fix it fix it fix it
[18:22:04] *** Quits: josh (josh@moz-6FB23C25.hvc.res.rr.com) (Quit: josh)
[18:22:09] <bstrie> Diablo-D3: in any case the upcoming package manager isn't ready to use yet, so make is what rust itself uses
[18:22:14] <Diablo-D3> perl's strange build system for modules that use C code? blargh.
[18:22:22] <strcat> bstrie: it's ready enough to use for simple stuff
[18:22:24] <Boreeas> Converting a char to a ~str, is there a better way than ~"" + mychar?
[18:22:29] <kimundi> Diablo-D3: The package manager (which is still in the works) is really just for convinience, you don't need to use it
[18:22:49] <ssbr> Diablo-D3: You can try it and complain if it doesn't let you do what you want.
[18:23:01] <Diablo-D3> yeah but if I write a library I want other people to use Im forced to use that package manager
[18:23:05] <ssbr> (That's what I did, and then I got a feature added into Rust 0.7)
[18:23:08] <Diablo-D3> oh oh oh, and nodejs's package manager? WHAT THE HELL
[18:23:22] <Diablo-D3> and then the whole ruby gem thing
[18:23:24] <ssbr> also build system != package manager
[18:23:26] <kimundi> Diablo-D3: The package masnager will be "some url"
[18:23:46] <Diablo-D3> ssbr: yeah but languages keep making the two the same thing
[18:23:54] <ssbr> Diablo-D3: no they don't
[18:24:04] <Diablo-D3> fine, highly connected
[18:24:08] <ssbr> at least, no language I've used does
[18:24:16] <Diablo-D3> ssbr: mvn.
[18:24:21] <strcat> pure rust projects don't need a build system
[18:24:22] <Diablo-D3> downloads your dependencies AND builds your app.
[18:24:29] <Boreeas> mvn kinda does. but neither ant nor any ide-based system does
[18:24:34] <Diablo-D3> ant does
[18:24:36] <Diablo-D3> just add ivy.
[18:24:42] *** Quits: Mowah (Mowah@moz-59D1A475.cust.bredbandsbolaget.se) (Ping timeout)
[18:24:52] <ssbr> If you have to add something, then that's the same as saying "it doesn't have that feature"
[18:24:59] * Diablo-D3 loves how mvn and ant+ivy do the same thing and they're both top level apache projects
[18:25:12] <Diablo-D3> ssbr: ivy is an ant subproject
[18:25:15] <kimundi> Diablo-D3: The devs try very hard to make package managemnt non-painful. The least work you have todo is write a libary, follow a anaming convention for the root sourcefile, and put it on github or some other public url
[18:25:16] <Diablo-D3> and it may eventually come standard
[18:25:16] <lucian> Diablo-D3: the amount of duplication within apache is insane
[18:25:20] <Diablo-D3> lucian: I agree
[18:25:21] <strcat> Diablo-D3: if your project is only rust, a build system isn't useful
[18:25:32] <Diablo-D3> I just want a language Im happy with, ntw
[18:25:36] <Diablo-D3> *btw
[18:25:39] <ssbr> Diablo-D3: anyway, if you want to use rust with make, you can
[18:25:41] <strcat> if you use stable releases of external libraries, you probably want to let people use systems libs anyway
[18:25:48] <strcat> system libs*
[18:25:52] <Diablo-D3> https://www.evernote.com/shard/s248/sh/c188c52a-3db4-46c1-84d8-1a38d5b93181/0312b5aa06a4b1a4c8442272863e87a1
[18:25:57] <ssbr> Diablo-D3: but the rust parts all get built at once via the rust compiler
[18:26:00] <Diablo-D3> thats what I think a perfect language might look like
[18:26:13] <Diablo-D3> ssbr: for LTO purposes?
[18:26:16] *** Quits: tgt (tgt@moz-D59EE478.aztw.cable.virginmedia.com) (Quit: Computer has gone to sleep.)
[18:26:18] <strcat> C-like speed (LLVM backend)
[18:26:19] <strcat> Variant dispatch tail call optimization
[18:26:22] <strcat> those two are impossible together ;p
[18:26:29] <ssbr> Diablo-D3: I don't know what LTO is.
[18:26:35] <strcat> link time optimization
[18:26:35] <Diablo-D3> ssbr: link time optimization
[18:26:47] <ssbr> Diablo-D3: I have no idea.
[18:26:48] <strcat> rust essentially does LTO inside a crate
[18:26:55] <Diablo-D3> strcat: they arent impossible, it just requires a fair bit of gymnastics to do it
[18:27:09] <Diablo-D3> strcat: Im flexible on that one
[18:27:11] <ssbr> Diablo-D3: The reason you'd use make with rust is to compile non-rust things into the same shared library
[18:27:14] <strcat> Diablo-D3: you can't have guaranteed TCO for non-sibling functions without losing perf
[18:27:27] <Diablo-D3> strcat: I know rust doesnt do it, and Im okay with that
[18:27:32] <bstrie> Boreeas: try .to_str()
[18:27:44] <Boreeas> Doesn't work, not implemented for char
[18:27:56] <Diablo-D3> oh and I need to add something to that list
[18:28:06] <Diablo-D3> a string class that is completely unicode safe, all 21 bits of it.
[18:28:12] <ssbr> rust is missing like half of that list
[18:28:20] <ssbr> pretty much anything that mentions classes or mixins or whatever
[18:28:57] <strcat> traits serve the same purpose as mixins, don't they?
[18:29:06] <Diablo-D3> yes, rust traits seem to be mixins from what I can tell
[18:29:09] <ssbr> Hmmmmm.
[18:29:16] <ssbr> Traits with default implementations, I guess.
[18:29:16] <strcat> they aren't mixins but they can serve the same purpose
[18:29:18] <kimundi> ssbr: Well, that doesn't mean traits could not solve it smilar, does it?
[18:29:33] <bstrie> Boreeas: that's insane :)
[18:29:34] *** Quits: robertknight (robertknig@moz-54528EE0.wby.mendeley.com) (Quit: Computer has gone to sleep.)
[18:29:48] <Diablo-D3> btw, I recognize interface, abstract class, and class as all the same thing
[18:30:04] <Boreeas> bstrie: Well, it's what rustc tells me :P
[18:30:04] <Diablo-D3> interfaces have no concrete methods, abstract classes still are missing some, classes are complete and can be constructed
[18:30:05] <Boreeas> "error: type `char` does not implement any method in scope named `to_str`"
[18:30:10] <ssbr> Diablo-D3: well, they aren't the same in rust
[18:30:19] <ssbr> Diablo-D3: you can subclass interfaces but not "classes"
[18:30:21] <Diablo-D3> mixins and classes under my model can do all three.
[18:30:27] <ssbr> Diablo-D3: your model is one thing.
[18:30:41] <Diablo-D3> ssbr: we're discussing my perfect language, not rust =P
[18:30:42] *** Joins: fabiand (fabiand@moz-A27A2041.adsl.alicedsl.de)
[18:30:47] <ssbr> I wasn't.
[18:31:06] <strcat> Diablo-D3: traits + trait bounds is static dispatch
[18:31:21] <strcat> it's only when they're used as objects that it's dynamic dispatch like an interface/mixin
[18:31:39] <Diablo-D3> can I add multiple traits to a class in rust?
[18:31:56] *** Joins: seth (seth@moz-BE33DA21.fw1.sfo1.mozilla.net)
[18:31:57] <engla> what's a class?
[18:32:06] <Diablo-D3> rust doesnt have classes?
[18:32:09] <ssbr> Diablo-D3: you add traits to a type
[18:32:11] <doomlord> when i hear the word class, i reach for my revolver
[18:32:12] <ssbr> rust doesn't have classes
[18:32:12] <kimundi> Diablo-D3: No, because rust doesn't have classes :P
[18:32:21] *** Quits: azita (Azita@2557E599.66715431.D25A875A.IP) (Quit: azita)
[18:32:22] <Diablo-D3> so how do you do OO in rust?
[18:32:25] <strcat> doomlord: you can implement any number of traits for a type that you want
[18:32:26] <ssbr> Diablo-D3: there are traits (interfaces), and implementations of traits for a type
[18:32:28] <strcat> Diablo-D3: *
[18:32:29] <Boreeas> structs + traits
[18:32:36] <strcat> traits aren't just for structs
[18:32:40] <ssbr> Diablo-D3: if OO means "classes with inheritance hierarchies", you don't
[18:32:42] <kimundi> Diablo-D3: some datatype that implements traits
[18:32:43] <strcat> you can implement traits or methods on any type
[18:32:49] <lucian> traits are awesome
[18:32:51] <bstrie> Boreeas: the real bug here is the absence of to_str on char... there's no way that the easiest way to get a string from a char is adding it to an empty string :P
[18:32:53] <ssbr> Diablo-D3: you do it more like you might in haskell
[18:33:00] <Diablo-D3> ssbr: I dont understand haskell.
[18:33:04] <Diablo-D3> I tried, I failed.
[18:33:08] <doomlord> classes are the reason i'm looking at rust :)
[18:33:11] <strcat> traits are used either as type classes or as interface objects
[18:33:11] *** Quits: pyrac (pyrac@moz-2FEC2239.w92-149.abo.wanadoo.fr) (Quit: pyrac)
[18:33:15] <ssbr> Diablo-D3: The part of haskell that is relevant is not very difficult, don't worry.
[18:33:19] <lucian> Diablo-D3: have you tried learn you a haskell?
[18:33:19] <ssbr> But forget haskell.
[18:33:28] <Diablo-D3> lucian: stop that.
[18:33:34] <Diablo-D3> ssbr: gladly.
[18:33:36] <strcat> Diablo-D3: so, traits are separate from types
[18:33:50] <Diablo-D3> okay so wait, can I make a linked list trait, and then add it to my object type?
[18:33:58] <strcat> any type can have a trait impl (enum, struct, tuple struct)
[18:34:02] <strcat> Diablo-D3: yes
[18:34:08] <strcat> and then
[18:34:13] <Diablo-D3> AND THEN NO MORE CONTAINERS
[18:34:14] <Diablo-D3> FUCK YES
[18:34:27] <ssbr> a linked list is a container
[18:34:27] <ssbr> fyi
[18:34:34] <Diablo-D3> containers are one of the worst anti-patterns Ive ever seen
[18:34:35] <kimundi> bstrie: Hm, I'm not sure if a to_str() methot should convert a 'c' into ~"c"
[18:34:37] <Diablo-D3> ssbr: no, not quite
[18:34:57] *** Quits: brson (brson@2557E599.66715431.D25A875A.IP) (Ping timeout)
[18:34:58] <Diablo-D3> ssbr: a container linked lists is a linked lists of pointers that point at your objects
[18:35:00] <bstrie> kimundi: what else would it convert it to?
[18:35:02] <strcat> fn foo<T: TraitA + TraitB>(a: &T, b: &T) {}
[18:35:04] *** Joins: pyrac (pyrac@moz-2FEC2239.w92-149.abo.wanadoo.fr)
[18:35:07] <strcat> that's usage as a type class
[18:35:14] <Diablo-D3> in the best linked list ever, the objects themselves have next/prev pointers.
[18:35:20] <strcat> T is the actual type, and it has to implement both traits
[18:35:22] <Diablo-D3> no fucking indirection.
[18:35:37] <strcat> or as objects
[18:35:40] *** Joins: ghrust (ghrust@moz-4EF5B6E5.rs.github.com)
[18:35:40] <ghrust> 01[13rust01] 15bors 04force-pushed 06auto from 14cd3167e to 14c081ffb: 02http://git.io/N3iJvQ
[18:35:40] *** Parts: ghrust (ghrust@moz-4EF5B6E5.rs.github.com) ()
[18:35:40] *** Joins: ghrust (ghrust@moz-4EF5B6E5.rs.github.com)
[18:35:40] <ghrust> 01[13rust01] 15bors pushed 2 new commits to 06auto: 02http://git.io/iYRkMg
[18:35:40] <ghrust> 13rust/06auto 14869e0d9 15gifnksm: libstd: impl Clone for BigUint/BigInt and replace `copy` with `.clone()`
[18:35:40] <ghrust> 13rust/06auto 1467457c8 15bors: auto merge of #6127 : gifnksm/rust/impl-clone-for-bigint, r=thestinger...
[18:35:40] *** Parts: ghrust (ghrust@moz-4EF5B6E5.rs.github.com) ()
[18:35:41] <ssbr> Diablo-D3: Oh. You can't do that unless the datatype was meant to be a linked list in the first place.
[18:35:42] <kimundi> bstrie: It could also convert to ~"'c'", because to_str() might mean 'a string represantation of its value'
[18:35:52] <ssbr> Diablo-D3: A trait implementation can't add extra data fields to a type.
[18:36:02] <ssbr> It only adds "methods"
[18:36:05] <Diablo-D3> ssbr: oh
[18:36:09] <Diablo-D3> goddamnit =/
[18:36:17] <Diablo-D3> thats not a very ueful mixin then
[18:36:17] <engla> but, you can implement the linked list trait on a type
[18:36:24] <strcat> Diablo-D3: you can add the fields yourself and a trait can add default impls of methods for it
[18:36:35] <Boreeas> bstrie: Well, I just took a look at the repo, neither char.rs nor to_str.rs implements to_str for char
[18:36:36] <jaen> As for fields, If I recall correctly macros can't add fields right now? Will they ever be able or is that a non-goal?
[18:36:37] <bstrie> kimundi: I feel like there should be a repr() or something for that. 
[18:36:44] <Diablo-D3> strcat: yes, but then that fails the code reuse test
[18:36:50] <kimundi> bstrie: I guess there needs to be a clear rule what kind of data to_ostr() should emit, especially in the case of string related functions
[18:37:22] <Diablo-D3> strcat: okay, how would I implement the shape/square/circle example in rust?
[18:37:24] <ssbr> Diablo-D3: I'm not sure what the advantage is of adding it to a struct vs a struct that contains your struct (and not a pointer to struct)
[18:37:38] <Diablo-D3> ssbr: thats the same thing
[18:37:41] <ssbr> there's no pointer indirection in the latter case, so it should be just as performant, surely?
[18:37:48] <ssbr> Diablo-D3: then use a "container"
[18:37:50] *** Joins: brson (brson@2557E599.66715431.D25A875A.IP)
[18:37:50] *** ChanServ sets mode: +o brson
[18:37:50] <Diablo-D3> ssbr: containers refer exclusively to the pointer to a struct case
[18:37:51] <bstrie> kimundi Boreeas https://github.com/mozilla/rust/issues/6133 feel free to comment
[18:37:54] <strcat> ssbr: linked containers need to allocate nodes
[18:37:56] <ssbr> Diablo-D3: except instead of pointers fo objects, you just have the objects
[18:38:07] <strcat> with intrusive containers the objects are the nodes
[18:38:17] <Diablo-D3> strcat: exactly
[18:38:18] <strcat> so the container can be stored in a vector or on the stack, or wherever
[18:38:23] <Diablo-D3> I prefer it that way, far less waste
[18:38:25] <ssbr> Yes.
[18:38:30] <Diablo-D3> can rust do that in a sane way?
[18:38:37] <strcat> Diablo-D3: yes and no
[18:38:39] <ssbr> What I'm saying is, instead of allocating the intrusive container, you can allocate the container, and yopu get the same effect
[18:38:52] <brson> nmatsakis: yes, the too-much-recursion failure is fixed
[18:38:57] <strcat> Diablo-D3: it's memory safe because & (borrowed pointer) is restricted to stuff that can be proven to be safe
[18:39:00] <strcat> you can make intrusive lists
[18:39:01] <ssbr> either way memory is allocated for exactly the width of the original struct plus the size of a next pointer, for each object in the list
[18:39:07] <strcat> but.... they aren't very flexible
[18:39:08] <ssbr> eh whatever
[18:39:11] *** Quits: int3_ (int3_@moz-359A42F6.subnet-248.amherst.edu) (Client exited)
[18:39:20] <nmatsakis> brson: has this been committed? I saw a PR to just remove the test?
[18:39:34] * Diablo-D3 wonders how b-heaps would be implemented in rust
[18:39:44] <Diablo-D3> those are so fun <3
[18:40:19] <strcat> Diablo-D3: http://ix.io/52d can definitely make an intrusive list, could make a trait for implementing that stuff automatically on a type
[18:40:22] <strcat> it just really isn't flexible
[18:40:38] *** Joins: bleibig (bleibig@moz-58EF3B3A.rochester.res.rr.com)
[18:40:56] <Diablo-D3> strcat: yyeah that doesnt look useful
[18:41:23] <strcat> well in that example it doesn't hit any of the restrictions on &
[18:41:31] <strcat> but you would, if you really tried to use it
[18:41:31] <Diablo-D3> okay, object types in rust CANT inherit at all?
[18:41:46] <strcat> Diablo-D3: no object inheritance
[18:41:50] <strcat> there's just trait inheritance
[18:41:55] <Diablo-D3> hrm
[18:42:01] <brson> nmatsakis: actually, it bounced, but the solution is to remove the test
[18:42:03] <Diablo-D3> can a function argument be for a trait?
[18:42:04] <ssbr> trait inheritance = adding new methods to interfaces, right?
[18:42:29] <strcat> Diablo-D3: you can use traits as static or dynamic dispatch, and yes the function can take a trait
[18:42:48] <Diablo-D3> whats the difference between static and dynamic dispatch in rust?
[18:42:51] <strcat> either it can take a generic type that implements a set of specified traits, or it can take a specific trait as an object
[18:43:08] <strcat> Diablo-D3: if you use them statically, there aren't vtables
[18:43:14] <bstrie> Diablo-D3: there might be struct single inheritance in a future version of rust. never multiple inheritance
[18:43:16] <strcat> it specializes the instantiations
[18:44:06] <brson> hm, incoming fixed itself without my fix :(
[18:44:19] <Diablo-D3> how much memory does a task in rust take?
[18:44:25] <brson> and master is all red (
[18:44:25] *** Joins: Mowah (Mowah@moz-59D1A475.cust.bredbandsbolaget.se)
[18:45:03] <bstrie> Diablo-D3: depends on the platform. not very much, the stacks will grow as needed
[18:45:14] <kimundi> Diablo-D3: Not really anwerable right now, because languaga still in flux, but it should only need one page at minimum
[18:45:18] <brson> Diablo-D3: somewhere between 3k and 21k minimum, depending on OS (I haven't measured). The bulk of the memory required for a task is taken up by the stack red zone
[18:45:30] <Diablo-D3> hrm
[18:45:31] <brson> on linux there is a 2k red zone
[18:45:46] <brson> and it may be harder to get it much lower
[18:45:48] <Diablo-D3> because erlang can do like thousands in a meg or something like that
[18:45:49] <strcat> brson: if it's not zeroed it won't actually allocate anything anyway (just 4k)
[18:46:08] <Diablo-D3> yes, it'll just consume the address space but not a physical page
[18:46:08] *** Quits: fabiand (fabiand@moz-A27A2041.adsl.alicedsl.de) (Ping timeout)
[18:46:11] <bstrie> Diablo-D3: I've seen benchmarks where people have spawned a million tasks in rust. I'll try it right now even
[18:46:21] *** Quits: sammykim__ (Administra@48AEBDE2.ACF655DA.97B9B372.IP) (Connection reset by peer)
[18:46:26] *** Joins: fabiand (fabiand@moz-A27A2041.adsl.alicedsl.de)
[18:46:30] <strcat> Diablo-D3: it has to consume 1 physical page, or at least the lowest level of granularity the OS can do
[18:46:31] <brson> I doubt anybody has spawned a million concurrent tasks in rust
[18:46:34] <Diablo-D3> I think gmaxwell had the right idea to recommend rust to me
[18:46:34] <bstrie> hm, I forget how to hold them open
[18:46:35] <strcat> which afaik is a page
[18:46:39] <Diablo-D3> it sounds like a language I'd like
[18:46:47] <Diablo-D3> strcat: I dont think so
[18:46:51] <bstrie> brson: right, it might have just been `for 1_000_000.times { do spawn {} }`
[18:46:58] <Diablo-D3> strcat: lazy allocation of pages mean it wont actually be allocated until you touch it
[18:47:07] <Diablo-D3> strcat: even for 1 page
[18:47:16] <Diablo-D3> at least in linux
[18:47:19] *** Joins: azita (Azita@2557E599.66715431.D25A875A.IP)
[18:47:21] <brson> i've done 500k simultaneous tasks last summer on i686 but since then there were regressions and last time I tried I only got around ~100k
[18:47:22] *** Joins: rgrinberg (rgrinberg@AE999E95.52DE4C60.258AD6F5.IP)
[18:47:24] <strcat> Diablo-D3: yes it allocates page-by-page
[18:47:35] <Diablo-D3> strcat: and its sparse
[18:47:41] <Diablo-D3> so this red zone thing, if you never ever ever ever touch it
[18:47:43] <strcat> but I don't think you can ever have a task without a page that it touched
[18:47:48] <Diablo-D3> it will never consume a page
[18:48:01] <brson> we do touch it
[18:48:05] <Diablo-D3> oh well
[18:48:07] <brson> maybe we can arrange not to do that
[18:48:08] <kimundi> Diablo-D3: Believe me, strcat knows this just to well ;) He has heavy opinions on rusts task stack modell.
[18:48:09] <Diablo-D3> 4k down the drain
[18:48:19] <Diablo-D3> kimundi: ahh
[18:48:32] <lucian> Diablo-D3: it's not an inherent limitation in the language or the design of the runtime
[18:48:40] *** Joins: int3_ (int3_@moz-359A42F6.subnet-248.amherst.edu)
[18:48:44] <lucian> Diablo-D3: keep in mind that the runtime is being changed significantly atm
[18:48:59] <strcat> Diablo-D3: rust uses segmented stacks right now which is mostly a way to conserve address space on 32-bit
[18:49:00] <Diablo-D3> lucian: I just want a language Im happy with, thats all
[18:49:04] *** Quits: jack (jack@moz-F1B36F9F.hsd1.nm.comcast.net) (Quit: Leaving.)
[18:49:09] <Diablo-D3> strcat: heh, I know what thats like
[18:49:14] <Diablo-D3> I was writing a malloc impl
[18:49:25] <Diablo-D3> Im not happy with it, but goddamnit I HATE 32 bit
[18:49:38] <strcat> if there weren't segmented stacks, it wouldn't scale very far on 32-bit
[18:49:41] <kimundi> Diablo-D3: I'd roughly say that rust covers more than 50% of your list in one way or another
[18:49:42] <jld> Note that if (on amd64) you map 2MiB and touch one byte, that's 8 KiB.
[18:49:46] <lucian> Diablo-D3: rust is likely to make you at least as happy as C++
[18:49:54] <Diablo-D3> kimundi: I agree, its one of the few languages that make it that far
[18:49:56] <jld> Accounting for page table memory is frequently an elephant in the room.
[18:50:00] <Diablo-D3> kimundi: and Im flexible on some of those
[18:50:14] <Diablo-D3> jld: errrrrrr, wtf? no
[18:50:24] <Diablo-D3> there are no 8kb pages on x86-64
[18:50:33] <strcat> he's not talking about pages
[18:50:39] <strcat> the address space accounting
[18:50:41] <jld> Diablo-D3: 4KiB for the page of data and 4KiB for the PTP.
[18:50:47] *** Joins: tiffany (kawaii@moz-1E0FE6E8.dhcp.embarqhsd.net)
[18:50:57] <Diablo-D3> is this a rust thing?
[18:51:05] <strcat> jld: how quickly does the page table scale?
[18:51:08] *** Joins: tgt (tgt@moz-D59EE478.aztw.cable.virginmedia.com)
[18:51:12] <jld> This is an x86 thing.
[18:51:20] *** Joins: ghrust (ghrust@moz-4EF5B6E5.rs.github.com)
[18:51:20] <ghrust> 01[13rust01] 15brson merged 06incoming into 06snap-stage3: 02http://git.io/DTQKMQ
[18:51:20] *** Parts: ghrust (ghrust@moz-4EF5B6E5.rs.github.com) ()
[18:51:22] <strcat> jld: like, say you did 10MiB
[18:51:27] <strcat> is it still 4KiB?
[18:51:29] <jld> And any other architecture that uses radix trees for page tables, which is most of them these days.
[18:51:54] <Diablo-D3> oh wait, is it just 4kb per allocation?
[18:52:12] <Diablo-D3> because my malloc was allocating 16mb at a time minimum from the OS via mmap =P
[18:52:36] *** Quits: tgt (tgt@moz-D59EE478.aztw.cable.virginmedia.com) (Quit: Computer has gone to sleep.)
[18:52:50] <jld> strcat: 10MiB (with one byte touched) is one page, one PTP, and 5 PDEs.  So 8 KiB + (amortized) 40 bytes.
[18:53:04] <brson> https://github.com/mozilla/rust/wiki/Meeting-weekly-2013-04-30
[18:53:13] <pcwalton> yay, down to 8 borrow check errors
[18:53:14] <bstrie> brson: thanks
[18:53:23] <strcat> jld: so that's pretty reasonable
[18:53:25] <Diablo-D3> used split buddy pages, only used 16 bytes per page
[18:53:37] <jld> And, for completeness, whatever extra structures the OS uses to indicate that the mmap exists.
[18:53:51] *** Joins: tgt (tgt@moz-D59EE478.aztw.cable.virginmedia.com)
[18:54:04] <Diablo-D3> stored free pages per size bin as a linked list, used pages as a binary search tree
[18:55:01] <Diablo-D3> and it wasnt really worth doing
[18:55:27] <brson> tjc: recursive_mkdir_rel failed here http://buildbot.rust-lang.org/builders/auto-linux/builds/1002/steps/test/logs/stdio
[18:55:39] <Diablo-D3> I mean, it proably would have been faster if I just used bheaps and arranged the innards so I could do something stupid like SSE2 or AVX comparison
[18:56:27] <pepijndevos> array == vector in Rust? And how do they compare to C arrays or higher level sequential thingies?
[18:57:05] <brson> tjc: and recursive_mkdir_rel_2 failed here http://buildbot.rust-lang.org/builders/auto-linux/builds/1001/steps/test/logs/stdio
[18:57:18] <strcat> pepijndevos: there are fixed-size vectors [int, ..5] which are like C arrays with value semantics
[18:57:30] <brson> tjc: hm, these are in std::tempfile. is that related to the mkdir changes you were working on?
[18:57:35] <strcat> pepijndevos: ~[] and @[] are a dynamic array with O(1) amortized append
[18:57:41] <strcat> &[] is a slice into any array
[18:57:43] <kimundi> Diablo-D3: Maybe you could in the future help on implementing a better memory allocator for rust. You seem to know what you're doing ;)
[18:58:03] *** Quits: lucian (lucian@6B2B4644.4304AE1E.CE5E78F6.IP) (Ping timeout)
[18:58:06] <brson> tjc: this is one of the failing assertions rust: task failed at 'assertion failed: os::mkdir_recursive(&path2, (S_IRUSR | S_IWUSR | S_IXUSR) as i32)', /home/rustbuild/src/rust-buildbot/slave/auto-linux/build/src/libstd/tempfile.rs:79
[18:58:08] <strcat> kimundi: the exchange heap could just use tcmalloc/jemalloc
[18:58:09] <tjc> brson: Yeah, I'll look at those
[18:58:21] <brson> thanks
[18:58:21] <strcat> kimundi: really unsure on which would be better though....
[18:58:42] <kimundi> strcat: Yeah I don't know enough about that stuff to have any opinion on this :P
[18:58:56] <nmatsakis> pcwalton: amusing. the run-fail tests for write guards fail now because the new borrowck catches the errors statically
[18:59:04] <pcwalton> nmatsakis: heh
[18:59:04] *** Quits: tjc (tjc@moz-E0677B46.vc.shawcable.net) (Quit: Places to go, people to annoy)
[18:59:07] <strcat> jemalloc optimizes for the case where you have a constant number of threads
[18:59:18] <pcwalton> add some levels of indirection to confuse the static check?
[18:59:23] <bstrie> nmatsakis: haha
[18:59:25] <pcwalton> or rather, function calls
[18:59:32] <strcat> active threads*
[18:59:43] <nmatsakis> pcwalton: it is easy to circumvent :)
[18:59:49] <kimundi> brson: Did I get that right, the error uncovered by the fail!() change fixed itself?
[18:59:58] <nmatsakis> pcwalton: just do something like "let z = x; *z = 3" instead of "*x = 3"
[18:59:59] <brson> kimundi: yes :-/
[19:00:02] <pcwalton> ah
[19:00:31] <kimundi> brson: That Is frustrating I guess :)
[19:00:33] <strcat> nmatsakis: until you make the static checking smarter ;p
[19:00:59] <nmatsakis> strcat: indeed... not on my short term plans :)
[19:01:02] * strcat assumes it won't ever cross function boundaries though
[19:02:03] <kimundi> strcat: Then ha just has to make the failure case smarter, which allows him to make the borrowchecker smarter, which goes back and forth until @ are statically checked. Sounds like a winwn to me :P
[19:02:38] <strcat> kimundi: if you could prove them statically checked in all cases you wouldn't need a garbage collector
[19:02:41] <strcat> ;p
[19:03:12] <kimundi> See? Iterate long enough and all are happy \o/
[19:03:32] <doomlord> rust has me wondering if they would ever add ~ to  existing GC'd langauges
[19:04:09] <kimundi> doomlord: I think some do that already implicitly
[19:04:37] <pcwalton> there are some proposals to add linear types to Haskell
[19:04:37] <doomlord> so the compiler/runtimemight be able to figure it out retroactively?
[19:04:40] <pcwalton> which would be adding ~
[19:04:40] <kimundi> IN that they probably can do optimisations because they can see that a value is only used once or so
[19:04:45] <strcat> doomlord: I could see it being added to haskell
[19:04:47] <strcat> for ioref
[19:05:00] <strcat> oh pcwalton mentioned it ;p
[19:05:12] <doomlord> i of course much prefer it in the langauge to it being figured out by the compiler
[19:05:27] <doomlord> i wouldn't object to a compiler figuring out when it can turn @ to ~ aswell
[19:05:38] <strcat> well having the compiler figure it out is just escape analysis, right?
[19:05:47] <strcat> whole program escape analysis though
[19:05:57] <strcat> not just in fn scopes
[19:06:04] <doomlord> yes. if it was trivial, GC'd languages would have replaced c++ already
[19:06:22] <pcwalton> fun project if anyone is interested: add escape analysis to LLVM
[19:06:24] <doomlord> well completely instead of just for certain typse of problem
[19:06:35] <pcwalton> you'd help not only Rust but also C++ and C
[19:07:16] <strcat> pcwalton: would they actually be allowed to move more data onto the stack in C though? could lead to hitting the stack limit earlier
[19:07:19] <doomlord> well C/C++ dont need escape analysis though do they? or are you talking about C/C++ with a GC runtime retrofitted (i've heard they exist)
[19:07:35] <pcwalton> strcat: there might be limits
[19:07:36] <Diablo-D3> [02:56:18] <kimundi> Diablo-D3: Maybe you could in the future help on implementing a better memory allocator for rust. You seem to know what you're doing ;)
[19:07:40] <strcat> doomlord: escape analysis is relevant for malloc -> stack
[19:07:47] <pcwalton> doomlord: if you use malloc and free where you don't need to
[19:07:48] <Diablo-D3> kimundi: apparently not, I was trying to be jemalloc and tcmalloc
[19:07:49] <doomlord> ah yes
[19:07:54] <Diablo-D3> kimundi: I didnt
[19:07:59] <doomlord> sorry of course. malloc -> alloca
[19:08:50] *** Joins: Jesin (Jessin_@moz-1866A4CC.cc.lehigh.edu)
[19:09:14] <doomlord> you can of course make stack-like custom allocators in C++ already and change programs to work like that by design (another stack)
[19:09:25] <doomlord> we worked like that on the SPU's on the PS3
[19:11:31] *** Quits: Jesin (Jessin_@moz-1866A4CC.cc.lehigh.edu) (Ping timeout)
[19:14:04] *** Joins: ghrust (ghrust@moz-4EF5B6E5.rs.github.com)
[19:14:04] <ghrust> 01[13rust01] 15bors 04force-pushed 06auto from 1467457c8 to 14c081ffb: 02http://git.io/N3iJvQ
[19:14:04] *** Parts: ghrust (ghrust@moz-4EF5B6E5.rs.github.com) ()
[19:14:06] *** Joins: ghrust (ghrust@moz-4EF5B6E5.rs.github.com)
[19:14:06] <ghrust> 01[13rust01] 15bors pushed 2 new commits to 06auto: 02http://git.io/0ynT2Q
[19:14:06] <ghrust> 13rust/06auto 149ddcf1c 15Brian Anderson: test: Remove run-pass/too-much-recursion.rs...
[19:14:06] <ghrust> 13rust/06auto 149b54fbd 15bors: auto merge of #6118 : brson/rust/too-much-recursion, r=thestinger...
[19:14:07] *** Parts: ghrust (ghrust@moz-4EF5B6E5.rs.github.com) ()
[19:16:07] <jclements> pcwalton (or anyone) : is there a modern alternative to mk_mumble? Are we calling this new_mumble() now?
[19:16:07] * brson snapshotting
[19:16:16] <pcwalton> jclements: Mumble::new()
[19:16:39] <pepijndevos> How would I map over a string into a vector? "0af" -> [0, 10, 16]
[19:17:53] <pepijndevos> Maybe I'm not looking hard enough, or thinking to functional
[19:18:32] <kimundi> pepijndevos: Depends. should it be the utf8 bytes, characters, graphemes? lazy iteration or up-front copy?
[19:18:53] *** Joins: dpritchett (dpritchett@1E686A23.8B146FD9.67894F1C.IP)
[19:19:17] <pepijndevos> kimundi: characters. I'm trying to parse things like hexadecimal
[19:19:22] <pcwalton> let mut result: ~[int] = ~[]; for "0af".each |c| { result.push(FromStrRadix::from_str_radix(c.to_str(), 16)); }
[19:19:26] <kimundi> pepijndevos: Ah, you just want to parse a hex string?
[19:19:44] <pcwalton> some wasteful allocation there, it could be more efficient, but there you go
[19:20:09] <kimundi> rusti: uint::from_str_radix("0af", 16)
[19:20:11] <rusti> Some(175)
[19:20:25] <pepijndevos> ah
[19:20:26] <kimundi> thats if you just want the final value
[19:21:24] <pepijndevos> I want to load the whole std lib in my head this very second :|
[19:21:30] <strcat> those free functions will go away in the future though, should use the trait ones
[19:21:34] <kimundi> Hm... In theory a grapheme in rust would have to be a string slice, right?
[19:22:15] <pepijndevos> Is a rust slice anything like a Python slice, or is it just a reference?
[19:22:16] <strcat> kimundi: yes
[19:22:32] <strcat> pepijndevos: python doesn't really have something like it
[19:22:34] *** Joins: Jesin (Jessin_@moz-1866A4CC.cc.lehigh.edu)
[19:22:34] <strcat> numpy does
[19:22:35] <kimundi> pepijndevos: its implementad as a tuple of ptr+len
[19:22:39] <pcwalton> FromStrRadix is in num
[19:22:41] <pcwalton> in core
[19:22:58] <strcat> pepijndevos: a slice is a view (immutable or mutable) into a vector/string
[19:23:05] <kimundi> so, twice the pointer size, can point at any valid interval of an vector
[19:23:09] <strcat> can't do stuff like changing the length since it's just a view into it
[19:23:16] <pepijndevos> Right, but you can;t have stuff like, give me every second element
[19:23:30] <strcat> pepijndevos: well that would require a copy or a lazy iterator
[19:23:32] <pcwalton> whee, libsyntax built, now 1,279 errors
[19:23:38] <pepijndevos> yes
[19:23:38] *** Quits: fabiand (fabiand@moz-A27A2041.adsl.alicedsl.de) (Quit: Verlassend)
[19:23:39] <pcwalton> err, libstd built
[19:23:41] <kimundi> pepijndevos: That's iterating, strcat will have lot to say about that :)
[19:23:42] <pcwalton> 1,279 errors in libsyntax
[19:23:59] <kimundi> pcwalton: Sounds fun :)
[19:24:05] <pepijndevos> strcat: okay, tell me about iterating :D
[19:24:18] <kimundi> pcwalton: What kind of change produces these errors?
[19:24:32] <pcwalton> kimundi: making serialization work with INHTWAMA
[19:24:32] <strcat> pepijndevos: well there isn't an iterator adaptor that can do that yet.
[19:24:45] <kimundi> "Let me tell you about iterators"
[19:24:47] <strcat> could make one
[19:24:48] *** Joins: askalski (akuda@2BA4E5A7.CC7751E8.6712E96B.IP)
[19:24:55] <pepijndevos> Is there one that can give me chunks of athing?
[19:25:25] <strcat> there isn't an adaptor to do that yet (turn iterator into iterator of chunks)
[19:25:29] <strcat> should be
[19:25:33] <kimundi> pepijndevos: Depends on how you define chunk and thing
[19:25:44] <strcat> there's .take(n) and .drop(n) so .slice(start, end) is possible
[19:25:46] <pepijndevos> "aaabbbccc".chunk(3, |ch| blah) "aaa"
[19:25:55] <strcat> could make .slice_step(start, end, step)
[19:25:59] *** Quits: Jesin (Jessin_@moz-1866A4CC.cc.lehigh.edu) (Ping timeout)
[19:26:03] <strcat> pepijndevos: well it could be
[19:26:06] <pepijndevos> yay
[19:26:17] <kimundi> pepijndevos: Basically, external iterators are new, still a lot of useful adapters that need to be written
[19:26:17] <strcat> for some_iter.chunk(3).advance |chunk| { }
[19:26:29] <strcat> could have an internal iterator adaptor for that too
[19:27:21] <doomlord> could anyone comment on the relative complexity of writing a rust->C translator* (patched into the compiler..) versus fixing LLVM->C translation (*i realise rust as C wouldn't behave the same r.e. stack)
[19:28:28] <strcat> doomlord: with a specific goal in mind?
[19:28:38] <doomlord> originally what i was after was iOS support; i discovered iOS has a different ABI. and apple docs claim they modified the standard ARM abi a bit aswell
[19:28:47] <pepijndevos> strcat: So in the absence of that, would I need some lower level looping construct to put chunks of a string into a vector?
[19:29:16] <doomlord> i figured the ability to compile to C  could be like a catch all for obscure architectures 
[19:29:18] <strcat> pepijndevos: you can use range_step to iterate over the start indices
[19:29:28] <strcat> and then .slice(start, start + chunk_size)
[19:29:43] *** Quits: vosen (vosen@moz-266BA656.icpnet.pl) (Connection reset by peer)
[19:29:46] *** Joins: vosen_ (vosen@moz-266BA656.icpnet.pl)
[19:29:54] <strcat> would be faster than a generic iterator adaptor anyway
[19:29:59] <doomlord> iOS support probably isn't a priority for mozilla or samsung :)
[19:30:10] *** Joins: catpig (catpig@moz-E041C70E.dip0.t-ipconnect.de)
[19:30:10] *** Quits: vosen_ (vosen@moz-266BA656.icpnet.pl) (Connection reset by peer)
[19:30:12] <strcat> at least without extending Iterator with a random access iterator trait
[19:30:13] <doomlord> and apple have objC so they dont need rust
[19:30:18] *** Joins: vosen_ (vosen@moz-266BA656.icpnet.pl)
[19:30:53] *** Quits: infynyxx (infynyxx@DB780A29.749BA1D.DCC373F0.IP) (Client exited)
[19:30:58] <pepijndevos> thanks :)
[19:31:10] *** Joins: jeff (jeff@4231C034.745B261B.F12515B4.IP)
[19:31:40] <doomlord> i suppose it could also be a tool to aid ones' comprehension of what the rust compiler is doing, much like low level C programmers sometimes compare C and asm output
[19:32:15] <strcat> rust has asm for stuff like stack switching
[19:32:24] <strcat> so it couldn't compile to standard C without __asm__
[19:32:26] <pascal> is there somewhere a working example of a simple TCP server? there's a 7 months old ticket (#3599) that socket.read times out and it doesn't seem to be fixed. is there anything "better" yet?
[19:32:35] <doomlord> yeah i should add, i'm thinking of a subset of rust
[19:32:55] <strcat> well I find LLVM IR pretty easy to deal with
[19:33:01] *** Quits: azita (Azita@2557E599.66715431.D25A875A.IP) (Quit: azita)
[19:33:24] <strcat> or looking at the assembly
[19:33:24] <pepijndevos> strcat: where can I find the docs for range_step ad slice?
[19:33:41] <bstrie> pascal: you'll probably just be sad if you try making a server in rust today. that's all being rewritten
[19:33:48] <strcat> pepijndevos: well slice is documented in the vec/str modules
[19:34:01] <doomlord> its just my path,  (basic in some distant past)->ASM->C->C++ ->???
[19:34:05] <strcat> just returns a slice between the given start index and end index
[19:34:18] <doomlord> C will always have a special place forme
[19:34:21] *** Joins: infynyxx (infynyxx@DB780A29.749BA1D.DCC373F0.IP)
[19:34:39] <ssbr> Since it's impossible to call C-ABI functions, does that mean it's impossible to call JIT'd code from Rust (as generated by LLVM)?
[19:34:48] <ssbr> egh
[19:34:51] <ssbr> to call C-ABI function pointers
[19:34:59] <pascal> bstrie: oh, ok - that's indeed sad. Maybe I'll leave the TCP stuff out and work on the other parts first. thanks!
[19:35:15] <kimundi> ssbr: It's not impossible, it's just nort yet implemented
[19:35:26] <strcat> bstrie: well you can just write it how you would in C
[19:35:26] *** Quits: askalski (akuda@2BA4E5A7.CC7751E8.6712E96B.IP) (Quit: Wychodzi)
[19:35:27] <kimundi> ssbr: It will be soonish
[19:35:28] <strcat> but with tasks
[19:35:29] <ssbr> kimundi: I guess that's what I meant, sorry
[19:35:35] <bstrie> pascal: ^
[19:36:03] <doomlord> is there a link describing "rust stack switching", i know rust has growable stacks or something..
[19:36:17] *** Joins: CarpNet (Alasdair@moz-EF831A5E.cable.virginmedia.com)
[19:36:22] <strcat> doomlord: stack switches for C calls are going away
[19:36:26] <pascal> strcat: -> use C bindings?
[19:36:46] <pepijndevos> strcat: af, I found a range_step in uint
[19:36:48] <strcat> pascal: yes, rust-socket or a higher level binding
[19:36:57] <bstrie> doomlord: that may have changed very recently, I don't know of any documentation of the new behavior
[19:37:02] <doomlord> ok
[19:37:16] <strcat> like libmicrohttpd for http
[19:37:22] <pascal> strcat: oh, that exists. will look into it. thanks!
[19:37:27] <doomlord> i wonder if i'd get any takers for collaboration on a Rust->C compiler
[19:37:37] <doomlord> or am i just a freak wanting it :)
[19:37:38] <kimundi> doomlord: rusts stacks are segmented and small. every function caa starts with 2 asm instructions that check if there is enough space on the current segment left, if not all argmunts are copied to a new one, and the function executed there
[19:38:00] <kimundi> function call*
[19:38:09] <doomlord> ^^^ will you have leaf-function optimization
[19:38:16] <strcat> doomlord: it's essentially like C code compiled with -fstack-protector=all but it can grow the stack when it runs out
[19:38:23] <doomlord> ok
[19:39:05] *** Joins: azita (Azita@2557E599.66715431.D25A875A.IP)
[19:39:10] <strcat> userspace context switching isn't something you can implement in standard C
[19:39:11] *** Quits: vosen_ (vosen@moz-266BA656.icpnet.pl) (Connection reset by peer)
[19:39:18] *** Joins: vosen_ (vosen@moz-266BA656.icpnet.pl)
[19:39:27] <strcat> I think you can do it in C + POSIX
[19:39:33] <strcat> with deprecated POSIX stuff
[19:40:01] <strcat> setcontext/getcontext are deprecated.
[19:40:24] *** Quits: Jesse (jruderman@moz-537BCF9.hsd1.ca.comcast.net) (Quit: Jesse)
[19:40:32] <ssbr> doomlord: what's the use case?
[19:40:46] <ssbr> I'm finding that rust works well enough with C, even if it doesn't compile to C
[19:41:02] <ssbr> I can compile it to an object file and link it with object files produced by C, and everything works as one would hope
[19:41:24] <doomlord> well initially  i just wanted to get rust onto the  iphone - i had a hacky attempt via arm asm, and discovered ABI differences must be handled before LLVM code is generated
[19:41:34] <pepijndevos> wow, segmentation fault
[19:41:58] <doomlord> initially i tried using the ARM/android support to emit ARM asm , but the apple tools dont like it
[19:42:21] <kimundi> pepijndevos: segfault or ice?
[19:42:36] <doomlord> LLVM and hence the ASM has details specfic to the ABI; iphone uses a customized ARM abi, different to android's EABI
[19:42:37] <pepijndevos> rusti> io::println(1i.to_str())
[19:42:37] <pepijndevos> Segmentation fault: 11
[19:42:47] <ssbr> doomlord: rustc can compile rust to LLVM IR
[19:42:52] <bstrie> pepijndevos: oh, that's the repl. it's broken :P
[19:42:54] <kimundi> ah, blame rusti for that
[19:43:07] <ssbr> doomlord: you can translate the LLVM IR to C and do whatever, or maybe use it directly with clang possibly
[19:43:11] <ssbr> doomlord: would that work?
[19:43:18] <bstrie> pepijndevos: you can use the bot in here for that instead:
[19:43:22] <bstrie> rusti: println(1i.to_str())
[19:43:24] <rusti> 1
[19:43:26] <kimundi> try it here instead. THIS rusti just uses the regular compiler :P
[19:43:29] <doomlord> sadly LLVM->C is brokken.   of course fixing that is a possible project
[19:43:39] <pepijndevos> ...
[19:43:52] <pepijndevos> can I talk to rusti privatly, or do I nee to spam the chan?
[19:43:57] <bstrie> private works
[19:44:22] <kimundi> pepijndevos: The sad truth is that an irc bot is the only currently working implmentation of an rust repl :P
[19:44:35] <ssbr> kimundi: that's extremely sad
[19:44:35] <kimundi> bstrie: It does? Since when.
[19:44:48] <pepijndevos> :) :(
[19:45:27] <bstrie> pepijndevos: you're welcome to fix the repl, you just need to learn how LLVM's JIT works
[19:45:33] <kimundi> ouh, niice it indeed works
[19:45:50] <pepijndevos> bstrie: Oh, sounds easy enough :P
[19:45:53] <kimundi> Now I can stop spamming this channel as well :P
[19:46:02] <doomlord> ssbr, LLVM IR compiling to iOS object files directly, then include those objects in the ios project?
[19:46:04] <bstrie> pepijndevos: yes, should only take you a few minutes surely
[19:46:26] <ssbr> doomlord: if that's possible it sounds reasonable
[19:46:35] <bstrie> doomlord: can you link in arbitrary C code to iOS programs?
[19:46:49] <doomlord> arbitrary C works on iOS
[19:47:01] <bstrie> doomlord: because if so, you could maybe have a standard iOS loader that just calls libraries created in rust
[19:47:22] <doomlord> so far i've seen the iOS toolchain accelt objC, C, C++, ObjC++, and ARM assembly - but not any arm assembly i've got out of rustc yet :)
[19:47:34] <Ralith> doomlord: you need to extend rustc with support for the iphone ABI
[19:47:38] <Ralith> it shouldn't involve too many changes
[19:47:45] <doomlord> ^^^ i realise at this point thats the "real solution"
[19:47:59] <doomlord> i am reading rustc source now- its massively fascinating but very daunting too
[19:48:10] <strcat> kimundi: I fixed the private message part ;p
[19:48:20] <doomlord> it would interest me to contribute here
[19:48:21] <strcat> 5 seconds of hard work
[19:48:22] <kimundi> yeah, nice :)
[19:48:55] <pepijndevos> bstrie: is there a "LLVM JIT getting started" I can read to get up to speed?
[19:49:25] <ssbr> pepijndevos: the kaleidoscope tutorial covers it
[19:49:41] <pepijndevos> Ok, back in two minutes :)
[19:49:41] <ssbr> I don't know how much you need to know to work on the REPL, but simple uses of the LLVM JIT are, well, simple.
[19:49:46] <kimundi> bstrie, what have yo done? He believed you!
[19:49:48] <ssbr> You pass in the IR, and get a function pointer back.
[19:49:56] <pepijndevos> haha
[19:50:11] <bstrie> kimundi: shh, nobody's told him he can't do it, that means he'll succeed!
[19:50:19] <pepijndevos> Actually, working out how to loop over s atring is already hard enough for today
[19:50:27] <doomlord> bstrie,  so far i've only written portable C++/GL|ES that i moved to iOS via a small objC stub that calls the C++, thats the standard way of doing crossplatform C++/gl games
[19:50:29] <kimundi> true... except you just did. good job.
[19:50:44] <doomlord> so i'm basically thinking you should be able to do the same with rust
[19:51:16] <pepijndevos> I think I just need a slice of a slice and I'm all set :)
[19:51:37] *** Joins: Sodel_the_V (user@moz-853663E1.va.shawcable.net)
[19:52:18] <pepijndevos> why the bool? http://static.rust-lang.org/doc/core/uint.html#function-range_step
[19:52:33] <jaen> How far is dynamic loading away in Rust? Because I want to do something that would have dynamically reloadable modules and not use C++ at the same time.
[19:53:29] <bstrie> pepijndevos: //gist.github.com/5491410
[19:53:43] <kimundi> pepijndevos: It's for rusts 'for' syntactic sugar
[19:53:45] <steven_is_false> jaen: Do you mean like using dlopen, and such?
[19:54:30] <steven_is_false> jaen: Apparently, there's not really any support for it but I made a tiny wrapper for the POSIX dlfcn stuff.
[19:54:37] <steven_is_false> jaen: It seems to work okay.
[19:54:51] <jaen> Yeah, I want to dlopen a lib get new function pointers and substitute the old on the fly. Last time I remember someone mentioning it was still in the works.
[19:54:58] <kimundi> rusti: for uint::range_step(0u, 100u, 5u) |e| {print(fmt!("%d ", e))}
[19:54:59] <rusti> more than 5 lines of output, pastebinned: http://sprunge.us/PZfF
[19:55:17] <kimundi> rusti: for uint::range_step(0u, 100u, 5) |e| {print(fmt!("%d ", e))}
[19:55:18] <rusti> more than 5 lines of output, pastebinned: http://sprunge.us/KMHX
[19:55:24] <Sodel_the_V> nmatsakis: ping
[19:55:34] <kimundi> rusti: for uint::range_step(0u, 100u, 5) |e| {print(fmt!("%? ", e))}
[19:55:35] <rusti> 0 5 10 15 20 25 30 35 40 45 50 55 60 65 70 75 80 85 90 95
[19:55:40] <steven_is_false> jaen: That seems possible to do with just wrapping dlopen, and such.
[19:55:56] <steven_is_false> jaen: Do you want to dlopen a Rust library, or a C library?
[19:55:59] <kimundi> pepijndevos: ^
[19:56:12] <pepijndevos> kimundi: wat... I need to look closer at what for does
[19:56:24] <jaen> steven_is_false: I'm aiming for Rust crates here actually
[19:56:56] <steven_is_false> jaen: Because the Rust library would have to use the #[no_mangle] attribute for the function name probable.
[19:57:20] *** Quits: fredy (fredy@moz-E7647C0E.vm.okeanos.grnet.gr) (Ping timeout)
[19:57:30] <jaen> Okay, thanks for the pointers, I'll try experimenting with it.
[19:58:49] <steven_is_false> jaen: Here's my wrapper http://gitorious.org/rust-dlfcn/rust-dlfcn
[19:59:37] <jaen> Thanks!
[19:59:59] <doomlord> let def=@ast::struct_def{ dtor:None,  .. copy *def  };   <<<< what does this mean ".. copy *def"
[20:00:05] <steven_is_false> jaen: I'm still reworking it slightly so I'll be changing it a little bit.
[20:00:17] <doy> heh https://github.com/doy/rust-dlopen
[20:00:52] <doomlord> is that modifying an object (def= def from an outer scope with 'dtor' changed to None..)
[20:00:53] <kimundi> doomlord: The .. means 'use this other struct as source for the other fields not mentioned here'
[20:01:09] <doomlord> ok thanks
[20:01:11] <doy> i stopped when i couldn't figure out how i'd be able to call the function pointers
[20:01:20] <nmatsakis> Sodel_the_V: pong
[20:01:31] <doomlord> thats rather neat.
[20:02:01] <kimundi> doomlord: copy on the other hand is the old way to copy something, which will be obsoleted by (somehow) having a clone implemntation on everything copyable
[20:02:30] <doomlord> you're still going to have this copy-and-modify sugar somehow?
[20:02:47] <kimundi> the .. part, yes
[20:03:51] <Sodel_the_V> nmatsakis: Don't ask what I thought they were before, but are TraitStores just whether a trait obj is a ~, @, or &Trait?
[20:03:55] <kimundi> I guess today it should be let def=@ast::struct_def{ dtor:None,  .. (*def).clone()  };
[20:04:04] <nmatsakis> Sodel_the_V: yes.
[20:04:14] <bstrie> Sodel_the_V: what are you working on?
[20:04:56] <doomlord> why does it need the 'clone' or 'copy' in the first place - because it might have ~T's in the source 'def' ?
[20:05:01] <Sodel_the_V> Ah, excellent. I'll document that, then.
[20:05:04] *** Joins: ghrust (ghrust@moz-4EF5B6E5.rs.github.com)
[20:05:04] <ghrust> 01[13rust01] 15bors merged 06auto into 06incoming: 02http://git.io/0ynT2Q
[20:05:04] *** Parts: ghrust (ghrust@moz-4EF5B6E5.rs.github.com) ()
[20:05:27] <doomlord> and it would have transfered ownership otherwise?
[20:05:28] *** Joins: fredy (fredy@moz-E7647C0E.vm.okeanos.grnet.gr)
[20:05:49] <Sodel_the_V> bstrie: #5762. Trying to clean up object types and emthod lookup
[20:07:38] <strcat> doomlord: you can move out of &T by doing *foo, you can only copy out or swap out (if it's &mut T)
[20:07:44] <bstrie> Sodel_the_V: awesome
[20:08:22] *** Joins: Jesse (jruderman@2557E599.66715431.D25A875A.IP)
[20:08:27] <kimundi> doomlord: Actually I don't have enough source context and legacy implementation knowledge to answer the question why a copy is necessary there :)
[20:08:44] <kimundi> doomlord: Probably because values move per default
[20:08:55] <doomlord> ok
[20:10:38] *** Quits: azita (Azita@2557E599.66715431.D25A875A.IP) (Quit: azita)
[20:11:52] *** Quits: burntsushi__ (burntsushi@moz-A046EF37.eecs.tufts.edu) (Quit: Konversation terminated!)
[20:13:20] *** Joins: azita (Azita@2557E599.66715431.D25A875A.IP)
[20:14:27] <pepijndevos> Why is there a bang in fmt!
[20:14:57] <EXetoC> it's a macro
[20:15:23] *** Joins: true_droid (Adium@moz-123FD9B8.beck.volia.net)
[20:15:58] <true_droid> what are some good examples of doing loops and iteration in Rust stdlib?
[20:16:08] <kimundi> rusti: fmt!("I'm %s and %s at compiletime!", "evaluated", "typechecked")
[20:16:09] <rusti> ~"I\'m evaluated and typechecked at compiletime!"
[20:16:47] <true_droid> kimundi: does it support generic % token? one suitable for any type?
[20:16:52] <kimundi> well, not evaluated, scratch that
[20:17:05] <strcat> true_droid: %?, but it uses reflection for aggregate types, not ToStr
[20:17:17] <kimundi> true_droid: It supporst what printf in c would support
[20:17:30] <kimundi> but compiletime typechecked
[20:17:51] <kimundi> and a generic %?, as strcat said
[20:17:56] <strcat> rusti (the bot) is just using fmt!("%?", { given_code })
[20:18:03] <true_droid> no %? at compile time?
[20:18:17] <strcat> true_droid: it does expand it at compile-time
[20:18:31] <strcat> but it generates the code based on reflection
[20:18:33] <true_droid> I see, that was a rushed question
[20:18:39] <strcat> it doesn't use a trait
[20:19:03] <strcat> rusti: let mut xs = std::treemap::TreeSet::new(); xs
[20:19:05] <rusti> foo.rs:5:22: 5:48 error: cannot determine a type for this bounded type parameter: unconstrained type
[20:19:05] <rusti> foo.rs:5          let mut xs = std::treemap::TreeSet::new(); xs
[20:19:05] <rusti>                                ^~~~~~~~~~~~~~~~~~~~~~~~~~
[20:19:05] <rusti> note: in expansion of fmt!
[20:19:05] <rusti> foo.rs:4:12: 6:7 note: expansion site
[20:19:06] <kimundi> rusti: struct A {b: uint, c:char}; let v = A{b: 145, c: 'w'}; v
[20:19:07] <rusti> {b: 145, c: 'w'}
[20:19:15] <strcat> rusti: let mut xs = std::treemap::TreeSet::new(); xs.insert("foo"); xs
[20:19:17] <rusti> {map: {root: Some(~{key: "foo", value: (), left: None, right: None, level: 1}), length: 1}}
[20:19:37] <strcat> rusti: let mut xs = std::treemap::TreeSet::new(); xs.insert("foo"); xs.insert("bar"); xs.insert("baz"); xs
[20:19:38] <rusti> line longer than 100 columns, pastebinned: http://sprunge.us/IbOc
[20:20:07] <nmatsakis> I forgot how long it takes to deal with this "last remaining errors in make check" part of the check-in cycle...
[20:20:18] *** Quits: lmandel (lmandel@2557E599.66715431.D25A875A.IP) (Quit: lmandel)
[20:20:37] *** Quits: doublec (doublec@moz-4DA4FA7C.cd.pn) (Quit: Bye )
[20:21:06] <true_droid> kimundi: > true_droid: It supporst what printf in c would support. That's would be a problem, because in C you need to know underlying type of typedef to print them. But in Rust %s should be applicable to any type if ir uses ToStr
[20:21:21] <nmatsakis> brson graydon : it'd be a hack, but maybe we should establish a convention that you write the unit tests for a libcore/libstd module in mod_tests.rs and then include them with a #[path] directive; then the makefile could ignore dependencies from such files 
[20:21:52] <strcat> nmatsakis: I've just been fudging the timestamps
[20:21:57] <strcat> mtime
[20:22:08] <kimundi> true_droid: It supports the same % options, but typechecks it's arguments at compiletime. So it's not like C in that regard
[20:22:31] <strcat> true_droid: probably shouldn't use ToStr though
[20:22:40] <strcat> ideally types would have a way of writing them out to a stream
[20:22:49] <strcat> not allocating a string and writing that out into another string for formatting and writing that out
[20:22:58] <strcat> it's pretty terrible right now
[20:23:03] <true_droid> sure
[20:23:21] <true_droid> I thought ToStr was an interface method that did just what you described would be ideal
[20:23:30] <nmatsakis> strcat: I've figured we'd eventually convert ToStr so that it has two methods, one for appending and then one (to_str) that wraps that with a default impl
[20:23:54] <strcat> nmatsakis: should be for writing to a Writer I guess
[20:23:59] <strcat> and strings can implement Writer
[20:24:00] <nmatsakis> yeah, I guess
[20:24:03] <strcat> that's what python does
[20:24:07] <strcat> io.StringIO
[20:24:12] <pepijndevos> to_str_bytes_common: radix 64 to high, must lie in the range [2, 36] :(
[20:24:20] <nmatsakis> and then `%s` can work for anything for which ToStr is implemented...
[20:24:24] <strcat> and I guess C++'s stringstreams are kind of like that but I *hate* stringstreams
[20:24:29] *** Joins: doublec (doublec@moz-4DA4FA7C.cd.pn)
[20:25:11] *** Joins: FrozenCow (FrozenCow@moz-9DF5D010.dynamic.upc.nl)
[20:25:20] *** Quits: FrozenCow (FrozenCow@moz-9DF5D010.dynamic.upc.nl) (Client exited)
[20:25:24] <kimundi> pepijndevos: Look in std for base64
[20:25:54] <strcat> nmatsakis: http://docs.python.org/3.3/library/io.html really nice imo
[20:26:10] <strcat> since you can pass StringIO to anything that wants a file-like thing
[20:26:26] <pepijndevos> kimundi: that's cheating :P Would be cool if the docs had a view-source link
[20:26:34] <true_droid> are there plans to make constants untyped? or is this syntax what you'll stick with? 512u64
[20:26:50] <strcat> true_droid: if you use '512' it will infer the type
[20:27:05] <strcat> it falls back to 'int' though
[20:27:25] *** Quits: int3_ (int3_@moz-359A42F6.subnet-248.amherst.edu) (Client exited)
[20:27:34] <strcat> rusti: 5u
[20:27:35] <rusti> 5
[20:27:41] <true_droid> strcat: so, is it purely optional to have all constants annotated like here? https://github.com/mozilla/rust/blob/master/src/libstd/md4.rs#L29
[20:27:44] <nmatsakis> brson: oh, I have a question/comment about in-progress io changes
[20:27:56] <strcat> true_droid: yes
[20:28:04] <strcat> true_droid: unless it doesn't have a place to infer from
[20:28:10] <nmatsakis> true_droid: btw if you DO want to annotate manually, I suggest "512_u64"
[20:28:15] <nmatsakis> (since _ is permitted)
[20:28:18] <strcat> let x = 5; let y = 6; x + y // will fall back to int
[20:28:29] <true_droid> I get it, thanks
[20:28:34] <strcat> let x = 5; let y = 6u; x + y /* both are uint */
[20:28:49] *** Joins: tjc (tjc@A5087023.2354C43D.D8E68FF6.IP)
[20:28:49] *** ChanServ sets mode: +o tjc
[20:28:58] <true_droid> nmatsakis: I don't :) 
[20:29:17] <true_droid> programmer needs to annotate only in the presence of ambiguity
[20:29:36] <kimundi> pepijndevos: What exactly are you trying to do that needs a base 64?
[20:29:41] <strcat> it won't tell you about ambiguity though, it will fall back to int (which I don't really like)
[20:29:56] <strcat> except in cases where it's broken...
[20:30:03] <nmatsakis> I'm inclined to agree, I think I'd prefer if you had to annotate 
[20:30:07] <nmatsakis> in such cases
[20:30:12] <strcat> [5i, 2, 3, 4, 5, 6] isn't that painful
[20:30:15] <pepijndevos> kimundi: crypto challenge
[20:30:26] * nmatsakis shrugs
[20:30:27] <kimundi> pepijndevos: Hehe, thought so
[20:30:48] <kimundi> pepijndevos: you're like, the fivt in the last few weeks
[20:31:03] <true_droid> does Rust support specifying expression type with : ? like, e.g. in Haskell â€” read "5" :: Int
[20:31:16] <strcat> true_droid: read::<int>(s)
[20:31:20] <pepijndevos> kimundi: lol. I'm not even sure if they intend me to write my own base64, or just use the lib.
[20:31:23] <strcat> or let x: int = read(s);
[20:31:40] <bstrie> rusti: float::pow(2,2)
[20:31:41] <rusti> more than 5 lines of output, pastebinned: http://sprunge.us/DaXB
[20:31:45] <bstrie> rusti: float::exp(2,2)
[20:31:47] <rusti> more than 5 lines of output, pastebinned: http://sprunge.us/XWGB
[20:31:48] <bstrie> bah
[20:32:06] *** Joins: ghrust (ghrust@moz-4EF5B6E5.rs.github.com)
[20:32:06] <ghrust> 01[13rust01] 15bors pushed 0 new commits to 06auto: 02http://git.io/U0q3MA
[20:32:06] *** Parts: ghrust (ghrust@moz-4EF5B6E5.rs.github.com) ()
[20:32:07] *** Joins: ghrust (ghrust@moz-4EF5B6E5.rs.github.com)
[20:32:07] <ghrust> 01[13rust01] 15bors pushed 2 new commits to 06auto: 02http://git.io/O5crYg
[20:32:07] <ghrust> 13rust/06auto 148408012 15Jed Davis: The null case of a nullable-poiner enum might not be nullary....
[20:32:07] <ghrust> 13rust/06auto 149d966ae 15bors: auto merge of #6134 : jld/rust/issue-6117, r=catamorphism...
[20:32:08] *** Parts: ghrust (ghrust@moz-4EF5B6E5.rs.github.com) ()
[20:32:09] <ssbr> pepijndevos: for an online challenge, with crypto? I'd assume they'd let you use an existing implementation. base64 isn't very interesting. :(
[20:32:24] <true_droid> is it applicable to values?  let v = 5; v :: int;  v :: float <â€” compiler error
[20:32:27] *** Quits: pyrac (pyrac@moz-2FEC2239.w92-149.abo.wanadoo.fr) (Quit: pyrac)
[20:32:30] <strcat> nmatsakis: btw I have a really simple test case for the type inference thing now - it turns out to be unrelated to borrowed pointers
[20:32:33] <pepijndevos> ssbr: probably...
[20:32:34] <strcat> nmatsakis: I think it has to do with closures.
[20:32:39] <strcat> sec
[20:32:50] <bstrie> how do I do pow in rust?
[20:32:56] <ssbr> true_droid: let v : int = 5;
[20:33:12] <ssbr> maybe you can do v:int as a standalone expression, I don't know.
[20:33:18] <ssbr> (probably not.)
[20:33:28] <true_droid> ok
[20:33:38] <strcat> ssbr: you can, kind of ;p
[20:33:44] <nmatsakis> strcat: which issue # is that again?
[20:33:48] <ssbr> true_droid: the ::<...> is for giving type parameters to generics, I don't think it applies to something like this.
[20:33:48] <strcat> util::id::<int>(foo)
[20:33:53] <ssbr> it doesn't mean the same as haskell ::
[20:34:07] <ssbr> it means the same as D's !(...), or C++'s <...>
[20:34:15] <ssbr> strcat: Ah, that would work!
[20:34:16] <strcat> nmatsakis: https://github.com/mozilla/rust/issues/5801 (which has the really long test case)
[20:34:34] <true_droid> strcat: is that compile-time?
[20:34:41] <kimundi> bstrie: There in num::pow_with_uint, and pow in f32 and f64
[20:34:51] <strcat> true_droid: yes, id is just the identify function
[20:34:53] <strcat> doesn't do anything ;p
[20:34:53] *** Joins: zakora (NC@moz-8EAF945F.fbx.proxad.net)
[20:34:54] <ssbr> true_droid: that would fail or pass at compile-time
[20:35:23] <true_droid> ssbr: yeah, I mean if it passes whether it adds function call overhead at runtime
[20:35:27] <ssbr> true_droid: if you do let v:float = 5; id::<int>(v); then the type checker can't unify the types
[20:35:28] <strcat> nmatsakis: http://ix.io/5pW here's the simple test case
[20:35:30] <ssbr> so it'll fail
[20:35:33] <strcat> nmatsakis: remove the : uint hint and it breaks
[20:35:44] <ssbr> true_droid: Oh. Yeah, I'd guess that it does, sorry :(
[20:35:50] <strcat> nmatsakis: I *hope* it's the same bug :)
[20:35:56] <ssbr> (but maybe not, and even if so, not much -- id does nothing.)
[20:36:18] *** Joins: fabiand (fabiand@moz-A27A2041.adsl.alicedsl.de)
[20:36:20] <true_droid> must be trivial to inline
[20:36:36] <ssbr> I'm bad at guessing how smart my compilers are, so I always assume the worst of them.
[20:36:37] *** Joins: int3_ (int3_@moz-359A42F6.subnet-248.amherst.edu)
[20:36:39] *** Quits: int3_ (int3_@moz-359A42F6.subnet-248.amherst.edu) (Client exited)
[20:36:40] *** Joins: int3_ (int3_@moz-359A42F6.subnet-248.amherst.edu)
[20:37:08] <strcat> true_droid: generic functions are specialized for each combination of type parameters
[20:37:29] <strcat> so a small one will definitely get inlined without overhead
[20:37:42] <ssbr> so in the case of id, it will became a no-op?
[20:37:52] <strcat> ssbr: with optimization on, yes for sure
[20:38:01] <ssbr> woohoo. :)
[20:40:02] <true_droid> strcat: is this specialization mechanism similar to C++. I'm guessing yes but with the exception of repeating the instantiation for every source file like C++ does since Rust has modules
[20:40:16] <true_droid> that was a question, sorry for my punctuation
[20:40:18] *** Quits: fabiand (fabiand@moz-A27A2041.adsl.alicedsl.de) (Quit: Verlassend)
[20:40:21] <strcat> true_droid: it *compiles* like C++ templates
[20:40:29] <strcat> but semantically it's equivalent to haskell type classes
[20:40:36] <strcat> the bounds are explicit and it's type-checked from the definition
[20:40:59] <strcat> C++ templates are type-checked for every instantiation and if it fails type-checking it looks for another overload (SFINAE - substitution failure is not an error)
[20:41:18] <strcat> and that's why C++ error messages are so bad :)
[20:41:46] <true_droid> seems good
[20:42:04] <strcat> true_droid: like fn foo<T: Ord + Eq>() { ... }
[20:42:24] <strcat> fn foo<T: Ord + Eq>(a: &T, b: &T) -> bool { ... }
[20:42:45] <strcat> where T is the actual type, and it implements Ord and Eq
[20:42:58] <strcat> they can also be used as interfaces, which is dynamic dispatch
[20:43:16] <strcat> you just take the actual trait object as the parameter, instead of a generic type
[20:44:10] <true_droid> I'm starting to like Rust more and more but still cautious of playing with it seriously because of instability
[20:45:43] <pcwalton> hooray, down to 729 errors
[20:45:59] <jclements> pcwalton: that's a perfect square!
[20:46:03] <pcwalton> yes, it is
[20:46:44] <steven_is_false> rusti: f32::sqrt (729)
[20:46:46] <rusti> more than 5 lines of output, pastebinned: http://sprunge.us/dLWY
[20:46:57] <steven_is_false> rusti: f32::sqrt (729.0)
[20:46:59] <rusti> 27
[20:49:33] <strcat> pcwalton: weren't you down to 200 before? ;p
[20:49:37] <pcwalton> that was in libstd
[20:49:40] <pcwalton> now I'm in libsyntax
[20:49:50] <nmatsakis> pcwalton: what are you working on?
[20:50:09] <pcwalton> nmatsakis: INHTWAMA-ifying the serializer, including auto_encode, auto_decode, json, ebml, and serialize
[20:50:30] <strcat> as in purging mut fields + &const?
[20:50:32] <pcwalton> requires passing the serializer/deserializer through since it's &mut
[20:50:33] <pcwalton> yes
[20:50:42] <pcwalton>  6 files changed, 2626 insertions(+), 164 deletions(-)
[20:51:37] *** Quits: BitPuffin (quassel@moz-8370D1B9.bredband.comhem.se) (Client exited)
[20:52:12] *** Joins: lmandel (lmandel@2557E599.66715431.D25A875A.IP)
[20:53:15] *** Joins: BitPuffin (quassel@moz-8370D1B9.bredband.comhem.se)
[20:58:24] *** Joins: pyrac (pyrac@moz-2FEC2239.w92-149.abo.wanadoo.fr)
[20:59:30] *** Quits: pyrac (pyrac@moz-2FEC2239.w92-149.abo.wanadoo.fr) (Quit: pyrac)
[21:00:48] *** Quits: haard (fredrik@moz-6A86987C.dynamic.se.alltele.net) (Ping timeout)
[21:04:40] *** Quits: steven_is_false (quassel@moz-9001998F.bchsia.telus.net) (Client exited)
[21:04:45] <nmatsakis> has anyone seen failures in os::tests:copy_file_ok before?
[21:04:56] <nmatsakis> that shows up in the test run for that fix to the annihilator
[21:04:59] <nmatsakis> no idea what could be going on there...
[21:05:26] <nmatsakis> but I think I'll request bors to retry, sounds like it might just be a transient os failure
[21:05:54] <strcat> nmatsakis: it might leave stuff in git_root/tmp
[21:06:01] <strcat> dunno
[21:06:05] <nmatsakis> what is the url of the bors status page again?
[21:06:12] <nmatsakis> my new machine doesn't have it in the awesomebar history yet :)
[21:06:18] <strcat> http://buildbot.rust-lang.org/bors/bors.html
[21:06:31] <strcat> I think make clean should clear git_root/tmp
[21:06:40] <strcat> or maybe it shouldn
[21:06:43] <strcat> 't ;p
[21:06:50] <strcat> it would be better to use an actual temp dir
[21:07:07] *** Quits: Sodel_the_V (user@moz-853663E1.va.shawcable.net) (Quit: Time for a break)
[21:08:54] *** Quits: Jesse (jruderman@2557E599.66715431.D25A875A.IP) (Quit: Jesse)
[21:09:55] <strcat> huh, it does kind of
[21:09:57] <strcat> $(Q)rm -f tmp/*.log tmp/*.rc tmp/*.rs tmp/*.ok
[21:10:03] <strcat> it could just use *
[21:10:19] *** Joins: Jesse (jruderman@2557E599.66715431.D25A875A.IP)
[21:10:44] *** Quits: h3r3tic (heretic@moz-8BC3B3DB.se) (Ping timeout)
[21:10:49] *** Quits: zakora (NC@moz-8EAF945F.fbx.proxad.net) (Quit: Textual IRC Client: www.textualapp.com)
[21:11:55] *** Joins: h3r3tic (heretic@moz-8BC3B3DB.se)
[21:12:58] <strcat> nmatsakis: https://github.com/mozilla/rust/pull/6139 r?
[21:14:10] <strcat> nmatsakis: oh the failures are probably just races
[21:14:15] <strcat> some of this stuff seems to reuse naming
[21:14:57] <strcat> each test could just grab a dir with tempfile::mkdtemp
[21:16:12] <pcwalton> down to 343
[21:19:42] *** Quits: bhearsum (bhearsum@moz-FBAE94.members.linode.com) (Ping timeout)
[21:21:36] *** Joins: bhearsum (bhearsum@moz-FBAE94.members.linode.com)
[21:23:14] *** Quits: rgrinberg (rgrinberg@AE999E95.52DE4C60.258AD6F5.IP) (Ping timeout)
[21:24:21] <Jeaye> How can I break out of all loops here? https://gist.github.com/Jeaye/b235efd41ffeb4536e4f
[21:24:34] <Jeaye> Returning is not an option.
[21:25:13] <bstrie> Jeaye: you could use while loops instead, and then use labeled break
[21:25:32] <Jeaye> Hmm, not familiar with labeled breaks.
[21:25:33] <bstrie> or you could pester someone to implement labeled break on for loops :P
[21:25:45] <Jeaye> pcwalton: <3
[21:25:54] <Jeaye> heh
[21:26:15] <Jeaye> bstrie: Do you've an example of the labeled break for a while I can see?
[21:26:43] <pcwalton> Jeaye: 'foo: loop { ... break 'foo; }
[21:26:43] <bstrie> Jeaye: https://github.com/mozilla/rust/blob/master/src/test/run-pass/labeled-break.rs
[21:27:40] <Jeaye> Ahh, so it has to be an infinite loop with my own logic for the 'for'ness of it.
[21:27:54] <Jeaye> That's workable; thanks.
[21:29:02] *** bhearsum is now known as bhearsum|afk
[21:31:22] <bstrie> Jeaye: I *think* while loops work too, maybe
[21:32:08] <bstrie> rusti: loop: foo { break foo; }
[21:32:09] <rusti> foo.rs:5:13: 5:14 error: expected `;` or `}` after expression but found `:`
[21:32:09] <rusti> foo.rs:5          loop: foo { break foo; }
[21:32:09] <rusti>                       ^
[21:32:18] <bstrie> rusti: foo: loop { break foo; }
[21:32:19] <rusti> foo.rs:5:12: 5:13 error: expected `;` or `}` after expression but found `:`
[21:32:19] <rusti> foo.rs:5          foo: loop { break foo; }
[21:32:19] <rusti>                      ^
[21:32:30] <bstrie> rusti: 'foo: loop { break 'foo; }
[21:32:31] <rusti> foo.rs:5:9: 5:13 error: unexpected token: `'foo`
[21:32:31] <rusti> foo.rs:5          'foo: loop { break 'foo; }
[21:32:31] <rusti>                   ^~~~
[21:32:36] <bstrie> pleh
[21:32:40] <bstrie> I forget the old syntax
[21:33:46] <graydon> pcwalton: are the sub-bugs dangling off https://github.com/mozilla/rust/issues/3944 something you expect to work on for 0.7?
[21:33:53] *** Joins: alisdair (textual@moz-EBE9F394.bchsia.telus.net)
[21:34:39] * strcat could just update rusti to incoming
[21:36:19] *** Quits: doublec (doublec@moz-4DA4FA7C.cd.pn) (Quit: Bye )
[21:36:54] <strcat> now is as good a time as ever to set up a nightly build ;p
[21:37:39] <Luqman> the segemented stack support in llvm for arm seems to only be for android
[21:37:51] *** Quits: Benvie (brandon@5FD20F9A.53D07D95.EFF8B7BF.IP) (Ping timeout)
[21:38:43] <strcat> Luqman: doesn't work on plain old linux/glibc/gcc?
[21:39:32] *** Joins: Benvie (brandon@5FD20F9A.53D07D95.EFF8B7BF.IP)
[21:39:49] <Luqman> strcat: nope, it fails for !android
[21:40:03] *** Joins: doublec (doublec@moz-4DA4FA7C.cd.pn)
[21:40:09] *** Quits: dpritchett (dpritchett@1E686A23.8B146FD9.67894F1C.IP) (Quit: Leaving)
[21:40:44] *** Quits: erickt (erickt@8C9ECD8F.3A598286.F12515B4.IP) (Quit: Leaving.)
[21:40:53] <brson> jld: are there going to be bad consequences if we snapshot a compiler that does not contain your llvm patch?
[21:41:49] <pcwalton> graydon: yes
[21:41:53] <pcwalton> I plan to work on that soon
[21:42:11] *** Joins: jgilbert (jgilbert@2557E599.66715431.D25A875A.IP)
[21:42:14] <Luqman> ILyoan: ping
[21:42:51] <graydon> pcwalton: ok. I'll assign them to you. drop if they're not going to make it.
[21:43:35] <jld> brson: Well, it's going to miscompile certain cases of pattern matching, if you have the nullable pointer change and not the simplifycfg patch.
[21:44:54] <brson> that sounds bad
[21:45:06] <brson> does it not affect any code in the tree?
[21:45:41] <brson> the build seems to be working without
[21:47:07] <jld> I think it doesn't.  I only caught it because one of the doc tests happened to trigger it.
[21:47:17] <jld> But of course I don't know if there was some other subtle wrongness going on.
[21:48:17] *** Quits: lmandel (lmandel@2557E599.66715431.D25A875A.IP) (Ping timeout)
[21:48:26] *** Joins: lmandel (lmandel@2557E599.66715431.D25A875A.IP)
[21:48:38] *** Quits: CarpNet (Alasdair@moz-EF831A5E.cable.virginmedia.com) (Quit: Leaving)
[21:49:35] <brson> I think I'm going to wait until LLVM is upgraded again before doing snapshots
[21:50:02] <jld> I guess I don't understand why we'd want to snapshot a compiler without the patch.
[21:50:03] *** Joins: ghrust (ghrust@moz-4EF5B6E5.rs.github.com)
[21:50:03] <ghrust> 01[13rust01] 15bors merged 06auto into 06incoming: 02http://git.io/O5crYg
[21:50:03] *** Parts: ghrust (ghrust@moz-4EF5B6E5.rs.github.com) ()
[21:50:11] *** Quits: tgt (tgt@moz-D59EE478.aztw.cable.virginmedia.com) (Quit: Computer has gone to sleep.)
[21:53:07] *** Joins: ghrust (ghrust@moz-4EF5B6E5.rs.github.com)
[21:53:07] <ghrust> 01[13rust01] 15bors pushed 0 new commits to 06auto: 02http://git.io/JGqavw
[21:53:07] *** Parts: ghrust (ghrust@moz-4EF5B6E5.rs.github.com) ()
[21:53:23] *** Quits: spider-mario (spidermari@moz-2F72F6FF.dsl.quantic-telecom.net) (Input/output error)
[21:55:49] *** Quits: devinus (devinus@moz-B4AF84BC.ptr.us.xo.net) (Quit: Textual IRC Client: www.textualapp.com)
[21:57:06] *** Quits: infynyxx (infynyxx@DB780A29.749BA1D.DCC373F0.IP) (Client exited)
[21:58:04] *** Joins: erickt (erickt@8C9ECD8F.3A598286.F12515B4.IP)
[21:59:18] *** Joins: lkuper (lkuper@moz-C0CD33ED.hsd1.in.comcast.net)
[22:02:59] *** Quits: pcwalton (pcwalton@43CB6079.66715431.D25A875A.IP) (Quit: pcwalton)
[22:03:46] *** Quits: libertas (libertas@98ADBCEC.786003BB.593B3862.IP) (Quit: Lost terminal)
[22:04:23] *** Joins: pcwalton (pcwalton@43CB6079.66715431.D25A875A.IP)
[22:04:23] *** ChanServ sets mode: +o pcwalton
[22:04:30] *** Joins: Sodel_the_V (user@moz-853663E1.va.shawcable.net)
[22:07:52] *** Quits: Benvie (brandon@5FD20F9A.53D07D95.EFF8B7BF.IP) (Quit: )
[22:09:47] *** Quits: pcwalton (pcwalton@43CB6079.66715431.D25A875A.IP) (Ping timeout)
[22:10:22] *** Joins: pcwalton (pcwalton@43CB6079.66715431.D25A875A.IP)
[22:10:22] *** ChanServ sets mode: +o pcwalton
[22:11:04] *** Quits: jyasskin_w (jyasskin@DAF66858.C60FE7DC.4065847B.IP) (Quit: Ex-Chat)
[22:11:06] *** Quits: Diablo-D3 (diablo@moz-52AA8794.port.east.myfairpoint.net) (Quit: This computer has gone to sleep)
[22:12:21] *** Quits: lkuper (lkuper@moz-C0CD33ED.hsd1.in.comcast.net) (Quit: lkuper)
[22:12:44] *** Quits: RagingDave (RagingDave@moz-3F31ACEF.pools.arcor-ip.net) (Client exited)
[22:14:07] *** Quits: donri (dag@moz-9BB61102.tbcn.telia.com) (Quit: Leaving)
[22:17:05] *** Quits: bjz (brendanzab@B398BE78.F804C29E.D35A31DF.IP) (Connection reset by peer)
[22:22:19] <tjc> brson: if I'm running a single test executable (like stdtest), does the test runner run different #[test] functions in parallel by default?
[22:23:24] *** Quits: alisdair (textual@moz-EBE9F394.bchsia.telus.net) (Quit: My MacBook Pro has gone to sleep. ZZZzzzâ€¦)
[22:23:41] <strcat> tjc: yes
[22:23:44] <graydon> pcwalton: shall I assign resolve-related stuff in the 0.7 milestone to you? there are a couple
[22:23:49] <tjc> strcat: ok, that makes me feel better
[22:23:51] <graydon> not sure how full your plate is presently
[22:23:57] <tjc> (as in, explains the bug I just isolated)
[22:24:02] <graydon> I'll leave on "backwards compat" otherwise
[22:24:18] <tjc> (which is a totally silly bug since as it turns out, two different tests for recursive directory creation are clobbering each other's directories)
[22:25:06] *** Quits: pcwalton (pcwalton@43CB6079.66715431.D25A875A.IP) (Quit: pcwalton)
[22:25:46] *** Joins: pcwalton (pcwalton@43CB6079.66715431.D25A875A.IP)
[22:25:46] *** ChanServ sets mode: +o pcwalton
[22:26:03] *** Joins: ghrust (ghrust@moz-4EF5B6E5.rs.github.com)
[22:26:03] <ghrust> 01[13rust01] 15bors 04force-pushed 06auto from 141a14586 to 149d966ae: 02http://git.io/N3iJvQ
[22:26:03] *** Parts: ghrust (ghrust@moz-4EF5B6E5.rs.github.com) ()
[22:26:04] *** Joins: ghrust (ghrust@moz-4EF5B6E5.rs.github.com)
[22:26:04] <ghrust> 01[13rust01] 15bors pushed 3 new commits to 06auto: 02http://git.io/pARTYQ
[22:26:04] <ghrust> 13rust/06auto 1441d06db 15Jed Davis: Reverse accidental src/llvm reversion in 876483dcf, and add test....
[22:26:04] <ghrust> 13rust/06auto 144701716 15Jed Davis: Revert "doc: XFAIL mysterious failure on bots"...
[22:26:04] <ghrust> 13rust/06auto 149329bd6 15bors: auto merge of #6136 : jld/rust/simplifycfg-unrevert, r=thestinger...
[22:26:07] *** Parts: ghrust (ghrust@moz-4EF5B6E5.rs.github.com) ()
[22:26:28] <pcwalton> graydon: if they're backwards incompatible language changes sure
[22:26:48] <graydon> eh. not changes so much as it just not doing what I think it probably should.
[22:27:00] <pcwalton> I might ask to hold off on those then
[22:27:09] <pcwalton> I don't know if I'll get to them for 0.7
[22:27:20] <graydon> https://github.com/mozilla/rust/issues/5248 and https://github.com/mozilla/rust/issues/5269
[22:27:24] *** Quits: erickt (erickt@8C9ECD8F.3A598286.F12515B4.IP) (Quit: Leaving.)
[22:27:33] <graydon> yeah. ok. I put them on maturity #2 but really they might be later, like production ready
[22:27:51] <graydon> assuming you have a "correct semantics" in mind for them and we're currently trying to and just failing
[22:28:00] <graydon> (they currently do reproduce)
[22:28:52] *** Joins: erickt (erickt@8C9ECD8F.3A598286.F12515B4.IP)
[22:31:39] *** Quits: jeff (jeff@4231C034.745B261B.F12515B4.IP) (Quit: jeff)
[22:32:00] *** Quits: Scriptor (historium@moz-E06F46F0.corp.bitshelter.com) (Quit: Scriptor)
[22:35:53] <doomlord_> is there something i can pass to rustc to generate 32bit code , if i didn't have android/arm compiled in
[22:35:59] <doomlord_> 32bit LLVM IR code
[22:36:20] *** Quits: erickt (erickt@8C9ECD8F.3A598286.F12515B4.IP) (Quit: Leaving.)
[22:40:05] <strcat> doomlord_: you need the proper target triple so #[cfg(arch)] gets the right stuff
[22:40:14] <graydon> --target=i686-unknown-linux should do
[22:40:14] <strcat> not just about 32-bit vs 64-bit
[22:40:19] <tjc> brson: ping
[22:40:28] <graydon> or i686-unknown-linux-gnu
[22:40:32] <strcat> graydon: I think he wants it for ARM though
[22:40:38] <strcat> so the assembly will be wrong
[22:40:40] <graydon> oh. dunno.
[22:40:52] *** Quits: ksev (DrunkenPan@745B767B.989A61DC.CA5B6332.IP) (Ping timeout)
[22:41:18] <doomlord_> what is at the back of my mind here always is, platform vendors can create lockins with compilers
[22:41:27] <brson> tjc: yes, tests in parallel by default
[22:41:29] <brson> tjc: pong
[22:41:29] <doomlord_> apple dont want you to be able to compile iOS programs on anything other than a mac
[22:41:41] <doomlord_> sony have a proprietary compiler for PS Vita . etc..
[22:41:47] *** Joins: rgrinberg (rgrinberg@AE999E95.52DE4C60.258AD6F5.IP)
[22:41:48] <tjc> brson: so I found the issue with the mkdir_recursive tests, which is pretty obvious now that I know the tests run in parallel
[22:41:58] <tjc> race condition with calls to os::change_dir and the cwd being something unexpected
[22:41:59] <tjc> But
[22:42:09] <tjc> how do I handle that? is there a way to make tests selectively run sequentially?
[22:42:23] <graydon> doomlord_ yes. what's your point?
[22:43:14] <strcat> tjc: maybe change_dir shouldn't be used
[22:43:18] <strcat> seems like it would be a problem with tasks too
[22:43:27] <tjc> strcat: any suggestions? I want to make sure that mkdir_recursive works on a relative path
[22:43:34] *** Quits: rgrinberg (rgrinberg@AE999E95.52DE4C60.258AD6F5.IP) (Ping timeout)
[22:43:36] <brson> tjc: it's possible to factor out a global mutex for all these functions that change the environment for testing purposes. there's an api in unstable::global_data that can help
[22:43:36] <tjc> well, maybe it shouldn't work on a relative path at all!
[22:43:53] <tjc> brson: ok, great. are there any existing examples of that? (using the mutex for the environment)
[22:44:04] <brson> tjc: os::getenv does it
[22:44:11] <tjc> brson: cool, will look at it; thanks
[22:44:56] <doomlord_> at the minute i'm trying to get rust code onto an iphone ; trying to see if there is a way to do this *without* rustc itself knowing about iOS
[22:45:04] <strcat> ugh, rust hates being built in a chroot - I don't understand ;p
[22:45:06] <strcat> the tests fail
[22:46:08] <doomlord_> it seems it could be a useful excercise r.e. using this language for 'other platforms' which may appear in future, and have appeared in the past.
[22:46:56] <strcat> rust has assembly so it has to know about the platform
[22:48:32] <strcat> well hopefully this cronjob works ;p
[22:49:42] <Ralith> doomlord_: compilers must know about the target platform
[22:49:49] <Ralith> there is no escaping that
[22:49:56] <Ralith> the best you can do is make it really easy to add new targets
[22:50:29] <doomlord_> i was hoping i could go rustc -> LLVMIR -> C -> [ platform vendors' C compiler] to get it anywhere
[22:50:35] *** Joins: jeff (jeff@moz-A18F84B1.nycmny.fios.verizon.net)
[22:51:01] <strcat> doomlord_: rustc needs to know the arch of the platform though so it can select the right runtime support stuff
[22:51:16] <strcat> src/rt/arch
[22:51:39] <doomlord_> at least in C i can make an emulation layer of any unsupported functions
[22:51:56] <Ralith> C is not portable
[22:52:11] <strcat> and that layer is done with #ifdef in C and #[cfg()] in rust
[22:52:15] <Ralith> there is no escaping the fact that target platforms differ
[22:52:17] <doomlord_> empirically i have seen C on more platforms than LLVM
[22:52:24] <Ralith> lol
[22:53:41] <pcwalton> it would be good to fix the LLVM C backend
[22:53:58] <doomlord_> yes, there is no need for Rust to compete with C.
[22:54:13] <doomlord_> any high level language should be able to exist symbiotically with C
[22:54:31] <strcat> pcwalton: it still has assembly in the rt
[22:54:43] <pcwalton> sure, you'd have to make a new target
[22:54:49] <pcwalton> basically like what PNaCl did
[22:54:54] <pcwalton> you can probably use the PNaCl target
[22:55:14] <pcwalton> and use setcontext and swapcontext or whatever
[22:55:28] <pcwalton> (or just go runtimeless)
[22:55:40] <pcwalton> once brson's I/O stuff lands a lot more of Rust will work runtimeless, btw
[22:55:44] <Jesse> nmatsakis: i'm interested in knowing where this goes: "One important guideline will be to establish what invariants unsafe code must maintain to avoid straying into 'undefined behavior' land.
[22:55:46] <jld> Alternately... has anyone tried to combine Rust with Emscripten yet?
[22:55:47] <doomlord_>  'the subset of rust that can translate to C' would be useful to me
[22:55:49] <pcwalton> everything but failure and logging I think.
[22:55:58] <pcwalton> and tasks obviously.
[22:56:34] <pcwalton> I would love to port sprocketnes to runtimeless Rust
[22:56:50] <pcwalton> since it doesn't really need tasks, emulation is pretty single-threaded
[22:57:04] <strcat> you could do failure with setjmp/longjmp, right?
[22:57:18] <pcwalton> well, C++ throw is better because it runs destructors
[22:57:24] <pcwalton> but as far as sprocketnes is concerned abort() is fine
[22:57:54] <pcwalton> I should say, *NES* emulation is single-threaded
[22:58:12] <pcwalton> has to be cycle accurate and there would be way too much locking to synchronize if you tried to make it a multithreaded NES emulator
[22:58:50] <doomlord_> i see "C++ backend" listed alongside CPU architectures in llc --version, i thought that would be LLVMIR->C++ .. however i can't get that to work :(
[22:59:09] <pcwalton> C++ means "the C++ necessary to reconstruct the LLVM IR"
[22:59:14] <pcwalton> it's not the C++ necessary to run the IR
[22:59:16] <pcwalton> it's a terrible name
[22:59:32] <Jesse> pcwalton: how much overhead does the runtime add to a program like the NES emulator that "isn't using" any runtime features?
[22:59:43] <pcwalton> Jesse: almost none
[22:59:45] <pcwalton> it's just for purism
[23:00:00] <doomlord_> should i just give up on this
[23:00:04] <pcwalton> it's a nice experiment for minimalist purity, I doubt it buys much
[23:00:18] <pcwalton> doomlord_: I think it is better to try to make Rust output native iOS binaries
[23:00:39] <pcwalton> using the arm-apple-darwin target
[23:00:40] <strcat> pcwalton: you need the runtime for the rng, right?
[23:00:57] <pcwalton> strcat: didn't the pure-rust isaac land?
[23:01:13] <strcat> pcwalton: there's a task-local rng though
[23:01:32] <strcat> every rust binary reads /dev/urandom
[23:01:32] <pcwalton> strcat: task-local whatevers can be handled with TLS or even globals in a freestanding rust
[23:01:42] <strcat> ah
[23:02:06] <pcwalton> I think the idea of being "runtimeless" is mostly just marketing honestly
[23:02:11] <pcwalton> even C is not runtimeless
[23:02:28] <pcwalton> C has facilities that, for example, the ARM processor does not provide
[23:02:32] <pcwalton> namely integer division
[23:02:35] <doomlord_> to run on iOS it must be a mixed language project - the main program is always apple's objectiveC
[23:02:37] <pcwalton> so it requires... a runtime!
[23:03:16] <doomlord_> at the minute to get my C++ sourcebase onto iOS, i just have a minimalist ObjC program that calls various entry points in my C++ code
[23:03:23] <pcwalton> ah
[23:03:38] <pcwalton> maybe it's best to output the .s and slurp the resulting .s file into Xcode?
[23:03:48] <doomlord_> so I dont actually need a program that *runs*, just something i can patch into the same stub
[23:04:06] <pcwalton> if you can output a .s with -S you could just drag the .s into Xcode
[23:04:07] <doomlord_> "output the .s" ...yeah this is an approach i've already tried: it looked promising
[23:04:30] <doomlord_> the sticking point was i was using the existing *android eabi* to get ARM asm... which xcode doesn't like
[23:04:39] <doomlord_> its got directives associated with a different ABI
[23:04:45] <pcwalton> yeah, you would need to write a new Rust target
[23:04:49] <pcwalton> to emit arm-apple-darwin
[23:04:54] <pcwalton> I don't think it would be that hard
[23:04:57] <pcwalton> but you'll have to hack the compiler
[23:05:11] <pcwalton> I think you will have to hack the compiler a bit
[23:05:24] <doomlord_> yeah this worries me, it *DOES* interest me to delve into the compiler but jumping into a large sourcebase is always daunting
[23:05:33] <pcwalton> yeah, the Rust compiler isn't the easiest
[23:05:36] <pcwalton> feel free to ask questions though
[23:05:47] *** Joins: z0w0 (zack@moz-A9182BA0.lns8.woo.bigpond.net.au)
[23:05:50] <doomlord_> i have been reading it a bit recently
[23:06:06] <pcwalton> I would love a port to iOS certainly, any and all patches are welcome!
[23:06:46] *** Joins: devbug (quassel@moz-E1DE087C.bchsia.telus.net)
[23:06:53] <doomlord_> i'm debating with myself, should i start a project to translate a subset of rust to C.. (as a compiler patch). but that sounds harder than adding the support
[23:07:07] <pcwalton> yes, that would be harder I suspect.
[23:07:33] <doomlord_> PS VIta is a platform i've worked with recently too. Just from experience, I have faith in C's ability to find its way anywhere
[23:08:10] <doomlord_> rust would be a fantastic C generator as an alternative to C++, I like everything about it.
[23:08:19] <Luqman> hmm how much of the split stack support that was added to llvm is android specific?
[23:09:37] *** Joins: erickt (erickt@8C9ECD8F.3A598286.F12515B4.IP)
[23:10:07] <doomlord_> hazy on some details here - specifically what didn't assemble on iOS was directives that i'm told are to do with exception handling support
[23:10:09] *** Quits: jgilbert (jgilbert@2557E599.66715431.D25A875A.IP) (Quit: Leaving)
[23:10:22] <doomlord_> it could be all I need to do is *disable* something in rustc , for an aditional path
[23:11:31] <indutny> do you guys have in plans using real GC for @ pointers?
[23:11:50] <jld> The one thing I know about the segmented stack support we're using on ARM is that it's apparently not the segmented stack support that's been in the ARM Procedure Call Standard since the 1980s.
[23:12:12] <pcwalton> indutny: graydon has a WIP patch to do that
[23:12:28] <indutny> great!
[23:12:39] <graydon> indutny: process of landing. unfortunately many many things competing for my time :(
[23:12:42] <indutny> graydon: what type of GC you implemnted?
[23:12:46] <graydon> should come in this release cycle
[23:12:48] <graydon> a terrible one
[23:12:50] <indutny> haha
[23:12:59] <indutny> well, generational/mark-sweep/copying?
[23:13:02] <graydon> non-moving, stop-the-task (not the world, thankfully), mark/sweep
[23:13:09] <indutny> oh
[23:13:18] <graydon> conservative, also
[23:13:22] <indutny> I got it
[23:13:23] <graydon> (as though that's not bad enough!)
[23:13:28] <graydon> I said terrible, I meant it :(
[23:13:32] <indutny> haha :)
[23:13:38] <indutny> well, its terrible that it is non-moving
[23:13:39] <graydon> better ones will be ... future work between now and production-ready
[23:13:45] <strcat> graydon: just with pointers on the stack or completely conservative?
[23:14:02] <graydon> this round is completely conservative
[23:14:10] <graydon> later version will be precise in the heap
[23:14:20] <indutny> graydon: are you working at mozilla?
[23:14:25] <graydon> yes
[23:14:29] <indutny> ok, good to know
[23:14:51] <indutny> btw, what strategy are you using for mark-sweep's freelist?
[23:14:54] <indutny> (just curious)
[23:15:56] * jld reads about how ARM does TLS, and, um.  "bl __tls_get_addr"?  Ew.
[23:16:12] *** Quits: erickt (erickt@8C9ECD8F.3A598286.F12515B4.IP) (Quit: Leaving.)
[23:16:26] <graydon> indutny: we are layered on top of malloc still, so it does the freelist
[23:16:35] <indutny> ah
[23:16:40] <strcat> tjc: could you make changing the dir use RAII? let cwd = cd_lock("foo"); /* release global lock with destructor */
[23:16:40] <graydon> indutny: allocation tracking is (currently) done redundantly in two structures, which is _totally_ absurd
[23:16:43] <strcat> tjc: maybe a silly idea
[23:16:45] <graydon> (a linked list and a digital trie)
[23:16:45] <indutny> :)
[23:16:51] <indutny> haha
[23:16:52] <graydon> we have to do things step-by-step unfortunately
[23:16:54] <tjc> strcat: hmm, interesting idea
[23:16:56] <tjc> maybe!
[23:17:01] <strcat> tjc: and it could pop the dir off
[23:17:01] <indutny> graydon: sure, that's good stuff
[23:17:05] <strcat> tjc: and go back
[23:17:08] <indutny> interesting enough
[23:17:11] <tjc> strcat: yeah, that'll be cool if it works
[23:17:16] <tjc> also, changing it to with_env_lock appears to have caused a deadlockâ€¦ *sigh*
[23:17:22] <indutny> I'm working on a JIT compiler written in rust
[23:17:22] <graydon> the amount of overhead in the current scheme almost defies reason, but there was a path here and in any case, here is where we are for planning forward movement
[23:17:24] <indutny> (just started)
[23:17:37] <indutny> and I'll implement GC for it
[23:17:59] <indutny> though, heap in this language is immutable
[23:18:08] <indutny> but it could be still useful
[23:18:16] <indutny> ah, nvm
[23:18:18] <indutny> it'll be moving
[23:18:29] *** Quits: an0nymous (an0nymous@moz-FF0B8E6D.ipredator.se) (Client exited)
[23:19:46] <strcat> brson: btw libuv currently isn't being compiled with optimizations, I'll open a bug
[23:19:51] * strcat noticed because of  #  warning _FORTIFY_SOURCE requires compiling with optimization (-O)
[23:20:28] <strcat> I guess CFLAGS has to be passes somewhere in the makefile
[23:20:31] <strcat> passed*
[23:20:41] <doomlord_> http://developer.apple.com/library/ios/#documentation/Xcode/Conceptual/iPhoneOSABIReference/Articles/ARMv6FunctionCallingConventions.html
[23:21:50] <doomlord_> iOS uses 'AAPCS with some minor moditications' ..
[23:21:51] <strcat> rustc: /build/src/rust/src/rt/rust_run_program.cpp:205: RunProgramResult rust_run_program(const char**, void*, const char*, int, int, int): Assertion `!result && "chdir failed"' failed.
[23:21:53] <strcat> /bin/sh: line 1: 21483 Segmentation fault      i686-unknown-linux-gnu/stage1/bin/rustc --cfg stage1 -O --target=i686-unknown-linux-gnu -o i686-unknown-linux-gnu/stage1/lib/rustc/i686-unknown-linux-gnu/lib/libcore.so /build/src/rust/src/libcore/core.rc
[23:21:55] <strcat> huh.
[23:21:59] <strcat> I don't think rust builds at all in a chroot anymore :(
[23:22:41] <jld> "Updating R7 in this way gives the debugger a way to find previous stack frames." -- Only if it knows the set of register that were saved, in which case it can just do full unwinding and there's no point burning a register like that.  Sigh.
[23:23:08] <jld> ...wait a minute.  R7 := SP before the other registers are saved?
[23:24:37] <strcat> well at least it's obvious where it fails...
[23:26:02] *** Quits: int3_ (int3_@moz-359A42F6.subnet-248.amherst.edu) (Client exited)
[23:27:05] <jld> Well, maybe the iOS compiler does that, but GCC 4.4.3 configured for arm-linux-androideabi definitely does the not-so-helpful thing I described.
[23:27:26] * jld has spent a nontrivial part of the past 2.5 months at work investigating stack unwinding on ARM....
[23:28:46] *** Joins: an0nymous (an0nymous@moz-8688491.privacyrepublic.org)
[23:29:09] <doomlord_> jld, are you after something similar
[23:30:05] <jld> doomlord_: No; I've been working on getting useful profiling data on Firefox OS (which is, in terms of the toolchain and basic userland, based on Android).
[23:30:59] <brson> strcat: that is an error specific to i686 in stage0
[23:31:16] <brson> strcat: It should be fixed by a snapshot
[23:31:34] <strcat> brson: so it's a consistent error, or only happens sometimes?
[23:31:57] <brson> consistent
[23:32:07] <strcat> alright I won't worry about it :)
[23:32:38] <strcat> just setting up an Arch repo with nightly builds of incoming
[23:32:50] <strcat> I guess not many people use i686 :)
[23:32:59] *** Joins: erickt (erickt@8C9ECD8F.3A598286.F12515B4.IP)
[23:34:13] <doomlord_> does LLVM IR include the calling convention r.e. registers vs stack, i thought LLVM worked as if it had "infinite registers",
[23:34:50] <strcat> functions are annotated with a calling convention
[23:35:03] <strcat> and it can use whatever it wants for internal calls
[23:36:52] *** Quits: true_droid (Adium@moz-123FD9B8.beck.volia.net) (Quit: Leaving.)
[23:37:51] <EXetoC> strcat: great. can I trust you though? it won't do rm -rf /, right?
[23:38:28] <strcat> EXetoC: well I'm an Arch TU already so if you're an Arch user you already trust me ;p
[23:38:35] <strcat> http://pkgbuild.com/~thestinger/repo/ it will be there
[23:38:40] <EXetoC> o :>
[23:39:18] *** Quits: pcdummy (quassel@moz-CF4CA865.page4me.ch) (Client exited)
[23:39:56] *** Joins: pcdummy (quassel@moz-CF4CA865.page4me.ch)
[23:40:15] *** Quits: ysuzuki (ysuzuki@moz-60FA9D06.net119083145.t-com.ne.jp) (Client exited)
[23:41:06] *** Joins: int3_ (int3_@moz-359A42F6.subnet-248.amherst.edu)
[23:41:26] *** Quits: jeff (jeff@moz-A18F84B1.nycmny.fios.verizon.net) (Quit: jeff)
[23:41:27] * strcat will try not to pull a bumblebee and rm -rf / ;p
[23:43:45] <strcat> oh bumblebee only did rm -rf /usr :)
[23:47:05] *** Joins: ghrust (ghrust@moz-4EF5B6E5.rs.github.com)
[23:47:05] <ghrust> 01[13rust01] 15bors merged 06auto into 06incoming: 02http://git.io/pARTYQ
[23:47:05] *** Parts: ghrust (ghrust@moz-4EF5B6E5.rs.github.com) ()
[23:47:45] <EXetoC> that's bloody stupid innit :p
[23:49:06] *** Quits: erickt (erickt@8C9ECD8F.3A598286.F12515B4.IP) (Quit: Leaving.)
[23:49:18] *** Quits: RageOfThou (RageOfThou@moz-CF7139ED.dynamic.telemach.ba) (Ping timeout)
[23:49:52] <engla> spring cleaning: rm *
[23:50:04] *** Joins: ghrust (ghrust@moz-4EF5B6E5.rs.github.com)
[23:50:04] <ghrust> 01[13rust01] 15bors pushed 0 new commits to 06auto: 02http://git.io/XJe7VQ
[23:50:04] *** Parts: ghrust (ghrust@moz-4EF5B6E5.rs.github.com) ()
[23:50:05] *** Joins: ghrust (ghrust@moz-4EF5B6E5.rs.github.com)
[23:50:05] <ghrust> 01[13rust01] 15bors pushed 3 new commits to 06auto: 02http://git.io/0quJHw
[23:50:05] <ghrust> 13rust/06auto 1400ce4a4 15Jesse Luehrs: libc bindings for glob.h...
[23:50:05] <ghrust> 13rust/06auto 144cbcf54 15Jesse Luehrs: add a higher level glob() function to os...
[23:50:06] <ghrust> 13rust/06auto 14bf94985 15bors: auto merge of #5832 : doy/rust/glob, r=graydon...
[23:50:08] *** Parts: ghrust (ghrust@moz-4EF5B6E5.rs.github.com) ()
[23:50:14] <brson> ok, I think we've upgraded llvm again.
[23:50:17] <brson> time to try another snapshot
[23:50:22] <graydon> \o/
[23:50:32] <bstrie> engla: that sort of thing should be a cron job. automatically rm / every march 21
[23:50:37] <graydon> (what was it for this time?)
[23:50:47] * strcat wonders how package signing is supposed to work with a cronjob
[23:50:51] <strcat> I guess you just don't do it
[23:51:18] <brson> graydon: we accidentally downgraded llvm :(
[23:51:22] <brson> graydon: so just treading water
[23:51:38] <graydon> oh gosh
[23:52:02] <graydon> strcat: you trust cron, don't you?
[23:52:12] <brson> and there are more llvm upgrades in the pipeline
[23:52:26] * graydon trusts cron more than any other program. it's a survivor!
[23:52:41] <strcat> graydon: I'm not putting my gpg key on a build server other people use ;p
[23:52:52] <strcat> usually you copy it back to your computer to sign it
[23:53:26] <graydon> I think it is the first unix program I ever learned, after someone gave me access to a unix machine I was a teenager and was very excited by this 'cron' program I'd read about in "the cuckoo's egg"
[23:54:13] <graydon> that and emacs. but I had something _like_ that already, in microemacs..
[23:54:14] <jclements> the cuckoo's egg! I was working in San Jose that year, I think.  But thenâ€¦ I think I read it late.
[23:54:38] <jclements> yep. four years late.
[23:55:07] <strcat> my attempts at cron jobs always fail
[23:55:17] <strcat> so many things manage to only work in a tty
[23:55:30] <graydon> strcat: you need cron to send you an otp request through sms. look in your wallet for the next code and text it back. voila.
[23:55:31] <graydon> what could go wrong?
[23:55:51] <graydon> cron will survive the end of the world
[23:55:58] <tjc> you lose your wallet
[23:56:14] <strcat> cron decides to betray me and signs something else
[23:56:58] <graydon> jclements: did you work for tymnet?
[23:57:49] <jclements> :)
[23:58:50] <graydon> http://telehack.com if you dare. only after you go home and aren't supposed to be getting any actual work done.
[23:58:57] <strcat> http://ix.io/5qe terrible hack for running things in cron that need a tty ;p
[23:59:21] <jclements> graydon: I'll try to remember thatâ€¦ erm, without clicking on itâ€¦ somehow.
[23:59:53] <graydon> jclements: if you haven't seen it now, you should read the summary first at least; it's worth it for the jaw-drop
[23:59:53] <jld> Ah, cron.  Always fun when a user accidentally sets something expensive to run every minute.
[23:59:59] <strcat> graydon: timer units are going to kill cron though :)

[00:00:21] <cmr> Well all uniquely-owned objects must be sendable.
[00:00:40] <cmr> They are ~-ptrs, a main point is that they are sendable
[00:01:38] <ssbr_> I don't care about that, I care about mutating some state shared between multiple things
[00:02:02] <ssbr_> I was trying to work out some way of doing this without pervasive use of managed pointers, but that doesn't seem possible
[00:02:12] <ssbr_> without something really silly like using indexes to simulate pointers
[00:02:44] *** Quits: acrichto (acrichto@moz-B63D64BD.res.cmu.edu) (Quit: Reconnecting)
[00:02:48] *** Joins: acrichto (acrichto@moz-B63D64BD.res.cmu.edu)
[00:02:55] *** Joins: strcat (strcat@moz-54F7FD49.cpe.net.cable.rogers.com)
[00:03:27] <strcat> heh
[00:03:34] <strcat> it's just because lxc doesn't know about block_suspend
[00:03:41] *** Joins: rusti (rusti@moz-54F7FD49.cpe.net.cable.rogers.com)
[00:03:46] <strcat> rusti: 5
[00:03:47] -rusti- 5
[00:10:03] *** Quits: mcomella (mcomella@moz-B10FF54F.ri.ri.cox.net) (Connection reset by peer)
[00:10:05] <cmr> Is it natural that check-stage1 can pass while check fails, and vice-versa?
[00:10:34] *** Joins: mcomella (mcomella@moz-B10FF54F.ri.ri.cox.net)
[00:11:15] <bjz> cmr: sometimes if you alter something, it won't pass stage0
[00:11:47] <bjz> cmr: that's because it's building stage0 from an older version of rust
[00:11:52] <bjz> (I think)
[00:12:41] <bjz> if you run into that problem, you can use #[cfg(stage0)] and #[cfg(not(stage0))] respectively
[00:13:15] <cmr> well it's not the problem of not building, it's that tests fail or pass at different stages.
[00:13:39] <cmr> and isn't stage1 supposed to be the built current-source?
[00:14:58] <bjz> strcat brson: odd: http://buildbot.rust-lang.org/builders/auto-linux/builds/1320/steps/test/logs/stdio
[00:15:11] *** Joins: ghrust (ghrust@moz-4EF5B6E5.rs.github.com)
[00:15:11] <ghrust> 01[13rust01] 15bors 04force-pushed 06auto from 145955670 to 143a323c1: 02http://git.io/N3iJvQ
[00:15:11] *** Parts: ghrust (ghrust@moz-4EF5B6E5.rs.github.com) ()
[00:15:13] *** Joins: ghrust (ghrust@moz-4EF5B6E5.rs.github.com)
[00:15:13] <ghrust> 01[13rust01] 15bors pushed 4 new commits to 06auto: 02http://git.io/WayQvw
[00:15:13] <ghrust> 13rust/06auto 14d73f31b 15Brendan Zabarauskas: Create Char trait
[00:15:13] <ghrust> 13rust/06auto 14efe6564 15Brendan Zabarauskas: Code modernisation and cleanup
[00:15:13] <ghrust> 13rust/06auto 14f687b9d 15Brendan Zabarauskas: Use `///` style doc-comments and add missing headings
[00:15:15] <bjz> 'error: multiple matching crates for `pub_use_xcrate2`
[00:15:15] *** Parts: ghrust (ghrust@moz-4EF5B6E5.rs.github.com) ()
[00:16:05] <strcat> oh that's not good, I hope the crate hash didn't become non-deterministic again
[00:16:19] <cmr> I encountered an error like that earlier today too
[00:19:35] <bjz> https://github.com/mozilla/rust/pull/6595#issuecomment-18110215
[00:19:51] <bjz> only on linux
[00:21:12] *** Joins: steven_is_false (user@moz-144077DE.bchsia.telus.net)
[00:21:43] <steven_is_false> Hi! I was wondering if this was a bug or not. ~fn () does not seem to be coercable to ~fn :Owned ().
[00:23:25] *** Quits: ldlework (ldlework@moz-EE947065.static.cloud-ips.com) (Ping timeout)
[00:26:48] *** Joins: tav (tav@moz-B2B8B585.zone7.bethere.co.uk)
[00:27:10] *** Joins: ldlework (ldlework@6AEB83D1.B92A0FC.176AC772.IP)
[00:27:26] <brson> I didn't even know that the ~fn:Owned syntax had landed
[00:27:47] <steven_is_false> brson: Yes it's quite new.
[00:28:07] *** Quits: tgt (tgt@moz-D59EE478.aztw.cable.virginmedia.com) (Quit: Computer has gone to sleep.)
[00:28:43] <cmr> Does sendable closures mean the stack can't be noexec?
[00:28:53] <cmr> or, rather, heap
[00:29:03] <steven_is_false> brson: It seems to be an issue, I can create the following method fn coerce <A, B> (f : ~fn (A) -> B) -> ~fn :Owned (A) -> B { |x| { f (x) } }
[00:29:42] *** Joins: dbaupp (Thunderbir@moz-856B3C14.lns20.syd6.internode.on.net)
[00:31:54] <bjz> brson: any clue about this error? https://github.com/mozilla/rust/pull/6595#issuecomment-18110215
[00:34:56] <cmr> steven_is_false: nmatsakis is probably the person to ask
[00:35:53] <steven_is_false> cmr: Okay but I'm actually pretty sure now that this is a bug. After all, the coerce function is creatable.
[00:36:09] *** Joins: RMF (RMF@moz-AE71C4DD.dsl.telepac.pt)
[00:36:35] *** Parts: steven_is_false (user@moz-144077DE.bchsia.telus.net) (ERC Version 5.3 (IRC client for Emacs))
[00:38:19] <brson> cmr: rust closures don't emit any executable code at runtime
[00:38:21] *** Quits: oyiptong (oyiptong@CD2A94.29EC3FEB.F9E1BAE1.IP) (Ping timeout)
[00:39:33] <cmr> brson: So ~fn has no relation to a ~T?
[00:41:09] *** Quits: igl (igl@moz-BFEB022D.adsl.alicedsl.de) (Ping timeout)
[00:41:17] <cmr> meh, I don't know enough about closures
[00:42:04] *** Joins: oyiptong (oyiptong@CD2A94.29EC3FEB.F9E1BAE1.IP)
[00:42:33] *** Joins: igl (igl@moz-83E3CF92.adsl.alicedsl.de)
[00:42:46] <brson> cmr: maybe I don't understand the question. ~fn is like a pair of (~env, *fnptr), where the function pointer is just a standard static function
[00:43:04] <brson> in some languages closures actually emit a new function that contains the environment in th efunction text
[00:43:07] <brson> go does that
[00:43:10] <brson> but rust does not
[00:43:25] <brson> if we did, then you would have to execute arbitrary parts of the heap
[00:43:45] *** Joins: sp3d (a@moz-49806493.dhcp.stls.mo.charter.com)
[00:43:57] *** Quits: oyiptong (oyiptong@CD2A94.29EC3FEB.F9E1BAE1.IP) (Ping timeout)
[00:46:22] *** Joins: samnardoni (samnardoni@moz-ECB14881.cable.virginmedia.com)
[00:47:02] *** Joins: oyiptong (oyiptong@CD2A94.29EC3FEB.F9E1BAE1.IP)
[00:48:16] *** Quits: samnardoni (samnardoni@moz-ECB14881.cable.virginmedia.com) (Ping timeout)
[00:49:07] *** Joins: maxli (maxli@C03F2759.C70D537E.2FA4EA88.IP)
[00:56:03] *** Quits: vosen (vosen@moz-266BA656.icpnet.pl) (Quit: Leaving)
[00:58:22] <dbaupp> bjz: I just realised something... the if a1 < b1 { true } else { a2 < b2 } thing is incorrect for lexical ordering
[01:02:31] *** Joins: davbo (dave@moz-E2C65EB0.zone11.bethere.co.uk)
[01:04:10] <strcat> bjz: because it can be greater
[01:04:14] <strcat> dbaupp: *
[01:04:22] <strcat> did that pull req go through? :(
[01:04:56] <dbaupp> strcat: yup... you can have s < t and t < s, which would be pretty confusing
[01:04:58] <dbaupp> strcat: nope
[01:06:13] *** Joins: ghrust (ghrust@moz-4EF5B6E5.rs.github.com)
[01:06:13] <ghrust> 01[13rust01] 15bors merged 06auto into 06incoming: 02http://git.io/WayQvw
[01:06:13] *** Parts: ghrust (ghrust@moz-4EF5B6E5.rs.github.com) ()
[01:06:43] <cmr> bjz: weird... did you do anything at all to fix that error?
[01:07:40] <dbaupp> cmr: that error was what strcat and I suggested he should do... oops :(
[01:07:55] <cmr> Talking about the error on the PR that just landed
[01:08:04] <dbaupp> oh
[01:11:10] *** Quits: acrichto (acrichto@moz-B63D64BD.res.cmu.edu) (Input/output error)
[01:15:56] *** Joins: dherman (dherman@moz-6CA476B1.hsd1.ca.comcast.net)
[01:15:56] *** ChanServ sets mode: +o dherman
[01:19:11] *** Joins: acrichto (acrichto@moz-B63D64BD.res.cmu.edu)
[01:19:13] *** Quits: MrFahrenheit (RageOfThou@3FEF494C.29C984D5.783DEDCA.IP) (Ping timeout)
[01:20:12] *** Joins: hjr3 (hradtke@AF4FC8FE.D2A4E84D.523CBD62.IP)
[01:29:18] *** Quits: BitPuffin (quassel@moz-8370D1B9.bredband.comhem.se) (Client exited)
[01:33:11] *** Quits: wilsonk-laptop (kvirc@moz-39EFBFC2.cg.shawcable.net) (Ping timeout)
[01:34:29] *** Quits: hjr3 (hradtke@AF4FC8FE.D2A4E84D.523CBD62.IP) (Quit: My MacBook has gone to sleep. ZZZzzzâ€¦)
[01:39:10] *** Joins: ghrust (ghrust@moz-4EF5B6E5.rs.github.com)
[01:39:10] <ghrust> 01[13rust01] 15bors pushed 0 new commits to 06auto: 02http://git.io/pXN1Ew
[01:39:10] *** Parts: ghrust (ghrust@moz-4EF5B6E5.rs.github.com) ()
[01:39:13] *** Joins: ghrust (ghrust@moz-4EF5B6E5.rs.github.com)
[01:39:13] <ghrust> 01[13rust01] 15bors pushed 59 new commits to 06auto: 02http://git.io/oHs-Ww
[01:39:13] <ghrust> 13rust/06auto 1434be071 15Brian Anderson: core::rt: Remove Close trait...
[01:39:13] <ghrust> 13rust/06auto 140b4d4ed 15Brian Anderson: core::rt: Fix a warning about unnecessary mutable variable
[01:39:13] <ghrust> 13rust/06auto 14b2fbd34 15Brian Anderson: core::rt: Begin implementing TcpStream...
[01:39:16] *** Parts: ghrust (ghrust@moz-4EF5B6E5.rs.github.com) ()
[01:40:28] *** Joins: samnardoni (samnardoni@moz-ECB14881.cable.virginmedia.com)
[01:46:45] *** Quits: samnardoni (samnardoni@moz-ECB14881.cable.virginmedia.com) (Ping timeout)
[01:47:00] <cmr> brson: congratulations!
[01:47:05] <cmr> brson: will it actually land? ;)
[01:47:30] *** cscottnet_away is now known as cscottnet
[01:51:34] *** Quits: KindOne (KindOne@moz-491499D.dynamic.ip.windstream.net) (Ping timeout)
[01:54:09] *** Quits: davbo (dave@moz-E2C65EB0.zone11.bethere.co.uk) (Client exited)
[01:55:28] *** Joins: KindOne (KindOne@29275653.D1A4D0AD.EC6A1518.IP)
[01:56:13] *** Joins: hjr3 (hradtke@AF4FC8FE.D2A4E84D.523CBD62.IP)
[01:58:14] *** Quits: a_m0d (a_m0d@moz-9F925EFA.hm.shawcable.net) (Quit: Leaving.)
[01:58:15] *** Joins: z0w0 (zack@moz-780F7535.lns9.cha.bigpond.net.au)
[01:59:46] *** Quits: hjr3 (hradtke@AF4FC8FE.D2A4E84D.523CBD62.IP) (Quit: My MacBook has gone to sleep. ZZZzzzâ€¦)
[02:00:54] *** Quits: Palmik (palmik@moz-DADC71F0.pks.muni.cz) (Quit: Lost terminal)
[02:02:35] *** Quits: bbrittain (ben@moz-A7CDB794.dia.static.qwest.net) (Ping timeout)
[02:05:05] <cmr> r? https://github.com/mozilla/rust/pull/6601
[02:05:24] <cmr> dbaupp: not quite by lunchtime ;)
[02:05:40] <cmr> underestimated length of compile-edit-test cycle
[02:06:34] <bjz> dbaupp: we'll have add some unit-tests for that mcro
[02:06:44] <bjz> dbaupp: I was lazy
[02:08:03] <brson> cmr: I'm crossing my fingers
[02:08:34] <bjz> dbaupp: would you be able to nock some up for me quickly, seeing as you have more of an idea what you're doing?
[02:09:20] *** Quits: maxli (maxli@C03F2759.C70D537E.2FA4EA88.IP) (Connection reset by peer)
[02:09:26] *** Joins: maxli (maxli@C03F2759.C70D537E.2FA4EA88.IP)
[02:11:48] *** Quits: maxli (maxli@C03F2759.C70D537E.2FA4EA88.IP) (Connection reset by peer)
[02:11:56] *** Joins: maxli (maxli@C03F2759.C70D537E.2FA4EA88.IP)
[02:13:58] *** Joins: wilsonk-laptop (kvirc@moz-39EFBFC2.cg.shawcable.net)
[02:28:45] *** Joins: steven_is_false (user@moz-144077DE.bchsia.telus.net)
[02:29:57] <steven_is_false> Does anyone know here some *Nix-fu for sorting a table by it's first column? I passed in -Z data-type-sizes to the rust compiler, and want to see if there's any suspicious structures.
[02:31:06] <steven_is_false> I'm checking the rust build.
[02:32:37] <bblum> sort -n
[02:33:15] *** Joins: bbrittain (ben@moz-A7CDB794.dia.static.qwest.net)
[02:33:55] <steven_is_false> bblum: Thanks. I'll use sort -n | uniq though.
[02:33:57] *** Quits: q66 (q66@6EE9DE40.46454B5D.33AABD5F.IP) (Client exited)
[02:34:47] <bblum> uniq -c is great too
[02:34:56] <steven_is_false> Hmm... Do any of the following look suspicious? 2064	rand::IsaacRng
[02:34:56] <steven_is_false> 2064	core::rand::IsaacRng
[02:34:56] <steven_is_false> 1248	middle::resolve::Resolver
[02:34:56] <steven_is_false> 1208	rustc::middle::ty::ctxt_
[02:34:59] <steven_is_false> 1208	middle::ty::ctxt_
[02:35:02] <steven_is_false> 1200	middle::resolve::Resolver
[02:35:05] <steven_is_false> 1024	[u32, .. 256]
[02:35:09] <steven_is_false> 944	middle::lang_items::LanguageItemCollector
[02:35:12] <steven_is_false> 888	middle::lang_items::LanguageItems
[02:35:14] <steven_is_false> 888	[core::option::Option<syntax::ast::def_id>, .. 37]
[02:35:18] <steven_is_false>  
[02:36:16] <strcat> steven_is_false: what is that from?
[02:36:43] <steven_is_false> stcat: make RUSTFLAGS='-Z data-type-sizes' | sort -nr | uniq
[02:36:47] <strcat> oh
[02:36:52] <steven_is_false> *In the rust source
[02:38:34] <steven_is_false> What are the @? types in the -Z data-type-sizes output?
[02:39:11] *** Joins: ghrust (ghrust@moz-4EF5B6E5.rs.github.com)
[02:39:11] <ghrust> 01[13rust01] 15bors merged 06auto into 06incoming: 02http://git.io/oHs-Ww
[02:39:11] *** Parts: ghrust (ghrust@moz-4EF5B6E5.rs.github.com) ()
[02:39:37] *** Quits: maxli (maxli@C03F2759.C70D537E.2FA4EA88.IP) (Quit: Leaving.)
[02:40:45] *** Quits: engla_ (engla@moz-DBD1D96E.cust.bredbandsbolaget.se) (Ping timeout)
[02:40:47] <steven_is_false> Is there a way to cut off data-types below a certain size in the output? Also, what size should I cut it off at?
[02:42:10] *** Joins: ghrust (ghrust@moz-4EF5B6E5.rs.github.com)
[02:42:10] <ghrust> 01[13rust01] 15bors pushed 0 new commits to 06auto: 02http://git.io/Ub1fbw
[02:42:10] *** Parts: ghrust (ghrust@moz-4EF5B6E5.rs.github.com) ()
[02:42:11] *** Joins: ghrust (ghrust@moz-4EF5B6E5.rs.github.com)
[02:42:11] <ghrust> 01[13rust01] 15bors pushed 7 new commits to 06auto: 02http://git.io/PgwLMA
[02:42:11] <ghrust> 13rust/06auto 14a9c465c 15Daniel Micay: iterator: remove `first`...
[02:42:11] <ghrust> 13rust/06auto 14ea8a55b 15Daniel Micay: iterator: make nth and last return Option...
[02:42:12] <ghrust> 13rust/06auto 14883d583 15Daniel Micay: iterator: reuse iter::to_vec, and use &mut self
[02:42:14] *** Parts: ghrust (ghrust@moz-4EF5B6E5.rs.github.com) ()
[02:42:29] <EXetoC> yay more bits
[02:43:03] <EXetoC> fewer bits actually. dang!
[02:43:23] <steven_is_false> Would anyone be interested in the top biggest data types?
[02:43:36] <EXetoC> ya
[02:43:36] *** Joins: engla (engla@moz-DBD1D96E.cust.bredbandsbolaget.se)
[02:44:14] <steven_is_false> EXetoC: I'm not sure what's the best way to distribute this. Besides it is simple for other people to gather this data as well.
[02:44:35] *** Quits: jack (jack@moz-F1B36F9F.hsd1.nm.comcast.net) (Quit: Leaving.)
[02:45:05] *** Joins: anshin (nbs@441B8B9E.2055B963.D2A6B5.IP)
[02:45:17] <EXetoC> ok. nevermind, gotta go. almost 5 AM here -.-
[02:45:35] <steven_is_false> EXetoC: okay, see ya later.
[02:46:18] <EXetoC> c(:)
[02:46:19] *** Quits: EXetoC (ex@moz-2DBEB1E4.customer.t3.se) (Quit: WeeChat 0.4.0)
[02:50:35] *** Quits: kimundi (kimundi@moz-1611DF1A.dip0.t-ipconnect.de) (Ping timeout)
[02:53:56] *** Joins: kimundi (kimundi@moz-2812E1B9.dip0.t-ipconnect.de)
[02:56:23] *** kimundi is now known as zz_kimundi
[03:03:06] <steven_is_false> Should I implement Clone, or only DeepClone?
[03:03:35] <steven_is_false> Or should I implement both?
[03:05:52] *** Joins: catpigger (catpig@moz-2864D03.dip0.t-ipconnect.de)
[03:06:53] *** Quits: catpig (catpig@moz-E824D416.dip0.t-ipconnect.de) (Ping timeout)
[03:07:46] <strcat> steven_is_false: for what?
[03:07:52] <strcat> you can just derive both
[03:08:03] <steven_is_false> strcat: Not for fixed sized arrays unfortunately.
[03:08:45] <steven_is_false> strcat: I'm making large structures like IsaacRng not copyable by default (only by clone) so that expensive copies aren't made accidentally.
[03:08:56] *** zz_kimundi is now known as kimundi
[03:09:16] <strcat> yes it should have both clone/deepclone
[03:09:42] *** Quits: brson (brson@2557E599.66715431.D25A875A.IP) (Quit: leaving)
[03:10:17] <steven_is_false> strcat: Okay then.
[03:11:40] *** Joins: jack (jack@moz-F1B36F9F.hsd1.nm.comcast.net)
[03:14:47] <steven_is_false> I'm not good at naming stuff. What's a good alternative name to IsaacRngImplementation in struct IsaacRng { priv contents : ~IsaacRngImplementation }?
[03:21:28] <strcat> steven_is_false: I don't think it should be wrapped with a box inside the impl
[03:21:37] <strcat> the caller might want to use @, or Rc
[03:21:45] <steven_is_false> strcat: Your right.
[03:22:10] <strcat> making huge things non-implicitly-copyable would be great though
[03:23:36] <steven_is_false> strcat: okay
[03:24:02] <strcat> rusti: ~[1, ..100000]
[03:24:03] -rusti- line longer than 10000 characters, bailing out
[03:24:12] <strcat> rusti: let xs = ~[1, ..100000];
[03:24:13] -rusti- foo.rs:5:13: 5:15 warning: unused variable: `xs` [-W unused-variable (default)]
[03:24:13] -rusti- foo.rs:5          let xs = ~[1, ..100000];
[03:24:13] -rusti-                       ^~
[03:24:13] -rusti- note: in expansion of fmt!
[03:24:13] -rusti- foo.rs:4:12: 6:7 note: expansion site
[03:24:21] <strcat> rusti: let _xs = ~[1, ..100000000];
[03:24:22] -rusti- /usr/local/bin/rust.sh: line 21:    15 Killed                  ./foo
[03:24:37] <strcat> rusti: let _xs = ~[1, ..10000000];
[03:24:49] <strcat> rusti: let _xs = ~[1, ..100000000];
[03:24:50] -rusti- /usr/local/bin/rust.sh: line 21:    15 Killed                  ./foo
[03:24:59] <strcat> rusti: let _xs = ~[1, ..100000000];
[03:25:21] <strcat> rusti: 2
[03:25:22] -rusti- 2
[03:25:26] <strcat> rusti: let _xs = ~[1, ..100000000];
[03:25:39] * strcat likes cgroups
[03:29:09] *** Joins: samnardoni (samnardoni@moz-ECB14881.cable.virginmedia.com)
[03:30:57] *** Quits: samnardoni (samnardoni@moz-ECB14881.cable.virginmedia.com) (Ping timeout)
[03:32:11] <cscottnet> what's the best practice for comparing a ~str with a static string?  (ie, num == "Infinity" fails, but I'd like to avoid the malloc which ~"Infinity" would produce)
[03:32:40] <strcat> "foo" == bar
[03:32:52] <strcat> or bar.equiv(&"foo")
[03:33:04] <strcat> in generic code you need the latter
[03:33:31] <strcat> cscottnet: Eq uses the same type on each side and it uses the LHS to decide the type
[03:33:35] <strcat> ~str can be borrowed as &str
[03:33:42] <strcat> implicitly
[03:33:58] <strcat> it would be nice if it tried harder and checked the RHS after
[03:34:40] <strcat> cscottnet: and for example there's find_equiv on HashMap
[03:34:59] <strcat> so you can do a lookup with &'static str in a ~str keyed table
[03:35:30] <cscottnet> dbaupp: if you add the "Iterator -> Length method (with `enum Length { Int(uint), Infinite, Unknown }`)" it would be nice to accept a Length in vec::with_capacity(l : Length)
[03:35:42] <cscottnet> ie, Infinite or Unknown would just allocate a vector of the default capacity
[03:35:48] <strcat> cscottnet: we can do that in to_vec
[03:36:13] <strcat> well
[03:36:18] <strcat> I think it will become a from_iterator trait
[03:36:23] <strcat> a static method
[03:36:32] *** Joins: jgilbert (jgilbert@8ACF1000.5EFFC0B8.24454B25.IP)
[03:36:46] <strcat> so you can have from_iterator for sets, vectors, strings, etc.
[03:37:02] <steven_is_false> Ugg, so I'm using magit for emacs, and I need explicitly give what to diff on. So for the start I use HEAD, and for my current changes I use what?
[03:41:15] *** Quits: dherman (dherman@moz-6CA476B1.hsd1.ca.comcast.net) (Quit: dherman)
[03:41:42] <cscottnet> jensnockert/bjz/strcat: "Is there a good reason explained somewhere why f64 != float btw?" -- doesn't x86 still have funky 40-ish bit floats?
[03:42:11] <strcat> cscottnet: x86 has two ways of doing floats
[03:42:36] <strcat> it has the modern SSE support, with explicit support for ieee754 floats/doubles
[03:42:43] <strcat> can do 4 floats at a time or 2 doubles
[03:43:05] <strcat> and there's the legacy x87 80-bit float support (it has to emulate floats/doubles and it's weird)
[03:47:13] <bjz> nmatsakis: ping
[03:51:08] <steven_is_false> Okay why are there two Resolver classes in middle? There's two middle::resolve::Resolver classes, one in resolve.rs, and one in resolve_stage0.rs.
[03:53:54] <steven_is_false> Okay, I'm not too sure of the difference between Clone, and DeepClone.
[03:54:09] *** Joins: ghrust (ghrust@moz-4EF5B6E5.rs.github.com)
[03:54:09] <ghrust> 01[13rust01] 15bors merged 06auto into 06incoming: 02http://git.io/PgwLMA
[03:54:09] *** Parts: ghrust (ghrust@moz-4EF5B6E5.rs.github.com) ()
[03:54:29] <steven_is_false> I think I'm going to hold of on implementing DeepClone, and let other people figure that out.
[03:54:38] <strcat> steven_is_false: it's the same as Clone
[03:54:47] <strcat> you just call deep_clone on the contained elements
[03:54:49] <strcat> instead of calling clone
[03:55:05] <steven_is_false> strcat: In some cases it's exactly the same as Clone though.
[03:55:11] <strcat> steven_is_false: yes
[03:55:12] <dbaupp> steven_is_false: the resolve_stage0.rs is because the current snapshot can't cope with the code in resolve.rs, so on the first stage of bootstraping it uses _stage0, but on the later ones it uses resolve.rs
[03:55:23] <steven_is_false> Also there doesn't seem to be a way to automatically derive DeepClone.
[03:55:26] <strcat> steven_is_false: you call deep_clone on the contained elements, not clone
[03:55:30] <strcat> steven_is_false: there's deriving for it
[03:55:34] <dbaupp> bjz: I'll whip up some unit tests in a bit
[03:55:34] <strcat> it's not in stage0
[03:55:43] <bjz> dbaupp: yay!
[03:55:55] <steven_is_false> strcat: Oh, so I'll have to do it manually then?
[03:56:06] <strcat> steven_is_false: I guess, are you doing Clone via derive?
[03:56:18] <steven_is_false> strcat: Yes.
[03:56:37] <dbaupp> cscottnet: that seems reasonable, although I'm not sure what the best behaviour for vec::with_length(Infinite) would be
[03:57:25] <dbaupp> cscottnet: oh, right, you said that in your next message...
[03:59:48] <strcat> dbaupp: I don't really think we should have Infinite
[04:00:01] <strcat> there's not much you can do with that knowledge
[04:00:06] <dbaupp> cmr: cool patch
[04:00:51] <dbaupp> strcat: I'm not fussed either way
[04:03:15] <steven_is_false> strcat: I'm not sure how to test my changes to make these things not copyable by default. A lot of these structues don't have equality defined so I can't do the obvious if x != x.clone () { fail!
[04:03:46] <strcat> steven_is_false: you can make your own examples for the test
[04:03:54] <strcat> don't have to test existing ones
[04:04:31] <cscottnet> strcat: the reason to allow it in with_capacity, not just to_vec, is to make it easier to write custom filter-ish things.
[04:05:03] <cscottnet> ie, often i know that the length of the input is a good approximation of the output, even if it's not exact.
[04:05:21] <steven_is_false> strcat: I don't understand what you mean.
[04:05:38] <strcat> steven_is_false: why do you need to test it that way on the existing types?
[04:06:06] <steven_is_false> strcat: I'm repeating foo : self.foo.deep_clone() a lot, and it's very easy to make a typo.
[04:06:34] <strcat> I don't really understand why you need to test it on the existing types though
[04:06:39] <strcat> you can make your own types for the tests
[04:06:51] *** Joins: wilsonk|2 (kvirc@moz-39EFBFC2.cg.shawcable.net)
[04:07:11] *** Quits: wilsonk-laptop (kvirc@moz-39EFBFC2.cg.shawcable.net) (Ping timeout)
[04:07:27] <steven_is_false> strcat: But I'm testing the deep_clone operation I made on an existing type.
[04:08:04] <strcat> could you just use deriving? does the impl really need to be there in stage0?
[04:08:44] <steven_is_false> strcat: Apparently, I can't just use deriving for stage0, and I have no idea if clone is the same as deep_clone in this case.
[04:09:11] <strcat> steven_is_false: if it contains generic types it's not the same
[04:09:26] <strcat> because those generic types can have a different Clone/DeepClone impl
[04:09:32] <strcat> as @ and reference counted pointers do
[04:09:58] <steven_is_false> Resolver isn't generic but it does use @ pointers.
[04:10:57] <steven_is_false> Shoot, apparently a lot of members of Resolver don't have a clone trait. Maybe I don't need to implement Clone anyways though.
[04:11:00] <strcat> steven_is_false: if nothing needs a DeepClone impl just don't make one ;p
[04:11:24] <strcat> DeepClone isn't functional that exists with implicit copies or the legacy 'copy'
[04:11:29] <strcat> functionality*
[04:12:00] <steven_is_false> strcat: Yes, it's simpler just not to implement it if there's no need.
[04:12:05] <bjz> dbaupp: if you like you can make the PR
[04:12:17] <bjz> dbaupp: and fix my implementation
[04:12:26] <bjz> strcat: https://github.com/mozilla/rust/pull/6604
[04:12:36] <strcat> bjz: sec
[04:13:01] <strcat> rusti: sys::size_of::<Option<*int>>()
[04:13:03] -rusti- 16
[04:13:16] <strcat> oh I didn't realize that wasn't optimized
[04:13:20] <strcat> rusti: sys::size_of::<Option<~int>>()
[04:13:21] -rusti- 8
[04:13:23] <strcat> rusti: sys::size_of::<Option<@int>>()
[04:13:25] -rusti- 8
[04:13:26] <strcat> rusti: sys::size_of::<Option<&int>>()
[04:13:27] -rusti- 8
[04:13:32] <strcat> oh right
[04:13:34] <strcat> it can't be
[04:13:39] <strcat> nvm :)
[04:13:47] <strcat> since you can have layers of nullable things
[04:14:29] <strcat> bjz: it's not safe though
[04:14:48] <strcat> deref of * is unsafe
[04:14:57] <strcat> can be dangling or just pointing somewhere weird
[04:14:59] <bjz> strcat: I added a comment
[04:16:36] *** Joins: brson (brson@E9CDE21E.991753BB.CA4D1600.IP)
[04:16:37] *** ChanServ sets mode: +o brson
[04:17:38] <bjz> brson: thoughts? https://github.com/mozilla/rust/pull/6604
[04:22:53] *** Quits: SiegeLord (sl@moz-CAF07B4C.hsd1.ma.comcast.net) (Quit: It's a joke. It's all a joke.)
[04:23:16] *** Joins: samnardoni (samnardoni@moz-ECB14881.cable.virginmedia.com)
[04:24:12] <steven_is_false> Is there a way to have the compiler only type check things? That'd speed up development a lot (I mean of course I'd make test everything before I make a pull request but before I do it'd help a lot.)
[04:25:02] *** Quits: samnardoni (samnardoni@moz-ECB14881.cable.virginmedia.com) (Ping timeout)
[04:25:11] *** Quits: jgilbert (jgilbert@8ACF1000.5EFFC0B8.24454B25.IP) (Ping timeout)
[04:27:16] *** Quits: heftig (heftig@moz-47F00EDE.dip0.t-ipconnect.de) (Ping timeout)
[04:27:59] *** Quits: anshin (nbs@441B8B9E.2055B963.D2A6B5.IP) (Quit: Lost terminal)
[04:28:58] <dbaupp> steven_is_false: --no-trans might be faster
[04:29:08] <steven_is_false> dbaupp: Thanks.
[04:29:40] <steven_is_false> Ahh, NonCopyable isn't exactly what I want. What I really want is even more restrictive, and is NonMovable.
[04:29:54] <brson> bjz: it's not safe, being unsafe is useful too
[04:30:23] *** Joins: heftig (heftig@moz-A99044C3.dip0.t-ipconnect.de)
[04:30:41] <brson> bjz: maybe an unsafe function doesn't belong on the Ptr trait though
[04:30:58] <steven_is_false> I think the only way to make a structure nonmoveable would be to add a & pointer to it though.
[04:31:19] <steven_is_false> No that wouldn't work but it's close.
[04:31:25] <brson> oh, unless Ptr means 'UnsafePtr'
[04:32:01] <dbaupp> do ~, @ and & impl Ptr?
[04:32:19] <brson> nope
[04:32:21] <bjz> brson: yeah. I was finding I was doing the 'let x = foo(); if !x.is_null() { Some(...) } else { None }' pattern quite a bit
[04:32:49] <steven_is_false> Unfortunately, I think making a structure nonmoveable by default would require changing the interface to it a whole lot.
[04:33:02] <ssbr_> Is there a way to ask rusti the type of an expression?
[04:33:25] <bjz> brson: foo.to_option().chain(|x| ...) would be nicer
[04:33:42] <brson> bjz: is to_option copying out the T?
[04:33:44] <bjz> brson: but yeah, it might be too difficult with safety
[04:33:55] <brson> bjz: it looks like it to me, but I don't see the Copy bound
[04:34:01] <steven_is_false> For example, instead of a function fn Type::new () -> Type I'd have to have fn Type::new <T> new (&fn (Type) -> T) -> T
[04:34:26] <bjz> brson: maybe that's the black magic going on in the unsafe block
[04:34:47] <bjz> brson: which is another reason to be concerned :)
[04:35:13] <steven_is_false> So what does everybody else think about this nonmoveable idea?
[04:37:11] <strcat> we really don't want to be using more Copy bounds anyway
[04:37:33] <strcat> should be Clone if it really needs to copy
[04:37:48] <strcat> lots of the stdlib is useless when you start using types with destructors :(
[04:38:11] <strcat> rusti: 5
[04:38:14] -rusti- 5
[04:39:54] <strcat> brson: https://github.com/mozilla/rust/pull/6606 r?
[04:43:26] <bjz> this one needs to be prioritised imo: https://github.com/mozilla/rust/pull/6601
[04:44:26] <dbaupp> bjz: it's already stale
[04:44:27] <dbaupp> :(
[04:44:34] <bjz> :(
[04:44:48] <dbaupp> cmr: the assert_eq pr is unmergeable already!
[04:45:06] <bjz> well he needs to do it pronto on the weekend
[04:45:17] <bjz> while things are reasonably quiet
[04:45:42] <steven_is_false> Okay, so I think that as well as having an explicit clone trait we should have an explicit move trait as well. What does anyone else think of that?
[04:46:51] <steven_is_false> The move trait would have a strange type though.
[04:46:58] <strcat> steven_is_false: I don't know how practical this would be to do
[04:47:09] <strcat> seems to involve making the language more complex
[04:48:17] <steven_is_false> strcat: I'll experiment with it a bit, knock the concept around until it's practical, and then show you a valid usecase.
[04:48:38] <strcat> sounds good :)
[04:50:19] <cscottnet> if I've got a ~str, how do i copy it so I can assign it to a struct with a ~str field?
[04:51:02] <strcat> you don't need to copy it
[04:51:25] <strcat> rusti: struct Foo(~str); let x = ~"foo"; let y = Foo(x); y
[04:51:30] -rusti- {__field__: ~"foo"}
[04:51:35] <cscottnet> oh, sorry, i guess I've got a &str
[04:51:46] <strcat> so &str to ~str?
[04:51:49] <strcat> you can use .to_str()
[04:52:27] <dbaupp> did the non_camel_case_types warning/error get changed recently?
[04:52:28] <cscottnet> since strs are immutable, i wonder if I should just use @str everywhere, so i don't need to copy it.
[04:52:42] <cscottnet> does rust have any notion of intern'ed strings?
[04:53:28] <strcat> cscottnet: or just use &str with lifetimes
[04:53:55] <cscottnet> i think i tried that before, without success.
[04:54:09] <strcat> there will be a string interner in the stdlib eventually
[04:54:19] <strcat> I suggested that to graydon for the one he was working on
[04:54:52] <cscottnet> presumably interned strings are @str
[04:55:32] <cscottnet> can i access pointer equality of @str? == will do an unnecessary byte-by-byte comparison if the strings are interned.
[04:56:16] <strcat> cscottnet: interned strings won't be @str
[04:57:09] <dbaupp> rusti: let mut a = ~"abc"; a[1] = 'X' as u8; a
[04:57:11] -rusti- ~"aXc"
[04:57:14] <cscottnet> struct Intern { value: ~str }; impl Intern { fn intern(s: ~str) -> @Intern { ... } ?
[04:57:15] *** Joins: ghrust (ghrust@moz-4EF5B6E5.rs.github.com)
[04:57:15] <ghrust> 01[13rust01] 15bors pushed 0 new commits to 06auto: 02http://git.io/OpU7Dw
[04:57:15] *** Parts: ghrust (ghrust@moz-4EF5B6E5.rs.github.com) ()
[04:57:16] *** Joins: ghrust (ghrust@moz-4EF5B6E5.rs.github.com)
[04:57:16] <ghrust> 01[13rust01] 15bors pushed 2 new commits to 06auto: 02http://git.io/rFZaDQ
[04:57:16] <ghrust> 13rust/06auto 1420ef423 15Daniel Micay: reduce the usage of explicit version markers
[04:57:16] <ghrust> 13rust/06auto 14aa82783 15bors: auto merge of #6606 : thestinger/rust/vers, r=brson...
[04:57:16] *** Parts: ghrust (ghrust@moz-4EF5B6E5.rs.github.com) ()
[04:57:18] <cscottnet> strcat: ^^
[04:58:24] <strcat> cscottnet: I don't think it needs @ for anything
[04:59:16] <cscottnet> strcat: who owns the interned strings?  presumably the intern table, which is task-global?
[04:59:39] <strcat> afaik the string interner would just be a plain old object you can put wherever you want
[05:00:18] <strcat> and you'd have something like a token with an index returned to you
[05:00:34] * strcat shrugs
[05:00:47] <cscottnet> strcat: care to venture a function prototype?
[05:01:00] <cscottnet> i'm still trying to be sure i understand the ownership type system
[05:01:45] <cscottnet> impl Interner { fn intern(s : &str) -> ~Token { ... } } seems like it does a lot of unnecessary allocation
[05:02:04] <strcat> no reason you have to return objects with ~
[05:02:32] <strcat> brson: ugh, the version marker removal hit some weird ICE in make check :(
[05:02:36] <cscottnet> impl Interner { fn intern(s : &str) -> Token { ... };
[05:02:54] <strcat> compiling stdtest
[05:02:54] <cscottnet> struct Token { priv str_id : uint };
[05:03:06] <strcat> maybe an unrelated random failure...
[05:03:29] <strcat> cscottnet: that would work
[05:03:39] <strcat> doesn't protect you from accidentally mixing interners though
[05:04:08] <cscottnet> which is why I'd make the Interner itself task-global
[05:04:28] <cscottnet> but that's not necessarily "the rust way"
[05:05:09] <strcat> brson: I think it tries to link libstd twice
[05:05:19] <strcat> something weird is going on
[05:05:21] * strcat shrugs ;p
[05:05:35] <strcat> if it fails on bors I'll just leave the marker in compiletest
[05:07:10] *** Quits: sp3d (a@moz-49806493.dhcp.stls.mo.charter.com) (Quit: sp3d)
[05:07:39] <benh> Someone patch git grep to not report matches within #[test] blocks ;)
[05:09:29] *** Joins: sp3d (a@moz-49806493.dhcp.stls.mo.charter.com)
[05:10:31] <steven_is_false> Okay so making a nonmoveable type is very contorted, and silly. Can anyone figure out a way to make it less silly? Here's the code https://gist.github.com/sstewartgallus/5606751
[05:14:46] <ssbr_> I can't figure out how to minimize this ICE any further, but it seems a little absurd presently: https://gist.github.com/ssbr/c87b721a8914ee82101e
[05:15:08] <ssbr_> Anyone have any simplifications, or suggestions as to what I've done wrong (if anything)?
[05:16:57] <ssbr_> in my own code I've worked around this by moving the content of the impl into the trait impl, which makes the issue go away
[05:18:04] *** Joins: youknowone (youknowone@A826BD81.8A0DEF81.38747683.IP)
[05:18:04] *** Quits: youknowone (youknowone@A826BD81.8A0DEF81.38747683.IP) (Z:lined (Open Proxy found on your host. Please visit www.blitzed.org/proxy?ip=115.68.131.49 for more information.))
[05:20:53] <dbaupp> ssbr_: eurgh, that type of ice is really annoying
[05:21:09] <dbaupp> (but that's much smaller than any testcase I've got for it)
[05:21:31] <ssbr_> dbaupp: if you mean the particular error, isue #6000 fails the same assertion using macros
[05:21:38] <ssbr_> and very little code
[05:21:48] <ssbr_> I'm filing a separate bug report right now.
[05:21:58] <dbaupp> ssbr_: yeah, there are 4 bugs with that error message
[05:22:11] <ssbr_> oh, I could only find one via search
[05:22:12] <dbaupp> ssbr_: https://github.com/mozilla/rust/search?q=assertion+failed%3A+!bcx.ccx%28%29.maps.moves_map.contains%28%26arg_expr.id%29&type=Issues
[05:22:31] <ssbr_> ugh, I should've used github search instead of google. Oops.
[05:22:55] <ssbr_> dbaupp: should I file, or no?
[05:23:09] <ssbr_> I'm looking at the other bug reports now
[05:24:17] <dbaupp> ssbr_: I don't know... it's hard to tell if they are the same or not
[05:25:36] <ssbr_> better safe than sorry, I guess.
[05:28:20] <steven_is_false> Is it dangerous to have a random owned pointer into the stack if it's never used?
[05:28:27] <ssbr_> Heh, after that, my code worked perfectly, no problems.
[05:29:21] <dbaupp> ssbr_: you should probably link to the 4 other issues
[05:29:58] <ssbr_> dbaupp: how do I link to issues? Just the URL< or is there a nice fancy shorthand like [#XXXX] or something
[05:30:19] <dbaupp> ssbr_: github will link '#xxxx'
[05:30:30] <ssbr_> ugh
[05:30:38] <dbaupp> (without the quotes)
[05:30:40] <ssbr_> github is autocompleting "#6000" as "#6500"
[05:31:53] <ssbr_> Done
[05:31:54] <dbaupp> ssbr_: you could probably also mention that the #[main] isn't relevant to the ICE (or convert it to be fn main())
[05:32:00] <ssbr_> oh, oops
[05:32:55] <ssbr_> done
[05:33:46] *** Joins: ysuzuki (ysuzuki@3969BCB2.9CD517C2.134C27BB.IP)
[05:33:52] <dbaupp> ssbr_: nice :)
[05:34:03] <dbaupp> are you still working on regexes?
[05:34:36] <ssbr_> dbaupp: this isn't that, no :(
[05:34:53] <ssbr_> I got antsy because I had to rewrite the parser code for the third time, and started writing a video game instead
[05:34:59] <ssbr_> I'm not very good at this
[05:36:49] <strcat> steven_is_false: yes it will explode
[05:37:09] <strcat> assuming you mean just casting something to an invalid ~ ;p
[05:37:37] <dbaupp> ssbr_: i'm not very good at this either... got way too many projects on the go
[05:37:41] <steven_is_false> strcat: Oh. I'll work on a different approach then.
[05:38:58] *** Quits: KindOne (KindOne@29275653.D1A4D0AD.EC6A1518.IP) (Ping timeout)
[05:39:51] <steven_is_false> Is there an opposite to 'static. Some sort of 'local region?
[05:40:51] <dbaupp> steven_is_false: leaving off the lifetime is inferred to be the current block
[05:41:04] <dbaupp>  /lifetime of what it's set to
[05:41:20] <dbaupp> (the latter is more correct than the former)
[05:41:28] <steven_is_false> dbaupp: That seems to be to permissive for what I want to do.
[05:42:10] *** Joins: KindOne (KindOne@70EC82D.5D2364C3.EC6A1518.IP)
[05:42:11] *** Quits: ysuzuki (ysuzuki@3969BCB2.9CD517C2.134C27BB.IP) (Ping timeout)
[05:42:12] <dbaupp> steven_is_false: you can have arbitrary { .. } blocks. is that at all helpful?
[05:42:31] *** Quits: engla (engla@moz-DBD1D96E.cust.bredbandsbolaget.se) (Ping timeout)
[05:42:48] <steven_is_false> dbaupp: Right but that's from the user side, I want the library to enforce the restriction.
[05:42:54] *** Joins: ysuzuki (ysuzuki@3969BCB2.9CD517C2.134C27BB.IP)
[05:44:05] <dbaupp> steven_is_false: ah, i see. the only way to do it would probably associating it with some object, but I'm not sure if it's possible like that
[05:45:13] <steven_is_false> dbaupp: Well I found a way to do what I want it's just clunky, and inconvenient.
[05:46:25] <steven_is_false> dbaupp: I have to take the double negation of an anonymous lifetime (taking the double negation is a common pattern.)
[05:46:56] <steven_is_false> dbaupp: But basically I want SOME lifetime not ANY lifetime.
[05:47:02] <dbaupp> steven_is_false: you can negate lifetimes?
[05:47:29] <steven_is_false> dbaupp: fn foo <T> (&fn (Type <'lifetime>) -> T) -> T
[05:48:06] <dbaupp> and double negation is using that on T<'lifetime>
[05:48:08] <dbaupp> ?
[05:49:51] <steven_is_false> dbaupp: double negation isn't exactly what I mean. Strictly speaking double negation would be fn foo (&fn (Type <'lifetime>) -> util::Void) -> util::Void but we can use an arbitrary T instead and get something useful.
[05:50:13] *** Quits: ysuzuki (ysuzuki@3969BCB2.9CD517C2.134C27BB.IP) (Client exited)
[05:51:02] <steven_is_false> &fn (T) -> util::Void is the negation of T because it's the type which only has an instance if T is an empty type (as long as we're working in a pure, and total context.)
[05:51:09] <dbaupp> so essentially it's the same as  `(forall a. a -> t) -> t` in Haskell (but with lifetimes rather than types)
[05:51:12] <dbaupp> ?
[05:51:19] <steven_is_false> dbaupp: Right!
[05:51:23] <dbaupp> I understand :)
[05:52:44] *** Quits: blitter (blitter@moz-7C98731E.dyn.centurytel.net) (Ping timeout)
[05:54:15] *** Joins: ghrust (ghrust@moz-4EF5B6E5.rs.github.com)
[05:54:15] <ghrust> 01[13rust01] 15bors merged 06auto into 06incoming: 02http://git.io/rFZaDQ
[05:54:15] *** Parts: ghrust (ghrust@moz-4EF5B6E5.rs.github.com) ()
[05:56:23] <steven_is_false> Strange, the syntax trait SomeNonMoveable <'r> { fn move (&self) -> NonMoveable <'r>; etc.. doesn't seem to work.
[05:57:19] *** Joins: ghrust (ghrust@moz-4EF5B6E5.rs.github.com)
[05:57:19] <ghrust> 01[13rust01] 15bors pushed 0 new commits to 06auto: 02http://git.io/VXJVcQ
[05:57:19] *** Parts: ghrust (ghrust@moz-4EF5B6E5.rs.github.com) ()
[05:57:50] <cscottnet> strcat: http://paste.debian.net/5108/ <- intern.rs
[05:57:55] *** Joins: ysuzuki (ysuzuki@moz-CCA5E396.tokyo.ocn.ne.jp)
[05:58:02] <dbaupp> steven_is_false: you need `-> Self` on traits
[05:58:02] <cscottnet> strcat: interested for your feedback, since i'm still a rust newbie
[05:58:10] <dbaupp> (to return self)
[05:58:32] <dbaupp> cscottnet: just out of interest, have you seen the interner in libsyntax?
[05:59:07] <dbaupp> cscottnet: https://github.com/mozilla/rust/blob/incoming/src/libsyntax/util/interner.rs
[06:04:00] <strcat> dbaupp: the current string interner is really terrible though
[06:04:02] <cscottnet> dbaupp: nope, but now it looks familiar. ;)
[06:04:28] <strcat> librustc/libsyntax is a pretty good example of how not to write rust ;p
[06:04:41] <strcat> because it just ended up that way after many iterative changes to the whole codebase
[06:06:52] <cscottnet> what's Equiv?
[06:06:57] *** Joins: tiffany (kawaii@moz-1E0FE6E8.dhcp.embarqhsd.net)
[06:07:19] <strcat> Eq between two different types that are still comparable
[06:07:24] <cscottnet> interner.rs uses self.map.find_equiv(&StringRef(val))
[06:08:48] <cscottnet> i'm suspicious that "a == b" for a, b: IString in my implementation is still going to invoke pointer dereferencing if I look at the asm
[06:09:10] <steven_is_false> Hmm, it's not possible to have a trait over lifetimes?
[06:09:30] <dbaupp> strcat: just uploading a big cleanup of (parts of) syntax/ext now
[06:11:32] *** Joins: samnardoni (samnardoni@moz-ECB14881.cable.virginmedia.com)
[06:13:16] *** Quits: samnardoni (samnardoni@moz-ECB14881.cable.virginmedia.com) (Ping timeout)
[06:16:12] <dbaupp> strcat: do you feel up to reviewing a ~3800 line patch? https://github.com/mozilla/rust/pull/6611 :S
[06:16:39] <strcat> dbaupp: would be better to ask someone familiar with that code
[06:16:54] <dbaupp> strcat: do you happen to know anyone?
[06:16:55] * strcat really hasn't touched any of libsyntax :(
[06:17:09] <strcat> dbaupp: dunno
[06:18:32] <cscottnet> yes, unfortunately the implementation of fn eq() still adds an extra dereference for 'struct { f: uint }' over just comparing uints directly :(
[06:18:38] *** Joins: aatch (aatch@moz-2BB0AC01.cable.telstraclear.net)
[06:18:38] *** Joins: jgilbert (jgilbert@8ACF1000.5EFFC0B8.24454B25.IP)
[06:19:00] <dbaupp> cscottnet: in the asm?
[06:20:30] <cscottnet> dbaupp: yes.  see: http://paste.debian.net/5109/
[06:20:59] <cscottnet> presumably if I defined eq as 'fn eq(self, other: IString)' I could get rid of the dereference, but then it wouldn't implement Eq.
[06:21:25] <dbaupp> cscottnet: does it do it for `struct IString(uint)`?
[06:22:09] <strcat> cscottnet: make it #[inline(always)]
[06:22:20] <strcat> I doubt it will actually deref except to preserve an ABI
[06:23:40] <cscottnet> strcat: that will require some more hardcore disassembly work to check.  but note that it shouldn't need to extra-deref for the given implementation of foo, since the arguments to foo are passed as values.
[06:23:52] <cscottnet> dbaupp: checking your case, hang on.
[06:24:27] <cscottnet> strcat: in other works, I don't think inlining helps at all, I'm already compiling with -O and the implementation of eq is being inlined into foo.
[06:24:30] <cscottnet> *words
[06:25:04] <strcat> we really need TBAA
[06:26:29] <dbaupp> cscottnet, strcat: #[inline(always)] doesn't seem to help
[06:27:46] *** Quits: jgilbert (jgilbert@8ACF1000.5EFFC0B8.24454B25.IP) (Ping timeout)
[06:29:02] <cscottnet> dbaupp: http://paste.debian.net/5110/ uses struct IString(uint) but I can't parse the assembly
[06:29:11] <cscottnet> I don't see a comparison at all in foo()
[06:30:02] <cscottnet> did I botch the implementation of eq()?
[06:30:51] <dbaupp> cscottnet: yep
[06:31:04] <dbaupp> you're comparing IString with IString
[06:31:10] <dbaupp> (i.e. infinite recursion)
[06:31:18] <dbaupp> you'll need to dereference twice
[06:31:36] <dbaupp> and it looks like it gives the same code as struct { id: uint }
[06:31:42] <cscottnet> ah, i just found the infinite recursion in the unoptimized assembly f
[06:31:53] *** Quits: wilsonk|2 (kvirc@moz-39EFBFC2.cg.shawcable.net) (Quit: KVIrc 4.0.4 Insomnia http://www.kvirc.net/)
[06:32:45] <cscottnet> funny that I don't see the recursion in the optimized assembly for foo
[06:33:20] <cscottnet> rust is very fast -- it compiles infinite loops into terminating code!
[06:33:30] <cscottnet> (as long as you use -O)
[06:33:42] <dbaupp> cscottnet: this came up before
[06:33:56] <dbaupp> looking for the issue now
[06:34:59] <cscottnet> but yes, i can confirm that, when correctly written, struct IString(uint) generates code indistinguishable from struct IString { id: uint }
[06:35:03] <dbaupp> cscottnet: https://github.com/mozilla/rust/issues/6179
[06:35:55] <cscottnet> dbaupp: i'll add my test case, which seems to be much simpler that the others
[06:38:09] <steven_is_false> Okay this makes me really angry! error: cannot call a method whose type contains a self-type through a boxed trait 
[06:40:14] <cscottnet> dbaupp: github issue commented.
[06:40:33] <dbaupp> cscottnet: yup, I already got the email notification :)
[06:40:51] <cscottnet> makes me think about using bare uint instead of IString... but I'll leave it this way for now and hope that rust eventually optimizes this out.
[06:41:18] <cscottnet> maybe there needs to be a 'fn eq_val(self, other: Self) { ... }' trait...
[06:41:49] <dbaupp> cscottnet: hopefully it does, because using newtype structs to control behaviour without a runtime penalty would be nice.
[06:42:23] <cscottnet> yeah, this should really be an optimization.  although the dereference is perfectly understandable given the signature of the method.
[06:43:26] <dbaupp> I'll open an issue
[06:43:50] <cscottnet> out of curiosity, does anyone know how c++ handles this?  operator= seems to have a similar signature, although maybe C++ '&' is more tricksy.
[06:47:43] <strcat> C++ doesn't auto-deref
[06:48:16] <strcat> and in C++03, you can only have one layer of &
[06:48:21] <strcat> C++11 complicates things
[06:48:22] <dbaupp> cscottnet: https://github.com/mozilla/rust/issues/6612
[06:50:15] <cscottnet> http://paste.debian.net/5111/ is the c++ version; i can confirm that it doesn't add the extra deref
[06:51:56] <dbaupp> cscottnet: if you actually use foo and it gets inlined (e.g. `if foo(IString(rand::random()), IString(rand::random())) { print("hi") }` in main), then there is no indirection
[06:52:34] <dbaupp> it's just `call random; mov rax, rbx; call random; cmp rax rbx`
[06:52:39] *** Joins: victorporof (victorporo@10AA7997.880C8D58.79933D60.IP)
[06:52:47] <strcat> do we really pass all structs by ref
[06:53:03] <dbaupp> strcat: seems so
[06:53:06] <strcat> ugh
[06:53:31] <dbaupp> do they get returned via an "out-pointer" that's passed in by the caller?
[06:53:43] <strcat> if they're big
[06:53:59] <dbaupp> i.e. is ~return_a_big_struct() a memcpy to move it to the heap?
[06:54:11] <strcat> no
[06:54:29] <cscottnet> hrm.  that might be part of the c calling convention on x86?
[06:54:29] <strcat> it shouldn't be doing all of them, I thought the code to return small things by-value landed
[06:54:36] <benh> Does that mean that fn f(x:&LargeStruct) and fn f(x:LargeStruct) are called the same, really?
[06:55:19] <dbaupp> benh: yes (although for large structs, that's probably the correct/fastest behaviour)
[06:55:45] <benh> Not complaining :)
[06:55:45] * cscottnet has to step afk
[07:00:13] *** Joins: ghrust (ghrust@moz-4EF5B6E5.rs.github.com)
[07:00:13] <ghrust> 01[13rust01] 15bors merged 06auto into 06incoming: 02http://git.io/IiwnSQ
[07:00:13] *** Parts: ghrust (ghrust@moz-4EF5B6E5.rs.github.com) ()
[07:05:42] *** Joins: samnardoni (samnardoni@moz-ECB14881.cable.virginmedia.com)
[07:07:31] *** Quits: samnardoni (samnardoni@moz-ECB14881.cable.virginmedia.com) (Ping timeout)
[07:10:04] *** Joins: pyrac (pyrac@moz-C70D038B.w109-214.abo.wanadoo.fr)
[07:14:06] *** Parts: steven_is_false (user@moz-144077DE.bchsia.telus.net) (ERC Version 5.3 (IRC client for Emacs))
[07:14:32] *** Quits: Ralith (ralith@moz-50F3C77.vc.shawcable.net) (Ping timeout)
[07:14:39] *** Quits: bbrittain (ben@moz-A7CDB794.dia.static.qwest.net) (Client exited)
[07:18:38] <dbaupp> cmr: ping
[07:18:47] *** Joins: Ralith (ralith@moz-50F3C77.vc.shawcable.net)
[07:26:10] <dbaupp> cscottnet: renamed!
[07:27:34] <dbaupp> bjz: has your tuple thing landed?
[07:30:25] <bjz> dbaupp: no
[07:30:47] <dbaupp> bjz: ok, doesn't matter, I'm working off your branch
[07:30:53] <bjz> dbaupp: coolies
[07:31:16] <dbaupp> do you want me to send a pr to you, or to replace your one to upstream?
[07:32:00] *** Quits: ysuzuki (ysuzuki@moz-CCA5E396.tokyo.ocn.ne.jp) (Client exited)
[07:32:46] *** Joins: wilsonk-laptop (kvirc@moz-39EFBFC2.cg.shawcable.net)
[07:33:14] *** Joins: ysuzuki (ysuzuki@moz-CCA5E396.tokyo.ocn.ne.jp)
[07:34:46] <dbaupp> bjz: I think #[inline(always)] might be too aggressive?
[07:37:59] <bjz> dbaupp: you can get rid of it if you like
[07:38:19] <bjz> dbaupp: um, I'll add you to my contributors
[07:38:23] <dbaupp> i'll convert them to #[inline]
[07:38:33] <bjz> huon right?
[07:39:04] <bjz> huonw?
[07:39:05] <dbaupp> bjz: huonw
[07:39:23] <bjz> added
[07:39:31] <bjz> just push to the branch
[07:39:40] <dbaupp> cool! I'm adding TotalEq and TotalOrd instances while I'm at it
[07:39:41] <bjz> and it'll probs update the PR
[07:39:45] <bjz> nice!
[07:40:29] <dbaupp> Also, I've found that using {} with top-level macros works better than () (at least, emacs' indentation works better with the former)
[07:40:49] <strcat> dbaupp: if it's relatively small and has #[inline], it will basically always inline it anyway
[07:41:12] *** Quits: solancile (solancile@moz-A1CFFAE5.hsd1.wa.comcast.net) (Quit: Leaving)
[07:41:55] <dbaupp> strcat: yup, but no need to force it for, e.g., 12-tuples
[07:42:44] <bjz> dbaupp: good idea
[07:42:49] <bjz> :)
[07:43:35] *** Quits: james4k (james@moz-726FE3EE.com) (Ping timeout)
[07:44:18] <dbaupp> hmm, should deriving put #[inline] on its methods?
[07:45:39] *** Quits: Jeaye (Jeaye@moz-FD505E54.hsd1.ca.comcast.net) (Ping timeout)
[07:46:20] <strcat> dbaupp: dunno, it's a mess to deal with
[07:46:41] <strcat> there are ABI implications
[07:46:41] <dbaupp> strcat: in what sense?
[07:46:48] <dbaupp> oh
[07:46:58] <strcat> we need #[inline(maybe)]
[07:47:01] <strcat> #[inline] is a hint
[07:47:12] <strcat> there is barely any different from LLVM's POV between #[inline] and #[inline(always)]
[07:47:26] <strcat> if it sees #[inline] it's going to inline 99% of the time
[07:47:40] <strcat> it doesn't have to respect the hints but it almost always will
[07:47:45] <dbaupp> is there a weaker inlining setting for LLVM?
[07:47:54] <strcat> dbaupp: the problem isn't LLVM
[07:48:03] <strcat> it's that rust doesn't have a way to expose a function to *allow* inlining
[07:48:20] <strcat> it mixes allowing inlining with inlining hints
[07:48:26] <strcat> (cross-crate inlining)
[07:48:35] <strcat> anyway there are ABI implications as I said
[07:49:55] <dbaupp> oh, I though #[inline] was basically just "put necessary metadata in compiled crate" + hint to LLVM, but clearly not
[07:50:45] <strcat> dbaupp: it is
[07:50:51] <strcat> hint to LLVM means LLVM almost always inlines
[07:51:19] <strcat> clang/gcc actually have -Winline to throw warnings if the hint fails - the hint doesn't *have* to be respected but it's not taken lightly
[07:51:44] <dbaupp> oh, so rustc has to manually decide about inlining for a weaker inlining hint?
[07:51:55] <strcat> no
[07:52:14] <strcat> dbaupp: LLVM will do inlining without any attributes within a crate because it's all available
[07:52:25] <strcat> to do cross-crate inlining, rust needs to output the serialized AST
[07:52:35] <strcat> currently, rust can't do that without also adding an inlining hint
[07:52:46] <strcat> there's no correct way to do deriving
[07:52:50] <benh> is there a rustc command line option to dump the AST in some form that looks vaguely machine-readable?
[07:52:55] <strcat> putting #[inline] on all of them is going to make massive code bloat
[07:52:57] <strcat> lots of them are big
[07:53:04] <benh> (i don't wanna read it, just want to see where whitespaces disappears... )
[07:53:15] <dbaupp> hm, I have a feeling that inline(maybe) wouldn't be hard to add
[07:53:25] <dbaupp> it's essentially just update the metadata writer
[07:53:41] <benh> rustc --pretty reorders comments with doc-comments :D
[07:55:02] <dbaupp> benh: you can use libsyntax directly
[07:55:09] <dbaupp> (i.e. get the ast in raw form)
[07:55:24] <dbaupp> would that be better?
[07:55:30] <benh> probably, yeah
[07:55:53] <benh> i'm just digging through the code between libsyntax and rustdoc right now--i want to figure out what a good behavior for lines that are just /// is
[07:57:00] *** Joins: cdidd (cdidd@moz-55E13B29.broadband.corbina.ru)
[07:58:17] *** Joins: devbug (quassel@moz-E1DE087C.bchsia.telus.net)
[07:59:47] *** Joins: samnardoni (samnardoni@moz-ECB14881.cable.virginmedia.com)
[08:00:38] <benh> I feel like the right thing to do is to merge consecutive ///-comments at lexer time rather than generating one doc attr for each line, but I don't really know what I'm doing :)
[08:01:38] *** Quits: samnardoni (samnardoni@moz-ECB14881.cable.virginmedia.com) (Ping timeout)
[08:02:18] <dbaupp> benh: does /// create a new attribute for each line at the moment?
[08:02:35] <benh> From how I read the lexer and parser, yes
[08:04:24] <benh> Each /// comment seems to generate a DOC_COMMENT token, in libsyntax/parser/attr.rs each DOC_COMMENT seems to result in one ast::attribute, but I have no idea what is going on inbetween/later on, maybe they do get merged...
[08:06:04] <dbaupp> strcat: http://ix.io/5HC/diff
[08:06:32] <strcat> dbaupp: still, I don't think it's really a solution for deriving
[08:06:38] *** Joins: Blei (philipp@moz-96D25F7A.cust.bluewin.ch)
[08:07:22] <strcat> *shrug*
[08:07:37] <strcat> I would be happy if we just had LTO support
[08:08:25] <dbaupp> strcat: should I submit that as pr? (just adding inline(maybe), not touching deriving)
[08:08:34] <strcat> dbaupp: yeah, seems worth having
[08:13:18] *** Joins: Blub\w (wry@7E3BB9D.71150E1A.237AE2BA.IP)
[08:14:10] <benh> How do I link a program against libsyntax? if I say rustc -L prefix/lib/ myprogram.rs with extern mod syntax, it complains that there's multiple matching crates for `core`
[08:15:35] <dbaupp> benh: just plain `extern mod syntax;` with no extra args should work
[08:15:54] <benh> oh
[08:16:19] <dbaupp> let sess = parse::new_parse_sess(None); let parsed = parse::parse_crate_from_file_using_tts(p, ~[], sess); let expanded = ext::expand::expand_crate(sess, ~[], parsed);
[08:16:26] <dbaupp> (where `p` is the file path)
[08:16:35] <benh> cheers
[08:16:43] <benh> I was trying to copy code from the librustdoc tests but not doing it very well
[08:16:45] <dbaupp> should give a fully macro-expanded ast
[08:19:50] *** Quits: catpigger (catpig@moz-2864D03.dip0.t-ipconnect.de) (Quit: Verlassend)
[08:22:47] *** Quits: Earnestly (earnest@6A917A59.5E1FD793.39C00A7A.IP) (Ping timeout)
[08:25:35] *** Quits: ysuzuki (ysuzuki@moz-CCA5E396.tokyo.ocn.ne.jp) (Client exited)
[08:28:32] <cscottnet> "cannot borrow foo as mutable because it is also borrowed as mutable"
[08:28:51] <cscottnet> *immutable (second mutable)
[08:29:08] <cscottnet> how do i get the immutable borrow to return the pointer so I can mutate it?
[08:34:17] *** Quits: snowmantw (snowmantw@moz-22F9C99D.dynamic.hinet.net) (Client exited)
[08:34:27] <dbaupp> cscottnet: what's the code?
[08:39:41] *** Quits: brson (brson@E9CDE21E.991753BB.CA4D1600.IP) (Quit: leaving)
[08:40:41] <cscottnet> dbaupp: http://paste.debian.net/5120/
[08:40:57] <cscottnet> the error is in ObjectMap::with_field
[08:41:19] <cscottnet> basically i would like to make a tree structure, which is owned by the root of the tree.
[08:41:30] <bjz> strcat: ping
[08:42:00] <cscottnet> tree::add() (more or less) should return a pointer with the same lifespan as the parent node.
[08:42:46] <bjz> strcat: https://gist.github.com/bjz/d7c90a39562bc054c28e
[08:42:49] <bjz> :S
[08:44:24] *** Quits: cdidd (cdidd@moz-55E13B29.broadband.corbina.ru) (Ping timeout)
[08:49:54] *** Joins: donri (dag@moz-9BB61102.tbcn.telia.com)
[08:53:56] *** Joins: samnardoni (samnardoni@moz-ECB14881.cable.virginmedia.com)
[08:55:36] *** Quits: samnardoni (samnardoni@moz-ECB14881.cable.virginmedia.com) (Ping timeout)
[08:56:23] *** Joins: victorporof_ (victorporo@10AA7997.880C8D58.79933D60.IP)
[08:56:32] <dbaupp> bjz: https://github.com/bjz/rust/commit/3a11ddb1b2a0807e1c3dc9a9a6afc1d578286bae
[08:57:06] <bjz> dbaupp: does that pass make check?
[08:57:22] *** Quits: victorporof (victorporo@10AA7997.880C8D58.79933D60.IP) (Ping timeout)
[08:57:23] <dbaupp> bjz: just running the full thing now
[08:57:56] <bjz> dbaupp: the biggest thing is operator overloads suring tests for some reason
[08:58:21] <dbaupp> 'suring' ?
[08:58:27] <bjz> that's why they have #[cfg(not(test))] around the place
[08:58:29] <bjz> *during
[08:58:52] <bjz> but it'll be interesting to see if it passes
[08:58:54] <bjz> :)
[08:59:09] <dbaupp> oh, so I don't need them on Total*?
[08:59:11] <bjz> I was only going to test the macros themselves
[08:59:27] <dbaupp> eh, whatever, it's written now :P
[08:59:28] <bjz> yeah dw
[08:59:39] <bjz> no it's awesome
[08:59:53] <bjz> probably not communicating very well
[08:59:55] <bjz> :P
[09:00:16] <bjz> but yeah, super yayayhooray
[09:00:26] *** Joins: Matt (Matt_S_G@E0886BDD.792EA451.EB1CD665.IP)
[09:01:51] *** Quits: wilsonk-laptop (kvirc@moz-39EFBFC2.cg.shawcable.net) (Ping timeout)
[09:02:43] *** Joins: victorporof (victorporo@10AA7997.880C8D58.79933D60.IP)
[09:04:00] *** Quits: victorporof_ (victorporo@10AA7997.880C8D58.79933D60.IP) (Ping timeout)
[09:08:42] *** Joins: victorporof_ (victorporo@10AA7997.880C8D58.79933D60.IP)
[09:09:17] *** Quits: devbug (quassel@moz-E1DE087C.bchsia.telus.net) (Client exited)
[09:09:52] *** Quits: victorporof (victorporo@10AA7997.880C8D58.79933D60.IP) (Ping timeout)
[09:14:55] *** Quits: pyrac (pyrac@moz-C70D038B.w109-214.abo.wanadoo.fr) (Quit: pyrac)
[09:17:50] *** Joins: spider-mario (spidermari@moz-2BC095A6.rev.sfr.net)
[09:18:00] *** Joins: FrozenCow (FrozenCow@moz-9DF5D010.dynamic.upc.nl)
[09:18:32] *** Joins: victorporof (victorporo@10AA7997.880C8D58.79933D60.IP)
[09:19:50] *** Quits: victorporof_ (victorporo@10AA7997.880C8D58.79933D60.IP) (Ping timeout)
[09:19:55] *** Joins: DasIch (DasIch@moz-7447F66F.dip0.t-ipconnect.de)
[09:22:56] *** Joins: EXetoC (ex@moz-2DBEB1E4.customer.t3.se)
[09:23:50] *** Quits: geomyidae (geomyidae@9FDA6BE2.37A86C23.448B98CC.IP) (Ping timeout)
[09:24:36] *** Joins: geomyidae (geomyidae@9FDA6BE2.37A86C23.448B98CC.IP)
[09:25:00] <Blei> cscottnet: might be a bug in the borrow checker
[09:25:22] <cscottnet> hm.
[09:25:35] <Blei> if you remove the `return` inside the `self.children.each` it works
[09:25:49] <Blei> err, the return clause
[09:25:49] <cscottnet> trie.rs has code similar to mine, i'm trying to figure out how that's different
[09:27:58] *** Joins: cdidd (cdidd@C60D1DFD.8AFAB4CD.62D8163C.IP)
[09:31:36] <bjz> dbaupp: how did it go?
[09:36:49] <Blei> cscottnet: this works, but is obviously a workaround
[09:36:51] <Blei> http://www.hastebin.com/xegomiqaba.vhdl
[09:36:52] *** Joins: pyrac (pyrac@moz-C70D038B.w109-214.abo.wanadoo.fr)
[09:37:43] <cscottnet> i'll take a workaround at this point, i've been banging my head against this
[09:38:00] <Blei> your original version should work, imo it's a bug (something like "return statements borrow arguments for the rest of the function even though that's not necessary")
[09:38:26] <benh> hooray, i managed to walk through the ast and get the attributes of top-level items ;)
[09:38:43] *** Quits: pyrac (pyrac@moz-C70D038B.w109-214.abo.wanadoo.fr) (Ping timeout)
[09:41:27] *** Joins: jensnockert (jensnocker@moz-8BE55278.customer.t3.se)
[09:43:15] <dbaupp> bjz: it passed
[09:43:24] <bjz> strcat: ping
[09:43:26] <bjz> :)
[09:44:05] <dbaupp> benh: top-level in all modules? :)
[09:44:57] *** Joins: pyrac (pyrac@moz-C70D038B.w109-214.abo.wanadoo.fr)
[09:45:45] <bjz> strcat: me and dbaupp are ready for an r? on that tuple thing
[09:46:24] <benh> dbaupp: in all modules in my single foo.rs file with two declarations ;)
[09:46:32] <dbaupp> (link https://github.com/mozilla/rust/pull/6595 )
[09:46:44] <benh> I just wanted to confirm that all /// doc comments get their own attribute in the ast
[09:46:46] <dbaupp> benh: close enough! :D
[09:47:13] <cscottnet> Blei: http://paste.debian.net/5128/ is another working version (uses vec::position)
[09:47:26] <dbaupp> benh: and they do?
[09:47:34] <cscottnet> Blei: I guess I'll file a bug for the other version
[09:47:43] <benh> yeah
[09:47:59] *** Joins: whidgle (Mibbit@8DC562F6.74F864AC.FD2437D8.IP)
[09:48:03] *** Joins: samnardoni (samnardoni@moz-ECB14881.cable.virginmedia.com)
[09:48:15] <benh> http://ix.io/5HF
[09:48:24] <whidgle> hello,everybody
[09:48:47] <dbaupp> benh: cool
[09:49:01] <whidgle> how can i get the rust actor demo?
[09:49:45] *** Quits: samnardoni (samnardoni@moz-ECB14881.cable.virginmedia.com) (Ping timeout)
[09:50:30] <Blei> cscottnet: oh, i just filed a bug about that
[09:50:55] <cscottnet> Blei: so you did.  good, thanks!
[09:51:45] <whidgle> there is no person~!
[09:52:07] <dbaupp> whidgle: what's the rust actor demo?
[09:53:39] <whidgle> Tasks and communication tutorial
[09:54:03] <benh> https://github.com/mozilla/rust/blob/incoming/doc/tutorial-tasks.md ?
[09:54:45] <dbaupp> or http://static.rust-lang.org/doc/0.6/tutorial-tasks.html if you're on 0.6
[09:55:28] *** cscottnet is now known as cscott
[09:56:02] *** Joins: int3_ (int3_@moz-B7B5F043.singnet.com.sg)
[09:56:28] <whidgle> that is no in more detail
[09:57:48] <whidgle> I learn Rust beging today, i come from china , i can say chinese english, haha
[10:01:43] *** Quits: strcat (strcat@moz-54F7FD49.cpe.net.cable.rogers.com) (Quit: WeeChat 0.4.0)
[10:03:13] *** Joins: ghrust (ghrust@moz-4EF5B6E5.rs.github.com)
[10:03:13] <ghrust> 01[13rust01] 15bors pushed 0 new commits to 06auto: 02http://git.io/F5T6yg
[10:03:13] *** Parts: ghrust (ghrust@moz-4EF5B6E5.rs.github.com) ()
[10:03:16] *** Joins: ghrust (ghrust@moz-4EF5B6E5.rs.github.com)
[10:03:17] <ghrust> 01[13rust01] 15bors pushed 7 new commits to 06auto: 02http://git.io/jIQewA
[10:03:17] <ghrust> 13rust/06auto 14ce1e211 15Brendan Zabarauskas: Adapt the getter macro to implement Clone, Eq and Ord for n-ary tuples
[10:03:17] <ghrust> 13rust/06auto 14ee4d11f 15Brendan Zabarauskas: Use match instead of intermediate variable
[10:03:17] <ghrust> 13rust/06auto 14db453ec 15Brendan Zabarauskas: Replace Tuple{2..12} trait with CloneableTuple{2..12} and ImmutableTuple{2..12}...
[10:03:19] *** Parts: ghrust (ghrust@moz-4EF5B6E5.rs.github.com) ()
[10:05:12] *** Joins: tgt (tgt@moz-D59EE478.aztw.cable.virginmedia.com)
[10:06:39] *** Joins: steven_is_false (user@moz-144077DE.bchsia.telus.net)
[10:07:28] *** Joins: samnardoni (samnardoni@moz-ECB14881.cable.virginmedia.com)
[10:08:18] *** Quits: jensnockert (jensnocker@moz-8BE55278.customer.t3.se) (Input/output error)
[10:08:23] *** Joins: q66 (q66@6EE9DE40.46454B5D.33AABD5F.IP)
[10:08:40] *** Quits: samnardoni (samnardoni@moz-ECB14881.cable.virginmedia.com) (Client exited)
[10:17:07] *** Joins: jensnockert (jensnocker@moz-153756A.mobileonline.telia.com)
[10:17:11] *** Quits: Blei (philipp@moz-96D25F7A.cust.bluewin.ch) (Quit: WeeChat 0.4.0)
[10:18:19] *** Joins: judder (maradukewa@CF01B517.FDE2B133.950D3BB5.IP)
[10:19:38] <aatch> ololol,: exchange heap not empty on exit
[10:19:38] <aatch> 13655024 dangling allocations
[10:20:53] <kimundi> hehe
[10:21:29] <kimundi> what did you do?
[10:21:46] <aatch> kimundi, I'm doing: https://github.com/mozilla/rust/issues/6598
[10:22:09] <aatch> and wrote temporary wrapper functions for the intrinsics
[10:22:48] <kimundi> ah, that explains it :-) 
[10:22:54] <aatch> but I got a copy-paste error and forgot to change the body of the xsub wrapper to actually do xsub
[10:23:04] <aatch> So malloc +1, free +1
[10:25:11] <whidgle> hao can i use the Module cmp?? use std::cmp ?? right?
[10:25:34] <aatch> whidgle, this should all be in the tutorial
[10:25:56] <whidgle> .......
[10:27:39] *** Quits: tav (tav@moz-B2B8B585.zone7.bethere.co.uk) (Connection reset by peer)
[10:27:45] *** Joins: tav (tav@moz-B2B8B585.zone7.bethere.co.uk)
[10:30:01] <kimundi> needs an 'extern mod std;' at the top of the file
[10:30:27] *** Parts: steven_is_false (user@moz-144077DE.bchsia.telus.net) (ERC Version 5.3 (IRC client for Emacs))
[10:32:43] *** Quits: Matt (Matt_S_G@E0886BDD.792EA451.EB1CD665.IP) (Quit: WeeChat 0.4.1-rc2)
[10:37:18] <whidgle>  extern mod std; use std::cmp::*;  fn main() {   let a = 100f;   let b = 1000f;    if(a.fuzzy_eq(&b)) {     println("a = b")   } else {     println("a != b")   }  }
[10:37:30] <whidgle> thanks kimundi.
[10:38:40] *** Joins: BitPuffin (quassel@moz-8370D1B9.bredband.comhem.se)
[10:41:00] *** Quits: BitPuffin (quassel@moz-8370D1B9.bredband.comhem.se) (Client exited)
[10:42:52] *** Joins: BitPuffin (quassel@moz-8370D1B9.bredband.comhem.se)
[10:47:39] <cscott> will the lifetime parameterization in "fn foo<'r>(&'r self, ...) -> &'r Foo" work if I give it @self?
[10:48:16] <cscott> it looks like rust is giving me back a borrowed pointer; i was hoping it would give me back a @
[10:48:42] <aatch> cscott, it will give you back exactly what you right
[10:48:45] <dbaupp> cscott: the pointer types aren't parameterised/generic like that
[10:49:21] <cscott> Hrm.
[10:49:22] <aatch> s/right/write
[10:49:23] <kimundi> well the signature is returning a borrowed, so...
[10:49:44] <cscott> then i'd expect the signature not to match @self then.
[10:49:57] <dbaupp> there is "auto-dereferencing"
[10:50:38] <dbaupp> so (@x).foo() will still call foo even if it's only implemented on the "raw" type
[10:50:42] <kimundi> a @ coerces to & but other way would be unsage
[10:50:45] <cscott> so it's dereferencing and then borrowing a pointer, with presumably lifespan == the current function?
[10:50:51] <dbaupp> yup
[10:51:15] <cscott> hm, that's not exactly what I wanted that signature to mean/do
[10:51:56] <cscott> what i want is to say "child nodes in the tree are owned by the parent, so if you inserted a node give it the same allocator/lifespan as the parent"
[10:52:04] <dbaupp> (I think lifespan == scope of the original @ in the current function)
[10:52:36] <aatch> cscott, if it's actually ownership you want, you can use ~
[10:52:55] <aatch> move it into the tree, then borrow out of it if you need to
[10:53:00] <cscott> well in this case I happen to have a heap reference (@) to the root of the tree
[10:53:17] <cscott> so when i insert a new node, i expect the new node to also be heap allocated
[10:53:42] <aatch> cscott, yeah, you actually need @ for that.
[10:54:09] <aatch> since they have more semantics than just where they are allocated
[10:54:14] <aatch> @ is garbage-collected
[10:54:23] <aatch> where as ~ is not
[10:54:27] <cscott> it seems like ~ fields don't work in @-allocated structs
[10:54:42] <kimundi> they should
[10:54:44] <aatch> though technically (in a C sense) both are "heap-allocated"
[10:54:59] <aatch> (as in they call malloc to get memory)
[10:55:02] <cscott> aatch: sorry, s/garbage-collected heap/heap/
[10:56:23] <whidgle> @ managed, ~ is private
[10:56:24] <aatch> cscott, well, as kimundi said, there shouldn't be an issue with having ~ inside a data structure though.
[10:56:33] <aatch> whidgle, ~ isn't private
[10:56:35] *** Quits: jensnockert (jensnocker@moz-153756A.mobileonline.telia.com) (Ping timeout)
[10:56:48] <aatch> it's unique/owned (we really need to standardise this)
[10:56:57] *** Joins: jensnockert (jensnocker@moz-3512F4C3.a189.priv.bahnhof.se)
[10:57:04] <aatch> in fact, @ is more owned, since it task-local
[10:57:10] <aatch> whereas ~ is not
[10:57:13] *** Joins: ghrust (ghrust@moz-4EF5B6E5.rs.github.com)
[10:57:13] <ghrust> 01[13rust01] 15bors merged 06auto into 06incoming: 02http://git.io/jIQewA
[10:57:13] *** Parts: ghrust (ghrust@moz-4EF5B6E5.rs.github.com) ()
[10:57:16] <whidgle> hehe....
[10:57:28] <aatch> more /local/ sorry
[10:57:31] <kimundi> cscott: note that if you want to modify the contents of @ after creation it needs to be @mut
[10:57:34] * aatch can't type today apparently
[10:57:39] *** Joins: Earnestly (earnest@6A917A59.5E1FD793.39C00A7A.IP)
[10:57:48] <cscott> i think the root problem is that i'm using ~ inside the tree to (in theory) make nodes "owned by" the root... but I also want to store @ pointers to the nodes in @-allocated objects.
[10:58:07] <cscott> that's conflating the "owned" and "unique" semantics of ~
[10:58:27] *** Quits: CMCL (cmcl@moz-8C2E912C.co.uk) (Ping timeout)
[10:58:32] *** Quits: int3_ (int3_@moz-B7B5F043.singnet.com.sg) (Connection reset by peer)
[10:58:34] <cscott> ie, my nodes are owned by the root, but the root doesn't have a unique pointer to them.
[10:58:38] <aatch> cscott, you can't have multiple pointers to the same object.
[10:58:45] *** Quits: jensnockert (jensnocker@moz-3512F4C3.a189.priv.bahnhof.se) (Ping timeout)
[10:58:49] *** Joins: int3_ (int3_@moz-B7B5F043.singnet.com.sg)
[10:58:54] <aatch> Except for borrowed pointers
[10:58:59] *** Joins: jensnockert (jensnocker@moz-153756A.mobileonline.telia.com)
[10:59:02] *** Quits: int3_ (int3_@moz-B7B5F043.singnet.com.sg) (Client exited)
[10:59:03] <cscott> yeah, i need to rip out the ~ pointers and replace them with @ i guess.
[10:59:05] <aatch> in which case, you are still limited
[10:59:23] <aatch> cscott, yep, or you need to rework it to use more borrowed pointers.
[10:59:52] <kimundi> rusti: ~@~@5u8
[10:59:54] -rusti- ~@~@5
[11:00:10] <dbaupp> aatch: you can have multiple via & and lifetimes
[11:00:16] <whidgle> I Like use &
[11:00:19] *** Joins: CMCL (cmcl@moz-8C2E912C.co.uk)
[11:00:21] <cscott> i'm writing a JS interpreter, so I either need JS objects to live in a @-allocated heap, or I need to play heavy-duty games to make them all owned by a single js environment, or some such.  I don't think the latter is really going to work.
[11:00:25] <aatch> dbaupp, I realised that and mentioned it.
[11:00:27] <dbaupp> bjz: it worked!
[11:00:43] * dbaupp can't read today
[11:00:54] <aatch> dbaupp, well I can't type
[11:00:55] <cscott> s/environment/environment object/
[11:01:06] <aatch> The perfect combination!
[11:01:17] <dbaupp> aatch: I'll do the reading, you can do the typing
[11:01:21] * aatch originally typed "combinatation"
[11:01:34] <dbaupp> let's fill #rust with nonsense :P
[11:02:12] <aatch> dbaupp, more than normal?
[11:02:47] <kimundi> rusti: for 5u.times {println("nonsense")}
[11:02:49] -rusti- nonsense
[11:02:49] -rusti- nonsense
[11:02:49] -rusti- nonsense
[11:02:49] -rusti- nonsense
[11:02:49] -rusti- nonsense
[11:03:00] <whidgle> :_)
[11:03:06] <whidgle> :-)
[11:03:55] <dbaupp> cscott: yeah, getting around the borrow checker globally would probably be impossible
[11:04:16] *** Joins: int3_ (int3_@moz-B7B5F043.singnet.com.sg)
[11:04:17] <dbaupp> (at least until all the little bugs have been ironed out)
[11:04:42] <cscott> i guess the moral is that graph data structures need to live in @
[11:06:21] <cscott> and that rust needs <@,&> and <mut> parameterization if it's to avoid code duplication (ie, vec::each, vec::each_mut, etc)
[11:08:18] <bjz> dbaupp: huzzaro
[11:08:51] <dbaupp> cscott: yeah, I've been thinking mut parameterisation would be nice
[11:08:57] *** Joins: samnardoni (samnardoni@moz-ECB14881.cable.virginmedia.com)
[11:09:07] <dbaupp> bjz: hopefully it's correct-ish ;)
[11:09:12] <aatch> dbaupp, bjz, what worked?
[11:09:29] <bjz> lexical ordering for tuples
[11:09:33] <bjz> 2-12
[11:09:45] <cscott> dbaupp: it would also be nice if your carefully-checked unique-pointer code also Just Worked once you started throwing around @ references.
[11:09:54] <dbaupp> aatch: tuples are now Ord'd and Total{Eq,Ord}'d
[11:10:18] <dbaupp> aatch: and there are accesssors, (1,2,3).n2()
[11:10:19] <cscott> dbaupp: ie, it's the same code, you just skip all the frees
[11:10:36] <aatch> dbaupp, ah, I saw that.
[11:10:45] *** Quits: samnardoni (samnardoni@moz-ECB14881.cable.virginmedia.com) (Ping timeout)
[11:10:52] <dbaupp> cscott: yeah, it would be nice
[11:14:31] <kimundi> cscott: that sounds like it would go along with the dynamic sized datatypes and custom smartpointer stuff nmatsakis and graydon are currently talking about
[11:15:16] <cscott> dynamic sized datatypes?
[11:16:24] <kimundi> http://smallcultfollowing.com/babysteps/blog/2013/04/30/dynamically-sized-types/
[11:16:36] *** Quits: cdidd (cdidd@C60D1DFD.8AFAB4CD.62D8163C.IP) (Ping timeout)
[11:20:43] *** Joins: BizarreCake (BizarreCak@32C9829A.151E84E7.561471F8.IP)
[11:22:41] *** Quits: z0w0 (zack@moz-780F7535.lns9.cha.bigpond.net.au) (Quit: Leaving.)
[11:23:44] *** Joins: berak (chatzilla@288BEF2A.5F42470D.16E13E53.IP)
[11:28:34] *** Quits: int3_ (int3_@moz-B7B5F043.singnet.com.sg) (Client exited)
[11:31:19] *** Quits: jensnockert (jensnocker@moz-153756A.mobileonline.telia.com) (Input/output error)
[11:32:28] *** Quits: whidgle (Mibbit@8DC562F6.74F864AC.FD2437D8.IP) (Quit: http://www.mibbit.com ajax IRC Client)
[11:32:56] *** Joins: engla (engla@moz-DBD1D96E.cust.bredbandsbolaget.se)
[11:33:50] *** Joins: rusti_ (rusti@moz-54F7FD49.cpe.net.cable.rogers.com)
[11:34:02] *** Quits: rusti (rusti@moz-54F7FD49.cpe.net.cable.rogers.com) (Connection reset by peer)
[11:34:02] *** Quits: rusti_ (rusti@moz-54F7FD49.cpe.net.cable.rogers.com) (Client exited)
[11:35:53] *** Joins: anshin (nbs@441B8B9E.2055B963.D2A6B5.IP)
[11:36:17] *** Joins: rusti (rusti@moz-54F7FD49.cpe.net.cable.rogers.com)
[11:50:24] <dbaupp> aatch: you have a stray e in the issue number in #6614
[11:50:49] <dbaupp> (yay typing! :P )
[11:55:31] <aatch> dbaupp, in my defense, my computer decided that typing was really low on the list of things to respond to
[11:58:19] *** Joins: maxli (maxli@C03F2759.C70D537E.2FA4EA88.IP)
[11:58:53] *** Joins: int3_ (int3_@moz-B7B5F043.singnet.com.sg)
[12:03:09] *** Joins: samnardoni (samnardoni@moz-ECB14881.cable.virginmedia.com)
[12:03:39] *** Quits: maxli (maxli@C03F2759.C70D537E.2FA4EA88.IP) (Ping timeout)
[12:06:43] <cmr> dbaupp: pong
[12:07:15] <dbaupp> cmr: ermm... I've forgotten what I was pinging you about
[12:07:29] <cmr> I think it was about https://github.com/mozilla/rust/pull/6601
[12:07:35] *** Quits: samnardoni (samnardoni@moz-ECB14881.cable.virginmedia.com) (Ping timeout)
[12:07:45] <dbaupp> cmr: oh, yup, there was that
[12:07:47] <dbaupp> cmr: but also
[12:08:01] <dbaupp> rusti: stringify!(SELECT bar.a, COUNT(*) FROM foo AS bar WHERE X = 1 AND y = 2 GROUP BY a)
[12:08:06] -rusti- "SELECT bar . a , COUNT ( * ) FROM foo AS bar WHERE X = 1 AND y = 2 GROUP BY a"
[12:08:24] <dbaupp> i.e. SQL does tokenise fine
[12:08:25] <cmr> dohoho
[12:08:28] <cmr> so it is possible
[12:08:31] <cmr> sweet!
[12:08:42] <benh> What's stringify?
[12:08:47] <dbaupp> (but yeah, 6601 needs a rebase)
[12:08:49] <benh> Token tree -> string?
[12:08:52] <dbaupp> benh: yes
[12:09:29] <benh> aw
[12:09:41] *** Quits: int3_ (int3_@moz-B7B5F043.singnet.com.sg) (Ping timeout)
[12:09:44] <benh> rusti: stringify!(foo /** bar */)
[12:09:46] -rusti- "foo /** bar */"
[12:09:48] <cmr> whoa did brson's patch actually land?
[12:09:52] <benh> rusti: stringify!(foo /// bar)
[12:09:53] -rusti- foo.rs:6:4: 6:5 error: incorrect close delimiter: `}`
[12:09:53] -rusti- foo.rs:6     });
[12:09:53] -rusti-              ^
[12:09:54] <benh> how asymmetric!
[12:10:07] <dbaupp> cmr: looks like it
[12:10:12] <cmr> awesome! :D
[12:10:17] <dbaupp> benh: I guess comments are special
[12:10:24] <benh> some of them! :D
[12:10:41] <cmr> Well
[12:10:44] <benh> /* */ comments disappear
[12:10:46] <cmr> /** ... */ is closed.
[12:10:50] *** Joins: maxli (maxli@C03F2759.C70D537E.2FA4EA88.IP)
[12:10:53] <cmr> But /// comments to the end of the line
[12:11:00] <dbaupp> rusti: stringify!(1 /* 2 */ 3)
[12:11:01] -rusti- "1 3"
[12:12:50] <benh> works with a newline within the !( ) though :)
[12:15:27] <aatch> dbaupp, with 6616, how is it different from just #[inline]?
[12:15:49] <dbaupp> aatch: #[inline] gives LLVM an inlining hint
[12:16:02] <dbaupp> which is closer to "command" than "hint"
[12:16:27] <dbaupp> i.e. it's too aggressive for just saying "please allow this to be inlined if LLVM thinks it'd be better"
[12:16:44] <cmr> inlining is a hard problem
[12:16:57] <dbaupp> so inline(maybe) puts the necessary metadata in the crate file so that inlining can happen cross-crate
[12:17:12] <dbaupp> but it doesn't actually hint/force it
[12:17:35] <dbaupp> (like #[inline] and #[inline(always)])
[12:17:50] <aatch> dbaupp, ahh, makes sense
[12:17:59] <aatch> I forgot about that.
[12:18:55] <cmr> r? https://github.com/mozilla/rust/pull/6601
[12:18:57] *** Quits: bytbox (s@moz-D83E9B31.wireless.umd.edu) (Ping timeout)
[12:19:34] <dbaupp> cmr: that was quick! (before lunch this time :P )
[12:19:44] <cmr> rebasing is easy :p
[12:19:47] <dbaupp> (depending on your timezone...)
[12:19:53] <cmr> there were only conflicts in like 7 files
[12:20:00] <dbaupp> ah, I see
[12:20:09] <dbaupp> easy as pie
[12:20:16] <aatch> cmr, r'd
[12:20:20] <cmr> thanks
[12:20:42] <dbaupp> now bors will swoop in
[12:21:56] <aatch> eventually
[12:22:03] <cmr> hopefully
[12:22:42] <aatch> (bors only just saw that it was mergable)
[12:22:48] <aatch> mergeable?
[12:22:55] <aatch> I dunno...
[12:24:15] *** Joins: ghrust (ghrust@moz-4EF5B6E5.rs.github.com)
[12:24:15] <ghrust> 01[13rust01] 15bors pushed 0 new commits to 06auto: 02http://git.io/RwMcXQ
[12:24:15] *** Parts: ghrust (ghrust@moz-4EF5B6E5.rs.github.com) ()
[12:24:18] *** Joins: ghrust (ghrust@moz-4EF5B6E5.rs.github.com)
[12:24:18] <ghrust> 01[13rust01] 15bors pushed 2 new commits to 06auto: 02http://git.io/aHeb0Q
[12:24:18] <ghrust> 13rust/06auto 14cc57ca0 15Corey Richardson: Use assert_eq! rather than assert! where possible
[12:24:18] <ghrust> 13rust/06auto 145cbdc53 15bors: auto merge of #6601 : cmr/rust/assert_eq, r=Aatch
[12:24:18] *** Parts: ghrust (ghrust@moz-4EF5B6E5.rs.github.com) ()
[12:26:59] <aatch> well there it goes
[12:27:01] *** Joins: bytbox (s@moz-D83E9B31.wireless.umd.edu)
[12:31:09] *** Joins: Axord (xord@moz-C3CCF156.lsanca.dsl-w.verizon.net)
[12:32:52] <aatch> dbaupp, would making #[inline] be what you added, and having the current meaning of #[inline] be #[inline(local)] make sense?
[12:33:08] <dbaupp> aatch: inline(local)?
[12:33:23] <aatch> inline only in the local crate
[12:33:27] <dbaupp> #[inline] does allow cross-crate inlining
[12:33:33] <aatch> dbaupp, it does?
[12:33:39] <aatch> I thought it didn't...
[12:33:43] *** Joins: Blei (philipp@moz-96D25F7A.cust.bluewin.ch)
[12:33:45] <dbaupp> it's basically #[inline(always)] but a little bit softer
[12:33:46] <aatch> NEVERMIND THEN
[12:33:50] <dbaupp> heh
[12:34:12] * aatch zoidbergs away
[12:34:25] <dbaupp> #[inline], #[inline(often)] and #[inline(always)] might be nicer (?)
[12:36:02] <aatch> #[inline] #[inline(please)] #[inline(pretty_please)]
[12:36:10] *** Quits: bytbox (s@moz-D83E9B31.wireless.umd.edu) (Ping timeout)
[12:36:21] <cmr> #[inline(only_if_it_doesnt_inconvenience_you)]
[12:36:49] <aatch> #[inline(dont_put_yourself_out_though)]
[12:36:53] *** Joins: bytbox (s@moz-D83E9B31.wireless.umd.edu)
[12:37:43] *** Quits: maxli (maxli@C03F2759.C70D537E.2FA4EA88.IP) (Quit: Leaving.)
[12:38:53] <aatch> #[inline(or_youre_fired)]
[12:38:59] <cmr> hah
[12:42:36] *** Joins: samnardoni (samnardoni@moz-ECB14881.cable.virginmedia.com)
[12:42:43] *** kimundi is now known as zz_kimundi
[12:47:39] *** zz_kimundi is now known as kimundi
[12:49:14] <bjz> aatch: we need #[please
[12:49:16] <bjz> ]
[12:50:10] *** Joins: a_m0d (a_m0d@moz-9F925EFA.hm.shawcable.net)
[12:51:21] <dbaupp> rusti: #[please] fn work() -> int { fail!() } work()
[12:51:22] -rusti- rust: task failed at 'explicit failure', foo.rs:4
[12:51:22] -rusti- rust: domain main @0x88a1b0 root task failed
[12:51:34] <dbaupp> bjz: it currently works :P
[12:56:54] *** Quits: a_m0d (a_m0d@moz-9F925EFA.hm.shawcable.net) (Quit: Leaving.)
[13:00:27] <kimundi> I heard a suggestion for #[wip] once but I can't remember what it was about
[13:02:39] <kimundi> Maybe for allowing functions with empty bodies? Adding an implicit 'fail("not yet implemented")'?
[13:04:22] *** Joins: MrFahrenheit (RageOfThou@3FEF494C.29C984D5.783DEDCA.IP)
[13:04:44] *** Joins: int3_ (int3_@moz-B7B5F043.singnet.com.sg)
[13:07:25] *** Joins: cdidd (cdidd@moz-C64D5DE3.broadband.corbina.ru)
[13:07:43] *** Joins: ysuzuki (ysuzuki@moz-60FA9D06.net119083145.t-com.ne.jp)
[13:07:46] <engla> something easy would be neat. In Python, it's a habit to stub out with    def f(x,y): pass.  in haskell, with   f = undefined
[13:10:19] <cmr> fn foo() { () } ?
[13:10:40] *** Quits: tgt (tgt@moz-D59EE478.aztw.cable.virginmedia.com) (Quit: Computer has gone to sleep.)
[13:10:44] <engla> well fail!() does it today
[13:10:50] <engla> I guess that's ok
[13:13:04] *** Quits: aatch (aatch@moz-2BB0AC01.cable.telstraclear.net) (Quit: Leaving)
[13:14:17] *** Quits: int3_ (int3_@moz-B7B5F043.singnet.com.sg) (Client exited)
[13:16:25] <engla> I didn't know fail accepted 0 arguments
[13:17:01] *** Quits: MrFahrenheit (RageOfThou@3FEF494C.29C984D5.783DEDCA.IP) (Quit: Leaving)
[13:19:17] *** Joins: hmax_ (hmax@moz-15514FA1.yandex.net)
[13:23:23] *** Joins: MrFahrenheit (RageOfThou@3FEF494C.29C984D5.783DEDCA.IP)
[13:24:56] *** Joins: int3_ (int3_@moz-B7B5F043.singnet.com.sg)
[13:27:14] *** Joins: ghrust (ghrust@moz-4EF5B6E5.rs.github.com)
[13:27:14] <ghrust> 01[13rust01] 15bors merged 06auto into 06incoming: 02http://git.io/aHeb0Q
[13:27:14] *** Parts: ghrust (ghrust@moz-4EF5B6E5.rs.github.com) ()
[13:30:32] <cmr> yay
[13:31:58] <dbaupp> cmr: I think you might win for largest commit
[13:32:15] <cmr> heh
[13:33:35] <EXetoC> yet another browser killer :p
[13:34:23] *** Joins: jviereck (Adium@moz-25A97802.hsi4.kabel-badenwuerttemberg.de)
[13:36:19] *** Quits: bjz (brendanzab@B398BE78.F804C29E.D35A31DF.IP) (Ping timeout)
[13:43:00] *** Joins: hmax__ (hmax@moz-6DFD5A0D.yandex.net)
[13:43:09] *** Quits: hmax_ (hmax@moz-15514FA1.yandex.net) (Ping timeout)
[13:45:47] *** Quits: bytbox (s@moz-D83E9B31.wireless.umd.edu) (Ping timeout)
[13:46:14] *** Joins: tgt (tgt@moz-D59EE478.aztw.cable.virginmedia.com)
[13:49:14] <kimundi> engla: fail now also accepts N arguments :)
[13:50:31] *** Joins: zakora (NC@moz-8EAF945F.fbx.proxad.net)
[13:50:32] *** Quits: zakora (NC@moz-8EAF945F.fbx.proxad.net) (Max SendQ exceeded)
[13:50:58] *** Joins: zakora (NC@moz-8EAF945F.fbx.proxad.net)
[13:51:00] *** Quits: zakora (NC@moz-8EAF945F.fbx.proxad.net) (Max SendQ exceeded)
[13:51:24] *** Joins: zakora (NC@moz-8EAF945F.fbx.proxad.net)
[13:58:11] *** Joins: bytbox (s@moz-D83E9B31.wireless.umd.edu)
[13:59:47] *** Quits: samnardoni (samnardoni@moz-ECB14881.cable.virginmedia.com) (Client exited)
[14:00:11] *** Joins: wilsonk-laptop (kvirc@moz-39EFBFC2.cg.shawcable.net)
[14:02:00] *** Quits: wilsonk-laptop (kvirc@moz-39EFBFC2.cg.shawcable.net) (Ping timeout)
[14:10:08] *** Joins: dherman (dherman@moz-6CA476B1.hsd1.ca.comcast.net)
[14:10:08] *** ChanServ sets mode: +o dherman
[14:10:26] *** Quits: Blei (philipp@moz-96D25F7A.cust.bluewin.ch) (Quit: WeeChat 0.4.0)
[14:18:53] *** Joins: davbo (dave@moz-E2C65EB0.zone11.bethere.co.uk)
[14:18:59] *** Quits: dherman (dherman@moz-6CA476B1.hsd1.ca.comcast.net) (Quit: dherman)
[14:19:18] *** Joins: nielsle (nielsle@moz-5CE8ECCD.boa.fiberby.dk)
[14:20:30] *** Joins: Yurume (yurume@AC58A8CE.8A059B47.E313B915.IP)
[14:25:03] *** Joins: SiegeLord (sl@moz-CAF07B4C.hsd1.ma.comcast.net)
[14:26:00] *** Joins: samnardoni (samnardoni@moz-ECB14881.cable.virginmedia.com)
[14:29:20] *** Joins: Blei (philipp@moz-96D25F7A.cust.bluewin.ch)
[14:30:37] *** Quits: CMCL (cmcl@moz-8C2E912C.co.uk) (Ping timeout)
[14:31:21] *** Joins: kud1ing (Mibbit@moz-18233A17.pools.arcor-ip.net)
[14:31:36] *** Joins: CMCL (cmcl@moz-8C2E912C.co.uk)
[14:31:47] <kud1ing> @rusti: let a = 42; println(fmt!("%d", a));
[14:32:03] *** Joins: steven_is_false (user@moz-144077DE.bchsia.telus.net)
[14:32:03] <kud1ing> @rusti: let a = 42; print(fmt!("%d", a));
[14:32:07] <cmr> rusti: let a = 42; println(fmt!("%d", a));
[14:32:10] -rusti- 42
[14:32:29] <kud1ing> rusti: let a = 42; print(fmt!("%d", a));
[14:32:30] -rusti- 42
[14:32:45] <cmr> can also do:
[14:32:47] <kud1ing> my local rusti says 42 and ~"42"
[14:32:57] <cmr> rusti: fmt!("%d", 52)
[14:32:58] -rusti- ~"52"
[14:33:13] <kud1ing> i wonder about the diefference
[14:33:22] <dbaupp> kud1ing: IRC-rusti isn't normal rusti
[14:34:00] <kud1ing> IRS-kud1ing isn't normal kud1ing either :P
[14:34:28] <kud1ing> dbaupp:i mean i wonder about local rusti's 42 vs ~"42"
[14:34:47] <cmr> Well
[14:34:49] <kud1ing> println vs print
[14:34:50] <cmr> fmt!() returns a ~str
[14:34:53] <steven_is_false> So earlier, I suggested replacing large types like IsaacRng (2024 bytes!) with owned boxes of the actual implementation to remove the accidental possibility of doing expensive copies. But apparently that's a bad idea to the fact that people might want to use reference counted boxes, or managed boxes. What does anyone think about using borrowed pointers?
[14:35:18] <dbaupp> steven_is_false: how would that work?
[14:35:20] <cmr> The real question, IMO, is why is println not just print(...) + print("\n")
[14:35:32] <kud1ing> cmr: yeah, sort of what i wondered
[14:35:34] <steven_is_false> dbaupp: let x : &'static () = @ (); works
[14:35:45] <dbaupp> (i.e. you can't return a borrowed pointer to something you create in a function)
[14:36:15] <dbaupp> rusti: fn f() -> &int { let x = 1; &x } f()
[14:36:24] -rusti- more than 5 lines of output, pastebinned: http://sprunge.us/PXFg
[14:36:38] <steven_is_false> rusti: fn f() -> &int { @4 } f ()
[14:36:46] -rusti- more than 5 lines of output, pastebinned: http://sprunge.us/OOgj
[14:36:51] <kud1ing> cmr: i am not sure where ~"42" comes from
[14:37:02] <dbaupp> steven_is_false: it's also important to make allocations optional
[14:37:10] <dbaupp> (where they can be optional)
[14:37:14] <steven_is_false> rusti: fn f() -> &int { let x : &'static int = @4; x } f ()
[14:37:16] <cmr> kud1ing: My guess is it's printing fmt!("%?", foo), but I'd have to check the source.
[14:37:16] *** Quits: jviereck (Adium@moz-25A97802.hsi4.kabel-badenwuerttemberg.de) (Quit: Leaving.)
[14:37:16] -rusti- more than 5 lines of output, pastebinned: http://sprunge.us/GWAX
[14:37:21] <kud1ing> cmr: i'd expect a 42 to be printed
[14:37:34] <cmr> rusti: println(fmt!("%?", fmt!("%d", 42)))
[14:37:35] -rusti- ~"42"
[14:37:51] <dbaupp> steven_is_false: i.e. someone might be in a position where want to avoid malloc completely
[14:38:06] <steven_is_false> dbaupp: Right, I have a scheme that also allows for the alternative,  fn new <T> (f : fn (IsaacRng) -> T) -> T;
[14:38:11] <dbaupp> even if they end up with huge types on the stack
[14:38:13] <cmr> Nope, it's just stdout().write_str(s)...
[14:38:16] <cmr> kud1ing: this is weird
[14:38:35] <cmr> kud1ing: It might be rusti doing special handling of println/print?
[14:38:43] <dbaupp> steven_is_false: I don't quite see how that gets around the implicit-copying issue?
[14:38:43] <kud1ing> cmr: i wanted to file an issue, but i am not sure against what part
[14:39:11] <kud1ing> on a side note, i am very pleased that rusti is more usable
[14:39:20] <dbaupp> steven_is_false: (sorry if i'm seeming aggressive about this :S )
[14:39:26] <kimundi> kud1ing: rusti here prints ~"42" because it pipes the last expression into a fmt!("%?")
[14:39:30] <steven_is_false> dbaupp: pub struct IsaacRng <'self> { contents: &'self IsaacRng_ }.
[14:39:32] <kimundi> rusti: 42
[14:39:34] -rusti- 42
[14:39:49] <dbaupp> steven_is_false: I see...
[14:39:52] <kimundi> rusti: fmt!("%?", 42)
[14:39:53] -rusti- ~"42"
[14:40:04] <kimundi> rusti: ~"42"
[14:40:06] -rusti- ~"42"
[14:40:37] <dbaupp> that then introduces a layer of indirection => slower always. whereas the copies thing is slower sometimes, and in a diagonosable way
[14:40:45] <kud1ing> kimundi: do yo have an idea why it does not occur for println()?
[14:41:03] <cmr> kud1ing: Oh, I see
[14:41:09] <cmr> kud1ing: src/librusti/wrapper.rs
[14:41:25] <cmr> fn print<T>(result: T) { io::println(fmt!("%?", result)); }
[14:41:32] <kimundi> I have no idea how rusti-the-program works
[14:41:34] <kud1ing> oh
[14:41:47] <kimundi> Just how rusti-the-bot-here
[14:41:49] <kud1ing> cmr: good catch, thanks
[14:42:08] <kud1ing> rusti the bot sounds like Krusti the clown
[14:42:21] <kud1ing> Krusty
[14:42:21] <kimundi> hehe
[14:42:52] <dbaupp> steven_is_false: have you considered adding a "large_implicit_copies" lint?
[14:43:15] <steven_is_false> dbaupp: I actually put up an issue for something similar to that the other day ago.
[14:43:18] <kimundi> rusti: run::run_program(~"cat", ~[~"foo.rs"]);
[14:43:19] -rusti- more than 5 lines of output, pastebinned: http://sprunge.us/GDNQ
[14:43:30] <dbaupp> steven_is_false: ah cool :)
[14:43:49] <steven_is_false> dbaupp: My suggestion was simply warn on large data types though which is a bit different.
[14:44:07] <kud1ing> i think i file an issue for rusti
[14:44:26] <dbaupp> steven_is_false: warn at the site of definition?
[14:44:36] <steven_is_false> dbaupp: Also there are these really weird, and strange pathological edge-cases for medium sized powers of two structures with the cache.
[14:44:43] <steven_is_false> dbaupp: Yes warn at the site of definition.
[14:45:06] <cmr> implicit-copies     warn  implicit copies of non implicitly copyable data
[14:45:13] <dbaupp> a warning like that wouldn't help users with IsaacRng etc, since they're defined in a different crate
[14:45:19] <cmr> erm... if it's not implicitly copyable, shouldn't it... not work?
[14:46:09] <kimundi> cmr: I think that might be for implicit copies enabled with an other attribute
[14:46:14] <steven_is_false> The thing is that even if a value isn't copyable it can still be moved which can be expensive.
[14:46:37] <cmr> steven_is_false: moves are a compiletime static analysis thing, aren't they?
[14:46:51] <dbaupp> cmr: they zero-on-move
[14:47:16] <dbaupp> (i.e. it actually has to move the data, because variable points to specific points in memory, and it zeros the old region)
[14:47:21] <steven_is_false> cmr: I'm sure there are lots more optimizations that can be done on moves versus copies but they still aren't perfect.
[14:47:26] *** Joins: jviereck (Adium@moz-25A97802.hsi4.kabel-badenwuerttemberg.de)
[14:47:26] <dbaupp> *variables point
[14:47:33] <kimundi> cmr: moves are a shallow copy with thoe original data inaccesible afterwards
[14:47:41] <steven_is_false> dbaupp: Oh really! It HAS to move.
[14:48:13] * cmr is still uncomfortable with rust's semantics
[14:48:25] <kimundi> cmr: why?
[14:48:25] <dbaupp> steven_is_false: yes (i'm not sure if that's sarcastic or not, sorry?)
[14:48:36] <cmr> kimundi: uncomfortable as in unfamiliar
[14:48:43] <kimundi> ah, okay :)
[14:49:08] <steven_is_false> dbaupp: I'm not sarcastic. I'm really surprized that they have to move all the time (unless they don't I still don't really understant what you mean.)
[14:49:25] <dbaupp> steven_is_false: what sort of scale are "medium sized" structures for caches?
[14:49:55] <dbaupp> steven_is_false: well, if you have `let x = ~[], y; ...; y = x;`
[14:50:05] *** Quits: kud1ing (Mibbit@moz-18233A17.pools.arcor-ip.net) (Quit: http://www.mibbit.com ajax IRC Client)
[14:50:15] <dbaupp> both x and y have a definite memory address (i.e. there is an 8 byte block for each of them)
[14:50:33] <steven_is_false> dbaupp: I don't know too much about this but I was reading a paper on optimizing matrix operations on large matrices, and they were working with large 512 element matrices.
[14:50:38] <cmr> Since rustc errors on use of moved value, I wouldn't have expected them to have any runtime ramifications.
[14:50:53] *** Joins: Jesin (Jessin_@moz-5654D37.washdc.fios.verizon.net)
[14:50:54] <dbaupp> so the move y = x has to take the value of x and put it in y it's not just a relabeling like in Python
[14:51:26] <dbaupp> (at the moment, it also zeros x)
[14:51:36] *** Joins: maxli (maxli@C03F2759.C70D537E.2FA4EA88.IP)
[14:51:44] <dbaupp> steven_is_false: 512x512 or 512 in total?
[14:51:52] <kimundi> cmr: They don't have runtime ramifications, it's just not really possibleto 'move' data in hardware
[14:52:07] <steven_is_false> dbaupp: Uggh, I really don't remember.
[14:52:19] <kimundi> cmr: So in hardware, a move is still a copy.
[14:52:21] <cmr> kimundi: Oh! I see, it's because it's by-value, yes?
[14:52:24] <dbaupp> steven_is_false: I'd guess the former, since 512 isn't a square
[14:52:25] <kimundi> yes
[14:52:33] <cmr> If it were a pointer it'd just be shuffling pointers around.
[14:52:38] <kimundi> jup
[14:52:45] <cmr> Ok, that makes sense now.
[14:52:59] <dbaupp> cmr: for pointer types, it is shuffling pointers around ;)
[14:53:40] <dbaupp> steven_is_false: and a 512x512 f64 matrix is 2MB
[14:53:50] *** Quits: samnardoni (samnardoni@moz-ECB14881.cable.virginmedia.com) (Client exited)
[14:53:50] <dbaupp> so maybe not... because that's pretty big
[14:54:26] <cmr> For moves of large values, it'd be interesting to try using http://blosc.pytables.org/trac
[14:55:05] <cmr> I don't think it'd interact very well with the concurrency model, though. Unsure.
[14:55:15] <steven_is_false> cmr: Sort of like how writing, and reading compressed data to disk, or a network can be faster sometimes?
[14:55:26] <cmr> steven_is_false: yup.
[14:56:34] *** Joins: samnardoni (samnardoni@moz-ECB14881.cable.virginmedia.com)
[14:56:53] <heftig> hm, does libuv have a sctp extension?
[14:59:28] *** Joins: bjz (brendanzab@B398BE78.F804C29E.D35A31DF.IP)
[14:59:35] <dbaupp> steven_is_false: reading your issue, I don't disagree
[14:59:59] <dbaupp> so #[allow(large_types)] struct IsaacRng { .. } would let it pass without warning
[15:00:46] <steven_is_false> dbaupp: Well you did suggest the alternative of a warning for copying the large types around.
[15:00:58] <cmr> Both would be good I think
[15:01:03] <dbaupp> steven_is_false: they're mostly orthogonal
[15:01:17] <steven_is_false> dbaupp: If you say so.
[15:01:20] <dbaupp> i.e. you might want to make a large type, but not copy it around
[15:01:25] <dbaupp> (accdidentally)
[15:01:53] <steven_is_false> dbaupp: Fair enough.
[15:02:11] <dbaupp> I'll add a note to the issue
[15:02:51] <steven_is_false> cool
[15:04:02] *** Quits: samnardoni (samnardoni@moz-ECB14881.cable.virginmedia.com) (Client exited)
[15:06:20] <dbaupp> done
[15:07:55] *** Quits: jviereck (Adium@moz-25A97802.hsi4.kabel-badenwuerttemberg.de) (Ping timeout)
[15:09:36] *** Quits: otters (joel@moz-82AAB099.rs) (Ping timeout)
[15:09:52] *** Joins: otters (joel@moz-82AAB099.rs)
[15:13:03] *** Joins: jviereck (Adium@moz-25A97802.hsi4.kabel-badenwuerttemberg.de)
[15:13:29] *** Joins: bbrittain (ben@moz-A7CDB794.dia.static.qwest.net)
[15:14:30] *** Joins: dave_ (dave@moz-E2C65EB0.zone11.bethere.co.uk)
[15:15:00] *** Quits: jaen (jaen@moz-E0979827.copit.pl) (Ping timeout)
[15:15:14] *** Joins: ghrust (ghrust@moz-4EF5B6E5.rs.github.com)
[15:15:14] <ghrust> 01[13rust01] 15bors pushed 0 new commits to 06auto: 02http://git.io/UyHiJw
[15:15:14] *** Parts: ghrust (ghrust@moz-4EF5B6E5.rs.github.com) ()
[15:15:16] *** Joins: ghrust (ghrust@moz-4EF5B6E5.rs.github.com)
[15:15:16] <ghrust> 01[13rust01] 15bors pushed 2 new commits to 06auto: 02http://git.io/4Fb3Kw
[15:15:16] <ghrust> 13rust/06auto 14d953a5c 15Daniel Micay: replace old_iter::repeat with the Times trait
[15:15:16] <ghrust> 13rust/06auto 149f67169 15bors: auto merge of #6106 : thestinger/rust/iter, r=bstrie...
[15:15:17] *** Parts: ghrust (ghrust@moz-4EF5B6E5.rs.github.com) ()
[15:15:37] *** Quits: davbo (dave@moz-E2C65EB0.zone11.bethere.co.uk) (Ping timeout)
[15:16:30] *** Joins: jaen (jaen@moz-E0979827.copit.pl)
[15:18:19] *** Quits: steven_is_false (user@moz-144077DE.bchsia.telus.net) (Ping timeout)
[15:18:36] *** Quits: DasIch (DasIch@moz-7447F66F.dip0.t-ipconnect.de) (Ping timeout)
[15:18:53] *** Joins: DasIch (DasIch@moz-CB618802.dip0.t-ipconnect.de)
[15:26:43] *** Joins: dherman (dherman@moz-6CA476B1.hsd1.ca.comcast.net)
[15:26:43] *** ChanServ sets mode: +o dherman
[15:28:43] *** Quits: dherman (dherman@moz-6CA476B1.hsd1.ca.comcast.net) (Quit: dherman)
[15:32:24] *** Joins: cary (cary@moz-F817A28B.static.twtelecom.net)
[15:33:53] *** Quits: jviereck (Adium@moz-25A97802.hsi4.kabel-badenwuerttemberg.de) (Quit: Leaving.)
[15:34:49] *** Quits: ysuzuki (ysuzuki@moz-60FA9D06.net119083145.t-com.ne.jp) (Client exited)
[15:35:22] *** Quits: dbaupp (Thunderbir@moz-856B3C14.lns20.syd6.internode.on.net) (Ping timeout)
[15:37:39] *** Quits: Diablo-D3 (diablo@moz-6317EE8A.port.east.myfairpoint.net) (Quit: This computer has gone to sleep)
[15:39:12] *** Quits: pigoz (pigoz@moz-93D3080C.as5577.net) (Quit: WeeChat 0.4.0-dev)
[15:39:29] *** Quits: Jesin (Jessin_@moz-5654D37.washdc.fios.verizon.net) (Quit: Leaving)
[15:39:48] *** Joins: hjr3 (hradtke@AF4FC8FE.D2A4E84D.523CBD62.IP)
[15:40:16] *** Quits: anshin (nbs@441B8B9E.2055B963.D2A6B5.IP) (Quit: Lost terminal)
[15:45:54] *** Quits: hmax__ (hmax@moz-6DFD5A0D.yandex.net) (Quit: ????? ? ?? ??? (xchat 2.4.5 ??? ??????))
[15:45:54] *** Joins: blitter (blitter@moz-7C98731E.dyn.centurytel.net)
[15:48:18] *** dave_ is now known as davbo
[15:51:40] *** Joins: Cromulent (Cromulent@moz-983B638D.cable.virginmedia.com)
[15:56:14] *** Quits: maxli (maxli@C03F2759.C70D537E.2FA4EA88.IP) (Quit: Leaving.)
[15:59:27] *** Quits: DasIch (DasIch@moz-CB618802.dip0.t-ipconnect.de) (Quit: DasIch)
[16:00:22] *** Quits: KindOne (KindOne@70EC82D.5D2364C3.EC6A1518.IP) (Ping timeout)
[16:03:58] *** Joins: KindOne (KindOne@moz-83DC5EFC.dynamic.ip.windstream.net)
[16:04:25] *** Joins: samnardoni (samnardoni@moz-ECB14881.cable.virginmedia.com)
[16:06:06] *** Quits: hjr3 (hradtke@AF4FC8FE.D2A4E84D.523CBD62.IP) (Quit: My MacBook has gone to sleep. ZZZzzzâ€¦)
[16:06:13] *** Quits: samnardoni (samnardoni@moz-ECB14881.cable.virginmedia.com) (Ping timeout)
[16:07:07] *** Joins: steven_is_false (user@moz-144077DE.bchsia.telus.net)
[16:08:38] *** Quits: TD-Linux (TD-Linux@E338EB99.2B4F0AE0.A0A36CCE.IP) (Ping timeout)
[16:08:40] *** Quits: KindOne (KindOne@moz-83DC5EFC.dynamic.ip.windstream.net) (Ping timeout)
[16:12:09] *** Joins: TD-Linux (TD-Linux@E338EB99.2B4F0AE0.A0A36CCE.IP)
[16:12:14] *** Joins: ghrust (ghrust@moz-4EF5B6E5.rs.github.com)
[16:12:14] <ghrust> 01[13rust01] 15bors merged 06auto into 06incoming: 02http://git.io/4Fb3Kw
[16:12:14] *** Parts: ghrust (ghrust@moz-4EF5B6E5.rs.github.com) ()
[16:12:43] *** Quits: cary (cary@moz-F817A28B.static.twtelecom.net) (Quit: cary)
[16:13:58] *** Joins: KindOne (KindOne@moz-15A65BA9.dynamic.ip.windstream.net)
[16:14:26] *** Joins: ysuzuki (ysuzuki@moz-60FA9D06.net119083145.t-com.ne.jp)
[16:14:36] *** Quits: victorporof (victorporo@10AA7997.880C8D58.79933D60.IP) (Quit: victorporof)
[16:18:44] *** Quits: KindOne (KindOne@moz-15A65BA9.dynamic.ip.windstream.net) (Ping timeout)
[16:22:52] *** Joins: KindOne (KindOne@moz-161C3730.dynamic.ip.windstream.net)
[16:23:38] *** Joins: wilsonk-laptop (kvirc@moz-39EFBFC2.cg.shawcable.net)
[16:26:57] *** Joins: catpig (catpig@moz-2864D03.dip0.t-ipconnect.de)
[16:27:44] *** Quits: KindOne (KindOne@moz-161C3730.dynamic.ip.windstream.net) (Ping timeout)
[16:31:42] *** Joins: KindOne (KindOne@moz-1DC51BE4.dynamic.ip.windstream.net)
[16:32:18] *** Joins: infynyxx (infynyxx@moz-8BE8F2CD.hsd1.md.comcast.net)
[16:34:19] *** Quits: steven_is_false (user@moz-144077DE.bchsia.telus.net) (Ping timeout)
[16:34:19] *** Quits: KindOne (KindOne@moz-1DC51BE4.dynamic.ip.windstream.net) (Ping timeout)
[16:35:18] *** Joins: steven_is_false (user@moz-144077DE.bchsia.telus.net)
[16:35:30] *** Joins: KindOne (KindOne@moz-2FA4899D.dynamic.ip.windstream.net)
[16:38:39] *** Quits: KindOne (KindOne@moz-2FA4899D.dynamic.ip.windstream.net) (Ping timeout)
[16:38:42] *** Quits: pyrac (pyrac@moz-C70D038B.w109-214.abo.wanadoo.fr) (Quit: pyrac)
[16:39:34] *** Quits: CMCL (cmcl@moz-8C2E912C.co.uk) (Ping timeout)
[16:39:35] *** Joins: CMCL (cmcl@moz-8C2E912C.co.uk)
[16:39:59] *** Joins: huanghongqiao (Mibbit@733ACF2E.74F864AC.FD2437D8.IP)
[16:40:29] <huanghongqiao> hello,everybody!
[16:40:35] <cmr> hullo
[16:40:36] *** Joins: Lorelei83 (Mibbit@AFF8A847.483C040D.9CC6496B.IP)
[16:40:57] <huanghongqiao> what dose the priv mean? private?
[16:41:04] <cmr> Yes
[16:41:12] <Lorelei83> hi
[16:41:32] <huanghongqiao> thanks,cmr
[16:41:59] *** Joins: KindOne (KindOne@moz-2E2F3646.dynamic.ip.windstream.net)
[16:42:54] *** Joins: pyrac (pyrac@moz-C70D038B.w109-214.abo.wanadoo.fr)
[16:43:02] *** Parts: berak (chatzilla@288BEF2A.5F42470D.16E13E53.IP) ()
[16:45:09] <huanghongqiao> I had read the rust tutorial,but i don't known how to use it
[16:45:22] <huanghongqiao> :-)
[16:45:37] *** Quits: jaen (jaen@moz-E0979827.copit.pl) (Ping timeout)
[16:45:47] *** Joins: jaen (jaen@moz-E0979827.copit.pl)
[16:48:16] *** Quits: Cromulent (Cromulent@moz-983B638D.cable.virginmedia.com) (Ping timeout)
[16:51:12] *** Joins: vosen (vosen@moz-266BA656.icpnet.pl)
[16:52:37] <steven_is_false> Hey, I've been really happy with getting support from Rust channel but now that I'm working on a game I'm edging into questions that are a little bit off topic. You're all pretty awesome people so I'd like to hear your recommendations on chat rooms that deal with math heavy topics such as versors, quarternions, matrices and normals. I have some really interesting questions that I want to figure out like finding out the connection
[16:52:37] <steven_is_false> between versors, and normals (is it possible to define something like a surface versor?)
[16:52:55] *** Joins: samnardoni (samnardoni@moz-ECB14881.cable.virginmedia.com)
[16:53:16] *** Quits: jaen (jaen@moz-E0979827.copit.pl) (Ping timeout)
[16:53:26] <cmr> steven_is_false: there's a bunch of great channels in freenode.
[16:53:37] <cmr> ##math, probably some gamedev specific ones
[16:53:53] *** Quits: KindOne (KindOne@moz-2E2F3646.dynamic.ip.windstream.net) (Ping timeout)
[16:53:57] *** Joins: jaen (jaen@moz-E0979827.copit.pl)
[16:55:07] <steven_is_false> cmr: Cool.
[16:55:30] <nielsle> rusti struct A {data : int} ; let a = A {data :2};
[16:55:51] <cmr> rusti: struct A {data : int} ; let a = A {data :2};
[16:55:53] -rusti- foo.rs:5:37: 5:38 warning: unused variable: `a` [-W unused-variable (default)]
[16:55:53] -rusti- foo.rs:5          struct A {data : int} ; let a = A {data :2};
[16:55:53] -rusti-                                               ^
[16:55:53] -rusti- note: in expansion of fmt!
[16:55:53] -rusti- foo.rs:4:12: 6:7 note: expansion site
[16:56:55] <nielsle> Hmm on my local install I just got "leaked memory in rust main loop (1 objects)"
[16:57:34] <cmr> nielsle: rusti-the-bot does not use rusti-the-program. but rusti-the-program was recently fixed; you'll need to build a copy from incoming (or find a precompiled one; there's packages for arch) to get it
[16:57:36] *** Joins: KindOne (KindOne@moz-DFF53C67.dynamic.ip.windstream.net)
[16:58:22] <cmr> rusti: ~"foo" == "foo"
[16:58:25] -rusti- more than 5 lines of output, pastebinned: http://sprunge.us/cBRP
[16:58:31] <nielsle> Thanks
[16:59:19] <huanghongqiao> unused
[16:59:45] *** Quits: int3_ (int3_@moz-B7B5F043.singnet.com.sg) (Client exited)
[16:59:51] <Lorelei83> and i thought this wasn't technical channel:)
[17:00:05] <cmr> Lorelei83: it definitely is
[17:01:08] <Lorelei83> i can see that.. cause i thought you're chatting in english but didn't understand a thing:)
[17:01:14] <huanghongqiao> good night,everybody
[17:01:19] *** Quits: KindOne (KindOne@moz-DFF53C67.dynamic.ip.windstream.net) (Ping timeout)
[17:03:48] *** Parts: Lorelei83 (Mibbit@AFF8A847.483C040D.9CC6496B.IP) ()
[17:04:29] *** Quits: huanghongqiao (Mibbit@733ACF2E.74F864AC.FD2437D8.IP) (Quit: http://www.mibbit.com ajax IRC Client)
[17:04:30] *** Quits: BizarreCake (BizarreCak@32C9829A.151E84E7.561471F8.IP) (Ping timeout)
[17:04:33] *** Joins: robertknight (robertknig@moz-54528EE0.wby.mendeley.com)
[17:04:48] *** Quits: tgt (tgt@moz-D59EE478.aztw.cable.virginmedia.com) (Quit: Computer has gone to sleep.)
[17:05:38] *** Joins: KindOne (KindOne@moz-EF19DCE5.dynamic.ip.windstream.net)
[17:07:06] *** Quits: robertknight (robertknig@moz-54528EE0.wby.mendeley.com) (Quit: Computer has gone to sleep.)
[17:09:13] *** Quits: pyrac (pyrac@moz-C70D038B.w109-214.abo.wanadoo.fr) (Quit: pyrac)
[17:09:33] *** Quits: samnardoni (samnardoni@moz-ECB14881.cable.virginmedia.com) (Client exited)
[17:13:07] *** Quits: jaen (jaen@moz-E0979827.copit.pl) (Ping timeout)
[17:13:19] *** Joins: jaen (jaen@moz-E0979827.copit.pl)
[17:13:28] *** Quits: fredy (fredy@moz-E7647C0E.vm.okeanos.grnet.gr) (Ping timeout)
[17:18:06] *** Quits: SiegeLord (sl@moz-CAF07B4C.hsd1.ma.comcast.net) (Quit: It's a joke. It's all a joke.)
[17:22:14] *** Joins: fredy (fredy@moz-E7647C0E.vm.okeanos.grnet.gr)
[17:28:56] *** Parts: steven_is_false (user@moz-144077DE.bchsia.telus.net) (ERC Version 5.3 (IRC client for Emacs))
[17:30:28] *** Joins: CanhTak (Mibbit@moz-ED64F631.rev.sfr.net)
[17:32:12] *** Joins: erickt (Adium@49C4075F.3AC15C18.2321E71E.IP)
[17:32:41] *** Joins: maxli (maxli@C03F2759.C70D537E.2FA4EA88.IP)
[17:35:42] <cscott> nmatsakis: i was reading http://smallcultfollowing.com/babysteps/blog/2013/04/30/dynamically-sized-types/ and noticed you mentioned pnkfelix -- he wrote a register allocator for me when he was a MEng at MIT
[17:37:42] <cscott> i didn't realize he's at mozilla now
[17:39:01] *** Joins: Diablo-D3 (diablo@moz-6317EE8A.port.east.myfairpoint.net)
[17:40:04] *** Quits: KindOne (KindOne@moz-EF19DCE5.dynamic.ip.windstream.net) (Ping timeout)
[17:41:00] *** Quits: erickt (Adium@49C4075F.3AC15C18.2321E71E.IP) (Quit: Leaving.)
[17:43:06] *** Joins: tgt (tgt@moz-D59EE478.aztw.cable.virginmedia.com)
[17:43:42] *** Quits: ysuzuki (ysuzuki@moz-60FA9D06.net119083145.t-com.ne.jp) (Client exited)
[17:44:12] *** Joins: KindOne (KindOne@moz-98B4EE65.dynamic.ip.windstream.net)
[17:51:14] *** Quits: Blei (philipp@moz-96D25F7A.cust.bluewin.ch) (Quit: WeeChat 0.4.0)
[17:54:41] <cmr> whee ast::spanned... attr.node.value.node
[17:58:05] *** Joins: jensnockert (jensnocker@moz-8BE55278.customer.t3.se)
[17:58:26] <cscott> hm, HashMap::find_or_insert_with() seems to be hostile to borrowed values
[17:59:33] <cscott> I'd like to do something like: fn get(&self, s:&str) { self.map.find_or_insert_with(s, ...) ... }
[18:00:24] <cscott> but that only works if self.map has type HashMap<&str, T>, which is obviously bogus (rust says, "Illegal anonymous lifetime")
[18:01:41] <cscott> I think find_or_insert_with should borrow k?
[18:02:06] *** Joins: steve (steve@moz-5EF6C37C.socal.res.rr.com)
[18:02:38] *** steve is now known as steveklabnik
[18:02:59] *** Joins: pyrac (pyrac@moz-C70D038B.w109-214.abo.wanadoo.fr)
[18:07:27] *** Joins: anshin (nbs@441B8B9E.2055B963.D2A6B5.IP)
[18:08:02] *** Quits: donri (dag@moz-9BB61102.tbcn.telia.com) (Quit: Leaving)
[18:08:06] <nmatsakis> cscott: yes, he is
[18:08:38] <cscott> nmatsakis: small world.
[18:08:39] <nmatsakis> cscott: yes, the matter of borrowing and string values is quite tricky.
[18:08:47] <nmatsakis> cscott: actually the dynamically sized types proposal would let us make that work better
[18:09:09] <nmatsakis> cscott: because it would permit a HashMap that takes dynamically sized keys (like `str`)
[18:09:24] <nmatsakis> cscott: in which case, you would insert with ~str but lookup with &str
[18:09:32] <nmatsakis> cscott: one option is to use find_equiv()
[18:09:35] <cscott> nmatsakis: related, there's some #[cfg(stage0)] / #[cfg(not(stage0))] cruft in hashmap.js.  when does that go awak?
[18:09:39] <nmatsakis> cscott: but there is no find_equiv_or_insert_with sort of thing.
[18:09:47] <nmatsakis> cscott: that goes away when we do a snapshot
[18:09:49] *** Joins: samnardoni (samnardoni@moz-ECB14881.cable.virginmedia.com)
[18:10:00] <nmatsakis> cscott: which means that we freeze a version of the compiler
[18:10:11] <nmatsakis> cscott: to use as the base for all future builds (until we do another snapshot)
[18:10:23] <cscott> how often does that happen?
[18:10:30] <nmatsakis> cscott: as needed. we ought to do one, there hvae been a lot of significant changes since the last one.
[18:10:30] *** Joins: donri (dag@moz-9BB61102.tbcn.telia.com)
[18:10:33] <cscott> and who gets to clean up all the cfg(stage0) when it does? ;)
[18:10:42] <nmatsakis> whoever does the snapshot gets that enviable job :)
[18:10:51] <nmatsakis> you can see why it sometimes gets put off :)
[18:11:23] <steveklabnik> so, i have a question. what's the best way to write docs for implementations of a trait? I want to work some more on http://static.rust-lang.org/doc/core/io.html today, and I previously documented all of ReaderUtil
[18:11:38] *** Quits: samnardoni (samnardoni@moz-ECB14881.cable.virginmedia.com) (Ping timeout)
[18:11:43] <cmr> steveklabnik: you are my hero <3
[18:11:45] <steveklabnik> but if I documented the implementation of ReaderUtil for T:Reader, it'd just be the same comments. seems bad
[18:11:49] <steveklabnik> cmr: <3
[18:11:50] *** Joins: Jeaye (Jeaye@moz-FD505E54.hsd1.ca.comcast.net)
[18:12:01] <steveklabnik> i wish i had more time to do this right now, i really need to finish this rails book
[18:12:22] <cscott> if i edit libcore/hashmap.rs, is there a good way to rebuild just libcore (other than type 'make' at top level and cross my fingers?)
[18:12:24] <cmr> nmatsakis: I'd make snapshots, but don't you need S3 and direct-commit access?
[18:13:01] <nmatsakis> cscott: not really, whenever you edit core you wind up having to rebuild everything since everything else is dependent on core...
[18:13:24] <nmatsakis> cmr: yes, I guess you do.
[18:13:35] <cscott> well i can rustc --test hashmap.rs I guess
[18:14:02] <nmatsakis> cscott: what I sometimes do is either (a) copy hashmap.rs into a temporary file to play with it
[18:14:14] <nmatsakis> cscott: or (b) run "make VERBOSE=1" and copy out the relevant build command
[18:14:36] <nmatsakis> cscott: in particular you could do "make check-stage1-core VERBOSE=1" to get the command for building the libcore  tests
[18:15:03] <nmatsakis> cscott: a better build system---particular one that understood the difference between changing the *signature* of a fn and changing its body, would be nice.
[18:15:09] <cscott> nmatsakis: thanks, that sounds like the advice i was looking for
[18:17:05] <nmatsakis> cscott: I generally prefer to copy the file out, less tricky overall
[18:17:38] <cscott> nmatsakis: i tried that, but i'm getting a bunch of import errors
[18:17:39] <nmatsakis> cscott: if I may ask, what kind of changes did you have in mind?
[18:17:55] <nmatsakis> cscott: oh, yes, you'd have to rewrite the imports to begin with core:: I suppose
[18:18:35] <cscott> nmatsakis: well, i though i'd add a & in front of the K in the signature for find_or_insert_with() and see what broke
[18:18:41] <cscott> *thought
[18:19:17] <nmatsakis> cscott: I see. ok. you'll wind up needing a copy bound as well (which is partly why there isn't one there now)
[18:19:39] <nmatsakis> cscott: because if you wind up needing to *insert*, you'll need an owned copy, not a borrowed copy
[18:20:32] <steveklabnik> is there a simple way to convert a string to a vector of u8?
[18:21:04] <cmr> steveklabnik: str::to_bytes
[18:21:07] <nmatsakis> steveklabnik: there are functions in str for that purpose
[18:21:17] <steveklabnik> thanks. still learning where everything is
[18:21:49] *** Joins: wilsonk|2 (kvirc@moz-39EFBFC2.cg.shawcable.net)
[18:22:03] <cscott> nmatsakis: right. I can call to_str() on my &str to clone it, so I guess my ideal signature would let me do the & -> ~ conversion in the closure.
[18:22:35] *** Quits: wilsonk-laptop (kvirc@moz-39EFBFC2.cg.shawcable.net) (Ping timeout)
[18:22:49] *** Quits: donri (dag@moz-9BB61102.tbcn.telia.com) (Client exited)
[18:22:50] *** Joins: enix (enix@moz-A50569DD.c3-0.slvr-ubr1.lnh-slvr.md.cable.rcn.com)
[18:22:58] <cscott> &fn(&K) -> (K,V) ?
[18:23:17] <nmatsakis> cscott: yes, to be honest, I'm not sure what'd be best. perhaps an alternate find_or_insert_with that required a copyable key...
[18:23:24] <nmatsakis> or that.
[18:23:28] <pyrac> hi all. Is this https://github.com/osaut/rust/commit/efd965cde7850e74005861d06de79dbd629bb214 the good way to add a get method to ARC? Is it worth sending it in PR (along with some doc)
[18:23:34] <nmatsakis> but that signature is abit tricky, 
[18:23:46] *** Joins: samnardoni (samnardoni@moz-ECB14881.cable.virginmedia.com)
[18:24:09] <nmatsakis> cscott: because if you'd be prepared to give waay your copy of the string, you wouldn't be able to do so from within the closure, because you will have already lent it to the find_or_insert_with() call in the first place
[18:24:26] *** Joins: alisdair (textual@moz-EBE9F394.bchsia.telus.net)
[18:24:35] <nmatsakis> pyrac: that looks fine.
[18:24:57] <nmatsakis> pyrac: my only nit is that I prefer <T:Const+Owned> for some bizarre reason :)
[18:24:59] <cmr> rusti: ~"foo" == "foo"
[18:25:01] -rusti- more than 5 lines of output, pastebinned: http://sprunge.us/ehPH
[18:25:04] <cmr> Why is that not possible?
[18:25:09] *** Joins: donri (dag@moz-9BB61102.tbcn.telia.com)
[18:25:14] <nmatsakis> cmr: because they are different types.
[18:25:14] <pyrac> nmatsakis: great. Should I implement the function from the method or let it as it is currently
[18:25:27] <nmatsakis> cmr: however, for the moment, "foo" == ~"foo" works due to the argument coercion rules
[18:25:32] <cmr> rusti: ~4 == 4
[18:25:33] -rusti- more than 5 lines of output, pastebinned: http://sprunge.us/VbTN
[18:25:33] <pyrac> nmatsakis: I'll change for you :)
[18:25:46] <cmr> rusti: 4 == ~4
[18:25:47] -rusti- more than 5 lines of output, pastebinned: http://sprunge.us/hJIP
[18:25:47] <nmatsakis> cmr: though I'd like to change that :)
[18:26:10] <cmr> nmatsakis: does comparing to ~"foo" require an allocation every time that comparison is hit?
[18:26:14] <nmatsakis> pyrac: doesn't matter which implements from which I don't think, maybe marginally better to implement the functon from the method, since eventually functions will go away and methods will be usable as functions
[18:26:21] <nmatsakis> cmr: yes, it's not advisable.
[18:26:34] <cscott> nmatsakis: hm, so find_or_insert_with_borrowed(). :(  maybe I should just give up and accept the fact that rust wants me to make copies.
[18:26:52] <cmr> rusti: &~"foo" == "foo"
[18:26:53] -rusti- more than 5 lines of output, pastebinned: http://sprunge.us/iUYb
[18:27:01] <nmatsakis> cscott: yeah, it's a matter of taste where to draw the line
[18:27:02] <pyrac> nmatsakis: perfect, thanks for your help
[18:27:11] *** Quits: eholk (eholk@moz-9AB4D52F.hsd1.ut.comcast.net) (Quit: eholk)
[18:27:16] <nmatsakis> cscott: between adding more methods etc or just accepting a few copies here and there
[18:27:17] <cmr> nmatsakis: is there a better way to compare a ~str against a str constant?
[18:27:28] <cscott> cmr: "foo" == s
[18:27:32] <nmatsakis> cmr: there are two ways. you can do: "foo" == s
[18:27:40] <cmr> well that just seems hacky
[18:27:43] <nmatsakis> cmr: or you can do "s.slice(0, s.len()) == "foo"
[18:28:01] <cscott> oh, that's much less hacky :)
[18:28:04] <nmatsakis> cmr: evetually (with dynamically sized types) you'd be able to &*s == "foo"
[18:28:12] <nmatsakis> &*s being "borrow this string pointer"
[18:28:13] *** Quits: Yurume (yurume@AC58A8CE.8A059B47.E313B915.IP) (Ping timeout)
[18:28:20] <cmr> nmatsakis: ok
[18:28:23] <nmatsakis> but today that doesn't work, so you need to use the slice method.
[18:28:31] <nmatsakis> which is a more verbose way of doing the same thing.
[18:29:17] <cscott> nmatsakis: really, i want to do the thing I'd do in other programming languages, which is to copy the key iff i need to store it in the map (in the same way find_or_insert_with lets me defer allocating the new value until I know I need it)
[18:29:27] *** Quits: CanhTak (Mibbit@moz-ED64F631.rev.sfr.net) (Quit: http://www.mibbit.com ajax IRC Client)
[18:29:43] <ssbr_> Man, I keep wishing for a "non-negative int" type. If I use uint, I run the risk of it being too big, and if I use int, I run the risk of it being negative. Wheres my 31 bit uint, man?
[18:29:57] <ssbr_> (or my indexed types, of course)
[18:30:23] <cscott> nmatsakis: i need to finish reading your dynamically-sized typed blog; i got distracted at the pnkfelix token and had to figure out where he's at and what he's doing now.
[18:30:37] *** Quits: bytbox (s@moz-D83E9B31.wireless.umd.edu) (Ping timeout)
[18:30:42] <cmr> cscott: ask him when he's next in irc :)
[18:30:47] <nmatsakis> cscott: yeah, that's why having a method that takes a borrowed key and conditioanlly copies it might be ideal.
[18:31:19] <cscott> nmatsakis: graydon also mentioned on irc that you're the person to talk to about fork/join parallelism (but maybe not right now)
[18:31:26] <nmatsakis> cscott: you can of course separate out the find and the insert if you prefer
[18:31:43] <nmatsakis> cscott: yes, I'd love to talk about that, but my daughter *just* woke up from her nap so now is not a good time, perhaps tomorrow? :)
[18:32:37] <cscott> i'm sure we'll find a good time
[18:32:39] *** Quits: Earnestly (earnest@6A917A59.5E1FD793.39C00A7A.IP) (Ping timeout)
[18:32:56] <nmatsakis> cscott: ok, I'm always on IRC, though not always at the keyboard, so just ping me whenever...
[18:33:15] <cscott> are you on SFO time?
[18:33:19] <nmatsakis> cscott: boston.
[18:33:26] <cscott> orly?
[18:33:44] <nmatsakis> yes.
[18:34:02] <cscott> i'm in hawaii at the moment (boston - 6 hours), but i'm usually a brookline-ian.
[18:34:05] <cscott> brookliner?
[18:34:20] <nmatsakis> cscott: very nice. well, technically I'm in Rockport right now, but that's temporary.
[18:34:22] *** Joins: bytbox (s@moz-D83E9B31.wireless.umd.edu)
[18:34:40] <cscott> i think i'm scheduled for a job interview w/ you later this week from the SFO office, which now seems kinda silly.
[18:36:56] <kimundi> steveklabnik: If you want to convert a string literal to a &[u8], there is also a brand new bytes!() macro
[18:37:18] <steveklabnik> kimundi: awesome, thanks! i actually found an even easier way to express what i was going for, but good to know.
[18:38:11] *** Quits: bytbox (s@moz-D83E9B31.wireless.umd.edu) (Ping timeout)
[18:38:12] * kimundi is glad that mcro is there. writing ['i' as u8, 'n' as u8, 'f' as u8] gets old really fast
[18:38:27] <steveklabnik> r+
[18:38:56] *** Quits: doomlord (doomlod@moz-19EDB75F.range86-166.btcentralplus.com) (Ping timeout)
[18:39:33] *** Quits: dobkeratops (walter@moz-19EDB75F.range86-166.btcentralplus.com) (Ping timeout)
[18:39:53] *** Joins: dobkeratops (walter@moz-1035DA3D.range86-135.btcentralplus.com)
[18:41:55] *** Joins: doomlord (doomlod@moz-1035DA3D.range86-135.btcentralplus.com)
[18:43:26] *** Joins: bytbox (s@moz-D83E9B31.wireless.umd.edu)
[18:45:03] <steveklabnik> wow, i somehow _really_ screwed up my repo. Any git command just returns "Fatal: Oops."
[18:45:24] <steveklabnik> after I re-clone, more docs for IO headed for incoming :)
[18:45:24] *** Joins: dherman (dherman@moz-6CA476B1.hsd1.ca.comcast.net)
[18:45:25] *** ChanServ sets mode: +o dherman
[18:54:42] *** Quits: ssbr (scorchsabe@A9D9D38C.B6F034AC.72A31D6.IP) (Ping timeout)
[18:55:06] *** Quits: ssbr_ (ssbr@A9D9D38C.B6F034AC.72A31D6.IP) (Ping timeout)
[18:56:50] *** Joins: ssbr (scorchsabe@A9D9D38C.B6F034AC.72A31D6.IP)
[18:56:55] *** Joins: ssbr_ (ssbr@A9D9D38C.B6F034AC.72A31D6.IP)
[19:00:35] *** Quits: bytbox (s@moz-D83E9B31.wireless.umd.edu) (Ping timeout)
[19:00:42] <cmr> Is there currently any way to get the name of the variant of enum you have? I'm working on https://github.com/mozilla/rust/issues/6568 and have got as far as adding a pass after check_const, https://gist.github.com/cmr/5608599, and I have a test file with a bunch of different uses of #[static_assert], but I want to know what typ and exp are.
[19:01:12] <cmr> and matching for all the variants is yucky :(
[19:01:13] *** Quits: maxli (maxli@C03F2759.C70D537E.2FA4EA88.IP) (Quit: Leaving.)
[19:02:00] *** Quits: ssbr_ (ssbr@A9D9D38C.B6F034AC.72A31D6.IP) (Ping timeout)
[19:02:09] *** Quits: ssbr (scorchsabe@A9D9D38C.B6F034AC.72A31D6.IP) (Ping timeout)
[19:02:21] <cmr> oh wait
[19:02:29] <cmr> "typ: @{id: 2, node: ty_path(..."
[19:02:39] <cmr> I think that's the enum name right there :)
[19:03:54] *** Joins: ssbr (scorchsabe@A9D9D38C.B6F034AC.72A31D6.IP)
[19:04:03] *** Joins: ssbr_ (ssbr@A9D9D38C.B6F034AC.72A31D6.IP)
[19:04:53] *** Joins: bytbox (s@moz-2E27684C.student.umd.edu)
[19:07:09] *** Quits: jensnockert (jensnocker@moz-8BE55278.customer.t3.se) (Input/output error)
[19:08:17] *** Joins: Earnestly (earnest@6A917A59.5E1FD793.39C00A7A.IP)
[19:08:39] *** Quits: ssbr_ (ssbr@A9D9D38C.B6F034AC.72A31D6.IP) (Ping timeout)
[19:08:39] *** Quits: ssbr (scorchsabe@A9D9D38C.B6F034AC.72A31D6.IP) (Ping timeout)
[19:10:32] *** Quits: samnardoni (samnardoni@moz-ECB14881.cable.virginmedia.com) (Client exited)
[19:10:49] *** Joins: ssbr (scorchsabe@A9D9D38C.B6F034AC.72A31D6.IP)
[19:10:52] *** Joins: ssbr_ (ssbr@A9D9D38C.B6F034AC.72A31D6.IP)
[19:15:47] *** Quits: ssbr (scorchsabe@A9D9D38C.B6F034AC.72A31D6.IP) (Ping timeout)
[19:16:07] *** Quits: ssbr_ (ssbr@A9D9D38C.B6F034AC.72A31D6.IP) (Ping timeout)
[19:17:49] *** Joins: ssbr (scorchsabe@A9D9D38C.B6F034AC.72A31D6.IP)
[19:18:02] *** Joins: ssbr_ (ssbr@A9D9D38C.B6F034AC.72A31D6.IP)
[19:19:23] *** Quits: steveklabnik (steve@moz-5EF6C37C.socal.res.rr.com) (Ping timeout)
[19:22:44] *** Quits: ssbr (scorchsabe@A9D9D38C.B6F034AC.72A31D6.IP) (Ping timeout)
[19:23:09] *** Quits: ssbr_ (ssbr@A9D9D38C.B6F034AC.72A31D6.IP) (Ping timeout)
[19:23:38] *** Joins: steveklabnik (steve@moz-5EF6C37C.socal.res.rr.com)
[19:24:21] *** Joins: jensnockert (jensnocker@moz-8BE55278.customer.t3.se)
[19:25:36] *** Joins: james4k (james@moz-726FE3EE.com)
[19:39:39] *** Joins: lkuper (lkuper@moz-D6AAFF3.cs.indiana.edu)
[19:41:33] *** Quits: jaen (jaen@moz-E0979827.copit.pl) (Ping timeout)
[19:41:44] *** Joins: jaen (jaen@moz-E0979827.copit.pl)
[19:41:52] *** Quits: anshin (nbs@441B8B9E.2055B963.D2A6B5.IP) (Quit: Lost terminal)
[19:41:57] *** Quits: james4k (james@moz-726FE3EE.com) (Quit: WeeChat 0.3.8)
[19:42:19] *** Joins: Blub\0 (wry@7E3BB9D.71150E1A.237AE2BA.IP)
[19:42:30] <cmr> rusti: -3 & 1
[19:42:31] -rusti- 1
[19:42:36] *** Quits: Blub\w (wry@7E3BB9D.71150E1A.237AE2BA.IP) (Ping timeout)
[19:42:44] <cmr> rusti: -3 & 1.0
[19:42:45] -rusti- more than 5 lines of output, pastebinned: http://sprunge.us/MgDG
[19:43:26] <cmr> rusti: 3.0 & 3.0
[19:43:28] -rusti- more than 5 lines of output, pastebinned: http://sprunge.us/RPbW
[19:44:11] <cmr> rusti: 3 && 1
[19:44:12] *** Joins: ssbr (ssbr@A9D9D38C.B6F034AC.72A31D6.IP)
[19:44:12] -rusti- more than 5 lines of output, pastebinned: http://sprunge.us/RhIf
[19:44:13] *** Joins: ssbr_ (scorchsabe@A9D9D38C.B6F034AC.72A31D6.IP)
[19:45:19] <steveklabnik> two more docs patches submitted, w00t.
[19:45:28] <steveklabnik> been meaning to do that for a long while
[19:45:41] *** Joins: maxli (maxli@C03F2759.C70D537E.2FA4EA88.IP)
[19:46:08] <cmr> steveklabnik: reader could use some more docs.
[19:46:12] <cmr> read_byte, for example.
[19:46:22] <cmr> as well as the fact that it *consumes* a byte of input
[19:46:25] <cmr> are all readers seekable?
[19:46:46] <cmr> (these are questions I had while doing some file io the other day)
[19:46:57] <steveklabnik> i wrote docs for read_byte
[19:47:04] <steveklabnik> but i didnt mention the consumption aspect
[19:47:08] <steveklabnik> because it was for the trait
[19:47:15] <steveklabnik> i'm not sure that that's always true
[19:47:26] *** Quits: maxli (maxli@C03F2759.C70D537E.2FA4EA88.IP) (Ping timeout)
[19:47:27] <cmr> well it advances the stream, which was the important part to me
[19:47:39] <cmr> I didn't know if I needed to seek forward or something after using read_byte
[19:47:45] * steveklabnik nods
[19:47:52] <steveklabnik> that'd be in one of the particular implementations, i guess
[19:48:59] <cmr> rusti: 1024 >> 4
[19:49:00] -rusti- 64
[19:49:19] <cmr> rusti: 1024 >> 8
[19:49:21] -rusti- 4
[19:49:25] <cmr> rusti: 1024 >> 11
[19:49:26] -rusti- 0
[19:49:28] <cmr> rusti: -1024 >> 11
[19:49:30] -rusti- -1
[19:49:35] *** Quits: bytbox (s@moz-2E27684C.student.umd.edu) (Ping timeout)
[19:49:54] <indutny> hey people
[19:50:03] <indutny> my linearscan implementation is going great :)
[19:50:11] <indutny> just wanted to share this visualization of it with you: http://blog.indutny.com/f/linearscan.svg
[19:50:45] <cmr> register allocation?
[19:50:51] <indutny> in a couple of months I'll probably polish out my JIT engine written in rust
[19:50:54] <indutny> cmr: yep
[19:51:16] <indutny> I've split it into components and developing it as a separate rust libraries
[19:53:31] <indutny> ok, gtg
[19:53:31] <indutny> ttyl
[19:53:32] *** Joins: victorporof (victorporo@10AA7997.880C8D58.79933D60.IP)
[19:57:27] *** Quits: dherman (dherman@moz-6CA476B1.hsd1.ca.comcast.net) (Quit: dherman)
[19:58:02] *** Joins: bytbox (s@moz-2E27684C.student.umd.edu)
[19:59:11] *** Joins: james4k (james@moz-726FE3EE.com)
[19:59:38] <steveklabnik> cmr: PR submitted, just for you. I mentioned you, so you should get a notice.
[19:59:47] <cmr> steveklabnik: thanks a bunch :)
[20:00:34] <cmr> rusti: 3.3 * 3.3
[20:00:36] -rusti- 10.89
[20:02:22] <cmr> rusti: 3 | 1
[20:02:23] -rusti- 3
[20:02:46] *** Joins: brson (brson@2557E599.66715431.D25A875A.IP)
[20:02:46] *** ChanServ sets mode: +o brson
[20:04:37] <heftig> rusti: 10.0 / 3.0
[20:04:38] -rusti- 3.33333333
[20:04:45] <heftig> rusti: 10.0 / 3.0 - 3.33333333
[20:04:46] -rusti- 0
[20:07:58] *** Quits: BitPuffin (quassel@moz-8370D1B9.bredband.comhem.se) (Client exited)
[20:08:24] *** Quits: tgt (tgt@moz-D59EE478.aztw.cable.virginmedia.com) (Quit: Computer has gone to sleep.)
[20:13:26] <cmr> How can I get at LLVM enum variants? For example, http://llvm.org/docs/doxygen/html/group__LLVMCCoreTypes.html#ga242440d0e4a6d84d80b91df15e161971. llvm::LLVMRealOEQ does not work
[20:13:35] <cmr> Do I need to add them to the ffi somewhere?
[20:15:44] *** Quits: infynyxx (infynyxx@moz-8BE8F2CD.hsd1.md.comcast.net) (Client exited)
[20:16:04] *** Joins: infynyxx (infynyxx@moz-8BE8F2CD.hsd1.md.comcast.net)
[20:17:59] *** Quits: infynyxx (infynyxx@moz-8BE8F2CD.hsd1.md.comcast.net) (Ping timeout)
[20:19:21] *** Joins: samnardoni (samnardoni@moz-ECB14881.cable.virginmedia.com)
[20:19:31] <cmr> Ahhh, librustc/lib/llvm.rs
[20:19:32] *** Joins: erickt (Adium@49C4075F.3AC15C18.2321E71E.IP)
[20:20:19] *** Quits: KindOne (KindOne@moz-98B4EE65.dynamic.ip.windstream.net) (Ping timeout)
[20:20:58] *** Joins: Jesin (Jessin_@moz-5654D37.washdc.fios.verizon.net)
[20:24:03] *** Joins: KindOne (KindOne@moz-FA7BC392.dynamic.ip.windstream.net)
[20:29:08] <brson> my io branch landed!
[20:29:18] <brson> best day ever
[20:29:29] <brson> and incoming is red
[20:29:33] <brson> :(
[20:30:00] <brson> "Cannot generate unaligned atomic load"
[20:30:43] *** Quits: donri (dag@moz-9BB61102.tbcn.telia.com) (Client exited)
[20:31:49] <doomlord> what would be the most productive wheel to re-invent in rust at the minute
[20:32:39] <doomlord> i've given up on my iphone port attempt for the timebeing.. 
[20:33:38] <cmr> Bah
[20:33:46] <cmr> brson: Could you make a new snapshot pretty please?
[20:34:11] <cmr> I am getting assertion failures in the snapshot compiler, rustc: /home/rustbuild/src/rust-buildbot/slave/snap3-linux/build/src/llvm/lib/IR/Instructions.cpp:281: void llvm::CallInst::init(llvm::Value*, llvm::ArrayRef<llvm::Value*>, const llvm::Twine&): Assertion `(i >= FTy->getNumParams() || FTy->getParamType(i) == Args[i]->getType()) && "Calling a function with a bad signature!"' failed.
[20:34:21] <cmr> (when building librustc)
[20:35:37] <cmr> not sure a new snapshot will actually fix it, of course
[20:35:37] <brson> cmr: i am trying to make a snapshot
[20:35:57] <brson> the linux snapshot bot is here: http://buildbot.rust-lang.org/builders/snap3-linux
[20:36:09] <brson> trying to get 2d28 to build green
[20:37:03] *** Joins: engla_ (engla@moz-DBD1D96E.cust.bredbandsbolaget.se)
[20:37:17] <cmr> are all those valgrind errors normal
[20:37:18] *** Joins: azita (Azita@moz-C1FB2A8.hsd1.ca.comcast.net)
[20:37:19] <cmr> ?
[20:37:52] *** Quits: engla (engla@moz-DBD1D96E.cust.bredbandsbolaget.se) (Ping timeout)
[20:38:23] <brson> no
[20:38:29] <cmr> ouch
[20:39:24] <cmr> doomlord: bjz expressed an interest in independance from libm (C math stdlib), that's a pretty big wheel to reinvent
[20:41:32] <doomlord> yeah i've seen some of the steps in that direction
[20:43:24] <brson> doomlord: fmt! needs to be redesigned and reimplemented. so does logging
[20:43:47] *** Quits: KindOne (KindOne@moz-FA7BC392.dynamic.ip.windstream.net) (Ping timeout)
[20:43:49] <doomlord> these are things i ended up patching over in my own experiments
[20:44:14] <doomlord> tried an 'n-ary' macro but still dont know what you'd call it..
[20:45:42] <doomlord> n_ary(print,  foo, bar, baz..) that sort of thing.. although i just had a print!(foo,bar,baz...) but the consensus here is it would need a better name
[20:46:12] <doomlord> n_ary!(io::print.... ) whatever it was
[20:46:48] *** Quits: tiffany (kawaii@moz-1E0FE6E8.dhcp.embarqhsd.net) (Ping timeout)
[20:47:04] *** Quits: azita (Azita@moz-C1FB2A8.hsd1.ca.comcast.net) (Quit: azita)
[20:47:26] <doomlord> Does the planned work around servo constitute a native GUI library in rust? (web based guis)
[20:48:19] *** Joins: ghrust (ghrust@moz-4EF5B6E5.rs.github.com)
[20:48:20] <ghrust> 01[13rust01] 15bors pushed 0 new commits to 06auto: 02http://git.io/hWpKUg
[20:48:20] *** Parts: ghrust (ghrust@moz-4EF5B6E5.rs.github.com) ()
[20:48:23] <cmr> isn't web based the opposite of native? (besides chromeos/b2g, of course)
[20:48:24] *** Joins: ghrust (ghrust@moz-4EF5B6E5.rs.github.com)
[20:48:24] <ghrust> 01[13rust01] 15bors pushed 3 new commits to 06auto: 02http://git.io/_2hxFw
[20:48:24] <ghrust> 13rust/06auto 14e0b1bdc 15Steve Klabnik: Add additional documentation in core::io....
[20:48:24] <ghrust> 13rust/06auto 14929050d 15Steve Klabnik: Added note about prelude inclusion.
[20:48:25] <ghrust> 13rust/06auto 148d6bceb 15bors: auto merge of #6619 : steveklabnik/rust/stdout_docs, r=brson...
[20:48:26] *** Parts: ghrust (ghrust@moz-4EF5B6E5.rs.github.com) ()
[20:49:12] *** Joins: KindOne (KindOne@moz-CCEAAAF.dynamic.ip.windstream.net)
[20:49:28] <doomlord> but it might generate native and rust-based gui libraries usable outside of the browser
[20:49:49] <doomlord> lets say i was to try writing a 3d modeller in rust.. what would i use for UI widgets
[20:50:21] *** Quits: james4k (james@moz-726FE3EE.com) (Quit: WeeChat 0.3.8)
[20:50:29] *** Joins: james4k (james@moz-726FE3EE.com)
[20:50:38] *** Parts: doomlord (doomlod@moz-1035DA3D.range86-135.btcentralplus.com) (Leaving)
[20:50:54] *** Joins: doomlord (doomlod@moz-1035DA3D.range86-135.btcentralplus.com)
[20:52:59] *** Joins: q66_ (q66@6EE9DE40.46454B5D.33AABD5F.IP)
[20:53:20] *** Joins: mib_1b42py (Mibbit@moz-FA2BE030.netcologne.de)
[20:53:31] *** Joins: q66__ (q66@6EE9DE40.46454B5D.33AABD5F.IP)
[20:54:10] *** Quits: q66 (q66@6EE9DE40.46454B5D.33AABD5F.IP) (Ping timeout)
[20:54:52] *** Quits: q66_ (q66@6EE9DE40.46454B5D.33AABD5F.IP) (Ping timeout)
[20:57:20] *** Quits: enix (enix@moz-A50569DD.c3-0.slvr-ubr1.lnh-slvr.md.cable.rcn.com) (Quit: Konversation terminated!)
[20:58:43] <brson> doomlord: the current plan for servo probably won't yield a general-purpose GUI library any time soon. we plan not to use native widgets for forms and there's no plan to implement a complete browser UI in the near term
[20:59:15] *** Joins: ctult (Mibbit@moz-1BC93140.bois.qwest.net)
[20:59:40] *** Joins: dherman (dherman@moz-6CA476B1.hsd1.ca.comcast.net)
[20:59:40] *** ChanServ sets mode: +o dherman
[20:59:41] <brson> and the UI we use *for* forms is probably going to be based on 'web components'
[21:00:16] *** Joins: infynyxx (infynyxx@moz-BD811F8D.sub-70-192-213.myvzw.com)
[21:00:25] <mib_1b42py> Hello, I'm new to Rust and couldn't find this by using google. How do I get an immutable copy of this vector (& mut u8). I need it as (&u8).
[21:00:55] <ctult> I am working on a game, is there any way I could add platform-independent scripting with Rust?
[21:01:10] <cmr> ctult: you could use lua.
[21:01:28] <Luqman> there were some lua bindings around, by bstrie i think
[21:01:30] <ctult> cmr: I mean scripting with the Rust language, sorry.
[21:01:35] <cmr> oh
[21:01:46] *** Quits: infynyxx (infynyxx@moz-BD811F8D.sub-70-192-213.myvzw.com) (Client exited)
[21:01:49] <cmr> ctult: that probably isn't a good idea, but you might be able to use the JIT
[21:02:07] <ctult> Are there any Python bindings to Rust?
[21:02:16] <cmr> ssbr_ is working on some, last I know
[21:02:23] <cmr> he might have finished them, I don't know.
[21:02:37] <ctult> hm
[21:02:46] <engla_> Rust isn't designed to be for scripting or to be an extension language. not that I understand
[21:02:51] *** Quits: KindOne (KindOne@moz-CCEAAAF.dynamic.ip.windstream.net) (Ping timeout)
[21:03:36] <cmr> I wouldn't use python as a scripting language for a game, too much trouble writing bindings, not the greatest performance.
[21:03:45] <doomlord> i guess rust applications will rely heavily on bindings to libraries with C interfaces (like opengl, etc..)
[21:03:49] <cmr> but that's just my opinion. I love python, but I love lua more :)
[21:03:50] <doomlord> no bad thing there
[21:04:02] <ctult> I don't get quite how rust works behind the scenes.  Is it a VM like the JVM or the CLR, is it totally static like C or C++, or is it a combination or something else?
[21:04:05] <engla_> lua is simply designed for that role so it's good at it
[21:04:10] <doomlord> rust is native like C++
[21:04:16] <cmr> ctult: static like C, code generated by LLVM
[21:04:25] <cmr> That question is answered in the table on http://www.rust-lang.org/
[21:04:40] <doomlord> rust is so interesting for that reason, finally an alternative native/static language
[21:05:10] <ctult> cmr: Lua is interesting, but I don't see it as a useful language.
[21:05:16] <cscott> how do i convert a @ to a @mut?  ie, for variables, I can just assign 'let mut b = a'. 
[21:05:25] <doomlord> lua is pretty decent for scripting, its lighter than python
[21:05:33] <doomlord> some say its a better design than JS
[21:05:35] <cmr> has a fantastic ffi too
[21:05:41] <cmr> which is its main utility
[21:06:02] <cmr> it's fairly powerful if you use metatables, almost useless otherwise
[21:06:05] <engla_> it's very easy to integrate lua in C
[21:06:17] <engla_> and expose exactly the api you want
[21:06:18] <ctult> See, I am used to the CLR, where I can use the same language for *everything*, including mods and the like.
[21:06:50] <cmr> ctult: Well you can do that with rust too, you will just need to load a DLL at runtime (like you would in the CLR)
[21:06:57] <cmr> but that isn't scripting.
[21:07:01] <doomlord> could a subset of rust be embedded/interpretted?  is that a potential wheel to reinvent .. rust-script :)
[21:07:08] <ctult> cmr: But I need a cross-platform solution.
[21:07:32] <ctult> doomlord: That was exactly what I was thinking :D.
[21:07:50] <cmr> ctult: Could distribute llvm bitcode and compile on each box.
[21:08:02] <cmr> (which is basically ngen)
[21:08:07] <ctult> cmr: Can Rust output llvm bytecode?
[21:08:15] <doomlord> yes it can^
[21:08:20] <cmr> ctult: of course. rustc --emit-llvm
[21:08:29] <cmr> it's built entirely on top of LLVM, that's where it gets it JIT too
[21:08:42] <ctult> That's just crazy enough it just might work.
[21:08:43] <doomlord> be warned, llvm bytecode does have OS dependancies
[21:08:51] <cscott> the google PNaCl runtime is based on that
[21:08:55] *** Quits: james4k (james@moz-726FE3EE.com) (Quit: WeeChat 0.3.8)
[21:09:05] <doomlord> ABI. i've run into this trying to do iphone support (and failingn)
[21:09:36] *** Joins: james4k (james@moz-726FE3EE.com)
[21:09:53] <ctult> doomlord: So it wouldn't work cross-platform?
[21:10:00] <cmr> doomlord: Can you give an example of LLVM IR that isn't platform-independant?
[21:10:04] <doomlord> you need runtimes for each platform
[21:10:07] <ctult> Could you scrub the OS dependencies? 
[21:10:16] <cmr> I thought LLVM was entirely platform neutral until codegen
[21:10:19] <doomlord> LLVM isn't platform independant
[21:10:24] <doomlord> "its like C"
[21:10:34] * cmr brb
[21:10:37] <doomlord> but designed for compiler backend. it still has platform dependant issues
[21:10:42] <ctult> It's like a C VM.
[21:11:01] *** Quits: james4k (james@moz-726FE3EE.com) (Quit: WeeChat 0.3.8)
[21:11:08] <rpearl> not really
[21:11:09] *** Joins: james4k (james@moz-726FE3EE.com)
[21:11:30] <doomlord> i've been unable to use LLVM to get rust onto the iphone, i can tell you that.
[21:11:34] <ctult> If you were to compile C to LLVM, it would be like a C VM.
[21:11:40] <ctult> LLVM is a VM.
[21:11:52] <ctult> doomlord: I don't see how it's like C an any way.
[21:11:56] <ctult> It's more like asm
[21:11:59] <doomlord> its like C in that it has platform dependancy
[21:12:09] <doomlord> its more portable than Asm, but less portable than Java
[21:12:15] <doomlord> thats the comparison to C
[21:12:21] *** Joins: ghrust (ghrust@moz-4EF5B6E5.rs.github.com)
[21:12:21] <ghrust> 01[13rust01] 15bors 04force-pushed 06auto from 148d6bceb to 149f67169: 02http://git.io/N3iJvQ
[21:12:21] *** Parts: ghrust (ghrust@moz-4EF5B6E5.rs.github.com) ()
[21:12:22] *** Joins: ghrust (ghrust@moz-4EF5B6E5.rs.github.com)
[21:12:22] <ghrust> 01[13rust01] 15bors pushed 2 new commits to 06auto: 02http://git.io/0LP4pA
[21:12:22] <ghrust> 13rust/06auto 14a389d86 15Steve Klabnik: Add docs for stdin in core::io.
[21:12:22] <ghrust> 13rust/06auto 14ebdb0de 15bors: auto merge of #6620 : steveklabnik/rust/stdin_docs, r=brson
[21:12:23] *** Parts: ghrust (ghrust@moz-4EF5B6E5.rs.github.com) ()
[21:12:24] <doomlord> of course it is lower leevel than C
[21:12:37] <doomlord> portability is a sliding scale.. LLVM is not portable
[21:12:53] <doomlord> but it IS more portable than raw asm
[21:13:18] <ctult> doomlord: I have before been able to compile Linux-compiled Clang code to LLVM IR and compile that IR on a Windows box.
[21:13:33] <doomlord> thats still x86 though
[21:13:57] <doomlord> i've not been able to get anyhting onto the iphone, via ARM asm or LLVM
[21:14:00] <spider-mario> what makes it less portable than Java?
[21:14:03] *** Joins: KindOne (KindOne@8C55469.C538DA2.EC6A1518.IP)
[21:14:09] <spider-mario> Java has to be ported as well
[21:14:10] <ctult> Oh, I thought we were talking about OSs
[21:14:15] <doomlord> it knows about 32/64bit for a start
[21:14:19] <spider-mario> and it doesnâ€™t run directly on iOS either, does it?
[21:14:20] <spider-mario> hm, true
[21:14:34] <doomlord> well, iOS toolchain is LLVM based. and I can't get rust onto iOS as yet
[21:14:42] <doomlord> there are details needed in the rust compiler to support iOS
[21:14:51] <doomlord> LLVM does not acheive platform independance
[21:15:15] <ctult> So I am back to where I started.  How do I script Rust in Rust?
[21:15:16] *** Quits: MX80 (MX80@moz-32BE33CD.dsl.g3telecom.net) (Ping timeout)
[21:15:46] <cmr> http://lists.cs.uiuc.edu/pipermail/llvmdev/2005-February/003485.html is that accurate?
[21:15:46] <engla_> LLVM is not a VM
[21:15:47] <doomlord> rust-script doesn't exist :)
[21:16:04] <doomlord> nice project idea IMO
[21:16:55] *** Joins: MX80 (MX80@moz-32BE33CD.dsl.g3telecom.net)
[21:17:00] <cmr> http://comments.gmane.org/gmane.comp.compilers.llvm.devel/43769
[21:18:07] *** Quits: james4k (james@moz-726FE3EE.com) (Quit: WeeChat 0.3.8)
[21:18:08] <doomlord> some say DLL's can be used as an alternative to scripting
[21:18:29] <doomlord> plugin native code modules. perhaps rusts' safety and lack of headers helps out there
[21:18:30] <ctult> doomlord: But that isn't OS cross-platform without embedding something like Wine.
[21:18:42] <cmr> ctult: Anyway, rust output isn't meant to be portable. You're trying to do something rust was not designed for at all.
[21:19:07] <cmr> It's like asking how do you script C++ in C++
[21:19:21] <doomlord> all i'm saying is, LLVM itself does not solve the problem of OS portability. it does solve independance from certain code-generation  issues
[21:19:23] *** Joins: tgt (tgt@moz-D59EE478.aztw.cable.virginmedia.com)
[21:19:25] <ctult> cmr: AngelScript
[21:19:31] <doomlord> independance from ISA 
[21:20:50] <doomlord> Rust needs to have platforms explicitely supported - target triples. Android support is in progress due to samsung support. I was interested in adding IOS support, but dont know enough about Rusts runtime or LLVM etc to finish this. i documented my attempts on github, i was stabbing around in the dark really
[21:20:53] *** Joins: infynyxx (infynyxx@moz-8C385D4F.sub-70-192-207.myvzw.com)
[21:21:02] <fread2281> ctult: AngelScript isn't C++
[21:21:16] <cmr> ctult: but that's just like using Lua or anything else.
[21:21:34] <doomlord> I have done crossplatform code in C++ , e.g 97% of the source the same, and a stub per OS.. same opengl program running onn windows,linux,mac,iOS,android.
[21:21:38] <ctult> fread2281: It is source-compatible
[21:21:42] <ctult> cmr: Exactly
[21:21:57] <doomlord> i would myself like to be in the same situation with Rust, but its down to us the community to make it posible 
[21:22:15] *** Quits: infynyxx (infynyxx@moz-8C385D4F.sub-70-192-207.myvzw.com) (Connection reset by peer)
[21:22:58] *** Joins: infynyxx (infynyxx@moz-8C385D4F.sub-70-192-207.myvzw.com)
[21:23:11] *** Quits: KindOne (KindOne@8C55469.C538DA2.EC6A1518.IP) (Ping timeout)
[21:23:12] <doomlord> i like the design of rust and want it to be my main language.. but i realise its alpha
[21:23:32] <doomlord> hence many issues.. like platform support yet to do
[21:23:47] <ctult> If I can't use Rust as a scripting language, does anyone know of a functional scripting language?
[21:23:55] <doomlord> scheme
[21:23:58] <cmr> guile
[21:24:24] <sp3d> r33fpwnR#-og
[21:24:29] <doomlord> lua can do some fp,  i think
[21:24:42] <sp3d> asdf
[21:25:06] <mib_1b42py> Anyone got a hint for me? (How do I get a immutable copy of a vector (& MrFahrenheit ut u8) to (&u8))
[21:25:10] <EXetoC> sp3d: agreed
[21:25:12] <sp3d> oh fucking damnit
[21:25:20] <engla_> sp3d: :-(
[21:25:33] <MrFahrenheit> yes?
[21:25:47] <EXetoC> lol
[21:25:50] <sp3d> turns out x11vnc will happily keep sending stale images across the network if you happen to be on a different VT, but accepts input just fine
[21:26:18] <cmr> rusti: ~[&mut 1u8, &mut 2u8, &mut 3u8] as [&u8]
[21:26:20] -rusti- more than 5 lines of output, pastebinned: http://sprunge.us/iLXJ
[21:26:23] <cmr> rusti: ~[&mut 1u8, &mut 2u8, &mut 3u8] as ~[&u8]
[21:26:25] -rusti- more than 5 lines of output, pastebinned: http://sprunge.us/Hech
[21:26:27] <doomlord> ctult, have you considered just hardcoding :)k
[21:26:32] <cmr> oh right
[21:26:33] <EXetoC> mib_1b42py: you wanna copy MrFahrenheit ? :p
[21:26:35] <doomlord> ctult or using DLLs for levels 
[21:26:49] <ctult> doomlord: The point of this is for modders to extend my game.
[21:26:59] <doomlord> DLLs can do that
[21:27:19] *** Quits: pyrac (pyrac@moz-C70D038B.w109-214.abo.wanadoo.fr) (Quit: pyrac)
[21:27:38] *** Joins: KindOne (KindOne@moz-E82E1E2A.dynamic.ip.windstream.net)
[21:27:39] <ctult> doomlord: This game is going to be for Windows, Mac, and Linux, and I don't want them to have to recompile for each different platform on each different platform.
[21:27:40] <doomlord> ctult , could your game be opensource, that is maximum mod-ability :)
[21:27:42] *** Joins: gareth0 (gareth0@moz-927693EF.dynamic.dsl.as9105.com)
[21:27:49] <mib_1b42py> Eh no meant to write mut. 
[21:27:50] <EXetoC> ctult: dynamically loaded library, I think
[21:28:00] <EXetoC> it's confusing
[21:28:12] <EXetoC> so yes he means in a cross-platform manner I think
[21:28:37] *** Quits: infynyxx (infynyxx@moz-8C385D4F.sub-70-192-207.myvzw.com) (Client exited)
[21:28:45] <doomlord> Lua is the most popular gamescripting langauge. it has considerable merit
[21:28:54] *** Quits: gareth0 (gareth0@moz-927693EF.dynamic.dsl.as9105.com) (Client exited)
[21:29:15] <doomlord> its easier syntax to read&write than guile/scheme. its lighter than python/JS. it does waht you need
[21:29:15] <EXetoC> doomlord: I like how it barely uses brackets :-D
[21:29:42] <doomlord> everyone i know who's used lua loves it
[21:29:58] <ctult> doomlord: That will probably be what I have to use, even though I hate the language.
[21:30:06] <ctult> Or maybe _why's Potion language.
[21:30:09] <doomlord> lua has one niche as far as i know - game scripting, including in AAA games
[21:30:28] *** Quits: zakora (NC@moz-8EAF945F.fbx.proxad.net) (Quit: Computer has gone to sleep.)
[21:30:30] <doomlord> you could say lua is the de-facto standard game scripting language
[21:30:36] <doomlord> what do you hate about lua?
[21:30:45] <engla_> wikipedia has moved to lua for their templates
[21:30:59] <ctult> doomlord: It has no paradigm
[21:31:05] <doomlord> who needs a paradigm
[21:31:10] <doomlord> FP/OOP?
[21:31:14] <doomlord> the best languaegs are hybrid
[21:31:30] <ctult> But it has both bad FP and bad OOP.
[21:32:00] <doomlord> bad FP or bad OOP is one or the other in isolation :) mix them, its good :)
[21:32:20] <doomlord> mix alongside good old fasioned procedural
[21:32:30] <ctult> maybe.
[21:32:57] <engla_> the simplicity of lua enables many good things. like being easy to grasp, small to embed, fast when JITed
[21:33:00] <doomlord> bad languaes force everything into FP, or OOP. resulting in things that are simple in the other paradigm being complex
[21:33:06] *** Joins: zakora (NC@moz-8EAF945F.fbx.proxad.net)
[21:33:06] *** Quits: zakora (NC@moz-8EAF945F.fbx.proxad.net) (Max SendQ exceeded)
[21:33:25] <engla_> compare attribute lookup in Python and Lua :-)
[21:33:25] <ctult> doomlord: If you just use one paradigm though everything is good.
[21:33:27] <doomlord> haskell is fantastic until you see the complexity generated by lenses to do simple imperative things
[21:33:39] <doomlord> disagree. different paradigms do different things better
[21:33:54] <doomlord> a real program mixes needs for different paradigms
[21:34:16] <doomlord> javas' stupid verbosity comes from trying to make classes where none exist
[21:34:21] <ctult> doomlord: That might be why I love Ruby so much.
[21:34:29] <ctult> And hate Java.
[21:34:33] <doomlord> haskell is amazing but struggles with complexity for things that are trivial in C
[21:35:00] <ctult> Haskell used to be my go-to programming language.
[21:35:09] <doomlord> C++ suffers from many programmers who are brainwashed into writing it like Java (even though C++ is multi-paradigm, with good old fasioned procedures aswell..)
[21:35:46] *** Joins: infynyxx (infynyxx@moz-E7B0F65B.sub-70-192-196.myvzw.com)
[21:35:48] <doomlord> i've just tried haskell again, and ran into the record system again... i 'm not sure i can be bothered with it
[21:35:59] <cmr> ctult: maybe you'll like http://moonscript.org/ better?
[21:36:29] <cmr> I will admit lua isn't a great language if you want lots of candy. It provides the building blocks that enable almost any candy, but it can be a pain to use.
[21:36:37] <fread2281> cmr: ooh, coffeescript for lua
[21:36:52] <cmr> (verbose, ugly syntax, ...)
[21:37:04] *** Quits: infynyxx (infynyxx@moz-E7B0F65B.sub-70-192-196.myvzw.com) (Client exited)
[21:37:07] <mib_1b42py> Thank you cmr. That did it.
[21:37:21] <ctult> I think I should just use this: https://github.com/fogus/potion
[21:37:24] <doomlord> ctult, can your project be opensource ? instead of modders, you'd get contributors. 
[21:37:53] *** Quits: mib_1b42py (Mibbit@moz-FA2BE030.netcologne.de) (Quit: http://www.mibbit.com ajax IRC Client)
[21:38:34] <ctult> doomlord: It might, but think about how bad Minecraft would be if people contributed their additions
[21:38:46] *** Quits: victorporof (victorporo@10AA7997.880C8D58.79933D60.IP) (Quit: victorporof)
[21:39:06] <ctult> It would be ugly, huge, and slow.  And you would probably have a lot of mods that you don't like
[21:39:13] <doomlord> well you can filter it, being the project maintainer
[21:39:25] <spider-mario> doomlord : what do you think of Scala, then?
[21:39:38] <doomlord> i liked what i saw of scala, but i dont like the JVM
[21:39:39] <fread2281> ctult: or good. the fail notchcode would be gone and maybe there would be a mod API
[21:40:01] <spider-mario> what about Nemerle? It runs on .NET / Mono.
[21:40:05] <engla_> Lua is open source without accepting contributions btw.
[21:41:30] <ctult> doomlord: What is Lua's speed comparable to?
[21:41:32] <doomlord> i've seen things which can be scripted with a choice of scripting language, interfacing with the same host APIs
[21:41:43] <doomlord> i think there are JITed luas
[21:41:48] <cmr> ctult: luajit approaches C
[21:41:59] <cmr> within 2-3x for most things
[21:42:14] *** Quits: KindOne (KindOne@moz-E82E1E2A.dynamic.ip.windstream.net) (Ping timeout)
[21:42:15] <doomlord> but really, game-scripting, you should only be doing event triggering etc
[21:42:20] <doomlord> responses whatever
[21:42:37] <doomlord> heavy processing should be done by the engine  not scripting
[21:43:02] <ctult> cmr: And luajit has a cross-platform bytecode compiler, right?
[21:43:07] <cmr> ctult: Yes.
[21:43:08] <ctult> That solves two things in one.
[21:43:26] <fread2281> ctult: seen http://julialang.org/ ?
[21:43:55] <ctult> fread2281: no, I don
[21:43:57] <EXetoC> Java is a ridiculous language because of how much it's based on OO. C# isn't as bad though, right? or at least it does other things better if I'm not mistaken
[21:43:59] <ctult> 't think.
[21:44:16] <cmr> I don't mind C#. F# is preferable though.
[21:44:21] <ctult> EXetoC: I hate Java and love C#, and I am a functional programmer
[21:44:57] <doomlord> i'm rooted in C++, with stockholm syndrome.
[21:45:04] <EXetoC> heh
[21:45:07] <ctult> fread2281: What exactly is Julia?
[21:45:09] <doomlord> i dont like the java-style OOP 
[21:45:17] <EXetoC> encouraging responses. alright, thanks :-P
[21:45:19] <fread2281> ctult: I don't really know :P
[21:45:25] <doomlord> which a lot of C++ tries to do. i like "C/C++".
[21:45:42] <cmr> ctult: comperable to python but LLVM
[21:45:45] *** Quits: samnardoni (samnardoni@moz-ECB14881.cable.virginmedia.com) (Client exited)
[21:46:00] *** Joins: KindOne (KindOne@moz-E82E1E2A.dynamic.ip.windstream.net)
[21:46:15] <fread2281> also if lua isn't fast enough there's http://terralang.org/
[21:47:02] <EXetoC> doomlord: some aren't even using exceptions, which surprised me at first
[21:47:06] *** Quits: Blub\0 (wry@7E3BB9D.71150E1A.237AE2BA.IP) (Quit: night)
[21:47:08] <EXetoC> but I'm sure they have their reasons
[21:47:52] <kimundi> cscott, late reply, but you can only change a @ to @mut by copying the content. let mut isn't able to change that, because an managed box is the root of its own ownership tree
[21:49:27] <brson> is there a function in core to take the tydesc out of a box?
[21:51:19] *** Joins: james4k (james@moz-726FE3EE.com)
[21:53:00] *** Quits: KindOne (KindOne@moz-E82E1E2A.dynamic.ip.windstream.net) (Ping timeout)
[21:53:03] <cmr> Is there an easy way to import all variants of an enum from a module?
[21:53:13] <cmr> I'm imagine use module::enumname::*
[21:53:54] <brson> cmr: no
[21:55:17] <EXetoC> would be nice
[21:57:25] *** Joins: KindOne (KindOne@C09937BA.D1A4D0AD.EC6A1518.IP)
[21:58:24] *** Quits: jensnockert (jensnocker@moz-8BE55278.customer.t3.se) (Input/output error)
[22:00:16] *** Quits: ksev (DrunkenPan@745B767B.989A61DC.CA5B6332.IP) (Ping timeout)
[22:02:31] *** Joins: samnardoni (samnardoni@moz-ECB14881.cable.virginmedia.com)
[22:03:37] *** Quits: spider-mario (spidermari@moz-2BC095A6.rev.sfr.net) (Input/output error)
[22:03:51] *** Joins: infynyxx (infynyxx@moz-A5ACBA84.sub-70-192-196.myvzw.com)
[22:05:37] *** Quits: infynyxx (infynyxx@moz-A5ACBA84.sub-70-192-196.myvzw.com) (Client exited)
[22:07:20] <cmr> How can I get logs from a module? I've tried RUST_LOG=rustc::middle::build=4 make and librustc::... and just middle::build, but no dice.
[22:08:38] <cmr> hm, just rustc::middle works. bug?
[22:08:55] *** Quits: alisdair (textual@moz-EBE9F394.bchsia.telus.net) (Quit: My MacBook Pro has gone to sleep. ZZZzzzâ€¦)
[22:09:20] *** Joins: ghrust (ghrust@moz-4EF5B6E5.rs.github.com)
[22:09:20] <ghrust> 01[13rust01] 15bors merged 06auto into 06incoming: 02http://git.io/0LP4pA
[22:09:20] *** Parts: ghrust (ghrust@moz-4EF5B6E5.rs.github.com) ()
[22:16:32] *** Quits: dherman (dherman@moz-6CA476B1.hsd1.ca.comcast.net) (Quit: dherman)
[22:17:51] *** Quits: KindOne (KindOne@C09937BA.D1A4D0AD.EC6A1518.IP) (Ping timeout)
[22:21:50] <doomlord> i wonder howmuch c++ could be auto  translated to rust, and vica versa
[22:22:12] *** Joins: KindOne (KindOne@moz-A7A9C796.dynamic.ip.windstream.net)
[22:24:37] <thiez> doomlord: go write a compiler ;)
[22:25:14] *** Quits: doomlord (doomlod@moz-1035DA3D.range86-135.btcentralplus.com) (Ping timeout)
[22:25:29] <thiez> of course it might be more interesting to decompile llvm-ir to rust
[22:26:56] *** Joins: pyrac (pyrac@moz-C70D038B.w109-214.abo.wanadoo.fr)
[22:28:33] *** Quits: pyrac (pyrac@moz-C70D038B.w109-214.abo.wanadoo.fr) (Quit: pyrac)
[22:28:44] *** Quits: [o__o] (~o__o@moz-24EBFAC7.me) (Input/output error)
[22:28:49] *** Joins: [o__o] (~o__o@moz-24EBFAC7.me)
[22:40:04] *** Quits: ctult (Mibbit@moz-1BC93140.bois.qwest.net) (Quit: http://www.mibbit.com ajax IRC Client)
[22:40:20] *** Quits: q66__ (q66@6EE9DE40.46454B5D.33AABD5F.IP) (Client exited)
[22:42:10] <cmr> Duh, I wanted rustc::middle::trans::build...
[22:43:37] *** Quits: KindOne (KindOne@moz-A7A9C796.dynamic.ip.windstream.net) (Ping timeout)
[22:47:08] *** Joins: KindOne (KindOne@moz-7BBBE9B9.dynamic.ip.windstream.net)
[22:48:03] *** cscott is now known as cscottnet_away
[22:51:44] *** Quits: bytbox (s@moz-2E27684C.student.umd.edu) (Ping timeout)
[22:52:06] *** Joins: devbug (quassel@moz-E1DE087C.bchsia.telus.net)
[22:53:38] *** Quits: jaen (jaen@moz-E0979827.copit.pl) (Ping timeout)
[22:56:03] *** Joins: bytbox (s@moz-D83E9B31.wireless.umd.edu)
[22:57:21] *** Quits: mcomella (mcomella@moz-B10FF54F.ri.ri.cox.net) (Connection reset by peer)
[22:58:17] *** Joins: mcomella (mcomella@moz-B10FF54F.ri.ri.cox.net)
[23:00:36] *** Joins: zxcdw (r-a@moz-4E99E901.ip13.netikka.fi)
[23:01:14] *** Joins: erickt1 (Adium@49C4075F.3AC15C18.2321E71E.IP)
[23:01:14] *** Quits: erickt (Adium@49C4075F.3AC15C18.2321E71E.IP) (Connection reset by peer)
[23:05:07] *** Quits: tgt (tgt@moz-D59EE478.aztw.cable.virginmedia.com) (Quit: Computer has gone to sleep.)
[23:05:25] *** Joins: tgt (tgt@moz-D59EE478.aztw.cable.virginmedia.com)
[23:06:36] *** Joins: aatch (aatch@moz-B437F499.pocketrent.com)
[23:07:41] *** Quits: vosen (vosen@moz-266BA656.icpnet.pl) (Quit: Leaving)
[23:09:49] *** Joins: ksev (DrunkenPan@5688B28D.841F5BFE.B9B3705E.IP)
[23:11:42] *** Quits: ksev (DrunkenPan@5688B28D.841F5BFE.B9B3705E.IP) (Ping timeout)
[23:16:32] *** Quits: erickt1 (Adium@49C4075F.3AC15C18.2321E71E.IP) (Quit: Leaving.)
[23:21:25] *** Quits: FrozenCow (FrozenCow@moz-9DF5D010.dynamic.upc.nl) (Client exited)
[23:27:18] *** Quits: samnardoni (samnardoni@moz-ECB14881.cable.virginmedia.com) (Client exited)
[23:27:18] *** Joins: Jesse (jruderman@moz-537BCF9.hsd1.ca.comcast.net)
[23:34:38] *** Joins: SiegeLord (sl@moz-CAF07B4C.hsd1.ma.comcast.net)
[23:37:31] *** Joins: int3_ (int3_@moz-B7B5F043.singnet.com.sg)
[23:39:23] *** Quits: int3_ (int3_@moz-B7B5F043.singnet.com.sg) (Ping timeout)
[23:42:40] *** Joins: int3_ (int3_@moz-B7B5F043.singnet.com.sg)
[23:43:16] *** Quits: int3_ (int3_@moz-B7B5F043.singnet.com.sg) (Client exited)
[23:48:07] <cmr> debug logging is *slow*
[23:49:49] <cmr> Are the strings that are logged deallocated?
[23:50:10] <cmr> because memory usage seems to be unbounded.
[23:50:46] <aatch> cmr, they are
[23:50:53] <brson> there could be a leak though
[23:51:00] <brson> i've seen several @ leaks recently
[23:51:09] <aatch> especially since it uses @-allocated writers
[23:51:17] <aatch> (which it really shouldn't)
[23:51:29] <brson> yeah, all logging currently uses @
[23:51:33] <brson> sadly
[23:51:51] <aatch> They should really use ~Writers
[23:52:18] <cmr> Anyway after running for an hour, I get:
[23:52:18] <cmr> rust: ~"Call(Fn=*fn({i64}, *{}, *{}) -> *{}, Args=~[@\"*{i64}\", @\"*{}\", @\"*{}\"])"
[23:52:18] <cmr> rustc: /home/rustbuild/src/rust-buildbot/slave/snap3-linux/build/src/llvm/lib/IR/Instructions.cpp:281: void llvm::CallInst::init(llvm::Value*, llvm::ArrayRef<llvm::Valu
[23:52:22] <cmr> Which... is less useful than I had hoped.
[23:52:59] <cmr> rusti:  ~"Call(Fn=*fn({i64}, *{}, *{}) -> *{}, Args=~[@\"*{i64}\", @\"*{}\", @\"*{}\"])"
[23:53:00] -rusti- ~"Call(Fn=*fn({i64}, *{}, *{}) -> *{}, Args=~[@\"*{i64}\", @\"*{}\", @\"*{}\"])"
[23:53:08] <cmr> rusti:  fmt!("%s", ~"Call(Fn=*fn({i64}, *{}, *{}) -> *{}, Args=~[@\"*{i64}\", @\"*{}\", @\"*{}\"])")
[23:53:09] -rusti- ~"Call(Fn=*fn({i64}, *{}, *{}) -> *{}, Args=~[@\"*{i64}\", @\"*{}\", @\"*{}\"])"
[23:53:20] <cmr> darnit, unescape
[23:53:40] *** Joins: jaen (jaen@moz-E0979827.copit.pl)
[23:53:42] <cmr> oh
[23:53:47] <cmr> rusti:  println(fmt!("%s", ~"Call(Fn=*fn({i64}, *{}, *{}) -> *{}, Args=~[@\"*{i64}\", @\"*{}\", @\"*{}\"])"))
[23:53:47] <aatch> rusti: println(~"Call(Fn=*fn({i64}, *{}, *{}) -> *{}, Args=~[@\"*{i64}\", @\"*{}\", @\"*{}\"])")
[23:53:48] -rusti- Call(Fn=*fn({i64}, *{}, *{}) -> *{}, Args=~[@"*{i64}", @"*{}", @"*{}"])
[23:53:49] -rusti- Call(Fn=*fn({i64}, *{}, *{}) -> *{}, Args=~[@"*{i64}", @"*{}", @"*{}"])
[23:53:52] <cmr> heh
[23:54:29] *** Quits: lkuper (lkuper@moz-D6AAFF3.cs.indiana.edu) (Ping timeout)
[23:54:39] <aatch> brson, r? https://github.com/mozilla/rust/pull/6614
[23:58:06] *** Joins: anshin (nbs@441B8B9E.2055B963.D2A6B5.IP)
[23:59:04] *** Quits: Jesse (jruderman@moz-537BCF9.hsd1.ca.comcast.net) (Quit: Jesse)
[23:59:15] *** Joins: maxli (maxli@C03F2759.C70D537E.2FA4EA88.IP)

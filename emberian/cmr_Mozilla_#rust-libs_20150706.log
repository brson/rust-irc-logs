[00:33:02] *** Quits: Tobba (Tobba@moz-o13d22.bredband.telia.com) (Ping timeout: 121 seconds)
[00:50:11] *** Quits: nagisa (nagisa@moz-8t068g.static.zebra.lt) (Ping timeout: 121 seconds)
[00:50:40] *** Joins: aatch (james@moz-i1k1ks.tlms.2o1v.e006.2406.IP)
[01:09:35] *** Quits: aatch (james@moz-i1k1ks.tlms.2o1v.e006.2406.IP) (Connection closed)
[01:10:21] *** Joins: aatch (james@moz-i1k1ks.tlms.2o1v.e006.2406.IP)
[01:35:07] *** Quits: bluss (bluss@moz-ec5o68.cust.bredbandsbolaget.se) (Ping timeout: 121 seconds)
[01:58:29] *** Joins: Tobba (Tobba@moz-o13d22.bredband.telia.com)
[02:19:24] *** Quits: kimundi (kimundi@moz-22fjhj.o533.1q3j.4fe2.2002.IP) (Ping timeout: 121 seconds)
[02:25:11] *** Joins: kimundi (kimundi@moz-d91h8n.dip0.t-ipconnect.de)
[03:15:52] <Elaine> It seems impossible to get a raw pointer to the guts of a VecDeque for the purposes of read(2)'ing directly into it?
[03:20:10] <Elaine> This ring buffer is surprisingly not very useful in unsafe code, which is where you'd think it would shine!
[03:20:35] <Elaine> I don't even know if the front or back is the side which has trailing allocation on the end of it after I call reserve.
[03:22:28] <Elaine> Or even which side .extend does.
[03:22:46] *** Quits: Rym (uid91135@moz-n2i7qm.charlton.irccloud.com) (Quit: Connection closed for inactivity)
[03:23:13] <Elaine> I assume it's the back, in that you enter a queue on the back and leave on the front...
[03:24:10] * Elaine writes some docs.
[03:25:02] <Elaine> nope.
[03:28:13] <Elaine> Oh, yes, it is, sorry, herp.
[03:28:16] <Elaine> Forgot what I said.
[03:30:50] <Elaine> I actually cannot figure out which end has extra space after reserve.
[03:30:54] <Elaine> Gankro: do you know off-hand?
[03:31:09] <Gankro> blerp
[03:31:10] *** Quits: rustbot (havvy@moz-tb54ql.airspeedinternet.net) (Ping timeout: 121 seconds)
[03:31:11] <Gankro> what's up
[03:31:23] <Elaine> Trying to figure out which end of the vecdeque has extra space after a reserve()
[03:31:41] <Gankro> I don't think either does, necessarily
[03:32:12] <Gankro> e.g. the space is in the middle
[03:32:25] <Elaine> Hrm. Is there a reasonable way to expose the slack as a raw pointer such that I could libc::read into it and do some sort of set_len equivalent?
[03:32:37] <Gankro> Wait that might be ideal
[03:32:50] <Gankro> THe real problem is when the slack is the wrapped bit
[03:32:59] <Gankro> so it's like [_____xxxxx____]
[03:33:05] <Elaine> Ah crap, yeah.
[03:33:43] <Gankro> Elaine: I suppose we could expose the inverse of slices
[03:33:47] <Gankro> uninit_slices
[03:33:49] <Gankro> or whatever
[03:34:14] <Gankro> Elaine: the impl details are way hairier than Vec though
[03:34:16] <Elaine> I think you wouldn't want slices directly, as that would make it somewhat easier to accidentally index them and read uninit garbage.
[03:34:19] <Elaine> Gankro: yeah they are.
[03:34:37] <Gankro> e.g. one index has to be empty
[03:34:48] <Gankro> so only allocation-1 space is available
[03:34:53] <Elaine> Hm.
[03:34:57] <Gankro> But reserve should handle that
[03:35:07] <Elaine> I'd hope so.
[03:35:25] <Elaine> I really want this code to be zero-copy, as it's in some input handling core library and that can be latency sensitive.
[03:36:01] <Gankro> Elaine: Does it have to become a memcopy? Can you handle writing each element?
[03:36:26] <Elaine> Gankro: Well, it's going through a read syscall, so going element-by-element does extra context switches.
[03:36:40] <Gankro> Ah shoot
[03:36:45] <Elaine> Right now I'm just reading into a temporary Vec and doing an extend.
[03:36:56] <Elaine> (obviously, since that's the only way to do it with the public api)
[03:37:02] <Gankro> Elaine: So one thing I've often pondered about was an align() method
[03:37:07] <huon> can you do one-or-two read calls?
[03:37:16] <Elaine> Yeah, doing two would be fine.
[03:37:17] *** Joins: rustbot (havvy@moz-tb54ql.airspeedinternet.net)
[03:37:21] <Elaine> For each half of the split slack.
[03:38:01] <Gankro> Elaine: so you could ask the data to be left-or-right aligned so you can blindly write to the rest without thinking about circularity
[03:38:23] <Elaine> Gankro: That seems like a reasonable method to add, but it'd be unnecessary shuffling in some cases it seems.
[03:38:44] <Gankro> Elaine: guaranteed no-op if you access it right, at least
[03:38:52] <Gankro> Elaine: What's the motivation for a Deque?
[03:38:54] <Elaine> What is the "right" way?
[03:39:09] <Elaine> Gankro: I read N events from the kernel into the deque and the consumer reads them out.
[03:39:23] <Elaine> And the order is important
[03:39:25] <Gankro> Elaine: Are you just using it as a stack?
[03:39:28] <Elaine> No, as a queue.
[03:39:30] <Gankro> *queue
[03:39:32] <Gankro> Yeah ok
[03:39:34] <Elaine> Yes, as a queue
[03:39:35] <Gankro> So not a deque
[03:39:38] <Elaine> Right.
[03:39:57] <Gankro> I assume read/writes are interspersed?
[03:40:02] <Elaine> Mhm.
[03:40:22] <Gankro> Yeah align isn't going to help there
[03:40:26] <Elaine> But in the ideal case the consumer drains the queue entirely before another write.
[03:40:42] <Elaine> So inefficiency when that isn't the case would actually be OK.
[03:40:42] <Gankro> Ah if you're drained align is free!
[03:40:45] <Elaine> Right!
[03:41:13] <Gankro> Elaine: does the consumer know how many they want at once?
[03:41:27] <Elaine> Gankro: Nope, no way for them to know.
[03:41:36] <Elaine> They just want "all the events since the last time I asked you for them"
[03:41:51] <Gankro> Isn't that... all the events?
[03:42:04] <Elaine> All the events in the queue, at least.
[03:42:17] <Gankro> Elaine: So why can't they just `drain`?
[03:42:19] *** Joins: annodomini (lambda@moz-qgii5v.ma.comcast.net)
[03:42:22] <Gankro> on a Vec
[03:42:23] <Elaine> It's hard for me to communicate this effectively since there are three separate queues, two in the kernel and one in userpsace...
[03:42:28] <Elaine> Gankro: because drain is unstable :D
[03:42:44] <Gankro> All the cool kids use nightly :P
[03:42:48] <Elaine> Alas.
[03:43:06] <Elaine> I could have a #[cfg(unstable)] that just uses Drain
[03:43:13] <Elaine> and let the stable scrubs be inefficient
[03:43:18] <Gankro> haha
[03:43:53] <Elaine> That actually seems really reasonable.
[03:44:44] <Gankro> I await the "stable rust is slow" blogposts
[03:46:04] <Elaine> I think this still leaves a hole in the VecDeque API even if I don't need to use that hole.
[03:46:22] <Gankro> I don't think many use it, so there's little demand
[03:46:37] <Elaine> mm.
[03:47:02] <Elaine> Judging by https://github.com/rust-lang/rust/pull/26806, I have to agree with that :P
[03:47:05] <Gankro> Settling on the repr is more controversial than Vec
[03:47:08] <Elaine> Yeah.
[03:47:20] <Elaine> Vec is easy, ring buffers are not.
[03:47:39] <Gankro> But align hypothetically bypasses that
[03:47:41] <Gankro> maybe
[03:47:42] <Elaine> It doesn't help that a lot of ring buffers in C are intrusive.
[03:48:04] * Elaine looks at what boost does
[03:48:23] * Gankro thinks brson dropped the ball not calling stdx "roost"
[03:49:05] <Elaine> lol stdx's readme.
[03:49:36] <Elaine> http://brson.github.io/temple-of-rust/
[03:49:41] <Elaine> brson is such a lovely person.
[03:50:21] <Elaine> Nice, it includes bitflags. Literally every crate I've writen in the past two days has used bitflags.
[03:50:56] <Elaine> "Rust 1.2 will be the first release for which stdx exists. There are no previous revisions yet."
[03:51:00] <Elaine> Is stdx going to be official?
[03:51:56] <Elaine> http://www.boost.org/doc/libs/1_58_0/doc/html/circular_buffer.html has lovely diagrams.
[03:52:43] <Gankro> stdx will at worst be defacto official, I reckon
[03:52:43] <Elaine> Oh, it only overwrites over old elements instead of expanding.
[03:52:53] <Elaine> They cop out.
[03:53:10] <Gankro> Stupid *real* ringbuffers
[03:53:55] <Elaine> r? https://github.com/rust-lang/rust/pull/26817
[03:58:16] <Gankro> Elaine: there was actually some discussion of e.g. append_back
[03:58:21] <Gankro> er, front
[03:58:23] <Gankro> well, both
[04:21:35] *** Joins: Tuba (Tobba@moz-o13d22.bredband.telia.com)
[04:22:28] *** Quits: Tobba (Tobba@moz-o13d22.bredband.telia.com) (Ping timeout: 121 seconds)
[04:22:48] *** Tuba is now known as Tobba
[04:46:57] *** Quits: annodomini (lambda@moz-qgii5v.ma.comcast.net) (Client exited)
[04:52:15] *** Quits: Tobba (Tobba@moz-o13d22.bredband.telia.com) (Connection closed)
[04:53:18] *** Joins: Tobba (Tobba@moz-o13d22.bredband.telia.com)
[05:55:48] *** Quits: Tobba (Tobba@moz-o13d22.bredband.telia.com) (Connection closed)
[05:56:52] *** Joins: Tobba (Tobba@moz-o13d22.bredband.telia.com)
[06:04:13] *** Quits: aatch (james@moz-i1k1ks.tlms.2o1v.e006.2406.IP) (Quit: Leaving)
[06:37:16] *** Joins: aatch (james@moz-is4j4r.cable.telstraclear.net)
[07:48:32] *** Quits: Tobba (Tobba@moz-o13d22.bredband.telia.com) (Ping timeout: 121 seconds)
[08:03:32] *** Joins: bluss (bluss@moz-ec5o68.cust.bredbandsbolaget.se)
[08:15:15] <aatch> Gankro, would this need an RFC to be added to libcore/libstd? https://play.rust-lang.org/?gist=d38ac5583f653dbb054c&version=stable
[08:36:45] *** Joins: Tobba (Tobba@moz-o13d22.bredband.telia.com)
[08:44:53] <SimonSapin> aatch: I’m not sure chunk_chars is a good idea, given combining code points are a thing. What’s the use case?
[08:46:04] <aatch> SimonSapin, no idea, guy on #rust wanted the functionality. Apparently it (well, just `chunks`) was proposed in an RFC and met with skepticism.
[08:46:12] <aatch> SimonSapin, which is fair enough.
[08:46:39] <SimonSapin> aatch: do you want to count "user-percieved characters"? (It’s a fuzzy concept.) Columns in a monospace font? (Some characters are "double width") Something else?
[08:47:13] *** Joins: nagisa (nagisa@moz-8t068g.static.zebra.lt)
[09:05:10] *** Quits: aatch (james@moz-is4j4r.cable.telstraclear.net) (Ping timeout: 121 seconds)
[10:00:10] <eternaleye> SimonSapin: I'd say that "graphemes" is the only meaningful unit there
[10:00:20] <eternaleye> SimonSapin: Considering doublewide characters that are single-codepoint
[10:00:41] <eternaleye> SimonSapin: And "graphemes" *is* the unicode definition of "user-perceived characters"
[10:01:20] <eternaleye> SimonSapin: http://unicode.org/reports/tr29/
[10:01:43] <eternaleye> Oh, proper term is "grapheme *clusters*", my mistake
[10:02:47] <eternaleye> SimonSapin: Oh, I see what you mean now by fuzzy, what with the spec encouraging locale-specialization of it :/
[10:06:38] <bluss> eternaleye: what's the use case you are thinking of then, if graphemes is the only meaningful?
[10:07:22] <bluss> I imagine some kind of parsing where you expect a certain format, certain range of characters where chunking could be meaningful
[10:08:11] <bluss> in such a context where you know a grapheme algorithm and by codepoint algorithm would segment it the same way, you could say
[10:22:49] <eternaleye> bluss: I mean that there really aren't any other feasible ways to do it
[10:23:14] <eternaleye> bluss: Columns are outright impossible, due to double-width single-codepoint chars existing
[10:23:35] <eternaleye> bluss: And graphemes are important in text _rendering_
[10:23:53] <eternaleye> bluss: If someone wanted to implement HarfBuzz or Pango in Rust, it'd draw one grapheme at a time
[10:24:20] <bluss> yes, so this doesn't look like it's the area where chunk_chars can be sensibly applied
[10:24:21] <eternaleye> bluss: Possibly with some matching against grapheme tuples in order to use ligatures
[10:24:26] <eternaleye> bluss: Oh, agreed
[10:24:28] <bluss> so I have to imagine other areas
[10:24:44] <eternaleye> bluss: Chunk APIs are a poor fit for strings IMO
[10:25:05] <eternaleye> bluss: I'm more saying that once you go above "codepoints", the next meaningful unit is "graphemes"
[10:25:24] <eternaleye> bluss: And above that, you hit _major_ locale pain because beyond that it'
[10:25:27] <eternaleye> s "words"
[10:25:30] <bluss> I can imagine it being useful in some settings
[10:25:49] <bluss> being completely wrong in others doesn't falsify its potential usefulness
[10:26:24] <bluss> I demo'd the Pattern API for aatch to show that once it goes stable you can coax str::split to produce the chunks for you  https://play.rust-lang.org/?gist=e55632e564519249ad7e&version=nightly
[10:26:41] <bluss> so that way it is "easily" available
[10:26:44] <eternaleye> bluss: The whole point of chunk APIs are to take a variable length sequence, and turn it into a variable-length sequence of fixed-length sequences
[10:26:56] <eternaleye> bluss: Using anything but plain codepoints violates unicode invariants
[10:27:03] <eternaleye> er, scratch that
[10:27:14] <eternaleye> bluss: Using plain codepoints violates unicode invariants
[10:27:28] <eternaleye> bluss: Using *anything* else means those fixed-length sequences *aren't*
[10:27:45] <eternaleye> bluss: So chunk APIs for strings strike me as a contradiction in terms
[10:28:06] <bluss> you seem to argue that it's wrong for one usecase and that means it's wrong for all?
[10:28:55] <eternaleye> bluss: No, I'm saying that strings are defined as unicode, chunking it by codepoint violates unicode, thus != string... and chunking by grapheme/etc violates the concept of chunking
[10:29:12] <eternaleye> bluss: Thus "string chunking" is a poor concept entirely
[10:29:35] <bluss> “violates unicode” is not well defined
[10:30:19] <bluss> unicode is in the application domain. How applications process the same text varies
[10:30:35] <bluss> which is why rust doesn't offer a comprehensive unicode library. It's too special case
[10:30:46] <eternaleye> bluss: Combining characters without a base character are illegal.
[10:31:04] <bluss> not illegal in rust's String type
[10:31:32] <eternaleye> bluss: Sure, but it violates the spec
[10:31:48] <eternaleye> bluss: And chunking by codepoints is *impossible* to use in a spec-safe way
[10:31:56] <bluss> which spec?
[10:32:01] <eternaleye> bluss: It violates the "fall into the correctness hole" principle violently
[10:32:03] <eternaleye> bluss: Unicode
[10:32:26] <bluss> is unicode defined in a single specification?
[10:32:42] <eternaleye> bluss: ...the Unicode specification?
[10:32:56] <eternaleye> bluss: Version 8.0
[10:33:20] <eternaleye> bluss: Rust may not be a _complete_ implementation
[10:33:55] <eternaleye> bluss: But it does obey it - the chunks API would be an active hazard to safe Unicode handling _on top_ of Rust's built-in behavior
[10:34:26] <bluss> how does it obey it if it allows slicing between base character and the combining character?
[10:34:34] <bluss> it does not enforce these rules
[10:35:09] <eternaleye> bluss: Code that has the whole (valid) string can check before splitting
[10:35:36] <eternaleye> bluss: Code that has a chunk cannot know if the base point is absent, or simply in another chunk, or was _removed_ from another chunk
[10:35:36] <bluss> so a chunks-using program could check the whole valid string before chunking?
[10:35:46] <bluss> Which is what I said, there are contexts where it is useful and sane
[10:38:11] <eternaleye> bluss: An example: let 'b' be any base character, 'c' be any combining character, and the chunk size be '4 codepoints'. The string 'bbbbcbbc' is chunked into 'bbbb' 'cbbc' - the original was valid, the first is valid, the second is not on its own but if rejoined is valid. Now some naïve person uses chunks to implement a streaming text replacer, that matches the first chunk exactly, and replaces it with the empty string.
[10:38:33] <eternaleye> bluss: The replacer is correct; the string is correct; the only incorrect thing is 'chunks' ignoring a unicode invariant.
[10:38:43] <bluss> yes this is exactly what we are discussing. It can be used wrongly and correctly
[10:38:44] *** Joins: gleb (gleb@moz-3u1drv.rusanovka-net.kiev.ua)
[10:39:00] <bluss> eternaleye: so slicing already offers the same hazarrd
[10:39:02] <bluss> *-r
[10:39:39] <eternaleye> bluss: In one sense, yes... except the slicing already says that using slice boundaries that do not come from matching etc. is unsafe
[10:39:45] <eternaleye> bluss: Or rather, may panic
[10:40:20] <eternaleye> bluss: Since slicing is by _byte_, not codepoint, since codepoints are synthesized lazily
[10:40:34] <bluss> this is something I know very well
[10:40:40] <eternaleye> bluss: The codepoint level is almost always the wrong level, IMO
[10:40:56] <eternaleye> bluss: There are uses for chunks at the byte level, but we have that
[10:41:08] <eternaleye> bluss: Chunks at the codepoint level are dangerous and misleading
[10:41:14] <eternaleye> bluss: Chunks at the grapheme level are not chunks
[10:41:22] <bluss> eternaleye: do you think the chars() iterator is dangerous and misleading?
[10:41:31] <bluss> it can certainly be used to produce rubbish
[10:41:41] <eternaleye> bluss: Yes, but less so than chunks would be
[10:42:09] <eternaleye> bluss: Because chars() either entirely ignores combining stuff, or handles it manually
[10:42:22] <eternaleye> bluss: chunks() has a failure mode of _partially_ handling it, silently.
[10:43:21] <eternaleye> bluss: But chars() is still hazardous, becuase whether s/e/E/ matches é depends on the whims of whatever emitted the source text.
[10:43:47] <bluss> yep
[10:43:51] <eternaleye> bluss: Rather than programmer intent
[10:44:11] <bluss> I usually use the example of our to_ascii_uppercase either producing é or É depending on normalization
[10:44:15] <eternaleye> bluss: Still, that is a considerably smaller hazard than chunks() presents IMO
[10:44:29] <bluss> typical example of “useful” stuff in rust's libstd and produces rubbish in some settings
[10:44:38] <eternaleye> Yup
[10:45:10] <eternaleye> Personally, I think that the .chars() iterator should take a normalization form generic parameter or something
[10:45:24] <eternaleye> It's already O(n)...
[10:46:18] <bluss> it would slow it down dramatically I think
[10:47:01] <eternaleye> bluss: Maybe? If Rust internal strings are normalized in compilation, and the "default" is the same, there could be a good bit of elision
[10:47:13] <eternaleye> bluss: And when IO is involved, I doubt it would dominate
[10:47:41] <eternaleye> bluss: Since one needs to validate to make it a string _anyway_
[10:49:44] <bluss> what do you think about equality? Right now string equality is byte stream equality (and the byte stream is one-to-one to the codepoint sequence)
[10:49:55] <bluss> so right now only equal strings will produce the same .chars() sequence
[10:50:10] <eternaleye> bluss: I think equality should be handled by Unicode collation
[10:50:13] <bluss> there's so much complexity on top :) it feels good to punt it to the application domain
[10:50:38] *** Quits: blank_name (blank_name@moz-r8p.iv2.183.192.IP) (Ping timeout: 121 seconds)
[10:50:42] <eternaleye> bluss: Comparing strings with bytestream equality is as wrong as comparing floats with ==
[10:51:11] <eternaleye> bluss: It's a pretty direct equivalence, in fact
[10:51:54] <eternaleye> (I do deeply wish Unicode wasn't the massive beast it is, but we live in the world we have :/)
[10:51:54] <bluss> well. the analogy has a point
[10:52:35] <bluss> Rust's String is UTF-8 encoded data and some methods on top
[10:52:44] <bluss> so equal data means the Strings are equal
[10:52:56] <eternaleye> bluss: Yup.
[10:53:09] <eternaleye> bluss: I don't object to the string type implementing Eq on that basis
[10:53:19] <eternaleye> bluss: Same as float :P
[10:53:32] <bluss> you should have seen it before when String allowed overlong encoding :)
[10:53:42] <eternaleye> bluss: I just think we should put a lot of care into documenting how a programmer should *sanely* compare them - both cases
[10:53:44] <bluss> see, celebrate the byte stream to codepoint sequence equivalence
[10:55:12] <eternaleye> bluss: Just like there's a _lot_ of docs on why comparing floats with ==, while possible, is basically never the right thing, strings should get the same care
[10:59:41] <bluss> a comprehensive string guide for rust would be nice
[11:53:04] *** Joins: annodomini (lambda@moz-qgii5v.ma.comcast.net)
[12:16:11] <SimonSapin> eternaleye: https://github.com/unicode-rs/unicode-normalization provides Iterator<Item=char> adaptors
[12:18:38] <SimonSapin> https://github.com/SimonSapin/rust-caseless is not as well documented, but relies on them
[12:33:08] *** Quits: annodomini (lambda@moz-qgii5v.ma.comcast.net) (Client exited)
[13:40:30] <eternaleye> SimonSapin: Nice!
[14:06:15] *** Joins: proc (proc@moz-98bci9.dip0.t-ipconnect.de)
[14:14:48] *** Quits: bluss (bluss@moz-ec5o68.cust.bredbandsbolaget.se) (Connection closed)
[14:15:27] *** Joins: bluss (bluss@moz-ec5o68.cust.bredbandsbolaget.se)
[16:27:43] *** Joins: blank_name (blank_name@moz-onojo8.mi.frontiernet.net)
[16:31:26] *** Joins: annodomini (lambda@moz-hceqmj.hfc.comcastbusiness.net)
[16:39:00] *** Quits: annodomini (lambda@moz-hceqmj.hfc.comcastbusiness.net) (Client exited)
[16:49:25] *** Joins: annodomini (lambda@moz-hceqmj.hfc.comcastbusiness.net)
[16:53:13] *** Joins: brson (brson@moz-cfhap5.mtv2.mozilla.com)
[16:53:13] *** ChanServ sets mode: +qo brson brson
[16:54:28] *** Quits: annodomini (lambda@moz-hceqmj.hfc.comcastbusiness.net) (Client exited)
[17:01:07] *** Quits: brson (brson@moz-cfhap5.mtv2.mozilla.com) (Quit: leaving)
[17:03:56] *** Joins: brson (brson@moz-cfhap5.mtv2.mozilla.com)
[17:03:57] *** ChanServ sets mode: +qo brson brson
[17:04:52] *** Quits: brson (brson@moz-cfhap5.mtv2.mozilla.com) (Quit: leaving)
[17:05:23] *** Joins: brson (brson@moz-cfhap5.mtv2.mozilla.com)
[17:05:24] *** ChanServ sets mode: +qo brson brson
[17:07:33] *** Quits: gleb (gleb@moz-3u1drv.rusanovka-net.kiev.ua) (Ping timeout: 121 seconds)
[17:30:39] *** Quits: blank_name (blank_name@moz-onojo8.mi.frontiernet.net) (Ping timeout: 121 seconds)
[17:32:41] *** Joins: blank_name (blank_name@moz-onojo8.mi.frontiernet.net)
[17:33:29] *** Joins: annodomini (lambda@moz-hceqmj.hfc.comcastbusiness.net)
[17:50:52] *** Quits: annodomini (lambda@moz-hceqmj.hfc.comcastbusiness.net) (Client exited)
[17:55:01] *** Joins: annodomini (lambda@moz-hceqmj.hfc.comcastbusiness.net)
[18:10:11] *** Quits: annodomini (lambda@moz-hceqmj.hfc.comcastbusiness.net) (Client exited)
[18:18:17] *** Quits: blank_name (blank_name@moz-onojo8.mi.frontiernet.net) (Quit: leaving)
[18:19:04] *** Joins: blank_name (blank_name@moz-onojo8.mi.frontiernet.net)
[18:36:40] *** Quits: nagisa (nagisa@moz-8t068g.static.zebra.lt) (Ping timeout: 121 seconds)
[18:54:06] *** Joins: nagisa (nagisa@moz-8t068g.static.zebra.lt)
[19:42:09] *** Quits: Tobba (Tobba@moz-o13d22.bredband.telia.com) (Connection closed)
[19:49:37] *** Joins: Tobba (Tobba@moz-o13d22.bredband.telia.com)
[19:57:09] *** Quits: Tobba (Tobba@moz-o13d22.bredband.telia.com) (Connection closed)
[20:00:09] *** Joins: Tobba (Tobba@moz-o13d22.bredband.telia.com)
[20:22:29] *** Quits: proc (proc@moz-98bci9.dip0.t-ipconnect.de) (Quit: Gotta eat my pizza)
[21:40:06] *** Quits: nagisa (nagisa@moz-8t068g.static.zebra.lt) (Ping timeout: 121 seconds)
[21:58:06] *** Joins: nagisa (nagisa@moz-8t068g.static.zebra.lt)
[22:27:49] *** Joins: annodomini (lambda@moz-qgii5v.ma.comcast.net)
[23:14:31] *** Quits: annodomini (lambda@moz-qgii5v.ma.comcast.net) (Ping timeout: 121 seconds)
[23:15:01] *** Joins: annodomini (lambda@moz-d5t.ubv.222.209.IP)
[23:26:41] *** Joins: aatch (james@moz-i1k1ks.tlms.2o1v.e006.2406.IP)
[23:48:25] <Elaine> r? https://github.com/rust-lang/bitflags/pull/17
[23:48:28] <Elaine> acrichto: ^
[23:49:28] <acrichto> Elaine: hm that seems less "obviously desirable" than much of the other functionality that has been recently added
[23:49:36] <Elaine> I agree.
[23:50:07] <acrichto> specifically the Rust syntax you're using to declare the flag names may be fairly orthogonal to the actual names of the flags
[23:50:20] <acrichto> and you can always provide the FromStr impl yourself
[23:50:46] <Elaine> "Providing an impl yourself" just doesn't scale when you have dozens of variants.
[23:51:04] <Elaine> I'm not sure what "actual names of the flags" means -- afaict this is the strict inverse of the Display impl?
[23:51:30] <acrichto> right but it scales fine if you write your own macro
[23:51:41] <acrichto> and I hope there isn't a Display impl
[23:51:43] <acrichto> that should be Debug
[23:51:51] <Elaine> Right it's Debug, sorry.
[23:51:57] <acrichto> ah yeah
[23:52:08] <acrichto> so it's not clear that the "string name" for a flag is the same as the rust identifier name
[23:52:20] <Elaine> I see, yes.
[23:55:18] <Elaine> The nice thing about having bitflags! provide it is that as a user of a library using bitflags!, I get a base feature level instead of having to ask the author to make changes/implementing it myself.
[23:55:24] <Elaine> But I agree that this may be suboptimal.

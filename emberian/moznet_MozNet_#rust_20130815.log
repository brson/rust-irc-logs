[00:00:21] *** Quits: mschifer (Adium@moz-BBE3ABD.mv.mozilla.com) (Quit: Leaving.)
[00:00:44] <graydon> Eridius: such that a naive user, who runs 'rust build' in a disorganized directory, gets deps that don't interfere with deps in other workspaces.
[00:00:49] <tjc> cmr: yes
[00:01:01] <sully> can somebody take a look at https://github.com/mozilla/rust/pull/8519
[00:01:11] <sully> lets you call supertrait methods on objects
[00:01:19] <tjc> sully: I
[00:01:20] <Eridius> ok so let me get this straight. You want to always behave as if RUST_PATH is suffixed with .rust:../.rust:../../.rust (and so on). But then you do the normal behavior of finding the first workspace in RUST_PATH that the cwd is inside (which obviously can't be .rust)
[00:01:21] <tjc> 'll look
[00:01:26] <tjc> (I tried to do that once and failed to)
[00:01:36] <Eridius> and then if you find nothing, you create the first workspace in the list, if necessary, and use that?
[00:01:41] <sully> tjc: awesome
[00:01:46] <Eridius> so if RUST_PATH is undefined, this will likely just create .rust in the current dir
[00:01:52] <graydon> Eridius: yes
[00:01:52] <sully> oh, argh, I left a warning in
[00:01:55] <Eridius> and if RUST_PATH is defined, but you're not in a workspace, it will just use the first entry. ok
[00:01:59] * sully forcepushes
[00:02:08] <Eridius> I suppose that works
[00:02:15] <cmr> So the only thing I'm proposing is that if you `rust build`, `rust install`, etc, and you do *not* supply a pkgid, rustpkg will build whatever is in the current directory. If it has dependencies, they are installed into the workspace, and used.
[00:02:28] <cmr> Basically I'm just saying "I want to be able to develop in packages outside of the workspace"
[00:02:40] <cmr> I'd expect only the source of my dependencies to land in the workspace, not *my* source itself
[00:02:55] <graydon> yeah, I think that's fair.
[00:02:55] *** Quits: gandi (zbraniecki@moz-BE33DA21.fw1.sfo1.mozilla.net) (Quit: My lid went down)
[00:02:57] <Eridius> cmr: btw, go will never fetch a dependency from the internt except with `go get`. `go install` will simply bail if it can't satisfy a dependency. We might want to do something similar
[00:03:14] <cmr> Ok, that's the only thing I'm suggesting
[00:03:15] <graydon> it'll certainly sweeten the offer of "starting to use rustpkg"
[00:03:36] <graydon> no need to reorganize your dirs on day 1, you can start using it to download deps until you want to be findable / installable yourself.
[00:04:01] <cmr> yep
[00:04:01] <tjc> so, conclusion -- rustpkg build and rustpkg install should look for source in the current directory if it can't find a workspace?
[00:04:09] <tjc> or should there be a different command, not build or install, that has that ability?
[00:04:10] <cmr> tjc: yes
[00:04:23] <Eridius> one potential worry is if you never set RUST_PATH you may end up with multiple copies of the same dependency on your machine, one per project that uses it, which may be unexpected
[00:04:24] <cmr> I don't think a different command is necessary?
[00:04:36] <graydon> tjc: that sounds about right, yeah. if it works; I mean, if it is able to make up a suitable pkgid
[00:04:51] <cmr> graydon: what do you mean make up a suitable pkgid?
[00:05:10] *** Quits: brendan (brendaneic@E908EF74.6BAC3F3B.56A6FAA.IP) (Quit: brendan)
[00:05:13] <graydon> cmr: every crate will be built with an implied pkgid.
[00:05:57] <graydon> this is replacing the previous role which UUIDs and URLs and such served, to disambiguate short-names
[00:06:20] <tjc> issue created: https://github.com/mozilla/rust/issues/8520
[00:06:29] *** Quits: eatkinson (eatkinson@moz-BBE3ABD.mv.mozilla.com) (Quit: eatkinson)
[00:06:31] *** Quits: dherman (dherman@moz-BBE3ABD.mv.mozilla.com) (Quit: dherman)
[00:06:39] <graydon> tjc: concerning 6408, got a minute to discuss?
[00:06:50] <tjc> graydon: sure
[00:07:05] <graydon> I was thinking more about it, convention-wise
[00:07:22] <graydon> it is currently the case that we take shortname = pkgid stem, yes?
[00:07:28] <graydon> like the last path component in the pkgid
[00:07:40] <graydon> github.com/mozilla/rust produces shortname 'rust'
[00:07:43] <tjc> yes
[00:07:43] <graydon> yes?
[00:08:04] <Seldaek> Eridius: frankly having per-project dependnecies is much better than system wide IMO, no central dir to clean up if you remove a project, no possibility for conflicts between versions (though that may not be an issue here)
[00:09:09] <graydon> tjc: ok. so we want to be able to say 'extern mod syntax = "github.com/mozilla/rust/src/syntax";' or such, yes?
[00:09:13] <Eridius> Seldaek: it's certainly got its benefits. I just want to recognize the downside
[00:09:27] *** Quits: dew (Instantbir@moz-8A63B53.dhcp.stls.mo.charter.com) (Ping timeout)
[00:09:36] <graydon> Eridius: there are some downsides. it's definitely a tradeoff.
[00:09:43] <Seldaek> Eridius: well the downside is only the surprise if you're not used to it no? and disk space but that's not really a big deal these days
[00:09:51] <Eridius> graydon: we should be able to say `extern mod syntax = "./syntax";` or somesuch to refer to the relative folder ./syntax
[00:10:17] <Eridius> and this should not break the ability for rustpkg to fetch/build your project, which is the issue I mentioned earlier with `go get`
[00:10:28] <Eridius> although I'm not sure how useful this really is
[00:10:32] <graydon> Eridius: that's a different feature.
[00:10:33] *** Joins: dew (Instantbir@moz-8A63B53.dhcp.stls.mo.charter.com)
[00:10:34] <Seldaek> Eridius: but per-project deps is the way everything is moving towards as far as I can see, ruby with rvm, python virtualenv, npm discourages -g, etc
[00:10:35] *** flaper87 is now known as flaper87|afk
[00:10:44] <Eridius> in Go's case, it's a lot more prevalent since you have to refer to every package by path instead of getting implicit relative modules
[00:10:52] <tjc> graydon: yes
[00:11:38] <graydon> tjc: ok. so then the trick is in figuring out where the git-repo part splits off from the path-within-it yes?
[00:11:46] <tjc> graydon: right
[00:12:10] <tjc> in the github case, that seems easy (github.com/mozilla/rust will always be the repo part)
[00:12:18] <graydon> this seems like something reasonable heuristics / configurable rules can handle
[00:12:20] <tjc> yeah
[00:12:31] <tjc> I guess in general we can start at the root and check each prefix for being-a-git-repo
[00:12:34] <graydon> like match-this-prefix => get-this-split
[00:12:47] *** Joins: brendan (brendaneic@538BABFE.A073F3E.97BBD552.IP)
[00:13:04] *** Quits: brson (brson@moz-BBE3ABD.mv.mozilla.com) (Ping timeout)
[00:13:13] <tjc> sure
[00:13:40] *** Joins: brson (brson@moz-BBE3ABD.mv.mozilla.com)
[00:13:40] *** ChanServ sets mode: +o brson
[00:13:41] *** Quits: jorendorff (jorendorff@moz-2F32ACA3.hsd1.tn.comcast.net) (Quit: jorendorff)
[00:14:41] <graydon> in the most general cases maybe. I think hard-wiring in rules for the top 10 hosting sites and having an argument flag called --repo=<repo-prefix>
[00:14:45] <graydon> will handle it well enough for now
[00:14:50] <tjc> sure
[00:15:17] <Seldaek> yeah for new code, github and bitbucket cover 99.9% of projects 
[00:15:47] <graydon> I was also wondering vaguely whether it'd be worth restricting it a touch
[00:16:02] <Seldaek> at least that's the stats I see out of 15K packages on packagist.org, 97%+ is github..
[00:16:26] *** Quits: KindOne (KindOne@664CD005.E1AE408F.34F73994.IP) (Ping timeout)
[00:16:55] <graydon> in the sense that .. you _could_ also handle 'extern mod "github.com/mozilla/rust/syntax";' (note, no src/) and just scan around for any syntax/lib.rs file
[00:17:10] <graydon> you know it has to be repo/something/syntax/lib.rs
[00:17:41] <Seldaek> I'd advise against too much magic in there.. or if you do want magic then set strict conventions that everyone must respect
[00:17:46] <graydon> the something part is just freezing your source organization that little bit more into your consumers. and we don't support having more than one installable syntax/lib.rs in a package anyways.
[00:18:04] <graydon> that is, in a given package, you have to have all-unique crate names, right?
[00:18:24] <graydon> you can't have foo/lib.rs and bleh/foo/lib.rs, because they'll both try to take libfoo.so when installing
[00:18:35] <graydon> oh, I guess if we mangle the full pathname they'll get different hashes
[00:18:40] <tjc> hmm
[00:18:47] <graydon> I guess that constraint is not necessary
[00:18:55] <graydon> Seldaek: yeah, I don't want "too much magic" either
[00:18:56] <tjc> as it is, I was assuming having foo/lib.rs and bleh/foo/lib.rs was okay
[00:19:00] <tjc> though I don't have a test for it
[00:19:08] <graydon> ok. it might be worth deciding and then adding a test.
[00:19:14] <graydon> someone will try it, goodness knows
[00:20:11] <graydon> Seldaek: just trying to make the pkgids a little less brittle, in case you move files around in your repo.
[00:20:17] <graydon> but maybe that's not too common
[00:20:18] <Seldaek> graydon: magic can always be added on top of a working system, the other way is near impossible, I learnt the hard way :)
[00:20:19] <tjc> well, if we're going to allow multiple crates in one package, it has to work, right?
[00:20:28] <graydon> Seldaek: I hear that.
[00:20:34] <tjc> at least, more than one library in one package, or more than one executable in one package
[00:20:36] *** Quits: Sodel_the_V (user@moz-853663E1.va.shawcable.net) (Quit: Eaten by a grue)
[00:20:42] *** Joins: ross (ross@moz-8A84103E.br.br.cox.net)
[00:20:53] *** Joins: KindOne (KindOne@664CD005.E1AE408F.34F73994.IP)
[00:20:59] <Seldaek> that's maybe not something you need to allow though.. 
[00:21:03] <graydon> tjc: they don't have to both be named libfoo
[00:21:11] <graydon> we are definitely allowing multiple libs and binaries in one package
[00:21:14] <graydon> that was a design requirement
[00:21:20] <tjc> yeah
[00:21:22] <Seldaek> ok :)
[00:21:32] <graydon> whether we allow multiple _with the same shortname_ is a little less clear
[00:21:45] <graydon> but I think given that the hash is the pkgid hash, it should actually work
[00:21:55] <Seldaek> yeah that doesn't sound extremely useful, except perhaps to have a lib and a binary wrapping the lib with the same name
[00:21:56] <graydon> you'll get libfoo-<hash1>.so and libfoo-<hash2>.so
[00:22:12] <Seldaek> but that could be foo and libfoo
[00:22:14] *** Joins: Jesse (jruderman@moz-BBE3ABD.mv.mozilla.com)
[00:22:35] <graydon> Seldaek: install/bin/foo and install/lib/libfoo.so are even less problematic, yeah
[00:23:02] *** Quits: maxli (maxli@13F2CEC5.7672369.D8E68FF6.IP) (Quit: Leaving.)
[00:23:03] <graydon> tjc: nothing in this conversation is too scary, is it? just working out corner cases?
[00:23:23] <tjc> graydon: no, it's not scary, just trying to keep track of all the statements as they fly by :-)
[00:23:30] *** Joins: maxli (maxli@13F2CEC5.7672369.D8E68FF6.IP)
[00:23:40] <graydon> heh. feel free to pause and ask for clarification / repetition
[00:23:55] *** Quits: maxli (maxli@13F2CEC5.7672369.D8E68FF6.IP) (Quit: Leaving.)
[00:24:07] *** Joins: eatkinson (eatkinson@moz-5CF47426.dia.static.qwest.net)
[00:24:09] <graydon> well!
[00:24:28] <graydon> I just installed rustdoc_ng via rustpkg
[00:24:34] <graydon> and it runs
[00:24:36] <graydon> excellent sign!
[00:24:41] <brson> \o/
[00:24:42] <cmr> wait it actually runs!?
[00:24:48] <tjc> great!
[00:24:49] <graydon> yup
[00:24:51] <cmr> can you run it on a crate and it spits out json?
[00:25:15] <kimundi> graydon: Another question: Apart from linking to it, does a 'extern mod' logically declare a new module whose content is whatever public interface that crate exposes, or does it work more like 'use' in that it creates an alias to the content of the extern crate under your crates module hierachy?
[00:25:22] <cmr> afaik it needs to be installed into the same directory as rustc in order to work correctly
[00:25:42] <graydon> cmr: I don't know about usability, but https://gist.github.com/graydon/599df3238e6be52e8489
[00:25:48] *** Quits: brendan (brendaneic@538BABFE.A073F3E.97BBD552.IP) (Quit: brendan)
[00:26:01] <dbaupp> cmr: iirc, I've run it locally from the build directory
[00:26:42] <tjc> hmm, I'm trying to install rustdoc_ng with rustpkg now, and it fetches but doesn't build
[00:26:44] <tjc> type errors
[00:26:49] <tjc> maybe my rustc isn't up-to-date enough =P
[00:27:05] *** Quits: KindOne (KindOne@664CD005.E1AE408F.34F73994.IP) (Ping timeout)
[00:27:08] <graydon> tjc: I had to clean and rebuild locally, yeah
[00:27:23] *** Quits: dew (Instantbir@moz-8A63B53.dhcp.stls.mo.charter.com) (Ping timeout)
[00:27:24] <graydon> and it seems I need to set CFG_* vars from make or something
[00:27:27] <doomlord> i should stick rustdoc links in my tool :)
[00:27:28] *** Joins: dew (Instantbir@moz-8A63B53.dhcp.stls.mo.charter.com)
[00:27:30] <graydon> which is a bit surprising
[00:27:34] <tjc> hmm
[00:27:45] <cmr> Oh I've seen that just now with the bencher
[00:27:53] <cmr> librustc uses env!
[00:27:53] <graydon> kimundi: I'm not sure the difference between those two statements
[00:28:21] <cmr> I don't know what the CFG_* are or why they are needed, but they're annoying
[00:28:27] <graydon> cmr: how do you normally invoke it?
[00:28:39] <cmr> graydon: rustdoc_ng? `rustdoc_ng path/to/crate.rs`
[00:28:54] <dbaupp> kimundi: it doesn't get (entirely) recompiled, so I'd guess the latter is a more reasonable way to look at it
[00:29:05] <cmr> On the bencher, though, I need to pass CFG_VERSION=1 CFG_PREFIX=foo CFG_LIBDIR=bar CFG_COMPILER_TRIPLE=x86_64-unknown-linux-gnu to get librustc to build
[00:29:08] *** Quits: dew (Instantbir@moz-8A63B53.dhcp.stls.mo.charter.com) (Ping timeout)
[00:29:26] <cmr> On further thought I don't understand the problem you have
[00:29:46] <graydon> cmr: wait, does rustdoc_ng compile the input?
[00:29:56] <cmr> graydon: yes.
[00:30:01] <graydon> oh, it expands then stops
[00:30:03] <graydon> why expand?
[00:30:11] <kimundi> graydon: If I have two 'extern mod' statements that refer to the same library, are they interchangeable, or would they create seperate definitions similar to having two 'mod foo;' statements  that refer to the same file
[00:30:14] <cmr> graydon: it runs typeck
[00:30:17] <dbaupp> graydon: https://github.com/mozilla/rust/pull/8362
[00:30:21] <cmr> the analysis passes
[00:30:22] <bjz> brson: oh, I figured out that problem
[00:30:33] <dbaupp> cmr: &
[00:30:36] <dbaupp> *^
[00:30:41] <bjz> brson: I'd just rearranged the fields in a C struct
[00:30:51] <cmr> graydon: to enable hyperlinking you need resolve, and to enable something else you need typeck
[00:30:56] <bjz> brson: which caused the segfaulkt
[00:30:58] <cmr> I don't remember what specifically I needed typeck for
[00:31:12] <dbaupp> graydon, cmr: that pull request changed the behaviour of env! to be an error if the env-var is missing
[00:31:14] <bjz> brson: https://github.com/bjz/sax-rs
[00:31:24] *** Joins: KindOne (KindOne@664CD005.E1AE408F.34F73994.IP)
[00:31:45] *** Joins: samx (sami@moz-48EC0983.dyn.optonline.net)
[00:31:51] <graydon> kimundi: interchangeable. the 'mod foo' statements cause duplicate compilation, extern mod just references an existing compilation.
[00:32:18] <dbaupp> cmr: typeck/resolve was to get the hyperlinks, right?
[00:32:33] <graydon> cmr: oh, probably to get type names, trait links, lots of stuff. you know very little about types until after typeck.
[00:33:01] <cmr> graydon: ah yeah, it was traits
[00:33:24] <cmr> resolve is obviously necessary to get any hyperlinking at all, you need the def map
[00:33:32] *** Quits: josh (josh@moz-348C4790.hsd1.mn.comcast.net) (Quit: josh)
[00:34:47] *** Quits: huseby (huseby@moz-4E8C421A.husebyhome.com) (Ping timeout)
[00:35:30] <kimundi> graydon: Hmm... Has 'extern use' ever been considered? Seems more fitting compared to 'mod' and 'use'. (No intend at syntax bikeshedding here)
[00:35:38] *** Quits: bent (chatzilla@moz-BE33DA21.fw1.sfo1.mozilla.net) (Quit: ChatZilla 0.9.90.1-rdmsoft [XULRunner 22.0/20130619132145])
[00:35:39] <graydon> a good rule of thumb is that resolve deals with foo and foo::bar; typeck deals with foo<bar> and foo.bar()
[00:36:06] <Seldaek> kimundi: that's a good point, the whole mod/extern mod tripped me up the first time I played with defining modules
[00:36:25] *** Joins: jorendorff (jorendorff@moz-2F32ACA3.hsd1.tn.comcast.net)
[00:36:50] <graydon> kimundi: oh probably, we considered about a million syntaxes for this. I don't much care so long as it avoids adding new keywords and is mostly orthogonal. but it'd be a little miserable to change in all existing code again.
[00:36:56] <tjc> kimundi: IIRC there was a loooooong discussion about that
[00:37:01] <tjc> not one I'm eager to revisit :-)
[00:37:17] *** Quits: eschweic (Adium@moz-BBE3ABD.mv.mozilla.com) (Quit: Leaving.)
[00:37:33] <graydon> likewise. there's a bug somewhere where we put all the keywords and requirements together and shook them extensively until the current arrangement settled out.
[00:37:49] <graydon> (for view items and externs and declarations)
[00:37:52] <Seldaek> kimundi: on the other hand, it sort of makes sense that you define/initialize a mod with extern mod, and then import things from it with use
[00:38:14] <Seldaek> if you'd use the mod, then use stuff from it, it would sound redundant
[00:38:52] <cmr> `use` never does anything besides look into the existing mod tree though
[00:38:57] <kimundi> He, don't want to force people to change it ;) But looking at the semantic it actually seems more consistenly named other way round. Oh well. :)
[00:39:05] <cmr> `extern use` would modify the module tree
[00:39:19] <cmr> (well, besides `pub use`...)
[00:39:31] <kimundi> cmr, Seldaek: Good point
[00:40:34] <kimundi> I think the problem is simply that extern mod is neiter a mod with additionial semantic, nor a use with additional semantic, but a third seperate thing that interacts with the module tree in a special way.
[00:41:05] <graydon> we had a strong contingent arguing for the word "link" there
[00:41:12] <cmr> (in the filesystem analogy it's mount)
[00:41:19] <dbaupp> cmr: http://www.ug.it.usyd.edu.au/~hwil7821/rust-bench/cpuacct.png
[00:41:19] <Seldaek> kimundi: yeah but keywords - like brackets - are scarce, anyway I shall go and sleep on it. 'night.
[00:41:21] <graydon> yeah, I think I proposed 'mount' at some point too
[00:41:32] <cmr> graydon: link is too good of an identifier to be a keyword!
[00:41:43] <cmr> dbaupp: shame, thanks though!
[00:41:43] <graydon> that was the strongest counterargument
[00:41:46] <brson> bjz: hey that looks really useful! put it in the package incubator
[00:41:51] <graydon> along with "not worth spending a keyword here"
[00:41:56] <cmr> yeah
[00:42:03] <bjz> brson: ?
[00:42:19] <brson> bjz: ?
[00:43:15] *** Joins: ChrisMorgan (chris@moz-6AC741CA.static.tpgi.com.au)
[00:44:41] *** Joins: josh (josh@moz-348C4790.hsd1.mn.comcast.net)
[00:45:45] *** Quits: eatkinson (eatkinson@moz-5CF47426.dia.static.qwest.net) (Quit: eatkinson)
[00:46:08] *** Quits: hjr3 (hradtke@1A0AE795.28A5F6C3.A2D40ED2.IP) (Quit: My MacBook has gone to sleep. ZZZzzzâ€¦)
[00:46:36] *** Quits: ecr (Thunderbir@moz-BBE3ABD.mv.mozilla.com) (Quit: ecr)
[00:46:58] <bjz> brson: "package incubator"?
[00:48:10] <bjz> how do I do ~str -> &'a str
[00:48:10] <graydon> attempting to mop up bors' weird behavior
[00:48:16] <Eridius> bjz: .as_slice()/
[00:48:21] <Eridius> s/\//?/
[00:48:43] <dbaupp> Eridius: s@/@?@ ;P
[00:49:05] <Eridius> dbaupp: pfft. My regular social channel will recognize and perform regex substitutions for you, but only handles / as a delimiter
[00:49:21] <Eridius> (although since I wrote the bot that does that...)
[00:49:45] *** Quits: lmandel (lmandel@moz-57D3C086.dsl.bell.ca) (Quit: lmandel)
[00:49:56] <engla> graydon: I think I tripped up bors. I deleted a branch by mistake, repushed it, reopened the PR since it was autoclosed
[00:49:58] *** Quits: BitPuffin (quassel@moz-7BB00EC9.bredband.comhem.se) (Ping timeout)
[00:50:07] <graydon> aha!
[00:50:18] <engla> https://github.com/mozilla/rust/pull/8471
[00:50:21] <graydon> #8471?
[00:50:22] <graydon> yeah
[00:50:23] <graydon> ok
[00:50:41] <graydon> so what's to happen there?
[00:50:50] <graydon> can you make a new PR? that tends to be the easiest way of un-confusing it
[00:51:02] *** Joins: lmandel (lmandel@moz-57D3C086.dsl.bell.ca)
[00:51:18] <engla> ok. it looks like it failed while building llvm on win-32-nopt for the original build of that PR. I think it's spurious
[00:51:29] *** Quits: bytewise (bytewise@moz-4A801D04.unitymediagroup.de) (Quit: Leaving)
[00:51:36] <engla> I'll make a new PR
[00:52:00] <graydon> thanks. if it's a spurious failure, you can ask someone to issue "@bors: retry" to it
[00:52:10] <graydon> but at this point I think it's sufficiently confused that a new PR will help
[00:52:26] <Eridius> graydon: btw I had to re-push #8203 (process::new)
[00:52:30] <brson> bjz: the package incubator is a hypothetical nursery for developing packages with some level of official support, standard-library type packages like xml
[00:52:35] <engla> do I need to rebase too (so that the hashes change)?
[00:52:46] <graydon> engla: might be wise, yeah
[00:52:52] <graydon> it attaches status markers to the head rev
[00:53:44] <engla> I'm sorry for the mess, hopefully bors merges the "competing" build
[00:53:59] <graydon> bjz: no worries. I'll babysit it for a bit to make sure it does.
[00:54:36] *** Quits: josh (josh@moz-348C4790.hsd1.mn.comcast.net) (Quit: josh)
[00:55:12] <bjz> brson: link?
[00:55:40] <tjc> graydon: getting back to an earlier topic, do you think we should remove all linkage attributes? including name, vers, uuid, I'm not sure what else?
[00:55:47] <bjz> graydon: that was meant for somebody else?
[00:56:17] <bjz> brson: not sure if what I have implemented is the best way
[00:56:18] <graydon> bjz: yes, was meant for engla. sorry
[00:56:39] <brson> bjz: there's no link. it doesn't really exist. sorry, i was just trying to express enthusiasm for your xml bindings
[00:56:48] <brson> it will probably exist someday
[00:57:07] <graydon> tjc: most of them, yes. I mean, it'll take a while to purge them from packages but I think rustpkg should probably complain when it sees them since they're indicative of leftovers from pre-rustpkg structure.
[00:57:08] *** Joins: josh (josh@moz-348C4790.hsd1.mn.comcast.net)
[00:57:20] <graydon> tjc: a lot of people cargo-culted that structure around for no reason, it looked official.
[00:57:31] *** Joins: m_kato (m_kato@moz-C286AD9A.bitcat.net)
[00:57:42] <dbaupp> graydon: I thought it *was* official?
[00:57:49] <graydon> well ..
[00:58:07] <graydon> nothing much used the uuid or url fields. they got hashed, helped uniqify things
[00:58:21] <graydon> but you could have put "lobster=magnet" in there just as easily
[00:58:31] <dbaupp> haha
[00:58:51] <bjz> brson: hopefully we will have a rust xml parser in the future, but it works for now at least
[00:59:07] <bjz> brson: if you have any suggestions on how to improve it let me know\
[00:59:27] <nmatsakis> bjz: extern fn patch ALMOST ready!!
[00:59:34] * nmatsakis feels a weight lifting off his shoulders
[00:59:38] <bjz> nmatsakis: !!!!!!!!!!!!!!!!
[00:59:46] <bjz> nmatsakis: YAAA
[00:59:48] <nmatsakis> hopefully just a day or two
[00:59:57] <nmatsakis> does try still work?
[00:59:59] <Eridius> what's the extern fn patch?
[01:00:06] <bjz> nmatsakis: I have to say though, I will believe it when I see it X)
[01:00:12] <nmatsakis> bjz: fair enough :)
[01:00:13] <graydon> um, I haven't tried it in forever
[01:00:24] *** Quits: int3_ (int3_@moz-ABE52D50.hsd1.ca.comcast.net) (Client exited)
[01:00:44] <dbaupp> Eridius: https://github.com/mozilla/rust/pull/6661
[01:00:55] <Eridius> oooh
[01:00:59] *** Joins: int3_ (int3_@moz-ABE52D50.hsd1.ca.comcast.net)
[01:01:47] <tjc> graydon: ok, should I officially do an RFC for that?
[01:01:52] <tjc> we don't seem to do too many RFCs lately
[01:02:42] <dbaupp> tjc: is there a way to build with -O using rustpkg?
[01:03:05] <tjc> dbaupp: right now there's no way to pass command line flags through to rustc, but there should be
[01:03:07] <tjc> I'll make an issue
[01:03:10] <tjc> unless you want to :-)
[01:03:29] <cmr> nmatsakis: I think try is working
[01:03:39] <dbaupp> tjc: you can do it, since presumably it'll be you working on it :)
[01:04:24] <tjc> done
[01:06:52] *** Quits: sigma (sigma@51C589B3.EF2694B5.DFAC6AA7.IP) (Ping timeout)
[01:08:34] <jld> Where are the globals created by trans::base::trans_constant used?
[01:10:43] <dbaupp> jld: iirc, they're enum discriminants
[01:11:17] <dbaupp> (or enum variant names, something to do with enums.)
[01:12:13] *** Quits: int3_ (int3_@moz-ABE52D50.hsd1.ca.comcast.net) (Client exited)
[01:12:28] *** Quits: doomlord (doomlod@moz-13E69BC8.range86-180.btcentralplus.com) (Ping timeout)
[01:13:32] *** Quits: mihneadb (Mihnea@moz-BE33DA21.fw1.sfo1.mozilla.net) (Quit: Leaving)
[01:14:22] <Eridius> hrm, I thought CString was supposed to test for interior nulls, but I don't see that in the code
[01:15:05] <dbaupp> rusti: "\x00".to_c_str()
[01:15:07] -rusti- {buf: (0x7f2720000d30 as *()), owns_buffer_: true}
[01:15:21] <dbaupp> rusti: "A\x00B".to_c_str()
[01:15:22] -rusti- {buf: (0x7ff428000d30 as *()), owns_buffer_: true}
[01:15:31] <dbaupp> Eridius: it appears that it doesn't
[01:15:39] <cmr> I thought that it did too
[01:15:45] <Eridius> dbaupp: yeah, I'm staring at the code. It never actually checks anything. But I'm pretty sure it was supposed to
[01:16:23] <dbaupp> Eridius: ask Eridius
[01:16:26] <dbaupp> gah, *erickt
[01:16:33] <Eridius> erickt: you around?
[01:16:43] <nmatsakis> pcwalton: ping
[01:16:48] <ChrisMorgan> That's certainly what I've heard being said about it.
[01:17:09] <Eridius> I'm also tempted to re-add .as_c_str() as a wrapper for .to_c_str().with_ref, for simplicity's sake, although there's an informal convention that .as_* doesn't allocate
[01:17:27] <cmr> afaik it's more than informal
[01:17:31] <Eridius> maybe .with_c_str()?
[01:17:40] * jld will comment it out and see what happens.
[01:18:08] <engla> acrichto: how do I use plural?
[01:18:25] <acrichto> engla: {0, plural, =1{...} two{...} other{...}}
[01:18:29] <engla> (can it be used to select either argument 2 or 3 from the ifmt arguments?)
[01:18:55] <acrichto> engla: yeah the thing before the first comma is a selector for the parameter, which can be an integer
[01:19:43] <engla> I mean something like this,    ifmt!("{0, plural, =1{1} other{2}", "apple", "apples")
[01:19:52] <engla> ah that's not the way it's supposed to be used
[01:19:55] *** Quits: bjz (brendanzab@B398BE78.F804C29E.D35A31DF.IP) (Quit: Leaving...)
[01:20:05] <dbaupp> rusti: ifmt!("{0, plural, =1{foo}, other{1}}", 2, "bar")
[01:20:06] -rusti- <anon>:5:15: 5:47 error: unexpected plural selector ``
[01:20:06] -rusti- <anon>:5          ifmt!("{0, plural, =1{foo}, other{1}}", 2, "bar")
[01:20:06] -rusti-                         ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
[01:20:06] -rusti- error: aborting due to previous error
[01:20:06] -rusti- application terminated with error code 101
[01:20:10] *** Joins: Jesin (Jessin_@moz-48B48C95.eecs.lehigh.edu)
[01:20:13] <engla> ok bad question anyway
[01:20:27] <brson> ChrisMorgan: how is the http client progressing? sorry i haven't been helping yet, been putting out fires mostly this week
[01:20:28] <acrichto> rusti: ifmt!("{0, plural, =1{apple} other{apples}}", 1)
[01:20:29] -rusti- ~"apple"
[01:20:33] <engla> right
[01:20:35] <acrichto> rusti: ifmt!("{0, plural, =1{apple} other{apples}}", 2)
[01:20:36] -rusti- ~"apples"
[01:20:36] <dbaupp> rusti: ifmt!("{0, plural, =1{1}, other{2}}", 2, "foo", "bar")
[01:20:36] -rusti- <anon>:5:15: 5:45 error: unexpected plural selector ``
[01:20:36] -rusti- <anon>:5          ifmt!("{0, plural, =1{1}, other{2}}", 2, "foo", "bar")
[01:20:37] -rusti-                         ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
[01:20:37] -rusti- error: aborting due to previous error
[01:20:37] -rusti- application terminated with error code 101
[01:20:44] <engla> is this sufficient for polish?
[01:20:56] <acrichto> dbaupp: no commas between cases
[01:20:56] <dbaupp> acrichto: why's mine not working?
[01:20:59] <dbaupp> oh
[01:21:04] <dbaupp> oooh!
[01:21:14] <acrichto> dbaupp: yeah the format syntax errors are hard to get super useful
[01:21:17] <dbaupp> rusti: ifmt!("{0, plural, =1{1} other{2}}", 2, "foo", "bar")
[01:21:19] -rusti- pastebinned 8 lines of output: http://ix.io/7ia
[01:21:19] * dbaupp knows
[01:21:21] <acrichto> although that empty erro rmessage is scary
[01:21:23] <ChrisMorgan> brson: I've been working on properly typed headers more recently, which will benefit both client and server
[01:21:43] <brson> ChrisMorgan: what does 'properly type headers' mean?
[01:21:46] <dbaupp> rusti: ifmt!("{0, plural, =1{{1}} other{{2}}}", 2, "foo", "bar")
[01:21:47] -rusti- ~"\"bar\""
[01:21:52] <dbaupp> \o/
[01:22:08] <dbaupp> acrichto: I vote for {} using ToStr rather than being ? too, btw.
[01:22:09] <ChrisMorgan> There hasn't been any significant change in the client since my initial prototype of it.
[01:22:20] *** Joins: brendan (brendaneic@538BABFE.A073F3E.97BBD552.IP)
[01:22:22] <engla> acrichto: do you know if it's sufficient for polish language?
[01:22:23] *** Quits: Jesin (Jessin_@moz-48B48C95.eecs.lehigh.edu) (Quit: Leaving)
[01:22:39] <acrichto> dbaupp: I'm actually really liking the `Default` option so you can define whatever you want for your own types
[01:22:44] *** Joins: Jesin (Jessin_@moz-48B48C95.eecs.lehigh.edu)
[01:22:45] <acrichto> engla: I would hope so
[01:22:46] *** Joins: ghrust (ghrust@C8693FCB.6A2AE50.F3114085.IP)
[01:22:47] <ghrust> 01[13rust01] 15bors 04force-pushed 06auto from 14ed7251a to 14e7b5729: 02http://git.io/N3iJvQ
[01:22:47] *** Parts: ghrust (ghrust@C8693FCB.6A2AE50.F3114085.IP) ()
[01:22:47] *** Joins: ghrust (ghrust@1E8607E8.6A2AE50.F3114085.IP)
[01:22:47] <ghrust> 01[13rust01] 15bors pushed 2 new commits to 06auto: 02http://git.io/QOvDDg
[01:22:47] <ghrust> 13rust/06auto 1463083ee 15Tim Chevalier: rustc: Eliminate a derived error in check::_match
[01:22:47] <ghrust> 13rust/06auto 141242b1b 15bors: auto merge of #8479 : catamorphism/rust/derived-errors, r=catamorphism...
[01:22:48] *** Parts: ghrust (ghrust@1E8607E8.6A2AE50.F3114085.IP) ()
[01:22:51] <ChrisMorgan> brson: things like treating the Date header as a Tm rather than as a ~str, Allow as ~[Method], etc.
[01:23:05] <acrichto> engla: oh I thought you meant polish as in to shine earlier in reference to something else...
[01:23:15] <dbaupp> acrichto: hm, I don't see how that's different to ToStr?
[01:23:17] <engla> no this is important
[01:23:23] <acrichto> engla: select/plural are two standard i18n functions for formatting, there's another called 'choice' that I'm not quite sure of
[01:23:33] *** Joins: int3_ (int3_@moz-ABE52D50.hsd1.ca.comcast.net)
[01:23:48] <acrichto> dbaupp: if you have ToStr on T, you can't define Default on T whatever way ou like (and you may want them to be different)
[01:23:53] <brson> ChrisMorgan: ah, neat
[01:23:58] <dbaupp> acrichto: the default formatter would be perfect as the implementation of ToStr, and vice versa, so I don't understand why we need a seperation?
[01:23:59] *** Joins: ghrust (ghrust@24260B07.6A2AE50.F3114085.IP)
[01:23:59] <ghrust> 01[13rust01] 15graydon pushed 1 new commit to 06master: 02http://git.io/jD7LiQ
[01:23:59] <ghrust> 13rust/06master 149b92500 15Graydon Hoare: Merge pull request #8479 from catamorphism/derived-errors...
[01:23:59] *** Parts: ghrust (ghrust@24260B07.6A2AE50.F3114085.IP) ()
[01:24:10] * graydon force-merged to get bors back thinking straight
[01:24:38] *** Quits: int3_ (int3_@moz-ABE52D50.hsd1.ca.comcast.net) (Client exited)
[01:24:52] <dbaupp> acrichto: have you examples of things where it is "required" for x.to_str() and fmt!("{}", x) to be different?
[01:25:21] <acrichto> dbaupp: it'd be sad for one to imply the other, I feel like you should be able to choose different ones if you want to
[01:25:27] <engla> acrichto: http://www.gnu.org/savannah-checkouts/gnu/gettext/manual/html_node/Plural-forms.html
[01:25:39] <acrichto> dbaupp: also with method lookup bugs `impl<T: Foo> Trait for T` means that you can't implement Trait for anything else
[01:25:44] <dbaupp> acrichto: (I know)
[01:26:07] <dbaupp> acrichto: (although, the method lookup bugs are different to the impl coherence.)
[01:26:12] <acrichto> engla: do you have an example?
[01:26:12] *** kimundi is now known as zz_kimundi
[01:26:21] <engla> yes there is an example in the link
[01:26:29] <engla> "In Polish we use e.g. plik (file) this way: "
[01:26:48] <acrichto> dbaupp: hmm... would you mind commenting on  https://github.com/mozilla/rust/issues/8489, I think we're trying to collect things there
[01:27:11] <acrichto> engla: it's possible, but annoying
[01:27:23] *** Quits: vk (chatzilla@moz-389FEE13.hsd1.ca.comcast.net) (Connection reset by peer)
[01:27:26] <acrichto> engla: there are no range selectors currently, so you'd have to explicitly define each case which would be sad
[01:27:31] <ChrisMorgan> brson: the standard way of doing it would then have, instead of response.headers["Date"] being a ~str, etc., response.headers.date being an Option<Tm>, etc. Extension headers probably as a Map<~str, ~str> in response.headers.
[01:27:36] <dbaupp> acrichto: sure
[01:27:40] <jld> ...well there goes how I used to debug rustc errors.
[01:27:58] <engla> oh
[01:28:00] <dbaupp> jld: ?
[01:28:02] <jld> `b upcall_fail` isn't a thing, and I keep getting errors about how CFG_* aren't defined.
[01:28:20] <jld> ...wait a minute.
[01:28:23] <engla> acrichto: so for each number from 1 to 1000? :-)
[01:28:27] <jld> How am I manageing to ICE the stage0 compiler?
[01:28:58] <dbaupp> jld: rust_begin_unwind
[01:28:59] <brson> jld: upcall_fail is called rust_begin_unwind
[01:29:09] <graydon> jld: happens all the time
[01:29:11] *** Joins: ghrust (ghrust@F6EE6DE3.6A2AE50.F3114085.IP)
[01:29:11] <ghrust> 01[13rust01] 15bors 04force-pushed 06auto from 141242b1b to 149b92500: 02http://git.io/N3iJvQ
[01:29:11] *** Parts: ghrust (ghrust@F6EE6DE3.6A2AE50.F3114085.IP) ()
[01:29:12] *** Joins: ghrust (ghrust@2EE61FCC.6A2AE50.F3114085.IP)
[01:29:12] <ghrust> 01[13rust01] 15bors pushed 2 new commits to 06auto: 02http://git.io/usc6Qg
[01:29:12] <ghrust> 13rust/06auto 1493fab48 15Corey Richardson: Remove unnecessary return
[01:29:12] <ghrust> 13rust/06auto 143dde8e0 15bors: auto merge of #8480 : cmr/rust/tutorial, r=metajack
[01:29:12] <acrichto> engla: is this naming convention in polish like the english translation of a number to a string?
[01:29:13] *** Parts: ghrust (ghrust@2EE61FCC.6A2AE50.F3114085.IP) ()
[01:29:47] <brson> not having debug logging in the stage0 compiler is a real drag
[01:30:09] <ChrisMorgan> brson: g2g for an unknown period of time, probably at least two hours. I'll be working on rust-http while I'm away, though. :-)
[01:30:16] <engla> I guess it's kinda similar. I don't actually know the language, just having worked with gettext and translators
[01:30:17] <brson> ChrisMorgan: ok :)
[01:30:18] <dbaupp> I thought someone reenabled --cfg debug for the snaps, or was I imagining things?
[01:30:49] <brson> dbaupp: i hadn't heard that, but that would be swell
[01:30:51] <engla> I just want to guard the correctness of this if it's intended for localization
[01:31:28] <dbaupp> maybe it's worth building with --cfg debug by default, and people can use --disable-debug if they want a "fast" compiler
[01:32:30] <jld> Okay.  It was the stage1 compiler that failed, and this begins to answer my earlier question about what trans_constant does.
[01:32:38] <jld> I should maybe just set VERBOSE=1 all the time.
[01:34:10] <engla> acrichto: the rule is, for singular it's CASE1. For numbers ending in 2, 3, 4  (except when ending in 12, 13, 14) it's CASE2, otherwise CASE3
[01:34:32] <engla> for example, 112 is CASE2
[01:35:56] *** Quits: goffrie (goffrie@moz-81CAF92F.dsl.ncf.ca) (Ping timeout)
[01:36:08] *** Joins: goffrie (goffrie@moz-81CAF92F.dsl.ncf.ca)
[01:36:44] <tjc> woo I got rustdoc_ng (installed via rustpkg) to build and emit json for a crate
[01:37:09] *** Joins: erickt1 (Adium@49C4075F.3AC15C18.2321E71E.IP)
[01:37:28] <acrichto> engla: to do that we'd want a second parameter of something like n % 100
[01:37:40] <acrichto> 7 cases isn't so bad
[01:39:07] <engla> you need both n % 10 and n % 100 then. but some languages need n too
[01:39:22] *** Quits: true_droid (true_droid@moz-123FD9B8.beck.volia.net) (Client exited)
[01:39:26] *** Quits: josh (josh@moz-348C4790.hsd1.mn.comcast.net) (Quit: josh)
[01:39:29] <acrichto> engla: you can specify them all as parameters
[01:39:33] *** Quits: brendan (brendaneic@538BABFE.A073F3E.97BBD552.IP) (Quit: brendan)
[01:39:33] <acrichto> it'd just be nested plural cases
[01:39:37] <cmr> tjc: awesome!
[01:40:08] <tjc> cmr: yeah, it only took me [too long] to notice it was segfaulting due to the usual issue because I hadn't set RUST_MIN_STACK...
[01:40:39] <sully> oh, argh, my PR is going to bounce
[01:40:50] <jld> So... the metadata encoder wants the symbols that trans_constant emits.
[01:40:51] <sully> it is failing an assertion in the runtime on one of the tutorial tests
[01:41:06] <engla> acrichto: ok, but it doesn't work for localization if you need different parameters for different languageu
[01:41:27] <jld> But a cross-crate variant reference uses the correct value, not the one that trans_constant emits.
[01:44:11] *** Quits: jorendorff (jorendorff@moz-2F32ACA3.hsd1.tn.comcast.net) (Quit: jorendorff)
[01:44:24] *** Quits: Houm (Houm@moz-25669AA8.fbx.proxad.net) (Ping timeout)
[01:45:43] <tjc> 'night all!
[01:45:46] *** Quits: tjc (tjc@moz-BBE3ABD.mv.mozilla.com) (Quit: Places to go, people to annoy)
[01:46:09] <acrichto> engla: good point, well this is all based off specs like https://github.com/SlexAxton/messageformat.js and  http://www.icu-project.org/apiref/icu4j/com/ibm/icu/text/PluralFormat.html
[01:46:18] <acrichto> engla: I may have missed something which enables this kind of behavior
[01:48:14] <engla> I guess it must be in the definitions of few and many
[01:48:37] <graydon> brson: r? https://github.com/mozilla/rust/pull/8525 (new snap, has stage0 carrying rtdebug fix)
[01:49:14] *** Quits: azakai (alon@moz-BBE3ABD.mv.mozilla.com) (Ping timeout)
[01:49:24] <engla> since english is  one and other, not one and many
[01:49:43] <brson> r+
[01:50:50] <acrichto> engla: although if it's by the last few digits then it should be mod
[01:50:59] <graydon> engla: I believe the CLDR spec does the mapping to the named keys
[01:50:59] <Eridius> rusti: bytes!("hello", 0)
[01:51:00] -rusti- &[104, 101, 108, 108, 111, 0]
[01:51:10] <Eridius> rusti: bytes!("he", 0, "llo")
[01:51:11] -rusti- &[104, 101, 0, 108, 108, 111]
[01:51:23] <Eridius> rusti: bytes!("he\x00llo")
[01:51:24] -rusti- &[104, 101, 0, 108, 108, 111]
[01:51:24] <acrichto> engla: also it's an XXX right now to have many/few be locale-dependent
[01:51:28] <engla> right, the locale must define the mapping of N to the zero, one, few, many, other keys
[01:51:51] <engla> few and many are confusing names for it, but that's where it must be
[01:51:51] <graydon> http://unicode.org/reports/tr35/tr35-numbers.html#Language_Plural_Rules
[01:51:53] <graydon> yeah
[01:52:00] <jeaye> rusti: bytes!(noquotes)
[01:52:00] -rusti- <anon>:5:9: 6:5 error: Non-literal in bytes!
[01:52:00] -rusti- <anon>:5          bytes!(noquotes)
[01:52:01] -rusti- <anon>:6     };
[01:52:01] -rusti- error: aborting due to previous error
[01:52:01] -rusti- application terminated with error code 101
[01:52:15] <dbaupp> acrichto: commented on that issue
[01:52:23] <pcwalton> nmatsakis: pong
[01:52:24] <acrichto> dbaupp: cool, thanks
[01:52:59] <brson> toddaaro: i think what may be going on in the bad run-pass perf is a pathological interaction between TaskFromFriend and the blocking waitpid call. the task that is blocking on waitpid is possibly running on the 'friend'
[01:53:19] <acrichto> graydon: would you have an opinion on https://github.com/mozilla/rust/issues/8489 ?
[01:53:21] <nmatsakis> pcwalton: I wanted to ask whether it was true that rustc always ran with #[fixed_stack_segment] -- but I am pretty sure answer is yes
[01:53:27] <pcwalton> yes I believe so
[01:53:53] <graydon> acrichto: looking
[01:54:17] <toddaaro> brson: ah, that could be it
[01:54:54] *** Joins: int3_ (int3_@moz-ABE52D50.hsd1.ca.comcast.net)
[01:54:57] <toddaaro> brson: I noticed some weirdness with the test_spawn_sched SingleThreaded test too, due to the pinning there all 10 pthread_joins are called from the initial thread
[01:55:50] <tikue> rusti: println("Hello there.")
[01:55:51] -rusti- Hello there.
[01:55:51] -rusti- ()
[01:56:02] <tikue> rusti: let (port, chan) = ::std::comm::stream(); let x = @1; chan.send(x); port.recv()
[01:56:05] -rusti- pastebinned 11 lines of output: http://ix.io/7ib
[01:56:38] <graydon> acrichto: what formatting flags would a fmt::Default trait be able to do anything useful with?
[01:57:03] <acrichto> graydon: the same, width/alignment and then it'd be up to an implementation to determine what precision meant
[01:57:17] <brson> toddaaro: yeah, i can imagine that
[01:57:53] <graydon> acrichto: hm. if someone did {s} would we provide an impl of fmt::Str for <T:ToStr>?
[01:58:16] <acrichto> graydon: no, I intend on defining {s} by default for str::Str implementors (&str, @str, ~str)
[01:58:29] <nmatsakis> pcwalton: cool. based on that assumption, I just set #[allow(cstack)] for the whole rust module, meaning that we it will permit C functions to be called anywhere...
[01:58:50] <pcwalton> heads up: please stop writing FromStr::from_str::<int>()
[01:58:54] <pcwalton> and the like
[01:58:59] <pcwalton> i.e. explicit type parameters on static methods
[01:59:04] <pcwalton> I am having to remove a bunch of them that landed
[01:59:08] <cmr> pcwalton: how should it be called?
[01:59:12] <dbaupp> pcwalton: will become FromStr::<int>::from_str()?
[01:59:15] <Eridius> pcwalton: what do you recommend, if it can't infer?
[01:59:21] <pcwalton> let x: int = FromStr::from_str()
[01:59:34] <pcwalton> probably it will eventually become
[01:59:39] <pcwalton> FromStr::<for int>::from_str()
[01:59:41] <engla> pcwalton: same with   HashMap::new::<int, int>() ?
[01:59:46] <pcwalton> engla: no, that's fine
[01:59:52] <Eridius> <for int>? not <int>
[01:59:58] <pcwalton> yeah, for int
[01:59:59] <jeaye> pcwalton: That syntax seems very backward to me
[01:59:59] <nmatsakis> pcwalton: woah! I... didn't know we were considering that as opposed to felix's proposal
[02:00:14] <Eridius> that's... interesting
[02:00:17] <jeaye> The usage of 'for' there
[02:00:19] <pcwalton> nmatsakis: felix's proposal was what?
[02:00:28] <brson> toddaaro: although now that i think about it I can't actually imagine the scenario where the waitpid blocking it's friends is going to cause a problem here. i'm going to try putting that waitpid in another thread and see what happens though
[02:00:29] <aatch> pcwalton, what's the difference between the from_str and new calls there?
[02:00:31] <pcwalton> stacking all the type parameters at the end was wrong and I have spent the last 2 weeks removing it
[02:00:48] <nmatsakis> pcwalton: I think in that case you had to declare some thing that wedded the FromStr to the int, I forget what syntax we brainstormed.
[02:00:52] *** Quits: int3_ (int3_@moz-ABE52D50.hsd1.ca.comcast.net) (Ping timeout)
[02:00:58] <dbaupp> aatch: from_str is Self, new is just normal type params
[02:01:05] <pcwalton> nmatsakis: I think that might be way too verbose
[02:01:06] <dbaupp> (i think)
[02:01:10] <nmatsakis> pcwalton: but yes stacking the type params at the end was wrong, moving them up is good
[02:01:11] <pcwalton> I'm having to add lets all over the place
[02:01:15] <nmatsakis> pcwalton: and ::<for int> is not verbose?
[02:01:18] <acrichto> dbaupp: what's this business with write_out you mentioned in the issue? the `&mut Formatter` has a `buf` field which is exactly a `&mut io::Writer`
[02:01:21] <Eridius> why the word "for" there?
[02:01:24] <pcwalton> nmatsakis: well, it keeps it on one line :)
[02:01:25] <jeaye> ^
[02:01:36] <cmr> Why do we need `for` there?
[02:01:40] <graydon> acrichto: I guess I just assume a lot of people will want a quick way to get the result of ToStr written; I'm sympathetic to what huon is saying there
[02:01:45] <dbaupp> acrichto: I don't quite understand how ifmt! works internally, but there's a writer, right?
[02:02:03] *** Quits: carllerche (carllerche@6B070D22.7E6A0813.1428D117.IP) (Quit: carllerche)
[02:02:06] <nmatsakis> cmr: because it's not a type parameter of anything, it's specifying the implicit Self type parameter of the trait, bsaically
[02:02:28] <graydon> acrichto: but am not of strong opinion, anything works here
[02:02:32] <acrichto> graydon: ok, my main motivation to figure this out is that I'd actually like to almost never need to do {:XXX}, and rather 90% of the time just {} is sufficient
[02:02:45] <acrichto> dbaupp: yeah, internally everything is streamed to an io::Writer
[02:02:51] <acrichto> rt::io::Writer that is
[02:02:56] <cmr> nmatsakis: I had assumed that it was supposed to be an implicit type parameter
[02:03:03] <dbaupp> acrichto: and so it'd be neat to be able to do something like fmt!("foo {write} bar", thing_that_takes_a_writer($writer)) instead of `with_str_writer |w| { w.write_str("foo "); thing_that_take_a_writer(w); w.writer_str(" bar") }`
[02:03:06] <pnkfelix> pcwalton: is there an RFC on this somewhere?  I know niko and i spent some time going over the options here a while back.
[02:03:12] <cmr> It's uncommon enough that i'd be ok with `for`
[02:03:20] <dbaupp> acrichto: (it's not particularly important, thought)
[02:03:23] <pcwalton> there isn't one I don't think
[02:03:28] <dbaupp> *though
[02:03:41] <engla> acrichto: %? and the typevisitor  find (and dereference) values that might be in an undefined state and otherwise be shielded by a safe interface + destructor. I'm unsure if that's considered valid (it could be mandated to always hide it behind a raw pointer?)
[02:04:37] <acrichto> dbaupp: that's pretty much already done, you must define a method of signature `fn fmt(&Self, &mut Formatter)` where the formatter has a buf inside that you have to write to
[02:04:39] <sp3d> it seems gross to me that "for foo" introduces a space into a (scoped) identifier name
[02:04:51] <nmatsakis> pcwalton: I guess type ascription would also solve it muc of th etime
[02:04:52] <dbaupp> acrichto: ah, neat! duck-typed?
[02:04:56] <acrichto> dbaupp: so if you impl something like String for your type T, you *must* write to the internal writer
[02:05:00] <sp3d> but I guess we already had ", " sometims
[02:05:01] <pcwalton> nmatsakis: it would, not every type though
[02:05:02] <sp3d> +e
[02:05:03] <acrichto> dbaupp: no, you must ascribe to the correct trait
[02:05:04] <pcwalton> Primitive::bits
[02:05:06] <pcwalton> was the culprit
[02:05:13] <acrichto> dbaupp: std::fmt::{String, Signed, Unsigned, ...}
[02:05:36] <acrichto> engla: yes, you're just saying that %? is a bad default? (I agree)
[02:05:47] <dbaupp> acrichto: oh, ok; sounds reasonable (although slightly more restrictive than what I was proposing); in any case, I've got to go.
[02:06:13] <dbaupp> s/slightly //
[02:06:24] <engla> acrichto: yes I think String/Default is better. But I also wonder about clarification on the invalid state question for rust in general
[02:07:10] <acrichto> engla: I think right now the type visitor will always traverse through valid rust types, so if you have a &-pointer which is actually invalid (but priv so no one else can see it), the type visitor will attempt to read it
[02:07:21] *** Quits: m_kato (m_kato@moz-C286AD9A.bitcat.net) (Ping timeout)
[02:07:26] <dbaupp> acrichto: (also, I'd forgotten about flags etc, so using ToStr is probably a no-go.)
[02:07:43] <engla> or if you have a &T that is valid, but was constructed with unsafe to be a circular link
[02:07:48] *** Joins: m_kato (m_kato@moz-C286AD9A.bitcat.net)
[02:07:57] <acrichto> dbaupp: yeah my other concern about ToStr is that it would be "the default" but the default wouldn't be fast for things like integers
[02:08:10] <acrichto> engla: yeah
[02:08:17] *** Joins: dew (Instantbir@moz-D2FA52B6.static.stls.mo.charter.com)
[02:08:22] <pnkfelix> pcwalton: I vaguely recall niko and i working through a bunch of examples for the different cases here, when he was explaining to me the motivation for the `Foo::<for Bar>::baz` syntax
[02:08:22] <engla> but ToStr needs to be redone, must be "ToWriter"
[02:08:32] <pnkfelix> pcwalton: but I think I'd still like a reminder.
[02:08:33] <dbaupp> acrichto, engla: those are your own "fault", for breaking the type-system, so I don't see why we should cripple it
[02:08:42] <pcwalton> well, I think we just need something
[02:08:43] <dbaupp> (it = %?)
[02:08:50] <pnkfelix> pcwalton: (unfortunately right now is not a good time)
[02:08:50] <engla> dbaupp: that's a valid resolution of my question
[02:08:50] <pcwalton> I don't really care what
[02:08:54] <engla> dbaupp: if it's that
[02:09:12] <acrichto> engla: well the problem with to_writer for formatting arguments is then you can't do things like alignment/padding/width/etc
[02:09:14] <engla> dbaupp: but we have all the possibilities of creating safe interfaces
[02:09:28] <engla> acrichto: it could be just to replace to_str
[02:09:32] <dbaupp> engla: that's a use of *; it's not followed by %?.
[02:10:14] <acrichto> engla: yeah it could work in some cases, but with alignment/width/precision the formatter would need a way to query how many characters would be printed, and then request that only N characters get printed
[02:10:32] *** Quits: graydon (Adium@A5087023.2354C43D.D8E68FF6.IP) (Quit: Leaving.)
[02:10:37] <strcat> rusti: 2
[02:10:38] -rusti- 2
[02:10:48] <engla> acrichto: using to_writer to write to a new ~str wouldn't be worse than the current to_str -> ~str
[02:11:02] <engla> but to_str always allocates, it's the worst case every time
[02:11:32] <acrichto> engla: fmt!("{}", 3) would be twice as slow if it had to intermediarily make an allocation of ~"3" via to_str()
[02:11:49] <pnkfelix> nmatsakis: pcwalton: FYI I'm about to put up the trait refactoring for review, but then I'll be on PTO until Monday, so there's no rush to get to it.
[02:11:51] <engla> well it doesn't with to_writer
[02:11:55] <pcwalton> ok, cool
[02:12:05] <pnkfelix> nmatsakis: pcwalton: (the visit.rs refactoring that is)
[02:12:09] <engla> I'm not advocating to_str() -> ~str, I want it to be redesigned
[02:12:13] <nmatsakis> pnkfelix: great!
[02:12:17] <jld> Evidence accumulates that discriminant symbols are not actually used, in that I commented out the code that emits them and the code that exports the names in the metadata, and rustc can bootstrap and run stage2-rpass.
[02:12:22] <nmatsakis> pnkfelix: r? me if you want :)
[02:12:42] <acrichto> engla: with to_writer though you don't know how much is being written and you can't limit it so you can't ever process formatting flags
[02:13:12] <engla> acrichto: what about   fmt!("{}", MyStruct { a: 1, b: 1, c: 1}).  with current #deriving ToStr you allocate 4 times?
[02:13:28] <engla> acrichto: but your example had no formatting flags. Also you can insert your own writer that has a byte limit
[02:14:18] <acrichto> engla: yeah the 4 allocations is bad, but formatting an integer really shouldn't require an allocation unless you request it result in one
[02:14:20] *** Quits: q66 (q66@6EE9DE40.46454B5D.33AABD5F.IP) (Quit: Leaving)
[02:14:29] <engla> right.. that's what I think too
[02:14:35] <acrichto> engla: you're right about a byte-limit writer, though, although the width would still be hard to know
[02:14:38] <acrichto> for padding
[02:14:50] <acrichto> this is why I kinda prefer a Default to T: ToStr
[02:15:02] <acrichto> b/c you can specialize things for as few allocations as possible
[02:15:10] <acrichto> the bad part is that it's not on everything as you might imagine
[02:15:20] <engla> please, I said I don't like current ToStr
[02:15:27] <strcat> it should basically never require an allocation
[02:15:40] <strcat> when you're formatting to a string, you probably want to have it append to a str
[02:15:56] <strcat> if you format 20 integers to it, it could be 1 alloc
[02:16:00] *** Quits: Jesse (jruderman@moz-BBE3ABD.mv.mozilla.com) (Quit: Jesse)
[02:16:03] <acrichto> strcat: yeah that'll always happen with {:d}, but {} is trickier
[02:16:05] <engla> you can do that with a writer-based interface
[02:16:15] <acrichto> only if you don't have width/precision
[02:16:26] <acrichto> which arguably is the common case
[02:16:30] *** Quits: sebcrozet (sebcrozet@moz-F96421F3.w80-13.abo.wanadoo.fr) (Ping timeout)
[02:16:33] <strcat> ugh
[02:16:40] <strcat> pretty printing feels like adding a newline
[02:16:47] <strcat> every time it adds 1 more ;p
[02:17:12] <acrichto> engla: you were saying though that you thought to_writer could be implemented in terms of ifmt!()
[02:17:30] <engla> no I don't think so
[02:18:07] <acrichto> it'd still be kinda a shame if you specified width/precision for an allocation to be performed with {:10} but not {:10d}
[02:19:40] <acrichto> so basically with Default, you don't get it for everything you'd want, but with ToStr (and a to_writer) on it, we could get it for lots of types, but not efficiently all the time
[02:20:40] <engla> ok I don't know about Default, I don't know about your plans for it. I'm just saying "ToWriter" is always as good or better than "ToStr"
[02:21:22] <acrichto> true
[02:21:56] <acrichto> in one case {} == those types who implement Default (provided for core types in std::fmt), and in the other case {} == those types implementing ToStr/ToWriter
[02:22:29] *** Joins: brendan (brendaneic@538BABFE.A073F3E.97BBD552.IP)
[02:23:00] *** Quits: rusti (rusti@moz-54F7FD49.cpe.net.cable.rogers.com) (Client exited)
[02:23:05] *** Joins: rusti (rusti@moz-54F7FD49.cpe.net.cable.rogers.com)
[02:23:10] <strcat> rusti: 2
[02:23:10] -rusti- 2
[02:23:22] *** Quits: MrFahrenheit (RageOfThou@3FEF494C.29C984D5.783DEDCA.IP) (Ping timeout)
[02:30:02] *** Quits: zz_kimundi (kimundi@moz-42A2AF2C.dip0.t-ipconnect.de) (Ping timeout)
[02:32:00] *** Quits: foxtrottango (Mibbit@moz-25ED1BAB.net.uwaterloo.ca) (Quit: http://www.mibbit.com ajax IRC Client)
[02:33:18] *** Joins: zz_kimundi (kimundi@moz-5D6B45D9.dip0.t-ipconnect.de)
[02:33:47] *** zz_kimundi is now known as kimundi
[02:37:00] <strcat> http://strcat.zapto.org:8000/ version 3 ;p
[02:37:08] <strcat> needs some fancy inline error reporting
[02:37:41] *** Joins: carllerche (carllerche@6B070D22.7E6A0813.1428D117.IP)
[02:38:18] *** Quits: carllerche (carllerche@6B070D22.7E6A0813.1428D117.IP) (Quit: carllerche)
[02:39:28] *** Joins: vk (chatzilla@moz-389FEE13.hsd1.ca.comcast.net)
[02:39:56] *** Quits: samx (sami@moz-48EC0983.dyn.optonline.net) (Quit: This computer has gone to sleep)
[02:40:58] *** Quits: Earnestly (earnest@B0BDF733.8FDE20A.5411983D.IP) (Ping timeout)
[02:41:57] <pcwalton> nmatsakis: r? https://github.com/mozilla/rust/pull/8528
[03:01:18] <Eridius> crud, ICE with no accompanying error
[03:01:39] <Eridius> oh huh, with RUST_LOG defined, it ends up being an unhandled condition. great.
[03:01:52] *** Joins: Jesse (jruderman@moz-537BCF9.hsd1.ca.comcast.net)
[03:02:11] <Eridius> so, umm.... making .to_c_str() fail if there's interior nulls apparently uncovered a bug in the compiler where it tried to convert ~[0, 1, 195, 190, 195, 191] to a CString
[03:02:38] <Eridius> sure wish ::rt::backtrace worked. Seeing the failure as condition.rs:43 isn't very helpful
[03:03:51] <pnkfelix> Eridius: can you run in gdb, set a breakpoint on rust_begin_unwind , then do `bt` there?
[03:04:50] <Eridius> pnkfelix: I can try with lldb (don't have gdb; I'm using the Xcode 5.0 dev seed, which drops gcc and gdb. Hopefully that's not a problem)
[03:04:55] *** Joins: snadon (chatzilla@moz-3BC727E8.mc.videotron.ca)
[03:05:08] <pnkfelix> Eridius: ah.  wow.  
[03:05:08] <jeaye> While in a `for foo in bar` is there any way I can progress the loop manually (given some condition)?
[03:05:27] <strcat> jeaye: next()
[03:05:40] <strcat> 'for' is just sugar
[03:05:49] <jeaye> strcat: On an object, or just in the body?
[03:05:57] <goffrie> strcat: I thought the for loop held onto the iterator with an explicit &mut reference
[03:06:01] <strcat> for pattern in iterator {}
[03:06:03] <strcat> compiles to
[03:06:26] <strcat> it does 'let it = &mut iterator; loop { match it.next() { Some(pattern) => { body }, None => break } }'
[03:06:50] <strcat> jeaye: well I'm not sure exactly what you want to do
[03:06:55] <sp3d> so "loop" should work?
[03:07:12] <goffrie> yup, `loop;` works as expected
[03:07:30] <jeaye> strcat: Given a char (looping through a string), I'm looking forward to the next char. When I do that (and I don't always), I want to manually skip the char I looked forward to
[03:07:55] <Eridius> pnkfelix: sadly, lldb only shows 2 stack frames. 1st is rust_begin_unwind, second is libstd-6c65cf4b443341b1-0.8-pre.dylib`rt::task::__extensions__::meth_25093::begin_unwind::_7c12263797ed078::_0$x2e8$x2dpre + 72
[03:07:55] *** Quits: brendan (brendaneic@538BABFE.A073F3E.97BBD552.IP) (Quit: brendan)
[03:08:47] <pnkfelix> Eridius: and just to double-check: This is with a â€”enable-debug build, right?
[03:08:57] <sp3d> is there some way to inspect the EBML in a compiled rust crate manually?
[03:09:08] *** Joins: bjz (brendanzab@B398BE78.F804C29E.D35A31DF.IP)
[03:09:10] <Eridius> pnkfelix: oh I forgot about that flag. Bah, I'll go rebuild
[03:09:19] <bjz> cmr: beep
[03:09:57] <bjz> Eridius:  .with_c_str() would be amaazing
[03:10:05] <Eridius> bjz: if I can get this to compile, I'll have a PR
[03:10:06] <goffrie> jeaye: I don't think you can really affect future loop iterations inside of a for loop without using some kind of flag (or other mutable state) :( you could also desugar the for loop manually, in which case you could advance the iterator yourself
[03:11:03] <Eridius> rusti: let mut it = ~[1,2,3].move_iter(); for x in it { printfln!(x); printfln!(it.next()) }
[03:11:03] -rusti- <anon>:5:23: 5:43 error: type `[<VI2>, .. 3]` does not implement any method in scope named `move_iter`
[03:11:03] -rusti- <anon>:5          let mut it = ~[1,2,3].move_iter(); for x in it { printfln!(x); printfln!(it.next()) }
[03:11:04] -rusti-                                 ^~~~~~~~~~~~~~~~~~~~
[03:11:04] -rusti- error: aborting due to previous error
[03:11:04] -rusti- application terminated with error code 101
[03:11:18] <Eridius> I thought consume_iter was renamed? or is rusti not up to date
[03:11:25] <Eridius> rusti: let mut it = ~[1,2,3].consume_iter(); for x in it { printfln!(x); printfln!(it.next()) }
[03:11:25] -rusti- <anon>:5:23: 5:46 error: type `[<VI2>, .. 3]` does not implement any method in scope named `consume_iter`
[03:11:25] -rusti- <anon>:5          let mut it = ~[1,2,3].consume_iter(); for x in it { printfln!(x); printfln!(it.next()) }
[03:11:26] -rusti-                                 ^~~~~~~~~~~~~~~~~~~~~~~
[03:11:26] -rusti- error: aborting due to previous error
[03:11:26] -rusti- application terminated with error code 101
[03:11:28] <Eridius> pfft
[03:11:38] <Eridius> oh silly me
[03:11:44] <Eridius> rusti: let mut it = (~[1,2,3]).move_iter(); for x in it { printfln!(x); printfln!(it.next()) }
[03:11:46] -rusti- pastebinned 12 lines of output: http://ix.io/7id
[03:12:02] <Eridius> damn ok, you can't touch it in the sugared loop. oh well
[03:12:27] <strcat> not until it's a compiler feature
[03:12:45] <goffrie> unfortunate, but the sugar has to work with both rvalues and lvalues
[03:15:09] <Eridius> I wonder if the for sugar could be extended to allow something like `for x in foo.iter() as it { ... }` where it is the iterator var
[03:15:29] <Eridius> so you could then say `for x in v.consume_iter() as it { printfln!(x); printfln!(it.next()) }`
[03:15:36] <goffrie> Eridius: that specific syntax looks ambiguous though :(
[03:15:54] <goffrie> not sure what would be better
[03:16:02] <Eridius> yeah, and I don't think `as` is a keyword. But surely something could be written
[03:16:14] <engla> as is a keyword :)
[03:16:16] <Eridius> Although it may not be worth complicating the syntax of the language just for this, since you can always desugar the loop yourself
[03:16:16] <goffrie> well, `as` as in `'a' as u8` exists :p
[03:16:21] <Eridius> oh dur of course it is
[03:16:35] <Eridius> although that means it definitely can't be used here
[03:16:39] <sp3d> don't we already have @ for that?
[03:16:55] <Eridius> sp3d: in patterns, yeah. `for x in it@v.consume_iter()` looks downright bizarre
[03:16:55] <goffrie> sp3d: that's for the pattern context; this is an alias for the &mut-pointer-to-iterator
[03:17:03] <engla> Eridius: you can have a macro for it
[03:17:08] <sp3d> yeah, I was suggesting it for this context
[03:17:09] <Eridius> engla: I suppose you can
[03:17:12] <sp3d> does look kinda weird though
[03:17:22] <goffrie> oh hm, that would work and also be pretty consistent, but yeah weird
[03:17:36] *** Joins: gavinb (gavinb@moz-CA19A0CF.vic.adsl.internode.on.net)
[03:17:37] <strcat> Eridius: it's really not necessary
[03:17:45] <goffrie> it's just the clash between the `for` `in` keywords and the `@` not-keyword, I think
[03:17:50] <strcat> it will work as you want it to when it's implemented in the compiler
[03:17:56] <Eridius> ok
[03:18:28] <strcat> I need some sample code to seed the web UI thing
[03:18:30] <strcat> ;p
[03:18:57] <goffrie> strcat: so it'll only make a temporary on rvalues?
[03:19:03] <strcat> yes
[03:19:10] <goffrie> hmm, seems reasonable
[03:19:21] <goffrie> strcat: what about the snippet on the front page :p
[03:19:37] *** Joins: carllerche (carllerche@6B070D22.7E6A0813.1428D117.IP)
[03:19:42] <Eridius> is the snippet on the front page supposed to be rust 0.7, or is it just outdated?
[03:19:48] <strcat> 0.7
[03:20:07] <Eridius> wow, compiling with RUST_LOG=rustc=4 prints a lot of stuff
[03:20:23] *** Quits: brson (brson@moz-BBE3ABD.mv.mozilla.com) (Ping timeout)
[03:20:26] *** Joins: brson (brson@moz-BBE3ABD.mv.mozilla.com)
[03:20:26] *** ChanServ sets mode: +o brson
[03:24:44] <acrichto> r? https://github.com/mozilla/rust/pull/8414
[03:25:27] *** Joins: mihneadb (Mihnea@moz-329F29A3.lightspeed.sntcca.sbcglobal.net)
[03:25:49] *** Quits: pcwalton (pcwalton@E2F7352.56080C53.97BBD552.IP) (Quit: pcwalton)
[03:26:10] *** Joins: ghrust (ghrust@F6EE6DE3.6A2AE50.F3114085.IP)
[03:26:10] <ghrust> 01[13rust01] 15bors merged 06auto into 06master: 02http://git.io/usc6Qg
[03:26:10] *** Parts: ghrust (ghrust@F6EE6DE3.6A2AE50.F3114085.IP) ()
[03:26:29] *** Joins: brendan (brendaneic@E908EF74.6BAC3F3B.56A6FAA.IP)
[03:27:08] <sp3d> how does rust compress its metadata these days?
[03:27:54] <acrichto> sp3d: zlib I believe from src/rt/miniz.cpp
[03:28:22] *** Quits: brendan (brendaneic@E908EF74.6BAC3F3B.56A6FAA.IP) (Quit: brendan)
[03:28:40] <sp3d> thanks <3
[03:28:49] *** Quits: vk (chatzilla@moz-389FEE13.hsd1.ca.comcast.net) (Ping timeout)
[03:28:56] *** Joins: brendan (brendaneic@E908EF74.6BAC3F3B.56A6FAA.IP)
[03:29:11] *** Joins: ghrust (ghrust@79968228.6A2AE50.F3114085.IP)
[03:29:11] <ghrust> 01[13rust01] 15bors pushed 0 new commits to 06auto: 02http://git.io/e3CDnA
[03:29:11] *** Parts: ghrust (ghrust@79968228.6A2AE50.F3114085.IP) ()
[03:29:14] *** Joins: ghrust (ghrust@9C8B94D4.6A2AE50.F3114085.IP)
[03:29:14] <ghrust> 01[13rust01] 15bors pushed 2 new commits to 06auto: 02http://git.io/NjBHnA
[03:29:14] <ghrust> 13rust/06auto 143411846 15Graydon Hoare: register new snapshots
[03:29:14] <ghrust> 13rust/06auto 1413c8254 15bors: auto merge of #8525 : graydon/rust/2013-08-14-register-snapshots, r=brson...
[03:29:14] *** Parts: ghrust (ghrust@9C8B94D4.6A2AE50.F3114085.IP) ()
[03:29:33] *** Joins: vk (chatzilla@moz-389FEE13.hsd1.ca.comcast.net)
[03:30:54] *** Quits: brendan (brendaneic@E908EF74.6BAC3F3B.56A6FAA.IP) (Quit: brendan)
[03:31:37] *** Quits: vk (chatzilla@moz-389FEE13.hsd1.ca.comcast.net) (Quit: ChatZilla 0.9.90.1 [Firefox 24.0/20130812173056])
[03:35:20] <Eridius> pnkfelix: recompiling with --enable-debug doesn't seem to have changed anything. 
[03:35:38] <pnkfelix> Eridius: sorry for the red herring
[03:36:05] <pnkfelix> Eridius: (i got a useful stack trace out of it this morning, but my situation was no doubt different from yours)
[03:36:09] <Eridius> pnkfelix: I tried RUST_LOG=rustc=4 but that spewed out so much output, that it slowed the compilation so much that it never finished
[03:36:21] <Eridius> I let it run for 15+ minutes..
[03:37:15] <pnkfelix> Eridius: I'm hitting the sack.  Sorry I can't be of more help.
[03:37:25] <Eridius> pnkfelix: I'm going to try installing gdb by hand and seeing if that helps
[03:37:26] <Eridius> thanks anyway
[03:38:06] <strcat> oh well it serves a random sample now, if only I had some good ones :P
[03:38:47] *** Quits: pnkfelix (pnkfelix@moz-43495417.fbx.proxad.net) (Quit: Leaving.)
[03:42:06] *** Joins: Cromulent (Cromulent@moz-983B638D.cable.virginmedia.com)
[03:43:04] <bjz> is there a sorted hashset?
[03:43:22] <strcat> bjz: no, hash tables are inherently unsorted
[03:43:23] <strcat> there's treeset
[03:43:27] <Eridius> bjz: TreeSet
[03:43:28] <Eridius> from extra
[03:43:36] <bjz> ok
[03:43:39] <bjz> cheers
[03:44:30] <acrichto> klutzy: ping
[03:46:04] <Eridius> wow, the hand-installed gdb is throwing internal errors. 
[03:46:34] *** Joins: wilmoore (wilmoore@moz-71431C3A.hsd1.co.comcast.net)
[03:48:37] <acrichto> cmr: Seldaek: ping
[03:50:13] <jld> So, um, my `make check` run just printed a Lovecraft quote and aborted.
[03:50:58] <Eridius> jld: yeah the runtime sometimes prints a cute quote when it has an error
[03:52:39] <strcat> the __morestack prelude really hurts minimax when the set of successors is small
[03:52:54] * strcat sighs
[03:55:04] <jld> It lacks the conciseness of http://www.multicians.org/hodie-natus-est.html I must say.
[03:58:00] <bjz> brson: whatever you do, don't let them remove the quotes from the rt!
[03:58:15] <bjz> brson: ^_^
[03:58:57] *** Quits: Axord (xord@moz-1B228827.lsanca.dsl-w.verizon.net) (Quit: I'm sure it's perfectly safe)
[03:59:17] * bjz fears potential party poopers
[03:59:46] <tikue> is there ever a reason to assign a closure to a variable?
[04:00:04] <tikue> (in lieue of declaring a function)
[04:00:06] <tikue> lieu*
[04:00:17] <Eridius> tikue: you need to capture the environment?
[04:00:32] <tikue> Eridius: thanks, forgot that functions don't capture lol
[04:00:55] <bjz> strcat: is there a way of doing this nicer by chaining iterators? https://gist.github.com/bjz/e15537500dc44fa04283
[04:01:43] <strcat>  for param in cmd.params.iter() {
[04:01:45] <strcat> tys.insert(&param.ty);
[04:01:47] <strcat> }
[04:01:49] <strcat> that one
[04:01:51] <strcat> could be
[04:01:53] <strcat> tys.extend(cmd.params.iter())
[04:01:55] <strcat> er
[04:01:59] <strcat> tys.extend(&mut cmd.params.iter())
[04:02:19] <Eridius> bjz: for cmd in reg.cmd_nss.iter().flat_map(|cmd_ns cmd_ns.cmds.iter()) {
[04:02:19] <strcat> but other than that not really
[04:02:21] <Eridius> that would remove one layer
[04:02:24] <tikue> can closures be generic?
[04:02:27] <Eridius> but I'm not sure that's actually any cleaner
[04:02:29] <acrichto> strcat: is extend like push_all_move?
[04:02:39] <strcat> acrichto: yes, but it takes an iterator
[04:02:42] <acrichto> cool
[04:02:53] <strcat> FromIterator/Extendable are the conversion traits basically
[04:02:59] <strcat> need to mention Extendable in the tutorial
[04:03:49] <tikue> rusti: let c: &fn<T>(t: T) -> T = |t| t;
[04:03:49] -rusti- <anon>:5:20: 5:21 error: expected `>`, found `T`
[04:03:49] -rusti- <anon>:5          let c: &fn<T>(t: T) -> T = |t| t;
[04:03:50] -rusti-                              ^
[04:03:50] -rusti- application terminated with error code 101
[04:04:27] <bjz> strcat: ahh, but I have to get the ty field off the param
[04:04:44] <bjz> strcat: would I need to map?
[04:04:55] <strcat> bjz: yeah, so not much better ;]
[04:05:11] <bjz> :(
[04:05:22] <strcat> although, extend will do a single allocation if it's a type like a vector
[04:05:33] <strcat> or a hash{map,set} (won't help for building a tree set)
[04:05:43] <tikue> can closures be lifetime parameterized?
[04:06:01] <acrichto> tikue: you can do &'a fn()
[04:07:07] <tikue> rusti: struct Foo<'self> { f: &'self fn(&'self int), }
[04:07:08] -rusti- ()
[04:07:31] <acrichto> tikue: &'self int wouldn't be necessary, the arguments could just be &T
[04:07:35] <bjz> strcat: is there a way of parallelising it?
[04:08:20] <bjz> strcat: just curious from a case study standpoint
[04:08:33] <bjz> and also to learn iterators better :P
[04:08:53] <strcat> bjz: not really
[04:09:03] <bjz> mmk
[04:09:28] <bjz> just seems very... imperative what I'm doing
[04:09:45] <tikue> rusti: struct Foo<'self> { f: &'self fn(), } let mut x = 1; let foo = Foo { f: || x += 1, };
[04:09:47] -rusti- <anon>:5:66: 5:69 warning: unused variable: `foo` [-W unused-variable (default)]
[04:09:47] -rusti- <anon>:5          struct Foo<'self> { f: &'self fn(), } let mut x = 1; let foo = Foo { f: || x += 1, };
[04:09:47] -rusti-                                                                            ^~~
[04:09:47] -rusti- ()
[04:09:48] <strcat> if you wanted to make it faster, you could probably build a vector and sort + dedup at the end
[04:09:54] <strcat> same time complexity
[04:10:05] <tikue> rusti: struct Foo<'self> { f: &'self fn(), } let mut x = 1; let foo = Foo { f: || x += 1, }; (foo.f)(); x
[04:10:05] -rusti- 2
[04:10:10] <tikue> wow
[04:10:17] <tikue> i thought you couldn't store stack closures in structs
[04:10:20] <strcat> but sets are only really worth it if you're inserts/searches are intertwined
[04:10:23] *** Quits: Cromulent (Cromulent@moz-983B638D.cable.virginmedia.com) (Quit: KVIrc 4.2.0 Equilibrium http://www.kvirc.net/)
[04:10:23] <strcat> your*
[04:10:31] <strcat> tikue: you're storing a reference to it
[04:10:52] <strcat> &fn isn't a stack closure, it's a borrowed ref to any closure
[04:11:01] <tikue> ah ok
[04:11:06] <tikue> of course
[04:11:14] <strcat> if you coerce a stack closure to &fn right away, the &fn can't outlive the stack frame
[04:11:31] <strcat> (there's not really anything else you can do with a stack closure atm - they become &fn immediately)
[04:11:39] <strcat> would need dynamically sized types to do anything else
[04:11:43] <bjz> strcat: not so much speed, more from a readability standpoint
[04:12:19] <strcat> bjz: the first two nested loops are just the cartesian product, and python has an adaptor for that
[04:12:30] <tikue> the tutorial has this to say about stack closures: "To ensure that stack closures never outlive the local variables to which they refer, stack closures are not first-class. That is, they can only be used in argument position; they cannot be stored in data structures or returned from functions."
[04:12:43] <tikue> that seems misleading
[04:12:48] <strcat> bjz: but you can't really make it look much better in rust (or really, python - itertools.product(a, b) doesn't look any better :P)
[04:13:02] <engla> I think it's actually something for flat_map
[04:13:16] <strcat> tikue: it's flat out wrong
[04:13:23] <strcat> stack closures do not exist in the type system at all
[04:13:28] <strcat> the docs suck ;p
[04:13:31] <tikue> lol :(
[04:13:33] <tikue> oh well
[04:13:48] <strcat> engla: well maybe flat_map is the cartesian product, I haven't really thought of it that way
[04:14:02] <bjz> will try that
[04:14:16] *** Quits: KindOne (KindOne@664CD005.E1AE408F.34F73994.IP) (Ping timeout)
[04:14:30] <engla> this is not a cartesian product
[04:14:54] <tikue> i don't think print_types.rs looks particularly bad though
[04:15:00] <strcat> that's why python calls it 'product'
[04:15:30] <strcat> except you'd have to coerce it to a set
[04:15:32] <tikue> rusti: fn -_-() { println("-_____-"); }
[04:15:34] -rusti- pastebinned 7 lines of output: http://ix.io/7ik
[04:16:17] <tikue> rusti: fn 6-_-() { println("-_____-"); }
[04:16:17] -rusti- <anon>:5:12: 5:13 error: expected ident, found `6`
[04:16:17] -rusti- <anon>:5          fn 6-_-() { println("-_____-"); }
[04:16:17] -rusti-                      ^
[04:16:17] -rusti- application terminated with error code 101
[04:16:31] <bjz> that's with flat_map: https://gist.github.com/bjz/e15537500dc44fa04283
[04:16:47] <bjz> not really an improvement
[04:16:49] <tikue> rusti: fn I-_-() { println("-_____-"); }
[04:16:49] -rusti- <anon>:5:13: 5:14 error: expected `(` but found `-`
[04:16:50] -rusti- <anon>:5          fn I-_-() { println("-_____-"); }
[04:16:50] -rusti-                       ^
[04:16:50] -rusti- application terminated with error code 101
[04:17:00] *** Quits: panzi (chatzilla@moz-94D85B10.adsl.highway.telekom.at) (Quit: ChatZilla 0.9.90.1 [Firefox 23.0/20130807192336])
[04:17:22] <bjz> hah
[04:17:32] <engla> right
[04:17:34] <tikue> bjz: what is the problem exactly? or rather, what do you wish it looked like?
[04:17:49] <engla> but you can write it with adaptors if you want
[04:18:35] <bjz> tikue: more chainy and functional than imperative. just trying to think more functionally
[04:18:55] *** Joins: KindOne (KindOne@moz-CE7A3C24.dynamic.ip.windstream.net)
[04:19:05] <bjz> tikue: it's not horrible, but yeah, just wondering if I could improve it
[04:19:22] <bjz> tikue: not the end of the world though, just thought I'd ask
[04:20:12] <tikue> maybe there's a way to use peak
[04:20:15] <tikue> before flattening one more time
[04:20:21] <tikue> s/peak/peek
[04:23:08] *** Joins: hjr3 (hradtke@moz-E87BDF1F.socal.res.rr.com)
[04:23:47] <tikue> oh i mean inspect
[04:23:54] *** Quits: mihneadb (Mihnea@moz-329F29A3.lightspeed.sntcca.sbcglobal.net) (Ping timeout)
[04:23:55] <engla> it was renamed :)
[04:24:02] <tikue> ah
[04:25:55] <sp3d> how would I dump a &[u8] to a file (or stdout)?
[04:27:03] <tikue> bjz: not sure if this actually does the same thing -- don't have code to test it with :) https://gist.github.com/tikue/6b8341aa00909221d00f
[04:28:06] <tikue> just updated it, now i have no idea if it does the same thing or not but might be worth trying
[04:28:39] <tikue> probably has some issues with mutably borrowing more than once *shrug*
[04:29:37] <tikue> probably can get rid of the inspect actually and put a side effect in the flat map
[04:31:19] <Eridius> tikue: I would expect capturing tys mutably in any of those closures to be an issue, although I can't be positive
[04:31:36] <tikue> Eridius: you can always extend afterward
[04:31:58] <tikue> is there a way to make an iterator from an element
[04:32:42] <engla> for one element, one time?
[04:32:51] <Eridius> wrap it in Option?
[04:32:52] <sp3d> you could [...].iter() or Some(...).iter() but I don't know of something that wouldn't allocate
[04:33:09] <engla> Some(1).iter() doesn't allocate more than creating the values
[04:33:28] <strcat> well neither does a fixed-size array
[04:33:28] <Eridius> wow llvm takes a while to compile. I'm too used to my parallelized fast computer
[04:33:29] <sp3d> a little on the stack is basically negligible I guess
[04:33:41] <strcat> sp3d: it won't actually put anything on the stack
[04:33:42] * Eridius is trying to build rust on a linode right now.. dreading the memory usage though
[04:33:46] <sp3d> strcat: oh?
[04:33:52] <strcat> LLVM optimizes
[04:33:58] <strcat> SROA will break up the struct
[04:34:05] <sp3d> cool
[04:34:07] <Eridius> SROA?
[04:34:13] <strcat> scalar replacement of aggregates
[04:34:16] <Eridius> ah
[04:34:17] <strcat> it's a pass
[04:34:26] <strcat> it breaks up iterators and things like that
[04:34:30] <strcat> and then later passes optimize it out
[04:34:50] <strcat> if you put a struct on the stack and don't return/pass it, SROA will split it up
[04:34:50] <engla> you want Some(x).move_iter() by the way
[04:35:12] <tikue> rusti: Some(1u).iter().chain([2u, 3, 4].iter())
[04:35:14] -rusti- pastebinned 28 lines of output: http://ix.io/7il
[04:35:29] <tikue> rusti: let it = Some(1u).iter().chain([2u, 3, 4].iter());
[04:35:31] -rusti- pastebinned 22 lines of output: http://ix.io/7im
[04:36:02] <Eridius> rvalue issue
[04:36:08] <tikue> rusti: let mut it1 = [2, 3, 4].iter(). let it = Some(1).iter().chain(it1);
[04:36:08] -rusti- <anon>:5:45: 5:47 error: expected `;` but found `it`
[04:36:08] -rusti- <anon>:5          let mut it1 = [2, 3, 4].iter(). let it = Some(1).iter().chain(it1);
[04:36:08] -rusti-                                                       ^~
[04:36:09] -rusti- application terminated with error code 101
[04:36:14] <tikue> rusti: let mut it1 = [2, 3, 4].iter(); let it = Some(1).iter().chain(it1);
[04:36:16] -rusti- pastebinned 22 lines of output: http://ix.io/7in
[04:36:33] <Eridius> rusti: let xs = [2u, 3, 4]; let it = Some(1u).iter().chain(xs.iter())
[04:36:33] -rusti- <anon>:6:4: 6:5 error: expected `;` but found `}`
[04:36:33] -rusti- <anon>:6     };
[04:36:33] -rusti-              ^
[04:36:33] -rusti- application terminated with error code 101
[04:36:37] <Eridius> rusti: let xs = [2u, 3, 4]; let it = Some(1u).iter().chain(xs.iter());
[04:36:39] -rusti- pastebinned 12 lines of output: http://ix.io/7io
[04:36:39] <tikue> rusti: let v = [2, 3, 4]; let it = Some(1).iter().chain(v.iter());
[04:36:41] -rusti- pastebinned 12 lines of output: http://ix.io/7ip
[04:36:53] <Eridius> ok yeah the Some has the rvalue issue too, unfortunately
[04:36:57] <tikue> rusti: let v = [2, 3, 4]; let it = Some(1); let it2 = it.iter().chain(v.iter());
[04:36:58] -rusti- <anon>:5:50: 5:53 warning: unused variable: `it2` [-W unused-variable (default)]
[04:36:58] -rusti- <anon>:5          let v = [2, 3, 4]; let it = Some(1); let it2 = it.iter().chain(v.iter());
[04:36:58] -rusti-                                                            ^~~
[04:36:58] -rusti- ()
[04:37:05] <tikue> ok
[04:37:06] <tikue> well there
[04:37:15] <Eridius> rusti: let xs = [2u, 3, 4]; let s = Some(1); let it = s.iter().chain(xs.iter()); it.to_owned_vec()
[04:37:17] -rusti- pastebinned 33 lines of output: http://ix.io/7iq
[04:37:37] <Eridius> forgot to make it mutable, but why is it complaining about xs?
[04:37:59] <Eridius> oooh, it's because I'm trying to return b orrowed values
[04:38:20] <Eridius> rusti: let xs = [2u, 3, 4]; let s = Some(1); let mut it = s.iter().chain(xs.iter()); printfln!(it.to_owned_vec())
[04:38:21] -rusti- ~[&1, &2, &3, &4]
[04:38:21] -rusti- ()
[04:38:43] <bjz> tikue: ahh the issue with .flat_map(|def| def.params.iter()) is that it needs to return def.ty
[04:38:46] <engla> after a long struggle :)
[04:38:59] <bjz> tikue: sorry, did some renaming
[04:39:48] <tikue> bjz: map would fix that
[04:40:11] <bjz> yeah
[04:40:26] <tikue> updated my gist
[04:40:30] <tikue> might be on the right track
[04:40:32] <tikue> lol
[04:41:32] <sp3d> rusti: std::rt::io::stdout()
[04:41:41] -rusti- task <unnamed> failed at 'explicit failure', /build/rust-git/src/rust/src/libstd/rt/io/stdio.rs:16
[04:41:41] -rusti- application terminated with error code 101
[04:41:50] <sp3d> oh, @ loop maybe
[04:42:13] <sp3d> hm, or maybe not, w/e
[04:42:33] <engla> that's just a stubbed out function sp3d 
[04:42:38] <tikue> bjz: any luck with that? not sure it's more readable, but it's certainly more functional...
[04:42:47] <engla> pub fn stdout() -> StdWriter { fail!() }
[04:42:52] <bjz> tikue: having a go
[04:43:02] <bjz> tikue: yeah, it's an interesting experiment
[04:43:33] <sp3d> ah... I was trying to figure out why stdout doesn't seem to implement Writer?
[04:43:56] <klutzy> acrichto: pong
[04:43:58] <sp3d> rusti: std::rt::io::stdout().write(&[30u8])
[04:44:09] <engla> it does implement it
[04:44:09] -rusti- <anon>:5:9: 6:5 error: type `std::rt::io::stdio::StdWriter` does not implement any method in scope named `write`
[04:44:09] -rusti- <anon>:5          std::rt::io::stdout().write(&[30u8])
[04:44:09] -rusti- <anon>:6     };
[04:44:09] -rusti- error: aborting due to previous error
[04:44:10] -rusti- application terminated with error code 101
[04:44:34] <bjz> tikue: might just stick with the iterative approach for now
[04:44:40] <bjz> tikue: again, thanks!
[04:44:42] <engla> std::rt::io is not ready yet, and its traits are not in the prelude
[04:44:49] <tikue> rusti: let it = Some(1u).move_iter().chain(~[2u, 3, 4].move_iter());
[04:44:56] <tikue> bjz: np :P 
[04:44:58] -rusti- pastebinned 7 lines of output: http://ix.io/7ir
[04:45:06] <sp3d> there's still a usable stdout in std::io?
[04:45:15] <engla> rusti: use std::rt::io::Writer; std::rt::io::stdout().write(&[30u8])
[04:45:15] <tikue> rusti: let it = Some(1u).move_iter().chain((~[2u, 3, 4]).move_iter());
[04:45:16] -rusti- task <unnamed> failed at 'explicit failure', /build/rust-git/src/rust/src/libstd/rt/io/stdio.rs:16
[04:45:16] -rusti- application terminated with error code 101
[04:45:16] -rusti- <anon>:5:13: 5:15 warning: unused variable: `it` [-W unused-variable (default)]
[04:45:16] -rusti- <anon>:5          let it = Some(1u).move_iter().chain((~[2u, 3, 4]).move_iter());
[04:45:17] -rusti-                       ^~
[04:45:18] -rusti- ()
[04:45:33] <engla> see, it does implement it, but it's not a useful implementation :)
[04:45:41] <sp3d> mm
[04:46:12] <aatch> most of the stuff in rt::io is just fail!()
[04:46:13] <tikue> rusti: let it = Some(1u).move_iter().chain((~[2u, 3, 4]).move_iter()); it.collect::<~[uint]>()
[04:46:18] -rusti- <anon>:5:73: 5:75 error: cannot borrow immutable local variable as mutable
[04:46:18] -rusti- <anon>:5          let it = Some(1u).move_iter().chain((~[2u, 3, 4]).move_iter()); it.collect::<~[uint]>()
[04:46:18] -rusti-                                                                                   ^~
[04:46:18] -rusti- error: aborting due to previous error
[04:46:20] -rusti- application terminated with error code 101
[04:46:31] <aatch> except the TCP stuff
[04:46:34] <engla> rusti: std::io::stdout().write_str("sp3d")
[04:46:35] -rusti- sp3d()
[04:46:43] <tikue> rusti: let mut it = Some(1u).move_iter().chain((~[2u, 3, 4]).move_iter()); it.collect::<~[uint]>()
[04:46:43] -rusti- ~[1, 2, 3, 4]
[04:46:49] <tikue> haha yay no temp vars
[04:47:10] *** Quits: brson (brson@moz-BBE3ABD.mv.mozilla.com) (Ping timeout)
[04:47:26] <Eridius> strcat: can llvm remove the allocation from (~[2u, 3, 4]).move_iter() ?
[04:47:37] * Eridius really should get around to adding .clone_iter()
[04:47:40] <strcat> it can in C++
[04:47:44] <strcat> it can't in rust
[04:47:49] <strcat> Eridius: I really don't want clone_iter :s
[04:47:57] <tikue> strcat: why
[04:48:07] <strcat> because rust puts opaque wrappers around FFI calls atm
[04:48:24] <Eridius> strcat: I keep places where .clone_iter() would be useful
[04:48:27] <aatch> because it's just `.transform(|x| x.clone())`
[04:48:36] <strcat> .map() now
[04:48:36] <engla> it's not possible to annotate malloc with some magic?
[04:48:39] <Eridius> aatch: a Map can't be cloned though
[04:48:44] <Eridius> because it has a closure
[04:48:46] <strcat> engla: with gcc, yes, not with LLVM
[04:48:48] <Eridius> CloneIter could be cloned
[04:49:15] <engla> Eridius: we could either make captureless closures clonable. or an iterator::Map variant that uses extern fn?
[04:49:31] *** Joins: brson (brson@moz-BBE3ABD.mv.mozilla.com)
[04:49:31] *** ChanServ sets mode: +o brson
[04:49:38] <tikue> Eridius: you want clone_iter() so you can do [1, 2, 3].clone_iter() and not have to malloc?
[04:49:53] <strcat> .iter().map(|&x| x)
[04:50:01] <tikue> word
[04:50:07] <Eridius> tikue: that's one use
[04:50:16] <strcat> clone_iter would still borrow
[04:50:30] <tikue> true
[04:50:36] <tikue> so it wouldn't work to get around lifetime issues in temp iterators
[04:50:37] <aatch> I can't really think of a case where you would need to be able to clone the iterator.
[04:50:46] <Eridius> yeah you'd still have the rvalue issue
[04:50:55] <engla> strcat: thanks for the info anyway (malloc)
[04:50:55] <tikue> aatch: for some kind of tee() maybe
[04:50:57] <strcat> there are cases when you want to clone iterators but `map` is not inherently non-clonable
[04:50:58] <Eridius> but I keep seeing .map(|&x| x) rop up
[04:51:01] <strcat> closures really suck in rust atm
[04:51:07] <Eridius> *crop up
[04:51:32] <strcat> Eridius: clone_iter would be an extra thing for *every* container to implement
[04:51:37] <tikue> yes I use map(|&x| x) a lot
[04:51:49] <strcat> the whole point of iterators is to avoid the combinatorial explosion of methods
[04:52:19] <tikue> well, one of the points :P
[04:52:22] <strcat> it could be a default method but I really don't want it
[04:52:25] <toddaaro> [Guardian, Medium guard]
[04:52:25] <toddaaro> 1600mm Reinforced Rolled Tungsten Plates I
[04:52:25] <toddaaro> Damage Control II
[04:52:25] <toddaaro> Armor Kinetic Hardener II
[04:52:28] <toddaaro> True Sansha Armor EM Hardener
[04:52:30] *** Quits: erickt1 (Adium@49C4075F.3AC15C18.2321E71E.IP) (Quit: Leaving.)
[04:52:30] <toddaaro> Armor Thermic Hardener II
[04:52:33] <toddaaro> 10MN Afterburner II
[04:52:35] <toddaaro> Conjunctive Radar ECCM Scanning Array I
[04:52:38] <toddaaro> Large 'Solace' Remote Bulwark Reconstruction
[04:52:39] *** Quits: snadon (chatzilla@moz-3BC727E8.mc.videotron.ca) (Ping timeout)
[04:52:40] <toddaaro> Large 'Solace' Remote Bulwark Reconstruction
[04:52:43] <tikue> what is happening
[04:52:43] <toddaaro> Large 'Solace' Remote Bulwark Reconstruction
[04:52:45] <toddaaro> Large 'Solace' Remote Bulwark Reconstruction
[04:52:48] <aatch> toddaaro, why are you pasting your ship fit into #rust?
[04:52:48] <toddaaro> Large 'Regard' Power Projector
[04:52:50] <toddaaro> Medium 'Regard' Power Projector
[04:52:53] <toddaaro> Medium Ancillary Current Router I
[04:52:55] <toddaaro> wow oops, my bad
[04:52:58] <toddaaro> putty combined with a right click on the bottom of my laptop
[04:53:08] <toddaaro> it is ... not safe
[04:53:19] <strcat> use a better irc client ;p
[04:53:20] <tikue> lol
[04:53:21] <toddaaro> whatever putty does evades irssi+screen overflow check
[04:53:34] <Eridius> irssi+screen overflow check? Not familiar with that
[04:53:45] <strcat> toddaaro: oh I guess that makes sense
[04:53:48] <tikue> personally i don't mind map(|&x| x) too much
[04:53:58] <strcat> Eridius: weechat/irssi check for you accidentally pasting a pile of lines
[04:53:59] <Eridius> tikue: well it's not so bad now, it was worse when it was .transform(|&x| x)
[04:54:00] <strcat> and yell at you
[04:54:01] <toddaaro> using a normal terminal it goes "you pasted X lines, are you sure, blah blah blah"
[04:54:11] <strcat>  [Paste 15 lines ? [ctrl-Y] Yes [ctrl-N] No]
[04:54:14] <toddaaro> but not putty, putty just goes BLAM BLAM BLAM and then you end up here
[04:54:19] <Eridius> strcat: how do they do that? Unless they try to aggressively read ahead
[04:54:40] <strcat> Eridius: I think the terminal tells them when you paste
[04:54:45] <strcat> might be part of xterm mouse support
[04:54:55] <Eridius> hmm, not familiar with that. Terminal.app doesn't have mouse support though
[04:55:01] <strcat> it has all the things you could ever want like selection extending now
[04:55:05] <Eridius> strcat: I could see them handling mouse middle-click or something
[04:55:23] <Eridius> but straight-up paste should behave the same as just typing all that instantaneously
[04:55:39] <strcat> Eridius: it doesn't though, the application decides
[04:55:54] <strcat> and terminals treat secondary screen apps as "the application" now
[04:56:04] <strcat> they can play around with scroll wheel stuff, etc.
[04:56:11] <toddaaro> so the "this is a paste" gets passed all the way to irssi?
[04:56:13] <strcat> you can skip terminfo and use raw input
[04:56:19] <strcat> and get all the events as you would in gtk basically
[04:56:22] <strcat> toddaaro: yeah, I think so
[04:56:35] <strcat> terminals are weird
[04:56:37] <toddaaro> interesting, that would explain how it works
[04:56:45] <strcat> there's also the xterm clipboard extension
[04:56:49] <strcat> for copy/paste
[04:56:54] <strcat> it uses the xterm's clipboard
[04:56:55] <Eridius> strcat: maybe xterm has this crap. Not so sure about other terminals ;)
[04:57:00] <strcat> Eridius: well, vte does
[04:57:04] <strcat> so most terminals do
[04:57:06] <strcat> and urxvt does
[04:57:18] <toddaaro> I usually use urxvt
[04:57:26] <Eridius> I don't think Terminal.app does anything special with paste
[04:57:31] <Eridius> certainly doesn't have mouse support
[04:57:33] <strcat> although, urxvt fell behind in mouse support recently
[04:57:37] *** Joins: snadon (chatzilla@moz-3BC727E8.mc.videotron.ca)
[04:57:45] <strcat> not that I use mouse support ;p
[04:57:45] *** Quits: bjz (brendanzab@B398BE78.F804C29E.D35A31DF.IP) (Connection reset by peer)
[04:57:52] * strcat has probably never extended a selection, ever
[04:57:56] <tikue> rusti: let ten = 10u; do ten.times { print('.'); }
[04:57:57] -rusti- <anon>:5:45: 5:48 error: mismatched types: expected `&str` but found `char` (expected &str but found char)
[04:57:57] -rusti- <anon>:5          let ten = 10u; do ten.times { print('.'); }
[04:57:57] -rusti-                                                       ^~~
[04:57:57] -rusti- error: aborting due to previous error
[04:57:57] -rusti- application terminated with error code 101
[04:58:00] <mcpherrin> Eridius: If you hold alt, terminal.app has mouse support
[04:58:05] <tikue> rusti: let ten = 10u; do ten.times { print("."); }
[04:58:06] -rusti- ..........()
[04:58:07] <aatch> strcat, I'm not even sure I have mouse support turned on
[04:58:25] <strcat> aatch: in weechat you mean?
[04:58:25] <mcpherrin> Eridius: of some sort at least.
[04:58:27] <Eridius> mcpherrin: that just does rectangular selection. But the program running in your terminal doesn't know
[04:58:35] <Eridius> mcpherrin: trust me, Terminal.app does not implement xterm mouse events
[04:58:41] <aatch> strcat, in anything (I don't use weechat, XChat for me)
[04:58:44] * Eridius has an open radar on this subject
[04:58:45] <mcpherrin> Eridius: No, it's not xterm mouse events
[04:58:45] <toddaaro> I wonder if I do, if it weren't for web browsing I'd unplug my mouse
[04:58:56] <strcat> aatch: well it's on by default in vte/xterm/urxvt
[04:58:57] <Eridius> mcpherrin: well it's not any events that the CLI program can see
[04:59:03] <strcat> aatch: open vim and :set mouse=a
[04:59:07] <mcpherrin> Eridius: You can get it to send cursor key events that "move" the cursor to where you click
[04:59:15] <mcpherrin> Eridius: With some clever code, you can make that work.  I've done it :P
[04:59:16] <Eridius> mcpherrin: ooh that's what you're referring to. I forgot about that weirdness
[04:59:18] <aatch> strcat, I think I _might_ have mouse support compiled in.
[04:59:20] <Eridius> yeah that just sends cursor events
[04:59:23] <strcat> aatch: the only thing vim in a terminal is missing atm is sloppy focus
[04:59:25] <strcat> gvim has it
[04:59:33] <strcat> but I think if you use raw input, you can follow hover
[04:59:38] <strcat> if you try hard enough
[05:01:27] <sp3d> rusti: std::os::args[0]
[05:01:27] -rusti- <anon>:5:9: 5:24 error: cannot index a value of type `extern "Rust" fn() -> ~[~str]`
[05:01:28] -rusti- <anon>:5          std::os::args[0]
[05:01:28] -rusti-                   ^~~~~~~~~~~~~~~
[05:01:28] -rusti- error: aborting due to previous error
[05:01:28] -rusti- application terminated with error code 101
[05:02:49] *** Quits: tikue (tkuehn@moz-F4812C6E.hsd1.fl.comcast.net) (Quit: tikue)
[05:02:57] *** Joins: tikue (tkuehn@moz-F4812C6E.hsd1.fl.comcast.net)
[05:04:48] *** Quits: enix (enix@moz-A50569DD.c3-0.slvr-ubr1.lnh-slvr.md.cable.rcn.com) (Quit: Konversation terminated!)
[05:05:21] <Eridius> huh, libstd's tests depend on extra?
[05:06:18] *** Quits: carllerche (carllerche@6B070D22.7E6A0813.1428D117.IP) (Quit: carllerche)
[05:06:23] <engla> yes for bench
[05:06:36] <strcat> the test harness is in extra afaik
[05:06:51] <engla> it's only the bench harness
[05:07:46] <Eridius> how do I request make build stage2 libextra?
[05:07:50] * Eridius doesn't want to do a full build
[05:07:58] <brson> the bench harness is part of the test harness
[05:08:19] <Eridius> actually I bet `make check-stage2-std` will do it for me
[05:08:37] <engla> ok but it didn't require libextra until we wanted bench to run in stdtests
[05:09:17] <brson> there weren't any explicit uses of extra, but stdtest has always linked to libextra. it's done implicitly when building with --test
[05:10:19] <strcat> should probably move it to libstd since it's a language feature
[05:11:09] <brson> maybe. it's certainly awkward where it is, but it has a number of dependencies
[05:11:48] <strcat> heh it does have a lot of deps
[05:11:51] <strcat> from extra
[05:12:15] <strcat> treemap, time, term, stats, sort, json, serialize, getops
[05:15:43] *** Joins: carllerche (carllerche@6B070D22.7E6A0813.1428D117.IP)
[05:15:48] *** Quits: carllerche (carllerche@6B070D22.7E6A0813.1428D117.IP) (Quit: carllerche)
[05:15:59] <acrichto> klutzy: oh dear you still there?
[05:16:18] <klutzy> yes :)
[05:16:23] *** Quits: cubic (cubic@moz-FE5AD6C7.mc.videotron.ca) (Connection reset by peer)
[05:16:53] <acrichto> you had some llvm patches for your w64 pull request
[05:17:04] <acrichto> I'm about ready to land the llvm-head one, so I should probably lump those in
[05:17:15] *** Quits: lmandel (lmandel@moz-57D3C086.dsl.bell.ca) (Quit: lmandel)
[05:17:28] <acrichto> I don't think anyone has had a chance to look at them though
[05:18:16] *** Joins: mihneadb (Mihnea@moz-329F29A3.lightspeed.sntcca.sbcglobal.net)
[05:18:35] <acrichto> klutzy: also I hear that windows stack unwinding is a can of worms right now that doesn't work for a number of reasons, but does that llvm commit really enable stack unwinding for everything?
[05:19:22] *** Quits: wting (wting@moz-250C027.csres.utexas.edu) (Ping timeout)
[05:19:41] *** Joins: wting (wting@moz-250C027.csres.utexas.edu)
[05:20:19] <klutzy> acrichto: not everything. the patch just makes llvm to recognize the register in use for unwinding
[05:20:24] *** Quits: boredomist (user@moz-63CF9F31.res-cmts.sesp.ptd.net) (Ping timeout)
[05:20:27] <bbouvier> hi! I am trying to compile pcwalton's sprocketnes with rustc-0.8-pre, but it fails with "util.rs:40:12: 44:13 error: type `&str` does not implement any method in scope named `as_c_str`". Any idea?
[05:20:36] <brson> klutzy: you have a win64 patch that *does unwinding*?
[05:20:46] <klutzy> acrichto: without the patch, cross-build fails with "unwinding is not supported"
[05:20:59] <Eridius> bbouvier: .to_c_str().with_ref
[05:21:09] <acrichto> brson: https://github.com/mozilla/rust/pull/8488
[05:21:12] <aatch> bbouvier, it's likely that pcwalton hasn't updated sprocketnes to latest version of the compiler.
[05:21:23] <aatch> And he's currently on a plane
[05:21:23] <klutzy> brson: I don't think so :p
[05:21:25] <acrichto> klutzy: oh so it's more of a "we don't really support unwinding, but this doesn't fail compiling instantly"
[05:22:29] <klutzy> acrichto: yes, it just pulls up win64 as win32 situation
[05:22:57] <bbouvier> Eridius: thanks, it solves it :)
[05:23:02] <Eridius> does ::rt::backtrace work on any platform? I just tried it on linux and I don't get a backtrace
[05:23:08] <bbouvier> aatch: seems you're right :)
[05:23:13] <klutzy> acrichto: my second patch disables dwarf2 use if we use SEH. I think it's trivial https://github.com/klutzy/llvm/commit/4455390413c412c5a37ac69392730a224cd3f658
[05:23:21] <Eridius> I only get the point of failure, which isn't very useful
[05:23:30] <acrichto> klutzy: does that patch actually enable behavior or prevent crashes?
[05:23:38] *** Quits: wting (wting@moz-250C027.csres.utexas.edu) (Ping timeout)
[05:23:54] <brson> Eridius: none of the ::rt logging directives do anything in the new scheduler. rustc is lying
[05:23:59] <Eridius> damn
[05:24:01] <sp3d> rusti: let s=~[~"ok"]; s.iter().map(|x:&~str|{println("hm")})
[05:24:04] -rusti- pastebinned 16 lines of output: http://ix.io/7iu
[05:24:15] <Luqman> Eridius: you'll probably have better luck with gdb
[05:24:17] <brson> adding back a way to get a backtrace would be nice
[05:24:22] <klutzy> acrichto: first or second one?
[05:24:27] <brson> yeah, that's true. gdb is just as good
[05:24:29] <brson> better
[05:24:35] <Eridius> Luqman: oh right, that's what I was going to do. use gdb on linux
[05:24:37] <acrichto> klutzy: the second, I presume the first allows compiling at all on win64 with split stacks
[05:24:47] *** Joins: wting (wting@moz-250C027.csres.utexas.edu)
[05:24:49] <Eridius> GDB 7.6 on OS X is throwing internal errors trying to read the dwarf debug info :(
[05:25:01] *** Joins: int3_ (int3_@moz-ABE52D50.hsd1.ca.comcast.net)
[05:25:21] *** Joins: bjz (brendanzab@B398BE78.F804C29E.D35A31DF.IP)
[05:25:44] <klutzy> acrichto: second one is needed to build llvm on win64. Some llvm stuff uses dwarf2 if available, but the "if" switch was slightly wrong so I fixed it
[05:25:59] <klutzy> build llvm on mingw-w64*
[05:26:08] *** Joins: ghrust (ghrust@C8693FCB.6A2AE50.F3114085.IP)
[05:26:08] <ghrust> 01[13rust01] 15bors merged 06auto into 06master: 02http://git.io/NjBHnA
[05:26:08] *** Parts: ghrust (ghrust@C8693FCB.6A2AE50.F3114085.IP) ()
[05:26:19] <acrichto> klutzy: so llvm itself just doesn't compile without the second patch?
[05:26:29] <klutzy> acrichto: yes
[05:26:30] <Eridius> oww this backtrace is hard to read
[05:26:49] *** Quits: int3_ (int3_@moz-ABE52D50.hsd1.ca.comcast.net) (Ping timeout)
[05:26:56] <acrichto> klutzy: wait, so llvm mainstream just doesn't compile *at all* on win64?
[05:27:00] <Eridius> any way to get line numbers in gdb's backtrace?
[05:27:16] <bjz> cmr: beep
[05:27:24] <sp3d> can anyone help me with this code? get_metadata only ever runs if I remove ".iter()": http://pastebin.com/xTsu0mjk
[05:28:00] <klutzy> acrichto: maybe I use unusual toolchain.. mingw-w64 and SEH-exceptions :)
[05:28:24] <acrichto> I'm not very familiar with windows, but is SEH-exceptions like a configurable thing?
[05:28:32] <Eridius> sp3d: you're not consuming the iterator, so it's never actually run, so your map is never handled
[05:28:41] <Eridius> sp3d: you should just turn that into a for loop, since that's what you really want
[05:28:56] <Eridius> for f in files.iter() { stdout().write(get_metadata(&Path(f.as_slice()))) }
[05:29:07] <klutzy> acrichto: VC toolchain will have no problem since #if defined(__GCC__) will filter them
[05:29:08] *** Joins: ghrust (ghrust@F6EE6DE3.6A2AE50.F3114085.IP)
[05:29:08] <ghrust> 01[13rust01] 15bors pushed 0 new commits to 06auto: 02http://git.io/V3SS2w
[05:29:08] *** Parts: ghrust (ghrust@F6EE6DE3.6A2AE50.F3114085.IP) ()
[05:29:09] *** Joins: ghrust (ghrust@1E8607E8.6A2AE50.F3114085.IP)
[05:29:09] <ghrust> 01[13rust01] 15bors pushed 2 new commits to 06auto: 02http://git.io/PNWgqw
[05:29:09] <ghrust> 13rust/06auto 145b28088 15Corey Richardson: std::at_vec: add benchmarks
[05:29:09] <ghrust> 13rust/06auto 147cda0d4 15bors: auto merge of #8481 : cmr/rust/bench/std/at_vec, r=graydon
[05:29:10] *** Parts: ghrust (ghrust@1E8607E8.6A2AE50.F3114085.IP) ()
[05:29:17] <Luqman> acrichto: you can go with either seh or sjlj exceptions
[05:29:23] <sp3d> so map on a vec is eager, but map on an iter is lazy?
[05:29:49] <sp3d> I guess that makes sense...
[05:29:53] <Eridius> map on a vec returns a new ~[T]. Map on an iter just wraps it in an adaptor that maps the value when you call .next()
[05:30:06] <sp3d> ah
[05:30:11] <sp3d> does make sense :)
[05:30:15] <Eridius> you're abusing map though. you don't care about the return value at all
[05:30:19] <sp3d> right
[05:30:39] <sp3d> I just wanted to understand the behavior before moving on
[05:30:42] <strcat> sp3d: map on vec is marked as deprecated
[05:30:55] <klutzy> acrichto: llvm's jit uses __register_frame(void*), which libgcc has. but actually libgcc has it only if drawf2 exception is supported
[05:30:56] <strcat> just hasn't been removed yet
[05:31:00] <sp3d> ok
[05:31:03] <strcat> needs to go away for Iterable to replace it
[05:31:20] *** Quits: wting (wting@moz-250C027.csres.utexas.edu) (Ping timeout)
[05:31:29] <acrichto> klutzy: makes sense, so can the pull request as is run a bootstrap up to stage2?
[05:32:20] <klutzy> acrichto: I think so. It must be harmless for other platforms
[05:32:44] <acrichto> does 'make check' finish?
[05:32:49] <sp3d> btw, thanks! now maybe I can figure out this metadata bug
[05:33:22] *** Joins: wting (wting@moz-250C027.csres.utexas.edu)
[05:33:28] <Luqman> acrichto: i see no reason why those two patches should affect any other platform
[05:33:45] <acrichto> Luqman: oh yeah, I'm just curious how far w64 gets
[05:35:08] <klutzy> acrichto: did 'make check-fast' on mingw. (ran make check now) I didn't ran tests win64 since it is not perfectly working for now
[05:35:47] <acrichto> also is it commont to refer to windows as 'win32' regardless of whether it's x86 or x86_64 architectures?
[05:36:52] <mcpherrin> acrichto: I don't do a lot of windows development, but I'll go with "No"
[05:36:59] <klutzy> acrichto: yes in C macros. win64 has both #define _WIN32 and #define _WIN64
[05:37:35] <acrichto> klutzy: weird
[05:37:55] <acrichto> PLAT_amd64_win32 seems like a weird #define
[05:38:01] <acrichto> or rather counter-intuitive
[05:39:08] <acrichto> klutzy: I think that if we want to merge this, a builder will probably be needed to start building win64 tests
[05:39:22] <acrichto> although that may require a win64 snapshot to happen first so it may not happen right off the bat
[05:39:25] <olsonjeffery> i need more screen real estate to keep track of all of my emacs buffers
[05:39:45] <Luqman> acrichto: at this point though it's not the tests would pass anyways
[05:40:02] <acrichto> Luqman: how come? what's blocking them?
[05:40:29] <Luqman> on win64? i'm pretty sure even with klutzy's patchs it's hitting a bit of trouble
[05:41:04] *** Quits: hjr3 (hradtke@moz-E87BDF1F.socal.res.rr.com) (Quit: My MacBook has gone to sleep. ZZZzzzâ€¦)
[05:41:13] <acrichto> oh that's not good, is it known trouble or unknown trouble?
[05:42:48] <klutzy> I think I have to rename pr title to "Partial support" :P it does not perfectly well as I expected
[05:42:56] <brson> toddaaro: i do believe that the lack of parallelism in the test suite is because of some interaction between waitpid blocking the scheduler and friend messages. i'm going to run one more test of moving the waitpid calls into their own thread and if it works make a pr
[05:43:23] <klutzy> acrichto: It does not work with std::rt::start(), but works with std::rt::start_on_main_thread(). I'm investigating it but no outcome so far
[05:43:53] <acrichto> klutzy: cool, I'm mostly just curious :)
[05:47:41] *** Joins: mib_6j5r3y (Mibbit@moz-C0D1CE56.nrflva.east.verizon.net)
[05:48:32] *** Quits: mib_6j5r3y (Mibbit@moz-C0D1CE56.nrflva.east.verizon.net) (Quit: http://www.mibbit.com ajax IRC Client)
[05:48:33] <klutzy> it's fantastic that I just wanted to write some small utility because I hate windows.. so I started to create win32 wrapper for rust
[05:48:48] <klutzy> then I started to work win64 stuff.. real yak shaving :p
[05:52:08] *** Joins: fabiand (fabiand@moz-E71B3C66.adsl.alicedsl.de)
[05:56:51] <brson> yak shaving is how everybody gets sucked into rust
[05:56:59] <sp3d> aha! rustc built a crate with invalid metadata entries for a couple symbols: "Fu[Rust,][*p0:641|0#26b1:e#]a[0:408|nn[p0:641|0]]" (n should have some valid region after it, rather than another n)
[05:58:27] <Eridius> brson: before one can use rust, one must first make rust work
[06:00:52] *** Quits: snadon (chatzilla@moz-3BC727E8.mc.videotron.ca) (Ping timeout)
[06:01:43] *** Joins: brendan (brendaneic@moz-9A8C9FB8.airnz.co.nz)
[06:01:50] *** Quits: brson (brson@moz-BBE3ABD.mv.mozilla.com) (Quit: leaving)
[06:06:30] *** Quits: richard|s (mindginati@moz-9C555AF3.spmconsultants.co.nz) (Quit: zzZZZ)
[06:15:16] *** Joins: sebcrozet (sebcrozet@moz-6DA639AF.w80-13.abo.wanadoo.fr)
[06:17:26] <sp3d> oh, always very nice when you get to the line of code that's killing things and it has a "FIXME" and a bug number :D
[06:20:03] <jld> ...and the rt tests are still busted on master, apparently?
[06:21:40] <bbouvier> Is there a way to compile rustc for an triple different of the host triple?
[06:22:18] *** Quits: brendan (brendaneic@moz-9A8C9FB8.airnz.co.nz) (Quit: brendan)
[06:22:56] <jld> Configure with --target-triples set to something appropriate?
[06:23:49] <jld> I think the target triples have to be a superset of the host triples which has to include the build triple, or something like that, but it should be possible to build, e.g., an x86-to-{x86,arm} compiler.
[06:23:52] <bbouvier> jld: configure returns "error: unsupported target triples "i386-pc-linux-gnu" found" :(
[06:24:22] <jld> i686-unknown-linux-gnu is how 32-bit x86 Linux is spelled.
[06:24:53] <klutzy> i386 :o
[06:25:06] <jld> (It's a bit picky.)
[06:25:08] <klutzy> bblum: what distribution do you use?
[06:25:10] <bbouvier> jld: indeed, it works :) I will try that. Thanks!
[06:25:12] <klutzy> oops. sorry
[06:25:12] <strcat> at least a certain blend of it
[06:25:30] <bblum> klutzy: i use gentoo but i suspect you did not actually want to know that
[06:27:02] *** Quits: m_kato (m_kato@moz-C286AD9A.bitcat.net) (Ping timeout)
[06:28:09] *** Joins: m_kato (m_kato@moz-C286AD9A.bitcat.net)
[06:29:49] <Eridius> well I've figured out what's going on with my c_str ICE
[06:30:09] <Eridius> apparently "foo" literals get encoded as CStrings internally. And libstd tests has a literal "\x00..."
[06:31:10] <strcat> "foo\x00bar"
[06:31:12] <strcat> hm?
[06:31:15] <strcat> rusti: "foo\x00bar"
[06:31:16] -rusti- "foo\x00bar"
[06:31:23] <strcat> what do you mean ideally though
[06:31:26] <strcat> internally*
[06:34:44] <Eridius> strcat: middle/trans/tvec.rs trans_lit_str
[06:35:11] <Eridius> not quite sure what's going on yet, since I'm looking at this in the middle of raiding (in WoW)
[06:35:26] <Eridius> but it takes the string literal and calls .to_c_str() on it (as part of the C_cstr() func)
[06:35:31] <strcat> Eridius: a cstr there means a constant string
[06:36:14] <Eridius> yeah, but it calls .to_c_str().with_ref and uses that to call llvm::LLVMConstStringInContext()
[06:36:23] <strcat> ah
[06:36:30] <strcat> probably incorrect
[06:36:34] <Eridius> I don't know enough about this stuff. Does it need a null terminator on this string?
[06:36:39] <Eridius> if not, this should use .as_imm_buf
[06:37:13] <strcat> Eridius: no, it doesn't need a \0
[06:37:15] <strcat> LLVMValueRef LLVMConstStringInContext  (  LLVMContextRef   C,
[06:37:17] <strcat>   const char *   Str,
[06:37:19] <strcat>   unsigned   Length,
[06:37:21] <strcat>   LLVMBool   DontNullTerminate 
[06:37:27] <strcat> it's likely wrong
[06:37:29] <Eridius> ok, I'm going to convert this to .as_imm_buf and see what happens
[06:37:41] <Eridius> what is DontNullTerminate?
[06:37:52] *** Quits: geomyidae (geomyidae@DD6F7E3A.21468E9A.30200F38.IP) (Quit: Konversation terminated!)
[06:38:19] <Eridius> I assume that if that's false, then it null-terminates. But I also assume it doesn't need the null terminator in the input
[06:38:59] *** Joins: azita (Azita@moz-C1FB2A8.hsd1.ca.comcast.net)
[06:39:20] <strcat> Eridius: yeah that's why it takes a length
[06:46:13] *** Joins: dim-an (ermolovd@moz-FE167E47.nationalcablenetworks.ru)
[06:46:56] *** Quits: tiffany (kawaii@moz-EB8B0C08.dhcp.embarqhsd.net) (Ping timeout)
[06:47:16] *** Quits: wilmoore (wilmoore@moz-71431C3A.hsd1.co.comcast.net) (Client exited)
[06:47:47] *** Joins: wilmoore (wilmoore@moz-71431C3A.hsd1.co.comcast.net)
[06:49:14] *** Quits: wilmoore (wilmoore@moz-71431C3A.hsd1.co.comcast.net) (Client exited)
[06:49:57] *** Joins: FDS (arnaud@moz-CE4D5907.bdx.modulonet.fr)
[06:53:04] *** Joins: maik__ (maik___@moz-E9AE01F.dip0.t-ipconnect.de)
[07:00:50] <Eridius> woohoo, no more ICE!
[07:01:39] *** Quits: tautologico (lymph@8ABDEDA.34CAB63A.7B974E06.IP) (Quit: tautologico)
[07:03:17] <Eridius> well, libstd tests pass. That's pretty good
[07:03:19] <Eridius> time for a full make check
[07:06:23] *** Joins: Ms2ger (Ms2ger@moz-3E74B52D.adsl-dyn.isp.belgacom.be)
[07:07:38] *** Joins: Sergio965 (sergiobz@moz-A8B88DF9.c3-0.sbo-ubr1.sbo.ma.cable.rcn.com)
[07:07:51] <Eridius> c_str PR submitted as https://github.com/mozilla/rust/pull/8532. Still running `make check` locally
[07:08:31] *** Joins: Houm (Houm@moz-25669AA8.fbx.proxad.net)
[07:09:03] <bbouvier> another newbie question: is it possible to compile libraries as static instead of dynamic libraries?
[07:09:57] <acrichto> bbouvier: not yet, although it is planned: https://github.com/mozilla/rust/issues/552
[07:14:59] *** Quits: Jesin (Jessin_@moz-48B48C95.eecs.lehigh.edu) (Quit: Leaving)
[07:15:26] *** Quits: tedh (tedh@moz-F0B37C08.hsd1.il.comcast.net) (Ping timeout)
[07:15:52] <bbouvier> acrichto: cool, thanks!
[07:16:29] *** Joins: tedh (tedh@moz-F0B37C08.hsd1.il.comcast.net)
[07:18:15] <Seldaek> acrichto: pong?
[07:19:20] *** Quits: dim-an (ermolovd@moz-FE167E47.nationalcablenetworks.ru) (Quit: dim-an)
[07:19:42] <acrichto> Seldaek: is rustdoc_ng running continuously somewhere or is it just at your discretion?
[07:20:19] *** Quits: tikue (tkuehn@moz-F4812C6E.hsd1.fl.comcast.net) (Quit: tikue)
[07:20:40] *** Joins: nano (nano@moz-74CAD1CA.superkabel.de)
[07:21:13] <Seldaek> acrichto: it's not yet running regularly no, and since the json of rustdoc_ng has stabilized cmr stopped sending me updates
[07:21:56] <Seldaek> acrichto: but I'll try to make some progress on the frontend this weekend and then hopefully critical issues are fixed and we can try to make it an official thing soon, with nightly builds or whatever
[07:22:19] <acrichto> Seldaek: oh no rush, I just wanted to see if my large doc-block on ifmt looks any good
[07:22:36] <Seldaek> paste it in a GH gist ;)
[07:23:03] <Seldaek> I mean GH's markdown should be compatible with most things, if you want to preview
[07:23:15] <acrichto> it's all in src/libstd/fmt/mod.rs right now
[07:23:18] <acrichto> oh
[07:23:25] <acrichto> I guess it's not too bad though
[07:23:27] <acrichto> then*
[07:25:16] <Seldaek> acrichto: I meant preview like this :) https://gist.github.com/Seldaek/3652f371e3737bc4a974
[07:25:49] <acrichto> Seldaek: yeah makes sense, thankfully it's not godawful :P
[07:26:20] *** Joins: ghrust (ghrust@DE823A67.6A2AE50.F3114085.IP)
[07:26:20] <ghrust> 01[13rust01] 15bors merged 06auto into 06master: 02http://git.io/PNWgqw
[07:26:20] *** Parts: ghrust (ghrust@DE823A67.6A2AE50.F3114085.IP) ()
[07:26:31] <Seldaek> acrichto: looks good. What's the plan for ifmt btw, to become the new fmt? I didn't follow the whole story
[07:26:51] <dbaupp> rusti: ifmt!("{0, select, foo{foo} other{bar} other{baz}}", "other")
[07:26:51] -rusti- <anon>:5:15: 5:60 error: multiple `other` statements in `select
[07:26:52] -rusti- <anon>:5          ifmt!("{0, select, foo{foo} other{bar} other{baz}}", "other")
[07:26:52] -rusti-                         ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
[07:26:52] -rusti- error: aborting due to previous error
[07:26:52] -rusti- application terminated with error code 101
[07:27:00] <acrichto> Seldaek: it's almost done, I want to flesh out what {} means entirely, and once that's done I'm going to start rampaging through destroying everything which currently exists
[07:27:20] <dbaupp> acrichto: there's no chance of that^ working right now?
[07:27:30] <acrichto> dbaupp: that's a good question...
[07:28:14] <dbaupp> (not that it matters that much right now, but probably something to resolve at some point.)
[07:28:16] <klutzy> acrichto: I have a bad news and a worse news
[07:28:28] <acrichto> klutzy: that doesn't sound good
[07:28:52] <klutzy> acrichto: I ran 'make check' on mingw (win32) to check safety of pr, then compiletest.exe died
[07:29:12] <klutzy> acrichto: worse news is it died on master too :(
[07:29:13] *** Joins: ghrust (ghrust@C8693FCB.6A2AE50.F3114085.IP)
[07:29:13] <ghrust> 01[13rust01] 15bors pushed 0 new commits to 06auto: 02http://git.io/aFPF6A
[07:29:13] *** Parts: ghrust (ghrust@C8693FCB.6A2AE50.F3114085.IP) ()
[07:29:13] *** Joins: ghrust (ghrust@2EE61FCC.6A2AE50.F3114085.IP)
[07:29:13] <ghrust> 01[13rust01] 15bors pushed 3 new commits to 06auto: 02http://git.io/97HZlQ
[07:29:13] <ghrust> 13rust/06auto 14ccc85b1 15Luqman Aden: librustc: Allow vector repeat exprs in statics.
[07:29:13] <ghrust> 13rust/06auto 14a2ed09a 15Luqman Aden: Add test for repeat expr in statics.
[07:29:14] <ghrust> 13rust/06auto 147f58552 15bors: auto merge of #8483 : luqmana/rust/rexprs, r=catamorphism...
[07:29:16] *** Parts: ghrust (ghrust@2EE61FCC.6A2AE50.F3114085.IP) ()
[07:29:42] *** Quits: gavinb (gavinb@moz-CA19A0CF.vic.adsl.internode.on.net) (Quit: gavinb)
[07:29:50] <acrichto> klutzy: oh the entire 'make check' suite is known to die
[07:29:57] <acrichto> b/c win32 doesn't have unwinding
[07:30:18] <acrichto> klutzy: the bots just run 'make check-fast'
[07:30:21] <dbaupp> klutzy: try `make check-fast`
[07:31:00] <Seldaek> acrichto: regarding dbaupp's edge case, maybe making 'other' '_' instead or something would be better
[07:31:27] <dbaupp> Seldaek: what if I wanna match on `_`! ;P
[07:31:29] <Seldaek> kinda goes well with the usual match syntax
[07:31:40] <klutzy> dbaupp: yep, I passed check-fast but I thought I have to run make check too
[07:31:40] <Seldaek> dbaupp: then use an if/else :p
[07:31:49] <acrichto> Seldaek: if I were making this from scratch I'd advocate for that, but I think that we're trying hard to make this system not introduce anything new and fancy
[07:32:07] <dbaupp> klutzy: nope, make check doesnt work on windows
[07:32:14] <acrichto> Seldaek: the existing systems all use 'other', I'm looking into them and see if they have some way of escaping
[07:32:27] <dbaupp> klutzy: (it should, but it doesn't get maintained, so it's  known to not work.)
[07:33:00] <Seldaek> acrichto: I see, I don't think it's a major fanciness though and this select thing really does match well to rust's "match" idiom, which has a _ for other afaik
[07:33:14] <Seldaek> I'd even argue the whole thing should be called match and not select ;)
[07:33:24] <klutzy> compiltest has interesting dying message: "'assertion failed: is_utf8(v)', D:\stone\rust-vanilla\src\libstd\str.rs:784"
[07:34:14] <klutzy> maybe it's more broken than we expect
[07:34:23] <acrichto> Seldaek: http://userguide.icu-project.org/formatparse/messages is I believe what we're attempting to adhere to
[07:35:44] <Seldaek> acrichto: ahh, the good ICU. well I rest my case then :) Anyway how would this work for translation, you'd first select a string from the current's language catalog, and pass that to ifmt! right?
[07:35:48] <dbaupp> klutzy: maybe, but you don't need to solve it now (you're certainly allowed to :P ), you're LLVM patches sound like they work.
[07:35:52] <dbaupp> *your
[07:36:00] *** Quits: TD-Linux (TD-Linux@E338EB99.2B4F0AE0.A0A36CCE.IP) (Ping timeout)
[07:36:20] <acrichto> Seldaek: from my understanding, you pass the format string to an i18n system which hands back a corresponding format string for the current locale and then you run using that
[07:36:42] *** Quits: mihneadb (Mihnea@moz-329F29A3.lightspeed.sntcca.sbcglobal.net) (Quit: Leaving)
[07:37:28] <Seldaek> acrichto: ok I see, thanks
[07:39:24] *** Joins: TD-Linux (TD-Linux@E338EB99.2B4F0AE0.A0A36CCE.IP)
[07:39:35] <dbaupp> acrichto: at runtime, right?
[07:39:37] *** Quits: jeaye (Jeaye@moz-FD505E54.hsd1.ca.comcast.net) (Quit: Don't tell them I was here...)
[07:40:02] <acrichto> dbaupp: yeah, and looking around at ICU specs, I'm not seeing anything about literally matching on the string "other" while not also hitting a catch-all case
[07:40:16] <acrichto> dbaupp: graydon may know, he's more familiar with the specs than I
[07:40:43] <dbaupp> acrichto: aha, I imagine that's it's very rare to want to match on "other" anyway
[07:40:50] *** Joins: spider-mario (spidermari@moz-81131DB6.fbx.proxad.net)
[07:41:04] <acrichto> apparently it's mostly intended for genders
[07:41:04] <strcat> dbaupp: I made the web rusti better ;]
[07:41:25] <dbaupp> strcat: you can't just say that without a link ;P
[07:41:34] <strcat> dbaupp: http://strcat.zapto.org:8000/
[07:41:38] <dbaupp> acrichto: could we match on enums rather than strings?
[07:41:40] <strcat> it's like a whole 8 minutes of work!
[07:41:55] <strcat> supports using different branches of rust, pretty printing and serves a random sample on load
[07:42:06] <dbaupp> acrichto: and have a built-in fmt::Male fmt::Female fmt::Unspecified (or whatever)
[07:42:17] <acrichto> dbaupp: I was considering doing something like that because it makes more sense from a rust-perspective, but I couldn't think of a good way to do it
[07:42:28] <dbaupp> something like fmt!("{1, match, fmt::Male { ...} fmt::Female {...}}")
[07:42:28] <dbaupp> oh
[07:42:36] <acrichto> dbaupp: Ideally the argument is some sort of trait, but you eventually need to do string matching b/c that's what the selectors are
[07:42:46] <dbaupp> acrichto: which selectors?
[07:42:46] *** Quits: ross (ross@moz-8A84103E.br.br.cox.net) (Quit: )
[07:43:05] <acrichto> dbaupp: {1, select, male{} female{} other{}} -- male/female/other
[07:43:14] <dbaupp> ah, right; because it all happens at runtime, so one couldn't parse a path and generate the match at compile-time.
[07:43:39] <acrichto> so ideally the argument to select would not be `&str` but some sort of trait
[07:43:47] <dbaupp> strcat: `format` uses --pretty normal?
[07:43:56] <strcat> dbaupp: just --pretty, so I guess normal
[07:44:03] <acrichto> I guess in theory it could be a trait with a method like `Selector::equivalent(&Self, &str) -> bool`
[07:44:15] <strcat> dbaupp: now it needs to underline spans from errors
[07:44:24] <strcat> but I need to figure out how to bubble up rustc error status somehow
[07:44:38] <dbaupp> strcat: is it running on your laptop also?
[07:44:43] <strcat> yes ;p
[07:44:54] * dbaupp pastes in all of libstd :P
[07:45:02] <strcat> it'll just go OOM at 128MiB
[07:45:04] <strcat> :D
[07:45:14] *** Quits: TD-Linux (TD-Linux@E338EB99.2B4F0AE0.A0A36CCE.IP) (Ping timeout)
[07:45:19] <strcat> dbaupp: https://github.com/thestinger/rust-playpen it's there
[07:45:23] <strcat> most of it, at least
[07:45:29] <strcat> need to include the script that makes the roots
[07:46:06] *** Quits: Sergio965 (sergiobz@moz-A8B88DF9.c3-0.sbo-ubr1.sbo.ma.cable.rcn.com) (Quit: My MacBook Pro has gone to sleep. ZZZzzzâ€¦)
[07:46:09] <dbaupp> you should probably remove the format button for now, btw; it just uglifies the code :(
[07:46:20] <dbaupp> do spawn { .. } => do spawn || { .. }
[07:46:53] <strcat> dbaupp: but if I advertise it, someone will get pissed off enough to fix it
[07:46:58] <strcat> ;p
[07:47:23] <dbaupp> hahaha
[07:47:40] <Seldaek> strcat: make it auto-format every time you submit code then :)
[07:47:52] <Seldaek> with a "formatting..." overlay and a spinner please
[07:48:00] <strcat> dbaupp: anyway cdnjs accepted my PR adding an up-to-date ace
[07:48:06] <strcat> so it doesn't destroy my upload anymore ;]
[07:49:05] <dbaupp> cool
[07:49:25] *** Joins: TD-Linux (TD-Linux@E338EB99.2B4F0AE0.A0A36CCE.IP)
[07:49:27] <dbaupp> strcat: we could set make tidy to run rustc --pretty on the whole codebase
[07:49:33] <dbaupp> that'd get the pprinter fixed fast
[07:49:58] * dbaupp particularly likes how it outputs invalid code
[07:50:42] <Eridius> if anyone has any opinion on c_str, now's the time to look at https://github.com/mozilla/rust/pull/8532
[07:51:12] <dbaupp> Eridius: I take it you removed the with_mut_c_str? :)
[07:51:17] <Eridius> dbaupp: yes :P
[07:51:22] <ion> Is there a way to use rust with non-Android Arm yet?
[07:54:10] *** Quits: azita (Azita@moz-C1FB2A8.hsd1.ca.comcast.net) (Quit: azita)
[07:54:28] <acrichto> ion: there was a pull request recently that supposedly added support for that
[07:54:44] <ion> Ok, thanks. Iâ€™ll try to find it.
[07:54:54] <acrichto> ion: https://github.com/mozilla/rust/pull/8220
[07:55:01] <ion> thanks
[07:55:10] <dbaupp> acrichto: I just tested, and it appears that the double indirection for https://github.com/mozilla/rust/issues/8529 does work
[07:55:24] <strcat> dbaupp: I need to make some nice code samples ;p
[07:55:34] <acrichto> dbaupp: maybe I don't know what I'm doing...
[07:55:50] *** Quits: maik__ (maik___@moz-E9AE01F.dip0.t-ipconnect.de) (Ping timeout)
[07:56:14] <acrichto> dbaupp: this code https://gist.github.com/alexcrichton/6239056 ?
[07:57:15] <strcat> dbaupp: it just seems to shove everything onto one line when it's small
[07:57:17] <strcat> ;\
[07:57:22] <acrichto> dbaupp: nmatsakis made a lot of changes recently to objects, which notably fixed every bug I had previously found with `&mut`, and perhaps they're using the correct semantics now?
[07:57:26] <strcat> luckily no one has taught it the real line limit is 100 now
[07:57:34] *** Quits: ab (alex@BC9D99CC.37C1012D.FE617B51.IP) (Quit: Konversation terminated!)
[07:57:35] <strcat> or it'd *really* shove everything onto 1 line
[07:57:44] *** Quits: bjz (brendanzab@B398BE78.F804C29E.D35A31DF.IP) (Quit: Leaving...)
[07:58:02] *** Joins: maik__ (maik___@moz-CE9473F1.dip0.t-ipconnect.de)
[07:58:46] <dbaupp> acrichto: https://gist.github.com/huonw/6239071
[07:58:57] <dbaupp> strcat: iterators!
[07:59:18] *** Joins: jensnockert (jensnocker@moz-C5F27039.cust.bredband2.com)
[07:59:23] <acrichto> dbaupp: oh yeah, but that isn't really feasible and nor can you move it out of a struct without taking &mut &mut &mut
[07:59:36] <dbaupp> acrichto: why isn't that feasible?
[07:59:49] <acrichto> b/c an api doesn't actually want &mut &mut it only wants &mut
[08:00:08] <dbaupp> the commented out write_http_header does only have &mut
[08:00:13] <acrichto> the problem is that you'd interfacing with apis design for an &mut buffer and you just want to hand off yours there for awhile
[08:00:15] *** Quits: jensnockert (jensnocker@moz-C5F27039.cust.bredband2.com) (Input/output error)
[08:00:30] <acrichto> dbaupp: but the commented out version won't work and it's the only one that you'd want to write
[08:00:42] <dbaupp> won't work why?
[08:00:54] <acrichto> uncomment it
[08:01:10] <dbaupp> that's only because we don't have impl Writer for &'self mut Writer in std::rt::io
[08:02:00] <acrichto> hmm... well the idea is that you're not writing <T: io::Writer>
[08:02:07] <acrichto> b/c there's no need to monomorphize
[08:02:30] <dbaupp> right, but sometimes you do want the monomorphised version
[08:02:31] <acrichto> although perhaps if we had automatic object coercion to traits this would work better...
[08:03:10] <acrichto> well the problem is that it's perfectly reasonable for one library to write a function which takes *just* an &mut io::Writer and then you end up wanting to call it
[08:03:17] <acrichto> but it turns out that your writer is stored in a struct
[08:03:29] <acrichto> or what if you just have a local reference and you just moved out of it?
[08:03:33] <dbaupp> ah, yes, that is a problem.
[08:03:59] <dbaupp> (But I think the stdlib should be designed to not cause that problem, even if it gets resolved.)
[08:04:02] <acrichto> you really need to give someone a loan on it...
[08:04:12] <dbaupp> sounds just like &mut :P
[08:04:36] <acrichto> that sounds kinda like the compiler should automatically generate some stuff for you
[08:04:40] <acrichto> but that may also be unreasonable
[08:04:59] <acrichto> I guess in theory &mut &mut io::Writer is coercable to &mut io::Writer
[08:05:06] <acrichto> it's *almost* the same vtable, but not quite
[08:05:19] <acrichto> or under the hood the representation is just the same maybe?
[08:05:44] <acrichto> dbaupp: well you still have problems, b/c &mut cannot alias and if the function returns &mut you've got problems
[08:05:58] <acrichto> dbaupp: so I don't think &mut &mut will solve this
[08:06:03] <dbaupp> Eridius: re the fast -> unchecked naming change; it's mainly because someone reading it will see `fast` and just use it (who wants a slow api?) without being appropriately careful. (although being `unsafe` makes this less of an issue.)
[08:06:46] <dbaupp> acrichto: if &mut Writer implements Writer then &mut &mut Writer can be cast to &mut Writer
[08:07:14] <dbaupp> there'll be a double indirection in the value field, and 2 copies of the vtable though.
[08:07:30] <dbaupp> (value = pointer that's not the vtable)
[08:07:40] <acrichto> dbaupp: oh wait yeah that should work
[08:08:00] <acrichto> hmmm that seems like a good solution
[08:08:02] * acrichto comments on the bug
[08:08:38] *** Joins: Earnestly (earnest@B0BDF733.8FDE20A.5411983D.IP)
[08:10:33] <Eridius> dbaupp: I feel like there's precedent for having a "_fast" unsafe variant function somewhere else in the codebase
[08:10:54] <dbaupp> Eridius: .push_fast
[08:11:04] <Eridius> and yeah I marked it unsafe specifically to tell people to take care with the function. It's not actually memory unsafe, it just doesn't enforce invariants
[08:11:05] <dbaupp> (that's the only one)
[08:11:07] <Eridius> ah yes
[08:11:42] <Eridius> I suppose I could rename it to _unchecked and drop the unsafe
[08:11:51] *** Joins: dim-an (ermolovd@moz-74FA7782.yandex.net)
[08:12:04] <dbaupp> both!
[08:12:12] <dbaupp> don't drop the unsafe
[08:12:54] <Eridius> well I mean null_byte::cond.trap(|_| Truncate).inside(|| { ... }) is equivalent to _fast
[08:13:51] <dbaupp> there's precedent for _nocheck (in std::ascii)
[08:14:21] *** Quits: maik__ (maik___@moz-CE9473F1.dip0.t-ipconnect.de) (Ping timeout)
[08:14:22] <Eridius> I'll look at that in a min
[08:14:46] <dbaupp> (I'm very definitely not advocating removing the unsafe, btw.)
[08:16:25] *** Joins: wilmoore (wilmoore@moz-71431C3A.hsd1.co.comcast.net)
[08:16:30] <Eridius> dbaupp: really? the more I think about it, the more inclined I am to remove it as long as I change the name away from _fast
[08:16:53] <Eridius> the _fast variant cannot cause memory unsafety, or an invalid state of the object. All it can do is cause premature truncation
[08:17:18] <dbaupp> Eridius: why convert the compile-time check into a write/review/grep-time check?
[08:17:49] <dbaupp> (I believe it can cause security holes, with file-paths being truncated too early and such.)
[08:18:01] <Eridius> hmm
[08:18:25] <dbaupp> acrichto: I think much of these problems would be resolved if trait objects implemented themselves as much as possible
[08:18:26] <Eridius> ok, I'll leave it as unsafe, since you feel so strongly about it
[08:18:40] <dbaupp> acrichto: (the problem about being specific to Writer)
[08:18:44] <Eridius> is there any reason why a trait object shouldn't just implicitly implement itself?
[08:18:58] <dbaupp> Eridius: you should get someone elses opinion... strcat knows his stuff.
[08:19:08] <dbaupp> Eridius: yes, if it mentions Self anywhere, then it can't
[08:19:29] <Eridius> ah
[08:19:31] <dbaupp> e.g. (@1i as @Eq) == (@1f as @Eq) ??
[08:19:55] <Eridius> dbaupp: so should I rename to _nocheck, following ascii's lead? I think _unchecked is aesthetically better though
[08:19:58] <dbaupp> (but, I think, in any other case it can, and I'd say, should.)
[08:20:05] *** Quits: strcat (strcat@moz-54F7FD49.cpe.net.cable.rogers.com) (Quit: sleep)
[08:20:22] <dbaupp> Eridius: i agree
[08:20:38] <dbaupp> (that unchecked is nicer, maybe ascii could be renamed.)
[08:27:59] <Eridius> ok, renamed
[08:28:00] <dbaupp> cmr: do you reckon you could add http://ix.io/7iA to the override file? (that should fill in the memory jump-gap)
[08:28:37] <Eridius> oops damn I amended the wrong commit
[08:29:12] *** Joins: robertknight (robertknig@moz-54528EE0.wby.mendeley.com)
[08:29:24] <dbaupp> cmr: (unless of course it's going to do that automatically soon)
[08:30:52] *** Joins: CarpNet (ac@moz-FD24B77.sohonet.co.uk)
[08:33:36] *** Joins: maik__ (maik___@moz-CE9473F1.dip0.t-ipconnect.de)
[08:34:51] <Eridius> ok, re-pushed and renamed to _unchecked
[08:34:53] <Eridius> now it's time for bed
[08:36:06] <dbaupp> night!
[08:37:03] *** Joins: jaen (jaen@moz-E0979827.copit.pl)
[08:38:37] *** Quits: m_kato (m_kato@moz-C286AD9A.bitcat.net) (Ping timeout)
[08:38:39] *** Joins: jensnockert (jensnocker@moz-FEE1F506.mobileonline.telia.com)
[08:40:37] *** Joins: m_kato (m_kato@moz-C286AD9A.bitcat.net)
[08:45:28] *** Joins: BitPuffin (quassel@moz-7BB00EC9.bredband.comhem.se)
[08:47:47] *** Joins: bjz (brendanzab@moz-38D46E1C.perm.iinet.net.au)
[08:50:04] *** Joins: lucian (lucian@6B2B4644.4304AE1E.CE5E78F6.IP)
[08:52:12] *** Quits: engla (engla@moz-DBD1D96E.cust.bredbandsbolaget.se) (Ping timeout)
[08:52:36] *** Joins: davbo (dave@moz-3FFA637C.oucs.ox.ac.uk)
[08:59:57] *** Joins: BizarreCake (BizarreCak@moz-361FE9B2.dynamic.barak-online.net)
[09:01:26] *** Joins: donri (dag@moz-9BB61102.tbcn.telia.com)
[09:06:15] *** Joins: maik_ (maik___@moz-7012C389.dip0.t-ipconnect.de)
[09:06:15] *** Parts: dim-an (ermolovd@moz-74FA7782.yandex.net) ()
[09:07:06] *** Quits: maik__ (maik___@moz-CE9473F1.dip0.t-ipconnect.de) (Ping timeout)
[09:11:37] *** Joins: snadon (chatzilla@moz-3BC727E8.mc.videotron.ca)
[09:16:06] <cmr> dbaupp: sure, a lot of them need building though
[09:16:17] <cmr> I'll do it when the round of benches is over
[09:16:36] <cmr> about 2 hrs left (~50 benches)
[09:17:09] <cmr> bjz: boop
[09:17:18] <cmr> acrichto: pong
[09:17:45] <dbaupp> cmr: okeydokey
[09:17:56] <dbaupp> cmr: (I guess those benches will fill in that gap anyway?)
[09:18:07] <cmr> dbaupp: (they should yeah)
[09:18:59] <cmr> not a lot though...
[09:19:05] <cmr> that gap seems to be conveniently persistent
[09:19:11] <cmr> I wonder if there was a build failure
[09:19:34] <cmr> or if it was due to the weird "celery forgets about queued tasks" thing
[09:19:45] <cmr> and the auto-skipper just skipped 'em
[09:20:35] <dbaupp> right, I guess we'll see
[09:22:41] *** Quits: dan_johnsin (dan_johnsi@6902762D.11B071D.FB9A45AF.IP) (Ping timeout)
[09:24:05] *** Joins: dan_johnsin (dan_johnsi@6902762D.11B071D.FB9A45AF.IP)
[09:26:12] *** Joins: ghrust (ghrust@DE823A67.6A2AE50.F3114085.IP)
[09:26:12] <ghrust> 01[13rust01] 15bors merged 06auto into 06master: 02http://git.io/97HZlQ
[09:26:12] *** Parts: ghrust (ghrust@DE823A67.6A2AE50.F3114085.IP) ()
[09:26:40] *** Joins: avaf (Mibbit@A1793499.EC15082C.D7C984E0.IP)
[09:26:50] *** Quits: jensnockert (jensnocker@moz-FEE1F506.mobileonline.telia.com) (Input/output error)
[09:29:41] *** Joins: ghrust (ghrust@DE823A67.6A2AE50.F3114085.IP)
[09:29:41] <ghrust> 01[13rust01] 15bors pushed 0 new commits to 06auto: 02http://git.io/9EaPJw
[09:29:41] *** Parts: ghrust (ghrust@DE823A67.6A2AE50.F3114085.IP) ()
[09:29:41] *** Joins: ghrust (ghrust@2EE61FCC.6A2AE50.F3114085.IP)
[09:29:41] <ghrust> 01[13rust01] 15bors pushed 3 new commits to 06auto: 02http://git.io/Yj4_Vg
[09:29:41] <ghrust> 13rust/06auto 14783c6a1 15Alex Crichton: Add a bunch of tests for closed issues...
[09:29:41] <ghrust> 13rust/06auto 1489b1420 15Alex Crichton: Fix a typo in the ifmt dox
[09:29:42] <ghrust> 13rust/06auto 1465b82ab 15bors: auto merge of #8485 : alexcrichton/rust/add-tests, r=catamorphism...
[09:29:44] *** Parts: ghrust (ghrust@2EE61FCC.6A2AE50.F3114085.IP) ()
[09:31:52] *** Joins: z0w0 (zack@moz-7E6DC3A.lnse2.woo.bigpond.net.au)
[09:40:53] *** Quits: victorporof (victorporo@DBFC8886.2203F6DA.D111398B.IP) (Quit: victorporof)
[09:41:33] *** Quits: avaf (Mibbit@A1793499.EC15082C.D7C984E0.IP) (Quit: http://www.mibbit.com ajax IRC Client)
[09:41:43] *** Joins: q66 (q66@6EE9DE40.46454B5D.33AABD5F.IP)
[09:42:00] *** Joins: vosen (vosen@moz-266BA656.icpnet.pl)
[09:44:04] <bjz> cmr: I have most of the registry outputting to structs now
[09:44:18] <bjz> cmr: just need to convert it into rust
[09:44:53] <bjz> not sure what to do about the lists of extensions the aliases and groups etc
[09:47:08] *** Joins: Blub\w (wry@7E3BB9D.71150E1A.237AE2BA.IP)
[09:51:40] *** Quits: maik_ (maik___@moz-7012C389.dip0.t-ipconnect.de) (Ping timeout)
[09:51:59] *** Joins: maik_ (maik___@moz-7012C389.dip0.t-ipconnect.de)
[09:52:48] <maik_> can we pattern match ~[]? like in haskel with (x:xs)
[09:52:53] <maik_> Haskell*
[09:52:57] <cmr> maik_: yes
[09:53:14] <cmr> al;though I think our vector matching is less powerful
[09:53:28] *** Quits: james4k (james@moz-E7990244.consolidated.net) (Ping timeout)
[09:54:10] <maik_> could you show me the syntax?
[09:54:58] <dbaupp> rusti: match ~[1,2] { [1, .._] => println("1"), [_, ..tail] => printfln!(tail), _ => println("other") }
[09:54:59] -rusti- 1
[09:54:59] -rusti- ()
[09:55:10] <dbaupp> rusti: match ~[3,2,1] { [1, .._] => println("1"), [_, ..tail] => printfln!(tail), _ => println("other") }
[09:55:10] -rusti- &[2, 1]
[09:55:11] -rusti- ()
[09:55:16] <cmr> rusti: let xs = range(0, 10).to_owned_vec(); match xs { [y, ..ys] => (y, ys) }
[09:55:16] -rusti- <anon>:5:47: 5:80 error: non-exhaustive patterns: vectors of length 0 not covered
[09:55:16] -rusti- <anon>:5          let xs = range(0, 10).to_owned_vec(); match xs { [y, ..ys] => (y, ys) }
[09:55:17] -rusti-                                                         ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
[09:55:17] -rusti- error: aborting due to previous error
[09:55:18] -rusti- application terminated with error code 101
[09:55:19] <dbaupp> rusti: match ~[3] { [1, .._] => println("1"), [_, ..tail] => printfln!(tail), _ => println("other") }
[09:55:20] -rusti- &[]
[09:55:21] -rusti- ()
[09:56:01] <dbaupp> cmr: (I actually think our vector pattern matching is more powerful than any of haskell's pattern matching, e.g. can't pattern match from the end.)
[09:56:10] *** Joins: ghrust (ghrust@F6EE6DE3.6A2AE50.F3114085.IP)
[09:56:10] <ghrust> 01[13rust01] 15bors 04force-pushed 06auto from 1465b82ab to 147f58552: 02http://git.io/N3iJvQ
[09:56:10] *** Parts: ghrust (ghrust@F6EE6DE3.6A2AE50.F3114085.IP) ()
[09:56:11] *** Joins: ghrust (ghrust@1E8607E8.6A2AE50.F3114085.IP)
[09:56:11] <ghrust> 01[13rust01] 15bors pushed 3 new commits to 06auto: 02http://git.io/Evq0Zw
[09:56:11] <ghrust> 13rust/06auto 1458021be 15Huon Wilson: rustc: allow @ as-patterns to move when the sub-pattern contains no bindings....
[09:56:11] <ghrust> 13rust/06auto 1453487a0 15Huon Wilson: std: Move the iterator param on FromIterator and Extendable to the method....
[09:56:12] <ghrust> 13rust/06auto 14790e6bb 15bors: auto merge of #8490 : huonw/rust/fromiterator-extendable, r=catamorphism...
[09:56:14] *** Parts: ghrust (ghrust@1E8607E8.6A2AE50.F3114085.IP) ()
[09:56:24] <dbaupp> rusti: match ~[] { [1, .._] => println("1"), [_, ..tail] => printfln!(tail), _ => println("empty") }
[09:56:25] -rusti- empty
[09:56:25] -rusti- ()
[09:56:31] <maik_> rusti: match ~[1,2,3] { [1, .._] => println("1"), [_, _,..tail] => printfln!(tail), _ => println("other") }
[09:56:31] -rusti- 1
[09:56:32] -rusti- ()
[09:56:51] <maik_> rusti: match ~[1,2,3] { [1, .._] => [_, _,..tail] => printfln!(tail), _ => println("other") }
[09:56:51] -rusti- <anon>:5:39: 5:40 error: unexpected token: `_`
[09:56:51] -rusti- <anon>:5          match ~[1,2,3] { [1, .._] => [_, _,..tail] => printfln!(tail), _ => println("other") }
[09:56:51] -rusti-                                                 ^
[09:56:51] -rusti- application terminated with error code 101
[09:57:06] <maik_> rusti: match ~[1,2,3] { [_, _,..tail] => printfln!(tail), _ => println("other") }
[09:57:07] -rusti- &[3]
[09:57:07] -rusti- ()
[09:57:11] <maik_> oh cool
[09:57:15] <maik_> thanks
[09:59:47] *** Quits: snadon (chatzilla@moz-3BC727E8.mc.videotron.ca) (Ping timeout)
[10:02:18] *** Joins: doomlord (doomlod@moz-13E69BC8.range86-180.btcentralplus.com)
[10:17:47] *** Joins: maxli (maxli@B5559308.9C54E60.2FA4EA88.IP)
[10:19:12] *** Quits: Voomer (Voomer@moz-CC05FF5E.hsd1.wa.comcast.net) (Connection reset by peer)
[10:19:52] *** Joins: Cromulent (Cromulent@moz-983B638D.cable.virginmedia.com)
[10:20:21] *** Quits: Cromulent (Cromulent@moz-983B638D.cable.virginmedia.com) (Quit: KVIrc 4.2.0 Equilibrium http://www.kvirc.net/)
[10:20:58] <maik_> we do also have as patterns right?
[10:21:16] <cmr> yes
[10:21:41] <cmr> rusti: match 5 { x@1..10 => printfln!(x), _ => println("nope") }
[10:21:42] -rusti- 5
[10:21:42] -rusti- ()
[10:21:45] <cmr> rusti: match 11 { x@1..10 => printfln!(x), _ => println("nope") }
[10:21:46] -rusti- nope
[10:21:46] -rusti- ()
[10:24:16] *** Joins: sk (sk@61A494B3.BA40E8A.AAC02D62.IP)
[10:24:17] <maik_> thanks
[10:31:03] <maik_> where can I look up the exit codes? or what does -11 mean?
[10:35:23] <cmr> dbaupp: bench round complete, scheduling builds!
[10:35:54] *** Quits: maxli (maxli@B5559308.9C54E60.2FA4EA88.IP) (Quit: Leaving.)
[10:46:10] <dbaupp> cmr: awesome!
[10:46:46] <dbaupp> cmr: (is the big gap from the 10th to now just because it was running benches rather than builds?)
[10:46:55] <cmr> dbaupp: yup!
[10:50:42] *** Quits: maik_ (maik___@moz-7012C389.dip0.t-ipconnect.de) (Connection reset by peer)
[10:50:56] *** Joins: maik (maik___@moz-7012C389.dip0.t-ipconnect.de)
[10:51:24] <maik> hm when I compile rust now I always run out of memory
[10:51:29] *** Joins: jclark (jjc@moz-B46FC3F8.revip7.asianet.co.th)
[10:53:36] *** Quits: TD-Linux (TD-Linux@E338EB99.2B4F0AE0.A0A36CCE.IP) (Ping timeout)
[10:54:16] <jclark> v. newbie question: what does 'self mean e.g. impl<'self> or fn glyphs(&'self self) ?
[10:54:46] *** Joins: TD-Linux (TD-Linux@E338EB99.2B4F0AE0.A0A36CCE.IP)
[10:54:51] <cmr> dbaupp: I discovered the magic of git-new-workdir, so should cut off ~10 minutes rsyncing the entire build tree...
[10:55:41] <cmr> jclark: They are lifetimes
[10:55:55] <cmr> http://static.rust-lang.org/doc/tutorial-borrowed-ptr.html#named-lifetimes
[10:59:16] <jclark> Does "self" have a special meaning after ' or is it just a conventional name?
[11:00:36] <cmr> jclark: conventional (also due to a deficiency in the parser, it's the only name accepted in some contexts, but that will be fixed in due time)
[11:00:53] <cmr> The only special lifetime is 'static, which means "always alive"
[11:01:05] *** Joins: ghaering (Mibbit@FF4EA6DF.7ACB71E6.8630996.IP)
[11:01:06] <dbaupp> maik: how much ram do you have?
[11:01:15] <dbaupp> cmr: cool; how often do you do that?
[11:01:24] <cmr> dbaupp: for every build
[11:01:28] <maik> dbaupp, 8gigs
[11:01:46] <maik> and 4gigs swap
[11:01:48] <cmr> I make a new tree in /var/rust/build/$hash, build it and install into /var/rust/$hash prefix
[11:01:54] <dbaupp> maik: should be easily enough
[11:02:04] <dbaupp> maik: do you have a lot of other things running?
[11:02:14] <maik> dbaupp, only sublime
[11:02:45] <cmr> maik: what do you mean run out of memory? it literally consumes all of your phys+swap?
[11:02:46] <dbaupp> maik: I believe the max mem usage of bootstrapping rustc is a little less than 2gigs atm.
[11:02:59] <dbaupp> cmr: oh, wow, that's much nicer.
[11:03:23] <maik> cmr, yeah
[11:04:22] *** Joins: richard|s (mindginati@moz-268511E5.dsl.dyn.ihug.co.nz)
[11:05:45] *** Joins: fylux (Mibbit@moz-11F9F15.red-83-37-58.dynamicip.rima-tde.net)
[11:06:02] *** Joins: maxli (maxli@B5559308.9C54E60.2FA4EA88.IP)
[11:06:06] <dbaupp> maik: what's the exact command you're running?
[11:06:19] <fylux> Hi Guys, can you tell me if the examples of rust code in wikipedia are right? http://en.wikipedia.org/wiki/Rust_%28programming_language%29 Because I'm gonna copy them in the spanish wikipedia
[11:07:13] *** Quits: ChrisMorgan (chris@moz-6AC741CA.static.tpgi.com.au) (Ping timeout)
[11:07:30] <dbaupp> fylux: they're correct for rust 0.7 (I think), but not for master.
[11:07:35] <maik> dbaupp, just make, and make -4 aborts with an error, it hangs at the line "cp: x86_64-unknown-linux-gnu/stage1/lib/libsyntax.so" for 15mins and then aborts with some weird error msg. 
[11:08:20] <fylux> Ok
[11:08:38] <maik> dbaupp, I think I used sudo one time and now something is messed up and has the wrong rights 
[11:09:15] <dbaupp> maik: `sudo make clean` should fix it
[11:09:28] *** Joins: ChrisMorgan (chris@moz-6AC741CA.static.tpgi.com.au)
[11:10:35] *** Quits: fylux (Mibbit@moz-11F9F15.red-83-37-58.dynamicip.rima-tde.net) (Quit: http://www.mibbit.com ajax IRC Client)
[11:10:39] <ChrisMorgan> I cope tolerably well with 4GB of RAM. If I have a large session running (especially a long-lived hundreds-of-tabs Firefox) I have to kill off some things first, but it works OK.
[11:11:54] *** Quits: maxli (maxli@B5559308.9C54E60.2FA4EA88.IP) (Ping timeout)
[11:12:02] <dbaupp> it's currently (at least, the most recent data I have) ~500MB worse than it could be
[11:12:10] <dbaupp> http://huonw.github.io/isrustfastyet/mem/#1de201c,dbde42e
[11:12:43] *** Joins: james4k (james@moz-E7990244.consolidated.net)
[11:18:31] *** Parts: jclark (jjc@moz-B46FC3F8.revip7.asianet.co.th) ()
[11:20:39] *** Joins: fylux (Mibbit@moz-11F9F15.red-83-37-58.dynamicip.rima-tde.net)
[11:20:52] <fylux> Does rust support typestates in the current version?
[11:21:05] <cmr> fylux: no, and it likely never will again
[11:21:08] *** Quits: ghaering (Mibbit@FF4EA6DF.7ACB71E6.8630996.IP) (Quit: http://www.mibbit.com ajax IRC Client)
[11:21:23] <doublec> fylux: see http://pcwalton.github.io/blog/2012/12/26/typestate-is-dead/
[11:21:26] *** Quits: TD-Linux (TD-Linux@E338EB99.2B4F0AE0.A0A36CCE.IP) (Ping timeout)
[11:21:33] <fylux> Anybody knows a translation for typestates in spanish?
[11:21:48] *** Joins: TD-Linux (TD-Linux@E338EB99.2B4F0AE0.A0A36CCE.IP)
[11:22:02] <dbaupp> doublec: nice blog post :)
[11:22:09] <doublec> dbaupp: thanks :)
[11:22:18] <dbaupp> it's neat how well some common Haskell patterns map into rust
[11:22:45] <cmr> dbaupp: which post is this?
[11:22:54] <dbaupp> cmr: you're so behind :P
[11:23:00] <doublec> yes. coming from ATS which doesn't have the greatest type inference it's nice using Rust where (like Haskell) it magically gets the correct type.
[11:23:05] <dbaupp> cmr: http://bluishcoder.co.nz/2013/08/15/phantom_types_in_rust.html
[11:23:17] <dbaupp> cmr: it's been on reddit for a whole *hour*!
[11:23:30] <doublec> haha, it appeared on reddit seconds after I posted. I was impressed.
[11:23:30] <fylux> nobody knows a translation?
[11:23:44] <cmr> fylux: what is the type of a variable called?
[11:24:04] <dbaupp> doublec: there's a planet.mozilla.org -> reddit auto-poster; but that doesn't post to /r/rust
[11:24:30] <fylux> type of the variable
[11:24:44] <fylux> cmr: tipo de la variable
[11:25:29] <doublec> fylux: typestate is the name of the technique. Maybe look for spanish translations of other articles talking about it?
[11:25:32] <cmr> fylux: I think the best translation would be a translation of "state of the type"
[11:25:49] <cmr> but it's a technical term, not a general one
[11:26:01] <dbaupp> fylux: http://en.wikipedia.org/wiki/Typestate_analysis
[11:26:16] * dbaupp isn't sure if that's what Rust had
[11:26:27] <fylux> unfortunately this article isn't in spanish
[11:27:05] <Seldaek> doublec: oh the tainted string stuff is pretty neat
[11:27:44] <dbaupp> <3 type safety
[11:27:58] <doublec> Seldaek: yes, I like the approach. Ur/Web does a lot of requiring of 'blessing' things to be allowed to be embedded in web pages.
[11:28:31] *** Joins: drrb (drrb@4D561226.896EE5A.377B9828.IP)
[11:28:49] <fylux> typestate is "association of state variables by type"?
[11:29:34] <drrb> Hello
[11:29:38] <fylux> it could be a definition?
[11:29:52] <dbaupp> doublec: I assume that bless is escaping the input, not just a "transmute" (in rust terms)
[11:29:55] <Seldaek> doublec: yeah I'm not too much into the religious terminology but the concept is solid and having compile time warnings for it is even more awesome
[11:30:21] <dbaupp> Seldaek: *errors
[11:30:25] <Seldaek> doublec: yeah it obviously should escape or strip evil stuff or whatever :)
[11:30:34] <Seldaek> err, dbaupp ^
[11:30:46] <doublec> dbaupp: correct
[11:30:51] <Seldaek> and yes, errors indeed
[11:30:59] <doublec> dbaupp: I was too lazy to actually write an escape function
[11:31:05] *** Joins: sigma (sigma@moz-5022C87F.range109-151.btcentralplus.com)
[11:31:11] <doublec> dbaupp: the transmute is needed though to change the type
[11:31:36] <doublec> dbaupp: it's a safe cast as the only thing being changed is the phantom type
[11:31:37] <drrb> Does anybody know of any projects that are using rustpkg?
[11:31:45] <cmr> drrb: rustdoc_ng does.
[11:32:00] <cmr> rust-zmq does too, but it's currently broken
[11:32:12] <dbaupp> doublec: right; any particular reason it's not called `escape`?
[11:32:20] <drrb> cmr: thanks :)
[11:32:22] *** Quits: james4k (james@moz-E7990244.consolidated.net) (Ping timeout)
[11:32:35] <doublec> dbaupp: I used Ur/Web's terminalogy but I probably should have called it escape.
[11:32:39] * doublec considers changing it
[11:32:46] *** Quits: sigma (sigma@moz-5022C87F.range109-151.btcentralplus.com) (Ping timeout)
[11:32:57] <dbaupp> doublec: oh, I see; precedent is good. :)
[11:33:14] <cmr> doublec: nit: "unique string allocated on the heap" should be "owned pointer to a string allocated on the heap"
[11:34:08] <dbaupp> doublec: I think that you can write `match Fragment { Str(s) => Str(s) }`, and avoid the transmute, btw.
[11:34:10] <maik> I created a "functional" list in Rust. Any complains? https://gist.github.com/anonymous/6240152
[11:34:13] <dbaupp> (not that it matters)
[11:34:31] <doublec> cmr: thanks, changed.
[11:34:55] <cmr> bblum: ^& see maik's list
[11:35:02] <cmr> maik: (bblum was wanting one at some point)
[11:35:06] *** Joins: sigma (sigma@51C589B3.EF2694B5.DFAC6AA7.IP)
[11:35:15] <doublec> dbaupp: yes, You can also use traits to write a function on <Safe> and <Unsafe> that does the escape/transmute on the latter and passes through on the former.
[11:35:25] <maik> cmr, ah ok
[11:35:34] <dbaupp> yup
[11:35:51] * dbaupp has experimented with this sort of type-safety in Haskell and Rust :)
[11:37:00] <doublec> maik: do those tail calls get optimized in Rust?
[11:37:08] *** Quits: fylux (Mibbit@moz-11F9F15.red-83-37-58.dynamicip.rima-tde.net) (Quit: http://www.mibbit.com ajax IRC Client)
[11:37:21] *** Joins: samx (sami@moz-48EC0983.dyn.optonline.net)
[11:37:34] <cmr> doublec: "maybe"
[11:37:44] <maik> doublec, I only have one tail call, but I have no idea 
[11:37:52] <cmr> Rust doesn't have guaranteed TCO
[11:38:14] <cmr> LLVM will do it when it can get away with it aiui
[11:38:16] <doublec> right, that's what I thought
[11:38:21] <maik> at least I think I only have one tail call
[11:38:50] <doublec> maik: contains and push?
[11:39:06] <doublec> s/push/elem_at
[11:39:46] <doublec> dbaupp: I tried to do a List with a length as a type index but got stuck 
[11:40:09] *** Quits: TD-Linux (TD-Linux@E338EB99.2B4F0AE0.A0A36CCE.IP) (Ping timeout)
[11:40:19] <maik> dbaupp, well push is definitely a tail call but let me check if elem_at is too
[11:41:00] <maik> oh
[11:41:08] <cmr> doublec: the phantom type thing is a pretty interesting technique
[11:41:13] <maik> should went do doublec ^
[11:41:35] <maik> doublec, only push is a tail call
[11:41:53] <doublec> this is what I ended up with: https://ezcrypt.it/ER6n#a00IeE5R6sdqKd8G3ZVFsChH
[11:42:15] <cmr> doublec: but for "`View` describes extra data associated with this node that this task has access to", how does the Node access the extra data at all? 
[11:42:21] *** Joins: TD-Linux (TD-Linux@E338EB99.2B4F0AE0.A0A36CCE.IP)
[11:42:36] <cmr> Or, it doesn't and just uses of it do, probably using some auxillary table?
[11:42:45] <maik> wait tail call in english means from top to bottom and to up again right?
[11:43:42] <doublec> cmr: you are right that the view itself doesn't, it just provides access to it.
[11:43:47] <dbaupp> maik: tail call means fn foo() { .... return bar() }
[11:44:06] <dbaupp> (where bar can be foo, but doesn't have to be.)
[11:44:15] <doublec> cmr: you need the LayoutView version of Node to be able to access the private field 'layout_data'
[11:44:52] <maik> dbaupp, ah okay we always called it end recursion 
[11:44:55] <dbaupp> doublec: list_zip is commented out because it doesn't work?
[11:44:59] <doublec> dbaupp: yes
[11:45:04] <maik> yeah then I have two tail calls
[11:45:24] *** Joins: FrozenCow (FrozenCow@moz-B2DF4929.chello.nl)
[11:45:42] *** Quits: robertknight (robertknig@moz-54528EE0.wby.mendeley.com) (Ping timeout)
[11:45:54] *** Quits: drrb (drrb@4D561226.896EE5A.377B9828.IP) (Quit: drrb)
[11:45:57] <doublec> dbaupp: with it uncommented I get https://ezcrypt.it/FR6n#DR2id3lPdil5hwmjksVq65R8
[11:46:15] <doublec> I was trying to translate some of the examples from http://bluishcoder.co.nz/2010/09/01/dependent-types-in-ats.html
[11:47:01] *** Quits: samx (sami@moz-48EC0983.dyn.optonline.net) (Quit: This computer has gone to sleep)
[11:47:27] <dbaupp> doublec: that's a little strange!
[11:48:02] <dbaupp> doublec: wait, no, I lie; it's not strange.
[11:48:15] <doublec> Please tell me I'm doing something stupid :)
[11:48:19] <maik> doublec, why did you have to use unsafe?
[11:48:26] <dbaupp> doublec: don't think so
[11:48:44] <doublec> maik: in the List<T,N> example?
[11:48:52] *** Quits: z0w0 (zack@moz-7E6DC3A.lnse2.woo.bigpond.net.au) (Ping timeout)
[11:49:10] <maik> doublec, yes
[11:49:32] <doublec> maik: that's in 'cons' to allow calling transmute to make the compiler change the type from List<T,N> to List<T,Succ<n>>
[11:49:48] <doublec> I couldn't work out how to get the type of N to change otherwise
[11:49:50] <dbaupp> doublec: it's just the nil/cons calls don't associate with the `N` parameter (since we don't have e.g. GADTs), and so it doesn't know that Nil => N = Zero (which matches with the nil call), and Cons => N = Prev<M> (and that this matches with the cons call.)
[11:50:02] <dbaupp> *Succ
[11:50:50] <doublec> dbaupp: I see. So it's probably not really useful in this case.
[11:51:07] <dbaupp> doublec: well, not really possible without some form of dependent types
[11:51:16] <cmr> https://gist.github.com/sstewartgallus/5605948
[11:51:20] <cmr> Dunno if that's helpful or not
[11:52:07] <doublec> cmr: that looks nifty. I'll take a look, thanks!
[11:53:09] *** Joins: ghrust (ghrust@24260B07.6A2AE50.F3114085.IP)
[11:53:09] <ghrust> 01[13rust01] 15bors merged 06auto into 06master: 02http://git.io/Evq0Zw
[11:53:09] *** Parts: ghrust (ghrust@24260B07.6A2AE50.F3114085.IP) ()
[11:53:20] <dbaupp> cmr: neat
[11:53:25] *** Quits: richard|s (mindginati@moz-268511E5.dsl.dyn.ihug.co.nz) (Quit: brb)
[11:54:05] <maik> ?
[11:54:09] <maik> what is this pub type Is <S, T> = Is_ <S, T>;
[11:54:27] <maik> couldn't you just have made it "priv struct Is <S, T>;"
[11:54:47] <maik> oh
[11:54:54] <maik> you want it to be visible
[11:55:21] <dbaupp> yeah, you want the type to be visible, but not constructible.
[11:55:45] <dbaupp> (also possible via `pub struct Is<S,T> { priv hah: () }`.)
[11:56:08] *** Joins: ghrust (ghrust@F6EE6DE3.6A2AE50.F3114085.IP)
[11:56:08] <ghrust> 01[13rust01] 15bors pushed 0 new commits to 06auto: 02http://git.io/dsMgVw
[11:56:08] *** Parts: ghrust (ghrust@F6EE6DE3.6A2AE50.F3114085.IP) ()
[11:56:09] *** Joins: ghrust (ghrust@C8693FCB.6A2AE50.F3114085.IP)
[11:56:09] <ghrust> 01[13rust01] 15bors pushed 5 new commits to 06auto: 02http://git.io/gPkxbg
[11:56:09] <ghrust> 13rust/06auto 143d83010 15Felix S. Klock II: Switch to new <V:Visitor> visitor (rather than @Visitor)....
[11:56:09] <ghrust> 13rust/06auto 14a5a5432 15Felix S. Klock II: Switch metadata::encoder to <V:Visitor> trait....
[11:56:09] <ghrust> 13rust/06auto 140d85928 15Felix S. Klock II: Switch borrowck::gather_loans to <V:Visitor> visit API....
[11:56:11] *** Parts: ghrust (ghrust@C8693FCB.6A2AE50.F3114085.IP) ()
[11:57:55] <cmr> Cycle time down to 2 hours, that's nice
[11:58:29] * dbaupp prefers the 30 minutes it used to be
[11:58:38] <dbaupp> breakage? meh.
[11:58:40] <cmr> Yeah :(
[11:59:15] <cmr> Some work in metadata could hugely speed up the test suite
[12:00:50] * dbaupp nominates cmr
[12:01:08] * cmr accepts nomination
[12:02:48] <Ms2ger> \o/
[12:03:16] <cmr> I don't know whether it's sad or inspiring that I replaced celery with gnu parallel
[12:04:26] * dbaupp is uninspired that it's still not in plain Rust yet
[12:04:56] *** Joins: true_droid (true_droid@moz-123FD9B8.beck.volia.net)
[12:04:57] <cmr> rust just can't beat `parallel -u buildit.py < builds` :p
[12:05:24] <cmr> it probably could, with some library work
[12:05:43] <dbaupp> 'course it could! Rust is the best.
[12:05:52] * dbaupp is in fanboy mode
[12:06:28] *** Joins: maxli (maxli@13F2CEC5.7672369.D8E68FF6.IP)
[12:06:58] *** Joins: Sergio965 (sergiobz@moz-A8B88DF9.c3-0.sbo-ubr1.sbo.ma.cable.rcn.com)
[12:07:50] <doomlord> lack of headers might mean more potential for better parallel build tools in future? (vs c++ )
[12:07:58] <cmr> doomlord: yup
[12:08:06] <cmr> https://github.com/mozilla/rust/issues/2369
[12:08:10] *** Quits: maxli (maxli@13F2CEC5.7672369.D8E68FF6.IP) (Ping timeout)
[12:08:18] * Ms2ger shakes his fist at C++ headers
[12:08:34] <doomlord> :) i'll refrain from another rant lol
[12:08:43] <dbaupp> "I am volunteering to work on this after 0.3" :'(
[12:09:03] <dbaupp> (well, I guess it's still after 0.3, so if tjc ever starts working on it, then he won't've been lying.)
[12:09:28] *** Quits: Sergio965 (sergiobz@moz-A8B88DF9.c3-0.sbo-ubr1.sbo.ma.cable.rcn.com) (Ping timeout)
[12:09:35] <cmr> Walter Bright had a really great article about why compiling C++ is such a chore
[12:09:42] *** Joins: bytewise (bytewise@moz-4A801D04.unitymediagroup.de)
[12:09:48] <dbaupp> woops
[12:09:56] <doomlord> so the 'cstore  metadata' is basically the information c++ has in headers (whats needed to link / generate inlined code)?
[12:10:09] * dbaupp just merged 2 commits in one pull request because of a rebase gone wrong
[12:10:38] <cmr> Rust (and D, aiui) eliminate all of the things that make C++ slow to compile, and since our compilation units are very large, we can break them up into smaller bits more easily, rather than just compilation-unit-at-a-time like C++
[12:10:43] <doomlord> and for IDE stuff , you could more intelligently lazily compile whats relevant to the current context i bet.
[12:13:16] *** Joins: maxli (maxli@13F2CEC5.7672369.D8E68FF6.IP)
[12:14:09] *** Quits: mibitzi (mibitzi@659DAD1F.60DF3A09.8395810B.IP) (Ping timeout)
[12:14:30] *** Joins: mibitzi (mibitzi@659DAD1F.60DF3A09.8395810B.IP)
[12:15:02] *** Quits: lucian (lucian@6B2B4644.4304AE1E.CE5E78F6.IP) (Input/output error)
[12:15:23] <dbaupp> rusti: match(1,2,3){(0,a,_)if a==3=>{false},(0,_,a)=>{true},_=>{fail!()}}
[12:15:24] -rusti- <anon>:5:51: 5:52 warning: unused variable: `a` [-W unused-variable (default)]
[12:15:24] -rusti- <anon>:5          match(1,2,3){(0,a,_)if a==3=>{false},(0,_,a)=>{true},_=>{fail!()}}
[12:15:24] -rusti-                                                             ^
[12:15:25] -rusti- task <unnamed> failed at 'explicit failure', <anon>:5
[12:15:25] -rusti- application terminated with error code 101
[12:15:34] <dbaupp> rusti: match(0,2,3){(0,a,_)if a==3=>{false},(0,_,_a)=>{true},_=>{fail!()}}
[12:15:35] -rusti- true
[12:16:38] <cmr> dbaupp: huh
[12:16:51] *** Joins: lucian (lucian@6B2B4644.4304AE1E.CE5E78F6.IP)
[12:16:58] *** Joins: victorporof (victorporo@DBFC8886.2203F6DA.D111398B.IP)
[12:17:01] <cmr> wait nevermind
[12:17:05] <cmr> I was reading that wrong
[12:17:14] <cmr> I thought the fail branch was being taken over the true branch
[12:17:19] <cmr> which would have made very little sense
[12:17:22] <cmr> but it wasn't :p
[12:17:31] <dbaupp> cmr: https://github.com/mozilla/rust/issues/8533
[12:17:39] <dbaupp> you're not the only one to read it wrong.
[12:17:58] <cmr> oh heh
[12:21:23] <dbaupp> it appears very long strings make emacs' rust-mode unhappy :(
[12:23:52] <cmr> Does anyone have an analog of managed pointers in any C API?
[12:24:03] <cmr> The only thing I can think of is CPython's ref counting
[12:25:47] <dbaupp> GObject?
[12:25:57] * dbaupp doesn't actually know anything about gobject
[12:26:01] <cmr> Does anyone actually know how GObject works? :p
[12:26:33] *** Joins: xmimx (Mibbit@3BF67B21.8C5C5E85.F298944D.IP)
[12:26:50] <dbaupp> I only know about it because people in #rust have mentioned it. :P
[12:26:55] <cmr> it's as good an example as any I guess
[12:29:28] *** Quits: reyre (reyre@moz-9002CDDA.cpe.net.cable.rogers.com) (Client exited)
[12:30:24] *** Joins: mibitzi_ (mibitzi@659DAD1F.60DF3A09.8395810B.IP)
[12:30:40] *** Quits: mibitzi (mibitzi@659DAD1F.60DF3A09.8395810B.IP) (Ping timeout)
[12:31:33] *** Quits: xmimx (Mibbit@3BF67B21.8C5C5E85.F298944D.IP) (Quit: http://www.mibbit.com ajax IRC Client)
[12:33:31] *** Joins: bellows (Mibbit@D55F017.86983878.14ACABD5.IP)
[12:34:18] *** Joins: msingle (Thunderbir@moz-930E5D97.hr.hr.cox.net)
[12:36:13] *** Joins: jorendorff (jorendorff@moz-2F32ACA3.hsd1.tn.comcast.net)
[12:38:48] *** Joins: mblbruce (Mibbit@moz-AC536087.se.axis.com)
[12:39:44] <mblbruce> Saw someone mentioning GObject and was unsure about ref counting, so I thought I'd weigh in. Yes, they're manually ref counted.
[12:40:14] <cmr> mblbruce: I more meant the implementation, I know the API
[12:40:19] <cmr> thanks though!
[12:40:45] <cmr> (I'm writing a tutorial on Rust's memory management)
[12:41:12] *** Quits: bellows (Mibbit@D55F017.86983878.14ACABD5.IP) (Quit: http://www.mibbit.com ajax IRC Client)
[12:41:24] <mblbruce> Ah... Don't know what it looks like on the inside, I'm afraid. I've just used them a bit, though I probably won't in the future.
[12:43:50] <dbaupp> heh, we still have staticants
[12:44:05] <cmr> whats?
[12:44:42] <dbaupp> https://github.com/mozilla/rust/blob/master/src/libstd/num/f32.rs#L127-L128
[12:44:59] <dbaupp> sed -i s/const/static/ gone wrong
[12:45:06] <cmr> Ohhhhhh
[12:45:07] *** Joins: lmandel (lmandel@moz-57D3C086.dsl.bell.ca)
[12:45:09] <cmr> hahah
[12:45:21] <cmr> I was going to say, "I have never heard this term in my life"
[12:45:22] <mblbruce> cmr: What about the implementation are you wondering about? I think it's just a counter that gets inced/deced on _ref()/_unref() calls and freed when it reaches 0. Sometimes refs are taken a little bit magically when GObjects are linked together, like when using GVariant, but it's mostly the user doing the ref management.
[12:45:56] <cmr> mblbruce: I'm mostly interested in how it has weakrefs
[12:45:59] *** Joins: tiffany (kawaii@moz-EB8B0C08.dhcp.embarqhsd.net)
[12:46:02] <Ms2ger> dbaupp, I'm pretty sure all big projects end up with things like that :)
[12:46:31] <smvv> cmr: https://developer.gnome.org/gobject/unstable/gobject-memory.html#gobject-memory-refcount
[12:46:45] <smvv> they mention how they handle cycles as well
[12:47:26] <smvv> (by invoking a _run_dispose method which will destroy an object with its references)
[12:47:39] *** Quits: tiffany (kawaii@moz-EB8B0C08.dhcp.embarqhsd.net) (Ping timeout)
[12:47:49] <dbaupp> Ms2ger: it's part of their character
[12:48:48] <smvv> what does "gep" mean (e.g. in trans/)?
[12:48:57] <cmr> smvv: http://llvm.org/docs/GetElementPtr.html
[12:49:56] <cmr> Ah and gobject just nullifies the weak pointer
[12:49:58] *** Quits: dju (dju@moz-83BD5EC.dmz.me) (Quit: ZNC - http://znc.in)
[12:52:37] <maik> improved functional list https://gist.github.com/anonymous/6240601 I reimplement it with foldl now :D
[12:53:01] <cmr> maik: bench mark it and compare it to other implementations!
[12:53:22] <maik> cmr, oh it going to be so slow :D
[12:53:26] *** Quits: bytbox (s@moz-DC83764A.washdc.fios.verizon.net) (Ping timeout)
[12:53:30] <maik> *it's
[12:53:33] <Ms2ger> It's all O(n) algorithms ;)
[12:53:50] <maik> yeah but its copying all over the place
[12:53:59] <maik> and some recursion
[12:58:51] *** Joins: Florob (Florob@moz-39532932.de)
[12:59:10] <smvv> what was the name of the lockfree deque? chave-lev or something. google does recognise my attempt to discover the name :(
[12:59:28] <cmr> chase-lev deque
[12:59:43] <cmr> http://citeseerx.ist.psu.edu/viewdoc/download?doi=10.1.1.170.1097&rep=rep1&type=pdf
[13:00:14] <FDS> ouch :  error: internal compiler error: debuginfo: FunctionDebugContext should be initialized but is not!
[13:00:26] <ChrisMorgan> FDS: with -Z debug-info? Filed that earlier today.
[13:00:33] <FDS> yep
[13:00:34] <ChrisMorgan> https://github.com/mozilla/rust/issues/8513
[13:00:35] <doublec> maik: why do you clone the car of the cons cell when traversing th elist?
[13:00:50] *** Quits: bjz (brendanzab@moz-38D46E1C.perm.iinet.net.au) (Quit: Leaving...)
[13:01:26] <doublec> maik: eg, the 'clone' in Cons(ref x,~Empty) => Cons(x.clone(),~List::singleton(elem)),
[13:02:01] *** Joins: bjz (brendanzab@moz-38D46E1C.perm.iinet.net.au)
[13:02:02] <FDS> ChrisMorgan : ok, thx for the link
[13:07:14] *** Joins: bytbox (s@moz-DC83764A.washdc.fios.verizon.net)
[13:08:08] <smvv> is a chase-lev deque also useable for multiple writers, single reader? i've a situation where multiple rust tasks can send output to a queue, while a single rust task reads from the queue
[13:08:45] <cmr> smvv: that's not really what they're designed for afaik
[13:09:03] *** Quits: bjz (brendanzab@moz-38D46E1C.perm.iinet.net.au) (Quit: Leaving...)
[13:10:14] <maik> doublec, because it doesn't let me move. it would invalidate the old list
[13:10:32] <dbaupp> http://static.rust-lang.org/doc/std/rand.html#function-weak_rng
[13:10:40] <dbaupp> "It returns the fatest Rng algorithm currently available"
[13:10:43] * dbaupp fixes that
[13:10:51] <cmr> Yeah I commented on that in the PR iirc
[13:11:04] <cmr> "That isn't true; the fastest rng would be `fn next() -> u32 { 4 }`
[13:14:14] <dbaupp> "currently available"
[13:14:40] * cmr adds XkcdRng
[13:15:30] <ChrisMorgan> cmr: gotta have the appropriate comment if returning 4.
[13:18:48] *** Joins: io2 (io2@moz-A6202C16.home.otenet.gr)
[13:20:23] <doublec> maik: what's the difference between what you have in 'push' and http://pastebin.mozilla.org/2861379
[13:20:39] <doublec> maik: does it make a difference in terms of copies, etc?
[13:24:36] <doublec> hmm, I guess passing 'self' makes it copy self by value on invocation
[13:25:38] <ChrisMorgan> Any handy fn on an iterator to consume it all, or should I just do `for _ in iter { }`?
[13:25:54] <Florob> consume()?
[13:26:48] <cmr> ChrisMorgan: I think one would be very handy
[13:26:55] <cmr> but there isn't one that I know of
[13:27:32] <maik> doublec, lets say you have let a = [1,2,3]; a.push(4)
[13:27:37] <ChrisMorgan> When I was working on my oh-so-conveniently-portable Android/Ubuntu tablet with no Rust, I just wrote iter.consume(), but when I checked, it wasn't there :-(
[13:28:31] <maik> doublec, when you don't copy, rust will move the value from a. Rust doesn't copy from itself. So when do you a.push(x) a will be destroyed
[13:29:05] <maik> doublec, you can do it
[13:29:36] <maik> doublec, but then you would probably call it .consume_push() or sth
[13:29:45] * ChrisMorgan seems to be running into ICEs quite frequently when adding large chunks of code to rust-http
[13:30:22] <maik> doublec, but always take my answers with a grain of salt :)
[13:31:41] *** Quits: mibitzi_ (mibitzi@659DAD1F.60DF3A09.8395810B.IP) (Ping timeout)
[13:31:42] *** Joins: mibitzi_ (mibitzi@659DAD1F.60DF3A09.8395810B.IP)
[13:32:01] <doublec> maik: thanks. I'm still new to this copy/move stuff so I'll do some more reading and experimenting.
[13:32:34] <doublec> is there a compiler output or useful debugging to show where copies are done implicitly?
[13:32:57] <cmr> doublec: unfortunately not
[13:33:11] *** Joins: saml (sam@moz-14C16814.cst.lightpath.net)
[13:33:15] <ChrisMorgan> task <unnamed> failed at 'ty_self not found in substs', /home/chris/vc/rust/src/libstd/option.rs:342
[13:33:23] <dbaupp> (note that a move is still a memcmp under the hood, if that's what you're worried about)
[13:34:07] <maik> doublec, it only copies implicit in a few cases like int
[13:34:16] <ChrisMorgan> I suspect this may be to do with the implementation of a static trait method on a generic type.
[13:35:41] *** Quits: TD-Linux (TD-Linux@E338EB99.2B4F0AE0.A0A36CCE.IP) (Ping timeout)
[13:36:15] *** Joins: reyre (reyre@B2D8AB09.33EE9F8A.1139E686.IP)
[13:37:21] <ChrisMorgan> I hope I can figure this out... because this new header reading that I got sorted out is actually of a quite tolerable design, at last. (Though it gets rather a lot of duplication in its enum handling.)
[13:39:09] *** Quits: mblbruce (Mibbit@moz-AC536087.se.axis.com) (Quit: http://www.mibbit.com ajax IRC Client)
[13:39:34] *** Joins: TD-Linux (TD-Linux@E338EB99.2B4F0AE0.A0A36CCE.IP)
[13:43:42] *** Joins: bjz (brendanzab@B398BE78.F804C29E.D35A31DF.IP)
[13:44:55] <bjz> cmr: ping
[13:45:00] <cmr> bjz: pong
[13:45:37] <bjz> cmr: do you know much about how the command aliases and extensions and such work with opengl?
[13:45:45] <cmr> bjz: I do not
[13:45:55] <bjz> :P
[13:46:16] <bjz> np
[13:46:59] *** kimundi is now known as zz_kimundi
[13:47:25] <ChrisMorgan> I dunno where I've found all this patience for working with Rust when it's so buggy. I think it must be that I see *so* much potential for the language. I'm already thinking that for an AI assignment in the next couple of weeks I'll write it in Rust first before porting it to C, C++ or Java as required for submission... last semester I would have been doing that in Python if at all.
[13:48:06] <dbaupp> the bugs are the best bit! :P
[13:48:47] <maik> ChrisMorgan, I always encounter ICE if I compiled Rust the the newest master and forgot to recompile my other Rust libs
[13:49:19] <ChrisMorgan> dbaupp: I do get to feel appreciated :-)
[13:51:12] <maik> dbaupp, you are an haskeller right? :) do you know if (++) is implemented with fold?
[13:51:31] <dbaupp> maik: pretty sure it's not
[13:51:56] <dbaupp> maik: (at least, not directly; there's probably some magic in GHC that uses fold to make it optimise better.)
[13:52:10] <dbaupp> ChrisMorgan: and you get to fix them
[13:52:36] <ChrisMorgan> dbaupp: I haven't had the courage to try that yet. Just isolating them.
[13:52:36] <dbaupp> maik: http://hackage.haskell.org/packages/archive/base/latest/doc/html/src/GHC-Base.html#%2B%2B
[13:52:42] <ChrisMorgan> And working around them sometimes.
[13:52:51] *** Quits: noam (noam@F6B530A7.720527A7.416762B.IP) (Connection reset by peer)
[13:52:54] *** Quits: msingle (Thunderbir@moz-930E5D97.hr.hr.cox.net) (Connection reset by peer)
[13:52:56] *** Joins: msingle (Thunderbir@moz-930E5D97.hr.hr.cox.net)
[13:53:08] *** Joins: ghrust (ghrust@1E8607E8.6A2AE50.F3114085.IP)
[13:53:08] <ghrust> 01[13rust01] 15bors merged 06auto into 06master: 02http://git.io/gPkxbg
[13:53:08] *** Parts: ghrust (ghrust@1E8607E8.6A2AE50.F3114085.IP) ()
[13:53:12] <ChrisMorgan> The only work I've done in the compiler is my augmented-assignment branch which is probably stale by now :-(
[13:53:27] <dbaupp> ChrisMorgan: that wasn't a choice. any bug you find, you're obliged to fix. (after all, it's you who broke the compiler.)
[13:53:28] <dbaupp> :P
[13:53:29] *** Joins: noam (noam@F6B530A7.720527A7.416762B.IP)
[13:53:47] *** Joins: erickt1 (Adium@49C4075F.3AC15C18.2321E71E.IP)
[13:54:04] <dbaupp> everything goes stale super-quick :( (`git rebase` is rusties favourite command.)
[13:54:09] *** Quits: fabiand (fabiand@moz-E71B3C66.adsl.alicedsl.de) (Ping timeout)
[13:54:21] <maik> :D
[13:55:12] <Florob> rusti: let a = "Ã¶Ã¤Ã¼"; a
[13:55:14] -rusti- "\xf6\xe4\xfc"
[13:55:33] <ChrisMorgan> :-( My first guess at the ICE failed.
[13:55:47] <nmatsakis> acrichto: afaik objects are working now, so i'd appreciate any pointers to further bugs
[13:55:59] <nmatsakis> acrichto: though I confess I haven't done a thorough search of the issue tracker
[13:56:06] *** Joins: fabiand (fabiand@moz-E71B3C66.adsl.alicedsl.de)
[13:56:07] *** Joins: ghrust (ghrust@9C8B94D4.6A2AE50.F3114085.IP)
[13:56:08] <ghrust> 01[13rust01] 15bors pushed 0 new commits to 06auto: 02http://git.io/vlIjlg
[13:56:08] *** Parts: ghrust (ghrust@9C8B94D4.6A2AE50.F3114085.IP) ()
[13:56:08] *** Joins: ghrust (ghrust@9C8B94D4.6A2AE50.F3114085.IP)
[13:56:08] <ghrust> 01[13rust01] 15bors pushed 2 new commits to 06auto: 02http://git.io/GGq2qQ
[13:56:08] <ghrust> 13rust/06auto 1411b3d76 15Robert Knight: Add RngUtils::sample() method for reservoir sampling from iterators
[13:56:08] <ghrust> 13rust/06auto 14435020e 15bors: auto merge of #8491 : robertknight/rust/7722-reservoir_sampling, r=graydon...
[13:56:09] *** Parts: ghrust (ghrust@9C8B94D4.6A2AE50.F3114085.IP) ()
[13:56:39] <dbaupp> nmatsakis: is there any particular reason that trait objects of traits that don't mention Self can't impl themselves automatically?
[13:56:55] <dbaupp> (other than all the extra code required.)
[13:57:24] <nmatsakis> dbaupp: that is not a sufficient criterion
[13:57:36] <nmatsakis> however, it is certainly possible to imagine thta we could define sufficient criteria
[13:58:09] <nmatsakis> for example, generic methods don't work with objects, regardless of how you use `Self`
[13:58:19] <nmatsakis> (same reason you can't have a virtual template method in C++)
[13:58:24] <nmatsakis> (you can't monomorphize it statically)
[13:58:34] <nmatsakis> also, &self, @self, etc interact in complicated ways
[13:58:54] <dbaupp> "generic method"? i.e. impl { ... fn foo<T: Bar>(&self, x: T) ... }
[13:58:55] <dbaupp> ?
[13:59:00] <nmatsakis> right
[13:59:13] <ChrisMorgan> With my ICE, this error message "ty_self not found in substs" comes from src/librustc/middle/subst.rs:61. Any idea what code could have caused it?
[13:59:32] <nmatsakis> ChrisMorgan: might be that you are using the `Self` type parameter outside of a trait def'n
[13:59:55] <dbaupp> nmatsakis: I see; thanks for the answer, I suspected that it must've been more complicated than just Self. :)
[14:00:22] <ChrisMorgan> nmatsakis: no, the three occurrences of Self in my code base are all inside a trait block.
[14:00:34] *** Joins: Sodel_the_V (user@moz-853663E1.va.shawcable.net)
[14:01:03] <nmatsakis> ChrisMorgan: ok -- how big is the code? if you can gist it, I could take a look
[14:01:35] <ChrisMorgan> nmatsakis: it's rust-http. Thus fairly big.
[14:01:54] <dbaupp> ChrisMorgan: is the diff that introduced the ICE big?
[14:02:16] <ChrisMorgan> dbaupp: it does end up rather large.
[14:02:25] *** Quits: aatch (aatch@moz-B437F499.pocketrent.com) (Ping timeout)
[14:02:31] * ChrisMorgan wasn't committing frequently at that point, silly /me
[14:03:06] *** Quits: Sodel_the_V (user@moz-853663E1.va.shawcable.net) (Quit: Eaten by a grue)
[14:03:31] <ChrisMorgan> But my suspicion is that it's the way https://github.com/chris-morgan/rust-http/blob/master/src/libhttp/headers/mod.rs#L101 is called from https://github.com/chris-morgan/rust-http/blob/master/src/libhttp/server/request.rs#L116
[14:04:30] <dbaupp> ChrisMorgan: can you replace the Option<Self> with e.g. `()` and see if that still dies?
[14:04:46] <nmatsakis> ChrisMorgan: ChrisMorgan that seems... quite possible.
[14:04:58] <ChrisMorgan> dbaupp: no compile, of course, but no ICE.
[14:05:03] <nmatsakis> ChrisMorgan: also, are you sure that this code will type check? it looks...wrong-ish
[14:05:50] <cmr> I find most ICEs noadays are usually a legitimate error that wasn't handled properly, than something which never should have been an error
[14:05:51] <nmatsakis> oh, I take that back
[14:05:52] <ChrisMorgan> nmatsakis: I think it's right.
[14:06:10] <nmatsakis> it does seem likely that this is a bug with default methods
[14:06:12] <cmr> ... at least the ones I get
[14:06:17] <nmatsakis> but I don't know
[14:06:24] <cmr> sully to the rescue!
[14:06:29] <nmatsakis> ChrisMorgan: can you run with -Z time-passes and tell me in which pass the error occurs?
[14:06:40] *** Quits: mibitzi_ (mibitzi@659DAD1F.60DF3A09.8395810B.IP) (Ping timeout)
[14:06:58] <ChrisMorgan> coherence checking
[14:07:01] *** Joins: mibitzi_ (mibitzi@659DAD1F.60DF3A09.8395810B.IP)
[14:07:03] <maik> what is the convention for type naming? like <T>
[14:07:19] <maik> what follows after T?
[14:07:23] <cmr> U
[14:07:34] <ChrisMorgan> Sometimes U, sometimes different letters work better.
[14:07:42] <cmr> Iterators frequently use A
[14:07:45] <ChrisMorgan> e.g. if you had a Reader and a Writer, I'd be doing R and W.
[14:07:54] <cmr> Key/Value are used in Map
[14:07:56] *** Joins: aatch (aatch@moz-B437F499.pocketrent.com)
[14:07:59] <cmr> sometimes K and V
[14:08:17] <cmr> maik: usually you give it a name if it's useful to give it a name
[14:08:33] <cmr> a real name, not T/U :p
[14:08:42] <ChrisMorgan> I tend to prefer single-letter names where it can still be meaningful. Clearer then that it's a generic.
[14:08:47] <ChrisMorgan> Thus, K and V rather than Key and Value.
[14:09:23] <ChrisMorgan> (I'm guilty of using T quite a lot in my latest changes in rust-http. I had S earlier when dealing with Stream, but then I changed them to using Reader and Writer and didn't change them to R and W, but both to T.)
[14:13:30] <maik> cmr, :D
[14:13:45] <maik> ok
[14:14:08] <maik> if you have fold from f(U,T)->U
[14:14:32] <maik> I think T and U are okay 
[14:15:25] <nmatsakis> ChrisMorgan: coherence eh? then yes, I'm pretty sure it's the default method, might have some idea what's wrong... gimme a sec...
[14:15:31] <ChrisMorgan> :-)
[14:17:14] *** Joins: Axord (xord@moz-1B228827.lsanca.dsl-w.verizon.net)
[14:17:23] <maik> okay http://www.reddit.com/r/rust/comments/1kf3n9/functional_list_in_rust/
[14:17:36] <maik> now I can benchmark it :p
[14:17:57] <dbaupp> maik: yes, for parameters that have no inherent meaning (i.e. pure generics), single letters are perfect
[14:20:41] *** Joins: infynyxx (infynyxx@moz-E95B370B.nyc.res.rr.com)
[14:21:24] <nmatsakis> ChrisMorgan: hmm I could be wrong, certainly simple attempts to pare it down haven't worked -- could you (1) run in gdb and get a stack trace for the ICE (break on upcall_fail) and (2) run with RUST_LOG=rustc::middle::typeck::coherence and gist the output? For the latter, you might have to rebuild with --enable-debug 
[14:21:33] <nmatsakis> ChrisMorgan: or I suppose I could clone your repo
[14:22:04] *** Quits: maxli (maxli@13F2CEC5.7672369.D8E68FF6.IP) (Ping timeout)
[14:23:20] *** Quits: Florob (Florob@moz-39532932.de) (Client exited)
[14:23:51] <cmr> What are the goals of rust's mutability rules? In particular I can't quite see what not being able to have multiple mutable loans wins you
[14:24:02] *** Quits: nano (nano@moz-74CAD1CA.superkabel.de) (Connection reset by peer)
[14:24:42] <dbaupp> cmr: memory safety
[14:25:19] <cmr> dbaupp: in which aspect? I don't see it improving memory safety over the ownership and lifetime semantics, but I'm probably missing something
[14:25:41] <nmatsakis> cmr: we often need to be able to guarantee that memory won't change,
[14:25:46] <nmatsakis> if we didn't have that rule for &mut,
[14:25:59] <nmatsakis> we would never be able to guarantee that an &mut wouldn't be modified by some assignment,
[14:26:01] *** Quits: ysuzuki (ysuzuki@moz-FEE44B6.net220148245.t-com.ne.jp) (Quit: Tiarra 0.1+svn-39209: SIGINT received; exit)
[14:26:11] <nmatsakis> and thus we would have to be much more restrictive about creating pointers into data referenced by an &mut
[14:26:15] <nmatsakis> this is how the old rules used to be
[14:26:16] <dbaupp> cmr: `fn foo(x: &mut ~[Foo], y: &mut Foo) { x.pop(); y.baz() } foo(&mut vec, &mut vec[vec.len() - 1])`
[14:27:07] <nmatsakis> cmr: for example, imagine you had something like &mut [T], and you want to do "&v[3]"
[14:27:13] <ChrisMorgan> dbaupp: OK, that demonstrates that you can't do it for something contained _in_ something else, but what about two copies of &mut vec? That's safe, surely?
[14:27:26] <nmatsakis> cmr: or rather &mut ~[T]
[14:27:38] <nmatsakis> ah, I guess what dbaupp said :)
[14:27:53] <cmr> rusti: fn foo(x: &mut ~[Foo], y: &mut Foo) { x.pop(); y.baz() } let vec = ~[1, 2, 3, 4]; foo(&mut vec, &mut vec[vec.len() - 1]);
[14:27:58] -rusti- pastebinned 8 lines of output: http://ix.io/7jf
[14:28:07] <cmr> heh
[14:28:09] <dbaupp> ChrisMorgan: I guess you could conjure up situations where it's memory unsafe, I can't off the top of my head though.
[14:28:15] <cmr> rusti: fn foo(x: &mut ~[int], y: &mut int) { x.pop(); y.baz() } let vec = ~[1, 2, 3, 4]; foo(&mut vec, &mut vec[vec.len() - 1]);
[14:28:16] -rusti- <anon>:5:56: 5:65 error: type `&mut int` does not implement any method in scope named `baz`
[14:28:16] -rusti- <anon>:5          fn foo(x: &mut ~[int], y: &mut int) { x.pop(); y.baz() } let vec = ~[1, 2, 3, 4]; foo(&mut vec, &mut vec[vec.len() - 1]);
[14:28:16] -rusti-                                                                  ^~~~~~~~~
[14:28:16] -rusti- error: aborting due to previous error
[14:28:17] -rusti- application terminated with error code 101
[14:28:22] <cmr> bah
[14:28:23] <nmatsakis> ChrisMorgan: two copies of  &mut vec is not safe
[14:28:25] <cmr> I get the point though
[14:28:37] <dbaupp> but, having &mut not alias makes certain optimisations magically easy.
[14:28:40] <maik> is this considered to be pure code? https://gist.github.com/anonymous/6241133
[14:28:40] <nmatsakis> ChrisMorgan: imagine x and y both have type &mut ~[T]
[14:28:53] <nmatsakis> ChrisMorgan: and in fact they are the same vector (x === y)
[14:28:58] *** Joins: cubic (cubic@moz-FE5AD6C7.mc.videotron.ca)
[14:28:58] *** Joins: ysuzuki (ysuzuki@moz-FEE44B6.net220148245.t-com.ne.jp)
[14:29:04] <maik> should be right? because I don't see any side effects
[14:29:06] <nmatsakis> ChrisMorgan: then I could do "let z = &x[0]; y.push()"
[14:29:16] <nmatsakis> ChrisMorgan: the push to y might invalidate `z`
[14:29:31] <nmatsakis> maik: I'm not sure what you mean by pure
[14:29:34] *** Joins: maxli (maxli@13F2CEC5.7672369.D8E68FF6.IP)
[14:29:37] *** Quits: wilsonk-laptop (kvirc@moz-8E86F35A.cg.shawcable.net) (Connection reset by peer)
[14:29:39] <cmr> nmatsakis: but that's for the case of having both a mutable and immutable loan at once
[14:29:41] <nmatsakis> maik: we used to have a formal notion of purity in Rust, but it's long gone
[14:29:41] *** Joins: Scriptor (historium@moz-E06F46F0.corp.bitshelter.com)
[14:29:47] <nmatsakis> cmr: no, it doesn't matter.
[14:29:54] <cmr> oh yeah
[14:29:55] <nmatsakis> cmr: same is true of &mut x[0]; y.push
[14:29:56] <cmr> you're right
[14:30:00] <cmr> it could be a &mut just the same
[14:30:18] <nmatsakis> cmr: it's a problem whenever you create a pointer into memory that you find by dereferencing a ~ pointer or inside of an enum
[14:30:19] *** Quits: [o__o] (~o__o@moz-24EBFAC7.me) (Ping timeout)
[14:30:27] *** Quits: ysuzuki (ysuzuki@moz-FEE44B6.net220148245.t-com.ne.jp) (Quit: Tiarra 0.1+svn-39209: SIGINT received; exit)
[14:30:29] <nmatsakis> which we do an awful lot :)
[14:30:41] *** Quits: fzzzy (fzzzy@A5CBE5CF.A81CC6E.44FA8ED.IP) (Ping timeout)
[14:30:41] *** Joins: ysuzuki (ysuzuki@moz-FEE44B6.net220148245.t-com.ne.jp)
[14:30:47] <nmatsakis> all that said, I think it might be useful to add &alias mut
[14:31:01] <dbaupp> maik: that looks "pure"
[14:31:08] <nmatsakis> ..maybe we should reserve the `alias` keyword...
[14:31:16] <nmatsakis> but I haven't really had a need for it yet
[14:31:27] *** Joins: wilsonk-laptop (kvirc@moz-8E86F35A.cg.shawcable.net)
[14:31:39] *** Joins: [o__o] (~o__o@moz-24EBFAC7.me)
[14:31:48] <dbaupp> nmatsakis: presumably all mutable references would need to be &alias mut, so that &mut still has the same non-alias semantics?
[14:31:59] <dbaupp> (and presumably it'd be unsafe?)
[14:32:00] <nmatsakis> maik: it looks pure, but if I were really going to implement functional data structures in Rust, I'd use @ pointers
[14:32:34] <nmatsakis> dbaupp: I'd keep &mut the same, &alias mut would be just another kind of reference, and it would be safe, there would just be limits on what one can do with an &alias mut. It'd basically only be useful for pointing at scalars
[14:32:35] <dbaupp> maik: also, for map and foldl, the function should take &T, and you shouldn't .clone()
[14:32:51] *** Joins: azita (Azita@moz-C1FB2A8.hsd1.ca.comcast.net)
[14:33:03] *** Quits: ysuzuki (ysuzuki@moz-FEE44B6.net220148245.t-com.ne.jp) (Quit: Tiarra 0.1+svn-39209: SIGINT received; exit)
[14:33:12] <dbaupp> nmatsakis: aha, sounds good (although i haven't had a place where I required it either)
[14:33:15] *** Joins: bananapeel (user@E7E2A35D.6F99A8B0.2AADDDA7.IP)
[14:33:18] <nmatsakis> dbaupp: it's probably not worth the "cognitive load", as I think you can achieve the same effect in a lot of other ways.
[14:33:28] <maik> dbaupp, okay thanks
[14:33:39] <dbaupp> maik: the closure can call .clone() itself if it needs a "full" `T`
[14:34:06] <maik> dbaupp, ah right
[14:34:14] *** Joins: ysuzuki (ysuzuki@moz-FEE44B6.net220148245.t-com.ne.jp)
[14:34:29] *** Joins: fzzzy (fzzzy@A5CBE5CF.A81CC6E.44FA8ED.IP)
[14:34:36] <ChrisMorgan> nmatsakis: have you been able to figure out my Self ICE?
[14:34:46] <dbaupp> maik: (also, as nmatsakis said, you should use @, because currently every operation clones the whole list, even prepend, which should be O(1))
[14:34:58] *** Quits: ysuzuki (ysuzuki@moz-FEE44B6.net220148245.t-com.ne.jp) (Quit: Tiarra 0.1+svn-39209: SIGINT received; exit)
[14:36:02] <nmatsakis> ChrisMorgan: I haven't tried any further, sorry. I guess I will clone your repo, sec
[14:36:22] <ChrisMorgan> Should be pretty easyâ€”clone and make.
[14:36:24] *** Quits: jaen (jaen@moz-E0979827.copit.pl) (Ping timeout)
[14:36:44] *** Quits: goffrie (goffrie@moz-81CAF92F.dsl.ncf.ca) (Ping timeout)
[14:36:44] *** Joins: ysuzuki (ysuzuki@moz-FEE44B6.net220148245.t-com.ne.jp)
[14:37:03] *** Quits: ysuzuki (ysuzuki@moz-FEE44B6.net220148245.t-com.ne.jp) (Quit: Tiarra 0.1+svn-39209: SIGINT received; exit)
[14:37:15] *** Joins: ysuzuki (ysuzuki@moz-FEE44B6.net220148245.t-com.ne.jp)
[14:37:23] *** Quits: ysuzuki (ysuzuki@moz-FEE44B6.net220148245.t-com.ne.jp) (Quit: ysuzuki)
[14:38:01] *** Joins: tautologico (lymph@8ABDEDA.34CAB63A.7B974E06.IP)
[14:38:42] *** Joins: ysuzuki (ysuzuki@moz-FEE44B6.net220148245.t-com.ne.jp)
[14:38:57] <nmatsakis> ChrisMorgan: apparently my version of rustc is not up to date enough to build your code, or maybe too up to date :)
[14:39:12] *** Quits: ysuzuki (ysuzuki@moz-FEE44B6.net220148245.t-com.ne.jp) (Quit: Tiarra 0.1+svn-39209: SIGINT received; exit)
[14:39:14] <nmatsakis> let me fetch latest
[14:39:18] <ChrisMorgan> nmatsakis: my build is from around thirteen hours ago.
[14:40:45] *** Joins: ysuzuki (ysuzuki@moz-FEE44B6.net220148245.t-com.ne.jp)
[14:41:10] *** Joins: goffrie (goffrie@moz-AA92FD24.dsl.ncf.ca)
[14:42:21] *** Quits: BizarreCake (BizarreCak@moz-361FE9B2.dynamic.barak-online.net) (Connection reset by peer)
[14:44:54] *** Joins: ofeldt (ofeldt@moz-881FBB49.dip0.t-ipconnect.de)
[14:45:42] *** Quits: azita (Azita@moz-C1FB2A8.hsd1.ca.comcast.net) (Quit: azita)
[14:45:56] *** Quits: ofeldt- (ofeldt@moz-91DA54E2.dip0.t-ipconnect.de) (Ping timeout)
[14:47:25] <erickt1> cmr: ping
[14:49:24] *** Quits: mibitzi_ (mibitzi@659DAD1F.60DF3A09.8395810B.IP) (Ping timeout)
[14:49:44] *** Joins: mibitzi_ (mibitzi@659DAD1F.60DF3A09.8395810B.IP)
[14:50:36] <cmr> erickt1: pong
[14:51:17] <erickt1> cmr: just wanted to let you know I finally updated my openssl libcrypto bindings to rust HEAD: https://github.com/erickt/rustcrypto
[14:51:23] <erickt1> for TWiR
[14:51:27] <cmr> erickt1: cool, thanks!
[14:51:48] <erickt1> I just just found a couple forks that I missed that I'm going to have to rectify
[14:53:14] *** Joins: dherman (dherman@moz-6CA476B1.hsd1.ca.comcast.net)
[14:53:14] *** ChanServ sets mode: +o dherman
[14:56:13] *** zz_kimundi is now known as kimundi
[14:56:17] *** Quits: mibitzi_ (mibitzi@659DAD1F.60DF3A09.8395810B.IP) (Ping timeout)
[14:56:35] *** Joins: mibitzi_ (mibitzi@659DAD1F.60DF3A09.8395810B.IP)
[14:59:16] *** Quits: bananapeel (user@E7E2A35D.6F99A8B0.2AADDDA7.IP) (Client exited)
[14:59:31] *** Quits: wilmoore (wilmoore@moz-71431C3A.hsd1.co.comcast.net) (Client exited)
[15:00:40] *** Joins: Jesin (Jessin_@moz-157A63DD.cc.lehigh.edu)
[15:00:47] *** Quits: ssbr (ssbr@moz-141F89C6.block0.gvtc.com) (Ping timeout)
[15:01:00] *** Joins: ssbr (ssbr@moz-141F89C6.block0.gvtc.com)
[15:02:08] *** Quits: TD-Linux (TD-Linux@E338EB99.2B4F0AE0.A0A36CCE.IP) (Ping timeout)
[15:05:43] *** Quits: StarLight (StarLight@moz-71A9D610.dynamic.avangarddsl.ru) (Client exited)
[15:06:01] *** Joins: MrFahrenheit (RageOfThou@3FEF494C.29C984D5.783DEDCA.IP)
[15:06:13] *** Joins: TD-Linux (TD-Linux@E338EB99.2B4F0AE0.A0A36CCE.IP)
[15:06:55] *** Joins: StarLight (StarLight@moz-71A9D610.dynamic.avangarddsl.ru)
[15:10:18] *** Joins: mrordinaire (Mibbit@1A659656.A607747.FD383126.IP)
[15:10:50] <maik> dbaupp, hm, can't i just add consume methods? like .consume_push?
[15:14:17] *** Quits: mibitzi_ (mibitzi@659DAD1F.60DF3A09.8395810B.IP) (Ping timeout)
[15:14:36] *** Joins: mibitzi_ (mibitzi@659DAD1F.60DF3A09.8395810B.IP)
[15:15:09] *** Joins: BizarreCake (BizarreCak@moz-361FE9B2.dynamic.barak-online.net)
[15:20:15] *** Quits: mrordinaire (Mibbit@1A659656.A607747.FD383126.IP) (Quit: http://www.mibbit.com ajax IRC Client)
[15:20:27] <maik> how can I implement  iter() on my own types?
[15:21:04] *** Joins: dju (dju@moz-83BD5EC.dmz.me)
[15:21:23] <nmatsakis> bjz: https://github.com/mozilla/rust/pull/8535
[15:21:46] <ion> Iâ€™m trying to build with ./configure --target-triples=x86_64-unknown-linux-gnu,arm-unknown-linux-gnueabihf, it fails with â€œâ€¦/arm-linux-gnueabihf/bin/ld: error: â€¦/libstd-6c65cf4b443341b1-0.8-pre.so uses VFP register arguments, â€¦/lib/std.o does notâ€. The compilation succeeds with non-hf gnueabi. Full log: http://heh.fi/tmp/rust-compile.log.html
[15:22:50] <maik> nmatsakis, oh is this for external function pointer?
[15:22:56] <nmatsakis> maik: yes.
[15:23:04] *** Quits: KindOne (KindOne@moz-CE7A3C24.dynamic.ip.windstream.net) (Ping timeout)
[15:23:10] <maik> nmatsakis, <3
[15:24:40] *** kimundi is now known as zz_kimundi
[15:25:55] *** Quits: erickt1 (Adium@49C4075F.3AC15C18.2321E71E.IP) (Quit: Leaving.)
[15:27:05] <ChrisMorgan> nmatsakis: in that PR, in src/libextra/extra.rs, was changing #[deny(missing_doc)] to #[denyg(missing_doc)] deliberate?
[15:27:23] <maik> why is the type next in Iterators mutable? fn next(&mut self) -> Option<T> 
[15:27:46] <nmatsakis> ChrisMorgan: uh...no.
[15:27:50] <ChrisMorgan> maik: most iterators will need to modify their own state
[15:28:06] <maik> shouldn't there be two next's? one that is mutable and one that isn't?
[15:28:10] <nmatsakis> ChrisMorgan: it probably did shut up a bunch of errors though :)
[15:28:48] <ChrisMorgan> BTW, when I was running rustc through GDB, `break upcall_fail` didn't do anything.
[15:28:52] <nmatsakis> ChrisMorgan: btw I am reproducing your ICE now
[15:29:50] <klutzy> maik: if you want to implement range(0, 10) iterator, you have to hold current index and next() will increment it
[15:30:19] *** Quits: doener (bs@moz-AA189A5A.unitymedia.biz) (Quit: leaving)
[15:30:30] <cmr> ChrisMorgan: it's rust_begin_unwind now aiui
[15:30:51] <cmr> maik: you cannot iterate without modifying the iterator
[15:30:55] <cmr> it's just.. not a thing you can do
[15:31:00] <cmr> the whole purpose of next is to advance the state
[15:31:19] <ChrisMorgan> Unless you want an infinite iterator.
[15:31:27] <ChrisMorgan> cmr: I had a feeling it had changed, thanks.
[15:31:30] <cmr> over a single item
[15:32:05] <ChrisMorgan> So, ::rt::backtrace doesn't work with new RT. Is there an equivalent, or must one now resort to gdb with `break rust_begin_unwind`?
[15:32:33] <cmr> ChrisMorgan: no equivalent
[15:32:38] <Ms2ger> cmr, or with random output, or something even sillier :)
[15:33:02] <ChrisMorgan> Ms2ger: and your RNG doesn't have state?
[15:33:33] <ChrisMorgan> We're back to fn next() -> Option<int> { Some(4) }...
[15:33:36] <Ms2ger> ChrisMorgan, mm, create a new one each time? :)
[15:34:02] <ChrisMorgan> s/()/(\&mut self)/
[15:34:04] <maik> cmr, hm but then every type that we create has to be mutable too, even types that don't need to be mutable at all. That doesn't seem right
[15:34:15] <cmr> maik: what do you mean every type?
[15:34:17] <cmr> Only iterators
[15:34:21] <ChrisMorgan> (Vim regular expression, that, so () isn't magic. :P)
[15:34:32] <maik> cmr, sec have to test something :)
[15:34:53] <maik> cmr, ohhh, nvm
[15:35:23] <ChrisMorgan> nmatsakis: I need to go to bed now (or an hour or two ago). I look forward to hearing it's been identified and fixed ;-)
[15:35:52] <ChrisMorgan> I could file an issue myself, but I haven't managed to reduce the test case beyond "this comparatively large Rust code base".
[15:37:34] <ChrisMorgan> (Did I really just call a code base which is only now approaching 5,000 lines of code "comparatively large"?)
[15:38:33] <cmr> rustdoc_ng is only 2k lines
[15:38:38] <cmr> (not even lines of code, lines)
[15:38:50] <ion> Submitted the issue to https://github.com/mozilla/rust/issues/8536
[15:39:31] *** Joins: boredomist (user@moz-63CF9F31.res-cmts.sesp.ptd.net)
[15:39:56] *** Joins: wilmoore (wilmoore@moz-7EE4D9D6.mystrotv.com)
[15:40:29] <nmatsakis> ChrisMorgan: ok, I'll try to poke at it, just have a lot of stuff going on simultaneously
[15:40:33] <ChrisMorgan> My 5,000 lines of code is lines total. Haven't added Rust support to ohcount yet.
[15:40:42] <ChrisMorgan> nmatsakis: thanks :-)
[15:44:25] *** Quits: a__ (a__@moz-250D9B4.nycmny.fios.verizon.net) (Client exited)
[15:44:58] *** Quits: vosen (vosen@moz-266BA656.icpnet.pl) (Ping timeout)
[15:45:31] *** Joins: a__ (a__@moz-250D9B4.nycmny.fios.verizon.net)
[15:48:49] *** Quits: goffrie (goffrie@moz-AA92FD24.dsl.ncf.ca) (Ping timeout)
[15:49:45] *** Joins: mib_qsaud0 (Mibbit@moz-C2B79D43.pool.mediaways.net)
[15:51:28] <ChrisMorgan> nmatsakis: I have a workaround which shows convincingly the locality of the problem: shift HeaderEnum::from_stream<R: Reader>(...) -> (Option<Self>, ...) to a new function header_enum_from_stream<R: Reader, E: HeaderEnum>(...) -> (Option<E>, ...)
[15:51:38] *** Joins: goffrie (goffrie@moz-AA92FD24.dsl.ncf.ca)
[15:51:58] *** Joins: tiffany (kawaii@moz-EB8B0C08.dhcp.embarqhsd.net)
[15:52:35] *** Joins: ozten (ozten@19BD73A1.5D8BCA3A.A0C1B52F.IP)
[15:53:05] *** Joins: ghrust (ghrust@1E8607E8.6A2AE50.F3114085.IP)
[15:53:05] <ghrust> 01[13rust01] 15bors merged 06auto into 06master: 02http://git.io/GGq2qQ
[15:53:05] *** Parts: ghrust (ghrust@1E8607E8.6A2AE50.F3114085.IP) ()
[15:53:19] *** Joins: cubic_ (cubic@moz-FE5AD6C7.mc.videotron.ca)
[15:53:33] *** Quits: goffrie (goffrie@moz-AA92FD24.dsl.ncf.ca) (Ping timeout)
[15:53:38] *** Quits: cubic (cubic@moz-FE5AD6C7.mc.videotron.ca) (Ping timeout)
[15:54:16] <nmatsakis> ChrisMorgan: and that makes prob go away? I wanted to ask you that
[15:54:21] <ChrisMorgan> It does.
[15:54:25] <maik> is it possible to implement an Iterator for "enum List<T> {Empty,Cons(T, ~List<T>)}"?
[15:54:32] <ChrisMorgan> Then there are just other compile errors which need fixing.
[15:54:46] <Ms2ger> Seems plausible
[15:55:15] *** Joins: Florob (Florob@moz-39532932.de)
[15:56:07] *** Joins: ghrust (ghrust@2EE61FCC.6A2AE50.F3114085.IP)
[15:56:07] <ghrust> 01[13rust01] 15bors pushed 0 new commits to 06auto: 02http://git.io/9KbyOw
[15:56:07] *** Parts: ghrust (ghrust@2EE61FCC.6A2AE50.F3114085.IP) ()
[15:56:08] *** Joins: ghrust (ghrust@DE823A67.6A2AE50.F3114085.IP)
[15:56:08] <ghrust> 01[13rust01] 15bors pushed 3 new commits to 06auto: 02http://git.io/8plJ2g
[15:56:08] <ghrust> 13rust/06auto 1458be69c 15Erick Tryzelaar: Deny warnings in stage1+ libsyntax/librustc/librustdoc/librusti/librust
[15:56:08] <ghrust> 13rust/06auto 1417d1b24 15Erick Tryzelaar: Deny warnings in tests
[15:56:08] <ghrust> 13rust/06auto 143ae6e45 15bors: auto merge of #8441 : erickt/rust/deny-warnings, r=erickt...
[15:56:10] *** Parts: ghrust (ghrust@DE823A67.6A2AE50.F3114085.IP) ()
[15:56:57] *** Joins: goffrie (goffrie@moz-AA92FD24.dsl.ncf.ca)
[16:00:32] *** Joins: huseby (huseby@19BD73A1.5D8BCA3A.A0C1B52F.IP)
[16:02:59] <nmatsakis> maik: yes?
[16:03:03] <nmatsakis> maik: shouldn't be hard
[16:05:00] *** Quits: goffrie (goffrie@moz-AA92FD24.dsl.ncf.ca) (Ping timeout)
[16:05:16] *** Quits: FrozenCow (FrozenCow@moz-B2DF4929.chello.nl) (Ping timeout)
[16:05:17] *** Joins: bent (chatzilla@moz-BE33DA21.fw1.sfo1.mozilla.net)
[16:05:26] *** Quits: infynyxx (infynyxx@moz-E95B370B.nyc.res.rr.com) (Client exited)
[16:06:24] *** Joins: FrozenCow (FrozenCow@moz-B2DF4929.chello.nl)
[16:06:44] *** Joins: mihneadb (Mihnea@moz-BBE3ABD.mv.mozilla.com)
[16:07:30] *** Quits: erickt (etryzelaar@8C9ECD8F.3A598286.F12515B4.IP) (Ping timeout)
[16:07:34] <bjz> rusti: fn f() {} mod f { pub static X: bool = false; } (f(), f::X)
[16:07:35] -rusti- ((), false)
[16:07:58] *** Joins: jfbk (textual@moz-EEA9CFB3.nyc.res.rr.com)
[16:08:33] <cmr> bjz: value and types don't share a namespace (since they can never be used in the same context)
[16:08:44] *** Joins: KindOne (KindOne@moz-C59D8596.dynamic.ip.windstream.net)
[16:09:33] <bjz> yeah
[16:10:06] *** Joins: jeaye (Jeaye@moz-FD505E54.hsd1.ca.comcast.net)
[16:10:56] <bjz> rusti: fn glFn() {} mod glFn { pub static mut is_loaded: bool = false; } (glFn(), glFn::is_loaded)
[16:10:57] -rusti- <anon>:5:84: 5:99 error: use of mutable static requires unsafe function or block
[16:10:57] -rusti- <anon>:5          fn glFn() {} mod glFn { pub static mut is_loaded: bool = false; } (glFn(), glFn::is_loaded)
[16:10:57] -rusti-                                                                                              ^~~~~~~~~~~~~~~
[16:10:57] -rusti- error: aborting due to previous error
[16:10:59] -rusti- application terminated with error code 101
[16:11:09] <bjz> rusti: fn glFn() {} mod glFn { pub static mut is_loaded: bool = false; } unsafe { (glFn(), glFn::is_loaded) }
[16:11:10] -rusti- ((), false)
[16:11:22] <bjz> cmr: that was my idea
[16:12:37] *** Joins: engla (engla@moz-DBD1D96E.cust.bredbandsbolaget.se)
[16:13:47] *** Quits: FrozenCow (FrozenCow@moz-B2DF4929.chello.nl) (Ping timeout)
[16:14:03] *** Joins: FrozenCow (FrozenCow@moz-B2DF4929.chello.nl)
[16:14:54] *** Quits: huseby (huseby@19BD73A1.5D8BCA3A.A0C1B52F.IP) (Quit: Leaving)
[16:15:35] *** Joins: huseby (huseby@19BD73A1.5D8BCA3A.A0C1B52F.IP)
[16:17:10] <nmatsakis> github down?
[16:17:27] <mib_qsaud0> looks like it
[16:17:38] * nmatsakis frowns
[16:17:44] <Ms2ger> Yeah
[16:17:48] <nmatsakis> how dare they be fallible
[16:18:12] <cmr> (https://status.github.com/)
[16:18:25] <Ms2ger> How could one live without github?
[16:18:41] <cmr> sourceforge!
[16:18:43] <cmr> bitbucket!
[16:18:49] <cmr> githq!
[16:18:59] <nmatsakis> who would DDOS github?
[16:19:17] <sigma> people trying to extort money? or may advertise their dos'ing ability?
[16:19:22] <sigma> maybe*
[16:19:27] <nmatsakis> I know, I know...
[16:19:50] <jfbk> i have a task that loops listening on a port for a msg.  when it receives one, it iters over items in a vec.  a second port listens for items to add to the vec.  right now i check the item port w/ peek at the top of the loop before calling recv on the msg port.  is there a way to interrupt the msg port's recv call when a message arrives on the item port?   
[16:20:06] <Ms2ger> nmatsakis, what seems to be the entire git community? :)
[16:20:17] <tiffany> a great disturbance in the open source has occured
[16:20:24] <tiffany> as if millions of developers cried out in agony
[16:20:50] <maik> Can someone implement an Iterator for "enum List<T> {Empty,Cons(T, ~List<T>)}"? I think I am too stupid
[16:20:58] <SimonSapin> yay centralization
[16:22:59] <sigma> time to fall back on the "mail in patches" system the kernel uses? ^^
[16:23:50] <cmr> it's a very reasonable system
[16:24:01] * cmr likes it almost as much as github-style PRs
[16:24:53] <sigma> I like it too, it appeals to my preference for decentralised systems
[16:25:00] *** Quits: bnicholson (bnicholson@moz-E98974C1.hsd1.ca.comcast.net) (Ping timeout)
[16:25:11] <sigma> I imagine it takes a bit of getting used to though
[16:25:18] *** Quits: Jesin (Jessin_@moz-157A63DD.cc.lehigh.edu) (Quit: Leaving)
[16:25:48] <cmr> What the world really needs is a frontend for emails which are just git-created patches with inline comments :p
[16:26:09] *** Joins: ghrust (ghrust@C8693FCB.6A2AE50.F3114085.IP)
[16:26:09] <ghrust> 01[13rust01] 15bors 04force-pushed 06auto from 143ae6e45 to 14435020e: 02http://git.io/N3iJvQ
[16:26:09] *** Parts: ghrust (ghrust@C8693FCB.6A2AE50.F3114085.IP) ()
[16:26:11] *** Joins: ghrust (ghrust@1E8607E8.6A2AE50.F3114085.IP)
[16:26:11] <ghrust> 01[13rust01] 15bors pushed 2 new commits to 06auto: 02http://git.io/yDes1g
[16:26:11] <ghrust> 13rust/06auto 140932ab3 15Nick Desaulniers: Remove unused automatic cfg bindings Fixes #7169
[16:26:11] <ghrust> 13rust/06auto 14fc3297f 15bors: auto merge of #8499 : nickdesaulniers/rust/issue7169, r=graydon...
[16:26:11] *** Parts: ghrust (ghrust@1E8607E8.6A2AE50.F3114085.IP) ()
[16:26:33] <mib_qsaud0> http://pastebin.com/mBihL8Ad I have basically no idea what I'm doing, but is something like that possible? I don't care what the "collection" looks like, as long as it is possible to iterate over it.
[16:27:18] *** Quits: bytbox (s@moz-DC83764A.washdc.fios.verizon.net) (Ping timeout)
[16:29:08] <nmatsakis> maik: https://gist.github.com/nikomatsakis/6242267
[16:29:10] <cmr> mib_qsaud0: Why do you have the Test trait?
[16:30:48] *** Quits: FrozenCow (FrozenCow@moz-B2DF4929.chello.nl) (Ping timeout)
[16:31:15] <cmr> mib_qsaud0: anyway you're saying you take the Iterator to be returned as a type parameter, but then you return a value of a concrete type
[16:31:36] <cmr> mib_qsaud0: it needs to be impl<'self, T> Test<T, VecIterator<'self, T>> for ~[T]
[16:31:51] *** Quits: sigma (sigma@51C589B3.EF2694B5.DFAC6AA7.IP) (Ping timeout)
[16:32:11] *** Joins: FrozenCow (FrozenCow@moz-B2DF4929.chello.nl)
[16:32:31] <maik> nmatsakis, thanks
[16:32:56] *** Joins: sigma (sigma@51C589B3.EF2694B5.DFAC6AA7.IP)
[16:35:20] *** Quits: FrozenCow (FrozenCow@moz-B2DF4929.chello.nl) (Ping timeout)
[16:36:35] <cmr> mib_qsaud0: actually in'st possible with that trait to iterate over a vector
[16:36:57] <cmr> mib_qsaud0: needs some more lifetimes, or not taking self by borrowed pointer
[16:37:30] <cmr> well, not necessarily
[16:37:34] <cmr> you could clone each item
[16:37:37] <cmr> but yuck
[16:38:03] *** Joins: azita (Azita@moz-BBE3ABD.mv.mozilla.com)
[16:38:59] <mib_qsaud0> cmr: Thanks thus far, I think I have to take a look at lifetimes.
[16:39:15] <cmr> http://static.rust-lang.org/doc/tutorial-borrowed-ptr.html
[16:39:26] <Ms2ger> let new_visitor = new_visitor; ?
[16:40:01] <cmr> Ms2ger: that could be stripping the mutability from the binding
[16:40:12] *** Joins: bnicholson (bnicholson@moz-BBE3ABD.mv.mozilla.com)
[16:40:13] *** Joins: FrozenCow (FrozenCow@moz-B2DF4929.chello.nl)
[16:40:20] <cmr> (ie, if it was previously `let mut new_visitor = ...`, or `mut new_visitor: ...`)
[16:42:06] <Ms2ger> Well, the diff is
[16:42:08] <Ms2ger> - let mut new_visitor = new_visitor; 
[16:42:14] <Ms2ger> + let new_visitor = new_visitor;
[16:42:18] <cmr> heh, that seems silly
[16:43:46] <km> jfbk: sounds like you want "select". I have no idea what the state of it is with the RT changes, though.
[16:50:25] *** Joins: mark_edward (quassel@477DC302.E191B2A.7D9BF48D.IP)
[16:51:12] <mark_edward> is there anyway to run the configure script without downloading the submodules? i just want to build the docs and im on a very slow internet connection
[16:51:19] *** Joins: graydon (graydon@moz-F14EE0DB.cable.teksavvy.com)
[16:51:19] *** ChanServ sets mode: +qo graydon graydon
[16:51:43] <cmr> mark_edward: edit the configure script to remove the submodule fetch
[16:52:04] <mark_edward> cmr: okay, thanks
[16:52:32] *** Joins: weirdo (Mibbit@moz-535184AB.customers.ownit.se)
[16:53:23] <weirdo> Is cargo they way to get dependencies? https://github.com/mozilla/cargo-central points to a rather well, empty wiki page
[16:53:23] *** Joins: azakai (alon@moz-BBE3ABD.mv.mozilla.com)
[16:54:03] <cmr> weirdo: no
[16:54:05] <weirdo> Github is acting out it seems, it could be the reason
[16:54:08] <cmr> cargo has been gone since rust 0.5
[16:54:13] <weirdo> ah
[16:54:29] <weirdo> rustpkg?
[16:55:40] <cmr> yes, rustpkg is its replacement
[16:56:32] <mark_edward> cmr: now it complains about LLVM. i just want the docs! is there anywhere the docs can just be downloaded? i shouldnt need LLV to get the docs :(
[16:56:55] <weirdo> it acts funny for me its "list" simply shows my ~/bin
[16:57:21] <cmr> oh right, you actually need a rustdoc to build the docs, which requires building everything
[16:57:43] <cmr> graydon: are there any doc zips/tarballs on the website? or the generated pdfs?
[16:57:50] <graydon> no
[16:58:30] <mark_edward> cmr: i havve a local rustdoc installed
[16:58:44] <cmr> mark_edward: run rustdoc on std.rs and friends then
[16:59:21] *** Joins: infynyxx (infynyxx@DB780A29.749BA1D.DCC373F0.IP)
[16:59:41] <mark_edward> okay
[17:01:04] <jfbk> km: thanks, that does look like what i want.  select looks like it requires ports w/ the same type msg?
[17:01:43] *** Quits: StarLight (StarLight@moz-71A9D610.dynamic.avangarddsl.ru) (Ping timeout)
[17:02:20] *** Joins: tjc (tjc@moz-6EB4E533.dsl.tsoft.com)
[17:02:20] *** ChanServ sets mode: +o tjc
[17:04:06] <tjc> graydon: is there a triage meeting?
[17:04:32] *** Joins: eschweic (Adium@moz-BBE3ABD.mv.mozilla.com)
[17:04:35] <graydon> yes
[17:04:35] <graydon> cya
[17:04:39] <tjc> oh
[17:06:09] *** Joins: StarLight (StarLight@moz-1887BE79.pppoe.avangarddsl.ru)
[17:07:09] *** Quits: weirdo (Mibbit@moz-535184AB.customers.ownit.se) (Quit: http://www.mibbit.com ajax IRC Client)
[17:07:32] *** Quits: maik (maik___@moz-7012C389.dip0.t-ipconnect.de) (Ping timeout)
[17:07:33] *** Joins: brson (brson@moz-BBE3ABD.mv.mozilla.com)
[17:07:34] *** ChanServ sets mode: +o brson
[17:07:43] *** Quits: brson (brson@moz-BBE3ABD.mv.mozilla.com) (Quit: leaving)
[17:07:51] *** Joins: brson (brson@moz-BBE3ABD.mv.mozilla.com)
[17:07:51] *** ChanServ sets mode: +o brson
[17:09:07] *** Quits: sk (sk@61A494B3.BA40E8A.AAC02D62.IP) (Quit: Leaving)
[17:13:20] *** Quits: mihneadb (Mihnea@moz-BBE3ABD.mv.mozilla.com) (Quit: Leaving)
[17:13:47] <klutzy> nmatsakis: "smallest-hell-world" https://github.com/mozilla/rust/issues/8538
[17:14:40] <Ms2ger> Oh, is *that* what 'shell' is an abbreviation for?
[17:14:59] <nmatsakis> klutzy: I wish I could say that was not an accident
[17:15:34] *** Joins: bytbox (s@moz-2D36DB45.wireless.umd.edu)
[17:15:54] <klutzy> when I learn new language, I usually use "hell-o-world" instead of "hello world" :)
[17:16:04] *** Joins: infynyxx_ (infynyxx@moz-E95B370B.nyc.res.rr.com)
[17:17:44] *** Quits: infynyxx_ (infynyxx@moz-E95B370B.nyc.res.rr.com) (Ping timeout)
[17:19:20] *** Joins: nano (nano@moz-74CAD1CA.superkabel.de)
[17:20:12] *** Quits: Houm (Houm@moz-25669AA8.fbx.proxad.net) (Ping timeout)
[17:21:22] <engla> tjc: can you re-r  https://github.com/mozilla/rust/pull/8526 ? The old PR of the same changes seems to have failed on llvm build in windows (so unrelated failure)?
[17:21:49] <tjc> engla: done
[17:21:53] <engla> thanks!
[17:22:36] <tjc> yw
[17:22:46] *** Quits: bytbox (s@moz-2D36DB45.wireless.umd.edu) (Ping timeout)
[17:23:59] *** Quits: huseby (huseby@19BD73A1.5D8BCA3A.A0C1B52F.IP) (Quit: Leaving)
[17:24:15] *** Quits: davbo (dave@moz-3FFA637C.oucs.ox.ac.uk) (Client exited)
[17:24:37] *** Joins: Houm (Houm@moz-25669AA8.fbx.proxad.net)
[17:27:01] *** Quits: ChrisMorgan (chris@moz-6AC741CA.static.tpgi.com.au) (Ping timeout)
[17:27:32] *** Quits: KindOne (KindOne@moz-C59D8596.dynamic.ip.windstream.net) (Ping timeout)
[17:32:09] *** Quits: LU324 (weechat@9AF4F288.83671C58.1B5D53D7.IP) (Input/output error)
[17:32:49] *** Joins: LU324 (weechat@9AF4F288.83671C58.1B5D53D7.IP)
[17:32:57] *** Quits: mib_qsaud0 (Mibbit@moz-C2B79D43.pool.mediaways.net) (Quit: http://www.mibbit.com ajax IRC Client)
[17:33:23] *** Joins: vosen (vosen@moz-266BA656.icpnet.pl)
[17:33:47] *** Joins: mschifer (Adium@moz-BBE3ABD.mv.mozilla.com)
[17:36:29] *** Quits: CarpNet (ac@moz-FD24B77.sohonet.co.uk) (Quit: Leaving)
[17:37:13] <toddaaro> brson: did you figure anything out with threads joining?
[17:37:34] <toddaaro> brson: nondeterministic deadlock on a join is still what is blocking my idle callback stuff
[17:37:45] <toddaaro> haven't been able to figure out why it would be doing so
[17:40:36] <olsonjeffery> rusti: let f: Option<()> = None; f.is_none()
[17:40:36] -rusti- true
[17:40:52] <olsonjeffery> rusti: let f: Option<()> = None; let r = &f; r.is_none()
[17:40:53] -rusti- true
[17:41:38] <olsonjeffery> rusti: let f: Option<fn~()> = Some(||{}); let r = &f; r.is_some();
[17:41:41] -rusti- pastebinned 10 lines of output: http://ix.io/7jy
[17:42:20] *** Joins: eatkinson (eatkinson@moz-BBE3ABD.mv.mozilla.com)
[17:44:21] *** Joins: ecr (Thunderbir@moz-BBE3ABD.mv.mozilla.com)
[17:46:57] <olsonjeffery> rusti: let f: Option<&fn()> = Some(||{println("hello")}); { let r = &f; r.is_some(); (*r.get_ref())(); }
[17:46:58] -rusti- hello
[17:46:58] -rusti- ()
[17:47:02] <olsonjeffery> does anybody care about that?
[17:47:14] <olsonjeffery> no auto-deref for references to closures
[17:47:28] *** Joins: hjr3 (hradtke@374E545A.3A8E9B0C.F9D9C60E.IP)
[17:47:31] <olsonjeffery> while we get it for methods on the referenced type
[17:48:00] <olsonjeffery> curious if there's some kind of ambiguity reason for that not happening or if it's just a rough corner
[17:48:41] <cmr> auto deref only happens with the . operator
[17:48:44] <cmr> aiui
[17:49:11] <olsonjeffery> cmr: yes, that's what im pointing out. im curious if there's a reason for it happening only w/ . and not () invocation.
[17:49:20] <olsonjeffery> besides "we take patches!"
[17:50:11] <cmr> dunno
[17:52:05] <ecr> rusti: let f = || { 2 }; let g = &f; g()
[17:52:05] -rusti- <anon>:5:39: 6:5 error: expected function but found `&&fn<no-bounds>() -> <VI0>`
[17:52:06] -rusti- <anon>:5          let f = || { 2 }; let g = &f; g()
[17:52:06] -rusti- <anon>:6     };
[17:52:06] -rusti- error: aborting due to previous error
[17:52:06] -rusti- application terminated with error code 101
[17:52:10] <Seldaek> cmr: do you offer bug triage services? I got a few hundred tickets that could use your skills :p
[17:52:26] <ecr> rusti: left f = || { 2}; let g = &f; *g()
[17:52:26] <cmr> Seldaek: sorry, already do a hundred a week for rust :p
[17:52:27] -rusti- <anon>:5:14: 5:15 error: expected one of `; }` but found `f`
[17:52:27] -rusti- <anon>:5          left f = || { 2}; let g = &f; *g()
[17:52:27] -rusti-                        ^
[17:52:27] -rusti- application terminated with error code 101
[17:52:38] <cmr> .... I wonder if I could make money doing that part time though
[17:52:45] <ecr> rusti: let f = || { 2}; let g = &f; *g()
[17:52:46] -rusti- <anon>:5:39: 6:5 error: expected function but found `&&fn<no-bounds>() -> <VI0>`
[17:52:46] -rusti- <anon>:5          let f = || { 2}; let g = &f; *g()
[17:52:46] -rusti- <anon>:6     };
[17:52:47] -rusti- error: aborting due to previous error
[17:52:47] -rusti- application terminated with error code 101
[17:53:07] <Seldaek> cmr: joking aside, the issue is you need to be somewhat familiar with a project to do it I think
[17:53:23] <olsonjeffery> cmr: well that's a more succinct test case, for sure.
[17:53:45] <ecr> rusti: let f = || { 2 }; let g = &f; (*g)()
[17:53:45] <olsonjeffery> anyways. if there's no barrier to it being done. i might take a whack at it after i land the initial file io stuff.
[17:53:46] -rusti- 2
[17:54:03] <olsonjeffery> ive been wanting to break into compiler/language contribution
[17:55:10] <tjc> Seldaek: Mozilla does have at least one paid employee whose entire job is to be the "bugmaster" and coordinate triage efforts :-)
[17:55:18] <olsonjeffery> i guess i should dig into the rust-dev discussion back when auto-deref was settled and see if there's anything there about closure invocation
[17:55:26] <jld>    * None of the above applies to Linux: SO_REUSEADDR implies SO_REUSEPORT on
[17:55:26] <jld>    * Linux and hence it does not have SO_REUSEPORT at all.
[17:55:27] <tjc> so it is possible to get paid to do that, though it's more than just going through bug-by-bug of course
[17:55:37] <jld> So why is libuv trying to use SO_REUSEPORT on a Linux host?
[17:55:49] <Seldaek> tjc: yes at the mozilla scale I am sure it makes sense, but it'd be hard to sell such services on a bounty basis though
[17:56:03] <jld> And then failing to know what ENOPROTOOPT is, such that rt dies with Lovecraft.
[17:56:07] <tjc> Seldaek: Yeah, probably. It would work better to work at a big-ish company doing that than to be a freelancer
[17:56:20] <Seldaek> tjc: also I don't know who that poor fella is, but I hope he's paid well :p
[17:56:27] <tjc> Seldaek: I believe she is paid well :-)
[17:56:35] <Seldaek> that works too
[17:56:43] <cmr> bug triage really isn't that bad
[17:57:04] <cmr> it's not very glamorous, but it's not that bad
[17:57:19] *** Joins: huseby (huseby@19BD73A1.5D8BCA3A.A0C1B52F.IP)
[17:57:30] <Seldaek> I have to do it enough as it is and I just check incoming issues, rarely go oover existing stuff, I'd quit this OSS thing if I had to do this all day :)
[17:58:04] <jld> ...ah.  Because Linux *does* support SO_REUSEPORT as of 3.9.  Thanks, IRC talk-to-the-bear debugging!  (-:
[17:58:15] <cmr> jld: any problem!
[17:58:21] <cmr> erm...
[17:58:24] <cmr> anytime/no problem
[17:58:26] <cmr> take your pick
[17:59:42] <olsonjeffery> ah. that feeling when your battle with the compiler reaching "only lint errors left" phase.
[17:59:52] <olsonjeffery> reaches the*
[18:00:23] *** Quits: dherman (dherman@moz-6CA476B1.hsd1.ca.comcast.net) (Quit: dherman)
[18:00:30] *** Quits: nano (nano@moz-74CAD1CA.superkabel.de) (Ping timeout)
[18:00:57] *** Quits: ecr (Thunderbir@moz-BBE3ABD.mv.mozilla.com) (Quit: ecr)
[18:02:32] *** Quits: bent (chatzilla@moz-BE33DA21.fw1.sfo1.mozilla.net) (Ping timeout)
[18:02:48] *** Joins: bent (chatzilla@moz-BE33DA21.fw1.sfo1.mozilla.net)
[18:03:46] *** Quits: azita (Azita@moz-BBE3ABD.mv.mozilla.com) (Quit: azita)
[18:03:59] <toddaaro> olsonjeffery: yea, it feels good, then you realize you are losing multiple minutes from your life because of #lint
[18:04:07] *** Joins: ecr (Thunderbir@moz-BBE3ABD.mv.mozilla.com)
[18:04:12] <toddaaro> I was wondering if we could have a --cfg no-lint option or somethig
[18:04:23] <mark_edward> do trait objects implement themselves?
[18:04:32] <cmr> mark_edward: no
[18:04:43] <toddaaro> as I've spent many, many hours this summer dealing with lint errors when I just want it to go again as fast as soon as possible for debugging
[18:04:44] *** Joins: nano (nano@moz-74CAD1CA.superkabel.de)
[18:05:10] *** Joins: azita (Azita@moz-BBE3ABD.mv.mozilla.com)
[18:05:14] <cmr> rustc -A warnings
[18:05:25] <cmr> I don't know if it actually skips processing the lint
[18:05:30] <cmr> but it at least surpresses it
[18:05:31] <mark_edward> cmr: so if i had fn foo<T: Trait>(x: &T); and an object v: ~Trait, i couldn't say foo(v)?
[18:05:32] <toddaaro> does that override the "lint warnings are errors" setting?
[18:05:47] <cmr> mark_edward: that isn't a trait object
[18:05:48] <toddaaro> if so I'm definitely going to start doing that
[18:05:54] <cmr> mark_edward: erm, wait, nevermind
[18:05:58] <cmr> toddaaro: yes, I'm pretty sure
[18:06:04] *** Quits: lucian (lucian@6B2B4644.4304AE1E.CE5E78F6.IP) (Ping timeout)
[18:06:06] <brson> toddaaro: i haven't been looking at that issue. do you have a test case that reproduces it?
[18:06:08] <cmr> mark_edward: you can, you just need to impl Trait for ~Trait
[18:06:08] <toddaaro> cmr: awesome, thanks for the tip
[18:06:20] *** Joins: jaen (jaen@moz-E0979827.copit.pl)
[18:06:21] <toddaaro> brson: I can push my branch and have you run tests there
[18:06:32] <brson> ok
[18:06:34] <mark_edward> cmr: wouldnt is make sense for trait objects to automatically implement the trait?
[18:06:48] <cmr> mark_edward: there's a very good reason that they don't, and I don't know what that reason is
[18:07:36] <mark_edward> cmr: okay, thanks! maybe it's like if you have T: Clone but ~Clone may not necessarily be cloned?
[18:07:50] <cmr> mark_edward: I really don't know :)
[18:08:07] <doomlord> trait objects dont have data?
[18:08:30] <doomlord> oh nonsense
[18:08:38] <doomlord> talking about the wrong thing
[18:09:01] *** Quits: tjc (tjc@moz-6EB4E533.dsl.tsoft.com) (Ping timeout)
[18:09:11] <cmr> Ugh, github isn't sending emails when I'm mentioned in an issue
[18:09:14] <cmr> that is really annoying
[18:09:18] <toddaaro> brson: you mentioned last night you had some weirdness due to thread_join behavior, what exactly was that?
[18:09:25] <olsonjeffery> my understanding, from experience, is that the rust build is enforcing lint-as-error
[18:09:35] <olsonjeffery> but if im just building a one-off .rs file with rustc, it's more lax
[18:09:51] <engla> mark_edward: .clone() on ~Clone says " cannot call a method whose type contains a self-type through an object"
[18:10:03] <toddaaro> olsonjeffery: yes, there are settings to make this the case in the mod.rs file for the runtime
[18:10:15] <cmr> olsonjeffery: yes, but it can be overridden with -A given to rustc, unless it'd #[forbid(lint_setting)]
[18:10:16] <toddaaro> olsonjeffery: it is great for make tidy style checking, but it really bogs down rapid testing
[18:10:44] <mark_edward> engla: "'I see,' said the blind man"
[18:11:00] *** Quits: tupshin (quassel@moz-E7B03838.c3-0.nyr-ubr1.nyr.ny.cable.rcn.com) (Ping timeout)
[18:11:34] *** Quits: MrFahrenheit (RageOfThou@3FEF494C.29C984D5.783DEDCA.IP) (Ping timeout)
[18:11:58] *** Joins: MrFahrenheit (RageOfThou@3FEF494C.29C984D5.783DEDCA.IP)
[18:12:38] <engla> so fn clone(&self) -> Self.   why shouldn't it be possible to have it wrap it to  fn clone(&self) -> ~Clone
[18:12:41] <brson> toddaaro: what i was looking at was related to the waitpid call that compiletest does when spawning subprocesses. I believe that that waitpid was blocking the scheduler, causing scheduler messages to be unhandled and making tests not run in parallel, though I don't know the specific sequence of events that causes it. this pr works around the problem https://github.com/mozilla/rust/pull/8531
[18:12:46] <olsonjeffery> brson: so i have an of c consts (O_RDONLY, O_WRONLY, ...) that i use to map them to their native values
[18:12:56] <olsonjeffery> and the linter is complaining about not being camel-case
[18:13:06] <olsonjeffery> is there an attribute to suppress the lint warning, here?
[18:13:16] <olsonjeffery> or should i make the naming rustic?
[18:13:55] <olsonjeffery> im using the enum variants in a match block to call down to native fns to get their value so that i can bitwise-or them into a useable value
[18:13:57] <cmr> graydon: I'm making the PR to integrate rustdoc_ng into mainline. Do you care about the history of the rustdoc_ng repository being merged, or is just a cp of the code fine?
[18:14:11] <olsonjeffery> obviously the user-facing API will be more elegant
[18:14:12] *** Quits: BizarreCake (BizarreCak@moz-361FE9B2.dynamic.barak-online.net) (Connection reset by peer)
[18:14:14] <doomlord> i have prefered to use bindings with exact c naming for  c libraries i.e. opengl, the focus on the library not the engine
[18:14:16] <cmr> olsonjeffery: #[allow(non_camel_cased_types)]
[18:14:17] <toddaaro> brson: ok, I'm pushing my branch as "new-idle" to my fork
[18:14:21] <brson> olsonjeffery: my preference is to give them rust names, though reasonable people i'm sure would disagree. you can though suppress the lint on the enum with #[allow(lint_setting)]
[18:14:25] <toddaaro> brson: if git unhangs the command at least
[18:14:50] <doomlord> i.e. so i can move back and forth between C and rust, and i'm looking at the same things
[18:14:51] <olsonjeffery> brson: yeah, as i said.. this is low, libuv-level implementation details that won't be exposed in the higher-level file io API
[18:15:07] <olsonjeffery> want to keep it consistent w/ what libuv is expecting.. although ORdOnly isn't horrible, i guess
[18:15:09] <brson> olsonjeffery: oh, sorry. i missed that
[18:15:21] <toddaaro> brson: bleh, git can't push to my repository
[18:15:22] <toddaaro> I
[18:15:25] <toddaaro> 'll have to debug this
[18:15:30] <mark_edward> if i have an object r: &Reader, why can't i call r.read_line() without getting an error about &Reader not implementing std::io::Reader?
[18:15:37] *** Joins: tjc (tjc@moz-6EB4E533.dsl.tsoft.com)
[18:15:37] *** ChanServ sets mode: +o tjc
[18:15:40] <brson> olsonjeffery: yeah, keep the libuv names and use #[allow(non_camel_cased_types)]
[18:15:41] <engla> the O_ part is just a "C namespace" so you don't have to keep that in the camel case version (if any) :)
[18:16:06] <cmr> mark_edward: that's actually a method on ReaderUtil, not Reader
[18:16:39] <mark_edward> cmr: so i should have an r: &ReaderUtil?
[18:16:51] <cmr> mark_edward: I think so, yeah
[18:17:04] <engla> I think you must implement ReaderUtil for &Reader simply
[18:17:14] <cmr> ReaderUtil should be killed for default methods, but I don't think it's relevant with the new runtime
[18:17:30] <engla> err, impl Reader for &Reader
[18:18:05] <mark_edward> cmr: now i get error: type `&'self std::io::ReaderUtil<no-bounds>` does not implement any method in scope named `eof`
[18:18:11] <toddaaro> brson: ok, code pushed to new-idle on my fork. There are two main issues to observe. The first is nondeterministic deadlock, the second is schedulers shutting down with messages in the queue and rtaborting.
[18:18:25] <cmr> mark_edward: ...right, because that's a method on Reader
[18:18:27] <toddaaro> brson: I just run the test suite in a loop until it fails and usually get one or the other
[18:18:30] <cmr> I think engla is right, and that is the only way
[18:18:53] <toddaaro> brson: as one would expect with a race rtdebug status changes behavior a lot
[18:19:00] <engla> @Reader implements Reader manually, &Reader should be the same
[18:19:05] <mark_edward> that doesn't seem reasonable...
[18:19:15] *** Joins: Kruppe (user@moz-E150F49F.cpe.net.cable.rogers.com)
[18:19:36] <mark_edward> i feel like there's a better way, maybe having an &T where T: Reader+ReaderUtil
[18:19:38] <sigma> hmm, can you destructure a str the same way you destructure a vector? ie [x,..xs] ?
[18:19:42] <kmc> why does @Reader implement Reader manually?
[18:19:59] <cmr> kmc: because trait objects don't implement their respective traits
[18:20:00] <engla> so that ReaderUtil works with @Reader
[18:22:01] <kmc> cmr: what's the rationale for that design, though?
[18:22:07] *** Joins: btm_work (btm@moz-2160AA7C.sakura.ne.jp)
[18:22:23] <brson> toddaaro: ok. i'll look at it
[18:22:48] <cmr> kmc: not all methods can be polymorphized with a given trait object, aiui
[18:22:53] <cmr> fn foo() -> Self, for example
[18:22:55] <cmr> What is Self?
[18:22:59] <cmr> Not known at compile time
[18:23:01] <cmr> (for trait objects)
[18:23:09] <cmr> s/poly/mono/
[18:23:15] *** Joins: maik (maik___@moz-7012C389.dip0.t-ipconnect.de)
[18:23:39] <engla> but for  fn foo(&self) -> Self   it should be possible to work it out
[18:23:51] <engla> (that's the ~Clone example again)
[18:24:17] *** Quits: Houm (Houm@moz-25669AA8.fbx.proxad.net) (Ping timeout)
[18:24:18] <cmr> wait, do trait objects even carry associated functions
[18:24:20] <cmr> I would assume not
[18:24:42] <cmr> I have no idea how you'd call them
[18:25:23] <engla> anyway, io is being reworked by some clever developers mark_edward 
[18:25:28] *** Joins: tupshin (quassel@moz-E7B03838.c3-0.nyr-ubr1.nyr.ny.cable.rcn.com)
[18:26:01] <mark_edward> yeah. when will std::io be replaced?
[18:26:22] <cmr> when the new one is done
[18:26:35] <cmr> olsonjeffery: ETA?
[18:27:25] *** Joins: gareth0 (gareth0@moz-74F9D207.dynamic.dsl.as9105.com)
[18:27:51] <olsonjeffery> im just working on file io
[18:28:05] <cmr> that's all that's in std::io :)
[18:28:08] <olsonjeffery> i want to have an initial PR with open, read, write and close tomorrow
[18:28:21] <olsonjeffery> ill pull a bender over the weekend if i miss that.
[18:28:25] <cmr> (well, besides the traits, but those are already in std::rt::io)
[18:28:28] <olsonjeffery> from there its mostly filling in the details
[18:29:08] *** Joins: ghrust (ghrust@79968228.6A2AE50.F3114085.IP)
[18:29:08] <ghrust> 01[13rust01] 15bors merged 06auto into 06master: 02http://git.io/yDes1g
[18:29:08] *** Parts: ghrust (ghrust@79968228.6A2AE50.F3114085.IP) ()
[18:29:18] *** Quits: tjc (tjc@moz-6EB4E533.dsl.tsoft.com) (Quit: Places to go, people to annoy)
[18:29:33] *** Quits: ozten (ozten@19BD73A1.5D8BCA3A.A0C1B52F.IP) (Quit: ozten)
[18:30:02] *** Quits: huseby (huseby@19BD73A1.5D8BCA3A.A0C1B52F.IP) (Quit: Leaving)
[18:30:31] <brson> olsonjeffery: neat!
[18:30:34] <nmatsakis> engla: you can't work it out in that case. That's the reason that e.g. Java's clone() method returns Object (think about it: what type would you put there?)
[18:30:52] <Seldaek> olsonjeffery: that'd be awesome, can't wait to port some code to see how it performs :)
[18:31:02] *** Joins: dherman (dherman@moz-6CA476B1.hsd1.ca.comcast.net)
[18:31:02] *** ChanServ sets mode: +o dherman
[18:31:50] *** Joins: Houm (Houm@moz-25669AA8.fbx.proxad.net)
[18:32:10] *** Joins: ghrust (ghrust@DE823A67.6A2AE50.F3114085.IP)
[18:32:10] <ghrust> 01[13rust01] 15bors pushed 0 new commits to 06auto: 02http://git.io/IriU-w
[18:32:10] *** Parts: ghrust (ghrust@DE823A67.6A2AE50.F3114085.IP) ()
[18:32:13] *** Joins: ghrust (ghrust@9C8B94D4.6A2AE50.F3114085.IP)
[18:32:13] <ghrust> 01[13rust01] 15bors pushed 8 new commits to 06auto: 02http://git.io/Xs3_aQ
[18:32:13] <ghrust> 13rust/06auto 1429876dc 15Niko Matsakis: Issue #3678: Remove wrappers and call foreign functions directly
[18:32:13] <ghrust> 13rust/06auto 14ab5898a 15Niko Matsakis: Remove implicit stack attributes and add a lint
[18:32:14] <ghrust> 13rust/06auto 148ce6546 15Niko Matsakis: Add externfn macro and correctly label fixed_stack_segments
[18:32:16] *** Parts: ghrust (ghrust@9C8B94D4.6A2AE50.F3114085.IP) ()
[18:32:56] <nmatsakis> does anyone know if there is a way to get github to give more context in diffs? (like -U8)?
[18:32:58] *** Quits: infynyxx (infynyxx@DB780A29.749BA1D.DCC373F0.IP) (Client exited)
[18:33:05] <engla> nmatsakis: I guess it would require a ridiculous wrapper, but have it transform foo(&self) -> Self into something that does   ~x.clone() as ~Clone
[18:33:41] *** Joins: mschifer1 (Adium@moz-BBE3ABD.mv.mozilla.com)
[18:33:42] *** Quits: mschifer (Adium@moz-BBE3ABD.mv.mozilla.com) (Connection reset by peer)
[18:34:46] *** Joins: infynyxx (infynyxx@DB780A29.749BA1D.DCC373F0.IP)
[18:36:56] <cmr> What's the thing like basename but strips any extension?
[18:37:18] *** Quits: dherman (dherman@moz-6CA476B1.hsd1.ca.comcast.net) (Quit: dherman)
[18:38:50] <nmatsakis> engla: yes, I think you could make that particular case work like that -- though I'm not sure, might be some complexities that arise when you use the type generically
[18:38:57] <maik> bjz, ping
[18:39:15] *** Joins: bytbox (s@moz-DC83764A.washdc.fios.verizon.net)
[18:39:20] <benh> Does anyone remember which meeting it was that discussed not making cmp::Eq::eq a static method?
[18:39:25] <engla> cmr: something like  ${NAME%.*} strips one extension
[18:39:58] <cmr> engla: in what language is that? I'm in a makefile
[18:40:42] <engla> posix shell
[18:40:54] *** Quits: fabiand (fabiand@moz-E71B3C66.adsl.alicedsl.de) (Quit: Verlassend)
[18:44:06] *** Joins: ghrust (ghrust@1E8607E8.6A2AE50.F3114085.IP)
[18:44:06] <ghrust> 01[13rust01] 15bors 04force-pushed 06auto from 14965cfbb to 14fc3297f: 02http://git.io/N3iJvQ
[18:44:06] *** Parts: ghrust (ghrust@1E8607E8.6A2AE50.F3114085.IP) ()
[18:44:07] *** Joins: ghrust (ghrust@1E8607E8.6A2AE50.F3114085.IP)
[18:44:07] <ghrust> 01[13rust01] 15bors pushed 4 new commits to 06auto: 02http://git.io/lUCJ0Q
[18:44:07] <ghrust> 13rust/06auto 1467df142 15Michael Sullivan: Get rid of some warnings.
[18:44:07] <ghrust> 13rust/06auto 14b1d4dbb 15Michael Sullivan: Rangechange the log message truncation limit.
[18:44:08] <ghrust> 13rust/06auto 1490dede9 15Michael Sullivan: Make supertrait methods callable on object types....
[18:44:10] *** Parts: ghrust (ghrust@1E8607E8.6A2AE50.F3114085.IP) ()
[18:44:19] <cmr> nmatsakis: well that failed quick
[18:44:54] <cmr> nmatsakis: heh, http://buildbot.rust-lang.org/builders/auto-mac-64-nopt-c/builds/35/steps/compile/logs/stdio
[18:45:30] <mark_edward> isn't the purpose of a rait object so that you can call the trait methos using it?
[18:45:58] *** Quits: nano (nano@moz-74CAD1CA.superkabel.de) (Ping timeout)
[18:47:40] <nmatsakis> cmr: I sort of expected some x-platform issues
[18:47:51] <nmatsakis> mark_edward: you can calt the trait methods, it just doesn't implement the trait
[18:48:06] <nmatsakis> a subtle distinction
[18:48:10] *** Joins: tjc (tjc@moz-BBE3ABD.mv.mozilla.com)
[18:48:10] *** ChanServ sets mode: +o tjc
[18:48:47] <cmr> So if you have a trait Foo<T> { fn foo(&self) -> T } and an x: &Foo, what does x.foo() return?
[18:49:19] <cmr> Oh, I suppose you can't have a &Foo?
[18:49:26] <cmr> You'd need a &Foo<ConcreteType>
[18:49:35] *** Joins: strcat (strcat@moz-54F7FD49.cpe.net.cable.rogers.com)
[18:49:42] <nmatsakis> cmr: yes.
[18:49:57] <nmatsakis> cmr: `Self` is the hidden one, which is kind of the *point* of an object (that you don't know what Self is, and don't have to know)
[18:50:10] <benh> how about trait Foo { fn foo(&self) -> Self } then?
[18:50:13] <mark_edward> cmr: did that last commit ghrust just mentioned just fix trait inheritance stuff
[18:50:30] <cmr> mark_edward: I don't know yet, haven't tested it :)
[18:51:09] <nmatsakis> benh: you are not permitted to call foo() in that scenario
[18:51:20] <benh> Is it a type error?
[18:51:29] <nmatsakis> it's an error to call a method that refers to Self through an object
[18:51:40] <nmatsakis> yes, a type error
[18:51:49] <benh> seems reasonable :D
[18:55:10] <benh> nmatsakis: sorry, this is a stupid bikesheddy question, but i seem to remember you were involved in that discussion; why do the overloads for binary functions privilege the lhs as the receiver of the method instead of having both lhs and rhs as a regular parameter? is it to make autoderef work or is there a deeper reason?
[18:57:52] *** Quits: maik (maik___@moz-7012C389.dip0.t-ipconnect.de) (Ping timeout)
[18:58:56] *** Quits: infynyxx (infynyxx@DB780A29.749BA1D.DCC373F0.IP) (Ping timeout)
[18:58:57] *** Joins: dherman (dherman@moz-6CA476B1.hsd1.ca.comcast.net)
[18:58:58] *** ChanServ sets mode: +o dherman
[18:59:15] *** Quits: dherman (dherman@moz-6CA476B1.hsd1.ca.comcast.net) (Quit: dherman)
[18:59:33] *** Quits: victorporof (victorporo@DBFC8886.2203F6DA.D111398B.IP) (Ping timeout)
[18:59:51] *** Quits: eschweic (Adium@moz-BBE3ABD.mv.mozilla.com) (Quit: Leaving.)
[19:01:09] *** Quits: azita (Azita@moz-BBE3ABD.mv.mozilla.com) (Quit: azita)
[19:01:28] <mark_edward> i feel like autoderef is more confusing than convenient. i like . and -> in C++. clarifies thigns
[19:01:32] *** Joins: maik (maik___@moz-CB2146E0.dip0.t-ipconnect.de)
[19:01:34] *** Joins: nano (nano@moz-74CAD1CA.superkabel.de)
[19:01:43] <mark_edward> and makes it easy for pointer types to have their own methdos
[19:01:59] *** Quits: spider-mario (spidermari@moz-81131DB6.fbx.proxad.net) (Ping timeout)
[19:02:01] <doomlord> somethign for future IDE's to clarify, just color code it or render the . as a -> :)
[19:02:53] <doomlord> i agree, i'm not immiediately sure if i'm looking at a pointer.. but you get that in C++ already with references
[19:03:51] <mark_edward> that seems like  lot of work for an IDE. i wonder what the rationale for autoderef is
[19:04:12] <doomlord> saves on symbols. bear in mind supposedly "good C++" avoids pointers
[19:04:15] <cmr> (*self).foo() sucks
[19:04:17] <mark_edward> and we don't have references in Rust, just borrowed pointers! we can be superclear
[19:04:33] <mark_edward> cmr: what about self->foo()
[19:04:40] <cmr> mark_edward: not much better IMO
[19:04:46] <Ms2ger> We need arrows for other things!
[19:04:50] <cmr> I don't find autoderef that confusing
[19:05:03] <cmr> it happens on the lhs of a . when method lookup fails
[19:05:05] <cmr> aiui
[19:05:07] <doomlord> i'm okwitht the auto-deref, i hope they dont change it. i agree it takes thought, but overall its not a problem IMO
[19:05:47] <doomlord> an IDE will need to do the work of figureing out types for other reasons (completion)
[19:06:54] *** Quits: eatkinson (eatkinson@moz-BBE3ABD.mv.mozilla.com) (Quit: eatkinson)
[19:07:14] <benh> (self->foo() sure, but (*self)->foo() and you're back where you started. Clearly we need the variable-length-for-depth-of-deref -----> operator...)
[19:07:27] <mark_edward> benh: RFC?
[19:07:39] *** Joins: victorporof (victorporo@DBFC8886.2203F6DA.D111398B.IP)
[19:07:52] * mark_edward embarrasingly thinks that would be pretty cool
[19:07:59] <doomlord> does rust actually do that, auto-deref any level
[19:08:13] <cmr> doomlord: yes
[19:08:21] <Ms2ger> mark_edward, definitely cool... A good idea? I dunno :)
[19:08:29] <cmr> rusti: let x = @@@@@@@@@@@@@@@@@@@@@@5; x.eq(&5)
[19:08:30] -rusti- <anon>:5:47: 5:49 error: mismatched types: expected `&@@@@@@@@@@@@@@@@@@@@@@<VI0>` but found `&<VI1>` (expected @-ptr but found integral variable)
[19:08:30] -rusti- <anon>:5          let x = @@@@@@@@@@@@@@@@@@@@@@5; x.eq(&5)
[19:08:30] -rusti-                                                         ^~
[19:08:30] -rusti- error: aborting due to previous error
[19:08:30] -rusti- application terminated with error code 101
[19:08:32] <doomlord> heh maybe that confirms it's confusing, i didn't know :)
[19:08:34] <cmr> Oh heh
[19:09:15] <nmatsakis> benh: define "binary function"?
[19:09:36] <cmr> rusti: let x = &&5; x.eq(&5)
[19:09:36] -rusti- <anon>:5:17: 5:19 error: unexpected token: `&&`
[19:09:37] -rusti- <anon>:5          let x = &&5; x.eq(&5)
[19:09:37] -rusti-                           ^~
[19:09:37] -rusti- application terminated with error code 101
[19:09:38] <mark_edward> rusti: let x = @@@@@@@@@@@@@@@@@@@@@@5u; x.eq(&5u)
[19:09:39] -rusti- <anon>:5:48: 5:51 error: mismatched types: expected `&@@@@@@@@@@@@@@@@@@@@@@uint` but found `&uint` (expected @-ptr but found uint)
[19:09:39] -rusti- <anon>:5          let x = @@@@@@@@@@@@@@@@@@@@@@5u; x.eq(&5u)
[19:09:39] -rusti-                                                          ^~~
[19:09:41] -rusti- error: aborting due to previous error
[19:09:43] -rusti- application terminated with error code 101
[19:10:18] *** Joins: ghrust (ghrust@DE823A67.6A2AE50.F3114085.IP)
[19:10:18] <ghrust> 01[13rust01] 15catamorphism pushed 1 new commit to 06try: 02http://git.io/NpmvPw
[19:10:18] <ghrust> 13rust/06try 141a53caf 15Tim Chevalier: rustpkg: Un-ignore tests
[19:10:18] *** Parts: ghrust (ghrust@DE823A67.6A2AE50.F3114085.IP) ()
[19:10:37] <mark_edward> so it want's the depth of the RHS to be all the same pointery... if that makes anysense
[19:10:46] *** Quits: bnicholson (bnicholson@moz-BBE3ABD.mv.mozilla.com) (Input/output error)
[19:10:55] <toddaaro> brson: do you know what calls close on the AsyncWatcher in a UvRemoteCallback? I can't find anything that does
[19:11:06] <toddaaro> brson: but it must be called somewhere, as otherwise it would be a memory leak
[19:11:08] *** Joins: bnicholson (bnicholson@moz-BBE3ABD.mv.mozilla.com)
[19:11:12] <benh> nmatsakis: i basically mean that a+b desugars to a.add(b) and not add(a,b), so (as i understand) you get autoderef for a but not b? (I'm not actually sure how it works)
[19:11:40] <toddaaro> brson: oh wow, found it
[19:12:20] <doomlord> maybe you need rpn style arithmetic.   (a,b).add() ...
[19:12:42] <benh> rusti: (&5i) + 5i
[19:12:43] -rusti- 10
[19:12:44] <nmatsakis> benh: we actually don't autoderef on operators, but there is argument coercion, which is separate but related
[19:12:49] <nmatsakis> benh: I am not a fan of this personally
[19:12:53] <benh> rusti: 5i + (&5i)
[19:12:54] -rusti- <anon>:5:14: 6:5 error: mismatched types: expected `int` but found `&int` (expected int but found &-ptr)
[19:12:54] -rusti- <anon>:5          5i + (&5i)
[19:12:54] -rusti- <anon>:6     };
[19:12:54] -rusti- error: aborting due to previous error
[19:12:54] -rusti- application terminated with error code 101
[19:13:01] <nmatsakis> benh: that is, I am not a fan of that treatment for operators
[19:13:54] <nmatsakis> benh: if you wrote a.add(b), however, you would get autoderef for a, coercion for b
[19:14:05] *** Quits: mark_edward (quassel@477DC302.E191B2A.7D9BF48D.IP) (Ping timeout)
[19:14:21] <nmatsakis> benh: but if you write `a + b`, it is kind o fequivalent to (&a).add(&b)
[19:14:35] <nmatsakis> benh: the arguments to binary operators are always passed by reference 
[19:15:21] <benh> ok, i got tripped up there :)
[19:16:41] *** mcpherrin is now known as mm
[19:17:56] *** mm is now known as mcpherrin
[19:18:14] <benh> maybe autoborrowing was the word I was looking for?
[19:18:35] *** mcpherrin is now known as mcpherrinm
[19:18:50] <brson> bjz: can you look at https://github.com/bjz/glfw-rs/pull/26?
[19:18:56] <brson> fairly soon
[19:19:00] *** mcpherrinm is now known as mm
[19:19:24] <SimonSapin> Does rustc 0.7 give "multiple applicatble methods" for methods with the same name from different traits, only one of which really applies because of trait bounds?
[19:19:46] <SimonSapin> eg. impl<T: Decoder> DecoderUtil for T and impl<T: Encoder> EncoderUtil for T
[19:20:00] <cmr> SimonSapin: when you have generic impls like that, yes.
[19:20:12] <cmr> it's the bug that prevented transform from being map
[19:20:13] <cmr> it's a bug
[19:21:05] <SimonSapin> cmr: but fixed in recent rust, right?
[19:21:10] <cmr> SimonSapin: no
[19:21:42] *** Joins: ghrust (ghrust@24260B07.6A2AE50.F3114085.IP)
[19:21:43] <ghrust> 01[13rust01] 15catamorphism 04force-pushed 06try from 141a53caf to 14bfadc8c: 02http://git.io/k471pw
[19:21:43] <ghrust> 13rust/06try 14bfadc8c 15Tim Chevalier: rustpkg: Un-ignore tests
[19:21:43] *** Parts: ghrust (ghrust@24260B07.6A2AE50.F3114085.IP) ()
[19:22:15] <SimonSapin> cmr: wasnâ€™t transform renamed bac
[19:22:17] <SimonSapin> back to map?
[19:22:32] <cmr> SimonSapin: it was changed from a generic implementation to a default method
[19:22:40] <SimonSapin> oh, ok
[19:22:50] <SimonSapin> but 0.7 errors out with default methods
[19:23:05] <strcat> it was never called map before
[19:23:24] *** Joins: infynyxx (infynyxx@DB780A29.749BA1D.DCC373F0.IP)
[19:23:33] <strcat> as far as I can remember at least
[19:24:00] <ecr> brson: added a line to rust_uv_write that ignores SIGPIPE on non-Windows systems. everything passes with homing IO now.
[19:24:15] <brson> ecr: you badass!
[19:24:36] *** Quits: bnicholson (bnicholson@moz-BBE3ABD.mv.mozilla.com) (Input/output error)
[19:24:47] *** Quits: FrozenCow (FrozenCow@moz-B2DF4929.chello.nl) (Client exited)
[19:25:50] <ecr> brson: :)  should I bother figuring out how to unignore SIGPIPE afterwards or just leave a big comment in case it becomes a problem later on?
[19:26:12] *** Joins: ghrust (ghrust@C8693FCB.6A2AE50.F3114085.IP)
[19:26:12] <ghrust> 01[13rust01] 15bors 04force-pushed 06auto from 14f509658 to 14fc3297f: 02http://git.io/N3iJvQ
[19:26:12] *** Parts: ghrust (ghrust@C8693FCB.6A2AE50.F3114085.IP) ()
[19:26:13] *** Joins: ghrust (ghrust@9C8B94D4.6A2AE50.F3114085.IP)
[19:26:13] <ghrust> 01[13rust01] 15bors pushed 9 new commits to 06auto: 02http://git.io/4olWZw
[19:26:13] <ghrust> 13rust/06auto 1429876dc 15Niko Matsakis: Issue #3678: Remove wrappers and call foreign functions directly
[19:26:13] <ghrust> 13rust/06auto 14ab5898a 15Niko Matsakis: Remove implicit stack attributes and add a lint
[19:26:14] <ghrust> 13rust/06auto 148ce6546 15Niko Matsakis: Add externfn macro and correctly label fixed_stack_segments
[19:26:16] *** Parts: ghrust (ghrust@9C8B94D4.6A2AE50.F3114085.IP) ()
[19:27:23] <brson> ecr: maybe add it to the event loop ctor so that it's just always ignored, and doesn't impact every write?
[19:28:30] <ecr> brson: sounds good.
[19:30:20] *** Joins: eschweic (Adium@moz-BBE3ABD.mv.mozilla.com)
[19:32:21] *** Joins: bnicholson (bnicholson@moz-BBE3ABD.mv.mozilla.com)
[19:33:58] *** Quits: tjc (tjc@moz-BBE3ABD.mv.mozilla.com) (Quit: zzzzzzzzzz)
[19:35:30] *** Quits: bnicholson (bnicholson@moz-BBE3ABD.mv.mozilla.com) (Ping timeout)
[19:35:35] *** cubic_ is now known as cubic
[19:36:11] *** Quits: eschweic (Adium@moz-BBE3ABD.mv.mozilla.com) (Ping timeout)
[19:36:15] *** Joins: bnicholson (bnicholson@moz-BBE3ABD.mv.mozilla.com)
[19:36:46] <maik> can i move values out of a task? like let r = do spawn {let msg = port.recv(); msg};
[19:37:31] <maik> ah this is what futures are for
[19:37:31] <maik> nvm
[19:37:38] *** Joins: james4k (james@moz-E7990244.consolidated.net)
[19:37:50] <ecr> maik: not like that. you have you use a port/chan pair, give the chan to the task, then wait on the port. (futures basically wraps this for you)
[19:37:55] <brson> maik: task::try will do something like that but it returns a Result where the Ok type is your return value
[19:38:04] <brson> and Err is if the task fails
[19:38:07] *** Joins: ghrust (ghrust@C8693FCB.6A2AE50.F3114085.IP)
[19:38:08] <ghrust> 01[13rust01] 15bors 04force-pushed 06auto from 14bad73a8 to 14fc3297f: 02http://git.io/N3iJvQ
[19:38:08] *** Parts: ghrust (ghrust@C8693FCB.6A2AE50.F3114085.IP) ()
[19:38:09] *** Joins: ghrust (ghrust@F6EE6DE3.6A2AE50.F3114085.IP)
[19:38:09] <ghrust> 01[13rust01] 15bors pushed 6 new commits to 06auto: 02http://git.io/Eu9jRQ
[19:38:09] <ghrust> 13rust/06auto 1417cfdc2 15Graydon Hoare: test: un-xfail now working run-pass/foreign-struct.rs, close #2334.
[19:38:09] <ghrust> 13rust/06auto 1402a13eb 15Graydon Hoare: test: add testcase, close #4759 which was already fixed.
[19:38:10] <ghrust> 13rust/06auto 14000973b 15Graydon Hoare: test: add testcase, close #4929 which was already fixed.
[19:38:12] *** Parts: ghrust (ghrust@F6EE6DE3.6A2AE50.F3114085.IP) ()
[19:38:21] <brson> task::try is more for isolating errors though
[19:38:47] <brson> it's kind of conflating two features now that I think about it though
[19:39:20] *** Quits: Ms2ger (Ms2ger@moz-3E74B52D.adsl-dyn.isp.belgacom.be) (Quit: nn)
[19:40:41] <olsonjeffery> yn.k;[];az;s[;"C
[19:40:42] <olsonjeffery> "
[19:40:55] <olsonjeffery> f\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\']zzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzz
[19:41:08] <ecr> alright there?
[19:42:18] *** Joins: ozten (ozten@19BD73A1.5D8BCA3A.A0C1B52F.IP)
[19:42:34] *** Joins: tjc (tjc@moz-BBE3ABD.mv.mozilla.com)
[19:42:34] *** ChanServ sets mode: +o tjc
[19:44:05] *** Joins: ghrust (ghrust@C8693FCB.6A2AE50.F3114085.IP)
[19:44:05] <ghrust> 01[13rust01] 15bors 04force-pushed 06auto from 14c449d40 to 14fc3297f: 02http://git.io/N3iJvQ
[19:44:05] *** Parts: ghrust (ghrust@C8693FCB.6A2AE50.F3114085.IP) ()
[19:44:08] *** Joins: ghrust (ghrust@C8693FCB.6A2AE50.F3114085.IP)
[19:44:09] <ghrust> 01[13rust01] 15bors pushed 10 new commits to 06auto: 02http://git.io/10g4Ug
[19:44:09] <ghrust> 13rust/06auto 1429876dc 15Niko Matsakis: Issue #3678: Remove wrappers and call foreign functions directly
[19:44:09] <ghrust> 13rust/06auto 14ab5898a 15Niko Matsakis: Remove implicit stack attributes and add a lint
[19:44:09] <ghrust> 13rust/06auto 148ce6546 15Niko Matsakis: Add externfn macro and correctly label fixed_stack_segments
[19:44:11] *** Parts: ghrust (ghrust@C8693FCB.6A2AE50.F3114085.IP) ()
[19:44:25] <toddaaro> bors is doing a lot of things in a short amount of time
[19:44:36] * nmatsakis apologies for hogging bors
[19:44:42] <ecr> did make check become fast when i wasn't looking?
[19:44:48] <ecr> i.e. why is bors fast now?
[19:45:14] *** Quits: ssbr (ssbr@moz-141F89C6.block0.gvtc.com) (Ping timeout)
[19:45:44] <nmatsakis> in the case of my PR, it's just been failing to compile rather quickly :)
[19:45:58] <graydon> uh oh
[19:46:02] <nmatsakis> due to missing annotations on cross-platform fns
[19:46:11] <nmatsakis> I tried to get them all, hopefully have them all now
[19:46:25] *** Joins: brendan (brendaneic@A01051A9.6F669779.3D1CA460.IP)
[19:46:27] <graydon> yeah, mine bounced too
[19:46:34] <graydon> toddaaro: it's just cases bouncing
[19:46:41] <ecr> oh
[19:46:42] <nmatsakis> not that I have a better sol'n, but I hate #ifdef and #[cfg()] :)
[19:47:00] <nmatsakis> but what you- gonna do
[19:47:03] *** Quits: FDS (arnaud@moz-CE4D5907.bdx.modulonet.fr) (Ping timeout)
[19:47:08] <nmatsakis> (make everyone use linux)
[19:47:18] <nmatsakis> (some specific distro of linux)
[19:47:30] <cmr> (never to be upgraded)
[19:47:36] <graydon> I wonder if cond.trap(|| foo).inside(bar) should be renamed to cond.handle(|| foo).inside(bar)
[19:47:45] <graydon> we refer to the first lambda as a handler
[19:47:49] <graydon> handle things with a handler?
[19:47:56] *** Quits: decoder (quassel@moz-D7023D7D.own-hero.net) (Ping timeout)
[19:48:13] <ecr> I like trap personally, but I'm fine with handle.
[19:48:28] <nmatsakis> graydon: I...sort of forget why, but I think it may be that both closures have to be provided to the fn at once?
[19:48:42] <nmatsakis> I have a vague recollection that to do otherwise was unsound, but I can't remember why
[19:48:52] <maik> http://www.youtube.com/watch?v=piVnArp9ZE0
[19:49:07] <nmatsakis> maybe no longer true
[19:49:29] <graydon> nmatsakis: regarding its _name_?
[19:49:33] <nmatsakis> graydon: I personally prefer trap, it's more .. colorful
[19:49:37] *** Joins: decoder (quassel@moz-D7023D7D.own-hero.net)
[19:49:39] <ecr> maik: if cond.akbar(|| foo).inside(bar)
[19:50:03] <Eridius> cond.akbar(|| foo).itsatrap(bar)
[19:50:11] <maik> :D
[19:50:12] <nmatsakis> graydon: but the problem I was referring to do had to do with writing "cond.trap(|| foo).inside(bar)" rather than "cond.trap(||foo, bar)
[19:50:25] <graydon> I like trap because it reminds me of the "keep running, just alter output" behavior of IEEE754, which they call traps. but it's also somewhat like (say) a signal handler.
[19:50:42] <nmatsakis> graydon: but I honestly can't recall what the issue was, I'll get back to you if it comes to me
[19:50:53] <cmr> it's handling the condition, is how I see it?
[19:50:58] <graydon> nmatsakis: oh. I don't remember if there was one about that. I guess that might work. we can try.
[19:51:32] <Eridius> what happens if I say something like `let x = cond.trap(foo); let y = cond.trap(bar); util::ignore(x)`? As in, force destruction of the Traps in the wrong order?
[19:51:38] <nmatsakis> graydon: I remember there was some problem, but it may have been specific to some other scenario
[19:51:46] *** Quits: lerc (quassel@B2E8CAD3.A8D14E52.788638A4.IP) (Ping timeout)
[19:52:12] <nmatsakis> that might have been part of it :) (what Eridius wrote)
[19:52:30] *** Joins: bnicholson_ (bnicholson@moz-BBE3ABD.mv.mozilla.com)
[19:52:58] <Eridius> yeah the destructor doesn't make sure it's popping its own handler. It just pops the most recent guard off the stack
[19:54:18] *** Joins: FrozenCow (FrozenCow@moz-B2DF4929.chello.nl)
[19:54:21] *** Quits: bnicholson_ (bnicholson@moz-BBE3ABD.mv.mozilla.com) (Input/output error)
[19:54:55] <olsonjeffery> ''''-'-/w 2
[19:54:58] <olsonjeffery> whoops
[19:55:14] <graydon> Eridius: mm, maybe a thing to fix!
[19:55:26] <Eridius> indeed
[19:56:09] *** Joins: ghrust (ghrust@F6EE6DE3.6A2AE50.F3114085.IP)
[19:56:10] <ghrust> 01[13rust01] 15bors 04force-pushed 06auto from 14caeb4d8 to 14fc3297f: 02http://git.io/N3iJvQ
[19:56:10] *** Parts: ghrust (ghrust@F6EE6DE3.6A2AE50.F3114085.IP) ()
[19:56:10] *** Joins: ghrust (ghrust@C8693FCB.6A2AE50.F3114085.IP)
[19:56:11] <ghrust> 01[13rust01] 15bors pushed 2 new commits to 06auto: 02http://git.io/NOZLHQ
[19:56:11] <ghrust> 13rust/06auto 14a7c48be 15Tim Chevalier: rustc: More helpful error message when using a struct type like a function...
[19:56:11] <ghrust> 13rust/06auto 14ba55317 15bors: auto merge of #8502 : catamorphism/rust/issue-6702, r=graydon...
[19:56:11] *** Parts: ghrust (ghrust@C8693FCB.6A2AE50.F3114085.IP) ()
[19:56:43] <Eridius> I also want to figure out some way to be able to pass &T to a condition, but I can't give it a lifetime. I considered making the macro take an optional lifetime annotation and update Condition<T, U> to be Condition<lifetime, T, U>, defaulting to 'static if not given, but I suspect that will hit the issue of structs can't have lifetime annotations if they don't have any fields that use it
[19:58:25] <Eridius> what does #[unsafe_destructor] do?
[19:58:30] *** Joins: eschweic (Adium@moz-BBE3ABD.mv.mozilla.com)
[19:58:31] *** Joins: eatkinson (eatkinson@moz-BBE3ABD.mv.mozilla.com)
[19:58:57] *** Joins: eschweic1 (Adium@moz-BBE3ABD.mv.mozilla.com)
[19:58:57] *** Quits: eschweic (Adium@moz-BBE3ABD.mv.mozilla.com) (Connection reset by peer)
[19:59:23] <Eridius> oh wait, I didn't read the entirety of condition. It's not actually broken like I thought. The handler doesn't get pushed onto the TLS stack until you call .inside()
[20:01:50] *** Joins: ghrust (ghrust@9C8B94D4.6A2AE50.F3114085.IP)
[20:01:50] <ghrust> 01[13rust01] 15nikomatsakis 04force-pushed 06try from 14bfadc8c to 141b588cb: 02http://git.io/k471pw
[20:01:50] <ghrust> 13rust/06try 1429876dc 15Niko Matsakis: Issue #3678: Remove wrappers and call foreign functions directly
[20:01:50] <ghrust> 13rust/06try 14ab5898a 15Niko Matsakis: Remove implicit stack attributes and add a lint
[20:01:50] <ghrust> 13rust/06try 148ce6546 15Niko Matsakis: Add externfn macro and correctly label fixed_stack_segments
[20:01:52] *** Parts: ghrust (ghrust@9C8B94D4.6A2AE50.F3114085.IP) ()
[20:02:57] <nmatsakis> Eridius: the matter of passing references vs by-move to condition handles is a big problem and there is no good sol'n right now
[20:03:16] <nmatsakis> either we have to extend the type system in some semi-complicated ways,
[20:03:28] <engla> nmatsakis: what's the change in the first hunk here? looks wrong +#[denyg(missing_doc)];   
[20:03:32] <engla> https://github.com/mozilla/rust/commit/8ce65468c78f7b25aebcee09d5f24af1fdca91c3
[20:03:37] <nmatsakis> engla: see the later fixes
[20:03:38] <maik> cool I think I understand tasks now https://gist.github.com/anonymous/6244290
[20:03:42] <engla> ok
[20:04:08] <engla> sorry
[20:04:28] <nmatsakis> ...or we have to define a variety of conditions, probably based on how many args they take by ref and how many by value
[20:04:37] *** Joins: mihneadb (Mihnea@moz-BBE3ABD.mv.mozilla.com)
[20:04:40] <nmatsakis> e.g., Condition11<A,B> would correspond to fn(&A, B)
[20:04:51] <nmatsakis> anyway, gotta run, this is something graydon and I need to talk about I think :)
[20:05:00] <Eridius> ok
[20:06:03] <SimonSapin> Is "-D default-methods" still default in recent Rust?
[20:06:29] <cmr> no
[20:06:50] <cmr> The lint doesn't even exist anymore
[20:07:49] *** Quits: maik (maik___@moz-CB2146E0.dip0.t-ipconnect.de) (Ping timeout)
[20:07:54] <SimonSapin> but default methods are not considered experimental anymore, right?
[20:08:05] <cmr> no
[20:08:19] <toddaaro> brson: I'm going to move onto a different project and leave callback stuff for now
[20:08:59] <toddaaro> brson: I'm considering some sort of better runtime logging, so that each line is tagged with task or thread id, and it is routed through a logger task of some sort to eliminate interleaving
[20:09:09] <SimonSapin> cmr: sorry I have trouble with double negation. No theyâ€™re not?
[20:09:22] <cmr> SimonSapin: They are no longer experimental
[20:09:25] <toddaaro> brson: this will probably be somewhat of an engineering project to deal with nested runtimes sharing a logger
[20:09:34] <SimonSapin> cool, thanks
[20:09:36] <jack> does -A default-methods do anything anymore?
[20:09:37] <toddaaro> brson: (otherwise the anti-interleaving is useless)
[20:10:03] <cmr> jack: yeah, throws an error because of unknown lint
[20:10:11] <toddaaro> brson: does this sound like a worthwhile use of some of my time? it might make it easier to figure out what is going on in the various races, as we seem to spend lots of time on races now
[20:13:04] <toddaaro> brson: the alternative would be "work around but not understand" the idle callback problems, but I don't know how to work around nondeterministic deadlock
[20:16:40] *** Joins: snadon (chatzilla@moz-3BC727E8.mc.videotron.ca)
[20:18:37] *** Quits: brendan (brendaneic@A01051A9.6F669779.3D1CA460.IP) (Quit: brendan)
[20:19:51] *** Quits: reyre (reyre@B2D8AB09.33EE9F8A.1139E686.IP) (Quit: Konversation terminated!)
[20:19:55] *** flaper87|afk is now known as flaper87
[20:23:08] <toddaaro> rusti: let x: ~str = ~"120"
[20:23:08] -rusti- <anon>:6:4: 6:5 error: expected `;` but found `}`
[20:23:08] -rusti- <anon>:6     };
[20:23:08] -rusti-              ^
[20:23:08] -rusti- application terminated with error code 101
[20:23:09] *** Joins: ghrust (ghrust@79968228.6A2AE50.F3114085.IP)
[20:23:09] <ghrust> 01[13rust01] 15bors 04force-pushed 06auto from 14ba55317 to 14fc3297f: 02http://git.io/N3iJvQ
[20:23:09] *** Parts: ghrust (ghrust@79968228.6A2AE50.F3114085.IP) ()
[20:23:09] *** Joins: ghrust (ghrust@DE823A67.6A2AE50.F3114085.IP)
[20:23:09] <ghrust> 01[13rust01] 15bors pushed 8 new commits to 06auto: 02http://git.io/IggkFg
[20:23:09] <ghrust> 13rust/06auto 142261cb7 15Daniel Micay: ptr: inline the Clone implementation
[20:23:09] <ghrust> 13rust/06auto 14de83112 15Daniel Micay: kinds: update documentation
[20:23:10] <ghrust> 13rust/06auto 148a5437d 15Daniel Micay: update the iterator tutorial
[20:23:12] *** Parts: ghrust (ghrust@DE823A67.6A2AE50.F3114085.IP) ()
[20:23:12] <toddaaro> rusti: let x: ~str = ~"120";
[20:23:13] -rusti- <anon>:5:13: 5:14 warning: unused variable: `x` [-W unused-variable (default)]
[20:23:13] -rusti- <anon>:5          let x: ~str = ~"120";
[20:23:13] -rusti-                       ^
[20:23:13] -rusti- ()
[20:23:13] *** Joins: azita (Azita@moz-BBE3ABD.mv.mozilla.com)
[20:23:18] <toddaaro> rusti: let x: ~str = ~"120"; x
[20:23:18] -rusti- ~"120"
[20:24:14] *** Quits: ecr (Thunderbir@moz-BBE3ABD.mv.mozilla.com) (Ping timeout)
[20:24:49] *** Quits: brson (brson@moz-BBE3ABD.mv.mozilla.com) (Ping timeout)
[20:26:13] <jfbk> i'm trying to implement a simple multicast:  https://gist.github.com/jfager/6244468
[20:26:20] *** Quits: tjc (tjc@moz-BBE3ABD.mv.mozilla.com) (Quit: zzzzzzzzzz)
[20:26:45] <jfbk> got it compiling, but instantly dies w/ all tasks 'receiving on closed channel'
[20:26:58] <jfbk> anyone see anything obvious I'm doing wrong?
[20:29:20] <Eridius> jfbk: unrelated observation: You don't actually need ch_ch, since msg_ch has the same enumeration type, and your code will behave the same if you pass a MsgChan on either channel
[20:29:46] *** Joins: huseby (huseby@19BD73A1.5D8BCA3A.A0C1B52F.IP)
[20:31:04] <Eridius> jfbk: also, you're only pushing 9 values to the channels. When the main function ends, and mc goes out of scope, your spawned tasks will still be alive and will attempt to read too many values
[20:31:14] * Eridius hasn't used ports/chans yet though, so isn't familiar with the precise behavioral semantics
[20:31:39] * Eridius also doesn't know how rust behaves if you have outstanding tasks when the main task ends
[20:32:18] <jfbk> doh, good catch on the off-by-one, thanks.  doesn't make a difference, though
[20:32:24] *** Joins: dim-an (ermolovd@moz-FE167E47.nationalcablenetworks.ru)
[20:33:06] <Eridius> jfbk: when I run it, p0 prints that it got 9 values before I gt the errors
[20:33:35] *** Joins: brson (brson@moz-BBE3ABD.mv.mozilla.com)
[20:33:35] *** ChanServ sets mode: +o brson
[20:33:46] <Eridius> and if I fix the off-by-one error, po0 no longer errors (but mc, po1, and po2 do)
[20:34:00] <dim-an> hi,
[20:34:02] <dim-an> I want to iterate through list of pairs, destructuring them, something like
[20:34:06] <dim-an> for (a, b) in [(1,2), (3,4)].iter() { /* do smth */ }
[20:34:10] <dim-an> is it possible?
[20:34:33] <Eridius> rusti: for (a, b) in (~[(1,2), (3,4)]).move_iter() { printfln!("%d, %d", a, b) }
[20:34:33] -rusti- 1, 2
[20:34:34] -rusti- 3, 4
[20:34:34] -rusti- ()
[20:34:47] <Eridius> dim-an: .iter() will yield &(a,b) instead of (a,b)
[20:35:05] <Eridius> rusti: for &(a,b) in [(1,2),(3,4)].iter() { printfln!((a,b)) }
[20:35:07] -rusti- pastebinned 11 lines of output: http://ix.io/7jP
[20:35:14] <Eridius> damn rvalue issue
[20:35:27] <Eridius> rusti: let xs = [(1,2),(3,4)]; for &(a,b) in xs.iter() { printfln!((a,b)) }
[20:35:28] -rusti- (1, 2)
[20:35:28] -rusti- (3, 4)
[20:35:28] -rusti- ()
[20:35:42] <Eridius> that only works with implicitly copyable values, e.g. primitive numbers
[20:36:11] <dim-an> Eridius: thanks!
[20:37:27] <dim-an> I'm still little bit confused with all that types of pointers in Rust. :(
[20:37:44] <cmr> dim-an: I'm writing a memory management tutorial that will hopefully clear it up
[20:38:01] <dim-an> cmr: that's cool!
[20:38:24] <myname> while we are at it: does anybody has any idea for a little project to actually learn rust a bit but not that big that you scream around after an update
[20:38:34] <myname> (i.e. it can be thrown away)
[20:38:46] <Eridius> myname: you could try the matasano crypto challenge
[20:39:10] <cmr> Or write a tic-tac-toe AI, for N-dimensional boards
[20:39:46] <myname> cmr: i do think people at university had to do that, but i like the idea
[20:40:06] <strcat> cmr: good sample program for the web UI thing ;p
[20:40:11] <Eridius> jfbk: this works for me: https://gist.github.com/kballard/6244625
[20:40:15] <cmr> heh
[20:40:17] <jfbk> Eridius: using just the one stream and getting rid of the select wfm.  got so hung up on trying to get select to work didn't notice that the 'hack' was actually the solution 
[20:40:32] * strcat was already benchmarking minimax for something else in rust
[20:40:57] <Eridius> jfbk: you need to kill the multicast loop too, which is why my solution adds a Close message and a Drop impl
[20:41:01] <Eridius> (sadly, needs #[unsafe_destructor])
[20:41:21] <Eridius> I mean, you could use an explicit .close() instead, but that's ugly
[20:41:51] <Eridius> actually, .try_recv would fix that
[20:42:39] <Eridius> jfbk: I updated my gist to use .try_recv instead of the destructor
[20:42:49] <jfbk> Eridius: nice, thanks!
[20:42:55] <Eridius> and I suppose the do_something loops could also switch over to .try_recv
[20:42:58] <Eridius> instead of explicit counts
[20:44:00] *** Quits: maxli (maxli@13F2CEC5.7672369.D8E68FF6.IP) (Quit: Leaving.)
[20:44:06] <Eridius> jfbk: yep, that worked. gist updated again
[20:44:12] <kmc> where do I break to get a backtrace on task failure?
[20:44:14] <kmc> in gdb I mean
[20:44:17] <Eridius> rust_begin_unwind
[20:44:22] <kmc> RUST_LOG=::rt::backtrace=4 does not help :/
[20:44:24] <kmc> ok thanks
[20:44:27] <Eridius> ::rt::backtrace is gone
[20:44:31] <cmr> the ::rt::* stuff is gone
[20:45:40] <kmc> ok
[20:45:47] <kmc> still in the manual
[20:47:00] <Eridius> there's a PR right now that removes it from the ICE message. I guess manual needs to be updated too
[20:47:11] <Eridius> #8530
[20:47:24] <cmr> r? https://github.com/mozilla/rust/pull/8540
[20:47:30] <cmr> Well, no, not r?
[20:47:36] <cmr> needs work still, for the buildsystem
[20:50:12] *** Joins: ghrust (ghrust@24260B07.6A2AE50.F3114085.IP)
[20:50:12] <ghrust> 01[13rust01] 15bors 04force-pushed 06auto from 14091d4e8 to 14fc3297f: 02http://git.io/N3iJvQ
[20:50:12] *** Parts: ghrust (ghrust@24260B07.6A2AE50.F3114085.IP) ()
[20:50:13] *** Joins: ghrust (ghrust@2EE61FCC.6A2AE50.F3114085.IP)
[20:50:13] <ghrust> 01[13rust01] 15bors pushed 2 new commits to 06auto: 02http://git.io/x2x84w
[20:50:13] <ghrust> 13rust/06auto 1415159a5 15Kevin Ballard: Rewrite Saturating in terms of CheckedAdd/CheckedSub
[20:50:13] <ghrust> 13rust/06auto 145c0d192 15bors: auto merge of #8515 : kballard/rust/saturating-checked, r=thestinger...
[20:50:14] *** Parts: ghrust (ghrust@2EE61FCC.6A2AE50.F3114085.IP) ()
[20:50:33] <Eridius> oh great, I got the "ld: library not found for -lmorestack" build error again. What causes that?
[20:50:55] <Eridius> last time a `make clean` fixed it, but I'd like to figure out what's broken
[20:51:14] <cmr> Eridius: are you building with -jfoo? Is it reproducable with additional `make`s?
[20:51:23] <Eridius> also a warning about no -L/Users/kevin/Dev/rust/rust/.rust
[20:51:56] <Eridius> cmr: yeah I built with -j4. Just tried explicitly rebuilding libstd.dylib since I thought that was what it was doing, and this time it worked
[20:52:20] <cmr> Eridius: I think it's a race condition due to improper dependencies
[20:52:23] <cmr> I don't actually know though
[20:52:27] <Eridius> that sound plausible
[20:53:13] <Eridius> there was no line about building libmorestack, so I'm not sure what it was necessarily doing in parallel
[20:53:28] *** Joins: maik (maik___@moz-CB2146E0.dip0.t-ipconnect.de)
[20:54:15] <strcat> rusti: 2
[20:54:16] -rusti- playpen: bind mount: No such file or directory
[20:54:16] -rusti- application terminated with error code 1
[20:54:19] *** Joins: lucian (lucian@moz-22A14C6A.cable.virginmedia.com)
[20:54:28] *** Quits: rusti (rusti@moz-54F7FD49.cpe.net.cable.rogers.com) (Client exited)
[20:54:34] *** Joins: rusti (rusti@moz-54F7FD49.cpe.net.cable.rogers.com)
[20:54:35] <strcat> rusti: 2
[20:54:36] -rusti- 2
[20:59:44] *** Quits: azita (Azita@moz-BBE3ABD.mv.mozilla.com) (Quit: azita)
[21:00:41] *** Quits: gareth0 (gareth0@moz-74F9D207.dynamic.dsl.as9105.com) (Input/output error)
[21:00:59] *** Joins: azita (Azita@moz-BBE3ABD.mv.mozilla.com)
[21:01:22] *** Quits: eschweic1 (Adium@moz-BBE3ABD.mv.mozilla.com) (Quit: Leaving.)
[21:02:58] <cmr> graydon: https://github.com/mozilla/rust/pull/8540 (github seems to not be sending cc emails)
[21:03:02] <cmr> at least to me..
[21:03:09] *** Quits: mmmonk (mmmonk@moz-F145F0FF.xlshosting.net) (Ping timeout)
[21:04:17] <olsonjeffery> what's the env var to run the build w/ valgrind?
[21:04:20] <olsonjeffery> build/tests
[21:05:32] *** Quits: msingle (Thunderbir@moz-930E5D97.hr.hr.cox.net) (Quit: msingle)
[21:07:31] <maik> how do I convert a string to a number?
[21:09:59] *** Joins: tjc (tjc@moz-BBE3ABD.mv.mozilla.com)
[21:10:00] *** ChanServ sets mode: +o tjc
[21:10:18] <Eridius> rusti: let x: Option<int> = from_str("324"); x
[21:10:18] -rusti- <anon>:5:30: 5:38 error: unresolved name `from_str`.
[21:10:18] -rusti- <anon>:5          let x: Option<int> = from_str("324"); x
[21:10:18] -rusti-                                        ^~~~~~~~
[21:10:19] -rusti- error: aborting due to previous error
[21:10:19] -rusti- application terminated with error code 101
[21:10:25] <Eridius> rusti: ues std::from_str; let x: Option<int> = from_str("324"); x
[21:10:26] -rusti- <anon>:5:13: 5:16 error: expected one of `; }` but found `std`
[21:10:26] -rusti- <anon>:5          ues std::from_str; let x: Option<int> = from_str("324"); x
[21:10:26] -rusti-                       ^~~
[21:10:26] -rusti- application terminated with error code 101
[21:10:32] <Eridius> rusti: use std::from_str; let x: Option<int> = from_str("324"); x
[21:10:33] -rusti- <anon>:5:49: 5:57 error: unresolved name `from_str`.
[21:10:33] -rusti- <anon>:5          use std::from_str; let x: Option<int> = from_str("324"); x
[21:10:33] -rusti-                                                           ^~~~~~~~
[21:10:33] -rusti- error: aborting due to previous error
[21:10:35] -rusti- application terminated with error code 101
[21:10:41] <Eridius> rusti: use std::from_str::from_str; let x: Option<int> = from_str("324"); x
[21:10:43] -rusti- pastebinned 8 lines of output: http://ix.io/7jW
[21:10:56] <Eridius> oh it's a trait. I need to read better
[21:10:58] <maik> there is a to_int() trait but str doesn't implement it
[21:11:19] <Eridius> rusti: use std::from_str::FromStr; let x: Option<int> = FromStr::from_str("324"); x
[21:11:20] -rusti- Some(324)
[21:11:35] <maik> oh
[21:11:36] <maik> ok
[21:11:38] *** Joins: mmmonk (mmmonk@moz-F145F0FF.xlshosting.net)
[21:11:58] <Eridius> rusti: std::int::from_str("324")
[21:11:59] -rusti- Some(324)
[21:12:01] <Eridius> that also exists
[21:12:20] <Eridius> (not documented because it's implemented using a macro)
[21:12:20] *** Joins: eschweic (Adium@moz-BBE3ABD.mv.mozilla.com)
[21:12:30] <cmr> (but it is documented in rustdoc_ng!)
[21:12:37] <Eridius> cmr: woo!
[21:12:43] <cmr> Eridius: have you seen it yet?
[21:12:47] <cmr> I know you were on vacation
[21:12:48] *** Joins: eschweic1 (Adium@moz-BBE3ABD.mv.mozilla.com)
[21:12:52] <Eridius> nope
[21:12:53] *** Quits: eschweic (Adium@moz-BBE3ABD.mv.mozilla.com) (Connection reset by peer)
[21:12:57] <cmr> http://seld.be/rustdoc/master/index.html
[21:13:30] <Eridius> sweet. But I don't see int::from_str :P
[21:13:46] <Eridius> oh there's a sub-module generated
[21:13:48] <Eridius> cute
[21:14:01] <cmr> the macro does that
[21:14:19] *** Quits: strcat (strcat@moz-54F7FD49.cpe.net.cable.rogers.com) (Quit: WeeChat 0.4.1)
[21:14:27] *** Quits: rusti (rusti@moz-54F7FD49.cpe.net.cable.rogers.com) (Client exited)
[21:14:30] *** Quits: lucian (lucian@moz-22A14C6A.cable.virginmedia.com) (Input/output error)
[21:15:39] *** Joins: rusti (rusti@moz-54F7FD49.cpe.net.cable.rogers.com)
[21:15:47] <Eridius> I like how the trait impls show up in the docs for the trait
[21:16:01] <Eridius> ooh it even works cross-module
[21:16:09] <cmr> cross-crate
[21:16:16] <Eridius> oh nice
[21:17:18] <Eridius> cmr: doesn't look like cross-crate to me. I don't see extra::treemap::TreeMap showing up as an impl of std::container::Container
[21:17:49] <cmr> Seldaek: Do you not search for impls across crate boundaries?
[21:18:24] *** flaper87 is now known as flaper87|afk
[21:18:35] *** flaper87|afk is now known as flaper87
[21:18:49] <Eridius> the docs for extra::treemap::TreeMap show what it implements, but the regular docs do that too
[21:19:00] <Eridius> (although this at least gives the fully-qualified path to what it implements)
[21:19:07] *** Joins: int3_ (int3_@moz-ABE52D50.hsd1.ca.comcast.net)
[21:19:24] <brson> toddaaro: rust's logging is pretty bad, so improvements there would be good. there's an issue open about doing a redesign somewhere but github's not finding it. does the scope of what you want to do include general rust logging or is it just for the runtime?
[21:19:47] <cmr> https://github.com/mozilla/rust/issues/3309
[21:19:55] <cmr> I also want to work on that issue
[21:21:04] *** Quits: jaen (jaen@moz-E0979827.copit.pl) (Ping timeout)
[21:21:38] <toddaaro> brson: "it depends" I guess, general rust logging and runtime logging diverge a fair bit in what they do and how they should do it, a general system could just have a LoggerTask which would be great, and you use pipes to send it messages, and blah blah async lightweight funtimes. Implementing the runtime log that way doesn't really work, as using the runtime to do runtime logging makes it no longer an observer. So for runtime logging I started hacking on s
[21:21:43] *** Joins: richard|s (mindginati@moz-C1729134.dsl.clear.net.nz)
[21:22:42] <toddaaro> brson: there is also performance - I think this approach for a runtime log will be kinda meh, as creating new remote callbacks is tricky and requires synchronization between threads
[21:22:58] <toddaaro> but right now rtdebug is so naive it can't be worse
[21:23:04] *** Quits: robarnold (rob@BD56354E.DB510C09.6E370BFC.IP) (Ping timeout)
[21:23:21] <cmr> toddaaro: truncated at "I started hacking on s"
[21:23:30] *** flaper87 is now known as flaper87|afk
[21:23:33] *** Joins: ecr (Thunderbir@moz-BBE3ABD.mv.mozilla.com)
[21:23:49] <toddaaro>  I started hacking on something that is just a libuv loop in a different thread that 
[21:23:52] <toddaaro>                   handles LogMessages send via remote callback (in the same style as a scheduler)
[21:24:24] <toddaaro> cmr: if you are interested in "normal" rust logging that would be a pretty awesome little project, I think it would be very easy to do as you simply use scheduler primitives to do all the work
[21:24:37] <cmr> toddaaro: yup!
[21:24:49] <cmr> I was inspired when I saw how cool q3's logger was in comparison to the Rust one
[21:25:18] <toddaaro> real loggers are pretty fancy
[21:25:51] <toddaaro> stitching together runtime logging "outside" and "normal" logging inside seems kinda messy
[21:25:54] *** Joins: jgilbert (jgilbert@moz-BBE3ABD.mv.mozilla.com)
[21:25:57] <cmr> I have a full plate though, can't really tackle much until rustdoc_ng is mainlined and https://github.com/mozilla/rust/issues/7532 is sufficiently covered
[21:26:03] *** Quits: victorporof (victorporo@DBFC8886.2203F6DA.D111398B.IP) (Ping timeout)
[21:26:05] *** Joins: reyre (reyre@moz-9002CDDA.cpe.net.cable.rogers.com)
[21:26:19] <toddaaro> but it might be easy if the "normal" log's print function is to send to the "outside" log
[21:26:31] <bblum> i'm a runtime and i'm okay; i sleep all night and i log all day
[21:26:49] <ecr> bblum +1
[21:26:49] <toddaaro> but then that requires that our "outside" log be fast and not slow
[21:27:28] <Seldaek> cmr: not sure anymore, but no it might be that I don't (yet?)
[21:27:39] <toddaaro> the tricky bit is creating a new handle to the logger, as you can't do that from a different thread, so you have to send it a message to make a new handle, but then you need to receive that message somehow, exactly a oneshot usecase but no oneshots exist in this context
[21:27:56] <toddaaro> a fancy implementation could do something with a handle pool perhaps
[21:29:07] <toddaaro> cmr: ah yes, I can't wait for that
[21:29:21] <cmr> toddaaro: for #7532?
[21:29:27] <toddaaro> cmr: rustdo
[21:29:28] <toddaaro> c
[21:29:30] <cmr> oh
[21:29:56] <cmr> all that's left really is the hard part, which Seldaek has been doing awesomely
[21:30:02] <brson> toddaaro: which interleaving are you trying to avoid in the runtime logging? there's a general issue that effects logging where write_line flushes the newline to the output stream seperately. are there additional issues?
[21:30:38] <cmr> toddaaro: also if you're talking about runtime logging, I wouldn't expect it to be so complicated. I see it as a debugging thing infrequently used. although as a rt dev you probalby use it all the time :p
[21:30:45] <toddaaro> brson: it seems really interleaved, words cut apart in more elaborate ways than just newline misses
[21:31:03] <Seldaek> toddaaro: if you do a better official or at least standalone logger, maybe consider supporting all 8 severity levels from http://tools.ietf.org/html/rfc5424#section-6.2.1
[21:31:33] <Seldaek> just saying because I think I saw the q3 one had only 4
[21:32:01] <cmr> the rust logger as it stands now takes an arbitrary integer
[21:32:06] *** Quits: nano (nano@moz-74CAD1CA.superkabel.de) (Connection reset by peer)
[21:32:07] <cmr> we just have macros for the 4 useful ones
[21:32:21] <toddaaro> brson: if there is just a simple thing I can do about that issue and that cleans up all the weirdness that would be great
[21:32:31] <Seldaek> I find the granularity of those 8 somewhat standard ones is useful at times
[21:32:44] <toddaaro> brson: I'm not super excited to design a nice runtime logger, I just want to use it
[21:32:52] <Seldaek> not for quick debugging, but for serious business logging in web apps..
[21:33:42] * cmr was going to look to some big java/.net loggers for inspiration
[21:33:52] <Seldaek> cmr: please don't :p
[21:34:26] <toddaaro> brson: is there just an argument to write_line that will make it flush the newline together?
[21:34:42] <maik> AOP is great for loggers
[21:34:54] <toddaaro> there are a lot of fancy loggers
[21:35:01] <Seldaek> cmr: I'd (biasedly) say look at https://github.com/Seldaek/monolog or http://pythonhosted.org/Logbook/ where I looked for inspiration, or there's someone that ported it to go as well I think if you prefer reading that
[21:35:07] <toddaaro> I feel like someone could get bogged down for months learning abotu what exists
[21:35:43] <maik> do you think aop is possible in Rust?
[21:36:01] <sigma> Erlangs logging system might be worth looking into
[21:36:06] <cmr> maik: seems like it'd be trivial with trait objects?
[21:36:34] <brson> toddaaro: actually, write_line does have this problem, but rtdebug appears not to be using it. rt::util::dumb_println is just calling write_str twice. if the problem is only at newlines then making that function concatenate the newline before writing the string might fix the problem
[21:36:44] <brson> also, github appears to have issue search turned off
[21:36:48] <toddaaro> brson: that, would be easy
[21:36:49] <Seldaek> toddaaro: my monolog lib supports 10-15 logging services as backends, and we managed to map to all of those reasonably well with a simple "message, context" interface, where context is arbitrary data. Not sure how you'd do that in rust though
[21:36:49] <brson> github is a real drag today
[21:37:14] <maik> cmr, can we implement traits on types that are not in the same module?
[21:37:22] <cmr> maik: yes
[21:37:29] <cmr> same crate, even.
[21:37:33] <cmr> as long as it's your own trait
[21:37:38] <cmr> (for coherency reasons)
[21:38:02] <maik> yeah then it should be possible
[21:38:15] <maik> well
[21:38:17] <maik> hm
[21:38:36] <toddaaro> Seldaek: that sounds fancy, I think if we set up an event loop as a logging bus that thread could dispatch to the various supporting loggers
[21:39:17] <cmr> "FingersCrossedHandler"
[21:39:20] <cmr> That is the perfect name
[21:39:30] <toddaaro> brson: yea this logging.rs file is hilariously simple, I'll try making that one call to write_str
[21:39:33] <olsonjeffery> busy busy busy
[21:39:36] *** Quits: saml (sam@moz-14C16814.cst.lightpath.net) (Quit: Leaving)
[21:39:40] <Seldaek> cmr: yeah I stole that from logbook but it is just an awesome name
[21:40:06] <Seldaek> cmr/toddaaro: ah there is the port in go I was mentioning.. https://github.com/marcw/gogol
[21:40:23] <Seldaek> didn't look at it much though
[21:40:35] *** Joins: Liothen (liothen@moz-80EF0CD7.spkn.qwest.net)
[21:40:51] <maik> cmr, well no, no quite. in aop you can hook up any function that you want and then execute custom logic before, after or at the function call
[21:41:02] <Eridius> toddaaro: I thought the problem with write_line is the only way to make it a single syscall is to allocate a new string with the newline
[21:41:07] *** Quits: huseby (huseby@19BD73A1.5D8BCA3A.A0C1B52F.IP) (Connection reset by peer)
[21:41:16] *** Joins: huseby (huseby@19BD73A1.5D8BCA3A.A0C1B52F.IP)
[21:41:25] <toddaaro> Eridius: hm?
[21:42:01] <Eridius> toddaaro: you asked how to make it flush the newline together
[21:42:12] *** Joins: Jesin (Jessin_@moz-157A63DD.cc.lehigh.edu)
[21:42:17] <cmr> maik: could you give an example? (in any language (within reason))
[21:42:24] <maik> cmr, AspectJ
[21:42:26] <Eridius> the problem is Rust doesn't buffer the output, it just calls directly to the underlying write(), so it needs 2 write()'s to stick a newline on there. Anything else requires allocation
[21:42:27] *** Joins: Black (Mibbit@moz-25ED1BAB.net.uwaterloo.ca)
[21:42:37] <toddaaro> Eridius: ah, ok
[21:42:38] <maik> cmr, it changes the bytecode
[21:42:58] <toddaaro> Eridius: yea, at this level of logging an allocation is not at all a drawback
[21:43:43] <maik> cmr, http://101companies.org/wiki/Script:Aspect-oriented_programming
[21:43:43] <Eridius> toddaaro: ok, I don't know the context of what you're trying to do. If you want to write a higher-level logger that is happy doing allocations, then you can certainly solve the newline problem
[21:43:50] *** Joins: obk (Mibbit@moz-B0F26027.red.bezeqint.net)
[21:44:58] <toddaaro> Eridius: ah, context. My main focus is the rtdebug! macro, which allows us to allocate and spew forth dozens of strings per scheduler doing anything so performance is kinda shot there. In a proper logging situation we would have to come up with something else to handle the newlines.
[21:45:40] <cmr> maik: http://www.eecs.ucf.edu/FOAL/slides-2007/Sulzmann-Wang.pdf
[21:46:53] *** Quits: Black (Mibbit@moz-25ED1BAB.net.uwaterloo.ca) (Quit: http://www.mibbit.com ajax IRC Client)
[21:48:15] <toddaaro> brson: trading the second call to write_string to an allocation to add the newline did the trick! no idea that would be so easy
[21:48:38] <toddaaro> brson: now that it doesn't interleave weirdly I'll add a few helpers to print task/sched ids
[21:48:46] <toddaaro> hopefully will make runtime work easier
[21:49:32] *** Joins: KindOne (KindOne@moz-3EA9DB0E.dynamic.ip.windstream.net)
[21:49:51] <obk> If I have a &[MyType], how do I get a ~[MyType]? Calling .clone() doesn't work...
[21:49:52] <maik> cmr, exactly yeah
[21:50:19] <maik> cmr, that would make a logger extremely trivial
[21:50:30] <brson> toddaaro: yeah, having it print the scheduler and task id's would be *much* better
[21:50:31] <cmr> obk: .to_owned()
[21:50:33] <Eridius> obk: .to_owned() will work, as long as MyTime implements Clone
[21:50:37] <bblum> obk: to_owned()
[21:50:40] <Eridius> err MyType
[21:50:45] <cmr> \o/ I win!
[21:50:51] <Eridius> cmr: your answer was incomplete!
[21:51:00] <obk> So... what's the difference between .clone() and .to_owned()?
[21:51:04] <toddaaro> brson: I'll futz around with the macro, I think I can make it pull the info from TLS
[21:51:24] <toddaaro> hm, perhaps sched_id would be tricky
[21:51:32] *** Quits: heftig (heftig@moz-4A54E499.dip0.t-ipconnect.de) (Ping timeout)
[21:51:32] <obk> I guess it depends what you start with...
[21:51:33] <Eridius> obk: .clone() is implemented on ~[A], not &[A]
[21:51:47] <cmr> obk: to_owned takes a slice and converts it into a vector, copying every element
[21:51:49] <maik> obk, clone copies and to.owned boxes it so it is ~
[21:52:01] <Eridius> on most types, .clone() is on the T and it just works on &T, but &[] (and ~[] and @[]) is special
[21:52:12] <cmr> maik: so afaict "real" AOP requires hijacking arbitrary functions and inserting code in/around them?
[21:52:17] <obk> I see...
[21:52:18] <obk> Thanks
[21:52:44] <Eridius> anyone know how I can ask the makefile to run the run-pass tests (ideally for a specific stage)?
[21:53:05] <maik> cmr, yes the advantage is that you never have to touch your code. You just write some AOP rules which injects some functions into your code
[21:54:40] <Eridius> oh hey `make check-fast` builds the stage2 run-pass tests. that's convenient
[21:54:41] <engla> cmr: since "pub use" is the last remaining feature in rustdoc_ng, does it display methods/impls for enums now?
[21:54:55] <sigma> heh
[21:54:58] <sigma> wrong chat
[21:55:10] <maik> its a trap
[21:55:24] <cmr> engla: I think so?
[21:55:33] <cmr> engla: did it not before?
[21:55:36] * cmr looks
[21:55:52] <cmr> engla: nope
[21:55:54] <engla> no impls for std::option. I'm only looking in the seld.be site
[21:55:56] <cmr> Seldaek: http://seld.be/rustdoc/master/std/option/enum.Option.html
[21:56:17] <cmr> maik: seems really hokey
[21:56:18] *** Quits: tiffany (kawaii@moz-EB8B0C08.dhcp.embarqhsd.net) (Ping timeout)
[21:56:36] <cmr> fragile
[21:56:57] <cmr> What can you do that doesn't depend on the implkementation details of the thing you're adding the aspect to?
[21:57:05] <engla> also, as I already discussed with Seldaek, currently displaying priv items too, like statics, enums, functions, methods. Sure that can be useful
[21:57:07] <cmr> And if nothing, how is that different than implementing a trait?
[21:57:22] <cmr> engla: rust allows you to use priv items and a lot of code depends on that behavior
[21:57:28] <cmr> until it's fixed, rustdoc will show priv items
[21:57:50] *** Joins: tiffany (kawaii@moz-EB8B0C08.dhcp.embarqhsd.net)
[21:57:53] <sigma> AOP in Java is one of those things that feels really like a hacked together fix for a missing language feature
[21:58:20] <Eridius> oh hey, rustdoc_ng shows std::Rt!
[21:58:22] <Eridius> s/R/r/
[21:58:38] <engla> well ok. all the internal stuff might clutter up the docs though.
[21:59:04] *** Joins: heftig (heftig@moz-740E747A.dip0.t-ipconnect.de)
[21:59:05] *** Quits: brson (brson@moz-BBE3ABD.mv.mozilla.com) (Ping timeout)
[21:59:24] *** Joins: brson (brson@moz-BBE3ABD.mv.mozilla.com)
[21:59:24] *** ChanServ sets mode: +o brson
[21:59:45] <maik> cmr, well lets say you have 10000 lines print("42")  in your code.  Then you can write sth like "before aspect print(x){ assert!(x,42)}"
[21:59:52] <bblum> tjc: is this your fault
[21:59:54] <bblum> "// >:-<"
[21:59:59] <engla> I didn't know rust was that leaky with its privates
[22:00:04] <maik> and it would assert all of your prints
[22:00:41] <sigma> it's like monkey patching on a decorator in python
[22:00:50] <sigma> at least it feels like that to me
[22:01:57] <maik> cmr, or if you have sth like  mstruct.set_value(-10), then you could do   "after aspect .set_my_value(x){ assert!(x,-10);"
[22:02:48] <Seldaek> sigma: you haven't seen what some people do to get AOP in php.. that is real hackery
[22:03:34] *** Quits: bnicholson (bnicholson@moz-BBE3ABD.mv.mozilla.com) (Quit: Ex-Chat)
[22:04:01] <maik> it's nice for testing/logging
[22:04:20] <sigma> Seldaek: php irritates me at the best of times, I don't see this improving my opinion :)
[22:04:33] <aatch> Seldaek, oh god the reflection abuse...
[22:04:51] *** Quits: azita (Azita@moz-BBE3ABD.mv.mozilla.com) (Quit: azita)
[22:05:23] <maik> "I am PHP dev and I write code that looks like this "$$$$$$$$$" all day, damn I feel so rich"
[22:05:46] <Seldaek> sigma: well, I do a lot of work with it and it gets the job done, but trying to make it do things it's not meant to results in horrendous things
[22:06:26] <aatch> Seldaek, we were using a framework that did that. It worked well enough, but god was it slow
[22:06:36] <Seldaek> aatch: flow3?
[22:06:41] <sigma> I have to use it sometimes, and I know it's good in some domains, but some of the behaviour is incredibly counter-intuitive...
[22:06:43] <aatch> Seldaek, Silverstripe
[22:06:49] *** Quits: tjc (tjc@moz-BBE3ABD.mv.mozilla.com) (Quit: zzzzzzzzzz)
[22:07:05] <Seldaek> aatch: oh, yeah that doesn't count as framework in my head:p but I don't know how they did it.
[22:07:43] *** Joins: azita (Azita@moz-BBE3ABD.mv.mozilla.com)
[22:07:43] *** Quits: eatkinson (eatkinson@moz-BBE3ABD.mv.mozilla.com) (Quit: eatkinson)
[22:07:45] <Seldaek> aatch: althoguh yes usually it works reasonably well, but I don't get why people go through so many hoops, because yes AOP can be nice in a few cases, but it's not really a major hindrance not to have it
[22:08:15] <aatch> Seldaek, well we're now making our own mini-framework/library, designed for HipHop
[22:08:24] <Seldaek> heh
[22:08:26] *** Quits: wilmoore (wilmoore@moz-7EE4D9D6.mystrotv.com) (Ping timeout)
[22:08:48] <aatch> And by 'now' I mean we started about two weeks ago and are almost done with it.
[22:08:50] <bblum> sully: ping
[22:09:00] <bblum> sully: can you tell me about how supertraits are encoded in metadata
[22:09:05] <bblum> grep is suggesting that they... aren't
[22:09:25] <Seldaek> aatch: yeah if you reuse some libs these days you can get a pretty good micro framework without much work
[22:10:02] <aatch> Seldaek, well the only external PHP libs we're using are PHPUnit and XHP
[22:10:13] <aatch> XHP is actually built into HipHop anyway.
[22:10:21] *** Quits: KindOne (KindOne@moz-3EA9DB0E.dynamic.ip.windstream.net) (Ping timeout)
[22:10:23] *** Joins: wilmoore (wilmoore@moz-7EE4D9D6.mystrotv.com)
[22:10:57] <aatch> Everything else is just simple. I think page routing came out as one of the most complex subsystems
[22:11:11] <Seldaek> aatch: really, well ok if you target hiphop it's tough to use much libs I suppose. But IMO good libs providing decent abstraction for php's silliness are really valuable, and last few years there is a bunch of good libs that appeared
[22:12:23] <aatch> Seldaek, I wouldn't really know. Part of the issue is that we're writing a application and almost everything PHP related seems to be geared towards building websites.
[22:12:39] *** Quits: maik (maik___@moz-CB2146E0.dip0.t-ipconnect.de) (Ping timeout)
[22:14:19] *** Joins: lucian (lucian@moz-22A14C6A.cable.virginmedia.com)
[22:14:48] <Seldaek> aatch: that's not true I think, we're building fairly complex custom web apps, usually symfony2 API and a backbone.js frontend. You still have to do the hard business logic stuff, but the rest is fairly simple
[22:15:29] <Seldaek> but anyway I didn't mean to sidetrack the channel into a php debate :P
[22:16:02] *** Joins: eatkinson (eatkinson@moz-BBE3ABD.mv.mozilla.com)
[22:16:05] <aatch> Seldaek, fair enough, I wouldn't call it a debate though, more a discussion. It's off topic either way though.
[22:16:29] <toddaaro> hm, maybe this logging macro change isn't so easy after all
[22:16:32] <toddaaro> it is ICEing
[22:17:20] <Seldaek> aatch: aye, happy to discuss it further if you like though ;)
[22:19:24] <aatch> Seldaek, nah, it's fine. I have a bit of a love-hate relationship with PHP, probably not worth feeding the hate.
[22:19:50] *** Quits: Scriptor (historium@moz-E06F46F0.corp.bitshelter.com) (Quit: Scriptor)
[22:19:51] <toddaaro> so uh, anyone want to help me figure out why my macro now ICEs?
[22:19:59] <cmr> toddaaro: sure
[22:20:10] <cmr> diff?
[22:20:43] <Seldaek> aatch: haha, well I wouldn't, I quite like it. I'm just happy to do other stuff for a change sometimes which is why I'm here.
[22:21:01] <toddaaro> cmr: http://pastebin.mozilla.org/2864360
[22:21:08] *** Joins: tikue (tkuehn@moz-F4812C6E.hsd1.fl.comcast.net)
[22:21:09] <toddaaro> that is the new macro + one of the ICEs I got
[22:21:43] *** zz_kimundi is now known as kimundi
[22:21:53] <aatch> Seldaek, PHP is just what I do for a living, tbh. I'm really a native-language programmer. I jumped at the chance to implement the psql extension for HipHop since it meant I could use C++ at work.
[22:22:16] *** Quits: wilmoore (wilmoore@moz-7EE4D9D6.mystrotv.com) (Ping timeout)
[22:23:20] *** Joins: strcat (strcat@moz-54F7FD49.cpe.net.cable.rogers.com)
[22:23:42] *** Quits: a__ (a__@moz-250D9B4.nycmny.fios.verizon.net) (Client exited)
[22:24:04] *** Quits: tikue (tkuehn@moz-F4812C6E.hsd1.fl.comcast.net) (Ping timeout)
[22:24:19] <toddaaro> cmr: oh huh, you need the Task change too
[22:25:04] *** Joins: tikue (tkuehn@moz-F4812C6E.hsd1.fl.comcast.net)
[22:25:44] <cmr> toddaaro: ok, so that error comes out of liveness
[22:25:52] <Seldaek> aatch: fair enough :) I kinda grew up learning php so I am so used to it that most things don't bother me, even though I realize it is quite a mess of a language.. It's hard to find excuses to use other stuff though as a web dev
[22:26:15] <toddaaro> cmr: http://pastebin.mozilla.org/2864362 full diff if you need it, though it looks like you might not
[22:26:23] <toddaaro> cmr: what do you mean by "comes out of liveness"?
[22:26:38] *** Quits: Florob (Florob@moz-39532932.de) (Client exited)
[22:26:41] <cmr> toddaaro: as in, that ICE is generated at line 312 of middle/liveness.rs
[22:26:57] *** Joins: wilmoore (wilmoore@moz-7EE4D9D6.mystrotv.com)
[22:27:36] <cmr> toddaaro: I have never seen that ICE or anything like it before :\
[22:27:50] <toddaaro> cmr: ha, thanks for taking a look
[22:28:10] <cmr> git blame says you should ask nmatsakis
[22:28:35] <toddaaro> ping nmatsakis
[22:28:40] <toddaaro> nmatsakis: you around to look at this ICE?
[22:31:20] *** Quits: huseby (huseby@19BD73A1.5D8BCA3A.A0C1B52F.IP) (Quit: Leaving)
[22:36:16] *** Quits: infynyxx (infynyxx@DB780A29.749BA1D.DCC373F0.IP) (Client exited)
[22:36:36] *** Quits: dim-an (ermolovd@moz-FE167E47.nationalcablenetworks.ru) (Quit: dim-an)
[22:37:37] *** Quits: froystig (froystig@5A39C99E.352137A1.BCED17D.IP) (Ping timeout)
[22:37:52] *** Joins: tjc (tjc@moz-BBE3ABD.mv.mozilla.com)
[22:37:52] *** ChanServ sets mode: +o tjc
[22:38:01] <tjc> bblum: yeah, that was my fault
[22:38:13] *** Joins: ghrust (ghrust@79968228.6A2AE50.F3114085.IP)
[22:38:13] <ghrust> 01[13rust01] 15bors merged 06auto into 06master: 02http://git.io/x2x84w
[22:38:13] *** Parts: ghrust (ghrust@79968228.6A2AE50.F3114085.IP) ()
[22:40:24] *** Joins: leonvv (leonvv@moz-7D83A5F1.ip.telfort.nl)
[22:41:14] *** Joins: ghrust (ghrust@2EE61FCC.6A2AE50.F3114085.IP)
[22:41:14] <ghrust> 01[13rust01] 15bors pushed 0 new commits to 06auto: 02http://git.io/qJFabQ
[22:41:14] *** Parts: ghrust (ghrust@2EE61FCC.6A2AE50.F3114085.IP) ()
[22:41:15] *** Joins: ghrust (ghrust@2EE61FCC.6A2AE50.F3114085.IP)
[22:41:15] <ghrust> 01[13rust01] 15bors pushed 4 new commits to 06auto: 02http://git.io/GBllMA
[22:41:15] <ghrust> 13rust/06auto 14783c6a1 15Alex Crichton: Add a bunch of tests for closed issues...
[22:41:15] <ghrust> 13rust/06auto 14443bf93 15Alex Crichton: Fix a typo in the ifmt dox
[22:41:16] <ghrust> 13rust/06auto 141764e20 15Alex Crichton: Add even more tests...
[22:41:17] *** Parts: ghrust (ghrust@2EE61FCC.6A2AE50.F3114085.IP) ()
[22:43:05] <bblum> tjc: do you know about metadata? i have some questions about supertraits
[22:43:45] <tjc> bblum: a little bit; however, sully has worked on that recently
[22:43:51] <tjc> his knowledge might be more fresh
[22:44:26] <bblum> yeah but he has not responded to my ping yet
[22:44:39] <bblum> my question is simply how are supertraits encoded
[22:44:45] <bblum> or where can i look to find
[22:46:49] <bblum> i am waffling on the mechanism by which i want to keep track of builtin-kinds-as-supertraits, and it all depends on the metadata, unfortunately
[22:47:27] <olsonjeffery> \o/ libuv file io works
[22:47:33] <olsonjeffery> onward to high-level bindings
[22:47:40] *** Quits: bent (chatzilla@moz-BE33DA21.fw1.sfo1.mozilla.net) (Quit: ChatZilla 0.9.90.1-rdmsoft [XULRunner 22.0/20130619132145])
[22:48:34] <aatch> olsonjeffery, woo! Request: if you could get basic unix pipe support done sooner rather than later, that would be super-extra-awesome
[22:49:07] <aatch> (More accurately, unix domain sockets)
[22:49:11] <olsonjeffery> aatch: i understand
[22:49:38] <olsonjeffery> my initial PR is for open, read, write and close on the filesystem
[22:49:49] <olsonjeffery> pipes will require some thought, because it kind of has big runtime implications
[22:50:12] <aatch> I'm attempting a native X protocol impl and being able to use domain sockets would be nice.
[22:50:18] <bblum> tjc: ^ ?
[22:52:04] <bjz> brson: done
[22:52:19] <brson> bjz: thanks!
[22:52:46] <bjz> brson: I wonder if there would be a way we can enforce that kind of thing...
[22:53:34] <bjz> brson: so silly folks like me have a more difficult time being silly
[22:53:37] <bjz> :P
[22:54:26] <tjc> bblum: you might take a look at https://github.com/msullivan/rust/commit/90dede9c8fb30899ee05d52c9bfb7de5e9d56307 --
[22:54:30] <tjc> it hasn't actually landed yet, but
[22:54:50] * obk is bothered by the lack of built-in shared immutable data. Needing to manually use ARC all over the place introduces all sort of boilerplate. What is the reasoning behind not doing this directly in the type system?
[22:54:50] <tjc> hmm, on second thought, this doesn't touch the metadata
[22:54:54] <tjc> never mind...
[22:55:13] *** Quits: Luqman (laden@moz-DCEF6040.csclub.uwaterloo.ca) (Ping timeout)
[22:55:25] <obk> I expect this has been asked before - any URL I could look at to read up on the reasoning?
[22:55:30] <bblum> tjc: yeah thanks anyway
[22:55:32] *** Quits: snadon (chatzilla@moz-3BC727E8.mc.videotron.ca) (Ping timeout)
[22:55:34] <tjc> bblum: I'm looking at the metadata code
[22:55:35] <cmr> obk: we have statics for compile-time immutable data
[22:55:51] <obk> Compile-time immutable data is very limited...
[22:56:05] <bjz> obk: there are plans to remove GC and provide traits to make that kind of thing easier
[22:56:10] <aatch> obk, I don't know if there is a URL, but it's because Rust has strong ownership semantics.
[22:56:23] <bjz> obk: I'm not sure if that covers Arc
[22:56:25] <tjc> bblum: hmm, I see the code in the encoder that encodes supertraits for a trait, but it seems like you were just looking at it too since you asked me about that comment :-)
[22:56:45] <obk> But ownership is a tool, right? It is intended to cover the case of "I want to mutate this and its OK because I _own_ it"
[22:57:20] <obk> But if I have a "really" immutable thing, which _never_ mutates, then ownership becomes a burden, not a tool
[22:57:22] <aatch> obk, but there's also the case of memory safety
[22:57:37] <obk> Well, again, if it is truly immutable... where's the risk?
[22:57:38] <aatch> obk, if you have shared data, then you still need to know when to free it.
[22:57:44] <cmr> obk: well that's exactly what Arc is
[22:57:51] <obk> Right. So it boils down to the reference counting.
[22:57:53] <cmr> deep immutability (Freeze) plus sendability
[22:58:10] <obk> Right. Deep immutability.
[22:58:29] <cmr> https://github.com/mozilla/rust/blob/master/src/libextra/arc.rs#L118
[22:58:36] <bblum> tjc: i don't think i did, please point me to it
[22:58:41] <bblum> tjc: all i was able to find was the decoding
[22:58:47] <obk> For me one of Rust's promises was "I no longer have to use libraries for the common idioms of a safe memory model"
[22:59:01] <tjc> bblum: the item_trait case in encode_info_for_item
[22:59:02] *** Quits: Blub\w (wry@7E3BB9D.71150E1A.237AE2BA.IP) (Quit: night)
[22:59:21] <obk> I mean, sure, ARC does the trick, but C++ people would argue that unique_ptr also works.
[22:59:34] <cmr> obk: I don't see how it's possible to encode shared immutable data in the type system. It doesn't know about tasks.
[23:00:09] <obk> It doesn't have too... Suppose there was another pointer type - say, #foo (for reference counted :-)
[23:00:10] <cmr> Besides what Arc already does
[23:00:29] <strcat> obk: sharing data between tasks isn't idiomatic in rust, message passing is
[23:00:34] *** Quits: azita (Azita@moz-BBE3ABD.mv.mozilla.com) (Quit: azita)
[23:00:35] <aatch> obk, people get confused with the 4 we have now
[23:00:39] <obk> Then one could freely copy and send #foo pointers, and they'd be ref-counted.
[23:00:58] <strcat> obk: regular reference counted pointers aren't sendable
[23:00:59] <obk> aatch: Well... yes.
[23:01:02] <cmr> obk: #foo is Arc<foo>
[23:01:09] <strcat> it requires atomic refcounting
[23:01:30] <strcat> rusti: use extra::rc::Rc; Rc::new(5)
[23:01:32] -rusti- pastebinned 8 lines of output: http://ix.io/7k5
[23:01:34] <strcat> rusti: use extra::rc::Rc; Rc::from_const(5)
[23:01:35] -rusti- <anon>:5:28: 5:42 error: unresolved name `Rc::from_const`.
[23:01:35] -rusti- <anon>:5          use extra::rc::Rc; Rc::from_const(5)
[23:01:35] -rusti-                                      ^~~~~~~~~~~~~~
[23:01:35] -rusti- error: aborting due to previous error
[23:01:35] -rusti- application terminated with error code 101
[23:01:37] <obk> strcat: Of course.
[23:01:39] *** Joins: a__ (a__@moz-250D9B4.nycmny.fios.verizon.net)
[23:01:59] <strcat> tasks are a library feature
[23:02:17] <obk> #foo isn't directly related to tasks.
[23:02:23] <aatch> obk, we're planning a Pointer trait that allows for custom smart pointers. It's likely that Arc will implement it, meaning that much of the boilerplate can be reduced.
[23:02:59] <strcat> obk: if there was a reference counted pointer as part of the language, it wouldn't be atomic refcounting
[23:03:05] <obk> E.g., I want to have a type: Foo { Str(#str) Int(int) } and treat it just like any other value. Freely copiable, no need to worry about x = y = z, etc.
[23:03:19] <obk> Being send-able is just an added benefit.
[23:03:56] <obk> Right now, Foo { Str(ARC<str>) Int(int) } requires a lot of boilerplate code; and doing anything else means it isn't sendable, isn't copyable...
[23:04:09] *** Joins: Luqman (laden@moz-DCEF6040.csclub.uwaterloo.ca)
[23:04:09] <aatch> obk, that's not very idiomatic rust though. Rust tends to lean towards being explicit.
[23:04:18] <obk> Sorry, I meant enum Foo { ... }
[23:04:19] <aatch> I mean, we already dropped the Copy trait.
[23:04:46] *** Quits: eatkinson (eatkinson@moz-BBE3ABD.mv.mozilla.com) (Quit: eatkinson)
[23:04:48] <obk> Right... which makes enum Foo { string or integer } that much harder, right?
[23:04:56] <bblum> tjc: ok great thanks
[23:05:07] <obk> What's not idiomatic about treating immutable strings as "values", just like integers are?
[23:05:37] *** Joins: azita (Azita@moz-BBE3ABD.mv.mozilla.com)
[23:06:08] <cmr> integers aren't dynamically sized types
[23:06:15] <cmr> once we have DST you very well might be able to
[23:06:17] <aatch> obk, because it's not true. Either you have a &'static str, which can be treated like a value, or a ~str which has unique ownership or @[mut] str that has shared ownership.
[23:06:31] <obk> Strings aren't dynamically sized either. Immutable strings, that is.
[23:06:33] *** Joins: infynyxx (infynyxx@DB780A29.749BA1D.DCC373F0.IP)
[23:06:39] <aatch> obk, in rust they are
[23:06:55] <obk> Hmmm. Can I dynamically create a new &'static str ?
[23:06:56] <cmr> An immutable string would be &'static str, which you can create unsafely if you want
[23:07:02] <cmr> obk: transmute
[23:07:11] <obk> Transmute a ~str into it?
[23:07:23] <aatch> obk, yes, but that's a very, very bad idea.
[23:07:24] <cmr> no, a &str stashed in someplace that will never get freed
[23:07:51] <obk> &str is just a ~str or a @str, right?
[23:08:04] <aatch> obk, no, a &str is a slice
[23:08:14] <obk> Hmmm.
[23:08:17] <kimundi> obk: Not 'is'. 'May point into'
[23:08:26] <aatch> you only have the data and the length.
[23:08:29] <obk> That really sounds dangerous...
[23:08:35] <aatch> obk, why?
[23:08:39] <kimundi> obk: It isn't in rust
[23:09:04] <aatch> Rust tracks the lifetimes, makes sure that the &str doesn't outlive the source
[23:09:19] * obk isn't clear on how to safely convert a &str into a &'static str
[23:09:24] <cmr> obk: you can't
[23:09:25] <aatch> obk, you can't
[23:09:27] <kimundi> If you have a &str, you are prohibited at compile time to free or even mutate that thing it points at
[23:10:02] <aatch> if you have a &mut str, you aren't even allowed another slice from the source data
[23:10:03] <obk> Sure, but if I transmute it into a &'static str, I need to be damn sure my caller doesn't mutate it, right?
[23:10:16] <cmr> obk: mutate or free
[23:10:21] <obk> Exactly
[23:10:24] <aatch> obk, well if you have a &'static str, then they can't because it's immutable.
[23:10:32] <cmr> which is why you need to stash it somewhere it can't be free'd
[23:10:45] <strcat> atomic reference counting is a big performance issue in parallel programs
[23:10:46] <obk> Right - at this point, I get no help from the type system
[23:10:56] <aatch> but &'static str is only really for compile-time strings.
[23:11:01] <obk> strcat: Good point...
[23:11:12] <strcat> the reference count will be in the same cacheline as the string data
[23:11:18] <obk> I guess that's why Erlang went with interned strings instead
[23:11:21] <cmr> obk: No: the type system guarantees that once you give something your unsafely-created &'static str, it won't be mutated or free'd
[23:11:29] <obk> strcat: It doesn't _have_ to be...
[23:11:36] <strcat> so every time you copy the string ref, it will be a cache miss the next time you read it in every thread
[23:11:45] <strcat> obk: well, you'll still have a cache miss on every refcount
[23:11:49] <strcat> in every thread
[23:11:55] <strcat> it won't scale
[23:12:06] <strcat> there are perf benchmarks of these issues with old copy-on-write std::string impls in C++
[23:12:21] <obk> Hmmm. Again, I see why Erlang decided to bite the bullet and go with a "magical interned strings" mechanism...
[23:13:00] <obk> That sidesteps the refcount issue, at the cost of an explicit (expensive) "intern" call.
[23:13:10] <obk> Then you get something you can copy forever.
[23:13:13] *** Quits: infynyxx (infynyxx@DB780A29.749BA1D.DCC373F0.IP) (Ping timeout)
[23:13:27] <obk> Doesn't Servo have these sort of issues with XML attribute names etc.?
[23:13:37] *** Quits: tedh (tedh@moz-F0B37C08.hsd1.il.comcast.net) (Client exited)
[23:13:59] <aatch> obk, I don't know for sure, but Servo likely uses an interner
[23:14:14] <strcat> LLVM uses bump allocation + small string optimization
[23:14:14] <obk> One would expect this would be a real problem for them (parsing HTML strings, dealing with arbitrary attributes, but passing them around between tasks).
[23:14:29] <strcat> obk: most are going to be very small strings
[23:14:33] <strcat> nearly all
[23:14:35] <obk> Right
[23:14:46] <obk> That's true in my case as well.
[23:15:25] <obk> Sure, I could use an interner, but in my case, different tasks may be doing the interning. So I need to use RWArc on the interner and share it between the tasks, and so on.
[23:15:37] *** Quits: jorendorff (jorendorff@moz-2F32ACA3.hsd1.tn.comcast.net) (Quit: jorendorff)
[23:15:51] <obk> Hmmm.
[23:16:41] <obk> Not sure why refcounting is so bad. Sure, one needs to XADD. And that means a cache RFO, which is a miss if the previous task which did a copy was on a different processor.
[23:16:43] <obk> But.
[23:17:19] <obk> In theory the system could actually choose to copy the #foo to another processor, if it chooses to.
[23:17:56] <obk> A "sufficiently smart" runtime could, say, copy the foo if it was "smaller than a breadbox" and only refcount if it was "bigger than a breadbox".
[23:18:14] <obk> E.g., smaller or bigger than a cache line?
[23:18:18] <aatch> obk, but then that's a library type. 
[23:18:27] <aatch> we've gone around in a big circle
[23:18:29] <strcat> obk: https://github.com/facebook/folly/blob/master/folly/FBString.h
[23:18:43] <obk> No, foo could be a user-defined type (as long as it only contained #bar and ints and so on)
[23:19:10] *** Quits: donri (dag@moz-9BB61102.tbcn.telia.com) (Client exited)
[23:19:18] <aatch> obk, but it's far too complex for a system type.
[23:19:20] <cmr> #T is exactly syntax for Arc<T>
[23:19:27] <obk> Almost.
[23:19:36] <strcat> FBString does SSO for small strings, plain heap allocation for most, and copy-on-write refcounting for large ones
[23:19:48] <obk> Except one needs to explicitly clone an Arc<T> and #T is copy-able just by saying x = y
[23:19:52] <strcat> the cost being that almost none of it gets inlined
[23:19:59] <obk> And there's no need to get the value
[23:20:02] *** Joins: robarnold (rob@BD56354E.DB510C09.6E370BFC.IP)
[23:20:38] <aatch> obk, and? the whole point is that implicit copying is just a memcpy (or equivalent)
[23:21:11] *** Quits: bjz (brendanzab@B398BE78.F804C29E.D35A31DF.IP) (Quit: Leaving...)
[23:21:25] <aatch> `@`-pointers are the only exception to this and they aren't considered to be very good right now
[23:21:38] <obk> strcat: But that doesn't help me... hmmm. I wonder. Can I write a fn statify(s: &str) -> &'static str that (1) clones the "s", holding a reference to it in "secret" task-local storage, (2) transmutes it to &'static str ?
[23:22:17] <obk> aatch: I'm just looking at the code that uses Arc<T> vs. hypothetical code that uses #T, and the latter seems to be much shorter/cleaner.
[23:22:41] <obk> Sure, using @ seems like the wrong tradeoff here.
[23:22:50] <aatch> obk, but short and clean isn't the be all and end all for code.
[23:22:59] <aatch> If you want that, use Python.
[23:23:04] <obk> Agreed. Still... it seems like such a common use case...
[23:23:04] *** Quits: azita (Azita@moz-BBE3ABD.mv.mozilla.com) (Quit: azita)
[23:23:18] <aatch> Rust is a systems language, so minimal hidden costs.
[23:23:23] <aatch> obk, but it's not really.
[23:23:36] <obk> @ is hardly "minimal hidden cost"
[23:23:38] *** Joins: azita (Azita@moz-BBE3ABD.mv.mozilla.com)
[23:24:00] <obk> I guess what you are saying is that #T isn't that common a use case.
[23:24:02] <obk> Hmmm.
[23:24:30] <obk> It sounds surprising. I guess Rust isn't _that_  big on functional programming...
[23:24:47] <olsonjeffery> brson: ping
[23:24:50] <obk> Because #T is the bread and butter of list processing.
[23:25:13] <aatch> An immutable, sendable pointer that is shared enough that the Arc boilerplate is a problem? It's not common.
[23:25:14] * obk will need to think about it some more.
[23:25:36] <aatch> Since you can borrow out of the Arc and just pass a & around instead
[23:26:01] <strcat> I don't think most functional languages have atomic refcounting
[23:26:18] <aatch> since & is implicitly copyable, immutable but tied to the lifetime of a specific object.
[23:26:19] <obk> No, they have general GC, sure.
[23:26:30] <obk> But I meant that sharing immutable data between threads is common.
[23:26:50] <bblum> obk: stashing a copy of a string in task-local storage does not make it safe to transmute to &'static str -- &'static pointers are sendable (I think? Or they might become such in the future) and the static lifetime outlives the task lifetime.
[23:26:59] <bblum> (if they were never sendable it would be fine)
[23:27:27] <obk> bblum: Assume the relevant task lives forever?
[23:27:40] <aatch> obk, prove that to the compiler
[23:27:40] <obk> It would in my case, anyway.
[23:27:44] <strcat> but you can't enforce that, it can fail
[23:27:54] <bblum> obk: then it would warrant the use of unsafe, but be fine, i guess
[23:28:04] <obk> aatch: At this point, I'm using "transmute" so proving to the compiler is out the window
[23:28:14] <bblum> obk: rather, i should say, it should be an 'unsafe fn' rather thana 'fn with unsafe inside'
[23:28:18] <obk> RIght, this is "unsafe" from the get go
[23:28:21] *** Quits: snerd (motk@moz-E535583C.nonstopcrunchy.net) (Quit: leaving)
[23:28:33] *** Joins: snerd (motk@moz-E535583C.nonstopcrunchy.net)
[23:28:45] <obk> Well, that depends on the system. As in, if it always was the root task?
[23:28:53] *** Quits: ozten (ozten@19BD73A1.5D8BCA3A.A0C1B52F.IP) (Quit: ozten)
[23:29:10] <bblum> root task can exit too
[23:29:15] <obk> Which, alas, I can't enforce, since there's no way of finding out which task is the root one.
[23:29:28] <obk> But I thought if it exists, then the whole program does.
[23:29:48] <bblum> fn main() { do spawn { loop { } } }
[23:30:03] <obk> Hmmm. I guess I was wrong then.
[23:30:14] <obk> So yes, technically it would be an unsafe fn.
[23:30:39] * obk really misses atoms/symbols/whatever-you-call-them.
[23:30:49] <obk> For my specific problem domain, anyway.
[23:30:50] <brson> olsonjeffery: pong
[23:30:57] <bblum> rusti: fn main() { do std::task::spawn_unlinked { let (p,_) = std::comm::stream(). let () = p.recv(); } }
[23:30:57] -rusti- <anon>:5:94: 5:95 error: unresolved name `p`.
[23:30:57] -rusti- <anon>:5          fn main() { do std::task::spawn_unlinked { let (p,_) = std::comm::stream(). let () = p.recv(); } }
[23:30:57] -rusti-                                                                                                        ^
[23:30:57] -rusti- error: aborting due to previous error
[23:30:58] -rusti- application terminated with error code 101
[23:31:19] <bblum> rusti: fn main() { do std::task::spawn_unlinked { let (p,_) = std::comm::stream(); let () = p.recv(); } }
[23:31:20] -rusti- ()
[23:31:28] <bblum> rusti: fn main() { do std::task::spawn { let (p,_) = std::comm::stream(); let () = p.recv(); } }
[23:31:29] -rusti- ()
[23:31:36] <obk> Thanks for the tips. I'll re-think my code and see what I can get to...
[23:31:51] *** Joins: erickt (etryzelaar@8C9ECD8F.3A598286.F12515B4.IP)
[23:32:18] <aatch> obk, remember, Rust is a systems language. It's very different to Erlang because Erlang is a VM language and designed for a different use case.
[23:32:30] <aatch> We have people writing kernels in Rust.
[23:33:21] <obk> aatch: Sure, I get it. I don't entirely disagree with the reasoning against #T. Just "somewhat" :-)
[23:33:28] <myname> aatch: huh?
[23:33:48] <aatch> myname, what?
[23:33:51] <obk> aatch: Yes, who is writing a real kernel in Rust?
[23:33:58] *** Quits: azita (Azita@moz-BBE3ABD.mv.mozilla.com) (Quit: azita)
[23:34:06] <tjc> Depends on your definition of "real"...
[23:34:13] <obk> I though that going all the way down to the kernel level was listed as a "non goal"
[23:34:18] <aatch> I didn't say a real kernel.
[23:34:25] <bblum> it ended up happening anyway
[23:34:35] <aatch> obk, and it's more like it's not an explicitly supported goal
[23:34:46] <myname> "i accidentally kernel"? :D
[23:34:53] <aatch> but runtimeless was and that apparently was enough
[23:35:21] <sigma> people really like the idea of a memory safe kernel :)
[23:35:24] <aatch> Heres one: https://github.com/charliesome/rustboot
[23:35:27] <obk> Fair enough - #T could be excluded from the run-time-less-ness. As are @Ts. So that argument against it is weak.
[23:35:50] <bblum> obk: i basically agree that #T and @T have about equal priority in terms of whether they deserve syntax sugar
[23:36:09] <olsonjeffery> brson: what's the env var to use valgrind in the test suite?
[23:36:13] <bblum> it just so happens that we have sugar for @
[23:36:21] <bblum> but @ itself is going to become a library type, so...
[23:36:28] <obk> Oh really?
[23:36:32] <aatch> The sugar for `@` is also contested, just fyi
[23:36:35] <aatch> https://github.com/jmgrosen/shorai
[23:36:43] <ecr> well, if we get the generic @ syntax for smart pointers, then it won't matter too much
[23:36:48] <Eridius> I'm tryign to understand the NullablePointer stuff in the compiler. This is prompted by issue #8516. Anyone know much about the implementation?
[23:36:57] <bblum> Eridius: jld 
[23:37:02] <Eridius> jld: ping
[23:37:10] <brson> olsonjeffery: CFG_ENABLE_VALGRIND=1
[23:37:19] <olsonjeffery> ty
[23:37:29] <obk> Well, if both ref-counted and gc-ed pointers are on equal footing - whatever that footing is - then I'd be happy
[23:37:30] <strcat> ecr: the only part we need is deref sugar
[23:37:39] <obk> Because I assume that whatever it is, it won't be "too bad"
[23:37:46] <obk> The mismatch between them is what bugged me
[23:38:04] <obk> So it sounds Rust is going to do _some_ "right" thing, one way or the other
[23:38:09] <bblum> ;)
[23:39:00] <obk> Anyway, I'm off to bed (way late in my TZ).
[23:39:05] <obk> Thanks again!
[23:39:17] <ecr> strcat: right. The @ sugar is just for allocating I think
[23:39:29] <strcat> ecr: well I don't really think it makes sense to have that
[23:39:43] <strcat> smart pointers aren't special
[23:39:47] *** Quits: obk (Mibbit@moz-B0F26027.red.bezeqint.net) (Quit: http://www.mibbit.com ajax IRC Client)
[23:39:56] <strcat> their semantics aren't different than something like a vector
[23:40:03] <strcat> or a map
[23:40:28] <strcat> they're a fixed-size container with some ownership semantics (like other containers) holding 1 element
[23:40:38] <strcat> so the special part is that they're always 1 element, thus deref sugar (like newtypes)
[23:41:17] *** Quits: int3_ (int3_@moz-ABE52D50.hsd1.ca.comcast.net) (Client exited)
[23:41:40] <jld> bblum: Eridius: pong?
[23:41:45] <brson> cmr: going to try to tweak your src-base makefile here. not exactly sure what's wrong
[23:41:46] <ecr> sure, but @ is a convenient syntactic flag for "this is just a pointer, but it does some runtime tracking"
[23:42:04] <ecr> whereas newtypes (should) have no runtime overhead
[23:42:06] * jld reads context.
[23:42:11] <strcat> ecr: containers have the same overhead
[23:42:15] <strcat> and don't have special syntax
[23:42:21] <ecr> vectors do
[23:42:32] <strcat> so do hash tables, trees, lists
[23:42:39] <strcat> deques
[23:42:46] <strcat> ecr: you mean syntax?
[23:42:49] <ecr> yes
[23:42:52] <strcat> only one kind of vector has special syntax
[23:43:04] <strcat> small vectors, ropes and persistent vectors don't
[23:43:17] <ecr> true
[23:43:26] <strcat> imo it's a mistake to have special-cased syntax for one kind, because it makes people unlikely to consider which they really want
[23:43:32] <strcat> I'd prefer have generic container literals like C++
[23:43:34] <strcat> having*
[23:43:41] <Eridius> jld: see issue https://github.com/mozilla/rust/issues/8516
[23:43:47] <bblum> can i git stash pop something and leave it in my stash at the same time
[23:44:06] <strcat> bblum: yes, use apply
[23:44:07] *** Quits: leonvv (leonvv@moz-7D83A5F1.ip.telfort.nl) (Broken pipe)
[23:44:10] <strcat> instead of pop
[23:44:15] <Eridius> jld: basically, a NullablePointer is being used for a 2-variant enum where the null variant is `One(())`, and when constructing the constant value `One(())` this is tripping the assertion that checks if vals is empty
[23:44:16] * strcat actually didn't know about pop for a long time
[23:44:26] <ecr> i'm not familiar enough with C++ to know what those are, but I'd be perfectly happy with overloading the vector syntax for vector-like things.
[23:44:28] <myname> i'm kinda curious about that rustboot thingie... how far away is it from being able to output text and read user keyboard input?
[23:44:47] <jld> Eridius: Ugh.  There was a bug or two with null-pointer-ized variants with a nonzero number of fields, but I thought I caught them all.
[23:44:49] *** Joins: carllerche (carllerche@6B070D22.7E6A0813.1428D117.IP)
[23:45:08] *** Quits: FrozenCow (FrozenCow@moz-B2DF4929.chello.nl) (Ping timeout)
[23:45:39] <strcat> ecr: http://en.cppreference.com/w/cpp/language/list_initialization
[23:45:41] <strcat> like
[23:45:46] <strcat> std::vector<int> a {1, 2, 3, 4, 5};
[23:45:47] <jld> Eridius: I think I might have forgotten about statics.
[23:45:53] <Eridius> jld: heh
[23:45:55] <strcat> std::map<int, int> m {{1, 2}, {3, 4}};
[23:46:34] <ecr> hm, I wonder if you could do something like that in a macro
[23:46:40] <strcat> they're just a generic list concept
[23:46:48] *** Joins: eatkinson (eatkinson@moz-BBE3ABD.mv.mozilla.com)
[23:46:52] <strcat> they also use it for variadic functions when they take N arguments of the same type
[23:46:55] <strcat> instead of a variadic template
[23:46:57] * jld looks for a test case for the non-static version of this, because there should be one....
[23:47:07] <strcat> constant compile-time lists, basically
[23:47:16] *** Joins: goffrie (goffrie@moz-AA92FD24.dsl.ncf.ca)
[23:47:19] <toddaaro> nmatsakis around now?
[23:47:26] <strcat> well I guess only their size has to be constant
[23:48:13] <strcat> ecr: if you could consume fixed-size vectors, they'd work for this
[23:48:39] *** Joins: bent (chatzilla@moz-932324BF.hsd1.ca.comcast.net)
[23:51:11] *** Quits: sigma (sigma@51C589B3.EF2694B5.DFAC6AA7.IP) (Ping timeout)
[23:53:17] *** Quits: azakai (alon@moz-BBE3ABD.mv.mozilla.com) (Quit: Ex-Chat)
[23:53:21] *** Joins: azakai_ (alon@moz-BBE3ABD.mv.mozilla.com)
[23:55:54] *** Joins: int3_ (int3_@moz-ABE52D50.hsd1.ca.comcast.net)
[23:57:01] *** Quits: erickt (etryzelaar@8C9ECD8F.3A598286.F12515B4.IP) (Ping timeout)
[23:57:48] <tikue> what is extra::list good for? and why are there module functions rather than methods on list?
[23:58:30] <strcat> because it's old
[23:59:21] <tikue> what about my first question :P

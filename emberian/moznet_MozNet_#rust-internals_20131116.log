[00:31:52] *** Quits: jdm (jdm@9C2E78E6.8C982E60.292610BC.IP) (Quit: Lost terminal)
[00:34:51] *** Joins: tautologico (iorek@33CCBB09.CFE755C8.C27E1635.IP)
[00:36:35] *** Quits: Sharp (Sharp@1710C26.8381A41.8725677B.IP) (Quit: Sharp)
[01:01:26] *** Joins: Sharp (Sharp@1710C26.8381A41.8725677B.IP)
[01:02:01] *** Joins: tjc (tjc@moz-BBE3ABD.mv.mozilla.com)
[01:02:01] *** ChanServ sets mode: +o tjc
[01:09:04] <vadimcn> Trying to figure out how to introduce a pre-defined type in rustc.   Any pointers where to look?
[01:10:54] *** Quits: tjc (tjc@moz-BBE3ABD.mv.mozilla.com) (Quit: Places to go, people to annoy)
[01:11:15] <kimundi> vadimcn: What do you mean?
[01:12:06] <vadimcn> I mean "a type that compiler knows about", like primitives (bool, int, ...)
[01:12:30] <vadimcn> I guess the closest one is how "for" loop interacts with Iterator
[01:12:50] *** nrc|holiday is now known as nrc
[01:14:04] <vadimcn> However in that particular case it looks like for gets desugared at ast stage, so compiler doesn't need to know about Iterator, it just expects for's argument to have next() method
[01:16:37] <dbaupp> what type(s) are you adding?
[01:20:29] <cmr> vadimcn: are you thinking, like, language items, or primitives?
[01:24:17] <vadimcn> I must admit I don't fully understand what " language items" are.   I want to add a type like this: enum Either<A,B> { First(A), Second(B) }
[01:25:44] <kimundi> vadimcn: Can't you just define it in a library?
[01:27:44] <vadimcn> So want to try my hand at adding co-coutines to Rust.   So I need something like Either<A,B> for the return type, where A and B are inferenced.
[01:28:39] <vadimcn> I think I need to create an instance of ty::t for it
[01:29:08] <vadimcn> It may also need to be defined in the library, but the compiler needs to understand that it's the same type.
[01:30:00] <dbaupp> that's what lang-items are. a method to communicate to the compiler that this is the thing that should be used in whatever context.
[01:30:16] *** kimundi is now known as zz_kimundi
[01:30:31] <dbaupp> so you'd have `#[lang="coroutine_either"] enum Either<A,B> { .. }`, or something like that
[01:30:53] <dbaupp> and then the compiler would look-up that lang item any time it needed to use it.
[01:33:32] *** Quits: tautologico (iorek@33CCBB09.CFE755C8.C27E1635.IP) (Quit: tautologico)
[01:34:02] <vadimcn> ok,   but can you point me to where in compiler's guts "lang items" are defined?  
[01:34:31] <cmr> middle/lang_items.rs
[01:36:25] *** Joins: ghrust (ghrust@9C8B94D4.6A2AE50.F3114085.IP)
[01:36:25] <ghrust> 01[13rust01] 15bors 04force-pushed 06auto from 147101e17 to 1490754ae: 02http://git.io/N3iJvQ
[01:36:25] *** Parts: ghrust (ghrust@9C8B94D4.6A2AE50.F3114085.IP) ()
[01:36:32] *** Joins: ghrust (ghrust@79968228.6A2AE50.F3114085.IP)
[01:36:32] <ghrust> 01[13rust01] 15bors pushed 2 new commits to 06auto: 02http://git.io/CaVGsw
[01:36:32] <ghrust> 13rust/06auto 14075131c 15Alex Crichton: Forbid privacy in inner functions...
[01:36:32] <ghrust> 13rust/06auto 14a244fee 15bors: auto merge of #10443 : alexcrichton/rust/meaninless-pub-priv, r=cmr...
[01:36:32] *** Parts: ghrust (ghrust@79968228.6A2AE50.F3114085.IP) ()
[01:37:16] <vadimcn> and where does compiler construct ty::t for them?  For example, I don't see DropTraitLangItem mentioned anywhere else outside of lang_items.rs
[01:37:33] <vadimcn> So how does it know that Drop trait has a drop() method?
[01:38:31] <cmr> That, I do not know the answer to.
[01:38:55] <cmr> Hmm
[01:38:58] <cmr> kind.rs, 138
[01:39:19] <cmr> Seems kinda like it?
[01:39:24] <cmr> Maybe it doesn't actually check
[01:39:38] *** Quits: erickt (etryzelaar@8C9ECD8F.3A598286.F12515B4.IP) (Ping timeout)
[01:42:16] *** Joins: tautologico (iorek@33CCBB09.CFE755C8.C27E1635.IP)
[01:45:20] <vadimcn> hmm, ok I guess TyDescStructLangItem is the closest to what I want.
[01:49:38] <vadimcn> thanks, will keep digging...
[01:51:11] *** Quits: andrew-d_w (andrew-d_w@moz-9A2674DF.dsl.static.sonic.net) (Quit: Leaving...)
[01:52:14] *** Quits: tautologico (iorek@33CCBB09.CFE755C8.C27E1635.IP) (Quit: tautologico)
[01:53:15] *** Quits: Sharp (Sharp@1710C26.8381A41.8725677B.IP) (Quit: Sharp)
[02:01:24] *** Quits: Kxepal (Miranda@moz-A25B204D.pppoe.mtu-net.ru) (Connection reset by peer)
[02:01:41] *** Joins: Kxepal (Miranda@moz-A25B204D.pppoe.mtu-net.ru)
[02:06:25] *** Joins: ghrust (ghrust@2EE61FCC.6A2AE50.F3114085.IP)
[02:06:25] <ghrust> 01[13rust01] 15bors 04force-pushed 06auto from 14a244fee to 1490754ae: 02http://git.io/N3iJvQ
[02:06:25] *** Parts: ghrust (ghrust@2EE61FCC.6A2AE50.F3114085.IP) ()
[02:06:28] *** Joins: ghrust (ghrust@DE823A67.6A2AE50.F3114085.IP)
[02:06:28] <ghrust> 01[13rust01] 15bors pushed 2 new commits to 06auto: 02http://git.io/iccAyA
[02:06:28] <ghrust> 13rust/06auto 144e0abc7 15Alex Crichton: Forbid privacy in inner functions...
[02:06:28] <ghrust> 13rust/06auto 14ebb07ce 15bors: auto merge of #10443 : alexcrichton/rust/meaninless-pub-priv, r=cmr...
[02:06:29] *** Parts: ghrust (ghrust@DE823A67.6A2AE50.F3114085.IP) ()
[02:24:53] *** Joins: Sharp (Sharp@1710C26.8381A41.8725677B.IP)
[02:29:31] *** Joins: tautologico (iorek@33CCBB09.CFE755C8.C27E1635.IP)
[02:31:19] *** Joins: strcat (strcat@moz-54F7FD49.cpe.net.cable.rogers.com)
[02:39:30] *** Quits: tautologico (iorek@33CCBB09.CFE755C8.C27E1635.IP) (Quit: tautologico)
[02:40:35] <acrichto> strcat: ping
[02:40:42] <strcat> acrichto: pong
[02:40:56] <acrichto> tell me more about libc++abi vs libstdc++ vs libXXXXX++
[02:42:02] <cmr> libc++abi and libstdc++ are entirely different
[02:42:12] <strcat> acrichto: libstdc++ and libc++ are C++ stdlib implementations
[02:42:20] <cmr> libc++abi provides things like exception handling, libstd++ provides the STL etc
[02:42:24] <strcat> libstdc++ uses libsupc++ to provide the low-leve lABI support
[02:42:33] <strcat> libc++ can use either libsupc++, libc++abi or libcxxrt
[02:43:15] <acrichto> hm, so the only thing we really need is c++abi ?
[02:43:37] <strcat> the low-level ABI support library provides exceptions, RTTI
[02:43:39] <strcat> acrichto: yes
[02:43:54] <acrichto> so can you find c++abi on all systems?
[02:43:56] <strcat> on linux, libc++abi will just be wrapping the libgcc_s low-level unwinding support
[02:44:06] <strcat> acrichto: well on OS X it is the native solution now afaik
[02:44:09] <cmr> (yes)
[02:44:11] <strcat> on linux and windows it will use libgcc
[02:44:15] <cmr> (and freebsd10)
[02:44:21] <strcat> yeah native on freebsd too
[02:44:34] <strcat> but they plan on eventually replacing libgcc
[02:44:48] <strcat> by making their own libunwind implementation that's portable to windows
[02:45:04] <acrichto> is it possible to statically link libc++abi?
[02:45:07] <strcat> acrichto: yes
[02:45:29] <acrichto> how so?
[02:45:29] <cmr> And actually, can we have our "exceptions" be entirely separate from the system C++ exceptions?
[02:45:34] <acrichto> I appear to only have .dylib
[02:45:43] <strcat> acrichto: well we'd build it that way
[02:45:46] <strcat> it's tiny
[02:45:56] <acrichto> where's the source code?
[02:46:06] <strcat> acrichto: llvm.org, http://sprunge.us/eYbK that's the whole thing
[02:46:14] <strcat> http://libcxxabi.llvm.org/
[02:46:25] <acrichto> http://libcxxabi.llvm.org/
[02:46:27] <acrichto> ah ok
[02:46:28] <strcat> it has an svn repo with tags
[02:46:29] *** Joins: ghrust (ghrust@79968228.6A2AE50.F3114085.IP)
[02:46:29] <ghrust> 01[13rust01] 15bors 04force-pushed 06auto from 14ebb07ce to 1490754ae: 02http://git.io/N3iJvQ
[02:46:29] *** Parts: ghrust (ghrust@79968228.6A2AE50.F3114085.IP) ()
[02:46:31] *** Joins: ghrust (ghrust@DE823A67.6A2AE50.F3114085.IP)
[02:46:31] <ghrust> 01[13rust01] 15bors pushed 2 new commits to 06auto: 02http://git.io/Z5eQUQ
[02:46:31] <ghrust> 13rust/06auto 14853c1cc 15Alex Crichton: Forbid privacy in inner functions...
[02:46:31] <ghrust> 13rust/06auto 14269f88d 15bors: auto merge of #10443 : alexcrichton/rust/meaninless-pub-priv, r=cmr...
[02:46:32] *** Parts: ghrust (ghrust@DE823A67.6A2AE50.F3114085.IP) ()
[02:46:53] <acrichto> what about _Unwind_Resume?
[02:47:07] <cmr> Would come from libunwind
[02:47:16] <cmr> (which apple just released to llvm)
[02:47:27] <acrichto> but libc++abi doesn't provide it
[02:47:38] <strcat> acrichto: it provides that but doesn't implement it itself
[02:47:44] <strcat> acrichto: it comes from libgcc
[02:47:52] <strcat> maybe it provides it on OS X
[02:47:56] <strcat> and freebsd
[02:48:11] <cmr> http://llvm.org/svn/llvm-project/libcxxabi/trunk/src/Unwind/ ?
[02:48:16] <cmr> They do implement it now
[02:48:22] <acrichto> my libgcc_s doesn't appear to provide Unwind_Resume
[02:48:36] <strcat> acrichto: mine does
[02:48:41] <strcat> 000000000000fcb0 g    DF .text 00000000000000c7  GCC_3.0     _Unwind_Resume
[02:48:42] <strcat> 000000000000fd80 g    DF .text 00000000000000dd  GCC_3.3     _Unwind_Resume_or_Rethrow
[02:48:51] <acrichto> hm
[02:49:01] <strcat> libc++abi has this
[02:49:03] <strcat> 0000000000000000      D  *UND*0000000000000000              _Unwind_Resume
[02:49:09] <acrichto> so the libc++abi on llvm.org says it only supports darwin
[02:49:12] <strcat> perhaps you can built it so that it provides it itself now, dunno
[02:49:15] <strcat> acrichto: it's not true ;p
[02:49:22] <strcat> their site is just out of date
[02:49:22] <acrichto> just out of date?
[02:49:24] <cmr> acrichto: I use it on linux all the time
[02:49:26] <strcat> acrichto: yeah
[02:49:45] <acrichto> how does one build it?
[02:50:20] <acrichto> ah, foud it
[02:50:27] <strcat> lib/buildit ;p
[02:50:31] <acrichto> well, almost
[02:50:38] <acrichto> ld: unknown option: -soname
[02:50:38] <acrichto> clang: error: linker command failed with exit code 1 (use -v to see invocation)
[02:50:58] <acrichto> -lstdc++
[02:51:01] <acrichto> that is a suspicious flag
[02:51:34] <strcat> acrichto: need to build the unwind portion
[02:51:46] <strcat> on some platforms
[02:51:48] <acrichto> hm
[02:51:57] <acrichto> yeah so this still has a dependency on libc++
[02:52:10] <strcat> ah
[02:52:33] <strcat> acrichto: well, I guess we have to let it mature more
[02:52:47] <cmr> well, *any* c++ stdlib
[02:52:50] <acrichto> at least it has  -lstdc++ -std=c++11 -stdlib=libc++  in the linking phase
[02:53:29] <acrichto> cmr: I was hoping to link libc++abi statically to drop all dependence on a c++ runtime
[02:53:41] <acrichto> strcat: you are correct though, this is 347k
[02:53:56] <strcat> it's smaller stripped :)
[02:54:24] <acrichto> hm I spoke too soon
[02:54:35] <acrichto> if I remove the relevant linker flags it links, and has no dependence
[02:54:48] <strcat> acrichto: well their builtit script is likely out of date :(
[02:55:15] <strcat> acrichto: does it provide Unwind_Resume though?
[02:56:00] <acrichto>                 U __Unwind_Resume
[02:56:04] <acrichto> doesn't look like it
[02:56:25] <strcat> http://llvm.org/svn/llvm-project/libcxxabi/trunk/src/Unwind/UnwindLevel1.c it's definitely in here
[02:57:04] <acrichto> hm it didn't build any of those objects
[02:57:16] <acrichto> this build script must be super old
[02:57:23] <cmr> 'for FILE ../src/*.cpp;'
[02:57:30] <cmr> Do they even use this to build it?
[02:58:12] *** Quits: Sharp (Sharp@1710C26.8381A41.8725677B.IP) (Quit: Sharp)
[02:58:33] <acrichto> fatal error: 'mach-o/dyld_priv.h' file not found
[02:58:36] <acrichto> hmm...
[02:59:07] <acrichto> I don't even have dyld_priv.h on my entire system
[02:59:14] <cmr> heh
[03:05:39] <strcat> acrichto: it's possible there's another build system in libc++ for it I guess
[03:08:12] <acrichto> hmmm
[03:08:34] <acrichto> https://github.com/llvm-mirror/libcxxabi/commit/b78da9875b6e35187b5d584746c78faaf3230a3d
[03:08:40] <acrichto> looks like it's "example code"
[03:10:02] <cmr> Have you considered asking in #llvm?
[03:10:12] *** Quits: jld (jld@moz-B94C75AD.xlerb.net) (Ping timeout)
[03:10:30] <acrichto> hehe, not yet
[03:10:33] <acrichto> although that would make sense...
[03:10:40] <cmr> :P
[03:10:53] <acrichto> man I can't even build libunwind
[03:10:58] *** Joins: jld (jld@moz-B94C75AD.xlerb.net)
[03:11:10] <acrichto> b/c it looks like libunwind provides Unwind_Resume
[03:11:23] <acrichto> so perhaps all we need is llvm's libcxxabi and libunwind to get statically linked and we're all good
[03:11:55] <cmr> the non-c++abi libunwind doesn't provide _Unwind_Resume etc either.
[03:12:16] <cmr> strcat: is there a static libgcc_s?
[03:12:26] <cmr> what does that library even contain
[03:12:33] * cmr finds http://gcc.gnu.org/onlinedocs/gccint/Libgcc.html
[03:12:38] <strcat> cmr: compiler-rt and libgcc_s are twins
[03:12:51] <strcat> they provide functions the compiler will lower code it generates to
[03:12:58] <strcat> calls not originating in the source code
[03:13:09] <strcat> libgcc_s *also* happens to include the gcc libunwind
[03:13:13] <cmr> "document me!" great!
[03:13:14] <strcat> and compiler-rt doesn't
[03:13:30] <strcat> cmr: http://llvm.org/svn/llvm-project/compiler-rt/trunk/lib/
[03:13:37] <strcat> the files are named after the functions
[03:13:49] <acrichto> what provides elf.h?
[03:14:15] <strcat> glibc for me
[03:14:23] <acrichto> gee thanks osx
[03:15:34] <strcat> cmr: for example mulodi4/mulosi4 seem to be the checked overflow implementations it will often use on 32-bit for 64-bit ints
[03:16:10] <cmr> acrichto: do we need http://sourceforge.net/apps/trac/elftoolchain/ too?
[03:17:23] <cmr> (specifically libelf)
[03:18:05] <acrichto> hm apparently libelf does not provide elf.h
[03:18:57] <cmr> so it doesn't
[03:19:06] * acrichto sighs, at least it builds on linux out of the box
[03:19:42] <acrichto> what in the world did I just build
[03:21:47] <acrichto> 0000000000003a10 T _Unwind_Resume
[03:21:48] <acrichto> bingo!
[03:22:15] <acrichto> so perhaps we can statically link libunwind + libcxxabi to librustrt
[03:26:33] *** Joins: ghrust (ghrust@F6EE6DE3.6A2AE50.F3114085.IP)
[03:26:33] <ghrust> 01[13rust01] 15bors 04force-pushed 06auto from 14269f88d to 1490754ae: 02http://git.io/N3iJvQ
[03:26:33] *** Parts: ghrust (ghrust@F6EE6DE3.6A2AE50.F3114085.IP) ()
[03:26:36] *** Joins: ghrust (ghrust@24260B07.6A2AE50.F3114085.IP)
[03:26:36] <ghrust> 01[13rust01] 15bors pushed 2 new commits to 06auto: 02http://git.io/Dw3grw
[03:26:36] <ghrust> 13rust/06auto 14853c1cc 15Alex Crichton: Forbid privacy in inner functions...
[03:26:36] <ghrust> 13rust/06auto 148bdf817 15bors: auto merge of #10443 : alexcrichton/rust/meaninless-pub-priv, r=cmr...
[03:26:37] *** Parts: ghrust (ghrust@24260B07.6A2AE50.F3114085.IP) ()
[03:28:39] *** Quits: geoffhill (geoffhill@moz-738DC0DB.org) (Quit: )
[03:37:02] *** Joins: Sharp (Sharp@1710C26.8381A41.8725677B.IP)
[03:37:35] *** Quits: zz_kimundi (kimundi@moz-31504FA9.dip0.t-ipconnect.de) (Ping timeout)
[03:39:16] *** Quits: tedh (tedh@moz-F0B37C08.hsd1.il.comcast.net) (Ping timeout)
[03:40:10] *** Joins: tedh (tedh@moz-F0B37C08.hsd1.il.comcast.net)
[03:41:13] *** Joins: zz_kimundi (kimundi@moz-8E17C911.dip0.t-ipconnect.de)
[03:41:15] *** zz_kimundi is now known as kimundi
[03:48:05] *** Joins: SiegeLord (sl@moz-CAF07B4C.hsd1.ma.comcast.net)
[03:49:27] *** Quits: Sharp (Sharp@1710C26.8381A41.8725677B.IP) (Quit: Sharp)
[03:51:45] <acrichto> strcat: how familiar are you with how LTO works under the hood?
[03:51:52] <strcat> very
[03:52:07] <acrichto> so my understanding is that the distributable thing is just a wad of LLVM IR, is that right?
[03:52:14] <strcat> acrichto: bytecode, yeah
[03:52:20] <strcat> but the optimization path is different
[03:52:23] <cmr> bitcode ;P
[03:52:28] <strcat> function passes -> module passes -> binary is the regular path
[03:52:51] <strcat> function passes -> shortened module pass -> output bytecode -> load it all in and run an LTO module pass
[03:53:15] <strcat> and it's able to discard unused symbols and so on with the 2nd path
[03:53:47] <acrichto> so let's say I'm building libetra
[03:54:01] <acrichto> and let's say I'm building an LTO of libextra
[03:54:09] <acrichto> what happens before the output file is generated?
[03:54:23] <strcat> function pass + module pass -> LTO object file
[03:54:33] <acrichto> so exactly as we to today?
[03:54:35] <strcat> it's different than the usual function/module pass
[03:54:36] <acrichto> except a different output format
[03:54:41] <acrichto> oh hm
[03:54:52] <strcat> it doesn't run as much because it runs other stuff after loading them
[03:54:57] *** Joins: Sharp (Sharp@1710C26.8381A41.8725677B.IP)
[03:54:59] <strcat> there's likely stuff you wouldn't want to run twice
[03:55:09] * strcat shrugds
[03:55:18] <acrichto> ok, so now let's say I want to build an executable
[03:55:23] <acrichto> this executable links to libextra and libstd
[03:55:42] <acrichto> I will generate executable IR, munge it a bit, then slurp in libextra/libstd IR, then tell llvm to create an object file
[03:55:48] <strcat> it runs a function/module pass on the executable to get a bytecode file, then loads all 3 bytecode files and runs an LTO pass
[03:56:05] <acrichto> is there an example of this LTO pass in code somewhere?
[03:56:29] <strcat> http://llvm.org/docs/LinkTimeOptimization.html *shrug*
[03:56:29] *** Quits: Sharp (Sharp@1710C26.8381A41.8725677B.IP) (Quit: Sharp)
[03:57:02] <acrichto> mk, I will read that
[03:57:04] <acrichto> thanks
[03:57:13] <strcat> acrichto: look at 'alternative approaches' especially
[03:57:18] <strcat> for why this way is better
[03:57:46] <acrichto> how much usage of #[inline] could be discarded if we used LTO?
[03:58:02] <cmr> I imagine all of it
[03:58:08] <strcat> we wouldn't need AST serialization for #[inline] if we *always* used LTO
[03:58:16] <strcat> but I imagine we still want non-LTO builds to not be really slow
[03:58:20] <cmr> Yeah
[03:58:28] <cmr> Well, actually...
[03:58:38] <acrichto> but essentially LTO covers all "optimization" use cases of #[inline]
[03:58:42] <acrichto> as long as you're willing to wait
[03:58:46] <strcat> acrichto: yes
[03:58:47] <cmr> Doesn't inlining make it hard to achieve the goals of dynamic linking? Specifically, upgrades.
[03:58:56] <strcat> cmr: yes, but you still need it
[03:58:59] <cmr> Right
[03:59:13] <strcat> anyway rust isn't well suited to dynamic linking because we use field privacy instead of PIMPL and have reflection stuff
[03:59:15] <cmr> I recognize that. I don't think we should support dynamic linking at all, tbh.
[03:59:50] <acrichto> so I got static linking working today
[03:59:50] <cmr> Not until we've sorted out ABI stability
[03:59:58] <acrichto> the only dynamic dependency is librustrt right now
[04:00:03] <acrichto> "hello world" is 11MB
[04:02:40] <cmr> heh
[04:03:16] <dbaupp> acrichto: is that stripped?
[04:03:18] <cmr> are you using ld -O ?
[04:03:34] <cmr> hm that only does sos
[04:03:45] <cmr> What's the option that removes unused symbols and their body entirely?
[04:03:49] <acrichto> if I --gc-sections, it's 6.5MB after all the rust metadata is gone (which should probably happen anyway), and it's 4.5MB after stripping
[04:04:01] <acrichto> cmr: I couldn't figure out how to do that
[04:04:07] <acrichto> although I would imagine that's most of the binary size
[04:04:29] <strcat> acrichto: and --as-needed but it probably won't help ;p
[04:04:44] <strcat> with musl you can get tiny little fast executables
[04:04:46] <dbaupp> acrichto: `-dead_strip`?
[04:04:48] <strcat> glibc is the elephant in the room
[04:05:09] <acrichto> dbaupp: osx was actually worse than linux
[04:05:19] <acrichto> -dead_strep went from 11 to 7.6MB
[04:05:23] <acrichto> -dead_strip*
[04:14:03] <cmr> acrichto: did you see my note on the remove io_error PR?
[04:14:45] <dbaupp> acrichto: any opinion on https://github.com/mozilla/rust/issues/8614 ? (I've got something 50%-ish working.)
[04:14:57] <acrichto> cmr: I did, I'm gonna discuss with brson when he gets back
[04:15:01] <cmr> acrichto: alright, cool
[04:15:13] <acrichto> cmr: I feel like this is the right direction to go
[04:15:21] <acrichto> cmr: although I feel like my tools for error detection are not sufficient
[04:15:26] <cmr> acrichto: I'm still in favor of the change, but we need a nice abstraction to deal with this. It's not just io that the problem is with, it's *all* APIs returning an Option/Result-alike
[04:15:50] <acrichto> dbaupp: I'd be mostly interested in how it's statically compiled or statically analyzed
[04:16:14] <acrichto> cmr: I believe that's inevitable
[04:16:19] <dbaupp> acrichto: my current plan is to just add extra args that are `let __arg<n> = __arg0.foo[0].bar;` etc.
[04:16:20] <acrichto> you must communicate the error somewhow
[04:16:44] <dbaupp> (well, `&(__arg0.foo...)`)
[04:16:47] <acrichto> dbaupp: hm, that seems reasonable
[04:17:03] <cmr> acrichto: re: ifmt for field access it's easy. For indexing, it can fail, but that's the same if you do format!("{}", foo[42])
[04:17:05] <acrichto> dbaupp: one concern I would have is sane error messages
[04:17:16] <dbaupp> acrichto: yeah, I'd need to get subspans into the format string
[04:17:42] <acrichto> dbaupp: I've wanted that a lot for format errors, but I think pointing to the argument is probably good enough
[04:17:43] * dbaupp was going to ask before diving in and doing it "properly"
[04:17:53] <acrichto> cmr: yeah I'm not too worried about indexing off a cliff
[04:17:57] <cmr> oh
[04:18:26] <dbaupp> ok, I'll acquire the lock on that bug
[04:18:35] <acrichto> dbaupp: would the grammar just be expanded to have an identifer be followed by [constant] or .dident?
[04:18:39] <acrichto> .ident*
[04:18:59] <dbaupp> acrichto: {0.foo} and {foo.bar} are both valid, but I decided to disallow {.foo}
[04:19:10] <acrichto> dbaupp: I agree
[04:19:36] * dbaupp thinks {0[0]} looks a little peculiar, though
[04:20:03] <acrichto> what does python do in this regard?
[04:20:11] <acrichto> perhaps we should only allow idents
[04:20:21] * dbaupp tests
[04:20:57] <cmr> 93.8% of mozilla/rust is Rust
[04:21:07] <dbaupp> >>> "{.format}".format("")                                                    
[04:21:07] <dbaupp> '<built-in method format of str object at 0x7f4bf49a0508>'
[04:21:08] <acrichto> \o/
[04:21:16] <acrichto> interesting
[04:21:22] <dbaupp> >>> "{0[0]}".format("1")
[04:21:22] <dbaupp> '1'
[04:22:19] <acrichto> dbaupp: hm..., perhaps the best thing to do here is err on the side of symmetry
[04:22:20] <dbaupp> I'm still thinking {.foo} is more confusing than useful, but the other two are ok.
[04:22:22] <acrichto> no weird rules
[04:22:27] <dbaupp> oh?
[04:22:34] <dbaupp> i.e. {.foo} is legal?
[04:22:41] <acrichto> we would support .foo b/c you'd have to add extra code to disallowe it
[04:22:44] <tikue> my bug ;D
[04:22:46] <acrichto> no one would sanely write that though
[04:24:56] <dbaupp> acrichto: https://gist.github.com/huonw/5b3e4c608320884c3ac0#file-gistfile1-diff-L36-L41 is the extent of the special handling, fwiw.
[04:25:29] <acrichto> dbaupp: I would vote for symmetry + consistency with python, but I don't really have a preference on the matter
[04:25:34] <dbaupp> ok
[04:25:36] <acrichto> *strong preference
[04:26:13] <dbaupp> I initially did it because I thought it'd make the syntax/ext impl harder, but that was before I'd actually worked out exactly how I was going to do it, and I don't think it will make it more difficult
[04:26:17] <dbaupp> so symmetry it is
[04:30:16] <acrichto> strcat: btw I was thinking about #[thread_local] the other day, and it seems like we have a lot of kinda one-off use cases for various llvm attributes on globals/functions
[04:30:28] <tikue> dbaupp: will it support chained operations as well?
[04:30:31] <acrichto> I wonder if we could adopt a more general syntax for special cases such as thouse
[04:30:56] <tikue> >>> "{v[0][0]}".format(v=[[1]])
[04:30:56] <tikue> '1'
[04:31:04] <dbaupp> tikue: {arg.foo.bar[0].baz[1]:<10.3s}, will be valid, yes.
[04:31:42] <tikue> anyone who does that is nuts
[04:31:47] <acrichto> dbaupp: you're scaring me
[04:31:54] <acrichto> {:<3}
[04:32:01] <tikue> lol
[04:32:37] <acrichto> "_upcall_rust_personality", referenced from: Dwarf Exception Unwind Info (__eh_frame) in rustuv.o
[04:32:44] <acrichto> that's a "reference location" I've never seen before
[04:43:26] <cmr> heh
[04:58:45] <cmr> r? https://github.com/mozilla/rust/pull/10509
[04:59:14] <acrichto> whoa that's a lot of code
[04:59:22] <acrichto> with very little test
[04:59:38] <cmr> Uhhh what happened there
[04:59:42] <cmr> That semes to be a rebase accident
[04:59:45] <cmr> ... it's a 2-line change
[04:59:57] <acrichto> heh, it also looks like that code is never called from anywhere
[05:00:17] *** Joins: Sharp (Sharp@1710C26.8381A41.8725677B.IP)
[05:00:23] <acrichto> did you contact the original author?
[05:00:37] <cmr> two weeks ago, yes.
[05:02:49] <acrichto> bors y u dead
[05:02:56] <sfackler> man, check-stage1-std takes forever to bootstrap
[05:03:10] <acrichto> rust takes forever to bootstrap :(
[05:03:11] <cmr> sfackler: NO_REBUILD=1
[05:03:36] <acrichto> and the finger of offending pull request points to...
[05:05:50] <acrichto> hm, it can't download json
[05:15:03] *** Joins: yuriks_ (yuriks@DD48A7C8.D06AB739.748B6D8D.IP)
[05:15:44] *** Quits: yuriks (yuriks@ECB1DF0D.88B480FC.748B6D8D.IP) (Ping timeout)
[05:22:36] *** Quits: Sharp (Sharp@1710C26.8381A41.8725677B.IP) (Quit: Sharp)
[05:26:32] *** Joins: ghrust (ghrust@24260B07.6A2AE50.F3114085.IP)
[05:26:32] <ghrust> 01[13rust01] 15bors 04force-pushed 06auto from 148bdf817 to 1490754ae: 02http://git.io/N3iJvQ
[05:26:32] *** Parts: ghrust (ghrust@24260B07.6A2AE50.F3114085.IP) ()
[05:26:38] *** Joins: ghrust (ghrust@9C8B94D4.6A2AE50.F3114085.IP)
[05:26:38] <ghrust> 01[13rust01] 15bors pushed 2 new commits to 06auto: 02http://git.io/XQyfHQ
[05:26:38] <ghrust> 13rust/06auto 1457e9a2f 15Alex Crichton: Make -Z gen-crate-map usable for I/O...
[05:26:38] <ghrust> 13rust/06auto 145effb35 15bors: auto merge of #10437 : alexcrichton/rust/fix-gen-crate-map, r=cmr...
[05:26:38] *** Parts: ghrust (ghrust@9C8B94D4.6A2AE50.F3114085.IP) ()
[05:49:49] *** Joins: ktt3ja (Mibbit@moz-F40FE31.washdc.fios.verizon.net)
[05:51:04] <cmr> r? https://github.com/mozilla/rust/pull/10509
[05:57:44] *** Joins: tautologico (iorek@33CCBB09.CFE755C8.C27E1635.IP)
[06:00:24] *** Joins: Sharp (Sharp@1710C26.8381A41.8725677B.IP)
[06:44:31] *** Quits: tautologico (iorek@33CCBB09.CFE755C8.C27E1635.IP) (Quit: tautologico)
[06:47:16] <cmr> rusti: static X: ~ToStr = ~42 as ~ToStr;
[06:47:18] -rusti- pastebinned 8 lines of output: http://sprunge.us/OhAf
[06:47:39] <cmr> rusti: static X: @int = @42;
[06:47:40] -rusti- <anon>:9:26: 9:29 error: disallowed operator in constant expression
[06:47:40] -rusti- <anon>:9          static X: @int = @42;
[06:47:40] -rusti-                                    ^~~
[06:47:40] -rusti- error: aborting due to previous error
[06:47:41] -rusti- application terminated with error code 101
[06:47:48] <cmr> That is very, very odd.
[06:48:42] <strcat> cmr: why?
[06:48:57] <cmr> An error that check_const should be making isn't getting made in the second case.
[06:50:33] <cmr> oh wait no it isn't
[06:50:40] <cmr> I'm looking in the entirely wrong place
[06:57:22] * strcat needs to write an aligned allocator, a cache-aligned allocator wrapper, Arc/Mutex stuff, and a bunch of concurrent data structures ;p
[06:58:37] *** Quits: blank_name (blank_name@FAB53C88.7071B2C8.31EC03F3.IP) (Ping timeout)
[07:03:04] *** Joins: eddyb (eddy@336E3A7F.D51DAF03.FB866788.IP)
[07:03:20] *** Quits: eddyb9 (eddy@336E3A7F.D51DAF03.FB866788.IP) (Quit: Leaving)
[07:03:53] *** Joins: eddyb9 (eddy@336E3A7F.D51DAF03.FB866788.IP)
[07:09:16] *** Joins: tikue_ (quassel@moz-FEADCD38.hsd1.pa.comcast.net)
[07:09:51] <cmr> r? https://github.com/mozilla/rust/pull/10511
[07:09:57] *** Quits: strcat (strcat@moz-54F7FD49.cpe.net.cable.rogers.com) (Ping timeout)
[07:10:12] *** Joins: strcat (strcat@moz-54F7FD49.cpe.net.cable.rogers.com)
[07:10:29] *** Quits: tikue (quassel@moz-FEADCD38.hsd1.pa.comcast.net) (Ping timeout)
[07:11:00] *** Quits: SimonSapin (simon@moz-9A1FE870.exyr.org) (Ping timeout)
[07:11:26] *** Quits: sully (sully@moz-388398CC.leptoquark.net) (Ping timeout)
[07:12:59] *** Joins: SimonSapin (simon@moz-9A1FE870.exyr.org)
[07:14:46] *** Joins: sully (sully@moz-388398CC.leptoquark.net)
[07:27:56] *** Quits: nrc (nrc@7BE24E90.A5032A01.3CFC199D.IP) (Ping timeout)
[07:40:54] *** Joins: pcwalton (pcwalton@2FD4AFFD.41051F7C.BBD3C053.IP)
[07:40:55] *** ChanServ sets mode: +ao pcwalton pcwalton
[07:56:05] <cmr> ffffffffffffffff
[07:56:14] <cmr> LLVM rebuild ;_;
[07:57:00] <dbaupp> ccache \o/
[07:57:46] <cmr> I do!
[07:57:52] <cmr> It still takes more than 0 seconds though
[07:57:56] <olsonjeffery> if you want a vision of the future, imagine endless llvm rebuilds
[07:57:57] <olsonjeffery> FOR EVER
[07:59:09] <cmr> also bors :(
[08:00:49] *** Quits: pcwalton (pcwalton@2FD4AFFD.41051F7C.BBD3C053.IP) (Quit: pcwalton)
[08:03:10] *** Quits: tedh (tedh@moz-F0B37C08.hsd1.il.comcast.net) (Ping timeout)
[08:06:09] *** Joins: pcwalton (pcwalton@2FD4AFFD.41051F7C.BBD3C053.IP)
[08:06:09] *** ChanServ sets mode: +ao pcwalton pcwalton
[08:06:31] *** Joins: tedh (tedh@moz-F0B37C08.hsd1.il.comcast.net)
[08:07:30] *** Quits: pcwalton (pcwalton@2FD4AFFD.41051F7C.BBD3C053.IP) (Quit: pcwalton)
[08:11:29] *** Joins: pcwalton (pcwalton@2FD4AFFD.41051F7C.BBD3C053.IP)
[08:11:29] *** ChanServ sets mode: +ao pcwalton pcwalton
[08:11:38] *** Quits: pcwalton (pcwalton@2FD4AFFD.41051F7C.BBD3C053.IP) (Quit: pcwalton)
[08:11:41] *** Quits: strcat (strcat@moz-54F7FD49.cpe.net.cable.rogers.com) (Connection reset by peer)
[08:11:42] *** Quits: rusti (rusti@moz-54F7FD49.cpe.net.cable.rogers.com) (Connection reset by peer)
[08:11:51] *** Joins: rusti (rusti@moz-54F7FD49.cpe.net.cable.rogers.com)
[08:14:00] *** Quits: SiegeLord (sl@moz-CAF07B4C.hsd1.ma.comcast.net) (Quit: It's a joke, it's all a joke.)
[08:14:50] *** Joins: pcwalton (pcwalton@2FD4AFFD.41051F7C.BBD3C053.IP)
[08:14:50] *** ChanServ sets mode: +ao pcwalton pcwalton
[08:41:04] *** Quits: Sharp (Sharp@1710C26.8381A41.8725677B.IP) (Quit: Sharp)
[08:49:49] *** Quits: pcwalton (pcwalton@2FD4AFFD.41051F7C.BBD3C053.IP) (Quit: pcwalton)
[08:50:35] *** Quits: tedh (tedh@moz-F0B37C08.hsd1.il.comcast.net) (Ping timeout)
[08:54:22] *** Joins: tedh (tedh@moz-F0B37C08.hsd1.il.comcast.net)
[08:56:19] *** Quits: tedh (tedh@moz-F0B37C08.hsd1.il.comcast.net) (Ping timeout)
[08:57:19] <eddyb9> in parse.rs, I can see that (A, ..(B, C), D) could be expanded immediately
[08:57:40] <eddyb9> but (A, ..B, C) couldn't, because B is just a path
[08:58:08] <eddyb9> where are types fully resolved?
[08:58:19] <cmr> in resolve
[08:58:27] <cmr> librustc/middle/resolve.rs
[08:59:03] <eddyb9> hehe, if I had used that verb earlier, I would've known what to look for
[08:59:30] <cmr> yup
[08:59:43] *** Joins: tedh (tedh@moz-F0B37C08.hsd1.il.comcast.net)
[09:01:57] <eddyb9> ty_tup(~[Ty]), if I make that ty_tup(~[(bool, Ty)]) (or by using an enum), it's too hacky
[09:02:15] <eddyb9> since I have to do it in a few arrays
[09:04:00] *** Joins: Sharp (Sharp@moz-7B61DF4.dsl.static.sonic.net)
[09:04:22] <cmr> acrichto: when do you sleep?
[09:04:29] <acrichto> oh god it's 1am
[09:04:31] <cmr> I know I shouldn't be talking, since I'm in EST, but still...
[09:04:37] <acrichto> jeez
[09:04:39] <acrichto> go to bed lol
[09:04:41] <cmr> :P
[09:04:50] <acrichto> what's an invalid utf8 sequence
[09:05:00] <eddyb9> if I add two expansions, one for an immediate tuple, in parse, and one for a path, in resolve... is that duplicated?
[09:05:01] <cmr> 0x80
[09:05:27] * acrichto make check-stage0-std
[09:05:49] <eddyb9> I mean, it really depends on the code size (a match against ty_tup and push_all should be enough)
[09:06:47] <eddyb9> how bad would it be to add a "preceded by DOTDOT" flag to ty_path?
[09:07:06] <eddyb9> in terms of some form of sanity
[09:12:54] <eddyb9> it would only make sense in a few contexts (tuple, type arguments, fn arguments)
[09:15:13] <cmr> acrichto: an interesting addition to the testsuite would be make sure everything in compile-fail still fails with --no-trans. ie, trans shouldn't be emitting its  own errors, any errors should be caught by analysis
[09:17:57] <eddyb9> well, if I add that flag to ty_tup and ty_path, I can handle both in resolve
[09:18:25] <eddyb9> otherwise, there would be some nasty code when parsing, for example, tuple-like structs
[09:19:59] <acrichto> cmr: some errors get cauht in trans though
[09:20:17] <cmr> acrichto: what errors get caught in trans that actually belong in trans?
[09:20:50] <acrichto> cmr: transmute on different size types
[09:21:02] <cmr> Ok, that's reasonble
[09:21:06] <cmr> xfail-no-trans :p
[09:26:27] *** Quits: Kxepal (Miranda@moz-A25B204D.pppoe.mtu-net.ru) (Ping timeout)
[09:26:46] <eddyb9> resolve_type looks like what I'd need to change, right now it only handles ty_path and ty_closure
[09:27:41] <cmr> Yikes, metadata is crazy
[09:27:55] <cmr> It reconstructs a tyencode::ctxt every time it needs one
[09:29:01] <cmr> This is really crazy
[09:29:15] <cmr> This rage refactor is going to take awhile..
[09:29:53] *** Joins: Kxepal (Miranda@moz-A25B204D.pppoe.mtu-net.ru)
[09:31:40] <cmr> guh, this is so nuts
[09:32:06] <eddyb9> resolve doesn't mutate the Ty it receives, which isn't even mutable
[09:32:16] <eddyb9> hmpf
[09:34:45] <eddyb9> what I would do, for ty_tup, is walk the types (to resolve them), then iterate, and for ty_tup or ty_path marked as "expand", replace them with the Ty vector from the referenced ty_tup
[09:39:06] <eddyb9> one danger here is that unhandled cases would turn something like (A, ..(B, C), D) into (A, (B, C), D)
[09:43:23] <cmr> So I'm thinking we should get an I-tedious
[09:45:00] <eddyb9> is there no way to mutate a Ty which is part of the AST?
[09:45:15] <cmr> eddyb9: the AST is supposed to be immutable
[09:45:18] <eddyb9> is it "frozen" after creation?
[09:45:30] <eddyb9> well, how am I supposed to do this then?
[09:45:33] <cmr> fold
[09:45:49] <eddyb9> oh, fold is a transform?
[09:46:17] <cmr> yes
[09:46:25] <eddyb9> there is no fold running as part of resolve, is there?
[09:46:34] <cmr> I have no idea
[09:46:57] <eddyb9> grep says no
[09:47:21] <eddyb9> I don't want to change a lot of code for this :(
[09:47:42] <eddyb9> I mean, adding a "flatten type lists" pass seems ridiculous
[09:47:58] <cmr> might ask pcwalton what to do? he basically owns resolve
[09:48:10] <eddyb9> cmr: good idea, thanks
[09:51:06] <eddyb9> well, it should be part of generic instantiation, too, so I can't just do it in resolve, I don't think
[09:52:17] <eddyb9> oh, there's a ty_fold.rs
[09:54:01] <dbaupp> cmr: how often do we do a .to_managed()? https://github.com/mozilla/rust/issues/10516
[09:54:14] * dbaupp thought that stopped after the parser
[09:54:33] <acrichto> https://gist.github.com/alexcrichton/7498280
[09:54:33] <cmr> dbaupp: the parser and everything that touches libsyntax
[09:54:39] <acrichto> and with that, I'm sleeping
[09:55:19] <dbaupp> cmr: and how much time does it spend copying?
[09:56:10] <cmr> dbaupp: when I last looked into it, I removed only a few of them and got a memory reduction by 1/3, with a ~3s speedup
[09:56:26] <cmr> (this is with --parse-only on librustc)
[09:56:39] <cmr> maybe it wasn't 3s, but a small percentage
[09:56:42] <dbaupp> what's the absolute memory reduction?
[09:56:55] <dbaupp> it'll be like, 30 MB, right?
[09:57:11] <cmr> it's not a lot, yeah
[09:57:15] <cmr> but it's a code smell
[09:57:29] * dbaupp thinks there are more productive uses of refactoring time
[09:57:36] <cmr> probably
[09:58:05] <dbaupp> most of the @str's should/could be slices into an internal buffer in the interner, or something like that.
[09:58:09] <cmr> yep
[09:58:13] * dbaupp isn't sure how lifetimes would work with that...
[09:58:26] <cmr> we do a ridiculous amount of to_managed() in libsyntax
[09:58:37] <dbaupp> I guess work on a well supported arena allocator would help.
[09:58:57] <cmr> dbaupp: well, for it to be easy to change, it'd need to be using &'static
[09:59:02] <dbaupp> most of it's just the quoter :P
[09:59:29] <cmr> a lot of those are in loops
[09:59:39] <cmr> (outsidethe quoter)
[10:00:16] <dbaupp> I guess we really need @str to support slicing to a sub-@str and have the containing string GC'd with the substrings, or something like that.
[10:00:27] <dbaupp> (at least, that would be a more useful form of @str)
[10:00:36] <eddyb9> ooh, middle/typeck/infer/resolve.rs does a ty_fold
[10:01:05] <cmr> dbaupp: and be able togeta reference to a @str given a &str,
[10:02:08] <cmr> getting rustc into a sane state isn't going to be easy, it needs a lot of  restructuring
[10:02:25] * dbaupp agrees 10000%
[10:03:34] <eddyb9> the infer resolver is a good place to expand tuples
[10:04:03] <eddyb9> but... I need to handle ..T in everything ran before that
[10:04:18] <cmr> anyway, I need to get to bed before mletterle wakes up. and I'm pretty sure we're in the same (or nearby) time zone
[10:04:37] <eddyb9> is there a diagram for the compilation process?
[10:04:46] <dbaupp> eddyb9: in what detail?
[10:05:01] <dbaupp> eddyb9: there's a "diagram" in rustc/driver/driver.rs
[10:05:10] <eddyb9> I want to know what passes run before typeck/infer/resolve
[10:05:14] <eddyb9> dbaupp: thanks
[10:05:17] <dbaupp> (and or the output of rustc foo.rs -Z time-passes)
[10:06:13] <dbaupp> eddyb9: http://ix.io/92z
[10:07:51] <eddyb9> ok, doesn't look like anything cares about types before typeck
[10:08:34] <eddyb9> I really don't want (A, ..B, C) being treated as (A, B, C)
[10:13:00] <eddyb9> dbaupp: hmm, what's instantiating generic methods? trans?
[10:13:19] *** Joins: notmatt (notmatt@moz-3C7AF18C.lightspeed.sntcca.sbcglobal.net)
[10:15:37] <eddyb9> type Fn<Ret, Args> = fn(..Args) -> Ret;
[10:15:54] <eddyb9> I'm afraid that might be impossible because of missing type bounds
[10:16:16] <eddyb9> is generic instantiation allowed to fail?
[10:17:07] <eddyb9> where does generic type alias instantiation happen?
[10:17:19] <eddyb9> (oh, I have so many questions :P)
[10:19:43] *** Quits: Sharp (Sharp@moz-7B61DF4.dsl.static.sonic.net) (Quit: Sharp)
[10:20:51] <dbaupp> you mean monomorphising them?
[10:21:02] * dbaupp doesn't know the depths of the compiler
[10:25:14] <eddyb9> it might happen later on...
[10:34:32] *** Joins: Sharp (Sharp@moz-7B61DF4.dsl.static.sonic.net)
[10:35:12] <eddyb9> maybe I can hijack fold_ty_vec to flatten ..T
[10:36:41] *** Quits: Sharp (Sharp@moz-7B61DF4.dsl.static.sonic.net) (Quit: Sharp)
[10:41:22] <eddyb9> sty means "super type"? how does that work :/?
[10:42:04] <dbaupp> s[uper]ty[pe]
[10:42:04] <dbaupp> easy
[10:42:05] <dbaupp> :P
[10:42:49] <eddyb9> I mean, there is apparently some type hierarchy, but it's a little obscure to me
[10:52:36] <eddyb9> rusti: fn foo<T>(x: T) -> int {x as int}
[10:52:37] -rusti- <anon>:9:33: 9:41 error: non-scalar cast: `T` as `int`
[10:52:37] -rusti- <anon>:9          fn foo<T>(x: T) -> int {x as int}
[10:52:37] -rusti-                                           ^~~~~~~~
[10:52:37] -rusti- error: aborting due to previous error
[10:52:37] -rusti- application terminated with error code 101
[10:55:02] <eddyb9> rusti: fn foo<T>(x: T) -> (int, ..T) {(0, ..x)}
[10:55:02] -rusti- <anon>:9:34: 9:36 error: expected type, found token DOTDOT
[10:55:03] -rusti- <anon>:9          fn foo<T>(x: T) -> (int, ..T) {(0, ..x)}
[10:55:03] -rusti-                                            ^~
[10:55:03] -rusti- application terminated with error code 101
[10:55:51] <eddyb9> should that fail?
[10:56:33] * eddyb9 's head is spinning around
[11:00:19] <eddyb9> type Pair<A, B> = (A, B); doesn't need monomorphization for type checks
[11:01:16] <eddyb9> rusti: fn foo<T>(x: T) -> (int, int) {x}
[11:01:17] -rusti- <anon>:9:40: 9:41 error: mismatched types: expected `(int,int)` but found `T` (expected tuple but found type parameter)
[11:01:17] -rusti- <anon>:9          fn foo<T>(x: T) -> (int, int) {x}
[11:01:17] -rusti-                                                  ^
[11:01:17] -rusti- error: aborting due to previous error
[11:01:18] -rusti- application terminated with error code 101
[11:01:53] <eddyb9> the entire type system is built on that assumption :(
[11:03:17] <eddyb9> type WrapTuple<T, U> = (U, ..T, U); seems impossible to implement
[11:03:52] *** Quits: notmatt (notmatt@moz-3C7AF18C.lightspeed.sntcca.sbcglobal.net) (Client exited)
[11:04:56] <eddyb9> even if it has the same physical repr as (U, T, U)
[11:08:53] <eddyb9> rusti: type Wrap<T, U> = (U, T, U); let x: Wrap = ('(', (1, 2), ')'); x
[11:08:54] -rusti- <anon>:9:45: 9:49 error: wrong number of type arguments: expected 2 but found 0
[11:08:54] -rusti- <anon>:9          type Wrap<T, U> = (U, T, U); let x: Wrap = ('(', (1, 2), ')'); x
[11:08:54] -rusti-                                                       ^~~~
[11:08:54] -rusti- application terminated with error code 101
[11:09:00] *** Joins: notmatt (notmatt@moz-3C7AF18C.lightspeed.sntcca.sbcglobal.net)
[11:09:23] <eddyb9> is that kind of inference implemented in master?
[11:10:18] *** Quits: notmatt (notmatt@moz-3C7AF18C.lightspeed.sntcca.sbcglobal.net) (Client exited)
[11:11:30] <eddyb9> why is 'foo called a "region" and not a "lifetime"?
[11:12:41] <eddyb9> type foo = { x: &a.int, y: &fn(&a.int) }
[11:12:55] <eddyb9> is that obsolete syntax?
[11:18:58] <dbaupp> eddyb9: no, history, yes
[11:19:43] <eddyb9> so refactor is needed?
[11:20:03] <eddyb9> I can barely understand what is going on
[11:20:58] *** Joins: jensnockert (jensnocker@moz-7DC16A5F.afb.bredband2.com)
[11:21:55] <dbaupp> r? https://github.com/mozilla/rust/pull/10518
[11:22:36] <eddyb9> ast_ty_to_ty seems like another good place to resolve expansion
[11:23:36] <eddyb9> what's using ast::Ty?
[11:23:47] <dbaupp> typeck?
[11:24:05] *** Quits: yuriks_ (yuriks@DD48A7C8.D06AB739.748B6D8D.IP) (Connection reset by peer)
[11:24:07] *** Joins: yuriks (yuriks@DD48A7C8.D06AB739.748B6D8D.IP)
[11:25:16] <eddyb9> I'm looking at typeck/astconv.rs
[11:26:35] <eddyb9> I guess after collect is ran, only ty::t types are used
[11:27:00] * dbaupp is at the limit of his knowledge when suggesting "typeck", and will be no more help.
[11:27:47] <eddyb9> I'm waiting for someone more knowledgeable to come around, anyway
[11:28:40] <eddyb9> if astconv has debug output, I should be able to use that
[11:36:11] <eddyb9> rusti: type Wrap<T, U> = (U, T, U); let x: Wrap<char, (int, int)> = ('(', (1, 2), ')'); x
[11:36:12] -rusti- pastebinned 5 lines of output: http://sprunge.us/VKae
[11:36:39] <eddyb9> oops
[11:36:52] <eddyb9> rusti: type Wrap<T, U> = (U, T, U); let x: Wrap<(int, int), char> = ('(', (1, 2), ')'); x
[11:36:52] -rusti- ('(', (1, 2), ')')
[11:37:15] <eddyb9> but the error message looks like monomorphization :D
[11:41:02] <dbaupp> acrichto: meh, looks like supporting {.foo} will be pretty hard/impossible (it'll have to reencode the runtime ArgumentNext logic to work out which fields it needs to be .foo-ing, but then we might as well just compute the ArgumentNext's entirely at compile time, defeating the purpose of it, right?), so I'm going to go back to just {0.foo} and {x.foo}
[11:44:04] *** Quits: jensnockert (jensnocker@moz-7DC16A5F.afb.bredband2.com) (Input/output error)
[11:44:34] *** Joins: jensnockert (jensnocker@moz-7DC16A5F.afb.bredband2.com)
[11:44:56] <eddyb9> rusti: type Pair<T,U>=(T,U);
[11:44:56] -rusti- <anon>:9:22: 9:24 error: expected `,` but found `>=`
[11:44:56] -rusti- <anon>:9          type Pair<T,U>=(T,U);
[11:44:56] -rusti-                                ^~
[11:44:57] -rusti- application terminated with error code 101
[11:45:06] <eddyb9> that's just ridiculous :(
[11:45:21] <dbaupp> haha
[11:45:25] <eddyb9> (one of the many reasons I dislike tokenizers)
[11:45:28] <dbaupp> rusti: &&"foo"
[11:45:28] -rusti- <anon>:9:9: 9:11 error: unexpected token: `&&`
[11:45:29] -rusti- <anon>:9          &&"foo"
[11:45:29] -rusti-                   ^~
[11:45:29] -rusti- application terminated with error code 101
[11:45:57] <dbaupp> eddyb9: (file a bug about the >= one)
[11:46:20] *** Quits: jensnockert (jensnocker@moz-7DC16A5F.afb.bredband2.com) (Ping timeout)
[11:46:25] <eddyb9> and someone will make the generic arg parse code handle >=...
[11:46:50] *** Joins: jensnockert (jensnocker@moz-7DC16A5F.afb.bredband2.com)
[11:50:53] <eddyb9> hmm, what's "rib"?
[11:53:51] <eddyb9> wait, resolve handles type parameters? how... does that work?
[11:58:26] <eddyb9> but I don't see a tuple of two type arguments, which is good
[12:02:07] <eddyb9> if I make (A, ..B, C) fail in astconv if B isn't a known tuple... types should work, functions generic over such an expansion shouldn't
[12:03:13] <eddyb9> which is kinda fine for me, as you would usually use a variadic generic in that case
[12:18:15] *** Quits: yuriks (yuriks@DD48A7C8.D06AB739.748B6D8D.IP) (Ping timeout)
[12:22:07] *** Quits: ktt3ja (Mibbit@moz-F40FE31.washdc.fios.verizon.net) (Quit: http://www.mibbit.com ajax IRC Client)
[12:38:04] <dbaupp> acrichto: wait... some parts of the code "dereference" ArgumentNext into an actual number (the verify_* functions), while others don't (trans_piece)... couldn't all the indexing be resolved at compile time?
[12:41:41] *** Quits: jensnockert (jensnocker@moz-7DC16A5F.afb.bredband2.com) (Input/output error)
[12:42:09] *** Joins: jensnockert (jensnocker@moz-7DC16A5F.afb.bredband2.com)
[12:43:59] *** Quits: jensnockert (jensnocker@moz-7DC16A5F.afb.bredband2.com) (Ping timeout)
[12:55:21] *** Joins: pnkfelix (pnkfelix@DA4ABEAF.1DE10CA8.D8E68FF6.IP)
[12:55:21] *** ChanServ sets mode: +o pnkfelix
[12:57:09] *** Quits: pnkfelix (pnkfelix@DA4ABEAF.1DE10CA8.D8E68FF6.IP) (Ping timeout)
[13:00:06] *** Joins: jensnockert (jensnocker@moz-7DC16A5F.afb.bredband2.com)
[13:01:30] <eddyb9> resolve can't change types
[13:02:05] <eddyb9> but it should resolve uses of generics, I think
[13:02:45] <eddyb9> I guess I have to change astconv to pretty-print
[13:03:32] *** Joins: pnkfelix (pnkfelix@DA4ABEAF.1DE10CA8.D8E68FF6.IP)
[13:03:32] *** ChanServ sets mode: +o pnkfelix
[13:06:20] *** Quits: pnkfelix (pnkfelix@DA4ABEAF.1DE10CA8.D8E68FF6.IP) (Ping timeout)
[13:06:54] *** Joins: pnkfelix (pnkfelix@87C1F78E.1DE10CA8.D8E68FF6.IP)
[13:06:54] *** ChanServ sets mode: +o pnkfelix
[13:28:02] *** Joins: yuriks (yuriks@DD48A7C8.D06AB739.748B6D8D.IP)
[13:37:01] <eddyb9> weekend *and* night in US - worst time to be in here, I think
[13:39:26] <eddyb9> I think that impl<T, U> Foo for (T, U) requires some code to deduce T and U from (T, U)
[13:40:02] <eddyb9> rusti: trait Foo {} impl<T, U> Foo for (T, U) {}
[13:40:03] -rusti- ()
[13:40:57] <eddyb9> rusti: type Pair<T, U> = (T, U); trait Foo {fn bar(){}} impl<T, U> Foo for Pair<T, U> {}
[13:40:58] -rusti- ()
[13:42:11] <eddyb9> rusti: type Pair<T, U> = (T, U); trait Foo {fn bar(self) {print!("{:?} ", self);}} impl<T, U> Foo for Pair<T, U> {} (1, 2).bar()
[13:42:12] -rusti- (1, 2) ()
[13:42:30] <eddyb9> rusti: type Pair<T, U> = (T, U); trait Foo {fn bar(self) {print!("{:?} ", self);}} impl<T, U> Foo for Pair<T, U> {} (1, 'a').bar()
[13:42:30] -rusti- (1, 'a') ()
[13:42:37] <eddyb9> rusti: type Pair<T, U> = (T, U); trait Foo {fn bar(self) {print!("{:?} ", self);}} impl<T, U> Foo for Pair<T, U> {} (1, 'a', 2).bar()
[13:42:37] -rusti- <anon>:9:118: 10:5 error: type `(<VI0>,char,<VI1>)` does not implement any method in scope named `bar`
[13:42:37] -rusti- <anon>:9          type Pair<T, U> = (T, U); trait Foo {fn bar(self) {print!("{:?} ", self);}} impl<T, U> Foo for Pair<T, U> {} (1, 'a', 2).bar()
[13:42:37] -rusti- <anon>:10     };
[13:42:37] -rusti- error: aborting due to previous error
[13:42:38] -rusti- application terminated with error code 101
[13:42:56] <eddyb9> rusti: type Pair<T, U> = (T, U, T); trait Foo {fn bar(self) {print!("{:?} ", self);}} impl<T, U> Foo for Pair<T, U> {} (1, 'a', 2).bar()
[13:42:57] -rusti- (1, 'a', 2) ()
[13:43:46] <eddyb9> I'm guessing it expands Pair quite soon, so ..T or ..U wouldn't work anyway
[13:53:44] <eddyb9> rusti: let x: Clone;
[13:53:45] -rusti- <anon>:9:16: 9:21 error: reference to trait `Clone` where a type is expected; try `@Clone`, `~Clone`, or `&Clone`
[13:53:45] -rusti- <anon>:9          let x: Clone;
[13:53:45] -rusti-                          ^~~~~
[13:53:45] -rusti- error: aborting due to previous error
[13:53:45] -rusti- application terminated with error code 101
[13:54:22] <eddyb9> so it's not a bad idea to throw errors for ..T there
[13:56:01] <eddyb9> rusti: let x: int; let y: x;
[13:56:01] -rusti- <anon>:9:28: 9:29 error: use of undeclared type name `x`
[13:56:02] -rusti- <anon>:9          let x: int; let y: x;
[13:56:02] -rusti-                                      ^
[13:56:02] -rusti- error: aborting due to previous error
[13:56:02] -rusti- application terminated with error code 101
[13:56:10] <eddyb9> weird
[14:27:01] <eddyb9> don't tell me I have to touch middle/type.rs
[14:28:03] <eddyb9> well, ..(...) can be replaced in astconv or something
[14:30:03] <eddyb9> but there's no path left, so it should go into type parameters
[14:41:08] <eddyb9> fold_ty for TpsFold in middle/ty looks good enough. but it means I have to fold ..T in ty and make astconv use that when ..path is known or something
[14:46:56] *** Quits: jensnockert (jensnocker@moz-7DC16A5F.afb.bredband2.com) (Input/output error)
[14:47:25] *** Joins: jensnockert (jensnocker@moz-7DC16A5F.afb.bredband2.com)
[14:49:14] *** Quits: jensnockert (jensnocker@moz-7DC16A5F.afb.bredband2.com) (Ping timeout)
[14:59:33] *** Quits: rusti (rusti@moz-54F7FD49.cpe.net.cable.rogers.com) (Ping timeout)
[15:16:16] *** Joins: rusti (rusti@moz-54F7FD49.cpe.net.cable.rogers.com)
[15:34:43] *** Quits: tedh (tedh@moz-F0B37C08.hsd1.il.comcast.net) (Ping timeout)
[15:36:07] *** Joins: tedh (tedh@moz-F0B37C08.hsd1.il.comcast.net)
[15:47:35] *** Quits: tedh (tedh@moz-F0B37C08.hsd1.il.comcast.net) (Ping timeout)
[15:50:58] *** Joins: tedh (tedh@moz-F0B37C08.hsd1.il.comcast.net)
[16:46:06] *** Quits: Axord (xord@moz-1B228827.lsanca.dsl-w.verizon.net) (Quit: I'm sure it's perfectly safe)
[17:20:29] *** Joins: blank_name (blank_name@FAB53C88.7071B2C8.31EC03F3.IP)
[17:24:10] *** Quits: Jesse (jruderman@moz-9754CB0.hsd1.ca.comcast.net) (Ping timeout)
[17:26:29] *** Joins: Jesse (jruderman@moz-9754CB0.hsd1.ca.comcast.net)
[17:33:34] *** Joins: Sharp (Sharp@moz-7B61DF4.dsl.static.sonic.net)
[17:36:04] *** Quits: Sharp (Sharp@moz-7B61DF4.dsl.static.sonic.net) (Quit: Sharp)
[17:41:49] *** Quits: pnkfelix (pnkfelix@87C1F78E.1DE10CA8.D8E68FF6.IP) (Quit: Leaving.)
[17:43:16] *** Quits: gavin (gavin@moz-DB4A9C19.scl3.mozilla.com) (Ping timeout)
[17:43:53] *** Joins: gavin (gavin@moz-DB4A9C19.scl3.mozilla.com)
[17:51:09] *** Quits: gavin (gavin@moz-DB4A9C19.scl3.mozilla.com) (Connection reset by peer)
[17:51:46] *** Quits: nmatsakis (nmatsakis@moz-DB4A9C19.scl3.mozilla.com) (Connection reset by peer)
[17:55:58] *** Quits: lbergstrom (lbergstrom@moz-DB4A9C19.scl3.mozilla.com) (Ping timeout)
[18:02:08] *** Quits: flaper87|afk (flaper87@moz-107AD163.redhat.com) (Ping timeout)
[18:05:41] *** Quits: Jesse (jruderman@moz-9754CB0.hsd1.ca.comcast.net) (Quit: Jesse)
[18:12:30] *** Joins: SiegeLord (sl@moz-CAF07B4C.hsd1.ma.comcast.net)
[18:19:51] *** Joins: flaper87|afk (flaper87@moz-107AD163.redhat.com)
[18:35:43] *** Joins: jensnockert (jensnocker@moz-7DC16A5F.afb.bredband2.com)
[19:04:39] *** Quits: jensnockert (jensnocker@moz-7DC16A5F.afb.bredband2.com) (Input/output error)
[19:05:11] *** Joins: jensnockert (jensnocker@moz-7DC16A5F.afb.bredband2.com)
[19:05:14] *** Joins: nmatsakis (nmatsakis@moz-DB4A9C19.scl3.mozilla.com)
[19:05:15] *** ChanServ sets mode: +ao nmatsakis nmatsakis
[19:05:42] *** Joins: gavin (gavin@moz-DB4A9C19.scl3.mozilla.com)
[19:06:39] *** Quits: jensnockert (jensnocker@moz-7DC16A5F.afb.bredband2.com) (Input/output error)
[19:06:48] *** Joins: jensnockert (jensnocker@moz-7DC16A5F.afb.bredband2.com)
[19:07:16] *** Joins: lbergstrom (lbergstrom@moz-DB4A9C19.scl3.mozilla.com)
[19:09:38] *** Quits: gavin (gavin@moz-DB4A9C19.scl3.mozilla.com) (Input/output error)
[19:09:39] *** Quits: nmatsakis (nmatsakis@moz-DB4A9C19.scl3.mozilla.com) (Input/output error)
[19:10:39] *** Quits: lbergstrom (lbergstrom@moz-DB4A9C19.scl3.mozilla.com) (Ping timeout)
[19:13:54] *** Joins: nmatsakis (nmatsakis@moz-DB4A9C19.scl3.mozilla.com)
[19:13:54] *** ChanServ sets mode: +ao nmatsakis nmatsakis
[19:13:58] *** Joins: lbergstrom (lbergstrom@moz-DB4A9C19.scl3.mozilla.com)
[19:14:23] *** Joins: gavin (gavin@moz-DB4A9C19.scl3.mozilla.com)
[19:34:24] <sfackler> acrichto: how would you feel about reducing Cell's API to new and take, and then renaming it to Move?
[19:36:36] *** Quits: nmatsakis (nmatsakis@moz-DB4A9C19.scl3.mozilla.com) (Input/output error)
[19:36:53] *** Quits: gavin (gavin@moz-DB4A9C19.scl3.mozilla.com) (Input/output error)
[19:37:38] *** Quits: lbergstrom (lbergstrom@moz-DB4A9C19.scl3.mozilla.com) (Ping timeout)
[19:38:12] *** Joins: nmatsakis (nmatsakis@moz-DB4A9C19.scl3.mozilla.com)
[19:38:12] *** ChanServ sets mode: +ao nmatsakis nmatsakis
[19:38:14] <acrichto> hmm
[19:38:39] *** Joins: gavin (gavin@moz-DB4A9C19.scl3.mozilla.com)
[19:38:52] <acrichto> sfackler: let's not rename the api just yet, just reduce it
[19:38:58] <sfackler> ok
[19:40:28] *** Quits: gavin (gavin@moz-DB4A9C19.scl3.mozilla.com) (Ping timeout)
[19:41:11] *** Quits: nmatsakis (nmatsakis@moz-DB4A9C19.scl3.mozilla.com) (Ping timeout)
[19:47:56] <cmr> eddyb: isn't compiler work  wonderful? :>
[19:48:27] <eddyb> cmr: oh fuck off
[19:48:33] <cmr> :D
[19:48:46] <eddyb> cmr: don't worry, I've only done research on it, and I have a possible injection point
[19:49:00] <eddyb> I'm afraid of messing too much with the type system, because it's bound to break after some point
[19:49:05] <cmr> If you figure out what the heck a "rib" is let me know, because that also confused me
[19:49:20] <eddyb> oh damn this keyboard is so noisy if I type fast like that, when I don't have to think
[19:49:26] <eddyb> cmr: hehe
[19:49:47] <eddyb> I'm now working on my emulator thing
[19:53:21] <eddyb> and almost spilling my drink while watching Dexter, over and over again
[19:59:45] <Luqman> cmr: compiling's just a waste of time no? :P
[20:00:01] <cmr> it is
[20:09:58] *** Joins: nmatsakis (nmatsakis@moz-DB4A9C19.scl3.mozilla.com)
[20:09:58] *** ChanServ sets mode: +ao nmatsakis nmatsakis
[20:10:23] *** Joins: lbergstrom (lbergstrom@moz-DB4A9C19.scl3.mozilla.com)
[20:10:33] *** Joins: gavin (gavin@moz-DB4A9C19.scl3.mozilla.com)
[20:20:53] *** Quits: lbergstrom (lbergstrom@moz-DB4A9C19.scl3.mozilla.com) (Ping timeout)
[20:21:07] *** Quits: nmatsakis (nmatsakis@moz-DB4A9C19.scl3.mozilla.com) (Ping timeout)
[20:21:19] *** Quits: gavin (gavin@moz-DB4A9C19.scl3.mozilla.com) (Ping timeout)
[20:22:53] *** Joins: nmatsakis (nmatsakis@moz-DB4A9C19.scl3.mozilla.com)
[20:22:53] *** ChanServ sets mode: +ao nmatsakis nmatsakis
[20:22:54] *** Joins: gavin (gavin@moz-DB4A9C19.scl3.mozilla.com)
[20:26:43] *** Joins: lbergstrom (lbergstrom@moz-DB4A9C19.scl3.mozilla.com)
[20:29:10] *** Quits: jensnockert (jensnocker@moz-7DC16A5F.afb.bredband2.com) (Input/output error)
[20:50:48] *** Joins: nrc (nrc@7BE24E90.A5032A01.3CFC199D.IP)
[20:59:28] *** Quits: kaeso (kaeso@moz-F21FF626.unstable.it) (Ping timeout)
[21:00:32] *** Joins: kaeso (kaeso@moz-F21FF626.unstable.it)
[21:03:01] <cmr> booooooors :(
[21:03:50] <cmr> acrichto: I've come to agree with you about the "removing previous" etc
[21:04:00] <cmr> I think unless VERBOSE=1, the makefile should be very quiet.
[21:04:13] <cmr> ie, only print a line hitting off a build of something, not a copy etc
[21:06:01] <acrichto> so much noise
[21:10:01] <eddyb> (or, you know, format the output, maybe color it)
[21:10:32] *** Joins: jensnockert (jensnocker@moz-7DC16A5F.afb.bredband2.com)
[21:10:47] <eddyb> so it's easy to ignore simple tasks
[21:13:40] <cmr> sure, with VERBOSE=1 :P
[21:15:52] <eddyb> I'd have VERBOSE also print different stages of compilation
[21:16:35] <cmr> such as?
[21:16:45] <cmr> (VERBOSE=2)
[21:16:49] <cmr> (jus sayin)
[21:16:51] <eddyb> like time-passes or whatever... oh nvm
[21:16:57] <eddyb> sounds good :)
[21:17:04] <eddyb> (as long as it's documented. pls)
[21:17:13] <cmr> Documentation? About our build system? Pah!
[21:59:49] *** Joins: Jesse (jruderman@moz-9754CB0.hsd1.ca.comcast.net)
[22:09:00] *** Quits: eddyb (eddy@336E3A7F.D51DAF03.FB866788.IP) (Ping timeout)
[22:16:17] *** Quits: Jesse (jruderman@moz-9754CB0.hsd1.ca.comcast.net) (Quit: Jesse)
[22:17:54] <dbaupp> cmr: https://github.com/mozilla/rust/pull/10523 r?
[22:19:38] <cmr> bors :(
[22:20:20] <dbaupp> what happened?
[22:20:31] <dbaupp> (also, you should remove the test you're adding for 10288)
[22:20:34] <cmr> he's still down
[22:21:19] <dbaupp> I didn't even know he was down...
[22:22:35] <cmr> lack of gh-rust and me moaning "bors" every so often didn't give it away? :P
[22:27:04] <dbaupp> well, I'm  guess I'm not paying enough attention :P
[22:27:18] *** Quits: eddyb9 (eddy@336E3A7F.D51DAF03.FB866788.IP) (Ping timeout)
[22:28:45] *** Joins: eddyb9 (eddy@336E3A7F.D51DAF03.FB866788.IP)
[22:29:28] *** Quits: blank_name (blank_name@FAB53C88.7071B2C8.31EC03F3.IP) (Ping timeout)
[22:30:13] *** Joins: blank_name (blank_name@FAB53C88.7071B2C8.31EC03F3.IP)
[22:32:07] *** Quits: jensnockert (jensnocker@moz-7DC16A5F.afb.bredband2.com) (Input/output error)
[22:36:46] *** Joins: ghrust (ghrust@24260B07.6A2AE50.F3114085.IP)
[22:36:46] <ghrust> 01[13rust01] 15bors 04force-pushed 06auto from 145effb35 to 1490754ae: 02http://git.io/N3iJvQ
[22:36:46] *** Parts: ghrust (ghrust@24260B07.6A2AE50.F3114085.IP) ()
[22:36:47] *** Joins: ghrust (ghrust@79968228.6A2AE50.F3114085.IP)
[22:36:47] <ghrust> 01[13rust01] 15bors pushed 2 new commits to 06auto: 02http://git.io/aR7yEQ
[22:36:47] <ghrust> 13rust/06auto 142337d88 15Seo Sanghyeon: Fix path parsing
[22:36:47] <ghrust> 13rust/06auto 14b0e1318 15bors: auto merge of #10420 : sanxiyn/rust/path, r=cmr...
[22:36:47] *** Parts: ghrust (ghrust@79968228.6A2AE50.F3114085.IP) ()
[22:37:43] *** Joins: Sharp (Sharp@moz-7B61DF4.dsl.static.sonic.net)
[22:39:34] *** Joins: strcat (strcat@moz-54F7FD49.cpe.net.cable.rogers.com)
[22:40:20] <andrew-d> cmr: ^^^ it's alive!
[22:52:01] <cmr> \o
[22:52:03] <cmr> /
[22:52:49] <eddyb9> cmr: who'd chop your left hand?
[22:53:18] <cmr> eddyb9: shouldn't you be sleeping? :P
[22:53:43] <eddyb9> cmr: but I have structures to design!
[22:53:57] <eddyb9> ADTs and traits to conquer
[22:57:36] <eddyb9> just going over things in my head
[23:02:30] *** Quits: nmatsakis (nmatsakis@moz-DB4A9C19.scl3.mozilla.com) (Ping timeout)
[23:02:33] *** Quits: lbergstrom (lbergstrom@moz-DB4A9C19.scl3.mozilla.com) (Ping timeout)
[23:02:33] *** Quits: gavin (gavin@moz-DB4A9C19.scl3.mozilla.com) (Ping timeout)
[23:07:06] *** Joins: lbergstrom (lbergstrom@moz-DB4A9C19.scl3.mozilla.com)
[23:07:10] *** Joins: nmatsakis (nmatsakis@moz-DB4A9C19.scl3.mozilla.com)
[23:07:10] *** ChanServ sets mode: +ao nmatsakis nmatsakis
[23:07:37] *** Joins: gavin (gavin@moz-DB4A9C19.scl3.mozilla.com)
[23:14:45] *** Joins: Jesse (jruderman@moz-9754CB0.hsd1.ca.comcast.net)
[23:14:58] *** Joins: pcwalton (pcwalton@moz-DA87EE4.hsd1.ca.comcast.net)
[23:14:58] *** ChanServ sets mode: +ao pcwalton pcwalton
[23:15:30] *** Quits: pcwalton (pcwalton@moz-DA87EE4.hsd1.ca.comcast.net) (Quit: pcwalton)
[23:24:18] *** Quits: pcmattman (pcmattman@moz-D9B7D938.net) (Ping timeout)
[23:25:04] *** Joins: pcmattman (pcmattman@moz-D9B7D938.net)
[23:30:33] *** Quits: pcmattman (pcmattman@moz-D9B7D938.net) (Ping timeout)
[23:34:35] *** Joins: pcmattman (pcmattman@moz-D9B7D938.net)
[23:48:10] <strcat> acrichto: the communication primitives don't map well to the 1:1 model :(
[23:49:30] <strcat> hm
[23:50:46] <strcat> I was thinking I would just expose a ringbuf behind a mutex + condition variable for a simple blocking queue and make non-blocking lock-free ones later
[23:52:05] <strcat> it seems like an UnsafeArc is going to be the minimum requirement for any 1:1 communication primitives to build on
[23:55:18] *** Joins: tikue (tkuehn@moz-FEADCD38.hsd1.pa.comcast.net)

[00:16:19] *** Joins: cmr (moznet@moz-EC676DFE.members.linode.com)
[00:16:50] *** Quits: lkuper (lkuper@moz-C0CD33ED.hsd1.in.comcast.net) (Ping timeout)
[00:18:34] *** Joins: KindOne (KindOne@7D0DB6F0.E114B4AE.EC6A1518.IP)
[00:19:07] *** Quits: jgilbert_ (jgilbert@43CB6079.66715431.D25A875A.IP) (Ping timeout)
[00:19:58] *** Joins: jmgrosen (jmgrosen@moz-848F6087.sb.sd.cox.net)
[00:20:11] <strcat> hm
[00:20:15] *** Joins: bjz (brendanzab@B398BE78.F804C29E.D35A31DF.IP)
[00:20:19] <brson> bblum: pipes don't work in scheduler context and they also have extra synchronization overhead
[00:20:19] <strcat> I forget if we already have a bug about pointer traits
[00:20:54] <bblum> brson: it seems to me like in the places tube is used, the send and the receive can run concurrently with each other
[00:21:07] <bblum> is there something that prevents that?
[00:21:13] <cmr> And I'm back
[00:21:17] <cmr> graydon: ping
[00:21:19] *** Quits: bent (chatzilla@moz-BE33DA21.fw1.sfo1.mozilla.net) (Quit: ChatZilla 0.9.90-rdmsoft [XULRunner 18.0.2/20130201065344])
[00:21:26] <graydon> cmr: pong
[00:21:40] <cmr> graydon: it seems triage bugs have been assigned to multiple people
[00:21:47] <cmr> I've had a few where others also triaged
[00:21:56] *** Joins: MaikKlein (maik@moz-7F4AE15A.dip0.t-ipconnect.de)
[00:22:14] <bblum> cmr: this may just be because i waited a week to deal with last week's triage bugs
[00:22:24] <bblum> which i now realize gets them assigned to someone else
[00:22:34] <cmr> heh
[00:23:35] <graydon> yeah, I think I've seen this too. I'm curious why it's happening, maybe my script is busted :(
[00:23:54] <cmr> maybe there's not enough to go around?
[00:24:02] <dbaupp> cmr: do you reckon you could also put a file with the output of `git show -s --format='%at%n%s'` in the directory for each hash?
[00:24:53] <cmr> what's that do?
[00:24:58] <tjc> graydon: on a different subject, do you have any ideas about how to handle rustpkg tests for fetching remote packages?
[00:24:59] <cmr> mostly what's the first number
[00:25:01] <cmr> timestamp?
[00:25:05] <tjc> tests have failed because of github being sporadically down
[00:25:05] <dbaupp> yeah
[00:25:06] <tjc> but
[00:25:12] <tjc> I want there to be tests of this feature
[00:25:12] *** Quits: jmgrosen (jmgrosen@moz-848F6087.sb.sd.cox.net) (Ping timeout)
[00:25:13] <cmr> sure
[00:25:26] <dbaupp> cmr: (currently I'm having to cd to my rust dir, and shell out to git... not pretty. :( )
[00:25:27] <graydon> tjc: use local git repos
[00:25:31] <dbaupp> cmr: cool
[00:25:32] *** Quits: maxli (maxli@B5559308.9C54E60.2FA4EA88.IP) (Quit: Leaving.)
[00:25:38] *** Parts: diverse (Mibbit@moz-ED94B8D.oc.oc.cox.net) ()
[00:25:49] *** Joins: maxli (maxli@B5559308.9C54E60.2FA4EA88.IP)
[00:25:51] <MaikKlein> is there a tutorial, how I can turn my rustcode into a c function?
[00:25:58] *** Joins: ghrust (ghrust@AD60B2E3.6A2AE50.F3114085.IP)
[00:25:58] <ghrust> 01[13rust01] 15bors merged 06auto into 06master: 02http://git.io/d4RDQA
[00:25:58] *** Parts: ghrust (ghrust@AD60B2E3.6A2AE50.F3114085.IP) ()
[00:26:05] <cmr> MaikKlein: extern "C" fn () {....}
[00:26:12] <graydon> tjc: otherwise if you absolutely demand seeing git running over a network protocol ... you'll need to use a loopback of some sort. presumably git can be put into local-server mode, but fragile, racy, awkward..
[00:26:13] <tjc> graydon: as it is, rustpkg copies files when installing something from the filesystem, and uses git otherwise...
[00:26:25] <MaikKlein> cmr, hm that seems easy
[00:26:26] <tjc> so should it look for a .git subdir and use git locally as well when one exists?
[00:26:30] <cmr> MaikKlein: make sure you only use c_foo types, from libc, for ABI compat
[00:27:01] <MaikKlein> does anyone know if javascript has a good c interop?
[00:27:21] <cmr> MaikKlein: *javascript*?
[00:27:22] <MaikKlein> i mean all languages should be able to do this
[00:27:27] <MaikKlein> y
[00:27:32] *** Quits: maxli (maxli@B5559308.9C54E60.2FA4EA88.IP) (Ping timeout)
[00:27:35] <dbaupp> cmr: (name = 'commit_info.txt', is ok?)
[00:27:37] <strcat> not actual standard js
[00:27:50] <strcat> node.js has (really bad) ffi
[00:27:54] <MaikKlein> :X
[00:27:55] <cmr> v8 ffi is slow, dunno about the others (I only know this from working with node.js)
[00:27:59] *** Quits: doomlord (doomlod@moz-6651F8D4.range86-145.btcentralplus.com) (Ping timeout)
[00:28:07] <MaikKlein> I wanted to use http://www.tidesdk.org/
[00:28:09] <MaikKlein> with rust
[00:28:11] <MaikKlein> :(
[00:28:17] <MaikKlein> but it also has python
[00:28:25] <MaikKlein> support so I maybe check that out
[00:28:56] *** Joins: ghrust (ghrust@AD60B2E3.6A2AE50.F3114085.IP)
[00:28:56] <ghrust> 01[13rust01] 15bors pushed 0 new commits to 06auto: 02http://git.io/7eKg4g
[00:28:56] *** Parts: ghrust (ghrust@AD60B2E3.6A2AE50.F3114085.IP) ()
[00:28:57] *** Joins: ghrust (ghrust@CFE85B59.6A2AE50.F3114085.IP)
[00:28:58] <ghrust> 01[13rust01] 15bors pushed 3 new commits to 06auto: 02http://git.io/yHZJLg
[00:28:58] <ghrust> 13rust/06auto 14419a147 15Michael Sullivan: Fix make_mono_id to take into account self types. Closes #7536.
[00:28:58] <ghrust> 13rust/06auto 147238d5a 15Michael Sullivan: Make privacy checking on default methods for cross crate structs not fail. Closes #7481....
[00:28:58] <ghrust> 13rust/06auto 1488b3bab 15bors: auto merge of #7545 : msullivan/rust/default-methods, r=catamorphism...
[00:29:00] *** Parts: ghrust (ghrust@CFE85B59.6A2AE50.F3114085.IP) ()
[00:29:23] *** Joins: ross (ross@moz-8A84103E.br.br.cox.net)
[00:29:34] <tikue> strcat: are you still making all iterator changes, or is that work divided among several people?
[00:30:01] <strcat> tikue: there's not much left to change
[00:30:07] <dbaupp> cmr: actually, could the format be '%an %aE%n%at%n%s'?
[00:30:09] <graydon> tjc: well, wait, when does git kick in presently?
[00:30:17] <graydon> tjc: when it sees a pkgid that starts with github.com?
[00:30:22] <tikue> strcat: the set interface has some methods that take callbacks that could be turned into iterators instead
[00:30:22] <graydon> anything else?
[00:30:29] <tjc> graydon: when the pkgid doesn't refer to a directory that exists on the local filesystem
[00:30:30] <cmr> dbaupp: whatever you want :)
[00:30:38] <dbaupp> cmr: well, I want that! :)
[00:30:42] <tjc> I think it'll actually work with any URL of a git repository, but I've only tested it with github :-)
[00:30:48] <tikue> strcat: e.g., fn difference(&self, other: &HashSet<T>, f: &fn(&T) -> bool) -> bool
[00:30:55] <tikue> could be an iterator instead
[00:30:59] <graydon> tjc: then it just .. passes it to git? huh
[00:30:59] <strcat> yeah, I know
[00:31:07] <graydon> tjc: well, ok, so .. maybe refine that a bit :)
[00:31:08] <bjz> MaikKlein Luqman: : eh, I was doing untangling in mat, but I broked some tests. If I push to a new branch, would you be able to have a look and try see what I did?
[00:31:23] <graydon> tjc: like make a guesswork table that maps prefixes to access methods
[00:31:51] <tikue> strcat: oh, ok, just wondering if it was on your radar :)
[00:32:25] <graydon> tjc: then have some prefix be like mockgithub.com/user/foo => git against the local filesystem
[00:32:35] <cmr> dbaupp: anything else that'd be nice to have?
[00:32:39] <graydon> tjc: does that make sense?
[00:32:41] <tjc> graydon: hmm
[00:32:52] <graydon> tjc: we're going to want to support hg and svn prefixes eventually too, as hints
[00:32:59] *** Joins: tiffany (kawaii@moz-1E0FE6E8.dhcp.embarqhsd.net)
[00:32:59] <bjz> Jeaye: jack was talking about how we might be able to use messages behind the scenes for the callbacks in glfw. I was wondering whether you had any thoughts on callbacks from a game dev point of view
[00:33:05] <tjc> I was thinking that in the test, I would just create a local directory called github.com/whatever/whatever and make it a github repo
[00:33:11] <tjc> and change rustpkg to use git clone if it finds a .git
[00:33:17] <tjc> supporting hg and svn is a separate issue :-)
[00:33:51] <MaikKlein> bjz, sure thing
[00:33:51] <bjz> Jeaye: I know I've heard some complaints about the flexibility of callbacks in the past, and was wondering if it would be good to expose the ports directly
[00:34:01] <graydon> tjc: if there's a local directory called github.com/whatever/whatever, then it's already checked out, no?
[00:34:11] <graydon> tjc: I mean, if it's in RUST_PATH
[00:34:23] <tjc> graydon: Yeah, so my thought was the test would just clone that into some other directory
[00:34:28] <tjc> but it seems like kind of a silly thing to test
[00:34:30] <graydon> tjc: then it's already cloned. this is for cases where you want to test rustpkg's willingness to clone
[00:34:51] <graydon> IMO it should clone from not-in-RUST_PATH to workspace-in-RUST_PATH
[00:34:58] <graydon> just treat it like a kind of remote
[00:35:09] <tjc> aha
[00:35:20] <graydon> I think in any case there should be a mapping table from prefix => access method
[00:35:25] <dbaupp> cmr: not right now :)
[00:35:35] <graydon> this is why I suggested doing it now, so you can have a prefix reserved for testing
[00:35:36] <cmr> dbaupp: kk
[00:35:38] <MaikKlein> how do I use a c type? I tried sth like this "let i : libc::types::common::c99::int32_t = 5;"
[00:35:52] <graydon> that treats that mock prefix as a cue to do remote access via looking in the filesystem
[00:35:58] <cmr> MaikKlein: well if you're going to be using int32_t just use i32
[00:35:59] <strcat> MaikKlein: just use i32
[00:36:00] <aatch> MaikKlein, just do std::libc::int32_t
[00:36:08] <aatch> or i32, like those guys said
[00:36:09] <graydon> similarly for downloading tarballs and such. don't actually download them, just grab them from next door on the filesystem.
[00:36:10] <cmr> MaikKlein: but otherwise use std::libc::{c_int, c_void, c_char} etc
[00:36:21] <strcat> I think we should remove the libc types that are always the same as certain rust types
[00:36:31] *** Joins: enix (enix@moz-A50569DD.c3-0.slvr-ubr1.lnh-slvr.md.cable.rcn.com)
[00:36:58] <MaikKlein> thanks
[00:37:19] <aatch> I'm not convinced that the seperation we have at the moment makes sense either...
[00:37:55] <aatch> Or rather, the strangely-nested and then re-exported set up.
[00:37:59] *** Joins: ghrust (ghrust@DE823A67.6A2AE50.F3114085.IP)
[00:37:59] <ghrust> 01[13rust01] 15bors 04force-pushed 06auto from 1488b3bab to 14648c5e9: 02http://git.io/N3iJvQ
[00:37:59] *** Parts: ghrust (ghrust@DE823A67.6A2AE50.F3114085.IP) ()
[00:38:00] *** Joins: ghrust (ghrust@79968228.6A2AE50.F3114085.IP)
[00:38:00] <ghrust> 01[13rust01] 15bors pushed 2 new commits to 06auto: 02http://git.io/vKW0Ug
[00:38:00] <ghrust> 13rust/06auto 14c842f13 15Alex Crichton: Completely disable rusti on 32-bit hosts
[00:38:00] <ghrust> 13rust/06auto 14bd9e362 15bors: auto merge of #7542 : alexcrichton/rust/patch-rusti, r=cmr...
[00:38:00] *** Parts: ghrust (ghrust@79968228.6A2AE50.F3114085.IP) ()
[00:38:20] <strcat> aatch: got a bit further on that header removal btw but I've given up now ;p
[00:38:28] <aatch> strcat, cool.
[00:38:39] <graydon> aatch: it's to make it easier to edit the file and get it correct and complete
[00:38:42] <strcat> aatch: almost all of trans pretends ~[] and ~[] are ~T
[00:38:48] <strcat> aatch: so it breaks nearly everything
[00:38:53] <aatch> strcat, ouch
[00:38:54] <strcat> and ~Trait is broken now
[00:39:14] <graydon> aatch: it's maddeningly difficult to check definitions for all platforms and figure out which are expected / required / defined / vary-by-platform / vary-by-arch
[00:39:15] <MaikKlein> ok cool c interop is really easy
[00:40:58] *** Joins: ghrust (ghrust@FD7BC443.6A2AE50.F3114085.IP)
[00:40:58] <ghrust> 01[13rust01] 15bors 04force-pushed 06auto from 14bd9e362 to 14648c5e9: 02http://git.io/N3iJvQ
[00:40:58] *** Parts: ghrust (ghrust@FD7BC443.6A2AE50.F3114085.IP) ()
[00:41:00] *** Joins: ghrust (ghrust@2EE61FCC.6A2AE50.F3114085.IP)
[00:41:00] <ghrust> 01[13rust01] 15bors pushed 2 new commits to 06auto: 02http://git.io/HNqxYg
[00:41:00] <ghrust> 13rust/06auto 14c842f13 15Alex Crichton: Completely disable rusti on 32-bit hosts
[00:41:00] <ghrust> 13rust/06auto 143c0a162 15bors: auto merge of #7542 : alexcrichton/rust/patch-rusti, r=cmr...
[00:41:01] *** Parts: ghrust (ghrust@2EE61FCC.6A2AE50.F3114085.IP) ()
[00:41:36] *** Quits: xLII (xLII@4BED3CB3.F5F53E8A.2D6DB75E.IP) (Ping timeout)
[00:41:37] <MaikKlein> ah whatever I probably just use Qt
[00:42:02] <cmr> C++ interop is extremely non-trivial
[00:42:04] <aatch> graydon, well then maybe flatten it a little? on the basis that libraries should be written for users, I've got no idea whether a particular function is in c95 or posix98 or plan9_2015v6
[00:42:10] <cmr> as is creating a good Qt wrapper with C
[00:42:44] <MaikKlein> cmr, I writing my GUI in c++ and expose my rust app via c functions
[00:42:46] <bjz> Luqman MaikKlein: https://github.com/bjz/lmath-rs/tree/mat
[00:42:52] <cmr> MaikKlein: ah
[00:42:58] <graydon> aatch: that's the point of all the exports at the top. users shouldn't need to look at the insides.
[00:43:34] <graydon> aatch: you're welcome to try sketching a better organization. that was the one I did after a horrible mess the first time out of making some per-OS and some per-arch and some per-OS-and-arch files.
[00:47:56] <brson> graydon: I've got the new mac bot partially setup. everything here is done: https://github.com/graydon/rust-admin/blob/master/mac-machine-setup.txt
[00:48:08] <brson> graydon: but I don't know how to setup buildbot. do you have instrs for that?
[00:48:51] <MaikKlein> bjz, result: FAILED. 72 passed; 2 failed; 0 ignored
[00:49:30] <MaikKlein> bjz,  mat::mat3_tests::test_predicates and mat4 failed
[00:50:27] <bjz> yep
[00:50:43] <graydon> brson: as it says, the tail end of the linux host config should cover it. mostly just clone the buildbot repo then run ./setup-slave.sh and enter the slave name/pw
[00:54:23] *** Quits: marc (marc@E31B39DA.F9D61A8.416A0103.IP) (Ping timeout)
[00:55:49] *** Joins: maxli (maxli@B5559308.9C54E60.2FA4EA88.IP)
[00:56:06] *** Joins: mreedell (mreedell@moz-9950CA28.hsd1.pa.comcast.net)
[00:56:11] *** Quits: tjc (tjc@2557E599.66715431.D25A875A.IP) (Quit: Places to go, people to annoy)
[00:56:37] <MaikKlein> bjz, assert!(a.is_invertible()); failes
[00:57:07] <MaikKlein> bjz, mat3
[00:57:17] *** Parts: ecr (ereed@2557E599.66715431.D25A875A.IP) ()
[00:57:19] <bjz> MaikKlein: oh! athe assert!(...) ws meant to be assert!(!...)
[00:57:26] *** Quits: cscehr (Mibbit@moz-AD42E670.torservers.net) (Quit: http://www.mibbit.com ajax IRC Client)
[00:57:35] <MaikKlein> bjz, there you go :)
[00:58:04] <bjz> *facepalm*
[00:59:05] <bjz> maybe I should be doing assert_eq!(..., false)
[00:59:15] <strcat> I guess I should put 0.7 in the arch repos
[00:59:37] * strcat waits for two builds of rust to finish ;p
[01:00:01] <MaikKlein> is there a good alternative for Qt? (in any language)
[01:00:17] <cmr> MaikKlein: just for gui?
[01:00:21] <MaikKlein> cmr, yes
[01:00:35] <bjz> MaikKlein: ok, done
[01:00:35] <aatch> curses! :P
[01:00:42] <bjz> yay!
[01:01:04] <strcat> ncurses is really bad, you don't want to use it
[01:01:09] <MaikKlein> "Curses is designed to facilitate GUI-like functionality on a text-only device" haha
[01:01:13] <strcat> no unicode support, just ucs4, and only old ucs4 chars
[01:01:15] <strcat> ;[
[01:01:24] <roo> I hear IUP is good
[01:01:32] <strcat> it strips combining chars
[01:01:50] <klutzy> anyone cross-built rust for rpi?
[01:01:52] *** Quits: maxli (maxli@B5559308.9C54E60.2FA4EA88.IP) (Ping timeout)
[01:02:07] <cmr> klutzy: I recall someone talking about it
[01:02:07] <dbaupp> klutzy: someone was working on it... not sure if they got it to work yet
[01:02:12] <klutzy> I've tried to do some days ago but got llvm-mc error
[01:02:41] <brson> graydon: ok, rust-mac5 reporting for duty
[01:02:49] <brson> is there a way to force a specific slave to do some work
[01:02:57] <graydon> brson: nope
[01:03:02] <klutzy> src/rt/arch/arm/_context.S has ".align" line which llvm-mc doesn't understand
[01:03:04] <graydon> brson: the one feature buildbot doesn't have!
[01:03:17] <graydon> brson: I can turn the max builds numbers on the other slaves down to spread it out a bit..
[01:03:51] <klutzy> sanxiyn said android build does not use llvm-mc since it is incomplete for arm..
[01:03:54] <strcat> hm
[01:04:03] <klutzy> so I'm curious anyone ever succeeded to build
[01:04:24] *** Joins: jedestep (jedestep@moz-DA1D61AB.natpool.nyu.edu)
[01:04:29] * aatch finds it amusing that target "triples" have 4 parts.
[01:04:39] <dbaupp> klutzy: https://github.com/mozilla/rust/pull/6249
[01:04:54] <dbaupp> klutzy: and then https://github.com/mozilla/rust/issues/6231
[01:05:56] <klutzy> dbaupp: yep I've been following the issues but no gain so far :'(
[01:06:07] <dbaupp> klutzy: :(
[01:06:32] <aatch> klutzy, if it helps, I've been thinking about how to make it easier to target Rust at other platforms.
[01:07:35] *** Joins: wilsonk|2 (kvirc@moz-39EFBFC2.cg.shawcable.net)
[01:08:08] *** Quits: wilsonk-laptop (kvirc@moz-39EFBFC2.cg.shawcable.net) (Ping timeout)
[01:09:02] <aatch> basically making it easier to pick a platform and at least get code running on it, even if you lose out on stuff like the standard and extra libraries.
[01:10:17] <strcat> svn: E155036: The working copy at '/home/strcat/svn-packages'
[01:10:19] <strcat> is too old (format 29) to work with client version '1.8.0 (r1490375)' (expects format 31). You need to upgrade the working copy first.
[01:10:21] <strcat> is svn serious
[01:10:23] <strcat> ;\
[01:10:38] <strcat> thestinger/rust-git  release.0.6.2863.gab34864-1  0.7.31.g0c6fc46-1  0.17 MiB        25.23 MiB
[01:10:42] <strcat> graydon: I see you left off the prefix :)
[01:11:06] * strcat hated the release- thing
[01:12:41] <strcat> rusti: 2
[01:12:42] -rusti- <anon>:5:0: 5:42 warning: static constant should have an uppercase identifier [-W non-uppercase-statics (default)]
[01:12:42] -rusti- <anon>:5 static botsnack: &'static str = "nom nom";
[01:12:42] -rusti-          ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
[01:12:42] -rusti- 2
[01:12:47] <strcat> heh
[01:13:03] <graydon> heading out, ttyl!
[01:13:06] <graydon> thanks everyone :)
[01:13:08] <strcat> \o
[01:13:12] *** Quits: graydon (Adium@A5087023.2354C43D.D8E68FF6.IP) (Quit: Leaving.)
[01:13:18] *** Joins: jmgrosen (jmgrosen@moz-ED8F62BC.cs.ucsb.edu)
[01:13:41] *** Quits: parcha (quassel@moz-A9A9F340.hsd1.ma.comcast.net) (No route to host)
[01:13:51] *** Joins: parcha (quassel@moz-A9A9F340.hsd1.ma.comcast.net)
[01:14:24] <roo> MaikKlein: If you are still curious about once fns, I wrote thing that emulates them with a trait and a macro. Pretty much anywhere where you would capture something owned with a heap closure, you need something like a once fn. https://github.com/jessopher/rust-goodies/blob/master/once_closures.rs
[01:15:06] *** Quits: jclements (jclements@2557E599.66715431.D25A875A.IP) (Quit: jclements)
[01:16:25] *** Quits: jmgrosen (jmgrosen@moz-ED8F62BC.cs.ucsb.edu) (Ping timeout)
[01:16:44] *** Joins: sanxiyn (tinuviel@858F408C.B797260D.EF43EC08.IP)
[01:17:04] *** Joins: jmgrosen (jmgrosen@moz-ED8F62BC.cs.ucsb.edu)
[01:17:09] *** Quits: q66 (q66@6EE9DE40.46454B5D.33AABD5F.IP) (Quit: Leaving)
[01:17:23] <roo> not sure if that makes things more obvious or more confusing though.
[01:18:29] <engla> bye
[01:19:14] <sanxiyn> klutzy: hi
[01:19:16] *** Quits: parcha (quassel@moz-A9A9F340.hsd1.ma.comcast.net) (Client exited)
[01:19:22] <engla> roo: that's cool
[01:19:22] *** Joins: Sgeo (Sgeo@moz-D0F30617.dyn.optonline.net)
[01:19:45] *** Joins: jpochyla (jpochyla@moz-8D99AE5D.broadband18.iol.cz)
[01:19:50] <klutzy> sanxiyn: hoi
[01:20:06] *** Joins: reyre_ (reyre@moz-9002CDDA.cpe.net.cable.rogers.com)
[01:20:43] *** Joins: parcha (quassel@moz-A9A9F340.hsd1.ma.comcast.net)
[01:20:56] *** Quits: roo (jesse.rudo@moz-FB1A29EA.dynamic.ip.windstream.net) (Ping timeout)
[01:21:20] *** Joins: roo (jesse.rudo@moz-2748285.dynamic.ip.windstream.net)
[01:21:50] *** Joins: Ralith (ralith@moz-50F3C77.vc.shawcable.net)
[01:22:24] <MaikKlein> roo, thanks I have a look
[01:24:46] *** Joins: dwrensha (chatzilla@moz-DE44EA45.hsd1.pa.comcast.net)
[01:24:57] *** Quits: mark_edward (quassel@moz-4A9A2F15.dynamic.utc.edu) (Ping timeout)
[01:26:47] *** Quits: jmgrosen (jmgrosen@moz-ED8F62BC.cs.ucsb.edu) (Ping timeout)
[01:27:12] *** Joins: jmgrosen (jmgrosen@moz-ED8F62BC.cs.ucsb.edu)
[01:27:43] *** Quits: brson (brson@2557E599.66715431.D25A875A.IP) (Ping timeout)
[01:29:11] *** Joins: brson (brson@2557E599.66715431.D25A875A.IP)
[01:29:11] *** ChanServ sets mode: +o brson
[01:32:01] *** Joins: naq (naq@D5C2D2DF.E4265FCD.E481B5B.IP)
[01:32:28] <naq> is there any way to return multiple values without tuples? like in go?
[01:32:38] <naq> without using tuples*
[01:32:46] <aatch> naq, nope.
[01:32:57] *** Joins: brendan (brendaneic@EB618058.615B56E6.43362C16.IP)
[01:33:03] <tikue> naq: would that be functionally different from a tuple in any way? I don't know much about go, so excuse my ignorance
[01:33:07] <aatch> you can use pattern-matching in let to ignore them though.
[01:33:15] <strcat> tikue: no, it wouldn't
[01:34:04] <aatch> so fn `i_tuple() -> (int, int, int); let (_, a, _) = i_tuple();` would bind the middle element to 'a' and ignore the others.
[01:34:12] <MaikKlein> you could return a struct :p
[01:34:23] <tikue> aatch: you can also do let a = i_tuple().second() right?
[01:34:31] <aatch> tikue, yes.
[01:34:37] <naq> I see, thank you
[01:34:41] <engla> it's called .second() ?
[01:34:57] <tikue> engla: I don't know how many there are, but yes
[01:35:05] <engla> aha
[01:35:06] <aatch> it's just normally, multiple-return-values is asked in terms of being able to optionally ignore some values.
[01:35:10] *** Quits: seth (seth@moz-BE33DA21.fw1.sfo1.mozilla.net) (Input/output error)
[01:35:21] <engla> I knew there were ._1()  before
[01:35:30] <aatch> engla, I think there still is.
[01:35:51] *** Quits: jpochyla (jpochyla@moz-8D99AE5D.broadband18.iol.cz) (Ping timeout)
[01:36:06] <engla> hm it looks like there is .second/.first for the pair and .n0(), .n1(), etc for all other
[01:36:20] <engla> and n0_ref()  etc
[01:36:27] <engla> not sure what the `n` denotes
[01:36:35] <MaikKlein> rusti: let (a,b,c) = (1,2,3);
[01:36:37] -rusti- more than 5 lines of output, pastebinned: http://sprunge.us/CfVW
[01:36:50] <SiegeLord> rusti: let a = (1, 2, 3, 4, 5, 6, 7).n_6();
[01:36:51] -rusti- <anon>:7:17: 7:45 error: type `(<VI0>,<VI1>,<VI2>,<VI3>,<VI4>,<VI5>,<VI6>)` does not implement any method in scope named `n_6`
[01:36:51] -rusti- <anon>:7          let a = (1, 2, 3, 4, 5, 6, 7).n_6();
[01:36:51] -rusti-                           ^~~~~~~~~~~~~~~~~~~~~~~~~~~~
[01:36:51] -rusti- error: aborting due to previous error
[01:36:51] -rusti- application terminated with error code 101
[01:36:53] *** Quits: jmgrosen (jmgrosen@moz-ED8F62BC.cs.ucsb.edu) (Ping timeout)
[01:37:05] <SiegeLord> :?
[01:37:09] <MaikKlein> .n
[01:37:17] <engla> rusti: (1,2,3).n2()
[01:37:18] -rusti- 3
[01:37:19] <aatch> rusti: let a = (1, 2, 3, 4, 5, 6, 7).n6();
[01:37:21] -rusti- <anon>:7:13: 7:14 warning: unused variable: `a` [-W unused-variable (default)]
[01:37:21] -rusti- <anon>:7          let a = (1, 2, 3, 4, 5, 6, 7).n6();
[01:37:21] -rusti-                       ^
[01:37:21] -rusti- ()
[01:37:28] <aatch> rusti: (1, 2, 3, 4, 5, 6, 7).n6()
[01:37:28] <SiegeLord> Sweet
[01:37:29] -rusti- 7
[01:37:35] <dbaupp> Does n*() move out, or copy out?
[01:37:38] *** Joins: jmgrosen (jmgrosen@moz-ED8F62BC.cs.ucsb.edu)
[01:37:49] *** Quits: pnathan (Adium@moz-E3C3FAF2.hfc.comcastbusiness.net) (Quit: Leaving.)
[01:37:50] <MaikKlein> rusti: (1, 2, 3, 4, 5, 6, 7).n1()
[01:37:51] -rusti- 2
[01:37:52] <aatch> dbaupp, no idea, probably copy.
[01:37:55] *** Quits: brendan (brendaneic@EB618058.615B56E6.43362C16.IP) (Connection reset by peer)
[01:37:56] <MaikKlein> rusti: (1, 2, 3, 4, 5, 6, 7).n0()
[01:37:57] *** Joins: brendan (brendaneic@EB618058.615B56E6.43362C16.IP)
[01:37:57] -rusti- 1
[01:38:00] <MaikKlein> rusti: (1, 2, 3, 4, 5, 6, 7).n()
[01:38:00] -rusti- <anon>:7:9: 8:5 error: type `(<VI0>,<VI1>,<VI2>,<VI3>,<VI4>,<VI5>,<VI6>)` does not implement any method in scope named `n`
[01:38:00] -rusti- <anon>:7          (1, 2, 3, 4, 5, 6, 7).n()
[01:38:00] -rusti- <anon>:8     };
[01:38:00] -rusti- error: aborting due to previous error
[01:38:01] -rusti- application terminated with error code 101
[01:38:05] <engla> it clones
[01:38:17] <aatch> rusti: let a = (1, 2, 3, 4, 5, 6, 7); (a.n1(), a.n2())
[01:38:17] <tikue> rusti: (1, 2, 3, 4, 5, 6, 7).n7()
[01:38:18] -rusti- (2, 3)
[01:38:18] -rusti- <anon>:7:9: 8:5 error: type `(<VI0>,<VI1>,<VI2>,<VI3>,<VI4>,<VI5>,<VI6>)` does not implement any method in scope named `n7`
[01:38:19] -rusti- <anon>:7          (1, 2, 3, 4, 5, 6, 7).n7()
[01:38:19] -rusti- <anon>:8     };
[01:38:19] -rusti- error: aborting due to previous error
[01:38:19] -rusti- application terminated with error code 101
[01:38:30] <tikue> rusti: (1, 2, 3, 4, 5, 6, 7).n6()
[01:38:31] -rusti- 7
[01:39:30] <MaikKlein> rusti: let (a,b,c) = (1,~"1",~[1,2,3,4]);
[01:39:33] -rusti- more than 5 lines of output, pastebinned: http://sprunge.us/GFhg
[01:39:48] *** Quits: sanxiyn (tinuviel@858F408C.B797260D.EF43EC08.IP) (Quit: Leaving)
[01:40:18] <SiegeLord> rusti: trait A { fn n0()->int } impl A for (i32,) { fn n0()->int {2} } (1i32,).n0()
[01:40:19] -rusti- <anon>:7:32: 7:33 error: expected `;` or `}` but found `}`
[01:40:19] -rusti- <anon>:7          trait A { fn n0()->int } impl A for (i32,) { fn n0()->int {2} } (1i32,).n0()
[01:40:19] -rusti-                                          ^
[01:40:19] -rusti- application terminated with error code 101
[01:40:31] <SiegeLord> rusti: trait A { fn n0()->int; } impl A for (i32,) { fn n0()->int {2} } (1i32,).n0()
[01:40:32] -rusti- <anon>:7:74: 8:5 error: type `(i32)` does not implement any method in scope named `n0`
[01:40:32] -rusti- <anon>:7          trait A { fn n0()->int; } impl A for (i32,) { fn n0()->int {2} } (1i32,).n0()
[01:40:32] -rusti- <anon>:8     };
[01:40:32] -rusti- error: aborting due to previous error
[01:40:32] -rusti- application terminated with error code 101
[01:41:04] <MaikKlein> (i32,)
[01:41:04] *** Quits: jmgrosen (jmgrosen@moz-ED8F62BC.cs.ucsb.edu) (Ping timeout)
[01:41:04] <SiegeLord> rusti: (1i32,).n0()
[01:41:05] -rusti- <anon>:7:9: 8:5 error: type `(i32)` does not implement any method in scope named `n0`
[01:41:05] -rusti- <anon>:7          (1i32,).n0()
[01:41:05] -rusti- <anon>:8     };
[01:41:05] -rusti- error: aborting due to previous error
[01:41:05] -rusti- application terminated with error code 101
[01:41:38] <SiegeLord> rusti: (1i32,2i32).n0()
[01:41:40] -rusti- 1
[01:41:45] <SiegeLord> That's odd
[01:42:07] *** Joins: jmgrosen (jmgrosen@moz-ED8F62BC.cs.ucsb.edu)
[01:42:13] * roo never really understood 1tuples anyhow
[01:42:36] <strcat> rusti: let xs: [int, ..0] = []; xs
[01:42:38] -rusti- []
[01:43:30] *** Joins: mark_edward (quassel@moz-4A9A2F15.dynamic.utc.edu)
[01:43:44] <bjz> engla: perhaps .n1() should be ._1()
[01:43:51] <engla> I think it was, before
[01:43:52] <SiegeLord> rusti: trait A { fn n0()->int; } impl A for (i32,i32) { fn n0()->int {2} } (1i32,2i32).n0()
[01:43:54] -rusti- 1
[01:44:18] <SiegeLord> rusti: trait A { fn n0()->int; } impl A for (i32,i32) { fn n2()->int {2} } (1i32,2i32).n2()
[01:44:19] -rusti- <anon>:7:58: 7:74 error: method `n2` is not a member of trait `A`
[01:44:19] -rusti- <anon>:7          trait A { fn n0()->int; } impl A for (i32,i32) { fn n2()->int {2} } (1i32,2i32).n2()
[01:44:19] -rusti-                                                                    ^~~~~~~~~~~~~~~~
[01:44:19] -rusti- error: aborting due to previous error
[01:44:20] <bjz> engla: it wasn't there when I added the n1... methods
[01:44:20] -rusti- application terminated with error code 101
[01:44:39] <SiegeLord> rusti: trait A { fn n2()->int; } impl A for (i32,i32) { fn n2()->int {2} } (1i32,2i32).n2()
[01:44:41] -rusti- <anon>:7:77: 8:5 error: type `(i32,i32)` does not implement any method in scope named `n2`
[01:44:41] -rusti- <anon>:7          trait A { fn n2()->int; } impl A for (i32,i32) { fn n2()->int {2} } (1i32,2i32).n2()
[01:44:41] -rusti- <anon>:8     };
[01:44:41] -rusti- error: aborting due to previous error
[01:44:41] -rusti- application terminated with error code 101
[01:44:48] <SiegeLord> Huh
[01:45:13] <bjz> engla: also, perhaps it should return a reference, and the _ref methods should be removed
[01:45:39] <tikue> rusti: (0, ~[]).second_ref().push(1)
[01:45:41] -rusti- more than 5 lines of output, pastebinned: http://sprunge.us/fDfg
[01:45:45] *** Quits: jmgrosen (jmgrosen@moz-ED8F62BC.cs.ucsb.edu) (Ping timeout)
[01:46:11] <engla> yeah bjz
[01:46:18] *** Quits: MaikKlein (maik@moz-7F4AE15A.dip0.t-ipconnect.de) (Ping timeout)
[01:46:23] <engla> the trend is to have copies explicit
[01:46:29] <bjz> yep
[01:46:44] <tikue> can we get mutable references
[01:46:47] <engla> someone mentioned _1 but maybe it never existed
[01:46:57] <aatch> engla, I think it used to exist
[01:46:57] <engla> with pattern matching
[01:46:59] <dbaupp> maybe we need ._1[_mut]() for references and ._1_move() to move out of the tuple
[01:47:06] <dbaupp> s/need/could have/
[01:47:13] *** Joins: jmgrosen (jmgrosen@moz-ED8F62BC.cs.ucsb.edu)
[01:47:46] *** Quits: echristo (echristo@D423593A.D6CCE4AE.77834EAA.IP) (Quit: echristo)
[01:47:50] *** Quits: etw (john@moz-B2936CAB.nyc.res.rr.com) (Quit: etw)
[01:50:23] *** Quits: jmgrosen (jmgrosen@moz-ED8F62BC.cs.ucsb.edu) (Ping timeout)
[01:51:12] *** Joins: jmgrosen (jmgrosen@moz-ED8F62BC.cs.ucsb.edu)
[01:51:31] *** Joins: xLII (xLII@4BED3CB3.F5F53E8A.2D6DB75E.IP)
[01:53:39] <roo> is there some way to get type information about an expression in a macro? like macro_rules! x(($e:expr) => ($e.ty))
[01:53:52] <strcat> no
[01:54:11] <roo> ok
[01:54:12] <strcat> macros just operate on tokens
[01:54:23] *** Quits: Kruppe (user@moz-E150F49F.cpe.net.cable.rogers.com) (Client exited)
[01:56:06] *** Quits: pcwalton (pcwalton@43CB6079.66715431.D25A875A.IP) (Quit: pcwalton)
[01:56:38] <tikue> rusti: let (a, mut b) = 0, ~[];
[01:56:40] -rusti- more than 5 lines of output, pastebinned: http://sprunge.us/EbBB
[01:56:51] <tikue> rusti: let (a, mut b) = (0, ~[]);
[01:56:52] -rusti- more than 5 lines of output, pastebinned: http://sprunge.us/MXUK
[01:57:17] <tikue> I could've sworn that was legal syntax
[01:57:34] <aatch> tikue, it should be.
[01:58:09] <tikue> aatch: any idea if it's planned for <= 1.0?
[01:58:17] <aatch> tikue, likely
[01:58:19] <tikue> cool :)
[02:01:31] *** Quits: bjz (brendanzab@B398BE78.F804C29E.D35A31DF.IP) (Quit: Leaving...)
[02:03:12] *** Quits: SiegeLord (sl@moz-CAF07B4C.hsd1.ma.comcast.net) (Quit: It's a joke, it's all a joke.)
[02:04:06] <tikue> rusti: let t = (0, ~[]); let (a, b) = match t { (a, ref mut b) => (a, b), }; b.push(1); b
[02:04:08] -rusti- more than 5 lines of output, pastebinned: http://sprunge.us/QIEJ
[02:04:53] <tikue> rusti: let t = (0, ~[]); let (a, b) = match t { (a, ref mut b) => (a, b), }; b.push(1);
[02:04:54] -rusti- <anon>:7:54: 7:63 error: cannot borrow immutable anonymous field as mutable
[02:04:54] -rusti- <anon>:7          let t = (0, ~[]); let (a, b) = match t { (a, ref mut b) => (a, b), }; b.push(1);
[02:04:54] -rusti-                                                                ^~~~~~~~~
[02:04:54] -rusti- error: aborting due to previous error
[02:04:54] -rusti- application terminated with error code 101
[02:05:50] <tikue> rusti: let mut t = (0, ~[]); let (a, b) = match t { (a, ref mut b) => (a, b), }; b.push(1);
[02:05:51] *** Joins: SiegeLord (sl@moz-CAF07B4C.hsd1.ma.comcast.net)
[02:05:52] -rusti- <anon>:7:36: 7:37 warning: unused variable: `a` [-W unused-variable (default)]
[02:05:52] -rusti- <anon>:7          let mut t = (0, ~[]); let (a, b) = match t { (a, ref mut b) => (a, b), }; b.push(1);
[02:05:52] -rusti-                                              ^
[02:05:52] -rusti- ()
[02:06:05] <tikue> rusti: let mut t = (0, ~[]); let (a, b) = match t { (a, ref mut b) => (a, b), }; b.push(1); (a, b[0])
[02:06:06] -rusti- (0, 1)
[02:06:12] *** Quits: jmgrosen (jmgrosen@moz-ED8F62BC.cs.ucsb.edu) (Ping timeout)
[02:06:37] *** Joins: jmgrosen (jmgrosen@moz-ED8F62BC.cs.ucsb.edu)
[02:08:00] <brson> .n1_ref()
[02:08:04] <brson> etc
[02:08:31] *** Quits: lmandel (lmandel@moz-BBE1EA67.dsl.bell.ca) (Quit: lmandel)
[02:08:56] <tikue> rusti: let mut t = (0, ~[]); let mut v = t.n1_ref(); v.push(1); v[0]
[02:08:57] -rusti- <anon>:7:55: 7:56 error: cannot borrow immutable dereference of & pointer as mutable
[02:08:57] -rusti- <anon>:7          let mut t = (0, ~[]); let mut v = t.n1_ref(); v.push(1); v[0]
[02:08:57] -rusti-                                                                 ^
[02:08:57] -rusti- error: aborting due to previous error
[02:08:57] -rusti- application terminated with error code 101
[02:09:08] <tikue> n1_ref() isn't mutable
[02:09:16] <strcat> it's &
[02:09:23] <tikue> ya
[02:09:47] *** Quits: azakai (alon@2557E599.66715431.D25A875A.IP) (Quit: Ex-Chat)
[02:10:26] <engla> for containers it would make sense to have mutability in the lifetime parameter..    fn get_1<'a>(&'a self) -> &'a A;    'a  transfers both lifetime and mutability
[02:10:54] <strcat> it wouldn't really
[02:10:58] *** Quits: BitPuffin (quassel@moz-49828767.cust.tele2.se) (Ping timeout)
[02:11:04] <steven_is_false> rusti: use std::libc; "test"
[02:11:05] <strcat> &mut acts a lot differently from &
[02:11:05] -rusti- <anon>:7:13: 7:22 warning: unused import [-W unused-imports (default)]
[02:11:05] -rusti- <anon>:7          use std::libc; "test"
[02:11:05] -rusti-                       ^~~~~~~~~
[02:11:05] -rusti- "test"
[02:11:09] <strcat> &mut isn't copyable
[02:11:10] <strcat> & is copyable
[02:11:18] <strcat> a map can return &mut refs to the values, not to the keys
[02:11:31] <engla> sure, but it would be useful in a lot of places
[02:11:52] <engla> the main benefit is not that you don't have to implement both ref() and ref_mut(), but that you only have to use one function
[02:11:53] *** Quits: jmgrosen (jmgrosen@moz-ED8F62BC.cs.ucsb.edu) (Ping timeout)
[02:11:54] <engla> use and know
[02:11:55] <strcat> but then you'd have no way to prevvent mutability
[02:11:59] <strcat> prevent*
[02:12:08] <engla> well, there could be some way
[02:12:30] <strcat> we have enough brittle magic imo, need less not more
[02:12:33] *** Joins: jmgrosen (jmgrosen@moz-ED8F62BC.cs.ucsb.edu)
[02:12:54] <strcat> if we didn't have auto-deref, deriving(Clone) would work on borrowed pointers
[02:12:58] <engla> true, it is magic
[02:13:03] <strcat> but as it is, it's really hard to call certain methods
[02:13:13] <strcat> impossible in deriving
[02:13:20] <engla> interesting
[02:13:29] <strcat> can be hacked around by using functions instead, but that's silly
[02:13:34] *** Joins: etw (john@moz-B2936CAB.nyc.res.rr.com)
[02:13:37] *** Quits: hjr3 (hradtke@374E545A.3A8E9B0C.F9D9C60E.IP) (Quit: My MacBook has gone to sleep. ZZZzzzâ€¦)
[02:13:40] *** Quits: xLII (xLII@4BED3CB3.F5F53E8A.2D6DB75E.IP) (Ping timeout)
[02:16:23] <huhlig-home> is there any intention of including something similar to rust zero into the mainline rust for bare metal programming?
[02:16:56] <strcat> huhlig-home: yes
[02:17:07] <strcat> it's a lot of work though and there are many more important things with priority
[02:17:10] <huhlig-home> ok
[02:17:48] <huhlig-home> second question, is there a good ide that is reasonably up to date? Oxide seems defunct. Rusty Cage hasnt had commits recently...
[02:18:50] <tikue> : rusti: let mut t = (0, ~[]); let (a, b) = match t { (a, ref mut b) => (a, b), }; b.push(1); (a, t[0])
[02:18:58] <tikue> rusti: let mut t = (0, ~[]); let (a, b) = match t { (a, ref mut b) => (a, b), }; b.push(1); (a, t[0])
[02:18:59] -rusti- <anon>:7:98: 7:101 error: cannot index a value of type `(<VI0>,~[<VI1>])`
[02:18:59] -rusti- <anon>:7          let mut t = (0, ~[]); let (a, b) = match t { (a, ref mut b) => (a, b), }; b.push(1); (a, t[0])
[02:18:59] -rusti-                                                                                                            ^~~
[02:18:59] -rusti- error: aborting due to previous error
[02:19:00] -rusti- application terminated with error code 101
[02:19:05] <strcat> huhlig-home: there is support for a few editors included in rust's source tree
[02:19:09] *** Joins: Nisstyre (wes@moz-FD86289.netflash.net)
[02:19:32] *** Quits: azita (Azita@2557E599.66715431.D25A875A.IP) (Quit: azita)
[02:19:46] <strcat> there's no semantic code completion (in any editor) yet
[02:20:33] <tikue> rusti: let mut t = (0, ~[]); let (a, b) = match t { (a, ref mut b) => (a, b), }; b.push(1); t
[02:20:35] -rusti- more than 5 lines of output, pastebinned: http://sprunge.us/ZDMW
[02:20:53] <tikue> rusti: let mut t = (0, ~[]); { let (a, b) = match t { (a, ref mut b) => (a, b), }; b.push(1); } t
[02:20:54] -rusti- <anon>:7:38: 7:39 warning: unused variable: `a` [-W unused-variable (default)]
[02:20:55] -rusti- <anon>:7          let mut t = (0, ~[]); { let (a, b) = match t { (a, ref mut b) => (a, b), }; b.push(1); } t
[02:20:55] -rusti-                                                ^
[02:20:55] -rusti- (0, ~[1])
[02:22:10] *** Quits: cdidd (cdidd@moz-225FA258.broadband.corbina.ru) (Ping timeout)
[02:23:18] <tikue> rusti: let mut t = (0, ~[]); { let (a, b) = match t.second() { ref mut b => (a, b), }; b.push(1); } t
[02:23:19] -rusti- <anon>:7:79: 7:80 error: unresolved name `a`. Did you mean `t`?
[02:23:19] -rusti- <anon>:7          let mut t = (0, ~[]); { let (a, b) = match t.second() { ref mut b => (a, b), }; b.push(1); } t
[02:23:19] -rusti-                                                                                         ^
[02:23:19] -rusti- error: aborting due to previous error
[02:23:20] -rusti- application terminated with error code 101
[02:23:21] *** Quits: jmgrosen (jmgrosen@moz-ED8F62BC.cs.ucsb.edu) (Ping timeout)
[02:23:34] <tikue> rusti: let mut t = (0, ~[]); { let b = match t.second() { ref mut b => (a, b), }; b.push(1); } t
[02:23:34] -rusti- <anon>:7:74: 7:75 error: unresolved name `a`. Did you mean `t`?
[02:23:35] -rusti- <anon>:7          let mut t = (0, ~[]); { let b = match t.second() { ref mut b => (a, b), }; b.push(1); } t
[02:23:35] -rusti-                                                                                    ^
[02:23:35] -rusti- error: aborting due to previous error
[02:23:35] -rusti- application terminated with error code 101
[02:23:45] <tikue> rusti: let mut t = (0, ~[]); { let b = match t.second() { ref mut b => b, }; b.push(1); } t
[02:23:47] -rusti- more than 5 lines of output, pastebinned: http://sprunge.us/QUBY
[02:23:49] *** Joins: jmgrosen (jmgrosen@moz-ED8F62BC.cs.ucsb.edu)
[02:24:48] *** Quits: kini (kini@moz-92AA953A.members.linode.com) (Ping timeout)
[02:24:59] <tikue> rusti: let mut t = (0, ~[]); t.second().push(1); } t
[02:24:59] -rusti- <anon>:10:0: 10:1 error: incorrect close delimiter: `}`
[02:25:00] -rusti- <anon>:10 }
[02:25:00] -rusti-           ^
[02:25:00] -rusti- application terminated with error code 101
[02:25:04] <tikue> rusti: let mut t = (0, ~[]); t.second().push(1); t
[02:25:09] -rusti- <anon>:7:17: 7:18 warning: variable does not need to be mutable [-W unused-mut (default)]
[02:25:10] -rusti- <anon>:7          let mut t = (0, ~[]); t.second().push(1); t
[02:25:10] -rusti-                           ^
[02:25:10] -rusti- timeout triggered!
[02:25:47] <tikue> rusti: let mut t = (0, ~[]); t.second().push(1); t[1]
[02:25:49] -rusti- <anon>:7:51: 7:54 error: cannot index a value of type `(<VI0>,~[<VI1>])`
[02:25:49] -rusti- <anon>:7          let mut t = (0, ~[]); t.second().push(1); t[1]
[02:25:49] -rusti-                                                             ^~~
[02:25:49] -rusti- error: aborting due to previous error
[02:25:49] -rusti- application terminated with error code 101
[02:27:19] *** Joins: kini (kini@moz-92AA953A.members.linode.com)
[02:28:32] *** Quits: brendan (brendaneic@EB618058.615B56E6.43362C16.IP) (Quit: brendan)
[02:28:42] *** Joins: int3_ (int3_@moz-ABE52D50.hsd1.ca.comcast.net)
[02:28:50] *** Quits: ldlework (ldlework@6AEB83D1.B92A0FC.176AC772.IP) (Ping timeout)
[02:30:57] *** Joins: Kruppe (user@moz-E150F49F.cpe.net.cable.rogers.com)
[02:31:56] *** Joins: ghrust (ghrust@CFE85B59.6A2AE50.F3114085.IP)
[02:31:56] <ghrust> 01[13rust01] 15bors merged 06auto into 06master: 02http://git.io/HNqxYg
[02:31:56] *** Parts: ghrust (ghrust@CFE85B59.6A2AE50.F3114085.IP) ()
[02:33:10] *** Joins: ldlework (ldlework@6AEB83D1.B92A0FC.176AC772.IP)
[02:34:21] *** Quits: roo (jesse.rudo@moz-2748285.dynamic.ip.windstream.net) (Ping timeout)
[02:34:28] *** Quits: brson (brson@2557E599.66715431.D25A875A.IP) (Quit: leaving)
[02:34:55] <strcat> https://www.archlinux.org/packages/community/x86_64/rust/ :)
[02:34:57] *** Joins: ghrust (ghrust@E7A4CCE2.6A2AE50.F3114085.IP)
[02:34:57] <ghrust> 01[13rust01] 15bors pushed 0 new commits to 06auto: 02http://git.io/Ok-iKQ
[02:34:57] *** Parts: ghrust (ghrust@E7A4CCE2.6A2AE50.F3114085.IP) ()
[02:34:58] *** Joins: ghrust (ghrust@24260B07.6A2AE50.F3114085.IP)
[02:34:58] <ghrust> 01[13rust01] 15bors pushed 3 new commits to 06auto: 02http://git.io/1oestg
[02:34:58] <ghrust> 13rust/06auto 14fd19289 15Seo Sanghyeon: Classify newtype structs S(T) as immediates if T is an immediate
[02:34:58] <ghrust> 13rust/06auto 148aa26ad 15Seo Sanghyeon: Fix dereference of temporary immediate newtype structs
[02:34:58] <ghrust> 13rust/06auto 1403bceae 15bors: auto merge of #7543 : sanxiyn/rust/newtype-immediates, r=catamorphism...
[02:35:00] *** Parts: ghrust (ghrust@24260B07.6A2AE50.F3114085.IP) ()
[02:35:07] <strcat> the daily build in my nightly repo is newer anyway
[02:35:37] *** Quits: mreedell (mreedell@moz-9950CA28.hsd1.pa.comcast.net) (Quit: Computer has gone to sleep.)
[02:38:02] *** Joins: pnathan (Adium@B9840254.2CD8A5F8.477B877D.IP)
[02:38:27] <tikue> let t = [1, 2, 3]; let min = t.iter().min().unwrap(); println(fmt!("%d", min));
[02:38:32] <tikue> rusti: let t = [1, 2, 3]; let min = t.iter().min().unwrap(); println(fmt!("%d", min));
[02:38:33] -rusti- more than 5 lines of output, pastebinned: http://sprunge.us/CiSa
[02:38:55] *** Joins: xLII (xLII@4BED3CB3.F5F53E8A.2D6DB75E.IP)
[02:39:09] <tikue> can someone help me out here?  I thought unwrap would return an int, but it's returning &int?
[02:39:34] <dbaupp> tikue: vec.iter() is an iterator over references to each element, i.e. &int
[02:40:02] <dbaupp> rusti: let t = [1, 2, 3]; let min = t.iter().transform(|&x| x).min().unwrap(); println(fmt!("%d", min));
[02:40:04] -rusti- 1
[02:40:04] -rusti- ()
[02:40:18] <strcat> we should fix the tuple getters to not do clones as the "default"
[02:40:18] <dbaupp> rusti: let t = [1, 2, 3]; let min = *t.iter().min().unwrap(); println(fmt!("%d", min));
[02:40:19] -rusti- 1
[02:40:19] -rusti- ()
[02:40:23] *** Quits: dherman (dherman@moz-6CA476B1.hsd1.ca.comcast.net) (Quit: dherman)
[02:40:25] <dbaupp> strcat: right
[02:40:49] <strcat> n0 -> &, n0_mut -> &mut, n0_clone
[02:40:52] <tikue> dbaupp: oh I see. what would you say is the most idiomatic way to do this, then? let &min = â€¦, or one of the methods you just did?
[02:40:56] *** Joins: ghrust (ghrust@2EE61FCC.6A2AE50.F3114085.IP)
[02:40:56] <ghrust> 01[13rust01] 15bors 04force-pushed 06auto from 1403bceae to 143c0a162: 02http://git.io/N3iJvQ
[02:40:56] *** Parts: ghrust (ghrust@2EE61FCC.6A2AE50.F3114085.IP) ()
[02:40:57] *** Joins: ghrust (ghrust@DE823A67.6A2AE50.F3114085.IP)
[02:40:57] <ghrust> 01[13rust01] 15bors pushed 2 new commits to 06auto: 02http://git.io/i51jKA
[02:40:57] <ghrust> 13rust/06auto 1459d3b2d 15Luqman Aden: Add x64 windows to platform.mk and mingw64 header fixes.
[02:40:57] <ghrust> 13rust/06auto 1473c8981 15bors: auto merge of #7547 : luqmana/rust/mingw64, r=yichoi...
[02:40:57] *** Parts: ghrust (ghrust@DE823A67.6A2AE50.F3114085.IP) ()
[02:41:10] <dbaupp> strcat: and n0_move
[02:41:30] <strcat> well actually we don't need a clone one
[02:41:33] <strcat> .n0().clone()
[02:42:07] <dbaupp> right
[02:42:11] <strcat> just like pattern matching does
[02:42:16] <strcat> by-ref and clone
[02:42:18] *** Quits: jmgrosen (jmgrosen@moz-ED8F62BC.cs.ucsb.edu) (Ping timeout)
[02:42:40] *** Joins: jmgrosen (jmgrosen@moz-ED8F62BC.cs.ucsb.edu)
[02:43:17] <tikue> strcat: why do you need n0 and n0_mut, as compared to just having n0 and doing &tuple.n0() or &mut tuple.n0()
[02:43:22] <dbaupp> cmr: http://huonw.github.io/isrustfastyet/mem/ (it's pretty basic atm)
[02:43:28] *** Quits: pnathan (Adium@B9840254.2CD8A5F8.477B877D.IP) (Ping timeout)
[02:43:35] <strcat> tikue: you can't take an & ref to an rvalue like that
[02:43:50] <strcat> that only works on vector indexing because it's a language feature, not a library feature
[02:44:08] <strcat> the fn needs to go
[02:44:16] <strcat> (&'a self) -> &'a T
[02:44:19] <strcat> if it does
[02:44:38] <strcat> (self) -> T, it moved from it and T is a temporary
[02:44:44] <strcat> or it could clone, and it's still an unrelated temporary
[02:44:59] *** Joins: jpochyla (jpochyla@moz-8D99AE5D.broadband18.iol.cz)
[02:46:35] <dbaupp> http://buildbot.rust-lang.org/builders/auto-linux-32-opt/builds/254/steps/compile/logs/stdio :/
[02:46:37] *** Quits: zz_kimundi (kimundi@moz-C54951C.dip0.t-ipconnect.de) (Ping timeout)
[02:46:40] <tikue> strcat: could it be extended to work more generally than just vectors, or is that just a really hard thing?
[02:46:53] <strcat> tikue: it's a really hard thing and it's probably bad that vectors use magic
[02:46:55] *** Quits: jpochyla (jpochyla@moz-8D99AE5D.broadband18.iol.cz) (Ping timeout)
[02:46:56] *** Joins: ghrust (ghrust@614D05BD.6A2AE50.F3114085.IP)
[02:46:56] <ghrust> 01[13rust01] 15bors 04force-pushed 06auto from 1473c8981 to 143c0a162: 02http://git.io/N3iJvQ
[02:46:56] *** Parts: ghrust (ghrust@614D05BD.6A2AE50.F3114085.IP) ()
[02:46:59] *** Joins: ghrust (ghrust@9C8B94D4.6A2AE50.F3114085.IP)
[02:47:00] <ghrust> 01[13rust01] 15bors pushed 4 new commits to 06auto: 02http://git.io/nzKY8g
[02:47:00] <ghrust> 13rust/06auto 143e265e7 15Steven Fackler: Small documentation changes...
[02:47:00] <ghrust> 13rust/06auto 14863e75f 15Steven Fackler: Fixed documentation for finalize->drop change
[02:47:00] <ghrust> 13rust/06auto 14c63b3f8 15Steven Fackler: Removing the rename warning...
[02:47:02] <strcat> weird magic like that is bad
[02:47:02] *** Parts: ghrust (ghrust@9C8B94D4.6A2AE50.F3114085.IP) ()
[02:47:08] <strcat> people don't know why it works, it just does
[02:47:14] <strcat> and the rest of the language doesn't work that way
[02:47:26] <tikue> strcat: it'd be nice if the rest of the language did work that way :D
[02:47:30] <engla> right
[02:47:33] <strcat> tikue: it can't though
[02:47:37] <tikue> :(
[02:47:41] <engla> enable the magic for everyone
[02:47:46] <strcat> you can't return by-value and somehow have a reference to where you copied/moved the value from
[02:47:56] <strcat> vector indexing doesn't use functions with actual signatures
[02:48:02] <strcat> it *can't* use functions with actual signatures.
[02:48:10] <engla> strcat: obviously with compiler changes it could be implemented
[02:48:15] <strcat> engla: no, it couldn't
[02:48:19] <strcat> it's something that doesn't make sense
[02:48:31] <Luqman> /bin/sh: /Users/rustbuild/src/rust-buildbot/slave/auto-mac-64-nopt/build/obj/llvm/x86_64-apple-darwin/Release+Asserts/bin/llvm-mc: No such file or directory
[02:48:36] <Luqman> o.o what?
[02:48:37] <engla> I think you are looking at this too narrowly
[02:49:03] <strcat> how can you return by-value (as in you moved or cloned) and the compiler magically has a & or &mut reference with a known lifetime?
[02:49:13] <Luqman> do i need to trigger an llvm clean for changing the platform.mk or something?
[02:49:13] <strcat> to the original location you moved or cloned from
[02:49:15] <tikue> engla: but how would it work? where would the original reference be stored? i'm with strcat on this oneâ€¦I don't think it's possible. just nice to imagine in a magical world
[02:49:26] *** Joins: hjr3 (hradtke@moz-E87BDF1F.socal.res.rr.com)
[02:49:42] <engla> I don't suggest it should be return by value
[02:49:53] *** Joins: alisdair (textual@moz-EBE9F394.bchsia.telus.net)
[02:49:55] <strcat> so how do we return by value then
[02:49:59] *** Joins: zz_kimundi (kimundi@moz-7A7B928D.dip0.t-ipconnect.de)
[02:50:01] <strcat> &, &mut and by-move have different semantics
[02:50:02] <engla> I think types should have the  &v[0], &mut v[0] magic available
[02:50:11] <strcat> engla: for indexing, sure
[02:50:15] <strcat> as a special case
[02:50:22] *** zz_kimundi is now known as kimundi
[02:50:23] <strcat> but it's not going to work anywhere else
[02:50:28] <tikue> strcat: I do think the magic could be extended to tuples. why not support indexing on tuples?
[02:50:37] <strcat> tikue: tuples need a constant index
[02:50:57] <tikue> strcat: I don't follow
[02:51:04] <Eridius> tuple[n] wouldn't work
[02:51:05] <strcat> tuples don't use runtime indexing
[02:51:27] <Eridius> clearly we need to add parameterization by values instead of just types, so you can say tuple.get::<1>()
[02:51:37] <huhlig-home> strcat, can you put it in the debian/ubuntu repos too :)
[02:51:42] <aatch> Luqman, brson just set up a new mac bot, maybe it's set up wrong?
[02:51:55] <Luqman> aatch: one of the linux bots too
[02:52:03] * huhlig-home notices how far back in the conversation he is
[02:52:03] <strcat> huhlig-home: nope ;p
[02:52:08] <strcat> and anyway the ubuntu repos are frozen
[02:52:14] <strcat> so it would take 6+ months to get to users
[02:52:20] <huhlig-home> ppa?
[02:52:27] <aatch> by which time, it's horribly out-of-date...
[02:52:27] <tikue> strcat: so you're saying there's a different type for each sized tuple?
[02:52:32] <strcat> tikue: yes
[02:52:33] <aatch> tikue, correct
[02:52:34] <Luqman> aatch: looking it seems like the last three pulls all failed like that
[02:52:40] <strcat> tikue: and tuples don't store the same type in each "field"
[02:52:43] <aatch> Luqman, hmm, no idea then.
[02:52:44] <strcat> (0, "foo", 5.5)
[02:52:52] <strcat> the index needs to know the type of the "field"
[02:52:53] *** Joins: ghrust (ghrust@79968228.6A2AE50.F3114085.IP)
[02:52:53] <ghrust> 01[13rust01] 15bors 04force-pushed 06auto from 14566c394 to 143c0a162: 02http://git.io/N3iJvQ
[02:52:53] *** Parts: ghrust (ghrust@79968228.6A2AE50.F3114085.IP) ()
[02:52:54] <strcat> fundamentally
[02:52:54] *** Joins: ghrust (ghrust@E7A4CCE2.6A2AE50.F3114085.IP)
[02:52:54] <ghrust> 01[13rust01] 15bors pushed 2 new commits to 06auto: 02http://git.io/1PJ-jg
[02:52:54] <ghrust> 13rust/06auto 142f27d43 15Jed Davis: GC static_size_of_enum, which was unused
[02:52:54] <ghrust> 13rust/06auto 14fb9c46c 15bors: auto merge of #7554 : jld/rust/rm-ssoe, r=catamorphism
[02:52:55] *** Parts: ghrust (ghrust@E7A4CCE2.6A2AE50.F3114085.IP) ()
[02:52:56] <strcat> to work
[02:53:10] <strcat> (int, &'static str, f64)
[02:53:14] <strcat> is an example tuple type
[02:53:20] <strcat> it has an arity of 3 and specific field types
[02:53:27] <Luqman> how does one trigger the clean-llvm on the buildbots?
[02:53:35] <strcat> you could add [] indexing as sugar to tuples
[02:53:40] <strcat> but the integer would need to be a constant expression
[02:53:44] <aatch> Tuples are why I could write a test that looped over an array of cases with the type [(&str, (Arch, Vendor, OS, Env))]
[02:53:53] <strcat> and it would take a lot of compiler effort, not possible in a library
[02:54:18] <tikue> strcat: gotcha. yeah it wouldn't be worth it, imo, if it only used constant expressions, and since it will never be able to work without constant expressions, no point
[02:54:39] <Eridius> you could do a syntax extension tuple_get!(tuple, 3)
[02:55:03] <strcat> Eridius: with [] it could work with actual constants though
[02:55:06] <Eridius> but that won't help if you want a ref or ar ef mut
[02:55:19] <Eridius> strcat: what do you mean, work with actual constants?
[02:55:31] <strcat> static a: uint = 0; (5.5, "foo")[a + 1]
[02:55:34] <Eridius> overloading [] on tuples that only works with constants seems nasty, since all current uses of [] allow for variables
[02:55:35] * aatch thinks that Python ruined tuples
[02:55:54] <strcat> python doesn't have tuples, just an immutable list called a tuple
[02:56:07] <engla>  why not call it tuple
[02:56:12] <strcat> because it's not one
[02:56:18] <strcat> tuple has a definition
[02:56:20] <strcat> and that's not it
[02:56:33] <tikue> strcat: with a lot of syntax support that make them really nice to work with :) 
[02:56:51] <strcat> tikue: same syntax support exists for lists in python
[02:56:58] <strcat> [a, b, c] = [1, 2, 3]
[02:57:05] <strcat> [head, **tail] = [1, 2, 3]
[02:57:09] <tikue> strcat: a, b, c = 1, 2, 3
[02:57:10] <strcat> [head, *tail] = [1, 2, 3]
[02:57:19] <tikue> strcat: * and ** unpacking always gives a list i believe
[02:57:22] <strcat> tikue: yeah, python has list unpacking too
[02:57:22] <Eridius> syntax support for tuples is really easy when you're working in a dynamically-typed language
[02:58:12] <strcat> tikue: it lets you arbitrarily put [] around them
[02:58:14] <tikue> yeah, i mean that's the benefit of dynamically-typed languages in general, right? good syntax support
[02:58:43] *** Quits: RMF (RMF@moz-2CA5F393.dsl.telepac.pt) (Quit: Textual IRC Client: www.textualapp.com)
[02:58:46] <tikue> strcat: I'm not sure what you're referring to
[02:58:55] *** Joins: ghrust (ghrust@E7A4CCE2.6A2AE50.F3114085.IP)
[02:58:55] <ghrust> 01[13rust01] 15bors 04force-pushed 06auto from 14fb9c46c to 143c0a162: 02http://git.io/N3iJvQ
[02:58:55] *** Parts: ghrust (ghrust@E7A4CCE2.6A2AE50.F3114085.IP) ()
[02:58:58] *** Joins: ghrust (ghrust@C621748.6A2AE50.F3114085.IP)
[02:58:58] <strcat> tikue: valid python: [a, b] = [1, 2]
[02:58:58] <ghrust> 01[13rust01] 15bors pushed 2 new commits to 06auto: 02http://git.io/rtYMYA
[02:58:58] <ghrust> 13rust/06auto 14866a5b1 15Michael Woerister: Added support for struct-like enum variants in middle::ty::enum_variants().
[02:58:58] <ghrust> 13rust/06auto 14880986a 15bors: auto merge of #7557 : michaelwoerister/rust/enum_structs, r=pcwalton...
[02:58:58] *** Parts: ghrust (ghrust@C621748.6A2AE50.F3114085.IP) ()
[02:59:09] <strcat> tikue: it's not a special case for just python's tuple
[02:59:11] <tikue> strcat: [l for [*l] in [[1, 2], [3], [4, 5, 6]]]
[02:59:20] <strcat> tikue: not talking about list comprehensions
[02:59:35] * strcat shrugs
[02:59:39] <tikue> strcat: I'm just giving an example of what I thought you were talking about...
[02:59:44] <strcat> oh
[03:00:25] <engla> so the reason you don't like python tuples are that they have too many features?
[03:00:46] <Eridius> rusti: match (1,2,3) { (1, .._) => true, _ => false }
[03:00:47] -rusti- <anon>:7:29: 7:31 error: unexpected token: `..`
[03:00:47] -rusti- <anon>:7          match (1,2,3) { (1, .._) => true, _ => false }
[03:00:47] -rusti-                                       ^~
[03:00:47] -rusti- application terminated with error code 101
[03:00:51] <Eridius> too bad that doesn't work
[03:00:55] <engla> iteration etc
[03:01:03] *** Quits: jedestep (jedestep@moz-DA1D61AB.natpool.nyu.edu) (Ping timeout)
[03:01:25] <strcat> rusti: let (x, *) = (1, 2, 3); x
[03:01:25] -rusti- <anon>:7:17: 7:18 error: unexpected token: `*`
[03:01:25] -rusti- <anon>:7          let (x, *) = (1, 2, 3); x
[03:01:25] -rusti-                           ^
[03:01:26] -rusti- application terminated with error code 101
[03:01:26] *** Joins: jedestep (jedestep@moz-DA1D61AB.natpool.nyu.edu)
[03:01:32] <strcat> it works for some types
[03:01:42] <tikue> strcat: anyway, the same syntax support doesn't exist for python's tuples and lists. it's very similar, but different in some cases, such as the fact that argument unpacking always returns a list, and leaving off parens or brackets is always a tuple
[03:01:47] <strcat> I have a bug open about */_ inconsistency
[03:01:52] <Eridius> rusti: match (1,2,3) { (1,*) => true, _ => false }
[03:01:52] -rusti- <anon>:7:28: 7:29 error: unexpected token: `*`
[03:01:52] -rusti- <anon>:7          match (1,2,3) { (1,*) => true, _ => false }
[03:01:52] -rusti-                                      ^
[03:01:52] -rusti- application terminated with error code 101
[03:02:05] <strcat> tikue: python's tuples don't use parens though
[03:02:06] <strcat> that's just a separator
[03:02:28] <engla> classic python.  1,  is a tuple and can fool you
[03:02:39] <tikue> strcat: not sure I follow
[03:02:39] <tikue> >>> t = 1, 2
[03:02:40] <tikue> >>> t
[03:02:41] <tikue> (1, 2)
[03:02:42] <tikue> >>> 
[03:02:49] <strcat> tikue: the repr doesn't matter
[03:02:57] <strcat> it's just using a separator because in many cases the separator is needed
[03:03:06] <strcat> it can't print a tuple as 1, 2
[03:03:16] <tikue> strcat: it seems we're debating semantics. :\
[03:03:29] <strcat> tikue: they aren't semantics... python's grammar doesn't include () for tuples
[03:03:57] <strcat> (1, 2) is just like ([1, 2]) - meaningless separators
[03:04:02] <strcat> why does it use () by default in repr?
[03:04:08] <strcat> because tuples know how to print themselves
[03:04:26] <strcat> other types don't know how, so when other types print contained tuples, the tuples must not be ambiguous
[03:04:53] *** Joins: ghrust (ghrust@2EE61FCC.6A2AE50.F3114085.IP)
[03:04:53] <ghrust> 01[13rust01] 15bors 04force-pushed 06auto from 14880986a to 143c0a162: 02http://git.io/N3iJvQ
[03:04:53] *** Parts: ghrust (ghrust@2EE61FCC.6A2AE50.F3114085.IP) ()
[03:04:57] *** Joins: ghrust (ghrust@9C8B94D4.6A2AE50.F3114085.IP)
[03:04:57] <ghrust> 01[13rust01] 15bors pushed 2 new commits to 06auto: 02http://git.io/IKMM_Q
[03:04:57] <ghrust> 13rust/06auto 14a8bfdca 15Seo Sanghyeon: Remove visit_struct_method
[03:04:57] <ghrust> 13rust/06auto 148722fc1 15bors: auto merge of #7559 : sanxiyn/rust/struct-method, r=z0w0...
[03:04:57] *** Parts: ghrust (ghrust@9C8B94D4.6A2AE50.F3114085.IP) ()
[03:05:07] <strcat> a list prints itself by calling the repr on the contained elements
[03:05:09] <tikue> >>> type(())
[03:05:09] <tikue> <class 'tuple'>
[03:05:25] <strcat> tikue: it's a special case
[03:05:27] <strcat> for empty literals
[03:06:09] <tikue> strcat: do you know where I can look at python's grammar
[03:07:31] *** Joins: dherman (dherman@moz-6CA476B1.hsd1.ca.comcast.net)
[03:07:31] *** ChanServ sets mode: +o dherman
[03:07:32] <engla> here is something http://docs.python.org/3/reference/grammar.html
[03:07:44] <tikue> strcat: anyway, that's cool. I didn't realize the parens were not defined as part of the tuple grammar
[03:08:32] *** Quits: Earnestly (earnest@2A2BF8F5.321FA5E6.BFD1ABFD.IP) (Ping timeout)
[03:08:49] *** Quits: dherman (dherman@moz-6CA476B1.hsd1.ca.comcast.net) (Quit: dherman)
[03:08:50] <tikue> strcat: but I'm not sure what you mean when you say "tuple has a definition, and that's not it." 
[03:09:11] *** Joins: bjz (brendanzab@B398BE78.F804C29E.D35A31DF.IP)
[03:09:22] <strcat> tikue: >>> type((1, 2)) == type((1,))
[03:09:24] <strcat> True
[03:09:31] <strcat> they aren't tuples per the mathematical and compsci definition of a tuple
[03:09:38] <strcat> they just needed a convenient word for "immutable list"
[03:09:47] <strcat> in the context of python, that's a tuple
[03:09:52] <strcat> outside of python, that's not what a tuple is
[03:09:54] <tikue> strcat: what do you believe is the compsci definition of a tuple?
[03:10:04] <strcat> product types
[03:10:17] <engla> the types don't really matter though
[03:10:32] <engla> the behavior is the type
[03:10:51] <tikue> strcat: what is "product types"
[03:10:53] <strcat> engla: python uses abstract base classes for lots of stuff now so that's not very true
[03:10:54] *** Joins: ghrust (ghrust@AC22872E.6A2AE50.F3114085.IP)
[03:10:54] <ghrust> 01[13rust01] 15bors 04force-pushed 06auto from 148722fc1 to 143c0a162: 02http://git.io/N3iJvQ
[03:10:54] *** Parts: ghrust (ghrust@AC22872E.6A2AE50.F3114085.IP) ()
[03:10:55] *** Joins: ghrust (ghrust@AD60B2E3.6A2AE50.F3114085.IP)
[03:10:55] <ghrust> 01[13rust01] 15bors pushed 2 new commits to 06auto: 02http://git.io/Q0onog
[03:10:55] <ghrust> 13rust/06auto 149ee0c3a 15Seo Sanghyeon: Do not rely on newtype enum dereference
[03:10:55] <ghrust> 13rust/06auto 14403eff3 15bors: auto merge of #7560 : sanxiyn/rust/newtype-enum, r=cmr...
[03:10:55] *** Parts: ghrust (ghrust@AD60B2E3.6A2AE50.F3114085.IP) ()
[03:11:03] <engla> not a lot of stuff
[03:11:06] *** Quits: alisdair (textual@moz-EBE9F394.bchsia.telus.net) (Quit: My MacBook Pro has gone to sleep. ZZZzzzâ€¦)
[03:11:37] <Luqman> :( buildbot is broken
[03:11:38] <strcat> tikue: a compound type with the actual type defined by what makes it up
[03:12:06] <strcat> since they have a fixed order/size/types
[03:12:16] <bjz> tikue: https://en.wikipedia.org/wiki/Product_type
[03:12:17] <tikue> strcat: ah, so you're saying python's tuple is not a tuple because it doesn't make note of the particular types of the elements?
[03:12:33] <tikue> in the type itself
[03:12:50] <bjz> tikue: in the MLs, the type is actually written: (T * U * ...)
[03:12:50] <strcat> tikue: that's one reason, yes
[03:12:58] <engla> but (int, int) can't be a type, int is a function in python :P
[03:13:04] <strcat> engla: it's not a function
[03:13:11] <engla> it used to be
[03:13:13] <strcat> >>> type(int)
[03:13:15] <strcat> <class 'type'>
[03:13:16] <engla> long ago
[03:13:18] <tikue> >>> type(int)
[03:13:19] <tikue> <class 'type'>
[03:13:21] <tikue> int is also a type
[03:13:23] <tikue> ah
[03:13:43] <strcat> int("5") is just like Class("5")
[03:14:09] <engla> I know
[03:14:19] <ross> the world of dynamic languages is scary
[03:14:23] *** Quits: Sorella (queen@78575561.924F2739.95C8B7C6.IP) (Quit: (quit))
[03:14:29] <strcat> rust has that same quirk for the built-ins
[03:14:33] <engla> "Starting in Python 2.2, built-in factory functions such as int() and str() are also names for the corresponding types"
[03:14:35] <bjz> ross: agreed D:
[03:14:40] <strcat> they're lowercase despite the convention being TypeName
[03:14:42] <engla> see, int and str used to be functions only
[03:14:47] <engla> that's what the joke was about
[03:14:57] <tikue> engla: but the function called isn't int(), it's int.__init__() i believe
[03:15:00] <strcat> engla: in 2001 ;p
[03:15:25] <strcat> I was.. 9
[03:15:29] *** Quits: jaen (jaen@moz-E0979827.copit.pl) (Ping timeout)
[03:15:37] <engla> good age for python
[03:15:42] <ross> now I feel old
[03:16:40] <strcat> github ruined issue search
[03:16:53] *** Joins: ghrust (ghrust@AD60B2E3.6A2AE50.F3114085.IP)
[03:16:54] <ghrust> 01[13rust01] 15bors 04force-pushed 06auto from 14403eff3 to 143c0a162: 02http://git.io/N3iJvQ
[03:16:54] *** Parts: ghrust (ghrust@AD60B2E3.6A2AE50.F3114085.IP) ()
[03:16:55] *** Joins: ghrust (ghrust@9C8B94D4.6A2AE50.F3114085.IP)
[03:16:55] <ghrust> 01[13rust01] 15bors pushed 5 new commits to 06auto: 02http://git.io/fQXT3Q
[03:16:55] <ghrust> 13rust/06auto 14fb689d1 15blake2-ppc: deque: Fix grow condition in add_front...
[03:16:55] <ghrust> 13rust/06auto 14237574b 15blake2-ppc: deque: Add tests and bench tests...
[03:16:55] <ghrust> 13rust/06auto 14d7dec5d 15blake2-ppc: deque: Speed up deque growth by a lot...
[03:16:57] *** Parts: ghrust (ghrust@9C8B94D4.6A2AE50.F3114085.IP) ()
[03:17:13] <strcat> with the UI itself, you can't search for both open bugs + by date created
[03:17:19] <strcat> if you change the sort, it removes filters
[03:17:21] <strcat> yay
[03:17:40] * strcat tries making the query himself
[03:17:56] <strcat> there we go
[03:18:08] <Luqman> i also hate when you previously chose an issue but forget later and don't notice because it's below the fold
[03:18:41] <strcat> Luqman: and they use tons of caching so they appear as open in a search for a while
[03:18:55] <strcat> sometimes until you ask the github people to fix the cache ;\
[03:19:10] <Luqman> hmm, by chose an issue I meant tag
[03:19:17] <strcat> Luqman: ah
[03:19:25] * strcat read chose as close
[03:19:59] <strcat> can thank my brain for the fuzzy error correction
[03:20:05] *** Quits: sp3d (a@moz-49806493.dhcp.stls.mo.charter.com) (Ping timeout)
[03:20:23] <strcat> but hey it's the same edit distance to choose so... it was a good try
[03:20:28] <strcat> rusti: foo
[03:20:28] -rusti- <anon>:7:9: 7:12 error: unresolved name `foo`.
[03:20:29] -rusti- <anon>:7          foo
[03:20:29] -rusti-                   ^~~
[03:20:29] -rusti- error: aborting due to previous error
[03:20:29] -rusti- application terminated with error code 101
[03:20:40] <strcat> rusti: let foobar = 5; nothing
[03:20:40] -rusti- <anon>:7:25: 7:32 error: unresolved name `nothing`.
[03:20:41] -rusti- <anon>:7          let foobar = 5; nothing
[03:20:41] -rusti-                                   ^~~~~~~
[03:20:41] -rusti- error: aborting due to previous error
[03:20:41] -rusti- application terminated with error code 101
[03:20:42] *** Joins: cdidd (cdidd@54BC2570.3F8A26A4.62D8163C.IP)
[03:20:51] <strcat> huh, where's the suggestion
[03:20:55] <strcat> rusti: let foobar = 5; foob
[03:20:56] -rusti- <anon>:7:25: 7:29 error: unresolved name `foob`. Did you mean `foobar`?
[03:20:56] -rusti- <anon>:7          let foobar = 5; foob
[03:20:56] -rusti-                                   ^~~~
[03:20:56] -rusti- error: aborting due to previous error
[03:20:56] -rusti- application terminated with error code 101
[03:20:58] *** Quits: jmgrosen (jmgrosen@moz-ED8F62BC.cs.ucsb.edu) (Ping timeout)
[03:21:13] <strcat> noooooooo, the terribly inaccurate suggestions are gone ;p
[03:21:25] *** Joins: jmgrosen (jmgrosen@moz-ED8F62BC.cs.ucsb.edu)
[03:21:27] <Luqman> welp good news is the queue will soon be empty, bad news cause they all "failed"
[03:21:47] <strcat> yeah the bots are broken
[03:22:07] <engla> ah so nothing can land?
[03:22:55] *** Joins: ghrust (ghrust@DE823A67.6A2AE50.F3114085.IP)
[03:22:55] <ghrust> 01[13rust01] 15bors 04force-pushed 06auto from 149b77703 to 143c0a162: 02http://git.io/N3iJvQ
[03:22:55] *** Parts: ghrust (ghrust@DE823A67.6A2AE50.F3114085.IP) ()
[03:22:56] *** Joins: ghrust (ghrust@C8693FCB.6A2AE50.F3114085.IP)
[03:22:56] <ghrust> 01[13rust01] 15bors pushed 2 new commits to 06auto: 02http://git.io/ipZsjw
[03:22:56] <ghrust> 13rust/06auto 146ee8fee 15Philipp BrÃ¼schweiler: vec: Fix size_hint() of reverse iterators...
[03:22:56] <ghrust> 13rust/06auto 142f556d1 15bors: auto merge of #7565 : Blei/rust/fix-rev-size-hint, r=cmr...
[03:22:56] *** Parts: ghrust (ghrust@C8693FCB.6A2AE50.F3114085.IP) ()
[03:23:07] <engla> :( my change failed too
[03:24:11] *** Joins: ghrust (ghrust@79968228.6A2AE50.F3114085.IP)
[03:24:11] <ghrust> 01[13rust01] 15thestinger pushed 1 new commit to 06master: 02http://git.io/8aVAJQ
[03:24:11] <ghrust> 13rust/06master 1423da380 15Daniel Micay: force LLVM clean
[03:24:11] *** Parts: ghrust (ghrust@79968228.6A2AE50.F3114085.IP) ()
[03:24:16] <tikue> are any of you familiar with extra::getopts?
[03:24:40] <strcat> and hey, use an iso8601 date while we're at it ;p
[03:25:01] <engla> something's broken "...i686-unknown-linux-gnu/Release+Asserts/bin/llvm-mc: No such file or directory"
[03:25:03] * strcat hopes that fixes it
[03:25:52] *** Joins: ghrust (ghrust@AD60B2E3.6A2AE50.F3114085.IP)
[03:25:52] <ghrust> 01[13rust01] 15bors 04force-pushed 06auto from 142f556d1 to 1423da380: 02http://git.io/N3iJvQ
[03:25:52] *** Parts: ghrust (ghrust@AD60B2E3.6A2AE50.F3114085.IP) ()
[03:25:53] *** Joins: ghrust (ghrust@AC22872E.6A2AE50.F3114085.IP)
[03:25:53] <ghrust> 01[13rust01] 15bors pushed 2 new commits to 06auto: 02http://git.io/wZWu3Q
[03:25:53] <ghrust> 13rust/06auto 146ee8fee 15Philipp BrÃ¼schweiler: vec: Fix size_hint() of reverse iterators...
[03:25:53] <ghrust> 13rust/06auto 1492a2ce2 15bors: auto merge of #7565 : Blei/rust/fix-rev-size-hint, r=cmr...
[03:25:54] *** Parts: ghrust (ghrust@AC22872E.6A2AE50.F3114085.IP) ()
[03:25:55] *** Joins: vk (vk@moz-389FEE13.hsd1.ca.comcast.net)
[03:28:22] *** Joins: tedh (tedh@moz-F0B37C08.hsd1.il.comcast.net)
[03:29:13] *** Quits: bytbox (s@moz-DC83764A.washdc.fios.verizon.net) (Ping timeout)
[03:33:15] <strcat> oh good it also lot a mac bot
[03:33:19] <strcat> so it's going to take 2x as long
[03:34:16] *** Joins: FG_Regulus (Mibbit@moz-D676CF1C.tampfl.fios.verizon.net)
[03:34:18] *** Quits: jmgrosen (jmgrosen@moz-ED8F62BC.cs.ucsb.edu) (Quit: jmgrosen)
[03:34:32] <FG_Regulus> Howdy, guys.
[03:35:48] *** Quits: Jesse (jruderman@2557E599.66715431.D25A875A.IP) (Quit: Jesse)
[03:35:57] <dbaupp> hi :)
[03:36:01] <sfackler> does run-pass/syntax-extension-fmt.rs fail for anyone else when running make check?
[03:36:14] <FG_Regulus> Real quick question - How do I go about assigning the `char` return of a function to the `&mut char` of an iterator?
[03:36:41] <dbaupp> FG_Regulus: *iter_value = my_func()
[03:36:50] <dbaupp> sfackler: it wasn't failing for me yesterday
[03:37:05] <dbaupp> (don't know about today)
[03:37:29] <strcat> aatch: any idea where 'as' is implemented
[03:37:41] <aatch> strcat, uh... expr?
[03:37:41] <FG_Regulus> dbaupp: I keep getting the error `mismatched types: expected `&mut char` but found `char` 
[03:37:59] <strcat> FG_Regulus: you need to deref the pointer
[03:38:02] <dbaupp> FG_Regulus: what's the line that happens on?
[03:38:19] <FG_Regulus> http://mibpaste.com/i5XJna Right there, my good man.
[03:38:34] *** Joins: snadon (chatzilla@moz-3BC727E8.mc.videotron.ca)
[03:38:42] <FG_Regulus> dbaupp: Works with a deref, though. Don't know why I didn't think of that.
[03:38:46] <aatch> strcat, yep,trans_imm_cast is one place.
[03:38:47] <strcat> aatch: ok I see some cast stuff, thanks
[03:38:57] <sfackler> that doesn't look right: task failed at 'left: ~"0" does not equal right: ~"5.82"'
[03:39:18] <dbaupp> sfackler: have you made any local changes?
[03:39:39] <sfackler> these: https://github.com/mozilla/rust/pull/7513 , but I can't imagine they'd mess with fmt!
[03:40:41] <strcat> rusti: 'a' + 'a'
[03:40:42] -rusti- '\xc2'
[03:40:49] <strcat> great, so many holes in char
[03:40:59] <strcat> should just remove all those operators so it's easier to fix it
[03:41:03] <dbaupp> sfackler: that is pretty strange
[03:41:38] <dbaupp> strcat: the "correct" way probably also involves removing char from the int ast item.
[03:41:56] *** Quits: heftig (heftig@moz-A3FE237F.dip0.t-ipconnect.de) (Ping timeout)
[03:42:07] <strcat> I like this screwup
[03:42:14] <strcat> rusti: let x = 5 as bool; x
[03:42:15] -rusti- true
[03:42:22] <strcat> rusti: let x = 5 as bool; (x, x == true)
[03:42:23] -rusti- (true, false)
[03:42:36] <aatch> When does true not equal true?
[03:42:38] <strcat> since we don't correctly treat bools as i1
[03:42:40] <aatch> when it's 5?
[03:42:45] <dbaupp> aatch: yep
[03:42:52] <aatch> strcat, I'm pretty sure that's not hard to do.
[03:43:01] *** Quits: taylanub (taylanub@moz-91576060.dip0.t-ipconnect.de) (Ping timeout)
[03:43:02] <strcat> aatch: they should be i8 when stored in a struct or a register
[03:43:07] <strcat> but i1 as soon as they are loaded
[03:43:11] *** Quits: FG_Regulus (Mibbit@moz-D676CF1C.tampfl.fios.verizon.net) (Quit: http://www.mibbit.com ajax IRC Client)
[03:43:15] <strcat> it should trunc on load and zext on store
[03:43:20] <strcat> range asserts remove the work
[03:43:27] <strcat> (and we have them)
[03:43:29] <aatch> strcat, nah, even better, just make them i1 everywhere.
[03:43:32] <strcat> aatch: no
[03:43:34] <strcat> you can't do that
[03:43:43] <strcat> they need to be stored as i8
[03:44:01] <strcat> you can pass them as 'i1 zeroext'
[03:44:03] <aatch> strcat, you know the data layout strings?
[03:44:13] <strcat> aatch: oh, that will fix it?
[03:44:28] <aatch> strcat, they say how big each type is, and a few other things
[03:44:39] <aatch> in theory you can tell LLVM to use 64 bits for an i32
[03:45:11] <strcat> aatch: well, can we just do what clang does? does it just say i1 is represented as i8?
[03:45:21] <aatch> strcat, wait, misread it.
[03:45:31] <aatch> I was hoping it would be easy...
[03:45:39] <strcat> clang stores them as i8, passes them as i1 zeroext and treats them as i1 after a load
[03:45:41] *** Joins: paupau (textual@moz-D6583788.hsd1.ca.comcast.net)
[03:45:45] <strcat> lets just copy that
[03:45:51] <paupau> congrats on 0.7
[03:45:55] <strcat> that's what LLVM knows how to optimize
[03:46:10] <strcat> it only knows how to optimize clang's output and venturing outside it is bad :(, our bool range asserts don't help atm
[03:46:10] <aatch> it's alignment and prefered alignment.
[03:46:35] *** Quits: tikue (tkuehn@2557E599.66715431.D25A875A.IP) (Quit: tikue)
[03:46:38] <strcat> the only thing it does with the range asserts is making extension/truncation a no-op
[03:47:44] <strcat> one day we'll have working bools :|
[03:48:35] *** Joins: roo (jesse.rudo@moz-B7585E4C.dynamic.ip.windstream.net)
[03:48:37] <aatch> strcat, I do like have clang to copy from though.
[03:49:01] <dbaupp> strcat: one day we'll have working everything
[03:49:05] <strcat> dbaupp: never
[03:49:08] <strcat> ;p
[03:49:29] <strcat> but working bools and sane unique pointers? we should probably have those...
[03:49:39] <strcat> when the basic language features don't work...
[03:49:40] *** Joins: seth (seth@moz-D840E602.dsl.static.sonic.net)
[03:50:19] *** Joins: illissius (illissius@moz-19397A63.catv.broadband.hu)
[03:50:39] *** Joins: heftig (heftig@moz-229FDAED.dip0.t-ipconnect.de)
[03:51:02] <dbaupp> nah, default methods are more important
[03:51:03] <dbaupp> :P
[03:51:29] *** Quits: seth (seth@moz-D840E602.dsl.static.sonic.net) (Ping timeout)
[03:51:29] *** Joins: jmgrosen (jmgrosen@moz-848F6087.sb.sd.cox.net)
[03:51:31] <engla> hey extra values of true can prove to be a lifesaver in the future
[03:51:47] <engla> especially in the underhanded rust code contest
[03:51:56] *** Quits: xLII (xLII@4BED3CB3.F5F53E8A.2D6DB75E.IP) (Ping timeout)
[03:52:02] <strcat> dbaupp: well that's actually a real issue.... we have layers and layers of features but the basic codegen can't compile trivial 2 lines programs right
[03:52:24] <strcat> it's going to be hard to actually *fix* trans
[03:52:29] <dbaupp> strcat: yeah, I know :(
[03:52:33] <strcat> building up features from a solid base is sane
[03:52:37] <aatch> strcat, the more I think about it, the more re-writing codegen from scratch seems appealing.
[03:52:40] <strcat> with good unit tests (which we don't have) and tests of the output
[03:52:50] <strcat> aatch: won't happen because it's a moving target though
[03:52:56] <Luqman> aatch: that's a losing battle
[03:52:57] <aatch> strcat, I know...
[03:53:06] <strcat> I think we need a cycle of fixing codegen
[03:53:13] <dbaupp> strcat: trans isn't moving that fast atm is it?
[03:53:16] <strcat> it's a serious issue
[03:53:22] <strcat> dbaupp: it moves fairly fast
[03:53:39] <strcat> all the language changes are churn across the codebase to contend with
[03:53:43] <strcat> and we add features all the time
[03:54:06] *** Joins: mnemotic (niko@8FFD1BD2.9D81E74C.53DF0002.IP)
[03:55:06] <dbaupp> fwiw, the most recent change for all but one of the files has been a broad syntactic change, not something specific to trans
[03:55:19] <dbaupp> (and most features are higher level features, I think)
[03:55:27] <aatch> there's way too much language-level logic in our codegen.
[03:55:34] *** Quits: int3_ (int3_@moz-ABE52D50.hsd1.ca.comcast.net) (Client exited)
[03:55:52] <strcat> I really don't think I can remove ~ headers
[03:55:56] <dbaupp> aatch: how's llvm-rs going? :)
[03:56:09] <strcat> I spent a lot of time working on it and basically got nowhere
[03:56:16] <aatch> dbaupp, stalled. I can't really muster the motivation at the moment.
[03:56:20] <strcat> and it's just going to make trans even more complicated
[03:56:30] <strcat> double the code paths all over the place
[03:56:55] <dbaupp> aatch: understandable
[03:58:02] <strcat> are we going to go 0.8 -> 0.9 -> 1.0? there's no way the basic language features are going to be working by then :|
[03:58:26] <mcpherrin> strcat: I really doubt it
[03:58:47] <Eridius> strcat: naw, it's gonna go to 0.10
[04:00:13] *** Quits: enix (enix@moz-A50569DD.c3-0.slvr-ubr1.lnh-slvr.md.cable.rcn.com) (Quit: Konversation terminated!)
[04:00:40] <strcat> if we were doing things sanely @, @mut, trait objects and heap closures wouldn't exist yet
[04:00:42] *** Quits: jmgrosen (jmgrosen@moz-848F6087.sb.sd.cox.net) (Quit: jmgrosen)
[04:00:42] <strcat> ;p
[04:01:27] *** Quits: vk (vk@moz-389FEE13.hsd1.ca.comcast.net) (Quit: vk)
[04:01:29] <paupau> time to write tests!
[04:02:09] <strcat> paupau: we know lots of stuff is wrong and have a thousand failing tests on the issue tracker
[04:02:21] <strcat> but no one is really working on fixing codegen
[04:02:31] *** Joins: rubber-duck (rubber-duc@moz-A141FE12.dsl.iskon.hr)
[04:02:32] <paupau> who's responsible for codegen?
[04:02:34] *** Joins: rubber-ducking (rubber-duc@moz-A141FE12.dsl.iskon.hr)
[04:02:49] *** Quits: rubber-ducking (rubber-duc@moz-A141FE12.dsl.iskon.hr) (Quit: Leaving)
[04:02:58] <strcat> no one is really responsible for it, there aren't module owners or anything
[04:03:05] *** Joins: jdm (jdm@moz-B993E2E3.dsl.teksavvy.com)
[04:03:07] <strcat> and it'd be cruel to make one person do it
[04:03:49] <paupau> well, the statement "no one is really working on fixing codegen" makes me feel like it needs at least a leader
[04:03:51] <rubber-duck> does Rust have named tuples or anonymous types ?
[04:04:07] <mcpherrin> paupau: i pronounce you in charge
[04:04:14] <paupau> help
[04:04:25] *** Joins: pcwalton (pcwalton@moz-481A040C.hsd1.ca.comcast.net)
[04:04:25] *** ChanServ sets mode: +o pcwalton
[04:05:04] <rubber-duck> I have a match expression that results in (char, bool, bool) but I would like those be named for clarity - I don't want to declare a new type since this completely internal to function
[04:05:14] <engla> strcat: you seem to have good ideas but it's very seldom that a rewrite is a good idea
[04:05:15] <strcat> rubber-duck: you can have types scoped to a function
[04:05:22] <strcat> engla: don't want a rewrite
[04:05:27] <strcat> just a lot of work on codegen
[04:05:36] <engla> ok
[04:05:39] <rubber-duck> strcat, I can define a struct inside function body ?
[04:05:43] <strcat> rubber-duck: yes
[04:05:48] <rubber-duck> strcat, neat
[04:05:57] <strcat> rubber-duck: there are named tuples 'struct Foo(int, int)' but that's just a way to avoid naming fields
[04:06:22] <rubber-duck> strcat, yea that's the opposite of what I want
[04:06:28] <strcat> rubber-duck: rusti (the bot here) actually runs everything in main
[04:06:35] <engla> a python namedtuple is where each member has an attribute (=name)
[04:06:53] *** Parts: steven_is_false (user@moz-144077DE.bchsia.telus.net) (ERC Version 5.3 (IRC client for Emacs))
[04:07:20] *** Quits: jedestep (jedestep@moz-DA1D61AB.natpool.nyu.edu) (Ping timeout)
[04:07:35] <aatch> paupau, the issue is that, as far as I can tell, the core devs aren't generally interested in the codegen unless it breaks or needs adding to.
[04:07:39] *** Quits: pcwalton (pcwalton@moz-481A040C.hsd1.ca.comcast.net) (Quit: .)
[04:09:21] *** Joins: int3_ (int3_@moz-ABE52D50.hsd1.ca.comcast.net)
[04:09:26] <paupau> aatch: right, so that's why it's the way it is now?
[04:09:51] *** Quits: int3_ (int3_@moz-ABE52D50.hsd1.ca.comcast.net) (Client exited)
[04:09:53] <strcat> there has been a lot of effort put into making backwards incompatible changes ASAP
[04:09:55] <aatch> paupau, kinda. Remember that Rust is self-hosting and has been for years
[04:10:34] <aatch> so we get a special kind of bit rot where things that don't make sense now were the only way at the time of writing.
[04:10:34] <strcat> changes to the language/libraries take a lot of effort due to it being self-hosting
[04:10:49] <paupau> ah, gotcha
[04:11:00] *** Joins: doomlord (doomlod@moz-6651F8D4.range86-145.btcentralplus.com)
[04:11:07] <aatch> codegen is also special in that it's pretty hard to work around bugs in codegen
[04:11:07] <paupau> like ~ headers eh
[04:11:43] <aatch> so you get a "it works, don't touch it" vibe.
[04:11:50] <aatch> not from the devs, but the code itself.
[04:11:52] <strcat> "works"
[04:12:24] <aatch> strcat, "doesn't segfault on code that should make it to trans, mostly"
[04:12:27] <paupau> so each release is built from the previous release? or from itself?
[04:12:38] <aatch> paupau, we have occasional snapshots.
[04:12:48] <engla> well you need test cases that fail that you can fix, you need to measure perf before you can improve it
[04:13:45] <aatch> engla, the issue is that there aren't really hotspots in codegen.
[04:13:45] <strcat> you don't need test cases to know that making 8 byte allocations 64 bytes is bad
[04:14:03] <strcat> I don't know how you'd show that with a test case
[04:14:13] <aatch> it's the dark side of the no-early-optimization mantra
[04:14:38] <strcat> it's not optimization though
[04:14:45] <strcat> it needs to generate really small IR
[04:14:48] <aatch> strcat, same idea though.
[04:14:58] <strcat> yeah it's just not premature
[04:15:30] <strcat> we know our compile-time is slow because of the amount of IR we generate
[04:15:41] <aatch> strcat, quality is pretty much uniform across the board, so picking something out what to fix is a nightmare.
[04:15:44] <strcat> we know that reducing the IR output by 50% is going to speed up compiles a lot
[04:15:49] <strcat> aatch: yep
[04:16:06] <strcat> we can do better than reducing it by 50% anyway
[04:16:13] <strcat> rust could compile 10-20x faster
[04:16:25] <engla> hopefully. current speed is hopeless
[04:16:44] <strcat> not 'hopefully', we know why it compiles slowly
[04:16:50] <aatch> The problem with trans is that it tries to be too smart, and fails miserably at it.
[04:16:51] <strcat> we can measure the time spent in LLVM passes
[04:17:12] <doomlord> does context-free-gramar increase the amount of parallelism you can find in a build
[04:17:21] <strcat> parsing, type checking, etc are a non-issue
[04:17:24] <strcat> that's not why rust is slow
[04:17:30] <strcat> 90% of the time is spent in LLVM passes
[04:17:33] <strcat> why? because we generate bad code
[04:17:36] <strcat> it is *the* issue
[04:17:38] <aatch> doomlord, in a 10 minute build, ~9 minutes are spent in LLVM
[04:17:52] <doomlord> ok
[04:17:59] <strcat> we generate 20-200x as much IR as clang depending on the code sample
[04:18:12] <strcat> we'll have 50-100 allocas in a function clang will generate 4-5 for
[04:18:28] <strcat> LLVM will optimize it to near the same thing
[04:18:30] <strcat> but it takes forever
[04:18:42] *** Quits: Kruppe (user@moz-E150F49F.cpe.net.cable.rogers.com) (Client exited)
[04:18:49] <strcat> anyway that's why rust compiles slowly, the solution isn't a high-level one
[04:18:51] <strcat> it's fixing codegen
[04:18:58] *** Quits: SiegeLord (sl@moz-CAF07B4C.hsd1.ma.comcast.net) (Quit: Leaving)
[04:20:10] <paupau> wow
[04:20:18] *** Quits: dwrensha (chatzilla@moz-DE44EA45.hsd1.pa.comcast.net) (Ping timeout)
[04:20:37] <aatch> strcat, I think one big bonus would be changing the way we handle intrinsics to be inserted into the function at call time.
[04:21:05] <aatch> at least for most of them.
[04:21:06] <strcat> I really want to fix ~ but..
[04:22:04] *** Quits: Diamond (dick@moz-C01E1CD1.ks.ks.cox.net) (Client exited)
[04:22:06] <aatch> they get marked alwaysinline anyway.
[04:22:16] *** Joins: doener (doener@moz-121949B3.unitymediagroup.de)
[04:24:11] <strcat> anyway trans is really messed up
[04:24:20] <strcat> it pretends all kinds of things are ~
[04:24:22] *** Quits: mnemotic (niko@8FFD1BD2.9D81E74C.53DF0002.IP) (Ping timeout)
[04:25:04] *** Joins: Diamond (dick@moz-C01E1CD1.ks.ks.cox.net)
[04:26:14] <strcat> oh well I fixed bors with that
[04:26:33] *** Joins: pnathan (Adium@B9840254.2CD8A5F8.477B877D.IP)
[04:27:05] <paupau> is it possible to slowly rid trans of that illusion
[04:27:10] <paupau> or do you have to do it all at once?
[04:27:19] <strcat> at once
[04:27:25] <paupau> eek
[04:27:26] <strcat> well
[04:27:37] <strcat> I think I'll have to write glue code
[04:27:43] <strcat> to handle more things properly
[04:27:58] <strcat> as in glue.rs (it generates code for moves/copies/destruction, etc.)
[04:28:11] <strcat> *shrug*
[04:28:20] <strcat> paupau: I actually wanted to just fix ~T
[04:28:25] <strcat> and leaving ~[] alone for now
[04:28:39] <strcat> but since trans pretends ~[] are ~T in many places...
[04:28:46] <paupau> right
[04:28:54] <paupau> that sounds like the first thing to attack then
[04:29:01] <strcat> and it treats managed-unique and unique as the same thing
[04:29:17] <paupau> is that the header problem?
[04:29:26] <strcat> one of them
[04:29:31] <aatch> man I wish we had the new for loop
[04:29:33] <strcat> managed-unique needs headers (for now)
[04:29:42] <strcat> unique doesn't
[04:29:51] <strcat> in fact they are totally unused on unique - never read/written to
[04:30:02] <aatch> I have to write bare loops because the borrow-checker can't trust the current ones.
[04:30:37] *** Quits: doomlord (doomlod@moz-6651F8D4.range86-145.btcentralplus.com) (Ping timeout)
[04:30:54] *** Joins: dudedude (Mibbit@moz-412E7E04.ftqn1.win.bigpond.net.au)
[04:31:00] <paupau> but trans still expects the headers to be present eh...
[04:31:11] <paupau> oh, so that's what you were talking about with two code paths
[04:31:12] <strcat> paupau: well it treats everything as "uniq"
[04:31:34] <strcat> paupau: so I need to split dozens of places (that I can't really find in a systemic way) to have 2 code paths instead of 1
[04:32:08] <strcat> and the fun part is that there are functions actually *returning* these fake uniq types
[04:32:17] <strcat> so if you fix the function, you have to fix all the callers - anywhere it bubbles up
[04:32:26] <strcat> and it's not in the type system
[04:32:30] <strcat> it's just a ValueRef
[04:32:39] *** Quits: pnathan (Adium@B9840254.2CD8A5F8.477B877D.IP) (Ping timeout)
[04:32:44] <paupau> that's not good
[04:33:14] <strcat> pointers, bools, integers, globals, closures, whatever - all just ValueRef
[04:33:28] <paupau> so dynamic
[04:33:28] <strcat> it's not quite as bad if you're using the actual LLVM API in C++
[04:33:32] <paupau> bring on the newtypes
[04:33:34] <strcat> but we use the crappy C wrapper
[04:33:40] <paupau> ohhh, OK
[04:33:58] <strcat> paupau: well there are 2 issues
[04:34:08] <strcat> we are using the C wrapper around the real LLVM API, and it makes everything weakly typed
[04:34:27] <strcat> and we don't have our *own* wrapper around the good C++ API, making it high-level/safe
[04:34:32] <mark_edward> can we habe pointers that say: what i'm poi nting to is atomic:
[04:34:41] <mark_edward> o think atomic pointers are good addition
[04:34:45] <paupau> when I was working on a language impl I was just spitting out llvm IR text, heheh.
[04:34:48] <strcat> trans is doing 1) implementing lots of language features, 2) translating them to LLVM, 3) implementing an API around LLVM
[04:34:55] <paupau> I was pretty anal about wrapping it with enums at least.
[04:35:16] <strcat> it does all 3 poorly and it's all mixed together
[04:35:18] * strcat sighs
[04:35:37] <mark_edward> strcat: w
[04:35:42] <mark_edward> hat u think?
[04:35:45] <aatch> mark_edward, what do you mean?
[04:35:50] *** Quits: sankha93 (Instantbir@761AFFFD.4A7A14DD.8B6C1D65.IP) (Quit: Instantbird 1.4 -- http://www.instantbird.com)
[04:36:01] <mark_edward> like an atmoic pointer type, share d on thrreads
[04:36:17] <aatch> mark_edward, well there's an AtomicPointer type in the std library
[04:36:24] <mark_edward> oh really
[04:36:27] <mark_edward> wow
[04:36:33] <mark_edward> i should've ceh
[04:36:35] <aatch> it's implemented a pointer that you do atomic operations on.
[04:36:45] <paupau> shared between threads? in rust?
[04:36:46] <mark_edward> *checked before spouting my ideas
[04:37:03] <mark_edward> paupau:  ARC2 and MutArc do that
[04:37:24] <paupau> right, ARC.
[04:37:37] <aatch> I /think/ it's sendable too, but you have to manage the lifetime.
[04:37:55] <aatch> not sendable, copyable
[04:38:17] <aatch> it's intended as a primitive though.
[04:38:19] *** Joins: dwrensha (chatzilla@moz-DE44EA45.hsd1.pa.comcast.net)
[04:38:40] <paupau> strcat: yeah that mixing must be a constant source of bugs
[04:38:45] * strcat is happy iter got mostly moved to libextra
[04:38:53] <mark_edward> what!!!!
[04:39:01] <mark_edward> vut i love your iterator llibrar
[04:39:06] <mark_edward> it belongs in std::
[04:39:09] <aatch> mark_edward, not iterator
[04:39:09] <strcat> that's in libstd
[04:39:13] <mark_edward> oh ok
[04:39:19] <aatch> iter, the old crappy one.
[04:39:26] <strcat> well actually iter is the new crappy one
[04:39:30] <mark_edward> please forgive my ryping, i've been drinking.
[04:39:33] <strcat> I replaced old_iter with iter
[04:39:40] <mark_edward> strcat: but i thought iterator is new?
[04:39:41] *** Joins: alisdair (textual@moz-EBE9F394.bchsia.telus.net)
[04:39:42] <aatch> mark_edward, ahh, I thought you were on a phone or something.
[04:39:43] <strcat> and then gave up on internal iterators because they are hopelessly bad
[04:39:44] <mark_edward> and it isn't crappy
[04:39:50] <strcat> mark_edward: I added iter and iterator
[04:39:54] <strcat> iter for internal, iterator for external
[04:39:59] <strcat> and moved the old iter to old_iter
[04:39:59] <mark_edward> ah i see
[04:40:10] <strcat> and then realized iter was hopeless
[04:40:13] <strcat> so it's on the way out
[04:40:21] <aatch> but internal iterators are going to die
[04:40:27] <mark_edward> i like the external iterators. did you see that one article on jte iterators; external vs internal? i'll try and find it
[04:40:34] <mark_edward> it wad linked on reddit
[04:40:44] <paupau> people can just do their own .each without language support anyway eh
[04:40:59] <aatch> well you can have a "loopy" do-expression
[04:40:59] *** Quits: hjr3 (hradtke@moz-E87BDF1F.socal.res.rr.com) (Ping timeout)
[04:41:12] <mark_edward> http://journal.stuffwithstuff.com/2013/01/13/iteration-inside-and-out/
[04:41:24] <mark_edward> how will your iterators deal with trees?
[04:41:37] <aatch> mark_edward, explicit stack?
[04:41:38] <mark_edward> does stdLLTreemap have exxternal iterators yet?
[04:41:42] <strcat> we will eventually (far in the future) have generators
[04:41:45] <strcat> mark_edward: yes in fact it was the first
[04:41:51] <strcat> I wrote the treemap iterator before any others
[04:41:54] <mark_edward> but the article says they were clumsy???
[04:41:56] <strcat> before there was an Iterator trait
[04:42:18] <mark_edward> strcat: oh cool
[04:42:21] <aatch> mark_edward, I think more clumsy is more accurate
[04:42:25] <strcat> well it's more useful than a vector/deque iterator, because it's not hard to do those yourself with an int
[04:42:41] <mark_edward> did you see the comment from the writer of Mgpie PL about his ttree iterators?
[04:42:43] <strcat> C# has a yield syntax that compiles to a state machine
[04:42:47] <strcat> we can have that too
[04:42:52] <mark_edward> http://www.reddit.com/r/programming/comments/1hl2qr/rust_07_released/cavjfkv
[04:42:53] <strcat> mark_edward: that's not acceptable for rust though
[04:42:59] <strcat> it's a systems language, can't be slow
[04:43:08] <strcat> context switch for each iteration isn't going to be acceptable
[04:43:11] <mark_edward> is it slow, his method? If so why?
[04:43:13] <mark_edward> oh ok
[04:43:23] <Jeaye> bjz: I don't think exposing more innards is a good idea. I don't mind the idea of message sending for callbacks, but I wonder how needed they really are. What I can say, from a gamedev standpoint, is that messages tend to make code (and debugging said code) much more complex very quickly; I think glfw-rs should be as absolutely straightforward as possible -- outside and inside.
[04:43:24] <strcat> generators can be compiled to state machines
[04:43:35] <strcat> we'll have yield one day, I'm sure
[04:43:41] <strcat> plenty of stuff to finish before then
[04:43:45] <strcat> give it 1-2 years
[04:44:05] <mark_edward> cool
[04:44:10] <strcat> until then I don't mind spending 15 mins to write a tree iterator myself ;p
[04:44:19] <mark_edward> can't wait for Rust to replace Java EE
[04:44:25] <mark_edward> i hate Java
[04:44:32] <rubber-duck> strcat, what's the difference between using LLVM C API and outputing llvm bytecode ?
[04:44:32] <mark_edward> and so may people want me to write it
[04:44:33] <aatch> mark_edward, it probably won't replace Java
[04:44:45] <strcat> rubber-duck: the bytecode isn't portable between LLVM versions
[04:44:49] <strcat> they change it all the time
[04:44:52] <mark_edward> aatch: why not?
[04:44:53] <strcat> you *really* don't want to be working with it
[04:45:00] <paupau> I'm interested in messing with rust's AST
[04:45:11] <strcat> LLVM has lots of functionality for dealing with the high-level LLVM concepts
[04:45:12] <aatch> mark_edward, because Rust is too hard to learn
[04:45:18] <rubber-duck> strcat, but creating a nice API that outputs it would be better than using C API ?
[04:45:22] <strcat> rubber-duck: no
[04:45:23] *** Joins: hjr3 (hradtke@moz-E87BDF1F.socal.res.rr.com)
[04:45:24] <paupau> should be pretty easy to rip out libsyntax and feed it source code and get AST trees right?
[04:45:32] <mark_edward> not 4 me, and i'm a novice programmer
[04:45:37] <strcat> rubber-duck: create a nice API around the C (or C++) API would be good
[04:45:51] <mark_edward> i love C++, but rust is like ((C++)++ )- C
[04:45:53] <strcat> using the raw C API everywhere is bad, using raw IR strings is far worse ;p
[04:45:55] <aatch> paupau, well libsyntax is already pretty easy to use outside of the tree
[04:46:10] <paupau> aatch: great to hear
[04:46:18] <aatch> it's also installed alongside libstd and libextra
[04:46:29] <paupau> oh!
[04:46:31] <aatch> so you can just do extern mod syntax
[04:46:36] <paupau> wow, neat
[04:46:44] <rubber-duck> strcat, it just seems it would be easier to isolate/localize errors with such separation :|
[04:47:13] <aatch> I mean, the usage isn't amazing, but it only takes about 10-15 lines of code to get an AST from a file
[04:47:23] <strcat> but you'd have more errors because you would have to reimplement 1/3 of LLVM
[04:47:27] <dbaupp> aatch: less than that
[04:47:31] <aatch> including it following imports etc.
[04:48:01] <mark_edward> OMG! we need rust IDE with auto completion and stuff with libsyntax and liibrustc
[04:48:03] <aatch> dbaupp, I was including whitespace? I dunno, I just guessed.
[04:48:33] <paupau> I might do a small editor :)
[04:48:39] <rubber-duck> strcat, are you saying the compiler -> LLVM isn't as cleanly separated but compiler uses LLVM internally ?
[04:48:48] <mark_edward> paupau: can you do it on github and let me try n contribute?
[04:48:51] <dbaupp> aatch: hm, to do it properly, maybe https://github.com/cmr/rustdoc_ng/blob/master/main.rs
[04:48:54] <mark_edward> i'd love to do useful things
[04:48:59] <strcat> rubber-duck: I'm saying trans is handling 3 separate layers
[04:49:03] <aatch> mark_edward, the hard part is that libsyntax doesn't know how to recover from errors very well.
[04:49:13] <strcat> it's wrapping the C API, it's doing codegen, and it's implementing high-level language features
[04:49:16] <mark_edward> aatch: what do you mean?
[04:49:19] <strcat> and it's not cleanly separated at all
[04:49:35] <paupau> mark_edward: if it happens sure
[04:49:35] <aatch> mark_edward, well if you have a syntax error, that's it, no AST.
[04:49:45] <aatch> Which means no context
[04:50:11] <mark_edward> aatch: hm :-(  that is sad. are there plans to fix that? i know clang is good for this purpose
[04:50:17] <paupau> mark_edward: my github is 'pshc'
[04:50:21] <mark_edward> why dont you take some pointers from them?
[04:50:22] <aatch> mark_edward, nothing solid.
[04:50:26] <mark_edward> paupau: thanks
[04:50:33] <strcat> mark_edward: it's not that simple
[04:50:42] <strcat> libsyntax and librustc should be better, yeah
[04:50:47] <strcat> but good luck rewriting them
[04:50:51] <mark_edward> i understand
[04:51:01] *** Quits: reyre_ (reyre@moz-9002CDDA.cpe.net.cable.rogers.com) (Client exited)
[04:51:12] <strcat> we know the ways in which they should be better but it takes a lot of effort, and it's hard to land any changes on a moving target like rust
[04:51:20] <strcat> even +3000/-3000 lines is going to bitrot in 5 hours
[04:51:25] <mark_edward> why don't you rewrite them? why not make that all 0.8 is? a BIG REWRITE! where you do all things that couldnt do with earlier Rust versions?
[04:51:32] <mark_edward> Freeze the language till then??
[04:51:37] *** Joins: echristo (echristo@moz-1892C634.hsd1.ca.comcast.net)
[04:51:41] <strcat> that's not enough time
[04:52:04] <aatch> strcat, we really need a "lowering pass" before trans that converts the AST into something with less smarts.
[04:52:12] <strcat> and stuff like code completion is really near the bottom of a list of priorities
[04:52:24] <strcat> lets have working bools, closures, pointers, etc. - really.
[04:52:39] <mark_edward> strcat: for the good of the language, you could make it so
[04:52:46] <mark_edward> who is the boss of Rust?
[04:52:51] <aatch> mark_edward, graydon
[04:52:52] <mark_edward> is it nmatsakis?
[04:52:54] <mark_edward> oh ok
[04:52:59] <aatch> Graydon Hoare
[04:53:07] <mark_edward> it must be done, for the good of all Rust
[04:53:21] <strcat> I think graydon is already convinced that this cycle will involve a lot of work on trans
[04:53:38] <strcat> I just feel like whining about it a bit before trying to fix ~ headers again ;p
[04:53:40] <aatch> strcat, I think you and me bitching about it helped with that.
[04:53:57] <echristo> heh.
[04:54:04] <paupau> :)
[04:54:30] <mark_edward> i think, if i was Rust boss, i would demand a grand rewrite sometime before 1.0
[04:54:50] <mark_edward> you awesome compiiler guys are held back by always requiring working compiler 
[04:54:51] *** Joins: seth (seth@moz-D840E602.dsl.static.sonic.net)
[04:55:04] <echristo> it's a crutch i admit.
[04:55:41] <strcat> now where was I before....
[04:55:47] <strcat> figuring out how to make myself an mt I think
[04:55:55] *** Joins: ghrust (ghrust@2EE61FCC.6A2AE50.F3114085.IP)
[04:55:55] <ghrust> 01[13rust01] 15bors 04force-pushed 06auto from 1492a2ce2 to 1423da380: 02http://git.io/N3iJvQ
[04:55:55] *** Parts: ghrust (ghrust@2EE61FCC.6A2AE50.F3114085.IP) ()
[04:55:57] *** Joins: ghrust (ghrust@E7A4CCE2.6A2AE50.F3114085.IP)
[04:55:58] <ghrust> 01[13rust01] 15bors pushed 4 new commits to 06auto: 02http://git.io/goQ9Bg
[04:55:58] <ghrust> 13rust/06auto 145a8a30f 15Steven Fackler: Added functionality to Base64 package...
[04:55:58] <ghrust> 13rust/06auto 141482cf5 15Steven Fackler: Base64 API changes...
[04:55:58] <ghrust> 13rust/06auto 14e9988c1 15Steven Fackler: Upper-cased exported statics
[04:55:59] *** Parts: ghrust (ghrust@E7A4CCE2.6A2AE50.F3114085.IP) ()
[04:56:29] <aatch> mark_edward, there are other battles to fight.
[04:56:50] *** Quits: seth (seth@moz-D840E602.dsl.static.sonic.net) (Ping timeout)
[04:56:58] <mark_edward> aatch: like what? high performance IR emission and optimal code are high priority, right?
[04:57:05] <mark_edward> most of the work left is library work right/
[04:57:09] <bjz> Jeaye: thanks for the feedback. yeah, jack was planning to use it for servo - was think it would be nice to make it more ideomatic. and was thinking ports/chans might be less brittle than the current implementation I have
[04:57:15] <aatch> mark_edward, yeah, but there is only so much we can do.
[04:57:37] <mark_edward> but it'd be greatly improved if you could start over with lessons youv'e learned right?
[04:57:39] <bjz> Jeaye: but we could always just have messages internally, then just expose the callbacks
[04:57:40] <aatch> I have no idea what is relevant in trans. We need an "old-timer" to help.
[04:57:47] <bjz> Jeaye: I dunno
[04:57:47] <mark_edward> from what i herd IR emission is super suboptimal
[04:58:13] <aatch> mark_edward, yeah, but you can say that about any large project.
[04:58:26] <mark_edward> i kknow, so why not do it?
[04:58:28] <Jeaye> bjz: What more flexibility do you need? o.O
[04:58:36] <strcat> there is always going to be a lot of work to do
[04:58:41] <strcat> there is only "better"
[04:58:43] <strcat> fewer bugs
[04:58:46] <mark_edward> you can right? 0.7 is out, it's nice, just focus on rewrite na dperformance gains for 0.8
[04:59:00] <mark_edward> i'm going to ask grayodn if my idea is reasonable
[04:59:04] <strcat> mark_edward: half of the language features don't work or are unimplemented
[04:59:04] <mark_edward> he'll probably say no
[04:59:07] <mark_edward> true
[04:59:11] <aatch> mark_edward, i suggest sobering up.
[04:59:45] <mark_edward> aatch: you're right, i'm typing to much. it's just rewriting my projects always turns out better
[05:00:03] <mark_edward> but it's of a different scale when you're writing a new PL
[05:00:10] <strcat> are your projects 200k lines of a language they implement? ;p
[05:00:26] <bjz> http://www.joelonsoftware.com/articles/fog0000000069.html
[05:00:27] <aatch> So if we only take the time Rust has been "owned" by Mozilla, re-writing Rust requires re-writing about 4 years worth of work.
[05:00:46] <strcat> aatch: where does 'mt' come from?
[05:00:50] <strcat> the one with a ty::t as a member
[05:00:57] <aatch> With the benefit of experience we can probably get that down to like 2 years
[05:01:01] <strcat> oh nvm
[05:01:03] <strcat> there it is
[05:01:05] <aatch> strcat, ty?
[05:01:08] <bjz> Jeaye: not much more
[05:01:10] <strcat> aatch: yeah
[05:01:14] <strcat> git grep found it
[05:01:19] <strcat> for some reason I was looking for an enum ;p
[05:01:39] <strcat> /home/strcat/projects/rust/src/librustc/middle/trans/base.rs:280:37: 280:58 error: mismatched types: expected `middle::ty::vstore` but found `syntax::ast::expr_vstore` (expected enum middle::ty::vstore but found enum syntax::ast::expr_vstore)
[05:01:40] <strcat> I hate this
[05:01:42] <bjz> Jeaye: I was just thinking in terms of composability with concurrent stuff
[05:01:49] <strcat> we have two versions of a dozen things
[05:02:27] <bjz> Jeaye: but the glfw events aren't done concurrently so I don't think that matters as much (they're on the main thread)
[05:02:49] <bjz> Jeaye: hence why jack was suggesting just using them internally
[05:03:10] <Jeaye> Eh, seems like a lot of work for not too much gain.
[05:03:24] *** Quits: alisdair (textual@moz-EBE9F394.bchsia.telus.net) (Quit: My MacBook Pro has gone to sleep. ZZZzzzâ€¦)
[05:03:31] *** Quits: james4k (james@moz-E7990244.consolidated.net) (Quit: WeeChat 0.4.1)
[05:04:09] <bjz> Jeaye: have you used rust's Ports/Chans before? they work out of the box pretty much
[05:04:24] <mark_edward> i apologize for my recent behavior on this lovely channel guys. This chan is so great, and I'm sorry.
[05:04:34] <bjz> mark_edward: heh, dw
[05:04:51] <strcat> on the positive side I think I fixed malloc_raw_dyn for vectors
[05:04:56] <Jeaye> bjz: Not yet. Soon enough though.
[05:05:00] <strcat> but I broke it for unique closures
[05:05:03] *** Joins: ChrisMorgan (chris@moz-6AC741CA.static.tpgi.com.au)
[05:05:05] <bjz> mark_edward: I have had my fare share of craziness on here
[05:05:13] <bjz> mark_edward: :)
[05:05:29] *** Joins: pyrac (pyrac@moz-18D74BD0.w90-60.abo.wanadoo.fr)
[05:05:42] <Jeaye> mark_edward: I'm generally just found pleading for help. :P We're all known for something.
[05:06:05] <mark_edward> true. i just love watching this language evolve
[05:06:29] <strcat> seriously bors...
[05:07:03] <strcat> passed on mac linux windows
[05:07:07] <strcat> good enough for me
[05:07:08] <strcat> stupid timeout
[05:07:24] *** Joins: ghrust (ghrust@C8693FCB.6A2AE50.F3114085.IP)
[05:07:24] <ghrust> 01[13rust01] 15thestinger pushed 2 new commits to 06master: 02http://git.io/ura7ng
[05:07:24] <ghrust> 13rust/06master 146ee8fee 15Philipp BrÃ¼schweiler: vec: Fix size_hint() of reverse iterators...
[05:07:24] <ghrust> 13rust/06master 14dd4f6bb 15Daniel Micay: Merge pull request #7565 from Blei/fix-rev-size-hint...
[05:07:24] *** Parts: ghrust (ghrust@C8693FCB.6A2AE50.F3114085.IP) ()
[05:07:54] *** Quits: engla (engla@moz-DBD1D96E.cust.bredbandsbolaget.se) (Ping timeout)
[05:07:56] *** Joins: ghrust (ghrust@2EE61FCC.6A2AE50.F3114085.IP)
[05:07:56] <ghrust> 01[13rust01] 15bors 04force-pushed 06auto from 14395be36 to 14dd4f6bb: 02http://git.io/N3iJvQ
[05:07:56] *** Parts: ghrust (ghrust@2EE61FCC.6A2AE50.F3114085.IP) ()
[05:07:57] *** Joins: ghrust (ghrust@5FEF1C87.6A2AE50.F3114085.IP)
[05:07:57] <ghrust> 01[13rust01] 15bors pushed 4 new commits to 06auto: 02http://git.io/XO07iw
[05:07:57] <ghrust> 13rust/06auto 145a8a30f 15Steven Fackler: Added functionality to Base64 package...
[05:07:57] <ghrust> 13rust/06auto 141482cf5 15Steven Fackler: Base64 API changes...
[05:07:57] <ghrust> 13rust/06auto 14e9988c1 15Steven Fackler: Upper-cased exported statics
[05:07:58] *** Parts: ghrust (ghrust@5FEF1C87.6A2AE50.F3114085.IP) ()
[05:09:01] *** Quits: dwrensha (chatzilla@moz-DE44EA45.hsd1.pa.comcast.net) (Ping timeout)
[05:09:13] <paupau> is a unique closure run-once-only?
[05:09:15] <ChrisMorgan> Say, for example, I'm having code along the lines of ``static foo : Bar = Bar{"foo"}``, and I'd like to turn it into something more along the lines of ``define_bar!(foo)``: can I do that? My first attempt with macro_rules! could not figure out a way of getting the foo as both an identifier and an expression.
[05:09:16] <ChrisMorgan> macro_rules! define_bar(($name:ident) => { static $name: Foo = Foo { id: "$name" }; }) ... except then of course you end up with "$name" rather than "foo"
[05:09:52] <strcat> oh cool
[05:09:58] <brendanc> man, bors is grumpy
[05:10:13] <strcat> brendanc: well I pushed the last one to master because a bot timed out
[05:10:17] <strcat> so it had to redo it ;p
[05:10:26] <strcat> it successfully cancelled the build it just started though
[05:10:43] <strcat> http://buildbot.rust-lang.org/console?branch=auto&refresh=15 as in I didn't have to interrupt them
[05:11:17] <brendanc> that's my interrupter module :)
[05:11:26] <brendanc> the valgrind timeout wasn't legit?
[05:11:30] <strcat> brendanc: nope
[05:11:33] <strcat> brendanc: it's a known issue
[05:11:43] <strcat> it's just the bot timing out from a network issue afaik
[05:11:46] <strcat> happens infrequently
[05:11:50] <brendanc> ah
[05:12:42] <strcat> mac5 went down sadly
[05:12:48] <aatch> ChrisMorgan, there is a stringify! macro
[05:12:52] <strcat> I think it's a new mac mini
[05:13:09] <ChrisMorgan> aatch: are these things documented anywhere?
[05:13:17] <aatch> ChrisMorgan, no idea
[05:13:23] <aatch> on the wiki, maybe
[05:13:38] <ChrisMorgan> Well, stringify! works, which suits me well. Thanks!
[05:13:45] <brendanc> on the one hand, perhaps bors should retry failed builds when it's out of accepted ones. otoh, it hardly ever gets to the end of the pending queue
[05:14:25] <strcat> brendanc: well it's falling more and more behind
[05:14:40] <strcat> brendanc: the only reason the queue isn't enormous is because I merged ~50 PRs into ~5
[05:14:50] <strcat> it's not sustainable as it is now
[05:15:01] <strcat> I'm already tired of doing that ;p
[05:15:22] <strcat> it used to clear out
[05:15:26] <strcat> back when a cycle took 30 mins
[05:15:36] <ChrisMorgan> Then my next question: is there a way for a macro to save some stuff for later? Say, for example, I then want to have a function which will accept these bar names and return the bar constant I had; basically, it needs a preprocessor string which I can keep appending to and then write out when done, into a match block.
[05:16:01] <mark_edward> strcat: why are external iterators so much more easily composable than internal ones?
[05:16:12] <strcat> because they are an object that can implement a trait
[05:16:17] <strcat> and the state is external so you can pause it
[05:16:28] *** Joins: jedestep (jedestep@moz-9918C03C.natpool.nyu.edu)
[05:16:33] <strcat> internal iterators can never have a generic zip, union, merge, etc.
[05:16:43] <strcat> and they aren't an object so no method chaining, or generics
[05:16:54] <strcat> and closures make borrowed pointer lifetimes painful
[05:17:01] <strcat> you need fold, fold_ref, min, min_ref
[05:17:12] <strcat> so just say no to internal iterators ;p
[05:17:22] <mark_edward> ah i see. but what about haskelll? it has fold and zip and union and stuff
[05:17:36] <strcat> haskell only implements them on lists
[05:17:40] <mark_edward> those aren't external iterators?
[05:17:41] *** Quits: jdm (jdm@moz-B993E2E3.dsl.teksavvy.com) (Ping timeout)
[05:17:41] <strcat> they aren't generic, because they don't have to be
[05:17:54] <strcat> haskell is a lazy language so it doesn't need iterator objects
[05:17:57] <mark_edward> ogh right! i forgot there's like a Data.Map.zip and Data.List.zip
[05:18:16] *** Quits: jedestep (jedestep@moz-9918C03C.natpool.nyu.edu) (Ping timeout)
[05:18:30] <mark_edward> thanks for the explanation strcat. i, and i think a lot of the rust community really appreciate your iterator work
[05:18:32] <strcat> if you wanted to zip a tree set and a hash set you would have to convert them both to lists
[05:18:41] <mark_edward> they're the coolest i've ever seen
[05:18:48] <strcat> thanks
[05:18:52] <strcat> they'll get better :)
[05:19:01] <bjz> they just need to be prettier
[05:19:08] <bjz> but awesome stuff
[05:19:13] <paupau> lack of iterator invalidation is really cool.
[05:19:17] <strcat> for xs.iter().zip(ys.iter()).advance |(x, y)| {} can become 'for (x, y) in xs.zip(ys) { }' or whatever
[05:19:25] <strcat> need an Iterable trait and a new loop
[05:19:33] <paupau> I assume .iter().advance will be gone in 0.8?
[05:19:55] <strcat> paupau: ideally
[05:20:04] <aatch> paupau, hopefully.
[05:20:04] <strcat> I hoped it would be gone by the 0.7 release :(
[05:20:09] <bjz> :(
[05:20:12] *** Joins: int3_ (int3_@moz-ABE52D50.hsd1.ca.comcast.net)
[05:20:15] <aatch> strcat, hey, you got pretty far as it is
[05:20:20] <strcat> the treemap iterator existing before 0.5
[05:20:24] <strcat> existed*
[05:20:31] <strcat> as far I as can remember at least
[05:21:01] <paupau> is `in` becoming a keyword then?
[05:21:12] <strcat> paupau: doesn't have to since it's only in that context
[05:21:18] <strcat> `in` could be <- or something
[05:21:21] <strcat> like scala/haskell
[05:21:44] <paupau> oh ok, bikeshed is not yet painted I guess
[05:21:50] <bjz> :)
[05:21:57] <strcat> yeah I don't really care about the specifics of the syntax
[05:22:02] *** Quits: int3_ (int3_@moz-ABE52D50.hsd1.ca.comcast.net) (Ping timeout)
[05:22:22] <strcat> just the semantics of not being a closure, and not having to deal with stupid borrowck/capture errors from it being a closure
[05:22:31] <aatch> semantics > syntax
[05:22:42] <aatch> fortunately, this is a sentiment that Graydon agrees with.
[05:22:55] <paupau> indeed
[05:23:16] <paupau> despite that policy, rust looks really pretty
[05:23:29] <mark_edward> indeed! I think rust is super pretty
[05:23:36] <mark_edward> def prettier than haskell
[05:23:50] <mark_edward> i just like going on github and looking at rust code, lol
[05:23:56] <strcat> aatch: I don't really know how to fix the rest of this function
[05:23:59] * strcat sighs
[05:24:02] <aatch> strcat, which one?
[05:24:11] <bjz> paupau: I thought everyone hated it. oh the sigils! x)
[05:24:12] <strcat> aatch: malloc_raw_dyn
[05:24:20] <strcat> aatch: it was pretending ~fn was ~T before
[05:24:26] <strcat> I don't know what to make it pretend now
[05:24:31] <strcat> I guess I'll pretend ~fn is ~[]
[05:24:33] <strcat> that'll work
[05:24:37] <strcat> I think/hope
[05:24:54] <strcat> if you ever wonder why we have such terrible casts, it's crap like this
[05:25:01] <aatch> strcat, I already know
[05:25:38] <doener> hm, seems I lost color in rustc again :-/
[05:25:59] <strcat> doener: what's TERM?
[05:26:08] <mark_edward> hey guys, what is the benefit of  self hosting compiler?
[05:26:09] <doener> xterm-256color
[05:26:15] <strcat> hm
[05:26:20] <doener> stage0 has color, stage1 doesn't
[05:26:29] <doener> current master (as of an hour ago or so)
[05:26:46] <aatch> mark_edward, it's a really good test for the language
[05:27:01] <mark_edward> but, like from technical standpoints?
[05:27:02] <aatch> few tasks are as hard as implementing a full-featured compiler.
[05:27:11] <doener> err, weird, the other build has color
[05:27:31] <strcat>             // this is a total hack, we pretend a closure is an ~[T]
[05:27:32] <strcat>             ty::mk_evec(bcx.tcx(), ty::mt { ty: t, mutbl: ast::m_imm }, ty::vstore_uniq)
[05:27:34] <strcat> good enough
[05:27:36] <paupau> bjz: ~sigils @remind &me 'of :IRC, very compact!
[05:27:36] <strcat> no worse than it was before ;p
[05:27:50] <aatch> mark_edward, well the standard reasons are that improving the language automatically improves the compiler
[05:27:57] <aatch> stuff like that.
[05:28:11] <bjz> paupau: I was kidding :)
[05:28:14] <mark_edward> doesn't it have something to do with portabiltity or something too:?
[05:30:01] <aatch> bjz, that said, it wasn't so popular when you had to choose between ~"str" and @"str"
[05:30:01] * strcat is so annoyed by rustc atm
[05:30:07] <strcat> really want these stupid ~ headers gone
[05:30:25] <bjz> aatch: yup
[05:33:27] <strcat> yay death in glue code
[05:33:33] <strcat> how wonderful
[05:33:43] <bjz> strcat: how do our iterators compare to D's ranges?
[05:34:04] <strcat> bjz: Iterator is InputRange
[05:34:10] <strcat> Iterator + Clone is ForwardRange
[05:34:21] <strcat> we don't have BidirectionalRange and RandomRange but we could
[05:34:24] <ChrisMorgan> Can I have a macro define something to be included in the source later by another macro call?
[05:35:02] <aatch> ChrisMorgan, expansion is done before any resolution or checking, if that's what you're asking.
[05:35:25] <ChrisMorgan> I don't know if that's what I'm asking.
[05:35:38] <bjz> strcat: http://www.reddit.com/r/programming/comments/1hl2qr/rust_07_released/cavnng9
[05:35:47] <aatch> So you want to reference 'a' from a macro, but 'a' is defined a macro?
[05:36:12] <aatch> defined _in_ a macro
[05:37:00] <ChrisMorgan> I want to call one macro which then collects all the values given to it so that later I can define a function which uses them in a match block, for reverse lookup.
[05:37:18] *** Joins: jdm (jdm@moz-99E0DB62.dsl.teksavvy.com)
[05:37:41] <aatch> ChrisMorgan, ah, in that case, not really
[05:37:44] <aatch> no state
[05:37:55] <bjz> strcat: would be good if you could answer that
[05:38:03] <ChrisMorgan> OK. That's what I thought it looked like, unfortunately.
[05:38:40] <bjz> strcat: http://forum.dlang.org/thread/kr2vpp$2jmf$1@digitalmars.com#post-kr2vpp:242jmf:241:40digitalmars.com
[05:38:53] *** Joins: fabiand (fabiand@moz-EDBC4C50.adsl.alicedsl.de)
[05:39:08] *** Joins: jviereck (Adium@moz-6715FEC2.adsl.alicedsl.de)
[05:39:40] <aatch> bjz, that link doesn't work...
[05:40:04] <doener> aatch: works for me
[05:40:08] <aatch> Or maybe it's just firefox
[05:40:35] <bjz> aatch: http://j.mp/13tPl4t ?
[05:41:20] <doener> now it's dead from here, too. Maybe the server is having problems
[05:41:43] <doener> yep, proxy error
[05:41:45] <bjz> I have an alert set for 'rust' on freenode, and saw it on #D :P
[05:42:02] <bjz> doener: mmk
[05:42:10] <bjz> doener: oh yeah me too
[05:42:20] <doener> https://gist.github.com/dotdash/76af67205765177b8759
[05:42:35] <doener> by Andrei
[05:42:37] <aatch> ugh, for some reason rust has decided that an empty string, isnt
[05:44:25] *** Quits: jviereck (Adium@moz-6715FEC2.adsl.alicedsl.de) (Ping timeout)
[05:44:51] <aatch> nope, nevermind, just me not converting ++i properly.
[05:46:02] *** Quits: paupau (textual@moz-D6583788.hsd1.ca.comcast.net) (Quit: out)
[05:46:04] *** Joins: jviereck (Adium@moz-C7D00CD5.adsl.alicedsl.de)
[05:46:44] *** Quits: cdidd (cdidd@54BC2570.3F8A26A4.62D8163C.IP) (Input/output error)
[05:48:55] *** Joins: bytbox (s@moz-DC83764A.washdc.fios.verizon.net)
[05:49:49] <aatch> I still think that andrei puts too much emphasis on ranges. I used D for a while and never really got what was amazing about them. I understood how they were nice and how they were an improvement over C++.
[05:50:54] <aatch> but it's not like anybody in C++ went "you know this iterator pattern, it's perfect! you just compare the current against the end"
[05:52:01] <strcat> aatch: here's why
[05:52:04] *** Quits: jviereck (Adium@moz-C7D00CD5.adsl.alicedsl.de) (Quit: Leaving.)
[05:52:08] <strcat> aatch: our slices are awesome right?
[05:52:12] <strcat> ranges are generic slices
[05:52:31] <strcat> you could have a random access + bidirectional range on a deque
[05:52:33] <strcat> but not a &[T]
[05:52:50] <strcat> &[T] could be the range implementation for vectors, ideally (it should really be two pointers to make iteration fast)
[05:56:03] *** Quits: yichoi (yichoi@5AB4884B.FCC4549.14D5B978.IP) (Ping timeout)
[05:56:28] <aatch> strcat, see, that's the thing, slices seem obvious to me.
[05:56:42] <strcat> aatch: well 'range' is just a unified slice/iterator
[05:56:51] <strcat> &[1, 2, 3, 4, 5]
[05:56:54] <strcat> .pop_front
[05:56:57] <strcat> &[2, 3, 4, 5]
[05:56:59] <strcat> .pop_front
[05:57:01] <strcat> &[3, 4, 5]
[05:57:04] <strcat> it's an iterator
[05:57:09] <strcat> but you can also pop_back
[05:57:11] *** Joins: yichoi (yichoi@33330B78.C27FDFFF.F77B52D8.IP)
[05:57:15] <strcat> and you can index, and if it's &mut you can swap
[05:57:36] <strcat> so you can have Range (pop_front), BidirectionalRange (pop_back) and RandomAccessRange (indexing, swapping)
[05:57:42] <strcat> that's all D ranges are
[05:58:09] *** Joins: mat1 (mat@579C1D31.DC7A989C.7F8AB798.IP)
[05:58:13] <strcat> Iterator == Range, next == pop_front
[05:59:03] *** Joins: sankha93 (Instantbir@9276287F.8CAC2DA9.D2D1FAF0.IP)
[05:59:11] *** Joins: cdidd (cdidd@moz-80CE443B.broadband.corbina.ru)
[05:59:30] <mat1> im getting the following error when trying to compile rust-0.7
[05:59:41] <mat1> /bin/sh: /home/user/Dev/rust-0.7/llvm/x86_64-unknown-linux-gnu/Release+Asserts/bin/llvm-mc: No such file or directory
[05:59:46] <mat1> make: *** [rt/x86_64-unknown-linux-gnu/stage0/arch/x86_64/_context.o] Error 127
[06:00:05] <klutzy> does llvm-cm exist in the directory?
[06:00:12] <aatch> mat1, did you do ./configure?
[06:00:15] <klutzy> it seems llvm didn't compiled correctly
[06:00:25] *** Quits: pyrac (pyrac@moz-18D74BD0.w90-60.abo.wanadoo.fr) (Quit: pyrac)
[06:00:32] <mat1> aatch: yes i did
[06:00:46] <klutzy> mat1: you should mkdir build && cd build && ../configure
[06:01:43] <mat1> klutzy: ok let me try, it didn't have the llvm-mc directory
[06:02:02] <aatch> mat1, llvm-mc is a binary
[06:02:11] <aatch> compiled as part of the llvm build
[06:02:33] *** Quits: yichoi (yichoi@33330B78.C27FDFFF.F77B52D8.IP) (Ping timeout)
[06:03:02] <mat1> aatch, klutzy: i think llvm did error out before it finished
[06:03:27] <mat1> and then i tried to rebuild rust with 'make', but it must be erroring out because the llvm never finished
[06:03:45] <klutzy> u-huh
[06:04:04] <aatch> mat1 that seems likely
[06:04:42] <aatch> it's pretty liberal with the LLVM dependency because it takes so long to do.
[06:05:38] <mat1> after ../configure, should i do ../make?
[06:05:47] <klutzy> no, just make
[06:06:29] <mat1> hmm i got the same error
[06:07:56] <mat1> oh... should i do the build stuff, inside the rust-0.7/llvm/ directory?
[06:08:02] <aatch> mat1, no
[06:09:09] <aatch> mat1, if you touch one of the cpp files inside the llvm dir, it should work
[06:09:22] <ChrisMorgan> I'm getting something really weird with my Rust 0.7 that I built a few hours ago. Minimal failure case: use std::*;fn main(){fail!("");}
[06:09:42] <ChrisMorgan> First line of rustc output: <core-macros>:45:12: 45:48 error: unresolved import: could not find `sys` in `std::std`.
[06:10:16] <ChrisMorgan> So, fail! works fine so long as I don't use std::*, but as soon as I do, it fails!
[06:10:29] *** Joins: yichoi (yichoi@5AB4884B.FCC4549.14D5B978.IP)
[06:10:41] <mat1> aatch: same error as before :(
[06:11:20] *** Quits: ssbr (ssbr@moz-141F89C6.block0.gvtc.com) (Ping timeout)
[06:11:21] <aatch> ChrisMorgan, glob imports are funky.
[06:11:42] <aatch> see if theres an issue open for it already, if not open one
[06:12:13] <heftig> >> use std::*;fn main(){fail!("");}
[06:12:17] <heftig> rusti: use std::*;fn main(){fail!("");}
[06:12:21] -rusti- <anon>:7:13: 7:20 warning: unused import [-W unused-imports (default)]
[06:12:21] -rusti- <anon>:7          use std::*;fn main(){fail!("");}
[06:12:22] -rusti-                       ^~~~~~~
[06:12:22] -rusti- ()
[06:13:24] <mat1> aatch: if i do a 'make clean', will that help?
[06:13:31] <aatch> mat1, maybe
[06:13:32] *** Joins: ssbr (ssbr@moz-141F89C6.block0.gvtc.com)
[06:14:26] <aatch> Oh, this is hilarious
[06:14:48] <mat1> aatch: oh same error again
[06:14:57] <aatch> mat1, no idea then, sorry
[06:15:06] *** Joins: pnathan (Adium@moz-E3C3FAF2.hfc.comcastbusiness.net)
[06:15:11] *** Joins: vk (vk@moz-389FEE13.hsd1.ca.comcast.net)
[06:15:22] <mat1> aatch: ok thanks
[06:15:44] <klutzy> mat1: try `git clean -d -f` for cleaning all generated stuff
[06:16:01] *** Joins: jaen (jaen@moz-E0979827.copit.pl)
[06:16:07] <ChrisMorgan> aatch: there we go, https://github.com/mozilla/rust/issues/7580
[06:16:54] <aatch> the 'target_family' config is actually the 'host' family.
[06:17:57] <aatch> so anything that relies on something like #[cfg(unix)] will break under cross-compile.
[06:20:04] *** Quits: cubic (cubic@moz-FE5AD6C7.mc.videotron.ca) (Quit: Leaving)
[06:20:08] <mat1> aatch, klutzy: i did a make from within the llvm/ directory, and it seems to be compiling some stuff. 
[06:20:15] *** Quits: jdm (jdm@moz-99E0DB62.dsl.teksavvy.com) (Ping timeout)
[06:20:35] <aatch> mat1, that won't work
[06:21:00] <aatch> probably
[06:21:04] <aatch> actually, it might
[06:21:05] *** Quits: pnathan (Adium@moz-E3C3FAF2.hfc.comcastbusiness.net) (Ping timeout)
[06:22:17] <mat1> aatch: i'm not totally sure, but just giving it a shot
[06:23:44] *** Quits: dudedude (Mibbit@moz-412E7E04.ftqn1.win.bigpond.net.au) (Quit: http://www.mibbit.com ajax IRC Client)
[06:27:48] *** Joins: paupau (NEAT@moz-C616DA0A.hsd1.ca.comcast.net)
[06:30:46] <sfackler> did this build get wedged or what? http://buildbot.rust-lang.org/builders/auto-linux-64-opt-vg/builds/268
[06:31:25] <roo> is there a way to get two owned fields out of a structure without running into partial movement stuff?
[06:31:59] *** Joins: ghrust (ghrust@1E8607E8.6A2AE50.F3114085.IP)
[06:31:59] <ghrust> 01[13rust01] 15bors 04force-pushed 06auto from 14fa995b4 to 14dd4f6bb: 02http://git.io/N3iJvQ
[06:31:59] *** Parts: ghrust (ghrust@1E8607E8.6A2AE50.F3114085.IP) ()
[06:31:59] *** Joins: ghrust (ghrust@E7A4CCE2.6A2AE50.F3114085.IP)
[06:31:59] <ghrust> 01[13rust01] 15bors pushed 3 new commits to 06auto: 02http://git.io/G25eFg
[06:32:00] <ghrust> 13rust/06auto 14fd19289 15Seo Sanghyeon: Classify newtype structs S(T) as immediates if T is an immediate
[06:32:00] <ghrust> 13rust/06auto 148aa26ad 15Seo Sanghyeon: Fix dereference of temporary immediate newtype structs
[06:32:00] <ghrust> 13rust/06auto 14e07e9bb 15bors: auto merge of #7543 : sanxiyn/rust/newtype-immediates, r=catamorphism...
[06:32:01] <aatch> roo, are you wanting to move?
[06:32:02] *** Parts: ghrust (ghrust@E7A4CCE2.6A2AE50.F3114085.IP) ()
[06:32:23] <roo> yeah
[06:32:49] <aatch> Then you can use destructuring.
[06:33:10] <aatch> so let Foo { a: bar, b: baz, _ } = ...
[06:33:24] <roo> ah, ok.
[06:34:49] <paupau> it would be nice if we could have Maybe in the typesystem
[06:35:09] <paupau> like foo: ~Foo {a=null}
[06:35:15] *** Quits: jld (jld@moz-B94C75AD.xlerb.net) (Quit: unconfusing irssi)
[06:35:18] *** Joins: jld (jld@moz-B94C75AD.xlerb.net)
[06:35:30] <paupau> so you could pass that around with foo.a missing, and fill it in later
[06:35:47] <aatch> paupau, what, you mean Option?
[06:35:47] <paupau> I guess this is typestate territory huh?
[06:36:07] <paupau> like instead of Foo { a: Option<bar> } dynamically
[06:36:17] <aatch> paupau, yeah, no.
[06:36:22] <paupau> foo: ~Foo { a=none } statically
[06:36:34] *** Quits: hjr3 (hradtke@moz-E87BDF1F.socal.res.rr.com) (Quit: My MacBook has gone to sleep. ZZZzzzâ€¦)
[06:36:48] <strcat> bjz: one use case of ranges is a generic sort
[06:36:54] <strcat> our sorts right now are defined on vectors only
[06:36:58] <strcat> they could work on deque too
[06:37:06] *** Joins: pnkfelix (pnkfelix@87C1F78E.1DE10CA8.D8E68FF6.IP)
[06:37:11] <strcat> but deque isn't contiguous (despite having O(1) indexing) so it can't use slices
[06:37:23] <strcat> it needs the generic form of slices, with indexing/swapping methods
[06:37:33] <strcat> and the generic form of a slice is a RandomAccessRange ;p
[06:37:49] <aatch> It's too complicated for what is ultimately a very rare case.
[06:37:57] <strcat> aatch: it's not really that complicated
[06:38:03] <strcat> Iterator is already InputRange/ForwardRange
[06:38:09] <aatch> strcat, I was talking about the type stuff
[06:38:12] <strcat> aatch: oh!
[06:38:27] <aatch> Iterator's aren't particularly complicated.
[06:38:41] <paupau> aatch: yeah, type safety is a rabbit hole
[06:38:44] *** Quits: Nisstyre (wes@moz-FD86289.netflash.net) (Quit: Leaving)
[06:39:05] <paupau> next thing you know I'll be asking for dependent types
[06:39:08] <strcat> paupau: nmatsakis wants to add the ability to have subsets of enums, so that's one bit of the same capabilities
[06:39:21] <paupau> strcat: 
[06:39:21] <strcat> and you can hack together state changes with rust's safe RAII
[06:39:24] <paupau> oh cool
[06:39:43] <strcat> if it has a destructor and you convert to another type by-value, you're guaranteed there are no references left to the old
[06:39:54] <strcat> it's just often painful
[06:39:58] <paupau> right
[06:40:15] <strcat> the usual use of them is just OPEN|CLOSED
[06:40:18] <strcat> but you could add more states
[06:41:07] <strcat> paupau: http://smallcultfollowing.com/babysteps/blog/2012/08/24/datasort-refinements/ there's the post about it
[06:41:11] <strcat> likely post 1.0 I guess
[06:41:32] <mat1> does anyone know what this error is when compiling llvm for building rust?
[06:41:36] <paupau> strcat: thanks!
[06:41:37] <mat1> rust-0.7/llvm/x86_64-unknown-linux-gnu/Release+Asserts/lib/libLLVMTarget.a: file not recognized: File truncated
[06:42:04] <paupau> strcat: I ran into the exact same issue when working with exprs in another language
[06:42:38] <strcat> paupau: I run into the enum subset thing all the time, for example all these vector functions taking a 'heap' enum but only 3 kinds out of 5 are valid ;p
[06:42:57] <paupau> strcat: grr hate that! :)
[06:45:03] *** Quits: illissius (illissius@moz-19397A63.catv.broadband.hu) (Quit: )
[06:47:20] *** Joins: jviereck (Adium@moz-3584DA80.dynamic.eduroam.mwn.de)
[06:47:46] *** Joins: leaper (Mibbit@moz-3F91CDD9.dip0.t-ipconnect.de)
[06:47:56] *** Quits: leaper (Mibbit@moz-3F91CDD9.dip0.t-ipconnect.de) (Quit: http://www.mibbit.com ajax IRC Client)
[06:48:30] *** Joins: alisdair (textual@moz-EBE9F394.bchsia.telus.net)
[06:48:52] *** Quits: ross (ross@moz-8A84103E.br.br.cox.net) (Quit: )
[06:49:53] <strcat> 0.7 finally synced to most of the arch mirrors ;p
[06:50:08] <paupau> wondering if I should write a homebrew PR
[06:50:37] * strcat has all the editor/completion stuff included now
[06:50:42] <strcat> http://ix.io/6vd \o/
[06:50:53] <strcat> was in rust-git for a while though
[06:51:02] <dbaupp> cmr: ping
[06:51:12] <paupau> yay vimfiles
[06:51:22] <strcat> zsh completion :)
[06:51:30] <paupau> I have got to get into zsh
[06:51:37] * strcat doesn't have to remember the lint/debug flags anymore
[06:52:31] <roo> doesn't bash have similar functionality?
[06:52:38] <strcat> roo: not really
[06:52:41] <strcat> menu complete, for one
[06:52:46] <aatch> roo, not as good as zsh
[06:52:50] <roo> ah
[06:52:52] <strcat> roo: paupau: http://i.imgur.com/Djdyd6S.png
[06:53:07] <paupau> oh gosh
[06:53:20] <strcat> and built-in support for dir colors in completion, git info in your prompt, etc.
[06:53:23] <strcat> no manually hacking it together
[06:53:48] <roo> yeah ok. lol, bash definitely cant do that
[06:54:18] *** Joins: pyrac (pyrac@moz-C6037E0A.ghst.net)
[06:55:03] *** Quits: MrFahrenheit (RageOfThou@3FEF494C.29C984D5.783DEDCA.IP) (Ping timeout)
[06:55:18] *** Joins: doomlord (doomlod@moz-6651F8D4.range86-145.btcentralplus.com)
[06:57:57] *** Quits: yichoi (yichoi@5AB4884B.FCC4549.14D5B978.IP) (Connection reset by peer)
[06:58:12] <strcat> some of it is because zsh completion files are much better maintained than bash-completion
[06:58:33] <strcat> so there's better support for git, pkill, and random utilities
[06:59:24] *** Joins: yichoi (yichoi@5AB4884B.FCC4549.14D5B978.IP)
[07:00:17] *** Quits: mat1 (mat@579C1D31.DC7A989C.7F8AB798.IP) (Quit: good bye!)
[07:05:40] *** Quits: ivan (ivan@moz-531C3EC9.members.linode.com) (Ping timeout)
[07:05:40] *** Quits: jroll (jroll@moz-5989BB9E.members.linode.com) (Ping timeout)
[07:05:40] *** Quits: cade (cadecairos@moz-DB3BF95F.members.linode.com) (Ping timeout)
[07:05:52] *** Quits: hoelzro (hoelzro@moz-937642A5.ro) (Ping timeout)
[07:05:52] *** Quits: petantik (oz@moz-20EC2160.net) (Ping timeout)
[07:05:53] *** Joins: hoelzro (hoelzro@moz-937642A5.ro)
[07:06:03] *** Quits: bstrie (ben@moz-D5A1D0F5.members.linode.com) (Ping timeout)
[07:06:03] *** Quits: reed (reed@tech.monkey) (Ping timeout)
[07:06:03] *** Joins: petantik (oz@moz-20EC2160.net)
[07:06:05] *** Joins: bstrie (ben@moz-D5A1D0F5.members.linode.com)
[07:06:10] *** Joins: jroll (jroll@moz-5989BB9E.members.linode.com)
[07:06:16] *** Joins: cadecairos (cadecairos@moz-DB3BF95F.members.linode.com)
[07:06:23] *** Joins: reed (reed@tech.monkey)
[07:06:56] *** Joins: ivan (ivan@moz-531C3EC9.members.linode.com)
[07:08:35] *** Joins: MaikKlein (maik@moz-51F0F9C8.dip0.t-ipconnect.de)
[07:12:24] *** Quits: doomlord (doomlod@moz-6651F8D4.range86-145.btcentralplus.com) (Ping timeout)
[07:13:42] *** Quits: jviereck (Adium@moz-3584DA80.dynamic.eduroam.mwn.de) (Quit: Leaving.)
[07:16:03] *** Quits: MaikKlein (maik@moz-51F0F9C8.dip0.t-ipconnect.de) (Ping timeout)
[07:16:36] <Eridius> fish-shell is best shell
[07:19:10] *** Quits: alisdair (textual@moz-EBE9F394.bchsia.telus.net) (Quit: My MacBook Pro has gone to sleep. ZZZzzzâ€¦)
[07:22:01] *** Quits: geomyidae (geomyidae@DD6F7E3A.21468E9A.30200F38.IP) (Client exited)
[07:23:17] *** Joins: Voomer__ (Voomer@moz-E97E8EB7.br.br.cox.net)
[07:23:17] *** Quits: Voomer_ (Voomer@moz-E97E8EB7.br.br.cox.net) (Connection reset by peer)
[07:25:48] <joelteon> eww gross
[07:26:32] <strcat> Eridius: it has much nicer defaults, but I don't really like it ;p
[07:28:12] * strcat has wasted the requisite time configuring zsh already
[07:28:15] <joelteon> yeah, my zsh does what fish does
[07:28:23] *** Joins: MaikKlein (maik@moz-51F0F9C8.dip0.t-ipconnect.de)
[07:28:59] <mcpherrin> Does anybody else find zsh slow?
[07:29:12] <mcpherrin> Maybe it's just something in my config... but it ain't as perky as I'd like
[07:29:30] <joelteon> I don't, it's probably something in your config
[07:29:37] <joelteon> I doubt basic zsh is noticeably slow
[07:30:03] *** Joins: Ms2ger (Ms2ger@moz-12E1F766.adsl-dyn.isp.belgacom.be)
[07:30:03] <mcpherrin> Especially on OS X -- a linux machine with the same config never really had issues.
[07:31:18] <strcat> mcpherrin: it actually runs a bit faster than bash, scripts at least
[07:31:24] <strcat> bash/zsh are both pretty slow
[07:31:37] <mcpherrin> I've been tempted to try and write a shell in rust
[07:31:38] <strcat> but there are big costs to things like git in a prompt
[07:31:43] <mcpherrin> (but I have more urgent things to do)
[07:32:01] <strcat> mcpherrin: it's annoying :(, all the syscalls and plumbing stuff means writing bindings
[07:32:05] <strcat> and lots is varargs
[07:32:38] * strcat didn't try writing a shell, but other things dealing with signals and stuff
[07:32:43] <mcpherrin> I'll stick to writing video games for fun for now :)
[07:35:06] <strcat> we do have a terminfo parser now though...
[07:36:18] *** Quits: MaikKlein (maik@moz-51F0F9C8.dip0.t-ipconnect.de) (Ping timeout)
[07:39:33] *** Joins: Blub\w (wry@7E3BB9D.71150E1A.237AE2BA.IP)
[07:41:08] *** Joins: gour (gour@moz-71E9D123.adsl.net.t-com.hr)
[07:41:55] *** Quits: wilsonk|2 (kvirc@moz-39EFBFC2.cg.shawcable.net) (Ping timeout)
[07:42:27] *** Quits: cdidd (cdidd@moz-80CE443B.broadband.corbina.ru) (Input/output error)
[07:46:10] *** Joins: BizarreCake (BizarreCak@51AA6B33.6D202491.34A7550B.IP)
[07:46:15] *** Joins: taylanub- (taylanub@moz-5D69E26C.dip0.t-ipconnect.de)
[07:46:22] *** taylanub- is now known as taylanub
[07:47:47] *** Quits: snadon (chatzilla@moz-3BC727E8.mc.videotron.ca) (Ping timeout)
[07:49:23] <taylanub> Is the `return' here redundant ?:  fn signum(x: int) -> int { if x < 0 { -1 } else if x > 0 { 1 } else { return 0 } }
[07:49:40] <strcat> taylanub: yeah, it's for early returns
[07:50:17] <taylanub> What do you mean .. is it in this case the same as leaving it out, or not ?..
[07:50:28] <Ms2ger> It is
[07:50:30] <strcat> taylanub: the same as not having it because it's the last expression
[07:50:55] <aatch> I sometimes use returns at the end when it would otherwise mean having a single-letter at the end.
[07:51:04] <aatch> so return t; instead of just t
[07:51:32] <aatch> In other news, it seems that ~Traits work well enough at the moment.
[07:51:43] <strcat> aatch: til I break them
[07:51:54] <strcat> or you can break them, if you finish that branch ;p
[07:52:15] * strcat doubts they are well tested
[07:52:31] <aatch> strcat, well if you break them, you'll break the compiler, since I'm using them for target info.
[07:52:36] <taylanub> Hrm, what exact kind of syntax is `return' ?  E.g. does it not theoretically have its own value as well, which would contradict with the values in the other if branches ?
[07:52:48] <taylanub> I guess I'm thinking too much in Scheme. :P
[07:52:51] <strcat> taylanub: there's an implicit 'bottom' type
[07:53:12] <taylanub> strcat: OK, but then wouldn't that be a type-error wrt. the other if branches ?
[07:53:40] <strcat> taylanub: well the bottom type can never actually be created, and it's usable as any type
[07:53:49] <aatch> taylanub, nope, bottom is a super-type of all types
[07:53:59] <taylanub> OK.
[07:53:59] <strcat> taylanub: for example you can write
[07:53:59] <dbaupp> taylanub: no, every type is a "subtype" of ! and that is a subtype of bottom
[07:54:02] <strcat> fn foo() -> !
[07:54:07] <strcat> and that's a function that will never return
[07:54:19] <strcat> rusti: let x = if true { 5 } else { fail!() }
[07:54:20] -rusti- <anon>:8:4: 8:5 error: expected `;` but found `}`
[07:54:20] -rusti- <anon>:8     };
[07:54:20] -rusti-              ^
[07:54:21] -rusti- application terminated with error code 101
[07:54:22] <strcat> rusti: let x = if true { 5 } else { fail!() }; x
[07:54:23] -rusti- 5
[07:54:24] <roo> bottom is on top!
[07:54:25] <taylanub> Is evaluating to ! an error or whta ?
[07:54:37] <strcat> rusti: fn foo() -> ! { fail!() } let x = if true { 5 } else { foo() }; x
[07:54:38] -rusti- 5
[07:54:48] <strcat> taylanub: well it means it never returns, it's diverging
[07:54:59] <strcat> there's a bug open about using a real type for this
[07:55:21] <taylanub> WDYM diverging ?
[07:55:21] <strcat> taylanub: https://github.com/mozilla/rust/issues/7538?source=cc
[07:55:34] <strcat> taylanub: control flow "diverges" and never returns
[07:55:41] <taylanub> Ah OK.
[07:55:44] <strcat> it exits or fails (unwinds to the parent task), basically
[07:56:06] <taylanub> Could also loop infinitely I guess ?
[07:56:07] <aatch> strcat, but theoretically it could also do a non-local jump.
[07:56:13] <aatch> taylanub, correct
[07:56:29] <taylanub> "What if it returns ?"
[07:56:40] <strcat> taylanub: well it can't, rustc will prevent it
[07:56:48] <taylanub> Ah..
[07:57:14] <strcat> taylanub: this is mostly about making sure all branches return a valid value, the concept of bottom/diverging lets you understand something like an infinite loop
[07:57:16] <strcat> so you can write...
[07:57:29] <taylanub> I see, so control-flow operators have type ! (among maybe other things).
[07:57:49] *** Joins: Jesin (Jessin_@moz-3AD6F09F.res.lehigh.edu)
[07:57:52] <strcat> taylanub: well, if you use 'loop {}' it has to check if there's a break
[07:57:57] <aatch> taylanub, well `if` is an expression
[07:58:17] <taylanub> OK, *some* control-flow operators have type !. :P
[07:58:19] <strcat> taylanub: if there's no break, it knows it's an infinite loop or returns/exits directly from it
[07:58:28] <taylanub> (OK scrap that, was meaningless.)
[07:59:14] <aatch> taylanub, try not to think too hard about `!`, it's a convenience first-and-foremost.
[07:59:31] <strcat> rusti: fn foo(f: &fn() -> bool) -> int { loop { if f() { return 5; } } }
[07:59:32] -rusti- ()
[07:59:39] <strcat> if you add a break though
[07:59:44] <strcat> rusti: fn foo(f: &fn() -> bool) -> int { loop { if f() { break; } } }
[07:59:45] -rusti- <anon>:7:43: 7:69 error: mismatched types: expected `int` but found `()` (expected int but found ())
[07:59:45] -rusti- <anon>:7          fn foo(f: &fn() -> bool) -> int { loop { if f() { break; } } }
[07:59:45] -rusti-                                                     ^~~~~~~~~~~~~~~~~~~~~~~~~~
[07:59:45] -rusti- error: aborting due to previous error
[07:59:46] -rusti- application terminated with error code 101
[07:59:53] <strcat> rusti: fn foo(f: &fn() -> bool) -> int { loop { if f() { break; } } 2 }
[07:59:54] -rusti- ()
[08:00:06] *** Joins: doomlord (doomlod@moz-6651F8D4.range86-145.btcentralplus.com)
[08:00:52] *** Quits: gour (gour@moz-71E9D123.adsl.net.t-com.hr) (Ping timeout)
[08:01:01] *** Quits: jaen (jaen@moz-E0979827.copit.pl) (Connection reset by peer)
[08:01:25] *** Joins: gour (gour@moz-71E9D123.adsl.net.t-com.hr)
[08:01:27] *** Joins: jaen (jaen@moz-E0979827.copit.pl)
[08:01:40] <strcat> anyway rustc should know that 'enum Foo {}' can't be created, and let it be usable instead of needing !
[08:01:43] <taylanub> Is there a technical reason that braces are mandated for if, when, etc., or is it just for getting rid of the choice ?
[08:02:02] <strcat> taylanub: do you mean why you can't omit them like C?
[08:02:12] <strcat> taylanub: C requires () around the condition part to let you omit them
[08:02:20] <strcat> so Go and Rust require braces always instead
[08:02:32] <taylanub> Huh .. why not just take two expressions ?
[08:02:40] <taylanub> if <expr> <expr>
[08:02:40] <aatch> taylanub, it would be ambiguous
[08:02:47] <strcat> taylanub: think about else
[08:02:57] <aatch> you need a way of separating the expressions.
[08:03:05] <taylanub> if <expr> <expr> else <expr>
[08:03:23] <strcat> taylanub: https://en.wikipedia.org/wiki/Dangling_else
[08:03:29] <taylanub> Does an expression not clearly have a beginning and an end ?
[08:03:39] *** Joins: pnathan (Adium@moz-E3C3FAF2.hfc.comcastbusiness.net)
[08:03:45] <strcat> taylanub: well the else thing is unrelated
[08:03:52] <aatch> taylanub, not always
[08:04:17] <roo> (foo)(bar) can be parsed as one or 2 expressions
[08:04:22] <roo> for instance
[08:04:35] <aatch> a + b - 1
[08:04:51] *** Joins: z0w0 (zack@moz-C7366B37.lns11.cha.bigpond.net.au)
[08:05:09] <strcat> roo: hm, when is it two?
[08:05:18] <taylanub> OK, but does that really require mandating parens or braces ?  AFAIK Ruby does it without both.
[08:05:24] <strcat> roo: oh I see what you mean
[08:05:25] *** Quits: pnathan (Adium@moz-E3C3FAF2.hfc.comcastbusiness.net) (Ping timeout)
[08:05:37] <strcat> taylanub: ruby has an 'end' marker
[08:05:46] <strcat> python uses whitespace
[08:05:54] <strcat> haskell lets you choose whitespace or {} (everyone uses whitespace)
[08:06:20] <Ms2ger> Maybe rust should go with whitespace too ;)
[08:06:27] <roo> :DD
[08:06:44] <aatch> Yeah... no. white-space sensitivity sucks
[08:06:47] <strcat> #[significant_whitespace]; // ;p
[08:07:03] <strcat> aatch: haskell style is okay
[08:07:30] <Ms2ger> Everyone in their right mind enforces significant whitespace anyway
[08:08:04] <strcat> the evalbot would be useless ;p
[08:08:23] <taylanub> Is there a comma operator like in C BTW ?
[08:08:27] <aatch> Ms2ger, but sometimes I want to indent differently.
[08:08:29] <strcat> taylanub: no
[08:08:31] <aatch> taylanub, no
[08:08:36] <Ms2ger> taylanub, no
[08:08:41] * Ms2ger jumps on the train
[08:08:46] <dbaupp> taylanub, no it's not necessary, since you can just use a full-blown block
[08:08:48] <taylanub> COMBO 3X
[08:08:58] <taylanub> dbaupp: Yeah, wondered due to that.
[08:09:01] <aatch> we have block exprs instead
[08:09:09] <aatch> which are way more awesome.
[08:09:13] <taylanub> Rust should use () instead of {} and whitespace instead of ;  ;P
[08:09:17] <Ms2ger> aatch, but if I have to read your code, *I* don't want you to indent differently ;)
[08:09:41] <strcat> taylanub: well whitespace could eliminate both {} and ;
[08:09:48] <aatch> Ms2ger, but I normally do it to make it easier to read.
[08:10:15] <aatch> it sounds fine on the surface, but what about lining up alternate cases in a match arm?
[08:11:18] <strcat> taylanub: http://ix.io/6vf if it used significant whitespace ;p
[08:11:44] <taylanub> Hrm, perhaps Rust could've went with sweet-expression like syntax if looking like C is so important, thus still have zero inconsistencies and ambiguities .. I really find it a shame that it's just "yet another C syntax", but oh well, I'm lamenting for no returns.
[08:11:49] <Ms2ger> strcat, doesn't that look nice? ;)
[08:11:51] <taylanub> My lamenting has type !. :(
[08:12:01] <strcat> Ms2ger: until you want closures
[08:12:18] <strcat> where does the function body go when you use a closure as an expr?
[08:12:22] <Ms2ger> Mm
[08:12:41] <aatch> also, rust is a pretty simple grammar.
[08:13:00] <Ms2ger> Sure
[08:13:04] <aatch> pcwalton managed to reduce it down to like LL(4) or something
[08:13:06] <Ms2ger> Just not one I happen to like :)
[08:13:32] <taylanub> What's that ?
[08:13:35] <aatch> Ms2ger, until you need to grep for a function definition in a 2000-line file.
[08:13:43] *** Quits: doomlord (doomlod@moz-6651F8D4.range86-145.btcentralplus.com) (Ping timeout)
[08:13:52] <strcat> taylanub: the parsing complexity
[08:13:58] <aatch> taylanub, how many tokens of lookahead needed for an unambiguous parse
[08:14:07] <strcat> for example parsing C++ is turing complete :D
[08:14:15] <aatch> if we didn't have `match` it'd be LL(1)
[08:14:21] <strcat> as in... the parser can run forever (actually forever)
[08:14:33] <Ms2ger> Getting Turing complete isn't that hard
[08:14:36] <strcat> assuming infinite memory, and finite file size
[08:14:41] <taylanub> strcat: Sure that's not the whole compiler ?
[08:15:00] <aatch> strcat, or even better, fail to parse or not based on whether or not a given value is prime.
[08:15:28] <strcat> taylanub: type checking is definitely turing complete, but I think some of the parsing needs type checking
[08:15:31] <taylanub> Is this really re. parsing, or compiling (templates) ?
[08:15:41] <strcat> taylanub: you need types to parse it though due to ambiguity
[08:15:44] <strcat> taylanub:  http://stackoverflow.com/a/14589567/1009916
[08:15:48] <aatch> taylanub, in C++, you can't make a strong distinction
[08:15:50] <taylanub> Ah OK.
[08:16:15] <strcat> C++ also can't be tokenized
[08:16:20] <strcat> I'm serious
[08:16:35] <dbaupp> aatch: apparently he actually got to LL(1) https://mail.mozilla.org/pipermail/rust-dev/2013-April/003764.html :D
[08:16:36] *** Joins: Pengoo (Jackson@moz-30109EF1.vf.shawcable.net)
[08:16:42] *** Quits: Pengoo (Jackson@moz-30109EF1.vf.shawcable.net) (Quit: KVIrc 4.1.3 Equilibrium http://www.kvirc.net/)
[08:17:06] *** Joins: jensnockert (jensnocker@moz-C5F27039.cust.bredband2.com)
[08:17:07] <aatch> dbaupp, awesome
[08:17:16] <strcat> the grammar is exposed via macros so that's why it might be better to not do that
[08:17:19] <strcat> afaik
[08:17:42] <dbaupp> (I don't know how he got around the things that were blocking k = 1.)
[08:18:04] <aatch> dbaupp, terrible hacks :D
[08:18:06] <taylanub> BTW I looked into Rusp and apparently it isn't really s-expression syntax for Rust itself, but rather a sub-language.
[08:18:14] <dbaupp> aatch: as always :D
[08:18:28] <aatch> taylanub, correct
[08:18:54] <dbaupp> taylanub: (also, a mostly abandoned one)
[08:19:00] <aatch> that too
[08:19:03] <taylanub> Has anyone attempted sexp-based Rust, as a parallel to the lexical-grammar/AST ?
[08:19:32] <aatch> taylanub, not as far as I know. What's the point?
[08:19:47] <taylanub> The point is sexps. :P
[08:20:18] <aatch> taylanub, but sexps aren't actually very good. Unless you absolutely need LISP-level macros
[08:20:44] <taylanub> Actually with Paredit I find them the best format for writing code.
[08:20:59] <taylanub> Or any data, for that matter.
[08:21:30] <aatch> taylanub, personal preference though. I find sexprs incredibly limiting.
[08:21:37] <strcat> taylanub: when syntax extensions become pluggable you can just write one and wrap your whole program in it ;p
[08:21:55] <taylanub> strcat: It will probably be limited on the lexical level ?
[08:21:55] <strcat> and scare away every contributor :D
[08:21:56] <aatch> I like the _idea_ of homoiconic languages, but the praticality of it?
[08:21:59] * roo counts the seconds
[08:22:10] <strcat> taylanub: well syntax exts are passed a token tree and have to make a valid AST
[08:22:21] <taylanub> aatch: I wouldn't comment before trying out Paredit for at least 2 weeks.
[08:22:28] <strcat> rusti: fmt!("%d %s", 5, 5)
[08:22:29] -rusti- more than 5 lines of output, pastebinned: http://sprunge.us/iJEC
[08:22:29] <aatch> taylanub, I have
[08:22:34] <strcat> that's one
[08:22:41] <strcat> it makes a little format string DSL
[08:22:55] <strcat> although that's boring because a string is 1 token ;p
[08:23:12] *** Joins: CarpNet (ac@moz-FD24B77.sohonet.co.uk)
[08:23:16] <taylanub> aatch: Paredit ?  How long have you used it ?
[08:23:37] <aatch> I don't use it any more, but when I was learning lisp, I used it.
[08:23:41] <aatch> so 2-3 weeks
[08:24:21] <aatch> But my point isn't editing or writing with them, it the fact that you end up so much noise
[08:24:26] *** Quits: strcat (strcat@moz-54F7FD49.cpe.net.cable.rogers.com) (Quit: sleep)
[08:25:04] <aatch> lisps only work because they are predominantly dynamic
[08:25:24] <taylanub> Unless you missed out on C-M-u/d/f/b/k and C-k and such, I can't really understand why one wouldn't appreciate Paredit.
[08:25:37] <taylanub> aatch: I don't think that has anything to do with the syntax ...
[08:25:59] <aatch> taylanub, but it does. the problem is that sexpr isn't syntax
[08:26:33] <taylanub> So what makes a usual AST better for static-typing than a binary tree ?
[08:27:14] <taylanub> (Rust doesn't do anything with types before generating the AST, right ?)
[08:29:24] <aatch> taylanub, if I want to write a generic function with bounded type parameters, then an S expr would look something like (fn foo ((T Bound1 Bound2) (U Bound3 Bound4)) ((arg1 (list T)) (arg2 U)) (Ret) ( ...body... ))
[08:30:22] <aatch> which in rust is fn foo<T:Bound1+Bound2,U:Bound3+Bound4>(arg1: &[T], arg2: U) -> Ret { ... }
[08:31:49] <taylanub> Guess which I find nicer. :P
[08:32:27] <Ms2ger> The latter? :)
[08:32:31] <aatch> taylanub, but there's no visual context
[08:33:07] <aatch> where what makes type parameters different to arguments different to the return type
[08:33:12] <aatch> ?
[08:33:18] <aatch> Other than the position.
[08:33:45] <aatch> and that's a simple case.
[08:33:47] *** Joins: pnathan (Adium@B9840254.2CD8A5F8.477B877D.IP)
[08:33:57] <roo> (which itself isn't immediately obvious when looking at a deeply nested part of that)
[08:33:59] *** Joins: jpochyla (jpochyla@moz-8D99AE5D.broadband18.iol.cz)
[08:33:59] <aatch> what about adding `~` and `&` in.
[08:34:00] <taylanub> I don't see a problem with the positions ..
[08:34:14] <aatch> and then `mut` on top of that.
[08:34:23] <paupau> dohoho
[08:35:15] <aatch> with S-exprs I would have to write out (tuple a b), to use tuples
[08:36:03] <aatch> lisps all share the strength and weakness that comes with not having any syntax.
[08:36:21] <aatch> because s-expressions aren't a syntax, they are writing out an AST
[08:36:38] <taylanub> (Not exactly an AST AFAIK, but yes.)
[08:37:18] <rubber-duck> if I have mut object I can't call any methods that take &self (immutable ref)  ?
[08:37:32] <aatch> rubber-duck, you can.
[08:37:38] <rubber-duck> *mut ref
[08:37:52] <rubber-duck> ie. let foo: &MyType
[08:37:56] <rubber-duck> ie. let foo: &mut MyType
[08:38:02] <taylanub> If you want brevity, I guess you can use sweet-expressions and reader extensions, although whether the verbosity is problematic is also a matter of opinion ...
[08:38:19] <rubber-duck> I get "error: cannot borrow `scanner` as immutable because it is also borrowed as mutable"
[08:39:03] <aatch> rubber-duck, ah, that's because somebody else borrowed it as mutable. and that borrow is still alive when you're trying to do the second borrow.
[08:39:23] *** Joins: int3_ (int3_@moz-ABE52D50.hsd1.ca.comcast.net)
[08:39:25] <rubber-duck> aatch, I don't get it - why would that be illegal ?
[08:39:47] <rubber-duck> this is specific line "scanner.advance_and_push_token(3, token::Char(scanner.peek_char_with_offset(1).get()))"
[08:39:59] *** Quits: pnathan (Adium@B9840254.2CD8A5F8.477B877D.IP) (Ping timeout)
[08:40:23] <aatch> the first borrow is .advance_and_push_token
[08:40:28] <doener> rubber-duck: there's an open bug for that problem, nested calls aren't handled correctly
[08:40:42] <aatch> the other is .peek_char_with_offset
[08:40:53] <doener> https://github.com/mozilla/rust/issues/6268
[08:41:00] <aatch> they both last for the entire statement.
[08:41:08] <rubber-duck> aatch, yeah but peek_char_with_offset is done before advance_and_push_token is called 
[08:41:22] <rubber-duck> so it's probably a bug doener is talking about
[08:41:31] <aatch> rubber-duck, the borrow checker doesn't think so though, hence the bug
[08:41:31] <doener> rubber-duck: let tmp = token::Char(scanner...); scanner.advance_and_push_token(3, tmp); should work
[08:42:44] <rubber-duck> yep the let trick works
[08:43:00] *** Joins: doomlord (doomlod@moz-6651F8D4.range86-145.btcentralplus.com)
[08:43:49] <aatch> but it's because, with an overlapping borrow, the guarentee that data you think isn't going to change doesn't hold
[08:44:33] *** Parts: doomlord (doomlod@moz-6651F8D4.range86-145.btcentralplus.com) (Leaving)
[08:45:39] <aatch> example: a vector, without the guarantee the compiler gives you, you can get a dangling reference if something causes the the vector to be re-allocated
[08:45:51] <rubber-duck> aatch, I can see how that would be a problem if peek_char_with_offset returned a reference to self members but it returns a value 
[08:46:10] <aatch> rubber-duck, it's bug, you borrow the scanner and that borrow lasts for the entire statement.
[08:46:16] <aatch> it shouldn't
[08:46:16] *** Joins: doomlord_ (servitor@moz-6651F8D4.range86-145.btcentralplus.com)
[08:46:59] <aatch> I'm just explaining why overlapping borrows are illegal to start with.
[08:47:29] <paupau> that borrowing-within-parameter bug is really annoying
[08:47:34] *** Joins: lucian (lucian@6B2B4644.4304AE1E.CE5E78F6.IP)
[08:48:36] <aatch> paupau, I rarely encounter it.
[08:48:57] <aatch> it actually seems like a code-smell to me
[08:49:31] <paupau> I had some code earlier like vec.grow(vec.size()) and it was unhappy
[08:49:54] <paupau> had to let n: uint outside, quite silly
[08:50:10] *** Joins: Sindwiller (sindwiller@moz-743130B2.dynamic.hispeed.ch)
[08:50:44] <aatch> paupau, that suggests to me that you need some method that grows to vec.size() when you call it.
[08:50:58] *** Parts: vk (vk@moz-389FEE13.hsd1.ca.comcast.net) ()
[08:50:59] <aatch> I mean, vec already has that information
[08:51:27] <paupau> interesting perspective
[08:51:56] <paupau> don't you feel like that would bloat the impl with all sorts of self-referential methods though
[08:52:30] *** Joins: davbo (dave@moz-3FFA637C.oucs.ox.ac.uk)
[08:52:39] <aatch> paupau, not really. especially if that's a common occurence.
[08:52:48] <paupau> such is the magic of traits I suppose
[08:53:36] *** Quits: fabiand (fabiand@moz-EDBC4C50.adsl.alicedsl.de) (Quit: Verlassend)
[08:53:45] *** Quits: indirect (indirect_m@moz-22FDA25B.hsd1.ca.comcast.net) (Quit: ZNC - http://znc.in)
[08:54:02] <aatch> paupau, I've spent long enough coding to know that if I'm doing something that seems silly, I've made a design mistake somewhere.
[08:54:39] <aatch> sure there are some bugs that force it in Rust, like the expanded freeze
[08:55:13] <Sindwiller> ahoy, there hasn't been any advancement to syntactic sugar for a vector of different types sharing a common trait, has there? Like this: http://paste.ofcode.org/9ayk7x3taJ7tzWXWhhStQT (taken from Rust for Rubyists :P) I wouldn't know how much static/dynamic type inferrence would be needed etc., so I'm curious
[08:55:34] <Sindwiller> (ignore the b0rked indentation)
[08:55:47] <paupau> aatch: the fact that the let-expanded and let-inlined forms give different compiler outputs is very silly
[08:56:00] <aatch> paupau, they don't really
[08:56:11] <aatch> it's just the way the scopes work.
[08:56:25] <paupau> they don't give a different output?
[08:56:43] <aatch> paupau, not considerably, there are some slight differences
[08:56:51] <Sindwiller> (or am I just doing something wrong?)
[08:57:03] <paupau> aatch: go on
[08:57:24] <aatch> Sindwiller, there is no such sugar at this time.
[08:57:36] <Sindwiller> aatch: alright :S
[08:58:08] <aatch> paupau, oh, well temporaries have a different code path to actual variables during codegen
[08:58:10] *** Joins: fabiand (fabiand@moz-EDBC4C50.adsl.alicedsl.de)
[08:58:21] <aatch> so the real output is slightly different
[08:58:21] *** Joins: indirect (indirect_m@moz-22FDA25B.hsd1.ca.comcast.net)
[08:58:38] <aatch> but there's no practical difference.
[08:58:43] <paupau> aatch: right
[08:58:55] <paupau> aatch: besides the bug
[09:00:20] <aatch> paupau, depends on what you mean by "output", but without the bug the generated code would likely only differ in order-of-operations and debug info.
[09:00:49] <paupau> aatch: yeah that's all good
[09:01:05] <aatch> since functions are translated in evaluation order.
[09:01:19] <aatch> and LLVM wont waste time re-ordering for the hell of it.
[09:01:33] <aatch> (it will re-order if it thinks it's a good idea though)
[09:01:37] <doener> regarding method naming conventions, as_foo means to return a &foo, to_foo means to return a new Foo, both keeping "self" intact. Is there a convention for something that moves self into a new type?
[09:01:59] <aatch> doener, I don't think so.
[09:02:37] <doomlord_> it would have to deallocate the argument, how could that work
[09:02:53] <aatch> hmm... I'm not sure it makes sense.
[09:03:11] <aatch> doomlord_, that's fine, you can move into a method
[09:03:50] <doomlord_> moves.. from a ~T ? ... leaving a nullptr behind ? 
[09:04:02] <aatch> but I can only really think of trival cases where you wouldn't have to re-allocate.
[09:04:04] <doomlord_> or just moving a temporary
[09:04:08] <paupau> leaving noptr behind :)
[09:04:37] <aatch> doomlord_, well if you have `let a = ~T; a.movingmethod()` then `a` isn't usable after that.
[09:04:41] <doomlord_> .. if its just moving a temporary would that be functionaly the same as to_foo() ... but you want the ability to recycle memory perhaps
[09:05:02] <doomlord_> is that compile-time enforced - like freezing
[09:05:08] <aatch> doomlord_, it is
[09:05:19] <doomlord_> oh thats neat then
[09:05:52] <aatch> doomlord_, it's pretty much crucial for getting unique pointers to work properly
[09:05:56] <doener> not really any different from using a function argument with a type that's moved
[09:07:00] <doener> I hate it when I switch to a different virt desktop while compiling, only to discover a few minutes later that I made a stupid type
[09:07:02] <aatch> fn imove(self)
[09:07:05] <doener> s/type/typo/
[09:07:30] <aatch> doener, I do the same thing.
[09:07:38] <aatch> anyway, gotta go
[09:07:42] *** aatch is now known as aatch|gone
[09:10:39] *** Joins: abra (abra@DDE1A929.83700187.23255EC6.IP)
[09:10:47] <doener> hm, reducing "duplicate" allocas doesn't really help much with compile times it seems
[09:13:02] *** Joins: true_droid (Adium@moz-123FD9B8.beck.volia.net)
[09:15:32] *** Joins: Blei (philipp@moz-4E4B9A0A.ethz.ch)
[09:16:30] *** Quits: roo (jesse.rudo@moz-B7585E4C.dynamic.ip.windstream.net) (Ping timeout)
[09:16:54] <dbaupp> doener: the naming convention is (weakly) as = no allocations/copies (-> &'a foo), to = possible allocations (-> foo), into = consume self, no allocations (i.e. fn(self) -> foo)
[09:16:56] *** Joins: roo (jesse.rudo@moz-B7585E4C.dynamic.ip.windstream.net)
[09:19:54] <doener> dbaupp: thanks
[09:20:58] <doener> hm, yeah, 11k allocas gone from libsyntax, no difference in compile times
[09:21:09] *** Quits: abra (abra@DDE1A929.83700187.23255EC6.IP) (Quit: Textual IRC Client: www.textualapp.com)
[09:21:26] <dbaupp> it makes the IR nicer though, doesn't it?
[09:22:28] <doener> the removal is due to allocas being reused, so it's less, but potentially more confusing IR
[09:24:25] <dbaupp> how many allocas are there in total in l
[09:24:32] <dbaupp> ... ibsyntax?
[09:24:53] <doener> old.ll:66995
[09:24:53] <doener> new.ll:55607
[09:25:30] <doener> so far, I'm only reusing the temp allocas for function arguments and return values
[09:25:47] <dbaupp> not local variables yet?
[09:26:52] <doener> did the easy ones first
[09:27:41] <doener> hm, some retval ones are left... *sigh*
[09:29:11] *** kimundi is now known as zz_kimundi
[09:33:29] *** Joins: cdidd (cdidd@C8FD756B.6E9B9CA2.62D8163C.IP)
[09:34:45] *** Joins: q66 (q66@6EE9DE40.46454B5D.33AABD5F.IP)
[09:36:11] <paupau> when you reference a fn does rustc alloca a fnptr and then load that fn in and then call it with params?
[09:36:38] <paupau> or does it call the const fn binding directly?
[09:37:47] *** Joins: pnathan (Adium@moz-E3C3FAF2.hfc.comcastbusiness.net)
[09:38:44] *** Quits: z0w0 (zack@moz-C7366B37.lns11.cha.bigpond.net.au) (Client exited)
[09:38:56] <dbaupp> paupau: what do you mean by "reference"?
[09:38:58] *** Joins: z0w0 (zack@moz-C7366B37.lns11.cha.bigpond.net.au)
[09:39:09] <paupau> dbaupp: sorry, call
[09:40:05] *** Joins: SimonSapin (simon@88F51059.F3BBB17D.144F44FA.IP)
[09:40:38] <dbaupp> depends: for a function defined with `fn`, it's a plain call like C, for a closure; there's an environment pointer and a function pointer... i'm not exactly sure how that works.
[09:41:26] <dbaupp> (err, I suck at punctuation)
[09:41:59] <paupau> dbaupp: sounds sensible, thanks
[09:42:06] <paupau> so there are different IR generation paths then, good
[09:43:19] *** Quits: KindOne (KindOne@7D0DB6F0.E114B4AE.EC6A1518.IP) (Ping timeout)
[09:43:24] <mitsuhiko> wohoo. 0.7 is out \o/
[09:43:41] <mitsuhiko> where are the people i have to hug?
[09:43:49] *** Quits: pnathan (Adium@moz-E3C3FAF2.hfc.comcastbusiness.net) (Ping timeout)
[09:47:01] *** Joins: KindOne (KindOne@7D0DB6F0.E114B4AE.EC6A1518.IP)
[09:49:22] <paupau> whoa, where did .substr() go
[09:49:36] *** Joins: illissius (illissius@moz-3590251D.kabelnet.hu)
[09:50:11] <paupau> gotta slice now?
[09:52:33] <dbaupp> paupau: yeah
[09:52:52] <dbaupp> (pop quiz: what were the two arguments of .substr?)
[09:53:04] <paupau> these docs are confusing me... slice_chars() is slightly more strict than slice()?
[09:53:15] <paupau> (start, n) ?
[09:53:27] <dbaupp> what units?
[09:53:37] <paupau> uint I should hope
[09:53:38] *** Quits: jpochyla (jpochyla@moz-8D99AE5D.broadband18.iol.cz) (Ping timeout)
[09:53:39] <roo> float!?
[09:53:46] <paupau> F64?!?!
[09:53:51] <dbaupp> start = byte index, n = unicode char count
[09:54:02] <paupau> I see
[09:54:12] <mcpherrin> ^ that bit me more than once :P
[09:54:12] <paupau> messy
[09:54:19] <mcpherrin> stupid function
[09:54:27] <roo> glad it died.
[09:54:29] * mcpherrin sulks and kicks corpse of .substr
[09:54:44] <dbaupp> it was very confusing; almost all uses in the rust source were wrong, so I removed it. use `s.slice_from(start).slice_chars(0, n)` if you need a literal replacement
[09:54:53] <mitsuhiko> is "drop" still a keyword?
[09:54:57] <dbaupp> nope
[09:55:08] <dbaupp> rusti: let drop = 1; drop
[09:55:09] -rusti- 1
[09:55:16] <mitsuhiko> then the docs need updating
[09:55:38] <paupau> rusti: 'a' + (10 as u8)
[09:55:39] -rusti- <anon>:7:15: 8:5 error: mismatched types: expected `char` but found `u8` (expected char but found u8)
[09:55:39] -rusti- <anon>:7          'a' + (10 as u8)
[09:55:39] -rusti- <anon>:8     };
[09:55:39] -rusti- error: aborting due to previous error
[09:55:39] -rusti- application terminated with error code 101
[09:55:47] <paupau> oops
[09:55:49] <paupau> rusti: 'a' + (10 as char)
[09:55:50] -rusti- 'k'
[09:56:38] <dbaupp> rusti: let x = 5 as bool; (x, x == true)
[09:56:39] -rusti- (true, false)
[09:56:49] *** Joins: FrozenCow (FrozenCow@moz-B2DF4929.chello.nl)
[09:57:04] <paupau> i1 right
[10:00:35] <mcpherrin> rusti: let x=5 as bool; (x, x==true,x==false)
[10:00:36] -rusti- (true, false, false)
[10:00:41] <mcpherrin> love me some bools
[10:01:07] <mcpherrin> rusti: true as uint
[10:01:08] -rusti- 1
[10:01:44] <mitsuhiko> rusti: 1 && 3
[10:01:45] -rusti- <anon>:7:9: 7:15 error: binary operation && cannot be applied to type `<VI0>`
[10:01:45] -rusti- <anon>:7          1 && 3
[10:01:45] -rusti-                   ^~~~~~
[10:01:45] -rusti- error: aborting due to previous error
[10:01:46] -rusti- application terminated with error code 101
[10:02:19] *** zz_kimundi is now known as kimundi
[10:03:55] <dbaupp> cmr: http://huonw.github.io/isrustfastyet/mem/#648c5e9,ca835f4
[10:04:03] <cmr> perfect timing, I just woke up :p
[10:04:16] <cmr> also, pong
[10:04:55] *** Joins: MaikKlein (maik@moz-51F0F9C8.dip0.t-ipconnect.de)
[10:05:22] <doener> heh, that weirdness again... I'm seeing 10% slower builds than a week ago, yours are 10% faster
[10:06:05] *** Joins: BitPuffin (quassel@moz-49828767.cust.tele2.se)
[10:06:12] <cmr> dbaupp: the time.txt data isn't skewed
[10:06:14] <cmr> it's a separate run
[10:06:18] <cmr> that's why I provide it
[10:06:22] *** Quits: anri (solancile@moz-A1CFFAE5.hsd1.wa.comcast.net) (Quit: anri)
[10:06:45] <paupau> is there documentation of the rust stages?
[10:06:54] <cmr> paupau: it's standard self-hosting compiler
[10:07:00] <paupau> same as GCC huh
[10:07:06] <cmr> yup
[10:07:45] <cmr> stage0 is build with a snapshot, stage1 is build with the stage0 compiler, stage2 is built with the stage1 compiler, thus making a compiler compiled with the compiler source
[10:09:37] <doener> oh wait, the upper graph actually agrees with me
[10:10:21] <cmr> dbaupp: this is really nifty!
[10:11:17] *** Joins: Khady (Khady@moz-31F9D77E.khady.info)
[10:15:26] <cmr> Something between 6fcd8bf and 6a2ad08 caused a nasty memory regression
[10:15:35] <cmr> 100MB in pre-trans :\
[10:15:59] *** Joins: jpochyla (jpochyla@moz-8D99AE5D.broadband18.iol.cz)
[10:16:13] <cmr> Between 6a2ad08 and 040ac2a that is
[10:19:38] <doener> that would likely be something from dbaupp's vector cleanup
[10:19:59] <doener> i.e. #7487
[10:20:13] <doomlord_> is there an existing search tool (command line or online) .. i give it a function name (with wildcards), it tells me the path to that/ what trait its from etc
[10:20:34] <cmr> doomlord_: nope
[10:20:49] <doomlord_> i thought i could knock one up that scans the sources , looking for the nested blocks, and just spits out 1 line per function  with the full path
[10:21:05] <doomlord_> but i figured the doc tools might do better
[10:21:14] <cmr> I hope to have search functionality like that with the new rustdoc, but it'd of course only work with generated docs
[10:22:02] <doomlord_> i dont think i'd parse everything properly eg <args> ... just raw function names
[10:22:16] <cmr> I think a tool like that would be worthwhile
[10:22:17] <doomlord_> but should i just look into the doc tool
[10:22:41] <cmr> no, the existing rustdoc is broken and I'm nowhere near done with rustdoc2
[10:22:56] <doomlord_> almost a 'rust grep' 
[10:23:04] <doomlord_> scope-block aware grep
[10:23:39] <cmr> doomlord_: Actually, writing a "proper" tool that walks an AST might not be too hard...
[10:23:52] <doomlord_> working from the compiler source ?
[10:24:10] <cmr> right. the parser and AST walker are separate from the compiler proper, libsyntax
[10:24:45] *** Quits: Blei (philipp@moz-4E4B9A0A.ethz.ch) (Quit: WeeChat 0.4.1)
[10:24:50] <cmr> You'd just need to provide a single function for visit_fn, turn the span or node_id back into its name and pattern match on those
[10:25:29] <cmr> For example
[10:25:35] <doomlord_> i guess your rustdoc tool uses it then
[10:25:46] <cmr> See src/librustc/middle/lint.rs line 947 and 955
[10:25:56] <cmr> yup, https://github.com/cmr/rustdoc_ng/blob/master/main.rs#L27
[10:26:47] <cmr> I am using aatch's experimental ast visitor though, not the current one (the experimental one hasn't landed yet)
[10:27:51] <doomlord_> i've got similar simple parsers for nested block structures lying around in c++ for various graphics file formats, but should do this in rust really lol..
[10:28:26] <doomlord_> it would be nice to get a graph of traits aswell
[10:28:36] <doomlord_> but thats further down the line
[10:28:55] <cmr> that would fall under the scope of https://github.com/mozilla/rust/issues/558 I think
[10:29:31] <paupau> cmr: how do I get that to work in 0.7?
[10:29:35] <paupau> rename visit_new to visit?
[10:29:46] <paupau> I still get error: Visitor is not a trait
[10:29:57] <cmr> paupau: you'd need to rewrite https://github.com/cmr/rustdoc_ng/blob/master/visit.rs
[10:29:59] <paupau> oh, experimental visitor
[10:31:11] <cmr> nice thing about a trait-based visitor is you can keep state locally (by implementing the trait on a struct) rather than having to use a @mut Context everywhere
[10:31:51] <paupau> that's nice
[10:32:04] *** Quits: eevee (eevee@moz-58058235.evrt.wa.frontiernet.net) (Ping timeout)
[10:32:13] <paupau> um, would you happen to know where the Visitor trait went?
[10:32:18] <cmr> it doesn't exist
[10:32:24] <cmr> :p
[10:32:26] <paupau> doh
[10:32:37] <cmr> https://github.com/Aatch/rust/tree/new_visitor
[10:32:47] <paupau> oh wow I need sleep
[10:32:54] <paupau> that's exactly what you were talking about
[10:34:52] *** Joins: eevee (eevee@moz-58058235.evrt.wa.frontiernet.net)
[10:36:10] <thiez> cmr: that new visitor looks very nice
[10:36:26] <thiez> all the @ is gone :)
[10:39:11] <MaikKlein> yeah visitors are nice to extend functionality
[10:41:21] *** Quits: jpochyla (jpochyla@moz-8D99AE5D.broadband18.iol.cz) (Ping timeout)
[10:45:13] *** Quits: MaikKlein (maik@moz-51F0F9C8.dip0.t-ipconnect.de) (Ping timeout)
[10:45:19] <thiez> cmr: if/when the new visitor stuff works, could you do a blog post about it? I think it would be quite informative as it would explain an important part of the compiler as well as being a great example of traits and default methods.
[10:45:44] <cmr> thiez: sure
[10:46:04] *** Quits: paupau (NEAT@moz-C616DA0A.hsd1.ca.comcast.net) (Ping timeout)
[10:47:24] *** Quits: jensnockert (jensnocker@moz-C5F27039.cust.bredband2.com) (Input/output error)
[10:49:26] <doener> hm, I suspect the lack of lifetimes might make the alloca reuse even worse than the alloca proliferation
[10:49:51] <cmr> http://lwn.net/SubscriberLink/557073/8a30fef40c95575c/ 
[10:52:24] *** Joins: xazax (Mibbit@6655692F.3B222813.3F580572.IP)
[10:52:34] <xazax> hi
[10:53:12] <xazax> what's up with rust and purity? was cheking the parser and there are traces of pure functions
[10:53:27] <cmr> There shouldn't be
[10:53:30] <cmr> Where do you see that?
[10:53:37] <cmr> I thought I removed the last of them
[10:54:37] <xazax> pares,rs line 3490 parse_methid function
[10:54:39] <xazax> for instance
[10:54:52] <xazax> parser.rs*
[10:55:15] *** Joins: paupau (NEAT@moz-C616DA0A.hsd1.ca.comcast.net)
[10:55:15] *** Joins: donri (dag@moz-9BB61102.tbcn.telia.com)
[10:55:47] <xazax> and there is also a parse_fn_purity method
[10:55:58] <cmr> "purity" is still used in the compiler to distinguish regular functions/extern "C"/unsafe fn
[10:56:06] <cmr> but there is no concept of pure/impure
[10:56:23] <cmr> See ast.rs line 778
[10:58:08] <xazax> but is pure still a valid keyword?
[10:58:29] <xazax> I wondering because of this: else if self.eat_keyword(keywords::Pure) {
[10:59:17] <xazax> oh never mind I just read the next line
[10:59:31] <xazax> it warns about obsolete stuff :)
[10:59:58] <xazax> thanks for the clarification
[11:00:55] <cmr> that's odd
[11:02:10] <cmr> probably still around just to warn for the obsolete syntax
[11:02:18] <cmr> I thought I had removed it though
[11:02:21] <cmr> guess not :)
[11:07:03] *** Quits: paupau (NEAT@moz-C616DA0A.hsd1.ca.comcast.net) (Ping timeout)
[11:07:22] *** Quits: jaen (jaen@moz-E0979827.copit.pl) (Quit: WeeChat 0.4.1)
[11:07:29] *** Joins: jaen (jaen@moz-E0979827.copit.pl)
[11:08:07] *** Joins: novabyte (Instantbir@moz-3E0F9699.cable.virginmedia.com)
[11:08:46] *** Quits: Sindwiller (sindwiller@moz-743130B2.dynamic.hispeed.ch) (Quit: Konversation terminated!)
[11:09:40] *** Quits: int3_ (int3_@moz-ABE52D50.hsd1.ca.comcast.net) (Client exited)
[11:11:19] <SimonSapin> [a, b, ..rest] doesnâ€™t match when rest is empty?
[11:12:22] <ChrisMorgan> Why does the ``do`` keyword exist? It seems it's just syntax sugar to change ``foo(..., |...| { ... });`` into ``do foo(...) |...| { ... };``, right?
[11:12:38] <cmr> ChrisMorgan: that's exactly what it does
[11:12:39] <SimonSapin> ChrisMorgan: it is
[11:12:51] <cmr> ChrisMorgan: It's to allow certain things to look more flow-controlly
[11:12:59] <SimonSapin> and I think the final ; is not required either
[11:13:02] <cmr> (and also to help eliminate rightward drift of code)
[11:13:11] <cmr> For example, `do spawn { .... } `
[11:13:41] <ChrisMorgan> I started out by assuming it must *do* something and was then surprised that it actually didn't do anything but act as a glorified simple macro.
[11:14:11] <cmr> It's just sugar
[11:15:16] *** Joins: Blei (philipp@moz-1D7F398F.ethz.ch)
[11:15:40] <cmr> dbaupp: all new benchmarks will have commit_info.txt
[11:15:48] <cmr> As of dd4f6bb
[11:16:12] <ChrisMorgan> http://static.rust-lang.org/doc/extra/net_tcp.html#function-listen is wrong: it says the on_establish_cb callback takes no parameters; it takes one called internally kill_chan
[11:16:22] <thiez> let pure_ = 8; pure_
[11:16:27] <thiez> rusti: let pure = 8; pure
[11:16:29] -rusti- more than 5 lines of output, pastebinned: http://sprunge.us/JdHQ
[11:16:39] <cmr> ChrisMorgan: unsurprising, the docs are incomplete and wrong in many places :)
[11:16:40] <thiez> it still likes 'pure' as a keyword.
[11:17:26] <cmr> ChrisMorgan: (plus, the existing net and IO code is being ripped out and replaced wholesale, so it's unmaintained)
[11:17:47] <ChrisMorgan> cmr: what's happening with it? What direction is it heading?
[11:18:45] <cmr> ChrisMorgan: Being rewritten to work with the new scheduler (https://github.com/brson/rust/tree/io)
[11:19:00] <cmr> I don't know all the details, I'm not part of that work
[11:19:21] <thiez> 'This branch is 12236 commits ahead and 4 commits behind master' <- that's going to be a pain to merge :p
[11:19:22] <cmr> I don't think work has actually started on the new net/io code, so
[11:19:48] <cmr> thiez: well it's comparing to whatever is in brson's master branch, not mozilla/master
[11:20:00] <thiez> ah, never mind then
[11:20:33] *** Joins: bjz_ (brendanzab@B398BE78.F804C29E.D35A31DF.IP)
[11:20:51] *** Quits: bjz (brendanzab@B398BE78.F804C29E.D35A31DF.IP) (Connection reset by peer)
[11:24:10] *** Joins: sk (sk@1696E5A5.E92B26F8.78DD174B.IP)
[11:26:22] *** Joins: pnathan (Adium@moz-E3C3FAF2.hfc.comcastbusiness.net)
[11:31:00] *** Quits: z0w0 (zack@moz-C7366B37.lns11.cha.bigpond.net.au) (Client exited)
[11:32:20] *** Quits: pnathan (Adium@moz-E3C3FAF2.hfc.comcastbusiness.net) (Ping timeout)
[11:33:43] <taylanub> unknown OS type: OpenBSD ;_;
[11:33:54] <cmr> taylanub: it should be trivial to port
[11:34:16] <taylanub> Maybe I'll have an attempt when I have time.
[11:35:49] *** Joins: Ripp__ (quassel@moz-4BA27C60.hsd1.md.comcast.net)
[11:35:56] <rubber-duck> rusti: use std::num::strconv; strconv::from_str_common::<u8>("257", 10, false, false, false, strconv::ExpNone, false, true)
[11:35:57] -rusti- None
[11:36:10] <rubber-duck> rusti: use std::num::strconv; strconv::from_str_common::<u8>("300", 10, false, false, false, strconv::ExpNone, false, true)
[11:36:11] -rusti- Some(44)
[11:36:20] <rubber-duck> this seems inconsistent :\
[11:38:11] <cmr> "Returns `Some(n)` if `buf` parses to a number n without overflowing"
[11:38:13] <cmr> Sounds broken
[11:41:58] *** Joins: Earnestly (earnest@2A2BF8F5.321FA5E6.BFD1ABFD.IP)
[11:42:53] *** Joins: sebcrozet (Mibbit@moz-7FB6C00B.w193-252.abo.wanadoo.fr)
[11:43:16] <sebcrozet> What is the difference between the 'Clone' and 'Copy' trait?
[11:43:27] <dbaupp> cmr: (sorry, dinner, back now.)
[11:43:30] *** Joins: dwrensha (chatzilla@moz-DE44EA45.hsd1.pa.comcast.net)
[11:44:02] <dbaupp> cmr: I'm not actually using the time.txt for that, I don't think. (Not having regexes makes parsing it quite annoying.)
[11:44:21] <dbaupp> cmr: cool re commit_info.txt
[11:44:37] <cmr> sebcrozet: Copy is a kind inserted by the compiler for types which qualify, Clone is user-implementable and generic. I think there's semantic differences, but I don't know them :)
[11:45:04] <dbaupp> (it'd be neat to add it to the other ones, just for consistency, `for f in *; do ( cd ~/rust; git show -s --format="%an %aE%n%at%n%s" $f; ) > $f/commit_info.txt; done` seems to work.)
[11:45:07] *** Quits: Earnestly (earnest@2A2BF8F5.321FA5E6.BFD1ABFD.IP) (Quit: WeeChat 0.4.2-dev)
[11:45:24] <sebcrozet> cmr: So it is "better" to use Clone instead of Copy as a type bound instead of Copy?
[11:45:33] <dbaupp> doener: are methods trans'd worse than functions?
[11:45:40] <cmr> sebcrozet: I do not know.
[11:45:57] <cmr> sebcrozet: afaik Copy is either deprecated or going to be.
[11:45:59] <sebcrozet> cmr: ok. Thanks.
[11:46:25] *** Joins: Earnestly (earnest@2A2BF8F5.321FA5E6.BFD1ABFD.IP)
[11:46:35] <cmr> dbaupp: done
[11:47:00] <SimonSapin> rusti: mod a{extern mod extra;use extra::json;}
[11:47:01] -rusti- <anon>:7:36: 7:47 warning: unused import [-W unused-imports (default)]
[11:47:01] -rusti- <anon>:7          mod a{extern mod extra;use extra::json;}
[11:47:02] -rusti-                                              ^~~~~~~~~~~
[11:47:02] -rusti- ()
[11:47:02] <dbaupp> sebcrozet: Using Clone is more flexible, since there are some Clone things that aren't Copy (and can't be), but everything that is Copy is Clone (or should be)
[11:47:18] <dbaupp> cmr: cool :)
[11:47:37] *** Parts: SimonSapin (simon@88F51059.F3BBB17D.144F44FA.IP) ()
[11:47:40] *** Joins: SimonSapin (simon@88F51059.F3BBB17D.144F44FA.IP)
[11:47:43] <cmr> Could there be an impl<T: Copy> Clone for T { ... } ? Although I think that'd conflict with user-defined clone impls :\
[11:48:15] <dbaupp> yeah, that would be "incoherent" in the typesystem at the moment
[11:48:27] <sebcrozet> dbaupp: do you have a exemple of something Copiable but not Clonable?
[11:48:41] <dbaupp> no
[11:48:54] <sebcrozet> dbaupp: and Clonable but not Copiable?
[11:48:56] <bjz_> sebcrozet: use Clone, not Copy.
[11:49:10] <bjz_> sebcrozet: is the basic answer
[11:49:19] <sebcrozet> bjz_: ^^ ok
[11:49:27] <bjz_> sebcrozet: foo.clone(), not copy foo
[11:49:27] <dbaupp> sebcrozet: for that one, I think e.g. Chan's might be Clone but not copy.
[11:49:57] <dbaupp> rusti: let (p,c) = std::comm::stream::<int>(); copy c
[11:49:59] -rusti- more than 5 lines of output, pastebinned: http://sprunge.us/cZaU
[11:50:14] <dbaupp> rusti: let (p,c) = std::comm::stream::<int>(); c.clone()
[11:50:15] -rusti- <anon>:7:49: 8:5 error: type `std::comm::Chan<int>` does not implement any method in scope named `clone`
[11:50:15] -rusti- <anon>:7          let (p,c) = std::comm::stream::<int>(); c.clone()
[11:50:15] -rusti- <anon>:8     };
[11:50:15] -rusti- error: aborting due to previous error
[11:50:15] -rusti- application terminated with error code 101
[11:51:07] <dbaupp> rusti: let (p,c) = std::comm::stream::<int>(); std::comm::SharedChan::new(c).clone()
[11:51:09] -rusti- <anon>:7:14: 7:15 warning: unused variable: `p` [-W unused-variable (default)]
[11:51:09] -rusti- <anon>:7          let (p,c) = std::comm::stream::<int>(); std::comm::SharedChan::new(c).clone()
[11:51:09] -rusti-                        ^
[11:51:09] -rusti- {ch: {x: {data: (0x7fc100201b40 as *())}}}
[11:51:18] <dbaupp> rusti: let (p,c) = std::comm::stream::<int>(); copy std::comm::SharedChan::new(c)
[11:51:19] -rusti- more than 5 lines of output, pastebinned: http://sprunge.us/VYAY
[11:51:25] <sebcrozet> dbaupp: Ok. The difference seems to be very small though. Iâ€™ll use Clone anyway.
[11:53:33] *** Joins: gavinb (gavinb@moz-9EC182F0.lowrp3.vic.optusnet.com.au)
[11:58:37] *** Joins: jdm (jdm@moz-99E0DB62.dsl.teksavvy.com)
[12:00:01] *** Joins: cubic (cubic@moz-FE5AD6C7.mc.videotron.ca)
[12:00:56] <dbaupp> cmr: also, I pinged you to ask if you could possibly run the benchmarker on some older commits... since it's presumably sitting doing nothing, and more data is always good :)
[12:01:42] <cmr> dbaupp: I am running it on some of the PRs I missed now
[12:01:46] <cmr> any in particular you want?
[12:01:52] <dbaupp> no not really
[12:02:03] <dbaupp> but it'd be awesome to get a historical view
[12:02:11] <cmr> sure
[12:02:15] <cmr> I'll run it on 0.6 ;)
[12:02:16] <dbaupp> (e.g. checking out each released version.)
[12:02:23] <cmr> mm
[12:02:25] <dbaupp> yeah
[12:03:01] <ChrisMorgan> Why does the standard library have extra::net import net_ip etc. as ip, so that extra::net::ip and extra::net_ip are synonymous?
[12:03:18] *** Joins: maxli (maxli@F2D29657.F60B0462.67AC9B1.IP)
[12:03:25] <dbaupp> ChrisMorgan: because being strange is the standard libraries favourite activity
[12:03:33] <dbaupp> *libraries'
[12:04:02] <dbaupp> (extra is particularly bad, it has accumulated a lot of cruft, and doesn't get used as much as std, so it doesn't get cleaned, ever.)
[12:04:37] * ChrisMorgan prefers Python's "there should be one, and only one, obvious way of doing things" to Perl's "here are forty different ways to do it, go decide which one to do" (or invent another)
[12:04:52] <cmr> ChrisMorgan: so do all/most of the rust devs
[12:04:59] <cmr> Obviously not there yet :)
[12:05:37] <ChrisMorgan> I'm curious: what would happen if I created an issue in GitHub requesting either the removal of extra::net, or the moving of extra::net_*?
[12:05:51] *** Quits: diegoyam (quassel@FF9B1514.A4EC3D18.3A1EC144.IP) (Ping timeout)
[12:05:52] <cmr> hell, open a PR about it.
[12:06:00] <cmr> I'd r+ it ;)
[12:06:17] <ChrisMorgan> I could offer pull requests in both directions and let people decide which one they preferred :D...
[12:06:29] <Blei> ChrisMorgan: most of the io related stuff will be removed/rewritten when brson's stuff lands anyways
[12:06:31] <cmr> net_ip and such shouldn't be public.
[12:06:56] <cmr> net.rs shouldn't even exist I think
[12:07:04] <cmr> it should be pub mod net { ... } in extra.rs
[12:07:06] *** Quits: Earnestly (earnest@2A2BF8F5.321FA5E6.BFD1ABFD.IP) (Quit: WeeChat 0.4.2-dev)
[12:07:30] *** Joins: Earnestly (earnest@2A2BF8F5.321FA5E6.BFD1ABFD.IP)
[12:07:37] <Ms2ger> Should extra.rs exist? :)
[12:07:39] <dbaupp> (it could also be a subfolder net/{mod, ip, url, ...}.rs with mod exporting ip url etc)
[12:07:44] <ChrisMorgan> Thus, you are favouring extra::net::*, cmr?
[12:07:44] <dbaupp> Ms2ger: yes
[12:07:48] <cmr> ChrisMorgan: yes
[12:08:06] <dbaupp> ChrisMorgan: yes, no need for a flat namespace :)
[12:08:22] <dbaupp> Ms2ger: it's the top-level crate file
[12:08:30] <ChrisMorgan> A sign of sure language immaturity: when someone who's only finally got round to actually doing stuff in Rust that very day is advised to submit a pull request to "remove" three modules in the standard library :-)
[12:09:10] *** Joins: diegoyam (quassel@FF9B1514.A4EC3D18.3A1EC144.IP)
[12:11:06] *** kimundi is now known as zz_kimundi
[12:13:21] *** Joins: jensnockert (jensnocker@moz-C5F27039.cust.bredband2.com)
[12:14:46] <ChrisMorgan> Now why would I be getting "unresolved import. maybe a missing `extern mod extra`?" when the first line of the file is "extern mod extra"?
[12:14:57] <dbaupp> cmr: hm, wasn't the build taking ~200s for you previously?
[12:15:07] <dbaupp> cmr: (or is this computer really 2x slower than yours?)
[12:15:30] <cmr> dbaupp: Yes, this computer is very likely 2x or more slower.
[12:15:31] <dbaupp> ChrisMorgan: is the 'extern mod extra' in the crate file? (i.e. the file you're running rustc on)
[12:15:38] <dbaupp> cmr: ok
[12:15:43] <ChrisMorgan> No, it's in a submodule. Ah.
[12:15:55] <cmr> dbaupp: it's a two dual-core 1.6GHz box
[12:16:03] <dbaupp> cmr: right, how much ram?
[12:16:12] <cmr> 8GB
[12:16:18] <ChrisMorgan> dbaupp: danke.
[12:16:22] <dbaupp> so it's not swapping, good.
[12:16:42] <gavinb> I can't seem to find documentation on what the single quote means (like 'a) means. Can anyone enlighten me?
[12:16:47] <dbaupp> ChrisMorgan: bitte :)
[12:16:57] <cmr> gavinb: Named lifetimes, http://static.rust-lang.org/doc/tutorial-borrowed-ptr.html#named-lifetimes
[12:17:28] <Seldaek> ChrisMorgan: given that the whole std/extra have themselves been renamed a few weeks ago, moving a couple modules is a fairly mature move ;)
[12:17:30] <dbaupp> ChrisMorgan: (there should probably be a better error message for that, since I only know the solution because someone else had the same problem and solve it yesterday :) )
[12:17:31] *** Joins: Cromulent (Cromulent@moz-983B638D.cable.virginmedia.com)
[12:17:35] <gavinb> cmr: whoa, thanks. Searching for quote or single quote in the lang ref didn't show this up.
[12:17:38] *** Quits: xazax (Mibbit@6655692F.3B222813.3F580572.IP) (Quit: http://www.mibbit.com ajax IRC Client)
[12:17:47] <cmr> gavinb: yeah, not easy to navigate the docs
[12:18:27] *** Quits: diegoyam (quassel@FF9B1514.A4EC3D18.3A1EC144.IP) (Ping timeout)
[12:20:02] *** Joins: int3_ (int3_@moz-ABE52D50.hsd1.ca.comcast.net)
[12:21:51] <ChrisMorgan> Hmm... takes a while to clone the rust repository with hg-git.
[12:21:55] *** Quits: int3_ (int3_@moz-ABE52D50.hsd1.ca.comcast.net) (Ping timeout)
[12:22:25] <cmr> ChrisMorgan: might not be a good idea, does it handle git submodules? We use a few of those.
[12:22:49] *** Quits: SimonSapin (simon@88F51059.F3BBB17D.144F44FA.IP) (Ping timeout)
[12:23:09] *** Joins: SimonSapin (simon@88F51059.F3BBB17D.144F44FA.IP)
[12:23:33] <SimonSapin> ChrisMorgan: wait until you get to all the submodules â€¦
[12:23:50] <ChrisMorgan> Not sure, I think it supports them but I've never tried it before.
[12:23:52] <cmr> well llvm takes a long time because it's huge
[12:24:01] <cmr> that's the only reason :p
[12:24:31] *** Joins: ggherdov_ (uid11402@moz-C944F5EC.irccloud.com)
[12:24:31] <SimonSapin> cmr: Is there any hope to not use a custom LLVM sometime?
[12:24:34] <ChrisMorgan> Well, I'll see what happens :-)
[12:24:57] <dbaupp> cmr: also, your data is fun, because it takes Rust's json parser 2 seconds to read it (python takes 150ms)
[12:24:57] <cmr> SimonSapin: once our patches are upstreamed and we don't use LLVM invalidly (thus requiring an assertions build)
[12:25:03] <cmr> dbaupp: ouch :\
[12:25:15] <dbaupp> cmr: > 25% is spent in malloc and free too
[12:25:30] <cmr> I find that odd, considering you can do zero-allocation json parsing
[12:25:59] <ChrisMorgan> Comments on the hg-git mailing list seem to suggest it supports submodules, turning them into Mercurial's subrepositories.
[12:26:16] <cmr> dbaupp: Yikes, older versions don't support ccache, this might take a while!
[12:26:30] *** Quits: jaen (jaen@moz-E0979827.copit.pl) (Quit: WeeChat 0.4.1)
[12:26:37] *** Joins: jaen (jaen@moz-E0979827.copit.pl)
[12:26:39] <dbaupp> cmr: yeah, well, clearly extra::json isn't :(
[12:27:00] <ChrisMorgan> Now that sort of thing is (part of) the reason why Mercurial is awesome. Git could never do it the other way, but Mercurial has excellent support for Git with hg-git and SVN with hgsubversion...
[12:27:02] <dbaupp> cmr: oh... how far back?
[12:27:05] *** Joins: Lilly (PinkLace@moz-145A6857.bredband.comhem.se)
[12:27:11] <cmr> dbaupp: 0.6
[12:27:20] <dbaupp> that doesn't support ccache?
[12:27:24] <cmr> nope
[12:27:36] <cmr> not with configure at least
[12:27:39] <dbaupp> (can't you symlink gcc etc to ccache... that's how I've got it)
[12:28:05] *** Quits: lucian (lucian@6B2B4644.4304AE1E.CE5E78F6.IP) (Input/output error)
[12:28:05] <SimonSapin> ChrisMorgan: not sure what you mean, git-remote-hg is working fine for me
[12:28:47] <dbaupp> cmr: https://github.com/mozilla/rust/wiki/Note-ccache
[12:28:50] <Lilly> Hello
[12:29:08] <ChrisMorgan> SimonSapin: and you know how it works? hg-git. :-)
[12:30:07] <SimonSapin> There are a few implementations of it, but I think this one doesnâ€™t
[12:30:08] <ChrisMorgan> SimonSapin: but when it comes to newer Mercurial features (e.g. phases) Git simply doesn't have equivalents. Nor does it for Mercurial's native branches.
[12:30:30] <ChrisMorgan> SimonSapin: https://pypi.python.org/pypi/git-remote-hg says it uses hg-git
[12:30:59] <SimonSapin> http://felipec.wordpress.com/2012/11/13/git-remote-hg-bzr-2/ is distributed with git nowadays
[12:31:35] <dbaupp> cmr: (also, are you passing -Z time-passes?)
[12:31:48] *** Joins: lucian (lucian@6B2B4644.4304AE1E.CE5E78F6.IP)
[12:31:56] <cmr> dbaupp: not yet. haven't figured out exactly how to handle the time pass data being interleaved with warnings and such
[12:32:14] <dbaupp> cmr: I see, does it all get dumped to stderr?
[12:32:50] <dbaupp> cmr: (I just pushed a change that uses time.txt rather than mem.json, btw. yay ugly hacks! ;P )
[12:32:54] *** Joins: cr (anonymous@moz-4B675928.dip0.t-ipconnect.de)
[12:33:00] <Blei> rustc -Z time-passes 2>/dev/null
[12:33:03] <cmr> dbaupp: oh, warnings are on stderr, time-passes are on stdout
[12:33:04] <Blei> worked for me
[12:33:05] <cmr> didn't notice that before
[12:35:19] <Lilly> Can I ask a question?
[12:35:23] <cmr> Lilly: of course
[12:35:57] <Lilly> If I have two traits, A and B
[12:36:23] <Lilly> And each has a method, a() and b()
[12:36:27] *** Quits: jdm (jdm@moz-99E0DB62.dsl.teksavvy.com) (Ping timeout)
[12:36:44] <Lilly> if I then have a third trait, C, so that: trait C: A + B {}
[12:37:11] * ChrisMorgan should have updated his copy of hg-git to one more recent than 2011 before cloning rust repository
[12:37:38] <Lilly> When I try to implement C for a type, I get an error, saying that C doesn't contain the methods a() and b()
[12:38:01] <Lilly> What am I missing? I feel stupid... :P
[12:38:09] <cmr> Lilly: in 0.7?
[12:38:13] <dbaupp> Lilly: you need to implement A and B as well (separately to C)
[12:38:15] <Lilly> Yes
[12:38:22] <cmr> dbaupp: I don't think that should be true
[12:38:28] <cmr> Since C inherits from A and B
[12:38:47] <dbaupp> cmr: yeah, maybe it shouldn't be true, but it is
[12:38:53] <cmr> Shouldn't C include everything from A and B?
[12:38:59] <Lilly> I was looking at the Num trait in std, and wanted to try something like it myself
[12:39:02] <cmr> Well just trying to dissertain if it's a bug or not :p
[12:39:28] <dbaupp> rusti: trait A { fn foo(&self); } trait B  { fn bar(&self); } impl B for uint { fn foo(&self){} fn bar(&self){} }
[12:39:29] -rusti- <anon>:7:82: 7:97 error: method `foo` is not a member of trait `B`
[12:39:29] -rusti- <anon>:7          trait A { fn foo(&self); } trait B  { fn bar(&self); } impl B for uint { fn foo(&self){} fn bar(&self){} }
[12:39:29] -rusti-                                                                                            ^~~~~~~~~~~~~~~
[12:39:29] -rusti- error: aborting due to previous error
[12:39:30] -rusti- application terminated with error code 101
[12:39:44] <dbaupp> rusti: trait A { fn foo(&self); } trait B  { fn bar(&self); } impl A for uint { fn foo(&self){} } impl B for uint {  fn bar(&self){} }
[12:39:45] -rusti- ()
[12:39:53] <SimonSapin> Are "extern mod foo" items supposed to be at the crate top-level? The seem to have no effect in a module
[12:39:56] <dbaupp> rusti: trait A { fn foo(&self); } trait B: A { fn bar(&self); } impl B for uint { fn foo(&self){} fn bar(&self){} }
[12:39:57] -rusti- <anon>:7:84: 7:99 error: method `foo` is not a member of trait `B`
[12:39:57] -rusti- <anon>:7          trait A { fn foo(&self); } trait B: A { fn bar(&self); } impl B for uint { fn foo(&self){} fn bar(&self){} }
[12:39:57] -rusti-                                                                                              ^~~~~~~~~~~~~~~
[12:39:57] -rusti- error: aborting due to previous error
[12:39:57] -rusti- application terminated with error code 101
[12:40:01] <dbaupp> SimonSapin: yes
[12:40:15] <SimonSapin> oooh, thatâ€™s why
[12:40:18] <SimonSapin> thanks dbaupp
[12:40:53] *** Quits: donri (dag@moz-9BB61102.tbcn.telia.com) (Client exited)
[12:41:10] <dbaupp> Lilly: the Num trait is just a convenience wrapper: you have to implement Add, Sub etc separately, and also write `impl Num for MyType {}` to get it to work
[12:41:13] *** Joins: wilsonk|2 (kvirc@moz-39EFBFC2.cg.shawcable.net)
[12:41:18] <Lilly> I just feel like B should "inherit" A when you do it like that, but maybe that's wrong
[12:41:33] <cmr> Lilly: I feel that way too
[12:41:38] <cmr> it might be a bug or unimplemented yet
[12:41:41] *** Joins: diegoyam (quassel@FF9B1514.A4EC3D18.3A1EC144.IP)
[12:41:48] <cmr> should open an issue about it, at the very least it needs to be better documented.
[12:41:55] <Lilly> Yeah, it feels very inconvenient
[12:43:03] <Lilly> But yeah, implementing A, B and C separately works as dbaupp showed
[12:43:06] <Lilly> Thanks!
[12:43:11] <dbaupp> np :)
[12:43:32] <dbaupp> cmr: (there we go, github pages finally updated with the non-skewed time data.)
[12:44:03] *** Joins: engla (engla@moz-DBD1D96E.cust.bredbandsbolaget.se)
[12:44:13] <cmr> dbaupp: could you mark the "real" time on the memory graphs below?
[12:44:19] <cmr> just a simple tick on the X axis
[12:44:22] <dbaupp> "real"?
[12:44:39] <dbaupp> what do you mean?
[12:44:47] <cmr> the actual duration of the non-skewed run
[12:44:53] <dbaupp> ah, right.
[12:45:11] <dbaupp> I can try
[12:45:14] <taylanub> How far does our type-inferring go ?  The tutorial says  fn head<T>(v: &[T]) -> T { v[0] }  is an error because T might be uncopyable; can't the Copy trait be inferred ? 
[12:45:14] <SimonSapin> https://github.com/mozilla/rust/issues/7583
[12:45:27] <dbaupp> cmr: (fwiw, the real time is only a few seconds slower than the mem'd time.)
[12:45:31] <dbaupp> *faster
[12:45:44] <cmr> taylanub: no, there's no global reasoning like that.
[12:46:04] <dbaupp> taylanub, type inference is local only, i.e. the types of parameters and return values to functions must be entirely known
[12:46:07] <cmr> taylanub: you explicitly need to do fn head<T: Copy>, and use an explicit copy.
[12:48:06] *** Joins: hjr3 (hradtke@moz-E87BDF1F.socal.res.rr.com)
[12:56:55] *** Quits: roo (jesse.rudo@moz-B7585E4C.dynamic.ip.windstream.net) (Ping timeout)
[12:57:07] *** Quits: wilsonk|2 (kvirc@moz-39EFBFC2.cg.shawcable.net) (Ping timeout)
[12:58:47] *** Quits: taylanub (taylanub@moz-5D69E26C.dip0.t-ipconnect.de) (Ping timeout)
[13:00:46] *** Joins: phrawzty (phrawzty@moz-D00E4D5F.rev.dedibox.fr)
[13:02:20] <phrawzty> hello all. just fiving into rust for the first time, and i've encountered the following compiler message : "error: multiple applicable methods in scope" related to my trying to use .to_str
[13:02:44] <phrawzty> not sure how to specify which candidate amongst the choices to use.  any insight would be appreciated. :)
[13:02:50] <cmr> rusti: let x = 4; x.to_str()
[13:02:52] -rusti- more than 5 lines of output, pastebinned: http://sprunge.us/LEPj
[13:02:54] <cmr> rusti: let x = 4u; x.to_str()
[13:02:56] -rusti- ~"4"
[13:03:01] <cmr> rusti: let x: i32 = 4; x.to_str()
[13:03:02] -rusti- ~"4"
[13:03:06] <cmr> And so forth
[13:04:02] <cmr> dbaupp: what are the blue and red lines in the top graph?
[13:04:07] <cmr> oh I see
[13:04:12] <cmr> peak memory and time?
[13:04:21] <dbaupp> right
[13:04:31] * dbaupp relabels memory
[13:05:32] <cmr> acrichto: seems threadsafe llvm was a time regression... do we actually use multiple threads?
[13:06:24] <cmr> dbaupp: this is very fancy, better than I could have imagined
[13:06:45] <dbaupp> cmr: thanks :)
[13:06:51] <phrawzty> I sort of figured this would just work :)
[13:06:51] <phrawzty>     for [1,2,3].each |num| {
[13:06:51] <phrawzty>         println(num.to_str())
[13:06:52] <phrawzty>     }
[13:06:55] * dbaupp now loves d3
[13:07:06] *** Quits: sebcrozet (Mibbit@moz-7FB6C00B.w193-252.abo.wanadoo.fr) (Quit: http://www.mibbit.com ajax IRC Client)
[13:07:10] <cmr> phrawzty: what is the type of num?
[13:07:13] <dbaupp> phrawzty: would... except .each has been removed
[13:07:16] <dbaupp> *it would
[13:07:16] <cmr> it could be *any* of the numerics
[13:07:22] <cmr> You can annotate it like:
[13:07:25] <phrawzty> dbaupp: oh. ok.
[13:07:27] <cmr> [1u, 2, 3]
[13:07:37] *** Quits: hjr3 (hradtke@moz-E87BDF1F.socal.res.rr.com) (Quit: My MacBook has gone to sleep. ZZZzzzâ€¦)
[13:07:40] <cmr> (only need to specify 1 for type inference to do its job)
[13:07:42] <dbaupp> cmr: (I believe it defaults to int, maybe.)
[13:07:46] *** Quits: Jesin (Jessin_@moz-3AD6F09F.res.lehigh.edu) (Ping timeout)
[13:07:46] <cmr> dbaupp: nope
[13:07:47] <Ms2ger> for num in [1,2,3] { println(num.to_str()); } ?
[13:07:55] <phrawzty> so this "rust for rubyists" book is no good, then ? :/
[13:07:56] <cmr> well, maybe, but the traits don't work like that
[13:07:57] <dbaupp> cmr: in some situations it does
[13:07:59] <cmr> phrawzty: It's out of date
[13:08:04] <phrawzty> cmr: :(
[13:08:06] <SimonSapin> Ms2ger :)
[13:08:07] <cmr> phrawzty: I'll update it today, sorry :(
[13:08:14] <cmr> I meant to do it before the 0.7 release but I forgot
[13:08:19] <Ms2ger> Please don't respond to that :)
[13:08:52] <phrawzty> cmr: heh, ok.  well thanks for your help then. :)
[13:09:35] <phrawzty> dbaupp: what has .each been replaced with, if anything ?
[13:09:44] <cmr> phrawzty: .iter().advance, unfortunately
[13:09:51] <phrawzty> cmr: yuck
[13:09:53] <cmr> in-between the iterator transition
[13:10:06] <cmr> it will eventually just be `for [1, 2, 3] |num|`
[13:10:16] <dbaupp> phrawzty: it looks bad, but it's much more flexible
[13:10:17] <AutomatedTester> phrawzty: I have started on a Rust Koans to start teaching myself
[13:10:19] <cmr> (or `for num in [1, 2, 3]`, syntax hasn't been settled yet)
[13:10:42] <phrawzty> hmm.. i appear to be using rust v0.6
[13:10:49] *** Quits: igl (igl@moz-8249BD2A.adsl.alicedsl.de) (Ping timeout)
[13:10:52] <phrawzty> should i be on 0.7 definitively ?
[13:11:00] <cmr> phrawzty: yes, definitely
[13:11:14] <dbaupp> AutomatedTester: oooh, online yet?
[13:11:15] <cmr> countless improvements
[13:11:32] <AutomatedTester> dbaupp: no and only done arrays so far
[13:11:33] *** Joins: igl (igl@moz-275D3E76.adsl.alicedsl.de)
[13:11:35] <phrawzty> AutomatedTester: your words intrigue me and i would like to subscribe to your newsletter
[13:12:10] <AutomatedTester> phrawzty: you have already subscribed to my news letter so just watch for the news
[13:12:10] *** Joins: jdm (jdm@CAB30FBD.8F96AEA7.2D179A7D.IP)
[13:12:18] <Ms2ger> Don't encourage him, he's got enough other work ;)
[13:12:19] <AutomatedTester> hopefully work on it a bit more tonight
[13:12:29] <AutomatedTester> Ms2ger: this is a personal project
[13:12:34] <phrawzty> AutomatedTester: i.. did ?
[13:12:44] <AutomatedTester> phrawzty: my twitter news letter
[13:12:47] <AutomatedTester> :D
[13:12:53] <phrawzty> AutomatedTester: oh haha yes
[13:13:28] <AutomatedTester> dbaupp: who handles updating brew?
[13:13:43] <cmr> rusti: for 5.times { print("foo ") }
[13:13:44] -rusti- foo foo foo foo foo ()
[13:14:04] <dbaupp> AutomatedTester: no idea
[13:14:07] <AutomatedTester> rust looks more and more like ruby everyday
[13:14:29] <SimonSapin> Rust 0.7 was in the Archlinux repositories mere hours after being announced. Good job whoever maintains it.
[13:14:33] <phrawzty> yes, as i installed via Brew, i got 0.6 by default.
[13:14:37] <cmr> SimonSapin: that'd be strcat
[13:14:45] <phrawzty> i suspect i could brew install --HEAD and get.. something.
[13:14:55] <phrawzty> i'd probably get master, which.. well who knows.
[13:14:56] *** Joins: pnathan (Adium@moz-E3C3FAF2.hfc.comcastbusiness.net)
[13:15:04] <cmr> phrawzty: master is stable
[13:15:13] <phrawzty> cmr: good to know !
[13:15:14] <Ms2ger> As stable as it gets, at least :)
[13:16:32] <dbaupp> SimonSapin: that's strcat (aka thestinger)
[13:16:38] *** Joins: gour_ (gour@moz-F4263343.adsl.net.t-com.hr)
[13:16:54] *** Quits: gour (gour@moz-71E9D123.adsl.net.t-com.hr) (Ping timeout)
[13:17:48] <phrawzty> well then. time to fire up the ol' macbook fan array.
[13:17:51] <phrawzty> prepare for liftoff!
[13:18:05] *** Joins: roo (jesse.rudo@moz-B7585E4C.dynamic.ip.windstream.net)
[13:20:56] *** Quits: pnathan (Adium@moz-E3C3FAF2.hfc.comcastbusiness.net) (Ping timeout)
[13:21:01] <engla> cmr: I solved the for syntax problem. We'll just have them all. https://gist.github.com/anonymous/e7650870140f7348d3cc 
[13:21:31] <cmr> engla: oh my!
[13:21:54] *** Quits: roo (jesse.rudo@moz-B7585E4C.dynamic.ip.windstream.net) (Client exited)
[13:21:58] *** zz_kimundi is now known as kimundi
[13:23:26] *** Joins: jedestep (jedestep@moz-CFA8EBCD.natpool.nyu.edu)
[13:23:39] *** Joins: MaikKlein (maik@moz-51F0F9C8.dip0.t-ipconnect.de)
[13:24:44] <dbaupp> engla: only 5?
[13:25:05] <dbaupp> engla: code will be forced to be so... consistent. urgh!
[13:25:17] <dbaupp> cmr: uploading the tickmarks now :)
[13:25:26] <dbaupp> (just gotta wait for github pages...)
[13:29:22] <dbaupp> cmr: it's really nice having consistent data... none of this buildbot silliness
[13:29:34] <engla> is vec::reserve guaranteed to succeed?
[13:29:48] <engla> wrt https://github.com/mozilla/rust/pull/7578  maybe it should just silently skip bogus values
[13:29:48] <cmr> engla: it could fail in an OOM situation
[13:29:51] <doomlord_> are rusters predominantly Spaces or Tabs people
[13:29:59] <engla> cmr: right now it crashes on overflow
[13:30:01] <dbaupp> doomlord_: spaces
[13:30:07] <cmr> doomlord_: spaces (unfortunately, IMO)
[13:30:13] <doomlord_> ok back to C++ :)
[13:30:34] <cmr> engla: yikes
[13:30:57] <doomlord_> ( i just tried emacs rust mode again , found it setup for spaces.. trying to get it into tabs..)
[13:31:16] *** cadecairos is now known as cade
[13:32:14] <doomlord_> i suppose i just need an auto formatter, or get a text editor which always deletes spaces to the nearest tab
[13:32:50] <MaikKlein> pretty printer
[13:32:58] <engla> cmr: unfortunately the core types will not fail on oom, but abort directly :-(  hopefully that can be fixed later
[13:33:05] <MaikKlein> it just doesn't work every time :(
[13:33:59] <engla> doomlord_: vim can do that
[13:34:27] <dbaupp> engla: we need a non-allocating fail for that to work
[13:35:02] <doomlord_> i've never managed to get into vim, maybe i should try again. i always got further with emacs. I have used windows tools for too long.. i keep going back to gedit on linux
[13:35:12] <MaikKlein> if I expose a rust function to C. How do I call it from C? is there anywhere an example?
[13:35:52] <cmr> MaikKlein: you need to output an object file using rustc -c, use `extern` in C, and link with the object file when compiling your C program
[13:35:52] <engla> doomlord_: not sure if it's worth it (with vim)
[13:36:18] <engla> doomlord_: any smart editor will have the right spaces as tabs behavior
[13:36:35] <doomlord_> i think emacs can do it, its just hard to setup
[13:36:48] <doomlord_> several conflicting states behind the scenes 
[13:37:21] <engla> ok. for vim you want  set sts=4 sw=4 et  , that's all
[13:37:51] <MaikKlein> cmr, so I don't need any headers? I just link the .o files an everything works?
[13:38:05] <cmr> MaikKlein: well you could but the `extern` declarations in a header
[13:38:08] <cmr> *put
[13:38:18] <cmr> but you don't need to (it's probably a good idea though)
[13:38:54] <MaikKlein> can I auto generate the header?
[13:39:05] <cmr> Not without writing a tool for it :p
[13:39:18] <MaikKlein> maybe I will :)
[13:39:30] <MaikKlein> should be easy enough
[13:40:37] <phrawzty> sweet, i'ma be all 0.7 up in this.
[13:40:55] *** Quits: illissius (illissius@moz-3590251D.kabelnet.hu) (Ping timeout)
[13:41:37] <SimonSapin> Are there known bugs with [a, b, ..rest] patterns? (Kinda hard to search forâ€¦)
[13:42:08] <dbaupp> SimonSapin: yes
[13:42:22] <SimonSapin> bugs like, they donâ€™t match when they should?
[13:42:41] <dbaupp> https://github.com/mozilla/rust/issues/6909
[13:43:00] <dbaupp> so not really
[13:43:03] <dbaupp> what's your code?
[13:46:29] <SimonSapin> dbaupp: Iâ€™m getting "Unexpected JSON: List(~[String(~"[]"), List(~[String(~"ident"), String(~"example")]), String(~"="), List(~[String(~"string"), String(~"foo(int x) {   this.x = x;}")])])" here https://github.com/SimonSapin/rust-cssparser/blob/920d436f33a1e8bf5e1b317c76d1c742632c0f40/tokenizer.rs#L922
[13:46:30] <SimonSapin> But it should match https://github.com/SimonSapin/rust-cssparser/blob/920d436f33a1e8bf5e1b317c76d1c742632c0f40/tokenizer.rs#L892
[13:47:10] <phrawzty> rusti for [1u,2,3].iter().advance |num| { println(num.to_str)); }
[13:47:14] <phrawzty> rusti: for [1u,2,3].iter().advance |num| { println(num.to_str)); }
[13:47:14] -rusti- <anon>:7:64: 7:65 error: incorrect close delimiter: `)`
[13:47:14] -rusti- <anon>:7          for [1u,2,3].iter().advance |num| { println(num.to_str)); }
[13:47:14] -rusti-                                                                          ^
[13:47:14] -rusti- application terminated with error code 101
[13:47:26] <phrawzty> oops.
[13:47:31] <phrawzty> rusti: for [1u,2,3].iter().advance |num| { println(num.to_str()); }
[13:47:33] -rusti- more than 5 lines of output, pastebinned: http://sprunge.us/iTDW
[13:47:45] <phrawzty> hm. ok.
[13:48:02] <engla> rust doesn't know to hold on to the vec literal right now phrawzty 
[13:48:09] <cmr> phrawzty: fix for that is to assign the vector to an intermediate variable, or use ~[1u, 2, 3]
[13:48:14] <SimonSapin> Perhaps more readable https://github.com/SimonSapin/rust-cssparser/blob/65ebc051883948a1a8857f9a5c18c3f132dddd9e/tokenizer.rs#L882
[13:48:14] <cmr> I think it's a bug
[13:48:25] <phrawzty> engla: cmr: ah. ok.
[13:49:01] <dbaupp> SimonSapin: I have a feeling that nested matches don't work... :(
[13:49:09] <Blei> how would i create a test comprised of multiple source files, but only one should be compiled?
[13:49:15] <phrawzty> rusti: for ~[1u,2,3].iter().advance |num| { println(num.to_str()); }
[13:49:15] -rusti- <anon>:7:30: 7:37 error: `for` must be followed by a block call
[13:49:15] <Blei> xfail-test the other file?
[13:49:16] -rusti- <anon>:7          for ~[1u,2,3].iter().advance |num| { println(num.to_str()); }
[13:49:16] -rusti-                                        ^~~~~~~
[13:49:16] -rusti- application terminated with error code 101
[13:49:46] <SimonSapin> dbaupp: nested matches without ..rest do
[13:49:47] <dbaupp> SimonSapin: something like match foo { JList(ref list) => match list { [~"[]", ..] => ..., ... }, JString() ... } might be a work around
[13:49:47] <cmr> Blei: I think you need to use the auxillary folder, and do some // aux-build or something
[13:49:51] *** Joins: Phlogistique (no@moz-B2BEB013.net)
[13:49:55] <SimonSapin> Iâ€™ll try to refactor
[13:49:57] <dbaupp> SimonSapin: oh, Isee
[13:50:01] <Blei> cmr: ah, yeah i've seen those
[13:50:03] <Phlogistique> hi
[13:50:12] <Blei> doesn't this build the other file as well?
[13:50:25] <engla> rusti: for (~[1,2,3]).consume_iter().advance |x| { println(x.to_str()) }
[13:50:26] -rusti- 1
[13:50:26] <Blei> err, i'll try that before complaining
[13:50:26] -rusti- 2
[13:50:26] -rusti- 3
[13:50:26] -rusti- ()
[13:50:34] <engla> the consume_iter works now ^^ thans dbaupp 
[13:50:45] <engla> very thans indeed.
[13:50:52] <dbaupp> rusti: match Some([1,2,3]) { Some([a, .. rest]) => println(fmt!("%?", rest)), _ => fail!("oops") }
[13:50:53] -rusti- <anon>:7:37: 7:38 warning: unused variable: `a` [-W unused-variable (default)]
[13:50:53] -rusti- <anon>:7          match Some([1,2,3]) { Some([a, .. rest]) => println(fmt!("%?", rest)), _ => fail!("oops") }
[13:50:53] -rusti-                                               ^
[13:50:53] -rusti- &[2, 3]
[13:50:54] -rusti- ()
[13:50:54] <SimonSapin> dbaupp: also, Iâ€™m using [constant, ..rest] rather than [name_to_assign_to, ..rest]
[13:51:00] <cmr> Blei: oh, hm.. why would a test have multiple files without building them?
[13:51:03] * phrawzty makes a note of consume_iter()
[13:51:05] <dbaupp> rusti: match Some([1,2,3]) { Some([1, .. rest]) => println(fmt!("%?", rest)), _ => fail!("oops") }
[13:51:06] -rusti- &[2, 3]
[13:51:06] -rusti- ()
[13:51:17] <dbaupp> engla: no probem :)
[13:51:38] *** Quits: gavinb (gavinb@moz-9EC182F0.lowrp3.vic.optusnet.com.au) (Quit: gavinb)
[13:51:44] <Blei> cmr: https://github.com/mozilla/rust/issues/7276
[13:51:54] <dbaupp> rusti: match Some([~"[]", ~"foo"]) { Some([~"[]", .. rest]) => println(fmt!("%?", rest)), _ => fail!("oops") }
[13:51:55] -rusti- &[~"foo"]
[13:51:55] -rusti- ()
[13:52:01] <cmr> ah...
[13:52:09] <cmr> Blei: well, good luck? ;)
[13:52:17] <dbaupp> rusti: match extra::json::List([~"[]", ~"foo"]) { extra::json::List([~"[]", .. rest]) => println(fmt!("%?", rest)), _ => fail!("oops") }
[13:52:18] <Blei> haha, thanks XD
[13:52:18] -rusti- more than 5 lines of output, pastebinned: http://sprunge.us/Laba
[13:52:48] <dbaupp> rusti: match extra::json::List([extra::json::String(~"[]"), extra::json::String(~"foo")]) { extra::json::List([extra::json::String(~"[]"), .. rest]) => println(fmt!("%?", rest)), _ => fail!("oops") }
[13:52:49] -rusti- line longer than 150 columns, pastebinned: http://sprunge.us/XUNX
[13:52:50] <MaikKlein> what is consume iter doing? "for (~[1,2,3]).consume_iter().advance |x| { println(x.to_str()) }" it goes over all elements and in the end the vector is gone?
[13:53:05] <dbaupp> rusti: match extra::json::List(~[extra::json::String(~"[]"), extra::json::String(~"foo")]) { extra::json::List([extra::json::String(~"[]"), .. rest]) => println(fmt!("%?", rest)), _ => fail!("oops") }
[13:53:05] -rusti- &[String(~"foo")]
[13:53:06] -rusti- ()
[13:53:07] <dbaupp> MaikKlein: yes
[13:53:19] <dbaupp> MaikKlein: it moves the elements out of the vector
[13:53:33] <dbaupp> SimonSapin: it appears to be non-trivial :(
[13:53:33] <MaikKlein> that's pretty cool
[13:54:00] <dbaupp> cmr: it's got the true-time ticks now
[13:54:45] <cmr> dbaupp: seems rustc has gotten slower :(
[13:54:53] <dbaupp> cmr: really?
[13:55:18] <cmr> dbaupp: starts going downhill after 0bd67f6
[13:55:33] <cmr> aside: I really wish keyboard number pads had hex digits...
[13:55:58] *** Joins: ghrust (ghrust@C621748.6A2AE50.F3114085.IP)
[13:55:58] <ghrust> 01[13rust01] 15bors merged 06auto into 06master: 02http://git.io/G25eFg
[13:55:58] *** Parts: ghrust (ghrust@C621748.6A2AE50.F3114085.IP) ()
[13:56:16] <dbaupp> wow, bors... speedy as always
[13:56:29] <dbaupp> cmr: oh :(
[13:56:51] <cmr> dbaupp: I suggest replacing IRFY with the mem graphs, and demoting the current one to /buildbots
[13:57:09] <dbaupp> cmr: yeah, that's what I'm going to do
[13:57:17] * dbaupp has plans
[13:57:27] <cmr> whoa was that a 7 hour cycle?
[13:57:40] *** Joins: sp3d (a@moz-49806493.dhcp.stls.mo.charter.com)
[13:57:54] *** Quits: MaikKlein (maik@moz-51F0F9C8.dip0.t-ipconnect.de) (Ping timeout)
[13:57:54] <dbaupp> quite probably
[13:58:01] *** Joins: sw17ch (sw17ch@moz-675AFBCF.hsd1.mi.comcast.net)
[13:58:42] *** Joins: Jesse (jruderman@moz-537BCF9.hsd1.ca.comcast.net)
[13:58:59] *** Quits: rubber-duck (rubber-duc@moz-A141FE12.dsl.iskon.hr) (Quit: Leaving)
[13:58:59] *** Joins: ghrust (ghrust@1E8607E8.6A2AE50.F3114085.IP)
[13:59:00] <ghrust> 01[13rust01] 15bors pushed 0 new commits to 06auto: 02http://git.io/zShe3w
[13:59:00] *** Parts: ghrust (ghrust@1E8607E8.6A2AE50.F3114085.IP) ()
[13:59:02] *** Joins: ghrust (ghrust@F6EE6DE3.6A2AE50.F3114085.IP)
[13:59:03] <ghrust> 01[13rust01] 15bors pushed 3 new commits to 06auto: 02http://git.io/LW_Hrg
[13:59:03] <ghrust> 13rust/06auto 14d31d8e3 15Felix S. Klock II: Refactored int/uint range code in preparation for change to range_rev semantics....
[13:59:03] <ghrust> 13rust/06auto 140b639c8 15Felix S. Klock II: Switch over to new range_rev semantics; fix #5270.
[13:59:03] <ghrust> 13rust/06auto 140266ca5 15bors: auto merge of #7524 : pnkfelix/rust/fsk-invert-range-rev-halfclosedness-issue5270, r=cmr...
[13:59:05] *** Parts: ghrust (ghrust@F6EE6DE3.6A2AE50.F3114085.IP) ()
[13:59:11] <ChrisMorgan> If I have a `struct Server { bind_address: ip::IpAddr, port: uint, backlog: uint}`, I can't see why it wouldn't satisfy `Send`, but the compiler is saying it isn't. Isn't it?
[13:59:18] *** Quits: jensnockert (jensnocker@moz-C5F27039.cust.bredband2.com) (Ping timeout)
[13:59:32] <dbaupp> I'd guess ip::IpAddr is not send
[14:00:03] <phrawzty> think i'll walk over and congratulate Felix for his most recent pushes.
[14:00:37] <dbaupp> ChrisMorgan: (hm, it looks like ip::IpAddr should be Send... but I don't really understand the magic traits.)
[14:00:54] <ChrisMorgan> Actually, my mistake. Method was using (&self)
[14:02:11] *** Joins: jensnockert (jensnocker@moz-C5F27039.cust.bredband2.com)
[14:02:26] <ChrisMorgan> That makes me think - on the impl of a struct, fn x(self) would mean it would copy the struct when calling the method, right?
[14:02:34] <cmr> ChrisMorgan: nope, moves.
[14:02:49] <cmr> ie, the method takes ownership.
[14:03:18] <ChrisMorgan> And when it returns, things go back to normal?
[14:03:33] <cmr> nope, value can't be used after it returns
[14:03:40] <cmr> it's said to "consume" the value
[14:03:45] <ChrisMorgan> OK.
[14:04:03] <ChrisMorgan> That removes the lack of safety that case had just made occur to me.
[14:04:34] <ChrisMorgan> But I guess I can just take the values from the &self and have them as local variables and that should satisfy the Send requirement in the spawn closure.
[14:04:55] <cmr> You can copy/clone &self explicitly.
[14:05:23] *** Joins: g5pw (g5pw@moz-94F4170D.retail.telecomitalia.it)
[14:05:25] <cmr> Taking the values from &self would move out of it, which also consumes self
[14:05:47] <ChrisMorgan> Though if I copy them that won't be the case.
[14:06:03] *** Joins: reyre_ (reyre@moz-9002CDDA.cpe.net.cable.rogers.com)
[14:06:05] <ChrisMorgan> Thanks, I'm getting more of a feel how it all works now.
[14:06:41] <cmr> note there might still be some weirdness around moving into closures and some implicit copies... not sure, I'm shaky on this part of rust still
[14:07:27] <engla> does niko have a branch for closure reform? or anyone
[14:07:27] <g5pw> hello everyone! I'm one of the rust maintainers at MacPorts, and I found a silly bug in src/etc/local_stage0.sh (rust v0.7). Should I just fork and request a pull?
[14:07:38] <engla> I want to look and see if I can help (well, it's unlikely)
[14:07:40] <cmr> engla: bblum is working on it I thought
[14:07:46] <engla> oh ok
[14:07:49] <cmr> g5pw: ye please!
[14:08:00] <cmr> *yes
[14:08:01] <g5pw> roger
[14:08:01] *** Quits: jedestep (jedestep@moz-CFA8EBCD.natpool.nyu.edu) (Ping timeout)
[14:09:04] *** Quits: jensnockert (jensnocker@moz-C5F27039.cust.bredband2.com) (Ping timeout)
[14:10:05] <engla> heh rust has the AtomicOption type
[14:10:08] *** Joins: jensnockert (jensnocker@moz-C5F27039.cust.bredband2.com)
[14:10:10] <g5pw> cmr: any code styling rules I should read before commiting? The bug is in src/etc/local_stage0.sh
[14:10:25] <g5pw> so the code is shell
[14:10:30] <cmr> g5pw: I don't think there is any style guide for shell
[14:10:39] <cmr> spaces, not tabs, though
[14:10:59] <g5pw> ok, thanks!
[14:11:34] <dbaupp> g5pw: what's the bug, btw?
[14:12:25] <g5pw> libextra does not get copied to stage0 dir if installing from local rust compiler
[14:12:47] <g5pw> so it segfaults on run :)
[14:12:54] <cmr> g5pw: are you trying to use local-rust-root?
[14:13:00] <g5pw> cmr: yes
[14:13:20] <cmr> g5pw: that probably isn't going to work unless you have a version at or near the snapshot compiler used for 0.7
[14:13:27] <cmr> ie, you can't use the 0.6 compiler
[14:14:13] <g5pw> we at macports love separating stages, so we fetch the bootstrap compiler (latest from snapshots.txt) and use it to build rust. In this way we can mirror the bootstrap compiler on our servers to reduce some load
[14:14:28] <g5pw> (and the build phase can be executed without internet connection)
[14:14:33] <cmr> ah, fancy
[14:14:36] *** Quits: Ripp__ (quassel@moz-4BA27C60.hsd1.md.comcast.net) (Client exited)
[14:15:05] <g5pw> thanks
[14:15:13] *** Quits: sankha93 (Instantbir@9276287F.8CAC2DA9.D2D1FAF0.IP) (Quit: Instantbird 1.4 -- http://www.instantbird.com)
[14:15:29] <cmr> you are probably among the only users of that feature, so makes sense that it has bugs
[14:15:35] <g5pw> maintainers like to tinker with build systems :P
[14:16:02] <g5pw> aha, I see. no problem, though!
[14:16:16] *** Quits: jensnockert (jensnocker@moz-C5F27039.cust.bredband2.com) (Ping timeout)
[14:16:21] <dbaupp> g5pw: segfaults? o_O
[14:16:54] <g5pw> dbaupp: yes, because the libextra library is not found at rpath
[14:17:09] <dbaupp> not just a normal failure?
[14:17:16] <dbaupp> ("normal")
[14:17:42] <g5pw> dbaupp: no, the bootstrap compiler just segfaults :)
[14:17:59] <dbaupp> oh :(
[14:18:18] <g5pw> heh, the commit is just 2 changed lines
[14:18:59] *** Joins: jensnockert (jensnocker@moz-C5F27039.cust.bredband2.com)
[14:20:05] <dbaupp> oooo, auto is going through bsd as well now
[14:20:10] *** Joins: ghrust (ghrust@1E8607E8.6A2AE50.F3114085.IP)
[14:20:10] <ghrust> 01[13rust01] 15bors 04force-pushed 06auto from 140266ca5 to 14e07e9bb: 02http://git.io/N3iJvQ
[14:20:10] *** Parts: ghrust (ghrust@1E8607E8.6A2AE50.F3114085.IP) ()
[14:20:13] *** Joins: ghrust (ghrust@24260B07.6A2AE50.F3114085.IP)
[14:20:13] <ghrust> 01[13rust01] 15bors pushed 5 new commits to 06auto: 02http://git.io/1ejENg
[14:20:13] <ghrust> 13rust/06auto 14cd0c25e 15Fedor Indutny: libc: add _SC_* consts for non-mips linux too...
[14:20:13] <ghrust> 13rust/06auto 14b959ba9 15Fedor Indutny: libc: VirtualAlloc and FileMapping bindings
[14:20:14] <ghrust> 13rust/06auto 140a39c8c 15Fedor Indutny: libc: add errno values
[14:20:15] *** Parts: ghrust (ghrust@24260B07.6A2AE50.F3114085.IP) ()
[14:20:24] <cmr> dbaupp: yup, master was removed entirely
[14:20:40] <dbaupp> cmr: oh, so it was
[14:21:00] *** Joins: dherman (dherman@moz-6CA476B1.hsd1.ca.comcast.net)
[14:21:00] *** ChanServ sets mode: +o dherman
[14:21:42] *** Joins: lkuper (lkuper@moz-C0CD33ED.hsd1.in.comcast.net)
[14:22:56] <g5pw> quick question: libcore is not called core anymore, right?
[14:23:03] <cmr> g5pw: right, it's now libstd
[14:23:19] <g5pw> ok, great. Pull request coming up!
[14:24:59] *** Joins: sherlockmao (Mibbit@moz-A813121A.construction.ualberta.ca)
[14:25:09] <dbaupp> cmr: how's 0.6 coming along?
[14:25:20] <cmr> dbaupp: LLVM build failed so I gave up :p
[14:25:22] <cmr> link failure
[14:25:27] <cmr> didn't really want to debug or fix
[14:25:32] <dbaupp> yeah, np
[14:25:41] *** Quits: Cromulent (Cromulent@moz-983B638D.cable.virginmedia.com) (Quit: KVIrc 4.2.0 Equilibrium http://www.kvirc.net/)
[14:25:50] *** Joins: SiegeLord (sl@moz-CAF07B4C.hsd1.ma.comcast.net)
[14:25:53] *** Quits: sherlockmao (Mibbit@moz-A813121A.construction.ualberta.ca) (Quit: http://www.mibbit.com ajax IRC Client)
[14:25:59] <cmr> picked a few random merges from the past 6 weeks
[14:26:14] <ChrisMorgan> super:: is special, I presume?
[14:26:26] <cmr> ChrisMorgan: Yes, imports from the parent mod, rather than the crate root.
[14:26:53] <ChrisMorgan> That's what I gathered. And that would explain why moving net_*.rs to net/*.rs broke the build.
[14:28:52] <pnkfelix> cmr: do we need to give luqmana's commit a higher priority to fix the mingw builds?  Or is the failure on the most recent range_rev merge attempt something unrelated to pull request 7547 ?
[14:29:14] <cmr> pnkfelix: did Luqman's pull fix that stuff?
[14:29:16] * cmr looks
[14:29:33] *** Joins: taylanub (taylanub@moz-5D69E26C.dip0.t-ipconnect.de)
[14:29:36] <pnkfelix> cmr: I have no idea, I don't actually understand the most recent build failure, I just saw it was only on mingw
[14:29:55] <cmr> pnkfelix: unrelated to 7547, 7547 is only paving the way for 64-bit windows
[14:29:56] <pnkfelix> cmr: (but maybe the mingw failure is unrelated to mingw64 support)
[14:30:07] <pnkfelix> cmr: Okay then I guess I'll just cross my fingers, thanks.
[14:30:08] *** Quits: pyrac (pyrac@moz-C6037E0A.ghst.net) (Quit: pyrac)
[14:30:14] <cmr> I don't understand why it's failing either :\
[14:31:00] *** Joins: mreedell (mreedell@moz-9950CA28.hsd1.pa.comcast.net)
[14:31:11] *** Quits: jensnockert (jensnocker@moz-C5F27039.cust.bredband2.com) (Input/output error)
[14:31:53] <g5pw> here it is http://github.com/mozilla/rust/pull/7586
[14:31:59] *** Joins: ghrust (ghrust@79968228.6A2AE50.F3114085.IP)
[14:31:59] <ghrust> 01[13rust01] 15bors 04force-pushed 06auto from 14856954a to 14e07e9bb: 02http://git.io/N3iJvQ
[14:31:59] *** Parts: ghrust (ghrust@79968228.6A2AE50.F3114085.IP) ()
[14:32:02] *** Joins: ghrust (ghrust@614D05BD.6A2AE50.F3114085.IP)
[14:32:03] <ghrust> 01[13rust01] 15bors pushed 3 new commits to 06auto: 02http://git.io/05haXQ
[14:32:03] <ghrust> 13rust/06auto 14d31d8e3 15Felix S. Klock II: Refactored int/uint range code in preparation for change to range_rev semantics....
[14:32:03] <ghrust> 13rust/06auto 140b639c8 15Felix S. Klock II: Switch over to new range_rev semantics; fix #5270.
[14:32:03] <ghrust> 13rust/06auto 1468fa9d7 15bors: auto merge of #7524 : pnkfelix/rust/fsk-invert-range-rev-halfclosedness-issue5270, r=cmr...
[14:32:04] *** Parts: ghrust (ghrust@614D05BD.6A2AE50.F3114085.IP) ()
[14:32:30] <ChrisMorgan> (Why exactly does ghrust not stay in the room all the time?)
[14:32:39] <dbaupp> cmr: was the LLVM thing something in configure?
[14:32:41] <cmr> ChrisMorgan: out of our control, it's a github feature
[14:32:43] <cmr> dbaupp: no
[14:32:55] <cmr> dbaupp: undefined reference to llvm:cl::SomethingHere
[14:32:55] <dbaupp> cmr: oh, ok...
[14:33:44] *** gour_ is now known as gour
[14:33:58] <cmr> dbaupp: r+ within a second of each other, nice :p
[14:34:00] <ChrisMorgan> I'm concerned about the example in extra::net::tcp; it sends a kill signal to the socket descriptor if accept() fails. That would mean such an error as ECONNABORTED, if the other end aborts the connection in the interim, will kill the socket entirely and lead to no more connections being accepted.
[14:34:13] <dbaupp> cmr: heh
[14:34:26] <gour> reading about the language (tutorial) and it looks very nice
[14:34:40] *** Quits: Blei (philipp@moz-1D7F398F.ethz.ch) (Quit: WeeChat 0.4.1)
[14:35:08] <dbaupp> ChrisMorgan: I wouldn't worry too much... all that code is due for removal :)
[14:35:17] <gour> it has type-safety in the mood of the haskell and wonder whether it could be pragmatic like f# which i consider
[14:35:20] <dbaupp> (hopefully soon.)
[14:35:39] <cmr> gour: I find it a quite pragmatic language
[14:35:45] <ChrisMorgan> dbaupp: any approximate ETA for it?
[14:35:47] *** Joins: pyrac (pyrac@9F71F32A.73C89388.AD05C589.IP)
[14:35:55] <cmr> ChrisMorgan: "when it's done"
[14:36:02] <dbaupp> ChrisMorgan: no idea
[14:36:07] <ChrisMorgan> Not "6-8 weeks"? ;-)
[14:36:15] <cmr> I imagine it will be less than that
[14:36:22] <gour> cmr: well, fsharp has, at least, gtk# bindings to write gui app, but wonder if anything is available for rust?
[14:36:32] <cmr> gour: No, not yet, too young
[14:36:42] <cmr> Doesn't have the advantage of building on a mature platform like .net
[14:37:05] <gour> cmr: i see...any estimation when we might see something and what?
[14:37:17] <cmr> gour: nobody is working on it atm, so nope
[14:37:37] <gour> besides fsharp, i also consider to simply use python+kiwi, but would prefer type-safe & compiled language
[14:38:07] <cmr> "Kiwi is pure Python and should work cross-platform, but is developed on Python 2.4, Linux ix86." yikes
[14:38:34] <gour> rust would probably use only C libs due to ffi
[14:38:42] *** Quits: novabyte (Instantbir@moz-3E0F9699.cable.virginmedia.com) (Ping timeout)
[14:38:47] <cmr> right
[14:39:00] <cmr> A C++ FFI in line with what D does is planned
[14:39:05] *** Joins: MaikKlein (maik@moz-51F0F9C8.dip0.t-ipconnect.de)
[14:39:06] *** Joins: jorendorff (jorendorff@moz-2F32ACA3.hsd1.tn.comcast.net)
[14:39:29] *** Joins: jpochyla (jpochyla@moz-8D99AE5D.broadband18.iol.cz)
[14:39:36] <gour> that's probably to oweak to bind qt, right'
[14:39:45] <gour> ?
[14:39:47] <cmr> dunno
[14:40:17] <cmr> Qt has SMOKE, which Go uses for bindings, but no one knows if rust's memory model conflicts with that yet
[14:41:04] <gour> hmm
[14:41:17] <dbaupp> cmr: just apply more `unsafe` ;P
[14:41:30] *** Quits: jpochyla (jpochyla@moz-8D99AE5D.broadband18.iol.cz) (Ping timeout)
[14:41:37] <gour> it would be pity not to have decent gui bindings for rust which can definitely replace C(++)
[14:41:51] *** Joins: wilsonk|2 (kvirc@moz-39EFBFC2.cg.shawcable.net)
[14:41:55] <cmr> gour: do I hear a volunteer? ;)
[14:42:31] <cmr> Bindings to any C lib should be fairly easy, although gtk is huge
[14:42:41] <monk> how is servo doing GUI?
[14:42:43] <cmr> there's some gobject introspection for rust somewhere but I'm sure it needs updating
[14:42:50] <cmr> monk: not using a native toolkit
[14:42:53] <gour> cmr: not yet ;)
[14:43:06] <cmr> there's rust-bindgen which can suck in C headers and spit out a rust binding
[14:43:11] <cmr> doesn't work with macros though
[14:43:26] <gour> .net has nice inititative with xwt to provide kind of wx-like lib
[14:45:37] *** Joins: jedestep (jedestep@moz-9918C03C.natpool.nyu.edu)
[14:45:38] *** Joins: novabyte (Instantbir@moz-3E0F9699.cable.virginmedia.com)
[14:45:56] *** Quits: BitPuffin (quassel@moz-49828767.cust.tele2.se) (Ping timeout)
[14:47:59] *** Quits: novabyte (Instantbir@moz-3E0F9699.cable.virginmedia.com) (Quit: bye bye)
[14:48:27] <dbaupp> cmr: (fwiw, 0.6 builds here... strange.)
[14:48:49] <engla> gtk/glib has a generic binding system, can it work with rust?
[14:48:52] <cmr> dbaupp: might be that I needed a clean-llvm
[14:48:55] <engla> gobject-introspection
[14:48:56] <dbaupp> cmr: (at least it got through the LLVM compile)
[14:49:05] *** Joins: BitPuffin (quassel@moz-49828767.cust.tele2.se)
[14:49:21] <cmr> engla: https://github.com/mzabaluev/grust
[14:49:25] <cmr> engla: I'm sure it needs updating though
[14:49:31] <jdm> monk: servo's using glut and glfw right now
[14:49:34] <jdm> there are bindings for both
[14:49:34] <dbaupp> cmr: (don't worry too much about it; I just think it'd be nice to see if Rust is making progress or not.)
[14:49:41] <jdm> we don't have much in the way of actual GUI, though
[14:49:44] <engla> nice. sure, it's probably hard
[14:49:45] <SimonSapin> Does this ring any bell?  task failed at 'enum value matched no variant', â€¦/libstd/repr.rs:543
[14:49:46] <jdm> just handling keys and mouse events
[14:50:03] <cmr> SimonSapin: are you doing an unsafe variant?
[14:50:05] <dbaupp> SimonSapin: that sounds like transmuting an int to an enum
[14:50:06] <cmr> erm, unsafe cast
[14:50:21] *** Quits: sw17ch (sw17ch@moz-675AFBCF.hsd1.mi.comcast.net) (Quit: sw17ch)
[14:50:30] <SimonSapin> Iâ€™m using println(fmt!("%?", json)); with json being of type ~[extra::json::Json]
[14:50:43] <dbaupp> that's pretty strange
[14:51:05] * gour hopes rust is meant to be used for writing gui apps
[14:51:15] <dbaupp> gour: yes
[14:51:25] <monk> jdm: ahh cool, thanks for the info
[14:51:37] <thiez> looking at that json library, it should probably be rewritten to use regions instead of spamming ~
[14:51:37] <dbaupp> gour: (it's just Rust isn't meant for writing any apps yet.)
[14:51:42] <dbaupp> thiez: yes
[14:51:50] <dbaupp> thiez: it's > 10x slower than Python
[14:51:55] *** Quits: Lilly (PinkLace@moz-145A6857.bredband.comhem.se) (Quit: Byeee~~~~)
[14:52:04] <cmr> well python's json lib is written in C
[14:52:07] <thiez> that's horrible :D
[14:52:18] <thiez> cmr: are you suggesting we can't beat C? ;)
[14:52:22] <dbaupp> cmr: right, and Rust should be faster!
[14:52:33] <engla> python implements json in C though
[14:52:49] <dbaupp> (we should at least be within 2x, if not equal.)
[14:52:50] * engla is a parrot
[14:52:50] *** Quits: jdm (jdm@CAB30FBD.8F96AEA7.2D179A7D.IP) (Quit: Lost terminal)
[14:53:02] *** Joins: ghrust (ghrust@C8693FCB.6A2AE50.F3114085.IP)
[14:53:02] <ghrust> 01[13rust01] 15bors 04force-pushed 06auto from 1468fa9d7 to 14e07e9bb: 02http://git.io/N3iJvQ
[14:53:02] *** Parts: ghrust (ghrust@C8693FCB.6A2AE50.F3114085.IP) ()
[14:53:05] *** Joins: ghrust (ghrust@24260B07.6A2AE50.F3114085.IP)
[14:53:05] <ghrust> 01[13rust01] 15bors pushed 2 new commits to 06auto: 02http://git.io/0jQU0w
[14:53:05] <ghrust> 13rust/06auto 145007fb2 15Luqman Aden: Add x64 windows to platform.mk and mingw64 header fixes.
[14:53:05] <ghrust> 13rust/06auto 14372f3d0 15bors: auto merge of #7547 : luqmana/rust/mingw64, r=yichoi...
[14:53:06] *** Parts: ghrust (ghrust@24260B07.6A2AE50.F3114085.IP) ()
[14:53:13] <cmr> engla: you asked a question I had already answered about gobject-introspection too :p
[14:54:05] <gour> dbaupp: by the end of the year there should be 1.0?
[14:54:09] <dbaupp> cmr: can't even get 0.1 to configure properly :(
[14:54:11] <cmr> gour: probably not
[14:54:22] *** Joins: bytewise (bytewise@moz-649C630D.unitymediagroup.de)
[14:54:29] <cmr> gour: https://github.com/mozilla/rust/issues/milestones
[14:54:30] <dbaupp> gour: northern-hemisphere spring 2014 was one approximate date I saw someone say
[14:54:30] *** Quits: g5pw (g5pw@moz-94F4170D.retail.telecomitalia.it) (Quit: g5pw)
[14:54:44] <engla> cmr: I'm logging in from my dementia home, you seem like a nice young man
[14:54:46] <cmr> gour: need at least maturity #2 for 1.0, minimum
[14:55:05] <monk> is there a roadmap/set of requirements for 1.0?
[14:55:14] <dbaupp> monk: ^^ that link
[14:55:17] <monk> ahh okay
[14:55:36] *** Quits: jorendorff (jorendorff@moz-2F32ACA3.hsd1.tn.comcast.net) (Quit: jorendorff)
[14:55:55] <gour> what is expected performance of rust when comparing with C(++)?
[14:56:08] <cmr> gour: equal or better
[14:56:22] <cmr> gour: (probably slightly better due to better aliasing guarantees)
[14:56:42] *** Joins: RMF (RMF@moz-2CA5F393.dsl.telepac.pt)
[14:57:04] <cmr> gour: https://gist.github.com/huonw/5553335
[14:57:30] <gour> cmr: thanks
[14:57:31] <dbaupp> (note the warnings though :) )
[14:57:46] * dbaupp was silly making outrageous claims like that
[14:58:10] <gour> so, we might start playing with the language, try to bind some C lib which we need...until gui matures somewhat
[14:58:56] <dbaupp> if you are binding libs, https://github.com/crabtw/rust-bindgen could help
[14:58:57] <cmr> gour: the route MaikKlein is taking is writing the GUI in C++ and interop with Rust via a C interface
[14:59:39] <gour> it looks as nicer language than fsharp, with better support than stuff we explored like cobra (net), nimrod etc.
[15:00:19] <dbaupp> cmr: http://www.reddit.com/r/rust/comments/1hmjzv/is_rust_slim_yet_rustc_memory_profiles/cavuirg
[15:00:24] <cmr> gour: rust is still (pre-)alpha with regular breaking changes though, and numerous bugs in the compiler, so, probably not a good idea to use rust :)
[15:00:27] <dbaupp> cmr: (time-passes? ;) )
[15:00:46] <cmr> dbaupp: fine, but I'm not parsing it for you :p
[15:00:53] *** Quits: dherman (dherman@moz-6CA476B1.hsd1.ca.comcast.net) (Quit: dherman)
[15:00:55] <dbaupp> cmr: np
[15:02:41] <cmr> dbaupp: should start appearing in the stderr after this next one finishes (running on ea31b9c atm)
[15:02:52] <dbaupp> cmr: stderr, or stdout?
[15:03:00] <cmr> erm, stdout, sorry
[15:03:12] * dbaupp hacks a parser
[15:03:27] <ChrisMorgan> How long does ``make check`` generally take? (On whatever hardware you normally do it on.)
[15:03:32] *** Joins: pnathan1 (Adium@moz-E3C3FAF2.hfc.comcastbusiness.net)
[15:03:46] <cmr> ChrisMorgan: the first build will take ~1hr 20min
[15:03:53] <cmr> most of it from building llvm
[15:04:13] <Ms2ger> cmr, that's not make check though, is it?
[15:04:14] <cmr> subsequent builds will take ~12-20 minutes for rust, ~12 minutes for testsuite iirc
[15:04:33] <cmr> Ms2ger: depends on where you start
[15:04:49] <gour> cmr: but rust seems to have some nice/bright future...i tried with haskell in the past, considered ocaml, ada, D...
[15:05:08] <cmr> gour: the future is not the present, but feel free to give it a go
[15:05:16] *** Joins: join (DrunkenPan@745B767B.989A61DC.CA5B6332.IP)
[15:05:24] <Yoric> cmr: No, a rust.
[15:05:34] <cmr> har har :p
[15:05:36] <Yoric> No way we'll give it a go on this channel.
[15:05:43] * gour is thinking about backing by mozilla
[15:05:56] <cmr> gour: and samsung!
[15:06:03] *** Joins: nano (nano@moz-972880B.superkabel.de)
[15:06:06] *** Joins: Yurume_ (yurume@AC58A8CE.8A059B47.E313B915.IP)
[15:06:54] <gour> cmr: that i was not aware of...even better ;)
[15:07:12] *** Quits: Yurume (yurume@AC58A8CE.8A059B47.E313B915.IP) (Ping timeout)
[15:08:00] <cmr> dbaupp: time-passes in the memory bench too.
[15:08:11] <dbaupp> cmr: ?
[15:08:28] <cmr> dbaupp: the time-passes data will be in both files, mem.json and time.txt
[15:09:06] <dbaupp> cmr: oh, ok, yeah, memory bench will be most useful, since it's going to be correlated against the memory profile
[15:09:16] <dbaupp> cmr: is it going at the top or bottom of time.txt?
[15:09:21] <cmr> Actually, it won't be in time.txt ... yet. I'll have to tweeze apart the output from time
[15:09:42] *** Quits: pnathan1 (Adium@moz-E3C3FAF2.hfc.comcastbusiness.net) (Ping timeout)
[15:10:01] <dbaupp> cmr: it'd be most convenient to have it either in a separate file or at the bottom of time.txt, fwiw
[15:10:01] <cmr> dbaupp: eventually time.txt will become time.json, with stdout, stderr, and time, hopefully
[15:10:08] <dbaupp> right, ok
[15:11:33] <gour> which build system is used by rust?
[15:11:46] <cmr> gour: uses GNU Makefiles
[15:11:57] <cmr> will eventually use our very own rustpkg
[15:12:14] <doener> dbaupp: methods should be mostly the same as function now, except that "self" is always a opaque box pointer (i.e. cast required) and by-value self is actually by-ref
[15:12:16] <cmr> (makefiles plus a configure script, that is)
[15:12:29] <doener> dbaupp: to answer your question from hours ago...
[15:12:34] <dbaupp> doener: I see, so an extra layer of indirection
[15:12:45] <gour> cmr: rustpkg is/would be capable to build 3rd aprty C libs as well?
[15:12:51] <cmr> gour: yes
[15:12:53] <dbaupp> doener: is there any possibility of by-val self being actually by-val?
[15:12:55] <gour> cool
[15:13:20] <cmr> gour: it has to, to be able to build rust, we use libuv, linenoise, and llvm :)
[15:15:08] <doener> dbaupp: would require a specific self slot / env slot that has the right type. For example i64 wouldn't fit into a pointer slot on x86. Not sure how calls via trait objects would deal with that.
[15:15:17] <engla>     let f: extern fn(int) -> int = |x| { x + 1 };
[15:15:35] <engla> bblum: do you know where to start to implement that ^
[15:16:51] <doener> dbaupp: luckily by-val self isn't possible with trait objects, so some casting might do the trick
[15:17:46] <dbaupp> doener: right, so it'd be an optimisation that's occasionally possible, rather than something that could be guaranteed?
[15:19:38] *** Quits: fabiand (fabiand@moz-EDBC4C50.adsl.alicedsl.de) (Quit: Verlassend)
[15:20:45] <doener> dbaupp: true by-val self for values that can be passed as immediates? Should always be doable. You just have to put use the actual type instead of an opaque box pointer. Dropping the cast for the other variants might be a problem (just guessing) because of trait objects.
[15:21:19] <cmr> Shouldn't the *caller* of a trait object method do the casting, ont the method itself?
[15:21:39] <cmr> wait, does that even make sense
[15:21:42] <cmr> now I'm confused
[15:21:56] * cmr goes to eat lunch
[15:22:04] <doener> cmr: it could cast the method to pretend that the self slot accepts an opaque box pointer
[15:22:21] <doener> cmr: but that's what broke the glue inling IIRC
[15:22:29] *** Joins: jdm (jdm@F2D29657.F60B0462.67AC9B1.IP)
[15:22:54] <doener> I'm not 100% sure whether we just did the glue stuff wrong, or whether such a cast is plain illegal
[15:23:13] *** Quits: pyrac (pyrac@9F71F32A.73C89388.AD05C589.IP) (Ping timeout)
[15:23:46] *** Joins: dherman (dherman@moz-6CA476B1.hsd1.ca.comcast.net)
[15:23:47] *** ChanServ sets mode: +o dherman
[15:25:09] *** Quits: nano (nano@moz-972880B.superkabel.de) (Connection reset by peer)
[15:25:13] *** Quits: etw (john@moz-B2936CAB.nyc.res.rr.com) (Ping timeout)
[15:26:13] *** Joins: Kruppe (user@moz-4DDA8AB8.uwaterloo.ca)
[15:26:45] *** Joins: graydon (graydon@moz-9918B407.vc.shawcable.net)
[15:26:45] *** ChanServ sets mode: +qo graydon graydon
[15:26:58] <graydon> I take it something's wrong with win1?
[15:27:02] *** Joins: wilsonk-laptop (kvirc@moz-39EFBFC2.cg.shawcable.net)
[15:27:06] <graydon> oh, huh
[15:27:10] <graydon> built!
[15:27:34] *** Quits: wilsonk|2 (kvirc@moz-39EFBFC2.cg.shawcable.net) (Ping timeout)
[15:27:48] *** Joins: jpochyla (jpochyla@moz-8D99AE5D.broadband18.iol.cz)
[15:28:08] *** Quits: jedestep (jedestep@moz-9918C03C.natpool.nyu.edu) (Ping timeout)
[15:29:17] <ChrisMorgan> ... what? No methods to change the case of a string?
[15:29:29] *** Joins: etw (john@moz-B2936CAB.nyc.res.rr.com)
[15:29:43] <thiez> 'fraid not, unless you change it to Ascii and back
[15:29:51] <thiez> it's really very inconvenient.
[15:29:56] <engla> ChrisMorgan: right, no full unicode tables included.
[15:30:03] <ChrisMorgan> :-(
[15:30:13] <dbaupp> engla: the tables are there... just not the algorithms
[15:30:27] <klutzy> upper/lower includes Ã¡ <-> Ã and so on
[15:30:33] <ChrisMorgan> Naturally.
[15:30:52] <engla> don't think so dbaupp 
[15:31:03] <dbaupp> engla: std::unicode
[15:31:54] <engla> yeah those are the character categories
[15:31:55] <ChrisMorgan> thiez: how can I convert it to ASCII? I know that the stuff I'm converting is ASCII-only (well, the thing I then compare it to is ASCII uppercase, anyway).
[15:32:14] <ChrisMorgan> ... and I hope you're not going to say str.map_chars(|c| unsafe {libc::toupper(c as c_char)} as char) ;-)
[15:32:33] <dbaupp> ChrisMorgan: .to_ascii()
[15:32:42] <dbaupp> (I think)
[15:32:46] <thiez> the ascii stuff is a disaster to work with though
[15:33:12] <ChrisMorgan> I see a str.only_ascii() -> bool, but no str.to_ascii()
[15:33:22] *** Quits: dherman (dherman@moz-6CA476B1.hsd1.ca.comcast.net) (Quit: dherman)
[15:33:26] <dbaupp> rusti: println(fmt!("%?", "foo".to_ascii()))
[15:33:38] <thiez> try looking in libstd/str/ascii.rs
[15:33:43] <thiez> I think that's where it's hidden.
[15:33:45] *** Quits: rusti (rusti@moz-54F7FD49.cpe.net.cable.rogers.com) (Ping timeout)
[15:33:46] *** Joins: rusti (rusti@moz-54F7FD49.cpe.net.cable.rogers.com)
[15:33:49] <dbaupp> ChrisMorgan: it's in std::ascii
[15:33:54] <dbaupp> rusti: println(fmt!("%?", "foo".to_ascii()))
[15:33:55] -rusti- &[{chr: 102}, {chr: 111}, {chr: 111}]
[15:33:55] -rusti- ()
[15:34:03] <engla> dbaupp: I don't think the category tables are enough
[15:34:34] <dbaupp> engla: yeah, I don't really know much about the details of unicode case folding etc.
[15:35:14] <engla> a unicode library would normally be 2MB of data or more
[15:35:29] <engla> unicode.rs is 128k
[15:35:50] <engla> the letter, uppercase does not have a one-to-one correspondance with letter, lowercase  category.. etc.
[15:36:04] <engla> but a part of it could have
[15:37:12] <kimundi> rusti: "Foobar".to_ascii().to_upper().to_str_ascii()
[15:37:13] -rusti- ~"FOOBAR"
[15:39:17] <kimundi> rusti: "Foobar".to_ascii().to_upper().iter().transform(|c| (c.to_byte() + 2)).collect::<~[Ascii]>().to_ascii().to_str_ascii()
[15:39:19] -rusti- more than 5 lines of output, pastebinned: http://sprunge.us/OBUO
[15:39:36] <ChrisMorgan> Hmm. rusti is pretty cool.
[15:39:38] <dbaupp> engla: right, yeah
[15:39:57] <kimundi> rusti: "Foobar".to_ascii().to_upper().iter().transform(|c| (c.to_byte() + 2).to_ascii()).collect::<~[Ascii]>().to_str_ascii()
[15:39:58] -rusti- more than 5 lines of output, pastebinned: http://sprunge.us/dHSd
[15:40:53] <kimundi> rusti: let s = "Foobar"; fmt!("%?", s.to_ascii().to_upper().iter().transform(|c| (c.to_byte() + 2).to_ascii()).collect::<~[Ascii]>().to_str_ascii())
[15:40:54] -rusti- more than 5 lines of output, pastebinned: http://sprunge.us/WSTQ
[15:41:42] <kimundi> rusti: let s = "Foobar"; let x = s.to_ascii().to_upper(); fmt!("%?", x.iter().transform(|c| (c.to_byte() + 2).to_ascii()).collect::<~[Ascii]>().to_str_ascii())
[15:41:43] -rusti- ~"~\"HQQDCT\""
[15:41:55] <kimundi> ha! success :P
[15:43:55] <kimundi> ChrisMorgan: The ascii stuff is in std::ascii
[15:44:17] <ChrisMorgan> Yep, I got it all working, thanks.
[15:44:49] <kimundi> it looks terrible verbose, but better than having inconsistent functionality on the base str type
[15:45:21] *** Quits: BitPuffin (quassel@moz-49828767.cust.tele2.se) (Ping timeout)
[15:45:58] <kimundi> there used to be a str::to_upper and to_lower... they completly ignored that a str contains utf8, instead just put each byte through the libc to_upper function
[15:46:19] <engla> yeah that's bad
[15:46:38] *** Quits: MaikKlein (maik@moz-51F0F9C8.dip0.t-ipconnect.de) (Ping timeout)
[15:47:41] <kimundi> What's needed to make that stuff less painfull is that a) dynamic sized types becomes a thing, so that `str` becomes a proper type, and b) the ability to typedef new dsts
[15:48:02] <kimundi> could then have a AsciiStr, Latin1Str etc
[15:48:32] <engla> not sure if Latin1Str is useful
[15:48:57] <engla> it's a legacy encoding
[15:48:58] *** Quits: jpochyla (jpochyla@moz-8D99AE5D.broadband18.iol.cz) (Ping timeout)
[15:49:02] <Ms2ger> Latin1Str sounds like a terrible idea
[15:49:07] <kimundi> well, maybe not as seperate type. But a generic fremwork for arbitrary string encodings
[15:49:13] <bstrie> engla: is Latin1 still the default on windows?
[15:49:25] * Ms2ger doesn't approve of arbitrary string encodings
[15:49:25] <engla> microsoft doesn't use the standard latin-1 either
[15:49:36] *** Joins: Cromulent (Cromulent@moz-983B638D.cable.virginmedia.com)
[15:49:41] <bstrie> terrible
[15:49:52] <bstrie> EcbdicStr
[15:50:00] <kimundi> just some way to hold a specific encoding of a string in a datatype, and convert it to other if neccessarry
[15:50:16] <bstrie> ShittyWindowsLatin1Str
[15:50:27] <engla> that's good
[15:50:33] <bstrie> MicrosoftThisIsWhyWeCantHaveNiceThingsStr
[15:50:47] <kimundi> having a seperate type for each like for utf8 sounds like a good system in my mind. (clearly they should not be used primarly)
[15:50:49] <dbaupp> UTF16Str might be useful
[15:50:57] <Yoric> bstrie: You forgot a "A" or a "W" at the end of the symbol.
[15:51:21] <bstrie> Yoric: I'm happy that I don't understand that reference
[15:51:50] <dbaupp> kimundi: we could have an encodings library in extra (or somewhere else) for the less common ones.
[15:51:59] <kimundi> yeah
[15:52:06] <Yoric> bstrie: In the Windows libraries, many symbols are defined twice, once suffixed with "A" (uses 8-bit strings) and once suffixed with "W" (uses 16-bit strings).
[15:52:25] <SimonSapin> Iâ€™m planing on implementing http://encoding.spec.whatwg.org/ at some point
[15:52:27] <bstrie> hilarious
[15:52:31] <thiez> UTF32Str ftw
[15:52:41] <bstrie> thiez: I think that's [char] :P
[15:52:46] <Ms2ger> There's a type for random encodings already, [u8]
[15:53:14] <thiez> bstrie: excellent, let's use that one
[15:53:15] <kimundi> Ms2ger: Thats not really a type for encodings. :P It's a list of bytes
[15:53:17] <ChrisMorgan> *Finally*. Took almost two hours for that first ``make check``.
[15:53:20] <thiez> much easier to index :p
[15:53:27] *** Joins: MaikKlein (maik@moz-51F0F9C8.dip0.t-ipconnect.de)
[15:53:38] <Ms2ger> kimundi, exactly :)
[15:53:53] <ChrisMorgan> But that's what you get for still using a seven-year-old laptop. It's not used to needing to cope with compiling _quite_ such big things.
[15:54:11] <SimonSapin> kimundi: yes. Random bytes from the nextwork or files are [u8], text is str or [char] or something, and encodings convert between the two
[15:54:21] <kimundi> Ms2ger: The point of making them own types would be to ensure that the encoding-specific invariants allways hold, without needing to assert them on each function that uses them
[15:55:25] <kimundi> That's why Ascci is not a u8: It holds the invariant that the msb is allways unset
[15:55:44] <Ms2ger> kimundi, why? You just decode them when getting them out of the file, and use utf-8 strings ever after
[15:55:49] <phrawzty> let x: float = 1.50; println(x.to_str); // am i interpreting the resulting error message correctly, that .to_str doesn't operate on floats ?
[15:55:57] <engla> and lets the type checker do the checking too
[15:56:05] <bstrie> phrawzty: you need .to_str()
[15:56:08] <bstrie> not .to_str
[15:56:27] <SimonSapin> kimundi: you should do the Unicode Sandwich: you get bytes from the outside, decode them as soon as possible into text, manipulate text internally, and encode back to bytes as late as possible when you have to for I/O
[15:56:29] <bstrie> rusti: let x = 1.50; x.to_str()
[15:56:31] -rusti- more than 5 lines of output, pastebinned: http://sprunge.us/BTgW
[15:56:31] <phrawzty> bstrie: right. yes. thanks. o_o
[15:56:45] <bstrie> rusti: let x = 1.50f; x.to_str()
[15:56:46] -rusti- ~"1.5"
[15:56:47] <kimundi> Ms2ger: But whad if you don't want to decode them into utf8? Say some kind of legacy interface that has to use old encodings for library apis
[15:56:50] <bstrie> phrawzty: ^
[15:57:05] <bstrie> phrawzty: are you from ruby, by chance? :)
[15:57:17] <phrawzty> bstrie: most recently, yes. :)
[15:57:41] <phrawzty> bstrie: sad about .each having been removed, for example. ;P
[15:58:10] <bstrie> phrawzty: we tried to make wuby-style internal iteration work for a long time, in the end it just wasn't enough
[15:58:15] <bstrie> er. ruby-style...
[15:58:25] <bstrie> how did I even make that typo...
[15:58:42] * bstrie using some kind of elmer fudd keyboard
[15:58:44] <phrawzty> "wuby", i like it.
[16:00:59] *** Quits: join (DrunkenPan@745B767B.989A61DC.CA5B6332.IP) (Ping timeout)
[16:01:19] <bstrie> phrawzty: in rust, if you see `.foo()` then it is *always* a method, and `.foo` is *always* a property. even if you have a first-class function as a property on an object, we force you to invoke it like `(bar.foo)()`
[16:02:00] <phrawzty> bstrie: ok, good to know.
[16:02:03] <phrawzty> thanks
[16:02:58] *** Quits: bjz_ (brendanzab@B398BE78.F804C29E.D35A31DF.IP) (Connection reset by peer)
[16:02:58] *** Joins: bjz (brendanzab@B398BE78.F804C29E.D35A31DF.IP)
[16:04:14] <engla> except in do and for syntax, there you can leave out ()
[16:05:55] <doener> dbaupp: do you have perf data for that json benchmark?
[16:06:10] <dbaupp> doener: http://ix.io/6tV
[16:06:24] <dbaupp> doener: (I literally just sent an email to the ML with that link, heh)
[16:06:39] * doener didn't see the link, read the mail on his phone
[16:06:49] <dbaupp> doener: oh
[16:06:52] <dbaupp> doener: that was quick
[16:06:54] <pnkfelix> dbaupp: can I get that input json file that you mentioned on rust-dev ?
[16:07:12] <doener> would like to have that, too
[16:07:22] <dbaupp> pnkfelix: any of the mem.json files in a subfolder of http://hnn.mrsd.org/~cmr/
[16:07:28] <pnkfelix> dbaupp: thanks
[16:11:37] <bstrie> engla: that actually raises a good point... if strcat's proposal goes through, then `for x.foo |bar| {` is no longer unambiguous
[16:12:01] <brendanc> graydon: if you look down the waterfall to about 8:30 last night you can see an example or two of what happens when you don't kill pending builds
[16:12:15] <graydon> brendanc: I put the pending-killer in
[16:12:20] *** Quits: SimonSapin (simon@88F51059.F3BBB17D.144F44FA.IP) (Ping timeout)
[16:12:21] <graydon> brendanc: yesterday, when I upgraded it
[16:12:25] <brendanc> huh, I guess it isn't working.
[16:12:28] <graydon> I added the bit of code you sent :)
[16:12:47] <brendanc> (worked in my test setup)
[16:13:21] <cmr> I'm still not used to seeing my name online
[16:13:26] <dbaupp> bstrie: there'd be no longer any need for closure sugar for for (heh), so that would presumably be unambiguously a property access
[16:13:35] <dbaupp> cmr: sorry ;(
[16:13:41] <cmr> it's fine
[16:13:51] <bblum> engla: i don't understand your question
[16:14:13] <bblum> engla: seems to me what you want to write is fn f(x: int) -> int { x + 1 }
[16:14:22] <engla> bblum: allow creating extern fn  from lambda syntax
[16:14:46] <bblum> why?
[16:15:04] <bstrie> dbaupp: right, we'd have to force people to write `for x.foo()` if they wanted to iterate over the return value of foo, and that's inconsistent with do-notation, so that's basically a huge +1 to the `for bar in qux` proposal
[16:15:06] <engla> extern fn is Sendable and copyable. it's the most versatile building block for closures
[16:15:25] <bblum> you... can't build closures with an extern fn though
[16:15:29] <bblum> they can't close over anything
[16:15:42] <dbaupp> bstrie: yeah, sounds reasonable
[16:15:50] <engla> bblum: it's like in niko's closure reform blog post
[16:16:15] <engla> also, lambda syntax doesn't require type and type parameters to be specified
[16:16:23] <engla> so it's vastly more usable
[16:16:59] <engla> and extern fn being the most basic and versatile function type, allows simpler code when no captures are needed. it's automatically borrowed to &fn when used like that
[16:17:14] <engla> and you can put it into a ~Trait object.
[16:18:54] *** Quits: sk (sk@1696E5A5.E92B26F8.78DD174B.IP) (Quit: Leaving)
[16:19:22] *** Quits: pnkfelix (pnkfelix@87C1F78E.1DE10CA8.D8E68FF6.IP) (Quit: Leaving.)
[16:20:06] *** jdm is now known as jdm|muzak
[16:22:38] *** Quits: dbaupp (Thunderbir@moz-712A1135.lns20.syd6.internode.on.net) (Ping timeout)
[16:24:34] <doener> http://i.minus.com/1373041398/43t7zpBOcgy3CeDpkSht0w/inUqVLvZGEUfx.svg -- flamegraph for the json benchmark. read_char is pretty heavy
[16:27:09] <cmr> doener: how do you make a flamegraph?
[16:27:10] <sp3d> hrm, rsvg-view can't handle that :x
[16:27:22] <doener> sp3d: works in firefox for me
[16:27:29] <sp3d> oh, it's a web page
[16:28:22] <doener> heh, takes only half as long if I use a large enough min stack size
[16:28:33] *** Joins: mnemotic (niko@8FFD1BD2.9D81E74C.53DF0002.IP)
[16:28:52] <doener> cmr: perf + tools from http://dtrace.org/blogs/brendan/2012/03/17/linux-kernel-performance-flame-graphs/
[16:29:08] <cmr> it really seems like segmented stacks are not worth it
[16:29:13] <cmr> or our implementation is broke-ass
[16:29:19] <doener> cmr: note that his stackcollapse script by default only cares about kernel functions, so you have to adjust that for userspace stuff
[16:30:36] <doener> cmr: and you'll want to record with "perf -gdwarf", not just -g
[16:31:11] <doener> err, perf record -gdwarf
[16:31:15] <engla> bblum: for example here, a sketch of allowing lambda syntax to make extern fn's http://smallcultfollowing.com/babysteps/blog/2013/05/30/removing-procs/
[16:32:46] <bblum> engla: i don't think those are extern fns
[16:32:58] <bblum> those are still allowed to, and indeed supposed to, capture their environments
[16:33:07] <engla> no, look at the spawn example
[16:33:27] <engla> fn spawn<T:Send>(arg: T, body: extern fn(T));
[16:33:35] <engla> it's using explicit capture
[16:34:00] <engla> I'm just saying that extern fn is the most versatile building block, so we have lots to win by exposing it in lambda syntax form
[16:34:17] *** Quits: Cromulent (Cromulent@moz-983B638D.cable.virginmedia.com) (Quit: KVIrc 4.2.0 Equilibrium http://www.kvirc.net/)
[16:35:17] <engla> I figure it shouldn't be too hard. A &fn is just (extern fn(..), Environment) today
[16:35:26] <engla> so it evidently already is the building block of closures
[16:35:52] <bblum> it's also the most inconvenient building block, because capturing environments is less painful than passing values around
[16:36:17] <engla> we can have both
[16:36:34] <engla> but I think it's better to have simple building blocks than lots of complicated types like ~once fn
[16:36:35] <bblum> we can, but i don't think it'll be useful in many places
[16:36:53] *** Joins: jedestep (jedestep@moz-9918C03C.natpool.nyu.edu)
[16:37:01] <bblum> also, replacing existential quantification with universal quantification would cause commonly-used functions like 'spawn' to have to be monomorphized many basically once for every spawn call in the program
[16:37:07] <engla> ok, but right now there is no Sendable closure. That's easy to make if the thunk is constructed in a library
[16:37:18] <bblum> ~fn() is sendable
[16:37:44] <engla> ok yeah I'm wrong
[16:37:53] <engla> ~once fn() has many of the good properties
[16:38:42] <bblum> existential quantification is also useful when you want to have a collection of heterogeneous objects; for example, ~[~fn()]
[16:38:44] *** Quits: jedestep (jedestep@moz-9918C03C.natpool.nyu.edu) (Ping timeout)
[16:38:52] <engla> you can use trait objects
[16:38:53] <engla> ~Thunk
[16:39:16] <engla> also you can construct a non-once  "closure" that can modify its upvars
[16:39:35] <bblum> right
[16:40:08] <engla> I don't see the downside of allowing lambda syntax to construct extern fn
[16:40:24] <engla> except for being work that's just complicated and distracting
[16:40:39] <engla> but I wanted to ask if you knew if it's possible and where I can start.
[16:40:48] <bblum> that would basically be it
[16:40:57] <bblum> i mean, i'm not opposed to it on principle, just questioning its usefulness
[16:41:10] *** Quits: MaikKlein (maik@moz-51F0F9C8.dip0.t-ipconnect.de) (Ping timeout)
[16:41:11] <bblum> as to where to start...
[16:41:54] *** Joins: jedestep (jedestep@moz-2C53377F.natpool.nyu.edu)
[16:41:57] *** Joins: jensnockert (jensnocker@moz-C5F27039.cust.bredband2.com)
[16:42:13] *** Joins: judder (maradukewa@5B9E91E7.2C8A8E2E.78E362FE.IP)
[16:42:19] <bblum> you would figure out whether to emit ty_closure or ty_bare_fn in typeck/astconv.rs
[16:43:04] <engla> ok
[16:43:41] *** Quits: jensnockert (jensnocker@moz-C5F27039.cust.bredband2.com) (Ping timeout)
[16:43:52] <bblum> after that i think most of the machinery would adapt automatically, for example, look at fn check_for_bare in kind.rs
[16:45:10] *** Joins: eagen (eagen@moz-92A457CB.hsd1.mn.comcast.net)
[16:45:32] <ChrisMorgan> x.to_str().as_bytes() doesn't work, as to_str() returns a ~str, and then there's a lifetime problem with regards to as_bytes; what can I do about it?
[16:46:03] <cmr> ChrisMorgan: what's the exact code you're using? context matters a lot in rust, especially with lifetimes
[16:46:29] <engla> bblum: much appreciated
[16:46:52] <bblum> np
[16:47:20] *** Quits: parcha (quassel@moz-A9A9F340.hsd1.ma.comcast.net) (Client exited)
[16:47:27] <ChrisMorgan> cmr: minimal case is `(~"").as_bytes()`
[16:47:31] *** Joins: parcha (quassel@moz-A9A9F340.hsd1.ma.comcast.net)
[16:47:52] <cmr> rusti: let x = (~"").as_bytes(); println(fmt!("%?", x));
[16:47:54] -rusti- more than 5 lines of output, pastebinned: http://sprunge.us/FPbA
[16:48:36] <cmr> ChrisMorgan: hm, should be able to stash the string in a local variable to fix that
[16:48:54] <ChrisMorgan> Erk. That's not nice.
[16:49:52] <cmr> not sure why, exactly, I would imagine the ~str to live for the whole stack frame.
[16:49:52] <phrawzty> in the rust world, is using a simple loop { if [condition] { break; } }; structure considered clean ?
[16:49:59] *** Quits: mark_edward (quassel@moz-4A9A2F15.dynamic.utc.edu) (Connection reset by peer)
[16:50:10] <doener> let x = ~""; println(fmt!("%?", x.as_bytes()));
[16:50:15] <doener> rusti: let x = ~""; println(fmt!("%?", x.as_bytes()));
[16:50:16] -rusti- &[]
[16:50:16] -rusti- ()
[16:50:36] <cmr> phrawzty: we have a while loop :p
[16:50:46] <cmr> at least, I thought we did...
[16:50:55] <cmr> yeah, http://static.rust-lang.org/doc/rust.html#while-loops
[16:51:27] <phrawzty> cmr: just curious, since http://static.rust-lang.org/doc/0.7/tutorial.html introduces the loop / break structure early, so i wondered if it was really used or not.
[16:51:50] <cmr> phrawzty: it's a poor example
[16:51:57] <cmr> don't even know why it's there tbh
[16:52:05] *** Joins: pnathan (Adium@moz-E3C3FAF2.hfc.comcastbusiness.net)
[16:52:07] <phrawzty> ... alright then. glad i asked :)
[16:52:08] <cmr> `loop` is infrequently useful
[16:52:43] <ChrisMorgan> cmr: sounds like it should be filed as a bug?
[16:52:54] <doener> cmr: (~"").method() is like func(~""). So its lifetime ends after the call (and the free call also happens right after the call)
[16:53:14] <SiegeLord> In C++ doing auto a = std::string(a).to_str(); is a bug
[16:53:20] *** Joins: mark_edward (quassel@moz-4A9A2F15.dynamic.utc.edu)
[16:53:24] <SiegeLord> So it seems that Rust is preventing that bug correctly
[16:53:43] <ChrisMorgan> Well, I don't understand what's wrong with it.
[16:54:12] *** Quits: CarpNet (ac@moz-FD24B77.sohonet.co.uk) (Quit: Leaving)
[16:54:12] <engla> ChrisMorgan: as_bytes has a borrowed pointer to the string, and that pointer's lifetime is tied to the lifetime of the ~""
[16:54:14] <SiegeLord> ~"" gets destroyed immediately after the 'let' statement
[16:54:19] *** Joins: jpochyla (jpochyla@moz-8D99AE5D.broadband18.iol.cz)
[16:54:34] <SiegeLord> So... referring to it afterward is incorrect
[16:55:00] <engla> I think you should file a bug if there isn't one already
[16:55:10] <doy> ~str could have a to_bytes method that returned a ~[u8] instead of a &[u8]
[16:55:23] <engla> doy: there already is as_bytes().to_owned
[16:55:25] <cmr> doy: as_bytes().to_owned() :p
[16:55:34] <doy> well, there you go then
[16:55:36] *** Quits: santiago (santiago@moz-8ADE82B4.socal.res.rr.com) (Quit: Computer has gone to sleep.)
[16:55:48] <doener> ChrisMorgan: it's like: char *a = malloc(1); *a[0] = '\0'; char *b = a; free(a); write(b);
[16:56:31] <doener> ChrisMorgan: b is invalid by the time you use it
[16:56:32] <phrawzty> thank you all for your willingness to put up with my new user questions and such. :)
[16:56:34] <ChrisMorgan> I don't see *why* it should be like that.
[16:56:54] *** Joins: ross (ross@moz-8A84103E.br.br.cox.net)
[16:57:22] <ChrisMorgan> Anyway, I'm not going to file-a-bug-and-see-what-happens just now. I need to go to bed. Should have been in bed hours ago...
[16:57:31] <SiegeLord> I think the destructors are called in Rust as soon as you cannot access the variable anymore
[16:57:38] <doener> ChrisMorgan: because ~ is an owned pointer, allocation happens via malloc and free is called when the pointer goes out of scope. In this case, this is when the method call finishes
[16:58:02] *** Quits: pnathan (Adium@moz-E3C3FAF2.hfc.comcastbusiness.net) (Ping timeout)
[16:59:33] *** Joins: brendan (brendaneic@35E90EE3.B8B12C49.396B22AD.IP)
[16:59:58] *** Quits: ChrisMorgan (chris@moz-6AC741CA.static.tpgi.com.au) (Ping timeout)
[17:00:50] <thiez> ~ is not a bug, it's a feature :p
[17:06:29] *** Quits: brendan (brendaneic@35E90EE3.B8B12C49.396B22AD.IP) (Ping timeout)
[17:08:04] *** Quits: davbo (dave@moz-3FFA637C.oucs.ox.ac.uk) (Client exited)
[17:12:17] *** Joins: sankha93 (Instantbir@D8F0AB2E.498FC86C.8B6C1D65.IP)
[17:13:39] <mark_edward> will rust have bidirectional iterators?
[17:13:50] <mark_edward> i think it'd be a good addition
[17:14:29] *** Quits: dwrensha (chatzilla@moz-DE44EA45.hsd1.pa.comcast.net) (Ping timeout)
[17:14:29] <engla> strcat has mentioned it
[17:14:37] <engla> so maybe
[17:18:36] *** Joins: jensnockert (jensnocker@moz-C5F27039.cust.bredband2.com)
[17:20:23] *** Joins: jmgrosen (jmgrosen@moz-848F6087.sb.sd.cox.net)
[17:20:54] *** Quits: jensnockert (jensnocker@moz-C5F27039.cust.bredband2.com) (Ping timeout)
[17:21:27] *** Quits: bjz (brendanzab@B398BE78.F804C29E.D35A31DF.IP) (Quit: Bye!)
[17:21:37] *** Joins: bjz (brendanzab@B398BE78.F804C29E.D35A31DF.IP)
[17:22:23] <sfackler> could someone retry https://github.com/mozilla/rust/pull/7513 ? It looks like the linux64-opt-vg tests timed out
[17:23:29] <sfackler> thanks
[17:24:34] *** Joins: sk (sk@1696E5A5.E92B26F8.78DD174B.IP)
[17:25:33] *** Joins: jensnockert (jensnocker@moz-C5F27039.cust.bredband2.com)
[17:25:39] *** Joins: join (DrunkenPan@745B767B.989A61DC.CA5B6332.IP)
[17:26:00] *** Joins: ghrust (ghrust@2EE61FCC.6A2AE50.F3114085.IP)
[17:26:00] <ghrust> 01[13rust01] 15bors 04force-pushed 06auto from 14372f3d0 to 14e07e9bb: 02http://git.io/N3iJvQ
[17:26:00] *** Parts: ghrust (ghrust@2EE61FCC.6A2AE50.F3114085.IP) ()
[17:26:02] *** Joins: ghrust (ghrust@E7A4CCE2.6A2AE50.F3114085.IP)
[17:26:02] <ghrust> 01[13rust01] 15bors pushed 4 new commits to 06auto: 02http://git.io/hQvqdQ
[17:26:02] <ghrust> 13rust/06auto 145a8a30f 15Steven Fackler: Added functionality to Base64 package...
[17:26:02] <ghrust> 13rust/06auto 141482cf5 15Steven Fackler: Base64 API changes...
[17:26:02] <ghrust> 13rust/06auto 14e9988c1 15Steven Fackler: Upper-cased exported statics
[17:26:03] *** Parts: ghrust (ghrust@E7A4CCE2.6A2AE50.F3114085.IP) ()
[17:26:17] *** Joins: Blei (philipp@moz-650B9C6A.cust.bluewin.ch)
[17:28:39] *** Joins: enix (enix@moz-A50569DD.c3-0.slvr-ubr1.lnh-slvr.md.cable.rcn.com)
[17:29:58] *** Quits: jensnockert (jensnocker@moz-C5F27039.cust.bredband2.com) (Ping timeout)
[17:31:14] *** Joins: jensnockert (jensnocker@moz-C5F27039.cust.bredband2.com)
[17:32:55] *** Quits: eagen (eagen@moz-92A457CB.hsd1.mn.comcast.net) (Ping timeout)
[17:33:00] <bstrie> rusti: "foo".to_buf()
[17:33:00] -rusti- <anon>:7:9: 8:5 error: type `&'static str` does not implement any method in scope named `to_buf`
[17:33:00] -rusti- <anon>:7          "foo".to_buf()
[17:33:01] -rusti- <anon>:8     };
[17:33:01] -rusti- error: aborting due to previous error
[17:33:01] -rusti- application terminated with error code 101
[17:33:10] <bstrie> rusti: ~"foo".to_buf()
[17:33:10] -rusti- <anon>:7:10: 8:5 error: type `&'static str` does not implement any method in scope named `to_buf`
[17:33:10] -rusti- <anon>:7          ~"foo".to_buf()
[17:33:10] -rusti- <anon>:8     };
[17:33:10] -rusti- error: aborting due to previous error
[17:33:10] -rusti- application terminated with error code 101
[17:33:16] <bstrie> rusti: (~"foo").to_buf()
[17:33:16] -rusti- <anon>:7:9: 8:5 error: type `~str` does not implement any method in scope named `to_buf`
[17:33:17] -rusti- <anon>:7          (~"foo").to_buf()
[17:33:17] -rusti- <anon>:8     };
[17:33:18] -rusti- error: aborting due to previous error
[17:33:20] -rusti- application terminated with error code 101
[17:33:34] *** Joins: lmandel (lmandel@moz-BBE1EA67.dsl.bell.ca)
[17:34:21] <bstrie> rusti: "asdf".as_buf()
[17:34:21] -rusti- <anon>:7:9: 8:5 error: type `&'static str` does not implement any method in scope named `as_buf`
[17:34:21] -rusti- <anon>:7          "asdf".as_buf()
[17:34:21] -rusti- <anon>:8     };
[17:34:22] -rusti- error: aborting due to previous error
[17:34:22] -rusti- application terminated with error code 101
[17:34:31] <bstrie> rusti: str::as_buf("asdf")\
[17:34:32] -rusti- <anon>:7:28: 7:29 error: unknown start of token: 92
[17:34:32] -rusti- <anon>:7          str::as_buf("asdf")\
[17:34:32] -rusti-                                      ^
[17:34:32] -rusti- application terminated with error code 101
[17:34:33] <bstrie> rusti: str::as_buf("asdf")
[17:34:35] -rusti- more than 5 lines of output, pastebinned: http://sprunge.us/ihQH
[17:34:42] *** Joins: anri (solancile@moz-A1CFFAE5.hsd1.wa.comcast.net)
[17:34:52] <bstrie> rusti: std::str::as_buf("asdf")
[17:34:53] -rusti- more than 5 lines of output, pastebinned: http://sprunge.us/MXhW
[17:35:05] <bstrie> in case you can't tell, I don't have a computer that can run rust today
[17:35:19] <cmr> bstrie: he listens to queries you know
[17:35:28] *** Quits: jedestep (jedestep@moz-2C53377F.natpool.nyu.edu) (Ping timeout)
[17:36:34] <bstrie> cmr: eh, nobody's speaking on the channel anyway :)
[17:38:02] *** Quits: etw (john@moz-B2936CAB.nyc.res.rr.com) (Quit: etw)
[17:38:43] *** Joins: infynyxx (infynyxx@DB780A29.749BA1D.DCC373F0.IP)
[17:41:17] *** Quits: infynyxx (infynyxx@DB780A29.749BA1D.DCC373F0.IP) (Ping timeout)
[17:41:20] *** Quits: jmgrosen (jmgrosen@moz-848F6087.sb.sd.cox.net) (Quit: jmgrosen)
[17:42:50] *** Joins: jmgrosen (jmgrosen@moz-848F6087.sb.sd.cox.net)
[17:43:49] *** Quits: join (DrunkenPan@745B767B.989A61DC.CA5B6332.IP) (Ping timeout)
[17:47:07] *** Joins: vk (vk@moz-389FEE13.hsd1.ca.comcast.net)
[17:54:20] *** Quits: RMF (RMF@moz-2CA5F393.dsl.telepac.pt) (Quit: Textual IRC Client: www.textualapp.com)
[17:55:43] <Yurume_> error: internal compiler error: ty::Region#subst(): Reference to self region when given substs with no self region: substs(self_r=None, self_ty=Some(T), tps=[U])
[17:55:46] *** Yurume_ is now known as Yurume
[17:55:57] <SiegeLord> I hope Iterator doesn't get renamed to Range
[17:55:59] <Yurume> ugh, any clue on this ICE?
[17:57:08] <cmr> Yurume: iirc using fn foo(&'self self) -> &'self foo{ .... } got me that when using an impl<'self>
[17:57:18] <cmr> don't remember the exact details
[17:57:31] <Yurume> does it occur at the usage and not at the definition?
[17:57:40] <cmr> I don't remember
[17:57:44] <Yurume> hmm.
[17:57:59] <Yurume> I'm (literally) fixing Angolmois to work in 0.7
[18:00:37] *** Joins: doomlord (doomlod@moz-6651F8D4.range86-145.btcentralplus.com)
[18:00:41] *** Quits: doomlord (doomlod@moz-6651F8D4.range86-145.btcentralplus.com) (Quit: doomlord)
[18:02:12] *** Quits: jensnockert (jensnocker@moz-C5F27039.cust.bredband2.com) (Input/output error)
[18:02:39] *** Joins: jensnockert (jensnocker@moz-C5F27039.cust.bredband2.com)
[18:03:28] *** Quits: vk (vk@moz-389FEE13.hsd1.ca.comcast.net) (Quit: vk)
[18:04:28] *** Quits: jensnockert (jensnocker@moz-C5F27039.cust.bredband2.com) (Ping timeout)
[18:04:55] *** Joins: jensnockert (jensnocker@moz-98578353.mobileonline.telia.com)
[18:05:28] *** Quits: jensnockert (jensnocker@moz-98578353.mobileonline.telia.com) (Input/output error)
[18:05:52] *** Joins: jensnockert (jensnocker@moz-C5F27039.cust.bredband2.com)
[18:06:54] *** Quits: jensnockert (jensnocker@moz-C5F27039.cust.bredband2.com) (Input/output error)
[18:07:18] *** Joins: jensnockert (jensnocker@moz-C5F27039.cust.bredband2.com)
[18:08:56] *** Quits: lucian (lucian@6B2B4644.4304AE1E.CE5E78F6.IP) (Ping timeout)
[18:09:04] *** Quits: jensnockert (jensnocker@moz-C5F27039.cust.bredband2.com) (Ping timeout)
[18:10:38] *** Joins: eagen (eagen@moz-92A457CB.hsd1.mn.comcast.net)
[18:11:44] <engla> "248:5 error: method `iter_bytes` has an incompatible type: expected fn but found extern fn"  ah, some kind of success. I managed to make an extern fn in the compiler ^^ probably in the wrong place but
[18:11:57] *** jdm|muzak is now known as jdm
[18:14:09] *** Joins: MaikKlein (maik@moz-51F0F9C8.dip0.t-ipconnect.de)
[18:16:52] *** Quits: true_droid (Adium@moz-123FD9B8.beck.volia.net) (Quit: Leaving.)
[18:20:30] *** Joins: jviereck (Adium@moz-C7D00CD5.adsl.alicedsl.de)
[18:21:07] *** Joins: steven_is_false (user@moz-144077DE.bchsia.telus.net)
[18:22:17] <steven_is_false> Hi! I want to test my latest changes on Rust but I can't get to the stage where my tests run because an unrelated test (test/run-pass/syntax-extension-fmt.rs) fails. Can anyone help me out?
[18:22:25] *** Joins: jensnockert (jensnocker@moz-C5F27039.cust.bredband2.com)
[18:23:28] *** Quits: jensnockert (jensnocker@moz-C5F27039.cust.bredband2.com) (Input/output error)
[18:24:13] *** Joins: jensnockert (jensnocker@moz-C5F27039.cust.bredband2.com)
[18:24:34] <cmr> steven_is_false: what's the failure?
[18:25:14] <steven_is_false> cmr: Unfortunately, it's not really easy to tell due to a helper test function.
[18:25:31] <steven_is_false> cmr: Let me get a backtrace with ::rt::backtrace.
[18:26:34] *** Quits: jviereck (Adium@moz-C7D00CD5.adsl.alicedsl.de) (Quit: Leaving.)
[18:26:59] *** Quits: jensnockert (jensnocker@moz-C5F27039.cust.bredband2.com) (Ping timeout)
[18:28:06] <AutomatedTester> Hi, I have just updated to 0.7
[18:28:10] <AutomatedTester> and getting 
[18:28:18] <AutomatedTester> â˜  rust_learning  rustc --test about_arrays.rs
[18:28:18] <AutomatedTester> about_arrays.rs:1:0: 1:0 warning: static constant should have an uppercase identifier [-W non-uppercase-statics (default)]
[18:28:18] <AutomatedTester> about_arrays.rs:1
[18:28:21] <sfackler> cmr: i ran into a failure of that test last night with this error: task failed at 'left: ~"0" does not equal right: ~"5.82"'
[18:28:23] <AutomatedTester> there is nothing on that line
[18:28:29] <AutomatedTester> seems weird to have a warning there
[18:28:34] *** Quits: SiegeLord (sl@moz-CAF07B4C.hsd1.ma.comcast.net) (Ping timeout)
[18:28:44] <steven_is_false> sfackler: cmr: That's the same error I'm getting.
[18:29:02] <cmr> I think that'd be line 52...
[18:29:29] <cmr> oh, there's a bunch of tests with that constant, nevermind
[18:29:58] *** Quits: robertknight (robertknig@moz-54528EE0.wby.mendeley.com) (Quit: Computer has gone to sleep.)
[18:30:31] <cmr> AutomatedTester: open a bug and tag @huonw
[18:30:55] <AutomatedTester> cmr: will do
[18:31:07] <AutomatedTester> cmr: on github or bugzilla?
[18:31:10] <cmr> AutomatedTester: github
[18:31:15] <cmr> we don't use bugzilla at all
[18:31:31] <AutomatedTester> ok
[18:31:35] *** Quits: MaikKlein (maik@moz-51F0F9C8.dip0.t-ipconnect.de) (Ping timeout)
[18:31:57] <AutomatedTester> holy moly you guys have a lot of bugs
[18:32:13] <cmr> have you /used/ rust recently? ;)
[18:32:37] <AutomatedTester> cmr: I am still teaching myself so havent hit the "fun" parts
[18:33:40] <engla> extra::fun_treemap is the most fun part
[18:34:12] <pauls_> I totally just ran into elly wearing a Rust shirt on a bike path in Somerville.
[18:34:55] <pauls_> The Rust shirts are already helping Rustic folk identify each other! 
[18:34:59] *** Quits: mreedell (mreedell@moz-9950CA28.hsd1.pa.comcast.net) (Quit: Computer has gone to sleep.)
[18:35:03] <cmr> They're sweet looking too
[18:35:06] <cmr> I can't wait for mine
[18:35:08] *** Joins: join (DrunkenPan@745B767B.989A61DC.CA5B6332.IP)
[18:36:01] *** Joins: mreedell (mreedell@moz-9950CA28.hsd1.pa.comcast.net)
[18:37:01] <pauls_> cmr, seriously! They are awesome.
[18:40:18] <bblum> pauls_: haha, xlnt
[18:40:30] *** Parts: graydon (graydon@moz-9918B407.vc.shawcable.net) ()
[18:40:36] *** Parts: steven_is_false (user@moz-144077DE.bchsia.telus.net) (ERC Version 5.3 (IRC client for Emacs))
[18:40:43] *** Joins: pnathan (Adium@B9840254.2CD8A5F8.477B877D.IP)
[18:40:50] <elly> haha
[18:40:54] <elly> indeed!
[18:41:50] *** Joins: jviereck (Adium@moz-C7D00CD5.adsl.alicedsl.de)
[18:41:59] *** Quits: jviereck (Adium@moz-C7D00CD5.adsl.alicedsl.de) (Client exited)
[18:42:05] <rntz> so, um, rust appears to have some problems with polymorphically-recursive types
[18:42:32] <rntz> rustc has the problems, rather
[18:42:47] <rntz> eg. enum Tree<T> { Leaf(T), Branch(~Tree<(T,T)>), }
[18:42:58] *** Joins: SiegeLord (sl@moz-CAF07B4C.hsd1.ma.comcast.net)
[18:43:17] <rntz> I don't have all the details as I'm in the middle of building rustc, but apparently doing basically anything with this type will make the compiler hang.
[18:43:35] <cmr> Hm, there shouldn't be problems with that
[18:43:36] <rntz> including, say, "let x: Tree<int> = Leaf(5);"
[18:43:59] *** Joins: jedestep (jedestep@moz-2C53377F.natpool.nyu.edu)
[18:44:07] <rntz> cmr: well, so we initially thought the problem might have something to do with monomorphization, but it's apparently even more immediate than that (as evidenced by the problematic let-statement above)
[18:44:11] <rntz> shachaf might know more
[18:44:36] <bblum> can you get a backtrace
[18:44:41] <rntz> shachaf: ^?
[18:44:43] <cmr> There's currently a bug that allows infinite types
[18:44:51] <cmr> infinitely sized types that is
[18:45:00] <rntz> ah, a bug in the occurs check? that shouldn't be an issue here
[18:45:02] <Blei> it's not infinitely sized
[18:45:10] <cmr> so this might be related... but it shouldn't be
[18:45:13] <Blei> but the problem is that you keep generating new types
[18:45:13] <cmr> right, this type is fine
[18:45:15] <rntz> the types aren't infinite, although there are potentially an infinite number of different types if you do polymorphic recursion
[18:45:29] <rntz> Blei: oh, that is exactly the problem we might thought there be to do with monomorphization
[18:45:38] <rntz> I am really rather sad that that is problematic for rust, but c'est la vie
[18:45:44] *** Quits: jedestep (jedestep@moz-2C53377F.natpool.nyu.edu) (Ping timeout)
[18:45:44] <Blei> not potentially, you generate infinitely many tyes with each instantiation
[18:45:50] <rntz> but this is... even more problematic than this
[18:45:58] <Blei> *types
[18:46:18] <bblum> Tree<(T,T)> oh my
[18:46:22] <bblum> that's not a tree
[18:46:23] <rntz> Blei: sure, at the type level. but only finitely many will ever be touched during actual evaluation.
[18:46:28] <rntz> bblum: it is a complete binary tree, actually.
[18:46:35] <rntz> bblum: see scrollback in that other channel we are both in
[18:46:59] *** Quits: pnathan (Adium@B9840254.2CD8A5F8.477B877D.IP) (Ping timeout)
[18:47:04] *** Joins: dualhbridge (dad@moz-9FEE6D3B.maine.res.rr.com)
[18:47:04] <Blei> it's a _weird_ binary tree though
[18:47:09] <bblum> rntz: it appears to me that it is only capable of holding a power of two number of elements
[18:47:10] <mjrosenb> it forces a tree of tuples
[18:47:22] <rntz> bblum: yes, that is a property of complete binary trees
[18:47:22] <mjrosenb> the tree isn't in the algebraic nodes of the tree type.
[18:47:27] <bblum> oh, complete
[18:47:28] <bblum> ok
[18:47:34] *** Parts: dualhbridge (dad@moz-9FEE6D3B.maine.res.rr.com) ()
[18:47:37] <shachaf> rntz: I don't know much more than what you've said, and I'm about to leave for the train.
[18:47:40] <bblum> yeah, please file a bug
[18:47:46] <shachaf> I assume that people in here have working rustcs too. :-)
[18:47:56] <rntz> I will file a bug as soon as I have rustc working to test my examples :P
[18:48:17] <mjrosenb> is'nt there a try rust in the browser demo?
[18:48:19] <rntz> I mean, it is a weird tree, yes. this is not a normal type. but there are more useful types which have this polymorphic-recursion behavior (like, apparently, finger trees)
[18:48:20] <mjrosenb> or is that llvm
[18:48:29] <cmr> http://strcat.zapto.org:8000/
[18:48:36] <cmr> seems to be down atm
[18:48:37] <taylanub> Any tips to port to OpenBSD ?
[18:48:51] <rntz> yeah, well, I'd be surprised if it gave me a good  way to debug compiler problems anyways :P
[18:48:53] <Blei> taylanub: compile it and see what breaks ;)
[18:48:56] <shachaf> rntz: I don't think any of those are really viable with Rust's current compilation strategy.
[18:49:16] <rntz> shachaf: yes. that makes me sad :(. but in any case this particular behavior (compiler hanging) is a bug and should  be fixed.
[18:49:27] <taylanub> Blei: "unknown OS type: OpenBSD" right at the start of ./configure. :D
[18:49:38] <shachaf> Sure. But the fix is more along the lines of "print an error" than "make it work".
[18:49:39] <shachaf> Oh well.
[18:49:57] <rntz> yeah, sure. although constructing values of that type should perhaps be okay?
[18:49:59] <shachaf> Anyway, it should be specified in the language spec whether this is allowed or not.
[18:50:10] <rntz> or perhaps the type should be forbidden in the first place, since it's almost unusable
[18:50:12] <shachaf> rntz: Yes -- in fact if you take the ~ away you can construct values of that type just fine.
[18:50:21] <rntz> huh! weird.
[18:50:23] <cmr> shachaf: what language spec?
[18:50:31] *** Quits: Yurume (yurume@AC58A8CE.8A059B47.E313B915.IP) (Ping timeout)
[18:50:33] <shachaf> cmr: Yes, well.
[18:50:35] <mjrosenb> taylanub: istr, freebsd got some love a while back, you may want to change everything to recognize freebsd|openbsd.
[18:50:41] <rntz> :< rust had a spec at some point! not, like, a formal spec. but a spec.
[18:50:50] <rntz> I could swear rust had a spec at some point.
[18:50:55] <cmr> there's http://static.rust-lang.org/doc/rust.html but it's hardly comprehensive or correct
[18:50:58] <shachaf> cmr: I'll go with "the language's semantics".
[18:51:13] <rntz> "should be documented somewhere useful", anyway :P
[18:51:23] <shachaf> Sure, that works.
[18:51:34] <cmr> sfackler: I can reproduce, so I'll poke at it in a bit
[18:51:34] <shachaf> "shouldn't hang the compiler" works too, at the moment.
[18:51:36] <taylanub> mjrosenb: Indeed I see FreeBSD there; I'll try that.
[18:51:46] * shachaf vanishes in a puff of orange smoke.
[18:53:34] <taylanub> Wait .. we're not using autotools ?
[18:53:49] <cmr> nope
[18:53:59] *** Joins: cp (cp@moz-993078EE.plus.com)
[18:54:07] <taylanub> Self-written ./configure ?
[18:54:18] <taylanub> Or what are those .mk files ?..
[18:54:53] <cmr> everything handbuilt afaik
[18:55:06] <ross> what changed with vec lately? I'm getting: type does not implement any method in scope named filter_mapped. code worked a week ago
[18:55:57] <cmr> taylanub: yup, eveything handwritten
[18:56:04] <cmr> mostly by graydon it seems
[18:56:06] *** Quits: sk (sk@1696E5A5.E92B26F8.78DD174B.IP) (Quit: Leaving)
[18:56:18] <Eridius> rusti: [1,2,3].filter_mapped(|&x| Some(x+1))
[18:56:19] -rusti- more than 5 lines of output, pastebinned: http://sprunge.us/hcON
[18:56:24] *** Quits: sankha93 (Instantbir@D8F0AB2E.498FC86C.8B6C1D65.IP) (Ping timeout)
[18:57:45] <Eridius> rusti: [1,2,3].last()
[18:57:46] -rusti- more than 5 lines of output, pastebinned: http://sprunge.us/CCdC
[18:58:01] <SiegeLord> rusti: [1,2,3].iter().filter_map(|&x| Some(x+1)).collect()
[18:58:01] <Eridius> rusti: let x = [1,2,3]; x.last()
[18:58:02] -rusti- <anon>:7:9: 8:5 error: cannot determine a type for this bounded type parameter: unconstrained type
[18:58:03] -rusti- <anon>:7          [1,2,3].iter().filter_map(|&x| Some(x+1)).collect()
[18:58:03] -rusti- <anon>:8     };
[18:58:03] -rusti- application terminated with error code 101
[18:58:03] -rusti- more than 5 lines of output, pastebinned: http://sprunge.us/YcOX
[18:59:32] <Eridius> de0d696 removed filter_mapped because iterators solves it
[18:59:37] <Eridius> I guess the docs are out of date?
[18:59:41] <ross> ah I see
[18:59:50] *** Quits: eagen (eagen@moz-92A457CB.hsd1.mn.comcast.net) (Ping timeout)
[18:59:59] <Eridius> rusti: [1,2,3,4,5].iter().filter(|&x| x < 4).transform(|&x| x*3).collect()
[19:00:01] -rusti- more than 5 lines of output, pastebinned: http://sprunge.us/ISjR
[19:00:08] *** Quits: lmandel (lmandel@moz-BBE1EA67.dsl.bell.ca) (Quit: lmandel)
[19:00:15] <Eridius> rusti: [1,2,3,4,5].iter().filter(|&&x| x < 4).transform(|&x| x*3).collect()
[19:00:17] -rusti- more than 5 lines of output, pastebinned: http://sprunge.us/LjAH
[19:00:19] *** Joins: pyrac (pyrac@moz-18D74BD0.w90-60.abo.wanadoo.fr)
[19:00:26] <Eridius> rusti: [1,2,3,4,5].iter().filter(|&x| *x < 4).transform(|&x| x*3).collect()
[19:00:27] -rusti- <anon>:7:9: 8:5 error: cannot determine a type for this bounded type parameter: unconstrained type
[19:00:27] -rusti- <anon>:7          [1,2,3,4,5].iter().filter(|&x| *x < 4).transform(|&x| x*3).collect()
[19:00:27] -rusti- <anon>:8     };
[19:00:27] -rusti- application terminated with error code 101
[19:00:39] <Eridius> rusti: [1,2,3,4,5].iter().filter(|&x| *x < 4).transform(|&x| x*3).collect::<~[int]>()
[19:00:40] -rusti- more than 5 lines of output, pastebinned: http://sprunge.us/VHTG
[19:00:55] <Eridius> rusti: let x = [1,2,3,4,5]; x.iter().filter(|&x| *x < 4).transform(|&x| x*3).collect::<~[int]>()
[19:00:57] -rusti- ~[3, 6, 9]
[19:01:03] *** Quits: BizarreCake (BizarreCak@51AA6B33.6D202491.34A7550B.IP) (Ping timeout)
[19:02:05] <SiegeLord> Is that a bug?
[19:02:51] <Eridius> what?
[19:03:18] <SiegeLord> The necessity to do the last modification
[19:03:41] <Eridius> yeah, rvalues don't live long enough. known issue
[19:04:58] *** Joins: ghrust (ghrust@C8693FCB.6A2AE50.F3114085.IP)
[19:04:58] <ghrust> 01[13rust01] 15bors merged 06auto into 06master: 02http://git.io/hQvqdQ
[19:04:58] *** Parts: ghrust (ghrust@C8693FCB.6A2AE50.F3114085.IP) ()
[19:07:20] *** Joins: lmandel (lmandel@F27D3820.D6C5F29.ADB88A9.IP)
[19:07:59] *** Joins: ghrust (ghrust@24260B07.6A2AE50.F3114085.IP)
[19:07:59] <ghrust> 01[13rust01] 15bors pushed 0 new commits to 06auto: 02http://git.io/jDTXUQ
[19:07:59] *** Parts: ghrust (ghrust@24260B07.6A2AE50.F3114085.IP) ()
[19:07:59] *** Joins: ghrust (ghrust@E7A4CCE2.6A2AE50.F3114085.IP)
[19:08:00] <ghrust> 01[13rust01] 15bors pushed 2 new commits to 06auto: 02http://git.io/mCfktg
[19:08:00] <ghrust> 13rust/06auto 145007fb2 15Luqman Aden: Add x64 windows to platform.mk and mingw64 header fixes.
[19:08:00] <ghrust> 13rust/06auto 14f850777 15bors: auto merge of #7547 : luqmana/rust/mingw64, r=yichoi...
[19:08:00] *** Parts: ghrust (ghrust@E7A4CCE2.6A2AE50.F3114085.IP) ()
[19:11:39] *** Joins: taruti (taruti@moz-60D35041.violetti.org)
[19:12:49] *** Quits: enix (enix@moz-A50569DD.c3-0.slvr-ubr1.lnh-slvr.md.cable.rcn.com) (Quit: Konversation terminated!)
[19:13:53] <taylanub> Does .7 actually build on FreeBSD ?
[19:14:00] <cmr> taylanub: yes.
[19:14:04] <cmr> And all tests pass
[19:14:15] <cmr> that's a requirement for every PR that gets merged
[19:14:22] *** Quits: jpochyla (jpochyla@moz-8D99AE5D.broadband18.iol.cz) (Ping timeout)
[19:14:24] <cmr> (as enforced by our robotic overlord, bors)
[19:14:34] <taylanub> http://sprunge.us/NAaX  OK, then this error is OpenBSD specific.
[19:14:40] <taylanub> "Red zone not defined for this platform"
[19:14:57] <rntz> arg, I grabbed a new version of rustc and now I need a way to un-install all the files from the old version
[19:15:00] <cmr> grep for RED_ZONE_SIZE and add it
[19:15:07] <cmr> in a OpenBSD-ifdef
[19:15:08] <rntz> anyone know a good way to do this other than going through them manually?
[19:15:16] <cmr> rntz: `make uninstall`
[19:15:23] <taylanub> Well, all I did was turn the FreeBSD clause in the `case' statement in ./configure to FreeBSD|OpenBSD, i.e. I'm telling it that OpenBSD is "unknown-freebsd" too. :P
[19:15:32] *** Joins: paupau (NEAT@moz-BFE94859.hfc.comcastbusiness.net)
[19:15:34] <rntz> cmr: nope
[19:15:40] <rntz> cmr: leaves around libraries & stuff from 0.6
[19:15:50] <cmr> ah, because the makefiles changed, right
[19:16:03] <rntz> I noticed because using rustc gave me an error because there were two versions of libstd, one from 0.6 and one from 0.7
[19:16:38] <paupau> hey cmr, how far did you get on those crypto challenges?
[19:16:41] *** Quits: SiegeLord (sl@moz-CAF07B4C.hsd1.ma.comcast.net) (Quit: Leaving)
[19:16:42] *** Joins: SiegeLordEx (sl@moz-CAF07B4C.hsd1.ma.comcast.net)
[19:16:46] <cmr> paupau: like the first two
[19:16:47] *** Quits: SiegeLordEx (sl@moz-CAF07B4C.hsd1.ma.comcast.net) (Quit: SiegeLordEx)
[19:16:53] *** Joins: SiegeLord (sl@moz-CAF07B4C.hsd1.ma.comcast.net)
[19:16:54] <cmr> paupau: I stopped doing them to hack on rustc
[19:17:10] <paupau> cmr: nice! I'm only like halfway into the first right now
[19:17:42] <rntz> hrm, okay, anyone know how to get a backtrace out of rustc when I ^C it?
[19:17:44] *** Joins: donri (dag@moz-9BB61102.tbcn.telia.com)
[19:17:44] *** Joins: SimonSapin (simon@moz-D0C2F181.zone2.bethere.co.uk)
[19:18:00] <cmr> rntz: gdb
[19:18:02] <cmr> :)
[19:19:11] <rntz> oh, hrm. it doesn't hang. it aborts after a while.
[19:19:12] *** Quits: cp (cp@moz-993078EE.plus.com) (Ping timeout)
[19:19:28] *** Joins: mib_lsuubu (Mibbit@moz-2B535B0A.f3.protectedgroup.com)
[19:19:29] <cmr> OOM or hit the stack limit I imagine
[19:19:34] <taylanub> http://sprunge.us/BHPD  Any idea why this happens ?
[19:19:36] *** Quits: mib_lsuubu (Mibbit@moz-2B535B0A.f3.protectedgroup.com) (User has been banned from Mozilla (no spamming here))
[19:19:44] <paupau> so a plain [T] vector... lives on the stack? or just its slice lives on the stack
[19:19:52] <rntz> yeah, it runs out of stack
[19:20:18] <rntz> ugh, okay, how am I supposed to give a backtrace that is pages and pages and pages long b/c it ran out of stack?
[19:20:38] <rntz> like, how am I even supposed to *get* the backtrace  out of gdb in a useful way?
[19:20:48] *** Quits: pyrac (pyrac@moz-18D74BD0.w90-60.abo.wanadoo.fr) (Quit: pyrac)
[19:20:50] <cmr> taylanub: look at the code... there are ifdefs for every platform
[19:21:39] *** Quits: Amanieu (amanieu@moz-D5D10CA8.halls.manchester.ac.uk) (Connection reset by peer)
[19:21:50] <taylanub> Oh OK .. I wonder how many places have them, then. :P
[19:21:53] <doener> rntz: break on a function in the recursion loop, continue until you run into the problematic case
[19:22:17] <cmr> taylanub: lots of places :)
[19:22:24] *** Joins: Amanieu (amanieu@moz-D5D10CA8.halls.manchester.ac.uk)
[19:22:25] <paupau> rntz: turn off gdb pagination, log to a file?
[19:22:40] <doener> paupau: too easy :-p
[19:22:42] * taylanub greps '#ifdef.*FreeBSD'
[19:22:43] <cmr> paupau: the values are passed on the stack, but you can have static [T, ..n] I think
[19:22:53] <cmr> (which lives in .rodata)
[19:23:18] <rntz> paupau: do you know how I can turn off gdb pagination?
[19:23:25] <paupau> rntz: set pagination off
[19:23:30] <rntz> ty
[19:23:55] <Blei> you can also allocate statically sized vectors inside boxes
[19:24:11] <Blei> rusti: let a = ~([0, ..5]); a
[19:24:12] -rusti- ~[0, 0, 0, 0, 0]
[19:24:12] <mnemotic> little lost here; any ideas why I'd be getting this: https://gist.github.com/mnemotic/b0df0ecf014d74230554
[19:24:17] <paupau> cmr: so if you return a [T] it's always copied?
[19:25:38] <rntz> oh god that nearly caused my computer to hang
[19:25:41] *** Joins: vk (vk@moz-389FEE13.hsd1.ca.comcast.net)
[19:25:42] <Blei> mnemotic: attributes are either added to the following item if there is no `;`, or to the containing item if there is one
[19:25:55] <Blei> apparently cfg doesn't like the second use case
[19:25:57] <rntz> why the hell would running backtrace on a large stack with pagination off and logging it to a file cause my computer to very nearly hang?
[19:26:37] <paupau> rntz: maybe rust's massive stacks + gdb caused tons of paging
[19:27:22] <rntz> hm...
[19:27:24] <doomlord_> &[T] is a 'slice' , and it should be possible to obtain a slice from a ~[T] ?
[19:27:40] <doomlord_> or not..
[19:27:49] <mnemotic> Blei: i figured as much. but this is not the first module-level cfg that i've done :S
[19:28:04] <rntz> it should be possible to borrow an &[T] from an ~[T], if I understand rust's borrowing system
[19:28:06] <doomlord_> if you borrow from ~[T] do you always get a &~[T]
[19:29:07] <Blei> mnemotic: really? i couldn't find a single one in all of rust
[19:29:30] <Blei> doomlord_: either &*foo or foo.slice(i, j)
[19:29:38] <Blei> wait, first one doesn't work
[19:29:56] <rntz> paupau: hrm, you could almost be right except that I have no swap space for it to be thrashing to.
[19:30:02] <doomlord_> i was about to say, looking at the standard libary code for reference there are cases where thers's a * involved 
[19:30:08] <rntz> I guess it could be thrashing in and out of cache, but that shouldn't be this noticeable.
[19:30:15] <doener> rntz: try running with RUST_MAX_STACK=48000
[19:30:24] <doener> rntz: that should keep the backtrace at a manageable size
[19:30:30] <rntz> doener: thanks!
[19:30:37] <rntz> RUST_MAX_STACK should be exported as an envvar?
[19:30:40] *** Joins: cp (cp@moz-993078EE.plus.com)
[19:30:45] <doener> rntz: yep
[19:33:37] <mnemotic> Blei: you can do it tho. in this case, i'm changing some things about atomic intrinsics and need to add not-stage0 cfg's all over std and extra.
[19:34:02] <Blei> mnemotic: cool, i didn't know that. thanks!
[19:34:26] <rntz> arg, github's redesign has obscured the "search issues" feature. I don't know where it is any more.
[19:35:04] <mnemotic> Blei: it makes sense, with `;` they apply to the containing item, like you said, and at the top-level, that's the entire module.
[19:35:48] <cmr> rntz: you search in the topbar, and click "Issues" in the left column
[19:36:08] *** Joins: sk (sk@61A494B3.BA40E8A.AAC02D62.IP)
[19:37:48] <paupau> I assume there's no particular reason I have to write &'static explicitly in "static stuff: &'static [uint] = &[1, 2, etc" other than that it hasn't been sugared yet?
[19:38:23] <paupau> there's no other lifetime it could have right
[19:39:23] *** Joins: km (quassel@FDBAF0A0.DBF71E41.29C67456.IP)
[19:39:30] <cmr> paupau: all types must be explicit in statics
[19:39:43] <cmr> there is no plan to have it sugared afaik
[19:39:51] <paupau> cmr: ok, thanks
[19:40:05] *** Joins: RMF (RMF@moz-2CA5F393.dsl.telepac.pt)
[19:40:30] <paupau> cmr: I'd assume that at some point &'static will be elided in the static item case
[19:40:36] <paupau> anyway, it's not really important
[19:41:16] *** Quits: tiffany (kawaii@moz-1E0FE6E8.dhcp.embarqhsd.net) (Ping timeout)
[19:42:20] *** Quits: bjz (brendanzab@B398BE78.F804C29E.D35A31DF.IP) (Quit: Leaving...)
[19:43:07] *** Joins: MaikKlein (maik@moz-51F0F9C8.dip0.t-ipconnect.de)
[19:43:17] *** Joins: strcat (strcat@moz-54F7FD49.cpe.net.cable.rogers.com)
[19:43:29] <rntz> okay, bug submitted: https://github.com/mozilla/rust/issues/7587
[19:44:23] <paupau> whoa, Tree<(T,T)> is gonna get huge
[19:45:07] <paupau> shouldn't it be Branch(~Tree<T>, ~Tree<T>) or something
[19:45:09] <cmr> #5232
[19:45:13] <cmr> Holy poop
[19:45:23] *** Quits: acrichto (acrichto@moz-B63D64BD.res.cmu.edu) (Ping timeout)
[19:45:41] *** Quits: mjrosenb (mjrosenb@moz-B3592BDA.club.cc.cmu.edu) (Ping timeout)
[19:46:59] <rntz> paupau: no, that is the point.
[19:47:01] *** Joins: mjrosenb (mjrosenb@moz-B3592BDA.club.cc.cmu.edu)
[19:47:36] <rntz> that is what a polymorphically recursive type is. I don't think you'd get the same compiler bug with Branch(~Tree<T>, ~Tree<T>) (I really hope you wouldn't!)
[19:47:52] <paupau> right
[19:47:54] <rntz> but yeah, the point is that it encodes complete binary trees with data at the leaves.
[19:47:59] <paupau> neat
[19:48:25] <paupau> so I guess it's going and trying to realize the whole type tree
[19:48:33] <paupau> oh boy
[19:48:51] <rntz> well, I'm not sure why it would actually try to do that in the code sample given in the bug report
[19:49:07] <cmr> the compiler isn't exactly smart
[19:49:15] <cmr> Where are all the mozilla people at today?
[19:49:19] <cmr> oh wiat
[19:49:21] <cmr> heh, america day
[19:49:25] <rntz> we don't even ask it to recurse on the tree!
[19:49:27] *** Joins: true_droid (Adium@moz-123FD9B8.beck.volia.net)
[19:49:59] <paupau> indeed
[19:50:19] <rntz> okay, but I literally see no reason for the compiler to be generating all those other types
[19:50:25] <paupau> I bet my pet language would have barfed in the same way :)
[19:50:41] *** Quits: rpearl (rpearl@moz-2B41ACB5.andrew.cmu.edu) (Ping timeout)
[19:50:45] <rntz> my pet language is unityped, so :P
[19:50:45] *** Quits: mjrosenb (mjrosenb@moz-B3592BDA.club.cc.cmu.edu) (Ping timeout)
[19:51:20] *** Quits: bblum (bblum@moz-2B41ACB5.andrew.cmu.edu) (Ping timeout)
[19:51:27] <paupau> the reason is: HISTORY!
[19:53:27] <engla> rntz: does this type have any use?
[19:53:28] *** Quits: rntz (rntz@moz-C76A8D96.sp.cs.cmu.edu) (Ping timeout)
[19:54:16] <paupau> practical use? THIS IS TYPE THEORY!
[19:54:28] *** Joins: rpearl (rpearl@moz-2B41ACB5.andrew.cmu.edu)
[19:54:33] *** Joins: doomlord (doomlod@moz-6651F8D4.range86-145.btcentralplus.com)
[19:54:51] <engla> the description does not line up with the type
[19:54:56] *** Quits: doomlord (doomlod@moz-6651F8D4.range86-145.btcentralplus.com) (Quit: Leaving)
[19:55:19] <engla> each leaf is a binary tree in tuple form?
[19:55:37] <paupau> engla: I guess?
[19:55:44] *** Joins: bblum (bblum@moz-2B41ACB5.andrew.cmu.edu)
[19:55:57] <paupau> yeah a tuple tree
[19:56:48] *** Joins: rntz (rntz@moz-C76A8D96.sp.cs.cmu.edu)
[19:57:36] <paupau> (((2, 3), (4, 5)), ((6, 7), (8, 9))): Branch(Branch(Branch(Leaf(int)))?
[19:58:31] <paupau> er,
[19:58:33] <paupau> Tree<*
[19:58:39] <paupau> no wait
[19:58:41] <paupau> grr
[19:59:05] <paupau> yeah.
[19:59:47] *** Joins: mjrosenb (mjrosenb@moz-B3592BDA.club.cc.cmu.edu)
[19:59:49] <paupau> just needs some ctors wrapped.
[19:59:50] *** Quits: jdm (jdm@F2D29657.F60B0462.67AC9B1.IP) (Quit: Lost terminal)
[20:00:33] *** Quits: mreedell (mreedell@moz-9950CA28.hsd1.pa.comcast.net) (Quit: Computer has gone to sleep.)
[20:01:07] <engla> yeah. I was confused about needing only one Leaf constructor, but the text says leaves
[20:01:28] *** Joins: jdm (jdm@F2D29657.F60B0462.67AC9B1.IP)
[20:01:59] *** Quits: ross (ross@moz-8A84103E.br.br.cox.net) (Quit: )
[20:02:01] *** Quits: echristo (echristo@moz-1892C634.hsd1.ca.comcast.net) (Ping timeout)
[20:03:34] *** Joins: korenchkin (Mibbit@moz-8DE1FF0F.pools.arcor-ip.net)
[20:04:15] <bblum> rntz: check ot my Tree<Tree<T>> example :P
[20:06:03] <bblum> not sure what that would even mean
[20:06:53] *** Quits: MaikKlein (maik@moz-51F0F9C8.dip0.t-ipconnect.de) (Ping timeout)
[20:07:58] <AutomatedTester> cmr: cc huonw on that bug I mentioned?
[20:08:11] <cmr> AutomatedTester: yes
[20:08:36] <AutomatedTester> cmr: thanks
[20:09:25] <AutomatedTester> cmr: https://github.com/mozilla/rust/issues/7589
[20:09:27] *** Joins: MaikKlein (maik@moz-51F0F9C8.dip0.t-ipconnect.de)
[20:11:03] <mark_edward> AutomatedTester: how are you aautomated?  yoju dont seem to be a bot
[20:11:16] *** Joins: Lovot (root@AE31FB56.8153C3BF.F3C9A2D9.IP)
[20:11:32] *** Parts: Lovot (root@AE31FB56.8153C3BF.F3C9A2D9.IP) ()
[20:12:42] <AutomatedTester> mark_edward: I write automation tools for testing
[20:13:06] <mark_edward> oh that's cool. do you write them in Rust? or python?
[20:13:09] *** Joins: spider-mario (spidermari@moz-81131DB6.fbx.proxad.net)
[20:13:09] <mark_edward> bash?
[20:13:28] <AutomatedTester> currently python/javascript mainly
[20:13:47] <AutomatedTester> but learning rust as something new
[20:14:04] *** Joins: jpochyla (jpochyla@moz-8D99AE5D.broadband18.iol.cz)
[20:14:47] <rntz> bblum: Tree<Tree<T>> is isomorphic to (T * nat).
[20:14:54] *** Joins: echristo (echristo@moz-1892C634.hsd1.ca.comcast.net)
[20:15:00] <rntz> er, (T,nat) in rust notation I guess
[20:15:17] *** Quits: doener (doener@moz-121949B3.unitymediagroup.de) (Quit: leaving)
[20:15:25] <rntz> oh, no, I'm full of shit I think
[20:15:47] <AutomatedTester> mark_edward: I know some Ops people want to see how Rust can be used there
[20:16:39] <rntz> oh, no, it really is (T,nat).
[20:16:49] <jmgrosen> can you have two `impl`s of Index that return different types?
[20:16:57] <cmr> jmgrosen: no
[20:17:01] <rntz> now, Branch(Tree<Tree<T>>) would be really weird
[20:17:02] <jmgrosen> cmr: ok, thanks
[20:17:06] <cmr> jmgrosen: or, actually, maybe!
[20:17:08] <cmr> not positive
[20:17:18] <cmr> they'd have to be concrete, non-overlapping types... not positive
[20:17:34] <jmgrosen> ok, the naive way i tried doesn't work
[20:18:02] <mark_edward> AutomatedTester:  it'd be cool if we could use rust for scripting stuff. how useful does this stuff look for your needs? http://static.rust-lang.org/doc/std/run.html
[20:18:18] <cmr> mark_edward: Rust wouldn't be very useful for that I think.
[20:18:24] *** Quits: jaen (jaen@moz-E0979827.copit.pl) (Ping timeout)
[20:18:34] <cmr> It's only really tolerable in python because of plumbum
[20:18:34] *** Joins: jaen (jaen@moz-E0979827.copit.pl)
[20:18:36] <mark_edward> why do you  say that?
[20:18:52] <jyeo> mark_edward: it's easier for scripting if the language has global type inference
[20:19:00] <AutomatedTester> cmr: mark_edward: I am not after a scripting language
[20:19:04] <AutomatedTester> I am happy to compile
[20:19:12] <cmr> You need to compile, not the best abstractions for easily running/extracting results from things
[20:19:23] <jmgrosen> cmr: it just says there are multiple applicable methods in scope, even when i declare the type of the variable i'm assigning it to
[20:19:32] <cmr> jmgrosen: guess not then :(
[20:19:39] <jmgrosen> ok
[20:19:43] <AutomatedTester> mark_edward: I work on browser automation tools
[20:19:52] <cmr> jmgrosen: I think it should be allowed though, maybe open a bug?
[20:20:01] <mark_edward> oh ok i see.
[20:20:04] <jmgrosen> cmr: ok, i'll work on a test case
[20:20:04] <AutomatedTester> as long as it makes sense for the browser to understand that language I will use it
[20:21:15] <AutomatedTester> mark_edward: that link looks useful for my first full rust project
[20:21:39] <mark_edward> glad to be of help, lol. what will it be?
[20:22:15] <paupau> is for zip(...) inlined?
[20:22:36] <paupau> or does it construct the intermediate vec?
[20:23:09] <AutomatedTester> mark_edward: Selenium bindings in Rust
[20:23:11] <engla> paupau: .zip on iterator doesn't allocate
[20:23:25] <paupau> engla: oh, that makes sense, right
[20:24:01] <mark_edward> that is a cool project!
[20:24:11] <engla> but vec::zip does create a new vec
[20:24:22] <AutomatedTester> mark_edward: I work on that most of the time
[20:24:38] <AutomatedTester> so know its ins and outs
[20:24:51] <AutomatedTester> anyway I am off, have a good weekend all
[20:25:38] <paupau> engla: works like a charm, thanks!
[20:26:03] *** Quits: maxli (maxli@F2D29657.F60B0462.67AC9B1.IP) (Quit: Leaving.)
[20:26:40] *** Quits: donri (dag@moz-9BB61102.tbcn.telia.com) (Client exited)
[20:27:00] <strcat> vec::zip will go away if it hasn't already
[20:27:23] <strcat> vector.zip(any_iterable) will give you an iterator
[20:27:32] <engla> yes of course
[20:27:54] <engla> vec::zip is replaced by a.consume_iter().zip(b.consume_iter()).collect()
[20:28:27] <paupau> for now I have to do `for v1.iter().zip(v2.iter()).advance |(&e1, &e2)|` understandably
[20:29:14] *** Joins: pnathan (Adium@moz-E3C3FAF2.hfc.comcastbusiness.net)
[20:31:28] *** Joins: Thad (chatzilla@moz-C35F90AE.tx.res.rr.com)
[20:34:12] *** Quits: lmandel (lmandel@F27D3820.D6C5F29.ADB88A9.IP) (Quit: lmandel)
[20:34:32] <jmgrosen> cmr: should this be possible? https://gist.github.com/jmgrosen/5930078
[20:34:36] *** Joins: pyrac (pyrac@moz-18D74BD0.w90-60.abo.wanadoo.fr)
[20:34:48] <paupau> what's the most concise way to get the first element from a 2-tuple?
[20:34:56] <paupau> is there `fst` provided or should I write that myself?
[20:35:01] <cmr> jmgrosen: I think it should be
[20:35:10] *** Quits: pnathan (Adium@moz-E3C3FAF2.hfc.comcastbusiness.net) (Ping timeout)
[20:35:11] <mark_edward> hey, if we have iterable traits, then we could have like more iterator traits too!
[20:35:13] <jmgrosen> cmr: ok, i'll file a bug then
[20:35:25] <cmr> paupau: t.first()
[20:35:30] <paupau> cmr: oh sweet thanks
[20:35:32] *** Joins: dherman (dherman@moz-6CA476B1.hsd1.ca.comcast.net)
[20:35:32] *** ChanServ sets mode: +o dherman
[20:35:34] <cmr> http://static.rust-lang.org/doc/std/tuple.html
[20:35:37] <cmr> they're kinda a hack
[20:35:42] <mark_edward> taken from C++ we could ahve forward_iterators (one use, unidirectional, also covers the reverse iterators)
[20:35:42] <cmr> but they work :)
[20:35:46] <engla> does anyone else see "static constant should have an uppercase identifier" warning on the first line of every file? urrent master
[20:35:47] <paupau> cmr: ah, this is good
[20:35:49] *** Joins: lmandel (lmandel@F27D3820.D6C5F29.ADB88A9.IP)
[20:35:54] <mark_edward> and then bidirectionals/random access
[20:35:59] <mark_edward> and the mutable variants
[20:36:04] <mark_edward> what do you think?
[20:36:25] <cmr> mark_edward: random access iterators? how is that different from the Index trait?
[20:36:35] *** Joins: james4k (james@moz-E7990244.consolidated.net)
[20:36:36] *** Quits: victorporof (victorporo@74A9C5E8.1745F5FA.9B1E38F4.IP) (Quit: victorporof)
[20:37:00] <mark_edward> cmr: well it's for the iterators and not the container itself
[20:37:03] <cmr> engla: AutomatedTester reported that... seems the lint pass is broken
[20:37:15] <engla> ok
[20:37:20] <mark_edward> so you could say iter.next().prev().prev().next()
[20:37:42] <cmr> strcat: ^
[20:38:06] <strcat> we won't have prev
[20:38:06] <jmgrosen> cmr: https://github.com/mozilla/rust/issues/7590
[20:38:19] <strcat> we can have ranges like D
[20:38:26] <strcat> mark_edward: http://www.reddit.com/r/programming/comments/1hl2qr/rust_07_released/cavnng9
[20:38:29] *** Quits: dherman (dherman@moz-6CA476B1.hsd1.ca.comcast.net) (Quit: dherman)
[20:38:45] <strcat> keep in mind that rust is memory safe
[20:38:52] <strcat> iterators like C++ don't lend themselves to memory safety
[20:38:57] <mark_edward> isn't a range just a bidirectional iterator that remembers it's bounds?
[20:39:06] <strcat> mark_edward: no
[20:39:09] *** Quits: lmandel (lmandel@F27D3820.D6C5F29.ADB88A9.IP) (Quit: lmandel)
[20:39:15] <mark_edward> what's different?
[20:39:19] <strcat> rust's slices are bidirectional and random access ranges
[20:39:21] <strcat> &[1, 2, 3, 4, 5]
[20:39:23] <strcat> pop_front
[20:39:26] <strcat> &[2, 3, 4, 5]
[20:39:28] <strcat> pop_front
[20:39:30] <strcat> &[3, 4, 5]
[20:39:32] <strcat> pop_back
[20:39:34] <strcat> &[3, 4]
[20:39:49] <SiegeLord> Just don't call them Ranges :P
[20:40:18] <strcat> Range, BidirectionalRange, RandomAccessRange seems like fine naming to me ;p
[20:40:25] <SiegeLord> It's a D'ism
[20:40:47] <SiegeLord> Probably a primary reason why 'range' is called iota
[20:40:53] <strcat> it's a D'ism in that other languages don't have ranges
[20:40:55] *** Quits: spider-mario (spidermari@moz-81131DB6.fbx.proxad.net) (Ping timeout)
[20:41:10] <mark_edward> what is the differene between that and an iter where you can call .next() and .prev() and it's bounds checked?
[20:41:12] <strcat> Boost.Range is something else
[20:41:23] <paupau> good article!
[20:41:38] <strcat> mark_edward: because a bidirectional iterator would be slow
[20:41:58] <strcat> it would have to be 3 words instead of 2
[20:42:09] <strcat> and it doesn't offer the same capabilities as a range
[20:42:09] *** Joins: spider-mario (spidermari@moz-81131DB6.fbx.proxad.net)
[20:42:21] <mark_edward> what capabilites are missing?
[20:42:25] <strcat> you can just clone a forward iterator and get the same functionality, if you start at the beginning/end
[20:42:41] <strcat> mark_edward: a BidirectionalRange allows you to pop from the front (like rust's Iterator) and the end
[20:42:54] <strcat> a bidirectional iterator allows traversals in both directions - it's not the same
[20:43:17] <strcat> a bidirectional iterator has no use on a vector because you can already get an iterator from any place and clone them
[20:43:35] <strcat> the only use is a tree with parent pointers, allowing bidirectional iteration from some key
[20:43:49] <strcat> but you can't write a tree like that in safe rust (and parent pointers are slow anyway)
[20:44:10] <mark_edward> i see
[20:44:20] <mark_edward> so are you going to transition to ranges ?
[20:44:29] <strcat> well we do have ranges
[20:44:32] <strcat> just only forward ones
[20:44:54] <mark_edward> we do haave ranges? where?
[20:45:13] <strcat> Iterator is an InputRange
[20:45:22] <strcat> if it also implements Clone, it's a ForwardRange
[20:45:26] <strcat> because you can save your spot
[20:45:48] *** Quits: gour (gour@moz-F4263343.adsl.net.t-com.hr) (Quit: WeeChat 0.4.0)
[20:45:56] *** Quits: spider-mario (spidermari@moz-81131DB6.fbx.proxad.net) (Ping timeout)
[20:46:18] *** Joins: spider-mario (spidermari@moz-81131DB6.fbx.proxad.net)
[20:46:46] <mark_edward> what would a bidirectional range for say a std::hashmap::HashMap look like then?
[20:47:02] *** Joins: ghrust (ghrust@F6EE6DE3.6A2AE50.F3114085.IP)
[20:47:02] <ghrust> 01[13rust01] 15bors merged 06auto into 06master: 02http://git.io/mCfktg
[20:47:02] *** Parts: ghrust (ghrust@F6EE6DE3.6A2AE50.F3114085.IP) ()
[20:47:32] <strcat> mark_edward: you wouldn't have one for HashMap ;p
[20:47:40] <strcat> the order in a HashMap is arbitrary
[20:47:41] <mark_edward> why is that?
[20:47:56] <strcat> because there's nothing special about the 2nd element compared to the 7th
[20:48:03] <strcat> it's entirely randomized for each hash table
[20:48:05] <mark_edward> but it's fixed if you don't mutaate the map
[20:48:25] <strcat> but it's not a meaningful order
[20:49:09] <mark_edward> i don't see how that voids the usefulness of a BiDiRange for it
[20:49:52] <strcat> what's the use case for iterating from the end if it's arbitrary?
[20:49:55] *** Joins: ghrust (ghrust@614D05BD.6A2AE50.F3114085.IP)
[20:49:55] <ghrust> 01[13rust01] 15bors pushed 0 new commits to 06auto: 02http://git.io/HUZPZg
[20:49:55] *** Parts: ghrust (ghrust@614D05BD.6A2AE50.F3114085.IP) ()
[20:49:59] *** Joins: ghrust (ghrust@24260B07.6A2AE50.F3114085.IP)
[20:49:59] <ghrust> 01[13rust01] 15bors pushed 3 new commits to 06auto: 02http://git.io/PFSmuA
[20:49:59] <ghrust> 13rust/06auto 14419a147 15Michael Sullivan: Fix make_mono_id to take into account self types. Closes #7536.
[20:49:59] <ghrust> 13rust/06auto 147238d5a 15Michael Sullivan: Make privacy checking on default methods for cross crate structs not fail. Closes #7481....
[20:49:59] <ghrust> 13rust/06auto 14b055a10 15bors: auto merge of #7545 : msullivan/rust/default-methods, r=catamorphism...
[20:50:01] *** Parts: ghrust (ghrust@24260B07.6A2AE50.F3114085.IP) ()
[20:50:02] *** Quits: Blei (philipp@moz-650B9C6A.cust.bluewin.ch) (Quit: WeeChat 0.4.1)
[20:50:43] <mark_edward> .i can't think of anyone, but it does no harm and could be useful.
[20:51:03] *** Joins: snadon (chatzilla@moz-3BC727E8.mc.videotron.ca)
[20:51:07] <paupau> mark_edward: YAGNI
[20:51:14] <mark_edward> YAGNI?
[20:51:18] <cmr> you ain't gunna need it
[20:51:23] <strcat> if it doesn't have a use case it's not going to be part of the API
[20:51:31] <mark_edward> oh ok.
[20:51:54] <mark_edward> so what containers have a meaningful order... TreeMap right?
[20:52:21] <paupau> pretty much everything other than hashmaps and hashsets
[20:52:26] *** Joins: tikue (tkuehn@moz-A7CDB794.dia.static.qwest.net)
[20:52:28] <strcat> vectors, deque, treemap (and TreeSet), TrieMap/TrieSet
[20:52:40] <mark_edward> would you make a BiDiRange for a treemap then?
[20:52:48] <strcat> no
[20:52:54] <strcat> it doesn't have parent pointers
[20:53:16] <mark_edward> but it'd be useful though right? just a difficult implementation?
[20:53:24] <strcat> difficult and slow
[20:53:33] <strcat> 2 stacks I guess
[20:53:35] <paupau> mark_edward: the point of using different data structures is they are good at different things
[20:53:59] <strcat> vectors and deque can easily do Bidirectional and RandomAccess
[20:54:03] <strcat> so that's one example
[20:54:05] <mark_edward> can you name containers that you could/would make a BiDirange for then?
[20:55:21] <strcat> we don't have many containers yet
[20:55:27] <strcat> when we have persistent containers there will be a lot more
[20:55:53] <mark_edward> what do you mean by persistent?
[20:56:06] <mark_edward> and you ahve many of the C++ containers already
[20:56:23] <mark_edward> although C++11 introduced a few new ones like priority_que
[20:56:28] <mark_edward> *queue
[20:56:34] <cmr> we already have a priority queue
[20:56:48] <paupau> what's a rust idiomatic way of reading a file line by line
[20:57:01] <paupau> gotta write my own line iterator?
[20:57:20] *** Quits: tikue (tkuehn@moz-A7CDB794.dia.static.qwest.net) (Quit: tikue)
[20:58:04] <mark_edward> what is Rust missing from here? http://www.cplusplus.com/reference/stl/
[20:58:36] <strcat> C++ had priority_queue before C++11
[20:58:47] <strcat> C++11 added unordered_{set,map}
[20:58:49] *** Quits: teratorn (teratorn@moz-5363C32C.teratorn.org) (Connection reset by peer)
[20:59:03] <mark_edward> oh ok
[20:59:24] <mark_edward> but it doesn't look like you're missing anything besides multiset and multimap, right?
[20:59:27] <strcat> C++ doesn't have persistent containers though
[20:59:38] <mark_edward> what is a persistent container?
[20:59:58] <strcat> where you can have efficient views of the whole history of the container
[21:00:03] <Jeaye> I gt a mutability error when my type is mutable. Ideas? https://gist.github.com/Jeaye/ae654e9a739068713848
[21:00:10] <strcat> git is a persistent directed graph
[21:00:30] <strcat> a simple one is a persistent singly-linked list
[21:00:31] *** Joins: maxli (maxli@B5559308.9C54E60.2FA4EA88.IP)
[21:00:42] <cmr> Jeaye: mut state: @mut State, I think? @mut is weird though
[21:00:44] <strcat> it uses either reference counting or gc for the nodes, and when you prepend a node you're given a new list
[21:01:06] <Jeaye> cmr: Huh, I didn't even know that was valid syntax.
[21:01:11] <Jeaye> Let's see.
[21:01:16] <strcat> and you can take views of the list by referencing a node further back
[21:01:30] <strcat> persistent binary trees are pretty simple too
[21:01:52] <mark_edward> what's the use case? I've never even heard of a PL with that in it's standard library
[21:01:59] *** Quits: cp (cp@moz-993078EE.plus.com) (Ping timeout)
[21:02:32] <Jeaye> cmr: Did the trick, thanks. :)
[21:02:42] <strcat> mark_edward: well what's the use case of git? there are plenty of cases where you want views of multiple previous states
[21:02:45] <Eridius> paupau: std::io::ReaderUtil has a method .each_line which is an internal line iterator
[21:03:02] <strcat> mark_edward: haskell and clojure primarily use persistent data structures
[21:03:05] <paupau> Eridius: oh thanks very much!
[21:03:07] <strcat> languages like scala have them included
[21:03:09] *** Joins: carllerche (carllerche@6B070D22.7E6A0813.1428D117.IP)
[21:03:10] <strcat> and rust will too
[21:03:21] <mark_edward> how are haskell lists persistenet?
[21:04:04] *** Quits: pyrac (pyrac@moz-18D74BD0.w90-60.abo.wanadoo.fr) (Quit: pyrac)
[21:04:11] <strcat> because they are immutable and share structure
[21:04:22] <strcat> when you prepend an element to some view of the list, you have a new list
[21:04:27] <strcat> but it never copies the list
[21:04:32] *** Quits: korenchkin (Mibbit@moz-8DE1FF0F.pools.arcor-ip.net) (Quit: http://www.mibbit.com ajax IRC Client)
[21:05:02] <strcat> it does the same thing for Data.Set and Data.Map but balancing reduces the sharing by a bounded worst case
[21:05:44] <engla> the conflict with rust is that such datastructures rely on GC
[21:05:53] *** Quits: snadon (chatzilla@moz-3BC727E8.mc.videotron.ca) (Client exited)
[21:05:59] <mark_edward> it doesn't copy the list???? how? you cant modify an immutable structure without creating a new copy can you?
[21:06:01] <strcat> gc or reference counting
[21:06:05] <engla> and they are not compact (lots of pointer traversals)
[21:06:06] <engla> yeah
[21:06:29] <strcat> mark_edward: it doesn't have to modify the existing structure
[21:06:31] <strcat> here's a list
[21:06:41] <paupau> is there something more more concise than std::path::GenericPath::from_str()?
[21:06:43] <strcat> xs = 5 -> 4 -> 2 -> 1
[21:06:50] <strcat> ys = 6 -> xs
[21:06:52] <strcat> now ys is
[21:06:56] <strcat> 6 -> 5 -> 4 -> 2 -> 1
[21:06:59] <strcat> it just points at the 5
[21:07:02] <strcat> now lets say
[21:07:36] <strcat> zs = 10 -> 9 -> xs[1]
[21:07:44] <strcat> so zs is 10 -> 9 -> 4 -> 2 -> 1
[21:07:51] <strcat> all 3 lists share some substructure, there were no copies
[21:08:36] <mark_edward> ah i see. but that's just because every node in a list is also a list in and of itself, and that cons just changes the next pt.
[21:08:48] <mark_edward> how would you have say a persistent vector type?
[21:09:14] <strcat> persistent vectors are usually something like a flattened trie
[21:10:16] <mark_edward> will they still maintain their memory contiguousness/compactness?
[21:10:28] <strcat> not entirely
[21:10:30] <strcat> only partially
[21:11:54] *** Quits: MaikKlein (maik@moz-51F0F9C8.dip0.t-ipconnect.de) (Ping timeout)
[21:11:57] <mark_edward> git seems like a very specific use case. are they any more general ones for persistance containers? i bet most industry devs, even great experienced, would never use them
[21:12:08] <paupau> "error: failed to find an implementation of trait std::path::GenericPath for &std::path::PosixPath"
[21:12:11] <paupau> whaaat
[21:12:30] <paupau> oh
[21:12:32] <paupau> I needed a &?
[21:12:32] <strcat> mark_edward: undo trees
[21:12:39] <strcat> for any application with 'undo'
[21:12:43] <engla> mark_edward: http://en.wikipedia.org/wiki/Hash_array_mapped_trie is an example
[21:12:47] <strcat> if you represent undo/redo as a stack....
[21:12:52] <strcat> undo undo undo, change something
[21:12:57] <strcat> bam, you lost a whole segment of the tree
[21:13:01] <strcat> you can no longer redo
[21:13:02] *** Joins: marmelade (marmelade@moz-33353561.dip0.t-ipconnect.de)
[21:13:09] <strcat> emacs/vim implement undo trees as persistent trees
[21:13:12] <cmr> (vim uses an undo tree)
[21:13:14] <strcat> other applications with 'unfo' should too.
[21:13:15] <paupau> you can (not) redo
[21:13:25] <strcat> undo*
[21:13:34] <strcat> silly f key
[21:13:36] <mark_edward> but like, that seems like something not worth putting it in standard library for. \
[21:14:02] <engla> that undo tree is regularly useful
[21:14:05] <mark_edward> but things like vectors and maps and stacks and queues are universally used in all sorts of things
[21:14:18] <strcat> so are persistent data structures
[21:14:19] <engla> (vim also has persistent undo nowadays)
[21:14:29] <strcat> you haven't used them because you haven't had them available
[21:15:20] <mark_edward> i guess. is this stuff supposed to happen before 1.0?
[21:15:27] <strcat> it can
[21:15:40] <strcat> it's not going to be a completion feature for 1.0
[21:15:50] <strcat> but it's the kind of thing that's easy for anyone to contribute
[21:16:08] *** Joins: MaikKlein (maik@moz-51F0F9C8.dip0.t-ipconnect.de)
[21:16:31] <mark_edward> oh ok well i'd love to figure out a use case for them,.
[21:16:56] *** Quits: Ms2ger (Ms2ger@moz-12E1F766.adsl-dyn.isp.belgacom.be) (Quit: nn)
[21:17:11] *** Joins: graydon (Adium@A5087023.2354C43D.D8E68FF6.IP)
[21:17:11] *** ChanServ sets mode: +qo graydon graydon
[21:18:28] <mark_edward> should smallintmap have reverse iterators?
[21:18:41] <mark_edward> hashmap doesnt
[21:18:46] *** Joins: int3_ (int3_@moz-ABE52D50.hsd1.ca.comcast.net)
[21:19:29] *** Quits: spider-mario (spidermari@moz-81131DB6.fbx.proxad.net) (Ping timeout)
[21:20:17] <strcat> mark_edward: smallintmap should
[21:20:21] <mark_edward> but he issue here: https://github.com/mozilla/rust/issues/7366 says it does
[21:20:24] <strcat> I don't think smallintmap even has a forward one
[21:20:28] *** Joins: spider-mario (spidermari@moz-81131DB6.fbx.proxad.net)
[21:20:33] <paupau> "use extra::base64" doesn't seem to work for me
[21:20:37] <paupau> do I need to install extra or something
[21:20:39] <mark_edward> strcat: oh ok. can you explain why? it doesn't have any. im trying to write name
[21:20:50] <cmr> paupau: what's the error
[21:20:51] <mark_edward> *write them
[21:20:52] <cmr> ?
[21:21:00] <paupau> crypto.rs:1:4: 1:9 error: unresolved import. maybe a missing `extern mod extra`?
[21:21:08] <paupau> oh, there's a solution :)
[21:21:08] <strcat> mark_edward: because it's ordered by the key value
[21:21:14] <strcat> it's not arbitrary
[21:21:17] <cmr> You know, I added that hint hoping people would see it
[21:21:23] <cmr> And so far, it seems nobody has
[21:21:25] <cmr> :p
[21:21:27] <paupau> ;_;
[21:21:44] <brendanc> needs more color?
[21:21:55] <mark_edward> oh ok
[21:23:35] *** Quits: MaikKlein (maik@moz-51F0F9C8.dip0.t-ipconnect.de) (Ping timeout)
[21:23:53] <cmr> sully: your default method fix works well, thanks <3
[21:24:09] <paupau> sigh, I'm a dummy, I still can't get my ~[u8].to_base64() to work
[21:24:30] *** Quits: Ralith (ralith@moz-50F3C77.vc.shawcable.net) (Ping timeout)
[21:24:41] <paupau> it ought to have the ToBase64 trait....
[21:25:03] <paupau> oh, import problem.
[21:25:04] <paupau> got it.
[21:25:46] *** Quits: mnemotic (niko@8FFD1BD2.9D81E74C.53DF0002.IP) (Ping timeout)
[21:28:22] <Thad> what is the name of this type ?   typedef struct SRWLOCK { void* p; };
[21:32:16] *** Joins: korenchkin (smuxi@moz-8DE1FF0F.pools.arcor-ip.net)
[21:32:43] <engla> that's not rust Thad
[21:32:47] <engla> I don't think it parses as C
[21:32:48] <Thad> no joe.
[21:32:51] <Thad> joke
[21:33:13] <Thad> trying to fix rust , libuv, and mingw-64 headers
[21:33:33] <Thad> SRWLOCK srwlock_;   SRWLOCK does not name a type
[21:33:47] *** Joins: victorporof (victorporo@74A9C5E8.1745F5FA.9B1E38F4.IP)
[21:33:48] <engla> I don't think your typedef line should compile
[21:33:49] <Thad> uv-win.h:240:3:error
[21:34:07] <engla> typedef struct  { void* p; } SRWLOCK;  would be the normal form
[21:34:14] <engla> or not typedeffing at all
[21:34:16] <Thad> http://msdn.microsoft.com/en-us/library/ms683483%28v=vs.85%29.aspx
[21:34:17] *** Quits: marmelade (marmelade@moz-33353561.dip0.t-ipconnect.de) (Quit: oO0°)
[21:34:23] <paupau> I feel like this signature isn't very rusty: fn xor(input: ~[u8], b: [u8]) -> ~[u8]
[21:34:43] <paupau> how can I make it better?
[21:34:59] <SiegeLord> I'd make it take a slice
[21:35:20] *** Quits: spider-mario (spidermari@moz-81131DB6.fbx.proxad.net) (Input/output error)
[21:35:21] <engla> you can take three slices
[21:35:32] *** Joins: bjz (brendanzab@B398BE78.F804C29E.D35A31DF.IP)
[21:36:10] <Luqman> Thad: oh, i think the SRWLOCK should no longer be an issue
[21:36:14] <paupau> SiegeLord: trying that, but I get "error: cannot borrow immutable vec content as mutable" at the caller
[21:36:28] <Thad> Luqman: how so , no longer an issue ?
[21:36:31] <paupau> oh, mut did it
[21:36:56] <paupau> I should get a rubber duck
[21:37:30] <Luqman> Thad: the changes to platform.mk that should've landed for windows added -D_WIN32_WINNT=0x0600 which makes it no longer complain about SRWLOCK
[21:38:09] <Thad> Luqman: that's basically what I have in winnt.h for mingw-64 .... now...lolol...
[21:38:17] <SiegeLord> Will a specific compiler requirement go away when the rust runtime is rewritten in Rust?
[21:38:29] <Thad> http://pastebin.mozilla.org/2592453
[21:38:33] <Thad> Luqman: http://pastebin.mozilla.org/2592453
[21:39:09] <Thad> Luqman: I wonder if the fix should not be there in mingw-64 as well ?  as I put it ?
[21:39:17] <Thad> Thoughts?
[21:39:48] <Luqman> Thad: which bit?
[21:39:50] <Thad> Luqman: btw, that's basically saying Windows Vista and Greater.
[21:40:09] <Thad> Luqman: winnt.h : 6530
[21:40:11] *** Joins: MrFahrenheit (RageOfThou@3FEF494C.29C984D5.783DEDCA.IP)
[21:40:43] <cmr> you're a brave soul, looking into the windows headers
[21:40:49] <cmr> it's like gazing into the void...
[21:40:55] <Luqman> Thad: i think that's fine considering that's what libuv does as well https://github.com/joyent/libuv/commit/b471b33da88da0ca0b913573370cc6919ec134e7
[21:40:57] <bstrie> brave? some would say foolish
[21:41:17] <Thad> cmr: Medal for my chest, then ? :)
[21:41:49] <Luqman> Thad: also something else i realized was llvm needs to be modified to support segmented stacks on win64
[21:41:51] <Thad> Luqman: so you agree that it should probably also be added to mingw ?
[21:42:16] <Luqman> Thad: add where?
[21:42:18] <Thad> Luqman: trying to help all the orgs with their Windows code...as I can.
[21:43:38] <Thad> Luqman: Here ->> http://sourceforge.net/p/mingw-w64/code/HEAD/tree/trunk/mingw-w64-headers/include/winnt.h#l6458
[21:44:05] *** Joins: Ralith (ralith@moz-AFAA4205.wireless.sfu.ca)
[21:46:13] <Luqman> Thad: ah, i guess. i haven't really done any development on windows so i'm not sure :P
[21:46:34] *** Quits: toddaaro (toddaaro@moz-98F46974.us) (Input/output error)
[21:47:44] <Luqman> Thad: also, can you try making a really simple c++ file and compiling with g++ -m32 and then running it
[21:48:01] <Thad> Luqman: can you GIVE me a really simple c++ file ?
[21:48:31] <Thad> Luqman: I know Python (done)
[21:48:41] <Thad> (well some Java)
[21:48:48] *** Quits: paupau (NEAT@moz-BFE94859.hfc.comcastbusiness.net) (Ping timeout)
[21:49:06] <strcat> int main() {}
[21:49:32] <Luqman> Thad: ^
[21:49:40] <Thad> Luqman: k
[21:50:28] <Thad> Luqman: pulled from master... it's building further with mingw-w64 (gcc4.8.1)
[21:51:29] *** Quits: maxli (maxli@B5559308.9C54E60.2FA4EA88.IP) (Quit: Leaving.)
[21:51:44] <Thad> Luqman: llvm-tblgen.exe ERROR   http://pastebin.mozilla.org/2592467
[21:53:03] *** Quits: Kruppe (user@moz-4DDA8AB8.uwaterloo.ca) (Ping timeout)
[21:53:36] <Luqman> Thad: yes, i ran into that too
[21:53:41] <Jeaye> What did vec::as_imm_buf become?
[21:53:48] <Luqman> and i think the problem is g++ with the -m32 flag
[21:53:57] <Luqman> it doesn't even seem to work with a simple program
[21:54:06] <jmgrosen> what's the state of rust on linux arm?
[21:55:08] <Luqman> jmgrosen: i think waiting on some llvm patches
[21:55:17] *** Quits: vk (vk@moz-389FEE13.hsd1.ca.comcast.net) (Quit: vk)
[21:56:06] <jmgrosen> Luqman: ah, ok
[21:56:10] <jmgrosen> Luqman: any ETA?
[21:57:23] <Luqman> jmgrosen: not sure https://github.com/mozilla/rust/pull/7115/files
[21:57:41] <Luqman> Thad: i think i know why the error seems to be occuring
[21:58:04] <Jeaye> Shows it's here: http://static.rust-lang.org/doc/std/vec.html#function-as_imm_buf
[21:58:14] <mark_edward> strcat: what should the size_hint be on SmallIntMap iterator? best i can figure is (None, Some(length_of_underlying_vec)) or (Some(0),Some(same_as_b4))
[21:58:17] <Jeaye> But I'm getting an error 'use'ing it.
[21:58:17] <Luqman> Thad: it might be because it can't find libgcc_s_sjlj-1.dll and libstd++6.dll
[21:58:19] <Thad> Luqman: your right... so the g++ for mingw-w64 (64bit version) called fully x86_64-w64-mingw32-g++.exe   is NOT compiled with multilib !
[21:58:46] <Luqman> Thad: :( that's disappointing
[21:58:57] <strcat> mark_edward: yeah that's fine
[21:59:02] <strcat> Option is going away on the lower bound
[21:59:04] <mark_edward> which one?
[21:59:04] <Thad> Luqman: But there docs and wiki say "neah"...
[21:59:12] <strcat> mark_edward: you won't have a choice ;p
[21:59:15] <Thad> Luqman: so we MUST be doing something wrong...
[21:59:19] <mark_edward> oh ok.
[21:59:20] <strcat> it will be 0, Some(vec.len())
[21:59:27] <mark_edward> when can i expect that change?
[22:00:05] <Luqman> Thad: actually, I see --enable-mutlilib in g++ -v
[22:00:25] <Thad> Luqman: how did you find that ?
[22:00:36] <strcat> mark_edward: I think it's an open PR
[22:00:43] <mark_edward> ok
[22:00:43] <Thad> Luqman: OH  -v
[22:00:54] <strcat> mark_edward: https://github.com/mozilla/rust/pull/7570
[22:01:07] <mark_edward> whose responsibility is it to change these things? that will break all current iterators right?
[22:02:07] <doomlord_> slice ... is ther a single helper function to get the the whole of ~[T] as a slice...  a.slice(0,a.len()) 
[22:02:14] <strcat> doomlord_: it will coerce
[22:02:21] <Thad> Luqman: hell, the title on sourceforge even says "dual targets"
[22:02:23] <strcat> id::<&[T]>(xs)
[22:02:31] <strcat> let slice: &[T] = xs;
[22:02:40] <engla> doomlord_: as_slice, too
[22:03:25] <engla> rusti: let v = ~[1i,2]; v.as_slice()
[22:03:27] -rusti- more than 5 lines of output, pastebinned: http://sprunge.us/ZjOc
[22:03:42] <engla> oh right. :-|
[22:03:47] <doomlord_> what i'm trying to do.. (i'm looking at vec.rs for reference..) is implement my 'findBest(array,costFunc)' as a method .. trying to figure out how to make it work with the various pointer types. I seemed to have it working as a function ok
[22:03:48] <engla> never can it be correct on first try
[22:04:02] <strcat> doomlord_: can you use max_by/min_by?
[22:04:04] *** Quits: true_droid (Adium@moz-123FD9B8.beck.volia.net) (Ping timeout)
[22:04:24] <km> I'm playing with Rust for the first time, and I'm trying to understand variable moves (and tasks). I have http://hastebin.com/webowalevo.rs . I added line 9 because it makes sense that you can't capture a mutable variable in a closure used for a task, but now I get the error "cannot move out of captured outer variable" on that line instead. What's a good way to get a non-copyable value from a previous loop iteration?
[22:04:29] <doomlord_> maybe there is something already to do this: but as a learning excercise i need to understand exactly how to write this myself
[22:04:51] <strcat> rusti: let xs = [11, 20, 2, 1, 9, 8]; fmt!("%?", xs.iter().max_by(|x| x))
[22:04:52] -rusti- more than 5 lines of output, pastebinned: http://sprunge.us/DIUj
[22:04:54] <doomlord_> or i dont feel proficient in the language
[22:04:55] <strcat> rusti: let xs = [11, 20, 2, 1, 9, 8]; fmt!("%?", xs.iter().max_by(|x| *x))
[22:04:56] -rusti- ~"Some(&20)"
[22:05:00] <strcat> rusti: let xs = [11, 20, 2, 1, 9, 8]; fmt!("%?", xs.iter().max_by(|x| -*x))
[22:05:01] -rusti- ~"Some(&1)"
[22:05:17] <strcat> rusti: let xs = [11, 20, 2, 1, 9, 8]; fmt!("%?", xs.iter().max_by(|x| (*x - 5).abs()))
[22:05:17] -rusti- ~"Some(&20)"
[22:05:24] <doomlord_> if max_by does it... i wont look yet, its cheating :)
[22:05:32] <strcat> rusti: let xs = [11, 20, 2, 1, 9, 8]; fmt!("%?", xs.iter().max_by(|x| -(5 - *x).abs()))
[22:05:33] -rusti- more than 5 lines of output, pastebinned: http://sprunge.us/cViL
[22:05:47] <doomlord_> of course its good to see you already have this in there.,.
[22:06:05] *** Joins: true_droid (Adium@moz-123FD9B8.beck.volia.net)
[22:06:14] <strcat> rusti: let xs = [11, 20, 2, 1, 9, 8]; fmt!("%?", xs.iter().max_by(|x| (*x - 5).abs()))
[22:06:14] -rusti- ~"Some(&20)"
[22:06:17] <strcat> rusti: let xs = [11, 20, 2, 1, 9, 8]; fmt!("%?", xs.iter().max_by(|x| -(*x - 5).abs()))
[22:06:18] -rusti- ~"Some(&2)"
[22:06:23] <strcat> rusti: let xs = [11, 20, 2, 1, 9, 8]; fmt!("%?", xs.iter().max_by(|x| -(*x - 8).abs()))
[22:06:24] -rusti- ~"Some(&8)"
[22:06:30] <strcat> rusti: let xs = [11, 20, 2, 1, 9, 8]; fmt!("%?", xs.iter().max_by(|x| -(*x - 11).abs()))
[22:06:31] -rusti- ~"Some(&11)"
[22:06:37] <strcat> rusti: let xs = [11, 20, 2, 1, 9, 8]; fmt!("%?", xs.iter().max_by(|x| -(*x - 13).abs()))
[22:06:37] -rusti- ~"Some(&11)"
[22:06:50] * strcat shrugs
[22:07:55] <doomlord_> ok great
[22:08:10] <brendanc> hmm. http://buildbot.rust-lang.org/builders/auto-linux-64-opt-vg/builds/273 has been running for 7 hours
[22:08:46] <doomlord_> i'll use max_by in practice (but for my satisfaction i must still  understand how to write this)
[22:09:05] * strcat was just making sure it worked as intended ;p
[22:09:21] <doomlord_> i was going to ask if you already had such a function too :)
[22:09:21] *** Joins: steven_is_false (user@moz-144077DE.bchsia.telus.net)
[22:09:26] <mark_edward> is 'self a special region?
[22:09:30] <strcat> mark_edward: no
[22:09:35] <mark_edward> ok cool
[22:09:38] <strcat> 'static is the only special lifetime
[22:09:52] <strcat> 'self is currently the only name you're allowed to give to type parameters other than 'static, but that will be relaxed
[22:10:01] <doomlord_> one minor difference.. my version also returns the score - and position in the container
[22:10:24] *** Joins: toddaaro (toddaaro@moz-98F46974.us)
[22:10:49] <doomlord_> (best,score,index) = findBest(array, |x|...)  
[22:11:17] <Jeaye> Latest master: error: unresolved import: there is no `as_imm_buf` in `std::vec`
[22:12:09] <strcat> Jeaye: the free functions are gone
[22:12:15] <strcat> except the ones not operating on a vector
[22:12:35] <Jeaye> ahhh
[22:13:20] <strcat> well
[22:13:23] <strcat> and some deprecated ones
[22:13:26] *** Joins: acrichto (acrichto@moz-B63D64BD.res.cmu.edu)
[22:16:18] *** Parts: steven_is_false (user@moz-144077DE.bchsia.telus.net) (ERC Version 5.3 (IRC client for Emacs))
[22:16:56] <Jeaye> Thanks. :
[22:16:58] <Jeaye> :)
[22:17:27] <doomlord_> heh. Seems i was nearly there. I simply wasn't making my trait 'pub' which is why i couldn't call it lol
[22:17:47] <bjz> Jeaye: https://github.com/mozilla/servo/pull/563
[22:17:48] *** Joins: pnathan (Adium@moz-E3C3FAF2.hfc.comcastbusiness.net)
[22:17:59] <bjz> Jeaye: :D
[22:18:21] <doomlord_> (i thought i needed to implement it diffently to work for &[T] and ~[T] ... but you say it coerces ~[T] to &[T} ?)
[22:19:31] <doomlord_> being able to bolt functionality onto the existing types is a major draw toward rust for me
[22:19:36] <Jeaye> bjz: That's awesome! :D
[22:20:33] <doomlord_> glfw, i'll have to take a look..
[22:21:00] <bjz> Jeaye: my only sadface: https://github.com/mozilla/servo/pull/563/files#L6R27
[22:21:13] <bjz> Jeaye: need to figure out a better way
[22:22:29] *** Quits: Ralith (ralith@moz-AFAA4205.wireless.sfu.ca) (Ping timeout)
[22:22:40] <Jeaye> bjz: Why is that needed? q3 doesn't have it.
[22:22:56] <bjz> Jeaye: it's done automatically in glfw::spawn
[22:23:30] *** Joins: maxli (maxli@B5559308.9C54E60.2FA4EA88.IP)
[22:24:03] *** Quits: pnathan (Adium@moz-E3C3FAF2.hfc.comcastbusiness.net) (Ping timeout)
[22:24:26] *** Joins: mreedell (mreedell@moz-9950CA28.hsd1.pa.comcast.net)
[22:24:42] <Jeaye> internal compiler error: no type for node 670: expr right * self.move_speed (id=670) in fcx 7fba1647f530
[22:25:00] <Jeaye> Aww, hadn't seen an ICE in a while.
[22:25:16] <cmr> I've only hit two in rustdoc_ng
[22:25:28] <cmr> I'm under quota, usually get one for each new file I write ;)
[22:25:37] <doomlord_> do sugar is neat
[22:25:43] *** Joins: MaikKlein (maik@moz-51F0F9C8.dip0.t-ipconnect.de)
[22:25:49] <cmr> doomlord_: yeah, it's quite handy
[22:26:02] <Jeaye> doomlord_: Aye, quite nice.
[22:26:09] *** Joins: gareth0 (gareth0@7C428FA9.3FD5F917.1A294DCF.IP)
[22:27:17] *** Quits: jaen (jaen@moz-E0979827.copit.pl) (Quit: WeeChat 0.4.1)
[22:27:49] *** Joins: jviereck (Adium@moz-F755A369.adsl.alicedsl.de)
[22:28:29] <cmr> Heh, one of my friends just got an ICE out of MSVC!
[22:28:31] <cmr> "c:\users\john\skydrive\code\source\utilities\utilities\DataStream.h(135): fatal error C1001: An internal error has occurred in the compiler."
[22:28:53] <Jeaye> heh
[22:28:57] *** Joins: ghrust (ghrust@CFE85B59.6A2AE50.F3114085.IP)
[22:28:57] <ghrust> 01[13rust01] 15bors merged 06auto into 06master: 02http://git.io/PFSmuA
[22:28:57] *** Parts: ghrust (ghrust@CFE85B59.6A2AE50.F3114085.IP) ()
[22:28:59] *** Quits: jviereck (Adium@moz-F755A369.adsl.alicedsl.de) (Quit: Leaving.)
[22:29:28] <Thad> Luqman: going out to eat... will modify the Wiki step by steps when I get back.... Jon mentioned to please encourage Rust Windows builders to use the installer version for Mingw-builds...I'll make sure to write it up nice and neat.
[22:29:28] *** Quits: maxli (maxli@B5559308.9C54E60.2FA4EA88.IP) (Ping timeout)
[22:29:29] *** Joins: jaen (jaen@moz-E0979827.copit.pl)
[22:31:44] *** Quits: Thad (chatzilla@moz-C35F90AE.tx.res.rr.com) (Quit: ChatZilla 0.9.90 [Firefox 23.0/20130625125232])
[22:31:56] *** Joins: ghrust (ghrust@79968228.6A2AE50.F3114085.IP)
[22:31:56] <ghrust> 01[13rust01] 15bors pushed 0 new commits to 06auto: 02http://git.io/U-6o8g
[22:31:56] *** Parts: ghrust (ghrust@79968228.6A2AE50.F3114085.IP) ()
[22:31:58] *** Joins: ghrust (ghrust@E7A4CCE2.6A2AE50.F3114085.IP)
[22:31:58] <ghrust> 01[13rust01] 15bors pushed 2 new commits to 06auto: 02http://git.io/Lbyh_A
[22:31:58] <ghrust> 13rust/06auto 145b31e0c 15Alex Crichton: Bring compiletest/rustpkg/driver up to date on std vs core
[22:31:58] <ghrust> 13rust/06auto 14705ce42 15bors: auto merge of #7520 : alexcrichton/rust/update-compiletest, r=pcwalton...
[22:31:58] *** Parts: ghrust (ghrust@E7A4CCE2.6A2AE50.F3114085.IP) ()
[22:33:18] *** Quits: bytbox (s@moz-DC83764A.washdc.fios.verizon.net) (Ping timeout)
[22:33:25] <Jeaye> What changed in 0.7 to affect the Add trait? I don't see it in the release notes, but I'm getting https://gist.github.com/Jeaye/ed35e1173f750bbeb316 
[22:33:42] <Jeaye> tl;dr error: binary operation - cannot be applied to type `math::vec3::vecf::Vec3f`
[22:33:56] <mark_edward> rusti: let op = &Some(5); match op { &None => { ":-(" } &Some(_) => { ":-)" } 
[22:33:56] <cmr> Jeaye: += and friends where removed
[22:33:56] -rusti- <anon>:10:0: 10:1 error: file ended with unbalanced delimiters
[22:33:56] -rusti- <anon>:10 }
[22:33:57] -rusti-           ^
[22:33:57] -rusti- application terminated with error code 101
[22:34:05] <mark_edward> rusti: let op = &Some(5); match op { &None => { ":-(" } &Some(_) => { ":-)" } }
[22:34:06] -rusti- ":-)"
[22:34:38] <cmr> Jeaye: they were broken (multiple evaluation) and fragile
[22:34:38] <mark_edward> cool
[22:34:43] <Jeaye> cmr: So we just don't have the compound ops anymore?
[22:34:45] <cmr> to be replaced with AddAssign and such
[22:34:53] <cmr> Jeaye: they still work on ints and stuff
[22:34:58] <cmr> just the trait that isn't used
[22:35:20] <cmr> pcwalton frontloaded all the breaking changes he could so 0.7 code wouldn't be *quite* as hard to port ;)
[22:35:27] <Jeaye> Ok, so they don't come from Add, Sub, etc, and AddAssign, SubAssign, etc are not yet provided?
[22:35:37] <cmr> yup
[22:35:52] <Jeaye> Ok. Maybe that should be in the detailed release notes.
[22:36:33] <cmr> probably should be!
[22:37:53] <cmr> The proggit thread on 0.7 is surprisingly not full of deadwit trolls (yet)
[22:41:48] <strcat> cmr: I scared off one
[22:41:50] <strcat> ;p
[22:41:56] *** Quits: MaikKlein (maik@moz-51F0F9C8.dip0.t-ipconnect.de) (Ping timeout)
[22:42:06] *** Quits: mreedell (mreedell@moz-9950CA28.hsd1.pa.comcast.net) (Quit: Computer has gone to sleep.)
[22:42:48] * strcat wonders how hard changing the slice representation would be
[22:42:58] <cmr> it'd be a nightmare I imagine
[22:43:32] <Jeaye> cmr: https://github.com/mozilla/rust/wiki/Doc-detailed-release-notes End of the Numeric Traits section.
[22:43:37] *** Quits: carllerche (carllerche@6B070D22.7E6A0813.1428D117.IP) (Quit: carllerche)
[22:43:45] <Jeaye> Mind telling me if that looks fine?
[22:43:55] <cmr> looks good to me
[22:44:06] <Jeaye> Cool, thanks for the info.
[22:44:07] <strcat> cmr: can't be as hard as removing ~ headers
[22:44:12] <strcat> which is maybe 65% done ;p
[22:44:15] <cmr> heh
[22:44:19] <cmr> you were half done yesterday!
[22:45:06] * strcat fixed one more thing
[22:45:09] <strcat> the glue is all broken though
[22:45:21] *** Joins: jviereck (Adium@moz-F755A369.adsl.alicedsl.de)
[22:45:22] <strcat> and glue calls other glue recursively so the traceback is 200 lines
[22:45:34] <cmr> :(
[22:45:41] <strcat> I somehow doubt that we use ~Trait in libstd so it must just be ~T take glue
[22:45:43] <strcat> or ~[]
[22:45:45] <strcat> or ~fn
[22:45:47] <strcat> ;\
[22:48:13] <cmr> indutny: you saw your PR failed, right?
[22:48:54] *** Joins: Ralith (ralith@moz-50F3C77.vc.shawcable.net)
[22:49:40] <mark_edward> what's the smallest/fastest make target for rust?
[22:50:08] <strcat> make docs ;p
[22:50:22] <strcat> meh maybe not
[22:50:33] <strcat> the dep tree is all wrong
[22:51:08] <engla> you can build the crates individually with rustc
[22:51:12] <engla> rustc rustc.rs etc
[22:51:37] *** Joins: paupau (NEAT@moz-C616DA0A.hsd1.ca.comcast.net)
[22:52:24] * xenocons glares at inbox searching for excuse to write rust
[22:52:35] <mark_edward> can i build std.rs?
[22:52:43] <cmr> mark_edward: yup
[22:52:46] <mark_edward> cool
[22:53:03] *** Quits: true_droid (Adium@moz-123FD9B8.beck.volia.net) (Quit: Leaving.)
[22:53:09] <mark_edward> xenocons: write  it as an alternative medicine healing process
[22:53:22] <mark_edward> does your insurance cover some alt-med?
[22:53:26] <xenocons> heh
[22:53:39] <xenocons> no i just want something at work to come up where i can use rust
[22:53:42] <friggle> ooh, interesting post from pcwalton on the mailing list. Glad to see others agreeing with strcat on segmented stacks
[22:53:56] <mark_edward> friggle: can you give me the link?
[22:54:23] <friggle> mark_edward: https://mail.mozilla.org/pipermail/rust-dev/2013-July/004686.html
[22:54:29] <mark_edward> thanks
[22:54:47] <engla> xenocons: buildbots can be used as heating elements
[22:54:56] <cmr> hahah
[22:55:42] <xenocons> heh
[22:56:12] *** Joins: carllerche (carllerche@6B070D22.7E6A0813.1428D117.IP)
[22:56:22] <xenocons> unfortunately i dont think i would have the auth to donate that
[22:57:09] *** Quits: jviereck (Adium@moz-F755A369.adsl.alicedsl.de) (Quit: Leaving.)
[23:01:26] <cmr> Anyone know where the AST stuffs the name of a trait? I see item_trait(Generics, ~[@trait_ref], ~[trait_method]). I imagine the name would be in one of the trait_refs as the path, but are there ever more than one?
[23:01:41] *** Joins: Kruppe (user@moz-E150F49F.cpe.net.cable.rogers.com)
[23:01:59] *** Quits: Kruppe (user@moz-E150F49F.cpe.net.cable.rogers.com) (Client exited)
[23:02:16] *** Joins: Kruppe (user@moz-E150F49F.cpe.net.cable.rogers.com)
[23:02:53] <eevee> error: aborting due to 611 previous errors
[23:02:54] <eevee> oh no
[23:03:09] *** Quits: gareth0 (gareth0@7C428FA9.3FD5F917.1A294DCF.IP) (Client exited)
[23:03:29] <cmr> pft, that's nothing, my personal record is somewhere in the 5000s
[23:04:05] <xenocons> friggle: yeah i think i agree (not knowing much about this topic, but have been following it with curiosity) i think waltons comments are pretty consistent with what ive read around
[23:04:29] *** Joins: ghrust (ghrust@2EE61FCC.6A2AE50.F3114085.IP)
[23:04:29] <ghrust> 01[13rust01] 15alexcrichton 04force-pushed 06try from 141098d69 to 14bce8a86: 02http://git.io/k471pw
[23:04:29] <ghrust> 13rust/06try 149da0b5a 15Brian Anderson: Try to fix a periodic windows build failure due to broken rwildcard macro
[23:04:29] <ghrust> 13rust/06try 1434d8e67 15Alex Crichton: Update LLVM
[23:04:29] <ghrust> 13rust/06try 148a7b169 15Alex Crichton: Fix build issues once LLVM has been upgraded...
[23:04:30] *** Parts: ghrust (ghrust@2EE61FCC.6A2AE50.F3114085.IP) ()
[23:04:36] *** Quits: Blub\w (wry@7E3BB9D.71150E1A.237AE2BA.IP) (Quit: night)
[23:04:45] <xenocons> now its time for rust team to think of a stack allocation method that is new and better than the rest :P)
[23:05:09] <graydon> r? someone https://github.com/mozilla/rust/pull/7456
[23:05:11] <cmr> every task gets 1TiB of stack!
[23:05:21] <xenocons> woot
[23:05:53] <xenocons> a stack in the heap that has page modifiers so u get a BSoD when its paged
[23:05:56] <eevee> to be fair most of these are complaints about ++ modes on stuff from bindgen
[23:05:57] <engla> great
[23:05:58] <friggle> well I'm not particulrly opposed to segmented stacks, but agree it should be easy to turn them off
[23:06:03] <eevee> i assume i can just delete the mode
[23:06:20] <xenocons> friggle: im opposed if they cause performance penalty of stack allocations i guess
[23:07:12] <mark_edward> when we fork the rust repo to work on it, should we make branches that we then rebase, or just work on master?
[23:07:28] <cmr> mark_edward: branches, and don't bother rebasing
[23:07:36] <SiegeLord> It's always a good idea to make feature branches
[23:07:53] <mark_edward> why no rebasing? 
[23:11:28] <cmr> it's pointless
[23:11:49] <cmr> you can open a pr from any branch to any branch
[23:12:05] <cmr> usually PRs don't conflict
[23:12:11] <cmr> when there are conflicts you of course rebas
[23:12:36] *** Quits: carllerche (carllerche@6B070D22.7E6A0813.1428D117.IP) (Quit: carllerche)
[23:12:55] <kimundi> in short: use any branch you want, rebase if you feel like it :P
[23:13:42] *** Joins: ChrisMorgan (chris@moz-6AC741CA.static.tpgi.com.au)
[23:14:33] <mark_edward> cmr: do i need to update my fork to latest mozilla rust before committing?
[23:14:58] <cmr> mark_edward: usually you'd fork your branch off of mozilla/rust, which you fetch from frequently
[23:15:09] <cmr> least, that's what I do
[23:15:39] *** Joins: vk (vk@2AAA6DD0.B568D26C.93B001FA.IP)
[23:15:41] <mark_edward> what's the git command you use?
[23:15:47] <cmr> for what?
[23:16:19] *** Quits: vk (vk@2AAA6DD0.B568D26C.93B001FA.IP) (Quit: vk)
[23:16:23] <mark_edward> fetching from mozilla/rust
[23:16:34] <cmr> `git fetch mozilla`
[23:16:46] <cmr> (after a `git remote add mozilla https://github.com/mozilla/rust.git`)
[23:17:04] <mark_edward> thanks mate
[23:17:05] <cmr> erm, you'd fork your branch off of mozilla/master, sorry
[23:18:18] <strcat> the only time you want to rebase is if something changed in master conflicting with your pull
[23:18:54] <kimundi> meh, I use rebase all the time to update my local fork
[23:18:57] <strcat> it's nicer to do 'git pull --rebase rust master' than 'git pull rust master' and end up with a merge commit
[23:19:20] <cmr> (I wouldn't r+ something with a merge commit)
[23:19:26] <strcat> kimundi: sure, might as well hide all your mistakes and make yourself look smarter in hindsight ;p
[23:19:38] <strcat> each commit might as well compile + pass tests
[23:19:45] <strcat> otherwise no point in splitting them
[23:20:00] <strcat> the value is being able to split the work into standalone chunks + do a partial revert
[23:20:04] <mark_edward> why can't extra.rs compile? and it's not stuff with my changes. tons of errors in other files?
[23:20:10] <kimundi> you're implying that I figured out how to rewrite history yet ;)
[23:20:22] <kimundi> (which, to be fair, I have)
[23:20:34] *** aatch|gone is now known as aatch
[23:20:55] <mark_edward> my compiler was recompiled 5am this morning
[23:22:20] <mark_edward> do i need to continually update my compiler to work on rust?
[23:22:55] *** Joins: ghrust (ghrust@E7A4CCE2.6A2AE50.F3114085.IP)
[23:22:55] <ghrust> 01[13rust01] 15bors 04force-pushed 06auto from 14705ce42 to 14b055a10: 02http://git.io/N3iJvQ
[23:22:55] *** Parts: ghrust (ghrust@E7A4CCE2.6A2AE50.F3114085.IP) ()
[23:22:57] *** Joins: ghrust (ghrust@DE823A67.6A2AE50.F3114085.IP)
[23:22:57] <ghrust> 01[13rust01] 15bors pushed 2 new commits to 06auto: 02http://git.io/yopsOg
[23:22:57] <ghrust> 13rust/06auto 14f80d6dc 15Graydon Hoare: rustc: improve -Z trans-stats to report per-fn LLVM instruction counts and translation timing
[23:22:57] <ghrust> 13rust/06auto 14cc00003 15bors: auto merge of #7456 : graydon/rust/better-trans-stats, r=cmr...
[23:22:57] *** Parts: ghrust (ghrust@DE823A67.6A2AE50.F3114085.IP) ()
[23:23:08] <cmr> mark_edward: no, but just use the makefiles..
[23:23:36] <mark_edward> oh ok. but stcat said you could compile each crate separatelly..
[23:23:44] <cmr> you can, and it's usually a bad idea
[23:24:04] <cmr> messes up the staging
[23:24:39] <mark_edward> with 4 cores make -j8 is best right?
[23:24:52] <strcat> mark_edward: there's not really a 'best' but rust doesn't build in parallel
[23:25:25] <mark_edward> ok. well off to play some assassins creed for a bit then
[23:25:34] *** Joins: bytbox (s@moz-F994426C.wireless.umd.edu)
[23:25:37] <cmr> you don't need to wait for the whole build to finish
[23:25:54] *** Quits: bytewise (bytewise@moz-649C630D.unitymediagroup.de) (Quit: Leaving)
[23:26:01] <mark_edward> you're right, just for libextra in my case
[23:26:15] <cmr> and probably only stage0 libextra
[23:28:22] *** Quits: bytbox (s@moz-F994426C.wireless.umd.edu) (Ping timeout)
[23:29:14] <brendanc> don't know anything about these segmented stacks, but wonder if it would help to dynamically reduce the size of the initial stack allocation?
[23:29:22] *** Joins: Sorella (queen@78575561.924F2739.95C8B7C6.IP)
[23:29:46] <cmr> brendanc: that's the point, to let stacks start out small (a single page) so you can have a lot of them in a 32bit address space
[23:30:03] <brendanc> but what if you start them out large until you have address space pressure?
[23:30:10] <indutny> cmr: yeah
[23:30:10] *** Quits: jpochyla (jpochyla@moz-8D99AE5D.broadband18.iol.cz) (Ping timeout)
[23:30:13] <cmr> by then it's too late?
[23:30:17] <indutny> going to look at it tomorrow
[23:30:25] <indutny> its pretty stupid, actually
[23:30:36] <brendanc> you could crank down the initial size based on some ratio of available address space to number of current tasks or something
[23:31:20] <aatch> eh, we're probably going to turn off segmented stacks for x86_64
[23:31:31] <brendanc> might not be too late depending on when you start reducing size
[23:31:56] <brendanc> still keeping them on 32-bit though?
[23:32:32] *** Quits: SimonSapin (simon@moz-D0C2F181.zone2.bethere.co.uk) (Ping timeout)
[23:32:42] <aatch> brendanc, the only real advantage is that you don't have to worry about address-space exhaustion as much
[23:32:49] <brendanc> sure
[23:33:37] <brendanc> it seems like it's hard to guess ahead of time what the right stack size is, for either the compiler or the developer
[23:34:01] <brendanc> so maybe some runtime adaptation would help
[23:34:20] <cmr> maybe PGO could help with this, eventually
[23:34:34] <cmr> though only really useful for leaf functions
[23:34:39] <cmr> which is, like, none of them :p
[23:34:49] <brendanc> pgo?
[23:35:03] <bstrie> wouldn't we need to actually add PGO to llvm
[23:35:12] <graydon> LLVM has PGO already
[23:35:19] <graydon> brendanc: profile guided optimization
[23:35:22] <brendanc> oh right
[23:35:22] <bstrie> ah, I though it didn't
[23:35:45] <graydon> type of a function-with-no-environment is presently spelled 'extern fn'?
[23:35:48] <cmr> it has the infrastructure
[23:35:52] <aatch> graydon, correct
[23:35:55] <cmr> but no real optimizations
[23:35:58] <brendanc> could do that but it might be nice to have a runtime heuristic for when you don't have an explicit size hint
[23:36:01] <cmr> also what I said about using PGO was entirely nonsensical
[23:36:04] <graydon> aatch: can I lambda-produce them?
[23:36:14] <aatch> graydon, what do you mean?
[23:36:21] <cmr> you *always* know the stack needed by any given function
[23:36:28] <engla> graydon: no. I've tried to hack on that today but I haven't understood any of rustc yet
[23:36:31] <graydon> let x : extern fn() = || foo();
[23:36:35] <cmr> its the stuff it calls that can be messy
[23:36:35] <graydon> np
[23:36:37] <cmr> graydon: no
[23:36:45] <cmr> graydon: someone was asking for that today though
[23:36:47] <cmr> don't remember who
[23:36:50] <engla> I was :)
[23:36:52] <cmr> bblum said it'd be weird
[23:36:54] <cmr> oh
[23:36:56] <cmr> heh
[23:36:58] <engla> I and bblum dicussed it
[23:37:02] <aatch> can't you do let x : extern fn() = foo; ?
[23:37:08] <engla> bblum doesn't see a use case
[23:37:13] <brendanc> you could use a profile to see maximum stack size based on task entry point or something, and use that as a hint for the initial stack allocation?
[23:37:27] <brendanc> I'm assuming segmented stacks only cost when you run over the edge
[23:37:55] *** Joins: dbaupp (Thunderbir@moz-712A1135.lns20.syd6.internode.on.net)
[23:38:06] <aatch> brendanc, there is also a check at every function boundary, but yes, most of it is the allocation
[23:38:16] *** Joins: vk (vk@2AAA6DD0.B568D26C.93B001FA.IP)
[23:38:37] * cmr doesn't think segmented stacks are worth it
[23:38:42] <graydon> I don't think we have enough data on the costs, honestly. nobody's done a page-recycling pool for stack pages yet.
[23:38:55] <graydon> but I don't think it's productive to argue over. let the numbers guide it. we know we need a way to turn it off.
[23:39:00] <cmr> yeah
[23:39:04] <cmr> delicious data
[23:39:20] * graydon grumpy about something I thought was going to be easy, but isn't
[23:39:25] <brendanc> is setting the initial allocation size large roughly equivalent to to turning it off for perf?
[23:39:32] <graydon> yeah
[23:39:37] <aatch> graydon, I'm assuming that turning it off isn't as simple as just not telling LLVM to use it?
[23:39:45] <eevee> http://static.rust-lang.org/doc/0.7/std/str.html  it is still reeeeally hard to tell what i can actually do to a string based on these docs
[23:39:52] <cmr> also needs changes to the runtime no?
[23:39:55] <cmr> eevee: working on it!
[23:40:06] <dbaupp> eevee: ask away ;)
[23:40:10] <eevee> â™¥
[23:40:11] <graydon> aatch: depends what you mean by turning it off
[23:40:12] <brendanc> this is why I'm wondering if it might make sense to use large initial allocations when address space is plentiful
[23:40:21] <graydon> brendanc: yeah, probably.
[23:40:24] <eevee> well each_char went away; can i iterate strings directly now?
[23:40:25] <cmr> dbaupp: fresh batch of data!
[23:40:37] <cmr> eevee: http://static.rust-lang.org/doc/0.7/std/str.html#struct-strchariterator
[23:40:41] <graydon> if we're on x64 the easiest thing is to just make the initial size huge. we'd just need to be careful that we don't actually touch the pages.
[23:40:53] <cmr> eevee: .iter() returns one of those
[23:41:01] <graydon> a more involved check is also to turn off the codegen for checking size on entry to a function
[23:41:16] <aatch> graydon, doesn't LLVM generate that check?
[23:41:17] <cmr> dbaupp: at least one of the data is going to be wrong
[23:41:24] <eevee> aha
[23:41:28] <brendanc> you'd end up with more wasted address space but could probably tune it, and if a 32-bit program doesn't have a ton of tasks it wouldn't have to pay stack allocation cost
[23:41:33] <dbaupp> cmr: ?
[23:41:38] <cmr> dbaupp: rustc.rc was renamed to rustc.rs, and all my scripts assume rustc.rs
[23:41:50] <cmr> it will be easy to spot
[23:41:52] *** Quits: ChrisMorgan (chris@moz-6AC741CA.static.tpgi.com.au) (Ping timeout)
[23:41:53] *** Joins: bytbox (s@moz-F994426C.wireless.umd.edu)
[23:41:55] <cmr> it's the one that's only 0s long :p
[23:42:00] *** Joins: maxli (maxli@B5559308.9C54E60.2FA4EA88.IP)
[23:42:07] * cmr looks through and fixes
[23:42:12] <dbaupp> cmr: (can you delete it?)
[23:42:16] <cmr> yeah
[23:43:08] <korenchkin> I have a general question: Why do unsigned numeric types implement Neg?
[23:44:50] <cmr> korenchkin: it's a defined operation on fixed-width unsigned numerics... but it'd break the assumption that 0 < -x where x > 0...
[23:44:54] <cmr> bjz: ^
[23:45:03] <engla> they implement Sub so why not Neg
[23:45:19] <aatch> korenchkin, because Rust has defined overflow/underflow for unsigned integer
[23:45:23] <cmr> dbaupp: fixed
[23:45:46] <aatch> rusti: -1u
[23:45:47] -rusti- 18446744073709551615
[23:46:13] <aatch> ^^^ Always UINT_MAX
[23:46:44] <paupau> rusti: -1u32
[23:46:45] -rusti- 4294967295
[23:47:28] <engla> rusti: Bounded::max_value::<uint>()
[23:47:30] -rusti- 18446744073709551615
[23:47:33] <engla> it's a bit verbose
[23:47:41] <engla> and a function
[23:47:49] <cmr> there's a shorter version of that I thought
[23:47:50] *** Joins: ghrust (ghrust@24260B07.6A2AE50.F3114085.IP)
[23:47:50] <ghrust> 01[13rust01] 15alexcrichton 04force-pushed 06try from 14bce8a86 to 1484792ee: 02http://git.io/k471pw
[23:47:50] <ghrust> 13rust/06try 1480cd785 15Brian Anderson: Try to fix a periodic windows build failure due to broken rwildcard macro
[23:47:50] <ghrust> 13rust/06try 14e08513c 15Alex Crichton: Update LLVM
[23:47:50] <ghrust> 13rust/06try 14a9391d9 15Alex Crichton: Fix build issues once LLVM has been upgraded...
[23:47:52] *** Parts: ghrust (ghrust@24260B07.6A2AE50.F3114085.IP) ()
[23:47:57] <cmr> rusti: std::u8::max_value
[23:47:58] -rusti- 255
[23:48:01] <cmr> mmm
[23:48:06] <engla> ah of course
[23:48:06] <cmr> but, you need the type name for that
[23:48:12] <graydon> dammit dammit
[23:48:13] <cmr> and what's the point if you know the type? :p
[23:48:15] <graydon> this is not working at all
[23:48:25] <cmr> graydon: what are you trying to do?
[23:48:55] <aatch> acrichto, is that really the issue!
[23:48:56] *** Quits: vk (vk@2AAA6DD0.B568D26C.93B001FA.IP) (Ping timeout)
[23:49:08] <graydon> cmr: split apart the phases so everything-before-llvm runs in a subtask we can properly annihilate
[23:49:12] <acrichto> aatch: I thought, but I'm trying to find which fast_ffi it is
[23:49:23] <cmr> graydon: oh yeah that's not going to be trivial at all
[23:49:25] <eevee> amulet/canvas.rs:168:8: 168:9 error: expected function but found `&str`
[23:49:25] <eevee> amulet/canvas.rs:168         }
[23:49:31] <cmr> I looked into it already
[23:49:33] <eevee> i have made rust so angry
[23:49:40] <graydon> cmr: the sess is @ and has tons of @ inside it
[23:49:53] * graydon curses the sloppiness of using @ everywhere
[23:49:57] <cmr> yup
[23:50:09] <aatch> graydon, I know. I know.
[23:50:31] <aatch> The problem is that there is so much code that relies on it.
[23:50:55] <cmr> graydon: my original though was, pass back some sort of internal LLVM value that LLVM can be called on but that doesn't require any of the context
[23:50:56] * aatch would love a sendable AST
[23:51:15] <graydon> cmr: yeah. except everything needs sess.
[23:51:18] <strcat> graydon: what do you think about using 4/8/10MiB stacks by default and adding task::spawn_reserve(n) as an override?
[23:51:21] <cmr> right :(
[23:51:31] <graydon> strcat: fine by me.
[23:51:31] <strcat> so if you just want tiny I/O handlers, you can use task::spawn_reserve(0) and get the smallest
[23:51:35] *** Joins: ChrisMorgan (chris@moz-6AC741CA.static.tpgi.com.au)
[23:51:59] <strcat> and not caching segments at all, just paying the price for underestimating the size with allocations
[23:52:11] <graydon> why not cache segments?
[23:52:13] *** kimundi is now known as zz_kimundi
[23:52:18] <strcat> graydon: it slows everything down
[23:52:23] <strcat> fast_ffi is slower than no-fast_ffi atm
[23:52:49] <strcat> and afaik it'll always have to synchronize to some extent
[23:53:08] <graydon> huh?
[23:53:37] <graydon> caching is just holding the last segment you discarded in a TLS thing so when you next grow you can just reuse it
[23:53:48] <graydon> how can that possibly be slower than reallocating every time you want to grow?
[23:53:57] *** Quits: bytbox (s@moz-F994426C.wireless.umd.edu) (Ping timeout)
[23:54:01] <strcat> graydon: afaik that's not what it's doing right now
[23:54:06] <graydon> what is it doing?
[23:54:15] <strcat> I think it's caching the 2MiB stacks used for FFI calls globally
[23:54:45] <graydon> ok. that's a different issue.
[23:54:56] <strcat> graydon: well that's what I mean by 'caching'
[23:54:59] <graydon> ok
[23:55:13] <graydon> on x64 it probably makes no sense to be doing those things, I agree.
[23:55:15] <aatch> strcat, I think you're both right, but talking about different segments.
[23:55:29] <strcat> yeah I didn't realize there was another form of caching
[23:55:49] <graydon> it makes no sense to be doing any of these things on x64. we should just be spending address space.
[23:56:02] <eevee> oh snap there's an extra::terminfo now
[23:56:09] <graydon> but on x86 it makes sense. note: rust bootstrapped on x86 :)
[23:56:12] <cmr> eevee: I told you about it I thought
[23:56:15] <strcat> graydon: I think you only want to be using small stacks for I/O handlers anyway
[23:56:21] <eevee> i don't think so
[23:56:30] <strcat> you don't want to be paying for segmented stacks in the browser's rendering, etc. on x86
[23:56:31] <cmr> Well, I meant to, sorry! :p
[23:56:34] <aatch> graydon, but what if I run out of my 256TB of address space! /s
[23:56:58] <strcat> I don't think it's too much to ask to use a different API for tasks you intend to use as lightweight I/O handlers
[23:57:02] <cmr> eevee: thanks to Eridius it should implement everything!
[23:57:14] <cmr> (I was lazy and only did the easy stuff)
[23:57:35] <eevee> \o/  wow that saves me a lot of effort
[23:57:43] <strcat> graydon: we can still beat page size on x86_64, you might still want segmented stacks to deal with I/O or use as coroutines
[23:57:51] <strcat> we don't atm afaik, but we could
[23:57:53] <eevee> i can possibly ditch the c bindings altogether
[23:58:06] <aatch> eevee, that would be brilliant
[23:58:13] <cmr> eevee: C bindings to ncurses?
[23:58:21] <eevee> yeah
[23:58:39] <eevee> i started moving away from actually using the curses parts of ncurses, so i'm only using it for terminfo parsing now
[23:58:40] <friggle> and 32-bit address spaces still matter. See: ARM, and there are a *lot* of 512MiB VPS with 32-bit userspace out there
[23:58:41] <cmr> if you're using any highlevel routines from ncurses, you'll need to reimplement those. terminal handling isn't trivial, even with terminfo.
[23:58:43] <graydon> strcat: sure. I would like to focus on codegen performance before spending too much time rearchitecting the stacks, but I agree it's a thing that needs to be done
[23:58:47] <cmr> ah
[23:58:58] <eevee> yeah i am basically (slowly) reinventing all of ncurses
[23:58:59] <strcat> graydon: well it just looks really bad when we run 2-3x slower than C++
[23:59:02] <strcat> and RUST_MIN_STACK fixes it
[23:59:06] <graydon> yes I know
[23:59:20] <cmr> friggle: thing is, you wouldn't be using thousands of tasks on such a system
[23:59:22] <brendanc> large stacks on x64 would probably make everyone who is upset by segmented stacks forget about it :)
[23:59:33] <graydon> I said several times in this conversation already, if you want to do the simple thing, just set it to a big number on x64 and we'll be fine for a while
[23:59:44] <graydon> that's fine by me
[23:59:45] *** Joins: dwrensha (chatzilla@moz-DE44EA45.hsd1.pa.comcast.net)

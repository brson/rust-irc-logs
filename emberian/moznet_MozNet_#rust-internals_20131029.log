[00:00:11] <dbaupp> yes, as far as I can tell from the literature I've found, Ziggurat (with its tables) is the state-of-the-art for high-speed sampling from Normal and exponential distributions
[00:00:48] <dbaupp> acrichto: maybe they should be printed like 4.1_3_4_5 so they don't get hit by grep...
[00:01:01] <strcat> is it actually proven to work? ;p
[00:01:13] <dbaupp> Ziggurat? yes.
[00:03:50] *** Quits: dbaupp (Thunderbir@CE33C7D9.D5A1DCF.37681C44.IP) (Ping timeout)
[00:03:53] <acrichto> dbaupp: haha no I'm jk, that's so much effort
[00:05:04] <aatch> Aren't the tables generated by a python script?
[00:10:02] <aatch> What, if any, discussion on a documented linking model has there been so far?
[00:10:59] *** Joins: yghannam (yghannam@moz-C5BCCF4E.lightspeed.austtx.sbcglobal.net)
[00:14:39] <acrichto> brson: good news, I just wrote a small benchmark sending 0s over loopback from a client to a server, go averages ~580MB/s and we average ~750MB/s
[00:15:29] <acrichto> https://gist.github.com/anonymous/7207113
[00:16:51] <brson> acrichto: that is good news!
[00:17:16] <acrichto> I kinda wish I had a compiler with pre-homing-io optimizations on hand
[00:17:47] <strcat> acrichto: minor nitpick is that the go array should also be fixed-size
[00:17:53] <strcat> but I doubt it makes any difference
[00:17:58] <acrichto> oh yeah you can do that
[00:19:05] <acrichto> strcat: yeah doesn't change the numbers much
[00:20:05] <acrichto> oh wow we're even faster if we sent one byte at a time
[00:20:15] <acrichto> 120KB/s vs 200KB/s
[00:21:10] * strcat wants to see how boost::asio compares
[00:21:16] <strcat> I'll try in a bit
[00:21:32] <acrichto> not a great metric really, but promising numbers!
[00:22:11] <brson> acrichto: what's at the top of the profiles?
[00:23:27] <McPherrin> Where's the bottleneck, sending or receiving?
[00:23:55] <acrichto> brson: on the client side, 52% read, 4% kevent, 2.4% free, 1.8% change_task_context
[00:23:57] *** Quits: pnkfelix (pnkfelix@moz-43495417.fbx.proxad.net) (Quit: Leaving.)
[00:24:11] <acrichto> McPherrin: dunno, I just figured that a kernel can only handle so much
[00:24:30] <acrichto> brson: I think the next big optimization for I/O is to stop allocating callbacks all over the place
[00:25:11] <strcat> acrichto: I think it's probably a fraction of the potential speed for something that simple
[00:25:35] <McPherrin> acrichto: Yeah, at that speed you'll start getting more mysterious bottlenecks, though I suspect you should be able to get at least 1000MB/s through loopback
[00:26:08] <acrichto> hm looks like the client is all blocked in reads, so I'm gonna try the server next
[00:27:06] <acrichto> on the server side, 15% of the time is spent in the server task itself
[00:27:38] <acrichto> lots of Local::borrow for Task
[00:27:48] <acrichto> that's all homing I/O though
[00:30:31] <acrichto> brson: also re the things on uv crate, I actually semi-intended only allowing linkage with one event_loop_factory, although I guess it would be kinda nice to have two
[00:31:03] <acrichto> brson: also about the event_loop lang item, I originally used it for symbol generation (but ended up scrapping that), and I left it around for if/when we ever typecheck lang items, but no it's not currently used at all
[00:31:44] *** Joins: ghrust (ghrust@24260B07.6A2AE50.F3114085.IP)
[00:31:44] <ghrust> 01[13rust01] 15bors merged 06auto into 06master: 02http://git.io/Tdhg1A
[00:31:44] *** Parts: ghrust (ghrust@24260B07.6A2AE50.F3114085.IP) ()
[00:34:50] <brson> acrichto: can we remove the event_loop lang item? other than that it looks pretty awesome. r=me
[00:35:07] <acrichto> brson: sounds good to me
[00:35:19] <acrichto> although lang items are probably the wrong abstraction if we want to have multiple event loops
[00:35:32] <brson> possibly, but nbd. it's all implementation detail
[00:35:48] <acrichto> cool beans, thanks for reviewing!
[00:36:21] <brson> acrichto: is the snapshot code adjusted to include librustuv?
[00:36:31] <brson> and install.mk
[00:36:34] *** Joins: ghrust (ghrust@F6EE6DE3.6A2AE50.F3114085.IP)
[00:36:34] <ghrust> 01[13rust01] 15bors pushed 2 new commits to 06auto: 02http://git.io/wUfFKA
[00:36:34] <ghrust> 13rust/06auto 146c75b73 15Alex Crichton: Handle another possible error in a unix pipe test...
[00:36:34] <ghrust> 13rust/06auto 1409c7a1f 15bors: auto merge of #10133 : alexcrichton/rust/another-error, r=thestinger...
[00:36:34] *** Parts: ghrust (ghrust@F6EE6DE3.6A2AE50.F3114085.IP) ()
[00:36:36] *** Joins: ghrust (ghrust@C8693FCB.6A2AE50.F3114085.IP)
[00:36:36] <ghrust> 01[13rust01] 15bors pushed 0 new commits to 06auto: 02http://git.io/DDawjw
[00:36:36] *** Parts: ghrust (ghrust@C8693FCB.6A2AE50.F3114085.IP) ()
[00:36:42] <acrichto> brson: it should be, but I have not manually verified so I shal do so
[00:37:46] <acrichto> oh sneaky sneaky
[00:37:53] <acrichto> the snapshot building code is *not* in the makefile
[00:37:56] <acrichto> it's in snapshot.py!
[00:43:50] <brson> acrichto: how does the new crate map discovery code work without weak linkage?
[00:44:20] <acrichto> brson: it still uses weak linkage, it's just not flagged explicitly so as a "weak_linkage" attribute
[00:44:42] <acrichto> and it's just a silent contract between the compiler and windows about the name of the symbol
[00:45:29] <acrichto> man I *really* wish we had backtraces
[00:45:35] <acrichto> that's the worst part about conditions
[00:55:19] <acrichto> lldb only goes through like one frame :(
[00:55:22] <acrichto> this makes me sad
[01:03:03] *** lbergstrom is now known as lbergstrom|away
[01:10:14] <Sharp> Is there a reason that when we don't really have a span for something, we pass down the parent node's span?  Is it considered better than nothing?
[01:11:26] <aatch> Sharp, probably. What's the situation?
[01:12:18] <Sharp> I'm making ast::Field.ident a Spanned<Ident> to fix https://github.com/mozilla/rust/issues/8263.  Just curious since there seem to be quite a few places where we just hand down the wrong span.
[01:12:41] *** Joins: dbaupp (Thunderbir@CE33C7D9.D5A1DCF.37681C44.IP)
[01:12:49] <cmr> Sharp: please comment on an issue when you're working on it.
[01:13:00] <Sharp> Okay, sure.
[01:13:24] <cmr> reedlepee started working on this too
[01:13:25] *** Quits: geoffhill (geoffhill@moz-244CF33A.amazon.com) (Quit: geoffhill)
[01:13:37] <Sharp> Oh, sorryâ€¦ didn't realize that.
[01:13:49] <Sharp> I can stop.
[01:13:54] <cmr> no, it's fine
[01:13:59] <cmr> you had it first :)
[01:14:42] <Sharp> Okay, cool.  I'll comment in the future before I start working.
[01:32:37] <Luqman> nmatsakis: think of any other tricky edge cases for variadic ffi?
[01:34:58] <strcat> Luqman: did you up end forbidding the types C is unable to pass?
[01:35:31] <Luqman> yea, just made it output an error telling you to explicitly cast it
[01:36:54] <strcat> good :)
[01:41:21] *** Quits: yghannam (yghannam@moz-C5BCCF4E.lightspeed.austtx.sbcglobal.net) (Ping timeout)
[01:50:46] *** Quits: bjz (brendanzab@B398BE78.F804C29E.D35A31DF.IP) (Ping timeout)
[01:51:48] *** Joins: bjz (brendanzab@B398BE78.F804C29E.D35A31DF.IP)
[01:54:43] *** Quits: dbaupp (Thunderbir@CE33C7D9.D5A1DCF.37681C44.IP) (Ping timeout)
[01:59:53] *** Joins: jdm (jdm@moz-AC9499B2.cable.teksavvy.com)
[02:18:52] *** Quits: steveklabnik (steveklabn@moz-5EF6C37C.socal.res.rr.com) (Ping timeout)
[02:21:37] *** Quits: pcwalton (pcwalton@moz-DFAA4E15.p2p.sfo1.mozilla.com) (Quit: pcwalton)
[02:21:44] *** Quits: tikue_ (tikue_star@A64AE68.28259105.689607DE.IP) (Ping timeout)
[02:26:34] *** Joins: ghrust (ghrust@F6EE6DE3.6A2AE50.F3114085.IP)
[02:26:34] <ghrust> 01[13rust01] 15bors 04force-pushed 06auto from 1409c7a1f to 148852cb7: 02http://git.io/N3iJvQ
[02:26:34] *** Parts: ghrust (ghrust@F6EE6DE3.6A2AE50.F3114085.IP) ()
[02:26:37] *** Joins: ghrust (ghrust@DE823A67.6A2AE50.F3114085.IP)
[02:26:37] <ghrust> 01[13rust01] 15bors pushed 2 new commits to 06auto: 02http://git.io/9d5BOg
[02:26:37] <ghrust> 13rust/06auto 146c75b73 15Alex Crichton: Handle another possible error in a unix pipe test...
[02:26:37] <ghrust> 13rust/06auto 14c0222cd 15bors: auto merge of #10133 : alexcrichton/rust/another-error, r=thestinger...
[02:26:37] *** Parts: ghrust (ghrust@DE823A67.6A2AE50.F3114085.IP) ()
[02:28:39] *** Joins: tikue_ (tikue_star@A64AE68.28259105.689607DE.IP)
[02:29:45] *** Joins: nrc (nrc@7BE24E90.A5032A01.3CFC199D.IP)
[02:49:14] *** Joins: tjc (tjc@5DFB91FC.8C350B7C.7C164FC0.IP)
[02:49:14] *** ChanServ sets mode: +o tjc
[02:57:28] <strcat> acrichto: I dunno any way to make sync I/O fast :(
[02:59:45] <strcat> acrichto: http://ix.io/8Nd http://ix.io/8Ne it spends almost all the time in copy_user_enhanced_fast_string :s
[03:00:17] *** Joins: dbaupp (Thunderbir@CE33C7D9.D5A1DCF.37681C44.IP)
[03:02:08] *** Joins: kimundi_ (kimundi@moz-C21C140E.dip0.t-ipconnect.de)
[03:02:44] <strcat> aligning more than 64 doesn't do any good ;p
[03:02:52] *** Quits: kimundi (kimundi@moz-EA7ECD3D.dip0.t-ipconnect.de) (Ping timeout)
[03:02:52] *** kimundi_ is now known as kimundi
[03:03:52] <strcat> I guess you have to make the tcp window really huge
[03:05:31] *** Quits: dbaupp (Thunderbir@CE33C7D9.D5A1DCF.37681C44.IP) (Ping timeout)
[03:07:27] <strcat> maybe vmsplice/tee ;p
[03:07:44] <acrichto> if you don't align it on a 64-byte boundary is it that much slower?
[03:08:13] <strcat> not significantly but it does make copying faster on this CPU
[03:10:02] * strcat wants more than 5GiB/s :(
[03:10:24] <strcat> can you copy a buffer to the kernel with vmsplice and then write it a bunch of times? hm
[03:11:10] *** kimundi is now known as zz_kimundi
[03:12:25] <brson> strcat: what stack do signal handlers run on?
[03:12:54] <strcat> brson: the current stack, but you can set a per-thread sigaltstack
[03:13:06] <strcat> but it's much better to do it via signalfd rather than handlers
[03:13:33] <brson> what happens to the cpu context when a signal is handled?
[03:14:37] <strcat> brson: not sure. but there are hardly any functions you are allowed to run in a signal
[03:14:39] <strcat> signal handler*
[03:15:36] <strcat> brson: http://pubs.opengroup.org/onlinepubs/009695399/functions/xsh_chap02_04.html there's a list here (search async-signal-safe)
[03:16:23] <brson> strcat: I'm trying to imagine how to use a signal handler to implement green thread preemption
[03:17:06] <strcat> brson: signals only interrupt system calls
[03:17:22] <jld> acrichto: => 0x7ffff7625128 <_ZN2rt4task20rust_stack_exhausted10__rust_abiE+344>: ud2    
[03:17:47] <strcat> hrm
[03:17:50] *** zz_kimundi is now known as kimundi
[03:18:04] <acrichto> jld: very interesting...
[03:18:18] <jld> acrichto: Also, #3  0x00007ffff74ac300 in vec::OwnedVector$__extensions__::reserve::h81ca6982e7da6e0oaah::v0.9$x2dpre ()
[03:18:47] <acrichto> jld: is that it or does it keep going?
[03:18:48] <jld> And that has a frame size of 0x128, it looks like.
[03:18:58] <jld> acrichto: That's the caller of __morestack.
[03:19:13] <acrichto> jld: hmm and the backtrace is just all trans?
[03:19:14] <jld> So it's not the 2MB FFI thing.
[03:20:41] <brson> strcat: i did not know that ...
[03:20:53] <strcat> brson: well it will stop the other code from running but afaik you can't return there
[03:21:01] <brson> strcat: so that explains what happens to the cpu context then - it's saved
[03:21:29] <brson> strcat: so a signal will never interrupt code until it calls into the kernel?
[03:21:30] <strcat> ofc there are sigsetjmp/siglongjmp but I have no idea what happens if you do that
[03:21:40] <strcat> brson: it will interrupt the code
[03:21:40] <brson> that's surprising
[03:21:50] <strcat> but not in a way you can return the code afaik
[03:21:58] <acrichto> wait there's no way, surely setting a timer interrups you if you don't enter the kernel
[03:22:20] <jld> acrichto: 1157 out of 1191 stack frames have ::trans:: in the symbol name.
[03:22:31] * strcat is used to the signalfd way anyway
[03:22:50] <acrichto> strcat: brson: if you set alarm(1) and then while(1) {} you definitely receive a signal
[03:23:08] <acrichto> jld: and this is optimized?
[03:23:17] <strcat> acrichto: yeah, that's not what I'm saying
[03:23:53] <jld> acrichto: ...it looks unoptimized.
[03:24:13] <jld> But config.mk contains CFG_DISABLE_OPTIMIZE := 0
[03:24:37] <acrichto> jld: do you know what source program it's compiling?
[03:25:59] <jld> acrichto: It's doing the package_script_with_default_build test.
[03:26:30] *** Joins: ghrust (ghrust@79968228.6A2AE50.F3114085.IP)
[03:26:30] <ghrust> 01[13rust01] 15bors merged 06auto into 06master: 02http://git.io/9d5BOg
[03:26:30] *** Parts: ghrust (ghrust@79968228.6A2AE50.F3114085.IP) ()
[03:26:54] <acrichto> jld: I'm confused because that's a tiny program
[03:27:02] <acrichto> compared to rustc at least
[03:27:20] <acrichto> but then again it is not optimized
[03:27:30] <jld> pkg.rs:use rustpkg::api;
[03:27:30] <jld> pkg.rs:use rustpkg::version::NoVersion;
[03:27:56] <acrichto> brson: how would you feel about setting RUST_MIN_STACK to a large value on the nopt bots?
[03:28:28] <jld> Oh, wait a minute.  It's ifdef CFG_DISABLE_OPTIMIZE>
[03:29:11] <brson> acrichto: if the test suite requires an explicit change to the stack size to pass then I think we have to do it in the test suite, not on the bots
[03:29:30] <jld> It's not, um... `ifneq ($(or $(FOO),0),0)`.
[03:29:43] <jld> So this is in fact a no-opt build.
[03:29:49] <acrichto> brson: the tough part is that this is  rustpkg invoking rustc, but the task is through something inside workcache
[03:30:00] <jld> Which is what I get for monkeying with the makefile instead of re-../configure'ing.
[03:30:00] <acrichto> so it's not easy to set the size of the stack the task creates
[03:31:27] <brson> if we had to we could hack the makefiles to export a bigger RUST_MIN_STACK - so that the suite continues to pass on everybody's computers, not just the bots - but this sounds like a rustpkg bug
[03:31:30] *** Joins: ghrust (ghrust@1E8607E8.6A2AE50.F3114085.IP)
[03:31:30] <ghrust> 01[13rust01] 15bors pushed 0 new commits to 06auto: 02http://git.io/MxsgEQ
[03:31:30] *** Parts: ghrust (ghrust@1E8607E8.6A2AE50.F3114085.IP) ()
[03:31:35] *** Joins: ghrust (ghrust@24260B07.6A2AE50.F3114085.IP)
[03:31:35] <ghrust> 01[13rust01] 15bors pushed 3 new commits to 06auto: 02http://git.io/5lm6kw
[03:31:35] <ghrust> 13rust/06auto 145dd1583 15Alex Crichton: Make some more rt components public...
[03:31:35] <ghrust> 13rust/06auto 142ecd89b 15Alex Crichton: Move rust's uv implementation to its own crate...
[03:31:36] <ghrust> 13rust/06auto 144795821 15bors: auto merge of #10058 : alexcrichton/rust/uv-crate, r=brson...
[03:31:38] *** Parts: ghrust (ghrust@24260B07.6A2AE50.F3114085.IP) ()
[03:32:33] * brson gtg
[03:32:40] *** Quits: brson (brson@moz-BBE3ABD.mv.mozilla.com) (Quit: leaving)
[03:33:26] <strcat> acrichto: what I mean is that only system calls are actually *interrupted*, the state of the stack/registers is otherwise saved
[03:33:39] <acrichto> jld: brson's got a good point, the rustpkg test suite could just have a larger stack (defined in the makefiles)
[03:33:42] <strcat> and you can't call pthread anything from the handler
[03:33:47] <strcat> so it can't yield
[03:34:06] <strcat> I guess that's not how rust would "yield" though
[03:34:45] <acrichto> I'm not sure if the kernel would handle this well
[03:35:03] <strcat> and you can't use pthread TLS in a signal handler
[03:35:04] <acrichto> b/c in theory you'd context switch away and only "return from the handler" when you came back to the original threads
[03:35:12] <acrichto> but from the kernel's point of view that's signals in signals which may be bad
[03:35:20] <strcat> you can get a signal before you initialize TLS
[03:35:52] <strcat> you basically... can't do anything in a signal handler
[03:36:15] <acrichto> that's what I remember a few other people I know came to the conclusion of
[03:36:18] <strcat> stdio, pthread, tls, none of it is sound there (not just per the standard, it doesn't work with glibc)
[03:36:24] <acrichto> it's like a kernel interrupt handler, you can't really do a whole lot
[03:36:33] <acrichto> you can probably do a fair amount in a synchronous interrupt handler
[03:36:39] <acrichto> but an async signal handler is just messy
[03:36:50] <acrichto> nothing is reentrant (and nothing really can be)
[03:37:04] <strcat> signalfd lets you do whatever you want, but it's part of the event loop and the signals won't interrupt
[03:37:22] <jld> I continue to wonder why this takes more stack space for no-opt.
[03:37:24] <acrichto> doesn't help with context switching though :(
[03:37:36] <acrichto> jld: we generate a lot of bad code
[03:37:47] <acrichto> and if we tell llvm to optimize it it will happily consume huge amounts of stack
[03:37:52] <acrichto> to not optimize it *
[03:37:53] <strcat> well if we want pre-emptive scheduling, shouldn't we just use threads? ;p
[03:38:04] <strcat> acrichto: https://sourceware.org/glibc/wiki/TLSandSignals
[03:38:28] <acrichto> I don't think anything is async-signal safe
[03:38:39] <strcat> acrichto: well there's a list of stuff that is
[03:38:43] <acrichto> except perhaps raw syscalls themselves
[03:38:48] <strcat> stdio isn't, but some POSIX I/O stuff is
[03:39:01] <acrichto> stdio via printf probably isn't, stdio via write probably is
[03:39:05] <strcat> acrichto: man 7 signal has an async-safe list
[03:39:05] <jld> And I'd argue async signals are worse than a real interrupt handler, since you don't have the tools for dealing with them you'd have in a kernel.
[03:39:25] <acrichto> yeah there's no "disable_signals()" and "enable_signals()" 
[03:39:39] <acrichto> it'd probably be bad if those functions existed
[03:39:50] <strcat> acrichto: well... you can mask and unmask ;p
[03:39:54] <jld> There's sigprocmask.
[03:40:18] <acrichto> jld: oh wait nvmd
[03:40:19] <acrichto> good point...
[03:40:25] <jld> But there's a lot of library stuff to get to, say, instantiating an IRQ-locked heap for your subsystem that wants to (try to) allocate in interrupt context.
[03:40:48] <acrichto> or anything which wants to take a lock in an async handler
[03:41:06] <strcat> acrichto: none of the thread primitives work
[03:41:18] <jld> sem_post works.
[03:41:38] <strcat> ha
[03:41:45] <acrichto> jld: really?
[03:41:50] <jld> Specifically because there is no other way (outside of the self-pipe hack) to defer work to regular context.
[03:41:51] <acrichto> that's kinda surprising actually
[03:42:35] *** Quits: tikue_ (tikue_star@A64AE68.28259105.689607DE.IP) (Ping timeout)
[03:43:23] <strcat> hm
[03:43:50] <strcat> wait so.... even memcpy isn't signal safe
[03:43:53] *** Joins: tikue_ (tikue_star@A64AE68.28259105.689607DE.IP)
[03:44:01] <acrichto> what
[03:44:09] <acrichto> how can memcpy possibly have global state
[03:44:11] <strcat> direction flag
[03:44:22] <acrichto> there's no way that the kernel doesn't preserve that
[03:44:24] <strcat> acrichto: it has CPU state
[03:44:37] <kmc> it's interesting that the selfpipe trick is kind of like hardirq vs softirq
[03:44:38] <sfackler> the kernel's got to be responsible for saving that
[03:44:51] <strcat> hrm
[03:44:51] <acrichto> surely the kernel saves eflags on the way in and out of signals
[03:45:02] <jld> Okay, no.  Any OS that messes up the direction flag around async signals is broken.
[03:45:09] <kmc> acrichto: the CPU itself saves it
[03:45:13] <kmc> and IRET restores it
[03:45:41] <strcat> jld: but POSIX says it's okay :)
[03:45:44] <acrichto> although in theory the kernel can overwrite that with whatever it wants
[03:45:53] <jld> POSIX is *wrong*.  On the Internet.  (-:
[03:45:53] <cmr> strcat: ergo, POSIX is broken
[03:45:56] <cmr> but we knew that
[03:46:14] * aatch POSIXES_HARDER
[03:46:20] <jld> But yeah, there's a reason for GCC's -mcld flag.
[03:47:25] <kmc> why does POSIX say anything about the direction flag, which is x86-specific?
[03:48:23] <jld> kmc: It doesn't.  But the list of async signal safe interface doesn't mention memcpy.  And there's speculation about why.
[03:48:33] <jld> s/face/&s
[03:49:29] <strcat> kmc: POSIX doesn't even give you a portable way to close files though :)
[03:49:35] <strcat> unless you mask all signals
[03:50:07] <strcat> what it does on EINTR for close is implementation defined
[03:50:15] <strcat> linux always closes it, other OSes don't (you need to loop)
[03:50:25] * strcat shrugs
[03:51:31] *** Joins: ghrust (ghrust@24260B07.6A2AE50.F3114085.IP)
[03:51:31] <ghrust> 01[13rust01] 15bors 04force-pushed 06auto from 144795821 to 14c0222cd: 02http://git.io/N3iJvQ
[03:51:31] *** Parts: ghrust (ghrust@24260B07.6A2AE50.F3114085.IP) ()
[03:51:35] *** Joins: ghrust (ghrust@F6EE6DE3.6A2AE50.F3114085.IP)
[03:51:35] <ghrust> 01[13rust01] 15bors pushed 2 new commits to 06auto: 02http://git.io/SRPKjg
[03:51:35] <ghrust> 13rust/06auto 1417b87d2 15Huon Wilson: syntax: remove dead @mut Visitor impl (only used in tests)....
[03:51:35] <ghrust> 13rust/06auto 14dba6070 15bors: auto merge of #10117 : huonw/rust/dead-visits, r=sanxiyn...
[03:51:35] *** Parts: ghrust (ghrust@F6EE6DE3.6A2AE50.F3114085.IP) ()
[03:55:02] <strcat> acrichto: seems like it's bounded by memory bandwidth
[03:55:04] <acrichto> kmc: can you put "Closes #10065" in the commit message?
[03:55:08] <strcat> the sync I/O thing
[03:55:14] <acrichto> strcat: that's actually pretty cool
[03:55:14] <strcat> it's 3x as fast on my desktop
[03:55:55] <strcat> acrichto: it's basically measuring the performance of a memcpy into the kernel and a memcpy out of the kernel
[03:56:00] *** Quits: tjc (tjc@5DFB91FC.8C350B7C.7C164FC0.IP) (Ping timeout)
[03:56:13] <acrichto> the kernel might even optimize it and not copy into the kernel and out
[03:56:27] <strcat> it can't with read/write
[03:56:40] <strcat> that's what stuff like splice/sendfile/mmap are for
[03:57:03] <strcat> I think you could vmsplice a buffer into the kernel and then splice it into file descriptors ;p
[03:57:10] <strcat> er
[03:57:15] <strcat> s/splice/tee/
[03:57:25] <strcat> but it's very pointless
[03:57:31] *** Joins: tjc (tjc@5DFB91FC.8C350B7C.7C164FC0.IP)
[03:57:31] *** ChanServ sets mode: +o tjc
[03:57:40] <strcat> splice is awesome when you have a program piping output around
[03:57:54] <strcat> since you can do a copy-free transfer of data
[03:57:57] * jld recalls reading about how NetBSD UVM was going to all kinds of awesome stuff with page loaning.
[03:58:08] <strcat> rusti: 2
[03:58:09] -rusti- 2
[03:58:15] <strcat> that's via splice ;p, as if it matters
[03:58:28] <jld> ...except it didn't.  And it sort of depended on COW, which in the era of TLB shootdowns... yeah.
[03:58:41] <strcat> splices the stdout of the sandboxed process into the actual stdout
[03:59:05] <kmc> acrichto: sure
[03:59:55] <kmc> acrichto: done
[04:00:02] *** Quits: kimundi (kimundi@moz-C21C140E.dip0.t-ipconnect.de) (Ping timeout)
[04:00:19] <kmc> if you want to review instead of brson that's great :)
[04:00:39] <kmc> thanks :)
[04:01:01] <acrichto> np :)
[04:03:40] *** Joins: kimundi (kimundi@moz-1D7A8D6E.dip0.t-ipconnect.de)
[04:07:46] *** kimundi is now known as zz_kimundi
[04:14:45] *** zz_kimundi is now known as kimundi
[04:26:46] *** Quits: tikue_ (tikue_star@A64AE68.28259105.689607DE.IP) (Ping timeout)
[04:30:01] <cmr> acrichto: unwinding on stack overflow works right now, right?
[04:30:21] <acrichto> cmr: sadly no, just aborting
[04:30:25] <cmr> Ok.
[04:30:27] <acrichto> unwinding would leak the arguments
[04:30:56] <cmr> Do you believe that segmented stacks have any future at all?
[04:31:02] <cmr> Growable stacks can be useful
[04:31:16] <cmr> And if they allowed unwinding on overflow, that could also be useful... but I don't think they can.
[04:31:19] <strcat> Go is dropping them
[04:31:40] <strcat> but they are going to be using their precise gc metadata to migrate to a new stack
[04:31:45] <acrichto> Growable stacksd would be really really difficult
[04:31:55] <acrichto> you'd have to know if a borrowed pointer came from a box or the stack
[04:32:08] <strcat> cmr: I found pcwalton's argument compelling
[04:32:09] <cmr> Not like that, segmented stack growable via __morestack
[04:32:15] <cmr> strcat: yeah
[04:32:18] <strcat> if you really do want performance, you need true async code anyway
[04:32:33] <strcat> performance as in scalability
[04:32:47] <strcat> if you want good small scale perf you just want a thread for everything and blocking calls
[04:34:15] <cmr> "Among the Firefox 25 changes include the find/search bar no longer being shared between tabs" noooo I used the search bar for temporary storage of my clipboard
[04:34:46] <strcat> lol
[04:34:50] <strcat> cmr: get a clipboard manager
[04:35:03] <strcat> you can have a history of clippings ;p
[04:35:40] * strcat uses vimperator so.... I have no idea what the regular UI looks like
[04:35:41] <cmr> Further proof that any change in a program's UI impacts someone's workflow.
[04:42:52] *** Joins: tikue_ (tikue_star@A64AE68.28259105.689607DE.IP)
[04:51:20] *** Quits: tjc (tjc@5DFB91FC.8C350B7C.7C164FC0.IP) (Quit: Places to go, people to annoy)
[04:51:46] *** Joins: ghrust (ghrust@DE823A67.6A2AE50.F3114085.IP)
[04:51:46] <ghrust> 01[13rust01] 15bors merged 06auto into 06master: 02http://git.io/SRPKjg
[04:51:46] *** Parts: ghrust (ghrust@DE823A67.6A2AE50.F3114085.IP) ()
[04:56:27] *** Joins: ghrust (ghrust@DE823A67.6A2AE50.F3114085.IP)
[04:56:27] <ghrust> 01[13rust01] 15bors pushed 0 new commits to 06auto: 02http://git.io/fYZxCg
[04:56:27] *** Parts: ghrust (ghrust@DE823A67.6A2AE50.F3114085.IP) ()
[04:56:28] *** Joins: ghrust (ghrust@1E8607E8.6A2AE50.F3114085.IP)
[04:56:28] <ghrust> 01[13rust01] 15bors pushed 3 new commits to 06auto: 02http://git.io/0EKOAw
[04:56:28] <ghrust> 13rust/06auto 145dd1583 15Alex Crichton: Make some more rt components public...
[04:56:28] <ghrust> 13rust/06auto 142bdeb0e 15Alex Crichton: Move rust's uv implementation to its own crate...
[04:56:28] <ghrust> 13rust/06auto 141120dab 15bors: auto merge of #10058 : alexcrichton/rust/uv-crate, r=brson...
[04:56:30] *** Parts: ghrust (ghrust@1E8607E8.6A2AE50.F3114085.IP) ()
[04:56:58] <cmr> http://128.153.202.194:4000/blog/2013/10/28/more-on-stack-safety/
[04:57:04] <cmr> Does this seem reasonable?
[04:59:47] <aatch> cmr, yep. I think that solving both memory safety *and* stack safety in a native environment efficiently is just too much to ask of an industry language
[05:00:05] <acrichto> cmr: segmented stacks don't prevent us from unwinding
[05:00:17] <acrichto> it's just not currently implemented in a correct fashion
[05:00:22] <strcat> aatch: well you can solve stack *safety*
[05:00:30] <strcat> guard pages! ;p
[05:00:33] <cmr> acrichto: would every function call require a landing pad, then?
[05:00:55] <strcat> if we did unwinding on out of stack, every function could throw
[05:00:56] <acrichto> you *could* have stack maps for function arguments
[05:00:58] <strcat> it would require LLVM patches
[05:01:11] <acrichto> cmr: it's a difficult problem, but not outside the realm of possibility
[05:02:09] <cmr> s/They only/They currently only/
[05:02:18] <aatch> strcat, eh, I couldn't be bothered qualifiying any further. I mainly meant that I agree that segmented stacks cause too many issues to be worthwhile.
[05:02:27] <strcat> aatch: ah
[05:02:27] <acrichto> cmr: although I'm still a little confused on how you know how big to make the "guard zone"
[05:02:31] <strcat> aatch: yeah
[05:03:18] <strcat> they ruin memory locality and thrashing is deadly
[05:03:22] <strcat> Go never solved thrashing at all
[05:03:50] <cmr> acrichto: When compiling an executable crate, you know every function that can be called (excluding runtime loading of crates, but that's currently unsafe anyway) directly or indirectly, and LLVM knows what their stack sizes are.
[05:04:16] <acrichto> cmr: you know nothing about foreign libraries though?
[05:04:18] <strcat> it doesn't know it for all of them
[05:04:19] <cmr> acrichto: The guard zone only needstobe as large as thelargest possible stack frame since a function won't access memory outside of its stack frame
[05:04:24] <strcat> cmr: oh yeah
[05:04:27] <cmr> acrichto: it'd be in the metadata
[05:04:37] <acrichto> cmr: not in things like llvm
[05:04:47] <cmr> hm?
[05:04:54] <acrichto> ffi calls to llvm
[05:04:55] <acrichto> or libuv
[05:04:56] <acrichto> or libc
[05:04:56] <strcat> acrichto: doesn't matter
[05:04:58] <cmr> those are unsafe
[05:05:06] <cmr> FFI is always unsafe
[05:05:10] <Sharp> Is there any currently defined way of checking that a span for an error is precisely at a particular position?  In tests, that is.
[05:05:13] <acrichto> well so nowadays we assume 2MB is "good enough"
[05:05:26] <acrichto> we can't just throw it on the ground saying "whelp it's unsafe nothing to do here"
[05:05:32] <strcat> acrichto: we can state that safe FFI requires that the library you're calling into have stack frames below an amount you can specify in an attribute
[05:05:33] <strcat> it's fine
[05:06:05] <cmr> acrichto: currently we can call a function that will blow past the end of the stack, and will be none the wiser.
[05:06:33] *** Joins: eddyb (eddy@A93A03C9.9065A63B.FCAAE698.IP)
[05:06:35] *** Quits: eddyb (eddy@A93A03C9.9065A63B.FCAAE698.IP) (Quit: eddyb)
[05:06:37] <acrichto> it seems weird to say "of course all my stack frames are larger than the foreign stack frames"
[05:06:38] <cmr> FFI isn't safe right now because it doesn't check the current stack size. This doesn't change
[05:06:49] *** Joins: eddyb (eddy@A93A03C9.9065A63B.FCAAE698.IP)
[05:06:55] <acrichto> cmr: it's pretty safe as-is b/c consuming a 2MB stack is quite rare
[05:07:06] <acrichto> it's not bullet proof of course 
[05:07:16] <cmr> acrichto: right, the stack won't be any smaller under thisscheme, it's just have some no-access pages mapped after the end of it
[05:07:44] <acrichto> I think that it'll be enough
[05:07:54] <cmr> What'll be enough?
[05:08:05] <acrichto> having guard pages and praying that C ffi hits them as well
[05:08:09] <cmr> yes
[05:08:14] <acrichto> I want to bring this up at the meeting tomorrow
[05:08:17] <cmr> Ok
[05:08:22] <acrichto> we need to make a decision about segmented stacks once and for all
[05:08:34] <cmr> That's why I wrote this up tonight :)
[05:08:35] <strcat> acrichto: we can add an attribute
[05:08:39] <acrichto> I don't really want to have to set up a segv handler lol
[05:08:46] <strcat> #[min_guard(N)]
[05:08:50] <acrichto> strcat: yeah I like the idea of that
[05:08:54] <strcat> and require that you specify the upper bound for foreign libs
[05:09:00] * aatch for one welcomes our linear-stack overlords
[05:09:02] <strcat> for pure rust, it is unnecessary
[05:09:08] <acrichto> I think that our default mode will cover just about as many use cases as it does today
[05:09:11] <acrichto> which is not all, but most
[05:09:14] <cmr> I'd phone into the meeting but I have class while it's going on. I can probably be in IRC/the etherpad chat though
[05:17:09] *** Quits: strcat (strcat@moz-54F7FD49.cpe.net.cable.rogers.com) (Connection reset by peer)
[05:17:09] *** Quits: rusti (rusti@moz-54F7FD49.cpe.net.cable.rogers.com) (Connection reset by peer)
[05:17:10] *** Joins: strcat1 (strcat@moz-54F7FD49.cpe.net.cable.rogers.com)
[05:17:36] *** Joins: rusti (rusti@moz-54F7FD49.cpe.net.cable.rogers.com)
[05:20:02] <cmr> acrichto: can you put it on the agenda?
[05:20:18] <cmr> (http://cmr.github.io/blog/2013/10/28/more-on-stack-safety/)
[05:21:52] <acrichto> it's kinda all lumped under "segmented stacks", but it's on there :)
[05:22:27] <cmr> oh right, there's a single etherpad now
[05:22:31] * cmr keeps forgetting
[05:26:16] <cmr> aatch: you should send http://aatch.github.io/blog/2013/10/29/a-rustic-linker-model/ to the ML too!
[05:26:31] <cmr> Wouldn't want to miss it just because I didn't have anything to post to reddit until TWiR ;)
[05:29:42] <cmr> aatch: one case which might be uncommon but is nonetheless important is *writing* native libraries exposing a C ABI in Rust.
[05:30:21] <cmr> Where linking to them from non-Rust environments is the primary usecase, rather than a minor one.
[05:32:58] <jld> acrichto: So, the place in the makefile where the tests are run looks like...
[05:33:01] <jld> $$(call TEST_OK_FILE,$(1),$(2),$(3),$(4)): \
[05:33:03] <jld>                 $(3)/stage$(1)/test/$(4)test-$(2)$$(X_$(2))
[05:33:05] <jld> I think.
[05:34:20] <jld> So I'd need to do make macros to test if $(4) is rustpkg and add an env var?
[05:34:37] <jld> That seems sketchy.
[05:40:46] <acrichto> jld: "target: export VAR = value" is a thing
[05:41:51] *** Joins: ghrust (ghrust@24260B07.6A2AE50.F3114085.IP)
[05:41:51] <ghrust> 01[13rust01] 15bors 04force-pushed 06auto from 141120dab to 14dba6070: 02http://git.io/N3iJvQ
[05:41:52] *** Parts: ghrust (ghrust@24260B07.6A2AE50.F3114085.IP) ()
[05:41:52] *** Joins: ghrust (ghrust@79968228.6A2AE50.F3114085.IP)
[05:41:53] <ghrust> 01[13rust01] 15bors pushed 2 new commits to 06auto: 02http://git.io/RtQyqA
[05:41:53] <ghrust> 13rust/06auto 1452c6a4b 15Alex Crichton: Add rt::io traits to the prelude....
[05:41:53] <ghrust> 13rust/06auto 141f17423 15bors: auto merge of #10125 : alexcrichton/rust/rt-prelude, r=brson...
[05:41:53] *** Parts: ghrust (ghrust@79968228.6A2AE50.F3114085.IP) ()
[05:51:53] *** Joins: ghrust (ghrust@9C8B94D4.6A2AE50.F3114085.IP)
[05:51:53] <ghrust> 01[13rust01] 15bors 04force-pushed 06auto from 141f17423 to 14dba6070: 02http://git.io/N3iJvQ
[05:51:53] *** Parts: ghrust (ghrust@9C8B94D4.6A2AE50.F3114085.IP) ()
[05:51:59] *** Joins: ghrust (ghrust@F6EE6DE3.6A2AE50.F3114085.IP)
[05:51:59] <ghrust> 01[13rust01] 15bors pushed 2 new commits to 06auto: 02http://git.io/IcBhag
[05:51:59] <ghrust> 13rust/06auto 14541e5f8 15Daniel Micay: add support for the `cold` function attribute...
[05:51:59] <ghrust> 13rust/06auto 14671ab42 15bors: auto merge of #10127 : thestinger/rust/cold, r=pcwalton...
[05:52:00] *** Parts: ghrust (ghrust@F6EE6DE3.6A2AE50.F3114085.IP) ()
[05:54:59] *** strcat1 is now known as strcat
[06:16:45] <jld> ...awesome.  I touched the makefile so it rebuilds everything?
[06:17:27] <strcat> jld: tbh that seems better than the usual situation
[06:17:33] <strcat> where you change the Makefile and nothing happens ;p
[06:17:37] <cmr> heh
[06:19:49] <pcmattman> in the dependency graph, everything depends on Makefile, it is the source of all life and configuration
[06:20:29] *** Joins: lkuper (lkuper@moz-7A8BA7B.public.wayport.net)
[06:22:46] *** Quits: lkuper (lkuper@moz-7A8BA7B.public.wayport.net) (Ping timeout)
[06:24:58] *** Quits: jeffdb_ (jeff@moz-D13B6004.hsd1.ca.comcast.net) (Quit: jeffdb_)
[06:26:19] *** kimundi is now known as zz_kimundi
[06:26:21] <jld> I mean, I don't know if anything besides Vesta ever had dependency tracking for elements of the build configuration itself.
[06:29:53] <strcat> I have a solution to that Freeze issue... hm
[06:31:48] <strcat> ugh
[06:31:50] <strcat> naming
[06:32:06] <strcat> so I'm making a unit struct with a type parameter, where it bubbles up the kinds of the type parameter
[06:32:10] <strcat> what should it be called?
[06:32:15] *** Joins: jeffdb_ (jeff@moz-D13B6004.hsd1.ca.comcast.net)
[06:32:47] <Luqman> strcat: TPB :D
[06:33:04] <strcat> I'll called it FIXME_BUGNUMBER
[06:33:12] <strcat> where that's the bug for coming up with a name
[06:33:13] <strcat> ;p
[06:35:03] <strcat> I'll call it KindMirror...
[06:35:05] * strcat shrugs
[06:35:13] *** Quits: jeffdb_ (jeff@moz-D13B6004.hsd1.ca.comcast.net) (Quit: jeffdb_)
[06:48:30] <strcat> // A special zero-size type with the kinds of the type parameter.
[06:48:33] <strcat> #[lang="kind_reflect"]
[06:48:34] <strcat> pub struct KindReflect<T>;
[06:48:36] <strcat> Luqman: good enough ;p
[06:52:13] *** Joins: ghrust (ghrust@DE823A67.6A2AE50.F3114085.IP)
[06:52:13] <ghrust> 01[13rust01] 15bors merged 06auto into 06master: 02http://git.io/IcBhag
[06:52:13] *** Parts: ghrust (ghrust@DE823A67.6A2AE50.F3114085.IP) ()
[06:52:15] <eddyb> strcat: huh? what does it do...?
[06:52:24] <strcat> eddyb: it's the magical solution to all my problems
[06:52:28] <strcat> so
[06:52:38] <strcat> lets take Rc for an example
[06:52:40] <strcat> Rc<T>
[06:52:49] <strcat> it has a 'new' function with a Freeze bound on the value
[06:53:05] <strcat> Rc is never send (it doesn't use atomic refcounting) but atm *always* Freeze
[06:53:25] <strcat> even though it *should* allow you to construct it from Send types, but it can't because there's no way to make it conditionally Freeze
[06:53:47] <strcat> so this magical KindReflect thing can be shoved into Rc, and KindReflect will be non-Freeze if T is non-Freeze
[06:54:25] <strcat> the alternative is using Option<T> and setting it to None, which consumes space needlessly.
[06:55:44] <eddyb> aaaah, copying the automatically derived "kind"? I wasn't thinking of Freeze/Send
[06:56:30] <eddyb> and poisoning Rc?
[06:56:59] <strcat> eddyb: yeah it will make Rc non-Freeze
[06:57:06] *** Joins: ghrust (ghrust@F6EE6DE3.6A2AE50.F3114085.IP)
[06:57:06] <ghrust> 01[13rust01] 15bors pushed 0 new commits to 06auto: 02http://git.io/Ne4Bew
[06:57:06] *** Parts: ghrust (ghrust@F6EE6DE3.6A2AE50.F3114085.IP) ()
[06:57:18] <strcat> since KindReflect/KindMirror will be directly in Rc
[06:57:24] <strcat> I can't decide on the name
[06:57:35] * strcat is going with KindMirror
[06:57:41] <strcat> Mimic!
[06:57:42] <strcat> that's it.
[06:57:42] <eddyb> strcat: that's a neat hack, but it seems like a proper effect system would be better...
[06:57:57] <strcat> this isn't really anything to do with effects
[06:58:04] <strcat> it has to do with properties of types
[06:58:11] <strcat> related entirely to rust's borrowing/ownership system
[06:58:30] <eddyb> hmm, ok
[06:59:45] *** Joins: dbaupp (Thunderbir@moz-15934519.lns20.syd6.internode.on.net)
[07:00:22] * strcat is glad he came up with an easy peasy solution to this
[07:00:33] <strcat> this is the major piece needed to move ~[T] to the stdlib
[07:00:41] <eddyb> oh
[07:00:57] <strcat> or rather, minor, now that I know how trivial it is
[07:01:03] <McPherrin> How do I get the uv_loop_t for the scheduler?
[07:01:50] <dbaupp> McPherrin: there's a native_handle() fn in rt/uv/mod.rs
[07:02:09] <dbaupp> ... but it appears to be private, so maybe not.
[07:03:10] <McPherrin> I'll go look at what net.rs or something does
[07:03:52] *** Quits: dbaupp (Thunderbir@moz-15934519.lns20.syd6.internode.on.net) (Ping timeout)
[07:04:32] *** Quits: tikue_ (tikue_star@A64AE68.28259105.689607DE.IP) (Client exited)
[07:07:24] *** Joins: dbaupp (Thunderbir@moz-B3C9E9E8.lns20.syd6.internode.on.net)
[07:14:45] *** Quits: nrc (nrc@7BE24E90.A5032A01.3CFC199D.IP) (Ping timeout)
[07:16:46] *** Quits: Sharp (Sharp@1710C26.8381A41.8725677B.IP) (Quit: Sharp)
[07:20:03] *** Joins: Axord (xord@moz-1B228827.lsanca.dsl-w.verizon.net)
[07:22:10] *** Quits: pcmattman (pcmattman@moz-D9B7D938.net) (Ping timeout)
[07:22:26] *** Joins: pcmattman (pcmattman@moz-D9B7D938.net)
[07:22:36] *** Quits: StarLight (StarLight@moz-5848D83A.dynamic.avangarddsl.ru) (Ping timeout)
[07:22:47] *** Quits: jxs (joaoxsouls@moz-A7EE0DAF.compute-1.amazonaws.com) (Ping timeout)
[07:22:47] *** Quits: zz_kimundi (kimundi@moz-1D7A8D6E.dip0.t-ipconnect.de) (Ping timeout)
[07:22:52] *** Quits: benh (ben@moz-4A0366D2.org) (Ping timeout)
[07:22:58] *** Joins: benh (ben@moz-4A0366D2.org)
[07:23:04] *** Joins: StarLight (StarLight@moz-5848D83A.dynamic.avangarddsl.ru)
[07:23:15] *** Joins: zz_kimundi (kimundi@moz-1D7A8D6E.dip0.t-ipconnect.de)
[07:23:31] *** zz_kimundi is now known as kimundi
[07:26:22] *** Joins: jxs (joaoxsouls@moz-A7EE0DAF.compute-1.amazonaws.com)
[07:26:57] <eddyb> interesting http://lists.cs.uiuc.edu/pipermail/llvmdev/2013-October/066573.html
[07:28:30] <eddyb> didn't know JSCore was moving to LLVM
[07:29:23] <strcat> eddyb: it's crap ;p
[07:29:28] <strcat> safari uses nitro, chrome uses v8
[07:29:35] * strcat shrugs
[07:29:59] <McPherrin> iOS still has JSCore users I think?
[07:30:04] <strcat> I guess they just want something working - LLVM is terrible for dynamic languages
[07:30:06] <McPherrin> This was a point of contention at some point
[07:30:08] <strcat> McPherrin: yeah, lots.
[07:30:23] <strcat> you're not allowed to use nitro if you're not safari ;p
[07:30:31] <strcat> at least back then... probably still now
[07:30:48] <strcat> I don't quite understand *how* they would use LLVM without dynamic codegen
[07:30:58] <strcat> are they seriously going to output bytecode and use the interpreter?
[07:31:00] * strcat shrugs
[07:31:18] <strcat> (unless they are going to remove that restriction)
[07:33:11] <McPherrin> How do I get a raw pointer from a ~[u8]?
[07:33:20] <McPherrin> This has changed since I last wrote ffi code
[07:33:22] <eddyb> McPherrin: &v[0] as *T
[07:35:14] <strcat> eddyb: will fail if it's 0 length though
[07:36:14] <eddyb> strcat: you don't want to pass zero-length arrays to C code anyway, I wouldn't think :P
[07:36:31] <strcat> you can though if you pass a 0 length along with them
[07:36:38] <strcat> I think that's common
[07:36:50] <McPherrin> Well I'm not so I don't care :)
[07:37:08] <eddyb> if v.len() > 0 {&v[0] as *u8} else {0 as *u8}
[07:37:23] <McPherrin> anybody have IP / ICMP / UDP structs laying around?
[07:37:30] <eddyb> nullptr deref is safer than out of bounds, IMO
[07:37:38] *** Joins: ghrust (ghrust@24260B07.6A2AE50.F3114085.IP)
[07:37:39] <ghrust> 01[13rust01] 15bors 04force-pushed 06auto from 14dd47e95 to 14671ab42: 02http://git.io/N3iJvQ
[07:37:39] *** Parts: ghrust (ghrust@24260B07.6A2AE50.F3114085.IP) ()
[07:37:42] *** Joins: ghrust (ghrust@2EE61FCC.6A2AE50.F3114085.IP)
[07:37:42] <ghrust> 01[13rust01] 15bors pushed 3 new commits to 06auto: 02http://git.io/DVHv2Q
[07:37:42] <ghrust> 13rust/06auto 145dd1583 15Alex Crichton: Make some more rt components public...
[07:37:42] <ghrust> 13rust/06auto 14399d1a5 15Alex Crichton: Move rust's uv implementation to its own crate...
[07:37:43] <ghrust> 13rust/06auto 1493cb9e7 15bors: auto merge of #10058 : alexcrichton/rust/uv-crate, r=brson...
[07:37:45] *** Parts: ghrust (ghrust@2EE61FCC.6A2AE50.F3114085.IP) ()
[07:37:46] <eddyb> McPherrin: grep /usr/include :P
[07:38:08] <McPherrin> eddyb: what I want to avoid doing is converting them by hand :P
[07:38:20] <strcat> eddyb: if you don't pass a length you are going to index out of bounds already
[07:38:21] <eddyb> they aren't huge
[07:38:26] <Luqman> McPherrin: rust-bindgen maybe :P
[07:38:50] <McPherrin> I should go to sleep anyways
[07:38:55] <McPherrin> I'll just type 'em out tomorrow
[07:39:03] <eddyb> strcat: let's copy every vector passed to C just before the end of a page so OOB ends up hitting a red zone :P
[07:39:44] *** Quits: SiegeLord (sl@moz-CAF07B4C.hsd1.ma.comcast.net) (Quit: It's a joke, it's all a joke.)
[07:40:09] <eddyb> this would be easy to convert to Rust pedigree/repository/revisions/master/entry/src/modules/system/network-stack/Ipv4.h#L81
[07:40:24] <eddyb> (apart from the bit fields)
[07:41:23] <eddyb> McPherrin: and TCP http://pedigree-project.org/projects/pedigree/repository/revisions/master/entry/src/modules/system/network-stack/Tcp.h#L63
[07:42:14] <McPherrin> Oh I know, I can do it
[07:42:23] <McPherrin> I've got plenty of reference material
[07:42:31] <McPherrin> (I write network code for a living :P)
[07:44:34] <McPherrin> I can probably alllmost type an IP header out from memory
[07:45:59] <eddyb> then you're either sick of doing it or lazy :))
[07:47:33] <eddyb> hmm, when we get a dereference trait, numeric values in generic parameters and variadic generics, you'll be able to do this:
[07:48:30] <eddyb> *BitField<2, 3, 3>(0xF9) == (3, 7, 1)
[07:49:29] <McPherrin> eddyb: both :)
[07:49:38] <strcat> dbaupp: https://github.com/thestinger/rust/commit/207025864e5c31f4c770b0569e26b528232a66c1 :D
[07:50:21] <strcat> just needs 2 compile-fail tests
[07:55:33] <strcat> rusti: struct Foo<T>; Foo<int>
[07:55:34] -rusti- pastebinned 6 lines of output: http://sprunge.us/NUFY
[07:55:36] <strcat> rusti: struct Foo<T>; Foo::<int>
[07:55:36] -rusti- main::Foo<int>
[07:56:49] <strcat> meh it doesn't work :\
[07:57:32] <strcat> hm
[07:58:45] * strcat tries again
[08:00:44] *** Quits: kimundi (kimundi@moz-1D7A8D6E.dip0.t-ipconnect.de) (Ping timeout)
[08:00:47] *** Quits: benh (ben@moz-4A0366D2.org) (Ping timeout)
[08:00:58] *** Quits: km (quassel@moz-777F24DE.kevinmehall.com) (Ping timeout)
[08:01:22] *** Quits: lbergstrom|away (Adium@moz-5D8E4B14.lightspeed.cicril.sbcglobal.net) (Ping timeout)
[08:01:22] *** Quits: hansjorg (hansjorg@moz-41C5CE61.redpill-linpro.com) (Ping timeout)
[08:01:34] *** Joins: hansjorg (hansjorg@moz-41C5CE61.redpill-linpro.com)
[08:03:01] *** Joins: lbergstrom (Adium@15117742.DA651652.D56BC519.IP)
[08:03:33] *** Joins: benh (ben@moz-4A0366D2.org)
[08:04:46] *** Joins: zz_kimundi (kimundi@moz-1D7A8D6E.dip0.t-ipconnect.de)
[08:04:47] *** zz_kimundi is now known as kimundi
[08:11:02] *** Joins: Sharp (Sharp@moz-7B61DF4.dsl.static.sonic.net)
[08:21:45] *** Joins: ghrust (ghrust@24260B07.6A2AE50.F3114085.IP)
[08:21:45] <ghrust> 01[13rust01] 15bors 04force-pushed 06auto from 1493cb9e7 to 14671ab42: 02http://git.io/N3iJvQ
[08:21:45] *** Parts: ghrust (ghrust@24260B07.6A2AE50.F3114085.IP) ()
[08:21:46] *** Joins: ghrust (ghrust@24260B07.6A2AE50.F3114085.IP)
[08:21:46] <ghrust> 01[13rust01] 15bors pushed 2 new commits to 06auto: 02http://git.io/F2cWtQ
[08:21:46] <ghrust> 13rust/06auto 148f56de8 15Patrick Walton: librustc: Implement the `proc` type as sugar for `~once fn` and `proc`...
[08:21:46] <ghrust> 13rust/06auto 148a11003 15bors: auto merge of #10132 : pcwalton/rust/proc, r=brson...
[08:21:47] *** Parts: ghrust (ghrust@24260B07.6A2AE50.F3114085.IP) ()
[08:27:20] <dbaupp> strcat: that's *really* neat
[08:27:35] <strcat> and it works now ;p
[08:27:36] <dbaupp> strcat: (is it worth adding it to http://static.rust-lang.org/doc/master/rust.html#type-kinds too?)
[08:27:39] *** Joins: km (quassel@moz-777F24DE.kevinmehall.com)
[08:28:05] <strcat> maybe
[08:28:23] <strcat> it's for low-level unsafe code like no_send/no_freeze
[08:28:37] <strcat> to build a safety layer over it
[08:31:50] <dbaupp> yeah
[08:31:58] <dbaupp> ( <3 new vectors)
[08:32:07] <kimundi> acrichto: ping
[08:34:49] *** flaper87|afk is now known as flaper87
[08:52:49] *** Quits: Jesse (jruderman@moz-537BCF9.hsd1.ca.comcast.net) (Ping timeout)
[08:52:58] <eddyb> strcat: oh, you need this for Vec<T>, too?
[08:53:23] <strcat> eddyb: yes
[08:53:44] <eddyb> ~[T] lang item, maybe?
[08:54:20] <Luqman> anyone know if it's possible to manually add a snapshot compiler?
[08:54:35] <Luqman> that is for a new platform
[08:56:02] <eddyb> Luqman: without pushing it to the server, you mean?
[08:56:26] <Luqman> as in not through the usual push to snap-stage3 or whatever
[08:56:47] <Luqman> since for a new platform it wouldn't be able to build one since a previous snap shot compiler doesn't exist
[08:58:18] <Sharp> Worst case you could always do it in stages starting from the last commit that didn't require rustc.
[08:58:48] <strcat> eddyb: later
[08:59:19] <Luqman> Sharp: haha well, i've already manually built one, i just need to register it
[08:59:35] <Sharp> Ah, okay, gotcha :P
[09:01:50] *** Joins: ghrust (ghrust@1E8607E8.6A2AE50.F3114085.IP)
[09:01:51] <ghrust> 01[13rust01] 15bors 04force-pushed 06auto from 148a11003 to 14671ab42: 02http://git.io/N3iJvQ
[09:01:51] *** Parts: ghrust (ghrust@1E8607E8.6A2AE50.F3114085.IP) ()
[09:01:52] *** Joins: ghrust (ghrust@1E8607E8.6A2AE50.F3114085.IP)
[09:01:53] <ghrust> 01[13rust01] 15bors pushed 2 new commits to 06auto: 02http://git.io/Acc0ew
[09:01:53] <ghrust> 13rust/06auto 142290131 15Alex Crichton: Register new snapshots
[09:01:53] <ghrust> 13rust/06auto 147309158 15bors: auto merge of #10135 : alexcrichton/rust/snapshots, r=thestinger...
[09:01:53] *** Parts: ghrust (ghrust@1E8607E8.6A2AE50.F3114085.IP) ()
[09:50:12] <dbaupp> strcat: would it be ridiculous to mark -> ! functions as cold (re: https://github.com/mozilla/rust/issues/10137 )?
[09:50:39] <strcat> dbaupp: they might not really be cold (and it wouldn't replace expect)
[09:50:55] <strcat> dbaupp: consider a tail-recursive function calling itself, and it never returns
[09:52:33] *** Joins: pnkfelix (pnkfelix@87C1F78E.1DE10CA8.D8E68FF6.IP)
[09:55:12] *** Quits: bjz (brendanzab@B398BE78.F804C29E.D35A31DF.IP) (Connection reset by peer)
[09:55:16] *** Joins: bjz (brendanzab@B398BE78.F804C29E.D35A31DF.IP)
[09:58:37] *** Quits: strcat (strcat@moz-54F7FD49.cpe.net.cable.rogers.com) (Quit: WeeChat 0.4.2)
[09:59:43] *** Quits: bjz (brendanzab@B398BE78.F804C29E.D35A31DF.IP) (Connection reset by peer)
[09:59:44] *** Joins: bjz_ (brendanzab@B398BE78.F804C29E.D35A31DF.IP)
[10:05:31] *** Quits: pnkfelix (pnkfelix@87C1F78E.1DE10CA8.D8E68FF6.IP) (Connection reset by peer)
[10:06:34] *** Joins: ghrust (ghrust@DE823A67.6A2AE50.F3114085.IP)
[10:06:34] <ghrust> 01[13rust01] 15bors merged 06auto into 06master: 02http://git.io/Acc0ew
[10:06:34] *** Parts: ghrust (ghrust@DE823A67.6A2AE50.F3114085.IP) ()
[10:06:38] *** Joins: pnkfelix (pnkfelix@87C1F78E.1DE10CA8.D8E68FF6.IP)
[10:11:43] *** Joins: ghrust (ghrust@C8693FCB.6A2AE50.F3114085.IP)
[10:11:43] <ghrust> 01[13rust01] 15bors pushed 2 new commits to 06auto: 02http://git.io/a1tR2A
[10:11:43] <ghrust> 13rust/06auto 143797f2b 15Ziad Hatahet: Capitalize statics in f32 and f64 mods...
[10:11:43] <ghrust> 13rust/06auto 140cb0bce 15bors: auto merge of #10136 : hatahet/rust/master, r=alexcrichton...
[10:11:44] *** Parts: ghrust (ghrust@C8693FCB.6A2AE50.F3114085.IP) ()
[10:11:45] *** Joins: ghrust (ghrust@24260B07.6A2AE50.F3114085.IP)
[10:11:45] <ghrust> 01[13rust01] 15bors pushed 0 new commits to 06auto: 02http://git.io/zeiMlw
[10:11:45] *** Parts: ghrust (ghrust@24260B07.6A2AE50.F3114085.IP) ()
[10:15:41] *** Quits: Sharp (Sharp@moz-7B61DF4.dsl.static.sonic.net) (Quit: Sharp)
[11:30:50] *** flaper87 is now known as flaper87|afk
[11:46:24] *** Joins: ghrust (ghrust@C8693FCB.6A2AE50.F3114085.IP)
[11:46:24] <ghrust> 01[13rust01] 15bors 04force-pushed 06auto from 140cb0bce to 147309158: 02http://git.io/N3iJvQ
[11:46:24] *** Parts: ghrust (ghrust@C8693FCB.6A2AE50.F3114085.IP) ()
[11:46:26] *** Joins: ghrust (ghrust@C8693FCB.6A2AE50.F3114085.IP)
[11:46:26] <ghrust> 01[13rust01] 15bors pushed 2 new commits to 06auto: 02http://git.io/1ZU0zg
[11:46:26] <ghrust> 13rust/06auto 14e6fa2d0 15Brian Anderson: std: Move the SendDeferred trait to std::comm
[11:46:26] <ghrust> 13rust/06auto 1432b2fe0 15bors: auto merge of #10140 : brson/rust/comm, r=alexcrichton...
[11:46:27] *** Parts: ghrust (ghrust@C8693FCB.6A2AE50.F3114085.IP) ()
[12:38:03] <bstrie> why is asm! feature-gated now?
[12:39:52] *** Joins: ash_136 (ashvini@1A256789.F78407A4.E5F05D4F.IP)
[12:46:58] *** Quits: bjz_ (brendanzab@B398BE78.F804C29E.D35A31DF.IP) (Client exited)
[12:47:00] *** Joins: bjz (brendanzab@B398BE78.F804C29E.D35A31DF.IP)
[12:53:21] *** Quits: StarLight (StarLight@moz-5848D83A.dynamic.avangarddsl.ru) (Ping timeout)
[12:53:36] *** Joins: adridu59 (Mibbit@moz-6C393FDD.rev.numericable.fr)
[12:53:47] *** Parts: adridu59 (Mibbit@moz-6C393FDD.rev.numericable.fr) ()
[12:54:10] <pnkfelix> bstrie: because it may change in the future, and we want users to be prepared for that possibility?  It hasn't gotten much attention from the core developers, and AFAIK it has no tests.
[12:56:12] <dbaupp> it has a few now
[12:57:00] <dbaupp> (eddyb added support for the `=` and `+` constrains on output registers and added some tests as part of that, iirc.)
[12:57:24] <eddyb> just =, although + is easy (but you can emulate it without support anyway)
[12:57:30] <dbaupp> ah, ok.
[12:58:10] <eddyb> well, = is required now, it doesn't make sense otherwise. the tests are for the implied assignment of the outputs
[13:01:20] *** Joins: erickt (etryzelaar@BF60BF52.64BC77A3.7FC6A66E.IP)
[13:04:09] *** Joins: StarLight (StarLight@moz-5848D83A.dynamic.avangarddsl.ru)
[13:05:49] *** kimundi is now known as zz_kimundi
[13:26:33] *** zz_kimundi is now known as kimundi
[13:36:44] *** Joins: ghrust (ghrust@1E8607E8.6A2AE50.F3114085.IP)
[13:36:44] <ghrust> 01[13rust01] 15bors 04force-pushed 06auto from 1432b2fe0 to 147309158: 02http://git.io/N3iJvQ
[13:36:44] *** Parts: ghrust (ghrust@1E8607E8.6A2AE50.F3114085.IP) ()
[13:36:51] *** Joins: ghrust (ghrust@79968228.6A2AE50.F3114085.IP)
[13:36:51] <ghrust> 01[13rust01] 15bors pushed 2 new commits to 06auto: 02http://git.io/8BtD5Q
[13:36:51] <ghrust> 13rust/06auto 14f6b236b 15Keegan McAllister: rt::task: Make current_stack_segment public again...
[13:36:51] <ghrust> 13rust/06auto 14fc766ef 15bors: auto merge of #10141 : kmcallister/rust/current_stack_segment, r=alexcrichton...
[13:36:51] *** Parts: ghrust (ghrust@79968228.6A2AE50.F3114085.IP) ()
[13:40:22] <ash_136> Hello:)
[13:40:31] *** Quits: dbaupp (Thunderbir@moz-B3C9E9E8.lns20.syd6.internode.on.net) (Input/output error)
[13:50:18] *** flaper87|afk is now known as flaper87
[13:56:06] <SimonSapin> pnkfelix: I was finally able to build Rust on OS X after installing a full XCode
[13:56:15] <pnkfelix> SimonSapin: huzaah?
[13:56:45] *** Quits: benh (ben@moz-4A0366D2.org) (Ping timeout)
[13:56:47] <pnkfelix> SimonSapin: (as in: now we celebrate?  Or do we try to figure out how to get back to where we were before?)
[13:57:06] <SimonSapin> no I can start tracking this Servo test that hangs only on OSÂ X
[13:57:44] <zokier`> what's the status of pull request 9909?
[13:59:01] <ash_136> I need a little help in indentation of code
[13:59:27] <ash_136> where are the rules for indentation ?
[13:59:34] <ash_136> is it documented somewhere?
[13:59:36] <ash_136> for vim
[14:00:06] <ash_136> in src/etc/vim/indent I dint find anything mentioning how to do it
[14:00:08] *** Joins: benh (ben@moz-4A0366D2.org)
[14:09:20] *** Quits: pnkfelix (pnkfelix@87C1F78E.1DE10CA8.D8E68FF6.IP) (Quit: Leaving.)
[14:09:29] *** Joins: pnkfelix (pnkfelix@87C1F78E.1DE10CA8.D8E68FF6.IP)
[14:21:47] *** kimundi is now known as zz_kimundi
[14:23:47] *** zz_kimundi is now known as kimundi
[14:31:07] *** Quits: erickt (etryzelaar@BF60BF52.64BC77A3.7FC6A66E.IP) (Ping timeout)
[14:36:51] *** Joins: ghrust (ghrust@9C8B94D4.6A2AE50.F3114085.IP)
[14:36:51] <ghrust> 01[13rust01] 15bors merged 06auto into 06master: 02http://git.io/8BtD5Q
[14:36:52] *** Parts: ghrust (ghrust@9C8B94D4.6A2AE50.F3114085.IP) ()
[14:41:50] *** Joins: ghrust (ghrust@DE823A67.6A2AE50.F3114085.IP)
[14:41:50] <ghrust> 01[13rust01] 15bors pushed 0 new commits to 06auto: 02http://git.io/fTHV8A
[14:41:50] *** Parts: ghrust (ghrust@DE823A67.6A2AE50.F3114085.IP) ()
[14:41:54] *** Joins: ghrust (ghrust@24260B07.6A2AE50.F3114085.IP)
[14:41:54] <ghrust> 01[13rust01] 15bors pushed 3 new commits to 06auto: 02http://git.io/HzjMrw
[14:41:54] <ghrust> 13rust/06auto 1401ab854 15Joshua Yanovski: Field identifiers now include specific spans (Closes #8263).
[14:41:54] <ghrust> 13rust/06auto 14a716657 15Joshua Yanovski: #8263 part 2: Adding struct name.
[14:41:54] <ghrust> 13rust/06auto 14e6650c8 15bors: auto merge of #10142 : pythonesque/rust/issue-8263, r=catamorphism...
[14:41:56] *** Parts: ghrust (ghrust@24260B07.6A2AE50.F3114085.IP) ()
[14:42:12] *** Joins: Jesse (jruderman@moz-537BCF9.hsd1.ca.comcast.net)
[15:00:58] *** Quits: rusti (rusti@moz-54F7FD49.cpe.net.cable.rogers.com) (Ping timeout)
[15:02:12] *** Joins: erickt (etryzelaar@BF60BF52.64BC77A3.7FC6A66E.IP)
[15:09:33] *** Quits: jdm (jdm@moz-AC9499B2.cable.teksavvy.com) (Quit: Lost terminal)
[15:11:05] *** kimundi is now known as zz_kimundi
[15:12:05] *** Joins: Sharp (Sharp@moz-7B61DF4.dsl.static.sonic.net)
[15:16:14] *** Joins: rusti (rusti@moz-54F7FD49.cpe.net.cable.rogers.com)
[15:19:25] *** Quits: friggle (friggle@moz-A607EAFA.members.linode.com) (Ping timeout)
[15:19:26] *** Joins: friggle (friggle@moz-A607EAFA.members.linode.com)
[15:21:57] <nmatsakis> r? https://github.com/mozilla/rust/pull/10153
[15:22:00] <nmatsakis> er, pnkfelix ^
[15:22:23] <pnkfelix> nmatsakis: thx, will look
[15:22:45] *** Quits: erickt (etryzelaar@BF60BF52.64BC77A3.7FC6A66E.IP) (Ping timeout)
[15:23:44] *** Joins: erickt (etryzelaar@BF60BF52.64BC77A3.7FC6A66E.IP)
[15:46:51] *** Joins: ghrust (ghrust@9C8B94D4.6A2AE50.F3114085.IP)
[15:46:52] <ghrust> 01[13rust01] 15bors merged 06auto into 06master: 02http://git.io/HzjMrw
[15:46:52] *** Parts: ghrust (ghrust@9C8B94D4.6A2AE50.F3114085.IP) ()
[15:47:26] <cmr> nmatsakis: \o/
[15:48:21] *** Quits: erickt (etryzelaar@BF60BF52.64BC77A3.7FC6A66E.IP) (Ping timeout)
[15:50:27] <Sharp> Yay!
[15:52:02] *** Joins: ghrust (ghrust@DE823A67.6A2AE50.F3114085.IP)
[15:52:02] <ghrust> 01[13rust01] 15bors pushed 0 new commits to 06auto: 02http://git.io/YkYlVg
[15:52:02] *** Parts: ghrust (ghrust@DE823A67.6A2AE50.F3114085.IP) ()
[15:52:04] *** Joins: ghrust (ghrust@24260B07.6A2AE50.F3114085.IP)
[15:52:04] <ghrust> 01[13rust01] 15bors pushed 3 new commits to 06auto: 02http://git.io/xQcHIw
[15:52:04] <ghrust> 13rust/06auto 145dd1583 15Alex Crichton: Make some more rt components public...
[15:52:04] <ghrust> 13rust/06auto 14201cab8 15Alex Crichton: Move rust's uv implementation to its own crate...
[15:52:04] <ghrust> 13rust/06auto 14e7a7dd0 15bors: auto merge of #10058 : alexcrichton/rust/uv-crate, r=brson...
[15:52:06] *** Parts: ghrust (ghrust@24260B07.6A2AE50.F3114085.IP) ()
[15:55:05] *** Quits: doomlord_ (servitor@moz-3F3192E5.range86-184.btcentralplus.com) (Ping timeout)
[16:00:13] <nmatsakis> cmr: as usual always take longer than it ought to... but it'll be nice to be free of 'self
[16:07:41] <eddyb> nmatsakis: I can't even load the diff... what's the simplest example that this fixes, if you don't mind?
[16:07:58] *** Joins: jdm (jdm@FCCEA34F.7672369.D8E68FF6.IP)
[16:08:04] <nmatsakis> eddyb: "struct Foo<'a> { x: &'a uint }"
[16:08:43] <eddyb> wasn't this possible before?
[16:09:10] <eddyb> I remember doing something like that (and then removing it when I didn't need references anymore)
[16:09:14] *** Joins: jdm_ (jdm@13F2CEC5.7672369.D8E68FF6.IP)
[16:09:36] <cmr> eddyb: no
[16:09:41] *** Quits: jdm (jdm@FCCEA34F.7672369.D8E68FF6.IP) (Ping timeout)
[16:09:50] <nmatsakis> eddyb: before you had to write "struct Foo<'self> { x: &'self uint }"
[16:10:02] <eddyb> nmatsakis: or did it work only with 'self, and you couldn't have more than one? (I guess that's what the description means)
[16:10:02] <nmatsakis> eddyb: that is, lifetime parameters on types *must* be called 'self and there must be only 1
[16:10:17] <eddyb> thanks, I figured it out while asking :P
[16:10:54] * eddyb tries to think of immediate uses for this
[16:12:00] <Sharp> Being able to specify Struct variants with references with different lifetimes?
[16:12:29] <Sharp> (Borrowed references, that is).
[16:13:05] <eddyb> Sharp: do you mean enum variants?
[16:13:12] <eddyb> (those are the only variants I know of)
[16:13:32] <Sharp> Iâ€¦ maybe.  I think yesterday I called them enums and someone corrected me to struct variants :P
[16:13:58] <cmr> Enums can have struct variants
[16:14:11] <eddyb> Sharp: well, a variant can either be a tuple or a struct, just like struct types themselves
[16:14:21] <cmr> enum Foo { A, B(int, uint), C { f: int, g: uint } }
[16:14:35] <Sharp> I think I did mean struct variants then, in this case.
[16:14:45] <eddyb> but borrowed references don't require named fields
[16:15:03] <eddyb> struct Foo<'a>(&'a uint);
[16:15:06] <Sharp> Don't they?  I think when I tried to define just &str it wouldn't let me unless I specified a lifetime.
[16:15:23] <Sharp> Oh, named fields, not named lifetimes.
[16:15:36] <Sharp> Right, fair enough.  Just variants then :)
[16:16:34] *** jdm_ is now known as jdm
[16:16:41] <Sharp> Either way, I'm pretty sure the line you just wrote didn't work until this change.
[16:17:00] <nmatsakis> eddyb: there are definitely cases where you want multiple lifetime parameters. For example, you might have various arens you can allocate from -- e.g., in rustc, an arena that persists for the entire compilation, and a distinct one for "per-pass" data
[16:17:29] <nmatsakis> but if nothing else I think that just avoiding the name 'self should help people understand lifetimes better
[16:17:35] <nmatsakis> since I think 'self implies that something very special is going on
[16:19:57] <eddyb> nmatsakis: aaah, passing 'static?
[16:20:01] <eddyb> I didn't think of that one
[16:20:29] <nmatsakis> eddyb: I'm not sure what you mena
[16:21:55] <eddyb> struct Foobar<'a, 'b>(&'a str, &'b str); Foobar(&'static "foo", ~"bar")
[16:22:33] <eddyb> nmatsakis: the arena that persists for the entire.. wait, you said compilation, maybe I didn't understand :/
[16:23:48] <eddyb> now that we can have more than one... ..'L anyone? although a tuple of lifetimes is beyond crazy
[16:24:41] <nmatsakis> eddyb: your example is plausible, though can also wite struct foobar<'b>(&'static str, &'b str)
[16:25:11] <eddyb> nmatsakis: but you wouldn't know that the first element is always 'static
[16:25:28] <eddyb> heh, not sure if this makes a lot of sense, but it may work: <..&'a T: Send>
[16:25:47] <cmr> eddyb: you don't have lifetimes in type variables
[16:27:08] <eddyb> cmr: I was considering pattern matching as a way to capture lifetimes, but it doesn't really make sense
[16:27:22] * eddyb can easily get confused
[16:27:58] <eddyb> though <..T> would work with <&'static str>, you just wouldn't be able to extract 'static from there
[16:28:01] *** Joins: SiegeLord (sl@moz-CAF07B4C.hsd1.ma.comcast.net)
[16:29:02] <eddyb> (sadly, lifetimes aren't compatible with a lot of things in the type system)
[16:29:41] *** Quits: jdm (jdm@13F2CEC5.7672369.D8E68FF6.IP) (Quit: Lost terminal)
[16:30:07] *** Joins: jdm (jdm@13F2CEC5.7672369.D8E68FF6.IP)
[16:30:33] <eddyb> a type CopyLifetime<T, U> = &'a U for T = &'a ...; would be cool :D
[16:33:17] <eddyb> can intrinsics be types?
[16:36:48] *** Joins: ghrust (ghrust@9C8B94D4.6A2AE50.F3114085.IP)
[16:36:48] <ghrust> 01[13rust01] 15bors 04force-pushed 06auto from 14e7a7dd0 to 14e6650c8: 02http://git.io/N3iJvQ
[16:36:48] *** Parts: ghrust (ghrust@9C8B94D4.6A2AE50.F3114085.IP) ()
[16:36:49] *** Joins: ghrust (ghrust@F6EE6DE3.6A2AE50.F3114085.IP)
[16:36:50] <ghrust> 01[13rust01] 15bors pushed 3 new commits to 06auto: 02http://git.io/weWcsw
[16:36:50] <ghrust> 13rust/06auto 145dd1583 15Alex Crichton: Make some more rt components public...
[16:36:50] <ghrust> 13rust/06auto 14201cab8 15Alex Crichton: Move rust's uv implementation to its own crate...
[16:36:50] <ghrust> 13rust/06auto 1452f42f1 15bors: auto merge of #10058 : alexcrichton/rust/uv-crate, r=brson...
[16:36:52] *** Parts: ghrust (ghrust@F6EE6DE3.6A2AE50.F3114085.IP) ()
[16:44:35] *** Joins: nrc (nrc@7BE24E90.A5032A01.3CFC199D.IP)
[16:54:55] <pnkfelix> nmatsakis: ping
[16:58:09] <pnkfelix> nmatsakis: nm, I'll try to catch you post-mtg
[16:58:14] <nmatsakis> pnkfelix: ok
[16:58:23] *** Quits: pnkfelix (pnkfelix@87C1F78E.1DE10CA8.D8E68FF6.IP) (Quit: Leaving.)
[16:59:22] *** Quits: Kxepal (Miranda@moz-54BF1851.pppoe.mtu-net.ru) (Ping timeout)
[17:01:26] *** Joins: pnkfelix (pnkfelix@87C1F78E.1DE10CA8.D8E68FF6.IP)
[17:02:44] *** Joins: Kxepal (Miranda@moz-A79FEB26.pppoe.mtu-net.ru)
[17:15:51] *** Joins: brson (brson@moz-BBE3ABD.mv.mozilla.com)
[17:15:51] *** ChanServ sets mode: +qo brson brson
[17:16:56] *** zz_kimundi is now known as kimundi
[17:20:04] <kimundi> brson, acrichto: ping
[17:22:27] *** flaper87 is now known as flaper87|afk
[17:25:17] *** Joins: pcwalton (pcwalton@moz-7B0110AD.mv.mozilla.com)
[17:25:17] *** ChanServ sets mode: +ao pcwalton pcwalton
[17:47:19] *** Joins: erickt (etryzelaar@BF60BF52.64BC77A3.7FC6A66E.IP)
[17:47:24] *** Joins: ghrust (ghrust@DE823A67.6A2AE50.F3114085.IP)
[17:47:24] <ghrust> 01[13rust01] 15bors merged 06auto into 06master: 02http://git.io/weWcsw
[17:47:24] *** Parts: ghrust (ghrust@DE823A67.6A2AE50.F3114085.IP) ()
[17:52:26] *** Joins: ghrust (ghrust@F6EE6DE3.6A2AE50.F3114085.IP)
[17:52:26] <ghrust> 01[13rust01] 15bors pushed 0 new commits to 06auto: 02http://git.io/92F6Nw
[17:52:26] *** Parts: ghrust (ghrust@F6EE6DE3.6A2AE50.F3114085.IP) ()
[17:52:31] *** Joins: ghrust (ghrust@79968228.6A2AE50.F3114085.IP)
[17:52:31] <ghrust> 01[13rust01] 15bors pushed 2 new commits to 06auto: 02http://git.io/oFcy9A
[17:52:31] <ghrust> 13rust/06auto 147e77bf1 15Patrick Walton: librustc: Implement the `proc` type as sugar for `~once fn` and `proc`...
[17:52:31] <ghrust> 13rust/06auto 14fed48cc 15bors: auto merge of #10132 : pcwalton/rust/proc, r=pcwalton...
[17:52:31] *** Parts: ghrust (ghrust@79968228.6A2AE50.F3114085.IP) ()
[17:55:42] *** Joins: tjc (tjc@moz-BBE3ABD.mv.mozilla.com)
[17:55:42] *** ChanServ sets mode: +o tjc
[18:01:12] *** Joins: steveklabnik (steveklabn@moz-5EF6C37C.socal.res.rr.com)
[18:02:28] *** Quits: tjc (tjc@moz-BBE3ABD.mv.mozilla.com) (Quit: zzzzzzzzzz)
[18:07:18] *** Joins: tikue_ (tikue_star@9746E5A.EB08480C.689607DE.IP)
[18:07:22] *** Quits: tikue_ (tikue_star@9746E5A.EB08480C.689607DE.IP) (Client exited)
[18:08:19] *** Joins: tikue_ (tikue_star@9746E5A.EB08480C.689607DE.IP)
[18:09:52] *** Joins: tjc (tjc@moz-BBE3ABD.mv.mozilla.com)
[18:09:52] *** ChanServ sets mode: +o tjc
[18:16:56] *** Joins: geoffhill (geoffhill@moz-244CF33A.amazon.com)
[18:18:58] *** Quits: pnkfelix (pnkfelix@87C1F78E.1DE10CA8.D8E68FF6.IP) (Quit: Leaving.)
[18:19:07] *** Joins: pnkfelix (pnkfelix@87C1F78E.1DE10CA8.D8E68FF6.IP)
[18:19:43] *** Quits: pnkfelix (pnkfelix@87C1F78E.1DE10CA8.D8E68FF6.IP) (Max SendQ exceeded)
[18:21:29] *** Quits: erickt (etryzelaar@BF60BF52.64BC77A3.7FC6A66E.IP) (Ping timeout)
[18:24:40] *** Joins: erickt (etryzelaar@93E94B80.D1E9439C.98A37E8C.IP)
[18:28:50] *** Quits: erickt (etryzelaar@93E94B80.D1E9439C.98A37E8C.IP) (Ping timeout)
[18:43:11] *** Joins: erickt (etryzelaar@BF60BF52.64BC77A3.7FC6A66E.IP)
[18:48:30] <brson> kimundi: pong
[18:51:48] *** Joins: ghrust (ghrust@1E8607E8.6A2AE50.F3114085.IP)
[18:51:48] <ghrust> 01[13rust01] 15alexcrichton merged 06auto into 06snap-stage3: 02http://git.io/AUaLRg
[18:51:48] *** Parts: ghrust (ghrust@1E8607E8.6A2AE50.F3114085.IP) ()
[18:53:37] *** Quits: brson (brson@moz-BBE3ABD.mv.mozilla.com) (Ping timeout)
[18:53:49] <kimundi> brson: I though over it again, and now I'm also starting to think that fail! just accepting any T: Send is the least confusing solution, so I'm implementing that now. It gets a bit complicated behind the scenes though because right now there is no general way for a ~Any to call through to an to_str() method on the wrapped object, so I still need to special case &'static str and ~str by unwrapping them out of the ~Any again just s
[18:53:49] <kimundi> o that begin_unwind can print the right error message
[18:55:12] <kimundi> And I can also not properly contain that that special casing because depending no how and where I do it, ~Any fails to work because of the instability of using the type descriptor for type equality
[18:55:58] <kimundi> (Urg, I should now write so much text at once while being sleep deprived)
[18:56:49] <kimundi> ... And now I noticed brson quit the channel :|
[18:57:01] *** Joins: brson (brson@moz-BBE3ABD.mv.mozilla.com)
[18:57:01] *** ChanServ sets mode: +qo brson brson
[18:57:31] *** Joins: ghrust (ghrust@24260B07.6A2AE50.F3114085.IP)
[18:57:31] <ghrust> 01[13rust01] 15bors merged 06auto into 06master: 02http://git.io/oFcy9A
[18:57:31] *** Parts: ghrust (ghrust@24260B07.6A2AE50.F3114085.IP) ()
[18:57:37] <kimundi> brson: haha, you just missed my reply ;)
[18:58:14] <kimundi> Or rather, I missed your leaving the channel and kept talking to empty air :P
[19:02:59] *** Joins: ghrust (ghrust@9C8B94D4.6A2AE50.F3114085.IP)
[19:02:59] <ghrust> 01[13rust01] 15bors pushed 0 new commits to 06auto: 02http://git.io/pIzJUw
[19:02:59] *** Parts: ghrust (ghrust@9C8B94D4.6A2AE50.F3114085.IP) ()
[19:03:01] *** Joins: ghrust (ghrust@C8693FCB.6A2AE50.F3114085.IP)
[19:03:01] <ghrust> 01[13rust01] 15bors pushed 2 new commits to 06auto: 02http://git.io/WXdHPg
[19:03:01] <ghrust> 13rust/06auto 143797f2b 15Ziad Hatahet: Capitalize statics in f32 and f64 mods...
[19:03:01] <ghrust> 13rust/06auto 1467d7be0 15bors: auto merge of #10136 : hatahet/rust/master, r=alexcrichton...
[19:03:02] *** Parts: ghrust (ghrust@C8693FCB.6A2AE50.F3114085.IP) ()
[19:03:40] <acrichto> pcwalton: I'm making a snapshot with proc/uv right now btw
[19:04:47] *** Quits: ash_136 (ashvini@1A256789.F78407A4.E5F05D4F.IP) (Quit: Leaving)
[19:05:09] *** Quits: steveklabnik (steveklabn@moz-5EF6C37C.socal.res.rr.com) (Ping timeout)
[19:05:12] <olsonjeffery> acrichto: \o/
[19:05:19] <olsonjeffery> pretty awesome, re: breaking out libuv bindings
[19:05:45] <acrichto> now we just need an actual alternate event loop implementation to test with :)
[19:08:27] <brson> kimundi: ok, so wee need type equality to work?
[19:08:57] *** Quits: pcwalton (pcwalton@moz-7B0110AD.mv.mozilla.com) (Quit: pcwalton)
[19:10:12] <kimundi> brson: Right, at least to make the implementation I have right now leaner, and also I think it might just be broken cross crate (one attempt from me resulted in almost all of run-fail failing because ~Anys of &str and ~str didn't get recognized as such, resulting in their failure messages getting printed as only "~Any")
[19:11:36] <kimundi> I'm still testing and reducing the accumulated code cruft from the various attempts, but a working version can be seen here right now: https://github.com/mozilla/rust/pull/10120
[19:13:43] <kimundi> The horrible part is that fail!("foo") ... try {...} currently goes &'static str -> ~&'static str as ~Any -> &'static str -> ~&'static str as ~Any  because of those weird issues :)
[19:14:03] *** Joins: pcwalton (pcwalton@moz-7B0110AD.mv.mozilla.com)
[19:14:03] *** ChanServ sets mode: +ao pcwalton pcwalton
[19:14:08] <olsonjeffery> acrichto: yeah i wasthinking about that
[19:14:16] <cmr> https://github.com/mozilla/rust/pull/9613#issuecomment-27321003 \o/
[19:14:16] <olsonjeffery> maybe NSRunLoop/CFRunLoop in OSX
[19:14:36] <acrichto> olsonjeffery: yeah there's also like the sdl or gl things (which I know very little about)
[19:14:46] <acrichto> although the IoFactory trait is constantly changing
[19:14:46] <cmr> acrichto: also gtk and qt
[19:14:55] <olsonjeffery> yeah, glib is an obvious one
[19:15:06] <olsonjeffery> i don't want to write gtk+ programs though, heh
[19:15:17] <olsonjeffery> also, imagine wrapping glib in rust. heh. good times.
[19:15:32] <olsonjeffery> acrichto: we can't even talk about IoFactory, tbh
[19:15:42] <olsonjeffery> brson hinted at this with the BasicEventLoop stuff
[19:15:53] <acrichto> olsonjeffery: well we have a basic event loop right now based on pthreads
[19:15:53] <olsonjeffery> im really curious how much "libuv-ism" has leaked into that API
[19:16:03] <acrichto> the pausible idle callback is annoying
[19:16:07] <acrichto> otherwise it seems totally legit
[19:16:08] <olsonjeffery> and the std::rt::io::native stuff totally exists outside of it, right?
[19:16:14] <acrichto> yeah
[19:16:20] <olsonjeffery> well there ya go
[19:16:20] <acrichto> I want to make a NativeIoFactory 
[19:16:30] <acrichto> we can implement most operations other than networking and signals
[19:16:33] <olsonjeffery> i imagined we could shoehorn the native stuff into using the std::rt::io traits
[19:16:43] <acrichto> it certainly should be doing so
[19:16:48] <olsonjeffery> but even that seems a bridge-too-far
[19:17:09] <acrichto> it's not a high priority I think, but it would be cool to have
[19:17:29] <acrichto> std::io should duplex silently among event loop or native implementations depending on what's available
[19:17:56] <olsonjeffery> too much magic. i come from the world of .net where we hand-wave that away with an IoC container, for the most part
[19:18:21] <acrichto> how so?
[19:18:23] <olsonjeffery> im all for dependency injection.. kinda tried it with the original global_event_loop impl. it was hideous and users hated it.
[19:19:00] <olsonjeffery> well all of your "services" are spelled out at interfaces with a single impl.. services take deps on each other via taking an inst of the interface in the ctor
[19:19:27] <olsonjeffery> and, when the app starts, you reflect over all of the loaded assemblies and load all of the service impls into the container
[19:19:35] <olsonjeffery> and then you just say to the container "give me an IFooService"
[19:19:49] <olsonjeffery> and it resolves all of the deps and news up the object graph and gives it to you
[19:20:22] <olsonjeffery> and in difference application contexts (like backend svc vs frontend web app) you have differing impls of key services (for things like cache/session mgmt, user lookup, etc)
[19:20:29] <olsonjeffery> so thats how you handle different platform/envs
[19:20:39] <acrichto> the logic that I was thinking of would be to query the local event loop for a factory, and if that doesn't exist fall back to the native impl
[19:20:56] <acrichto> there's already a trait object boundary to implement the abstraction, so the interface doesn't change at all
[19:21:17] <olsonjeffery> i think the EventLoop should rightly be the source for everything
[19:21:32] <olsonjeffery> id love the eventloop to be an arg to main() and use it tocreate schedulers
[19:21:39] <olsonjeffery> but thats pretty hardcore for your hello world use case
[19:21:52] <olsonjeffery> or an EventLoopFactory, i should say
[19:22:01] <olsonjeffery> with different impls for various event loop strategies
[19:22:11] <olsonjeffery> since you need one per thread (once again: a libuv'ism)
[19:22:27] <acrichto> that's what we currently hae
[19:22:27] <olsonjeffery> but what we have works. more or less
[19:22:38] <acrichto> there's an event_loop_factory lang item
[19:22:44] <acrichto> and the instance of that is shoved into the crate map
[19:22:50] <olsonjeffery> yeah
[19:22:52] <acrichto> so you can define that to be whatever you want
[19:22:59] <olsonjeffery> so maybe some compiler tooling or CTFE
[19:23:07] <acrichto> it's true that we dictate that you must have one per thread
[19:23:31] <cmr> What is the crate map exactly?
[19:23:47] <olsonjeffery> its written in crayon, currently
[19:24:04] <acrichto> cmr: it's a structure emitted to all executables which is a global value that describes the crate
[19:24:17] <acrichto> the standard library weakly links against it to resolve it at runtime
[19:24:31] <acrichto> and it has stuff like metadata for the logging macros, and now an I/O loop factory
[19:27:46] *** Quits: erickt (etryzelaar@BF60BF52.64BC77A3.7FC6A66E.IP) (Ping timeout)
[19:30:56] *** Joins: steveklabnik (steveklabn@moz-679CA643.public.wayport.net)
[19:33:26] <brson> acrichto olsonjeffery: I'm actually not convinced at this point of the value of creating a GLFW event loop, etc. The way servo integrates with GLFW it just puts a task on main, then calls into the GLFW event loop, blocking the scheduler event loop, and this is working fine
[19:33:54] <brson> if we put GLFW into the scheduler event loop then there a bunch of hard questions about how to *actually* use it for non-scheduler things from within the main task
[19:34:16] <brson> same seems to be true for gtk, win32, etc.
[19:34:31] <brson> still worth pursuing though
[19:46:15] *** Quits: StarLight (StarLight@moz-5848D83A.dynamic.avangarddsl.ru) (Ping timeout)
[19:49:11] <lbergstrom> brson: currently we still poll_events(), sleep for a short time, and then check for available messages from other tasks that want us to perform some actions:
[19:49:12] <lbergstrom> https://github.com/mozilla/servo/blob/master/src/components/main/compositing/run.rs#L377-L388
[19:49:36] *** Joins: jensnockert (jensnocker@moz-7DC16A5F.afb.bredband2.com)
[19:49:55] <lbergstrom> I have some pending changes that would let us block in glfw, but we still need that thread to be able to wake up from other events (e.g., a received msg) so that we can perform non-windowing system event actions on that thread.
[19:50:29] <lbergstrom> The pending changes are a bit of a hack, though, as they tweak glfw to have an interrupt() call, which basically sends a WM_USER message on window, null message on OSX, fake message to a fake window on X, etc.
[19:51:09] *** Quits: jensnockert (jensnocker@moz-7DC16A5F.afb.bredband2.com) (Input/output error)
[20:02:13] *** Quits: eddyb (eddy@A93A03C9.9065A63B.FCAAE698.IP) (Ping timeout)
[20:04:05] *** Joins: onr99 (onur@DBB90BD8.70012127.53438D71.IP)
[20:04:52] *** Quits: tjc (tjc@moz-BBE3ABD.mv.mozilla.com) (Quit: zzzzzzzzzz)
[20:07:13] *** Quits: onr99 (onur@DBB90BD8.70012127.53438D71.IP) (Quit: Leaving)
[20:08:03] *** Joins: onr99 (onur@DBB90BD8.70012127.53438D71.IP)
[20:16:44] *** Joins: strcat (strcat@moz-54F7FD49.cpe.net.cable.rogers.com)
[20:26:00] *** Quits: tikue_ (tikue_star@9746E5A.EB08480C.689607DE.IP) (Ping timeout)
[20:28:40] *** Joins: tikue_ (tikue_star@9746E5A.EB08480C.689607DE.IP)
[20:31:14] <bstrie> pcwalton: the meeting notes are a bit vague, are you still proposing to switch the sigil for owned pointers from ~ to *?
[20:32:08] *** Quits: tikue_ (tikue_star@9746E5A.EB08480C.689607DE.IP) (Client exited)
[20:32:15] *** Joins: ghrust (ghrust@79968228.6A2AE50.F3114085.IP)
[20:32:15] <ghrust> 01[13rust01] 15bors merged 06auto into 06master: 02http://git.io/WXdHPg
[20:32:15] *** Parts: ghrust (ghrust@79968228.6A2AE50.F3114085.IP) ()
[20:35:36] <strcat> nmatsakis: did you see https://github.com/mozilla/rust/pull/10144 ? I'm wondering if you think that approach is okay
[20:35:49] <strcat> (I decided it really needs to split into one for each kind though)
[20:36:00] <nmatsakis> strcat: yes I saw it, I started writing some comments, but then I never finished
[20:36:27] *** Joins: erickt (etryzelaar@93E94B80.D1E9439C.98A37E8C.IP)
[20:37:07] *** Joins: ghrust (ghrust@DE823A67.6A2AE50.F3114085.IP)
[20:37:07] <ghrust> 01[13rust01] 15bors pushed 0 new commits to 06auto: 02http://git.io/42N8xQ
[20:37:07] *** Parts: ghrust (ghrust@DE823A67.6A2AE50.F3114085.IP) ()
[20:37:12] *** Joins: ghrust (ghrust@1E8607E8.6A2AE50.F3114085.IP)
[20:37:13] <ghrust> 01[13rust01] 15bors pushed 2 new commits to 06auto: 02http://git.io/23XgFA
[20:37:13] <ghrust> 13rust/06auto 14e6fa2d0 15Brian Anderson: std: Move the SendDeferred trait to std::comm
[20:37:13] <ghrust> 13rust/06auto 14886819c 15bors: auto merge of #10140 : brson/rust/comm, r=alexcrichton...
[20:37:13] *** Parts: ghrust (ghrust@1E8607E8.6A2AE50.F3114085.IP) ()
[20:42:41] <nmatsakis> strcat: https://github.com/mozilla/rust/pull/10144#issuecomment-27341497
[20:43:50] <strcat> nmatsakis: I think I'll call them SendMimic/FreezeMimic
[20:44:31] <strcat> it's wrong to glue them into one because the type might always be Freeze even if the stored type isn't (although I can't think of a good example)
[20:44:32] <nmatsakis> strcat: meaning "not sendable if T is not sendable"?
[20:44:35] <strcat> yes
[20:44:42] <nmatsakis> strcat: not very future proof that way
[20:44:59] <nmatsakis> strcat: if we add more builtin bounds in the future, you'd have to add new Mimics
[20:45:01] <strcat> yeah, if we add new traits like this
[20:45:08] <strcat> nmatsakis: it likely makes no sense for Sized though
[20:45:29] <strcat> maybe better to not split it
[20:45:40] <nmatsakis> strcat: I'd prefer something like Indirect<T> that inherits the types from T that are appropriate for an (non-owned) indirection
[20:46:08] <nmatsakis> strcat: er, inherits the builtin bounds. obviously need to find a goo dname.
[20:46:12] <strcat> do you think they would be different for owned vs non-owned?
[20:46:21] <nmatsakis> yes, very different
[20:46:51] <nmatsakis> strcat: have to run to catch train, but check out https://github.com/nikomatsakis/rust/commit/89244499091aa5758e993985d5abcc5f1c5ecdce#diff-0f85fcb07fb739876892e633fa0e2be6R1885
[20:47:14] <nmatsakis> strcat: that's my refactoring of TypedContents, it breaks down the properties we track, you can see that some of them only matter if they are owned, the rest matter if they are reachable
[20:47:20] <strcat> ah
[20:50:57] *** Quits: erickt (etryzelaar@93E94B80.D1E9439C.98A37E8C.IP) (Ping timeout)
[21:00:22] <strcat> nmatsakis: maybe we *should* just bubble up the indirect ones through raw ptrs, and just have #[unsafe_send]/#[unsafe_freeze] as overrides
[21:08:03] <pcwalton> bstrie: yes
[21:11:29] <brson> lbergstrom: I believe that change to glfw will be necessary even if glfw implements the rust event loop
[21:15:38] *** Joins: tjc (tjc@moz-BBE3ABD.mv.mozilla.com)
[21:15:38] *** ChanServ sets mode: +o tjc
[21:25:07] *** Joins: dbaupp (Thunderbir@moz-B3C9E9E8.lns20.syd6.internode.on.net)
[21:27:32] <dbaupp> strcat: doesn't that stop * being sendable in the general case? (e.g. precluding writing a (safe) fork-join library using unsafe code?)
[21:28:06] <strcat> dbaupp: yes but you could work around it, *shrug*
[21:28:21] <strcat> custom smart pointers are going to be common
[21:28:40] <strcat> I don't think fork-join libraries will be, and it's already hard to get that right
[21:28:42] <dbaupp> strcat: I guess we could have `#[unsafe_send] struct SendRaw<T> { x: *T }` or whatever, yeah.
[21:38:26] *** Joins: pnkfelix (pnkfelix@moz-43495417.fbx.proxad.net)
[21:38:26] *** ChanServ sets mode: +o pnkfelix
[21:40:11] <bstrie> pcwalton: if so, I really hope that you also change the sigil for unsafe pointers away from *. and also the symbol for dereferencing, since one of the things that rust did right was not make me parse context to know whether a * is a dereference or a pointer
[21:40:31] <pcwalton> I don't think we would change the syntax for dereference
[21:40:43] <bstrie> well then I object to the change from ~ to * :)
[21:41:13] <bstrie> I really don't like the confused situation of * in C
[21:41:19] <kimundi> wait, change ~ to * ?
[21:42:08] * kimundi thinks ~ is much easier on the eyes
[21:44:08] <bstrie> btw, another one of the things that rust did right was to not have two "not" operators, so I also object to ~ being repurposed for bitwise negation :P
[21:45:46] <bstrie> I'm also not convinced that switching from ~ to * for the sake of familiarity will actually win you anything, since the difficulties around owned pointers have always been their semantics, not their syntax
[21:46:03] <bstrie> having something different there visually helps to emphasize that this isn't "just" a pointer
[21:46:25] <bstrie> but then again it's a bit different from C++ smart pointers, so I dunno
[21:48:06] *** Quits: steveklabnik (steveklabn@moz-679CA643.public.wayport.net) (Ping timeout)
[21:55:49] *** Quits: onr99 (onur@DBB90BD8.70012127.53438D71.IP) (Ping timeout)
[22:01:09] *** Quits: geoffhill (geoffhill@moz-244CF33A.amazon.com) (Ping timeout)
[22:03:54] *** Joins: geoffhill (geoffhill@moz-79C8D45C.amazon.com)
[22:06:32] *** Joins: ghrust (ghrust@24260B07.6A2AE50.F3114085.IP)
[22:06:32] <ghrust> 01[13rust01] 15bors merged 06auto into 06master: 02http://git.io/23XgFA
[22:06:32] *** Parts: ghrust (ghrust@24260B07.6A2AE50.F3114085.IP) ()
[22:11:31] *** Joins: ghrust (ghrust@2EE61FCC.6A2AE50.F3114085.IP)
[22:11:31] <ghrust> 01[13rust01] 15bors pushed 0 new commits to 06auto: 02http://git.io/uhgjZg
[22:11:31] *** Parts: ghrust (ghrust@2EE61FCC.6A2AE50.F3114085.IP) ()
[22:11:36] *** Joins: ghrust (ghrust@2EE61FCC.6A2AE50.F3114085.IP)
[22:11:36] <ghrust> 01[13rust01] 15bors pushed 7 new commits to 06auto: 02http://git.io/SSWavg
[22:11:36] <ghrust> 13rust/06auto 1483cdae6 15reedlepee: Replaced empty destructors with NonCopyable #7427...
[22:11:36] <ghrust> 13rust/06auto 14b7e9b0c 15reedlepee: Added the comment #7427
[22:11:36] <ghrust> 13rust/06auto 146e07377 15reedlepee: Changed name to non_copyable #7427
[22:11:38] *** Parts: ghrust (ghrust@2EE61FCC.6A2AE50.F3114085.IP) ()
[22:11:57] <dbaupp> acrichto: "15 additions, 7000 deletions" nice
[22:12:15] <acrichto> dbaupp: it's sad though b/c the previous one had 7k additions :(
[22:12:25] <Luqman> yay OOM'd building rust on an arm board :P
[22:12:40] <dbaupp> acrichto: ssssh, we live in the present
[22:15:35] <Luqman> but arm chroot seems to be working
[22:20:11] <acrichto> olsonjeffery: how attached are you to having specific readers/writers of files?
[22:20:23] <acrichto> it seems like it's an extra layer of abstraction which isn't all that useful
[22:20:55] <acrichto> or rather if you want to enforce to code that it can only write you should use it as a Writer trait object
[22:22:58] <pnkfelix> Luqman: how much memory does the board have ?
[22:23:32] <Luqman> pnkfelix: 128mb so i was expecting it to fail :P
[22:23:51] <McPherrin> wait goto80 has that little ram? roflcopters
[22:24:01] <pnkfelix> Luqman: yeah we'll need to do something about our mem usage before you can pull that off .....
[22:24:19] <Luqman> McPherrin: binaerpilot has 512! :)
[22:24:43] <Luqman> pnkfelix: yea, i mostly just wanted to make sure the snapshot i made unpacked properly
[22:24:55] <McPherrin> Luqman: Yeah.  When I get home I'll turn my binaerpilot equivalent on and you can use that
[22:25:06] <McPherrin> (it is set up to use CSC kerberos)
[22:25:28] <Luqman> McPherrin: i just set up an arm chroot on hfcs, make -j64 here i come :P
[22:26:13] <McPherrin> Luqman: sweet
[22:26:45] *** Joins: yghannam (yghannam@moz-C5BCCF4E.lightspeed.austtx.sbcglobal.net)
[22:29:23] *** Quits: yghannam (yghannam@moz-C5BCCF4E.lightspeed.austtx.sbcglobal.net) (Ping timeout)
[22:37:18] *** Quits: jdm (jdm@13F2CEC5.7672369.D8E68FF6.IP) (Quit: Lost terminal)
[22:53:52] *** Quits: pnkfelix (pnkfelix@moz-43495417.fbx.proxad.net) (Quit: Leaving.)
[23:16:28] *** Joins: ghrust (ghrust@C8693FCB.6A2AE50.F3114085.IP)
[23:16:28] <ghrust> 01[13rust01] 15bors merged 06auto into 06master: 02http://git.io/SSWavg
[23:16:28] *** Parts: ghrust (ghrust@C8693FCB.6A2AE50.F3114085.IP) ()
[23:18:44] *** Quits: brson (brson@moz-BBE3ABD.mv.mozilla.com) (Ping timeout)
[23:18:46] *** Joins: brson (brson@moz-BBE3ABD.mv.mozilla.com)
[23:18:46] *** ChanServ sets mode: +qo brson brson
[23:21:34] *** Joins: ghrust (ghrust@79968228.6A2AE50.F3114085.IP)
[23:21:34] <ghrust> 01[13rust01] 15bors pushed 0 new commits to 06auto: 02http://git.io/VFxvbQ
[23:21:34] *** Parts: ghrust (ghrust@79968228.6A2AE50.F3114085.IP) ()
[23:23:09] *** Joins: ghrust (ghrust@1E8607E8.6A2AE50.F3114085.IP)
[23:23:09] <ghrust> 01[13rust01] 15brson pushed 3 new commits to 06try: 02http://git.io/QZ4WnQ
[23:23:09] <ghrust> 13rust/06try 148a593a8 15Heather: support for GNU configure syntax
[23:23:09] <ghrust> 13rust/06try 141c4a348 15Heather: Correct prefix / CFG_PREFIX work in configure / install.mk
[23:23:10] <ghrust> 13rust/06try 14b9504f9 15Heather: support for GNU configure syntax corrections: patch from brson
[23:23:12] *** Parts: ghrust (ghrust@1E8607E8.6A2AE50.F3114085.IP) ()
[23:26:08] <McPherrin> Luqman: Or I suppose this was the channel being discussed in
[23:26:26] *** Joins: ghrust (ghrust@1E8607E8.6A2AE50.F3114085.IP)
[23:26:26] <ghrust> 01[13rust01] 15bors pushed 0 new commits to 06auto: 02http://git.io/VFxvbQ
[23:26:26] *** Parts: ghrust (ghrust@1E8607E8.6A2AE50.F3114085.IP) ()
[23:26:30] *** Joins: ghrust (ghrust@79968228.6A2AE50.F3114085.IP)
[23:26:30] <ghrust> 01[13rust01] 15bors pushed 2 new commits to 06auto: 02http://git.io/AK1K2g
[23:26:30] <ghrust> 13rust/06auto 144ca32e1 15Guillaume Pinot: rewrite shootout-binarytrees.rs to match shootout directives...
[23:26:30] <ghrust> 13rust/06auto 14c7853c9 15bors: auto merge of #10145 : TeXitoi/rust/issues-2913, r=bstrie...
[23:26:31] *** Parts: ghrust (ghrust@79968228.6A2AE50.F3114085.IP) ()
[23:27:20] <Luqman> McPherrin: well, i built my stage0 rustc on debian testing but hfcs is on wheezy so got bit by that :/
[23:27:25] <Luqman> but it did get through llvm
[23:47:27] *** Quits: brson (brson@moz-BBE3ABD.mv.mozilla.com) (Ping timeout)
[23:47:54] *** lbergstrom is now known as lbergstrom|away
[23:50:50] *** Joins: brson (brson@moz-BBE3ABD.mv.mozilla.com)
[23:50:50] *** ChanServ sets mode: +qo brson brson
[23:50:57] *** Quits: tjc (tjc@moz-BBE3ABD.mv.mozilla.com) (Quit: Places to go, people to annoy)
[23:55:59] *** Joins: tikue_ (tikue_star@9746E5A.EB08480C.689607DE.IP)
